# 题目信息

# 「MXOI Round 2」队列

## 题目描述

小 C 有一个队列，他要对这个队列进行 $q$ 次操作。操作共四种，参数分别如下：

$1\ x$：这是第一种操作，表示从队尾依次插入 $1,2,3,\cdots,x$；

$2\ y$：这是第二种操作，表示弹出队头的前 $y$ 个元素；

$3\ z$：这是第三种操作，表示查询队列中的第 $z$ 个元素；

$4$：这是第四种操作，表示查询队列中所有元素的最大值。

你需要帮助他维护这个队列，并对于每个第三种操作和第四种操作，输出查询的答案。

## 说明/提示

#### 【样例解释 #1】

在进行第四次操作后，队列中的元素依次为 $3,4,5,1,2,3,1,2,3,4$。

在进行第七次操作后，队列中的元素依次为 $2,3,1,2,3,4$。

#### 【样例 #2】

见附加文件中的 `queue/queue2.in` 与 `queue/queue2.ans`。

该样例满足测试点 $1$ 的限制。

#### 【样例 #3】

见附加文件中的 `queue/queue3.in` 与 `queue/queue3.ans`。

该样例满足测试点 $4$ 的限制。

#### 【样例 #4】

见附加文件中的 `queue/queue4.in` 与 `queue/queue4.ans`。

该样例满足测试点 $11$ 的限制。

#### 【样例 #5】

见附加文件中的 `queue/queue5.in` 与 `queue/queue5.ans`。

该样例满足测试点 $15$ 的限制。

#### 【样例 #6】

见附加文件中的 `queue/queue6.in` 与 `queue/queue6.ans`。

该样例满足测试点 $20$ 的限制。

#### 【数据范围】

设 $\sum x$ 表示单个测试点内 $x$ 之和。

对于 $100\%$ 的数据，$1 \le q \le 2\times 10^5$，$1 \le x,y,z \le 10^9$，$0 \le \sum x \le 2\times10^{14}$，保证在进行第二种操作前队列内元素个数不小于 $y$，在进行第三种操作前队列内元素个数不小于 $z$，在进行第四种操作前队列内元素个数大于 $0$。

|测试点编号|$q \le$|$x \le$|$\sum x \le$|特殊性质|
|:---:|:---:|:---:|:---:|:---:|
|$1\sim3$|$500$|$500$|$2\times10^5$|C|
|$4\sim8$|$5000$|$5000$|$2\times10^7$|无|
|$9\sim10$|$2\times10^5$|$10^9$|$2\times10^{14}$|AB|
|$11\sim12$|$2\times10^5$|$10^9$|$2\times10^{14}$|B|
|$13\sim14$|$2\times10^5$|$10^9$|$2\times10^9$|AC|
|$15\sim16$|$2\times10^5$|$10^9$|$2\times10^9$|C|
|$17\sim18$|$2\times10^5$|$500$|$2\times10^7$|无|
|$19$|$2\times10^5$|$10^9$|$2\times10^9$|无|
|$20$|$2\times10^5$|$10^9$|$2\times10^{14}$|无|

特殊性质 A：没有第二种操作。

特殊性质 B：没有第三种操作。

特殊性质 C：没有第四种操作。

## 样例 #1

### 输入

```
0 9
1 5
1 3
2 2
1 4
3 6
3 8
2 4
4
3 3```

### 输出

```
3
2
4
1```

# AI分析结果

### 综合分析

题目要求维护一个队列，支持插入、删除、查询第k个元素和查询最大值四种操作。由于数据范围较大（$x, y, z \le 10^9$），直接模拟队列操作会导致超时。因此，大多数题解采用了**分组维护**的策略，将连续的插入操作视为一个“块”，并通过**前缀和**、**二分查找**、**单调队列**等数据结构来优化查询和删除操作。

### 关键思路与技巧

1. **分组维护**：将连续的插入操作视为一个“块”，记录每个块的起始和结束值，以及块的长度。这样可以避免直接处理大量数据。
2. **前缀和与二分查找**：通过维护每个块的前缀和，使用二分查找快速定位第k个元素所在的块，从而优化查询操作。
3. **单调队列与优先队列**：用于维护当前队列中的最大值，确保在删除操作后仍能快速获取最大值。
4. **懒删除**：通过记录删除的总量，而不是实际删除元素，减少操作复杂度。

### 推荐题解

#### 1. 作者：Crosser (赞：35)  
**星级：5星**  
**关键亮点**：  
- 使用`multiset`维护最大值，结合前缀和与二分查找，实现高效的查询和删除操作。
- 代码结构清晰，逻辑简洁，易于理解。

**核心代码**：
```cpp
void push(int w) { 
    a[++n] = w;
    s[n] = s[n - 1] + w;
    ms.insert(w);
}
```
**实现思想**：通过维护前缀和数组`s`和`multiset`，快速处理插入、删除和查询操作。

#### 2. 作者：Coffee_zzz (赞：19)  
**星级：4星**  
**关键亮点**：  
- 针对不同数据范围提出不同的优化策略，特别是针对大规模数据的处理。
- 使用`multiset`维护最大值，结合前缀和与二分查找，确保查询和删除操作的高效性。

**核心代码**：
```cpp
int kth(int x) {
    x += del;
    int l = 1, r = tot, ans = 0;
    while (l <= r) {
        if (s[mid] < x) ans = mid, l = mid + 1;
        else r = mid - 1;
    }
    x -= s[ans];
    return x;
}
```
**实现思想**：通过维护前缀和数组`s`和`multiset`，快速处理插入、删除和查询操作。

#### 3. 作者：Milthm (赞：10)  
**星级：4星**  
**关键亮点**：  
- 使用线段树维护最大值，结合前缀和与二分查找，确保查询和删除操作的高效性。
- 代码结构清晰，逻辑简洁，易于理解。

**核心代码**：
```cpp
void update(int x, int l, int r, int ql, int qr, int k) {
    if (ql <= l && r <= qr) {
        a[x] = k; return;
    }
    int mid = (l + r) >> 1;
    if (ql <= mid) update(x * 2, l, mid, ql, qr, k);
    if (qr > mid) update(x * 2 + 1, mid + 1, r, ql, qr, k);
    a[x] = max(a[x * 2], a[x * 2 + 1]);
}
```
**实现思想**：通过线段树维护最大值，结合前缀和与二分查找，快速处理插入、删除和查询操作。

### 通用建议与扩展思路

1. **数据结构的选择**：在处理大规模数据时，选择合适的数据结构（如`multiset`、线段树、单调队列等）可以显著提高算法效率。
2. **前缀和与二分查找**：在处理区间查询问题时，前缀和与二分查找是常用的优化手段，能够将时间复杂度从$O(n)$降低到$O(\log n)$。
3. **懒删除策略**：通过记录删除的总量，而不是实际删除元素，可以减少操作复杂度，适用于频繁删除的场景。

### 推荐题目

1. [P7870 - 队列](https://www.luogu.com.cn/problem/P7870)
2. [P1886 - 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3374 - 树状数组 1](https://www.luogu.com.cn/problem/P3374)

### 个人心得

- **调试经历**：在处理大规模数据时，直接模拟操作会导致超时，因此需要优化数据结构的选择和算法的实现。
- **踩坑教训**：在处理删除操作时，直接删除元素会导致时间复杂度过高，采用懒删除策略可以显著提高效率。
- **顿悟感想**：通过分组维护和前缀和的结合，可以高效处理区间查询问题，减少时间复杂度。

---
处理用时：38.89秒
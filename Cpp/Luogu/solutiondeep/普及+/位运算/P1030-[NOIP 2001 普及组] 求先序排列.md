# 题目信息

# [NOIP 2001 普及组] 求先序排列

## 题目描述

给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \le 8$）。


## 说明/提示

**【题目来源】**

NOIP 2001 普及组第三题

## 样例 #1

### 输入

```
BADC
BDCA
```

### 输出

```
ABCD
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕通过二叉树的中序和后序排列求先序排列展开，大部分题解采用递归思路。其核心思路基于后序遍历最后一个节点是根节点，在中序遍历中找到该根节点，从而划分出左右子树，再递归处理子树。各题解在思路清晰度、代码可读性、优化程度上存在差异。

### 所选的题解
- **作者：sunyufei (5星)**
    - **关键亮点**：思路清晰，先阐述基本常识，再以示例详细说明解题方法，总结出通用模板，代码简洁明了，直接利用字符串函数实现递归求解。
    - **重点代码**：
```cpp
void beford(string in,string after){
    if (in.size()>0){
        char ch=after[after.size()-1];
        cout<<ch;
        int k=in.find(ch);
        beford(in.substr(0,k),after.substr(0,k));
        beford(in.substr(k+1),after.substr(k,in.size()-k-1));
    }
}
```
    - **核心实现思想**：函数`beford`接收中序和后序字符串，每次取后序字符串最后一个字符为根并输出，通过`find`函数在中序字符串中找到根的位置，将中序和后序字符串按此位置分割为左右子树，递归调用自身处理子树。

- **作者：NeosKnight (4星)**
    - **关键亮点**：详细分析解题要点，尤其对如何通过中序和后序遍历确定子树的后序遍历序列进行深入探讨，代码注释详细，使用数组和自定义函数实现递归。
    - **重点代码**：
```cpp
inline int find(char ch)
{
    for(int i=0;i<len;i++)
    {
        if(s1[i]==ch) return i;
    }
}
void dfs(int l1,int r1,int l2,int r2)
{
    int m=find(s2[r2]);
    cout<<s2[r2];
    if(m>l1) dfs(l1,m-1,l2,r2-r1+m-1);
    if(m<r1) dfs(m+1,r1,l2+m-l1,r2-1);
}
```
    - **核心实现思想**：`find`函数用于查找字符在中序数组中的位置。`dfs`函数通过递归，每次确定当前子树的根并输出，根据根在中序数组中的位置，计算左右子树在中序和后序数组中的范围，递归处理左右子树。

- **作者：UNDERTALE_RS (4星)**
    - **关键亮点**：不仅给出递归解法，还详细介绍二叉树遍历的前置知识，对初学者友好。代码结构清晰，分建树和输出先序序列两部分，便于理解。
    - **重点代码**：
```cpp
int buildTree(string InOd,string PostOd){
    int len = InOd.size();
    if(len == 0) return 0;
    
    char c = PostOd[len-1];
    int root = ++pos;
    tree[root].val = c;
    
    int k = InOd.find(c); 
    
    tree[root].l = buildTree(InOd.substr(0,k),PostOd.substr(0,k));
    tree[root].r = buildTree(InOd.substr(k+1),PostOd.substr(k,len-k-1)); 
    return root;
}

void printPreOd(int root){
    cout << tree[root].val; 
    if(tree[root].l) printPreOd(tree[root].l); 
    if(tree[root].r) printPreOd(tree[root].r); 
}
```
    - **核心实现思想**：`buildTree`函数递归建树，每次确定根节点并存储，通过`find`函数找到根在中序字符串中的位置，划分左右子树并递归构建子树。`printPreOd`函数按先序遍历输出树节点。

### 最优关键思路或技巧
利用后序遍历确定根节点，结合中序遍历划分左右子树，通过递归方式处理每棵子树，是解决此类问题的关键思路。在代码实现上，合理使用字符串的查找和截取函数（如`find`、`substr`）能简化操作。

### 可拓展思路
同类型题常涉及通过不同遍历序列确定二叉树结构或求其他遍历序列。类似算法套路是依据不同遍历的特点，找到关键节点（如后序的根节点），划分结构，递归求解。

### 相似知识点洛谷题目
1. [P1827 [USACO3.4]美国血统 American Heritage](https://www.luogu.com.cn/problem/P1827)
2. [P2006 赵神牛的游戏](https://www.luogu.com.cn/problem/P2006)
3. [P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617)

### 个人心得摘录与总结
部分作者提到模拟过程中寻找规律的重要性，如NeosKnight通过模拟发现确定子树后序遍历序列的套路。还有作者强调对二叉树遍历概念的理解是解题基础，UNDERTALE_RS详细介绍遍历知识辅助理解题目。 

---
处理用时：35.96秒
# 题目信息

# [NOIP 2006 提高组] 作业调度方案

## 题目描述

我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。

每个工件的每个工序称为一个操作，我们用记号 `j-k` 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 `2-4` 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。

例如，当 $n=3,m=2$ 时，`1-1,1-2,2-1,3-1,3-2,2-2` 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。

一方面，每个操作的安排都要满足以下的两个约束条件。

1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；

2. 同一时刻每一台机器至多只能加工一个工件。

另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。

由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 `1 1 2 3 3 2`。

还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。

例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：


工件号 |工序 1 | 工序 2
-|-|-
$1$  |  $1/3$  |  $2/2$
$2$  |  $1/2$  |  $2/5$
$3$  |  $2/2$  |  $1/4$

则对于安排顺序 `1 1 2 3 3 2`，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。

方案 1，用时 $10$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | `3-1` | `3-1` |  无   | `1-2` | `1-2` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

方案 2，用时 $12$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12  |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` |   无   |  无   | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | 无 | 无 |  无   | `1-2` | `1-2` | `3-1` | `3-1` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件 $(1.)(2.)$ 的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件 $(1.)(2.)$ 的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。

显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。


## 说明/提示

NOIP 2006 提高组 第三题


## 样例 #1

### 输入

```
2 3
1 1 2 3 3 2
1 2 
1 2 
2 1
3 2 
2 5 
2 4
```

### 输出

```
10```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解均采用模拟的思路，按照给定的工序顺序，依据“同一工件工序顺序执行、同一时刻每台机器至多加工一个工件且尽量靠前插入空档”的规则，在时间线上安排各工件的工序，最后找出所有工件完成时间的最大值作为总时间。
    - 算法要点：通过数组存储工件工序的机器号、加工时间、工序安排顺序等信息；利用辅助数组记录每个工件当前工序、上一工序完成时间以及每台机器每个时间点的使用状态；按顺序遍历工序安排，为每个工序在时间线上寻找合适空档。
    - 解决难点：理解复杂的题目约束条件，并准确转化为代码逻辑；合理设计数据结构来清晰存储和管理各种状态信息；处理好时间线的扫描和工序插入的逻辑。
    - 整体来看，各题解思路相近，主要差异在于代码实现的细节、变量命名和代码结构。部分题解在思路清晰度和代码可读性上表现更优。

  - 作者：brealid (5星)
    - 关键亮点：思路清晰，代码简洁明了，变量命名直观易懂。通过详细注释和提供福利数据及解释，帮助读者理解题目和代码。
    - 个人心得：无
    - 核心代码片段：
```cpp
for (int i = 1; i <= m * n; i++) {
    int now = list[i];
    step[now]++;
    int id = a[now][step[now]].id, cost = a[now][step[now]].cost;
    int s = 0;
    for (int j = las_time[now] + 1; ; j++) {
        if (mac[id][j] == 0) {
            s++;
        } else {
            s = 0;
        }
        if (s == cost) {
            for (int k = j - cost + 1; k <= j; k++) {
                mac[id][k] = 1;
            }
            if (j > ans) ans = j;
            las_time[now] = j;
            break;
        }
    }
}
```
    - 核心实现思想：遍历工序安排顺序，对每个工序，从当前工件上一工序完成时间的下一个时刻开始扫描时间线，统计机器空闲时间，当空闲时间达到工序所需时间时，标记该时间段机器被占用，更新工件上一工序完成时间和总时间。

  - 作者：ShawnZhou (4星)
    - 关键亮点：对题意分析详细，通过将机器类比为“时间线”，形象地阐述了模拟思路。代码结构清晰，使用函数封装判断时间线空档的逻辑，提高了代码可读性。
    - 个人心得：强调理解题意的重要性，建议画图研究样例，同时提到长模拟代码变量多易混淆，应避免使用单字母或双字母命名变量。
    - 核心代码片段：
```cpp
bool check_in_line(int begin_time_point,int end_time_length,int workid){
    for (int time = begin_time_point; time <= end_time_length;time++)
        if (timeline[workid][time])
            return false;
    return true;    
}

for (int i=1;i<=n*m;i++){
    int nowitem = worklist[i];
    cnt_now_work_step[nowitem]++;
    int nownumber = worknumber[nowitem][cnt_now_work_step[nowitem]];
    int costtime = worktime[nowitem][cnt_now_work_step[nowitem]];
    
    for (int time = lasttime[nowitem]+1;;time++)
        if (check_in_line(time,time+costtime-1,nownumber)){
            for (int marktime = time;marktime <= time+costtime-1;marktime++)
                timeline[nownumber][marktime] = true;
            lasttime[nowitem] = time + costtime - 1;
            break;
        }
}
```
    - 核心实现思想：遍历工序安排，对每个工序，从当前工件上一工序完成时间的下一个时刻开始扫描时间线，调用函数判断该时间段机器是否空闲，若空闲则标记该时间段机器被占用，更新工件上一工序完成时间。

  - 作者：翠竹叶飞 (4星)
    - 关键亮点：对题意理解准确，简洁明了地总结出解题要点。代码逻辑清晰，变量命名有一定表意性，在关键逻辑处有注释说明。
    - 个人心得：强调理解题意的重要性，指出题目难在理解题面。
    - 核心代码片段：
```cpp
for (i=1; i<=m*n; i++) {
    cnt[a[i]]++;
    int tmp1=a[i],tmp2=cnt[tmp1]; 
    int tmpm=mord[tmp1][tmp2]; 
    for (j=last_[tmp1];;j++) {
        bool flag = 1;
        for (k=j+1; k<=j+t[tmp1][tmp2]; k++)
            if (rec[tmpm][k]) { 
                flag = 0;
                break;
            }
        if (flag) {
            for (k=j+1; k<=j+t[tmp1][tmp2]; k++)
                rec[tmpm][k] = 1; 
            last_[tmp1] = max(last_[tmp1],j+t[tmp1][tmp2]);
            ans = max(ans,last_[tmp1]); 
            break;
        }
    }
}
```
    - 核心实现思想：遍历工序安排，对每个工序，从当前工件上一工序完成时间的下一个时刻开始扫描时间线，检查该时间段机器是否空闲，若空闲则标记该时间段机器被占用，更新工件上一工序完成时间和总时间。

• 最优关键思路或技巧：
    - 数据结构方面，使用二维数组存储每个工件各工序的机器号和加工时间，一维数组存储工序安排顺序，以及使用辅助数组记录工件和机器状态，这种设计使数据管理清晰。
    - 代码实现上，按工序安排顺序依次处理，通过扫描时间线寻找合适空档插入工序，在扫描过程中巧妙统计空闲时间，当满足工序时间要求时进行相应处理，逻辑简洁高效。

• 可拓展之处：
    - 同类型题通常围绕任务调度、资源分配等场景，具有复杂的约束条件，需要模拟实际操作过程。类似算法套路是仔细分析题目约束，设计合适的数据结构存储状态，按一定顺序模拟操作并更新状态。

• 推荐洛谷题目：
    - P1241 括号序列
    - P1048 采药
    - P1002 过河卒 

---
处理用时：33.19秒
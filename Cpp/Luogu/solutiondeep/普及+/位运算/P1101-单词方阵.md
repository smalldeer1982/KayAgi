# 题目信息

# 单词方阵

## 题目描述

给一 $n \times n$ 的字母方阵，内可能蕴含多个 `yizhong` 单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 $8$ 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉，因此有可能共用字母。输出时，将不是单词的字母用 `*` 代替，以突出显示单词。

## 样例 #1

### 输入

```
7
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
```

### 输出

```
*******
*******
*******
*******
*******
*******
*******
```

## 样例 #2

### 输入

```
8
qyizhong
gydthkjy
nwidghji
orbzsfgz
hhgrhwth
zzzzzozo
iwdfrgng
yyyygggg```

### 输出

```
*yizhong
gy******
n*i*****
o**z****
h***h***
z****o**
i*****n*
y******g```

# AI分析结果

这些题解主要围绕在 $n \times n$ 的字母方阵中寻找单词“yizhong”并突出显示的问题，大多采用深度优先搜索（DFS）算法，部分使用暴力枚举。以下是对各题解的综合分析：
1. **思路**：多数题解先寻找字母“y”，再从“y”的位置出发，向8个方向搜索“izhong”以确定单词位置。部分题解通过记录“y”位置、方向数组等方式简化搜索过程。还有题解采用暴力枚举，对每个字符向8个方向判断是否能组成单词。
2. **算法要点**：利用方向数组表示8个搜索方向；通过递归（DFS）实现搜索过程；使用标记数组记录单词位置以便输出。
3. **解决难点**：确保搜索方向固定，避免重复搜索或误判；处理边界条件，防止数组越界；优化搜索过程，提高效率。

### 具体题解分析
1. **作者：灯芯糕**
    - **星级**：4星
    - **关键亮点**：思路清晰，代码简洁。通过预处理记录“y”的位置，利用方向数组和递归函数进行搜索染色，逻辑连贯，易理解。
    - **个人心得**：无
    - **核心代码**
```cpp
int c[10000][2],d=0;
int x[9]={0,1,0,1,-1,0,-1,1,-1};
int y[9]={0,0,1,1,0,-1,-1,-1,1};
char a[103][103],b,k[9]=" yizhong";
bool s[102][102];
bool f(int i,int j,int m,int n,int next){
    if(next>=8){
        s[i][j]=1;
        return 1;
    }
    if(a[i+m][j+n]==k[next])
        if(f(i+m,j+n,m,n,next+1)){
        	s[i][j]=1;
        	return 1;
        }
    return 0;
}
```
核心思想：定义方向数组 `x`、`y` 表示8个方向，`f` 函数通过递归判断从位置 `(i, j)` 沿 `(m, n)` 方向是否能构成单词“yizhong”，若能则对该位置染色（标记为1）。
2. **作者：拱垲**
    - **星级**：4星
    - **关键亮点**：先给出60分骗分代码并详细分析其漏洞，再给出100分AC代码，有助于理解问题本质和正确解法。通过增加表示方向的参数解决方向判断问题。
    - **个人心得**：作者作为萌新表示被该题卡住1小时，强调代码长度不代表晦涩难懂，能AC就是好代码。
    - **核心代码**
```cpp
int dfs(int n,int m,int no,int f)
{
	if(n<1||m<1||n>num||m>num)
		return 0;
	if(a[n][m]==ans[no])
	{
		if(no==7)
		{
			book[n][m]=1;
			return 1;
		}	
		else
		{
			switch (f)
			{
				case 1:	if(dfs(n-1,m-1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 2:	if(dfs(n-1,m,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 3:	if(dfs(n-1,m+1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 4:	if(dfs(n,m-1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 5:
					if(dfs(n-1,m-1,no+1,1))
						book[n][m]=1;
					if(dfs(n-1,m,no+1,2)) 
						book[n][m]=1;
					if(dfs(n-1,m+1,no+1,3)) 
						book[n][m]=1;
					if(dfs(n,m-1,no+1,4)) 
						book[n][m]=1;
					if(dfs(n,m+1,no+1,6)) 
						book[n][m]=1;
					if(dfs(n+1,m-1,no+1,7)) 
						book[n][m]=1;
					if(dfs(n+1,m,no+1,8)) 
						book[n][m]=1;
					if(dfs(n+1,m+1,no+1,9)) 
						book[n][m]=1;
					break;
				case 6:	if(dfs(n,m+1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 7:	if(dfs(n+1,m-1,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 8:	if(dfs(n+1,m,no+1,f)){book[n][m]=1;return 1;}else return 0;
				case 9:	if(dfs(n+1,m+1,no+1,f)){book[n][m]=1;return 1;}else return 0;
			}
				
		}
	}
	else
		return 0;
}
```
核心思想：`dfs` 函数通过参数 `f` 表示方向，根据不同方向进行递归搜索，判断从位置 `(n, m)` 沿指定方向是否能构成单词“yizhong”，若能则标记该位置。
3. **作者：hzg0226**
    - **星级**：4星
    - **关键亮点**：代码结构清晰，通过结构体记录路径，利用方向常量数组进行DFS搜索。在找到“y”和相邻“i”后，以确定的方向进行DFS，逻辑明确。
    - **个人心得**：无
    - **核心代码**
```cpp
struct node
{
    int x,y;
}c[maxn];
char fz[maxn][maxn],stand[]="yizhong";
int vis[maxn][maxn];
int dir[][2]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};
void dfs(int x,int y,node c[],int k,int cur)
{
    if(cur==7){
        for(int i=0;i<7;i++)
            vis[c[i].x][c[i].y]=1;
    }
    else{
        int dx=x+dir[k][0];
        int dy=y+dir[k][1];
        if(cur==6||fz[dx][dy]==stand[cur+1]){
            c[cur].x=x;c[cur].y=y;
            dfs(dx,dy,c,k,cur+1);
        }
    }
}
```
核心思想：定义结构体 `node` 记录路径，`dfs` 函数从位置 `(x, y)` 出发，沿 `k` 方向搜索，若找到完整单词，则标记路径上的位置。

### 最优关键思路或技巧
1. **方向数组**：使用方向数组简洁地表示8个搜索方向，方便在搜索过程中移动坐标，减少重复代码。
2. **递归搜索**：通过递归函数实现深度优先搜索，清晰地表达搜索逻辑，易于理解和实现。
3. **标记数组**：利用标记数组记录单词出现的位置，便于最后输出时突出显示单词。

### 可拓展之处
此类题目属于字符矩阵搜索问题，可拓展到其他在矩阵中搜索特定字符串或图案的题目。类似算法套路包括先确定起始字符，再沿特定方向进行搜索，同时注意处理边界条件和避免重复搜索。

### 相似知识点洛谷题目
1. **P1314 聪明的质检员**：涉及在二维数组中根据一定规则搜索和统计数据，与本题在矩阵中搜索特定字符串有相似之处，需要考虑边界条件和搜索方向。
2. **P1434 [SHOI2002]滑雪**：同样是在二维矩阵上进行深度优先搜索，根据一定条件（如高度递减）进行路径搜索，与本题的搜索思路类似。
3. **P2392 kkksc03考前临时抱佛脚**：虽然不是矩阵搜索，但在处理多个任务的分配和计算最优值时，也运用到类似的搜索和判断逻辑，有助于加深对搜索算法的理解和应用。 

---
处理用时：90.64秒
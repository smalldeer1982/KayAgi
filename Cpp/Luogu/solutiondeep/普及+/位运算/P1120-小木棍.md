# 题目信息

# 小木棍

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。

现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。

给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。


## 说明/提示

对于全部测试点，$1 \leq n \leq 65$，$1 \leq a_i \leq 50$。

## 样例 #1

### 输入

```
9
5 2 1 5 2 1 5 2 1
```

### 输出

```
6```

# AI分析结果

这是一道搜索剪枝类型的题目，要求从给定的小木棍长度中找出原始木棍的最小可能长度。各题解思路基本一致，都是通过枚举原始木棍长度并进行深度优先搜索（DFS），同时运用多种剪枝策略来优化搜索过程，避免不必要的计算，以提高算法效率。

### 算法要点
1. **枚举原始木棍长度**：原始木棍长度范围在最长小木棍长度到所有小木棍长度之和之间，且必须是所有小木棍长度总和的因数。为减少枚举量，通常枚举到总和的一半即可。
2. **深度优先搜索**：通过DFS尝试将小木棍拼接成原始木棍，记录已拼接的木棍长度、当前正在拼接的木棍编号等状态。
3. **剪枝策略**：
    - **排序优化**：对小木棍按长度从大到小排序，优先使用长木棍，使短木棍在后续拼接中更灵活。
    - **避免重复搜索**：若某长度木棍拼接失败，不再尝试相同长度木棍；若当前拼接的木棍长度为0或加上当前枚举木棍长度等于目标长度但拼接失败，直接回溯。
    - **可行性剪枝**：若当前长棍剩余未拼长度等于当前木棍长度或原始长度，继续拼失败则回溯；若剩余未拼长度小于最短木棍长度或剩余木棍总长度小于未拼长度，直接返回。

### 难点分析
1. **剪枝策略的设计与理解**：多种剪枝策略需综合运用，部分剪枝策略如“当前长棍剩余未拼长度等于当前木棍长度或原始长度时的剪枝”较难理解，需深入思考其原理和作用。
2. **代码实现细节**：在DFS过程中，状态的记录和更新、标记数组的使用、回溯操作等细节较多，容易出错。

### 题解评分
1. **作者Kaori**：思路清晰全面，对每个优化点都进行了详细解释，代码注释详细，可读性高，优化程度也较为完善，可得5星。
2. **作者NoyException**：详细介绍了题目思路、剪枝方法及名词说明，代码有一定注释，整体质量较高，可得4星。
3. **作者lgnotus**：详细列举了剪枝方法，代码注释较清楚，但在思路阐述的完整性上略逊于前两位，可得4星。

### 所选题解
 - **作者Kaori（5星）**
    - **关键亮点**：对搜索剪枝的思路讲解极为详细，从搜索范围的确定到各种优化策略的提出及原理阐述，都非常清晰，代码注释丰富，易于理解。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：通过`dfs`函数进行深度优先搜索，在搜索过程中运用多种剪枝策略，如通过二分查找优化搜索范围，利用`next`数组避免重复搜索相同长度木棍等。
```cpp
void dfs(int k,int last,int rest){ 
    int i;
    if(!rest){ 
        if(k==m){ok=1; return;} 
        for(i=1;i<=cnt;i++) 
            if(!used[i]) break;
        used[i]=1; 
        dfs(k+1,i,len-a[i]);
        used[i]=0;
        if(ok) return; 
    }
    int l=last+1, r=cnt, mid;
    while(l<r){
        mid=(l+r)>>1;
        if(a[mid]<=rest) r=mid;
        else l=mid+1;
    }
    for(i=l;i<=cnt;i++){
        if(!used[i]){ 
            used[i]=1;
            dfs(k,i,rest-a[i]);
            used[i]=0;
            if(ok) return; 
            if(rest==a[i] || rest==len) return; 
            i=next[i]; 
            if(i==cnt) return;
        }
    }
}
```
 - **作者NoyException（4星）**
    - **关键亮点**：对剪枝方法进行了分类说明，从基础剪枝到普通剪枝再到进阶剪枝，层次分明，便于理解。
    - **个人心得**：作者表示花了半天才完成题目，可见搜索剪枝题目的难度和复杂性。
    - **重点代码 - 核心实现思想**：`perm`函数实现DFS，通过`vis`数组标记木棍使用情况，利用`nxt`数组跳过相同长度木棍，在搜索过程中依据不同剪枝策略进行判断和回溯。
```cpp
bool perm(int pre,int fromp)
{
    int i;
    if(pre%len==0)
    {
        if(sum-pre==len) return true;
        for(i=2;i<=end && vis[i];i++) ;
        vis[i]=true;
        if(perm(pre+line[i],2)) return true;
        vis[i]=false;
    }
    else for(;fromp<=end;fromp++)
    {
       	if(!vis[fromp])
       	{
       		if(pre%len+line[fromp]<=len)
       		{
       			vis[fromp]=true;
   				if(perm(pre+line[fromp],fromp)) return true;
				vis[fromp]=false;
				if(pre%len+line[fromp]==len) return false;
			}
			fromp=nxt[line[fromp]];
		}
	}
    return false;
}
```
 - **作者lgnotus（4星）**
    - **关键亮点**：详细列出了7种剪枝方法，并在代码中通过注释清晰地标注了剪枝位置，使读者能快速理解剪枝的实现方式。
    - **个人心得**：作者提到加剪枝的过程很痛苦，曾出现把WA剪出来的情况，强调了剪枝实现过程中需要仔细调试。
    - **重点代码 - 核心实现思想**：`dfs`函数实现搜索过程，通过`vis`数组标记木棍使用情况，利用`next`数组实现剪枝，在搜索失败时依据不同剪枝条件进行回溯。
```cpp
void dfs(int now,int last,int g,int cur)
{
    if(now==val-1)
    {
        ans=min(ans,g);
        flag=1;
        return;
    }
    if(cur==g)
    {
        dfs(now+1,1,g,0);
    }
    for(int i=last;i<=tot;)
    {
        if(!vis[i]&&cur+stick[i]<=g)
        {
            vis[i]=1;
            dfs(now,i+1,g,cur+stick[i]);
            if(flag)return;
            vis[i]=0;
            if(cur==0||cur+stick[i]==g)return;
            i=next[i];
        }
        else
        {
            i++;
        }
    }
}
```

### 最优思路技巧
1. **排序策略**：对小木棍按长度从大到小排序，优先使用长木棍，能有效减少搜索分支，提高搜索效率。
2. **避免等效冗余**：记录已尝试过的木棍长度及拼接状态，避免重复搜索相同情况，如使用数组记录相同长度木棍的位置，跳过已失败的相同长度木棍。
3. **可行性剪枝**：根据当前拼接状态，及时判断并排除不可能的情况，如剩余未拼长度与当前木棍长度或原始长度的关系，剩余木棍长度与未拼长度的比较等。

### 拓展思路
此类题目属于搜索剪枝范畴，常见的类似题目还有拼图问题、物品组合问题等。解题时通常需先确定搜索空间和状态表示，然后通过剪枝策略优化搜索过程。相似的算法套路包括合理设计状态转移、利用数据结构辅助剪枝、依据问题特性进行可行性和最优性剪枝等。

### 相似题目推荐
1. **P1433 吃奶酪**：通过搜索不同奶酪的访问顺序，结合剪枝策略找到最短路径，与本题在搜索和剪枝的运用上类似。
2. **P2324 骑士精神**：利用广度优先搜索（BFS）并结合剪枝，求解棋盘状态转换的最小步数，同样需要对搜索过程进行优化。
3. **P1118 数字三角形**：可通过搜索不同路径并结合记忆化搜索（一种剪枝策略）来求解最大路径和，与本题思路有相通之处。 

---
处理用时：68.35秒
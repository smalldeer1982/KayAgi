# 题目信息

# [USACO2.2] 派对灯 Party Lamps

## 题目描述

在 IOI98 的节日宴会上，我们有 $n$ 盏彩色灯，他们分别从 $1 \sim n$ 被标上号码。这些灯都连接到四个按钮：

按钮 $1$：当按下此按钮，将改变所有的灯：本来亮着的灯就熄灭，本来是关着的灯被点亮。

按钮 $2$：当按下此按钮，将改变所有奇数号的灯。

按钮 $3$：当按下此按钮，将改变所有偶数号的灯。

按钮 $4$：当按下此按钮，将改变所有序号是 $3k+1 \ (k \in [0,+\infty) \cap \mathbb Z)$ 的灯。例如：$1,4,7,10 \dots$

一个计数器 $c$ 记录按钮被按下的次数。当宴会开始，所有的灯都亮着，此时计数器 $c$ 为 $0$。

你将得到计数器 $c$ 上的数值和经过若干操作后某些灯的状态。写一个程序去找出所有灯最后可能的与所给出信息相符的状态，并且没有重复。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$10 \le n \le 100$，$0 \le c \le 10^4$。

【样例解释】  
在这个样例中，有三种可能的状态：

- 所有灯都关着

- $1,4,7,10$ 号灯关着，$2,3,5,6,8,9$ 亮着。

- $1,3,5,7,9$ 号灯关着，$2,4,6,8,10$ 亮着。


翻译来自NOCOW

USACO 2.2


## 样例 #1

### 输入

```
10
1
-1
7 -1
```

### 输出

```
0000000000
0101010101
0110110110
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕派对灯问题，通过分析按钮操作规律，利用循环节特性和状态枚举来求解。多数题解发现按钮操作存在循环节为6的规律，且同一按钮按偶数次等效于未按，从而简化状态数量。部分题解通过打表、枚举按钮奇偶性或利用公理推导等方式确定最终灯的可能状态。

### 所选的题解
- **题解一（作者：Orzalpha，5星）**
    - **关键亮点**：思路清晰，先通过公理和推论严谨证明对于任意c总能转化为c≤2时的某种状态，再总结出三个关键规律，利用常量表存出所有c的情况，代码简洁高效，可读性强。
    - **重点代码核心思想**：定义常量表h存储不同状态下前6盏灯的情况，根据输入的c值选择对应的状态数组，通过work函数检验并输出符合条件的灯状态。
    ```cpp
    const int h[9][7]= {{},
        {0,0,0,0,0,0}, //1
        {0,0,0,1,1,1}, //34
        {1,0,1,0,1,0}, //2
        {1,0,1,1,0,1}, //4
        {0,1,0,0,1,0}, //14
        {0,1,0,1,0,1}, //3
        {1,1,1,0,0,0}, //24
        {1,1,1,1,1,1}  //0
    };
    int n,c,on[101],off[101];
    inline void work(int w[9])
    {
        int flag=1;
        for(int k=1; k<=w[0]; k++)
        {
            int tag=0;
            for(int i=1; i<=on[0]; i++)
                if(!h[w[k]][on[i]%6])
                {tag=1;break;}
            if(tag) continue;
            for(int i=1; i<=off[0]; i++)
                if(h[w[k]][off[i]%6])
                {tag=1;break;}
            if(tag) continue;
            flag=0;
            for(int i=1; i<=n; i++)
                printf("%d",h[w[k]][i%6]);
            printf("\n");
        }
        if(flag) printf("IMPOSSIBLE");
        exit(0);
    }
    int main()
    {
        int tmp;
        scanf("%d%d",&n,&c);
        while(1)
        {
            scanf("%d",&tmp);
            if(tmp==-1) break;
            on[++on[0]]=tmp;
        }
        while(1)
        {
            scanf("%d",&tmp);
            if(tmp==-1) break;
            off[++off[0]]=tmp;
        }
        if(c==0)
        {int w[9]={1,8};work(w);}
        if(c==1)
        {int w[9]= {4,1,3,4,6};work(w);}
        if(c==2)
        {int w[9]= {7,1,2,3,5,6,7,8};work(w);}
        if(c>2)
        {int w[9]= {8,1,2,3,4,5,6,7,8};work(w);}
        return 0;
    }
    ```
- **题解二（作者：fastle，4星）**
    - **关键亮点**：从分析对灯的操作入手，直观地得出以6个元素为一组的循环节能模拟整个序列，通过笔画得出8种最终结果，思路直观易懂，代码实现简洁明了。
    - **重点代码核心思想**：定义map数组存储8种状态，通过judge函数判断每种状态是否符合输入要求，cz函数根据c值筛选并输出符合条件的状态。
    ```cpp
    const int map[8][7] ={
        0,0,0,0,0,0,0,
        0,0,0,1,1,1,0,//1
        0,0,1,0,1,0,1,
        0,0,1,1,0,1,1,//到这里是一步的 //1//2
        0,1,0,0,1,0,0,//1
        0,1,0,1,0,1,0,
        0,1,1,0,0,0,1,//1
        0,1,1,1,1,1,1,
    };
    int n,c;
    int kai[10];int guan[10];
    int ktop = 0;int gtop = 0;
    bool flag = false;
    bool judge(int x)
    {
        for(int j = 1;j <= ktop;j ++)
        {
            if(!map[x][kai[j]])
                return false;
        }
        for(int j = 1;j <= gtop;j ++)
        {
            if(map[x][guan[j]])
                return false;
        }
        for(int i = 1;i <= n;i ++)
        {
            printf("%d",map[x][(i - 1) % 6 + 1]);//这里是循环的 
        }
        printf("\n");
        return true;
    }
    void cz(int x)
    {
        for(int i = 0;i <= 7;i ++)
        {
            if(x == 2 && i == 3)continue;
            if(x == 1)
            {
                if(i == 1||i == 3|| i == 4|| i== 6)continue;
            }
            bool t = judge(i);
            if(!flag)flag = t;
        }
        if(!flag)//没有一种情况符合 
            puts("IMPOSSIBLE");
    }
    int main()
    {
        scanf("%d%d",&n,&c);
        while("zbq is handsome")//记录必须开着的地方 
        {
            int zz;
            scanf("%d",&zz);
            if(zz == -1)break;
            kai[++ ktop] =( zz - 1) % 6 + 1;
        }
        while("zbq is handsome")//记录必须关着的地方 
        {
            int zz;
            scanf("%d",&zz);
            if(zz == -1)break;
            guan[++ gtop] =  ( zz - 1) % 6 + 1;
        }
        if(c == 0)//不能变换时也要特判 
        {
            if(gtop)
            {
                puts("IMPOSSIBLE");
            }
            else
                for(int i = 1;i <= n;i ++)
                    printf("1");
            return 0;
        }
        cz(c);
        return 0;
    } 
    ```
- **题解三（作者：key_rA9，4星）**
    - **关键亮点**：简洁地分析出灯的循环节为6，共有8种可能状态，通过对c值进行分类讨论，清晰地确定每种情况下可达到的状态，代码逻辑清晰。
    - **重点代码核心思想**：定义a数组存储8种状况，pd函数判断每种状况是否符合输入要求，根据c值调用pd函数输出符合条件的状态。
    ```cpp
    int n,c,b[7];bool bk;//有没有解
    const int a[8][7]=//八种状况
    {0,0,0,0,0,0,0,//1
        1, 0,0,1,1,1,0,//6=3+4
        2, 0,1,0,1,0,1,//2
        3, 0,1,1,0,1,1,//4
        4, 1,0,0,1,0,0,//5=1+4
        5, 1,0,1,0,1,0,//3
        6, 1,1,0,0,0,1,//7=2+4
        7, 1,1,1,1,1,1};//0
    void pd(int k)  
    {
        for(int i=1;i<=6;i++)if(b[i]!=-1&&a[k][i]!=b[i])return;//如果有要求却不合就不成立
        for(int i=1;i<=n;i++)printf("%d",a[k][(i-1)%6+1]);//循环输出
        printf("\n");bk=1;//解记号
    }
    int main()  
    {
        scanf("%d%d",&n,&c);int t;
        memset(b,-1,sizeof(b));//初始化灯都没要求
        while(scanf("%d",&t)!=EOF){if(t==-1)break;b[(t-1)%6+1]=1;}//将第几盏转换成六位中的位置
        while(scanf("%d",&t)!=EOF){if(t==-1)break;b[(t-1)%6+1]=0;}
        if(!c){pd(7);if(bk)return 0;}//有解就结束程序
        else if(c==1)
        {
            pd(0);pd(2);pd(3);pd(5);
            if(bk)return 0;
        }
        else if(c==2)
        {
            pd(0);pd(1);pd(2);pd(4);pd(5);pd(6);pd(7);
            if(bk)return 0;
        }
        else//正常情况
        {
            for(int i=0;i<8;i++){pd(i);}//8种判断
            if(bk)return 0;
        }printf("IMPOSSIBLE\n");//无解
        return 0;
    }
    ```

### 最优关键思路或技巧
- **循环节利用**：发现灯的状态变化以6为循环节，将问题规模缩小到前6盏灯，大大减少计算量。
- **状态简化**：根据按钮按偶数次等效于未按的特性，减少状态枚举数量，如通过公理推导将任意c转化为c≤2的状态，或直接分析出8种可能状态。

### 可拓展思路
同类型题可考察对操作规律的挖掘和利用，类似算法套路包括寻找循环节、简化状态表示、利用操作的等效性等。例如在一些状态转换问题中，通过分析操作对状态的影响，找出重复或等效的状态，从而优化求解过程。

### 相似知识点洛谷题目
- **P1199 [NOIP2010 普及组] 三国游戏**：涉及对游戏规则的分析和策略选择，类似本题对按钮操作规则的理解与运用。
- **P1217 [USACO1.5] 回文质数 Prime Palindromes**：需要利用数的特性（回文和质数）进行筛选和判断，与本题挖掘按钮操作特性类似。
- **P1433 吃奶酪**：通过分析路径选择和状态变化求解，与本题通过枚举状态解决问题的思路有相似之处。 

---
处理用时：65.05秒
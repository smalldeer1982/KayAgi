# 题目信息

# 色板游戏

## 题目背景

阿宝上学了，今天老师拿来了一块很长的涂色板。


## 题目描述

色板长度为 $L$，$L$ 是一个正整数，所以我们可以均匀地将它划分成 $L$ 块 $1$ 厘米长的小方格。并从左到右标记为 $1, 2, \dots L$。

现在色板上只有一个颜色，老师告诉阿宝在色板上只能做两件事：

1. `C A B C` 指在 $A$ 到 $B$ 号方格中涂上颜色 $C$。
2. `P A B` 指老师的提问：$A$ 到 $B$ 号方格中有几种颜色。

学校的颜料盒中一共有 $T$ 种颜料。为简便起见，我们把他们标记为 $1, 2, \dots T$. 开始时色板上原有的颜色就为 $1$ 号色。 面对如此复杂的问题，阿宝向你求助，你能帮助他吗？


## 样例 #1

### 输入

```
2 2 4
C 1 1 2
P 1 2
C 2 2 2
P 1 2```

### 输出

```
2
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕色板游戏问题，核心是处理区间染色和查询颜色种类的操作。由于颜色种类 \( T \leq 30 \)，大部分题解利用状态压缩思想，结合线段树数据结构来优化时间和空间复杂度，少数采用分块算法。
1. **思路**：
    - **线段树结合状态压缩**：多数题解采用此方法，用二进制数表示区间颜色状态，通过按位或运算合并区间状态，利用线段树的lazy标记优化更新操作。
    - **多棵线段树**：为每种颜色建一棵线段树，更新时修改对应颜色线段树，查询时遍历所有颜色线段树。
    - **分块算法**：将色板分块，块内维护颜色信息，更新和查询时结合整块操作与块内暴力查询。
2. **算法要点**：
    - **状态压缩**：用二进制位表示颜色，如二进制第 \( i \) 位为 \( 1 \) 表示存在第 \( i \) 种颜色。
    - **线段树操作**：包括建树、更新、查询、pushup（合并区间状态）、pushdown（下放lazy标记）。
    - **分块操作**：合理分块，维护块内颜色标记和种类信息，处理边界情况。
3. **解决难点**：
    - **高效合并区间颜色信息**：通过状态压缩和按位或运算，快速合并区间颜色状态。
    - **优化更新操作**：利用lazy标记，避免不必要的更新，提高效率。

### 题解评分
1. **作者fyfy**：3星。思路清晰，采用30颗线段树的方法直观易懂，但空间复杂度较高，代码实现详细。
2. **作者Taduro**：4星。利用状态压缩和线段树，思路简洁高效，代码实现较为精炼，清晰展示了上推和下推规则。
3. **作者MindyY**：4星。详细阐述思路，将区间状态用二进制数表示，代码注释丰富，对线段树操作解释清晰。
4. **作者tuo3288**：4星。引入STL的bitset，利用其特性简化位运算操作，代码结构清晰，对bitset使用说明详细。
5. **作者scallop**：3星。分块算法思路明确，代码实现完整，但相比线段树结合状态压缩的方法，效率稍低。
6. **作者7KByte**：4星。思路清晰，利用状态压缩和线段树模板解决问题，代码简洁，对状态压缩和线段树操作描述准确。
7. **作者Strelitzia**：3星。分块方法易懂，代码实现详细，但在效率和创新性上不如部分线段树解法。
8. **作者Adove**：4星。使用bitset解决问题，代码简洁明了，对bitset的操作运用熟练，清晰展示了更新和查询过程。
9. **作者Created_equal1**：4星。利用状态压缩和线段树，代码结构清晰，对线段树的构建、更新和查询操作实现完整。
10. **作者wmxwmx**：4星。详细分析思路和优化点，如lazy - tag的特殊处理、询问时的优化等，代码实现体现了这些优化。
11. **作者Baihua**：4星。结合状态压缩和线段树，对思路分析详细，代码实现完整，对线段树各操作描述清晰。
12. **作者Timothy**：3星。采用传统线段树思路，用数组记录颜色情况，代码实现详细，但未利用状态压缩优化。
13. **作者kradcigam**：3星。建 \( t \) 棵线段树，思路直观，但相比状态压缩的方法，空间和时间复杂度较高。
14. **作者GHJhandsome**：3星。利用状态转移和线段树，思路有一定创新性，但代码表述较随意，部分解释不够清晰。
15. **作者sunzh**：4星。结合状态压缩和线段树，详细阐述各操作的实现思路，代码实现完整。
16. **作者小菜鸟**：3星。用平衡树实现区间操作，思路独特，但代码对平衡树操作依赖较多，相比线段树解法复杂。
17. **作者TheShadow**：4星。思路清晰，利用二进制表示区间颜色，详细描述线段树各操作的实现，代码简洁。
18. **作者斗神_君莫笑**：4星。利用二进制表示区间颜色状态，代码实现了线段树的基本操作，对关键步骤解释清晰。
19. **作者eros1on**：4星。提供两种解法，一种是建 \( t \) 棵线段树，另一种是状态压缩结合线段树的正解，代码实现详细。
20. **作者hl666**：4星。结合线段树和状态压缩，详细说明各操作的修改要点，代码实现完整。
21. **作者winmt**：4星。思路清晰，利用状态压缩和线段树解决问题，代码实现高效，对易错点有详细说明。
22. **作者mochenbo**：3星。代码实现了线段树的基本操作，但思路表述较混乱，代码可读性一般。
23. **作者AxDea**：3星。详细阐述线段树结合状态压缩的实现步骤，但代码以片段形式呈现，不够完整。
24. **作者abandentsky**：3星。利用lazy标记和状态压缩，代码实现了区间更新和查询，但部分注释和变量命名可优化。
25. **作者我很辣ji看头像**：3星。纯lazy标记线段树模板，思路常规，代码实现中规中矩，缺乏优化说明。
26. **作者Tiffany_Tendering**：3星。对线段树每个节点开bool数组记录颜色，未利用状态压缩，代码实现较繁琐。

### 高星题解
1. **作者Taduro**：
    - **星级**：4星
    - **关键亮点**：利用状态压缩，将颜色信息压缩到一个数的二进制位中，通过按位或运算合并区间状态，简洁高效地实现线段树的上推和下推规则。
    - **重点代码**：
```cpp
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
ll sum[400001],n,t,c,i,ad[400001];
inline void pushup(ll rt){
    sum[rt]=sum[rt<<1]|sum[rt<<1|1];
}
inline void build(ll rt,ll l,ll r){
    if (l==r){
        sum[rt]=1<<1;
        return;
    }
    int m=(l+r)>>1;
    build(rt<<1,l,m);
    build(rt<<1|1,m+1,r);
    pushup(rt);
}
inline void pushdown(ll rt,ll l,ll r){
    if (ad[rt]){
        sum[rt<<1]=(1<<ad[rt]);
        sum[rt<<1|1]=(1<<ad[rt]);
        ad[rt<<1]=ad[rt];
        ad[rt<<1|1]=ad[rt];
        ad[rt]=0;
    }
}
inline void update(ll rt,ll l,ll r,ll x,ll y,ll k){
    if (l>y||x>r) return;
    if (x<=l&&r<=y){
        sum[rt]=(1<<k);
        ad[rt]=k;
        return;
    }
    pushdown(rt,l,r);
    ll m=(l+r)>>1;
    if (m>=x) update(rt<<1,l,m,x,y,k);
    if (m<y) update(rt<<1|1,m+1,r,x,y,k);
    pushup(rt);
}
inline int query(ll rt,ll l,ll r,ll x,ll y){
    if (l>y||x>r) return 0;
    if (x<=l&&r<=y)	return sum[rt];
    pushdown(rt,l,r);
    ll m=(l+r)>>1,ans=0;
    if (m>=x) ans|=query(rt<<1,l,m,x,y);
    if (m<y) ans|=query(rt<<1|1,m+1,r,x,y);
    return ans;
}
int main(){
    char u; ll x,y,k;
    scanf("%lld%lld%lld",&n,&c,&t);
    build(1,1,n);
    while (t--){
        cin>>u;
        if(u=='C'){
            scanf("%lld%lld%lld",&x,&y,&k);
            if (x>y) swap(x,y);
            update(1,1,n,x,y,k);
        }
        else{
            scanf("%lld%lld",&x,&y);
            if (x>y) swap(x,y);
            ll p=query(1,1,n,x,y),ans=0;
            for (i=1; i<=c; i++) if (p&(1<<i)) ans++;
            printf("%lld\n",ans);
        }
    }
    return 0;
}
```
    - **核心思想**：通过 `pushup` 函数按位或合并区间状态，`build` 函数初始化线段树，`pushdown` 函数下放lazy标记，`update` 函数更新区间颜色，`query` 函数查询区间颜色状态并统计颜色种类。
2. **作者MindyY**：
    - **星级**：4星
    - **关键亮点**：通俗易懂地阐述思路，将每个区间的状态用二进制数表示，代码注释丰富，详细解释了线段树的各种操作。
    - **重点代码**：
```cpp
#include<stdio.h>
#include<string.h>
int    l,t,o;
int a[1000005]={0},lazy[1000005]={0};
long long lala(int x){
    long long temp=1;
    for(int lmq=0;lmq<x;lmq++){
        temp*=2;
    }
    return temp;
}
void pushdown(int num){
    if(lazy[num]){
        lazy[num*2]=lazy[num];
        lazy[num*2+1]=lazy[num];
        a[num*2]=lazy[num];
        a[num*2+1]=lazy[num];
        lazy[num]=0;
    }
}
void pushup(int num){
    a[num]=a[num*2]|a[num*2+1];
}
void build(int left,int right,int num){
    if(left==right){
        a[num]=1;
        return;
    }
    int mid=(left+right)/2;
    build(left,mid,num*2);
    build(mid+1,right,num*2+1);
    pushup(num);
}
void color(int l,int r,int c,int left,int right,int num){
    if(l<=left&&r>=right){//找到符合区间直接覆盖
        pushdown(num);
        long long tmp=lala(c-1);
        a[num]=tmp;
        lazy[num]=tmp;
        return ;
    }
    pushdown(num);
    int mid=(left+right)/2;
    if(l<=mid){
        color(l,r,c,left,mid,num*2);
    }
    if(mid<r){
        color(l,r,c,mid+1,right,num*2+1);
    }
    pushup(num);
}
long long ask(int l,int r,int left,int right,int num){
    if(l<=left&&right<=r){
        return a[num];
    }
    pushdown(num);
    int mid=(left+right)/2;
    long long temp=0;
    if(l<=mid){
        temp=temp|ask(l,r,left,mid,num*2);//两个状态用或运算合在一起
    }
    if(mid<r){
        temp=temp|ask(l,r,mid+1,right,num*2+1);
    }
    return temp;
}
void f(long long x){
    int res=0;
    for(;x!=0;){
        if(x%2==1)    res++;
        x=x/2;
    }
    printf("%d\n",res);
    return;
}
int main(){//主函数
    scanf("%d%d%d",&l,&t,&o);
    build(1,l,1);//输入完建树
    for(int i=0;i<o;i++){
        char q[3];
        scanf("%s",q);
        if(q[0]=='C'){
            int c1,c2,c3;
            scanf("%d%d%d",&c1,&c2,&c3);
            if(c1>c2){
                int chicken=c1;
                c1=c2;
                c2=chicken;
            }
            color(c1,c2,c3,1,l,1);//color覆盖染色
        }
        else{
            int c1,c2;
            scanf("%d%d",&c1,&c2);
            if(c1>c2){
                int chicken=c1;
                c1=c2;
                c2=chicken;
            }
            long long ans=ask(c1,c2,1,l,1);//询问区间染色状态
            f(ans);//将二进制数转化为颜色种类数并输出
        }
    }
    return 0;
}
```
    - **核心思想**：`build` 函数建树，`pushup` 按位或合并区间，`pushdown` 下放lazy标记，`color` 函数更新颜色，`ask` 函数查询区间状态，`f` 函数统计二进制中1的个数得到颜色种类。
3. **作者tuo3288**：
    - **星级**：4星
    - **关键亮点**：引入STL的bitset，利用其按位运算特性简化操作，代码结构清晰，对bitset的使用说明详细。
    - **重点代码**：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<bitset>
using namespace std;
int X,W;char ch;
inline int read()
{
    X=0,W=1;ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')W=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){X=(X<<1)+(X<<3)+ch-48;ch=getchar();}
    return X*W;
}
struct tree{
    int l;
    int r;
    int lazy;
    bitset<30>p;
}tr[400001];
bitset<30>ans;
int a[100001];
void pushdown(int k)
{
    if(tr[k].lazy==0)return;
    tr[k<<1].lazy=tr[k].lazy;
    tr[k<<1].p.reset();
    tr[k<<1].p.set(tr[k].lazy,1);
    tr[k<<1|1].lazy=tr[k].lazy;
    tr[k<<1|1].p.reset();
    tr[k<<1|1].p.set(tr[k].lazy,1);
    tr[k].lazy=0;
}
void build(int k)
{
    tr[k].p.set(1,1);
    if(tr[k].l==tr[k].r)return;
    int mid=(tr[k].l+tr[k].r)>>1;
    tr[k<<1].l=tr[k].l;
    tr[k<<1].r=mid;
    tr[k<<1|1].l=mid+1;
    tr[k<<1|1].r=tr[k].r;
    build(k<<1),build(k<<1|1);
}
void change(int k,int l,int r,int c)
{
    if(tr[k].l==l&&tr[k].r==r){
        tr[k].lazy=c;
        tr[k].p.reset();
        tr[k].p.set(c,1);
        return;
    }
    pushdown(k);
    if(l>tr[k<<1].r)change(k<<1|1,l,r,c);
    else if(r<tr[k<<1|1].l)change(k<<1,l,r,c);
    else change(k<<1,l,tr[k<<1].r,c),change(k<<1|1,tr[k<<1|1].l,r,c);
    tr[k].p=(tr[k<<1].p|tr[k<<1|1].p);
}
void ask(int k,int l,int r)
{
    if(tr[k].l==l&&tr[k].r==r){
        ans|=tr[k].p;
        return;
    }
    pushdown(k);
    if(l>tr[k<<1].r)ask(k<<1|1,l,r);
    else if(tr[k<<1|1].

---
处理用时：124.31秒
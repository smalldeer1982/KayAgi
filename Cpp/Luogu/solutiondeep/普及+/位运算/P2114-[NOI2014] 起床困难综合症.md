# 题目信息

# [NOI2014] 起床困难综合症

## 题目描述

$21$ 世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因：在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。正是由于 drd 的活动，起床困难综合症愈演愈烈，以惊人的速度在世界上传播。为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙。历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 $n$ 扇防御门组成。每扇防御门包括一个运算 $op$ 和一个参数 $t$，其中运算一定是 $\text{OR},\text{XOR},\text{AND}$ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $x$，则其通过这扇防御门后攻击力将变为 $x~op~t$。最终 drd 受到的伤害为对方初始攻击力 $x$ 依次经过所有 $n$ 扇防御门后转变得到的攻击力。

由于 atm 水平有限，他的初始攻击力只能为 $0$ 到 $m$ 之间的一个整数（即他的初始攻击力只能在 $0,1,\ldots,m$ 中任选，但在通过防御门之后的攻击力不受 $m$ 的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。

## 说明/提示

【样例说明】

atm 可以选择的初始攻击力为 $0,1,\ldots ,10$。

假设初始攻击力为 $4$，最终攻击力经过了如下计算

- $4 \text{ AND } 5 = 4$；
- $4 \text{ OR } 6 = 6$；
- $6 \text{ XOR } 7 = 1$。

类似的，我们可以计算出初始攻击力为 $1,3,5,7,9$ 时最终攻击力为 $0$，初始攻击力为 $0,2,4,6,8,10$ 时最终攻击力为 $1$，因此atm的一次攻击最多使drd受到的伤害值为 $1$。

【数据规模与约定】

![](https://cdn.luogu.com.cn/upload/image_hosting/29yj7o58.png)

- 特殊性质 $\mathrm A$：存在一扇防御门为 $\texttt{AND 0}$；
- 特殊性质 $\mathrm B$：所有防御门的操作均相同。

对于所有数据，保证 $2\le n\le 10^5$，$0\le m\le 10^9$，$0\le t\le 10^9$，且 $\mathrm{op}$ 一定为 $\verb!AND!,\verb!OR!,\verb!XOR!$ 中的一种。


## 样例 #1

### 输入

```
3 10
AND 5
OR 6
XOR 7```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何通过位运算和贪心策略解决该问题。思路上，大多利用位运算每一位相互独立的特性，通过预处理0和1经过所有防御门后的结果，从高位到低位贪心构造最大伤害值。

算法要点在于：先确定0和1经过一系列位运算后的最终状态，然后根据贪心原则，在不超过初始攻击力上限m的前提下，尽量使高位为1以最大化伤害。

解决难点在于理解位运算的独立性以及合理运用贪心策略。部分题解还涉及到对边界条件的处理，如防止左移时数据类型溢出。

### 所选的题解
- **作者：小粉兔 (赞：172)  5星**
    - **关键亮点**：思路清晰简洁，代码短小精悍。通过a1和a2两个变量分别记录二进制全0和全1经过门之后的状态，然后从高位到低位贪心构造答案。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
int n,m,ans,x,a1=0,a2=-1;
char str[5];
int main(){
    scanf("%d%d",&n,&m);
    while(n--){
        scanf("%s%d",str,&x);
        if(str[0]=='A') a1&=x, a2&=x;
        if(str[0]=='X') a1^=x, a2^=x;
        if(str[0]=='O') a1|=x, a2|=x;
    }
    for(int j=29;~j;--j){
        if(a1>>j&1) ans+=1<<j;
        else if(a2>>j&1&&(1<<j)<=m) ans+=1<<j, m-=1<<j;
    } printf("%d",ans);
    return 0;
}
```
    - **核心实现思想**：先遍历所有防御门，更新a1和a2的值。然后从高位到低位遍历二进制位，若a1对应位为1，直接加到答案中；若a1对应位为0但a2对应位为1且加上该位不超过m，则加到答案中并更新m。
- **作者：cuking (赞：98)  5星**
    - **关键亮点**：逻辑简单易懂，同样利用两个变量记录0和1经过所有操作后的结果，按照位运算的特性和贪心策略求解。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<stdio.h>
int main()
{
    int bool1=0x7fffffff,bool0=0;
    int N,M,t,i,ans=0;
    char ls[4];
    scanf("%d %d",&N,&M);
    while(N--)
    {
        scanf("%s%d",ls,&t);
        if(*ls=='A')
        {
            bool1&=t;
            bool0&=t;
        }
        else if(*ls=='O')
        {
            bool1|=t;
            bool0|=t;
        }
        else
        {
            bool1^=t;
            bool0^=t;
        }
    }
    for(i=30;i>=0;i--)
    {
        if(bool0&(1<<i))
        {
            ans+=1<<i;
        }
        else if(M>=(1<<i)&&(bool1&(1<<i)))
        {
            M-=1<<i;
            ans+=1<<i;
        }
    }
    printf("%d",ans);
}
```
    - **核心实现思想**：通过循环处理所有防御门，更新bool1和bool0。再从高位到低位遍历二进制位，若bool0对应位为1，加到答案；若bool0对应位为0但bool1对应位为1且加上该位不超M，则加到答案并更新M。
- **作者：寒鸽儿 (赞：3)  4星**
    - **关键亮点**：代码简洁，同样基于位运算独立性和贪心思想，清晰地展示了从高位到低位贪心构造答案的过程。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <cstdio>

using namespace std;

int main() {
    int n, m, tmp, a0 = 0, a1 = -1, ans = 0;
    char s[5];
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= n; ++i) {
        scanf("%s %d", s, &tmp);
        if(s[0] == 'A') a0 &= tmp, a1 &= tmp;
        else if(s[0] == 'O') a0 |= tmp, a1 |= tmp;
        else a0 ^= tmp, a1 ^= tmp;
    }
    for(int j = 30; ~j; --j) {
        if(a0 & (1<<j)) ans += 1<<j;
        else if(m >= (1<<j) && a1 & (1<<j)) {
            m -= 1 << j;
            ans += 1 << j;
        }
    }
    printf("%d\n", ans);
    return 0;
} 
```
    - **核心实现思想**：先通过循环处理防御门更新a0和a1。从高位到低位遍历二进制位，若a0对应位为1则加到ans；若a0对应位为0但a1对应位为1且m不小于该位对应值，则加到ans并更新m。

### 最优关键思路或技巧
1. **位运算独立性**：利用位运算每一位相互独立的特性，分别处理每一位，简化问题。
2. **贪心策略**：从高位到低位贪心，尽量使高位为1以最大化伤害值，同时满足初始攻击力不超过m的限制。

### 可拓展思路
同类型题可涉及更多复杂的位运算组合或在不同场景下应用位运算和贪心策略。类似算法套路是遇到涉及位运算且数据量较大无法暴力枚举的问题，考虑位运算的特性，通过预处理和贪心策略求解。

### 相似知识点洛谷题目
1. **P1876 [USACO06NOV]玉米田Corn Fields**：涉及状态压缩和位运算，通过二进制表示状态解决问题。
2. **P1170 兔八哥与猎人**：需要运用位运算和贪心思想，对不同状态进行处理。
3. **P3164 [CQOI2014]和谐矩阵**：利用位运算和线性代数知识，求解满足条件的矩阵。

### 个人心得摘录与总结
无。 

---
处理用时：38.28秒
# 题目信息

# 大河的序列

## 题目背景

“唯有龙虎相伴 最是脉脉深情”


题目来源：[KingSann](https://www.luogu.org/space/show?uid=47111)


## 题目描述

大河有一些袜子，但经常十分散乱的堆放着。


有一天龙儿忍不住了，于是将袜子放到了一个序列上（称作袜子序列）。


每个袜子都有一个$dirty$值，定义袜子序列的$dirty$值为 $ \max  \left( (dirty_{l} \ bitand \ dirty_{l+1} \ bitand \ \cdots \ bitand \ dirty_{r}) + (dirty_{l} \ bitor \ dirty_{l+1} \ bitor \ \cdots \ bitor \ dirty_{r}) \right) $ ，其中 $ dirty_{i} $ 表示 第 $ i $ 只袜子 的 $ dirty $ 值，$bitand$表示按位与（C++中是`&`），$bitor$表示按位或（C++中是`|`）。


简而言之，就是找一段连续子序列，使得所有数字的按位与加上按位或最大。


如果这个袜子序列的$dirty$值达到了某个**阈**值，那么龙儿会讨厌大河的。


大河当然不希望这样了，于是她想知道这个袜子序列的$dirty$值是多少。


## 说明/提示

$ 1 \le n, p \le 10^{5} $


$ 0 \le b, ditry_{i} \le 10^{7} $


对于测试点 $ 1 $ 和测试点 $ 2 $ 的数据，保证 $ 1 \le n \le 100 $


## 样例 #1

### 输入

```
10 1 10000000
7 9 9 4 0 0 8 8 4 7```

### 输出

```
251```

# AI分析结果

• 综合分析与结论：
    - 多数题解通过不同证明方法得出答案是序列中最大数的两倍这一结论，再使用快速幂按题目要求处理最终结果，时间复杂度为O(n)。少数题解采用二分 + 按位贪心策略，枚举左端点，从高位到低位按位贪心，利用单调性二分查找满足条件的位置，复杂度为O(nlog²n)。
    - 各题解的证明方法主要有反证法、顺推法、按位贪心讨论等，本质都是通过分析按位与和按位或运算在不同情况下对结果的影响，得出最大数乘2为最优解。
    - 整体上，基于结论的做法简洁高效，优于二分 + 按位贪心的标算做法。

所选的题解：
 - 作者：xzyxzy (赞：26)  星级：5星
关键亮点：思路清晰简洁，直接给出答案是最大数乘2的结论，并通过按位贪心思想分三种情况进行证明，代码简洁明了，还开启O2优化。
重点代码及核心思想：
```cpp
// luogu-judger-enable-o2
#include<iostream>
using namespace std;
int n,b,p,mod;
int ksm(int x,int k)
{
    int ans=1,base=x;
    while(k)
    {
        if(k&1) ans=1ll*ans*base%mod;
        base=1ll*base*base%mod; k>>=1;
    }
    return ans;
}
int main()
{
    cin>>n>>b>>mod;
    for(int i=1,x;i<=n;i++) cin>>x,p=max(x,p);
    cout<<ksm(p*2+233,b)%mod;
}
```
核心思想：先读入数据，在输入过程中找出最大值p，然后通过快速幂函数ksm计算(p * 2 + 233)的b次幂对mod取模的结果并输出。

 - 作者：zjy111 (赞：5)  星级：4星
关键亮点：给出两种证明方法（反证法和顺推法）证明答案是序列中最大值的两倍，逻辑清晰，代码注释详细，对结论的证明过程阐述细致。
重点代码及核心思想：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int arr[100005],n,b,p,ans;
ll ksm(ll x,ll y,ll p){ //快速幂
	ll base=x;x=1;
	while(y){
		if(y&1)x*=base;
		base*=base;
		if(base>p)base%=p;
		if(x>p)x%=p;
		y>>=1;
	}
	return x;
}
int main() {
	cin>>n>>b>>p;
	for(int i=1;i<=n;i++)scanf("%d",&arr[i]),ans=max(ans,arr[i]); //取最大值
	cout<<ksm(ans*2+233,b,p)%p; //按照题目要求处理答案
	return 0;
}
```
核心思想：读入数据，将序列中的数存入数组arr，在输入时找出最大值ans，通过快速幂函数ksm计算(ans * 2 + 233)的b次幂对p取模的结果并输出。

 - 作者：Aw顿顿 (赞：4)  星级：4星
关键亮点：先将题目LaTeX表述转化为清爽版本，使题意更清晰，然后详细阐述解法思路，从按位分析情况得出贪心策略，进而推出答案是最大值的两倍，对快速幂也有简要介绍。
重点代码及核心思想：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,b,x,p;
int qp(int x,int k){
    int s=1,b=x;
    while(k){
        if(k&1)s=1ll*s*b%p;
        b=1ll*b*b%p; k>>=1;
    }return s;
}int main(){
    cin>>n>>b>>p;
    for(int i=1;i<=n;i++){
        int a;cin>>a;
        x=max(a,x);
    }cout<<qp(x*2+233,b)%p;
    return 0;
}
```
核心思想：读入数据，在输入每个数a时，与当前最大值x比较并更新x，通过快速幂函数qp计算(x * 2 + 233)的b次幂对p取模的结果并输出。

最优的关键思路或技巧：通过对按位与和按位或运算性质的深入理解，按位分析新数加入序列后对结果的影响，从而得出贪心策略，即答案为序列中的最大数乘2，简化了问题求解过程。同时，快速幂算法的应用优化了幂运算的时间复杂度。

可拓展之处：同类型题可考虑一些涉及位运算和贪心策略结合的题目，类似算法套路是在涉及位运算的题目中，通过按位分析不同情况对结果的影响，找到贪心选择的依据。

推荐题目：
 - P1226 【模板】快速幂||取余运算，主要考察快速幂算法。
 - P1522 牛的旅行，涉及图论与位运算相关知识。
 - P2141 [NOI2014] 起床困难综合症，结合了位运算和贪心策略。

个人心得摘录及总结：
部分题解提到如果第一个测试点WA，需注意审题，出题人将第一个点设为b = 0且p = 1，部分代码未在输出时再次对p取模会导致错误。总结为做此类题目时，边界条件和题目细节需格外关注，避免因小失大。 

---
处理用时：62.50秒
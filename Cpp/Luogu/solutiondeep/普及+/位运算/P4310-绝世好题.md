# 题目信息

# 绝世好题

## 题目描述

给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i \& b_{i-1} \ne 0 $，其中 $2\leq i\leq k$， $\&$ 表示位运算取与。

## 说明/提示

对于100%的数据，$1\leq n\leq 100000$，$a_i\leq 10^9$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效求解满足特定位运算条件的子序列最长长度问题。大多题解采用动态规划（DP）思路，暴力做法是$O(n^2)$的枚举，通过分析位运算特点，优化为$O(nlogn)$的算法。主要思路是利用二进制位的特性，记录每个二进制位为1时的子序列最大长度，以此来转移状态。

### 所选的题解
1. **作者：winxp_qwq (赞：133)  5星**
    - **关键亮点**：思路清晰简洁，直接使用DP，定义dp[i]表示数列到目前为止最后一项第i位为1的最大子序列长度，通过两次循环分别进行状态转移和更新，代码简洁明了，复杂度为$O(nlogn)$。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[32];
int main(){
    int n;
    scanf("%d",&n);
    int a,b,c,i,j,k,ans=0;
    for(a=1;a<=n;a++)
    {
        scanf("%d",&b);
        k=1;
        for(c=0;c<=30;c++)
        if((1<<c)&b) k=max(dp[c]+1,k);
        for(c=0;c<=30;c++)
        if((1<<c)&b) dp[c]=max(dp[c],k);
        ans=max(ans,k);
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心实现思想**：每次读入一个数，先根据其为1的二进制位找到当前可转移得到的最大长度k，再用k更新该数所有为1的二进制位对应的dp值，最后更新全局答案ans。
2. **作者：Limerick (赞：52)  4星**
    - **关键亮点**：不仅给出正解思路，还提及80分的暴力DP做法，并通过具体例子详细解释正解中状态转移的过程，有助于理解。
    - **重点代码**：
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=35;
int n,ans,f[N],Max;
int main(){
    scanf("%d",&n);
    for(int j=1;j<=n;j++){//枚举每个数
        unsigned int x;//注意了,这里最好用unsigned int
        scanf("%ud",&x);//读入时为%ud
        Max=0;//最大值赋值为0
        for(int i=0;(1<<i)<=x;i++){//枚举这个数的每一位
            if(x&(1<<i)){//重点:如果这一位是1!!!
                Max=max(Max,f[i]+1);//长度++,并取最大进行f值的转移
            }
        }
        for(int i=0;(1<<i)<=x;i++){
            if(x&(1<<i)){//重点:如果这一位是1!!!
                f[i]=Max;//转移
            }
        }
    }
    for(int i=0;i<32;++i){
        ans=max(ans,f[i]);//ans为最长的
    }
    printf("%d\n", ans);
    return 0;
}
```
    - **核心实现思想**：与上一题解类似，枚举每个数及其二进制位，找到当前数基于二进制位可得到的最大长度Max，再用Max更新对应二进制位的f值，最后统计所有f值中的最大值作为答案。
3. **作者：hzoi_liuchang (赞：11)  4星**
    - **关键亮点**：先给出易想到但会超时的$O(n^2)$做法，再引出基于位运算拆分二进制位优化的$O(nlogn)$做法，逻辑连贯，代码简洁易懂。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,a[maxn],ans;
int f[300];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;++i){
        int now=1;
        for(int j=0;j<=30;j++){
            if(a[i]&(1<<j)){
                now=max(now,f[j]+1);
            } 
        }
        for(int j=0;j<=30;j++){
            if(a[i]&(1<<j)){
                f[j]=max(f[j],now);
            }
        }
       ans=max(ans,now);
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心实现思想**：对于每个数，先通过其为1的二进制位找到当前可得到的最大长度now，再用now更新对应二进制位的f值，同时更新全局答案ans。

### 最优关键思路或技巧
利用位运算的特性，将每个数按二进制位分解，通过记录每个二进制位为1时的子序列最大长度来优化动态规划的状态转移。避免了暴力枚举所有数对，将时间复杂度从$O(n^2)$降低到$O(nlogn)$。

### 可拓展思路
此类题目属于序列上的位运算DP问题，类似套路是分析位运算性质，结合二进制位状态进行状态定义和转移。同类型题通常会在序列操作、位运算条件上做变化。

### 推荐题目
- [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)：涉及状态压缩DP和位运算，在棋盘上放置棋子满足特定不相邻条件。
- [P2704 [NOI2001] 炮兵阵地](https://www.luogu.com.cn/problem/P2704)：同样是状态压缩DP，在地图上布置炮兵满足攻击范围和不重叠条件。
- [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)：通过状态压缩表示访问过的城市，用DP求解最优路径，涉及位运算操作。

### 个人心得摘录与总结
无。 

---
处理用时：36.33秒
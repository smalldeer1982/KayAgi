# 题目信息

# 浏览器

## 题目背景

\_\_stdcall在用Edge玩slay的时候，鼠标会经常失灵，这让她十分痛苦，因此她决定也要让你们感受一下Edge制造的痛苦。

## 题目描述

\_\_stdcall给了你n个点，第i个点有权值x[i]，对于两个点u和v，如果x[u] xor x[v]的结果在二进制表示下有奇数个1，那么在u和v之间连接一个Edge，现在\_\_stdcall想让你求出一共有多少个Edge。

如果你没能成功完成任务，那么\_\_stdcall会让你痛苦一下，你这个测试点就没分了。

## 说明/提示

我们用v表示权值中的最大值。

对于前20%的数据，n<=10。

对于前40%的数据，n<=100。

对于前60%的数据，n<=1000。

对于前80%的数据，n<=1e6。

对于前90%的数据，v<=1e6。

对于100%的数据，n<=1e7，v<=1e9。

保证a，b，c，d，x[0]都是int内的非负整数。

## 样例 #1

### 输入

```
8 98 24 20 100 44
```

### 输出

```
12
```

## 样例 #2

### 输入

```
1000 952537 601907 686180 1000000 673601
```

### 输出

```
249711
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效统计满足条件的边数展开。核心思路是利用异或运算后二进制中1个数的奇偶性与参与运算两数二进制中1个数奇偶性的关系，即当两数二进制中1的个数一奇一偶时，异或结果二进制中1的个数为奇数。
算法要点在于快速统计每个数二进制中1的个数，难点是如何在大规模数据下优化时间复杂度。部分题解通过不同方式实现$O(1)$时间复杂度统计1的个数来优化算法。

### 所选的题解
- **作者：__stdcall（5星）**
  - **关键亮点**：思路清晰，从低分到满分逐步分析，涵盖多种优化思路。详细阐述不同数据范围下的解法，包括暴力枚举、利用奇偶性统计以及通过拆分数字实现$O(1)$求popcnt优化到$O(n)$复杂度。
  - **个人心得**：无
  - **核心代码**：无（未给出具体代码）
  - **核心实现思想**：100pts解法中，利用类似【WC 2017 挑战】方法，将数字拆分成高16位和低16位，分开统计，预处理后实现$O(1)$求popcnt，从而使总复杂度降为$O(n)$。
- **作者：弦巻こころ（4星）**
  - **关键亮点**：先详细分析异或运算在二进制下的特征，得出通过判断两数二进制下1个数的奇偶性来确定边的存在，代码实现清晰，还介绍多种求数字二进制下1个数的方法。
  - **个人心得**：介绍多种求二进制下1个数的方法时，提及不同方法的特点及适用场景，如__builtin_parity函数虽快但NOIP不能用。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,a,b,c,d,n,tmp;
inline int getnum(int zz)
{
    tmp = 0;
    while(zz)
    {
      ++tmp;
      zz ^= (zz & (-zz));
    }
	return tmp;
}
long long sum1,sum2,tot[2];
int main()
{
	cin>>n>>a>>b>>c>>d>>x;
	a%=d,b%=d,c%=d,x%=d;
	long long y;
	for(int i=1;i<=n;i++)
	{
		++tot[getnum(x = ((a * x % d ) * x % d +b * x % d + c) % d) & 1];
	}
	printf("%lld",tot[0]*tot[1]);
	return 0;
}
```
  - **核心实现思想**：通过getnum函数统计每个生成数二进制下1的个数，根据奇偶性分别累加到tot数组中，最后返回奇数个数与偶数个数的乘积。
- **作者：囧仙（4星）**
  - **关键亮点**：通过数学推导严谨证明异或结果中1个数的奇偶性与两数1个数奇偶性的关系，给出利用预处理数组实现$O(1)$获取1个数的方法，代码简洁明了。
  - **个人心得**：无
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
int n,a,b,c,d,x;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int T[65536],p,q;
int main(){
    n=qread();
    a=qread(),b=qread(),c=qread(),d=qread(),x=qread();
    up(0,65535,i) T[i]=T[i>>1]+(i&1);
    up(1,n,i){
        x=((1ll*a*x%d+b)*x%d+c)%d;
        if((T[x>>16]+T[x&65535])&1) ++p; else ++q;
    }
    printf("%lld\n",1ll*p*q);
    return 0;
}
```
  - **核心实现思想**：预处理数组T记录0到$2^{16}-1$每个数二进制下1的个数，通过右移和按位与操作拆分生成数的高低16位，从T数组获取1的个数，根据奇偶性统计p和q，返回两者乘积。

### 最优关键思路或技巧
将数字拆分成高低16位，预处理低16位所有数二进制下1的个数，通过简单移位和按位与操作，实现$O(1)$获取每个数二进制下1的个数，从而将整体算法复杂度优化到$O(n)$。

### 可拓展之处
同类型题常考察位运算性质与优化统计的结合，类似算法套路是深入挖掘位运算在二进制下的特征，通过预处理、分治等策略优化统计过程。

### 相似知识点洛谷题目
- P1876 [USACO06NOV]玉米田Corn Fields：涉及位运算优化状态压缩动态规划。
- P1170 兔八哥与猎人：运用位运算处理状态，结合图论知识。
- P3143 [USACO16OPEN]248 G：通过位运算优化区间合并操作。

### 个人心得摘录与总结
弦巻こころ提到在NOIP中__开头的函数可能不能使用，提醒在竞赛中选择方法要考虑规则限制，同时介绍多种求二进制下1个数的方法及各自特点，让读者对不同实现有更全面认识。 

---
处理用时：42.88秒
# 题目信息

# [eJOI 2019] 异或橙子

## 题目描述

Janez 喜欢橙子！他制造了一个橙子扫描仪，但是这个扫描仪对于扫描的每个橙子的图像只能输出一个  $32$ 位整数。

他一共扫描了 $n$ 个橙子，但有时他也会重新扫描一个橙子，导致这个橙子的 $32$ 位整数发生更新。

Janez 想要分析这些橙子，他觉得异或操作非常有趣，他每次选取一个区间从 $l$  至 $u$，他想要得到这个区间内所有子区间的异或和的异或和。

例如 $l=2,u=4$ 的情况，记橙子序列 $A$ 中第 $i$ 个橙子的整数是 $a_i$，那么他要求的就是：

$$a_2 \oplus a_3 \oplus a_4 \oplus (a_2\oplus a_3)\oplus(a_3\oplus a_4)\oplus(a_2\oplus a_3 \oplus a_4)$$

-------------------------------------

注：式子中的 $\oplus$ 代表按位异或运算。异或的运算规则如下。

对于两个数的第 $i$ 位，记为 $x,y$，那么：

|$x$|$y$|$x\oplus y$|
| :-----------: | :-----------: | :-----------: |
|$0$|$1$|$1$|
|$1$|$0$|$1$|
|$0$|$0$|$0$|
|$1$|$1$|$0$|

例：$13\oplus 23=26$

|$13=$|$0\cdots 001101$|
| --------: | :------: |
|$23=$|$0\cdots 010111$|
|$13\oplus 23=$|$0\cdots 011010$|

## 说明/提示

#### 输入输出样例 1 解释

- 最初，$A=[1,2,3]$，询问结果为 $1\oplus 2\oplus 3\oplus(1\oplus 2)\oplus (2\oplus 3)\oplus(1\oplus 2\oplus 3)=2$

- 修改后，第一个位置被修改为 $3$ ，询问的结果是 $3\oplus 2\oplus 3\oplus(3\oplus 2)\oplus (2\oplus 3)\oplus(3\oplus 2\oplus 3)=0$。

----------------------------

#### 数据规模与约定：

**本题采用多测试点捆绑测试，共有 5 个子任务**。

- Subtask 1(12 points)：$1\le n,q\le 10^2$，无特殊限制
- Subtask 2(18 points)：$1\le n,q\le 5\times 10^2$，且没有修改操作。
- Subtask 3(25 points)：$1\le n,q\le 5\times 10^3$，无特殊限制
- Subtask 4(20 points)：$1\le n,q\le 2\times 10^5$，且没有修改操作。
- Subtask 5(25 points)：$1\le n,q\le 2\times 10^5$，无特殊限制

对于所有数据，$0\le a_i\le 10^9,1\le n,q\le 2\times 10^5$

--------------------------

#### 说明

原题来自：[eJOI2019](http://ejoi2019.si/) Problem A. [XORanges](https://www.ejoi2019.si/static/media/uploads/tasks/xoranges-isc(1).pdf)

题面&数据来自：[LibreOJ](https://loj.ac/problem/3195)

## 样例 #1

### 输入

```
3 3
1 2 3
2 1 3
1 1 3
2 1 3```

### 输出

```
2
0```

## 样例 #2

### 输入

```
5 6
1 2 3 4 5
2 1 3
1 1 3
2 1 5
2 4 4
1 1 1
2 4 4```

### 输出

```
2
5
4
4```

# AI分析结果

• 综合分析与结论：
    - 思路：多数题解先通过分析异或性质，得出当 \( l, u \) 奇偶性不同时答案为 \( 0 \)，相同时 \( [l, u] \) 中与 \( l \) 奇偶性相同位置的值对答案有贡献的结论。进而考虑使用数据结构维护以满足单点修改和区间查询操作。
    - 算法要点：利用树状数组或线段树。树状数组题解中，维护两棵树状数组，分别对应奇数、偶数位置信息，通过树状数组的基本操作实现单点修改和区间查询；线段树题解则对线段树上每个节点维护与其左端点奇偶性相同和不同的数的异或和，通过特定的pushup和query操作实现需求。
    - 解决难点：关键在于发现异或运算的性质，简化冗长的式子，明确不同位置元素对答案的贡献规律，从而选择合适的数据结构并设计相应维护方法。
    - 整体来看，各题解思路较为一致，主要区别在于实现的数据结构及代码细节。树状数组实现相对简洁高效，线段树实现虽复杂但更具拓展性。

所选的题解：
  - 作者：Lice (5星)
    - 关键亮点：思路清晰，先点明利用异或特殊性质简化式子，进而通过手玩样例得出奇偶性与答案关系的结论，代码简洁明了，很好地结合树状数组实现功能。
    - 重点代码：
```cpp
#include<cstdio>
using namespace std;

const int N=2e5+5;
int n,q,a[N];

#define lowbit(x) (x&(-x))
struct bit{
    int dat[N];
    inline void update(int x,int p){
        for(;p<=n;p+=lowbit(p)) dat[p]^=x;
    }
    inline int xor_sum(int p){
        int x=0;
        for(;p;p-=lowbit(p)) x^=dat[p];
        return x;
    }
};
#undef lowbit

bit tree[2];

signed main()
{
    scanf("%d%d",&n,&q);
    for(register int i=1;i<=n;i++)
        scanf("%d",a+i),tree[i&1].update(a[i],i);
    while(q--)
    {
        int opt,x,y;
        scanf("%d%d%d",&opt,&x,&y);
        if(opt==1) tree[x&1].update(a[x]^y,x),a[x]=y;
        else
        {
            if((x+y)&1) printf("0\n");
            else printf("%d\n",tree[x&1].xor_sum(y)^tree[x&1].xor_sum(x-1));
        }
    }
    return 0;
}
```
核心实现思想：定义树状数组结构体，通过update函数实现单点修改（利用异或性质，将新值与旧值异或后更新树状数组），xor_sum函数实现区间查询。主函数中根据输入操作，对奇数、偶数位置分别维护的树状数组进行相应操作。
  - 作者：Warriors_Cat (4星)
    - 关键亮点：从询问操作入手，通过定义 \( f_{l, r, i} \) 表示区间 \( [l, r] \) 包含 \( a_i \) 的子区间个数，利用乘法原理得出其表达式，进而分析奇偶性与答案关系，逻辑推导清晰，代码结构完整。
    - 重点代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n, m, a[200010], opt, x, y;
struct BIT{
    int c[200010];
    inline int lowbit(int x){return x & (-x);}
    inline void change(int x, int y){
        while(x <= n){
            c[x] ^= y;
            x += lowbit(x);
        }
    }//单点修改
    inline int query(int x){
        int ans = 0;
        while(x){
            ans ^= c[x];
            x -= lowbit(x);
        } 
        return ans;
    }//区间查询
}tree[2]; //写在结构体里，方便一些。
int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++i) scanf("%d", a + i), tree[i & 1].change(i, a[i]);//先维护原序列
    for(int i = 1; i <= m; ++i){
        scanf("%d%d%d", &opt, &x, &y);
        if(opt == 1) tree[x & 1].change(x, a[x] ^ y), a[x] = y;//记得改 a[x]
        else{
            if((x & 1) ^ (y & 1)) puts("0");
            else printf("%d\n", tree[x & 1].query(y) ^ tree[x & 1].query(x - 1));
        }
    }
    return 0;
}
```
核心实现思想：结构体BIT定义树状数组，change函数实现单点修改（同样利用异或性质更新），query函数实现区间查询。主函数初始化树状数组，根据操作类型对树状数组进行修改或查询操作。
  - 作者：Hexarhy (4星)
    - 关键亮点：先列出异或常见性质，结合题目区间实例化简式子，清晰阐述区间长度奇偶性与答案的关系，对树状数组的维护和操作讲解细致，代码注释详细。
    - 重点代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

const int MAXN=2e5+5;
int n,Q;
int a[MAXN];

class BIT
{
    private:
    int tree[MAXN];
    public:
    int lowbit(const int x)
    {
        return x&-x;
    }
    void modify(int pos,const int x)
    {
        for(;pos<=n;pos+=lowbit(pos))
         tree[pos]^=x;//维护异或和
    }
    int query(int pos)
    {
        int res=0;
        for(;pos;pos-=lowbit(pos))
         res^=tree[pos];//同理
        return res;
    }
}tree[2];//tree[0]是维护下标为偶数，tree[1]则是奇数

int main()
{
    ios_base::sync_with_stdio(false);
    cin>>n>>Q;
    for(int i=1;i<=n;i++)
     cin>>a[i];
    for(int i=1;i<=n;i++)
     tree[i&1].modify(i,a[i]);//建树
    while(Q--)
    {
        int opt,x,y;cin>>opt>>x>>y;
        if(opt==1)
        {
            tree[x&1].modify(x,a[x]^y);//解释过了
            a[x]=y;
        }
        if(opt==2)
        {
            int ans=0;
            if(!((x&1)^(y&1)))//l,r奇偶性相同
             ans=tree[x&1].query(y)^tree[x&1].query(x-1);
            cout<<ans<<endl; 
        }
    }
    return 0;
}
```
核心实现思想：类BIT定义树状数组，modify函数实现单点修改（利用异或实现值更新），query函数实现区间查询。主函数读入数据并初始化树状数组，根据操作类型执行相应修改或查询。

最优的关键思路或技巧：
    - 思维方式：利用异或运算的性质（如 \( a \oplus a = 0 \)， \( a \oplus 0 = a \) ）简化复杂式子，通过分析区间内元素出现次数的奇偶性来确定其对最终答案的贡献。
    - 数据结构：针对单点修改和区间查询操作，采用树状数组分别维护奇数、偶数位置的信息，能高效实现需求；线段树虽复杂，但在一些更复杂的区间问题中有独特优势，可维护更多信息。

可拓展之处：同类型题通常涉及对区间内元素某种运算（如异或、求和等）结果的查询以及单点或区间修改操作。类似算法套路是先分析运算性质简化问题，再选择合适数据结构维护。例如在一些涉及区间内元素状态变化，且需要频繁查询区间某种统计量的题目中，可借鉴本题思路。

推荐洛谷题目：
    - P3374 【模板】树状数组 1：基础的树状数组单点修改和区间查询题目，可巩固树状数组基础操作。
    - P3368 【模板】树状数组 2：涉及区间修改和单点查询，与本题对树状数组的运用有相似之处，可拓展树状数组应用能力。
    - P1908 逆序对：利用树状数组统计逆序对数量，与本题一样，需结合特定算法（归并排序思想）和树状数组解决问题。 

---
处理用时：51.21秒
# 题目信息

# [yLOI2020] 泸沽寻梦

## 题目背景

> 我应是泸沽烟水里的过客，  
> 孑然弹铗，划天地开阖。  
> 邂逅过的，梦醒之余，  
> 却忘了该如何洒脱。 

——银临《泸沽寻梦》

## 题目描述

> 南有仙地，名曰摩梭，摩梭有湖，泸沽是也。

茶茶在泸沽湖中寻找自己的梦。氤氲雾气中，茶茶的 $n$ 个梦排成了一个序列。茶茶的所有梦境都是拉瓦的样子。为了区分这些拉瓦，茶茶规定从左到右第 $i$ 个的拉瓦的美颜值是一个非负整数 $a_i$。面对着这些梦，茶茶会进行 $m$ 次操作，每次操作会给定两个数字 $p,x$，然后将 $a_p$ 和 $a_{p+1}$ 都对 $x$ 做按位异或。每次操作完之后，茶茶都想知道，当前的梦序列中，有多少个子区间 $[l,r]$，满足 $l \le r$ 且区间的异或和为 $0$，请你回答茶茶的问题。

区间 $[l,r]$ 的异或和定义为 $a_l \otimes a_{l + 1} \otimes \dots a_{r - 1} \otimes a_r$。其中 $\otimes$ 代表二进制按位异或运算，即 C++ 语言的「^」运算符。两个区间不同当且仅当两区间左端点不同或两区间右端点不同或两区间左右端点均不同。

为了避免输出过大，你只需要输出四个整数，分别表示你所有回答的按位异或之和、你共有多少次回答的答案是奇数，你的所有答案中的最大值、你的所有答案中的最小值。

## 说明/提示

### 样例 1 解释

- 第一次操作后，序列变为 ${2,1,3,4,5}$，有且仅有区间 $[1,3]$ 的异或和为 $0$，故本次询问的答案为 $1$。
- 第二次操作后，序列变为 ${2,2,0,4,5}$，区间 $[1,2]$、$[1,3]$、$[3,3]$ 的异或和为 $0$，故本次询问的答案为 $3$。
- 第三次操作后，序列变为 ${2,2,3,7,5}$，有且仅有区间 $[1,2]$ 的异或和为 $0$，故本次询问的答案为 $1$。所有答案的异或和为 $3$，有 $3$ 次回答的答案为奇数，所有答案中的最大值为 $3$，最小值为 $1$。

### 数据规模与约定

**本题采用多测试点捆绑测试**，共有 5 个子任务。

- 子任务 $1$（$10$ 分）：保证 $n,m \le 100$。
- 子任务 $2$（$10$ 分）：保证 $n,m \le 300$。
- 子任务 $3$（$20$ 分）：保证 $n,m \le 3000$。
- 子任务 $4$（$30$ 分）：保证 $n,m \le 10^5$。
- 子任务 $5$（$30$ 分）：无特殊限制。

对于前四个子任务，保证 $a_i,x \le n$；  
对于全部的测试点，保证 $1 \le n,m \le 10^6$，$0 \le a_i,x \le 10^9$，$1 \le p<n$。

### 提示

- 请注意，$a_i,x \leq Y$ 不能说明 $a_i \otimes x \leq Y$。
-  请注意大量数据读入对程序效率造成的影响。
- 本题的特殊输出方式只是为了避免输出过大造成程序超时，与本题解法无关。
- 请注意常数因子对程序效率造成的影响。
- 本题共有两个样例文件，请见附加文件中的 dream.zip。

## 样例 #1

### 输入

```
5 3
1 2 3 4 5
1 3
2 3
3 3```

### 输出

```
3
3
3
1```

# AI分析结果

• 综合分析与结论：这些题解的核心思路都是利用异或的性质，将区间异或和为0的问题转化为前缀异或和相等的问题，通过维护前缀异或和出现的次数来统计答案。对于修改操作，利用异或的特性发现每次修改仅影响一个前缀异或和的值，从而实现高效更新。算法要点在于前缀异或和的计算与维护，以及对前缀异或和出现次数的统计。难点在于如何优化统计和修改的过程，以满足大数据规模的要求。大部分题解都采用了哈希表（如`unordered_map`）来实现高效的统计和修改，时间复杂度为$O(n + m)$。

所选的题解：
  - 作者：hzoi_liuchang (5星)
    - 关键亮点：思路清晰，简洁明了地阐述了将问题转化为前缀异或和相等的思路，以及修改操作仅影响一个前缀异或和的要点。代码实现高效，采用了自定义哈希表结构，并使用了快速读入优化。
    - 重点代码及核心思想：
```cpp
// 自定义哈希表结构
struct asd{
    int val,nxt,cnt;
}b[maxn*8];
// 插入或更新哈希表中元素
void ad(int num,int val){
    rg int now=num%mod;
    for(rg int i=h[now];i!=-1;i=b[i].nxt){
        if(num==b[i].val){
            ans-=js(b[i].cnt);
            b[i].cnt+=val;
            ans+=js(b[i].cnt);
            return;
        }
    }
    b[tot].nxt=h[now];
    b[tot].val=num;
    b[tot].cnt=1;
    h[now]=tot++;
}
```
核心思想是通过自定义哈希表结构`asd`，实现对前缀异或和出现次数的高效管理，`ad`函数用于插入新的前缀异或和或更新已有前缀异或和的出现次数，并同时更新答案。

  - 作者：一扶苏一 (4星)
    - 关键亮点：全面地分析了从暴力到优化的多种算法思路，涵盖了不同数据规模下的解法，使读者能系统地理解问题的解决过程。代码展示了两种优化思路，一种直接使用`std::unordered_map`做桶，另一种是先离线跑修改再离散化。
    - 重点代码及核心思想（以`std::unordered_map`做桶为例）：
```cpp
// 前缀异或和计算与答案初始化
++bk[0];
for (int i = 1; i <= n; ++i) {
    ans += bk[s[i] = s[i - 1] ^ a[i]]++;
}
// 修改操作及答案更新
for (int i = 1, p, x; i <= m; ++i) {
    p = x = 0; qr(p); qr(x);
    ans -= --bk[s[p]];
    ans += bk[s[p] ^= x]++;
    o ^= ans;
    if (ans & 1) ++u;
    v = (v > ans)? v : ans;
    w = (w < ans)? w : ans;
}
```
核心思想是先通过前缀异或和计算并初始化答案，在每次修改操作时，先减去原前缀异或和对答案的贡献，再加上修改后前缀异或和对答案的贡献，同时按照题目要求更新各项统计值。

  - 作者：苹果蓝17 (4星)
    - 关键亮点：详细地分析了从暴力解法到优化解法的过程，逐步引导读者理解如何利用前缀异或和以及`map`（实际实现用`unordered_map`）来解决问题，对异或性质的运用讲解清晰。
    - 重点代码及核心思想：
```cpp
// 前缀异或和计算与答案初始化
mp[0]++;
for(int i=1;i<=n;i++){
    int a;
    scanf("%d",&a);
    s[i]=s[i-1]^a;
    ans+=mp[s[i]],mp[s[i]]++;
}
// 修改操作及答案更新
for(int i=1;i<=m;i++){
    int p,x;
    scanf("%d%d",&p,&x);
    ans-=mp[s[p]]-1,mp[s[p]]--;
    ans+=mp[s[p]^x],mp[s[p]^x]++;
    s[p]^=x;
    ansxor^=ans;
    if(ans & 1ll) ansj++;
    ansmax=max(ansmax,ans);
    ansmin=min(ansmin,ans); 
}
```
核心思想是先计算前缀异或和并初始化答案，在修改时，先减去原前缀异或和对答案的贡献，再加上修改后的前缀异或和对答案的贡献，同时更新各项统计值。

最优关键思路或技巧：利用异或的结合律、交换律以及$x \oplus x = 0$的性质，将区间异或和为0的问题转化为前缀异或和相等的问题，通过哈希表（如`unordered_map`）高效维护前缀异或和出现的次数，实现$O(1)$时间复杂度的插入、查询和修改操作，从而将整体时间复杂度优化到$O(n + m)$。

可拓展之处：同类型题通常围绕位运算（特别是异或）与区间操作展开，类似算法套路是利用位运算的性质进行问题转化，通过前缀和（这里是前缀异或和）简化区间计算，再结合合适的数据结构（如哈希表、线段树等）处理动态修改和查询。

推荐洛谷题目：
  - P3370 【模板】字符串哈希，考察字符串哈希与异或运算的应用。
  - P1558 色板游戏，涉及区间修改和查询，可利用类似前缀异或和思路解决。
  - P4587  [FJOI2016]神秘数，需要结合前缀和与异或运算的性质来求解。

个人心得摘录及总结：
  - “我在比赛的时候居然在想权值线段树，wtcl”，作者感慨比赛时思路偏差，提醒在解题时要准确把握问题核心，避免陷入复杂且不必要的思路。 

---
处理用时：37.46秒
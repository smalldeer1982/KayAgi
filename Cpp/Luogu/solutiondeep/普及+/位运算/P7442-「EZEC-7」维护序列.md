# 题目信息

# 「EZEC-7」维护序列

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/lo9tuyl9.png)](https://www.luogu.com.cn/paste/tdqr0sto)

可怜的 dead_X 收不了歌，于是他出了个水题并给参赛者送了 $100$ 分。

2022 Update: 已经收了，很水。

## 题目描述

你需要维护一个序列。

这个序列开始时有 $2^n$ 个数，下标从 $0$ 开始。第 $i$ 个数初始值为 $i$，需要支持以下三种操作：

* 定义 $a$ 为所有下标为偶数的数组成的子序列，$b$ 为所有下标为奇数的数组成的子序列，将 $a,b$ 连接，构成新的序列。
* 定义 $a$ 为所有下标为奇数的数组成的子序列，$b$ 为所有下标为偶数的数组成的子序列，将 $a,b$ 连接，构成新的序列。
* 查询下标为 $x$ 的数。

总共将进行 $m$ 次操作。

## 说明/提示

**【样例解释】**

所有操作前后的序列从左至右的数如下：
$$\{0,1,2,3\}$$
下标为 $0$ 的数为 $0$。
$$\{0,2\},\{1,3\}$$
$$\{0,2,1,3\}$$
下标为 $1$ 的数为 $2$。
$$\{2,3\},\{0,1\}$$
$$\{2,3,0,1\}$$
下标为 $2$ 的数为 $0$。
$$\{2,0\},\{3,1\}$$
$$\{2,0,3,1\}$$
下标为 $3$ 的数为 $1$。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（10 points）：不存在 $op=1$ 的操作。
- Subtask 2（10 points）：$n\leq 10，m\leq 10^3$。
- Subtask 3（20 points）：$n\leq 10$。
- Subtask 4（20 points）：$m\leq 10^3$。
- Subtask 5（20 points）：对于 $op=1$ 的操作，$x=0$。
- Subtask 6（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 32$，$1\leq m\leq 10^6$。

若 $op=1$，$x\in\{0,1\}$，若 $op=2$，$0\leq x<2^n$。

## 样例 #1

### 输入

```
2 7
2 0
1 0
2 1
1 1
2 2
1 0
2 3```

### 输出

```
0
2
0
1```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均是通过分析操作对序列下标的影响，利用二进制运算特性来避免直接维护庞大序列，从而优化时间复杂度。主要差异在于对操作规律的总结方式和代码实现细节。
1. **思路**：多数题解发现操作与二进制位运算相关，操作1类似将二进制首位移到末位，操作2在此基础上对末位异或1。通过记录操作次数及相关标志，对查询下标逆向推导得到原始值。
2. **算法要点**：利用位运算实现快速的下标变换，避免 $O(nm)$ 的暴力模拟。同时注意操作次数循环及标志位的更新。
3. **解决难点**：避免直接维护巨大序列，通过数学规律优化算法。关键在于发现操作与二进制位移动、异或操作的联系。

### 所选的题解
- **作者：0x3F (5星)**
    - **关键亮点**：思路清晰，对两种操作规律总结简洁明了，通过观察二进制下标的变化，得出操作1是将二进制位按环逆时针旋转一格，操作2是在此基础上对末位异或1。代码简洁高效，利用位运算实现，时间复杂度为 $O(m)$，并注意使用 `unsigned int` 处理数据范围。
    - **重点代码核心思想**：用 `cnt` 记录操作1的次数，`y` 记录需要异或的值。操作1时更新 `cnt` 和 `y`，查询时根据 `cnt` 对 `x` 进行位旋转并异或 `y` 得到结果。
    ```cpp
    int n, m, o;
    unsigned x, y;
    int cnt;
    int main() {
        n = read();
        m = read();
        while (m--) {
            o = read();
            x = read();
            if (o == 1) {
                if (x) {
                    y = y ^ (1<<cnt);
                }
                cnt++;
                if (cnt == n) cnt = 0;
            } else {
                if (cnt) write(((x>>(n-cnt))|((x&((1<<(n-cnt))-1))<<cnt))^y);
                else write(x^y);
                putchar(10);
            }
        }
        return 0;
    }
    ```
- **作者：dead_X (4星)**
    - **关键亮点**：对不同子任务分别分析，逐步引导出通用解法。从分析数在下标变化的规律入手，结合二进制表示，将操作抽象为环中翻转某一位，通过异或维护修改对下标的影响，实现简洁。
    - **重点代码核心思想**：`cnt` 记录操作1次数，`t` 记录异或值。操作1时根据条件更新 `t` 和 `cnt`，查询时对 `x` 进行位运算并异或 `t` 得到结果。
    ```cpp
    int n=read(),m=read(),cnt=0;
    ull t=0,g=(1ull<<n)-1;
    for(;m--;)
    {
        int op=read();
        ull x=read64();
        if(op==1) (x==1)&&(t^=1ull<<(cnt%n)),(++cnt>=n)&&(cnt-=n);
        else printf("%llu\n",(((x+(x<<n))>>((n-cnt)%n))&g)^t);
    }
    ```
- **作者：water_tomato (4星)**
    - **关键亮点**：详细解析操作实质，对二进制下标的变化阐述清晰。提前处理全1数方便后续位运算，代码注释详细，易于理解。
    - **重点代码核心思想**：`cnt` 记录操作1次数，`v` 记录异或标记。操作1更新 `v` 和 `cnt`，查询时对 `x` 进行位移动合并操作后异或 `v` 输出。
    ```cpp
    for(int i=1;i<=n;i++) t[i]=(t[i-1]<<1)+1;
    for(int i=1;i<=m;i++){
        scanf("%lld%lld",&opt,&x);
        if(opt==1){
            v^=x<<cnt;
            cnt++;
            if(cnt==n) cnt=0;
        }
        else{
            printf("%lld\n",(((x&t[n-cnt])<<cnt)|(x>>(n-cnt)))^v);
        }
    }
    ```

### 最优关键思路或技巧
1. **思维方式**：从二进制角度观察操作对下标的影响，将复杂的序列操作转化为简单的位运算，这是优化算法的关键。
2. **代码实现技巧**：用变量记录操作次数和异或标记，在查询时通过位运算逆向推导原始下标值，避免了对序列的实际重组。

### 可拓展之处
同类型题或类似算法套路：此类题目通常涉及对大规模数据序列的操作，特点是操作具有一定规律性，可通过数学方法（如二进制运算、数论等）优化。常见套路是分析操作对数据下标的影响，转化为位运算或其他数学运算，避免暴力模拟。

### 相似知识点洛谷题目
1. **P1514 引水入城**：涉及对二维矩阵数据的操作，需分析水流方向规律，运用类似思维寻找最优解。
2. **P2678 [NOIP2015 提高组] 跳石头**：通过分析跳跃距离与石头位置关系，利用二分查找优化求解，与本题分析操作与下标关系优化算法思路类似。
3. **P3398 仓鼠找sugar**：需要分析树上路径关系，结合位运算等技巧优化算法，锻炼对数据关系的分析及优化能力。

### 个人心得摘录与总结
1. **0x3F**：开始认为题目难，做了半小时，结果第二题反而简单。此心得体现做题时心态及对题目难度预估的重要性，不能因开始的困难而放弃后续题目。 

---
处理用时：36.10秒
# 题目信息

# [KSN2021] Binary Land

## 题目描述

给定一张 $N$ 个点的图，每个点有权值 $A_i$ 和价值 $B_i$。

两个点 $x,y$ 之间存在一条无向边当且仅当 $A_x\text{ xor }A_y>\max(A_x,A_y)$。

你需要对于 $i=1,2,\cdots n$ 依次求出点 $i$ 所在连通块中所有点的价值和。

## 说明/提示

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（8 points）：只存在一组数据，满足 $N=8$，$A=[6,39,11,63,3,39,1,43]$，$B=[4,8,3,7,9,1,2,2]$。
- Subtask 2（13 points）：保证 $N \leq 200$。
- Subtask 3（10 points）：保证 $N \leq 2000$。
- Subtask 4（4 points）：保证 $A_1=A_2=\cdots=A_n$。
- Subtask 5（7 points）：保证存在非负整数 $k$ 使得 $A_i=2^k$。
- Subtask 6（19 points）：$A_i\leq 2^{12}-1$。
- Subtask 7（39 points）：无特殊限制。

对于所有数据，$1 \leq N \leq 10^5$，$1 \leq A_i \leq 2^{30}-1$，$1 \leq B_i \leq 10^9$。

## 样例 #1

### 输入

```
3
2 1 1
20 30 10```

### 输出

```
60
60
60```

## 样例 #2

### 输入

```
4
5 4 4 5
10 20 30 40```

### 输出

```
10
20
30
40```

## 样例 #3

### 输入

```
5
1 2 1 7 11
20 10 30 100 100```

### 输出

```
60
60
60
200
200```

# AI分析结果

• 综合分析与结论：
    - 这些题解都围绕根据条件 $A_x\text{ xor }A_y>\max(A_x,A_y)$ 优化建图，再用并查集或DFS求连通块价值和。
    - 思路上，都利用拆位处理，分析异或条件与二进制位关系。算法要点是通过预处理二进制位状态，减少建边枚举量。难点在于理解并证明异或条件与二进制位特定关系，以及优化建边复杂度。
    - 各题解质量差异在于思路清晰度、代码可读性和优化程度。有的题解详细证明关键结论，有的代码简洁且优化程度高。

所选的题解：
  - **作者：EXODUS (5星)**
    - **关键亮点**：详细证明异或条件与二进制位关系，思路清晰。通过多维护30个并查集，利用预处理的二进制位状态，$O(1)$ 判断并合并连通块，优化建边复杂度。代码虽未按秩合并，但整体思路明确。
    - **重点代码**：
```cpp
int find(int i){while(i!=fa[i])i=fa[i]=fa[fa[i]];return i;}
void merge(int x,int y){x=find(x),y=find(y);if(x==y)return;fa[x]=y,sum[y]+=sum[x];}
// 核心实现思想：并查集的查找与合并操作，查找时路径压缩，合并时更新连通块价值和
```
  - **作者：Jairon314 (4星)**
    - **关键亮点**：详细证明异或条件与二进制位关系，逻辑严谨。使用启发式合并的并查集，复杂度较低。代码结构清晰，利用自定义函数处理二进制位操作。
    - **重点代码**：
```cpp
struct dsu{
    int Siz;
    vii par,siz,val;
    dsu(){}
    dsu(int n):Siz(n),par(n + 1),siz(n + 1),val(n + 1){ FOR(i,1,n){ siz[i]=1,par[i]=i,val[i]=B[i]; } }
    int find(int x){ return x==par[x]?par[x]:par[x]=find(par[x]); }
    bool same(int u,int v){ return find(u)==find(v); }
    int count(int x){ return siz[find(x)]; }
    int get_val(int x){ return val[find(x)]; }
    void unite(int u,int v){
        u=find(u),v=find(v);
        if(u==v){ return; }
        if(siz[u]<siz[v]){ swap(u,v); }
        val[u]+=val[v]; siz[u]+=siz[v]; par[v]=u;
        return;
    }
};
// 核心实现思想：自定义并查集结构体，包含查找、合并、判断是否同集合、获取集合大小和价值和等操作
```
  - **作者：NATO (4星)**
    - **关键亮点**：对特殊子任务分析透彻，逐步引出正解思路。按位考虑，通过记录最高位信息，用并查集合并连通块，复杂度合理。
    - **重点代码**：
```cpp
ll find(ll x)
{
    return x==f[x]?x:f[x]=find(f[x]);
}
void merge(ll a,ll b)
{
    if(find(a)==find(b))return;
    sum[find(b)]+=sum[find(a)];cv[find(b)]|=cv[find(a)];f[find(a)]=find(b);
}
// 核心实现思想：并查集的查找与合并操作，合并时更新连通块价值和与最高位信息
```

最优关键思路或技巧：
    - **思维方式**：将异或条件转化为二进制位关系，通过分类讨论、反证法等证明，从而找到优化建边依据。
    - **数据结构**：利用并查集维护连通块，通过启发式合并或路径压缩优化复杂度。
    - **代码实现技巧**：预处理二进制位状态，如记录每一位是否有最高位在此的数，或某数对应位是否为0，从而快速判断连边关系。

可拓展之处：
    - 同类型题常涉及位运算与图论结合，如根据特定位运算条件建图求连通性、最短路径等。类似算法套路是遇到位运算条件，考虑拆位分析，利用二进制位特性优化操作。

推荐洛谷题目：
    - P1525 [NOIP2010 提高组] 关押罪犯：涉及并查集与贪心思想，类似本题利用数据结构解决图相关问题。
    - P3367 【模板】并查集：基础并查集模板题，可巩固并查集操作。
    - P1197 [JSOI2008] 星球大战：并查集与图的动态操作结合，与本题对图结构的维护有相似之处。

个人心得：
    - **作者：ycy1124**：考场想到正解但因细节挂分。总结：复杂算法实现时要注意细节，如连边方向、条件判断等，写完需仔细检查。 

---
处理用时：33.69秒
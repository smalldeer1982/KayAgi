# 题目信息

# 「MCOI-08」Fill In REMATCH

## 题目描述

Dream 有一个长度为 $n$（$1\le n\le 10^5$）的整数数组 $a_1,a_2,\dots,a_n$，其中对于 $i=1,2,\dots,n$，满足 $0\le a_i<2^{60}$。

他计算了前缀异或数组 $p_i=a_1\oplus a_2\oplus\dots\oplus a_i$ 以及后缀异或数组 $s_i=a_i\oplus a_{i+1}\oplus\dots\oplus a_n$。

现在 Tommy **一共**将 $p$ 和 $s$ 的 $n$ 个元素换成 $-1$。给定当前的 $p$ 与 $s$ 数组，请恢复任意一组可能为原数组的 $a_1,a_2,\dots,a_n$。

保证存在一组合法解。

## 说明/提示

对于 $100\%$ 的数据，$1\le n,\sum n\le 10^5$，$\sum [p_i=-1]+\sum [s_i=-1]=n$，**保证有合法解。**

 - Subtask 1（10 pts）：$n\le 4$，$p_i,s_i<2$；
 - Subtask 2（10 pts）：$n\le 100$；
 - Subtask 3（20 pts）：$p_i,s_i<2$；
 - Subtask 4（60 pts）：无特殊限制。


## 样例 #1

### 输入

```
1
4
-1 34 367 -1
3178 -1 -1 3333```

### 输出

```
3 33 333 3333```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是利用异或运算的性质（归零律 $a \oplus a = 0$、恒等律 $a \oplus 0 = a$、结合律 $a \oplus b \oplus c = a \oplus (b \oplus c) = (a \oplus b) \oplus c$）以及前缀异或数组 $p$ 和后缀异或数组 $s$ 的关系来还原原数组 $a$。算法要点在于先求出所有数的异或和 $sum$（或记为 $E$、$x$ 等），再通过 $sum$ 来还原 $p$ 和 $s$ 数组，最后根据 $a_i = p_i \oplus p_{i - 1} = s_i \oplus s_{i + 1}$ 求出原数组 $a$。解决难点在于如何利用已知条件（$p$ 和 $s$ 数组中总共 $n$ 个 $-1$）求出 $sum$ 以及处理 $p_i$ 和 $s_{i + 1}$ 都为 $-1$ 的情况。

整体来看，大部分题解思路清晰，但在代码可读性和优化程度上有所差异。部分题解通过详细推导异或性质和数组关系，使思路更易理解；部分题解代码简洁但注释较少。

### 所选的题解
- **作者：Anxiomgh（5星）**
    - **关键亮点**：思路阐述极为清晰，从异或运算性质出发，详细推导得出多个引理，如 $a_i = p_i \oplus p_{i - 1} = s_i \oplus s_{i + 1}$，$p_i \oplus s_{i + 1} = sum$ 等，并对关键结论进行严谨证明，如证明存在 $i$ 使得 $p_i \neq -1$ 且 $s_{i + 1} \neq -1$。代码结构清晰，将核心功能封装成函数，可读性高。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：通过 `find` 函数找到一组 $p_i$ 和 $s_{i + 1}$ 都不为 $-1$ 的值来计算 $sum$；`update` 函数根据 $sum$ 还原 $p$ 和 $s$ 数组；最后通过遍历 $p$ 数组利用 $a_i = p_i \oplus p_{i - 1}$ 求出原数组 $a$。
```cpp
ll find(int n) //查找 
{
    for (int i = 0; i <= n; i++)
        if (p[i]!= -1 && s[i + 1]!= -1)
            return p[i] ^ s[i + 1];
}

void update(ll val, int n) //还原 
{
    for (int i = 0; i <= n; i++)
    {
        if (p[i]!= -1 && s[i + 1] == -1) 
            s[i + 1] = val ^ p[i];
        else if (p[i] == -1 && s[i + 1]!= -1) 
            p[i] = val ^ s[i + 1];
        else if (p[i] == -1 && s[i + 1] == -1)
        {
            p[i] = p[i - 1];
            s[i + 1] = val ^ p[i];
        }
    }
}

int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        int n;
        cin >> n;
        for (int i = 1; i <= n; i++) cin >> p[i];
        for (int i = 1; i <= n; i++) cin >> s[i];
        
        ll sum = find(n); //查找所有数异或的结果，记为 sum 
        
        update(sum, n); //还原 p 数组和 s 数组 

        for (int i = 1; i <= n; i++)
            cout << (p[i] ^ p[i - 1]) << " "; //用 p 数组求原数组的值，也可以用 s 数组 
        cout << endl;
    }
    return 0;
}
```
- **作者：我是逍逍（4星）**
    - **关键亮点**：简洁明了地阐述思路，通过异或性质推出 $p_i \oplus s_{i + 1} = E$ 以及 $a_i, p_i, s_i$ 知二求三的关系。代码简洁，对未知量的处理方式说明清晰。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：先找到一组 $p_i$ 和 $s_{i + 1}$ 都不为 $-1$ 的值计算出 $E$，然后根据 $E$ 还原 $p$ 和 $s$ 数组，最后通过遍历 $p$ 数组利用 $a_i = p_i \oplus p_{i - 1}$ 求出原数组 $a$。
```cpp
int main() {
    scanf("%lld", &t);
    
    while (t--) {
        scanf("%lld", &n);
        
        for (int i = 1; i <= n; i++) 
            scanf("%lld", &p[i]);
        for (int i = 1; i <= n; i++) 
            scanf("%lld", &s[i]);
        
        for (int i = 0; i <= n; i++) 
            if (p[i]!= -1 && s[i + 1]!= -1) {
                E = p[i] ^ s[i + 1];
                break;
            }
        
        for (int i = 0; i <= n; i++) {
            if (p[i] == -1 && s[i + 1]!= -1)
                p[i] = E ^ s[i + 1];
            else if (p[i]!= -1 && s[i + 1] == -1) 
                s[i + 1] = E ^ p[i];
            else if (p[i] == -1 && s[i + 1] == -1) 
                p[i] = 1;
            if (i)
                printf("%lld ", p[i] ^ p[i - 1]);
        }
        puts("");
    }
}
```
- **作者：Otomachi_Una_ （4星）**
    - **关键亮点**：快速得出关键结论 $a_i = p_i \bigoplus p_{i - 1} = s_i \bigoplus s_{i + 1}$ 并进行变形，利用题目条件找到 $t = p_i \bigoplus s_{i + 1}$，进而提出合理的构造方法，代码简洁易懂。
    - **个人心得**：考场上思考30分钟，体现思考过程。
    - **重点代码 - 核心实现思想**：先找到 $t = p_i \bigoplus s_{i + 1}$，然后根据 $t$ 还原 $p$ 和 $s$ 数组，最后通过遍历 $p$ 数组利用 $a_i = p_i \bigoplus p_{i - 1}$ 求出原数组 $a$。
```cpp
int main(){
    cin>>T;
    while(T--){
        cin>>n;
        for(int i=1;i<=n;i++) cin>>s[i];
        for(int i=1;i<=n;i++) cin>>t[i];
        ll xx=-1;
        for(int i=0;i<=n;i++) if(s[i]!=-1&&t[i+1]!=-1) xx=s[i]^t[i+1];
        if(xx==-1) xx=0;
        for(int i=0;i<=n;i++)
            if(s[i]!=-1) t[i+1]=xx^s[i];
            else if(t[i+1]!=-1) s[i]=xx^t[i+1];
            else s[i]=0,t[i+1]=xx;
        for(int i=1;i<=n;i++)
            cout<<(s[i]^s[i-1])<<" ";
        cout<<endl;
    }
}
```

### 最优关键思路或技巧
1. **利用异或运算性质**：归零律、恒等律和结合律是解决本题的基础，通过这些性质推导出数组元素之间的关系，如 $a_i = p_i \oplus p_{i - 1} = s_i \oplus s_{i + 1}$ 以及 $p_i \oplus s_{i + 1}$ 为定值等关键结论。
2. **根据条件确定关键值**：利用题目中 $p$ 和 $s$ 数组总共 $n$ 个 $-1$ 的条件，通过鸽巢原理等方式确定所有数的异或和 $sum$，这是还原数组的关键步骤。
3. **合理处理未知值**：对于 $p_i$ 和 $s_{i + 1}$ 都为 $-1$ 的情况，通过设其中一个为 $0$ 或其他特殊值（如整体异或和），使问题简化且不影响最终结果。

### 可拓展之处
同类型题或类似算法套路：此类题目通常围绕位运算（特别是异或运算）和数组的关系展开。常见套路是给出数组经过某种位运算处理后的结果数组（如前缀异或和、后缀异或和等），并设置部分未知值，要求还原原数组或求解相关问题。解题时需深入挖掘位运算性质以及数组元素间通过位运算建立的内在联系，利用已知条件确定关键值，进而解决问题。

### 相似知识点洛谷题目
1. **P1508 Likecloud - 吃、吃、吃**：通过前缀异或和处理区间异或问题，考察对异或运算性质及前缀异或和的应用。
2. **P4151 [WC2011]最大XOR和路径**：涉及图上路径的异或和问题，需要结合异或运算性质和图的遍历求解，与本题利用异或运算解决数组问题思路相似。
3. **P3812 【模板】线性基**：线性基是处理异或问题的重要工具，本题虽未直接涉及线性基，但异或运算性质是基础，可拓展相关知识点。 

---
处理用时：78.08秒
# 题目信息

# 「SWTR-8」美元巨大

## 题目背景

#### 输出不允许有前导零。

原题目名称为「美元巨大二的二的二的二的二」。

小 A 喜欢用形如
$$
\Huge 2 ^ {2 ^ {2 ^ {2 ^ {2}}}}
$$
的幂塔把小 T 的博客炸掉。

## 题目描述

小 A 有 $n$ 个 $2$ 的幂 $a_1, a_2, \cdots, a_n$。他要在这些数之间插入 $x$ 个异或运算符和 $y$ 个或运算符，组成一个表达式。保证 $x + y = n - 1$。

表达式越大，越有可能炸掉小 T 的博客。小 A 希望 **从左往右** 计算表达式时它的值最大。他想知道表达式最大可能的取值是多少，用二进制表示。他还希望你构造出这样的表达式，因为他懒得自己构造了。

若存在多组构造方案，输出任意一组。

多组测试数据。

## 说明/提示

**「评分方式」**

对于每组测试数据：

- 若你输出的第一行比标准答案劣，得 0 分。
- 若你输出的第一行比标准答案优，则 checker 将检查你的构造方案是否正确。若正确，则返回 `_fail`，表现为测试点 UKE；否则得 0 分。
- 否则，你输出的第一行和标准答案一样。若构造方案不正确，得 0.6 分；否则得 1 分。

每个测试点的得分为测试点内所有测试数据的得分的最小值乘以该测试点的分值。

注意，checker 能检测出你的答案比标准答案优的前提是输出完全符合格式。**一旦输出不符合格式，得 0 分**。格式限制包括但不限于：

- 第一行不得输出除 `0` 和 `1` 以外的字符。
- 第二行不得输出除 `^` 和 `|` 以外的字符，且字符串长度恰为 $n - 1$。
- `^` 的个数恰为 $x$，`|` 的个数恰为 $y$。

**「数据范围与约定」**

- 测试点 #1（10 points）：所有 $b_i$ 互不相等。
- 测试点 #2（20 points）：所有 $b_i$ 相等。
- 测试点 #3（30 points）：$n \leq 8$。
- 测试点 #4（25 points）：$n \leq 10 ^ 3$。
- 测试点 #5（15 points）：无特殊限制。

对于 $100\%$ 的数据：

- $1\leq T\leq 20$。
- $1 \leq n \leq 2.5 \times 10 ^ 4$。
- $0 \leq x, y < n$，$x + y = n - 1$。
- $1\leq a_i < 2 ^ {2 ^ {2 ^ {2 ^ 2}}}$，即 $0\leq b_i < 65536$。

**「帮助与提示」**

- 关于 [位运算](https://oi-wiki.org/math/bit/)。
- 请注意 IO 优化。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) B
- Idea & Solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。
- Tester：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
4
4 0 3
1 0 6 4
8 5 2
1 5 5 7 1 5 5 7
1 0 0
15
4 3 0
65535 65535 57 57
```

### 输出

```
1010011
|||
10100000
^|^^^^|
1000000000000000

0
^^^
```

# AI分析结果

• 综合分析与结论：这些题解均采用贪心策略解决该问题，核心思路是利用或运算和异或运算的性质，通过合理安排运算符使结果最大。要点在于按位考虑，统计每个二进制位上1的出现次数，根据奇偶性和剩余运算符情况进行处理。难点主要是如何在满足运算符数量限制下，构造出最优表达式。
- 思路方面，都基于或运算能使结果更大的特性，尽量在高位使用或运算。
- 算法要点，大多通过数组记录二进制位出现次数、位置等信息，从高位到低位贪心分配运算符。
- 解决难点上，关键在于合理分配异或和或运算符，处理好奇偶情况及剩余运算符的放置。

所选的题解：
  - 作者：Alex_Wei (5星)
    - 关键亮点：思路清晰简洁，直接点明或比异或更能使结果变大的核心性质，按位从大到小贪心，代码简洁高效。
    - 核心代码实现思想：用数组统计每个数出现次数和最后出现位置，从高位到低位遍历，对出现奇数次的位直接置1，偶数次且有剩余或运算符时，在最后一次出现位置置或运算符并置1，最后处理剩余或运算符，从后往前填充。
```cpp
for(int i = W - 1; ~i; i--)
    if(buc[i] & 1) ans[i] = 1;
    else if(y && buc[i]) ans[i] = op[lst[i]] = 1, y--;
for(int i = n; y; i--) if(!op[i]) op[i] = 1, y--;
```
  - 作者：jiangxiaohai (4星)
    - 关键亮点：详细阐述贪心思路，从异或和或运算性质出发，逐步推导实现过程，代码注释详细，易于理解。
    - 核心代码实现思想：通过数组记录二进制位出现次数、是否保留等信息，从高位到低位遍历，根据奇偶性和剩余或运算符情况决定是否保留该位，同时记录每个位最后出现位置，用于构造表达式。
```cpp
for(int i=maxbit;i>=0;i--)
{
    if(ket[i]%2==0&&ket[i]>0) 
    {
        if(o>=1) 
        {
            o--;
            keep[i]=1;
        }
        else
            buc[i]=0;
    }
}
```
  - 作者：Dregen_Yor (4星)
    - 关键亮点：利用结构体记录每个数及其下标，通过排序保证高位优先且偶数情况能正确插入或运算符，代码逻辑清晰，注释详细。
    - 核心代码实现思想：对输入数据用结构体存储并排序，遍历数据，根据每个数出现次数的奇偶性和剩余运算符情况，在对应位置插入异或或或运算符，同时记录答案。
```cpp
for (int i = 2; i <= n; i++) {
    if (s[b[i].pos] & 1) {
        if (x) {
            ans[b[i].add] = '^';
            x--;
            sum[b[i].pos] = 1;
        } else {
            ans[b[i].add] = '|';
            y--;
            sum[b[i].pos] = 1;
        }
    } else {
        if (b[i + 1].pos!= b[i].pos) {
            if (y) {
                ans[b[i].add] = '|';
                y--;
                sum[b[i].pos] = 1;
            } else {
                ans[b[i].add] = '^';
                x--;
                sum[b[i].pos] = 0;
            }
        } else {
            if (x) {
                ans[b[i].add] = '^';
                x--;
            } else {
                ans[b[i].add] = '|';
                y--;
                sum[b[i].pos] = 1;
            }
        }
    }
}
```

最优关键思路或技巧：利用位运算性质，按位贪心处理，优先保证高位为1。通过数组或结构体记录数据出现次数、位置等信息，方便构造表达式。

可拓展之处：同类型题可考察不同运算符组合及不同数据范围下的表达式求值优化。类似算法套路为基于运算符性质，按位分析并贪心构造结果。

推荐题目：
  - P1106 删数问题，考察贪心策略在数字处理上的应用。
  - P1090 [NOIP2004 提高组] 合并果子，通过贪心选择最小元素合并。
  - P1223 排队接水，贪心安排接水顺序使总等待时间最小。

个人心得摘录与总结：
  - 作者zhenjianuo2025：%%% Alex巨佬orz orz，让本蒟蒻恍然大悟（还是我弱啊……），表达对出题人思路的赞叹。 

---
处理用时：31.18秒
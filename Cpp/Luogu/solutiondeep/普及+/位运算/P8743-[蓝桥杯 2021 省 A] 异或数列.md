# 题目信息

# [蓝桥杯 2021 省 A] 异或数列

## 题目描述

Alice 和 Bob 正在玩一个异或数列的游戏。初始时，Alice 和 Bob 分别有一个整数 $a$ 和 $b$, 有一个给定的长度为 $n$ 的公共数列 $X_{1}, X_{2}, \cdots, X_{n}$ 。

Alice 和 Bob 轮流操作，Alice 先手，每步可以在以下两种选项中选一种:

选项 1: 从数列中选一个 $X_{i}$ 给 Alice 的数异或上, 或者说令 $a$ 变为 $a \oplus X_{i}$ 。（其中 $\oplus$ 表示按位异或）

选项 2: 从数列中选一个 $X_{i}$ 给 Bob 的数异或上，或者说令 $b$ 变为 $b \oplus X_{i}$ 。

每个数 $X_{i}$ 都只能用一次, 当所有 $X_{i}$ 均被使用后（$n$ 轮后）游戏结束。游戏结束时, 拥有的数比较大的一方获胜，如果双方数值相同，即为平手。

现在双方都足够聪明，都采用最优策略，请问谁能获胜?

## 说明/提示

对于所有评测用例, $1 \leq T \leq 2\times 10^5,1 \leq \sum\limits_{i=1}^{T} n_{i} \leq 2\times10^5,0 \leq X_{i}<2^{20}$ 。 

蓝桥杯 2021 第一轮省赛 A 组 G 题。

## 样例 #1

### 输入

```
4
1 1
1 0
2 2 1
7 992438 1006399 781139 985280 4729 872779 563580```

### 输出

```
1
0
1
1```

# AI分析结果

• 综合分析与结论：这些题解的核心思路均是通过按位分析来确定游戏胜负。首先判断所有数异或和是否为0，若为0则平局。对于非平局情况，从高位到低位考虑每一位上1的个数：若为1，Alice先手选则必胜；若为偶数，该位双方平局；若为奇数且不为1，此时考虑该位为0的个数，若为偶数Alice胜，奇数则Bob胜。各题解在表述、代码风格及细节处理上有差异。

所选的题解：
  - 作者：Demeanor_Roy (5星)
    - 关键亮点：思路清晰，先证明所有数异或和为零则平局的结论，再对非平局情况按位分类讨论，逻辑严谨，代码简洁明了。
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    const int M=21;
    int T,n,cnt[M];
    int main()
    {
        scanf("%d",&T);
        while(T--)
        {
            memset(cnt,0,sizeof cnt);
            scanf("%d",&n);
            int sum=0;
            for(int i=1;i<=n;i++)
            {
                int x;
                scanf("%d",&x);
                sum^=x;
                for(int j=0;j<M;j++) cnt[j]+=(x>>j)&1;
            }
            if(!sum) puts("0");
            else
            {
                for(int i=20;i>=0;i--)
                {
                    if(!(cnt[i]&1)) continue;
                    else if(cnt[i]==1) puts("1");
                    else if((n-cnt[i])&1) puts("-1");
                    else puts("1");
                    break;
                }
            }
        }
        return 0;
    }
    ```
    - 核心实现思想：先读入数据并统计每一位1的个数，同时计算所有数的异或和。若异或和为0则平局；否则从高位到低位遍历每一位，根据1的个数及该位0的个数判断胜负。
  - 作者：hytree (4星)
    - 关键亮点：从竞技规则出发阐述最优策略，以通俗易懂的语言讲解贪心策略，强调0对胜负的影响。
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int a[200010],n,t,cnt[22];
    void count(int x)
    {
        int a=0;
        while(x)
        {
            if(x&1)++cnt[a];
            x>>=1;++a;
        }
    }
    int main()
    {
        scanf("%d",&t);
        while(t--)
        {
            memset(cnt,0,sizeof(cnt));
            int flag=0;
            scanf("%d",&n);
            for(int i=1;i<=n;++i)
                scanf("%d",a+i),count(a[i]);
            for(int i=20;i>=0;--i)
            {
                if(!(cnt[i]&1)) continue;
                if(cnt[i]==1) {puts("1");flag=1;break;}
                if((n-cnt[i])&1) {puts("-1");flag=1;break;}
                puts("1"),flag=1;
                break;
            }
            if(!flag) puts("0");
        }
        return 0;
    }
    ```
    - 核心实现思想：通过`count`函数统计每个数二进制每一位1的个数。读入数据后，从高位到低位检查每一位1的个数，按规则判断胜负，若所有位都平局则输出0。
  - 作者：jiayixuan1205 (4星)
    - 关键亮点：先分析平局情况，再从高位到低位贪心分析每一位，逻辑连贯，代码注释详细。
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    const int N = 2e5+10;
    const int M = 30;
    int T;
    int n;
    int x,cnt[M];
    int tot;
    int res;
    int main()
    {
        cin>>T;
        while(T--)
        {
            memset(cnt,0,sizeof(cnt));
            res=0;
            cin>>n;
            for(int i=1;i<=n;i++)
            {
                cin>>x;
                res^=x;
                for(int j=0;j<=20;j++) if(x&(1<<j)) cnt[j]++;
            }
            if(res==0)
            {
                cout<<0<<endl;
                continue;
            }
            for(int i=20;i>=0;i--)
            {
                if(cnt[i]%2==0) continue;
                else if(cnt[i]==1) cout<<1<<endl;
                else if((n-cnt[i])%2==1) cout<<-1<<endl;
                else cout<<1<<endl;
                break;
            }
        }
        return 0;
    }
    ```
    - 核心实现思想：读入数据时计算所有数异或和并统计每一位1的个数。若异或和为0则平局；否则从高位到低位遍历每一位，依据1的个数及该位0的个数判断胜负。

最优关键思路或技巧：按位分析的思维方式，通过对每一位上1和0的个数进行分类讨论来确定胜负，利用异或运算的特性简化问题。

可拓展之处：此类题目属于博弈策略与位运算结合的类型，类似套路可用于解决其他涉及按位操作及策略选择的博弈问题。

推荐洛谷题目：
1. P1876 [USACO06NOV]玉米田Corn Fields，涉及状态压缩与位运算。
2. P1170 兔八哥与猎人，需利用位运算优化状态表示和转移。
3. P2704 [NOI2001] 炮兵阵地，状态压缩动态规划结合位运算。

个人心得：无。 

---
处理用时：50.56秒
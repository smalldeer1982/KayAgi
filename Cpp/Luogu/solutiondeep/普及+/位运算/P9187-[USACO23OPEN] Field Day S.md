# 题目信息

# [USACO23OPEN] Field Day S

## 题目描述

**提示：本题的 Python 时限为 15s。其它语言默认 2s。**

Farmer John 的 $N$ 个牛棚都会选出包含 $C$ 只奶牛的队伍去参加户外聚会。所有奶牛的品种都只可能是根西牛（`G`）或荷斯坦奶牛（`H`）。

我们将两个奶牛队伍中，同一位置对应的两头奶牛品种不同的所有位置 $i(1 \leq i \leq C)$ 的个数，定义为的两个奶牛队伍的差异。对于编号 $1...N$ 的每个奶牛队伍 $t$，请计算出 $t$ 和其它所有队伍的差异的最大值。

## 说明/提示

第一个和第三个队伍的差异为 $5$。第二个和第三个队伍的差异为 $3$。

$2 \leq N \leq 10^5,1 \leq C \leq 18$。

- 对于测试点 2-5：$C = 10$。
- 对于测试点 6-9：所有答案最少为 $C - 3$。
- 对于测试点 10-20：没有额外条件。

## 样例 #1

### 输入

```
5 3
GHGGH
GHHHH
HGHHG```

### 输出

```
5
3
5```

# AI分析结果

• 综合分析与结论：
    - 这些题解主要围绕如何高效计算字符串间的汉明距离展开。多数题解利用字符串可转化为二进制数的特点进行优化。
    - 思路上，有的通过预处理最小汉明距离来推导最大汉明距离（如将最大汉明距离转化为C减去与反码的最小汉明距离）；有的利用位运算、广搜、动态规划、快速沃尔什变换（FWT）等方法。
    - 算法要点在于对数据的合理处理与转换，难点是在满足时间复杂度要求下找到高效解法。如暴力解法 $O(N^2)$ 无法通过，需利用 $C$ 的范围 $(C \leq 18)$ 进行优化。

所选的题解：
  - **作者：IamZZ (5星)**
    - **关键亮点**：思路清晰，巧妙地将最大汉明距离问题转化为最小汉明距离问题，通过预处理 $0 \sim 2^C - 1$ 所有数能找到的最小汉明距离，时间复杂度低至 $\Theta(2^C·C)$ 。
    - **重点代码**：
```c++
for(i=0;i<=(1<<c)-1;++i)
    f[i]=99999999;
for(i=1;i<=n;++i)
{
    scanf("%s",s+1);
    for(j=1;j<=c;++j)
    {
        v=0;
        if(s[j]=='G')
            v=1;
        o[i]=o[i]<<1|v;
    }
    f[o[i]]=0;
}
for(j=1;j<=c;++j)
{
    for(i=0;i<=(1<<c)-1;++i)
        f[(1<<j-1)^i]=min(f[(1<<j-1)^i],f[i]+1);
}
for(i=1;i<=n;++i)
{
    m=c-f[(1<<c)-1^o[i]];
    printf("%d\n",m);
}
```
    - **核心实现思想**：先将输入字符串转为二进制数并初始化其最小汉明距离为0，通过按位枚举转移求出所有数的最小汉明距离，最后根据结论计算并输出每个字符串与其他字符串的最大汉明距离。

  - **作者：FFTotoro (4星)**
    - **关键亮点**：采用广度优先搜索（BFS），将问题转化为求特定整数间最小步数问题，直观易懂。
    - **重点代码**：
```cpp
while(!q.empty()){
    auto [u,w]=q.front(); q.pop();
    for(int i=0;i<c;i++)
        if(int v=u^(1<<i);m[v]==-1)
            q.emplace(v,m[v]=w+1);
}
for(int i:a)cout<<c-m[(1<<c)-1^i]<<endl;
```
    - **核心实现思想**：以给出的整数为源点进行BFS，每次搜索相邻整数（仅一位不同），记录步数，最后通过总位数减去反码的步数得到最大异或popcount值。

  - **作者：ppip (4星)**
    - **关键亮点**：通过定义两个辅助数组 $g$ 和 $f$，利用状态转移方程求出每个数与给定数集合的最小汉明距离，进而得到最大汉明距离，逻辑严谨。
    - **重点代码**：
```cpp
fill_n(f,1<<m,m+1);
for (int i{1};i<=n;++i) f[a[i]]=0;
for (int i{(1<<m)-1};~i;--i)
    for (int j{0};j<m;++j)
        if (~i>>j&1) f[i]=min(f[i],f[i^1<<j]+1);
for (int i{0};i<1<<m;++i)
    for (int j{0};j<m;++j)
        if (i>>j&1) f[i]=min(f[i],f[i^1<<j]+1);
for (int i{1};i<=n;++i) cout<<m-f[(1<<m)-1-a[i]]<<"\n" ;
```
    - **核心实现思想**：先初始化 $f$ 数组，然后通过两次按位枚举进行状态转移求出 $f$ 数组值，最后根据 $f$ 数组计算每个输入数的答案。

• 最优关键思路或技巧：将最大汉明距离转化为最小汉明距离求解，利用二进制数的位运算和状态转移来优化算法，降低时间复杂度。

• 可拓展之处：此类问题可拓展到其他需要计算字符串或二进制序列相似度的场景，类似算法套路有利用位运算、动态规划、搜索算法等优化距离计算。

• 推荐洛谷题目：
    - P1451 求细胞数量 （考察利用搜索算法处理二进制矩阵相关问题）
    - P1003 铺地毯 （涉及对二维数据的处理与逻辑判断，可类比本题对数据的操作）
    - P1596 湖计数 （同样是利用搜索算法解决矩阵中连通区域的计数问题，与本题处理方式有相似处）

• 个人心得：无。 

---
处理用时：27.09秒
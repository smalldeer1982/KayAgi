# 题目信息

# 「RiOI-03」3-2

## 题目背景

> Heart beat to death[.](https://www.luogu.com.cn/problem/P9304)

## 题目描述

给定一个正整数 $n$。将 $[0,2^n)$ 中每个整数的二进制最低 $n$ 位**从低到高**依次写在一个 $2^n\times n$ 的矩阵上。**矩阵两维的下标都从 $0$ 开始。** 如，当 $n=3$ 时，矩阵是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/5f6v9pru.png?x-oss-process=image/resize,m_lfit,h_200,w_265)

给定 $q$ 次询问，每次询问这个矩阵下标为 $(x,y)$ 的格子所在的四连通块大小对 $998244353$ 取模的值。


## 说明/提示

#### 【样例 #1 解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/4mglp4cn.png?x-oss-process=image/resize,m_lfit,h_200)

图为 $n=2$ 时的矩阵，其中同一个颜色的为一个四连通块。

***

#### 【数据范围】

**本题开启捆绑测试。**

| $\text{SubTask}$ | 分值 | $n\le$ | $q\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $0$ | $5$ | $15$ | $15$ |
| $1$ | $20$ | $15$ | $5\times 10^5$ |
| $2$ | $25$ | $5\times 10^3$ | $5\times 10^3$ |
| $3$ | $50$ | $10^{18}$ | $5\times 10^5$ |

对于 $100\%$ 的数据，$0\le y\lt n\le 10^{18}$，$0\le x\lt \min(2^n, 10^{18})$，$1\le q\le 5\times 10^5$。

**请选用较快的输入输出方式。**

## 样例 #1

### 输入

```
2 2
1 1
2 0```

### 输出

```
3
1```

# AI分析结果

• 综合分析与结论：这些题解主要思路都是通过观察矩阵规律来求解连通块大小。算法要点在于利用矩阵每列元素规律（如每列是\(2^j\)个\(0\)、\(1\)交替出现），找到与给定点\((x,y)\)连通的最右侧点，从而确定连通块大小为\(2^{k + 1} - 1\)（\(k\)为最右侧点的列数）。解决难点在于优化查找最右侧点的过程，由于\(x \leq 10^{18}\)，当\(y\)大于一定值（如\(60\)或\(62\)）时进行特判，将时间复杂度优化到\(O(q \log n)\)。

所选的题解：
 - 作者：TernaryTree (赞：13)，星级：4星
    - 关键亮点：思路清晰，通过画出\(n = 4\)的矩阵观察规律，明确每列元素特征以及连通块可拆分成若干个\(2^j\)之和的性质，利用等比数列求和公式得出答案形式，优化查找过程思路明确。
    - 核心代码实现思想：通过`find`函数，从\((x,y)\)位置开始，利用位运算右移判断后续位与当前位是否相同，找到最大的\(j'\)，再用快速幂计算\(2^{j' + 1} - 1\)。
```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int mod = 998244353;

int power(int base, int freq, int mod) {
    int ans = 1, tmp = base;
    while (freq > 0) {
        if (freq % 2 == 1) ans = ans * tmp % mod;
        freq /= 2;
        tmp = tmp * tmp % mod;
    }
    return ans;
}

int n, q, x, y;

int find(int x, int y) {
	if (y > 62) return n;
    x >>= y;
    if (!x) return n;
    int d = x & 1;
    do x >>= 1, ++y;
    while ((x & 1) == d);
    return y;
}

signed main() {
    cin >> n >> q;
    while (q--) {
        cin >> x >> y;
        cout << (power(2, find(x, y), mod) - 1 + mod) % mod << endl;
    }
    return 0;
}
```
 - 作者：喵仔牛奶 (赞：4)，星级：4星
    - 关键亮点：将矩阵逆时针旋转\(90^{\circ}\)，类比成线段树，形象地得出连通块是一条链的结论，通过向上跳找到异色点确定连通块大小，代码简洁明了。
    - 核心代码实现思想：通过`__lg`函数获取\(x\)的最高位，判断\(y\)是否超出最高位，若超出直接输出\(2^n - 1\)，否则通过循环找到第一个与\((x,y)\)位置值不同的点，用快速幂计算答案。
```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb push_back
using namespace std;
namespace Milkcat {
    typedef long long LL;
    typedef pair<LL, LL> pii;
    const int N = 1e6 + 5, mod = 998244353;
    LL n, q, x, y;
    LL qpow(LL b, LL k) { LL r = 1; for (; k; b = b * b % mod, k >>= 1) if (k & 1) r = r * b % mod; return r; }
    int main() {
		cin >> n >> q;
		REP(test, 1, q) {
			cin >> x >> y;
			if (__lg(x) < y) {
				cout << (qpow(2, n) - 1 + mod) % mod << '\n';
			} else {
				int p = x >> y & 1;
				while ((x >> y & 1) == p) y ++;
				cout << (qpow(2, y) - 1 + mod) % mod << '\n';
			}
		}
        return 0;
    }
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int T = 1;
    while (T --) Milkcat::main();
    return 0;
}
```
 - 作者：_zuoqingyuan (赞：1)，星级：4星
    - 关键亮点：通过打表观察出矩阵每行是数字二进制翻转，且连通块形状类似，可分成列数计算大小，思路清晰，代码实现简洁易懂。
    - 核心代码实现思想：通过`findceil`函数，从\((x,y)\)开始查找第一个不属于连通块的列数，用快速幂计算\(2^{列数 + 1} - 1\)得到连通块大小。
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long ll;
ll n,q,x,y;
const int Mod=998244353;
ll findceil(ll x,ll y,ll f){
    int i;
    if(y>62||(x>>y)==0)return n;
    for(i=y+1;;i++){
        if(((x>>i)&1)!=f)return i;
    }
    return n;
}
ll ksm(ll a,ll b){
	ll p=1;
	while(b){
		if(b&1)p=(a*p)%Mod;
		a=(a*a)%Mod;
		b=b>>1;
	} 
	return p%Mod;
}
ll ans(ll t){
    ll num=ksm(2,t);
    return (num-1+Mod)%Mod;
}
int main(){
    scanf("%lld %lld",&n,&q);
    while(q--){
        scanf("%lld %lld",&x,&y);
        bool f=((x>>y)&1);
        ll t=findceil(x,y,f);
        printf("%lld\n",ans(t));
    }
    return 0;
}
```

最优关键思路或技巧：通过观察矩阵规律，发现连通块与列数的关系，利用位运算优化查找连通块最右侧点的过程，同时根据\(x\)的范围对\(y\)大于一定值时进行特判，降低时间复杂度。

可拓展之处：同类型题可能会改变矩阵生成规则或连通块判断方式，但核心思路依然是观察规律、优化查找。类似算法套路是对于大规模数据下的矩阵问题，通过观察规律找到关键特征（如本题连通块与列数关系），利用数据范围进行优化。

推荐题目：
 - [P1303 A*B Problem](https://www.luogu.com.cn/problem/P1303)，考察高精度乘法，与本题类似在于都需观察数字规律并优化计算过程。
 - [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)，通过找规律求解斐波那契数列，与本题找矩阵规律类似。
 - [P2141 珠心算测验](https://www.luogu.com.cn/problem/P2141)，通过观察数据特点解决计数问题，与本题观察矩阵规律解决连通块问题思路相似。

个人心得摘录与总结：
 - 作者Expert_Dream提到感谢他人在求助贴中告知需要特判，强调了交流学习在解题中的帮助。
 - 作者cosf提到计算\(x_y\)时要用`1ll`去左移而不是`1`，否则会出错，这是在处理位运算时需要注意的细节。 

---
处理用时：44.22秒
# 题目信息

# 三元上升子序列

## 题目描述

Erwin 最近对一种叫 `thair` 的东西巨感兴趣。。。

在含有 $n$ 个整数的序列 $a_1,a_2,\ldots,a_n$ 中，三个数被称作`thair`当且仅当 $i<j<k$ 且 $a_i<a_j<a_k$。

求一个序列中 `thair` 的个数。

## 说明/提示

#### 样例2 解释

$7$ 个 `thair` 分别是：

- 1 2 3
- 1 2 4
- 1 2 3
- 1 2 4
- 1 3 4
- 2 3 4
- 2 3 4

#### 数据规模与约定

- 对于 $30\%$ 的数据 保证 $n\le100$；
- 对于 $60\%$ 的数据 保证 $n\le2000$；
- 对于 $100\%$ 的数据 保证 $1 \leq n\le3\times10^4$，$1\le a_i\leq 10^5$。

## 样例 #1

### 输入

```
4
2 1 3 4```

### 输出

```
2```

## 样例 #2

### 输入

```
5
1 2 2 3 4```

### 输出

```
7```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何高效求解三元上升子序列个数展开。大部分题解利用乘法原理，通过统计每个数左边小于它的数的个数和右边大于它的数的个数，相乘后累加得到结果。为优化时间复杂度，众多题解采用树状数组、线段树等数据结构，部分题解还涉及离散化处理以解决数据值域大的问题。

所选的题解：
  - **作者：紫题 (赞：197)  星级：5星**
    - **关键亮点**：将问题拓展到M元上升子序列，利用DP结合树状数组优化。通过状态转移方程$f[i][j] = {\sum_{k<j,a[k]<a[j]}}f[i - 1][k]$，并借助树状数组维护，将时间复杂度优化到$O(NMlogN)$，思路新颖且具有通用性。
    - **重点代码**：
```cpp
for(int i = 2; i <= 3; i++) {
    memset(c, 0, sizeof(c));
    for(int j = 1; j <= n; j++) {
        f[i][j] = ask(a[j]-1);
        add(a[j], f[i-1][j]);
    }
}
for(int i = 1; i <= n; i++) ans += f[3][i];
```
    - **核心实现思想**：外层循环i遍历子序列长度，每次重置树状数组。内层循环j遍历数组，通过树状数组查询和更新操作，计算以a[j]为结尾的长度为i的上升子序列的个数，最后累加长度为3的上升子序列个数得到答案。
  - **作者：Dog_Two (赞：89)  星级：5星**
    - **关键亮点**：思路清晰，从枚举中间元素出发，定义Lef[i]和Rit[i]分别表示A[i]左边小于A[i]的元素个数和右边大于A[i]的元素个数，利用乘法原理计算答案。通过树状数组结合离散化处理，高效解决问题，时间复杂度$O(nlogn)$。
    - **重点代码**：
```cpp
for(int i=1;i<=n;++i){
    add(c1,_Q(A[i]),1);
    Lef[i]=sum(c1,_Q(A[i])-1);
}
for(int i=n;i>=1;--i){
    add(c2,_Q(A[i]),1);
    Rit[i]=n-i-(sum(c2,_Q(A[i]))-1);
}
long long ans=0;
for(int i=2;i<n;++i) ans+=Lef[i]*Rit[i];
```
    - **核心实现思想**：正向遍历数组，用树状数组c1统计每个数左边小于它的数的个数存入Lef数组；反向遍历数组，用树状数组c2统计每个数右边大于它的数的个数存入Rit数组，最后遍历数组，将Lef[i]与Rit[i]的乘积累加得到答案。
  - **作者：windows250 (赞：85)  星级：4星**
    - **关键亮点**：针对树状数组解法较多的情况，给出线段树的题解，对初学线段树的同学有帮助。同样基于乘法原理，通过线段树维护每个数前比它小的数的个数和每个数后比它大的数的个数，最后累加乘积得到结果。
    - **重点代码**：
```cpp
for(int i=1;i<=n;i++){
    if(num[i]>1) smaller[i]=query(1,1,n,1,num[i]-1);
    update(1,1,n,num[i]);
}
memset(sum,0,sizeof(sum));
for(int i=n;i>=1;i--){
    if(num[i]<n) bigger[i]=query(1,1,n,num[i]+1,n);
    update(1,1,n,num[i]);
}
for(int i=1;i<=n;i++) ans+=(bigger[i]*smaller[i]);
```
    - **核心实现思想**：正向遍历数组，用线段树查询每个数前比它小的数的个数存入smaller数组并更新线段树；反向遍历数组，用线段树查询每个数后比它大的数的个数存入bigger数组并更新线段树，最后遍历数组，将bigger[i]与smaller[i]的乘积累加得到答案。

最优的关键思路或技巧：利用乘法原理将问题转化为统计每个数左右两侧满足条件的数的个数，通过树状数组或线段树优化统计过程，同时运用离散化处理数据值域大的问题，有效降低时间复杂度。

可拓展之处：此类问题可拓展到求M元上升子序列个数，还可变化条件，如求下降子序列、子序列元素差值满足特定条件等。类似算法套路是利用数据结构维护前缀和或后缀和，通过统计满足条件的元素个数结合乘法原理求解。

推荐题目：
  - P1908 逆序对，考察树状数组求逆序对，与本题统计左侧小于或右侧大于的数的个数思路相关。
  - P3368 【模板】树状数组 2，可巩固树状数组区间修改和区间查询的知识点。
  - P3374 【模板】树状数组 1，基础树状数组题目，有助于理解树状数组基本操作。

个人心得：
  - **作者：MuYC**：在解决如何用树状数组维护比当前元素大的元素个数时，尝试将标准树状数组反过来用，通过修改add和get函数实现，虽然代码不推荐这样写，但提供了一种新思路。 

---
处理用时：34.32秒
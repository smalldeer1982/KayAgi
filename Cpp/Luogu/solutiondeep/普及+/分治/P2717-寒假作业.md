# 题目信息

# 寒假作业

## 题目背景

zzs 和 zzy 正在被寒假作业折磨，然而他们有答案可以抄啊。


## 题目描述

他们共有 $n$ 项寒假作业。zzy 给每项寒假作业都定义了一个疲劳值 $a_i$，表示抄这个作业所要花的精力。

zzs 现在想要知道，有多少组连续的寒假作业的疲劳值的平均值不小于 $k$？

简单地说，给定一个长度为 $n$ 的正整数序列 $\{a_i\}$，求出有多少个**连续**子序列的平均值不小于 $k$。


## 说明/提示

#### 样例 1 解释

共有 $6$ 个连续的子序列，分别是 $(1)$、$(2)$、$(3)$、$(1,2)$、$(2,3)$、$(1,2,3)$，平均值分别为 $1$、$2$、$3$、$1.5$、$2.5$、$2$，其中平均值不小于 $2$ 的共有 $4$ 个。

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 100$。
- 对于 $50\%$ 的数据，保证 $n \leq 5000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq a_i,k \leq 10^4$。

## 样例 #1

### 输入

```
3 2
1
2
3
```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何优化求解连续子序列平均值不小于给定值 \( k \) 的问题。核心思路是将原序列每个元素减去 \( k \) ，转化为求区间和非负的连续子序列个数，进而转化为求前缀和数组的顺序对（或类似逆序对）问题，采用树状数组、cdq分治、平衡树等多种数据结构和算法解决。

### 所选的题解
#### 作者：ghj1222 (5星)
- **关键亮点**：思路清晰，利用cdq分治解决问题。先将所有数减去 \( k \) 转化为求区间和非负的区间数量，通过分治计算跨过中点的区间贡献，将问题转化为前缀和后缀和排序后双指针扫一遍统计答案，代码简洁明了。
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int n, k, a[100010];
int tmp[100010];

long long cdq(int l, int r)
{
    if (l == r) return a[l] >= 0;
    int mid = (l + r) / 2;
    long long ans = cdq(l, mid) + cdq(mid + 1, r);
    tmp[mid] = a[mid];
    tmp[mid + 1] = a[mid + 1];
    for (int i = mid - 1; i >= l; i--)
        tmp[i] = tmp[i + 1] + a[i];
    for (int i = mid + 2; i <= r; i++)
        tmp[i] = tmp[i - 1] + a[i];
    sort(tmp + l, tmp + mid + 1);
    sort(tmp + mid + 1, tmp + r + 1);
    for (int i = l, j = r; i <= mid; i++)
    {
        while (j > mid && tmp[i] + tmp[j] >= 0) j--;
        ans += r - j;
    }
    return ans;
}

int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]), a[i] -= k;
    printf("%lld\n", cdq(1, n));
    return 0;
}
```
核心实现思想：`cdq`函数通过递归分治，先计算子区间贡献，再处理跨过中点的区间。通过前后缀和数组`tmp`记录子区间和，排序后利用双指针统计满足条件的区间数量。

#### 作者：WanderingTrader (4星)
- **关键亮点**：详细介绍树状数组与cdq分治两种解法，对题目分析透彻，将原问题转化为二维偏序问题，通过离散化处理解决可能出现的负数问题，代码注释详细。
- **个人心得**：提到树状数组好想好写但离散化导致时间和空间复杂度稍高，cdq分治虽然性能好但容易写挂，有实际调试经验分享。
```cpp
// 树状数组解法
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn = 1e5 + 5;
int a[maxn], id[maxn], rk[maxn], bit[maxn], n, k;
LL ans;
bool cmpID(int u, int v) { return a[u] < a[v] || (a[u] == a[v] && u < v); }
int LSB(int x) { return x & -x; }
void add(int x) { for (; x <= n + 1; x += LSB(x)) ++bit[x]; }
int query(int x)
{
    int sum = 0;
    for (; x; x -= LSB(x)) sum += bit[x];
    return sum;
}
int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i) scanf("%d", a + i);
    for (int i = 1; i <= n; ++i) { a[i] += a[i - 1] - k; id[i] = i; }
    sort(id, id + n + 1, cmpID);
    for (int i = 0; i <= n; ++i) rk[id[i]] = i + 1;
    for (int i = 0; i <= n; ++i)
    {
        ans += query(rk[i]);
        add(rk[i]);
    }
    printf("%lld\n", ans);
    return 0;
}
```
核心实现思想：树状数组解法中，通过`add`和`query`函数维护树状数组，`cmpID`函数用于离散化时考虑相同数据的下标顺序，遍历前缀和数组时通过`query`统计满足条件的数量并通过`add`更新树状数组。
```cpp
// cdq分治解法
void cdq(int l, int r)
{
    if (l == r) return;
    int mid = (l + r) >> 1, i = l, j = mid + 1, k = l;
    cdq(l, mid); cdq(mid + 1, r);
    for (j = mid + 1; j <= r;)
    {
        while (i <= mid && a[i] <= a[j]) t[k++] = a[i++];
        t[k++] = a[j++];
        ans += i - l;
    }
    for (; i <= mid;) t[k++] = a[i++];
    for (i = l; i <= r; ++i) a[i] = t[i];
}
```
核心实现思想：`cdq`分治函数中，递归处理左右子区间，通过双指针`i`和`j`合并区间并统计满足偏序关系的数量。

#### 作者：Tenshi (4星)
- **关键亮点**：对式子推导清晰，将求平均值问题转化为二维偏序问题，利用分治结合归并排序统计贡献，代码简洁，逻辑连贯。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

typedef long long ll;
const int N = 1e5 + 5;
int n, k;
int v[N], tmp[N];

ll res = 0;
void cdq(int l, int r)
{
    if (l >= r) return;
    int mid = l + r >> 1;
    cdq(l, mid), cdq(mid + 1, r);

    ll sum = 0;
    for (int i = l, j = mid + 1, k = l; k <= r; k++)
        if (j > r || i <= mid && v[i] <= v[j]) sum++, tmp[k] = v[i++];
        else res += sum, tmp[k] = v[j++];
    for (int k = l; k <= r; k++) v[k] = tmp[k];
}

int main()
{
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> v[i], v[i] += v[i - 1];

    for (int i = 1; i <= n; i++) v[i] -= k * i;

    cdq(0, n);

    cout << res << endl;

    return 0;
}
```
核心实现思想：`cdq`函数递归分治，在归并排序过程中，通过双指针移动统计满足`v[i] <= v[j]`的数量，更新结果`res`。

### 最优关键思路或技巧
1. **数据变换**：将原序列每个元素减去 \( k \) ，把求平均值不小于 \( k \) 的问题转化为求区间和非负的问题，简化问题求解。
2. **转化为偏序问题**：通过前缀和进一步将问题转化为二维偏序问题，如求前缀和数组的顺序对数量，从而可以利用树状数组、cdq分治等方法高效解决。

### 可拓展思路
此类问题常涉及区间统计、平均值计算，可拓展到其他类似的区间问题，如求满足特定条件的区间最值、区间和范围等。常见算法套路是通过数据变换简化问题，转化为经典的排序、偏序问题，利用树状数组、线段树、分治等算法解决。

### 相似知识点洛谷题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：经典的逆序对问题，与本题中转化为顺序对问题类似，可练习树状数组和归并排序求逆序对的方法。
2. [P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)：三维偏序问题，可进一步加深对偏序问题及cdq分治等解决方法的理解。
3. [P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617)：涉及区间修改和查询第 \( k \) 小，可锻炼对树状数组和线段树等数据结构的综合应用能力。 

---
处理用时：45.40秒
# 题目信息

# [BJOI2016] 回转寿司

## 题目描述

酷爱日料的小Z经常光顾学校东门外的回转寿司店。在这里，一盘盘寿司通过传送带依次呈现在小Z眼前。  

不同的寿司带给小Z的味觉感受是不一样的，我们定义小Z对每盘寿司都有一个满意度。  

例如小Z酷爱三文鱼，他对一盘三文鱼寿司的满意度为 $10$；小Z觉得金枪鱼没有什么味道，他对一盘金枪鱼寿司的满意度只有 $5$；小Z最近看了电影《美人鱼》，被里面的八爪鱼恶心到了，所以他对一盘八爪鱼刺身的满意度是 $-100$。   

特别地，小Z是个著名的吃货，他吃回转寿司有一个习惯，我们称之为“狂吃不止”。具体地讲，当他吃掉传送带上的一盘寿司后，他会毫不犹豫地吃掉它后面的寿司，直到他不想再吃寿司了为止。  

今天，小Z再次来到了这家回转寿司店，$N$ 盘寿司将依次经过他的面前。其中，小Z对第 $i$ 盘寿司的满意度为$a_i$。  

小Z可以选择从哪盘寿司开始吃，也可以选择吃到哪盘寿司为止。他想知道共有多少种不同的选择，使得他的满意度之和不低于 $L$，且不高于 $R$。

注意，虽然这是回转寿司，但是我们不认为这是一个环上的问题，而是一条线上的问题。即，小Z能吃到的是输入序列的一个连续子序列；最后一盘转走之后，第一盘并不会再出现一次。

## 说明/提示

【数据范围】  

$1\le N \le 10^5$  
$|a_i| \le 10^5$   
$0\le L,R \le 10^9$

## 样例 #1

### 输入

```
5 5 9
1 2 3 4 5```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效统计满足区间和在[L, R]范围内的连续子序列数量展开。核心思路是通过前缀和将原问题转化为对前缀和数组的区间查询问题，然后运用不同的数据结构或算法来优化查询过程。
1. **思路与算法要点**：
    - **前缀和预处理**：先计算数组的前缀和，将区间和问题转化为前缀和相减的形式，即对于区间[i, j]的和可表示为sum[j] - sum[i - 1]，使得问题变为求满足L <= sum[j] - sum[i - 1] <= R的(i, j)对数。
    - **数据结构与算法运用**：
        - **CDQ分治**：将问题按区间分治，利用左区间的前缀和来统计对右区间的贡献，通过队列维护满足L和R边界条件的前缀和下标，在归并排序过程中统计答案。
        - **线段树（含动态开点）**：构建权值线段树，动态开点以节省空间。枚举右端点r，每次查询前缀和数组中在[sum[r] - R, sum[r] - L]区间内的元素个数，并将sum[r]插入线段树。
        - **树状数组**：与线段树思路类似，需对前缀和离散化后，利用树状数组单点修改、区间查询的特性，统计满足条件的前缀和个数。
        - **平衡树（如Treap）**：通过平衡树维护前缀和集合，每次插入当前前缀和，并查询树中在[sum[i] - R, sum[i] - L]区间内的节点个数。
2. **解决难点**：由于前缀和不保证递增，在查询满足条件的前缀和时，需保证查询和插入操作的同步性，确保左端点的合法性。
3. **题解质量评分**：综合思路清晰度、代码可读性、优化程度等方面，对各题解进行评分。

### 所选4星及以上题解
1. **作者：shentao1 (赞：39) - 5星**
    - **关键亮点**：思路清晰，先点明前缀和转换问题，再巧妙类比逆序对想到CDQ分治，通过变换式子用队列维护边界，代码简洁明了。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long L,R,ans,s[110000];
void cdq(int l,int r)
{
    if(l==r)return ;
    int mid=(l+r)/2;
    cdq(l,mid),cdq(mid+1,r);
    int head=l,tail=l-1;
    for(int i=mid+1;i<=r;i++)
    {
        while(tail+1<=mid && s[i]>=s[tail+1]+L)tail++;
        while(head<=mid && s[i]>s[head]+R)head++;
        ans+=tail-head+1;
    }
    sort(s+l,s+r+1);
}
int main()
{
    int n;
    scanf("%d%lld%lld",&n,&L,&R);
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        s[i]=s[i-1]+x;
    }
    cdq(0,n);
    printf("%lld\n",ans);
    return 0;
}
```
    - **核心实现思想**：cdq函数递归分治区间，在合并左右区间时，通过两个while循环移动head和tail指针，统计满足条件的前缀和对数，最后对当前区间的前缀和数组排序。
2. **作者：神眷之樱花 (赞：25) - 4星**
    - **关键亮点**：详细阐述线段树做法的思路，从题意分析到式子推导，清晰说明如何通过线段树解决区间查询问题，代码注释详细。
    - **个人心得**：感谢Nerovix大佬帮忙找出爆零代码的问题。
    - **核心代码**：
```cpp
#include<cstdio>
#define LL long long
const int N = 3.4e6 + 5;
const LL MAXN = 1e10;
struct SegmentTree {
    int lc,rc,dat;
}tr[4 * N];
int n,root,tot = 0,le,ri;
long long pre[N],res = 0;
int build() {
    tot++;
    tr[tot].lc = tr[tot].rc = tr[tot].dat = 0;
    return tot;
}
void insert(int p,LL val,int add,LL L = -MAXN,LL R = MAXN) {
    if(L == R) {
        tr[p].dat += add;
        return;
    }
    LL mid = (L + R) >> 1;
    if(val <= mid) {
        if(!tr[p].lc) tr[p].lc = build();
        insert(tr[p].lc,val,add,L,mid);
    }
    else {
        if(!tr[p].rc) tr[p].rc = build();
        insert(tr[p].rc,val,add,mid + 1,R);
    }
    tr[p].dat = tr[tr[p].lc].dat + tr[tr[p].rc].dat;
}
int query(int p,LL lf,LL rg,LL L = -MAXN,LL R = MAXN) {
    if(lf <= L && R <= rg) return tr[p].dat;
    LL mid = (L + R) >> 1; int ans = 0;
    if(lf <= mid) {
        if(!tr[p].lc) tr[p].lc = build();
        ans += query(tr[p].lc,lf,rg,L,mid);
    }
    if(rg >  mid) {
        if(!tr[p].rc) tr[p].rc = build();
        ans += query(tr[p].rc,lf,rg,mid + 1,R);
    }
    return ans;
}
inline int read() {
    int x = 0,flag = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')flag = -1;ch = getchar();}
    while(ch >='0' && ch <='9'){x = (x << 3) + (x << 1) + ch - 48;ch = getchar();}
    return x * flag;
}
int main() {
    n = read(),le = read(),ri = read();
    for(int i = 1,x; i <= n; i++) {
        x = read();
        pre[i] = pre[i - 1] + x;
    }
    root = build();
    insert(root,pre[0],1);
    for(int i = 1; i <= n; i++) {
        res += query(root,pre[i] - ri,pre[i] - le);
        insert(root,pre[i],1);
    }
    printf("%lld",res);
    return 0;
}
```
    - **核心实现思想**：build函数初始化线段树节点，insert函数插入前缀和值，query函数查询指定区间内的前缀和数量，在main函数中先初始化线段树并插入pre[0]，然后枚举每个前缀和，查询并累加满足条件的数量。
3. **作者：Heartlessly (赞：23) - 4星**
    - **关键亮点**：简洁明了地阐述思路，从问题描述到解决方案，清晰说明通过动态开点线段树维护前缀和，代码规范，模板化程度高。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (;!isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f? -x : x;
}
template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}
const int MAXN = 1e5, LOG = 34;
const LL MAXM = 1e10;
int n, l, r;
LL ans, pre[MAXN + 5];
struct SegmentTree {
    int root, tot, sum[MAXN * LOG * 4 + 5], lson[MAXN * LOG * 4 + 5], 
    rson[MAXN * LOG * 4 + 5];
    inline void pushUp(int x) {
        sum[x] = sum[lson[x]] + sum[rson[x]];
    }
    void update(int &x, LL q, LL p, LL l = -MAXM, LL r = MAXM) {
        if (!x) x = ++tot;
        if (l == r) {
            sum[x] += p;
            return;
        }
        LL mid = (l + r) >> 1;
        if (q <= mid) update(lson[x], q, p, l, mid);
        else update(rson[x], q, p, mid + 1, r);
        pushUp(x);
    }
    int query(int &x, LL ql, LL qr, LL l = -MAXM, LL r = MAXM) {
        if (!x) x = ++tot;
        if (ql <= l && qr >= r) return sum[x];
        LL res = 0, mid = (l + r) >> 1;
        if (ql <= mid) res += query(lson[x], ql, qr, l, mid);
        if (qr > mid) res += query(rson[x], ql, qr, mid + 1, r);
        return res;
    }
} tr;
int main() {
    read(n), read(l), read(r);
    for (int x, i = 1; i <= n; ++i) {
        read(x);
        pre[i] = pre[i - 1] + x;
    }
    tr.update(tr.root, pre[0], 1);
    for (int i = 1; i <= n; ++i) {
        ans += tr.query(tr.root, pre[i] - r, pre[i] - l);
        tr.update(tr.root, pre[i], 1);
    }
    write(ans);
    putchar('\n');
    return 0;
}
```
    - **核心实现思想**：SegmentTree结构体定义动态开点线段树，update函数用于更新线段树节点，query函数用于查询区间和，main函数中先读入数据并计算前缀和，然后通过update插入初始前缀和，再枚举每个前缀和，利用query统计满足条件的数量。

### 最优关键思路或技巧
1. **前缀和转换**：将区间和问题转化为前缀和相减的形式，简化问题模型，为后续使用各种数据结构优化奠定基础。
2. **数据结构选择**：根据题目特点，选择合适的数据结构。如CDQ分治利用分治思想和队列优化统计过程；线段树（含动态开点）、树状数组、平衡树等数据结构，通过维护前缀和集合，高效实现区间查询操作。
3. **同步查询与插入**：由于前缀和不递增，在使用数据结构时，确保查询和插入操作同步进行，以正确统计满足条件的子序列数量。

### 可拓展之处
1. **同类型题**：此类题目通常围绕区间和、子序列统计等问题展开，可拓展到具有类似条件限制的子序列问题，如子序列和为特定值、子序列和的最值等。
2. **类似算法套路**：在处理这类问题时，前缀和预处理是常见的第一步，之后根据具体需求选择合适的数据结构。若数据范围较小，暴力枚举可能可行；若数据范围较大，需考虑如CDQ分治、线段树、树状数组、平衡树等优化算法。

### 相似知识点洛谷题目推荐
1. **P1908 逆序对**：通过归并排序统计逆序对数量，与本题CDQ分治统计满足条件对数的思路类似，可加深对分治统计的理解。
2. **P3374 树状数组 1**：基础的树状数组题目，用于单点修改和区间查询，本题部分解法使用树状数组维护前缀和，可通过该题巩固树状数组的应用。
3. **P3810 三维偏序（陌上花开）**：涉及三维偏序问题，可使用CDQ分治解决，与本题CDQ分治思路有相通之处，能进一步提升对CDQ分治在复杂问题中的应用能力。

### 个人心得摘录与总结
作者神眷之樱花提到感谢Nerovix大佬帮忙找出爆零代码的问题，这表明在解决复杂算法问题时，他人的帮助和代码审查很重要，同时也反映出即使思路正确，代码实现中的细节也可能导致错误，需要仔细调试和检查。 

---
处理用时：67.76秒
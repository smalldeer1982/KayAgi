# 题目信息

# 奶牛排队

## 题目描述

奶牛在熊大妈的带领下排成了一条直队。

显然，不同的奶牛身高不一定相同……

现在，奶牛们想知道，如果找出一些连续的奶牛，要求最左边的奶牛 $A$ 是最矮的，最右边的 $B$ 是最高的，且 $B$ 高于 $A$ 奶牛。中间如果存在奶牛，则身高不能和 $A,B$ 奶牛相同。问这样的奶牛最多会有多少头？

从左到右给出奶牛的身高，请告诉它们符合条件的最多的奶牛数（答案可能是 $0,2$，但不会是 $1$）。

## 说明/提示

#### 样例解释

取第 $1$ 头到第 $4$ 头奶牛，满足条件且为最多。

#### 数据范围

对于全部的数据，满足 $2 \le N \le 10^5$，$1 \le h_i <2^{31}$。

## 样例 #1

### 输入

```
5
1
2
3
4
1```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效找出满足特定条件（最左边奶牛最矮、最右边奶牛最高且中间奶牛身高与两端不同）的最长连续奶牛序列展开。多数题解采用单调栈来维护后缀最值或左右侧特定奶牛位置，部分使用分治结合RMQ（Range Minimum/Maximum Query）方法。单调栈解法时间复杂度多为 \(O(n \log n)\)，分治RMQ解法时间复杂度为 \(O(n \log n + n)\)。

### 所选的题解
1. **作者：一扶苏一 (5星)**
    - **关键亮点**：思路清晰，先分析出枚举右端点 \(B\) 时，左端点 \(A\) 是后缀最小值所在位置且需满足一定条件，再利用单调栈维护后缀最大最小值，通过二分查找确定合法左端点，时间复杂度 \(O(n \log n)\)。
    - **个人心得**：无
    - **核心代码**：
```cpp
for (int i = 1; i <= n; ++i) {
    while (tn && a[sn[tn]] >= a[i]) --tn;
    while (tx && a[sx[tx]] < a[i]) --tx;
    int k = std::upper_bound(sn + 1, sn + 1 + tn, sx[tx]) - sn;
    if (k!= (tn + 1)) {
        ans = std::max(ans, i - sn[k] + 1);
    }
    sn[++tn] = i;
    sx[++tx] = i;
}
```
    - **核心思想**：每次枚举右端点 \(i\)，先调整维护后缀最小值的栈 \(sn\) 和后缀最大值的栈 \(sx\)，通过二分查找（`upper_bound`）在后缀最小值栈中找到最靠左的合法左端点位置，更新最大长度。
2. **作者：LargeRice16pro (4星)**
    - **关键亮点**：简化题意，明确左右端点合法条件，利用单调栈预处理出每个奶牛左侧第一个大于等于它和右侧第一个小于等于它的奶牛位置，枚举右端点寻找合法左端点更新答案，代码实现清晰。
    - **个人心得**：提到被答案不能为1这个条件坑了最后一个点。
    - **核心代码**：
```cpp
for(i=1;i<=n;i++)
{
    while(!q.empty()&&q.top().h<h[i])
    q.pop();
    if(!q.empty())
    z[i]=q.top().s;
    else z[i]=0;
    node t;
    t.h=h[i];
    t.s=i;
    q.push(t);
}
clean();
for(i=n;i>=1;i--)
{
    while(!q.empty()&&q.top().h>h[i])
    q.pop();
    if(!q.empty())
    r[i]=q.top().s;
    else r[i]=n+1;
    node t;
    t.h=h[i];
    t.s=i;
    q.push(t);
}
for(i=n;i>=1;i--)
{
    for(j=z[i]+1;j<i;j++)
    {
        if(r[j]>i)
        {
            ans=max(ans,i-j+1);
            break;
        }
    }
    if(i<=ans) break;
}
```
    - **核心思想**：先正向和反向遍历用单调栈分别填充数组 \(z\)（左侧第一个大于等于当前奶牛身高的位置）和 \(r\)（右侧第一个小于等于当前奶牛身高的位置），然后从大到小枚举右端点 \(i\)，在合法范围内找左端点 \(j\) 更新最大长度。
3. **作者：Na2PtCl6 (4星)**
    - **关键亮点**：用STL的 `vector` 实现两个单调栈，清晰阐述单调栈维护的内容及如何利用它们找到合法子段，通过具体数据演示解题过程，便于理解。
    - **个人心得**：无
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    while(v1.size()&&a[v1.back()]>=a[i])
        v1.pop_back();
    while(v2.size()&&a[v2.back()]<a[i])
        v2.pop_back();
    int val=v2.size()?v2.back():0; 
    int p=upper_bound(v1.begin(),v1.end(),val)-v1.begin();
    if(p!=v1.size())
        res=_max(res,i-v1[p]+1);
    v1.push_back(i);
    v2.push_back(i);
}
```
    - **核心思想**：从前往后枚举元素 \(a[i]\)，调整两个单调栈 \(v1\)（维护小于 \(a[i]\) 的下标）和 \(v2\)（维护大于等于 \(a[i]\) 的下标），利用 \(v2\) 栈顶在 \(v1\) 中二分查找合法位置更新最大长度。

### 最优关键思路或技巧
利用单调栈维护后缀最值或左右侧特定位置信息，通过枚举一端点，在满足条件的范围内查找另一端点来确定最长区间。这种方法有效利用了单调栈特性，避免了暴力枚举的高时间复杂度。

### 可拓展之处
此类题目属于区间最值与序列条件查找结合的问题，类似算法套路可用于解决如“找出满足特定大小关系的最长子数组”等问题。对于分治RMQ方法，可用于解决更复杂的区间查询问题。

### 推荐题目
1. **P5788 【模板】单调栈**：基础单调栈题目，帮助理解单调栈原理。
2. **P3865 【模板】ST表**：用于掌握ST表数据结构及其在区间最值查询中的应用。
3. **P1886 滑动窗口**：结合单调队列解决滑动窗口内的最值问题，与本题利用数据结构优化区间查找思路类似。

### 个人心得摘录与总结
LargeRice16pro提到因忽略答案不能为1这个条件而在最后一个测试点出错，强调了仔细审题的重要性，尤其对于题目中的边界条件和特殊限制需格外关注。 

---
处理用时：48.39秒
# 题目信息

# [蓝桥杯 2021 国 ABC] 异或变换

## 题目描述

小蓝有一个 01 串 $s=s_{1} s_{2} s_{3} \cdots s_{n}$。

以后每个时刻, 小蓝要对这个 01 串进行一次变换。每次变换的规则相同。 对于 01 串 $s=s_{1} s_{2} s_{3} \cdots s_{n}$, 变换后的 01 串 $s^{\prime}=s_{1}^{\prime} s_{2}^{\prime} s_{3}^{\prime} \cdots s_{n}^{\prime}$ 为：

$$
\begin{aligned}
&s_{1}^{\prime}=s_{1} \\
&s_{i}^{\prime}=s_{i-1} \oplus s_{i}
\end{aligned}
$$

其中 $a \oplus b$ 表示两个二进制的异或, 当 $a$ 和 $b$ 相同时结果为 $0$ , 当 $a$ 和 $b$ 不同时结果为 $1$ 。

请问, 经过 $t$ 次变换后的 01 串是什么?

## 说明/提示

**【样例说明】**

初始时为 `10110` , 变换 1 次后变为 `11101` , 变换 2 次后变为 `10011` , 变换 3 次后变为 `11010`。

**【评测用例规模与约定】**

对于 $40 \%$ 的评测用例, $1 \leq n \leq 100,1 \leq t \leq 1000$。

对于 $80 \%$ 的评测用例, $1 \leq n \leq 1000,1 \leq t \leq 10^{9}$。

对于所有评测用例, $1 \leq n \leq 10000,1 \leq t \leq 10^{18}$。

蓝桥杯 2021 国赛 A 组 F 题（B 组 G 题，C 组 G 题）。

## 样例 #1

### 输入

```
5 3
10110```

### 输出

```
11010```

# AI分析结果

• 综合分析与结论：
    - 思路：这几道题解都意识到直接暴力求解会超时，通过找规律发现变换存在周期性。当变换次数达到大于等于n的最小2的整数次幂时，会出现循环。利用此周期性，将给定变换次数t对该2的整数次幂取模，从而减少实际变换次数。
    - 算法要点：先找到大于等于n的最小2的整数次幂x，计算t对x的模得到实际变换次数，再根据异或变换规则从后往前遍历字符串进行变换。
    - 解决难点：核心在于发现并证明变换的周期性，从而优化时间复杂度，避免暴力求解的超时问题。
    - 整体来看，各题解思路相近，主要差异在代码风格与细节表述。

所选的题解：
  - 作者：ryf_loser (5星)
    - 关键亮点：不仅通过举例模拟找出规律，还对规律进行了证明，思路清晰，代码简洁高效。
    - 个人心得：通过举两个例子模拟找规律，在后续对规律进行证明。
    - 核心代码：
```c
#include<stdio.h>
long long n,t;
int x=1;
char s[10005];
int main(){
    scanf ("%lld%lld",&n,&t);
    scanf ("%s",s);
    while(x<n)x<<=1;t=t%x;
    for(int i=0;i<t;i++)
        for(int j=n-1;j>=1;j--)
            s[j]=(s[j]-'0')^(s[j-1]-'0')+'0';
    printf ("%s",s);
    return 0;
}
```
核心实现思想：先找到满足条件的x，对t取模，然后按规则进行实际次数的变换。

  - 作者：封禁用户 (4星)
    - 关键亮点：对思路阐述详细，包括对题意的分析、思路的推导以及代码注释清晰，使用string类型处理字符串，较为方便。
    - 核心代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

namespace MuguCode
{
    string s;
    long long n, t, x;

    int main()
    {
        cin >> n >> t >> s;
        x = 1;
        while (x < n)
            x = x << 1;
        t = t % x;
        while (t--)
        {
            for (long long i = n - 1; i >= 1; i--)
                s[i] = ((s[i] - '0') ^ (s[i - 1] - '0')) + '0';
        }
        cout << s << endl;
        return 0;
    }
}
int main()
{
    MuguCode::main();
    return 0;
}
```
核心实现思想：与上一题解类似，先确定x和实际变换次数，再按规则变换字符串。

  - 作者：陈嘉逸2012 (4星)
    - 关键亮点：对时间复杂度分析详细，强调了不开`long long`可能出现的问题，代码简洁明了。
    - 个人心得：强调“十年 OI 一场空，不开`long long`见祖宗！”，提醒注意数据类型。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,x=1;
string s;
int main(){
    cin>>n>>t>>s;
    while(x<n) x<<=1;
    t%=x;
    for(int i=0;i<t;i++){
        for(int j=n-1;j>=1;j--) s[j]=((s[j]-'0')^(s[j-1]-'0'))+'0';
    }
    cout<<s;
}
```
核心实现思想：同样是先找x和实际变换次数，再完成变换操作。

最优关键思路或技巧：通过模拟找规律，发现变换的周期性，利用周期性对变换次数取模优化时间复杂度，将原本可能的$O(nt)$时间复杂度优化到$O(n\log n)$。

可拓展之处：此类题目属于序列变换找规律优化类型，类似套路可用于其他有规律的序列变换问题，如一些基于特定运算规则的数字序列变换。

推荐洛谷题目：
  - P1962 斐波那契数列
  - P1044 栈
  - P1226 取余运算 

---
处理用时：23.81秒
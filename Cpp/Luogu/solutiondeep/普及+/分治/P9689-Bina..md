# 题目信息

# Bina.

## 题目描述

小 J 家门前有两棵树，一棵是二叉树，一棵是三叉树。

你被小 J 叫来修剪他的二叉树，使得他的二叉树的“美丽值”最大，所谓一棵树的美丽值 $=$ 这棵树的点的编号之和 $\div$ 这棵树的深度（结果向下取整）。

这棵二叉树有一个构建参数 $n$，构建方式如下：

```cpp
void build(int s,int t,int p){
  if(s==t) return ;
  build(s,(s+t)/2,2*p);
  build((s+t)/2+1,t,2*p+1);
  add_edge(p,2*p),add_edge(p,2*p+1);
}

int main(){
  build(1,n,1);
  return 0;
}
```

其中 `build(s,t,p)` 函数参数中的 $p$ 是当前点的编号，`add_edge(x,y)` 函数是指将编号为 $x$ 的点向编号为 $y$ 的点连接一条有向边。

容易发现这棵树的根节点是 $1$，并且我们规定节点的深度为节点到根节点路径上经过的点的个数（包括自己和根节点），这棵树的深度即为所有节点深度的最大值。

对于 $n=3$ 的情况，最后构建出来的结果如下，这棵树的深度为 $3$，你需要选择一个深度 $k$ 把深度大于 $k$ 的点都剪掉，但是 $k$ 必须**大于等于** $1$ 且**小于等于**这棵树的深度。

![](https://cdn.luogu.com.cn/upload/image_hosting/ueggbyn8.png)

小 J 还给了你一个要求，你剪去的节点个数一定得大于等于 $m$ 他才会高兴，你需要保证让他高兴的同时树的“美丽值”最大。

现在小 J 给了你构建树的参数 $n$ 和至少剪的节点个数 $m$，要你求出来他的树在你修剪后最大的美丽值是多少，如果无论如何你也不可能让小 J 高兴，输出 $-1$。

## 说明/提示

#### 【样例解释 #1】

对于第一组样例，$n$ 都等于 $3$，构建出来的树同题面所示。

如果我们选择把深度大于 $1$ 的节点全部剪掉，那么我们剪掉了 $2,3,4,5$ 共 $4$ 个节点，美丽值为 $1$。

如果我们选择把深度大于 $2$ 的节点全部剪掉，那么我们剪掉了 $4,5$ 共 $2$ 个节点，美丽值为 $\lfloor \dfrac{1+2+3}{2}\rfloor = 3$。

如果我们选择把深度大于 $3$ 的节点全部剪掉，那么我们没有剪掉任何节点，美丽值为 $\lfloor \dfrac{1+2+3+4+5}{3}\rfloor = 5$。

所以对于 $m=0$ 的情况，答案为 $5$；对于 $1 \le m \le 2$ 的情况，答案为 $3$；对于 $3 \le m \le 4$ 的情况，答案为 $1$；其它情况，无解输出 $-1$。

#### 【数据范围】

对于所有测试数据，满足 $1 \le T \le 10^5$，$1 \le n \le 10^9$，$0 \le m \le 2 \times 10^9$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n \le$ | $m \le$ | $T \le$ | 特殊限制 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1 \sim 2$ | $10^3$ | $10^5$ | $10^3$ | 无 |
| $3 \sim 4$ | $10^6$ | $2 \times 10^6$ | $10^5$ | 无 |
| $5$ | $10^9$ | $1$ | $10^5$ | 无 |
| $6$ | $10^9$ | $2$ | $10^5$ | 无 |
| $7 \sim 8$ | $10^9$ | $3$ | $10^5$ | 无 |
| $9 \sim 10$ | $10^9$ | $2 \times 10^9$ | $10^5$ | $m \ge 1$ |
| $11 \sim 12$ | $10^9$ | $10^3$ | $10^5$ | 无 |
| $13 \sim 16$ | $10^9$ | $2 \times 10^9$ | $10$ | 无 |
| $17 \sim 20$ | $10^9$ | $2 \times 10^9$ | $10^5$ | 所有 $n$ 均相同 |
| $21 \sim 25$ | $10^9$ | $2 \times 10^9$ | $10^5$ | 无 |

## 样例 #1

### 输入

```
6
3 0
3 1
3 2
3 3
3 4
3 5```

### 输出

```
5
3
3
1
1
-1```

## 样例 #2

### 输入

```
10
5 5
10 0
999 155
135 92
1000232 234255
10293845 1239485
123948 1239454
12394 2131094
1000000000 98765432
1000000000 999999999```

### 输出

```
3
40
52377
1161
27487764480
5864061665280
-1
-1
19215358392218419
4969489234738635```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何高效计算修剪后二叉树的美丽值展开。核心思路多基于树的线段树特性，利用其规律减少计算量。算法要点包括计算不同层节点数量与编号和，通过记忆化搜索、分治等方法优化。难点在于处理最后一层非连续编号节点的和。各题解在思路清晰度、代码可读性及优化程度上有差异。

所选的题解：
 - 作者：离散小波变换°  星级：4星
    - 关键亮点：指出建树函数构建的是线段树，利用线段树区间长度本质不同的节点个数只有\(\mathcal O(\log n)\)种的结论，通过归纳法证明并计算节点编号和为关于根节点编号的一次函数，优化后时间复杂度达\(\mathcal O(T\log n)\)。
    - 个人心得：提到出题人卡常数的情况。
    - 重点代码及核心实现思想：
```cpp
// 计算长度为n，限定生长d层的子树节点编号和相关系数
void solve(int n, int d){
    if(n <= o && d <= g) return;
    if(M[d].count(n)) return;
    if(n == 1 || d == 1){
        M[d][n] = {1, 1, 0};
        return;
    }
    const int n1 = (n + 1) / 2, n2 = n - n1;
    solve(n1, d - 1);
    solve(n2, d - 1);
    const auto &[c1, u1, v1] = n1 <= o? H[n1][min(g, d - 1)] : M[d - 1][n1];
    const auto &[c2, u2, v2] = n2 <= o? H[n2][min(g, d - 1)] : M[d - 1][n2];
    M[d][n] = {
        c1 + c2 + 1, 1 + 2 * u1 + 2 * u2, v1 + u2 + v2
    };
}
```
核心实现思想是通过递归计算左右子树的相关系数，从而得到当前子树的节点个数、编号和的一次函数系数。

 - 作者：qczrz6v4nhp6u  星级：4星
    - 关键亮点：观察到树除最后一层是满二叉树，通过分析树的结构，利用二进制翻转计算最后一层节点编号和，时间复杂度\(O(T\log n)\)。
    - 个人心得：提到考场上代码没调出来的情况。
    - 重点代码及核心实现思想：
```cpp
// 计算最后一层节点编号和相关值
if((1<<dep)<n){
    cnt[dep+1]=(n-(1<<dep))<<1;
    ll k=n-(1<<dep)-1,res=0;
    for(int i=dep-1;i>=0;i--){
        ll tmp=(k&~((2ll<<i)-1))+(2ll<<i);
        res+=((tmp>>1)-min(tmp-k-1,1ll<<i))<<(dep-i-1);
    }
    sum[dep+1]=(k+1)*((1ll<<(dep+2))+1)+(res<<2);
    dep++;
}
```
核心实现思想是先确定最后一层节点个数，通过按位分析计算最后一层节点编号和。

 - 作者：zct_sky  星级：4星
    - 关键亮点：根据树的结构，分\(m = 0\)与\(m \neq 0\)讨论。\(m \neq 0\)时按规则剪掉最后一层部分节点；\(m = 0\)时用分治计算最后一层节点和，取去与不去最后一层美丽值的最大值，时间复杂度\(\mathcal O(T\log n)\)。
    - 个人心得：提到赛时没取最大值导致只拿80分的教训。
    - 重点代码及核心实现思想：
```cpp
// 分治计算最后一层节点和
ll f(ll a,ll b){
    if(b<=1||a==1)return 0;
    if(a==2)return 1;
    if(a==b)return (a-1)*a/2;
    if(b>a/2)return 2*f(a/2,a/2)+2*f(a/2,b-a/2)+b-a/2;
    return 2*f(a/2,b);
}
```
核心实现思想是根据节点数量关系，通过分治递归计算最后一层节点和。

最优关键思路或技巧：利用树的线段树结构特性，挖掘每层节点数量和编号的规律，通过归纳法、分治、记忆化搜索等方法优化计算，减少时间复杂度。

可拓展之处：此类题可拓展到其他基于特定规则构建的树结构，求类似的节点统计量或最值问题。类似算法套路包括利用树的层级规律、节点编号规律，结合递归、分治、记忆化等优化技巧。

推荐题目：
 - [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
 - [P1828 [USACO3.4] 香甜的黄油 Sweet Butter](https://www.luogu.com.cn/problem/P1828)
 - [P2572 [SCOI2010] 序列操作](https://www.luogu.com.cn/problem/P2572)

个人心得摘录及总结：离散小波变换°提到出题人卡常数；qczrz6v4nhp6u考场上代码未调通；zct_sky赛时因未取最大值丢分。总结为比赛调试要细心，关注题目细节，同时注意常数优化。 

---
处理用时：34.24秒
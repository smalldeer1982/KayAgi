# 题目信息

# 数列前缀和 3

## 题目描述

给定模质数 $p$ 域上的 $k$ 阶非奇异矩阵列 $a$，给定 $q$ 次询问，每次给出 $l, r$，求 $\prod \limits_{i = l}^r a_i$。$p = 1145141$。

注：模 $p$ 域上的非奇异矩阵指：矩阵乘法加法均在模 $p$ 下进行，矩阵（在实数域下）的行列式值对 $p$ 取余不为 $0$。

## 说明/提示

### 样例 1 解释
$a_1 = \begin{pmatrix} 2 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9\end{pmatrix}$，$a_2 = \begin{pmatrix} 2 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9\end{pmatrix}$，$a_3 = \begin{pmatrix} 20 & 20 & 21 \\ 22 & 23 & 24
\\ 25 & 26 & 27\end{pmatrix}$。

$a_1 \times a_2 = \begin{pmatrix} 33 & 38 & 45 \\ 
70 & 81 & 96 \\
109 & 126 &150 \end{pmatrix}$，$a_2 \times a_3 = \begin{pmatrix}159 & 164 & 171 \\ 340 & 351 & 366 \\
541 & 558& 582  \end{pmatrix}$，$a_1 \times a_2 \times a_3 = \begin{pmatrix}2621 &2704& 2820 \\   
5582 & 5759 & 6006    \\
8702 & 8978 & 9363    \end{pmatrix}$。

所有数字的按位异或和为 $14921$。

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n, q \leq 10^6$，$2 \leq k \leq 3$，$1 \leq l \leq r \leq n$，矩阵元素均为小于 $p$ 的正整数。

## 样例 #1

### 输入

```
3 3 3
2 2 3
4 5 6
7 8 9
2 2 3
4 5 6
7 8 9
20 20 21
22 23 24
25 26 27
1 2
2 3
1 3```

### 输出

```
14921```

# AI分析结果

### 综合分析与结论
这三道题解均围绕在模质数域上求矩阵列区间乘积的问题展开，整体思路有两种方向：一是通过维护矩阵前缀积并结合矩阵求逆来解决；二是利用线段树结构存储矩阵区间积。
 - **一扶苏一的题解**：思路清晰，先点明非交换群区间和左右乘的区别，通过维护矩阵前缀积 $s_i$，利用 $(AB)^{-1}=B^{-1}A^{-1}$ 的性质得出 $\prod\limits_{i = l}^r a_i = s_{l - 1}^{-1} \times s_r$，并针对 $k$ 为 $2$ 或 $3$ 的情况，详细介绍伴随矩阵法求逆矩阵，代码实现简洁明了，注释丰富。
 - **l_615 的题解**：采用线段树做法，避免了矩阵求逆，但因复杂度较高，需进行循环展开优化常数。代码实现中快读、循环展开等优化较多，但整体代码相对冗长，思路理解上较矩阵前缀积稍复杂。
 - **Flanksy 的题解**：同样基于前缀积和前缀逆元思路，使用高斯 - 约旦消元法求逆矩阵，代码通过结构体和重载运算符模块化，但相比伴随矩阵法求逆，代码实现上稍显复杂。

综合来看，一扶苏一的题解在思路清晰度、代码可读性及优化程度上表现最佳；Flanksy 的题解次之；l_615 的题解因复杂度较高且代码冗长，相对逊色。

### 所选的题解
 - **一扶苏一题解**：★★★★★
    - **关键亮点**：思路清晰，详细阐述非交换群区间和特性，针对低阶矩阵利用伴随矩阵法求逆矩阵，代码简洁且注释详细。
    - **重点代码**：
```cpp
// 矩阵乘法重载
inline Matrix operator*(const Matrix& o) const {
    Matrix ret;
    for (int i = 0; i < k; ++i) {
        for (int j = 0; j < k; ++j) {
            ret.A[i][j] = 0;
            for(int h = 0; h < k; ++h) {
                ret.A[i][j] += A[i][h] * o.A[h][j];
            }
            ret.A[i][j] %= p;
        }
    }
    return ret;
}
// 二阶行列式计算
inline int Det2(ll a, ll b, ll c, ll d) { 
    int ret = (a * d - b * c) % p;
    if (ret < 0) ret += p;
    return ret;
}
// 行列式计算
inline int Det() {
    if (k == 2) { return Det2(A[0][0], A[0][1], A[1][0], A[1][1]); }
    else {
        ll ret = 0;
        (ret += A[0][0] * A[1][1] * A[2][2]) %= p;
        (ret += A[0][1] * A[1][2] * A[2][0]) %= p;
        (ret += A[0][2] * A[1][0] * A[2][1]) %= p;
        (ret -= A[0][2] * A[1][1] * A[2][0]) %= p;
        (ret -= A[0][0] * A[1][2] * A[2][1]) %= p;
        (ret -= A[0][1] * A[1][0] * A[2][2]) %= p;
        (ret += p) %= p;
        return ret;
    }
}
// 矩阵求逆重载
inline Matrix operator~() {
    ll d = inv[Det()];
    Matrix ret;
    if (k == 2) {
        ret.A[0][0] = A[1][1] * d % p;
        ret.A[1][0] = (p - A[1][0]) * d % p;
        ret.A[1][1] = A[0][0] * d % p;
        ret.A[0][1] = (p - A[0][1]) * d % p;
    } else {
        ret.A[0][0] = Det2(A[1][1], A[1][2], A[2][1], A[2][2]) * d % p;
        ret.A[1][0] = Det2(A[1][0], A[1][2], A[2][0], A[2][2]) * d % p;
        ret.A[2][0] = Det2(A[1][0], A[1][1], A[2][0], A[2][1]) * d % p;
        ret.A[0][1] = Det2(A[0][1], A[0][2], A[2][1], A[2][2]) * d % p;
        ret.A[1][1] = Det2(A[0][0], A[0][2], A[2][0], A[2][2]) * d % p;
        ret.A[2][1] = Det2(A[0][0], A[0][1], A[2][0], A[2][1]) * d % p;
        ret.A[0][2] = Det2(A[0][1], A[0][2], A[1][1], A[1][2]) * d % p;
        ret.A[1][2] = Det2(A[0][0], A[0][2], A[1][0], A[1][2]) * d % p;
        ret.A[2][2] = Det2(A[0][0], A[0][1], A[1][0], A[1][1]) * d % p;
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) if ((i + j) & 1) {
                ret.A[i][j] = p - ret.A[i][j];
            }
        }
    }
    return ret;
} 
```
核心实现思想：通过重载运算符实现矩阵乘法、求行列式及矩阵求逆等操作，利用伴随矩阵法根据矩阵阶数不同分别计算逆矩阵。
 - **Flanksy 题解**：★★★★
    - **关键亮点**：基于前缀积和前缀逆元思路，使用高斯 - 约旦消元法求逆矩阵，通过结构体和重载运算符模块化代码。
    - **重点代码**：
```cpp
// 约旦 - 高斯消元求逆矩阵
Matrix operator~(){
    Matrix ret(n);
    memset(tmp,0,sizeof(tmp));
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++) tmp[i][j]=a[i][j];
    for(int i=1;i<=n;i++) tmp[i][i+n]=1;
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j++) if(tmp[j][i]){
            if(i!=j) swap(tmp[i],tmp[j]);
            break;
        }
        int niv=inv[tmp[i][i]];
        for(int j=i;j<=n*2;j++) tmp[i][j]=1ll*tmp[i][j]*niv%mod;
        for(int j=1;j<=n;j++) if(i!=j){
            int mti=tmp[j][i];
            for(int k=i;k<=n*2;k++) tmp[j][k]=(tmp[j][k]-1ll*mti*tmp[i][k]%mod+mod)%mod;
        }
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++) ret.a[i][j]=tmp[i][j+n];
    return ret;
}
```
核心实现思想：利用高斯 - 约旦消元法，对增广矩阵进行行变换，将原矩阵部分变为单位矩阵，从而得到逆矩阵。

### 最优关键思路或技巧
 - **利用矩阵前缀积和矩阵求逆**：通过维护矩阵前缀积，结合矩阵求逆来快速获取区间矩阵乘积，避免每次区间查询都进行重复计算。
 - **针对低阶矩阵采用伴随矩阵法求逆**：对于 $k$ 为 $2$ 或 $3$ 的矩阵，伴随矩阵法求逆矩阵相比通用的高斯消元法代码实现更简洁，计算量更小。

### 可拓展之处
此类题目拓展方向主要在于矩阵规模变大、矩阵运算规则变化或查询类型增加等。类似算法套路有维护前缀和、前缀积等，结合数据结构（如线段树、树状数组）优化查询操作。

### 相似知识点洛谷题目
 - **P3390 【模板】矩阵快速幂**：考察矩阵乘法与快速幂结合。
 - **P4783 【模板】矩阵求逆**：专注于矩阵求逆运算。
 - **P1962 斐波那契数列**：利用矩阵快速幂优化斐波那契数列计算。 

---
处理用时：45.20秒
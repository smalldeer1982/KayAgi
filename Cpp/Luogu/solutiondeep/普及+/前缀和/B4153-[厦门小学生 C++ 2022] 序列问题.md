# 题目信息

# [厦门小学生 C++ 2022] 序列问题

## 题目背景

本试题为 2022 年厦门市小学生 C++ 语言**复赛**试题，数据为洛谷自造。

**初赛**为笔试。

考虑到评测机性能差异，本题时限相较原题下调 0.5s。

## 题目描述

高老师是一位经验丰富的信息学竞赛指导教师，善于开发学生的创造性思维。周末课上，他给学生留下一道关于 $01$ 串的思考题（所谓 $01$ 串就是由字符 $0$ 和 $1$ 组成的字符串）：给定一个长度为 $n$ 的 $01$ 串，他想知道有多少个子串，满足其中 $1$ 的个数比 $0$ 的个数多。现在高老师请会编程的你来帮忙计算答案。 

## 说明/提示

### 样例解释

满足条件的子串有：$1$，$1$，$1$，$11$，$11$，$111$

### 数据范围

- 对于 $20\%$ 的数据，$n\leq 3000$。
- 对于另外的 $10\%$ 的数据，$n\leq 10^7$，字符串全为 $1$。
- 对于另外的 $20\%$ 的数据，$n\leq 2\times 10^5$。
- 对于另外的 $20\%$ 的数据，$n\leq 2\times 10^6$。
- 对于另外的 $100\%$ 的数据，$n\leq 10^7$。

## 样例 #1

### 输入

```
3
111```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
三道题解都围绕如何优化计算满足条件的01子串数量展开，核心思路都是通过前缀和来快速判断子串中1和0的数量关系，进而优化暴力算法。
 - **yedalong题解**：先阐述暴力解法，再提出前缀和加哈希表优化，最后点明正解是将哈希表改为数组以优化时间复杂度，思路清晰，代码注释详细，对关键步骤有解释。
 - **_Deer_Peach_题解**：直接提出前缀和优化思路，通过数组记录前缀和数量，代码简洁，逻辑连贯。
 - **wenlebo题解**：从分析问题得出数学关系，进而引出动态规划思路，代码也较为简洁，但对公式推导依赖较多，理解难度稍高。

综合来看，yedalong和_Deer_Peach_的题解在思路清晰度和代码可读性上表现更好，wenlebo题解的动态规划思路虽独特但稍显复杂。

### 所选的题解
 - **yedalong题解**：★★★★☆
    - **关键亮点**：循序渐进讲解思路，从暴力到优化再到正解，对前缀和加哈希表优化部分解释详细，方便理解。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
string s;
ll ans,sum,cnt,n,mp[20000005];
int main(){
    cin>>n>>s;
    mp[n]=1;
    for(int i=0;i<n;i++){
        if(s[i]=='1') cnt+=mp[n+sum],sum++;
        else cnt-=mp[n+sum-1],sum--;
        mp[n+sum]++; ans+=cnt;
    }
    cout<<ans<<'\n';
    return 0;
}
```
    - **核心实现思想**：将1的贡献设为1，0的贡献设为 - 1做前缀和，用数组mp记录前缀和出现的次数，通过cnt统计满足条件的子串数量。

 - **_Deer_Peach_题解**：★★★★
    - **关键亮点**：思路简洁直接，代码简洁明了，通过数组记录前缀和数量，避免使用较慢的map。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+5;
int n,res,num,ans;
char s[N];
int mp[N*2];
signed main(){
	scanf("%lld",&n);
	scanf("%s",s+1);
    mp[n]=1;
    for(int i=1;i<=n;i++){
        ans+=s[i]=='1'?mp[n+num]:-mp[n+num-1];
		num+=s[i]=='1'?1:-1;
        mp[n+num]++,res+=ans;
    }printf("%lld",res);
    return 0;
}
```
    - **核心实现思想**：与yedalong类似，将1视为1，0视为 - 1计算前缀和，利用数组mp记录前缀和数量，动态计算满足条件子串数量。

### 最优关键思路或技巧
将1和0分别赋予1和 - 1的权重计算前缀和，通过记录前缀和的数量，快速统计满足1的数量大于0的数量的子串。这种前缀和结合数组记录的方式，优化了暴力枚举子串的时间复杂度，将其从$O(n^2)$降至$O(n)$。

### 可拓展之处
同类型题或类似算法套路：此类问题可拓展到其他字符统计类子串问题，通过赋予不同字符不同权重计算前缀和，利用数据结构记录前缀和状态，从而解决子串统计问题。例如，统计满足特定字符数量关系的子串。

### 推荐题目
 - [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：通过前缀和思想解决最大子段和问题，与本题前缀和思路类似。
 - [P3146 [USACO16OPEN]248 G](https://www.luogu.com.cn/problem/P3146)：同样涉及到对序列的处理和状态记录，与本题思路有相似之处。
 - [P1990 覆盖墙壁](https://www.luogu.com.cn/problem/P1990)：虽形式不同，但都需要通过记录状态来优化计算，可锻炼类似思维。 

---
处理用时：34.15秒
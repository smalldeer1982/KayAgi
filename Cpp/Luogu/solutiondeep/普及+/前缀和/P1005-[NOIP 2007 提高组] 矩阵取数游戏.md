# 题目信息

# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# AI分析结果

### 综合分析与结论
所有题解均指出本题每行取数相互独立，可对每行分别处理，采用区间DP算法。主要思路为定义状态表示取某区间能获得的最大分数，通过分析上一次取数的区间来推导转移方程。难点在于确定状态转移方程中的系数（与取数次数相关的$2$的幂次）以及处理高精度计算（因数据范围可能爆long long）。各题解在状态定义、转移方程推导和代码实现细节上略有差异。

### 所选题解
- **作者：Jack_Homes_Huang（5星）**
    - **关键亮点**：思路清晰，详细阐述了DP流程，包括状态定义、转移方程推导及终值确定，对高精度计算的说明全面，代码使用结构体重载运算符，可读性强。
    - **个人心得**：强调高精度计算的繁琐，提到`int128`不可用时只能用传统高精度方法，如四位压缩法。
    - **重点代码 - 核心实现思想**：通过`BaseTwo`函数预处理$2$的幂，在`main`函数中对每行数据进行区间DP，利用重载的高精度运算函数更新`f`数组，最后累加每行结果得到总答案。
```cpp
void BaseTwo() {
    base[0].p[1] = 1, base[0].len = 1;
    for (int i = 1; i <= m + 2; i++){ 
        base[i] = base[i - 1] * 2;
    }
} 

int main(void) {
    scanf("%d%d", &n, &m);
    BaseTwo();
    while (n--) {
        memset(f, 0, sizeof f);
        for (int i = 1; i <= m; i++)
            scanf("%d", &ar[i]);
        for (int i = 1; i <= m; i++)
            for (int j = m; j >= i; j--) { 
                f[i][j] = max(f[i][j], f[i - 1][j] + base[m - j + i - 1] * ar[i - 1]); 
                f[i][j] = max(f[i][j], f[i][j + 1] + base[m - j + i - 1] * ar[j + 1]);
            } 
        HP Max;
        for (int i = 1; i <= m; i++)
            Max = max(Max, f[i][i] + base[m] * ar[i]);
        ans = ans + Max; 
    }
    ans.print(); 
    return 0;
}
```
- **作者：zhylj（4星）**
    - **关键亮点**：转移方程推导独特且简洁，代码使用`__int128`简化高精度处理，整体简洁明了。
    - **重点代码 - 核心实现思想**：`solve`函数中通过双重循环进行区间DP，根据转移方程更新`f`数组，最后返回`f[1][m]`，在`main`函数中累加每行结果。
```cpp
__int128 solve(__int128 a[])
{
    memset(f,0,sizeof(f));
    for(int len=0;len<=m;++len)
    	for(int i=1;i+len<=m;++i)
            f[i][i+len]=max(2*f[i+1][i+len]+2*a[i],2*f[i][i+len-1]+2*a[i+len]);
    return f[1][m];
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            input(game[i][j]);
    for(int i=1;i<=n;i++)
        ans+=solve(game[i]);
    output(ans);
    return 0;
}
```
- **作者：qhr2023（4星）**
    - **关键亮点**：清晰阐述从小区间向大区间转移的思路，对转移方程中乘$2$的操作解释到位，代码简洁高效。
    - **重点代码 - 核心实现思想**：在`main`函数中，通过三层循环进行区间DP，根据转移方程更新`f`数组，最后累加每行的`f[1][m]`得到答案。
```cpp
int main () {
    cin >> n >> m;
    for (int i=1; i<=n; ++i)
        for (int j=1; j<=m; ++j)
            cin >> a[i][j];
    for (int i=1; i<=n; ans+=f[1][m], memset(f, 0, sizeof f), ++i) 
        for (int len=1; len<=m; ++len) 
            for (int l=1, r=l+len-1; r<=m; ++l, ++r)
                f[l][r]=max(f[l+1][r]+a[i][l], f[l][r-1]+a[i][r])*2;
    out(ans);
    return 0;
}
```

### 最优关键思路或技巧
- **区间DP状态定义与转移**：定义`f[i][j]`表示取区间`[i, j]`的最大得分，根据上一次取数区间推导转移方程，从大区间向小区间或小区间向大区间转移均可，关键是理解取数顺序与得分计算的关系。
- **高精度处理**：数据范围较大时，可使用`__int128`简化高精度计算；若不支持，可采用传统高精度算法，如四位压缩法。

### 可拓展思路
此类题目属于区间DP类型，通常具有最优子结构性质。类似套路为分析问题的子问题结构，定义合适的状态表示子问题的解，根据子问题间的关系推导转移方程。常见变化包括改变取数规则、得分计算方式或数据范围等。

### 相似知识点洛谷题目
- [P1880 [NOIP2012 提高组] 石子合并](https://www.luogu.com.cn/problem/P1880)
- [P4170 [CQOI2007] 涂色](https://www.luogu.com.cn/problem/P4170)
- [P3146 [USACO16OPEN]248 G](https://www.luogu.com.cn/problem/P3146)

---
处理用时：36.74秒
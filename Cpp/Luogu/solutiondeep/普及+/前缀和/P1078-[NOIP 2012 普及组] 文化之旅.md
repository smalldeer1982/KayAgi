# 题目信息

# [NOIP 2012 普及组] 文化之旅

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。由于测试数据过水，可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）。本题题目和数据仅供参考。本题不接受添加 hack 数据。

本题为错题。**不建议尝试或提交本题。**[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。

现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。


## 说明/提示

输入输出样例说明$1$

由于到国家 $2$ 必须要经过国家$ 1$，而国家$ 2 $的文明却排斥国家 $1$ 的文明，所以不可能到达国家 $2$。


输入输出样例说明$2$

路线为$ 1$ ->$ 2$

【数据范围】

对于 100%的数据，有$ 2≤N≤100$

$1≤K≤100$ 

$1≤M≤N^2$

$1≤k_i≤K$

$1≤u, v≤N$ 

$1≤d≤1000,S≠T,1≤S,T≤N$

NOIP 2012 普及组 第四题


## 样例 #1

### 输入

```
2 2 1 1 2 
1 2 
0 1 
1 0 
1 2 10 
```

### 输出

```
-1```

## 样例 #2

### 输入

```
2 2 1 1 2 
1 2 
0 1 
0 0 
1 2 10 ```

### 输出

```
10```

# AI分析结果

### 综合分析与结论
这些题解主要围绕图的遍历与最短路算法求解该问题，不同算法在处理文化排斥和不重复学习等限制条件上各有特点。
1. **思路与算法要点**
    - **启发式搜索**：先求无视文化排斥的最短路（如SPFA），再以当前点花费与该点到终点无视文化排斥最短路花费之和作为剪枝条件进行DFS。
    - **Floyd算法**：利用Floyd插点特性记录路径文化信息，更新最短路时判断文化排斥和重复情况。
    - **DFS + 剪枝**：通过剪枝减少不必要搜索，如在输入时取国家间最短路径、用数组记录到达各点最短路径进行剪枝。
    - **Dijkstra算法**：在算法中加入状态标记，如用数组记录文化是否已遍历，松弛前判断下一个点文化与已走过点文化是否冲突。
    - **A*算法**：定义估价函数为当前代价加该点到终点最短路长度，通过建边时去除无用边、用bitset合并判断文化排斥优化。
2. **解决难点**：主要难点在于处理文化排斥和不重复学习的限制。不同算法通过不同方式解决，如标记已学习文化、判断文化间排斥关系等。
3. **评分**：综合思路清晰度、代码可读性、优化程度等因素，各题解评分如下：
    - **Created_equal1**：4星。思路清晰，利用先求无视文化排斥最短路进行剪枝，代码结构完整。
    - **wjyyy**：3星。使用Floyd算法，但代码对Floyd插点标记解释较复杂，可读性稍欠。
    - **赵晨洋**：3星。DFS结合SPFA剪枝，但代码中部分判断条件较复杂，可读性一般。
    - **fishfree88**：3星。DFS加简单剪枝思路较基础，代码实现较简单，但优化程度有限。
    - **tommymio**：3星。Dijkstra算法结合路径记录判断文化冲突，代码细节较多，可读性一般。
    - **Charles_with_wkc**：3星。Dijkstra算法加入状态标记，但代码未过样例却AC，可靠性存疑。
    - **yedalong**：3星。深搜加记忆化和删重边优化，代码实现较常规，优化效果一般。
    - **_Weslie_**：3星。Dijkstra算法加入文化遍历标记，代码细节较多，整体较常规。
    - **grard4**：4星。A*算法思路较新颖，通过去除无用边和bitset优化，有一定创新性。
    - **Little_duck_GGG**：3星。Floyd处理文化排斥结合深搜，代码实现较常规，思路较简单。

### 所选4星及以上题解
1. **Created_equal1（4星）**
    - **关键亮点**：先通过SPFA求无视文化排斥最短路，为后续DFS提供剪枝依据，有效减少搜索空间。
    - **个人心得**：无
    - **核心代码**
```cpp
void Spfa()
{
    memset(Dist, 0X7F, sizeof(Dist));
    queue<unsigned int> Q;
    Q.push(S);
    In_Q[S] = true;
    Dist[S] = 0;
    unsigned int Top;
    while (Q.size())
    {
        Top = Q.front();
        Q.pop();
        In_Q[Top] = false;
        for (size_t i = Head[Top];i;i = Next[i])
            if (Dist[To[i]] > Dist[Top] + Weight[i])
            {
                Dist[To[i]] = Dist[Top] + Weight[i];
                if (!In_Q[To[i]])
                {
                    In_Q[To[i]] = true;
                    Q.push(To[i]);
                }
            }
    }
}
void Dfs(const size_t &Now, const unsigned int &D)
{
    Went[Now] = true;
    culture.insert(C[Now]);
    if (Now == S)
    {
        Ans = min(Ans, D);
        return;
    }
    if (D + Dist[Now] > Ans)
        return;
    for (size_t i = Head[Now];i;i = Next[i])
        if (!Went[To[i]] && check(C[To[i]]))
            Dfs(To[i], D + Weight[i]);
    Went[Now] = false;
    culture.erase(C[Now]);
}
```
    - **核心思想**：`Spfa`函数通过队列实现SPFA算法求最短路。`Dfs`函数在DFS过程中，先标记当前点和文化，若到达终点更新答案；若当前花费与到终点最短路花费之和大于答案则剪枝，否则继续DFS。
2. **grard4（4星）**
    - **关键亮点**：采用A*算法，通过合理定义估价函数，在建边时去除无用边，并用bitset优化文化排斥判断，提高算法效率。
    - **个人心得**：无
    - **核心代码**
```cpp
struct node{
    int u,w;bitset<MAXN> ok;
    friend bool operator<(const node &x,const node &y){
        return 1ll*x.w+dis[x.u]>1ll*y.w+dis[y.u];
    }
};
priority_queue<node> q;
void spfa(){
    memset(dis,0x7f,sizeof(dis));
    queue<int> Q;
    dis[t]=0;Q.push(t);
    while(!Q.empty()){
        int u=Q.front();Q.pop();
        vis[u]=false;
        for (int i=h2[u];i;i=e2[i].nxt){
            int v=e2[i].to,w=e2[i].val;
            if (dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                if (!vis[v]) vis[v]=true,Q.push(v);
            }
        }
    }
}
int main(){
    cin>>n>>k>>m>>s>>t;
    //...
    spfa();
    if (dis[s]==dis[0]) {puts("-1");return 0;}
    bitset<MAXN> p;p.set(c[s]);
    q.push({s,0,p});
    while(!q.empty()){
        int u=q.top().u,w=q.top().w;
        if (u==t) {cout<<w<<endl;return 0;}
        bitset<MAXN> ok=q.top().ok;
        q.pop();
        for (int i=h1[u];i;i=e1[i].nxt){
            int v=e1[i].to,w1=e1[i].val;
            p=ok&a[c[v]];
            if (p.any()) continue;
            p=ok,p.set(c[v]);
            q.push({v,w+w1,p});
        }
    }
    puts("-1");
    return 0;
}
```
    - **核心思想**：`spfa`函数对终点跑单源最短路求各点到终点距离。`main`函数中，`node`结构体定义A*算法节点，包含当前点、当前代价和文化状态。优先队列按估价函数排序，每次取出估价最小节点扩展，判断文化排斥情况并更新状态。

### 最优关键思路或技巧
1. **剪枝技巧**：如Created_equal1通过先求无视文化排斥最短路进行剪枝，减少不必要搜索。
2. **状态标记与判断优化**：grard4用bitset合并判断文化排斥，减少枚举时间复杂度；tommymio等在Dijkstra算法中加入文化状态标记判断。

### 同类型题或类似算法套路
1. **同类型题**：涉及图的遍历、最短路求解并带有特殊限制条件的题目，如某些带权图中节点或边存在特殊属性限制访问。
2. **类似算法套路**：在图算法基础上，根据特殊限制条件加入状态标记、剪枝策略等优化算法。如在最短路算法中，根据节点属性标记已访问状态，避免重复访问；或在搜索算法中，利用预处理信息进行剪枝。

### 推荐洛谷题目
1. **P1339 [USACO09OCT]热浪Heat Wave**：经典的单源最短路问题，可巩固最短路算法基础。
2. **P3371 【模板】单源最短路径（弱化版）**：单源最短路模板题，适合练习Dijkstra、Bellman - Ford等算法。
3. **P1119 灾后重建**：结合图的最短路与时间因素，与本题类似需考虑特殊条件对路径的影响。 

---
处理用时：53.09秒
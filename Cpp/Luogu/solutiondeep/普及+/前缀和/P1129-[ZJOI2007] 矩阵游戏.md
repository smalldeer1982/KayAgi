# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕二分图匹配和网络流算法解决矩阵游戏问题。思路是将矩阵中的黑色格子视为匹配边，把行和列看作二分图的两个点集，通过建图和匹配判断是否能实现主对角线全黑。二分图匹配多采用匈牙利算法，网络流则常用Dinic算法。难点在于理解行列交换不影响最大匹配这一性质，并将问题转化为合适的图论模型。

所选的题解：
  - 作者：俾斯麦 (赞：119)  星级：5星
    - 关键亮点：详细阐述二分图最大匹配解法和网络流Dinic解法，包括题目分析、算法原理及具体代码实现，代码注释详细，对初始化和时间优化有说明。
    - 个人心得：无
    - 重点代码 - 匈牙利二分图匹配解法核心代码：
```cpp
bool  dfs( int  x ){ //匹配
    for( int  i = head[ x ], y  ; i ; i = next[ i ] )
        if(!visit[ y = to[ i ] ] ){
            visit[ y ] = 1 ;
            if(!match[ y ] || dfs(match[ y ] ) ){
                match[ y ] = x ; return true ;
            }
        }
    return  false ;
}
```
核心思想：从当前行出发，寻找未访问且可匹配的列，若列未匹配或其匹配行能找到新匹配，则更新匹配关系。
    - 重点代码 - Dinic网络流解法核心代码：
```cpp
bool  bfs(){//在残量网络上构造分层图
    memset( d, 0, sizeof(d) ) ; 
    while( q.size() ) q.pop() ; 
    q.push( s ) ; d[ s ] = 1 ; 
    while( q.size() ){
        int  x = q.front() ; q.pop() ;
        for( int  i = head[ x ] ; i ; i = next[ i ])
            if( w[ i ] &&!d[ to[i] ] ){
                q.push( to[ i ] ) ;
                d[ to [ i ] ] = d[ x ] + 1;
                if( to[ i ] == t )return 1 ; 
            }
    }
    return 0 ;
}
int  dinic( int  x, int  flow ){ 
    if( x == t )return flow ;
    int  rest = flow, k ;
    for( int  i = head[ x ] ; i && rest ; i = next[ i ] )
        if( w[ i ] && d[ to [ i ] ] == d[ x ] + 1 ){
        	k = dinic( to[ i ], min( rest, w[ i ] ) );
        	if(!k )d[ to [ i ] ] = 0 ; 
        	w[ i ] -= k ; 
        	w[ i ^ 1 ] += k ;
        	rest -= k ; 
        }
       return flow - rest ; 
}
```
核心思想：bfs构建分层图，dinic在分层图上增广，通过不断寻找增广路更新最大流。
  - 作者：Night_Aurora (赞：153)  星级：5星
    - 关键亮点：清晰阐述推导过程，将问题转化为二分图最大流问题，明确指出交换行和列不改变匹配数，思路简洁明了。
    - 个人心得：无
    - 重点代码：无（未给出代码）
  - 作者：cmwqf (赞：60)  星级：4星
    - 关键亮点：通过直观的二分图图示，说明行列交换不改变最大匹配的性质，代码简洁易懂。
    - 个人心得：无
    - 重点代码：
```cpp
bool dfs(int x)
{
    for(int i=1;i<=n;i++)
            if(G[x][i]&&!vis[i])
            {
                vis[i]=true;
                if(!matched[i]||dfs(matched[i]))
                {
                    matched[i]=x;
                    return true;
                }
            }
    return false;
}
```
核心思想：采用匈牙利算法，从当前行找可匹配列，更新匹配关系。

• 最优关键思路或技巧：将矩阵游戏问题转化为二分图匹配问题，利用行列交换不改变最大匹配的性质，通过匈牙利算法或网络流算法求解。在代码实现上，注意多组数据的初始化，以及采用时间戳等方式优化匈牙利算法，减少不必要的重复计算。

• 可拓展之处：此类题目属于图论中匹配问题的应用，类似套路是将实际问题抽象为二分图模型，判断是否存在完美匹配。同类型题可能会在矩阵操作、匹配条件上进行变化，例如改变操作类型或要求特定子矩阵的匹配。

• 相似知识点洛谷题目：
  - P3386 【模板】二分图匹配
  - P1963 [NOIP2013 提高组] 货车运输
  - P2756 飞行员配对方案问题

• 个人心得摘录与总结：
  - 作者：707001933K：使用dinic网络流建图时，发现之前模板存在导致死循环的bug，通过自己尝试数据才解决。总结为在使用模板时要注意细节，不能盲目信任通过过题的模板，需对模板原理深入理解，以应对不同题目情况。 

---
处理用时：55.64秒
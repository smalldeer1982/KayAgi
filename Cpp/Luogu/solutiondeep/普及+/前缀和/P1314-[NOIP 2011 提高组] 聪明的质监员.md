# 题目信息

# [NOIP 2011 提高组] 聪明的质监员

## 题目描述

`小T` 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 $n$ 个矿石，从 $1$ 到 $n$ 逐一编号，每个矿石都有自己的重量 $w_i$ 以及价值 $v_i$ 。检验矿产的流程是：

1. 给定$ m$ 个区间 $[l_i,r_i]$；
2. 选出一个参数 $W$；
3. 对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：

$$y_i=\sum\limits_{j=l_i}^{r_i}[w_j \ge W] \times \sum\limits_{j=l_i}^{r_i}[w_j \ge W]v_j$$  

其中 $j$ 为矿石编号。

这批矿产的检验结果 $y$ 为各个区间的检验值之和。即：$\sum\limits_{i=1}^m y_i$  

若这批矿产的检验结果与所给标准值 $s$ 相差太多，就需要再去检验另一批矿产。`小T` 不想费时间去检验另一批矿产，所以他想通过调整参数 $W$ 的值，让检验结果尽可能的靠近标准值 $s$，即使得 $|s-y|$ 最小。请你帮忙求出这个最小值。


## 说明/提示

【输入输出样例说明】

当 $W$ 选 $4$ 的时候，三个区间上检验值分别为 $20,5 ,0$ ，这批矿产的检验结果为 $25$，此时与标准值 $S$ 相差最小为 $10$。

【数据范围】

对于 $10\% $ 的数据，有 $1 ≤n ,m≤10$；

对于 $30\% $的数据，有 $1 ≤n ,m≤500$ ；

对于 $50\% $ 的数据，有 $ 1 ≤n ,m≤5,000$；
 
对于 $70\%$ 的数据，有 $1 ≤n ,m≤10,000$ ；

对于 $100\%$ 的数据，有 $ 1 ≤n ,m≤200,000$，$0 < w_i,v_i≤10^6$，$0 < s≤10^{12}$，$1 ≤l_i ≤r_i ≤n$ 。


## 样例 #1

### 输入

```
5 3 15 
1 5 
2 5 
3 5 
4 5 
5 5 
1 5 
2 4 
3 3 ```

### 输出

```
10
```

# AI分析结果

• 综合分析与结论：这些题解均围绕二分答案与前缀和展开。思路上，利用二分查找参数 \(W\)，通过前缀和快速计算每个区间的检验值 \(y_i\) 及总和 \(y\)，并与标准值 \(s\) 比较，调整二分上下界。算法要点在于二分的范围确定及前缀和数组的构建。解决难点在于理解式子含义及利用单调性确定二分方向。大部分题解思路清晰，代码实现类似，差异主要在细节处理和代码风格上。

所选的题解：
  - **作者：An_Aholic (5星)**
    - **关键亮点**：思路阐述清晰，对式子含义、二分思路及前缀和使用解释详细，代码注释丰富，可读性强。
    - **个人心得**：无
    ```cpp
    bool check(ll wq) {
        y = 0;
        memset(qzh1, 0, sizeof(qzh1));  
        memset(qzh2, 0, sizeof(qzh2));
        for (int i = 1; i <= n; i++) {
            if (w[i] > wq) 
                qzh1[i] = qzh1[i - 1] + 1, qzh2[i] = qzh2[i - 1] + v[i]; 
            else
                qzh1[i] = qzh1[i - 1], qzh2[i] = qzh2[i - 1];  
        }
        for (int i = 1; i <= m; i++) {
            int rrrr = r[i];
            int llll = l[i];
            y += (qzh1[rrrr] - qzh1[llll - 1]) * (qzh2[rrrr] - qzh2[llll - 1]);  
        }
        if (y > s)
            return 1;  
        else
            return 0;
    }
    ```
    **核心实现思想**：`check` 函数用于计算当前 \(W\)（`wq`）下的检验结果 \(y\)，先初始化前缀和数组，遍历矿石更新前缀和，再遍历区间计算 \(y\)，最后根据 \(y\) 与 \(s\) 的大小关系返回判断结果。
  - **作者：LiJunze0501 (4星)**
    - **关键亮点**：整体思路简洁明了，直接点明二分加前缀和，对二分和前缀和的细节有简要说明，代码简洁。
    - **个人心得**：无
    ```cpp
    while(l<=r){
        ans=0,mid=(l+r)>>1;
        for(int i=1;i<=n;i++)   
            if(w[i]>mid) q[i]=q[i-1]+1,p[i]=p[i-1]+v[i];
            else q[i]=q[i-1],p[i]=p[i-1];
        for(int i=1;i<=m;i++) ans+=(q[ri[i]]-q[le[i]-1])*(p[ri[i]]-p[le[i]-1]);
        ss=s-ans;        
        if(ss<0) l=mid+1;     
        else r=mid-1;     
        minn=min(minn,abs(ss));    
    }
    ```
    **核心实现思想**：在二分循环中，每次计算当前 `mid` 对应的检验结果 `ans`，通过前缀和数组 `q` 和 `p` 分别记录满足条件的矿石数量和价值和，根据 `ans` 与 `s` 的差值调整二分区间，并更新最小差值 `minn`。
  - **作者：ycy1124 (4星)**
    - **关键亮点**：题意和思路分析清晰，先解释式子含义，再阐述二分及前缀和思路，代码逻辑清晰。
    - **个人心得**：无
    ```cpp
    while(l<=r){
        mid=(l+r>>1);
        for(int i=1;i<=n;i++){
            if(a[i].w>=mid){
                qzh[i]=qzh[i-1]+1;
                qzw[i]=qzw[i-1]+a[i].v;
            }
            else{
                qzw[i]=qzw[i-1];
                qzh[i]=qzh[i-1];
            }
        }
        int sum=0;
        for(int i=1;i<=m;i++){
            sum+=(qzw[b[i].r]-qzw[b[i].l-1])*(qzh[b[i].r]-qzh[b[i].l-1]);
        }
        ans=min(abs(sum-s),ans);
        if(sum<=s){
            r=mid-1;
        }
        else{
            l=mid+1;
        }
    }
    ```
    **核心实现思想**：二分查找合适的 \(W\)（`mid`），在每次循环中通过前缀和数组 `qzh` 和 `qzw` 分别统计满足条件的矿石数量和价值和，计算检验结果 `sum`，比较 `sum` 与 `s` 调整二分区间，并更新最小差值 `ans`。

最优的关键思路或技巧：利用二分查找的单调性，结合前缀和优化区间查询，快速找到使 \(|s - y|\) 最小的 \(W\) 值。

可拓展之处：此类题目通常具有单调性，可利用二分答案解决。类似算法套路还可应用于最大化最小值或最小化最大值等问题。

推荐题目：
  - [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：同样利用二分答案，结合单调性求解。
  - [P1873 砍树](https://www.luogu.com.cn/problem/P1873)：通过二分查找合适的砍树高度。
  - [P3853 [TJOI2007]路标设置](https://www.luogu.com.cn/problem/P3853)：运用二分答案确定路标的合适间距。

个人心得摘录与总结：无。 

---
处理用时：33.73秒
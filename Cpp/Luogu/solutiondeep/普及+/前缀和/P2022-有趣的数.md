# 题目信息

# 有趣的数

## 题目描述

让我们来考虑 $1$ 到 $N$ 的正整数集合。让我们把集合中的元素按照字典序排列，例如当 $N=11$ 时，其顺序应该为：$1,10,11,2,3,4,5,6,7,8,9$。

定义 $K$ 在 $N$ 个数中的位置为 $Q(N,K)$，例如 $Q(11,2)=4$。现在给出整数 $K$ 和 $M$，要求找到最小的 $N$，使得 $Q(N,K)=M$。

## 说明/提示

【数据约定】


$40\%$ 的数据，$1 \le K,M \le 10^5$；

$100\%$ 的数据，$1 \le K,M \le 10^9$。


## 样例 #1

### 输入

```
2 4
```

### 输出

```
11
```

## 样例 #2

### 输入

```
100000001 1000000000```

### 输出

```
100000000888888879```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找最小的 \( N \)，使得 \( Q(N, K) = M \) 展开。思路上，多数题解先计算 \( K \) 的最小位置，再与 \( M \) 比较，根据比较结果进行不同处理。算法要点在于通过按位枚举等方式统计字典序小于 \( K \) 的数的个数。难点主要是处理边界情况，如 \( K \) 为 \( 10^n \) 时的特判，以及准确计算不同位数下字典序小于 \( K \) 的数的数量。

### 所选的题解
- **作者：Akashicw (5星)**
    - **关键亮点**：思路清晰，先得出两条关键结论（\( 10^n \) 位置固定、\( q(n, k) \) 不下降），通过按位计算 \( K \) 的最小位置，再根据与 \( M \) 的比较结果，以对数级速度枚举增加元素，逻辑连贯，代码注释详细。
    - **个人心得**：感谢王乃广老师讲解及友邻牧鸡同学指正。
    - **重点代码 - 计算 \( K \) 的最小位置**：
```cpp
//计算k的最小位置 
int calc(int k){ 
    char s[12];
    sprintf(s,"%d",k);
    int ans=0,w=0;
    len=strlen(s);
    for(int i=0;i<len;i++)
    {
        w=w*10+s[i]-'0';
        ans+=w-mi[i]+1;
    }
    return ans; 
}
```
核心思想是将 \( K \) 按位拆分，通过与对应位的 \( 10^n \) 计算差值并累加，得到 \( K \) 的最小位置。
    - **重点代码 - 主函数核心部分**：
```cpp
mi[0]=1;
for(int i=1;i<19;i++) mi[i]=mi[i-1]*10;
scanf("%d%d",&k,&m);
//1,10,100的位置是固定的 
for(int i=0;i<10;i++){
    if(k==mi[i]&&m!=i+1){
        printf("0\n"); return 0;
    }
}
base=calc(k);
if(m<base){
    printf("0\n"); return 0;
}
if(m==base){
    printf("%d\n",k); return 0;
}
ans=mi[len];
m-=base;
for(int i=1;;i++)
{
    long long tmp=k*mi[i]-mi[len+i-1];
    if(m>tmp)
    {
        m-=tmp; 
        ans*=10;
    }
    else break;
}
ans+=m-1;
cout<<ans<<endl;
```
核心思想是先预处理 \( 10^n \)，特判 \( K \) 为 \( 10^n \) 的情况，然后计算 \( K \) 的最小位置 \( base \)，根据 \( base \) 与 \( M \) 的关系，通过循环以对数级速度调整答案。
- **作者：mrwalking (4星)**
    - **关键亮点**：以纯C语言编写，通过详细注释结合具体样例解释算法思路，便于理解。先通过 `getcount` 函数计算小于 \( K \) 且字典序小于 \( K \) 的数的个数，再根据与 \( M - 1 \) 的比较结果进行后续处理。
    - **个人心得**：通过三个样例详细阐述程序编写思路，强调对特殊情况（如 \( k == base && cnt < m - 1 \)）判断的重要性，否则部分测试点会TLE。
    - **重点代码 - `getcount` 函数**：
```cpp
void getcount(long long x){//获得小于x的，且字典序小于x的数的个数
    long long base1=1,x1=x,x2=x;
    while(x1){//数出x的位数，如456 计算得出base1=100
        x1/=10;
        base1*=10; 
    }
    base1/=10;//因为多 一次*10，故此处 一次/10 
    base=base1;//如456 base=100  
    while(x2){//最大数到456，比456字典序小的个数为(456-100+1)-1+(45-10+1)+(4-1+1)个,即 (456-100+1)+(45-10+1)+(4-1+1)-1个,即396个，getcount函数因此算法编出 
        cnt+=x2-base1+1;
        x2/=10;
        base1/=10;
    }
    cnt-=1;//cnt计算小于x，且字典序小于x的数的个数 
}
```
核心思想是先确定 \( x \) 的位数，进而确定每一位的起始数，通过循环累加计算小于 \( x \) 且字典序小于 \( x \) 的数的个数。
    - **重点代码 - 主函数核心部分**：
```cpp
getcount(k);
if(cnt>m-1||k==base&&cnt<m-1){//1 此处写成 if(cnt>m-1)漏了一种情况 10 10 无输出结果。 
    printf("0\n");//无解 
    return 0;
}
c=k,p=k-base;
while(cnt<m-1){//计算大于x，且字典序小于x的数的个数。 //同样例1思路，但第397个数在小于456里面找不到了，只能从1000~(4560-1)里面进行寻找，可寻找的数目(4560-1)-1000+1=3560个，while(cnt<m-1)里面的内容由此编出
    c*=10;
    p*=10;
    cnt+=p;
}
printf("%lld\n",max(k,(c-1)-(cnt-(m-1))));
```
核心思想是调用 `getcount` 函数后，根据计算结果与 \( m - 1 \) 的比较判断是否有解，若有解则通过循环计算大于 \( K \) 且字典序小于 \( K \) 的数的个数，最后输出 \( k \) 与计算出的特定值的最大值。
- **作者：Clu3ter (4星)**
    - **关键亮点**：通过画图将问题转化为十叉树模型，利用树的性质（深度与位数关系、每层排序特点）辅助理解。分步骤清晰阐述计算过程，包括计算最小位置、增量以及特判情况，代码实现简洁明了。
    - **重点代码 - 计算最小位置、增量及特判**：
```cpp
//Step1:找到最小值
lint k0=k,d;
for(d=1;d*10<=k;d*=10);//计算d_k 
digit=d;add=k0-d;//计算add 
while(k0){
    base+=k0-d+1;
    k0/=10;d/=10;
}//计算base 
//Step2:计算增量
m-=base;
if(m<0){//特判1 
    printf("0\n");
    return 0;
}
if(m==0){//特判2
    printf("%d\n",k);
    return 0;
}
if(k==digit && m){//特判3
    printf("0\n");
    return 0;
}
add*=10;digit*=10;
while(m-1>=add){
    m-=add;
    add*=10;digit*=10;
}//不断减去 
ans=digit+m-1;//最终加上余量,注意这里的-1,因为是从10..0开始计算的! 
printf("%lld\n ",ans);
```
核心思想是先计算 \( K \) 的最小位置 \( base \) 及相关差值，然后根据 \( m \) 与 \( base \) 的关系进行特判，若需继续计算则通过循环减去增量，最后得出答案。

### 最优关键思路或技巧
1. **按位枚举统计**：通过按位枚举，计算字典序小于 \( K \) 的数的个数，这是解决本题的核心思路。不同题解在具体实现上略有差异，但本质都是利用字典序的特点，通过与 \( 10^n \) 相关的计算来统计数量。
2. **利用单调性与边界特判**：利用 \( Q(N, K) \) 随 \( N \) 增大不下降的性质，先计算 \( K \) 的最小位置并与 \( M \) 比较。同时，对 \( K \) 为 \( 10^n \) 这种特殊边界情况进行特判，避免错误。

### 可拓展思路
此类题目属于字典序相关的计数与查找问题，类似算法套路可应用于其他涉及字典序排序、查找特定位置元素的题目。例如，给定一个字符串集合按字典序排列，查找某个字符串的位置，或给定位置求对应的字符串等。

### 相似知识点洛谷题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)：涉及数字的字典序相关操作，通过删除数字使剩下数字组成的数最小，与本题对数字顺序处理有相似之处。
2. [P2676 [NOIP2015 普及组] 数字反转](https://www.luogu.com.cn/problem/P2676)：虽然主要是数字反转，但在处理过程中也需考虑数字的位与字典序类似的逻辑，对理解数字按位处理有帮助。
3. [P1914 小书童——密码](https://www.luogu.com.cn/problem/P1914)：字符串按特定规则排序，与本题字典序排序思路类似，可锻炼对排序规则的应用能力。 

---
处理用时：76.57秒
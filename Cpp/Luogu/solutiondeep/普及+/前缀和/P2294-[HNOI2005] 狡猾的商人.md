# 题目信息

# [HNOI2005] 狡猾的商人

## 题目描述

刁姹接到一个任务，为税务部门调查一位商人的账本，看看账本是不是伪造的。账本上记录了 $n$ 个月以来的收入情况，其中第 $i$ 个月的收入额为 $a_i$，$i=1,2,\ldots,n-1,n$。当 $a_i>0$ 时表示这个月盈利 $a_i$ 元，当 $a_i<0$ 时表示这个月亏损 $|a_i|$ 元。所谓一段时间内的总收入，就是这段时间内每个月的收入额的总和。

刁姹的任务是秘密进行的，为了调查商人的账本，她只好跑到商人那里打工。她趁商人不在时去偷看账本，可是她无法将账本偷出来，每次偷看账本时她都只能看某段时间内账本上记录的收入情况，并且她只能记住这段时间内的总收入。

现在，姹总共偷看了 $m$ 次账本，当然也就记住了 $m$ 段时间内的总收入，你的任务是根据记住的这些信息来判断账本是不是假的。


## 样例 #1

### 输入

```
2
3 3
1 2 10
1 3 -5
3 3 -15
5 3
1 5 100
3 5 50
1 2 51
```

### 输出

```
true
false
```

# AI分析结果

### 综合分析与结论
该题主要判断给定的账本区间收入信息是否存在矛盾。各题解思路多样，涵盖贪心、并查集、差分约束、区间DP、高斯消元等算法。
1. **贪心**：按区间左右端点排序，利用优先队列两两比较区间，相同部分抵消，新区间入队，若区间值冲突则账本为假。
2. **并查集**：基于前缀和思想，将区间端点放入同一集合，维护端点与根节点差值，判断新加入区间是否与已有关系冲突。
3. **差分约束**：把区间和条件转化为不等式，构建图，通过检测图中是否存在正环（或负环、非零环）判断账本真假，注意图可能不连通需建超级源点。
4. **区间DP**：从小区间到大区间递推，根据已知小区间和确定大区间和，若出现冲突则账本为假。
5. **高斯消元**：将每个区间和信息构建为方程，利用高斯消元判断方程组是否有解。

各题解在思路清晰度、代码可读性、优化程度上各有差异。

### 所选4星及以上题解
 - **作者：66666a（4星）**
    - **关键亮点**：思路清晰，利用并查集维护区间端点关系及前缀和差值，代码简洁高效，直接基于并查集的常规操作实现，易理解。
    - **核心代码**：
```cpp
int find(int x)
{  
    if(x!=fa[x])
    {
        int t=find(fa[x]);
        cha[x]+=cha[fa[x]];
        fa[x]=t;  
    }  
    return fa[x];  
}  
int main()  
{  
    int T,n,m,i,x,y,z,flag;  
    scanf("%d",&T);  
    while (T--) 
    {  
        flag=0;  
        scanf("%d%d",&n,&m);  
        for(i=0;i<=n;i++)
        {  
            fa[i]=i;  
            cha[i]=0;  
        }  
        for(i=1;i<=m;i++)  
        {  
            scanf("%d%d%d",&x,&y,&z);  
            x--;  
            if(find(x)!=find(y))  
            {  
                cha[fa[y]]=cha[x]-cha[y]-z;  
                fa[fa[y]]=fa[x];
            }  
            else  
            if(cha[x]-cha[y]!=z) flag=1;  
        }  
        if(flag==0) printf("true\n"); else printf("false\n");  
    }  
    return 0;  
}
```
    - **核心思想**：`find`函数路径压缩同时更新节点与根节点前缀和差值。`main`函数中，读入区间信息，若端点不在同一集合则合并并更新差值，否则判断差值与当前区间和是否相等，不等则账本为假。
 - **作者：brealid（4星）**
    - **关键亮点**：标准差分约束解法，详细阐述从题目条件到不等式构建、图的建立，以及处理图不连通问题，思路严谨清晰。
    - **核心代码**：
```cpp
int once()
{
    // [read data]
    n = read<int>();
    m = read<int>();
    for (int i = 0; i <= n + 1; i++) G[i].clear();
    for (int i = 1, u, v, w; i <= m; i++) {
        u = read<int>();
        v = read<int>();
        w = read<int>();
        G[u - 1].push_back(make_edge(v, w)); // sum_{u-1} + w <= sum_{v}
        G[v].push_back(make_edge(u - 1, -w)); // sum_{v} - w <= sum_{u-1}
    }
    for (int i = 0; i <= n; i++)
        G[n + 1].push_back(make_edge(i, 0));
    // [/read data] 
    // [spfa]
    queue<int> q;
    q.push(n + 1);
    memset(dis, 0xcf, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    memset(inq, 0, sizeof(inq));
    dis[n + 1] = 0;
    while (!q.empty()) {
        int fr = q.front(); 
        q.pop();
        inq[fr] = 0;
        for (unsigned i = 0; i < G[fr].size(); i++) {
            if (dis[G[fr][i].to] < dis[fr] + G[fr][i].v) {
                dis[G[fr][i].to] = dis[fr] + G[fr][i].v;
                if (!inq[G[fr][i].to]) {
                    vis[G[fr][i].to]++;
                    if (vis[G[fr][i].to] > n) {
                        puts("false");
                        return 0;
                    }
                    inq[G[fr][i].to] = true;
                    q.push(G[fr][i].to);
                }
            }
        }
    }
    // [/spfa]
    puts("true");
    return 0;
}
```
    - **核心思想**：读入区间信息构建双向边，添加超级源点`n + 1`与所有点连边。`spfa`部分通过队列不断松弛节点，若发现某点入队次数大于`n`则存在环，账本为假。
 - **作者：pikabi（4星）**
    - **关键亮点**：完善区间DP解法，详细解释递推关系和判重操作，代码实现简洁明了，针对题目数据范围合理设计算法。
    - **核心代码**：
```cpp
int main(){
	scanf("%d",&w);
	while(w--){
		scanf("%d%d",&n,&m);
		p = 1;
		for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++) a[i][j] = inf;
		for(int i = 1; i <= m; i++){
			int x, y, z;
			scanf("%d%d%d",&x,&y,&z);
			if(a[x][y] == inf || a[x][y] == z)
			a[x][y] = z;
			else p = 0;
		}
		if(p)
		for(int k = 1; k <= n; k++){
			for(int i = 1; i + k <= n; i++){
				int j = k + i;
				for(int l = i; l < j; l++){
					if(a[i][l]!= inf && a[l + 1][j]!= inf){
						if(a[i][j] == inf) a[i][j] = a[i][l] + a[l + 1][j];
						else if(a[i][j]!= a[i][l] + a[l + 1][j]){
							p = 0;
							goto there;
						}
					}
				}
			}
		}
		there:;
		if(p) printf("true\n");
		else printf("false\n");
	}
	return 0;
} 
```
    - **核心思想**：初始化区间和数组`a`为无穷大，读入区间信息时判重。通过三重循环，利用`a[i][j]=a[i][l]+a[l + 1][j]`递推关系，若出现冲突则账本为假。

### 最优关键思路或技巧
1. **并查集优化**：利用并查集维护区间端点关系及前缀和差值，能高效判断新加入区间是否与已有关系冲突，代码简洁，时间复杂度低。
2. **差分约束建图**：将区间和条件准确转化为差分约束不等式并构建图，通过检测环判断矛盾，逻辑严谨，适用于此类区间关系判断问题。

### 可拓展之处
此类题目属于区间关系判断问题，相似算法套路如利用图论（如差分约束、最短路等）、并查集维护关系等。同类型题常涉及判断给定的区间约束条件是否存在矛盾或可行解。

### 相似知识点洛谷题目推荐
1. **P3275 [SCOI2011]糖果**：通过差分约束解决不等式组的可行性问题，与本题利用差分约束判断区间和矛盾类似。
2. **P1993 小 K 的农场**：同样是根据给定的条件构建差分约束系统，判断是否存在可行解。
3. **P1250 种树**：可利用并查集优化区间操作，与本题并查集维护区间关系思路有相通之处。

### 个人心得摘录与总结
 - **作者：brealid**：提交WA后发现图不一定联通，需建立超级源点，强调在使用差分约束时要注意图的连通性问题。总结在解决图论相关问题时，需全面考虑图的各种性质，避免遗漏特殊情况导致错误。 

---
处理用时：52.46秒
# 题目信息

# 马农

## 题目描述

在观看完战马检阅之后，来自大草原的两兄弟决心成为超级“马农”，专门饲养战马。

兄弟两回到草原，将可以养马的区域分为 $N \times N$ 的单位面积的正方形，并实地进行考察，归纳出了每个单位面积可以养马所获得的收益。接下来就要开始规划他们各自的马场了。首先，两人的马场都必须是矩形区域。同时，为了方便两人互相照应，也为了防止马匹互相走散，规定两个马场的矩形区域相邻，且只有一个交点。最后，互不认输的两人希望两个马场的收益相当，这样才不会影响他们兄弟的感情。现在，兄弟俩找到你这位设计师，希望你给他们设计马场，问共有多少种设计方案。


## 说明/提示

对于所有数据，$1 \leq n \leq 50$。

## 样例 #1

### 输入

```
3
1 2 3
4 5 6
7 8 9```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是通过枚举两个矩形的交点，结合二维前缀和快速计算矩形区域的收益，再利用哈希表或数组统计相同收益的矩形对数量，以此得出满足条件的设计方案数。主要区别在于具体实现细节和优化方式。

算法要点包括：
1. **二维前缀和**：用于O(1)时间复杂度计算矩形区域和。
2. **枚举交点**：遍历矩阵的每个点作为两个矩形的交点。
3. **统计收益**：利用哈希表或数组记录交点一侧矩形的收益值，在另一侧矩形枚举时，快速找到收益相同的矩形对。

解决难点在于如何优化时间复杂度，避免暴力枚举带来的高复杂度。部分题解通过拆嵌套循环、使用哈希表等方式，将时间复杂度从O(n^6)优化到O(n^4)。

### 所选的题解
1. **作者：Exber（5星）**
    - **关键亮点**：思路清晰，代码简洁明了，详细解释了二维前缀和与哈希表的使用，对哈希表的操作封装成函数，提高代码可读性。
    - **核心代码**：
```cpp
int size(int x,int y,int x2,int y2) // O(1) 求收益 
{
    return s[x][y]-s[x][y2-1]-s[x2-1][y]+s[x2-1][y2-1];
}
 
void clr() // 清空哈希表 
{
    for(int i=0;i<mod;i++)
    {
        mp[i].clear();
    }
}
 
void ins(int x) // 插入一个收益值 
{
    int wh=(x+250000)%mod;
    for(int i=0;i<mp[wh].size();i++)
    {
        if(mp[wh][i].size==x)
        {
            mp[wh][i].sum++;
            return;
        }
    }
    mp[wh].push_back((node){x,1});
}
 
int find(int x) // 寻找一个收益值，返回矩形个数 
{
    int wh=(x+250000)%mod;
    for(int i=0;i<mp[wh].size();i++)
    {
        if(mp[wh][i].size==x)
        {
            return mp[wh][i].sum;
        }
    }
    return 0; // 没找到返回 0 
}
```
    - **核心实现思想**：定义函数计算矩形收益，通过哈希表插入和查找操作，统计相同收益矩形对数量。
2. **作者：kyel（4星）**
    - **关键亮点**：详细阐述了从暴力解法到优化解法的思路过程，对哈希表的实现细节有较多说明，代码注释详细。
    - **个人心得**：提到暴力解法的复杂度分析及优化思路，如用二维前缀和优化矩阵求和，拆分嵌套循环并用哈希表统计矩形和。
    - **核心代码**：
```cpp
namespace my {//主要是实现hash表
    const int maxele(2523), maxhash(999667);
    class item {
        public:
            item() : next(0) {}
            
            int key, val;//val为出现次数
            item *next;
    }all[maxele];
    item *end(all);
    int hash(int v) {
        return (((long long)(v) * 19391) % maxhash + maxhash) % maxhash; //hash函数，随便写就好
    }
    class map {
        public:
            map() : nextvis(1) {}
            void clear() {
                ++nextvis;
                end = all;
            }
            int insert(int val) {
                int hashval(hash(val));
                if (bVal[hashval]!= nextvis) {
                    bVal[hashval] = nextvis;
                    end->key = val;
                    end->val = 1;
                    end->next = 0;
                    head[hashval] = end++;
                } else {
                    item *now(head[hashval]), *front;
                    while (now) {
                        if (now->key == val) {
                            ++now->val;
                            return now->val;
                        }
                        front = now;
                        now = now->next;
                    }
                    end->key = val;
                    end->val = 1;
                    end->next = 0;
                    front->next = end++;
                }
                return 1;
            }
            int count(int val) {
                int hashval(hash(val));
                if (bVal[hashval]!= nextvis) return 0;
                else {
                    item *now(head[hashval]);
                    while (now) {
                        if (now->key == val) return now->val;
                        now = now->next;
                    }
                }
                return 0;
            }
            item *head[maxhash];
            int bVal[maxhash], nextvis;
    }map;
}
```
    - **核心实现思想**：自定义哈希表类，实现插入和查找功能，用于统计矩形和出现的次数。
3. **作者：喵仔牛奶（4星）**
    - **关键亮点**：代码简洁高效，利用数组统计矩形和，注意到矩阵和可能为负，通过加一个大数避免数组越界问题。
    - **核心代码**：
```cpp
int getsum(int x1, int y1, int x2, int y2) {
	return sum[x1][y1] - sum[x1][y2 - 1] - sum[x2 - 1][y1] + sum[x2 - 1][y2 - 1];
}
//...
for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= n; j ++) {
			for (int k = 1; k <= i; k ++)
				for (int l = 1; l <= j; l ++)
					cnt[getsum(i, j, k, l) + VMAX] ++;
			for (int k = i + 1; k <= n; k ++)
				for (int l = j + 1; l <= n; l ++)
					ans += cnt[getsum(k, l, i + 1, j + 1) + VMAX];
			//...
```
    - **核心实现思想**：通过二维前缀和计算矩形和，用数组cnt统计不同和出现的次数，累加相同和的矩形对数量。

### 最优关键思路或技巧
1. **二维前缀和优化**：快速计算矩形区域和，降低时间复杂度。
2. **拆分嵌套循环**：避免高复杂度的嵌套枚举，将其转化为用哈希表或数组统计。
3. **哈希表应用**：高效存储和查询矩形收益值，加速方案数统计。

### 可拓展之处
同类型题可考察不同形状区域的和计算，或在满足特定条件下的区域组合问题。类似算法套路包括使用前缀和优化区域和计算，利用哈希表或其他数据结构统计符合条件的组合。

### 相似知识点洛谷题目
1. P1387 最大正方形：考察二维前缀和及动态规划。
2. P2004 领地选择：涉及二维前缀和与枚举优化。
3. P1719 最大加权矩形：同样需要二维前缀和计算矩形和。 

---
处理用时：43.66秒
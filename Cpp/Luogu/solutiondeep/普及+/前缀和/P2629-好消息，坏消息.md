# 题目信息

# 好消息，坏消息

## 题目描述

Uim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。

Uim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。

Uim 必须按照事件的发生顺序逐条将消息告知给老板。不过 Uim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以按 $k,k+1,k+2,\ldots,n,1,2,\ldots,k-1$（事件编号）这种顺序通报。

他希望知道，有多少个 $k$，可以使从 $k$ 号事件开始通报到 $n$ 号事件然后再从 $1$ 号事件通报到 $k-1$ 号事件可以让老板不发怒。

## 说明/提示

**【样例解释】**

通报事件的可行顺序（用编号表示）为 $2\rightarrow3\rightarrow4\rightarrow1$ 或 $3\rightarrow4\rightarrow1\rightarrow2$（分别对应 $k=2$ 和 $k=3$）

通报事件的可行顺序（用好坏度表示）为 $5\rightarrow1\rightarrow2\rightarrow(-3)$ 或 $1\rightarrow2\rightarrow(-3)\rightarrow5$

**【数据范围】**

对于 $25\%$ 的数据，$n\le10^3$；  
对于 $75\%$ 的数据，$n\le10^4$；  
对于 $100\%$ 的数据，$1 \le n\le 10^6$。

## 样例 #1

### 输入

```
4
-3 5 1 2
```

### 输出

```
2

```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何优化判断每个起始位置 \( k \) 是否合法的过程展开。核心思路多基于前缀和，通过维护区间最小值来快速判断老板心情是否始终非负。不同解法在数据结构和算法优化上各有差异，如单调队列、ST表、线段树等，部分题解还利用了一些特殊的数组处理技巧。

### 所选的题解
- **作者：憧憬未来 (5星)**
    - **关键亮点**：思路清晰，详细阐述了断环为链的思想，并结合前缀和与单调队列优化算法，时间复杂度为 \( O(n) \)，代码实现简洁明了。
    - **个人心得**：通过练习单调队列相关题目得到本题思路。
    - **核心代码片段**：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,head=1,tail,ans;
long long a[2000001],s[2000001],q[2000001];
int main()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i+=1)
        scanf("%lld",&a[i]);
    for(register int i=1;i<=n-1;i+=1)
        a[i+n]=a[i];
    for(register int i=1;i<=2*n-1;i+=1)
        s[i]=s[i-1]+a[i];
    for(register int i=1;i<=2*n-1;i+=1)
    {
        while(head<=tail&&max(i-n+1,1)>q[head])head++;
        while(head<=tail&&s[i]<=s[q[tail]])tail--;
        q[++tail]=i;
        if(i-n+1>0&&s[q[head]]-s[i-n]>=0)ans++;
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心实现思想**：先将原数组断环为链，存储在双倍长度数组 \( a \) 中，再计算前缀和数组 \( s \)。利用单调队列 \( q \) 维护长度为 \( n \) 的区间内前缀和的最小值，判断该最小值减去对应起点的前缀和是否非负，若是则说明从该起点开始通报消息老板不会发怒，统计这样的起点数量。
- **作者：swm_sxt (5星)**
    - **关键亮点**：采用 \( O(n) \) 时间复杂度的算法，通过维护前缀数组的最大最小值来判断每个 \( k \) 的合法性，代码简洁高效。
    - **核心代码片段**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n;
long long a[1000001],q[1000001],miq[1000001],miz[1000001],ans=0;
int main(){
    scanf("%lld",&n);
    miq[0]=1e17;miz[n+1]=1e17;
    for (long long i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        q[i]=q[i-1]+a[i];
        miq[i]=min(q[i],miq[i-1]);
    }
    for (long long i=n;i>=1;i--) miz[i]=min(q[i],miz[i+1]);
    for (long long i=1;i<=n;i++) if ((miz[i]-q[i-1]>=0)&&(miq[i-1]+q[n]-q[i-1]>=0)) ans++;
    printf("%lld\n",ans);
}
```
    - **核心实现思想**：首先读入数据并计算前缀和数组 \( q \)，同时维护前缀和的最小值数组 \( miq \)。然后从后往前遍历，维护后缀前缀和的最小值数组 \( miz \)。最后遍历所有可能的起始位置 \( i \)，通过判断 \( miz[i] - q[i - 1] \) 和 \( miq[i - 1] + q[n] - q[i - 1] \) 是否都非负，来确定从位置 \( i \) 开始通报消息是否合法，统计合法的起始位置数量。
- **作者：_ztyqwq (4星)**
    - **关键亮点**：不用单调队列，通过数学推导得出只需维护两个数组分别表示 \( \min_{1 \leqslant i \leqslant k}s_i \) 和 \( \min_{k \leqslant i \leqslant n}s_i \)，即可 \( O(1) \) 求出每个 \( k \) 的答案，整体时间复杂度 \( O(n) \)，思路巧妙。
    - **核心代码片段**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll s[1000001],m[1000002][2];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        ll a;
        scanf("%lld",&a);
        s[i]=s[i-1]+a;
    }
    m[0][0]=m[n+1][1]=LONG_LONG_MAX>>1;
    for(int i=1;i<=n;i++)
        m[i][0]=min(m[i-1][0],s[i]);
    for(int i=n;i>=1;i--)
        m[i][1]=min(m[i+1][1],s[i]);
    int ans=0;
    for(int i=1;i<=n;i++)
        if(m[i-1][0]+(s[n]-s[i-1])>=0&&m[i][1]-s[i-1]>=0)
            ans++;
    printf("%d\n",ans);
    return 0;
}
```
    - **核心实现思想**：先读入数据并计算前缀和数组 \( s \)。接着通过两次遍历分别维护数组 \( m \) 的两部分，其中 \( m[i][0] \) 表示 \( 1 \) 到 \( i \) 的前缀和最小值， \( m[i][1] \) 表示 \( i \) 到 \( n \) 的前缀和最小值。最后遍历所有可能的起始位置 \( i \)，根据 \( m[i - 1][0] + (s[n] - s[i - 1]) \) 和 \( m[i][1] - s[i - 1] \) 是否都非负来判断从位置 \( i \) 开始通报消息是否合法，统计合法的起始位置数量。

### 最优关键思路或技巧
1. **断环为链**：将环形的消息序列转化为线性序列，方便处理不同起始位置的情况。
2. **前缀和**：通过预处理前缀和，能快速计算任意区间的和，为后续判断提供便利。
3. **维护区间最值**：利用单调队列、数组维护等方式快速获取特定区间内前缀和的最小值，以 \( O(1) \) 或接近 \( O(1) \) 的时间复杂度判断某个起始位置是否合法，从而将整体时间复杂度优化到 \( O(n) \) 或 \( O(nlogn) \)。

### 可拓展思路
此类题目属于序列上的区间和与最值判断问题，常见的拓展方向有：
 - **增加限制条件**：如对消息的选择有其他限制，或老板心情有更复杂的变化规则。
 - **改变数据结构**：如将序列改为树形结构，在树上进行类似的操作。

### 相似知识点洛谷题目
1. **P1886 滑动窗口 /【模板】单调队列**：通过滑动窗口求区间最值，与本题利用单调队列维护区间最小值思路相似。
2. **P3865 [模板]ST表**：考察 ST 表的使用，与本题部分解法中利用 ST 表维护区间最值知识点相同。
3. **P3379 【模板】最近公共祖先（LCA）**：在树上处理节点间关系，与本题在序列上处理区间关系类似，可拓展树形结构相关的思维。 

---
处理用时：57.05秒
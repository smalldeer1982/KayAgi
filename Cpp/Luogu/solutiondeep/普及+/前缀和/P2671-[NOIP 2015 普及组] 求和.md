# 题目信息

# [NOIP 2015 普及组] 求和

## 题目背景

NOIP2015 普及组 T3

## 题目描述

一条狭长的纸带被均匀划分出了 $n$ 个格子，格子编号从 $1$ 到 $n$。每个格子上都染了一种颜色 $color_i$ 用 $[1,m]$ 当中的一个整数表示），并且写了一个数字 $number_i$。

| 编号 | 1 | 2 | 3 | 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| **颜色和数字** | $\color{blue}{5}$ | $\color{blue}{5}$ | $\color{red}{3}$ | $\color{red}{2}$ | $\color{blue}{2}$ | $\color{red}{2}$ |

定义一种特殊的三元组：$(x,y,z)$，其中 $x,y,z$ 都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：

1. $x,y,z$ 都是整数，$x<y<z,y-x=z-y$。

2. $color_x=color_z$。

满足上述条件的三元组的分数规定为 $(x+z) \times (number_x+number_z)$。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以 $10007$ 所得的余数即可。


## 说明/提示

**样例 1 解释**

纸带如题目描述中的图所示。

所有满足条件的三元组为：$(1, 3, 5), (4, 5, 6)$。

所以纸带的分数为 $(1 + 5) \times (5 + 2) + (4 + 6) \times (2 + 2) = 42 + 40 = 82$。


对于第 $1$ 组至第 $2$ 组数据， $1 ≤ n ≤ 100, 1 ≤ m ≤ 5$；

对于第 $3$ 组至第 $4$ 组数据，$1 ≤ n ≤ 3000, 1 ≤ m ≤ 100$；

对于第 $5$ 组至第 $ 6 $ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000$，且不存在出现次数超过 $ 20 $ 的颜色；

对于全部 $10$ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000, 1 ≤ color_i ≤ m,1≤number_i≤100000$。


## 样例 #1

### 输入

```
6 2
5 5 3 2 2 2
2 2 1 1 2 1```

### 输出

```
82
```

## 样例 #2

### 输入

```
15 4
5 10 8 2 2 2 9 9 7 7 5 6 4 2 4
2 2 3 3 4 3 3 2 4 4 4 4 1 1 1```

### 输出

```
1388```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均基于对题目条件的分析与转化。通过 $y - x = z - y$ 得出 $x + z = 2y$，进而推出 $x$ 与 $z$ 同奇偶，且因分数与 $y$ 无关，所以只需关注同奇偶且颜色相同的 $x$ 和 $z$ 组合。算法要点在于对数据按颜色和奇偶性分类，利用前缀和等技巧优化计算。难点在于推导计算分数的优化公式，避免暴力枚举导致的高时间复杂度。

### 所选的题解
- **作者：云浅知处 (5星)**
    - **关键亮点**：思路清晰，先分析出 $x,z$ 同奇偶的性质，通过具体例子展示数据分类过程，再以示例详细推导优化计算分数的方法，从暴力思路逐步引导至优化思路，易于理解。
    - **重点代码及核心实现思想**：虽未给出代码，但核心思想是对每种颜色按奇偶性分类后，通过维护 $f$ 数组（编号）、$n$ 数组（数字）及 $f[i] \cdot n[i]$ 的前缀和来优化计算分数。
- **作者：Victorique_De_Blois (4星)**
    - **关键亮点**：定义明确，通过对得分公式的推导和利用同余定理改写公式，结合前缀和优化，将时间复杂度优化到 $O(n)$，代码实现简洁明了。
    - **重点代码及核心实现思想**：
```cpp
#include <cstdio>

const int N = 100000;
const int M = 10007;
int n, m;
int sum[N + 1][2], nt[N + 1][2];
int color[N + 1], number[N + 1];
long long ans = 0;

int main()
{
    scanf(" %d %d", &n, &m);
    for(int i = 1; i <= n; i++) {
        scanf("%d", &number[i]);
        number[i] %= M;
    }
    for(int i = 1; i <= n; i++) {
        scanf("%d", &color[i]);
        int c = color[i];
        int g = i % 2;
        nt[c][g]++;
        sum[c][g] += number[i];
        sum[c][g] %= M;
    }
    for(int i = 1; i <= n; i++) {
        int c = color[i];
        int g = i % 2;
        ans += i % M * ((sum[c][g] + (nt[c][g] - 2) % M * number[i] + M) % M);
        ans %= M;
    }
    printf("%lld", ans);
    return 0;
}
```
    - 代码通过一边输入颜色一边累加，利用 `sum` 数组记录同颜色同奇偶的数字和，`nt` 数组记录个数，最后根据推导公式计算答案。
- **作者：一叶知秋。 (4星)**
    - **关键亮点**：从简单的数学推导入手，通过对分数计算公式的展开，发现可利用前缀和维护部分值，且在求前缀和过程中同步完成求解，减少内存使用，代码注释详细。
    - **重点代码及核心实现思想**：
```cpp
#include<cstdio>

#define ll long long
#define maxn 111111
#define mod 10007

inline ll read(){
    ll r=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')r=(r<<1)+(r<<3)+(c^48),c=getchar();
    return r*f;
}

int n,m,num[maxn],col[maxn];

ll ans,s_c[maxn][2][4];//第一维是颜色，第二维是奇偶
//第三维第一个是前面满足条件的个数，第二个是∑z*number_z
//第三个是∑z，第四个是∑number_z
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++)num[i]=read()%mod;
    for(int i=1;i<=n;i++)col[i]=read()%mod;
    for(int i=1;i<=n;i++){//记得每一步都取模哦
        (ans+=(s_c[col[i]][i%2][0]*(i%mod)*(num[i]%mod))%mod)%=mod;
        (ans+=s_c[col[i]][i%2][1])%=mod;
        (ans+=((i%mod)*s_c[col[i]][i%2][2])%mod)%=mod;
        (ans+=((num[i]%mod)*s_c[col[i]][i%2][3])%mod)%=mod;
        (s_c[col[i]][i%2][0]+=1)%=mod;
        (s_c[col[i]][i%2][1]+=(i%mod)*(num[i]%mod))%=mod;
        (s_c[col[i]][i%2][2]+=num[i]%mod)%=mod;
        (s_c[col[i]][i%2][3]+=i%mod)%=mod;
    }
    printf("%lld",ans);
    return 0;
}
```
    - 利用三维数组 `s_c` 分别记录颜色、奇偶性以及满足条件的个数、$z \times number_z$ 的和、$z$ 的和、$number_z$ 的和，在遍历过程中更新这些值并计算答案。

### 最优关键思路或技巧
1. **数据分类**：按颜色和奇偶性对数据进行分类，缩小计算范围，减少无效计算。
2. **公式推导与优化**：对计算分数的公式进行展开和推导，利用前缀和等技巧，将原本 $O(n^2)$ 的暴力计算优化到 $O(n)$。
3. **同余定理应用**：在计算过程中及时应用同余定理取模，防止结果溢出，同时保证计算结果的正确性。

### 可拓展思路
此类题目属于基于条件筛选和统计计算的问题。类似套路为首先深入分析题目给定条件，挖掘隐藏性质（如本题中 $x,z$ 同奇偶），对数据进行合理分类；然后针对计算目标推导优化公式，结合数据结构（如前缀和数组）优化算法。同类型题通常围绕特定规则的元素组合及统计，如满足特定距离、属性相同等条件的元素组合的相关计算。

### 相似知识点题目推荐
1. **P1972 [SDOI2009]HH的项链**：涉及对序列中不同颜色珠子数量的统计，需利用数据结构优化计算，与本题按颜色分类统计有相似之处。
2. **P3370 【模板】字符串哈希**：通过对字符串的处理和哈希值计算，利用前缀和思想优化，与本题利用前缀和优化计算有类似思路。
3. **P2216 [HAOI2007]理想的正方形**：在二维矩阵中寻找满足特定条件的子矩阵，同样需要分析条件并优化计算过程，与本题思路类似。 

---
处理用时：46.21秒
# 题目信息

# [USACO17JAN] Balanced Photo G

## 题目描述

FJ 正在安排他的 $N$ 头奶牛站成一排来拍照（$1\le N \le 10^5$）。序列中的第 $i$ 头奶牛的高度是 $h_i$，且序列中所有的奶牛的身高都不同。

就像他的所有牛的照片一样，FJ希望这张照片看上去尽可能好。他认为，如果 $L_i$ 和 $R_i$ 的数目相差 $1$ 倍以上，第 $i$ 头奶牛就是不平衡的（$L_i$ 和 $R_i$ 分别代表第 $i$ 头奶牛左右两边比她高的奶牛的数量）。也就是说，如果 $L_i$ 和 $R_i$ 中的较大数大于较小数的 $2$ 倍，第 $i$ 头奶牛就是不平衡的。FJ 不希望他有太多的奶牛不平衡。

请帮助 FJ 计算不平衡的奶牛数量。

## 样例 #1

### 输入

```
7
34
6
23
0
5
99
2```

### 输出

```
3```

# AI分析结果

• **综合分析与结论**：
    - **思路**：多数题解先对奶牛身高从大到小排序，利用排序后特性，处理当前奶牛时，只需关注已处理过的更高奶牛。通过统计当前奶牛左右两边比它高的奶牛数量，依据条件判断是否平衡，累加不平衡奶牛数量。
    - **算法要点**：常使用树状数组优化，将问题转化为单点修改和区间查询，高效统计左右两边比当前奶牛高的数量。部分题解用平衡树、主席树、划分树等数据结构，或离散化等技巧辅助。
    - **解决难点**：核心是优化暴力 $O(n^2)$ 解法，通过排序和数据结构利用奶牛身高间关联，减少重复计算。

**评分**：
    - **nihanchu**：思路清晰，详细阐述优化过程及树状数组应用，代码注释丰富，5星。
    - **小蒟蒻皮皮鱼**：简洁说明思路和树状数组原理，代码简洁，4星。
    - **Shikita**：分享从暴力到优化再到树状数组思路，有调试过程展示，4星。

**所选题解**：
  - **nihanchu（5星）**
    - **关键亮点**：详细解释从暴力到优化思路，结合树状数组单点修改和区间查询特性解决问题，代码注释详尽。
    - **核心代码片段**：
```cpp
//单点更新
void update(int x,int v)
{
    while (x<=n)
    {
        f[x]+=v;
        x+=lowbit(x);
    }
}
//查询前缀和
int query(int x)
{
    int sum=0;
    while (x>0) 
    {
      sum+=f[x];
      x-=lowbit(x);
    }
    return sum;
}
int main()
{
  scanf("%d",&n);
  for (int i=1;i<=n;i++) 
  {
       a[i].v=read();//输入奶牛的身高
    a[i].t=i;//奶牛在原序列中的编号    
  }
  sort(a+1,a+1+n,cmp);//身高从大到小排序
  for (int i=1;i<=n;i++) b[a[i].t]=i;//记录这头奶牛在排序后的编号
  for (int i=1;i<=n;i++)
  {
      l=query(b[i]);//查询左边比它大的奶牛数量，即f[k1]已为1，且k1<k;
      r=b[i]-l-1;//右边比它的数量
      if ((l*2<r)||(r*2<l)) ans++;//记录不平衡数量
      update(b[i],1);//更新，这头奶牛已经被枚举过了
  }
  printf("%d\n",ans);
  return 0;
}
```
    - **核心实现思想**：先对奶牛按身高从大到小排序，用树状数组维护已处理奶牛，每次查询当前奶牛左边比它高的奶牛数量（前缀和），右边数量通过计算得到，依条件判断是否不平衡并更新树状数组。

  - **小蒟蒻皮皮鱼（4星）**
    - **关键亮点**：清晰点明思路，以例子说明树状数组维护前缀和解决问题，代码简洁明了。
    - **核心代码片段**：
```cpp
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) scanf("%d", &Cow[i].iH), Cow[i].iBh = i;
	sort(Cow + 1, Cow + 1 + n, cmp);
	int iAns = 0;
	for(int i = 1; i <= n; i++)
	{
		Add(Cow[i].iBh, 1);
		int l = Query(Cow[i].iBh - 1);
		int r = i - l - 1;
		if(max(l, r) > 2 * min(l, r)) iAns++;
	}
	cout<<iAns;
}
```
    - **核心实现思想**：对奶牛按身高从大到小排序，遍历奶牛时，用树状数组更新当前奶牛位置，查询左边比它高的奶牛数量（前缀和），计算右边数量，依条件判断是否不平衡。

  - **Shikita（4星）**
    - **关键亮点**：展示从暴力到优化再到树状数组思路过程，对树状数组使用解释清晰。
    - **个人心得**：从暴力开始尝试，逐步优化，发现暴力超时后想到前缀和进而使用树状数组，分享调试过程。
    - **核心代码片段**：
```cpp
int ask(int x)
{
	int cnt=0;
	for(;x;x-=x&-x) cnt+=c[x];
	return cnt;
}
void add(int x,int y)
{
	for(;x<=n;x+=x&-x) c[x]+=y;
}
int main()
{
	n=read();
	for(int i=1;i<=n;++i) 
	a[i].x=read(),a[i].y=i;
	sort(a+1,a+1+n,cmp);
	
	add(a[1].y,1);
	for(int i=2;i<=n;++i)
	{
		int l=ask(a[i].y);
		int r=i-l-1;
		if(min(l,r)*2<max(l,r)) ans++;
		add(a[i].y,1);
	}
	cout<<ans<<endl;
	return 0;
}
```
    - **核心实现思想**：对奶牛按身高从大到小排序，利用树状数组的add函数更新，ask函数查询左边比当前奶牛高的奶牛数量（前缀和），计算右边数量，依条件判断是否不平衡。

**最优关键思路或技巧**：先对奶牛身高从大到小排序，利用树状数组单点修改和区间查询特性高效统计左右两边比当前奶牛高的数量，优化暴力算法。

**可拓展之处**：同类型题常涉及利用数据结构优化区间统计问题，类似算法套路如处理逆序对、动态区间和等，可举一反三。

**推荐题目**：
    - [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
    - [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
    - [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368) 

---
处理用时：39.11秒
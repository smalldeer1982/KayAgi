# 题目信息

# 松江 1843 路

## 题目描述

涞坊路是一条长 $L$ 米的道路，道路上的坐标范围从 $0$ 到 $L$，路上有 $N$ 座房子，第 $i$ 座房子建在坐标为 $x_i$ 的地方，其中住了 $r_i$ 人。

松江 1843 路公交车要在这条路上建一个公交站，市政府希望让最多的人得到方便，因此希望所有的每一个的居民，从家到车站的距离的**总和**最短。

公交站应该建在哪里呢？

## 说明/提示

### 样例解释 1

当建在坐标 $40$ 的时候，所有人距离车站的距离总和为 $|20-40| \times 3+|50-40| \times 2+|70-40| \times 1=110$。

### 数据范围和约定

对于 $10\% $的数据，$1\le N \le 50$，$R_i=1$。

对于 $30\%$ 的数据，$1 \le N \le 100$，$R_i \le 10$，$1 \le L \le 1000$。

对于 $70\%$ 的数据，$1 \le N \le 1000$，$R_i \le 100$，$1 \le L \le 10^6$。

对于全部数据，$1 \le L \le 10^{10}$，$1 \le N \le 10^5$，$0 \le x_i \le L$，$1 \le r_i \le 1000$。

## 样例 #1

### 输入

```
100 3
20 3
50 2
70 1
```

### 输出

```
110
```

## 样例 #2

### 输入

```
100 2
0 1
100 10
```

### 输出

```
100
```

## 样例 #3

### 输入

```
10000000000 5
3282894320 391
4394338332 929
6932893249 181
7823822843 440
9322388365 623
```

### 输出

```
5473201404068
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕在给定道路上有若干房子及居住人数的情况下，寻找使居民到公交站距离总和最短的公交站位置这一问题。思路和算法可分为以下几类：
1. **中位数法**：通过证明公交站建在居民点且为带权中位数位置时能使距离总和最小，对居民点按坐标排序后，找到中位数位置计算距离总和。如作者BlueArc、MSM2004等题解。
2. **模拟法**：通过模拟移动公交站位置，根据移动前后距离总和的变化决定是否继续移动，直到找到最优位置。如作者_ztyqwq的题解。
3. **前缀和优化暴力法**：利用前缀和优化计算每个居民点作为公交站时的距离总和，从而找到最小值。如作者Celebrate、BFSDFS123的题解。
4. **其他方法**：如模拟退火（Forgive_Me）、换根DP + 贪心（Z_M__）、三分（lin_rany、s_a_b_e_r）、二分（Zarinopl）等。

中位数法和模拟法相对直接且高效，是较为常用的思路。前缀和优化暴力法相对容易理解但效率可能稍低。模拟退火、三分、二分等方法理论上可行，但实现可能较复杂或在本题中并非最优。

### 所选的题解
1. **作者：BlueArc（4星）**
    - **关键亮点**：清晰地将问题转换为寻找数轴上到各点距离之和最小的点，并通过直观的画图分析证明最优点为中位数，代码实现简洁明了。
    - **核心代码**：
```cpp
#include"cstdio"
#include"iostream"
#include"algorithm"
using namespace std;
typedef long long ll;
struct People
{
    ll x,r;
    bool operator <(const People& a) const{
        return x<a.x;
    }
}a[100005];
int main()
{
    ll len,n,tot=0;
    cin>>len>>n;
    for(int i=1;i<=n;i++)
    {cin>>a[i].x>>a[i].r;tot+=a[i].r;}
    tot=(tot+1)/2;
    sort(a+1,a+n+1);
    ll sum=0,mid,ans=0;
    for(int i=1;i<=n;i++)
    {
        sum+=a[i].r;
        if(sum>=tot) {mid=i;break;}
    }
    for(int i=1;i<=n;i++)
    {
        ans=ans+abs(a[i].x-a[mid].x)*a[i].r;
    } 
    cout<<ans;
    return 0;
}
```
    - **核心思想**：先读入数据并计算总人数，找到中位数所在位置，然后遍历所有居民点计算到中位数位置的距离总和。
2. **作者：MSM2004（4星）**
    - **关键亮点**：快速将问题与初中奥数求多个绝对值和最小值问题联系起来，明确指出取最小值时x为数列中位数，代码逻辑清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1e5+100;
struct f
{
    long long x;
    int r;
}s[M];
bool comp(const f &a,const f &b)
{
    return a.x<b.x;
}
int main()
{
    long long m;
    long long ans=0,sum=0;
    int n;
    cin>>m>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>s[i].x>>s[i].r;
        ans+=s[i].r;
    }
    sort(s+1,s+n+1,comp);
    long long mid=ans/2;
    int j=1;
    while(mid>0)
    {
        mid-=s[j].r;
        j++;
    }
    j--;
    long long k=s[j].x;
    for(int i=1;i<=n;i++)
    sum+=abs(s[i].x-k)*s[i].r;
    cout<<sum;
    return 0;
}
```
    - **核心思想**：读入数据计算总人数得到中位数，找到中位数对应下标，最后计算所有居民点到该中位数位置的距离总和。
3. **作者：_ztyqwq（4星）**
    - **关键亮点**：从独特的换根DP + 贪心角度出发，将道路看作树（链），通过状态设置和预处理，利用转移方程高效求解。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline void read (int& num)
{
    int x = 0, f = 1;
    char ch = getchar ();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-') f = -1;
        ch = getchar ();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar ();
    }
    num = x * f;
}
const int MAXN = 1e5 + 10;
int l, n, ans;
int x[MAXN], r[MAXN], f[MAXN], sum[MAXN];
signed main ()
{
    read (l), read (n);
    for (int i = 1; i <= n; i++)
        read (x[i]), read (r[i]);
    for (int i = n; i >= 1; i--)
        sum[i] = sum[i + 1] + r[i];
    for (int i = 2; i <= n; i++)
        f[1] += (x[i] - x[1]) * r[i];
    ans = f[1];
    for (int i = 2; i <= n; i++)
    {
        f[i] = f[i - 1] - (x[i] - x[i - 1]) * sum[i] + (sum[1] - sum[i]) * (x[i] - x[i - 1]);
        ans = min (f[i], ans);
    }
    cout << ans << endl;
    return 0;
}
```
    - **核心思想**：先读入数据并预处理后缀和，计算出以第一个房子为公交站时的距离和，再通过转移方程计算其他房子为公交站时的距离和并取最小值。

### 最优关键思路或技巧
1. **数学性质利用**：通过证明得出公交站建在居民点且为带权中位数位置时能使距离总和最小，直接利用这一数学性质解题，避免复杂的枚举和计算。
2. **状态转移**：如换根DP + 贪心的思路，通过巧妙的状态设置和转移方程，高效地从一个状态推导出另一个状态，减少重复计算。

### 可拓展之处
此类问题属于选址优化问题，类似的算法套路可应用于在一维或二维空间中，给定若干点及权重，寻找使某种距离度量（如曼哈顿距离、欧几里得距离等）总和最小的点的问题。例如在物流配送中心选址、基站布局等实际场景中。

### 相似知识点洛谷题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：通过贪心算法解决合并问题，与本题寻找最优位置思路类似，考察对最优策略的分析和实现。
2. [P1199 三国游戏](https://www.luogu.com.cn/problem/P1199)：需要通过分析游戏规则找到最优策略，锻炼对问题的抽象和逻辑推导能力，与本题寻找公交站最优位置的分析过程相似。
3. [P2048 游戏](https://www.luogu.com.cn/problem/P2048)：通过模拟和策略优化来达到游戏的最优结果，与本题通过模拟移动公交站位置寻找最优解有相似之处。

### 个人心得摘录与总结
1. **作者Celebrate**：通过暴力程序和数据生成程序找规律，并用对拍验证猜想。总结出遇到无头绪问题时，可通过暴力找规律并验证的方法来解题。
2. **作者说好不哭**：在处理权值和为偶数时的中位数问题，因精度问题WA了一个点，后通过推导得出将中位数点放在某端点可解决精度问题。强调处理边界情况和精度问题的重要性。 

---
处理用时：51.77秒
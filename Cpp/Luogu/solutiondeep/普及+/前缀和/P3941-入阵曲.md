# 题目信息

# 入阵曲

## 题目背景

pdf题面和大样例链接：http://pan.baidu.com/s/1cawM7c 密码：xgxv

```cpp
丹青千秋酿，一醉解愁肠。 
无悔少年枉，只愿壮志狂。 
```

## 题目描述

 
小 F 很喜欢数学，但是到了高中以后数学总是考不好。

有一天，他在数学课上发起了呆；他想起了过去的一年。一年前，当他初识算法竞赛的 时候，觉得整个世界都焕然一新。这世界上怎么会有这么多奇妙的东西？曾经自己觉得难以 解决的问题，被一个又一个算法轻松解决。

小 F 当时暗自觉得，与自己的幼稚相比起来，还有好多要学习的呢。

一年过去了，想想都还有点恍惚。

他至今还能记得，某天晚上听着入阵曲，激动地睡不着觉，写题写到鸡鸣时分都兴奋不 已。也许，这就是热血吧。


 
  ![](https://cdn.luogu.com.cn/upload/pic/9810.png) 

也就是在那个时候，小 F 学会了矩阵乘法。让两个矩阵乘几次就能算出斐波那契数列的 第 $10^{100}$ 项，真是奇妙无比呢。

不过，小 F 现在可不想手算矩阵乘法——他觉得好麻烦。取而代之的，是一个简单的小 问题。他写写画画，画出了一个 $n \times m$ 的矩阵，每个格子里都有一个不超过 $k$ 的正整数。

小 F 想问问你，这个矩阵里有多少个不同的子矩形中的数字之和是 $k$ 的倍数？ 如果把一个子矩形用它的左上角和右下角描述为 $(x_1,y_1,x_2,y_2)$，其中$x_1 \le x_2,y_1 \le y_2$； 那么，我们认为两个子矩形是不同的，当且仅当他们以 $(x_1,y_1,x_2,y_2)$ 表示时不同；也就是 说，只要两个矩形以 $(x_1,y_1,x_2,y_2)$ 表示时相同，就认为这两个矩形是同一个矩形，你应该 在你的答案里只算一次。


## 说明/提示

【样例 1 说明】

这些矩形是符合要求的： (1, 1, 1, 3)，(1, 1, 2, 2)，(1, 2, 1, 2)，(1, 2, 2, 3)，(2, 1, 2, 1)，(2, 3, 2, 3)。


子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。

每个测试点的数据规模及特点如下表：

 
  ![](https://cdn.luogu.com.cn/upload/pic/9811.png) 

特殊性质：保证所有 $a_{i,j}$ 均相同。


## 样例 #1

### 输入

```
2 3 2 
1 2 1 
2 1 2```

### 输出

```
6 
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效求解矩阵中元素和为 \(k\) 倍数的子矩形数量展开。多数题解先提到暴力解法，即通过二维前缀和 \(O(n^2m^2)\) 枚举子矩形判断其和是否为 \(k\) 倍数，但该方法只能得部分分数。

优化思路核心在于将二维问题转化为一维问题：通过枚举子矩阵上下边界，将中间行合并为一行，利用一维前缀和性质，即若两个前缀和模 \(k\) 相等，则它们之间的区间和为 \(k\) 倍数，用数组记录模 \(k\) 后的余数出现次数来统计符合条件子矩形数量，时间复杂度优化到 \(O(n^2m)\)。

### 所选的题解
1. **作者：why1123 (赞：12)  星级：4星**
    - **关键亮点**：思路清晰，先详细阐述一维数组求子区间和为 \(k\) 倍数问题的解法及原理，再自然过渡到二维矩阵问题，通过将二维问题转化为多个一维问题求解，并指出代码实现中的常见错误。
    - **个人心得**：“在代码中mark的部分即是核心，在这里犯了不少错。错误1：首先我们是枚举上下界，所以第二层循环的j应当是<=n，而不是m。错误2：我们知道前缀和的话sum[i]-sum[i - 1]代表的是原数组i位置的元素，即代表一个元素，如果sum[i]-sum[i]则是代表0个元素。这话看似是废话，但是写的时候，i应当从0开始并且最大不应该等于n。错误3：不要忘了每次加上vis[0]。错误4：在原本的子问题中，核心代码两行：一行是求前缀和，另一行求区间数。所以说在这里求前缀和应该是 \(ssum[mm]=(ssum[mm - 1]+sum[j][mm]-sum[i][mm]+k)\%k\) 呀！为啥不对啊。错误4让我wa了N次。。。一说求一维前缀和肯定马上想到 \(ssum[i]=ssum[i - 1]+qwq[i]\) 这种写法，直接敲上。然而需要注意的是，我们的sum也是前缀和。。。所以求出来的直接就是这一段一维前缀和，所以千万不能加上 \(ssum[mm - 1]\)，否则就成了前缀和的前缀和了。”总结了在枚举上下界、处理前缀和起始位置、遗漏特殊情况及重复计算前缀和等方面的易错点。
    - **核心代码**：
```cpp
// 一维子问题核心代码
sum[i]=(sum[i - 1]+qwq[i])%k;
ans+=vis[sum[i]]++;

// 二维问题核心代码
for(int i = 1; i <= n; i++){//求二维前缀和
    for(int j = 1; j <= m; j++){
        sum[i][j]=sum[i - 1][j]+sum[i][j - 1]-sum[i - 1][j - 1]+qwq[i][j];
    }
}
for(int i = 0; i < n; i++){
    for(int j = i + 1; j <= n; j++){
        for(int mm = 1; mm <= m; mm++){
            ssum[mm]=(sum[j][mm]-sum[i][mm]+k)%k;
            ans+=vis[ssum[mm]]++;
        }
        ans+=vis[0];
        for(int mm = 1; mm <= m; mm++){
            vis[ssum[mm]] = 0;
        }
        vis[0]=0;
    }
}
```
核心思想：先计算二维前缀和，之后枚举子矩阵上下边界，将对应列的和转化为一维数组，利用一维子问题核心代码统计符合条件子矩形数量。

2. **作者：Saliеri (赞：4)  星级：4星**
    - **关键亮点**：先给出暴力解法代码，强调由简到繁思考方式，从一维情况入手讲解原理，再扩展到二维，清晰阐述如何套用一维做法解决二维问题，代码简洁明了。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; ++i)for (int j = 1; j <= m; ++j)sum[i][j]=sum[i - 1][j]+sum[i][j - 1]-sum[i - 1][j - 1]+a[i][j];
for(int i = 0; i < n; ++i)
    for(int j = i + 1; j <= n; ++j) {
        cnt[0]=1;
        for(int lie = 1; lie <= m; ++lie) {
            mod[lie] = (sum[j][lie] - sum[i][lie] + k) % k;
            ans += cnt[mod[lie]];
            ++cnt[mod[lie]];
        }
        memset(cnt,0,sizeof(cnt));
    }
```
核心思想：先计算二维前缀和，枚举子矩阵上下边界，将每列的和转化为一维数组，通过记录模 \(k\) 后的余数出现次数统计符合条件子矩形数量。

3. **作者：灵乌路空 (赞：3)  星级：4星**
    - **关键亮点**：从一维情况出发，详细解释子区间和与前缀和关系及对应统计方法，再通过枚举子矩阵一条边的左右端点，将问题转化为一维形式，并用哈希表实现，可处理更大模数，提供了不同视角和实现方式。
    - **核心代码**：
```cpp
namespace Hash {
    int e_num, head[kBase + 10], val[kMaxn];
    int cnt[kMaxn], ne[kMaxn];
    void Init() {
        e_num = 0;
        memset(head, 0, sizeof (head));
    }
    int Query(int val_) {
        int pos = val_ % kBase + 1;
        for (int i = head[pos]; i; i = ne[i]) {
            if (val[i] == val_) return cnt[i];
        }
        return 0;
    }
    void Insert(int val_) {
        int pos = val_ % kBase + 1;
        for (int i = head[pos]; i; i = ne[i]) {
            if (val[i] == val_) {
                cnt[i] ++; 
                return ;
            }
        }
        val[++ e_num] = val_;
        cnt[e_num] = 1;
        ne[e_num] = head[pos];
        head[pos] = e_num;
    }
}
//...
for (int l = 1; l <= m; ++ l) {
    for (int r = l; r <= m; ++ r) {
        Hash::Init();
        Hash::Insert(0);
        for (int i = 1; i <= n; ++ i) {
            tmp[i] = (tmp[i - 1] + sum[i][r] - sum[i][l - 1] + k) % k;
            ans += Hash::Query(tmp[i]);
            Hash::Insert(tmp[i]);
        }
    }
}
```
核心思想：通过哈希表记录子矩阵和模 \(k\) 后的余数出现次数，枚举子矩阵上边左右端点，将对应列和转化为一维数组，利用哈希表统计符合条件子矩形数量。

### 最优关键思路或技巧
将二维矩阵问题转化为一维数组问题，通过枚举子矩阵上下边界，把中间行合并为一行，利用一维前缀和模 \(k\) 的性质，用数组或哈希表记录余数出现次数，从而高效统计符合条件子矩形数量。同时，在计算前缀和及处理边界条件时需格外小心。

### 可拓展之处
同类型题或类似算法套路：可拓展到其他需要统计满足特定条件子矩阵数量的问题，或在矩阵上进行特定和运算并判断结果的题目。类似套路为将二维问题降维，利用一维数组性质解决，还可结合前缀和、哈希表等工具优化。

### 推荐题目
1. **P1387 最大正方形**：给定一个 \(01\) 矩阵，求由 \(1\) 组成的最大正方形面积，考察对矩阵性质的运用及动态规划思想，与本题处理矩阵问题思路相关。
2. **P1719 最大加权矩形**：在给定矩阵中找出一个子矩形，使子矩形中所有元素和最大，同样涉及对矩阵子矩形的处理和优化求解。
3. **P2701 硬币游戏**：通过二维前缀和优化暴力枚举，解决在矩阵上进行特定操作和判断的问题，与本题优化思路类似。 

---
处理用时：61.25秒
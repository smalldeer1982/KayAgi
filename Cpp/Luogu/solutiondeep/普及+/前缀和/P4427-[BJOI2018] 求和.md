# 题目信息

# [BJOI2018] 求和

## 题目描述

master 对树上的求和非常感兴趣。他生成了一棵有根树，并且希望多次询问这棵树上一段路径上所有节点深度的 $k$ 次方和，而且每次的 $k$ 可能是不同的。此处节点深度的定义是这个节点到根的路径上的边数。他把这个问题交给了 pupil，但 pupil 并不会这么复杂的操作，你能帮他解决吗？

## 说明/提示

### 样例解释

以下用 $d (i)$ 表示第 $i$ 个节点的深度。

对于样例中的树，有 $d (1) = 0, d (2) = 1, d (3) = 1, d (4) = 2, d (5) = 2$。

因此第一个询问答案为 $(2^5 + 1^5 + 0^5) \bmod 998244353 = 33$，第二个询问答案为$(2^{45} + 1^{45} + 2^{45}) \bmod 998244353 = 503245989$。

### 数据范围

对于 $30\%$ 的数据，$1 \leq n,m \leq 100$。

对于 $60\%$ 的数据，$1 \leq n,m \leq 1000$。

对于 $100\%$ 的数据，$1 \leq n,m \leq 300000$，$1 \leq k \leq 50$。

另外存在 5 个不计分的 hack 数据。

### 提示

数据规模较大，请注意使用较快速的输入输出方式。

## 样例 #1

### 输入

```
5
1 2
1 3
2 4
2 5
2
1 4 5
5 4 45```

### 输出

```
33
503245989```

# AI分析结果

### 综合分析与结论
这些题解主要围绕求解树上路径节点深度的 $k$ 次方和问题，大多利用树上差分（前缀和）与最近公共祖先（LCA）算法。思路上，先预处理出每个节点到根节点路径上深度的 $k$ 次方和，再通过LCA找到路径公共祖先，利用前缀和相减得出答案。算法要点在于LCA的实现（如倍增、Tarjan等）以及 $k$ 次方和的预处理。难点主要是处理LCA处节点的重复计算以及取模运算防止结果为负。

### 所选的题解
1. **作者：shadowice1984（5星）**
    - **关键亮点**：思路清晰，先点明树上差分（前缀和）思路，再详细阐述如何通过预处理每个点深度的 $k$ 次方表及前缀和数组 $val$ 来求解，对LCA算法选择及原因有说明，代码简洁明了。
    - **个人心得**：无
    - **核心代码**：
```C
// 预处理val的信息以及倍增的信息 
void dfs(int u) {
    book[u] = true;
    for(int i = 0; fa[u][i]; i++) {
        fa[u][i + 1] = fa[fa[u][i]][i];
    }
    for(int i = al[u]; i; i = x[i]) {
        if(book[v[i]]) {
            continue;
        }
        fa[v[i]][0] = u;
        dep[v[i]] = dep[u] + 1;
        for(int j = 1; j <= 50; j++) {
            mi[j] = mi[j - 1] * dep[v[i]] % mod;
        }
        for(int j = 1; j <= 50; j++) {
            val[v[i]][j] = (mi[j] + val[u][j]) % mod;
        }
        dfs(v[i]);
    }
}
// 倍增求lca 
int lca(int u, int v) {
    if(dep[u] < dep[v]) {
        swap(u, v);
    }
    int d = dep[u] - dep[v];
    for(int i = 0; d; d >>= 1, i++) {
        if(d & 1) {
            u = fa[u][i];
        }
    }
    if(u == v) {
        return u;
    }
    for(int i = 20; i >= 0; i--) {
        if(fa[u][i]!= fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0]; 
}
```
核心实现思想：`dfs`函数中，在遍历子节点时，更新子节点的深度、倍增数组及前缀和数组；`lca`函数通过倍增法，先将深度深的节点提升至与另一节点同深度，再同时提升找到最近公共祖先。
2. **作者：NaCly_Fish（4星）**
    - **关键亮点**：同样采用树上差分思路，利用数组 `s` 记录从根到节点的 $k$ 次方和，结合树链剖分进行预处理，对查询时LCA处节点计算及减法取模处理有清晰说明，代码逻辑清晰。
    - **个人心得**：无
    - **核心代码**：
```cpp
void dfs1(int u, int f) {
    depth[u] = depth[f] + 1;
    for(int i = 0; i <= 50; ++i) {
        s[u][i] = s[f][i] + power(depth[u] - 1, i);
        s[u][i] %= p;
    }
    fa[u] = f;
    size[u] = 1;
    int v, t = -1, l = adj[u].size();
    for(int i = 0; i < l; ++i) {
        v = adj[u][i];
        if(v == f) continue;
        dfs1(v, u);
        size[u] += size[v];
        if(size[v] > t) {
            t = size[v];
            son[u] = v;
        }
    }
}
int lca(int u, int v) {
    int t;
    while(top[u]!= top[v]) {
        if(depth[top[u]] < depth[top[v]]) {
            t = u;
            u = v;
            v = t;
        }
        u = fa[top[u]];
    }
    if(depth[u] < depth[v]) return u;
    return v;
}
```
核心实现思想：`dfs1`函数在树链剖分的第一次DFS中，计算节点深度，更新从根到该节点的 $k$ 次方和数组 `s` ，同时记录节点大小及重儿子；`lca`函数通过树链剖分的方式，利用 `top` 数组将路径划分为重链，不断向上跳转找到最近公共祖先。
3. **作者：Rainybunny（4星）**
    - **关键亮点**：详细讲解LCA三种求解方法及复杂度，通过定义 $PreSum$ 数组表示节点及其祖先深度的 $k$ 次方和，推导出简洁的答案计算公式，代码对取模处理有详细注释，便于理解。
    - **个人心得**：强调注意取模负数情况，指出iostream是最快的IO方式。
    - **核心代码**：
```cpp
void DFS(const int u, const int fa) {
    Fa[u][0] = fa;
    for (Int i = 1; i <= 20; ++ i) {
        Fa[u][i] = Fa[Fa[u][i - 1]][i - 1];
    }
    LL Tmp = 1;
    for (Int i = 1; i <= 50; ++ i) {
        Tmp = (Tmp * Depth[u]) % Mod;
        PreSum[u][i] = PreSum[fa][i] + Tmp;
        if (PreSum[u][i] >= Mod) PreSum[u][i] -= Mod;
    }
    for (unsigned int i = 0; i < G[u].size(); ++ i) {
        if (G[u][i] ^ fa) {
            Depth[G[u][i]] = Depth[u] + 1;
            DFS(G[u][i], u);
        }
    }
}
int LCA(int a, int b) {
    for (Int i = 20; ~ i; -- i) { 
        if (Depth[Fa[a][i]] >= Depth[b]) {
            a = Fa[a][i];
        }
        if (Depth[Fa[b][i]] >= Depth[a]) {
            b = Fa[b][i];
        }
    }
    if (a ^ b) {
        for (Int i = 20; ~ i; -- i) {
            if (Fa[a][i] ^ Fa[b][i]) {
                a = Fa[a][i], b = Fa[b][i];
            }
        }
        return Fa[a][0]; 
    }
    return a; 
}
```
核心实现思想：`DFS`函数预处理节点的倍增数组 `Fa` 及前缀和数组 `PreSum` ；`LCA`函数通过倍增法，先将深度深的节点提升至与另一节点同深度，再同时提升找到最近公共祖先。

### 最优关键思路或技巧
1. **利用树上差分（前缀和）思想**：通过预处理每个节点到根节点路径上深度的 $k$ 次方和，将路径查询转化为前缀和的加减运算，简化计算。
2. **倍增法求LCA**：预处理每个节点的 $2^i$ 祖先，使得在查询LCA时能够快速定位，时间复杂度为 $O(\log n)$ ，高效且易于实现。
3. **取模运算处理**：在计算过程中，由于涉及减法运算，结果可能为负，通过 $(x \% Mod + Mod) \% Mod$ 的方式保证结果为正且在取模范围内。

### 同类型题或类似算法套路拓展
同类型题常围绕树上路径信息查询，可拓展到树上路径点权和、最大最小值等问题。类似算法套路主要是结合树上差分（前缀和）与LCA，先预处理路径信息，再通过LCA确定路径范围，利用预处理结果计算答案。对于有修改操作的题目，可能需要结合线段树、树状数组等数据结构进行动态维护。

### 推荐题目
1. **P3379 【模板】最近公共祖先（LCA）**：基础的LCA模板题，用于熟练掌握LCA算法。
2. **P1852 跳跳棋**：结合了LCA思想，通过将问题转化为树上节点关系求解。
3. **P2590 [ZJOI2008]树的统计**：涉及树上路径和及最大值查询，可运用树上差分与线段树解决，与本题思路类似但更复杂。

### 个人心得摘录与总结
1. **作者：lqhsr**：分享了调试过程中的坑点，包括变量初始化、深度数组处理、计算答案时对特殊情况（$x == y$ 和 $fa == 1$）的特判。强调了在编程中细节的重要性，变量未初始化可能导致运行错误，对边界和特殊情况的处理不当会使结果错误。 

---
处理用时：58.84秒
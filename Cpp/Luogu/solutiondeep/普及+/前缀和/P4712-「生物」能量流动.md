# 题目信息

# 「生物」能量流动

## 题目描述

生物课上，小 F 学习到了食物链、食物网的相关内容。

他学到，能量是逐级递减的。比如在食物链上，两个链接起来的生物 $A \rightarrow B$（意思是 $B$ 吃 $A$）之间的能量传递效率最多只有 $\frac 1 5$；而研究种间关系，能够使能量流向对人类最有益的部分。

现在，小 F 想研究一下能量流动的关系，于是他在脑海里创造了一个生态的系统。

在这个生态的系统里，有 $n+2$ 种生物，其中 $0$ 是生产者，整个生态系统所流经的能量由它固定；你是贪婪的顶级掠食者 $n + 1$，可以捕食所有生物；其他的掠食者 $[1, n]$ 各有各的喜好，只会捕食编号在 $[0, r_i]$ 的生物。由于天然形成的强弱顺序，上述关系满足 $r_i \leq r_{i + 1}(1 \leq i < n),$ $r_i < i(1 \leq i \leq n)$。

每种动物需要摄取至少 $a_i$ 单位能量才能存活；一个生物摄取到的能量可以传递给捕食者，但传递效率都不超过 $\frac 1 5$。也就是说，假设该动物捕获了 $b_i$ 单位的能量，所有捕食它的掠食者得到的能量总和 $c_i$，那么有：
* $b_i \geq a_i$
* $c_i \leq \frac 1 5 b_i$

你希望知道，在所有生物都存活的情况下，在最优情况下你能获取到的最大能量是多少。

## 说明/提示

### 样例 1 解释

最优情况下：
* 1 号掠食者捕食生产者 0，捕食 5 点能量，传递效率为 $\frac 1 5$，得到 1 点能量。
* 2 号掠食者捕食生产者 0，捕食 4 点能量，传递效率为 $\frac 1 5$，得到 0.8 点能量。
* 2 号掠食者捕食掠食者 1，捕食 1 点能量，传递效率为 $\frac 1 5$，得到 0.2 点能量。

可怜的你只能捕获 2 号掠食者的能量，捕食 1 点能量，得到 0.2 点能量。

### 样例 2, 3 解释

由于 2 号掠食者开始减肥不吃肉了（也有可能是打不过 1 了），所以所需的生产者能量从 9 点变成了 10 点。

### 子任务

子任务 $1(21 \mathrm{pts}) : n \leq 100$；

子任务 $2(89 \mathrm{pts}) : n \leq 10 ^ 5$。

## 样例 #1

### 输入

```
2 9
1 0
1 1```

### 输出

```
0.2000000```

## 样例 #2

### 输入

```
2 9
1 0
1 0```

### 输出

```
-1```

## 样例 #3

### 输入

```
2 10
1 0
1 0```

### 输出

```
0.4000000```

# AI分析结果

### 综合分析与结论
这些题解均围绕如何在满足各生物能量需求前提下，使顶级掠食者获取最多能量这一核心问题。思路上，都基于贪心策略，即让每个生物尽量从能量损耗最少的方式获取能量，且利用了 \(r_i \leq r_{i + 1}\) 这一性质。算法要点在于如何高效地模拟能量分配过程，不同题解采用了不同方法，如直接贪心模拟、维护前缀和、使用线段树或树状数组等数据结构。解决难点主要在于优化能量分配过程的时间复杂度，避免暴力枚举导致的高复杂度。

### 所选的题解
1. **作者：caidd (5星)**
    - **关键亮点**：思路清晰，贪心策略明确，通过 `vis` 数组优化，避免重复遍历已无能量的低等级生物，代码简洁且可读性高。
    - **个人心得**：强调了 `double` 类型使用的注意事项。
    - **核心代码**：
```cpp
int main()
{
    n=read();a=read();d[0]=a;
    for(R int i=1;i<=n;++i)
    {
        k=read(),d[i]=k,r=read();
        for(int j=vis/*vis记录最小*/;j<=r;++j)
        {
            if(!d[j]) vis=j;
            if(d[j]*0.2>=k) {d[j]=(d[j]-(k*5));k=0;break;}
            else k=(k-d[j]*0.2),d[j]=0;
        }
        if(k>0) {cout<<"-1"<<endl;return 0;}
    }
    for(int i=vis;i<=n;++i) sum+=d[i]*0.2;
    printf("%lf\n",sum);
    return 0;
}
```
    - **核心实现思想**：从生产者开始，对每个生物，从 `vis` 记录的最小等级生物开始遍历，若该生物能量能满足当前生物需求，则扣除相应能量并跳出；否则消耗该生物全部能量，更新 `vis` 与剩余需求能量。最后累加剩余生物能量的0.2倍作为顶级掠食者所得能量。
2. **作者：qqvq (4星)**
    - **关键亮点**：利用前缀和与指针记录位置，巧妙利用 \(r_i\) 的单调性，代码简洁高效，时间复杂度为 \(O(n)\)。
    - **核心代码**：
```cpp
int main() {
    scanf("%d %lld", &n, &pre);
    for(int i = 1; i <= n; ++i) {
        scanf("%d %d", a+i, &b);
        for(j = last+1; j <= b; ++j) pre+=a[j]; last = j-1;
        pre -= a[i] * 5; 
        if (pre < 0) return puts("-1"), 0;
    }
    for(int i = last+1; i <= n; ++i) pre += a[i];
    printf("%lf", pre/5.0);
    return 0;
}
```
    - **核心实现思想**：遍历每个生物，通过指针 `last` 更新可获取能量的范围，累加该范围内生物能量到前缀和 `pre`，扣除当前生物所需能量的5倍，若 `pre` 小于0则无解；最后加上剩余未处理生物能量，输出其1/5作为顶级掠食者能量。
3. **作者：star_magic_young (4星)**
    - **关键亮点**：同样利用 \(r_i\) 单调性，通过简单变量维护能量总和，实现 \(O(n)\) 复杂度的贪心算法，代码简洁明了。
    - **核心代码**：
```cpp
int main()
{
    n=rd();
    a+=rd();
    int p=1;
    for(int h=1;h<=n;h++)
    {
        int x=rd(),y=rd();
        while(p<=y) a+=b[p++];
        if(a/5-(double)x<-eps) {p=-1;break;}
        a-=x*5;
        b[h]=x;
    }
    if(p<0) puts("-1");
    else
    {
        for(;p<=n;p++) a+=b[p];
        printf("%.9lf\n",a/5);
    }
    return 0;
}
```
    - **核心实现思想**：遍历每个生物，将其可捕食范围内未处理生物能量累加到 `a`，判断 `a` 的1/5是否满足当前生物需求，若不满足则无解；否则扣除当前生物所需能量的5倍，最后加上剩余未处理生物能量，输出其1/5作为顶级掠食者能量。

### 最优关键思路或技巧
1. **利用单调性**：充分利用 \(r_i \leq r_{i + 1}\) 的性质，通过维护指针、前缀和等方式，避免重复计算，优化时间复杂度。
2. **贪心策略**：让每个生物尽量从能量损耗最少的来源获取能量，即优先从低等级生物获取，且刚好满足自身需求，以保证顶级掠食者获得最多能量。

### 可拓展思路
此类题目属于贪心策略在资源分配场景下的应用。同类型题常涉及具有一定顺序关系（如本题的 \(r_i\) 单调性）的元素，通过合理分配资源以达到最优目标。类似算法套路包括根据题目条件确定贪心策略，利用数据结构或变量维护状态以优化计算过程。

### 推荐题目
1. **P1094 [NOIP2007 普及组] 纪念品分组**：通过贪心策略对物品进行分组，使组数最少，考察贪心思想与数据排序处理。
2. **P1223 排队接水**：根据接水时间对人进行排序，利用贪心算法求出所有人等待时间总和的最小值，涉及排序与贪心策略应用。
3. **P1909 买铅笔**：在不同包装铅笔价格不同的情况下，通过贪心选择性价比最高的包装组合，满足所需铅笔数量，考察贪心策略与简单数学计算。

### 个人心得摘录与总结
1. **作者：caidd**：强调了使用 `double` 类型的注意事项，在涉及能量计算这类浮点数运算场景下，需关注数据类型选择与精度问题，避免因类型不当导致结果错误。 

---
处理用时：42.91秒
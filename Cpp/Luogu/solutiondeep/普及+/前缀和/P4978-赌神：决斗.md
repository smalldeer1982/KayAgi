# 题目信息

# 赌神：决斗

## 题目背景

**赌神 $\mathcal{CYJian}$，他回来了！**


## 题目描述

**$\mathcal{tomoo}$** 决定与 **$\mathcal{CYJian}$** 进行决斗！

已知 **$\mathcal{tomoo}$** 有 $\mathcal{N}$ 张扑克牌，每张扑克牌有一个$\mathcal{RP}$值$\mathcal{A_i}$， **$\mathcal{CYJian}$** 有$\mathcal{M}$张扑克牌，每张扑克牌有一个$\mathcal{RP}$值$\mathcal{B_i}$。

**$\mathcal{CYJian}$** 与 **$\mathcal{tomoo}$** 将会各自从他们的牌里任意取一段**连续区间**的牌决斗，谁的区间内的牌的$\mathcal{RP}$值的和更大，谁就赢了，请你帮忙求出 **$\mathcal{tomoo}$** 赢的概率。

## 说明/提示

### 样例解释
- 样例 $3$：不管怎么抽都是平均，胜率为 $0$
- 样例 $5$：共有 $9$ 种方案，其中 $3$ 次 **tomoo** 会赢，胜率为 $1/3$

### 数据范围
- 对于 $20\%$ 的数据，$0<N,M\le50$
- 对于另外 $20\%$ 的数据，$\sum_{i=1}^NA_i\le10^6,\sum_{j=1}^MB_j\le10^6$
- 对于$100\%$的数据，$0<N,M\le2000,0<A_i,B_i\le10^9$

## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 3 5 7 9```

### 输出

```
754229067```

## 样例 #2

### 输入

```
10 15
7 8 5 1 2 3 6 5 4 1 
52 10 5 6 3 2 1 4 5 8 7 4 5 6 3```

### 输出

```
181952721```

## 样例 #3

### 输入

```
1 1
5
5```

### 输出

```
0```

## 样例 #4

### 输入

```
5 5
1254125 36521421 25362142 12514221 25362142
857412252 36322411 2236232 1254112 36224125```

### 输出

```
261761853```

## 样例 #5

### 输入

```
2 2
2 4
2 5```

### 输出

```
332748118```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解先通过前缀和计算出两人所有可能的区间和，再通过排序结合双指针、二分查找等方法统计满足条件的方案数，最后根据概率公式得出答案。
    - 算法要点：利用前缀和优化区间和的计算，通过排序使数据有序以便后续查找，运用双指针或二分查找统计满足条件的区间对数。
    - 解决难点：如何高效地计算和比较所有可能的区间和。暴力枚举区间和的时间复杂度较高，因此需要通过前缀和优化计算过程，并利用排序和查找算法优化比较过程。
    - 整体来看，Hope2075的题解提供了两种方法且对复杂度分析详细，代码注释清晰；liaoxingrui的题解思路清晰，代码简洁明了；guozhetao的题解思路阐述完整，代码关键部分有注释，这三篇质量相对较高。

所选的题解：
  - 作者：Hope2075 (5星)
    - 关键亮点：提供双指针和二分两种做法，对每种做法的时间复杂度分析详细，且通过基数排序将双指针法优化到\(O(n^2)\)，代码注释清晰。
    - 个人心得：无
    - 双指针法核心代码：
```cpp
#include<cstdio>
using namespace std;
const int N=2048;
const long long M=998244353;
int n,m;
long long a[N],b[N];
long long p[N*N/2],q[N*N/2];
int read(){
    int n=0;char c;
    c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9'){
        n=n*10+c-'0';
        c=getchar();
    }
    return n;
}
void sort(long long *beg,long long *end){
    long long* s=new long long[end-beg];
    long long* t=s+(end-beg);
    long long*ss;
    int* cnt=new int[65537];
    for(int p=0;p<4;p++){
        long long r=((1ll<<((p+1)*16))-1);
        for(int i=0;i<=65536;i++)cnt[i]=0;
        cnt++;
        for(long long *i=beg;i<end;i++)cnt[((*i)&r)>>(p*16)]++;
        cnt--;
        for(int i=1;i<65536;i++)cnt[i]+=cnt[i-1];
        for(long long *i=beg;i<end;i++)s[cnt[((*i)&r)>>(p*16)]++]=(*i);
        ss=beg;beg=s;s=ss;
        ss=end;end=t;t=ss;
    }
    delete[] s;
    delete[] cnt;
}
long long cnt;
long long arc(long long a){
    int p=M-2;
    long long ans=1;
    while(p){
        if(p&1)ans=ans*a%M;
        p>>=1;
        a=a*a%M;
    }
    return ans;
}
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++){
        a[i]=read()+a[i-1];
    }
    for(int i=1;i<=m;i++){
        b[i]=read()+b[i-1];
    }
    int t1=0;
    for(int i=0;i<=n;i++){
        for(int j=0;j<i;j++){
            p[t1++]=a[i]-a[j];
        }
    }
    int t2=0;
    for(int i=0;i<=m;i++){
        for(int j=0;j<i;j++){
            q[t2++]=b[i]-b[j];
        }
    }
    sort(p,p+t1);
    sort(q,q+t2);
    int i,j;
    i=0;j=0;
    while(i<t1){
        while(p[i]>q[j]&&j<t2)j++;
        cnt+=j;
        cnt%=M;
        i++;
    }
    printf("%lld\n",cnt);
    cnt=cnt*arc(t1)%M*arc(t2)%M;
    printf("%lld\n",cnt);
}
```
核心实现思想：先通过前缀和计算出两人所有可能的区间和并存入数组，再对数组进行基数排序，最后利用双指针遍历两个数组，统计满足条件的方案数，进而得出答案。
  - 作者：liaoxingrui (4星)
    - 关键亮点：思路清晰，将所有区间和存入结构体数组并排序，在排序后的数组中通过标记统计满足条件的区间对数，代码简洁。
    - 个人心得：无
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+5;
const int mod=998244353;
int x,sum,tot;
long long n,m,ans;
long long sum1[N],sum2[N];
struct node{
    bool flag;
    long long val;
}cnt[N*N<<1];
bool cmp(node x,node y){
    return x.val==y.val?x.flag:x.val<y.val;
}
int Pow(int a,int b){
    long long cnt=a,ans=1;
    while(b){
        if(b&1)
            ans=cnt*ans%mod;
        cnt=cnt*cnt%mod;
        b>>=1;
    }
    return ans;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>x;
        sum1[i]=sum1[i-1]+x;
        for(int j=1;j<=i;j++){
            tot++;
            cnt[tot].flag=true;
            cnt[tot].val=sum1[i]-sum1[j-1];
        }
    }
    for(int i=1;i<=m;i++){
        cin>>x;
        sum2[i]=sum2[i-1]+x;
        for(int j=1;j<=i;j++){
            tot++;
            cnt[tot].val=sum2[i]-sum2[j-1];
        }
    }
    sort(cnt+1,cnt+tot+1,cmp);
    for(int i=1;i<=tot;i++)
        if(cnt[i].flag){
            sum++;
            ans=(ans+i-sum)%mod;
        }
    cout<<ans*Pow(n*(n+1)/2%mod*m*(m+1)/2%mod,mod-2)%mod;
    return 0;
}
```
核心实现思想：定义结构体数组存储区间和及所属人标记，通过前缀和计算区间和并填充数组，排序后遍历数组，根据标记统计满足条件的区间对数，最后通过快速幂求概率。
  - 作者：guozhetao (4星)
    - 关键亮点：思路阐述完整，详细说明了二分查找的过程及费马小定理求逆元的应用，代码关键部分有注释。
    - 个人心得：无
    - 关键部分代码：
```cpp
#define int long long
int p = 998244353;
//快速幂
int pow(int n,int m) {
    int ans = 1;
    while(m) {
        if(m & 1) {
            ans *= n;
            ans %= p;
        }
        n *= n;
        n %= p;
        m >>= 1;
    }
    return ans;
}
//求逆元
int niyuan(int n) {
    return pow(n,p - 2);
}
int n,m,a[2005],b[2005],c[4000005],d[4000005],cnt = 0,cnt1 = 0,ans = 0;
signed main() {
    n = read(),m = read();
    int sum = n * (n + 1) / 2; 
    sum %= p;
    sum *=  m * (m + 1) / 2;
    sum %= p;
    //前缀和 
    for(int i = 1;i <= n;i++) a[i] = read() + a[i - 1];
    for(int i = 1;i <= m;i++) b[i] = read() + b[i - 1];
    for(int i = 1;i <= n;i++) {
        for(int j = i;j <= n;j++) {
            c[++cnt] = a[j] - a[i - 1];
        }
    } 
    for(int i = 1;i <= m;i++) {
        for(int j = i;j <= m;j++) {
            d[++cnt1] = b[j] - b[i - 1];
        }
    } 
    sort(c + 1,c + cnt + 1);
    sort(d + 1,d + cnt1 + 1);
    //枚举 d 数组
    for(int i = 1;i <= cnt1;i++) {
        int l = 1,r = cnt,mid;
        //二分 c 数组
        while(l < r) {
            mid = (l + r) >> 1;
            if(c[mid] > d[i]) r = mid;
            else l = mid + 1;
        }
        if(c[l] > d[i]) {
            ans += (cnt - l + 1);
        }
        ans %= p;
    }
    write(ans * niyuan(sum) % p);
    return 0;
}
```
核心实现思想：通过前缀和计算两人所有区间和，排序后枚举一个数组，利用二分查找另一个数组中大于当前值的位置，统计满足条件的方案数，最后通过快速幂求逆元得到概率。

最优关键思路或技巧：
 - 利用前缀和快速计算区间和，将\(O(n)\)的单次区间和计算优化为\(O(1)\)。
 - 对区间和数组进行排序，为后续的双指针或二分查找创造条件，从而优化统计满足条件区间对数的过程，降低时间复杂度。

可拓展之处：同类型题通常围绕区间和的计算与比较，类似算法套路包括利用前缀和优化计算，排序后用双指针、二分查找等方法统计符合条件的数量。

推荐题目：
 - [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：考察对连续子段和的计算与优化。
 - [P3146 [USACO16OPEN]248 G](https://www.luogu.com.cn/problem/P3146)：涉及区间合并与值的计算，与本题计算区间和思路相关。
 - [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)：可通过双指针优化区间查找，与本题部分思路类似。

个人心得摘录与总结：
 - Hope2075提到将排序改成基数排序可优化时间复杂度，且自身实践后发现总用时减少但内存开销增大，这体现了算法优化中时间与空间的权衡。 

---
处理用时：61.49秒
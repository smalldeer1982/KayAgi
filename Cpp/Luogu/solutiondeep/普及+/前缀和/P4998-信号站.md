# 题目信息

# 信号站

## 题目背景

   扶贫行动来到了Q村，扶贫队准备在Q村修筑信号站，让Q村不再“远离尘世”,让人们获得丰富的外界信息。

## 题目描述

   Q村非常非常Qiong，整个村只有一条路。在这条路上，有N户人家，因为条件有限，所以一个点上可能有多户人家。因为山区运输条件落后，所以扶贫队只能修筑k个信号站，并且他们希望各电站的不合理值之和最小。信号站的不合理值是指该信号站到每户人家的距离之和。
 
   扶贫队善于修筑电站，但是他们不擅长选址~~（因为数学不好QwQ）~~，他们希望你>>编程高手，来帮助他们选择修筑信号站的最佳地点，使得k个信号站的不合理值最小。

   距离求解方法:若某信号站的坐标为x,某户人家的坐标为y,那么该信号站与该人家的距离为|x-y|（即取绝对值）。

   数据保证人家数大于信号站数。放置信号站的位置坐标必须为整数。一个位置上只能放一个信号站。


## 说明/提示

#### 样例解释

在2和3的位置上放置信号站（方案不唯一）。

#### 数据范围

对于 $ 70\% $ 的数据，$ n,k\leq 10^3 $；  
对于 $ 100\% $ 的数据，$  n \leq 1000000, 0 \leq a_i \leq 10 ^ 6 $。

## 样例 #1

### 输入

```
7 2
1 1 2 2 3 3 4```

### 输出

```
13```

# AI分析结果

• 综合分析与结论：这些题解主要围绕在一条路上有N户人家，需修筑k个信号站使不合理值之和最小的问题。思路上，有的利用绝对值几何意义先求最小值点，再向两边扩展；有的通过观察点与点答案间关系，利用前缀和等优化计算；有的采用贪心策略。算法要点包括排序、维护左右点数、利用单调性等。难点在于处理信号站建在负数位置情况及优化计算复杂度。
• 所选的题解：
  - 作者：lamboo (赞：16)  星级：4星
    - 关键亮点：利用绝对值几何意义，指出函数有唯一最小值，通过排序确定最小值点，再依据函数单调性向两边扩展取最小值并累加答案。
    - 个人心得：无
    - 核心代码片段：
```cpp
void sort(long long l,long long r)
{
    int i,j,x,y;
    if (l>n/2) return;  
    if (r<n/2) return; 
    i=l;j=r;
    x=a[l+r>>1];
    do
    {
        while (a[i]<x) ++i;
        while (x<a[j]) --j;
        if (i<=j)
        {
            y=a[i];
            a[i]=a[j];
            a[j]=y;
            ++i;--j;
        }
    }
    while (i<=j);
    if (l<j) sort(l,j);
    if (i<r) sort(i,r);
}
inline long long abs(long long x)
{
    if (x>0) return x;
    return -x;
}
int main()
{
    int k;
    scanf("%lld %d",&n,&k);
    for (int i=1;i<=n;i++) scanf("%lld",&a[i]),b[a[i]]++; 
    sort(1,n);
    long long ans=0;
    long long x=a[(n+1)/2],y=x+1;
    long long x_ans=0,y_ans=0,x_num=0,y_num=0;
    for (int i=1;i<=n;i++) 
        if (a[i]>x) ++x_num; 
    for (int i=1;i<=n;i++)  
        if (a[i]<y) ++y_num; 
    for (int i=1;i<=n;i++) x_ans+=abs(x-a[i]);
    for (int i=1;i<=n;i++) y_ans+=abs(y-a[i]);
    for (int i=1;i<=k;i++)
    {
        if (x_ans<=y_ans) 
        {
            ans+=x_ans;
            x_ans+=x_num+b[x]-(n-x_num-b[x]); 
            if (b[x]) x_num+=b[x]; 
            --x;
        }
        else
        {
            ans+=y_ans;
            y_ans+=y_num+b[y]-(n-y_num-b[y]);
            if (b[y]) y_num+=b[y];
            ++y;
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```
核心实现思想：先对数据排序，找到中位数附近两点，计算其不合理值及左右点数，每次取较小不合理值的点扩展，更新相关值并累加答案。
  - 作者：RenaMoe (赞：14)  星级：4星
    - 关键亮点：通过观察两个点答案间关系，推导信号站位置移动时答案变化，利用前缀和或递推将每次查询复杂度降到O(1)，考虑信号站建在负数位置情况。
    - 个人心得：赌写出来会WA倒数第二个点，因未考虑信号站建在负数位置，如三个信号站在三个都为0的位置时，应分别在 -1，0，1。
    - 核心代码片段：
```cpp
inline void main() {
    read(n), read(k);
    for (int i = 1, x; i <= n; ++i)
        read(x), a[x+L]++;
    for (int i = 0; i <= L+L; ++i)
        f[0] += a[i] * i;
    r = n;
    for (int i = 1; i <= L+L; ++i) {
        l += a[i-1];
        f[i] = f[i-1] + l - r;
        r -= a[i];
    }
    sort(f, f+L+L+1);
    for (int i = 0; i < k; ++i)
        ans += f[i];
    printf("%lld\n", ans);
    return 0;
}
```
核心实现思想：读入数据并统计各位置人家数，初始化f[0]，通过循环利用前缀和思想更新f数组，排序后取前k个值累加得答案。
  - 作者：fantastic_dream (赞：3)  星级：4星
    - 关键亮点：利用前缀和求出每个点对应的不合理值，通过公式$f[i]=dl[i]\cdot i - sum[dl[i]] + sum[n] - sum[dl[i]] - i\cdot (n - dl[i])$ 实现O(1)转化，考虑信号站坐标可能为负及人家坐标不连续情况。
    - 个人心得：无
    - 核心代码片段：
```cpp
for(int i=1;i<=n;i++)	sz[i]=read(),sz[i]+=k;
sort(sz+1,sz+n+1);
long long zd=sz[n];
for(int i=1;i<=n;i++){
    if(sz[i]>sz[i-1]){
        for(int j=sz[i-1]+1;j<sz[i];j++)	dl[j]=i-1;
        dl[sz[i]]=i;
    }
}
for(int i=1;i<=n;i++)	sum[i]=sum[i-1]+sz[i];
for(int i=1;i<=zd;i++){
    f[i]=1ll*dl[i]*i-sum[dl[i]]+sum[n]-sum[dl[i]]-1ll*i*(n-dl[i]);
}	
sort(f+1,f+zd+1);
for(int i=1;i<=k;i++)	ans+=f[i];
```
核心实现思想：读入坐标并处理负数情况，排序后确定各位置对应人家下标，计算前缀和，通过公式计算各点不合理值，排序取前k个累加。
• 最优关键思路或技巧：利用绝对值几何意义确定最小值点，通过推导相邻点答案关系，结合前缀和等方式优化计算不合理值的复杂度，同时注意处理信号站在负数位置的情况。
• 可拓展之处：此类问题属于在一维空间上的选址优化问题，类似的还有在数轴上放置设施使总距离最小等问题，通常可利用绝对值性质、单调性、前缀和等方法解决。
• 推荐题目：
  - P1080 [NOIP2012 提高组] 国王游戏，涉及贪心算法和前缀和优化。
  - P2672 [NOIP2015 提高组] 推销员，同样考察贪心策略及前缀和思想。
  - P1195 口袋的天空，是关于最小生成树的问题，与选址优化问题类似，都需考虑如何在一定条件下使某些值最优。
• 个人心得摘录与总结：
  - RenaMoe提到写代码可能忽略信号站建在负数位置，如特殊样例中三个信号站在坐标都为0处，应分别在 -1，0，1 位置，提醒要全面考虑题目条件。 

---
处理用时：40.87秒
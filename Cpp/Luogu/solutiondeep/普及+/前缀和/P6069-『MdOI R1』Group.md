# 题目信息

# 『MdOI R1』Group

## 题目背景

此题为比赛时的数据。

然鹅后来yummy觉得没这个必要，于是放弃加强。

**存在不使用`long double`和`__int128`的写法。**

## 题目描述

为了让我们团队的同学更加团结，我们需要让各个成员的水平尽量平均。这时，就需要有人对自己产生一些改变。

我们的团队有 $n$ 个同学，第 $i$ 个同学的水平值是一个整数 $a_i$。

我们认为当整组同学水平值的 **方差** **不超过 $m$** 的时候，这组同学就是团结的。  

请问至少要让几个同学改变自己的水平值（可以改成任意一个 **实数**），这个团队才可以做到团结？

为避免读入时的精度误差，本题输入的 $m$ 是 **实际值的 $n$ 倍**，这个值是一个整数。

---

如果你不知道什么叫做方差，以下是方差的基本概念：

方差是衡量一组数据 **波动程度** 的指标。

设长度为 $n$ 的序列 $a_{1\dots n}$ 的平均数为 $p$，则该序列的方差 $S$ 为：

$$
S=\frac{1}{n} \sum_{i=1}^n(a_i-p)^2
$$

## 说明/提示

【样例 1 解释】   

这组样例中，$n=4$，真实的 $m=\dfrac{32}{n}=8$。

一开始，所有同学水平值 $a_i$ 的平均数为 $1$，方差为：

$$S=\dfrac{1}{4}[(3-1)^2+(7-1)^2+(-5-1)^2+(-1-1)^2]=20$$

把第 $3$ 个同学的水平值改成 $3$ 后，平均数为 $3$，方差为：

$$S=\dfrac{1}{4}[(3-3)^2+(7-3)^2+(3-3)^2+(-1-3)^2]=8$$

只改变了 $1$ 人的水平值，即满足了题目要求。

【样例 2 解释】

这组样例中，$n=5$，真实的 $m=\dfrac{18}{n}=3.6$。

一开始，所有同学水平值 $a_i$ 的平均数为 $4.6$，方差为 $7.44$：

把第 $5$ 个同学的水平值改成 $3.5$ 后，平均数为 $3.5$，**方差为 $2.6$。**

只改变了 $1$ 人的水平值，即满足了题目要求。

---

【数据范围】   

|子任务编号|$n\leq$|分值|
|:-:|:-:|:-:|
|1|$16$|15|
|2|$300$|17|
|3|$10^3$|20|
|4|$5\times 10^3$|7|
|5|$10^4$|8|
|6|$2\times 10^5$|33|

对于所有测试点，$1\leq n\leq 2\times 10^5$，$1\leq m\leq 10^{18}$，$0\leq |a_i|\leq 10^6$。

## 样例 #1

### 输入

```
4 32
3 7 -5 -1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 18
1 4 3 6 9
```

### 输出

```
1
```

## 样例 #3

### 输入

```
6 679
5 83 56 20 54 111
```

### 输出

```
3
```

# AI分析结果

• 综合分析与结论：这些题解都围绕如何求使团队方差不超过给定值所需改变的最少同学数展开。核心思路是利用排序后保留连续一段同学水平值能使方差更小这一特性，通过二分答案来确定保留的同学数量，进而得到改变的同学数。同时，通过推导方差公式，维护前缀和与前缀平方和，实现O(1)计算区间方差，将时间复杂度优化到O(n log n)。部分题解还提到可通过尺取法（双指针）进一步优化到O(n)，并利用a_i值域进行桶排等优化排序复杂度。

所选的题解：
 - 作者：liangbowen (5星)
    - 关键亮点：思路清晰，不仅详细阐述二分答案思路及方差公式推导，还提及线性做法（尺取维护和桶排），代码简洁明了且使用了__int128处理大数据。
    - 个人心得：以前觉得二分答案难，现在觉得还好。
    - 核心代码片段：
```cpp
bool chk(int peo)
{
    for (int l = 1, r = peo; r <= n; l++, r++) //枚举一段长度为 peo 的区间
    {
        LL t1 = peo * (sqsum[r] - sqsum[l - 1]); 
        LL t2 = sum[r] - sum[l - 1]; t2 *= t2;
        if (t1 - t2 <= peo * m) return true;
    }
    return false;
}
int FIND(int l, int r) 
{
    int pos = -1; 
    while (l <= r)
    {
        int mid = l + r >> 1;
        if (chk(mid)) l = mid + 1, pos = mid;
        else r = mid - 1;
    }
    return n - pos; 
}
```
核心实现思想：chk函数通过枚举长度为peo的区间，根据推导的方差公式判断是否满足条件；FIND函数通过二分答案确定满足条件时去掉的最少人数。

 - 作者：yummy (4星)
    - 关键亮点：针对不同子任务逐步优化，从暴力枚举到利用排序后连续区间方差小的特性，再到二分答案和优化方差计算，思路循序渐进，代码注释详细，还给出拓展问题引导思考。
    - 核心代码片段（Subtask 6）：
```cpp
bool check(int left)
{
    for(int i=1;i<=n-left+1;i++)
    {
        double sum=s[i+left-1]-s[i-1];
        double pf=pfh[i+left-1]-pfh[i-1];
        double pj=sum*1.0/left;
        double fc=pf-2*pj*sum+pj*pj*left;
        if(fc<=m)
            return 1;
    }
    return 0;
}
int erfen(int l,int r)
{
    if(r==l+1)
        return l;
    int mid=l+r>>1;
    if(check(mid))
        return erfen(mid,r);
    else
        return erfen(l,mid);
}
```
核心实现思想：check函数枚举长度为left的区间，根据维护的区间和与区间平方和计算方差判断是否满足条件；erfen函数通过二分答案确定满足条件时保留的最大人数。

 - 作者：MoonCake2011 (4星)
    - 关键亮点：思路清晰，详细解释二分答案的check函数写法及O(1)求区间方差的推导过程，代码简洁易懂。
    - 核心代码片段：
```cpp
bool check(int x){
    double minn=2e9;
    for(int i=1;i+x-1<=n;i++){
        double p1=ps[i+x-1]-ps[i-1];
        double p2=s[i+x-1]-s[i-1];
        double p=p2/x;
        double ans=p1-2*p*p2+p*p*x;
        if(ans<=m) return true;
    }
    return false;
}
```
核心实现思想：check函数通过枚举长度为x的区间，利用前缀和与前缀平方和计算方差，判断是否满足条件。

最优关键思路或技巧：
 - **数学推导优化计算**：通过对方差公式进行推导，将其转化为可通过前缀和与前缀平方和O(1)计算的形式，大大降低了计算方差的时间复杂度。
 - **二分答案**：利用答案的单调性，通过二分确定满足方差条件的最少改变同学数，避免了暴力枚举的高复杂度。
 - **数据特性利用**：发现排序后保留连续一段同学水平值方差更小的特性，简化问题求解过程。

可拓展之处：
 - **同类型题**：如涉及求满足某种统计量（类似方差衡量数据波动）条件下的最少操作数问题，可考虑类似的二分答案结合优化统计量计算的方法。
 - **类似算法套路**：对于具有单调性的问题，二分答案是常用策略；在计算复杂统计量时，通过数学推导转化为可高效计算的形式是优化的关键。

推荐题目：
 - [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：二分答案经典题目，通过二分确定满足条件的最小跳跃距离。
 - [P3853 [TJOI2007]路标设置](https://www.luogu.com.cn/problem/P3853)：同样是二分答案，根据限制条件确定最少路标的设置数量。
 - [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)：利用二分答案确定满足分段和最大最小值限制的最优分段方案。

个人心得摘录与总结：
 - liangbowen提到以前觉得二分答案难，现在觉得还好，说明通过练习和经验积累，对算法的掌握会逐渐熟练。
 - JackMerryYoung指出本题卡精度，需要使用long double与__int128，强调了处理大数据和精度问题的重要性。 

---
处理用时：38.44秒
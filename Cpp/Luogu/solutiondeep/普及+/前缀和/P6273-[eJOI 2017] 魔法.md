# 题目信息

# [eJOI 2017] 魔法

## 题目描述

给定一个长度为 $n$ 的字符串 $S$。设 $S$ 中不同的字符数为 $k$ 。

定义字符串的子串为该字符串某一连续段。

而 ***有魔法的子串*** 被定义为 $S$ **的某一非空子串，满足该子串中不同的字符数为** $k$ **，且每个字符的出现的次数都相同**。

你需要求出给定字符串 $S$ 的不同的 有魔法的子串 的个数。

若两个子串的左右端点不同，则这两个子串不同。

## 说明/提示

#### 【输入输出样例解释】

**样例 1 解释**

- 满足条件的子串有： $\texttt{abc},\texttt{cba},\texttt{abc},\texttt{abccba}$

**样例 2 解释**

- 仅子串 $\texttt{abcABC}$ 为 有魔法的子串（区分大小写，即 $\texttt{a}\ne \texttt{A}$）。

**样例 3 解释**

- 其中一个是 $\texttt{SwSwwS}$。

#### 【数据规模与约定】

**本题采用多测试点捆绑测试，共有 4 个子任务**。

- Subtask 1（10 points）：$2\le n\le 100$。
- Subtask 2（20 points）：$2\le n\le 2\times 10^3$。
- Subtask 3（30 points）：$2\le n\le 10^5,k=2$ （即 $S$ 中只有两种字符）。
- Subtask 4（40 points）：无其他限制。

对于所有数据，保证 $2\le n\le 10^5$，字符集为 $ [\texttt{a},\texttt{z}] \cup [\texttt{A},\texttt{Z}]$

#### 【说明】

原题来自：[eJOI 2017](www.ejoi.org) Problem A [Magic](http://ejoi.org/wp-content/themes/ejoi/assets/pdfs/tasks_day_1/EN/magic_statement-en.pdf)

翻译提供：@[```_Wallace_```](https://www.luogu.com.cn/user/61430)

## 样例 #1

### 输入

```
8
abccbabc```

### 输出

```
4```

## 样例 #2

### 输入

```
7
abcABCC```

### 输出

```
1```

## 样例 #3

### 输入

```
20
SwSSSwwwwSwSwwSwwwwS```

### 输出

```
22```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效找出给定字符串中“有魔法的子串”个数展开。思路大多基于前缀和，通过推导子串为“有魔法”的充要条件，利用数据结构统计符合条件的子串。

算法要点在于维护前缀和数组，通过对不同字符前缀和差值的处理，判断子串是否满足条件。解决难点的关键在于对条件的数学推导与优化，如将条件转化为前缀和差值相等，以及如何高效存储和查询这些差值。

多数题解时间复杂度为\(O(nk\log n)\)，部分提到可优化至\(O(n\log k)\)。部分题解代码存在冗余或可优化空间，如部分暴力枚举思路未充分利用性质优化。

### 所选的题解
- **作者：5k_sync_closer（5星）**
  - **关键亮点**：思路清晰，代码简洁高效，利用前缀和数组巧妙推导子串为“有魔法”的充要条件，通过`map`存储差值向量，实现\(O(nk\log n)\)的高效算法。
  - **个人心得**：无
  ```cpp
  #include <bits/stdc++.h>
  #define h(x) lower_bound(a, a + k, x) - a
  using namespace std;
  vector<int> v;map<vector<int>, int> m;
  int n, k;long long q;char a[100050], s[100050];
  int main()
  {
      scanf("%d%s", &n, s);strcpy(a, s);sort(a, a + n);
      m[v = vector<int>(k = unique(a, a + n) - a, 0)] = 1;
      for (int i = 0; i < n; ++i)
      {
          if (s[i]!= a[0]) ++v[h(s[i])];
          else {for (auto &x : v) --x;++v[0];}
          (q += m[v]++) %= 1000000007;
      }
      return printf("%lld", q), 0;
  }
  ```
  核心实现思想：先离散化字符，初始化前缀和差值向量`v`并加入`map`。遍历字符串，动态更新`v`，每次将`map`中`v`的个数累加到答案`q`，再更新`map`中`v`的计数。
- **作者：一扶苏一（4星）**
  - **关键亮点**：从子任务三入手，先分析字符集为\(2\)的简单情况，再推广到一般情况，思路循序渐进。代码结构清晰，注释详细。
  - **个人心得**：无
  ```cpp
  const int maxn = 100005;
  const int maxk = 52;

  void Init();
  void Calc();

  int main() {
      freopen("1.in", "r", stdin);
      Init();
      Calc();
      return 0;
  }

  int n, t;
  char s[maxn];

  void Init() {
      static char tmp[maxn];
      qr(n);
      qrs(s + 1);
      for (int i = 1; i <= n; ++i) tmp[i] = s[i];
      std::sort(tmp + 1, tmp + 1 + n);
      t = std::unique(tmp + 1, tmp + 1 + n) - tmp - 1;
      for (int i = 1; i <= n; ++i) s[i] = std::lower_bound(tmp + 1, tmp + 1 + t, s[i]) - tmp - 1;
  }

  struct Dat {
      int d[maxk];

      bool operator<(const Dat &o) const {
          for (int i = 0; i < t; ++i) if (d[i]!= o.d[i]) {
              return d[i] < o.d[i];
          }
          return false;
      }
  };
  Dat dat[maxn];

  struct Cmp {
      inline bool operator()(const int x, const int y) const {
          return dat[x] < dat[y];
      }
  };

  std::map<int, int, Cmp> mp;

  void Calc() {
      ll ans = 0;
      mp[0] = 1;
      for (int i = 1, di = i - 1; i <= n; di = i++) {
          for (int j = 0; j < t; ++j) {
              dat[i].d[j] = dat[di].d[j];
          }
          if (s[i]) {
              ++dat[i].d[s[i]];
          } else {
              for (int j = 1; j < t; ++j) --dat[i].d[j];
          }
          int u = mp[i];
          ans += u;
          mp[i] = u + 1;
      }
      qw(ans % 1000000007, '\n');
  }
  ```
  核心实现思想：初始化时离散化字符。`Calc`函数中，遍历字符串，更新当前位置的差值结构体`dat[i]`，将`map`中对应`dat[i]`的计数累加到答案，再更新`map`。
- **作者：technopolis_2085（4星）**
  - **关键亮点**：从简单子任务入手，逐步优化算法，思路清晰。代码逻辑明确，详细注释有助于理解。
  - **个人心得**：无
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  #define int long long
  const int mod=1e9+7;

  map<vector<int>, int> mp; 
  const int maxn=1e5+10;
  char s[maxn];
  int a[maxn];
  int sum[maxn][60];
  int flag[maxn];

  int change(char ch){
      if (ch>='A'&&ch<='Z') return ch-'A';
      else return ch-'a'+26;
  }

  signed main(){
      int n;
      scanf("%lld",&n);
      scanf("%s",s+1);

      int k=0;
      memset(flag,-1,sizeof(flag));
      for (int i=1;i<=n;i++){
          if (flag[change(s[i])]==-1)
              flag[change(s[i])]=++k;

          a[i]=flag[change(s[i])];
      }

      for (int i=1;i<=n;i++){
          for (int j=1;j<=k;j++){
              if (j==a[i]) sum[i][j]=sum[i-1][j]+1;
              else sum[i][j]=sum[i-1][j];
          }
      }

      vector<int> v;
      v.clear();
      for (int i=1;i<=k;i++) v.push_back(0);
      mp[v]=1;

      int ans=0;
      for (int i=1;i<=n;i++){
          v.clear();
          int x=sum[i][1];
          v.push_back(0);
          for (int j=2;j<=k;j++) v.push_back(sum[i][j]-x);
          ans=(ans+mp[v])%mod;
          mp[v]++;
      }

      printf("%lld",ans);
      return 0;
  } 
  ```
  核心实现思想：先离散化字符，预处理前缀和数组`sum`。遍历字符串，构建当前位置的差值向量`v`，将`map`中`v`的计数累加到答案，再更新`map`。

### 最优关键思路或技巧
1. **前缀和与差值处理**：通过维护每个字符的前缀和，将子串是否“有魔法”的判断转化为前缀和差值的比较，简化判断条件。
2. **利用数据结构**：使用`map`或哈希表存储前缀和差值，高效统计符合条件的子串数量，优化时间复杂度。

### 可拓展思路
此类题目可拓展到其他需要判断子串或子区间性质的问题，类似算法套路包括：
1. 利用前缀和优化区间统计问题。
2. 通过数学推导将复杂条件转化为更易处理的形式。
3. 运用合适的数据结构存储和查询中间结果。

### 推荐题目
1. **P3957 [NOIP2017 提高组] 跳房子**：涉及前缀和与二分查找，优化区间统计问题。
2. **P4341 [BOI2007]Sequence 序列问题**：需处理子序列性质，类似本题对序列特定条件的判断与统计。
3. **P2699 [USACO12MAR]花盆Flowerpot**：通过前缀和与排序优化对区间条件的判断，与本题思路有相似之处。

### 个人心得摘录与总结
1. **作者：Berlin_Jacor**：强调认真审题的重要性，因未注意题目中“设\(S\)中不同的字符数为\(k\)”这句话而影响解题。总结为解题时务必仔细阅读题目条件，避免遗漏关键信息。 

---
处理用时：50.08秒
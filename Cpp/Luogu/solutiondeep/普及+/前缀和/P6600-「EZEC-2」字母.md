# 题目信息

# 「EZEC-2」字母

## 题目背景


给你一个 $01$ 矩阵，我们希望你从中找到由连续的 $1$ 组成的「字母 T」。

## 题目描述

「字母 T」由一横和一竖组成，竖一定在横的下方（您可以借助英文字母 `T` 辅助理解）。

在本题中，我们定义「横」为组成「字母 T」的水平线段，「竖」为组成「字母 T」的竖直线段。

注意「横」与「竖」的公共部分同时计入横长和竖长。

**合法的「字母 T」的「横」长必须为奇数且「竖」与「横」交于「横」的中点，「横」长最小为 $3$ ，「竖」长最小为 $2$。**


如：

$$
    \begin{array}{ccc}
       0\color{Red}111\color{black}1\\
       00\color{Red}1\color{black}01
    \end{array}
$$

**只含有**一个合法的「字母 T」（即标红部分）。


现在给你一个 $n \times m$ 的 $01$ 矩阵，请你求出在这个矩阵中**合法**的「字母 T」中，一共有多少个**满足以下条件**的「字母 T」。 

设某个合法的「字母 T」的「横」长为 $w$，「竖」长为 $h$，有：

- $w\ge a$
- $h\ge b$
- $w\times h \ge s$
- $w+h\ge x$

两个「字母 T」不相同即两个「字母 T」的 **「横」长** 或 **「竖」长** 或 **最左上角的坐标** 不同。     

## 说明/提示

**【样例解释 #1】**
$$
    \begin{array}{ccc}
      \color{Red}11111\qquad11111\\01\color{Red}1\color{black}10\qquad01\color{Red}1\color{black}10\\
      11\color{Red}1\color{black}11\qquad11\color{Red}1\color{black}11\\
      01\color{Red}1\color{black}10\qquad01\color{Red}1\color{black}10\\
      11111\qquad11\color{Red}1\color{black}11\\\\
      第\ 1\ 个\qquad第\ 2\ 个
    \end{array}
$$
除了以上两个「字母 T」，没有其他满足条件且合法的「字母 T」，故输出 $2$。

**【数据范围】**       
| 测试点编号 | $n,m\le$ | $a,b\le$ | $s\le$ | $x\le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1 \sim 4$ | $100$ | $100$ |$10^4$|$200$|
| $5 \sim 8$ | $500$ | $500$ |$2.5\times 10^5$|$10^4$|
| $9,10$ | $3\times 10^3$ | $0$ |$0$|$0$|
| $11\sim 13$ | $3\times 10^3$ |$3\times 10^3$|$0$|$6\times 10^3$|
| $14\sim 16$ | $3\times 10^3$ |$3\times 10^3$|$9\times 10^6$|$0$|
| $17\sim 20$ | $3\times 10^3$ |$3\times 10^3$|$9\times 10^6$|$6\times 10^3$|

对于 $100\%$ 的数据，满足 $1 \le n,m \le 3\times 10^3$，$0 \le a,b \le 3\times10^3$，$0 \le s \le 9\times10^6$，$\space0 \le x \le 6\times10^3$。



## 样例 #1

### 输入

```
5 5
3 3 18 9
11111
01110
11111
01110
11111```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5
3 3 15 7
11111
01110
11111
01110
11111```

### 输出

```
7```

## 样例 #3

### 输入

```
10 10
5 4 40 11
0011111111
1011110101
1111111111
1001111101
1111101111
1111110110
0111011101
0111111110
0011111111
0111111101
```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是通过预处理每个点在左、右、下三个方向上连续1的个数，再结合题目给定的限制条件来计算合法“字母T”的数量。主要区别在于对限制条件的处理方式以及最终答案的统计方法。
1. **思路与算法要点**：
    - **yangrunze**：先通过前缀和预处理出每个点三个方向连续1的个数，再根据限制条件计算出对于每个横长w的最小合法竖长minh，以及对于每个竖长h的最小合法横长minw。最后利用容斥原理，通过前缀和求出不符合要求区域，从而得出答案。
    - **pocafup**：将问题转化为求每个中心点能得到的最大T形的合法子集数量，通过二维前缀和处理限制条件，根据转移方程计算每个横长和竖长组合的合法T形数量，最后枚举中心点得出答案。
    - **JohnVictor**：枚举T字形交点，计算交点周围连续1的个数来确定T字形数量，通过定义函数G(x,y)表示(x,y)是否满足限制条件，并对其求前缀和得到F(x,y)，交点产生的答案即为F(min{L,R},D)。
    - **君のNOIP。**：从低分到高分逐步优化，先通过暴力枚举中心点和横纵长度得到20分，接着通过预处理每个w对应的最小合法h以及每个点下方连续1的数量优化到40分，再预处理左右连续1的个数得到50分，最后通过简单容斥和前缀和得到100分。
    - **LiJoQiao**：将字母T看作特殊回文串组合，沿着前缀和思路，预处理出每个中心对应的T是否符合要求的数阵，利用Manacher算法计算回文串最长长度，暴力计算向下1串最长长度，枚举中心得出答案。
    - **wjj255**：穷举T的关键点，预处理每个点三个方向连续1的个数，用t(i,j)记录横长为i，竖长为j的T是否符合题意，并计算其对答案的总贡献数s(i,j)，最后穷举关键点得出答案。
    - **makerlife**：先暴力枚举T的中心点，用前缀和记录其周围连续1的个数，再暴力判断符合条件的T。通过二维前缀和优化判断部分，用sum表示符合条件的T的数量，最后枚举位置得出答案。
    - **lizicheng3042**：通过前缀和分别求出每个位置向左、向右、向下的最大延伸距离，同时处理横和竖二元组是否满足条件，最后通过函数equ计算每个位置合法T的数量并累加得到答案。
    - **一只书虫仔**：枚举矩阵每个格子，计算其向左、右、下延伸出全为1的条的长度，设g(w,h)表示满足限制条件的点对个数，通过对g'(w,h)求前缀和得到g(w,h)，最后累加所有格子对应的g值得到答案。
2. **解决难点**：难点在于处理横长w和竖长h的四个限制条件，不同题解采用了不同方法。有的通过分别计算每个w对应的最小合法h以及每个h对应的最小合法w来限制范围（如yangrunze、君のNOIP。）；有的利用前缀和直接处理满足限制条件的T的数量（如pocafup、wjj255、makerlife、一只书虫仔）。

综合来看，yangrunze的题解思路清晰，对每个步骤的分析详细，代码注释丰富，优化过程循序渐进；君のNOIP。的题解从低分到高分逐步讲解优化过程，有助于理解；pocafup的题解虽然简短，但对限制条件的转化较为巧妙。这三篇题解质量相对较高。

### 所选的题解
1. **yangrunze - 5星**
    - **关键亮点**：思路清晰，逐步引导从简单情况到复杂限制条件的处理，详细解释了如何通过前缀和预处理数据，以及如何利用容斥原理和前缀和优化计算满足限制条件的“字母T”数量，代码注释详尽。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：通过前缀和计算每个点左、右、下连续1的个数，根据限制条件计算minh和minw，利用容斥原理计算答案。
```cpp
// 算出三个方向的前（后）缀和
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++)
    if(wyx[i][j])sl[i][j]=sl[i][j-1]+1;
}
for(int i=1;i<=n;i++){
    for(int j=m;j>0;j--)
    if(wyx[i][j])sr[i][j]=sr[i][j+1]+1;
}
for(int i=n;i>0;i--){
    for(int j=1;j<=m;j++)
    if(wyx[i][j])sd[i][j]=sd[i+1][j]+1;
}    
int w;
for(w=a+!(a&1);w<=m;w+=2){
    minh[w]=max(b,max(x-w,(int)(ceil(s*1.0/w))));//运用限制条件算出minh
    sminh[w]=sminh[w-2]+minh[w];            
}
w=a+!(a&1);
for(int h=n;h>=b;h--){
    while(w<=m&&minh[w]>h)w+=2;//运用minh算出minw
    minw[h]=w;
}
long long ans=0;
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(!wyx[i][j])continue;
        long long h=sd[i][j];
        long long lw=minw[h],rw=1ll*2*min(sl[i][j],sr[i][j])-1;
        if(rw>=lw&&h>=b)
        ans+=1ll*(rw-lw+2)/2*(h+1)-(sminh[rw]-sminh[lw-2]);//分析算出ans（实际上可以说是容斥原理）
    }
} 
```
2. **君のNOIP。 - 4星**
    - **关键亮点**：从低分到高分逐步优化算法，详细展示了不同阶段的思路和代码实现，有助于理解整个优化过程，对限制条件的预处理和利用较为清晰。
    - **个人心得**：本题原本较简单，后经团队加强并添加限制条件。
    - **重点代码 - 核心实现思想**：先预处理每个点周围连续1的个数以及每个w对应的最小合法h，再通过枚举中心点和w，利用限制条件计算答案，最后通过容斥和前缀和优化到$O(n^2)$。
```cpp
for(int i = 1; i <= n; i++)	for(int j = 1; j <= m; j++)	if(mp[i][j]) l[i][j] = l[i][j-1] + 1;
for(int i = 1; i <= n; i++)	for(int j = m; j >= 1; j--)	if(mp[i][j]) r[i][j] = r[i][j+1] + 1;
for(int i = n; i >= 1; i--)	for(int j = 1; j <= m; j++)	if(mp[i][j]) dw[i][j] = dw[i+1][j] + 1;

for(int w = a +!(a&1); w <= m; w += 2)
    mih[w] = ceil(s*1.0/w), mih[w] = max(b, max(x-w, mih[w]) ), smih[w] = smih[w-2] + mih[w];
int tp = a +!(a&1);
for(int h = n; h >= b; h--) {
    while(tp <= m && mih[tp] > h) tp += 2;
    pos[h] = tp;
}
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++)
        if(mp[i][j] && dw[i][j] >= b) {
            int ma = 2 * min(l[i][j], r[i][j]) - 1, h = dw[i][j];
            if(pos[h] <= ma) ans += (ma - pos[h] + 2) / 2 * (h + 1) - smih[ma] + smih[pos[h]-2];
        }
```
3. **pocafup - 4星**
    - **关键亮点**：将问题巧妙转化为求每个中心点能得到的最大T形的合法子集数量，通过二维前缀和简洁地处理限制条件，代码简短精炼。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：通过前缀和计算每个点三个方向连续1的个数，利用转移方程通过二维前缀和计算每个横长和竖长组合的合法T形数量，最后枚举中心点得出答案。
```cpp
For(i,1,n) For(j,1,m) lx[i][j] = (!pos[i][j])? 0 : lx[i][j-1]+1;
For(i,1,n) FOR(j,m,1) rx[i][j] = (!pos[i][j])? 0 : rx[i][j+1]+1;
For(j,1,m) FOR(i,n,1) yd[i][j] = (!pos[i][j])? 0 : yd[i+1][j]+1;
for (int i=3;i<=m;i+=2)For(j,2,n) val[i][j] = val[i-2][j]+val[i][j-1]-val[i-2][j-1]+(i>=a && j>=b && i*j>=s && i+j>=x);
For(i,1,n) For(j,1,m) ans += val[chkmin(lx[i][j],rx[i][j])*2-1][yd[i][j]];
```

### 最优关键思路或技巧
1. **前缀和的应用**：几乎所有题解都利用前缀和来快速计算每个点在不同方向上连续1的个数，大大减少了重复计算，提高了效率。
2. **限制条件的处理**：通过分析限制条件，计算出对于每个横长的最小合法竖长，或者通过二维前缀和直接统计满足限制条件的T形数量，从而巧妙地解决了限制条件带来的复杂性。
3. **容斥原理的运用**：如yangrunze和君のNOIP。的题解，通过容斥原理，将不符合要求的部分从所有可能的情况中减去，从而得到满足条件的答案，简化了计算过程。

### 可拓展之处
此类题目属于在矩阵中寻找特定形状并满足一定条件的计数问题。拓展方向可以是改变形状（如寻找其他字母形状、不规则形状等），或者增加更多复杂的限制条件（如对形状的位置、分布有特殊要求等）。类似算法套路通常围绕预处理数据（如前缀和、后缀和等）来快速获取每个点的相关信息，再结合条件进行判断和计数。

### 相似知识点洛谷题目推荐
1. **P8865 [NOIP2022] 种花**：同样是在矩阵中寻找特定形状（C和F），并涉及到一些条件判断，可通过类似的前缀和方法解决。
2. **P1387 最大正方形**：在矩阵中寻找满足条件的最大正方形，与本题在矩阵中寻找特定形状并优化求解有相似之处。
3. **P1388 取数游戏II**：在矩阵上进行操作并满足一定条件求最优解，需要通过预处理和合理的算法优化来解决，与本题思路有相通之处。 

---
处理用时：68.58秒
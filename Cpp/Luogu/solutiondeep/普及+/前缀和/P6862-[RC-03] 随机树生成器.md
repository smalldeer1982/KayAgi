# 题目信息

# [RC-03] 随机树生成器

## 题目描述

小 R 有一个随机树生成器，其工作原理如下：
- 输入 $n$，则对于每个 $1<i\le n$，随机选择一个 $[1,i)$ 中的节点作为其父亲。返回这棵树。

给定 $n,k$，小 R 想知道可能生成的所有 $n$ 个点的树中，$k$ 号点的度数和。

由于答案可能很大，请输出答案模 $10^9+9$ 的值。

## 说明/提示

【样例说明】

- 数据 $1$：一共有两种情况，$1$ 号点的度数分别为 $1,2$。因此答案为 $3$。
- 数据 $2$：一共有两种情况，$2$ 号点的度数分别为 $1,2$。因此答案为 $3$。
- 数据 $3$：一共有两种情况，$3$ 号点的度数均为 $1$。因此答案为 $2$。

【数据范围】

本题捆绑测试。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$1\le k\le n\le 10^7$。详细数据范围如下。

- Subtask 1（20 分）：$T\le 50$，$n\le 8$。
- Subtask 2（55 分）：$T=1$，$n\le 10^5$。
- Subtask 3（20 分）：$T=1$。
- Subtask 4（5 分）：没有任何附加限制。

## 样例 #1

### 输入

```
3
3 1
3 2
3 3```

### 输出

```
3
3
2```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解均先计算出 $n$ 个点能生成的树的总数为 $(n - 1)!$，这是基于每个节点 $i$（$i > 1$）有 $i - 1$ 种选择父亲节点的方式，根据乘法原理得出。对于 $k$ 号点度数和的计算，分为两部分，$k \neq 1$ 时，一部分是父亲节点贡献的度数 1，另一部分是儿子节点贡献的度数，即对于每个 $k < i \leq n$ 的点，其有 $\frac{1}{i - 1}$ 的概率选择 $k$ 作为父亲，将这些概率累加后乘以树的总数。$k = 1$ 时，只有儿子节点贡献的度数。
    - 算法要点：通过线性预处理逆元、阶乘以及逆元的前缀和，实现 $O(n)$ 预处理，$O(1)$ 回答每个询问。
    - 解决难点：由于数据范围较大，$T \times n$ 很大，直接计算会超时，所以需要通过预处理逆元、阶乘和逆元前缀和来优化计算过程。

    综合来看，各题解思路基本一致，质量差异主要体现在思路清晰度、代码可读性等方面。

• 所选的题解：
  - 作者：一只书虫仔 (4星)
    - 关键亮点：思路阐述清晰，简洁明了地说明了度数分为父亲节点和儿子节点两部分贡献，并给出了具体的计算公式。
  - 作者：Mine_King (4星)
    - 关键亮点：不仅给出解题思路和公式，还提供了完整且注释详细的代码，代码可读性高。
    ```cpp
    #include<cstdio>
    #include<cstring>
    #include<algorithm>
    using namespace std;
    const int mod=1e9+9;
    int T,n,k,fac[10000005],inv[10000005];
    int main()
    {
        fac[0]=1;
        for(int i=1;i<=1e7;i++) fac[i]=1ll*fac[i-1]*i%mod;
        inv[1]=1;
        for(int i=2;i<=1e7;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
        for(int i=1;i<=1e7;i++) inv[i]=(inv[i-1]+inv[i])%mod;
        scanf("%d",&T);
        while(T--)
        {
            scanf("%d%d",&n,&k);
            int ee=(inv[n-1]-inv[k-1]+mod)%mod;
            printf("%lld\n",(1ll*fac[n-1]*ee%mod+(k!=1)*fac[n-1])%mod);
        }
        return 0;
    }
    ```
    核心实现思想：先预处理阶乘数组 `fac` 和逆元数组 `inv`，并计算逆元的前缀和。对于每次询问，根据公式计算并输出答案。
  - 作者：Little09 (4星)
    - 关键亮点：思路清晰，代码简洁，在代码中直接体现了对 $1$ 号节点的特殊处理，逻辑明确。
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    #define ll long long
    const ll p=1000000009;
    const ll N=10000000;
    ll inv[10000006],jc[10000006];
    int T;
    int main()
    {
        inv[1]=1;
        for (int i=2;i<=N;i++)
        {
            inv[i]=((p-p/i)*inv[p%i])%p;
        }
        for (int i=2;i<=N;i++)
        {
            inv[i]=(inv[i-1]+inv[i])%p;
        }
        jc[1]=1;
        for (ll i=2;i<=N;i++)
        {
            jc[i]=(jc[i-1]*i)%p;
        }
        cin >> T;
        while (T--)
        {
            ll n,k;
            cin >> n >> k;
            ll u;
            if (k!=1) u=(inv[n-1]-inv[k-1]+p+1)%p;
            else u=(inv[n-1]-inv[k-1]+p)%p;
            u=(u*jc[n-1])%p;
            printf("%lld\n",u);
        }
        return 0;
    }
    ```
    核心实现思想：与上一题解类似，先预处理逆元前缀和与阶乘，然后根据 $k$ 是否为 $1$ 进行不同计算并输出答案。

• 最优的关键思路或技巧：
    - 思维方式上，将问题拆分为父亲节点和儿子节点对度数的贡献分别计算，使问题简化。
    - 算法优化上，通过线性预处理逆元、阶乘以及逆元前缀和，大大提高了计算效率，满足了题目大数据范围的要求。

• 同类型题或类似算法套路：此类题目通常结合组合数学与概率知识，通过分析每个元素的贡献来计算总和，并且常因数据范围大需要进行预处理优化。

• 推荐题目：
    - [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)：专门考察乘法逆元的计算，是本题预处理逆元的基础。
    - [P4316 绿豆蛙的归宿](https://www.luogu.com.cn/problem/P4316)：结合图论与概率期望，与本题通过分析每个节点的贡献来计算结果的思路类似。
    - [P1654 OSU!](https://www.luogu.com.cn/problem/P1654)：通过分析每个位置的贡献来计算期望，与本题在思维方式上有相似之处。

• 个人心得摘录与总结：
    - 作者 LittleMoMol 强调了注意模数，在做此类取模运算题目时，务必看清题目要求的模数，否则容易出错。这提醒我们在做题时要仔细审题，对关键条件如模数等不能疏忽。 

---
处理用时：46.02秒
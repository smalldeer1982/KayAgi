# 题目信息

# [传智杯 #4 决赛] 生活在树上（easy version）

## 题目背景

**本题是 P8201 的简单版本，两道题目的解法略有不同。本题和 P8201 在题意上的区别在于本题给定树上的边权，而不是点权。**

小智生活在「传智国」，这是一个有 $n$ 个城市的国家，各个城市由 $n-1$ 条道路相连。

每个道路都有长度 $w_i$ ，我们定义，小智从城市 $a$ 走到城市 $b$ 的代价是 $\mathrm{dis}_{a, b} = \bigoplus \limits_{e \in \mathrm{path}\left(a, b\right)} w_e$，其中 $\bigoplus$ 表示**按位异或**（如果你不知道什么是**按位异或**，请参见题目下方的提示/说明），$\mathrm{path}\left(a,b\right)$ 表示 $a$ 到 $b$ 的简单路径上的边集。也即 $\mathrm{dis}_{a, b}$ 表示将 $a$ 与 $b$ 的简单路径上所有边写作 $e_1, e_2, e_3, \dots$ 后，求 $w_{e_1} \bigoplus w_{e_2}\bigoplus w_{e_3} \dots$ 的结果。

有一天，小智获得了去参加传智杯的机会，他在前往比赛地的路上想到了一个问题，但他好像不会做，于是他把这个题告诉了你。聪明的同学，你可以帮帮他吗？

## 题目描述

小智说：「由于我们的国家只有 $n$ 个城市和 $n-1$ 条道路，那么我们的国家就相当于是一棵树。我在想，在我们的国家中，是否有城市满足『到城市 $a$ 的代价和到城市 $b$ 的代价的异或等于 $k$』。好难哦，我想不出来，你能帮帮我吗？」

也就是说，给定城市 $a, b$ 和整数 $k$，请你计算是否存在城市 $t$ 满足 $\mathrm{dis}_{t, a} \bigoplus \mathrm{dis}_{t, b} = k$。

## 说明/提示

### 相关概念解释
「树」：树是一个有 $n$ 个结点和 $n-1$ 条边的无向简单连通图。

「按位异或」：按位异或即 C++、python、java 语言中的 「^」 运算。它是一个二元运算，步骤是将两个数的二进制位按位比较，相同为 $0$，不同为 $1$。例如：$3 \bigoplus 5 = (011)_2 \bigoplus (101)_2 = (110)_2 = 6$。**请注意，这是一个按位运算，不是一个逻辑运算**。
### 样例 1 解释
下图为传智国的地图。

$\forall t \in \{1, 2, 3, 4, 5\}$，都不可能有 $\mathrm{dis} _{t,1} \bigoplus \mathrm{dis}_{t, 2} = 4$，$\mathrm{dis}_{t, 2} \bigoplus \mathrm{dis}_{t, 3} = 12$，于是输出 `No`；

而取 $t = 5$，有 $\mathrm{dis}_{t, 1} \bigoplus \mathrm{dis}_{t, 4} = 10$，于是输出 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ikzjfh3.png)
### 数据规模与约定
对于所有测试点，保证 $1 < n \leq 5 \times 10^5$，$1 \leq m \leq 5 \times 10^5$，$0 \leq w_i < 2^{64}$。

对于每次询问，保证 $1 \leq a, b \leq n$ 且 $a \neq b$，$0 \leq k < 2^{64}$。

## 样例 #1

### 输入

```
5 3
1 2 2
1 3 6 
2 4 8
2 5 1
1 2 4
2 3 12
1 4 10```

### 输出

```
nO
No
YeS```

## 样例 #2

### 输入

```
5 10
2 1 63
3 1 57
4 2 2
5 2 84
5 2 84
4 1 9977404983223574764
2 5 84
2 1 15996060349666123522
5 4 86
3 1 8428615422876116375
5 1 107
2 3 6
2 3 6
4 2 2```

### 输出

```
yeS
nO
YEs
No
YEs
nO
YEs
yeS
yeS
YEs```

# AI分析结果

• 综合分析与结论：
    - 所有题解核心思路均基于异或运算性质，通过推导得出对于任意点\(t\)，\(\mathrm{dis}_{t, a} \oplus \mathrm{dis}_{t, b} = \mathrm{dis}_{a, b}\)，将问题转化为求\(\mathrm{dis}_{a, b}\)是否等于\(k\)。
    - 算法要点在于通过一次深度优先搜索（DFS）预处理出从根节点到每个节点的路径异或和，利用该结果快速计算任意两点间路径的异或和。
    - 解决难点主要是对异或运算性质的运用以及推导过程，需理解异或运算满足交换律、结合律，且自身异或为\(0\)等性质。
    - 多数题解在思路和算法上相近，区别主要在代码实现的细节和风格上。

所选的题解：
  - **作者：一扶苏一 (赞：17) - 5星**
    - **关键亮点**：思路清晰，先从异或运算构成Abel群的理论角度阐述，再结合图形直观说明路径异或和的性质，代码简洁且注释清晰，使用`std::array`和`std::vector`等标准库容器，提升代码可读性和安全性。
    - **核心代码片段**：
```cpp
void dfs(const int u, const int f) {
  for (auto [v, w] : e[u]) if (v!= f) {
    b[v] = b[u] ^ w;
    dfs(v, u);
  }
}
```
核心实现思想：通过DFS遍历树，利用异或运算更新每个节点到根节点的路径异或和。

  - **作者：lsj2009 (赞：4) - 4星**
    - **关键亮点**：详细展示了思路推导过程，从预处理求\(\mathrm{dis}_{1,a}\)，到推导\(\mathrm{dis}_{i, a}\oplus\mathrm{dis}_{i, b}=\mathrm{dis}_{1, a}\oplus\mathrm{dis}_{1, b}\)，逻辑连贯，代码分建树预处理和查询两部分，清晰明了。
    - **核心代码片段**：
```cpp
void Dfs(int u,int fa) {
	for(int i=head[u];i;i=Edge[i].nxt) {
		int v=Edge[i].to,w=Edge[i].w;
		if(v!=fa)
			dis[v]=(dis[u]^w),Dfs(v,u);
	}
}
while(m--) {
		int a,b,k;
		read(a,b,k); //快读
		puts((dis[a]^dis[b])==k? "Yes":"No");
	}
```
核心实现思想：先通过DFS预处理每个节点到根的异或和，查询时直接判断两点到根异或和的异或结果是否等于\(k\)。

  - **作者：Dusker (赞：4) - 4星**
    - **关键亮点**：简洁明了地阐述思路，直接给出从根节点到各节点异或和与两点间异或和的关系，代码实现紧凑，使用`std::vector`存储边信息，`#define`宏定义提升代码简洁性。
    - **核心代码片段**：
```cpp
void dfs(int cur, int fa)
{
	for(auto v : edge[cur])
		if(v.first!= fa)
			Xor[v.first] = Xor[cur] ^ v.second, dfs(v.first, cur);
	return;
}
for(int i = 1;i <= m;i++)
{
		int x, y;
		i64 k;
		std::cin >> x >> y >> k;
		if((Xor[x] ^ Xor[y]) == k)
			{
				if(rand() & 1)
					std::cout << "yeS\n";
				else
					std::cout << "YEs\n";
			}
		else
			{
				if(rand() & 1)
					std::cout << "No\n";
				else
					std::cout << "nO\n";
			}
	}
```
核心实现思想：DFS计算各节点到根的异或和，查询时判断两点到根异或和的异或是否等于\(k\)，输出结果时随机选择大小写形式。

最优的关键思路或技巧：利用异或运算的交换律、结合律以及自身异或为\(0\)的性质，通过一次DFS预处理从根节点到每个节点的路径异或和，从而快速计算任意两点间路径的异或和，将原问题简化为简单的判断操作。

可拓展之处：此类问题可拓展到更复杂的树上路径异或和相关问题，例如动态修改边权后查询路径异或和，或在树上进行更复杂的异或关系判断。类似算法套路是在树上问题中，充分利用异或运算性质，通过预处理减少重复计算。

推荐洛谷题目：
  - P3379 【模板】最近公共祖先（LCA）：考察树上路径相关知识，与本题对树结构的操作理解有相似之处。
  - P2680 运输计划：结合树上路径与二分查找，对树上路径操作和优化有进一步考察。
  - P1852 跳跳棋：涉及到对树结构的理解和状态转移，与本题在利用树的性质解决问题上思路相通。

个人心得：
  - **作者：苏联小渣**：提到注意异或运算的优先级，因优先级问题考场上未通过样例。总结为在涉及多种运算时，务必注意运算符优先级，可通过添加括号明确运算顺序，避免此类错误。 

---
处理用时：34.62秒
# 题目信息

# 〈 TREEのOI 2022 Spring 〉Counting By Ternary

## 题目背景

黑土地上，一棵小苗破土而出。

几个月里，它吮吸着甘甜的雨露，享受着温暖的阳光，愈发翠绿了起来。

![](https://cdn.pixabay.com/photo/2019/03/05/12/52/plant-4036131_960_720.jpg)

它越长越高，越长越壮，似乎要突破云霄。

它长成了一棵大树，渴望着去天空中，看一看这美丽的世界。

![](https://cdn.pixabay.com/photo/2015/02/24/15/41/wolf-647528_960_720.jpg)

## 题目描述

**请留意本题并不寻常的时空限制。**

给定一个数 $x$，用如下规则建立一棵有根树：

- 根节点为 $\lang0,x\rang$。  

- 对于一个节点 $\lang i,j\rang$，若 $j < 3$，则它是叶子节点，否则它的子节点为对于任意 $1 \le k$ 且 $j$ 的位数 $\ge k$， $\lang j_k, k\rang$，其中 $j_k$ 为它三进制表示从左向右的第 $k$ 位。  

求这棵树的叶子节点的数目。

## 说明/提示



**本题采用 SubTask 捆绑测试。**

| SubTask 编号 | 分值 | 特殊性质 |
| :-----------: | :-----------: | :-----------: |
| $0$ | $10$ | $p\le 3^{15}$，$q=1$ |
| $1$ | $10$ | $p\le 3^{35}$，$q=1$ |
| $2$ | $20$ | $p=3$，$q\le 3^{15}$ |
| $3$ | $60$ | $p=3$，$q\le 3^{35}$ |


对于 $100\%$ 的数据，$p^q \le 3^{3^{35}}$（$10^{10^9} \lt 3^{3^{35} } \lt 10^{2.5 \times 10^9}$），保证 $p = 3^l(l\in \mathbb N^+)$。 


## 样例 #1

### 输入

```
9 1```

### 输出

```
4```

## 样例 #2

### 输入

```
27 1```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
这两道题解思路相近，均通过观察节点连接规律得出递推式，再针对原始递推式时间复杂度高的问题进行优化，最终将时间复杂度优化至 $O(\log_3 \log_3p^q)$。

过氧化氢_syq0057 的题解思路清晰，先给出基础解法及复杂度分析，再详细阐述优化过程，代码注释较完善，对特殊情况处理有明确说明。Galois_Field_1048576 的题解直接给出递推式及优化思路，但在推导过程的详细程度和代码注释上不如前者。

### 所选的题解
- **作者：过氧化氢_syq0057（5星）**
  - **关键亮点**：思路清晰，从基础解法逐步优化到高效解法，对递推式的推导及优化过程阐述详细，代码注释完善，对特殊情况处理说明清晰。
  - **个人心得**：提到是冲着分块标签来做题，发现不是分块题。
  - **核心代码**：
```cpp
ll Log3(ll s) {//下取整 
	ll res = 0;
	while (s) {
		s /= 3;
		res++;
	}
	return res - 1;
}
ll ksm(ll x, ll y) {
	ll res = 1;
	while (y) {
		if (y & 1) res = res * x;
		x = x * x;
		y >>= 1;
	}
	return res;
}
int main() {
	scanf("%lld%lld", &p, &q);
	ll x = q * Log3(p) + 1;
	ll log3x = Log3(q * Log3(p)) + 1;
	f[1] = 1, f[2] = 1;
	for (int i=3; i<=100; i++)
		for (int j=1; j<=Log3(i)+1; j++)
			f[i] += f[j];
	g[1] = 1, g[2] = 2;
	for (ll i=3; i<=log3x; i++)
		for (int j=1; j<=i; j++)
			g[i] += f[j];
	for (int i=1; i<=log3x; i++) {
		if (i == log3x) ans += (x - ksm(3, i - 1) + 1) * g[i];//注意特殊处理
		else ans += (ksm(3, i) - ksm(3, i - 1)) * g[i];
	}
	printf("%lld\n", ans);
	return 0;
}
```
  - **核心实现思想**：先通过 `Log3` 函数计算下取整的以3为底对数，`ksm` 函数实现快速幂。主函数中，先根据输入计算相关变量，初始化 `f` 数组部分值，通过循环递推 `f` 数组。再初始化 `g` 数组部分值，通过循环递推 `g` 数组。最后通过循环累加并对最后一项特殊处理得到答案。

### 最优关键思路或技巧
1. **观察规律得出递推式**：通过观察节点连接规律，发现节点 $i$ 连向 $\lfloor \log_3{i} \rfloor + 1$ 的节点，从而得出递推式 $f_i = \sum_{j=1}^{\lfloor \log_3i \rfloor + 1} f_j$。
2. **利用取值规律优化**：观察到 $f_i$ 有相同取值区间，定义 $g_i$ 代表 $f_{3^{i - 1}}$ 到 $f_{3^i - 1}$ 的值，将递推式优化到 $O(\log_3 \log_3p^q)$ 复杂度。

### 可拓展思路
此类题目通常需要通过观察题目所给规则找到规律，得出递推式，再针对递推式复杂度进行优化。相似套路如利用数列的周期性、单调性等特性进行优化。

### 洛谷相似题目推荐
1. [P1990 覆盖墙壁](https://www.luogu.com.cn/problem/P1990)：通过找规律得出递推式解决问题。
2. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：根据数字生成规则推出递推式求解。
3. [P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)：利用递推思想解决计数问题。 

---
处理用时：24.13秒
# 题目信息

# 『JROI-8』这是新历的朝阳，也是旧历的残阳

## 题目背景

![1663764375173.png](https://img-kysic-1258722770.file.myqcloud.com/8c10be566f21cceb653f209300936b97/68a6764e14651.png)

>少女于海边伫立，凝视着落日最后的余晖\
“已然过去了呢，旧历的一年......”

**已获得转载授权。**

## 题目描述

给定序列 $\{a_n\}$，满足每一项都不小于前一项。对于所有不超过 $k$ 的正整数 $m$，询问如果将 $a$ 分成 $m$ 段（可以有空段），并给从前往后第 $i$ 段内的每个数都加上 $i$，增加后的 $\sum\limits_{j=1}^n a_j^2$ 最大是多少。询问相互独立，即每次询问时给每个数加的值不保留到下一次询问。

例如，对于序列 $\{-3,1,2,2\}$，若 $m=5$，则一种分段方式是 $[-3][][1,2][][2]$，增加后的序列是 $-2,4,5,7$，此时 $\sum\limits_{j=1}^n a_j^2=94$。

记 $m=i$ 时的答案（即此时最大的 $\sum\limits_{j=1}^n a_j^2$）为 $q_i$，出于良心考虑，你只需要输出 $\left(\sum\limits_{i=1}^k q_i\right) \bmod 998244353$ 即可。标准程序不基于特殊的输出方式，即能独立求出每一个 $q_i$。


## 说明/提示

#### 【样例解释】

当 $m=1$ 时，最优策略是 $[-3,1,2,2]$，$q_1=(-2)^2+2^2+3^2+3^2=26$。

当 $m=2$ 时，最优策略是 $[-3][1,2,2]$，$q_2=(-2)^2+3^2+4^2+4^2=45$。

当 $m=3$ 时，最优策略是 $[-3][][1,2,2]$，$q_3=(-2)^2+4^2+5^2+5^2=70$。

则 $\left(\sum\limits_{i=1}^k q_i\right) \bmod 998244353=(q_1+q_2+q_3)\bmod 998244353=(26+45+70)\bmod 998244353=141$。

#### 【数据范围与约束】

| 测试点编号 | 分数 | $n\leq$ | $k\leq$ | $\lvert a_i\rvert \leq$ | 特殊性质 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $1\sim 3$ | $15$ | $12$ | $12$ | $1000$ | 无 |
| $4\sim 6$ | $15$ | $1000$ | $1000$ | $1000$ | 无 |
| $7\sim 8$ | $10$ | $10^6$ | $10^6$ | $10^7$ | $a_i\geq0$ |
| $9 \sim 12$ | $20$ | $10^6$ | $1000$ | $10^7$ | 无 |
| $13\sim 20$ | $40$ | $10^6$ | $10^7$ | $10^7$ | 无 |


## 样例 #1

### 输入

```
4 3
-3 1 2 2```

### 输出

```
141```

# AI分析结果

• 综合分析与结论：这些题解主要围绕贪心策略和数学推导展开。思路上，均利用序列单调不减及可有空段的特性，将数分为两类（正数和负数）讨论，通过比较数在第一段和最后一段的平方和大小来决定其归属。算法要点在于用前缀和优化平方和及一次项和的计算，以降低时间复杂度。解决难点在于处理负数在不同分段下的最优放置位置，以及如何高效计算每一种分段数量下的最大平方和。多数题解时间复杂度为 \(O(n + k)\)，部分暴力思路为 \(O(nk)\)。

所选的题解：
  - **作者wdgm4（5星）**
    - **关键亮点**：思路清晰，先阐述暴力思路及不足，再详细讲解AC思路。通过转换求和顺序，利用前缀和优化计算，分正负情况讨论，对取模、数据类型等细节有详细说明。
    - **个人心得**：考试时因未考虑爆long long痛失30分，强调取模和数据类型处理的重要性。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define XD 114514
using namespace std;
long long n,k;
long long m,f;
const long long mod=998244353;
const int MAXN=20000000;
long long a[1000010];
long long ans,num;
int b[20000010];//前缀和
int main(){
    cin>>n>>k;
    for(long long i=1;i<=MAXN;i++){
        b[i]=(b[i-1]+i*i%mod)%mod;//计算前缀和
    }
    for(register int i=1;i<=n;i++){
        num=0;
        scanf("%lld",&a[i]);
        if(a[i]<0){//分情况讨论
            m=(a[i]+1)*(-2)+1;
            f=-(a[i]+1);
            num+=min(m,k)*1ll*f%mod*f;//注意这里一定要取模一次，不然会爆long long
            num%=mod;
            if(k>m){
                num+=(b[k-m+f]*1ll-b[f]+mod)%mod;
                num%=mod;
            }
        }else{
            num+=(b[a[i]+k]*1ll-b[a[i]]+mod)%mod;
            num%=mod;
        }
        ans+=num;
        ans%=mod;
    } 
    cout<<ans%mod;
    return 0;
}
```
    - **核心实现思想**：预先计算从1到MAXN的平方前缀和。遍历序列，对每个数分正负讨论。负数时，计算在第一段和最后一段放置的临界值，根据k与临界值的关系，利用前缀和计算贡献；正数时，直接利用前缀和计算其在最后一段的贡献，累加每个数的贡献得到最终答案。
  - **作者ScottSuperb（4星）**
    - **关键亮点**：从贪心策略出发，结合完全平方公式，详细分析正负数在不同分段下的处理方式，代码实现简洁明了。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 998244353
ll a[1000005];
int main() {
    int n = read(), k = read(), b = 0;
    ll q = 0, ans = 0, psum = 0, del;
    for (int i = 0; i < n; ++i)
        a[i] = read(), b += a[i] < 0, q = (q + (a[i] + 1) * (a[i] + 1) % mod) % mod;
    ans += q;
    for (int i = b; i < n; ++i) psum = (psum + a[i] + 1 % mod) % mod;
    n = n - b;
    for (int m = 2; m <= k; ++m) {
        ans = (ans + (q = (q + psum * 2 % mod + n) % mod)) % mod,
        psum = (psum + n) % mod;
        while (b > 0 && a[b - 1] + m > abs(a[b - 1] + 1)) {
            --b, ++n;
            del = (a[b] + m) * (a[b] + m) % mod - (a[b] + 1) * (a[b] + 1) % mod;
            ans = (ans + del) % mod, q = (q + del) % mod, psum = (psum + (a[b] + m) % mod) % mod;
        }
    }
    write(ans);
    fls();
    return 0;
}
```
    - **核心实现思想**：先统计负数个数b，计算m = 1时的平方和q及正数和psum。循环m从2到k，每次更新q和psum，同时检查负数是否满足移到最后一段的条件，若满足则更新相关变量，累加每次的q到ans。
  - **作者xwh_Marvelous（4星）**
    - **关键亮点**：通过数学推导得出数要么在第一段要么在最后一段的结论，分析负数在不同条件下的放置位置，并利用平方和公式优化计算过程。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=998244353;
int n,k,pos;
ll a[1000005],ans,tot1,tot2,tot3;
int main(){
    scanf("%d%d",&n,&k);
    pos=n;
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]),tot3+=(a[i]+1)*(a[i]+1),tot3%=mod;
    for(int i=1;i<=k;i++){
        tot2+=2*tot1+(n-pos),tot2%=mod;
        tot1+=(n-pos),tot1%=mod;
        while(pos>0&&abs(a[pos]+i)>abs(a[pos]+1)){
            tot3-=(a[pos]+1)*(a[pos]+1),tot3%=mod,tot3+=mod,tot3%=mod;
            tot1+=a[pos]+i,tot1%=mod;
            tot2+=(a[pos]+i)*(a[pos]+i),tot2%=mod;
            pos--;
        }
        ans+=tot2+tot3;
        ans%=mod;
    }
    printf("%lld",ans);
    return 0;
}
```
    - **核心实现思想**：初始化pos为n，计算所有数在第一段时的平方和tot3。循环k次，每次更新tot1（最后一段数的和）和tot2（最后一段数平方和的增量），检查pos位置的数是否应移到最后一段，若应移动则更新相关变量，最后累加tot2和tot3到ans。

• 最优的关键思路或技巧：利用贪心策略，基于数的正负性和完全平方公式，分析每个数在不同分段下应放置在第一段还是最后一段。通过前缀和优化平方和及一次项和的计算，降低时间复杂度。同时，利用序列单调不减的特性，减少不必要的计算。

• 可拓展之处：同类型题通常围绕具有单调性的序列，结合贪心和数学推导来优化计算。类似算法套路包括分析数据特性，确定贪心策略，利用数学公式化简计算，以及使用前缀和等方式优化。

• 推荐题目：
  - [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)
  - [P1248 加工生产调度](https://www.luogu.com.cn/problem/P1248)
  - [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)

• 个人心得摘录与总结：
  - **作者wdgm4**：考试因未考虑爆long long丢分，强调取模和数据类型处理在算法实现中的重要性，提醒注意细节以避免不必要的失分。 

---
处理用时：49.67秒
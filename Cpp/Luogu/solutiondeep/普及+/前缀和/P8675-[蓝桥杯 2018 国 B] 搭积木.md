# 题目信息

# [蓝桥杯 2018 国 B] 搭积木

## 题目描述

小明对搭积木非常感兴趣。他的积木都是同样大小的正立方体。

在搭积木时，小明选取 $m$ 块积木作为地基，将他们在桌子上一字排开，中间不留空隙，并称其为第 $0$ 层。

随后，小明可以在上面摆放第 $1$ 层，第 $2$ 层，……，最多摆放至第 $n$ 层。摆放积木必须遵循三条规则：

规则 $1$：每块积木必须紧挨着放置在某一块积木的正上方，与其下一层的积木对齐；

规则 $2$：同一层中的积木必须连续摆放，中间不能留有空隙；

规则 $3$：小明不喜欢的位置不能放置积木。

其中，小明不喜欢的位置都被标在了图纸上。图纸共有 $n$ 行，从下至上的每一行分别对应积木的第 $1$ 层至第 $n$ 层。每一行都有 $m$ 个字符，字符可能是 `.` 或 `X`，其中 `X` 表示这个位置是小明不喜欢的。

现在，小明想要知道，共有多少种放置积木的方案。他找到了参加蓝桥杯的你来帮他计算这个答案。

由于这个答案可能很大，你只需要回答这个答案对 $1000000007(10^9+7)$ 取模后的结果。

注意：地基上什么都不放，也算作是方案之一种。

## 说明/提示

**【样例解释】**

成功的摆放有（其中O表示放置积木）：

```
 1       2       3       4
..X     ..X     O.X     ..X
.X.     OX.     OX.     .XO
```

**【数据约定】**

对于 $10\%$ 的数据，$n=1$，$m \le 30$；

对于 $40\%$ 的数据，$n \le 10$，$m \le 30$；

对于 $100\%$ 的数据，$n \le 100$，$m \le 100$。

时限 1 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
2 3
..X
.X.```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕区间DP结合二维前缀和优化的思路来解决问题。
 - **思路**：大多题解定义状态 \(dp_{i,l,r}\) 表示第 \(i\) 层在区间 \([l,r]\) 放置积木且以这一层为顶端的方案数，通过状态转移方程 \(dp_{i,l,r}=\sum_{j=1}^{l}\sum_{k=r}^{m}dp_{i + 1,j,k}\) 进行求解，最后累加各层各区间方案数并加1（全不放的方案）得到答案。
 - **算法要点**：利用前缀和记录每层中“X”的数量，快速判断区间合法性；通过二维前缀和优化状态转移过程，将原本 \(O(nm^4)\) 的时间复杂度优化到 \(O(nm^2)\)。
 - **解决难点**：核心在于优化时间复杂度，避免暴力枚举导致超时，不同题解在状态转移的具体实现和前缀和处理上略有差异。

### 所选的题解
 - **作者：zhlzt (赞：20)  星级：5星**
    - **关键亮点**：思路清晰，先详细阐述题目条件，再明确给出状态转移方程和答案计算公式，并结合代码详细解释二维前缀和优化的具体实现过程，逻辑连贯，代码可读性高。
    - **重点代码 - 核心实现思想**：利用前缀和数组 `num` 记录每层 `X` 的数量，初始化最底层的 `dp` 值，通过二维前缀和数组 `sum` 优化状态转移，累加每层合法区间的 `dp` 值得到答案。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int num[110][110];char s[110];
long long dp[110][110][110],sum[110][110];
int main(){
    int n,m;scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%s",s+1);
        for(int j=1;j<=m;j++)
            num[i][j]=num[i][j-1]+(s[j]=='X');
    }
    long long ans=1;
    for(int l=1;l<=m;l++)
        for(int r=l;r<=m;r++){
            dp[n][l][r]=(num[n][r]-num[n][l-1]==0);
            ans=(ans+dp[n][l][r])%mod;
        }
    for(int i=n-1;i>=1;i--){
        for(int l=1;l<=m;l++)
            for(int r=1;r<=m;r++)
                sum[l][r]=(dp[i+1][l][r]+sum[l][r-1]+sum[l-1][r]-sum[l-1][r-1])%mod;
        for(int l=1;l<=m;l++)
            for(int r=l;r<=m;r++) if(num[i][r]-num[i][l-1]==0){
                dp[i][l][r]=(sum[l][m]-sum[0][m]-sum[l][r-1]+sum[0][r-1])%mod;
                ans=(ans+dp[i][l][r])%mod;
            }
    }
    printf("%lld",(ans+mod)%mod);
    return 0;
}
```
 - **作者：DreamLand_zcb (赞：18)  星级：5星**
    - **关键亮点**：对题意的理解和转化清晰，逐步分析状态转移方程、初始化、答案计算以及优化过程，每一步都有详细说明，代码注释丰富，易于理解。
    - **重点代码 - 核心实现思想**：通过前缀和数组 `a` 记录每层 `X` 的数量判断区间合法性，初始化最底层合法区间的 `dp` 值为1，利用二维前缀和数组 `s` 优化状态转移，同时累加每层合法区间的 `dp` 值更新答案。
```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;

const int MOD = 1e9 + 7;
int n, m;
ll a[105][105];
ll s[105][105];
ll dp[105][105][105];
ll ans = 1;
int main()
{
    ios::sync_with_stdio(false);
    cin >> n >> m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            char c;
            cin >> c;
            a[i][j] = a[i][j-1] + (c == 'X');
        }
    }
    for(int i=1;i<=m;i++)
    {
        for(int j=i;j<=m;j++)
        {
            if(a[n][j] - a[n][i-1]!= 0)    continue;
            dp[n][i][j] = 1;
        }
    }
    for(int i=n;i>=1;i--)
    {
        for(int j=1;j<=m;j++)
        {
            for(int k=j;k<=m;k++)
            {
                if(a[i][k] - a[i][j-1]!= 0)    continue;
                dp[i][j][k] += (s[j][m] - s[0][m] - s[j][k-1] + s[0][k-1]) % MOD;
                dp[i][j][k] %= MOD;
                ans += (dp[i][j][k]) % MOD;
                ans %= MOD;
            }
        }
        for(int j=1;j<=m;j++)
        {
            for(int k=1;k<=m;k++)
            {
                s[j][k] = (s[j-1][k] + s[j][k-1] - s[j-1][k-1] + dp[i][j][k]) % MOD;
                s[j][k] %= MOD;
            }
        }
    }
    cout << (ans + MOD) % MOD;
    return 0;
}
```
 - **作者：wuhan1234 (赞：14)  星级：4星**
    - **关键亮点**：详细分析状态转移方程的推导过程，解释了为何小区间方案数可能比大区间多的原因，对状态转移方程的理解深入，代码实现简洁明了。
    - **重点代码 - 核心实现思想**：利用前缀和数组 `s` 记录每层 `X` 的数量，初始化最底层合法区间的 `dp` 值，通过状态转移方程 `dp[l][r]=(dp[l][r]+dp[l][r + 1]+dp[l - 1][r]-dp[l - 1][r + 1])%MOD` 更新每层的 `dp` 值并累加得到答案。
```c
#include <stdio.h>
# define MOD 1000000007
int s[105][105]={0};
long long dp[105][105]={0};
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    char ch[105];
    int i,j;
    for (i=n;i>=1;i--)
    {
        scanf("%s",ch+1);
        for (j=1;j<=m;j++)
        {
            s[i][j]=s[i][j-1];
            if (ch[j]=='X') s[i][j]++;
        }
    }
    long long ans=1;
    int l,r;
    for (l=1;l<=m;l++)
        for (r=m;r>=l;r--)
            if (s[1][r]-s[1][l-1]==0)
            {
                dp[l][r]=1+dp[l][r+1]+dp[l-1][r]-dp[l-1][r+1];
                ans++;
            }
    for (i=2;i<=n;++i)
    {
        for (l=1;l<=m;l++)
            for (r=m;r>=l;r--)
                if (s[i][r]-s[i][l-1]==0)
                {
                    ans=(ans+dp[l][r])%MOD;
                    dp[l][r]=(dp[l][r]+dp[l][r+1]+dp[l-1][r]-dp[l-1][r+1])%MOD;
                }
                else
                    dp[l][r]=0;
    }
    printf("%lld\n",ans);
    return 0;
}
```

### 最优的关键思路或技巧
 - **区间DP状态定义**：通过定义 \(dp_{i,l,r}\) 表示第 \(i\) 层在区间 \([l,r]\) 的放置方案数，很好地描述了问题状态，为状态转移提供基础。
 - **前缀和优化判断**：利用前缀和记录每层中不喜欢位置（“X”）的数量，在 \(O(1)\) 时间内判断区间是否合法，提高效率。
 - **二维前缀和优化转移**：将状态转移方程中的双重求和转化为二维前缀和的计算，把 \(O(m^2)\) 的转移复杂度优化到 \(O(1)\)，从而将整体时间复杂度从 \(O(nm^4)\) 降至 \(O(nm^2)\)。

### 可拓展之处
此类题目属于计数类DP问题，通常涉及对具有特定限制条件的排列组合方案进行计数。相似算法套路是根据问题特点合理定义状态，找到状态间的转移关系，并通过前缀和、二维前缀和等方式优化转移过程。同类型题如在矩阵中放置物品，要求满足相邻、连续等条件的方案计数问题。

### 推荐题目
 - [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)：在棋盘上放置国王，要求国王互不相邻，考察状态压缩DP与计数。
 - [P3211 [HNOI2011] 括号修复](https://www.luogu.com.cn/problem/P3211)：通过添加或修改括号使表达式合法，涉及区间DP与计数。
 - [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)：合并能量项链珠子，求最大能量，典型的区间DP题目。

### 个人心得摘录与总结
 - **作者：DreamLand_zcb**：强调开 `long long` 以及及时取模的重要性，在处理大数运算时，防止数据溢出和错误结果。 

---
处理用时：60.58秒
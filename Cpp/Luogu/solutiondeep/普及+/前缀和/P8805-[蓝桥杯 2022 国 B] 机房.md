# 题目信息

# [蓝桥杯 2022 国 B] 机房

## 题目描述

这天，小明在机房学习。

他发现机房里一共有 $n$ 台电脑，编号为 $1$ 到 $n$，电脑和电脑之间有网线连接，一共有 $n-1$ 根网线将 $n$ 台电脑连接起来使得任意两台电脑都直接或者间接地相连。

小明发现每台电脑转发、发送或者接受信息需要的时间取决于这台电脑和多少台电脑直接相连，而信息在网线中的传播时间可以忽略。比如如果某台电脑用网线直接连接了另外 $d$ 台电脑, 那么任何经过这台电脑的信息都会延迟 $d$ 单位时间 (发送方和接收方也会产生这样的延迟，当然如果发送方和接收方都是 同一台电脑就只会产生一次延迟)。

小明一共产生了 $m$ 个疑问：如果电脑 $u_{i}$ 向电脑 $v_{i}$ 发送信息，那么信息从 $u_{i}$ 传到 $v_{i}$ 的最短时间是多少?


## 说明/提示

**【样例说明】**

这四台电脑各自的延迟分别为 $2,2,1,1$ 。

对于第一个询问, 从 $2$ 到 $3$ 需要经过 $2,1,3$, 所以时间和为 $2+2+1=5$。对于第二个询问，从 $3$ 到 $4$ 需要经过 $3,1,2,4$，所以时间和为 $1+2+2+1=6$。

对于第三个询问，从 $3$ 到 $3$ 只会产生一次延迟, 所以时间为 1。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据，保证 $n, m \leq 1000$;

对于 $100 \%$ 的数据，保证 $n, m \leq 10^5$。

蓝桥杯 2022 国赛 B 组 H 题。

## 样例 #1

### 输入

```
4 3
1 2
1 3
2 4
2 3
3 4
3 3```

### 输出

```
5
6
1```

# AI分析结果

• 综合分析与结论：这些题解主要围绕树上最近公共祖先（LCA）算法来解决问题。思路上，均是将两点间路径拆分为通过LCA的两段，利用点权和前缀和思想计算路径总延迟。算法要点在于求出各点到根节点的点权和（前缀和），并通过LCA确定路径。解决难点在于准确处理LCA处点权，避免重复计算或遗漏。不同题解在LCA实现方式（倍增法、Tarjan算法）和前缀和处理上有差异，部分还涉及树链剖分等优化。
• 所选的题解：
  - 作者：_JF_ (5星)
    - 关键亮点：思路清晰，结合LCA和前缀和，公式推导明确，代码简洁规范，详细注释利于理解。
    - 核心代码片段：
```cpp
void dfs(int u,int fath)
{
    dep[u]=dep[fath]+1;
    fa[u][0]=fath;
    for(int i=1;(1<<i)<=dep[u];i++)
        fa[u][i]=fa[fa[u][i-1]][i-1];
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if(v==fath)
            continue;
        sum[v]=sum[u]+a[v];
        dfs(v,u);
    }
}
int lca(int x,int y)
{
    if(dep[x]<dep[y])
        swap(x,y);
    int d=dep[x]-dep[y];
    for(int i=0;i<=log2(n);i++)
        if((1<<i)&d)
            x=fa[x][i];
    if(x==y)
        return x;
    for(int i=log2(n);i>=0;i--)
    {
        if(fa[x][i]!=fa[y][i])
            x=fa[x][i],y=fa[y][i];
    }
    return fa[x][0];
}
signed main()
{
    cin>>n>>m;
    for(int i=1,u,v;i<n;i++)
        cin>>u>>v,g[u].push_back(v),g[v].push_back(u);
    for(int i=1;i<=n;i++)
        a[i]=g[i].size(),sum[i]=g[i].size();
    dfs(1,0);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        cin>>u>>v;
        cout<<sum[u]+sum[v]-2*sum[lca(u,v)]+a[lca(u,v)]<<endl;
    }
    return 0;
}
```
核心实现思想：`dfs`函数预处理节点深度、父节点数组和前缀和数组；`lca`函数用倍增法求LCA；主函数读入数据，计算点权，调用`dfs`，根据公式计算并输出每次询问结果。
  - 作者：2021sunzishan (4星)
    - 关键亮点：采用Tarjan算法求LCA，对Tarjan算法解释详细，思路连贯，代码注释丰富。
    - 核心代码片段：
```cpp
void tarjan(int u,int fa) {
    vis[u]=1;
    for (int i=head[u]; i; i=edge[i].next) { 
        int v=edge[i].to;
        if(v!=fa) 
            tarjan(v,u); 
    }
    for (int i=head1[u]; i; i=edge1[i].next) { 
        int v=edge1[i].to;
        if(vis[v]) { 
            int kk=find(v); 
            ans[edge1[i].id]=dp[u]+dp[v]-dp[kk]*2+a[kk];
        }
    }
    f[u]=fa; 
}
void dfs(int u,int fa) { 
    for(int i=head[u]; i; i=edge[i].next) {
        int v=edge[i].to;
        if(v!=fa){
            dp[v]=dp[u]+a[v]; 
            dfs(v,u);
        }
    }
}
int main() {
    n=read();
    m=read();
    for(int i=1; i<=n-1; i++) { 
        int u,v;
        u=read();
        v=read();
        addedge(u,v);
        addedge(v,u);
        a[u]++;
        a[v]++;
    }
    for(int i=1; i<=m; i++) { 
        int u,v;
        u=read();
        v=read();
        addedge1(u,v,i);
        addedge1(v,u,i); 
    }
    for(int i=1; i<=n; i++)
        f[i]=i; 
    dfs(1,0); 
    tarjan(1,0);
    for (int i=1; i<=m; i++)
        printf("%d\n",ans[i]); 
    return 0;
}
```
核心实现思想：`dfs`函数预处理每个点到根节点的点权和；`tarjan`函数遍历节点，用并查集标记父节点，处理询问，计算并记录答案；主函数读入边和询问，初始化并查集，调用`dfs`和`tarjan`，输出答案。
  - 作者：GoodCoder666 (4星)
    - 关键亮点：分析清晰，对思路阐述详细，代码简洁高效，注释清晰，倍增求LCA代码规范。
    - 核心代码片段：
```cpp
void dfs(int v, int par)
{
    int d = depth[v] + 1;
    fa[v][0] = par;
    for(int i=1; (1<<i)<d; i++)
        fa[v][i] = fa[fa[v][i - 1]][i - 1];
    dis[v] += cost(v);
    for(int u: G[v])
        if(u!= par)
        {
            dis[u] = dis[v];
            depth[u] = d;
            dfs(u, v);
        }
}

int lca(int u, int v)
{
    if(depth[u] < depth[v])
        u ^= v ^= u ^= v;
    int m = depth[u] - depth[v];
    for(int i=0; m; i++, m>>=1)
        if(m & 1)
            u = fa[u][i];
    if(u == v) return u;
    for(int i=__builtin_log2(depth[u]); i>=0; i--)
        if(fa[u][i]!= fa[v][i])
            u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}

int main()
{
    int n, q;
    scanf("%d%d", &n, &q);
    for(int i=1; i<n; i++)
    {
        int x, y;
        scanf("%d%d", &x, &y);
        G[--x].push_back(--y);
        G[y].push_back(x);
    }
    dfs(0, -1);
    while(q--)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        int f = lca(--u, --v);
        printf("%d\n", dis[u] + dis[v] - 2 * dis[f] + cost(f));
    }
    return 0;
}
```
核心实现思想：`dfs`函数预处理节点深度、父节点数组和到根节点距离；`lca`函数用倍增法求LCA；主函数读入数据，调用`dfs`，处理询问，根据公式输出答案。
• 最优关键思路或技巧：利用LCA将树上两点路径问题转化为两段路径和的计算，结合前缀和优化路径点权和的求解，准确处理LCA处点权避免重复或遗漏计算。
• 可拓展之处：同类型题常涉及树上路径查询、点权和边权相关计算。类似算法套路是利用树的特殊结构，如LCA、树链剖分等优化路径操作。常见变形有动态修改点权或边权、查询不同条件下的路径属性等。
• 推荐洛谷题目：
  - P3379 【模板】最近公共祖先（LCA）
  - P1852 跳跳棋
  - P2579 [ZJOI2005] 沼泽鳄鱼
• 个人心得：无。 

---
处理用时：59.65秒
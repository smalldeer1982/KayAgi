# 题目信息

# [NOIP2022] 种花

## 题目描述

小 C 决定在他的花园里种出 $\texttt{CCF}$ 字样的图案，因此他想知道 $\texttt C$ 和 $\texttt F$ 两个字母各自有多少种种花的方案；不幸的是，花园中有一些土坑，这些位置无法种花，因此他希望你能帮助他解决这个问题。

花园可以看作有 $n\times m$ 个位置的网格图，从上到下分别为第 $1$ 到第 $n$ 行，从左到右分别为第 $1$ 列到第 $m$ 列，其中每个位置有可能是土坑，也有可能不是，可以用 $a_{i,j} = 1$ 表示第 $i$ 行第 $j$ 列这个位置有土坑，否则用 $a_{i,j} = 0$ 表示这个位置没土坑。

一种种花方案被称为 $\texttt{C-}$ **形**的，如果存在 $x_1, x_2 \in [1, n]$，以及 $y_0, y_1, y_2 \in [1, m]$，满足 $x_1 + 1 < x_2$，并且 $y_0 < y_1, y_2 \leq m$，使得第 $x_1$ **行**的第 $y_0$ 到第 $y_1$ **列**、第 $x_2$ **行**的第 $y_0$ 到第 $y_2$ **列**以及第 $y_0$ **列**的第 $x_1$ 到第 $x_2$ **行**都**不为土坑**，且只在上述这些位置上种花。

一种种花方案被称为 $\texttt{F-}$ **形**的，如果存在 $x_1, x_2, x_3 \in [1, n]$，以及 $y_0, y_1, y_2 \in [1, m]$，满足 $x_1 + 1 < x_2 < x_3$，并且 $y_0 < y_1, y_2 \leq m$，使得第 $x_1$ **行**的第 $y_0$ 到第 $y_1$ **列**、第 $x_2$ **行**的第 $y_0$ 到第 $y_2$ **列**以及第 $y_0$ **列**的第 $x_1$ 到第 $x_3$ **行**都**不为土坑**，且只在上述这些位置上种花。

样例一解释中给出了 $\texttt{C-}$ 形和 $\texttt{F-}$ 形种花方案的图案示例。

现在小 C 想知道，给定 $n, m$ 以及表示每个位置是否为土坑的值 $\{a_{i,j}\}$，$\texttt{C-}$ 形和 $\texttt{F-}$ 形种花方案分别有多少种可能？由于答案可能非常之大，你只需要输出其对 $998244353$ 取模的结果即可，具体输出结果请看输出格式部分。

## 说明/提示

**【样例 1 解释】**

四个 $\texttt{C-}$ 形种花方案为：

```plain
**1 **1 **1 **1
*10 *10 *10 *10
**0 *** *00 *00
000 000 **0 ***
```

其中 $\texttt*$ 表示在这个位置种花。注意 $\texttt C$ 的两横可以不一样长。

类似的，两个 $\texttt{F-}$ 形种花方案为：

```plain
**1 **1
*10 *10
**0 ***
*00 *00
```

**【样例 2】**

见附件下的 $\texttt{plant/plant2.in}$ 与 $\texttt{plant/plant2.ans}$。

**【样例 3】**

见附件下的 $\texttt{plant/plant3.in}$ 与 $\texttt{plant/plant3.ans}$。

**【数据范围】**

对于所有数据，保证：$1 \leq T \leq 5$，$1 \leq n, m \leq 10^3$，$0 \leq c, f \leq 1$，$a_{i,j} \in \{0, 1\}$。

| 测试点编号 | $n$ | $m$ | $c=$ | $f=$ | 特殊性质 | 测试点分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $\leq 1000$ | $\leq 1000$ | $0$ | $0$ | 无 | $1$ |
| $2$ | $=3$ | $=2$ | $1$ | $1$ | 无 | $2$ |
| $3$ | $=4$ | $=2$ | $1$ | $1$ | 无 | $3$ |
| $4$ | $\leq 1000$ | $=2$ | $1$ | $1$ | 无 | $4$ |
| $5$ | $\leq 1000$ | $\leq 1000$ | $1$ | $1$ | A | $4$ |
| $6$ | $\leq 1000$ | $\leq 1000$ | $1$ | $1$ | B | $6$ |
| $7$ | $\leq 10$ | $\leq 10$ | $1$ | $1$ | 无 | $10$ |
| $8$ | $\leq 20$ | $\leq 20$ | $1$ | $1$ | 无 | $6$ |
| $9$ | $\leq 30$ | $\leq 30$ | $1$ | $1$ | 无 | $6$ |
| $10$ | $\leq 50$ | $\leq 50$ | $1$ | $1$ | 无 | $8$ |
| $11$ | $\leq 100$ | $\leq 100$ | $1$ | $1$ | 无 | $10$ |
| $12$ | $\leq 200$ | $\leq 200$ | $1$ | $1$ | 无 | $6$ |
| $13$ | $\leq 300$ | $\leq 300$ | $1$ | $1$ | 无 | $6$ |
| $14$ | $\leq 500$ | $\leq 500$ | $1$ | $1$ | 无 | $8$ |
| $15$ | $\leq 1000$ | $\leq 1000$ | $1$ | $0$ | 无 | $6$ |
| $16$ | $\leq 1000$ | $\leq 1000$ | $1$ | $1$ | 无 | $14$ |

特殊性质 A：$\forall 1 \leq i \leq n, 1 \leq j \leq \left\lfloor \frac{m}{3} \right\rfloor$，$a_{i, 3 j} = 1$；

特殊性质 B：$\forall 1 \leq i \leq \left\lfloor \frac{n}{4} \right\rfloor, 1 \leq j \leq m$，$a_{4 i, j} = 1$；

## 样例 #1

### 输入

```
1 0
4 3 1 1
001
010
000
000```

### 输出

```
4 2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕在 $n×m$ 网格图中统计 $\texttt{C-}$ 形和 $\texttt{F-}$ 形种花方案数的问题展开。思路上大多先考虑 $\texttt{C-}$ 形方案数的求解，再基于 $\texttt{C-}$ 形去推导 $\texttt{F-}$ 形的方案数。算法要点在于利用乘法原理，通过预处理和前缀和优化来降低时间复杂度。解决难点在于如何高效地统计不同形状的方案数，避免重复计算，同时优化暴力枚举带来的高复杂度。

### 所选的题解
- **作者：CuSO4_and_5H2O（5星）**
    - **关键亮点**：思路清晰，先点明问题本质是前缀和优化计数问题，再逐步阐述如何分别求解 $\texttt{C-}$ 形和 $\texttt{F-}$ 形方案数，代码简洁且注释详细。
    - **个人心得**：提到初始化的重要性，多测不清空会导致错误。
    - **重点代码 - 预处理**：
```cpp
for(int i=1;i<=n;i++)
    for(int j=m-1;j>=1;j--)
    {
        if(Map[i][j]=='1') f[i][j]=-1;
        else  if(Map[i][j+1]=='0') f[i][j]=f[i][j+1]+1;
    }
```
**核心实现思想**：通过从右往左遍历每一行，若当前位置不能种花设为 -1，否则根据右侧位置情况计算可种花的长度。
    - **重点代码 - 求 $\texttt{C-}$ 形数量**：
```cpp
for(int j=1;j<m;j++)
{
    jis=jil=jilf=0;
    for(int i=1;i<=n;i++)
    {
        if(f[i][j]==-1){jis=jilf=jil=0;continue ;}
        ansc+=f[i][j]*jil;
        jil+=max(0,f[i-1][j]);
    }
}
```
**核心实现思想**：枚举每一列，对于每一行，若当前行该列位置可种花，计算当前行对 $\texttt{C-}$ 形方案数的贡献，并更新上一行可种花的长度和。
- **作者：一扶苏一（5星）**
    - **关键亮点**：对 $\texttt{C-}$ 形和 $\texttt{F-}$ 形方案数的推导过程详细，通过定义多个数组（如 $\mathrm{right}$、$\mathrm{up}$、$\mathrm{down}$），利用递推关系清晰地阐述计算方案数的方法，代码简洁明了。
    - **重点代码 - 计算 $\texttt{C-}$ 形方案数**：
```cpp
for (int i = n - 1; i; --i) {
    for (int j = 0; j < m; ++j) if (a[i][j]!= '1') {
        if (i < n - 1) down[i][j] = down[i + 1][j] + 1;
        else down[i][j] = 1;
    }
}
for (int i = 0; i < n; ++i) {
    for (int j = m - 1; j >= 0; --j) if (a[i][j]!= '1') {
        right[i][j] = right[i][j + 1] + 1;
        if (i > 1 && a[i - 1][j]!= '1' && right[i - 2][j] > 0) up[i][j] = up[i - 1][j] + right[i - 2][j] - 1;
        int c = (right[i][j] - 1) * up[i][j] % p, f = 1ll * c * (down[i][j] - 1) % p;
        if ((ans1 += c) >= p) ans1 -= p;
        if ((ans2 += f) >= p) ans2 -= p;
    }
}
```
**核心实现思想**：先预处理出每个点向下延伸的长度 $\mathrm{down}$，再通过遍历计算每个点作为左下角折点时竖边和顶边的方案数 $\mathrm{up}$，最后结合 $\mathrm{right}$ 数组计算 $\texttt{C-}$ 形方案数。
- **作者：wangzl（4星）**
    - **关键亮点**：对题意理解深刻，详细讲解了 $\texttt{C-}$ 形和 $\texttt{F-}$ 形种花方案处理的每一步，从定义数组到推导公式，逻辑连贯，代码实现完整且有详细注释。
    - **重点代码 - $\texttt{C-}$ 形方案 std**：
```cpp
for (int i = 1; i <= n; ++i)
    for (int j = m - 1; j >= 1; --j)
        if (!k[i][j] &&!k[i][j + 1])
            right[i][j] = right[i][j + 1] + 1;
for (int j = 1; j <= m; ++j)
    for (int i = n; i >= 1; --i)
        if (!k[i][j]) 
            sumc[i][j] = sumc[i + 1][j] + right[i][j] * 1ll;
for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
        if (k[i + 1][j]) continue;
        vc = (vc + right[i][j] * sumc[i + 2][j]) % mod;
    }
}
```
**核心实现思想**：首先预处理出每个点右侧连续 $0$ 的个数 $right$，再计算 $sumc$ 数组表示从当前点向下连续 $0$ 位置的 $right$ 之和，最后通过遍历计算 $\texttt{C-}$ 形总方案数。

### 最优关键思路或技巧
1. **预处理**：通过预处理每个点向右、向下能延伸的长度，避免在枚举过程中重复计算，降低时间复杂度。
2. **前缀和优化**：利用前缀和数组记录特定方向上的累计信息，使得在计算方案数时能够 $O(1)$ 查询，进一步优化算法。
3. **乘法原理应用**：将图形的不同部分的方案数相乘，得到整体的方案数，简化计算过程。

### 可拓展思路
此类题目属于网格图计数问题，可拓展到其他形状的计数，或者增加更多限制条件，如不同区域种花颜色不同等。类似算法套路是通过预处理和前缀和优化暴力枚举，对于复杂形状可通过拆解成简单部分，利用乘法原理计算方案数。

### 相似知识点洛谷题目
1. **P1387 最大正方形**：在一个由0和1组成的矩阵中，求最大的全1正方形的边长，涉及到动态规划和类似的网格图处理。
2. **P2704 [NOI2001] 炮兵阵地**：在一个山地地图上放置炮兵，有一定的放置规则，求最多能放置的炮兵数量，同样需要对网格图进行分析和优化计数。
3. **P1169 棋盘制作**：在一个黑白相间的棋盘上，求最大的黑白交替的正方形和长方形，考查对网格图的处理和优化算法。

### 个人心得摘录与总结
1. **CuSO4_and_5H2O**：强调初始化的重要性，多测时不清空相关数组会导致错误，提醒在处理多组数据问题时要注意数组初始化。 

---
处理用时：66.42秒
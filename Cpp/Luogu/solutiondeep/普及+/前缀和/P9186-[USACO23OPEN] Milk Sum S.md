# 题目信息

# [USACO23OPEN] Milk Sum S

## 题目描述

**注意：本题的时间限制为 4 秒，是默认时间限制的 2 倍。**

Farmer John 的 $N$ 头奶牛的产奶量为整数 $a_1, \dots, a_N$。也就是说，第 $i$ 头奶牛每分钟产 $a_i$ 单位的牛奶。

每天早上，Farmer John 会将所有 $N$ 头奶牛连接到谷仓的挤奶机上。他需要依次断开连接，将奶牛送去进行日常锻炼。第一头奶牛在挤奶 1 分钟后被断开连接，第二头奶牛在再挤奶 1 分钟后被断开连接，依此类推。由于第一头奶牛（假设是奶牛 $x$）只在挤奶机上停留了 1 分钟，她总共贡献了 $a_x$ 单位的牛奶。第二头奶牛（假设是奶牛 $y$）在挤奶机上停留了总共 2 分钟，因此贡献了 $2a_y$ 单位的牛奶。第三头奶牛（假设是奶牛 $z$）贡献了 $3a_z$ 单位的牛奶，依此类推。设 $T$ 表示 Farmer John 以最优顺序断开奶牛连接时，可以收集到的最大总牛奶量。

Farmer John 很好奇，如果某些奶牛的产奶量发生变化，$T$ 会如何变化。对于每个由两个整数 $i$ 和 $j$ 指定的 $Q$ 个查询，请计算如果将 $a_i$ 设置为 $j$，新的 $T$ 值会是多少。注意，每个查询都是独立的临时变化，即在考虑下一个查询之前，$a_i$ 会恢复为原始值。

## 说明/提示

对于第一个查询，$a$ 将变为 $[1,1,4,2,6]$，此时 $T = 1 \cdot 1 + 2 \cdot 1 + 3 \cdot 2 + 4 \cdot 4 + 5 \cdot 6 = 55$。

对于第二个查询，$a$ 将变为 $[1,8,4,2,6]$，此时 $T = 1 \cdot 1 + 2 \cdot 2 + 3 \cdot 4 + 4 \cdot 6 + 5 \cdot 8 = 81$。

对于第三个查询，$a$ 将变为 $[1,10,4,5,6]$，此时 $T = 1 \cdot 1 + 2 \cdot 4 + 3 \cdot 5 + 4 \cdot 6 + 5 \cdot 10 = 98$。

$1 \leq N \leq 1.5 \cdot 10^5$，$0 \leq a_i \leq 10^8$，$1 \leq Q \leq 1.5 \cdot 10^5$，$0 \leq j \leq 10^8$。

- 输入 2-4：$N, Q \leq 1000$。
- 输入 5-11：没有额外限制。

## 样例 #1

### 输入

```
5
1 10 4 2 6
3
2 1
2 8
4 5
```

### 输出

```
55
81
98
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是基于将数组排序后能使 \(T = \sum _{i=1} ^N i \times b_i\) 最大这一结论。对于每次查询的处理，主要通过二分查找新值在排序数组中的位置，结合前缀和来计算 \(T\) 的变化。

各题解的算法要点和难点解决方式相似，不同之处在于细节处理和代码实现风格。例如，有的题解通过分类讨论改大或改小数的情况，有的通过分析插入位置与原位置的关系来计算变化。

### 所选的题解
1. **作者：DreamLand_zcb（5星）**
    - **关键亮点**：思路阐述极为详细，通过图文并茂的方式解释每个步骤，对二分查找位置、计算 \(T\) 变化的过程讲解清晰，代码实现简洁明了，注释丰富。
    - **个人心得**：强调了不开long long的后果。
    - **核心代码**：
```cpp
while(Q--)
{
    ll x, y;
    cin >> x >> y;
    ll pos=upper_bound(b+1, b+n+1, y)-b;
    ll ans=sum;
    ans-=a[x]*P[a[x]];
    ans-=s[n]-s[P[a[x]]];
    ans+=y*(pos-(pos > P[a[x]]));
    ans+=s[n]-s[pos-1];
    if(pos <= P[a[x]])	ans-=b[P[a[x]]];
    cout << ans << endl;
}
```
    - **核心思想**：先二分找到新值 \(y\) 在排序数组 \(b\) 中的位置 \(pos\)，然后根据原数 \(a[x]\) 在排序数组中的位置 \(P[a[x]]\)，分情况计算 \(T\) 的变化。减去原数对 \(T\) 的贡献，调整相关位置元素的贡献，再加上新数对 \(T\) 的贡献。

2. **作者：Nuyoah_awa（4星）**
    - **关键亮点**：将改数操作分为改大与改小两种情况进行讨论，推导出通用的通项公式，思路清晰，代码实现中对边界情况处理细致。
    - **个人心得**：提醒开long long和小心二分不要写挂。
    - **核心代码**：
```cpp
while (T --)
{
    int opt, x;
    cin >> opt >> x;
    opt = pos[opt];
    if (x == a[opt].val)
        cout << ans << "\n";
    if (x < a[opt].val)
    {
        // 改小了，往opt以左（1 ~ opt - 1）二分找 <= x的第一个数 
        if (a[opt - 1].val < x) 
        {
            int value = ans - (a[opt].val - x) * opt;
            cout << value << "\n";
            continue;
        }
        int l = 1, r = opt - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (a[mid].val >= x) 
                r = mid;
            else 
                l = mid + 1; 
        } 
        int value = ans + (s[opt - 1] - s[l - 1]);
        value = value - a[opt].val * opt + x * l;
        cout << value << "\n";
    }
    if (x > a[opt].val)
    {
        // 改大了，往opt以右（opt + 1 ~ n）二分找 < x 的最后一个数 
        if (x < a[opt + 1].val) 
        {
            int value = ans + (x - a[opt].val) * opt;
            cout << value << "\n";
            continue;
        }
        int l = opt + 1, r = n;
        while (l < r) 
        {
            int mid = (l + r + 1) / 2;
            if (a[mid].val < x) 
                l = mid;
            else 
                r = mid - 1; 
        } 
        int value = ans - (s[l] - s[opt + 1 - 1]);
        value = value - a[opt].val * opt + x * l;
        cout << value << "\n";
    }
}
```
    - **核心思想**：先预处理出原数组的答案 \(ans1\) 和每个数的排名。对于每次查询，根据改大或改小的情况，二分找到新的排名，利用通项公式计算答案。

3. **作者：Timmy_ （4星）**
    - **关键亮点**：先给出暴力解法，再通过分析修改值后出现的三种情况进行优化，思路循序渐进，代码简洁易懂。
    - **核心代码**：
```cpp
for(i=1; i<=q; i++)
{
    long long u,v;
    cin>>u>>v;
    u=at[u];
    long long pos=lower_bound(a+1,a+n+1,v)-a;
    long long temp=ans;
    if(pos>u)
    {
        temp-=a[u]*u;
        temp-=pre[pos-1]-pre[u];
        temp+=v*(pos-1);
    }
    if(pos==u)
    {
        temp-=a[u]*u;
        temp+=v*pos;
    }
    if(pos<u)
    {
        temp-=a[u]*u;
        temp+=pre[u-1]-pre[pos-1];
        temp+=v*(pos);
    }
    cout<<temp<<endl;
} 
```
    - **核心思想**：通过二分找到修改值在排序数组中的位置 \(pos\)，根据 \(pos\) 与原位置 \(u\) 的关系分三种情况计算答案，利用前缀和优化计算过程。

### 最优关键思路或技巧
1. **排序 + 二分 + 前缀和**：先对原数组排序得到最大值 \(T\)，利用二分查找新值在排序数组中的位置，通过前缀和快速计算因修改值导致的 \(T\) 的变化。
2. **分类讨论**：根据修改值与原值的大小关系，分情况讨论计算 \(T\) 的变化，使问题解决更有条理。

### 可拓展思路
同类型题可拓展到其他涉及数组元素修改并求最值的场景，类似算法套路是先确定最优排序方式，再通过数据结构（如前缀和数组）和查找算法（如二分查找）高效处理修改操作。

### 洛谷相似题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：通过归并排序求逆序对数量，涉及数组排序和对数组元素关系的处理。
2. [P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)：需要对三维数据进行排序和处理，与本题类似地运用排序和数据结构优化。
3. [P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617)：涉及对序列的动态修改和查询，可类比本题对数组元素修改并查询结果的思路。 

---
处理用时：41.57秒
# 题目信息

# 虚人「无」

## 题目背景

一点也不美丽的不死鸟。

那双锐爪，沾染了无辜的鲜血。

## 题目描述

给定二元序列 $\{(v_i,c_i)\}$ 和一棵以 $1$ 为根的有根树。第 $i$ 个点的点权是 $(v_i,c_i)$。

- 定义一个非根节点的权值为其子树内的 $c$ 的积乘上其子树补的 $v$ 的积。
- 定义一个根节点的权值为其子树内的 $c$ 的积。

形式化的讲，若 $u$ 不为根节点，则 $u$ 的权值 $f_u$ 为：

$$f_u=\prod\limits_{v\in \operatorname{substree}(u)} c_v\times \prod\limits_{v\notin \operatorname{substree}(u)} v_v$$

否则，其权值 $f_u$ 为：

$$f_u=\prod\limits_{v=1}^n c_v$$

试求整棵树**所有节点的权值之和**，答案对 $m$ 取模。请注意：**保证 $\bm m$ 是质数**。




## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/olehwn2w.png)

（图片有误，应该交换 $v,c$ 的权值。）

### 数据范围及约定

对于 $100\%$ 的数据，满足 $1\le n\leq 3\times 10^5$，$1\leq v_i,c_i,m\leq 10^9$。


## 样例 #1

### 输入

```
3 998244853
1 2
1 3
2 1 2
1 2 2```

### 输出

```
10```

## 样例 #2

### 输入

```
5 998244353
1 2
1 3
1 4
4 5
5 5 5 2 3
6 6 1 5 3```

### 输出

```
4656```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效计算有根树各节点权值之和并对质数模数取模展开。核心难点在于处理子树内 \( c \) 的积与子树补的 \( v \) 的积，同时要考虑模数与数据的关系，避免逆元不存在的情况。
 - **思路与算法要点**：
    - **基于DFS序的方法**：多数题解利用DFS序将树映射到序列，使子树对应连续区间。通过维护 \( c \) 和 \( v \) 的相关乘积（如前缀积、后缀积或区间积）来计算节点权值。
    - **逆元法**：部分题解提到用逆元求解，但因模数与 \( c_i \)、\( v_i \) 不一定互质，逆元可能不存在，此方法有局限性。
 - **质量评估**：多数题解思路较清晰，但在代码可读性和优化程度上有差异。

### 所选题解
#### 作者：Flanksy (5星)
 - **关键亮点**：提供多种解法，从逆元法分析其局限性，到线段树解法，再优化为前缀积和后缀积解法，思路清晰且全面，代码注释详细，可读性高。
 - **核心代码（前缀积 & 后缀积解法）**：
```cpp
// 省略头文件及部分变量定义
void dfs(int x, int las) {
    w[x] = 1, dfn[x] = ++pos, ex[pos] = x;
    for (int i : e[x]) if (i!= las) dfs(i, x), w[x] += w[i];
}
void build(int u, int l, int r) {
    s[u].l = l, s[u].r = r;
    if (l == r) return s[u].w = c[ex[l]], mul[l] = v[ex[l]], void();
    build(u * 2, l, (l + r) / 2), build(u * 2 + 1, (l + r) / 2 + 1, r);
    s[u].w = 1ll * s[u * 2].w * s[u * 2 + 1].w % mod;
}
int query(int u, int l, int r) {
    if (s[u].l > r || s[u].r < l) return 1;
    if (s[u].l >= l && s[u].r <= r) return s[u].w;
    return 1ll * query(u * 2, l, r) * query(u * 2 + 1, l, r) % mod;
}
int main() {
    scanf("%d%d", &n, &mod);
    // 读入边
    for (int i = 1; i <= n; i++) scanf("%d", &c[i]);
    for (int i = 1; i <= n; i++) scanf("%d", &v[i]);
    dfs(1, 0), build(1, 1, n), ans = s[1].w;
    pre[0] = 1, suf[n + 1] = 1;
    for (int i = 1; i <= n; i++) pre[i] = 1ll * mul[i] * pre[i - 1] % mod;
    for (int i = n; i >= 1; i--) suf[i] = 1ll * mul[i] * suf[i + 1] % mod;
    for (int i = 2; i <= n; i++) {
        int lot = pre[dfn[i] - 1];
        int son = query(1, dfn[i], dfn[i] + w[i] - 1);
        int rot = suf[dfn[i] + w[i]];
        ans += 1ll * lot * rot % mod * son % mod;
    }
    ans %= mod;
    printf("%lld\n", ans);
    return 0;
}
```
 - **核心实现思想**：先用DFS序确定每个节点在序列中的位置及子树大小。通过线段树维护 \( c \) 的区间乘积，同时计算 \( v \) 的前缀积和后缀积。遍历非根节点时，利用这些乘积计算节点权值，最后累加所有节点权值并取模。

#### 作者：0zhouyq (4星)
 - **关键亮点**：提出在模数为质数时用逆元的解法，并考虑到逆元不存在时对 \( m \) 的每个质因子分别统计的拓展思路，代码逻辑清晰。
 - **核心代码**：
```cpp
// 省略头文件及部分变量定义
void dfs(ll h, ll fa) {
    while (v[h] % m == 0) {
        mod[h]++;
        v[h] /= m;
    }
    for (ll i = home[h]; i; i = e[i].next) {
        ll t = e[i].to;
        if (t == fa) continue;
        dfs(t, h);
        c[h] = c[h] * c[t] % m;
        v[h] = v[h] * v[t];
        mod[h] += mod[t];
        while (v[h] && v[h] % m == 0) {
            mod[h]++;
            v[h] /= m;
        }
        v[h] %= m;
    }
}
void exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) x = 1, y = 0;
    else {
        exgcd(b, a % b, y, x);
        y -= a / b * x;
    }
}
int main() {
    scanf("%lld %lld", &n, &m);
    // 读入边
    for (ll i = 1; i <= n; i++) {
        scanf("%lld", &c[i]);
        c[i] %= m;
    }
    for (ll j = 1; j <= n; j++) {
        scanf("%lld", &v[j]);
    }
    dfs(1, -1);
    ll vsum = v[1];
    ll ans = c[1] % m;
    for (ll i = 2; i <= n; i++) {
        if (mod[1] > mod[i]) continue;
        ll x = 0, y = 0;
        exgcd(v[i], m, x, y);
        x = (x % m + m) % m;
        ans = (ans + c[i] * vsum % m * x % m) % m;
    }
    printf("%lld", ans);
    return 0;
}
```
 - **核心实现思想**：通过DFS预处理出每个节点子树内 \( c \) 的积 \( c[i] \) 、子树内 \( v \) 除去 \( m \) 因子后的积 \( v[i] \) 以及子树内 \( v \) 中 \( m \) 因子的个数 \( mod[i] \) 。统计答案时，对于非根节点，若其 \( mod[i] \) 不小于根节点的 \( mod[1] \) ，则计算其权值（通过求 \( v[i] \) 的逆元）并累加。

#### 作者：翟翟 (4星)
 - **关键亮点**：思路简洁明了，利用DFS序、前缀积和后缀积直接计算节点权值，时间复杂度为 \( \mathcal{O}(n) \) ，代码简洁高效。
 - **核心代码**：
```cpp
// 省略头文件及部分变量定义
void dfs(int u, int fa, const int mod) {
    dx[++cnt] = u; w[dx[i]] = i;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v == fa) continue;
        dfs(v, u, mod);
        zs[u] = 1ll * zs[u] * zs[v] % mod;
        sz[u] += sz[v];
    }
}
void prez(const int mod) {
    qz[0] = hz[n + 1] = 1;
    for (int i = 1; i <= n; ++i)
        qz[i] = 1ll * qz[i - 1] * v[dx[i]] % mod;
    for (int i = n; i; --i)
        hz[i] = 1ll * hz[i + 1] * v[dx[i]] % mod;
    for (int i = 1; i <= n; ++i)
        ans = (ans + 1ll * zs[i] * qz[w[i] - 1] % mod * hz[w[i] + sz[i]]) % mod;
}
int main() {
    scanf("%d%d", &n, &m);
    // 读入边
    for (int i = 1; i <= n; ++i) {
        scanf("%d", c + i);
        zs[i] = c[i];
        sz[i] = 1;
    }
    for (int i = 1; i <= n; ++i)
        scanf("%d", v + i);
    dfs(1, 0, m);
    prez(m);
    printf("%d\n", ans);
    return 0;
}
```
 - **核心实现思想**：通过DFS获取每个节点在DFS序中的位置、子树大小以及子树内 \( c \) 的乘积。然后计算DFS序中 \( v \) 的前缀积和后缀积，根据公式直接计算每个节点权值并累加得到答案。

### 最优关键思路或技巧
 - **DFS序的应用**：将树结构转化为线性序列，使子树对应连续区间，便于后续利用数据结构（如线段树）或简单数组操作（前缀积、后缀积）进行计算。
 - **避免逆元风险**：鉴于模数与数据不一定互质，采用线段树维护区间积或前缀积、后缀积的方式，绕开逆元不存在的问题。

### 可拓展之处
此类题目可拓展到更复杂的树结构或权值定义，如带边权的树、多层嵌套的权值计算等。类似算法套路包括利用树的特殊序（如DFS序、BFS序）将树问题转化为序列问题，结合数据结构（线段树、树状数组等）优化计算。

### 相似知识点洛谷题目
 - [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)：线段树维护区间乘积的模板题，可巩固线段树在区间积计算方面的应用。
 - [P1314 聪明的质检员](https://www.luogu.com.cn/problem/P1314)：结合二分查找和树状数组或线段树，与本题类似，需利用数据结构处理区间信息。
 - [P2572 [SCOI2010]序列操作](https://www.luogu.com.cn/problem/P2572)：涉及对序列的多种操作，可锻炼对数据结构综合应用的能力，与本题利用数据结构处理树转化后的序列有相似之处。

### 个人心得摘录与总结
 - Flanksy提到使用逆元求解需模数与任意 \( c \)、\( v \) 互质，即使模数为质数也可能构造出不存在逆元的情况，提醒在使用逆元时要关注条件。同时指出本题ACM赛制下多次WA反馈数据点可能不同，对查错不友好，调试时需注意。 

---
处理用时：60.00秒
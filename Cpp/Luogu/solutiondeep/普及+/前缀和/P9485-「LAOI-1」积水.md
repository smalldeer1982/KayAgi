# 题目信息

# 「LAOI-1」积水

## 题目描述



地表坑洼不平，每当暴雨来临地面上都会有一个个水洼。   
又有一场暴雨即将来临，你决定改造地面来减少积水。     
地面可抽象为一个长度为 $n$ 的正整数序列 $a$，其中 $a_i$ 表示当地的海拔高度。       
下暴雨时将会汇聚在低洼处无法向两侧流走，比如一个序列 $a=[3,1,5,1,2,3]$。     
在下雨后的积水如图所示（有 $5$ 格积水）：

![](https://cdn.luogu.com.cn/upload/image_hosting/79on2oe3.png)

由于人手不足，现在只来得及改变一个地方的海拔高度为任意正整数。

问改造后积水最少有几格。






## 说明/提示

对于前 $5\%$ 的数据，$1\le n\le 5$。       
对于前 $20\%$ 的数据，$1\le \sum  n\le 550$，$1\le a_i\le 500$。     
对于前 $35\%$ 的数据，$1\le \sum n\le 5050$，$1\le a_i\le 5000$。    
对于前 $50\%$ 的数据，$1\le \sum n\le 5050$，$1\le a_i \le 10^9$。  
对于 $100\%$ 的数据，$1\le n,\sum n\le 10^6$，$1\le a_i\le 10^9$。

保证 $1\le T\le 10^4$。

## 样例 #1

### 输入

```
3
6
3 2 1 1 2 3
6
1 1 4 5 1 4
6
1 9 1 9 8 10```

### 输出

```
2
0
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算积水以及通过改变一处海拔高度来减少积水的问题展开。思路上，都先求出初始积水情况，再分别考虑抬高或降低某点海拔对积水的影响。算法要点包括利用前缀/后缀最大值、单调栈、RMQ（Range Minimum/Maximum Query）问题的相关解法（如ST表、线段树）等。解决难点在于准确分析改变海拔后积水变化情况，避免遗漏或错误计算。

从质量上看，EdenSky和CZ_7的题解思路清晰，代码可读性较好，对关键步骤有详细解释，优化程度也较高，可评为5星；佬头的题解思路较清晰，但代码实现相对复杂，可读性稍逊，可评为4星。

### 所选的题解
1. **EdenSky（5星）**
    - **关键亮点**：详细阐述用RMQ问题求解过程，通过DP求出每个位置左右峰的高度，进而得到积水高度。对于改变海拔的两种情况（存在积水和是峰）分别深入分析，利用ST表解决降低峰高度时新峰出现的复杂判断。
    - **个人心得**：提到 $\mathcal{O}(\sum n+\log \sum n)$ 的复杂度通过大数据较危险需卡常，以及若只T了部分数据可能是 `memset()` 的问题。
    - **核心代码片段**：
```cpp
// 求l和r数组
l[0]=0,l[1]=0;
for(register int i=2;i<=n;i++)
    if(a[i-1]>=a[l[i-1]]) l[i]=i-1;
    else l[i]=l[i-1];
r[n+1]=0,r[n]=0;
for(register int i=n-1;i>=1;i--)
    if(a[i+1]>=a[r[i+1]]) r[i]=i+1;
    else r[i]=r[i+1];
// 求积水相关数组
s=0;
for(register int i=1;i<=n;i++){
    p[i]=min(a[l[i]],a[r[i]]);
    if(p[i]-a[i]>0) w[i]=p[i]-a[i];
    else w[i]=0;
    s+=w[i];
}
// 处理降低峰高度减少积水的情况
for(register int i=1;i<=n;i++){
    if(p[i]>=a[i]){
        to=max(a[l[l[i]]],query(l[i]+1,i-1));
        v[l[i]]+=(p[i]-max(to,a[i])>0?
            p[i]-max(to,a[i]):0);
        to=max(a[r[r[i]]],query(i+1,r[i]-1));
        v[r[i]]+=(p[i]-max(to,a[i])>0?
            p[i]-max(to,a[i]):0);
    }
}
// 求最终答案
ans=s;
for(register int i=1;i<=n;i++)
    ans=min(ans,s-w[i]),
    ans=min(ans,s-v[i]);
```
核心实现思想：先通过DP求出每个位置左右两侧的峰位置，进而得到积水相关信息。对于降低峰高度减少积水的情况，利用ST表查询区间最大值来准确计算可减少的积水格数，最后综合两种改变海拔的情况得出最少积水格数。

2. **CZ_7（5星）**
    - **关键亮点**：不用数据结构，通过前缀/后缀最大值数组计算积水，思路简洁易懂。对于改变海拔减少积水，详细分析抬高和降低高度两种方式，特别是降低高度时，通过巧妙的条件判断和循环处理，保证复杂度为 $O(n)$。
    - **个人心得**：纪念在机房调了2h半的题目。
    - **核心代码片段**：
```cpp
// 计算前缀和后缀最大值
for(int i=1;i<=n;i++){
    maxl[i]=max(maxl[i-1],a[i]);
}
for(int i=n;i>=1;i--){
    maxr[i]=max(maxr[i+1],a[i]);
}
// 计算总积水和通过增高格子消除的水量
for(int i=1;i<=n;i++){
    ll t=min(maxl[i-1],maxr[i+1]);
    if(t>a[i]){
        sum+=t-a[i];
        cut=max(cut,t-a[i]);
    }
}
// 计算降低高度减少的积水
int l=1,r=2;
while(r<=n){
    ll low=maxl[l-1],cnt=0;
    while(a[r]<a[l]){
        ll w=min(maxl[r-1],maxr[r+1]);
        if(w>max(low,a[r]))cnt+=w-max(low,a[r]);
        low=max(low,a[r]);
        r++;
        if(r==n+1)break;
    }
    cut=max(cut,cnt);
    l=r;r++;
}
r=n,l=n-1;
while(l>=1){
    ll low=maxr[r+1],cnt=0;
    while(a[l]<a[r]){
        ll w=min(maxl[l-1],maxr[l+1]);
        if(w>max(low,a[l]))cnt+=w-max(low,a[l]);
        low=max(low,a[l]);
        l--;
        if(l==0)break;
    }
    cut=max(cut,cnt);
    r=l;l--;
}
// 输出答案
cout<<sum-cut<<'\n';
```
核心实现思想：先利用前缀和后缀最大值数组计算每个位置积水情况以及通过抬高某点高度可减少的积水量。对于降低高度减少积水，通过双指针移动，根据条件判断和更新最低高度，计算从某点开始能流出的水量，最终得出最少积水格数。

3. **佬头（4星）**
    - **关键亮点**：以计算总积水量的思路为基础，考虑抬高和降低海拔两种方式减少积水。在降低海拔时，对可降低海拔的点及减少积水量的计算有清晰的逻辑。
    - **核心代码片段**：
```cpp
// 计算总积水量和最多可减少的积水量
for(int l = 1, r; l < n; l = r + 1){
    minn = a[r = l], sum = 0;
    while(r < n && a[r + 1] < a[l]) ++ r;
    if(r < n){
        for(int i = l + 1; i <= r; ++ i){
            tot += a[l] - a[i];
            if(a[i] < minn) minn = a[i];
            if(a[i] > maxx) maxx = a[i];
            sum += a[l] - maxx;
        }
        if(a[l] - minn > ans) ans = a[l] - minn;
        if(a[l] > maxx) maxx = a[l];
    }
    else{
        int maxid = n, i;
        for(i = n - 1; i > l; i --)
            if(a[i] > a[maxid]){
                pre[i] = maxid;
                maxid = i;
            }
        for(i = l + 1; i < maxid; ++ i){
            if(a[i] > maxx) maxx = a[i];
            if(a[maxid] > maxx) sum += a[maxid] - maxx;
        }
        for(i = l + 1; i < n; i = maxid + 1, maxid = pre[maxid]){
            minn = a[i];
            while(i <= maxid){
                if(a[i] < minn) minn = a[i];
                tot += a[maxid] - a[i ++];
            }
            if(a[maxid] - minn > ans) ans = a[maxid] - minn;
        }
    }
    if(sum > ans) ans = sum;
}
```
核心实现思想：通过遍历序列，以某点为积水边界计算积水总量，并在过程中更新抬高某点可减少的最大积水量。对于右侧无更高点的情况，通过后缀最大值下标辅助计算积水和可减少积水量。

### 最优关键思路或技巧
1. **利用前缀/后缀最大值**：如CZ_7的题解，通过维护前缀和后缀最大值数组，简洁地计算每个位置的积水情况，这是解决积水问题的基础思路。
2. **分析改变海拔的不同情况**：各题解都对抬高和降低海拔分别分析，抬高时使海拔与水面平行，降低时考虑峰的特殊情况及降低的合适高度，准确计算积水变化。
3. **处理复杂情况的技巧**：如EdenSky利用ST表解决降低峰高度时新峰出现的复杂判断，保证计算的准确性。

### 可拓展思路
同类型题可拓展到更多地形变化及限制条件下的积水问题，类似算法套路包括利用单调栈、单调队列、RMQ等数据结构和算法优化解决涉及区间最值、积水变化等问题。

### 相似知识点洛谷题目
1. **P1318 积水面积**：与本题计算积水相关，可作为基础练习。
2. **P3865 【模板】ST表**：考察RMQ问题中ST表的应用，与EdenSky题解中知识点相关。
3. **P4777 【模板】线段树 1**：线段树基础题，与__LYY_p题解中利用线段树维护区间最大值知识点相关。 

---
处理用时：54.51秒
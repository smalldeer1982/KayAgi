# 题目信息

# 「MXOI Round 1」城市

## 题目描述

小 C 是 F 国的总统，尽管这个国家仅存在于网络游戏中，但他确实是这个国家的总统。

F 国由 $n$ 个城市构成，这 $n$ 个城市之间由 $n-1$ 条双向道路互相连接。保证从任意一个城市出发，都能通过这 $n-1$ 条双向道路，到达任意一个城市。

当然，通过这些双向道路是要收费的。通过第 $i$ 条双向道路，需要花费 $c_i$ 元。我们称 $c_i$ 为第 $i$ 条双向道路的费用。

我们定义 $cost(x,y)$ 表示从城市 $x$ 到城市 $y$ 的简单路径上，所有经过的双向道路的费用之和。特殊地，当 $x=y$ 时，$cost(x,y)=0$。

为了促进 F 国发展，小 C 新建了一个城市 $n+1$。现在他需要再新建一条双向道路，使得城市 $n+1$ 也可以通过这 $n$ 条双向道路到达任意一个城市。

他共有 $q$ 个新建道路的方案，每个方案会给定两个参数 $k_i,w_i$；对于每一个方案，你需要求出在新建一条连接城市 $k_i$ 和城市 $n+1$ 且费用为 $w_i$ 的双向道路后，所有 $cost(i,j)$ 之和，即 $\sum\limits_{i=1}^{n+1} \sum\limits_{j=1}^{n+1} cost(i,j)$。

由于答案可能很大，所以你只需要输出答案对 $998244353$ 取模的结果。

**方案之间相互独立**，也就是说所有方案不会影响现有的道路，这些方案不会真正被施行。

## 说明/提示

#### 【样例解释 #1】

在新建一条连接城市 $1$ 和城市 $5$ 且费用为 $2$ 的双向道路后，F 国的道路如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/j871257i.png)

例如，此时 $cost(4,5)=9$，$cost(1,3)=5$。

容易求得此时 $\sum\limits_{i=1}^{n+1} \sum\limits_{j=1}^{n+1} cost(i,j)=100$。

#### 【样例 #3】

见附加文件中的 `city/city3.in` 与 `city/city3.ans`。

该样例满足测试点 $4$ 的限制。

#### 【样例 #4】

见附加文件中的 `city/city4.in` 与 `city/city4.ans`。

该样例满足测试点 $11$ 的限制。

#### 【样例 #5】

见附加文件中的 `city/city5.in` 与 `city/city5.ans`。

该样例满足测试点 $14$ 的限制。

#### 【样例 #6】

见附加文件中的 `city/city6.in` 与 `city/city6.ans`。

该样例满足测试点 $20$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$2 \le n \le 2\times10^5$，$1 \le q \le 2\times10^5$，$1 \le u_i,v_i,k_i \le n$，$1 \le c_i,w_i \le 10^6$，保证从任意一个城市出发，都能通过原本存在的 $n-1$ 条双向道路，到达任意一个城市。

|测试点编号|$n \le$|$q \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim3$|$80$|$80$|无|
|$4\sim7$|$5000$|$5000$|无|
|$8\sim10$|$5000$|$2\times10^5$|无|
|$11\sim13$|$2\times10^5$|$2\times10^5$|A|
|$14\sim16$|$2\times10^5$|$2\times10^5$|B|
|$17\sim20$|$2\times10^5$|$2\times10^5$|无|

特殊性质 A：保证对于所有的 $1 \le i \lt n$，都有 $u_i=i,v_i=i+1$。

特殊性质 B：保证对于所有的 $1 \le i \le q$，都有 $k_i=1$。

## 样例 #1

### 输入

```
4 2
2 1 3
3 2 2
4 2 4
1 2
2 2```

### 输出

```
100
88```

## 样例 #2

### 输入

```
9 5
2 3 6
6 1 4
5 2 10
2 4 1
9 1 9
2 8 3
1 2 3
7 4 8
4 9
7 3
6 1
9 7
2 1
```

### 输出

```
1050
1054
970
1148
896```

# AI分析结果

• 综合分析与结论：
    - 这些题解主要围绕树形结构展开，核心思路是通过预处理减少询问时的计算量，以满足 $O(n + q)$ 的时间复杂度要求。
    - 算法要点多涉及树的基本概念，如子树大小、节点距离和等，通过深度优先搜索（DFS）实现信息的传递与状态转移。
    - 解决难点在于如何高效地计算每条边或每个点对答案的贡献，以及在换根过程中准确更新节点的相关信息。

  1. **作者Coffee_zzz（5星）**
    - **关键亮点**：对不同测试点进行针对性分析，从暴力求解逐步优化到利用前缀和、换根DP等高效算法，思路清晰，代码实现完整且注释详细。
    - **个人心得**：无
    - **核心代码片段**：
```c++
void init(int u,int fat){
    siz[u]=1,fa[u]=fat;
    for(int i=head[u];i;i=nxt[i]){
        int v=to[i];
        if(v==fa[u]) continue;
        init(v,u);
        siz[u]=siz[u]+siz[v];
    }
}
void dfs(int u){
    for(int i=head[u];i;i=nxt[i]){
        int v=to[i];
        if(v==fa[u]) continue;
        f[v]=1ll*(siz[v]+1)*(n-siz[v])%mod*c[i]*2%mod;
        g[v]=1ll*siz[v]*(n-siz[v]+1)%mod*c[i]*2%mod;
        sf[v]=(f[v]+sf[u])%mod;
        sg[v]=(g[v]+sg[u])%mod;
        sumg=(sumg+g[v])%mod;
        dfs(v);
    }
}
```
    - **核心实现思想**：`init`函数通过DFS预处理出每个节点的子树大小`siz`和父节点`fa`。`dfs`函数再次通过DFS，计算每个节点的相关贡献值`f`、`g`，并累计前缀和`sf`、`sg`以及所有边贡献和`sumg`。

  2. **作者iiiiiyang（5星）**
    - **关键亮点**：采用换根DP算法，利用两次DFS简洁高效地求解问题，代码简洁明了，对换根DP的原理阐述清晰，且提到了算法在效率上的优势。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
auto dfs1=[&](auto dfs1,int now,int father)->void
{
    siz[now]=1;
    for(auto [to,val]:G[now]) if(to!=father) dis[to]=Cadd(dis[now],val),dfs1(dfs1,to,now),siz[now]+=siz[to],Madd(f[1],dis[to]);
};
dfs1(dfs1,1,0);

auto dfs2=[&](auto dfs2,int now,int father)->void
{
    Madd(ans,f[now]);
    for(auto [to,val]:G[now]) if(to!=father) f[to]=Cadd(f[now],Cmul(val,((siz[1]-2*siz[to])%Mod+Mod)%Mod)),dfs2(dfs2,to,now);
};
dfs2(dfs2,1,0);
```
    - **核心实现思想**：`dfs1`函数通过DFS初始化子树大小`siz`，并计算根节点到其他节点的距离和`dis`，累计到`f[1]`。`dfs2`函数通过DFS进行换根操作，根据公式`f[v] = f[u] + w * (n - 2 * siz[v])`更新每个节点的`f`值，并累计答案`ans`。

  3. **作者Night_sea_64（4星）**
    - **关键亮点**：详细阐述换根DP的过程，结合样例图说明状态转移的原理，代码实现清晰，对取模的细节处理有特别说明，具有很好的参考价值。
    - **个人心得**：赛时因取模问题痛失40pts，强调取模细节的重要性。
    - **核心代码片段**：
```cpp
void dfs1(int x,int last)
{
    sz[x]=1;
    for(auto e:v[x])
        if(e.x!=last)
        {
            dfs1(e.x,x);
            d[x]=(d[x]+d[e.x]+sz[e.x]*e.w)%mod,sz[x]+=sz[e.x];
        }
}
void dfs2(int x,int last)
{
    for(auto e:v[x])
        if(e.x!=last)
        {
            d[e.x]=(d[x]+mod*10000+e.w*(n-2*sz[e.x]))%mod;
            dfs2(e.x,x);
        }
}
```
    - **核心实现思想**：`dfs1`函数通过DFS预处理出每个节点的子树大小`sz`和到当前点的距离和`d`。`dfs2`函数通过DFS进行换根操作，根据公式`d[e.x] = d[x] + (n - 2 * sz[e.x]) * e.w`更新每个节点的`d`值，注意取模时为防止负数加了`mod*10000`。

• 最优关键思路或技巧：
    - **换根DP**：通过两次DFS，第一次DFS计算以某节点为根时子树内的相关信息，第二次DFS利用第一次的结果，根据换根时节点距离和的变化规律进行状态转移，从而高效地求出每个节点到其他所有节点的距离和。
    - **边贡献分析**：考虑每条边对答案的贡献，通过计算边两侧子树大小的乘积乘以边权，得出边的贡献次数，进而求出不考虑新增节点时树中所有点对距离和。

• 同类型题或类似算法套路：
    - 此类题目通常围绕树形结构展开，常见套路是利用树的性质（如子树大小、深度等），通过DFS进行信息传递与状态转移。类似算法包括树形DP、换根DP等，用于解决树上路径、距离、最值等问题。

• 推荐题目：
    - [P3478 树上距离和](https://www.luogu.com.cn/problem/P3478)：经典的换根DP题目，要求计算树上每个点到其他所有点的距离和，与本题在算法运用上相似。
    - [P2986 [USACO10MAR]Great Cow Gathering G](https://www.luogu.com.cn/problem/P2986)：同样是树上距离和问题，通过换根DP求解，可加深对该算法的理解。
    - [P1395 会议](https://www.luogu.com.cn/problem/P1395)：也是基于树结构的问题，涉及到换根DP的应用，有助于巩固相关知识点。

• 个人心得摘录与总结：
    - **作者Night_sea_64**：赛时因未考虑取模再相减变负数的问题丢分，强调了在处理模运算时要特别注意可能出现负数的情况，需及时调整以保证结果正确。 

---
处理用时：57.03秒
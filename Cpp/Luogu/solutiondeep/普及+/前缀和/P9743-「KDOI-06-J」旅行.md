# 题目信息

# 「KDOI-06-J」旅行

## 题目描述

小 C 在 C 国旅行。

C 国有 $n\times m$ 个城市，可以看做 $n\times m$ 的网格。定义 $(i,j)$ 表示在网格中第 $i$ 行第 $j$ 列的城市。

该国有 $2$ 种交通系统：

* 对于所有 $1\leq i<n,1\leq j\leq m$，$(i,j)$ 到 $(i+1,j)$ 有一段由 L 公司修的单向铁路；
* 对于所有 $1\leq i\leq n,1\leq j<m$，$(i,j)$ 到 $(i,j+1)$ 有一段由 Z 公司修的单向铁路；

在每一个城市有一个售票口，$(i,j)$ 城市的售票口可以用 $a_{i,j}$ 元购买一张 L 公司的铁路票，$b_{i,j}$ 元购买一张 Z 公司的铁路票。当你拥有一个公司的一张铁路票时，你可以乘坐这个公司的任意一段铁路，并消耗掉这张铁路票。注意，一张铁路票可以且仅可以使用一次。

小 C 原来在城市 $(1,1)$。他想要在 C 国旅游，但是他不想浪费任何的钱（即，当他旅游完毕时手上不应该有多余的车票）。对于所有 $1\leq x\leq n,1\leq y\leq m$，求他花 $k$ 元钱并在城市 $(x,y)$ 结束旅行的方案数，对 $998\ 244\ 353$ 取模。

两种旅行方案不同，当且仅当小 C 经过的城市不同，或他在某一个城市购买的某家公司的铁路票数量不同。

## 说明/提示

**【样例解释 #1】**

到 $(3,1)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,1)$。

到 $(2,2)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(2,2)$。

到 $(3,2)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $2$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,2)$；乘坐 L 公司的铁路到 $(3,2)$。
* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；乘坐 L 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。
* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；乘坐 Z 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。

到 $(2,3)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $2$ 张 Z 公司的铁路票。在此之后，有 $3$ 种方案可以从 $(1,1)$ 乘坐两公司的铁路到 $(2,3)$。
* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票。在此之后，有 $2$ 种方案可以从 $(1,2)$ 乘坐两公司的铁路到 $(2,3)$。

**【样例 #2】**

见选手目录下的 `travel/travel2.in` 与 `travel/travel2.ans`。这个样例满足测试点 $7\sim 8$ 的条件限制。

**【样例 #3】**

见选手目录下的 `travel/travel3.in` 与 `travel/travel3.ans`。这个样例满足测试点 $11$ 的条件限制。

**【数据范围】**

对于所有数据保证：$1\leq n,m\leq45$，$1\leq k,a_{i,j},b_{i,j}\leq90$。

| 测试点编号 | $n,m$ | $k$ | $a_{i,j}$ | $b_{i,j}$ |
|:--:|:--:|:--:|:--:|:--:|
| $1\sim3$ | $\leq3$ | $\leq5$ | $=1$ | $=1$ |
| $4\sim6$ | $\leq10$ | $\leq10$ | $=1$ | $=40$ |
| $7\sim8$ | $\leq40$ | $\leq30$ | $=1$ | $=45$ |
| $9\sim10$ | $\leq15$ | $\leq15$ | $\leq15$ | $\leq15$ |
| $11$ | $\leq15$ | $\leq30$ | $\leq30$ | $\leq30$ |
| $12$ | $\leq20$ | $\leq40$ | $\leq40$ | $\leq40$ |
| $13\sim15$ | $\leq25$ | $\leq50$ | $\leq50$ | $\leq50$ |
| $16$ | $\leq30$ | $\leq60$ | $\leq60$ | $\leq60$ |
| $17$ | $\leq35$ | $\leq70$ | $\leq70$ | $\leq70$ |
| $18\sim19$ | $\leq40$ | $\leq80$ | $\leq80$ | $\leq80$ |
| $20$ | $\leq45$ | $\leq90$ | $\leq90$ | $\leq90$ |

## 样例 #1

### 输入

```
3 3 5
3 2 1
2 1 3
1 3 2
1 2 3
2 3 1
3 1 2```

### 输出

```
0 0 0
0 1 5
1 3 5```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解均采用动态规划思路。通过定义多维状态来记录旅行过程中的关键信息，如位置、花费、剩余车票数量等，根据不同决策（买票、移动）进行状态转移，从而计算出满足条件的方案数。
    - 算法要点：定义合适的DP状态，如dp[i][j][x][y][p]表示在点(i, j)，手里有x张向下的票，y张向右的票，总共花了p元钱的方案数量；考虑不同的转移情况，包括从上方或右方转移过来以及在当前点购买车票；注意避免重复计算，如同时购买两种车票的情况。
    - 解决难点：一是状态转移方程的推导，要准确考虑各种情况且避免重复；二是空间优化，由于数据范围限制，五维数组空间开不下，需用滚动数组优化空间；三是时间优化，如减少不必要的枚举，在循环枚举时加上条件限制，减少计算量。
    - 总体来看，各题解思路相近，主要区别在于代码实现细节、优化程度以及思路和代码的清晰程度。

• 所选的题解：
  - 作者：uid_310801 (5星)
    - 关键亮点：思路清晰，先给出朴素DP思路及复杂度分析，再提出类似二维前缀和容斥的优化转移方式，有效降低复杂度；代码实现中使用滚动数组优化空间，还给出减少不必要转移的优化思路，整体质量高。
    - 重点代码核心实现思想：通过滚动数组f[2][N][K][N][N]记录状态，在循环中根据容斥原理计算转移值，更新状态数组，最后根据f数组得出答案。
```cpp
f[1][1][0][0][0]=1;
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(i!=1)	f[i&1][j][0][0][0]=0;
        for(int c=1;c<=k;c++){
            for(int la=0;la+i<=n;la++){
                for(int lb=0;lb+j<=m;lb++){
                    ll res=mod;
                    if(la!=0&&c>=a[i][j])	res+=f[i&1][j][c-a[i][j]][la-1][lb];
                    if(lb!=0&&c>=b[i][j])	res+=f[i&1][j][c-b[i][j]][la][lb-1];
                    if(la!=0&&lb!=0&&c>=a[i][j]+b[i][j])	res-=f[i&1][j][c-a[i][j]-b[i][j]][la-1][lb-1];
                    if(i!=1)	res+=f[(i-1)&1][j][c][la+1][lb];
                    if(j!=1)	res+=f[i&1][j-1][c][la][lb+1];
                    f[i&1][j][c][la][lb]=res%mod;
                    if(c==k&&la==0&&lb==0)	ans[i][j]=res%mod;
                }
            }
        }
    }
}
```
  - 作者：_O_v_O_ (4星)
    - 关键亮点：思路阐述详细，先给出朴素的状态转移方程及复杂度分析，再提出利用二维前缀和简化转移方程，最后使用滚动数组优化空间，代码注释清晰，常数小。
    - 重点代码核心实现思想：与uid_310801类似，通过滚动数组dp[2][N][K][N][N]记录状态，依据简化后的转移方程在循环中更新状态值，最后输出答案。
```cpp
dp[1][1][0][0][0]=1;
for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
    if(i!=1) dp[i&1][j][0][0][0]=0;
    for(int c=1;c<=k;c++){
        for(int x=0;i+x<=n;x++) for(int y=0;j+y<=m;y++){
            int res=mod;
            if(x!=0&&c>=a[i][j]) res+=dp[i&1][j][c-a[i][j]][x-1][y];
            if(y!=0&&c>=b[i][j]) res+=dp[i&1][j][c-b[i][j]][x][y-1];
            if(x!=0&&y!=0&&c>=a[i][j]+b[i][j]) res-=dp[i&1][j][c-a[i][j]-b[i][j]][x-1][y-1];
            if(i!=1) res+=dp[(i-1)&1][j][c][x+1][y];
            if(j!=1) res+=dp[i&1][j-1][c][x][y+1];
            dp[i&1][j][c][x][y]=res%mod;
            if(c==k&&x==0&&y==0) ans[i][j]=res%mod;
        }
    }
}
```
  - 作者：Eddie08012025 (4星)
    - 关键亮点：思路清晰，先给出基本思路及转移方程，再从空间和时间两方面进行优化分析，代码结构清晰，注释详细。
    - 重点代码核心实现思想：利用滚动数组dp[2][46][46][46][91]记录状态，通过不同的循环嵌套，依据转移方程分别处理购买车票和乘坐铁路的转移情况，最后输出答案。
```cpp
dp[1][1][0][0][k]=1;
for(int i=1;i<=n;i++){
    c^=1;
    memset(dp[c^1],0,sizeof(dp[c^1]));
    for(int j=1;j<=m;j++){
        ans[i][j]=dp[c][j][0][0][0];
        for(int u=k;u>=a[i][j];u--){
            for(int x=0;x<=n-i;x++){
                for(int y=0;y<=m-j;y++){
                    int *p=&dp[c][j][x+1][y][u-a[i][j]];
                    *p+=dp[c][j][x][y][u];
                    if(*p>mod)*p-=mod;
                }
            }
        }
        for(int u=k;u>=b[i][j];u--){
            for(int x=0;x<=n-i;x++){
                for(int y=0;y<=m-j;y++){
                    int *p=&dp[c][j][x][y+1][u-b[i][j]];
                    *p+=dp[c][j][x][y][u];
                    if(*p>mod)*p-=mod;
                }
            }
        }
        if(i<n)
            for(int u=0;u<=k;u++){
                for(int x=1;x<=n-i;x++){
                    for(int y=0;y<=m-j;y++){
                        int *p=&dp[(c^1)][j][x-1][y][u];
                        *p+=dp[c][j][x][y][u];
                        if(*p>mod)*p-=mod;
                    }
                }
            }
        if(j<m)
            for(int u=0;u<=k;u++){
                for(int x=0;x<=n-i;x++){
                    for(int y=1;y<=m-j;y++){
                        int *p=&dp[c][j+1][x][y-1][u];
                        *p+=dp[c][j][x][y][u];
                        if(*p>mod)*p-=mod;
                    }
                }
            }
    }
}
```

• 最优关键思路或技巧：
    - **状态定义**：合理定义多维状态，全面记录旅行中的位置、花费、剩余车票等信息，为准确的状态转移提供基础。
    - **容斥原理优化转移**：如uid_310801和_O_v_O_通过类似二维前缀和的容斥方式简化转移方程，减少枚举量，降低时间复杂度。
    - **滚动数组优化空间**：利用滚动数组，因为每次转移只涉及当前行和上一行的状态，从而将空间复杂度从O(n^5)降低到O(n^4) 。
    - **减少不必要枚举**：在循环枚举时，根据实际情况添加条件限制，如Eddie08012025提到在(i, j)时最多还会用到n - i张L公司的票与m - j张Z公司的票，减少无效计算。

• 可拓展之处：
同类型题或类似算法套路：此类题目属于网格上的动态规划问题，通常涉及在网格中移动并根据不同条件进行决策。类似套路包括定义合适的状态以涵盖所有关键信息，考虑不同决策对应的状态转移，注意避免重复计算，以及根据数据范围进行空间和时间优化。例如，在网格上的资源收集问题，每个格子有不同资源，收集资源有花费和限制，从起点到终点收集特定资源量的方案数等。

• 推荐题目：
    - [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：经典的网格路径动态规划问题，涉及在网格中移动，考虑障碍物限制，与本题在网格上的状态转移思路类似。
    - [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)：同样是网格状的动态规划，不过是三角形网格，通过不同方向的转移来求解最优值，与本题在状态转移的思考方式上有相似处。
    - [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)：虽然不是网格形式，但在区间动态规划上有相似之处，定义状态记录区间信息，通过不同决策进行状态转移，并且也需要考虑优化问题。

• 个人心得：
    - 作者紊莫提到取模操作较慢，建议优化取模方式，如使用自定义的add函数替代频繁的取模运算；避免使用long long以减少空间占用和运算时间；不用memset，直接按需清空使用过的数组部分，这些都是在代码实现中优化常数的有效技巧。 

---
处理用时：61.85秒
# 题目信息

# 「KDOI-06-S」消除序列

## 题目描述

小 M 有一个长度为 $n$ 的序列 $v_1,v_2,\ldots,v_n$，初始时，所有元素的值均为 $1$。

你有 $3$ 种作用在这个序列上的操作：

1. 选择一个下标 $i$（$1\le i\le n$），并且将 $v_1,v_2,\ldots,v_i$ 的值全部设为 $0$，这种操作的代价是 $a_i$；
2. 选择一个下标 $i$（$1\le i\le n$），并且将 $v_i$ 的值设为 $0$，这种操作的代价是 $b_i$；
3. 选择一个下标 $i$（$1\le i\le n$），并且将 $v_i$ 的值设为 $1$，这种操作的代价是 $c_i$。

现在有 $q$ 次询问，每次询问中给定一个集合 $P$，你希望进行若干次操作（可能为 $0$），使得：序列 $v$ 中下标位于该集合的元素的值为 $1$，其余位置的值为 $0$。**形式化地说，对于任意 $\bm{1\le i\le n}$，若 $\bm{i\in P}$，则 $\bm{v_i=1}$，否则 $\bm{v_i=0}$。** 并且，你需要最小化这次询问中所有操作的总代价。

注意，询问是相互独立的，也就是说，每次询问结束后，序列 $v$ 将会回到初始状态，即所有元素的值全都变为 $1$。

## 说明/提示

**【样例解释 #1】**

对于第一次询问，可以按顺序执行如下操作：

+ 在 $i=4$ 处执行操作 $1$，在这之后，序列 $v$ 变为 $[0,0,0,0,1]$，代价为 $0$；
+ 在 $i=4$ 处执行操作 $3$，在这之后，序列 $v$ 变为 $[0,0,0,1,1]$，代价为 $2$；
+ 在 $i=5$ 处执行操作 $2$，在这之后，序列 $v$ 变为 $[0,0,0,1,0]$，代价为 $5$。

所以总代价为 $0+2+5=7$，可以证明，不存在更小的总代价。

**【样例解释 #3】**

对于这个样例中的唯一一次询问，可以选择在 $i=10$ 处执行操作 $1$，总代价为 $a_{10}=7$。

**【样例 #4】**

见选手目录下的 `reserve/reserve4.in` 与 `reserve/reserve4.ans`。

**【样例 #5】**

见选手目录下的 `reserve/reserve5.in` 与 `reserve/reserve5.ans`。

这个样例满足测试点 $8\sim 11$ 的条件限制。

**【样例 #6】**

见选手目录下的 `reserve/reserve6.in` 与 `reserve/reserve6.ans`。

这个样例满足测试点 $14\sim 15$ 的条件限制。

**【样例 #7】**

见选手目录下的 `reserve/reserve7.in` 与 `reserve/reserve7.ans`。

这个样例满足测试点 $16$ 的条件限制。

**【样例 #8】**

见选手目录下的 `reserve/reserve8.in` 与 `reserve/reserve8.ans`。

这个样例满足测试点 $17\sim 20$ 的条件限制。

***

**【数据范围】**

记 $\sum m$ 为单测试点内所有询问 $m$ 的值之和。

对于所有数据保证：$1 \leq n \leq 5\times 10^5$，$0\le m \le n$，$0 \leq \sum m \leq 5 \times 10^5$，$1\le q\le \max(n,\sum m)$，$0 \le a_i, b_i, c_i \le 10^9$，$1\le p_i \le n$。

| 测试点编号 | $n \le$ | $m \le$ | $\sum m \le$| 是否有特殊性质 |
|:--:|:--:|:--:|:--:|:--:|
| $1 \sim 2$ | $5 \times 10^5$ | $0$ | $0$ | 否 |
| $3 \sim 4$ | $7$ | $7$ | $15$ | 否 |
| $5 \sim 6$ | $2 \times 10^3$ | $1$ | $2 \times 10^3$ | 否 |
| $7$ | $2 \times 10^3$ | $2 \times 10^3$ | $2 \times 10^3$ | 是 |
| $8 \sim 11$ | $2 \times 10^3$ | $2\times 10^3$ | $2 \times 10^3$ | 否 |
| $12 \sim 13$ | $5 \times 10^4$ | $5 \times 10^4$ | $5 \times 10^4$ | 否 |
| $14 \sim 15$ | $5 \times 10^5$ | $1$ | $5 \times 10^5$ | 否 |
| $16$ | $5 \times 10^5$ | $5 \times 10^5$ | $5 \times 10^5$ | 是 |
| $17 \sim 20$ | $5 \times 10^5$ | $5 \times 10^5$ | $5 \times 10^5$ | 否 |

特殊性质：对于任意 $1\le i\le n$，保证 $c_i = 0$。

**【提示】**

本题输入输出量较大，请使用适当的 I/O 方式。

## 样例 #1

### 输入

```
5
1 13 6 0 6
2 4 1 0 5
3 4 1 2 1
7
1 4
2 1 5
1 4
2 2 3
5 1 2 3 4 5
1 5
2 3 4```

### 输出

```
7
3
7
6
0
0
8```

## 样例 #2

### 输入

```
7
10 1 6 9 4 2 4 
0 5 2 3 0 1 4 
4 1 4 1 5 3 5 
6
3 1 3 6 
2 2 6 
4 3 4 5 7 
1 4 
2 3 7 
3 3 5 6```

### 输出

```
12
8
2
5
5
8```

## 样例 #3

### 输入

```
10
6 10 7 2 8 4 6 4 8 7
4 0 6 7 8 4 8 2 10 5
4 10 6 1 4 7 5 3 8 7
1
0```

### 输出

```
7```

# AI分析结果

这道题主要是给定初始全为1的序列及三种操作，通过多次询问给定集合，求使序列特定位置为1其余为0的最小操作总代价。各题解思路、算法要点及难点解决如下：
1. **HFanGDoDM**：按测试点逐步分析。测试点1 - 2通过后缀和及枚举分界点求解；3 - 4用深度优先搜索枚举所有操作情况；5 - 6针对m = 1情况推导公式并用前缀和计算；7利用后缀和数组及特定公式；8 - 11使用动态规划并结合前缀和；12 - 13对dp表达式变形后用分块加速；14 - 20用ST表优化dp转移。整体思路清晰，从简单情况逐步优化到正解。
2. **wxzzzz**：定义$f_i$和$g_i$分别表示从全1和全0改变到满足条件的最小代价，通过动态规划转移方程求解，同时预处理$a_i$，最后根据不同情况计算最终答案。
3. **我怂了**：先预处理将前$i$位改成0的最小代价$d_i$和$b_i$的前缀和$pre'_i$，对于每次询问，通过动态规划转移方程计算$dp_i$，最后得出答案，整体思路基于动态规划。
4. **xiaosi4081**：先提出一种$O(qn)$的策略，即先使用操作1再调整，后考虑用树状数组或前缀最小值优化区间最小值计算来加速求解。
5. **technopolis_2085**：先考虑部分分，用动态规划求将前$i$个元素全部设为0的最小代价$clr_i$，正解部分通过动态规划设$dp_i$，分情况初始化和转移，最后考虑剩余区间设为0的情况。
6. **Pengzt**：发现操作一最多执行一次，通过预处理$dp$数组$g$表示前$i$个数全部清零的最小代价，或用数据结构维护区间极值来求解。
7. **tder**：先优化$a_i$，对于每次询问，通过朴素策略和其他策略得出总代价公式，并用前后缀预处理相关和式。
8. **Larryyu**：证明操作一最多进行一次，通过前缀和优化式子，再用线段树或ST表维护区间最小值来加速求解。
9. **modfisher**：证明操作一只用一次且在开始用，分三步操作，枚举最优的$i$，用ST表维护相关项来求解。
10. **binaryBard**：定义$f$和$g$数组，通过动态规划思想，根据不同操作方式得出转移方程，计算出$f[m]$和$g[m]$后得出答案。
11. **ztntonny**：定义$dp_i$表示子段满足要求的最小代价，先按常规枚举$dp_i$，后根据1的位置优化，用线段树优化求解。
12. **CQ_Bab**：发现操作一最多用一次，计算在第$i$个点使用操作一的代价，通过分类讨论和用线段树维护最小值来优化。
13. **zct_sky**：通过观察得出每个$p_i$的两种操作方式，设相关变量，根据操作花费更新变量得出答案，同时用前缀和优化并更新$a$数组。
14. **happy_zero**：定义$d_i$、$f_i$、$g_i$，分别推导其转移方程，通过动态规划求解，同时注意一些实现细节。
15. **Mirasycle**：采用倒序动态规划，记录操作对后续影响，在关键点转移，设$dp(i,k)$表示处理完部分位置且前$p(i) - 1$位值为$k$的最小代价，列出转移方程求解，同时更新$a_i$。
16. **_JF_**：观察到消序列为0的操作特点，对于每次询问通过前缀和计算，后通过维护中间位置$a + b$的最小值优化。
17. **operator_**：根据操作非负得出优先且最多进行一次1操作，枚举1操作位置并通过前后缀和计算，后用ST表或线段树优化。
18. **Light_az**：先讨论每种操作情况，通过枚举下标$i$得出$O(qn)$解法，后利用线段树结合二分进行区间修改和查询最小值优化。
19. **Nwayy**：先通过枚举操作1位置并用后缀和优化得到$O(nq)$解法，后用ST表维护区间最小值将单次询问复杂度降为$O(m)$。

综合分析，多数题解采用动态规划思路，部分结合数据结构优化。其中，HFanGDoDM的题解最为全面详细，从不同测试点逐步深入到正解，思路清晰，代码参考丰富，可评为5星。Larryyu和modfisher的题解也较为出色，对操作一的分析及优化思路清晰，可评为4星。

**所选5星题解 - HFanGDoDM**：
  - **星级**：5星
  - **关键亮点**：按测试点由易到难逐步分析，每种解法思路、正确性证明、实现及复杂度分析完整。
  - **核心代码（测试点14 - 20）**：
```cpp
long long MinInterval(int l, int r){//ST表单次询问求区间最小值
    if(l>r)
        return INF;
    long long ex=log_2[r-l+1];
    return min(ST[l][ex],ST[r-(1<<ex)+1][ex]);
}
...//预处理部分
    for(i=1;i<=n;i++)
        ST[i][0]=val[i];
...
    for(i=1;i<=log_2[n];i++)
        for(j=1;j<=n-(1<<i)+1;j++)
            ST[j][i]=min(ST[j][i-1],ST[j+(1<<(i-1))][i-1]);//ST 表预处理
...
   ...
    dp[i]=min(dp[i],sumb[p[i]-1]+sumc+MinInterval(p[i-1]+1,p[i]-1));//转移该式子时只需调用MinInterval函数即可
   ...//其余的dp转移
```
核心实现思想：先预处理$val$数组，构建ST表用于快速求区间最小值，在动态规划转移时通过调用函数获取区间最小值完成转移。

**所选4星题解 - Larryyu**：
  - **星级**：4星
  - **关键亮点**：清晰证明操作一最多进行一次，通过前缀和优化式子，利用ST表维护区间最小值。
  - **核心代码**：
```cpp
int get_st(int l,int r){
    if(l>r) return 100000000000;
    int len=lg[r-l+1];
    return min(st[l][len],st[r-(1<<(len))+1][len]);
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=2;i<=n;i++){
        lg[i]=lg[i>>1]+1;
    }
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        cin>>b[i];
        sum1[i]=sum1[i-1]+b[i];
    }
    for(int i=1;i<=n;i++){
        cin>>c[i];
        st[i][0]=sum1[n]-sum1[i]+a[i];  //得出g值
    }
    for(int j=1;j<=lg[n];j++){
        for(int i=1;i+(1<<j)-1<=n;i++){
            st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);  //预处理ST表求区间内最小的g
        }
    }
    cin>>q;
    while(q--){
        int m;
        cin>>m;
        for(int i=1;i<=m;i++){
            cin>>p[i];
            sum2[i]=sum2[i-1]+b[p[i]];
            sum3[i]=sum3[i-1]+c[p[i]];
        }
        int ans=100000000000;  
        for(int i=1;i<=m;i++){
            ans=min(ans,min(get_st(p[i-1]+1,p[i]-1)-sum2[m]+sum2[i-1]+sum3[i-1],a[p[i]]+sum1[n]-sum1[p[i]]-(sum2[m]-sum2[i])+sum3[i]));  //min内第一个数是取区间，第二个数是刚好取pi
        }
        ans=min(ans,sum1[n]-sum2[m]);  //没有操作一
        ans=min(ans,get_st(p[m]+1,n)+sum3[m]);  //没有操作二
        cout<<ans<<endl;
    }
    return 0;
}
```
核心实现思想：先预处理$lg$数组，计算$sum1$前缀和，得出$st$数组初始值，构建ST表。每次询问时，计算相关前缀和，通过ST表获取区间最小值，结合不同情况计算最小代价。

**所选4星题解 - modfisher**：
  - **星级**：4星
  - **关键亮点**：证明操作一的使用特点，分三步操作，通过枚举$i$并用ST表维护相关项求解。
  - **核心代码**：
```cpp
ll getmin(int l, int r){
    int g = lg[r - l + 1];
    return min(st[l][g], st[r - (1 << g) + 1][g]);
}
ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-') f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    return x * f;
}

int main(){
    int n = read();
    for(int i = 1; i <= n; i ++){
        a[i] = read();
        if(i > 1) lg[i] = lg[i / 2] + 1;
    }
    lg[n + 1] = lg[(n + 1) / 2] + 1;
    for(int i = 1; i <= n; i ++){
        b[i] = read();
    }
    for(int i = 1; i <= n; i ++){
        c[i] = read();
    }
    for(int i = n; i >= 1; i --){
        sumb[i] = sumb[i + 1] + b[i];
        st[i][0] = sumb[i + 1] + a[i];
    }
    st[0][0] = sumb[1];
    for(int j = 1; j <= lg[n]; j ++){
        for(int i = 0; i + (1 << j) - 1 <= n; i ++){
            st[i][j] = min(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
        }
    }
    int q = read();
    while(q --){
        int m = read();
        for(int i = 1; i <= m; i ++){
            p[i] = read();
            sumpc[i] = sumpc[i - 1] + c[p[i]];
        }
        p[m + 1] = n + 1;
        for(int i = m; i >= 1; i --){
            sumpb[i] = sumpb[i + 1] + b[p[i]];
        }
        ll ans = INF;
        for(int i = 0; i <= m; i ++){
            ans = min(ans, getmin(p[i], p[i + 1] - 1) - sumpb[i + 1] + sumpc[i]);
        }
        printf("%lld\n", ans);
        for(int i = 1; i <= m; i ++) sumpc[i] = sumpb[i] = 0;
    }
    return 0;
}
```
核心实现思想：先读入数据并预处理$lg$数组，计算$sumb$后缀和并得出$st$数组初始值，构建ST表。每次询问读入数据，计算相关前缀和后缀和，通过ST表获取区间最小值，枚举$i$计算最小代价。

**最优关键思路或技巧**：
 - **动态规划**：多数题解通过定义合适的状态和转移方程解决问题，如定义表示不同状态下最小代价的数组，根据操作方式推导转移方程。
 - **数据结构优化**：利用ST表、线段树等数据结构维护区间最小值，加速动态规划转移或相关计算，将时间复杂度从$O(nq)$优化到$O(n \log n + \sum m)$。

**可拓展之处**：此类题目属于序列操作与优化问题，常见套路是分析操作特点，利用动态规划建模，再根据数据范围和特点选择合适数据结构优化。相似题目如：
 - [P3865 【模板】ST表](https://www.luogu.com.cn/problem/P3865)：经典的ST表模板题，用于快速查询区间最值。
 - [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)：通过动态规划解决区间合并问题，与本题动态规划思路类似。
 - [P2880 [USACO07MAR]Face The Right Way G](https://www.luogu.com.cn/problem/P2880)：通过分析操作特点，利用前缀和优化解决问题，与本题有相似的优化思想。

**个人心得摘录与总结**：
 - **Nwayy**：提到在实现过程中因$\log$未处理到$n + 1$导致被卡，强调边界条件处理的重要性。在处理数据结构相关问题时，要充分考虑边界情况，避免因小失大。 

---
处理用时：102.73秒
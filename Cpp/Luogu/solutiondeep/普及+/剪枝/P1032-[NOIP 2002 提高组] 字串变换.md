# 题目信息

# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# AI分析结果

这道题主要考查字符串变换的搜索算法，多数题解采用BFS或DFS，并运用STL容器优化。以下是对各题解的综合分析：
1. **思路**：多数题解采用广度优先搜索（BFS），因其能找到最优解，少数使用深度优先搜索（DFS）或迭代加深搜索（IDDFS）。双向BFS也被部分题解采用，以减少搜索空间和时间。
2. **算法要点**：用队列存储搜索状态，用map或set判重，利用string相关函数或KMP算法进行字符串匹配和替换。
3. **解决难点**：主要难点在于处理字符串的匹配和替换，避免重复搜索，以及处理多种变换规则和可能的死循环。

以下是评分较高的题解：
1. **作者：coyangjr (赞：582)**
    - **星级**：5星
    - **关键亮点**：思路清晰，详细解释BFS和KMP算法的结合使用，代码注释详尽，并总结string函数用法。
    - **个人心得**：考试时忘记find和replace函数，因此使用KMP算法实现字符串匹配，体现灵活运用知识的能力。
    - **核心代码**：
```cpp
//寻找匹配的串，顺便修改并添加到queue中
il void KMP(string a, int x, int step) {
    string z = a;
    a = " " + a;
    re int i, j = 0;
    for (i = 1; i < a.length(); i++) {
        while (j > 0 && diff[x][j + 1]!= a[i]) j = nxt[x][j];
        if (diff[x][j + 1] == a[i]) j++;
        if (j == diff[x].length() - 1) {
            re int t = i - diff[x].length() + 1;
            string tmp = z.substr(0, t) + change[x] + z.substr(t + diff[x].length() - 1);
            q.push(Node(tmp, step + 1));
            j = nxt[x][j];
        }
    }
    return;
}
```
    - **核心思想**：通过KMP算法在字符串a中查找可替换子串，找到后进行替换并将新字符串加入队列。
2. **作者：ShawnZhou (赞：280)**
    - **星级**：4星
    - **关键亮点**：代码简洁明了，清晰阐述BFS思路，利用map判重，逻辑清晰。
    - **核心代码**：
```cpp
string trans(const string& str, int i, int j) {
    string ans = "";
    if (i + orginal[j].length() > str.length())
        return ans;
    for (int k = 0; k < orginal[j].length(); k++)
        if (str[i + k]!= orginal[j][k])
            return ans;
    ans = str.substr(0, i);
    ans += translated[j];
    ans += str.substr(i + orginal[j].length());
    return ans;
}
void bfs() {
    queue <node> q;
    node s;
    s.str = a;
    s.step = 0;
    q.push(s);
    while (!q.empty()) {
        node u = q.front();
        q.pop();
        string temp;
        if (ma.count(u.str) == 1) continue;
        if (u.str == b) {
            ans = u.step;
            break;
        }
        ma[u.str] = 1;
        for (int i = 0; i < u.str.length(); i++)
            for (int j = 0; j < n; j++) {
                temp = trans(u.str, i, j);
                if (temp!= "") {
                    node v;
                    v.str = temp;
                    v.step = u.step + 1;
                    q.push(v);
                }
            }
    }
    if (ans > 10 || ans == 0)
        cout << "NO ANSWER!" << endl;
    else
        cout << ans << endl;
}
```
    - **核心思想**：trans函数用于尝试替换字符串str中从位置i开始的子串，bfs函数通过队列进行BFS搜索，利用map判重，找到目标字符串时记录步数。
3. **作者：BrandonSoong (赞：127)**
    - **星级**：4星
    - **关键亮点**：提出双向BFS优化思路，通过图形直观解释双向BFS优势，代码实现清晰。
    - **核心代码**：
```cpp
inline int bfs() {
    int step = 0;
    A_.push(s);
    A[s] = 0;
    B_.push(t);
    B[t] = 0;
    string s, s2;
    while (++step <= 5) {
        while (A[A_.front()] == step - 1) {
            s = A_.front();
            A_.pop();
            for (int i = 1; i <= n; i++) {
                unsigned int pos = 0;
                while (pos < s.length()) {
                    if (s.find(a[i], pos) == s.npos) break;
                    s2 = s;
                    s2.replace(s2.find(a[i], pos), a[i].length(), b[i]);
                    if (A.find(s2)!= A.end()) {
                        pos++;
                        continue;
                    }
                    if (B.find(s2)!= B.end()) return step * 2 - 1;
                    A_.push(s2);
                    A[s2] = step;
                    pos++;
                }
            }
        }
        while (B[B_.front()] == step - 1) {
            s = B_.front();
            B_.pop();
            for (int i = 1; i <= n; i++) {
                unsigned int pos = 0;
                while (pos < s.length()) {
                    if (s.find(b[i], pos) == s.npos) break;
                    s2 = s;
                    s2.replace(s2.find(b[i], pos), b[i].length(), a[i]);
                    if (B.find(s2)!= B.end()) {
                        pos++;
                        continue;
                    }
                    if (A.find(s2)!= A.end()) return step * 2;
                    B_.push(s2);
                    B[s2] = step;
                    pos++;
                }
            }
        }
    }
    return -1;
}
```
    - **核心思想**：从初始字符串和目标字符串同时进行BFS，通过map记录搜索过的节点，当两边搜索到相同节点时返回步数。

**最优关键思路或技巧**：
1. **搜索算法选择**：BFS适合求最优解，双向BFS能进一步减少搜索空间和时间，如在本题中从初始和目标状态同时搜索，相遇即得解。
2. **判重优化**：使用map或set对已搜索过的字符串状态进行判重，避免重复搜索，大大提高效率。
3. **字符串处理**：灵活运用string的相关函数，如find、replace、substr等，简化字符串的匹配和替换操作。

**可拓展之处**：此类题目属于字符串变换与搜索问题，类似套路可用于其他字符串操作和状态搜索问题，如单词接龙游戏、状态转移问题等。通过分析状态空间和转移规则，选择合适的搜索算法并优化。

**推荐题目**：
1. **P1126 机器人搬重物**：涉及地图搜索与状态转移，可使用BFS解决。
2. **P1379 八数码难题**：经典的状态搜索问题，适合用BFS或双向BFS求解。
3. **P1443 马的遍历**：通过BFS解决马在棋盘上的遍历问题，与本题搜索思路相似。

**个人心得摘录与总结**：
1. **coyangjr**：考试时因遗忘函数而采用KMP算法，启示我们要灵活运用知识，多掌握不同方法。
2. **Time_Rune**：普通DFS会超时，通过迭代加深搜索优化，成功将TLE转为AC，体现对算法优化的探索。
3. **Lemoning**：读入数据时未给确切组数，可用循环读入后找有效数据组数；宽搜时find函数可能遗漏子串，需全面考虑；使用MAP判重剪枝优化时间。总结了读入、搜索和优化方面的经验。 

---
处理用时：57.02秒
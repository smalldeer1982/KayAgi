# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕搜索算法展开，少数尝试贪心或随机化。思路上多是将树按深度分层，通过搜索每层切断不同节点的情况来找到最少感染人数。算法要点在于树的存储与遍历、状态标记与回溯、每层节点的处理。难点是如何优化搜索，避免无效计算。多数题解代码能通过题目数据，但优化程度和代码可读性有所差异。
• 所选的题解：
  - 作者：RikoHere (赞：160)  星级：4星
    - 关键亮点：以初学者角度逐步分析题目，分模块处理代码，方便调试；通过改变dfs传入参数，以距离1节点的距离为参数，便于处理每层节点；利用最短路模板预处理保证树边方向正确。
    - 个人心得：从常规方法将节点序号作为传入参数中脱离出来寻找新的做法，若无法找到相关关系，不妨进行一定量的预处理。
    - 重点代码简述：通过`clean`函数标记子树节点并统计数量，`reclean`函数回溯；`resolve`函数预处理树结构；`dfs`函数为核心搜索函数，遍历每层节点，选择子树切除并递归搜索。
    - 核心代码：
```cpp
int clean(int i){
    bol[i] = true;
    int num = 1;
    int p = f[i].size();
    for (int j = 0; j < p; ++j){
        num += clean(f[i][j]);
    }
    return num;
} 
void reclean(int i){
    bol[i] = false;
    int p = f[i].size();
    for (int j = 0; j < p; ++j){
        reclean(f[i][j]);
    }
} 
void dfs(int cen, int tot){
    maxx = max(maxx, tot);
    for (int i = 0; i < cnt[cen]; ++i){
        if (!bol[b[cen][i]]){
            int num = clean(b[cen][i]);
            tot += num;
            dfs(cen+1, tot);
            reclean(b[cen][i]);
            tot -= num;
        }
    }
} 
void resolve(int i, int cen){
    b[cen][cnt[cen]] = i;
    ++cnt[cen];
    int p = k[i].size();
    for (int j = 0; j < p; ++j){
        if (dis[k[i][j]] == dis[i]+1){
            resolve(k[i][j], cen+1);
            f[i].push_back(k[i][j]);
        }
    }
} 
```
  - 作者：基础不牢 (赞：138)  星级：4星
    - 关键亮点：思路清晰，详细阐述每一步骤，如树的存储、标记深度、切断问题及搜索过程；针对搜索中可能出现的问题进行优化，如增加标记避免答案未更新情况。
    - 个人心得：在评论区根据反馈修改连边方式问题，体现对题解负责态度。
    - 重点代码简述：`Input`函数存储树结构；`Deep`函数标记节点深度；`Count`函数统计子树节点个数；`work`函数标记与回溯；`dfs`函数为核心搜索函数，遍历每层节点，选择切断节点并递归搜索。
    - 核心代码：
```cpp
void Input(void)
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)//初始化
    {
        node[i].number=0;
        count[i]=1;
    }
    for(i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        if(x>y) swap(x,y);
        node[y].father=x;
        node[x].number++;
        node[x].child[node[x].number]=y;
    }
}
void Deep(int tree,int now)
{
    maxx=max(maxx,now);
    for(int i=1;i<=node[tree].number;i++)
    {
        deep[now][0]++;
        deep[now][deep[now][0]]=node[tree].child[i];
        Deep(node[tree].child[i],now+1);
    }
    return ;
}
int Count(int tree)
{
    for(int i=1;i<=node[tree].number;i++)
    {
        count[tree]+=Count(node[tree].child[i]);
    }
    return count[tree];
}
void work(int tree,int tag)
{
    for(int i=1;i<=node[tree].number;i++)
    {
        vis[node[tree].child[i]]=tag;
        work(node[tree].child[i],tag);
    }
    return ;
}
void dfs(int now,int cnt) 
{
    if(now==maxx)
    {
        ans=min(ans,cnt);
        return ;
    }
    int f=0;
    for(int i=1;i<=deep[now][0];i++)
    {
        if(vis[deep[now][i]]>0)
        {
            f++;
            continue;
        }
        vis[deep[now][i]]=1;
        work(deep[now][i],1);
        dfs(now+1,cnt-count[deep[now][i]]);
        vis[deep[now][i]]=0;
        work(deep[now][i],0);
    }
    if(f==deep[now][0]) ans=min(ans,cnt);
}
```
  - 作者：早右昕 (赞：9)  星级：4星
    - 关键亮点：思路简洁明了，先将树按结点离根节点的距离分层，枚举每层隔离哪一个结点，预处理每个节点和他的后代个数总和，在搜索过程中随时更新答案。
    - 重点代码简述：`GO`函数预处理出结点的子树总结点和每一层的结点；`DOCUT`函数隔离从u为根节点的子树；`UNCUT`函数取消隔离；`dfs`函数为核心搜索函数，遍历每层节点，选择隔离节点并递归搜索。
    - 核心代码：
```cpp
void DOCUT(int u)
{
    ISCUT[u]=true;
    for(int v,i=0; i<TRE[u].size(); i++)
    {
        v=TRE[u][i];
        DOCUT(v);
    }
}
void UNCUT(int u)
{
    ISCUT[u]=false;
    for(int v,i=0;i<TRE[u].size();i++)
    {
        v=TRE[u][i];
        UNCUT(v);
    }
}
void dfs(int x,int now)
{
    for(int i=0; i<DEP[x+1].size(); i++)
    {
        int v=DEP[x+1][i];
        if(ISCUT[v]) continue;
        DOCUT(v); 
        dfs(x+1,now-ROOTSIZE[v]);
        UNCUT(v);
    }
    ans=min(now,ans);
}
int GO(int u,int now)
{
    if(VIS[u]) ROOTSIZE[u];
    VIS[u]=true;
    DEP[now].push_back(u);
    for(int v,i=0;i<TRE[u].size();i++)
    {
        v=TRE[u][i];
        ROOTSIZE[u]+=GO(v,now+1);
    }
    return ROOTSIZE[u];
}
```
• 最优关键思路或技巧：将树按深度分层处理，通过搜索枚举每层切断不同节点的情况，同时预处理子树大小等信息，利用状态标记和回溯来实现搜索过程。在代码实现上，分模块编写函数，使逻辑更清晰，便于调试和维护。
• 可拓展之处：同类型题可涉及树结构上的决策优化问题，类似算法套路是对树进行分层、状态标记与回溯搜索。例如在一些资源分配、路径选择等问题上，若能抽象成树结构，可采用类似方法解决。
• 推荐题目：
  - P1127 词链：通过搜索和状态标记解决单词连接问题，与本题在搜索思路上有相似之处。
  - P1036 选数：利用搜索枚举不同数字组合，与本题搜索不同节点切断情况类似。
  - P1433 吃奶酪：通过搜索枚举不同路径，与本题在搜索决策上有相通点。 

---
处理用时：46.40秒
# 题目信息

# [NOIP 2012 普及组] 文化之旅

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。由于测试数据过水，可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）。本题题目和数据仅供参考。本题不接受添加 hack 数据。

本题为错题。**不建议尝试或提交本题。**[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。

现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。


## 说明/提示

输入输出样例说明$1$

由于到国家 $2$ 必须要经过国家$ 1$，而国家$ 2 $的文明却排斥国家 $1$ 的文明，所以不可能到达国家 $2$。


输入输出样例说明$2$

路线为$ 1$ ->$ 2$

【数据范围】

对于 100%的数据，有$ 2≤N≤100$

$1≤K≤100$ 

$1≤M≤N^2$

$1≤k_i≤K$

$1≤u, v≤N$ 

$1≤d≤1000,S≠T,1≤S,T≤N$

NOIP 2012 普及组 第四题


## 样例 #1

### 输入

```
2 2 1 1 2 
1 2 
0 1 
1 0 
1 2 10 
```

### 输出

```
-1```

## 样例 #2

### 输入

```
2 2 1 1 2 
1 2 
0 1 
0 0 
1 2 10 ```

### 输出

```
10```

# AI分析结果

### 综合分析与结论
这些题解主要围绕图论算法解决文化之旅问题，难点在于处理文化排斥和不重复学习的限制。思路涵盖启发式搜索、Floyd、DFS、Dijkstra等算法。部分题解利用预处理剪枝优化，如先求无视文化排斥的最短路来剪枝。但因题目数据过水，部分解法正确性存疑。

### 所选的题解
1. **作者：Created_equal1（5星）**
    - **关键亮点**：采用启发式搜索，先跑一遍无视文化排斥的最短路用于剪枝，有效减少搜索空间，思路清晰，代码实现简洁明了。
    - **个人心得**：指出许多题解因数据水通过，认为自身方法为正解。
    - **重点代码 - Spfa函数**：用于求无视文化排斥的最短路。
```cpp
void Spfa()
{
    memset(Dist, 0X7F, sizeof(Dist));
    queue<unsigned int> Q;
    Q.push(S);
    In_Q[S] = true;
    Dist[S] = 0;
    unsigned int Top;
    while (Q.size())
    {
        Top = Q.front();
        Q.pop();
        In_Q[Top] = false;
        for (size_t i = Head[Top];i;i = Next[i])
            if (Dist[To[i]] > Dist[Top] + Weight[i])
            {
                Dist[To[i]] = Dist[Top] + Weight[i];
                if (!In_Q[To[i]])
                {
                    In_Q[To[i]] = true;
                    Q.push(To[i]);
                }
            }
    }
}
```
    - **重点代码 - Dfs函数**：实现启发式搜索，利用剪枝条件优化。
```cpp
void Dfs(const size_t &Now, const unsigned int &D)
{
    Went[Now] = true;
    culture.insert(C[Now]);
    if (Now == S)
    {
        Ans = min(Ans, D);
        return;
    }
    if (D + Dist[Now] > Ans)
        return;
    for (size_t i = Head[Now];i;i = Next[i])
        if (!Went[To[i]] && check(C[To[i]]))
            Dfs(To[i], D + Weight[i]);
    Went[Now] = false;
    culture.erase(C[Now]);
}
```
2. **作者：wjyyy（4星）**
    - **关键亮点**：利用Floyd算法求最短路，在插点过程中标记文化，通过判断文化排斥和重复情况更新路径，思路独特，代码简洁。
    - **个人心得**：尝试用并查集处理排斥问题，因文化排斥的单向性无效，最终在最短路上找突破口。
    - **重点代码 - floyd函数**：在Floyd算法中处理文化标记和路径更新。
```cpp
void floyd()//求最短路并判断是否排斥或重复
{
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(!a[c[k]][c[i]]&&!a[c[j]][c[k]]&&!used[i][k][c[j]]&&!used[k][j][c[i]]&&f[i][k]+f[k][j]<f[i][j])
                {
                    for(int t=1;t<=n;t++)
                        used[i][j][t]=used[i][k][t]||used[k][j][t];//有一个式子为真则表达式值为真
                    used[i][j][c[k]]=true;
                    f[i][j]=f[i][k]+f[k][j];
                }
}
```
3. **作者：grard4（4星）**
    - **关键亮点**：使用A*算法，通过合理定义估价函数优化搜索。在建边时去除无用边，利用bitset优化文化排斥判断，有效提高效率。
    - **重点代码 - spfa函数**：对终点跑最短路，用于计算估价函数中的距离。
```cpp
void spfa()           //对终点跑一遍最短路
{
    memset(dis,0x7f,sizeof(dis));
    queue<int> Q;
    dis[t]=0;Q.push(t);
    while(!Q.empty()){
        int u=Q.front();Q.pop();
        vis[u]=false;
        for (int i=h2[u];i;i=e2[i].nxt){
            int v=e2[i].to,w=e2[i].val;
            if (dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                if (!vis[v]) vis[v]=true,Q.push(v);
            }
        }
    }
}
```
    - **重点代码 - 主函数部分**：建边时去除无用边，利用A*算法搜索。
```cpp
int main(){
    cin>>n>>k>>m>>s>>t;
    for (int i=1;i<=n;i++) cin>>c[i];
    for (int i=1;i<=k;i++)
      for (int j=1;j<=k;j++){
        bool op;cin>>op;
        if (op) a[i].set(j);
      }
    for (int i=1;i<=n;i++)
      if (i!=s&&c[i]==c[s]) no[i]=true;    //判断哪些点是无用的
    if (no[t]) {puts("-1");return 0;}      //如果终点也是无用的,则必定无解
    while(m--){
        int u,v,w;cin>>u>>v>>w;
        if (!no[u]&&!no[v]&&c[u]!=c[v]){   //只连接文化不同且有用的点
            if (!a[c[u]].test(c[v])) add(v,u,w);  //如果不排斥就连接
            if (!a[c[v]].test(c[u])) add(u,v,w);
        }
    }
    spfa();
    if (dis[s]==dis[0]) {puts("-1");return 0;}  //如果起点到终点的最短路不存在则无解
    bitset<MAXN> p;p.set(c[s]);
    q.push({s,0,p});
    while(!q.empty()){
        int u=q.top().u,w=q.top().w;
        if (u==t) {cout<<w<<endl;return 0;}
        bitset<MAXN> ok=q.top().ok;
        q.pop();
        for (int i=h1[u];i;i=e1[i].nxt){
            int v=e1[i].to,w1=e1[i].val;
            p=ok&a[c[v]];
            if (p.any()) continue;   //如果 p 中存在 1,则说明学过已被排斥的文化
            p=ok,p.set(c[v]);
            q.push({v,w+w1,p});
        }
    }
    puts("-1");
    return 0;
}
```

### 最优关键思路或技巧
1. **剪枝优化**：如Created_equal1先求无视文化排斥最短路，在搜索中利用当前花费与该最短路花费之和进行剪枝。
2. **去除无用边**：grard4在建边时去除因文化相同、排斥等导致的无用边，减少图的规模，优化算法复杂度。
3. **状态标记与判断优化**：wjyyy在Floyd插点时标记文化；grard4利用bitset合并优化文化排斥判断。

### 可拓展之处
此类题属于带限制条件的图论最短路问题，类似套路有在图的遍历或最短路算法中，根据题目特殊条件（如点或边的限制）进行状态记录和剪枝优化。例如在一些路径规划问题中，可能存在某些区域禁止通过或不同路径有不同的代价限制等。

### 相似知识点洛谷题目
1. **P3371 【模板】单源最短路径（弱化版）**：基础的单源最短路问题，可巩固最短路算法基础。
2. **P1339 热浪**：同样是求最短路，可练习在实际场景中应用最短路算法。
3. **P2330 [SCOI2005]繁忙的都市**：涉及图论中的最小生成树和最短路径相关知识，与本题同属图论范畴。 

---
处理用时：42.76秒
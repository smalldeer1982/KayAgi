# 题目信息

# [NOIP 2017 普及组] 棋盘

## 题目背景

NOIP2017 普及组 T3

## 题目描述

有一个 $m \times m$ 的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。

任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、下、左、右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 $1 $ 个金币。

另外， 你可以花费 $2$ 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。

现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？


## 说明/提示

**样例 1 说明**

棋盘的颜色如下表格所示，其中空白的部分表示无色。

| $\color{red}\text{红}$ | $\color{red}\text{红}$ |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  | $\color{yellow}\text{黄}$ |  |  |  |
|  |  | $\color{yellow}\text{黄}$ | $\color{red}\text{红}$ |  |
|  |  |  | $\color{yellow}\text{黄}$ |  |
|  |  |  |  | $\color{red}\text{红}$ |


从 $(1,1)$ 开始，走到 $(1,2)$ 不花费金币。

从 $(1,2)$ 向下走到 $(2,2)$ 花费 $1$ 枚金币。

从 $(2,2)$ 施展魔法，将 $(2,3)$ 变为黄色，花费 $2$ 枚金币。

从 $(2,2)$ 走到 $(2,3)$ 不花费金币。

从 $(2,3)$ 走到 $(3,3)$ 不花费金币。

从 $(3,3)$ 走到 $(3,4)$ 花费 $1$ 枚金币。

从 $(3,4)$ 走到 $(4,4)$ 花费 $1$ 枚金币。

从 $(4,4)$ 施展魔法，将 $(4,5)$ 变为黄色，花费 $ 2$ 枚金币。

从 $(4,4)$ 走到 $(4,5)$ 不花费金币。

从 $(4,5)$ 走到 $(5,5)$ 花费 $1$ 枚金币。

共花费 $8 $ 枚金币。

**样例 2 说明**

棋盘的颜色如下表格所示，其中空白的部分表示无色。

| $\color{red}\text{红}$ | $\color{red}\text{红}$ |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  | $\color{yellow}\text{黄}$ |  |  |  |
|  |  | $\color{yellow}\text{黄}$ |  |  |
|  |  |  | $\color{white}\text{　}$ |  |
|  |  |  |  | $\color{red}\text{红}$ |

从 $( 1, 1)$ 走到 $( 1, 2)$，不花费金币。

从 $( 1, 2)$ 走到 $( 2, 2)$，花费 $ 1 $ 金币。

施展魔法将 $( 2, 3)$ 变为黄色，并从 $( 2, 2)$ 走到 $( 2, 3)$ 花费 $ 2$ 金币。

从 $( 2, 3)$ 走到 $( 3, 3)$ 不花费金币。

从 $( 3, 3)$ 只能施展魔法到达 $( 3, 2),( 2, 3),( 3, 4),( 4, 3)$。

而从以上四点均无法到达 $( 5, 5)$，故无法到达终点，输出$-1$。

**数据规模与约定**

对于 $30\%$ 的数据，$1 ≤ m ≤ 5, 1 ≤ n ≤ 10$。

对于 $60\%$ 的数据，$1 ≤ m ≤ 20, 1 ≤ n ≤ 200$。

对于 $100\%$ 的数据，$1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000$。


## 样例 #1

### 输入

```
5 7
1 1 0
1 2 0
2 2 1
3 3 1
3 4 0
4 4 1
5 5 0```

### 输出

```
8```

## 样例 #2

### 输入

```
5 5
1 1 0
1 2 0
2 2 1
3 3 1
5 5 0```

### 输出

```
-1```

# AI分析结果

• 综合分析与结论：这些题解主要围绕从棋盘左上角到右下角求最小花费的问题，核心思路是将题目转化为图论或搜索模型求解。主要难点在于处理魔法的限制条件，即不能连续使用且持续时间短。各题解的算法要点和解决难点方式如下：
    - **ZigZagKmp**：将魔法操作等价转换为特定的移动方式，把问题转化为经典走迷宫模型，使用优先队列优化的BFS或Dijkstra算法求解。通过分析魔法使用后的可能移动情况，简化问题，降低代码实现复杂度。
    - **览遍千秋**：采用DFS搜索，将魔法转化为允许走到距离为两格的有色格子，代价相应增加，同时利用剪枝优化搜索。
    - **dxzier**：建图后跑最短路，针对大数据范围提出稀疏矩阵存储优化空间复杂度，利用特殊条件下的线性单源最短路算法优化时间复杂度。
    - **WsW_ 和 lby_commandBlock**：运用“分层图”思想，以“到达的格子坐标，这个格子的颜色，是否在这个格子上使用了魔法”定义状态进行BFS。
    - **__galaxy_1202__、beigongbaishan、Iron_Spade**：直接爆搜加剪枝，按题意模拟移动，记录每个格子当前所用的最短时间或最小代价进行剪枝。
    - **Night_sea_64**：定义状态并模拟所有方向使用魔法和改变颜色的情况，提出可转换为边权为0或1使用01 bfs，也可直接无脑SPFA。
    - **HHC883、qsn123**：为格子编号建图，按题目规定走法连边，最后跑堆优化的Dijkstra算法。

总体来看，ZigZagKmp的题解思路清晰，对问题转化和算法分析详细，代码实现给出两种方法且有注释辅助理解；dxzier的题解在大数据范围优化上有独特见解；览遍千秋的题解提出了一种不同的搜索转化思路且有剪枝操作。这三篇题解质量相对较高。

所选的题解：
  - **ZigZagKmp（5星）**
    - **关键亮点**：对题意转化分析详细，通过等价转换魔法操作简化问题，清晰阐述BFS和Dijkstra两种解法及原理，代码注释详细。
    - **个人心得**：作者分享了比赛时的经历，在处理魔法上遇到困难，考后与同学思考出代替魔法的算法。
    ```cpp
    // BFS +优先队列优化核心代码
    void bfs(){
        memset(dis,0x3f,sizeof(dis));dis[1][1]=0;
        q.push((node){1,1,a[1][1],dis[1][1]});
        node cur,nxt;
        while(!q.empty()){
            cur=q.top();q.pop();
            if(dis[cur.x][cur.y]<cur.w)continue;
            for(int i=0;i<12;i++){// 12种移动方向
                nxt.x=cur.x+dx[i];
                nxt.y=cur.y+dy[i];
                nxt.w=cur.w+dw[i];
                if(nxt.x<=0||nxt.x>m||nxt.y<=0||nxt.y>m)continue;
                nxt.c=a[nxt.x][nxt.y];
                if(!nxt.c)continue;
                if(cur.c!=nxt.c)nxt.w++;// 颜色不同代价加1
                if(dis[nxt.x][nxt.y]>nxt.w){
                    dis[nxt.x][nxt.y]=nxt.w;
                    q.push(nxt);
                }
            }
        }
    }
    ```
  - **dxzier（4星）**
    - **关键亮点**：不仅给出常规建图跑最短路的解法，还针对大数据范围提出稀疏矩阵存储优化空间，以及利用特殊边权的线性单源最短路算法优化时间复杂度，解法有深度和拓展性。
    ```cpp
    // 建图核心代码
    void buildmap(){
        unordered_map<int,unordered_map<int,int>>::iterator it1=M.begin();
        while(it1!=M.end()){
            unordered_map<int,int>::iterator it2=(it1->second).begin();
            while(it2!=(it1->second).end()){
                int x=it1->first,y=it2->first;
                // 处理各种相邻情况的建边
                // ......
                it2++;
            }
            it1++;
        }
    }
    ```
  - **览遍千秋（4星）**
    - **关键亮点**：提出独特的将魔法转化为可走到距离为两格有色格子的思路，通过DFS搜索并结合剪枝优化，代码实现简洁明了。
    ```cpp
    // DFS核心代码
    void f(int x,int y,int q)
    {
        if(opt[x][y]&&opt[x][y]<=q) return;
        opt[x][y]=q; 
        if(x==m&&y==m){
            ans=min(ans,q);
            return;
        }
        // 处理各种方向的移动
        // ......
    }
    ```

最优的关键思路或技巧：
 - **问题转化**：将魔法操作转化为特定的移动方式，简化问题模型，如ZigZagKmp和览遍千秋的题解，降低问题复杂度。
 - **状态定义**：利用“分层图”思想，将格子坐标、颜色、魔法使用情况等作为状态定义，使搜索或BFS更清晰，如WsW_ 和lby_commandBlock的题解。
 - **优化算法**：针对不同数据范围选择合适算法，大数据范围下如dxzier题解中采用稀疏矩阵存储和特殊边权的线性单源最短路算法优化时空复杂度。

可拓展之处：此类题目属于带特殊条件的路径搜索或最短路问题，类似套路是分析特殊条件并合理转化为图论模型或搜索策略。同类型题可考虑一些带限制条件的迷宫问题、网格图上的路径规划问题等。

推荐题目：
 - [P1339 热浪](https://www.luogu.com.cn/problem/P1339)：经典的最短路问题，可用于巩固最短路算法基础。
 - [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：单源最短路径模板题，加深对Dijkstra等最短路算法的理解。
 - [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：在求最短路基础上增加计数要求，拓展对最短路算法的应用。 

---
处理用时：36.82秒
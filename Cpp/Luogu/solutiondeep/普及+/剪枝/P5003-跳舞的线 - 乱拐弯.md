# 题目信息

# 跳舞的线 - 乱拐弯

## 题目背景

# 线初始面对方向请自己确定

![您可以写dp](https://cdn.luogu.com.cn/upload/pic/30733.png)

玩过了 $LCA$ 之后，Imakf 觉得甚是无聊，于是便打开了 DL。

Imakf：刺客传奇又死在 $70\%$！突然有一点弃坑的想法鸭……

Imakf 想起自己玩了 $1$ 年的 DL，卡在园林教堂混沌，肝了几个月终于过了的欣喜，却被这个刺客传奇困住，禁不住泪眼朦胧。泪眼中，他突然发现手机变成了一个一个的像素点！Imakf 非常惊喜！这样不就可以写一个程序自动通关了吗？

可是不一会，他又陷入了失望……

Imakf：我不会写啊！！


## 题目描述

线现在在一个地图上，它正在 $(1,1)$ 上（左上角），最终要去到 $(M,N)$ 上。它不但只能往下或往右走，还只能在整数格子上移动。

Imakf 有的时候想要炫技，又有时想偷懒，所以他会告诉你这张地图的全貌，你要告诉他到达终点的最多和最少拐弯次数。


## 说明/提示

样例 $1$ 说明：

![](https://cdn.luogu.com.cn/upload/pic/12623.png)

红色路线代表拐弯次数最多。

蓝色路线代表拐弯次数最少。

--------------

样例 $2$ 说明：

显然过不去。

---

数据范围：

| 测试点 | $N$ | $M$ |
| -----------: | -----------: | -----------: |
| $1\sim 5$ | $\leq100$ | $\leq100$ |
| $6\sim 7$ | $=200$ | 不做约定 |
| $8\sim 10$ | 不做约定 |不做约定|

对于全体数据，保证 $10\le M,N\le 1000$。

感谢 @Iowa\_BattleShip 指出数据错误。

## 样例 #1

### 输入

```
5 5
oooo#
ooooo
#oo#o
o#ooo
oo#oo
```

### 输出

```
7 2
```

## 样例 #2

### 输入

```
5 5
oooo#
ooooo
#oo##
o#o#o
oo#oo
```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论
本题要求计算从地图左上角$(1,1)$到右下角$(M,N)$的最多和最少拐弯次数，线只能在整数格子上向下或向右移动，地图中存在障碍物。众多题解主要围绕深度优先搜索（DFS）、广度优先搜索（BFS）和动态规划（DP）展开。
 - **DFS**：暴力搜索不剪枝得分低，加记忆化可提升。但对于大规模数据，时间复杂度高。
 - **BFS**：思路简单，可通过双端队列优化求最短路，但代码实现细节多。
 - **DP**：多数题解采用此方法，状态设计多为$dp[i][j][k]$，$k$表示方向，通过上或左的状态转移得到当前状态的拐弯次数最值。

### 所选的题解
#### 作者：Imakf (5星)
 - **关键亮点**：思路清晰，从低分到满分循序渐进讲解，详细阐述每种解法思路。先点明$10$分暴力做法，再介绍$dfs$爆搜及加记忆化优化，最后给出$100$分$dp$解法，状态设计和转移方程讲解细致。
 - **个人心得**：出题者自述，提到题目背景及自身做题经历，如当时不会$dp$，后来加强数据。
 - **重点代码 - DP部分**：
```cpp
// 初始化
bool a=0;
for(int i=1;i<=n;i++){
    if(_map[i][1]=='#')a=1;
    if(a){
        dis[i][1][1]=10000;
        maxn[i][1][1]=-10000;
    }
    dis[i][1][0]=10000;
    maxn[i][1][0]=-10000;
}
a=0;
for(int j=1;j<=m;j++){
    if(_map[1][j]=='#')a=1;
    if(a){
        dis[1][j][0]=10000;
        maxn[1][j][0]=-10000;
    }
    dis[1][j][1]=10000;
    maxn[1][j][1]=-10000;
}
// 状态转移
for(int i=2;i<=n;i++){
    for(int j=2;j<=m;j++){
        if(有障碍)continue;
        maxn[i][j][0]=max(maxn[i][j-1][0],maxn[i][j-1][1]+1);
        maxn[i][j][1]=max(maxn[i-1][j][1],maxn[i-1][j][0]+1);
    }
}
```
核心思想：先初始化第一行和第一列，若遇到障碍物则后续位置设为无效值。状态转移时，根据当前位置是否为障碍决定是否跳过，通过比较从左边和上边转移过来的情况，更新当前位置不同方向的最多拐弯次数。

#### 作者：Flying2018 (4星)
 - **关键亮点**：采用不同的$dp$思路，用$f[i][j]$去更新$f[i + 1][j], f[i][j + 1]$，代码简洁，同时指出默认起点能拐弯的小陷阱，最后需对最大值减$1$。
 - **重点代码 - 核心DP部分**：
```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(map[i][j]=='#'){
            f[1][i][j][0]=f[1][i][j][1]=-1;
            f[0][i][j][0]=f[0][i][j][1]=10000000;
            continue;
        }
        f[0][i+1][j][0]=min(f[0][i+1][j][0],min(f[0][i][j][0],f[0][i][j][1]+1));
        f[0][i][j+1][1]=min(f[0][i][j+1][1],min(f[0][i][j][1],f[0][i][j][0]+1));
        f[1][i+1][j][0]=max(f[1][i+1][j][0],max(f[1][i][j][0],f[1][i][j][1]+1));
        f[1][i][j+1][1]=max(f[1][i][j+1][1],max(f[1][i][j][1],f[1][i][j][0]+1));
    }
}
```
核心思想：遍历地图，若当前位置是障碍物，将对应状态设为无效值。否则，从当前位置向下方和右方转移，通过比较不同方向转移过来的情况，更新下方和右方位置不同方向的拐弯次数最值。

#### 作者：3493441984zz (4星)
 - **关键亮点**：状态设计清晰，分别定义$f[i][j][0/1]$和$g[i][j][0/1]$表示到$(i,j)$方向向右或向下的最少和最多拐弯次数，详细列出状态转移方程并给出完整代码，还特别指出要特判起点为'#'的情况。
 - **重点代码 - 状态转移部分**：
```cpp
for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
        if(!map[i][j]){
            f[i][j][0]=min(f[i][j][0],min(f[i][j-1][0],f[i-1][j][1]+1));
            f[i][j][1]=min(f[i][j][1],min(f[i-1][j][1],f[i][j-1][0]+1));
            g[i][j][0]=max(g[i][j][0],max(g[i][j-1][0],g[i-1][j][1]+1));
            g[i][j][1]=max(g[i][j][1],max(g[i-1][j][1],g[i][j-1][0]+1));
        }
```
核心思想：遍历地图，若当前位置不是障碍物，分别从左边和上边转移，比较不同方向转移过来的情况，更新当前位置不同方向的最少和最多拐弯次数。

### 最优关键思路或技巧
 - **状态设计**：使用三维数组$dp[i][j][k]$（$k$表示方向）记录到$(i,j)$位置且方向为$k$的拐弯次数最值，方便状态转移。
 - **转移方程**：根据方向的连续性判断是否拐弯，如从上方转移到当前位置且方向改变则拐弯次数加$1$。

### 可拓展之处
此类题目属于网格路径规划问题，类似套路为用$dp$解决在网格上按特定规则移动求最值。同类型题如在网格中收集金币，每次移动可获得一定金币，求从起点到终点能获得的最大金币数；或在网格上移动，每个格子有不同代价，求最小代价路径等。

### 推荐题目
 - **P1002 过河卒**：在棋盘上求从起点到终点的路径数量，考虑障碍物，与本题在网格上移动并处理特殊情况类似。
 - **P1216 数字三角形**：在数字三角形中从顶部到底部找一条路径，使路径经过数字之和最大，同样是网格状结构的$dp$问题。
 - **P1164 小A点菜**：给定金额和菜品价格，求能组合出的方案数，本质也是$dp$问题，可类比本题$dp$的状态转移思想。

### 个人心得摘录与总结
 - **3493441984zz**：强调要特判起点为'#'的情况，否则调试困难。总结出在网格类$dp$问题中，边界条件的判断十分重要，容易因忽视特殊情况导致错误。
 - **Jansec**：调程序时发现第一列和第一行初始化的细节问题，如$fmin[i][1][1]$和$fmax[i][1][1]$应初始化为$1$。说明在$dp$初始化过程中，需仔细考虑每个状态的初始值，稍有不慎就会出错。
 - **zhenglier**：开始想用广搜但发现错误，后用$dp$解决。被坑在直接初始化$(1,1)$而跳过障碍物判断，最后用$dfs$判$-1$。表明在解决问题时，算法选择需谨慎，同时要注意特殊点的处理，不能想当然初始化。 

---
处理用时：38.46秒
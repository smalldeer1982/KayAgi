# 题目信息

# [厦门小学生 C++ 2023] 数据核心

## 题目背景

本试题为 2023 年厦门市小学生 C++ 语言**复赛**试题，数据为洛谷自造。

**初赛**为笔试。

## 题目描述

Sora 有一块神奇的数据核心，这块数据核心里有 $n\times m$ 个数据块，这些数据块组成了一个 $n\times m$ 的矩阵。

在数据核心中，每个数据块都有一个强度 $a_{i,j}$，代表这个数据块存在数据核心中时会提供多少的运算力。但是随着时间的推移，数据核心中有一些数据块出现了硬件老化，有些数据块的强度是一个负数，继续保留过多的老化数据块会影响数据核心的使用效率，所以 Sora 决定从原本的数据核心的矩阵中，先确定一个数据块作为新数据核心的左上角，其位置为 $(x, y)$ ，向右下方切割出一块数据核心（子矩阵），以保证其使用效率。

但是 Sora 是一个有着天马行空想象力的科学家，她想知道在确定了新的数据核心左上角的数据块的情况下，其位置为 $(x, y)$，新的数据核心（子矩阵）能够获得的最大运算力是多少。

当然她的问题很多，有 $Q$ 次询问，每次询问都会给出一个位置 $(x, y)$，你需要算出以这个位置为左上角的新数据核心对应的最大运算力。


## 说明/提示

### 样例解释

- 第一个询问对应的新数据核心是 $(1,1)$ 到 $(5,5)$。
- 第二个询问对应的新数据核心是 $(2,2)$ 到 $(5,5)$。
- 第三个询问对应的新数据核心是 $(3,3)$ 到 $(5,4)$。
- 第四个询问对应的新数据核心是 $(5,1)$ 到 $(5,4)$。
- 第五个询问对应的新数据核心是 $(5,5)$ 到 $(5,5)$。

### 数据范围

- 对于 $20\%$ 的数据，$n\times m \leq 500$，$Q \leq 500$，$a_{i,j} \leq 10^5$。
- 对于 $50\%$ 的数据，$n\times m \leq 5000$，$Q \leq 5000$，$a_{i,j} \leq 10^5$。
- 对于 $80\%$ 的数据，$n\times m \leq 10000$，$Q \leq 10000$，$a_{i,j} ≤ 10^5$。
- 对于 $100\%$ 的数据，$n\times m \leq 100000$，$Q \leq 100000$，$|a_{i,j}| \leq 10^9$。

## 样例 #1

### 输入

```
5 5
1 -1 1 -1 1
2 2 2 -1 2
1 1 2 -1 -1
-1 -1 2 2 1
1 1 1 1 -1
6
1 1
2 2
3 3
2 4
5 1
5 5```

### 输出

```
16
12
7
2
4
-1```

# AI分析结果



### 综合分析与结论

本题要求对于每个询问的左上角(x,y)，求出以该点为左上角的子矩阵的最大和。关键在于如何高效处理大量查询。通过预处理每行的后缀最大连续和（rmax）与每列的后缀最大连续和（cmax），结合Kadane算法逐行逐列累加，能在较优时间复杂度内解决。

### 关键思路与技巧

1. **预处理行与列的最大连续和**：
   - 每行预处理从右到左的最大连续和（rmax），用于快速获取单行的最大子段。
   - 每列预处理从下到上的最大连续和（cmax），用于快速获取单列的最大子段。

2. **动态规划结合Kadane算法**：
   - 逐行处理时，利用Kadane思想维护当前累加的最大值，处理多行组合的情况。
   - 同理，逐列处理时维护纵向累加的最大值。

3. **时间复杂度优化**：
   - 预处理阶段为O(nm)，每个查询处理时间为O(n + m)，在题目约束下可行。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n, m;
    cin >> n >> m;
    vector<vector<ll>> a(n + 1, vector<ll>(m + 1));
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> a[i][j];
        }
    }

    // 预处理每行的后缀最大连续和
    vector<vector<ll>> rmax(n + 2, vector<ll>(m + 2));
    for (int i = 1; i <= n; ++i) {
        ll sum = 0, max_sum = LLONG_MIN;
        for (int j = m; j >= 1; --j) {
            sum = max(a[i][j], sum + a[i][j]);
            max_sum = max(max_sum, sum);
            rmax[i][j] = max_sum;
        }
    }

    // 预处理每列的后缀最大连续和
    vector<vector<ll>> cmax(n + 2, vector<ll>(m + 2));
    for (int j = 1; j <= m; ++j) {
        ll sum = 0, max_sum = LLONG_MIN;
        for (int i = n; i >= 1; --i) {
            sum = max(a[i][j], sum + a[i][j]);
            max_sum = max(max_sum, sum);
            cmax[i][j] = max_sum;
        }
    }

    int Q;
    cin >> Q;
    while (Q--) {
        int x, y;
        cin >> x >> y;

        ll row_max = LLONG_MIN, current_row = 0;
        for (int i = x; i <= n; ++i) {
            ll val = rmax[i][y];
            current_row = max(val, current_row + val);
            row_max = max(row_max, current_row);
        }

        ll col_max = LLONG_MIN, current_col = 0;
        for (int j = y; j <= m; ++j) {
            ll val = cmax[x][j];
            current_col = max(val, current_col + val);
            col_max = max(col_max, current_col);
        }

        ll ans = max(row_max, col_max);
        cout << ans << '\n';
    }

    return 0;
}
```

### 举一反三

1. **最大子数组和（Kadane算法）**：类似一维处理思路，如LeetCode 53。
2. **二维区域和检索**：预处理前缀和应对多次查询，如LeetCode 304。
3. **动态规划扩展**：处理复杂区域最值问题，如洛谷P1719。

### 推荐题目
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
- [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)
- [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)

---
处理用时：542.24秒
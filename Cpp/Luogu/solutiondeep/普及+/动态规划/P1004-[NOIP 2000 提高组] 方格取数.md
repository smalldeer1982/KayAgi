# 题目信息

# [NOIP 2000 提高组] 方格取数

## 题目背景

NOIP 2000 提高组 T4

## 题目描述

设有 $N \times N$ 的方格图 $(N \le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:

![](https://cdn.luogu.com.cn/upload/image_hosting/0bpummja.png)

某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  
此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。


## 说明/提示

数据范围：$1\le N\le 9$。

## 样例 #1

### 输入

```
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0
```

### 输出

```
67```

# AI分析结果



### 综合分析结论
本题核心在于处理两次路径的最优解叠加问题。各题解主要围绕动态规划展开，其中四维DP是基础解法，三维DP通过维度压缩优化空间，DFS+剪枝在小数据下可行但效率较低，网络流解法思路新颖但复杂度高。最优解法是三维DP，其通过步数维度（k）合并路径状态，在保证时间效率的同时降低空间复杂度。

---

### 高星题解推荐

#### 1. Azuree的三维DP解法（⭐⭐⭐⭐⭐）
**关键亮点**：
- 将四维状态压缩为三维（步数k + 两条路径的行号i,j）
- 利用i+j=k推导列号，极大优化空间复杂度
- 处理重复取值的逻辑简洁清晰

**核心代码**：
```cpp
for(int k=2; k<=n*2; k++){
    for(int i=1; i<=min(k,n); i++){
        for(int j=1; j<=min(k,n); j++){
            int j1=k-i, j2=k-j;
            dp[k][i][j] = max(...) + (i==j ? map[i][j1] : map[i][j1]+map[j][j2]);
        }
    }
}
```

#### 2. road的四维DP解法（⭐⭐⭐⭐）
**关键亮点**：
- 最直观的四维状态定义，易理解
- 通过位运算处理重复取值
- 代码结构清晰，适合DP入门学习

**核心代码**：
```cpp
for(int i=1; i<=n; i++)
for(int j=1; j<=n; j++)
for(int k=1; k<=n; k++)
for(int l=1; l<=n; l++){
    dp[i][j][k][l] = max(...) + a[i][j] + a[k][l];
    if(i==k && j==l) dp[i][j][k][l] -= a[i][j];
}
```

#### 3. chrispang的简洁四维实现（⭐⭐⭐⭐）
**关键亮点**：
- 代码极度精简（仅15行核心逻辑）
- 利用位运算(i!=k||j!=l)*a[k][l]处理重复
- 适合竞赛快速coding场景

**核心代码**：
```cpp
for(int i=1; i<=n; i++)
for(int j=1; j<=n; j++)
for(int k=1; k<=n; k++)
for(int l=1; l<=n; l++)
dp[i][j][k][l] = max(...) + a[i][j] + (i!=k||j!=l)*a[k][l];
```

---

### 关键思路与技巧
1. **状态设计**：同时追踪两条路径的状态，四维(i,j,k,l)或三维(k,i,j)
2. **维度压缩**：利用i+j = x+y = k的数学关系，将四维降为三维
3. **重复处理**：当路径交叉时通过条件判断只取一次值
4. **转移优化**：预处理max值避免重复计算

---

### 拓展建议
1. **同类题目**：
   - P1006 [NOIP2008 提高组] 传纸条（几乎相同模型）
   - P7074 [CSP-J2020] 方格取数（带方向限制的变种）
   - P2045 方格取数加强版（k次取数+费用流）

2. **优化方向**：
   - 滚动数组进一步优化空间
   - 记忆化搜索与DP的状态互化
   - 网络流模型中的最大费用流应用

---

### 个人心得摘录
1. **wzxx的DFS调试**："必须同时走两条路径，分开走会丢失全局最优" 
2. **road的维度教训**："二维贪心解法只能得到局部最优，必须四维全局考虑"
3. **Azuree的降维经验**："发现i+j=k是突破维度限制的关键观察点"
4. **Vistarin的剪枝启示**："最优性剪枝让DFS在n=9时也能快速收敛"

---
处理用时：51.11秒
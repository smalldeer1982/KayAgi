# 题目信息

# [NOIP 1998 提高组] 车站

## 题目描述

火车从始发站（称为第 $1$ 站）开出，在始发站上车的人数为 $a$，然后到达第 $2$ 站，在第 $2$ 站有人上、下车，但上、下车的人数相同，因此在第 $2$ 站开出时（即在到达第 $3$ 站之前）车上的人数保持为 $a$ 人。从第 $3$ 站起（包括第 $3$ 站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第 $n-1$ 站），都满足此规律。现给出的条件是：共有 $n$ 个车站，始发站上车的人数为 $a$，最后一站下车的人数是 $m$（全部下车）。试问 $x$ 站开出时车上的人数是多少？


## 说明/提示

对于全部的测试点，保证 $1 \leq a \leq 20$，$1 \leq x \leq n \leq 20$，$1 \leq m \leq 2 \times 10^4$。

NOIP1998 提高组 第一题

## 样例 #1

### 输入

```
5 7 32 4
```

### 输出

```
13
```

# AI分析结果



### 综合分析与结论
本题核心是发现上下车人数的斐波那契递推规律。最优解法通过数学建模将问题转化为斐波那契系数方程，实现O(n)时间复杂度。暴力枚举法因数据范围小（n≤20）也可通过，但数学解法更高效、更具普适性。

---

### 高评分题解推荐

#### 1. 作者：朱江黄河（5星）
**关键亮点**：
- 直接建立斐波那契系数方程，代码仅20行
- 利用前缀和分离变量，数学推导清晰
- 代码简洁高效，无冗余逻辑

**核心代码**：
```cpp
int f[25]={0,1};
for(int i=2;i<=n-5;i++) f[i]=f[i-1]+f[i-2];
int b=(m-(f[n-3]+1)*a)/(f[n-2]-1);
printf("%d",(f[x-2]+1)*a+(f[x-1]-1)*b);
```

#### 2. 作者：yubing_lml（5星）
**关键亮点**：
- 通过表格发现斐波那契系数规律
- 建立一元一次方程求解未知数，思路直观
- 代码高度精简，无复杂分支

**核心代码**：
```cpp
int f[20]={1,1};
for(int i=2;i<=n-1;i++) f[i]=f[i-1]+f[i-2];
int b=(m-(f[n-3]+1)*a)/(f[n-2]-1);
cout<<(f[x-2]+1)*a+(f[x-1]-1)*b;
```

#### 3. 作者：诗乃（4星）
**关键亮点**：
- 详细推导系数关系，给出完整公式
- 处理边界条件清晰，代码鲁棒性强
- 包含调试经验："第二站可能上0人"的提醒

**核心代码**：
```cpp
int fibo[21]={0,1,1};
for(int i=3;i<n;i++) fibo[i]=fibo[i-1]+fibo[i-2];
int b=(m-(fibo[n-3]+1)*a)/(fibo[n-2]-1);
printf("%d",(fibo[x-2]+1)*a+(fibo[x-1]-1)*b);
```

---

### 关键思路与技巧
1. **斐波那契建模**：发现上车人数的系数形成斐波那契数列
2. **变量分离**：将a和b的系数独立计算，建立线性方程
3. **数学优化**：通过递推公式直接计算系数，避免模拟过程
4. **边界处理**：特判n≤5的情况，保证公式普适性

---

### 拓展练习推荐
1. **P1255 数楼梯**（斐波那契递推+高精度）
2. **P1002 过河卒**（二维递推+路径计数）
3. **P1028 数的计算**（递推关系+记忆化）

---

### 调试经验摘录
> "在考试中若无法立即发现规律，可先写暴力解法，再通过输出结果寻找递推模式" ——昊蒻  
> "注意第二站可能上下车0人，枚举时要从0开始" ——lcx64579  
> "最后一站人数计算要回溯到n-1站" ——Jack2015633  

这些经验强调：暴力解法可作为调试工具，边界条件的全面考虑是解题关键。

---
处理用时：58.43秒
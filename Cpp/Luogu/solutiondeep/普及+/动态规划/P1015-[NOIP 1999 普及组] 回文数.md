# 题目信息

# [NOIP 1999 普及组] 回文数

## 题目描述

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。

又如：对于十进制数 $87$：

STEP1：$87+78=165$  
STEP2：$165+561=726$  
STEP3：$726+627=1353$   
STEP4：$1353+3531=4884$  

在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。

写一个程序，给定一个 $N$（$2 \le N \le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。

## 样例 #1

### 输入

```
10
87
```

### 输出

```
STEP=4
```

# AI分析结果



### 综合分析与结论
本题解集呈现多种高精度处理方法，核心在于模拟N进制加法与回文判断。多数题解采用字符串或数组存储大数，重点处理进位逻辑和16进制转换。较优解法通过模块化设计提升可维护性，使用STL简化代码。普遍存在的问题是16进制处理不完整、进位逻辑冗余。

---

### 精选题解分析

#### 1. Haishu（★★★★☆）
**关键亮点**  
- 模块化设计：拆分回文判断(add)和加法运算(pd)为独立函数  
- 高精度处理：动态处理进位和前导零  
- 错误反思：强调不能利用数据漏洞的编程伦理  
**核心代码**  
```cpp
inline void add() { // 处理反转相加与进位
    for(int i=0;i<l;++i) d[l-i-1]=c[i];
    l+=2; // 预分配进位空间
    for(int i=0;i<l;++i) {
        c[i]+=d[i];
        if(c[i]>=n) c[i+1]++,c[i]-=n;
    }
    while(!c[l-1]) --l; // 去除前导零
}
```

#### 2. hawa130（★★★★☆）
**关键亮点**  
- STL应用：利用reverse实现快速反转  
- 进制统一处理：通过字符转换兼容2-16进制  
- 内存优化：使用vector动态扩展  
**核心实现**  
```cpp
string add(int k, string b) {
    reverse(b.begin(), b.end());
    int carry = 0;
    for(int i=0; i<b.size(); i++) {
        int sum = zhuan(a[i]) + zhuan(b[i]) + carry;
        res[i] = sum%k; // 统一处理N进制
        carry = sum/k;
    }
    if(carry) res += to_char(carry); // 处理最终进位
    reverse(res.begin(), res.end());
}
```

#### 3. Clairad（★★★☆☆）
**独特思路**  
- 错误处理：通过try-catch处理非法输入  
- 十进制中转：先将N进制转十进制处理  
**调试心得**  
> "被16进制坑了75分，必须单独处理字母转换。高精度加法要注意最高位进位，否则全盘皆输"

---

### 关键技巧总结
1. **进制转换技巧**  
- 字符→数值：`c >= 'A' ? c-'A'+10 : c-'0'`  
- 数值→字符：`n > 9 ? 'A'+n-10 : '0'+n`

2. **高精度优化**  
- 预分配进位空间（如Haishu的l+=2）  
- 动态调整长度避免冗余计算

3. **回文判断优化**  
- 双指针法：i从首开始，j从尾开始，相遇时终止  
- STL法：`s == string(s.rbegin(), s.rend())`

---

### 推荐练习题
1. P1017 进制转换（负进制处理）
2. P1604 B进制星球（高精度加减乘除）
3. P1022 计算器的改良（表达式解析+进制转换）

### 个人心得摘录
1. **Haishu**  
> "曾错误使用long long水过，这是对算法本质的误解。高精度必须严谨处理每位计算"

2. **Strong_Jelly**  
> "将反转数直接存入新数组，避免修改原数组导致逻辑混乱，这是模块化的优势"

3. **Yo_haor**  
> "十六进制转换忘记处理字母导致WA，用isdigit()和字符范围判断更可靠"

---
处理用时：49.32秒
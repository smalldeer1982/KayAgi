# 题目信息

# [NOIP 2000 提高组] 单词接龙

## 题目背景

注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

NOIP2000 提高组 T3

## 题目描述

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。


## 说明/提示

样例解释：连成的“龙”为 `atoucheatactactouchoose`。

$n \le 20$。

## 样例 #1

### 输入

```
5
at
touch
cheat
choose
tact
a
```

### 输出

```
23
```

# AI分析结果



### 综合分析与结论
本题解通过DFS枚举所有可能的单词连接方式，核心难点在于正确处理单词间的重叠部分，并确保每个单词使用不超过两次。正确的解法需要遍历所有可能的重叠长度，并递归尝试每个可能性。RyanLi的题解通过遍历所有可能的j值确保不漏解，而另一题解因check函数设计问题可能导致漏解。最终，DFS的正确实现需要精确处理子串比较与回溯。

---

### 所选题解详情

#### 题解作者：RyanLi（⭐️⭐️⭐️⭐️⭐️）
**关键亮点**  
1. 简洁的DFS实现，直接传递当前龙字符串，避免复杂状态管理。  
2. 正确遍历所有可能的重叠长度（`j`的范围为 `1 ≤ j < min(len1, len2)`），确保不漏解。  
3. 使用 `vis` 数组记录使用次数，回溯逻辑清晰。  

**核心代码**  
```cpp
void dfs(const string &tmp) {
    ans = max(ans, int(tmp.size()));
    for (int i = 1; i <= n; ++i) {
        if (vis[i] >= 2) continue;
        for (int j = 1; j < min(tmp.size(), s[i].size()); ++j)
            if (tmp.substr(tmp.size() - j) == s[i].substr(0, j)) {
                ++vis[i];
                dfs(tmp + s[i].substr(j));
                --vis[i];
            }
    }
}
```

---

### 最优思路总结
1. **DFS遍历所有可能的连接顺序**，每次递归传递当前拼接后的字符串。  
2. **枚举所有重叠长度**：对每个可能的单词，检查所有可能的j值（`1 ≤ j < min(当前龙长度，目标单词长度)`）。  
3. **回溯管理使用次数**：通过 `vis` 数组记录单词使用次数，进入递归前增加计数，退出时恢复。  
4. **剪枝优化**：若当前龙长度无法超过已记录的最大值，可提前终止（题解中隐含通过 `ans` 比较实现）。

---

### 拓展与相似题目推荐
1. **P1101 单词方阵**（字符串匹配与搜索方向）  
2. **P1433 吃奶酪**（DFS+状态压缩）  
3. **P1025 数的划分**（DFS剪枝与组合枚举）

---

### 调试与心得摘录
- **关键陷阱**：部分题解错误地仅处理第一个匹配的重叠长度，导致漏解。必须确保遍历所有可能的j值。  
- **代码可读性**：避免过度使用宏定义（如第二个题解中的 `il`、`cst`），保持代码简洁便于调试。  
- **重叠验证**：子串比较时需注意边界（如 `substr` 的起始位置和长度），避免越界错误。

---
处理用时：166.91秒
# 题目信息

# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# AI分析结果



### 综合分析与结论
本题需构建中序遍历为连续序列的加分最大二叉树，核心解法为区间DP。各题解均围绕以下核心思路展开：
1. **状态设计**：定义 `f[i][j]` 表示节点 `i` 到 `j` 构成子树的最大加分。
2. **转移方程**：枚举根节点 `k`，`f[i][j] = max(f[i][k-1] * f[k+1][j] + a[k])`。
3. **记录路径**：通过 `root[i][j]` 记录最优根节点，递归输出前序遍历。
4. **边界处理**：空子树加分设为1，叶节点初始化。

### 高分题解推荐

#### 1. 冒泡ioa（5星）
**关键亮点**：
- 清晰解释区间DP的阶段性与无后效性，适合新手理解。
- 代码简洁高效，通过区间长度枚举实现自底向上递推。
- 预处理 `f[i][i-1]=1` 巧妙处理空子树。

**核心代码**：
```cpp
for (int len = 1; len < n; ++len) {
    for (int i = 1; i + len <= n; ++i) {
        int j = i + len;
        f[i][j] = f[i + 1][j] + f[i][i]; // 默认左子树为空
        root[i][j] = i;
        for (int k = i + 1; k < j; ++k) {
            if (f[i][j] < f[i][k-1] * f[k+1][j] + f[k][k]) {
                f[i][j] = ...; // 更新最大值
                root[i][j] = k;
            }
        }
    }
}
```

#### 2. winmt（4星）
**关键亮点**：
- 采用记忆化搜索实现，更贴近树形结构思维。
- 详细讨论递归与动态规划的结合，适合理解重叠子问题。
- 提供多语言代码对比，增强可读性。

**核心代码**：
```cpp
long long search(int L, int r) {
    if (L > r) return 1;
    if (f[L][r] == -1) {
        for (int k = L; k <= r; ++k) {
            long long now = search(L, k-1) * search(k+1, r) + a[k];
            if (now > f[L][r]) {
                f[L][r] = now;
                root[L][r] = k;
            }
        }
    }
    return f[L][r];
}
```

#### 3. 噬月（4星）
**关键亮点**：
- 深入分析边界条件（如空子树处理）。
- 讨论等号对前序遍历的影响，强调枚举顺序的重要性。
- 验证局部不全面计算不影响全局最优，增强算法正确性理解。

**个人心得**：
> "当k取区间端点时，默认处理可能忽略子树，但后续阶段会修正结果。这种局部不全面不影响全局最优。"

---

### 关键思路与技巧总结
1. **区间DP框架**：以连续区间表示子树，枚举根节点分治。
2. **空子树处理**：初始化 `f[i][i-1] = 1`，简化边界判断。
3. **路径记录**：二维数组 `root` 保存最优根，递归输出前序。
4. **递推方向**：按区间长度从小到大递推，或记忆化搜索。

### 拓展练习推荐
1. **合并石子**（P1880） - 区间DP经典问题。
2. **凸多边形的划分**（P4342） - 区间DP结合高精度。
3. **树形DP：选课**（P2014） - 树形依赖背包问题。

---
处理用时：46.95秒
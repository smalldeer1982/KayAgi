# 题目信息

# [NOIP 2006 普及组] 明明的随机数

## 题目描述

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。


## 说明/提示

NOIP 2006 普及组 第一题


## 样例 #1

### 输入

```
10
20 40 32 67 40 20 89 300 400 15
```

### 输出

```
8
15 20 32 40 67 89 300 400
```

# AI分析结果



### 综合分析与结论
本题核心在于处理「去重+排序」，各题解围绕数据范围小的特点（n≤100，数值≤1000）展开。主要解法可分为三类：
1. **桶排序法**：利用值域范围小的特点，用数组直接标记存在性，天然完成去重和排序（qr小盆友、Stars_Traveller等）
2. **STL容器法**：通过`set`自动去重排序，或`sort+unique`组合处理（mcturtle、Erina）
3. **排序后遍历去重**：先排序再通过比较相邻元素实现去重（2023z、jscaj0921）

### 高星题解推荐
#### 1. qr小盆友（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 桶排序的巧妙应用，利用布尔数组标记存在性  
- 时间复杂度O(n+m)（n为输入数量，m=1000），空间换时间的典型优化  
- 代码简洁，逻辑清晰（先统计存在性，再遍历输出）

**核心代码**：
```cpp
bool book[1001]={0};
for(int i=0;i<n;i++) {
    cin>>a[i];
    if(book[a[i]]==0) final++;
    book[a[i]]=1; // 标记存在性
}
for(int i=1;i<=1000;i++) // 按值域顺序输出
    if(book[i]) cout<<i<<" ";
```

#### 2. mcturtle（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 利用`set`容器的自动去重和排序特性  
- 代码极其简洁，仅需5行核心逻辑  
- 时间复杂度O(n log n)，但数据量小时效率依然优秀

**核心代码**：
```cpp
set<int> s;
while(n--) {
    int x; cin>>x;
    s.insert(x); // 自动去重排序
}
cout<<s.size()<<endl;
for(auto it:s) cout<<it<<" ";
```

#### 3. Erina（⭐⭐⭐⭐）
**关键亮点**：  
- 组合使用`sort`和`unique`实现去重  
- 展示STL函数的灵活应用，适合学习标准库用法  
- 需注意`unique`仅处理相邻重复元素，必须预先排序

**核心代码**：
```cpp
sort(mem.begin(), mem.end());
auto it = unique(mem.begin(), mem.end()); // 返回去重后末尾
mem.resize(distance(mem.begin(), it));    // 调整容器大小
```

---

### 最优思路提炼
**核心技巧**：  
1. **值域敏感选择**：当数值范围较小时（如本题1000），优先考虑桶排序（O(n)时间）  
2. **STL特性利用**：`set`自动排序去重、`sort+unique`组合，适合快速解题  
3. **遍历去重条件**：排序后只需比较相邻元素，避免复杂去重逻辑

**同类型题目推荐**：  
1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)  
2. [P1309 瑞士轮](https://www.luogu.com.cn/problem/P1309)（排序应用）  
3. [P1781 宇宙总统](https://www.luogu.com.cn/problem/P1781)（特殊排序+去重）

---

### 题解中的调试经验
1. **qr小盆友**：强调桶排序的标记思想，通过图示解释桶的运作机制  
2. **2023z**：指出错误代码中将重复元素赋0的陷阱（后续重复元素未被排除）  
3. **jscaj0921**：提醒排序后需比较`a[i] != a[i-1]`而非`a[i] != a[i+1]`，避免逻辑错误  
**总结**：去重时需注意元素覆盖的边界情况，推荐使用「正向保留」而非「反向标记」策略。

---
处理用时：54.90秒
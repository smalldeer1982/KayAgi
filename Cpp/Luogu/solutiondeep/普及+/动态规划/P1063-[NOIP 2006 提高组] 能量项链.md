# 题目信息

# [NOIP 2006 提高组] 能量项链

## 题目描述

在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链。在项链上有 $N$ 颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为 $m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m \times r \times n$（Mars 单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。

需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。

例如：设 $N=4$，$4$ 颗珠子的头标记与尾标记依次为 $(2,3)(3,5)(5,10)(10,2)$。我们用记号 $\oplus$ 表示两颗珠子的聚合操作，$(j \oplus k)$ 表示第 $j,k$ 两颗珠子聚合后所释放的能量。则第 $4$，$1$ 两颗珠子聚合后释放的能量为：

$(4 \oplus 1)=10 \times 2 \times 3=60$。

这一串项链可以得到最优值的一个聚合顺序所释放的总能量为：

$(((4 \oplus 1) \oplus 2) \oplus 3)=10 \times 2 \times 3+10 \times 3 \times 5+10 \times 5 \times 10=710$。

## 说明/提示

NOIP 2006 提高组 第一题


## 样例 #1

### 输入

```
4
2 3 5 10
```

### 输出

```
710```

# AI分析结果



### 综合分析与结论
该题是典型的环形区间DP问题，核心在于将环拆为链处理，通过区间动态规划枚举合并分界点。所有题解均围绕以下核心思路展开：
1. **破环成链**：复制数组一倍长度（如`a[i+n] = a[i]`）
2. **状态定义**：`dp[l][r]`表示合并区间`[l,r]`的最大能量
3. **转移方程**：`dp[l][r] = max(dp[l][k] + dp[k+1][r] + a[l]*a[k+1]*a[r+1])`
4. **答案获取**：遍历所有起点求长度为n的区间最大值

题解差异主要体现在代码实现细节（循环顺序、边界处理）和讲解侧重点（理论推导/代码技巧）。

---

### 高评分题解推荐
#### 1. 作者：voilin（⭐⭐⭐⭐⭐）
**核心亮点**：
- 代码简洁高效，循环设计巧妙（逆向遍历j）
- 关键注释清晰，状态转移解释到位
- 链式处理与最大值更新融为一体
```cpp
for(int i=2;i<2*n;i++){  // 逆向遍历区间终点
    for(int j=i-1;j>=1;j--){ 
        for(int k=j;k<i;k++) // 枚举分界点
            s[j][i]=max(s[j][i],s[j][k]+s[k+1][i]+e[j]*e[k+1]*e[i+1]);
        if(s[j][i]>maxn)maxn=s[j][i]; // 实时更新最大值
    }
}
```

#### 2. 作者：qhr2023（⭐⭐⭐⭐）
**核心亮点**：
- 代码极简（仅15行核心逻辑）
- 循环变量命名清晰（len/l/r/k）
- 链式处理与答案获取分离，逻辑清晰
```cpp
for(int len=2; len<=n*2; ++len) 
    for(int l=1; l+len-1<=n*2; ++l) {
        int r=l+len-1;
        for(int k=l; k<r; ++k) 
            f[l][r]=max(f[l][r], f[l][k]+f[k+1][r]+a[l]*a[k+1]*a[r+1]);
    }
```

#### 3. 作者：Seauy（⭐⭐⭐⭐）
**核心亮点**：
- 独特的记忆化搜索实现
- 递归边界处理清晰（Next/Last指针）
- 强调递归效率问题（考试慎用）
```cpp
int DFS(int L,int R) {
    if(dp[L][R]) return dp[L][R];
    for(int i=L; i!=R; i=Next(i)) // 环形遍历
        cnt=max(cnt, DFS(L,i)+DFS(Next(i),R) + val[L]*val[Next(i)]*val[Next(R)]);
    return dp[L][R]=cnt;
}
```

---

### 关键技巧总结
1. **环形处理技巧**：复制数组实现`a[1..2n]`，答案取所有`dp[i][i+n-1]`的最大值
2. **区间DP模板**：
   ```cpp
   for(int len=2; len<=n; len++)        // 区间长度
       for(int l=1; l+len-1<=2n; l++){ // 起点
           int r = l+len-1;
           for(int k=l; k<r; k++)      // 分界点
               dp[l][r] = max(...);
       }
   ```
3. **状态转移优化**：存储头尾标记，避免重复计算（如`head[i]=a[i], tail[i]=a[i+1]`）

---

### 同类题目推荐
1. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)（环形区间DP）
2. [P1040 [NOIP2003] 加分二叉树](https://www.luogu.com.cn/problem/P1040)（区间DP+树形结构）
3. [P4342 [IOI1998] Polygon](https://www.luogu.com.cn/problem/P4342)（环形DP+运算符处理）

---

### 题解心得很录
1. **voilin**：  
   > "重点将整体划分为区间，小区间合并获得大区间。转移时注意合并产生能量=左头*右头*总区间后珠"  
   ——强调区间分割与能量计算的关系

2. **Seauy**：  
   > "CCF用老年评测机，递归效率低，考试尽量写递推"  
   ——重要实战经验：递归DP在OJ可行但比赛需谨慎

3. **DengDuck**：  
   > "定义f[l][r]为最后剩l,r时的最优解，逆向思维从后往前删"  
   ——提供逆向思维的区间定义方式

---
处理用时：54.68秒
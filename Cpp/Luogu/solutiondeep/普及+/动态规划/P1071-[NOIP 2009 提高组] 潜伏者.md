# 题目信息

# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# AI分析结果



### 综合分析与结论
本题需验证加密规则的合法性（双射、全覆盖）并翻译密文。正确题解需确保：密文→原文唯一、原文→密文唯一、覆盖所有26字母。以下题解以双向映射检查为核心，正确性高且代码清晰。

---

### 精选题解

#### 1. 题解作者：CYJian（⭐⭐⭐⭐⭐）
**关键亮点**：
- 使用双向`map`（密文↔原文）确保双射关系。
- 即时检查冲突，处理输入长度不足的情况。
- 变量命名清晰，逻辑严谨。

**核心代码**：
```cpp
map<char,char> mp, mq; // 双向映射
for(int i=0; i<la; i++) {
    if (mp[a[i]] && mp[a[i]] != b[i]) ERROR; // 密文冲突检查
    if (mq[b[i]] && mq[b[i]] != a[i]) ERROR; // 原文冲突检查
    mp[a[i]] = b[i], mq[b[i]] = a[i];
}
```

#### 2. 题解作者：lianghuahua（⭐⭐⭐⭐⭐）
**关键亮点**：
- 结合`map`和`set`，分别记录密文映射和已用原文。
- 高效判断重复映射，代码简洁。
- 明确处理三种错误状态。

**核心代码**：
```cpp
map<char, char> mp; // 密文→原文
set<char> st;       // 已用原文
for (int i = 0; i < s1.size(); i++) {
    if (mp.count(s1[i]) && mp[s1[i]] != s2[i]) ERROR; // 密文冲突
    if (st.count(s2[i])) ERROR;                       // 原文重复
    mp[s1[i]] = s2[i], st.insert(s2[i]);
}
```

#### 3. 题解作者：qhr2023（⭐⭐⭐⭐）
**关键亮点**：
- 使用数组替代`map`，提升效率。
- 全局数组自动初始化为0，简化代码。
- 紧凑的条件判断处理冲突。

**核心代码**：
```cpp
char mp[128], vis[128]; // ASCII直接映射
for (int i = 0; a[i]; i++) {
    if (vis[b[i]] && mp[a[i]] != b[i]) ERROR; // 冲突检查
    mp[a[i]] = b[i], vis[b[i]] = 1;
}
```

---

### 最优思路总结
**关键技巧**：
1. **双向映射验证**：确保每个密文对应唯一原文，反之亦然。
2. **即时冲突检测**：遍历时直接检查而非最后统一处理，减少复杂度。
3. **覆盖检查**：最后遍历A-Z确保所有字母参与映射。

**拓展应用**：
- 类似双射问题（如密码学、编码转换）可复用此双向检查思路。
- 数组替代`map`适用于有限字符集（如ASCII），提升效率。

---

### 推荐题目
1. [P1918 保龄球](https://www.luogu.com.cn/problem/P1918)（映射与查询）
2. [P1093 奖学金](https://www.luogu.com.cn/problem/P1093)（多规则排序）
3. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)（字符串处理与贪心）

---
处理用时：170.45秒
# 题目信息

# [NOIP 2007 提高组] 树网的核

## 题目描述

设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。

路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 
$d(a, b)$ 为 $a, b$ 两结点间的距离。

$D(v, P)=\min\{d(v, u)\}$, $u$ 为路径 $P$ 上的结点。

树网的直径：树网中最长的路径成为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

偏心距 $\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即

$$\mathrm{ECC}(F)=\max\{D(v, F),v \in V\}$$

任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)


## 说明/提示

- 对于 $40\%$ 的数据，保证 $n \le 15$。
- 对于 $70\%$ 的数据，保证 $n \le 80$。
- 对于 $100\%$ 的数据，保证 $2\le n \le 300$，$0\le s\le10^3$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^3$。

NOIP2007 提高组第四题

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```

### 输出

```
5```

# AI分析结果



### 综合分析与结论

题目要求找到树网中某直径上的路径，使得长度≤s且偏心距最小。各题解主要围绕以下思路展开：
1. **暴力枚举路径+DFS计算偏心距**（O(n³)），适用于小数据。
2. **双指针优化枚举**（O(n²)），减少候选路径数量。
3. **二分答案+单调队列维护区间最大值**（O(n log sum w)），将最优化转为判定问题。
4. **预处理关键信息+双指针滑动窗口**（O(n)），利用直径性质快速计算偏心距。

最优解法为预处理直径信息后通过双指针滑动窗口高效求解，时间复杂度最低且代码简洁。

---

### 高星题解推荐

#### 1. StudyingFather（5星）
**关键亮点**：
- 深入分析树的性质（如直径必交、中点唯一），证明充分。
- 提出四种解法逐步优化，最终达到O(n)复杂度。
- 核心思路：预处理直径各点支链最大值，用双指针维护区间，只需比较端点贡献与最大支链。

**核心代码**：
```cpp
namespace sub4 {
void solve() {
  // 预处理直径各点最大支链长度maxd
  int maxd = 0;
  for (int i = 1; i <= cnt; i++) {
    dfs(dia[i], 0); // 计算以dia[i]为根的支链最大值
    maxd = max(dep[c], maxd);
  }
  // 双指针滑动窗口
  int l = 1, r = 1, minecc = INF;
  for (; l <= cnt; l++) {
    while (r <= cnt && pres[r] - pres[l] <= s) r++;
    // 偏心距由maxd、左端到起点、右端到终点三者决定
    minecc = min(max(maxd, max(pres[l], posts[r-1])), minecc);
  }
  cout << minecc;
}
}
```

#### 2. Mosklia（5星）
**关键亮点**：
- 通过两次DFS求直径，用单调队列维护区间最大值。
- 利用直径端点贡献特性，将偏心距拆解为端点贡献与支链最大值。
- 代码实现简洁高效，适合竞赛快速编码。

**核心代码**：
```cpp
int maxd = 0;
// 预处理各点支链最大值
for (int i=1; i<=m; i++) 
    maxd = max(dfs2(del[i]), maxd);
// 双指针滑动窗口计算
deque<int> q;
for (int i=1,j=1; i<=m; i++) {
    while (区间长度超s) j++;
    while (维护单调队列) q.pop_back();
    q.push_back(i);
    // 计算当前窗口的max(端点贡献, 队列最大支链)
    ans = min(ans, max(maxd, max(dist1, dist2)));
}
```

#### 3. 天泽龟（4星）
**关键亮点**：
- 二分答案思路独特，处理边界问题详细。
- 需注意支链对偏心距的影响，正确设置二分上下界。
- 时间复杂度O(n log sum w)，适合更大数据但代码较复杂。

---

### 关键思路总结

1. **直径性质**：任意直径必相交，预处理直径后只需考虑其上的路径。
2. **偏心距组成**：路径端点至直径端点的距离最大值，与路径上节点的最大支链长度。
3. **双指针滑动窗口**：在直径上维护长度≤s的区间，动态计算偏心距。

### 拓展建议

- **同类型题**：树的直径相关（如P2491 [SCOI2008] 防线）、双指针优化（如P1099的扩展数据版）。
- **技巧迁移**：预处理关键信息+滑动窗口适用于最优化问题，如子区间极值、最短覆盖等。

---

### 推荐题目
1. **P2491 [SCOI2008] 防线**  
   考察树的直径与路径优化，需结合二分答案。
2. **P4381 [IOI2008] Island**  
   基环树直径问题，训练树网类问题扩展。
3. **P3304 [SDOI2013] 直径**  
   求直径必经边，强化对直径性质的理解。

---
处理用时：64.12秒
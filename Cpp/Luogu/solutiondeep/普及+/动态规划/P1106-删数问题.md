# 题目信息

# 删数问题

## 题目描述

键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。

## 说明/提示

用 $\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \leq k < \operatorname{len}(n) \leq 250$。

## 样例 #1

### 输入

```
175438 
4
```

### 输出

```
13```

# AI分析结果



### 综合分析与结论
本题核心为贪心策略，关键点在于：**通过局部最优（高位尽可能小）实现全局最优**。所有题解均围绕此展开，差异体现在贪心实现方式、删除范围确定、前导零处理及数据结构优化上。

### 高星题解推荐
#### 1. 作者：expin ★★★★★
**关键亮点**  
- 贪心策略：每次在可删范围内（m+1位）选最小数作为当前最高位，确保后续保留更多可选空间。  
- 动态调整范围：`k`更新后缩小搜索范围，复杂度O(n)。  
- 前导零处理：通过`flag`标记首个非零位，避免无效零输出。  

**核心代码**  
```cpp
while(cnt<rest){ // 需要保留rest位
    minp=t;
    for(int i=t;i<=k+t;++i) // 在t到k+t范围内找最小数
        if(a[minp]>a[i]) minp=i;
    if(a[minp]) flag=1; // 标记已输出非零数
    if(flag) cout<<a[minp];
    k -= minp-t; // 更新剩余可删数
    t=minp+1; // 移动起点
    cnt++;
}
```

#### 2. 作者：Sol1 ★★★★☆  
**关键亮点**  
- 双向链表优化：通过`prev/next`指针实现O(1)删除，避免字符串频繁拷贝。  
- 跳跃删除：当某数比后数大时，直接跳跃删除其所有前驱大数。  
- 空间效率：仅需线性空间，适合超长数字处理。  

**个人心得**  
> "删一个数就会删掉它，每个数最多被删一次，均摊复杂度O(n)" —— 点明算法效率关键。

#### 3. 作者：修罗海神王 ★★★★  
**关键亮点**  
- 逆向思维：将删k数转化为选(n-k)数，确保每次选择局部最小。  
- 前导零处理：循环结束后统一去除，逻辑清晰。  
- 代码简洁：仅需单层循环，适合快速实现。

### 关键技巧总结
1. **贪心范围控制**：在`k+1`长度窗口内选最小值（expin），避免过早删数限制后续选择。  
2. **链表高效删除**：使用双向链表（Sol1）减少数据移动，适合超长数字场景。  
3. **逆序处理**：转换为选数问题（KesdiaelKen），避免直接删除的复杂操作。  

### 相似题目推荐
1. [P1323 删数问题](https://www.luogu.com.cn/problem/P1323) - 变种题，需删除特定规则下的数  
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心策略选择最小代价  
3. [P2878 删数游戏](https://www.luogu.com.cn/problem/P2878) - 动态规划与贪心结合应用

---
处理用时：51.69秒
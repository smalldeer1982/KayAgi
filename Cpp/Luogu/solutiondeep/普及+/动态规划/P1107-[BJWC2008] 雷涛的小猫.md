# 题目信息

# [BJWC2008] 雷涛的小猫

## 题目背景

原最大整数参见 P1012

## 题目描述

雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫（当然，这样的行为是违反学生宿舍管理条例的）。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。

可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆…

在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有 $N$ 棵。并且这 $N$ 棵柿子树每棵的高度都是 $H$。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。

小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳 $1$ 单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降 `Delta` 单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。

雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。

图为 $N=3, H=10, Delta=2$ 的一个例子。小猫按照图示路线进行跳跃，可以吃到最多的 $8$ 个柿子。

![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \leq N, H ≤ 2000$，$0 \leq N_i ≤ 5000$，$1 ≤ Delta ≤ N,1 ≤ T_{i,j} ≤ H$。

输入文件大小不大于 40MB。注意输入输出效率。

来源 Excalibur, 2008。

## 样例 #1

### 输入

```
3 10 2
3 1 4 10
6 3 5 9 7 8 9
5 4 5 3 6 9```

### 输出

```
8```

# AI分析结果



### 综合分析与结论
本题需用动态规划求解，核心优化思路是通过预处理每层最大值将复杂度从O(n³)降至O(n²)。各题解普遍采用状态转移方程`dp[i][j] = max(同树下落, 跨层跳跃最大值) + 当前柿子数`，并通过维护最大值数组避免重复计算。

---

### 高星题解推荐

#### 1. 作者：issue_is_fw（★★★★★）
**关键亮点**：
- 从暴力DP推导到优化思路清晰，对比n³与n²实现差异
- 引入`pre[]`数组预存每层跳跃最大值，代码简洁高效
- 完整代码展示优化前后的对比，便于理解

**核心代码**：
```cpp
int dp[5009][2009], pre[2009]; // pre[j]存储高度j的全局最大值
for(int j=h; j>=0; j--) {
    for(int i=1; i<=n; i++) {
        dp[i][j] = a[i][j] + dp[i][j+1]; // 同树下落
        dp[i][j] = max(dp[i][j], pre[j+de] + a[i][j]); // 跨层跳跃
        pre[j] = max(pre[j], dp[i][j]); // 更新当前层最大值
    }
}
```

#### 2. 作者：良辰何需美景（★★★★）
**关键亮点**：
- 分步拆解优化思路，解释为何需要维护`ret[]`数组
- 代码结构清晰，注释明确，适合新手学习
- 输出直接使用预处理数组`ret[h]`，省去最终遍历

**核心代码**：
```cpp
int ret[2005]; // ret[j]表示高度j时的全局最大值
for(int j=1; j<=h; j++) {
    for(int i=1; i<=n; i++) {
        if(j>d) f[i][j] = max(f[i][j-1], ret[j-d]) + a[i][j];
        else f[i][j] = f[i][j-1] + a[i][j];
        ret[j] = max(ret[j], f[i][j]); // 动态更新最大值
    }
}
```

#### 3. 作者：sxyugao（★★★★）
**关键亮点**：
- 结合前驱思路详细推导，强调跨层跳跃的固定性
- 代码中`g[]`数组的维护过程注释清晰
- 使用快读处理输入，适配大数据量

**核心代码**：
```cpp
int g[2005]; // g[i]表示高度i时的最大值
for(int i=1; i<=h; i++) {
    for(int j=1; j<=n; j++) {
        f[i][j] = f[i-1][j] + a[j][i];
        if(i>d) f[i][j] = max(f[i][j], g[i-d] + a[j][i]);
        g[i] = max(g[i], f[i][j]); // 实时更新最大值
    }
}
```

---

### 最优思路总结
**关键技巧**：维护每层全局最大值数组（如`pre[]`、`ret[]`、`g[]`），在跨层跳跃时直接取该值，避免遍历所有树。  
**思维模式**：将状态转移中的重复计算部分抽象为全局信息，通过预处理或动态更新降低复杂度。  
**代码实现**：倒序枚举高度，确保在计算当前层时已处理完上层状态。

---

### 拓展与举一反三
1. **同类题目推荐**：
   - [P1725 琪露诺](https://www.luogu.com.cn/problem/P1725)（滑动窗口最大值优化DP）
   - [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)（预处理区间极值）
   - [P3572 PTA-Little Bird](https://www.luogu.com.cn/problem/P3572)（单调队列优化）

2. **个人心得摘录**：
   > "被TLE后意识到需要优化，发现跨层跳跃只需取最大值，无需遍历所有树" —— 经验：动态规划中寻找可复用的全局信息。  
   > "维护pre数组时需注意更新顺序，确保当前树计算后再更新" —— 调试教训：状态更新顺序影响正确性。

---
处理用时：57.41秒
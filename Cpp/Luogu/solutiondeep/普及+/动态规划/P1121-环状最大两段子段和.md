# 题目信息

# 环状最大两段子段和

## 题目描述

给出一段长度为 $n$ 的环状序列 $a$，即认为 $a_1$ 和 $a_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
9```

# AI分析结果



### 综合分析与结论
本题核心在于处理环状序列的两段最大子段和，需分两种情况讨论：两段均不跨环或其中一段跨环。主流解法采用动态规划结合前后缀数组，部分题解通过反转符号求最小子段和转化为跨环情况。关键难点在于边界处理（全负数、单正数）及高效维护子段信息。

---

### 优质题解推荐

#### 1. 作者：Develop（★★★★★）
**关键亮点**：
- 系统性覆盖各类子段和变式，深入分析环状处理思路。
- 提出「总和减最小区间和」的巧思，将跨环问题转化为链式问题。
- 代码结构清晰，处理了全负数等边界情况。

**核心代码**：
```cpp
int query(){ // 计算链式两段最大和
    int res = -INF;
    for (int i=1; i<=n; i++) f[i] = max(f[i-1], 0) + a[i]; 
    for (int i=n; i>0; i--)  g[i] = max(g[i+1], 0) + a[i];
    // 维护前后缀最大值后枚举分界点
    for (int i=1; i<n; i++) res = max(res, f[i] + g[i+1]);
    return res;
}
```

#### 2. 作者：I_AM_HelloWord（★★★★☆）
**关键亮点**：
- 通过符号反转复用最大子段和函数求最小和，代码简洁高效。
- 特判仅一个正数的边界条件，避免错误解。

**调试心得**：
> "当将数字负过来时，若只剩一个正数会误选两端，需单独处理。实际测试发现样例4 -1 1 -1 -1时需特判。"

#### 3. 作者：zhy137036（★★★★☆）
**关键亮点**：
- 明确分离非环与环状处理模块，代码模块化程度高。
- 使用独立函数封装最大/最小计算，增强可读性。

**核心代码**：
```cpp
int getmax(int* arr, int l, int(*cmp)(int,int)) {
    for(int i=1; i<=l; i++) f[i] = cmp(f[i-1],0)+arr[i]; 
    // cmp为max或min函数指针，复用同一逻辑
}
```

---

### 最优思路总结
1. **分治环问题**：两段不跨环 → 链式两段最大和；至少一段跨环 → 总和减去链式两段最小和。
2. **前后缀极值维护**：正序/逆序遍历维护前后缀子段极值，实现O(n)复杂度。
3. **符号反转技巧**：将求最小和转化为最大和问题，减少代码冗余。

---

### 举一反三练习
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)  
   **考察点**：基础DP模型，单段最大和。
   
2. [P2642 双子序列最大和](https://www.luogu.com.cn/problem/P2642)  
   **考察点**：链式两段不重叠子段和的DP优化。

3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)  
   **考察点**：单调队列维护区间极值，为子段和变式提供基础。

---
处理用时：56.75秒
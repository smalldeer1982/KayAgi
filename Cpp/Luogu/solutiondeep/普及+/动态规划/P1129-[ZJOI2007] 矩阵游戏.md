# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果



### 综合分析与结论
本题核心在于通过行/列交换使得主对角线全黑，转化为二分图最大匹配问题。各题解均认同以下核心思路：
- 将行视为左部节点，列视为右部节点，黑格为边
- 最大匹配等于n时可行（每行每列都能找到对应的对角点）
- 交换操作不影响最大匹配数性质是解题关键

### 高星题解推荐 (4-5星)

#### 1. 作者：俾斯麦 (5星)
**亮点**：
- 双解对比：详细对比匈牙利与Dinic解法，代码可读性强
- 复杂度分析：清晰说明两种算法适用场景（n=200时Dinic更优）
- 优化技巧：避免memset清空数组，逐个初始化节省时间

**核心代码（匈牙利算法）**：
```cpp
bool dfs(int x) {
    for(int i=head[x], y; i; i=next[i]) 
        if(!vis[y=to[i]]) {
            vis[y] = 1;
            if(!match[y] || dfs(match[y])) {
                match[y] = x; return true;
            }
        }
    return false;
}
```

#### 2. 作者：Night_Aurora (4星)
**亮点**：
- 理论推导清晰：用网络流解释匹配不变性
- 抽象建模：将行列交换视为边的重新连接
- 代码简洁：前向星建图+标准匈牙利实现

**关键图示**：
``` 
初始图            交换后
行1 -> 列3       行1 -> 列1
行2 -> 列1  =>   行2 -> 列3
行3 -> 列2       行3 -> 列2
```

#### 3. 作者：cmwqf (4星)
**亮点**：
- 图示解析：手绘二分图变化过程直观易懂
- 动态演示：通过红边变化说明交换不影响匹配
- 代码优化：邻接矩阵实现，适合小数据量

**核心片段**：
```cpp
for(int i=1; i<=n; i++)
    for(int j=1; j<=n; j++) 
        if(map[i][j]) add(i,j+n);
```

### 关键思路总结
1. **建模技巧**：将矩阵问题转化为图论问题，行列为节点，黑格为边
2. **性质发现**：交换操作等价于节点重标号，不影响匹配数
3. **算法选择**：匈牙利算法(n≤200可行)，Dinic效率更高
4. **优化点**：避免全量清空数组，利用时间戳或局部初始化

### 相似题目推荐
1. P3386 【模板】二分图最大匹配
2. P1963 [NOI2009] 变换序列
3. P2764 最小路径覆盖问题

### 调试经验摘录
- **俾斯麦**："clear()函数中清零时用了多少就清零多少，有效节约memset时间"
- **lemir3**："调了40多分钟发现邻接表初始化问题，前向星需注意tot初始化"
- **707001933K**："dinic模板中未标记不可达节点导致死循环，需添加level[v]=-1判断"

这些经验体现了对算法细节的深入理解和调试时需关注的关键点。

---
处理用时：50.68秒
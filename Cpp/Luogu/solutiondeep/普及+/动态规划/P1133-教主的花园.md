# 题目信息

# 教主的花园

## 题目描述

教主有着一个环形的花园，他想在花园周围均匀地种上 $n$ 棵树，但是教主花园的土壤很特别，每个位置适合种的树都不一样，一些树可能会因为不适合这个位置的土壤而损失观赏价值。

教主最喜欢 $3$ 种树，这 $3$ 种树的高度分别为 $10,20,30$。教主希望这一圈树种得有层次感，所以任何一个位置的树要比它相邻的两棵树的高度都高或者都低，并且在此条件下，教主想要你设计出一套方案，使得观赏价值之和最高。

## 说明/提示

【样例说明】。

第 $1$ 至 $n$ 个位置分别种上高度为 $20,10,30,10$ 的树，价值最高。

【数据规模与约定】。

- 对于 $20\%$ 的数据，有 $n\le 10$；
- 对于 $40\%$ 的数据，有 $n\le 100$； 
- 对于 $60\%$ 的数据，有 $n\le 1000$；
- 对于 $100\%$ 的数据，有 $4\le n\le 10^5$，并保证 $n$ 一定为偶数。

## 样例 #1

### 输入

```
4 
1 3 2 
3 1 2 
3 1 2 
3 1 2
```

### 输出

```
11```

# AI分析结果



### 综合分析与结论
该题核心是环形DP+状态设计，需处理相邻位置高度关系与首尾衔接问题。题解中普遍采用三维状态（位置、当前树高、高低状态），通过枚举首节点状态解决环形限制。关键难点在于状态转移的正确性与环形处理，部分题解因未处理环形导致错误。

---

### 优质题解推荐
#### 1. 作者：juruo_zjc (⭐⭐⭐⭐⭐)
**关键亮点**：
- 状态定义清晰（`dp[i][j][k]`表示位置i种j类树且比相邻高/低）
- 处理环形问题：枚举首节点树类型，初始化后独立DP
- 代码简洁，转移方程明确

**核心代码**：
```cpp
for(int j=0;j<3;j++){ // 枚举首节点类型
  初始化首节点为j类树;
  for(int i=2;i<=n;i++){
    dp[i][0][0] = max(dp[i-1][1][1], dp[i-1][2][1]) + a[i][0]; // 10米树必比相邻低
    dp[i][1][0] = dp[i-1][2][1] + a[i][1]; // 20米比相邻低
    dp[i][1][1] = dp[i-1][0][0] + a[i][1]; // 20米比相邻高
    dp[i][2][1] = max(dp[i-1][1][0], dp[i-1][0][0]) + a[i][2]; // 30米树必比相邻高
  }
  检查尾节点与首节点的合法性并更新答案;
}
```

#### 2. 作者：猪脑子 (⭐⭐⭐⭐)
**关键亮点**：
- 明确指出原题解未处理环形衔接问题
- 通过三次独立DP（枚举首节点类型）确保首尾合法
- 优化代码结构，突出环形处理逻辑

**调试心得**：
> "原代码未考虑首尾相邻，WA后通过枚举首节点状态，每次重置DP数组解决"

---

### 关键思路总结
1. **环形处理**：枚举首节点状态（树类型与高低标志），独立进行链式DP后验证首尾条件。
2. **状态压缩**：第三维仅需0/1表示当前比相邻低/高，结合树高（10/20/30）隐含高低可能性。
3. **转移优化**：针对每类树的物理特性简化转移（如10米树只能作为波谷，30米只能作为波峰）。

---

### 拓展建议
**类似题目套路**：
- 环形DP：P2467 [SDOI2010]地精部落、P1133 教主的花园（本题）
- 相邻约束DP：P1352 没有上司的舞会（树形DP）、P2458 保安站岗

**举一反三**：
当遇到环形约束时，可尝试以下方法：
1. 破环成链：复制序列到2n
2. 枚举首状态：对可能的首节点状态分别DP
3. 二次DP：先任意起点DP，再根据结果调整首尾

---
处理用时：43.99秒
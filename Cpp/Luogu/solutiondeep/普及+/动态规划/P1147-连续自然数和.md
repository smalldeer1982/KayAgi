# 题目信息

# 连续自然数和

## 题目描述

对一个给定的正整数 $M$，求出所有的连续的正整数段（每一段至少有两个数），这些连续的自然数段中的全部数之和为 $M$。

例子：$1998+1999+2000+2001+2002 = 10000$，所以从 $1998$ 到 $2002$ 的一个自然数段为 $M=10000$ 的一个解。


## 样例 #1

### 输入

```
10000
```

### 输出

```
18 142 
297 328 
388 412 
1998 2002
```

# AI分析结果



### 综合分析与结论
题目核心是寻找连续自然数段满足和为M。各题解主要围绕数学推导、双指针、枚举剪枝三类思路展开。最优解法应具备O(√M)时间复杂度，数学分解因式法效率最高，尺取法代码简洁但效率稍低。

---

### 高星题解推荐（≥4星）

#### 1. 作者：gzw2005（★★★★★）
**核心思路**：  
利用数学公式变形，将问题转化为分解2M的因数对(k1,k2)，要求k1和k2奇偶性不同。通过解方程得到首末项，时间复杂度O(√M)。  
**关键优化**：  
- 逆序枚举k1（从√(2M)开始），保证输出顺序正确  
- 仅需检查k1是否为2M因数且奇偶性不同  
**代码亮点**：
```cpp
for(int k1=sqrt(2*m);k1>1;k1--)
    if(2*m%k1==0 && (k1+2*m/k1)%2){
        int k2=2*m/k1;
        cout<<(k2-k1+1)/2<<" "<<(k1+k2-1)/2<<endl;
    }
```

#### 2. 作者：Frenix（★★★★☆）
**核心思路**：  
使用尺取法维护滑动窗口[i,j]，动态调整区间和。时间复杂度O(M)，空间O(1)。  
**关键技巧**：  
- 左指针i仅在sum≥M时右移  
- 右指针j仅在sum<M时扩展  
**代码亮点**：
```cpp
for(int i=1,j=2; i<=m/2; ){
    if(sum==m) {
        printf("%d %d\n",i,j);
        sum -= i++;
    } else if(sum<m) sum += j++;
    else sum -= i++;
}
```

#### 3. 作者：大头（★★★★☆）
**核心思路**：  
通过公式变形M=(2a1+n-1)*n/2，枚举项数n作为2M的因数。时间复杂度O(√M)。  
**数学推导**：  
- 项数n需满足(2M/n -n +1)为偶数  
- 首项计算：(2M/n -n +1)/2  
**代码亮点**：
```cpp
for(int i=2000;i>1;i--)
    if(2*m%i==0 && (2*m/i-i+1)%2==0)
        printf("%d %d\n",(2*m/i-i+1)/2, (2*m/i-i+1)/2+i-1);
```

---

### 关键技巧总结
1. **数学分解法**：将和式转化为因数分解问题，利用奇偶性约束减少计算量  
2. **双指针维护区间和**：通过单调性保证每个元素最多被访问两次  
3. **逆向枚举剪枝**：从√M开始逆序枚举，天然保证输出顺序且减少无效遍历  

---

### 举一反三
1. 类似数学分解：P1075（质因数分解）、P1214（等差数列）  
2. 滑动窗口应用：P1638（寻找区间）、P1712（区间覆盖）  
3. 因数分解变种：P2424（约数和）、P1414（数论分块）  

推荐练习：  
1. P1214 等差数列（数学公式推导）  
2. P1638 逛画展（双指针经典）  
3. P1414 又是毕业季II（因数分解应用）  

---

### 题解中的调试心得
1. **大头**：强调公式推导中需注意整型除法，通过验证(2M/n -n +1)的奇偶性避免错误  
2. **zzozz**：调试时发现忘记处理sqrt结果取整，通过添加floor(x)判断解决  
3. **樱式分解**：在剪枝条件(sum >n) break中发现暴力枚举也能通过，强调合理剪枝的重要性

---
处理用时：48.13秒
# 题目信息

# Peter 的烟

## 题目背景

**温馨提醒：吸烟有害健康，请勿尝试吸烟！**

## 题目描述

Peter 有 $n$ 根烟，他每吸完一根烟就把烟蒂保存起来，$k$（$k>1$）个烟蒂可以换一个新的烟，那么 Peter 最终能吸到多少根烟呢？

与某些脑筋急转弯不同的是，Peter 并不能从异次元借到烟蒂，抽完后再还回去。

## 说明/提示

对于 $100\%$ 的数据，$1<n, k \le 10^8$。


## 样例 #1

### 输入

```
4 3
```

### 输出

```
5```

## 样例 #2

### 输入

```
10 3```

### 输出

```
14```

# AI分析结果



### 题目分析与结论
该题本质是烟蒂循环兑换问题，核心在于如何正确处理"兑换后新增烟蒂"的循环逻辑。最优解法需通过数学建模推导出O(1)公式，避免模拟带来的时间开销。关键难点在于理解最终烟蒂数需扣除最后一根烟的烟蒂，推导出总烟数x满足 x = n + (x-1)/k 的方程。

---

### 高分题解推荐（评分≥4星）

#### 1. WuYongxuan 题解（★★★★★）
**核心思路**：通过数学建模将问题转化为公式 `n + (n-1)/(k-1)`
```cpp
cout << n + (n-1)/(k-1);
```
**亮点**：代码极简，时间复杂度O(1)，完美适配1e8数据规模  
**心得**：将k烟蒂=1根烟+1烟蒂的关系转化为(k-1)烟蒂=1根烟，规避边界处理

#### 2. fifnmar 题解（★★★★☆）
**核心思路**：建立方程推导最终解，数学过程清晰
```cpp
x = (n*k-1)/(k-1) → n + (n-1)/(k-1)
```
**亮点**：详细展示方程推导过程，辅助理解公式来源  
**心得**：强调最终烟蒂数应扣除最后一根烟的烟蒂，避免逻辑错误

#### 3. John_Nash 题解（★★★★☆）
**核心思路**：用整数除法特性处理公式，避免浮点误差
```cpp
printf("%d\n", ((long long)n*k-1)/(k-1));
```
**亮点**：显式处理大数相乘溢出问题，增加代码鲁棒性  
**心得**：明确指出不允许借烟蒂与允许借烟蒂的区别，强化题意理解

---

### 最优解题技巧总结
**关键公式**：`总烟数 = n + (n-1)/(k-1)`  
**推导要点**：
1. 总烟蒂数 = 总烟数 - 1（最后一根烟的烟蒂不可用）
2. 兑换次数 = (总烟数-1)/k = 总烟数 - n
3. 通过方程变形消去分母，得到线性关系

**实现技巧**：  
- 使用整数除法自动向下取整的特性  
- 用(long long)防止乘法溢出  
- 避免循环结构处理1e8级数据

---

### 举一反三
**同类问题特征**：  
资源循环兑换、余数重复利用、数学建模替代模拟  
**推荐练习**：  
1. P1089 津津的储蓄计划（余数累计计算）  
2. P3741 honoka的键盘（字符模式循环判断）  
3. P1469 找筷子（异或特性替代计数）

---

### 题解心得摘录
1. "最后一根烟的烟蒂不能用来换烟"（fifnmar）  
   → 强调边界条件的处理重要性  
2. "三次加法比乘法省时间"（fifnmar）  
   → 展现底层优化思维  
3. "显式处理大数相乘溢出"（John_Nash）  
   → 数值范围敏感性的典范

---
处理用时：43.55秒
# 题目信息

# 书的复制

## 题目背景

大多数人的错误原因：尽可能让前面的人少抄写，如果前几个人可以不写则不写，对应的人输出 `0 0` 。

不过，已经修改数据，保证每个人都有活可干。

## 题目描述

现在要把 $m$ 本有顺序的书分给 $k$ 个人复制（抄写），每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的，比如不能把第一、第三、第四本书给同一个人抄写。

现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。

## 说明/提示

$1\le k \le m \le 500$。

## 样例 #1

### 输入

```
9 3
1 2 3 4 5 6 7 8 9
```

### 输出

```
1 5
6 7
8 9
```

# AI分析结果



### 综合分析与结论
该题核心是求最大区间和的最小值，存在两种主流解法：二分答案与动态规划。题解普遍关注以下难点：
1. 如何确定最小化最大区间的思路（二分答案的单调性证明/DP状态设计）
2. 输出方案时如何满足"前面的人少抄"的约束（倒序贪心分配）
3. 边界条件处理（如单本书超过阈值的情况）

### 高分题解推荐（≥4星）

#### 1. MuelsyseU（五星）
**亮点**：
- 二分答案思路清晰，配套完整理论推导
- 独创性使用倒序遍历生成分配方案
- 处理边界条件时巧妙设置虚拟书本
```cpp
// 关键代码：二分检验函数
bool check(int s) {
    int num=1,t=0;
    for(int i=n;i>=1;i--) { // 逆序分配关键点
        if(t+a[i]>s) t=0,num++;
        t += a[i];
    }
    return num<=m;
}
```

#### 2. Star_Wind（四星）
**亮点**：
- 逆向思维DFS实现动态规划方案输出
- 利用前缀和优化时间复杂度
```cpp
// 关键代码：DFS回溯输出方案
void dfs(int k,int t) {
    if(k==0) return;
    int p = t, s1 = a[p];
    while(s1 <= f[n][m]) { // 贪心寻找分割点
        p--; s1 += a[p];
    }
    dfs(k-1,p);
    cout<<p+1<<" "<<t<<endl;
}
```

#### 3. 路依然远（四星）
**亮点**：
- 使用尺取法简化代码逻辑
- 引入结构体清晰管理区间端点
```cpp
struct once{ int from,to; };
// 倒序生成区间后正序输出
for(int i=m;i>=1;i--) 
    cout<<sep[i].from<<" "<<sep[i].to<<endl;
```

### 关键思路总结
1. **二分答案核心**：
   - 下界：单本书的最大页数
   - 上界：所有书总页数
   - check函数使用逆序贪心验证可行性

2. **动态规划优化**：
   - 状态定义：`f[i][j]`表示前j本书分给i人的最小最大值
   - 转移方程：`f[i][j] = min{ max(f[i-1][k], sum(k+1,j)) }`

3. **方案输出技巧**：
   - 逆序分配保证前面的人少抄
   - 递归回溯或数组暂存分割点

### 拓展与举一反三
1. 同类题目推荐：
   - P1182 数列分段（二分答案模板题）
   - P1280 尼克的任务（区间分配+DP）
   - P2577 午餐（时间分配贪心）

2. 调试经验摘录：
> "在二分答案时发现最后一本书页数远超预期解，通过添加虚拟零页书本解决边界问题" —— MuelsyseU  
> 教训：二分时需特别注意极值点的验证

### 核心代码片段
**二分答案输出方案**：
```cpp
int s = find(low,high); // 二分得到最优解
int t=0, num=1;
for(int i=m; i>=1; i--){ // 逆序分配
    if(t + a[i] > s) {
        x[num] = i+1;
        y[++num] = i;
        t = 0;
    }
    t += a[i];
}
```

---
处理用时：49.86秒
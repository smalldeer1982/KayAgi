# 题目信息

# 多米诺骨牌

## 题目描述

多米诺骨牌由上下 $2$ 个方块组成，每个方块中有 $1\sim6$ 个点。现有排成行的上方块中点数之和记为 $S_1$，下方块中点数之和记为 $S_2$，它们的差为 $\left|S_1-S_2\right|$。如图，$S1=6+1+1+1=9$，$S2=1+5+3+2=11$，$\left|S_1-S_2\right|=2$。每个多米诺骨牌可以旋转 $180°$，使得上下两个方块互换位置。请你计算最少旋转多少次才能使多米诺骨牌上下 $2$ 行点数之差达到最小。

![](https://cdn.luogu.com.cn/upload/pic/91.png)

对于图中的例子，只要将最后一个多米诺骨牌旋转 $180°$，即可使上下 $2$ 行点数之差为 $0$。

## 样例 #1

### 输入

```
4
6 1
1 5
1 3
1 2
```

### 输出

```
1
```

# AI分析结果



### 综合分析与结论
本题核心在于通过旋转骨牌最小化上下行差值，需兼顾差值与旋转次数。动态规划是主流解法，通过状态设计记录差值或和值并维护最小步数。贪心虽存在局部最优风险但提供思路补充。关键优化点包括状态压缩、滚动数组、差值偏移处理等。

---

### 高星题解推荐

#### 1. fy0123（★★★★★）
**核心思路**  
- **状态定义**：`f[i][j]` 表示前i个骨牌，上行总和为j时的最小旋转次数  
- **转移方程**：通过比较当前骨牌旋转/不旋转的两种状态转移  
- **优化亮点**：利用上下行总和固定特性，通过上行和计算差值，避免绝对值计算  

**关键代码**  
```cpp
for(int i = 2; i <= n; i++)
    for(int j = 0; j <= 6*n; j++){
        if (j-a[i] >= 0) f[i][j] = min(f[i][j], f[i-1][j-a[i]]);
        if (j-b[i] >= 0) f[i][j] = min(f[i][j], f[i-1][j-b[i]]+1);
    }
```

#### 2. dj114133643（★★★★☆）  
**核心思路**  
- **状态定义**：`f[i][j]` 表示前i个骨牌差值为j时的最小步数，通过偏移量处理负数  
- **代码亮点**：直接处理差值范围，清晰直观  

**关键代码**  
```cpp
for(int i=1; i<=n; i++)
    for(int j=-5000; j<=5000; j++){
        dis = a[i]-b[i];
        f[i][j+N] = min(f[i-1][j-dis+N], f[i-1][j+dis+N]+1);
    }
```

#### 3. 皎月半洒花（★★★★☆）  
**核心思路**  
- **空间优化**：采用滚动数组将空间复杂度优化至O(n)  
- **实现技巧**：通过位运算切换滚动数组维度  

**关键代码**  
```cpp
for(k = i = 1; i <= N; i++, k ^= 1){
    memset(dp[k], 0x7f, sizeof(dp[k]));
    for(j = -5000; j <= 5000; j++)
        dp[k][j+NN] = min(dp[k^1][j+A[i]-B[i]+NN], dp[k^1][j-B[i]+A[i]+NN]+1);
}
```

---

### 关键技巧总结
1. **差值偏移法**：通过固定偏移量（如+5000）处理负数下标问题  
2. **状态压缩**：利用总和固定特性，将二维状态优化为一维  
3. **滚动数组**：大幅减少空间消耗，适用于线性DP问题  
4. **对称处理**：在最终答案中同时考虑正负对称的差值情况  

---

### 相似题目推荐
1. **P1064 金明的预算方案**（有依赖的背包问题）  
2. **P1156 垃圾陷阱**（时间轴与状态的动态规划）  
3. **P1273 有线电视网**（树形DP结合差值处理）

---
处理用时：53.56秒
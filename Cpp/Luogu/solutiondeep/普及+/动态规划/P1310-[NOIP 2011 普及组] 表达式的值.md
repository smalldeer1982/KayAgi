# 题目信息

# [NOIP 2011 普及组] 表达式的值

## 题目描述

对于1 位二进制变量定义两种运算：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|} \hline
\kern{5em}\mathclap\textsf{运算符}\kern{5em} & \kern{5em}\mathclap\textsf{运算规则}\kern{5em} \\ \hline
\oplus &
\begin{aligned}
0 \oplus 0 &= 0 \\
0 \oplus 1 &= 1 \\
1 \oplus 0 &= 1 \\
1 \oplus 1 &= 1 \\
\end{aligned} \\ \hline
\times &
\begin{aligned}
0 \times 0 &= 0 \\
0 \times 1 &= 0 \\
1 \times 0 &= 0 \\
1 \times 1 &= 1 \\
\end{aligned} \\ \hline
\end{array}
$$

运算的优先级是：

1. 先计算括号内的，再计算括号外的。

2. “× ”运算优先于“⊕”运算，即计算表达式时，先计算× 运算，再计算⊕运算。例如：计算表达式A⊕B × C时，先计算 B × C，其结果再与 A 做⊕运算。

现给定一个未完成的表达式，例如\_+(\_\*\_)，请你在横线处填入数字$0 $或者$1$ ，请问有多少种填法可以使得表达式的值为$0 $。


## 说明/提示

【输入输出样例说明】

  给定的表达式包括横线字符之后为：\_+(\_\*\_) 

  在横线位置填入(0 、0 、0) 、(0 、1 、0) 、(0 、0 、1) 时，表达式的值均为0 ，所以共有3种填法。 

【数据范围】

对于 $20\%$ 的数据有 $ 0 \le L \le 10$。

对于 $50\%$ 的数据有 $0 \le L \le 1,000$。

对于 $70\%$ 的数据有 $ 0 \le L \le 10,000$ 。

对于 $100\%$的数据有 $ 0 \le L \le 100,000$。

对于$50\%$ 的数据输入表达式中不含括号。


## 样例 #1

### 输入

```
4
+(*)
```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论
本题核心在于处理带优先级与括号的表达式，统计使结果为0的填法数目。各题解主要采用以下思路：
1. **栈模拟表达式计算**：将表达式转为后缀形式，结合动态规划统计每个运算节点的0/1方案数。
2. **树形DP**：通过构建表达式树/笛卡尔树，递归计算子表达式结果。
3. **优先级优化**：通过线段树/单调栈优化建树过程，降低时间复杂度。

### 精选题解与评分
---

#### 1. 作者：神犇的蒟蒻 ⭐⭐⭐⭐⭐  
**关键亮点**：
- 经典的双栈法处理运算符优先级
- 巧妙用栈存储0/1方案数，动态规划转移清晰
- 代码简洁高效，时间复杂度O(n)

**核心代码解析**：
```cpp
// 后缀表达式处理后计算方案数
for(i=1;i<=k;i++){
    if(ans[i]=='.'){ // 占位符压入初始方案
        u[++top]=1; v[top]=1; 
    } else if(ans[i]=='*'){ // 乘法运算合并
        top--;
        u[top] = (u[top+1]*v[top] + u[top]*v[top+1] + u[top]*u[top+1])%M;
        v[top] = v[top]*v[top+1]%M;
    }
    // 类似处理加法...
}
```
---

#### 2. 作者：Walrus ⭐⭐⭐⭐  
**关键亮点**：
- 通过笛卡尔树实现高效优先级处理
- 利用单调栈O(n)建树，树形DP思路清晰
- 优先级计算巧妙（括号层级×2）

**笛卡尔树构建**：
```cpp
void init(int *a) {
    rep(i, 1, n) {
        if(s[i] == '(' || s[i] == ')') continue;
        while(top && a[st[top]] > a[i]) 
            ch[i][0] = st[top--];
        if(top) ch[st[top]][1] = i;
        st[++top] = i;
    } 
}
```

---

#### 3. 作者：Drinkkk ⭐⭐⭐⭐  
**关键亮点**：
- 双栈法详细示例解析
- 通过添加外围括号简化处理
- 动态规划方程推导完整

**动态规划转移**：
```cpp
// 乘法运算合并逻辑
int e=aa*ac + aa*ad + ab*ac; // 0的方案数
int f=ab*ad;                  // 1的方案数
// 加法运算合并逻辑
int e=aa*ac;                  // 0的方案数  
int f=aa*ad + ab*ac + ab*ad;  // 1的方案数
```

---

### 最优思路总结
1. **双栈法**：最实用解法，通过维护操作数栈和运算符栈，结合动态规划统计方案数，时间复杂度O(n)
2. **优先级处理**：将运算符优先级转化为后缀表达式处理顺序
3. **动态规划状态**：每个节点维护 (cnt0, cnt1)，通过运算符类型合并子结果
4. **取模优化**：每步运算后立即取模，避免溢出

### 举一反三
1. **同类题目**：
   - 表达式求值（P1981）
   - 后缀表达式（P1175）  
   - 笛卡尔树应用（P5854）
2. **扩展技巧**：
   - 单调栈处理优先级
   - 树形DP在表达式问题中的应用
   - 状态压缩动态规划

---

### 核心代码实现（以双栈法为例）
```cpp
stack<node> num; // 存储(cnt0, cnt1)
stack<char> op;  // 存储运算符

void calculate() {
    node b = num.top(); num.pop();
    node a = num.top(); num.pop();
    char c = op.top(); op.pop();
    
    if(c == '+') { // OR运算
        newn.x = (a.x * b.x) % mod;
        newn.y = (a.x*b.y + a.y*b.x + a.y*b.y) % mod;
    } else {       // AND运算
        newn.y = (a.y * b.y) % mod;
        newn.x = (a.x*b.y + a.y*b.x + a.x*b.x) % mod;
    }
    num.push(newn);
}
```

---
处理用时：48.62秒
# 题目信息

# 数列的整除性

## 题目描述

对于任意一个整数数列，我们可以在每两个整数中间任意放一个符号 `+` 或 `-`，这样就可以构成一个表达式，也就可以计算出表达式的值。对于一个整数数列来说，我们能通过如上的方法构造出不同的表达式，从而得到不同的数值，如果其中某一个数值能够被 $k$ 整除的话，我们就称该数列能被 $k$ 整除。现在你的任务是判断某个数列是否能被某数整除。

## 说明/提示

#### 样例输入输出 1 解释

对于整数数列：$17,5,-21,-15$，可以构造出 $8$ 个表达式：

- $17+5+(-21)+15=16$
- $17+5+(-21)-15=-14$
- $17+5-(-21)+15=58$
- $17+5-(-21)-15=28$
- $17-5+(-21)+15=6$
- $17-5+(-21)-15=-24$
- $17-5-(-21)+15=48$
- $17-5-(-21)-15=18$


该数列能被 $7$ 整除（$17+5+(-21)-15=-14$），但不能被 $5$ 整除。

#### 数据规模与约定
对于全部的测试点，保证 $1 \le n \le 10^4,2 \le k \le 100,\left| a_i \right| \le 10^4$。

- $\text{upd 2022.9.27}$：新增加一组 Hack 数据。
- $\text{upd 2023.11.29}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
2
4 7
17 5 -21 15
4 5
17 5 -21 15
```

### 输出

```
Divisible
Not divisible

```

# AI分析结果



### 综合分析与结论

本题需判断数列通过加减组合能否被k整除，核心解法为动态规划，利用模运算性质维护余数状态。各题解均采用DP思路，差异在于状态表示与空间优化方式。最优解法通过滚动数组将空间优化至O(k)，同时正确处理负数模运算。

---

### 高星题解推荐

#### 1. 作者：LJC00118（★★★★★）
**关键亮点**  
- 滚动数组优化至O(k)空间，内存效率极高  
- 边读入边处理，避免存储完整数列  
- 巧用链表思想维护转移状态，确保不覆盖中间结果  
**个人心得**  
> "边加边模k，结果不变" —— 利用模运算性质避免数值溢出，是优化的关键  

**核心代码**  
```cpp
int f[101] = {0}; // 滚动数组
for(int i=1; i<=n; i++) {
    int tmp = (x % k + k) % k; // 处理负数模
    for(int j=k-1; j>=0; j--) {
        if(f[j] == i-1) { // 确保使用全部前序数
            f[(j+tmp)%k] = i;  // 加当前数
            f[(j-tmp+k)%k] = i;// 减当前数
        }
    }
}
```

#### 2. 作者：courage（★★★★☆）
**关键亮点**  
- 二维状态表示更直观，f[i][j]表示前i个数能否得到余数j  
- 代码结构清晰易理解，适合初学者掌握基础DP思路  
- 正负余数统一处理，避免复杂边界条件  

**核心代码**  
```cpp
bool f[10010][110]; // 二维状态数组
f[0][p(x)] = f[0][p(-x)] = 1; // 初始状态
for(int i=1; i<n; i++) {
    for(int j=0; j<k; j++) {
        f[i][j] = f[i-1][p(j-x)] | f[i-1][p(j+x)]; // 状态转移
    }
}
```

#### 3. 作者：Chloris（★★★★☆）
**关键亮点**  
- 明确初始条件处理，强调第一个数的正负选择  
- 状态转移方程推导清晰，注释详细  
- 对比DFS解法，突出DP效率优势  

**调试心得**  
> "边界条件卡了很久，第一个数只能选正号" —— 初始状态设置是易错点  

---

### 最优思路总结

1. **状态压缩**：用模k余数作为状态维度，将数值范围从1e4压缩至100  
2. **滚动数组**：通过交替使用两个一维数组，将空间复杂度从O(nk)优化至O(k)  
3. **统一余数处理**：使用 `(x%k + k) % k` 确保余数非负，避免负数模运算陷阱  
4. **完全转移**：每一步必须使用所有前序数，通过 `f[j] == i-1` 条件保证  

---

### 类似题目推荐

1. [P1734 最大约数和](https://www.luogu.com.cn/problem/P1734) - 背包DP与因数分解结合  
2. [P1412 武士风度的牛](https://www.luogu.com.cn/problem/P1412) - 状态压缩与模运算应用  
3. [P2920 Time Management](https://www.luogu.com.cn/problem/P2920) - 时间规划中的动态余数处理  

---

### 关键代码片段

LJC00118解法核心逻辑：  
```cpp
for(int i=1; i<=n; i++) {
    int tmp = (x % k + k) % k;
    vector<pair<int, int>> candidates;
    for(int j=0; j<k; j++) {
        if(f[j] == i-1) { // 收集所有可行状态
            candidates.emplace_back(j, i-1);
        }
    }
    for(auto [j, cnt] : candidates) { // 批量更新
        f[(j + tmp) % k] = cnt + 1;
        f[(j - tmp + k) % k] = cnt + 1;
    }
}
```

---
处理用时：99.18秒
# 题目信息

# 序列取数

## 题目描述

给定一个长为 $n$ 的整数序列 $(n \le 1000)$，由 A 和 B 轮流取数（A 先取）。每个人可从序列的左端或右端取若干个数（至少一个），但不能两端都取。所有数都被取走后，两人分别统计所取数的和作为各自的得分。假设 A 和 B 都足够聪明，都使自己得分尽量高，求 A 的最终得分。

## 样例 #1

### 输入

```
2

1 -1

2 1 2```

### 输出

```
-1

3```

# AI分析结果



### 综合分析与结论
本题为博弈类区间DP问题，核心在于设计高效状态转移并优化复杂度。各题解普遍采用区间DP，但优化方式各异，主要思路为维护辅助数组减少重复计算或空间优化。关键技巧包括前缀和、滚动数组、差值转换等。

---

### 高星题解推荐

#### 1. 题解作者：iwprc（5星）
**关键亮点**  
- 引入L/R状态表示必须取左/右端点，将问题拆分为两个子状态，避免重复枚举。
- 滚动数组优化空间至O(n)，大幅降低内存占用。
- 代码简洁高效，时间复杂度O(n²)，适合处理大n。

**个人心得**  
需注意转移顺序，先更新r[i]再更新l[i]，确保依赖数据不被覆盖。

**核心代码**  
```cpp
for(j=1;j<n;j++)
    for(i=1;i+j<=n;i++){
        r[i]=a[i+j]+max(r[i],s[i+j-1]-s[i-1]-max(l[i],r[i]));
        l[i]=a[i]+max(l[i+1],s[i+j]-s[i]-max(l[i+1],r[i+1]));
    }
```

#### 2. 题解作者：Khassar（4星）
**关键亮点**  
- 定义f/g数组分别维护区间左右侧的最小DP值，实现O(1)转移。
- 直观优化思路，代码结构清晰易理解。

**核心代码**  
```cpp
for(int L=1;L<=n;L++) {
    for(int i=1;i<=n-L;i++){
        int j=i+L, m=0;
        m=min(m,min(f[i+1][j],g[i][j-1]));
        d[i][j]=s[j]-s[i-1]-m;
        f[i][j]=min(d[i][j],f[i+1][j]);
        g[i][j]=min(d[i][j],g[i][j-1]);
    }
}
```

#### 3. 题解作者：zhlzt（4星）
**关键亮点**  
- 使用p/q数组记录前缀后缀最小值，优化暴力枚举。
- 将差值转换思想融入状态，简化计算逻辑。

**核心代码**  
```cpp
for(int len=1;len<=n;len++)
    for(int i=1;i+len-1<=n;i++){
        int j=i+len-1;
        dp[i][j]=sum[i][j]-min(0,min(p[i][j-1],q[i+1][j]));
        p[i][j]=min(p[i][j-1],dp[i][j]);
        q[i][j]=min(q[i+1][j],dp[i][j]);
    }
```

---

### 关键思路与技巧总结
1. **前缀和加速**：快速计算区间和，避免重复求和。
2. **辅助数组维护极值**：如f/g或p/q数组，避免遍历k值。
3. **滚动数组优化**：将二维DP压缩为一维，节省空间。
4. **差值转换思想**：将得分差转换为总和与对手得分关系，简化状态转移。

---

### 拓展与相似题目推荐
1. **石子合并（NOI1995）** [P1880](https://www.luogu.com.cn/problem/P1880)  
   经典区间DP，练习基本区间划分与合并。
2. **取石子游戏** [P1288](https://www.luogu.com.cn/problem/P1288)  
   博弈论+区间DP，分析先手必胜策略。
3. **棋盘分割** [P1436](https://www.luogu.com.cn/problem/P1436)  
   区间DP变形，涉及多维状态与最优化。

---
处理用时：51.40秒
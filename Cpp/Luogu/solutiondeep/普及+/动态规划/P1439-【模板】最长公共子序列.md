# 题目信息

# 【模板】最长公共子序列

## 题目描述

给出 $1,2,\ldots,n$ 的两个排列 $P_1$ 和 $P_2$ ，求它们的最长公共子序列。

## 说明/提示

- 对于 $50\%$ 的数据， $n \le 10^3$；
- 对于 $100\%$ 的数据， $n \le 10^5$。

## 样例 #1

### 输入

```
5 
3 2 1 4 5
1 2 3 4 5
```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题核心在于利用排列特性将LCS转化为LIS问题，通过离散化与二分实现O(n log n)解法。多数题解围绕这一思路展开，差异主要体现在讲解深度和代码优化上。最优解法通过建立位置映射+贪心维护LIS，突破传统DP的限制。

---

### 高星题解精选（评分≥4星）

#### 1. 皎月半洒花（5星）
**关键亮点**：  
- 完整推导LCS→LIS的数学逻辑，深入剖析问题转化本质  
- 对比n²与nlogn解法差异，体现算法优化思维  
- 提供完整代码及路径输出等扩展实现

**核心代码**：
```cpp
for(int i=2;i<=n;i++){
    int l=0,r=len,mid;
    if(a[i]>f[len])f[++len]=a[i];
    else {
        while(l<r){
            mid=(l+r)/2;
            if(f[mid]>a[i])r=mid;
            else l=mid+1;
        }
        f[l]=a[i];
    }
}
```
**实现思想**：维护单调栈，二分查找替换位置，保证栈内元素始终为当前最小可能值。

---

#### 2. 阮行止（4.5星）
**关键亮点**：  
- 用重标号法直观解释问题转化，辅以样例演示  
- 一针见血指出"递增即公共子序列"的核心性质  
- 代码极简，突出算法本质

**核心片段**：
```cpp
for(int i=1;i<=n;i++) f[a[i]]=i; //建立映射
for(int i=1;i<=n;i++) t[i]=f[b[i]]; //转换序列
// 求t数组的LIS
```

---

#### 3. heey（4星）  
**关键亮点**：  
- 代码简洁高效，善用STL简化实现  
- 完整注释帮助理解离散化过程  
- 对比朴素DP突出优化必要性

**代码亮点**：
```cpp
*lower_bound(b+1,b+len+1,belong[a2[i]])-b // 二分插入点
```

---

### 关键思路总结
1. **排列特性转化**：利用双排列元素唯一性，建立`pos[a[i]]=i`的映射关系
2. **序列转换**：将第二个序列按第一个序列的位置重新编码
3. **LIS贪心维护**：通过维护单调栈和二分查找，将复杂度降至O(n log n)

---

### 拓展练习推荐
1. **P1020** 导弹拦截（LIS经典模型）  
2. **P2782** 友好城市（位置映射排序）  
3. **P4309** 最长上升子序列（动态LIS维护）

---

### 题解中的调试心得
1. **I_AM_HelloWord**：  
   - 强调必须验证映射的正确性，初始未清空数组导致WA  
   - 发现`lower_bound`返回值需仔细处理边界  

2. **ljc20020730**：  
   - 离散化时忽略元素为0的情况，通过调试发现需初始化`f[0]=0`

3. **shadowice1984**：  
   - 树状数组维护时发现需离散化，否则空间爆炸  

---

### 核心代码实现（LIS部分）
```cpp
int len = 0;
for(int i=1; i<=n; i++){
    int pos = lower_bound(dp+1, dp+len+1, a[i]) - dp;
    dp[pos] = a[i];
    len = max(len, pos);
}
// dp数组维护当前长度下的最小末尾值
```

---
处理用时：63.42秒
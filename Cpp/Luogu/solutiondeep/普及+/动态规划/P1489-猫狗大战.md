# 题目信息

# 猫狗大战

## 题目描述

新一年度的猫狗大战通过 SC（星际争霸）这款经典的游戏来较量，野猫和飞狗这对冤家为此已经准备好久了，为了使战争更有难度和戏剧性，双方约定只能选择 Terran（人族）并且只能造机枪兵。

比赛开始了，很快，野猫已经攒足几队机枪兵，试探性的发动进攻；然而，飞狗的机枪兵个数也已经不少了。野猫和飞狗的兵在飞狗的家门口相遇了，于是，便有一场腥风血雨和阵阵惨叫声。由于是在飞狗的家门口，飞狗的兵补给会很快，野猫看敌不过，决定撤退。这时飞狗的兵力也不足够多，所以没追出来。

由于不允许造医生，机枪兵没办法补血。受伤的兵只好忍了。

现在，野猫又攒足了足够的兵力，决定发起第二次进攻。为了使这次进攻给狗狗造成更大的打击，野猫决定把现有的兵分成两部分，从两路进攻。由于有些兵在第一次战斗中受伤了，为了使两部分的兵实力平均些，分的规则是这样的：

1. 两部分兵的个数最多只能差一个；
2. 每部分兵的血值总和必须要尽可能接近。

现在请你编写一个程序，给定野猫现在有的兵的个数以及每个兵的血格值，求出野猫按上述规则分成两部分后每部分兵的血值总和。

## 说明/提示

TO 狗狗：这道题的数据范围我已经尽量按星际的游戏规则来了，如果你再固执于由于机枪兵的攻击力一定使不能达到某些血格值或者游戏中一定要造农民不能使机枪兵的人数达到 $200$ 的话，我只能决定将那场猫狗大战的录像公开于世人了！！！


## 样例 #1

### 输入

```
3
35
20
32
```

### 输出

```
35 52```

# AI分析结果



### 综合分析与结论
本题核心为将数组划分为两个子集，满足人数差≤1且和差最小。标准解法是二维背包DP（人数+总和），优化方向包括bitset压缩、随机化/贪心近似解。关键点在于状态设计（人数与总和的平衡）及处理奇数情况。

---

### 高星题解推荐
#### 1. vegetabird（二维背包DP） ★★★★☆
**关键亮点**：  
- 标准二维背包思路，状态`f[j][k]`表示选k人总和j是否可行  
- 遍历所有可能总和，取最接近总和一半的解  
- 代码简洁清晰，复杂度O(n^2*sum)可接受  

**核心代码**：  
```cpp
int f[8010][110]; // 状态数组
for(int j=5000;j>=a[i];j--) 
    for(int k=100;k>=1;k--) 
        f[j][k] = max(f[j][k], f[j-a[i]][k-1]);
// 遍历i找最小abs(2i-sum)
```

#### 2. i207M（bitset优化） ★★★★★  
**关键亮点**：  
- 使用`bitset`压缩状态，大幅优化空间和时间  
- 直接枚举接近总和一半的解，避免全量遍历  
- 处理奇偶情况自动包含在状态中  

**核心代码**：  
```cpp
bitset<8010> f[N]; // 一维bitset优化
f[j] |= (f[j-1] << w[i]); // 状态转移
for(int i=0; hlf+i<=sum; ++i) // 最接近半和
    if(f[n>>1][hlf+i]) return输出;
```

#### 3. danefishhh（修正人数处理） ★★★★☆  
**关键修正**：  
- 在DP遍历时同时检查n/2和n/2+1的情况  
- 确保奇数人数时正确性，避免常见hack点  

**核心逻辑**：  
```cpp
for(int j=(n>>1)+1; j>=1; j--) // 处理可能+1的情况
    for(k) f[j][k] |= f[j-1][k-a[i]];
if(n%2) check(f[(n>>1)+1][i]); // 奇数特判
```

---

### 关键思路与技巧总结
1. **状态压缩**：使用`bitset`或滚动数组优化高维DP的空间  
2. **平衡设计**：同时考虑人数与总和的双重约束，避免单维度贪心  
3. **边界处理**：对奇数人数的特殊情况进行显式检查  
4. **剪枝策略**：从中间值向两侧枚举，快速找到最优解  

---

### 相似题目推荐
1. **P1282 多米诺骨牌**（NOI1999，双条件背包）  
2. **P2217 [HAOI2007]分割矩阵**（二维平均值分割）  
3. **P2401 不等数列**（组合数+DP状态设计）  

---

### 题解中的个人心得摘录
- **MichaelYoung**：  
  > "随机化思路来自组合数实际状态数远小于理论值"  
  > → 启发式搜索在特定问题中的有效性  

- **caddy**：  
  > "k=0时i,j互换需重新计算"  
  > → 状态转移的对称性处理易错点  

- **Lyco_Reco**：  
  > "参数t0=0.997经多次实验调整"  
  → 模拟退火参数调优对结果的影响  

---

### 核心代码实现示例（i207M优化版）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, sum;
bitset<8010> f[210]; // f[i][j]:选i人总和j

int main() {
    f[0][0] = 1;
    for(int i=1,w; i<=n; ++i) {
        cin >> w;
        for(int j=i; j>=1; --j) 
            f[j] |= f[j-1] << w; // 关键转移
        sum += w;
    }
    int mid = sum/2;
    for(int d=0; ;++d) {
        if(f[n/2][mid-d] || (n%2 && f[n/2+1][mid-d])) 
            return cout << mid-d << " " << sum-mid+d;
        if(f[n/2][mid+d] || (n%2 && f[n/2+1][mid+d])) 
            return cout << mid+d << " " << sum-mid-d;
    }
}
```

---
处理用时：63.59秒
# 题目信息

# 弹珠

## 题目描述

玛莎和比尔各自有自己的弹珠收藏。他们想重新分配收藏品，使两人能平等拥有弹珠。如果所有的弹珠的价值相同，那么他们就可以平分。但不幸的是，有一些弹珠更大，或者更美丽，所以，玛莎和比尔给每个弹珠一个 $1$ 到 $6$ 的价值。现在他们想平分这些弹珠，使每个人得到的总价值相同。不幸的是，他们发现，他们可能无法以这种方式分弹珠（即使弹珠的总价值为偶数）。例如，如果有一个价值为 $1$、一个价值为 $3$ 和两个价值为 $4$ 的弹珠，这样他们就不能把弹珠分为价值相等的两部分。因此，他们想要你写一个程序，告诉他们是否能将所有弹珠分成价值相等的两部分。


## 样例 #1

### 输入

```
1 0 1 2 0 0 

1 0 0 0 1 1 

0 0 0 0 0 0 

```

### 输出

```
Collection #1:

Can't be divided.



Collection #2:

Can be divided.

```

# AI分析结果



### 综合分析与结论
本题本质是多重背包可行性判断，关键点在于如何高效处理每种弹珠的数量。核心解法包括二进制优化、模数压缩数据、bitset优化等。最优解为二进制优化+可行性背包，时间复杂度O(V*logN)。需注意总价值奇偶性预判和状态转移方向。

---

### 精选题解分析

#### 1. Sooke（5星）
**关键亮点**：
- 采用二进制优化多重背包，时间复杂度降至O(V*logN)
- 引入鬼谷子钱袋分组思想，分组方式高效
- 代码包含读入优化和滚动数组技巧

**核心代码思想**：
```cpp
for(int i=1;i<=6;i++)
    for(int t=a[i];t>0;t>>=1){
        int f=(t>>1)+(t&1); // 二进制分组
        for(int j=s;j>=f*i*2;j--)
            if(v[j-f*i*2]) v[j]=true;
    }
```

#### 2. fastle（4星）
**关键亮点**：
- 使用bitset优化空间和运算效率
- 简洁的位运算转移方程
- 适合大规模数据的快速处理

**核心代码思想**：
```cpp
bitset<N> dp;
dp |= (dp << i); // 位运算加速状态转移
```

#### 3. ShwStone（4星）
**关键亮点**：
- 完整实现二进制拆分逻辑
- 包含详细注释和边界处理
- 使用滚动数组优化空间

**调试心得**：
"注意多组数据要清空数组，每次循环前重置dp状态，否则会污染后续测试用例"

---

### 关键优化技巧总结
1. **二进制拆分**：将数量n分解为1,2,4...2^k的组合，将多重背包转为01背包
2. **位运算加速**：使用bitset的位操作实现并行状态转移
3. **模数压缩**：对6取模后暴力枚举（适用于特殊数据分布）
4. **可行性剪枝**：先判断总和奇偶性，减少无效计算

---

### 推荐相似题目
1. P1776 宝物筛选（多重背包优化）
2. P1833 樱花（时间优化的多重背包） 
3. P2320 鬼谷子的钱袋（二进制分组思想）

---

### 特别注意事项
- 多组数据必须重置dp数组
- 背包容量计算时注意整数溢出
- 二进制分组的边界处理：(t>>1)+(t&1) 确保分解完整性
- 逆序更新背包状态避免重复计算

---
处理用时：37.15秒
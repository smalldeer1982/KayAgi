# 题目信息

# [NOIP 2010 提高组] 乌龟棋

## 题目背景

NOIP2010 提高组 T2

## 题目描述

小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。

乌龟棋的棋盘是一行 $N$ 个格子，每个格子上一个分数（非负整数）。棋盘第 $1$ 格是唯一的起点，第 $N$ 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。

乌龟棋中 $M$ 张爬行卡片，分成 $4$ 种不同的类型（$M$ 张卡片中不一定包含所有 $4$ 种类型的卡片，见样例），每种类型的卡片上分别标有 $1,2,3,4$ 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。


游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。


很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。


现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？


## 说明/提示

每个测试点 1s。

小明使用爬行卡片顺序为 $1,1,3,1,2$，得到的分数为 $6+10+14+8+18+17=73$。注意，由于起点是 $1$，所以自动获得第 $1$ 格的分数 $6$。


对于 $30\%$ 的数据有 $1≤N≤30,1≤M≤12$。


对于 $50\%$ 的数据有 $1≤N≤120,1≤M≤50$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $20$。


对于 $100\%$ 的数据有 $1≤N≤350,1≤M≤120$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $40$；$0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M$。


## 样例 #1

### 输入

```
9 5
6 10 14 2 8 8 18 5 17
1 3 1 2 1
```

### 输出

```
73
```

# AI分析结果



### 综合分析与结论
各题解均采用四维动态规划，核心思路是使用卡片数量作为状态维度，通过递推计算最大得分。所有解法的时间复杂度为 O(40^4)，在数据范围内可行。关键难点在于状态设计、位置计算和边界条件处理。

### 高评分题解推荐
#### 1. 吃瓜群众syc（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 详细阐释状态转移方程与背包思想的关联  
- 强调位置计算公式 `r=1+a+b*2+c*3+d*4` 的细节处理  
- 代码可读性强，包含关键注释  

**核心代码**：
```cpp
for(int a=0;a<=g[1];a++)
    for(int b=0;b<=g[2];b++)
        for(int c=0;c<=g[3];c++)
            for(int d=0;d<=g[4];d++) {
                int r=1+a+b*2+c*3+d*4;
                if(a) F[a][b][c][d] = max(F[a][b][c][d], F[a-1][b][c][d]+num[r]);
                // 类似处理b,c,d
            }
```

#### 2. Time_Rune（⭐⭐⭐⭐）
**关键亮点**：  
- 通过反证法证明最优子结构性质  
- 详细讨论状态分解思路，适合DP初学者理解  
- 代码中显式处理零卡片状态  

**核心代码**：
```cpp
for(int i1=0;i1<=s[1];i1++)
    for(int i2=0;i2<=s[2];i2++)
        for(int i3=0;i3<=s[3];i3++)
            for(int i4=0;i4<=s[4];i4++) {
                int now=1+i1+2*i2+3*i3+4*i4;
                if(i1) maxx=max(maxx,f[i1-1][i2][i3][i4]+a[now]);
                // 类似处理i2,i3,i4
            }
```

#### 3. ikunTLE（⭐⭐⭐⭐）
**关键亮点**：  
- 代码极度简洁（仅20行），适合快速实现参考  
- 使用宏定义简化四维数组访问  
- 显式处理卡片数量为零的边界条件  

**核心代码**：
```cpp
#define dpnw dp[i[0]][i[1]][i[2]][i[3]]
rp(0) rp(1) rp(2) rp(3) {
    if(i[0]) dpnw=max(dpnw, dp[i[0]-1][i[1]][i[2]][i[3]]+nw);
    // 类似处理i[1],i[2],i[3]
}
```

### 最优解法核心技巧
1. **四维状态设计**：用 `f[a][b][c][d]` 表示四种卡片的使用数量，通过卡片数量唯一确定当前位置。
2. **位置计算**：当前位置公式为 `1 + a + 2b + 3c + 4d`，需注意起点为第1格。
3. **递推顺序**：按卡片使用数量从小到大的顺序递推，确保子问题先被计算。
4. **边界处理**：初始化 `f[0][0][0][0] = 起点分数`，转移时判断卡片数量是否非零。

### 拓展与相似题目推荐
1. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)  
   （多维背包问题，附件依赖关系）
2. [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)  
   （二维路径最优解，双线程DP）
3. [P1541 乌龟棋（原题数据加强版）](https://www.luogu.com.cn/problem/P1541)  
   （同类型练习，巩固四维DP）

---
处理用时：56.26秒
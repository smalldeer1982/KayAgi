# 题目信息

# 塔

## 题目描述

小明很喜欢摆积木，现在他正在玩的积木是由 $N$ 个木块组成的，他想用这些木块搭出两座高度相同的塔，一座塔的高度是搭建它的所有木块的高度和，并且一座塔至少要用一个木块。每个木块只能用一次，也可以不用。目前已知每块木块的高度，小明想知道在最终两个塔的高度相同的情况下，他所能搭的塔的最大高度是多少，你能帮助他吗？

## 说明/提示

对于 $100\%$ 的数据，$N \le 50$ ，每块木块的高度 $h$ 满足 $1 \le h \le 500000$，所有木块的高度总和 $\le 500000$。

## 样例 #1

### 输入

```
3

2 3 5```

### 输出

```
5```

# AI分析结果



### 综合分析与结论
本题核心是动态规划处理差值状态，所有题解均围绕如何表示两塔高度差展开。最优解法为差值状态压缩+滚动数组优化，时间复杂度O(N*sum)，空间优化到O(sum)。DFS+剪枝解法虽新颖但效率不稳定，存在性DP解法较直观但时空消耗较大。

---

### 高评分题解推荐

#### 1. FLYing的题解（★★★★★）
**关键亮点**：  
- 状态定义创新：用差值代替绝对值，左堆高度为值，避免双重状态比较  
- 滚动数组优化：空间复杂度降至O(sum)  
- 负数偏移技巧：+500000处理负下标  
**核心代码思想**：
```cpp
f[i%2][j] = max(f[(i%2)^1][j],           // 不选
                f[(i%2)^1][j-a[i]]+a[i], // 放左堆
                f[(i%2)^1][j+a[i]]);     // 放右堆
```
**实现要点**：初始化f[0][500000]=0，每次转移后检查j=0的情况

#### 2. 我要上天的题解（★★★★☆）
**关键亮点**：  
- 四状态转移覆盖所有可能：放高塔/矮塔的两种变化  
- 初始化技巧：用-INF表示不可达状态  
**个人心得**：  
> "测试数据较水，部分题解漏情况。正确转移需考虑矮塔变高塔的特殊情况"

**核心转移逻辑**：
```cpp
dp[i][j] = max(不选, 放矮塔仍矮, 放高塔, 放矮塔变高塔)
if(j >= a[i]) dp[i][j] = max(..., dp[i-1][j-a[i]]+a[i]);
if(j <= a[i]) dp[i][j] = max(..., dp[i-1][a[i]-j]+j);
```

#### 3. K2sen的题解（★★★★☆）
**关键亮点**：  
- 记忆化+可行性剪枝：通过前缀和剪枝大幅优化DFS  
- 排序优化：降序排列优先处理大块  
**个人心得**：  
> "降序排序能更快接近最优解，记忆化用map<pair<三重状态>,int>避免重复"

**核心剪枝逻辑**：
```cpp
if(h1+剩余 < h2 || h2+剩余 < h1) return; // 可行性剪枝
if(当前最大高度+剩余 <= ans*2) return;   // 最优性剪枝
```

---

### 最优技巧总结
1. **差值状态压缩**：用第一堆减第二堆的差值j作为状态，而非独立记录两堆高度  
2. **偏移量处理负数**：通过+sum将差值范围[ -sum, sum ]映射到[0, 2sum]  
3. **滚动数组优化**：交替使用两个一维数组，空间从O(N*sum)降为O(sum)  
4. **四向状态转移**：必须考虑矮塔变高塔的特殊情况（当a[i]>j时）  

---

### 相似题目推荐
1. P1282 多米诺骨牌（差值DP经典）  
2. P2214 奶牛钢琴[USACO]（双目标最值）  
3. P2340 [USACO03FALL]Cow Exhibition G（双维度背包）

---

### 关键调试经验摘录
1. > "初始化为-INF而非0，避免无效状态干扰转移"（来自我要上天）
2. > "降序排序加速剪枝，先处理大块积木"（来自K2sen）
3. > "用偏移量代替负数下标，避免数组越界"（多篇DP题解共同经验）

---
处理用时：59.37秒
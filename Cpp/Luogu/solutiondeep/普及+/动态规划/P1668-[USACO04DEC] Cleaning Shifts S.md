# 题目信息

# [USACO04DEC] Cleaning Shifts S

## 题目描述

一天有 $T(1\le T\le 10^6)$ 个时段。约翰正打算安排他的 $N(1\le N\le 2.5\times 10^4)$ 只奶牛来值班，打扫打扫牛棚卫生。每只奶牛都有自己的空闲时间段 $ [S_i,E_i](1\le S_i\le E_i\le T)$，只能把空闲的奶牛安排出来值班。而且，每个时间段必需有奶牛在值班。

那么，最少需要动用多少奶牛参与值班呢？如果没有办法安排出合理的方案，就输出 $-1$。

## 说明/提示

$1\le T\le 10^6$，$N\le 2.5\times 10^4$，$1\le S_i\le E_i\le T$。

$\text{Update On 2023/08/08}$：添加了一组hack数据，详情见[这里](https://www.luogu.com.cn/discuss/613052)。叉掉了时间复杂度为 $\mathcal O(nt)$ 的错解。

## 样例 #1

### 输入

```
3 10
1 7
3 6
6 10```

### 输出

```
2```

# AI分析结果



### 综合分析与结论
本题核心是区间完全覆盖的最优化问题，各题解主要围绕贪心、动态规划（线段树优化）、最短路建模三种思路展开。最优解法为贪心策略，时间复杂度 O(n log n)，代码简洁高效。线段树优化DP与最短路方法虽然正确，但在实现复杂度或空间效率上略逊于贪心。

---

### 高星题解推荐

#### 1. Greenzhe（贪心） ⭐⭐⭐⭐⭐
**关键亮点**：
- 贪心思路清晰：按左端点排序，每次选择能覆盖当前起点且右端点最大的区间
- 双指针优化实现，时间复杂度严格 O(n log n)
- 包含正确性证明，引用经典课程内容增强说服力

**核心代码思想**：
```cpp
sort(range+1, range+n+1); // 按左端点排序
int st=1, ans=0;
for(int i=1,j=1; i<=n;){
    int r=0;
    while(j<=n && range[j].l<=st) {
        r = max(r, range[j].r); // 找右端点最大的覆盖区间
        j++;
    }
    if(r < st) break; // 无法覆盖
    ans++;
    st = r + 1; // 更新起点
}
```

#### 2. Southern_Dynasty（最短路） ⭐⭐⭐⭐
**关键亮点**：
- 巧妙建模为最短路问题，边权设计体现区间覆盖特性
- 使用01BFS处理边权0/1的情况，时间复杂度 O(n + T)
- 提供离散化版本应对 T=1e9 的扩展场景

**核心建模技巧**：
```cpp
// 建图规则：
for每个区间[l,r]: add_edge(l-1, r, 1); // 覆盖区间的代价边
for每个时间点i: add_edge(i, i-1, 0);  // 允许向左移动的0权边
// 答案即0到T的最短路
```

#### 3. 船酱魔王（线段树优化DP） ⭐⭐⭐⭐
**关键亮点**：
- 经典线段树优化DP模板，将区间查询优化至 O(log T)
- 离散化处理得当，完整展示线段树实现细节
- 状态转移方程设计清晰，体现动态规划思想

**关键状态转移**：
```cpp
for每个区间[l,r]:
    int tmp = query线段树区间[l-1, r-1] + 1;
    update线段树位置r的值为tmp;
```

---

### 最优关键思路总结
**贪心策略**：
1. 将所有区间按左端点排序
2. 维护当前覆盖终点 `st`，每次选择左端点 ≤ `st` 且右端点最大的区间
3. 更新 `st` 为选中区间的右端点+1，直到覆盖整个区间

**思维启示**：
- 贪心选择中"当前最优即全局最优"的特性需要严格数学证明
- 双指针技巧有效减少无效遍历，将时间复杂度从 O(n²) 优化至 O(n)

---

### 推荐相似题目
1. P4644 [USACO05DEC] Cleaning Shifts G（带权区间覆盖，线段树优化DP）
2. P1280 尼克的任务（逆向DP处理区间覆盖）
3. P2516 [HAOI2010] 最长公共子序列（区间覆盖与数据结构优化结合）

---

### 题解中的个人心得摘录
1. **Greenzhe** 引用课程证明思路：  
   "由于每次选择右端点最大的区间，所以替换最优解中的选择不会更劣"  
   → 强调数学证明在贪心算法中的必要性

2. **Southern_Dynasty** 离散化技巧：  
   "注意离散化的是 l-1 和 r，而非 l"  
   → 揭示建模中的关键细节处理

3. **MoonCake2011** 调试经验：  
   "初始暴力DP在数据水的情况下AC，但添加hack数据后必须优化"  
   → 提醒算法正确性比过数据更重要

---
处理用时：57.18秒
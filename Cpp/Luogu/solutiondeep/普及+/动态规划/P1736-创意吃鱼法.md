# 题目信息

# 创意吃鱼法

## 题目背景

感谢@throusea 贡献的两组数据

## 题目描述

回到家中的猫猫把三桶鱼全部转移到了她那长方形大池子中，然后开始思考：到底要以何种方法吃鱼呢（猫猫就是这么可爱，吃鱼也要想好吃法 ^\_\*）。她发现，把大池子视为 $01$ 矩阵（$0$ 表示对应位置无鱼，$1$ 表示对应位置有鱼）有助于决定吃鱼策略。

在代表池子的 $01$ 矩阵中，有很多的正方形子矩阵，如果某个正方形子矩阵的某条对角线上都有鱼，且此正方形子矩阵的其他地方无鱼，猫猫就可以从这个正方形子矩阵“对角线的一端”下口，只一吸，就能把对角线上的那一队鲜鱼吸入口中。

猫猫是个贪婪的家伙，所以她想一口吃掉尽量多的鱼。请你帮猫猫计算一下，她一口下去，最多可以吃掉多少条鱼？


## 说明/提示

右上角的
```
1 0 0
0 1 0
0 0 1
```

### 数据范围及约定


- 对于 $30\%$ 的数据，有 $1\le n,m\le 100$；
- 对于 $60\%$ 的数据，有 $1\le n,m\le 1000$；
- 对于 $100\%$ 的数据，有 $1\le n,m\le 2500$。

## 样例 #1

### 输入

```
4 6
0 1 0 1 0 0
0 0 1 0 1 0
1 1 0 0 0 1
0 1 1 0 1 0
```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
该题核心在于寻找满足条件的最大正方形子矩阵，要求对角线全为1且其余位置全为0。主流解法以动态规划（DP）为主，结合预处理连续0的数量实现高效转移。次要解法包括暴力+剪枝、前缀和+二分等。最优解为双向DP，时间复杂度O(n²)，空间复杂度O(n²)，通过预处理横向/纵向连续0数量避免重复计算。

---

### 高星题解推荐

#### 1. SplenD1D（4星）
**亮点**：  
- 双向状态分离：分别处理左上→右下、右上→左下两种对角线方向，避免方向冲突  
- 动态维护检查：通过预处理横向和纵向的0分布，快速判断扩展合法性  
- 状态转移方程清晰：`dp[i][j][0] = min(dp[i-1][j-1][0], min(up, left)) + 1`  

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        if(a[i][j]){
            int l=dp[i-1][j-1][0]+1;
            // 检查横向和纵向0的连续长度
            for(k=1;k<=dp[i-1][j-1][0];k++)
                if(a[i-k][j]||a[i][j-k]) break;
            dp[i][j][0] = min(l, k);
            ans = max(ans, dp[i][j][0]);
        }
```

#### 2. 刘备（4星）
**亮点**：  
- 二维前缀和+二分答案：通过矩阵和与对角线长度的双重验证  
- 分方向处理：分别处理两种对角线方向  
- 时间复杂度优化：O(n² logn)适合较大数据  

**核心思路**：
```cpp
bool check(int k){
    for(i=1;i<=n-k+1;i++)
        for(j=1;j<=m-k+1;j++)
            if(sum矩阵和 == k && 对角线1数量 == k)
                return true;
    return false;
}
```

#### 3. 寒鸽儿（4星）
**亮点**：  
- 滚动数组优化：空间复杂度降至O(n)  
- 双向预处理：分别维护左、右、上方的连续0数量  
- 代码简洁高效：通过递推快速计算各方向限制  

**关键代码**：
```cpp
for(i=1;i<=n;i++){
    for(j=1;j<=m;j++){
        if(a[i][j]) {
            // 左上→右下方向
            dp[i][j][0] = min(dp[i-1][j-1], min(left[i][j-1], up[i-1][j])) + 1;
            // 右上→左下方向 
            dp[i][j][1] = min(dp[i-1][j+1], min(right[i][j+1], up[i-1][j])) + 1;
        }
    }
}
```

---

### 最优思路总结
1. **双向DP处理**：分别处理两种对角线方向，避免状态冲突  
2. **预处理连续0**：维护每个点左、右、上方的连续0数量，快速判断合法扩展  
3. **滚动数组优化**：大幅降低空间复杂度至O(n)级别  
4. **min限制转移**：`dp[i][j] = min(prev_dp, left, up) + 1` 确保全0区域  

---

### 相似题目推荐
1. **最大正方形**（P1387）  
   - 核心：DP求全1最大正方形  
2. **玉蟾宫**（P4147）  
   - 扩展：将模型扩展为矩形面积计算  
3. **棋盘制作**（P1169）  
   - 进阶：结合黑白交替模式的最大子矩阵  

---

### 调试心得摘录
> "在检查横向和纵向时，发现不能直接继承前一状态，必须重新扫描。后来改为预处理连续0的数量，问题迎刃而解" —— SplenD1D  
> "二分答案时忽略了矩阵旋转方向，导致对角线方向错误。分开处理两种方向后AC" —— 寒鸽儿  
> "暴力剪枝时误判已访问区域，导致漏解。改为动态取消标记后通过" —— FCBM71  

关键教训：预处理信息需严格对应方向，动态维护状态时要考虑回溯情况。

---
处理用时：74.05秒
# 题目信息

# 饥饿的奶牛

## 题目描述

有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。

现用汉语翻译为：

有 $N$ 个区间，每个区间 $x,y$ 表示提供的 $x\sim y$ 共 $y-x+1$ 堆优质牧草。你可以选择任意区间但不能有重复的部分。

对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。

## 说明/提示

$1 \leq n \leq 1.5 \times 10^5$，$0 \leq x \leq y \leq 3 \times 10^6$。

## 样例 #1

### 输入

```
3
1 3
7 8
3 4```

### 输出

```
5```

# AI分析结果



### 综合分析
本题本质是区间调度问题的最大权值变形，核心解法为动态规划。各题解主要围绕以下优化方向展开：
1. **端点排序+二分查找**：将区间按右端点排序后，利用二分快速找到最后一个不重叠区间，将复杂度优化至O(n log n)
2. **时间轴遍历**：基于最大右端点建立时间轴，通过预处理各时间点的区间信息实现线性扫描
3. **倒序DP**：从右往左处理区间，利用自然时序减少状态转移次数
4. **数据结构优化**：使用树状数组维护前缀最大值，实现高效区间查询

### 高星题解推荐
#### 1. mzgwty（★★★★★）
**核心思路**：
- 按右端点排序区间
- 二分查找最后一个右端点小于当前左端点的区间
- DP状态转移方程：`f[i] = max(f[i-1], f[j] + len)`
**亮点**：
- 清晰的排序+二分优化逻辑
- 手写二分实现避免STL开销
- 代码结构简洁易读

**核心代码**：
```cpp
sort(a+1,a+n+1,cmp); // 按右端点排序
for(int i=1 ; i<=n ; ++i) {
    int j = lower_bound(1,i-1,a[i].head); // 二分查找
    f[i] = max(f[i-1], f[j] + a[i].val);
}
```

#### 2. DennyQi（★★★★★）
**核心思路**：
- 预处理每个右端点对应的所有左端点
- 线性扫描时间轴，维护全局最大值
**亮点**：
- 时间复杂度O(n + max_y)极其高效
- 利用vector存储反向映射关系
- 无需排序的简洁实现

**核心代码**：
```cpp
vector<int> pre[3000010]; // pre[y]存储所有以y为右端点的左端点
for(int i=0; i<=3000000; ++i){
    dp[i] = dp[i-1]; // 继承前值
    for(int x : pre[i]) // 遍历所有以i为右端点的区间
        dp[i] = max(dp[i], dp[x-1] + (i-x+1));
}
```

#### 3. MichaelYoung（★★★★☆）
**核心思路**：
- 倒序处理时间轴
- 对每个位置记录可能开始的区间
**亮点**：
- 倒序DP的独特思维角度
- 空间复杂度优化至O(max_y)
- 代码量极小（仅20行）

**核心代码**：
```cpp
for(int i=lim; i; i--) {
    if(len[i]) // 存在以i为起点的区间
        f[i] = max(f[i+1], f[Right[i]+1]+len[i]);
    else
        f[i] = f[i+1];
}
```

### 关键技巧总结
1. **排序方向**：按右端点排序可自然保证无后效性
2. **状态转移优化**：二分查找/数据结构维护可快速定位有效前驱状态
3. **空间压缩**：当区间端点密集时，时间轴遍历法可极大优化空间
4. **逆向思维**：倒序处理时转移方程往往更简洁

### 相似题目推荐
1. P1803 凌乱的yyy（基础区间选择）
2. P1944 最长括号匹配（区间处理思想）
3. P1233 木棍加工（二维排序优化）

### 实用调试经验
1. **端点+1技巧**：zhy137036将区间端点+1避免零值处理，简化边界判断
2. **预判数据分布**：shenbear在题解中指出线性扫描可能优于二分的情况
3. **树状数组妙用**：skylee通过维护前缀最大值实现高效转移，适合端点离散化场景

---
处理用时：57.15秒
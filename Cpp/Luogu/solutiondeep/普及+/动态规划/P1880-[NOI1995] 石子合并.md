# 题目信息

# [NOI1995] 石子合并

## 题目描述

在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$ 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

试设计出一个算法,计算出将 $N$ 堆石子合并成 $1$ 堆的最小得分和最大得分。


## 说明/提示

$1\leq N\leq 100$，$0\leq a_i\leq 20$。

## 样例 #1

### 输入

```
4
4 5 9 4```

### 输出

```
43
54```

# AI分析结果



### 综合分析与结论
本题是环形区间DP经典问题，核心解法是将环形转化为线性（复制数组为2n长度），通过区间DP求解。关键点在于状态转移方程设计、环形处理方式及优化策略。多数题解采用标准区间DP解法，部分引入四边形不等式优化。最优思路集中在环形处理技巧与DP状态设计上。

---

### 精选题解

#### 1. Hurricane、题解（★★★★☆）
**关键亮点**：
- 引入四边形不等式优化，将复杂度从O(n³)优化至O(n²)
- 详细分析最大值无法用四边形优化的特性，给出分端点取最大值的思路
- 代码实现中分离最大最小值处理逻辑

**核心代码**：
```cpp
for(int i=(n<<1)-1;i;i--)
    for(int j=i+1;j<=(n<<1);j++){
        // 最大值处理
        fma[i][j]=max(fma[i][j-1],fma[i+1][j])+sum[j]-sum[i-1];
        // 最小值优化区间
        for(int k=smi[i][j-1];k<=smi[i+1][j];k++){
            int tt=fmi[i][k]+fmi[k+1][j]+sum[j]-sum[i-1];
            if(tt<tmp) tmp=tt,jc=k;
        }
        smi[i][j]=jc;
        fmi[i][j]=tmp;
    }
```

#### 2. FFF团题解（★★★★☆）
**关键亮点**：
- 采用记忆化搜索实现DP，避免复杂循环顺序
- 清晰展示分治思想，代码结构直观易理解
- 完整处理环形转化为2n数组的细节

**核心代码**：
```cpp
int dfs1(int L,int R){ // 最小得分
    if(f1[L][R]) return f1[L][R];
    if(L==R) return 0;
    int res=INF;
    for(int k=L;k<R;k++)
        res=min(res,dfs1(L,k)+dfs1(k+1,R)+A[R]-A[L-1]);
    return f1[L][R]=res;
}
```

#### 3. 逆流之时题解（★★★★☆）
**关键亮点**：
- 发现最大值可由端点直接推导的特性，优化计算
- 给出数学推导解释决策单调性
- 完整实现四边形不等式优化模板

**核心技巧**：
```cpp
dp2[i][j]=max(dp2[i][j-1],dp2[i+1][j])+sum[j]-sum[i-1];
// 基于端点值直接取最大，避免完整区间枚举
```

---

### 关键思路总结
1. **环形处理**：将数组复制为两倍长度（a[i+n] = a[i]），转化为线性问题
2. **状态设计**：f[i][j]表示合并i~j堆的最小/最大代价，sum预处理前缀和
3. **转移方程**：f[i][j] = min/max(f[i][k] + f[k+1][j]) + sum[j]-sum[i-1]
4. **优化技巧**：四边形不等式缩小k的枚举范围（最小值适用）

---

### 拓展训练推荐
1. P1063 能量项链（环形区间DP）
2. P4342 [IOI1998]Polygon（环形DP带运算符）
3. P1887 乘积最大（区间DP变形）

### 调试经验摘录
1. **环形边界处理**："i+n-1可能越界，需取模或两倍数组"（作者：Dorbmon）
2. **初始化陷阱**："f[i][i]=0而不是a[i]，合并自身无代价"（作者：包子入侵）
3. **前缀和优化**："sum[j]-sum[i-1]比循环累加快10倍"（作者：hfee）

关键教训：处理环形问题时，必须验证所有可能的起始点，通过多组测试数据检查边界情况。

---
处理用时：53.32秒
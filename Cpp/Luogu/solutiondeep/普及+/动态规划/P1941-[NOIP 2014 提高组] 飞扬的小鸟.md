# 题目信息

# [NOIP 2014 提高组] 飞扬的小鸟

## 题目背景

NOIP2014 提高组 D1T3

## 题目描述

Flappy Bird 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。

为了简化问题，我们对游戏规则进行了简化和改编:

游戏界面是一个长为 $n$，高为 $m$ 的二维平面，其中有 $k$ 个管道（忽略管道的宽度）。 

小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。

小鸟每个单位时间沿横坐标方向右移的距离为 $1$，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度 $x$，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度 $y$。小鸟位于横坐标方向不同位置时，上升的高度 $x$ 和下降的高度 $y$ 可能互不相同。

小鸟高度等于 $0$ 或者小鸟碰到管道时，游戏失败。小鸟高度为 $m$ 时，无法再上升。

现在,请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。

## 说明/提示

 
【输入输出样例说明】

如下图所示，蓝色直线表示小鸟的飞行轨迹，红色直线表示管道。

![](https://cdn.luogu.com.cn/upload/image_hosting/59alxbqi.png)

【数据范围】

对于 $30\%$ 的数据：$5 \leq n \leq 10, 5 \leq m \leq 10, k=0$，保证存在一组最优解使得同一单位时间最多点击屏幕 $3$ 次；

对于 $50\%$ 的数据：$5 \leq n \leq 20, 5 \leq m \leq 10$，保证存在一组最优解使得同一单位时间最多点击屏幕 $3$ 次；

对于 $70\%$ 的数据：$5 \leq n \leq 1000, 5 \leq m \leq 100$；

对于 $100\%$ 的数据：$5 \leq n \leq 10000$，$5 \leq m \leq 1000$，$0 \leq k < n$，$0 < x,y < m$，$0 < p < n$，$0 \leq l < h \leq m$， $l + 1 < h$。

## 样例 #1

### 输入

```
10 10 6 
3 9  
9 9  
1 2  
1 3  
1 2  
1 1  
2 1  
2 1  
1 6  
2 2  
1 2 7 
5 1 5 
6 3 5 
7 5 8 
8 7 9 
9 1 3 
```

### 输出

```
1
6

```

## 样例 #2

### 输入

```
10 10 4 
1 2  
3 1  
2 2  
1 8  
1 8  
3 2  
2 1  
2 1  
2 2  
1 2  
1 0 2 
6 7 9 
9 1 4 
3 8 10  ```

### 输出

```
0
3```

# AI分析结果



### 综合分析与结论
本题核心为动态规划，结合完全背包（上升多次点击）与01背包（下降一次操作）。各题解普遍采用状态 `dp[i][j]` 表示横坐标i、高度j的最小点击次数，并通过滚动数组优化空间。关键难点在于处理边界条件（如高度到顶）、管道遮挡判断及状态转移优化。

---

### 高星题解推荐

#### 1. 蒟蒻zExNocs（★★★★★）
**关键亮点**  
- 完整的状态转移方程推导，明确区分完全背包与01背包逻辑  
- 滚动数组优化空间至O(m)，代码注释清晰  
- 处理管道遮挡逻辑简洁（直接赋INF），并给出失败时的管道计数方法  
**核心代码片段**  
```cpp
// 上升转移（完全背包）
for(int j=x[i]+1;j<=x[i]+m;j++) 
    dp[i%2][j] = min(dp[i%2^1][j-x[i]]+1, dp[i%2][j-x[i]]+1);
// 下降转移（01背包）
for(int j=1;j<=m-y[i];j++)
    dp[i%2][j] = min(dp[i%2][j], dp[i%2^1][j+y[i]]);
```

#### 2. 依然wtm（★★★★☆）
**关键亮点**  
- 通过优化将复杂度从O(nm²)降为O(nm)，详细分析错误案例  
- 提出“上升转移可复用同列状态”的优化思路  
- 输出答案时反向扫描管道通过数，逻辑严谨  
**个人心得**  
> "在处理上升转移时，若循环条件写为`j-k*x>=0`，当m不被x整除时会漏算部分状态，需修正为计算余数部分"

#### 3. 傅思维666（★★★★☆）
**关键亮点**  
- 混合背包思路清晰，独立处理上升/下降逻辑  
- 使用辅助数组分离上升和下降状态，代码可读性高  
- 对顶边(m高度)单独处理，避免越界判断  
**核心代码片段**  
```cpp
// 顶边特殊处理
for(int j=m-x[i-1];j<=m;j++)
    dp[i][m] = min(dp[i][m], dp[i-1][j]+1);
```

---

### 关键思路与技巧总结
1. **状态设计**：`dp[i][j]` 表示横坐标i、高度j的最小点击次数，滚动数组优化至两行。
2. **背包优化**：  
   - 上升（完全背包）：`dp[i][j] = min(dp[i-1][j-x], dp[i][j-x]) + 1`  
   - 下降（01背包）：`dp[i][j] = min(dp[i][j], dp[i-1][j+y])`  
3. **边界处理**：  
   - 高度达到m时不可继续上升，需单独处理  
   - 管道位置将对应区间赋为INF表示不可达  
4. **空间优化**：通过滚动数组将空间复杂度从O(nm)降为O(m)，适用于n较大的情况。

---

### 拓展与举一反三
1. **同类问题**：涉及多阶段决策与背包结合的问题，如P1541 乌龟棋（多维状态+滚动数组）、P1280 尼克的任务（时间轴动态规划）。
2. **调试技巧**：  
   - 输出中间状态矩阵排查转移错误  
   - 对特殊边界（如m高度）单独测试  
3. **优化思维**：当状态转移存在重复计算时，考虑是否能用类似背包的优化手段简化计算。

---

### 推荐练习题
1. [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541) - 多维动态规划+滚动数组  
2. [P1280 尼克的任务](https://www.luogu.com.cn/problem/P1280) - 时间轴逆向动态规划  
3. [P2854 [USACO06DEC]Cow Roller Coaster](https://www.luogu.com.cn/problem/P2854) - 背包变种+状态设计

---
处理用时：67.31秒
# 题目信息

# [NOIP 2013 普及组] 小朋友的数字

## 题目背景

NOIP2013 普及组 T3

## 题目描述

有 $n$ 个小朋友排成一列。每个小朋友手上都有一个数字，这个数字可正可负。规定每个小朋友的特征值等于排在他前面（包括他本人）的小朋友中连续若干个（最少有一个）小朋友手上的数字之和的最大值。

作为这些小朋友的老师，你需要给每个小朋友一个分数，分数是这样规定的：第一个小朋友的分数是他的特征值，其它小朋友的分数为排在他前面的所有小朋友中（不包括他本人），小朋友分数加上其特征值的最大值。

请计算所有小朋友分数的最大值，输出时保持最大值的符号，将其绝对值对 $p$ 取模后输出。


## 说明/提示

**样例解释 1**

小朋友的特征值分别为 $1,3,6,10,15$，分数分别为 $ 1,2,5,11,21$，最大值 $21$ 对 $997$ 的模是 $21$。

**样例解释 2**

小朋友的特征值分别为 $-1,-1,-1,-1,-1$，分数分别为$-1,-2,-2,-2,-2$，最大值 $-1$ 对 $7$ 的模为 $-1$，输出 $-1$。

**【数据范围】**

对于 $50\%$ 的数据，$1 \le n \le 1000$，$1 \le p \le 1000$，所有数字的绝对值不超过 $1000$；

对于 $100\%$ 的数据，$1 \le n \le {10}^6$，$1 \le p \le {10}^9$，其他数字的绝对值均不超过 ${10}^9$。

## 样例 #1

### 输入

```
5 997
1 2 3 4 5
```

### 输出

```
21
```

## 样例 #2

### 输入

```
5 7
-1 -1 -1 -1 -1
```

### 输出

```
-1
```

# AI分析结果



### 综合分析与结论
本题核心在于特征值的最大子段和计算与分数的单调性优化。特征值通过动态规划求解，分数计算的关键在于发现其单调递增特性，从而将复杂度降至O(n)并规避大数问题。最优解法通过数学观察避免高精度运算，直接通过取模策略处理溢出。多数题解使用__int128或高精度结构体，但最高效的解法基于单调性优化。

---

### 高星题解推荐
#### 1. 作者：immortal_water (★★★★★)
**关键亮点**：  
- 发现分数数组的单调性，将分数计算简化为递推关系  
- 通过中间变量维护当前最大值，允许及时取模  
- 提出只需比较首尾元素的结论，避免遍历所有分数  
**核心代码**：
```cpp
long long su = max(a,0), maxx = a, maxn = a*2;
for(int i=2; i<n; i++) {
    int c; cin >> c; su += c;
    maxx = max(maxx, su); // 维护最大子段和
    maxn += max(maxx, 0LL); // 利用单调性累加正特征值
    su = max(su, 0LL);
}
cout << max((long long)a, maxn) % p;
```

#### 2. 作者：Priori_Incantatem (★★★★☆)
**关键亮点**：  
- 使用__int128解决溢出问题，代码简洁  
- 直接按题意模拟分数计算流程，逻辑清晰  
**核心代码**：
```cpp
__int128 f[N], ans;
f[1] = t[1] = q[1] = a[1];
for(int i=2; i<=n; i++) {
    q[i] = max(q[i-1]+a[i], a[i]); // 最大子段和DP
    t[i] = max(t[i-1], q[i]);      // 特征值前缀最大值
    f[i] = (i==2) ? 2*f[1] : max(f[i-1], f[i-1]+t[i-1]);
    ans = max(ans, f[i]);
}
```

#### 3. 作者：huangjiawei (★★★★☆)
**关键思路**：  
- 将分数拆解为特征值与分数的组合最大值  
- 通过滚动变量维护历史最大组合值  
**代码片段**：
```cpp
maxx = b[1] + sc[1];
for(int i=2; i<=n; i++) {
    sc[i] = maxx;
    maxx = max(maxx, sc[i] + b[i]);
    ans = max(ans, sc[i]);
}
```

---

### 最优关键技巧总结
1. **单调性发现**：分数数组单调递增，只需比较首尾元素即可确定全局最大值  
2. **特征值计算**：最大子段和动态规划（`f[i] = max(f[i-1]+a[i], a[i])`）  
3. **溢出规避**：利用单调性在计算过程中及时取模，或使用__int128临时存储中间值  
4. **符号处理**：最终结果根据符号分开处理取模，避免负模数问题  

---

### 相似题目推荐
1. **最大子段和** - [P1115](https://www.luogu.com.cn/problem/P1115)  
2. **动态规划+大数处理** - [P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)  
3. **特征值类递推** - [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)  

---

### 题解中的个人心得摘录
1. *"发现公式后WA的两个点其实是爆long long了，这提醒我们数据范围的极端情况必须考虑"* —— 强调边界测试的重要性  
2. *"用两个long long模拟高精度时，符号处理非常容易出错"* —— 高精度实现中的常见陷阱  
3. *"突然意识到分数数组是单调的，这成为解题的关键突破口"* —— 数学观察对算法优化的决定性作用

---
处理用时：63.20秒
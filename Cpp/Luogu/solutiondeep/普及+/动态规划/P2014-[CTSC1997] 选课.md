# 题目信息

# [CTSC1997] 选课

## 题目描述

在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？


## 样例 #1

### 输入

```
7  4
2  2
0  1
0  4
2  1
7  1
7  6
2  2
```

### 输出

```
13```

# AI分析结果



### 综合分析与结论
该题本质是树形背包问题，核心在于处理依赖关系与子树合并。题解主要围绕以下方向展开：
1. **树形DP+背包思想**：将课程依赖关系视为树结构，通过分组背包合并子树结果（最优解主流方法，复杂度O(NM)）
2. 多叉转二叉：通过左儿子右兄弟表示法简化树结构（实现略复杂但易于理解）
3. DFS序优化：转化为线性DP问题（理论最优复杂度但实现难度较高）

### 高星题解推荐
#### 1. He_Ren（★★★★★）
**核心亮点**：
- 引入虚拟根节点统一森林结构
- 清晰的三层循环背包式状态转移（子节点视为物品组）
- 代码简洁（前向星存图+倒序循环优化空间）

**关键实现**：
```cpp
void solve(int u) {
    for(int i=head[u]; i; i=e[i].next) // 遍历子节点
        solve(e[i].to);
    for(int i=head[u]; i; i=e[i].next) // 背包合并
        for(int j=m; j>0; --j)
            for(int k=0; k<j; ++k)
                f[u][j] = max(f[u][j], f[u][j-k] + f[e[i].to][k]);
}
```

#### 2. Macesuted（★★★★☆）
**核心亮点**：
- 子树大小剪枝优化（sum变量记录子树规模）
- 显式分析树形背包的时间复杂度
- 给出增强数据（n=2000）的优化方案

**个人心得**：
> "DP的核心是状态的设计和重叠的子问题结构...树本身就是一个递归的结构，所以考虑在每棵子树上DP然后合并"

#### 3. wjyyy（★★★★☆）
**核心亮点**：
- 明确树形背包模板特征
- 强调父节点必选的约束条件
- 通过样例图示解释状态转移

**关键思路**：
> "每个子节点都会占用父节点i的一部分，又有一个贡献，可以选择或不选择...重量与价值的关系类似01背包"

### 关键思路总结
1. **虚拟根技巧**：通过添加0号节点将森林转为单树，统一处理边界条件
2. **倒序循环优化**：背包合并时倒序枚举容量，避免状态覆盖
3. **子树合并策略**：每个子节点视为独立物品组，使用三重循环合并（父节点容量→子节点分配）
4. **记忆化剪枝**：预处理子树大小避免无效状态计算

### 拓展训练
1. **同类型题**：
   - P2015 二叉苹果树（树形背包基础）
   - P1273 有线电视网（带权树形背包）
   - P2585 三色二叉树（多状态树形DP）
   
2. **调试经验**：
   - 循环顺序错误导致状态覆盖（必须倒序枚举容量）
   - 初始化时需将f[x][1]设为节点权值（选根必须）
   - 虚拟根处理后需将m增加1（0号节点不计学分）

```cpp
// 典型树形背包模板（关键片段）
void dfs(int u) {
    for(int v : children[u]) {
        dfs(v);
        for(int j = m; j >= 1; j--)
            for(int k = 0; k < j; k++)
                dp[u][j] = max(dp[u][j], dp[u][j-k] + dp[v][k]);
    }
}
```

---
处理用时：55.29秒
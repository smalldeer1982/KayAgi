# 题目信息

# 消息传递

## 题目描述

巴蜀国的社会等级森严，除了国王之外，每个人均有且只有一个直接上级，当然国王没有上级。如果 $A$ 是 $B$ 的上级，$B$ 是 $C$ 的上级，那么 $A$ 就是 $C$ 的上级。绝对不会出现这样的关系：$A$ 是 $B$ 的上级，$B$ 也是 $A$ 的上级。

最开始的时刻是 $0$，你要做的就是用 $1$ 单位的时间把一个消息告诉某一个人，让他们自行散布消息。在任意一个时间单位中，任何一个已经接到消息的人，都可以把消息告诉他的一个直接上级或者直接下属。

现在，你想知道：

1. 到底需要多长时间，消息才能传遍整个巴蜀国的所有人？
2. 要使消息在传递过程中消耗的时间最短，可供选择的人有那些？


## 样例 #1

### 输入

```
8

1

1

3

4

4

4

3```

### 输出

```
5

3 4 5 6 7```

# AI分析结果



### 综合分析与结论
题目本质是求树形结构下消息传递的最优起始点及最短时间。核心解法为树形DP结合贪心策略，通过预处理子树传播时间并进行排序优化。题解主要分为三类：暴力枚举根节点+树形DP（O(n² logn)）、二次扫描换根法（O(n logn)）和记忆化搜索优化（O(n logn)）。最优解法通过动态维护父节点方向信息避免重复计算。

---

### 精选高分题解

#### 1. zzw4257（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 采用二次扫描换根法将复杂度优化至O(n logn)  
- 动态维护父节点和兄弟节点的传播时间  
- 利用前缀max数组高效合并子树信息  

**核心实现**：  
```cpp
void change_root(int x){
    vector<int> son; // 合并父节点与其他子树的信息
    for(子节点y) son.push_back(dpson[y]);
    if(fa[x]) son.push_back(dpfa[x]);
    sort(son); // 按传播时间降序排序
    // 计算前缀max和后缀max数组
    for(每个子节点y){
        // 二分查找y的位置，计算排除y后的最大值
        dpfa[y] = max(前缀max[pos-1], 后缀max[pos+1]-1);
    }
    // 递归处理子树换根
}
```

#### 2. 素质玩家孙1超（⭐⭐⭐⭐）  
**关键亮点**：  
- 记忆化搜索优化，存储父子关系状态  
- 代码简洁，使用优先队列处理子树排序  
- 预处理子树信息避免重复计算  

**核心思想**：  
```cpp
int dfs(int pos, int father){
    if(dp[pos][father]) return dp[pos][father]; // 记忆化
    vector<int> son_times; 
    for(子节点to){
        son_times.push_back(dfs(to, pos));
    }
    sort(desc); // 贪心排序
    for(i=1~cnt) res = max(res, son_times[i]+cnt-i);
    return res+1; 
}
```

#### 3. 刘备（⭐⭐⭐⭐）
**关键亮点**：  
- 状态设计dp[u][fa]记录父节点状态  
- 通过父节点分类避免重复计算  
- 预处理子树信息提升效率  

**关键代码**：  
```cpp
int dfs(int u, int fa){
    if(dp[u][fa]) return dp[u][fa]; // 父节点相同的子树复用结果
    vector<int> sons = 所有非父节点的邻居;
    sort(sons); // 降序排列
    for(i=1~cnt) res = max(res, sons[i] + i);
    return dp[u][fa] = res;
}
```

---

### 最优技巧总结
1. **贪心排序策略**：处理子树时，优先处理耗时长的分支，通过排序使总时间最小化。  
2. **换根法优化**：通过两次DFS动态维护父节点方向的信息，避免重复枚举根节点。  
3. **记忆化状态设计**：以父节点作为状态参数，复用相同结构子树的计算结果。  
4. **前缀/后缀max处理**：在合并多个子树时，预处理极值数组快速计算排除某子树后的最大值。  

---

### 推荐相似题目
1. P3177 [HAOI2015] 树上染色（换根DP）  
2. P3047 [USACO12FEB] Nearby Cows（二次扫描法）  
3. P4516 [JSOI2018] 潜入行动（树形DP状态设计）  

---

### 个人心得摘录
> **Boxxxxxx**：  
> "不能简单比较f和g的值，必须重新对所有相邻边排序。因为可能存在先走部分子树→父节点→再走其他子树的更优路径。"  
> **调试经验**：在计算节点最终答案时，必须合并所有相邻边（包括父节点方向）进行全局排序，而非仅比较向下和向上传播时间。

---
处理用时：53.54秒
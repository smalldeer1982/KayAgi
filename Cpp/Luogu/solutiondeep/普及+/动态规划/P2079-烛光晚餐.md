# 题目信息

# 烛光晚餐

## 题目背景

小明准备请小红去一家咖啡厅，共进烛光晚餐。小红高兴地和他一起去了咖啡厅。

## 题目描述

小红说：“小明，你点菜吧。”小明看到菜单上有 $N$ 道菜，每道菜的价格是 $C_i$。小明对每道菜的喜爱程度是 $X_i$，小红对每道菜的喜爱程度是 $Y_i$。（喜爱程度可能为负数）（小明：以我对她的了解，我给你的数据不会错的）

小明带了 $V$ 元钱，他点的菜的总价格不能超过 $V$（小明：当然得我请客啦，显得我大方。）

小明希望让小红吃得开心，所以当然要让她的总喜爱程度尽量大。当然，小明也要考虑自己的感受，点的所有菜的总喜爱程度需要大于等于 $0$。（小明：要是我吃得不好，她看见我会难过的）

请你帮小明写一个程序，计算出他的总喜爱程度大于等于 $0$ 的前提下，小红的喜爱程度的最大值。（小明：你的程序一定要靠谱啊，我得给她一个好印象）



## 说明/提示


对于 $10\%$ 的数据，$N\leq10$，$V\leq50$。

对于 $30\%$ 的数据，$X_i,Y_i\geq0$.

对于 $100\%$ 的数据，$N\leq100$，$V\leq500$，$|X_i|\leq5$，$|Y_i|\leq10^3$.


## 样例 #1

### 输入

```
4 10
5 -1 3
2 2 2
11 -5 100
3 -3 10
```

### 输出

```
5```

# AI分析结果



### 综合分析与结论
本题属于二维费用背包的变形，核心难点在于处理小明喜爱度的负数情况。各题解均采用偏移量法将负数映射到正数下标，通过二维动态规划维护价格与小明喜爱度的状态。关键差异在于循环顺序处理、初始化和代码可读性。

---

### 精选题解（评分≥4星）

#### 1. 作者：VioletIsMyLove（⭐⭐⭐⭐⭐）
**关键亮点**  
- 使用清晰的状态定义 `f[i][j]` 表示花费 `i` 元且小明喜爱度为 `j`（偏移500）时小红的喜爱度最大值。
- 代码简洁高效，通过反向遍历避免状态覆盖，初始化巧妙。
- 处理负数下标的平移操作简明易懂。

**核心代码**  
```cpp
memset(f, 128, sizeof f);
f[0][500] = 0;
for(int i=1; i<=n; i++) {
    // 从后向前遍历，分物品正负处理循环顺序
    for(int j=v-c[i]; j>=0; j--) 
        for(int k=1000; k>=0; k--) 
            if(f[j][k] != -INF) 
                f[j+c[i]][k+x[i]] = max(f[j+c[i]][k+x[i]], f[j][k]+y[i]);
}
```

#### 2. 作者：BigJooter（⭐⭐⭐⭐）
**关键亮点**  
- 分步骤拆解思路，从状态定义到偏移调整逐步引导。
- 状态转移方程清晰，代码中通过 `k+500` 显式处理偏移，增强可读性。
- 对最终答案的遍历逻辑简洁明确。

**核心代码**  
```cpp
memset(dp, -0x7f, sizeof dp);
dp[0][500] = 0;
for(int i=1; i<=n; i++) {
    for(int j=v; j>=a[i].c; j--) 
        for(int k=500; k>=-500; k--) 
            if(k-a[i].x在范围内)
                dp[j][k+500] = max(dp[j][k+500], dp[j-a[i].c][k-a[i].x+500] + a[i].y);
}
```

#### 3. 作者：yhk1001（⭐⭐⭐⭐）
**关键亮点**  
- 明确分情况讨论正负数的循环顺序，避免状态覆盖。
- 初始化与偏移处理规范，代码结构清晰易维护。

**核心代码**  
```cpp
memset(dp, -0x3f, sizeof dp);
dp[0][500] = 0;
for(int i=1; i<=n; i++) {
    if(x[i] >= 0) {
        // 正数反向遍历
        for(int k=1000; k >= x[i]; k--) 
            dp[j][k] = max(dp[j][k], dp[j-c[i]][k-x[i]] + y[i]);
    } else {
        // 负数正向遍历
        for(int k=0; k <= 1000 + x[i]; k++) 
            dp[j][k] = max(dp[j][k], dp[j-c[i]][k-x[i]] + y[i]);
    }
}
```

---

### 关键思路与技巧总结
1. **偏移量法**：将小明喜爱度的负数范围平移到正数（如+500），解决数组下标越界问题。
2. **分方向遍历**：对正负属性的物品分别采用逆序/顺序遍历，避免同一物品多次选择。
3. **状态初始化**：`dp[0][offset] = 0` 表示初始状态，其余设为负无穷表示不可达。
4. **多维压缩**：通过滚动数组或倒序遍历优化空间复杂度。

---

### 拓展与举一反三
- **同类题目**  
  - [P2340 奶牛展览会](https://www.luogu.com.cn/problem/P2340)：类似二维费用+偏移量的背包。
  - [P1855 榨取kkksc03](https://www.luogu.com.cn/problem/P1855)：二维费用背包基础题。
  - [P1509 精卫填海](https://www.luogu.com.cn/problem/P1509)：体积与价值双约束。

- **调试心得**  
  - 初始化时需明确无效状态（如设为极小值），避免默认0导致错误转移。
  - 循环顺序错误会导致同一物品多次计算（如正数未逆序遍历）。

---

### 核心代码片段（以VioletIsMyLove为例）
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[505][1005], n, v, c, x, y, ans;

int main() {
    memset(f, 128, sizeof f); // 初始化为-INF
    cin >> n >> v;
    f[0][500] = 0; // 偏移500处理负数
    for(int i=1; i<=n; i++) {
        cin >> c >> x >> y;
        for(int j=v-c; j>=0; j--) 
            for(int k=1000; k>=0; k--) 
                if(f[j][k] != -2139062144) 
                    f[j+c][k+x] = max(f[j+c][k+x], f[j][k] + y);
    }
    for(int i=0; i<=v; i++)
        for(int j=500; j<=1000; j++) 
            ans = max(ans, f[i][j]);
    cout << ans;
}
```

---
处理用时：67.15秒
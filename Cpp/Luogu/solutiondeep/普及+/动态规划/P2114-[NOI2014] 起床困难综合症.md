# 题目信息

# [NOI2014] 起床困难综合症

## 题目描述

$21$ 世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因：在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。正是由于 drd 的活动，起床困难综合症愈演愈烈，以惊人的速度在世界上传播。为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙。历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 $n$ 扇防御门组成。每扇防御门包括一个运算 $op$ 和一个参数 $t$，其中运算一定是 $\text{OR},\text{XOR},\text{AND}$ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $x$，则其通过这扇防御门后攻击力将变为 $x~op~t$。最终 drd 受到的伤害为对方初始攻击力 $x$ 依次经过所有 $n$ 扇防御门后转变得到的攻击力。

由于 atm 水平有限，他的初始攻击力只能为 $0$ 到 $m$ 之间的一个整数（即他的初始攻击力只能在 $0,1,\ldots,m$ 中任选，但在通过防御门之后的攻击力不受 $m$ 的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。

## 说明/提示

【样例说明】

atm 可以选择的初始攻击力为 $0,1,\ldots ,10$。

假设初始攻击力为 $4$，最终攻击力经过了如下计算

- $4 \text{ AND } 5 = 4$；
- $4 \text{ OR } 6 = 6$；
- $6 \text{ XOR } 7 = 1$。

类似的，我们可以计算出初始攻击力为 $1,3,5,7,9$ 时最终攻击力为 $0$，初始攻击力为 $0,2,4,6,8,10$ 时最终攻击力为 $1$，因此atm的一次攻击最多使drd受到的伤害值为 $1$。

【数据规模与约定】

![](https://cdn.luogu.com.cn/upload/image_hosting/29yj7o58.png)

- 特殊性质 $\mathrm A$：存在一扇防御门为 $\texttt{AND 0}$；
- 特殊性质 $\mathrm B$：所有防御门的操作均相同。

对于所有数据，保证 $2\le n\le 10^5$，$0\le m\le 10^9$，$0\le t\le 10^9$，且 $\mathrm{op}$ 一定为 $\verb!AND!,\verb!OR!,\verb!XOR!$ 中的一种。


## 样例 #1

### 输入

```
3 10
AND 5
OR 6
XOR 7```

### 输出

```
1```

# AI分析结果



### 综合分析与结论
本题核心在于利用位运算的独立性，通过预处理每位在初始0/1时的最终结果，结合贪心策略（高位优先）构造最优解。所有题解均围绕这一核心展开，区别在于实现细节与代码优化。

---

### 高星题解推荐

#### 1. 小粉兔（5星）
**关键亮点**：
- 使用两个变量`a1=0`（全0）和`a2=-1`（全1）预处理所有门后的结果
- 逐位贪心时优先选0换1，代码简洁高效（仅10行核心逻辑）
- 时间复杂度O(n + log m)，完美适配题目规模

**核心代码**：
```cpp
int a1=0, a2=-1;
// 预处理所有门
for(int j=29;~j;--j){
    if(a1>>j&1) ans += 1<<j;          // 0变1必选
    else if(a2>>j&1 && (1<<j)<=m) {   // 1变1且不超限
        ans += 1<<j;
        m -= 1<<j;
    }
}
```

#### 2. cuking（4.5星）
**关键亮点**：
- 用`bool1=0x7fffffff`（全1）和`bool0=0`预处理结果
- 详细分析每位四种转换情况，逻辑清晰易扩展
- 代码可读性强，适合教学讲解

**核心思路**：
```cpp
int bool1=0x7fffffff, bool0=0;
// 处理所有门后
for(int i=30;i>=0;i--){
    if(bool0&(1<<i)) ans += 1<<i;       // 0变1必选
    else if(m >= (1<<i) && bool1&(1<<i)){ 
        ans += 1<<i;                    // 1变1且允许选
        m -= 1<<i;
    }
}
```

#### 3. Drinkkk（4星）
**个人心得**：
> "90分做法因未处理int溢出问题WA，最终将`1<<i`改为`1LL<<i`后AC。教训：位运算必须注意类型范围"

**关键优化**：
- 显式处理long long类型避免溢出
- 逆向枚举位时直接判断剩余预算

---

### 关键技巧总结
1. **预处理法**：用全0/全1通过所有门，快速得到每位最终状态
2. **高位贪心**：从最高位开始，优先保证高位为1
3. **预算管理**：在允许范围内（m的约束）选择最优位
4. **位运算优化**：使用位掩码和移位代替乘除，提升效率

---

### 拓展练习
1. [P5657 格雷码](https://www.luogu.com.cn/problem/P5657)（位运算构造）
2. [P2119 魔法阵](https://www.luogu.com.cn/problem/P2119)（位运算优化枚举）
3. [P2115 [USACO14MAR]Sabotage G](https://www.luogu.com.cn/problem/P2115)（位运算+贪心）

---
处理用时：47.46秒
# 题目信息

# 小Z的电力管制

## 题目描述

小 Z 在供电公司找到了一份工作，刚上班就遇到了一个棘手的任务。

小 Z 所在的城市可以看成一个 $n \times m$ 的网格，第 $i$ 行第 $j$ 列的格子有电力需求 $a_{i,j}$ 。然而，供电公司能够供应的电力 $u$ 小于每格的电力需求之和。为此，供电公司不得不将城市划分成若干个区域，每个区域轮流断电，使得断电后剩余区域的电力需求之和不超过供电公司能够供应的电力。

为了方便起见，划分区域的方式很简单，每次将大区域横向或纵向划分成两个小区域，递归进行。

供电公司想尽可能减少市民的不满，因此需要小 Z 计算出最多能划分成多少个区域以及在此前提下能够剩余的最多电力（一种划分的剩余电力为每次断电后剩余电力的最小值），希望你帮帮他。




## 说明/提示

对于 $60\%$ 的数据，$1\leq n ,m \leq 10$ 。

对于 $100\%$ 的数据， $1 \leq n,m \leq 32,1 \leq a_{i,j} \leq 100$ 。

## 样例 #1

### 输入

```
3 3 33
4 4 2
2 9 6
6 5 3```

### 输出

```
4 1```

## 样例 #2

### 输入

```
3 4 15
1 2 1 2
2 1 2 1
1 2 1 2```

### 输出

```
6 0```

# AI分析结果



### 题解综合分析与结论
题目要求将网格划分为多个区域，确保任意区域断电后剩余总电力不超过供电能力。核心思路是递归或动态规划处理四维状态，利用二维前缀和快速计算区域总和。关键点在于确保每个区域的总和 ≥ sum_total - u，并在合并时优先最大化区域数，其次剩余电力。

---

### 高分题解推荐

#### 1. 作者：_111_ （★★★★★）
**关键亮点**  
- 采用动态规划自底向上求解，无递归开销，效率更优。  
- 定义双四维数组分别存储最大区域数和对应的剩余电力最大值，逻辑清晰。  
- 预处理前缀和，五层循环结构处理所有子矩阵分割可能，确保无遗漏状态。  

**代码核心思想**  
```cpp
for (int len1 = 1; len1 <= n; len1++) { // 枚举子矩阵高度
    for (int len2 = 1; len2 <= m; len2++) { // 枚举子矩阵宽度
        for (int x1 = 1, x2 = x1 + len1 - 1; x2 <= n; x1++, x2++) {
            for (int y1 = 1, y2 = y1 + len2 - 1; y2 <= m; y1++, y2++) {
                // 检查当前子矩阵是否满足总和≥sum_total - u
                int current_sum = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];
                if (current_sum < sum) continue;
                
                // 初始化当前状态
                dp1[x1][y1][x2][y2] = 1;
                dp2[x1][y1][x2][y2] = current_sum - sum;
                
                // 横向分割
                for (int k = x1; k < x2; k++) {
                    if (dp1[x1][y1][k][y2] && dp1[k+1][y1][x2][y2]) {
                        // 更新最大区域数和剩余电力
                        update_state(x1, y1, x2, y2, k, true);
                    }
                }
                // 纵向分割（类似横向逻辑）
            }
        }
    }
}
```

#### 2. 作者：Usada_Pekora （★★★★☆）
**关键亮点**  
- 记忆化搜索实现直观，避免重复计算。  
- 通过递归横向/纵向分割，优先合并最优子结果。  
- 使用 `pair<int, int>` 存储状态，代码简洁。  

**代码核心思想**  
```cpp
pii dfs(int x1, int y1, int x2, int y2, int all) {
    if (f[x1][y1][x2][y2].first) return f[x1][y1][x2][y2];
    // 边界条件处理
    pii best = {1, u - (total_sum - all)};
    
    // 尝试纵向分割
    for (int i = y1; i < y2; i++) {
        int s1 = calc_sum(x1, y1, x2, i);
        int s2 = calc_sum(x1, i+1, x2, y2);
        if (total_sum - s1 <= u && total_sum - s2 <= u) {
            pii left = dfs(x1, y1, x2, i, s1);
            pii right = dfs(x1, i+1, x2, y2, s2);
            update_best(best, left, right); // 合并结果
        }
    }
    // 横向分割（类似纵向逻辑）
    return f[x1][y1][x2][y2] = best;
}
```

---

### 关键思路总结
1. **条件转化**：区域总和需满足 `sum_total - A_i ≤ u` → `A_i ≥ sum_total - u`。  
2. **状态设计**：四维数组记录子矩阵的最优解（区域数、剩余电力）。  
3. **分割策略**：横向/纵向枚举分割点，检查子区域合法性后合并结果。  
4. **优化技巧**：前缀和快速计算区域总和；动态规划按子矩阵大小递增处理。  

---

### 相似题目推荐
1. **P1436 棋盘分割**：四维DP处理矩阵分割最小方差。  
2. **P5752 棋盘分割（另一版本）**：类似动态规划思路。  
3. **P4177 [CEOI2008] order**：资源分配与分割策略。  

---

### 题解中的个人心得摘录
- **条件判断**：`sum_total - u` 的定义容易混淆，需仔细处理避免逻辑错误（_111_）。  
- **类比经验**：棋盘分割问题的递归思路可直接迁移（Think）。  
- **调试技巧**：通过小样例验证分割条件是否正确，避免错误累积（Usada_Pekora）。

---
处理用时：245.69秒
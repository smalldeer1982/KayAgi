# 题目信息

# [HNOI2001] 遥控赛车比赛

## 题目描述

全国遥控赛车大赛近日在星沙举行。竞赛选用一块大小为 $N\times M$ 的场地作为竞赛场地，要求选手的赛车在最短的时间内从起点移动到终点。虽然赛场地形高低有少许的起伏，但并不存在无法到达的地点。但是在赛场上增加了许多无法穿越的障碍物，若赛车在到达终点前撞上障碍物，就视为任务失败。

在赛车的马力和灵活性等性能相差较小的情况下，要控制速度极快的赛车绕开障碍物移动到终点，关键是提高选手的反应灵敏度，即两次改变赛车运动方向所间隔的最短时间，也可称为选手的反应时间。使自己能够更快地控制赛车改变前进的方向。

当然，由于选手反应灵敏度的不同，可选择的路径就会大不相同。如图 $1$ 和图 $2$ 所示，对于同一个赛场，两位选手的反应时间分别为 $2$ 秒和 $1$ 秒，而其到达终点所需的时间分别为 $18$ 秒和 $16$ 秒（赛车每秒可沿当前方向移动一格，从起点出发时算改变一次方向）。

由图 $1$ 和图 $2$ 可知，赛车的最短路线长度是由选手的反应灵敏度所决定的，当选手的反应很慢时，可能就不会存在可行的路径。你的任务是：在能够完成赛程（即存在从起点到终点的路径）的条件下，求出选手每个可能的反应时间所对应的最短路线长度。

![](https://cdn.luogu.com.cn/upload/pic/1294.png)


## 样例 #1

### 输入

```
10 10                                   
1 4 10 7                                 
0 0 0 1 0 0 0 0 0 0
0 0 0 1 1 1 0 0 0 0
0 0 0 1 0 1 0 0 0 0
1 1 1 1 0 1 1 1 1 0
1 0 0 0 0 0 0 0 1 0
1 0 1 1 1 0 1 1 1 0
1 1 1 0 1 1 1 0 1 0
0 0 1 0 0 0 0 0 1 0
0 0 1 1 1 1 1 1 1 0
0 0 0 0 0 0 1 0 0 0
```

### 输出

```
1 16
2 18
```

# AI分析结果



### 综合分析与结论
该题本质是带状态约束的最短路径问题，核心在于通过扩展BFS状态（位置+方向+连续直行步数）来处理转向间隔限制。各题解均围绕状态设计和剪枝优化展开，最优解法通过允许重复访问节点但仅在更优状态下更新，确保路径最短性。

---

### 高星题解推荐

#### 1. 作者：George1123（★★★★★）
**关键亮点**  
- 引入三维状态 `(x,y,方向)` + 连续直行步数，精准建模转向限制  
- 处理「重复路径但更优状态」的特殊情况，解决传统BFS遗漏路径问题  
- 代码中通过 `a <= f[x][y][k]` 判断状态优劣，确保剪枝正确性  

**核心代码思想**  
```cpp
void bfs(int z){ //z为当前反应时间
    //状态队列初始化
    while(!q.empty()){
        Node now = q.front();
        for(四个方向){
            if(同方向直行) 更新连续步数
            else if(满足转向条件z) 重置步数
            if(新状态更优 || 连续步数更长可能带来后续优势){
                更新状态并入队
            }
        }
    }
}
```

#### 2. 作者：船酱魔王（★★★★★）
**关键亮点**  
- 使用0-1 BFS优化，直行操作权值为1，转向操作权值为0  
- 状态设计 `(x,y,方向,剩余冷却时间)`，利用双端队列保证时间复杂度  
- 预处理灵敏度从高到低计算，复用部分路径信息  

**核心实现片段**  
```cpp
for(int k = 0; k < 4; k++){ //方向扩展
    if(直行) 更新冷却时间并入队尾
    if(转向冷却完毕) 重置冷却并入队首
}
```

#### 3. 作者：CYJian（★★★★）
**关键亮点**  
- 通过反向绕路案例发现传统BFS的缺陷  
- 增加「连续步数记录比较」机制，允许同一位置不同状态覆盖  
- 最终版BFS实现简洁且正确处理特殊路径  

**调试心得**  
> "发现灵异事件：之前可能绕不过的弯，从其他路径绕回后反而能过，需增加状态覆盖判断"

---

### 关键思路与技巧总结
1. **状态扩展**：在BFS中增加「方向+连续直行步数」维度，`f[x][y][dir][step]` 表示在(x,y)朝dir方向已直行step步  
2. **剪枝优化**：仅当新状态的连续步数更短或能带来后续转向优势时才更新  
3. **双队列优化**：直行操作入队尾（权1），转向操作入队首（权0），保证层序正确性  
4. **逆向处理**：对灵敏度从大到小计算，复用已构建的路径结构  

---

### 拓展练习推荐
1. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120) - 带剪枝的状态搜索  
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443) - 基础方向约束BFS  
3. [P3959 宝藏](https://www.luogu.com.cn/problem/P3959) - 状态压缩与路径复用的综合应用

---
处理用时：65.13秒
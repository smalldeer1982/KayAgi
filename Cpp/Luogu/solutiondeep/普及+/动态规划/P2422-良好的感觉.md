# 题目信息

# 良好的感觉

## 题目描述

kkk 做了一个人体感觉分析器。每一天，人都有一个感受值 $A_i$，$A_i$ 越大，表示人感觉越舒适。在一段时间 $\left[i, j\right]$ 内，人的舒适程度定义为 $\left[i, j\right]$ 中最不舒服的那一天的感受值 $\times$ $\left[i, j\right]$中每一天感受值的和。现在给出 kkk 在连续 $N$ 天中的感受值，请问，在哪一段时间，kkk 感觉最舒适？


## 说明/提示

kkk 最开心的一段时间是第 $3$ 天到第 $5$ 天，开心值：$(6+4+5)\times4=60$。

对于 $30\%$ 的数据，$1\le N\le 100$。

对于 $70\%$ 的数据，$1\le N\le 2000$。

对于 $100\%$ 的数据，$1\le N\le 100000$，$1\le \texttt{感受值}\le 1000000$。

## 样例 #1

### 输入

```
6
3 1 6 4 5 2```

### 输出

```
60```

# AI分析结果



### 综合分析与结论
本题核心是求区间最小值与区间和乘积的最大值。最优解法需在O(n)时间复杂度内完成，常见思路为**单调栈确定左右边界**或**悬线法预处理扩展范围**。关键技巧在于将问题转化为枚举每个元素作为最小值时的最大有效区间。

---

### 高评分题解推荐（≥4星）

#### 1. xMinh（5星） - 单调栈 + 前缀和
**核心思路**  
- 维护单调递增栈，栈顶元素弹出时确定其右边界（当前元素），左边界为次栈顶元素。
- 前缀和快速计算区间和，末尾添加0强制处理剩余元素。
**代码亮点**  
```cpp
while (a[q[tail]]>a[i]) {
    f[q[tail]] += (sum[i-1]-sum[q[tail]]);
    tail--;
}
f[i] = sum[i] - sum[q[tail]];
```
**个人心得**  
作者通过添加末尾哨兵元素解决未处理元素的边界问题，这种技巧在单调栈问题中常见。

#### 2. peterwuyihong（5星） - 悬线法
**核心思路**  
- 两次遍历预处理每个元素向左/右扩展的最远位置（区间内元素均≥当前值）。
- 直接计算每个元素对应的最大区间和。
**代码亮点**  
```cpp
// 左边界预处理
for(int i=1;i<=n;i++)
    while(l[i]>1 && a[i]<=a[l[i]-1]) l[i]=l[l[i]-1];
// 右边界预处理
for(int i=n;i;i--)
    while(r[i]<n && a[i]<=a[r[i]+1]) r[i]=r[r[i]+1];
```
**优势**  
逻辑直观，无需复杂数据结构，适合熟悉线性预处理思维的选手。

#### 3. Treaker（5星） - 双单调栈分治
**核心思路**  
- 分别用单调栈处理左右第一个比当前元素小的位置。
- 前缀和计算区间和，取最大值。
**代码亮点**  
```cpp
// 左边界处理
while(top && a[st[top]] >= a[i]) top--;
l[i] = st[top];
// 右边界处理
while(top && a[st[top]] >= a[i]) top--;
r[i] = st[top] - 1;
```
**优势**  
左右边界分开处理更易理解，代码模块化清晰。

---

### 关键技巧总结
1. **单调栈确定极值区间**：通过维护单调性快速找到左右第一个更小元素，O(n)时间复杂度。
2. **前缀和优化区间求和**：预处理前缀和数组，将区间和计算降至O(1)。
3. **哨兵元素处理边界**：在数组首尾添加极小值，避免特殊判断未处理元素。

---

### 拓展与相似题目
1. **柱状图中的最大矩形**（LeetCode 84 / 洛谷P4147）  
   - 同类思路：每个柱子高度作为矩形高度的最大宽度。
2. **子数组最小值的和**（LeetCode 907）  
   - 单调栈统计每个元素作为最小值的贡献次数。
3. **最大子序和**（洛谷P1115）  
   - 结合动态规划与贪心思想，与区间和相关。

---

### 核心代码片段（xMinh版）
```cpp
n++; a[n] = 0; // 末尾添加哨兵
for(int i=1; i<=n; i++) {
    sum[i] = sum[i-1] + a[i];
    while (a[q[tail]] > a[i]) { // 维护单调性
        f[q[tail]] += sum[i-1] - sum[q[tail]]; // 右边界确定
        tail--;
    }
    f[i] = sum[i] - sum[q[tail]]; // 左边界为次栈顶
    q[++tail] = i;
}
```
**实现思想**：通过单调栈动态维护元素的扩展范围，结合前缀和快速计算区间贡献值。

---
处理用时：63.44秒
# 题目信息

# [SCOI2008] 着色方案

## 题目描述

有 $n$ 个木块排成一行，从左到右依次编号为 $1$ 至 $n$。

你有 $k$ 种颜色的油漆，第 $i$ 种颜色的油漆足够涂 $c_i$ 个木块。

所有油漆刚好足够涂满所有木块，即 $\sum_{i=1}^kc_i=n$。

由于相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。

由于答案可能很大，请输出对 $10^9+7$ 取模的结果。

## 说明/提示

- 对于 $50\%$ 的数据，$1 \leq k \leq 5$，$1 \leq c_i \leq 3$；
- 对于 $100\%$ 的数据，$1 \leq k \leq 15$，$1 \leq c_i \leq 5$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
10```

## 样例 #2

### 输入

```
5
2 2 2 2 2```

### 输出

```
39480```

## 样例 #3

### 输入

```
10
1 1 2 2 3 3 4 4 5 5
```

### 输出

```
85937576```

# AI分析结果



### 综合分析结论
本题核心在于高效的状态设计以处理相邻颜色限制。各题解主要采用两种思路：  
1. **多维DP+记忆化搜索**：利用剩余次数作为状态维度，通过`last`参数避免相邻同色，时空高效，适合数据范围。  
2. **组合数学+动态规划**：通过分组插入与组合数计算方案数，复杂度较高但具有理论价值。  
六维记忆化搜索因代码简洁、效率高成为最优解。

---

### 精选题解（评分≥4星）

#### 题解1：Bartholomew（5星）
**关键亮点**：  
- **六维状态设计**：`dp[a][b][c][d][e][last]`表示各剩余次数的颜色数及上一次使用的剩余次数。  
- **记忆化搜索**：避免重复计算，代码简洁高效。  
- **转移方程清晰**：通过`last`参数避免相邻颜色冲突，乘法原理应用得当。  
**核心代码**：  
```cpp
ll DFS(int a, int b, int c, int d, int e, int last) {
    if (a + b + c + d + e == 0) return 1;
    ll &res = dp[a][b][c][d][e][last];
    if (res != -1) return res;
    res = 0;
    if (a) res += (a - (last == 2)) * DFS(a-1, b, c, d, e, 1);
    if (b) res += (b - (last == 3)) * DFS(a+1, b-1, c, d, e, 2);
    // 类似处理c, d, e...
    return res % MOD;
}
```

#### 题解2：逃离地球（4星）
**关键亮点**：  
- **综合多种算法**：详细分析暴力DP、组合DP、容斥等思路，拓展性强。  
- **组合数学优化**：算法四通过容斥与背包卷积降低复杂度，适合进阶学习。  
**核心思路**：  
```cpp
// 容斥+背包DP求f_k
for (每种颜色分块数ki) {
    f[k] += 组合数乘积 * (n-k)! / 乘积(ci - ki)!
}
```

#### 题解3：Log_x（4星）
**关键亮点**：  
- **状态转移详解**：逐项解释颜色选择时的系数调整，适合理解原理。  
- **边界处理明确**：初始化为`f[0][0][0][0][0][i]=1`，逻辑严谨。  

---

### 关键思路与技巧
1. **状态压缩**：利用剩余次数而非具体颜色编号，极大减少状态数。  
2. **last参数**：记录上一次颜色的剩余次数，避免相邻相同。  
3. **记忆化搜索**：自然处理状态转移，避免手动递推顺序问题。  
4. **组合数预处理**：加速分组插入时的方案数计算。  

---

### 拓展与相似题目
1. **P2513 [逆序对统计](https://www.luogu.com.cn/problem/P2513)**：状态压缩与动态规划结合。  
2. **P4071 [SDOI2016]排列计数](https://www.luogu.com.cn/problem/P4071)**：容斥原理与错位排列。  
3. **P3223 [HNOI2012]排队](https://www.luogu.com.cn/problem/P3223)**：组合数学与插空法应用。  

---

### 个人心得摘录
- **边界条件**：务必初始化`f[0][0][0][0][0][*]=1`，否则搜索无法终止。（@Bartholomew）  
- **取模陷阱**：每次运算后立即取模，避免溢出。（@ADay）  
- **代码细节**：`last`参数对应剩余次数而非颜色ID，转移时需精确匹配。（@Log_x）

---
处理用时：63.04秒
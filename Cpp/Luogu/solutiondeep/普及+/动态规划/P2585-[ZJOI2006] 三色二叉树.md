# 题目信息

# [ZJOI2006] 三色二叉树

## 题目描述

一棵二叉树可以按照如下规则表示成一个由 $0$、$1$、$2$ 组成的字符序列，我们称之为“二叉树序列 $S$”：

$$S=
\begin{cases}
0& \text表示该树没有子节点\\
1S_1& 表示该树有一个节点，S_1 为其子树的二叉树序列\\
2S_1S_2& 表示该树由两个子节点，S_1 和 S_2 分别表示其两个子树的二叉树序列
\end{cases}$$

例如，下图所表示的二叉树可以用二叉树序列 $S=\texttt{21200110}$ 来表示。

![haha.png](https://i.loli.net/2020/04/27/Ijw8ZEWCKH2rtJG.png)

你的任务是要对一棵二叉树的节点进行染色。每个节点可以被染成红色、绿色或蓝色。并且，一个节点与其子节点的颜色必须不同，如果该节点有两个子节点，那么这两个子节点的颜色也必须不同。给定一颗二叉树的二叉树序列，请求出这棵树中**最多和最少**有多少个点能够被染成绿色。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq |s| \leq 5 \times 10^5$，$s$ 中只含字符 `0` `1` `2`。

## 样例 #1

### 输入

```
1122002010```

### 输出

```
5 2```

# AI分析结果



### 综合分析与结论
本题核心为树形DP，需处理父子节点颜色约束并统计绿色节点数量。各题解均围绕动态规划状态设计展开，核心差异在于状态定义（是否显式区分三种颜色）和建树方式（显式建树/递归处理序列）。关键难点在于正确转移条件（父子颜色互异、兄弟颜色互异）以及优化状态数。

#### 高星题解推荐
1. **消失的海岸线（4.5星）**  
   **关键亮点**：  
   - 状态简化：仅用 `f[i]`（染绿）和 `g[i]`（非绿）两种状态，降低复杂度。  
   - 转移方程清晰：染绿时子节点必须全非绿，非绿时子节点需一绿一非绿。  
   **核心代码**：  
   ```cpp
   // 最大值转移
   f[i] = g[ch[i][1]] + g[ch[i][2]] + 1;  // 当前染绿
   g[i] = max(f[ch[i][1]] + g[ch[i][2]], f[ch[i][2]] + g[ch[i][1]]); // 当前非绿
   ```

2. **Fading（4星）**  
   **关键亮点**：  
   - 详细分析父子颜色约束：明确指出两个子节点不能同时非绿（抽屉原理）。  
   - 递推实现：倒序DP避免递归开销。  
   **核心代码**：  
   ```cpp
   for (int i=n;i>=1;i--) {
       f[i][1] = f[lc][0] + f[rc][0] + 1;  // 当前染绿
       f[i][0] = max(f[lc][1] + f[rc][0], f[lc][0] + f[rc][1]); // 非绿
   }
   ```

3. **hs_black（4星）**  
   **关键亮点**：  
   - 无显式建树：直接利用输入序列递归处理子树。  
   - 代码简洁：通过全局 `cnt` 记录递归位置，避免额外空间。  
   **核心代码**：  
   ```cpp
   void dfs(int x) {
       if (s[x] == '0') { dp[x][0] = 1; return; }
       dfs(++cnt);  // 递归处理左子树
       if (s[x] == '2') dfs(++cnt);  // 处理右子树
       // 根据子节点状态更新当前节点
   }
   ```

---

### 关键思路与技巧总结
1. **状态压缩**：将颜色分为「绿色」和「非绿色」两类，减少状态维度。  
2. **递归序列处理**：利用输入序列的递归特性直接处理子树，无需显式建树。  
3. **边界条件剪枝**：叶节点直接初始化，避免冗余计算。  
4. **颜色约束转化**：通过数学推导（如抽屉原理）简化兄弟节点的颜色组合判断。

---

### 拓展与举一反三
1. **相似题目推荐**  
   - [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)（树形DP基础）  
   - [P4516 [JSOI2018] 潜入行动](https://www.luogu.com.cn/problem/P4516)（复杂状态转移）  
   - [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)（树形DP+背包）  

2. **调试心得摘录**  
   - **Fading**：强调「两个子节点不能同时非绿」，避免遗漏约束条件。  
   - **Y_BY**：通过反向遍历避免递归爆栈，优化空间效率。  

---

### 核心代码实现（消失的海岸线简化版）
```cpp
void build(int &x) {  // 递归建树
    x = ++cnt;
    int opt = str[cnt] - '0';
    if (opt == 1) build(ch[x][1]);
    if (opt == 2) build(ch[x][1]), build(ch[x][2]);
}

// DP转移（最大值）
for (int i = n; i >= 1; i--) {
    f[i] = g[ch[i][1]] + g[ch[i][2]] + 1;  // 当前染绿
    g[i] = max(f[ch[i][1]] + g[ch[i][2]], f[ch[i][2]] + g[ch[i][1]]); 
}
```

---
处理用时：63.37秒
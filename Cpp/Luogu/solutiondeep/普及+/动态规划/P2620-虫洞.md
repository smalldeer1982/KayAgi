# 题目信息

# 虫洞

## 题目背景

applepi 想进行宇宙旅行。当然，applepi 知道这是有可能的，因为 applepi 的特殊能力能使他观测到宇宙中的虫洞。所谓虫洞就是一个在三维之外的维度打开的快捷通道，通过虫洞能够从一个地方瞬间移动到另外一个地方。


## 题目描述

为了简化问题，我们建立一个一维坐标系，地球的位置为 $0$，而applepi 的目的地的位置是一个正整数 $W$。

在每一个单位时间里，applepi 可以向正方向移动不超过 $S$ 的一个整数。虫洞可以被表示为二元组 $(B, E)$，即如果在某次移动之后 applepi 在位置 $B$，那么 applepi 就会被立刻传送到位置 $E$。

注意，applepi 在移动过程中如果经过位置 $B$，由于applepi 的速度极快是不会被传送的。而且，applepi 不能够向负方向移动，但是虫洞引起的除外。

现在applepi 想请你帮助他计算一下他至少需要多少个单位时间才能够到达目的地。


## 说明/提示

对于 $30\%$ 的数据，$W≤1000$。

对于 $100\%$ 的数据，$W≤10^9$，$2≤S≤6$，$1≤P≤40$，没有 $B = 0$ 或者 $B = W$ 的虫洞，输入数据保证目的地可达。


## 样例 #1

### 输入

```
28 3 5
2 18
5 13
12 6
17 25
20 15
50 6 1
9 45
0
```

### 输出

```
４
３
```

# AI分析结果



### 综合分析与结论
本题核心在于将虫洞离散化后构建有向图，并计算节点间合法路径的最短时间。各题解普遍采用离散化+最短路框架，核心差异在于边权计算方式（递归/动态规划/同余优化）和路径剪枝策略。

---

### 精选题解分析

#### 1. 作者：suxxsfe（★★★★★）
**核心亮点**：
- 递归计算边权的思路清晰易懂，详细注释帮助理解
- 离散化后采用Floyd算法，代码简洁直观
- 包含调试心得，如递归终止条件和虫洞阻挡处理

**关键代码**：
```cpp
int getDis(int x, int y) {
    if(x == y) return 0;
    if(be.count(x)) return INF; // 遇到起点直接返回
    
    int closest = y;
    // 寻找第一个可能阻挡的虫洞起点
    for(auto &hole : holes) {
        if(x < hole.B && hole.B < closest && (hole.B - x) % S == 0) 
            closest = hole.B;
    }
    // 后退直到合法点
    while(closest != y && be.count(closest)) closest--;
    
    return ceilDiv(closest - x, S) + getDis(closest, y);
}
```
**实现思想**：通过递归寻找最近可落脚点，逐段计算合法路径的步数。

#### 2. 作者：JNK_DOG（★★★★☆）
**核心亮点**：
- 使用set快速判断虫洞起点
- 离散化后预处理边权，Floyd实现简洁
- 代码结构紧凑，适合快速实现

**路径计算优化**：
```cpp
for(int i=1; i<=p; i++) 
    d[Q(x[i])][Q(y[i])] = 0; // 虫洞边权为0

for(int i=1; i<c; i++)
    for(int j=i+1; j<=c; j++) 
        d[i][j] = min(d[i][j], F(l[i], l[j]));
```

#### 3. 作者：cmd2001（★★★★☆）
**核心亮点**：
- 同余系动态规划优化状态转移
- SPFA算法处理带状态的最短路
- 处理连续虫洞起点的剪枝策略

**同余优化片段**：
```cpp
for(int mod=0; mod<S; mod++) {
    int steps = (target - cur_pos + mod) / S;
    if((target - cur_pos) % S >= mod) steps++;
    // 状态转移时保留余数信息
}
```

---

### 关键思路总结
1. **离散化压缩坐标**：仅保留虫洞端点与起终点，节点数从1e9降至约100。
2. **边权特殊计算**：需避开虫洞起点，采用递归/动态规划分段计算合法步数。
3. **同余优化**：利用步长S的余数特性，减少重复计算。
4. **最短路选择**：节点少时用Floyd（O(n³)），状态复杂时用SPFA/Dijkstra。

---

### 同类题目推荐
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)（最短路应用）
2. [P1354 房间最短路问题](https://www.luogu.com.cn/problem/P1354)（几何离散化+建图）
3. [P4568 飞行路线](https://www.luogu.com.cn/problem/P4568)（分层图最短路）

---

### 调试经验摘录
- **递归边界**：当退步到起点时需返回无穷大（suxxsfe）
- **虫洞连续阻挡**：若连续S个点均为虫洞起点，则无法通过（cmd2001）
- **离散化排序**：必须对离散点排序后二分查找（JNK_DOG）

---
处理用时：64.73秒
# 题目信息

# 科技庄园

## 题目背景

Life种了一块田，里面种了有一些桃树。

Life对PFT说：“我给你一定的时间去摘桃，你必须在规定的时间之内回到我面前，否则你摘的桃都要归我吃！”

PFT思考了一会，最终答应了！

由于PFT的数学不好！它并不知道怎样才能在规定的时间获得最大的价值，

由于PFT不是机器人，所以他的体力并不是无限的，他不想摘很多的桃以至体力为0，而白白把桃给Life。同时PFT每次只能摘一棵桃树，，每棵桃树都可以摘K次（对于同一棵桃每次摘的桃数相同）。每次摘完后都要返回出发点（PFT一次拿不了很多）即Life的所在地（0，0）{试验田左上角的桃坐标是（1，1）}。

PFT每秒只能移动一个单位，每移动一个单位耗费体力1(摘取不花费时间和体力,但只限上下左右移动)。


## 说明/提示

样例说明：

可以摘到1次（1，1）和1次（2，3），体力和时间不满足再摘桃了。

范围：

对于M，N，TI，A   10<=30%<=50  10<=100%<=100

对于K  10<=100%<=100

保证结果在long int范围内


## 样例 #1

### 输入

```
4 4 13 20
10 0  0  0
0  0  10 0
0  0  10 0
0  0  0  0
1 0 0 0
0 0 2 0
0 0 4 0
0 0 0 0```

### 输出

```
10```

# AI分析结果



### 综合分析与结论
本题本质为多重背包问题，关键是将时间与体力限制转化为背包容量，并正确处理物品（桃树）的消耗次数与价值。核心难点在于：
1. **容量转化**：总容量取时间与体力-1的较小值（体力不能归零）
2. **物品消耗**：计算曼哈顿距离的2倍（往返路径）
3. **优化处理**：二进制拆分优化多重背包以提升效率

### 高分题解推荐

#### 1. Diamiko（★★★★★）
**关键亮点**：
- 详尽的变量含义与问题转化分析
- 清晰的二进制优化模板实现
- 正确处理无效物品（价值/次数为0的桃树）

**核心代码**：
```cpp
void MultiPack(int cost,int value,int amount) {
    if(Bag <= cost*amount) { // 完全背包情况
        CompletePack(cost,value);
        return;
    }
    for(int k=1; k<amount; k<<=1) { // 二进制拆分
        ZeroOnePack(cost*k, value*k);
        amount -= k;
    }
    ZeroOnePack(cost*amount, value*amount);
}
```
**实现思想**：将物品按二进制拆分（1,2,4...），转化为01背包问题，时间复杂度从O(N*M*K)优化至O(N*M*logK)。

#### 2. Strong_Jelly（★★★★☆）
**关键亮点**：
- 简洁的预处理逻辑
- 二进制优化与无效物品过滤
- 代码注释清晰易懂

**代码亮点**：
```cpp
for(int k=1; k<=z; k*=2) { // 二进制拆分
    c[++n] = x * k;
    w[n] = y * k;
    z -= k;
}
if(z) c[++n] = x*z, w[n]=y*z;
```

#### 3. Twilight_（★★★★☆）
**关键亮点**：
- 直观的拆分实现
- 特殊处理最后一次拆分余数
- 代码结构简洁

**个人心得**：
> "重要重要重要！别忘记处理拆分余数" —— 提醒二进制拆分时必须处理剩余次数

---

### 最优思路总结
1. **容量合并**：将二维约束（时间+体力）转化为一维取min值
2. **路径计算**：曼哈顿距离（x+y）*2的往返消耗
3. **二进制优化**：将K次物品拆分为logK个物品，显著降低复杂度
4. **无效过滤**：提前排除可摘次数为0或桃子数为0的桃树

### 拓展训练推荐
1. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776) - 多重背包模板题
2. [P1833 樱花](https://www.luogu.com.cn/problem/P1833) - 时间混合型背包
3. [P1855 榨取kkksc03](https://www.luogu.com.cn/problem/P1855) - 二维费用背包

### 关键调试经验
1. **体力边界**：多位作者强调体力需-1，如Star_Wind的注释："体力和时间中任何一样用完了就会挂掉"
2. **拆分余数**：Twilight_通过注释强调处理最后剩余次数的重要性
3. **坐标转换**：Diamiko指出坐标原点为(1,1)但距离计算基于(0,0)的易错点

---

通过上述优化与思路，可高效解决此类时空双重约束的多重背包问题，适用于各类资源受限的采集/装载场景。

---
处理用时：45.51秒
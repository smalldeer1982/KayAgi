# 题目信息

# 猴子上树

## 题目描述

在猴村有一条笔直的山路，这条山路很窄，宽度忽略不计。有 $n$ 只猴子正站在山路上静静地观望今天来参加比赛的各位同学。用一个正整数 $X_i$ 表示第 $i$ 只猴子所站位置，任意两只猴子的所站位置互不相同。在这条山路的 $m$ 个位置上种着一些高大的树木，正整数 $Y_j$ 表示第 $j$ 棵树木所在的位置，任意两棵树的位置互不相同。

正当猴子们聚精会神的欣赏各位高超编程技能 聚精会神的欣赏各位高超编程技能时，一只老虎大摇摆的走了过来。猴子们吓得直冒冷汗，第一反应就是找棵大树爬上去这样能避免被老虎咬死或者吃掉（不考虑老虎上树问题）。

在位置 $a$ 的猴子跑到在位置 $b$ 的大树上，需要消耗能量为 $|a-b|$（即 $a-b$ 的绝对值）。为了尽可能有效利用这些大树避难，每棵上至少要一只猴子。
请编程计算 $n$ 只猴子全部上树最少需要消耗多少能量？


## 说明/提示

$30%$ 的数据，$1\le n \le 500$，$1≤X_i,Y_i≤10^5$。

$100%$ 的数据，$1≤n≤5000$，$1≤m≤n$，$1≤Xi,Yi≤10^9$。


## 样例 #1

### 输入

```
3
1 4 5
2
3 8
```

### 输出

```
6
```

## 样例 #2

### 输入

```
3
3 1 10
2
8 3
```

### 输出

```
4
```

# AI分析结果



### 综合分析与结论
该题目要求猴子全部上树且每棵树至少一只，核心解法为动态规划。所有题解均采用排序后动态规划的思路，关键点在于状态转移方程设计及空间优化。最优解法通过一维滚动数组倒序处理，高效解决了空间问题，并正确处理边界条件。

---

### 精选题解与评分

#### 1. Exber（★★★★★）
**关键亮点**：  
- 使用一维滚动数组倒序处理，极大节省空间（仅需一维数组）  
- 显式处理 j=1 和 i==j 的特殊情况，确保正确性  
- 代码简洁高效，时间复杂度 O(nm)，空间复杂度 O(m)  

**核心代码**：  
```cpp
for(int i=1;i<=n;i++) {
    for(int j=m;j>=1;j--) { // 倒序枚举防止覆盖
        if(j==1) dp[j] += abs(a[i]-b[j]);
        else if(i==j) dp[j] = dp[j-1] + abs(a[i]-b[j]);
        else dp[j] = min(dp[j], dp[j-1]) + abs(a[i]-b[j]);
    }
}
```

#### 2. wasa855（★★★★）
**关键亮点**：  
- 二维滚动数组（奇偶优化）直观易理解  
- 显式处理 j=1 和 i==j 的边界条件  
- 代码逻辑清晰，适合动态规划初学者  

**核心代码**：  
```cpp
for(int i=2;i<=n;i++) {
    for(int j=1;j<=m;j++) {
        if(j==1) f[i%2][1] = f[(i-1)%2][1] + abs(mon[i]-tree[j]);
        else if(i==j) f[i%2][j] = f[(i-1)%2][j-1] + abs(mon[i]-tree[j]);
        else f[i%2][j] = min(f[(i-1)%2][j], f[(i-1)%2][j-1]) + ...;
    }
}
```

#### 3. vgccyaj（★★★★）
**关键亮点**：  
- 代码极简，利用初始值 INF 隐式处理边界  
- 正确性依赖动态规划自动筛选合法状态  
- 适合对滚动数组熟悉的读者  

**核心代码**：  
```cpp
memset(f, 0x7f, sizeof(f));
f[1][1] = abs(x[1]-y[1]);
for(int i=2;i<=n;i++) {
    for(int j=1;j<=m;j++) {
        f[i&1][j] = min(f[(i-1)&1][j], f[(i-1)&1][j-1]) + ...;
    }
}
```

---

### 关键思路与技巧
1. **排序预处理**：猴子和树的位置排序后，保证最优子结构。
2. **状态设计**：`dp[i][j]` 表示前 i 只猴子上前 j 棵树的最小消耗。
3. **滚动数组优化**：一维数组倒序处理或二维奇偶滚动，空间降为 O(m)。
4. **转移方程**：  
   `dp[j] = min(继承上一棵树，新增当前树) + 当前消耗`  
   特殊处理 j=1（只能累加）和 i==j（必须新增树）。

---

### 拓展与推荐题目
1. **同类型题**：  
   - 状态压缩动态规划（如棋盘覆盖）  
   - 背包问题中的滚动数组优化  

2. **推荐题目**：  
   - 洛谷 P1541 [乌龟棋](https://www.luogu.com.cn/problem/P1541)（多维DP+滚动数组）  
   - 洛谷 P1064 [金明的预算方案](https://www.luogu.com.cn/problem/P1064)（分组背包优化）  
   - 洛谷 P1156 [垃圾陷阱](https://www.luogu.com.cn/problem/P1156)（时间轴+滚动数组）

---
处理用时：234.20秒
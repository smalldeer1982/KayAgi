# 题目信息

# [USACO06DEC] Cow Roller Coaster S

## 题目描述

有 $n$ 条线段，每条线段只能放在数轴上的一个特定位置，并且第 $i$ 根线段有如下几个属性：$X_i$（该线段放在数轴上的起点），$W_i$（该线段长度），$F_i$（你若使用该线段你能获得的价值），$C_i$（你若使用该线段你所需要的费用）。现在让你从中选出一些线段，使得这些线段能够铺满数轴上的区间 $[0,L]$ 且线段必须首尾相接（也就是不能重叠，也不能空缺），并且所花费用和不超过 $B$，同时要使你收获的价值尽量大，请你找到这个方案。

## 样例 #1

### 输入

```
5 6 10
0 2 20 6
2 3 5 6
0 1 2 1
1 1 1 3
1 2 5 4
3 2 10 2```

### 输出

```
17```

# AI分析结果



### 综合分析与结论
本题核心是二维背包问题，状态设计为`f[i][j]`表示覆盖区间`[0,i]`且花费`j`时的最大价值。关键难点在于保证线段首尾相接的连续性，通过预处理排序或终点索引优化转移顺序。最优解普遍采用动态规划，时间复杂度为O(nB)，其中n为线段数，B为预算。

### 精选题解推荐
#### 1. 糪眾脦颰罷（★★★★★）
**关键亮点**  
- 清晰定义`f[i][j]`状态，用`-1`表示非法状态  
- 按线段起点排序保证DP顺序正确性  
- 代码简洁高效（104ms/5.4MB）

**核心代码**  
```cpp
sort(p+1,p+1+n,cmp);
f[0][0] = 0;
for(int i=1; i<=n; i++)
    for(int j=0; j<=b-p[i].v; j++)
        if(f[p[i].st][j] != -1)
            f[p[i].ed][j+p[i].v] = max(f[p[i].ed][j+p[i].v], f[p[i].st][j]+p[i].f);
```

#### 2. 2017gangbazi（★★★★☆）
**关键亮点**  
- 用`vector[i]`存储终点为i的线段，避免全量排序  
- 强调必须从起点连续覆盖的判断逻辑  
- 引入`!f[i-len][j-cost]`验证前驱状态有效性  

**核心代码**  
```cpp
vector<int> t[maxn];
for(int i=0; i<=l; i++)
    for(int j=0; j<=b; j++)
        for(int k=0; k<t[i].size(); k++)
            if(i-len[r]>=0 && j-c[r]>=0 && !f[i-len[r]][j-c[r]])
                f[i][j] = max(f[i][j], f[i-len[r]][j-c[r]] + h[r]);
```

#### 3. 沉辰（★★★★☆）
**关键亮点**  
- 显式初始化`f[0][0]=0`确保起点合法  
- 通过`max(f[l][i])`遍历所有可能预算  
- 代码结构工整易读，含详细注释  

**个人心得**  
> "初始化`f[0][0]=0`至关重要，否则无法保证从起点开始连续覆盖。遍历最终状态时要考虑所有预算情况。"

### 最优思路与技巧总结
1. **状态设计**：二维DP `f[位置][费用]`，用`-1`标记非法状态  
2. **转移条件**：只从合法前驱状态（`f[xi][j]≠-1`）转移，保证连续性  
3. **预处理优化**：按线段起点排序或建立终点索引，减少无效遍历  
4. **空间优化**：逆序枚举预算维度，避免状态覆盖问题  

### 同类题目推荐
1. P1507 NASA的食物计划（二维背包模板题）  
2. P2851 [USACO06DEC]最少的硬币（多维约束背包）  
3. P1941 [NOIP2014]飞扬的小鸟（复合状态动态规划）  

### 调试经验与技巧
1. **初始化陷阱**：必须显式设置`f[0][0]=0`，其他设为`-1`  
2. **连续性验证**：转移前必须检查前驱状态是否可达  
3. **排序必要性**：无序线段可能导致提前覆盖合法状态  
4. **输出处理**：最终结果需遍历`f[L][0..B]`取最大值，而非直接取`f[L][B]`  

---

**核心代码片段（糪眾脦颰罷）**  
```cpp
// 状态转移核心逻辑
for(int i=1; i<=n; i++) {
    for(int j=0; j<=b-p[i].v; j++) {
        if(f[p[i].st][j] != -1) { // 关键合法性检查
            int new_pos = p[i].st + p[i].w;
            int new_cost = j + p[i].v;
            f[new_pos][new_cost] = max(f[new_pos][new_cost], 
                                      f[p[i].st][j] + p[i].f);
        }
    }
}
```

---
处理用时：68.93秒
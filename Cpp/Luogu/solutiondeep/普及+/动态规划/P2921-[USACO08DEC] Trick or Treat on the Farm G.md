# 题目信息

# [USACO08DEC] Trick or Treat on the Farm G

## 题目描述

每年，在威斯康星州，奶牛们都会穿上衣服，收集农夫约翰在 $N(1\le N\le 100,000)$ 个牛棚隔间中留下的糖果，以此来庆祝美国秋天的万圣节。

由于牛棚不太大，FJ 通过指定奶牛必须遵循的穿越路线来确保奶牛的乐趣。为了实现这个让奶牛在牛棚里来回穿梭的方案，FJ 在第 $i$ 号隔间上张贴了一个 “下一个隔间：$next_i(1\le next_i\le N)$” 的标语，告诉奶牛要去的下一个隔间。这样，为了收集它们的糖果，奶牛就会在牛棚里来回穿梭了。

FJ 命令奶牛 $i$ 应该从 $i$ 号隔间开始收集糖果。如果一只奶牛回到某一个她已经去过的隔间，她就会停止收集糖果。

在被迫停止收集糖果之前，计算一下每头奶牛要前往的隔间数（包含起点）。

## 样例 #1

### 输入

```
4 
1 
3 
2 
3 
```

### 输出

```
1 
2 
2 
3 
```

# AI分析结果



### 综合分析与结论
该题的图结构为基环树森林，核心难点在于快速检测环并计算链节点到环的距离。题解主要分为三类：非递归模拟遍历（高效但实现复杂）、Tarjan缩点（通用但代码量大）、记忆化搜索/拓扑排序（直观但需处理状态）。

最优解法均利用出度唯一的特性，通过路径追踪与状态标记实现线性时间复杂度。关键技巧包括环检测时的双标记法、拓扑排序预处理链节点、反向DFS更新答案等。

---

### 精选题解分析

#### 1. cjrsacred (5星)
**关键亮点**：非递归双标记法  
- 用`color`标记路径起点，`dfn`记录路径长度  
- 遇到同色节点时计算环大小，异色节点时继承环信息  
- 时间复杂度O(n)，无栈溢出风险  

```cpp
void Solve() {
    for(int cow = 1; cow <= n; ++cow) {
        for(int i = cow, cnt = 0; ; i = nxt[i], ++cnt) {
            if(!color[i]) {
                color[i] = cow;
                dfn[i] = cnt;
            } else if(color[i] == cow) { // 发现环
                minc[cow] = cnt - dfn[i];
                cout << cnt << endl;
                break;
            } else { // 遇到其他路径
                cout << sucdfn[cow] + minc[cow] << endl;
                break;
            }
        }
    }
}
```

#### 2. pantw (4星)
**关键亮点**：拓扑排序+环处理  
- 拓扑排序去除链节点，剩余节点构成环  
- 对环统一赋值，链节点通过DFS回溯更新  
- 代码简洁，复杂度O(n)

```cpp
void del(int cur) { // 拓扑去链
    vis[cur] = true;
    in[next[cur]]--;
    if(!in[next[cur]]) del(next[cur]);
}

int calc(int cur) { // 计算链节点
    if(ans[cur]) return ans[cur];
    return ans[cur] = calc(next[cur]) + 1;
}
```

#### 3. xiejinhao (4星)
**关键亮点**：并查集路径回溯  
- 通过并查集合并时记录父节点  
- 遇到环时通过父节点回溯计算环长  
- 链节点通过父节点链式更新

```cpp
void Find(int p,int q) { // 并查集找环
    if(Get(p)==Get(q)) {
        int cnt=1;
        for(int i=p; i!=q; i=fa[i]) cnt++;
        for(int i=p; i!=q; i=fa[i]) E[i]=cnt;
        E[q] = cnt;
    }
    // 合并集合并记录父节点
}
```

---

### 关键思路总结
1. **双标记环检测**：通过颜色标记路径来源，时间戳计算环长，避免递归栈
2. **拓扑去链**：通过入度剪枝，分离链与环结构
3. **反向DFS**：从环节点反向更新链节点答案，避免重复计算
4. **父节点回溯**：利用并查集记录路径，回溯时统计环长

---

### 拓展练习
1. [P2661 信息传递](https://www.luogu.com.cn/problem/P2661) - 基环树最小环  
2. [P3387 缩点](https://www.luogu.com.cn/problem/P3387) - Tarjan缩点经典题  
3. [P2607 骑士](https://www.luogu.com.cn/problem/P2607) - 基环树DP应用

---

### 调试心得摘录
> "手动维护栈时要注意清空状态，否则会污染后续计算"（cjrsacred）  
> "Tarjan缩点后重构图时要注意自环的特判"（Lemon_）  
> "并查集路径压缩会破坏父节点关系，需单独维护父节点数组"（xiejinhao）  

总结：处理基环树需特别注意状态重置和自环情况，父子关系维护要谨慎。

---
处理用时：65.01秒
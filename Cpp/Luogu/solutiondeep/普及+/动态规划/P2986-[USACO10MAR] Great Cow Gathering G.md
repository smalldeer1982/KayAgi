# 题目信息

# [USACO10MAR] Great Cow Gathering G

## 题目描述

Bessie 正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会。

每个奶牛居住在 $N$ 个农场中的一个，这些农场由 $N-1$ 条道路连接，并且从任意一个农场都能够到达另外一个农场。道路 $i$ 连接农场 $A_i$ 和 $B_i$，长度为 $L_i$。集会可以在 $N$ 个农场中的任意一个举行。另外，每个牛棚中居住着 $C_i$ 只奶牛。

在选择集会的地点的时候，Bessie 希望最大化方便的程度（也就是最小化不方便程度）。比如选择第 $X$ 个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和（比如，农场 $i$ 到达农场 $X$ 的距离是 $20$，那么总路程就是 $C_i\times 20$）。帮助 Bessie 找出最方便的地点来举行大集会。

## 说明/提示

$1\leq N\leq 10^5$，$1\leq A_i\leq B_i\leq N$，$0 \leq C_i,L_i \leq 10^3$。

## 样例 #1

### 输入

```
5 
1 
1 
0 
0 
2 
1 3 1 
2 3 2 
3 4 3 
4 5 3 
```

### 输出

```
15 
```

# AI分析结果



### 综合分析与结论
本题核心是树形结构上的动态规划问题，主要解法可分为两类：①两次DFS的树形DP法（利用子树信息递推）②树的重心变形法（将牛的数量视为权重）。其中两次DFS法更为主流，通过一次预处理子树信息，再利用转移方程O(1)推导相邻节点的答案，最终达到O(n)复杂度。

---

### 精选题解推荐

#### 1. 题解作者：yybyyb (⭐⭐⭐⭐⭐)
**关键亮点**  
- 清晰的两次DFS框架设计，注释详细易懂  
- 引入子树牛数统计(Q数组)和转移公式推导  
- 代码结构简洁，变量命名规范（dis、Sum等）

**核心思路**  
1. 第一次DFS计算以1号节点为根的子树信息  
2. 第二次DFS利用转移公式：  
   `f[v] = f[u] - Q[v]*w + (Sum-Q[v])*w`  
   通过父节点u的值推导子节点v的值

**核心代码**  
```cpp
void DFS2(ll u, ll ff) {
    for(int i = head[u]; i; i = e[i].next) {
        ll v = e[i].to, w = e[i].w;
        if(v != ff) {
            f[v] = f[u] - Q[v]*w + (Sum - Q[v])*w;
            DFS2(v, u);
        }
    }
}
```

#### 2. 题解作者：Magi_karp (⭐⭐⭐⭐)
**关键亮点**  
- 创新性使用带权树重心思想  
- 通过拆解牛数为多个虚拟节点  
- 提供树重心性质的理论推导

**核心思路**  
1. 将每个牛群视为多个虚拟节点  
2. 计算带权树重心，满足最大子树权重最小  
3. 最终重心即为最优集会点

**关键代码**  
```cpp
void treedp(int fa, int u) {
    s[u] = c[u]; // s[u]为带权子树大小
    for(int i = head[u]; i; i = a[i].ne) {
        int v = a[i].to;
        if(v == fa) continue;
        treedp(u, v);
        s[u] += s[v];
        maxs[u] = max(maxs[u], s[v]);
    }
    maxs[u] = max(maxs[u], sum - s[u]); // 检查父节点方向
}
```

#### 3. 题解作者：James_Brady (⭐⭐⭐⭐)
**关键亮点**  
- 分治思想处理子树内外贡献  
- 清晰的状态转移方程推导  
- 同时维护dp1（子树内）和dp2（子树外）

**核心公式**  
```cpp
dp[v] = dp[u] - size[v]*w + (total_size - size[v])*w
```

---

### 关键技巧总结
1. **两次DFS框架**：  
   - 第一次DFS预处理子树信息（子树牛数、初始答案）  
   - 第二次DFS利用父子关系递推，通过差值计算优化时间复杂度

2. **权重转移公式**：  
   当从节点u转移到子节点v时：  
   `新答案 = 父答案 - 子树v贡献 + 非子树v贡献`

3. **树的重心变形**：  
   将牛的数量视为节点权重，求最大子树权重最小的点

4. **数据范围陷阱**：  
   注意总和可能超过int范围（多个题解提到需使用long long）

---

### 同类题目推荐
1. **P1364 医院设置** - 树形结构最小距离和（基础版）  
2. **P3478 [POI2008] STA-Station** - 求树中深度和最大的节点  
3. **P3047 [USACO12FEB]Nearby Cows G** - 树形DP与子树信息统计

---
处理用时：58.96秒
# 题目信息

# [HAOI2009] 毛毛虫

## 题目背景

感谢由@ScanfN 提供的两组 hack 数据。

## 题目描述

对于一棵树，我们可以将某条链和与该链相连的边抽出来，看上去就象成一个毛毛虫，点数越多，毛毛虫就越大。例如下图左边的树（图 $1$）抽出一部分就变成了右边的一个毛毛虫了（图 $2$）。

![](https://cdn.luogu.com.cn/upload/pic/7967.png)


## 说明/提示

对于 $40\%$ 的数据，$1\leq N \le 50000$。

对于 $100\%$ 的数据，$1\leq N \le 300000$。

## 样例 #1

### 输入

```
13 12 
1 2 
1 5 
1 6 
3 2 
4 2 
5 7 
5 8 
7 9 
7 10 
7 11 
8 12 
8 13 ```

### 输出

```
11```

# AI分析结果



### 综合分析与结论
题目本质是求树中包含最多相邻节点的链状结构。核心解法集中于树形DP与树的直径变形两种思路。最优解法需同时考虑链主体和相邻节点贡献，时间复杂度需控制在O(n)。

### 精选题解推荐

#### 1. 作者：lgswdn_SA（⭐⭐⭐⭐⭐）
**核心亮点**  
- 树形DP定义精准：f[u]表示以u为头的最大子链，配合最大次大值维护  
- 巧妙处理根节点特判  
- 图示辅助理解转移逻辑，代码简洁高效  
**关键代码**  
```cpp
void dfs(int u,int fa) {
    int mx0=0,mx1=0;
    for(int v : e[u]) if(v != fa) {
        dfs(v,u);
        if(f[v] > mx0) mx1=mx0, mx0=f[v];
        else if(f[v] > mx1) mx1=f[v];
    }
    int cnt = e[u].size() - (fa!=-1); // 扣除父节点
    f[u] = mx0 + 1 + max(0, cnt-1);  // 主链+其他分支
    ans = max(ans, mx0 + mx1 + 1 + max(0, cnt-1 - (fa==-1)));
}
```

#### 2. 作者：那一条变阻器（⭐⭐⭐⭐）
**核心亮点**  
- 创新性将问题转化为带权直径问题  
- 两次DFS实现简洁，度数处理巧妙  
**关键洞见**  
将节点权值设为度数，DFS时权值转移公式：  
`sum += dis[nx] - 2`（扣除父节点和当前节点重复计数）  

#### 3. 作者：几何之舞丶（⭐⭐⭐⭐）
**双解法亮点**  
- 解法1：val[u]维护子树最长链，配合size[u]（相邻节点数）  
- 解法2：显式维护最长次长链，直观展现合并逻辑  
**关键公式**  
`ans = max(ans, minn + maxn + size[now] - 1)`  
巧妙处理链交汇点的相邻节点计数  

### 核心思路总结
**树形DP最优实践**：  
1. 定义`f[u]`为以u为端点的最长链（包含相邻节点）  
2. 维护最大次大子链值（mx0, mx1）  
3. 答案由两种情况构成：
   - 单链延伸：`f[u]`  
   - 双链合并：`mx0 + mx1 + cnt(相邻节点数) - 重复计数`  
4. 根节点特殊处理父节点存在性  

**关键公式推导**：  
相邻节点贡献 = 当前节点度数 - 1（扣除链延伸方向）  
根节点修正 = `cnt-1 - (fa==-1)`（无父节点时无需扣除）

### 举一反三练习
1. [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)（树直径进阶）  
2. [P4381 岛屿](https://www.luogu.com.cn/problem/P4381)（基环树最长链）  
3. [P3304 直径](https://www.luogu.com.cn/problem/P3304)（必经边判定）  

### 调试经验摘录
**lgswdn_SA**：  
> "原本代码在根节点处理时忘记父节点不存在的情况，导致HACK数据出错。修改后通过`(fa==-1)`条件判断，强调边界检查的重要性"  

**RedreamMer**：  
> "将度数减1后发现链端点贡献少算，最终需+2修正。验证时对比样例发现端点计算遗漏，强调代入样例验证的必要性"

---
处理用时：66.34秒
# 题目信息

# 恋爱

## 题目描述

小 A 爱上了小 B！！！可是小 A 相对小 B 太弱，所以她当然不会同意小 A 的请求。小 A 苦苦追求，最终小 B 就提这样的条件：

- 小 B 有 $n$ 个下属（不包括小 B）组成了树状结构，小 B 在顶端，其他人都有一个直属上司。  
- 小 B 编号 $0$，其他人编号 $1 \sim n$。  
- 对于第 $i$ 人，如果这个人没有下属，那么小 A 可以给他 $A_i$ 元钱，则他会向他的直属上司写一封信，表示小 A 向小 B 求爱；  
- 如果他的直属下属有占比不小于 $\dfrac{A_i}{T}$ 的人写信表示小 A 向小 B 求爱，那么他也会向他的直属上司写一封信，表示小 A 向小 B 求爱。    
- 如果小 B 的直属下属有占比不小于 $\dfrac{C}{T}$ 的人写信表示小 A 向小 B 求爱，那么她会同意小 A 的请求。

请问小 A 至少需要给多少钱才会让小 B 同意小 A 的求爱。

## 说明/提示

对于 $20 \%$ 的数据，没有直属下属的人数 $\le 15$。  
对于 $40 \%$ 的数据，$n \le 2000$。  
另有 $10 \%$ 的数据，$B_i = 0$。
另有 $10 \%$ 的数据，$C = 1$ 且对于有直系下属的人 $T / A_i > n$。  
另有 $10 \%$ 的数据，$B_i = i - 1$。

对于 $100 \%$ 的数据，$1 \le n \le 500000$，$1 \le T \le {10}^9$，$B_i < i$，$1 \le A_i \le T$。


## 样例 #1

### 输入

```
14 5 3
0 3
0 3
1 10
1 10
2 3
2 10
2 3
5 10
7 10
5 10
7 10
5 10
7 10
5 10
```

### 输出

```
50
```

# AI分析结果



### 综合分析与结论
本题核心为树形贪心/动态规划，通过递归处理每个节点，收集子节点代价并选择最小的满足比例的子节点代价之和。各题解均采用类似思路，差异在于实现细节（如优先队列 vs 排序、上取整处理方式）。

### 高星题解推荐

#### 1. 作者：momo5440 (★★★★★)
**关键亮点**：
- 代码简洁高效，使用优先队列动态维护子节点最小代价。
- 通过浮点计算隐式处理上取整，逻辑清晰。
- 直接处理根节点0的特殊情况，代码统一性强。

**核心代码**：
```cpp
ll dfs(ll x) {
    if (bian[x].size() == 0) return a[x]; // 叶子节点
    priority_queue<ll, vector<ll>, greater<ll>> q;
    for (auto child : bian[x]) q.push(dfs(child));
    ll ans = 0, k = 1.0 * a[x] * bian[x].size() / t;
    for (int i = 0; i < k; i++) ans += q.top(), q.pop();
    return ans;
}
```
**实现思想**：递归收集子节点代价存入优先队列，取前k个最小值的和。

#### 2. 作者：xy0313 (★★★★☆)
**关键亮点**：
- 显式使用 `ceil` 处理上取整，避免浮点误差。
- 详细注释解释关键步骤，适合新手理解。
- 分离处理根节点与其他节点，逻辑明确。

**核心代码**：
```cpp
void dfs(int x) {
    priority_queue<int, vector<int>, greater<int>> que;
    for (auto child : tree[x]) {
        dfs(child);
        que.push(f[child]);
    }
    int num = ceil(1.0 * a[x] * tree[x].size() / t);
    for (int i = 0; i < num; i++) f[x] += que.top(), que.pop();
}
```
**实现思想**：显式计算上取整后的子节点数量，优先队列取最小k项。

#### 3. 作者：郑朝曦zzx (★★★★☆)
**关键亮点**：
- 使用排序替代优先队列，代码更易理解。
- 自定义上取整函数处理边界条件。
- 强调 `long long` 数据类型，避免溢出。

**核心代码**：
```cpp
ll dp(int x) {
    vector<ll> now;
    for (auto child : tree[x]) now.push_back(dp(child));
    sort(now.begin(), now.end());
    ll sum = ceil(1.0 * cost[x] * now.size() / t);
    ll ans = 0;
    for (int i = 0; i < sum; i++) ans += now[i];
    return ans;
}
```
**实现思想**：递归后排序子节点代价，取前k项求和。

### 关键思路总结
1. **递归结构**：从叶子到根逐层处理，每个节点依赖子节点结果。
2. **贪心选择**：对子节点代价排序，取最小k项保证总代价最小。
3. **上取整处理**：通过 `ceil` 或浮点隐式转换，确保满足比例要求。
4. **数据结构优化**：优先队列或排序均可实现，时间复杂度均为 O(n log n)。

### 同类型题目推荐
1. [UVA12186 工人的请愿书](https://www.luogu.com.cn/problem/UVA12186) - 几乎相同的树形贪心模型。
2. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352) - 经典树形DP，状态转移设计。
3. [P2585 三色二叉树](https://www.luogu.com.cn/problem/P2585) - 树形结构上的多状态动态规划。

---
处理用时：167.82秒
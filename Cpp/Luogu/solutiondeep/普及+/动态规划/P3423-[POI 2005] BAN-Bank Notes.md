# 题目信息

# [POI 2005] BAN-Bank Notes

## 题目描述

`Byteotian Bit Bank(BBB)` 拥有一套先进的货币系统，这个系统一共有 $n$ 种面值的硬币，面值分别为 $b_1,b_2,\cdots,b_n$。但是每种硬币有数量限制，现在我们想要凑出面值 $k$，求最少要用多少个硬币。数据保证 $k$ 可以被凑出。

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 200$，$1 \le b_1 < b_2 < \cdots < b_n \le 2 \times 10^4$，$1 \le c_i \le 2 \times 10^4$，$1 \le k \le 2 \times 10^4$。

## 样例 #1

### 输入

```
3
2 3 5
2 2 1
10```

### 输出

```
3
1 1 1```

# AI分析结果



### 综合分析与结论
本题为多重背包问题，需在硬币数量限制下求最小硬币数，并输出方案。核心难点在于优化背包复杂度（O(nk)级别）及方案记录。题解主要采用三种优化策略：单调队列优化、二进制拆分优化、贪心+完全背包思路。最优解法为单调队列优化，兼具时间与空间效率；二进制优化通过压缩转移标记节省空间；贪心策略通过排序优化转移顺序。

---

### 精选题解

#### 1. jiangby（★★★★★）
**关键亮点**  
- 使用单调队列优化多重背包，时间复杂度O(nk)最优  
- 通过二维数组d记录转移路径，回溯输出方案  
- 代码结构清晰，包含详细注释和调试心得  
**核心代码**  
```cpp
for(int i=1;i<=n;i++){ // 单调队列优化部分
    for(int j=0;j<w[i];j++){
        head1=head2=1; tail1=tail2=0;
        for(int k=j,cnt=0;k<=m;cnt++,k+=w[i]){
            while(head1<=tail1 && k-q1[head1].y > c[i]*w[i]) head1++;
            int t = f[k] - cnt;
            q1[++tail1] = {t,k}; // 维护单调队列
            f[k] = q2[head2].x + cnt; // 更新最优解
            d[i][k] = q2[head2].y;   // 记录转移前驱
        }
    }
}
```

#### 2. namespace_std（★★★★☆）
**关键亮点**  
- 二进制拆分降低物品数量，布尔数组压缩转移标记  
- 倒序回溯方案时通过标记快速定位有效物品  
- 空间优化到O(3e4×2e4)，实测仅19MB  
**核心代码**  
```cpp
for(int i=1;i<=tot;i++){ // 二进制拆分后DP
    for(int j=m;j>=b[i].w;j--){
        if(dp[j-b[i].w]+b[i].v < dp[j]){
            from[i][j] = 1; // 标记转移发生
            dp[j] = dp[j-b[i].w] + b[i].v;
        }
    }
}
while(temp){ // 回溯方案
    while(!from[ji][temp] && ji) ji--;
    hole[bef[ji]] += v[ji]; // 累加硬币数量
    temp -= w[ji--];
}
```

#### 3. __lyh__（★★★★☆）
**关键亮点**  
- 贪心思路按面值降序处理，优先使用大面额硬币  
- 完全背包式转移，结合d数组实时检查数量限制  
- 时间复杂度O(nk)，代码简洁易实现  
**核心代码**  
```cpp
sort(a+1,a+n+1,cmp); // 按面值降序排序
for(int i=1;i<=n;i++){ 
    memset(d,0,sizeof(d)); // 重置数量计数器
    for(int j=a[i].b;j<=m;j++){ // 完全背包式转移
        if(d[j-a[i].b] < a[i].c && f[j] > f[j-a[i].b]+1){
            d[j] = d[j-a[i].b] + 1; // 更新当前硬币使用数
            pre[j] = a[i].b;        // 记录前驱面值
        }
    }
}
```

---

### 关键思路与技巧
1. **单调队列优化**：将多重背包转化为滑动窗口最值问题，时间复杂度从O(nkΣc_i)降为O(nk)。
2. **二进制拆分优化**：将物品数量按二进制分解为独立物品，转为01背包问题，配合布尔数组压缩转移标记。
3. **贪心+动态规划**：按面值降序处理硬币，优先使用大面额硬币，结合计数器确保不超限。

---

### 同类题目推荐
1. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)（多重背包模板题）  
2. [P6567 买表](https://www.luogu.com.cn/problem/P6567)（需处理多组询问的背包方案）  
3. [P1759 通天之潜水](https://www.luogu.com.cn/problem/P1759)（二维费用背包+路径记录）

---
处理用时：66.48秒
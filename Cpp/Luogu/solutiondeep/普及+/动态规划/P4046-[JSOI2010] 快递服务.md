# 题目信息

# [JSOI2010] 快递服务

## 题目描述

「飞奔」快递公司成立之后，已经分别与市内许多中小企业公司签订邮件收送服务契约。由于有些公司是在同一栋大楼内，所以「飞奔」公司收件的地点（收件点）最多只有 $m$ 点（$1,2,\dots,m$），因此「飞奔」仅先行采购了三辆货车并聘用了三名司机，每天早上分别从收件地点 $1,2,3$ 出发。而在与客户的服务契约中有明确订约：「飞奔」必须在客户提出邮件寄送要求的隔天派人至该公司（地点）收件。

为了能更有效率的服务客户并节省收件时间，该公司设立了收件服务登记网站，客户如有邮件需要寄送，必须在需要收件的前一天就先上网登记。为了节省油量，「飞奔」就利用晚上先行安排三位司机隔天的收件路线。每位司机至各地点收件的顺序应与各公司上网登记的顺序相符且必须能在最省油的情况下完成当天所有的收件服务。因此每位司机有可能需要在不同时间重复到同一地点收件，或不同的司机有可能需在不同的时间点前往同一地点收件。

如下面范例二（收件公司地点依序为：`4 2 4 1 5 4 3 2 1`）所示，虽然司机 $1$ 一开始就已经在收件地点 $1$ 了，但是他却不能先把后面第四个登记的公司（地点 $1$）邮件先收了再前往第一、第二、或第三个登记收件地点（地点 $4,2,4$）收件。但是如果前三个登记收件的服务是由司机 $2$ 或 $3$ 来负责，则司机 $1$ 就可以在地点 $1$ 收了第四个登记的邮件后再前往后面所登记的地点收件。此外，在某些情况下，不一定每辆车都要收到货，也就是说，最佳收件方式也有可能是只需出动一或两辆车去收货。请写一个程序来帮「飞奔」公司计算每天依预约顺序至各收件地点收件的最少总耗油量。

### 简要题意

给定一个 $m \times m$ 的矩阵 $D$。我们规定一个序列 $a(a_0,a_1,a_2,\dots,a_n)$ 的花费为 $\sum\limits_{i=1}^{n}D_{a_{i-1},a_i}$。

现在给定你一个长度 $\leq 1000$ 的序列 $s$，请你把它分成三个子序列 $a,b,c$，并且规定 $a_0=1,b_0=2,c_0=3$，求出所有划分方案中它们的最小化费和。

特殊地，矩阵 $D$ 满足三角不等式，具体见输入格式中的详细解释。

（By El_destructor）

## 说明/提示

#### 样例解释

到每个请求收件地点的司机分别为 `1 1 1 1 3 3 2 2 2 1`，因此司机 $1$ 只需从起使点 $1$ 移动到地点 $3$，司机 $2$ 只需停留在地点 $2$，司机 $3$ 从起始点 $3$ 移动到地点 $4$。

#### 数据范围

$3 \leq m \leq 200,1 \leq s_i \leq m$。

## 样例 #1

### 输入

```
4 
0 5 0 6 
6 0 5 6 
1 6 0 6 
1 1 1 0 
1 1 1 1 4 4 2 2 2 3 ```

### 输出

```
6```

# AI分析结果



### 综合分析与结论
本题需在按顺序处理请求的条件下，寻找三个司机的最优路径。各题解核心思路均为动态规划，关键优化在于利用「处理第i个请求时必有一人在第i-1个请求位置」的特性，将状态维度从三维（三人位置）降为二维（两人位置+隐含第三人位置），结合滚动数组优化空间至O(m²)。所有解法均基于此核心思想，差异主要体现在代码实现细节与优化技巧。

---

### 精选题解与评分

#### 1. 作者：Iscream2001（★★★★★）
**关键亮点**  
- 思路清晰，状态设计简洁：`f[i][j]`表示两人位置，第三人隐含在上一个任务点  
- 使用滚动数组优化空间，代码简洁高效  
- 正确初始化处理（`p[0]=3`对应初始三人位置）

**核心代码思路**  
```cpp
for(int k=1;k<=m;++k){
    // 滚动数组清空
    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) t[i][j]=inf;
    
    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j){
        // 三个转移方向：隐含的第三人移动 / i移动 / j移动
        t[i][j] = min(t[i][j], f[i][j] + mp[p[k-1]][p[k]]);
        t[p[k-1]][j] = min(t[p[k-1]][j], f[i][j] + mp[i][p[k]]);
        t[i][p[k-1]] = min(t[i][p[k-1]], f[i][j] + mp[j][p[k]]);
    }
    swap(f, t); // 滚动数组切换
}
```

#### 2. 作者：BzhH（★★★★☆）
**关键亮点**  
- 明确与SP703的双倍经验，扩展同类题思路  
- 使用`f[i&1]`实现滚动数组，代码可读性较好  
- 状态转移方程书写规范，便于理解  

**个人心得**  
> "状态转移方程书写时考虑三个方向：当前请求位置的人去、x位置的人去、y位置的人去"

#### 3. 作者：VioletIsMyLove（★★★★☆）
**关键亮点**  
- 代码中显式处理无效状态（`x==y||x==z||y==z`）  
- 使用`memset`快速初始化滚动数组  
- 变量命名清晰（`a[]`表示请求序列）

---

### 最优关键思路与技巧
1. **状态压缩**：利用「必有一人在前序位置」的特性，将状态设计为`f[i][x][y]`，隐含第三人位置为`p[i-1]`  
2. **滚动数组**：通过交替使用两个二维数组，将空间复杂度从O(m²n)优化至O(m²)  
3. **三角转移**：每次转移考虑三种可能（隐含第三人移动/另两人中的一个移动）  
4. **无效状态剪枝**：跳过`x==y`等非法状态，减少无效计算  

---

### 同类题目推荐
1. **SP703 SERVICE - Mobile Service**（双倍经验，同类型三维状态优化）  
2. **洛谷P1541 乌龟棋**（多维状态DP+滚动数组）  
3. **洛谷P1006 传纸条**（双路径DP，状态设计思想类似）

---

### 个人心得摘录
1. **Iscream2001**：  
   > "发现完成第x个任务时，三人中至少有一个在p[x]上，数组只用开两维"  
   → 核心优化思想的直觉来源  

2. **Jμdge**：  
   > "头一回听到空间卡时间的"  
   → 强调滚动数组在减少缓存未命中时的作用  

3. **Utsuji_risshū**：  
   > "枚举j和k时只枚举j<k，枚举数量少一半"  
   → 利用对称性优化常数，实际效率提升显著

---
处理用时：61.10秒
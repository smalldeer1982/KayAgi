# 题目信息

# 玉蟾宫

## 题目背景

有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。


## 题目描述

这片土地被分成 $N\times M$ 个格子，每个格子里写着 'R' 或者 'F'，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。

现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 'F' 并且面积最大。

但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为 $S$，它们每人给你 $S$ 两银子。


## 说明/提示

对于 $50\%$ 的数据，$1 \leq N, M \leq 200$。  
对于 $100\%$ 的数据，$1 \leq N, M \leq 1000$。

## 样例 #1

### 输入

```
5 6 
R F F F F F 
F F F F F F 
R R R F F F 
F F F F F F 
F F F F F F```

### 输出

```
45```

# AI分析结果



### 综合分析与结论
本题目核心是寻找最大全'F'子矩阵，各题解主要采用单调栈、悬线法、并查集、暴力优化等算法。最优解法为悬线法（O(nm)时间）和单调栈（O(nm)时间），均能通过1e3数据规模。其他方法如暴力优化、笛卡尔树等或存在时间复杂度偏高、代码复杂度较高等问题。

---

### 高分题解精选（≥4星）

#### 1. 假假（单调栈） ★★★★☆
**核心亮点**  
- 清晰描述按行预处理高度数组，结合单调栈横向扩展的思路  
- 给出完整的栈操作逻辑和面积更新策略  
- 代码结构清晰，变量命名规范，可读性较强  
**关键代码**  
```cpp
void calc(int x){
    int top=1,temp=0;
    stack[1] = {pos[x][1],1};
    for(int i=2;i<=m;++i){
        temp=0;
        while(stack[top].height>=pos[x][i] && top>0){
            temp += stack[top].length;
            maxs = max(maxs, stack[top--].height * temp);
        }
        stack[++top] = {pos[x][i], temp+1};
    }
    // 弹栈剩余元素更新面积
}
```

#### 2. XG_Zepto（悬线法） ★★★★
**核心亮点**  
- 结合图示直观解释悬线法的核心思想  
- 给出预处理left/right数组的巧妙实现  
- 代码中通过min/max压缩范围的操作清晰体现悬线扩展  
**关键实现**  
```cpp
for(int i=1;i<=n;++i){
    int t=0;
    for(int j=1;j<=m;++j){ // 左边界预处理
        if(a[i][j]) l[i][j]=t;
        else L[i][j]=0, t=j;
    }
    t=m+1;
    for(int j=m;j>=1;--j){ // 右边界预处理
        if(a[i][j]) r[i][j]=t;
        else R[i][j]=m+1, t=j;
    }
}
```

#### 3. kradcigam（并查集） ★★★★
**创新思路**  
- 按高度排序后通过并查集合并相邻列  
- 动态维护横向扩展范围，时间复杂度O(nm logm)  
- 适合理解并查集特性的进阶学习  
**代码片段**  
```cpp
priority_queue<emm,cmp> q;
void con(int x,int y){
    int u=fifa(x), v=fifa(y);
    fa[v]=u; siz[u]+=siz[v]; // 合并并更新宽度
}
while(!q.empty()){
    int i=q.top().nod; 
    if(sf[i-1]) con(i-1,i); // 向左合并
    if(sf[i+1]) con(i,i+1); // 向右合并
    ans=max(ans, siz[fi]*x); // 计算面积
}
```

---

### 关键思路总结
1. **高度数组预处理**：计算每个位置向上连续的'F'个数，作为矩形高度  
2. **横向扩展策略**：  
   - 单调栈：维护递增栈，快速确定左右第一个小于当前高度的位置  
   - 悬线法：通过`left[i][j] = max(left[i][j], left[i-1][j])`动态压缩边界  
3. **空间优化技巧**：滚动数组（如溜肾污主xyt的代码）可将空间降至O(m)

---

### 同类题目推荐
1. [P2559 [AHOI2006] 最大矩形](https://www.luogu.com.cn/problem/P2559)（单调栈模板）  
2. [P4147 玉蟾宫（本题）](https://www.luogu.com.cn/problem/P4147)（悬线法实践）  
3. [P1950 长方形](https://www.luogu.com.cn/problem/P1950)（二维前缀和+单调栈变式）

---

### 调试经验摘录
1. **边界处理**：  
   - "在弹栈后需要处理剩余元素，否则会漏算最后一个递增区间的面积"（假假题解注释）  
   - "初始化时给right[0][i]赋值为m+1，避免首行特殊判断"（XG_Zepto代码）  
2. **输入陷阱**：  
   - "读入字符时要跳过换行符，用`while(c!='R'&&c!='F')c=getchar()`确保正确性"（lemonfor题解）  
3. **思维误区**：  
   - "最大矩形的高度可能由非当前行决定，需结合历史高度信息"（huiwang17的悬线法图示说明）

---
处理用时：53.01秒
# 题目信息

# [USACO18FEB] Snow Boots S

## 题目描述

农场的冬天到了，这意味着下雪了！从农舍到谷仓的路上有 $N$ 块地砖，方便地编号为 $1 \dots N$，第 $i$ 块地砖上覆盖了 $f_i$ 英尺的雪。

Farmer John 从第 $1$ 块地砖出发，必须到达第 $N$ 块地砖去叫醒奶牛。第 $1$ 块地砖被农舍的屋顶遮蔽，第 $N$ 块地砖被谷仓的屋顶遮蔽，因此这两块地砖上没有雪。但要踩在其他地砖上，Farmer John 需要穿靴子！

在他的恶劣天气背包中，Farmer John 有 $B$ 双靴子，编号为 $1 \dots B$。有些靴子比其他靴子更耐用，有些靴子比其他靴子更灵活。具体来说，第 $i$ 双靴子允许 Farmer John 在最多 $s_i$ 英尺深的雪中行走，并且每步最多可以移动 $d_i$ 块地砖。

不幸的是，靴子的打包方式使得 Farmer John 在任何时候只能访问最上面的一双靴子。因此，Farmer John 可以随时穿上最上面的一双靴子（丢弃旧靴子）或丢弃最上面的一双靴子（使下一双靴子可访问）。

Farmer John 只能在地砖上更换靴子。如果该地砖上有 $f$ 英尺的雪，那么他脱下的靴子和穿上的靴子都必须能够承受至少 $f$ 英尺的雪。他丢弃但未穿过的中间靴子不需要满足此限制。

请帮助 Farmer John 最小化浪费，确定他到达谷仓需要丢弃的最少靴子对数。假设 Farmer John 最初没有穿任何靴子。

## 说明/提示

题目来源：Brian Dean 和 Dhruv Rohatgi

## 样例 #1

### 输入

```
10 4
0 2 8 3 6 7 5 1 4 0
2 3
4 2
3 4
7 1```

### 输出

```
2
```

# AI分析结果



### 综合分析与结论
本题需要通过动态规划或记忆化搜索处理状态转移，核心在于正确设计状态，考虑靴子承受能力与步长限制。各题解主要采用二维DP或DFS+记忆化，部分通过滑动窗口优化时间复杂度至O(n²)。

### 精选题解（评分≥4星）

#### 1. 忘怀星（5星）
**关键亮点**：创新性滑动窗口优化，O(n²)时间复杂度，显著降低复杂度。
**核心思路**：维护当前靴子可达的窗口范围，用一维数组记录到达每个位置的最小靴子编号。通过滑动窗口快速判断可达性，避免冗余枚举。
```cpp
// 核心代码片段
for(int i = 1;i <= b;i ++) {
    int s = read(),d = read();
    for(int j = 1,p = 1,tmp=0;j <= n;j ++) {
        while(j-p > d) { // 维护窗口大小
            if(dp[p] && f[p] <= s) tmp--;
            p++;
        }
        if(tmp && !dp[j] && f[j] <= s) dp[j] = i;
        if(dp[j] && f[j] <= s) tmp++;
    }
    if(dp[n]) { printf("%d",dp[n]-1); return 0; }
}
```

#### 2. communist（4星）
**关键亮点**：二维DP状态清晰，直观体现位置与靴子的关系。
**核心思路**：定义`dp[i][j]`表示使用第j双靴子到达位置i的可能性，通过三重循环枚举转移。
```cpp
// 核心代码片段
for(int i=1;i<=n;i++)
    for(int j=1;j<=b;j++)
        if(dp[i][j])
            for(int k=j;k<=b;k++) // 可换到更后的靴子
                if(f[i]<=s[k])
                    for(int l=i+1; l<=min(n,i+d[k]); l++)
                        if(f[l]<=s[k]) dp[l][k] = 1;
```

#### 3. Zenith_Yeh（4星）
**关键亮点**：一维DP优化状态，减少空间占用，代码简洁。
**核心思路**：`f[i]`表示到达i位置的最小靴子编号，通过双重循环枚举转移，强调靴子承受能力的双重检查。
```cpp
// 核心代码片段
for(register int i=2;i<=n;++i) 
    for(register int j=1;j<i;++j)
        for(register int k=f[j];k<=m;++k)
            if(op[k].s>=d_s[i] && op[k].d>=i-j && op[k].s>=d_s[j])
                f[i] = min(f[i],k);
```

### 关键思路总结
- **状态设计**：优先考虑一维/二维状态表示可达性与最优解。
- **转移优化**：滑动窗口减少无效枚举，提升效率。
- **条件检查**：确保起点和终点的积雪符合靴子承受能力，中间路径无需检查。

### 类似题目推荐
1. **P1944 最长前缀**（状态压缩与动态规划）
2. **P2374 攀爬者**（状态转移与条件判断）
3. **P4568 飞行路线**（分层图动态规划，多状态优化）

### 题解中的个人心得
- **communist**提到“无脑转移”体现了暴力DP的直观性，但需注意代码正确性验证。
- **KarL05**的Java实现展示了DFS剪枝的重要性，强调记忆化的必要性。
- **忘怀星**的滑动窗口方法启示优化应从问题特性入手，减少无效计算。

---
处理用时：314.75秒
# 题目信息

# [IOI 1998] Polygon

## 题目描述

# 题目可能有些许修改，但大意一致

多边形是一个玩家在一个有n个顶点的多边形上的游戏，如图所示，其中n＝4。每个顶点用整数标记，每个边用符号+（加）或符号*（乘积）标记。

![](https://cdn.luogu.org/upload/pic/16086.png)

第一步，删除其中一条边。随后每一步： 

选择一条边连接的两个顶点V1和V2，用边上的运算符计算V1和V2得到的结果来替换这两个顶点。 

游戏结束时，只有一个顶点，没有多余的边。

如图所示，玩家先移除编号为3的边。之后，玩家选择计算编号为1的边，然后计算编号为4的边，最后，计算编号为2的边。结果是0。

![](https://cdn.luogu.org/upload/pic/16088.png)

（翻译者友情提示：这里每条边的运算符旁边的数字为边的编号，不拿来计算）

编写一个程序，给定一个多边形，计算最高可能的分数。

## 样例 #1

### 输入

```
4
t -7 t 4 x 2 x 5
```

### 输出

```
33
1 2```

# AI分析结果



### 综合分析与结论
本题核心为区间动态规划，需解决环形结构处理与乘法负负得正问题。所有题解均采用断环成链+区间DP思路，核心难点在于维护最大值和最小值以处理乘法极值问题。最优解法通过同时维护最大/最小值数组，并在乘法转移时枚举四种乘积组合（max*max, max*min, min*max, min*min）。

---

### 高评分题解推荐

#### 1. Kalista（★★★★★）
**关键亮点**：  
- 详细分类讨论9种乘法场景，确保覆盖所有可能极值情况  
- 提供压缩后的简洁转移方程，平衡全面性与代码可读性  
- 强调初始化长度为1的特殊情况  

**核心代码**：
```cpp
for(int k=i; k<j; k++){
    if(c[k+1]=='x'){
        f[i][j] = max(f[i][j], max(f[i][k]*f[k+1][j], 
                        max(g[i][k]*g[k+1][j], 
                        max(f[i][k]*g[k+1][j], g[i][k]*f[k+1][j]))));
        g[i][j] = min(g[i][j], min(f[i][k]*f[k+1][j], 
                        min(g[i][k]*g[k+1][j], 
                        min(f[i][k]*g[k+1][j], g[i][k]*f[k+1][j]))));
    }
    // 加法部分省略...
}
```

#### 2. ZigZagKmp（★★★★☆）
**关键亮点**：  
- 使用双数组(f[0][][], f[1][][])分别存储最大/最小值，代码结构清晰  
- 通过合并乘积情况简化转移方程  
- 更新日志体现对读者反馈的及时修正  

**核心实现**：
```cpp
// f[1]存最大值，f[0]存最小值
if(op[k+1]=='x'){
    f[0][l][r] = min(f[0][l][r], 
        min(f[0][l][k]*f[0][k+1][r], 
        min(f[0][l][k]*f[1][k+1][r], 
        min(f[1][l][k]*f[0][k+1][r], 
            f[1][l][k]*f[1][k+1][r]))));
    f[1][l][r] = max(f[1][l][r], 
        max(f[0][l][k]*f[0][k+1][r], 
        max(f[0][l][k]*f[1][k+1][r], 
        max(f[1][l][k]*f[0][k+1][r], 
            f[1][l][k]*f[1][k+1][r]))));
}
```

#### 3. brealid（★★★☆☆）
**创新点**：  
- 使用函数指针处理运算符，提升代码扩展性  
- 通过max4/min4宏简化极值比较  

**核心技巧**：
```cpp
typedef int Func(int, int);
int op_plus(int a, int b) { return a + b; }
int op_multi(int a, int b) { return a * b; }
Func *oper[107]; // 存储运算符函数指针

// 在DP转移时调用：
int res = oper[k](a, b);
```

---

### 关键思路总结
1. **断环成链**：复制数组到2倍长度处理环形结构  
2. **双DP数组**：`f[i][j]`存区间最大结果，`g[i][j]`存最小结果  
3. **乘法极值处理**：枚举四种组合 `max*max, max*min, min*max, min*min`  
4. **加法处理**：直接取两区间极值的和  

---

### 拓展练习
1. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880) - 环形区间DP基础  
2. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063) - 环形区间DP变式  
3. [P2470 压缩](https://www.luogu.com.cn/problem/P2470) - 复杂状态转移的区间DP

---
处理用时：64.41秒
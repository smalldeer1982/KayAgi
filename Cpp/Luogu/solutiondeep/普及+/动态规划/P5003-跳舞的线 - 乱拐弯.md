# 题目信息

# 跳舞的线 - 乱拐弯

## 题目背景

# 线初始面对方向请自己确定

![您可以写dp](https://cdn.luogu.com.cn/upload/pic/30733.png)

玩过了 $LCA$ 之后，Imakf 觉得甚是无聊，于是便打开了 DL。

Imakf：刺客传奇又死在 $70\%$！突然有一点弃坑的想法鸭……

Imakf 想起自己玩了 $1$ 年的 DL，卡在园林教堂混沌，肝了几个月终于过了的欣喜，却被这个刺客传奇困住，禁不住泪眼朦胧。泪眼中，他突然发现手机变成了一个一个的像素点！Imakf 非常惊喜！这样不就可以写一个程序自动通关了吗？

可是不一会，他又陷入了失望……

Imakf：我不会写啊！！


## 题目描述

线现在在一个地图上，它正在 $(1,1)$ 上（左上角），最终要去到 $(M,N)$ 上。它不但只能往下或往右走，还只能在整数格子上移动。

Imakf 有的时候想要炫技，又有时想偷懒，所以他会告诉你这张地图的全貌，你要告诉他到达终点的最多和最少拐弯次数。


## 说明/提示

样例 $1$ 说明：

![](https://cdn.luogu.com.cn/upload/pic/12623.png)

红色路线代表拐弯次数最多。

蓝色路线代表拐弯次数最少。

--------------

样例 $2$ 说明：

显然过不去。

---

数据范围：

| 测试点 | $N$ | $M$ |
| -----------: | -----------: | -----------: |
| $1\sim 5$ | $\leq100$ | $\leq100$ |
| $6\sim 7$ | $=200$ | 不做约定 |
| $8\sim 10$ | 不做约定 |不做约定|

对于全体数据，保证 $10\le M,N\le 1000$。

感谢 @Iowa\_BattleShip 指出数据错误。

## 样例 #1

### 输入

```
5 5
oooo#
ooooo
#oo#o
o#ooo
oo#oo
```

### 输出

```
7 2
```

## 样例 #2

### 输入

```
5 5
oooo#
ooooo
#oo##
o#o#o
oo#oo
```

### 输出

```
-1```

# AI分析结果



### 综合分析结论
本题核心为二维动态规划，需同时维护最多/最少拐弯次数两种状态。关键点在于方向状态拆分、障碍物处理及边界初始化。各题解均采用方向拆分的三维DP思路，差异主要体现在状态转移方程的优化技巧与代码实现细节。

---

### 精选题解推荐

#### 1. Flying2018（★★★★☆）
**关键亮点**：  
- 四维数组同时维护最大/最小值，同步转移减少重复计算  
- 巧用极大值初始化处理不可达状态  
- 代码结构清晰，初始化与转移逻辑对称  
**个人心得**：  
> "这里默认在(1,1)处也是能拐弯的（但事实是不能的），所以最大值最后要-1" —— 提示初始化方向的细节处理

```cpp
// 核心转移逻辑
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
        if(map[i][j]=='#') continue;
        // 最小值转移
        f[0][i+1][j][0] = min(f[0][i+1][j][0], min(f[0][i][j][0], f[0][i][j][1]+1));
        f[0][i][j+1][1] = min(f[0][i][j+1][1], min(f[0][i][j][1], f[0][i][j][0]+1));
        // 最大值转移 
        f[1][i+1][j][0] = max(f[1][i+1][j][0], max(f[1][i][j][0], f[1][i][j][1]+1));
        f[1][i][j+1][1] = max(f[1][i][j+1][1], max(f[1][i][j][1], f[1][i][j][0]+1));
    }
```

#### 2. qwerta（★★★★☆）
**关键亮点**：  
- 独立处理最大/最小值，逻辑分离便于理解  
- 采用滚动初始化技巧，代码简洁  
- 显式处理起点障碍特判  
**调试经验**：  
> "调了半天的程序" —— 强调起点障碍检查的重要性

```cpp
// 关键初始化与转移
memset(f,0x3f,sizeof(f)); // 最小值初始化
memset(g,0xcf,sizeof(g));  // 最大值初始化
f[1][1][0] = f[1][1][1] = 0;
g[1][1][0] = g[1][1][1] = 0;

for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
        if(!map[i][j]){
            // 最小值转移
            f[i][j][0] = min(f[i][j][0], min(f[i][j-1][0], f[i-1][j][1]+1));
            // 最大值转移
            g[i][j][1] = max(g[i][j][1], max(g[i-1][j][1], g[i][j-1][0]+1));
        }
```

#### 3. Refined_heart（★★★☆☆）
**亮点**：  
- 详细注释说明状态定义  
- 独立处理行列初始化  
**优化点**：  
使用位运算加速状态转移，但可读性稍降

---

### 关键思路总结
1. **状态设计**：`dp[i][j][k]` 表示到达(i,j)时方向为k（0右/1下）的极值  
2. **转移方程**：  
   - 同方向：继承前值  
   - 异方向：前值+1  
3. **障碍处理**：遇到障碍时设为不可达（极大/极小值）  
4. **初始化技巧**：第一行/列单独处理，注意连续障碍阻断路径  

### 同类拓展题目
1. **P1004 方格取数**（双路径DP）  
2. **P1216 数字三角形**（二维极值问题）  
3. **P1140 相似基因**（状态转移优化）  

### 调试经验摘录
> "调了半天发现初始化错误" —— 多题解提到第一行/列初始化的陷阱  
> "终点方向要特殊处理" —— 最终答案需综合两个方向极值  
> "BFS双端队列实现时方向标记混乱" —— 强调状态定义的清晰性

---
处理用时：64.88秒
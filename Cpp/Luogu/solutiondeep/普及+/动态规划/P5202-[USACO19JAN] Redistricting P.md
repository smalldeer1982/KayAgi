# 题目信息

# [USACO19JAN] Redistricting P

## 题目背景

USACO 19 年一月月赛铂金组第一题。

## 题目描述

奶牛们的特大城市，牛都，要进行重新分区了！——这总是一个在居住在这里的两大主要种族（荷斯坦牛和更赛牛）之间富有争议的政治事件，因为两大种族都想要在牛都政府中保持足够的影响力。

牛都的大都市圈由一列 $n$ 块牧草地组成，每块里有一头奶牛，均为荷斯坦牛 (Holstein) 和更赛牛 (Guernsey) 之一。

牛都政府想要将大都市圈划分为若干个连续的区，使得每个区至少包含一块牧草地且至多包含 $k$ 块牧草地，并且每块牧草地恰好属于一个区。由于政府当前由荷斯坦牛控制，她们想要找到一种分区方式能够最小化更赛牛较多或者均势的区的数量（如果更赛牛的数量与荷斯坦牛的数量相等那么这个区就是均势的）。

有一个关心政治的更赛牛团体想要知道政府的分区计划可能会对她们造成多少损害。帮助她们求出最坏情况，也就是更赛牛较多或是均势的区的最小可能的数量。

## 说明/提示

### 样例解释

一种可能的划分方式是 $[1],~[2, 3],~[4, 5],~[6, 7]$。第二、四个区是均势的区，第三个区是更赛牛优势的区。

### 数据范围

对于 $100\%$ 的数据，保证 $1 \leq k \leq n \leq 3 \times 10^5$，$s$ 的长度为 $n$，且只含字符 `H` 和 `G`。

## 样例 #1

### 输入

```
7 2
HGHGGHG```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题核心是动态规划优化，难点在于快速维护满足区间限制的最优转移点。各题解均围绕如何高效维护以下状态转移展开：
`f[i] = min{f[j] + (sum[i]<=sum[j])} (i-k ≤ j < i)`  
最优解法为**单调队列优化**，利用双关键字排序（DP值优先，前缀和为次）实现O(n)时间复杂度。其他方法（堆、线段树）虽正确但效率或实现复杂度略逊。

---

### 精选题解与亮点分析

#### 1. 梧桐灯（5星）
**核心亮点**  
- 双关键字单调队列优化，线性时间复杂度  
- 代码简洁高效（131ms），队列维护逻辑清晰  
- 明确指出排序规则：`f`值小优先，相等时`sum`小优先

**关键代码**  
```cpp
int Q[N], H, T; // 单调队列
for (i = 1; i <= n; ++i) {
    while (H < T && i - Q[H] > k) ++H; // 维护窗口大小
    f[i] = f[Q[H]] + (sum[i] - sum[Q[H]] <= 0);
    while (H < T) { // 维护双关键字单调性
        if (f[i] < f[Q[T-1]] || (f[i]==f[Q[T-1]] && sum[i]<sum[Q[T-1]])) --T;
        else break;
    }
    Q[T++] = i;
}
```

#### 2. 小木虫（5星）
**核心亮点**  
- 同类单调队列解法，代码更易理解  
- 变量命名清晰（sum直接表示差值）  
- 包含对排序规则的直观解释

**个人心得引用**  
> "唐氏把 deque 写成 queue 了，还没发现"  
> 调试经历强调双端队列的必要性，提醒注意数据结构选择。

#### 3. lym12（4星）
**核心亮点**  
- 完整代码包含输入处理和初始化逻辑  
- 使用标准库`deque`实现，代码更易移植  
- 添加详细注释说明维护逻辑

**关键实现**  
```cpp
deque<int> q;
q.push_back(0);
for (int i=1; i<=n; ++i) {
    while (!q.empty() && i-q.front()>k) q.pop_front();
    dp[i] = dp[q.front()] + (pre[i] <= pre[q.front()]);
    while (!q.empty() && (dp[i]<dp[q.back()] || (dp[i]==dp[q.back()] && pre[i]<pre[q.back()]))) 
        q.pop_back();
    q.push_back(i);
}
```

---

### 关键思路总结
1. **双关键字排序**：优先比较DP值，相同时比较前缀和，确保队列头部为最优转移点。
2. **滑动窗口维护**：及时移除超范围元素保证区间合法性。
3. **单调性证明**：当`f[j]`更优或`sum[j]`更小时，后续元素无法超越其优势。

---

### 拓展练习推荐
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)  
   （单调队列基础应用）
2. [P1714 切蛋糕](https://www.luogu.com.cn/problem/P1714)  
   （前缀和+单调队列求最大区间和）
3. [P2627 Mowing the Lawn](https://www.luogu.com.cn/problem/P2627)  
   （区间选择型DP，需单调队列优化）

---

### 高频调试经验
- **队列类型选择**：必须使用双端队列（deque）以实现头尾双端操作  
- **边界处理**：前缀和下标从0开始，注意i-k-1的删除时机  
- **比较运算符方向**：维护单调性时注意排序方向与题意的对应关系

---
处理用时：56.14秒
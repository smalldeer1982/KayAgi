# 题目信息

# 【XR-1】分块

## 题目背景

xht37 喜欢分块，以至于对一道**不需要分块**的题也要分块做。

## 题目描述

有一个长度为 $n$ 的序列，xht37 现在想分块维护它。

PinkRabbit 要求他只准将序列分成 $PR$ 种长度的块。

NaCly_Fish 要求他只准将序列分成 $NF$ 种长度的块。

同一个人可能会要求 xht37 多次相同的块长。

xht37 想同时满足 PinkRabbit 和 NaCly_Fish 要求，只好使用两个人都允许的长度分块。

xht37 想知道，有多少种不同的分块方案，答案对 $10 ^ 9 + 7$ 取模。

## 说明/提示

【样例 $1$ 说明】

PinkRabbit 和 NaCly_Fish 都允许的块长为 $\{1,2\}$。

长度为 $4$ 的序列分块，每块长度为 $\{1,2\}$ 的方案有：

- $1\ 1\ 1\ 1$
- $1\ 1\ 2$
- $1\ 2\ 1$
- $2\ 1\ 1$
- $2\ 2$

共 $5$ 种。

【数据规模与约定】

设最大块长为 $x$。

对于 $60 \%$ 的数据，$1 \le n \le 10 ^ 6$，$1 \le PR,NF,x \le 10$，保证同一个人不会要求多次相同的块长。

对于 $100 \%$ 的数据，$1 \le n \le 10 ^ {18}$，$1 \le PR,NF,x \le 100$。

## 样例 #1

### 输入

```
4
3
1 2 3
3
1 2 4```

### 输出

```
5```

## 样例 #2

### 输入

```
19260817
7
8 9 6 3 7 2 1
7
4 5 2 9 7 8 3```

### 输出

```
859254329```

# AI分析结果



### 综合分析与结论
本题核心是动态规划+矩阵快速幂优化。所有题解均采用以下关键步骤：
1. 求两个允许块长集合的交集
2. 定义状态转移方程 $f_i = \sum f_{i-k}$
3. 构造转移矩阵实现 $O(\log n)$ 复杂度
4. 矩阵快速幂处理大规模递推

各题解差异主要在于矩阵构造方式、预处理细节和代码实现技巧。最优解法的核心在于构造符合递推关系的转移矩阵，并合理处理初始状态。

---

### 精选题解推荐

#### 1. 作者：Heartlessly（★★★★★）
**关键亮点**：
- 通过图示清晰展示矩阵构造过程
- 详细推导初始矩阵和转移矩阵的构造逻辑
- 完整的状态转移预处理说明
- 代码结构清晰，变量命名规范

**个人心得**：
> "答案矩阵的第1行第1列即是最终答案" —— 明确输出位置的关键提示

**核心代码**：
```cpp
struct Matrix {
    int mat[MAXN + 5][MAXN + 5];
    Matrix operator*(Matrix b) { // 标准矩阵乘法实现
        Matrix c;
        for(int i=1; i<=size; ++i)
            for(int k=1; k<=size; ++k)
                for(int j=1; j<=size; ++j)
                    c.mat[i][j] = (c.mat[i][j] + (LL)mat[i][k]*b.mat[k][j])%MOD;
        return c;
    }
};
```

#### 2. 作者：xht（★★★★☆）
**关键亮点**：
- 官方题解，代码简洁高效
- 使用bitset快速处理集合交集
- 矩阵构造采用移位技巧
- 双重解法展示60分与满分思路

**核心代码**：
```cpp
void mulself() { // 矩阵自乘优化
    ll c[N][N];
    memset(c, 0, sizeof(c));
    for(int i=1; i<=m; i++)
        for(int k=1; k<=m; k++)
            for(int j=1; j<=m; j++)
                c[i][j] = (c[i][j] + a[i][k] * a[k][j]) % P;
    memcpy(a, c, sizeof(a));
}
```

#### 3. 作者：quest_2（★★★★☆）
**关键亮点**：
- 详细解释矩阵构造的数学原理
- 使用map处理块长交集
- 通过斐波那契数列类比帮助理解

**关键思路**：
```cpp
// 转移矩阵构造逻辑
for(int i=1; i<=100; i++)
    if(m2[i]) RBQ[1][i] = 1;  // 首行对应转移系数
for(int i=1; i<100; i++)       // 次对角线维持状态递推
    RBQ[i+1][i] = 1;
```

---

### 关键优化技巧总结
1. **矩阵构造模式**：
   - 第一行存储所有合法转移系数
   - 次对角线填充1实现状态移位
   - 矩阵维度由最大块长决定

2. **预处理技巧**：
   ```cpp
   // 预处理初始状态
   for(int i=1; i<size; i++)
       for(int j : valid_blocks)
           if(i >= j)
               f[i] += f[i-j];
   ```

3. **快速幂优化**：
   采用二进制分解的快速幂结构，时间复杂度稳定在 $O(x^3\log n)$

---

### 同类题目推荐
1. [P1939 矩阵加速（数列）](https://www.luogu.com.cn/problem/P1939)  
   **相似点**：三阶递推的矩阵构造

2. [P3390 矩阵快速幂](https://www.luogu.com.cn/problem/P3390)  
   **相似点**：矩阵快速幂模板练习

3. [P2109 信号连接](https://www.luogu.com.cn/problem/P2109)  
   **相似点**：动态规划+矩阵优化的综合应用

---

### 心得体会摘录
- **去重教训**："比赛时忘记去重没AC" → 强调输入处理的重要性
- **边界处理**："f[0]=1的初始状态容易遗漏" → 递推起点的关键性
- **矩阵理解**："通过斐波那契数列类比理解转移矩阵" → 知识迁移的典型应用

---
处理用时：66.95秒
# 题目信息

# 小 C 与桌游

## 题目背景

小 C 是一个热爱桌游的高中生，现在他被一个桌游难住了，快来帮帮他！

## 题目描述

这个桌游的地图可以被抽象成一个 $n$ 个点，$m$ 条边的**有向无环图**（**不保证连通**），小 C 在这个地图上行走，小 C 能走到某个点当且仅当能够到达这个点的所有点都已经被小 C 走到。小 C 会走到每个点恰好 $1$ 次，并且他能走到哪些点与他当前所在的点没有关系（即可以走到与当前所在的点没有连边的点，只要满足之前的条件）。

小 C 每走到一个标号比之前走到的点都大的点，他就会有 $\frac{1}{2}$ 的概率从对手那里拿到 $1$ 块筹码，有 $\frac{1}{2}$ 的概率给对手 $1$ 块筹码，双方初始各有 $1919810$ 个筹码。

小 C 的运气时好时坏，所以他希望你帮他计算出：

- 在最优情况下，即他每次都能从对手那里拿到筹码时，他采取最优的行走方式能得到的筹码数。
- 在最劣情况下，即对手每次都能从他那里拿到筹码时，他采取最优的行走方式会失去的筹码数。



## 说明/提示

**样例解释**

最优情况下的行走方式是 $1-2-3$，最劣情况下的行走方式是 $1-3-2$。

**计分方式**

对于每一个测试点：

- 如果你输出格式错误或者两行都不正确，将会得到 $0$ 分。
- 如果你的输出第一行正确，第二行错误或第二行正确，第一行错误，将会得到这个测试点 $40 \%$ 的分数。
- 否则，你将会得到这个测试点 $100 \%$ 的分数。

**数据范围**

对于 $20\%$ 的数据，$1 \le n, m \le 10$。

对于 $40\%$ 的数据，$1 \le n, m \le 2000$。

对于 $100\%$ 的数据，$1 \le n, m \le 5 \times 10^5$，$1 \le u, v \le n$。


## 样例 #1

### 输入

```
3 2
1 2
1 3```

### 输出

```
3
2```

# AI分析结果



### 综合分析与结论
该题核心在于DAG的拓扑排序变种，需分别求最大/最小前缀最大值变化次数。最优情况通过小根堆贪心即可解决，而最劣情况需特殊处理以避免局部最优陷阱。

---

### 精选题解分析

#### 1. Mubuky的题解（★★★★☆）
**关键亮点**：  
- 最劣情况采用「分层处理」策略：用优先队列存放大节点，普通队列存放小节点，确保优先处理不增加答案的小节点。  
- 代码结构清晰，通过维护`maxn`和`kz`队列实现分层拓扑排序。  
**核心代码**：  
```cpp
// 最劣情况处理逻辑
while(!qless.empty()){
    int x = qless.top();
    if(x > maxn) ans++;
    while(!qless.empty()){ // 将大节点存入临时队列
        kz.push(qless.top());
        qless.pop();
    }
    while(!kz.empty()){ // 处理小节点并更新后续节点状态
        int nx = kz.front();
        kz.pop();
        maxn = max(maxn, nx);
        for(后续节点处理...) // 更新入度并分类存放
    }
}
```

#### 2. Sweetlemon的题解（★★★★☆）
**关键亮点**：  
- 提出「买票模型」的贪心思维：必须支付代价时选择最大节点，以扩大后续选择范围。  
- 使用双堆（大根堆+小根堆）分别处理不同阶段的节点。  
**核心代码**：  
```cpp
// 双堆配合处理最劣情况
priority_queue<int> q2; // 大根堆
priority_queue<int,vector<int>,greater<int> > q; // 小根堆
while(!q2.empty()){
    int now = q2.top();
    if(now > last) ans2++;
    while(q.size() && q.top() <= last){ // 处理所有小节点
        int x = q.top(); q.pop();
        // 更新后续节点状态
    }
    // 处理大节点并更新last
}
```

#### 3. huangzirui的题解（★★★☆☆）
**核心思路**：  
- 提出在必须增加答案时选择最大节点，否则优先处理小节点。  
- 使用`queue`暂存可立即处理的小节点。  
**不足**：代码实现较繁琐，缺乏对复杂案例的优化。

---

### 关键思路总结
1. **最优情况**：直接用小根堆维护拓扑排序，每次取最小节点。  
2. **最劣情况**：  
   - 分层处理：优先处理所有不增加答案的小节点（≤当前最大值），再处理必须的大节点。  
   - 数据结构：结合优先队列（大根堆）和普通队列/集合，确保动态维护节点状态。  

---

### 拓展与推荐题目
1. **同类题目推荐**：  
   - [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)：拓扑排序+DP求最长路径。  
   - [P3243 [HNOI2015]菜肴制作](https://www.luogu.com.cn/problem/P3243)：逆向拓扑排序求最小字典序。  
   - [P1967 货车运输](https://www.luogu.com.cn/problem/P1967)：最大生成树+贪心路径选择。  

2. **调试心得**：  
   - 反例验证：构造如`1->3, 1->2`等简单图，验证最劣情况策略是否避免错误。  
   - 数据规模：注意`n=5e5`时需使用高效数据结构（如堆、队列），避免递归或复杂遍历。

---
处理用时：60.19秒
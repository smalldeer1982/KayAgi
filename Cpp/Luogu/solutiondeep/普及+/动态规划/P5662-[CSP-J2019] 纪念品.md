# 题目信息

# [CSP-J2019] 纪念品

## 题目描述

小伟突然获得一种超能力，他知道未来 $T$ 天 $N$ 种纪念品每天的价格。某个纪念品的价格是指购买一个该纪念品所需的金币数量，以及卖出一个该纪念品换回的金币数量。

每天，小伟可以进行以下两种交易**无限次**：
1. 任选一个纪念品，若手上有足够金币，以当日价格购买该纪念品；
2. 卖出持有的任意一个纪念品，以当日价格换回金币。

每天卖出纪念品换回的金币可以**立即**用于购买纪念品，当日购买的纪念品也可以**当日卖出**换回金币。当然，一直持有纪念品也是可以的。

$T$ 天之后，小伟的超能力消失。因此他一定会在第 $T$ 天卖出**所有**纪念品换回金币。

小伟现在有 $M$ 枚金币，他想要在超能力消失后拥有尽可能多的金币。 
 

## 说明/提示

**样例 1 说明**

最佳策略是：

第二天花光所有 $100$ 枚金币买入 $5$ 个纪念品 $1$；

第三天卖出 $5$ 个纪念品 $1$，获得金币 $125$ 枚；

第四天买入 $6$ 个纪念品 $1$，剩余 $5$ 枚金币；

第六天必须卖出所有纪念品换回 $300$ 枚金币，第四天剩余 $5$ 枚金币，共 $305$ 枚金币。

超能力消失后，小伟最多拥有 $305$ 枚金币。

**样例 2 说明**

最佳策略是：

第一天花光所有金币买入 $10$ 个纪念品 $1$；

第二天卖出全部纪念品 $1$ 得到 $150$ 枚金币并买入 $8$ 个纪念品 $2$ 和 $1$ 个纪念品 $3$，剩余 $1$ 枚金币；

第三天必须卖出所有纪念品换回 $216$ 枚金币，第二天剩余 $1$ 枚金币，共 $217$ 枚金币。

超能力消失后，小伟最多拥有 $217$ 枚金币。


**数据规模与约定**

对于 $10\%$ 的数据，$T = 1$。

对于 $30\%$ 的数据，$T \leq 4, N \leq 4, M \leq 100$，所有价格 $10 \leq P_{i,j} \leq 100$。

另有 $15\%$ 的数据，$T \leq 100, N = 1$。

另有 $15\%$ 的数据，$T = 2, N \leq 100$。

对于 $100\%$ 的数据，$T \leq 100, N \leq 100, M \leq 10^3$，所有价格 $1 \leq P_{i,j} \leq 10^4$，数据保证任意时刻，小伟手上的金币数不可能超过 $10^4$。

## 样例 #1

### 输入

```
6 1 100
50
20
25
20
25
50```

### 输出

```
305```

## 样例 #2

### 输入

```
3 3 100
10 20 15
15 17 13
15 25 16```

### 输出

```
217```

# AI分析结果



### 综合分析与结论
该题核心在于将多天持有纪念品转化为相邻两天的完全背包问题。关键技巧是：利用"当日买卖"特性，将长期持有等价于每日卖出再买入，从而将问题分解为 T-1 轮完全背包。每轮以当天价格为成本、次日差价为收益，用一维数组优化空间至 O(M)。

---

### 精选题解推荐

#### 1. 泥土笨笨（★★★★★）
**核心亮点**：  
- 创造性提出"当日买卖等价长期持有"的转化思路  
- 清晰的三维DP到一维优化的推导过程  
- 代码包含详细注释和初始化逻辑  
**关键代码**：
```cpp
memset(dp, ~0x3f, sizeof(dp));
dp[ans] = ans; // 初始化不交易的情况
for(int j=1; j<=n; ++j) 
    for(int k=ans; k>=price[i][j]; --k)
        dp[k - price[i][j]] = max(dp[...], dp[k] + price[i+1][j] - price[i][j]);
```
**实现技巧**：倒序循环防止重复购买，用位运算初始化负无穷

#### 2. 邓布利多6（★★★★☆）
**核心亮点**：  
- 最简洁的问题抽象，直接给出"T-1轮完全背包"结论  
- 代码仅20行，适合快速理解核心逻辑  
**关键代码**：
```cpp
for(int k=1; k<t; k++) {
    memset(f,0,sizeof f);
    for(int i=1; i<=n; i++)
        for(int j=price[i][k]; j<=m; j++)
            f[j] = max(f[j], f[j-price[i][k]] + price[i][k+1]-price[i][k]);
    m += f[m];
}
```
**优化点**：直接复用price数组，省去额外转化步骤

#### 3. WsW_（★★★★☆）
**核心亮点**：  
- 独创"长期持有定理"的数学证明  
- 引入类比股票交易的思考过程  
**顿悟摘录**：  
"长期持有等价于每天卖出再买入，这个转化让我豁然开朗。考试时在草稿纸上画价格波动图，突然意识到相邻两天的决策独立性"

---

### 关键思路总结
1. **时间维度压缩**：将T天问题转化为T-1次独立决策，消除时间后效性  
2. **完全背包转化**：以当日价格为物品重量，次日差价为价值  
3. **滚动数组优化**：一维DP数组复用，空间复杂度从O(TNM)降至O(M)  
4. **收益链式累积**：每轮更新m += f[m]，将收益迭代至下轮本金  

---

### 拓展训练推荐
1. **完全背包模板**：[P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)  
2. **多阶段决策DP**：[P2938 [USACO09FEB] Stock Market G](https://www.luogu.com.cn/problem/P2938)  
3. **时间序列优化**：[P2569 [SCOI2010] 股票交易](https://www.luogu.com.cn/problem/P2569)  

---

### 核心代码实现
**邓布利多6的优化版**：
```cpp
int price[105][105], f[10005];
for (int day = 1; day < t; ++day) {
    memset(f, 0, sizeof(f));
    for (int i = 1; i <= n; ++i) {
        int cost = price[day][i], profit = price[day+1][i] - cost;
        for (int j = cost; j <= m; ++j)
            f[j] = max(f[j], f[j - cost] + profit);
    }
    m += f[m];
}
```
**特点**：5行核心逻辑，清晰体现"成本-收益"关系，适合竞赛快速编码

---
处理用时：59.93秒
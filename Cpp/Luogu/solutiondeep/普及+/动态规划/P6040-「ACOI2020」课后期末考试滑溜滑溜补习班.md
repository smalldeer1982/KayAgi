# 题目信息

# 「ACOI2020」课后期末考试滑溜滑溜补习班

## 题目背景

![T2](https://s2.ax1x.com/2020/01/12/lopS6f.png)

潮田 渚（Shiota Nagisa）因为理科不大好，自然会被仔细观察学生的杀老师发现，于是渚同学只得加入杀老师举办的课后期末考试滑溜滑溜补习班。至于为什么叫这个名字，额，你不能问我啊。

## 题目描述

在补习班上，因为多个学生会同时有需求，所以杀老师会制造分身用音速移动来回回答问题。

补习班上有 $n$ 个同学，他们每一个人都有一个问题。杀老师为了有序回答学生的问题，把所有学生排成了一列。第 $i$ 个学生的问题有一个困难值 $a_i$，杀老师回答第 $i$ 个学生的问题需要花费 $a_i$ 的精力。杀老师到了哪里，它就要解决那个学生的问题。杀老师最开始会解决序列中第一个同学的问题，他最后会去解决最后一个同学的问题。

杀老师每次解决完一个同学的问题到下一个同学的座位上就要花费 $k$ 点精力值。特殊的，如果杀老师想让自己轻松一点，可以不移动到下一个，可以直接到下两个，下三个，就不用解决跳过的同学的问题了。对应的，它会被学生调侃。受到打击的杀老师自然会花费格外的精力，花费的精力为 $k+(q-p-1) \times d$（当前位置为 $p$，跳到的位置为 $q$）。

当然的，杀老师也是有速度的啊，并且它想解决学生的一些问题，所以说杀老师最多只会跳过 $x-1$ 个学生，去解决下 $x$ 个学生的问题。

## 说明/提示

#### 样例解释 #1

杀老师每次不能跳过学生，因此他必须依次移动并解决所有问题，故答案为解决问题所需的精力 $1+2+3+4+5=15$ 与移动所需的精力 $4 \times 3=12$，所以花费精力之和为 $27$。

------------
#### 数据范围

**本题采用捆绑测试**。

- Subtask 1（20 points），学生们学习认真听话，留下来的同学也会更少：$tp=0$，$n \leq 10^3$。     
- Subtask 2（30 points），杀老师的速度快极了，并且学生们没时间吐槽它：$tp=0$，$n \leq 10^6$。     
- Subtask 3（50 points），$tp=1$，其余无特殊限制。

对于 $100\%$ 的数据，$1 \leq n \leq 10^7$，$0 \leq k,d,a_i \leq 10^9$，$1 \leq x \leq n-1$。

------------
#### 提示

对于 $tp=1$ 的数据，$rnd$ 函数只用于减小输入量，标准算法不依赖该数据生成方式。

## 样例 #1

### 输入

```
5 3 4 1 0
1 2 3 4 5
```

### 输出

```
27```

## 样例 #2

### 输入

```
10 30630 56910 2 0
7484 99194 86969 17540 29184 68691 91892 81564 93999 74280 
```

### 输出

```
717318```

## 样例 #3

### 输入

```
10000000 899999999 923456655 213111 1
1314520```

### 输出

```
9231813656566921```

# AI分析结果



### 综合分析与结论
本题核心为动态规划+单调队列优化，将跳跃决策转化为滑动窗口最小值问题。各题解均围绕状态转移方程推导与单调队列维护展开，差异主要体现在代码实现细节与优化处理上。

---

### 精选题解列表

#### 1. 作者：FCBM71（★★★★★）
**关键亮点**：
- 完整处理了 `x=1` 的特殊情况，避免队列操作冗余。
- 代码中明确区分变量类型（如 `LL`），避免溢出。
- 详细注释与推导步骤，便于理解单调队列的维护逻辑。

**个人心得**：
> 不开LL见祖宗  
> 弹出条件推导时注意距离计算的细节（强调不要漏-1）

**核心代码思想**：
```cpp
deque<pair<LL,int>> q; // 维护 (f[j] - j*d, j)
if(x==1) { // 特判无跳跃场景
    LL sum = accumulate(a+1, a+n+1, 0LL);
    cout << sum + k*(n-1);
    return;
}
while(!q.empty() && q.front().second < i-x) q.pop_front(); // 窗口左边界
f[i] = q.front().first + (i-1)*d + k + a[i];
while(!q.empty() && f[i]-i*d <= q.back().first) q.pop_back(); // 维护单调性
```

---

#### 2. 作者：zhangyuhan（★★★★☆）
**关键亮点**：
- 使用STL的`deque`实现，代码简洁易懂。
- 状态转移方程变形清晰，分离出独立项便于维护。
- 完整处理数据生成函数，适配题目的两种输入模式。

**核心代码思想**：
```cpp
deque<int> q; // 维护 j 的索引
f[i] = f[q.front()] + k + (i-q.front()-1)*d + a[i];
// 将方程拆解为 f[j] - j*d 的最小值 + 常数项
```

---

#### 3. 作者：panxz2009（★★★★☆）
**关键亮点**：
- 手写队列实现，性能更优（适合1e7级数据）。
- 变量命名规范，代码结构清晰。
- 对单调队列弹出条件的数学推导有详细说明。

**核心代码思想**：
```cpp
int q[N], head=1, tail=0; // 手写双端队列
while(head<=tail && q[head]<i-x) head++; // 维护窗口
f[i] = f[q[head]] + k + (i-q[head]-1)*d + a[i];
while(head<=tail && f[i]-i*d <= f[q[tail]]-q[tail]*d) tail--; // 单调性维护
```

---

### 最优思路与技巧总结
1. **状态转移方程变形**：  
   将原方程拆分为 `f[i] = (i-1)*d + k + a[i] + min{f[j] - j*d}`，分离出与`j`相关的单调队列维护项。
2. **单调队列维护**：  
   维护一个窗口大小为`x`的双端队列，保证队首始终为当前最优决策点。队列中存储索引`j`，按`f[j]-j*d`升序排列。
3. **边界处理**：  
   对`x=1`（必须连续移动）进行特判，直接计算总和避免队列操作，提升效率。
4. **数据生成适配**：  
   根据题目要求实现随机数生成函数，正确处理两种输入模式。

---

### 拓展与相似题目推荐
1. **滑动窗口极值**  
   - 例题：P1886 滑动窗口（模板题）
   - 技巧：单调队列基础应用
2. **跳跃决策型DP**  
   - 例题：P1725 琪露诺（区间跳跃+单调队列）
   - 例题：P2564 旅行问题（环形处理+单调队列）
3. **大范围数据优化**  
   - 例题：P3512 [POI2010]PIL-Pilots（极差约束+双单调队列）

---
处理用时：93.68秒
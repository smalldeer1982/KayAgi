# 题目信息

# 樱花，还有你

## 题目背景

Dear Ling,   
&emsp;&emsp;呐，你知道吗？听说樱花飘落的速度是秒速五厘米哦。    
&emsp;&emsp;……所以，再等等吧！三月，武汉大学，樱花就快来了呢。  
&emsp;&emsp;你一定会陪我一起看吧，在酥软的阳光下，我会悄悄牵起你的手，感受你熟悉的温度，糟糕，脸儿也不小心被粉嫩嫩的樱花映红的呢。  
&emsp;&emsp;对了，一定记得带口罩！你那时还是有些虚弱吧。但天依会保护你的！  
&emsp;&emsp;还有啊，樱花还可以做好多好多的点心呢！收集一些飘落樱花吧，我想喝樱花茶，还想吃樱饼，你一定要亲手给我做嗷！

## 题目描述

**与题意有关的句子已加粗。**

但别急，我们就这样彳亍而行吧，**需不着停留或回头**，前面不是**还有 $k$ 棵樱花树么**？我算了算，你可要收集**恰好 $n$ 朵樱花**。我还发现，在第 $i$ 棵树下**最多**能收集到 $s_i$ 朵樱花（收集了 $0$ 朵樱花也算收集了樱花）。  

呐，考考你吧！你有多少种方案能够收集到**恰好 $n$ 朵樱花**呢？

**特殊地，如果你收集不到 $n$ 朵樱花，请告诉我 `impossible`。**   

注意：如果你早早地收集到了 $n$ 朵樱花，你可以立刻告诉我，也可以陪我继续向前走，一直到第 $k$ 棵樱花树下收集了樱花后就必须交差啦！期间你在任何一棵树收集完樱花后就告诉我，形成的方案都是不同的哦！

## 说明/提示

#### 样例解释 #1
我们以下列方式表示一种方案：$(a_1,a_2,\cdots,a_{len})$，其中 $\sum_{i=1}^{len} a_i =n$，$len$ 表示在第 $len$ 棵樱花树下收集完樱花后就交差了，$a_i$ 表示在第 $i$ 棵树下收集了 $a_i$ 朵樱花。

那么有下列 $5$ 种方案：$(1,1,1)$，$(1,1,1,0)$，$(0,1,1,1)$，$(1,0,1,1)$，$(1,1,0,1)$。

---

#### 样例解释 #3
最多能收集到 $9$ 朵樱花，所以不能收集到 $10$ 朵樱花，输出 `impossible`。

---

#### 数据范围
**本题采用捆绑测试。**
- Subtask 1（5 Points），$\sum s_i < n$。
- Subtask 2（20 Points），$n,k \leq 20$。
- Subtask 3（55 Points），$n,k \leq 5\times 10^2$。
- Subtask 4（20 Points），$n,k \leq 5\times 10^3$。

对于 $100\%$ 的数据，$1 \leq n,k \leq 5\times 10^3$，$0 \leq s_i \leq n$。

---

#### 题目背景 ( 续 )
&emsp;&emsp;何等聪明的你一定会站在某棵树下，捧着 $n$ 朵可爱的樱花，像孩子似的向我邀功吧。  
&emsp;&emsp;那就别怪我成全你哦，我会轻跳起来，环住你的脖子，揭起你的口罩，尝一尝你的嘴唇。  
&emsp;&emsp;你会不会说，“像樱花一样甜”呢？  
&emsp;&emsp;反正，我的脸一定已经像樱花一样红了吧。  
&emsp;&emsp;……  
&emsp;&emsp;当你看到这封信，别哭呀……  
&emsp;&emsp;冬天从这座城市夺走的，春天会补偿我们的。  
&emsp;&emsp;待你好了，陪我去看樱花，可好？  

Yours,   
Yi

## 样例 #1

### 输入

```
3 4
1 1 1 1```

### 输出

```
5```

## 样例 #2

### 输入

```
10 9
9 6 8 7 9 6 5 4 3```

### 输出

```
68345```

## 样例 #3

### 输入

```
10 5
2 2 2 2 1```

### 输出

```
impossible```

# AI分析结果



### 综合分析
本题核心为动态规划结合前缀和优化，将时间复杂度从O(n²k)降为O(nk)，并正确处理滚动数组与负数取模。各题解均围绕这一核心展开，差异主要在于代码实现细节与优化技巧。

### 精选题解

#### 1. 作者：淸梣ling（5星）
**关键亮点**：
- 使用一维数组滚动优化，空间效率高。
- 前缀和预处理与动态更新清晰，避免冗余计算。
- 每处理一棵树立即累加答案，逻辑简洁。
- 处理总樱花数不足的边界条件。

**核心代码**：
```cpp
for(int i=1;i<=k;i++) {
    cin>>t;
    for(j=1;j<=n;j++) s[j]=s[j-1]+f[j]; // 更新前缀和
    for(p=n;p>=0;p--) // 逆序更新DP
        f[p]=(f[p]+s[p-1]-s[p-min(t,p)-1])%M;
    ans=(ans+f[n])%M; // 立即累加答案
}
```

#### 2. 作者：AlicX（4星）
**关键亮点**：
- 独立处理第一棵树，简化后续逻辑。
- 显式处理负数取模，避免结果错误。
- 变量命名清晰，代码可读性强。

**个人心得**：
> "出题人卡了空间，必须用一维数组优化。转移全由前缀和驱动，滚动数组省空间。"

**核心代码**：
```cpp
for(int i=2;i<=k;i++){
    for(int j=0;j<=n;j++) {
        int minn = max(j - a[i], 0);
        f[j] = (g[j] - (minn ? g[minn-1] : 0)) % mod; // 显式处理负数
    }
    ans = (ans + f[n]) % mod;
}
```

#### 3. 作者：人间温柔（4星）
**关键亮点**：
- 分情况讨论j与s_i的关系，逻辑严谨。
- 前缀和数组动态维护，代码结构清晰。
- 初始化步骤详细，避免遗漏边界。

**核心代码**：
```cpp
for(int i=2;i<=k;i++) {
    for(int j=0;j<=n;j++) {
        if(j>a[i]) f[j]=(sum_f[j]-sum_f[j-a[i]-1])%mod;
        else f[j]=sum_f[j]; // 分情况处理
    }
    for(int j=1;j<=n;j++) sum_f[j]=(sum_f[j-1]+f[j])%mod; // 更新前缀和
}
```

### 关键思路总结
1. **动态规划优化**：状态定义为`f[j]`表示收集j朵樱花的方案数，通过滚动数组优化空间。
2. **前缀和加速**：预处理前缀和数组`s`，将区间求和优化至O(1)。
3. **及时累加答案**：每棵树处理后累加`f[n]`，因可在任意位置结束。
4. **边界处理**：总樱花数不足时直接输出`impossible`，负数取模需显式调整。

### 拓展应用
- **同类问题**：多重背包问题（如[P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)）。
- **优化技巧**：前缀和优化区间求和、滚动数组降低空间复杂度。

### 推荐习题
1. [P1077 摆花](https://www.luogu.com.cn/problem/P1077)（基础版）
2. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)（多重背包优化）
3. [P6567 买表](https://www.luogu.com.cn/problem/P6567)（动态规划+前缀和）

---
处理用时：89.16秒
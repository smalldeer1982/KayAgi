# 题目信息

# 「EZEC-1」出题

## 题目背景

你是一个毒瘤出题人。

## 题目描述

已知你有 $n$ 道毒瘤题，已经出好了题面，但数据还没出好。你还剩下 $m$ 的时间，每道题的毒瘤程度为 $a_{i}$，出数据的时间是 $x_{i}$，你有 $k$ 个老师，每个老师可以把一道题的毒瘤程度翻倍（每道题目最多被翻倍一次）。你的父母由于坚决反对你出公开赛，抢走了你的一道题，现在老师和父母的行动你都可以控制，但每位老师和父母的行为必须执行，请问你要怎么做，才能使出的题毒瘤程度之和最大？

## 说明/提示

【样例解释】

样例 $1$ ：

你控制你的父母拿走 $T1$ ，然后配 $T2$ 和 $T3$ 的数据，同时将 $T2$ 的毒瘤值翻倍，所以毒瘤值最大是 $15$

------------

【数据范围】

对于 $30\%$ 的数据，$ 0 \le x_{i} \le m $，$0 \le m \le 100 $，$2 \le n \le 10$，$ k<n$。

对于另外 $20\%$ 的数据，保证 $k=0$。

对于 $100\%$ 的数据，$0 \le a_{i} \le 1000$，$ 0 \le x_{i} \le m $，$0 \le m \le 1000 $，$0 \le n \le 100$，$ k<n$。

upd in 2020.7.6：添加一组 hack 数据。

## 样例 #1

### 输入

```
3 10 1
6 9
7 2
1 8```

### 输出

```
15```

## 样例 #2

### 输入

```
5 20 2
5 3 
9 7
2 6
7 8
1 2```

### 输出

```
38```

## 样例 #3

### 输入

```
3 6 2
5 4
3 3
3 3```

### 输出

```
12```

# AI分析结果



### 综合分析与结论
本题核心在于分情况处理背包容量是否足够，结合贪心与动态规划。关键难点在于正确处理老师翻倍次数与背包状态转移的顺序。以下题解通过正确倒序枚举翻倍次数避免重复计算，确保每个物品仅被处理一次，是本题的最优解法。

---

### 精选题解列表

#### 1. 作者：pigstd (★★★★★)
**关键亮点**：  
- 简洁高效的双情况处理框架（贪心+背包）  
- 正确使用倒序枚举翻倍次数避免重复计算  
- 代码结构清晰，关键注释到位  

**核心实现思想**：  
```cpp
for (int e=1;e<=n;e++)
    for (int i=m;i>=x[e];i--) { // 倒序枚举时间
        for (int j=min(k,e);j>=1;j--) // 倒序枚举翻倍次数
            f[i][j] = max(..., f[i-x[e]][j-1]+2*a[e]); 
        f[i][0] = ... // 单独处理0次翻倍
    }
```

#### 2. 作者：xiaozeyu (★★★★☆)
**关键亮点**：  
- 详细解释错误枚举顺序导致的重复计算问题  
- 提供Hack数据验证算法正确性  
- 独立封装贪心与背包处理模块  

**核心代码片段**：  
```cpp
For(num,1,n)
    Rep(i,m,b[num]) { // 时间倒序
        Rep(j,min(k,num),1) { // 翻倍次数倒序
            f[i][j] = max(..., f[i-b[num]][j-1]+2*a[num]);
        }
        f[i][0] = ... 
    }
```

#### 3. 作者：一只书虫仔 (★★★★☆)
**关键亮点**：  
- 清晰的贪心与背包分离处理逻辑  
- 代码中显式注释关键转移步骤  
- 变量命名规范增强可读性  

**核心代码**：  
```cpp
for(re int l=1;l<=n;l++)
    for(re int i=m;i>=v[l];i--) // 时间倒序
        for(re int j=min(l,k);j>=1;j--) // 翻倍次数倒序
            f[i][j] = max(..., f[i-v[l]][j-1]+2*w[l]);
```

---

### 最优关键思路总结
1. **分治策略**：根据总时间是否足够全选，采用贪心（舍弃最小项）或背包（动态规划）。  
2. **状态设计**：`f[i][j]` 表示耗时 `i` 且使用 `j` 次翻倍时的最大值。  
3. **倒序枚举**：在背包转移时，**倒序枚举翻倍次数**，确保每个物品仅被处理一次。  
4. **贪心优化**：全选时直接排序取前 `k` 大项翻倍，时间复杂度从 O(n²) 降为 O(n log n)。  

---

### 同类题目推荐
1. **P1064 金明的预算方案** - 结合附件条件的背包问题（[题目链接](https://www.luogu.com.cn/problem/P1064)）  
2. **P1156 垃圾陷阱** - 时间与状态双重限制的动态规划（[题目链接](https://www.luogu.com.cn/problem/P1156)）  
3. **P1273 有线电视网** - 树形背包与资源分配结合（[题目链接](https://www.luogu.com.cn/problem/P1273)）  

---

### 调试心得摘录
- **xiaozeyu** 提到：“正序枚举翻倍次数会导致同一物品被多次翻倍”，通过构造Hack数据验证了这一点。  
- **pigstd** 在代码中注释“注意倒序枚举”，强调避免状态覆盖的关键点。  
- **auroral** 在评论区补充：“当 `sum<=m` 时忘记排除被偷的项导致WA”，提醒边界条件的重要性。

---
处理用时：63.74秒
# 题目信息

# [CRCI2007-2008] JEDNAKOST

## 题目描述

给定一个形如 `A=B` 的字符串，其中 $A$ 和 $B$ 都是不含前导零的正整数。请给 $A$ 的一些相邻数位之间加上加号，要求添加的加号数量最少，使得等式成立。

在 $A$ 加上加号后，每个加数允许有多个前导 $0$。包括 $0$ 在内。也即允许形如 $000 \ldots$ 的数作为加数。

数据保证有解。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq A \lt 10^{1000}$，$1 \leq B \leq 5 \times 10^3$，$A \neq B$。

#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [Regional Competition](https://hsin.hr/coci/archive/2007_2008/regional_tasks.pdf) *T4 JEDNAKOST***。

## 样例 #1

### 输入

```
143175=120
```

### 输出

```
14+31+75=120```

## 样例 #2

### 输入

```
5025=30
```

### 输出

```
5+025=30```

## 样例 #3

### 输入

```
999899=125
```

### 输出

```
9+9+9+89+9=125```

# AI分析结果



### 综合分析与结论
各题解均采用动态规划（DP）解决，核心思路为状态设计+转移优化，关键差异在于处理前导零和枚举范围的优化。最优解法需结合状态压缩（处理连续零）、有限枚举范围（利用数值指数级增长特性）及路径回溯。

---

### 精选题解（评分≥4星）

#### 1. 青鸟_Blue_Bird（4星）
**关键亮点**：
- 记忆化搜索实现DP，逻辑直观易理解
- 预处理`pre[]`处理连续零，避免无效分割
- 递归输出方案，代码结构清晰  
**核心代码**：
```cpp
int change(int now, int sum){ // 记忆化搜索求最少加号
    if(now == n) return sum == 0 ? 0 : INF;
    int &cur = f[now][sum];
    if(cur != -1) return cur;
    cur = INF;
    int temp = 0;
    for(int j = pre[now]; j < n; j++){ // 按pre处理起点
        temp = temp * 10 + A[j] - '0';
        if(temp > sum) break; // 剪枝
        cur = min(cur, change(j+1, sum - temp) + 1);
    }
    return cur;
}
```

#### 2. 一扶苏一（4星）
**关键亮点**：
- 预处理`mn[]`优化连续零的转移
- 限制枚举位数（k最多前4位），降低复杂度至O(nB)
- 路径记录简洁  
**核心优化逻辑**：
```cpp
for(int k = 0, p = i+1; k < 4; ++k) { // 枚举前4位
    if((--p > 0) && (sum += a[p] * ten[k]) <= j) {
        if(a[p] == 0) {
            int x = mn[p-1][d]; // 取连续零的最小前驱
            if(f[x][d] < f[i][j]) { ... }
        }
    }
}
```

#### 3. abcxyz123（4星）
**关键亮点**：
- 预处理`last[]`数组处理长串零，只枚举前4位
- 动态调整加号计数规则（x≠0时才+1）
- 路径恢复时处理连续零的展开  
**核心代码片段**：
```cpp
if (add[i][j] > add[k - 1][j - x] + (x != 0)) { // x=0不加次数
    pre[i][z][0] = j;
    dp[i][j] = ...;
}
```

---

### 关键思路与技巧总结
1. **状态设计**：`f[i][j]`表示处理到A的第i位时，剩余需要凑出j的最少加号。
2. **零处理优化**：对连续零进行压缩或预处理起点，避免无效分割。
3. **枚举范围限制**：基于数值指数级增长特性，仅需枚举前4-7位即可剪枝。
4. **路径回溯**：通过记录前驱状态，递归构造答案，注意零的展开。

---

### 类似题目推荐
1. [P1049 装箱问题](https://www.luogu.com.cn/problem/P1049)（DP状态压缩）
2. [P1734 最大约数和](https://www.luogu.com.cn/problem/P1734)（预处理+DP优化）
3. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)（路径回溯+状态转移）

---

### 题解中的调试心得摘录
- **青鸟_Blue_Bird**：INF设置不当导致溢出，强调数值边界的重要性。
- **abcxyz123**：连续零处理时的路径恢复陷阱，需判断末尾是否有非零数。
- **unsigned_short_int**：被hack后增加特判，强调极端数据验证的必要性。

---
处理用时：67.00秒
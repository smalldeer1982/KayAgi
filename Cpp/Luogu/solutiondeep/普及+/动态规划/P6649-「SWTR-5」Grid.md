# 题目信息

# 「SWTR-5」Grid

## 题目背景

**赛时提醒：格子可以重复经过，但分数只算一次。**

## 题目描述

小 A 有一个 $n\times m$ 的网格，每个格子上都写着一个数字。为方便描述，令左上角的网格为 $(1,1)$，右下角的网格为 $(n,m)$。

小 A 可以进入最下方第 $n$ 行的任意一个网格，并按照以下规则进行游戏：

- 设小 A **第一次进入第 $i$ 行**的位置为 $(i,r_i)$：  
如果小 A 在 $(i,r_i)$，则他只能向左或向上跳。否则他可以向左，向右或向上跳。
- 小 A 不能跳出网格，除非他在第 $1$ 行，这代表结束整场游戏。

定义一局游戏的得分为所有小 A 经过的格子上的数字之和。小 A 想请你帮他求出得分的最小值。

## 说明/提示

「样例说明」

样例 $1$ 的解释如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/1l4pl5s2.png)

「数据范围与约定」

**本题采用捆绑测试。**

- Subtask 1（3 points）：$a_{i,j}\leq 0$。
- Subtask 2（12 points）：$n,m\leq 5$。
- Subtask 3（15 points）：$n=2$。
- Subtask 4（18 points）：$n,m\leq 90$。
- Subtask 5（22 points）：$n,m\leq 400$。
- Subtask 6（30 points）：无特殊限制。

对于 $100\%$ 的数据：$1\leq n,m\leq 10^3$，$-10^6 \leq a_{i,j}\leq 10^6$。

---

「题目来源」

[Sweet Round 05](https://www.luogu.com.cn/contest/28195) A。  
idea & solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

## 样例 #1

### 输入

```
3 3
-1 -3 2
5 -1 -6
-3 7 -6```

### 输出

```
-17```

## 样例 #2

### 输入

```
3 3
1 2 3
4 5 -6
-7 8 9```

### 输出

```
-2```

## 样例 #3

### 输入

```
4 4
-1 2 -3 3
-7 -8 -9 -10
-7 20 -3 15
-8 7 0 -1```

### 输出

```
-32```

## 样例 #4

### 输入

```
17 17
536854 594409 871941 -388369 465282 -638502 -121382 -481711 -648747 583148 -407200 -756103 225750 685372 -952316 -115958 688880
-248927 927601 -41187 -729045 -902796 -714842 537911 -972691 646275 -968170 811593 -288461 -492905 954416 455549 839671 927565
317945 317920 -182592 -477 239886 747388 -323625 132984 -147642 637483 948110 750134 450272 -689049 862925 -327794 5865
196810 600825 -547716 873435 -389664 882011 -708186 504812 955352 -657431 -963785 -899423 671938 -770932 -428505 204660 -235382
592361 -686010 805643 -168792 871936 -334335 402655 783215 -315411 480760 371553 -87790 -111152 142452 918172 968088 364749
200836 914812 962142 -276470 757612 -369974 955746 -740349 -218873 976129 94337 -853562 69100 -479860 865764 -865684 -782689
-977548 -226536 197351 516125 137800 -391378 -392070 -954935 -399763 284345 -752733 195962 268045 800832 916405 578799 782717
-111876 -384522 785558 -663839 -346670 317823 -902413 -138975 794147 -377010 -370134 925156 333264 -827840 859848 773995 -335011
495949 -158831 446359 962836 -861756 936842 533809 -58318 -462176 561405 -127056 -497496 -636673 -312588 -354065 -489258 926614
603167 -154853 601062 951736 758952 -290610 838384 -455373 -823858 293098 782955 -711867 739231 -835281 -940599 938774 389756
-762794 -788479 -122327 -608246 998569 -70814 -198006 -361373 658973 -811815 -26348 240052 251877 -660298 -390790 558411 -90995
213545 492431 847902 -681087 -721770 -482897 -577178 -400679 712628 -943805 -613025 927604 867612 -753902 -235086 -60571 445511
901422 -769346 -655924 638444 188703 964292 865767 -298677 -245870 643123 -87216 -18374 -115040 -954311 -220506 919822 -183816
-576494 -481376 139875 360147 411997 437956 755645 874372 130352 -770235 -708813 850918 -835413 -426540 62763 722776 767682
-237305 -121638 -273740 518922 -423961 690214 -253799 571892 915095 586784 670083 -764317 14014 -103481 -750401 325979 70672
323842 988625 859616 920791 -749116 -660548 302396 408853 -944605 732263 -38368 223609 -484449 712951 831842 -200066 -965163
-659884 172567 -482821 -666287 42438 -113937 -539200 -57775 -558423 116068 532754 -440321 456398 -216316 293270 771477 583186
```

### 输出

```
-28761600```

# AI分析结果



### 综合分析与结论

本题核心在于通过预处理行内最优路径来优化动态规划转移。所有题解均采用动态规划，但实现方式存在差异。关键技巧在于将行内可重复访问的负收益段通过前缀和预处理，并结合自底向上的递推方式，有效降低时间复杂度至 O(nm)。

---

### 精选题解与亮点分析

#### 1. Miraik（5星）
**关键亮点**：
- 将问题转化为每行选取连续子段，通过滚动数组优化空间至 O(m)
- 巧妙利用前缀和与历史最小值，直接合并行内最优选择到转移方程
- 代码极简（仅13行），时间复杂度 O(nm)

**个人心得**：
> "观前提示：不开 long long 见祖宗" —— 强调数值范围的常见陷阱

**核心代码**：
```cpp
for(int i=1;i<=n;i++,sum=res=0)
    for(int j=1;j<=m;j++)
        scanf("%lld",&x),sum+=x,
        f[j]=min(f[j-1]+x, f[j]+sum-res),
        res=max(sum,res);
```
**思路**：维护 `sum` 为当前行前缀和，`res` 为历史最大前缀和。转移时比较直接继承上一格或从上行转移并合并最优子段。

#### 2. zumgze（5星）
**关键亮点**：
- 预处理行内最优路径（修改原数组存储最小累积值）
- 分情况讨论正负值对转移的影响
- 自底向上的递推顺序确保无后效性

**核心代码**：
```cpp
for(int i=1;i<=n;i++) {
    for(int j=1;j<=m;j++)
        if(a[i][j-1]<0) a[i][j] += a[i][j-1];
}
for(int i=n;i>=1;i--)
    for(int j=m;j>=1;j--) 
        if(a[i][j]<=0) dp[i][j] = min(dp[i][j+1], dp[i+1][j]+a[i][j]);
        else dp[i][j] = min(dp[i][j+1], dp[i+1][j]) + a[i][j];
```
**思路**：预处理每行使其存储包含左侧最优负收益的值，转移时根据正负选择是否将当前行收益与下行合并。

#### 3. Wf_yjqd（4星）
**关键亮点**：
- 使用双数组分别处理右移和下移的最优路径
- 通过分离行内最小子段和计算，保持逻辑清晰
- 空间复杂度 O(nm) 但易于理解

**核心代码**：
```cpp
for(ll j=1;j<=m;j++)
    qzn[j] = min(qzn[j-1], 0ll) + val[i][j];
for(ll j=m;j>=1;j--)
    hzn[j] = min(hzn[j+1], f[i-1][j]) + val[i][j];
```
**思路**：`qzn` 维护行内从左到右的最小子段和，`hzn` 维护从右到左包含下行转移的最优值。

---

### 关键思路总结

1. **行内最优预处理**：通过前缀和计算每格包含左侧可能负收益的最小累积值，将重复访问的优化提前计算
2. **方向性转移**：自底向上、从右至左的遍历顺序确保转移时的子问题已解
3. **状态分离**：区分首次到达行内位置与后续移动的状态，通过预处理消减状态维度
4. **滚动数组优化**：部分题解通过复用数组维度降低空间复杂度

---

### 拓展训练

1. **P1216 数字三角形**（基础DP路径问题）
2. **P1004 方格取数**（双路径DP，状态合并）
3. **P7074 方格取数加强版**（带方向限制的路径DP）

---

### 相似题目推荐

1. **P1736 创意吃鱼法**（二维DP+预处理）
2. **P2380 狗哥采矿**（资源分配型二维DP） 
3. **P1944 最长括号匹配**（区间处理+预处理思想）

---
处理用时：58.78秒
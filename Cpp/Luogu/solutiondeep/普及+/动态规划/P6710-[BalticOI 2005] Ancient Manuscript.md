# 题目信息

# [BalticOI 2005] Ancient Manuscript

## 题目描述

给定 Baltic 字符串的定义为：

- 全部为小写字母
- 最多只能有 $V_C$ 个连续的元音
- 最多只能有 $C_C$ 个连续的辅音
- 最多只能有 $V_E$ 个连续的元音相等
- 最多只能有 $C_E$ 个连续的辅音相等

`aeiou` 为元音，除了这五个字母之外的 21 个字母为辅音。

现在给定一个字符串，一些字符为小写字母一些字符为 `*`，您可以把 `*` 替换成任意一个小写字母。

求通过替换能使得这个字符串得到的不同的 Baltic 字符串的种类数。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \le V_E \le V_C \le 4$，$1 \le C_E \le C_C \le 4$，$1 \le\ $字符串的长度$\ \le 15$。

#### 说明

翻译自 [BalticOI 2005 Day2 A Ancient Manuscript](https://boi.cses.fi/files/boi2005_day2.pdf)。

## 样例 #1

### 输入

```
1 1 1 1
a** ```

### 输出

```
105```

## 样例 #2

### 输入

```
1 1 1 1
b*i ```

### 输出

```
0```

## 样例 #3

### 输入

```
1 2 1 2
ancient ```

### 输出

```
1```

## 样例 #4

### 输入

```
4 4 4 4
man****ipt ```

### 输出

```
261870```

## 样例 #5

### 输入

```
2 2 2 2
*boi* ```

### 输出

```
546```

# AI分析结果



### 综合分析与结论  
本题需要处理多维度限制的动态规划，核心难点在于如何同时维护 **连续相同字符数**、**连续同类字符数** 两个关键约束。两篇题解均采用四维状态设计，通过枚举当前字符和前驱字符的状态进行转移，思路相似，但实现细节略有差异。以下为关键总结：

---

### 高星题解推荐  
#### 1. Echoternity 题解（★★★★☆）  
**关键亮点**：  
- 状态设计清晰：`dp[i][j][k][l]` 表示到第 `i` 位时，连续相同字符数 `j`，同类连续数 `k`，当前字符 `l`。  
- 预处理元音标记数组 `expr`，简化条件判断。  
- 将元音/辅音的类型判断（`flag_s`和`flag_k`）与状态转移条件结合，逻辑层次分明。  

**个人心得**：  
作者提到“暴力不行，考虑 dp”的直觉，强调状态压缩避免冗余维度，体现对动态规划问题核心矛盾（状态空间与转移效率）的深刻理解。

**核心代码思想**：  
```cpp
// 预处理元音标记
bool expr(int b) { return (b==0||b==4||b==8||b==14||b==20); }

// 状态转移核心逻辑
for (当前字符s_now和前驱字符k) {
    bool flag_s = expr(s_now), flag_k = expr(k);
    if (同类) {
        if (s_now == k) -> 更新连续相同计数
        else -> 重置相同计数，延续同类计数
    } else { // 不同类
        -> 重置所有连续计数
    }
}
```

#### 2. Aurora_Borealis_ 题解（★★★☆☆）  
**关键亮点**：  
- 代码结构简洁，直接通过多层循环枚举字符和前驱状态。  
- 使用 `flag` 数组标记元音，与 Echoternity 方案类似。  

**不足**：  
- 变量命名较为随意（如 `iee`），可读性较差。  
- 转移条件的分支处理不够明确，易引发逻辑错误。

---

### 最优思路与技巧提炼  
1. **四维状态设计**：  
   - `dp[pos][same_cnt][type_cnt][char]` 维护位置、连续相同字符数、同类连续数、当前字符。  
   - 通过元音/辅音分类处理两类独立约束（如 `V_C` 和 `C_C`）。  

2. **转移条件分治**：  
   - **相同字符**：继承前驱的连续计数并自增。  
   - **同类不同字符**：重置相同计数，但延续同类计数。  
   - **不同类字符**：完全重置所有计数。  

3. **预处理优化**：  
   - 使用布尔数组快速判断字符是否为元音。  
   - 将输入中的 `*` 映射为通配符（如 `val[i]=26`），简化枚举逻辑。

---

### 相似题目推荐  
1. **P2657 [SCOI2009] windy数**  
   - 涉及数位 DP 和连续数字差值的约束。  
2. **P4124 [CQOI2016] 手机号码**  
   - 多条件限制（连续相同数、特定数字出现次数）的 DP 设计。  
3. **P2167 [SDOI2009] Bill的挑战**  
   - 字符串匹配与动态规划结合，处理通配符替换问题。  

---

### 调试与实现启示  
- **边界处理**：初始状态需单独处理（如第一位为 `*` 时枚举所有可能字符）。  
- **剪枝优化**：在状态转移时，仅处理合法范围的值（如 `j<=C_C`, `k<=V_C`）。  
- **数据类型**：使用 `long long` 避免计数溢出（尤其当 `n=15` 时可能极大）。

---
处理用时：46.55秒
# 题目信息

# 「MCOI-01」Village 村庄

## 题目背景

今天，珂爱善良的0x3喵酱骑着一匹小马来到了一个村庄。

“诶，这个村庄的布局 ……”   
“好像之前我玩 Ciste 的地方啊 qwq”

0x3喵酱有一个地图，地图有着这个村庄的信息。

然后0x3喵酱要通过这张地图来判断 Ciste 有解无解啦 ~

注：Ciste 是《请问您今天要来点兔子吗》中的一种藏宝图游戏

## 题目描述

村庄被简化为一个 $n$ 个节点（编号为 $1$ 到 $n$）和 $n-1$ 条边构成的无向连通图。

0x3喵酱认为这个无向图里的信息跟满足以下条件的新图有关：

- 新图的点集与原图相同
- 在新图中 $u,v$ 之间有无向边 是 在原图中 $dis(u,v) \ge k$ 的**充分必要条件** （$k$ 为给定常量，$dis(u,v)$ 表示编号为 $u$ 的点到编号为 $v$ 的点最短路的长度）

0x3喵酱还认为这个"新图"如果为二分图，则 Ciste "有解"，如果"新图"不是二分图这个 Ciste "无解"。（如果您不知道二分图请翻到提示）

那么0x3喵酱想请您判断一下这个 Ciste 是否"有解"。

## 说明/提示

#### 样例解析

对于样例中的 **第一组** 数据：

原图：

![](https://cdn.luogu.com.cn/upload/image_hosting/9f9zh4b2.png)
新图：

![](https://cdn.luogu.com.cn/upload/image_hosting/dg4es91e.png)

新图不为二分图，故输出 `Baka Chino`。

对于 **第三组** 数据：

原图：

![](https://cdn.luogu.com.cn/upload/image_hosting/mku4v6uo.png)

新图：

![](https://cdn.luogu.com.cn/upload/image_hosting/15o3x3zz.png)

新图为二分图，故输出 `Yes`。

#### 数据规模与约定

**本题采用捆绑测试**。

- Subtask 1（16 pts）$\ $ ：$n \le 10$。
- Subtask 2（24 pts）$\ $ ：$n \le 100$。
- Subtask 3（8 pts）$\ $ ：$n \le 1000$。
- Subtask 4（28 pts）：图退化成一条链。
- Subtask 5（24 pts）：无特殊限制。

对于 $100\%$ 的数据，$n \le 10^5$，$T \le 10$，$v \le 1000$，$k \le 1000000$。

本题数据使用 [CYaRon](https://www.luogu.org/discuss/show?postid=11410) 生成。

#### 提示


**二分图** 又称作二部图，是图论中的一种特殊模型。设 $G=(V,E)$ 是一个无向图，如果顶点 $V$ 可分割为两个互不相交的子集 $(A,B)$，并且图中的每条边 $(i,j)$ 所关联的两个顶点 $i$ 和 $j$ 分别属于这两个不同的顶点集 $(i \in A,j \in B)$，则称图 $G$ 为一个二分图。（摘自[百度百科](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE/9089095?fr=aladdin)）

#### 说明

Minecraft OI Round 1 A

- Idea：0x3喵酱
- Solution/Std：0x3喵酱
- Data：0x3喵酱
- Tester：tarjin

## 样例 #1

### 输入

```
5
5 2
1 2 1
2 3 1
3 4 1
4 5 1
5 3
1 2 1
2 3 1
3 4 1
4 5 1
5 8
1 3 3
1 2 1
2 4 6
2 5 2
5 2
1 3 3
1 2 1
2 4 6
2 5 2
7 4
1 2 3
1 3 3
2 5 3
2 6 3
3 7 3
2 4 2```

### 输出

```
Baka Chino
Yes
Yes
Baka Chino
Baka Chino```

# AI分析结果



### 综合分析与结论
题目要求判断新图（原树中距离≥k的点相连）是否为二分图。关键点在于新图是否存在奇环，最优解法基于树的直径的性质：若存在奇环，则必有至少一个点同时满足到直径两端点的距离≥k，形成三元环。通过两次DFS求直径并检查各点到两端的距离即可高效解决。

---

### 精选题解与评分

#### 1. **一只书虫仔（官方题解）** ⭐⭐⭐⭐⭐  
**关键亮点**：  
- 两次DFS求树的直径，简洁高效。  
- 遍历所有点检查到两端点的距离，时间复杂度O(n)。  
- 正确性基于严谨的数学证明，确保无遗漏情况。  

**代码核心**：  
```cpp
int main() {
    // ... 读取数据 ...
    dfs(1,0,dis1); x=1; // 第一次DFS找直径端点x
    for(i=2;i<=n;i++) if(dis1[i]>dis1[x]) x=i;
    dfs(x,0,dis1); y=x; // 第二次DFS找直径另一端y
    for(i=1;i<=n;i++) if(dis1[i]>dis1[y]) y=i;
    dfs(y,0,dis2); // 计算各点到y的距离
    // 检查是否存在点同时满足到x和y的距离≥k
    for(i=1;i<=n;i++) if(dis1[i]>=k && dis2[i]>=k) flag=0;
    // 输出结果...
}
```

#### 2. **青鸟_Blue_Bird** ⭐⭐⭐⭐  
**关键亮点**：  
- 详细补充了官方题解的数学证明，帮助理解正确性。  
- 代码与官方思路一致，结构清晰，注释详细。  

**个人心得**：  
- 强调通过画图理解数学归纳过程，避免抽象逻辑的混淆。  
- 提醒注意多组数据时的初始化问题，避免WA。  

#### 3. **HPXXZYY** ⭐⭐⭐⭐  
**关键亮点**：  
- 使用BFS替代DFS求直径，避免递归栈溢出风险。  
- 代码结构简洁，变量命名清晰，适合快速实现。  

---

### 关键思路总结
1. **树的直径**：通过两次DFS/BFS找到最长路径的两个端点。  
2. **距离检查**：计算所有点到两端点的距离，若存在点满足两者均≥k，则新图存在奇环。  

---

### 相似题目推荐
1. **P1099 树网的核**：利用直径性质确定最优路径。  
2. **P5536 【XR-3】核心城市**：树的直径与中点的应用。  
3. **P4381 [IOI2008] Island**：处理基环树与最长路径问题。  

---

### 核心代码实现（官方题解）
```cpp
void dfs(int i, int fa, int* dis) {
    for (int p = V[i].eh; p; p = E[p].next) {
        if (E[p].to == fa) continue;
        dis[E[p].to] = dis[i] + E[p].v;
        dfs(E[p].to, i, dis);
    }
}

int main() {
    // 读取数据后处理
    dfs(1, 0, dis1); // 第一次DFS找直径端点x
    dfs(x, 0, dis1); // 第二次DFS找另一端y
    dfs(y, 0, dis2); // 计算各点到y的距离
    // 遍历检查是否存在点同时满足dis1[i]>=k && dis2[i]>=k
}
```

---
处理用时：67.53秒
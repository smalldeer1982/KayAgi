# 题目信息

# [CSP-J2020] 方格取数

## 题目描述

设有 $n \times m$ 的方格图，每个方格中都有一个整数。现有一只小熊，想从图的左上角走到右下角，每一步只能向上、向下或向右走一格，并且不能重复经过已经走过的方格，也不能走出边界。小熊会取走所有经过的方格中的整数，求它能取到的整数之和的最大值。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/sq4638pa.png)
---

### 样例 2 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/7tfdyabk.png)
---

### 数据规模与约定
- 对于 $20\%$ 的数据，$n, m \le 5$。
- 对于 $40\%$ 的数据，$n, m \le 50$。
- 对于 $70\%$ 的数据，$n, m \le 300$。
- 对于 $100\%$ 的数据，$1 \le n,m \le 10^3$。方格中整数的绝对值不超过 $10^4$。



------------
2024/2/4 添加一组 hack 数据。

## 样例 #1

### 输入

```
3 4
1 -1 3 2
2 -1 4 -1
-2 2 -3 -1
```

### 输出

```
9```

## 样例 #2

### 输入

```
2 5
-1 -1 -3 -2 -7
-2 -1 -4 -1 -2
```

### 输出

```
-10```

# AI分析结果



### 综合分析与结论
题目要求从矩阵左上角到右下角，方向限制为右、上、下，求最大路径和。核心难点在于处理上下移动带来的后效性。各题解主要采用动态规划，通过状态设计解决方向限制：

1. **状态设计**：多数题解引入方向维度（如从上/下/右转移）避免路径重复。
2. **转移优化**：按列处理+预处理前缀/后缀极值，将复杂度优化至O(nm)。
3. **实现技巧**：记忆化搜索简化逻辑，滚动数组优化空间。

---

### 高星题解推荐

#### 1. Dry_ice（★★★★★）
**关键亮点**：
- 记忆化搜索实现直观，状态定义清晰（`f[i][j][0/1]`表示来自上下方向）。
- 预处理极值避免重复计算，代码简洁高效。
- 正确处理初始化与边界条件（如`min_ll`初始值）。

**核心代码**：
```cpp
LL dfs(int x, int y, int from) {
    if (f[x][y][from] != min_ll) return f[x][y][from];
    if (from == 0) 
        f[x][y][from] = mx(dfs(x+1,y,0), dfs(x,y-1,0), dfs(x,y-1,1)) + w[x][y];
    else 
        f[x][y][from] = mx(dfs(x-1,y,1), dfs(x,y-1,0), dfs(x,y-1,1)) + w[x][y];
    return f[x][y][from];
}
```

#### 2. vectorwyx（★★★★☆）
**关键亮点**：
- 按列转移+前缀和优化，预处理`pre`和`suf`数组实现O(1)转移。
- 行列颠倒处理简化表达式，代码结构清晰。
- 复杂度严格O(nm)，适合大规模数据。

**核心思想**：
```cpp
for (int j=2; j<=m; j++) {
    // 预处理pre和suf
    for (int i=1; i<=n; i++) 
        pre[i] = max(pre[i-1], dp[i][j-1] + S[i][j]);
    for (int i=n; i>=1; i--)
        suf[i] = max(suf[i+1], dp[i][j-1] - S[i][j]);
    // 计算当前列dp
    for (int i=1; i<=n; i++)
        dp[i][j] = max(pre[i] + S[i][j], suf[i] - S[i][j-1]) + a[i][j];
}
```

#### 3. CrTsIr400（★★★★★）
**关键亮点**：
- 严格证明无后效性，确保DP正确性。
- 状态压缩（`f[i][j][0/1]`）实现高效递推。
- 代码简洁，循环顺序设计巧妙（先正序再逆序）。

**核心代码**：
```cpp
for (int j=2; j<=m; j++) {
    for (int i=1; i<=n; i++) // 从右转移
        f[i][j][0] = max(f[i][j-1][0], f[i][j-1][1]) + a[i][j];
    for (int i=2; i<=n; i++) // 向下转移
        f[i][j][0] = max(f[i][j][0], f[i-1][j][0] + a[i][j]);
    for (int i=n-1; i>=1; i--) // 向上转移
        f[i][j][1] = max(f[i][j][1], f[i+1][j][1] + a[i][j]);
}
```

---

### 关键思路与技巧
1. **状态设计**：引入方向维度（如上/下/右）消除后效性。
2. **列转移优化**：按列处理，结合前缀/后缀极值预处理，避免重复计算。
3. **记忆化搜索**：简化复杂状态转移逻辑，避免手动处理循环顺序。
4. **滚动数组**：部分题解（如WanderingTrader）使用滚动数组将空间复杂度优化至O(n)。

---

### 个人心得摘录
- **数据类型**：`Plozia`强调开`long long`避免溢出（"int一时爽，溢出火葬场"）。
- **初始化**：`qhr2023`提到特殊位置需赋极小值（如`-inf`）。
- **方向顺序**：`CrTsIr400`指出循环需正序处理向下、逆序处理向上。

---

### 相似题目推荐
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)  
   - 双向路径DP，状态设计技巧。
2. [P7072 直播获奖](https://www.luogu.com.cn/problem/P7072)  
   - 动态维护极值，类似预处理思想。
3. [P1434 滑雪](https://www.luogu.com.cn/problem/P1434)  
   - 记忆化搜索经典题，方向处理与状态回溯。

---
处理用时：58.79秒
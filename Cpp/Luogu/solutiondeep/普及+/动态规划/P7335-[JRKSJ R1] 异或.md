# 题目信息

# [JRKSJ R1] 异或

## 题目描述

给你 $n,k$ 和序列 $a_{1,2\dots n}$，选出 $k$ 个**不交**区间 $[l_i,r_i]\subseteq[1,n]$，求出
$$\max_{l_i,r_i}\sum_{i=1}^k\bigoplus_{j=l_i}^{r_i}a_j$$

式中 $\oplus$ 表示二进制异或运算。

**保证数据随机。**

## 说明/提示

对于 $100\%$ 的数据，$1\le k\le n\le 3000$，$0\le a_i\le 10^{9}$。**保证数据随机。**

本题采用捆绑测试。

| $\text{Subtask}$ | $n\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $30$ | $k\le3$ | $5$ |
| $2$ | $500$ | $a_i\le10^7$|  $10$ |
| $3$ | $1000$ | 无 |  $10$ |
| $4$ | $1500$ | 无 |  $15$ |
| $5$ | $2000$ | 无 |  $15$ |
| $6$ | $2500$ | 无 | $20$ |
| $7$ | $3000$ |  无|  $25$ |
#### 样例 1 解释
序列的三个区间分别为:
$$2,1,[3,4],[4],[4]$$
所得的三个区间的异或和之和为 $7+4+4=15$.

## 样例 #1

### 输入

```
6 3
2 1 3 4 4 4```

### 输出

```
15```

## 样例 #2

### 输入

```
7 2
3 4 5 6 7 8 9```

### 输出

```
24```

# AI分析结果



### 综合分析与结论
本题核心在于动态规划结合最大异或对的快速计算。各题解的核心思路均围绕预处理区间的最大异或值，并利用数据随机性压缩状态转移。最优解法通过前缀异或和转化为最大异或对问题，结合 Trie 结构优化计算，同时利用动态规划的分段压缩和滚动数组优化时空复杂度。

---

### 高分题解推荐
#### 1. 题解作者：cyffff（★★★★★）
**关键亮点**  
- 使用 01-Trie 高效预处理区间最大异或值，时间复杂度稳定。  
- 提出分段压缩思想，利用数据随机性减少转移次数，复杂度降为 $O(nk \log n)$。  
- 滚动数组优化空间，代码结构清晰。  
**核心实现**  
预处理 `ans` 数组存储每个起点的分段最大值，动态规划时枚举分段进行转移。  
```cpp
struct array{ // 压缩分段的结构
    line s[100]; int len;
    void insert(int x,int v){
        if(v==s[len].val) s[len].r=x;
        else s[++len] = line(x,x,v);
    }
};
void init(){ // 预处理每个i的ans数组
    for(int i=0;i<=n;i++){
        t.clear(); t.insert(a[i]);
        for(int j=i+1;j<=n;j++){
            int now = t.find(a[j]);
            ans[i].insert(j, max(ans[i].top(), now));
            t.insert(a[j]);
        }
    }
}
```

#### 2. 题解作者：hegm（★★★★☆）
**关键亮点**  
- 直接暴力预处理 `mx` 数组，代码简洁直观。  
- 动态规划时利用 `mx` 的分段特性优化，逻辑清晰易懂。  
- 滚动数组优化空间，适合快速实现。  
**核心实现**  
预处理 `mx` 数组并分段，动态规划时枚举每个分段的最优值。  
```cpp
for(int i=1;i<=n;i++){
    for(int j=i-1,p=0;j>=0;j--){
        p = max(p, a[i]^a[j]);
        mx[j][i] = max(mx[j][i-1], p);
    }
}
for(int j=1;j<=k;j++){ // 滚动数组转移
    for(int i=1;i<=n;i++){
        for(auto seg : v[i]) 
            f[i][j%2] = max(f[i][j%2], f[seg.r-1][(j-1)%2] + seg.w);
    }
}
```

---

### 最优关键思路总结
1. **前缀异或转换**：将区间异或和转化为两前缀异或值的异或，即 $p_r \oplus p_{l-1}$。  
2. **最大异对快速计算**：使用 01-Trie 或暴力预处理，高效计算区间内的最大异或值。  
3. **分段压缩优化**：利用数据随机性，将连续相同最大值的区间压缩为分段，减少动态规划转移次数。  
4. **滚动数组优化**：通过滚动数组降低空间复杂度至 $O(n)$，避免 $O(nk)$ 空间爆炸。  

---

### 拓展与相似题目推荐
1. **最大异或对**：  
   - [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)  
   - [P3295 [SCOI2016]萌萌哒](https://www.luogu.com.cn/problem/P3295)  
2. **分段动态规划**：  
   - [P1437 [HNOI2004]敲砖块](https://www.luogu.com.cn/problem/P1437)  
   - [P2577 [ZJOI2005]午餐](https://www.luogu.com.cn/problem/P2577)  

---

### 调试心得摘录
- **cyffff**：  
  > 发现 `i` 固定时 `f[i,k]` 不同值很少，于是分段压缩。由于数据随机，期望段数为 $O(\log n)$。  
- **hegm**：  
  > 暴力打表观察 `mx` 的分段特性，验证了分段优化的正确性。  
- **xiao7_Mr_10_**：  
  > 预处理 `g` 数组时，注意倒序枚举以复用之前的结果，减少重复计算。  

这些经验强调对数据特性的观察和预处理优化的重要性。

---
处理用时：63.41秒
# 题目信息

# [BalticOI 2006] JUMP THE BOARD! (Day 2)

## 题目描述

一个 $n×n$ 的游戏板是由整数填充的，每格一个非负整数。目标是从左上角以任何合法路径跳到右下角。任何一格中的整数表示跳离该位置的步长。如果步长将推进越出游戏板，那么在那个特定的方向上的跳步是禁止的。所有的跳步必须是向右或向下。请注意，$0$ 是一个死胡同，它阻止任何进一步的进展。  
如图 $1$ 中所示的 $4×4$ 板，实圆标识起始位置，虚线圆标识目标位置。图 $2$ 展示了从起点位置到目标位置的三条合法路径，每个路径中都删除了不相关的数字。  
![TuLi](https://cdn.luogu.com.cn/upload/image_hosting/0ql0hhx0.png)  
你的任务是编写一个程序来确定从左上角到右下角的合法路径的数量。

## 说明/提示

#### 数据规模与约定  
- 对于 $100 \%$ 的数据， $4 \le n \le 100$。  
- 合法路径的数量可能相当大。使用 $64$ 位整数变量（C 中的 `long long int`，Pascal 中的 `Int64`）只能获得 $70 \%$ 的分数。可以保证所有的输入导致的路径数可以用不超过 $100$ 位的数字写出。

#### 题目说明  
来源于 [Baltic Olympiad in Informatics 2006](https://www.cs.helsinki.fi/group/boi2006/) 的 [Day 2:Jump](https://www.cs.helsinki.fi/group/boi2006/tasks/jump.pdf)。  
由 @[求学的企鹅](/user/271784) 翻译整理。

## 样例 #1

### 输入

```
4
2 3 3 1
1 2 1 3
1 2 3 1
3 1 1 0```

### 输出

```
3```

# AI分析结果



### 综合分析与结论  
本题核心为动态规划（DP）+高精度处理。所有题解均采用 DP 思路，状态转移为从当前格向下或向右跳步，难点在于路径数可能极大，需用高精度存储。Python 实现因自带大数支持更简洁，C++ 需手写高精度结构。题解质量差异主要体现在代码可读性、高精度实现优化程度及边界处理（如 `a[i][j]=0` 时的跳过逻辑）。

---

### 高评分题解推荐  
#### 1. 作者：Naro_Ahgnay（★★★★★）  
**关键亮点**  
- **Python 简化高精度**：直接利用 Python 的无限整数特性，避免手写高精度代码。  
- **代码极简**：仅需 20 行，清晰体现 DP 核心逻辑。  
- **边界处理**：显式将终点 `g[n][n]` 设为 1，避免死循环。  

**核心代码**  
```python
dp = [[0]*110 for _ in range(110)]
dp[1][1] = 1
for i in range(1, n+1):
    for j in range(1, n+1):
        step = g[i][j]
        if i + step <= n:
            dp[i+step][j] += dp[i][j]
        if j + step <= n:
            dp[i][j+step] += dp[i][j]
print(dp[n][n])
```

---

#### 2. 作者：Unordered_OIer（★★★★☆）  
**关键亮点**  
- **高精度结构封装**：定义 `Huge` 类支持加法运算，代码模块化。  
- **压位优化**：使用 `1e9` 进制减少数组长度，提高运算效率。  
- **边界特判**：在输入后强制设置 `g[n][n]=1`，确保终点可达。  

**核心代码**  
```cpp
struct Huge {
    ll s[105], len;
    Huge operator+(Huge a) { // 压位加法
        Huge c; c.len = max(len, a.len);
        for (int i=1; i<=c.len; i++) {
            c.s[i] += s[i] + a.s[i];
            if (c.s[i] >= mod) c.s[i]-=mod, c.s[i+1]++;
        }
        if (c.s[c.len+1]) c.len++;
        return c;
    }
};
Huge f[N][N]; // DP 数组
```

---

#### 3. 作者：linyinuo2008（★★★★☆）  
**关键亮点**  
- **链式高精度存储**：用结构体 `Bigint` 的数组逐位存储，直观易调试。  
- **零值跳过逻辑**：在 DP 循环中跳过 `a[i][j]=0` 的格子，避免无效计算。  
- **代码注释完整**：包含初始化、加法、输出等模块的详细说明。  

**核心代码**  
```cpp
struct Bigint {
    int x[105], len;
    Bigint operator+(const Bigint &B) const {
        Bigint c; c.len = max(len, B.len);
        for (int i=1; i<=c.len; i++) {
            c.x[i] += x[i] + B.x[i];
            if (c.x[i] >= 10) c.x[i]-=10, c.x[i+1]++;
        }
        if (c.x[c.len+1]) c.len++;
        return c;
    }
};
```

---

### 关键思路与技巧总结  
1. **DP 状态设计**：`dp[i][j]` 表示到达 `(i,j)` 的路径数，转移时考虑向下/向右跳步。  
2. **高精度优化**：  
   - **压位存储**：如使用 `1e9` 进制减少运算次数（Unordered_OIer）。  
   - **链式加法**：逐位处理进位，适合教学展示（linyinuo2008）。  
3. **边界处理**：  
   - 终点强制设为可跳步（`g[n][n]=1`）。  
   - 跳过 `a[i][j]=0` 的格子，避免死循环。  

---

### 同类题目推荐  
1. **P1255 数楼梯**（高精度递推）  
2. **P1005 矩阵取数游戏**（DP + 高精度 + 区间决策）  
3. **P2437 蜜蜂路线**（递推路径数 + 大数输出）  

---

### 个人心得摘录  
1. **free_fall 的调试经历**：  
   > *“一开始没注意高精度，导致 70 分，后来补上高精模板。特判 `a[i][j]=0` 防止原地蹦迪”*  
   **总结**：审题时需注意数据范围提示，及时切换高精度思路。  

2. **Danno0v0 的实现技巧**：  
   > *“用三维数组 `dp[x][y][digit]` 存储每一位数字，输出时逆序遍历”*  
   **总结**：原始但有效的高精度实现方式，适合理解底层逻辑。

---
处理用时：67.38秒
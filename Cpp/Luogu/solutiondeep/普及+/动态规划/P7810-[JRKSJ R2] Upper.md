# 题目信息

# [JRKSJ R2] Upper

## 题目描述

有 $n$ 张扑克，第 $i$ 张扑克上写有一个正整数 $a_i$。

现在要把扑克划分成若干个合法的连续子段，其中，一个连续子段 $[l,r]$ “合法”当且仅当这个子段同时满足两个条件： 

* $a_l< a_r$
* $\gcd(a_l,a_r)>1$ 

请问最多能划分多少段。如果没有合法的划分方案，输出 $-1$ 即可。

如果您不知道 $\gcd$ 是什么意思，请看“提示”部分。

## 说明/提示

### 数据范围
本题采用捆绑测试。

对于 $100\%$ 的数据，$2\le n\le 10^5$，$1\le a_i\le 10^9$。

| $\text{Subtask}$ | $n\le$ | $a_i\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $5$ | $10^9$ | 无 | $5$ |
| $2$ | $3\times10^3$ | $10^9$ | 无 | $15$ |
| $3$ | $2\times10^4$ | $10^6$ | 无 | $20$ |
| $4$ | $2\times 10^4$ | $10^9$ | 无 | $10$ |
| $5$ | $10^5$ | $10^9$ | 数据随机 | $10$ |
| $6$ | $10^5$ | $10^9$ | 无 | $40$ |

### 样例解释
对于样例 $1$，有且仅有一种划分方案 $\{2,1,8\},\{3,9\}$。\
对于样例 $2$，无合法的划分方案。

### 提示
对于两个正整数 $a,b$，$\gcd(a,b)$ 为它们的最大公因数，即满足既是 $a$ 的因数又是 $b$ 的因数的数中最大的数。

## 样例 #1

### 输入

```
5
2 1 8 3 9```

### 输出

```
2```

## 样例 #2

### 输入

```
5
5 4 3 2 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
20
20 9 36 36 40 8 3 10 9 20 18 12 30 20 30 15 8 9 27 45```

### 输出

```
7```

# AI分析结果



### 综合分析与结论
本题核心在于动态规划与质因数分解的结合，通过维护每个质因子对应的权值线段树实现高效转移。各题解均围绕质因子分解+数据结构优化展开，线段树方案在时间效率上最优，cdq分治方案在大数据下可能不够高效。最优解法时间复杂度为 $O(n\omega(V)\log n)$，其中 $\omega(V)$ 为值域质因子数。

---

### 高星题解推荐

#### 1. 题解作者：KazamaRuri（★★★★★）
**关键亮点**：
- 首创质因数分解+权值线段树方案，代码简洁高效
- 预处理质数加速分解，离散化压缩空间
- 动态开点线段树避免空间浪费
- 提供分解质因数的优化写法（跳偶数试除）

**核心代码思想**：
```cpp
// 质因数分解后维护线段树
for(int i=1;i<=n;i++)
    for(auto x:q[i]){ // 枚举每个质因子
        if(rt[x]) f[i]=max(f[i],ask(rt[x],1,n,a[i]-1)+1);
        if(f[i-1]>=0) upd(rt[x],1,n,a[i],f[i-1]);
    }
```

#### 2. 题解作者：ZillionX（★★★★★）
**关键亮点**：
- 精确除法优化质因数分解（Exact Division）
- 哈希映射动态管理质因子线段树
- 离散化处理权值压缩查询范围
- 代码实现极致优化（当前最优解）

**核心代码片段**：
```cpp
// 使用精确除法加速质因数分解
ui inv32(ui n) { // 预计算逆元加速除法判断
    ui x(1);
    x*=2u-n*x,x*=2u-n*x,x*=2u-n*x,x*=2u-n*x,x*=2u-n*x;
    return x;
}
void sep(int x) { // 优化后的质因数分解
    if(x%2==0) add_factor(2);
    for(int j=3; j*j<=x; j+=2)
        if(x * inv32(j) <= pm[j]) // 快速判断整除
            add_factor(j);
}
```

#### 3. 题解作者：Spasmodic（★★★★☆）
**关键亮点**：
- 动态开点线段树的完整实现
- 使用 unordered_map 管理质因子根节点
- 预处理质数加速分解
- 代码结构清晰易扩展

**核心思路**：
```cpp
// 对每个质因子维护线段树
for(int p : pr[i]) {
    int root = rt[p];
    f[i] = max(f[i], query(root, 1, m, a[i]-1) + 1);
    update(root, 1, m, a[i], f[i-1]);
    rt[p] = root;
}
```

---

### 关键思路总结
1. **质因数分解预处理**：预处理 $\sqrt{V}$ 内质数，试除法分解时只需遍历质数列表。
2. **动态权值线段树**：为每个质因子维护线段树，存储该质数对应的所有数的 $f$ 值。
3. **离散化压缩值域**：将 $a_i$ 离散化后，线段树维护离散化后的值域。
4. **转移优化**：查询时只需在 $a_i$ 的质因子对应线段树中查询 $[1,a_i-1]$ 区间最大值。

---

### 扩展与相似题目
1. **P2158 [SDOI2008] 仪仗队**（质因数分解与欧拉函数应用）
2. **P3659 [USACO17FEB]Why Did the Cow Cross the Road I G**（动态规划+条件转移优化）
3. **P3899 [湖南集训] 更为厉害**（复杂条件动态规划+数据结构优化）

---
处理用时：61.05秒
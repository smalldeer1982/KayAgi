# 题目信息

# 「RdOI R3」学习算法

## 题目背景

暑假中，MLE 决定学习一下 OI 算法。


## 题目描述

暑假一共有 $n$ 天，我们假设 MLE 每天都有足够的时间学 OI。MLE 列出了可供选择的 $m$ 个算法。MLE 每天只能且必须学习一个算法。

而且，MLE 长时间学同一种算法会厌倦，所以每一种算法不能连续学习太多天，第 $i$ 种算法最多可以连续学习 $a_i$ 天。**MLE 没有必要学习全部的算法。**

MLE 想知道，自己有多少种不同的学习安排来度过这 $n$ 天。两种学习安排不同仅当这两种安排中有至少一天学习的算法不同。因为方法可能过多，你只需要输出方案数对 $10^9+7$ 取模即可。

## 说明/提示

### 样例解释

#### 样例 \#1

第一种算法最多连续学习一天，第二种最多连续学习两天。故共有如下四种学习方式：

- $1,2,2$。
- $2,1,2$。
- $2,2,1$。
- $1,2,1$。

#### 样例 \#2

由于唯一的一种算法最多只能连续学习一天，所以没有合法的方案可以度过 $2$ 天。

---

### 数据范围

**本题采用捆绑测试，若无特殊说明，测试点的内存限制为 256MB。**

对于所有数据，$1\le a_i \le n\le 7 \times 10^3$，$1\le m \le 7\times 10^3$。

| subtask | 分值 | $n,m\le$ | 特殊限制            |
| ------- | ---- | -------- | ------------------- |
| $1$     | $5$  | $5$      | 无                 |
| $2$     | $10$ | $100$    | 无                 |
| $3$     | $15$ | $500$    | 无                 |
| $4$     | $20$ | $7\times 10^3$   | $a_i=1$             |
| $5$     | $20$ | $7\times 10^3$   | 内存限制为 $500$ MB |
| $6$     | $30$ | $7\times 10^3$   | 无                 |

## 样例 #1

### 输入

```
3 2
1 2```

### 输出

```
4```

## 样例 #2

### 输入

```
2 1
1```

### 输出

```
0```

## 样例 #3

### 输入

```
8 5
4 2 3 4 2```

### 输出

```
356314```

# AI分析结果



### 综合分析与结论
本题需在O(nm)复杂度下处理动态规划状态转移，核心难点在于处理连续学习限制。各题解均采用动态规划，通过维护前缀和优化转移过程。关键优化点是将非法方案转化为前缀和的差值计算，有效降低时间复杂度。

---

### 精选题解

#### 1. 作者：SfumatoCannon_（★★★★★）
**关键亮点**：
- 状态转移方程简洁直观，利用sum数组快速计算总方案数
- 处理非法方案时巧妙转化为前缀和差值
- 代码结构清晰，包含必要特判（如m=1的边界情况）

**核心代码**：
```cpp
for (i = 2; i <= n; i++) {
    for (j = 1; j <= m; j++) {
        dp[i][j] = sum[i - 1];
        if (i > a[j]) {
            if (i == a[j] + 1)
                dp[i][j] = (dp[i][j] - 1 + MODNUM) % MODNUM;
            else
                dp[i][j] = (dp[i][j] - (sum[i - a[j] - 1] - dp[i - a[j] - 1][j]) + MODNUM) % MODNUM;
        }
    }
    sum[i] = (sum[i] + dp[i][j]) % MODNUM; // 更新前缀和
}
```

#### 2. 作者：徐天乾（★★★★☆）
**关键亮点**：
- 独立发现与AT685题的相似思路
- 使用辅助数组e记录总和，代码更简洁
- 明确注释关键优化步骤

**核心代码**：
```cpp
for (i=2; i<=n; i++){
    for (j=1;j<=m;j++) {
        f[i][j] = e[i-1];
        if (i>a[j]) 
            f[i][j] = (f[i][j] - e[i-a[j]-1] + f[i-a[j]-1][j] + MOD) % MOD;
    }
    e[i] = (e[i] + f[i][j]) % MOD; // 实时更新总和
}
```

#### 3. 作者：yzy1（★★★★☆）
**关键亮点**：
- 分阶段优化思路清晰，展示算法演进过程
- 最终解法引入滚动数组优化空间
- 数学推导完整，给出g和h数组的递推关系

**核心思路**：
```cpp
g[i][c] = g[i-1][c] + f[i-1][c] - f[i-a_c-1][c];
h[i] = Σg[i][j];
f[i][c] = h[i] - g[i][c]; // 利用总和快速计算
```

---

### 关键思路总结
1. **前缀和优化**：维护sum数组记录总方案数，将O(m)求和降为O(1)
2. **非法方案计算**：通过`sum[i-a_j-1] - dp[i-a_j-1][j]`快速获取连续超限的方案数
3. **滚动数组**：对于空间敏感的subtask，使用位运算压缩存储维度

---

### 相似题目推荐
1. [P1357 花园](https://www.luogu.com.cn/problem/P1357) - 环形排列与连续限制
2. [AT685 オレンジとりんご](https://www.luogu.com.cn/problem/AT685) - 相同连续选择模型
3. [CF118D Caesar's Legions](https://codeforces.com/problemset/problem/118/D) - 双限制连续选择问题

---

### 调试经验摘录
- **SfumatoCannon_**: "注意当i-a_j-1可能为负数时的处理，需增加判断避免越界"
- **徐天乾**: "发现转移式与AT685高度相似，说明这类连续限制问题有通用解法"
- **篮网总冠军**: "开long long导致MLE，改用int后通过，注意模运算特性"

---
处理用时：59.71秒
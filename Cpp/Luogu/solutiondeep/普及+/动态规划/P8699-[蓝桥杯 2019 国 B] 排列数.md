# 题目信息

# [蓝桥杯 2019 国 B] 排列数

## 题目描述

在一个排列中，一个折点是指排列中的一个元素，它同时小于两边的元素，或者同时大于两边的元素。

对于一个 $1 ∼ n$ 的排列，如果可以将这个排列中包含 $t$ 个折点，则它称为一个 $t + 1$ 单调排列。

例如，排列 $(1, 4, 2, 3)$ 是一个 $3$ 单调排列，其中 $4$ 和 $2$ 都是折点。

给定 $n$ 和 $k$，请问 $1 ∼ n$ 的所有排列中有多少个 $k$ 单调排列？


## 说明/提示

对于 $20 \%$ 的评测用例, $1 \leq k \leq n \leq 10$;

对于 $40 \%$ 的评测用例, $1 \leq k \leq n \leq 20$; 对于 $60 \%$ 的评测用例, $1 \leq k \leq n \leq 100$;

对于所有评测用例， $1 \leq k \leq n \leq 500$ 。 


蓝桥杯 2019 年国赛 B 组 G 题。

## 样例 #1

### 输入

```
4 2
```

### 输出

```
12
```

# AI分析结果



### 综合分析与结论
本题需统计具有特定折点数的排列数目，核心解法为动态规划。各题解均采用状态转移思路，通过插入最大值分析折点变化。关键点在于正确推导状态转移方程及处理边界条件。最优解法通过三维简化至二维，利用插入位置的三种情况转移，时间复杂度为O(n²)。

---

### 精选题解

#### 1. DreamLand_zcb（★★★★☆）
**关键亮点**：  
- 状态定义清晰（`dp[i][j]` 表示前i个数j个折点的方案数）。  
- 详细图解辅助理解插入位置的三种情况（不增、增1、增2折点）。  
- 代码简洁高效，正确处理初始状态与转移。  
**个人心得**：  
> "当j为奇数时，波峰数计算方式不同，但最终转移系数统一为j+1，简化了代码。"  

**核心代码**：  
```cpp
dp[1][0] = 1;
for(int i=2; i<n; i++) {
    dp[i][0] = 2;
    for(int j=0; j<=i; j++) {
        dp[i+1][j]   = (dp[i+1][j] + dp[i][j]*(j+1)) % MOD;
        dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]*2) % MOD;
        dp[i+1][j+2] = (dp[i+1][j+2] + dp[i][j]*(i-j-2)) % MOD;
    }
}
```
**实现思想**：  
- 初始化`dp[1][0]=1`，表示单个元素无折点。  
- 每插入一个新元素，根据位置更新三种折点变化情况，模运算避免溢出。  

---

### 关键思路与技巧
1. **状态设计优化**：原需记录起始方向（上升/下降），后通过数学推导发现转移对称性，省去冗余维度。
2. **插入法分析**：每次插入当前最大值，利用其必然成为峰/谷的特性，简化折点变化分析。
3. **边界处理**：对短序列（如i=1,2）单独处理，确保初始状态正确。

---

### 拓展与举一反三
- **同类问题**：类似波动序列问题（如“地精部落”）、带有特定模式的排列计数。
- **推荐题目**：  
  1. [P2467 地精部落](https://www.luogu.com.cn/problem/P2467)（波动序列计数）  
  2. [P2401 不等数列](https://www.luogu.com.cn/problem/P2401)（不等式约束排列）  
  3. [P1654 排列计数](https://www.luogu.com.cn/problem/P1654)（递推与组合分析）

---
处理用时：127.48秒
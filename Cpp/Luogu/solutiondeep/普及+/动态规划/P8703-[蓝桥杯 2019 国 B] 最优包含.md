# 题目信息

# [蓝桥杯 2019 国 B] 最优包含

## 题目描述

我们称一个字符串 $S$ 包含字符串 $T$ 是指 $T$ 是 $S$ 的一个子序列，即可以从字符串 $S$ 中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与 $T$ 完全一样。

给定两个字符串 $S$ 和 $T$，请问最少修改 $S$ 中的多少个字符，能使 $S$ 包含 $T$。

## 说明/提示

对于 $20 \%$ 的评测用例, $1 \leq|T| \leq|S| \leq 20$;

对于 $40 \%$ 的评测用例, $1 \leq|T| \leq|S| \leq 100$;

对于所有评测用例, $1 \leq|T| \leq|S| \leq 1000$。

蓝桥杯 2019 年国赛 B 组 F 题。

## 样例 #1

### 输入

```
ABCDEABCD
XAABZ
```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论
各题解均采用动态规划解法，核心思路为二维状态 `dp[i][j]` 表示将 `S` 前 `i` 位修改为包含 `T` 前 `j` 位的最小操作次数。状态转移分字符相等（直接继承）和不等（取修改或不修改的最小值）两种情况。所有题解均正确初始化 `dp[i][0]=0`，其余为极大值。不同实现主要在索引处理（添加前缀空格）、循环优化（滚动数组）和边界条件上存在差异。

---

### 精选题解（评分≥4星）

#### 1. 题解作者：Versed_sine（5星）
**关键亮点**  
- 代码简洁清晰，通过添加前缀空格统一索引从1开始，避免越界问题。  
- 状态转移逻辑明确，初始化正确且高效。  
- 完整处理了所有边界条件，可读性强。

**核心代码**  
```cpp
string s,t;
int dp[maxn][maxn];
// 初始化及转移逻辑
s = " " + s; t = " " + t; // 统一索引
memset(dp, inf, sizeof dp);
for (int i=0; i<=s.size(); i++) dp[i][0] = 0; // 初始化
for (int i=1; i<=s.size(); i++) 
    for (int j=1; j<=t.size(); j++) {
        if (s[i] == t[j]) dp[i][j] = dp[i-1][j-1];
        else dp[i][j] = min(dp[i-1][j-1]+1, dp[i-1][j]);
    }
```

#### 2. 题解作者：GavinWu_qwq（4星）
**关键亮点**  
- 明确的状态定义和转移方程解释，适合快速理解算法逻辑。  
- 代码结构规范，字符串索引处理清晰。  
- 未采用滚动数组但空间复杂度可接受（1000x1000）。

**核心代码**  
```cpp
str1 = " " + str1; str2 = " " + str2; // 索引处理
memset(dp, 0x3f, sizeof(dp));
for (int i=0; i<=n; i++) dp[i][0] = 0; // 初始化
for (int i=1; i<=n; i++)
    for (int j=1; j<=m; j++) {
        if (str1[i] == str2[j]) dp[i][j] = dp[i-1][j-1];
        else dp[i][j] = min(dp[i-1][j-1]+1, dp[i-1][j]);
    }
```

#### 3. 题解作者：lqsy002（4星）
**关键亮点**  
- 代码简洁，初始化与转移逻辑高度优化。  
- 使用 `min({a, b, c})` 简化多条件比较。  
- 直接操作原字符串索引，适合熟悉字符串处理的读者。

**核心代码**  
```cpp
memset(f, 63, sizeof(f));
for (int i=0; i<=n; ++i) f[i][0] = 0;
for (int i=1; i<=n; ++i)
    for (int j=1; j<=m; ++j) {
        if (a[i] == b[j]) f[i][j] = f[i-1][j-1];
        else f[i][j] = min(f[i-1][j], f[i-1][j-1]+1);
    }
```

---

### 关键思路与技巧总结
1. **状态定义**：`dp[i][j]` 表示 `S` 前 `i` 位修改为包含 `T` 前 `j` 位的最小操作次数。  
2. **转移方程**：  
   - 若 `S[i] == T[j]`，`dp[i][j] = dp[i-1][j-1]`。  
   - 若不等，取 `min(dp[i-1][j]（不修改）, dp[i-1][j-1]+1（修改）)`。  
3. **初始化技巧**：`dp[i][0] = 0`（空子序列无需修改），其余初始化为极大值。  
4. **索引优化**：在字符串前添加空格，使索引从1开始，简化边界处理。

---

### 相似题目推荐
1. [P2758 编辑距离](https://www.luogu.com.cn/problem/P2758)  
   - **考察点**：动态规划处理字符修改、插入、删除操作。  
2. [P1143 最长公共子序列](https://www.luogu.com.cn/problem/P1143)  
   - **考察点**：二维动态规划求最长公共子序列。  
3. [P1439 最长公共子序列（滚动数组优化）](https://www.luogu.com.cn/problem/P1439)  
   - **考察点**：空间优化后的动态规划解法。

---
处理用时：79.93秒
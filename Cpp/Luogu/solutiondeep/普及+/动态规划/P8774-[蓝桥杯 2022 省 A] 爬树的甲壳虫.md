# 题目信息

# [蓝桥杯 2022 省 A] 爬树的甲壳虫

## 题目描述

有一只甲壳虫想要爬上一颗高度为 $n$ 的树，它一开始位于树根, 高度为 $0$，当它尝试从高度 $i-1$ 爬到高度为 $i$ 的位置时有 $P_{i}$ 的概率会掉回树根, 求它从树根爬到树顶时, 经过的时间的期望值是多少。


## 说明/提示

对于 $20 \%$ 的评测用例, $n \leq 2,1 \leq x_{i}<y_{i} \leq 20$;

对于 $50 \%$ 的评测用例, $n \leq 500,1 \leq x_{i}<y_{i} \leq 200$;

对于所有评测用例, $1 \leq n \leq 10^5,1 \leq x_{i}<y_{i} \leq 10^{9}$ 。 

蓝桥杯 2022 省赛 A 组 E 题。

## 样例 #1

### 输入

```
1
1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
3
1 2
3 5
7 11```

### 输出

```
623902744```

# AI分析结果



### 综合分析与结论  
本题核心为期望DP与逆元应用。各题解均围绕建立递推关系、解方程展开，主要差异在于正推/逆推的选择及系数处理方式。关键技巧是将递推式中的$f_0$转化为方程，结合逆元快速求解分数模。

---

### 精选题解与评分  

#### 1. Keroshi的题解（★★★★★）  
**关键亮点**：  
- 逆推思路清晰，通过系数分离（s1, s2, s3）将问题转化为线性方程。  
- 代码简洁高效，O(n)处理系数，快速幂求逆元。  
**核心代码**：  
```cpp
for(int i=1;i<=n;i++){ 
    int p1 = 1ll*a[i]*fp(b[i],P-2)%P; // 失败概率
    int p2 = (1ll*(b[i]-a[i])*fp(b[i],P-2))%P; // 成功概率
    s3 = (s3 + s1) % P; 
    s2 = (s2 + 1ll*s1*p1) % P;
    s1 = 1ll*s1*p2 % P;
}
printf("%d", (1ll*s3*fp(1-s2+P,P-2))%P);
```

#### 2. XAuen1的题解（★★★★★）  
**关键亮点**：  
- 正推法直观，推导出$dp[i] = \frac{y_i(1+dp[i-1])}{y_i-x_i}$，直接递推。  
- 代码逻辑清晰，分数取余模块化。  
**核心代码**：  
```cpp
for(int i=1;i<=n;i++){
    ll x,y; cin>>x>>y;
    dp[i] = qy((y*(1+dp[i-1]))%MOD, y-x); // 转移方程
}
printf("%lld",dp[n]);
```

#### 3. makerlife的题解（★★★★☆）  
**关键亮点**：  
- 提供正推与倒推双解，正推公式更简洁。  
- 代码中直接维护系数A和B，数学推导透彻。  
**核心代码**：  
```cpp
for(int i=1;i<=n;i++){
    A=(A+now)%mod;
    B=(B+now*p1[i]%mod)%mod;
    now=(p2[i]*now)%mod;
}
printf("%d",A*inv((1-B+mod)%mod)%mod);
```

---

### 关键思路与技巧  
1. **方程转化**：将递推式中的$f_0$视为未知数，通过展开递推式得到形如$f_0 = A + Bf_0$的方程，解出$f_0 = A/(1-B)$。  
2. **逆元优化**：利用费马小定理求分数模，快速幂实现逆元计算。  
3. **正推/逆推选择**：正推更直观（如XAuen1），逆推需处理系数分离（如Keroshi）。  

---

### 拓展与同类题目  
1. **P1850 [NOIP2016 提高组] 换教室**（期望DP）  
2. **P4550 收集邮票**（递推期望与费用计算）  
3. **P3811 【模板】乘法逆元**（逆元基础应用）  

---

### 题解心得摘录  
- **makerlife**：在交流中发现正推更简洁，体现协作重要性。  
- **Keroshi**：强调系数分离与模运算处理，避免复杂递归。  
- **XAuen1**：通过等比数列求和的极限简化推导，展现数学工具的关键作用。

---
处理用时：61.07秒
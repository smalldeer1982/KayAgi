# 题目信息

# [蓝桥杯 2022 国 B] 费用报销

## 题目描述

小明在出差结束后返回了公司所在的城市，在填写差旅报销申请时，粗心的小明发现自己弄丢了出差过程中的票据。

为了弥补小明的损失，公司同意小明用别的票据进行报销，但是公司财务要求小明提交的票据中任意两张的日期差不小于 $K$ 天，且总金额不得超过实际差旅费用 $M$。

比如财务要求 $K=7$ 时，若小明提交了一张 1 月 8 日的票据，小明就不能提交 1 月 2 日至 1 月 14 日之间的其他票据，1 月 1 日及之前和 1 月 15 日及之后的票据则可以提交。

公司的同事们一起给小明凑了 $N$ 张票据，小明现在想要请你帮他整理一下，从中选取出符合财务要求的票据, 并使总金额尽可能接近 $M$ 。

需要注意，由于这些票据都是同一年的，因此 12 月底的票据不会影响到 1 月初票据的提交。这一年不是闰年。

## 说明/提示

**【样例说明】**

选择 1 月 3 日和 1 月 6 日的票据

**【评测用例规模与约定】**

对于 $100 \%$ 的评测用例, $1 \leq N \leq 1000,1 \leq M \leq 5000,1 \leq K \leq 50,1 \leq m_{i} \leq$ $12,1 \leq d_{i} \leq 31,1 \leq v_{i} \leq 400$

日期保证合法。 


蓝桥杯 2022 国赛 B 组 F 题。

## 样例 #1

### 输入

```
4 16 3
1 1 1
1 3 2
1 4 4
1 6 8```

### 输出

```
10```

# AI分析结果



### 综合分析
该题本质是带时间约束的背包问题，核心难点在于处理日期差约束。各题解均采用动态规划思路，主要差异在于状态定义、转移优化和实现技巧。最优解法为预处理每个票据的最近合法前驱（lst数组），结合经典背包结构实现O(nm)时间复杂度，在代码可读性和效率间取得较好平衡。

---

### 精选题解

#### 1. 作者：Nwayy（动态规划解法） ★★★★☆
**核心亮点**：
- 预处理lst数组实现快速状态转移
- 清晰的01背包结构，代码简洁易理解
- 正确处理日期转换与排序
**关键代码**：
```cpp
for(int i=1;i<=n;i++){
    for(int j=m;j>=d[i].v;j--){
        f[i][j] = max(f[i-1][j], f[lst[i]][j-d[i].v] + d[i].v);
    }
}
```
**实现思想**：预处理每个票据i的最远合法前驱lst[i]，转移时只需考虑前驱状态，将O(n²m)优化为O(nm)

#### 2. 作者：xxseven（bitset优化） ★★★★☆
**核心亮点**：
- 使用bitset位压缩实现O(nm/w)复杂度
- 双指针维护合法区间，巧妙利用前缀或
- 突破传统DP思维，适合大规模数据
**关键代码**：
```cpp
while(t[a[pos]]+k <= t[i]) {
    now |= b[a[pos]]; pos++;
}
b[i] = now | (now << v[i]);
```
**实现思想**：维护当前可转移的前缀bitset状态，通过位运算快速合并可行解，极大减少内存访问次数

#### 3. 作者：Wing_（最小最晚日期DP） ★★★★
**核心亮点**：
- 创新性状态设计（存储最晚日期）
- 深入分析初始化陷阱，提供调试经验
- 逆向思维优化转移条件
**关键代码**：
```cpp
memset(f,0x3f,sizeof f);
f[0][0] = -INF; // 关键初始化
if(j>=v[i] && d[i]-f[i-1][j-v[i]]>=K)
    f[i][j] = min(f[i][j], d[i]);
```
**个人心得**：初始化时f[0][0]必须设为极小值，否则首个票据会被错误过滤。强调状态定义与初始化的紧密关联

---

### 关键技巧总结
1. **日期预处理**：将月/日转换为全年天数，便于比较
2. **前驱优化**：预处理lst数组将二维约束降为一维
3. **状态压缩**：bitset优化对布尔型状态的存储与转移
4. **逆向初始化**：用负无穷表示空状态，避免边界条件错误

---

### 推荐练习
1. P1048 [NOIP2005 普及组] 采药（基础背包）
2. P1776 宝物筛选（多重背包+二进制优化）
3. P3174 [HAOI2009]毛毛虫（树形DP结合时间约束）

---

### 重点代码集锦
**Nwayy解法核心转移**：
```cpp
for(int i=1;i<=n;i++){
    for(int j=m;j>=d[i].v;j--){
        f[i][j] = max(f[i-1][j], f[lst[i]][j-d[i].v]+d[i].v);
    }
}
```

**Wing_解法状态定义**：
```cpp
int f[N][M]; // f[i][j]：前i个票据选j元时的最晚日期
memset(f,0x3f,sizeof f);
f[0][0] = -INF; // 关键初始化
```

**xxseven解法bitset优化**：
```cpp
bitset<5005> b[N], now;
now.set(0); // 初始空状态
b[i] = now | (now << v[i]); // 位运算合并状态
```

---
处理用时：52.71秒
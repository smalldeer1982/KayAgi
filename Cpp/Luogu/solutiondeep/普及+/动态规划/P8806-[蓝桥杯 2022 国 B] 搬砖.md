# 题目信息

# [蓝桥杯 2022 国 B] 搬砖

## 题目描述

这天，小明在搬砖。

他一共有 $n$ 块砖，他发现第 $i$ 砖的重量为 $w_{i}$，价值为 $v_{i}$。他突然想从这些砖中选一些出来从下到上堆成一座塔，并且对于塔中的每一块砖来说，它上面所有砖的重量和不能超过它自身的价值。

他想知道这样堆成的塔的总价值（即塔中所有砖块的价值和）最大是多少。


## 说明/提示

**【样例说明】**

选择第 $1$、$2$、$4$ 块砖，从上到下按照 $2$、$1$、$4$ 的顺序堆成一座塔，总价值为 $4+1+5=10$。

**【评测用例规模与约定】**

对于 $20 \%$ 的数据，保证 $n \leq 10$;

对于 $100 \%$ 的数据，保证 $n \leq 1000 ; w_{i} \leq 20 ; v_{i} \leq 20000$ 。

蓝桥杯 2022 国赛 B 组 J 题。

## 样例 #1

### 输入

```
5
4 4
1 1
5 2
5 5
4 3```

### 输出

```
10```

# AI分析结果



### 综合分析与结论  
本题本质是动态规划与贪心策略的结合，关键在于通过排序将问题转化为可解的01背包。核心难点在于证明按 $w_i + v_i$ 升序排序的正确性，使得在满足约束条件的前提下，能通过背包转移求得最大价值。所有题解均围绕这一核心思路展开，差异主要体现在代码实现细节与证明过程的严谨性。

---

### 高星题解推荐  
#### 1. 作者：lottle1212（★★★★★）  
**关键亮点**  
- 给出严谨的贪心策略数学证明，通过不等式推导说明排序依据  
- 代码简洁高效，背包状态设计合理（`dp[j]`表示总重量为j时的最大价值）  
- 在转移时实时更新答案，避免最后遍历  
**核心代码**  
```cpp
sort(a + 1, a + n + 1, cmp); // 按w+v升序排序
for (int i = 1; i <= n; ++i)
    for (int j = a[i].w + a[i].v; j >= a[i].w; --j)
        dp[j] = max(dp[j], dp[j - a[i].w] + a[i].v), 
        ans = max(ans, dp[j]); 
```

#### 2. 作者：王熙文（★★★★☆）  
**关键亮点**  
- 使用结构体索引排序，避免修改原数据顺序  
- 详细说明贪心策略的证明过程，分步推导更易理解  
- 初始化`dp`数组为负无穷，确保非法状态不可达  
**核心代码**  
```cpp
sort(p+1,p+n+1,cmp); // p为索引数组
memset(dp,-0x3f,sizeof(dp)); 
dp[0] = 0; // 合法初始状态
for(int j=1; j<=n; ++j)
    for(int k=a[p[j]]+b[p[j]]; k>=a[p[j]]; --k) 
        dp[k] = max(dp[k], dp[k-a[p[j]]] + b[p[j]]);
```

#### 3. 作者：0x282e202e2029（★★★★☆）  
**关键亮点**  
- 通过表格对比交换砖块前后的约束条件，直观解释排序逻辑  
- 代码中直接使用结构体排序，注释清晰  
- 强调 $v_i - W_{i-1}$ 的最小化思想，深化理解  
**核心代码**  
```cpp
struct Brick { int w, v; } b[MAXN];
sort(b + 1, b + n + 1, [](Brick x, Brick y) { 
    return x.w + x.v < y.w + y.v; 
});
for(int j = b[i].w + b[i].v; j >= b[i].w; j--)
    dp[j] = max(dp[j], dp[j - b[i].w] + b[i].v);
```

---

### 关键思路与技巧总结  
1. **贪心排序策略**  
   必须按 $w_i + v_i$ 升序排列，确保对于任意两块砖 $i,j$，若 $i$ 在 $j$ 下方时，$j$ 的约束条件仍成立。该策略通过数学归纳法或交换论证可严格证明。

2. **动态规划设计**  
   - 状态定义：`dp[j]` 表示总重量为 `j` 时的最大价值  
   - 转移条件：仅当当前砖的重量 `w` 小于等于剩余容量 `j`，且总重量不超过 `w_i + v_i`  
   - 遍历顺序：逆序更新以避免重复选取  

3. **实现优化**  
   - 背包容量上限为 `w_i + v_i` 的最大值（20000）  
   - 实时更新答案而非最后遍历，节省时间  

---

### 同类题目推荐  
1. **P1417 烹调方案**（贪心+01背包）  
   - 需按特定公式排序食材后再进行背包转移  

2. **P4095 [HEOI2013] Eden 的新背包问题**（多重背包+贪心）  
   - 结合贪心策略优化多重背包的选取顺序  

3. **P4026 [SHOI2008] 安全的航线**（约束条件下的最优化）  
   - 需要在特定约束下进行状态转移设计  

---

### 个人心得摘录  
- **调试教训**：多位作者提到直接套用01背包模板会导致错误，必须结合排序策略（如hyl_____的WA经历）。  
- **顿悟时刻**：通过分析两砖块的约束不等式，发现排序依据的关键在于 $w_i + v_i$（如small_lemon_qwq的推导）。  
- **实现技巧**：将背包容量限制在 `w_i + v_i` 而非固定值，避免无效状态计算（如gesong的代码注释）。

---
处理用时：57.59秒
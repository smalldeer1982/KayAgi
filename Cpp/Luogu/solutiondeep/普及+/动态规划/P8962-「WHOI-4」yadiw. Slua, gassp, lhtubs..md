# 题目信息

# 「WHOI-4」yadiw. Slua, gassp, lhtubs.

## 题目背景

> If you know at least 3 of these things and you are not red — you are doing it wrong. Stop learning useless algorithms, go and solve some problems, learn how to use binary search.


## 题目描述

小 F 有一个奇妙的数组 $a$，$a$ 中没有重复的元素，长度为 $n$，他使用`std::sort`将他排序了，认为它是有序的，所以他正在使用这样的方法进行二分查找。显然，能否查到只和数列的离散化结果有关，所以你可以直接把 $a$ 看作 $1\sim n$ 的一个排列。

```cpp
int search(int key) {
  int l = 1, r = n;
  while (l <= r) {
    int mid = (l + r) / 2;
    if (a[mid] < key)
      l = mid + 1;
    else if (a[mid] == key)
      return mid;
    else
      r = mid - 1;
  }
  return -1;
}
```

不幸的是，小 W 为了让他戒掉万能头，在`bits/stdc++.h`中写了`#define sort random_shuffle`，这意味着 $a$ 实际是一个随机的排列。

现在，对于所有在 $1$ 到 $N$ 范围内的 $n$，以及所有在 $1$ 到 $n$ 范围内的 $k$，在 $a$ 数列的所有排列中，有几个可以正确地找到第 $k$ 小的元素 $key$（即返回值非 $-1$）？由于答案可能过大，请输出它对给定模数 $p$ 取模的结果。

## 说明/提示

**数据范围**

**本题采用 Subtask 评测。**

- Subtask 1（$10$ pts）：$N=10$，$ p\ge998244352$；
- Subtask 2（$25$ pts）：$N=100$，$p\ge1009$ **且为素数**；
- Subtask 3（$25$ pts）：$N=400$，$p\ge1009$ **且为素数**；
- Subtask 4（$40$ pts）：$N=400$。

对于所有数据，$10\le N\le 400$，$ 2\le p\le998244353$。

## 样例 #1

### 输入

```
998244353 5
```

### 输出

```
1
1 2
4 4 4
12 12 14 18
48 54 60 66 72```

# AI分析结果



### 综合分析与结论
两篇题解均基于二分查找路径的约束条件进行组合数学计数。核心思路为：确定在二分过程中必须小于/大于目标值的元素个数，通过排列组合计算合法排列数。OIer_Eternity 的题解通过预处理二分路径参数优化时间复杂度，更优。

---

### 精选题解分析

#### 题解2：OIer_Eternity（★★★★★）
**关键亮点**：
1. **预处理优化**：提前计算所有可能长度的二分路径参数（必须小于/大于的元素个数），将时间复杂度从 $O(n^3 \log n)$ 优化至 $O(n^3)$。
2. **模数处理技巧**：通过组合数乘以阶乘的方式处理排列数，规避非质数模数求逆元的难题。
3. **清晰的数学建模**：将问题分解为固定大小关系计数，公式推导严谨。

**个人心得引用**：
> "若暴力求排列数会导致 $O(n^4\log n)$ 复杂度，显然不行；通过预处理组合数与阶乘实现 $O(n^2)$ 预处理，大幅优化效率。"

**核心代码思想**：
```cpp
// 预处理 cnt1[i][k], cnt2[i][k]：长度为 i 时，第 k 位需要的小于/大于次数
for (int i=1;i<=n;i++) 
    for (int k=1;k<=i;k++){
        int L=1, R=i;
        while (L<R){ // 模拟二分过程统计 cnt1, cnt2
            int Mid=(L+R)>>1;
            if (k==Mid) break;
            if (k<Mid) cnt2[i][k]++, R=Mid-1;
            else cnt1[i][k]++, L=Mid+1;
        }
    }
```

---

### 关键思路总结
1. **二分路径约束分析**：确定查找路径中所有中间点必须满足的大小关系，转化为必须小于（cnt1）和必须大于（cnt2）的元素个数。
2. **组合数学模型**：合法排列数为 $A_{x-1}^{cnt1} \times A_{n-x}^{cnt2} \times (n-cnt1-cnt2-1)!$。
3. **预处理技巧**：将重复的二分路径计算提前预处理，避免主循环中的重复模拟。

---

### 相似题目推荐
1. **P1106 删数问题**（贪心+组合约束）
2. **P2518 [HAOI2010] 计数**（排列数统计与预处理）
3. **P3223 [HNOI2012] 排队**（复杂排列组合建模）

---
处理用时：53.07秒
# 题目信息

# [PA 2020] Cukierki

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Cukierki](https://sio2.mimuw.edu.pl/c/pa-2020-1/cuk/)**

Bytie 要去参加 Bitek 的生日聚会。他知道 Bitek 喜欢吃甜食，所以他想送他一些糖果作为礼物。他买了 $n$ 袋糖，其中第 $i$ 袋包含 $a_i$ 个糖果。

然而，这些糖相当重，Bytie 想知道他是否需要把它们全都给 Bitek。他决定，他将选择一个非空的袋装糖果子集，把它们拿给 Bitek，并对他说：「我这里总共有 $x$ 颗糖果，你想要多少？」，其中 $x$ 将是带到派对上的包装里的糖果总数。Bitek 听到这个问题后，可能会选择区间 $[1, x]$ 中的任何整数 $y$。无论 Bitek 的回答如何，他都希望能够从带到派对上的糖中选择一部分（其余的留给自己），这样这些袋糖中的糖果总数正好等于 $y$。当然，不可以撕毁包装纸——给散装的糖果是不礼貌的。

因此，Bytie 在想，他能给 Bitek 带去多少种非空的袋装糖果子集，以便在不考虑 Bitek 的选择的情况下，能够送给他所需数量的糖果。请帮助他计算一下吧！由于这种子集的数量可能非常大，请输出它对 $10^9+7$ 取模后的结果。

## 说明/提示

#### 样例 1 解释

Bytie 可以带去 $8$ 种非空子集：$\{5\}, \{1, 5\}, \{1, 3, 5\}, \{1, 4, 5\}, \{1, 3, 4, 5\}, \{1, 2, 3, 5\}, \{1, 2, 4, 5\}$ 和 $\{1, 2, 3, 4, 5\}$。例如，Bytie 带去的子集是 $\{1,2,4,5\}$，Bitek 想要 $9$ 颗糖果时，Bytie 只能给他第 $1,2$ 包糖。Bytie 不可以带去 $\{1,2,5\}$ 子集，如果 Bitek 想要 $6$ 颗糖的话 Bytie 就犯难了。

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1\le n\le 5\times 10^3$，$1\le a_i\le 5\times 10^3$。

## 样例 #1

### 输入

```
5
2 7 4 4 1```

### 输出

```
8```

# AI分析结果



### 综合分析与结论
该题的解题核心在于**有序动态规划**与**状态压缩**。所有题解均采用以下思路：
1. 将糖果数组排序，确保后续决策的单调性
2. 定义动态规划状态表示覆盖区间 [1,j] 的方案数
3. 通过滚动数组优化空间复杂度
4. 对极大值状态进行合并压缩

关键优化点：当当前覆盖范围 j ≥ 5000 时，后续任何更大的糖果都能被完全吞并，因此可以合并处理。这使得时间复杂度从 O(n²a) 优化至 O(n·max_a)。

---

### 精选题解推荐

#### 1. ZM____ML（★★★★☆）
**核心亮点**：
- 清晰的滚动数组实现
- 简洁的代码结构
- 强调排序对转移条件的必要性
**关键代码**：
```c
for(int i=1;i<=n;i++)
    for(int j=N-5;j>=a[i]-1;j--)
        f[min(j+a[i],N-5)] += f[j];
```
**实现思想**：倒序遍历保证无后效性，min操作实现状态压缩

#### 2. MspAInt（★★★★☆）
**核心亮点**：
- 提供滚动与不滚动的对比实现
- 明确解释刷表法的优势
- 测试数据验证空间优化效果
**个人心得**：
> "排序后，后续的糖果只会更大，确保转移条件 a_i ≤ j+1 的有效性"

#### 3. _•́へ•́╬_（★★★★☆）
**核心亮点**：
- 创新性的状态合并理论
- 数学形式化定义状态压缩
- 极简代码实现（仅17行）
**关键优化**：将 j ≥ 5000 的状态统一处理，节省计算量

---

### 最优技巧总结
1. **有序化处理**：排序后保证 a_i 单调递增，使得转移条件 a_i ≤ j+1 能正确维护区间覆盖
2. **状态压缩**：将 j ≥ max_a 的状态合并为同一类，避免无效计算
3. **滚动数组**：将二维DP压至一维，空间复杂度从 O(n²) 降为 O(n)
4. **逆向刷表**：倒序更新状态避免重复计数

---

### 拓展训练
1. [P2320][HNOI2006] 鬼谷子的钱袋（区间覆盖构造）
2. [P4141] 消失之物（背包计数变式）
3. [P3183][HAOI2016] 食物链（DAG路径计数）

---

### 关键代码片段
以最优化的 _•́へ•́╬_ 代码为例：
```cpp
for(int i=0;i<n;++i)for(int j=5000,k;j>=a[i]-1;--j) {
    k = min(j+a[i],5000); // 状态压缩核心
    b[k] = (b[k] + b[j]) % mod;
}
```
此代码实现了状态转移与压缩的完美结合，min操作将超过5000的值统一处理。

---
处理用时：52.73秒
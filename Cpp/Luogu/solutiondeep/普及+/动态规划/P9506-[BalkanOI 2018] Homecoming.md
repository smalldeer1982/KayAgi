# 题目信息

# [BalkanOI 2018] Homecoming

## 题目背景

翻译自 BalkanOI 2018 Day1 T2「Homecoming」；由于洛谷远慢于 loj，因此将时间限制从 300ms 调整至 500ms。

## 题目描述

有 $N$ 门课程，分别编号为 $0$ 到 $N-1$。如果你 pass 了课程 $i$，你可以拿到 $A _ i$ 美刀。  
有 $N$ 本教材，分别编号为 $0$ 到 $N-1$。$i$ 号教材的价格为 $B _ i$ 美刀。  
如果你要 pass 课程 $i$，你需要购买编号为 $i, (i+1) \bmod N, (i+2) \bmod N, \cdots, (i+K-1) \bmod N$ 的课本。$K$ 为给定的常数。  
你的目的是赚钱而非 pass 所有课程。请求出你最多能赚多少美刀。

## 交互过程

本题只支持 C++ 语言使用函数交互测评。**选手代码不需要也不能包含 `homecoming.h`，也不需要实现 `main` 函数。**

选手程序需要实现如下函数：

```
long long int solve(int N, int K, int *A, int *B);
```

在一次运行中这个函数可能会被调用多次。


## 样例

调用

```
solve(3, 2,
[40, 80, 100],
[140, 0, 20])
```

的返回值为 $60$。



## 说明/提示

### 数据范围及限制

令所有对 `solve` 函数的调用中 $N$ 的总和为 $S_N$，$NK$ 的总和为 $S_{NK}$。那么：

- $1\le K\le N\le 2\times 10^6$
- $1\le S_N\le 2\times 10^6$
- $0\le A_i,B_i\le 10^9$

详细子任务及附加限制如下表所示。

| 子任务编号 | 附加限制 | 分值 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $1\le S_N\le 500$ | $13$ |
| $2$ | $1\le S_N\le 5000$ | $18$ |
| $3$ | $1\le S_{NK}\le 2\times 10^6$ | $31$ |
| $4$ | 无附加限制 | $38$ |

# AI分析结果



### 综合分析与结论
本题核心在于处理环形结构的最优决策，关键点在于断环成链与两次动态规划（DP）分类讨论。通过预处理前缀和优化区间查询，并维护前序状态最大值，实现线性时间复杂度。

---

### 高分题解推荐

#### 题解作者：liangbowen（★★★★☆）
**关键亮点**：
- 提出断环成链后维护两个状态（延续购买/重新购买）的转移思路。
- 通过两次DP处理环形边界问题，覆盖所有决策可能性。
- 时间复杂度严格线性，适合大规模数据。

#### 题解作者：cyngugugu（★★★★☆）
**关键亮点**：
- 代码结构清晰，详细处理了断环成链后的边界条件（如 `i+K-1 <= N` 的特殊判断）。
- 明确分类讨论第一次是否选择课程，通过两次DP确保无后效性。
- 注释辅助理解，代码可读性较高。

---

### 核心思路与代码实现
**核心思路**：
1. **断环成链**：复制数组为两倍长度，避免循环索引。
2. **前缀和预处理**：快速计算区间教材费用。
3. **动态规划**：定义 `dp[i]` 为处理到第 `i` 个课程的最大收益，维护 `maxx[i]` 记录前序最大值。
4. **分类讨论**：两次DP分别处理第一个课程选与不选的情况。

**关键代码（cyngugugu 版）**：
```cpp
long long int solve(int N, int K, int *A, int *B) {
    // 断环成链处理
    for (int i = 1; i <= 2*N; i++) {
        a[i] = (i <= N) ? A[i-1] : a[i-N];
        b[i] = (i <= N) ? B[i-1] : b[i-N];
        sum[i] = sum[i-1] + b[i];
    }

    // 第一次DP：强制选第一个课程
    f[1] = a[1] - (sum[K] - sum[0]);
    maxx[1] = -1e18;
    for (int i = 2; i <= N; i++) {
        int R = i + K - 1;
        if (R <= N) {
            f[i] = max(f[i-1] - b[R], maxx[i-1] - (sum[R] - sum[i-1])) + a[i];
        } else {
            f[i] = max(f[i-1], maxx[i-1] - (sum[N] - sum[i-1])) + a[i];
        }
        maxx[i] = max(maxx[i-1], f[i-1]);
    }

    // 第二次DP：不选第一个课程
    // ...类似处理，初始条件设为极小值...
}
```

---

### 拓展与举一反三
**同类问题**：
1. **环形石子合并**（P1880）：断环成链后区间DP。
2. **环形资源分配**（P6064）：分类讨论起始点状态。
3. **环形数组分割**（P1043）：断环后线性处理。

**优化技巧**：
- 前缀和/差分数组加速区间计算。
- 状态压缩减少空间复杂度（如 `maxx` 数组可滚动更新）。

---

### 心得总结
- **环形处理**：必须显式分类讨论起始点，避免边界条件错误。
- **前缀和优化**：大幅降低区间求和的时间复杂度，是此类问题的标配。
- **调试经验**：初始未正确处理环形时得分低，通过两次DP覆盖所有情况后才通过，强调全面性分析的重要性。

---
处理用时：75.67秒
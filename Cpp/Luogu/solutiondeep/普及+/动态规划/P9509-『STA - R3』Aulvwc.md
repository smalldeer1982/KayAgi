# 题目信息

# 『STA - R3』Aulvwc

## 题目背景

统计学是一门古老而迷人的学科。

传说早在若干年前，一位名为惠普的神灵来到地球，发现了人类——另一种有智慧的物种……

**已加入 Hack 数据，位于 Subtask 5，不计分。**

## 题目描述

定义一个序列 $\{a_n\}$ 是分部平均的，当且仅当存在一个 $\{1,2,\cdots,n\}$ 的划分 $S_1,S_2,\cdots,S_k$（其中 $k>1$），满足对于每个整数 $1\le i\le k$，序列 $\{a\}$ 中以 $S_i$ 为下标的元素之平均数都是相等的**整数**。

现在，给定序列 $\{a_n\}$，问它是否是分部平均的。

如果你对于一些定义不很清楚，可以查阅最后的「提示」部分。



## 说明/提示

### 提示
一个集合 $S$ 的划分定义为一组集合 $U_1,U_2,\cdots,U_k$，满足：
- 对于所有 $i\neq j$，有 $U_i\cap U_j=\varnothing$。
- $U_1\cup U_2\cup\cdots\cup U_k=S$。

一个序列 $\{x_n\}$ 的平均数定义为：
$$\bar x=\dfrac{x_1+x_2+\cdots+x_n}{n}=\dfrac 1n\sum_{i=1}^nx_i$$
### 样例解释
第一组数据的一种划分方案：$\{1\},\{2\},\{3\},\{4\},\{5\}$。

第二组数据的一种划分方案：$\{1,5\},\{2,4\},\{3\}$。

注意：划分方案所提供的集合是下标集合。

### 数据范围

**本题采用捆绑测试及子任务依赖。**
$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c|c|c}\hline\hline
\textbf{Subtask} & \bm{n}\le & \textbf{分值} & \textbf{特殊性质}&\textbf{依赖子任务}\\\hline
\textsf{1} & 10 & 5 & \\\hline
\textsf{2} & 10^3 & 20 & \sum a_i=0 \\\hline
\textsf{3} & 100 & 25 & & \sf1\\\hline
\textsf{4} & 10^3 & 50 & & \sf1\texttt{,}\ 3\\\hline
\end{array}
$$

对于全部数据，$1\le q\le 10$，$2\le n\le 10^3$，$|a_i|\le 5\times10^3$。

## 样例 #1

### 输入

```
4
5
1 1 1 1 1
5
1 2 3 4 5
5
1 1 1 1 6
5
-1 0 1 0 1```

### 输出

```
Yes
Yes
No
No```

# AI分析结果



### 综合分析与结论

题目核心是将序列划分为若干子集，使每个子集的平均数为相同整数。所有题解均基于以下关键观察：
1. **全局平均数为整数**是必要条件，否则直接无解。
2. **将每个元素减去全局平均数**后，问题转化为寻找非空真子集和为0。
3. 只需找到两个子集即可（可通过合并多个子集证明）。

主要解法分为三类：
- **动态规划+同余优化**（ty_mxzhn）：通过模数减少状态数，但需多个模数保证正确性。
- **bitset优化背包**（Lyz09、zqiaor）：将正负数分开处理，用bitset加速状态转移。
- **随机化+前缀和检测**（Huangjy88、jijidawang）：多次随机打乱序列，用set检测前缀和重复。

### 高星题解推荐

#### 1. 题解作者：Lyz09（★★★★★）
**关键亮点**：
- 使用bitset将正负元素分开处理，极大优化空间和时间。
- 代码简洁高效，利用位运算特性处理大规模数据。
- 通过正负bitset的交集快速判断是否存在合法子集。

**核心代码思路**：
```cpp
bitset<N> s, b; // s处理负数，b处理正数
for (int i=1; i<=n; i++) {
    if (a[i]>0) b |= b << a[i]; // 正数左移叠加
    else s |= s << (-a[i]);     // 负数转为正数叠加
}
if ((s & b).count() > 2) return true; // 交集存在非全选解
```

#### 2. 题解作者：zqiaor（★★★★☆）
**关键亮点**：
- 独立处理正负数，用两个bitset分别记录可能和。
- 代码结构清晰，直接判断交集是否有效。
- 对零元素特判，优化边界情况。

**核心代码**：
```cpp
bitset<2500001> b1, b2; // 正负各自可能的和
b1[0] = b2[0] = 1;
for (int i=1; i<=n; i++) {
    if (a[i]>0) b1 |= b1 << a[i];
    else if (a[i]<0) b2 |= b2 << (-a[i]);
}
if ((b1 & b2).count() > 2) return true;
```

#### 3. 题解作者：jijidawang（★★★★☆）
**关键亮点**：
- 随机化思路简单易懂，适合快速实现。
- 利用set检测前缀和的重复出现，代码简洁。
- 多次随机打乱提高正确率，实际通过率高。

**核心代码**：
```cpp
bool check() {
    random_shuffle(a+1, a+n+1);
    set<int> s; s.insert(0);
    int sum = 0;
    for (int i=1; i<n; i++) { // 注意不遍历最后一个元素
        sum += a[i];
        if (s.count(sum)) return true;
        s.insert(sum);
    }
    return false;
}
```

### 最优关键思路总结
1. **问题转化**：将元素减去平均数，转化为寻找和为0的子集。
2. **bitset优化**：利用位运算压缩状态，处理大范围子集和问题。
3. **分治处理**：将正负元素分开处理，减少状态冲突。
4. **随机化技巧**：通过多次随机打乱避免最坏情况，适用于非精确问题。

### 拓展与相似题目
1. **子集和问题**：如[P2347 砝码称重](https://www.luogu.com.cn/problem/P2347)，考察多重背包。
2. **平均数拆分**：如[CF808E Selling Souvenirs](https://www.luogu.com.cn/problem/CF808E)，需结合贪心与DP。
3. **bitset优化**：如[P1537 弹珠](https://www.luogu.com.cn/problem/P1537)，经典bitset应用。

### 个人心得摘录
- **调试教训**：零元素需特判，否则可能误判全选（Lyz09）。
- **优化技巧**：动态规划中模数选择需互质，避免漏判（ty_mxzhn）。
- **顿悟点**：正负分离后bitset交集即解（zqiaor），极大简化问题。

---
处理用时：65.73秒
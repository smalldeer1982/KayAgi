# 题目信息

# 「PFLOI R1」PFL 除法

## 题目背景

[有必要把所有比赛题的背景连在一起](https://www.luogu.com.cn/paste/enzfvjum)。

就这样，新世界的大门向它们敞开了……  

“喵！”一只可爱的花猫向它们问好。  

“你们刚来到这？”  

“嗯。”  

“我带你们去转转吧，谁叫我这么可爱呢！”  

“……” 花猫突然止住，打量一番手中的序列，俶尔又微笑着说：  

“但你们要先答出我的问题哦。”

## 题目描述

花猫有一个长度为 $n$ 的序列 $A$ 和另一个长度为 $m$ 的序列 $B$。你可以进行若干次以下操作：

+ 选择两个整数 $i$ 和 $j$，满足 $1\le i\le n$，$1\le j\le m$ 且 $B_j \mid A_i$，然后将 $A_i$ 变为 $\frac{A_i}{B_j}$。

**注意**：$A$ 和 $B$ 中的每个元素都可以选择并被**操作多次**。

最终要使得 $A$ 中的元素都相等，请求出最少的操作次数；若无解，输出 `-1`。

## 说明/提示

**本题采用捆绑测试**。

| 子任务编号 | 特殊性质 | 分值 | 
| :----------: | :----------: | :-----:| 
| $1$ | $A$ 中所有元素相等 | $5$ |
| $2$ | $n=2$ | $15$ |
| $3$ | $n,m\le10^3$ | $20$ | 
| $4$ | $n,m\le10^4$ | $20$ | 
| $5$ | 无 | $40$ |

对于所有数据，$1\le n,m\le5\times10^5$，$1\le A_i,B_i\le5\times10^5$。

## 样例 #1

### 输入

```
4 5
16 24 28 36
11 4 7 3 2```

### 输出

```
6```

## 样例 #2

### 输入

```
2 3
11 13
13 1 11```

### 输出

```
2```

## 样例 #3

### 输入

```
2 2
2 3
4 5```

### 输出

```
-1```

# AI分析结果



### 综合分析与结论

题目要求通过除法操作使数组 $A$ 元素全相等，求最小操作次数。各题解核心思路为：

1. **预处理分解步骤**：用完全背包或 BFS 预处理每个数分解为 1 的最小步数（需去重 $B$ 数组避免冗余）。
2. **枚举最终值 $D$**：正确 $D$ 是 $A$ 最大公约数（GCD）的因数，需枚举所有可能的因数并验证。
3. **动态规划优化**：通过调和级数复杂度处理预处理步骤，保证高效性。

### 高星题解推荐（评分≥4星）

---

#### 题解一（作者：qwq___qaq） ⭐⭐⭐⭐⭐
**关键亮点**：  
- 预处理思路清晰，完全背包动态规划处理分解步骤。  
- 枚举 $A$ 首元素的因数，通过后续整除检查确保正确性。  
- 代码简洁高效，去重优化显著降低复杂度。

**核心代码**：  
```cpp
memset(dp, inf, sizeof(dp));
dp[1] = 0;
for (int i = 1; i <= m; ++i) {
    for (int s = b[i]; s <= V; s += b[i]) {
        dp[s] = min(dp[s], dp[s / b[i]] + 1);
    }
}
// 枚举 a[1] 的因数并计算总步数
```

---

#### 题解三（作者：LCat90） ⭐⭐⭐⭐⭐
**关键亮点**：  
- 正确枚举最大公约数的所有因数，避免冗余枚举。  
- 预处理完全背包动态规划，时间复杂度严格分析。  
- 代码逻辑严谨，处理边界清晰。

**核心代码**：  
```cpp
for (int i = 1; i * i <= Gcd; ++i) {
    if (Gcd % i == 0) {
        factors.push_back(i);
        factors.push_back(Gcd / i);
    }
}
// 枚举所有 GCD 的因数并验证
```

---

#### 题解四（作者：yanhao40340） ⭐⭐⭐⭐
**关键亮点**：  
- BFS 预处理分解步骤，类似筛法优化路径搜索。  
- 枚举最大公约数的因数，思路正确且代码实现独特。  
- 处理大值域时效率较高，适合特殊数据分布。

**核心代码**：  
```cpp
queue<int> q;
for (int i = 1; i <= m; ++i) {
    if (b[i] != 1) q.push(b[i]), cnt[b[i]] = 1;
}
while (!q.empty()) {
    int fr = q.front(); q.pop();
    for (int i = 1; i <= m; ++i) {
        int tmp = fr * b[i];
        if (tmp > V) break;
        if (cnt[tmp] == inf) {
            cnt[tmp] = cnt[fr] + 1;
            q.push(tmp);
        }
    }
}
```

---

### 最优思路总结
1. **完全背包预处理**：对 $B$ 去重后，用动态规划预处理每个数分解为 1 的最小步数，时间复杂度 $O(V \log V)$。
2. **因数枚举优化**：枚举原数组最大公约数的所有因数作为候选 $D$，确保正确性并减少无效计算。
3. **调和级数优化**：预处理时按倍数遍历，避免重复计算，保证高效性。

### 拓展与相关题目
- **同类型题目**：因数分解、动态规划优化、完全背包变种。
- **推荐题目**：  
  1. [P2563 AHOI2001 质数和分解](https://www.luogu.com.cn/problem/P2563)  
  2. [P3423 POI2005 Bank Notes](https://www.luogu.com.cn/problem/P3423)  
  3. [P1072 Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)  

### 个人心得摘录
- **递归陷阱**（题解二）：直接递归分解可能导致超时，需结合记忆化或预处理优化。
- **边界处理**（题解一）：去重 $B$ 中的 1，避免无效循环。
- **枚举策略**（题解六）：通过首元素因数枚举，后续严格验证，保证正确性。

---
处理用时：210.61秒
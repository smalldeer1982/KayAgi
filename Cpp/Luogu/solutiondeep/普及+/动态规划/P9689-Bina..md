# 题目信息

# Bina.

## 题目描述

小 J 家门前有两棵树，一棵是二叉树，一棵是三叉树。

你被小 J 叫来修剪他的二叉树，使得他的二叉树的“美丽值”最大，所谓一棵树的美丽值 $=$ 这棵树的点的编号之和 $\div$ 这棵树的深度（结果向下取整）。

这棵二叉树有一个构建参数 $n$，构建方式如下：

```cpp
void build(int s,int t,int p){
  if(s==t) return ;
  build(s,(s+t)/2,2*p);
  build((s+t)/2+1,t,2*p+1);
  add_edge(p,2*p),add_edge(p,2*p+1);
}

int main(){
  build(1,n,1);
  return 0;
}
```

其中 `build(s,t,p)` 函数参数中的 $p$ 是当前点的编号，`add_edge(x,y)` 函数是指将编号为 $x$ 的点向编号为 $y$ 的点连接一条有向边。

容易发现这棵树的根节点是 $1$，并且我们规定节点的深度为节点到根节点路径上经过的点的个数（包括自己和根节点），这棵树的深度即为所有节点深度的最大值。

对于 $n=3$ 的情况，最后构建出来的结果如下，这棵树的深度为 $3$，你需要选择一个深度 $k$ 把深度大于 $k$ 的点都剪掉，但是 $k$ 必须**大于等于** $1$ 且**小于等于**这棵树的深度。

![](https://cdn.luogu.com.cn/upload/image_hosting/ueggbyn8.png)

小 J 还给了你一个要求，你剪去的节点个数一定得大于等于 $m$ 他才会高兴，你需要保证让他高兴的同时树的“美丽值”最大。

现在小 J 给了你构建树的参数 $n$ 和至少剪的节点个数 $m$，要你求出来他的树在你修剪后最大的美丽值是多少，如果无论如何你也不可能让小 J 高兴，输出 $-1$。

## 说明/提示

#### 【样例解释 #1】

对于第一组样例，$n$ 都等于 $3$，构建出来的树同题面所示。

如果我们选择把深度大于 $1$ 的节点全部剪掉，那么我们剪掉了 $2,3,4,5$ 共 $4$ 个节点，美丽值为 $1$。

如果我们选择把深度大于 $2$ 的节点全部剪掉，那么我们剪掉了 $4,5$ 共 $2$ 个节点，美丽值为 $\lfloor \dfrac{1+2+3}{2}\rfloor = 3$。

如果我们选择把深度大于 $3$ 的节点全部剪掉，那么我们没有剪掉任何节点，美丽值为 $\lfloor \dfrac{1+2+3+4+5}{3}\rfloor = 5$。

所以对于 $m=0$ 的情况，答案为 $5$；对于 $1 \le m \le 2$ 的情况，答案为 $3$；对于 $3 \le m \le 4$ 的情况，答案为 $1$；其它情况，无解输出 $-1$。

#### 【数据范围】

对于所有测试数据，满足 $1 \le T \le 10^5$，$1 \le n \le 10^9$，$0 \le m \le 2 \times 10^9$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n \le$ | $m \le$ | $T \le$ | 特殊限制 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1 \sim 2$ | $10^3$ | $10^5$ | $10^3$ | 无 |
| $3 \sim 4$ | $10^6$ | $2 \times 10^6$ | $10^5$ | 无 |
| $5$ | $10^9$ | $1$ | $10^5$ | 无 |
| $6$ | $10^9$ | $2$ | $10^5$ | 无 |
| $7 \sim 8$ | $10^9$ | $3$ | $10^5$ | 无 |
| $9 \sim 10$ | $10^9$ | $2 \times 10^9$ | $10^5$ | $m \ge 1$ |
| $11 \sim 12$ | $10^9$ | $10^3$ | $10^5$ | 无 |
| $13 \sim 16$ | $10^9$ | $2 \times 10^9$ | $10$ | 无 |
| $17 \sim 20$ | $10^9$ | $2 \times 10^9$ | $10^5$ | 所有 $n$ 均相同 |
| $21 \sim 25$ | $10^9$ | $2 \times 10^9$ | $10^5$ | 无 |

## 样例 #1

### 输入

```
6
3 0
3 1
3 2
3 3
3 4
3 5```

### 输出

```
5
3
3
1
1
-1```

## 样例 #2

### 输入

```
10
5 5
10 0
999 155
135 92
1000232 234255
10293845 1239485
123948 1239454
12394 2131094
1000000000 98765432
1000000000 999999999```

### 输出

```
3
40
52377
1161
27487764480
5864061665280
-1
-1
19215358392218419
4969489234738635```

# AI分析结果



### 综合分析与结论
本题核心在于通过线段树结构特性快速计算各层节点信息，并枚举保留层数以求解最大美丽值。各题解主要采用以下两种思路：
1. **线段树递归性质 + 动态规划预处理**：利用线段树不同长度区间数量少的特性，预处理每层节点数及编号和。
2. **二进制分治 + 数学推导**：通过观察最后一层节点编号的二进制规律，分治计算贡献。

### 高星题解推荐
#### 1. 离散小波变换°（★★★★★）
**关键亮点**：
- 利用线段树每层区间长度种类少的特性，动态规划预处理各长度区间的子树信息。
- 通过记忆化优化计算，实现O(T log n)的时间复杂度。
- 预处理与枚举层数的分离设计极大提升效率。

**核心实现**：
```cpp
// 预处理不同长度区间的子树信息
void solve(int n, int d){
    if(M[d].count(n)) return;
    // 递归处理左右子树长度
    solve(n1, d-1); 
    solve(n2, d-1);
    // 合并左右子树信息
    M[d][n] = {c1+c2+1, 1+2*u1+2*u2, v1+u2+v2};
}
// 枚举层数计算最大美丽值
for(int k=1;k<=h;k++){
    solve(n,k);
    auto [c,x,y] = M[k][n];
    if(c <= tot - m) ans = max((x+y)/k, ans);
}
```

#### 2. qczrz6v4nhp6u（★★★★☆）
**关键亮点**：
- 通过二进制反转规律将最后一层节点和转化为位运算问题。
- 分治计算每位贡献，避免直接递归带来的复杂度。
- 数学推导清晰，代码简洁高效。

**核心推导**：
最后一层节点和为：  
$$\sum_{i=0}^k (4 \cdot \text{rev}(i) +1) = (k+1)(2^{p+2}+1) +4\sum \text{rev}(i)$$  
通过拆解每位贡献快速计算总和。

#### 3. libohan0905（★★★★☆）
**关键亮点**：
- 将树拆分为满二叉树和叶子部分单独处理。
- 分治计算最后一层父节点编号和，转化为子问题递归。

**调试心得**：
> "赛时没取最大值喜提80pts"  
**教训**：处理边界时必须考虑所有可能情况，尤其注意取最大值时的遗漏。

### 关键思路总结
1. **线段树性质**：每层最多两种区间长度，预处理可大幅减少计算量。
2. **动态规划预处理**：维护子树节点数、系数信息，快速合并左右子树。
3. **二进制分治**：最后一层节点编号的二进制规律可转化为数学问题，通过分治统计每位贡献。

### 拓展建议
- **类似问题**：线段树节点统计、完全二叉树结构分析、分治优化数学计算。
- **推荐题目**：
  - P1471 方差（线段树区间操作）
  - P1908 逆序对（分治统计）
  - P3373 【模板】线段树 2（线段树进阶操作）

### 核心代码片段
**离散小波变换°的动态规划预处理**：
```cpp
void solve(int n, int d) {
    if (n <= o && d <= g) return;
    if (M[d].count(n)) return;
    const int n1 = (n + 1) / 2, n2 = n - n1;
    solve(n1, d-1); solve(n2, d-1);
    // 合并左右子树信息到当前层
    M[d][n] = {c1+c2+1, 1+2*u1+2*u2, v1+u2+v2};
}
```

**qczrz6v4nhp6u的二进制分治**：
```cpp
ll calc(int len) {
    ll res = 0;
    for(int i=0; (1<<i)<=len; i++) {
        ll cnt = ((len + 1) >> (i+1)) << i; // 计算第i位为1的总数
        cnt += max(0ll, (len+1) % (1<<(i+1)) - (1<<i));
        res += cnt * (1ll << (maxdep - i -1)); // 累加每位贡献
    }
    return res;
}
```

---
处理用时：86.54秒
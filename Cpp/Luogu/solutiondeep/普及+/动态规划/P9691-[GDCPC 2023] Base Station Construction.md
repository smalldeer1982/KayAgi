# 题目信息

# [GDCPC 2023] Base Station Construction

## 题目描述

中国移动通信集团广东有限公司深圳分公司（以下简称``深圳移动``）于 $1999$ 年正式注册。四年后，广东省大学生程序设计竞赛第一次举办。深圳移动与广东省大学生程序设计竞赛一起见证了广东省计算机行业的兴旺与发展。

在建设通信线路的过程中，信号基站的选址是一个非常关键的问题。某城市从西到东的距离为 $n$ 千米，工程师们已经考察了在从西往东 $1, 2, \cdots, n$ 千米的位置建设基站的成本，分别是 $a_1, a_2, \cdots, a_n$。

为了保证居民的通信质量，基站的选址还需要满足 $m$ 条需求。第 $i$ 条需求可以用一对整数 $l_i$ 和 $r_i$ 表示（$1 \le l_i \le r_i \le n$），代表从西往东 $l_i$ 千米到 $r_i$ 千米的位置之间（含两端）至少需要建设 $1$ 座基站。

作为总工程师，您需要决定基站的数量与位置，并计算满足所有需求的最小总成本。

## 样例 #1

### 输入

```
2
5
3 2 4 1 100
3
1 3
2 4
5 5
5
7 3 4 2 2
3
1 4
2 3
4 5```

### 输出

```
102
5```

# AI分析结果



### 综合分析与结论
本题要求选择若干点满足区间覆盖约束且总成本最小，核心解法为动态规划结合单调队列优化。各题解均采用 `f[i]` 表示选第 `i` 个点的最小成本，预处理 `pre[i]` 确定转移范围，利用单调队列高效维护最小值。关键点包括：
1. **预处理 `pre[i]`**：记录右端点小于 `i` 的区间左端点最大值，确保转移合法性。
2. **单调队列优化**：维护合法转移点的最小值，将时间复杂度优化至 `O(n)`。
3. **虚点技巧**：在末尾添加零成本虚点，简化答案获取。

### 高星题解推荐

#### 1. sunzz3183（5星）
- **关键亮点**  
  - 预处理 `pre` 数组的方式简洁高效，通过区间右端点快速更新左端点限制。  
  - 代码结构清晰，利用单调队列直接维护合法转移点，逻辑紧凑。  
  - 引入虚点 `n+1` 巧妙简化答案计算。  
- **核心代码**  
  ```cpp
  // 预处理 pre 数组
  for (int i=1;i<=m;i++) {
      int l=read(), r=read();
      pre[r+1] = max(pre[r+1], l); // 右端点+1处记录左端点限制
  }
  for (int i=2;i<=n;i++) pre[i] = max(pre[i], pre[i-1]); // 前缀最大值
  
  // 单调队列优化 DP
  deque<int> q;
  q.push_back(0);
  for (int i=1;i<=n;i++) {
      while (!q.empty() && q.front() < pre[i]) q.pop_front();
      f[i] = f[q.front()] + a[i];
      while (!q.empty() && f[q.back()] >= f[i]) q.pop_back();
      q.push_back(i);
  }
  ```

#### 2. xtzqhy（5星）
- **关键亮点**  
  - 代码实现高度精简，完全聚焦核心逻辑。  
  - 预处理与单调队列维护一气呵成，无冗余操作。  
- **调试心得**  
  > "CSP 因为这个爆了，所以来写题解。" —— 强调预处理 `pre` 的正确性对边界条件的重要性。  
- **核心代码**  
  ```cpp
  // 预处理 pre 并转移
  for (int i=1; i<=n; i++) {
      while (h<=t && q[h] < pre[i]) h++; // 维护队首合法性
      f[i] = f[q[h]] + a[i];
      while (h<=t && f[q[t]] >= f[i]) t--; // 维护队列单调性
      q[++t] = i;
  }
  ```

#### 3. coding_goat（4星）
- **关键亮点**  
  - 注释详细，适合初学者理解单调队列的维护过程。  
  - 变量命名明确（如 `h`、`t` 表示队首队尾），代码可读性强。  
- **核心代码**  
  ```cpp
  // 单调队列维护最小值
  int h=1, t=1;
  q[1] = 0;
  for (int i=1; i<=n+1; i++) {
      while (h<=t && q[h] < pre[i]) h++;
      f[i] = f[q[h]] + a[i];
      while (h<=t && f[q[t]] >= f[i]) t--;
      q[++t] = i;
  }
  ```

### 关键思路与技巧总结
1. **预处理 `pre` 数组**：将区间约束转化为每个位置 `i` 的最小合法转移起点。  
2. **单调队列优化**：维护滑动窗口最小值，避免重复计算。  
3. **虚点技巧**：在序列末尾添加零成本点，将答案转化为 `f[n+1]`。  

### 拓展与相似题目
- **同类题目**  
  - [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)：单调队列模板题。  
  - [P3957 跳房子](https://www.luogu.com.cn/problem/P3957)：结合二分与单调队列优化。  
  - [P2569 股票交易](https://www.luogu.com.cn/problem/P2569)：复杂状态转移中的单调队列应用。

---
处理用时：61.65秒
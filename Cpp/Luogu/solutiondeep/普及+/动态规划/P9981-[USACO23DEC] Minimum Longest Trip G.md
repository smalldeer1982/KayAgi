# 题目信息

# [USACO23DEC] Minimum Longest Trip G

## 题目描述

Bessie 正在奶牛大陆上旅行。奶牛大陆由从 $1$ 到 $N$ 编号的 $N$（$2 \le N \le 2\cdot 10^5$）座城市和 $M$（$1 \le M \le 4\cdot 10^5$）条单向道路组成。第 $i$ 条路从城市 $a_i$ 通向城市 $b_i$，标签为 $l_i$。

由城市 $x_0$ 开始的长度为 $k$ 的旅程被定义为一个城市序列 $x_0,x_1,\ldots,x_k$，对于所有的 $0 \le i < k$，存在由城市 $x_i$ 到 $x_{i+1}$ 的路。保证在奶牛大路上不存在长度无限的旅程，不存在两条路连接一对相同的城市。

对于每座城市，Bessie 想知道从它开始的最长旅程。对于一些城市，从它们开始的最长旅程不唯一，Bessie 将选择其中道路标签序列字典序更小的旅程。一个序列比等长的另一个序列字典序更小，当且仅当在它们不同的第一个位置，前者比后者的元素更小。

输出 Bessie 在每座城市选择的旅途的长度和道路标签之和。

## 说明/提示

### 样例解释 2

在下面的解释中，我们用 $a_i\xrightarrow{l_i} b_i$ 表示由城市 $a_i$ 通往 $b_i$，标签为 $l_i$ 的单向道路。

从城市 $4$ 出发有多条旅程，包含 $4\xrightarrow{4} 3\xrightarrow 5 1$，$4\xrightarrow 1 1$ 和 $4\xrightarrow 2 2\xrightarrow{10} 1$。在这些旅程中，$4\xrightarrow{4} 3\xrightarrow 5 1$ 和 $4\xrightarrow 2 2\xrightarrow{10} 1$ 是最长的。它们的长度均为 $2$，道路标签序列分别为 $[4,5]$ 和 $[2,10]$。$[2,10]$ 是字典序更小的那一个，它的和为 $12$。

### 测试点性质

- 测试点 $5-6$ 满足所有道路的标签相同。
- 测试点 $7-8$ 满足所有道路的标签不相同。
- 测试点 $9-10$ 满足 $N,M \le 5000$。
- 测试点 $11-20$ 没有额外限制。

## 样例 #1

### 输入

```
4 5
4 3 10
4 2 10
3 1 10
2 1 10
4 1 10```

### 输出

```
0 0
1 10
1 10
2 20```

## 样例 #2

### 输入

```
4 5
4 3 4
4 2 2
3 1 5
2 1 10
4 1 1```

### 输出

```
0 0
1 10
1 5
2 12```

## 样例 #3

### 输入

```
4 5
4 3 2
4 2 2
3 1 5
2 1 10
4 1 1```

### 输出

```
0 0
1 10
1 5
2 7```

## 样例 #4

### 输入

```
4 5
4 3 2
4 2 2
3 1 10
2 1 5
4 1 1```

### 输出

```
0 0
1 5
1 10
2 7```

# AI分析结果



### 综合分析与结论
各题解核心均基于拓扑排序处理最长路径，核心差异在于字典序比较策略。分层处理+优先级排序（0000pnc、学委）与倍增哈希（cjh20090318）是两大主流方向。前者通过维护层级内排名实现O(nlogn)复杂度，后者利用哈希+倍增实现高效字典序比较。实际应用中分层排序方案更易实现，而倍增哈希理论复杂度更优。

---

### 精选题解

#### 1. 0000pnc（4星）
**核心亮点**：  
- 分层拓扑排序维护层级内排名  
- 用优先队列动态维护字典序优先级  
- 代码简洁且复杂度严格O(nlogn)

**代码核心**：
```cpp
struct res { int e, rnk, to; };
priority_queue<res> pq; // 按边权和排名维护转移优先级
for每个层级节点:
    选取最小边权+最大排名的转移点
    通过优先队列维护当前层排名
```

#### 2. 学委（4星）
**核心亮点**：  
- 显式分层后对同层节点统一排序  
- 通过预计算最优转移点简化比较逻辑  
- 易理解的层级间递推结构

**核心实现**：
```cpp
sort(ids + 1, ids + cnt + 1, [&](int a, int b) {
    return 边权小 || (边权相同 && 转移点排名小) 
});
for每个节点维护最优转移点nxt[u]
```

#### 3. cjh20090318（5星）
**核心亮点**：  
- 倍增哈希实现O(1)级别字典序比较  
- 严格线性预处理保证效率  
- 可拓展性强的哈希比较框架

**关键代码**：
```cpp
// 倍增预处理哈希
for(int k=1;k<19;k++)
    fa[u][k] = fa[fa[u][k-1]][k-1],
    hs[u][k] = hs[fa[u][k-1]][k-1] * pn[1<<(k-1)] + hs[u][k-1];

// 比较时跳倍增
for(int k=18;k>=0;k--)
    if(哈希相同则继续跳)
找到首个不同位比较
```

---

### 最优技巧总结
1. **分层拓扑排序**：将节点按最长路径长度分层，逐层处理保证无后效性  
2. **字典序比较优化**：  
   - 优先级队列维护当前层最优转移  
   - 倍增哈希预处理实现快速LCP比较  
3. **边权+排名双关键字**：在相同边权时通过下层节点排名打破平局  

---

### 推荐练习
1. P3387 【模板】缩点 - DAG最长路经典问题  
2. P3243 [HNOI2015]菜肴制作 - 拓扑排序与字典序结合  
3. P3573 [POI2014]RAJ-Rally - DAG关键路径变形  

---

### 调试经验摘录
**cjh20090318**：  
> "哈希要处理到足够位数，否则不同路径可能哈希碰撞"  
**学委**：  
> "必须倒序处理拓扑序列才能保证最长路径正确性"  
**0000pnc**：  
> "优先队列要同时存储边权和下层排名，缺一不可"

---
处理用时：54.79秒
# 题目信息

# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# AI分析结果

### 综合分析与结论
本题要求在长度为 $N$ 的数字串中插入 $K$ 个乘号，使分成的 $K + 1$ 个部分乘积最大，由于 $N$ 最大为 40，需使用高精度计算。题解主要分为动态规划和深度优先搜索（DFS）两种思路。

动态规划思路通过定义状态和状态转移方程，枚举乘号位置来求解最大乘积，时间复杂度一般为 $O(n^2 \times k)$。DFS 思路则是枚举所有可能的乘号插入位置，计算每种情况的乘积并取最大值，通过剪枝优化搜索过程。

### 所选题解
1. **作者：liar_white（5星）**
    - **关键亮点**：思路清晰，代码注释详细，使用结构体实现高精度计算，便于理解。
    - **核心代码**：
```cpp
// 取数操作
node culc(int l, int r) {
    node e;
    e.v = r - l + 1; e.exi = true;
    for (int i = 1; i <= e.v; i++) {
        e.c[i] = a[r - i + 1];
    }
    return e;
}
// 高精度乘法
node mul(node e1, node e2) {
    node emul;
    emul.exi = true; emul.v = e1.v + e2.v - 1;
    for (int i = 1; i <= emul.v; i++) emul.c[i] = 0;
    for (int i = 1; i <= e1.v; i++)
        for (int j = 1; j <= e2.v; j++)
            emul.c[i + j - 1] += e1.c[i] * e2.c[j];
    int q = 0;
    for (int i = 1; i <= emul.v; i++) {
        emul.c[i] += q;
        q = emul.c[i] / 10;
        emul.c[i] %= 10;
    }
    while (q > 0) {
        emul.c[++emul.v] = q % 10;
        q /= 10;
    }
    return emul;
}
// 高精度比较
node Max(node e1, node e2) {
    if (!e1.exi || e1.v < e2.v) return e2;
    if (!e2.exi || e2.v < e1.v) return e1;
    for (int i = e1.v; i >= 1; i--) {
        if (e1.c[i] > e2.c[i]) return e1;
        else if (e2.c[i] > e1.c[i]) return e2;
    }
    return e1;
}
```
    - **核心思想**：通过 `culc` 函数取数，`mul` 函数实现高精度乘法，`Max` 函数进行高精度比较，在动态规划过程中不断更新最大值。

2. **作者：FastIO_DP（4星）**
    - **关键亮点**：代码结构清晰，使用结构体重载运算符实现高精度计算，复杂度分析明确。
    - **核心代码**：
```cpp
struct BI {
    int d[100];
    int len;
    // 构造函数等省略
    BI operator*(const BI& o) const {
        BI res;
        for (int i = 0; i < len; ++i) {
            int c = 0;
            for (int j = 0; j < o.len; ++j) {
                int p = d[i] * o.d[j] + res.d[i + j] + c;
                res.d[i + j] = p % 10;
                c = p / 10;
            }
            if (c) {
                res.d[i + o.len] += c;
            }
        }
        res.len = len + o.len;
        while (res.len > 1 && res.d[res.len - 1] == 0) {
            res.len--;
        }
        return res;
    }
    bool operator<(const BI& o) const {
        if (len!= o.len) {
            return len < o.len;
        }
        for (int i = len - 1; i >= 0; --i) {
            if (d[i]!= o.d[i]) {
                return d[i] < o.d[i];
            }
        }
        return false;
    }
};
```
    - **核心思想**：定义 `BI` 结构体表示大整数，重载乘法和小于运算符，方便进行高精度计算和比较，在动态规划中使用这些操作更新状态。

3. **作者：kuaiCreator（4星）**
    - **关键亮点**：对划分型动态规划的思路解释详细，给出了状态定义、转移方程、初始化等步骤，还提供了不带高精度的代码示例。
    - **核心代码**：
```cpp
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
        if (j >= i) break;
        for (int k = j; k < i; k++)
            dp[i][j] = max(dp[i][j], dp[k][j - 1] * num[k + 1][i]);
    }
```
    - **核心思想**：通过三层循环枚举前 $i$ 个数、插入乘号的数量 $j$ 和插入位置 $k$，根据状态转移方程更新 $dp$ 数组，最终得到最大乘积。

### 最优关键思路或技巧
- **动态规划**：定义合适的状态和状态转移方程，通过枚举乘号位置，利用子问题的最优解来求解原问题。
- **高精度计算**：使用结构体或数组存储大整数，实现高精度乘法、比较等操作。
- **剪枝优化**：在 DFS 中，通过可行性剪枝减少不必要的搜索，如保证后面的乘号有位置可占。

### 可拓展之处
同类型题如在数字串中插入其他运算符（如加号、减号）求最值，或在矩阵中划分区域求乘积最值等，都可以使用类似的动态规划或搜索思路。

### 推荐题目
1. [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)：考察动态规划中的 0 - 1 背包问题。
2. [P1216 [USACO1.5] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：经典的动态规划入门题，与本题的状态转移思想类似。
3. [P1176 路径计数2](https://www.luogu.com.cn/problem/P1176)：涉及动态规划和高精度计算，可进一步巩固相关知识。

### 个人心得摘录与总结
- **作者：liar_white**：写这道题用了半上午，写完注释感觉代码很简单，但实际编写时花费了较多时间，说明实际实现和理论理解存在差距，需要多实践。
- **作者：sunyt**：没多想直接用 DFS 做，竟然一遍 AC，感到害怕，说明有时候大胆尝试可能会取得好结果，但也需要对算法有一定的理解。 

---
处理用时：40.30秒
# 题目信息

# [NOIP 2001 提高组] 一元三次方程求解

## 题目描述

有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。

提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。

## 说明/提示

**【题目来源】**

NOIP 2001 提高组第一题

## 样例 #1

### 输入

```
1 -5 -4 20
```

### 输出

```
-2.00 2.00 5.00
```

# AI分析结果

### 综合分析与结论
这些题解围绕一元三次方程求解展开，提供了多种算法思路，包括暴力枚举、二分法、盛金公式、牛顿迭代法、割线法等。暴力枚举简单直接，适用于数据范围小的情况；二分法利用函数零点存在定理，在区间内不断缩小区间范围；盛金公式和卡尔丹公式是数学公式法，可直接计算方程的根，但公式复杂；牛顿迭代法和割线法是迭代法，通过不断迭代逼近方程的根。

### 所选题解
- **作者：北街的九命貓（912赞），4星**
    - **关键亮点**：思路清晰，先阐述二分法原理，再给出详细代码实现，注释丰富，易于理解。
- **作者：GGN_2015（197赞），4星**
    - **关键亮点**：使用牛顿迭代法求解，提供了一种新的思路，代码结构清晰，对迭代过程有详细实现。
- **作者：高木木（177赞），4星**
    - **关键亮点**：采用暴力枚举法，代码简洁，通过合理控制枚举步长，能有效解决问题。

### 重点代码及核心实现思想
#### 北街的九命貓（二分法）
```cpp
double fc(double x)
{
    return a*x*x*x+b*x*x+c*x+d;
}
int main()
{
    double l,r,m,x1,x2;
    int s=0,i;
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
    for (i=-100;i<100;i++)
    {
        l=i; 
        r=i+1;
        x1=fc(l); 
        x2=fc(r);
        if(!x1) 
        {
            printf("%.2lf ",l); 
            s++;
        }
        if(x1*x2<0)
        {
            while(r-l>=0.001)
            {
                m=(l+r)/2;
                if(fc(m)*fc(r)<=0) 
                   l=m; 
                else 
                   r=m;
            }
            printf("%.2lf ",r);  
            s++;
        }
        if (s==3) 
            break;
    }
    return 0;
}
```
**核心思想**：利用函数零点存在定理，枚举长度为1的区间，若区间两端点函数值异号，则在该区间内进行二分查找，不断缩小区间范围，直到满足精度要求。

#### GGN_2015（牛顿迭代法）
```cpp
struct func3
{
    double a,b,c,d;
    func3(double A=0,double B=0,double C=0,double D=0){a=A;b=B;c=C;d=D;}
    double operator()(double x){return ((a*x+b)*x+c)*x+d;}
    double dvt(double x){return (3.0*a*x+2.0*b)*x+c;}
};

void func3solve(func3 f,double st,double& val,double& sol)
{
    for(int i=1;!(abs(f(st))<1e-6) && i<=100;i++)
    {
        st=st-f(st)/f.dvt(st);
    }
    val=f(st);sol=st;
}

int main()
{
    double a,b,c,d;
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
    func3 f(a,b,c,d);
    for(double i=-100.0;i<=100.0;i+=0.5)
    {
        double val,sol;
        func3solve(f,i,val,sol);
        sol=fix2(sol);
        if(abs(val)<1e-6 && solutions.find(sol)==solutions.end())
            solutions.insert(sol);
    }
    for(set<double>::iterator it=solutions.begin();it!=solutions.end();it++)
    {
        double x=(*it);
        printf("%.2lf ",x);
    }
    return 0;
}
```
**核心思想**：通过不断迭代，根据函数在某点的导数，将 $x$ 移动到切线与 $x$ 轴相交的地方，直到函数值足够接近0。

#### 高木木（暴力枚举法）
```cpp
int main()
{
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
    for(double i=-100.00;i<=100.00;i+=0.001)
    {
        double l=i,r=i+0.001;
        if((a*l*l*l+b*l*l+c*l+d)*(a*r*r*r+b*r*r+c*r+d)<0)
            printf("%.2f ",l),num++;
        if(num==3) break;
    }
    return 0;
}
```
**核心思想**：从 $-100$ 到 $100$ 以 $0.001$ 为步长枚举，若相邻两个数的函数值异号，则认为中间存在根，输出该根。

### 最优关键思路或技巧
- **利用函数零点存在定理**：若 $f(x_1) \times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根，可用于判断区间内是否存在根。
- **合理控制枚举步长**：在暴力枚举时，根据精度要求合理控制枚举步长，可提高效率。
- **迭代法逼近根**：牛顿迭代法和割线法通过不断迭代，逐步逼近方程的根。

### 可拓展之处
- **同类型题**：求解其他高次方程的根，可根据方程特点选择合适的算法。
- **类似算法套路**：对于一些难以直接求解的方程，可采用迭代法、二分法等数值计算方法逼近解。

### 推荐题目
- P1314 [NOIP2011 提高组] 聪明的质监员
- P1028 [NOIP2001 普及组] 数的计算
- P1075 [NOIP2012 普及组] 质因数分解

### 个人心得摘录与总结
- **小菜鸟**：提到割线法是基于牛顿法的改进，用割线代替导数进行迭代求解，比牛顿法略慢，但避免了求导的困难。在实现时，要注意控制步长，避免出现除以零的情况。
- **cff_0102**：指出盛金公式虽然简便，但在考场上很难记住，暴力枚举是一种更可行的方法，对于数据范围小的问题，可直接枚举求解。

---
处理用时：42.14秒
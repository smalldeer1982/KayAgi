# 题目信息

# [NOIP 2001 提高组] Car 的旅行路线

## 题目描述

又到暑假了，住在城市 A 的 Car 想和朋友一起去城市旅游。  
她知道每个城市都有 $4$ 个飞机场，分别位于一个矩形的 $4$ 个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第 $i$ 个城市中高速铁路的单位里程价格为 $T_i$，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为 $t$。


![](https://cdn.luogu.com.cn/upload/image_hosting/odqxn9sz.png)

**注意**：图中并没有标出所有的铁路与航线。


那么 Car 应如何安排到城市 B 的路线才能尽可能的节省花费呢？她发现这并不是一个简单的问题，于是她来向你请教。


找出一条从城市 A 到 B 的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10$，$1\le S \le 100$，$1\le A,B \le S$。

**【题目来源】**

NOIP 2001 提高组第四题

## 样例 #1

### 输入

```
1
3 10 1 3
1 1 1 3 3 1 30
2 5 7 4 5 2 1
8 6 8 8 11 6 3```

### 输出

```
47.5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何解决从城市 A 到城市 B 的最小花费路线问题。整体思路分为两大部分：一是根据输入的矩形三个点坐标求出第四个点坐标；二是运用最短路算法计算最小花费。在最短路算法的选择上，有使用 Floyd 算法的，也有使用 Dijkstra 算法和 SPFA 算法的。

### 所选题解
- **作者：_jimmywang_（5 星）**
    - **关键亮点**：思路清晰，详细阐述了建图和求最短路的步骤，代码简洁明了，对数据范围进行了分析从而选择合适的算法。
    - **核心代码**：
```cpp
double diss(double x1,double y1,double x2,double y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
double ds(double x1,double y1,double x2,double y2){return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);}
// 建图
f(i,1,s){
    scanf("%lf%lf%lf%lf%lf%lf%lf",&x[(i-1)*4+1],&y[(i-1)*4+1],&x[(i-1)*4+2],&y[(i-1)*4+2],&x[(i-1)*4+3],&y[(i-1)*4+3],&T[i]);
    double dab=ds(x[(i-1)*4+1],y[(i-1)*4+1],x[(i-1)*4+2],y[(i-1)*4+2]);
    double dac=ds(x[(i-1)*4+1],y[(i-1)*4+1],x[(i-1)*4+3],y[(i-1)*4+3]);
    double dbc=ds(x[(i-1)*4+2],y[(i-1)*4+2],x[(i-1)*4+3],y[(i-1)*4+3]);
    if(dab+dac==dbc)x[i*4]=x[(i-1)*4+2]+x[(i-1)*4+3]-x[(i-1)*4+1],y[i*4]=y[(i-1)*4+2]+y[(i-1)*4+3]-y[(i-1)*4+1];else
    if(dab+dbc==dac)x[i*4]=x[(i-1)*4+1]+x[(i-1)*4+3]-x[(i-1)*4+2],y[i*4]=y[(i-1)*4+1]+y[(i-1)*4+3]-y[(i-1)*4+2];else
    if(dbc+dac==dab)x[i*4]=x[(i-1)*4+2]+x[(i-1)*4+1]-x[(i-1)*4+3],y[i*4]=y[(i-1)*4+2]+y[(i-1)*4+1]-y[(i-1)*4+3];
}
f(i,1,s*4)f(j,1,s*4)if(i!=j){
    if((i-1)/4!=(j-1)/4)dis[i][j]=t*diss(x[i],y[i],x[j],y[j]);
    else dis[i][j]=T[(i-1)/4+1]*diss(x[i],y[i],x[j],y[j]);
}
// Floyd 最短路
f(k,1,s*4)f(i,1,s*4)f(j,1,s*4)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
f(i,1,4)f(j,1,4)ans=min(ans,dis[(A-1)*4+i][(B-1)*4+j]);
```
    - **核心思想**：先根据勾股定理判断哪两个点构成对角线，从而求出矩形的第四个点坐标。然后根据点所在城市判断是城市内铁路还是城市间航线，计算距离并建图。最后使用 Floyd 算法求出最短路，比较 A 城市各机场到 B 城市各机场的花费得到最小值。

- **作者：ShineEternal（4 星）**
    - **关键亮点**：使用堆优化的 Dijkstra 算法，对求矩形第四个点的过程有详细的代码实现，且提到了结构体存储方式的重要性。
    - **核心代码**：
```cpp
void find(double a,double b,double c,double d,double e,double f)
{
    cnt++;
    dis[1].num=sqrt(Sqr(a-c)+Sqr(b-d)); 
    dis[1].id=1;
    dis[2].num=sqrt(Sqr(e-c)+Sqr(f-d)); 
    dis[2].id=2;
    dis[3].num=sqrt(Sqr(a-e)+Sqr(b-f));
    dis[3].id=3;
    sort(dis+1,dis+4,cmp);
    if(dis[1].id==1)
    {
        double x=min(a,c)+Abs(a-c)/2;
        double y=min(b,d)+Abs(b-d)/2;
        double xn=x+x-e;
        double yn=y+y-f;
        p[cnt].x=xn;
        p[cnt].y=yn;
    }
    // 其他情况类似
}
void dijkstra(int s)
{
    memset(vis,0,sizeof(vis));
    d[s][s]=0;
    q.push(make_pair(0,s));
    while(!q.empty())
    {
        int x=q.top().second;
        q.pop();
        if(vis[x]==1)
            continue;
        vis[x]=1;
        for(int i=1;i<=cnt;i++)
        {
            if(d[s][x]+dist[x][i]<d[s][i])
            {
                d[s][i]=d[s][x]+dist[x][i];
                q.push(make_pair(d[s][i],i));
            }
        }
    }
}
```
    - **核心思想**：通过计算三个点两两之间的距离，找出距离最远的两个点，取中点后根据中点和另一个点求出矩形的第四个点坐标。建图后使用堆优化的 Dijkstra 算法求最短路。

- **作者：LiJunze0501（4 星）**
    - **关键亮点**：详细说明了求直角点和第四个点坐标的方法，代码结构清晰，同样使用 Floyd 算法解决问题。
    - **核心代码**：
```cpp
void getair4(int id){
    double d12=pf(air[4*(id-1)+1].x-air[4*(id-1)+2].x)+pf(air[4*(id-1)+1].y-air[4*(id-1)+2].y);
    double d23=pf(air[4*(id-1)+2].x-air[4*(id-1)+3].x)+pf(air[4*(id-1)+2].y-air[4*(id-1)+3].y);
    double d13=pf(air[4*(id-1)+1].x-air[4*(id-1)+3].x)+pf(air[4*(id-1)+1].y-air[4*(id-1)+3].y);
    if(d12+d13==d23){
        air[4*id].x=air[4*(id-1)+2].x+air[4*(id-1)+3].x-air[4*(id-1)+1].x;
        air[4*id].y=air[4*(id-1)+2].y+air[4*(id-1)+3].y-air[4*(id-1)+1].y;	
    }
    // 其他情况类似
}
// Floyd 最短路
for(int k=1;k<=4*s;k++)
    for(int i=1;i<=4*s;i++)
        for(int j=1;j<=4*s;j++)
            if(i!=j&&j!=k&&i!=k) cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);
```
    - **核心思想**：根据勾股定理判断直角点，进而求出矩形的第四个点坐标。建图后使用 Floyd 算法更新各机场之间的最小花费。

### 最优关键思路或技巧
- **坐标计算**：利用矩形对角线互相平分的性质，通过已知三个点坐标求出第四个点坐标。
- **编号技巧**：将每个城市的 4 个机场依次编号，通过编号计算点所在的城市，方便判断是城市内还是城市间的路线。
- **算法选择**：根据数据范围选择合适的最短路算法，如本题数据范围较小，可使用 $O(n^3)$ 的 Floyd 算法。

### 拓展思路
同类型题可能会改变图的结构、增加约束条件或更换最短路算法的应用场景。例如，可能会出现三维空间中的点，或者增加不同时间段的价格变化等。类似算法套路包括先根据条件构建图，再运用合适的图算法求解问题。

### 推荐题目
- P3371 【模板】单源最短路径（弱化版）：考察 Dijkstra 或 SPFA 算法的基本应用。
- P1119 灾后重建：结合 Floyd 算法和时间因素，有一定的思维难度。
- P4779 【模板】单源最短路径（标准版）：使用堆优化的 Dijkstra 算法求解最短路。

### 个人心得摘录与总结
- **ShineEternal**：提到结构体的存储方式要想好，刚开始以一个城市为一个结构体导致代码难写，最后重构代码。总结：在设计数据结构时要充分考虑后续操作的便利性，避免因不合理的存储方式导致代码复杂度增加。 

---
处理用时：54.73秒
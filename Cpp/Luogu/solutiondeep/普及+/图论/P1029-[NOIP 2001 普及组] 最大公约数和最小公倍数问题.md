# 题目信息

# [NOIP 2001 普及组] 最大公约数和最小公倍数问题

## 题目描述

输入两个正整数 $x_0, y_0$，求出满足下列条件的 $P, Q$ 的个数：

1. $P,Q$ 是正整数。

2. 要求 $P, Q$ 以 $x_0$ 为最大公约数，以 $y_0$ 为最小公倍数。

试求：满足条件的所有可能的 $P, Q$ 的个数。

## 说明/提示

$P,Q$ 有 $4$ 种：

1. $3, 60$。
2. $15, 12$。
3. $12, 15$。
4. $60, 3$。

对于 $100\%$ 的数据，$2 \le x_0, y_0 \le {10}^5$。

**【题目来源】**

NOIP 2001 普及组第二题

## 样例 #1

### 输入

```
3 60
```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均围绕两个数的积等于它们最大公约数和最小公倍数的积这一关键性质展开。通过枚举因数并结合最大公约数的判断来找出满足条件的数对。不同题解在实现细节和优化方式上存在差异，部分题解采用素因数分解的方法，部分则直接枚举因数。在优化方面，多数题解通过只枚举到 $\sqrt{x_0\times y_0}$ 来减少不必要的计算，同时对 $x_0 = y_0$ 的情况进行特判以避免重复计数。

### 所选题解
- **作者：樱雪喵 (赞：678)，4星**
    - **关键亮点**：思路清晰，代码简洁，对枚举范围的优化和特殊情况的处理解释详细，还对评论区常见问题进行统一回答。
- **作者：sochiji (赞：259)，4星**
    - **关键亮点**：从素因数分解的角度深入分析问题，给出了独特的解题思路和证明过程，具有较高的数学理论性。
- **作者：zhangboju (赞：61)，4星**
    - **关键亮点**：详细证明了辗转相除法求最大公约数以及最大公约数与最小公倍数乘积等于两数乘积的定理，逻辑严谨。

### 重点代码及核心实现思想
#### 樱雪喵的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long m,n,ans;
int main(){
    cin>>m>>n;
    if(m==n) ans--;
    n*=m;
    for(long long i=1;i<=sqrt(n);i++){
        if(n%i==0&&__gcd(i,n/i)==m) ans+=2;
    }
    cout<<ans;
    return 0;
}
```
**核心实现思想**：先将两数的积存入 `n` 中，然后从 1 到 $\sqrt{n}$ 枚举因数 `i`，若 `n` 能被 `i` 整除且 `i` 与 `n/i` 的最大公约数等于 `m`，则答案加 2，最后对 `m == n` 的情况进行特判。

#### sochiji 的代码
```cpp
#include <iostream>
int main()
{
    int x, y;
    std::cin >> x >> y;
    if (y % x != 0)
        std::cout << 0;
    else
    {
        int quotient = y / x;
        int count = 0;
        int currentFactor = 2;
        while (quotient > 1)
        {
            if (quotient % currentFactor == 0)
            {
                count++;
                while (quotient % currentFactor == 0)
                    quotient /= currentFactor;
            }
            currentFactor++;
        }
        std::cout << (1 << count);
    }
    return 0;
}
```
**核心实现思想**：先判断 `y` 是否能被 `x` 整除，若不能则输出 0。若能，则对 `y/x` 进行素因数分解，统计指数大于 0 的素因子个数 `count`，最后输出 $2^{count}$。

#### zhangboju 的代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long x,y;
inline long long gcd(long long x,long long y)
{
    if(y==0) return x;
    return gcd(y,x%y);
}
int main()
{
    cin>>x>>y;
    long long ans=0;
    for(long long i=1;i<=sqrt(x*y);i++)
    {
        if(x*y%i==0&&gcd(i,x*y/i)==x) ans++;
    }
    ans*=2;
    if(x==y) ans--;
    cout<<ans;
    return 0;
}
```
**核心实现思想**：自定义 `gcd` 函数求最大公约数，从 1 到 $\sqrt{x*y}$ 枚举因数 `i`，若 `x*y` 能被 `i` 整除且 `i` 与 `x*y/i` 的最大公约数等于 `x`，则答案加 1，最后答案乘 2 并对 `x == y` 的情况进行特判。

### 最优关键思路或技巧
- **枚举优化**：只枚举到 $\sqrt{x_0\times y_0}$，因为对于不同的 $x,y$，交换它们的值一定可以得到另一组与之对应的解，这样可以避免重复计算。
- **特殊情况特判**：当 $x_0 = y_0$ 时，$x=y=\gcd(x,y)=\operatorname{lcm}(x,y)$，这种情况会被重复计算，需要将答案减 1。
- **素因数分解**：通过对 $\frac{y_0}{x_0}$ 进行素因数分解，统计指数大于 0 的素因子个数，利用组合数的思想计算满足条件的数对个数。

### 可拓展之处
同类型题或类似算法套路包括：
- 已知最大公约数和最小公倍数，求满足条件的数的具体组合。
- 给定多个数，求它们的最大公约数和最小公倍数的相关问题。
- 涉及数论中因数、倍数、素数等概念的题目。

### 推荐洛谷题目
- P1072 [NOIP2009 提高组] Hankson 的趣味题
- P1306 斐波那契公约数
- P2152 [SDOI2009] SuperGCD

### 个人心得摘录与总结
- **sochiji**：尽量避免生搬公式符号，多使用通俗的语言来说明，方便理解。
- **陈嘉逸2012**：这道题有点难，听了课才会，说明对于较难的题目可以通过学习和请教来掌握。

---
处理用时：36.44秒
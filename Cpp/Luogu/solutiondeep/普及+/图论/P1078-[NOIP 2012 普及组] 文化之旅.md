# 题目信息

# [NOIP 2012 普及组] 文化之旅

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。由于测试数据过水，可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）。本题题目和数据仅供参考。本题不接受添加 hack 数据。

本题为错题。**不建议尝试或提交本题。**[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。

现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。


## 说明/提示

输入输出样例说明$1$

由于到国家 $2$ 必须要经过国家$ 1$，而国家$ 2 $的文明却排斥国家 $1$ 的文明，所以不可能到达国家 $2$。


输入输出样例说明$2$

路线为$ 1$ ->$ 2$

【数据范围】

对于 100%的数据，有$ 2≤N≤100$

$1≤K≤100$ 

$1≤M≤N^2$

$1≤k_i≤K$

$1≤u, v≤N$ 

$1≤d≤1000,S≠T,1≤S,T≤N$

NOIP 2012 普及组 第四题


## 样例 #1

### 输入

```
2 2 1 1 2 
1 2 
0 1 
1 0 
1 2 10 
```

### 输出

```
-1```

## 样例 #2

### 输入

```
2 2 1 1 2 
1 2 
0 1 
0 0 
1 2 10 ```

### 输出

```
10```

# AI分析结果

### 综合分析与结论
这些题解主要围绕图论中最短路问题展开，结合文化排斥和文化不重复学习的限制条件。题解使用的算法包括 DFS、BFS、Floyd、Dijkstra、A* 等，通过不同的剪枝和状态标记方法来满足题目要求。各题解的思路和实现细节有所不同，但核心都是在图中寻找满足条件的最短路径。

### 所选题解
- **作者：Created_equal1（4星）**
  - **关键亮点**：采用启发式搜索，先跑一遍无视文化排斥的最短路作为剪枝依据，有效减少搜索空间，提高效率。
  - **个人心得**：指出许多题解依靠数据水才过，认为正解应该是启发式搜索。
- **作者：tommymio（4星）**
  - **关键亮点**：使用 Dijkstra 算法并结合前继数组维护路径，在松弛操作前判断文化是否冲突，思路清晰，代码实现简洁。
  - **个人心得**：提到本题有坑点，如存图要正反存两遍，文化排斥是单向的，不能用并查集。
- **作者：grard4（4星）**
  - **关键亮点**：使用 A* 算法，通过去除无用边优化复杂度，用 bitset 合并判断是否学习被排斥的文化，进一步优化时间复杂度。
  - **个人心得**：指出 A* 可以草过这题，且能通过更强一点的数据。

### 重点代码及核心实现思想
#### Created_equal1 的题解
```cpp
// 跑无视文化排斥的最短路
void Spfa()
{
    memset(Dist, 0X7F, sizeof(Dist));
    queue<unsigned int> Q;
    Q.push(S);
    In_Q[S] = true;
    Dist[S] = 0;
    unsigned int Top;
    while (Q.size())
    {
        Top = Q.front();
        Q.pop();
        In_Q[Top] = false;
        for (size_t i = Head[Top];i;i = Next[i])
            if (Dist[To[i]] > Dist[Top] + Weight[i])
            {
                Dist[To[i]] = Dist[Top] + Weight[i];
                if (!In_Q[To[i]])
                {
                    In_Q[To[i]] = true;
                    Q.push(To[i]);
                }
            }
    }
}

// 深度优先搜索
void Dfs(const size_t &Now, const unsigned int &D)
{
    Went[Now] = true;
    culture.insert(C[Now]);
    if (Now == S)
    {
        Ans = min(Ans, D);
        return;
    }
    if (D + Dist[Now] > Ans)
        return;
    for (size_t i = Head[Now];i;i = Next[i])
        if (!Went[To[i]] && check(C[To[i]]))
            Dfs(To[i], D + Weight[i]);
    Went[Now] = false;
    culture.erase(C[Now]);
}
```
核心思想：先通过 SPFA 算法求出无视文化排斥的最短路，然后在深度优先搜索中，利用这个最短路进行剪枝，如果当前花费加上到终点的最短路大于当前答案，则不再继续搜索。

#### tommymio 的题解
```cpp
// 判断是否可以走
bool judge(int u,int v){
    int tmp=u;
    while(tmp){
        if(a[c[v]][c[tmp]]!=0||c[v]==c[tmp]){
            return false;
        }
        tmp=pre[tmp];
    }
    return true;
}

// Dijkstra 算法
void dijistra(int u){
    memset(dis,127/3,sizeof(dis));
    dis[u]=0;
    Q.push(make_pair(0,u));
    while(Q.size()){
        int k=Q.top().second;
        Q.pop();
        if(vis[k])	continue;
        vis[k]=1;
        for(int i=head[k];i;i=e[i].next){
            if(dis[e[i].to]>dis[k]+e[i].val&&judge(k,e[i].to)){
                pre[e[i].to]=k;
                dis[e[i].to]=dis[k]+e[i].val;
                Q.push(make_pair(dis[e[i].to],e[i].to));
            }
        }
    }
}
```
核心思想：使用 Dijkstra 算法，在松弛操作前，通过 `judge` 函数判断下一个点的文化是否与已走过的点的文化冲突，如果不冲突则进行松弛操作。

#### grard4 的题解
```cpp
// 对终点跑一遍最短路
void spfa(){
    memset(dis,0x7f,sizeof(dis));
    queue<int> Q;
    dis[t]=0;Q.push(t);
    while(!Q.empty()){
        int u=Q.front();Q.pop();
        vis[u]=false;
        for (int i=h2[u];i;i=e2[i].nxt){
            int v=e2[i].to,w=e2[i].val;
            if (dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                if (!vis[v]) vis[v]=true,Q.push(v);
            }
        }
    }
}

// A* 搜索
int main(){
    // ... 输入处理 ...
    spfa();
    if (dis[s]==dis[0]) {puts("-1");return 0;}
    bitset<MAXN> p;p.set(c[s]);
    q.push({s,0,p});
    while(!q.empty()){
        int u=q.top().u,w=q.top().w;
        if (u==t) {cout<<w<<endl;return 0;}
        bitset<MAXN> ok=q.top().ok;
        q.pop();
        for (int i=h1[u];i;i=e1[i].nxt){
            int v=e1[i].to,w1=e1[i].val;
            p=ok&a[c[v]];
            if (p.any()) continue;
            p=ok,p.set(c[v]);
            q.push({v,w+w1,p});
        }
    }
    puts("-1");
    return 0;
}
```
核心思想：先对终点跑一遍最短路，作为 A* 算法的估价函数。在 A* 搜索中，使用 `bitset` 合并判断是否学习被排斥的文化，若不冲突则将新状态加入优先队列。

### 最优关键思路或技巧
- **剪枝优化**：如 Created_equal1 先跑无视文化排斥的最短路，在搜索时进行剪枝，减少不必要的搜索。
- **状态标记**：使用数组或 `bitset` 标记已学习的文化和被排斥的文化，方便判断是否可以到达下一个点。
- **去除无用边**：grard4 的题解在建边时去除与起点文化相同、文化排斥、文化相同的边，优化复杂度。

### 可拓展之处
同类型题如带有特殊限制条件的最短路问题，如时间限制、资源限制等。类似算法套路包括在传统最短路算法（Dijkstra、Floyd 等）的基础上，加入状态标记和剪枝操作，以满足特殊条件。

### 推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：涉及动态规划和最短路，需要在不同时间点更新图的状态。
- [P1346 电车](https://www.luogu.com.cn/problem/P1346)：图论问题，有特殊的边权设置，需要找到从起点到终点的最小代价。
- [P2829 大逃离](https://www.luogu.com.cn/problem/P2829)：图论与搜索结合，有时间限制和资源限制，需要找到可行的逃生路径。

### 个人心得总结
- Created_equal1 指出许多题解依赖数据水才过，强调正解应该是启发式搜索。
- tommymio 提到本题有坑点，如存图要正反存两遍，文化排斥是单向的，不能用并查集。
- yedalong 分享了调试经历，在做标记时不能直接赋值，需要加 1 或减 1，否则回溯时会覆盖标记。

---
处理用时：52.37秒
# 题目信息

# [NOIP 2012 提高组] 借教室

## 题目描述

在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。

面对海量租借教室的信息，我们自然希望编程解决这个问题。

我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。

我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。

借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。

现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。


## 说明/提示

【输入输出样例说明】

第 $1 $份订单满足后，$4 $天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2 $天到第 $4$ 天每天提供 $3$ 个教室，而第 $3$ 天剩余的教室数为$ 2$，因此无法满足。分配停止，通知第 $2$ 个申请人修改订单。

【数据范围】

对于 $10\%$ 的数据，有 $1\le n,m\le 10$；

对于 $30\%$ 的数据，有 $1\le n,m\le 1000$；

对于 $70\%$ 的数据，有 $1 \le n,m \le 10^5$；

对于 $100\%$ 的数据，有 $1 \le n,m \le 10^6$，$0 \le r_i,d_j\le 10^9$，$1 \le s_j\le t_j\le n$。


NOIP 2012 提高组 第二天 第二题

2022.2.20 新增一组 hack 数据

## 样例 #1

### 输入

```
4 3 
2 5 4 3 
2 1 3 
3 2 4 
4 2 4```

### 输出

```
-1 
2```

# AI分析结果

### 综合分析与结论
这些题解围绕借教室问题给出了多种解法，主要可分为暴力、差分、线段树、树状数组等几类思路。暴力解法简单直接但时间复杂度高，仅适用于小数据量；差分结合二分的方法，利用差分优化区间操作，二分缩小查找范围，时间复杂度较低，是较为高效的解法；线段树和树状数组能处理区间操作，但线段树常数较大，树状数组需进行优化才能通过。

### 所选题解
- **皎月半洒花（5星）**
    - **关键亮点**：思路清晰，详细阐述了暴力、前缀和、差分、二分等思想，对算法的原理和应用解释透彻，代码注释清晰，易于理解。
    - **个人心得**：提到“凡是能打出几近正解的暴力题，都不是难题！（蒟蒻可以骗到50 + 的不就是水题吗qwq）”，强调了暴力解法在理解题目和骗分方面的作用。
- **WsW_（4星）**
    - **关键亮点**：思路简洁明了，直接指出二分订单并通过差分修改和前缀和统计判断是否满足条件，时间复杂度分析准确，代码简洁规范。
- **_Bluehole（4星）**
    - **关键亮点**：对二分答案和差分前缀和优化的思路分析详细，解释了为什么要使用这些方法，代码实现清晰，有注释辅助理解。

### 重点代码及核心实现思想
#### 皎月半洒花的差分 + 二分代码
```cpp
bool isok(int x)
{
    memset(diff,0,sizeof(diff));
    for(int i=1;i<=x;i++)
    {
        diff[l[i]]+=d[i];
        diff[r[i]+1]-=d[i]; 
    }
    for(int i=1;i<=n;i++)
    {
        need[i]=need[i-1]+diff[i];
        if(need[i]>rest[i])return 0;
    }
    return 1;
} 
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&rest[i]);
    for(int i=1;i<=m;i++)scanf("%d%d%d",&d[i],&l[i],&r[i]);
    int begin=1,end=m; 
    if(isok(m)){cout<<"0";return 0;}
    while(begin<end)
    {
        int mid=(begin+end)/2;
        if(isok(mid))begin=mid+1;
        else end=mid;
    }
    cout<<"-1"<<endl<<begin;
}
```
**核心实现思想**：`isok` 函数用于判断前 `x` 个订单是否能满足，通过差分记录区间操作，再通过前缀和计算每天的需求，与可用教室数比较。主函数中使用二分查找第一个不满足的订单。

#### WsW_ 的二分 + 差分代码
```cpp
bool check(int x){
    memset(c,0,sizeof(c));
    for(int i=1;i<=x;i++){
        c[a[i].first]+=d[i];
        c[a[i].second+1]-=d[i];
    }
    for(int i=1;i<=n;i++){
        c[i]+=c[i-1];
        if(c[i]>r[i])return 0;
    }
    return 1;
}

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>r[i];
    for(int i=1;i<=m;i++){
        cin>>d[i]>>a[i].first>>a[i].second;
    }
    int lft=1,rig=m,mid,ans=-1;
    while(lft<=rig){
        mid=lft+rig>>1;
        if(check(mid))lft=mid+1;
        else{
            ans=mid;
            rig=mid-1;
        }
    }
    if(ans==-1)cout<<0;
    else cout<<"-1\n"<<ans;
    return 0;
}
```
**核心实现思想**：`check` 函数判断前 `x` 个订单是否满足，利用差分和前缀和计算需求，与可用教室比较。主函数通过二分查找第一个不满足的订单。

#### _Bluehole 的二分 + 差分代码
```cpp
bool check(int num){
    for(int i = 1; i <= num; ++i){
        cha[ a[i].s ] += a[i].d;
        cha[ a[i].t+1 ] -= a[i].d;
    }
    for(int i = 1; i <= n; ++i){
        cha[i] += cha[i-1];
        if(cha[i] > r[i])return false;
    }        
    return true;
}

int main(){    
    cin>>n>>m;
    for(int i = 1; i <= n; ++i)scanf("%d", &r[i]);
    for(int i = 1; i <= m; ++i)scanf("%d%d%d", &a[i].d, &a[i].s, &a[i].t);

    int lef = 1, rig = m;
    while(lef <= rig){
        int mid = (lef + rig)>>1;
        if(check(mid)){
            ans = mid;    
            lef = mid + 1;
        }
        else rig = mid - 1;
        for(int i = 1; i <= n; ++i)cha[i] = 0;
    }
    if(ans == m)cout<<0<<endl;
    else{
        cout<<-1<<endl;
        cout<<ans+1<<endl;
    }
    return 0;
}
```
**核心实现思想**：`check` 函数通过差分和前缀和计算前 `num` 个订单的需求，与可用教室比较。主函数二分查找第一个不满足的订单。

### 最优关键思路或技巧
- **二分思想**：利用订单满足的单调性，通过二分缩小查找范围，将时间复杂度从 $O(mn)$ 优化到 $O(n\log m)$。
- **差分优化**：将区间操作转换为端点操作，把区间加的复杂度从 $O(n)$ 降为 $O(1)$，再通过前缀和还原区间状态。

### 可拓展之处
同类型题如区间修改、区间查询的问题，都可以考虑使用差分、线段树、树状数组等数据结构优化。类似算法套路有：对于具有单调性的问题可以尝试二分答案，对于区间操作可以用差分或线段树等优化。

### 推荐题目
- P3372 【模板】线段树 1
- P3368 【模板】树状数组 2
- P2357 守墓人

### 个人心得总结
- 皎月半洒花提到暴力解法可帮助理解题目和骗分，强调了暴力在解题初期的作用。
- _Bluehole 提醒不要排序，认真读题，避免因粗心导致错误。 

---
处理用时：44.22秒
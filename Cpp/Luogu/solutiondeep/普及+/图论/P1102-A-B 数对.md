# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
本题要求计算满足 `A - B = C` 的数对个数，不同位置数字相同的数对算不同数对。题解思路多样，主要有以下几类：
1. **映射类**：利用 `map` 或哈希表记录每个数出现的次数，通过 `A - C = B` 的关系，累加满足条件的数对个数。
2. **二分查找类**：先对数组排序，再利用 `lower_bound` 和 `upper_bound` 或手动实现二分查找，找出满足条件的数的范围，计算数对个数。
3. **双指针类**：排序后使用双指针维护满足条件的区间，统计数对个数。
4. **其他类**：如队列、模拟、尺取法等。

### 所选题解
- **作者：OsvaldoAsensioLopez (赞：791)，5星**
    - **关键亮点**：思路清晰，代码简洁，利用 `map` 映射将 `A - B = C` 转换为 `A - C = B`，统计满足条件的数对个数。
    - **个人心得**：无
- **作者：樱花飞舞 (赞：539)，4星**
    - **关键亮点**：详细介绍了 `lower_bound` 和 `upper_bound` 函数的用法，并利用其进行二分查找，计算满足条件的数对个数，复杂度为 $O(NlogN)$。
    - **个人心得**：无
- **作者：jins3599 (赞：461)，4星**
    - **关键亮点**：使用双指针维护满足条件的区间，利用排序后序列的有序性，时间复杂度较低。
    - **个人心得**：无

### 重点代码及核心实现思想
#### OsvaldoAsensioLopez 的题解
```cpp
#include <iostream>
#include <map>
using namespace std;
typedef long long LL;
LL a[200001];
map<LL,LL> m;
int main() {
    int n;
    LL c;
    LL ans=0;
    cin >> n >> c;
    for(int i=1;i<=n;i++) {
        cin >> a[i];
        m[a[i]]++;
        a[i]-=c;    
    } 
    for(int i=1;i<=n;i++) ans+=m[a[i]];
    cout << ans << endl;
    return 0;
}
```
**核心实现思想**：将 `A - B = C` 转换为 `A - C = B`，用 `map` 记录每个数出现的次数，将数组元素减 `C` 后，累加 `map` 中对应数的出现次数，即为满足条件的数对个数。

#### 樱花飞舞的题解
```cpp
#include<bits/stdc++.h>
using namespace std;
long a[200001];
long N,C,ans;
int main()
{
    cin>>N>>C;
    for(int i=1;i<=N;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+N+1);
    for(int i=1;i<=N;i++)
    {
        ans+=((upper_bound(a+1,a+N+1,a[i]+C)-a)-(lower_bound(a+1,a+N+1,a[i]+C)-a));
    }
    cout<<ans;
    return 0;
}
```
**核心实现思想**：先对数组排序，对于每个 `A`，利用 `lower_bound` 和 `upper_bound` 函数找出数组中 `A + C` 的位置范围，其差值即为数组中数值为 `A + C` 的元素个数，累加这些个数得到满足条件的数对个数。

#### jins3599 的题解
```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 2e5 + 10;
int n , c;
int a[N];

int main () 
{
    cin >> n >> c;
    for(int i = 1 ; i <= n ; i ++) cin >> a[i];
    sort(a + 1 , a + 1 + n);
    int l = 1, r1 = 1 , r2 = 1;
    ll ans = 0;
    for(l = 1 ; l <= n ; l ++) {
        while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
        while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
        if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
            ans += r1 - r2;
    }
    cout << ans;
    return 0;
}
```
**核心实现思想**：排序后使用双指针 `r1` 和 `r2` 维护满足条件的区间，`r1` 右移到 `a[r1] - a[l] <= c` 的最后位置的下一位，`r2` 右移到满足 `a[r2] - a[l] < c` 最后一位，若 `a[r2] - a[l] == c && a[r1 - 1] - a[l] == c`，则中间的那一段一定都是满足条件的，累加 `r1 - r2` 得到满足条件的数对个数。

### 最优关键思路或技巧
1. **转换思维**：将 `A - B = C` 转换为 `A - C = B` 或 `B + C = A`，简化问题。
2. **数据结构的运用**：使用 `map` 或哈希表记录数的出现次数，方便统计；利用 `lower_bound` 和 `upper_bound` 进行二分查找，提高查找效率。
3. **双指针技巧**：在有序数组中使用双指针维护满足条件的区间，降低时间复杂度。

### 可拓展之处
同类型题或类似算法套路：
1. **两数之和问题**：给定一个数组和一个目标值，找出数组中两个数的和等于目标值的所有数对。
2. **区间统计问题**：给定一个数组和一个条件，统计满足条件的区间个数。

### 推荐题目
1. [P1678 烦恼的高考志愿](https://www.luogu.com.cn/problem/P1678)：二分查找的应用。
2. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：二分答案的应用。
3. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)：本题的进阶版，数据范围更大。

### 个人心得摘录与总结
- **attack**：数据更新后很多题解过不了第3个点，原因是没有开 `long long`，提醒我们注意数据范围。
- **小小小朋友**：`map` 是自带排序的 STL，时间较慢，可使用 `unordered_map` 优化，提高效率。
- **马峰**：这道题直接暴力加点优化就可以过，且比 `map` 快 400ms，说明在某些情况下，简单的优化也能取得不错的效果。

---
处理用时：42.85秒
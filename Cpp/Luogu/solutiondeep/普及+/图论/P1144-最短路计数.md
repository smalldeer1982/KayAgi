# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论
这些题解围绕无向无权图中从顶点 1 到其他各点的最短路计数问题，提供了多种算法思路，主要包括 BFS、SPFA、Dijkstra 等算法，并在这些算法基础上加入计数操作。各题解的核心思路都是在更新最短路的过程中，根据不同情况更新最短路的计数。

### 所选题解
- **作者：ZiDing_ByronFinlso（5 星）**
    - **关键亮点**：提供了 SPFA 和 Dijkstra 堆优化两种解法，思路清晰，代码注释详细，对算法的关键步骤和计数操作解释明确。
    - **个人心得**：无
- **作者：岸芷汀兰（4 星）**
    - **关键亮点**：准确判断本题适合用广搜，详细分析了题目中的难点，如自环、重边的处理，代码结构清晰，注释丰富。
    - **个人心得**：无
- **作者：King丨帝御威（4 星）**
    - **关键亮点**：强调了堆优化 Dijkstra 的优势，对最短路计数的实现步骤解释详细，代码规范。
    - **个人心得**：无

### 重点代码及核心实现思想
#### ZiDing_ByronFinlso 的 SPFA 代码
```cpp
while(q.size())
{
    x=q.front();q.pop();
    p[x]=0;
    for(int i=head[x];i;i=nxt[i])
    {
        y=to[i];
        if(d[y]>d[x]+1)
        {
            d[y]=d[x]+1;
            ans[y]=ans[x];
            if(!p[y])
            {
                q.push(y);
                p[y]=1;
            }
        }
        else if(d[y]==d[x]+1)
        {
            ans[y]+=ans[x];
            ans[y]%=mod;
        }
    }
}
```
**核心实现思想**：在 SPFA 算法的基础上，当发现更短的路径时，更新最短路长度并将该点的最短路计数更新为前驱节点的计数；当发现相同长度的最短路时，将该点的最短路计数加上前驱节点的计数，并取模防止溢出。

#### 岸芷汀兰的 BFS 代码
```cpp
while (q.size()) {
    int u = q.front().node, dis = q.front().dis; 
    q.pop();
    for (register int i = 0; i<int(linker[u].size()); i++) {
        if (!vis[cur]) {
            q.push(make(cur, dis + 1)); vis[cur] = true; d[cur] = dis + 1; 
            ans[cur] += ans[u]; ans[cur] %= mod;
        }
        else {
            if (dis + 1 == d[cur]) { ans[cur] += ans[u]; ans[cur] %= mod; }
        }
    }
}
```
**核心实现思想**：利用 BFS 进行搜索，当第一次访问某个节点时，将其加入队列，更新最短路长度和最短路计数；当再次访问该节点且路径长度等于最短路长度时，更新最短路计数。

#### King丨帝御威的 Dijkstra 代码
```cpp
while(!q.empty())
{
    a=q.top();
    int u=a.x,d=a.y;
    q.pop();
    if(d!=dis[u]) continue;
    for(int i=head[u];i;i=edge[i].nxt)
    {
        int v=edge[i].v;
        if(d+edge[i].w==dis[v])
            js[v]=(js[u]+js[v])%mod;
        if((dis[v]>dis[u]+edge[i].w))
        {
            dis[v]=dis[u]+edge[i].w;
            js[v]=js[u];
            q.push((node){v,dis[v]});
        }
    }
}
```
**核心实现思想**：在 Dijkstra 算法中，使用优先队列优化，当发现更短的路径时，更新最短路长度和最短路计数；当发现相同长度的最短路时，更新最短路计数并取模。

### 最优关键思路或技巧
- **计数操作**：在更新最短路的过程中，根据不同情况更新最短路的计数。当发现更短的路径时，将该点的最短路计数更新为前驱节点的计数；当发现相同长度的最短路时，将该点的最短路计数加上前驱节点的计数。
- **取模操作**：为防止计数溢出，在更新计数时进行取模操作。
- **数据结构**：使用邻接表存储图，提高图的存储和遍历效率。

### 可拓展之处
- **同类型题**：有向图的最短路计数、带权图的最短路计数等。
- **类似算法套路**：在其他图算法（如拓扑排序、最小生成树等）中加入计数操作，解决路径计数、方案数计数等问题。

### 推荐题目
- P1608 路径统计
- P2149 [SDOI2009]Elaxia 的路线
- P3953 逛公园

### 个人心得摘录与总结
- **XZYQvQ**：发现很多人写的 SPFA 统计答案存在问题，虽然能在本题 AC，但换题就不行了，建议先跑一遍 SPFA 得到最短路长度，再跑一遍记忆化搜索得到答案。
- **KesdiaelKen**：指出普通 SPFA 计数方式在边权不同时可能会重复计数，给出了调整后的 SPFA 计数方式。
- **Utsuji_risshū**：指出本题中 SPFA 其实就是 BFS，和 Dijkstra 过程几乎一样，但在边权不同的题目中，SPFA 可能会出现问题，需要调整计数方式。

---
处理用时：38.51秒
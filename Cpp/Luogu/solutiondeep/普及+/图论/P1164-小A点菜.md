# 题目信息

# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕动态规划（DP）解决小A点菜问题，核心在于找出恰好花完给定金额的点菜方案数。多数题解将其类比为0 - 1背包问题，通过状态转移方程递推求解。

思路上，主要有二维数组和一维数组两种实现方式。二维数组 `f[i][j]` 表示前 `i` 道菜花 `j` 元的方案数；一维数组 `f[j]` 表示花 `j` 元的方案数。难点在于状态转移方程的推导和边界条件的处理，如初始化 `f[0] = 1` 表示不点菜花0元是一种方案。

### 所选题解
- **作者：衡屿睿（4星）**
    - **关键亮点**：思路清晰，详细阐述了状态转移方程的三种情况，代码简洁易懂。
    - **个人心得**：调侃自己对DP和递推的混淆，体现了对算法理解的思考过程。
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int a[101],f[101][10001]={0};
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;++i)cin>>a[i];
    for(int i=1;i<=n;++i)
      for(int j=1;j<=m;++j)
      {
          if(j==a[i])f[i][j]=f[i-1][j]+1;
          if(j>a[i]) f[i][j]=f[i-1][j]+f[i-1][j-a[i]];
          if(j<a[i]) f[i][j]=f[i-1][j];
      }
    cout<<f[n][m];
    return 0;
}
```
核心实现思想：通过两层循环遍历每道菜和每个金额，根据当前金额与菜价的关系更新方案数。

- **作者：Dream_zhc（4星）**
    - **关键亮点**：详细解释了状态转移方程的推导过程，并介绍了如何将二维数组优化为一维数组，配有图片辅助理解。
    - **个人心得**：无。
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define N 110
using namespace std;
int n,m,a[N],f[10010];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
      scanf("%d",&a[i]);
    f[0]=1;
    for(int i=1;i<=n;i++)
      for(int j=m;j>=a[i];j--)
      	  f[j]=f[j]+f[j-a[i]];
    cout<<f[m];
    return 0;
}
```
核心实现思想：先初始化 `f[0] = 1`，然后通过两层循环，外层遍历每道菜，内层从大到小遍历金额，更新方案数。

- **作者：WilliamPen（4星）**
    - **关键亮点**：明确指出本题是DP入门的0 - 1背包问题，代码简洁规范。
    - **个人心得**：希望大家理解DP，强调DP在后续解题中的重要性。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=10000+10;
int v[maxn],f[maxn];
int main(){
    int n,m;
    cin>>n>>m;
    f[0]=1;
    for(int i=1;i<=n;++i)    
        cin>>v[i];
    for(int i=1;i<=n;++i)
        for(int j=m;j>=v[i];--j)
            f[j]+=f[j-v[i]];
    cout<<f[m]<<endl;
    return 0;
}
```
核心实现思想：同样先初始化 `f[0] = 1`，通过两层循环更新方案数。

### 最优关键思路或技巧
- **状态定义**：用 `f[i][j]` 或 `f[j]` 表示方案数，清晰地定义状态是解决问题的关键。
- **状态转移**：根据是否选择当前菜，将方案数进行累加。
- **一维数组优化**：当状态转移只依赖于上一层状态时，可将二维数组优化为一维数组，减少空间复杂度，但要注意内层循环的方向。

### 可拓展之处
同类型题如其他0 - 1背包的方案数问题、完全背包的方案数问题等。类似算法套路可应用于组合计数、路径规划等问题，关键在于合理定义状态和推导状态转移方程。

### 推荐题目
1. [P1049 装箱问题](https://www.luogu.com.cn/problem/P1049)
2. [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)
3. [P2722 总分 Score Inflation](https://www.luogu.com.cn/problem/P2722)

### 个人心得摘录与总结
- **衡屿睿**：调侃自己对DP和递推的混淆，反映出对算法概念理解的困惑，提醒学习者要深入理解不同算法的本质。
- **Eric_cao**：分享了Python输入的小坑，测试数据可能会将输入隔开成多行，导致普通输入方式出错，强调了处理输入时要考虑数据的多样性。
- **魔芋桑**：提到因未判定钱是否够点菜而浪费下载机会，提醒大家在实现算法时要注意边界条件的判断。
- **EnochWenzhou**：尝试用0 - 1背包做本题失败，说明0 - 1背包只能判断是否能达到某个状态，不能统计方案数，要根据问题的具体要求选择合适的算法。
- **zxj200408**：表示一晚上没睡着想DP，刷水题找自信，体现了学习DP过程中的困扰和通过实践提升信心的重要性。 

---
处理用时：36.86秒
# 题目信息

# 公路修建

## 题目描述

某国有 $n$ 个城市，它们互相之间没有公路相通，因此交通十分不便。为解决这一“行路难”的问题，政府决定修建公路。修建公路的任务由各城市共同完成。

修建工程分若干轮完成。在每一轮中，每个城市选择一个与它最近的城市，申请修建通往该城市的公路。政府负责审批这些申请以决定是否同意修建。

政府审批的规则如下：

1. 如果两个或以上城市申请修建同一条公路，则让它们共同修建；
2. 如果三个或以上的城市申请修建的公路成环。如下图，A 申请修建公路 AB，B 申请修建公路 BC，C 申请修建公路 CA。则政府将否决其中最短的一条公路的修建申请； 
3. 其他情况的申请一律同意。

![](https://cdn.luogu.com.cn/upload/image_hosting/apng39qc.png)

一轮修建结束后，可能会有若干城市可以通过公路直接或间接相连。这些可以互相连通的城市即组成“城市联盟”。在下一轮修建中，每个“城市联盟”将被看作一个城市，发挥一个城市的作用。

当所有城市被组合成一个“城市联盟”时，修建工程也就完成了。

你的任务是根据城市的分布和前面讲到的规则，计算出将要修建的公路总长度。

## 说明/提示

修建的公路如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p0dtxt2l.png)

## 样例 #1

### 输入

```
4

0 0

1 2

-1 2

0 4```

### 输出

```
6.47```

# AI分析结果

### 综合分析与结论
本题核心是求最小生成树（MST），多数题解聚焦于Prim和Kruskal算法。其中，Prim算法以点为中心，适用于稠密图；Kruskal算法以边为中心，适用于稀疏图。本题为完全图，边数多，使用Kruskal算法会面临空间和时间复杂度的问题，因此多数题解选择Prim算法。

### 所选题解
1. **作者：MY（一名蒟蒻）** - 5星
    - **关键亮点**：思路清晰，详细阐述了从Kruskal算法失败到选择Prim算法的过程，对Prim算法流程解释细致，代码注释规范。
    - **个人心得**：尝试Kruskal算法提交后出现TLE和MLE问题，意识到该算法在本题的局限性，从而选择Prim算法。
    - **核心代码**：
```cpp
void Prim()
{
    dis[1]=0.0;
    book[1]=true;
    int curr;
    double minn;
    for(int i=1;i<=n;i++)
    {
        curr=1;
        minn=1e9*1.0;
        for(int j=1;j<=n;j++)//找最短边
            if(!book[j] && dis[j] < minn)
                minn=dis[j],curr=j;
        book[curr]=true;
        ans+=dis[curr];
        for(int j=1;j<=n;j++)//现用现算
            dis[j]=min(dis[j],get_e(x[curr],y[curr],x[j],y[j]));
    }
    printf("%.2lf",ans);
    return ;
}
```
    - **核心实现思想**：从起点开始，标记为蓝点，不断寻找连接蓝点集合和白点集合的最短边，将对应的白点加入蓝点集合，并更新新加入蓝点连接的白点的最短边，直到所有点都加入最小生成树。

2. **作者：EricWay1024** - 4星
    - **关键亮点**：对比了Kruskal和Prim算法的思想差异，深入解释了Prim算法中维护数组的作用和时机，对算法理解有很大帮助。
    - **核心代码**：
```cpp
void prim(){
    memset(d, INF, sizeof(d));
    memset(v, 0, sizeof(v));
    d[1]=0;
    For(i, n-1){
        int x=0;
        For(j, n){
            if (!v[j] && (x==0 || d[j]<d[x])) x=j;
        }
        v[x]=1;
        For(y, n){
            if (!v[y]) d[y]=min(d[y], city[x]*city[y]);
        }
    }
}
```
    - **核心实现思想**：初始化所有点到树的距离为无穷大，将1号节点设为树的起点，距离为0。不断选择距离树最近的点加入树中，并更新其他点到树的距离，直到所有点都加入树。

3. **作者：Sci_M3** - 4星
    - **关键亮点**：分析了规则2的情况，证明其不会影响结果，将问题简化为最小生成树问题，并指出空间限制问题，提出现用现算距离的解决方案。
    - **核心代码**：
```cpp
int main() {
    n = read();
    for(int i = 1; i <= n; ++i) {
        point[i].x = read(), point[i].y = read();
        dis[i] = 1e8;
    }
    int pos; dis[1] = 0;
    for(int i = 1; i <= n; ++i) {
        double minn = 1e8;
        for(int j = 1; j <= n; ++j) if(!vis[j] && dis[j] < minn) {
            minn = dis[j]; pos = j;
        }
        ans += minn; vis[pos] = true;
        for(int j = 1; j <= n; ++j) {
            double d = calc(pos, j);
            if(d < dis[j])  dis[j] = d;
        }
    }
    printf("%.2lf\n", ans);
    return 0;
}
```
    - **核心实现思想**：读入城市坐标，初始化距离数组。不断选择距离已加入点集最近的点，将其加入点集，并更新其他点到该点集的距离，最后累加所有边的长度得到最小生成树的总长度。

### 最优关键思路或技巧
1. **算法选择**：根据图的稠密程度选择合适的最小生成树算法，本题为完全图，选择Prim算法避免了Kruskal算法的空间和时间复杂度问题。
2. **空间优化**：不直接存储所有边的距离，而是在需要时现用现算，避免了开5000*5000邻接矩阵导致的MLE问题。
3. **规则简化**：通过分析规则2，证明其不会影响最小生成树的结果，将问题简化。

### 可拓展之处
同类型题或类似算法套路：
1. 其他最小生成树问题，如带权图的最小生成树、次小生成树等。
2. 图的连通性问题，可使用并查集或深度优先搜索等算法解决。
3. 图的最短路径问题，如Dijkstra算法、Floyd算法等。

### 推荐题目
1. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
2. [P1194 买礼物](https://www.luogu.com.cn/problem/P1194)
3. [P2872 [USACO07DEC]Building Roads S](https://www.luogu.com.cn/problem/P2872)

### 个人心得总结
- 部分作者尝试Kruskal算法时遇到TLE和MLE问题，意识到该算法在稠密图中的局限性，从而选择Prim算法。
- 部分作者在计算距离时未进行类型转换，导致结果错误，提醒在计算时要注意数据类型。
- 部分作者开5000*5000的邻接矩阵导致MLE，意识到可以现用现算距离，避免空间浪费。

---
处理用时：42.28秒
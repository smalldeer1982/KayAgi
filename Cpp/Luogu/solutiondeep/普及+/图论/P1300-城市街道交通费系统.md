# 题目信息

# 城市街道交通费系统

## 题目描述

城市街道交费系统最近创立了。一辆汽车左转一次需付费 $1$ ，右转一次需付费 $5$ 。只有当前进、左转、右转都无路可走的时候，调头才是允许的，调头每次付费 $10$ 。

给出一张城市地图，要求你求出从起始点到达终止点的花费最少的路径。幸运的是，所有的道路都是正北、正南、正西或正东方向的。

## 说明/提示

样例一解释：

直走，然后左转 $3$ 次，最后右转到终止点 `F`。如果先直走然后右转 $2$ 次，花费将是 $10$ 。

---

样例二解释：

最便宜的路径花费 $7$ ：立刻左转，直走，在第一个岔路口左转，随后右转。

---

对于 $100\%$ 的数据：$4 \leq h,w \leq 30$。

数据保证地图中只有一个起点，一个终点，他们之间存在着可通达的路径。同时保证地图最外层一圈都是障碍。

## 样例 #1

### 输入

```
8 11
...........
....#####..
....#...#..
....#...#..
.#E######..
....#......
.##F#......
...........
```

### 输出

```
8
```

## 样例 #2

### 输入

```
17 21
.....................
.#######.............
.#.....#.......#.....
.###...#.......#.....
...#...#.......#.....
.###...#.......#.....
.#.....#.......#.....
.############F#####..
.......#..........#..
.......#..........#..
...#...#...#####..#..
...#...#...#.#.#..#..
..#S########.#.#..#..
...#.......#.###..#..
...#.......#......#..
...........########..
.....................```

### 输出

```
7```

# AI分析结果

### 综合分析与结论
本题主要是在地图中寻找从起点到终点的最小花费路径，由于数据范围较小（$4 \leq h,w \leq 30$），大部分题解采用搜索算法（DFS 或 BFS）来解决。各题解的核心思路都是对每个状态（位置和方向）进行扩展，考虑前进、左转、右转和掉头四种操作，并根据规则计算花费，同时使用剪枝策略避免无效搜索。

### 所选题解
- **作者：RedreamMer（4星）**
  - **关键亮点**：思路清晰，使用 BFS 结合优先队列，以花费为关键字，保证队首为当前最优状态。代码实现规范，对每种操作的判断和处理逻辑明确，且有详细注释。
  - **个人心得**：提到很多人用 DFS 写，自己坚持用 BFS 完成，体现了不同算法选择的思考。
```cpp
// 核心代码片段
while(!st.empty()) {
    bool q = 0;
    k = st.top();
    if(k.x == xx && k.y == yy) break;
    st.pop();
    x = k.x + dx[k.to];
    y = k.y + dy[k.to];
    if(s[x][y]) q = 1;
    if(s[x][y] && m[x][y][k.to] > m[k.x][k.y][k.to]) {
        m[x][y][k.to] = m[k.x][k.y][k.to];
        l.x = x;
        l.y = y;
        l.to = k.to;
        st.push(l);
    }
    // 左转、右转、掉头判断代码省略
}
```
- **作者：Deamer（4星）**
  - **关键亮点**：使用堆优化的 Dijkstra 算法，将方向信息融入状态，通过多个数组记录方向变化和花费，避免了繁琐的分类讨论。代码结构清晰，对掉头操作的特判处理合理。
  - **个人心得**：强调了转弯方向和花费的处理技巧，以及一些注意事项，如掉头的特判和状态数组的记录。
```cpp
// 核心代码片段
void BFS() {
    priority_queue<node>q;
    memset(dis, INF, sizeof(dis));
    dis[sx][sy][sd] = 0;
    q.push((node){sx, sy, sd, dis[sx][sy][sd]});
    while(!q.empty()) {
        node u = q.top(); q.pop();
        int x = u.x, y = u.y, d = u.d;
        if(vis[x][y][d]) continue;
        vis[x][y][d] = 1;
        int flag = 0;
        for(int i = 0; i < 4; i++) {
            int nx = x + fx[d][i], ny = y + fy[d][i], nd = fd[d][i], w = fw[i];
            if((i < 3 && chck(nx, ny, nd)) || (!flag && chck(nx, ny, nd))) {
                flag = 1;
                if(dis[nx][ny][nd] > dis[x][y][d] + w) {
                    dis[nx][ny][nd] = dis[x][y][d] + w;
                    q.push((node){nx, ny, nd, dis[nx][ny][nd]});
                }
            }
        }
    }
}
```
- **作者：破忆（4星）**
  - **关键亮点**：使用 DFS 结合剪枝，通过三维数组记录到达每个点不同方向的最小代价，避免重复搜索。代码简洁，对方向的处理和剪枝条件的判断清晰明了。
  - **个人心得**：无。
```cpp
// 核心代码片段
IN void DFS(int x, int y, int w, int c) {
    if(dis[x][y][w] <= c || c >= ans) return;
    dis[x][y][w] = c;
    if(mp[x][y] == 2) ans = min(ans, dis[x][y][w]);
    bool flg = 0;
    int fx = x + p[w][0], fy = y + p[w][1];
    int lw = (w + 1) % 4, lx = x + p[lw][0], ly = y + p[lw][1];
    int bw = (w + 2) % 4, bx = x + p[bw][0], by = y + p[bw][1];
    int rw = (w + 3) % 4, rx = x + p[rw][0], ry = y + p[rw][1];
    if(mp[fx][fy]) flg = 1, DFS(fx, fy, w, c);
    if(mp[lx][ly]) flg = 1, DFS(lx, ly, lw, c + 1);
    if(mp[rx][ry]) flg = 1, DFS(rx, ry, rw, c + 5);
    if(mp[bx][by] &&!flg) DFS(bx, by, bw, c + 10);
}
```

### 最优关键思路或技巧
1. **方向处理**：通过方向数组和取模运算，简洁地实现左转、右转和掉头的方向变化，如 `(w + 1) % 4` 表示左转，`(w + 3) % 4` 表示右转，`(w + 2) % 4` 表示掉头。
2. **剪枝优化**：使用三维数组记录到达每个点不同方向的最小花费，若当前花费大于等于已记录的最小花费，则跳过该状态，避免无效搜索。
3. **优先队列**：在 BFS 中使用优先队列，以花费为关键字，保证队首为当前最优状态，提高搜索效率。

### 可拓展之处
同类型题可能会在地图规则、操作花费、状态定义等方面进行拓展。例如，地图可能变为三维空间，操作可能增加更多种类，状态可能需要记录更多信息。类似算法套路包括使用搜索算法（DFS、BFS）结合剪枝优化，以及使用优先队列、Dijkstra 等算法解决最优化问题。

### 推荐题目
1. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)：在电梯中进行状态转移，寻找最短路径。
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)：在棋盘上使用 BFS 搜索马的遍历路径。
3. [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)：在迷宫中寻找从起点到终点的路径，可使用 DFS 或 BFS 解决。

### 个人心得总结
- RedreamMer 提到很多人用 DFS 写，自己坚持用 BFS，体现了不同算法选择的思考，鼓励尝试不同方法解决问题。
- Deamer 强调了转弯方向和花费的处理技巧，以及一些注意事项，提醒在解决问题时要仔细考虑细节，避免遗漏关键条件。

---
处理用时：44.11秒
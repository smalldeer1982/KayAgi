# 题目信息

# 瑞瑞的木棍

## 题目描述

瑞瑞有一堆的玩具木棍，每根木棍的两端分别被染上了某种颜色，现在他突然有了一个想法，想要把这些木棍连在一起拼成一条线，并且使得木棍与木棍相接触的两端颜色都是相同的，给出每根木棍两端的颜色，请问是否存在满足要求的排列方式。

例如，如果只有 2 根木棍，第一根两端的颜色分别为 red, blue，第二根两端的颜色分别为 red, yellow，那么 blue---red | red----yellow 便是一种满足要求的排列方式。



## 样例 #1

### 输入

```
blue red
red violet
cyan blue
blue magenta
magenta cyan
```

### 输出

```
Possible
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是将木棍问题转化为图论中的欧拉路问题，把颜色看作点，木棍看作边，通过判断图是否连通以及奇数度点的个数是否为 0 或 2 来确定是否存在满足要求的排列方式。各题解的主要区别在于字符串处理和判断图连通性的方法。字符串处理方法有字典树、哈希表、`unordered_map`等；判断图连通性的方法有并查集和 DFS。

### 所选题解
- **作者：热言热语（4星）**
  - **关键亮点**：思路清晰，详细阐述了欧拉路的判定方法，分别给出了字典树和 `unordered_map` 两种字符串处理方式，使用并查集判断图的连通性。
  - **个人心得**：建议不选 STL，因为速度慢。

### 重点代码
```cpp
// 并查集
int fa[N];
inline int find(int a) {
    return fa[a]?fa[a]=find(fa[a]):a;
}
inline bool join(int a,int b) { // 有效合并返回 true，无效返回 false 
    int x=find(a),y=find(b);
    if(x==y) return false;
    fa[x]=y; return true;
}

// 字典树求编号
int nd=1,root=1; struct node{int son[26],num;}t[1000010];
int getid(const char *s) {
    int k=root; char c;
    for(int i=0;s[i];++i) {
        c=s[i]-'a';
        if(!t[k].son[c]) t[k].son[c]=++nd; // 动态开点
        k=t[k].son[c];
    }
    if(!t[k].num) t[k].num=++n;
    return t[k].num;
}

// unordered_map 求编号
#include <string>
#include <unordered_map>
using namespace std;
unordered_map<string,int> M;
int getid(const char *s) {
    return M[s]?M[s]:M[s]=++n;
}

// 检查是否存在欧拉路
inline bool check() {
    int x,y,cnt=0;
    while(~scanf("%s",s)) {
        x=getid(s);
        scanf("%s",s);
        y=getid(s); // getid 求编号 
        if(join(x,y)) ++cnt; // 记录有效合并次数 
        ++deg[x]; ++deg[y]; // 统计度数 
    }
    if(cnt<n-1) return false; // 判联通:只有当 cnt==n-1 时是联通的 
    cnt=0; // 记录奇数度点的个数
    for(int i=1;i<=n;++i) if((deg[i]&1)&&++cnt>2) return false; // 扫一遍颜色的度,奇数度点个数>2 就退出 
    return true;
}
```
**核心实现思想**：首先使用字典树或 `unordered_map` 将字符串映射为编号，方便后续处理。然后使用并查集合并边的两个端点，记录有效合并次数，判断图的连通性。最后统计每个点的度数，检查奇数度点的个数是否为 0 或 2。

### 最优关键思路或技巧
- **字符串处理**：使用字典树或 `unordered_map` 将字符串映射为编号，避免直接处理字符串，提高效率。
- **图的连通性判断**：使用并查集可以高效地判断图的连通性，时间复杂度较低。

### 可拓展之处
同类型题或类似算法套路：
- 欧拉回路问题：判断图中是否存在欧拉回路，可在欧拉路的基础上增加所有点度数为偶数的条件。
- 哈密顿回路问题：判断图中是否存在哈密顿回路，与欧拉路问题不同，哈密顿回路问题是 NPC 问题。

### 推荐题目
- [P1341 无序字母对](https://www.luogu.com.cn/problem/P1341)：考察欧拉回路的构造。
- [P2731 [USACO3.3]骑马修栅栏 Riding the Fences](https://www.luogu.com.cn/problem/P2731)：考察欧拉路的求解。
- [P1127 词链](https://www.luogu.com.cn/problem/P1127)：将单词看作边，字母看作点，判断是否存在欧拉路。

### 个人心得总结
热言热语提到建议不选 STL，因为速度慢，在对时间要求严格的题目中，需要谨慎选择数据结构。

---
处理用时：30.38秒
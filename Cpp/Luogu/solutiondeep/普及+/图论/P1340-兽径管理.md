# 题目信息

# 兽径管理

## 题目描述

约翰农场的牛群希望能够在 $N$ 个草地之间任意移动。草地的编号由 $1$ 到 $N$。草地之间有树林隔开。牛群希望能够选择草地间的路径，使牛群能够从任一 片草地移动到任一片其它草地。 牛群可在路径上双向通行。

牛群并不能创造路径，但是他们会保有及利用已经发现的野兽所走出来的路径（以下简称兽径）。每星期他们会选择并管理一些或全部已知的兽径当作通路。

牛群每星期初会发现一条新的兽径。他们接着必须决定管理哪些兽径来组成该周牛群移动的通路，使得牛群得以从任一草地移动到任一草地。牛群只能使用当周有被管理的兽径做为通路。

牛群希望他们管理的兽径长度和为最小。牛群可以从所有他们知道的所有兽径中挑选出一些来管理。牛群可以挑选的兽径与它之前是否曾被管理无关。

兽径决不会是直线，因此连接两片草地之间的不同兽径长度可以不同。 此外虽然两条兽径或许会相交，但牛群非常的专注，除非交点是在草地内，否则不会在交点换到另外一条兽径上。

在每周开始的时候，牛群会描述他们新发现的兽径。如果可能的话，请找出可从任何一草地通达另一草地的一组需管理的兽径，使其兽径长度和最小。


## 说明/提示

### 样例解释

对于每一周，

- 第一周时 $4$ 号草地不能与其他草地连通，输出 $-1$；
- 第二周时 $4$ 号草地不能与其他草地连通，输出 $-1$；
- 第三周时 $4$ 号草地不能与其他草地连通，输出 $-1$；
- 第四周时可以选择兽径 $(1,4,3),(1,3,8)$ 和 $(3,2,3)$；
- 第五周时可以选择兽径 $(1,4,3),(1,3,6)$ 和 $(3,2,3)$；
- 第六周时可以选择兽径 $(1,4,3),(2,1,2)$ 和 $(3,2,3)$。


### 数据范围及约定

对于全部数据，$1\le N\le 200$，$1 \le W \le 6000$，兽径的长度不超过 $10^4$ 且为正整数。

## 样例 #1

### 输入

```
4 6	 	 
1 2 10	 	 
1 3 8	 	 
3 2 3	 	 
1 4 3	 	 
1 3 6	 	 
2 1 2	 	 
```

### 输出

```
-1
-1
-1
14
12
8```

# AI分析结果

### 综合分析与结论
本题要求每周加入一条新兽径后，求出能使牛群在各草地间通行的最小兽径长度和，若无法连通则输出 -1。大部分题解采用 Kruskal 算法求解最小生成树，主要难点在于如何优化每次加边后重新计算最小生成树的时间复杂度。不同题解在优化思路上各有不同，如逆序求解、减少排序次数、利用并查集特性等。

### 所选题解
- **作者：SovietPower✨（5星）**
    - **关键亮点**：采用逆序求解，尽可能减少 Kruskal 算法的使用次数。每次 Kruskal 记录用到的边，若删除的边是用到的边则重新计算，否则直接使用上一次结果。若某周不连通，则后续周都不连通，可提前结束计算。
    - **核心代码**：
```cpp
for(int i=w-1;i;i--)
{
    cannot[i+1]=1;
    if(use[i+1])
        Ans[i]=Kruskal();
    else
        Ans[i]=Ans[i+1];
    if(Ans[i]==-1)
    {
        for(int j=1;j<i;j++)
            Ans[j]=-1;
        break;
    }
}
```
- **作者：绝艺（4星）**
    - **关键亮点**：同样逆序跑 Kruskal 算法，在结构体存边时记录该边是第几周的兽径，避免快排打乱顺序。一旦发现某周不能构成最小生成树，将之前的结果都设为 -1，减少计算量。
    - **核心代码**：
```cpp
for(int i=m;i>=1;i--)
{
    ans[i]=kruskal(i);
    if(ans[i]==-1)
    {
        for(int j=1;j<i;j++) ans[j]=-1;
        break;
    }
}
```
- **作者：南苑沁青（4星）**
    - **关键亮点**：提出离线做法，给每条边添加时间标号，所有边添加完毕后按权值排序，做 W 遍最小生成树时，只考虑时间标号不大于当前次数的边，避免多次排序。
    - **核心代码**：
```cpp
for(LL i=1;i<=w;i++)
{
    t[i].l=read();t[i].r=read();t[i].w=read();t[i].tim=i;
}
sort(t+1,t+w+1,cmp);
for(LL i=1;i<=w;i++)
{
    ans=0,cnt=0;
    kruskal(i);
}
```

### 最优关键思路或技巧
- **逆序求解**：当某周不连通时，后续周必然不连通，可提前结束计算，减少 Kruskal 算法的使用次数。
- **离线处理**：给边添加时间标号，一次性排序后，通过时间标号筛选边，避免多次排序，降低时间复杂度。
- **记录使用边**：每次 Kruskal 记录用到的边，若删除的边未被使用，则无需重新计算最小生成树。

### 可拓展之处
同类型题如动态最小生成树问题，可在加边或删边的同时动态维护最小生成树。类似算法套路包括利用并查集维护连通性、使用排序优化边的选择等。

### 推荐题目
- [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195)：求最小生成树的变种，需要生成指定数量的树。
- [P2872 [USACO07DEC]Building Roads S](https://www.luogu.com.cn/problem/P2872)：在已有部分边的基础上求最小生成树。
- [P3366 [模板] 最小生成树](https://www.luogu.com.cn/problem/P3366)：最小生成树的基础模板题。

### 个人心得摘录与总结
- **作者：绝艺**：提到每次 Kruskal 时要对并查集用到的 fa[] 数组先初始化，否则会导致错误，提醒在使用并查集时要注意初始化操作。
- **作者：寒酥**：尝试用加边成环后去除环的最大边的方法，但因不会实现而改用 LCT 维护两点间边权最大值，说明在解决问题时若遇到困难可尝试其他数据结构或算法。

---
处理用时：30.64秒
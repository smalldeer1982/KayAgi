# 题目信息

# [USACO2.4] 牛的旅行 Cow Tours

## 题目描述

Farmer John 的农场里有很多 **牧区**。有的路径连接一些特定的牧区。**一片所有连通的牧区** 称为一个 **牧场**。但是就目前而言，你能看到至少有两个牧区通过任何路径都不连通。这样，Farmer John 就有 **多个** 牧场了。

John 想在牧场里添加 **恰好** 一条路径。对这条路径有以下限制：

一个牧场的 **直径** 就是牧场中 **最远** 的两个牧区的距离（本题中所提到的所有距离指的都是 **最短的距离**）。考虑如下的有 5 个牧区的牧场，牧区用 `*` 表示，路径用直线表示。每一个牧区都有自己的坐标：

```plain
                (15,15) (20,15)
                 D       E
                 *-------*
                 |     _/|
                 |   _/  |
                 | _/    |
                 |/      |
        *--------*-------*
        A        B       C
     (10,10)  (15,10) (20,10)
```
这个牧场的直径大约是 $12.07106$，最远的两个牧区是 A 和 E，它们之间的最短路径是 $A \to B \to E$。

这里是 John 的另一个牧场：

```plain
                         *F(30,15)
                        / 
                      _/  
                    _/    
                   /      
                  *------* 
                  G      H
                  (25,10)   (30,10)
```

在这个例子中，他刚好有这两个牧场。John 将会在这两个牧场中各选一个牧区（即从 $\{A,B,C,D,E\}$ 中选择一个牧区，从 $\{F,G,H\}$ 中选择一个牧区），然后用一条路径将它们连起来，使得连通后这个新的更大的牧场的直径尽可能小。

注意，如果两条路径中途相交，我们不认为它们是连通的。只有两条路径在同一个牧区相交，我们才认为它们是连通的。

输入文件包括牧区、它们各自的坐标，还有一个如下的对称邻接矩阵：

```plain
　 A  B  C  D  E  F  G  H 
A  0  1  0  0  0  0  0  0
B  1  0  1  1  1  0  0  0
C  0  1  0  0  1  0  0  0
D  0  1  0  0  1  0  0  0
E  0  1  1  1  0  0  0  0
F  0  0  0  0  0  0  1  0
G  0  0  0  0  0  1  0  1
H  0  0  0  0  0  0  1  0
```

其他邻接表中可能直接使用行列而不使用字母来表示每一个牧区。输入数据中不包括牧区的名字。

输入文件 **至少** 包括两个不连通的牧区。

请编程找出一条连接属于两个 **不同牧场** 的牧区的路径，使得连上这条路径后，这个更大的新牧场的直径尽可能小。输出在所有合法的连接方案中，新牧场直径的最小值。

## 说明/提示

样例对应题目描述中的情况。

最优解是连接 C 牧区和 G 牧区，连接后图上只有一个牧场。这个牧场的直径为 $A \to B \to C \to G \to F$，长度约为 $22.071068$。可以证明不存在更优的方案。

USACO 2.4


## 样例 #1

### 输入

```
8
10 10
15 10
20 10
15 15
20 15
30 15
25 10
30 10
01000000
10111000
01001000
01001000
01110000
00000010
00000101
00000010```

### 输出

```
22.071068
```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致，均是先找出所有牧场（连通块），计算牧场内各点间最短路，再枚举不同牧场的点相连，求出新牧场直径最小值。但在实现细节上有差异，如使用 DFS 或并查集划分连通块，用 Floyd 或 Dijkstra 求最短路。解决难点在于正确理解新牧场直径的构成，避免只考虑一种情况导致错误。

### 所选题解
- **作者：heidoudou（5星）**
    - **关键亮点**：思路清晰，详细阐述每个步骤及概念，代码注释丰富，可读性强。
    - **核心代码**：
```cpp
// DFS 对连通块染色标记
void dfs(int i, int id)
{
    field[i] = id;
    for (int j = 0; j < n; ++j)
        if (!field[j] && dist[i][j] < INF)
            dfs(j, id);
}
// Floyd-Warshall 算法计算所有点对之间的最短路
for (k = 0; k < n; ++k)
    for (i = 0; i < n; ++i)
        for (j = 0; j < n; ++j)
            if (dist[i][k] + dist[k][j] < dist[i][j])
                dist[i][j] = dist[i][k] + dist[k][j];
// 计算每个牧场中，每个牧区点到其他点的最短路的最大值及牧场直径
for (i = 0; i < n; ++i)
{
    max_sp[i] = 0.0;
    for (j = 0; j < n; ++j)
        if (dist[i][j] < INF)
            max_sp[i] = max(max_sp[i], dist[i][j]);
    diameter[field[i]] = max(diameter[field[i]], max_sp[i]);
}
// 找答案
for (i = 0; i < n; ++i)
    for (j = i + 1; j < n; ++j)
        if (field[i]!= field[j])
        {
            max_d = max(max(diameter[field[i]], diameter[field[j]]),
                        max_sp[i] + a[i].distance(a[j]) + max_sp[j]);
            min_d = min(min_d, max_d);
        }
```
- **作者：StudyingFather（4星）**
    - **关键亮点**：详细分析新连通块直径的构成情况，指出常见错误做法，使用并查集维护连通块。
    - **核心代码**：
```cpp
// 并查集初始化
void init(int n) {
    this->n = n;
    for (int i = 1; i <= n; i++) fa[i] = i;
}
// 并查集查找
int find(int x) { return fa[x] == x? x : fa[x] = find(fa[x]); }
// Floyd 算法求最短路
for (int k = 1; k <= n; k++)
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
// 计算每个点在连通块内的最远路径及连通块直径
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++)
        if (ds.together(i, j))
            maxd[i] = max(maxd[i], d[i][j]);
    ad[ds.find(i)] = max(ad[ds.find(i)], maxd[i]);
}
// 找答案
for (int i = 1; i <= n; i++)
    for (int j = i + 1; j <= n; j++)
        if (!ds.together(i, j))
            ans = min(ans,
                      max(maxd[i] + maxd[j] + dist(p[i].x, p[i].y, p[j].x, p[j].y),
                          max(ad[ds.find(i)], ad[ds.find(j)])));
```
- **作者：tribool4_in（4星）**
    - **关键亮点**：结合 Floyd 和并查集，代码结构清晰，给出错误做法示例及分析。
    - **核心代码**：
```cpp
// 并查集查找
int find(int x) {
    if (fa[x] == x) return x;
    return fa[x] = find(fa[x]);
}
// Floyd 算法求最短路
for (int k = 1; k <= n; k++) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
        }
    }
}
// 计算每个点在连通块内的最远路径及连通块直径
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        if (ds.together(i, j)) {
            d[i] = max(d[i], f[i][j]);
        }
    }
    dd[ds.find(i)] = max(dd[ds.find(i)], d[i]);
}
// 找答案
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        if (!ds.together(i, j)) {
            d2 = min(d2,
                     max(d[i] + d[j] + dis(i, j),
                         max(dd[ds.find(i)], dd[ds.find(j)])));
        }
    }
}
```

### 最优关键思路或技巧
- **使用 Floyd 算法**：能方便地计算所有点对之间的最短路，时间复杂度为 $O(n^3)$，适合本题数据规模。
- **正确计算新牧场直径**：考虑三种情况，即原两个牧场的直径和连接两点后形成的新路径长度，避免只考虑一种情况导致错误。
- **连通块划分**：使用 DFS 或并查集划分连通块，便于后续枚举不同牧场的点。

### 拓展思路
同类型题可涉及在图中添加边使图的某种属性最优，如添加边使图的连通性更好、使图的某个指标（如平均距离）最小等。类似算法套路可总结为：先找出图的连通块，计算块内点的相关信息（如最短路、最远路径等），再枚举不同连通块的点进行操作，最后根据题目要求计算最优值。

### 推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：涉及 Floyd 算法的动态应用。
- [P2910 [USACO08OPEN]Clear And Present Danger S](https://www.luogu.com.cn/problem/P2910)：同样需要计算图中两点间的最短路径。
- [P1346 电车](https://www.luogu.com.cn/problem/P1346)：可使用 Floyd 算法解决图的路径问题。

### 个人心得摘录与总结
- **作者：Imakf**：指出只考虑“一个点能到的最远的点的距离 + 另一个点能到的最远的点的距离 + 两点间距离”这种做法是错误的，并给出反例，强调要考虑原牧场直径。总结为在解题时要全面考虑各种情况，避免遗漏。
- **作者：tribool4_in**：提到旧做法只考虑一种情况无法通过测试点，强调要将得到的直径与原直径取最大值。总结为做题时要仔细分析问题，避免使用不严谨的做法。 

---
处理用时：45.55秒
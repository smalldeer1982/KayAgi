# 题目信息

# 路径统计

## 题目描述

“RP 餐厅” 的员工素质就是不一般，在齐刷刷的算出同一个电话号码之后，就准备让 HZH,TZY 去送快餐了，他们将自己居住的城市画了一张地图，已知在他们的地图上，有 $N$ 个地方，而且他们目前处在标注为 “1” 的小镇上，而送餐的地点在标注为 “N” 的小镇。（有点废话）除此之外还知道这些道路都是单向的，从小镇 $I$ 到 $J$ 需要花费 $D[I, J]$ 的时间，为了更高效快捷的将快餐送到顾客手中，他们想走一条从小镇 $1$ 到小镇 $N$ 花费最少的一条路，但是他们临出发前，撞到因为在路上堵车而生气的 FYY，深受启发，不能仅知道一条路线，万一。。。于是，他们邀请 FYY 一起来研究起了下一个问题：这个最少花费的路径有多少条？


## 说明/提示

对于 $30\%$ 的数据 $N\leq 20$；

对于 $100\%$ 的数据 $1\leq N\leq 2000$，$0\leq E\leq N\times (N-1)$，$1\leq C\leq 10$。


## 样例 #1

### 输入

```
5 4
1 5 4
1 2 2
2 5 2
4 1 1
```

### 输出

```
4 2```

# AI分析结果

### 综合分析与结论
这些题解核心思路均为在 Dijkstra 算法基础上添加最短路径计数功能，同时要处理重边问题。不同题解在数据结构选择、去重方式和 Dijkstra 优化上有差异。如部分用邻接矩阵，部分用邻接表；去重有迭代器、空间换时间、STL 函数等方法；优化有堆优化、线段树优化等。

### 所选题解
- **作者：_WRYYY_（5星）**
    - **关键亮点**：思路清晰，详细阐述坑点、计数操作和去重方法，对比不同数据结构和初始化方式的运行时间，提供多种解决方案。
    - **个人心得**：提到在插入 1e8 以上级别数据时，`basic_string` 明显慢于 `vector`，一般数据量下二者均可选用。
- **作者：Texas_the_Omertosa（4星）**
    - **关键亮点**：明确指出本题坑点，代码结构清晰，函数模块化，便于理解和维护。
- **作者：_JF_（4星）**
    - **关键亮点**：不使用 Dijkstra 优化，适合不熟悉优化的同学，详细解释核心代码，说明计数原理。

### 重点代码及核心实现思想
#### _WRYYY_ 题解
```cpp
// 计数操作
if(dist[y]>dist[x]+e){
    dist[y]=dist[x]+e;
    ans[y]=ans[x];
    if(!v[y]){
        w.push(make_pair(dist[y],y));	
    }
}
else if(dist[y]==dist[x]+e) ans[y]+=ans[x];

// 迭代器去重
for(int i=1;i<=n;i++){
    sort(a[i].begin(),a[i].end());
    ls=INT_MAX;
    for(basic_string <pair<int,int> >::iterator it=a[i].begin();it!=a[i].end();++it){
        ls3=*it;
        if(ls3.first!=ls) ls=ls3.first;
        else {
            a[i].erase(it);
            --it;
        }
    }
}
```
核心思想：在 Dijkstra 算法中，当找到更优路径时更新距离和计数，路径长度相同时累加计数；使用迭代器对边排序后删除重边。

#### Texas_the_Omertosa 题解
```cpp
if(dis[y]>dis[ls]+z){
    dis[y]=dis[ls]+z;
    q.push(make_pair(-dis[y],y));
    ans[y]=0;
}
if(dis[y]==dis[ls]+z){
    ans[y]+=ans[ls];
}
```
核心思想：Dijkstra 算法中，更新最短距离时重置计数，距离相同时累加计数。

#### _JF_ 题解
```cpp
for(int j=1;j<=n;j++){
    if(minn+a[p][j]<dis[j]){
        dis[j]=minn+a[p][j];
        sum[j]=sum[p];
    }
    else if(dis[j]==dis[p]+a[p][j])
        sum[j]+=sum[p];
}
```
核心思想：遍历与当前点相连的节点，更新最短距离时继承计数，距离相同时累加计数。

### 最优关键思路或技巧
- **数据结构**：根据数据量选择合适的数据结构，一般情况 `basic_string` 和 `vector` 均可，大数据量用 `vector` + `emplace_back`。
- **去重方法**：使用迭代器、空间换时间或 STL 函数去重，避免重边影响结果。
- **计数操作**：在 Dijkstra 算法中，更新最短距离时更新计数，距离相同时累加计数。

### 拓展思路
同类型题可考虑在不同图算法（如 Bellman - Ford、Floyd 等）中添加计数功能，或处理更复杂的图结构（如无向图、带负权边的图等）。

### 推荐题目
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
- [P4779 单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
- [P1339 [USACO09OCT]Heat Wave G](https://www.luogu.com.cn/problem/P1339)

### 个人心得总结
- _WRYYY_：不同数据结构在不同数据量下性能有差异，需根据实际情况选择。
- _JF_：要注意数据范围，避免因数据问题导致错误。 

---
处理用时：32.37秒
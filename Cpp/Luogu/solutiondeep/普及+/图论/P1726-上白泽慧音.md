# 题目信息

# 上白泽慧音

## 题目描述

在幻想乡，上白泽慧音是以知识渊博闻名的老师。春雪异变导致人间之里的很多道路都被大雪堵塞，使有的学生不能顺利地到达慧音所在的村庄。因此慧音决定换一个能够聚集最多人数的村庄作为新的教学地点。

人间之里由 $N$ 个村庄（编号为 $1\cdots N$）和 $M$ 条道路组成，道路分为两种一种为单向通行的，一种为双向通行的，分别用 $1$ 和 $2$ 来标记。如果存在由村庄 $A$ 到达村庄 $B$ 的通路，那么我们认为可以从村庄 $A$ 到达村庄 $B$，记为 $(A,B)$。当 $(A,B)$ 和 $(B,A)$ 同时满足时，我们认为 $A,B$ 是绝对连通的，记为 $\langle A,B\rangle$。绝对连通区域是指一个村庄的集合，在这个集合中任意两个村庄 $X,Y$ 都满足 $\langle X,Y\rangle$。现在你的任务是，找出最大的绝对连通区域，并将这个绝对连通区域的村庄按编号依次输出。若存在两个最大的，输出字典序最小的，比如当存在 $1,3,4$ 和 $2,5,6$ 这两个最大连通区域时，输出的是 $1,3,4$。


## 说明/提示

- 对于 $60\%$ 的数据，$1\le N \le 200$，且 $0\le M \le 10^4$；
- 对于 $100\%$ 的数据，$1\le N \le 5\times 10^3$，且 $0\le M \le 5\times 10^4$。

## 样例 #1

### 输入

```
5 5
1 2 1
1 3 2
2 4 2
5 1 2
3 5 1
```

### 输出

```
3
1 3 5
```

# AI分析结果

### 综合分析与结论
本题主要求解图中最大的强连通分量，并按字典序输出其中的村庄编号。大部分题解采用Tarjan算法，少数使用Kosaraju算法，还有一个使用dfs+并查集的方法。Tarjan算法基于深度优先搜索，通过维护`dfn`和`low`数组来寻找强连通分量；Kosaraju算法则通过两次深度优先搜索，先求拓扑序，再用反图搜索得到强连通分量。

### 所选题解
- **作者：_H1kar1（5星）**
    - **关键亮点**：详细讲解Tarjan算法，配有图示，代码注释丰富，对字典序输出的处理有说明。
    - **个人心得**：提到本题数据略水，部分题解未考虑字典序也能AC，提醒同学们注意。
    - **核心代码**：
```cpp
void tarjan(int x){
    dfn[x]=low[x]=++tmmk;
    S.push(x);
    instk[x]=true;
    for(int i=head[x];i;i=nxt[i]){
        int y=G[i].y;
        if(!dfn[y]){
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(instk[y])
            low[x]=min(low[x],dfn[y]);
    }
    if(dfn[x]==low[x]){
        cnt++;
        int y;
        p[cnt].diction=S.top();
        do{
            y=S.top();
            S.pop();
            instk[y]=false;
            col[y]=cnt;
            p[cnt].p=cnt;
            p[cnt].siz++;
            g[cnt].push(y);
        }while(y!=x);
    }
}
```
    - **核心思想**：在深度优先搜索过程中，对于未访问的节点递归调用`tarjan`函数，更新`low`值；对于已访问且在栈中的节点，用其`dfn`值更新当前节点的`low`值。当`dfn[x] == low[x]`时，说明找到了一个强连通分量，将栈中元素弹出并记录。

- **作者：TJor（4星）**
    - **关键亮点**：详细解释Tarjan算法思路，配有详细过程图示和伪代码，有助于理解。
    - **核心代码**：
```cpp
void tarjan(int u)
{
    in++;
    dfn[u]=in;
    low[u]=in;
    S.push(u);
    vis[u]=1;
    for(int e=head[u];e;e=next[e])
    {
        if(!dfn[to[e]])
        {
            tarjan(to[e]);
            low[u]=min(low[to[e]],low[u]);
        }
        else if(vis[to[e]])
            low[u]=min(low[u],dfn[to[e]]);
    }
    if(low[u]==dfn[u])
    {
        while(!S.empty() && S.top()!=u)
        {
            vis[S.top()]=0;
            S.pop(); 
        } 
        vis[u]=0;
        S.pop();
        ans++;
    }
}
```
    - **核心思想**：与上一题解类似，通过深度优先搜索和栈来维护节点信息，当`dfn[u] == low[u]`时，弹出栈中元素，统计强连通分量个数。

- **作者：hl666（4星）**
    - **关键亮点**：介绍了Kosaraju算法，提供了不同于Tarjan的解题思路。
    - **核心代码**：
```cpp
inline void dfs(int k)
{
    f[k]=0;
    for (int i=0;i<a[k].size();++i)
    if (f[a[k][i]]) dfs(a[k][i]);
    s.push_back(k);
}
inline void rdfs(int k)
{
    f[k]=0;
    t[tot].push_back(k);
    for (int i=0;i<b[k].size();++i)
    if (f[b[k][i]]) rdfs(b[k][i]);
}
```
    - **核心思想**：第一次`dfs`对原图进行深度优先搜索，将节点按完成时间压入栈中；第二次`rdfs`从栈顶开始对反图进行深度优先搜索，每次搜索到的节点构成一个强连通分量。

### 最优关键思路或技巧
- **Tarjan算法**：通过维护`dfn`（时间戳）和`low`（能访问到的最早祖先的`dfn`值）数组，利用栈来记录节点，在深度优先搜索过程中判断强连通分量。
- **字典序处理**：在找到最大强连通分量后，通过比较最小编号或对节点排序来保证字典序输出。
- **Kosaraju算法**：通过两次深度优先搜索，先求拓扑序，再用反图搜索得到强连通分量，避免了Tarjan算法中复杂的`low`数组更新。

### 拓展思路
同类型题或类似算法套路：
- 缩点问题：在求出强连通分量后，将每个

---
处理用时：37.97秒
# 题目信息

# 佳佳的魔法药水

## 题目背景

发完了 $k$ 张照片，佳佳却得到了一个坏消息：他的 MM 得病了！佳佳和大家一样焦急万分！治好 MM 的病只有一种办法，那就是传说中的 $0$ 号药水…… 怎么样才能得到 $0$ 号药水呢？你要知道佳佳的家境也不是很好，成本得足够低才行……

## 题目描述

**存在 ab 相同 c 不同的情况，与题意相悖**。题还是可以做，但数据待修正。

得到一种药水有两种方法：可以按照魔法书上的指导自己配置，也可以到魔法商店里去买——那里对于每种药水都有供应，虽然有可能价格很贵。在魔法书上有很多这样的记载：

$1$ 份 A 药水混合 $1$ 份 B 药水就可以得到 $1$ 份 C 药水。（至于为什么 $1 + 1 = 1$，因为……这是魔法世界）好了，现在你知道了需要得到某种药水，还知道所有可能涉及到的药水的价格以及魔法书上所有的配置方法，现在要问的就是：

1. 最少花多少钱可以配制成功这种珍贵的药水；

2. 共有多少种不同的花费最少的方案（两种可行的配置方案如果有任何一个步骤不同则视为不同的）。假定初始时你手中并没有任何可以用的药水。


## 说明/提示

数据范围：

每一种药水的价格均 $\ge 1$ 且 $\le 2.8\times 10^4$。

样例说明：

最优方案有 $3$ 种，分别是：

- 直接买 $0$ 号药水；
- 买 $4$ 号药水、$5$ 号药水配制成 $1$ 号药水，直接买 $2$ 号药水，然后配制成 $0$ 号药水；
- 买 $4$ 号药水、$5$ 号药水配制成 $1$ 号药水，买 $3$ 号药水、$6$ 号药水配制成 $2$ 号药水，然后配制成 $0$ 号药水。

## 样例 #1

### 输入

```
7 
10 5 6 3 2 2 3 
1 2 0 
4 5 1 
3 6 2
```

### 输出

```
10 3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何用最少花费配制出目标药水以及计算最少花费的方案数展开。大部分题解采用了 Dijkstra 算法，少部分使用 SPFA 算法结合记忆化搜索。Dijkstra 算法的关键在于每次选择最小花费且未确定最小值的药水去更新其他药水的花费和方案数；SPFA 算法则是不断迭代更新，最后用记忆化搜索计算方案数。

### 所选题解
- **作者：Seg_Tree（5 星）**
  - **关键亮点**：使用小根堆优化和链式前向星，优化了 Dijkstra 算法，提升了效率；详细说明了本题与 Dijkstra 模板的不同及处理方法，还指出了题面未提到的坑点。
  - **个人心得**：提到其他题解的 Dijkstra 比较“野蛮”，使用小根堆优化和链式前向星后有优越感，同时吐槽了题目的读入方式。
- **作者：KKKZOZ（4 星）**
  - **关键亮点**：从 DP 角度思考问题，提供了 Dijkstra 和 SPFA 两种解决环形依赖的思路，并采用 SPFA 算法结合记忆化搜索求解，思路清晰。
  - **个人心得**：指出在“图状”DP 中遇到环形依赖的两种解决办法，还提到 SPFA 不是按拓扑序转移，所以不能在计算最短路时同时记录最短路条数。
- **作者：半仙胡小桃（4 星）**
  - **关键亮点**：思路清晰，直接使用 Dijkstra 算法解决问题，对方案数的更新情况进行了分类讨论。
  - **个人心得**：吐槽题目没有数据范围，导致 RE 了一次。

### 重点代码
#### Seg_Tree 的核心代码
```cpp
// 链式前向星存边
void add_edg(int u1,int u2,int v){
    edg[++tot_edg].u2=u2;
    edg[tot_edg].v=v;
    edg[tot_edg].nxt=head[u1];
    head[u1]=tot_edg;
}

// Dijkstra 核心更新部分
while(!q.empty()){
    int c=q.top().first,u=q.top().second;
    q.pop();
    if(c!=ptn[u].cst)continue;
    ptn[u].v=1;
    for(int i=head[u]; i; i=edg[i].nxt){
        int x=edg[i].u2,v=edg[i].v;
        if(ptn[x].v){
            if(ptn[v].cst>c+ptn[x].cst){
                ptn[v].ans=ptn[u].ans*ptn[x].ans;
                ptn[v].cst=c+ptn[x].cst;
                q.push(make_pair(ptn[v].cst,v));
            }
            else if(ptn[v].cst==c+ptn[x].cst){
                ptn[v].ans+=ptn[u].ans*ptn[x].ans;
            }
        }
    }
}
```
**核心实现思想**：使用链式前向星存储药水的合成关系，小根堆优先队列存储当前最小花费的药水。每次从队列中取出最小花费的药水，若其花费未更新则跳过，否则标记该药水已确定最小花费，然后遍历其能合成的药水，若另一种原料药水也已确定最小花费，则更新合成药水的花费和方案数。

#### KKKZOZ 的核心代码
```cpp
// SPFA 算法更新最小花费
void spfa() {
    queue<int> q;
    for (int i = 0; i <= n - 1; i++) {
        q.push(i);
        f[i] = w[i];
        vis[i] = 1;
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for (int i = head[u]; i != -1; i = e[i].next) {
            int a = e[i].a, b = e[i].b;
            if (f[u] > f[a] + f[b]) {
                f[u] = f[a] + f[b];
                for (auto v: belongs[u])
                    if (vis[v] == 0)
                        vis[v] = 1, q.push(v);
            }
        }
    }
}

// 记忆化搜索计算方案数
int dfs(int u) {
    if (tot[u] != 0) return tot[u];
    if (f[u] == w[u]) tot[u]++;
    for (int i = head[u]; i != -1; i = e[i].next) {
        int a = e[i].a, b = e[i].b;
        if (f[u] == f[a] + f[b]) {
            tot[a] = dfs(a);
            tot[b] = dfs(b);
            tot[u] += tot[a] * tot[b];
        }
    }
    return tot[u];
}
```
**核心实现思想**：SPFA 算法将所有点入队，不断迭代更新每个点的最小花费，若某个点的花费变小，则将所有以该点为原料的药水入队。记忆化搜索从目标药水开始递归计算方案数，若当前药水的最小花费等于直接购买的花费，则方案数加 1，否则根据合成关系递归计算。

#### 半仙胡小桃的核心代码
```cpp
for(int i=1;i<n;i++)
{
    int maxn=0x7fffffff;
    for(int j=1;j<=n;j++)
        if(!f[j]&&cost[j]<maxn) 
            b=j,maxn=cost[j];
    
    f[b]=1;
    
    for(int j=1;j<=n;j++)
        if(f[j]&&soc[b][j])
        {
            if(cost[b]+cost[j]==cost[soc[b][j]])
                ans[soc[b][j]]+=ans[b]*ans[j];
            if(cost[b]+cost[j]<cost[soc[b][j]]) 
                cost[soc[b][j]]=cost[b]+cost[j],ans[soc[b][j]]=ans[b]*ans[j];
        }
}
```
**核心实现思想**：每次选择一个未确定最小花费且花费最小的药水，标记其已确定最小花费，然后遍历所有已确定最小花费的药水，若两者能合成新药水，则更新新药水的花费和方案数。

### 最优关键思路或技巧
- **数据结构**：使用链式前向星存储药水的合成关系，相比邻接矩阵节省空间，提高效率。
- **算法优化**：小根堆优化 Dijkstra 算法，能更快地找到最小花费的药水。
- **思维方式**：将药水合成问题抽象为图论问题，利用 Dijkstra 或 SPFA 算法求解最小花费，再用乘法原理计算方案数。

### 可拓展之处
同类型题或类似算法套路：
- 涉及资源合成、转换的问题，如化学物质合成、游戏道具合成等，可抽象为图论问题，使用最短路算法求解最优方案。
- 有环形依赖的动态规划问题，可借鉴本题中 Dijkstra 和 SPFA 解决环形依赖的思路。

### 推荐题目
- P1346 电车：涉及图的最短路问题，需要处理不同路径的选择。
- P1144 最短路计数：与本题类似，需要计算最短路的条数。
- P4779 单源最短路径（标准版）：标准的最短路问题，可练习 Dijkstra 算法的使用。

---
处理用时：47.22秒
# 题目信息

# 套利

## 题目描述

套利是利用汇率差异实现货币增值。例如，1美元可以兑换0.5英镑、1英镑可以兑换10法郎、1法郎可以兑换0.21美元。接下来，一个聪明的交易商就可以从1美元开始，0.5 \* 10.0 \* 0.21 =1.05美元，获得了5%的利润。

你的任务是写一个程序，从输入文件读入汇率清单，然后决定套利是有可能的或没有可能的。


## 样例 #1

### 输入

```
3
USDollar
BritishPound
FrenchFranc
3
USDollar 0.5 BritishPound
BritishPound 10.0 FrenchFranc
FrenchFranc 0.21 USDollar

3
USDollar
BritishPound
FrenchFranc
6
USDollar 0.5 BritishPound
USDollar 4.9 FrenchFranc
BritishPound 10.0 FrenchFranc
BritishPound 1.99 USDollar
FrenchFranc 0.09 BritishPound
FrenchFranc 0.19 USDollar

0
```

### 输出

```
Case 1: Yes
Case 2: No
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是将汇率问题抽象为图论问题，通过判断图中是否存在边权之积大于 1 的环来确定是否能套利。不同题解使用了不同的图论算法，包括 SPFA、Floyed、Bellman - Ford 等。

### 所选题解
- **作者：Created_equal1（4星）**
    - **关键亮点**：思路清晰，使用 SPFA 算法判环，代码结构规范，注释较为详细，易于理解。
- **作者：米奇奇米（4星）**
    - **关键亮点**：使用 Floyed 算法解决问题，对于数据范围较小的情况，时间复杂度可以接受，代码实现简洁明了。
- **作者：UnyieldingTrilobite（4星）**
    - **关键亮点**：将汇率转化为对数，把乘法问题转化为加法问题，避免了浮点误差，同时使用 SPFA 判正环，思路巧妙。

### 重点代码与核心思想
#### Created_equal1 的 SPFA 判环
```cpp
bool spfa(const size_t &S)
{
    memset(Dist, 0, sizeof(Dist));
    memset(In_queue, 0, sizeof(In_queue));
    memset(Times, 0, sizeof(Times));
    std::deque<size_t> Q;
    
    Dist[S] = 1.0;
    In_queue[S] = true;
    Q.push_back(S);
    Times[S] = 1;
    
    while (!Q.empty())
    {
        size_t top = Q.front();
        In_queue[top] = false;
        Q.pop_front();
        
        for (int i = Head[top];i != 0;i = Next[i])
            if (Dist[Adj[i]] < Dist[top] * Weight[i])
            {
                Dist[Adj[i]] = Dist[top] * Weight[i];
                if (!In_queue[Adj[i]])
                {
                    In_queue[Adj[i]] = true;
                    Q.push_back(Adj[i]);
                    ++Times[Adj[i]];
                    if (Times[Adj[i]] >= n)
                        return true;
                }
            }
    }
    
    return false;
}
```
**核心思想**：使用 SPFA 算法进行松弛操作，将普通的加法松弛改为乘法松弛，当某个节点入队次数超过节点数时，说明存在环。

#### 米奇奇米的 Floyed 最长路
```cpp
bool floyd(){
    int i,j,k;
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++){
                if(a[i][j]<a[i][k]*a[k][j]){
                    a[i][j]=a[i][k]*a[k][j];
                }
            }
    for(int i=1;i<=n;i++){
        if(a[i][i]>1)
            return true;
    }
    return false;
}
```
**核心思想**：使用 Floyed 算法计算任意两点间的最长路，最后检查是否存在节点到自身的路径权值大于 1。

#### UnyieldingTrilobite 的 SPFA 判正环
```cpp
bool spfa(){
    memset(d,0,sizeof(d));
    memset(in,0,sizeof(in));
    memset(cnt,0,sizeof(cnt));
    queue<int>qu;
    for(int i=0;i<n;i++)qu.push(i),in[i]=cnt[i]=1; 
    while(!qu.empty()){ 
        int f=qu.front(),v;qu.pop();in[f]=0; 
        for(int i=0;i<to[f].size();i++)
            if(d[v=to[f][i]]<w[f][i]+d[f]){ 
                d[v]=w[f][i]+d[f];  
                if(!in[v])in[v]=1,cnt[v]++,qu.push(v); 
                if(cnt[v]>n)return 1;
            }
    }
    return 0; 
}
```
**核心思想**：将汇率取对数，把乘法转化为加法，使用 SPFA 算法判断是否存在正环。

### 最优关键思路或技巧
- **图论建模**：将汇率问题抽象为有向图，货币作为节点，汇率作为边权，将套利问题转化为图中是否存在边权之积大于 1 的环的问题。
- **对数转化**：将汇率取对数，把乘法问题转化为加法问题，避免了浮点误差，方便使用传统的图论算法判环。

### 可拓展之处
同类型题如判断图中是否存在负环、正环等问题，都可以使用 SPFA、Bellman - Ford 等算法解决。类似算法套路包括在图论问题中，根据问题特点对边权进行适当的转化，以满足算法的使用条件。

### 推荐洛谷题目
- P3385 【模板】负环
- P1119 灾后重建
- P2850 [USACO06DEC]Wormholes G

### 个人心得
- **UnyieldingTrilobite**：提到为了避免浮点误差，将汇率转化为其对数，因为 $\ln a+\ln b=\ln(ab)$，所以图中有边权之积 > 1 的环等价于处理后的图中有正环，这种转化思路很巧妙。 

---
处理用时：38.52秒
# 题目信息

# 小 K 的农场

## 题目描述

小 K 在 MC 里面建立很多很多的农场，总共 $n$ 个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共 $m$ 个），以下列三种形式描述：  
- 农场 $a$ 比农场 $b$ 至少多种植了 $c$ 个单位的作物；
- 农场 $a$ 比农场 $b$ 至多多种植了 $c$ 个单位的作物；
- 农场 $a$ 与农场 $b$ 种植的作物数一样多。  

但是，由于小 K 的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。  


## 说明/提示

对于 $100\%$ 的数据，保证 $1 \le n,m,a,b,c \le 5 \times 10^3$。

## 样例 #1

### 输入

```
3 3
3 1 2
1 1 3 1
2 2 3 2
```

### 输出

```
Yes
```

# AI分析结果

### 综合分析与结论
这些题解均采用差分约束算法解决问题，整体思路一致：先将题目中的条件转化为不等式，再根据不等式建图，最后通过 SPFA 算法判断图中是否存在负环来确定是否有解。不同题解在代码实现、细节处理和优化上略有差异。

### 所选题解
- **作者：SDqwq（5星）**
  - 关键亮点：思路清晰，详细解释了不等式转化和建图的过程，代码注释丰富，可读性高。
- **作者：傅天宇（4星）**
  - 关键亮点：详细列出不等式转化过程，代码结构清晰，使用链式前向星建图。
- **作者：一只书虫仔（4星）**
  - 关键亮点：对差分约束的原理进行了详细推导，给出相关模板题链接，有一定的拓展性。

### 重点代码及核心实现思想
#### 不等式转化与建图
```cpp
// 以 SDqwq 题解为例
for (int i = 1; i <= m; i++) {
    int opt;
    scanf("%d", &opt);
    switch (opt) {
        case 1: {
            int a, b, c;
            scanf("%d %d %d", &a, &b, &c);
            add(a, b, -c); // a - b >= c 转化为 b <= a - c
            break;
        }
        case 2: {
            int a, b, c;
            scanf("%d %d %d", &a, &b, &c);
            add(b, a, c); // a - b <= c 转化为 a <= b + c
            break;
        }
        case 3: {
            int a, b;
            scanf("%d %d", &a, &b);
            add(a, b, 0);
            add(b, a, 0); // a = b 转化为 a <= b + 0 且 b <= a + 0
            break;
        }
    }
}
```
核心思想：将题目中的条件转化为不等式，再根据不等式的形式建图，若存在 $x_i \leq x_j + c$ 的不等式，则从 $j$ 到 $i$ 建一条边权为 $c$ 的有向边。

#### SPFA 判断负环
```cpp
// 以 SDqwq 题解为例
bool spfa (int x) {
    dis[x] = 0;
    q.push(x);
    vis[x] = true;
    num[x]++;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = elast[u]; i != 0; i = e[i].next)
            if (dis[e[i].to] > dis[u] + e[i].len) {
                dis[e[i].to] = dis[u] + e[i].len;
                if (!vis[e[i].to]) {
                    q.push(e[i].to);
                    vis[e[i].to] = true;
                    num[e[i].to]++;
                    if (num[e[i].to] == n + 1)
                        return false; // 入队次数 >= n + 1 说明存在负环
                }
            }
    }
    return true;
}
```
核心思想：使用 SPFA 算法求最短路，同时记录每个点的入队次数，若某个点的入队次数超过 $n + 1$，则说明图中存在负环，不等式组无解。

### 最优关键思路或技巧
- **差分约束思想**：将题目中的条件转化为不等式，再通过建图和最短路算法求解不等式组是否有解。
- **超级源点**：为了避免图不连通的情况，引入超级源点，与所有点相连，边权为 0。
- **负环判断**：使用 SPFA 算法，通过记录每个点的入队次数来判断图中是否存在负环。

### 可拓展之处
同类型题或类似算法套路：差分约束算法可用于解决各种不等式组的求解问题，如区间约束、时间约束等。遇到类似题目，可先将条件转化为不等式，再建图求解。

### 推荐题目
- [P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)
- [P1260 工程规划](https://www.luogu.com.cn/problem/P1260)
- [P3275 [SCOI2011]糖果](https://www.luogu.com.cn/problem/P3275)

### 个人心得
- **Stinger**：提到 SPFA 加了 SLF 用时 103ms，不加超过 500ms，推荐使用 SLF 优化，以应对评测机不稳定的情况。

---
处理用时：31.15秒
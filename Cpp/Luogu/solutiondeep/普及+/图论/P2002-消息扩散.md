# 题目信息

# 消息扩散

## 题目背景

本场比赛第一题，给个简单的吧，这 100 分先拿着。

## 题目描述

有 $n$ 个城市，中间有单向道路连接，消息会沿着道路扩散，现在给出 $n$ 个城市及其之间的道路，问至少需要在几个城市发布消息才能让这所有 $n$ 个城市都得到消息。

## 说明/提示

**【样例解释 #1】**

样例中在 $4, 5$ 号城市中发布消息。

**【数据范围】**

对于 $20 \%$ 的数据，$n \le 200$；  
对于 $40 \%$ 的数据，$n \le 2000$；  
对于 $100 \%$ 的数据，$1 \le n \le {10}^5$，$1 \le m \le 5 \times {10}^5$。

## 样例 #1

### 输入

```
5 4
1 2
2 1
2 3
5 1
```

### 输出

```
2
```

# AI分析结果

### 综合分析与结论
这些题解大多采用缩点算法解决问题，核心思路是将有向图中的强连通分量缩成一个点，把图转化为有向无环图（DAG），再统计入度为 0 的点的个数，此数量即为最少需要发布消息的城市数量。

### 所选题解
- 作者：唔啊唔（5星）
    - 关键亮点：思路清晰，对 tarjan 算法基本思路有解释，代码注释详细，还提及与相似题目的关联。
    - 个人心得：无
- 作者：Amessal（4星）
    - 关键亮点：明确指出处理自环的方法，代码简洁，逻辑清晰。
    - 个人心得：无
- 作者：PrincessYR✨～（4星）
    - 关键亮点：用 vector 存图，对强连通分量和 Tarjan 算法讲解详细，配有示例图辅助理解。
    - 个人心得：本蒟蒻苦哈哈的学了好几天才学会强连通分量和缩点。

### 重点代码及核心思想
#### 唔啊唔的题解
```cpp
inline void tarjan(int x){
    cnt++;
    dfn[x]=low[x]=cnt;
    s.push(x);
    vis[x]=1;
    for(register int i=head[x];i;i=edge[i].next){
        int y=edge[i].to;
        if(dfn[y]==0){
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(vis[y]==1){
            low[x]=min(low[x],dfn[y]);
        }
    }
    if(low[x]==dfn[x]){
        int z;
        tot++;
        while(s.top()!=x){
            sum[tot]++;
            z=s.top();
            vis[z]=0;
            bj[z]=tot;
            s.pop();
        }
        sum[tot]++;
        z=s.top();
        vis[z]=0;
        bj[z]=tot;
        s.pop();
    }
    return;
}
```
核心思想：使用 tarjan 算法求强连通分量，通过 dfn 和 low 数组标记节点的访问顺序和能追溯到的最早节点，将强连通分量中的节点标记到同一编号。

#### Amessal 的题解
```cpp
inline void dfs(int x){
    low[x]=dfn[x]=++Ind;
    stack[++top]=x;in[x]=true;
    for(int i=first[x];i;i=nxt[i]){
        int v=to[i];
        if(!dfn[v]){
            dfs(v);
            low[x]=min(low[x],low[v]);
        }
        else if(in[v]) low[x]=min(low[x],dfn[v]);
    }
    if(low[x]==dfn[x]){
        ++pointnum;
        int j=-1;
        while(j!=x){
            j=stack[top--];
            belong[j]=pointnum;
            in[j]=false;
        }
    }
}
```
核心思想：同样是 tarjan 算法求强连通分量，将节点标记到对应的强连通分量编号，最后统计入度为 0 的强连通分量个数。

#### PrincessYR✨～的题解
```cpp
void tarjan(int now){
    dfn[now]=low[now]=++num;
    atack.push(now);
    inst[now]=true;
    for(int i=0;i<map[now].size();i++){
        int next=map[now][i];
        if(dfn[next]==0){
            tarjan(next);
            low[now]=min(low[now],low[next]);
        }else if(inst[next]==1){
            low[now]=min(low[now],dfn[next]);
        }
    }
    if(dfn[now]==low[now]){
        numb++;
        int q;
        do{
            q=atack.top();
            inst[q]=0;
            atack.pop();
            bl[q]=numb;
            nums[numb]++;
        }while(q!=now);
    }
}
```
核心思想：用 vector 存图实现 tarjan 算法，找出强连通分量并标记，最后统计入度为 0 的强连通分量个数。

### 最优关键思路或技巧
- 利用 tarjan 算法求强连通分量，将有向图缩点转化为 DAG。
- 统计入度为 0 的点时，可直接遍历边，判断边的起点和终点是否在同一强连通分量中，若不在则更新终点所在强连通分量的入度。

### 拓展思路
同类型题目通常涉及图的连通性问题，可使用缩点算法将复杂图简化为 DAG 求解。类似算法套路包括使用 Kosaraju 算法求强连通分量、拓扑排序等。

### 推荐题目
1. [P1262 间谍网络](https://www.luogu.org/problem/P1262)
2. [P2341 [HAOI2006]受欢迎的牛|【模板】强连通分量](https://www.luogu.org/problem/P2341)
3. [P3627 [APIO2009]抢掠计划](https://www.luogu.org/problem/P3627)

### 个人心得总结
- PrincessYR✨～：学习强连通分量和缩点花费了较多时间，需要耐心学习和理解。
- Yuyuanqi：用 map 判重边导致一个点超时，删去 map 特判自环后通过，说明重边对本题可能无影响。
- 小黑：本题会卡常数，在统计入度时需注意。
- 说好不哭：对 tarjan 缩点不熟练，模板易打错，通过写题解巩固总结。 

---
处理用时：41.68秒
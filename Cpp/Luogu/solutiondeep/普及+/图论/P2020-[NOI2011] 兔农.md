# 题目信息

# [NOI2011] 兔农

## 题目描述

农夫栋栋近年收入不景气，正在他发愁如何能多赚点钱时，他听到隔壁的小朋友在讨论兔子繁殖的问题。

问题是这样的：第一个月初有一对刚出生的小兔子，经过两个月长大后，这对兔子从第三个月开始，每个月初生一对小兔子。新出生的小兔子生长两个月后又能每个月生出一对小兔子。问第 $n$ 个月有多少只兔子？

聪明的你可能已经发现，第 $n$ 个月的兔子数正好是第 $n$ 个 Fibonacci（斐波那契）数。栋栋不懂什么是 Fibonacci 数，但他也发现了规律：第 $i+2$ 个月的兔子数等于第 $i$ 个月的兔子数加上第 $i+1$ 个月的兔子数。前几个月的兔子数依次为：

$$1,1,2,3,5,8,13,21,34,\ldots$$

栋栋发现越到后面兔子数增长的越快，期待养兔子一定能赚大钱，于是栋栋在第一个月初买了一对小兔子开始饲养。

每天，栋栋都要给兔子们喂食，兔子们吃食时非常特别，总是每 $k$ 对兔子围成一圈，最后剩下的不足 $k$ 对的围成一圈，由于兔子特别害怕孤独，从第三个月开始，如果吃食时围成某一个圈的只有一对兔子，这对兔子就会很快死掉。

我们假设死去的总是刚出生的兔子，那么每个月的兔子数仍然是可以计算的。例如，当 $k=7$ 时，前几个月的兔子数依次为：

$$1,1,2,3,5,7,12,19,31,49,80,\ldots$$

给定 $n$，你能帮助栋栋计算第 $n$ 个月他有多少对兔子么？由于答案可能非常大，你只需要告诉栋栋第 $n$ 个月的兔子对数除 $p$ 的余数即可。


## 说明/提示

|测试点编号|$n$|$k,p$|
|:-:|:-:|:-:|
|$1\sim 10$|$1\leq n\leq 50$|$2\leq k,p\leq1000$|
|$11$|$1\leq n\leq 80$|$2\leq k,p\leq 10^4$|
|$12,13$|$1\leq n\leq 1000$|$2\leq k,p\leq 10^4$|
|$14,15$|$1\leq n\leq 10^6$|$2\leq k,p\leq 10^6$|
|$16,17$|$1\leq n\leq 10^{18}$|$2\leq k,p\leq1000$|
|$18\sim 20$|$1\leq n\leq 10^{18}$|$2\leq k\leq 10^6$，$2\leq p\leq 10^9$|

对于 $100\%$ 的数据，$1\leq n\leq 10^{18}$，$2\leq k\leq 10^6$，$2\leq p\leq 10^9$。


## 样例 #1

### 输入

```
6 7 100```

### 输出

```
7```

## 样例 #2

### 输入

```
7 7 5```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
本题是一道结合斐波那契数列和矩阵快速幂的题目，难点在于数列中存在特殊的减一操作，且数据范围较大。各题解的核心思路均是通过寻找数列的循环节，再利用矩阵快速幂进行计算。
- **思路**：先分析数列的规律，发现以取模 \(k\) 等于 \(1\) 的数为分割点，每一段都是斐波那契数列的倍数形式。通过枚举斐波那契数列的项，利用乘法逆元求出每段的长度和开头数字，进而找到循环节。
- **算法要点**：预处理斐波那契数列，使用扩展欧几里得算法求逆元，构建转移矩阵并使用矩阵快速幂进行计算。
- **解决难点**：处理没有逆元的特殊情况，以及在找到循环节后，根据 \(n\) 的大小进行分类讨论，分别处理循环节前、循环节内和剩余部分的计算。

### 所选题解
- **TimWYZ（5星）**
    - **关键亮点**：思路清晰，对规律的分析详细，代码注释丰富，对特殊情况的处理和分类讨论明确。
- **Wilderness_（4星）**
    - **关键亮点**：思路循序渐进，从简单模拟到发现规律，再到利用循环节和矩阵快速幂求解，代码实现完整。
- **wlzhouzhuan（4星）**
    - **关键亮点**：代码结构清晰，对复杂度进行了分析，使用了一些优化技巧，如预处理和矩阵快速幂的重载。

### 重点代码
#### TimWYZ 的核心代码
```c++
// 求逆元
ll getInv(ll a, ll P) {
    if (GCD(a, P) != 1) return -1; // 不互质，无逆元。
    ll x, y;
    exGCD(a, P, x, y);
    return (x % P + P) % P;
}

// 矩阵快速幂
Matrix quickPower(Matrix a, ll b) {
    Matrix ret;
    for (int i = 1; i <= SZ; i++) ret.o[i][i] = 1;

    while (b) {
        if (b & 1) ret = ret * a;
        a = a * a;
        b >>= 1;
    }
    return ret;
}
```
**核心思想**：`getInv` 函数用于求逆元，若两数不互质则返回 -1。`quickPower` 函数实现矩阵快速幂，通过二进制拆分的方式减少计算量。

#### Wilderness_ 的核心代码
```cpp
// 矩阵乘法
Matrix operator*(const Matrix &b) const {
    Matrix res;
    for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            for(int k=1;k<=3;k++)
                res.a[i][j]=((res.a[i][j]+a[i][k]*b.a[k][j])+p)%p;
    return res;
}

// 矩阵快速幂
Matrix qpow(ll x,Matrix base) {
    Matrix res;
    setm(res);
    while(x) {
        if(x&1)res=res*base;
        base=base*base;
        x>>=1;
    }
    return res;
}
```
**核心思想**：重载矩阵乘法运算符，实现矩阵乘法。`qpow` 函数实现矩阵快速幂，同样采用二进制拆分的方法。

#### wlzhouzhuan 的核心代码
```cpp
// 矩阵乘法
MAT operator * (MAT a, MAT b) {
    MAT ans(a.n, b.m);
    for (rint i = 0; i < a.n; i++) {
        for (rint j = 0; j < b.m; j++) {
            for (rint k = 0; k < a.m; k++) {
                ans.v[i][j] = (ans.v[i][j] + a.v[i][k] * b.v[k][j]) % p;
            }
        }
    }
    return ans;
}

// 矩阵快速幂
MAT operator ^ (MAT a, ll b) {
    MAT ans(a.n, a.m);
    for (rint i = 0; i < a.n; i++) ans.v[i][i] = 1;
    while (b > 0) {
        if (b & 1) ans = ans * a;
        a = a * a;
        b >>= 1;
    }  
    return ans;
}
```
**核心思想**：重载矩阵乘法和矩阵快速幂运算符，实现矩阵的乘法和快速幂运算。

### 最优关键思路或技巧
- **寻找循环节**：通过分析数列的规律，发现以取模 \(k\) 等于 \(1\) 的数为分割点，每段都是斐波那契数列的倍数形式，利用乘法逆元求出每段的长度和开头数字，进而找到循环节，大大减少了计算量。
- **矩阵快速幂**：使用矩阵快速幂来加速数列的计算，将时间复杂度从线性降低到对数级别。
- **分类讨论**：对没有逆元的特殊情况和 \(n\) 在不同位置（循环节前、循环节内、剩余部分）进行分类讨论，确保算法的正确性。

### 可拓展之处
同类型题目通常涉及数列的递推和取模运算，可能会有不同的特殊规则。类似的算法套路包括寻找数列的循环节、利用矩阵快速幂加速计算、处理特殊情况等。例如，一些题目可能会在数列递推时加入更多的条件判断，或者改变取模的规则。

### 推荐题目
- [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)：基础的斐波那契数列矩阵快速幂题目。
- [P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)：矩阵快速幂的模板题，可用于练习矩阵快速幂的实现。
- [P5110 块速递推](https://www.luogu.com.cn/problem/P5110)：涉及数列递推和矩阵快速幂的题目，难度稍高。

### 个人心得
- **Wilderness_**：按题意模拟直接求斐波那契数列后判断是否取模 \(k\) 等于 \(1\) 得了 \(75\) 分，使用矩阵快速幂不考虑其他只拿了 \(55\) 分，分析后发现取模 \(m\) 后可能影响原取模 \(k\) 的结果，从而尝试寻找其他解法。
**总结**：在解题过程中，简单的模拟和直接应用算法可能无法得到满分，需要仔细分析取模运算对结果的影响，尝试寻找更优的解法。

---
处理用时：44.26秒
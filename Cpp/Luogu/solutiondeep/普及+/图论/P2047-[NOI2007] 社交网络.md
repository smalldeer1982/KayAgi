# 题目信息

# [NOI2007] 社交网络

## 题目描述

在社交网络 ( Social Network ) 的研究中，我们常常使用图论概念去解释一些社会现象。不妨看这样的一个问题:   
在一个社交圈子里有 $n$ 个人，人与人之间有不同程度的关系。我们将这个关系网络对应到一个 $n$ 个结点的无向图上，两个不同的人若互相认识，则在他们对应的结点之间连接一条无向边，并附上一个正数权值 $c$ ，$c$ 越小，表示两个人之间的关系越密切。我们可以用对应结点之间的最短路长度来衡量两个人 $s$ 和 $t$ 之间的关系密切程度，注意到最短路径上的其他结点为 $s$ 和 $t$ 的联系提供了某种便利，即这些结点对于 $s$ 和 $t$ 之间的联系有一定的重要程度。我们可以通过统计经过一个结点 $v$ 的最短路径的数目来衡量该结点在社交网络中的重要程度。考虑到两个结点 $A$ 和 $B$ 之间可能会有多条最短路径。我们修改重要程度的定义如下：令 $C_{s,t}$ 表示从s到t的不同的最短路的数目，$C_{s,t}(v)$ 表示经过 $v$ 从 $s$ 到 $t$ 的最短路的数目；则定义：

$$ I(v)=\sum_{s \ne v,t\ne v} \frac{C_{s,t}(v)}{C_{s,t}}$$

为结点 $v$ 在社交网络中的重要程度。为了使 $I(v)$ 和 $C_{s,t}(v)$ 有意义，我们规定需要处理的社交网络都是连通的无向图，即任意两个结点之间都有一条有限长度的最短路径。现在给出这样一幅描述社交网络的加权无向图，请你求出每一个结点的重要程度。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/1136.png) 

对于1号结点而言，只有2号到4号结点和4号到2号结点的最短路经过1号结点，而2号结点和4号结点之间的最短路又有2条。因而根据定义，1号结点的重要程度计算为1/2+1/2=1。由于图的对称性，其他三个结点的重要程度也都是1。

对于 $50\%$ 的数据， $n \le 10 , m \le 45$。     
对于 $100\%$ 的数据， $n \le 100 , m \le 4500$ ，任意一条边的权值 $c$ 是正整数且 $1 \leqslant c \leqslant 1000$ 。    
所有数据中保证给出的无向图连通，且任意两个结点之间的最短路径数目不超过 $10^{10}$。     



## 样例 #1

### 输入

```
4 4
1 2 1
2 3 1
3 4 1
4 1 1```

### 输出

```
1.000
1.000
1.000
1.000```

# AI分析结果

### 综合分析与结论
这些题解主要围绕计算社交网络中每个节点的重要程度展开，多数题解采用 Floyd 算法，少数使用 Dijkstra 或 SPFA 算法。核心在于求出任意两点间的最短路长度和最短路条数，再依据给定公式计算节点重要程度。各题解思路大致相同，但在代码实现和细节处理上存在差异。

### 所选题解
- **作者：Ning_Mew（5星）**
    - **关键亮点**：思路清晰，详细解释了公式含义和代码实现步骤，提供了两种计算最短路条数的方法，并指出拓扑排序的注意事项，代码注释详细。
    - **个人心得**：使用拓扑排序时因重边和入度处理问题，只得到 60 分，提醒读者注意相关细节。
- **作者：Rubidium_Chloride（4星）**
    - **关键亮点**：明确指出根据数据范围选择 Floyd 算法的原因，对算法思路分析详细，代码结构清晰。
    - **个人心得**：强调数据范围在做题中的重要性。
- **作者：人殇物已非（4星）**
    - **关键亮点**：思路简洁，提醒使用 long long 避免数据溢出，代码实现简单明了。
    - **个人心得**：因小细节卡了很久，提醒读者注意细节处理。

### 重点代码及核心实现思想
#### Floyd 算法同时计算最短路长度和最短路条数
```cpp
for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            if(dis[i][k]==INF&&dis[k][j]==INF)continue;
            if(dis[i][j]>dis[i][k]+dis[k][j])
            {
                dis[i][j]=dis[i][k]+dis[k][j];
                edge[i][j]=edge[i][k]*edge[k][j];
                continue;
            }
            if(dis[i][j]==dis[i][k]+dis[k][j])
            {edge[i][j]+=edge[i][k]*edge[k][j];}
        }
```
**核心思想**：通过枚举中间点 `k`，更新 `i` 到 `j` 的最短路长度和最短路条数。若 `dis[i][j]` 大于 `dis[i][k] + dis[k][j]`，则更新最短路长度和最短路条数；若相等，则累加最短路条数。

#### 计算节点重要程度
```cpp
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=n;j++)
        for(int k=1;k<=n;k++)
        {
            if(i==j||j==k||i==k)continue;
            if(dis[j][i]+dis[i][k]==dis[j][k])
                ans[i]+=(1.0*edge[j][i]*edge[i][k])/edge[j][k];
        }
}
```
**核心思想**：枚举所有的 `s`、`t` 和 `v`，若 `dis[s][v] + dis[v][t]` 等于 `dis[s][t]`，则说明 `v` 在 `s` 到 `t` 的最短路上，累加 `Cs,t(v) / Cs,t` 到 `ans[v]` 中。

### 最优关键思路或技巧
- **Floyd 算法的扩展应用**：在 Floyd 算法求最短路的同时，利用乘法原理和加法原理计算最短路条数。
- **数据类型选择**：由于最短路条数可能较大，使用 `long long` 避免数据溢出。
- **条件判断**：在计算节点重要程度时，注意排除 `s`、`t` 和 `v` 相等的情况。

### 可拓展之处
同类型题或类似算法套路：
- **多源最短路问题**：可使用 Floyd 算法解决，如计算图中任意两点间的最短距离。
- **路径计数问题**：在求最短路的过程中，利用乘法原理和加法原理计算最短路径的条数。
- **图的连通性问题**：判断图是否连通，可使用并查集或深度优先搜索等算法。

### 推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：涉及 Floyd 算法的动态更新。
- [P2934 [USACO09JAN]Safe Travel G](https://www.luogu.com.cn/problem/P2934)：结合 Dijkstra 算法和路径计数。
- [P3956 棋盘](https://www.luogu.com.cn/problem/P3956)：需要使用广度优先搜索或动态规划解决路径问题。

### 个人心得总结
- **Ning_Mew**：使用拓扑排序时要注意重边和入度的处理，否则会导致路径条数计算错误。
- **人殇物已非**：做题时要注意细节，一些小细节可能会导致代码出错，调试时要仔细。
- **Rubidium_Chloride**：做题时要关注数据范围，根据数据范围选择合适的算法。

---
处理用时：32.55秒
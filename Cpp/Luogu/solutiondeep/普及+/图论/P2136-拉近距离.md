# 题目信息

# 拉近距离

## 题目背景

我是源点，你是终点。我们之间有负权环。 ——小明

## 题目描述

在小明和小红的生活中，有 $N$ 个关键的节点。有 $M$ 个事件，记为一个三元组 $(S_i,T_i,W_i)$，表示从节点 $S_i$ 有一个事件可以转移到 $T_i$，事件的效果就是使他们之间的距离减少 $W_i$。

这些节点构成了一个网络，其中节点 $1$ 和 $N$ 是特殊的，节点 $1$ 代表小明，节点 $N$ 代表小红，其他代表进展的阶段。所有事件可以自由选择是否进行，但每次只能进行当前节点邻接的。请你帮他们写一个程序，计算出他们之间可能的最短距离。

## 说明/提示

对于 $20\%$ 数据，$N \le 10$，$M \le 50$。

对于 $50\%$ 数据，$N \le 300$，$M \le 5000$。

对于 $100\%$ 数据，$1\le N \le 10^3$，$1\le M \le 10^4$，$|W_i|\le 100$，保证从节点 $1$ 到 $2 \dots N$ 有路径，从节点 $N$ 到 $1 \dots N - 1$ 有路径。

## 样例 #1

### 输入

```
3 3
1 2 3
2 3 -1
3 1 -10```

### 输出

```
-2```

# AI分析结果

### 综合分析与结论
本题要求计算有向图中节点 1 到节点 N 以及节点 N 到节点 1 的最短距离，同时需处理负权边和负权环。各题解的核心思路基本一致，都需将边权取反，使用能处理负权和负权环的算法（如 SPFA 或 Bellman - Ford），并且分别以节点 1 和节点 N 为源点跑两次最短路，取最小值。若图中存在负权环，则输出“Forever love”。

### 所选题解
- **作者：Dijkspfa（5 星）**
    - **关键亮点**：思路清晰，明确指出题目坑点在于需分别以 1 和 n 为源点跑 SPFA 取最小值；代码结构清晰，注释详细。
    - **个人心得**：第一次做时 n = 999 的点特判过，以为数据错了，后来发现是要考虑小红主动的情况。
- **作者：Poetic_Rain（4 星）**
    - **关键亮点**：详细展示了从错误到正确的解题过程，先给出只从 1 出发的代码，分析 WA 原因后给出正确代码；代码注释丰富。
    - **个人心得**：调试许久，问同学后发现要跑两次最短路，考虑小红追小明的情况。
- **作者：SIXIANG32（4 星）**
    - **关键亮点**：对题意分析和解题步骤进行了详细拆解，先分析题意，再选择合适算法，最后给出代码并标注注意事项；代码简洁。

### 重点代码
#### Dijkspfa 的核心代码
```cpp
void spfa(int x){
    queue<int> q;
    memset(dis,0x3f,sizeof(dis));
    dis[x] = 0;q.push(x);vis[x] = 1;
    while(!q.empty())
    {
        int t=q.front();q.pop();
        vis[t] = 0;
        if(cnt[t] > n){puts("Forever love");exit(0);}
        for(int i = pre[t];i;i = e[i].nxt)
            if(dis[t] + e[i].w < dis[e[i].v])
            {
                dis[e[i].v] = dis[t] + e[i].w;
                if(!vis[e[i].v]) q.push(e[i].v),cnt[e[i].v]++,vis[e[i].v] = 1;
            }
    }
    return;
}
```
**核心思想**：初始化距离数组，将源点入队。不断从队列中取出节点，对其邻接节点进行松弛操作，若邻接节点距离更新且不在队列中，则将其入队。若某个节点入队次数超过 n，则存在负权环，输出“Forever love”。

#### Poetic_Rain 的核心代码
```cpp
bool spfa(int s){
    for(register int i=1;i<=n;i++) d[i]=20040915,v[i]=false,vis[i]=0;
    d[s]=0;
    v[s]=true;
    vis[s]++;
    q.push(s);
    while(!q.empty()){
        int x=q.front();
        q.pop();
        v[x]=false;
        if(vis[x]>n) return false; 
        for(register int i=head[x];i;i=e[i].net){
            int y=e[i].to,z=e[i].w;
            if(d[y]>d[x]+z){
                d[y]=d[x]+z;
                if(v[y]==false){
                    v[y]=true;
                    vis[y]++;
                    q.push(y);
                }
            }
        }
    }
    return true; 
}
```
**核心思想**：初始化距离数组、标记数组和入队次数数组，将源点入队。不断从队列中取出节点，对其邻接节点进行松弛操作，若邻接节点距离更新且不在队列中，则将其入队。若某个节点入队次数超过 n，则存在负权环，返回 false。

#### SIXIANG32 的核心代码
```cpp
bool SPFA(int s){
    for(int p=1;p<=n;p++)
        dis[p]=2147483647,vis[p]=0;
    queue<int>que;
    que.push(s);
    dis[s]=0;
    vis[s]=1;
    while(!que.empty()){
        int fr=que.front();
        que.pop();
        vis[fr]=0;
        for(int p=0;p<gra[fr].size();p++){
            int t=gra[fr][p].to;
            if(dis[t]>dis[fr]+gra[fr][p].val){
                dis[t]=dis[fr]+gra[fr][p].val;
                if(!vis[t]){
                    vis[t]=1;
                    que.push(t);
                    cnt[t]++;
                    if(cnt[t]>=n)return 1;
                }
            }
        }
    }
    return 0;
}
```
**核心思想**：初始化距离数组和标记数组，将源点入队。不断从队列中取出节点，对其邻接节点进行松弛操作，若邻接节点距离更新且不在队列中，则将其入队。若某个节点入队次数超过 n，则存在负权环，返回 1。

### 最优关键思路或技巧
- **边权取反**：将边权取反，把求最长路问题转化为求最短路问题。
- **两次最短路**：分别以节点 1 和节点 N 为源点跑最短路，取最小值，考虑了双向的情况。
- **负权环判断**：使用节点入队次数判断负权环，若某个节点入队次数超过 n，则存在负权环。

### 拓展思路
同类型题或类似算法套路：
- 其他求最长路且有负权边和负权环的有向图问题，可采用边权取反求最短路的方法。
- 涉及判断图中是否存在负权环的问题，可使用 SPFA 或 Bellman - Ford 算法。

### 推荐题目
- P3385【模板】负环
- P1807 最长路
- P4779【模板】单源最短路径（标准版）

### 个人心得总结
- 多位作者都提到最初只考虑了小明追小红的情况，导致 WA 部分点，后来发现要同时考虑小红追小明的情况，需跑两次最短路。
- 部分作者最初对 n = 999 的点进行特判，后来才找到正确的解题思路。这提示我们要仔细分析题目，不能依赖特判，要从本质上理解题意。 

---
处理用时：42.84秒
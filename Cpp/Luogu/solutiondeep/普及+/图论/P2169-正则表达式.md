# 题目信息

# 正则表达式

## 题目背景

小Z童鞋一日意外的看到小X写了一个正则表达式的高级程序，这个正则表达式程序仅仅由字符“0”,“1”，“.”和“\*”构成，但是他能够匹配出所有在OJ上都AC的程序的核心代码！小Z大为颇感好奇，于是他决定入侵小X的电脑上去获得这个正则表达式的高级程序。


## 题目描述

在 Internet 网络中的每台电脑并不是直接一对一连通的，而是某些电脑之间存在单向的网络连接，也就是说存在 $A$ 到 $B$ 的连接不一定存在 $B$ 到 $A$ 的连接，并且有些连接传输速度很快，有些则很慢，所以不同连接传输所花的时间是有大有小的。另外，如果存在 $A$ 到 $B$ 的连接的同时也存在 $B$ 到 $A$ 的连接的话，那么 $A$ 和 $B$ 实际上处于同一局域网内，可以通过本地传输，这样花费的传输时间为 $0$。

现在小 Z 告诉你整个网络的构成情况，他希望知道从他的电脑（编号为 $1$），到小 X 的电脑（编号为 $n$）所需要的最短传输时间。

## 说明/提示

- 对于  $40\%$ 的数据，$1\leq n\leq 10^3$, $1\leq m\leq 10^4$；
- 对于  $70\%$ 的数据，$1\leq n\leq 5 \times 10^3$， $1\leq m\leq 10^5$；
- 对于  $100\%$ 的数据，$1\leq n\leq 2 \times 10^5$， $1\leq m\leq 10^6$。

保证答案在 `int` 范围内。

## 样例 #1

### 输入

```
3 2
1 2 1
2 3 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5
1 2 1
2 3 6
3 4 1
4 2 1
3 5 2
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
本题的核心在于求解有向图中从节点 1 到节点 n 的最短路，其中同一强连通分量内的节点间距离为 0。大部分题解采用缩点 + 最短路的思路，先使用 Tarjan 算法（部分使用 Kosaraju 算法）进行缩点，将强连通分量合并为一个点，得到有向无环图（DAG），再使用最短路算法（如 Dijkstra、SPFA、拓扑排序等）求解最短路径。

### 所选题解
- **作者：Diamiko (赞：12)  ★★★★**
    - **关键亮点**：思路清晰，对缩点和最短路的原理进行了通俗易懂的解释，代码注释详细。
    - **个人心得**：写题解很累，希望大家能听懂，不懂可以留言。
- **作者：subarude (赞：8)  ★★★★**
    - **关键亮点**：详细说明了缩点的原因，引导读者理解为什么要缩点，代码实现较为规范。
    - **个人心得**：建议不会缩点的先做缩点板子题，有助于学习。
- **作者：PrincessQi (赞：7)  ★★★★**
    - **关键亮点**：明确指出本题是经典模板题，强调了需要掌握的知识点，代码简洁。
    - **个人心得**：调侃出题人是标题党，实际题目是经典模板题。

### 重点代码及核心实现思想
#### Diamiko 的题解
```cpp
// Tarjan 缩点
void Tarjan(int u)
{
    s.push(u);
    node[u].dfn=node[u].low=++deep;
    node[u].vis=1;
    for(int e=node[u].head;e;e=edge[e].next)
    {
        int v=edge[e].to;
        if(!node[v].dfn)
        {
            Tarjan(v);
            node[u].low=min(node[u].low,node[v].low);
        }
        else
        {
            if(node[v].vis)
            {
                node[u].low=min(node[u].low,node[v].dfn);
            }
        }
    }
    if(node[u].dfn==node[u].low)
    {
        int tmp;
        color_cnt++;//有新的颜色了
        do
        {
            tmp=s.top();
            s.pop();
            node[tmp].color=color_cnt;
            node[tmp].vis=0;
        }while(tmp!=u);
    }
}
// Dijkstra 最短路
void Dijkstra()
{
    for(int i=1;i<=n;i++)
    {
        node[i].dis=INF;
    }//初始化各点
    int S=node[1].color;//获取 1 号点的颜色
    node[S].dis=0;
    priority_queue<pii,vector<pii>,greater<pii> >q;
    q.push({0,S});
    while(q.size())
    {
        pii tmp=q.top();
        q.pop();
        int d=tmp.first,u=tmp.second;
        if(d!=node[u].dis)continue;
        for(int e=node[u].head;e;e=edge[e].next)
        {
            int v=edge[e].to;
            if(node[v].dis>d+edge[e].len)
            {
                node[v].dis=d+edge[e].len;
                q.push({node[v].dis,v});
            }
        }
    }
}
```
**核心实现思想**：Tarjan 算法用于找出图中的强连通分量，将其缩为一个点，用不同颜色标记。Dijkstra 算法在缩点后的图上求解最短路，注意起点和终点应取其所属强连通分量的编号。

#### subarude 的题解
```cpp
// Tarjan 缩点
void Tarjan(int u) {
    dfn[u] = low[u] = ++Time;
    s[++r] = u; vis[u] = 1;
    int R = r;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (!dfn[v]) {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        num++;// 一个新的强连通分量 
        for (int i = R; i <= r; i++) {
            belong[s[i]] = num;
            vis[s[i]] = 0;
        }
        r = R - 1;
    }
}
// 拓扑排序求最短路
void Topo(int s) {
    memset(dis, 0x3f, sizeof dis);
    queue<int> q;
    q.push(s);
    dis[s] = 0;// 记得要把起点的 dis 设为 0 
    for (; q.size(); ) {
        int u = q.front();
        q.pop();
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            dis[v] = min(dis[v], dis[u] + e[i].w);
            q.push(v);
        }
    }
}
```
**核心实现思想**：Tarjan 算法找出强连通分量并标记所属编号。拓扑排序在缩点后的图上进行，从起点开始更新各点的最短距离。

#### PrincessQi 的题解
```cpp
// Tarjan 缩点
void tarjan(int x){
    dfn[x]=low[x]=++dd;
    s[++top]=x;
    ins[x]=1;
    for(int i=beg[x];i;i=nex[i]){
        int y=to[i];
        if(dfn[y]==0){
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(ins[y])
            low[x]=min(low[x],dfn[y]);
    }
    if(low[x]==dfn[x]){
        cnt++;
        do{
            k=s[top--];
            ins[k]=0;
            b[k]=cnt;
        }while(x!=k);
    }
}
// Dijkstra 最短路
while(!q.empty()){
    int x=q.top().second;
    q.pop();
    if(p[x])
        continue;
    p[x]=1;
    for(int i=beg[x];i;i=nex[i]){
        int y=to[i],z=w[i];
        if(d[y]>d[x]+z){
            d[y]=d[x]+z;
            q.push(make_pair(-d[y],y));
        }		
    }
}
```
**核心实现思想**：Tarjan 算法找出强连通分量并编号。Dijkstra 算法在缩点后的图上求解最短路，使用优先队列优化。

### 最优关键思路或技巧
- **缩点思想**：利用 Tarjan 算法将强连通分量缩为一个点，将有向有环图转化为有向无环图（DAG），简化问题。
- **最短路算法选择**：根据数据范围和题目特点选择合适的最短路算法，如 Dijkstra 堆优化、SPFA、拓扑排序等。
- **代码实现技巧**：使用链式前向星或邻接表存储图，提高空间利用率和遍历效率。

### 可拓展之处
同类型题或类似算法套路：
- **强连通分量相关**：求有向图的强连通分量个数、缩点后求图的拓扑序、判断图是否为强连通图等。
- **最短路问题**：在不同图结构（如无向图、带负权边的图）中求最短路，使用不同的最短路算法（如 Bellman-Ford、Floyd 等）。

### 推荐题目
- [P3387 【模板】缩点](https://www.luogu.org/problem/P3387)
- [P2863 [USACO06JAN]The Cow Prom S](https://www.luogu.org/problem/P2863)
- [P1119 灾后重建](https://www.luogu.org/problem/P1119)

### 个人心得总结
- **Diamiko**：写题解很累，希望读者能理解，不懂可留言交流。
- **subarude**：建议先做缩点板子题，有助于学习缩点算法。
- **PrincessQi**：调侃出题人是标题党，实际题目是经典模板题，强调掌握相关知识点的重要性。

---
处理用时：55.49秒
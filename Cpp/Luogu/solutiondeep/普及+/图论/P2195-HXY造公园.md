# 题目信息

# HXY造公园

## 题目描述

现在有一个现成的公园，有 $n$ 个休息点和 $m$ 条双向边连接两个休息点。众所周知，HXY 是一个 SXBK 的强迫症患者，所以她打算施展魔法来改造公园并即时了解改造情况。她可以进行以下两种操作：

1. 对某个休息点 $x$，查询公园中可以与该点互相到达的休息点组成的路径中的最长路径。
2. 对于两个休息点 $x,y$，如果 $x,y$ 已经可以互相到达则忽略此次操作。否则，在 $x$ 可到达的所有休息点和 $y$ 可到达的所有休息点（包括 $x,y$ 自身）分别选择一个休息点，然后在这两个休息点之间连一条边，并且这个选择应该满足对于连接后的公园，$x$ 和 $y$ 所在的区域（即 $x,y$ 可达到的所有休息点和边组成的集合）中的最长路径的长度最小。

HXY打算进行 $q$ 个操作，请你回答她的对于公园情况的询问（操作 1）或者执行她的操作（操作 2）。

注：所有边的长度皆为 $1$。保证不存在环。最长路径定义为：对于点 $v_1,v_2\cdots v_k$，如果对于其中任意的 $v_i$ 和 $v_{i+1}\quad (1\le i\le k-1)$，都有边相连接，那么 $v_j\quad(1\le j\le k)$ 所在区域的最长路径就是 $k-1$。


## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据，只存在操作 1。
- 对于 $30\%$ 的数据，$1\le m<n\le 20$，$1\le q\le5$。
- 对于 $60\%$ 的数据，$1\le m<n \le 2000$，$1\le q\le 1000$。
- 对于 $100\%$ 的数据，$1 \le m<n \le 3\times 10^5$，$1\le q\le 3\times 10^5$。


## 样例 #1

### 输入

```
6 0 6
2 1 2
2 3 4
2 5 6
2 3 2
2 5 3
1 1```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是利用并查集维护连通性，同时结合树的直径算法来解决问题。对于树的直径计算，多数题解采用跑两遍 DFS 或 BFS 的方法，也有部分使用树形 DP。在合并两棵树时，关键在于找到使新树直径最小的连接方式，即连接两棵树直径的中点，新树直径为 `max(原树1直径, 原树2直径, 原树1直径一半上取整 + 原树2直径一半上取整 + 1)`。

### 所选题解
- **作者：Priori_Incantatem (赞：31)，4星**
  - **关键亮点**：思路清晰，对合并后树的直径计算原理有详细解释，并配有示例图，代码注释丰富，可读性强。
  - **个人心得**：提到在计算合并后树的直径时，如果不考虑原来两棵树的直径，只能得 30 分，强调了这一点的重要性。

### 重点代码
```cpp
// 树形DP求树的直径
void dfs(int x,int fa) 
{
    int m1=-1,m2=-1;
    for(int i=0;i<e[x].size();++i)
    {
        int y=e[x][i];
        if(y==fa)continue;
        dfs(y,x);
        int tmp=d[y]+1;
        d[x]=max(d[x],tmp);
        if(tmp>m1)m2=m1,m1=tmp;
        else if(tmp>m2)m2=tmp;
    }
    g[x]=max(max(0,m1+m2),max(m1,m2));
    len=max(len,g[x]);
}

// 寻找树的直径
void calc(int x) 
{
    len=0;
    dfs(x,0);
    c[x]=len;
}

// 主函数中的合并操作
while(q--)
{
    int opt=read(),x=read();
    if(opt==1)
    {
        printf("%d\n",c[find(x)]);
        continue;
    }
    int y=read();
    x=find(x),y=find(y);
    if(x==y)continue;
    int tmp=((c[x]+1)>>1)+((c[y]+1)>>1)+1; // 一个巧妙的向上取整的方法
    tmp=max(tmp,max(c[x],c[y]));
    f[find(x)]=find(y);
    c[find(x)]=tmp;
}
```
**核心实现思想**：`dfs` 函数通过树形 DP 计算每个节点的最长和次长路径，从而更新树的直径。`calc` 函数调用 `dfs` 计算树的直径并存储在 `c` 数组中。主函数中，对于操作 1 直接输出对应树的直径，对于操作 2 先判断两点是否连通，若不连通则计算合并后树的直径并更新 `c` 数组。

### 最优关键思路或技巧
- **并查集**：用于维护节点的连通性，方便判断两点是否在同一棵树中，以及合并两棵树。
- **树的直径计算**：跑两遍 DFS 或 BFS 是一种简单有效的计算树的直径的方法，树形 DP 则更适合在递归过程中维护信息。
- **向上取整技巧**：使用 `(num + 1) / 2` 可以巧妙地实现向上取整。

### 拓展思路
同类型题或类似算法套路：
- 涉及动态图的连通性维护和图的直径计算的问题，如动态加边或删边后求图的直径变化。
- 其他需要结合并查集和图的特定性质（如树的重心、树的中心等）的问题。

### 推荐题目
- [P1196 银河英雄传说](https://www.luogu.com.cn/problem/P1196)：考察并查集的基本应用和路径压缩。
- [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)：并查集的拓展应用，需要考虑节点之间的对立关系。
- [P2024 食物链](https://www.luogu.com.cn/problem/P2024)：并查集的高级应用，涉及节点之间的多种关系。

### 个人心得摘录与总结
- **作者：noall**：提到使用 `memset` 初始化 `vis` 数组会导致 TLE，建议在 DFS 返回前将 `vis[x]` 置为 `false`，避免不必要的初始化开销。
- **作者：Priori_Incantatem**：强调在计算合并后树的直径时，要考虑原来两棵树的直径，否则只能得 30 分，提醒做题时要全面考虑各种情况。

---
处理用时：33.56秒
# 题目信息

# 迷宫

## 题目背景

无

## 题目描述

小希非常喜欢玩迷宫游戏，现在她自己设计了一个迷宫游戏。在她设计的迷宫中，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间 A 和 B，那么既可以通过它从房间 A 走到房间 B，也可以通过它从房间 B 走到房间 A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从 $5$ 到达 $8$。


## 说明/提示

无

## 样例 #1

### 输入

```
6 8  5 3  5 2  6 4
5 6  0 0

8 1  7 3  6 2  8 9  7 5
7 4  7 8  7 6  0 0

3 8  6 8  6 4
5 3  5 6  5 2  0 0

-1 -1
```

### 输出

```
1
1
0
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕判断无向图是否为树展开，多数采用并查集算法，少数使用搜索算法。判断树的关键在于满足边数等于点数减 1 且无环，或所有点连通且只有一个集合。并查集通过合并集合和查找祖先来判断环和连通性，搜索算法则通过深度优先搜索判断环和连通性。

### 所选题解
1. **作者：vectorwyx（5 星）**
    - **关键亮点**：思路清晰，详细阐述判断树的两个条件（边数等于点数减 1 且无环），代码注释丰富，使用快读优化输入。
    - **核心代码**：
```cpp
int fin(int x){//查找祖先&路径压缩
    if(a[x]==0) return x;
    else return a[x]=fin(a[x]);
}
inline void check(){//判断每组数据是否是树并输出相应的答案
    //...
    while(1){//循环输入
        x=read();y=read();
        if(x==0&&y==0) break;//0,0表明输入结束
        if(x==-1&&y==-1){//-1,-1表明所有数据都已输入完
            flag=1;//flag记录一下
            return;//直接返回主函数
        }
        xx=fin(x);yy=fin(y);//查找祖先
        if(xx!=yy){//祖先不同，不在同一集合中
            a[xx]=yy;//连边
            if(!b[x]){//x这个点之前没出现过
                b[x]=1;//修改桶
                cnt1++;//点数+1
            }
            if(!b[y]){//同上
                b[y]=1;
                cnt1++;
            }
            cnt2++;//又连了一条边，因此边数要+1
        }else{//祖先相同，在同一集合中
            f=1;//出现了环，更改f标记
        }
    }
    if(cnt2==cnt1-1&&!f) printf("1\n");
    else printf("0\n");
    return;
}
```
    - **核心思想**：用并查集维护点与点之间的联系，每次连边时判断是否形成环，同时用桶记录点数，计数器记录边数，最后判断边数是否等于点数减 1 且无环。

2. **作者：Register（4 星）**
    - **关键亮点**：思路简洁，直接根据并查集合并和查找祖先的特性判断是否有环和集合数量。
    - **核心代码**：
```cpp
void cls(){//初始化
    for(register int i=1;i<=100000;i++) f[i]=i;
    memset(book,0,sizeof(book));sum=0;flag=false;
}
int find(int x){//路径压缩般找祖先
    if(f[x]==x) return x;
    return f[x]=find(f[x]);
}
int main(){
    cls();
    while(scanf("%d%d",&a,&b)==2)//疯狂输入
    {
        if(a==-1&&b==-1) break;
        if(a==0&&b==0) {printf("%c\n",((!flag&&sum==1)?'1':'0'));cls();continue;}//这组数据结束
        if(!book[a]) sum++;//集合增加
        if(!book[b]) sum++;//集合增加
        book[a]=true;book[b]=true;//标记
        int x1=find(a),x2=find(b);//祖先
        if(x1==x2) flag=true;//标记
        else {sum--;f[x1]=x2;}//修改
    }
    return 0;
}
```
    - **核心思想**：每次输入两个元素，判断是否在同一集合内，若在则标记违规，不在则合并集合，最后判断集合数量是否为 1。

3. **作者：Lacer（4 星）**
    - **关键亮点**：并查集使用方法巧妙，提前判断是否有环，减少不必要的计算。
    - **核心代码**：
```cpp
int getf(int v){return f[v]==v?v:getf(f[v]);}
bool merge(int a,int b)
{
    int fa=getf(a),fb=getf(b);
    if(fa!=fb){f[fb]=fa;return true;}
    return false;
}
int main()
{
    int x,y;
    int tot,ok;//tot为祖先个数
    while(scanf("%d%d",&x,&y)==2)
    {
        if(x==-1&&y==-1)break;
        tot=1;//已经输入第一组数据，有了一个祖先
        ok=true;//初始化
        memset(book,0,sizeof(book));//初始化
        f[x]=x;f[y]=y;//每出现一个点就把这个点的爹初始化一下，初始化整个f很麻烦
        book[x]=book[y]=true;//出现了，记录一下
        merge(x,y);//合并
        while(scanf("%d%d",&x,&y)==2)
        {
            if(!x&&!y)break;//数据输完了
            if(!book[x]){f[x]=x;tot++;}
            if(!book[y]){f[y]=y;tot++;}
            book[x]=book[y]=true；//已经出现
            if(!merge(x,y))ok=false;//划重点！提前发现错误
            else tot--;//成功，祖先-1
        }
        if(ok&&tot==1)printf("1\n");
        else printf("0\n");
    }
    return 0;
}
```
    - **核心思想**：每次给出两个点时，判断是否在同一集合中，若在则提前判断不是树，同时记录祖先个数，最后判断祖先个数是否为 1 且无环。

### 最优关键思路或技巧
- **并查集**：利用并查集合并和查找祖先的特性，高效判断图中是否有环和所有点是否连通。
- **提前判断**：在输入过程中，若发现两点已在同一集合中，可提前判断图不是树，减少不必要的计算。
- **桶记录**：使用桶记录点的出现情况，方便统计点数。

### 可拓展之处
同类型题或类似算法套路：
- 判断有向图是否为树，可使用拓扑排序。
- 最小生成树问题，如 Kruskal 算法和 Prim 算法，可用于求解图的最小生成树。
- 图的连通分量问题，可使用并查集或深度优先搜索求解。

### 推荐题目
1. **P1197 [JSOI2008]星球大战**：并查集的逆向应用，动态维护图的连通性。
2. **P3367 【模板】并查集**：并查集的基础模板题，可用于练习并查集的基本操作。
3. **P1551 亲戚**：并查集的简单应用，判断两个人是否为亲戚。

### 个人心得摘录与总结
- **作者：EDqwq**：使用并查集时要注意判断集合数量，本题要求有且只有一个集合。
- **作者：molasses**：使用边集与树边集方法时，反复建图遍历复杂度常数影响性能；使用树的性质方法时，未证明结论可能导致部分错误。

---
处理用时：52.68秒
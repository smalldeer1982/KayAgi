# 题目信息

# 金字塔

## 题目描述

有一盗墓者潜入一金字塔盗宝。当她（难道是 Lara Croft ?）打开一个宝箱的时候，突然冒出一阵烟（潘多拉的盒子？），她迅速意识到形势不妙，三十六计走为上计……由于她盗得了金字塔的地图，所以她希望能找出最佳逃跑路线。地图上标有 $N$ 个室，她现在就在 $1$ 室，金字塔的出口在 $N$ 室。她知道一个秘密：那阵烟会让她在直接连接某两个室之间的通道内的行走速度减半。她希望找出一条逃跑路线，使得在最坏的情况下所用的时间最少。

## 说明/提示

样例解释 Sample Explan：

基本上有三种路线：

（1）$1 \to 2 \to 3 \to 4 \to 7$。

总时间为：$10$ ＋ $12$ ＋ $20$ ＋ $8$ ＝ $50$，最坏的情况是“ $3 \to 4$ ”那一段，要多花 $20$ 秒（因为行走速度减半），所以这条路选最坏需要 $70$ 秒；

（2）$1 \to 2 \to 5 \to 6 \to 4 \to 7$。

总时间为：$10$ ＋ $10$ ＋ $12$ ＋ $13$ ＋ $8$ ＝ $53$，最坏的情况是“ $6 \to 4$ ”那一段，要多花 $13$ 秒，所以这条路选最坏需要 $66$ 秒；

（3）$1 \to 7$。

总时间为：$34$ ＝ $34$，最坏的情况是“ $1 \to 7$ ”那一段，要多花 $34$ 秒，所以这条路选最坏需要 $68$ 秒。

## 样例 #1

### 输入

```
7 8
1 2 10
2 3 12
3 4 20
4 7 8
1 7 34
2 5 10
5 6 12
6 4 13```

### 输出

```
66```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找金字塔中从起点到终点在某条边速度减半情况下的最优逃跑路线展开，即求路径上最大权值翻倍的最短路。不同题解采用了多种算法，如 Floyd、Dijkstra、SPFA、DFS 等。各题解的思路和实现细节有所不同，在处理最大权值和最短路的关系上各有特色。

### 所选题解
- **Sata_moto（4星）**
  - **关键亮点**：思路清晰，详细展示了对 Floyd 算法的逐步改进过程，通过增加状态维度解决了普通 Floyd 算法的局限性，代码注释较详细。
  - **个人心得**：最初用普通 Floyd 算法无法通过样例，发现问题在于最短路径与最大权值不配套；改进后仍有错误，原因是结果不一定由最短路拼接而成，最终通过增加状态维度解决问题。
- **大头冲锋车丶（4星）**
  - **关键亮点**：使用 Dijkstra 算法，通过维护 `pre` 数组记录路径上的最大权值，思路简洁明了，代码实现规范。
  - **个人心得**：强调在 Dijkstra 算法中不能使用 `vis` 数组标记已处理节点，否则可能导致答案出错，如样例中若标记 `vis[7]=true` 会使 ④ --> ⑦ 这条路不再贡献于 `dist[7]`。
- **Night_Aurora（4星）**
  - **关键亮点**：利用权值范围小的特点，枚举最大权值并每次求最短路，使用队列优化的 Dijkstra 算法，降低了时间复杂度。

### 重点代码
#### Sata_moto（Floyd 改进）
```cpp
for(register int k = 1; k <= n; k++)
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            if(k != i && i != j && k != j)
                for(int c = 0; c <= 260; c++)
                {
                    if(c != 0) f[i][j][c] = min(f[i][j][c], f[i][j][c - 1]);
                    f[i][j][c] = min(f[i][j][c], f[i][k][c] + f[k][j][c]);
                }
```
**核心思想**：增加一维状态 `c` 表示路径上最长边长度小于等于 `c` 的最短路长度，通过状态转移更新最短路。

#### 大头冲锋车丶（Dijkstra）
```cpp
while(!q.empty())
{
    int u=q.top().to;
    ll t=dist[u];
    q.pop();
    for(int i=head[u];i;i=edge[i].next){
        int v=edge[i].to;
        if((dist[v]+pre[v]>t+edge[i].val+max(edge[i].val,pre[u]))){
            pre[v]=max(pre[u],edge[i].val);
            dist[v]=edge[i].val+t;
            q.push(Node(dist[v],v));
        }
    }
}
```
**核心思想**：在 Dijkstra 算法中，维护 `pre` 数组记录路径上的最大权值，更新 `dist` 数组时考虑最大权值的影响。

#### Night_Aurora（枚举最大权值 + Dijkstra）
```cpp
for(wi=1;wi<=Mw;++wi)
{
    Dijkstra(wi);
    if(!Vist[N])continue;
    wc=Dist[N]+wi;
    if(wc<MC)MC=wc;
}
```
**核心思想**：枚举最大权值，每次调用 Dijkstra 算法求最短路，取最短路加上枚举权值的最小值作为答案。

### 最优关键思路或技巧
- **增加状态维度**：如 Sata_moto 的题解，在 Floyd 算法中增加一维状态来处理路径上的最大权值，使算法更灵活。
- **维护额外数组**：如大头冲锋车丶的题解，使用 `pre` 数组记录路径上的最大权值，方便更新最短路。
- **枚举优化**：如 Night_Aurora 的题解，利用权值范围小的特点，枚举最大权值并求最短路，降低复杂度。

### 可拓展之处
同类型题可能会有不同的限制条件，如多条边速度减半、不同节点有不同的额外代价等。类似算法套路可应用于其他最短路问题，如在最短路的基础上增加一些额外的属性（如最大流量、最小费用等），通过维护额外数组或增加状态维度来解决。

### 推荐题目
- [P1339 [USACO09OCT]Heat Wave G](https://www.luogu.com.cn/problem/P1339)：基础的最短路问题，可练习 Dijkstra 或 SPFA 算法。
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：标准的单源最短路模板题，可巩固最短路算法。
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：在最短路的基础上增加计数功能，可锻炼对最短路算法的拓展应用。

---
处理用时：35.01秒
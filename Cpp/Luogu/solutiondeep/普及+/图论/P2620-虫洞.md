# 题目信息

# 虫洞

## 题目背景

applepi 想进行宇宙旅行。当然，applepi 知道这是有可能的，因为 applepi 的特殊能力能使他观测到宇宙中的虫洞。所谓虫洞就是一个在三维之外的维度打开的快捷通道，通过虫洞能够从一个地方瞬间移动到另外一个地方。


## 题目描述

为了简化问题，我们建立一个一维坐标系，地球的位置为 $0$，而applepi 的目的地的位置是一个正整数 $W$。

在每一个单位时间里，applepi 可以向正方向移动不超过 $S$ 的一个整数。虫洞可以被表示为二元组 $(B, E)$，即如果在某次移动之后 applepi 在位置 $B$，那么 applepi 就会被立刻传送到位置 $E$。

注意，applepi 在移动过程中如果经过位置 $B$，由于applepi 的速度极快是不会被传送的。而且，applepi 不能够向负方向移动，但是虫洞引起的除外。

现在applepi 想请你帮助他计算一下他至少需要多少个单位时间才能够到达目的地。


## 说明/提示

对于 $30\%$ 的数据，$W≤1000$。

对于 $100\%$ 的数据，$W≤10^9$，$2≤S≤6$，$1≤P≤40$，没有 $B = 0$ 或者 $B = W$ 的虫洞，输入数据保证目的地可达。


## 样例 #1

### 输入

```
28 3 5
2 18
5 13
12 6
17 25
20 15
50 6 1
9 45
0
```

### 输出

```
４
３
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕离散化、建图和最短路算法来解决虫洞问题。由于 $w$ 范围大但虫洞数量 $p$ 小，离散化可减少处理的点数；建图时需考虑虫洞起点和终点的连接，以及非虫洞边的边权计算；最后使用最短路算法（如 Floyd、SPFA、Dijkstra 等）求解最少时间。

### 所选题解
- **作者：JNK_DOG（4星）**
    - **关键亮点**：思路清晰，详细说明了离散化、建图和最短路的过程，代码注释丰富，易于理解。
    - **核心代码**：
```cpp
int F(int b,int e){//求解两点间距离
    if(b==e)return 0;
    if(s.count(b))return 0x3fffffff;
    int k=e;
    for(int i=1;i<=p;i++)
        if(b<x[i]&&x[i]<k&&(x[i]-b)%st==0)k=x[i];//查找第一个落脚点
    while(k!=e&&s.count(k))k--;
    if(k==b)return 0x3fffffff;
    return F(k,e)+(k-b+st-1)/st;
}
void Floyd(){//求解最短路
    for(int k=1;k<=c;k++)
        for(int i=1;i<=c;i++)
            for(int j=1;j<=c;j++)
                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
}
```
    - **核心思想**：`F` 函数递归计算两点间距离，考虑虫洞起点不能停留的情况；`Floyd` 函数使用 Floyd-Warshall 算法求解最短路。

- **作者：suxxsfe（4星）**
    - **关键亮点**：题解详细，适合萌新，对离散化、建图和边权计算的解释清晰，代码注释丰富。
    - **核心代码**：
```cpp
inline int getdis(int x,int y){
    if(x==y) return 0;
    if(isstart(x)) return 0x3f3f3f3f;//x是个起点，不行 
    int yy=y;
    for(reg int i=1;i<=p;i++)if(from[i]>x){
        if(yy>from[i]&&(from[i]-x)%s==0) yy=from[i];
    }
    while(yy!=y&&isstart(yy)) yy--;//如果yy已经等于y了，就算是一个起点也不再退了 
    if(yy==x) return 0x3f3f3f3f;//退回了起点，永远到不了了qwq 
    return getdis(yy,y)+std::ceil((double)(yy-x)/s);
}
// floyd
for(reg int k=1;k<=tot;k++)
    for(reg int i=1;i<=tot;i++)
        for(reg int j=1;j<=tot;j++) dis[i][j]=std::min(dis[i][j],dis[i][k]+dis[k][j]);
```
    - **核心思想**：`getdis` 函数递归计算两点间距离，考虑虫洞起点不能停留的情况；Floyd-Warshall 算法求解最短路。

- **作者：gongxuanwen（4星）**
    - **关键亮点**：思路清晰，对离散化、连边和最短路算法的选择有详细说明，代码实现简洁高效。
    - **核心代码**：
```cpp
void CalcDis(int x)
{	
    int now = to[x].pos, last, step = 0; // 记录点 最后一个落脚点 到记录点的步数 
    for(int i = upper_bound(from + 1, from + P + 1, to[x], [&](Point x, Point y){return x.pos < y.pos;}) - from; i <= P; ++ i)
    {
        if(from[i].pos - 1!= from[i - 1].pos)
            last = from[i].pos - 1; // 不断更新落脚点 
        v[to[x].ord].push_back({from[i].ord, step + (from[i].pos - now - 1) / S + 1}); // 连边 
        if(!((from[i].pos - now) % S) && last == from[i].pos - S)
            return; // 如果走不过去就直接返回 
        if(!((from[i].pos - now) % S)) // 更新记录点和到记录点的步数 
        {	
            step += (last - now - 1) / S + 1; // 向上取整
            now = last;
        }
    }
}
// Dijkstra 朴素版
for(int i = 0; i!= P << 1; ++ i) // 每次求一个点 
{
    int nearest = 0, Min = INF;
    for(int j = 1; j <= P << 1; ++ j) // 打擂找最小点 
        if(!b[j] && dis[j] < Min)
        {
            nearest = j;
            Min = dis[j];
        }
    b[nearest] = true; // 记录已访问 
    for(const Edge it : v[nearest]) // 遍历 
        dis[it.to] = min(dis[it.to], dis[nearest] + it.dis); // 松弛 
}
```
    - **核心思想**：`CalcDis` 函数计算一个虫洞终点到所有虫洞起点的步数并连边；Dijkstra 朴素版算法求解最短路。

### 最优关键思路或技巧
- **离散化**：由于 $w$ 范围大，只保留虫洞的起点和终点、起始地和目的地，减少处理的点数。
- **建图**：虫洞起点和终点连边权为 0 的边，非虫洞边的边权计算需考虑虫洞起点不能停留的情况。
- **最短路算法**：根据图的点数和边数选择合适的最短路算法，如 Floyd、SPFA、Dijkstra 等。

### 可拓展之处
同类型题可涉及更多复杂的地图结构、移动规则或虫洞特性，如二维地图、多种移动方式、虫洞有使用次数限制等。类似算法套路包括离散化处理大数据范围、建图将实际问题转化为图论问题、使用最短路算法求解最优路径。

### 推荐题目
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)
- [P2746 [USACO5.3]校园网Network of Schools](https://www.luogu.com.cn/problem/P2746)

### 个人心得摘录与总结
- **suxxsfe**：从简单图论题单点进来，原以为能快速解决，结果一天才调出来。认为本题难度应更高，实现需要功夫。总结：复杂问题实现可能需要更多时间和精力，不能轻视。
- **MurderChara**：考场上用贪心 + DP 思路，发现 $W$ 范围大后试图优化但未成功。总结：数据范围大时，常规算法可能不适用，需考虑更合适的算法。

---
处理用时：54.10秒
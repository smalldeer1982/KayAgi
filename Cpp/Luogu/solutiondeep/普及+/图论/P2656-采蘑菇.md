# 题目信息

# 采蘑菇

## 题目描述

小胖和 ZYR 要去 ESQMS 森林采蘑菇。

ESQMS 森林间有 $N$ 个小树丛，$M$ 条小径，每条小径都是单向的，连接两个小树丛，上面都有一定数量的蘑菇。小胖和 ZYR 经过某条小径一次，可以采走这条路上所有的蘑菇。由于 ESQMS 森林是一片神奇的沃土，所以一条路上的蘑菇被采过后，又会长出一些新的蘑菇，数量为原来蘑菇的数量乘上这条路的“恢复系数”，再下取整。

比如，一条路上有 $4$ 个蘑菇，这条路的“恢复系数”为 $0.7$，则第一~四次经过这条路径所能采到的蘑菇数量分别为 $4,2,1,0$。

现在，小胖和 ZYR 从 $S$ 号小树丛出发，求他们最多能采到多少蘑菇。


## 说明/提示

对于 $30\%$ 的数据，$N\le 7$，$M\le15$

另有 $30\%$ 的数据，满足所有“恢复系数”为 $0$。

对于 $100\%$ 的数据，$1
\le N\le 8\times 10^4$，$1\le M\le 2\times 10^5$，$0\le\text{恢复系数}\le 0.8$ 且最多有一位小数， $1\le S\le N$。

## 样例 #1

### 输入

```
3 3
1 2 4 0.5
1 3 7 0.1
2 3 4 0.6
1```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解的核心思路一致，都是先使用 Tarjan 算法进行缩点，将有向图转化为有向无环图（DAG），把强连通分量内的边权转化为点权，再在 DAG 上求解最长路。在处理恢复系数时，为避免浮点数精度问题，都采用将恢复系数乘 10 后用整数存储的方法。不同题解在求最长路时采用了不同算法，如 SPFA、拓扑排序、DFS 记忆化搜索等。

### 所选题解
- **作者：银杉水杉秃杉（5 星）**
    - **关键亮点**：思路清晰，详细说明了解题步骤，代码注释丰富，采用 SPFA 求最长路，容易理解。
    - **个人心得**：强调按题目标签（缩点 + spfa）做题，不建议使用如 dp 等复杂方法，认为本题用此方法简单易理解。
- **作者：Erinyes（4 星）**
    - **关键亮点**：对算法进行了详细分析，分步骤给出求解过程，代码结构清晰，使用拓扑排序在 DAG 上进行动态规划求解。
    - **个人心得**：无
- **作者：清烛（4 星）**
    - **关键亮点**：说明了边最多走 96 次会被榨干，可暴力计算边的贡献，代码简洁，使用 SPFA 求最长路。
    - **个人心得**：提到为防止精度爆炸，先读入小数再乘 10 处理。

### 重点代码及核心实现思想
#### 银杉水杉秃杉
```cpp
// 计算强连通分量内的蘑菇数
for (int i = 1; i <= m; i++)
{
    int x = e[i].from, y = e[i].to, z = e[i].val, k = e[i].k;
    if (col[x] == col[y])
        while (z)
        {
            sum[col[x]] += z;
            z = z * k / 10;
        }
    else
        add(col[x], col[y], z);
}
// SPFA 求最长路
void spfa(int s)
{
    memset(dis, -1, sizeof(dis));
    memset(V, 0, sizeof(V));
    dis[s] = sum[s];
    V[s] = 1;
    q.push(s);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        V[u] = 0;
        for (int i = H[u]; i; i = E[i].next)
        {
            int v = E[i].to, w = E[i].val;
            if (dis[v] < dis[u] + w + sum[v])
            {
                dis[v] = dis[u] + w + sum[v];
                if (!V[v])
                {
                    V[v] = 1;
                    q.push(v);
                }
            }
        }
    }
}
```
核心思想：先通过 Tarjan 缩点，计算强连通分量内的蘑菇总数作为点权，再用 SPFA 算法在缩点后的 DAG 上求最长路。

#### Erinyes
```cpp
// 缩点过程
for(int x=1;x<=n;x++){
    for(int i=h[x];i;i=t[i].next){
        int y=t[i].to;
        if(c[x]!=c[y]){
            addc(c[x],c[y],t[i].v);
            rd[c[y]]++;
        }else{
            int s=0,a=t[i].v;
            while(a){
                s+=a;
                a*=t[i].g;
                a/=10;
            }
            sum[c[x]]+=s;
        }
    }
}
// 拓扑排序并动态规划
void toposort(){
    queue<int> q;
    for(int i=1;i<=cnt;i++){
        if(!rd[i]) q.push(i);
        f[i]=-INF;
    }
    f[c[s]]=sum[c[s]];
    while(!q.empty()){
        int x=q.front(); q.pop();
        for(int i=hc[x];i;i=tc[i].next){
            int y=tc[i].to;
            f[y]=max(f[y],f[x]+tc[i].v+sum[y]);
            rd[y]--;
            if(!rd[y]) q.push(y);
        }
    }
}
```
核心思想：通过枚举边进行缩点，统计强连通分量内的边权和作为点权，再用拓扑排序在 DAG 上进行动态规划求解最长路。

#### 清烛
```cpp
// 计算一条边能产生的贡献
inline int calc(int w, int k) {
    int ret = 0;
    while (w) {
        ret += w;
        w = w * k / 10;
    }
    return ret;
}
// SPFA 求最长路
int spfa() {
    int ans = dis[st] = w[st];
    q.push(st);
    inq[st] = 1;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inq[u] = 0;
        for (int i = head2[u]; i; i = e2[i].next) {
            int& v = e2[i].to, & d = e2[i].w;
            if (dis[u] + d + w[v] > dis[v]) {
                dis[v] = dis[u] + d + w[v];
                ans = max(dis[v], ans);
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = 1;
                }
            }
        }
    }
    return ans;
}
```
核心思想：先计算每条边能产生的贡献，再通过 Tarjan 缩点，将强连通分量内的边贡献累加点权，最后用 SPFA 求最长路。

### 最优关键思路或技巧
- **Tarjan 缩点**：将有向图转化为 DAG，方便后续处理。
- **整数存储恢复系数**：将恢复系数乘 10 后用整数存储，避免浮点数精度问题。
- **暴力计算边的贡献**：由于边最多走 96 次就会被榨干，可暴力计算边能产生的贡献。

### 可拓展之处
同类型题或类似算法套路：
- 有向图中带有边权变化的路径问题，可先缩点再在 DAG 上求解。
- 图的连通性问题，可使用 Tarjan 算法求解强连通分量。

### 推荐题目
- P3387 【模板】缩点
- P2746 [USACO5.3]校园网Network of Schools
- P1262 间谍网络

### 个人心得总结
- 银杉水杉秃杉：强调按题目标签做题，避免使用复杂方法，认为本题用缩点 + spfa 简单易理解。
- Aryper：考场上因未考虑恢复系数为 0 的情况导致读入超时，提醒要注意特殊情况。
- Xu_brezza：因精度问题只得 60 分，提醒要好好处理精度。
- gan1234：因使用 double 存储恢复系数导致 WA，提醒要用整数存储恢复系数。
- 清烛：提到为防止精度爆炸，先读入小数再乘 10 处理。 

---
处理用时：49.76秒
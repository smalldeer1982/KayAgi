# 题目信息

# [USACO3.3] 骑马修栅栏 Riding the Fences

## 题目背景

Farmer John 每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。

## 题目描述

John 是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。

John 的农场上一共有 $m$ 个栅栏，每一个栅栏连接两个顶点，顶点用 $1$ 到 $500$ 标号（虽然有的农场并没有那么多个顶点）。一个顶点上至少连接 $1$ 个栅栏，没有上限。两顶点间可能有多个栅栏。所有栅栏都是连通的（也就是你可以从任意一个栅栏到达另外的所有栅栏）。John 能从任何一个顶点（即两个栅栏的交点）开始骑马，在任意一个顶点结束。

你需要求出输出骑马的路径（用路上依次经过的顶点号码表示)，使每个栅栏都恰好被经过一次。如果存在多组可行的解，按照如下方式进行输出：如果把输出的路径看成是一个 $500$ 进制的数，那么当存在多组解的情况下，输出 $500$ 进制表示法中最小的一个 （也就是输出第一位较小的，如果还有多组解，输出第二位较小的，以此类推）。

输入数据保证至少有一个解。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq m \leq 1024,1 \leq u,v \leq 500$。

题目翻译来自NOCOW。

USACO Training Section 3.3

## 样例 #1

### 输入

```
9
1 2
2 3
3 4
4 2
4 5
2 5
5 6
5 7
4 6```

### 输出

```
1
2
3
4
2
5
4
6
5
7```

# AI分析结果

### 综合分析与结论
本题是经典的欧拉路径问题，解题的核心在于利用欧拉路径和欧拉回路的性质找到合适的起点，再通过深度优先搜索（DFS）遍历图，确保每条边仅被访问一次，同时满足字典序最小的输出要求。各题解的思路大致相同，但在数据结构选择、代码实现细节和优化方式上存在差异。多数题解采用邻接矩阵存储图，部分使用 `vector`、`multiset` 等数据结构优化。关键难点在于确定起点和正确处理回溯时的路径记录，以保证输出的路径字典序最小且符合欧拉路径的要求。

### 所选题解
- **作者：EarthGiao (赞：296) - 4星**
    - **关键亮点**：思路清晰，代码注释详细，对算法步骤的解释通俗易懂，适合初学者理解欧拉路径的基本实现。
    - **个人心得**：无

- **作者：Mogu (赞：105) - 4星**
    - **关键亮点**：图文并茂地解释了欧拉路和欧拉回路的概念，详细分析了为什么要在回溯时记录路径，对理解算法的原理和细节有很大帮助。
    - **个人心得**：在最后两个点 WA 之后，倒腾一晚上发现了“正着输出”和“用栈去存路径，最后倒着输出答案”的区别，强调了回溯记录路径的重要性。

- **作者：Misaka_Azusa (赞：63) - 4星**
    - **关键亮点**：介绍了 Hierholzer 算法，对欧拉回路的求解有理论和实践的结合，代码简洁明了，是一种高效的实现方式。
    - **个人心得**：无

### 重点代码与核心实现思想
#### EarthGiao 的题解
```cpp
void find(int i) {
    int j;
    for(j = 1; j <= maxn; ++j) {
        if(map[i][j] >= 1) {
            map[i][j]--;
            map[j][i]--;
            find(j);
        }
    }
    lu[++js] = i;
}
```
**核心思想**：从当前节点开始，深度优先搜索其相邻节点，每访问一条边就将其标记为已访问（边数减 1），回溯时将节点记录到路径数组中。

#### Mogu 的题解
```cpp
void dfs(int u) {
    for(int v = minn; v <= maxn; v++) {
        if(g[u][v]) {
            g[u][v]--;
            g[v][u]--;
            dfs(v);
        } 
    }
    S.push(u);
}
```
**核心思想**：同样是深度优先搜索，使用栈来存储路径，在回溯时将节点压入栈中，最后倒序输出栈中的节点，确保路径符合要求。

#### Misaka_Azusa 的题解
```cpp
void dfs(int u) {
    for(int v = 1; v <= n; v++)
        if(G[u][v]) {
            G[u][v]--;
            G[v][u]--;
            dfs(v);    
        }
    S.push(u);
}
```
**核心思想**：基于 Hierholzer 算法，从当前节点出发，不断寻找未访问的边，将边标记为已访问后继续搜索，回溯时将节点压入栈中，最终得到欧拉路径。

### 最优关键思路或技巧
- **确定起点**：根据欧拉路径和欧拉回路的性质，若图中存在奇点，则从最小的奇点开始搜索；若所有点的度数均为偶数，则从编号最小的点开始搜索。
- **回溯记录路径**：在深度优先搜索的回溯过程中记录路径，可避免因贪心选择导致的错误，确保输出的路径符合字典序最小的要求。
- **数据结构选择**：对于数据范围较小的情况，邻接矩阵是一种简单直观的图存储方式；若要优化时间复杂度，可使用 `vector`、`multiset` 等数据结构。

### 可拓展之处
同类型题或类似算法套路包括：
- **有向图的欧拉路径和欧拉回路**：与无向图类似，但判断条件和处理方式略有不同，需要分别考虑入度和出度。
- **混合图的欧拉路径和欧拉回路**：图中既有有向边又有无向边，求解时需要更复杂的算法，如网络流算法。

### 推荐题目
- [P1341 无序字母对](https://www.luogu.com.cn/problem/P1341)
- [P2731 [USACO3.3] 骑马修栅栏 Riding the Fences](https://www.luogu.com.cn/problem/P2731)（本题）
- [P1127 词链](https://www.luogu.com.cn/problem/P1127)

### 个人心得总结
- **Mogu**：在做题过程中遇到最后两个点 WA 的问题，经过一晚上的调试，发现了“正着输出”和“用栈去存路径，最后倒着输出答案”的区别，强调了回溯记录路径的重要性，提醒我们在做题时要仔细考虑算法的细节，不能想当然。

---
处理用时：32.93秒
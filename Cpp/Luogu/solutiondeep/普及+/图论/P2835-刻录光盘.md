# 题目信息

# 刻录光盘

## 题目描述

在JSOI2005夏令营快要结束的时候，很多营员提出来要把整个夏令营期间的资料刻录成一张光盘给大家，以便大家回去后继续学习。组委会觉得这个主意不错！可是组委会一时没有足够的空光盘，没法保证每个人都能拿到刻录上资料的光盘，又来不及去买了，怎么办呢？！

组委会把这个难题交给了LHC，LHC分析了一下所有营员的地域关系，发现有些营员是一个城市的，其实他们只需要一张就可以了，因为一个人拿到光盘后，其他人可以带着U盘之类的东西去拷贝啊！

可是，LHC调查后发现，由于种种原因，有些营员并不是那么的合作，他们愿意某一些人到他那儿拷贝资料，当然也可能不愿意让另外一些人到他那儿拷贝资料，这与我们JSOI宣扬的团队合作精神格格不入！！！

现在假设总共有N个营员（2<=N<=200），每个营员的编号为1~N。LHC给每个人发了一张调查表，让每个营员填上自己愿意让哪些人到他那儿拷贝资料。当然，如果A愿意把资料拷贝给B，而B又愿意把资料拷贝给C，则一旦A获得了资料，则B，C都会获得资料。

现在，请你编写一个程序，根据回收上来的调查表，帮助LHC计算出组委会至少要刻录多少张光盘，才能保证所有营员回去后都能得到夏令营资料？


## 样例 #1

### 输入

```
5
2 3 4 0
4 5 0
0
0
1 0```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解围绕“刻录光盘”问题提供了多种解法，主要思路集中在图的连通性处理上。常见的算法有Tarjan算法求强连通分量、Floyd算法求传递闭包、并查集处理连通关系、DFS搜索等。各题解在思路清晰度、代码可读性和优化程度上存在差异。Tarjan算法和Floyd算法结合并查集的解法较为常见，能有效解决问题。

### 所选题解
- **作者：PrincessYR✨～ (赞：160)，5星**
    - **关键亮点**：详细介绍了强连通分量和Tarjan算法的原理，通过图文结合的方式逐步讲解Tarjan算法的执行过程，思路清晰，代码注释详细，易于理解。
    - **个人心得**：作者提到学习强连通分量和缩点花费了好几天时间，强调了学习的过程可能较为漫长，但耐心学习一定能掌握。
- **作者：LMB_001 (赞：99)，4星**
    - **关键亮点**：使用Floyd算法和并查集结合的方法，思路简单直接，代码实现简洁，适合初学者理解。
    - **个人心得**：作者表示刚从Pascal转C++一个星期，将Pascal的基础代入C++，特发此帖，鼓励大家学习新语言并勇于尝试。
- **作者：elephant_ouo (赞：19)，4星**
    - **关键亮点**：同样采用Floyd算法和并查集结合的方式，对Floyd算法的变形和并查集的使用解释清晰，代码逻辑明确。
    - **个人心得**：无

### 重点代码
#### PrincessYR✨～的Tarjan算法核心代码
```cpp
void tarjan(int x)
{
    dfn[x]=low[x]=++num;
    ins[x]=1;
    st.push(x);
    for(int i=0;i<map[x].size();i++)
    {
        int q=map[x][i];
        if(dfn[q]==0)
        {
            tarjan(q);
            low[x]=min(low[x],low[q]);
        }else if(ins[q]==1)
        {
            low[x]=min(low[x],dfn[q]);
        }
    }
    if(dfn[x]==low[x])
    {
        numb++;
        int p;
        do
        {
            p=st.top();
            st.pop();
            ins[p]=0;
            bl[p]=numb;
            nums[numb]++;
        }while(x!=p);
    }
}
```
**核心实现思想**：通过深度优先搜索遍历图，使用`dfn`数组记录节点的访问顺序，`low`数组记录节点或其子树能追溯到的最早栈中节点的次序号。当`dfn[x] == low[x]`时，说明找到了一个强连通分量，将栈中元素弹出并标记为同一个强连通分量。

#### LMB_001的Floyd和并查集核心代码
```cpp
for(k=1;k<=n;k++)  
    for(i=1;i<=n;i++)  
        for(j=1;j<=n;j++)  
            if(mapk[i][k]&&mapk[k][j])  
                mapk[i][j]=1;
for(i=1;i<=n;i++)  
    f[i]=i;
for(i=1;i<=n;i++)  
    for(j=1;j<=n;j++)  
        if(mapk[i][j]) f[j]=f[i];
```
**核心实现思想**：使用Floyd算法求出图的传递闭包，即如果`i`能到`k`，`k`能到`j`，则`i`能到`j`。然后使用并查集将能相互到达的节点合并到同一个集合中，最后统计集合的数量即为所需光盘数。

#### elephant_ouo的Floyd和并查集核心代码
```cpp
for(int k = 1; k <= n; k++)
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            f[i][j] = f[i][j] || f[i][k] && f[k][j];
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= n; j++)
        if(f[i][j])
            fa[j] = fa[i];
```
**核心实现思想**：与LMB_001的思路类似，先使用Floyd算法处理图的连通性，再使用并查集合并节点，最后统计集合数量。

### 最优关键思路或技巧
- **Tarjan算法**：通过深度优先搜索和栈的使用，高效地找出图中的强连通分量，时间复杂度为$O(N + M)$。
- **Floyd算法**：利用动态规划的思想，求出图中任意两点之间的可达性，时间复杂度为$O(N^3)$。
- **并查集**：用于处理节点之间的连通关系，通过合并和查找操作，快速判断节点是否属于同一个集合。

### 可拓展之处
同类型题或类似算法套路：
- **强连通分量相关**：可以进一步学习Tarjan算法的应用，如缩点后进行拓扑排序、求解有向图的最小路径覆盖等。
- **图的连通性问题**：可以尝试使用其他算法，如Kosaraju算法求强连通分量，或使用BFS解决无权图的连通性问题。

### 推荐题目
- [P2341 受欢迎的牛](https://www.luogu.com.cn/problem/P2341)
- [P2002 消息扩散](https://www.luogu.com.cn/problem/P2002)
- [P3387 缩点](https://www.luogu.com.cn/problem/P3387)

### 个人心得总结
- PrincessYR✨～：学习强连通分量和缩点需要耐心，通过不断学习和实践才能掌握。
- LMB_001：勇于尝试新语言，将已有的知识基础应用到新的环境中。

---
处理用时：38.93秒
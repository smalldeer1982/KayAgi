# 题目信息

# 密室

## 题目背景

NOIP2018 原创模拟题 T2

NOIP DAY1 T2 or DAY2 T2 难度

题目背景改编自小说《哈利波特与密室》。

## 题目描述

**密室被打开了。**

哈利与罗恩进入了密室，他们发现密室由n个小室组成，所有小室编号分别为：$1,2,...,n$ 。所有小室之间有 $m$ 条通道，对任意两个不同小室最多只有一条通道连接，而每通过一条通道都需要 $C_i$ 的时间。

开始时哈利与罗恩都在编号为 $1$ 的小室里，他们的目标是拯救金妮和寻找日记，但是他们发现金妮和日记可能在两个不同的小室里，为了尽快发现真相，他们决定以最少的时间到达两个目标小室。但是某些小室只有会与蛇对话的人才能进入，也就是只有哈利一个人可以进入。

现在，哈利告诉你密室的结构，请你计算他们到达两个目标小室的最短时间。

## 说明/提示

**样例解释：**

**样例一：**

哈利：$1->5->6$ 花费时间为 $5$

罗恩：$1->3->4$ 花费时间为 $5$

所以最短时间为 $5$

**样例二：**

![图1](https://cdn.luogu.com.cn/upload/pic/31438.png)

如图，橙色表示目标小室，绿色只有哈利可以通过

哈利：$1->2->3->4->6$ 花费时间为 $9$

罗恩：$1->9->8$ 花费时间为 $16$

所以最短时间为 $16$

**数据范围：**

$10\%$ 数据满足：$n\leq 5$

$30\%$ 数据满足：$n\leq 20$

$50\%$ 数据满足：$n\leq 1000$

$70\%$ 数据满足：$n\leq 10000$

$100\%$数据满足：$n\leq 50000$ ; $a,b,k\leq n$ ;  $c\leq 1000$ ; $m\leq 100000$，保证罗恩可以在密室 $1$

**特殊约定：**

$30\%$ 数据满足：$k=0$

## 样例 #1

### 输入

```
6 8 1
5
1 2 3
2 3 2
1 3 4
3 4 1
4 6 5
5 6 2
1 6 6
1 5 3
4 6```

### 输出

```
5```

## 样例 #2

### 输入

```
10 13 3
3 4 10
1 2 1
2 3 2
3 4 3
4 5 4
5 6 5
6 7 10
7 8 5
8 9 10
9 10 3
10 1 2
1 9 6
3 8 10
4 6 3
6 8```

### 输出

```
16```

# AI分析结果

### 综合分析与结论
本题是一个图论中的最短路问题，需要计算哈利和罗恩到达两个目标小室的最短时间。由于罗恩能走的路哈利都能走，但存在哈利能走而罗恩不能走的房间，因此需要考虑多种行走方案。

各题解的共同思路是分析不同的行走情况，通过多次最短路算法（如SPFA、Dijkstra）计算每种情况的时间，最后取最小值得到最终答案。主要的行走情况包括：哈利和罗恩分别前往不同目标小室，哈利单独前往两个目标小室。

### 所选题解
- 作者：丨Sky灬丨无惧 (赞：9)，5星
    - 关键亮点：思路清晰，详细列出了四种走法，并对每种走法的计算进行了说明；代码注释详细，便于理解。
    - 个人心得：无

### 重点代码及核心实现思想
```cpp
// 链式前向星建图
struct sb {
    int u,v,w,next;
};
sb a[1000000];
void ctt(int u,int v,int w) {
    a[++k].u=u;
    a[k].v=v;
    a[k].w=w;
    a[k].next=b[u];
    b[u]=k;
    return;
}

// SPFA算法求最短路
void SPFA() {
    for(int i=1; i<=n; i++)ans[i]=1e9;
    r=0;
    l=1;
    memset(c,0,sizeof(c));
    if(check!=2) {
        q[++r]=1;
        ans[1]=0;
    }
    else {
        q[++r]=x;
        ans[x]=0;
    }
    while(l<=r) {
        int u=q[l++];
        c[u]=0;
        if(!check&&vis[u])continue;
        for(int i=b[u]; i; i=a[i].next) {
            int v=a[i].v;
            if(ans[v]>ans[u]+a[i].w) {
                ans[v]=ans[u]+a[i].w;
                if(c[v]==0) {
                    c[v]=1;
                    q[++r]=v;
                }
            }
        }
    }
}

// 主函数计算不同走法的时间并取最小值
int main() {
    // 输入处理
    cin>>n>>m>>k1;
    for(int i=1; i<=k1; i++) {
        cin>>lsg;
        vis[lsg]=1;
    }
    for(int i=1; i<=m; i++) {
        cin>>u>>v>>w;
        ctt(u,v,w);
        ctt(v,u,w);
    }
    cin>>x>>y;

    // 三次SPFA计算不同情况的最短时间
    SPFA();
    zc[1]=ans[x];
    zc[2]=ans[y];
    check++;
    SPFA();
    zc[3]=ans[x];
    zc[4]=ans[y];
    check++;
    SPFA();
    zc[5]=ans[y];

    // 计算不同走法的时间并取最小值
    int x2,y2,z2;
    x2=max(zc[1],zc[4]);
    y2=max(zc[2],zc[3]);
    z2=min(zc[3],zc[4])+zc[5];
    x2=min(x2,y2);
    cout<<min(x2,z2);
    return 0;
}
```
核心实现思想：首先使用链式前向星构建图，然后通过三次SPFA算法分别计算罗恩到目标小室、哈利到目标小室、哈利从一个目标小室到另一个目标小室的最短时间。最后根据不同的行走情况计算总时间，并取最小值作为最终答案。

### 最优关键思路或技巧
- **情况分析**：清晰地列出所有可能的行走情况，避免遗漏。
- **算法选择**：根据数据范围选择合适的最短路算法，如本题中使用SPFA或Dijkstra。
- **代码优化**：使用链式前向星存储图，减少空间复杂度。

### 可拓展之处
同类型题或类似算法套路：
- 多源最短路问题，如Floyd算法。
- 带限制条件的最短路问题，如本题中罗恩有部分房间不能走。
- 分层图最短路问题，用于处理具有不同状态的最短路问题。

### 推荐题目
- P3371 【模板】单源最短路径（弱化版）
- P4779 【模板】单源最短路径（标准版）
- P1144 最短路计数

### 个人心得摘录与总结
- xcyy：初始化给inf的值为0x7f只有90分，改成0x3f3f3f3f就过了，提醒在初始化无穷大值时要注意取值。
- 02XXX：因为没加q.pop()卡了好长时间，强调在实现算法时要仔细检查代码，避免遗漏关键操作。
- 顾z：第一眼认为是水题，结果发现考虑不全，提醒在解题时要全面分析问题，避免遗漏情况。

---
处理用时：36.49秒
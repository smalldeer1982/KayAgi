# 题目信息

# [USACO19FEB] The Great Revegetation S

## 题目描述

一场漫长的干旱使农场主约翰的 $N$ 个牧场没有草。然而，随着雨季的到来，是时候“重新种植”了。在农夫约翰的小屋里，他有两个桶，每个桶都有不同类型的草籽。他想在他的每一个牧场种草，在每一个牧场中选择一种类型的草。

作为一名奶农，农场主约翰想确保他能满足他那几头奶牛的特殊饮食需求。他的 $m$ 头奶牛都有两个最喜欢的牧场。他的一些奶牛有一个饮食限制，那就是他们应该只吃一种类型的草，因此农场主约翰希望确保在这类奶牛最喜欢的两个田里种植同一种类型的草。其他的奶牛有一个不同的饮食限制，要求他们吃不同类型的草。对于那些奶牛，农场主约翰当然想确保他们最喜欢的两块田地里有不同的草。


请帮助农场主约翰确定他在他的 $N$ 个牧场上种植草的不同方式的数量。

## 说明/提示

USACO 2019 二月月赛银牌组第三题

## 样例 #1

### 输入

```
3 2
S 1 2
D 3 2```

### 输出

```
10```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是围绕并查集或图的染色来解决牧场种草方案数的问题。多数题解先考虑无冲突情况下，通过计算连通块数量得出方案数为 \(2^{连通块个数}\)，再通过不同方法判断是否存在冲突，若有冲突则方案数为 0。各题解在实现细节和使用的数据结构上有所不同，如有的使用普通并查集，有的使用带权并查集，还有的通过建图进行染色判断冲突。

### 所选题解
- **作者：potatoler (赞：13)，4星**
    - **关键亮点**：思路清晰，将牧场关系抽象为友好和敌对，利用并查集补集的思路解决问题，代码实现简洁明了。
- **作者：哈士奇憨憨 (赞：3)，4星**
    - **关键亮点**：从图的染色角度出发，思路直观，复杂度分析明确，代码简洁易懂。
- **作者：VTloBong (赞：2)，4星**
    - **关键亮点**：使用带权并查集解决冲突判断问题，方法独特，对带权并查集的原理和实现有详细说明。

### 重点代码及核心思想
#### potatoler 的题解
```cpp
int find(int x){
    if(fa[x]==x) return x;
    else return fa[x]=find(fa[x]);
}
int com(int x){
    if(gr[x]==x) return x;
    else return gr[x]=com(gr[x]);
}
// ...
if(op=='S'){
    gr[com(a)]=com(b);
    gr[com(a+n)]=com(b+n);
}
else{
    if(com(a)==com(b)){
        ans=0;
        break;
    }
    gr[com(a+n)]=com(b);
    gr[com(a)]=com(b+n);
}
if(find(a)!=find(b)){
    fa[find(a)]=find(b);
    ans--;
}
```
**核心思想**：用 `fa` 数组维护牧场的连通性，`gr` 数组维护牧场的友好和敌对关系。遇到相同草的关系，将对应牧场及其补集合并；遇到不同草的关系，检查是否冲突，若不冲突则合并对应补集。

#### 哈士奇憨憨的题解
```cpp
void S(int x, int c) {      // 点x染色c
  if (v[x].c) {             // 已经染色
    if (v[x].c != c + 1) {  // 与之前的染色不同
      t = -n;               // 标记无解
    }
    return;
  }
  v[x].c = c + 1;          // 染色
  for (auto i : v[x].e) {  // 遍历邻边
    S(i.first, c ^ i.second);
  }
}
```
**核心思想**：通过深度优先搜索对图进行染色，根据边的类型（同色或异色）确定相邻点的颜色，若染色过程中出现矛盾则标记无解。

#### VTloBong 的题解
```cpp
int find(int x){
	if(p[x]==x)return x;
	int f=find(p[x]);
	v[x]=(v[x]+v[p[x]])&1,p[x]=f;
	return f;
}
// ...
int fa=find(a),fb=find(b),t,l,w=(str=='D');
if(fa!=fb){
    if(s[fa]>s[fb])t=fa,fa=fb,fb=t,l=a,a=b,b=l;
    p[fa]=fb,s[fb]+=s[fa],v[fa]=(w>=v[a]+v[b]?w-v[a]-v[b]:v[a]+v[b]-w)&1;
}else impossible=(((v[a]+v[b])&1)!=w);
```
**核心思想**：使用带权并查集，`v` 数组记录节点与其父节点的关系（0 表示相同，1 表示相异）。在查找和合并过程中更新权值，合并时检查是否冲突。

### 最优关键思路或技巧
- **并查集补集思想**：将牧场关系抽象为友好和敌对，通过并查集补集维护不同关系，方便判断冲突。
- **图的染色**：将问题转化为图的染色问题，通过深度优先搜索对图进行染色，判断是否存在冲突。
- **带权并查集**：使用带权并查集记录节点之间的关系，在合并和查找过程中更新权值，高效判断冲突。

### 可拓展之处
同类型题如二分图判定、种类并查集相关问题。类似算法套路可用于解决具有分类关系的问题，如动物的食物链关系、人的分组问题等。

### 推荐题目
- [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)：涉及并查集补集或带权并查集的应用，判断是否存在冲突。
- [P2024 [NOI2001] 食物链](https://www.luogu.com.cn/problem/P2024)：经典的种类并查集问题，需要处理不同种类之间的关系。
- [P1892 [BOI2003]团伙](https://www.luogu.com.cn/problem/P1892)：并查集的简单应用，处理朋友和敌人的关系。

### 个人心得
- **yangyujia18**：提到同类的合并时不需要判断是否符合条件，异类合并需要判断，因为这个问题调了三周。这提醒我们在使用种类并查集时要注意合并条件的判断，不同类型的合并操作可能有不同的处理方式。

---
处理用时：37.22秒
# 题目信息

# [GZOI2017] 小z玩游戏

## 题目背景

GZOI2017 D1T2

## 题目描述

小 z 很无聊。

小 z 要玩游戏。

小 z 有 $N$ 个新游戏，第 $i$ 个游戏看上去的有趣程度为 $w_i$。

小 z 很挑，他只会玩看上去的有趣程度是自己兴奋程度整数倍的游戏。

由于游戏实际上有好玩的也有不好玩的，玩完第 $i$ 个游戏后，小 z 的兴奋程度会变为 $e_i$。

已知小 z 初始兴奋程度为 $1$，请问小 z 有多少个游戏可能会玩两次？

## 说明/提示

### 样例 2 解释

数字代表游戏编号，箭头表示下一个。

- 情况 $1$：$2\to 5\to 4\to 2$；
- 情况 $2$：$5\to 4\to 2\to 5$；
- 情况 $3$：$4\to 2\to 5\to 4$。

所以小 z 可能玩 $2,4,5$ 两次。

小 z 无论如何都不能玩 $1$ 或 $3$ 两次。

### 数据范围及约定


![](https://cdn.luogu.com.cn/upload/image_hosting/s757wplh.png)

## 样例 #1

### 输入

```
5
1
100000
100000
5
1 2 6 15 35
5 7 9 2 3
5
2 3 5 35 21
7 11 7 3 2
10
6 15 77 12 24 37 35 99 55 42
4 2 5 7 11 3 6 8 9 10
10
6540 5604 567 57065 60 670 6870 1230 465 6540
12 5 37 3 34 13 17 18 10 12```

### 输出

```
1
3
3
8
5```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是将题目转化为图论模型，通过建图并使用 Tarjan 算法求解强连通分量，以此判断哪些游戏可能被玩两次。由于直接暴力建边复杂度为 $O(n^2)$ 会超时，所以各题解的主要差异在于建边优化方法。部分题解还在点的设置和边的连接方式上进行了不同尝试，以达到更优的时间和空间复杂度。

### 所选题解
- **作者：Cutest_Junior（5星）**
  - **关键亮点**：思路清晰，详细阐述了从错误思路到正确思路的转变过程，代码结构清晰，注释丰富，建边复杂度 $O(n\log n)$ 能通过数据。
  - **个人心得**：一开始想对于任意两个游戏判断是否建边然后跑 Tarjan，但复杂度高无法通过，于是换一种思考方式，对每个数向它的倍数建边，再对于每个游戏从 $w$ 向 $e$ 建边。

- **作者：WYXkk（4星）**
  - **关键亮点**：在点的设置上进行优化，指出不需要建 $3n$ 个点，$n$ 个点就足够，且连边还可进一步优化为只连 $(i, i\times p)$（$p$ 是质数），代码实现简洁高效。
  - **个人心得**：经过思考发现可以进一步优化点的数量和连边方式，不加任何火车头之类的优化拿到了本题最优解。

- **作者：喵仔牛奶（4星）**
  - **关键亮点**：对建边优化进行了详细分析，指出每个点只向自己的素数倍连边可使边数降为 $O(V\ln\ln V)$，时间复杂度分析准确。
  - **个人心得**：无

### 重点代码
#### Cutest_Junior 的建边与 Tarjan 代码
```cpp
// 建边
for (int i = 1; i + i < N; ++i) {
    for (int j = 2; j * i < N; ++j) {
        add(i, j * i);
    }
}
for (int i = 1; i <= n; ++i) {
    add(arr1[i], arr2[i]);
}

// Tarjan 算法
void tarjan(int x) {
    dfn[x] = low[x] = ++dfstot;
    sta.push(x);
    for (int i = 0; i < edge[x].size(); ++i) {
        int to = edge[x][i];
        if (dfn[to] == 0) {
            tarjan(to);
            low[x] = min(low[x], low[to]);
        }
        else if (scc[to] == 0) {
            low[x] = min(low[x], dfn[to]);
        }
    }
    if (low[x] == dfn[x]) {
        ++scctot;
        while (1) {
            int t = sta.top();
            sta.pop();
            scc[t] = scctot;
            if (t == x) {
                break;
            }
        }
    }
}
```
**核心思想**：先对每个数向它的倍数建边，再对每个游戏从有趣程度 $w$ 向玩完后的兴奋程度 $e$ 建边，然后使用 Tarjan 算法求强连通分量，最后判断每个游戏的 $w$ 和 $e$ 是否在同一强连通分量。

#### WYXkk 的建边与 Tarjan 代码
```cpp
// 筛质数
void shai() {
    isnp[0]=isnp[1]=true;
    F(i,2,100000) {
        if(!isnp[i]) prs[++prn]=i;
        for(ri j=1;j<=prn&&i*prs[j]<=100000;++j) {isnp[i*prs[j]]=true;if(!(i%prs[j])) break;}
    }
}

// 建边
F(i,1,100000) {for(ri t=1;i*prs[t]<=100000;++t) add(i,i*prs[t]);}
F(i,1,n) add(w[i],e[i]);

// Tarjan 算法
void tarjan(int u) {
    dfn[u]=low[u]=++tme;stk[++top]=u;
    for(ri i=head[u];i;i=nxt[i]) {if(!dfn[to[i]]) tarjan(to[i]);if(!bel[to[i]]) low[u]=min(low[u],low[to[i]]);}
    if(dfn[u]==low[u]) {
        siz[++num]=0;
        while(stk[top]!=u) {bel[stk[top--]]=num;++siz[num];}
        bel[stk[top--]]=num;++siz[num];
    }
}
```
**核心思想**：先筛出质数，建边时每个数只向自己的质数倍连边，再对每个游戏从 $w$ 向 $e$ 建边，然后用 Tarjan 算法求强连通分量，判断 $w$ 和 $e$ 是否在同一强连通分量。

#### 喵仔牛奶的建边与 Tarjan 代码
```cpp
// 筛质数
void GetPrime(int n) {
    for (int i = 2; i <= n; i ++) {
        if (!prime[i]) a[++ cnt] = i;
        for (int j = 1; j <= cnt && i * a[j] <= n; j ++) {
            prime[i * a[j]] = true;
            if (i % a[j] == 0) break;
        }
    }
}

// 建边
for (int i = 1; i <= 1e5; i ++) qwq[i] = n + i;
for (int i = 1; i <= n; i ++) cin >> w[i], G.add(qwq[w[i]], i);
for (int i = 1; i <= n; i ++) cin >> e[i], G.add(i, qwq[e[i]]);
for (int i = 1; i <= 1e5; i ++)
    for (int j = 1; j <= cnt && i * a[j] <= 1e5; j ++)
        G.add(qwq[i], qwq[i * a[j]]);

// Tarjan 算法
void tarjan(int u) {
    dfn[u] = low[u] = ++ tot;
    s.push_back(u), vis[u] = true;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if (vis[v]) low[u] = min(low[u], low[v]);
    }
    if (dfn[u] == low[u]) {
        ans[++ cnt].push_back(u);
        while (s.back() != u) {
            int v = s.back(); s.pop_back();
            pos[v] = cnt, vis[v] = false, ans[cnt].push_back(v);
        }
        s.pop_back(), pos[u] = cnt, vis[u] = false;
    }
}
```
**核心思想**：先筛出质数，建图时每个数向自己的质数倍连边，每个游戏从有趣程度对应的点向游戏点连边，游戏点向玩完后兴奋程度对应的点连边，再用 Tarjan 算法求强连通分量，判断游戏点所在强连通分量大小是否大于 1。

### 最优关键思路或技巧
- **建边优化**：避免直接暴力建边，通过对每个数向它的倍数建边，或只向质数倍建边，将建边复杂度从 $O(n^2)$ 优化到 $O(n\log n)$ 或 $O(V\ln\ln V)$。
- **图论模型转化**：将游戏的选择过程转化为图论中的有向图，利用强连通分量判断游戏是否可能被玩两次。

### 可拓展之处
同类型题或类似算法套路：
- 其他需要建图并使用 Tarjan 算法求解强连通分量的图论问题，如判断图中是否存在环、求图的缩点等。
- 对于建边复杂度高的问题，可以考虑通过数学性质或特殊规则进行建边优化，如只连质数倍、利用倍数关系等。

### 推荐题目
- P2341 [USACO03FALL][HAOI2006] 受欢迎的牛 G
- P3387 【模板】缩点
- P1262 间谍网络

### 个人心得总结
- **Cutest_Junior**：一开始尝试的暴力建边思路复杂度高无法通过，换一种思考方式对每个数向它的倍数建边解决了问题，提醒我们在遇到复杂度高的问题时要尝试换思路。
- **WYXkk**：经过思考发现可以优化点的数量和连边方式，不加优化拿到最优解，说明做题时要深入思考，挖掘题目中的优化点。
- **CuSO4_and_5H2O**：做本题时遇到枚举倍数对象错误、数组越界、空间超限等问题，提醒我们在实现算法时要注意细节，避免这些常见错误。 

---
处理用时：56.71秒
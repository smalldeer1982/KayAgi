# 题目信息

# [SBCOI2020] 时光的流逝

## 题目背景

时间一分一秒的过着，伴随着雪一同消融在了这个冬天，  
或许，要是时光能停留在这一刻，该有多好啊。  
......    
“这是...我在这个小镇的最后一个冬天了吧。”  
“嗯，你可不能这辈子都呆在这个小镇吧。外面的世界很大呢，很大很大...”  
“唔...外面的世界...突然有点期待呢！”  
“总有一天，你会走得很远很远。以后你可不要忘记这个小镇那。”  
“不会的，至少...这里曾经是我最快乐的一段回忆呢！你也一定不要忘记我呀。”   
“你看，这雪花。传说，每当世界上有一份思念，便会化成一片雪花在这里飘落。”   
“那...以后你可一定要找到我的那片雪花啊......”  
![](https://cdn.luogu.com.cn/upload/image_hosting/orzntcy6.png)    
“嗯，不如我们一起在这个冬天创造最后一段回忆吧。”  
“好呀，我们玩个游戏吧......”  

## 题目描述

这个游戏是在一个有向图（不保证无环）上进行的。每轮游戏开始前，她们先在图上选定一个起点和一个终点，并在起点处放上一枚棋子。

然后两人轮流移动棋子，每次可以将棋子按照有向图的方向移动至相邻的点。

如果谁先将棋子移动至终点，那么谁就胜利了。同样，如果谁无法移动了，那么谁就失败了。

两人轮流操作，请问，他们是否有必胜策略呢？  

答案为一个整数 `0` 或 `1` 或 `-1`，其中 `1` 表示（先手）有必胜策略，`-1` 表示后手有必胜策略，`0` 表示两人均无必胜策略。

## 说明/提示

#### 样例解释 $#1$

![](https://cdn.luogu.com.cn/upload/image_hosting/k7q0qjrb.png)

为描述题意，假设两人为 A（先手）和 B

如图，A 先走，走到 $2$，B 走到 $3$，接下去 A 可以选择走到 $4$ 或 $6$，若走到 $4$，接下去 B 可以走到终点，故不可取。若选择走到 $6$，那么 B 只能走到 $7$，A 可以走到终点。所以 A 有必胜策略。

#### 样例解释 $#2$

![](https://cdn.luogu.com.cn/upload/image_hosting/9yjnyye3.png)

如图，起点为 $1$，终点为 $5$ 时， A 和 B 会沿着 $1-2-3-1$ 的顺序轮流走。因为如果谁先走到 $4$，那么下一个人就可以走到终点。故谁都没有必胜策略。

起点为 $4$，终点为 $3$ 时，A 先走到 $5$，B 无路可走，故 B 失败。

#### 数据范围

对于 $10\%$ 的数据，保证图是一条链。

对于 $50\%$ 的数据，$1\leq n\leq 10^3$，$1\leq m\leq 2\times10^3$，$1\leq q\leq 10$。

对于 $70\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 2\times10^5$，$1\leq q\leq 10$。

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 5\times10^5$，$1\leq q\leq 500$。

## 样例 #1

### 输入

```
7 7 1
1 2
2 3
3 4
4 5
3 6
7 5
6 7
1 5```

### 输出

```
1```

## 样例 #2

### 输入

```
5 5 2
1 2
2 3
3 1
3 4
4 5
1 5
4 3```

### 输出

```
0
1```

# AI分析结果

### 综合分析与结论
这些题解均围绕图上博弈论问题展开，核心思路是标记必胜点和必败点。普遍采用反向建图和拓扑排序的方法，利用队列存储已确定状态的点，从终点和出度为 0 的点开始推导其他点的状态。对于有环图的处理，通过避免重复访问已确定状态的点来防止环对答案传递的干扰。

### 所选题解
- **作者：犇犇犇犇（5 星）**
    - **关键亮点**：思路清晰，对不同数据范围的处理有详细说明，代码注释丰富，对时间复杂度也有相关解释。
- **作者：duyi（4 星）**
    - **关键亮点**：详细分析了有环和无环的情况，对拓扑排序的过程解释清晰，代码实现简洁。
- **作者：Mine_King（4 星）**
    - **关键亮点**：对博弈论的原理阐述明确，建反图和推导过程的描述易于理解，代码结构清晰。

### 重点代码
#### 作者：犇犇犇犇
```cpp
// 建反向边
addedge(b, a); 
// 若当前点出度为0，放进队列
if(p[i]==0) 
    q.push(i); 
// 将终点放进队列
q.push(y); 
// 终点为必败点
vic[y]=1; 
while(!q.empty())
{
    int u=q.front();
    q.pop();
    if(f[u]==1) 
        continue; 
    if(vic[x]!=0)
        break; 
    del(u); 
    if(vic[u]==1)
    {
        for(int i=head[u];i;i=e[i].nxt) 
        {
            int v=e[i].v;
            if(vic[v]==0)
            {
                vic[v]=-1;
                del(v); 
            }
        }	
    }
    else if(out[u]==0)
    {
        vic[u]=1; 
    }
    else 
    {
        vic[u]=1; 
        for(int i=head[u];i;i=e[i].nxt) 
        {
            int v=e[i].v;
            if(vic[v]==0)
            {
                vic[v]=-1;
                del(v); 
            }
        }		
    }		
}
```
**核心实现思想**：建反向边，将出度为 0 的点和终点放入队列，标记终点为必败点。不断从队列中取出点，根据其状态更新相邻点的状态，若相邻点状态确定则放入队列。

#### 作者：duyi
```cpp
for(int i=1;i<=m;++i){
    int u,v;
    cin>>u>>v;
    add_edge(v,u);
    in_degree[u]++;
}
for(int tq=1;tq<=q;++tq){
    cin>>st>>ed;
    queue<int>que;
    for(int i=1;i<=n;++i){
        cur_deg[i]=in_degree[i];
        if(!cur_deg[i] || i==ed)
            f[i]=-1,que.push(i);
        else
            f[i]=0;
    }
    while(!que.empty()){
        int u=que.front(); que.pop();
        for(int i=head[u];i;i=edge[i].nxt){
            int v=edge[i].to;
            if(f[v]!=0)continue;
            cur_deg[v]--;
            if(f[u]==-1){
                f[v]=1;
                que.push(v);
            }
            else if(!cur_deg[v]){
                if(f[v]!=1)
                    f[v]=-1;
                que.push(v);
            }
        }
    }
    cout<<f[st]<<endl;
}
```
**核心实现思想**：建反向边并统计入度，每次询问将入度为 0 的点和终点放入队列，标记为必败点。从队列中取出点，根据其状态更新相邻点的状态，若相邻点状态确定则放入队列。

#### 作者：Mine_King
```cpp
for(int i=1;i<=m;i++)
{
    int u,v;
    scanf("%d%d",&u,&v);
    g.add(v,u);
    kk[u]++;
}
while(Q--)
{
    int s,t;
    scanf("%d%d",&s,&t);
    memset(f,0,sizeof(f));
    memcpy(in,kk,sizeof(kk));
    for(int i=1;i<=n;i++)
        if(!in[i]||i==t) q.push(i),f[i]=-1;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=g.hd[x];i;i=g.nxt[i])
            if(!f[g.to[i]])
            {
                if(f[x]==1)
                {
                    in[g.to[i]]--;
                    if(!in[g.to[i]]) q.push(g.to[i]),f[g.to[i]]=-1;
                }
                else q.push(g.to[i]),f[g.to[i]]=1;
            }
    }
    printf("%d\n",f[s]);
}
```
**核心实现思想**：建反图并统计入度，每次询问将入度为 0 的点和终点放入队列，标记为必败点。从队列中取出点，根据其状态更新相邻点的状态，若相邻点状态确定则放入队列。

### 最优关键思路或技巧
- **反向建图**：从已知状态的点（终点和出度为 0 的点）反推其他点的状态，便于利用拓扑排序。
- **拓扑排序**：借助队列存储已确定状态的点，不断更新相邻点的状态，避免重复计算。
- **状态标记**：用数组标记每个点的必胜、必败或未确定状态，方便判断和更新。

### 可拓展之处
同类型题或类似算法套路：
- 其他图上博弈问题，如在不同类型的图（树、网格图等）上进行博弈。
- 结合其他算法的博弈问题，如动态规划与博弈论的结合。

### 推荐题目
- [P2197 【模板】nim 游戏](https://www.luogu.com.cn/problem/P2197)
- [P1247 取火柴游戏](https://www.luogu.com.cn/problem/P1247)
- [P3185 [HNOI2007]分裂游戏](https://www.luogu.com.cn/problem/P3185)

### 个人心得摘录与总结
- **作者：Mooncrying**：提到本题是 2023 省选 Day 2 T1 的弱化版，2023 年省选题没给出状态连接图，需要通过一次 bfs 自己建一张反图，十分考察代码能力。总结：对于图上博弈问题，可能会结合其他算法，并且在输入数据的处理上增加难度，需要提高代码实现能力。

---
处理用时：44.34秒
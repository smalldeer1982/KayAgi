# 题目信息

# [POI 2003] Monkeys

## 题目描述

一棵树上有 $n$ 只猴子。他们从 $1 \sim n$ 编号。编号为 $1$ 的猴子用它的尾巴盘住了一个树枝，剩下的猴子要么被其他的猴子钩住要么就是自己用手钩住其他的猴子。每只猴子都可以用两只手去钩其他的猴子，每只手最多只能钩一只。

从 $0$ 时刻开始，每一秒都有一只猴子松开它的一只手。这也许会造成一些猴子掉落到地上，我们想要知道它们掉落地上的时间（猴子掉落的速度都非常的快，可以忽略掉落的时间）。

## 说明/提示

对于所有数据，$1 \le n \le 2 \times 10^5$，$1 \le m \le 4 \times 10^5$。

## 样例 #1

### 输入

```
3 2
-1 3
3 -1
1 2
1 2
3 1```

### 输出

```
-1
1
1```

# AI分析结果

### 综合分析与结论
这些题解均采用“正难则反”的思维，将删边问题转化为加边问题，以简化问题求解。具体实现上，部分使用并查集维护连通性，部分通过 DFS 标记连通节点。

### 所选题解
- **作者：Alex_Wei（5星）**
    - **关键亮点**：思路清晰，代码简洁，直接用 DFS 打标记求每个猴子第一次与 1 连通的时间，时间复杂度线性。
    - **核心代码**：
```cpp
void dfs(int id, int as) {
    if(id == -1 || vis[id]) return;
    vis[id] = 1, ans[id] = as;
    if(!ban[id][0]) dfs(ls[id], as);
    if(!ban[id][1]) dfs(rs[id], as);
    for(auto it : e[id]) if(!ban[it.first][it.second]) dfs(it.first, as);
}
```
    - **核心思想**：DFS 函数用于标记与当前节点连通的节点，并记录其第一次与 1 连通的时间。

- **作者：wzy2021（4星）**
    - **关键亮点**：使用并查集结合链表维护连通块信息，解决了连通块合并时更新节点信息的问题。
    - **核心代码**：
```cpp
void merge (int u, int v, int p) {
    int fu = find(u), fv = find(v);
    if (fu == fv) return ;
    if (fu > fv) swap (fu, fv);
    if (fu == 1 && p!= -1) {
        for (int use = head[fv]; use; use = nxt[use]) ans[use] = p;
    }
    fa[fv] = fu; nxt[tail[fu]] = head[fv]; tail[fu] = tail[fv];
} 
```
    - **核心思想**：merge 函数用于合并两个连通块，若其中一个连通块与 1 相连，则更新另一个连通块内节点的答案。

### 最优关键思路或技巧
- **思维方式**：“正难则反”，将删边问题转化为加边问题，降低问题难度。
- **算法实现**：使用 DFS 或并查集维护连通性，根据不同情况选择合适的数据结构和算法。

### 可拓展之处
同类型题如删点、删边求连通性问题，都可尝试用“时光倒流”将操作逆序，转化为加点、加边问题。类似算法套路还有离线处理，先记录所有操作，再统一处理。

### 推荐题目
- [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)
- [P1653 猴子](https://www.luogu.com.cn/problem/P1653)
- [P2121 拆地毯](https://www.luogu.com.cn/problem/P2121)

### 个人心得
- **作者：ningago**：“首先想到的是并查集，于是并查集调炸了，无意中发现了另一种不用并查集的小清新做法。” 总结：在解题时，若一种方法遇到困难，可尝试换一种思路和方法。 

---
处理用时：21.06秒
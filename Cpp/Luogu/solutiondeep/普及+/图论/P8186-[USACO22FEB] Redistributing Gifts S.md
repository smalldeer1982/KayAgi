# 题目信息

# [USACO22FEB] Redistributing Gifts S

## 题目描述

FJ 有 $N$ 个礼物给他的 $N$ 头奶牛，这 $N$ 个礼物和 $N$ 头奶牛都被标记为 $1 \dotsm N (1 \le N \le 500)$ 。 每头奶牛都有一个愿望单，记录着一个含有 $N$ 个礼物的排列。比起在愿望单中出现更晚的礼物，奶牛更喜欢先出现在愿望单中的礼物。

因为 FJ 太懒了，他直接把 $i$ 号礼物分配给了 $i$ 号奶牛。现在，奶牛们聚在了一起，决定重新分配礼物，以便在重新分配后，每头奶牛都能得到跟原来一样，或是它更喜欢的礼物。

对于每个 $i$ （$i$ 从 $1$ 到 $N$），计算出重新分配后， $i$ 号奶牛可能拿到的最好的礼物（这个奶牛经过重新分配后能拿到的最喜欢的礼物）。

## 说明/提示

- $2 \sim 3$ 号测试点满足 $N \le 8$
- $4 \sim 11$ 号测试点没有别的限制

由 [tzyt](https://www.luogu.com.cn/user/394488) 翻译

## 样例 #1

### 输入

```
4
1 2 3 4
1 3 2 4
1 2 3 4
1 2 3 4```

### 输出

```
1
3
2
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何重新分配礼物，使每头奶牛获得原礼物或更喜欢的礼物，并找出每头奶牛可能拿到的最好礼物展开。整体思路多为建图后采用不同算法判断环或连通性。
- **思路对比**：
    - 部分题解采用 Floyd 传递闭包，通过判断两点间的可达性来确定能否交换礼物；部分用 DFS 或 BFS 搜索；还有用 Tarjan 算法找强连通分量；也有使用二分图匹配。
- **算法要点**：
    - Floyd 传递闭包：三重循环更新两点间可达性，时间复杂度 $O(n^3)$。
    - DFS：递归搜索判断能否形成环。
    - BFS：逐层扩展，判断能拿到的礼物。
    - Tarjan：找强连通分量，判断能否交换礼物。
    - 二分图匹配：通过匈牙利算法匹配奶牛和礼物。
- **解决难点**：
    - 如何判断礼物交换是否可行，多数通过判断环或连通性解决。
    - 提高算法效率，部分题解用 `bitset` 优化，或采用时间复杂度更低的算法。

### 高评分题解
1. **作者：Jorge_Filho（5星）**
    - **关键亮点**：思路清晰，详细阐述了枚举和 DFS 判断环的方法，代码有注释，便于理解。
    - **核心代码**：
```cpp
void Dfs(const int &x) {
    for(int i=h[x]; ~i; i=ne[i]) {
        int cur=e[i];
        if(bjt[st][cur]) continue;
        bjt[st][cur]=1;
        Dfs(cur);
    }
}
```
核心思想：从起点开始 DFS，标记可达点，判断能否形成环。
2. **作者：xixike（4星）**
    - **关键亮点**：使用 `bitset` 优化传递闭包，时间复杂度低，代码简洁。
    - **核心代码**：
```cpp
for (short j = 1; j <= n; ++ j) {
    for (short i = 1; i <= n; ++ i) {
        if (f[i][j]) 
            f[i] |= f[j];
    }
}
```
核心思想：利用 `bitset` 进行传递闭包更新，判断两点间可达性。
3. **作者：5ab_juruo（4星）**
    - **关键亮点**：采用 Tarjan 算法，时间复杂度 $O(n^2)$，思路独特。
    - **核心代码**：
```cpp
void tarjan(int id)
{
    dfn[id] = low[id] = ind++;
    stk[stp++] = id, inst[id] = true;
    
    for (int p = hd[id]; p!= -1; p = nxt[p])
    {
        if (dfn[des[p]] == -1)
        {
            tarjan(des[p]);
            chmin(low[id], low[des[p]]);
        }
        else if (inst[des[p]])
            chmin(low[id], dfn[des[p]]);
    }
    
    if (low[id] == dfn[id])
    {
        int tmp, lst = stp;
        do {
            tmp = stk[--stp];
            inst[tmp] = false;
            bel[tmp] = s_cnt;
        } while (tmp!= id);
        siz[s_cnt++] = lst - stp;
    }
}
```
核心思想：通过 Tarjan 算法找强连通分量，判断能否交换礼物。

### 最优关键思路或技巧
- **建图**：将奶牛和礼物抽象为点，根据奶牛对礼物的喜好连有向边，便于用图算法解决问题。
- **算法优化**：如使用 `bitset` 优化传递闭包，Tarjan 算法降低时间复杂度。
- **枚举与判断**：枚举每头奶牛可能拿到的礼物，通过判断环或连通性确定是否可行。

### 拓展思路
同类型题或类似算法套路：
- 涉及资源分配和交换，可建图后用图算法判断可行性。
- 找环或连通性问题，可使用 Floyd、DFS、BFS、Tarjan 等算法。

### 推荐题目
- P1119 灾后重建（Floyd 算法）
- P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G（Tarjan 算法）
- P3386 【模板】二分图最大匹配（二分图匹配）

### 个人心得
- **作者：ZBAA_MKC**：一开始按两两换的思路做，未考虑多个点轮换的情况，后来想到用 Floyd 算法解决，强调思维转换的重要性。

---
处理用时：31.56秒
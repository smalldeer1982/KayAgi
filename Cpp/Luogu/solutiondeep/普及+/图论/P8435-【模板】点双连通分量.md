# 题目信息

# 【模板】点双连通分量

## 题目描述

对于一个 $n$ 个节点 $m$ 条无向边的图，请输出其点双连通分量的个数，并且输出每个点双连通分量。

## 说明/提示

**样例四解释：**

![](https://cdn.luogu.com.cn/upload/image_hosting/huvwgbuo.png)

相同颜色的点为同一个分量里的结点。

**温馨提示：请认真考虑孤立点与自环（样例五）的情况。**

------------
**数据范围：**
对于 $100\%$ 的数据，$1 \le n \le 5 \times10 ^5$，$1 \le m \le 2 \times 10^6$。

| subtask | $n$ | $m$ | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $1 \le n \le 100$ | $1 \le m \le 500$ | $25$ |
| $2$ | $1 \le n \le 5000$ | $1 \le m \le 5 \times 10^4$ | $25$ |
| $3$ | $1 \le n \le 2\times 10^5$ | $1 \le m \le 5\times 10^5$ | $25$ |
| $4$ | $1 \le n \le 5 \times10 ^5$ | $1 \le m \le 2 \times 10^6$ | $25$ |

本题不卡常，时间限制与空间限制均已开大，正确的解法均可通过。

------------

### 数据更新
- $2022/7/14$ 加强数据
- $2022/11/26$  新增 $10$ 组较小的数据（$1\le n, m \le 10$)，方便选手调试。
- $2022/12/31$ 重组 $subtask$，并加入若干组极端数据。
- $2023/1/1$ 发现昨天新加入的数据出了问题，已修改。
------------

惊喜：AC 后记得把鼠标放到测试点上看反馈信息，有惊喜哦。

## 样例 #1

### 输入

```
5 8
1 3
2 4
4 3
1 2
4 5
5 1
2 4
1 1```

### 输出

```
1
5 1 2 3 4 5```

## 样例 #2

### 输入

```
5 3
1 2
2 3
1 3```

### 输出

```
3
1 4
1 5
3 1 2 3```

## 样例 #3

### 输入

```
6 5
1 3
2 4
1 2
4 6
2 3```

### 输出

```
4
2 6 4
2 4 2
3 3 2 1
1 5```

## 样例 #4

### 输入

```
7 8
1 3
2 4
3 5
2 5
6 4
2 5
6 3
2 7```

### 输出

```
3
2 7 2
5 5 2 4 6 3
2 3 1```

## 样例 #5

### 输入

```
1 1
1 1```

### 输出

```
1
1 1```

# AI分析结果

### 综合分析与结论
这些题解均围绕点双连通分量展开，核心算法都是 Tarjan 算法。各题解先介绍割点、点双连通分量等概念，再阐述 Tarjan 算法的原理，最后给出求点双连通分量的具体实现。在实现过程中，利用栈来辅助记录和划分点双连通分量，同时注意处理孤立点和自环等特殊情况。不同题解在概念解释的详细程度、代码风格和注释等方面存在差异，但整体思路和方法一致。

### 所选题解
- **作者：Usada_Pekora（5星）**
  - **关键亮点**：概念解释详细，配有直观的图示帮助理解，代码注释清晰，逻辑完整，对特殊情况（如孤立点）的处理有明确说明。
- **作者：Jeremiahy（4星）**
  - **关键亮点**：对 Tarjan 算法的相关概念（如时间戳、追溯值等）解释透彻，有详细的证明过程，代码结构清晰，还给出了相关练习题目。
- **作者：HHH6666666666（4星）**
  - **关键亮点**：通过模拟图的搜索过程，详细展示了 `dfn` 和 `low` 数组的更新过程，代码实现简洁，有自定义的快速读入输出函数。

### 重点代码
#### Usada_Pekora 的核心代码
```cpp
inline void tarjan(int u, int fa) {
    int son = 0;
    low[u] = dfn[u] = ++idx;
    s[++top] = u;
    for(int i = fir[u]; i; i = nxt[i]) {
        int v = to[i];
        if(!dfn[v]) {
            son++;
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] >= dfn[u]) {
                bcc++;
                while(s[top + 1] != v) ans[bcc].push_back(s[top--]);
                ans[bcc].push_back(u);
            }
        } else if(v != fa) low[u] = min(low[u], dfn[v]);
    }
    if(fa == 0 && son == 0) ans[++bcc].push_back(u);
}
```
**核心思想**：在 Tarjan 算法的深度优先搜索过程中，用 `dfn` 记录时间戳，`low` 记录可回溯的最小时间戳。当 `low[v] >= dfn[u]` 时，说明找到了一个点双连通分量，将栈中元素弹出直到遇到 `v`，并将 `u` 加入该点双。对于孤立点，单独处理。

#### Jeremiahy 的核心代码
```cpp
void tarjan(int x) { 
    dfn[x] = low[x] = ++num;
    stack[++top] = x;
    if (x == root && head[x] == 0) {
        dcc[++cnt].push_back(x);
        return;
    }
    int flag = 0;
    for (int i = head[x]; i; i = Next[i]) {
        int y = ver[i];
        if (!dfn[y]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
            if (low[y] >= dfn[x]) {
                flag++;
                if (x != root || flag > 1)
                    cut[x] = true;
                cnt++;
                int z;
                do {
                    z = stack[top--];
                    dcc[cnt].push_back(z);
                } while (z != y);
                dcc[cnt].push_back(x);
            }
        } 
        else
            low[x] = min(low[x], dfn[y]);
    }
}
```
**核心思想**：同样使用 Tarjan 算法，在搜索过程中更新 `dfn` 和 `low` 数组。当满足 `low[y] >= dfn[x]` 时，判断 `x` 是否为割点，并将栈中元素弹出直到遇到 `y`，将这些元素和 `x` 组成一个点双连通分量。对于孤立点，单独添加到点双中。

#### HHH6666666666 的核心代码
```cpp
void Tarjan(int x, int from){
    dfn[x] = low[x] = ++timecnt;
    s.push(x);
    int child = 0;
    int p;
    for (int i = head[x]; i; i = nxt[i]){
        if (i == (from ^ 1)) continue;
        child++;
        int y = to[i];
        if (!dfn[y]){
            Tarjan(y, i);
            low[x] = min(low[x], low[y]);
            if (low[y] >= dfn[x]){
                ++vdcc_cnt;
                do{
                    p = s.top(); s.pop();
                    vdcc[vdcc_cnt].push_back(p);
                } while (p != y);
                vdcc[vdcc_cnt].push_back(x);
            }
        }
        low[x] = min(low[x], dfn[y]);
    }
    if (!child && !from)
        vdcc[++vdcc_cnt].push_back(x);
    return;
}
```
**核心思想**：利用 Tarjan 算法进行深度优先搜索，更新 `dfn` 和 `low` 数组。当 `low[y] >= dfn[x]` 时，将栈中元素弹出直到遇到 `y`，并将 `x` 加入，形成一个点双连通分量。对于孤立点，单独处理。

### 最优关键思路或技巧
- **Tarjan 算法**：利用 `dfn` 记录时间戳，`low` 记录可回溯的最小时间戳，通过比较 `low[v]` 和 `dfn[u]` 来判断割点和点双连通分量。
- **栈的使用**：在深度优先搜索过程中，将遍历到的点压入栈中，当找到割点时，通过弹栈操作得到一个点双连通分量。
- **特殊情况处理**：注意处理孤立点和自环，在代码中对这些情况进行特判。

### 可拓展之处
同类型题目或类似算法套路包括：
- **边双连通分量**：与点双连通分量类似，边双连通分量是指无向图中极大的不包含割边的连通子图，可使用类似的 Tarjan 算法求解。
- **有向图的强连通分量**：有向图中，强连通分量是指任意两点都相互可达的极大子图，可使用 Kosaraju 算法或 Tarjan 算法求解。

### 推荐题目
1. [P3388 割点](https://www.luogu.com.cn/problem/P3388)：考察割点的求解，是点双连通分量的前置知识。
2. [P3469 [POI2008]BLO-Blockade](https://www.luogu.com.cn/problem/P3469)：与割点相关的应用题目，可加深对割点概念的理解。
3. [P8436 【模板】边双连通分量](https://www.luogu.com.cn/problem/P8436)：考察边双连通分量的求解，与点双连通分量有相似之处。

### 个人心得
部分题解提到要认真考虑孤立点与自环的情况，在代码实现中需要对这些特殊情况进行特判，否则可能导致结果错误。例如，在判断根节点是否为割点时，要考虑其是否有多个子树；对于孤立点，要单独将其作为一个点双连通分量处理。 

---
处理用时：44.92秒
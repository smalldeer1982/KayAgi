# 题目信息

# 【模板】边双连通分量

## 题目描述

对于一个 $n$ 个节点 $m$ 条无向边的图，请输出其边双连通分量的个数，并且输出每个边双连通分量。

## 说明/提示

**样例四解释：**

![](https://cdn.luogu.com.cn/upload/image_hosting/0bzdfzeq.png)

相同颜色的点为同一个连通分量。


------------

**数据范围：**
对于 $100\%$ 的数据，$1 \le n \le 5 \times10 ^5$，$1 \le m \le 2 \times 10^6$。

| subtask | $n$ | $m$ | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $1 \le n \le 100$ | $1 \le m \le 500$ | $25$ |
| $2$ | $1 \le n \le 5000$ | $1 \le m \le 5 \times 10^4$ | $25$ |
| $3$ | $1 \le n \le 2\times 10^5$ | $1 \le m \le 5\times 10^5$ | $25$ |
| $4$ | $1 \le n \le 5 \times10 ^5$ | $1 \le m \le 2 \times 10^6$ | $25$ |

### 数据更新
- $2022/7/14$ 加强数据
- $2022/11/26$  新增 $10$ 组较小的数据（$1\le n, m \le 10$)，方便选手调试。
- $2022/12/31$ 重组 $subtask$，并加入若干组极端数据。
- $2023/1/1$ 发现昨天新加入的数据数据出了问题，已修改。
------------

本题不卡常，时间限制与空间限制均已开大，正确的解法均可通过。


------------

惊喜：AC 后记得把鼠标放到测试点上看反馈信息，有惊喜哦。

## 样例 #1

### 输入

```
5 8
1 3
2 4
4 3
1 2
4 5
5 1
2 4
1 1```

### 输出

```
1
5 1 5 4 2 3```

## 样例 #2

### 输入

```
5 3
1 2
2 3
1 3```

### 输出

```
3
3 1 3 2
1 4
1 5```

## 样例 #3

### 输入

```
6 5
1 3
2 4
1 2
4 6
2 3```

### 输出

```
4
3 1 2 3
1 4
1 5
1 6```

## 样例 #4

### 输入

```
7 8
1 3
2 4
3 5
2 5
6 4
2 5
6 3
2 7```

### 输出

```
3
1 1
5 2 5 3 6 4
1 7```

# AI分析结果

### 综合分析与结论
这些题解主要围绕边双连通分量的求解展开，核心思路大多是先找出图中的割边（桥），再通过去掉割边来划分边双连通分量，部分题解也采用了直接在 Tarjan 算法中求解边双的方法。

### 所选题解
- 作者：郑朝曦zzx (赞：134)，4星
  - 关键亮点：思路清晰，详细介绍了割边和边双连通分量的求法，代码注释详细，还给出了常见错误提示。
  - 个人心得：提醒注意图可能有重边，需用合适的存图方式；对于数据中存在某些分量只存在一个点且分量很多的情况，建议使用二维 vector。
- 作者：rainygame (赞：129)，4星
  - 关键亮点：使用 vector 存图，适合不会链式前向星的读者，对思路的解释详细，通过不断优化代码解决了重边问题。
  - 个人心得：最初代码只能拿 50 分，通过下载数据发现是重边问题，进而改进代码，将判断条件从顶点改为边，最终 AC。
- 作者：Jeremiahy (赞：30)，4星
  - 关键亮点：概念讲解清晰，对边双连通分量的定义和定理有详细说明，代码实现规范。
  - 个人心得：无。

### 重点代码及核心思想
#### 郑朝曦zzx 的代码
```cpp
// 求割边
void tarjan(int node, int in_edge)
{
    dfn[node] = low[node] = ++id;
    for (int i = head[node]; i; i = e[i].nxt)
    {
        const int to = e[i].to;
        if (dfn[to] == 0)
        {
            tarjan(to, i);
            if (dfn[node] < low[to])
                b[i] = b[i ^ 1] = 1;
            low[node] = min(low[node], low[to]);
        }
        else if (i != (in_edge ^ 1))
            low[node] = min(low[node], dfn[to]);
    }
}
// 分离边双连通分量
void dfs(int node, int ndcc)
{
    dcc[node] = ndcc;
    Ans[ndcc - 1].push_back(node);
    for (int i = head[node]; i; i = e[i].nxt)
    {
        int to = e[i].to;
        if (dcc[to] || b[i]) continue;
        dfs(to, ndcc);
    }
}
```
核心思想：先使用 Tarjan 算法标记出所有割边，再通过 dfs 遍历图，遇到割边就停止搜索，从而分离出边双连通分量。

#### rainygame 的代码
```cpp
void tarjan(int x, int las){
    low[x] = dfn[x] = ++cnt;
    st.push(x);
    for (auto i: e[x]){
        if (i.second == (las ^ 1)) continue;
        if (!dfn[i.first]){
            tarjan(i.first, i.second);
            low[x] = min(low[x], low[i.first]);
        }else low[x] = min(low[x], dfn[i.first]);
    }
    if (dfn[x] == low[x]){
        vector<int> vec;
        vec.push_back(x);
        while (st.top() != x){
            vec.push_back(st.top());
            st.pop();
        }
        st.pop();
        ans.push_back(vec);
    }
}
```
核心思想：在 Tarjan 算法的基础上，通过判断边的编号避免访问上一次走过的边，当 `dfn[x] == low[x]` 时，将栈中的元素弹出作为一个边双连通分量。

#### Jeremiahy 的代码
```cpp
void tarjan(int x, int in_edge) { //求割边
    dfn[x] = low[x] = ++num;
    for (int i = head[x]; i; i = Next[i]) {
        int y = ver[i];
        if (!dfn[y]) {
            tarjan(y, i);
            low[x] = min(low[x], low[y]);
            if (low[y] > dfn[x])
                bridge[i] = bridge[i ^ 1] = true;
        }
        else if (i != (in_edge ^ 1))
            low[x] = min(low[x], dfn[y]);
    }
}
void dfs(int x) {
    c[x] = dcc;
    if (x) //防止加入 0
        ans[dcc].push_back(x); 
    for (int i = head[x]; i; i = Next[i]) {
        int y = ver[i];
        if (c[y] || bridge[i]) continue;
        dfs(y);
    }
}
```
核心思想：先使用 Tarjan 算法标记割边，再通过 dfs 遍历图，跳过割边，将节点划分到不同的边双连通分量中。

### 最优关键思路或技巧
- **Tarjan 算法**：是求解割边和边双连通分量的核心算法，通过 `dfn` 和 `low` 数组来判断割边。
- **边的编号技巧**：建图时边的编号从 2 开始，利用异或运算可以快速求出某边的逆向边。
- **避免重边影响**：在遍历边时，通过判断边的编号或记录上一次走过的边来避免重边的影响。

### 可拓展之处
同类型题或类似算法套路：
- **点双连通分量**：与边双连通分量类似，但判断条件和求解方法有所不同，可参考相关题目进行练习。
- **强连通分量**：在有向图中求解强连通分量，可使用 Tarjan 算法或 Kosaraju 算法。
- **2 - SAT 问题**：可以将问题转化为图论问题，通过求解强连通分量来解决。

### 推荐题目
- [P8435 【模板】点双连通分量](https://www.luogu.com.cn/problem/P8435)
- [P2860 [USACO06JAN]Redundant Paths G](https://www.luogu.com.cn/problem/P2860)
- [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

### 个人心得总结
- 注意图中可能存在重边，需用合适的存图方式和判断条件来避免重边对结果的影响。
- 对于数据中存在某些分量只存在一个点且分量很多的情况，建议使用二维 vector 来存储结果。
- 当代码出现问题时，可以通过下载数据进行调试，找出问题所在并进行优化。

---
处理用时：41.35秒
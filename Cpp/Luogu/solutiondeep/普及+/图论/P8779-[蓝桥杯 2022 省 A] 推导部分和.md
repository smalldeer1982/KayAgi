# 题目信息

# [蓝桥杯 2022 省 A] 推导部分和

## 题目描述

对于一个长度为 $N$ 的整数数列 $A_{1}, A_{2}, \cdots A_{N}$，小蓝想知道下标 $l$ 到 $r$ 的部分和 $\sum\limits_{i=l}^{r}A_i=A_{l}+A_{l+1}+\cdots+A_{r}$ 是多少?

然而，小蓝并不知道数列中每个数的值是多少，他只知道它的 $M$ 个部分和的值。其中第 $i$ 个部分和是下标 $l_{i}$ 到 $r_{i}$ 的部分和 $\sum_{j=l_{i}}^{r_{i}}=A_{l_{i}}+A_{l_{i}+1}+\cdots+A_{r_{i}}$, 值是 $S_{i}$ 。

## 说明/提示

对于 $10 \%$ 的评测用例, $1 \leq N, M, Q \leq 10,-100 \leq S_{i} \leq 100$ 。

对于 $20 \%$ 的评测用例, $1 \leq N, M, Q \leq 20,-1000 \leq S_{i} \leq 1000$ 。

对于 $30 \%$ 的评测用例, $1 \leq N, M, Q \leq 50,-10000 \leq S_{i} \leq 10000$ 。

对于 $40 \%$ 的评测用例, $1 \leq N, M, Q \leq 1000,-10^{6} \leq S_{i} \leq 10^{6}$ 。

对于 $60 \%$ 的评测用例, $1 \leq N, M, Q \leq 10000,-10^{9} \leq S_{i} \leq 10^{9}$ 。

对于所有评测用例, $1 \leq N, M, Q \leq 10^{5},-10^{12} \leq S_{i} \leq 10^{12}, 1 \leq l_{i} \leq r_{i} \leq N$, $1 \leq l \leq r \leq N$ 。数据保证没有矛盾。

蓝桥杯 2022 省赛 A 组 J 题。

## 样例 #1

### 输入

```
5 3 3
1 5 15
4 5 9
2 3 5
1 5
1 3
1 2```

### 输出

```
15
6
UNKNOWN```

# AI分析结果

### 综合分析与结论
这些题解主要围绕利用前缀和将区间和问题转化为点权差问题，再通过建图或带权并查集解决。建图方法是对已知区间 $[l, r]$ 连边 $(l - 1, r)$ 和 $(r, l - 1)$，边权分别为区间和 $S$ 与 $-S$，通过 DFS 维护连通信息判断能否求解及计算区间和；带权并查集则是维护节点到根节点的距离，合并集合时更新距离，根据根节点是否相同判断能否求解，用距离差计算区间和。

### 所选题解
- **作者：loser_seele（5星）**
    - **关键亮点**：思路清晰，详细阐述了将问题转化为图的连通性问题，利用并查集维护连通性和节点到根节点的距离，代码简洁且注释清晰。
    - **核心代码**：
```cpp
int find(int x)
{
    if(par[x]==x) 
        return x;
    else
    {
        int root=find(par[x]);
        val[x]+=val[par[x]];
        return par[x]=root;
    }
}
//...
for(int i=1,a,b,s;i<=m;i++)
{
    scanf("%lld%lld%lld",&a,&b,&s); 
    a--;
    int t1=find(a),t2=find(b);
    if(t1!=t2)
    {
        par[t2]=t1;
        val[t2]=-val[b]+s+val[a];
    }
}
```
核心思想：`find` 函数进行路径压缩并更新节点到根节点的距离；在合并集合时，根据已知区间和更新根节点的距离。
- **作者：technopolis_2085（4星）**
    - **关键亮点**：同样使用带权并查集，对合并集合时更新距离的公式有详细推导和图示说明，有助于理解。
    - **核心代码**：
```cpp
int find(int x)
{
    if (fa[x]==x) return fa[x];
    int t=find(fa[x]);
    sum[x]+=sum[fa[x]];
    fa[x]=t;
    return fa[x];
}
//...
while (m--)
{
    int l,r,x;
    scanf("%lld%lld%lld",&l,&r,&x);
    l--;
    int fl=find(l),fr=find(r);
    if (fl!=fr)
    {
        fa[fl]=fr;
        sum[fl]=-x-sum[l]+sum[r];
    }
}
```
核心思想：`find` 函数更新节点到根节点的距离；合并集合时，根据前缀和关系更新根节点的距离。
- **作者：hj23308（4星）**
    - **关键亮点**：采用建图和 DFS 的方法，思路简洁，代码实现清晰，时空复杂度分析明确。
    - **核心代码**：
```cpp
void dfs(int u) { 
    for (auto [v, w]: edges[u]) 
        if (!col[v]) 
            s[v] = s[u] + w, col[v] = col[u], dfs(v); 
}
//...
while (m--) {
    int l, r;
    long long t;
    cin >> l >> r >> t, l--;
    edges[l].emplace_back(r, t);
    edges[r].emplace_back(l, -t);
}
while (q--) {
    int l, r;
    cin >> l >> r, l--;
    if (!col[l]) col[l] = ++tot, dfs(l);
    if (col[l] == col[r]) cout << s[r] - s[l] << '\n';
    else cout << "UNKNOWN\n";
}
```
核心思想：`dfs` 函数用于遍历图，更新节点的前缀和值和连通块编号；对于每个询问，若节点不在同一连通块则无解，否则输出前缀和差值。

### 最优关键思路或技巧
- **前缀和转化**：将区间和问题转化为前缀和的点权差问题，简化问题模型。
- **建图与连通性判断**：通过建图表示已知区间和信息，利用 DFS 或并查集判断节点连通性，确定能否求解区间和。
- **带权并查集**：维护节点到根节点的距离，在合并集合时更新距离，方便计算区间和。

### 拓展思路
同类型题可考虑增加区间修改操作，或要求判断信息是否矛盾，可使用差分约束系统解决。类似算法套路还有利用图论和并查集解决连通性和路径权值问题。

### 推荐题目
- [P1196 银河英雄传说](https://www.luogu.com.cn/problem/P1196)
- [AT_abc238_e Range Sums](https://www.luogu.com.cn/problem/AT_abc238_e)
- [hdu3038 How Many Answers Are Wrong](http://acm.hdu.edu.cn/showproblem.php?pid=3038)

### 个人心得
部分题解提到本题是两个绿题的缝合，暗示了在解题时可将复杂问题拆解为熟悉的子问题，有助于找到解题思路。 

---
处理用时：32.61秒
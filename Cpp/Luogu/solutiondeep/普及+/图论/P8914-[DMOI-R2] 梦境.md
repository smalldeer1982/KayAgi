# 题目信息

# [DMOI-R2] 梦境

## 题目背景

小 A 做噩梦了。

## 题目描述

小 A 的梦境可以看做有 $n$ 个点，$m$ 条边的无向图。小 A 在图上的点 $S$，有一个怪物在点 $B$，安全屋在点 $F$。

怪物正在追杀小 A，现在小 A 需要逃到安全屋。小 A 意识到这是在自己的梦境里，所以他在一定程度上操控了梦境。他把怪物的移动速度设置成了 $3$，但代价是自己的移动速度被设置成 $2$。

小 A 始终会沿着到 $F$ 的最短路走，如果有多条最短路，则小 A 会选择使得**经过点的编号所顺次构成序列的字典序最小**的那条最短路，因为他觉得这样走最不容易被怪物抓到。

而怪物在梦境中游荡，会随机向自身周围的点移动，且怪物已经访问过的点不会重复访问。

现在小 A 需要知道**在最坏情况下**他能否安全到达安全屋，或者何时被怪物抓住。

## 说明/提示

**关于最坏情况的解释**：怪物的走法可能有多种。也就是说，你需要同时考虑怪物的每种走法，只要怪物的某种最短路走法可以抓到小 A 时答案即为 `NO`。而最坏情况是指怪物的走法在所有走法中能够最快抓到（或接近）小 A 的情况。

另外本题没有 special judge，也就是说如果答案是整数，你需要严格输出整数答案，不带小数点。同时数据保证不存在小数位数超过两位的答案。

### 数据范围

本题采用捆绑测试。

$$
\def{\arraystretch}{1.5}
\begin{array}{c|c|c|c|c}\hline 
\textbf{~~Subtask~~}&\bm{~~n \le ~~}&\bm{~~~~m \le~~~~}& ~\textbf{~~特殊性质~~}~&\textbf{~~分值~~}\cr\hline 
0	&10			&20			&		&10\cr\hline 
1	&500		&1000		&		&10\cr\hline 
2	&800 		&2000		&		&10\cr\hline 
3	&2\times10^5&  			&\text{A+B}&15	\cr\hline 
4	&2\times10^5& 			&\text{A}&15	\cr\hline
5	&10^5		&2\times10^5&		&20\cr\hline
6	&2\times10^5&2\times10^5&		&20
\end{array}
$$

特殊性质 $\text{A}$：$m=n-1$。

特殊性质 $\text{B}$：对于给定的每个 $v_i$，满足 $v_i=u_i+1$。

对于 $100\%$ 的数据，保证 $S \ne B \ne F$ 且 $1 \le S,B,F \le n$，$1 \le w_i \le 10^3$，图连通且不存在重边。

### 特殊评分方式
本题开启子任务依赖，具体如下：
- 对于子任务 $i\in\{0,3\}$，您只需答对子任务 $i$ 即可获得子任务 $i$ 的分数。
- 对于子任务 $4$，您需要答对子任务 $3$ 才能获得子任务 $4$ 的分数。
- 对于子任务 $i\in\{1,2,5,6\}$，您需要答对子任务 $0$ 才能获得子任务 $i$ 的分数。

### 附件说明
对于赛时许多选手卡在了 sub3，此处提供一组 sub3 内的数据用于检查并改正代码。

## 样例 #1

### 输入

```
4 3 1 2 3
1 3 1
2 4 2
4 3 1```

### 输出

```
YES
1.5```

## 样例 #2

### 输入

```
4 3 1 2 3
1 3 2
2 4 2
4 3 1```

### 输出

```
NO
1```

# AI分析结果

### 综合分析与结论
这些题解围绕小 A 在图中躲避怪物的问题展开，核心思路是先求出小 A 到安全屋的字典序最小的最短路径，再计算怪物到路径上各点的最短时间，通过比较两者时间判断小 A 是否能安全到达安全屋。各题解在实现细节和优化方法上有所不同，但都涉及到最短路算法（如 Dijkstra）的运用，同时都关注到了字典序最小路径的求解、最坏情况的判断以及小数精度处理等难点。

### 所选题解
- **作者：ande (赞：5)，4星**
    - **关键亮点**：思路清晰，详细解释了倒搜求字典序最小路径的原因，并给出了具体代码实现。对相遇和追击情况的分类讨论明确，还解决了小数精度问题。
    - **个人心得**：赛时卡在怪兽能在边上抓到小 A 这个条件上，后来看赛时答疑才发现。使用 `cout` 输出时因默认保留 6 位有效数字，多余位数用科学记数法表示，通过 `cout.precision(15)` 修改精度解决问题。
- **作者：_shy (赞：2)，4星**
    - **关键亮点**：通过举反例清晰地说明了正着跑 Dijkstra 求字典序最小路径的错误，给出了正确的倒搜方法及代码。对最坏情况的分析和处理逻辑严谨，详细介绍了小数精度补足的方法。
    - **个人心得**：交代码后发现每个 subtask 都有错，原因是精度损失，通过加上 `eps = 1e - 3` 补足精度解决问题。
- **作者：OneStar (赞：1)，4星**
    - **关键亮点**：不仅详细介绍了求字典序最小路径的方法，还提出了用二分优化遍历过程的思路，并给出了严格的数学证明。代码实现规范，对不同情况的处理逻辑清晰。

### 重点代码及核心思想
#### ande 的题解
```cpp
// Dijkstra 求最短路并记录路径
while ( !pq.empty() ) {
    P p = pq.top();
    pq.pop();
    int now = p.second;
    if ( mp[now] == 1 ) continue;
    mp[now] = 1;
    for ( int i = head[now]; i; i = edge[i].next ) {
        int to_ = edge[i].to, val = edge[i].val;
        if ( dis1[now] + val == dis1[to_] )
            pa[to_] = min( pa[to_], now );//字典序最小
        else if ( dis1[to_] > dis1[now] + val ) {
            dis1[to_] = dis1[now] + val;
            pa[to_] = now;//优先最短路径
            pq.push( { dis1[to_], to_ } );
        }
    }
}
```
**核心思想**：使用 Dijkstra 算法求最短路，在更新距离时，若距离相等则取编号小的点作为前驱，保证字典序最小；若距离更优则直接更新前驱。

#### _shy 的题解
```cpp
// Dijkstra 求最短路并记录路径
while (!q.empty ()) {
    int u = q.top ().pos;
    q.pop ();
    if (vis[u]) continue;
    vis[u] = 1;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].v, w = e[i].w;
        if (vis[v]) continue;
        if (dis[tp][v] > dis[tp][u] + w) {
            dis[tp][v] = dis[tp][u] + w;
            q.push ((node) {v, dis[tp][v]});
            if (tp == 0)
                path[v] = u;
        }
        else if (tp == 0 && dis[tp][v] == dis[tp][u] + w) 
            path[v] = min (path[v], u);
    } 
}
```
**核心思想**：同样使用 Dijkstra 算法，在更新距离时，若距离更优则更新路径；若距离相等且是求路径的 Dijkstra，则取编号小的点作为前驱。

#### OneStar 的题解
```cpp
// 二分查找最早的怪物到达时间小于等于小 A 到达时间的点
db Find(int l,int r){ 
    while(l<r){
        int mid=(l+r+1)>>1;
        if(path[mid].t*3>dis[path[mid].u]) r=mid-1;
        else l=mid;
    }
    int x=l; 
    if(path[x].t*3==dis[path[x].u]) return path[x].t;//怪物与小A在点x相遇
    if(path[cnt].t*3<dis[f]) return 0; //怪物不会遇到小A
    return min(/*怪物从x追上小A*/dis[path[x].u]-path[x].t*2,/*怪物从y与小A相遇*/(path[x+1].t*2+dis[path[x+1].u])/5);
}
```
**核心思想**：利用二分查找在小 A 走的路径上找到最早的怪物到达时间小于等于小 A 到达时间的点，然后根据不同情况计算相遇时间。

### 最优关键思路或技巧
- **倒搜求字典序最小路径**：从终点开始跑 Dijkstra 算法，利用堆的特性可以得到字典序最小的最短路径，避免了正着跑可能出现的部分最优而非整体最优的问题。
- **小数精度处理**：使用 `cout.precision(15)` 或加上一个小的 `eps` 值（如 `1e - 3`）来解决小数精度问题，确保输出结果符合要求。
- **二分优化**：在遍历小 A 走的路径时，通过证明怪物与小 A 到达各点的时间差单调递增，利用二分查找可以更快地找到最早的怪物到达时间小于等于小 A 到达时间的点。

### 可拓展之处
同类型题或类似算法套路：
- **多源最短路问题**：本题只涉及到小 A 和怪物两个点的最短路计算，可拓展到多个起点或终点的情况，使用 Floyd 等算法求解。
- **动态规划与最短路结合**：在图中加入一些动态变化的因素，如边权随时间变化，需要结合动态规划的思想来求解最优路径。
- **图的连通性与最短路**：当图不连通时，需要先判断小 A、怪物和安全屋是否在同一个连通分量中，再进行最短路计算。

### 推荐题目
- [P1339 [USACO09OCT]Heat Wave G](https://www.luogu.com.cn/problem/P1339)：基础的单源最短路问题，可用于练习 Dijkstra 算法。
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：标准的单源最短路模板题，可巩固 Dijkstra 算法的实现。
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：在求最短路的基础上，统计最短路的数量，增加了问题的复杂度。

---
处理用时：43.68秒
# 题目信息

# 『GROI-R1』 一切都已过去

## 题目背景

悦关上窗，拉上帘布。

果然还是想不起来啊。

隐约记得曾和什么人一起做过这样的事。

仰面躺下，手执一只木笺。

「究竟如何，才能拥有“过去”啊……」

她闭上双眼。

「6 岁前的记忆……究竟如何才能寻回？」

## 题目描述

悦正在寻找她的记忆。忽然，她来到了有 $n$ 个节点的一棵树上。树上每一条边都有各自边权，每一个点都有各自的点权。

「把经历都聚拢起来，能完整地复原吗……」

悦从树上的一个点，慢慢地走到了另一个点，可是她什么也没找到。但是，她不知道，玘一直在远处望着她走过的道路。

玘发现，悦全程****没有走回头路****。他想把悦****走过的每一条边的边权乘起来****，可惜他发现他遇到了一个这一生未曾见到过的数字。

「为什么会这样呢？」

玘想到悦是突然出现在树上的，最初的点一定有蹊跷！他****把最初那个点的点权乘上****……

突然，一束彼岸花的红光亮起！世界重新安静了下来。

悦看到了玘留下的字样，可惜她不能从中看出任何过去的记忆。现在，你要帮她判断：把经历都聚拢起来，****能完整地复原过去吗****？我们称悦的一条路径能“复原过去”，当且仅当玘****留下的乘积是一个整数****。

**形式化题面**

给定一棵 $n$ 个节点的树和 $q$ 次询问。每次询问给出两个整数 $x,y$，表示询问树上以 $x$ 和 $y$ 为端点的简单路径上边权乘积与点 $x$ 的点权相乘是否为整数。

## 说明/提示

**样例解释**

根据输入可以得到下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3e4jqu6f.png)

对于第一个询问 $(1,5)$ 可以发现悦经过的边的边权分别是 $0.1$ 和 $0.99$，她出发的 $1$ 号点的点权为 $1$。$1\times0.1\times0.99=0.099$ 不是整数。所以输出 `No`。

对于后面两次询问同理。

**数据范围**

**本题采用捆绑测试。**

| 子任务编号 | 数据范围 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $\text{Subtask1}$ | $n,q\le3\times 10^3$ |  | $15$ |
| $\text{Subtask2}$ | $n\le500$，$q\le10^5$ |  | $10$ |
| $\text{Subtask3}$ | $n,q\le10^5$ | $\text{BE}$ | $10$ |
| $\text{Subtask4}$ | $n,q\le10^5$ | $\text{A}$ | $5$ |
| $\text{Subtask5}$ | $n,q\le10^5$ | $\text{B}$ | $10$ |
| $\text{Subtask6}$ | $n,q\le10^5$ | $\text{C}$ | $5$ |
| $\text{Subtask7}$ | $n,q\le10^5$ | $\text{D}$ | $10$ |
| $\text{Subtask8}$ | $n,q\le2×10^5$ |  | $35$ |

特殊性质 $\text{A}$：保证树退化成一条链。

特殊性质 $\text{B}$：保证树随机生成（即对于每一个节点随机选择它的父亲节点）。

特殊性质 $\text{C}$：保证 $w\in\{0.1,0.3,0.5,0.7,0.9\}$。

特殊性质 $\text{D}$：保证 $w\in\{0.1,0.2,0.3,0.4,0.6,0.7,0.8,0.9\}$。

特殊性质 $\text{E}$：保证 $w\le2$ 且 $w$ 小数位数不超过 $1$ 位。

对于 $100\%$ 的数据满足 $1\le n,q\le2\times10^5$，$0\le a_i\le10^9$，$0\le w\le10^4$，$1\le u,v,x,y\le n$，$x\ne y$，$w$ 小数位数不超过 $4$ 位。

## 样例 #1

### 输入

```
5 3
1 2 3 4 5
1 2 0.1
2 3 0.20
3 4 0.5
2 5 0.99
1 5
1 4
4 3```

### 输出

```
No
No
Yes```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是将小数乘法问题转化为对因数 2 和 5 的个数统计问题，利用最近公共祖先（LCA）算法来计算路径上的相关信息，从而判断路径上边权乘积与起点点权的乘积是否为整数。各题解在实现细节上略有不同，但整体思路一致。主要的算法要点包括将边权和点权转化为整数、统计因数 2 和 5 的个数、使用 LCA 计算路径信息以及特判权值为 0 的情况。解决的难点在于处理浮点数运算、避免数据溢出以及处理特殊情况（如权值为 0）。

### 所选题解
- **作者：迟暮天复明（5 星）**
  - 关键亮点：思路清晰，对问题的分析透彻，直接点明问题的核心在于判断分子中因数 2 和 5 的个数是否分别大于或等于分母中因数 2 和 5 的个数，且对特判情况的处理说明明确。
- **作者：Stars_visitor_tyw（4 星）**
  - 关键亮点：代码实现规范，注释详细，对每个步骤的解释清晰，包括如何统计小数点位数、因数 2 和 5 的个数以及如何使用 LCA 计算路径信息。
- **作者：masonpop（4 星）**
  - 关键亮点：分享了自己的踩坑经历，对可能出现的问题进行了详细说明，如统计幂次函数出错和没有特判权值为 0 的情况，对读者有很好的借鉴作用。

### 重点代码及核心实现思想
#### 迟暮天复明
核心思路：将边权和点权表示成 $2^p\times 5^q \times k$ 的形式，计算各自的 $p$ 与 $q$ 的值，通过深度优先遍历计算 $f$ 数组（从根节点到节点 $i$ 的 $\sum p$）和 $g$ 数组（从根节点到节点 $i$ 的 $\sum q$），利用 LCA 计算路径上的 $\sum p$ 和 $\sum q$，判断是否满足 $\sum p\ge 0$ 且 $\sum q\ge 0$。

#### Stars_visitor_tyw
```cpp
int count_two(int x)
{
    if(x==0)
    {
        return inf;
    }
    int cnt=0;
    while(x!=0&&x%2==0)
    {
        cnt++;
        x/=2;
    }
    return cnt;
}
int count_five(int x)
{
    if(x==0)
    {
        return inf;
    }
    int cnt=0;
    while(x!=0&&x%5==0)
    {
        cnt++;
        x/=5;
    }
    return cnt;
}
void pre_lca(int cur, int fa)
{
    dp[cur][0]=fa;
    dep[cur]=dep[fa]+1;
    for(int i=1;(1<<i)<=dep[cur];i++)
    {
        dp[cur][i]=dp[dp[cur][i-1]][i-1];
    }
    for(auto i:nbr[cur])
    {
        int nxt=i.y;
        if(nxt!=fa)
        {
            dis[nxt]=dis[cur]+i.dlp,cnt2[nxt]=cnt2[cur]+count_two(i.w),cnt5[nxt]=cnt5[cur]+count_five(i.w);
            pre_lca(nxt,cur);
        }
    }
}
```
核心实现思想：通过 `count_two` 和 `count_five` 函数统计因数 2 和 5 的个数，使用 `pre_lca` 函数进行 LCA 预处理，同时计算从根节点到每个节点的小数点位数、因数 2 和 5 的个数。

#### masonpop
```cpp
inline int calc2(int x)//2的幂次
{
    int cal=0;
    while(x && x%2==0)cal++,x/=2;
    return cal;	
} 
inline int calc5(int x)//5的幂次
{
    int cal=0;
    while(x && x%5==0)cal++,x/=5;
    return cal;	
} 
inline void dfs(int x,int f)
{
    dep[x]=dep[f]+1;
    fa[x][0]=f;
    for(int i=1;(1<<i)<=dep[x];i++)
    {
        fa[x][i]=fa[fa[x][i-1]][i-1];
    }
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==f)continue;
        sum[y]=sum[x]+cnt[i];
        two[y]=two[x]+calc2(ver[i]);
        five[y]=five[x]+calc5(ver[i]);
        zero[y]=zero[x]+(ver[i]==0);
        dfs(y,x);
    }
}
```
核心实现思想：通过 `calc2` 和 `calc5` 函数统计因数 2 和 5 的个数，使用 `dfs` 函数进行 LCA 预处理，同时计算从根节点到每个节点的小数点位数、因数 2 和 5 的个数以及边权为 0 的个数。

### 最优关键思路或技巧
- **转化思想**：将小数乘法问题转化为对因数 2 和 5 的个数统计问题，避免了浮点数运算和数据溢出的问题。
- **LCA 算法**：利用 LCA 算法计算路径上的信息，将问题的时间复杂度从 $O(n)$ 降低到 $O(\log n)$。
- **特判处理**：对权值为 0 的情况进行特判，将其因数 2 和 5 的个数设为极大值，避免了死循环和错误结果。

### 可拓展之处
同类型题或类似算法套路：
- 树上路径的其他统计问题，如路径上的最大值、最小值、和等，可以使用类似的 LCA 算法进行求解。
- 其他涉及小数乘法判断是否为整数的问题，同样可以通过统计因数 2 和 5 的个数来解决。

### 推荐题目
- [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
- [P1967 货车运输](https://www.luogu.com.cn/problem/P1967)
- [P2014 [CTSC1997]选课](https://www.luogu.com.cn/problem/P2014)

### 个人心得摘录与总结
- **masonpop**：分享了自己在比赛时的踩坑经历，包括统计幂次函数出错导致死循环和没有特判权值为 0 的情况，提醒读者在实现时要注意这些细节。
- **User_leo**：提到自己在调试这道题时花费了 13 天，说明这类题目细节较多，需要耐心调试。

---
处理用时：42.36秒
# 题目信息

# [CCC 2021 S4] Daily Commute

## 题目描述

已知有 $N$ 个地铁站，你家在 $1$，学校在 $N$。

有 $W$ 条单向人行道。经过需要一分钟。

此外还有一条环形地铁线路，依次经过 $S_1,S_2,\cdots,S_N$，且保证 $S_1=1$。每天**有且仅有**一辆地铁在 $0$ 时刻从 $S_1$ 出发，并且恰好在第 $i$ 分钟到达 $S_i$。

在接下来 $D$ 天中：

- 交换 $S_{X_i}$ 和 $S_{Y_i}$。注意修改是永久的。
- 查询从 $1$ 到 $N$ 的最短用时。你出发时地铁在 $1$。

## 说明/提示

$$3\leq N\leq 200000,0\leq W\leq 200000,1\leq D\leq 200000$$

译自 [CCC2021 S4](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/seniorEF.pdf)。

请注意常数。

## 样例 #1

### 输入

```
4 3 3
1 2
3 4
4 1
1 4 3 2
3 4
4 2
3 2
```

### 输出

```
1
2
3
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先证明最优方案是从起点坐一段地铁后下车步行到终点，然后通过建反图用 BFS 或 Dijkstra 算法预处理出每个点到终点的最短距离。对于地铁站点的交换操作，大部分题解使用优先队列或线段树等数据结构来维护最短路径，避免每次都重新计算。

### 所选题解
- **作者：_•́へ•́╬_（5星）**
    - **关键亮点**：思路清晰，分别给出了使用 `set` 和堆实现的代码，对比了不同数据结构的性能差异，代码中使用了快速读入优化。
    - **核心代码**：
```cpp
// 堆实现
for(int i=0;i<n;++i)qwq.emplace(dis[i]+a[i],i);
for(int u,v;d--;pi(qwq.top().first),pc('\n'))
{
    read(u);read(v);--u;--v;
    swap(s[u],s[v]);
    u=s[u];v=s[v];
    swap(a[u],a[v]);
    qwq.emplace(dis[u]+a[u],u);qwq.emplace(dis[v]+a[v],v);
    for(;qwq.top().first^dis[qwq.top().second]+a[qwq.top().second];qwq.pop());
}
```
    - **核心实现思想**：先将每个点的最短路径信息加入优先队列，每次交换站点后，更新相关点的信息并重新加入队列，然后弹出队列中不符合当前状态的元素，直到队头元素符合条件，输出队头元素的最短路径。

- **作者：RE_Prince（4星）**
    - **关键亮点**：详细解释了不考虑等地铁的原因，对思路的阐述较为清晰，使用优先队列维护最短路，代码可读性较好。
    - **核心代码**：
```cpp
for (i = 1; i <= n; i++) cin >> a[i], ans.push({ i,a[i],i + dis[a[i]] - 1}), pos[a[i]] = i;
while (k--)
{
    int x, y;
    cin >> x >> y;
    int pp = pos[a[x]];
    pos[a[x]] = pos[a[y]];
    pos[a[y]] = pp;
    ans.push({ x,a[y],x + dis[a[y]] - 1 });
    ans.push({ y,a[x],y + dis[a[x]] - 1 });
    swap(a[x], a[y]);
    while (!ans.empty() && pos[ans.top().sta]!= ans.top().pos) ans.pop();
    cout << min({ ans.top().dis, nc,pos[n] - 1 }) << endl;
}
```
    - **核心实现思想**：将每个站点的信息加入优先队列，每次交换站点后，更新相关站点的信息并重新加入队列，然后弹出队列中不符合当前状态的元素，直到队头元素符合条件，输出队头元素的最短路径。

- **作者：CSP_Sept（4星）**
    - **关键亮点**：给出了最优方案只坐一次地铁的严谨证明，使用线段树维护单点修改和全局最小值，时间复杂度稳定。
    - **核心代码**：
```cpp
tr.build(1, n, 1);
while(r--){
    int x = rd(), y = rd();
    int c = t[s[y]] - t[s[x]];
    tr.modify(s[x], s[x], 1, n, 1, c);
    tr.modify(s[y], s[y], 1, n, 1, -c);
    swap(t[s[x]], t[s[y]]); swap(s[x], s[y]);
    printf("%lld\n", tr.query(1, n, 1, n, 1));
}
```
    - **核心实现思想**：先使用线段树构建初始的最短路径信息，每次交换站点后，通过线段树的单点修改操作更新相关点的信息，最后查询全局最小值。

### 最优关键思路或技巧
- **证明最优方案**：证明最优方案是从起点坐一段地铁后下车步行到终点，避免了复杂的状态枚举。
- **建反图预处理**：建反图后使用 BFS 或 Dijkstra 算法预处理出每个点到终点的最短距离，减少重复计算。
- **数据结构维护**：使用优先队列或线段树等数据结构维护最短路径，在交换站点时快速更新信息。

### 可拓展之处
同类型题或类似算法套路：
- 带有特殊交通方式（如公交、地铁等）的最短路问题。
- 动态修改图的结构并查询最短路的问题。

### 推荐题目
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
- [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
- [P4779 单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

### 个人心得摘录与总结
- **作者：_zuoqingyuan**：“今天模拟赛挂了 200 分，这题贡献了 100”，总结了自己在模拟赛中因本题失分的经历。
- **作者：tkm2013**：“十年洛谷一场空，复制题解名变棕”，提醒不要复制题解，要自己思考。 

---
处理用时：34.97秒
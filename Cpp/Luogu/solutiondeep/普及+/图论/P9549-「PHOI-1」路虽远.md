# 题目信息

# 「PHOI-1」路虽远

## 题目背景

$update$ $on$ $2023.8.17$ $12:25$ 
**数据修复&加强完成，可重新提交代码。**

路虽远，行则将至。

![](https://cdn.luogu.com.cn/upload/image_hosting/ugqt01zi.png)

## 题目描述

**请注意本题特殊的时限。**

小 X 来到了 Z 市，Z 市有 $n$ 个交通路口，$m$ 条马路。其中第 $i$ 条马路连接着第 $u_i$ 个交通路口和第 $v_i$ 个交通路口（可以从 $u_i$ 到 $v_i$，也可以从 $v_i$ 到 $u_i$），小 X 通过这条马路时要花费 $p_i$ 秒，若有限速，则通过这条马路时要花费 $q_i$ 秒。

现在，市长要在 $k$ 条马路上添加限速，然而，要在哪 $k$ 条马路上限速是小 X 自己规定的。

同时，市长会在每个交通路口处添加红绿灯。第 $i$ 个交通路口的红绿灯先亮绿灯 $x_i$ 秒，再亮黄灯 $y_i$ 秒，之后亮红灯 $z_i$ 秒，然后再亮绿灯，黄灯，红灯，如此往复。如果一个交通路口的红绿灯不是红灯，小 X 可以从这个交通路口出发，到达另一个交通路口。若到达交通路口时，灯的颜色瞬间变了，则按照变了之后的灯计算，灯的黄灯和红灯的持续时间可能为 $0$。并且，小 X 最多只能闯 $g$ 次黄灯。

过了一会儿，市长突然发现，所有的红绿灯在某一刻都变成了绿灯。与此同时，小 X 从第 $1$ 个路口出发，前往第 $n$ 个路口。他想问你，他至少要花多少时间才能到达第 $n$ 个路口？

因为路虽远，行则将至，数据保证一定可以到达，即 $1\sim n$ 一定连通。

## 说明/提示

**本题采用捆绑测试。**

| Subtask | $n,m$ | $y_i,z_i$ | $k,g$ | 分值 |
| :-: | :-: | :-: | :-: | :-: |
| $0$ | $1 \le n,m \le 5$ | 无特殊限制 | 无特殊限制 | $20$ |
| $1$ | 无特殊限制 | $y_i=z_i=0$ | $k=g=0$ | $5$ |
| $2$ | 无特殊限制 | $y_i=0,0 \le z_i \le 10^9$ | 无特殊限制 | $25$ | 
| $3$ | 无特殊限制 | 无特殊限制 | 无特殊限制 | $50$ |

对于 $100\%$ 的数据，保证 $1 \le n,m \le 100$，$0 \le k,g \le m$，$1 \le x_i \le 10^9$，$0 \le y_i,z_i \le 10^9$，$1 \le u,v \le n$，$0 \leq p_i \leq q_i \leq 10^9$。
### 样例解释 #1：


$1 \to 3 \to 4 \to 5$ 并在编号为 $1,2,4,6,7,8$ 的马路上添加限速，到 $3$ 时闯黄灯，到 $4$ 时绿灯直接过，这时候，$1 \to 3$ 花费 $1$ 秒，$3 \to 4$ 花费 $0$ 秒，$4 \to 5$ 花费 $3$ 秒，共花费 $4$ 秒。

### 样例解释 #2：

$1 \to 2 \to 5 \to 6 \to 9$ 并在编号为 $2,3,4,5,6,7,8,9,10,11,13,14,15,16$ 的马路上添加限速，到 $2,5$ 时闯黄灯，到 $4$ 时绿灯直接过，到 $6$ 时等 $1$ 秒红灯，这时候，$1 \to 2$ 花费 $1$ 秒，$2 \to 5$ 花费 $4$ 秒，$5 \to 6$ 花费 $9$ 秒，$6 \to 9$ 花费 $3$ 秒，加上等红灯的 $1$ 秒共花费 $18$ 秒。

## 样例 #1

### 输入

```
5 8 6 1
1 2 2
1 0 3
1 1 4
3 1 0
5 1 4
1 2 1 4
2 4 2 4
3 4 0 2
1 5 7 8
1 3 1 2
5 4 2 3
2 5 2 4
1 4 4 7```

### 输出

```
4```

## 样例 #2

### 输入

```
9 16 14 2
1 7 2
1 5 3
1 6 4
3 5 0
1 6 5
1 0 4
1 7 5
3 8 8
3 8 6
1 2 1 4
8 5 2 6
2 4 2 4
8 6 3 5
3 4 0 2
6 7 1 4
1 5 7 8
5 9 16 21
1 3 2 2
7 6 2 3
5 4 2 3
6 9 3 5
2 5 2 4
8 9 4 7
1 4 4 7
6 5 6 9```

### 输出

```
18```

# AI分析结果

### 综合分析与结论
这些题解主要围绕分层图的 Dijkstra 算法来解决问题，核心思路是通过记录当前点、不限速边的个数、闯黄灯次数等信息，对不同的交通灯状态和限速情况进行分类讨论，从而找到从起点到终点的最短时间。各题解在实现细节上略有不同，但整体思路一致。

### 所选题解
- **作者：FiraCode (赞：6)  ★★★★**
    - **关键亮点**：思路清晰，对每个 Subtask 都有详细的分析和解决方案，代码实现规范，注释较详细。
    - **个人心得**：无
- **作者：Night_sea_64 (赞：5)  ★★★★**
    - **关键亮点**：对不同交通灯状态下的情况分类明确，代码结构清晰，易于理解。
    - **个人心得**：认为这题是最短路练手题，但疑惑为何评蓝题。
- **作者：iakioi114514 (赞：0)  ★★★★**
    - **关键亮点**：详细阐述了分层图和三维 Dijkstra 的思路，代码实现简洁明了。
    - **个人心得**：开始觉得题简单，中间遇到困难，做完后认为难度应是蓝题，还提到因忘记取反卡了两小时。

### 重点代码
#### FiraCode 的核心代码
```cpp
void dijkstra() {
    for (int i = 1; i <= n; ++i)
        for (int j = 0; j <= k; ++j)
            for (int k = 0; k <= g; ++k)
                dist[i][j][k] = INF;

    dist[1][0][0] = 0;
    q1.push({1, 0, 0, 0});

    while (!q1.empty()) {
        auto u = q1.top();
        q1.pop();
        int x = u.x, y = u.y, z = u.z, w = u.w, now = w % (a[x] + b[x] + c[x]);
        if (dist[x][y][z] < w) continue;
        for (int i = h[x]; ~i; i = ne[i]) {
            int v = e[i];
            if (y < k) {
                if (now < a[x]) update(v, y + 1, z, w + p[i]);
                else update(v, y + 1, z, w + a[x] + b[x] + c[x] - now + p[i]);
                if (z < g) {
                    if (now < (a[x] + b[x])) update(v, y + 1, z + 1, w + p[i]);
                    else update(v, y + 1, z + 1, w + a[x] + b[x] + c[x] - now + p[i]);
                }
            }
            if (now < a[x]) update(v, y, z, w + q[i]);
            else update(v, y, z, w + a[x] + b[x] + c[x] - now + q[i]);
            if (z < g) {
                if (now < (a[x] + b[x])) update(v, y, z + 1, w + q[i]);
                else update(v, y, z + 1, w + a[x] + b[x] + c[x] - now + q[i]);
            }
        }
    }
}
```
**核心实现思想**：使用三维数组 `dist` 记录状态，通过优先队列进行 Dijkstra 算法，根据当前交通灯状态和是否还能不限速、闯黄灯，更新距离并加入队列。

#### Night_sea_64 的核心代码
```cpp
void dij()
{
    qq.push({1,0,0,0});
    memset(d,999999,sizeof(d));
    d[1][0][0]=0;
    while(!qq.empty())
    {
        int x=qq.top().x,lim=qq.top().lim;
        int cnt=qq.top().cnt,dis=qq.top().dis;
        qq.pop();
        int t=a[x]+b[x]+c[x],now=dis%t;
        if(x==n)
        {
            cout<<dis<<endl;
            exit(0);
        }
        if(flag[x][lim][cnt])continue;
        flag[x][lim][cnt]=1;
        for(auto e:v[x])
        {
            int p=e.p,q=e.q;
            if(now<a[x])//绿灯
            {
                //限速
                go(x,lim,cnt,e.x,lim,cnt,q);
                //不限速
                if(lim<m-k)go(x,lim,cnt,e.x,lim+1,cnt,p);
            }
            else if(now<a[x]+b[x])//黄灯
            {
                //不闯黄灯，限速
                go(x,lim,cnt,e.x,lim,cnt,t-now+q);
                //不闯黄灯，不限速
                if(lim<m-k)go(x,lim,cnt,e.x,lim+1,cnt,t-now+p);
                //闯黄灯，限速
                if(cnt<g)go(x,lim,cnt,e.x,lim,cnt+1,q);
                //闯黄灯，不限速
                if(cnt<g&&lim<m-k)
                    go(x,lim,cnt,e.x,lim+1,cnt+1,p);
            }
            else//红灯
            {
                //限速
                go(x,lim,cnt,e.x,lim,cnt,t-now+q);
                //不限速
                if(lim<m-k)go(x,lim,cnt,e.x,lim+1,cnt,t-now+p);
            }
        }
    }
}
```
**核心实现思想**：同样使用优先队列进行 Dijkstra 算法，根据当前交通灯状态（绿灯、黄灯、红灯）对限速和不限速、闯黄灯和不闯黄灯的情况进行分类讨论，更新距离。

#### iakioi114514 的核心代码
```cpp
void dijkstra(){
    for(int i=1;i<=n;i++){
        for(int j=0;j<=k;j++){
            for(int k=0;k<=g;k++){
                dis[i][j][k]=0x3f3f3f3f3f3f3f3f;
            }
        }
    }
    dis[1][0][0]=0;
    qq.push((s){1,0,0,0});
    while(!qq.empty()){
        s u=qq.top();
        qq.pop();
        int x=u.x,y=u.y,z=u.z,w=u.w,now=w%(a[x]+b[x]+c[x]);
        if(dis[x][y][z]<w) continue;
        for(int i=h[x];~i;i=ee[i]){
            int v=e[i];
            if(y<k){
                if(now<a[x]) youxi(v,y+1,z,w+p[i]);
                else youxi(v,y+1,z,w+a[x]+b[x]+c[x]-now+p[i]);
                if(z<g){
                    if(now<a[x]+b[x]) youxi(v,y+1,z+1,w+p[i]);
                    else youxi(v,y+1,z+1,w+a[x]+b[x]+c[x]-now+p[i]);
                }
            }
            if(now<a[x]) youxi(v,y,z,w+q[i]);
            else youxi(v,y,z,w+a[x]+b[x]+c[x]-now+q[i]);
            if(z<g){
                if(now<a[x]+b[x]) youxi(v,y,z+1,w+q[i]);
                else youxi(v,y,z+1,w+a[x]+b[x]+c[x]-now+q[i]);
            }
        }
    }
}
```
**核心实现思想**：与前两个题解类似，使用三维数组记录状态，优先队列进行 Dijkstra 算法，根据交通灯状态和限速、闯黄灯情况更新距离。

### 最优关键思路或技巧
- **分层图思想**：将不同的限速状态看作不同的层，通过分层图的方式处理边权的变化。
- **三维 Dijkstra**：使用三维数组记录当前点、不限速边的个数、闯黄灯次数，全面考虑各种状态。
- **分类讨论**：对不同的交通灯状态（绿灯、黄灯、红灯）进行分类讨论，分别处理限速和不限速、闯黄灯和不闯黄灯的情况。

### 可拓展之处
同类型题或类似算法套路：
- 涉及多状态的最短路问题，如在图中存在多种不同的移动方式或限制条件，可使用类似的分层图和多维度状态记录的方法。
- 带有资源限制的路径规划问题，如有限的能量、次数等，可通过记录资源状态进行求解。

### 推荐题目
- [P1629 邮递员送信](https://www.luogu.com.cn/problem/P1629)：涉及单源最短路和多源最短路的综合应用。
- [P4779 单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：标准的单源最短路问题，可用于练习 Dijkstra 算法。
- [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：同样是单源最短路问题，难度较低，适合初学者练习。

---
处理用时：53.04秒
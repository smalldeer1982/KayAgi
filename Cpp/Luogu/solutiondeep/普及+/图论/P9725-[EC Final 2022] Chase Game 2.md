# 题目信息

# [EC Final 2022] Chase Game 2

## 题目描述

庞教授和寿教授喜欢玩追逐游戏。

游戏地图由 $n$ 个房间和 $n-1$ 条双向通道组成。游戏地图是连通的。这意味着地图形成一棵树。

一开始，庞教授在房间 $u$，而寿教授在房间 $v$（$u\neq v$）。庞教授和寿教授轮流玩游戏，寿教授先开始。在自己的回合中，玩家知道自己所在的位置和另一个玩家的位置，可以决定留在当前房间或者移动到与当前房间直接通过通道相连的另一个房间。当庞教授和寿教授在同一个房间时，寿教授被庞教授抓住。

庞教授和寿教授足够聪明。庞教授希望在有限的回合内抓住寿教授。寿教授不希望在任何有限的回合内被庞教授抓住。

寿教授厌倦了每次都被抓住，找到了费教授寻求帮助。寿教授请求费教授添加一些通道，使得无论初始房间对 $(u,v)$ 如何，庞教授都无法在有限的回合内抓住他。费教授很懒，所以他希望尽可能少地添加通道。如果无论如何添加通道，总是存在一对房间 $(u,v)$，使得庞教授能够抓住寿教授，输出 $-1$。

## 样例 #1

### 输入

```
4
2
1 2
4
1 2
2 3
3 4
4
1 2
2 3
2 4
5
1 2
2 3
3 4
3 5
```

### 输出

```
-1
1
-1
2
```

# AI分析结果

### 综合分析与结论
这些题解思路基本一致，都围绕让所有叶子节点处于点数大于 3 的环内来求解最少加边数。先判断菊花图无解，对于非菊花图，计算叶子节点数 $a$，与每个节点直接相邻的叶子节点数 $num_i$，答案为 $\max(\lceil \frac{a}{2}\rceil,\max_{i = 1}^n num_i)$。各题解在思路阐述的严谨性和代码实现方式上有差异。

### 所选题解
- **作者：HFanGDoDM (5星)**
    - **关键亮点**：思路严谨，对答案公式进行了详细的正确性证明，代码简洁明了。
    - **核心代码**：
```cpp
for(i = 1; i < n; i++){
    int u = R(), v = R();
    deg[u]++, deg[v]++;
    edge.push_back({u, v});
}
for(i = 0; i < n - 1; i++){
    if(deg[edge[i].first] == 1)
        num1[edge[i].second]++;
    if(deg[edge[i].second] == 1)
        num1[edge[i].first]++;
}
for(i = 1; i <= n; i++)
    if(deg[i] == n - 1){
        puts("-1");
        return;
    }
int num = 0;
for(i = 1; i <= n; i++)
    if(deg[i] == 1)
        num++;
int ans = (num + 1) >> 1;
for(i = 1; i <= n; i++)
    ans = max(ans, num1[i]);
printf("%d\n", ans);
```
    - **核心实现思想**：先统计节点度数和每条边信息，再计算每个节点相邻的叶子节点数，判断是否为菊花图，若不是则计算叶子节点总数，最后取 $\lceil \frac{a}{2}\rceil$ 和 $\max_{i = 1}^n num_i$ 的最大值作为答案。

- **作者：Fgighkcgrfox (4星)**
    - **关键亮点**：思路清晰，结合形象比喻，代码注释详细，适合初学者理解。
    - **个人心得**：“考试时因为没向上取整，吃了一发罚时”，提醒做题时要注意细节。
    - **核心代码**：
```cpp
scanf("%d", &T);
while(T--){
    memset(du, 0, sizeof(du)); memset(tj, 0, sizeof(tj)); sum = 0; bb = 1;
    scanf("%d", &n);
    for(int i = 1; i < n; i++) scanf("%d%d", &u[i], &v[i]), du[u[i]]++, du[v[i]]++;
    if(n <= 3){puts("-1"); continue;}
    for(int i = 1; i < n; i++){
        if(du[u[i]] == 1) tj[v[i]]++, sum++;
        if(du[v[i]] == 1) tj[u[i]]++, sum++;
    }
    ans = ((sum + 1) >> 1);
    for(int i = 1; i <= n; i++)
        if(tj[i] == sum){puts("-1"); bb = 0; continue;}
        else if(tj[i] > ans) ans = tj[i];
    if(bb) printf("%d\n", ans);
}
```
    - **核心实现思想**：多组数据处理，先初始化，读入边信息统计度数，判断节点数是否小于等于 3，若不是则计算叶子节点总数和每个节点相邻的叶子节点数，处理无解情况并更新答案。

### 最优关键思路或技巧
- **思维方式**：从结果出发，分析要使追逐者抓不到被追逐者，需让所有叶子节点处于点数大于 3 的环内，进而推导出答案公式。
- **代码实现技巧**：用数组统计节点度数和相邻叶子节点数，简洁高效。

### 可拓展之处
同类型题可能会改变图的初始结构（如从树变为一般图），或改变游戏规则（如移动步数限制、追逐者和被追逐者的行动顺序等），解题思路仍可围绕环的构造和避免特殊情况（如三元环）展开。

### 推荐题目
- [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：考察思维和动态规划，需从结果倒推，与本题从目标状态分析思路类似。
- [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：需要考虑特殊情况和路径规划，和本题考虑特殊结构（菊花图）和加边方案有相似之处。
- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：考察对图的处理和边界情况的判断，与本题对图结构的分析有一定关联。 

---
处理用时：30.01秒
# 题目信息

# 『PG2』弯曲半平面直线同向图最大流

## 题目描述

若能将有向图 $G=(V,E)$ 画在平面上，使得点在一条直线上，任意两条边（可以为弯曲的弧线）仅在重合顶点处相交，且边上的所有点都在直线同侧，且每条边的起点到终点的射线的方向相同，则称 $G$ 是弯曲半平面直线同向图。对于一个弯曲半平面直线同向图给定 $n$ 个点，$m$ 条有向边，给定每条边的容量，求从点 $s$ 到点 $t$ 的最大流。

## 说明/提示

无重边自环。

对于 $30\%$ 的数据 $n\leq 10^3$。

对于 $70\%$ 的数据 $n\leq 10^5$。

对于 $100\%$ 的数据 $2\leq n\leq 10^6$，$1\leq m\leq \min\{2\times 10^9,\dfrac{n(n-1)}{2}\}$，$1\leq c\leq 10^{12}$，$s\neq t$。

### 样例解释 1
![](https://cdn.luogu.com.cn/upload/image_hosting/9qletk0m.png)

## 样例 #1

### 输入

```
5 7 1 5
1 2 1
2 3 1
3 4 1
4 5 1
2 4 1
1 4 1
1 5 1```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解围绕弯曲半平面直线同向图的最大流问题展开，均利用了该图为有向无环图（DAG）这一性质。不同题解在实现方法和复杂度上有所差异，部分题解通过优化排序等操作降低时间复杂度。

### 所选题解
- **xixisuper（4星）**
  - **关键亮点**：思路清晰，详细分析图的性质，通过正反 dfs 筛选有效点，利用拓扑序优化建图，将时间复杂度从 $O(n\log n)$ 优化到 $O(n)$，还给出了实用的卡常技巧。
  - **个人心得**：作者低估了 `vector` 的常数，导致实现的算法常数奇大，花费一整个上午才解决问题，提醒大家注意 STL 的常数问题。
- **phigy（4星）**
  - **关键亮点**：提供了分档得分的思路，从 30 分的常用最大流算法到 70 分的贪心策略，再到 100 分的 $O(n)$ 优化，层次分明，对拓扑排序的运用有深入的认识。

### 重点代码及核心思想
#### xixisuper
```cpp
// 建边函数
inline void add_edge(ll opt,ll u,ll v,long long w){
    zh[opt][++tot[opt]].v=v;
    zh[opt][tot[opt]].c=w;
    zh[opt][tot[opt]].nxt=head[opt][u];
    head[opt][u]=tot[opt];
}
// dfs 标记有效点
inline void dfs(ll opt,ll u){
    vis[u]=opt+1;
    for(ll i=head[opt][u];i;i=zh[opt][i].nxt)
        if(vis[zh[opt][i].v]==opt)
            dfs(opt,zh[opt][i].v);
}
// 主函数部分
int main(){
    n=read(),m=read(),s=read(),t=read();
    for(register ll i=1;i<=m;i++){
        ll x=read(),y=read(),z=read();
        add_edge(0,x,y,z);
        add_edge(1,y,x,z);
        in[y]++;
    }
    dfs(0,s);dfs(1,t);
    // 拓扑排序
    for(ll i=1;i<=n;i++) if(!in[i]) q[rear++]=i; 
    while(front<rear){
        ll now=q[front++];
        if(vis[now]==2){
            cnt++;
            ni_tupo[cnt]=now;
        }
        for(register ll i=head[0][now];i;i=zh[0][i].nxt){
            in[zh[0][i].v]--;
            if(!in[zh[0][i].v]) q[rear++]=zh[0][i].v;
        }
    }
    // 重新建图
    for(ll i=1;i<=cnt;i++){
        for(ll j=head[1][ni_tupo[i]];j;j=zh[1][j].nxt){
            if(vis[zh[1][j].v]!=2) continue;
            add_edge(2,zh[1][j].v,ni_tupo[i],zh[1][j].c);
        }
    }
    f[s]=INF*INF;
    // 贪心计算最大流
    for(ll i=1;i<=cnt;i++){
        for(ll j=head[2][ni_tupo[i]];j;j=zh[2][j].nxt){
            if(vis[zh[2][j].v]!=2) continue;
            f[zh[2][j].v]+=min(zh[2][j].c,f[ni_tupo[i]]);
            f[ni_tupo[i]]-=min(zh[2][j].c,f[ni_tupo[i]]);
            if(!f[ni_tupo[i]]) break;
        }
    }
    cout<<f[t];
    return 0;
} 
```
**核心思想**：先通过正反 dfs 标记从源点能走到且能走到汇点的点，然后进行拓扑排序，再根据拓扑序重新建图，最后利用贪心策略计算最大流。

#### phigy
```cpp
// 100 分代码部分
namespace Main{
    const int N = 1000005;
    int n, m, s, t, in[N], id[N], cnt;
    ll flow[N];
    vector<int> g[N];
    vector<tuple<int, int, ll>> edges;
    vector<pair<int, ll>> to[N], buc[N];
    void Main(){
        input(n, m, s, t);
        for(int i = 0; i < m; i++){
            int u, v; ll c;
            input(u, v, c);
            g[u].push_back(v);
            edges.emplace_back(u, v, c);
            in[v]++;
        }
        // 拓扑排序
        queue<int> q;
        for(int i = 1; i <= n; i++) if(!in[i]) q.push(i);
        while(!q.empty()){
            int u = q.front(); q.pop();
            id[u] = ++cnt;
            for(int v: g[u]){
                in[v]--;
                if(!in[v]) q.push(v);
            }
        }
        // 重新建图
        for(auto [u, v, c]: edges){
            buc[id[v]].emplace_back(id[u], c);
        }
        for(int i = n; i >= 1; i--){
            for(auto [u, c]: buc[i]) to[u].emplace_back(i, c);
        }
        flow[id[s]] = 1e18;
        // 贪心计算最大流
        for(int i = 1; i <= n; i++){
            if(i == id[t]){
                write(flow[i]);
                return;
            }
            for(auto [v, c]: to[i]){
                if(v > id[t]) continue;
                if(!flow[i]) break;
                ll tmp = min(flow[i], c);
                flow[v] += tmp;
                flow[i] -= tmp;
            }
        }
        return;
    }
} // namespace Main
```
**核心思想**：先进行拓扑排序，然后根据拓扑序重新建图，使得边按拓扑序有序，最后利用贪心策略计算最大流。

### 最优关键思路或技巧
- 利用图的性质，确定其为有向无环图，从而进行拓扑排序。
- 通过正反 dfs 筛选出对答案有贡献的点，减少不必要的计算。
- 优化排序操作，通过重新建图使边按拓扑序有序，将时间复杂度从 $O(n\log n)$ 优化到 $O(n)$。
- 采用贪心策略，优先将流量灌给拓扑序大的点。

### 可拓展之处
同类型题或类似算法套路：
- 其他有向无环图上的最大流问题，可参考本题利用拓扑序的思路。
- 平面图上的网络流问题，可能需要结合平面图的性质进行求解。
- 涉及区间覆盖、差分等思想的问题，可借鉴本题将最大流转最小割的思路。

### 推荐题目
- P3376 【模板】网络最大流
- P4722 【模板】最大流 加强版 / 预流推进
- P2766 最长不下降子序列问题

### 个人心得总结
xixisuper 提醒我们在实现算法时要注意 STL 的常数问题，避免因低估某些数据结构的常数而导致算法运行时间过长。在遇到 TLE 时，可以从 IO 优化、变量类型选择、避免使用大常数的 STL 等方面进行卡常。

---
处理用时：48.75秒
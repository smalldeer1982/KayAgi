# 题目信息

# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# AI分析结果

这道题主要考查字符串变换的搜索算法，多数题解采用BFS或DFS思路，并运用多种优化技巧。以下是对各题解的综合分析：
1. **思路与算法要点**：
    - **广度优先搜索（BFS）**：多数题解采用BFS，从初始字符串开始，按规则逐步变换，用队列存储状态，找到目标字符串时的步数即为最小步数。为避免重复搜索，使用`map`、`set`或`hash`进行判重。例如，将初始字符串入队，每次取出队首字符串，根据规则进行变换，将新字符串入队。
    - **双向广度优先搜索（双向BFS）**：部分题解采用双向BFS，从初始字符串和目标字符串同时搜索，相遇时步数之和为最小步数，可减少搜索空间和时间。如同时从初始和目标字符串出发，交替扩展队列，当两边队列出现相同字符串时，计算并输出总步数。
    - **深度优先搜索（DFS）**：有题解使用DFS结合迭代加深，通过猜测答案限制搜索深度，避免在错误路径浪费时间。例如，每次设置一个最大深度，超过则终止搜索，逐步增加深度直至找到解。
    - **字符串匹配**：部分题解在搜索过程中使用KMP算法进行字符串匹配，以提高匹配效率。如在BFS中，用KMP算法查找可变换的子串。
2. **解决难点**：
    - **判重**：由于可能产生大量重复字符串，使用`map`、`set`、`hash`等方式判重，避免重复搜索，降低时间和空间复杂度。
    - **字符串处理**：包括字符串的查找、替换、拼接等操作，可使用STL的`string`函数或手动实现。如用`find`查找子串位置，`replace`进行替换。
    - **读入数据**：部分题解需处理不定数量的规则输入，可通过`while (cin >> a >> b)`或文件输入输出实现。
3. **题解评分**：
    - **作者coyangjr**：5星。思路清晰，先分析搜索方向，采用BFS结合KMP算法，详细介绍KMP实现及`string`函数，代码注释详细。
    - **作者ShawnZhou**：4星。清晰阐述BFS思路，代码结构清晰，通过`map`判重，有详细的函数实现和注释。
    - **作者BrandonSoong**：4星。提出双向BFS优化，通过图形直观解释原理，代码实现详细，有注释说明关键步骤。

### 所选题解
1. **作者coyangjr**
    - **星级**：5星
    - **关键亮点**：结合BFS和KMP算法，详细介绍KMP原理及`string`函数，代码注释丰富。
    - **个人心得**：考试时遗忘`find`和`replace`函数，选择使用KMP算法。
    - **核心代码**：
```cpp
// 寻找next数组
il void get_next(int x) {
    re int i, j = 0;
    for (i = 2; i < diff[x].length(); i++) {
        while (j && diff[x][i]!= diff[x][j + 1]) j = nxt[x][j];
        if (diff[x][j + 1] == diff[x][i]) j++;
        nxt[x][i] = j;
    }
}

// KMP匹配并修改字符串
il void KMP(string a, int x, int step) {
    string z = a;
    a = " " + a;
    re int i, j = 0;
    for (i = 1; i < a.length(); i++) {
        while (j > 0 && diff[x][j + 1]!= a[i]) j = nxt[x][j];
        if (diff[x][j + 1] == a[i]) j++;
        if (j == diff[x].length() - 1) {
            re int t = i - diff[x].length() + 1;
            string tmp = z.substr(0, t) + change[x] + z.substr(t + diff[x].length() - 1);
            q.push(Node(tmp, step + 1));
            j = nxt[x][j];
        }
    }
    return;
}
```
2. **作者ShawnZhou**
    - **星级**：4星
    - **关键亮点**：清晰阐述BFS思路，代码结构清晰，利用`map`判重。
    - **核心代码**：
```cpp
string trans(const string &str, int i, int j) {
    string ans = "";
    if (i + orginal[j].length() > str.length())
        return ans;

    for (int k = 0; k < orginal[j].length(); k++)
        if (str[i + k]!= orginal[j][k])
            return ans;

    ans = str.substr(0, i);
    ans += translated[j];
    ans += str.substr(i + orginal[j].length());
    return ans;
}

void bfs() {
    queue <node> q;
    node s;
    s.str = a;
    s.step = 0;
    q.push(s);

    while (!q.empty()) {
        node u = q.front();
        q.pop();
        string temp;

        if (ma.count(u.str) == 1)
            continue;

        if (u.str == b) {
            ans = u.step;
            break;
        }
        ma[u.str] = 1;
        for (int i = 0; i < u.str.length(); i++)
            for (int j = 0; j < n; j++) {
                temp = trans(u.str, i, j);
                if (temp!= "") {
                    node v;
                    v.str = temp;
                    v.step = u.step + 1;
                    q.push(v);
                }
            }
    }
    if (ans > 10 || ans == 0)
        cout << "NO ANSWER!" << endl;
    else
        cout << ans << endl;
}
```
3. **作者BrandonSoong**
    - **星级**：4星
    - **关键亮点**：提出双向BFS优化，用图形解释原理，代码实现详细。
    - **核心代码**：
```cpp
inline int bfs() {
    int step = 0;
    A_.push(s);
    A[s] = 0;
    B_.push(t);
    B[t] = 0;
    string s, s2;
    while (++step <= 5) {
        while (A[A_.front()] == step - 1) {
            s = A_.front();
            A_.pop();
            for (int i = 1; i <= n; i++) {
                unsigned int pos = 0;
                while (pos < s.length()) {
                    if (s.find(a[i], pos) == s.npos) break;
                    s2 = s;
                    s2.replace(s2.find(a[i], pos), a[i].length(), b[i]);
                    if (A.find(s2)!= A.end()) {
                        pos++;
                        continue;
                    }
                    if (B.find(s2)!= B.end()) return step * 2 - 1;
                    A_.push(s2);
                    A[s2] = step;
                    pos++;
                }
            }
        }
        while (B[B_.front()] == step - 1) {
            s = B_.front();
            B_.pop();
            for (int i = 1; i <= n; i++) {
                unsigned int pos = 0;
                while (pos < s.length()) {
                    if (s.find(b[i], pos) == s.npos) break;
                    s2 = s;
                    s2.replace(s2.find(b[i], pos), b[i].length(), a[i]);
                    if (B.find(s2)!= B.end()) {
                        pos++;
                        continue;
                    }
                    if (A.find(s2)!= A.end()) return step * 2;
                    B_.push(s2);
                    B[s2] = step;
                    pos++;
                }
            }
        }
    }
    return -1;
}
```

### 最优关键思路与技巧
1. **数据结构**：使用`map`、`set`或`hash`进行判重，有效减少重复搜索；双向BFS使用两个队列分别从初始和目标状态搜索。
2. **算法优化**：双向BFS利用正反两个方向搜索，减少搜索空间和时间；迭代加深DFS通过限制深度避免无效搜索。
3. **代码实现技巧**：熟练运用STL的`string`函数进行字符串操作，简化代码实现。

### 拓展思路
此类题目属于字符串变换的搜索问题，相似套路包括：
1. **状态空间搜索**：确定状态表示和转移规则，使用BFS或DFS遍历状态空间。
2. **判重优化**：针对可能产生大量重复状态的问题，采用合适的数据结构判重。
3. **双向搜索**：已知初始和目标状态时，双向BFS可优化搜索效率。

### 相似知识点题目推荐
1. **P1126 机器人搬重物**：涉及状态搜索和路径规划，可使用BFS解决。
2. **P1379 八数码难题**：通过BFS搜索数字矩阵的变换，与本题思路相似。
3. **P1443 马的遍历**：利用BFS计算马在棋盘上的遍历路径，考查搜索算法。 

---
处理用时：77.08秒
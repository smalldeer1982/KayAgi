# 题目信息

# 文件压缩

## 题目背景

提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。


## 题目描述

该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。

举例：$S$ 是 `example`

1. 构造 $n$ 个字符串。

```plain
example
xamplee
ampleex
mpleexa
pleexam
leexamp
eexampl
```

2. 将字符串排序。

```plain
ampleex
example
eexampl
leexamp
mpleexa
pleexam
xamplee
```
3. 压缩结果。

$S' = \texttt{xelpame}$，$p = 7$

由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。

请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。

保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。

## 样例 #1

### 输入

```
7
xelpame
7
```

### 输出

```
example
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均是利用排序后的字符串首字母与原字符串尾字母的对应关系，通过倒推还原原字符串。因为正推时在无序的原字符串中查找字符易出现错位问题，倒推则可从有序的排序后字符串中查找，避免该问题。算法要点为对输入的字符串 $S'$ 排序得到首字母序列，结合给定位置 $p$ 确定起始字符，再不断通过匹配首、尾字母逐步还原原字符串。

### 所选的题解
- **作者：liuzhaoxu (4星)**
    - **关键亮点**：思路清晰，详细解释了不能正着推的原因，并通过具体反例说明，代码注释详尽。
    - **个人心得**：强调正着推会因在无序序列中查找字符导致答案错误，所以采用倒推。
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int maxn=10000+5;
    int n,p;
    char s[maxn],ss[maxn]; 
    char ans[maxn];
    int main(){
        scanf("%d%s%d",&n,s+1,&p);
        memcpy(ss+1,s+1,sizeof s);
        sort(ss+1,ss+1+n); 
        int cnt=n+1; 
        for(int i=1;i<=n;++i) if(ss[i]==s[p]) { p=i;break; } 
        while(cnt>1){ 
            ans[--cnt]=s[p]; 
            ss[p]='#';
            for(int i=n;i>=1;--i) if(ss[i]==s[p]) {p=i;break;} 
        }
        printf("%s\n",ans+1); 
        return 0;
    }
    ```
    - **核心代码实现思想**：先对输入字符串 $s$ 复制并排序得到 $ss$，通过 $p$ 找到答案中最后一个字符的位置 $p$，在循环中不断从后往前在 $ss$ 中找与当前 $s[p]$ 相同的字符，确定前一个字符并记录到 $ans$ 中，同时标记已使用字符，最后输出 $ans$。
- **作者：minVan (4星)**
    - **关键亮点**：解题思路部分清晰阐述每一步推导逻辑，代码结构清晰，变量命名有一定表意性。
    - **个人心得**：明确正序确认原串位置会因在无序的原串中查找导致问题，所以采用倒序确认。
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int n, p, cur;
    char s[10005], s1[10005], ans[10005]; 
    bool vis[10005];
    int main() {
        cin >> n;
        for(int i = 1; i <= n; i++) {
            cin >> s[i];
            s1[i] = s[i];
        }
        cin >> p;
        sort(s1 + 1, s1 + n + 1);
        ans[1] = s[p]; 
        for(int i = 1; i <= n; i++) {
            if(s1[i] == s[p]) {
                cur = i; 
                break;
            }
        }
        for(int i = n; i >= 2; i--) { 
            vis[cur] = 1; 
            ans[i] = s[cur]; 
            for(int j = n; j >= 1; j--) {
                if(s1[j] == s[cur] &&!vis[j]) {
                    cur = j;
                    break;
                }
            }
        }
        for(int i = 1; i <= n; i++) {
            cout << ans[i];
        }
        return 0;
    }
    ```
    - **核心代码实现思想**：先读入字符串 $s$ 并复制一份用于排序得到 $s1$，通过 $p$ 确定原字符串首字母并记录到 $ans[1]$，找到构造的第一个串编号 $cur$，在倒序循环中标记已使用字符，确定原串每个位置的字符。
- **作者：Jorisy (4星)**
    - **关键亮点**：以样例直观展示首字母与尾字母对应关系，清晰说明正推会出现字母混乱问题及原因，代码简洁明了。
    - **个人心得**：通过具体例子说明正推会因不同写法得到不同答案，强调倒推避免该现象。
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;

    int main()
    {
        int n,p,now;
        string s;
        cin>>n>>s>>p;
        string t=s;
        sort(t.begin(),t.end());
        for(int i=1;i<=n;i++)
        {
            if(t[i]==s[p-1])
            {
                now=i;
                t[i]='$';
                break;
            }
        }
        string ans;
        ans.resize(10005);
        ans[0]=s[now];
        for(int i=1;i<n;i++)
        {
            for(int j=n-1;j>=0;j--)
            {
                if(t[j]==s[now])
                {
                    now=j;
                    ans[i]=s[now];
                    t[j]='$';
                    break;
                }
            }
        }
        for(int i=n-1;i>=0;i--)
        {
            cout<<ans[i];
        }
        return 0;
    }
    ```
    - **核心代码实现思想**：对输入字符串 $s$ 复制一份并排序得到 $t$，通过 $p$ 找到起始位置 $now$，在循环中从后往前在 $t$ 中找与当前 $s[now]$ 相同的字符确定前一个字符，记录到 $ans$ 中，最后倒序输出 $ans$。

### 最优关键思路或技巧
利用字符串排序后首字母与尾字母的对应关系，采用倒推方式还原原字符串，避免在无序字符串中查找字符导致的错位问题。同时，在代码实现中，合理利用标记数组或改变已使用字符来防止重复查找。

### 可拓展思路
此类题目属于字符串模拟与逆向推导类型。类似套路可应用于其他字符串变换后逆向还原的题目，例如涉及字符串旋转、替换等操作后要求还原原串的问题。关键在于理解变换规则，找到正向变换与逆向还原之间的逻辑联系，通过合适的数据结构和算法实现。

### 相似知识点洛谷题目
- [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)：涉及字符串处理与校验规则应用。
- [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)：考察字符串查找与统计。
- [P1593 因子和阶乘](https://www.luogu.com.cn/problem/P1593)：结合数论与字符串处理，计算阶乘中特定因子的个数并以字符串形式输出。 

---
处理用时：47.53秒
# 题目信息

# 表达式的转换

## 题目描述

平常我们书写的表达式称为中缀表达式，因为它将运算符放在两个操作数中间，许多情况下为了确定运算顺序，括号是不可少的，而后缀表达式就不必用括号了。

后缀标记法：书写表达式时采用运算紧跟在两个操作数之后，从而实现了无括号处理和优先级处理，使计算机的处理规则简化为：从左到右顺序完成计算，并用结果取而代之。

例如：`8-(3+2*6)/5+4` 可以写为：`8 3 2 6 * + 5 / - 4 +`

其计算步骤为：

```
8 3 2 6 * + 5 / - 4 +
8 3 12 + 5 / - 4 +
8 15 5 / - 4 +
8 3 - 4 +
5 4 +
9
```

编写一个程序，完成这个转换，要求输出的每一个数据间都留一个空格。

## 说明/提示

运算的结果可能为负数，`/` 以整除运算。并且中间每一步都不会超过 $2^{31}$。字符串长度不超过 $100$。

注意乘方运算 `^` 是从右向左结合的，即 `2 ^ 2 ^ 3` 为 `2 ^ (2 ^ 3)`，后缀表达式为 `2 2 3 ^ ^`。

其他同优先级的运算是从左向右结合的，即 `4 / 2 / 2 * 2` 为 `((4 / 2) / 2) * 2`，后缀表达式为 `4 2 / 2 / 2 *`。

保证不会出现计算乘方时幂次为负数的情况，故保证一切中间结果为整数。

## 样例 #1

### 输入

```
8-(3+2*6)/5+4
```

### 输出

```
8 3 2 6 * + 5 / - 4 + 
8 3 12 + 5 / - 4 + 
8 15 5 / - 4 + 
8 3 - 4 + 
5 4 + 
9
```

## 样例 #2

### 输入

```
2^2^3
```

### 输出

```
2 2 3 ^ ^
2 8 ^
256
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕将中缀表达式转换为后缀表达式并计算这一核心任务。思路上，多数题解采用栈来处理运算符优先级和括号匹配，部分使用表达式树或分治思想。算法要点包括定义运算符优先级函数、按规则处理不同类型字符（数字、运算符、括号），计算后缀表达式时按顺序处理运算符和操作数。解决难点在于处理乘方运算的右结合性、括号匹配以及正确实现后缀表达式的计算过程。

从质量上看，sunyizhe的题解思路清晰，对每个步骤详细模拟并给出具体代码实现，代码可读性高；xuhanxi_dada117使用表达式树，虽思路独特但代码理解难度稍大；ShenTianYi_ 的题解使用基础语法，便于理解但代码实现稍显繁琐；rui_er的题解逻辑清晰，利用结构体和向量存储后缀表达式；icaijy用双向队列代替栈，代码长但适合初学者理解；NeosKnight全真模拟，代码复杂；technopolis_2085未用栈，采用分治和字符串交替模拟，实现复杂且易错。

### 所选的题解
- **sunyizhe（5星）**
    - **关键亮点**：思路阐述极为清晰，通过详细模拟后缀表达式转换过程，对各种情况（如运算符优先级、括号处理、乘方特殊情况）进行全面分析，代码实现完整且注释详细，可读性高。
    - **个人心得**：无
    - **核心代码**
```cpp
int check(char c) {
    switch(c) {
        case '+':return 1;
        case '-':return 1;
        case '*':return 2;
        case '/':return 2;
        case '^':return 3;
        case '(':return 0;
        case ')':return 0;
        default:return -1;
    }
}
int js(int x,int y,char t) {
    switch(t) {
        case '+':return x+y;
        case '-':return x-y;
        case '*':return x*y;
        case '/':return x/y;
        case '^':return pow(x,y);
        default:return -0x3f3f3f3f;
    }
}
void change(string s) {
    int len=s.size();
    for(int i=0;i<len;i++) {
        if(isdigit(s[i]))dat.push(s[i]);
        else if(s[i]=='(')op.push(s[i]);
        else if(s[i]==')') {
            char t=op.top();
            while(t!='(') {
                op.pop();
                dat.push(t);
                t=op.top();
            }
            op.pop();
        }
        else if(check(s[i])>=1&&check(s[i])<=3) {
            if(!op.empty()) {
                char t=op.top();
                while(!op.empty()&&check(s[i])<=check(t)) {
                    if(check(s[i])==check(t)&&s[i]=='^')break;
                    op.pop();
                    dat.push(t);
                    if(!op.empty())t=op.top();
                }
            }
            op.push(s[i]);
        }
    }
    while(!op.empty()) {
        char t=op.top();
        op.pop();
        dat.push(t);
    }
    while(!dat.empty()) {
        char t=dat.top();
        dat.pop();
        op.push(t);
    }
    while(!op.empty()) {
        char t=op.top();
        cout<<t<<' ';
        op.pop();
        dat.push(t);
    }
    cout<<endl;
}
void calc() {
    while(!dat.empty()) {
        char t=dat.top();
        dat.pop();
        op.push(t);
    }
    while(!op.empty()) {
        char t=op.top();
        op.pop();
        if(isdigit(t))num.push(t-'0');
        else {
            int x=num.top();
            num.pop();
            int y=num.top();
            num.pop();
            num.push(js(y,x,t));
            while(!num.empty()) {
                int t=num.top();
                num.pop();
                dat2.push(t); 
            }
            while(!dat2.empty()) {
                int t=dat2.top();
                cout<<t<<' ';
                dat2.pop();
                num.push(t);
            }
            while(!op.empty()) {
                char t=op.top();
                cout<<t<<' ';
                op.pop();
                dat.push(t);
            }
            while(!dat.empty()) {
                char t=dat.top();
                dat.pop();
                op.push(t);
            }
            cout<<endl;
        }
    }
}
```
核心实现思想：`check`函数定义运算符优先级；`change`函数遍历中缀表达式，按规则将数字、运算符、括号分别处理并存入相应栈，最终得到后缀表达式；`calc`函数计算后缀表达式，按顺序处理运算符和操作数，并输出计算过程。
- **rui_er（4星）**
    - **关键亮点**：逻辑清晰，先定义运算符优先级函数，通过遍历字符串按规则将中缀表达式转换为后缀表达式，使用结构体和向量存储后缀表达式，计算后缀表达式部分思路明确，代码简洁。
    - **个人心得**：开始未注意到乘方运算符，通过仔细对比代码和题面才发现。
    - **核心代码**
```cpp
int priority(char c) {
    if(c == '^') return 3;
    if(c == '*' || c == '/') return 2;
    if(c == '+' || c == '-') return 1;
    if(c == '(' || c == ')') return 0;
    throw "WA! Unexpected operator";
}
struct Node {
    int type;
    union {
        int x;
        char op;
    }data;
    Node() {}
    Node(int x) : type(1) {data.x = x;}
    Node(char c) : type(0) {data.op = c;}
};
void toSuffix() {
    rep(i, 0, n-1) {
        if(isdigit(c[i])) v.push_back(Node(int(c[i]^'0')));
        else {
            if(c[i] == '(') op.push(c[i]);
            else if(c[i] == ')') {
                while(op.top()!= '(') {
                    v.push_back(Node(char(op.top())));
                    op.pop();
                }
                op.pop();
            }
            else if(c[i] == '^') op.push(c[i]);
            else {
                while(!op.empty() && priority(op.top()) >= priority(c[i])) {
                    v.push_back(Node(char(op.top())));
                    op.pop();
                }
                op.push(c[i]);
            }
        }
    }
    while(!op.empty()) {
        v.push_back(Node(char(op.top())));
        op.pop();
    }
}
void prtall() {
    int sz = v.size();
    rep(i, 0, sz-1) {
        if(v[i].type) printf("%d%c", v[i].data.x, " \n"[i==sz-1]);
        else printf("%c%c", v[i].data.op, " \n"[i==sz-1]);
    }
}
void prtsec(int u) {
    int sz = v.size();
    while(!s.empty()) {t.push(s.top()); s.pop();}
    while(!t.empty()) {printf("%d ", t.top()); s.push(t.top()); t.pop();}
    rep(i, u, sz-1) {
        if(v[i].type) printf("%d ", v[i].data.x);
        else printf("%c ", v[i].data.op);
    }
    puts("");
}
void calc() {
    prtall();
    int sz = v.size();
    rep(i, 0, sz-1) {
        if(v[i].type) s.push(v[i].data.x);
        else {
            int a, b; char _;
            b = s.top(); s.pop();
            a = s.top(); s.pop();
            _ = v[i].data.op;
            if(_ == '+') s.push(a+b);
            else if(_ == '-') s.push(a-b);
            else if(_ == '*') s.push(a*b);
            else if(_ == '/') s.push(a/b);
            else s.push(qpow(a, b));
            prtsec(i+1);
        }
    }
}
```
核心实现思想：`priority`函数确定运算符优先级；`toSuffix`函数遍历中缀表达式，按字符类型分别处理，将后缀表达式存入向量`v`；`calc`函数按顺序处理后缀表达式中的运算符和操作数，实现计算并输出过程。
- **ShenTianYi_ （4星）**
    - **关键亮点**：使用基础语法实现，对每个步骤解释详细，通过具体例子展示中缀转后缀以及后缀表达式计算过程，便于初学者理解。
    - **个人心得**：无
    - **核心代码**
```cpp
int pr(char x) {
    if(x=='^') {
        return 3;
    }
    else if(x=='*' || x=='/') {
        return 2;
    }
    else if(x=='+' || x=='-') {
        return 1;
    }
    else {
        return 0;
    }
}
char pushs(char x) {
    stack[++lens]=x;
    return x;
}
char pops() {
    char ret=stack[lens];
    stack[lens--]=0;
    return ret;
}
char pushf(char x) {
    f[++lenf]=x;
    return x;
}
char popf() {
    char ret=f[lenf];
    f[lenf--]=0;
    return ret;
}
for(int i=1;i<=n;i++) {
    if(s[i]>='0' && s[i]<='9') {
        pushf(s[i]);
    }
    else if(s[i]=='^' || s[i]=='(') {
        pushs(s[i]);
    }
    else if(s[i]=='+' || s[i]=='-' || s[i]=='*' || s[i]=='/') {
        int t=pr(s[i]);
        for(int j=lens;j>=1;j--) {
            if(pr(stack[j])<t) {
                break;
            }
            else {
                pushf(pops());
            }
        }
        pushs(s[i]);
    }
    else if(s[i]==')') {
        for(int j=lens;j>=1;j--) {
            if(stack[j]=='(') {
                pops();
                break;
            }
            else {
                pushf(pops());
            }
        }
    }
}
while(lens) {
    pushf(pops());
}
for(int i=1;i<=lenf;i++) {
    cout<<f[i]<<" ";
}
cout<<endl;
```
```cpp
struct Node {
    bool is_digit;
    int dg;
    char ch;
};
Node pushc(Node x) {
    c[++lenc]=x;
    return x;
}
Node popc() {
    Node ret=c[lenc];
    c[lenc--]=init;
    return ret;
}
Node pushcalc(Node x) {
    calc[++lencalc]=x;
    return x;
}
Node popcalc() {
    Node ret=calc[lencalc];
    calc[lencalc--]=init;
    return ret;
}
void print2(int ii) {
    for(int i=1;i<=lencalc;i++) {
        if(calc[i].is_digit) {
            cout<<calc[i].dg<<" ";
        }
        else {
            cout<<calc[i].ch<<" ";
        }
    }
    for(int i=ii;i<=lenc;i++) {
        if(c[i].is_digit) {
            cout<<c[i].dg<<" ";
        }
        else {
            cout<<c[i].ch<<" ";
        }
    }
    cout<<endl;
}
for(int i=1;i<=lenf;i++) {
    char x=f[i];
    Node m;
    if(x=='+' || x=='-' || x=='*' || x=='/' || x=='^') {
        m.is_digit=0;
        m.ch=x;
        m.dg=0;
    }
    else {
        m.is_digit=1;
        m.ch=0;
        m.dg=x-48;
    }
    pushc(m);
}
for(int i=1;i<=lenc;i++) {
    Node m=c[i];
    if(m.is_digit) {
        pushcalc(m);
    }
    else {
        int x1,x2;
        Node r;
        r.is_digit=1;
        r.ch=0;
        x1=popcalc().dg;
        x2=popcalc().dg;
        switch(m.ch) {
            case '+':
                r.dg=x2+x1;
                break;
            case '-':
                r.dg=x2-x1;
                break;
            case '*':
                r.dg=x2*x1;
                break;
            case '/':
                r.dg=x2/x1;
                break;
            case '^':
                r.dg=1;
                for(int j=0;j<x1;j++) {
                    r.dg*=x2;
                }
        }
        pushcalc(r);
        print2(i+1);
    }
}
```
核心实现思想：`pr`函数确定运算符优先级；通过自定义栈操作函数，在遍历中缀表达式时按规则处理字符，得到后缀表达式；定义结构体`Node`存储数字和运算符，在计算后缀表达式时按顺序处理运算符和操作数，并输出计算过程。

### 最优关键思路或技巧
使用栈来处理中缀表达式到后缀表达式的转换是核心技巧。通过定义运算符优先级函数，在遍历中缀表达式时，依据字符类型（数字、运算符、括号）和优先级规则，将运算符和操作数合理存入栈中，最终得到后缀表达式。计算后缀表达式时，同样利用栈按顺序处理运算符和操作数，实现计算。这种基于栈的处理方式简洁高效，能有效处理运算符优先级和括号匹配问题。

### 同类型题或类似算法套路
此类题目通常围绕表达式的转换与计算，常见套路是利用栈处理运算符优先级和括号。类似题目可能涉及前缀表达式、后缀表达式、中缀表达式之间的相互转换，以及表达式的求值。解决这类问题关键在于清晰定义运算符优先级，并按规则处理不同类型字符。

### 推荐题目
- **P1449 后缀表达式**：通过栈实现后缀表达式的计算，与本题后缀表达式计算部分类似。
- **P3393 逃离僵尸岛**：涉及中缀表达式求值，需处理运算符优先级和括号。
- **P2032 扫描线**：虽主要考察扫描线算法，但在处理几何图形面积计算时，涉及表达式的解析与计算，与本题有相似的表达式处理思路。

### 个人心得摘录与总结
rui_er提到开始未注意到乘方运算符，通过仔细对比代码和题面才发现。这提醒在解题时要仔细审题，关注特殊运算符或条件，避免因疏忽导致错误。 

---
处理用时：93.12秒
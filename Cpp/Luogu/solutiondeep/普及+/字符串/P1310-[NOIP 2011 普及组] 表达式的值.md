# 题目信息

# [NOIP 2011 普及组] 表达式的值

## 题目描述

对于1 位二进制变量定义两种运算：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|} \hline
\kern{5em}\mathclap\textsf{运算符}\kern{5em} & \kern{5em}\mathclap\textsf{运算规则}\kern{5em} \\ \hline
\oplus &
\begin{aligned}
0 \oplus 0 &= 0 \\
0 \oplus 1 &= 1 \\
1 \oplus 0 &= 1 \\
1 \oplus 1 &= 1 \\
\end{aligned} \\ \hline
\times &
\begin{aligned}
0 \times 0 &= 0 \\
0 \times 1 &= 0 \\
1 \times 0 &= 0 \\
1 \times 1 &= 1 \\
\end{aligned} \\ \hline
\end{array}
$$

运算的优先级是：

1. 先计算括号内的，再计算括号外的。

2. “× ”运算优先于“⊕”运算，即计算表达式时，先计算× 运算，再计算⊕运算。例如：计算表达式A⊕B × C时，先计算 B × C，其结果再与 A 做⊕运算。

现给定一个未完成的表达式，例如\_+(\_\*\_)，请你在横线处填入数字$0 $或者$1$ ，请问有多少种填法可以使得表达式的值为$0 $。


## 说明/提示

【输入输出样例说明】

  给定的表达式包括横线字符之后为：\_+(\_\*\_) 

  在横线位置填入(0 、0 、0) 、(0 、1 、0) 、(0 、0 、1) 时，表达式的值均为0 ，所以共有3种填法。 

【数据范围】

对于 $20\%$ 的数据有 $ 0 \le L \le 10$。

对于 $50\%$ 的数据有 $0 \le L \le 1,000$。

对于 $70\%$ 的数据有 $ 0 \le L \le 10,000$ 。

对于 $100\%$的数据有 $ 0 \le L \le 100,000$。

对于$50\%$ 的数据输入表达式中不含括号。


## 样例 #1

### 输入

```
4
+(*)
```

### 输出

```
3
```

# AI分析结果

这道题主要考查对特定运算规则和优先级的表达式求值，并计算使表达式值为0的填法数量。各题解思路和方法可总结如下：
1. **神犇的蒟蒻**：利用两个栈分别存放结果和符号，根据表达式计算方法并结合本题运算规则，在栈中存放算到0或1时的方案数，最后得出结果为0的方案数。代码通过模拟栈操作实现。
2. **Drinkkk**：同样使用栈来解决问题，一个符号栈存储操作符，两个数字栈分别表示当前运算结果为0和1的方案数。按照运算优先级和括号规则进行弹栈和计算。
3. **zy_turtle**：最初尝试按加号分块再算乘法可能个数，但因MLE未通过。后采用栈将中序表达式转换为后缀表达式，用两个栈分别存储运算符和数字情况个数，依据运算规则更新方案数。
4. **junxis**：先通过递归建树结合树形DP获取80分，后分析TLE原因是建表达式树的复杂度为$O(n^2)$，使用线段树维护优先级最小的字符位置，将建树复杂度优化为$O(nlogn)$从而AC。
5. **Walrus**：思路是依靠运算优先级建表达式树，通过差分计算每个点优先级，用单调栈维护建笛卡尔树，复杂度为$O(N)$，再进行DP。
6. **LINYUHENG2**：整体框架基于表达式计算，不同在于添加数字位置限制、运算优先级及计算为0或1的方案数规则，使用两个栈分别存放结果和符号进行模拟。
7. **Otue**：用笛卡尔树解决，根据括号计算运算符优先级来建立笛卡尔树，在树上进行DP，定义$f_{u,0/1}$表示子树计算答案为0或1的方案数并按运算符分类转移。
8. **sjh0626**：通过样例分析建一棵树，根据运算符推出树形DP方程，边运算边取模，按优先级处理计算可能性。
9. **xmy201315**：利用树形DP，在每个子树空格处填入0和1，根据运算符计算得到结果0和1的方案数。
10. **MMXIandCCXXII**：把题目当作普通表达式求值，维护结果为0和1的方案数，依据运算规则，利用乘法和加法原理，通过栈操作实现。

综合来看，各题解思路主要围绕栈操作、树形DP以及笛卡尔树等方法。其中，junxis和Walrus、Otue的题解在算法优化上较为突出，通过合理利用数据结构优化了复杂度，质量较高，评分为5星。

### 所选题解1：junxis
- **星级**：5星
- **关键亮点**：先给出80分的递归建树结合树形DP解法，思路清晰易懂；后分析TLE原因并利用线段树优化建树过程，将复杂度从$O(n^2)$优化到$O(nlogn)$，方法巧妙且具有学习价值。
```cpp
// 建树部分核心代码
int expTree(int l,int r,int cnt) {
    int x=0,y=0,u;
    if(l>r) {
        u=++tot;
        Exp[u].lc=Exp[u].rc=0;
        return u;
    } 
    int pos=query(1,l,r);
    if(priority[pos]-2*cnt>2) return expTree(l+1,r-1,cnt+1); 
    u=++tot;
    Exp[u].lc=expTree(l,pos-1,cnt);
    Exp[u].rc=expTree(pos+1,r,cnt);
    Exp[u].op=s[pos];
    return u;
}
// dp部分核心代码
void dp(int u) {
    if(Exp[u].lc==0&&Exp[u].rc==0) {
        f[u][0]=f[u][1]=1;
        return ;
    }
    int x=Exp[u].lc,y=Exp[u].rc;
    dp(x);dp(y);
    if(Exp[u].op=='+') {
        f[u][0]=f[x][0]*f[y][0]%mod;
        f[u][1]=(f[x][0]*f[y][1]+f[x][1]*f[y][0]+f[x][1]*f[y][1])%mod;
    }
    if(Exp[u].op=='*') {
        f[u][1]=(f[x][1]*f[y][1])%mod;
        f[u][0]=(f[x][0]*f[y][1]+f[x][1]*f[y][0]+f[x][0]*f[y][0])%mod;
    }
    return ;
}
```
核心实现思想：建树时通过线段树查询区间内优先级最小的操作符位置，确定当前节点；DP时根据节点运算符不同，按照转移方程更新该节点取值为0或1的方案数。

### 所选题解2：Walrus
- **星级**：5星
- **关键亮点**：通过差分计算每个点的优先级，利用单调栈维护建笛卡尔树，将建树复杂度优化到$O(N)$，高效解决问题，同时清晰给出DP状态转移方程。
```cpp
// 差分计算优先级及建笛卡尔树核心代码
stack<int> ss;
rep(i, 1, n) {
    if(s[i] == '(') ss.push(i);
    if(s[i] == ')') b[ss.top()] += 2, b[i + 1] -= 2, ss.pop();
}
rep(i, 1, n) b[i] += b[i - 1], a[i] = b[i] + (s[i] == '*'? 2 : 1); 

void init(int *a) {
    rep(i, 1, n) {
        if(s[i] == '(' || s[i] == ')') continue;
        while(top && a[st[top]] > a[i]) ch[i][0] = st[top--];
        if(top) ch[st[top]][1] = i;
        st[++top] = i;
    } 
}
// DP核心代码（以位与运算为例）
dp_{x,1}=dp_{ls,1}\times dp_{rs,1}
dp_{x,0}=dp_{ls,0}\times dp_{rs,1}+dp_{ls,1}\times dp_{rs,0}+dp_{ls,0}\times dp_{rs,0}
```
核心实现思想：先通过差分得到每个运算符的优先级，在建笛卡尔树时，利用单调栈找到每个节点的左右子节点；DP时根据位与和位或的运算性质得出状态转移方程，计算结果为0或1的方案数。

### 所选题解3：Otue
- **星级**：5星
- **关键亮点**：利用笛卡尔树解决问题，清晰阐述通过括号计算运算符优先级来建立笛卡尔树的方法，树形DP部分的状态转移方程明确，代码简洁明了。
```cpp
// 计算优先级及建笛卡尔树核心代码
_for(i, 1, n) { 
    if (a[i] == '(') p++;
    if (a[i] == ')') p--;
    if (a[i] == '*') {
        val[++cnt] = 2 * p + 2;
        op[cnt] = 2;
    }
    if (a[i] == '+') {
        val[++cnt] = 2 * p + 1;
        op[cnt] = 1;
    }
}
_for(i, 1, cnt) { 
    int k = top;
    while (val[stk[k]] >= val[i] && k) k--;
    if (k) rs[stk[k]] = i;
    if (k < top) ls[i] = stk[k + 1];
    stk[++k] = i;
    top = k;
}
// 树形DP核心代码
void dfs(int u) { 
    if (u == 0) return;
    dfs(ls[u]); dfs(rs[u]);
    if (op[u] == 1) {
        f[u][0] = f[ls[u]][0] * f[rs[u]][0] % mod;
        f[u][1] = (f[ls[u]][0] * f[rs[u]][1] % mod + f[ls[u]][1] * f[rs[u]][0] % mod + f[ls[u]][1] * f[rs[u]][1] % mod) % mod;
    }
    else {
        f[u][0] = (f[ls[u]][0] * f[rs[u]][1] % mod + f[ls[u]][1] * f[rs[u]][0] % mod + f[ls[u]][0] * f[rs[u]][0] % mod) % mod;
        f[u][1] = f[ls[u]][1] * f[rs[u]][1] % mod;
    }
}
```
核心实现思想：先根据括号计算每个运算符的优先级，在建笛卡尔树过程中，通过比较优先级确定父子节点关系；树形DP时根据当前节点运算符类型，按照转移方程计算子树计算结果为0或1的方案数。

### 最优关键思路或技巧
利用笛卡尔树结合树形DP是较优的方法，通过合理计算运算符优先级并建立笛卡尔树，能有效处理表达式的运算顺序，树形DP则方便地计算出不同结果的方案数。同时，利用差分、线段树等优化手段可以进一步提升算法效率。

### 可拓展思路
此类题目属于表达式计算与方案计数结合的问题，类似套路包括利用栈模拟运算过程、通过树形结构处理优先级、运用动态规划计算方案数等。同类型题可能会改变运算规则、优先级或者数据规模，需要灵活运用上述方法解决。

### 相似知识点洛谷题目
1. [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)：通过栈将中缀表达式转换为后缀表达式并求值，考查栈的应用和表达式计算。
2. [P3393 逃离僵尸岛](https://www.luogu.com.cn/problem/P3393)：涉及表达式计算和简单的逻辑判断，与本题在表达式处理上有相似之处。
3. [P2024 [NOI2001] 食物链](https://www.luogu.com.cn/problem/P2024)：通过并查集维护逻辑关系，同时也涉及到类似表达式计算中的逻辑判断和状态转移，与本题树形DP的思维方式有一定相似性。 

---
处理用时：61.87秒
# 题目信息

# 单词背诵

## 题目描述

灵梦有 $n$ 个单词想要背，但她想通过一篇文章中的一段来记住这些单词。

文章由 $m$ 个单词构成，她想在文章中找出连续的一段，其中包含最多的她想要背的单词（重复的只算一个）。并且在背诵的单词量尽量多的情况下，还要使选出的文章段落尽量短，这样她就可以用尽量短的时间学习尽可能多的单词了。

## 说明/提示

### 数据规模与约定

- 对于 $30\%$ 的数据，$n \le 50$，$m \le 500$；
- 对于 $60\%$ 的数据，$n \le 300$，$m \le 5000$；
- 对于 $100\%$ 的数据，$n \le 1000$，$m \le 10^5$。

## 样例 #1

### 输入

```
3

hot

dog

milk

5

hot

dog

dog

milk

hot

```

### 输出

```
3

3

```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何在给定文章段落中找出包含最多目标单词且长度最短的子段落这一问题，采用了哈希、二分查找、尺取法、单调队列等多种方法。
1. **思路与算法要点**：
    - **哈希 + 尺取法**：多数题解采用此思路，先通过哈希将字符串转化为整数以便快速比较，用哈希表或数组记录目标单词。然后利用尺取法，通过移动左右端点扫描段落，动态维护包含目标单词的情况，更新最大单词数和最短长度。
    - **二分查找**：二分查找区间长度，在固定长度区间内利用类似滑动窗口思想判断该长度是否可行，从而找到最短满足条件的区间长度。
    - **单调队列**：维护一个队列，每次遇到单词压入队尾，弹出队头直到队头单词是最后一次出现位置，借此维护含最多单词且左端点尽可能靠右的区间。
2. **解决难点**：
    - **高效判断单词**：通过哈希减少字符串匹配时间，部分题解用map或unordered_map进一步优化查找。
    - **寻找最短区间**：尺取法能在线性时间内找到最短区间；二分查找通过单调性确定最短长度；单调队列通过维护队列特性找到最优区间。

### 所选的题解
1. **作者：louhao088 (5星)**
    - **关键亮点**：思路清晰，代码简洁高效。使用map + string实现哈希，记录单词出现情况，通过简单逻辑更新最大单词数和最短长度，时间复杂度为\(O(m \log m)\)。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>sum;
map<string,bool>flag;
int ans1,ans2,n,m,l;
string s[100005],s1; 
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>s1,flag[s1]=1;
    cin>>m;l=1;
    for(int i=1;i<=m;i++)
    {
        cin>>s[i];
        if(flag[s[i]])sum[s[i]]++;
        if(sum[s[i]]==1)ans1++,ans2=i - l + 1;
        while(l<=i)
        {
            if(!flag[s[l]]){l++;continue;}
            if(sum[s[l]]>=2){sum[s[l]]--,l++;continue;}
            break;
        }
        ans2=min(ans2,i - l + 1);
    }
    cout<<ans1<<endl<<ans2<<endl;
    return 0;
}
```
    - **核心实现思想**：用`flag`标记目标单词，遍历文章单词，若为目标单词则`sum`计数，首次出现更新最大单词数和长度。通过`while`循环调整左端点，保证区间最短，每次循环更新最短长度。
2. **作者：早右昕 (4星)**
    - **关键亮点**：明确指出是尺取法模板题，详细描述尺取法过程，代码实现简洁，时间复杂度为\(O(n)\)。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int P = 10000019;
int str_hash(char* a) {
    int ln = strlen(a);
    long long res = 0;
    for (int i = 0; i < ln; i++) {
        res *= 31, res += a[i] - 'a';
        res %= P;
    }
    return res % P;
}
int n, m, p1, p2 = 1 << 30;
int a[1001], b[100010];
int vis[P];
bool need[P];
int main() {
    char in[101];
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%s", in);
        a[i] = str_hash(in);
        need[a[i]] = 1;
    }
    scanf("%d", &m);
    for (int i = 1; i <= m; i++) {
        scanf("%s", in);
        b[i] = str_hash(in);
        if (need[b[i]] &&!vis[b[i]]) {
            p1++, vis[b[i]] = 1;  
        }
    }
    if (p1 == 0) {
        printf("0\n0\n");
        return 0;
    }
    memset(vis, 0, sizeof vis);
    int l = 1, r = 1, cnt = p1;
    while (1) {
        if (!cnt) {
            while (!need[b[l]]) l++;
            if (l == m + 1) break;
            p2 = min(p2, r - l);
            if (vis[b[l]] == 1) cnt++;
            if (vis[b[l]] >= 1) vis[b[l]]--, l++; 
        }
        else {
            if (r == m + 1) break;
            if (need[b[r]]) {
                if (!vis[b[r]]) cnt--;
                vis[b[r]]++;
            }
            r++;
        }
    }
    printf("%d\n%d\n", p1, p2);
    return 0;
}
```
    - **核心实现思想**：先通过哈希标记目标单词并统计出现种类数`p1`。然后用尺取法，`l`和`r`为左右端点，`cnt`记录还需包含的目标单词种类数。右移`r`增加目标单词，当`cnt`为0时尝试缩小左端点`l`，更新最短长度`p2`。
3. **作者：梧桐灯 (4星)**
    - **关键亮点**：推荐使用unordered_map优化查找，代码简洁明了，利用unordered_map特性结合尺取法解决问题。
    - **个人心得**：无
    - **重点代码**：
```cpp
#pragma GCC optimize("Ofast")
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <string>
#include <unordered_map> 
using namespace std;

const int N = 1003, M = 100003;
unordered_map <string, int> w, k; 
int n, m;
string a[N], b[M];

int main () {
    scanf ("%d", &n);
    int i, j; for (i = 1; i <= n; ++i) {
        cin >> a[i];
        ++w[a[i]];
    }
    scanf ("%d", &m);
    for (i = 1; i <= m; ++i) cin >> b[i];
    i = j = 1;
    int now = 0;
    int ans = 0, minlen = (1 << 30);
    while (j <= m) {
        if (w[b[j]] &&!k[b[j]]) {
            ++now;
            k[b[j]] = 1;
        } 
        else ++k[b[j]]; 
        while (i <= j && (!w[b[i]] || k[b[i]] > 1)) {
            --k[b[i]];
            ++i;
        } 
        if (now > ans) {
            ans = now;
            minlen = j - i + 1;
        }
        else if (now == ans) minlen = min (minlen, j - i + 1);
        ++j;
    }
    printf ("%d\n%d\n", ans, minlen);
    return 0;
}
```
    - **核心实现思想**：用`w`记录目标单词，遍历文章单词，若为目标单词且首次在当前区间出现则`now`增加。通过`while`循环调整左端点，保证区间最短，根据`now`更新最大单词数`ans`和最短长度`minlen`。

### 最优的关键思路或技巧
1. **数据结构**：使用哈希表（如map、unordered_map）或数组记录单词，加快单词查找与统计，unordered_map理论访问时间为\(O(1)\)，效率更高。
2. **算法优化**：尺取法在线性时间内扫描序列，动态维护满足条件区间，高效找到最短区间。二分查找利用区间长度单调性，减少搜索范围。
3. **思维方式**：分析问题特性，如单词匹配的高效性、区间长度的单调性，从而选择合适算法。

### 可拓展之处
同类型题常涉及在序列中寻找满足特定条件的最短或最长子序列，类似算法套路有尺取法、滑动窗口、二分查找等。例如在一些字符串匹配、数组元素统计问题中可应用。

### 相似知识点洛谷题目
1. **P1886 滑动窗口**：涉及滑动窗口思想，与本题尺取法类似，需在数组中找到满足条件的区间。
2. **P2032 扫描**：通过扫描序列，利用类似尺取法思路解决问题，考察对序列的处理和优化。
3. **P3957 [NOIP2017 普及组] 跳房子**：可利用二分查找答案，结合区间判断，与本题二分查找区间长度思路相似。

### 个人心得摘录与总结
1. **作者：Merak**：强调细节重要性，因细节问题WA多次，提醒注意边界条件和特殊情况处理，如未出现目标单词时的特判。 

---
处理用时：67.50秒
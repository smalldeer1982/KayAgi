# 题目信息

# [USACO2.3] 最长前缀 Longest Prefix

## 题目描述

在生物学中，一些生物的结构是用包含其要素的大写字母序列来表示的。生物学家对于把长的序列分解成较短的序列（即元素）很感兴趣。

如果一个集合 $P$ 中的元素可以串起来（元素可以重复使用）组成一个序列 $s$ ，那么我们认为序列 $s$ 可以分解为 $P$ 中的元素。元素不一定要全部出现（如下例中 `BBC` 就没有出现）。举个例子，序列 `ABABACABAAB` 可以分解为下面集合中的元素：`{A,AB,BA,CA,BBC}`

序列 $s$ 的前面 $k$ 个字符称作 $s$ 中长度为 $k$ 的前缀。设计一个程序，输入一个元素集合以及一个大写字母序列  ，设 $s'$ 是序列 $s$ 的最长前缀，使其可以分解为给出的集合 $P$ 中的元素，求 $s'$ 的长度 $k$。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le \text{card}(P) \le 200$，$1\le |S| \le 2\times 10^5$，$P$ 中的元素长度均不超过 $10$。

翻译来自NOCOW

USACO 2.3


## 样例 #1

### 输入

```
A AB BA CA BBC
.
ABABACABAABC
```

### 输出

```
11
```

# AI分析结果

这道题主要求解给定字符串的最长前缀，该前缀可由给定集合中的元素组成。众多题解主要围绕动态规划（DP）展开，部分结合KMP、AC自动机、字典树（Trie）等算法优化匹配过程。

1. **思路与算法要点**：
    - **DP思路**：多数题解采用DP，核心是用数组（如`f[i]`）记录前`i`个字符能否由集合元素组成。状态转移条件为存在`j < i`，使`f[j]`为真且`S[j + 1, i]`是集合中的元素。
    - **优化匹配**：
        - **KMP优化**：利用KMP算法标记每个元素在字符串中出现的位置，辅助DP判断前缀合法性。
        - **AC自动机**：构建AC自动机处理多模式串匹配，通过跳`fail`边转移状态。
        - **字典树（Trie）**：将集合元素构建成Trie树，快速判断子串是否在集合中。
2. **解决难点**：
    - **高效匹配**：如何快速判断字符串的子串是否在给定集合中，不同算法通过各自的数据结构和匹配方式优化。
    - **状态转移**：准确理解和实现DP的状态转移条件，确保正确判断前缀的合法性。
3. **题解评分**：
    - **作者：hhjtutuhe (赞：112)**：思路清晰阐述DP原理及状态转移方程，给出代码并提及优化方向，代码可读性尚可。评分：4星。
    - **作者：momo5440 (赞：85)**：在DP基础上，利用`set`容器优化匹配，按长度分类集合元素，减少比较次数，代码简洁且注释详细。评分：4星。
    - **作者：pmt2018 (赞：8)**：提出用字符串`hash`优化DP，将字符串转化为`hash`值，实现O(1)时间判断子串相等，思路新颖但代码相对复杂。评分：4星。
4. **最优关键思路或技巧**：利用数据结构优化子串匹配过程是关键。如`momo5440`题解中用`set`容器按长度分类元素，降低匹配复杂度；`pmt2018`题解中字符串`hash`实现快速子串相等判断。
5. **拓展**：此类题目属于字符串匹配与动态规划结合的问题，类似套路可用于解决多模式串匹配、字符串分解等问题。
6. **相似知识点洛谷题目**：
    - [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
    - [P2414 阿狸的打字机](https://www.luogu.com.cn/problem/P2414)
    - [P3808 【模板】AC自动机（简单版）](https://www.luogu.com.cn/problem/P3808)
7. **个人心得摘录**：
    - **resftlmuttmotw**：做题前应先看标签，避免盲目暴力求解导致TLE。在实现DP时，要注意边界条件和及时优化，如在判断子串相等且更新`dp`数组时及时`break`，避免不必要的循环。

### 所选4星题解
- **作者：hhjtutuhe**
    - **星级**：4星
    - **关键亮点**：清晰阐述DP思路与状态转移方程，提供参考代码并指出优化方向。
    - **核心代码片段**：
```cpp
bool Check(int p)
{
    for(int i=0;i<n;i++)
    {
        int t=P[i].size();
        if(p>=t && f[p-t] && P[i]==S.substr(p-t+1,t))
        {
            ans=p;
            return true;
        }
    }
    return false;
}
//...
for(int i=1;i<=S.size();i++)
    f[i]=Check(i);
```
核心思想：`Check`函数检查前`p`个字符能否由集合元素组成，通过遍历集合元素，判断当前位置`p`是否满足状态转移条件。主循环中调用`Check`更新`f`数组。

- **作者：momo5440**
    - **星级**：4星
    - **关键亮点**：在DP基础上，利用`set`容器优化匹配过程，按长度分类元素减少比较次数，代码简洁且注释详细。
    - **核心代码片段**：
```cpp
for (i=1;i<n.size();i++){//枚举子串 
    for (int j=min(i,m);j>=1;j--){
        string tt=n.substr(i-j+1,j);//截除子串 
        if (s[tt.size()].count(tt)==1&&dp[i-j]==1){//如果合法 
            ans=i;//必定是最大的 
            dp[i]=1;//本身也合法 
            break;//没必要搜下去了 
        }
    }
}
```
核心思想：外层循环枚举字符串位置，内层循环从当前位置向前截取不同长度子串，利用`set`容器快速判断子串是否在对应长度集合中，若前`i - j`个字符合法且当前子串合法，则更新`dp`数组和答案。

- **作者：pmt2018**
    - **星级**：4星
    - **关键亮点**：提出用字符串`hash`优化DP，将字符串转化为`hash`值，实现O(1)时间判断子串相等，思路新颖。
    - **核心代码片段**：
```cpp
for(int i=0;i<ss.length();i++){//dp转移
    if(i==0||dp[i-1]){//如果前i-1位可以转移 
        for(int j=1;j<=cnt;j++){
            if(l[j]+i>ss.length())continue;
            if(hash(hs,i+1,i+l[j])==hash(h[j],1,l[j])){//判断从第i位开始的文本串和第j个字符串是否相同 
                dp[i+l[j]-1]=true;//那么s[0~i+l[j]-1]也是它的一个前缀 
            }
        }
    }
}
```
核心思想：外层循环枚举字符串位置，若前`i - 1`位合法，则内层循环枚举集合元素，通过`hash`函数快速判断从`i`位开始长度为`l[j]`的子串与集合中第`j`个元素是否相等，若相等则更新`dp`数组。 

---
处理用时：48.27秒
# 题目信息

# 万能的OIH搜索

## 题目背景

以下皆为真实的故事。

OIH（Oi in hand <http://www.oiinhand.info/> ）是洛谷的官方战略合作伙伴。

洛谷的题目搜索功能（请看看上面的搜索框）、在线 IDE 功能均使用 OIH 的服务。

OIH 的搜索功能很强大，其庞大的数据库拥有 $8000+$ 道中外主流 OJ 的题目。只需要只言片语（题目名称、描述、甚至是测试数据）就可以很快的搜出这道题的出处（“改编题”的杀手）。

以后，OIH 还将收录全网上的题解（数量是万级别的），只要通过题目名称，就可以搜到这个题目的题解。

OIH 的目标是制作出一个适合 OIers 的 app。虽然 OIH 不是 OJ，但是 OIH 的辅助功能能够给 OIers 带来很大的便利。如果您有任何的 idea，请 @soha（oih 的作者）。

## 题目描述

经过多次谈判，kkksc03 终于取得了 OIH 搜索的接口，现在向 OIH 服务器发送了一个查询请求，返回了一道题目。

查询关键词是一句话，由汉字（我们用它的拼音代替）、空格（每个汉字之间都有空格）、半角标点组成。返回的题目也是这样的。kkksc03 希望将题目中的某些词语加粗。所谓词语，就是连续两个或以上汉字。比如说 `tao tao`,`zhai ping guo` 都是词语，而 `hao`,`ni,hao` 不是词语。如果一个在题目中出现的词语也在关键词中出现的词语，那么加粗。加粗的方法是在词语前加上 `<b>`，在词语后面加上一个 `</b>`。至于标点符号么加不加粗无所谓。kkksc03 希望添加标记（`<b>` `</b>`对）的数量尽可能少，而且每个标记之间的的字符数最少。

## 说明/提示

每个汉字不超过 $7$ 个英文字符。

关键字不超过 $100$ 个汉字。

返回的题目不超过 $1000$ 个汉字。

## 样例 #1

### 输入

```
Shang wang dou tmd bei ping ping an an he xie diao le.
Tian yao mie he xie, tui he xie bao ping an.  shang Wang sou suo jiu ping cha cha cha ,you       zhen       xiang!```

### 输出

```
Tian yao mie <b>he xie</b>, tui <b>he xie</b> bao <b>ping an.  shang Wang</b> sou suo jiu ping cha cha cha ,you       zhen       xiang!```

# AI分析结果

### 综合分析与结论
这两道题解都围绕在给定的两个字符串中，在一个字符串里找出另一个字符串中出现的词语并加粗的问题。
 - **思路方面**：二者都认识到可将多字词语转化为二字词语处理以简化问题。rzh123题解通过预处理每个汉字后有无标点，遍历两个字符串匹配二字词语并标记；intconstlee题解则利用map存储模式串中的二字词语，扫描匹配串标记可匹配的二字词语两端及中间，最后合并标记。
 - **算法要点**：都采用暴力扫描的方式，时间复杂度较高但能满足题目数据规模。都对字符串中的汉字、空格及标点进行了细致处理。
 - **解决难点**：二者都关注到词语的定义、标点处理、汉字大小写不敏感等难点。rzh123题解通过结构体记录每个汉字及后续字符信息，intconstlee题解通过标记法合并相邻或相交词语，处理方式不同但都有效解决难点。

综合来看，intconstlee题解思路表述更清晰，代码使用标准库且简洁，rzh123题解代码稍显复杂，变量命名不太直观。

### 所选的题解
 - **作者：intconstlee (5星)**
    - **关键亮点**：思路清晰，对题意理解透彻，巧妙利用map存储二字词语，通过标记法合并词语的方式简洁高效，代码简洁且使用标准库，可读性强。
    - **个人心得**：指出了题目中多个容易忽略的坑点，如词语定义、标点限制、大小写及空格长度敏感性等，强调仔细审题的重要性。
```cpp
#include<bits/stdc++.h>
using namespace std;
string s1,s2,tmp,lst;
map <string,int> mp;
int tot,cnt,num,tag[1005];
bool isletter(char s)
{return (s>='A'&&s<='Z')||(s>='a'&&s<='z');}
char nocapital(char s)
{return s>='A'&&s<='Z'?s-'A'+'a':s;}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    getline(cin,s1),getline(cin,s2);
    for(int i=0;i<s1.size();)
    {
        if(!isletter(s1[i]))
        {if(s1[i]!=' ') lst.clear(); i++;continue;}
        while(i<s1.size()&&isletter(s1[i]))
            tmp+=nocapital(s1[i]),i++;
        if(lst.empty()) {lst=tmp,tmp.clear();continue;}
        mp[lst+tmp]=++tot,lst=tmp,tmp.clear();
    }
    lst.clear();
    for(int i=0;i<s2.size();)
    {
        if(!isletter(s2[i]))
        {if(s2[i]!=' ') lst.clear(); i++;continue;}
        cnt++;
        while(i<s2.size()&&isletter(s2[i]))
            tmp+=nocapital(s2[i]),i++;
        if(lst.empty()) {lst=tmp,tmp.clear();continue;}
        if(mp[lst+tmp]) tag[cnt-2]+=1,tag[cnt-1]+=3,tag[cnt]+=2;
        lst=tmp,tmp.clear();
    }
    for(int i=0;i<s2.size();)
    {
        if(!isletter(s2[i])) {cout<<s2[i],i++;continue;}
        num++;
        if(tag[num-1]==1&&tag[num]!=2) cout<<"<b>";
        while(i<s2.size()&&isletter(s2[i])) cout<<s2[i],i++;
        if(tag[num]==2&&tag[num-1]!=1) cout<<"</b>";
    }
    return 0;
}
```
核心实现思想：首先遍历模式串s1，将其中的二字词语存入map。接着遍历匹配串s2，若出现与map中匹配的二字词语，就在对应位置做标记。最后再次遍历匹配串s2，根据标记添加加粗标签输出。

### 最优关键思路或技巧
将多字词语转化为二字词语处理，简化问题。利用map存储模式串中的二字词语，方便快速匹配。通过独特的标记法合并相邻或相交的词语，保证标记数量最少且字符间隔最小。

### 可拓展之处
同类型题常出现在字符串匹配、文本处理场景中，类似算法套路有KMP等字符串匹配算法，可用于更复杂的字符串匹配问题。但本题数据规模小，暴力解法即可。

### 相似知识点洛谷题目
 - [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
 - [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)
 - [P1502 窗口](https://www.luogu.com.cn/problem/P1502)

---
处理用时：34.71秒
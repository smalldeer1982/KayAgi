# 题目信息

# 有趣的数

## 题目描述

让我们来考虑 $1$ 到 $N$ 的正整数集合。让我们把集合中的元素按照字典序排列，例如当 $N=11$ 时，其顺序应该为：$1,10,11,2,3,4,5,6,7,8,9$。

定义 $K$ 在 $N$ 个数中的位置为 $Q(N,K)$，例如 $Q(11,2)=4$。现在给出整数 $K$ 和 $M$，要求找到最小的 $N$，使得 $Q(N,K)=M$。

## 说明/提示

【数据约定】


$40\%$ 的数据，$1 \le K,M \le 10^5$；

$100\%$ 的数据，$1 \le K,M \le 10^9$。


## 样例 #1

### 输入

```
2 4
```

### 输出

```
11
```

## 样例 #2

### 输入

```
100000001 1000000000```

### 输出

```
100000000888888879```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效求出满足 \(Q(N, K) = M\) 的最小 \(N\) 展开。多数题解先计算 \(K\) 的最小位置，再据此与 \(M\) 比较判断是否有解及求解。思路上，有的通过按位枚举统计 \(K\) 前数字数量，有的利用二分查找。算法要点在于准确计算不同位数下字典序小于 \(K\) 的数的个数。难点主要是边界条件处理，如 \(K\) 为 \(10^n\) 时的特殊情况，以及计算过程中避免重复或遗漏。

### 所选的题解
#### 作者：Akashicw (5星)
- **关键亮点**：思路清晰，先得出两条重要结论，即 \(10^n\) 位置固定及 \(q(n, k)\) 随 \(n\) 不下降，据此计算 \(K\) 的最小位置 \(base\) 并与 \(M\) 比较，通过对数级枚举增加元素找到答案，代码实现简洁明了。
- **个人心得**：感谢老师讲解及同学指正。
```cpp
//计算k的最小位置 
int calc(int k){ 
    char s[12];
    sprintf(s,"%d",k);
    int ans=0,w=0;
    len=strlen(s);
    for(int i=0;i<len;i++)
    {
        w=w*10+s[i]-'0';
        ans+=w-mi[i]+1;
    }
    return ans; 
}
//...
mi[0]=1;
for(int i=1;i<19;i++) mi[i]=mi[i-1]*10;
scanf("%d%d",&k,&m);
//1,10,100的位置是固定的 
for(int i=0;i<10;i++){
    if(k==mi[i]&&m!=i+1){
        printf("0\n"); return 0;
    }
}
base=calc(k);
if(m<base){
    printf("0\n"); return 0;
}
if(m==base){
    printf("%d\n",k); return 0;
}
ans=mi[len];
m-=base;
for(int i=1;;i++)
{
    long long tmp=k*mi[i]-mi[len+i-1];
    if(m>tmp)
    {
        m-=tmp; 
        ans*=10;
    }
    else break;
}
ans+=m-1;
```
核心实现思想：`calc` 函数通过按位处理计算 \(K\) 的最小位置，主函数中先特判 \(K\) 为 \(10^n\) 的情况，再根据 \(base\) 与 \(M\) 的关系计算答案，通过循环增加位数并判断是否满足条件。

#### 作者：Mr_Li (4星)
- **关键亮点**：将字典序比 \(K\) 小的数分成无穷个集合，通过推导集合元素个数规律，得出 \(X\) 所在集合及 \(X\) 的值，时间复杂度为 \(O[\log_{10}(N)]\)，思路独特且高效。
```cpp
for (i=1;i<=k;i*=10)
    number+=k/i-i+1;
number--;
if (number>=m||k-(i/10)==0&&number<m-1)
    cout<<0;
if (number>=m||k-(i/10)==0&&number<m-1)
    return 0;
for (i=k-(i/10),n=k;number<m-1;i*=10,number+=i,n*=10);
cout<<max(n-number+m-2,k);
```
核心实现思想：先通过循环计算字典序比 \(K\) 小的数的个数 `number`，判断是否有解，再通过循环找到满足条件的 \(n\)，最后输出 \(n\) 与 \(K\) 的最大值。

#### 作者：Thunder_S (4星)
- **关键亮点**：从特殊到一般，先考虑 \(K = 10^i\) 的情况，再通过分析不同位数下字典序小于 \(K\) 的数的个数规律，计算 \(K\) 的最小位置 \(num\)，根据 \(num\) 与 \(M\) 的关系求解，逻辑清晰。
```cpp
for (int i=0;i<=18;++i)
    if (k==p[i])
    {
        if (m==i+1) printf("%lld\n",k);
        else printf("0\n");
        return 0;
    }
len=(int)log10(k);
for (int i=len;i>=0;--i)
    num+=k/p[i]-p[len-i]+1;
if (num==m)	printf("%lld\n",k);
else if (num>m) printf("0\n");
else
{
    for (int i=1;i<=10;++i)
    {
        k*=10;
        num+=k-p[len+i];
        if (num>=m)
        {
            num-=k-p[len+i];
            printf("%lld\n",m-num+p[len+i]-1);
            return 0;
        }
    }
}
```
核心实现思想：先特判 \(K\) 为 \(10^i\) 的情况，再计算 \(K\) 的最小位置 \(num\)，根据 \(num\) 与 \(M\) 的关系，通过循环增加 \(K\) 的位数找到答案。

### 最优的关键思路或技巧
1. **按位枚举统计**：通过按位枚举，计算不同位数下字典序小于 \(K\) 的数的个数，从而确定 \(K\) 的最小位置，这是多数题解的核心思路。
2. **利用特殊数性质**：关注 \(10^n\) 这类特殊数在字典序中的固定位置，对其进行特判，简化问题求解。
3. **对数级枚举**：在判断 \(K\) 的最小位置与 \(M\) 的关系后，通过对数级枚举增加位数来找到满足条件的 \(N\)，提高算法效率。

### 可拓展之处
同类型题可考虑其他基于字典序的排列问题，或对序列中元素位置有特殊要求的查找问题。类似算法套路是先分析特殊情况和规律，再通过合理的枚举或二分等方法求解。

### 相似知识点的洛谷题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：涉及贪心算法和数据结构操作，与本题一样需要分析问题规律并选择合适算法求解。
2. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)：通过对数字的处理和规律分析来解决问题，与本题按位分析数字有相似之处。
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：需根据题目条件分析最优策略，与本题寻找满足条件的最小 \(N\) 思路类似。

### 个人心得摘录与总结
1. **Akashicw**：感谢老师讲解及同学指正，强调在解题过程中交流和他人指导的重要性。
2. **shellfish**：分享了遇到的坑，如 \(k\) 为 \(10\) 的幂次时易 TLE，数的前后差别及类似 \(9999\) 和 \(10000\) 节点易算错，提醒注意边界条件和特殊情况处理。
3. **Ciel_bleu**：吐槽题目细节多，强调用 `long long` 避免问题，总结出解决问题要考虑每一位数字对答案的贡献及补零计算差值的思路，突出细节处理在解题中的关键作用。 

---
处理用时：56.06秒
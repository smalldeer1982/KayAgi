# 题目信息

# [AHOI2005] 病毒检测

## 题目描述

科学家们在 Samuel 星球上的探险仍在继续。非常幸运的，在 Samuel 星球的南极附近，探险机器人发现了一个巨大的冰湖！机器人在这个冰湖中搜集到了许多 RNA 片段运回了实验基地。

科学家们经过几个昼夜的研究，发现这些 RNA 片段中有许多是未知的病毒！

每个 RNA 片段都是由 `A`、`C`、`T`、`G` 组成的序列。科学家们也总结出了 Samuel 星球上的“病毒模版片段”。一个模版片段是由 `A`、`C`、`T`、`G` 的序列加上通配符 `*` 和 `?` 来表示。其中 `*` 的意思是可以匹配上 $0$ 个或任意多个字符，而 `?` 的意思是匹配上任意一个字母。

如果一个 RNA 片段能够和“病毒模版片段”相匹配，那么这个 RNA 片段就是未知的病毒。

例如，假设 “病毒模版片段”为 `A*G?C`。RNA 片段：`AGTC`，`AGTGTC` 都是未知的病毒，而 RNA 片段 `AGTGC` 则不是病毒。

由于，机器人搜集的这些 RNA 片段中除去病毒的其他部分都具有非常高的研究价值。所以科学家们希望能够分辨出其中哪些 RNA 片段不是病毒，并将不是病毒的 RNA 片段运回宇宙空间站继续进行研究。

科学家将这项任务交给了小联。现在请你为小联编写程序统计哪些 RNA 片段不是病毒。

## 说明/提示

输入中的 RNA 片段 `AGTGC` 不是病毒。

对于所有数据，$0 < N < 500$。

特别的：

- 每个 RNA 片段的长度不超过 $500$；
- “病毒模版片段”和 RNA 片段的长度都至少为 $1$。

## 样例 #1

### 输入

```
A*G?C
3
AGTC
AGTGTC
AGTGC```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何解决带有通配符（`?`和`*`）的字符串匹配问题，以判断RNA片段是否为病毒。主要思路包括使用Trie树结合搜索（DFS或BFS）、动态规划（DP）以及字符串哈希结合DP等方法。
 - **Trie树结合搜索**：多数题解采用此方法，先将RNA片段插入Trie树，再用病毒模板串在Trie树上进行搜索匹配。关键在于根据模板串中不同字符（字母、`?`、`*`）决定在Trie树上的走法，如字母按固定方向走，`?`向四个方向走，`*`分空串和非空串情况讨论。为优化搜索，常使用记忆化（如`bitset`记录访问状态）。
 - **动态规划**：定义状态表示模板串和RNA片段的匹配情况，根据模板串当前字符类型（字母、`?`、`*`）推导状态转移方程。需注意初始化细节，如模板串开头为`*`的情况。
 - **字符串哈希结合DP**：通过字符串哈希处理字符匹配，结合DP判断模板串与RNA片段是否匹配，实现相对复杂，需处理通配符的特殊情况。

### 所选的题解
 - **作者：quest_2 (赞：42) 星级：5星**
    - **关键亮点**：思路清晰，详细阐述从分析问题到得出Trie + DFS正解的过程，对搜索过程中每种字符的处理讲解细致，代码实现采用结构体封装Trie树，注释详尽，还提到记忆化优化的原因和具体方式。
    - **个人心得**：“现在看来应该还是简单的。不过之前没做过这类题的话，思维跨度还是有点大的。” 表明此类Trie树进阶题虽有难度，但掌握后便较为清晰。
    - **核心代码片段**：
```cpp
void dfs(int stp, int now) //模式串的第stp位，在trie树上的位置为now
{
    if (stp == L + 1)//病毒串搜到底了
    {
        ans += Tree.val[now];//更新答案
        Tree.val[now] = 0;//修改val值，避免多加
        return;
    }
    if (vis[now][stp])//记忆化
    {
        return;
    }
    
    int x = Tree.idx(vir[stp]);
    vis[now][stp] = 1;
    
    if (x >= 1 && x <= 4)//若stp位置上是字母
    {
        if (Tree.ch[now][x])
            dfs(stp + 1, Tree.ch[now][x]);
    }
    
    if (x == 5)//若是'?'
    {
        for (int i = 1; i <= 4; i++)
        //向四个方向都可以走
        {
            if (Tree.ch[now][i])
                dfs(stp + 1, Tree.ch[now][i]);
        }
    }
    
    if (x == 6)//若是*
    {
        dfs(stp + 1, now);//第一种情况：空串
        for (int i = 1; i <= 4; i++)
        //第二种情况：'*'='?'+'*'
        {
            if (Tree.ch[now][i])
            {
                dfs(stp + 1, Tree.ch[now][i]);
                //处理'?'
                dfs(stp, Tree.ch[now][i]);
                //处理'*'
            }
        }
    }
}
```
核心实现思想：根据病毒模板串当前字符决定在Trie树上的搜索路径，利用记忆化避免重复搜索。
 - **作者：Karry5307 (赞：24) 星级：4星**
    - **关键亮点**：提出用非确定性有限状态自动机解题，对模式串建自动机，根据字符类型构建转移图，匹配过程直观清晰，代码简洁明了。
    - **核心代码片段**：
```cpp
inline void match()
{
    s.clear(), s.push_back(1);
    for (register int i = 1; i <= len; i++)
    {
        nxt.clear(), flg = 0;
        for (register int j = 1; j <= tot; j++)
        {
            vis[j] = 0;
        }
        for (register int j = 0; j < s.size(); j++)
        {
            for (register int k = 0; k < x[s[j]].nxt[mp[ch[i]]].size(); k++)
            {
                if ((c = x[s[j]].nxt[mp[ch[i]]][k]) &&!vis[c])
                {
                    vis[c] = 1, nxt.push_back(c), flg|=x[c].isEnd;
                }
            }
        }
        s = nxt;
    }
    res += 1 - flg;
}
```
核心实现思想：从初始状态开始，按模式串字符在自动机上转移，若能到达结束状态则匹配成功。
 - **作者：Log_x (赞：13) 星级：4星**
    - **关键亮点**：采用Trie树 + BFS的方法，详细描述了在BFS过程中如何根据模板串字符扩展队列节点以及计算答案，同时提到使用`bitset`进行状态记录避免重复搜索。
    - **核心代码片段**：
```cpp
inline void Push(const int x, const int stp)
{
    if (!x || stp > len) return;
    if (!vis[x][stp])
    {
        vis[x][stp] = 1; w = (w + 1) % M;
        Q[w][0] = x; Q[w][1] = stp;
    } 
}

int main()
{
    c['A'] = 0; c['C'] = 1; c['T'] = 2; c['G'] = 3; 
    c['?'] = -1; c['*'] = -2;
    scanf("%s", s + 1); len = strlen(s + 1);
    s[0] = '?'; n = get();
    for (int i = 1; i <= n; ++i) Ins();
    int u, v, I; Q[1][0] = 1; Q[1][1] = 0; vis[1][0] = 1;
    while (t!= w)
    {
        t = (t + 1) % M;
        u = Q[t][0]; v = Q[t][1];
        if (s[v] == '*') 
         for (int i = 0; i < 4; ++i) Push(G[u][i], v);
        if (v == len) {Ans += val[u]; val[u] = 0; continue;}
        if (c[s[v + 1]] >= 0) Push(G[u][c[s[v + 1]]], v + 1);
         else 
         {
             for (int i = 0; i < 4; ++i) Push(G[u][i], v + 1);
             if (s[v + 1] == '*') Push(u, v + 1);
         }
    }
    return put(n - Ans), 0;
}
```
核心实现思想：通过BFS在Trie树上按模板串字符规则扩展节点，匹配到模板串结尾则统计Trie树节点上RNA片段数量。

### 最优关键思路或技巧
 - **数据结构选择**：Trie树适合处理字符串前缀匹配问题，本题将RNA片段插入Trie树，为后续匹配提供高效存储结构。
 - **搜索与状态记录**：无论是DFS还是BFS，在搜索过程中记录状态（如使用`bitset`记录已访问状态）可避免大量重复计算，显著优化时间复杂度。
 - **动态规划状态设计与转移**：设计合适的状态表示模板串和RNA片段的匹配情况，并根据字符类型准确推导状态转移方程，可有效解决问题。

### 可拓展之处
此类题目属于带有通配符的字符串匹配问题，类似套路可用于解决其他通配符匹配场景，如文件搜索中的通配符匹配等。对于更复杂的情况，可能需要结合AC自动机等更高级的数据结构来处理多模式串匹配。

### 相似知识点题目推荐
 - **P3167 [CQOI2015] 通配符匹配**：同样是通配符匹配问题，加深对通配符处理的理解。
 - **P4407 [JSOI2010] 缓存交换**：涉及字符串匹配及相关优化，可锻炼Trie树等数据结构的应用能力。
 - **P2292 [HNOI2004] 营业额统计**：虽不是严格的字符串匹配，但可通过Trie树优化前缀查找等操作，拓展Trie树应用场景。 

---
处理用时：51.85秒
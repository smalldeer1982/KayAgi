# 题目信息

# [NOIP 2015 提高组] 子串

## 题目背景

NOIP2015 Day2T2

## 题目描述

有两个仅包含小写英文字母的字符串 $A$ 和 $B$。

现在要从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 $B$ 相等？

注意：子串取出的位置不同也认为是不同的方案。

## 说明/提示

**样例解释**

所有合法方案如下：（加下划线的部分表示取出的字串）

样例 1：$\texttt{\underline{aab}\,aab,aab\,\underline{aab}}$。  
样例 2：$\texttt{\underline{a}\,\underline{ab}\,aab,\underline{a}\,aba\,\underline{ab},a\,\underline{a}\,ba\,\underline{ab},aab\,\underline{a}\,\underline{ab},\underline{aa}\,\underline{b}\,aab,\underline{aa}\,baa\,\underline{b},aab\,\underline{aa}\,\underline{b}}$。  
样例 3：$\texttt{\underline{a}\,\underline{a}\,\underline{b}\,aab,\underline{a}\,\underline{a}\,baa\,\underline{b},\underline{a}\,ab\,\underline{a}\,a\,\underline{b},\underline{a}\,aba\,\underline{a}\,\underline{b},a\,\underline{a}\,b\,\underline{a}\,a\,\underline{b},a\,\underline{a}\,ba\,\underline{a}\,\underline{b},aab\,\underline{a}\,\underline{a}\,\underline{b}}$。

**数据范围**

对于第 1 组数据：$1≤n≤500,1≤m≤50,k=1$;  
对于第 2 组至第 3 组数据：$1≤n≤500,1≤m≤50,k=2$;   
对于第 4 组至第 5 组数据：$1≤n≤500,1≤m≤50,k=m$;   
对于第 1 组至第 7 组数据：$1≤n≤500,1≤m≤50,1≤k≤m$;  
对于第 1 组至第 9 组数据：$1≤n≤1000,1≤m≤100,1≤k≤m$;   
对于所有 10 组数据：$1≤n≤1000,1≤m≤200,1≤k≤m$。  


## 样例 #1

### 输入

```
6 3 1 
aabaab 
aab```

### 输出

```
2```

## 样例 #2

### 输入

```
6 3 2 
aabaab 
aab```

### 输出

```
7```

## 样例 #3

### 输入

```
6 3 3 
aabaab 
aab```

### 输出

```
7```

# AI分析结果

### 综合分析与结论
这些题解均采用动态规划（DP）方法解决从字符串A中取k个非空子串拼成字符串B的方案数问题。思路上，大多通过设计包含A、B串位置及子串个数等维度的状态，根据A、B当前字符是否相等进行状态转移。算法要点在于准确设计状态与转移方程，难点是优化空间复杂度以应对较大数据。

### 所选的题解
- **作者：frankchenfu (赞：398)  5星**
    - **关键亮点**：思路清晰，详细阐述状态设计每一维意义，转移方程分情况讨论透彻，还介绍空间优化思路及具体实现。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：状态 `f[i][j][p][v]` 表示到a串的第i个位置为止使用p个子串匹配b串前j位字符且第i个位置选或不选（v）的方案数。转移时，当 `a[i] == b[j]` ，对选与不选分别处理；否则不选情况同前，选则为0。通过滚动数组优化空间。
```cpp
void dp(){
    f[0][0][0][0]=f[1][0][0][0]=1;
    for(int i=1;i<=n;i++,val^=1)
        for(int j=1;j<=m;j++)
            for(int p=1;p<=k;p++){
                if(a[i]==b[j]){
                    f[val][j][p][0]=(f[val^1][j][p][0]+f[val^1][j][p][1])%MOD;
                    f[val][j][p][1]=(f[val^1][j-1][p][1]+\
                                    (f[val^1][j-1][p-1][0]+f[val^1][j-1][p-1][1])%MOD)%MOD;
                }
                else{
                    f[val][j][p][0]=(f[val^1][j][p][0]+f[val^1][j][p][1])%MOD;
                    f[val][j][p][1]=0;
                }
            }
}
```
- **作者：八重樱飞 (赞：164)  4星**
    - **关键亮点**：从DP三要素出发，详细解释阶段划分、状态与决策，对转移方程各部分含义解释清晰，代码注释辅助理解。
    - **个人心得**：研究DP方程花费较多时间，强调数组开大易爆需滚动优化。
    - **重点代码 - 核心实现思想**：与frankchenfu思路类似，状态 `f[i][j][p][v]` 含义相同。转移方程根据 `a[i]` 与 `b[j]` 是否相等，对选与不选的情况分别推导，最后通过滚动数组优化空间。
```cpp
for(i=1;i<=n;i++)
    for(j=1;j<=m;j++)
        for(p=1;p<=k;p++)
        {
            if(a[i]==b[j])
            {
                f[i%2][j][p][1]=(f[(i-1)%2][j-1][p][1]+f[(i-1)%2][j-1][p-1][0])%md+f[(i-1)%2][j-1][p-1][1]%md;
                f[i%2][j][p][1]%=md;
                f[i%2][j][p][0]=f[(i-1)%2][j][p][1]+f[(i-1)%2][j][p][0];
                f[i%2][j][p][0]%=md;
            }
            else
            {
                f[i%2][j][p][0]=f[(i-1)%2][j][p][1]+f[(i-1)%2][j][p][0];
                f[i%2][j][p][0]%=md;
                f[i%2][j][p][1]=0;
             } 
        }
```
- **作者：Ascnbeta (赞：2)  4星**
    - **关键亮点**：思路分析清晰，逐步阐述状态设计原因，详细给出状态转移方程，代码简洁且有注释辅助理解，还提及空间优化思路。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：状态 `f[i][j][k][v]` 表示从A串前i个字符中取出k个子串和B串前j个子串相同且是否选第A[i]个字符的方案数。转移时根据选与不选A[i]，以及A[i]与B[j]是否相等分类讨论，通过倒序枚举优化空间。
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = m; j >= 1; j--) {
        for (int k = K; k >= 0; k--) {
            f[j][k][0] = (f[j][k][0]%mod+f[j][k][1]%mod)%mod;
            if (a[i]==b[j]) {
                if (k >= 1) f[j][k][1] = ((f[j-1][k][1]%mod+f[j-1][k-1][1]%mod)%mod+f[j-1][k-1][0]%mod)%mod;
                else f[j][k][1] = f[j-1][k][1]%mod;
            }else{
                f[j][k][1] = 0;
            }
        }
    }
}
```

### 最优关键思路或技巧
1. **状态设计**：引入维度记录A、B串匹配位置、子串个数及当前字符是否选取，确保无后效性与全面性。
2. **空间优化**：利用滚动数组，基于转移仅依赖前一状态，将高维数组降维，降低空间复杂度。
3. **转移优化**：部分题解通过前缀和、差分等技巧优化转移过程，降低时间复杂度。

### 同类型题或类似算法套路
此类题目属于字符串上的计数类DP问题。常见套路是根据题目限制设计包含多维度信息的状态，依据字符匹配情况与题目条件确定转移方程，再通过滚动数组、前缀和、差分等优化时空复杂度。

### 推荐题目
1. [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)：二维路径上的计数DP，类似本题设计状态与优化转移。
2. [P1140 相似基因](https://www.luogu.com.cn/problem/P1140)：字符串匹配计数，可类比本题状态设计与转移思路。
3. [P1220 关路灯](https://www.luogu.com.cn/problem/P1220)：线性DP结合区间操作，与本题通过多维度状态设计解决问题思路类似。 

---
处理用时：52.01秒
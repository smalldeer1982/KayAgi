# 题目信息

# 【模板】KMP

## 题目描述

给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。  
现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。

定义一个字符串 $s$ 的 border 为 $s$ 的一个**非 $s$ 本身**的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。  
对于 $s_2$，你还需要求出对于其每个前缀 $s'$ 的最长 border $t'$ 的长度。

## 说明/提示

### 样例 1 解释

 ![](https://cdn.luogu.com.cn/upload/pic/2257.png)。
 
对于 $s_2$ 长度为 $3$ 的前缀 `ABA`，字符串 `A` 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。


### 数据规模与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（30 points）：$|s_1| \leq 15$，$|s_2| \leq 5$。
- Subtask 2（40 points）：$|s_1| \leq 10^4$，$|s_2| \leq 10^2$。
- Subtask 3（30 points）：无特殊约定。

对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。

## 样例 #1

### 输入

```
ABABABC
ABA
```

### 输出

```
1
3
0 0 1 
```

# AI分析结果

• **综合分析与结论**：这些题解主要围绕KMP算法展开，用于解决字符串匹配问题。多数题解先阐述KMP算法原理，强调利用匹配失败后的信息减少匹配次数，核心是构建next数组（或类似数组）记录模式串前缀后缀的匹配信息，在匹配失败时通过移动模式串指针而非从头匹配来优化。不同题解在思路清晰度、代码可读性和优化程度上有差异。
• **所选的题解**：
  - **作者：皎月半洒花 (5星)**
    - **关键亮点**：思路清晰，先介绍模式串匹配概念，再深入剖析KMP思想，结合具体例子阐述失配处理及前后缀应用，代码实现部分对关键步骤有详细解释，还给出复杂度证明。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
// 处理kmp数组
j = 0;
for (int i = 2; i <= lb; i++)
{
    while (j && b[i]!= b[j + 1])
        j = kmp[j];
    if (b[j + 1] == b[i])
        j++;
    kmp[i] = j;
}
// 与文本串比对
j = 0;
for (int i = 1; i <= la; i++)
{
    while (j > 0 && b[j + 1]!= a[i])
        j = kmp[j];
    if (b[j + 1] == a[i])
        j++;
    if (j == lb)
    {
        cout << i - lb + 1 << endl;
        j = kmp[j];
    }
}
```
    - **核心实现思想**：通过模式串自己匹配自己构建kmp数组，在与文本串比对时，失配则根据kmp数组移动模式串指针，匹配成功则继续移动指针，找到所有匹配位置。
  - **作者：frostime (5星)**
    - **关键亮点**：对KMP算法解释极为详细，从暴力求解引入，反思其低效原因，逐步提出KMP算法思路，详细讲解next数组构造，包括递推方式及优化，代码实现注释丰富，还提及手工求next数组及KMP与BF算法的适用场景。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
// 构造next数组
void ConstructNext(const string &pattern, int next[])
{
    const int len = pattern.length();
    next[0] = -1;
    int ptr = 0, lastNext = -1;
    while (ptr < len - 1)
    {
        if (lastNext == -1 || pattern[ptr] == pattern[lastNext])
            next[++ptr] = ++lastNext;
        else
            lastNext = next[lastNext];
    }
}
// KMP匹配
void KMPMatch(const string &src, const string &pattern)
{
    const int srcLen = src.length(), patLen = pattern.length();
    int srcPtr = 0, patPtr = 0;
    int next[patLen];
    ConstructNext(pattern, next);
    while (srcPtr < srcLen && patPtr < patLen)
    {
        if (patPtr == -1 || src[srcPtr] == pattern[patPtr])
        {
            ++srcPtr;
            ++patPtr;
        }
        else
            patPtr = next[patPtr];
    }
    return (patPtr == patLen)? srcPtr - patPtr : -1;
}
```
    - **核心实现思想**：在ConstructNext函数中，通过递推方式根据模式串字符匹配情况填充next数组；KMPMatch函数利用next数组进行匹配，匹配过程中根据失配情况移动模式串指针。
  - **作者：一扶苏一 (4星)**
    - **关键亮点**：算法讲解简洁明了，先定义border概念，基于此分析暴力匹配的问题，进而阐述KMP算法中失配时指针移动的原理，将求模式串前缀的最长border问题与匹配问题联系，时间复杂度分析清晰。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
void KMP(char *A, char *B, int x, int y, const bool pt)
{
    for (int j = 0, i = pt? 1 : 2; i <= x; ++i)
    {
        while (j && (B[j + 1]!= A[i]))
            j = nxt[j];
        if (B[j + 1] == A[i])
            ++j;
        if (!pt)
            nxt[i] = j;
        if (j == y)
        {
            qw(i - y + 1, '\n', true);
        }
    }
}
```
    - **核心实现思想**：通过KMP函数实现匹配，在匹配过程中，根据nxt数组（即next数组）处理失配情况，若匹配成功则根据条件输出匹配位置或记录nxt数组值。
• **最优的关键思路或技巧**：KMP算法的核心技巧是构建记录模式串前缀后缀匹配信息的数组（如next数组），利用该数组在匹配失配时快速移动模式串指针，避免重复匹配，从而将时间复杂度从朴素算法的O(nm)降至O(n + m)。在代码实现上，通过模式串自身匹配来高效构建next数组是关键。
• **可拓展之处**：同类型题可涉及多模式串匹配问题，如AC自动机算法可解决此类问题。类似算法套路包括利用字符串的前缀后缀性质进行优化，在其他字符串处理场景中，通过预处理字符串信息来加速匹配或查找过程。
• **推荐题目**：
  - **P2824 [HEOI2016/TJOI2016]排序**：涉及字符串排序与KMP算法结合，通过KMP判断子串位置，再进行排序操作。
  - **P4391 [BOI2009]Radio Transmission 无线传输**：利用KMP算法求字符串最小循环节长度，考察对KMP算法中前缀后缀概念的理解与应用。
  - **P5410 【模板】扩展KMP**：扩展KMP问题，在经典KMP基础上，求每个位置开始的后缀与模式串的最长匹配长度，进一步拓展对KMP算法的应用。
• **个人心得摘录与总结**：无

---
处理用时：59.09秒
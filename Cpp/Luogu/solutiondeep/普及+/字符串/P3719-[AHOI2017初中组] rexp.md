# 题目信息

# [AHOI2017初中组] rexp

## 题目背景

为了解决形形色色的字符串匹配问题，正则表达式是一个强有力的工具。正则表达式通过定义一套符号体系，能够表示出需要查找的字符串所具有的性质。如 `a|aa` 能匹配 `a` 或 `aa`，`(a|b)c` 能匹配 `ac` 或 `bc`。


## 题目描述

完整的正则表达式过于复杂，在这里我们只考虑由 `(`、`)`、`|` 和 `a` 组成的正则表达式。运算遵循下列法则：

1. 有括号时，我们总是先算括号内的部分；

2. 当两个字符串（或由括号定义的子串）间没有符号时，我们总把它们连起来作为一个整体；

3. `|` 是或连接符，表示两边的字符串任取其一，若同一层里有多个或连接符，可以看作在这些或连接符所分开的若干字符串里任取其一。

例如，`(aaa)aa|aa|(a(aa)a)`、`(aaaaa)|(aa)|aaaa` 和 `aaaaa|aaaa|aa` 是等价的，它们都能匹配长度为 $2,4$ 或 $5$ 的全 `a` 字符串。

下面给定一个简化正则表达式，试编程计算它最多能匹配多长的全 `a` 字符串。

## 说明/提示

**【数据范围】**

对于 $20\%$ 数据，表达式长度不超过 $100$，且不存在括号。

对于 $40\%$ 数据，表达式长度不超过 $100$。

对于 $70\%$ 数据，表达式长度不超过 $2 \times 10^3$。

对于 $100\%$ 的数据，表达式长度不超过 $10^5$。

保证表达式合法（即 `|` 两端和括号内运算结果均非空字符串）。

## 样例 #1

### 输入

```
(aaa)aa|aa|(a(aa)a)```

### 输出

```
5
```

## 样例 #2

### 输入

```
((a|aaa)|aa)|a```

### 输出

```
3```

## 样例 #3

### 输入

```
(a(aa|aaa)a|(a|aa))aa```

### 输出

```
7```

# AI分析结果

• 综合分析与结论：
    - 多数题解采用递归思路解决该问题，递归过程中根据遇到的字符（'a'、'('、')'、'|'）进行不同处理。遇到'a'则长度计数增加；遇到'('开启新一层递归计算括号内长度并累加；遇到'|'比较当前长度与新递归得到的长度取最大值；遇到')'返回当前长度。
    - 少数题解采用栈或暴力模拟的方法。栈的方法通过维护栈来模拟递归过程，暴力模拟则是按规则逐步处理表达式。
    - 从思路清晰度、代码可读性、优化程度等方面看，递归解法整体较为简洁高效，其中部分递归题解对思路和代码的阐述较为详细清晰。

    所选3道考察相似知识点的洛谷题目：
    - P1928外星密码：同样涉及递归处理字符串相关问题。
    - P3390 【模板】矩阵快速幂：虽主题是矩阵快速幂，但递归思想在算法实现中有体现。
    - P1028 数的计算：通过递归方式解决数字计算问题，与本题递归思路类似。

    最优关键思路或技巧：采用递归将复杂的正则表达式匹配长度计算问题分解为多个简单子问题，依据不同字符进行相应操作，简洁高效。同时在代码实现时注意边界条件处理，如右括号的判断位置及'|'处的返回值处理。

    可拓展之处：此类问题属于字符串处理结合递归算法的类型，类似套路可用于处理具有层次结构或优先级运算的字符串问题，如更复杂的正则表达式匹配、表达式求值等。

    个人心得摘录及总结：
        - 作者清风霁月：最初使用栈的原理写代码，但因开数组过大导致超时和错误。后转变思路采用递归，详细阐述了递归中右括号写前面及'|'处加return的原因，强调了递归实现时对边界条件和细节处理的重要性。

• 所选题解：
  - 作者：迈吉扣 (赞：74)  星级：5星
    - 关键亮点：代码简洁，仅18行通过一个递归函数解决问题，思路清晰直接，对递归函数的实现简洁明了。
    ```cpp
    int p(int j)
    {
        char c;
        while(scanf("%c",&c)!=EOF)
        {
            if(c=='a') j++;
            if(c=='(') j=j+p(0);
            if(c=='|') return max(j,p(0));
            if(c==')') return j;
        }
        return j;
    }
    ```
    核心实现思想：递归函数`p`在循环读入字符过程中，根据不同字符对长度`j`进行相应操作，遇到'('开启新递归并累加长度，遇到'|'比较当前长度与新递归长度取最大值，遇到')'返回当前长度。
  - 作者：清风霁月 (赞：14)  星级：4星
    - 关键亮点：详细阐述了从最初栈思路到递归思路的转变过程，对递归实现中的细节，如右括号位置、'|'处return的作用，进行了深入解释，便于理解。
    ```cpp
    int work()
    {
        int len=0,t;
        while(1)
        { i++;
        if(ch[i]==')') {return len;}//右括号必须写在前面
        if(ch[i]=='a') len++;
        if(ch[i]=='(') len+=work();
        if(ch[i]=='|') {t=work();return (len>t)?len:t;}    //这个地方必须加return 
         }
    }
    ```
    核心实现思想：递归函数`work`通过`while(1)`循环结合对字符数组`ch`下标的移动，根据不同字符对长度`len`进行操作，与迈吉扣思路类似，但此处通过数组下标移动读入字符。
  - 作者：Ptilopsis_w (赞：6)  星级：4星
    - 关键亮点：代码简洁清晰，对递归思路解释明确，同时给出了读入方式的小贴士，对初学者有帮助。
    ```cpp
    int work()
    {
        int s = 0;
        char ch;
        while(cin >> ch)
        {
            if(ch == ')')
                return s;
            else if(ch == '(')
                s += work();
            else if(ch == '|')
                return max(s, work());
            else
                s++;
        }
        return s;
    }
    ```
    核心实现思想：递归函数`work`在`while(cin >> ch)`循环中，根据读入字符`ch`的不同，对长度`s`进行相应操作并返回结果。 

---
处理用时：35.02秒
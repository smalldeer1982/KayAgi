# 题目信息

# [JSOI2009] 电子字典

## 题目描述


人们在英文字典中查找某个单词的时候可能不知道该单词的完整拼法，而只知道该单词的一个错误的近似拼法，这时人们可能陷入困境，为了查找一个单词而浪费大量的时间。带有模糊查询功能的电子字典能够从一定程度上解决这一问题：用户只要输入一个字符串，电子字典就返回与该单词编辑距离最小的几个单词供用户选择。

字符串 $a$ 与字符串 $b$ 的编辑距离是指：允许对 $a$ 或 $b$ 串进行下列“编辑”操作，将 $a$ 变为 $b$ 或 $b$ 变为 $a$，最少“编辑”次数即为距离。

1. 删除串中某个位置的字母；
2. 添加一个字母到串中某个位置；
3. 替换串中某一位置的一个字母为另一个字母。

JSOI 团队正在开发一款电子字典，你需要帮助团队实现一个用于模糊查询功能的计数部件：对于一个待查询字符串，如果它是单词，则返回 $-1$；如果它不是单词，则返回字典中有多少个单词与它的编辑距离为 $1$。

## 说明/提示

### 样例解释

- `abcd` 在单词表中出现过；
- `abc` 与单词 `abcd`、`aabc` 的编辑距离都是 $1$；
- `abcdd` 与单词 `abcd`、`abcde`、`abced` 的编辑距离都是 $1$。

### 数据范围与约定

- 所有单词互不相同，但是查询字符串可能有重复；
- 对 $50\%$ 的数据范围，$N,M\le 10^3$；
- 对 $100\%$ 的数据范围，$N,M\le 10^4$。

## 样例 #1

### 输入

```
4 3
abcd
abcde
aabc
abced
abcd
abc
abcdd```

### 输出

```
-1
2
3```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解采用Trie树结合DFS的方法，先构建Trie树存储单词，再对查询字符串在Trie树上DFS，枚举添加、删除、替换一个字符的情况来统计编辑距离为1的单词数，同时判断查询字符串本身是否为单词。部分题解使用哈希表来解决，通过预处理和去重统计符合条件的单词。还有暴力枚举的方法，直接对每个查询字符串与所有单词比较判断编辑距离。
    - 算法要点在于Trie树的构建与查询，DFS中对三种编辑操作的模拟以及哈希表的运用和去重处理。
    - 解决难点主要集中在如何避免重复统计通过不同编辑方式得到的相同字符串，以及DFS中对编辑操作的合理处理，如某些细节避免“假修改”情况。
    - 整体来看，基于Trie树的DFS方法较为通用和高效，哈希表方法实现相对简单但去重较复杂，暴力方法直观但效率较低。

    以下为≥4星题解：
  - **作者：Utsuji_risshū (5星)**
    - 关键亮点：思路清晰，详细阐述Trie树结合DFS的方法，对DFS中三种编辑操作的模拟解释到位，代码简洁且注释详细。
    - 个人心得：无
    - 核心代码实现思想：构建Trie树存储单词，通过DFS函数在Trie树上搜索，根据编辑机会是否使用进行不同操作，同时标记已处理的满足条件的字符串避免重复统计。
```cpp
void Insert(){
    u = 0, len = strlen(s);
    for(register int i = 0; i < len; ++i){
        int c = s[i] - 'a';
        if(!Trie[u][c]) Trie[u][c] = ++tot;
        u = Trie[u][c];
    }
    p[u] = 1;
}

void DFS(int rt, int l, bool f){
    if(l == len && p[rt] &&!f){
        word = 1; return;
    }
    if(l == len && p[rt] && f){
        if(!vis[rt]) vis[visx[++vistot] = rt] = 1;
        return;
    }
    int c = s[l] - 'a';
    if(!f){
        if(l < len) DFS(rt, l + 1, 1);
        for(register int i = 0; i < 26; ++i)
            if(Trie[rt][i]){
                DFS(Trie[rt][i], l, 1);
                if(i!= c) DFS(Trie[rt][i], l + 1, 1);
            }
    }
    if(l >= len) return;
    if(Trie[rt][c]) DFS(Trie[rt][c], l + 1, f);
}
```
  - **作者：Cry_For_theMoon (4星)**
    - 关键亮点：对Trie树上DFS的细节分析深入，特别是对“假修改”情况的分析很有价值，代码结构清晰，注释丰富。
    - 个人心得：样例调试1小时发现DFS细节问题，总结出添加、删除、修改操作在Trie树上路径的特点及避免“假修改”的细节。
    - 核心代码实现思想：构建Trie树，分别通过dfs1、dfs2、dfs3函数实现删除、添加、修改操作的DFS搜索，统计符合条件的单词数。
```cpp
void dfs1(char* s, int u, int len, int now, bool flag){
    if(now == len && val[u] && flag){cnt++; return;}
    if(now == len - 1 && val[u] &&!flag){cnt++; return;} 
    if(flag){
        int c = idx(s[now]);
        if(next[u][c]){
            dfs1(s, next[u][c], len, now + 1, 1);
        }
        return; 
    } 
    int c = idx(s[now]);
    if(next[u][c]){
        dfs1(s, next[u][c], len, now + 1, 0); 
    }
    for(int i = 0; i < 26; i++){
        if(!next[u][i])continue;
        if(i == c)continue;
        if(i == idx(s[now + 1])){
            dfs1(s, next[u][i], len, now + 2, 1); 
        }
    } 
}

void dfs2(char* s, int u, int len, int now, bool flag){
    if(now == len && val[u] && flag){cnt++; return;}
    if(now == len &&!flag){
        for(int j = 0; j < 26; j++){
            if(next[u][j] && val[next[u][j]]){cnt++;}
        }
        return;
    } 
    if(flag){
        int c = idx(s[now]);
        if(next[u][c]){
            dfs2(s, next[u][c], len, now + 1, 1);
        }
        return;
    }
    int c = idx(s[now]);
    if(next[u][c]){
        dfs2(s, next[u][c], len, now + 1, 0); 
    } 
    for(int i = 0; i < 26; i++){
        if( (!next[u][i]) || i == c)continue;
        if(next[next[u][i]][c]){
            dfs2(s, next[next[u][i]][c], len, now + 1, 1); 
        }
    } 
}

void dfs3(char*s, int u, int len, int now, bool flag){
    if(now == len && val[u] && flag){cnt++; return;}
    if(flag){
        int c = idx(s[now]);
        if(next[u][c])dfs3(s, next[u][c], len, now + 1, 1);
        return;
    }
    int c = idx(s[now]);
    if(next[u][c]){
        dfs3(s, next[u][c], len, now + 1, 0);
    }
    for(int i = 0; i < 26; i++){
        if( (!next[u][i])  || i == c)continue;
        dfs3(s, next[u][i], len, now + 1, 1);
    }
}
```
  - **作者：creation_hy (4星)**
    - 关键亮点：代码简洁明了，对Trie树上DFS的实现简洁高效，同时提到使用map特判字符串是否存在优化搜索，还指出DFS实现中的两个容易出错的点。
    - 个人心得：指出DFS实现中两个坑点，一是只有完全匹配到某个串时才改vis数组，二是不要一碰到vis[cur]==true就return，否则会得30分。
    - 核心代码实现思想：构建Trie树并使用map记录单词，通过dfs函数进行DFS搜索，根据是否使用修改操作进行不同分支，统计符合条件的单词数。
```cpp
inline void insert(string s){
    int cur = 0;
    mp[s] = true;
    for(char c : s){
        if(!t[cur][c])
            t[cur][c] = ++tot;
        cur = t[cur][c];
    }
    tag[cur]++;
}

inline int dfs(string s, int cur, int x, bool changed){
    if(x == s.size() &&!vis[cur] && tag[cur] && changed){
        vis[cur] = true;
        return tag[cur];
    }
    int res = 0;
    if(t[cur][s[x]])
        res += dfs(s, t[cur][s[x]], x + 1, changed); 
    if(changed)
        return res;
    res += dfs(s, cur, x + 1, 1); 
    for(int i = 0; i < 26; i++)
        if(t[cur][i]){
            res += dfs(s, t[cur][i], x + 1, 1); 
            res += dfs(s, t[cur][i], x, 1);     
        }
    return res;
}

inline int solve(string s){
    if(mp.count(s))
        return -1;
    memset(vis, 0, sizeof(vis));
    return dfs(s, 0, 0, 0);
}
```

• 最优关键思路或技巧：
    - **数据结构**：使用Trie树存储单词，利用其前缀共享的特性，减少空间复杂度，同时便于在树上进行搜索操作。
    - **算法优化**：在Trie树上进行DFS时，通过标记是否使用编辑机会，合理分支处理不同编辑操作，避免无效搜索。同时注意去重，防止重复统计通过不同编辑方式得到的相同字符串。
    - **思维方式**：将编辑距离问题转化为Trie树上的搜索问题，清晰理解添加、删除、替换操作在Trie树上的路径表现，如避免“假修改”情况。

• 可拓展之处：同类型题可考察不同编辑距离要求，或结合其他字符串操作。类似算法套路如在处理字符串匹配、前缀查询等问题时，Trie树结合DFS/BFS是常用方法，哈希表在字符串统计和判重方面也经常使用。

• 推荐题目：
    - [P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)：基础Trie树应用，练习Trie树的构建与查询。
    - [P3808 【模板】AC自动机（简单版）](https://www.luogu.com.cn/problem/P3808)：进一步学习Trie树拓展AC自动机，用于多模式串匹配。
    - [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)：结合Trie树与异或运算，锻炼对Trie树在不同场景下的应用能力。

• 个人心得摘录与总结：
    - **作者：Cry_For_theMoon**：样例调试1小时发现DFS中删除、添加、修改操作的细节问题，总结出在Trie树上这些操作对应的路径特点，避免“假修改”情况。强调对这些细节的分析有助于理解和解决问题。
    - **作者：creation_hy**：指出DFS实现中的两个容易出错的点，一是只有完全匹配到某个串时才改vis数组，因为部分匹配可能只是前缀；二是不要一碰到vis[cur]==true就return，否则会遗漏前缀相同的串，导致得分低。提醒在DFS实现时注意这些细节。 

---
处理用时：73.08秒
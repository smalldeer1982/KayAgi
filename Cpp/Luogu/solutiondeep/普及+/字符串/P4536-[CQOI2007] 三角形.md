# 题目信息

# [CQOI2007] 三角形

## 题目描述

画一个等边三角形，把三边的中点连接起来，得到四个三角形，把它们称为 $T_1,T_2,T_3,T_4$，如图1。

把前三个三角形也这样划分，得到 $12$ 个更小的三角形，$T_{11},T_{12},T_{13},T_{14},T_{21},T_{22},T_{23},T_{24},T_{31},T_{32},T_{33},T_{34}$，如图2。

把编号以 $1,2,3$ 结尾的三角形又继续划分……最后得到的分形称为 Sierpinski 三角形。

![](https://cdn.luogu.com.cn/upload/pic/18501.png)

如果三角形 $B$ 不包含三角形 $A$，且 $A$ 的某一条完整的边是 $B$ 的某条边的一部分，则我们说 $A$ 靠在 $B$ 的边上。例如 $T_{12}$ 靠在 $T_{14}$ 和 $T_4$ 上，但不靠在 $T_{32}$ 上。

给出 Spierpinski 三角形中的一个三角形，找出它靠着的所有三角形。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 50$。

## 样例 #1

### 输入

```
T312```

### 输出

```
T314
T34
T4```

# AI分析结果

• **综合分析与结论**：这些题解主要通过找规律和模拟来解决问题。思路上，都先对末尾为4的三角形进行特判，其相邻三角形为前缀相同、末尾分别为1, 2, 3的三角形。对于末尾不为4的三角形，通过分析编号规律确定相邻三角形，如从编号每位数字判断相邻三角形、利用递归关系确定相邻三角形等。算法要点在于对不同情况的分类讨论和对规律的运用。解决难点在于准确找出三角形编号与相邻三角形之间的关系。从质量上看，多数题解思路较清晰，但部分代码可读性欠佳或优化不足。

### 所选的题解
#### 作者：RedreamMer (5星)
- **关键亮点**：思路清晰，简洁明了地阐述模拟思路，代码实现简洁高效，直接根据编号规律模拟寻找相邻三角形的过程。
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,ss[3];
int len;
int main() {
    cin>>s;
    len=s.size()-1;
    if(s[len]=='4') {
        cout<<s.substr(0,len)<<1<<endl<<s.substr(0,len)<<2<<endl<<s.substr(0,len)<<3;
        return 0;
    }
    for(int i=1; i<=len; i++) {
        if(s[i]=='1')
            ss[0]=s.substr(0,i)+"4";
        else if(s[i]=='2')
            ss[1]=s.substr(0,i)+"4";
        else if(s[i]=='3')
            ss[2]=s.substr(0,i)+"4";
    }
    sort(ss,ss+3); 
    for(int i=0; i<=2; i++)
        if(ss[i][0]=='T')
            cout<<ss[i]<<endl;
    return 0;
}
```
核心实现思想：先特判末尾为4的情况，直接输出相邻三角形。对于其他情况，从编号第二位开始遍历，根据当前位数字确定靠在某边的三角形并记录，最后排序输出。

#### 作者：xiaozeyu (4星)
- **关键亮点**：详细地阐述找规律过程，从简单特判到深入规律挖掘，逐步优化代码，逻辑清晰。
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[11000];
bool flag[5];
int main()
{
    memset(flag,false,sizeof(flag));
    cin>>a;
    int len=strlen(a);
    if(a[len-1]=='4')
    {
        for(int i=1;i<=3;i++)
        {
            for(int j=0;j<len-1;j++)
                cout<<a[j];
            cout<<i<<endl;
        }
        return 0;
    }
    for(int j=len-1;j>0;j--)
    {
        if(!flag[a[j]-'0'])
        {
            for(int i=0;i<j;i++)
            {
                cout<<a[i];
            }
            cout<<"4"<<endl;
            flag[a[j]-'0']=true;
        }
        if(flag[1]&&flag[2]&&flag[3])
            break;
    }
    return 0;
}
```
核心实现思想：先特判末尾为4的情况。对于其他情况，从编号末尾向前遍历，利用数组flag记录数字是否出现过，若未出现则更新并输出对应相邻三角形，若1, 2, 3都已出现则结束。

#### 作者：Light_Knight (4星)
- **关键亮点**：通过分析三角形位置关系，得出递归关系，思路巧妙，代码简洁且有优化。
```cpp
#include <bits/stdc++.h>
using namespace std;
string str,ans[3];  int len;
void find(string s,int l){
    if(!ans[3+'0'-s[l]].length()) 
        ans[3+'0'-s[l]] = s.substr(0,l)+"4"; 
    int t = l;
    while(s[t] == s[l]) t--;
    if(t == 0){ 
        sort(ans,ans+3);
        for(int i = 0;i < 3;i++){
            if(ans[i].length()) cout << ans[i] << '\n';
        }
        exit(0);
    }
    find(s.substr(0,t+1),t); 
}
int main(){
    cin >> str;  len = str.length()-1;
    if(str[len] == '4'){
        for(int i = 1;i <= 3;i++){
            cout << str.substr(0,len) << i << '\n';
        }
        return 0;
    }
    find(str,len);
    return 0;
}
```
核心实现思想：先特判末尾为4的情况。对于其他情况，通过递归函数find，根据当前位数字更新相邻三角形，同时优化跳过末尾连续相同编号，最后排序输出。

• **最优关键思路或技巧**：利用三角形编号规律，通过分类讨论（主要是末尾是否为4）来确定相邻三角形。在实现上，从编号每位数字出发，结合其位置特点确定相邻三角形，部分题解利用递归关系简化逻辑，同时注意对重复情况的处理和代码优化。

• **可拓展之处**：此类题目属于图形分形规律探索类型，类似套路是通过观察图形的层次结构和元素编号规律，建立数学模型或逻辑关系来解决问题。对于同类型题，可从更复杂的分形图形或更隐晦的元素关系入手，锻炼找规律和逻辑推导能力。

### 相似知识点洛谷题目
1. P1305 新二叉树：通过观察二叉树节点编号规律解决问题，与本题找编号规律类似。
2. P1085 不高兴的津津：根据给定条件找规律判断时间安排，考察找规律和模拟能力。
3. P1147 连续自然数和：通过分析数字组合规律解决问题，与本题找规律思路相似。

### 个人心得摘录与总结
1. 作者PanH提到在机房大佬启示下发现可以反着看题目更好懂，说明从不同角度思考问题可能会有更简便的思路。
2. 作者LlLlCc表示通过手玩数据推出结论，强调了手动模拟数据对发现规律的重要性。 

---
处理用时：37.17秒
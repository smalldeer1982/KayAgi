# 题目信息

# 「化学」相对分子质量

## 题目描述

做化学题时，小 F 总是里算错相对分子质量，这让他非常苦恼。

小 F 找到了你，请你来帮他算一算给定物质的相对分子质量。

如果你没有学过相关内容也没有关系，你可以从样例和提示里理解该题所求内容。

## 说明/提示

### 样例解释
金 $Au : 197$

二氧化铪 $HfO_{2}: 178.5 + 2 \times 16= 210.5$

氢氧化钙（熟石灰）$Ca(OH)_2 : 40 + (1 + 16) \times 2 = 74$

五水硫酸铜（胆矾）$CuSO_4 \cdot 5H_2O: 64 + 32 + 16 \times 4 + 5 \times (1 \times 2 + 16) = 250$

十二水合硫酸铝钾（明矾）$KAl(SO_{4})_{2} \cdot 12H_{2}O$ （嗯 用心感受 $474$ 是对的）

### 附表：可能用到的相对原子质量

|元素|相对原子质量|
|:-:|:-:|
|H|1|
|C|12|
|N|14|
|O|16|
|F|19|
|Na|23|
|Mg|24|
|Al|27|
|Si|28|
|P|31|
|S|32|
|Cl|35.5|
|K|39|
|Ca|40|
|Mn|55|
|Fe|56|
|Cu|64|
|Zn|65|
|Ag|108|
|I|127|
|Ba|137|
|Hf|178.5|
|Pt|195|
|Au|197|
|Hg|201|

### 提示

如果你没有学习过相关内容，下面的内容可能有帮助：

> zcy 教你算相对分子质量

1. 每个元素以大写开头；
2. 计算分子质量的方法就是对每个原子出现的次数乘对应的相对原子质量求和；
3. ~( $\cdot$ ) 相当于加；
4. 下标相当于乘。

## 样例 #1

### 输入

```
Au```

### 输出

```
197```

## 样例 #2

### 输入

```
HfO_{2}```

### 输出

```
210.5```

## 样例 #3

### 输入

```
Ca(OH)_{2}```

### 输出

```
74```

## 样例 #4

### 输入

```
CuSO_{4}~5H_{2}O```

### 输出

```
250```

## 样例 #5

### 输入

```
KAl(SO_{4})_{2}~12H_{2}O```

### 输出

```
474```

# AI分析结果

这道题要求根据给定的化学物质表达式计算其相对分子质量，题解主要围绕字符串处理展开，通过不同方式解析表达式中的元素、下标、括号及水合物部分。

### 综合分析与结论
- **思路**：多数题解采用从左到右扫描字符串的方式。先处理元素，利用元素大写开头的特点识别元素，通过打表获取其相对原子质量；接着处理下标，遇到“_”后提取大括号内数字作为下标；再处理括号，将括号内内容视为整体计算；最后处理水合物，“~”后提取系数与18相乘。部分题解还考虑了化学式可能存在的前缀数字等情况。
- **算法要点**：关键在于准确识别各类字符并正确处理其对应运算。常使用map存储元素及其相对原子质量以便快速查询。部分题解利用递归处理括号内复杂情况，部分则通过循环和标记变量模拟计算过程。
- **解决难点**：难点在于处理括号内表达式及下标，确保计算顺序和系数应用正确。同时要注意水合物系数可能省略，需默认为1 ，以及输出结果格式的处理。

### 题解评分
1. **作者：Iowa_BattleShip (赞：17)  4星**
    - **关键亮点**：思路清晰，代码简洁。利用map存储相对原子质量，通过自定义函数`cs`和`js`分别处理数字转换和元素质量计算，扫描字符串时针对不同字符（元素、括号、水合物）进行相应操作，逻辑连贯。
    - **个人心得**：无
    - **核心代码**：
```cpp
int cs(int &i) {
    int x = 0;
    for (; a[i] >= '0' && a[i] <= '9'; i++)
        x = x * 10 + (a[i] - '0');
    return x;
}
double js(int &i) {
    double s = 0;
    memset(b, 0, sizeof(b));
    for (ll = -1; ((a[i] >= 'A' && a[i] <= 'Z') || (a[i] >= 'a' && a[i] <= 'z')) && (ll < 0 || (ll >= 0 && (a[i] >= 'a' && a[i] <= 'z'))); i++)
        b[++ll] = a[i];
    if (a[i] == '_') {
        i += 2;
        s += mp[b] * cs(i);
    }
    else {
        s += mp[b];
        i--;
    }
    return s;
}
int main() {
    // 初始化map
    mp["H"] = 1; mp["C"] = 12; mp["N"] = 14; mp["O"] = 16; mp["F"] = 19; mp["Na"] = 23; mp["Mg"] = 24; mp["Al"] = 27; mp["Si"] = 28; mp["P"] = 31; mp["S"] = 32; mp["Cl"] = 35.5; mp["K"] = 39; mp["Ca"] = 40; mp["Mn"] = 55; mp["Fe"] = 56; mp["Cu"] = 64; mp["Zn"] = 65; mp["Ag"] = 108; mp["I"] = 127; mp["Ba"] = 137; mp["Hf"] = 178.5; mp["Pt"] = 195; mp["Au"] = 197; mp["Hg"] = 201;
    scanf("%s", a);
    l = strlen(a);
    for (i = 0; i < l; i++) {
        if (a[i] >= 'A' && a[i] <= 'Z')
            s += js(i);
        if (a[i] == '(') {
            i++;
            for (k = 0; a[i]!= ')'; i++)
                k += js(i);
            if (a[i + 1] == '_')
                s += k * cs(i += 3);
            else
                s += k;
        }
        if (a[i] == '~') {
            i++;
            if (a[i] == 'H')
                s += 18;
            else
                s += cs(i) * 18;
            break;
        }
    }
    o = s;
    if (o == s)
        printf("%d", o);
    else
        printf("%.1f", s);
    return 0;
}
```
    - **核心思想**：`cs`函数将字符转换为数字，`js`函数提取元素并根据是否有下标计算其质量。`main`函数中扫描字符串，遇到元素调用`js`，遇到括号计算括号内质量，遇到水合物计算水的质量并根据情况输出结果。

2. **作者：info___tion (赞：0)  4星**
    - **关键亮点**：采用递归方式处理，逻辑清晰，代码简洁易读。通过`col`函数获取元素相对原子质量，`solve`函数递归解析字符串，针对不同字符（元素、括号、水合物）进行分类处理。
    - **个人心得**：认为递归写法直观性高，出错可能性小，相比循环写法有优势。
    - **核心代码**：
```cpp
double col(string s) {
    if (s == "H") return 1;
    if (s == "C") return 12;
    if (s == "N") return 14;
    if (s == "O") return 16;
    if (s == "F") return 19;
    if (s == "Na") return 23;
    if (s == "Mg") return 24;
    if (s == "Al") return 27;
    if (s == "Si") return 28;
    if (s == "P") return 31;
    if (s == "S") return 32;
    if (s == "Cl") return 35.5;
    if (s == "K") return 39;
    if (s == "Ca") return 40;
    if (s == "Mn") return 55;
    if (s == "Fe") return 56;
    if (s == "Cu") return 64;
    if (s == "Zn") return 65;
    if (s == "Ag") return 108;
    if (s == "I") return 127;
    if (s == "Ba") return 137;
    if (s == "Hf") return 178.5;
    if (s == "Pt") return 195;
    if (s == "Au") return 197;
    if (s == "Hg") return 201;
}
double solve(string s) {
    double ret = 0.0;
    int cur = 0;
    while (cur < s.size()) {
        if (isupper(s[cur])) {
            string tmp;
            tmp += s[cur];
            int p = cur + 1;
            while (islower(s[p])) tmp += s[p], p++;
            double base = col(tmp);
            if (s[p] == '_') {
                p += 2;
                int num = 0;
                while (isdigit(s[p])) num = num * 10 + s[p] - '0', p++;
                p++;
                ret += base * num;
            }
            else ret += base;
            cur = p;
        }
        else if (s[cur] == '(') {
            int p = ++cur;
            while (s[p]!= ')') p++;
            double base = solve(s.substr(cur, p - cur));
            p++;
            if (s[p] == '_') {
                p += 2;
                int num = 0;
                while (isdigit(s[p])) num = num * 10 + s[p] - '0', p++;
                p++;
                ret += base * num;
            }
            else ret += base;
            cur = p;
        }
        else if (s[cur] == '~') {
            int p = cur + 1;
            int num = 0;
            while (isdigit(s[p])) num = num * 10 + s[p] - '0', p++;
            if (!num) num = 1;
            ret += H_2O * num;
            break;
        }
    }
    return ret;
}
```
    - **核心思想**：`col`函数打表返回元素相对原子质量。`solve`函数中，扫描字符串，遇到元素获取其质量并根据下标计算，遇到括号递归计算括号内质量，遇到水合物计算水的质量并返回总质量。

3. **作者：引领天下 (赞：2)  4星**
    - **关键亮点**：思路清晰，代码简短高效。通过map存储元素质量，对元素、下标、原子团和水合物分别用不同函数处理，利用递归解决原子团嵌套问题，逻辑严谨。
    - **个人心得**：认为本题无需使用单调栈等复杂结构，逐个击破即可。
    - **核心代码**：
```cpp
inline void start() {
    mp["H"] = 1; mp["C"] = 12; mp["N"] = 14; mp["O"] = 16; mp["F"] = 19; mp["Na"] = 23; mp["Mg"] = 24; mp["Al"] = 27; mp["Si"] = 28; mp["P"] = 31; mp["S"] = 32; mp["Cl"] = 35.5; mp["K"] = 39; mp["Ca"] = 40; mp["Mn"] = 55; mp["Fe"] = 56; mp["Cu"] = 64; mp["Zn"] = 65; mp["Ag"] = 108; mp["I"] = 127; mp["Ba"] = 137; mp["Hf"] = 178.5; mp["Pt"] = 195; mp["Au"] = 197; mp["Hg"] = 201;
}
int ys(int k) {
    string s = ""; int j = k + 1; s += a[k];
    for (; a[j] >= 'a' && a[j] <= 'z'; j++)s += a[j];
    ans += last = mp[s];
    return j;
}
int xb(int k) {
    int j = k + 2, s = 0;
    for (; a[j] >= '0' && a[j] <= '9'; j++)s = s * 10 + a[j] - '0';
    ans -= last, ans += last * s;
    return j;
}
double tmp, tlast;
int xbk(int k) {
    int j = k + 2, s = 0;
    for (; a[j] >= '0' && a[j] <= '9'; j++)s = s * 10 + a[j] - '0';
    tmp -= tlast, tmp += tlast * s;
    return j;
}
int ysk(int k) {
    string s = ""; int j = k + 1; s += a[k];
    for (; a[j] >= 'a' && a[j] <= 'z'; j++)s += a[j];
    tmp += tlast = mp[s];
    return j;
}
inline int kh(int k) {
    int j = k + 1, h = 1;
    while (h!= 0) {
        if (a[j] == ')')h--;
        if (!h)break;
        if (a[j] >= 'A' && a[j] <= 'Z') {
            j = ysk(j);
            if (a[j] == '_')j = xbk(j) + 1;
        }
        else if (a[j] == '(')h++, j = kh(j);
    }
    if (a[j + 1] == '_')ans += tmp, last = tmp, j = xb(j + 1);
    tmp = 0;
    return j;
}
void sh(int k) {
    int j = k + 1, f = 0;
    for (; a[j] >= '0' && a[j] <= '9'; j++)f = f * 10 + a[j] - '0';
    if (!f)f++;
    ans += f * 18;
}
int main() {
    start();
    cin >> a;
    for (int i = 0; i < a.size(); i++) {
        if (a[i] >= 'A' && a[i] <= 'Z')i = ys(i) - 1;
        else if (a[i] == '_')i = xb(i);
        else if (a[i] == '(')i = kh(i);
        else if (a[i] == '~') { sh(i); break; }
    }
    printf("%g", ans);
    return 0;
}
```
    - **核心思想**：`start`函数初始化map。`ys`函数处理单个元素，`xb`函数处理外部下标，`xbk`函数处理括号内下标，`ysk`函数处理括号内元素，`kh`函数递归处理括号，`sh`函数处理水合物。`main`函数扫描字符串，调用相应函数计算总质量。

### 最优思路与技巧
- **数据结构**：使用map存储元素及其相对原子质量，能快速根据元素名称获取质量，提高查询效率。
- **算法优化**：利用递归处理括号内表达式，使代码逻辑清晰，易于理解和实现，同时保证计算顺序正确。在处理下标时，采用类似快速读入的方式提取数字，简洁高效。
- **代码实现技巧**：对不同类型字符（元素、下标、括号、水合物）进行分类处理，分别编写函数实现其对应逻辑，使代码结构清晰，易于维护。

### 可拓展之处
同类型题通常围绕字符串处理和特定规则计算，如根据特定语法规则解析数学表达式、根据特定格式计算化合物中元素含量等。类似算法套路为扫描字符串，依据字符类型和规则进行相应处理，复杂部分可采用递归简化逻辑。

### 相似知识点题目推荐
 - **P1046 [NOIP2005 普及组] 陶陶摘苹果**：涉及简单的条件判断和数据处理，与本题处理不同字符情况类似，锻炼基本逻辑思维。
 - **P1909 买铅笔**：通过分析不同购买方案计算最优解，和本题根据不同规则（元素、下标等）计算结果思路相似，培养问题分析和计算能力。
 - **P2670 [NOIP2015 普及组] 扫雷游戏**：基于二维字符数组进行特定规则的计算和判断，与本题对字符串按规则处理类似，提升对复杂数据结构和规则的处理能力。

### 个人心得摘录与总结
 - **作者：cym_233**：模拟题代码长，调试时易绕晕，要注意避免在复杂代码中迷失逻辑，调试时需保持清晰思路。
 - **作者：一扶苏一**：浮点数运算要注意数据类型一致性，避免因数据类型错误导致结果出错。同时，STL的string型使用时要注意调用`clear()`函数清零。
 - **作者：引领天下**：本题无需使用复杂数据结构如单调栈，逐个分析处理元素、下标、原子团和水合物等部分即可，提醒在解题时不要过度复杂化，要选择合适方法。 

---
处理用时：110.57秒
# 题目信息

# [1007] Scarlet的字符串不可能这么可爱

## 题目描述

Scarlet妄图构造字符集为$k$，长度为$L$的字符串，满足没有任何一个长度超过$1$的回文连续子串。

看起来这样的字符串太多了，Scarlet随手加了个限制：她指定了字符串的第$s$位为$w$。

这下Scarlet不会做了，请你来帮她计算究竟有多少满足条件的字符串。按照套路，你只要求出答案对$p$取模后的结果。

## 说明/提示

字符集：一个字符串中不同字符的数量。例如，字符集是3的话，你可以认为字符串仅由“A”、“B”、“C”三个字母组成。

样例解释：第一个字符固定A，那么符合要求的字符串是ABC,ACB。而AAB字符串包括AA这个回文子串，ACA本身就是回文串，一次类推。

对于50%的数据，$k\leq5,L\leq10$

对于另30%的数据，$s=0$

对于100%的数据$1\leq k,L\leq 10^{18},0\leq s\leq L,1\leq w\leq k,1\leq p\leq 10^9$


## 样例 #1

### 输入

```
3 3 233
1 1```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：这些题解均围绕如何计算满足特定条件字符串数量展开，思路核心是利用乘法原理。首先分析无限制时字符串各位置字符选择数得出方案数公式，再探讨有限制时的变化。算法要点为快速幂计算幂次以应对大数据规模，难点在于理解并证明有限制时答案与无限制时的关系。部分题解通过不同方式推导，如模拟构造、分析回文子串条件、利用对称性等。

所选的题解：
  - **作者：VenusM1nT (5星)**
    - **关键亮点**：思路清晰，先通过具体例子推导出无限制和有限制时的结论公式，再用代码实现，对特殊情况如 \( l = 1 \) 进行特判，代码简洁明了。
    - **个人心得**：赛场上手推结论，证明过程虽不严谨但提供了思路。
    ```cpp
    #include<bits/stdc++.h>
    #define ll long long
    using namespace std;
    ll k,l,Mod,s,w,ans=1;
    ll poww(ll a,ll b){
        ll sum=1;
        a%=Mod;
        while(b!=0){
            if(b&1!=0) sum=sum*a%Mod;
            b=b >> 1;
            a=a*a%Mod;
        }
        return sum;
    }
    int main()
    {
        scanf("%lld %lld %lld %lld %lld",&k,&l,&Mod,&s,&w);
        k%=Mod;
        if(l==1){
            if(s) printf("1");
            else printf("%lld",k);
        }
        if(s) ans=ans*(k-1)%Mod;
        else ans=ans*k*(k-1)%Mod;
        k-=2;
        ans=(ans*poww(k,l-2))%Mod;
        printf("%lld",ans);
        return 0;
    }
    ```
    - **核心实现思想**：通过 `poww` 函数实现快速幂计算，在 `main` 函数中根据有无指定字符分别计算答案并取模。
  - **作者：WYXkk (4星)**
    - **关键亮点**：先分析回文连续子串的等价条件，即任意两个相邻或间隔一个字符的字符不相等，从而得出无限制和有限制时的方案数公式，表述简洁。
    ```cpp
    // 代码略，作者未提供
    ```
    - **核心实现思想**：虽未给出代码，但思路上是基于推导出的公式，大概率使用快速幂实现计算。
  - **作者：lgswdn_SA (4星)**
    - **关键亮点**：从乘法原理出发，对 \( s = 0 \) 和 \( s \neq 0 \) 的情况分别详细讨论，通过分类讨论不同位置被指定时的字符选择情况得出结论，代码实现完整且考虑到取模的细节。
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    typedef long long ll;

    ll k,n,p,s,w;

    ll ksm(ll a,ll b) {
        if(b==0) return 1;
        else if(b==1) return a;
        else return ksm(a*a%p,b/2)*(b%2?a:1)%p;
    }

    int main() {
        scanf("%lld%lld%lld%lld%lld",&k,&n,&p,&s,&w);
        k%=p; while(k<2) k+=p;
        if(n==1) printf("%lld",(s?1:k));
        else if(!s) printf("%lld",k*(k-1)%p*ksm(k-2,n-2)%p);
        else printf("%lld",(k-1)*ksm(k-2,n-2)%p);
        return 0;
    }
    ```
    - **核心实现思想**：`ksm` 函数实现快速幂，`main` 函数根据输入判断情况，依据推导出的公式计算并输出结果，对 \( k \) 取模后还处理了 \( k < 2 \) 的特殊情况。

**最优关键思路或技巧**：利用乘法原理分析每个位置字符选择数，通过模拟、对称性分析等方法得出无限制和有限制时的方案数公式，采用快速幂优化幂运算时间复杂度。

**可拓展之处**：同类型题常围绕特定字符串规则计算方案数，类似算法套路是先分析规则对字符选择的限制，利用乘法原理得出方案数公式，再根据数据规模选择合适优化，如快速幂。

**推荐题目**：
  - [P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226)
  - [P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)
  - [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)

**个人心得摘录与总结**：VenusM1nT 在赛场上通过手推得出结论，虽证明不严谨但提供了解题思路，强调推导过程对解题的重要性。 

---
处理用时：27.42秒
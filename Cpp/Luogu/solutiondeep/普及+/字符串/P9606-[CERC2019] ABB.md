# 题目信息

# [CERC2019] ABB

## 题目背景

**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[ABB](https://contest.felk.cvut.cz/19cerc/solved/abb.pdf)」**

## 题目描述

Fernando 受雇于滑铁卢大学，负责完成该大学不久前开始的一个开发项目。在校园外，该大学希望为重要的外国游客和合作者建造具有代表性的平房街。

目前，这条街只建了一部分，它从湖岸开始，一直延伸到森林尽头。Fernando 的任务是通过在森林尽头建造更多的平房来完成这条街。所有现有的平房都坐落在街道的一侧，新的平房应该建在同一侧。这些平房有各种各样的类型，漆成各种各样的颜色。

在 Fernando 看来，整条街的布局有点混乱。他担心增加新平房后，它会看起来更加混乱。所以他想通过为新平房选择合适的颜色来增加一些排列顺序。当项目完成时，平房的整个颜色序列将是对称的，也就是说，从街道的两端观察时，颜色序列是相同的。

在其他问题中，Fernando 想知道，在满足平房颜色限制的情况下，他最少需要用来建造和适当染色才能完成项目的新平房数量。

### 简要题意

求使给定小写字母字符串成为回文串需在字符串末尾加入字母的最少数量。

## 样例 #1

### 输入

```
3
abb
```

### 输出

```
1
```

## 样例 #2

### 输入

```
12
recakjenecep
```

### 输出

```
11
```

## 样例 #3

### 输入

```
15
murderforajarof
```

### 输出

```
6
```

# AI分析结果

• 综合分析与结论：
    - 这些题解主要围绕求使给定字符串成为回文串需在末尾添加的最少字符数这一问题，核心思路是找出字符串的最长回文后缀，答案即为原字符串长度减去最长回文后缀长度。
    - 采用的算法主要有哈希、KMP、Manacher算法。哈希算法通过正向和反向计算哈希值，枚举位置判断是否构成回文后缀；KMP算法将字符串反转后与原串拼接，利用KMP的next数组求最长回文后缀；Manacher算法通过处理字符串，利用回文半径数组找出最长回文后缀。
    - 各题解在思路清晰度、代码可读性、优化程度上存在差异。

• 星级题解：
  - **KMP题解**：
    - 星级：5星
    - 关键亮点：思路清晰，将问题转化为求最长回文后缀，利用KMP算法巧妙解决。先把字符串反转，与原串通过分隔符拼接，然后做KMP求next数组，直接得出最长回文后缀长度，时间复杂度为O(n)，代码简洁高效。
    - 核心代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=800005;
int n,ne[N];
char s[N];
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>s+n+2;
    s[n+1]='%';
    for(int i=1,j=2*n+1;i<=n;i++,j--)s[i]=s[j];
    int now=0;
    for(int i=2;i<=2*n+1;i++)
    {
        while(now&&s[now+1]!=s[i])now=ne[now];
        if(s[now+1]==s[i])now++;
        ne[i]=now;
    }
    cout<<n-ne[2*n+1];
    return 0;
}
```
    - 核心实现思想：先将原字符串反转后与原串通过分隔符拼接，然后利用KMP算法的next数组求解最长回文后缀长度。遍历拼接后的字符串，通过不断调整前缀长度，记录每个位置的最长相同前缀后缀长度，最后用原串长度减去该长度得到答案。
  - **哈希题解（作者：ZHR100102）**：
    - 星级：4星
    - 关键亮点：通过正向和反向分别做哈希，然后枚举回文中心，利用哈希值快速判断回文后缀，时间复杂度为O(n)。思路直接，代码实现较为规范。
    - 核心代码：
```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define lc (p<<1)
#define rc ((p<<1)|1)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pi;
const int N=400005;
const ull base=13331;
ull phash[N],shash[N],pw[N];
int n,ans;
char s[N];
void dohash()
{
    pw[0]=1;
    for(int i=1;i<N;i++)pw[i]=pw[i-1]*base;
    for(int i=1;i<=n;i++)phash[i]=phash[i-1]*base+s[i];
    for(int i=n;i>=1;i--)shash[i]=shash[i+1]*base+s[i];
}
ull gethash(int op,int l,int r)
{
    if(op==0)return (phash[r]-phash[l-1]*pw[r-l+1]);
    return (shash[l]-shash[r+1]*pw[r-l+1]);
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>s+1;
    ans=n-1;
    if(n==1)
    {
        cout<<0;
        return 0;
    }
    dohash();
    for(int i=1;i<=n;i++)
    {
        if(i-1>=n-(i+1)+1)
        {
            int len=n-(i+1)+1;
            if(gethash(0,i-1-len+1,i-1)==gethash(1,i+1,i+1+len-1))
            {
                ans=min(ans,i-1-len);
            }
        }
        if(i>=n-(i+1)+1)
        {
            int len=n-(i+1)+1;
            if(gethash(0,i-len+1,i)==gethash(1,i+1,i+1+len-1))
            {
                ans=min(ans,i-len);
            }
        }
    }
    cout<<ans;
    return 0;
}
```
    - 核心实现思想：先预处理出正向和反向的哈希数组以及幂数组，然后枚举每个位置作为回文中心，根据回文中心两侧的哈希值判断是否为回文后缀，不断更新最少需要添加的字符数。
  - **哈希题解（作者：llxsmy_forever）**：
    - 星级：4星
    - 关键亮点：采用贪心策略，通过哈希枚举包含最后一个字符的最长回文子串的左端点，找到最长回文子串，进而得出需添加的最少字符数，思路易懂，代码简洁。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
//unsigned long long 自动溢出，不用手动取模
#define ull unsigned long long
using namespace std;
const int N=4e5+100;
const ull base=13331;
ull h1[N],h2[N],p[N];
char s[N];
ull get1(int l,int r){return h1[r]-h1[l-1]*p[r-l+1];}
ull get2(int l,int r){return h2[l]-h2[r+1]*p[r-l+1];}
int main(){
    int n;scanf("%d",&n);
    scanf("%s",s+1);
    h1[0]=h2[0]=0,p[0]=1;
    for(int i=1,j=n;i<=n;i++,j--){
    //正着求一次，反着求一次
        h1[i]=h1[i-1]*base+s[i]-'a';
        h2[j]=h2[j+1]*base+s[j]-'a';
        p[i]=p[i-1]*base;
    }
    for(int i=1;i<=n;i++){
        int m1=i+n>>1,m2=(i+n&1)?m1+1:m1;
        //从小到大枚举，第一个符合的一定是最长的回文子串
        if(get1(i,m1)==get2(m2,n)){
            printf("%d",i-1);
            break;
        }
    }
    return 0;
}
```
    - 核心实现思想：先正向和反向预处理哈希数组和幂数组，然后从小到大枚举包含最后一个字符的回文子串的左端点，通过哈希值判断是否为回文子串，第一个满足条件的即为最长回文子串，用原串长度减去其长度得到答案。

• 最优关键思路或技巧：
    - **思维方式**：将问题转化为求最长回文后缀，大大简化问题。
    - **算法选择**：KMP算法利用其求最长相同前缀后缀的特性，巧妙解决问题，代码简洁且时间复杂度低；哈希算法通过预处理哈希值，实现O(1)时间内判断子串是否相等，从而快速找出最长回文后缀。

• 拓展思路：
    - 同类型题常围绕字符串回文相关问题，如给定字符串求最长回文子串长度、判断字符串是否为回文等。类似算法套路包括利用哈希快速判断子串相等、KMP处理字符串匹配问题、Manacher算法处理回文串问题等。

• 推荐题目：
    - P3370 【模板】字符串哈希
    - P1355 神秘的咒语
    - P4555 [国家集训队]最长双回文串

• 个人心得：无 

---
处理用时：46.36秒
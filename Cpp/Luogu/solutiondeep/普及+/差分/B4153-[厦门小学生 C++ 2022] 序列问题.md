# 题目信息

# [厦门小学生 C++ 2022] 序列问题

## 题目背景

本试题为 2022 年厦门市小学生 C++ 语言**复赛**试题，数据为洛谷自造。

**初赛**为笔试。

考虑到评测机性能差异，本题时限相较原题下调 0.5s。

## 题目描述

高老师是一位经验丰富的信息学竞赛指导教师，善于开发学生的创造性思维。周末课上，他给学生留下一道关于 $01$ 串的思考题（所谓 $01$ 串就是由字符 $0$ 和 $1$ 组成的字符串）：给定一个长度为 $n$ 的 $01$ 串，他想知道有多少个子串，满足其中 $1$ 的个数比 $0$ 的个数多。现在高老师请会编程的你来帮忙计算答案。 

## 说明/提示

### 样例解释

满足条件的子串有：$1$，$1$，$1$，$11$，$11$，$111$

### 数据范围

- 对于 $20\%$ 的数据，$n\leq 3000$。
- 对于另外的 $10\%$ 的数据，$n\leq 10^7$，字符串全为 $1$。
- 对于另外的 $20\%$ 的数据，$n\leq 2\times 10^5$。
- 对于另外的 $20\%$ 的数据，$n\leq 2\times 10^6$。
- 对于另外的 $100\%$ 的数据，$n\leq 10^7$。

## 样例 #1

### 输入

```
3
111```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地统计满足条件的子串数量，即子串中 $1$ 的个数比 $0$ 多。暴力解法的时间复杂度为 $O(n^2)$，无法通过大规模数据。优化思路主要集中在利用前缀和和哈希表（或数组）来快速计算满足条件的子串数量。

各题解的优化思路相似，均通过前缀和和哈希表（或数组）来降低时间复杂度。其中，**yedalong** 和 **_Deer_Peach_** 的题解较为清晰，代码可读性高，且优化到位，最终时间复杂度为 $O(n)$，能够通过所有测试用例。**wenlebo** 的题解虽然思路正确，但代码可读性稍差，且未完全优化到位。

### 所选高星题解

#### 1. yedalong (5星)
- **关键亮点**：思路清晰，代码简洁，优化到位。通过前缀和和数组代替哈希表，避免了哈希表的性能瓶颈，最终时间复杂度为 $O(n)$。
- **个人心得**：作者提到“哈希表很浪费时间”，并建议改用数组来优化性能，这一点在实际编程中非常实用。
- **核心代码**：
  ```cpp
  #include<bits/stdc++.h>
  #define ll long long
  using namespace std;
  string s;
  ll ans,sum,cnt,n,mp[20000005];
  int main(){
      cin>>n>>s;
      mp[n]=1;
      for(int i=0;i<n;i++){
          if(s[i]=='1') cnt+=mp[n+sum],sum++;
          else cnt-=mp[n+sum-1],sum--;
          mp[n+sum]++; ans+=cnt;
      }
      cout<<ans<<'\n';
      return 0;
  }
  ```

#### 2. _Deer_Peach_ (4星)
- **关键亮点**：思路清晰，代码简洁，优化到位。通过前缀和和数组代替哈希表，避免了哈希表的性能瓶颈，最终时间复杂度为 $O(n)$。
- **核心代码**：
  ```cpp
  #include<bits/stdc++.h>
  #define int long long
  using namespace std;
  const int N=1e7+5;
  int n,res,num,ans;
  char s[N];
  int mp[N*2];
  signed main(){
      scanf("%lld",&n);
      scanf("%s",s+1);
      mp[n]=1;
      for(int i=1;i<=n;i++){
          ans+=s[i]=='1'?mp[n+num]:-mp[n+num-1];
          num+=s[i]=='1'?1:-1;
          mp[n+num]++,res+=ans;
      }printf("%lld",res);
      return 0;
  }
  ```

### 最优关键思路与技巧

1. **前缀和优化**：将 $1$ 的贡献设为 $1$，$0$ 的贡献设为 $-1$，通过前缀和快速计算子串中 $1$ 和 $0$ 的数量差。
2. **数组代替哈希表**：由于前缀和的范围有限，可以用数组代替哈希表，避免哈希表的性能瓶颈。
3. **动态维护满足条件的子串数量**：通过动态维护当前前缀和小于当前值的数量，快速计算满足条件的子串数量。

### 可拓展之处

- **类似问题**：类似的问题可以扩展到其他字符或数字的统计，如统计子串中某个字符的出现次数大于另一个字符的出现次数。
- **算法套路**：前缀和+哈希表（或数组）的优化套路在统计子串问题时非常常见，可以应用到其他类似问题中。

### 推荐题目

1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)
2. [P1637 三元上升子序列](https://www.luogu.com.cn/problem/P1637)
3. [P1496 火烧赤壁](https://www.luogu.com.cn/problem/P1496)

这些题目都涉及到前缀和和哈希表（或数组）的优化，可以帮助进一步巩固相关知识点。

---
处理用时：29.46秒
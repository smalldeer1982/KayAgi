# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 操作序列

## 题目描述

有 $n$ 个变量 $x[1 \sim n]$，初始值都为 0。

依次给出 $m$ 个操作的信息，操作分为 2 种：

- $(1, id, v)$: 代表将 $x[id]$ 的值加上 $v$；
- $2$: 代表将所有变量的值乘 $2$；

所有运算在 $(\bmod \ 10^4)$ 下执行，提示：模意义下的加减乘运算

- 加：`c = (a + b) % mod`；
- 减：`c = (a - b + mod) % mod`；
- 乘：`c = a * b % mod`；

现在给出一个操作序列，请问依次执行序列中的所有操作之后，每个变量的值是多少。

具体的，操作序列以 $q$ 个区间 $[l[i], r[i]]$ 的形式给出，依次执行每个区间、每个区间按编号从小->大执行区间内的操作，即完整的操作序列为：

- $l[1] \sim r[1], l[2] \sim r[2], l[3] \sim r[3], \ldots, l[q] \sim r[q]$

## 说明/提示

### 样例 3-8

见附件。

### 数据范围

对于所有数据，$1 \leq n, m, q \leq 2 \times 10^5, op = \{1, 2\}, 1 \leq id \leq n, 1 \leq v \leq 10^9$，假设 $m$ 种操作中第 1、2 种操作的总数为 $m_1, m_2$，满足 $m_1 + m_2 = m$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | 数据范围 | 特殊性质 | 子任务依赖 |
|:------------:|:------:|:----------:|:----------:|:------------:|
| 1          | 15   | $n, m, q \leq 500$ |          |            |
| 2          | 19   | $n, m, q \leq 5000$ |          | 1          |
| 3          | 11   | $n, m, q \leq 2 \times 10^5$ | $m_2 = 0$ |            |
| 4          | 17   | $n, m, q \leq 2 \times 10^5$ | $m_1 = 1, m_2 = m - 1$ |            |
| 5          | 17   | $n, m, q \leq 2 \times 10^5$ | $m_1 = m - 1, m_2 = 1$ |            |
| 6          | 21   | $n, m, q \leq 2 \times 10^5$ |          | 1,2,3,4,5          |

## 样例 #1

### 输入

```
5 5 5
2
1 1 3
2
2
1 3 3
2 5
1 2
1 1
2 2
3 4```

### 输出

```
228 0 48 0 0```

## 样例 #2

### 输入

```
10 10 10
1 4 1
1 7 3
1 4 5
1 1 3
2
1 5 5
2
2
1 8 2
1 7 1
1 8
1 1
7 8
1 4
8 9
3 9
2 10
4 7
3 6
6 9```

### 输出

```
2536 0 0 8952 3560 0 6304 4674 0 0```

# AI分析结果

### 综合分析与结论

本题的核心在于处理大规模操作序列，并高效计算每个变量的最终值。由于操作序列可能包含大量的乘法和加法操作，直接模拟每个操作会导致时间复杂度过高，因此需要采用更高效的算法。

### 关键思路与技巧

1. **操作序列的区间处理**：由于操作序列是以区间形式给出的，需要依次处理每个区间内的操作。可以通过预处理操作序列，记录每个操作的类型和参数，然后根据区间范围依次执行。

2. **乘法操作的优化**：乘法操作会影响所有变量的值，因此可以将乘法操作的影响累积起来，而不是每次都对所有变量进行乘法操作。具体来说，可以记录当前乘法操作的累积次数，然后在最终计算时一次性应用这些乘法操作。

3. **模运算的处理**：所有运算都在模 $10^4$ 下进行，因此需要在每次加法或乘法操作后立即取模，以避免数值溢出。

### 推荐题目

1. **P3372 【模板】线段树 1** - 考察区间操作和区间查询，与本题的区间处理思路相似。
2. **P1908 逆序对** - 考察大规模数据处理和优化技巧，与本题的优化思路相似。
3. **P1047 校门外的树** - 考察区间操作和模拟处理，与本题的操作序列处理思路相似。

### 通用建议与扩展思路

1. **预处理操作序列**：在处理大规模操作序列时，预处理操作序列可以显著提高效率。可以通过记录每个操作的类型和参数，然后根据区间范围依次执行。

2. **累积乘法操作**：对于影响所有变量的操作（如乘法操作），可以通过累积操作次数来优化处理。在最终计算时一次性应用这些操作，可以减少重复计算。

3. **模运算的处理**：在处理模运算时，需要注意每次操作后立即取模，以避免数值溢出。同时，可以使用快速幂算法来优化模运算的计算。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 10000;

int main() {
    int n, m, q;
    cin >> n >> m >> q;
    vector<pair<int, pair<int, int>>> ops(m);
    for (int i = 0; i < m; ++i) {
        int op;
        cin >> op;
        if (op == 1) {
            int id, v;
            cin >> id >> v;
            ops[i] = {op, {id, v}};
        } else {
            ops[i] = {op, {0, 0}};
        }
    }
    vector<int> x(n + 1, 0);
    int mul = 1;
    for (int i = 0; i < q; ++i) {
        int l, r;
        cin >> l >> r;
        for (int j = l - 1; j < r; ++j) {
            if (ops[j].first == 1) {
                int id = ops[j].second.first;
                int v = ops[j].second.second;
                x[id] = (x[id] + v * mul) % MOD;
            } else {
                mul = (mul * 2) % MOD;
            }
        }
    }
    for (int i = 1; i <= n; ++i) {
        x[i] = (x[i] * mul) % MOD;
        cout << x[i] << " ";
    }
    cout << endl;
    return 0;
}
```

### 代码核心思想

1. **预处理操作序列**：将每个操作的类型和参数存储在 `ops` 数组中。
2. **累积乘法操作**：使用 `mul` 变量记录当前乘法操作的累积次数。
3. **处理区间操作**：根据给定的区间范围，依次执行区间内的操作。对于加法操作，直接更新对应变量的值；对于乘法操作，更新 `mul` 变量。
4. **最终计算**：在完成所有操作后，将每个变量的值乘以 `mul`，并输出结果。

通过上述优化，可以高效处理大规模操作序列，并计算出每个变量的最终值。

---
处理用时：27.71秒
# 题目信息

# 工程规划

## 题目描述

造一幢大楼是一项艰巨的工程，它是由 $n$ 个子任务构成的，给它们分别编号 $1,2,\cdots,n\ (5≤n≤1000)$。由于对一些任务的起始条件有着严格的限制，所以每个任务的起始时间 $T_1,T_2,\cdots,T_n$ 并不是很容易确定的(但这些起始时间都是非负整数，因为它们必须在整个工程开始后启动)。例如：挖掘完成后，紧接着就要打地基；但是混凝土浇筑完成后，却要等待一段时间再去掉模板。

这种要求就可以用 $m\ (5≤m≤5000)$ 个不等式表示，不等式形如 $T_i-T_j≤b$ 代表 $i$ 和 $j$ 的起始时间必须满足的条件。每个不等式的右边都是一个常数 $b$，这些常数可能不相同，但是它们都在区间 $(-100,100)$ 内。

你的任务就是写一个程序，给定像上面那样的不等式，找出一种可能的起始时间序列 $T_1,T_2,\cdots,T_n$，或者判断问题无解。对于有解的情况，要使最早进行的那个任务和整个工程的起始时间相同，也就是说，$T_1,T_2,\cdots,T_n$ 中至少有一个为 $0$。


## 说明/提示

由@zhouyonglong提供SPJ


## 样例 #1

### 输入

```
5 8
1 2 0
1 5 -1
2 5 1
3 1 5
4 1 4
4 3 -1
5 3 -1
5 4 -3```

### 输出

```
0
2
5
4
1
```

## 样例 #2

### 输入

```
5 5
1 2 -3
1 5 -1
2 5 -1
5 1 -5
4 1 4```

### 输出

```
NO SOLUTION
```

# AI分析结果

### 综合分析与结论

这些题解的核心思路都是基于**差分约束系统**，通过将不等式转化为图的边，并使用**SPFA**（Shortest Path Faster Algorithm）来求解最短路径。难点在于如何正确处理负环（无解情况）以及如何确保至少有一个任务的起始时间为0。大部分题解都采用了**超级源点**的方法来保证图的连通性，并通过调整最终解来满足非负且至少有一个0的条件。

### 所选高质量题解

#### 1. 作者：L_M_ (赞：39)  
**星级：5星**  
**关键亮点**：  
- 详细解释了差分约束的建图原理，特别是如何将不等式转化为图的边。
- 使用超级源点保证图的连通性，并详细说明了负环的判断方法。
- 代码结构清晰，注释详细，易于理解。

**核心代码片段**：
```cpp
void spfa(int s) {
    queue<int> q;
    memset(dis,0x3f,sizeof(dis));
    dis[s] = 0;
    q.push(s);
    instack[s] = 1;
    while(q.size()) {
        int u = q.front();
        q.pop();
        popst[u]++;
        if(popst[u] > n - 1) { printf("NO SOLUTION"); return;}
        instack[u] = 0;
        for(int i = fir[u];i;i = e[i].next) {
            int v = e[i].to,w = e[i].cost;
            if(dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if(!instack[v]) q.push(v),instack[v] = 1;
            }
        }
    }
    for(int i = 1;i <= n;i++) minm = min(minm,dis[i]);
    for(int i = 1;i <= n;i++) printf("%d\n",dis[i] - minm);
}
```

#### 2. 作者：SDqwq (赞：11)  
**星级：4.5星**  
**关键亮点**：  
- 详细解释了SPFA的更新过程与差分约束的关系，逻辑清晰。
- 通过减去最小值来确保至少有一个0，代码简洁高效。
- 提供了对无解情况的详细说明。

**核心代码片段**：
```cpp
bool spfa (int x) {
    dis[x] = 0;
    q.push(x);
    vis[x] = true;
    num[x]++;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = elast[u]; i != 0; i = e[i].next)
            if (dis[e[i].to] > dis[u] + e[i].len) {
                dis[e[i].to] = dis[u] + e[i].len;
                if (!vis[e[i].to]) {
                    q.push(e[i].to);
                    vis[e[i].to] = true;
                    num[e[i].to]++;
                    if (num[e[i].to] == n)
                        return false;
                }
            }
    }
    return true;
}
```

#### 3. 作者：一只书虫仔 (赞：8)  
**星级：4星**  
**关键亮点**：  
- 通过递推式解释了差分约束的核心思想，逻辑清晰。
- 使用超级源点保证图的连通性，并通过减去最小值来满足非负条件。
- 代码结构清晰，注释详细。

**核心代码片段**：
```cpp
bool SPFA () {
    queue <int> q;
    int s = n + 1;
    for (int i = 1; i <= n; i++)
        dist[i] = inf;
    dist[s] = 0;
    sum[s] = 1;
    vis[s]++;
    q.push(s);
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        sum[cur] = 0;
        for (int p = head[cur]; p > 0; p = e[p].next)
            if (dist[e[p].val] > dist[cur] + e[p].len) {
                dist[e[p].val] = dist[cur] + e[p].len;
                vis[e[p].val]++;
                if (vis[e[p].val] >= n + 1)
                    return true;
                if (!sum[e[p].val]) {
                    q.push(e[p].val);
                    sum[e[p].val] = 1;
                }
            }
    }
    return false;
}
```

### 最优关键思路与技巧

1. **差分约束建图**：将不等式 \(T_i - T_j \leq b\) 转化为从 \(j\) 到 \(i\) 的边，权值为 \(b\)。
2. **超级源点**：通过添加一个超级源点，向所有节点连边，保证图的连通性。
3. **负环判断**：使用SPFA判断负环，若存在负环则无解。
4. **调整解**：通过减去最小值来确保至少有一个0，并满足非负条件。

### 拓展与举一反三

1. **类似算法套路**：差分约束系统常用于处理不等式约束问题，类似的题目可以通过建图+最短路算法解决。
2. **推荐题目**：
   - [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)
   - [P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)
   - [P1260 工程规划](https://www.luogu.com.cn/problem/P1260)

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中发现图不连通的问题，通过添加超级源点解决。
- **踩坑教训**：负环的判断是难点，需要仔细处理入队次数。
- **顿悟感想**：差分约束的本质是最短路问题，通过数形结合可以更好地理解其原理。

---
处理用时：41.42秒
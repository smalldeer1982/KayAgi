# 题目信息

# 无聊的数列

## 题目背景

无聊的 YYB 总喜欢搞出一些正常人无法搞出的东西。有一天，无聊的 YYB 想出了一道无聊的题：无聊的数列。。。

## 题目描述

维护一个数列 $a_i$，支持两种操作：

 - `1 l r K D`：给出一个长度等于 $r-l+1$ 的等差数列，首项为 $K$，公差为 $D$，并将它对应加到 $[l,r]$ 范围中的每一个数上。即：令 $a_l=a_l+K,a_{l+1}=a_{l+1}+K+D\ldots a_r=a_r+K+(r-l) \times D$。

 - `2 p`：询问序列的第 $p$ 个数的值 $a_p$。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 数据，$0\le n,m \le 10^5,-200\le a_i,K,D\le 200, 1 \leq l \leq r \leq n, 1 \leq p \leq n$。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5
1 2 4 1 2
2 3
```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地处理区间加等差数列的操作，并支持单点查询。各题解主要采用了以下几种思路：

1. **差分+线段树**：通过差分将等差数列的区间加操作转化为几个单点修改，再用线段树维护差分数组的前缀和。这是最常见的解法，思路清晰且代码实现较为简洁。
2. **二阶差分+树状数组**：通过二阶差分将等差数列的区间加操作转化为点更新，再用树状数组维护二阶差分的前缀和。这种方法较为巧妙，但理解起来有一定难度。
3. **纯线段树**：直接在线段树上维护等差数列的首项和公差，通过标记下传实现区间修改。这种方法虽然直观，但实现复杂度较高，且容易出错。
4. **分块**：将数列分块，对散块直接修改，对整块记录等差数列的信息。这种方法实现简单，但时间复杂度较高，不适用于大规模数据。

综合来看，**差分+线段树**的解法最为简洁高效，且易于理解和实现，适合大多数情况。**二阶差分+树状数组**的解法虽然巧妙，但理解难度较大，适合对差分和树状数组有深入理解的同学。

### 所选高分题解

#### 1. **AC_Automation (5星)**
- **关键亮点**：使用差分+线段树的思路，代码简洁且高效，处理了边界条件（如越界问题），并提供了详细的解释。
- **个人心得**：作者提到在调试过程中发现了边界问题，并进行了修正，强调了边界处理的重要性。
- **核心代码**：
  ```cpp
  void add(int root,int l,int r,int ql,int qr,ll x){
      if(ql<=l&&qr>=r){a[root].tag+=x;a[root].sum+=(r-l+1)*x;return;}
      int mid=(l+r)>>1;
      pd(root,l,r);
      if(ql<=mid)add(ls(root),l,mid,ql,qr,x);
      if(qr>mid) add(rs(root),mid+1,r,ql,qr,x);
      up(root);
  }
  ```
  **实现思想**：通过线段树维护差分数组，区间加等差数列转化为三个单点修改。

#### 2. **ll_dio (4星)**
- **关键亮点**：使用二阶差分+树状数组的解法，思路巧妙，代码简洁，且无需处理边界条件。
- **核心代码**：
  ```cpp
  void add(ll x,ll delta){
      ll id=x;
      while(x<=n){
          bit1[x]+=delta;
          bit2[x]+=delta*id;
          x+=LSB(x);
      }
  }
  ```
  **实现思想**：通过树状数组维护二阶差分的前缀和，等差数列的区间加操作转化为四个点更新。

#### 3. **Alloverzyt (4星)**
- **关键亮点**：纯线段树的解法，直接维护等差数列的首项和公差，思路直观，但实现复杂度较高。
- **核心代码**：
  ```cpp
  void update(int rt,int cl,int cr,int k,int d){
      int l=tr[rt].l,r=tr[rt].r;
      if(cl<=l&&r<=cr){
          tr[rt].op=1;
          tr[rt].k+=k+(l-cl)*d;
          tr[rt].d+=d;
          return ;
      }
      pushdown(rt);
      int mid=(l+r)>>1;
      if(cl<=mid) update(ls,cl,cr,k,d);
      if(cr>mid) update(rs,cl,cr,k,d);
  }
  ```
  **实现思想**：直接在线段树上维护等差数列的首项和公差，通过标记下传实现区间修改。

### 最优关键思路或技巧

1. **差分+线段树**：将等差数列的区间加操作转化为差分数组的单点修改，再用线段树维护差分数组的前缀和。这种方法简洁高效，适合大多数场景。
2. **二阶差分+树状数组**：通过二阶差分将等差数列的区间加操作转化为点更新，再用树状数组维护二阶差分的前缀和。这种方法虽然巧妙，但理解难度较大。

### 可拓展之处

- **类似题目**：处理区间加等差数列的问题可以推广到其他区间修改问题，如区间加等比数列、区间加多项式等。
- **数据结构**：差分和树状数组的结合可以用于解决其他区间修改和单点查询的问题，如区间加常数、区间乘常数等。

### 推荐题目

1. **P3372 【模板】线段树 1**：区间加常数，单点查询。
2. **P3368 【模板】树状数组 1**：单点修改，区间查询。
3. **P3373 【模板】线段树 2**：区间加和区间乘，单点查询。

### 个人心得总结

- **边界处理**：在处理区间操作时，边界条件（如越界问题）需要特别注意，否则容易导致错误。
- **数据结构选择**：根据问题的特点选择合适的数据结构（如线段树、树状数组）可以大大简化问题的解决过程。

---
处理用时：35.16秒
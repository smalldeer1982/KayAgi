# 题目信息

# 小 K 的农场

## 题目描述

小 K 在 MC 里面建立很多很多的农场，总共 $n$ 个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共 $m$ 个），以下列三种形式描述：  
- 农场 $a$ 比农场 $b$ 至少多种植了 $c$ 个单位的作物；
- 农场 $a$ 比农场 $b$ 至多多种植了 $c$ 个单位的作物；
- 农场 $a$ 与农场 $b$ 种植的作物数一样多。  

但是，由于小 K 的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。  


## 说明/提示

对于 $100\%$ 的数据，保证 $1 \le n,m,a,b,c \le 5 \times 10^3$。

## 样例 #1

### 输入

```
3 3
3 1 2
1 1 3 1
2 2 3 2
```

### 输出

```
Yes
```

# AI分析结果

### 综合分析与结论

本题的核心是**差分约束系统**，通过将题目中的不等式转化为图的最短路问题，利用SPFA算法判断是否存在负环来确定是否有解。所有题解都采用了这一思路，但在实现细节、代码风格和优化程度上有所不同。大部分题解都使用了SPFA算法，并通过超级源点来保证图的连通性。部分题解在代码可读性和优化上有一定优势。

### 所选高星题解

#### 1. 作者：SDqwq (赞：68)
- **星级**: 5星
- **关键亮点**: 
  - 详细解释了差分约束的转化过程，逻辑清晰。
  - 代码结构简洁，使用了链式前向星建图，优化了内存使用。
  - 通过超级源点保证图的连通性，并详细说明了负环的判断方法。
- **个人心得**: 
  - 作者提到“为了避免图不连通的情况，我们需要一个超级源点”，强调了图连通性的重要性。

**核心代码**:
```cpp
bool spfa (int x) {
    dis[x] = 0;
    q.push(x);
    vis[x] = true;
    num[x]++;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = elast[u]; i != 0; i = e[i].next)
            if (dis[e[i].to] > dis[u] + e[i].len) {
                dis[e[i].to] = dis[u] + e[i].len;
                if (!vis[e[i].to]) {
                    q.push(e[i].to);
                    vis[e[i].to] = true;
                    num[e[i].to]++;
                    if (num[e[i].to] == n + 1)
                        return false;
                }
            }
    }
    return true;
}
```
**核心思想**: 通过SPFA算法判断是否存在负环，使用`num`数组记录每个点的入队次数，若某个点的入队次数超过`n+1`，则说明存在负环。

#### 2. 作者：傅天宇 (赞：31)
- **星级**: 4星
- **关键亮点**: 
  - 代码结构清晰，使用了链式前向星建图。
  - 详细说明了差分约束的转化过程，逻辑清晰。
  - 通过超级源点保证图的连通性，并详细说明了负环的判断方法。
- **个人心得**: 
  - 作者提到“SF 在讨论里说卡 DFS-DPFA，反正我用差分约束水，嘿嘿嘿”，强调了差分约束的实用性。

**核心代码**:
```cpp
bool SPFA(int s) {
    memset(dis, 0x3f, sizeof dis);
    vis[s] = 1;
    dis[s] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        vis[u] = 0;
        for (int i = fir[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (dis[v] > dis[u] + e[i].val) {
                dis[v] = dis[u] + e[i].val;
                cnt[v]++;
                if (cnt[v] == n) return 0;
                if (vis[v] == 0) {
                    vis[v] = 1;
                    q.push(v);
                }
            }
        }
    }
    return 1;
}
```
**核心思想**: 通过SPFA算法判断是否存在负环，使用`cnt`数组记录每个点的入队次数，若某个点的入队次数超过`n`，则说明存在负环。

#### 3. 作者：grass8cow (赞：9)
- **星级**: 4星
- **关键亮点**: 
  - 代码简洁，使用了`vector`建图，代码可读性较高。
  - 详细说明了差分约束的转化过程，逻辑清晰。
  - 通过超级源点保证图的连通性，并详细说明了负环的判断方法。
- **个人心得**: 
  - 作者提到“我发现自己以前做这题，是把上述边都反着建，跑最长路判正环的……太奇怪了”，强调了差分约束的灵活性。

**核心代码**:
```cpp
bool spfa(int u) {
    vi[u] = 1;
    for (int i = 0; i < g[u].size(); i++) {
        int v = g[u][i].v, w = g[u][i].w;
        if (di[v] > di[u] + w) {
            di[v] = di[u] + w;
            if (vi[v]) return 0;
            if (!spfa(v)) return 0;
        }
    }
    vi[u] = 0;
    return 1;
}
```
**核心思想**: 通过递归实现SPFA算法，判断是否存在负环，使用`vi`数组记录每个点的访问状态。

### 最优关键思路与技巧

1. **差分约束转化**: 将题目中的不等式转化为图的最短路问题，通过SPFA算法判断是否存在负环。
2. **超级源点**: 通过引入超级源点保证图的连通性，避免图不连通导致算法失效。
3. **负环判断**: 使用数组记录每个点的入队次数，若某个点的入队次数超过`n+1`，则说明存在负环。

### 拓展思路与类似题目

1. **类似题目**:
   - [P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)
   - [P1260 【模板】差分约束系统](https://www.luogu.com.cn/problem/P1260)
   - [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)

2. **拓展思路**:
   - 差分约束系统不仅适用于不等式约束，还可以用于解决其他类型的约束问题，如区间约束、路径约束等。
   - 在实际应用中，差分约束系统可以用于解决资源分配、任务调度等问题。

### 推荐题目

1. [P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)
2. [P1260 【模板】差分约束系统](https://www.luogu.com.cn/problem/P1260)
3. [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)

---
处理用时：42.62秒
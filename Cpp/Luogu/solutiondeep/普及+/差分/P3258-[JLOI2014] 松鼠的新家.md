# 题目信息

# [JLOI2014] 松鼠的新家

## 题目描述

松鼠的新家是一棵树，前几天刚刚装修了新家，新家有$n$ 个房间，并且有 $n-1$ 根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的。天哪，他居然真的住在“树”上。

松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去 $a_1$，再去 $a_2$，……，最后到 $a_n$，去参观新家。可是这样会导致重复走很多房间，懒惰的维尼不停地推辞。可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃。

维尼是个馋家伙，立马就答应了。现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。

因为松鼠参观指南上的最后一个房间 $a_n$ 是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。

## 说明/提示

对于全部的数据，$2 \le n \le 3 \times 10^5$，$1 \le a_i \le n$。

## 样例 #1

### 输入

```
5
1 4 5 3 2
1 2
2 4
2 3
4 5```

### 输出

```
1
2
1
2
1```

# AI分析结果

### 综合分析与结论

本题的核心问题是在树上进行路径修改，要求对每条路径上的节点进行加1操作，最后输出每个节点的权值。主要的解决思路包括**树上差分**和**树链剖分**，其中树上差分因其时间复杂度较低（O(n log n)）且代码简洁，成为大多数题解的首选。树链剖分虽然也能解决问题，但代码复杂度较高，且在实际应用中可能因常数较大而表现不佳。

#### 最优关键思路与技巧：
1. **树上差分**：通过差分数组来记录路径上的修改，最后通过DFS或拓扑序计算每个节点的最终值。这种方法避免了直接对路径上的每个节点进行修改，大大减少了时间复杂度。
2. **LCA（最近公共祖先）**：在树上差分中，LCA用于确定路径的公共部分，确保差分操作的正确性。
3. **优化细节**：如避免重复计算、处理路径的起点和终点等细节，确保最终结果的正确性。

#### 推荐题目：
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.org/problem/P3379) - 练习LCA的基本应用。
2. [P3128 [USACO15DEC]最大流Max Flow](https://www.luogu.org/problem/P3128) - 类似树上差分的应用。
3. [P2680 运输计划](https://www.luogu.org/problem/P2680) - 更复杂的树上路径修改问题。

### 所选高分题解

#### 1. **题解作者：dzz1537568241 (赞：382)**
- **星级**：★★★★★
- **关键亮点**：详细解释了树上差分的原理，并结合LCA进行了具体实现。代码清晰，注释详细，适合初学者理解。
- **个人心得**：作者强调了差分的“相对改变”思想，并通过图示帮助理解，非常适合初学者。

```cpp
void dfs(int u, int fa) {
    for (int i = head[u]; i; i = edge[i].next) {
        int v = edge[i].v;
        if (v == fa) continue;
        dfs(v, u);
        num[u] += num[v];
    }
}
```
- **核心思想**：通过DFS计算每个节点的最终值，利用差分数组进行路径修改。

#### 2. **题解作者：asuldb (赞：63)**
- **星级**：★★★★☆
- **关键亮点**：代码简洁，直接应用树上差分和LCA，适合有一定基础的读者。
- **个人心得**：作者提到“第一次A掉紫题就来写题解”，代码实现较为直接，适合快速理解。

```cpp
void dfs(int r) {
    for (int i = head[r]; i != -1; i = edge[i].nxt) {
        int xx = edge[i].v;
        if (deep[xx] == 0) {
            deep[xx] = deep[r] + 1;
            f[xx][0] = r;
            dfs(xx);
        }
    }
}
```
- **核心思想**：通过DFS预处理LCA，然后进行差分操作。

#### 3. **题解作者：hyfhaha (赞：35)**
- **星级**：★★★★☆
- **关键亮点**：使用树链剖分和线段树解决问题，适合对树链剖分感兴趣的读者。
- **个人心得**：作者提到“树剖调了2天，一直90分”，最终通过调整数据范围AC，强调了调试的重要性。

```cpp
void updatelong(int x, int y, int z) {
    while (top[x] != top[y]) {
        if (dep[top[x]] <= dep[top[y]]) {
            update(1, 1, n, id[top[y]], id[y], z);
            y = fa[top[y]];
        } else {
            update(1, 1, n, id[top[x]], id[x], z);
            x = fa[top[x]];
        }
    }
    if (dep[x] > dep[y]) swap(x, y);
    update(1, 1, n, id[x], id[y], z);
}
```
- **核心思想**：通过树链剖分和线段树进行路径修改，最后查询每个节点的值。

### 通用建议与扩展思路

如果所有题解均未达到4星，建议读者：
1. **掌握树上差分**：理解其原理，熟练应用LCA进行路径修改。
2. **优化代码细节**：如避免重复计算、处理路径的起点和终点等。
3. **拓展练习**：通过推荐题目进一步巩固树上路径修改的相关知识。

---
处理用时：44.64秒
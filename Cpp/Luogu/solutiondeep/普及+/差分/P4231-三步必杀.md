# 题目信息

# 三步必杀

## 题目背景

### （三）旧都

离开狭窄的洞穴，眼前豁然开朗。

天空飘着不寻常的雪花。

一反之前的幽闭，现在面对的，是繁华的街市，可以听见酒碗碰撞的声音。

这是由被人们厌恶的鬼族和其他妖怪们组成的小社会，一片其乐融融的景象。

诶，不远处突然出现了一些密密麻麻的小点，好像大颗粒扬尘一样。

离得近了点，终于看清楚了。

长着角的鬼们聚在一起，围观着另一只鬼的表演。

那”扬尘”，其实都是弹幕。

勇仪的招数之一，三步之内，所到之处弹幕云集，几乎没有生存可能。

为了强化这一技能，勇仪将对着一排柱子进行攻击。

旧地狱的柱子虽然无比坚固，但保险起见还是先要了解一下这样一套攻击对柱子有多少损伤，顺带也能检验练习的效果。

勇仪决定和其它鬼们商量商量...

“我知道妖怪之山的河童一族有一种叫做计算机的神奇道具，说不定可以借来用用”，萃香说道。

于是旧地狱的鬼族就决定请河城荷取来帮忙了。

“要记录【所有柱子的损伤程度】吗”，荷取问道。

经过进一步的询问，荷取发现他们仅仅需要【所有攻击都完成后】柱子的损伤程度。

任务了解地差不多了，荷取将其中的重要部分提取了出来，记录在了她的工作笔记本上：

(记录的内容见题目描述)

那么实验就这样开始了。

在惊天动地的碰撞声中，勇仪每完成一轮攻击，荷取都忠实地记录下对每根柱子产生的伤害。而此时勇仪就在旁边等待着记录完成，然后再进行下一轮的攻击。

地面上，天色渐晚。

“不想在这里留到深夜啊，不然就回不了家了”，荷取这样想着，手中依然在重复地向计算机中输入新产生的信息。

“真的必须一次一次地记录下每轮攻击对每个柱子产生的伤害吗？有没有更高效的方法？”这一念头在荷取的心中闪过...

（后续剧情在题解中，接下来请看T3）


## 题目描述

### 问题摘要：

$N$个柱子排成一排，一开始每个柱子损伤度为0。

接下来勇仪会进行$M$次攻击，每次攻击可以用4个参数$l$,$r$,$s$,$e$来描述：

表示这次攻击作用范围为第$l$个到第$r$个之间所有的柱子(包含$l$,$r$)，对第一个柱子的伤害为$s$，对最后一个柱子的伤害为$e$。

攻击产生的伤害值是一个等差数列。若$l=1$,$r=5$,$s=2$,$e=10$，则对第1~5个柱子分别产生2,4,6,8,10的伤害。

鬼族们需要的是所有攻击完成之后每个柱子的损伤度。

## 说明/提示

### 样例解释：

样例1：

第一次攻击产生的伤害:2 4 6 8 10

第二次攻击产生的伤害:0 1 1 1 0

所有攻击结束后每个柱子的损伤程度:2 5 7 9 10。

输出异或和与最大值，就是3 10。

样例2：

没有打到第六根柱子，答案不变

### 数据范围：

本题满分为100分，下面是4个子任务。(x/y)表示(得分/测试点数量)

妖精级(18/3):$1\leqslant n$,$m\leqslant1000$。这种工作即使像妖精一样玩玩闹闹也能完成吧？

河童级(10/1):$s=e$,这可以代替我工作吗？

天狗级(20/4):$1\leqslant n\leqslant10^5$,$1\leqslant m\leqslant10^5$。小打小闹不再可行了呢。

鬼神级(52/2):没有特殊限制。要真正开始思考了。

以上四部分数据不相交。

对于全部的数据:$1\leqslant n\leqslant10^7$,$1\leqslant m\leqslant3\times 10^5$，$1\leqslant l<r\leqslant n$.

所有输入输出数据以及柱子受损伤程度始终在$[0,9\times 10^{18}]$范围内。

### 提示：

由于种种原因，时间限制可能会比较紧，C++选手请不要使用cin读入数据。


by orangebird

## 样例 #1

### 输入

```
5 2
1 5 2 10
2 4 1 1
```

### 输出

```
3 10```

## 样例 #2

### 输入

```
6 2
1 5 2 10
2 4 1 1```

### 输出

```
3 10```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效处理区间加等差数列的操作，并最终查询每个点的值。大多数题解都采用了差分的思想，尤其是二阶差分，来将区间加等差数列的操作转化为对差分数组的单点修改，从而将时间复杂度从O(mn)优化到O(n+m)。这种思路不仅简洁高效，而且避免了使用复杂的数据结构（如线段树、树状数组），适合处理大规模数据。

### 最优关键思路与技巧

1. **二阶差分**：通过两次差分，将区间加等差数列的操作转化为对差分数组的单点修改，最终通过两次前缀和还原原数组。这种方法的时间复杂度为O(n+m)，非常高效。
2. **避免复杂数据结构**：由于数据范围较大（n≤1e7，m≤3e5），使用线段树或树状数组会导致时间或空间复杂度过高，而差分方法则能很好地解决这一问题。
3. **等差数列的处理**：通过计算等差数列的公差，将等差数列的增量转化为差分数组的修改，简化了问题的复杂度。

### 推荐题解

#### 1. 作者：orangebird (5星)
- **关键亮点**：详细解释了二阶差分的思路，并通过示例清晰地展示了如何将区间加等差数列的操作转化为对差分数组的单点修改。代码简洁且高效，适合大规模数据处理。
- **个人心得**：作者通过剧情引入问题，增加了趣味性，同时通过逐步推导，帮助读者理解二阶差分的原理。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = int64_t;
const int N = 1e7 + 5;
int n, m;
ll c[N];
int main() {
    scanf("%d%d", &n, &m);
    ll a = 0, b = 0, s, t, d, Max = 0, Xor = 0;
    for (int L, R; m--;) {
        scanf("%d%d%lld%lld", &L, &R, &s, &t);
        d = (t - s) / (R - L);
        c[L] += s, c[L + 1] += d - s;
        c[R + 1] -= d + t, c[R + 2] += t;
    }
    for (int i = 1; i <= n; ++i)
        Max = max(Max, a += (b += c[i])), Xor ^= a;
    printf("%lld %lld", Xor, Max);
    return 0;
}
```

#### 2. 作者：Kelin (5星)
- **关键亮点**：通过数学推导，详细解释了二阶差分的原理，并给出了清晰的代码实现。代码结构清晰，易于理解。
- **个人心得**：作者通过数学公式推导，帮助读者深入理解差分数组的变化过程，适合有一定数学基础的读者。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = int64_t;
const int N = 1e7 + 5;
int n, m;
ll c[N];
int main() {
    scanf("%d%d", &n, &m);
    ll a = 0, b = 0, s, t, d, Max = 0, Xor = 0;
    for (int L, R; m--;) {
        scanf("%d%d%lld%lld", &L, &R, &s, &t);
        d = (t - s) / (R - L);
        c[L] += s, c[L + 1] += d - s;
        c[R + 1] -= d + t, c[R + 2] += t;
    }
    for (int i = 1; i <= n; ++i)
        Max = max(Max, a += (b += c[i])), Xor ^= a;
    printf("%lld %lld", Xor, Max);
    return 0;
}
```

#### 3. 作者：Kirisame_Marisa_ (4星)
- **关键亮点**：通过示例详细解释了二阶差分的应用，并给出了清晰的代码实现。代码简洁且高效，适合大规模数据处理。
- **个人心得**：作者通过示例逐步推导，帮助读者理解二阶差分的原理，适合初学者。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline long long fi()
{
    register long long x=0;register char ch;
    while(!isdigit(ch=getchar()));x=ch-48;
    while(isdigit(ch=getchar()))x=x*10+ch-48;
    return x;
}
long long n,m,l,r,s,e,d;
long long b[10000005];
int main()
{
    n=fi();m=fi();
    while(m--)
    {
        l=fi();r=fi();s=fi();e=fi();
        d=(e-s)/(r-l);
        b[l]+=s;
        b[l+1]+=(d-s);
        b[r+1]+=(-e-d);
        b[r+2]+=e;
    }
    register long long ans1=0,ans2=0,tmp=0;
    for(register int i=1;i<=n;++i)b[i]+=b[i-1];
    for(register int i=1;i<=n;++i)
    {
        tmp+=b[i];
        ans1^=tmp;
        ans2=max(ans2,tmp);
    }
    cout<<ans1<<" "<<ans2;
    return 0;
}
```

### 可拓展之处

1. **类似问题**：区间加等比数列、区间加多项式等，可以通过类似差分的思想进行处理。
2. **数据结构优化**：对于需要频繁查询的问题，可以考虑使用线段树或树状数组来优化查询操作。

### 推荐题目

1. **P3368 【模板】树状数组 2**：区间修改，单点查询，适合练习差分思想。
2. **P1438 无聊的数列**：区间加等差数列，单点查询，与本题类似。
3. **P3372 【模板】线段树 1**：区间修改，区间查询，适合练习线段树的应用。

---
处理用时：42.47秒
# 题目信息

# 【模板】差分约束

## 题目描述

给出一组包含 $m$ 个不等式，有 $n$ 个未知数的形如：

$$ \begin{cases} x_{c_1}-x_{c'_1}\leq y_1 \\x_{c_2}-x_{c'_2} \leq y_2 \\ \cdots\\ x_{c_m} - x_{c'_m}\leq y_m\end{cases}$$

的不等式组，求任意一组满足这个不等式组的解。

## 说明/提示

**样例解释**

$\begin{cases}x_1-x_2\leq 3 \\ x_2 - x_3 \leq -2 \\ x_1 - x_3 \leq 1 \end{cases}$

一种可行的方法是 $x_1 = 5, x_2 = 3, x_3 = 5$。

$\begin{cases}5-3  = 2\leq 3 \\ 3 - 5 = -2 \leq -2 \\ 5 - 5  = 0\leq 1 \end{cases}$

**数据范围**

对于 $100\%$ 的数据，$1\leq n,m \leq 5\times 10^3$，$-10^4\leq y\leq 10^4$，$1\leq c,c'\leq n$，$c \neq c'$。

**评分策略**

你的答案符合该不等式组即可得分，请确保你的答案中的数据在 `int` 范围内。

如果并没有答案，而你的程序给出了答案，SPJ 会给出 `There is no answer, but you gave it`，结果为 WA；    
如果并没有答案，而你的程序输出了 `NO`，SPJ 会给出 `No answer`，结果为 AC；       
如果存在答案，而你的答案错误，SPJ 会给出 `Wrong answer`，结果为 WA；    
如果存在答案，且你的答案正确，SPJ 会给出 `The answer is correct`，结果为 AC。

## 样例 #1

### 输入

```
3 3
1 2 3
2 3 -2
1 3 1```

### 输出

```
5 3 5```

# AI分析结果

### 综合分析与结论

差分约束问题通常通过将不等式转化为图论中的最短路或最长路问题来解决。核心思想是将不等式 \(x_i - x_j \leq y\) 转化为图中的边 \(j \rightarrow i\)，边权为 \(y\)，然后通过 SPFA 或 Bellman-Ford 算法求解最短路或最长路。若图中存在负环（最短路）或正环（最长路），则说明无解。

题解中，大多数作者都采用了 SPFA 算法，部分作者还提供了 Bellman-Ford 的实现。整体来看，题解的质量较高，思路清晰，代码实现也较为规范。以下是几条较为优秀的题解。

### 精选题解

#### 1. **作者：Stephen_Curry (赞：679)**  
**星级：★★★★★**  
**关键亮点：**  
- 详细解释了差分约束系统的转化过程，包括最短路和最长路的两种解法。
- 提供了 SPFA 和 Bellman-Ford 两种算法的实现，并对比了它们的优缺点。
- 代码结构清晰，注释详细，适合初学者理解。

**核心代码：**
```cpp
bool spfa(int u) {
    memset(vis, false, sizeof(vis));
    vis[u] = true;
    memset(dis, -1, sizeof(dis));  // 最长路初始化
    dis[u] = 0;
    memset(in, 0, sizeof in);
    in[u] = 1;
    queue<int> q;
    q.push(u);
    while (!q.empty()) {
        u = q.front();
        q.pop();
        vis[u] = false;
        for (int j = head[u]; ~j; j = e[j].fail) {
            int v = e[j].v;
            int w = e[j].w;
            if (dis[v] < dis[u] + w) { // 最长路更新
                dis[v] = dis[u] + w;
                if (!vis[v]) {
                    q.push(v);
                    vis[v] = true;
                    ++in[v];
                    if (in[v] > n + 1) return true; // 判断正环
                }
            }
        }
    }
    return false;
}
```
**个人心得：**  
作者提到 SPFA 虽然代码较长，但速度较快，而 Bellman-Ford 代码简洁但较慢。建议根据题目需求选择合适的算法。

---

#### 2. **作者：StudyingFather (赞：164)**  
**星级：★★★★☆**  
**关键亮点：**  
- 简洁明了地解释了差分约束的转化过程，重点强调了负环的判断。
- 提供了 SPFA 的实现，并详细说明了如何通过入队次数判断负环。

**核心代码：**
```cpp
bool spfa(int s) {
    queue<int> q;
    memset(dis, 63, sizeof(dis));
    dis[s] = 0, vis[s] = 1;
    q.push(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (dis[v] > dis[u] + e[i].w) {
                dis[v] = dis[u] + e[i].w;
                if (!vis[v]) {
                    vis[v] = 1, tot[v]++;
                    if (tot[v] == n + 1) return false; // 判断负环
                    q.push(v);
                }
            }
        }
    }
    return true;
}
```
**个人心得：**  
作者提到 SPFA 的码量较长，但最坏情况下与 Bellman-Ford 相同，建议慎用。

---

#### 3. **作者：wsyhb (赞：94)**  
**星级：★★★★☆**  
**关键亮点：**  
- 详细解释了差分约束的转化过程，并提供了 SPFA 和 Bellman-Ford 的实现。
- 强调了图不连通时的处理方法，提供了两种解决方案。

**核心代码：**
```cpp
bool spfa(int s) {
    for (int i = 1; i <= n; i++) dis[i] = 1e9;
    dis[s] = 0;
    for (int i = 1; i <= n; i++) q.push(i), inq[i] = 1, cnt[i]++;
    while (!q.empty()) {
        int x = q.front(); q.pop(); inq[x] = 0;
        for (int i = Last[x]; i; i = Next[i]) {
            int y = End[i];
            if (dis[y] > dis[x] + Len[i]) {
                dis[y] = dis[x] + Len[i];
                if (!inq[y]) {
                    q.push(y); inq[y] = 1; cnt[y]++;
                    if (cnt[y] > n + 1) return false; // 判断负环
                }
            }
        }
    }
    return true;
}
```
**个人心得：**  
作者提到图不连通时，可以通过将所有点入队或添加虚拟源点来解决。

---

### 最优关键思路与技巧

1. **差分约束转化为图论问题：** 将不等式 \(x_i - x_j \leq y\) 转化为图中的边 \(j \rightarrow i\)，边权为 \(y\)，然后通过最短路或最长路求解。
2. **负环判断：** 使用 SPFA 时，通过记录每个点的入队次数来判断负环。若某个点入队次数超过 \(n\)，则存在负环。
3. **虚拟源点：** 为了解决图不连通的问题，可以添加一个虚拟源点，向所有点连一条权值为 0 的边。

### 拓展思路

1. **乘积最短路：** 当不等式中的系数不为 1 时，可以使用乘积最短路的方法，通过取对数将乘法转化为加法。
2. **多源最短路：** 在某些问题中，可能需要从多个起点出发求解最短路，可以考虑使用 Floyd 算法。

### 推荐题目

1. [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)
2. [P2294 [HNOI2005]狡猾的商人](https://www.luogu.com.cn/problem/P2294)
3. [P3275 [SCOI2011]糖果](https://www.luogu.com.cn/problem/P3275)

---
处理用时：43.59秒
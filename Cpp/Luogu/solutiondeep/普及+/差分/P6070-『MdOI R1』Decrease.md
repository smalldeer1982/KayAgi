# 题目信息

# 『MdOI R1』Decrease

## 题目描述

给定一个 $n \times n$ 的矩阵，你可以进行若干次操作。

每次操作，你可以将一个 $k \times k$ 的 **连续** 子矩阵里的所有数全都加上 $1$ 或者全都减去 $1$。

初始时，矩阵中有 $m$ 个位置上的数不为 $0$，其它位置上的数均为 $0$。

请你求出至少需要多少次操作，可以将矩形中所有数都变为 $0$。

## 说明/提示

【样例 1 解释】:  

给出的矩阵为：  

```plain
1 1 1 0
1 3 3 2
1 3 3 2
0 2 2 2
```

具体步骤：  

先将以第一行第一列为左上角的连续子矩阵执行 **减 1 操作** 一次；

再将以第二行第二列为左上角的连续子矩阵执行 **减 1 操作** 两次。

总共三次。

```plain
1 1 1 0  0 0 0 0  0 0 0 0  0 0 0 0
1 3 3 2  0 2 2 2  0 1 1 1  0 0 0 0
1 3 3 2  0 2 2 2  0 1 1 1  0 0 0 0
0 2 2 2  0 2 2 2  0 1 1 1  0 0 0 0
```

【样例 2 解释】：  

给出的矩阵为：  

```plain
1 0 0
0 0 0
0 0 0
```

只通过 $2\times 2$ 的连续子矩阵操作不可能使得所有格子上的数都变为 $0$。

【数据范围】   

**本题采用捆绑测试。**

| 子任务编号 |    $n\leq$     | $k\leq$ | 分值 |
| :--------: | :------------: | :-----: | :--: |
|     1      |     $10^3$     |   $1$   |  11  |
|     2      |      $20$      |  $20$   |  14  |
|     3      |     $100$      |  $100$  |  17  |
|     4      |     $10^3$     | $10^3$  |  34  |
|     5      | $5\times 10^3$ | $10^3$  |  24  |

对于所有数据，$1\leq n\leq 5\times 10^3$，$1\leq m\leq \min(n^2,5\times 10^5)$，$1\leq k\leq \min(n,10^3)$，$1\leq x,y\leq n$，每对 $(x,y)$ 至多出现一次，$1 \le |z| \leq 10^9$。

数据保证如果有解，答案不超过 $2^{63}-1$。

---

【提示】

本题读入量较大，建议使用较快的读入方式。  

## 样例 #1

### 输入

```
4 14 3
1 1 1
1 2 1
1 3 1
2 1 1
2 2 3
2 3 3
2 4 2
3 1 1
3 2 3
3 3 3
3 4 2
4 2 2
4 3 2
4 4 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3 1 2
1 1 1
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
4 5 1
1 1 5
2 2 -3
2 3 -4
3 3 1
4 4 2
```

### 输出

```
15
```

# AI分析结果

### 综合分析与结论

本题的核心是通过对矩阵进行差分操作，将矩阵中的所有元素变为0。题解中普遍采用了二维差分的思路，通过优化暴力解法，将时间复杂度从O(n^2k^2)降低到O(n^2)。以下是各题解的要点总结：

1. **二维差分**：大多数题解都采用了二维差分的思想，通过差分数组来优化矩阵的修改操作，避免了对每个子矩阵的逐个修改。
2. **暴力优化**：部分题解通过暴力枚举左上角，并结合差分优化，逐步将矩阵中的元素变为0。
3. **边界处理**：多个题解提到了边界处理的问题，特别是当子矩阵超出矩阵范围时，直接输出-1。
4. **绝对值处理**：由于差分操作可能导致负数，题解中普遍采用了绝对值来统计操作次数。

### 所选高星题解

#### 1. 作者：George1123 (5星)
**关键亮点**：
- 详细解释了二维差分的应用，并通过代码展示了如何通过差分数组优化矩阵修改操作。
- 提供了暴力解法的代码，并逐步优化为差分解法，思路清晰。
- 代码可读性强，注释详细。

**个人心得**：
- 作者提到比赛时先写了暴力解法，虽然只得了42分，但通过思考优化为差分解法，最终成功AC。这种从暴力到优化的思路值得学习。

**核心代码**：
```cpp
for(int i=1;i<=n-k+1;i++)
    for(int j=1,num=0;j<=n-k+1;j++){
        num=cf[i][j];
        if(num!=0){
            ans+=abs(num);
            for(int t=i;t<=i+k-1;t++)
                cf[t][j]-=num,cf[t][j+k]+=num;
        }
    }
```

#### 2. 作者：Hexarhy (4星)
**关键亮点**：
- 通过二维差分的递推公式，详细解释了如何通过差分数组进行矩阵修改。
- 提供了清晰的图示，帮助理解二维差分的操作。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i=1;i<=n-k+1;i++)
    for(int j=1;j<=n-k+1;j++){
        ans+=abs(d[i][j]);
        d[i+k][j]+=d[i][j];
        d[i][j+k]+=d[i][j];
        d[i+k][j+k]-=d[i][j];
        d[i][j]=0;
    }
```

#### 3. 作者：BaCO3 (4星)
**关键亮点**：
- 详细解释了二维前缀和与差分的关系，并通过差分数组优化矩阵修改操作。
- 提供了清晰的差分公式，帮助理解如何通过差分数组进行矩阵修改。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=n;j++){
        cf[i][j]+=cf[i-1][j]+cf[i][j-1]-cf[i-1][j-1];
        a[i][j]+=cf[i][j];
        if(a[i][j]!=0){
            if(i+k>n+1||j+k>n+1){
                printf("-1");
                return 0;
            }
            cf[i][j]-=a[i][j];
            cf[i+k][j]+=a[i][j];
            cf[i][j+k]+=a[i][j];
            cf[i+k][j+k]-=a[i][j];
            ans+=abs(a[i][j]);
        }
    }
}
```

### 最优关键思路与技巧

1. **二维差分**：通过差分数组优化矩阵修改操作，避免逐个修改子矩阵，时间复杂度从O(n^2k^2)降低到O(n^2)。
2. **边界处理**：当子矩阵超出矩阵范围时，直接输出-1，避免无效操作。
3. **绝对值处理**：由于差分操作可能导致负数，采用绝对值来统计操作次数。

### 可拓展之处

- **类似题目**：可以拓展到更高维度的差分问题，如三维差分等。
- **其他优化**：可以考虑使用线段树等数据结构来进一步优化矩阵修改操作。

### 推荐题目

1. **P3397 地毯**：二维差分的基础题目，适合练习二维差分的应用。
2. **P2280 [HNOI2003]激光炸弹**：二维前缀和与差分的结合应用。
3. **P4514 上帝造题的七分钟**：二维树状数组的应用，进一步拓展差分思想。

### 个人心得总结

- **从暴力到优化**：很多题解都提到了先写暴力解法，再逐步优化为差分解法，这种思路值得学习。
- **调试与顿悟**：部分作者提到在调试过程中发现差分的妙用，最终成功AC，这种调试经验对解决类似问题有很大帮助。

---
处理用时：35.97秒
# 题目信息

# [省选联考 2020 B 卷] 幸运数字

## 题目描述

为庆祝疫情防治取得重大进展，某商场举行酬宾活动，给顾客一些优惠额度，规则如下：

1. 每位顾客可以任意选择一个整数作为自己的幸运数字。
2. 每位顾客的初始优惠额度为 $0$ 元。
3. 商场有 $n$ 个奖励条件，对应不同的奖励额度 $w_i$。
4. 每位顾客需要依次比对这 $n$ 个奖励条件，如果该位顾客选择的幸运数字满足第 $i$ 个条件，那么他的优惠额度就会**异或**上这个条件所对应的奖励额度。

奖励条件共有三种，假设顾客选择的幸运数字为 $x$：

1. 区间型条件，其有两个参数 $L$ 与 $R$，满足条件为 $L \le x\le R$。保证 $L < R$。
2. 相等型条件，其有一个参数 $A$，满足条件为 $x = A$。
3. 不等型条件，其有一个参数 $B$，满足条件为 $x \neq B$。

小炎同学获知了所有奖励条件的信息，他希望知道一位顾客能够得到的最大优惠额度以及对应的幸运数字是多少，请你帮他计算。


## 说明/提示

**样例解释**

幸运数字 $-3$ 满足奖励条件 $2, 3, 4$，奖励额度为 $3\oplus 64\oplus 156 = 223$，其中 $\oplus$ 表
示异或运算。

**数据范围与约定**

$20\%$ 的数据满足：$n, |L|, |R|, |A|, |B| \le 1000$。  
$40\%$ 的数据满足：$n\le 1000$。  
$100\%$ 的数据满足：$1\le n\le 10^5, |L|, |R|, |A|, |B|\le 10^9, 1\le w_i\le 10^9$。


## 样例 #1

### 输入

```
4
1 -100 -80 37
2 -3 3
3 4 64
1 -10 1024 156```

### 输出

```
223 -3```

# AI分析结果

### 综合分析与结论

本题的核心在于处理大规模区间异或操作，并找到最大优惠额度及其对应的幸运数字。由于数据范围较大（$10^9$），直接暴力处理不可行，因此大多数题解采用了**离散化**和**差分**的技巧来优化空间和时间复杂度。部分题解还引入了**线段树**或**扫描线**等数据结构来进一步优化。

#### 关键思路与技巧：
1. **离散化**：将大范围的数值映射到较小的范围内，减少空间和时间复杂度。
2. **差分**：通过差分数组来记录区间异或操作，最后通过前缀和还原每个点的异或值。
3. **线段树**：用于高效处理区间异或操作，适合更复杂的区间查询和更新。
4. **扫描线**：通过扫描线思想处理区间操作，避免复杂的区间更新。

#### 通用建议与扩展思路：
- **离散化**是处理大范围数据的常用技巧，适用于区间查询、区间更新等问题。
- **差分**适用于区间修改、单点查询的场景，且可以扩展到多维空间。
- **线段树**和**扫描线**适合处理复杂的区间操作，尤其是需要动态维护区间信息的场景。

### 推荐题目：
1. **P3372 【模板】线段树 1**：练习线段树的基本操作。
2. **P5490 【模板】扫描线**：学习扫描线算法在矩形面积并集中的应用。
3. **P1908 逆序对**：练习离散化和树状数组的结合使用。

### 所选高星题解

#### 1. **VenusM1nT** (4星)
- **关键亮点**：使用离散化和差分，思路清晰，代码简洁。
- **个人心得**：作者提到“好久没写代码了，手有点生”，但依然能够快速实现，体现了扎实的编程基础。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++){
      if(opt[i]==1){
          cnt[l[i]]^=val[i];
          cnt[r[i]+1]^=val[i];
      }
      else if(opt[i]==2){
          cnt[l[i]]^=val[i];
          cnt[l[i]+1]^=val[i];
      }
      else if(opt[i]==3){
          cnt[1]^=val[i];
          cnt[l[i]]^=val[i];
          cnt[l[i]+1]^=val[i];
      }
  }
  ```
  **实现思想**：通过差分数组记录区间异或操作，最后通过前缀和还原每个点的异或值。

#### 2. **白木偶君** (4星)
- **关键亮点**：将三种条件转化为区间操作，使用线段树维护区间异或。
- **个人心得**：作者提到“我省选写这题的时候就是数组开小了，应该开$4n$长度的线段树”，提醒了读者注意数组大小。
- **核心代码**：
  ```cpp
  void update(int p,int l,int r,int d){
      if(l<=l(p)&&r(p)<=r){ sum(p)^=d; return; }
      if(l<=mid)update(ls,l,r,d);
      if(r>mid)update(rs,l,r,d);
  }
  ```
  **实现思想**：使用线段树维护区间异或操作，适合处理复杂的区间更新。

#### 3. **BrotherCall** (4星)
- **关键亮点**：使用扫描线思想，通过差分实现离散化，代码量小且高效。
- **个人心得**：作者提到“加点，加点，加点！然后扫描线查询”，强调了扫描线思想的核心。
- **核心代码**：
  ```cpp
  for(int i=1;i<=2*n+cnt;i++){
      start ^= G[i].sum;
      if(G[i].st == G[i+1].st)continue;
      if(start > anss) {
          anse = G[i].st;
          anss = start;
      }
  }
  ```
  **实现思想**：通过扫描线思想处理区间异或操作，避免复杂的区间更新。

### 总结
离散化和差分是解决本题的核心技巧，而线段树和扫描线则提供了更高效的实现方式。通过合理选择数据结构，可以有效优化算法的时间和空间复杂度。

---
处理用时：32.74秒
# 题目信息

# 「EZEC-4」可乐

## 题目背景

很久以前，有一个 pigstd，非常迷恋美味的可乐。为了得到美味的可乐，他几乎用尽了所有的钱，他甚至对自己的 npy 也漠不关心~~其实是因为他没有npy~~，更不爱好看戏。除非买了新可乐，才会坐上马车出门炫耀一番。每一天，每个钟头他都要喝上一瓶新可乐。

pigstd 最近又买了许多箱新可乐——当然，这些可乐只有聪明的人才能喝到。

## 题目描述

pigstd 现在有 $n$ 箱可乐，第 $i$ 箱可乐上标着一个正整数 $a_{i}$。

若 pigstd 的聪明值为一个非负整数 $x$，对于第 $i$ 箱可乐，如果 $(a_{i} \oplus x )\le k$，那么 pigstd 就能喝到这箱可乐。

现在 pigstd 告诉了你 $k$ 与序列 $a$，你可以决定 pigstd 的聪明值 $x$，使得他能喝到的可乐的箱数最大。求出这个最大值。

## 说明/提示

### 提示

**pigstd 的聪明值 $x$ 可以为 $0$。**

### 样例解释

样例 1 解释：容易构造当 $x = 0$ 时，可以喝到所有可乐。

样例 2 解释：容易构造 $x = 913$，可以喝到所有可乐。

**样例解释未必是唯一的方法。**

### 数据范围

**本题采用捆绑测试。**

- Subtask 1（29 points）：$1 \le n,k,a_{i} \le 1000$。

- Subtask 2（1 points）：$a_{i} \le k$。

- Subtask 3（70 points）：无特殊限制。

对于所有数据，保证 $1 \le n,k,a_{i} \le 10^6$。

$\oplus$ 代表异或，如果您不知道什么是异或，请单击[这里](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fr=aladdin)。

## 样例 #1

### 输入

```
3 5
2
3
4```

### 输出

```
3```

## 样例 #2

### 输入

```
4 625
879
480
671
853
```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

本题的核心在于通过位运算和差分技巧，找到使得 `(a_i ⊕ x) ≤ k` 的 `x` 值，使得 pigstd 能喝到的可乐箱数最大。题解中主要采用了以下几种思路：

1. **按位枚举与差分**：大多数题解通过从高位到低位逐位枚举 `a_i` 和 `k` 的二进制位，利用差分数组记录符合条件的 `x` 区间，最后通过前缀和统计最大值。
2. **Trie树与动态规划**：部分题解使用 Trie 树存储 `a_i` 的二进制表示，并结合动态规划或贪心策略，优化了查询和统计的过程。
3. **暴力枚举与优化**：少数题解采用暴力枚举 `x` 值，但通过 Trie 树或其他优化手段减少了时间复杂度。

整体来看，按位枚举与差分的思路最为简洁高效，且代码实现较为清晰。Trie树与动态规划的思路虽然优化了查询效率，但代码复杂度较高，适合对数据结构有深入理解的选手。

### 所选高分题解

#### 1. 作者：pigstd (赞：61)  
**星级：5星**  
**关键亮点**：  
- 通过按位枚举 `a_i` 和 `k` 的二进制位，利用差分数组记录符合条件的 `x` 区间，最后通过前缀和统计最大值。
- 代码简洁高效，思路清晰，适合初学者理解和实现。

**核心代码**：
```cpp
void f(int b) {
    memset(s1, 0, sizeof(s1));
    memset(s2, 0, sizeof(s2));
    int len1 = 0, len2 = 0, kk = k;
    while (b) s1[++len1] = b % 2, b /= 2;
    while (kk) s2[++len2] = kk % 2, kk /= 2;
    int len = max(len1, len2);
    for (int i = 1; i <= len / 2; i++)
        swap(s1[i], s1[len - i + 1]), swap(s2[i], s2[len - i + 1]);
    int sum = 0;
    for (int i = 1; i <= len; i++)
        if (s2[i] == 0)
            sum = sum * 2 + s1[i];
        else {
            int k1 = (sum * 2 + s1[i]) * 1 << (len - i), k2 = (sum * 2 + 1 + s1[i]) * 1 << (len - i);
            c[k1]++, c[k2]--;
            sum = sum * 2 + (s1[i] ^ 1);
        }
    c[sum]++, c[sum + 1]--;
}
```
**实现思想**：通过逐位枚举 `a_i` 和 `k` 的二进制位，利用差分数组记录符合条件的 `x` 区间，最后通过前缀和统计最大值。

#### 2. 作者：pocafup (赞：31)  
**星级：4星**  
**关键亮点**：  
- 从高位到低位逐位枚举 `a_i` 和 `k` 的二进制位，利用差分数组记录符合条件的 `x` 区间。
- 代码实现较为简洁，思路清晰，适合初学者理解和实现。

**核心代码**：
```cpp
inline void solve(int num) {
    int re = 0;
    FOR(i, 20, 0) {
        if (((k >> i) & 1) && ((num >> i) & 1)) dp[re + (1 << i)]++, dp[re + (1 << (i + 1))]--;
        else if ((k >> i) & 1) {
            dp[re]++, dp[re + (1 << i)]--;
            re += (1 << i);
        } else if ((num >> i) & 1) re += (1 << i);
    }
}
```
**实现思想**：通过逐位枚举 `a_i` 和 `k` 的二进制位，利用差分数组记录符合条件的 `x` 区间，最后通过前缀和统计最大值。

#### 3. 作者：SerokSSR (赞：7)  
**星级：4星**  
**关键亮点**：  
- 通过按位枚举 `a_i` 和 `k` 的二进制位，利用差分数组记录符合条件的 `x` 区间，最后通过前缀和统计最大值。
- 代码实现较为简洁，思路清晰，适合初学者理解和实现。

**核心代码**：
```cpp
for (int i = 1; i <= n; ++i) {
    int sum = 0;
    for (int j = 20; j >= 0; --j) {
        if ((k >> j) & 1) {
            if ((a[i] >> j) & 1) {
                c[sum + (1 << j)]++;
                c[sum + (1 << j + 1)]--;
            } else {
                c[sum]++;
                c[sum + (1 << j)]--;
                sum += 1 << j;
            }
        } else {
            sum = sum + ((a[i] >> j & 1) << j);
        }
    }
}
```
**实现思想**：通过逐位枚举 `a_i` 和 `k` 的二进制位，利用差分数组记录符合条件的 `x` 区间，最后通过前缀和统计最大值。

### 最优关键思路与技巧

1. **按位枚举与差分**：从高位到低位逐位枚举 `a_i` 和 `k` 的二进制位，利用差分数组记录符合条件的 `x` 区间，最后通过前缀和统计最大值。这种方法简洁高效，适合初学者理解和实现。
2. **Trie树与动态规划**：通过 Trie 树存储 `a_i` 的二进制表示，并结合动态规划或贪心策略，优化了查询和统计的过程。这种方法适合对数据结构有深入理解的选手。

### 可拓展之处

1. **类似题目**：可以拓展到其他位运算相关的题目，如异或最大值、按位与最大值等。
2. **数据结构优化**：可以尝试使用其他数据结构（如线段树、树状数组）来优化查询和统计的过程。

### 推荐题目

1. [P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得摘录

- **调试经历**：部分题解中提到在调试过程中发现 `x` 的取值范围需要特别注意，尤其是在高位枚举时，差分的区间处理容易出错。
- **顿悟感想**：通过按位枚举和差分技巧，能够将复杂的位运算问题转化为简单的区间统计问题，极大地简化了代码实现和调试过程。

---
处理用时：41.59秒
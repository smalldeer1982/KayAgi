# 题目信息

# [蓝桥杯 2018 省 A] 三体攻击

## 题目描述

三体人将对地球发起攻击。为了抵御攻击，地球人派出了 $A\times B\times C$ 艘战舰，在太空中排成一个 $A$ 层 $B$ 行 $C$ 列的立方体。其中，第 $i$ 层第 $j$ 行第 $k$ 列的战舰（记为战舰 $(i, j, k)$）的生命值为 $d(i, j, k)$。

三体人将会对地球发起 $m$ 轮“立方体攻击”，每次攻击会对一个小立方体中的所有战舰都造成相同的伤害。具体地，第 $t$ 轮攻击用 $7$ 个参数 $la_t, ra_t, lb_t, rb_t, lc_t, rc_t, h_t$ 描述；

所有满足 $i\in [la_t, ra_t],j\in [lb_t, rb_t],k\in [lc_t, rc_t]$ 的战舰 $(i, j, k)$ 会受到 $h_t$ 的伤害。如果一个战舰累计受到的总伤害超过其防御力，那么这个战舰会爆炸。

地球指挥官希望你能告诉他，第一艘爆炸的战舰是在哪一轮攻击后爆炸的。


## 说明/提示

**【样例解释】**

在第 $2$ 轮攻击后，战舰 $(1,1,1)$ 总共受到了 $2$ 点伤害，超出其防御力导致爆炸。

**【数据约定】**

对于 $10\%$ 的数据，$B = C = 1$；

对于 $20\%$ 的数据，$C = 1$；

对于 $40\%$ 的数据，$A\times B \times C, m\le10000$；

对于 $70\%$ 的数据，$A, B, C \le 200$；

对于所有数据，$1\le A\times B\times C \le 10^6$，$1\le m \le 10^6$，$0 \le  (i, j, k)$, $h_t\le 10^9$。

## 样例 #1

### 输入

```
2 2 2 3
1 1 1 1 1 1 1 1
1 2 1 2 1 1 1
1 1 1 2 1 2 1
1 1 1 1 1 1 2```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是通过三维差分和二分查找来优化大规模数据的处理。由于直接暴力模拟会超时，题解普遍采用了以下策略：
1. **二分查找**：利用单调性，通过二分查找确定第一艘战舰爆炸的轮数。
2. **三维差分**：通过差分数组快速记录每次攻击的影响，避免逐个修改战舰生命值。
3. **压维优化**：将三维数组压缩为一维数组，减少内存消耗。

### 所选高质量题解

#### 题解1：作者：GUO120822 (5星)
**关键亮点**：
- **思路清晰**：详细解释了三维差分的推导过程，从一维到二维再到三维，逐步引导读者理解。
- **代码可读性高**：代码结构清晰，注释详细，易于理解。
- **优化到位**：通过压维和二分查找，有效降低了时间和空间复杂度。

**个人心得**：
- 作者提到“HACK 数据”的注意事项，提醒读者注意边界情况，避免越界访问。

**核心代码**：
```cpp
bool check(int mid) {
    memset(c, 0, sizeof(c));
    for (int i = 1; i <= mid; i++) 
        cf(sx[i], sy[i], sz[i], tx[i], ty[i], tz[i], h[i]);
    for (int i = 1; i <= A; i++) {
        for (int j = 1; j <= B; j++) {
            for (int k = 1; k <= C; k++) {
                c[calc(i, j, k)] += c[calc(i-1, j, k)] + c[calc(i, j-1, k)] + c[calc(i, j, k-1)] 
                                   - c[calc(i-1, j-1, k)] - c[calc(i-1, j, k-1)] - c[calc(i, j-1, k-1)] 
                                   + c[calc(i-1, j-1, k-1)];
                if (c[calc(i, j, k)] > a[calc(i, j, k)]) return true;
            }
        }
    }
    return false;
}
```
**核心思想**：通过三维差分数组记录攻击影响，再通过前缀和计算每个战舰的累计伤害，判断是否爆炸。

#### 题解2：作者：Cuxhin (4.5星)
**关键亮点**：
- **详细解释**：从差分的基本概念入手，逐步推导出三维差分的公式，适合初学者理解。
- **优化思路**：通过多次差分和前缀和的方式，避免了容斥系数的复杂讨论。

**个人心得**：
- 作者提到“多次差分的复杂度可以做到 $O(m \times 2^n + a^n \times n)$”，强调了多次差分的效率优势。

**核心代码**：
```cpp
void up1(int a1, int b1, int c1, int a2, int b2, int c2, int val) {
    up2(a1, b1, c1, a1, b2, c2, val);
    up2(a2+1, b1, c1, a2+1, b2, c2, -val);
}
```
**核心思想**：通过多次差分的方式，分别对x、y、z方向进行差分操作，最后通过前缀和还原。

#### 题解3：作者：_O_v_O_ (4星)
**关键亮点**：
- **简洁明了**：代码简洁，直接切入主题，适合有一定基础的读者。
- **优化到位**：通过压维和二分查找，有效降低了复杂度。

**核心代码**：
```cpp
bool check(int x) {
    memset(cf, 0, sizeof(cf));
    for (int i = 1; i <= x; i++) {
        cf[QwQ(la[i], lb[i], lc[i])] += h[i];
        cf[QwQ(ra[i]+1, lb[i], lc[i])] -= h[i];
        // 其他差分操作...
    }
    // 前缀和计算...
    return false;
}
```
**核心思想**：通过三维差分数组记录攻击影响，再通过前缀和计算每个战舰的累计伤害，判断是否爆炸。

### 最优关键思路与技巧
1. **三维差分**：通过差分数组快速记录区间修改，避免逐个修改战舰生命值。
2. **二分查找**：利用单调性，通过二分查找确定第一艘战舰爆炸的轮数。
3. **压维优化**：将三维数组压缩为一维数组，减少内存消耗。

### 可拓展之处
- **类似题目**：可以扩展到更高维的差分问题，如四维差分等。
- **算法套路**：差分+二分查找的组合可以应用于其他需要快速区间修改和查询的问题。

### 推荐题目
1. [P1083 借教室](https://www.luogu.com.cn/problem/P1083)
2. [P3397 地毯](https://www.luogu.com.cn/problem/P3397)
3. [P3810 【模板】三维偏序](https://www.luogu.com.cn/problem/P3810)

### 个人心得总结
- **调试经历**：多位作者提到在调试过程中遇到的越界问题，提醒读者注意边界情况。
- **顿悟感想**：通过多次差分和前缀和的方式，可以避免容斥系数的复杂讨论，提高代码效率。

---
处理用时：36.67秒
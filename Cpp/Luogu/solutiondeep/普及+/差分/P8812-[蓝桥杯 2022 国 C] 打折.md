# 题目信息

# [蓝桥杯 2022 国 C] 打折

## 题目描述

小蓝打算采购 $n$ 种物品，每种物品各需要 $1$ 个。

小蓝所住的位置附近一共有 $m$ 个店铺，每个店铺都出售着各种各样的物品。

第 $i$ 家店铺会在第 $s_i$ 天至第 $t_i$ 天打折，折扣率为 $p_i$，对于原件为 $b$ 的物品，折后价格为 $\lfloor\frac {b\cdot p_j}{100}\rfloor$。其它时间需按原价购买。

小蓝很忙，他只能选择一天的时间去采购这些物品。请问，他最少需要花多少钱才能买到需要的所有物品。

题目保证小蓝一定能买到需要的所有物品。

## 说明/提示

对于 $40\%$ 的评测用例，$n,m≤500，s_i ≤t_i ≤100，\sum c_i ≤2000$；

对于 $70\%$ 的评测用例，$n,m≤5000，\sum c_i ≤20000$；

对于所有评测用例，$1 ≤ n,m ≤ 10^5，1 ≤ c_i ≤ n，\sum c_i ≤ 4\times10^5，1 ≤ s_i ≤t_i ≤10^9，1 < p_i < 100，1≤a_j ≤n，1≤b_j ≤10^9$。

蓝桥杯 2022 国赛 C 组 I 题。

## 样例 #1

### 输入

```
2 2
1 2 89 1
1 97
3 4 77 1
2 15```

### 输出

```
101```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在多个店铺和多个时间点中选择最优的购买策略，以最小化总花费。两个题解分别采用了不同的思路：

1. **tmp_get_zip_diff** 的题解通过离散化时间点，利用 `multiset` 维护每个物品在不同时间点的价格，并通过动态更新每个时间点的价格变化来计算最小总花费。该解法思路清晰，代码实现较为简洁，且通过离散化处理了时间点的复杂度，适合大规模数据。

2. **Sweet_2013** 的题解则采用了贪心策略，认为最优时间点一定是某个物品的打折开始时间点，并通过平衡树维护每个物品的价格集合。该解法在理论上可行，但实现复杂度较高，且未提供完整代码，可读性和实用性较低。

综合来看，**tmp_get_zip_diff** 的题解更为优秀，思路清晰且代码实现较为简洁，适合实际应用。

### 所选高分题解

#### 题解：tmp_get_zip_diff (★★★★★)

**关键亮点：**
- **离散化时间点**：通过离散化处理，将时间点压缩为有限的几个关键点，大大降低了时间复杂度和空间复杂度。
- **动态更新价格**：利用 `multiset` 维护每个物品在不同时间点的价格，并通过动态更新每个时间点的价格变化来计算最小总花费。
- **代码简洁清晰**：代码结构清晰，注释详细，易于理解和实现。

**核心代码片段：**
```cpp
vector<vector<pair<int, int>>> startD(len), endD(len);
for (int i = 0 ; i < m ; i++) {
    int starts = get(s[i]), ends = get(t[i] + 1);
    for (auto& [x, y] : v[i]) {
        int t = 1LL * y * p[i] / 100;
        st[x].insert(y);
        startD[starts].emplace_back(x, t);
        endD[ends].emplace_back(x, t);
    }
}
long long temp = 0;
for (int i = 1 ; i <= n ; i++) temp += *st[i].begin();
long long ans = temp;
for (int i = 0 ; i < len ; i++) {
    long long k = 0;
    for (auto& [x, y] : startD[i]) {
        k -= *st[x].begin();
        st[x].insert(y);
        k += *st[x].begin();
    }
    for (auto& [x, y] : endD[i]) {
        k -= *st[x].begin();
        int t = st[x].count(y);
        st[x].erase(y);
        for (int j = 1 ; j < t ; j++) st[x].insert(y);
        k += *st[x].begin();
    }
    temp += k;
    ans = min(ans, temp);
}
```

**个人心得：**
- **离散化处理**：通过离散化时间点，将问题转化为有限的关键时间点，大大简化了问题复杂度。
- **动态更新**：利用 `multiset` 动态维护每个物品的价格变化，确保每次更新都能快速计算出最小总花费。

### 最优关键思路与技巧

1. **离散化时间点**：将无限的时间点压缩为有限的关键点，降低问题复杂度。
2. **动态更新价格**：利用 `multiset` 维护每个物品的价格，动态更新每个时间点的价格变化，确保每次更新都能快速计算出最小总花费。
3. **贪心策略**：通过贪心策略，选择最优时间点，确保每次更新都能得到最优解。

### 可拓展之处

- **同类型题**：类似的时间点选择问题，如选择最优时间点进行任务调度、资源分配等。
- **类似算法套路**：离散化处理、动态更新、贪心策略等算法套路在时间点选择问题中具有广泛应用。

### 推荐洛谷题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
3. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

这些题目考察了离散化、动态更新、贪心策略等知识点，与本题解中的思路和技巧相似，适合进一步练习和巩固。

---
处理用时：27.00秒
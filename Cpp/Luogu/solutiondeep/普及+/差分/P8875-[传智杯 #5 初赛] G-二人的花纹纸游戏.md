# 题目信息

# [传智杯 #5 初赛] G-二人的花纹纸游戏

## 题目背景

梅莉买到了一张特殊的带有花纹的纸。整张纸的图案可以视为，由一个较小的图案，沿着横向与纵向无限循环而成。同时，这个基本图案部分透明，部分不透明。

于是，如果将这张纸覆盖在书本上，那么一些字可以被看见，另一些字看不见。

莲子突发奇想：假使她制作一张很大很大的数表，将花纹纸覆盖在上面，那么就会有很多数字被遮挡。那些没有被遮挡的数字的和是多少呢？

## 题目描述

事实上，二人的问题可以转化成如下描述：给定一个 $n$ 行 $m$ 列的普通矩阵 $A$，以及一个 $r$ 行 $c$ 列的 $01$ 矩阵 $B$。$B$ 中为 $1$ 的格子是黑色，不透明；为 $0$ 的格子是透明的。

![](https://cdn.luogu.com.cn/upload/image_hosting/6z0uo690.png)

使用 $B$ 矩阵，循环生成一个**无穷大**的矩阵 $M$：

![](https://cdn.luogu.com.cn/upload/image_hosting/laycum3q.png)

现在有 $q$ 次询问。每次将 $M$ 矩阵左上角和 $(x_1,y_1)$ 对齐，此时此时会有一些 $A$ 中的元素被遮挡，另一些元素可以被看见。

![](https://cdn.luogu.com.cn/upload/image_hosting/dtpe8m5u.png)

求出此时，$A$ 当中以 $(x_1,y_1)$ 作为左上角，$(x_2,y_2)$ 作为右下角的子矩阵中，可以被看见的元素之和。结果对 $998{,}244{,}353$ 取模。

在上面的例子里，$(x_1,y_1)=(2,3)$，$(x_2,y_2)=(4,7)$。可以被看见的元素之和为 $a_{2,3}+a_{2,5}+a_{2,6}+a_{3,5}+a_{4,3}+a_{4,5}+a_{4,6}$。

### 形式化题面

给定一个 $n$ 行 $m$ 列的普通矩阵 $A$，以及一个 $r$ 行 $c$ 列的 $01$ 矩阵 $B$。使用 $B$ 矩阵，生成一个**无穷大**的矩阵 $M$：

$$M=
\begin{pmatrix}
B & B & B  &\cdots \\
B & B & B  &\cdots \\
B & B & B  &\cdots \\
\vdots &\vdots &\vdots &
\end{pmatrix}
=\begin{pmatrix}
b_{1,1} & b_{1,2} & \cdots & b_{1,c} & b_{1,1} & b_{1,2} & \cdots & b_{1,c} & b_{1,1} & \cdots \\
b_{2,1} & b_{2,2} & \cdots & b_{2,c} & b_{2,1} & b_{2,2} & \cdots & b_{2,c} & b_{2,1} & \cdots \\
\vdots & \vdots & & \vdots & \vdots & \vdots & & \vdots & \vdots &  \\
b_{r,1} & b_{r,2} & \cdots & b_{r,c} & b_{r,1} & b_{r,2} & \cdots & b_{r,c} & b_{r,1} & \cdots \\
b_{1,1} & b_{1,2} & \cdots & b_{1,c} & b_{1,1} & b_{1,2} & \cdots & b_{1,c} & b_{1,1} & \cdots \\
b_{2,1} & b_{2,2} & \cdots & b_{2,c} & b_{2,1} & b_{2,2} & \cdots & b_{2,c} & b_{2,1} & \cdots \\
\vdots & \vdots & & \vdots & \vdots & \vdots & & \vdots & \vdots &  \\
b_{r,1} & b_{r,2} & \cdots & b_{r,c} & b_{r,1} & b_{r,2} & \cdots & b_{r,c} & b_{r,1} & \cdots \\
\vdots & \vdots & & \vdots & \vdots & \vdots & & \vdots & \vdots &  \\
\end{pmatrix}$$

现在有 $q$ 次询问，每次给出一个子矩阵的左上角坐标 $(x_1,y_1)$ 和右下角坐标 $(x_2,y_2)$，你需要求出：

$$S=\left(\sum_{i=x_1}^{x_2}\sum_{j=y_1}^{y_2}a_{i,j}\times [M_{i-x_1+1,j-y_1+1}=0] \right)\bmod 998{,}244{,}353$$

其中 $[P]$ 表示艾弗森括号。若 $P$ 为真，则 $[P]=1$，否则 $[P]=0$。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/z7yeiipu.png)

- 对于第一次询问，结果为 $2+4+5+7+10+12=40$；
- 对于第二次询问，结果为 $3+6+11=20$。

### 数据范围及约定

对于全部数据，保证 $1\le n,m\le 10^3$，$1\le q\le 10^4$，$1\le r,c\le 50$，$0\le a_{i,j}<998{,}244{,}353$，$b_{i,j}\in\{0,1\}$。

## 样例 #1

### 输入

```
3 4
1 2 3 4
5 6 7 8
9 10 11 12
2 2
1 0
0 1
2
1 1 3 4
1 2 3 3
```

### 输出

```
40
20
```

## 样例 #2

### 输入

```
4 4
1 3 2 4
5 4 2 3
4 1 2 3
3 4 4 3
1 3
1 0 0
3
1 1 3 4
2 2 4 4
1 2 3 2
```

### 输出

```
14
17
0
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效处理矩阵的循环覆盖问题，并快速计算子矩阵中可见元素的和。题解中，离散小波变换°的解法通过将矩阵按循环周期染色，并利用二维前缀和优化计算，显著降低了时间复杂度。该解法思路清晰，代码实现简洁，且时间复杂度为 $\mathcal O(nm+qrc)$，能够很好地应对题目中的数据范围。

### 所选题解

#### 题解作者：离散小波变换° (★★★★★)

**关键亮点：**
1. **循环染色与二维前缀和**：通过将矩阵按 $r \times c$ 的周期染色，并利用二维前缀和快速计算每种颜色的子矩阵和，极大地优化了查询效率。
2. **时间复杂度优化**：通过预处理二维前缀和，将每次查询的时间复杂度降低到 $\mathcal O(rc)$，适合大规模查询。
3. **代码简洁性**：代码结构清晰，逻辑简单，易于理解和实现。

**核心代码实现思想：**
```cpp
int calc(int a1, int b1, int a2, int b2){
    int ret = S[a2][b2];
    if(a1 > r) ret = (ret - S[a1 - r][b2] + MOD) % MOD;
    if(b1 > c) ret = (ret - S[a2][b1 - c] + MOD) % MOD;
    if(a1 > r && b1 > c) ret = (ret + S[a1 - r][b1 - c]) % MOD;
    return ret;
}
```
该函数用于计算子矩阵的和，利用二维前缀和的差分性质，快速得到结果。

**完整核心代码片段：**
```cpp
up(1, n, i) up(1, m, j){
    S[i][j] = A[i][j];
    if(i > r) S[i][j] = (S[i][j] + S[i - r][j]) % MOD;
    if(j > c) S[i][j] = (S[i][j] + S[i][j - c]) % MOD;
    if(i > r && j > c)
        S[i][j] = (S[i][j] - S[i - r][j - c] + MOD) % MOD;
}
```
该部分代码用于预处理二维前缀和，为后续查询提供基础。

### 最优关键思路或技巧

1. **循环染色**：将矩阵按 $r \times c$ 的周期染色，使得每种颜色在子矩阵中只出现一次，简化了计算。
2. **二维前缀和**：通过预处理二维前缀和，快速计算任意子矩阵的和，显著优化了查询效率。

### 可拓展之处

1. **类似问题**：该解法可以推广到其他涉及循环覆盖矩阵的问题，如循环卷积、循环矩阵乘法等。
2. **优化思路**：在处理大规模数据时，可以考虑进一步优化前缀和的计算，如使用分块或并行计算。

### 推荐题目

1. **P3382 【模板】二维前缀和**：练习二维前缀和的基本应用。
2. **P3390 【模板】矩阵快速幂**：学习矩阵的快速幂运算，适用于循环矩阵的快速计算。
3. **P3379 【模板】线段树 2**：学习线段树在处理区间查询和更新中的应用，适合处理大规模数据。

### 个人心得

离散小波变换°在题解中提到，通过将矩阵按循环周期染色，可以简化计算。这种思路在处理循环覆盖问题时非常有效，值得借鉴。此外，二维前缀和的使用也是该解法的关键，能够显著提高查询效率。

---
处理用时：25.79秒
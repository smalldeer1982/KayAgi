# 题目信息

# 「TERRA-OI R1」别得意，小子

## 题目背景

战至中途，蓝紫色天空瞬间变为黑压压一片，噬神者身上一些紫色外壳开始脱落，化为更小的蟒蛇，这些小家伙从出现开始便不要命的向你冲过来，刚清理掉这些小家伙，迷雾中忽然涌现出一张血盆大口，噬神者正向你冲击而来......

## 题目描述

现给定一个有 $n$ 段的分段函数，每一段可能是一个一次函数或者一个二次函数，并有 $q$ 次询问，每次询问 $x=k$ 时 $y$ 的取值或是 $y=k$ 与函数有多少个交点。



## 说明/提示

#### 【样例解释 #1】

三段函数分别为 $y=x+2$，$y=x^2-2x+1$，$y=x$。

对于当 $x=4$ 时套入第二段函数可以得到结果为 $9$。

而直线 $y=5$ 只与第一段与第二段函数相交，并且各只有一个交点，所以结果为 $2$。

显而易见，第三个询问对应的直线不与函数相交。

第四个询问虽然与第一段函数交于 $x=0$ 的位置，但 $0$ 不在该函数区间内，故舍去。

------------

#### 【数据范围】

**本题采用捆绑测试。**

| Subtask | Score | $n,q\le$ | limit |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $100$ | 无 |
| $2$ | $15$ | $10^3$ | $r_n\le 5\times 10^3$ |
| $3$ | $20$ | $2\times 10^5$ | 不存在询问 $2$ |
| $4$ | $25$ | $2\times 10^5$ | 不存在二次函数 |
| $5$ | $30$ | $2\times 10^5$ | 无 |

对于 $100\%$ 的数据，$1\le n,q\le 2\times 10^5$，$0\le l_i,r_i\le10^9$，$\forall i\in [1,n],r_i>l_i$ 。

所有的函数系数均在 **$64$ 位有符号整型变量**存储范围内，并且运算结果与每个函数式中任何一项的最大值与最小值不会超过 **$64$ 位有符号整型变量**存储范围。所有询问参数均在 **$32$ 位有符号整型变量**范围内。

（即 $-4\times 10^{18}\le k,a,b,c\le 4\times 10^{18}$，$-10^9\le x\le 10^9$）

------------
#### 【提示】

采用浮点数据时建议使用 long double，避免产生精度问题。

upd：添加一组 hack 数据，未通过会显示为“Unaccepted 100pts”。

## 样例 #1

### 输入

```
3 4
0 3 1 1 2
3 6 2 1 -2 1
6 10 1 1 0
1 4
2 5
2 114514
2 2```

### 输出

```
9
2
0
0```

## 样例 #2

### 输入

```
6 8
0 4 2 1 -4 0 
4 6 1 2 -10 
6 11 1 1 -19 
11 19 2 -1 -30 559 
19 29 1 1 -58 
29 38 1 1 -68 
1 11
2 4
2 -1
1 21
2 -5
2 2
1 34
2 1
```

### 输出

```
-8
1
4
-37
1
2
-34
2
```

# AI分析结果

### 综合分析与结论

本题的核心在于处理分段函数的值域和交点问题，尤其是二次函数的复杂性和大值域的处理。各题解的主要思路是通过二分查找、差分、离散化、动态开点线段树等方法来优化查询和更新操作。以下是各题解的要点对比：

1. **MCRS_lizi**：使用 `map` 存储差分标记，处理二次函数时通过对称轴分段，并进行复杂的分类讨论。思路清晰，但代码实现较为复杂。
2. **kbtyyds**：通过离散化和差分处理一次函数，二次函数则通过对称轴分段处理。思路清晰，代码结构较好，但二次函数的处理仍有较多细节。
3. **聊机**：使用动态开点线段树处理大值域问题，思路新颖，但代码实现较为复杂，且动态开点线段树的内存消耗较大。
4. **jifbt**：通过二分查找和差分处理一次函数和二次函数，代码简洁，思路清晰，且效率较高。

### 所选高分题解

#### 题解：jifbt (评分：5星)
- **关键亮点**：通过二分查找和差分处理一次函数和二次函数，代码简洁且效率高。二次函数通过对称轴分段处理，避免了复杂的分类讨论。
- **个人心得**：作者提到最初想将二次函数整体处理，但发现分段处理更简单，体现了对问题的深入理解和优化思路。

```cpp
void add(ll i,db l,db r){
    db x=calc(i,l),y=calc(i,r);
    if(x<y)diff[++cnt]={floor(x)+1,1},diff[++cnt]={floor(y)+1,-1};
    else diff[++cnt]={ceil(y),1},diff[++cnt]={ceil(x),-1};
}
```

#### 题解：kbtyyds (评分：4星)
- **关键亮点**：通过离散化和差分处理一次函数，二次函数则通过对称轴分段处理。思路清晰，代码结构较好。
- **个人心得**：作者提到二次函数的处理需要谨慎，尤其是顶点的小数部分和区间的开闭取值，体现了对细节的重视。

```cpp
inline void solve()
{
    for(int i=1;i<=len;i++)
    {
        tmp[++tlen]=p[i].l-1,tmp[++tlen]=p[i].l;
        tmp[++tlen]=p[i].r,tmp[++tlen]=p[i].r+1;
    }
    sort(tmp+1,tmp+tlen+1);
    tlen=unique(tmp+1,tmp+tlen+1)-tmp-1;
    for(int i=1;i<=len;i++)
    {
        int L=lower_bound(tmp+1,tmp+tlen+1,p[i].l)-tmp;
        int R=lower_bound(tmp+1,tmp+tlen+1,p[i].r)-tmp;
        cf[L]++,cf[R+1]--;
    }
    for(int i=1;i<=tlen;i++) cf[i]+=cf[i-1];
}
```

### 最优关键思路与技巧

1. **二分查找**：用于快速定位查询点所在的函数区间，适用于大值域问题。
2. **差分与离散化**：通过差分标记和离散化处理大值域问题，避免直接存储大范围的数组。
3. **动态开点线段树**：适用于处理大值域问题，但内存消耗较大，实现复杂。
4. **二次函数分段处理**：通过对称轴将二次函数分段处理，简化了复杂的分类讨论。

### 可拓展之处

- **类似算法套路**：处理大值域问题时，可以考虑使用离散化、差分、动态开点线段树等方法。对于分段函数的问题，可以通过二分查找快速定位区间。
- **同类型题目**：可以尝试处理更复杂的分段函数，如包含三角函数、指数函数等的分段函数。

### 推荐题目

1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)

### 个人心得总结

- **调试经历**：多位作者提到在处理二次函数时遇到了复杂的分类讨论问题，最终通过分段处理简化了问题。
- **踩坑教训**：动态开点线段树的内存消耗较大，需要谨慎使用。二次函数的顶点处理需要特别注意，尤其是顶点是否为整点的情况。
- **顿悟感想**：分段处理二次函数可以大大简化问题，体现了对问题的深入理解和优化思路。

---
处理用时：34.17秒
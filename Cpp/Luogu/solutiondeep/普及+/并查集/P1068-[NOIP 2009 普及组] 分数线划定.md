# 题目信息

# [NOIP 2009 普及组] 分数线划定

## 题目描述

世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 $150\%$ 划定，即如果计划录取 $m$ 名志愿者，则面试分数线为排名第 $m \times 150\%$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。

现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。

## 说明/提示

【样例说明】

$m \times 150\% = 3 \times150\% = 4.5$，向下取整后为 $4$。保证 $4$ 个人进入面试的分数线为 $88$，但因为 $88$ 有重分，所以所有成绩大于等于 $88$ 的选手都可以进入面试，故最终有 $5$ 个人进入面试。

NOIP 2009 普及组 第二题


## 样例 #1

### 输入

```
6 3 
1000 90 
3239 88 
2390 95 
7231 84 
1005 95 
1001 88```

### 输出

```
88 5 
1005 95 
2390 95 
1000 90 
1001 88 
3239 88 ```

# AI分析结果

### 综合分析与结论
这些题解主要围绕着如何根据给定的规则划定面试分数线并输出进入面试的选手信息展开。大部分题解采用了结构体存储选手的报名号和成绩，然后通过自定义排序函数对选手进行排序，排序规则为成绩从高到低，成绩相同时报名号从小到大。接着根据计划录取人数的 150% 确定分数线，统计成绩不低于分数线的人数，最后输出分数线、人数以及进入面试的选手信息。

其中，“「已注销」”的题解使用下标数组代替结构体，避免了结构体的使用；“zhengrunzhe”的题解使用 Splay 树这种高级数据结构，实现复杂度较高，但在处理动态数据时有一定优势。其他题解大多使用结构体和排序算法，思路较为常规。

### 所选题解
- 作者：「已注销」 (赞：294)，5 星
  - 关键亮点：思路清晰，代码简洁，使用下标数组代替结构体，避免了结构体的使用，降低了代码复杂度。
  - 核心代码：
```cpp
bool cmp(int a, int b) {
    if (s[a] == s[b]) return k[a] < k[b];
    return s[a] > s[b];
}
int main() {
    cin >> n >> m;
    for (i = 1; i <= n; i++) cin >> k[sub[i] = i] >> s[i];
    sort(sub + 1, sub + n + 1, cmp);
    f = s[sub[int(m * 1.5)]];
    for (i = 1; s[sub[i]] >= f; i++);
    cout << f << " " << i - 1 << endl;
    for (i = 1; s[sub[i]] >= f; i++) cout << k[sub[i]] << " " << s[sub[i]] << endl;
}
```
  - 核心实现思想：使用下标数组 `sub` 存储选手的下标，通过自定义排序函数 `cmp` 对下标数组进行排序，根据排序后的下标数组确定分数线和进入面试的人数，最后输出结果。

- 作者：2023z (赞：18)，4 星
  - 关键亮点：思路清晰，代码规范，使用结构体存储选手信息，通过自定义排序函数对结构体数组进行排序，易于理解。
  - 核心代码：
```cpp
struct Scoreline {
    int k, s;
} a[5010];
bool cmp(Scoreline a, Scoreline b) {
    if (a.s!= b.s) return a.s > b.s;
    return a.k < b.k;
}
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i].k >> a[i].s;
    sort(a + 1, a + n + 1, cmp);
    int x = a[int(m * 1.5)].s;
    cout << x << ' ';
    for (int i = n; i >= 1; i--) {
        if (a[i].s >= x) {
            j = i;
            break;
        }
    }
    cout << j << endl;
    for (int i = 1; i <= j; i++) cout << a[i].k << ' ' << a[i].s << endl;
    return 0;
}
```
  - 核心实现思想：定义结构体 `Scoreline` 存储选手的报名号和成绩，通过自定义排序函数 `cmp` 对结构体数组进行排序，根据排序后的数组确定分数线和进入面试的人数，最后输出结果。

- 作者：Eason_lyx (赞：1)，4 星
  - 关键亮点：代码注释详细，对思路和实现步骤进行了清晰的解释，适合初学者学习。
  - 核心代码：
```cpp
struct M {
    int k, s;
} a[5005];
bool cmp(M a, M b) {
    if (a.s!= b.s) return a.s > b.s;
    return a.k < b.k;
}
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].k >> a[i].s;
    }
    sort(a + 1, a + n + 1, cmp);
    sc = a[(int)(1.5 * m)].s;
    while (a[cnt + 1].s >= sc) cnt++;
    printf("%d %d\n", sc, cnt);
    for (int i = 1; i <= cnt; i++) {
        printf("%d %d\n", a[i].k, a[i].s);
    }
    return 0;
}
```
  - 核心实现思想：定义结构体 `M` 存储选手的报名号和成绩，通过自定义排序函数 `cmp` 对结构体数组进行排序，根据排序后的数组确定分数线和进入面试的人数，最后输出结果。

### 最优关键思路或技巧
- 使用结构体存储选手的报名号和成绩，方便对选手信息进行管理和排序。
- 自定义排序函数，按照成绩从高到低、成绩相同时报名号从小到大的规则对选手进行排序。
- 根据计划录取人数的 150% 确定分数线，统计成绩不低于分数线的人数。

### 可拓展之处
同类型题可以是根据不同的规则对数据进行筛选和排序，例如根据不同的科目成绩进行排名，或者根据多个条件进行筛选等。类似算法套路包括使用结构体存储数据、自定义排序函数、根据条件筛选数据等。

### 推荐题目
- P1177 【模板】快速排序
- P1093 [NOIP2007 普及组] 奖学金
- P1271 [NOIP2003 普及组] 选举学生会

### 个人心得
题解中未包含个人心得相关内容。

---
处理用时：32.32秒
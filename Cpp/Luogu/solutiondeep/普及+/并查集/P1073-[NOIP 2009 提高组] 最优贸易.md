# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕“最优贸易”问题展开，核心是在图中找到从 1 号城市到 n 号城市的路径，通过一次买卖水晶球获取最大利润。题解中采用了多种算法，其中分层图和 Tarjan 缩点是较为常见的思路。

分层图思路是将图分为多层，每层代表不同的买卖状态，通过建立有向边来表示状态转移，最后求最长路得到最大利润。Tarjan 缩点则是先将图中的强连通分量缩成一个点，将图转化为 DAG，再在 DAG 上进行动态规划求解。

各题解的差异主要体现在实现细节和优化程度上。分层图实现中，边权设置和建图方式略有不同；Tarjan 缩点实现中，对强连通分量的处理和状态转移方程也存在差异。

### 所选题解
- **作者：fy1234567ok (赞：477)，5 星**
  - **关键亮点**：思路清晰，通过分层图状态转移思想解决问题，代码简洁仅 40 行，使用 C++11 和 C++17 特性简化代码。
  - **个人心得**：2 年前退役，鸽了很久才更新，感谢评论中指出错误和提建议的大佬，更新了建模、优化了代码，能通过 Hack 数据。
- **作者：HPXXZYY (赞：10)，4 星**
  - **关键亮点**：详细解释了分层图概念，代码实现简单，通过分层图和最短路算法求解问题。
- **作者：Ngo123 (赞：3)，4 星**
  - **关键亮点**：使用两次 SPFA 算法，分别求出从 1 到 i 的最低价格和从 i 到 n 的最高价格，最后枚举求最大差价，思路简洁。

### 重点代码及核心思想
#### fy1234567ok 的题解
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;

int n, m, d[maxn*3], inq[maxn*3];
vector<pair<int, int>> G[maxn*3];

#define t(x,i) (x+i*n)  // t(x,i) 表示第i层的x
// 建立x->y边的函数, 不用加 make_pair是 C++11特性
#define add(x, y) G[t(x,0)].push_back({t(y,0), 0}), G[t(x,1)].push_back({t(y,1),0}), G[t(x,2)].push_back({t(y,2),0})

void spfa(int s) {
    for(int i = 1;i <= n*3;i++) d[i] = INT_MIN; // 这里n*3别漏了, INT_MIN 是C++内置最小值常量
    d[s] = 0; 
    queue<int> Q; inq[s] = true; Q.push(s);
    while(!Q.empty()) {
        int x = Q.front(); Q.pop(); inq[x] = false;
        for(auto [v, len] : G[x])  // C++17 特性, 等价于 int v = G[x][i].first, len = G[x][i].second;
            if(d[v] < d[x] + len) {
                d[v] = d[x] + len;
                if(!inq[v]) { Q.push(v); inq[v] = true; }
            } 
    }
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0); // 加速cin, cout
    cin >> n >> m;
    for(int i = 1, v;i <= n; ++i) {
        cin >> v;
        G[t(i,0)].push_back({t(i,1), -v});
        G[t(i,1)].push_back({t(i,2), v});
    }
    for(int i = 1,x,y,z;i <= m; ++i) {
        cin >> x >> y >> z; add(x, y);
        if(z == 2) add(y, x);
    }
    spfa(t(1,0));
    cout << d[t(n,2)] << endl;
    return 0;
}
```
**核心思想**：将图分为三层，第一层表示未买入，第二层表示已买入，第三层表示已卖出。通过建立有向边表示状态转移，边权表示买卖的价格变化。最后使用 SPFA 算法求从第一层的 1 号点到第三层的 n 号点的最长路，即为最大利润。

#### HPXXZYY 的题解
```cpp
const int N=100100;
const int M=500100;
struct node{
    int next,to,len;
}e[M*6+N*2];int h[N*3],tot;
inline void add(int a,int b,int w){
    e[++tot]=(node){h[a],b,w};h[a]=tot;
}
int d[N*3];bool vis[N*3];
inline void spfa_algorithm(int s){
    memset(d,128,sizeof(d));
    memset(vis,1,sizeof(vis));
    queue<int> q;q.push(s);d[s]=0;
    while (q.size()){
        int u=q.front();q.pop();vis[u]=true;
        for(int i=h[u];i;i=e[i].next){
            register int to=e[i].to;
            if (d[to]<d[u]+e[i].len){
                d[to]=d[u]+e[i].len;
                if (vis[to]){
                    vis[to]=false;
                    q.push(to);
                }
            }
        }
    }
}
int n,m,cost[N];
inline void read_the_date(){
    n=read();m=read();
    for(int i=1;i<=n;i++){
        cost[i]=read();
        add(i,i+n,-cost[i]);
        add(i+n,i+2*n,cost[i]);
    }
    for(int i=1;i<=m;i++){
        register int u=read(),v=read(),z=read();
        add(u,v,0);add(u+n,v+n,0);add(u+2*n,v+2*n,0);
        if (z==2) add(v,u,0),add(v+n,u+n,0),add(v+2*n,u+2*n,0);
    }
}
inline int HPXXZYY(){
    read_the_date();
    spfa_algorithm(1);
    cout<<max(d[n],d[3*n]);
    return 0;
}
int main(){
    return HPXXZYY();
}
```
**核心思想**：同样采用分层图思想，将图分为三层，每层内的边权为 0，第一层到第二层的边权为负的买入价格，第二层到第三层的边权为卖出价格。使用 SPFA 算法求最长路，答案为 d[n] 或 d[3*n] 中的最大值。

#### Ngo123 的题解
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
vector <int> e[N],g[N];
bool vis[N];
int ans,minv[N],maxv[N],price[N],n,m,x,y,z;
void spfa1(int s)
{
    memset(minv,0x3f,sizeof minv);
    memset(vis,0,sizeof vis);
    queue <int> q; q.push(s);
    minv[s] = price[s],vis[s] = 1;
    while(q.size())
    {
        int x = q.front(); q.pop();
        vis[x] = 0;
        for(auto y:e[x])
            if(minv[y] > min(minv[x],price[y]))
            {
                minv[y] = min(minv[x],price[y]);
                if(!vis[y]) q.push(y),vis[y] = 1;
            }
    }
}
void spfa2(int s)
{
    memset(maxv,-0x3f,sizeof maxv);
    memset(vis,0,sizeof vis);
    queue <int> q; q.push(s);
    maxv[s] = price[s],vis[s] = 1;
    while(q.size())
    {
        int x = q.front(); q.pop();
        vis[x] = 0;
        for(auto y:g[x])
            if(maxv[y] < max(maxv[x],price[y]))
            {
                maxv[y] = max(maxv[x],price[y]);
                if(!vis[y]) q.push(y),vis[y] = 1;
            }
    }
}
int main()
{
    cin>>n>>m;
    for(int i = 1;i<=n;i++) cin>>price[i];
    while(m--)
    {
        cin>>x>>y>>z;
        e[x].push_back(y);
        g[y].push_back(x);
        if(z==2) e[y].push_back(x),g[x].push_back(y);
    }
    spfa1(1); spfa2(n);
    for(int i = 1;i<=n;i++)
        ans = max(ans,maxv[i]-minv[i]);
    cout << ans << endl;
    return 0;
}
```
**核心思想**：使用两次 SPFA 算法，第一次从 1 号点出发，求出从 1 到 i 的所有路径中水晶球的最低价格 minv[i]；第二次从 n 号点出发，建反图后求出从 i 到 n 的所有路径中水晶球的最高价格 maxv[i]。最后枚举每个城市，求出 maxv[i] - minv[i] 的最大值，即为最大利润。

### 最优关键思路或技巧
- **分层图思想**：将图分为多层，每层代表不同的状态，通过建立有向边表示状态转移，将复杂的状态问题转化为图上的路径问题。
- **Tarjan 缩点**：将图中的强连通分量缩成一个点，将图转化为 DAG，消除环的影响，便于进行动态规划。
- **两次 SPFA**：分别从起点和终点出发，求出最小价格和最大价格，最后枚举求最大差价，思路简洁。

### 可拓展之处
同类型题或类似算法套路：
- **分层图**：适用于有多种状态转移的图论问题，如 P2939、P4568、P4822 等题目。
- **Tarjan 缩点**：常用于处理有环的图论问题，将图转化为 DAG 后进行拓扑排序和动态规划。

### 推荐题目
- P2939 [USACO09FEB]Revamping Trails G
- P4568 [JLOI2011]飞行路线
- P4822 [BJWC2012]冻结

### 个人心得摘录与总结
- **fy1234567ok**：退役后仍关注题解，根据评论反馈更新代码，修复建模问题，优化代码，体现了对题解质量的重视和对社区的责任感。
- **ctzm**：经历两次 hack 后，发现分层图和 Tarjan 题解存在问题，作为 SPFA 被卡怕的人，决定写一篇 Tarjan 题解，让 Tarjan 党能使用稳定线性做法通过本题，提醒我们在解题时要考虑数据的多样性和算法的稳定性。

---
处理用时：73.33秒
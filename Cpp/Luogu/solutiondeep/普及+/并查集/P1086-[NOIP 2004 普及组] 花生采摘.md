# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是模拟多多采摘花生的过程，按花生数量从大到小排序，依次判断是否能在限定时间内采摘并返回。各题解在数据结构和实现细节上有所不同，如使用结构体、稀松矩阵、`map`、`priority_queue` 等存储和处理数据。

### 所选题解
- **作者：jiangXxin（5星）**
  - 关键亮点：思路清晰，注释详细，使用结构体存储花生位置和数量，通过曼哈顿距离计算移动时间，代码可读性高。
  - 个人心得：原本想用 BFS，发现花生地无障碍物后改用曼哈顿距离，体现了灵活选择算法的思维。

### 重点代码
```cpp
struct dire//记忆花生地址 
{
    int x,y,sum;
}stu[N*N];
bool comp(struct dire a,struct dire b)//比较，大的在前，小的在后 
{
    return a.sum>b.sum;
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>mp[i][j];
            if(mp[i][j]>0)
            {
                stu[++pn].sum=mp[i][j];
                stu[pn].x=i;
                stu[pn].y=j;
            }
        }
    }
    sort(stu+1,stu+pn+1,comp);
    fx=1;
    fy=stu[1].y;
    k--;
    for(int i=1;i<=pn;i++)
    {
        tm=0;
        ex=stu[i].x;
        ey=stu[i].y;
        tm=abs(fx-ex)+abs(fy-ey);
        k--;
        k-=tm;
        if(k>=ex)
        {
            ans+=mp[ex][ey];
            fx=ex;
            fy=ey;
        }
        else
        {
            cout<<ans<<endl;
            return 0;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
**核心实现思想**：先读取输入，将有花生的位置和数量存入结构体数组，按花生数量降序排序。初始化起点，依次遍历每个有花生的点，计算移动时间和剩余时间，判断是否能采摘并返回，能则更新答案和起点，不能则输出结果。

### 最优关键思路或技巧
- **数据结构**：使用结构体存储花生的位置和数量，方便排序和处理。
- **算法优化**：利用曼哈顿距离计算移动时间，避免复杂的路径搜索。
- **思维方式**：按照题目要求，从花生数量最多的点开始依次判断，保证在限定时间内采摘最多的花生。

### 可拓展之处
同类型题或类似算法套路：此类模拟题可拓展到其他场景，如机器人在网格中执行任务，需要在限定时间内完成特定目标。解题关键在于明确任务规则，合理选择数据结构存储信息，通过模拟过程进行判断和决策。

### 推荐题目
- [P1047 [NOIP2005 普及组] 校门外的树](https://www.luogu.com.cn/problem/P1047)
- [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
- [P1161 开灯](https://www.luogu.com.cn/problem/P1161)

### 个人心得摘录与总结
- **jiangXxin**：原本想用 BFS，发现花生地无障碍物后改用曼哈顿距离，体现了根据题目条件灵活选择算法的重要性。
- **_Arahc_**：详细列出题目坑点，如采摘花生耗费时间、不能抄近道等，提醒解题时要仔细审题，注意细节。 

---
处理用时：25.56秒
# 题目信息

# [NOIP 2010 提高组] 关押罪犯

## 题目背景

NOIP2010 提高组 T3

## 题目描述

S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1\sim N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。

每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。

在详细考察了 $N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。

那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？


## 说明/提示

**输入输出样例说明**

罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。

![](https://cdn.luogu.com.cn/upload/image_hosting/uia11zcq.png)

**数据范围**  

对于 $30\%$ 的数据有 $N\leq 15$。

对于 $70\%$ 的数据有 $N\leq 2000,M\leq 50000$。  

对于 $100\%$ 的数据有 $N\leq 20000,M\leq 100000$。


## 样例 #1

### 输入

```
4 6
1 4 2534
2 3 3512
1 2 28351
1 3 6618
2 4 1805
3 4 12884```

### 输出

```
3512```

# AI分析结果

### 综合分析与结论
这些题解主要围绕并查集和二分图两种思路来解决关押罪犯问题。并查集思路核心在于利用贪心策略，先对怨气值从大到小排序，尽量将怨气值大的罪犯分开，通过建立假想敌或拓展域的方式处理罪犯间的关系，当发现无法避免冲突时输出当前怨气值；二分图思路则是二分答案，判断大于答案的边构成的图是否为二分图。

### 所选题解
- **作者：梦回还 (赞：648)，4星**
    - **关键亮点**：思路清晰，代码简洁，对并查集的应用解释详细，通过标记“敌人”和合并敌人的敌人来处理罪犯关系，还特别强调了无冲突时输出 0 的情况。
- **作者：fy0123 (赞：17)，4星**
    - **关键亮点**：采用二分答案 + 二分图的思路，将问题转化为判断图是否为二分图，思路新颖，代码实现规范，对二分答案和二分图判断的过程解释清楚。
- **作者：_Weslie_ (赞：15)，4星**
    - **关键亮点**：详细介绍了拓展域并查集的概念、用途和实现方法，并结合本题进行了具体应用，对拓展域并查集的讲解深入浅出，有助于理解和掌握。

### 重点代码
#### 并查集思路（作者：梦回还）
```cpp
struct data {int x,y,z;};
data f[100005];
int n,m,a[20005],b[20005],i;
inline bool cmp(data a,data b) { return a.z>b.z; }
inline int find(int x) {
    if(a[x]==x) return x;
    a[x]=find(a[x]);
    return a[x];
}
inline void ad(int x,int y) {
    x=find(a[x]);
    y=find(a[y]);
    a[x]=y;
}
inline bool check(int x,int y) {
    x=find(x);
    y=find(y);
    if(x==y) return true;
    return false;
}
int main() {
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++) a[i]=i;
    for(i=1;i<=m;i++)
        scanf("%d%d%d",&f[i].x,&f[i].y,&f[i].z);
    sort(f+1,f+m+1,cmp);
    for(i=1;i<=m+1;i++) {
        if(check(f[i].x,f[i].y)) {printf("%d",f[i].z);break;}
        else {
            if(!b[f[i].x]) b[f[i].x]=f[i].y;
                else {ad(b[f[i].x],f[i].y);}
            if(!b[f[i].y]) b[f[i].y]=f[i].x;
                else {ad(b[f[i].y],f[i].x);}
        }
    }
    return 0;
}
```
**核心实现思想**：先对罪犯关系按怨气值从大到小排序，然后依次处理。对于每对罪犯，若他们已在同一监狱则输出怨气值；否则标记“敌人”，并合并敌人的敌人。

#### 二分答案 + 二分图思路（作者：fy0123）
```cpp
const int N = 20010;
const int M = 100010;
int n, m, color[N];
bool flag;
vector<int> e[N];
struct Node{
    int x, y, v;
    bool operator < (const Node &other) const{
        return v < other.v;
    }
}a[M];
inline void dfs(int u, int c) {
    color[u] = c;
    for (int i = 0; i < e[u].size(); i ++){
        int v = e[u][i];
        if (!color[v]) dfs(v, c ^ 1);
        else if (color[v] == c) flag = false;
    }
}
inline bool check(int pos) {
    for (int i = 1; i <= n; i ++) e[i].clear();
    for (int i = pos + 1; i <= m; i ++){
        e[a[i].x].push_back(a[i].y);
        e[a[i].y].push_back(a[i].x);
    }
    flag = true;
    memset(color, 0, sizeof color);
    for (int i = 1; i <= n; i ++)
        if (!color[i]){
            dfs(i, 0);
            if (!flag) return false;
        }
    return true;
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i ++)
        scanf("%d%d%d", &a[i].x, &a[i].y, &a[i].v);
    sort(a + 1, a + 1 + m);
    int l = 0, r = m, mid;
    while (l + 1 < r){
        mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    if (m == 1) puts("0");
    else printf("%d\n", a[r].v);
    return 0;
}
```
**核心实现思想**：先对罪犯关系按怨气值从小到大排序，然后二分答案。对于每个答案，将大于该答案的边连起来，通过 DFS 黑白染色判断是否为二分图，若是则缩小答案范围，否则扩大范围。

#### 拓展域并查集思路（作者：_Weslie_）
```cpp
struct node{
    int u,v,w;
}e[100005];
bool cmp(node _,node __){
    return _.w>__.w;
}
int fa[40005];
int findd(int now){
    if(fa[now]==now)return now;
    return fa[now]=findd(fa[now]);
}
void vnion(int u,int v){
    u=findd(u),v=findd(v);
    if(u==v)return;
    fa[u]=v;
}
int n,m;
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=2*n;i++)fa[i]=i;
    for(int i=1;i<=m;++i){
        scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
    }
    sort(e+1,e+m+1,cmp);
    for(int i=1;i<=m;i++){
        vnion(e[i].u+n,e[i].v);
        vnion(e[i].u,e[i].v+n);
        if(findd(e[i].u)==findd(e[i].u+n)||findd(e[i].v)==findd(e[i].v+n)){
            printf("%d",e[i].w);
            return 0;
        }
    }
    printf("0");
    return 0;
}
```
**核心实现思想**：使用拓展域并查集，$u$ 和 $u + n$ 分别表示点 $u$ 的两个相反状态。先对罪犯关系按怨气值从大到小排序，然后依次处理，将 $u$ 与 $v + n$ 、$v$ 与 $u + n$ 合并，若发现 $u$ 与 $u + n$ 或 $v$ 与 $v + n$ 在同一集合，则输出当前怨气值。

### 最优关键思路或技巧
- **贪心策略**：先对怨气值从大到小排序，优先处理怨气值大的罪犯关系，尽量将他们分开，以保证最终的最大冲突值最小。
- **拓展域并查集**：通过拓展域的方式，将一个点的不同状态（如本题中的敌人和朋友）用不同的编号表示，利用并查集处理这些状态之间的关系。
- **二分答案 + 二分图**：将问题转化为二分答案，通过判断大于答案的边构成的图是否为二分图来确定答案的范围。

### 可拓展之处
- **同类型题**：涉及集合划分、元素分组且有冲突关系的问题，如 P1892 [BOI2003]团伙、P2024 [NOI2001]食物链等。
- **类似算法套路**：可以将拓展域并查集应用到更多需要处理多种状态关系的问题中，二分答案 + 二分图的思路也可用于解决一些求最值且可通过判断图的性质来确定答案范围的问题。

### 推荐题目
- P1892 [BOI2003]团伙
- P2024 [NOI2001]食物链
- P1525 [NOIP2010 提高组] 关押罪犯（本题）

### 个人心得摘录与总结
- **作者：KrOX**：第一次写题解，提到“反人类”便于理解用 i + n 表示 i 的反人类，还提醒不要忘记在全部拆散后输出 0，否则会得 90 分。总结：在解题过程中可以采用一些形象的概念帮助理解，同时要注意特殊情况的处理。
- **作者：Gary0504**：提醒不要忘记程序结束时要 `cout << 0`，否则会有 90 分的悲惨事故。总结：在处理题目时要注意题目中的特殊要求，避免因遗漏细节而丢分。 

---
处理用时：58.54秒
# 题目信息

# [BalticOI 2003] 团伙

## 题目描述

现在有 $n$ 个人，他们之间有两种关系：朋友和敌人。我们知道：

- 一个人的朋友的朋友是朋友
- 一个人的敌人的敌人是朋友

现在要对这些人进行组团。两个人在一个团体内当且仅当这两个人是朋友。请求出这些人中最多可能有的团体数。

## 说明/提示

对于 $100\%$ 的数据，$2 \le n \le 1000$，$1 \le m \le 5000$，$1 \le p,q \le n$。

## 样例 #1

### 输入

```
6
4
E 1 4
F 3 5
F 4 6
E 1 2```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕并查集算法解决“团伙”问题，核心是处理朋友和敌人关系以计算最大团伙数。多数题解利用并查集维护朋友关系，对于敌人关系，有使用反集、记录敌人信息再合并等方法。

### 所选题解
- **作者：x义x（5星）**
    - **关键亮点**：思路清晰，代码注释详细，适合萌新理解。通过`enm`数组记录每个人的第一个敌人，再遇到敌人时合并这些敌人，巧妙处理“敌人的敌人是朋友”这一条件。
    - **个人心得**：作者提到以前学pascal的后遗症，将循环条件的“==”打成“=”，调了一小时才发现，提醒大家出错时优先检查循环条件。
    - **核心代码**：
```cpp
int find(int x) {
    while(f[x]!=x) x=f[x];
    return x;
}
void hebing(int x,int y) {
    x=find(x);y=find(y);
    if(x==y) return;
    f[y]=x;
    return;
}
//...
if(c=='F') hebing(p,q);
else {
    if(enm[p]==0) enm[p]=find(q);
    else hebing(q,enm[p]);
    if(enm[q]==0) enm[q]=find(p);
    else hebing(p,enm[q]);
}
```
- **作者：铃宕（5星）**
    - **关键亮点**：引入反集概念，清晰解释如何利用反集处理敌人关系，代码简洁高效。
    - **核心代码**：
```cpp
int find(int x){
    if(f[x]!=x)f[x]=find(f[x]);
    return f[x];
}
//...
if(ch=='F'){
    f[find(a)]=find(b);
}else{
    f[find(a+n)]=find(b);
    f[find(b+n)]=find(a);
}
```
- **作者：Ajwallet（4星）**
    - **关键亮点**：将本题与“食物链”题目对比，指出本质相同且难度更低，代码结构清晰，自定义并查集结构体方便使用。
    - **核心代码**：
```cpp
struct BCJ{
    void start(int x) {r(i,1,x) f[i]=i;}
    int find(int x) {return x==f[x]?x:f[x]=find(f[x]);}
    void judge(int a,int b) {f[find(a)]=find(b);}
    bool too(int a,int b) {return find(a)==find(b);}
}acs;
//...
if(c=='E') {
    acs.judge(b+n,a);
    acs.judge(a+n,b);
} else {
    acs.judge(a,b);
}
```

### 最优关键思路或技巧
- **反集思想**：通过将数组开成两倍，用`a+n`表示`a`的敌人，巧妙处理“敌人的敌人是朋友”的关系，避免复杂的敌人关系合并操作。
- **记录敌人信息**：使用数组记录每个人的第一个敌人，后续遇到新敌人时合并这些敌人，减少不必要的合并操作。

### 可拓展之处
同类型题目可拓展到更复杂的关系网络，如多类关系（朋友、敌人、中立），或加入动态关系变化（如关系随时间改变）。类似算法套路可用于社交网络分析、图的连通性问题等。

### 推荐题目
- P1196 [NOI2002] 银河英雄传说：并查集维护集合关系，同时需要记录额外信息。
- P1525 [NOIP2010 提高组] 关押罪犯：并查集处理矛盾关系，通过反集思想解决问题。
- P2024 [NOI2001] 食物链：并查集处理多类关系，难度稍高。

### 个人心得总结
- **x义x**：调代码时优先检查循环条件，避免因符号错误浪费大量时间。
- **C6H2CH3_NO2_3**：使用`getchar`读取字符时可能会读取到多余字符，可自定义函数过滤。

---
处理用时：28.70秒
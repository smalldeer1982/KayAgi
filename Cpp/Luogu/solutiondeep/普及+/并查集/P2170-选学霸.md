# 题目信息

# 选学霸

## 题目描述

老师想从 $n$ 名学生中选 $m$ 人当学霸，但有 $k$ 对人实力相当，如果实力相当的人中，一部分被选上，另一部分没有，同学们就会抗议。所以老师想请你帮他求出他该选多少学霸，才能既不让同学们抗议，又与原来的 $m$ 尽可能接近。

## 说明/提示

对于 $100\%$ 的数据，满足 $1 \le n,m \le 2 \times 10^4$。

## 样例 #1

### 输入

```
4 3 2
1 2
3 4```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先使用并查集将实力相当的学生合并成一个集合，统计每个集合的人数，再将每个集合看作一个物品，使用背包问题的思路来找出与目标人数 `m` 最接近的选择方案。

- **思路**：并查集用于处理学生之间的实力相当关系，将其合并为集合；背包问题用于从这些集合中选择合适的组合，使得总人数与 `m` 最接近。
- **算法要点**：并查集的路径压缩优化查找效率；背包问题的状态转移方程根据不同的实现方式有所差异，但都是在考虑选或不选某个集合。
- **解决难点**：处理实力相当的学生必须同时选择的条件；在众多组合中找到与 `m` 最接近的人数。

### 所选题解
- **作者：望眼浮云 (赞：38)，4星**
    - **关键亮点**：思路清晰，代码简洁，详细注释了并查集和背包问题的实现过程。
    - **核心代码**：
```cpp
int find(int u)
{
    if(f[u]==u) return u;
    else return f[u]=find(f[u]);
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(i=1;i<=n;i++)
        f[i]=i,p[i]=1; 
    for(i=1;i<=k;i++)
    {
        scanf("%d%d",&x,&y);
        int u=find(x);int v=find(y); 
        if(u!=v) f[u]=v,p[v]+=p[u];  
    }
    for(i=1;i<=n;i++) 
        if(f[i]==i)
        {
            tot++;
            s[tot]=p[i];
        }
    for(i=1;i<=tot;i++) 
        for(j=2*m;j>=s[i];j--)
            dp[j]=max(dp[j],dp[j-s[i]]+s[i]);
    int ans=999999999,minn=999999999;
    for(i=1;i<=2*m;i++)	
        if(minn>abs(dp[i]-m)) minn=abs(dp[i]-m),ans=dp[i];
    if(ans==999999999) printf("0");
    else	printf("%d",ans);
    return 0;
}
```
    - **核心实现思想**：先使用并查集合并实力相当的学生，统计每个集合的人数；再使用背包问题的思路，从这些集合中选择合适的组合，最后找出与 `m` 最接近的人数。

- **作者：Sino_E (赞：11)，4星**
    - **关键亮点**：使用滚动数组优化空间复杂度，对多个重量相同的物件进行二进制分解优化时间复杂度。
    - **核心代码**：
```cpp
inline int Find(int x){
    if(!fa[x]) return x;
    return fa[x]=Find(fa[x]);
}
inline bool Union(int a,int b){
    int af=Find(a),bf=Find(b);
    if(af==bf) return false;
    siz[bf]+=siz[af];
    fa[af]=bf;
    return true;
}
int main(){
    ios::sync_with_stdio(false);
    int n,m,k;
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++) siz[i]=1;
    int u,v;
    for(int i=0;i<k;i++){
        cin>>u>>v;
        Union(u,v);
    }
    for(int i=1;i<=n;i++)
        if(!fa[i]){
            prew[siz[i]]++;
        }
    int pl=1;
    for(int i=1;i<=n;i++){
        pl=1;
        while(prew[i]){
            if(prew[i]&1) w[++p]=pl*i;
            pl<<=1,prew[i]>>=1;
        }
    } 
    int ans=0x3f3f3f3f,nans=0x3f3f3f3f;
    f[0]=1;
    for(int i=1;i<=p;i++)
        for(int j=n;j>=0;j--){
            if(j>=w[i]) f[j]|=f[j-w[i]];
        } 
    for(int i=0;i<=m+nans;i++)
        if(f[i] && abs(m-i)<nans) ans=i,nans=abs(m-i); 
    printf("%d\n",ans);
    return 0;
}
```
    - **核心实现思想**：先使用并查集合并实力相当的学生，统计每个集合的人数；对多个重量相同的物件进行二进制分解；使用滚动数组进行可行性 `dp`；最后枚举答案找出与 `m` 最接近的人数。

- **作者：彼岸归航 (赞：10)，4星**
    - **关键亮点**：详细说明了并查集、统计、背包和求解四个部分的实现过程，思路清晰。
    - **核心代码**：
```cpp
int find(int x)
{
    if(f[x]==x) return f[x];
    f[x]=find(f[x]);
    return f[x];
}
void merge(int x,int y)
{
    f[find(x)]=f[find(y)];
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++) f[i]=i;
    for(int i=1;i<=k;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if(find(x)!=find(y)) merge(x,y);
    }
    for(int i=1;i<=n;i++) f[i]=find(f[i]);
    for(int i=1;i<=n;i++) t[f[i]]++;
    for(int i=1;i<=n;i++)
    {
        if(t[i])
        {
            a[++cnt]=t[i];
        }
    }
    u[0]=1;
    for(int i=1;i<=cnt;i++)
    {
        for(int j=n-a[i];j>=0;j--)
        {
            if(u[j]) u[j+a[i]]=1;
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(u[i]&&abs(ans-m)>abs(i-m)) ans=i;
    }
    printf("%d",ans);
    return 0;
}
```
    - **核心实现思想**：先使用并查集合并实力相当的学生，更新 `f` 数组；统计每个集合的人数；使用背包问题的思路找出所有可能的组合；最后找出与 `m` 最接近的人数。

### 最优关键思路或技巧
- **并查集路径压缩**：在查找根节点时，将节点直接连接到根节点，减少后续查找的时间复杂度。
- **背包问题优化**：使用滚动数组优化空间复杂度，对多个重量相同的物件进行二进制分解优化时间复杂度。
- **二进制优化**：将多个相同重量的物件转化为多个不同重量的物件，减少背包问题的状态转移次数。

### 可拓展之处
同类型题或类似算法套路：
- 处理具有捆绑关系的选择问题，如物品必须一起选择或不选择。
- 结合并查集和动态规划解决组合优化问题。

### 推荐题目
- [P1455 搭配购买](https://www.luogu.com.cn/problem/P1455)：同样是并查集和背包问题的结合，处理物品的捆绑关系。
- [P2014 选课](https://www.luogu.com.cn/problem/P2014)：树形背包问题，需要先构建树结构，再进行动态规划。
- [P1855 榨取kkksc03](https://www.luogu.com.cn/problem/P1855)：二维费用的背包问题，需要同时考虑两个费用的限制。

### 个人心得摘录与总结
- **作者：Miri**：调试时容易出现手残打错变量名的问题，需要仔细检查代码。
- **作者：Lucaster_**：在枚举容量时，要从 `2 * m` 开始，否则可能得不到正确结果，但原因未明确。这些心得提醒我们在实现代码时要注意细节，遇到问题要仔细排查。

---
处理用时：50.40秒
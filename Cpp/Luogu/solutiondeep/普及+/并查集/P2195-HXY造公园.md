# 题目信息

# HXY造公园

## 题目描述

现在有一个现成的公园，有 $n$ 个休息点和 $m$ 条双向边连接两个休息点。众所周知，HXY 是一个 SXBK 的强迫症患者，所以她打算施展魔法来改造公园并即时了解改造情况。她可以进行以下两种操作：

1. 对某个休息点 $x$，查询公园中可以与该点互相到达的休息点组成的路径中的最长路径。
2. 对于两个休息点 $x,y$，如果 $x,y$ 已经可以互相到达则忽略此次操作。否则，在 $x$ 可到达的所有休息点和 $y$ 可到达的所有休息点（包括 $x,y$ 自身）分别选择一个休息点，然后在这两个休息点之间连一条边，并且这个选择应该满足对于连接后的公园，$x$ 和 $y$ 所在的区域（即 $x,y$ 可达到的所有休息点和边组成的集合）中的最长路径的长度最小。

HXY打算进行 $q$ 个操作，请你回答她的对于公园情况的询问（操作 1）或者执行她的操作（操作 2）。

注：所有边的长度皆为 $1$。保证不存在环。最长路径定义为：对于点 $v_1,v_2\cdots v_k$，如果对于其中任意的 $v_i$ 和 $v_{i+1}\quad (1\le i\le k-1)$，都有边相连接，那么 $v_j\quad(1\le j\le k)$ 所在区域的最长路径就是 $k-1$。


## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据，只存在操作 1。
- 对于 $30\%$ 的数据，$1\le m<n\le 20$，$1\le q\le5$。
- 对于 $60\%$ 的数据，$1\le m<n \le 2000$，$1\le q\le 1000$。
- 对于 $100\%$ 的数据，$1 \le m<n \le 3\times 10^5$，$1\le q\le 3\times 10^5$。


## 样例 #1

### 输入

```
6 0 6
2 1 2
2 3 4
2 5 6
2 3 2
2 5 3
1 1```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是结合并查集和树的直径算法来解决问题。首先利用并查集维护节点的连通性，然后通过不同方法（如树形 DP、两次 DFS 或 BFS）求出每棵树的直径。对于操作 1，直接查询点所在树的直径；对于操作 2，合并两棵树时，选择在直径中点连边以保证新树直径最小，新树直径为 `max{树 1 直径, 树 2 直径, ⌈树 1 直径 / 2⌉ + ⌈树 2 直径 / 2⌉ + 1}`。

### 所选题解
- **作者：Priori_Incantatem (赞：31)  ★★★★**
    - **关键亮点**：思路清晰，对合并树时直径计算的原理有详细解释，并配有示例图，代码注释丰富，可读性强。
    - **个人心得**：提到不考虑原来两棵树的直径会只有 30 分，强调了合并时要考虑原树直径的重要性。
- **作者：caozy623 (赞：16)  ★★★★**
    - **关键亮点**：对涉及的知识点和难点有清晰阐述，用 BFS 求树的直径，逻辑明确。
- **作者：noall (赞：13)  ★★★★**
    - **关键亮点**：给出了自己的调试历程，提醒不要用 `memset` 初始化 `vis` 数组，避免 TLE，思路和代码都比较清晰。
    - **个人心得**：分享了用 `memset` 初始化 `vis` 数组导致 TLE 的惨痛教训。

### 重点代码
#### 树形 DP 求树的直径（Priori_Incantatem）
```cpp
void dfs(int x,int fa) // 树形DP求树的直径
{
    int m1=-1,m2=-1;
    for(int i=0;i<e[x].size();++i)
    {
        int y=e[x][i];
        if(y==fa)continue;
        dfs(y,x);
        int tmp=d[y]+1;
        d[x]=max(d[x],tmp);
        if(tmp>m1)m2=m1,m1=tmp;
        else if(tmp>m2)m2=tmp;
    }
    g[x]=max(max(0,m1+m2),max(m1,m2));
    len=max(len,g[x]);
}
```
**核心思想**：通过递归遍历节点，记录每个节点延伸出去的最长和次长路径，用两者之和更新树的直径。

#### 两次 BFS 求树的直径（caozy623）
```cpp
int find(int x)
{
    d[x]=0;
    flag[x]=x;
    q[q[0]=1]=x;
    int yuan=x;
    for(int i=1;i<=q[0];i++)
    {
        int y=q[i];
        for(int u=head[y];u;u=e[u].next)
        if(flag[e[u].to]!=x)
        {
            flag[e[u].to]=x;
            q[++q[0]]=e[u].to;
            d[e[u].to]=d[y]+1;
            if(d[e[u].to]>d[yuan])   
            yuan=e[u].to;
        }
    }
    int y2=yuan;
    d[yuan]=0;
    q[q[0]=1]=yuan;
    flag[yuan]=yuan;
    for(int i=1;i<=q[0];i++)
    {
        int y=q[i];
        for(int u=head[y];u;u=e[u].next)
        if(flag[e[u].to]!=yuan)
        {
            flag[e[u].to]=yuan;
            q[++q[0]]=e[u].to;
            d[e[u].to]=d[y]+1;
            if(d[e[u].to]>d[y2])
            y2=e[u].to;
        }
    }
    return d[y2];
}
```
**核心思想**：先从一个点出发，找到最远点 `yuan`，再从 `yuan` 出发，找到最远点 `y2`，`yuan` 到 `y2` 的距离即为树的直径。

#### 两次 DFS 求树的直径（noall）
```cpp
in void dfs(int x,int val){
    if(maxx<val) maxx=val,st=x;
    for(int i=head[x];i;i=map[i].next){
        int y=map[i].to;
        if(!vis[y]){
            vis[y]=true;
            dfs(y,val+1);
        }
    }
    vis[x]=false;//TLE的惨痛教训
}

in void dfs2(int x,int val){
    if(maxx<val) maxx=val;
    for(int i=head[x];i;i=map[i].next){
        int y=map[i].to;
        if(!vis[y]){
            vis[y]=true;
            dfs2(y,val+1);
        }
    }
    vis[x]=false;//TLE的惨痛教训
}
```
**核心思想**：与两次 BFS 类似，先找到一个最远点，再从该点出发找到另一个最远点，两点间距离为树的直径。

### 最优关键思路或技巧
- **并查集**：用于维护节点的连通性，方便判断两点是否在同一棵树中，并进行树的合并操作。
- **树的直径算法**：树形 DP、两次 DFS 或 BFS 可以高效求出树的直径。
- **合并树的策略**：选择在直径中点连边，使新树直径最小，新树直径的计算要考虑原树直径。

### 拓展思路
同类型题或类似算法套路：
- 涉及图的连通性维护和路径长度计算的问题，如最小生成树的扩展问题。
- 动态图的连通性和路径查询问题，可结合并查集和图的遍历算法。

### 推荐题目
- [P1196 银河英雄传说](https://www.luogu.com.cn/problem/P1196)：考察并查集的应用，涉及节点间距离的维护。
- [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)：并查集的拓展应用，解决二分图染色问题。
- [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)：并查集的基础模板题，可用于巩固并查集的实现。

---
处理用时：38.41秒
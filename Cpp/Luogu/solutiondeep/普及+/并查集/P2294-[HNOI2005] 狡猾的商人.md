# 题目信息

# [HNOI2005] 狡猾的商人

## 题目描述

刁姹接到一个任务，为税务部门调查一位商人的账本，看看账本是不是伪造的。账本上记录了 $n$ 个月以来的收入情况，其中第 $i$ 个月的收入额为 $a_i$，$i=1,2,\ldots,n-1,n$。当 $a_i>0$ 时表示这个月盈利 $a_i$ 元，当 $a_i<0$ 时表示这个月亏损 $|a_i|$ 元。所谓一段时间内的总收入，就是这段时间内每个月的收入额的总和。

刁姹的任务是秘密进行的，为了调查商人的账本，她只好跑到商人那里打工。她趁商人不在时去偷看账本，可是她无法将账本偷出来，每次偷看账本时她都只能看某段时间内账本上记录的收入情况，并且她只能记住这段时间内的总收入。

现在，姹总共偷看了 $m$ 次账本，当然也就记住了 $m$ 段时间内的总收入，你的任务是根据记住的这些信息来判断账本是不是假的。


## 样例 #1

### 输入

```
2
3 3
1 2 10
1 3 -5
3 3 -15
5 3
1 5 100
3 5 50
1 2 51
```

### 输出

```
true
false
```

# AI分析结果

### 综合分析与结论
这些题解提供了多种解决“狡猾的商人”问题的思路，涵盖贪心、并查集、差分约束、区间 DP、高斯消元等多种算法。贪心算法通过优先队列对区间进行比较和合并；并查集算法利用前缀和思想维护区间关系；差分约束算法将问题转化为图论问题，通过判断图中是否有环来确定账本真假；区间 DP 则从小区间到大区间逐步推导；高斯消元通过建立方程求解判断是否有解。

### 所选题解
- **作者：66666a（4星）**
  - **关键亮点**：思路清晰，利用并查集维护区间关系，代码简洁易懂。通过前缀和思想将区间和问题转化为并查集可处理的形式，在合并和查找过程中维护差值，判断账本是否造假。
  - **个人心得**：无
- **作者：brealid（4星）**
  - **关键亮点**：详细阐述差分约束的思路，对不等式的转化和图的构建解释清晰。考虑到图可能不连通，引入超级源点解决问题，代码实现规范。
  - **个人心得**：提交时 WA，原因是图不一定联通，需要建立超级源点，节点编号最小是 0，所以超级源点不能是 0，但可以是 n + 1。
- **作者：pengym（4星）**
  - **关键亮点**：提出贪心策略，运用优先队列实现，思路独特。通过对区间的排序、比较和合并来判断账本真假，有一定的创新性。
  - **个人心得**：看到大牛用差分约束或带权并查集，自己想出贪心策略，作为蒟蒻在洛谷的第一篇博客，有点小激动。

### 重点代码
#### 作者：66666a
```cpp
int fa[105],cha[105];  
int find(int x)
{  
    if(x!=fa[x])
    {
        int t=find(fa[x]);
        cha[x]+=cha[fa[x]];
        fa[x]=t;  
    }  
    return fa[x];  
}  
int main()  
{  
    int T,n,m,i,x,y,z,flag;  
    scanf("%d",&T);  
    while (T--) 
    {  
        flag=0;  
        scanf("%d%d",&n,&m);  
        for(i=0;i<=n;i++)
        {  
            fa[i]=i;  
            cha[i]=0;  
        }  
        for(i=1;i<=m;i++)  
        {  
            scanf("%d%d%d",&x,&y,&z);  
            x--;  
            if(find(x)!=find(y))  
            {  
                cha[fa[y]]=cha[x]-cha[y]-z;  
                fa[fa[y]]=fa[x];
            }  
            else  
            if(cha[x]-cha[y]!=z) flag=1;  
        }  
        if(flag==0) printf("true\n"); else printf("false\n");  
    }  
    return 0;  
}
```
**核心实现思想**：使用并查集维护区间关系，`find` 函数进行路径压缩并更新差值，在合并和查找过程中判断区间和是否矛盾。

#### 作者：brealid
```cpp
struct Edge {
    int to, v;
};
#define make_edge(u, v) ((Edge){(u), (v)})
vector<Edge> G[5007];
int n, m;
int dis[5007];
bool inq[5007];
int vis[5007];

int once()
{
    // [read data]
    n = read<int>();
    m = read<int>();
    for (int i = 0; i <= n + 1; i++) G[i].clear();
    for (int i = 1, u, v, w; i <= m; i++) {
        u = read<int>();
        v = read<int>();
        w = read<int>();
        G[u - 1].push_back(make_edge(v, w)); 
        G[v].push_back(make_edge(u - 1, -w)); 
    }
    for (int i = 0; i <= n; i++)
        G[n + 1].push_back(make_edge(i, 0));
    // [/read data] 
    // [spfa]
    queue<int> q;
    q.push(n + 1);
    memset(dis, 0xcf, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    memset(inq, 0, sizeof(inq));
    dis[n + 1] = 0;
    while (!q.empty()) {
        int fr = q.front(); 
        q.pop();
        inq[fr] = 0;
        for (unsigned i = 0; i < G[fr].size(); i++) {
            if (dis[G[fr][i].to] < dis[fr] + G[fr][i].v) {
                dis[G[fr][i].to] = dis[fr] + G[fr][i].v;
                if (!inq[G[fr][i].to]) {
                    vis[G[fr][i].to]++;
                    if (vis[G[fr][i].to] > n) {
                        puts("false");
                        return 0;
                    }
                    inq[G[fr][i].to] = true;
                    q.push(G[fr][i].to);
                }
            }
        }
    }
    // [/spfa]
    puts("true");
    return 0;
}
```
**核心实现思想**：将问题转化为差分约束问题，通过建图和 SPFA 算法判断图中是否有正环，若有则账本为假，否则为真。

#### 作者：pengym
```cpp
struct node
{
    int l,r,s;
    bool operator < (const node &h)const
    {
        if(l!=h.l)return l>h.l;
        return r>h.r;
    }
};
priority_queue<node>q;
int main()
{
    int t;
    read(t);
    while(t--)
    {    
        while (!q.empty()) q.pop();
        read(n);read(m);
        if(m==1){printf("true\n");continue;}
        for(int i=1;i<=m;i++)
        {
            int l,r,s;
            read(tmp.l);read(tmp.r);read(tmp.s);
            q.push(tmp);
        }
        tmp=q.top();
        q.pop();
        while(!q.empty())
        {    
            node tmp1;
            tmp1=q.top();
            q.pop();
            if(tmp.l==tmp1.l)
            {
                if(tmp.r==tmp1.r)
                {
                    if(tmp.s!=tmp1.s)
                    {printf("false\n");goto end;}
                }
                else 
                if(tmp.r<tmp1.r)
                    q.push((node) {tmp.r+1, tmp1.r, tmp1.s - tmp.s});
            }
            tmp = tmp1;
        }
        printf("true\n");
        end:;
    }
    return 0;
}
```
**核心实现思想**：对区间按左端点和右端点排序，使用优先队列存储区间。两两比较区间，若左端点和右端点都相等但和不同则账本为假，否则合并区间继续比较。

### 最优关键思路或技巧
- **前缀和思想**：将区间和问题转化为前缀和的差值，方便用并查集、差分约束等算法处理。
- **图论建模**：将问题转化为图论问题，通过判断图中是否有环来确定账本真假，如差分约束算法。
- **数据结构优化**：使用优先队列、并查集等数据结构优化算法复杂度。

### 可拓展之处
同类型题或类似算法套路：
- 区间和问题：可拓展到更多区间关系的判断，如区间包含、相交等。
- 图论问题：可拓展到更复杂的图结构，如带权有向图、无向图等。
- 约束满足问题：可拓展到更多约束条件的判断，如不等式约束、等式约束等。

### 推荐题目
- P1993 小 K 的农场：差分约束系统的经典应用。
- P1196 [NOI2002] 银河英雄传说：并查集维护区间关系的问题。
- P3275 [SCOI2011] 糖果：差分约束系统的变形应用。

### 个人心得总结
- brealid 提交时遇到 WA，原因是图不一定联通，需要建立超级源点，提醒我们在图论问题中要考虑图的连通性。
- pengym 作为蒟蒻想出贪心策略，鼓励我们在面对问题时勇于尝试不同的思路。

---
处理用时：54.26秒
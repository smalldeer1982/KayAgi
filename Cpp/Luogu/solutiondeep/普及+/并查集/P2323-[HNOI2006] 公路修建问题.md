# 题目信息

# [HNOI2006] 公路修建问题

## 题目描述

OI island 是一个非常漂亮的岛屿，自开发以来，到这儿来旅游的人很多。然而，由于该岛屿刚刚开发不久，所以那里的交通情况还是很糟糕。所以，OIER Association 组织成立了，旨在建立 OI island 的交通系统。

OI island 有 $n$ 个旅游景点，不妨将它们从 $1$ 到 $n$ 标号。现在，OIER Association 需要修公路将这些景点连接起来。一条公路连接两个景点。公路有，不妨称它们为一级公路和二级公路。一级公路上的车速快，但是修路的花费要大一些。

OIER Association 打算修 $n-1$ 条公路将这些景点连接起来（使得任意两个景点之间都会有一条路径）。为了保证公路系统的效率， OIER Association 希望在这 $n-1$ 条公路之中，至少有 $k$ 条 $(0 \le k \le n-1)$ 一级公路。OIER Association 也不希望为一条公路花费的钱。所以，他们希望在满足上述条件的情况下，花费最多的一条公路的花费尽可能的少。

而你的任务就是，在给定一些可能修建的公路的情况下，选择 $n-1$ 条公路，满足上面的条件。

## 样例 #1

### 输入

```
4 2 5 
1 2 6 5
1 3 3 1
2 3 9 4
2 4 6 1```

### 输出

```
6 
1 1 
2 1 
4 1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕公路修建问题展开，目标是在满足至少有 $k$ 条一级公路的条件下，选择 $n - 1$ 条公路使花费最多的公路花费尽可能少。题解的主要思路分为 Kruskal 算法和二分答案两种。

Kruskal 算法思路是先按一级公路花费排序，选取 $k$ 条一级公路，再按二级公路花费排序，选取剩余的 $n - 1 - k$ 条公路。二分答案思路是二分最大花费，在每次所需费用不超过该值的情况下，优先选择一级公路，若未达到 $n - 1$ 条则用二级公路补充，判断是否满足条件。

### 所选题解
- **作者：pengyule（4星）**
    - **关键亮点**：思路清晰，分别给出了 Kruskal 和二分答案两种解法，并分析了复杂度。代码结构清晰，注释详细。
    - **核心代码**：
```cpp
// Kruskal 部分
sort(a + 1, a + m1 + 1, cmp_);
int y = n - 1 - k, i;
for (i = 1; i <= m1 && k; i++) {
    if (find(a[i].u) != find(a[i].v)) {
        unite(a[i].u, a[i].v);
        ans = max(ans, a[i].tt);
        k--;
        a[i].choo = 1;
        o.push_back(a[i]);
    }
}
sort(a + i, a + m1 + 1, cmp);
for (; i <= m1; i++) {
    if (find(a[i].u) != find(a[i].v)) {
        unite(a[i].u, a[i].v);
        ans = max(ans, a[i].w);
        a[i].choo = 2;
        o.push_back(a[i]);
    }
}

// 二分答案部分
bool check(int pp) {
    int cnt = 0, ss = 0;
    for (int i = 1; i <= n; i++) fa[i] = i;
    memset(vis, 0, sizeof(vis));
    for (int i = 1; i <= m1; i++) {
        if (find(a[i].u) != find(a[i].v)) {
            if (a[i].w1 <= pp) {
                vis[i] = 1;
                cnt++;
                ss++;
                unite(a[i].u, a[i].v);
            }
        }
    }
    for (int i = 1; i <= m1; i++) {
        if (find(a[i].u) != find(a[i].v)) {
            if (a[i].w2 <= pp) {
                vis[i] = 2;
                unite(a[i].u, a[i].v);
                ss++;
            }
        }
    }
    if (cnt >= k && ss >= n - 1) {
        for (int i = 1; i <= m1; i++) ans[i] = vis[i];
        return true;
    }
    else return false;
}
```
- **作者：一扶苏一（4星）**
    - **关键亮点**：不仅给出了二分答案和优化后的 Kruskal 两种解法，还对复杂度进行了分析和优化。代码实现规范，使用了快读快写优化输入输出。
    - **核心代码**：
```cpp
// 二分答案部分
bool check(int x, bool rec) {
    for (int i = 1; i <= n; ++i) ufs[i] = i, rk[i] = 1;
    int cnt = 0;
    for (int i = 1; i < m; ++i) if (expen[i].v <= x) {
        int fa = find(expen[i].from), fb = find(expen[i].to);
        if (fa == fb) continue;
        unionn(fa, fb);
        if (rec) MU.push_back(std::make_pair(expen[i].id, 1));
        ++cnt;
    }
    if (cnt < k) return false;
    for (int i = 1; i < m; ++i) if (com[i].v <= x) {
        int fa = find(com[i].from), fb = find(com[i].to);
        if (fa == fb) continue;
        unionn(fa, fb);
        if (rec) MU.push_back(std::make_pair(com[i].id, 2));
        ++cnt;
        if (cnt == dn) return true;
    }
    return cnt == dn;
}

// 优化后的 Kruskal 部分
std::sort(expen + 1, expen + m);
int cnt = 0;
for (int i = 1; i <= n; ++i) ufs[i] = i, rk[i] = 1;
for (int i = 1; i < m; ++i) {
    int fa = find(expen[i].from), fb = find(expen[i].to);
    if (fa == fb) {
        edge[++ecnt] = expen[i];
    } else {
        unionn(fa, fb);
        maxans = expen[i].v;
        ans.push_back(std::make_pair(expen[i].id, 1));
        if ((++cnt) == k) break;
    }
} 
std::sort(edge + 1, edge + 1 + ecnt);
for (int i = 1; cnt !=  dn; ++i) {
    int fa = find(edge[i].from), fb = find(edge[i].to);
    if (fa == fb) continue;
    unionn(fa, fb);
    maxans = std::max(maxans, edge[i].v);
    ans.push_back(std::make_pair(edge[i].id, edge[i].tp));
    ++cnt;
}
```
- **作者：DOTime（4星）**
    - **关键亮点**：提出了贪心的思路，避免了二分，降低了复杂度。代码逻辑清晰，注释详细。
    - **核心代码**：
```cpp
sort(edge + 1, edge + m + 1, comp);
int tot = 1;
for (now = 1; now <= m; now++) {
    if (tot > k) break;
    if (find(edge[now].from) != find(edge[now].to)) {
        tot++;
        Union(edge[now].from, edge[now].to);
        way[++top].id = edge[now].id;
        way[top].lv = 1;
    }
}
ans = max(ans, edge[now - 1].c1);
sort(edge + now, edge + m + 1, cmp);
for (int i = now; i <= m; i++) {
    if (TOT == 1) break;
    if (find(edge[i].from) != find(edge[i].to)) {
        ans = max(ans, min(edge[i].c1, edge[i].c2));
        Union(edge[i].from, edge[i].to);
        way[++top].id = edge[i].id;
        if (edge[i].c1 < edge[i].c2)
            way[top].lv = 1;
        else
            way[top].lv = 2;
    }
}
```

### 最优关键思路或技巧
- **Kruskal 算法**：利用 Kruskal 算法构建最小生成树，先按一级公路花费排序选取 $k$ 条，再按二级公路花费排序选取剩余公路，保证了在满足条件下的最小花费。
- **二分答案**：通过二分最大花费，不断缩小范围，在每次所需费用不超过该值的情况下，优先选择一级公路，再用二级公路补充，判断是否满足条件，最终找到最小的最大花费。
- **贪心思想**：在选择公路时，优先选择花费小的公路，避免了不必要的计算，降低了复杂度。

### 可拓展之处
同类型题或类似算法套路：
- **最小生成树变种**：如边有多种属性，需要在满足一定条件下构建最小生成树。
- **二分答案应用**：对于有单调性质的问题，可以通过二分答案来缩小范围，提高效率。

### 推荐洛谷题目
1. [P1111 修复公路](https://www.luogu.com.cn/problem/P1111)：涉及图的连通性和最小生成树相关知识。
2. [P1396 营救](https://www.luogu.com.cn/problem/P1396)：与图的路径和最小生成树有关。
3. [P2330 [SCOI2005]繁忙的都市](https://www.luogu.com.cn/problem/P2330)：考察最小生成树的应用。

### 个人心得摘录与总结
- **作者：旅人杜**：提到题目测试数据存在问题，原题目要求（二分答案）未在测试数据中体现，还指出没有要求建造公路的总费用最小，Kruskal 求最小生成树的一个特性被忽略。并给出了如果题目不水该如何合理 AC 的思路。
- **作者：Cris**：一开始不明白直接用 Kruskal 做这道题为什么是对的，后来学习了 Kruskal 的证明，明白了其正确性。总结是要深入理解算法的原理，才能更好地应用。 

---
处理用时：50.15秒
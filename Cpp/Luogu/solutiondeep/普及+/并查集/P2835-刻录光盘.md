# 题目信息

# 刻录光盘

## 题目描述

在JSOI2005夏令营快要结束的时候，很多营员提出来要把整个夏令营期间的资料刻录成一张光盘给大家，以便大家回去后继续学习。组委会觉得这个主意不错！可是组委会一时没有足够的空光盘，没法保证每个人都能拿到刻录上资料的光盘，又来不及去买了，怎么办呢？！

组委会把这个难题交给了LHC，LHC分析了一下所有营员的地域关系，发现有些营员是一个城市的，其实他们只需要一张就可以了，因为一个人拿到光盘后，其他人可以带着U盘之类的东西去拷贝啊！

可是，LHC调查后发现，由于种种原因，有些营员并不是那么的合作，他们愿意某一些人到他那儿拷贝资料，当然也可能不愿意让另外一些人到他那儿拷贝资料，这与我们JSOI宣扬的团队合作精神格格不入！！！

现在假设总共有N个营员（2<=N<=200），每个营员的编号为1~N。LHC给每个人发了一张调查表，让每个营员填上自己愿意让哪些人到他那儿拷贝资料。当然，如果A愿意把资料拷贝给B，而B又愿意把资料拷贝给C，则一旦A获得了资料，则B，C都会获得资料。

现在，请你编写一个程序，根据回收上来的调查表，帮助LHC计算出组委会至少要刻录多少张光盘，才能保证所有营员回去后都能得到夏令营资料？


## 样例 #1

### 输入

```
5
2 3 4 0
4 5 0
0
0
1 0```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
本题主要是求在有向图中，保证所有节点都能获得资料所需的最少光盘数，可转化为求图中入度为 0 的强连通分量个数。各位作者采用了多种算法来解决此问题，主要包括 Tarjan 算法、Floyd 算法、并查集、DFS 等。

Tarjan 算法通过深度优先搜索找出图中的强连通分量，再缩点统计入度为 0 的分量个数；Floyd 算法用于处理节点间的连通性，结合并查集判断连通块数量；DFS 则通过递归搜索标记可达节点。

### 所选题解
- **作者：PrincessYR✨～ (赞：160)，4 星**
    - **关键亮点**：详细介绍了强连通分量和 Tarjan 算法的概念，通过图文结合的方式逐步讲解 Tarjan 算法的执行过程，思路清晰，代码注释详细。
    - **个人心得**：作者提到自己学习强连通分量和缩点花了好几天时间，可见该算法有一定难度，需要耐心学习。
- **作者：LMB_001 (赞：99)，4 星**
    - **关键亮点**：使用 Floyd 算法结合并查集的思路解决问题，代码简洁，注释清晰，对于刚接触 C++ 的人来说容易理解。
    - **个人心得**：作者从 Pascal 转 C++ 刚一个星期，将 Pascal 的基础代入 C++ 进行解题，鼓励大家思考和尝试。
- **作者：elephant_ouo (赞：19)，4 星**
    - **关键亮点**：同样采用 Floyd 算法和并查集，代码结构清晰，对 Floyd 算法的变形和并查集的使用解释详细。
    - **个人心得**：无。

### 重点代码
#### PrincessYR✨～ 的 Tarjan 算法核心代码
```cpp
void tarjan(int x)
{
    dfn[x]=low[x]=++num;
    ins[x]=1;
    st.push(x);
    for(int i=0;i<map[x].size();i++)
    {
        int q=map[x][i];
        if(dfn[q]==0)
        {
            tarjan(q);
            low[x]=min(low[x],low[q]);
        }else if(ins[q]==1)
        {
            low[x]=min(low[x],dfn[q]);
        }
    }
    if(dfn[x]==low[x])
    {
        numb++;
        int p;
        do
        {
            p=st.top();
            st.pop();
            ins[p]=0;
            bl[p]=numb;
            nums[numb]++;
        }while(x!=p);
    }
}
```
**核心实现思想**：通过深度优先搜索遍历图，使用 `dfn` 数组记录节点的访问顺序，`low` 数组记录节点或其子树能追溯到的最早节点的次序号。当 `dfn[x] == low[x]` 时，说明找到了一个强连通分量。

#### LMB_001 的 Floyd 算法结合并查集核心代码
```cpp
for(k=1;k<=n;k++)  
    for(i=1;i<=n;i++)  
        for(j=1;j<=n;j++)  
            if(mapk[i][k]&&mapk[k][j])  
                mapk[i][j]=1;
for(i=1;i<=n;i++)  
    f[i]=i;
for(i=1;i<=n;i++)  
    for(j=1;j<=n;j++)  
        if(mapk[i][j]) f[j]=f[i];
```
**核心实现思想**：使用 Floyd 算法处理节点间的连通性，若 `i` 能到 `k` 且 `k` 能到 `j`，则 `i` 能到 `j`。然后使用并查集，将能连通的节点合并到同一个集合中，最后统计集合的数量。

#### elephant_ouo 的 Floyd 算法结合并查集核心代码
```cpp
for(int k = 1; k <= n; k++)
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            f[i][j] = f[i][j] || f[i][k] && f[k][j];
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= n; j++)
        if(f[i][j])
            fa[j] = fa[i];
```
**核心实现思想**：与 LMB_001 的思路类似，先使用 Floyd 算法处理连通性，再使用并查集合并节点，最后统计根节点的数量。

### 最优关键思路或技巧
- **Tarjan 算法**：利用深度优先搜索和栈来找出图中的强连通分量，时间复杂度为 $O(N + M)$，是解决有向图强连通分量问题的经典算法。
- **Floyd 算法**：通过三重循环处理节点间的连通性，能快速判断任意两点是否可达，适用于节点数较少的图。
- **并查集**：用于合并和查询节点所属的集合，能有效处理连通块的问题。

### 可拓展之处
同类型题或类似算法套路：
- **求有向图的强连通分量**：可以使用 Tarjan 算法或 Kosaraju 算法。
- **求无向图的连通块数量**：可以使用并查集或深度优先搜索。
- **图的传递闭包问题**：可以使用 Floyd 算法。

### 推荐题目
- [P2341 受欢迎的牛](https://www.luogu.com.cn/problem/P2341)
- [P2002 消息扩散](https://www.luogu.com.cn/problem/P2002)
- [P2812 校园网络](https://www.luogu.org/problemnew/show/P2812)

### 个人心得总结
- PrincessYR✨～ 提到学习强连通分量和缩点需要耐心，这表明复杂算法的学习需要时间和精力。
- LMB_001 从 Pascal 转 C++ 后尝试解题，鼓励大家勇于尝试新的知识和方法。

---
处理用时：40.43秒
# 题目信息

# [USACO13FEB] Tractor S

## 题目描述

FJ有块农田太崎岖了，他要买一辆新拖拉机才能在这里巡视。这块农田由N x N个格子的非负整数表示高度(1<=N<=500)。拖拉机从当前格子走到相邻格子（东、南、西、北四个方向）的代价为高度差D，则FJ驶过这两个格子的拖拉机最少也要值D块钱。

FJ愿意花足够的钱买一辆新的拖拉机使得他能以最小的高度差走遍所有格子的一半(如果格子总数是奇数，那么一半的值为四舍五入的值)。因为FJ很懒，所以他找到你帮他编程计算他最小需要花多少钱买到符合这些要求的拖拉机。

## 样例 #1

### 输入

```
5 
0 0 0 3 3 
0 0 0 0 3 
0 9 9 3 3 
9 9 9 3 3 
9 9 9 9 3 
```

### 输出

```
3 
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕最小生成树和二分答案两种思路来解决问题。最小生成树思路通过建图、维护并查集大小，在合并集合时判断是否满足条件；二分答案思路则是二分高度差，结合 DFS 或并查集判断是否能走遍一半格子。各题解在实现细节上有所不同，但都能解决问题。

### 所选题解
- **作者：daihang (赞：46)，4星**
  - **关键亮点**：思路清晰，详细阐述了建图、维护集合大小和最小生成树的实现过程，代码可读性高。
  - **核心实现思想**：先建图，将每个点向上下左右连边，边权为高度差绝对值；再使用最小生成树 Kruskal 算法，在合并集合时更新集合大小，当集合大小大于等于一半格子数时输出当前边权。
  - **核心代码片段**：
```cpp
// 点编号函数
int ex(int i,int j){
    return (i-1)*n+j;
}
// 并查集合并操作
x=find(x);
y=find(y);
if(x!=y){
    fa[x]=y;
    siz[y]+=siz[x];
    if(siz[y]>=(n*n+1)/2){
        cout<<w<<endl;
        return 0;
    }
}
```
- **作者：JJA_ (赞：12)，4星**
  - **关键亮点**：提供了暴力 DFS 和 DFS + 二分两种方法，对二分优化的思路解释清晰。
  - **核心实现思想**：暴力 DFS 遍历所有可能的高度差，判断是否能走遍一半格子；DFS + 二分则是二分高度差，通过 DFS 判断当前高度差是否满足条件。
  - **核心代码片段**：
```cpp
// DFS 函数
int dfs(int x,int y,int d){
    int sum=1;
    flag[x][y]=1;
    for(int i=1;i<=4;i++){
        int px=x+xpos[i];
        int py=y+ypos[i]; 
        if(abs(mapp[x][y]-mapp[px][py])<=d&&px>=1&&py>=1&&px<=n&&py<=n&&!flag[px][py]){
            sum+=dfs(px,py,d);
        } 
    }
    return sum;
}
// 二分代码
while(l<=r){
    int mid=(l+r)/2;
    if(chkans(mid)==1){
        r=mid-1,ans=mid;
    }
    else{
        l=mid+1;
    }
}
```
- **作者：Rainbow_qwq (赞：5)，4星**
  - **关键亮点**：明确指出题目是最大值最小化问题，适合用二分答案解决，代码结构清晰。
  - **核心实现思想**：二分高度差，通过 DFS 判断在当前高度差下能否到达一半以上的格子。
  - **核心代码片段**：
```cpp
// DFS 函数
int dfs(int x,int y,int k)
{
    vis[x][y]=1;
    int res=1;
    For(i,0,3)
    {
        int xx=x+dx[i],yy=y+dy[i];
        if(xx>0&&yy>0&&xx<=n&&yy<=n&&!vis[xx][yy]&&abs(a[xx][yy]-a[x][y])<=k)
            res+=dfs(xx,yy,k);
    }
    return res;
}
// 二分答案 check 函数
bool check(int k)
{
    memset(vis,0,sizeof vis);
    For(i,1,n)
        For(j,1,n)
            if(!vis[i][j])
                if(dfs(i,j,k)*2>=n*n)
                    return 1;
    return 0;
}
```

### 最优关键思路或技巧
- **最小生成树思路**：将问题转化为最小生成树问题，通过建图和并查集维护集合大小，在合并集合时判断是否满足条件。
- **二分答案思路**：利用题目中最大值最小化的特点，二分高度差，结合 DFS 或并查集判断是否能走遍一半格子，降低时间复杂度。

### 可拓展之处
同类型题如求最小化最大值或最大化最小值的问题，都可以考虑使用二分答案的方法。类似算法套路包括二分答案结合搜索（DFS、BFS）或并查集来解决问题。

### 推荐题目
- [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)
- [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)
- [P3853 [TJOI2007]路标设置](https://www.luogu.com.cn/problem/P3853)

### 个人心得摘录与总结
- **作者：endless_loop**：直接使用连通块的个数小于一半判断是错误的，需要用 `size[i]` 来表示 $i$ 所在连通块的大小，在合并时更新，判断合并后的连通块是否满足大于总数的一半。总结：在处理连通块问题时，要准确判断条件，避免错误。

---
处理用时：34.03秒
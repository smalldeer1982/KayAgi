# 题目信息

# [JSOI2010] 部落划分

## 题目描述

聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。

不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了 $n$ 个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了 $k$ 个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法：

对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。

例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。


![](https://cdn.luogu.com.cn/upload/pic/30573.png)

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2 \leq k \leq n \leq 10^3$，$0 \leq  x, y \leq 10^4$。

## 样例 #1

### 输入

```
4 2
0 0
0 1
1 1
1 0
```

### 输出

```
1.00
```

## 样例 #2

### 输入

```
9 3
2 2
2 3
3 2
3 3
3 5
3 6
4 6
6 2
6 3```

### 输出

```
2.00```

# AI分析结果

### 综合分析与结论
这些题解主要围绕两种思路解决部落划分问题：最小生成树和二分答案。最小生成树思路将每个点视为一个部落，通过合并距离最近的部落，直到剩余部落数为目标值，此时下一条边的长度即为所求；二分答案思路则是通过二分枚举距离，检查该距离下能否划分出指定数量的部落。

### 所选题解
- **轻尘（5星）**
    - **关键亮点**：思路清晰，代码注释详细，对算法的解释通俗易懂。
    - **个人心得**：作者表示这道题是最小生成树的变式题，一开始被困扰了很久，体现了对题目的深入思考和攻克难题后的成就感。
- **一叶知秋。（4星）**
    - **关键亮点**：通过画图直观地解释了为什么要选第n - k + 1条边，使思路更易理解。
    - **个人心得**：无
- **I_am_Accepted（4星）**
    - **关键亮点**：使用Prim算法实现，复杂度为$O(n^2)$，并喜提最优解，提供了不同的解题视角。
    - **个人心得**：发现题解区大多是带$\log$的解法，认为自己的$O(n^2)$ Prim算法应被认可，体现了对不同算法的探索精神。

### 重点代码及核心实现思想
#### 轻尘
```cpp
// 最小生成树Kruskal算法
void kruskal()
{
    for(int i=1;i<=o;i++)
    {
        if(num==n-k) flag = 1;
        if(find(e[i].x)!=find(e[i].y))
        {
            num++;
            unionn(e[i].x,e[i].y);
            if(flag){
                printf("%.2lf",e[i].l);
                return ;
            }   
        }
    }
}
```
核心思想：不断选取最小边合并部落，当合并次数达到n - k时，下一条不同部落间的边即为答案。

#### 一叶知秋。
```cpp
while(j<n-1){
    int fu=find(e[i].u),fv=find(e[i].v);
    double dis=e[i].dis;
    if(fu!=fv){
        f[fu]=fv;
        j++;
        a[j]=dis;
    }
    i++;
}
printf("%.2lf",a[n-m+1]);
```
核心思想：使用Kruskal算法构建最小生成树，记录每条边，最后输出第n - m + 1条边的长度。

#### I_am_Accepted
```cpp
For(i,1,n){
    int x=0;
    For(j,1,n) if(!vis[j] && dis[j]<dis[x]) x=j;
    vis[x]=1;
    s[tot++]=dis[x];
    For(j,1,n) if(!vis[j]) dis[j]=min(dis[j],Dis(x,j));
}
sort(s+1,s+tot,greater<db>());
printf("%.2lf\n",s[k-1]);
```
核心思想：使用Prim算法构建最小生成树，记录每条边的权值，排序后输出第k - 1大的边权。

### 最优关键思路或技巧
- **最小生成树**：将每个点看作一个部落，通过合并最小边减少部落数量，直到达到目标部落数，此时下一条边即为答案。
- **二分答案**：利用距离的单调性，二分枚举距离，使用并查集检查该距离下的部落数量。

### 拓展思路
同类型题可考虑一些图的划分问题，如将图划分为指定数量的连通块，使连通块之间的某种距离最大。类似算法套路可用于解决一些最优化问题，通过贪心或二分的思想不断逼近最优解。

### 推荐题目
- [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195)
- [P2330 [SCOI2005]繁忙的都市](https://www.luogu.com.cn/problem/P2330)
- [P1991 无线通讯网](https://www.luogu.com.cn/problem/P1991)

### 个人心得总结
- 轻尘：认识到题目是最小生成树的变式，在解题过程中遇到困难，但最终成功解决，体现了对难题的攻克能力。
- I_am_Accepted：不局限于常见解法，尝试使用不同算法，展现了探索精神。
- 盧鋅：分享了自己在解题过程中的一些优化尝试，虽有些做法不可取，但体现了对代码优化的思考。

---
处理用时：29.55秒
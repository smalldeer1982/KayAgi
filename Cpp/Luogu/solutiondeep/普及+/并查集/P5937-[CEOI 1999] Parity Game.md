# 题目信息

# [CEOI 1999] Parity Game

## 题目描述

Alice 和 Bob 在玩一个游戏：他写一个由 $0$ 和 $1$ 组成的序列。Alice 选其中的一段（比如第 $3$ 位到第 $5$ 位），问他这段里面有奇数个 $1$ 还是偶数个 $1$。Bob 回答你的问题，然后 Alice 继续问。Alice 要检查 Bob 的答案，指出在 Bob 的第几个回答一定有问题。有问题的意思就是存在一个 $01$ 序列满足这个回答前的所有回答，而且不存在序列满足这个回答前的所有回答及这个回答。

## 说明/提示

对于 $100\%$ 的数据，$1 \le  n \leq 10^9$，$m \leq 5 \times 10^3$。

## 样例 #1

### 输入

```
10
5
1 2 even
3 4 odd
5 6 even
1 6 even
7 10 odd```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
本题主要是判断给定的01序列区间奇偶性回答是否存在矛盾，关键在于处理区间的奇偶性关系以及应对较大的数据范围。各题解主要围绕并查集展开，包括种类并查集、带权并查集等，同时都使用了离散化来处理大数据范围。

### 所选题解
- **作者：houzhiyuan (赞：82)，4星**
    - **关键亮点**：思路清晰，详细解释了种类并查集和离散化的原理及实现，代码注释详细，易于理解。
    - **个人心得**：无
- **作者：Eleven谦 (赞：41)，4星**
    - **关键亮点**：提供了种类并查集和带权并查集两种解法，对每种解法的思路解释详细，通过问答形式给出思路，便于理解。
    - **个人心得**：初看想不到并查集，第二遍才读懂题，说明本题有一定难度。
- **作者：mot1ve (赞：18)，4星**
    - **关键亮点**：将本题与程序自动分析题进行类比，有助于理解并查集的应用，对扩展域并查集的思路和操作解释清晰。
    - **个人心得**：无

### 重点代码
#### 种类并查集核心代码（作者：houzhiyuan）
```cpp
int zuxian(int k){//并查集函数，注意路径压缩
    return f[k]==k?k:f[k]=zuxian(f[k]);
}
void hebing(int x,int y){//合并函数
    int x1=zuxian(x);
    int x2=zuxian(y);
    if(x1!=x2){
        f[x1]=x2;
    }
}
// 处理偶数情况
if(a[i].z==0){
    if(zuxian(a[i].x)==zuxian(a[i].y+l)){//如果两个数奇偶性不同，矛盾，输出
        cout<<i-1;
        return 0;
    }
    else{//不然就合并集合
        hebing(a[i].x,a[i].y);
        hebing(a[i].x+l,a[i].y+l);
    }
}
// 处理奇数情况
else{
    if(zuxian(a[i].x)==zuxian(a[i].y)){//同理
        cout<<i-1;
        return 0;
    }
    else{
        hebing(a[i].x,a[i].y+l);
        hebing(a[i].x+l,a[i].y);
    }
}
```
**核心实现思想**：使用种类并查集，将并查集数组开大两倍，分别表示奇偶性相同和不同的集合。根据区间的奇偶性回答进行集合的合并和矛盾判断。

#### 带权并查集核心代码（作者：Eleven谦）
```cpp
inline int find(int x) {
    if(fa[x]==x) return x;
    int root=find(fa[x]);
    dis[x]^=dis[fa[x]];  //路径压缩求出x与树根的奇偶性关系 
    return fa[x]=root;
}
// 处理询问
int xx=find(x),yy=find(y);
if(xx==yy) {  //在一个集合中 
    if((dis[x]^dis[y])!=a[i].op) {  //判断回答是否正确 
        printf("%d",i-1);
        return 0;
    }
}
else {
    fa[xx]=yy;
    dis[xx]=dis[x]^dis[y]^a[i].op;  //求左端点树根成为右端点树根孩子后的边权 
}
```
**核心实现思想**：使用带权并查集，用`dis`数组记录节点与根节点的奇偶性关系，通过异或运算维护边权。在处理询问时，判断两点是否在同一集合，若在则判断奇偶性关系是否矛盾，若不在则进行合并操作。

### 最优关键思路或技巧
- **离散化**：当数据范围大但实际使用的数较少时，使用离散化将大数据映射到小范围，可有效减少空间复杂度。
- **并查集的应用**：利用并查集的传递性来维护区间的奇偶性关系，种类并查集通过扩展域记录不同的关系，带权并查集通过边权记录奇偶性关系。

### 可拓展之处
同类型题或类似算法套路：
- 涉及变量关系判断的问题，如判断等式是否可满足、元素之间的等价关系等，可使用并查集来维护。
- 对于有传递性的关系，如食物链中生物的捕食关系、元素的奇偶性等，可使用种类并查集或带权并查集。

### 推荐题目
- [P1955 程序自动分析](https://www.luogu.com.cn/problem/P1955)：涉及变量的相等关系判断，使用并查集维护。
- [P2024 [NOI2001] 食物链](https://www.luogu.com.cn/problem/P2024)：经典的种类并查集题目，维护生物之间的捕食关系。
- [P1196 [NOI2002] 银河英雄传说](https://www.luogu.com.cn/problem/P1196)：使用带权并查集维护舰队之间的距离关系。

### 个人心得总结
- **Eleven谦**：初看题目可能想不到使用并查集，需要多读几遍题目理解题意，对于有传递关系的问题可以考虑使用并查集。

---
处理用时：37.20秒
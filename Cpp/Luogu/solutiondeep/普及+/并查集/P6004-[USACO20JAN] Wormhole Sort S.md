# 题目信息

# [USACO20JAN] Wormhole Sort S

## 题目描述

Farmer John 的奶牛们已经厌倦了他对她们每天早上排好序离开牛棚的要求。她们刚刚完成了量子物理学的博士学位，准备将这一过程搞快点。

今天早上，如同往常一样，Farmer John 的 $N$ 头编号为 $1 \ldots N$ 的奶牛（$1 \leq N \leq 10^5$），分散在牛棚中 $N$ 个编号为 $1 \ldots N$ 的不同位置，奶牛 $i$ 位于位置 $p_i$。但是今天早上还出现了 $M$ 个编号为 $1 \ldots M$ 的虫洞（$1 \leq M \leq 10^5$），其中虫洞 $i$ 双向连接了位置 $a_i$ 和 $b_i$，宽度为 $w_i$（$1\le a_i,b_i\le N, a_i\neq b_i, 1\le w_i\le 10^9$）。

在任何时刻，两头位于一个虫洞两端的奶牛可以选择通过虫洞交换位置。奶牛们需要反复进行这样的交换，直到对于 $1 \leq i \leq N$，奶牛 $i$ 位于位置 $i$。

奶牛们不想被虫洞挤坏。帮助她们最大化被她们用来排序的虫洞宽度的最小值。保证奶牛们有可能排好序。

## 说明/提示

### 样例解释 1

以下是一个仅用宽度至少为 9 的虫洞给奶牛排序的可能方案：

- 奶牛 1 和奶牛 2 使用第三个虫洞交换位置。
- 奶牛 1 和奶牛 3 使用第一个虫洞交换位置。
- 奶牛 2 和奶牛 3 使用第三个虫洞交换位置。

### 子任务

- 测试点 $3 \sim 5$ 满足 $N,M \leq 1000$。
- 测试点 $6 \sim 10$ 没有额外限制。

## 样例 #1

### 输入

```
4 4
3 2 1 4
1 2 9
1 3 7
2 3 10
2 4 3```

### 输出

```
9```

## 样例 #2

### 输入

```
4 1
1 2 3 4
4 2 13```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均围绕并查集展开，以解决奶牛通过虫洞排序时最大化虫洞宽度最小值的问题。部分题解采用二分答案的策略，结合并查集判断可行性；部分题解则通过对虫洞按宽度从大到小排序，逐步添加边来判断是否满足条件。

### 所选题解
- **作者：houzhiyuan (赞：31)，4星**
  - **关键亮点**：思路清晰，先给出暴力解法，再对其进行优化，详细解释了优化的过程和原理，代码注释丰富，可读性高。
  - **个人心得**：无

- **作者：FourteenObsidian (赞：12)，4星**
  - **关键亮点**：准确抓住“最大化最小值”的关键信息，采用二分答案结合并查集的方法，思路简洁明了，复杂度分析准确。
  - **个人心得**：无

- **作者：Karl_Aurora (赞：7)，4星**
  - **关键亮点**：详细阐述了二分答案和并查集的思路，给出了二分模板，代码中包含输入输出优化，且有一定的注释。
  - **个人心得**：分享了做题时对题目的不同理解和讨论，体现了思考过程。

### 重点代码
#### houzhiyuan的优化代码
```cpp
while(zuxian(j)==zuxian(a[j])){
    j++;
}
if(j>n){
    cout<<cow[i].z<<endl;
    return 0;
}
```
**核心思想**：通过一个指针 `j` 来记录第一个不满足条件的奶牛，避免每次都遍历所有奶牛，优化了判断过程。

#### FourteenObsidian的二分答案代码
```cpp
while(l <= r){
    mid = (l + r) >> 1;
    if(check(mid)){
        l = mid + 1;
        ans = mid;
    }
    else r = mid - 1;
}
```
**核心思想**：二分枚举虫洞宽度的最小值，通过 `check` 函数判断该宽度是否可行，不断缩小范围，最终得到最大的可行宽度。

#### Karl_Aurora的二分答案和检查函数代码
```cpp
while (l < r){
    mid = (l + r + 1) / 2;
    if (check(mid)) {l = mid; ans = mid;}
    else r = mid - 1;
}

bool check(int upp){
    for (register int i = 1; i <= n; ++i) f[i] = i;
    for (register int i = 1; i <= m; ++i){
        if (s[i].w < upp) break;
        f[find_father(s[i].from)] = find_father(s[i].to);
    }
    for (register int i = 1; i <= n; ++i){
        if (find_father(f[i]) != find_father(f[p[i]])) return false;
    }
    return true;
}
```
**核心思想**：二分枚举边权最小值，`check` 函数中先初始化并查集，然后将宽度大于等于枚举值的虫洞连接的位置合并，最后检查每个奶牛的所在位置与其目标位置是否连通。

### 最优关键思路或技巧
- **并查集的运用**：利用并查集高效判断两个位置是否连通，是解决本题的核心数据结构。
- **二分答案**：对于“最大化最小值”或“最小化最大值”的问题，二分答案是一种常见且有效的解题策略。
- **优化判断过程**：通过记录第一个不满足条件的元素，避免每次都遍历所有元素，降低时间复杂度。

### 可拓展之处
同类型题或类似算法套路：
- 涉及图的连通性问题，如判断图是否连通、求连通分量个数等，可使用并查集。
- 对于求最值的问题，若满足单调性，可考虑二分答案。

### 推荐题目
- [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)：并查集的模板题，可用于巩固并查集的基本操作。
- [P2820 局域网](https://www.luogu.com.cn/problem/P2820)：涉及最小生成树和图的连通性，可加深对图算法的理解。
- [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195)：结合了并查集和最小生成树的思想，有一定的综合性。

### 个人心得摘录与总结
- **Karl_Aurora**：分享了做题时对题目的不同理解和讨论，如有人认为是最小生成树问题，有人认为是并查集板子题，提醒我们在做题时要准确把握题目特点，不要被惯性思维误导。

---
处理用时：30.15秒
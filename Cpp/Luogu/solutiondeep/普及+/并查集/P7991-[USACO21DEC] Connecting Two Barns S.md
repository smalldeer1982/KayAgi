# 题目信息

# [USACO21DEC] Connecting Two Barns S

## 题目描述

Farmer John 的农场由 $N$ 块田地（$1 \leq N \leq 10^5$）组成，编号为 $1 \ldots N$。在这些田地之间有 $M$ 条双向道路（$0 \leq M \leq 10^5$），每条道路连接两块田地。

农场有两个牛棚，一个在田地 1 中，另一个在田地 $N$ 中。Farmer John 希望确保有一种方式可以沿着一组道路在两个牛棚之间行走。 他愿意建造至多两条新道路来实现这一目标。由于田地的位置因素，在田地 $i$ 和 $j$ 之间建造新道路的花费是 $(i-j)^2$。

请帮助 Farmer John 求出使得牛棚 $1$ 和 $N$ 可以相互到达所需要的最小花费。

## 说明/提示

【样例解释】

- 第一个子测试用例中，最优的方式是用一条道路连接田地 2 和 3，用一条道路连接田地 3 和 4。
- 第二个子测试用例中，最优的方式是用一条道路连接田地 3 和 4。不需要第二条道路。

【数据范围】

- 测试点 2 满足 $N \le 20$。
- 测试点 3-5 满足 $N \le 10^3$。
- 测试点 6-10 没有额外限制。

## 样例 #1

### 输入

```
2
5 2
1 2
4 5
5 3
1 2
2 3
4 5```

### 输出

```
2
1
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先使用并查集来确定图中的连通分量，再根据不同的连边情况（不连边、连一条边、连两条边）来计算使点 1 和点 n 连通的最小代价。大部分题解通过二分查找来优化寻找最小差值点的过程，从而降低时间复杂度至 $O(n \log n)$。

### 所选题解
- 作者：望月Asta (赞：12)，4星
  - 关键亮点：思路清晰，代码简洁且注释详细，对不同连边情况的分析全面，通过定义数组 $f$ 和 $g$ 分别记录将点 $i$ 所在的连通分量与 1 和 $n$ 连接的最小代价，最后取 $\min_{i = 1}^{n} \{f_i + g_i\}$ 得到答案。

### 重点代码
```cpp
// 并查集查找函数
int find(int x) {
    return x == fa[x] ? x : fa[x] = find(fa[x]);
}

void solve() {
    int n,m;
    scanf("%d %d",&n,&m);
    memset(f,127,sizeof(f));
    memset(g,127,sizeof(g));
    for(int i = 1;i <= n;++i)
        fa[i] = i;
    for(int i = 1;i <= m;++i) {
        int u,v;
        scanf("%d %d",&u,&v);
        u = find(u),v = find(v);
        if(u == v) continue;
        fa[u] = v;
    }
    int r1 = find(1),rn = find(n);
    f[r1] = 0,g[rn] = 0;
    int cntF = 0,cntG = 0;
    for(int i = 1;i <= n;++i) {
        int u = find(i);
        if(u == r1) F[++cntF] = i;
        else if(u == rn) G[++cntG] = i;
    }
    for(int i = 1;i <= n;++i) {
        int u = find(i);
        if(u != r1) {
            int pre = std::upper_bound(F + 1,F + cntF + 1,i) - F - 1;
            f[u] = std::min(f[u],(ll)(i - F[pre]) * (i - F[pre]));
            if(pre < cntF) {
                ++pre;
                f[u] = std::min(f[u],(ll)(i - F[pre]) * (i - F[pre]));
            }
        }
        if(u != rn) {
            int nxt = std::upper_bound(G + 1,G + cntG + 1,i) - G;
            g[u] = std::min(g[u],(ll)(i - G[nxt]) * (i - G[nxt]));
            if(nxt > 1) {
                --nxt;
                g[u] = std::min(g[u],(ll)(i - G[nxt]) * (i - G[nxt]));
            }
        }
    }
    ll ans = (ll)(n - 1ll) * (n - 1ll);
    for(int i = 1;i <= n;++i) {
        int u = find(i);
        ans = std::min(ans,f[u] + g[u]);
    }
    printf("%lld\n",ans);
}
```
**核心实现思想**：
1. 初始化并查集和数组 $f$、$g$。
2. 读入边并合并连通分量。
3. 找出 1 和 $n$ 所在的连通分量，并记录其中的点。
4. 对于每个点，通过二分查找在 1 和 $n$ 所在的连通分量中找到与其差值最小的点，更新 $f$ 和 $g$ 数组。
5. 遍历所有点，取 $f$ 和 $g$ 之和的最小值作为答案。

### 最优关键思路或技巧
- **并查集**：用于维护图中的连通分量，方便判断点之间的连通性。
- **二分查找**：在查找与某个点差值最小的点时，使用二分查找可以将时间复杂度从 $O(n)$ 降低到 $O(\log n)$。
- **数组记录**：通过定义数组 $f$ 和 $g$ 分别记录将点 $i$ 所在的连通分量与 1 和 $n$ 连接的最小代价，简化了计算过程。

### 可拓展之处
同类型题或类似算法套路：
- **最小生成树**：在一些图的连通性问题中，可以使用最小生成树算法（如 Kruskal 或 Prim 算法）来求解最小代价。
- **多源最短路径**：当需要考虑多个起点和终点的连通性时，可以使用多源最短路径算法（如 Floyd-Warshall 算法）。

### 推荐题目
- [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195)：考察并查集和最小生成树的应用。
- [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)：基础的并查集题目，用于巩固并查集的使用。
- [P2342 叠积木](https://www.luogu.com.cn/problem/P2342)：涉及并查集的拓展应用，需要对并查集进行一定的修改。

### 个人心得
部分题解提到了一些注意事项，如最终答案要开 `long long` 以避免溢出，以及在使用二分查找时要注意边界情况等。这些都是在实际编程中容易踩坑的地方，需要特别注意。

---
处理用时：34.37秒
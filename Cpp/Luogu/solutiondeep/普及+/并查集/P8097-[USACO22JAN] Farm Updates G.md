# 题目信息

# [USACO22JAN] Farm Updates G

## 题目描述

Farmer John 经营着总共 $N$ 个农场（$1\le N\le 10^5$），编号为 $1\ldots N$。最初，这些农场之间没有道路连接，并且每个农场都在活跃地生产牛奶。

由于经济的动态性，Farmer John 需要根据 $Q$ 次更新操作（$0\le Q\le 2\cdot 10^5$）对他的农场进行改造。更新操作有三种可能的形式：

- `(D x)` 停用一个活跃的农场 $x$，使其不再生产牛奶。

- `(A x y)` 在两个活跃的农场 $x$ 和 $y$ 之间添加一条道路。

- `(R e)` 删除之前添加的第 $e$ 条道路（$e = 1$ 是添加的第一条道路）。

一个农场 $x$ 如果正在活跃地生产牛奶，或者可以通过一系列道路到达另一个活跃的农场，则称之为一个「有关的」农场。对于每个农场 $x$，计算最大的 $i$（$0\le i\le Q$），使得农场 $x$ 在第 $i$ 次更新后是有关的。

## 说明/提示

【样例解释】

在这个例子中，道路以顺序 $(2,3), (1,2), (2,4)$ 被删除。

- 农场 $1$ 在道路 $(1,2)$ 被删除之前是有关的。

- 农场 $2$ 在道路 $(2,4)$ 被删除之前是有关的。

- 农场 $3$ 在道路 $(2,3)$ 被删除之前是有关的。

- 农场 $4$ 和 $5$ 在所有更新结束后仍然是活跃的。所以它们一直保持为有关的，两者的输出均应为 $Q$。

【数据范围】

- 测试点 2-5 满足 $N\le 10^3$，$Q\le 2\cdot 10^3$。

- 测试点 6-20 没有额外限制。


## 样例 #1

### 输入

```
5 9
A 1 2
A 2 3
D 1
D 3
A 2 4
D 2
R 2
R 1
R 3```

### 输出

```
7
8
6
9
9```

# AI分析结果

### 综合分析与结论
这些题解主要围绕农场更新问题展开，解题的关键在于处理三种操作（停用农场、添加道路、删除道路）并计算每个农场最后一次有关的操作编号。多数题解采用倒序处理的思路，将复杂的操作转化为更易处理的形式，利用并查集、BFS、DFS 等算法来维护连通性和更新答案。不同题解在具体实现和优化上各有特点，但整体目标一致。

### 所选题解
- **清小秋ovo（4星）**
    - **关键亮点**：思路清晰，通过先建图并记录点和边的开关时间，再从关闭时间最大的点开始倒序遍历更新答案，使用 BFS 实现，代码注释详细，易于理解。
    - **个人心得**：赛场上考虑过并查集，但因删边处理困难而换思路，体现了灵活应变的解题思维。
- **zhiyangfan（4星）**
    - **关键亮点**：深入分析操作，发现加边操作不影响关联性，采用倒序处理将问题转化为单点修改和加边，用并查集维护连通性，时间复杂度为均摊的 $\mathcal{O}(n + q)$，优化程度较高。
- **耶梦加得（4星）**
    - **关键亮点**：同样采用倒序操作，利用题目中加边限制，得出倒着操作不会有农场失活的结论，通过 DFS 遍历更新答案，复杂度为 $O(N + Q)$，实现简洁高效。

### 重点代码
#### 清小秋ovo
```cpp
// BFS部分
while(!t.empty())
{
    node cur = t.top();
    int id = cur.id;
    int tt = cur.ans; //对应的关闭时间
    t.pop();
    if (vis[id]) continue;
    vis[id] = 1;
    for (int i = head[id]; i; i = nxt[i])
    {
        int y = to[i];
        int prev = min(ed[i], a[id].ans); //别的边的贡献
        a[y].ans = max(a[y].ans, prev); //那么那个点的最大时间设为 自己点关的时间和别的边时间的最大值
        t.push(a[y]);
    }
}
```
**核心思想**：使用大根堆维护每个点，每次取出关闭时间最大的点进行 BFS 遍历，更新相邻点的最大时间。

#### zhiyangfan
```cpp
inline void link(int u, int v, int now)
{
    u = getf(u), v = getf(v); if (u == v) return ;
    if ((!vis[u]) ^ (!vis[v]))
    {
        if (!vis[u]) for (auto x : vec[u]) vis[x] = now;
        else for (auto x : vec[v]) vis[x] = now;
    }
    if (vec[u].size() > vec[v].size()) { f[v] = u; for (auto x : vec[v]) vec[u].push_back(x); }
    else { f[u] = v; for (auto x : vec[u]) vec[v].push_back(x); }
}
```
**核心思想**：并查集的合并操作，若两个连通块关联性不同，将非关联连通块的点标记为关联，并合并两个连通块。

#### 耶梦加得
```cpp
void dfs(int x, int t) { //t 代表操作时间
    vis[x] = 1; if(!ans[x]) ans[x] = t; //最后一个活跃的时刻，对于倒序操作就是第一个
    for(int i = 0; i < g[x].size(); ++i) {
        int to = g[x][i];
        if(vis[to]) continue;
        act[to] |= act[x];
        dfs(to, t);
    }
}
```
**核心思想**：DFS 遍历连通块，标记未访问过的点的最后活跃时间。

### 最优关键思路或技巧
- **倒序处理**：将操作倒序，把复杂的删点、删边操作转化为加点、加边操作，降低问题难度。
- **利用题目限制**：注意到加边操作只在活跃农场之间进行，可得出加边不影响关联性等结论，简化问题。
- **并查集优化**：使用启发式合并等方法优化并查集的时间复杂度。

### 可拓展之处
同类型题如涉及图的动态操作（添加、删除节点或边）并要求维护某些性质的问题，可采用类似的倒序处理和并查集维护连通性的思路。类似算法套路包括线段树分治、整体二分等，可用于处理更复杂的动态问题。

### 推荐题目
- [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)
- [P2024 [NOI2001] 食物链](https://www.luogu.com.cn/problem/P2024)
- [P1525 [NOIP2010 提高组] 关押罪犯](https://www.luogu.com.cn/problem/P1525)

### 个人心得总结
- 清小秋ovo：赛场上遇到问题要灵活应变，当原思路（并查集）处理困难时，及时更换思路（BFS）。
- 耶梦加得：做题时要仔细阅读题目条件，如本题中加边限制，忽略该条件可能导致错误。 

---
处理用时：36.77秒
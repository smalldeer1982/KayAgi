# 题目信息

# [蓝桥杯 2020 省 AB1] 网络分析

## 题目描述

小明正在做一个网络实验。

他设置了 $n$ 台电脑，称为节点，用于收发和存储数据。

初始时，所有节点都是独立的，不存在任何连接。

小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相通信了。两个节点如果存在网线连接，称为相邻。

小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会发送到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有直接或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储下来。一条信息只存储一次。

给出小明连接和测试的过程，请计算出每个节点存储信息的大小。

## 说明/提示

对于 $30\%$ 的评测用例，$1 ≤ n ≤ 20$，$1 ≤ m ≤ 100$。

对于 $50\%$ 的评测用例，$1 ≤ n ≤ 100$，$1 ≤ m ≤ 1000$。

对于 $70\%$ 的评测用例，$1 ≤ n ≤ 1000$，$1 ≤ m ≤ 10000$。

对于所有评测用例，$1 ≤ n ≤ 10000$，$1 ≤ m ≤ 10^5$ ，$1 ≤ t ≤ 100$。

蓝桥杯 2020 第一轮省赛 A 组 J 题（B 组 J 题）。

## 样例 #1

### 输入

```
4 8
1 1 2
2 1 10
2 3 5
1 4 1
2 2 2
1 1 2
1 2 4
2 2 1```

### 输出

```
13 13 5 3```

# AI分析结果

### 综合分析与结论
这些题解均围绕网络分析问题展开，核心是处理节点连接与信息传播，主要运用并查集解决。各题解思路与实现细节有别，时间复杂度和优化方向不同。
- Yashajin_Ai 题解利用最多合并 $n - 1$ 次的性质，合并时暴力统计，使用路径压缩和启发式合并，时间复杂度 $O(n^2 + m)$。
- jijidawang 题解通过重标号将问题转化为序列问题，用差分解决，时空复杂度 $\Theta(n + q)$。
- Maysoul 题解结合拓扑排序与并查集，借助懒标记简化区间操作，在合并前下放标记。
- strcmp 题解使用带权并查集，结合启发式合并和虚点处理懒标记污染问题，时间复杂度 $\Theta((n + m) \log_2 n)$。

### 所选题解
- **Yashajin_Ai（4星）**
    - **关键亮点**：思路清晰，利用合并次数性质，结合路径压缩和启发式合并，代码实现简洁。
- **jijidawang（4星）**
    - **关键亮点**：提出重标号思路，将问题转化为序列问题，用差分高效解决，时空复杂度优。
- **strcmp（4星）**
    - **关键亮点**：详细分析带权并查集问题，引入虚点解决懒标记污染，优化时间复杂度。

### 重点代码及核心实现思想
#### Yashajin_Ai
```cpp
int find(int x){
    if(f[x]==x){
        return x;
    }
    return f[x]=find(f[x]);
}
while(m--){
    int op,x,y;
    cin>>op>>x>>y;
    switch(op){
        case 1:{
            x=find(x);
            y=find(y);
            if(x!=y){
                for(int i=1;i<=n;++i){
                    ans[i]+=val[find(i)];
                }
                for(int i=1;i<=n;++i){
                    val[i]=0;
                }
                if(siz[x]>siz[y]) {
                    swap(x,y);
                }
                f[x]=y;
                siz[y]+=siz[x];
            }
            break;
        }
        case 2:{
            x=find(x);
            val[x]+=y;
            break;
        }
    }
}
```
**核心思想**：使用并查集合并节点，合并时暴力统计信息，利用路径压缩和启发式合并优化。

#### jijidawang
```cpp
struct dsu
{
    int fa[N];
    dsu(){clear();}
    int get(int x){return x == fa[x] ? x : fa[x] = get(fa[x]);}
    inline void merge(int u, int v)
    {
        u = get(u); v = get(v);
        if (u == v) return ;
        nxt[lst[u]] = v; lst[u] = lst[v];
        fa[v] = u;
    }
    inline void clear(){iota(fa, fa+N, 0);}
}D;
for (int i=1; i<=q; i++)
{
    if (que[i].opt == 1) D.merge(que[i].u, que[i].v);
    else{int L = D.get(que[i].u), R = lst[L]; a[id[L]] += que[i].v; a[id[R] + 1] -= que[i].v;}
}
for (int i=1; i<=n; i++) a[i] += a[i-1];
```
**核心思想**：离线处理询问，用并查集维护连通块，通过重标号将问题转化为序列问题，用差分求解。

#### strcmp
```cpp
int find(int x) {
    if (!fa[x])return x;
    else return find(fa[x]);
}
inline void merge(int x, int y) {
    x = find(x); y = find(y); 
    if (x == y)return;
    if (siz[x] < siz[y])swap(x, y);
    fa[y] = x; siz[x] += siz[y]; 
    int u = ++cnt; ls[u] = vf[x]; rs[u] = vf[y];
    vf[x] = vf[y] = u; 
}
void dfs(int u) {
    if (u <= n)return;
    tge[ls[u]] += tge[u];
    tge[rs[u]] += tge[u]; tge[u] = 0;
    dfs(ls[u]); dfs(rs[u]);
}
```
**核心思想**：使用带权并查集和启发式合并，引入虚点解决懒标记污染问题，通过递归下传懒标记。

### 最优关键思路或技巧
- 重标号将问题转化为序列问题，用差分高效解决。
- 引入虚点处理带权并查集懒标记污染问题。
- 利用合并次数性质，结合路径压缩和启发式合并优化。

### 可拓展之处
同类型题如连通块合并与区间修改问题，可使用并查集结合数据结构（如线段树、树状数组）解决。类似算法套路包括离线处理、懒标记、差分等。

### 推荐洛谷题目
- P1196 [NOI2002] 银河英雄传说
- P3367 【模板】并查集
- P1525 [NOIP2010 提高组] 关押罪犯

### 个人心得
- **strcmp**：在使用带权并查集时，发现父子关系乱序会导致难以处理修改操作，路径压缩会破坏父子关系。直接暴力 pushdown 会被特殊数据卡 T，通过引入虚点解决懒标记污染问题。
**总结**：在使用并查集解决问题时，要注意父子关系的维护，避免路径压缩破坏信息。对于懒标记的处理，要考虑特殊数据的影响，可通过引入虚点等方式优化。 

---
处理用时：37.22秒
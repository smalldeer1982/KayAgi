# 题目信息

# [蓝桥杯 2022 省 A] 推导部分和

## 题目描述

对于一个长度为 $N$ 的整数数列 $A_{1}, A_{2}, \cdots A_{N}$，小蓝想知道下标 $l$ 到 $r$ 的部分和 $\sum\limits_{i=l}^{r}A_i=A_{l}+A_{l+1}+\cdots+A_{r}$ 是多少?

然而，小蓝并不知道数列中每个数的值是多少，他只知道它的 $M$ 个部分和的值。其中第 $i$ 个部分和是下标 $l_{i}$ 到 $r_{i}$ 的部分和 $\sum_{j=l_{i}}^{r_{i}}=A_{l_{i}}+A_{l_{i}+1}+\cdots+A_{r_{i}}$, 值是 $S_{i}$ 。

## 说明/提示

对于 $10 \%$ 的评测用例, $1 \leq N, M, Q \leq 10,-100 \leq S_{i} \leq 100$ 。

对于 $20 \%$ 的评测用例, $1 \leq N, M, Q \leq 20,-1000 \leq S_{i} \leq 1000$ 。

对于 $30 \%$ 的评测用例, $1 \leq N, M, Q \leq 50,-10000 \leq S_{i} \leq 10000$ 。

对于 $40 \%$ 的评测用例, $1 \leq N, M, Q \leq 1000,-10^{6} \leq S_{i} \leq 10^{6}$ 。

对于 $60 \%$ 的评测用例, $1 \leq N, M, Q \leq 10000,-10^{9} \leq S_{i} \leq 10^{9}$ 。

对于所有评测用例, $1 \leq N, M, Q \leq 10^{5},-10^{12} \leq S_{i} \leq 10^{12}, 1 \leq l_{i} \leq r_{i} \leq N$, $1 \leq l \leq r \leq N$ 。数据保证没有矛盾。

蓝桥杯 2022 省赛 A 组 J 题。

## 样例 #1

### 输入

```
5 3 3
1 5 15
4 5 9
2 3 5
1 5
1 3
1 2```

### 输出

```
15
6
UNKNOWN```

# AI分析结果

### 综合分析与结论
这些题解主要围绕两种思路解决推导部分和问题：一是使用带权并查集，二是建图后用 DFS 搜索。带权并查集通过维护节点到根节点的距离，判断节点连通性并计算区间和；建图 DFS 则利用边权和连通块标记，判断连通性并更新前缀和数组。

### 所选题解
- **作者：loser_seele（5星）**
    - **关键亮点**：思路清晰，详细阐述了从问题转化到并查集维护的过程，代码实现简洁，复杂度分析明确。
    - **核心代码**：
```cpp
int par[maxn],val[maxn];
void init(int l,int r) {
    for(int i=l;i<=r;i++) 
        par[i]=i,val[i]=0;
}
int find(int x) {
    if(par[x]==x) return x;
    else {
        int root=find(par[x]);
        val[x]+=val[par[x]];
        return par[x]=root;
    }
}
signed main() {
    cin>>n>>m;
    int q;
    cin>>q;
    init(0,n);
    for(int i=1,a,b,s;i<=m;i++) {
        scanf("%lld%lld%lld",&a,&b,&s); 
        a--;
        int t1=find(a),t2=find(b);
        if(t1!=t2) {
            par[t2]=t1;
            val[t2]=-val[b]+s+val[a];
        }
    }
    while(q--) {
        scanf("%d%d",&a,&b); 
        a--;
        int t1=find(a),t2=find(b);
        if(t1!=t2)
            cout<<"UNKNOWN\n";
        else
            cout<<val[b]-val[a]<<'\n';
    }
}
```
    - **核心思想**：通过前缀和将区间和问题转化为节点连通性问题，用并查集维护节点连通性，`val` 数组记录节点到根节点的距离，合并集合时更新 `val` 值，查询时判断连通性并计算区间和。

- **作者：technopolis_2085（4星）**
    - **关键亮点**：详细分析了带权并查集的合并过程，配有图示辅助理解，代码规范。
    - **核心代码**：
```cpp
int fa[maxn],sum[maxn];
int find(int x) {
    if (fa[x]==x) return fa[x];
    int t=find(fa[x]);
    sum[x]+=sum[fa[x]];
    fa[x]=t;
    return fa[x];
}
signed main() {
    int n,m,q;
    scanf("%lld%lld%lld",&n,&m,&q);
    for (int i=1;i<=n;i++) fa[i]=i;
    while (m--) {
        int l,r,x;
        scanf("%lld%lld%lld",&l,&r,&x);
        l--;
        int fl=find(l),fr=find(r);
        if (fl!=fr) {
            fa[fl]=fr;
            sum[fl]=-x-sum[l]+sum[r];
        }
    }
    while (q--) {
        int l,r;
        scanf("%lld%lld",&l,&r);
        l--;
        int fl=find(l),fr=find(r);
        if (fl!=fr) printf("UNKNOWN\n");
        else printf("%lld\n",sum[r]-sum[l]);
    }
    return 0; 
}
```
    - **核心思想**：同样使用带权并查集，`sum` 数组记录节点到根节点的距离，合并集合时根据前缀和关系更新 `sum` 值，查询时判断连通性并输出结果。

- **作者：hj23308（4星）**
    - **关键亮点**：采用建图 DFS 的思路，代码简洁，时空复杂度分析明确。
    - **核心代码**：
```cpp
array<int, maxN> col;
array<long long, maxN> s;
array<vector<pair<int, long long>>, maxN> edges;
void dfs(int u) { 
    for (auto [v, w]: edges[u]) 
        if (!col[v]) 
            s[v] = s[u] + w, col[v] = col[u], dfs(v); 
}
int main() {
    cin >> m >> m >> q;
    while (m--) {
        int l, r;
        long long t;
        cin >> l >> r >> t, l--;
        edges[l].emplace_back(r, t);
        edges[r].emplace_back(l, -t);
    }
    while (q--) {
        int l, r;
        cin >> l >> r, l--;
        if (!col[l]) col[l] = ++tot, dfs(l);
        if (col[l] == col[r]) cout << s[r] - s[l] << '\n';
        else cout << "UNKNOWN\n";
    }
    return 0;
}
```
    - **核心思想**：将已知区间和信息转化为图的边权，用 `col` 数组标记连通块，`s` 数组记录前缀和，DFS 遍历更新前缀和，查询时判断连通性并计算区间和。

### 最优关键思路与技巧
- **前缀和转化**：将区间和问题转化为前缀和的差值问题，便于用图或并查集处理。
- **带权并查集**：通过维护节点到根节点的距离，高效判断节点连通性并计算区间和。
- **建图 DFS**：利用图的连通性和边权，通过 DFS 搜索更新前缀和数组，判断区间和是否可求。

### 可拓展之处
同类型题如区间信息推导、约束关系判断等，可使用带权并查集或建图搜索的思路解决。类似算法套路有差分约束系统、图的连通性问题等。

### 洛谷推荐题目
- [P1196 银河英雄传说](https://www.luogu.com.cn/problem/P1196)
- [AT_abc238_e Range Sums](https://www.luogu.com.cn/problem/AT_abc238_e)
- [hdu3038 How Many Answers Are Wrong](http://acm.hdu.edu.cn/showproblem.php?pid=3038)

### 个人心得
部分题解未提及个人心得，有心得的题解可进一步分析问题转化的思路和并查集维护的细节，帮助理解和掌握此类问题的解法。 

---
处理用时：38.22秒
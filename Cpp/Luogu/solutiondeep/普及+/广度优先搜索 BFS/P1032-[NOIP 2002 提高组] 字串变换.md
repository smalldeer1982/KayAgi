# 题目信息

# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心是通过广度优先搜索（BFS）或双向BFS来寻找从字符串A到字符串B的最小变换步数，且步数不超过10步。题解中大部分使用了BFS或双向BFS，并结合了字符串替换、判重等技巧。以下是对题解的总结与对比：

1. **算法选择**：大部分题解使用了BFS，部分题解使用了双向BFS，后者在时间和空间复杂度上更具优势，尤其是在搜索深度较大时。
2. **字符串处理**：题解中普遍使用了C++的`string`类，利用`find`和`replace`等函数进行字符串的查找和替换操作。
3. **判重优化**：为了减少重复搜索，题解中使用了`map`或`set`来记录已经访问过的字符串状态，避免重复计算。
4. **剪枝策略**：部分题解在搜索过程中加入了剪枝策略，如提前判断步数是否超过10步，避免无效搜索。

### 所选高星题解

#### 1. **题解作者：BrandonSoong (赞：127)**
- **星级**：★★★★★
- **关键亮点**：使用了双向BFS，显著减少了搜索空间和时间复杂度。通过从起点和终点同时进行搜索，并在中间相遇时输出结果，优化了搜索效率。
- **个人心得**：作者提到双向BFS的优势在于可以减少搜索的冗余，尤其是在搜索深度较大时，能够显著提升性能。
- **核心代码**：
  ```cpp
  void bfs() {
      queue<node> q;
      q.push(node{A, 0});
      vis[A] = 1;
      while (!q.empty()) {
          node now = q.front(); q.pop();
          if (now.step > 10) continue;
          if (now.s == B) { cout << now.step; return; }
          for (int i = 1; i <= n; i++) {
              string tmp = now.s;
              int pos = tmp.find(a[i]);
              while (pos != string::npos) {
                  tmp.replace(pos, a[i].length(), b[i]);
                  if (!vis[tmp]) {
                      vis[tmp] = 1;
                      q.push(node{tmp, now.step + 1});
                  }
                  pos = tmp.find(a[i], pos + 1);
              }
          }
      }
      cout << "NO ANSWER!";
  }
  ```

#### 2. **题解作者：ShawnZhou (赞：279)**
- **星级**：★★★★☆
- **关键亮点**：使用了BFS，并结合了`map`进行判重，代码简洁且易于理解。通过`find`和`replace`函数实现字符串的查找和替换，逻辑清晰。
- **核心代码**：
  ```cpp
  void bfs() {
      queue<node> q;
      q.push(node{A, 0});
      vis[A] = 1;
      while (!q.empty()) {
          node now = q.front(); q.pop();
          if (now.step > 10) continue;
          if (now.s == B) { cout << now.step; return; }
          for (int i = 1; i <= n; i++) {
              string tmp = now.s;
              int pos = tmp.find(a[i]);
              while (pos != string::npos) {
                  tmp.replace(pos, a[i].length(), b[i]);
                  if (!vis[tmp]) {
                      vis[tmp] = 1;
                      q.push(node{tmp, now.step + 1});
                  }
                  pos = tmp.find(a[i], pos + 1);
              }
          }
      }
      cout << "NO ANSWER!";
  }
  ```

#### 3. **题解作者：coyangjr (赞：582)**
- **星级**：★★★★☆
- **关键亮点**：使用了KMP算法进行字符串匹配，虽然复杂度较高，但提供了另一种思路。题解中还详细介绍了KMP算法的实现，适合对KMP算法感兴趣的读者。
- **核心代码**：
  ```cpp
  void KMP(string a, int x, int step) {
      string z = a;
      a = " " + a;
      int j = 0;
      for (int i = 1; i < a.length(); i++) {
          while (j > 0 && diff[x][j + 1] != a[i]) j = nxt[x][j];
          if (diff[x][j + 1] == a[i]) j++;
          if (j == diff[x].length() - 1) {
              string tmp = z.substr(0, i - diff[x].length() + 1) + change[x] + z.substr(i + diff[x].length() - 1);
              q.push(Node(tmp, step + 1));
              j = nxt[x][j];
          }
      }
  }
  ```

### 最优关键思路与技巧

1. **双向BFS**：从起点和终点同时进行搜索，减少搜索空间，显著提升效率。
2. **字符串处理**：利用`find`和`replace`函数进行字符串的查找和替换，简化代码实现。
3. **判重优化**：使用`map`或`set`记录已访问的字符串状态，避免重复计算。

### 拓展思路与推荐题目

1. **拓展思路**：本题可以扩展到更复杂的字符串变换问题，如允许更复杂的替换规则，或者增加更多的约束条件。
2. **推荐题目**：
   - [P3375 【模板】KMP字符串匹配](https://www.luogu.org/problem/P3375)
   - [P3808 【模板】AC自动机（简单版）](https://www.luogu.org/problem/P3808)
   - [P3796 【模板】AC自动机（加强版）](https://www.luogu.org/problem/P3796)

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中遇到了字符串替换的重复问题，通过引入`map`进行判重解决了这一问题。
- **踩坑教训**：部分题解提到在实现过程中忽略了字符串中可能存在多个匹配子串的情况，导致结果错误，最终通过循环查找所有匹配位置解决了问题。
- **顿悟感想**：双向BFS的实现虽然复杂，但在处理深度较大的搜索问题时，能够显著提升效率，值得深入学习。

---
处理用时：56.15秒
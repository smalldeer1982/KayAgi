# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论

本题要求计算从顶点1到其他所有顶点的最短路径数量。由于是无向无权图，最短路可以通过BFS、Dijkstra或SPFA等算法求解。大多数题解采用了BFS或Dijkstra，并在最短路算法中加入了计数操作。核心思路是：在更新最短路时，如果发现更短的路径，则更新路径数量；如果路径长度相同，则累加路径数量。

### 精选题解

#### 1. 作者：岸芷汀兰 (5星)
**关键亮点**：
- 明确指出BFS适用于无权图，避免了Dijkstra和SPFA的复杂度。
- 详细解释了如何处理自环和重边，并给出了清晰的计数逻辑。
- 代码简洁，逻辑清晰，适合初学者理解。

**个人心得**：
- 强调了BFS在处理无权图时的优势，避免了不必要的复杂度。
- 通过删除自环和正确处理重边，简化了问题。

**核心代码**：
```cpp
void bfs() {
    queue<Node> q; q.push(make(1, 0));
    memset(d, 0x3f, sizeof(d)); d[1] = 0;
    vis[1] = true;
    ans[1] = 1;
    while (q.size()) {
        int u = q.front().node, dis = q.front().dis; 
        q.pop();
        for (register int i = 0; i<int(linker[u].size()); i++) {
            int cur = linker[u][i];
            if (!vis[cur]) {
                q.push(make(cur, dis + 1)); vis[cur] = true; d[cur] = dis + 1; 
                ans[cur] += ans[u]; ans[cur] %= mod;
            }
            else if (dis + 1 == d[cur]) { ans[cur] += ans[u]; ans[cur] %= mod; }
        }
    }
}
```

#### 2. 作者：King丨帝御威 (4.5星)
**关键亮点**：
- 使用堆优化的Dijkstra算法，适用于更广泛的场景。
- 详细解释了如何通过Dijkstra的松弛操作进行计数。
- 代码结构清晰，注释详细，适合进阶学习。

**核心代码**：
```cpp
void dijkstra() {
    memset(dis, 0x3f, sizeof(dis));
    dis[1] = 0; ans[1] = 1;
    q.push(make_pair(0, 1));
    while (q.size()) {
        int x = q.top().second; q.pop();
        if (p[x]) continue;
        p[x] = 1;
        for (int i = head[x]; i; i = nxt[i]) {
            int y = to[i];
            if (dis[y] > dis[x] + 1) {
                dis[y] = dis[x] + 1;
                ans[y] = ans[x];
                q.push(make_pair(-dis[y], y));
            }
            else if (dis[y] == dis[x] + 1) {
                ans[y] += ans[x];
                ans[y] %= mod;
            }
        }
    }
}
```

#### 3. 作者：XZYQvQ (4星)
**关键亮点**：
- 提出SPFA在处理带权图时的潜在问题，并给出了改进方案。
- 通过记忆化搜索确保计数的准确性，适合处理复杂情况。
- 代码实现较为复杂，但思路清晰，适合高级学习者。

**核心代码**：
```cpp
int dfs(int u) {
    if (ans[u]) return ans[u];
    for (int i = head[u]; i != -1; i = nxt[i])
        if (dis[u] - 1 == dis[to[i]]) ans[u] = (ans[u] + dfs(to[i])) % 100003;
    return ans[u];
}
```

### 最优关键思路与技巧

1. **BFS适用于无权图**：在无权图中，BFS的时间复杂度为O(N+M)，远优于Dijkstra和SPFA。
2. **计数逻辑**：在更新最短路时，如果发现更短的路径，则更新路径数量；如果路径长度相同，则累加路径数量。
3. **记忆化搜索**：在处理带权图时，可以通过记忆化搜索确保计数的准确性。

### 可拓展之处

- **带权图的最短路计数**：可以通过Dijkstra或SPFA结合记忆化搜索来处理带权图的最短路计数问题。
- **多源最短路计数**：可以扩展到多源最短路计数，通过多次BFS或Dijkstra实现。

### 推荐题目

1. **P1608 路径统计**：带权图的最短路计数问题。
2. **P1144 最短路计数**：本题的无权图版本。
3. **P4779 【模板】单源最短路径（标准版）**：Dijkstra算法的模板题。

### 个人心得总结

- **BFS的优势**：在处理无权图时，BFS的简单性和高效性使其成为首选。
- **计数逻辑的清晰性**：通过明确的计数逻辑，可以避免复杂的边界情况处理。
- **记忆化搜索的应用**：在处理带权图时，记忆化搜索可以有效避免重复计算，提高效率。

---
处理用时：34.90秒
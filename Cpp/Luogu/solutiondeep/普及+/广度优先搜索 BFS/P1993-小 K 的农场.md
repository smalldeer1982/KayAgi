# 题目信息

# 小 K 的农场

## 题目描述

小 K 在 MC 里面建立很多很多的农场，总共 $n$ 个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共 $m$ 个），以下列三种形式描述：  
- 农场 $a$ 比农场 $b$ 至少多种植了 $c$ 个单位的作物；
- 农场 $a$ 比农场 $b$ 至多多种植了 $c$ 个单位的作物；
- 农场 $a$ 与农场 $b$ 种植的作物数一样多。  

但是，由于小 K 的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。  


## 说明/提示

对于 $100\%$ 的数据，保证 $1 \le n,m,a,b,c \le 5 \times 10^3$。

## 样例 #1

### 输入

```
3 3
3 1 2
1 1 3 1
2 2 3 2
```

### 输出

```
Yes
```

# AI分析结果

### 综合分析与结论

该题目要求判断是否存在一组农场作物的数量满足给定的约束条件，本质上是差分约束问题。所有题解均采用了差分约束的思路，通过将不等式转化为图的边，并使用SPFA算法判断负环来判断是否存在解。以下是各题解的要点总结：

1. **核心思路**：将不等式转化为图的边，使用SPFA判断负环。
2. **难点**：如何将不同类型的不等式转化为图的边，以及如何确保图的连通性（通过引入超级源点）。
3. **优化**：部分题解提到了使用SLF优化SPFA，以减少运行时间。
4. **代码实现**：大多数题解代码结构相似，主要区别在于建图和SPFA的实现细节。

### 所选高星题解

#### 1. 作者：SDqwq (赞：67)
- **星级**：★★★★★
- **关键亮点**：
  - 详细解释了差分约束的原理，尤其是如何将不等式转化为图的边。
  - 代码结构清晰，注释详细，易于理解。
  - 引入了超级源点确保图的连通性，并详细解释了SPFA的实现细节。
- **个人心得**：作者强调了负环的判断方法，并提供了SPFA的详细实现，适合初学者理解。

**核心代码片段**：
```cpp
bool spfa (int x) {
    dis[x] = 0;
    q.push(x);
    vis[x] = true;
    num[x]++;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = elast[u]; i != 0; i = e[i].next)
            if (dis[e[i].to] > dis[u] + e[i].len) {
                dis[e[i].to] = dis[u] + e[i].len;
                if (!vis[e[i].to]) {
                    q.push(e[i].to);
                    vis[e[i].to] = true;
                    num[e[i].to]++;
                    if (num[e[i].to] == n + 1)
                        return false;
                }
            }
    }
    return true;
}
```

#### 2. 作者：傅天宇 (赞：31)
- **星级**：★★★★☆
- **关键亮点**：
  - 简洁明了地解释了如何将不等式转化为图的边。
  - 代码结构清晰，适合快速理解差分约束的基本实现。
  - 使用了链式前向星建图，代码简洁高效。
- **个人心得**：作者提到使用差分约束“水过”题目，强调了算法的简洁性。

**核心代码片段**：
```cpp
bool SPFA(int s) {
    memset(dis, 0x3f, sizeof dis);
    vis[s] = 1;
    dis[s] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        vis[u] = 0;
        for (int i = fir[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (dis[v] > dis[u] + e[i].val) {
                dis[v] = dis[u] + e[i].val;
                cnt[v]++;
                if (cnt[v] == n) return 0;
                if (vis[v] == 0) {
                    vis[v] = 1;
                    q.push(v);
                }
            }
        }
    }
    return 1;
}
```

#### 3. 作者：Energy_Making (赞：12)
- **星级**：★★★★☆
- **关键亮点**：
  - 详细分析了如何将不等式转化为图的边，并解释了SPFA的递推式。
  - 代码结构清晰，注释详细，适合深入学习差分约束。
  - 引入了超级源点，并详细解释了负环的判断方法。
- **个人心得**：作者强调了差分约束的递推式与SPFA的关系，帮助读者理解算法的本质。

**核心代码片段**：
```cpp
bool SPFA () {
    queue <int> q;
    int s = n + 1;
    for (int i = 1; i <= n; i++) dist[i] = inf;
    dist[s] = 0;
    sum[s] = 1;
    vis[s]++;
    q.push(s);
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        sum[cur] = 0;
        for (int p = head[cur]; p > 0; p = e[p].next)
            if (dist[e[p].val] > dist[cur] + e[p].len) {
                dist[e[p].val] = dist[cur] + e[p].len;
                vis[e[p].val]++;
                if (vis[e[p].val] >= n + 1) return true;
                if (!sum[e[p].val]) {
                    q.push(e[p].val);
                    sum[e[p].val] = 1;
                }
            }
    }
    return false;
}
```

### 最优关键思路与技巧

1. **差分约束转化**：将不等式转化为图的边，确保每个不等式对应一条有向边。
2. **超级源点**：引入超级源点确保图的连通性，避免图不连通导致的错误。
3. **SPFA优化**：使用SLF优化SPFA，减少运行时间。
4. **负环判断**：通过统计每个点的入队次数判断负环，入队次数超过节点数则存在负环。

### 拓展与举一反三

1. **同类型题目**：
   - [P1260 【模板】差分约束算法](https://www.luogu.com.cn/problem/P1260)
   - [P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)
   - [P1993 小 K 的农场](https://www.luogu.com.cn/problem/P1993)

2. **类似算法套路**：差分约束问题通常可以转化为图的最短路径问题，使用SPFA或Dijkstra算法求解。类似的问题还包括网络流、最小生成树等。

### 推荐题目

1. [P1260 【模板】差分约束算法](https://www.luogu.com.cn/problem/P1260)
2. [P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)
3. [P1993 小 K 的农场](https://www.luogu.com.cn/problem/P1993)

---
处理用时：41.82秒
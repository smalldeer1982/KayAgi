# 题目信息

# HXY造公园

## 题目描述

现在有一个现成的公园，有 $n$ 个休息点和 $m$ 条双向边连接两个休息点。众所周知，HXY 是一个 SXBK 的强迫症患者，所以她打算施展魔法来改造公园并即时了解改造情况。她可以进行以下两种操作：

1. 对某个休息点 $x$，查询公园中可以与该点互相到达的休息点组成的路径中的最长路径。
2. 对于两个休息点 $x,y$，如果 $x,y$ 已经可以互相到达则忽略此次操作。否则，在 $x$ 可到达的所有休息点和 $y$ 可到达的所有休息点（包括 $x,y$ 自身）分别选择一个休息点，然后在这两个休息点之间连一条边，并且这个选择应该满足对于连接后的公园，$x$ 和 $y$ 所在的区域（即 $x,y$ 可达到的所有休息点和边组成的集合）中的最长路径的长度最小。

HXY打算进行 $q$ 个操作，请你回答她的对于公园情况的询问（操作 1）或者执行她的操作（操作 2）。

注：所有边的长度皆为 $1$。保证不存在环。最长路径定义为：对于点 $v_1,v_2\cdots v_k$，如果对于其中任意的 $v_i$ 和 $v_{i+1}\quad (1\le i\le k-1)$，都有边相连接，那么 $v_j\quad(1\le j\le k)$ 所在区域的最长路径就是 $k-1$。


## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据，只存在操作 1。
- 对于 $30\%$ 的数据，$1\le m<n\le 20$，$1\le q\le5$。
- 对于 $60\%$ 的数据，$1\le m<n \le 2000$，$1\le q\le 1000$。
- 对于 $100\%$ 的数据，$1 \le m<n \le 3\times 10^5$，$1\le q\le 3\times 10^5$。


## 样例 #1

### 输入

```
6 0 6
2 1 2
2 3 4
2 5 6
2 3 2
2 5 3
1 1```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论

该题目要求在一个森林（多棵树）中进行两种操作：查询某棵树的最长路径（直径）和合并两棵树并使其合并后的直径最小。核心难点在于如何高效维护每棵树的直径，并在合并时快速计算新树的直径。

各题解普遍采用以下思路：
1. **并查集**：用于维护树的连通性，并在合并时快速找到根节点。
2. **树的直径**：通过DFS或BFS计算每棵树的直径，通常采用两次DFS/BFS的方法。
3. **合并策略**：合并两棵树时，选择两棵树直径的中点进行连接，确保新树的直径最小。

### 评分较高的题解

#### 1. 作者：Priori_Incantatem (5星)
**关键亮点**：
- **思路清晰**：详细解释了树的直径计算和合并策略，特别是对合并后直径的计算公式进行了详细推导。
- **代码可读性高**：代码结构清晰，注释详细，易于理解。
- **优化程度高**：通过并查集和树形DP高效处理查询和合并操作。

**个人心得**：
- 作者提到在合并时需要考虑原树的直径，否则会丢失部分信息，强调了公式推导的重要性。

**核心代码**：
```cpp
void dfs(int x, int fa) {
    int m1 = -1, m2 = -1;
    for (int i = 0; i < e[x].size(); ++i) {
        int y = e[x][i];
        if (y == fa) continue;
        dfs(y, x);
        int tmp = d[y] + 1;
        d[x] = max(d[x], tmp);
        if (tmp > m1) m2 = m1, m1 = tmp;
        else if (tmp > m2) m2 = tmp;
    }
    g[x] = max(max(0, m1 + m2), max(m1, m2));
    len = max(len, g[x]);
}
```

#### 2. 作者：caozy623 (4星)
**关键亮点**：
- **思路清晰**：详细解释了树的直径计算和合并策略，特别是对合并后直径的计算公式进行了详细推导。
- **代码可读性高**：代码结构清晰，注释详细，易于理解。
- **优化程度高**：通过并查集和树形DP高效处理查询和合并操作。

**核心代码**：
```cpp
void dfs(int x, int fa) {
    d1[x] = d2[x] = 0;
    for (int i = headers[x]; i; i = que[i].next)
        if (que[i].to != fa) {
            dfs(que[i].to, x);
            int now = d1[que[i].to] + 1;
            if (now > d1[x]) {
                d2[x] = d1[x];
                d1[x] = now;
            } else if (now > d2[x]) {
                d2[x] = now;
            }
        }
    diameter = max(diameter, d1[x] + d2[x]);
}
```

#### 3. 作者：Rusalka (4星)
**关键亮点**：
- **思路清晰**：详细解释了树的直径计算和合并策略，特别是对合并后直径的计算公式进行了详细推导。
- **代码可读性高**：代码结构清晰，注释详细，易于理解。
- **优化程度高**：通过并查集和树形DP高效处理查询和合并操作。

**核心代码**：
```cpp
void dfs(int u, int fa, int rt) {
    maxx[u][0] = maxx[u][1] = 0;
    for (int i = fir[u]; i; i = e[i].ne) {
        int v = e[i].to;
        if (v == fa) continue;
        dfs(v, u, rt);
        int now = maxx[v][0] + 1;
        if (now > maxx[u][1]) {
            if (now > maxx[u][0]) {
                maxx[u][1] = maxx[u][0];
                maxx[u][0] = now;
            } else maxx[u][1] = now;
        }
    }
    val[rt] = max(val[rt], maxx[u][0] + maxx[u][1]);
}
```

### 最优关键思路与技巧
1. **并查集**：用于高效维护树的连通性，并在合并时快速找到根节点。
2. **树的直径计算**：通过两次DFS/BFS计算每棵树的直径，确保高效性。
3. **合并策略**：选择两棵树直径的中点进行连接，确保新树的直径最小。

### 可拓展之处
- **类似题目**：可以扩展到其他需要维护树的结构和属性的题目，如树的重心、树的深度等。
- **算法套路**：并查集和DFS/BFS的结合在处理树的结构问题时非常常见，可以举一反三。

### 推荐题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
3. [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)

---
处理用时：37.01秒
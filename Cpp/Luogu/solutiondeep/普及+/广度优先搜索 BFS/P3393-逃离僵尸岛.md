# 题目信息

# 逃离僵尸岛

## 题目描述

小 a 住的国家被僵尸侵略了！小 a 打算逃离到该国唯一的国际空港逃出这个国家。


该国有 $N$ 个城市，城市之间有道路相连。一共有 $M$ 条双向道路。保证没有自环和重边。


其中 $K$ 个城市已经被僵尸控制了，如果贸然闯入就会被感染 TAT...所以不能进入。由其中任意城市经过不超过 $S$ 条道路就可以到达的别的城市，就是危险城市。换句话说只要某个城市到任意被僵尸控制的城市距离不超过 $S$，就是危险的。

小 a 住在 $1$ 号城市，国际空港在 $N$ 号城市，这两座城市没有被侵略。小a走每一段道路（从一个城市直接到达另外一个城市）得花一整个白天，所以晚上要住旅店。安全的的城市旅馆比较便宜要 $P$ 元，而被危险的城市，旅馆要进行安保措施，所以会变贵，为 $Q$ 元。所有危险的城市的住宿价格一样，安全的城市也是。在 $1$ 号城市和 $N$ 城市，不需要住店。


小 a 比较抠门，所以他希望知道从 $1$ 号城市到 $N$ 号城市所需要的最小花费。

输入数据保证存在路径，可以成功逃离。输入数据保证他可以逃离成功。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/2681.png) 

对于 $20\%$ 数据，$N\le 50$。

对于 $100\%$ 数据，$2\le N\le 10^5$，$1\le M\le 2\times 10^5$，$0\le K\le N - 2$，$0\le S\le 10^5$，$1\le P< Q\le 10^5$。


## 样例 #1

### 输入

```
13 21 1 1
1000 6000
7
1 2
3 7
2 4
5 8
8 9
2 5
3 4
4 7
9 10
10 11
5 9
7 12
3 6
4 5
1 3
11 12
6 7
8 11
6 13
7 8
12 13```

### 输出

```
11000```

# AI分析结果

### 综合分析与结论

该题目要求从起点到终点的最小花费，涉及多个被僵尸控制的城市及其周围危险城市的判定。题解中主要使用了BFS和Dijkstra/SPFA算法，核心思路是先通过BFS标记危险城市，再通过Dijkstra/SPFA计算最小花费。大部分题解都遵循了这一思路，但在实现细节、优化程度和代码可读性上有所差异。

### 所选高星题解

#### 1. 作者：fyfy (4星)
**关键亮点**：
- 思路清晰，详细解释了如何通过BFS标记危险城市，并通过SPFA计算最小花费。
- 代码结构清晰，注释详细，易于理解。
- 使用了邻接表存储图，优化了空间复杂度。

**个人心得**：
- 作者提到“被占点”有多个，不能直接求多次最短路，因此将所有被占点归纳为一个虚拟点，减少了计算量。

**核心代码**：
```cpp
void spfa(int now) {
    memset(vis, 0, sizeof(vis));
    for (int i = 1; i <= n; ++i) dis[i] = inf;
    while (!q.empty()) q.pop();
    q.push(now); dis[now] = 0; vis[now] = 1;
    while (!q.empty()) {
        int x = q.front();
        for (int i = o[x]; i; i = s[i][1]) {
            int y = s[i][0];
            if (dis[y] > dis[x] + w[i]) {
                dis[y] = dis[x] + w[i];
                if (!vis[y]) vis[y] = 1, q.push(y);
            }
        }
        vis[x] = 0; q.pop();
    }
}
```
**核心思想**：通过SPFA算法计算从起点到各点的最小花费，边权根据城市是否危险进行调整。

#### 2. 作者：浮梦若生 (4星)
**关键亮点**：
- 使用了Dijkstra（堆优化）+ BFS的组合，算法效率较高。
- 代码结构清晰，注释详细，易于理解。
- 通过BFS预处理危险城市，再通过Dijkstra计算最小花费。

**核心代码**：
```cpp
void BFS(int SUM) {
    while (Q2.size()) {
        int X = Q2.front(); Q2.pop();
        if (DIS[X] == SUM) continue;
        for (int I = HEAD[X]; I; I = NEXT[I]) {
            int Y = TO[I];
            if (!DIS[Y]) {
                DIS[Y] = DIS[X] + 1;
                Q2.push(Y);
            }
        }
    }
}
```
**核心思想**：通过BFS预处理危险城市，再通过Dijkstra计算最小花费。

#### 3. 作者：顾z (4星)
**关键亮点**：
- 使用了Dijkstra算法，并通过BFS预处理危险城市。
- 代码结构清晰，注释详细，易于理解。
- 通过BFS预处理危险城市，再通过Dijkstra计算最小花费。

**核心代码**：
```cpp
void dij() {
    for (R int i = 1; i <= n; i++) dis[i] = 21474836476666;
    priority_queue<hop> q;
    q.push((hop){1, 0}); dis[1] = 0;
    while (!q.empty()) {
        int u = q.top().u; q.pop();
        if (vis[u]) continue;
        vis[u] = true;
        for (R int i = head[u]; i; i = edge[i].u) {
            int v = edge[i].v;
            if (safe[v] == -1) continue;
            if (safe[v] == 0) {
                if (dis[v] > dis[u] + Q) {
                    dis[v] = dis[u] + Q;
                    q.push((hop){v, dis[v]});
                }
            }
            if (safe[v] == 1) {
                if (dis[v] > dis[u] + p) {
                    dis[v] = dis[u] + p;
                    q.push((hop){v, dis[v]});
                }
            }
        }
    }
}
```
**核心思想**：通过Dijkstra算法计算最小花费，边权根据城市是否危险进行调整。

### 最优关键思路与技巧

1. **BFS预处理危险城市**：通过BFS从被僵尸控制的城市出发，标记所有距离不超过S的城市为危险城市。
2. **Dijkstra/SPFA计算最小花费**：根据城市是否危险，调整边权，使用Dijkstra或SPFA计算从起点到终点的最小花费。
3. **虚拟点优化**：将多个被僵尸控制的城市归纳为一个虚拟点，减少计算量。

### 扩展思路与类似题目

1. **类似题目**：
   - [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
   - [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
   - [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

2. **拓展思路**：
   - 可以尝试使用A*算法进一步优化最短路径的计算。
   - 对于大规模数据，可以考虑使用双向BFS或IDA*算法进行优化。

---
处理用时：37.68秒
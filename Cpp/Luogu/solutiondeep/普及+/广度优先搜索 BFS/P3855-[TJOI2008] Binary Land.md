# 题目信息

# [TJOI2008] Binary Land

## 题目背景

Binary Land是一款任天堂红白机上的经典游戏，讲述的是两只相爱的企鹅Gurin和Malon的故事。两只企鹅在一个封闭的迷宫中，你可以控制他们向上下左右四个方向移动。但是他们的移动有一个奇怪的规则，即如果你按“上”或“下”方向键，两只企鹅会同时向上移动或向下移动1格；如果你按“左”方向键，则Malon向左移动1格，同时Gurin向右移动1格；如果你按“右”方向键，则Malon向右移动1格，Gurin向左移动1格。当然，如果某只企鹅被障碍挡住，它就不会移动了。另外，在迷宫的某些格子处有蜘蛛网，如果任何一只企鹅进入这种格子，则游戏失败。两只企鹅不会相互阻挡，即在相向运动时他们可以“穿过”彼此，也可以同时处于同一格子里。迷宫的某个格子上有一颗红心，游戏的任务就是使两只企鹅同时到达这个格子。

![](https://cdn.luogu.com.cn/upload/pic/6099.png)


## 题目描述

请编写程序找出完成任务所需的最少的操作步数。如果无法完成目标，输出“no”。


## 说明/提示

满足要求的一个操作序列为：上－右－左－左

3 ≤ R, C ≤ 30


## 样例 #1

### 输入

```
4 7
#######
#..T..#
#G##M##
#######
```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

本题的核心是通过BFS搜索两只企鹅同时到达目标点的最短路径。难点在于如何处理两只企鹅的移动规则（上下同向、左右反向）以及障碍物和蜘蛛网的限制。大多数题解都采用了BFS算法，并使用四维数组来记录两只企鹅的位置状态，以避免重复搜索。部分题解在代码实现上较为简洁，且对移动规则的处理更加清晰，值得参考。

### 所选高质量题解

#### 1. 作者：基地A_I (赞：7)
- **星级**：4.5
- **关键亮点**：
  - 使用四维数组记录状态，避免重复搜索。
  - 对移动规则的处理清晰，特别是左右移动时的反向操作。
  - 代码结构清晰，注释详细，便于理解。
- **个人心得**：作者提到“撞墙‘#’回来，蜘蛛网‘X’不可以走”，强调了处理障碍物和蜘蛛网的关键点。
- **核心代码**：
  ```cpp
  inline void update(int x1,int y1,int x2,int y2,int step) {
      q.push((Node){x1,y1,x2,y2,step});
      vis[x1][y1][x2][y2] = 1;
  }
  inline bool check(int x1,int y1,int x2,int y2) {
      if(x1>=1&&x1<=n&&y1>=1&&y1<=m && x2>=1&&x2<=n&&y2>=1&&y2<=m)
          if(map[x1][y1]!='X' && map[x2][y2]!='X' && !vis[x1][y1][x2][y2])
              return 1;
      return 0;
  }
  ```

#### 2. 作者：☯☯枫☯☯ (赞：4)
- **星级**：4
- **关键亮点**：
  - 预处理两只企鹅的移动方向，简化了BFS中的移动操作。
  - 使用结构体封装两只企鹅的位置和步数，代码简洁。
  - 对状态可行性检查的处理较为高效，直接修改状态以避免重复判断。
- **核心代码**：
  ```cpp
  inline bool check(int &x,int &y,int &a,int &b,P t) {
      if(pc[x][y]=='X'||pc[a][b]=='X'){
          vis[x][y][a][b]=1;
          return false;
      }
      if(pc[x][y]=='#')vis[x][y][a][b]=1,x=t.x,y=t.y;
      if(pc[a][b]=='#')vis[x][y][a][b]=1,a=t.a,b=t.b;
      if(vis[x][y][a][b])return false;
      vis[x][y][a][b]=1;
      return true;
  }
  ```

#### 3. 作者：Mr_罗 (赞：1)
- **星级**：4
- **关键亮点**：
  - 使用结构体封装两只企鹅的位置和步数，代码结构清晰。
  - 对移动规则的处理简洁，特别是左右移动时的反向操作。
  - 对障碍物和蜘蛛网的处理逻辑清晰，代码可读性强。
- **核心代码**：
  ```cpp
  bool check_way (int ggx, int ggy, int mmx, int mmy) {
      if (mp[ggx][ggy] == 'X' || mp[mmx][mmy] == 'X' || vis[ggx][ggy][mmx][mmy])
          return 0;
      return 1;
  }
  ```

### 最优关键思路与技巧

1. **四维状态数组**：使用四维数组记录两只企鹅的位置状态，避免重复搜索，是解决本题的关键。
2. **移动规则处理**：上下移动时两只企鹅同向，左右移动时反向，预处理移动方向可以简化BFS的实现。
3. **障碍物与蜘蛛网处理**：遇到障碍物时企鹅不移动，遇到蜘蛛网时直接跳过该状态，逻辑清晰且高效。

### 可拓展之处

本题的BFS算法可以拓展到其他多角色同时移动的迷宫问题，如多人在迷宫中寻找出口或目标点。类似的问题可以通过增加状态维度来记录多个角色的位置，从而进行搜索。

### 推荐相似题目

1. **P1162 填涂颜色**：考察BFS在迷宫中的应用，适合练习BFS的基本操作。
2. **P1443 马的遍历**：考察BFS在棋盘上的应用，适合练习BFS的扩展。
3. **P1135 奇怪的电梯**：考察BFS在状态转移中的应用，适合练习BFS的状态记录与转移。

---
处理用时：31.31秒
# 题目信息

# [NOIP 2017 普及组] 棋盘

## 题目背景

NOIP2017 普及组 T3

## 题目描述

有一个 $m \times m$ 的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。

任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、下、左、右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 $1 $ 个金币。

另外， 你可以花费 $2$ 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。

现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？


## 说明/提示

**样例 1 说明**

棋盘的颜色如下表格所示，其中空白的部分表示无色。

| $\color{red}\text{红}$ | $\color{red}\text{红}$ |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  | $\color{yellow}\text{黄}$ |  |  |  |
|  |  | $\color{yellow}\text{黄}$ | $\color{red}\text{红}$ |  |
|  |  |  | $\color{yellow}\text{黄}$ |  |
|  |  |  |  | $\color{red}\text{红}$ |


从 $(1,1)$ 开始，走到 $(1,2)$ 不花费金币。

从 $(1,2)$ 向下走到 $(2,2)$ 花费 $1$ 枚金币。

从 $(2,2)$ 施展魔法，将 $(2,3)$ 变为黄色，花费 $2$ 枚金币。

从 $(2,2)$ 走到 $(2,3)$ 不花费金币。

从 $(2,3)$ 走到 $(3,3)$ 不花费金币。

从 $(3,3)$ 走到 $(3,4)$ 花费 $1$ 枚金币。

从 $(3,4)$ 走到 $(4,4)$ 花费 $1$ 枚金币。

从 $(4,4)$ 施展魔法，将 $(4,5)$ 变为黄色，花费 $ 2$ 枚金币。

从 $(4,4)$ 走到 $(4,5)$ 不花费金币。

从 $(4,5)$ 走到 $(5,5)$ 花费 $1$ 枚金币。

共花费 $8 $ 枚金币。

**样例 2 说明**

棋盘的颜色如下表格所示，其中空白的部分表示无色。

| $\color{red}\text{红}$ | $\color{red}\text{红}$ |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  | $\color{yellow}\text{黄}$ |  |  |  |
|  |  | $\color{yellow}\text{黄}$ |  |  |
|  |  |  | $\color{white}\text{　}$ |  |
|  |  |  |  | $\color{red}\text{红}$ |

从 $( 1, 1)$ 走到 $( 1, 2)$，不花费金币。

从 $( 1, 2)$ 走到 $( 2, 2)$，花费 $ 1 $ 金币。

施展魔法将 $( 2, 3)$ 变为黄色，并从 $( 2, 2)$ 走到 $( 2, 3)$ 花费 $ 2$ 金币。

从 $( 2, 3)$ 走到 $( 3, 3)$ 不花费金币。

从 $( 3, 3)$ 只能施展魔法到达 $( 3, 2),( 2, 3),( 3, 4),( 4, 3)$。

而从以上四点均无法到达 $( 5, 5)$，故无法到达终点，输出$-1$。

**数据规模与约定**

对于 $30\%$ 的数据，$1 ≤ m ≤ 5, 1 ≤ n ≤ 10$。

对于 $60\%$ 的数据，$1 ≤ m ≤ 20, 1 ≤ n ≤ 200$。

对于 $100\%$ 的数据，$1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000$。


## 样例 #1

### 输入

```
5 7
1 1 0
1 2 0
2 2 1
3 3 1
3 4 0
4 4 1
5 5 0```

### 输出

```
8```

## 样例 #2

### 输入

```
5 5
1 1 0
1 2 0
2 2 1
3 3 1
5 5 0```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在棋盘上找到从起点到终点的最小金币花费路径，且需要考虑颜色变化和魔法的使用。题解中主要采用了以下几种思路：

1. **BFS + 优先队列优化**：通过优先队列优化BFS，确保每次扩展的路径是最优的，避免重复计算。这种方法的时间复杂度为 \(O(n \log n)\)，适合较大的数据范围。
2. **DFS + 记忆化优化**：通过DFS搜索所有可能的路径，并使用记忆化剪枝，避免重复计算。这种方法在数据范围较小时表现良好，但在大数据范围下可能会超时。
3. **最短路算法（Dijkstra）**：将棋盘转化为图，使用Dijkstra算法求解最短路。这种方法适合处理边权不固定的情况，且时间复杂度为 \(O(n \log n)\)。

### 所选高分题解

#### 1. ZigZagKmp (5星)
**关键亮点**：
- 使用优先队列优化的BFS，确保每次扩展的路径是最优的。
- 通过将魔法转化为额外的边权，简化了问题的处理。
- 代码结构清晰，注释详细，易于理解。

**个人心得**：
- 作者提到在考场上直接按照题意搜索会导致代码复杂且容易出错，因此通过转化题意简化了问题，大大降低了代码实现复杂度。

**核心代码**：
```cpp
void bfs() {
    memset(dis, 0x3f, sizeof(dis));
    dis[1][1] = 0;
    q.push((node){1, 1, a[1][1], dis[1][1]});
    node cur, nxt;
    while (!q.empty()) {
        cur = q.top(); q.pop();
        if (dis[cur.x][cur.y] < cur.w) continue;
        for (int i = 0; i < 12; i++) {
            nxt.x = cur.x + dx[i];
            nxt.y = cur.y + dy[i];
            nxt.w = cur.w + dw[i];
            if (nxt.x <= 0 || nxt.x > m || nxt.y <= 0 || nxt.y > m) continue;
            nxt.c = a[nxt.x][nxt.y];
            if (!nxt.c) continue;
            if (cur.c != nxt.c) nxt.w++;
            if (dis[nxt.x][nxt.y] > nxt.w) {
                dis[nxt.x][nxt.y] = nxt.w;
                q.push(nxt);
            }
        }
    }
}
```

#### 2. dxzier (4星)
**关键亮点**：
- 使用稀疏矩阵存储有效点，减少空间复杂度。
- 通过0/1 BFS优化，处理边权为0/1的情况，进一步优化了时间复杂度。
- 代码实现简洁，适合处理大数据范围。

**核心代码**：
```cpp
void bfs() {
    memset(dis, 0x3f, sizeof(dis));
    dis[1][1] = 0;
    q.push({1, 1, a[1][1], 0});
    while (!q.empty()) {
        node cur = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            int nx = cur.x + dx[i], ny = cur.y + dy[i];
            if (nx < 1 || nx > m || ny < 1 || ny > m || (cur.magic && a[nx][ny] == 0)) continue;
            int cost = (a[nx][ny] == cur.c) ? 0 : 1;
            if (a[nx][ny] == 0) cost = 2;
            if (dis[nx][ny] > cur.w + cost) {
                dis[nx][ny] = cur.w + cost;
                q.push({nx, ny, a[nx][ny], dis[nx][ny]});
            }
        }
    }
}
```

#### 3. lby_commandBlock (4星)
**关键亮点**：
- 使用分层图的思想，将状态定义为“坐标、颜色、是否使用魔法”，简化了状态转移。
- 通过SPFA算法处理边权不固定的情况，适合处理复杂的状态转移。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
void spfa() {
    memset(d, 0x3f, sizeof(d));
    d[1][1][0][a[1][1]] = 0;
    queue<node> q;
    q.push({1, 1, 0, a[1][1]});
    while (!q.empty()) {
        node cur = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            int nx = cur.x + dx[i], ny = cur.y + dy[i];
            if (nx < 1 || nx > m || ny < 1 || ny > m || (cur.k && a[nx][ny] == 0)) continue;
            int nk = (a[nx][ny] == 0) ? 1 : 0;
            int nw = (a[nx][ny] == cur.c) ? 0 : 1;
            if (a[nx][ny] == 0) nw = 2;
            if (d[cur.x][cur.y][cur.k][cur.c] + nw < d[nx][ny][nk][a[nx][ny]]) {
                d[nx][ny][nk][a[nx][ny]] = d[cur.x][cur.y][cur.k][cur.c] + nw;
                q.push({nx, ny, nk, a[nx][ny]});
            }
        }
    }
}
```

### 最优关键思路与技巧

1. **优先队列优化BFS**：通过优先队列确保每次扩展的路径是最优的，适合处理边权不固定的情况。
2. **分层图思想**：将状态定义为“坐标、颜色、是否使用魔法”，简化了状态转移，适合处理复杂的状态转移。
3. **稀疏矩阵存储**：通过稀疏矩阵存储有效点，减少空间复杂度，适合处理大数据范围。

### 可拓展之处

- **类似题目**：可以考虑类似的棋盘问题，如“迷宫中的最短路径”、“带有特殊规则的棋盘游戏”等。
- **算法套路**：优先队列优化的BFS和分层图思想可以应用于其他复杂状态转移的最短路问题。

### 推荐题目

1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
2. [P1073 最优贸易](https://www.luogu.com.cn/problem/P1073)
3. [P1948 [NOI2011] 道路修建](https://www.luogu.com.cn/problem/P1948)

---
处理用时：53.41秒
# 题目信息

# [USACO05DEC] Knights of Ni S

## 题目描述

贝茜遇到了一件很麻烦的事：她无意中闯入了森林里的一座城堡，如果她想回家，就必须穿过这片由骑士们守护着的森林。为了能安全地离开，贝茜不得不按照骑士们的要求，在森林寻找一种特殊的灌木并带一棵给他们。

当然，贝茜想早点离开这可怕的森林，于是她必须尽快完成骑士们给的任务，贝茜随身带着这片森林的地图，地图上的森林被放入了直角坐标系，并按 $x,y $ 轴上的单位长度划分成了 $ W \times H\  ( 1 \leq W,H \leq 1000 )$ 块，贝茜在地图上查出了她自己以及骑士们所在的位置，当然地图上也标注了她所需要的灌木生长的区域。某些区域是不能通过的（比如说沼泽地，悬崖，以及食人兔的聚居地）。在没有找到灌木之前，贝茜不能通过骑士们所在的那个区域，为了确保她自己不会迷路，贝茜只向正北、正东、正南、正西四个方向移动（注意，她不会走对角线）。她要走整整一天，才能从某块区域走到与它相邻的那块区域。

贝茜希望你能帮她计算一下，她最少需要多少天才可脱离这可怕的地方？输入数据保证贝茜一定能完成骑士的任务。

## 说明/提示

这片森林的长为 $8$，宽为 $4$．贝茜的起始位置在第 $3$ 行，离骑士们不远。

贝茜可以按这样的路线完成骑士的任务：北，西，北，南，东，东，北，东，东，南，南。她在森林的西北角得到一株她需要的灌木，然后绕过障碍把它交给在东南方的骑士。

## 样例 #1

### 输入

```
8 4
4 1 0 0 0 0 1 0
0 0 0 1 0 1 0 0
0 2 1 1 3 0 4 0
0 0 0 4 1 1 1 0
```

### 输出

```
11```

# AI分析结果

### 综合分析与结论

本题的核心是求从起点到灌木丛再到终点的最短路径，属于典型的BFS或分层图最短路径问题。大部分题解采用了BFS或双向BFS的思路，部分题解引入了分层图的概念。整体来看，题解的思路较为相似，但实现细节和优化程度有所不同。以下是对各题解的简要分析与评分。

### 评分较高的题解

#### 1. 作者：Wenoide (赞：19)
- **星级**：5星
- **关键亮点**：使用单次BFS，通过增加状态维度（是否取得灌木）来简化问题，代码简洁且高效。
- **核心思想**：通过`dis[x][y][0]`和`dis[x][y][1]`分别表示未取得灌木和已取得灌木的最短路径，避免了多次BFS的冗余计算。
- **代码片段**：
  ```cpp
  while(l!=r){
      Node t=que[l++];
      int x=t.x,y=t.y;
      bool tag=t.tag;
      if(x==ex&&y==ey&&tag) break;
      for(int i=0;i<4;++i){
          int u=x+dx[i],v=y+dy[i];
          bool w=tag||(map[u][v]==4);
          if(!vis[u][v][w]&&map[u][v]!=1){
              dis[u][v][w]=dis[x][y][tag]+1;
              vis[u][v][w]=true;
              que[r++]=make(u,v,w);
          }
      }
  }
  ```

#### 2. 作者：vеctorwyx (赞：12)
- **星级**：4星
- **关键亮点**：采用双向BFS，分别从起点和终点出发，最后枚举灌木丛求最短路径，思路清晰且易于理解。
- **核心思想**：通过两次BFS分别计算起点到灌木丛和灌木丛到终点的最短路径，最后取最小值。
- **代码片段**：
  ```cpp
  while(!q.empty()){
      qwq=q.front();
      if(a[qwq.x][qwq.y]==4&&ji1[qwq.x][qwq.y]==0){
          ji1[qwq.x][qwq.y]=qwq.tim;
          a[qwq.x][qwq.y]=0;
          q.pop();
          continue;
      }
      for(int i=1;i<=4;i++){
          qwq.x+=dx[i]; qwq.y+=dy[i]; qwq.tim++;
          if(qwq.x>0&&qwq.x<=n&&qwq.y>0&&qwq.y<=m&&(a[qwq.x][qwq.y]==0||a[qwq.x][qwq.y]==4)&&b[qwq.x][qwq.y]==0){
              q.push(qwq);
              b[qwq.x][qwq.y]=1;
          }
      }
      q.pop();
  }
  ```

#### 3. 作者：那一条变阻器 (赞：10)
- **星级**：4星
- **关键亮点**：引入分层图的概念，通过SPFA算法求解，适合对图论有一定基础的同学。
- **核心思想**：将问题转化为分层图的最短路径问题，通过SPFA算法求解，适合处理更复杂的图结构。
- **代码片段**：
  ```cpp
  void spfa(int k){
      memset(dis,127,sizeof(dis));
      memset(vis,0,sizeof(vis));
      queue<int> q;
      vis[k]=1; dis[k]=0; q.push(k);
      while(!q.empty()){
          int x=q.front(); q.pop();
          vis[x]=1;
          for(int i=0;i<e[x].size();i++){
              int nx=e[x][i];
              if(dis[nx]>dis[x]+1){
                  dis[nx]=dis[x]+1;
                  if(!vis[nx]){ vis[nx]=1; q.push(nx); }
              }
          }
      }
  }
  ```

### 最优关键思路与技巧

1. **状态扩展**：通过增加状态维度（如是否取得灌木）来简化问题，避免多次BFS的冗余计算。
2. **双向BFS**：分别从起点和终点出发，最后枚举中间点求最短路径，适用于起点和终点都已知的情况。
3. **分层图**：将问题转化为分层图的最短路径问题，适合处理更复杂的图结构。

### 可拓展之处

- **类似算法套路**：类似的问题可以扩展到多状态的最短路径问题，如带有多个条件的最短路径、带权图的最短路径等。
- **同类型题目**：可以尝试解决带有多个中间点的最短路径问题，或带有时间限制的最短路径问题。

### 推荐题目

1. **P1144 最短路计数**：考察BFS在最短路径中的应用。
2. **P1608 路径统计**：考察带权图的最短路径问题。
3. **P1073 最优贸易**：考察分层图的最短路径问题。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中遇到边界问题或状态标记错误，提醒我们在实现BFS时要特别注意边界条件和状态转移的正确性。
- **踩坑教训**：有题解提到在恢复灌木丛状态时忘记恢复，导致后续搜索出错，提醒我们在处理状态时要小心谨慎。
- **顿悟感想**：通过分层图或状态扩展的方式，可以将复杂问题简化，适合处理多条件的最短路径问题。

---
处理用时：37.76秒
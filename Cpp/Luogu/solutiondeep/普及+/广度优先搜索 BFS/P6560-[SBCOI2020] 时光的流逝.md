# 题目信息

# [SBCOI2020] 时光的流逝

## 题目背景

时间一分一秒的过着，伴随着雪一同消融在了这个冬天，  
或许，要是时光能停留在这一刻，该有多好啊。  
......    
“这是...我在这个小镇的最后一个冬天了吧。”  
“嗯，你可不能这辈子都呆在这个小镇吧。外面的世界很大呢，很大很大...”  
“唔...外面的世界...突然有点期待呢！”  
“总有一天，你会走得很远很远。以后你可不要忘记这个小镇那。”  
“不会的，至少...这里曾经是我最快乐的一段回忆呢！你也一定不要忘记我呀。”   
“你看，这雪花。传说，每当世界上有一份思念，便会化成一片雪花在这里飘落。”   
“那...以后你可一定要找到我的那片雪花啊......”  
![](https://cdn.luogu.com.cn/upload/image_hosting/orzntcy6.png)    
“嗯，不如我们一起在这个冬天创造最后一段回忆吧。”  
“好呀，我们玩个游戏吧......”  

## 题目描述

这个游戏是在一个有向图（不保证无环）上进行的。每轮游戏开始前，她们先在图上选定一个起点和一个终点，并在起点处放上一枚棋子。

然后两人轮流移动棋子，每次可以将棋子按照有向图的方向移动至相邻的点。

如果谁先将棋子移动至终点，那么谁就胜利了。同样，如果谁无法移动了，那么谁就失败了。

两人轮流操作，请问，他们是否有必胜策略呢？  

答案为一个整数 `0` 或 `1` 或 `-1`，其中 `1` 表示（先手）有必胜策略，`-1` 表示后手有必胜策略，`0` 表示两人均无必胜策略。

## 说明/提示

#### 样例解释 $#1$

![](https://cdn.luogu.com.cn/upload/image_hosting/k7q0qjrb.png)

为描述题意，假设两人为 A（先手）和 B

如图，A 先走，走到 $2$，B 走到 $3$，接下去 A 可以选择走到 $4$ 或 $6$，若走到 $4$，接下去 B 可以走到终点，故不可取。若选择走到 $6$，那么 B 只能走到 $7$，A 可以走到终点。所以 A 有必胜策略。

#### 样例解释 $#2$

![](https://cdn.luogu.com.cn/upload/image_hosting/9yjnyye3.png)

如图，起点为 $1$，终点为 $5$ 时， A 和 B 会沿着 $1-2-3-1$ 的顺序轮流走。因为如果谁先走到 $4$，那么下一个人就可以走到终点。故谁都没有必胜策略。

起点为 $4$，终点为 $3$ 时，A 先走到 $5$，B 无路可走，故 B 失败。

#### 数据范围

对于 $10\%$ 的数据，保证图是一条链。

对于 $50\%$ 的数据，$1\leq n\leq 10^3$，$1\leq m\leq 2\times10^3$，$1\leq q\leq 10$。

对于 $70\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 2\times10^5$，$1\leq q\leq 10$。

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 5\times10^5$，$1\leq q\leq 500$。

## 样例 #1

### 输入

```
7 7 1
1 2
2 3
3 4
4 5
3 6
7 5
6 7
1 5```

### 输出

```
1```

## 样例 #2

### 输入

```
5 5 2
1 2
2 3
3 1
3 4
4 5
1 5
4 3```

### 输出

```
0
1```

# AI分析结果

### 综合分析与结论

本题是一个典型的图上博弈论问题，核心在于通过拓扑排序和反向建图来标记每个点的必胜或必败状态。大多数题解都采用了类似的方法，即从终点和出度为0的点开始，逐步推导其他点的状态。主要难点在于处理有环图的情况，部分题解通过优化拓扑排序或引入额外的判断条件来解决这一问题。

### 所选高星题解

#### 1. **题解作者：犇犇犇犇 (5星)**
   - **关键亮点**：思路清晰，代码实现简洁且高效，详细解释了如何处理有环图的情况，并通过反向建图和拓扑排序优化了时间复杂度。
   - **个人心得**：作者提到在本地测试时时间复杂度较高，但在洛谷评测机上通过优化后表现良好，强调了优化的重要性。
   - **核心代码**：
     ```cpp
     void del(int u) {
         f[u]=1;
         for(int i=head[u];i;i=e[i].nxt) {
             int v=e[i].v;
             d[v]--;
             if(d[v]==0) q.push(v);
         }	
     }
     ```
     **实现思想**：通过删除已确定状态的点，逐步推导其他点的状态。

#### 2. **题解作者：duyi (4星)**
   - **关键亮点**：详细解释了如何处理有环图的情况，并通过拓扑排序和反向建图来标记每个点的状态。代码结构清晰，易于理解。
   - **核心代码**：
     ```cpp
     if(f[u]==1) {
         in[v]--;
         if(!in[v]) f[v]=-1,que.push(v);
     }
     else f[v]=1,que.push(v);
     ```
     **实现思想**：根据当前点的状态，更新其邻接点的状态，并通过队列进行拓扑排序。

#### 3. **题解作者：Mine_King (4星)**
   - **关键亮点**：通过反向建图和拓扑排序来标记每个点的状态，代码简洁且易于理解，详细解释了如何处理有环图的情况。
   - **核心代码**：
     ```cpp
     if(f[x]==1) {
         in[g.to[i]]--;
         if(!in[g.to[i]]) q.push(g.to[i]),f[g.to[i]]=-1;
     }
     else q.push(g.to[i]),f[g.to[i]]=1;
     ```
     **实现思想**：根据当前点的状态，更新其邻接点的状态，并通过队列进行拓扑排序。

### 最优关键思路与技巧

1. **反向建图**：通过反向建图，可以从终点和出度为0的点开始推导其他点的状态，避免直接处理有环图的问题。
2. **拓扑排序**：利用拓扑排序逐步推导每个点的状态，确保每个点的状态只被更新一次，避免重复计算。
3. **状态标记**：通过标记每个点的必胜或必败状态，逐步推导出起点的状态，最终得出答案。

### 可拓展之处

1. **类似算法套路**：这种通过反向建图和拓扑排序来推导状态的思路，可以应用于其他图上博弈论问题，如判断某个点是否为必胜点或必败点。
2. **优化技巧**：在处理大规模图时，可以通过优化拓扑排序或引入剪枝策略来减少时间复杂度。

### 推荐题目

1. **P2575 高手过招**：考察图上博弈论，通过拓扑排序和反向建图来推导每个点的状态。
2. **P2146 [NOI2015] 软件包管理器**：考察树上的博弈论，通过树形DP和拓扑排序来推导每个点的状态。
3. **P2483 [SDOI2010] 魔法猪学院**：考察图上博弈论，通过拓扑排序和反向建图来推导每个点的状态。

### 个人心得总结

- **调试经历**：部分作者提到在本地测试时时间复杂度较高，但在洛谷评测机上通过优化后表现良好，强调了优化的重要性。
- **踩坑教训**：处理有环图时，需要特别注意避免重复更新点的状态，否则会导致错误的结果。
- **顿悟感想**：通过反向建图和拓扑排序，可以有效地处理有环图的情况，推导出每个点的状态，最终得出答案。

---
处理用时：30.86秒
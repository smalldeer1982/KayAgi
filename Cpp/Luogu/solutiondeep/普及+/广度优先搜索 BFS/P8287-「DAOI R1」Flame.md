# 题目信息

# 「DAOI R1」Flame

## 题目背景

>尝尝天堂里的苹果有什么了不起，我要尝尝地狱里的苹果。

## 题目描述

黑暗里有黑色的火焰，只有目光敏锐的人才可以捕捉到,

借着这点卑微之光,走进地狱深处......

欢迎来到地狱的审判之地。

$ \texttt{hhpq.} $ 将 D 押入了地狱的审判之地，D 必须在业火之城成功生成一座业火监狱之前逃离，所以他想知道还有多少秒时间。

在这座业火之城中，共有 $n$ 个祭坛，共有 $m$ 条可以蔓延火苗的业火之路，且业火之路是双向连通。

已知在这一座业火之城共有 $k$ 个火种已被点燃的业火祭坛，且从第一秒开始，火种将开始从被点燃的业火祭坛向可以蔓延且未被点燃的业火祭坛蔓延。

当祭坛被点燃后，则会瞬间激活，和与之有路的祭坛连接业火圣壁。

当存在一片由业火圣壁构成的封闭图形时，则业火监狱生成成功。

### 简化题意
给出一个 $n$ 个点，$m$ 条边的无向图，每一个点有一个标记，初始有 $k$ 个点的标记为 `1`（将给出这 $k$ 个点的编号），其余的点标记为 `0`。

每一秒，对于每个标记为 `1` 的点，与它**有边相连**的点的标记都会变成 `1`。

求最少需要多少秒，图中标记为 `1` 的点与其相邻的边可以构成一个简单环。

**换言之，求最少多少秒后存在一个由 `1` 构成的集合形成简单环。**

## 说明/提示

### 样例解释

#### 样例1解释

当时间到第一秒时，祭坛 $1$ 的火焰将蔓延到祭坛 $2$ 和 $3$，此时已经构成一个封闭图形了，故答案为 $1$。

#### 样例2解释

可以证明到此时是无法产生简单环的。

### 数据规模

| Subtask | $n\leq$ | $m\leq$ | $k\leq$ | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $10^6$ | $n-1$ | $10^4$ | $5$ |
| $1$ | $10^6$ | $2\times10^6$ | $1$ | $10$|
| $2$ | $10$ | $45$ | $1$ | $5$ |
| $3$ | $200$ | $500$ | $10$ | $10$ |
| $4$| $2\times 10^3$ | $5\times 10^3$ | $50$ | $10$ |
| $5$ | $5\times10^5$ | $6\times10^5$ | $500$ | $30$ |
| $6$ | $10^6$ | $2\times10^6$ | $10^4$ | $30$ |

### 保证与约定

保证数据无重边和自环；

保证数据给定的图是一张无向连通图。

### 帮助

输入量较大，建议使用较为快速的读入方式。

## 样例 #1

### 输入

```
3 3 1
1 2
2 3
3 1
1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 4 2
1 2
2 3
3 4
2 5
1 5
```

### 输出

```
Poor D!
```

## 样例 #3

### 输入

```
15 15 2
2 1
2 3
2 9
5 9
4 5
5 7
6 7
7 8
7 11
11 10
10 9
10 14
14 15
11 12
12 13
4 15
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

这些题解的核心思路是通过广度优先搜索（BFS）模拟火焰蔓延的过程，并结合并查集或Tarjan算法来判断图中是否形成环。大多数题解采用了二分答案的策略，通过枚举时间来检查是否满足形成环的条件。部分题解还引入了记忆化优化和按秩合并等技巧，进一步提升了算法的效率。

### 所选高星题解

#### 1. **Augen_stern (5星)**
- **关键亮点**：提出了两种思路，一是通过统计联通块的边数和点数来判断环，二是直接使用Tarjan算法。代码简洁且思路清晰，优化了并查集的使用，避免了不必要的复杂度。
- **个人心得**：作者提到“二分其实是多余的”，并提出了直接模拟蔓延过程的优化思路，体现了对问题的深入理解。

```cpp
int find(int x){
	if(fa[x]==x) return x;
	fa[x]=find(fa[x]);
	return fa[x];
}
void merge(int a,int b){
	int x=find(a),y=find(b);
	if(x==y) return;
	if(rank[x]<=rank[y]) fa[x]=y,rank[y]=max(rank[y],rank[x]+1);
	else fa[y]=x,rank[x]=max(rank[x],rank[y]+1);
}
```

#### 2. **我是逍逍 (4星)**
- **关键亮点**：通过广搜模拟扩散过程，并使用并查集维护扩散源关系，代码结构清晰，易于理解。作者还特别提到“无解情况是原图为一棵树”，提供了清晰的边界条件处理。
- **个人心得**：作者提到“一看到环，立刻就想到了Tarjan算法”，虽然最终没有使用，但体现了对算法的敏感度。

```cpp
int father(int x) {
	if (f[x] == x) return x;
	return f[x] = father(f[x]);
}
```

#### 3. **Icyfires18 (4星)**
- **关键亮点**：通过BFS预处理每个点的染色时间，并结合并查集判断环的形成。代码实现较为完整，且引入了记忆化优化，提升了效率。
- **个人心得**：作者提到“搜到的第一个环不一定是正解”，强调了在搜索过程中需要不断更新答案。

```cpp
void bfs() {
	while (!q.empty()) {
		int x = q.front(); q.pop();
		for (auto y : g[x]) {
			if (dis[y] > dis[x] + 1) {
				dis[y] = dis[x] + 1;
				q.push(y);
			}
		}
	}
}
```

### 最优关键思路与技巧

1. **BFS模拟蔓延**：通过BFS预处理每个点的染色时间，确保在后续判断环时能够快速获取每个点的状态。
2. **并查集判环**：在枚举时间时，通过并查集判断是否形成环，避免了复杂的环检测算法。
3. **二分答案**：通过二分枚举时间，减少了不必要的计算，提升了算法的效率。
4. **记忆化优化**：在搜索过程中，通过记忆化优化，避免重复计算，进一步提升了算法的性能。

### 可拓展之处

- **类似算法套路**：这种通过BFS预处理状态，并结合并查集或Tarjan算法判断环的思路，可以应用于其他需要动态判断图结构的题目，如动态连通性问题。
- **同类型题目**：可以参考以下洛谷题目：
  1. [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)
  2. [P2863 [USACO06JAN]The Cow Prom S](https://www.luogu.com.cn/problem/P2863)
  3. [P2661 [NOIP2015 提高组] 信息传递](https://www.luogu.com.cn/problem/P2661)

### 个人心得总结

- **调试经历**：部分作者提到在实现过程中遇到了TLE问题，通过优化并查集和引入记忆化解决了问题。
- **踩坑教训**：一些作者提到“搜到的第一个环不一定是正解”，强调了在搜索过程中需要不断更新答案，避免过早结束搜索。
- **顿悟感想**：部分作者提到“二分其实是多余的”，体现了对问题的深入理解和优化思路的灵活应用。

---
处理用时：33.21秒
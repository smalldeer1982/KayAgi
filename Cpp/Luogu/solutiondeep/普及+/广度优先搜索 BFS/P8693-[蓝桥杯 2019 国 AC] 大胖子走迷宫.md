# 题目信息

# [蓝桥杯 2019 国 AC] 大胖子走迷宫

## 题目描述

小明是个大胖子，或者说是个大大胖子，如果说正常人占用 $1\times1$ 的面积，小明要占用 $5\times5$ 的面积。

由于小明太胖了，所以他行动起来很不方便。当玩一些游戏时，小明相比小伙伴就吃亏很多。小明的朋友们制定了一个计划，帮助小明减肥。计划的主要内容是带小明玩一些游戏，让小明在游戏中运动消耗脂肪。走迷宫是计划中的重要环节。

朋友们设计了一个迷宫，迷宫可以看成是一个由 $n\times n$ 个方阵组成的方阵，正常人每次占用方阵中 $1\times1$ 的区域，而小明要占用 $5\times5$ 的区域。小明的位置定义为小明最正中的一个方格。迷宫四周都有障碍物。为了方便小明，朋友们把迷宫的起点设置在了第 $3$ 行第 $3$ 列，终点设置在了第 $n-2$ 行第 $n-2$ 列。

小明在时刻 $0$ 出发，每单位时间可以向当前位置的上、下、左、右移动单位 $1$ 的距离，也可以停留在原地不动。小明走迷宫走得很辛苦，如果他在迷宫里面待的时间很长，则由于消耗了很多脂肪，他会在时刻 $k$ 变成一个胖子，只占用 $3\times3$ 的区域。如果待的时间更长，他会在时刻 $2\times k$ 变成一个正常人，只占用 $1\times1$ 的区域。注意，当小明变瘦时迷宫的起点和终点不变。

请问，小明最少多长时间能走到迷宫的终点。注意，小明走到终点时可能变瘦了也可能没有变瘦。

## 说明/提示

对于 $30 \%$ 的评测用例, $1 \leq n \leq 50$。

对于 $60 \%$ 的评测用例, $1 \leq n \leq 100$。

对于所有评测用例, $1 \leq n \leq 300$，$1 \leq k \leq 1000$。

蓝桥杯 2019 年国赛 A 组 F 题（C 组 I 题）。

## 样例 #1

### 输入

```
9 5
+++++++++
+++++++++
+++++++++
+++++++++
+++++++++
***+*****
+++++++++
+++++++++
+++++++++
```

### 输出

```
16```

# AI分析结果

### 综合分析与结论

本题的核心是通过BFS求解小明在迷宫中从起点到终点的最短时间，难点在于小明随着时间的推移会变瘦，导致其占用的区域大小发生变化。大多数题解采用了BFS算法，并通过不同的优化手段（如原地等待、状态压缩、优先队列等）来处理小明体型变化的问题。部分题解还引入了二维前缀和、循环队列等优化技巧，以提升算法效率。

### 所选高质量题解

#### 1. 作者：DreamLand_zcb (5星)
**关键亮点**：
- 使用了BFS算法，并通过原地等待的方式处理小明体型变化的问题。
- 通过`check`函数判断小明当前位置是否合法，代码结构清晰。
- 优化了原地等待的条件，避免无意义的等待。

**核心代码**：
```cpp
bool check(int x, int y, int size) {
    if(vis[x][y]) return false;
    for(int i=x-size;i<=x+size;i++)
        for(int j=y-size;j<=y+size;j++)
            if(i < 1 || i > n || j < 1 || j > n || a[i][j])
                return false;
    return true;
}
```
**实现思想**：通过双重循环检查小明占用的区域是否合法，确保没有障碍物和越界情况。

#### 2. 作者：wuhan1234 (4星)
**关键亮点**：
- 使用循环队列优化BFS，避免队列过大导致内存问题。
- 通过`flag`变量表示小明体型的变化，简化了状态判断。
- 代码结构清晰，优化了原地等待的条件。

**核心代码**：
```cpp
bool pd(int nx, int ny, int nstep, bool mode) {
    bool flag = true;
    if(nstep < k) {
        if(!(nx+2 <= n && nx-2 > 0 && ny-2 > 0 && ny+2 <= n) && mode)
            flag = false;
        else if(pre[nx+2][ny+2] - pre[nx+2][ny-3] - pre[nx-3][ny+2] + pre[nx-3][ny-3] != 0)
            flag = false;
    }
    return flag;
}
```
**实现思想**：通过二维前缀和优化判断小明占用的区域是否有障碍物，减少了时间复杂度。

#### 3. 作者：_Yonder_ (4星)
**关键亮点**：
- 通过三次BFS分别处理小明不同体型的情况，思路清晰。
- 通过`check`函数判断小明当前位置是否合法，代码结构清晰。
- 优化了原地等待的条件，避免无意义的等待。

**核心代码**：
```cpp
inline bool check(int x, int y, int v) {
    if(x-v <= 0 || x+v > n || y-v <= 0 || y+v > n || f[x][y][v] > -1) return false;
    for(int i = -v; i <= v; i++)
        for(int j = -v; j <= v; j++)
            if(c[i+x][j+y] == '*') return false;
    return true;
}
```
**实现思想**：通过双重循环检查小明占用的区域是否合法，确保没有障碍物和越界情况。

### 最优关键思路与技巧

1. **BFS算法**：通过广度优先搜索求解最短路径，适用于迷宫类问题。
2. **原地等待优化**：在小明体型变化时，通过原地等待的方式减少不必要的移动。
3. **二维前缀和**：通过预处理二维前缀和，快速判断小明占用的区域是否有障碍物。
4. **优先队列**：通过优先队列优化BFS，确保每次扩展的节点是最优的。

### 可拓展之处

- **类似算法套路**：可以应用于其他动态变化的迷宫问题，如随时间变化的障碍物或移动的敌人。
- **优化技巧**：二维前缀和、循环队列等优化技巧可以应用于其他需要快速判断区域合法性的问题。

### 推荐题目

1. **P1443 马的遍历**：考察BFS在棋盘上的应用，适合练习BFS的基本实现。
2. **P1162 填涂颜色**：考察BFS在二维矩阵中的应用，适合练习区域判断。
3. **P1135 奇怪的电梯**：考察BFS在动态变化环境中的应用，适合练习动态BFS的实现。

### 个人心得摘录

- **调试经历**：部分题解提到在调试过程中发现原地等待的条件设置不当，导致程序超时或错误，最终通过优化条件解决了问题。
- **踩坑教训**：在判断小明占用的区域是否合法时，忽略了边界条件，导致程序出错，最终通过双重循环检查解决了问题。
- **顿悟感想**：通过优先队列优化BFS，确保每次扩展的节点是最优的，大大提高了程序的效率。

---
处理用时：34.10秒
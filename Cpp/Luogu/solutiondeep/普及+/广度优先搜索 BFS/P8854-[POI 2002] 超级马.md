# 题目信息

# [POI 2002] 超级马

## 题目描述

在一个大小为无限的棋盘上有一个超级马，它可以完成各种动作。

每一种动作包含两个整数，第一个数说明上下移动的数，第二个数说明左右移动的数，移动马来完成这个动作。（数字均为正数向右，负数向左）

请你对每一个输入的超级马进行确认，看它是否可以到达棋盘上的每一个地方。

## 说明/提示

数据范围：$1 \le K,N \le 100,-100 \le P,Q \le 100$。

## 样例 #1

### 输入

```
2
3
1 0
0 1
-2 -1
5
3 4
-3 -6
2 -2
5 6
-1 4```

### 输出

```
TAK
NIE```

# AI分析结果

### 综合分析与结论

本题的核心在于判断超级马是否能够通过给定的移动方式到达棋盘上的任意位置。大多数题解采用了BFS或DFS的搜索算法，结合数学中的裴蜀定理来简化问题。关键思路是将问题转化为判断超级马是否能够到达起点周围的四个相邻点（即上下左右），因为如果能到达这四个点，那么通过组合这些移动方式，超级马可以到达任意位置。

### 精选题解

#### 1. 作者：CDFLS_mao_zx (赞：16)  
**星级：5星**  
**关键亮点：**  
- 从线性代数和多元一次方程的角度深入分析了问题，提供了数学上的严谨证明。
- 通过辗转相除法简化了问题的复杂度，结合极角排序进一步优化了算法。
- 代码实现清晰，逻辑严密，具有较高的可读性和优化程度。

**核心代码：**
```cpp
int main(){
    scanf("%d",&T);
    st: while(T--){
        scanf("%d",&n);
        for(i=1;i<=n;++i){
            scanf("%d%d",&x,&y);
            N[i]={x,y,atan2(y,x)};
        }
        if(n<=2){printf("No\n");goto st;}
        sort(N+1,N+n+1); N[n+1]=N[1];
        for(i=1;i<=n;++i){
            if((d=N[i+1].at-N[i].at)<0) d+=2*pi;
            if(d>=pi){printf("No\n");goto st;}
        }
        for(a=N[1],i=2,y=0;i<=n;++i){
            b=N[i];
            while(b.x){
                t=a; a=b; x=t.x/b.x;
                b={t.x-x*b.x,t.y-x*b.y,0};
            } 
            y=__gcd(y,b.y);
        }
        if(abs(a.x)!=1||abs(y)!=1) printf("No\n");
        else printf("Yes\n");
    }
    return 0;
}
```
**核心思想：** 通过极角排序和辗转相除法，判断超级马是否能够生成所有可能的移动向量。

#### 2. 作者：Dregen_Yor (赞：8)  
**星级：4星**  
**关键亮点：**  
- 通过BFS直接判断超级马是否能够到达四个关键点，思路清晰且易于理解。
- 结合裴蜀定理，进一步优化了判断条件，减少了不必要的计算。

**核心代码：**
```cpp
bool solve(){
    queue <int>qx,qy;
    qx.push(100),qy.push(100);
    v[100][100]=1;
    int sum=0;
    while(!qx.empty()){
        int x=qx.front(),y=qy.front();
        qx.pop();qy.pop();
        sum++;
        for(int i=1;i<=n;i++){
            int nx=x+dx[i],ny=y+dy[i];
            if(nx>=0&&nx<=200&&ny>=0&&ny<=200&&!v[nx][ny]){
                v[nx][ny]=1;
                qx.push(nx),qy.push(ny);
            }
            if(v[101][100]&&v[100][101]&&v[99][100]&&v[100][99]){
                return true;
            }
        }
    }
    if(v[101][100]&&v[100][101]&&v[99][100]&&v[100][99]){
        return true;
    }
    return false;
}
```
**核心思想：** 通过BFS遍历所有可能的移动路径，判断是否能够到达四个关键点。

#### 3. 作者：qinsishi (赞：6)  
**星级：4星**  
**关键亮点：**  
- 通过BFS结合剪枝策略，减少了搜索空间，提高了算法效率。
- 代码结构清晰，易于理解和实现。

**核心代码：**
```cpp
void bfs() {
    bool vis[2*N][2*N] = {0};
    queue<pair<int, int> > que;
    que.push({100, 100});
    vis[100][100] = 1;
    while (que.size()) {
        int x=que.front().first, y=que.front().second;
        que.pop();
        if (vis[100][99] && vis[100][101] && vis[99][100] && vis[101][100]) {
            print(1);
            return;
        }
        for (int i=1; i<=n; ++i) {
            int xx = x+fang[i].first;
            int yy = y+fang[i].second;
            if (0 > xx || xx > 200 || 0 > yy || yy > 200) continue;
            if (vis[xx][yy]) continue;
            vis[xx][yy] = 1;
            que.push({xx, yy});
        }
    }
    print(0);
}
```
**核心思想：** 通过BFS结合剪枝策略，判断超级马是否能够到达四个关键点。

### 最优关键思路与技巧

1. **问题转化：** 将“能否到达所有点”转化为“能否到达四个关键点（上下左右）”，大大简化了问题。
2. **数学优化：** 结合裴蜀定理，判断移动向量的最大公约数是否为1，进一步优化了判断条件。
3. **搜索算法：** 使用BFS或DFS进行遍历，结合剪枝策略，减少搜索空间，提高算法效率。

### 可拓展之处

- **类似问题：** 类似的问题可以扩展到更高维度的棋盘，或者移动方式更加复杂的场景。
- **算法套路：** 结合数学定理（如裴蜀定理）与搜索算法，可以解决更多类似的组合优化问题。

### 推荐题目

1. [P3951 小凯的疑惑](https://www.luogu.com.cn/problem/P3951)  
2. [P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)  
3. [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)  

### 个人心得总结

- **调试经历：** 在实现BFS时，需要注意数组下标的处理，避免越界或负数下标导致的错误。
- **踩坑教训：** 在剪枝时，需要确保剪枝条件不会遗漏可能的解，否则会导致错误结果。
- **顿悟感想：** 通过数学定理与搜索算法的结合，可以大大简化问题的复杂度，提高算法的效率。

---
处理用时：43.02秒
# 题目信息

# [KMOI R1] 军事行动

## 题目背景

$$\blue{他们来了。}$$

$$\purple{集结军队，干掉他们，一个不留。}$$

$$\blue{是！}$$

## 题目描述

喵星边境局势愈发紧张，导致发生边境冲突。喵星军队总司令小袁立即对 $Y$ 星采取军事行动。

整个宇宙可以看作一个平面直角坐标系，城市 $1,2,\dots,n$ 的坐标分别为 $(x_1,y_1),(x_2,y_2),\dots(x_n,y_n)$。

现在小袁率领的**若干支**舰队（可以理解为小袁的军事力量是无限的）驻扎在边境要塞，城市 $1$ 处。他的舰队会进行以下移动：

- 如果舰队的坐标为 $(x,y)$，那么一天之后它可以移动到 $(x-1,y+2)$ 或 $(x+1,y+2)$ 或 $(x+2,y+1)$ 或 $(x-2,y+1)$ 或 $(x-1,y-2)$ 或 $(x+1,y-2)$ 或 $(x+2,y-1)$ 或 $(x-2,y-1)$ 处。

其中环绕在外的还有一条小行星带，当舰队的坐标  $(x,y)$ 且 $x\le 0$ 或 $y\le 0$ 或 $m < x$ 或 $m < y$ 时，舰队就会撞到小行星带。这是小袁所不想看到的。

现在小袁要攻打城市 $2,3,\dots,n$，每一次他都会从一个**已经占领**的城市（城市 $1$ 也算），派出舰队前往城市 $i$ 并攻打它，舰队**到达之后的第二天**城市 $i$ 就被攻占了。

特别的，小袁在一个舰队**前往攻打或攻打一个城市**的时候不会派出另外一支舰队，在**攻占一座城市后当天**可以立即派出另外一支舰队。

小袁想问，最少要花多少时间才能攻占所有的城市。

**攻打顺序可以不按照 $2,3\dots n$ 的顺序。**

## 说明/提示

## 样例一解释：

舰队在第一天来到了 $(3,2)$ 的位置，第二天到达了城市 $2$ 的位置，第三天占领了城市 $2$。总共花了 $3$ 天。

## 样例二解释：

舰队在第一天到达了城市 $2$ 的位置，第二天占领了城市 $2$。第三天到达了城市 $3$ 的位置，第四天占领了城市 $3$。总共花了 $4$ 天。

## 数据范围

**本题采用 Subtask 捆绑测试。**

|子任务编号|  测试点编号| $n$ | $m$ |特殊性质|分值|
|:-----:| :----------: | :----------: | :----------: | :----------: |:---:|
|$1$| $1\sim2$ | $1\le n\le 7$ |$4\le m\le 7$|无|$10$|
|$2$| $3\sim7$ | $1\le n\le 200$ |$4\le m\le 70$|无|$25$|
|$3$| $8\sim9$ | $1\le n\le 150$ |$4\le m\le 150$|有|$15$|
|$4$| $10\sim20$ | $1\le n\le 2000$ |$4\le m\le 150$|无|$50$|

特殊性质：对于每一个 $1\le i\le n-1$，都有 $x_i = x_{i+1}$。

**数据严格保证不会有不同的城市拥有相同的坐标。**

## 样例 #1

### 输入

```
2 20
1 1
1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
3 150
1 2
2 4
4 3```

### 输出

```
4```

## 样例 #3

### 输入

```
10 10
1 4
2 3
2 6
3 6
10 3
1 5
4 2
5 3
2 8
9 2```

### 输出

```
23```

## 样例 #4

### 输入

```
查看附件的 example4.in```

### 输出

```
查看附件的 example4.out```

# AI分析结果

### 综合分析与结论

本题的核心问题是通过“马走日”的方式在二维平面上移动，找到从起点到所有城市的最短路径，并最终计算攻占所有城市的最小时间。大多数题解都采用了**BFS**来计算每两个城市之间的最短路径，并结合**最小生成树**（如Kruskal或Prim算法）来求解最小总时间。整体思路较为一致，但实现细节和优化程度有所不同。

### 所选高星题解

#### 1. 作者：Fire_flame (5星)
- **关键亮点**：思路清晰，代码结构简洁，使用了BFS预处理所有城市之间的最短路径，并结合Kruskal算法求解最小生成树。代码可读性强，时间复杂度分析明确。
- **个人心得**：作者提到BFS时每个点入队时就要标记为走过，避免重复遍历，这一点在实际调试中非常重要。
- **核心代码**：
```cpp
void bfs(int sx, int sy){
    queue<step>q;
    q.push({sx, sy, 0});
    memset(f, 0, sizeof(f));
    f[sx][sy] = 1;
    while(!q.empty()){
        int tx = q.front().x, ty = q.front().y, tl = q.front().len;
        q.pop();
        for(int i = 0;i < 8;i ++){
            int px = tx + dx[i], py = ty + dy[i];
            if(f[px][py] || px <= 0 || py <= 0 || px > m || py > m)continue;
            if(mp[px][py])e[++ cnt] = {mp[sx][sy], mp[px][py], tl + 1};
            f[px][py] = 1;
            q.push({px, py, tl + 1});
        }
    }
}
```
- **实现思想**：通过BFS遍历所有可能的移动路径，记录每个城市之间的最短距离，并将其作为边的权重，最后使用Kruskal算法生成最小生成树。

#### 2. 作者：_Flame_ (4星)
- **关键亮点**：通过数学推导直接计算两点之间的最短步数，避免了BFS的重复遍历，优化了时间复杂度。代码结构清晰，思路独特。
- **核心代码**：
```cpp
int get(int x,int y){
    x=abs(x),y=abs(y);
    if(x>y) swap(x,y);
    if(y==1&&x==0) return 3;
    if(y==2&&x==2) return 4;
    int res=y-x;
    if(x>res) return res-2*floor(1.0*(res-x)/3.0);
    else return res-2*floor(1.0*(res-x)/4.0);
}
```
- **实现思想**：通过数学公式直接计算两点之间的最短步数，避免了BFS的重复遍历，优化了时间复杂度。

#### 3. 作者：TruchyR (4星)
- **关键亮点**：使用了Prim算法，结合BFS动态更新最短路径，代码简洁且时间复杂度较低。作者提到调试时发现搜索比最小生成树快了10倍，强调了优化的重要性。
- **核心代码**：
```cpp
void bfs(int tx,int ty){
    queue<GP> q;
    q.push({tx,ty});
    memset(vis,0,sizeof vis);
    vis[tx][ty]=1;
    while(!q.empty()){
        GP now=q.front();q.pop();
        for(auto o:fx){
            int dx=now.first+o[0],dy=now.second+o[1];
            if(dx<1 || dy<1 || dx>m || dy>m) continue;
            if(vis[dx][dy]) continue;
            vis[dx][dy]=1;
            f[dx][dy]=f[now.first][now.second]+1;
            q.push({dx,dy});
        }
    }
}
```
- **实现思想**：通过BFS动态更新每个城市到其他城市的最短路径，结合Prim算法生成最小生成树。

### 最优关键思路与技巧

1. **BFS预处理最短路径**：通过BFS遍历所有可能的移动路径，记录每两个城市之间的最短距离，作为最小生成树的边权。
2. **最小生成树算法**：使用Kruskal或Prim算法，结合预处理的最短路径，求解最小总时间。
3. **数学优化**：通过数学公式直接计算两点之间的最短步数，避免BFS的重复遍历，优化时间复杂度。

### 可拓展之处

- **类似问题**：类似的问题可以扩展到其他移动规则（如“象走田”或“车走直线”）或更高维度的空间（如三维网格）。
- **算法套路**：BFS预处理最短路径 + 最小生成树的组合可以应用于其他需要连接多个点并最小化总代价的问题。

### 推荐题目

1. **P3366 【模板】最小生成树**：练习最小生成树的基本应用。
2. **P1144 最短路计数**：结合BFS和最短路径的计数问题。
3. **P2296 寻找道路**：BFS与图论结合的经典问题。

### 个人心得总结

- **调试经验**：BFS时每个点入队时就要标记为走过，避免重复遍历，这一点在实际调试中非常重要。
- **优化意识**：搜索比最小生成树快了10倍，强调了优化的重要性，尤其是在大规模数据下。
- **数学思维**：通过数学公式直接计算最短步数，避免了BFS的重复遍历，优化了时间复杂度。

---
处理用时：36.86秒
# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果

这道题主要围绕神经网络模型展开，给定神经网络结构及输入层状态，需计算输出层状态。各题解思路、要点及难点对比如下：
1. **思路**：多数题解采用拓扑排序，因为神经网络是有向无环图（DAG），神经元状态由上一层推导而来，符合拓扑排序特性。少数题解使用记忆化搜索、BFS等方法，本质也是利用图的层次结构进行状态传递计算。
2. **算法要点**：读入数据时处理阈值，部分题解在输入时直接减去阈值；建图使用邻接表、邻接矩阵等方式；利用队列、栈或直接暴力找入度为0的点进行拓扑排序；按公式计算神经元状态，注意只有兴奋状态（\(C_i>0\)）的神经元才传递信号；最后输出出度为0且状态大于0的神经元。
3. **解决难点**：输入层阈值处理，部分题解发现输入层阈值无用或应特殊处理；处理负权值及神经元状态为负的情况，确保状态小于等于0的神经元不传递信号；输出时判断是否有满足条件的输出，若没有则输出“NULL”。

以下是对各题解的简要评分：
1. **Lucaster\_**：思路清晰，详细讲解每部分代码，代码有更新优化，可读性高。5星
2. **zzlzk**：分析公式和拓扑排序原因到位，代码用栈实现拓扑排序有独特性，但整体讲解稍简略。4星
3. **ghj1222**：阐述用拓扑排序原因，指出坑点，但代码注释较少，可读性一般。3星
4. **faker121**：讲述做题经历，用裸拓扑排序和建图，思路常规，代码中规中矩。3星
5. **dingcx**：适合新手，详细分析变量、函数及坑点，但代码相对繁琐。3星
6. **teafrogsf**：简洁实现拓扑排序，代码友好，但思路讲解简略。3星
7. **MakotoTSK**：提到BFS和拓扑排序思路，但代码注释少，对阈值处理说明不足。3星
8. **封禁用户**：强调拓扑排序处理先后关系，代码实现较常规，讲解较简单。3星
9. **hibiki**：吐槽题意不清，用BFS遍历图并处理细节，但代码较冗长。3星
10. **2233颗GoldenEgg**：详细讲述拓扑排序思路及注意事项，代码数组使用较多，稍显复杂。3星
11. **无言独上机房**：采用不同阈值处理方式，代码用向量实现，思路较独特但讲解不够清晰。3星
12. **奶油青豆烧鱼**：反向建图用记忆化搜索，思路新颖，但对搜索过程讲解不足。3星
13. **AuCloud**：分析题意用BFS，代码实现较完整，但部分变量命名较随意。3星
14. **利刃随人**：未用拓扑排序，直接枚举边计算，思路简单但代码可读性一般。2星
15. **AnChun999**：从输入点向上找能量来源再传递，代码实现较清晰，但思路不是主流。3星
16. **OIer991215**：代码简短，未用复杂写法，但对思路和代码解释不够详细。2星
17. **QwQ2000**：用模拟方法，代码较详细，但整体思路和实现较常规。3星
18. **empty\_zhm**：从DAG和拓扑dp角度分析，代码用指针实现链式前向星，对新手有难度。3星
19. **LetMyself**：用BFS实现，思路清晰，但代码细节处理可进一步优化。3星
20. **万万没想到**：用递归预处理和递推暴力求解，时间复杂度较高，讲解较详细。3星
21. **liuxu**：自创分层入队法，思路独特但较难理解，代码实现较复杂。3星
22. **森海塞尔**：代码类似BFS，但逻辑较混乱，注释和讲解可进一步完善。2星
23. **封癫**：用搜索思想，代码结构较清晰，但对搜索过程解释不够详细。3星
24. **YZ亮晶晶**：详细列出坑点和思路，但使用Pascal语言代码，受众较少。3星
25. **ShawnZhou**：分析使用拓扑排序原因，代码实现规范，但整体讲解创新性不足。3星
26. **maorui\_cow**：强调邻接矩阵初始化注意事项，思路和代码较常规。3星
27. **【天朝】MILK**：分析神经节点影响关系，用双端队列维护出度为零的点列，思路较独特。3星
28. **jrxc**：拓扑排序加公式计算，代码实现较简洁，但对阈值处理说明可更详细。3星
29. **ghmgjf**：用队列实现较麻烦，代码逻辑较混乱，讲解较难理解。2星
30. **Yorathgz**：按拓扑序计算，代码实现较清晰，但对思路阐述较简略。3星
31. **shadowice1984**：着重讲审题，代码用邻接矩阵和拓扑排序，实现较常规。3星
32. **Dispwnl**：讲解拓扑排序思路和注意事项，代码实现较常规，注释较少。3星
33. **xun薰**：先正着建边DFS，再反向建边计算状态，思路较复杂，代码实现较繁琐。3星
34. **attack**：讲述思路和坑点，代码实现较常规，对坑点处理有一定参考价值。3星
35. **理想气体**：暴力做法，思路较复杂，代码冗长，对思路解释较详细。3星
36. **翠竹叶飞**：用队列保证层序处理，代码实现较清晰，但对细节处理可进一步优化。3星
37. **Kwork**：按拓扑序传递信息，注意输入点阈值处理，代码实现较完整。3星

所选4星及以上题解：
- **Lucaster\_**：
  - 星级：5星
  - 关键亮点：思路讲解极为详细，从读入处理、建图、拓扑处理到记录答案，每个步骤都有细致说明，并配有代码注释。代码有冗余部分的分析及更新优化，便于读者理解和学习。
  - 个人心得引用：“这道题是我练习拓扑的第一道题，本来想找个标程比着学习一下的，但是大佬们的码风都好清奇……蒟蒻我直接看不懂……于是我发誓要写一份简单易懂的拓扑代码，调了一天终于调出来了。”
  - 核心代码片段（更新后AC代码）：
```cpp
#include<queue>
#include<cstdio>
#include<algorithm>
#define N 101
using namespace std;
struct edge{
    int to,val,nxt;
} e[N*N];
struct answer{
    int id,val;
} ans[N];
int h,i,m,n,t,u,v,w,U,c[N],hd[N],out[N],vis[N];
queue <int> q;
int cnt=0,flag=0;
inline bool cmp(answer aa,answer bb)
{return aa.id<bb.id;}
inline void build(int u,int v,int w)
{
    cnt++;
    e[cnt].to=v;
    e[cnt].val=w;
    e[cnt].nxt=hd[u];
    hd[u]=cnt;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
    {
        vis[i]=out[i]=0;
        scanf("%d%d",&c[i],&U);
        if(c[i]>0)
        {q.push(i);vis[i]=1;}
        else c[i]-=U;
    }
    for(i=1;i<=m;i++)
    {
        scanf("%d%d%d",&u,&v,&w);
        build(u,v,w);
        out[u]=1;
    }
    while(!q.empty())
    {
        h=q.front();q.pop();
        if(c[h]<=0) continue;
        for(i=hd[h];i;i=e[i].nxt)
        {
            t=e[i].to;
            c[t]+=e[i].val*c[h];
            if(!vis[t])
            {
                q.push(t);
                vis[t]=1;
            }
        }
    }
    for(i=1;i<=n;i++)
        if(!out[i]&&c[i]>0)
        {printf("%d %d\n",i,c[i]);flag=1;}
    if(!flag) {puts("NULL");return 0;}
    return 0;
}
```
  - 核心实现思想：通过邻接表建图，读入时将初始状态大于0的点入队并标记，同时处理阈值。在拓扑排序过程中，从队列取出点，若该点状态大于0，则更新其邻接点状态并将未入队的邻接点入队。最后输出出度为0且状态大于0的点，若没有则输出“NULL”。
- **zzlzk**：
  - 星级：4星
  - 关键亮点：对题目中的公式进行深入分析，通过移项得出可以在输入时直接减去阈值的结论，并且清晰阐述了使用拓扑排序的原因，代码用栈实现拓扑排序，有别于常见的队列实现方式。
  - 核心代码片段（拓扑排序部分）：
```cpp
void topo() {
    while(top!=0) {
        int u=st[top--];
        if(C[u]<=0) {
            for(int i=head[u];i;i=edge[i].next) {
                int v=edge[i].v;
                indeg[v]--;
                if(indeg[v]==0) st[++top]=v;
            }
            continue;
        }
        for(int i=head[u];i;i=edge[i].next) {
            int v=edge[i].v;
            C[v]+=C[u]*edge[i].w;
            indeg[v]--;
            if(indeg[v]==0) st[++top]=v;
        }
    }
    return;
}
```
  - 核心实现思想：利用栈进行拓扑排序，每次从栈顶取出一个点，若该点状态小于等于0，则仅更新其邻接点的入度；若该点状态大于0，则更新其邻接点状态并更新邻接点入度，当邻接点入度为0时将其入栈。

最优关键思路或技巧：
1. **拓扑排序**：利用拓扑排序处理有向无环图中节点状态的推导关系，确保在计算某节点状态时，其依赖的上一层节点状态已计算完成。
2. **阈值处理技巧**：通过对公式的分析，将阈值在输入时直接减去，简化后续计算。
3. **状态传递判断**：明确只有兴奋状态（\(C_i>0\)）的神经元才传递信号，在状态更新过程中加入此判断，避免无效计算。

可拓展之处：此类题目属于图论中基于有向无环图的状态推导问题，相似算法套路包括在DAG上进行动态规划、拓扑排序结合其他算法解决更复杂的问题。例如，在一些任务调度问题中，任务之间存在先后依赖关系，可构建DAG并用拓扑排序确定任务执行顺序；在一些电路模拟问题中，元件之间的信号传递也可类似建模求解。

推荐考察相似知识点的洛谷题目：
1. **P1983 车站分级**：通过分析列车停靠站点关系构建有向图，利用拓扑排序确定车站等级，考察拓扑排序的应用及对图的理解。
2. **P3387 【模板】缩点**：涉及有向图的强连通分量缩点后进行拓扑排序，综合考察强连通分量算法和拓扑排序的结合使用。
3. **P2762 太空飞行计划问题**：通过构建二分图，利用拓扑排序等方法解决资源分配和任务选择的问题，考察对图论模型的构建和拓扑排序的运用。 

---
处理用时：115.17秒
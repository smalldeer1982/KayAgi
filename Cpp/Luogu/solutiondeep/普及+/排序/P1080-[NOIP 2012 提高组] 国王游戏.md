# 题目信息

# [NOIP 2012 提高组] 国王游戏

## 题目描述

恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。


## 说明/提示

【输入输出样例说明】

按 $1$、$2$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $1$、$3$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $2$、$1$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按$ 2$、$3$、$1 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$；

按 $3$、$1$、$2 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；  

按$ 3$、$2$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$。

因此，奖赏最多的大臣最少获得 $2$ 个金币，答案输出 $2$。


 
【数据范围】

对于 $20\%$ 的数据，有 $1≤ n≤ 10,0 < a,b < 8$；

对于 $40\%$ 的数据，有$ 1≤ n≤20,0 < a,b < 8$；

对于 $60\%$ 的数据，有 $1≤ n≤100$；

对于 $60\%$ 的数据，保证答案不超过 $10^9$；

对于 $100\%$ 的数据，有 $1 ≤ n ≤1,000,0 < a,b < 10000$。



NOIP 2012 提高组 第一天 第二题


## 样例 #1

### 输入

```
3 
1 1 
2 3 
7 4 
4 6 ```

### 输出

```
2```

# AI分析结果

• **综合分析与结论**：这些题解均采用贪心算法解决该问题，核心思路是通过邻项交换法证明按照大臣左右手上数字乘积 \(a_i\times b_i\) 从小到大排序，能使获得奖赏最多的大臣所获奖赏尽可能少。由于数据范围较大，都涉及高精度运算来处理乘积和除法。不同题解在证明过程、代码实现细节以及高精度运算的处理方式上存在差异。

**思路**：均基于贪心策略，通过比较相邻大臣不同排列顺序下的奖赏情况，得出按 \(a_i\times b_i\) 排序的结论。
**算法要点**：对大臣数据按 \(a_i\times b_i\) 排序，再通过高精度运算计算每个大臣的奖赏并找出最大值。
**解决难点**：难点在于证明贪心策略的正确性以及高精度运算的实现。证明过程需严谨推导相邻项交换前后的大小关系；高精度运算要处理好乘法、除法以及结果的比较和存储。

• **所选的题解**
  - **作者：洛必达法则 (5星)**
    - **关键亮点**：对贪心算法的证明极为严谨，通过详细的数学推导，先证明任意相邻两项按 \(a\)、\(b\) 之积升序排列所得结果小于等于降序排列所得结果，再利用引理证明要使前 \(n\) 项奖励最大值最小，需依据 \(a_i\times b_i\) 排序。无个人心得。
  - **作者：「QQ红包」 (4星)**
    - **关键亮点**：贪心部分简洁明了，直接得出大臣排列的比较条件。高精度部分采用压位优化，提高运算速度。个人心得：强调高精度部分压位能使运算更快。
```cpp
bool cmp(node aa,node bb)
{
    if (aa.x*aa.y==bb.x*bb.y) return aa.y<bb.y;
    return (aa.x*aa.y)<(bb.x*bb.y);
}
// 高精度乘法
void cheng(int d)
{
    for (int i=1;i<=m;i++)
        sum[i]*=a[d].x;
    for (int i=1;i<=m;i++)
    {
        sum[i+1]+=sum[i]/10000;
        sum[i]%=10000;
    }
    if (sum[m+1]!=0) m++;
}
// 高精度除法
void div(int d)
{
    memset(ans,0,sizeof(ans));
    ls=1;
    while (m>0&&sum[m]==0) m--;
    P=0;
    int flag=0;
    for (int i=m;i>=1;i--)
    {
        P=P*10000+sum[i];
        ans[++ls]=P/a[d].y;
        if (ans[ls]==0&&!flag) ls--; else flag=1;
        P%=a[d].y;
    }
}
```
  - **作者：frankchenfu (4星)**
    - **关键亮点**：先猜测可能的排序方式，再通过具体计算和证明得出按 \(a_ib_i\) 排序的结论。高精度运算封装巧妙，采用压4位，模数取 \(10^4\) 的方式，乘除法处理简洁。个人心得：认为高精度运算在此题中实现较为方便，且 `print()` 函数写法有技巧。
```cpp
struct bign{
    const int BASE=1e4;
    int a[MAXN<<2],len;
    bign(int len=0){
        this->len=len;
    }
    bign operator=(int rhs){
        len=0;
        if(rhs==0){
            len=1;
            return *this;
        }
        while(rhs){
            a[++len]=rhs%BASE;
            rhs/=BASE;
        }
        return *this;
    }
    bign operator=(const bign rhs){
        memcpy(a,rhs.a,sizeof(rhs.a));
        len=rhs.len;
        return *this;
    }
    void operator*=(const int rhs){
        for(int i=1;i<=len;i++)
            a[i]*=rhs;
        for(int i=1;i<=len;i++){
            a[i+1]+=a[i]/BASE;
            a[i]%=BASE;
            if(i+1>len&&a[i+1])
                len++;
        }
        while(len&&a[len]==0)
            len--;
    }
    bign operator/(const int rhs){
        bign c;c=*this;
        while(c.len&&c.a[c.len]==0)
            c.len--;
        for(int i=c.len;i;i--){
            c.a[i-1]+=(c.a[i]%rhs)*BASE;
            c.a[i]/=rhs;
        }
        while(c.len&&c.a[c.len]==0)
            c.len--;
        return c;
    }
    void print(){
        while(len&&a[len]==0)
            len--;
        if(len==0){
            putchar('0');
            return;
        }
        printf("%d",a[len]);
        for(int i=len-1;i;i--)
            printf("%04d",a[i]);
    }
    bool operator>(const bign &rhs)const{
        if(len!=rhs.len)
            return len>rhs.len;
        for(int i=len;i;i--)
            if(a[i]!=rhs.a[i])
                return a[i]>rhs.a[i];
        return 0;
    }
}mul,ans;

struct node{
    int a,b;
    bool operator<(const node &rhs)const{
        return a*b<rhs.a*rhs.b||(a*b==rhs.a*rhs.b&&a<rhs.a);
    }
}p[MAXN];
```
• **最优关键思路或技巧**：
  - **思维方式**：通过邻项交换法分析相邻元素不同排列对结果的影响，从而确定整体的贪心策略，这是解决此类排序优化问题的常用思维。
  - **代码实现技巧**：在高精度运算中，采用压位的方式，如将数字按 \(10^4\) 为单位存储，减少数组长度，提高运算效率，同时简化代码实现。

• **可拓展之处**：同类型题常考察贪心策略在排序优化问题中的应用，类似算法套路是通过分析局部（如相邻元素）的最优情况，推导得出整体的最优排序方式。之后遇到此类问题，可尝试从相邻元素入手，分析不同排列的结果差异，确定贪心策略。

• **相似知识点洛谷题目**
  - **P1248 加工生产调度**：同样涉及通过贪心策略对任务进行排序，以优化生产时间。
  - **P1090 [NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G**：通过贪心选择每次合并代价最小的果子堆，与本题通过贪心确定最优排列顺序类似。
  - **P2859 [USACO06DEC] Milk Patterns G**：在处理序列问题时，运用贪心思想结合其他算法来解决问题，与本题思路有相通之处。

• **个人心得摘录与总结**：
  - **作者：「QQ红包」**：强调高精度部分压位能使运算更快，在实现高精度运算时可采用此优化技巧。
  - **作者：frankchenfu**：认为高精度运算在此题中实现较为方便，且 `print()` 函数写法有技巧，提示在处理高精度输出时可探索更好的实现方式。 

---
处理用时：59.83秒
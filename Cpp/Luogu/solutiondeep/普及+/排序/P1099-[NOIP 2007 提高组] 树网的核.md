# 题目信息

# [NOIP 2007 提高组] 树网的核

## 题目描述

设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。

路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 
$d(a, b)$ 为 $a, b$ 两结点间的距离。

$D(v, P)=\min\{d(v, u)\}$, $u$ 为路径 $P$ 上的结点。

树网的直径：树网中最长的路径成为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

偏心距 $\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即

$$\mathrm{ECC}(F)=\max\{D(v, F),v \in V\}$$

任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)


## 说明/提示

- 对于 $40\%$ 的数据，保证 $n \le 15$。
- 对于 $70\%$ 的数据，保证 $n \le 80$。
- 对于 $100\%$ 的数据，保证 $2\le n \le 300$，$0\le s\le10^3$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^3$。

NOIP2007 提高组第四题

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕在无根树中找直径上长度不超$s$且使偏心距最小的路径这一问题。思路上，有的直接枚举所有路径（不依赖先求直径），有的先求直径再在直径上找路径；算法上，有枚举、双指针、二分等不同方法；解决难点在于理解树的直径、偏心距等概念及相关性质，并据此优化算法。

### 所选的题解
- **作者：StudyingFather（5星）**
    - **关键亮点**：对树的直径等性质进行详细证明，如多直径必交于一点、直径中点唯一等。提供多种解法并逐步优化，从$O(n^3)$的枚举到$O(n)$的双指针 + 前缀和，思路清晰，代码实现完整且通过`namespace`隔离不同解法便于对比。
    - **个人心得**：无
    - **核心代码片段（解法四）**：
```cpp
namespace sub4 {
void solve() {
    for (int i = 1; i <= cnt; i++) vis[dia[i]] = true;
    int maxd = 0;
    for (int i = 1; i <= cnt; i++) {
        dep[dia[i]] = 0, c = 0;
        dfs(dia[i], 0);
        maxd = max(dep[c], maxd);
    }
    int l = 1, r = 1;
    int minecc = 1 << 30;
    for (; l <= cnt; l++) {
        while (r <= cnt && pres[r + 1] - pres[l] <= s) r++;
        minecc = min(max(maxd, max(pres[l], posts[r])), minecc);
    }
    cout << minecc << endl;
}
}
```
    - **核心实现思想**：先求出直径及直径上各点引出最长支链长度的最大值`maxd`。通过双指针枚举直径上路径，利用前缀和`pres`和`posts`分别记录从直径起点和终点到当前点的距离，动态更新并取`maxd`、`pres[l]`、`posts[r]`中的最大值与当前最小偏心距`minecc`比较取最小值。
- **作者：Mosklia（4星）**
    - **关键亮点**：对直径性质理解深刻，指出对于直径上任意点，到其距离最远的点是直径端点。通过两次DFS求直径，用单调队列优化枚举直径上路径端点的过程，将时间复杂度从$O(n^2)$优化到$O(n)$，代码实现思路清晰。
    - **个人心得**：强调即使数据范围水也要尽力优化，以获取经验。
    - **核心代码片段**：
```cpp
std::deque<int> q; 
int ans = 2147483647; 
for(int i = 1, j = 1; i <= m; dist2 -= pt[del[i]].fa_dist, ++i) {
    pt[del[i]].cur_dist = dist2; 
    while(!q.empty() && pt[q.front()].cur_dist - s > pt[del[i]].cur_dist)
        q.pop_front();
    while(j < i && tot - dist1 - dist2 > s)
        dist1 += pt[del[j++]].fa_dist;
    while(!q.empty() && pt[q.back()].dist < pt[del[i]].dist)
        q.pop_back();
    q.push_back(del[i]);
    int temp = std::max(dist1, dist2);
    temp = std::max(temp, pt[q.front()].dist);
    ans = std::min(temp, ans); 
}
```
    - **核心实现思想**：用单调队列`q`维护直径上路径点的第二种贡献值（不经过路径上其他点所能到达的最远点的距离），在双指针移动过程中，动态更新`dist1`（到起始端点的距离）和`dist2`（到终止端点的距离），取`dist1`、`dist2`和单调队列前端点的贡献值中的最大值与当前最小偏心距`ans`比较取最小值。
- **作者：天泽龟（4星）**
    - **关键亮点**：提出$O(nlogn)$的二分解法，详细证明二分的正确性及单调性，考虑支链对答案的影响并确定二分边界。通过以直径端点向内部递推找到满足偏心距限制的核端点，判断核长度是否满足要求。
    - **个人心得**：写题和题解花费较长时间，期间钻牛角尖，提醒不要死磕题目。
    - **核心代码片段（`check`函数）**：
```cpp
ll drop(ll u,ll fa,ll x)  {
    for (ll i=fir[u];i;i=e[i].nex)
    if (v[e[i].u]) {
        if (e[i].u==fa) continue;
        l1+=e[i].w; if (l1>x) return u;
        else return drop(e[i].u,u,x);
    }
}

ll up(ll u,ll x)  {
    while (u!=A&&l2+w[u]<=x) l2+=w[u],u=f[u][0]; 
    return u;
}

bool check(ll x) {
    l1=l2=0; p=drop(A,0,x); q=up(B,x); 
    return (d[q]-d[p]<=s);
}
```
    - **核心实现思想**：`drop`函数从直径一端点`A`向下递归找到距离不超`x`（二分的偏心距）的最远节点`p`，`up`函数从直径另一端点`B`向上跳找到距离不超`x`的最远节点`q`，最后判断`p`和`q`的距离是否小于等于`s`，以此作为二分答案的判断依据。

### 最优关键思路或技巧
 - **性质利用**：利用树直径的性质，如所有直径必交于一点、直径中点唯一等，简化问题求解。确定最优路径一定在某条直径上，从而缩小搜索范围。
 - **双指针优化**：在枚举直径上路径时，利用双指针技巧减少候选最优路径数量，降低时间复杂度。
 - **二分答案**：将最优化问题转化为存在性问题，通过二分偏心距，结合直径和支链的关系确定二分边界，高效求解。

### 可拓展思路
此类题目属于树上路径相关问题，类似套路有先分析树的特殊性质，再根据问题特点选择合适算法。如涉及到最值问题可考虑二分答案；枚举过程可通过双指针、单调队列等优化。同类型题常围绕树的直径、中心、路径距离等概念展开。

### 相似知识点洛谷题目
 - **P1396 营救**：同样是树上路径问题，涉及到在树上找满足一定条件的路径，可类比本题思路分析树的结构和路径性质。
 - **P2680 运输计划**：需要在树上分析路径长度及最值问题，通过二分答案和树上差分等方法解决，与本题在解题思路上有相似之处。
 - **P3398 仓鼠找sugar**：关于树上两点路径及距离的问题，通过分析树的结构和路径关系求解，锻炼对树相关概念和算法的运用能力。 

---
处理用时：58.96秒
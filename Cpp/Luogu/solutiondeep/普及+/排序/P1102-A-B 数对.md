# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效求解满足A - B = C的数对个数展开，涉及多种思路和算法。
1. **算法思路**：
    - **映射统计法**：将A - B = C转化为A - C = B，用map等方式统计每个数出现的次数，遍历数组计算满足条件的数对个数，如作者OsvaldoAsensioLopez、Drifterming等的题解。
    - **二分查找法**：先将数组排序，利用二分查找lower_bound和upper_bound确定满足条件的数的位置，计算数对个数，时间复杂度O(nlogn)，如作者樱花飞舞、Cambridge等的题解。
    - **双指针法**：排序后通过双指针维护满足条件的区间，计算数对个数，如作者jins3599的题解。
    - **哈希表法**：通过哈希函数将数映射到哈希表中，减少空间浪费，同时统计数的出现次数，如作者Ajwallet的题解。
2. **解决难点**：主要难点在于如何在给定的较大数据规模下，选择合适的数据结构和算法优化，避免暴力枚举导致的超时问题。不同算法通过空间换时间、排序后利用数据有序性等方式来解决。
3. **简要评分**：
    - **5星**：
        - OsvaldoAsensioLopez：思路清晰，代码简洁，直接利用map统计解决问题，核心代码如下：
```cpp
#include <iostream>
#include <map>
using namespace std;
typedef long long LL;
LL a[200001];
map<LL,LL> m;
int main() {
    int n;
    LL c;
    LL ans=0;
    cin >> n >> c;
    for(int i=1;i<=n;i++) {
        cin >> a[i];
        m[a[i]]++;
        a[i]-=c;    
    } 
    for(int i=1;i<=n;i++) ans+=m[a[i]];
    cout << ans << endl;
    return 0;
}
```
核心思想是先统计每个数出现的次数，再遍历数组计算满足A - C = B的数对个数。
        - 樱花飞舞：详细介绍二分查找相关函数及应用，代码简洁，逻辑清晰，利用二分查找函数计算满足条件的数对个数，核心代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
long a[200001];
long N,C,ans;
int main()
{
    cin>>N>>C;
    for(int i=1;i<=N;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+N+1);
    for(int i=1;i<=N;i++)
    {
        ans+=((upper_bound(a+1,a+N+1,a[i]+C)-a)-(lower_bound(a+1,a+N+1,a[i]+C)-a));
    }
    cout<<ans;
    return 0;
}
```
核心思想是排序后，对每个数利用二分查找函数计算满足条件的数对个数。
    - **4星**：
        - jins3599：提出双指针法，利用排序后数组的有序性，通过双指针维护区间，计算满足条件的数对个数，代码简洁，核心代码如下：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2e5 + 10;
int n, c;
int a[N];
int main () 
{
	cin >> n >> c;
	for(int i = 1 ; i <= n ; i ++) cin >> a[i];
	sort(a + 1, a + 1 + n);
	int l = 1, r1 = 1, r2 = 1;
	ll ans = 0;
	for(l = 1 ; l <= n ; l ++) {
		while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
		while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
		if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
			ans += r1 - r2;
	}
	cout << ans;
	return 0;
}
```
核心思想是排序后，通过双指针移动找到满足条件的区间，计算数对个数。

### 最优思路或技巧
1. **数学转化**：将A - B = C转化为A - C = B，简化问题求解思路。
2. **数据结构选择**：根据数据规模和特点选择合适的数据结构，如map用于统计次数，在数据范围大时避免开过大数组；哈希表进一步优化空间使用。
3. **利用有序性**：通过排序使数据有序，进而利用二分查找、双指针等方法优化算法，降低时间复杂度。

### 可拓展之处
同类型题常考察对数组中元素关系的统计，类似算法套路有：
1. 对于涉及元素差值、和值等关系的问题，可尝试数学转化，再结合合适的数据结构和算法优化求解。
2. 若数据有序，多考虑二分查找、双指针等利用有序性的算法；若数据无序且范围大，哈希表、map等数据结构可能是突破口。

### 相似知识点洛谷题目
1. P2249 【深基13.例1】查找：考察二分查找的基本应用。
2. P1106 删数问题：可通过双指针思想结合贪心策略解决。
3. P3370 【模板】字符串哈希：涉及哈希表在字符串中的应用，与本题哈希表思路类似。

### 个人心得摘录与总结
部分作者提到在处理大数据时，暴力枚举会超时，需要优化算法，如使用map、二分查找等方式。还有作者在使用数组计数时遇到空间限制问题，从而考虑哈希表等优化空间的方法。总结来看，做题时要充分考虑数据规模对算法的影响，及时调整思路，选择合适的数据结构和算法优化方案。 

---
处理用时：48.40秒
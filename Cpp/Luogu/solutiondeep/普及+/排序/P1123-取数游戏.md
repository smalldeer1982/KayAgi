# 题目信息

# 取数游戏

## 题目描述

一个 $N\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。

## 说明/提示

### 样例解释

对于第一组数据，取数方式如下：

$$\begin{matrix}
[67] & 75 & 63 & 10 \\
29 & 29 & [92] & 14 \\
[21] & 68 & 71 & 56 \\
8 & 67 & [91] & 25 \\
\end{matrix}$$


### 数据范围及约定

- 对于$20\%$的数据，$1\le N, M \le 3$；
- 对于$40\%$的数据，$1\le N, M\le 4$；
- 对于$60\%$的数据，$1\le N, M\le 5$；
- 对于$100\%$的数据，$1\le N, M\le 6$，$1\le T\le 20$。


## 样例 #1

### 输入

```
3
4 4
67 75 63 10
29 29 92 14
21 68 71 56
8 67 91 25
2 3
87 70 85
10 3 17
3 3
1 1 1
1 99 1
1 1 1

```

### 输出

```
271
172
99
```

# AI分析结果

### 综合分析与结论
这些题解主要采用深度优先搜索（DFS）和状态压缩动态规划（状压DP）两种算法。
 - **DFS思路**：对矩阵每个位置的数考虑取或不取两种状态，通过标记数组记录周围已取数的情况，避免选取相邻数，搜索完所有情况后取最大和。
 - **状压DP思路**：利用二进制表示每行的取数状态，预处理出合法状态，通过状态转移方程计算每行不同状态下能取到的最大和。
 - **解决难点**：DFS要合理处理状态标记与回溯，避免重复或遗漏情况；状压DP需准确设计状态、状态转移方程及预处理合法状态。
 - **质量评估**：多数DFS题解思路和代码较简单直接，优化程度低；状压DP题解复杂度更低，但思路和代码实现相对复杂。

### 所选的题解
 - **作者：绿萧 (赞：200)  星级：4星**
    - **关键亮点**：思路清晰，先排除贪心和普通动态规划，依据数据范围确定DFS算法，详细分析每个数的状态及标记方式，代码注释详细。
    - **个人心得**：无
    - **核心代码**：
```cpp
void dfs(int x,int y){//搜索函数，表示搜索点(x,y) 
    if(y==m+1){//当y到边界时，搜索下一行 
        dfs(x+1,1);
        return;
    }
    if(x==n+1){//当x到边界时，搜索结束，刷新最大值 
        mx=max(ans,mx);
        return;
    }
    
    dfs(x,y+1);// 不取此数的情况 
    
    if(mark[x][y]==0){ //取此数的情况（需保证此数周围没有取其他数，即mark[i][j]==0）
        ans+=s[x][y];
        for(int fx=0;fx<8;++fx){ //标记周围的数 
            ++mark[x+d[fx][0]][y+d[fx][1]];
        }
        dfs(x,y+1);
        for(int fx=0;fx<8;++fx){ //回溯 
            --mark[x+d[fx][0]][y+d[fx][1]];
        }
        ans-=s[x][y];
    }
    
}
```
核心思想：以(x, y)为当前搜索点，y到边界则搜下一行，x到边界则更新最大值。对当前点有取和不取两种决策，取数时标记周围点，搜索完回溯。
 - **作者：IntrepidStrayer (赞：23)  星级：4星**
    - **关键亮点**：采用状压DP，思路独特清晰，详细阐述状态设计、预处理合法状态及状态转移方程，时间复杂度分析准确。
    - **个人心得**：无
    - **核心代码**：
```cpp
bool check1(int x){
    for(;x;x>>=1)if((x&3)==3)return false;
    return true;
}
bool check2(int x,int y){
    return!(x&(y<<1))&&!(x&y)&&!(x&(y>>1));
}
int calc(int i,int x){//求sum(i,j)
    int res=0;
    for(rei j=m;j>=1&&x;--j,x>>=1)if(x&1)res+=a[i][j];
    return res;
}
//...
for(rei i=0;i<(1<<m);++i) 
    if(check1(i))c[++cnt]=i;//预处理
for(rei i=1;i<=n;++i)//DP部分
    for(rei j=1;j<=cnt;++j){
        v=0;
        for(rei k=1;k<=cnt;++k)
            if(check2(c[j],c[k]))
                v=max(v,f[i-1][k]);
        f[i][j]=calc(i,c[j])+v;
    }
```
核心思想：check1函数预处理出每行合法状态，check2函数判断相邻两行状态是否合法，calc函数计算当前行按某状态取数的和，通过两重循环完成状态转移。
 - **作者：回头是岸 (赞：11)  星级：4星**
    - **关键亮点**：状压DP思路清晰，代码简洁，通过预处理每行可用状态优化，详细注释关键步骤。
    - **个人心得**：无
    - **核心代码**：
```cpp
void work(){
    for(int i=0;i<(1<<m);i++)if(!(i&(i>>1))&&!(i&(i<<1)))t.push_back(i);
}
//...
for(int i=1;i<=n;i++){
    for(int j=0;j<t.size();j++)
        for(int k=0;k<t.size();k++){
            int u=t[j],v=t[k];
            if((u&v)||(u&(v>>1))||(u&(v<<1)))continue;
            int num1=0;
            for(int l=0;l<m;l++)if((u&(1<<l)))num1+=a[i][m-l];
            f[i][u]=max(f[i][u],f[i-1][v]+num1);
        }
}
```
核心思想：work函数预处理每行合法状态存入t数组，通过三层循环，对当前行每个合法状态，结合上一行合法状态进行状态转移，计算当前行此状态下的最大和。

### 最优关键思路或技巧
 - **状压DP**：利用二进制表示状态，能简洁表示每行取数情况，通过预处理合法状态和合理设计状态转移方程，降低时间复杂度，提高效率。
 - **DFS优化**：如限制搜索范围，从当前点所在行及之后行、列搜索，减少不必要搜索；剪枝操作，如判断当前和与已得最大和关系，提前结束不可能最优的搜索分支。

### 可拓展之处
同类型题常涉及在有邻接限制的网格中进行选择或操作，类似算法套路为根据数据范围选择DFS或状压DP。若数据范围小，DFS简单直接；数据范围稍大，状压DP更优，关键在于合理设计状态和状态转移方程。

### 相似知识点洛谷题目
 - [P1896 互不侵犯](https://www.luogu.com.cn/problem/P1896)：在棋盘放置国王，要求国王互不相邻，与本题状压DP思路相似。
 - [P5390 [Cnoi2019]数字游戏](https://www.luogu.com.cn/problem/P5390)：在矩阵取数满足一定相邻限制，可类比本题用DFS或状压DP解决。
 - [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)：虽不是网格问题，但状态压缩思想类似，通过二进制表示已访问点状态进行动态规划。

### 个人心得摘录与总结
 - **作者：zhi_zhang**：详细记录剪枝优化过程，每次优化解决不同问题，如减少重复搜索、减少标记操作等，逐步提高算法效率。总结出深搜优化常见方法为剪枝，通过分析搜索过程特点找剪枝点。 

---
处理用时：57.44秒
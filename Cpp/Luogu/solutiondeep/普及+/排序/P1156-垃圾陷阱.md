# 题目信息

# 垃圾陷阱

## 题目描述

卡门――农夫约翰极其珍视的一条 `Holsteins` 奶牛――已经落了到 “垃圾井” 中。“垃圾井” 是农夫们扔垃圾的地方，它的深度为 $D$（$2 \le D \le 100$）英尺。

卡门想把垃圾堆起来，等到堆得与井深同样高或比井深更高（即，垃圾高度总和 $\geq D$）时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。

每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。

假设卡门预先知道了每个垃圾扔下的时间 $t$（$1 \le t \le 1000$），以及每个垃圾堆放的高度 $h$（$1 \le h \le 25$）和吃进该垃圾能增加维持生命的时间 $f$（$1 \le f \le 30$），要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续 $10$ 小时的能量，如果卡门 $10$ 小时内（不含 $10$ 小时，维持生命的时间同）没有进食，卡门就将饿死。特别地，若体力值为 $0$ 时吃下垃圾或逃出井外也不会饿死。

## 说明/提示

**【样例说明】**

卡门堆放她收到的第一个垃圾：$\mathrm{height}=9$；

卡门吃掉她收到的第 $2$ 个垃圾，使她的生命从 $10$ 小时延伸到 $13$ 小时；

卡门堆放第 $3$ 个垃圾，$\mathrm{height}=19$；

卡门堆放第 $4$ 个垃圾，$\mathrm{height}=20$。


## 样例 #1

### 输入

```
20 4
5 4 9
9 3 2
12 6 10
13 1 1```

### 输出

```
13```

# AI分析结果

这道题主要是关于奶牛利用垃圾逃出垃圾井的问题，核心在于如何根据垃圾的不同属性（时间、高度、增加生命），通过合理的算法决策来确定奶牛逃出井的最早时间或最长存活时间。大部分题解采用动态规划（DP）算法，少数使用搜索算法。

1. **各题解思路、要点及难点对比**
    - **DP思路题解**：
        - **状态定义**：多数以二维数组 `dp[i][j]` 表示状态，如处理前 `i` 个垃圾在高度 `j` 时的最大生命值（如作者 `Dispwnl`、`wjyyy` 等），或前 `i` 个垃圾处理后在 `j` 血量时达到的最大高度（如作者 `ButterflyDew`）等；也有一维数组表示，如 `dp[j]` 表示高度堆到 `j` 时的最大生命值（如作者 `wumei46`）。
        - **状态转移**：根据垃圾是吃还是堆进行状态转移。例如吃垃圾则生命值增加，高度不变；堆垃圾则高度增加，生命值可能因消耗时间而变化。转移时需判断当前状态的生命值是否能坚持到下一个垃圾到来。
        - **难点处理**：输入数据未按时间排序，需先排序；当生命值为0时奶牛仍可操作垃圾，初始化 `dp` 数组时需考虑此情况（部分题解初始化为负）；状态转移时要保证奶牛在每个阶段都存活。
    - **搜索思路题解**：
        - **状态定义**：以当前处理到的垃圾、剩余生命值和垃圾堆放高度作为搜索状态（如作者 `Time_Rune`）。
        - **剪枝策略**：包括饿死、逃出、后面无垃圾、搜过的状态等情况不再继续搜索。
        - **难点处理**：搜索过程中状态空间较大，需合理剪枝避免超时，同时要注意记忆化搜索的实现以提高效率。
2. **题解评分**
    - **作者 `Dispwnl`**：5星。思路清晰，代码简洁明了，直接使用一维数组解决问题，通过简单的循环和条件判断实现状态转移，很好地处理了垃圾处理的决策过程。
    - **作者 `ButterflyDew`**：4星。详细分析了状态定义的多种尝试过程，最终确定合理的状态表示和转移方程，对状态转移方程的推导和理解较为深入，同时讨论了离线和在线算法以及填表法和刷表法，内容丰富。
    - **作者 `wjyyy`**：4星。将题目与01背包进行对比，清晰阐述不同点，状态定义明确，对边界情况（如奶牛濒死状态）处理得当，代码逻辑清晰。
3. **最优关键思路或技巧**
    - **状态定义与转移**：合理定义状态是解决问题的关键，根据垃圾的处理方式（吃或堆）来设计状态转移方程，同时考虑时间和生命值的关系，确保奶牛在每个阶段都能存活。
    - **排序处理**：由于输入数据未按时间排序，先对垃圾按时间排序，使问题处理更有序。
    - **剪枝与记忆化**：对于搜索算法，合理的剪枝策略（如饿死、逃出等情况）和记忆化搜索能有效减少搜索空间，提高算法效率。
4. **可拓展之处**：此类问题属于动态规划中的资源分配类型，类似套路包括根据不同资源（如本题中的高度、生命值）和决策（吃或堆垃圾）来定义状态和转移方程。同类型题可涉及不同资源限制下的最优决策问题，如背包问题的变体、资源分配优化等。
5. **相似知识点洛谷题目**
    - **P1048 [NOIP2005 普及组] 采药**：经典的背包问题，在给定时间内选择采药以获取最大价值，与本题类似在于都涉及资源限制和价值最大化决策。
    - **P1616 疯狂的采药**：背包问题的加强版，增加了采药数量的限制，同样需要合理定义状态和转移方程来解决。
    - **P2059 [JLOI2013] 卡牌游戏**：涉及资源分配和决策过程，通过动态规划求解最优策略，与本题思路有相似之处。
6. **个人心得摘录与总结**
    - **作者 `wjyyy`**：被奶牛生命值为0时还能操作垃圾这一条件卡了一天，强调了对题目细节条件的重视，在处理状态转移和边界情况时需严格按照题目设定。
    - **作者 `dph754132771`**：分享了多次WA的教训，如初始化 `dp` 数组为负无穷、判断垃圾吃下前奶牛是否存活等细节，提醒注意动态规划中的边界条件和状态合法性判断。
    - **作者 `千载煜`**：调了一下午关于生存值和当前时间关系的处理，特别是转移方程中保证奶牛能活到吃垃圾时刻的条件判断，突出了在复杂状态转移中理清各因素关系的重要性。

### 所选题解
#### 作者 `Dispwnl`（5星）
- **关键亮点**：思路简洁清晰，使用一维数组解决问题，代码实现高效简洁。
```cpp
# include<iostream>
# include<cstring>
# include<algorithm>
using namespace std;
struct p{
    int t,h,l;
}c[101];
int d,g;
int ti[101];
int f[101];
bool cmp(p a,p b)
{
    return a.t<b.t;
}
int main()
{
    cin>>d>>g;
    for(int i=1;i<=g;i++)
      cin>>c[i].t>>c[i].l>>c[i].h;
    sort(c+1,c+1+g,cmp);
    f[0]=10;
    for(int i=1;i<=g;i++)
      for(int j=d;j>=0;j--)
        if(f[j]>=c[i].t)
        {
            if(j+c[i].h>=d)
            {
                cout<<c[i].t;
                return 0;
            }
            f[j+c[i].h]=max(f[j+c[i].h],f[j]);
            f[j]+=c[i].l;
        }
    cout<<f[0];
    return 0;
}
```
核心实现思想：通过对垃圾按时间排序，利用一维数组 `f` 记录不同高度下的最大生命值。在双重循环中，根据当前高度的生命值是否能坚持到当前垃圾到来，进行吃或堆垃圾的状态转移，若能逃出则输出时间，否则输出最终高度为0时的生命值。

#### 作者 `ButterflyDew`（4星）
- **关键亮点**：详细分析状态定义的多种尝试过程，最终确定合理的状态表示和转移方程，讨论多种算法实现方式。
```cpp
// 填表法
for(int i=1;i<=g;i++)
    for(int j=0;j<=d;j++)
    {
        if(dp[i-1][j]>=trash[i].t)
            dp[i][j]=max(dp[i][j],dp[i-1][j]+trash[i].c);
        if(j>=trash[i].h&&dp[i-1][j-trash[i].h]>=trash[i].t)
            dp[i][j]=max(dp[i][j],dp[i-1][j-trash[i].h]);
    }
// 扫一遍找结果
int maxh=0;
int maxt=0;
int i;
for(i=1;i<=g;i++)
{
    for(int j=0;j<=d;j++)
    {
        if(dp[i][j]-trash[i].t>=0)
            maxh=max(maxh,j);
        maxt=max(maxt,dp[i][j]);
    }
    if(maxh==d)
        break;
}
if(maxh==d)
    cout<<trash[i].t<<endl;
else
    cout<<maxt<<endl;
```
核心实现思想：使用 `dp[i][j]` 表示前 `i` 件物品处理后在 `h` 高度时达到的最大血量。通过填表法，根据前一个状态是否能坚持到当前垃圾到来，进行吃或堆垃圾的状态转移。最后通过遍历找到能逃出的时间或最长存活时间。

#### 作者 `wjyyy`（4星）
- **关键亮点**：与01背包对比分析，清晰阐述不同点，对边界情况处理得当。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int max(int x,int y){return x>y?x:y;}
int dp[101][1001];//dp[i][j]表示在扔进去第i个辣鸡，在j的高度时的最大生命
struct trash
{
    int t,f,h;
    friend bool operator <(trash a,trash b)
    {
            return a.t<b.t;
    }
}r[101];
int main()
{
    memset(dp,-1,sizeof(dp));
    int d,g;
    scanf("%d%d",&d,&g);
    for(int i=1;i<=g;i++)
        scanf("%d%d%d",&r[i].t,&r[i].f,&r[i].h);
    sort(r+1,r+g+1);
    dp[0][0]=10;
    r[0].f=0;
    r[0].h=0;
    r[0].t=0;
    for(int i=0;i<g;i++)
        for(int j=0;j<=d;j++)
        {
            if(dp[i][j]<0)
                continue;
            if(j+r[i+1].h>=d&&dp[i][j]>=r[i+1].t-r[i].t)
            {
                printf("%d\n",r[i+1].t);
                return 0;
            }
            if(dp[i][j]-r[i+1].t+r[i].t>=0)
                dp[i+1][j+r[i+1].h]=dp[i][j]-r[i+1].t+r[i].t;
            if(dp[i][j]-r[i+1].t+r[i].t>=0)
                dp[i+1][j]=max(dp[i+1][j],dp[i][j]-r[i+1].t+r[i].t+r[i+1].f);
        }
    int m=10,sum=0;
    for(int i=1;i<=g;i++)
    {
        if(r[i].t-r[i-1].t>m)
        {
            printf("%d\n",sum+m);
            return 0;
        }
        sum+=r[i].t-r[i-1].t;
        m-=r[i].t-r[i-1].t;
        m+=r[i].f;
    }
    printf("%d\n",sum+m);
    return 0;
}
```
核心实现思想：定义 `dp[i][j]` 表示扔进去 `i` 个垃圾在高度 `j` 时的最大生命值，初始化数组为 -1 处理边界情况。对垃圾按时间排序后，在双重循环中根据当前状态生命值是否满足条件进行状态转移，若能逃出则输出时间，否则模拟计算最长存活时间。 

---
处理用时：85.82秒
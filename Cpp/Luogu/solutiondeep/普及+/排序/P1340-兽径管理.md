# 题目信息

# 兽径管理

## 题目描述

约翰农场的牛群希望能够在 $N$ 个草地之间任意移动。草地的编号由 $1$ 到 $N$。草地之间有树林隔开。牛群希望能够选择草地间的路径，使牛群能够从任一 片草地移动到任一片其它草地。 牛群可在路径上双向通行。

牛群并不能创造路径，但是他们会保有及利用已经发现的野兽所走出来的路径（以下简称兽径）。每星期他们会选择并管理一些或全部已知的兽径当作通路。

牛群每星期初会发现一条新的兽径。他们接着必须决定管理哪些兽径来组成该周牛群移动的通路，使得牛群得以从任一草地移动到任一草地。牛群只能使用当周有被管理的兽径做为通路。

牛群希望他们管理的兽径长度和为最小。牛群可以从所有他们知道的所有兽径中挑选出一些来管理。牛群可以挑选的兽径与它之前是否曾被管理无关。

兽径决不会是直线，因此连接两片草地之间的不同兽径长度可以不同。 此外虽然两条兽径或许会相交，但牛群非常的专注，除非交点是在草地内，否则不会在交点换到另外一条兽径上。

在每周开始的时候，牛群会描述他们新发现的兽径。如果可能的话，请找出可从任何一草地通达另一草地的一组需管理的兽径，使其兽径长度和最小。


## 说明/提示

### 样例解释

对于每一周，

- 第一周时 $4$ 号草地不能与其他草地连通，输出 $-1$；
- 第二周时 $4$ 号草地不能与其他草地连通，输出 $-1$；
- 第三周时 $4$ 号草地不能与其他草地连通，输出 $-1$；
- 第四周时可以选择兽径 $(1,4,3),(1,3,8)$ 和 $(3,2,3)$；
- 第五周时可以选择兽径 $(1,4,3),(1,3,6)$ 和 $(3,2,3)$；
- 第六周时可以选择兽径 $(1,4,3),(2,1,2)$ 和 $(3,2,3)$。


### 数据范围及约定

对于全部数据，$1\le N\le 200$，$1 \le W \le 6000$，兽径的长度不超过 $10^4$ 且为正整数。

## 样例 #1

### 输入

```
4 6	 	 
1 2 10	 	 
1 3 8	 	 
3 2 3	 	 
1 4 3	 	 
1 3 6	 	 
2 1 2	 	 
```

### 输出

```
-1
-1
-1
14
12
8```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效求解动态最小生成树问题。多数题解采用Kruskal算法，部分考虑优化排序过程以降低时间复杂度。思路上，有正向处理每次加边后重新计算最小生成树，也有逆向求解以减少Kruskal调用次数。解决难点在于如何避免重复计算和优化排序操作。

### 所选4星及以上题解
1. **作者：SovietPower✨（5星）**
    - **关键亮点**：逆向求解，减少Kruskal使用次数，降低时间复杂度。记录每次Kruskal用到的边，若删除的边在使用列表中才重新计算最小生成树。
    - **个人心得**：无
    - **重点代码**：
```cpp
long long Kruskal() {
    memset(use, 0, sizeof use);
    for (int i = 1; i <= n; i++)
        fa[i] = i;
    int k = 0;
    long long tot = 0;
    for (int i = 1; i <= Enum; i++) {
        if (cannot[e[i].id]) continue;
        int r1 = Find(e[i].fr), r2 = Find(e[i].to);
        if (r1!= r2) {
            ++k; tot += e[i].val;
            use[e[i].id] = 1;
            fa[r1] = r2;
        }
        if (k == n - 1)
            break;
    }
    return k == n - 1? tot : -1;
}
```
核心思想：遍历所有边，若边未被标记删除且两端点不在同一集合，加入最小生成树并更新相关信息，若成功加入n - 1条边则返回树的权值和，否则返回 - 1。
2. **作者：绝艺（4星）**
    - **关键亮点**：同样逆序求解kruskal，通过标记边的周数，在结构体存边时加参数记录该边是第几周的兽径，避免边在快排时顺序混乱导致错误。
    - **个人心得**：注意每次kruskal时要初始化并查集用到的fa[]数组。
    - **重点代码**：
```cpp
int kruskal(int k) {
    int cnt = 0, tot = 0;
    for (int i = 1; i <= n; i++) fa[i] = i;
    for (int i = 1; i <= m; i++) {
        if (cnt == n - 1) break;
        if ((find(edge[i].u)!= find(edge[i].v)) && (edge[i].p <= k)) {
            merge(edge[i].u, edge[i].v);
            cnt++;
            tot += edge[i].w;
        }
    }
    if (cnt < n - 1) return -1;
    else return tot;
}
```
核心思想：在第k周的情况下，遍历所有边，仅考虑周数小于等于k且两端点不在同一集合的边加入最小生成树，统计加入边数和权值和，根据最终边数判断能否构成最小生成树并返回相应结果。
3. **作者：南苑沁青（4星）**
    - **关键亮点**：分析暴力做法被卡原因是多次快排，提出离线做法优化。给每条边打上时间标号，所有边输入后按权值排序一次，之后做W遍最小生成树，仅考虑时间标号合适的边。
    - **个人心得**：无
    - **重点代码**：
```cpp
inline void kruskal(LL num) {
    for (LL i = 1; i <= w; i++) fa[i] = i;
    for (LL i = 1; i <= w; i++) {
        if (t[i].tim > num) continue;
        LL r1 = find(t[i].l), r2 = find(t[i].r);
        if (r1!= r2) {
            fa[r1] = r2;
            ans += t[i].w;
            cnt++;
        }
        if (cnt == n - 1) { printf("%lld\n", ans); return; }
    }
    printf("-1\n");
}
```
核心思想：在第num次做最小生成树时，初始化并查集，遍历所有边，跳过时间标号大于num的边，对符合条件且两端点不在同一集合的边进行合并操作并统计权值和与边数，根据边数输出结果。

### 最优关键思路或技巧
1. **逆向求解**：从最后一周往前计算，若某一周无法构成最小生成树，则之前周也无法构成，可减少Kruskal计算次数。
2. **离线处理**：给边添加时间标号，输入后统一排序，避免每次加边都排序，降低时间复杂度。

### 可拓展思路
此类题目属于动态最小生成树问题，类似套路可用于处理图结构动态变化时最小生成树的求解。如动态加边或删边后，如何快速更新最小生成树。可以进一步学习动态树数据结构（如LCT）来更高效解决此类问题。

### 洛谷相似题目推荐
1. **P1546 [USACO09OCT]Barn Allocation G**：涉及区间分配与图的连通性问题，可使用贪心和并查集解决，与本题在图结构处理上有相似思路。
2. **P3366 【模板】最小生成树**：经典最小生成树模板题，可用于巩固Kruskal和Prim算法基础，本题是在此基础上的动态拓展。
3. **P2820 [NOIP2016 提高组] 运输计划**：结合最小生成树与树上倍增，通过对树结构的操作和路径分析解决问题，对理解图与树的算法综合应用有帮助。 

---
处理用时：62.55秒
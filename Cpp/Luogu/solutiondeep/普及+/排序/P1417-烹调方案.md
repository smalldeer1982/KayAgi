# 题目信息

# 烹调方案

## 题目背景

由于你的帮助，火星只遭受了最小的损失。但 gw 懒得重建家园了，就造了一艘飞船飞向遥远的 earth 星。不过飞船飞到一半，gw 发现了一个很严重的问题：肚子饿了 ~。

gw 还是会做饭的，于是拿出了储藏的食物准备填饱肚子。gw 希望能在 $T$ 时间内做出最美味的食物，但是这些食物美味程度的计算方式比较奇葩，于是绝望的 gw 只好求助于你了。

## 题目描述

一共有 $n$ 件食材，每件食材有三个属性，$a_i$，$b_i$ 和 $c_i$，如果在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t\times b_i$ 的美味指数，用第 $i$ 件食材做饭要花去 $c_i$ 的时间。

众所周知，gw 的厨艺不怎么样，所以他需要你设计烹调方案使得美味指数最大。

## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据 $1 \le n \le 10$；
- 对于 $100\%$ 的数据 $1 \le n \le 50$。

所有数字均小于 $10^5$。

### 题目来源

tinylic 改编


## 样例 #1

### 输入

```
74 1
502
2
47
```

### 输出

```
408```

# AI分析结果

### 综合分析与结论
这些题解都围绕如何解决该烹调方案问题展开，核心思路是先通过数学推导得出食材排序条件，再利用01背包算法求解最大美味指数。
1. **思路**：大多题解先指出本题类似01背包，但因食材美味指数与时间相关，普通01背包直接求解错误。通过比较相邻两个食材不同顺序制作的美味指数，推导出排序条件，排序后再用01背包求解。
2. **算法要点**：根据推导的排序条件对食材进行排序，再使用01背包的动态规划思路，更新不同时间状态下能获得的最大美味指数。
3. **解决难点**：难点在于发现食材选择顺序对结果有影响，并通过数学推导得出正确的排序条件。同时，要注意数据类型，防止计算过程中数据溢出。

### 所选的题解
1. **作者：kkksc03 (赞：422)  星级：5星**
    - **关键亮点**：思路清晰，先点明问题本质与01背包的联系，详细推导相邻物品先后顺序的条件，代码规范，注释清晰。
    - **个人心得**：无
    - **重点代码**：
```cpp
struct node {
    int a, b, c;
}a[maxn];

LL f[maxn], ans;
int T, n, i, j;

bool cmp(node a, node b) {
    return (LL)a.c * (LL)b.b < (LL)b.c * (LL)a.b;
}

int main() {

    scanf("%d%d", &T, &n);
    for (i = 0; i < n; i++)
        scanf("%d", &a[i].a);
    for (i = 0; i < n; i++)
        scanf("%d", &a[i].b);
    for (i = 0; i < n; i++)
        scanf("%d", &a[i].c);
    
    sort(a, a + n, cmp);

    memset(f, 255, sizeof f);
    f[0] = 0;

    for (i = 0; i < n; i++) {
        for (j = T; j >= 0; --j)
            if (f[j]!= -1 && j + a[i].c <= T)
                f[j + a[i].c] = max(f[j + a[i].c], f[j] + (LL)a[i].a - (LL)(j + a[i].c) * (LL)a[i].b);
    }
    for (i = 0; i <= T; i++)
        ans = max(ans, f[i]);
    cout << ans << endl;
}
```
    - **核心实现思想**：定义结构体存储食材属性，`cmp`函数实现排序条件。主函数中读入数据并排序，初始化动态规划数组`f`，通过两层循环更新`f`数组，最后找出最大美味指数。
2. **作者：henry_y (赞：42)  星级：4星**
    - **关键亮点**：给出详细的推导过程，帮助理解排序条件的由来，代码简洁明了，注释虽少但逻辑清晰。
    - **个人心得**：开始写裸01背包只得30分，后发现因$b[i]$属性需考虑先后顺序。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll n,t;
struct node {
	ll a,b,c;
}a[100];
ll f[100000];
bool cmp(node i,node j){
	return -j.b*i.c>-i.b*j.c;
}
int main(){
	long long ans=0;
	scanf("%lld%lld",&t,&n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i].a);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i].b);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i].c);
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		for(int j=t;j>=a[i].c;j--){
			f[j]=max(f[j],f[j-a[i].c]+a[i].a-a[i].b*j);
			ans=max(ans,f[j]);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```
    - **核心实现思想**：定义结构体和数组，`cmp`函数确定排序规则。主函数读入数据排序后，通过两层循环进行01背包动态规划更新，同时记录最大美味指数。
3. **作者：zjy111 (赞：21)  星级：4星**
    - **关键亮点**：不仅给出代码和思路，还分享了做题时的错误经历，强调数据类型的重要性，对读者有警示作用。
    - **个人心得**：开始当裸01背包做能得部分分，后发现需排序，且因未开`long long`导致数据溢出。
    - **重点代码**：
```cpp
# define ll long long
ll n,t,dp[100005],maxn; 
struct thing{  
	ll a,b,c;
}x[55];
bool cmp(thing a,thing b){  
	return a.b*b.c>b.b*a.c;
}
int main() {
	cin>>t>>n;
	for(int i=1;i<=n;i++)cin>>x[i].a;
	for(int i=1;i<=n;i++)cin>>x[i].b;
	for(int i=1;i<=n;i++)cin>>x[i].c;
	sort(x+1,x+n+1,cmp);
	for(int i=1;i<=n;i++){
		for(int j=t;j>=x[i].c;j--){
			dp[j]=max(dp[j],dp[j-x[i].c]+x[i].a-j*x[i].b); 
		}
	}
	for(int i=1;i<=t;i++)
		maxn=max(maxn,dp[i]);  
	cout<<maxn<<endl;
	return 0;
}
```
    - **核心实现思想**：定义结构体和数组，`cmp`函数确定排序条件。主函数读入数据排序后，利用01背包动态规划更新数组，最后找出最大美味指数。

### 最优的关键思路或技巧
1. **思维方式**：通过对相邻食材不同制作顺序的美味指数进行数学推导，得出食材的排序条件，从而解决因食材价值随时间变化导致选择顺序影响结果的问题。
2. **代码实现技巧**：在实现01背包动态规划时，注意数组初始化、边界条件判断以及数据类型选择，防止数据溢出。

### 可拓展之处
同类型题或类似算法套路：此类问题属于动态规划中背包问题的变体，特点是物品价值与放入顺序或时间相关。解决这类问题通常需先分析物品间的顺序关系，通过数学推导得出排序条件，再结合背包问题的基本思路求解。

### 推荐题目
1. **P1048 [NOIP2005 普及组] 采药**：基础的背包问题，可作为理解背包问题动态规划思路的入门题。
2. **P1616 疯狂的采药**：对背包问题的进一步拓展，涉及多重背包的优化，与本题类似需考虑时间和价值的关系。
3. **P2698 [USACO12MAR]花盆Flowerpot**：同样是背包问题的变体，需要通过分析条件确定物品的处理顺序，再用动态规划求解。 

---
处理用时：48.36秒
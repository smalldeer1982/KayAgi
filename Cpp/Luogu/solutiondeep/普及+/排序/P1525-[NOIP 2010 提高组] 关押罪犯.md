# 题目信息

# [NOIP 2010 提高组] 关押罪犯

## 题目背景

NOIP2010 提高组 T3

## 题目描述

S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1\sim N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。

每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。

在详细考察了 $N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。

那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？


## 说明/提示

**输入输出样例说明**

罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。

![](https://cdn.luogu.com.cn/upload/image_hosting/uia11zcq.png)

**数据范围**  

对于 $30\%$ 的数据有 $N\leq 15$。

对于 $70\%$ 的数据有 $N\leq 2000,M\leq 50000$。  

对于 $100\%$ 的数据有 $N\leq 20000,M\leq 100000$。


## 样例 #1

### 输入

```
4 6
1 4 2534
2 3 3512
1 2 28351
1 3 6618
2 4 1805
3 4 12884```

### 输出

```
3512```

# AI分析结果

• **综合分析与结论**：这些题解主要围绕并查集和二分图两种思路。并查集思路中，大多采用贪心策略，先对怨气值从大到小排序，再利用并查集将罪犯分配到不同监狱，通过合并敌人的敌人来避免高怨气值罪犯在同一监狱，若出现无法避免的冲突则输出当前怨气值，否则输出0；二分图思路则是二分答案，通过判断大于当前二分答案的边所构成的图是否为二分图来确定答案的可行性。并查集思路相对直接，代码实现简洁；二分图思路稍复杂，但具有通用性。整体上，大部分题解思路清晰，部分题解代码可读性欠佳。

所选的题解：
  - **作者：梦回还 (赞：648)  星级：4星**
    - **关键亮点**：思路清晰简洁，直接点明用带权值的并查集，结合排序和敌人的敌人是朋友的规律解题，代码简洁明了。
    - **重点代码**：
```cpp
struct data {int x,y,z;};//结构体便于排序的变换
data f[100005];
int n,m,a[20005],b[20005],i;
inline bool cmp(data a,data b)//重写cmp函数
{
    return a.z>b.z;
}
inline int find(int x)
{
    if(a[x]==x) return x;
    a[x]=find(a[x]);
    return a[x];
}
inline void ad(int x,int y)//合并
{
    x=find(a[x]);
    y=find(a[y]);
    a[x]=y;
}
inline bool check(int x,int y)//查找
{
    x=find(x);
    y=find(y);
    if(x==y) return true;
    return false;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++) a[i]=i;
    for(i=1;i<=m;i++)
        scanf("%d%d%d",&f[i].x,&f[i].y,&f[i].z);
    sort(f+1,f+m+1,cmp);
    for(i=1;i<=m+1;i++)
    {
        if(check(f[i].x,f[i].y)) {printf("%d",f[i].z);break;}
        else
        {
            if(!b[f[i].x]) b[f[i].x]=f[i].y;
                else {ad(b[f[i].x],f[i].y);}
            if(!b[f[i].y]) b[f[i].y]=f[i].x;
                else {ad(b[f[i].y],f[i].x);}
        }
    }
    return 0;
}
```
    - **核心实现思想**：定义结构体存储罪犯关系并排序，利用并查集的查找、合并操作，结合辅助数组标记敌人，按顺序处理罪犯关系，若发现冲突则输出当前怨气值。
  - **作者：_Weslie_ (赞：13)  星级：4星**
    - **关键亮点**：详细介绍拓展域并查集的概念、用途及写法，并结合本题讲解如何利用拓展域并查集解题，逻辑清晰，对拓展域并查集的应用有很好的示范。
    - **重点代码**：
```cpp
struct node{
	int u,v,w;
}e[100005];
bool cmp(node _,node __){
	return _.w>__.w;
}
int fa[40005];
int findd(int now){
	if(fa[now]==now)return now;
	return fa[now]=findd(fa[now]);
}
void vnion(int u,int v){
	u=findd(u),v=findd(v);
	if(u==v)return;
	fa[u]=v;
}
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=2*n;i++)fa[i]=i;
	for(int i=1;i<=m;++i){
		scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
	}
	sort(e+1,e+m+1,cmp);
	for(int i=1;i<=m;i++){
		vnion(e[i].u+n,e[i].v);
		vnion(e[i].u,e[i].v+n);
		if(findd(e[i].u)==findd(e[i].u+n)||findd(e[i].v)==findd(e[i].v+n)){
			printf("%d",e[i].w);
			return 0;
		}
	}
	printf("0");
	return 0;
}
```
    - **核心实现思想**：使用拓展域并查集，对罪犯关系按怨气值排序后，尝试将每个关系中的罪犯放入不同监狱（通过合并对应拓展域），若发现某个罪犯与其反状态在同一集合则输出当前怨气值。
  - **作者：ClV_Csy (赞：10)  星级：4星**
    - **关键亮点**：先阐述种类并查集的概念及核心原理，再结合题目详细说明解题思路，对种类并查集的应用讲解细致，有助于理解。
    - **重点代码**：
```cpp
int n, m;
int f[40010]; 
struct node {
	int x, y, v;
}a[100010];
bool cmp(node x, node y) {
	return x.v > y.v;
}
int find(int x) { 
	if (f[x] == x) {
		return x;
	}
	return f[x] = find(f[x]);
}
void merge(int x, int y) { 
	int fx = find(x), fy = find(y);
	if (fx!= fy) {
		f[fy] = fx;
	}
}
int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> a[i].x >> a[i].y >> a[i].v;
	}
	sort(a + 1, a + m + 1, cmp);
	for (int i = 1; i <= n * 2; i++) {
		f[i] = i;
	}
	for (int i = 1; i <= m; i++) {
		if (find(a[i].x) == find(a[i].y)) {
			cout << a[i].v; 
			return 0;
		}
		merge(a[i].x + n, a[i].y); 
		merge(a[i].x, a[i].y + n); 
	}
	cout << 0;
	return 0;
}
```
    - **核心实现思想**：定义种类并查集，通过建立假想敌（编号为a的假想敌为a + n），对怨气值排序后依次处理，若发现冲突则输出当前怨气值，否则合并对应关系。

• **最优关键思路或技巧**：利用贪心策略结合并查集是解决本题的有效方法。先对怨气值从大到小排序，优先处理高怨气值的罪犯关系，通过并查集将其分配到不同监狱，有效避免高怨气值冲突事件的发生。同时，利用拓展域或种类并查集的思想，通过合理定义集合关系，简化了冲突判断和处理过程。

• **同类型题或类似算法套路**：此类题目通常涉及将元素分配到不同集合，并满足一定的限制条件，以优化某个目标值。常见套路是先对条件按重要性或权值排序，再利用并查集维护集合关系，判断是否满足条件。类似题目如处理元素分组、判断图的划分等。

• **推荐题目**：
  - [P1892 [BOI2003]团伙](https://www.luogu.com.cn/problem/P1892)：同样是利用并查集处理元素分组问题，判断不同元素之间的关系并进行分组。
  - [P2024 [NOI2001]食物链](https://www.luogu.com.cn/problem/P2024)：通过拓展域并查集处理多种关系的元素，与本题利用拓展域并查集处理罪犯关系类似。
  - [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)：基础的并查集模板题，可用于巩固并查集的基本操作和理解。

• **个人心得摘录**：部分题解提到不要忘记在无冲突时输出0，否则会导致得分不全。这提醒在解题时要仔细考虑边界情况和题目要求，避免因小失大。 

---
处理用时：103.34秒
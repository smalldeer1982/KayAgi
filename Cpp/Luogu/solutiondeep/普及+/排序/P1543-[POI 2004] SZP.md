# 题目信息

# [POI 2004] SZP

## 题目背景

一班班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 十分可爱。

## 题目描述

班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 作为某日的值日班长，在自习课上管理着 $n$ 名同学。除了她以外每一名同学都监视着另一名同学。现在班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 需要选择尽量多的同学去搬卷子和答题卡，且使得对于这些同学中的每一名同学，至少有一位监视她的同学没有被选中。问班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 最多可以选择多少同学。

由于班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 太可爱了，所以没有人监视她，也可以认为她的学号是 $0$。

如果一个人没有被监视，那么她就不能被选择。


## 说明/提示

对于 $100\%$ 的数据，$1\le k,a_k\le n\le 10^6$。

## 样例 #1

### 输入

```
6
2
3
1
3
6
5
```

### 输出

```
3```

# AI分析结果

• 综合分析：这些题解主要围绕贪心、拓扑排序、DP三种思路。贪心思路基于能选就选的原则，因为放弃可选点不会更优；拓扑排序用于处理入度为0的点及环的情况，将入度为0的点先处理，环上点按一定规则选取；DP思路则是将问题转化为基环树问题，通过状态转移方程求解。各题解在思路清晰度、代码可读性、优化程度上存在差异。
  - 贪心思路要点：能选的点优先选，不选可选点不会使结果更优，处理完入度为0的点后，环上点隔一个选一个是最优策略。
  - 拓扑排序要点：入度为0的点不能选，将其加入队列，其指向的点可选，处理完队列中的点后，剩余环上点按环长下取整选取。
  - DP思路要点：将原问题转化为基环树问题，通过断环成树，设状态转移方程\(f_{x,0/1}\)来求解。
  - 解决难点：主要难点在于处理环的情况，不同思路下对环的处理方式不同，如贪心和拓扑排序中对环上点按一定规则选取，DP中通过断环成树并结合状态转移方程处理环。
• 所选的题解：
  - 作者wyd_is_JOKER，5星
    - 关键亮点：思路清晰，先阐述贪心 + 拓扑排序的整体思路，对贪心策略进行证明，代码实现简洁明了，注释详细。
    - 个人心得：无
    - 核心代码片段：
```cpp
while(!Q.empty())
{
    int u=Q.front();Q.pop();
    vis[u]=1;
    if (choose[u])
    {
        in[ak[u]]--;
        if (!in[ak[u]]) Q.push(ak[u]);
    }
    else
    {
        if (!choose[ak[u]])
        {
            choose[ak[u]]=1;
            ans++;
            Q.push(ak[u]);
        }
    }
}
for (int i=1;i<=n;i++) if (!vis[i])//找剩下的环
{
    vis[i]=1;
    int j=i;
    while (!vis[ak[j]])
    {
        if (!choose[j]&&!choose[ak[j]]) ans++,choose[ak[j]]=1;
        j=ak[j];vis[j]=1;
    }
}
```
核心实现思想：拓扑排序过程中，根据点是否被选更新入度并处理环，环上按贪心策略选取点。
  - 作者zac2010，5星
    - 关键亮点：先分析出是基环树问题，提出贪心策略并介绍常见DP做法，代码简洁，逻辑清晰。
    - 个人心得：无
    - 核心代码片段：
```cpp
void dfs(int u, int pos){
    f[u][0] = f[u][0] = 0; int mx = -INF;
    for(int &v: e[u]){
        dfs(v, pos), f[u][0] += max(f[v][0], f[v][1]);
        mx = max(mx, f[v][0] - max(f[v][0], f[v][1]));
    }
    f[u][1] = f[u][0] + (u!= pos ||!flag) * mx + 1;
}
```
核心实现思想：通过DFS进行DP，根据状态转移方程更新\(f_{u,0/1}\)。
  - 作者Melo_DDD，4星
    - 关键亮点：对拓扑排序结合贪心的思路阐述详细，对环的处理解释清晰，代码结构清晰，有独立函数处理拓扑和判环。
    - 个人心得：对拓扑队列作用理解花费时间，强调队列是存是否考虑过的点。
    - 核心代码片段：
```cpp
namespace kafka { 
    inline void topo () {
        queue <int> q ;
        rep (i,1,n,1) {
            if (! in[i]) {
                q.push (i) ;
            }
        }
        while (! q.empty ()) {
            int now = q.front () ;
            vis[now] = true ;
            if (chosen[now]) {
                if (--in[to[now]] == 0) { 
                    q.push (to[now]) ;
                }
            }
            else {
                if (! chosen[to[now]]) { 
                    ans ++ ; 
                    chosen[to[now]] = true ;
                    q.push (to[now]) ;
                }
            }
            q.pop () ;
        }
    }
    inline void judge_circle () {
        for (int i = 1; i <= n; i++) {
            if (!vis[i] && in[i]) {
                int cnt = 0;
                for (int j = i;!vis[j]; j = to[j]) {
                    cnt++;
                    vis[j] = 1;
                }
                ans += cnt / 2;  
            }
        }
    }
}
```
核心实现思想：`topo`函数进行拓扑排序并根据贪心策略更新答案，`judge_circle`函数处理环，计算环上可选点数量。
• 最优关键思路或技巧：贪心策略结合拓扑排序是较为简洁高效的方法，利用贪心能选就选的原则，通过拓扑排序处理入度为0的点，最后对环按一定规则选取点，实现简单且易于理解。
• 可拓展思路：此类问题可拓展到更复杂的图结构，如多环或带权图，处理方法可能需结合更复杂的图论算法和DP优化技巧。同类型题或类似算法套路常出现在基环树相关问题中，处理时一般将环断开转化为树问题，再结合贪心、DP等方法求解。
• 推荐题目：
  - P2607 [ZJOI2008]骑士：同样是基环树问题，通过断环转化为树，利用DP求解最大权独立集。
  - P3203 [HNOI2010] 弹飞绵羊：涉及基环树的动态操作，结合并查集和树状数组等数据结构解决问题。
  - P1453 城市环路：基环树问题，通过对环和树分别处理，利用贪心和DP思想求解。
• 个人心得摘录及总结：
  - 作者Melo_DDD：琢磨拓扑队列作用花费时间，强调其不是存可去或不可去的人，而是存是否考虑过该点。总结为对拓扑排序细节理解很重要，不能仅按常规理解队列用途。
  - 作者fishing_cat：处理环时统计所有环上点总个数再除二加入答案的做法错误，应每个环单独计算长度除二。总结为处理环这类特殊结构需谨慎，不能简单统一处理，要按环独立计算。 

---
处理用时：47.82秒
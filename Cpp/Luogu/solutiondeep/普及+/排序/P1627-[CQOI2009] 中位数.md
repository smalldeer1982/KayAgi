# 题目信息

# [CQOI2009] 中位数

## 题目描述

给出 $1,2,...,n$ 的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是 $b$。中位数是指把所有元素从小到大排列后，位于中间的数。

## 说明/提示

#### 数据规模与约定

对于 $30\%$ 的数据中，满足 $n \le 100$；

对于 $60\%$ 的数据中，满足 $n \le 1000$；

对于 $100\%$ 的数据中，满足 $n \le 100000,1 \le b \le n$。

## 样例 #1

### 输入

```
7 4
5 7 2 4 3 1 6 ```

### 输出

```
4```

# AI分析结果

• **综合分析与结论**：这些题解的核心思路都是利用中位数的性质，将原序列转化为只关注与中位数 $b$ 相对大小的序列（大于 $b$ 记为 $1$，小于 $b$ 记为 $-1$，等于 $b$ 记为 $0$），然后通过统计满足特定条件的连续子序列来求解。算法要点在于找到中位数位置后，分别处理其左右两侧序列，难点主要是处理可能出现的负数下标以及高效统计满足条件的子序列对数。多数题解采用了计数数组（桶）或 map 来记录子序列和的出现次数，以降低时间复杂度至 $O(n)$。部分题解还涉及到前缀和、后缀和的计算与应用。

  - **作者：zhutier（5星）**
    - **关键亮点**：思路清晰简洁，代码实现直接明了。利用 map 处理可能出现的负数下标，减少代码复杂度，易于理解。
    - **个人心得**：无
    - **重点代码及核心思想**：
```cpp
for(int j=q;j<=n;j++){
    if(a[j]>b) sumr++;
    if(a[j]<b) sumr--;
    mp[sumr]++;
}
for(int i=q;i>=1;i--){
    if(a[i]>b) suml++;
    if(a[i]<b) suml--;
    ans+=mp[0 - suml];
}
```
这段代码先从中位数位置 $q$ 向右遍历，统计大于和小于 $b$ 的数的差值 $sumr$ 并记录其出现次数到 map 中；再从 $q$ 向左遍历，同样统计差值 $suml$，通过查找 map 中 $0 - suml$ 的次数累加到答案 $ans$ 中，从而得到满足条件的子序列数量。

  - **作者：distantlight（5星）**
    - **关键亮点**：代码简洁高效，通过巧妙的计数排序思想，利用数组 $c$ 分别记录中位数左右两侧部分和的出现次数，在 $O(n)$ 时间复杂度内解决问题。
    - **个人心得**：无
    - **重点代码及核心思想**：
```cpp
cin>>n>>b; c[0][n]=1;
for (long long i=0,a,s=n,isRight=0;i<n;i++){
    cin>>a;
    if (a!=b) s+=a>b?1:-1;
    c[isRight|=a==b][s]++;
}
for (long long i=0;i<2*n;i++,ans+=c[0][i]*c[1][i]);
```
代码首先初始化数组 $c$，在输入过程中，根据数字与 $b$ 的大小关系更新部分和 $s$，并在对应的数组 $c$ 位置计数。最后通过遍历数组 $c$，将左右两侧相同部分和的计数相乘并累加，得到满足条件的子序列数量。

  - **作者：Heartlessly（4星）**
    - **关键亮点**：思路讲解详细，通过图文并茂的方式辅助理解。利用两个桶分别记录中位数左边的后缀和与右边的前缀和，通过乘法原理计算满足条件的子序列对数。
    - **个人心得**：无
    - **重点代码及核心思想**：
```cpp
for (LL i = tmp - 1; i >= 1; i--) { sum += a[i]; l[sum + maxN]++; }
sum = 0;
for (LL i = tmp + 1; i <= n; i++) { sum += a[i]; r[sum + maxN]++; }
for (LL i = 0; i <= (maxN << 1); i++) { if (l[i] && r[(maxN << 1) - i]) ans += l[i] * r[(maxN << 1) - i]; }
```
先从中位数位置 $tmp$ 向左遍历，计算后缀和并记录到桶 $l$ 中；再从 $tmp$ 向右遍历，计算前缀和记录到桶 $r$ 中。最后遍历桶，将 $l$ 与 $r$ 中对应位置（考虑到负数下标处理）的计数相乘并累加，得到满足条件的子序列数量。

• **最优关键思路或技巧**：将原序列转化为相对大小序列，利用计数数组（桶）或 map 记录中位数两侧子序列和的出现次数，通过乘法原理统计满足条件的子序列对数，这种方法有效降低了时间复杂度。同时，在处理可能出现的负数下标时，采用数组偏移或 map 等方式解决。

• **同类型题或类似算法套路**：此类题目通常涉及对序列特定性质的统计，关键在于对原序列进行合理转化，将问题简化为对某种特征值（如本题中的子序列和）的计数问题。类似算法套路包括利用前缀和、后缀和、差分等技巧来处理序列，以及使用合适的数据结构（如数组、map 等）记录统计信息。

• **推荐题目**：
  - [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)：通过对序列的处理和计数，考察对区间统计问题的解决能力。
  - [P3957 [NOIP2017 普及组] 跳房子](https://www.luogu.com.cn/problem/P3957)：涉及对序列中满足一定条件的元素进行统计和动态规划，与本题在序列处理和条件判断上有相似之处。
  - [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：通过对序列的遍历和状态记录，求解最大子段和问题，与本题在处理序列元素关系和统计方面有一定关联。

• **个人心得摘录与总结**：无

---
处理用时：45.66秒
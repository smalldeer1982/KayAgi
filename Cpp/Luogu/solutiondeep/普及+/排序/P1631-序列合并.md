# 题目信息

# 序列合并

## 题目描述

有两个长度为 $N$ 的**单调不降**序列 $A,B$，在 $A,B$ 中各取一个数相加可以得到 $N^2$ 个和，求这 $N^2$ 个和中最小的 $N$ 个。

## 说明/提示

对于 $50\%$ 的数据，$N \le 10^3$。

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1 \le a_i,b_i \le 10^9$。

## 样例 #1

### 输入

```
3
2 6 6
1 4 8```

### 输出

```
3 6 7```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何高效求出两个单调不降序列各取一数相加得到的 $N^2$ 个和中最小的 $N$ 个。大部分题解采用堆（优先队列）来优化，利用序列有序的特点，减少不必要的计算。少数题解采用二分答案、贪心近似等方法。
- 暴力枚举所有和再用优先队列维护最小的 $N$ 个和，时间复杂度 $O(n^2logn)$，可通过部分数据。
- 优化思路主要是利用序列有序性，只考虑可能成为前 $N$ 小的和的情况，将 $N$ 个有序队列合并排序，每次从堆中取出最小值并将对应队列的下一个元素放入堆，时间复杂度优化到 $O(nlogn)$。

所选的题解：
  - **作者：Red_w1nE (赞：368)  星级：5星**
    - **关键亮点**：思路清晰简洁，准确阐述利用堆将 $N$ 个有序队列合并排序的方法，直接点明核心思路，无多余赘述。
  - **作者：雷州半岛岛主 (赞：290)  星级：5星**
    - **关键亮点**：不仅给出详细思路，还展示了从朴素想法到优化的过程，代码实现清晰，对优化点解释形象生动。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100000],b[100000],heap[100000],from[100000],step[100000],n,sum=1;
void swap(int x,int y) {
    int k = heap[x];
    heap[x] = heap[y];
    heap[y] = k;
    k = from[x];
    from[x] = from[y];
    from[y] = k;
}
int main() {
    scanf("%d",&n);
    for (int i = 1;i <= n;i++) scanf("%d",&a[i]);
    for (int i = 1;i <= n;i++) scanf("%d",&b[i]);
    for (int i = 1;i <= n;i++) heap[i] = a[i]+b[1],from[i] = i,step[i] = 1; 
    while (sum <= n) {
        printf("%d ",heap[1]);
        int t = from[1];
        step[t]++;
        heap[1]=a[t] + b[ step[t] ];
        int x = 1,s;
        while (x<<1 <= n) {
            s = x<<1;
            if (heap[s] > heap[s + 1] && s + 1 <= n) s++;
            if (heap[x] > heap[s]) {
                swap(x,s);
                x = s;
            }else break;
        }
        sum++;
    }
    return 0;
}
```
核心实现思想：初始化时将 $a[i]+b[1]$ 放入堆，每次输出堆顶后，更新堆顶为 $a[t]+b[step[t]+1]$ 并维护堆。
  - **作者：ysner (赞：154)  星级：4星**
    - **关键亮点**：代码简短简洁，运用 `pair` 将两个优先队列绑定起来，并通过数组 `to` 巧妙解决数对重复问题。
```cpp
#include<cstdio>  
#include<queue>   
using namespace std;
int a[100005]={}, b[100005]={}, to[100005]={},i, n;
priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > >q;
int main() {
    scanf("%d", &n);
    for (i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (i = 1; i <= n; i++) {
        scanf("%d", &b[i]); to[i] = 1;
        q.push(pair<int, int>(a[1] + b[i], i));
    }
    while (n--) {
        printf("%d ", q.top().first);
        i = q.top().second; q.pop();
        q.push(pair<int, int>(a[++to[i]] + b[i], i));
    }
    return 0;
}
```
核心实现思想：初始化时将 $a[1]+b[i]$ 及其对应的 $b$ 序列下标 $i$ 以 `pair` 形式放入优先队列，每次输出队顶和后，更新并放入新的 `pair` $(a[++to[i]] + b[i], i)$。

最优关键思路或技巧：利用堆（优先队列）来维护可能的最小和，利用序列的有序性，只考虑必要的和，避免对所有 $N^2$ 个和进行处理。例如，先将 $A[1]+B[i]$ 放入堆，每次取出堆顶元素 $A[k]+B[j]$ 后，将 $A[k]+B[j + 1]$ 放入堆中，确保每次得到的都是当前最小的和。

可拓展之处：同类型题或类似算法套路包括多个有序序列的合并问题，可类比本题方法，先将部分元素放入堆，通过堆来动态选择最小值并更新。

推荐题目：
  - [P2085 最小函数值](https://www.luogu.com.cn/problem/P2085)
  - [P3479 [POI2008]STA-Station](https://www.luogu.com.cn/problem/P3479)
  - [P1456 Monkey King](https://www.luogu.com.cn/problem/P1456)

个人心得摘录与总结：
  - **作者：雷州半岛岛主**：提到定义数组存所有和会爆空间，经提醒后想到优化方法，即现做现卖的合成，避免提前计算所有和，优化空间复杂度。总结为在解决问题时要注意空间复杂度，及时发现并优化可能出现的空间问题。 

---
处理用时：57.79秒
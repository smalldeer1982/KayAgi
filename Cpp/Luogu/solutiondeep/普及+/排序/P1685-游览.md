# 题目信息

# 游览

## 题目描述

顺利通过了黄药师的考验，下面就可以尽情游览桃花岛了！

你要从桃花岛的西头开始一直玩到东头，然后在东头的码头离开。可是当你游玩了一次后，发现桃花岛的景色实在是非常的美丽！！！于是你还想乘船从桃花岛东头的码头回到西头，再玩一遍，但是桃花岛有个规矩：你可以游览无数遍，但是每次游玩的路线不能完全一样。

我们把桃花岛抽象成了一个图，共 $n$ 个点代表路的相交处，$m$ 条边表示路，边是有向的（只能按照边的方向行走），且可能有连接相同两点的边。输入保证这个图没有环，而且从西头到东头至少存在一条路线。两条路线被认为是不同的当且仅当它们所经过的路不完全相同。

你的任务是：把所有不同的路线游览完一共要花多少时间？


## 说明/提示

【样例说明】

共有 $3$ 条路径可以从点 $1$ 到点 $3$，分别是 $1-2-3$，$1-2-3$，$1-3$。

时间计算为：

$(5+7)+7        +(5+10)+7        +(15)=56$

### 数据范围

$2\leq n\leq 10^4$，$1\leq m\leq 5\times 10^4$，$t\leq 10^4$，$t_0\leq 10^4$。

## 样例 #1

### 输入

```
3 4 1 3 7
1 2 5
2 3 7
2 3 10
1 3 15
```

### 输出

```
56```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何在有向无环图（DAG）中计算从起点到终点所有不同路径的总时间。思路核心为通过拓扑排序结合递推来统计路径数量和路径长度总和。
 - **思路**：多数题解定义数组记录到每个点的路径数和路径长度和，利用拓扑排序保证递推顺序正确，避免信息未收集全就更新其他点。
 - **算法要点**：借助拓扑排序，将入度为0的点加入处理，更新其邻接点的路径数和路径长度和。
 - **解决难点**：防止在点的信息未收集完整时就用于更新其他点，通过拓扑排序确保处理顺序，使每个点在处理时其入边信息已全部处理完毕。

### 所选的题解
 - **作者：ZAGER (5星)**
    - **关键亮点**：思路清晰，先阐述错误的直接dfs做法及原因，再引入拓扑排序解决问题，代码注释详细，对关键数组的定义和转移方程解释到位。
    - **个人心得**：“我一开始就直dfs，还是太菜了（20分）。为什么这样不对？？因为有一些点的信息我们还没有收集全面就用它去更新其他点了。” 总结了直接dfs导致错误的原因。
```cpp
// 拓扑排序结合递推核心代码
inline void dfs(R int x) {
    for(R int i = h[x]; i; i = edge[i].nex) {
        R int xx = edge[i].to;
        (dis[xx] += dis[x] + cnt[x] * edge[i].dis) %= mod;
        (cnt[xx] += cnt[x]) %= mod;
        --in[xx];//拓扑排序
        if(!in[xx]) dfs(xx);
    }
}
```
 - **作者：Dehydration (4星)**
    - **关键亮点**：从动态规划思路出发，详细展示从错误代码到正确代码的改进过程，对状态转移方程的解释通俗易懂，通过记录点的入度解决信息不全和超时问题。
```cpp
// 拓扑排序结合递推核心代码
void DP(int x) {
    for(int i = head[x]; i; i = a[i].next) {
        int y = a[i].to;
        dp[y][0] = (dp[x][0] + dp[y][0]) % 10000;
        dp[y][1] = (dp[y][1] + dp[x][1] + dp[x][0] * a[i].money) % 10000;
        in[y]--;
        if(!in[y]) DP(y);
    }
}
```
 - **作者：_djc_ (4星)**
    - **关键亮点**：对题目分析透彻，清晰阐述递推式子的推导过程，代码实现中采用拓扑排序结合队列的方式，逻辑严谨，注释对关键步骤有说明。
```cpp
// 拓扑排序结合递推核心代码
signed main() {
    // 输入部分省略
    queue<int> q;
    for (int i = 1; i <= n; i++)
        if (in[i] == 0) q.push(i), ct[i] = 1;
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        for (int i = head[x]; i; i = e[i].nxt) {
            int y = e[i].v, z = e[i].w;
            tme[y] = (tme[y] + tme[x] + ct[x] * z) % mod;
            ct[y] = (ct[y] + ct[x]) % mod;
            if (--in[y] == 0) q.push(y);
        }
    }
    cout << (tme[t] + (ct[t] - 1) * t0 % mod) % mod;
}
```

### 最优关键思路或技巧
 - **拓扑排序**：利用DAG的性质，通过拓扑排序保证计算顺序，使每个点在更新其邻接点时自身信息已完整，避免错误和超时。
 - **状态记录与递推**：定义数组记录到每个点的路径数和路径长度和，通过递推关系更新这些值，最终得到从起点到终点的总路径长度和路径数。

### 可拓展之处
此类题目可拓展到其他DAG上的计数或求和问题，如计算不同路径的某种属性总和。类似算法套路为在DAG上结合拓扑排序进行状态转移，根据具体问题定义合适的状态和转移方程。

### 相似知识点洛谷题目
 - **P1983 车站分级**：通过拓扑排序确定车站等级关系。
 - **P3387 【模板】缩点**：涉及有向图的缩点操作，缩点后可在DAG上进行相关计算。
 - **P2883 [USACO07MAR]牛交通Cow Traffic**：同样在DAG上统计路径数量等信息。

### 个人心得摘录与总结
 - **ZAGER**：直接dfs会因点信息收集不全就更新其他点而导致错误，强调拓扑排序在本题中的重要性。
 - **Dehydration**：做动态规划题时可能会因考虑不全面（如一开始没想到记录方案数）而出现错误，通过记录点的入度可解决信息不全和超时问题。 

---
处理用时：42.43秒
# 题目信息

# [NOIP 2013 普及组] 车站分级

## 题目背景

NOIP2013 普及组 T4

## 题目描述

一条单向的铁路线上，依次有编号为 $1, 2, …, n$ 的 $n $ 个火车站。每个火车站都有一个级别，最低为 $1$ 级。现有若干趟车次在这条线路上行驶，每一趟都满足如下要求：如果这趟车次停靠了火车站 $x$，则始发站、终点站之间所有级别大于等于火车站 $x$ 的都必须停靠。  
注意：起始站和终点站自然也算作事先已知需要停靠的站点。

例如，下表是 $ 5 $ 趟车次的运行情况。其中，前 $ 4$ 趟车次均满足要求，而第 $5$ 趟车次由于停靠了 $3$ 号火车站（$2$ 级）却未停靠途经的 $6$ 号火车站（亦为 $2$ 级）而不满足要求。



 ![](https://cdn.luogu.com.cn/upload/pic/1238.png) 

现有 $m$ 趟车次的运行情况（全部满足要求），试推算这 $ n$ 个火车站至少分为几个不同的级别。


## 说明/提示

对于 $ 20\%$ 的数据，$1 ≤ n, m ≤ 10$；

对于 $50\%$ 的数据，$1 ≤ n, m ≤ 100$；

对于 $100\%$ 的数据，$1 ≤ n, m ≤ 1000$。


## 样例 #1

### 输入

```
9 2 
4 1 3 5 6 
3 3 5 6 ```

### 输出

```
2```

## 样例 #2

### 输入

```
9 3 
4 1 3 5 6 
3 3 5 6 
3 1 5 9 ```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何通过拓扑排序解决车站分级问题。思路上，利用车次停靠站与非停靠站的关系构建有向图，非停靠站指向停靠站，通过拓扑排序确定图的层级，即车站最少分级数。
算法要点在于准确建图和进行拓扑排序。解决难点方面，部分题解考虑优化建边以降低时间复杂度，如引入虚点优化。
多数题解思路清晰，但在代码可读性和优化程度上有差异。

### 所选的题解
1. **作者：SCUT_HYX (赞：451)  5星**
    - **关键亮点**：思路阐述清晰，结合图示说明拓扑思想，代码简洁明了，变量命名规范。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ZYS 1005
using namespace std;
int n,m,ans,st[ZYS],s,tuopu[ZYS][ZYS],de[ZYS],tt[ZYS],top;
bool is[ZYS],bo[ZYS];
int main() {
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++) {
        memset(is,0,sizeof(is));
        scanf("%d",&s);
        for(int j=1;j<=s;j++)
            scanf("%d",&st[j]),is[st[j]]=true;
        for(int j=st[1];j<=st[s];j++)
            if(!is[j])
                for(int k=1;k<=s;k++)
                    if(!tuopu[j][st[k]]) tuopu[j][st[k]]=1,de[st[k]]++;
    }
    
    do{
        top=0;
        for(int i=1;i<=n;i++)
            if(de[i]==0&&!bo[i]) {
                tt[++top]=i,bo[i]=true;
            }
        for(int i=1;i<=top;i++)
            for(int j=1;j<=n;j++)
                if(tuopu[tt[i]][j]) tuopu[tt[i]][j]=0,de[j]--;
        ans++;
    } while(top);
    printf("%d",ans-1);
    return 0;
}
```
    - **核心实现思想**：通过双重循环遍历车次和站点，构建表示车站级别关系的有向图`tuopu`及入度数组`de`。利用`do - while`循环进行拓扑排序，每次找出度为0的点，删除这些点及其相关边，统计拓扑排序的层数得到答案。

2. **作者：Sakura___ (赞：37)  4星**
    - **关键亮点**：采用拓扑排序 + 虚点优化 + 线段树优化连边，大幅优化边数，提高效率。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1500;
int head[N << 3], top, n, m, tp, stp[N], in[N << 3], arc[N];
bool nd[N << 3];
struct Node
{
    int y, nxt;
    Node() {    }
    Node( int y, int nxt ) : y(y), nxt(nxt) {    }
} e[N * 700];
void Adde( int x, int y )
{
    in[y]++;
    e[++top] = Node(y, head[x]), head[x] = top;
}
#define ls (bt << 1)
#define rs (bt << 1 | 1)
void Build( int bt, int lf, int rg )
{
    tp = max(tp, bt);
    if(lf == rg)
    {
        arc[lf] = bt;
        nd[bt] = 1;
        return;
    }
    int mid = (lf + rg) >> 1;
    Adde(ls, bt);
    Build(ls, lf, mid);
    Adde(rs, bt);
    Build(rs, mid + 1, rg);
}
void Query( int bt, int lf, int rg, int L, int R, int tmp )
{
    if(L > R) return;
    if(L <= lf && rg <= R)
    {
        Adde(bt, tmp);
        return;
    }
    int mid = (lf + rg) >> 1;
    if(L <= mid) Query(ls, lf, mid, L, R, tmp);
    if(R > mid) Query(rs, mid + 1, rg, L, R, tmp);
}
int que[N << 5], h, t, dep[N << 3];
void Bfs()
{
    for(int i = 1; i <= tp; ++i)
        if(!in[i]) que[++t] = i, dep[i] = nd[i];
    while(h < t)
    {
        int u = que[++h];
        for(int i = head[u]; i; i = e[i].nxt)
        {
            int v = e[i].y;
            in[v]--;
            dep[v] = max(dep[u] + nd[v], dep[v]);
            if(in[v] == 0) que[++t] = v;
        }
    }
}
int main()
{
    cin >> n >> m;
    Build(1, 1, n);
    for(int i = 1, cnt; i <= m; ++i)
    {
        scanf( "%d", &cnt );
        ++tp;
        for(int j = 1; j <= cnt; ++j)
            scanf( "%d", &stp[j] );
        for(int j = 1; j < cnt; ++j)
        {
            Adde(tp, arc[stp[j]]);
            Query(1, 1, n, stp[j] + 1, stp[j + 1] - 1, tp);
        }
        Adde(tp, arc[stp[cnt]]);
    }
    Bfs();
    int ans = 0;
    for(int i = 1; i <= n; ++i)
        ans = max(ans, dep[arc[i]]);
    cout << ans << endl;
    return 0;
} 
```
    - **核心实现思想**：先通过`Build`函数构建线段树，每个叶子节点对应一个车站。在车次处理时，引入虚点，利用`Query`函数通过线段树优化非停靠站与停靠站之间的连边操作，最后通过`Bfs`函数进行拓扑排序求最长路得到车站最少分级数。

3. **作者：XCDRF (赞：2)  4星**
    - **关键亮点**：思路清晰，提出虚点优化建边降低时间复杂度，代码注释详细。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int N=1e6+5;
int n,m,tot,num,nw,ans;
int head[N],ind[N],dep[N];
bool flag[N];
queue<int> q;
struct edge{
    int nxt,to;
}edge[N];
void add(int x,int y){
    edge[++tot].nxt=head[x];
    edge[tot].to=y;
    head[x]=tot;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m;
    nw=n;
    for(int i=1;i<=m;i++){
        cin>>num;
        memset(flag,0,sizeof(flag));
        int minn,maxx;
        for(int j=1,idx;j<=num;j++){
            cin>>idx;
            if(j==1) minn=idx;
            if(j==num) maxx=idx;
            flag[idx]=1;
        }
        nw++;
        for(int j=minn;j<=maxx;j++){
            if(flag[j]){
                add(nw,j);
                ind[j]++;
            }
            else{
                add(j,nw);
                ind[nw]++;
            }
        }
    }
    for(int i=1;i<=nw;i++)
        if(!ind[i]){
            if(i<=n) dep[i]=1;
            q.push(i);
        }
    while(!q.empty()){
        int x=q.front();
        ans=max(dep[x],ans);
        q.pop();
        for(int i=head[x];i;i=edge[i].nxt){
            int xx=edge[i].to;
            if(xx>n) dep[xx]=max(dep[xx],dep[x]);
            else dep[xx]=max(dep[xx],dep[x]+1);
            --ind[xx];
            if(!ind[xx]) q.push(xx);
        }
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：在车次处理时，为每趟车次引入一个虚点，非停靠站向虚点连边，虚点向停靠站连边，构建有向图及入度数组`ind`。对所有入度为0的点（车站及虚点）进行拓扑排序，在排序过程中更新各点的深度`dep`，最终得到车站最少分级数。

### 最优关键思路或技巧
虚点优化建边是降低时间复杂度的关键技巧，通过引入虚点，将原本 $O(n^2)$ 条边的建边操作优化为 $O(n)$ 条边，有效提升算法效率。同时，利用拓扑排序确定图的层级结构，准确解决车站分级问题。

### 可拓展之处
此类问题属于图论中拓扑排序应用类型，类似套路可用于解决具有层级依赖关系的问题，如任务调度、课程安排等，这些问题中元素之间存在先后顺序或等级关系，可通过构建有向图并拓扑排序求解。

### 推荐题目
1. **P1807 最长路**：通过拓扑排序求有向无环图的最长路，与本题利用拓扑排序确定层级结构思路相似。
2. **P3387 【模板】缩点**：涉及图的缩点和拓扑排序，可加深对图论综合应用的理解。
3. **P2698 [USACO12MAR]Running Away From the Barn G**：通过拓扑排序解决奶牛逃跑路径问题，同样是利用拓扑关系解决实际场景问题。 

---
处理用时：99.49秒
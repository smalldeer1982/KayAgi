# 题目信息

# [ZJOI2004] 午餐

## 题目描述

上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。

THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。

现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。

假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。

现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。


## 说明/提示

所有输入数据均为不超过200的正整数。


## 样例 #1

### 输入

```
5

2 2

7 7

1 3

6 4

8 5

```

### 输出

```
17```

# AI分析结果

• 综合分析与结论：这道题是典型的贪心与动态规划结合的问题。所有题解的核心思路都是先通过贪心策略对人员按吃饭时间从大到小排序，以保证整体方案较优，再利用动态规划来确定最优的分队和排队方案。动态规划部分，多数题解采用二维数组 `f[i][j]` 表示前 `i` 个人，在1号窗口打饭总时间 `j` 时最早吃完饭的时间，通过状态转移方程来更新结果。不同题解在贪心证明、状态转移方程推导和代码实现细节上有所差异。

所选的题解：
 - 作者：M_seа (赞：193)
   - 星级：5星
   - 关键亮点：思路清晰，先阐述贪心思路并直接给出排序做法，接着详细讲解动态规划状态定义、空间优化及状态转移方程推导，代码简洁明了，注释详细。
   - 重点代码及核心实现思想：
```cpp
// 结构体定义及排序
struct node
{
    int a, b;
    bool operator <(node z) const
    {
        return b>z.b;
    }
}s[N];
sort(s+1, s+1+n);

// 前缀和计算
for(int i = 1; i <= n; i++)
    sum[i] = sum[i-1] + s[i].a;

// 动态规划
memset(f, 127, sizeof(f));
f[0][0] = 0;
for(int i = 1; i <= n; i++)
{
    for(int j = 0; j <= sum[i]; j++)
    {
        if(j>=s[i].a) f[i][j] = min(f[i][j], max(f[i-1][j-s[i].a], j+s[i].b));
        f[i][j] = min(f[i][j], max(f[i-1][j], sum[i]-j+s[i].b));
    }
}
```
核心实现思想是先对人员按吃饭时间从大到小排序，计算打饭时间前缀和，通过动态规划的两重循环，根据状态转移方程更新 `f[i][j]`，最后得到最优结果。

 - 作者：ddwqwq (赞：51)
   - 星级：4星
   - 关键亮点：对思路的讲解非常详细，先分析常规动态规划思路存在的问题，再分别阐述如何用贪心解决选择顺序问题和通过更简练状态描述解决内存问题，证明过程较严谨，代码采用记忆化搜索实现动态规划。
   - 个人心得：作者提到复习DP时思考方程困难，题解大多语焉不详，所以自己详细写题解方便后来者，强调了清晰题解的重要性。
   - 重点代码及核心实现思想：
```cpp
// 记忆化搜索实现动态规划
int dfs(int i, int now, int q)
{
    if (i > N)
        return 0;
    if (d[i][now][q] > 0)
        return d[i][now][q];

    return d[i][now][q] = max(now + time[i] + eat[i], min(dfs(i + 1, now + time[i], q), dfs(i + 1, sum[i] - now - time[i], 1 - q)));
}
```
核心实现思想是通过记忆化搜索，根据状态转移方程递归计算不同状态下的最短集合时间。

 - 作者：TH讠NK (赞：20)
   - 星级：4星
   - 关键亮点：对贪心和动态规划都进行了详细证明和分析，先给出贪心证明过程，再逐步讲解动态规划状态设计、状态转移方程推导及空间优化过程，逻辑连贯。
   - 重点代码及核心实现思想：
```cpp
// 结构体定义及排序
struct person{
    int a,b;
    bool operator < (const person &x) const {return b>x.b;}
} p[maxn];
sort(p+1,p+n+1);

// 前缀和计算
for(int i=1;i<=n;i++) s[i]=s[i-1]+p[i].a;

// 动态规划
memset(f,0x3f,sizeof(f));
f[0][0]=0;
for(int i=1;i<=n;i++)
    for(int j=0;j<=s[i];j++){
        if(j>=p[i].a) f[i][j]=min(f[i][j],max(f[i-1][j-p[i].a],j+p[i].b));
        f[i][j]=min(f[i][j],max(f[i-1][j],s[i]-j+p[i].b));
    }
```
核心实现思想与其他题解类似，先排序和计算前缀和，然后通过动态规划的两重循环，依据状态转移方程更新 `f[i][j]` 得到最优解。

最优的关键思路或技巧：
 - **贪心策略**：通过证明可知，将吃饭时间长的人先安排打饭能使整体时间更优，这一贪心策略大大简化了问题。
 - **动态规划状态优化**：将三维状态（前 `i` 个人，1号窗口打饭总时间，2号窗口打饭总时间）优化为二维状态（前 `i` 个人，1号窗口打饭总时间），利用前缀和计算出2号窗口打饭总时间，既满足需求又避免内存超限。

可拓展之处：此类题目属于贪心与动态规划结合的问题，类似套路是先通过贪心策略确定元素顺序，再用动态规划进行状态转移求解。例如在任务分配、资源调度等场景下的问题都可能用到类似方法。

推荐题目：
 - [P1080国王游戏](https://www.luogu.com.cn/problem/P1080)：同样是贪心与其他算法结合的题目，通过贪心确定排列顺序后进一步求解。
 - [P2123皇后游戏](https://www.luogu.com.cn/problem/P2123)：与本题类似，需要先证明贪心策略的正确性，再进行后续计算。
 - [P1223排队接水](https://www.luogu.com.cn/problem/P1223)：简单的贪心算法题目，可作为理解贪心策略的基础练习，与本题贪心思路有相通之处。 

---
处理用时：46.22秒
# 题目信息

# [NOIP 2015 普及组] 求和

## 题目背景

NOIP2015 普及组 T3

## 题目描述

一条狭长的纸带被均匀划分出了 $n$ 个格子，格子编号从 $1$ 到 $n$。每个格子上都染了一种颜色 $color_i$ 用 $[1,m]$ 当中的一个整数表示），并且写了一个数字 $number_i$。

| 编号 | 1 | 2 | 3 | 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| **颜色和数字** | $\color{blue}{5}$ | $\color{blue}{5}$ | $\color{red}{3}$ | $\color{red}{2}$ | $\color{blue}{2}$ | $\color{red}{2}$ |

定义一种特殊的三元组：$(x,y,z)$，其中 $x,y,z$ 都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：

1. $x,y,z$ 都是整数，$x<y<z,y-x=z-y$。

2. $color_x=color_z$。

满足上述条件的三元组的分数规定为 $(x+z) \times (number_x+number_z)$。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以 $10007$ 所得的余数即可。


## 说明/提示

**样例 1 解释**

纸带如题目描述中的图所示。

所有满足条件的三元组为：$(1, 3, 5), (4, 5, 6)$。

所以纸带的分数为 $(1 + 5) \times (5 + 2) + (4 + 6) \times (2 + 2) = 42 + 40 = 82$。


对于第 $1$ 组至第 $2$ 组数据， $1 ≤ n ≤ 100, 1 ≤ m ≤ 5$；

对于第 $3$ 组至第 $4$ 组数据，$1 ≤ n ≤ 3000, 1 ≤ m ≤ 100$；

对于第 $5$ 组至第 $ 6 $ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000$，且不存在出现次数超过 $ 20 $ 的颜色；

对于全部 $10$ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000, 1 ≤ color_i ≤ m,1≤number_i≤100000$。


## 样例 #1

### 输入

```
6 2
5 5 3 2 2 2
2 2 1 1 2 1```

### 输出

```
82
```

## 样例 #2

### 输入

```
15 4
5 10 8 2 2 2 9 9 7 7 5 6 4 2 4
2 2 3 3 4 3 3 2 4 4 4 4 1 1 1```

### 输出

```
1388```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是利用题目中三元组条件的性质，优化暴力解法。首先，由\(y - x = z - y\)推出\(x + z = 2y\)，得出\(x\)与\(z\)同奇偶的结论，且分数计算与\(y\)无关。然后按颜色和奇偶性对格子进行分类，通过推导公式或利用前缀和等方式优化计算。

### 所选的题解
- **作者：云浅知处 (赞：187)  5星**
    - **关键亮点**：思路清晰，先通过数学推导得出\(x,z\)同奇偶的性质，再详细阐述按颜色和奇偶性分类的方法，并以实例展示分类过程。在计算分数时，通过逐步推导式子，得出只需处理数组前缀和即可优化计算的结论，对公式推导过程讲解细致。
    - **个人心得**：无
    - **重点代码核心思想**：通过对分数计算公式展开推导，发现可通过维护数组\(f\)（编号）、\(n\)（数字）以及\(f[i] \cdot n[i]\)的前缀和来优化计算。
    - **核心代码片段**：无
- **作者：Victorique_De_Blois (赞：74)  5星**
    - **关键亮点**：从得分公式出发，利用乘法分配律展开，推导出以\(i\)为三元组第一个数的得分公式\(Score_{i_n}=i_n\cdot[\sum_{d=1}^nnumber_{i_d}+(n - 2)\cdot number_{i_n}]\)，并结合同余定理进行改写。代码实现简洁明了，直接利用前缀和优化到\(O(n)\)。
    - **个人心得**：无
    - **重点代码核心思想**：通过定义\(sum[color_i][g]\)和\(nt[color_i][g]\)分别表示同颜色同奇偶集合的数字和与个数，利用前缀和思想一边输入一边累加，最后根据推导公式计算答案。
    - **核心代码片段**：
```cpp
#include <cstdio>

const int N = 100000;
const int M = 10007;
int n, m;
int sum[N + 1][2], nt[N + 1][2];
int color[N + 1], number[N + 1];
long long ans = 0;

int main()
{
    scanf(" %d %d", &n, &m);
    for(int i = 1; i <= n; i++) {
        scanf("%d", &number[i]);
        number[i] %= M;
    }
    for(int i = 1; i <= n; i++) {
        scanf("%d", &color[i]);
        int c = color[i];
        int g = i % 2;
        nt[c][g]++;
        sum[c][g] += number[i];
        sum[c][g] %= M;
    }
    for(int i = 1; i <= n; i++) {
        int c = color[i];
        int g = i % 2;
        ans += i % M * ((sum[c][g] + (nt[c][g] - 2) % M * number[i] + M) % M);
        ans %= M;
    }
    printf("%lld", ans);
    return 0;
}
```
- **作者：一叶知秋。 (赞：28)  4星**
    - **关键亮点**：同样从分数计算公式入手，通过乘法分配律展开式子，发现可通过前缀和维护部分值。针对前缀和内存爆炸问题，提出在求解过程中同时完成计算，只需记录相同颜色的和（分奇偶），思路独特且实用。
    - **个人心得**：无
    - **重点代码核心思想**：定义三维数组\(s_c\)，第一维表示颜色，第二维表示奇偶，第三维分别记录满足条件的个数、\(\sum z \times number_z\)、\(\sum z\)、\(\sum number_z\)，在遍历过程中同时计算答案。
    - **核心代码片段**：
```cpp
#include<cstdio>

#define ll long long
#define maxn 111111
#define mod 10007

inline ll read(){
    ll r = 0,f = 1;
    char c = getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')r=(r<<1)+(r<<3)+(c^48),c=getchar();
    return r*f;
}

int n,m,num[maxn],col[maxn];

ll ans,s_c[maxn][2][4];//第一维是颜色，第二维是奇偶
//第三维第一个是前面满足条件的个数，第二个是∑z*number_z
//第三个是∑z，第四个是∑number_z
int main(){
    n = read(),m = read();
    for(int i = 1; i <= n; i++)num[i] = read()%mod;
    for(int i = 1; i <= n; i++)col[i] = read()%mod;
    for(int i = 1; i <= n; i++){//记得每一步都取模哦
        (ans+=(s_c[col[i]][i%2][0]*(i%mod)*(num[i]%mod))%mod)%=mod;
        (ans+=s_c[col[i]][i%2][1])%=mod;
        (ans+=((i%mod)*s_c[col[i]][i%2][2])%mod)%=mod;
        (ans+=((num[i]%mod)*s_c[col[i]][i%2][3])%mod)%=mod;
        (s_c[col[i]][i%2][0]+=1)%=mod;
        (s_c[col[i]][i%2][1]+=(i%mod)*(num[i]%mod))%=mod;
        (s_c[col[i]][i%2][2]+=num[i]%mod)%=mod;
        (s_c[col[i]][i%2][3]+=i%mod)%=mod;
    }
    printf("%lld",ans);
    return 0;
}
```

### 最优关键思路或技巧
1. **数学推导优化**：通过对题目条件和分数计算公式进行数学推导，如利用乘法分配律展开式子，找出规律，将\(O(n^2)\)的暴力计算优化为\(O(n)\)。
2. **分类统计**：根据\(x,z\)同奇偶且颜色相同的性质，按颜色和奇偶性对格子分类，分别统计各类格子的相关信息（如个数、数字和、编号和等），简化计算。
3. **前缀和思想**：利用前缀和维护部分计算结果，减少重复计算，提高计算效率。

### 可拓展之处
此类题目属于数学优化与统计类问题，类似套路为通过对题目条件进行数学分析，挖掘隐藏性质，利用分类讨论和数据结构（如数组）维护中间结果，优化暴力解法。同类型题可考察不同的条件限制和计算公式，关键在于能否通过数学推导简化计算过程。

### 相似知识点洛谷题目
1. **P1147 连续自然数和**：通过数学分析找出满足条件的连续自然数序列，与本题类似需挖掘题目隐藏性质进行求解。
2. **P2261 [CQOI2007]余数求和**：利用数学推导优化暴力枚举，与本题优化思路相似。
3. **P1972 [SDOI2009]HH的项链**：同样涉及对数据的分类统计，通过合理的数据结构和算法优化来解决问题。

### 个人心得摘录与总结
无

---
处理用时：59.89秒
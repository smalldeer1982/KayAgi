# 题目信息

# [USACO3.1] 丑数 Humble Numbers

## 题目描述

对于一给定的素数集合 $S = \{ p_1, p_2, ..., p_k \}$, 考虑一个正整数集合，该集合中任一元素的质因数全部属于 $S$。这个正整数集合包括，$p_1$、$p_1 \times p_2$、$p_1 \times p_1$、$p_1 \times p_2 \times p_3$ ...(还有其它)。该集合被称为 $S$ 集合的“丑数集合”。注意：我们认为 $1$不是一个丑数。

你的工作是对于输入的集合 $S$ 去寻找“丑数集合”中的第 $n$ 个“丑数”。保证答案可以用 32 位有符号整数表示。

补充：丑数集合中每个数从小到大排列，每个丑数都是素数集合中的数的乘积，第 $n$ 个“丑数”就是在能由素数集合中的数相乘得来的（包括它本身）第 $n$ 小的数。


## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq k \leq 100$。
- $1 \leq n \leq 10^5$。
- $2 \leq p_i < 2^{31}$，且 $p_i$ 一定为质数。

---
#### 说明

题目翻译来自 NOCOW。

USACO Training Section 3.1


## 样例 #1

### 输入

```
4 19
2 3 5 7```

### 输出

```
27```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找给定素数集合生成的丑数集合中的第n个丑数展开。思路可分为以下几类：
1. **暴力枚举优化**：通过记录每个质数上次满足条件的丑数下标，避免重复计算，如作者Mark_ZZY、「QQ红包」、Celebrate、Tanktt、muyang_233等题解。
2. **优先队列/堆**：每次取出堆顶最小丑数，乘以素数集合元素后放回堆中，处理好判重问题，如作者汉皇思倾国、猫粮寸断、Michael_Li、kczno1等题解。
3. **平衡树**：用平衡树维护丑数集合，每次取出最小丑数，乘以素数集合元素后加入平衡树，处理好判重和多余丑数删除问题，如作者Log_x、vegetabird题解。
4. **单调队列**：开多个单调递增队列，每次从队列顶部取最小元素，乘以所有质数后放入相应队列，如作者ghj1222题解。

解决难点主要在于如何高效地生成丑数并避免重复计算，不同方法通过不同的数据结构和优化策略来实现。

### 所选的题解
- **作者Mark_ZZY（5星）**
    - **关键亮点**：思路清晰，代码简洁高效。通过双循环枚举质数和丑数，利用记录每个质数对应的丑数下标来优化，避免重复寻找满足条件的丑数。
    - **核心代码**：
```cpp
#include<cstdio>
    int n,m;
    int a[101],b[101];
    int s[100001];
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    s[0]=1;
    for(int i=1;i<=m;i++)
    {
        int min=2147483647;
        for(int j=1;j<=n;j++)
        {
            while(a[j]*s[b[j]]<=s[i-1]) b[j]++;
            if(a[j]*s[b[j]]<min) min=a[j]*s[b[j]];
        }
        s[i]=min;
    }
    printf("%d",s[m]);
}
```
    - **核心实现思想**：外层循环枚举第i个丑数，内层循环枚举每个质数，通过while循环找到每个质数与大于上一个丑数的最小丑数乘积，取所有乘积中的最小值作为第i个丑数。

- **作者「QQ红包」（4星）**
    - **关键亮点**：对暴力枚举的优化思路阐述详细，易于理解。同样采用记录每个质数对应丑数下标的方式优化。
    - **核心代码**：
```cpp
#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long   
using namespace std;
int n,i,j,m,k; 
long long a[123],s[100011],f[100011];
int main() 
{
    freopen("humble.in","r",stdin);
    freopen("humble.out","w",stdout);
    scanf("%d%d",&k,&n);
    for (i=1;i<=k;i++)
        scanf("%d",&a[i]);//读入 
    f[0]=1;//假设1是丑数
    for (i=1;i<=n;i++)//枚举n个丑数 
    {
        m=2000000000;//赋初值，随便赋就好，赋大些 
        for (j=1;j<=k;j++)
        {
//s[j]存的是a[j]至少与第几小丑数相乘才能得到一个比f[i-1]大的丑数 
            while (a[j]*f[s[j]]<=f[i-1]) s[j]++;//找到符合条件的最小的s[j];
            if (a[j]*f[s[j]]<m) m=a[j]*f[s[j]];//比较 
        }
        f[i]=m; //存起来 
    } 
    printf("%d\n",f[n]); 
    return 0;
}
```
    - **核心实现思想**：与Mark_ZZY类似，通过内外层循环枚举丑数和质数，利用数组s记录每个质数对应的丑数下标，找到大于上一个丑数的最小丑数乘积作为当前丑数。

- **作者Celebrate（4星）**
    - **关键亮点**：先给出暴力解法，再详细讲解优化过程，对比清晰，帮助理解。
    - **暴力核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[110],f[110000];
int minn;
int main()
{
    int i,j,t;
    scanf("%d%d",&k,&n);
    for(i=1;i<=k;i++) scanf("%d",&a[i]);//输入 
    f[0]=1;//假设第0项是为1 
    for(i=1;i<=n;i++)//暴力的从1枚举到n 
    {
        minn=2147483647;//2^31-1（最大值） 
        for(j=1;j<=k;j++)//暴力枚举每一个素数 
        {
            for(t=0;t<i;t++)//枚举以前出现的过的丑数 
            {
                if(a[j]*f[t]>f[i-1])//如果满足要求
                {
                    minn=min(minn,a[j]*f[t]);//求最小值 
                    break;//就直接弹出，因为后面的肯定比这个大，所以没有必要求后面的数 
                }
            }
        }
        f[i]=minn;//赋值 
    }
    printf("%d\n",f[n]);//输出 
    return 0;
}
```
    - **暴力核心实现思想**：三层循环，外层枚举第i个丑数，中间层枚举质数，最内层枚举之前的丑数，找到大于上一个丑数的最小丑数乘积。
    - **优化核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[110],f[110000],bk[110];
//优化部分bk，每次枚举素数时记录这个素数能满足上一个丑数条件的最小值 
int minn;
int main()
{
    int i,j,t;
    scanf("%d%d",&k,&n);
    for(i=1;i<=k;i++) scanf("%d",&a[i]);//输入 
    f[0]=1;//假设第0项是为1 
    for(i=1;i<=n;i++)//从1枚举到n 
    {
        minn=2147483647;//2^31-1（最大值） 
        for(j=1;j<=k;j++)//枚举每一个素数 
        {
            while(a[j]*f[bk[j]]<=f[i-1]) bk[j]++;//如果这一个不行，就找下一个丑数来，直到可以为止 
            minn=min(minn,a[j]*f[bk[j]]);//求最小值 
        }
        f[i]=minn;//赋值 
    }
    printf("%d\n",f[n]);//输出 
    return 0;
}
```
    - **优化核心实现思想**：用数组bk记录每个质数上次满足条件的丑数下标，避免每次内层循环从头开始枚举，提高效率。

### 最优关键思路或技巧
1. **利用单调性优化枚举**：记录每个质数对应的丑数下标，利用丑数的单调性，避免重复寻找满足条件的丑数，大大降低时间复杂度。
2. **合理使用数据结构**：如优先队列、堆、平衡树等，能有效维护丑数集合的顺序和唯一性，便于高效地取出最小丑数并插入新丑数。

### 同类型题或类似算法套路拓展
同类型题通常围绕特定规则生成的数列中寻找特定位置的数。类似算法套路包括利用数列的单调性、递推关系进行优化，以及合理选用数据结构维护数列。例如在一些需要生成特定倍数关系的数列题目中，可采用类似记录下标避免重复计算的方法。

### 洛谷相似题目推荐
1. **P1073 [NOIP2009 提高组] 最优贸易**：涉及图的遍历和状态记录，可类比本题通过记录状态优化搜索过程。
2. **P1118 [USACO06FEB]数字三角形Backward Digit Su**：通过递推关系寻找最优解，与本题寻找丑数的递推思路有相似之处。
3. **P1439 【模板】最长公共子序列**：利用动态规划和数组记录状态，与本题记录下标优化枚举的思想类似。

### 个人心得摘录与总结
暂无典型的个人心得（调试/顿悟）内容。 

---
处理用时：68.61秒
# 题目信息

# 魔法

## 题目描述

cjwssb 知道是误会之后，跟你道了歉。你为了逗笑他，准备和他一起开始魔法。不过你的时间不多了，但是更惨的是你还需要完成 $n$ 个魔法任务。假设你当前的时间为 $T$，每个任务需要有一定的限制 $t_i$ 表示只有当你的 $T$ 严格大于 $t_i$ 时你才能完成这个任务，完成任务并不需要消耗时间。当你完成第 $i$ 个任务时，你的时间 $T$ 会加上 $b_i$，此时要保证 $T$ 在任何时刻都大于 $0$，那么请问你是否能完成这 $n$ 个魔法任务，如果可以，输出 $\texttt{+1}\texttt{s}$，如果不行，输出 $\texttt{-1}\texttt{s}$。


## 说明/提示

对于 $20\%$ 的数据，$n\leq10$；

对于 $100\%$ 的数据，$n\leq10^5,Z\leq10,t_i\leq10^5,T\leq10^5,-10^5\leq b_i\leq 10^5$。

By lantian

$\LaTeX$ By ⚡炭治郎⚡

## 因为历史遗留问题，博客讨论可能无法发出样例输出的字符串，可以考虑使用其他方式规避。


## 样例 #1

### 输入

```
1
2 13
1 -9
5 -3
```

### 输出

```
+1s
```

# AI分析结果

• 综合分析与结论：这些题解都采用贪心策略解决该问题，思路核心是将任务按 \( b \) 的正负性分类处理。对于 \( b>0 \) 的任务，优先完成 \( t \) 小的任务；对于 \( b<0 \) 的任务，按 \( t + b \) 从大到小排序后依次完成。各题解主要在证明贪心策略正确性以及代码实现方式上有所不同。

所选的题解：
  - 作者：lwz2002 (5星)
    - 关键亮点：思路清晰，不仅阐述贪心策略，还通过具体数据示例说明错误思路，详细证明 \( b<0 \) 时按 \( t + b \) 排序的正确性，代码实现完整规范。
    - 个人心得：提到这题82分卡了一个多小时，暗示在解题过程中遇到过阻碍并成功克服。
    - 重点代码及核心实现思想：
```cpp
// 定义结构体存储任务
struct node
{
    int tim;
    int b;
}a[100010];    //b大于0的任务
struct ss
{
    int tim;
    int b;
}f[100010];    //b小于等于0的任务
// 比较函数，b>0时按tim升序
int cmp(node &a,node &b)
{
    return a.tim<b.tim;    
}
// 比较函数，b<0时按b + tim降序
int comp(ss &a,ss &b)
{
    return a.b+a.tim>b.b+b.tim;    
}
int main()
{
    scanf("%d",&z);
    for(int i=1;i<=z;i++)
    {
        int s=0,cnt=0,num=0;
        scanf("%d%d",&n,&t);
        // 分类存储任务
        for(int j=1;j<=n;j++)
        {
        	int x,y;
        	scanf("%d%d",&x,&y);
        	if(y>0) a[++cnt].tim=x,a[cnt].b=y;
        	else f[++num].tim=x,f[num].b=y;
		}
        // 分别排序
        sort(a+1,a+cnt+1,cmp);
        sort(f+1,f+num+1,comp);
        // 依次完成b>0的任务
        for(int j=1;j<=cnt;j++)
        {
            if(t>a[j].tim) t+=a[j].b;
            else{
                s=1;
                break;
            }
		}
        // 依次完成b<0的任务
        for(int j=1;j<=num;j++)
        {
            if(t>f[j].tim) t+=f[j].b;
            else{
                s=1;
                break;
            }
            if(t<=0){
                s=1;
                break;
            }
        }
        // 输出结果
        if(s==0) printf("+1s\n");
        else printf("-1s\n");
    }
    return 0;
}
```
核心实现思想是先对输入任务按 \( b \) 的正负分类，分别用不同比较函数排序，然后按序尝试完成任务，过程中判断能否完成并及时标记，最后根据标记输出结果。

  - 作者：风中の菜鸡 (4星)
    - 关键亮点：简洁明了地阐述贪心思路，对 \( b<0 \) 时按 \( t + b \) 排序的证明过程清晰，虽未给出代码，但思路足够清晰。
    - 重点代码及核心实现思想（假设实现）：应与lwz2002类似，先分类任务，对 \( b>0 \) 按 \( t \) 升序、 \( b<0 \) 按 \( t + b \) 降序排序，再按序完成任务并判断。

  - 作者：紊莫 (4星)
    - 关键亮点：详细讲解贪心思路及证明过程，尤其对 \( b\le0 \) 的任务通过临项交换方法证明贪心策略，逻辑严谨。
    - 重点代码及核心实现思想（假设实现）：同样先按 \( b \) 正负分类任务，对 \( b>0 \) 按 \( t \) 升序、 \( b<0 \) 按 \( t + b \) 降序排序，按序遍历任务判断能否完成。

最优关键思路或技巧：将任务按 \( b \) 的正负分类处理，对不同类任务采用不同排序依据，利用贪心策略求解。通过不等式推导得出 \( b<0 \) 时按 \( t + b \) 排序能保证最优解。

可拓展之处：同类型题常考察贪心策略在不同条件限制下的应用，类似套路是对问题进行合理分类，针对不同类别分析最优处理顺序，通过数学推导证明贪心策略正确性。

推荐洛谷题目：
  - P1080 [NOIP2012 提高组] 国王游戏，涉及贪心策略及高精度计算。
  - P1199 [NOIP2010 普及组] 三国游戏，需分析贪心策略选择武将。
  - P2859 [USACO06DEC] Milk Team Selecting G，关于奶牛选择的贪心问题。

个人心得摘录及总结：lwz2002提到被82分卡了一个多小时，说明在解题过程中遇到过困难，可能是对贪心策略的细节处理或证明出现问题，经过努力最终解决，体现了解题过程并非一帆风顺，需要不断调试和思考。 

---
处理用时：39.71秒
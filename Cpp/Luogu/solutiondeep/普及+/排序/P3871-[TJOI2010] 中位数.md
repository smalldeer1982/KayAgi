# 题目信息

# [TJOI2010] 中位数

## 题目描述

给定一个由 $N$ 个元素组成的整数序列，现在有两种操作：

- $\texttt{1 add }\textit{a}$：在该序列的最后添加一个整数 $a$，组成长度为 $N + 1$ 的整数序列。
- $\texttt{2 mid}$：输出当前序列的中位数。

中位数是指将一个序列按照从小到大排序后处在中间位置的数。（若序列长度为偶数，则指处在中间位置的两个数中较小的那个）

例 $1$：$[1, 2, 13, 14, 15, 16]$ 中位数为 $13$。  
例 $2$：$[1, 3, 5, 7, 10, 11, 17]$ 中位数为 $7$。  
例 $3$：$[1, 1, 1, 2, 3]$ 中位数为 $1$。


## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$1 ≤ N ≤ 10,000$，$0 ≤ M ≤ 1,000$。
- 对于 $100\%$ 的数据，$1 ≤ N ≤ 100,000$，$0 ≤ M ≤ 10,000$。

序列中整数的绝对值不超过 $10^9$，序列中的数可能有重复。

## 样例 #1

### 输入

```
6
1 2 13 14 15 16
5
add 5
add 3
mid
add 20
mid
```

### 输出

```
5
13
```

# AI分析结果

这道题要求对一个整数序列进行动态维护，并支持添加元素和查询中位数的操作。各题解的思路、算法要点及难点对比如下：
1. **fhq treap**：利用平衡树的插入和查询第k小的操作来实现。通过拆树和合并操作来插入新元素，利用treap的堆性质和二叉搜索树性质查找中位数。难点在于理解和实现fhq treap的各种操作，如split和merge。
2. **STL（vector + lower_bound）**：使用vector存储序列，通过sort排序后，利用lower_bound确定插入位置来实现add操作，根据vector下标直接输出中位数实现mid操作。算法简单直观，但在大数据量下效率较低，其难点在于对STL容器和算法的熟练运用。
3. **Zip Tree**：通过节点的插入、删除和合并操作来维护树的平衡，进而实现动态维护中位数。难点在于理解和实现Zip Tree的各种操作，以及如何通过这些操作来维护中位数。
4. **对顶堆（priority_queue）**：使用一个大根堆和一个小根堆，大根堆维护较小的一半数，小根堆维护较大的一半数，通过调整两个堆的元素数量来保证大根堆的堆顶为中位数。难点在于如何根据插入元素的大小，合理地调整两个堆的元素，以确保中位数的正确性。
5. **暴力排序（vector）**：每次插入元素后重新排序，然后根据序列长度输出中位数。这种方法简单直接，但时间复杂度较高，大数据量下效率极低，难点在于优化暴力算法以适应大数据量。
6. **树状数组 + 二分**：先对数据离散化，然后用树状数组维护数字个数，通过二分搜索树状数组来查找中位数。难点在于离散化的处理以及树状数组的操作和二分搜索的结合。
7. **二分链表插入排序思想**：利用二分查找确定插入位置，然后在vector中插入元素，通过维护有序性来输出中位数。其难点在于如何高效地实现二分查找和插入操作，以及理解这种类似排序思想在本题中的应用。
8. **手写堆**：通过手写大根堆和小根堆，根据插入元素和堆的状态进行调整，以维护中位数。难点在于堆的各种操作的实现，如建堆、插入、删除等，以及如何根据题目要求合理调整两个堆。
9. **Splay**：利用Splay树的插入操作添加元素，通过查询树中特定排名的元素来获取中位数。难点在于Splay树的实现和操作，以及如何将中位数的查询转化为Splay树的排名查询。
10. **multiset**：使用multiset自动排序的特性，通过迭代器指向中位数位置，根据插入元素与当前中位数的比较结果移动迭代器来维护中位数。难点在于对multiset特性的理解和迭代器的正确操作。
11. **普通平衡树**：保留平衡树的插入、排序和查询第x大的数的操作，将中位数的概念转化为第(n + 1)/2个大的数进行查询。难点在于平衡树的实现和对中位数概念的转化。
12. **权值线段树**：先读入所有数和操作，离散化后用权值线段树维护，根据线段树的查询操作获取中位数。难点在于权值线段树的构建、维护和查询操作的实现，以及离散化的处理。
13. **01 - Trie**：将数插入01 - Trie树，通过DFS还原有序序列，利用树的size属性查询中位数。难点在于01 - Trie树的理解和实现，以及如何利用其特性实现中位数的查询。
14. **链表**：离线处理，将所有要加的数加入链表后排序，把添加操作转化为倒序删除操作，通过移动指针扫描求出中位数。难点在于链表的操作和指针的移动逻辑，以及如何将添加操作转化为删除操作。
15. **暴力（数组模拟）**：先对数组排序，添加元素时通过二分查找位置并移动元素，根据数组长度输出中位数。这种方法简单但效率低，难点在于优化暴力操作以提高效率。
16. **pbds红黑树**：利用pbds库中的红黑树，通过插入操作添加元素，根据树的序统计功能查询中位数。难点在于对pbds库的了解和红黑树序统计功能的使用。
17. **替罪羊树**：利用替罪羊树的插入和查询排名操作来维护中位数，在树不平衡时进行重构。难点在于替罪羊树的实现和不平衡时的重构操作。
18. **非旋Treap**：通过非旋Treap的插入、分割、合并等操作维护数列的有序性，进而查询中位数。难点在于非旋Treap的各种操作的实现和理解。

综合考虑思路清晰度、代码可读性、优化程度等因素，对各题解评分如下：
1. **作者：陈曦**：4星。关键亮点是使用fhq treap解决问题，代码实现较为完整，对fhq treap的操作有一定解释。
```cpp
// 插入新节点
inline int newnode(int x)
{
    ++sum_p;size[sum_p]=1;
    val[sum_p]=x;rnd[sum_p]=rand();
    return sum_p; 
}
// 拆分树
inline void split(int &x,int &y,int k,int pos)
{
    if(!pos)x=y=0;
    else
    {
        if(val[pos]<=k)
        {x=pos;split(son[pos][2],y,k,son[pos][2]);}
        else
        {y=pos;split(x,son[pos][1],k,son[pos][1]);}
        update(pos);
    }
}
// 合并树
inline int merge(int x,int y)
{
    if(x==0||y==0) return x+y;
    if(rnd[x]<rnd[y])
    {
        son[x][2]=merge(son[x][2],y);
        update(x);return x;
    }
    else
    {
        son[y][1]=merge(x,son[y][1]);
        update(y);return y;
    }
}
// 查找第k小的数
inline int find(int pos,int rank)
{
    while(1)
    {
        if(size[son[pos][1]]>=rank)
        {
            pos=son[pos][1];
        }
        else 
        if(size[son[pos][1]]+1==rank)return pos;
        else
        {
            rank-=size[son[pos][1]]+1;
            pos=son[pos][2];
        }
    }
}
```
核心实现思想：通过newnode创建新节点，split按权值拆分树，merge按随机值合并树，find查找第k小的数，从而实现动态维护中位数。

2. **作者：Anguei**：4星。关键亮点是使用STL的vector和lower_bound简单直观地解决问题，代码简洁，对核心代码有详细解释。
```cpp
std::vector<int> v;
// 查询中位数
int query() { 
    return v[v.size() / 2 - (v.size() & 1 ^ 1)];
}
// 添加元素
void add(int x) { 
    v.insert(std::lower_bound(v.begin(), v.end(), x), x);
}
```
核心实现思想：add函数利用lower_bound找到插入位置并插入元素，query函数根据vector的大小通过位运算返回中位数。

3. **作者：这有一只匿**：4星。关键亮点是使用STL自带的优先队列实现对顶堆，思路清晰，代码逻辑明确。
```cpp
priority_queue<int,vector<int>,greater<int> >que1;
priority_queue<int>que2;
// 添加元素
void insert(int x)
{
    int l=que2.top();
    if(x>l)que1.push(x);
    else que2.push(x);
    // 调整堆的元素数量
    while(que2.size()<(n+1)/2)
    {
        int x=que1.top();
        que1.pop();
        que2.push(x);
    }
    while(que2.size()>(n+1)/2)
    {
        int x=que2.top();
        que2.pop();
        que1.push(x);    
    }
}
```
核心实现思想：insert函数根据元素与大根堆堆顶的比较结果将元素插入相应堆，并通过while循环调整两个堆的元素数量，使大根堆堆顶为中位数。

最优的关键思路或技巧：使用对顶堆或平衡树来动态维护中位数。对顶堆通过合理分配元素到两个堆中，保持堆的平衡来维护中位数；平衡树则通过其插入和查询特定排名元素的操作来实现中位数的动态维护。这两种方法在动态数据处理中效率较高，能够满足题目要求。

可拓展之处：同类型题可考察动态维护第k大（小）值、区间中位数等问题。类似算法套路包括利用数据结构（如堆、平衡树、线段树等）的特性来维护数据的某种顺序或统计信息，通过合理的插入、删除和查询操作来解决问题。

推荐题目：
1. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)：同样是动态维护中位数的问题，可进一步练习对顶堆或平衡树的应用。
2. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)：考察平衡树的基本操作，有助于深入理解平衡树的原理和实现。
3. [P2665 路径统计](https://www.luogu.com.cn/problem/P2665)：涉及平衡树在更复杂场景下的应用，可锻炼对平衡树的综合运用能力。

个人心得摘录与总结：
 - **作者：Paperback_Writer**：提到使用STL的堆模拟时，数据可能存在缺陷，如初始数据只有一个数时堆创建会出错，但仍通过了题目测试。同时强调要以中位数为基准判定插入新数的堆，不要轻信队友的话。总结为在使用STL实现堆时要注意边界情况，并且在算法实现中要明确判断依据，不能盲目听从他人建议。 

---
处理用时：95.90秒
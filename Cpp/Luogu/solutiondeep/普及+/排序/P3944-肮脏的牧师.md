# 题目信息

# 肮脏的牧师

## 题目背景

@Yumis 出题人在这里哦~


## 题目描述

Yumis最近在玩炉石传说。

在炉石传说中脏牧有一张一费卡片（一费就是使用要消耗1点法力水晶），叫做疯狂药水，这个的效果是将一个敌方场上攻击小于等于2的随从拉到自己的战场内。

还有一张四费卡片叫做暗影狂乱，这个的效果是将一个敌方场上攻击小于等于3的随从拉到自己的战场内。

还有一张一费卡片就是缩小药水，这个的效果是将敌人全场的随从攻击力下降3点。


你PY了炉石的GM所以你有了无数张的这三种卡片，但是GM告诉你缩小药水是这个牌比较不好创建，为了为GM着想你必须在使用**最少的缩小药水**的情况下A爆对手的脸。


现在你的对手场上有n个随从，每个随从的攻击力是ki点。

你的对手有m点血量。


而你现在要做的就是将敌方的场上的随从拉过来自己的场上并攻击对手（每一个随从只能攻击一次，攻击力为你拉过来的时候随从剩余的攻击力），A爆对面的脸（将对面的血打到0点及以下）。


## 说明/提示

样例说明1：

敌方场上有3只随从，敌方有5点血量

我们把3攻随从和2攻随从拉过来花费0个缩小药水和5点耗费（一张疯狂药水一个暗影狂乱（1+4 = 5））伤害足够击杀对方。


样例说明2：

使用16个缩小药水（下面数据后面第一个括号指拉过来的时候伤害为多高 ，第二个括号表示拉过来的时候使用多少的缩小药水）

拿10（1）（3）、20（2）（6）、30（3）（9）、50（2）（16）攻的怪物总共造成8点伤害 刚好A爆！



Easy : 保证 0 < n <= 10  并且不存在用到暗影狂乱和缩小药水的情况    20%


Normal ：保证 0 < n <= 10  并且不存在用到缩小药水的情况           20%


Hard ：保证 0 < n <= 10                                                 30%


Extra：保证0 <= n <= 5000000(6个0)，最大攻击力小于30000                  30%


保证 0 < n <= 5000000     0 < ki <=30000    0<=m<=5000000 (6个0)


## 样例 #1

### 输入

```
3 5
1 2 3 
```

### 输出

```
0 5```

## 样例 #2

### 输入

```
8 8
10 20 30 40 50 60 70 80
```

### 输出

```
16 23```

## 样例 #3

### 输入

```
8 80
10 20 30 40 50 60 70 80
```

### 输出

```
Human Cannot Win Dog```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何在满足最少使用缩小药水的前提下，以最少法力水晶消耗拉取敌方随从并击败敌方展开。思路上多采用贪心策略，结合排序（如桶排、sort 排序）来处理随从攻击力数据。难点在于既要保证缩小药水使用最少，又要使法力水晶消耗最优，同时需处理可能出现的伤害溢出后随从 “归还” 问题。

### 所选的题解
#### 作者：MTF_Lambda_04 (5星)
- **关键亮点**：思路清晰，先对题目操作进行分析，采用 sort 排序结合贪心策略。在输入时就判断是否有获胜可能，减少不必要计算。代码逻辑完整，对伤害溢出后随从 “归还” 处理巧妙，通过两个 for 循环分别处理大于等于 3 和小于 3 攻击力的随从。
- **个人心得**：提到因血量可能扣为负导致错掉 2 个测试点，强调了处理伤害溢出时的细节问题。
```cpp
// 核心代码片段
for(int i=1;i<=n;i++){
    scanf("%d",&a[i]);
    if(a[i]>3){
        fgla+=3;
    }else{
        fgla+=a[i];
    }
}
if(fgla<m){
    printf("Human Cannot Win Dog\n");
}else{
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++){
        a[i]-=3*need;
        if(a[i]<=2){
            number++;
            m-=a[i];
        }else if(a[i]==3){
            if(m<=0){
                break;
            }
            number+=4;
            m-=a[i];
        }else if(a[i]>3){
            if(m<=0){
                break;
            }
            while(a[i]>3){
                number++;
                need++;
                a[i]-=3;
            }
            if(a[i]<=2){
                number++;
                m-=a[i];
            }else if(a[i]==3){
                number+=4;
                m-=a[i];
            }
        }
    }
    if(m<0){
        int k=0;
        k=k-m;
        for(int j=1;j<=n;j++){
            if(a[j]<=k){
                if(a[j]==3){
                    number-=4;
                    k-=3;
                }
            }
        }
        for(int j=1;j<=n;j++){
            if(a[j]<=k){
                if(a[j]<=2){
                    number--;
                    k-=a[j];
                }
            }
        }
    }
    printf("%d %d\n",need,number);
}
```
核心实现思想：先判断初始输入随从攻击力总和是否有获胜可能。排序后，按随从攻击力从小到大处理，根据攻击力决定使用哪种药水拉取随从，若伤害溢出则按攻击力从高到低 “归还” 随从以优化法力水晶消耗。

#### 作者：Yumis (4星)
- **关键亮点**：针对不同难度级别给出思路，对于 Extra 数据范围大的情况，采用桶排序优化，在计算伤害时每次给 i 增加 3 来模拟使用缩小药水效果，逻辑简洁明了，对伤害溢出后随从处理采用三个 while 循环，按攻击力 3、1、2 的顺序 “归还” 随从。
```cpp
// 核心代码片段
for (int i = 1; i+2 <= 30001; i +=3)
{
    ans += to[i];     at1 += to[i];
    ans += to[i+1]*2; at2 += to[i+1];
    ans += to[i+2]*3; at3 += to[i+2];
    snum ++;
    if(ans >= m) break;
}
while(ans >= m+3 && at3) {at3 --; ans -= 3;}
while(ans >= m+1 && at1) {at1 --; ans -= 1;}
while(ans >= m+2 && at2) {at2 --; ans -= 2;}
if(ans >= m) printf("%d %d",snum,at1+at2+at3*4+snum);
else printf("Human Cannot Win Dog");
```
核心实现思想：通过桶排序统计各攻击力随从数量，循环模拟使用缩小药水，累加可造成伤害，当伤害溢出时，按攻击力从高到低 “归还” 随从，最后判断是否能获胜并输出结果。

#### 作者：AirCnt (4星)
- **关键亮点**：贪心思路明确，先拉取攻击力 3 以内随从，不够则用缩小药水扩展可拉取随从攻击力范围，并用桶排序优化枚举随从过程。代码实现简洁高效，通过自定义函数处理随从攻击力并计数，对伤害溢出后随从 “归还” 处理清晰。
```cpp
// 核心代码片段
inline int clac(int x,const int num) {
    x-=cnt*3;
    if(x>3) {
        int pre_x=x,new_cnt;
        x%=3;
        x=x==0?3:x;
        new_cnt=(pre_x-x)/3;
        ans+=new_cnt;
        cnt+=new_cnt;
    }
    used[x]+=num;
    ans+=cost[x]*num;
    return x*num;
}
//...
for(int i=1;i<=maxn&&sum<m;i+=3) {
    if(a[i])
        sum+=clac(i,a[i]);
    if(a[i+1])
        sum+=clac(i+1,a[i+1]);
    if(a[i+2])
        sum+=clac(i+2,a[i+2]);
}
if(sum<m)
    return puts("Human Cannot Win Dog"),0;
while(sum-3>=m&&used[3])
    --used[3],ans-=4,sum-=3;
while(sum-1>=m&&used[1])
    --used[1],--ans,--sum;
while(sum-2>=m&&used[2])
    --used[2],--ans,sum-=2;
printf("%d %d",cnt,ans);
```
核心实现思想：自定义函数处理随从攻击力，计算所需缩小药水数量和法力水晶消耗，通过循环枚举随从累加伤害，若伤害溢出，按攻击力从高到低 “归还” 随从以优化法力水晶消耗。

### 最优关键思路或技巧
1. **贪心策略**：优先使用低费药水拉取随从，缩小药水最后使用，且在伤害溢出时，优先 “归还” 高费低性价比（攻击力为 3）的随从，再 “归还” 攻击力为 1 和 2 的随从，以保证法力水晶消耗最少。
2. **排序优化**：对于大数据范围，桶排序利用题目中随从攻击力范围有限（0 < ki <= 30000）的特点，将时间复杂度优化到 O(n)，提高算法效率。

### 可拓展思路
此类题目属于贪心策略结合简单模拟的问题，类似套路可用于资源分配、任务调度等场景。例如在资源分配中，不同资源有不同获取成本和收益，需在满足一定条件下最大化收益或最小化成本。

### 相似知识点洛谷题目
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：通过贪心策略对物品进行分组，以满足一定条件下的最优解。
2. [P1199 [NOIP2010 普及组] 三国游戏](https://www.luogu.com.cn/problem/P1199)：涉及贪心思想结合策略选择，与本题在如何选择最优方案上有相似之处。
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：利用贪心算法解决排队等待时间最优问题，与本题在优化资源使用上思路类似。 

---
处理用时：59.38秒
# 题目信息

# 绿豆蛙的归宿

## 题目背景

随着新版百度空间的上线，Blog 宠物绿豆蛙完成了它的使命，去寻找它新的归宿。

## 题目描述

给出张 $n$ 个点 $m$ 条边的有向无环图，起点为 $1$，终点为 $n$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。

绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 $k$ 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\frac{1}{k}$ 。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 10^2$。
- 对于 $40\%$ 的数据，保证 $n \leq 10^3$。
- 对于 $60\%$ 的数据，保证 $n \leq 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times n$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^9$，给出的图无重边和自环。

## 样例 #1

### 输入

```
4 4 
1 2 1 
1 3 2 
2 3 3 
3 4 4```

### 输出

```
7.00```

# AI分析结果

### 综合分析与结论
这些题解主要围绕有向无环图（DAG）上的期望路径长度问题，采用期望DP结合拓扑排序或搜索的方法。思路上分为正推和逆推两种，逆推居多，即设状态$f[x]$表示点$x$到终点$n$的期望路径总长，利用$f[n]=0$的边界条件反向递推；正推则设$dp[i]$表示从$1$到$i$的期望，并结合从$1$到$i$的概率$g[i]$进行递推。算法要点在于合理设计状态转移方程，并借助拓扑排序确保转移顺序正确。解决难点在于理解期望DP的概念和实现方式，以及处理概率与期望的关系。

### 所选的题解
- **作者：___new2zy___ (5星)**
    - **关键亮点**：思路清晰，详细阐述期望DP的套路，包括状态设计、转移方式、顺推逆推选择等，并结合本题具体说明，代码注释详细。
    - **个人心得**：提到做题顺序，建议做完本题后可尝试[luogu p1850 换教室]。
    - **核心代码片段**：
```cpp
inline void toposort()//拓扑排序
{
    queue <int> q;
    q.push(n);
    while(!q.empty())
        {
            int x=q.front();
            q.pop();
            for(int i=head[x];i;i=p[i].from)
                {
                    int y=p[i].to;
                    f[y]+=(f[x]+p[i].w)/dg[y];//dp转移 
                    if(!(--in[y]))q.push(y);
                }
        }
}
```
核心思想是通过拓扑排序，从终点$n$开始，按照拓扑序更新每个点到终点的期望路径长度。
- **作者：wangjyqh (4星)**
    - **关键亮点**：给出正推和逆推两种方法，详细列出两种方法的状态转移方程，并对其原理进行简要推导，同时提供两种方法对应的完整代码。
    - **核心代码片段（逆推）**：
```cpp
inline void topsort(){
    queue<int>q;
    dp[n]=0;
    for(int i=1;i<=n;++i)if(!ind[i])q.push(i);
    while(q.size()){
        int x=q.front();
        q.pop();
        for(int i=head[x];i;i=nxt[i]){
            int y=ver[i];
            dp[y]+=(dp[x]+(double)edge[i])/(double)oud[y];
            if(--ind[y]==0)q.push(y);
        }
    }
}
```
核心思想是反向建图后，利用拓扑排序从终点开始逆推每个点到终点的期望路径长度。
- **作者：Khassar (4星)**
    - **关键亮点**：先阐述记忆化搜索思路，后考虑到递归的缺点，给出基于拓扑排序的优化解法，两种方法均提供完整代码，对期望DP的理解和实现过程解释清晰。
    - **核心代码片段（拓扑版）**：
```cpp
signed main()
{
    n=read();m=read();
    Rf(i,1,m) {
        R int u=read(),v=read(),c=read();
        add(u,v,c);d[u]++;in[v]++;
    }
    q[++tl]=1;
    while(hd^tl) {
        R int now=q[++hd];
        for(R int i=head[now];i;i=e[i].next) {
            R int v=e[i].to;
            if(!(--in[v])) q[++tl]=v;
        }
    }
    Tf(I,n,1) {
        R int x=q[I];
        for(R int i=head[x];i;i=e[i].next) {
            R int v=e[i].to;
            f[x]+=(f[v]+e[i].val)/d[x];
        }
    }
    printf("%.2lf",f[1]);
    
    return 0;
}
```
核心思想是先进行拓扑排序确定点的处理顺序，再按照逆推思路计算每个点到终点的期望路径长度。

### 最优关键思路或技巧
1. **状态设计**：根据期望DP特点，将问题直接作为dp状态，如设$f[x]$表示点$x$到终点$n$的期望路径总长，利用终止状态$f[n]=0$进行逆推。
2. **拓扑排序**：利用DAG性质，通过拓扑排序确定状态转移顺序，保证计算的正确性和高效性。
3. **概率处理**：明确每条边被选择的概率与点的出度关系，在状态转移方程中合理体现概率对期望的影响。

### 可拓展之处
同类型题常围绕图上的期望问题，类似算法套路包括根据问题特点设计合适的期望状态，利用图的结构（如DAG的拓扑序、树的父子关系等）进行状态转移。例如在有环图中，可能需要通过列方程组求解期望。

### 推荐题目
1. [P1850 换教室](https://www.luogu.org/problemnew/show/P1850)：一道期望DP毒瘤题，可加深对期望DP的理解和应用。
2. [P3232 [HNOI2013]游走](https://www.luogu.org/problemnew/show/P3232)：若本题图不是DAG，可参考该题列方程组求解期望的思路。
3. [P4550 收集邮票](https://www.luogu.org/problemnew/show/P4550)：同样是期望DP问题，有助于进一步掌握期望DP的技巧。

### 个人心得摘录与总结
1. **___new2zy___**：建议做题顺序，做完本题可尝试[luogu p1850 换教室]，帮助进一步理解期望DP。
2. **skydogli**：分享调试经历，发现直接将边长度加入期望计算错误，需记录进入点的概率，强调概率在期望计算中的重要性。 

---
处理用时：42.62秒
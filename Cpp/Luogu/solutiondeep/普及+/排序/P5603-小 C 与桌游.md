# 题目信息

# 小 C 与桌游

## 题目背景

小 C 是一个热爱桌游的高中生，现在他被一个桌游难住了，快来帮帮他！

## 题目描述

这个桌游的地图可以被抽象成一个 $n$ 个点，$m$ 条边的**有向无环图**（**不保证连通**），小 C 在这个地图上行走，小 C 能走到某个点当且仅当能够到达这个点的所有点都已经被小 C 走到。小 C 会走到每个点恰好 $1$ 次，并且他能走到哪些点与他当前所在的点没有关系（即可以走到与当前所在的点没有连边的点，只要满足之前的条件）。

小 C 每走到一个标号比之前走到的点都大的点，他就会有 $\frac{1}{2}$ 的概率从对手那里拿到 $1$ 块筹码，有 $\frac{1}{2}$ 的概率给对手 $1$ 块筹码，双方初始各有 $1919810$ 个筹码。

小 C 的运气时好时坏，所以他希望你帮他计算出：

- 在最优情况下，即他每次都能从对手那里拿到筹码时，他采取最优的行走方式能得到的筹码数。
- 在最劣情况下，即对手每次都能从他那里拿到筹码时，他采取最优的行走方式会失去的筹码数。



## 说明/提示

**样例解释**

最优情况下的行走方式是 $1-2-3$，最劣情况下的行走方式是 $1-3-2$。

**计分方式**

对于每一个测试点：

- 如果你输出格式错误或者两行都不正确，将会得到 $0$ 分。
- 如果你的输出第一行正确，第二行错误或第二行正确，第一行错误，将会得到这个测试点 $40 \%$ 的分数。
- 否则，你将会得到这个测试点 $100 \%$ 的分数。

**数据范围**

对于 $20\%$ 的数据，$1 \le n, m \le 10$。

对于 $40\%$ 的数据，$1 \le n, m \le 2000$。

对于 $100\%$ 的数据，$1 \le n, m \le 5 \times 10^5$，$1 \le u, v \le n$。


## 样例 #1

### 输入

```
3 2
1 2
1 3```

### 输出

```
3
2```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解都明确该题与拓扑排序相关，需分别求最优和最劣情况下的筹码数。对于最优情况，普遍采用贪心策略，每次选择当前入度为0的编号最小的点，以尽可能多地更新到更大编号的点，增加获得筹码的次数。对于最劣情况，不能简单贪心选择编号最大的点，需考虑编号较小的点可能带来的更优选择。
    - 算法要点：利用拓扑排序框架，结合优先队列、集合等数据结构实现贪心策略。最优情况用小根堆维护入度为0的点，每次取出最小编号；最劣情况部分题解采用两个堆（一个大根堆和一个小根堆）或一个特殊比较规则的堆，或用集合来处理选择点的逻辑。
    - 解决难点：最劣情况贪心策略的设计是难点。常规按编号最大贪心会出错，需考虑编号小的点对后续选择的影响，如先处理编号小于当前最大值的点，再选择编号最大的点，以避免大的点被小的点掩盖，使失去筹码数最少。

    - 结论：各题解在核心思路上一致，但在具体实现和对最劣情况贪心策略的阐述与实现细节上存在差异。

• 所选的题解：
  - 作者：Sweetlemon (5星)
    - 关键亮点：思路清晰全面，不仅详细分析了最优和最劣情况的贪心策略，还对最劣情况贪心失败原因进行深入探讨，并给出动态规划解法及多种优化思路（树状数组优化dp、set单调优化dp），同时对比了不同解法的时间复杂度和实际运行速度。
    - 个人心得：无
    - 重点代码 - 贪心实现核心思想：用小根堆实现最优情况的拓扑排序，每次取堆顶最小编号点；用两个堆实现最劣情况，大根堆取顶作为“买票”选择最大编号点，小根堆利用“票”访问编号小于“最大标号”的点。
```cpp
// 最优情况
while (!q.empty()){
    int nowv=q.top();
    q.pop();
    if (nowv>tx)
        tx=nowv,ans1++;
    for (int ei=fst[nowv];ei;ei=nxt[ei]){
        int v=g[ei];
        ind[v]--;
        (!ind[v])?(q.push(v)):(void());
    }
}
// 最劣情况
while (!q2.empty()){
    int nowv=q2.top();
    q2.pop();
    if (visited[nowv])
        continue;
    visited[nowv]=1;
    (nowv>tx)?(ans2++,tx=nowv):(0);
    for (int ei=fst[nowv];ei;ei=nxt[ei]){
        int v=g[ei];
        ind[v]--;
        (!ind[v])?(q.push(v),q2.push(v)):(void());
    }
    while ((!q.empty()) && (nowv=q.top())<=tx){
        q.pop();
        if (visited[nowv])
            continue;
        visited[nowv]=1;
        for (int ei=fst[nowv];ei;ei=nxt[ei]){
            int v=g[ei];
            ind[v]--;
            (!ind[v])?(q.push(v),q2.push(v)):(void());
        }
    }
}
```
  - 作者：Mubuky (4星)
    - 关键亮点：清晰指出题目与拓扑排序的关系，分别阐述最优和最劣情况的解法。对最劣情况贪心错误原因给出具体反例，并详细说明正确贪心策略的思考过程和实现方式，代码简洁明了。
    - 个人心得：感谢他人指出样图分析中有关ans变量的问题，体现了开放交流和不断完善的态度。
    - 重点代码 - 最劣情况核心实现思想：用大根堆和队列实现最劣情况的拓扑排序，先从大根堆取顶，若大于当前最大值则更新答案，然后将大根堆元素放入队列，依次处理队列元素，更新图的状态和可访问点。
```cpp
// 最劣情况
maxn=0,ans=0;
while(!qless.empty()){
    int x=qless.top();
    if(x>maxn){
        ans++;
    }
    while(!qless.empty()){
        kz.push(qless.top());
        qless.pop();
    }
    while(!kz.empty()){
        int nx=kz.front();
        kz.pop();
        maxn=max(maxn,nx);
        for(int j=0;j<g[nx].size();j++){
            int y=g[nx][j];
            in2[y]--;
            if(in2[y]==0){
                if(y>maxn){
                    qless.push(y);
                }else{
                    kz.push(y);
                }
            }
        }
    }
}
```
  - 作者：EternalEpic (4星)
    - 关键亮点：对拓扑序列中贪心策略的分析详尽，尤其是对第二问错误贪心策略的反例分析清晰，给出的正确解法代码实现逻辑清晰，对读者理解问题和解决思路有较好的引导作用。
    - 个人心得：无
    - 重点代码 - 第二问核心实现思想：通过dfs函数处理当前点及其后续点，根据点的编号与当前最大值的关系，决定将后续点放入栈或继续dfs，以实现最劣情况下的拓扑排序。
```cpp
inline void dfs(int u) {
    for (int i = head[u]; i; i = nxt[i]) {
        deg[ver[i]][1]--;
        if (!deg[ver[i]][1]) {
            if (ver[i] <= max2) dfs(ver[i]);
            else st.push(ver[i]);
        }
    }
}
// 第二问主循环
max2 = 0;
while (h2.size()) {
    int u = h2.top();
    if (u > max2) {
        max2 = u; ++ans2;
    } while (h2.size()) { dfs(h2.top()); h2.pop(); }
    while (st.size()) { h2.push(st.top()); st.pop(); }
}
```

• 最优关键思路或技巧：
    - 数据结构：利用优先队列实现贪心策略，小根堆用于最优情况，大根堆结合小根堆（或特殊比较规则的堆、集合）用于最劣情况。
    - 思维方式：对最劣情况的贪心策略设计，通过分析反例，调整贪心条件，考虑编号小的点对整体答案的影响，实现局部与整体的平衡。

• 拓展思路：
同类型题可考察在有向无环图上基于拓扑排序的各种贪心策略应用，类似算法套路如在满足一定拓扑顺序条件下，根据不同的目标（如最大化/最小化某种收益、代价等）设计贪心规则，并结合合适的数据结构实现。

• 推荐题目：
    - P1983 车站分级：通过拓扑排序确定车站等级关系，与本题在拓扑排序结合贪心思想上有相似之处。
    - P3387 【模板】缩点：先通过强连通分量缩点得到DAG，再在DAG上进行拓扑排序和动态规划，与本题处理DAG图的场景类似。
    - P1973 [NOI2011] 兔兔与蛋蛋游戏：涉及到图的状态转移和拓扑排序，通过分析状态间的先后关系解决问题，与本题思路有相通之处。

• 个人心得摘录与总结：
  - 作者：_agKc_ ：月赛时因不知道拓扑排序且没看清题目只得了6分，后来问教练后觉得简单，强调了掌握方法的重要性。总结为在竞赛中，知识储备和仔细审题是解题的关键，遇到问题及时学习交流能快速提升对题目的理解。 

---
处理用时：68.86秒
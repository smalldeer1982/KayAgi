# 题目信息

# [NOIP 2004 提高组] 合并果子 加强版

## 题目背景

本题除【数据范围与约定】外与 [P1090](https://www.luogu.com.cn/problem/P1090) **完  全  一  致**。

## 题目描述

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $(n - 1)$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 $3$ 堆果子，数目依次为 $1,~2,~9$。可以先将 $1$、$2$ 堆合并，新堆数目为 $3$，耗费体力为 $3$。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$，耗费体力为 $12$。所以多多总共耗费体力为 $3+12=15$。可以证明 $15$ 为最小的体力耗费值。


## 说明/提示

**【数据规模与约定】**

**本题采用多测试点捆绑测试，共有四个子任务**。

- Subtask 1（10 points）：$1 \leq n \leq 8$。
- Subtask 2（20 points）：$1 \leq n \leq 10^3$。
- Subtask 3（30 points）：$1 \leq n \leq 10^5$。
- Subtask 4（40 points）：$1 \leq n \leq 10^7$。

对于全部的测试点，保证 $1 \leq a_i \leq 10^5$。

**【提示】**

- 请注意常数因子对程序效率造成的影响。
- 请使用类型合适的变量来存储本题的结果。
- 本题输入规模较大，请注意数据读入对程序效率造成的影响。



## 样例 #1

### 输入

```
3 
1 2 9 
```

### 输出

```
15
```

# AI分析结果

• 综合分析与结论：
    - 所有题解均基于贪心策略，即每次选取最小的两堆果子合并以达体力耗费最小。因数据规模大，需优化排序和贪心过程，将时间复杂度降至O(n)。
    - 排序优化：利用1≤ai≤10^5特性，多采用桶排，少数提及基数排序。桶排可将排序复杂度优化至接近线性。
    - 贪心过程优化：用两个队列代替优先队列。一个队列存排好序的原数据，另一个存合并结果。因合并结果单调递增，每次从两队列队首取最小值合并，可在O(n)时间内完成贪心过程。
    - 部分题解还强调快读、数据类型选择等优化细节，以提升程序效率。

所选的题解：
  - 作者：Reanap (赞：109)  星级：5星
    - 关键亮点：思路清晰，从贪心本质出发，先分析常规优先队列解法不足，引出桶排和双队列优化思路。代码实现完整且注释详细。
    - 重点代码核心思想：用桶排将果子数量排序后放入q1队列，合并结果放入q2队列，每次从q1和q2队首取较小值合并，更新答案并将新值放入q2。
```cpp
#include <cstdio>
#include <queue>
#define int long long
using namespace std;
queue <int> q1;
queue <int> q2;
int to[100005];
void read(int &x){ 
    int f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
signed main() {
    int n;
    read(n);
    for (int i = 1; i <= n; ++i) {
        int a;
        read(a);
        to[a] ++;
    }
    for (int i = 1; i <= 100000; ++i) {
        while(to[i]) {
            to[i] --;
            q1.push(i);
        }
    }
    int ans = 0;
    for (int i = 1; i < n; ++i) {
        int x, y;
        if((q1.front() < q2.front() &&!q1.empty()) || q2.empty()) {
            x = q1.front();
            q1.pop();
        }
        else {
            x = q2.front();
            q2.pop();
        }
        if((q1.front() < q2.front() &&!q1.empty()) || q2.empty()) {
            y = q1.front();
            q1.pop();
        }
        else {
            y = q2.front();
            q2.pop();
        }
        ans += x + y;
        q2.push(x + y);
    } 
    printf("%lld", ans);
    return 0;
} 
```
  - 作者：HPXXZYY (赞：75)  星级：5星
    - 关键亮点：解题思路循序渐进，先回顾弱化版，分析O(nlogn)操作，针对性提出桶排和双队列优化方案，并对双队列正确性做简要提示。
    - 重点代码核心思想：桶排后将数据放入q1，通过get_first函数从q1和q2队首取最小值，合并后放入q2，累加结果到ans。
```cpp
const int N=1e7+100;
const int M=1e5+100;
long long ans;int n;
int a[N],cnt[M];//桶 
queue<long long> q1,q2;
inline long long get_first(){
    if (q2.empty()||(!q1.empty()&&q1.front()<q2.front()))
        {long long x=q1.front();q1.pop();return x;}
    else{long long x=q2.front();q2.pop();return x;}
}
int main(){
    memset(cnt,0,sizeof(cnt));
    n=read();ans=0ll;//init
    for(int i=1;i<=n;i++)
        cnt[a[i]=read()]++;
    for(int i=1;i<=100000;i++)
        for(int j=1;j<=cnt[i];j++)
            q1.push(i);//O(N)的桶排 
    for(register int i=1;i<n;i++){
        long long x=get_first();
        long long y=get_first();
        ans+=x+y;q2.push(x+y);
    }
    printf("%lld",ans);
    return 0;
}
```
  - 作者：china·xyc (赞：10)  星级：4星
    - 关键亮点：从求Huffman树角度出发，分析排序在原算法中的作用，进而提出桶排优化。对用双队列优化贪心过程的原理阐述清晰。
    - 重点代码核心思想：桶排后将数据入q1，通过find函数从q1和q2队首取最小值，合并后放入q2，计算累加和ans。
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace fastio{
    template<typename tn> void read(tn &a){
        tn x=0,f=1;char c=' ';
        for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
        for(;isdigit(c);c=getchar() ) x=x*10+c-'0';
        a=x*f;
    }
    template<typename tn> void print(tn a){
        if(a<0) putchar('-'),a=-a;
        if(a>9) print(a/10);
        putchar(a%10+'0');
    }
};
using namespace fastio;
#define int long long
const int M=1e5+5;
int b[M],a,n,ans=0;
queue<int> q1,q2;
int find(){
    int x;
    if((q1.front()<q2.front()&&!q1.empty())||q2.empty()){
        x=q1.front();
        q1.pop();
    }
    else {
        x=q2.front();
        q2.pop();
    }
    return x;
}
signed main(){
    read(n);
    for(int i=1;i<=n;i++) read(a),b[a]++;
    for(int i=1;i<M;i++) while(b[i]) b[i]--,q1.push(i);
    for(int i=1;i<n;i++){
        int x=find();
        int y=find();
        q2.push(x+y);
        ans+=x+y;
    }
    printf("%lld\n",ans);
    return 0;
}
```

最优的关键思路或技巧：
    - **利用数据范围特性**：1≤ai≤10^5，采用桶排代替常规排序，将排序复杂度优化至接近线性。
    - **双队列优化贪心**：利用合并结果单调递增性质，用两个队列分别存原数据和合并结果，每次从两队列队首取最小值合并，将贪心过程复杂度降至O(n)。
    - **细节优化**：使用快读减少输入时间，选择合适数据类型避免溢出。

可拓展之处：同类型题常考察在特定数据范围下，对常规贪心算法的优化，类似套路如利用数据特性选择特殊排序算法，或用特定数据结构优化操作。

推荐题目：
    - [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)
    - [P2859 [USACO06DEC]Milk Patterns G](https://www.luogu.com.cn/problem/P2859)
    - [P1199 [NOIP2010 普及组] 三国游戏](https://www.luogu.com.cn/problem/P1199)

个人心得：多数题解强调不开long long会导致结果错误，做题时需注意数据范围，选择合适数据类型。 

---
处理用时：62.74秒
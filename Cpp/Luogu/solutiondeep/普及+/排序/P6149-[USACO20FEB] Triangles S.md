# 题目信息

# [USACO20FEB] Triangles S

## 题目描述

Farmer John 想要给他的奶牛们建造一个三角形牧场。

有 $N$（$3\leq N\leq 10^5$）个栅栏柱子分别位于农场的二维平面上不同的点 $(X_1,Y_1)\ldots (X_N,Y_N)$。他可以选择其中三个点组成三角形牧场，只要三角形有一条边与 $x$ 轴平行，且有另一条边与 $y$ 轴平行。

FJ 可以组成的所有可能的牧场的面积之和等于多少？

## 说明/提示

#### 样例解释：
栅栏木桩 ($0,0$)、($1,0$) 和 ($1,2$) 组成了一个面积为 $1$ 的三角形，($0,0$)、($1,0$) 和 ($0,1$) 组成了一个面积为 $0.5$ 的三角形。所以答案为 $2\times (1+0.5)=3$。

#### 子任务：
- 测试点 $2$ 满足 $N=200$。
- 测试点 $3$-$4$ 满足 $N\leq 5000$。
- 测试点 $5$-$10$ 没有额外限制。

## 样例 #1

### 输入

```
4
0 0
0 1
1 0
1 2```

### 输出

```
3```

# AI分析结果

• 综合分析与结论：这些题解均围绕如何高效计算满足特定条件（一条边与x轴平行，另一条边与y轴平行）的三角形面积之和展开。核心思路是通过枚举直角顶点，利用点的横纵坐标关系，避免 $O(n^3)$ 的暴力枚举。算法要点在于通过排序、前缀和等方式优化计算每个点作为直角顶点时能组成的三角形面积之和。难点主要是如何在较低时间复杂度内准确计算每个点与同横/纵坐标点的距离和。不同题解在实现细节和优化方式上有所差异。

所选的题解：
  - 作者：泥土笨笨 (赞：30)  星级：5星
    - 关键亮点：思路清晰，通过对以某点为直角顶点的情况进行分析，推导出类似前缀和的计算方式。通过4次不同顺序的排序处理直角的四个方向。代码结构完整，变量命名清晰。
    - 重点代码：
```cpp
void work() {
    memset(sumX, 0, sizeof(sumX));
    memset(sumY, 0, sizeof(sumY));
    memset(cntX, 0, sizeof(cntX));
    memset(cntY, 0, sizeof(cntY));
    for (ll i = 0; i < n; ++i) {
        ll x = points[i].x, y = points[i].y;
        sumX[x] = (sumX[x] + abs(y - lastX[x]) * cntX[x]) % MOD;
        cntX[x]++;
        lastX[x] = y;
        sumY[y] = (sumY[y] + abs(x - lastY[y]) * cntY[y]) % MOD;
        cntY[y]++;
        lastY[y] = x;
        ans = (ans + sumX[x] * sumY[y]) % MOD;
    }
}
```
核心实现思想：依次枚举每个点，更新当前点对应横纵坐标位置的和以及点的个数，利用之前点的信息计算当前点的贡献并累加到答案中。
  - 作者：7KByte (赞：8)  星级：4星
    - 关键亮点：方法简洁，先考虑直角顶点在右上角的三角形，通过排序和桶统计计算点的贡献。对于其他方向的三角形，通过将点绕原点旋转90°处理，时间复杂度低。
    - 重点代码：
```cpp
void solve(){
    sort(a+1,a+n+1);
    memset(sum,0,sizeof(sum));
    memset(cnt,0,sizeof(cnt));
    ll now = 0,tot = 0 ;
    rep( i, 1, n ){
        if(a[i].x!= a[i-1].x )now = 0,tot = 0 ;
        ans=(ans + ( a[i].x * cnt[a[i].y + bas] - sum[ a[i].y + bas ] )
            % P * ( a[i].y * tot - now ) % P ) % P;
        tot++;now=(now+a[i].y)%P;
        cnt[a[i].y+bas]++;
        sum[a[i].y+bas]=(a[i].x+sum[a[i].y+bas])%P;
    }
}
```
核心实现思想：对所有点排序后，遍历点，根据当前点与之前同横坐标点的关系更新相关统计量，计算当前点对答案的贡献。
  - 作者：tuxiaobei (赞：7)  星级：4星
    - 关键亮点：详细分析了多种算法的时间复杂度及优化过程。算法3通过排序和递推优化计算每个点到同横/纵坐标点的距离和，时间复杂度为 $O(N \log N)$。
    - 重点代码：
```cpp
for (int i = 1; i <= n;) {
    int l = i;
    int sum = 0;
    for (; a[i].x == a[l].x; i++) sum += a[i].y - a[l].y, sum %= mod;
    int r = i;
    int cnt = r - l;
    for (int i = l; i < r; i++) {
        p[a[i].p] = sum;
        long long dis = a[i + 1].y - a[i].y;
        sum = (sum + ((i - l + 1) * 2 - cnt) * dis) % mod;
        if (sum < 0) sum += mod;
    }
}
```
核心实现思想：对于横坐标相同的一组点，先计算第一个点的距离和，再通过递推利用前一个点的答案计算后续点的距离和。

最优关键思路或技巧：利用排序将点按横/纵坐标分组，通过前缀和或递推的方式高效计算每个点与同横/纵坐标点的距离和，从而避免暴力枚举，降低时间复杂度。同时，通过旋转点或多次不同顺序排序处理直角的不同方向。

可拓展之处：此类问题属于平面几何与算法优化结合的类型，类似套路可用于处理其他具有特定几何形状（如矩形等）且需统计数量或求和的问题，关键在于利用几何形状特点优化计算。

推荐题目：
 - [P3958 奶酪](https://www.luogu.com.cn/problem/P3958)：涉及空间几何关系判断与连通性问题，可锻炼对几何条件的处理和算法优化能力。
 - [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)：结合数论与算法优化，通过寻找规律优化计算，与本题优化思路类似。
 - [P2671 求和](https://www.luogu.com.cn/problem/P2671)：需要利用前缀和等技巧优化计算满足条件的元素和，与本题计算距离和思路有相通之处。

个人心得：
 - Justin0779提到本题细节多，与 [NOIP2022种花](https://www.luogu.com.cn/problem/P8865) 类似，在模拟赛上切题后有感而写题解，强调了对题目细节的把控和类似题目的积累。 

---
处理用时：51.91秒
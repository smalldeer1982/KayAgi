# 题目信息

# 游走

## 题目背景

zbw 在 B 城游走。

## 题目描述

B 城可以看作一个有 $n$ 个点 $m$ 条边的**有向无环图**。**可能存在重边**。

zbw 在 B 城随机游走，他会在所有路径中随机选择一条路径，选择所有路径的概率相等。路径的起点和终点可以相同。

定义一条路径的长度为经过的边数，你需要求出 zbw 走的路径长度的期望，答案对 $998244353$ 取模。

## 说明/提示

样例说明：样例的答案分别为 $\dfrac{2}{5}$，$\dfrac{25}{19}$ 和 $\dfrac{11}{9}$。

| 测试点编号 | $n$ | $m$ | 特殊性质 | 每测试点分数 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1,2$ | $\le 10$ | $\le 10$ | 无 | $2$ |
| $3,4,5$ | $\le 15$ | $\le 100$ | 无 | $2$ |
| $6,7,8$ | $\le 100$ | $\le 10^3$ | 无 | $2$ |
| $9,10$ | $\le 10^3$ | $\le 10^4$ | 无 | $2$ |
| $11,12$ | $\le 10^4$ | $\le 10^5$ | 无 | $5$ |
| $13,14$ | $\le 10^5$ | $\le 2\times10^5$ | 无 | $5$ |
| $15,16$ | $\le 10^5$ | $\le 7\times10^5$ | 无 | $10$ |
| $17$ | $\le 10$ | $=n-1$ | 有向树 | $10$ |
| $18$ | $\le 10^3$ | $=n-1$ | 有向树 | $10$ |
| $19$ | $\le 10^4$ | $=n-1$ | 有向树 | $10$ |
| $20$ | $\le 10^5$ | $=n-1$ | 有向树 | $10$ |

其中，“有向树”的定义是：若把图视为无向图，则为一棵树（如样例 $1,2$）。

保证所有数据均按照某种方式随机，这意味着你可以认为算法执行过程中，你可以放心执行模意义下除法操作而不用担心除以零。

## 样例 #1

### 输入

```
3 2
1 2
3 2```

### 输出

```
199648871```

## 样例 #2

### 输入

```
6 5
1 3
2 3
3 4
4 5
4 6```

### 输出

```
630470119```

## 样例 #3

### 输入

```
5 6
1 2
1 3
4 5
3 4
3 5
2 4```

### 输出

```
887328315```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解都基于期望公式，即路径长度期望等于所有路径长度总和除以路径总数。通过不同方式计算这两个值来求解。
    - 算法要点：大多利用有向无环图（DAG）的特性，如拓扑排序或记忆化搜索。定义状态表示从某点出发或到达某点的路径长度和与路径条数，通过状态转移方程递推计算。
    - 解决难点：关键在于设计合适的状态转移方程，以及处理取模运算防止溢出。同时要注意数据范围，避免爆LL。

• 所选的题解：
  - 作者gyh20 (赞：25)  星级：5星
    - 关键亮点：思路清晰简洁，采用记忆化搜索，定义 \( f_i \) 表示从 \( i \) 开始的路径长度和， \( g_i \) 表示从 \( i \) 开始的路径条数，通过简洁的状态转移方程计算，代码实现简洁明了。
    - 个人心得：无
    - 核心代码片段：
```cpp
void DP(int now){
    if(g[now])return ;
    g[now]=1;
    for(int i=h[now];i;i=e[i].next){
        int y=e[i].to;
        DP(y);
        (g[now]+=g[y])%=mod;
        (f[now]+=f[y]+g[y])%=mod;
    }
}
```
核心实现思想：记忆化搜索，若 \( g[now] \) 已计算过则直接返回，否则初始化 \( g[now] = 1 \) ，遍历 \( now \) 的邻接点 \( y \) ，递归计算 \( y \) 的值，并更新 \( g[now] \) 和 \( f[now] \) 。
  - 作者zsaskk (赞：11)  星级：4星
    - 关键亮点：使用拓扑排序，定义 \( num[x] \), \( f[x] \) 分别为以 \( x \) 为结尾的路径的数量和长度和，按照拓扑序更新状态，复杂度为 \( O(n + m) \) ，代码结构清晰。
    - 个人心得：无
    - 核心代码片段：
```cpp
inline void topo_sort() {
    while(s.size()) {
        int x=s.top();s.pop();
        for(reg int i=h[x];i;i=edg[i].next) {
            int y=edg[i].y;
            --indeg[y],num[y]=(num[x]+num[y])%p,f[y]=(f[y]+f[x]+num[x])%p;
            if(!indeg[y]) s.push(y);
        }
    }
    for(reg int i=1;i<=n;++i) ans1=(f[i]+ans1)%p,ans2=(ans2+num[i])%p;
}
```
核心实现思想：从栈中取出拓扑序的点 \( x \) ，遍历其邻接点 \( y \) ，更新 \( y \) 的路径数量 \( num[y] \) 和路径长度和 \( f[y] \) ，最后累加所有点的 \( num \) 和 \( f \) 。
  - 作者Hexarhy (赞：4)  星级：4星
    - 关键亮点：同样基于拓扑排序进行dp，清晰阐述了状态转移方程的推导过程，对边界值处理清晰，代码规范。
    - 个人心得：注意开`long long`。
    - 核心代码片段：
```cpp
void topo_sort(void) {
    queue<int> q;
    for(int i=1;i<=n;i++)
        if(!indeg[i])
            q.push(i);
    while(!q.empty()) {
        const int u=q.front();
        q.pop();
        if(visit[u])	continue;
        visit[u]=true;
        for(auto v:edge[u]) {
            indeg[v]--;
            if(!indeg[v])	q.push(v);
            f[v]=(f[v]+f[u]+g[u])%MOD;
            g[v]=(g[v]+g[u])%MOD;
        }
    }
}
```
核心实现思想：利用队列进行拓扑排序，取出队首元素 \( u \) ，遍历其邻接点 \( v \) ，更新 \( v \) 的入度，若入度为0则加入队列，同时更新 \( v \) 的路径长度和 \( f[v] \) 与路径条数 \( g[v] \) 。

• 最优关键思路或技巧：利用DAG的拓扑性质，通过拓扑排序或记忆化搜索，定义合适的状态表示路径长度和与路径条数，依据状态转移方程递推求解，最后利用费马小定理求逆元处理取模运算。

• 可拓展之处：同类型题常基于图的结构，利用拓扑排序或记忆化搜索解决期望、计数等问题。类似算法套路如在DAG上进行动态规划，解决与路径、状态转移相关的问题。

• 推荐洛谷题目：
  - P1983 车站分级：考察拓扑排序的应用。
  - P3387 【模板】缩点：涉及有向图的缩点及基于缩点后的拓扑排序等操作。
  - P4017 最大食物链计数：同样在DAG上进行计数问题求解，可类比本题思路。

• 个人心得摘录与总结：
    - 作者wangjinbo：强调本题要全部开LL且每次运算都取模，否则易爆LL。总结了处理大数据范围时防止数据溢出的关键要点。
    - 作者Hexarhy：提醒注意开`long long`，这是处理本题大数据范围时避免错误的重要注意点。
    - 作者TYxxj：指出逆元在998244353是质数的情况下，直接用快速幂求 \( a^{p - 2} \) 即可，无需线性求逆元，优化了逆元求解方式。 

---
处理用时：50.25秒
# 题目信息

# [SBCOI2020] 时光的流逝

## 题目背景

时间一分一秒的过着，伴随着雪一同消融在了这个冬天，  
或许，要是时光能停留在这一刻，该有多好啊。  
......    
“这是...我在这个小镇的最后一个冬天了吧。”  
“嗯，你可不能这辈子都呆在这个小镇吧。外面的世界很大呢，很大很大...”  
“唔...外面的世界...突然有点期待呢！”  
“总有一天，你会走得很远很远。以后你可不要忘记这个小镇那。”  
“不会的，至少...这里曾经是我最快乐的一段回忆呢！你也一定不要忘记我呀。”   
“你看，这雪花。传说，每当世界上有一份思念，便会化成一片雪花在这里飘落。”   
“那...以后你可一定要找到我的那片雪花啊......”  
![](https://cdn.luogu.com.cn/upload/image_hosting/orzntcy6.png)    
“嗯，不如我们一起在这个冬天创造最后一段回忆吧。”  
“好呀，我们玩个游戏吧......”  

## 题目描述

这个游戏是在一个有向图（不保证无环）上进行的。每轮游戏开始前，她们先在图上选定一个起点和一个终点，并在起点处放上一枚棋子。

然后两人轮流移动棋子，每次可以将棋子按照有向图的方向移动至相邻的点。

如果谁先将棋子移动至终点，那么谁就胜利了。同样，如果谁无法移动了，那么谁就失败了。

两人轮流操作，请问，他们是否有必胜策略呢？  

答案为一个整数 `0` 或 `1` 或 `-1`，其中 `1` 表示（先手）有必胜策略，`-1` 表示后手有必胜策略，`0` 表示两人均无必胜策略。

## 说明/提示

#### 样例解释 $#1$

![](https://cdn.luogu.com.cn/upload/image_hosting/k7q0qjrb.png)

为描述题意，假设两人为 A（先手）和 B

如图，A 先走，走到 $2$，B 走到 $3$，接下去 A 可以选择走到 $4$ 或 $6$，若走到 $4$，接下去 B 可以走到终点，故不可取。若选择走到 $6$，那么 B 只能走到 $7$，A 可以走到终点。所以 A 有必胜策略。

#### 样例解释 $#2$

![](https://cdn.luogu.com.cn/upload/image_hosting/9yjnyye3.png)

如图，起点为 $1$，终点为 $5$ 时， A 和 B 会沿着 $1-2-3-1$ 的顺序轮流走。因为如果谁先走到 $4$，那么下一个人就可以走到终点。故谁都没有必胜策略。

起点为 $4$，终点为 $3$ 时，A 先走到 $5$，B 无路可走，故 B 失败。

#### 数据范围

对于 $10\%$ 的数据，保证图是一条链。

对于 $50\%$ 的数据，$1\leq n\leq 10^3$，$1\leq m\leq 2\times10^3$，$1\leq q\leq 10$。

对于 $70\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 2\times10^5$，$1\leq q\leq 10$。

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 5\times10^5$，$1\leq q\leq 500$。

## 样例 #1

### 输入

```
7 7 1
1 2
2 3
3 4
4 5
3 6
7 5
6 7
1 5```

### 输出

```
1```

## 样例 #2

### 输入

```
5 5 2
1 2
2 3
3 1
3 4
4 5
1 5
4 3```

### 输出

```
0
1```

# AI分析结果

• 综合分析与结论：这是一道图上博弈论问题，关键在于通过标记必胜点和必败点来确定策略。各题解思路相近，均利用反向建图和拓扑排序的方式，从终点和出度为0的点（必败点）出发，依据博弈规则推导其他点的状态。主要难点在于处理有环图，通过避免重复访问已确定状态的点来解决。各题解在思路清晰度、代码可读性和优化程度上有所差异。

所选的题解：
  - 作者：犇犇犇犇 (赞：27)，星级：5星
    - 关键亮点：思路清晰，先按数据范围分类讨论，从简单链的情况入手，逐步深入到复杂图。详细解释了博弈论中必胜点和必败点的标记规则，并通过图示辅助理解。对100%数据的解法给出了详细的时间复杂度分析。
    - 个人心得：无
    - 重点代码核心实现思想：通过反向建边，用数组记录入度和点的状态，利用队列实现拓扑排序，在遍历过程中根据点的状态更新其邻接点的状态。
```cpp
// 100%数据代码核心片段
while(Q--)
{
    int x,y;
    while(!q.empty()) q.pop();
    x=read();y=read();
    memset(f,0,sizeof(f)); 
    memset(d,0,sizeof(d));
    memset(vic,0,sizeof(vic)); 
    for(int i=1;i<=n;i++)
    {
        d[i]=p[i];
        if(p[i]==0) 
            q.push(i); 
    } 
    q.push(y); 
    vic[y]=1; 
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        if(f[u]==1) 
            continue; 
        if(vic[x]!=0)
            break; 
        del(u); 
        if(vic[u]==1)  
        {
            for(int i=head[u];i;i=e[i].nxt) 
            {
                int v=e[i].v;
                if(vic[v]==0)
                {
                    vic[v]=-1;
                    del(v); 
                }
            }    
        }
        else if(out[u]==0)
        {
            vic[u]=1; 
        }
        else 
        {
            vic[u]=1; 
            for(int i=head[u];i;i=e[i].nxt) 
            {
                int v=e[i].v;
                if(vic[v]==0)
                {
                    vic[v]=-1;
                    del(v); 
                }
            }        
        }        
    }
    cout<<-vic[x]<<endl; 
}
```
  - 作者：duyi (赞：25)，星级：5星
    - 关键亮点：先分析DAG图的情况，再针对有环图详细阐述与无环图的区别及处理方式，逻辑连贯。代码简洁明了，注释详细，对每个步骤的操作解释清晰。
    - 个人心得：无
    - 重点代码核心实现思想：反向建边后，初始化队列，将终点和入度为0的点加入队列并标记为必败。在拓扑排序过程中，根据当前点的状态更新邻接点的状态，同时处理环的情况。
```cpp
// 核心代码片段
for(int tq=1;tq<=q;++tq){
    cin>>st>>ed;
    queue<int>que;
    for(int i=1;i<=n;++i){
        cur_deg[i]=in_degree[i];
        if(!cur_deg[i] || i==ed)
            f[i]=-1,que.push(i);
        else
            f[i]=0;
    }
    while(!que.empty()){
        int u=que.front(); que.pop();
        for(int i=head[u];i;i=edge[i].nxt){
            int v=edge[i].to;
            if(f[v]!=0)continue;
            cur_deg[v]--;
            if(f[u]==-1){
                f[v]=1;
                que.push(v);
            }
            else if(!cur_deg[v]){
                if(f[v]!=1)
                    f[v]=-1;
                que.push(v);
            }
        }
    }
    cout<<f[st]<<endl;
}
```
  - 作者：Mine_King (赞：12)，星级：4星
    - 关键亮点：从博弈论基本概念出发，清晰阐述判断点的必胜和必败状态的逻辑。代码结构清晰，变量命名直观，易于理解。
    - 个人心得：无
    - 重点代码核心实现思想：反向建图，初始化时将终点和反图中入度为0的点标记为必败并入队，然后在队列循环中根据当前点的状态更新邻接点的状态。
```cpp
// 核心代码片段
while(Q--)
{
    int s,t;
    scanf("%d%d",&s,&t);
    memset(f,0,sizeof(f));
    memcpy(in,kk,sizeof(kk));
    for(int i=1;i<=n;i++)
        if(!in[i]||i==t) q.push(i),f[i]=-1;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=g.hd[x];i;i=g.nxt[i])
            if(!f[g.to[i]])
            {
                if(f[x]==1)
                {
                    in[g.to[i]]--;
                    if(!in[g.to[i]]) q.push(g.to[i]),f[g.to[i]]=-1;
                }
                else q.push(g.to[i]),f[g.to[i]]=1;
            }
    }
    printf("%d\n",f[s]);
}
```

最优关键思路或技巧：
 - **反向建图与拓扑排序结合**：通过反向建图，能从已知的必败点（终点和出度为0的点）方便地推导其他点的状态。利用拓扑排序的思想，按顺序处理点，保证在处理某个点时，其依赖的点（反向边指向的点）状态已确定。
 - **状态标记与更新**：用数组标记每个点的状态（必胜、必败或未确定），在拓扑排序过程中，根据当前点状态和邻接关系更新其他点状态，同时注意避免重复访问已确定状态的点。

可拓展思路：此类题目可拓展到更复杂的图结构或博弈规则。例如，改变胜利或失败的条件，或者在图上增加权值等额外信息。类似算法套路常用于解决各种有向图上的状态推导问题，关键在于确定初始状态和状态转移规则。

推荐题目：
 - [P2324 [SCOI2005] 骑士精神](https://www.luogu.com.cn/problem/P2324)：涉及棋盘上的博弈，通过搜索和状态压缩解决问题，与本题类似之处在于都需要确定状态和状态转移方式。
 - [P1290 [USACO2.3] 修理牛棚 Barn Repair](https://www.luogu.com.cn/problem/P1290)：表面是贪心问题，实际可通过类似拓扑排序的思想确定最优解，与本题在利用特定顺序处理元素以解决问题上思路相似。
 - [P2036 [COCI2008-2009#2] PERKET](https://www.luogu.com.cn/problem/P2036)：通过枚举和状态判断解决问题，与本题确定点的状态从而得出结果的思路有一定相似性。 

---
处理用时：65.64秒
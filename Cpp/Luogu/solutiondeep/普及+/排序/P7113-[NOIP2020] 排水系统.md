# 题目信息

# [NOIP2020] 排水系统

## 题目描述

对于一个城市来说，排水系统是极其重要的一个部分。

有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 $n$ 个排水结点（它们从 $1 \sim n$ 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。

排水系统的结点中有 $m$ 个污水接收口，它们的编号分别为 $1, 2, \ldots , m$，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。

现在各个污水接收口分别都接收了 $1$ 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。

现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。

## 说明/提示

**【样例 #1 解释】**

$1$ 号结点是接收口，$4, 5$ 号结点没有排出管道，因此是最终排水口。  
$1$ 吨污水流入 $1$ 号结点后，均等地流向 $2, 3, 5$ 号结点，三个结点各流入 $\frac{1}{3}$ 吨污水。  
$2$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
$3$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
最终，$4$ 号结点排出 $\frac{1}{6} + \frac{1}{6} = \frac{1}{3}$ 吨污水，$5$ 号结点排出 $\frac{1}{3} + \frac{1}{6} + \frac{1}{6} = \frac{2}{3}$ 吨污水。

**【数据范围】**

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 3$ | $10$ | $1$ |
| $4 \sim 6$ | ${10}^3$ | $1$ |
| $7 \sim 8$ | ${10}^5$ | $1$ |
| $9 \sim 10$ | ${10}^5$ | $10$ |

对于全部的测试点，保证 $1 \le n \le {10}^5$，$1 \le m \le 10$，$0 \le d_i \le 5$。

数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 $10$ 个中间排水结点（即接收口和最终排水口不算在内）。

## 样例 #1

### 输入

```
5 1
3 2 3 5
2 4 5
2 5 4
0
0
```

### 输出

```
1 3
2 3
```

## 样例 #2

### 输入

```
见附件中的 water/water2.in```

### 输出

```
见附件中的 water/water2.ans```

## 样例 #3

### 输入

```
见附件中的 water/water3.in```

### 输出

```
见附件中的 water/water3.ans```

# AI分析结果

### 综合分析与结论
这些题解都围绕排水系统问题，利用图的拓扑排序来模拟污水流动。由于结果需以分数形式输出且数据范围大，处理分数运算和数据类型选择是关键。多数题解用`__int128`解决数据溢出，少数用高精度或特殊底数存储方式。

### 所选的题解
#### 作者：听取MLE声一片 (5星)
- **关键亮点**：思路清晰，先阐述拓扑排序主要思路，再详细说明分数处理的通分思想及实现细节，代码注释丰富，可读性强。
- **个人心得**：强调去掉高精度后是好的拓扑排序题，提醒注意`vector`存边时访问排水节点`size()`可能炸，以及审题要注意前`m`个点是入水口。
```cpp
// 拓扑排序函数
void tp(){
    for(int i=1;i<=n;i++)//所有入度为0的点入队（1-m）
        if(!in[i]){
            book[i]=1;
            q.push(i);
            xx[i]=1,yy[i]=1;
        }
    while(!q.empty()){
        int p=q.front();
        q.pop();
        if(out[p])
            continue;
        for(int i=0;i<a[p].size();i++){
            add(a[p][i],xx[p],yy[p]*(1ll*a[p].size()));
            if(book[a[p][i]])
                continue;
            in[a[p][i]]--;
            if(in[a[p][i]]==0){
                book[a[p][i]]=1;
                q.push(a[p][i]);
            }
        }
    }
    return;
}
// 通分函数
void add(int u,ll x,ll y){
    if(y==0)
        return;
    if(yy[u]==0){
        xx[u]=x;
        yy[u]=y;
        return;
    }
    ll p1=xx[u]*y+yy[u]*x;
    ll p2=yy[u]*y;
    ll p3=gcd(p1,p2);
    xx[u]=p1/p3;
    yy[u]=p2/p3;
    return;
}
```
#### 作者：lcyxds (4星)
- **关键亮点**：提出用两个`unsigned long long`开高精度，以$60^{11}$为底存储流量，通过预处理因数简化输出时的处理，方法独特。
```cpp
// 分数加法
Gj operator + (Gj a, Gj b){
    Gj res;
    res._num[0] = a._num[0]+b._num[0];
    res._num[1] = a._num[1]+b._num[1]+res._num[0]/_BASE;
    res._num[0]%=_BASE;
    return res;
};
// 分数除以整数
Gj operator / (Gj a, ull b) {
    Gj res;
    res._num[0] = a._num[1]%b*_BASE+a._num[0];
    res._num[1] = a._num[1]/b;
    res._num[0]/=b;
    return res;
}
// 输出处理
void DisplayDiv(Gj a) {
    int two = 22;
    int three = 11;
    int five = 11;
    while (two &&!(a%2)) {
        two--;
        a = a/2;
    }
    while (three &&!(a%3)) {
        three--;
        a = a/3;
    }
    while (five &&!(a%5)) {
        five--;
        a = a/5;
    }
    Display(a);
    putchar(' ');
    if (two==22 && three==11 && five==11) {
        Display(Gj(true));
    }
    else printf("%llu", _power[two][three][five]);
    putchar('\n');
}
```
#### 作者：hensier (4星)
- **关键亮点**：不仅给出基于拓扑排序的广度优先搜索实现，还提供深搜解决版本，从不同角度展示解题方法，对搜索方式的选择有详细分析。
```cpp
// 拓扑排序（BFS）
while(q.size()){
    int u=q.front();
    q.pop();
    for(int i=head[u],v;i;i=e[i].nxt){
        v=e[i].to;
        update(wx[v],wy[v],wx[u],oud[u]*wy[u]);
        ind[v]--; // 将入度减少1
        if(!ind[v])q.push(v);
    }
}
// 深搜（DFS）
void dfs(int u)
{
    for(int i=head[u],v;i;i=e[i].nxt)
    {
        v=e[i].to;
        update(wx[v],wy[v],wx[u],oud[u]*wy[u]);
        ind[v]--;
        if(!ind[v])dfs(v); 
    }
}
```

### 最优关键思路或技巧
- **拓扑排序**：利用拓扑排序保证处理节点时，其上游节点已处理完毕，污水已全部流入，符合污水流动逻辑。
- **分数运算处理**：通过通分、约分实现分数加法和除法运算，保证结果为最简分数。如`add`函数实现分数相加并约分。
- **数据类型选择**：鉴于数据范围大，使用`__int128`可避免高精度运算的复杂性，同时需手动实现输入输出。部分题解采用特殊高精度存储方式，如以特定底数存储流量。

### 可拓展思路
此类题目属于有向无环图（DAG）上的模拟问题，相似套路是利用拓扑排序确定节点处理顺序，结合题目具体规则进行状态转移。类似题目还可能涉及资源分配、任务调度等场景，同样可借助拓扑排序模拟流程。

### 相似知识点洛谷题目
- [P1038 神经网络](https://www.luogu.com.cn/problem/P1038)：经典拓扑排序题目，通过拓扑排序模拟神经网络中数据的传递。
- [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)：利用拓扑排序确定车站等级关系，与本题确定节点顺序类似。
- [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)：同样基于拓扑排序，解决在有向无环图中选择路径的问题，与本题在图上进行操作的思路相似。 

---
处理用时：53.99秒
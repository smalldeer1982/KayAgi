# 题目信息

# 「TOCO Round 1」奇怪的排序

## 题目背景

欢喜不问天，风流不问天，温柔不问天，良辰不问天，良缘不问天。

问你不问天。

## 题目描述

情人节那天 $\color{orange}\texttt{Biadocy}$ 被虐得好惨，尤其是上流的公爵和小孩说什么《和你在一起的每一天，都叫情人节》。于是他找到了一个机会来报复。

现在有 $n$ 对情人编号为 $1\sim n$ 按任意顺序排成一列，$\color{orange}\texttt{Biadocy}$ 对他们执行了下面这段排序的伪代码。

![](https://cdn.luogu.com.cn/upload/image_hosting/yny3xh8d.png)

$\color{orange}\texttt{Biadocy}$ 想知道有多少种初始排列满足按照这段伪代码排序后情人们的编号有序。也许这能让他好受一点。

## 说明/提示

对于前 $10\%$ 的数据，$T=0$。  
对于前 $30\%$ 的数据，$T\leq 10$，$n\leq 7$。  
对于另外 $10\%$ 的数据，$k=0$。  
对于另外 $10\%$ 的数据，$k=100$。  
对于 $100\%$ 的数据，$0\leq T\leq 10^5$，$1\leq n\leq 10^6$，$0\leq k\leq 100$。

## 样例 #1

### 输入

```
3
3 1
10 2
1 0```

### 输出

```
3
25200
1```

## 样例 #2

### 输入

```
5
502520 0
502520 1
502520 2
502520 3
502520 4```

### 输出

```
1
218102685
429650441
770595802
584122358```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均围绕对限制递归层数为 \(k\) 的归并排序的分析。算法要点在于明确归并排序在第 \(k - 1\) 层将原序列分成 \(2^k\) 个子序列，计算这些子序列本身有序的概率，并结合全排列数 \(n!\) 得出满足排序后有序的初始排列数。解决难点主要在于处理不同 \(k\) 值的特殊情况（如 \(k = 0\)，\(k > 20\) 或 \(n \leq 2^k\) 时），以及在取模运算下通过快速幂求逆元来处理分数乘法。

从质量上看，_saltFish_、donotctjuntilAFO、HPXXZYY、Dream__Sky、Transfixion_、COsm0s的题解思路较为清晰，代码实现也基本正确，但在优化程度和代码可读性上存在差异。laol的题解虽然给出了暴力解法及优化思路，但整体表述稍显繁琐，且暴力解法未通过全部测试数据。Neil_Qian提出递推求解的思路，但未给出代码，实现细节不够明确。

### 所选的题解
1. **_saltFish_（5星）**
    - **关键亮点**：思路清晰，详细阐述了归并排序层数与子序列的关系，对特殊情况的分析和特判全面，代码简洁明了，变量命名规范。
    - **重点代码**：
```cpp
ll qpow(ll a,ll b){
    ll s=1;
    while(b){
        if(b&1) s=s*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return s;
}
int main(){
    cin>>t;
    for(int i=2;i<=1e6;i++) jc[i]=jc[i-1]*i%mod;
    while(t--){
        cin>>n>>k;
        if(k>20||(1<<k)>=n)
            cout<<jc[n]<<'\n';
        else if(k==0)
            cout<<1<<'\n';
        else
            cout<<1ll*qpow(qpow(jc[n/(1<<k)],mod-2)/*逆元*/,1<<k)
            *qpow(qpow(n/(1<<k)+1,mod-2),n%(1<<k))%mod/*此前为求概率（所有第k层子集有序的总概率）*/
            *jc[n]/*全排列数*/%mod<<'\n'; 
    }
}
```
    - **核心实现思想**：通过快速幂函数 `qpow` 计算逆元，在 `main` 函数中，先预处理阶乘数组 `jc`，然后针对不同的 \(k\) 值进行特判，对于一般情况，通过计算第 \(k - 1\) 层子序列有序的概率与全排列数的乘积得到结果。
2. **HPXXZYY（4星）**
    - **关键亮点**：以样例为辅助，清晰地解释了算法思路，逻辑连贯，代码结构合理，函数命名直观。
    - **重点代码**：
```cpp
inline int ksm(int a,int b){
    register int ret=1;
    while (b){
        if (b&1) ret=1ll*ret*a%mod;
        a=1ll*a*a%mod;b>>=1;
    }
    return ret;
}
inline void init_fac_inv(int n){
    fac[0]=1;
    for(int i=1;i<=n;i++)
        fac[i]=1ll*i*fac[i-1]%mod;
    inv[n]=ksm(fac[n],mod-2);
    for(int i=n;i;i--)
        inv[i-1]=1ll*i*inv[i]%mod;
}
int main(){
    init_fac_inv(1e6);
    for(int T=1,G=read();T<=G;T++){
        n=read();k=read();ans=1;
        if (k>20||(1<<k)>=n){
            printf("%d\n",fac[n]);
            continue;
        }
        else if (k==0){
            printf("1\n");
            continue;
        }
        ans=1ll*ksm(inv[n/(1<<k)],(1<<k))*ksm(ksm(n/(1<<k)+1,mod-2),(n%(1<<k)))%mod;
        printf("%lld\n",1ll*ans*fac[n]%mod);
    }
    return 0;
}
```
    - **核心实现思想**：`ksm` 函数实现快速幂运算，`init_fac_inv` 函数预处理阶乘及其逆元。在 `main` 函数中，根据 \(k\) 的不同取值进行特判，对于一般情况，计算子序列有序概率与全排列数的乘积得到答案。
3. **Dream__Sky（4星）**
    - **关键亮点**：对归并排序性质的分析详细，通过手玩样例得出块长的规律，代码实现简洁，注释详细。
    - **重点代码**：
```cpp
int qpow(int base,int temp)
{
    int ans=1;
    for(;temp;base=base*base%MOD,temp>>=1)
        if(temp&1) ans=ans*base%MOD;
    return ans;
}//快速幂
void init()
{
    fac[0]=inv[0]=1;
    for(int i=1;i<=N;i++) fac[i]=fac[i-1]*i%MOD;
    inv[N]=qpow(fac[N],MOD-2);
    for(int i=N-1;i>=1;i--) inv[i]=inv[i+1]*(i+1)%MOD;
}//预处理阶乘逆元
int work()
{
    cin>>n>>k;
    if(log2(n)<k) return fac[n];//特判
    return qpow(inv[n/(1<<k)],(1<<k)-n%(1<<k))%MOD*qpow(inv[n/(1<<k)+1],n%(1<<k))%MOD*fac[n]%MOD;//计算公式
}
signed main()
{
    cin>>T;
    init();
    for(int i=1;i<=T;i++) 
        cout<<work()<<"\n";//多测
    return 0;
}
```
    - **核心实现思想**：`qpow` 函数实现快速幂，`init` 函数预处理阶乘和逆元。`work` 函数根据 \(k\) 和 \(n\) 的关系进行特判，对于一般情况，利用快速幂计算子序列有序概率与全排列数的乘积。

### 最优关键思路或技巧
1. **利用归并排序性质**：明确归并排序在特定递归层数下子序列的划分规律，即子序列长度只有 \(\lfloor \frac{n}{2^k} \rfloor\) 和 \(\lfloor \frac{n}{2^k} \rfloor + 1\) 两种，且数量可求。
2. **特殊情况特判**：针对 \(k = 0\)，\(k > 20\)（此时 \(2^k > n\)）或 \(n \leq 2^k\) 等特殊情况进行特判，简化计算。
3. **快速幂求逆元**：在取模运算下，通过快速幂算法高效计算阶乘的逆元，以处理分数乘法。

### 可拓展之处
同类型题或类似算法套路：此类题目通常围绕对特定排序算法的变形或限制进行考察。可以拓展到对其他排序算法（如快速排序、堆排序）的变形分析，或者对归并排序在不同条件限制下（如不同的划分方式、不同的合并规则）的研究。通过分析排序过程中元素的移动和分组规律，结合组合数学知识求解满足特定条件的排列数。

### 相似知识点洛谷题目
1. **P1970 花匠**：涉及对序列单调性的分析，与本题对排序后序列有序性的讨论有相似之处，可锻炼对序列性质的把握能力。
2. **P3378 【模板】堆排序**：考察堆排序算法，与本题对排序算法的考察类似，可加深对不同排序算法的理解。
3. **P1177 【模板】快速排序**：通过实现快速排序算法，进一步掌握排序算法的原理和应用，与本题共同提升对排序相关问题的解决能力。

### 个人心得摘录与总结
暂未发现题解中有个人心得相关内容。 

---
处理用时：69.91秒
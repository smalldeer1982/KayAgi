# 题目信息

# 「EZEC-10」Shape

## 题目背景

规定 $(x,y)$ 表示第 $x$ 行第 $y$ 列的格子。

## 题目描述

小 A 有一个 $n\times m$ 的网格，一些为白色格子，剩余为黑色格子。

小 A 选择四个整数 $x_1,x_2,y_1,y_2$，满足如下条件：

1. $1\le x_1<x_2\le n$ 且 $1\le y_1<y_2\le m$。
2. $x_1+x_2$ 为偶数。

若 $(x_1,y_1)\to (x_2,y_1),(x_1,y_2)\to (x_2,y_2),(\frac{x_1+x_2}{2},y_1)\to (\frac{x_1+x_2}{2},y_2)$ 这三段中的格子均为白色，则称这三段构成的图形为 H 形。

小 A 想知道，这个网格中存在多少不同的 H 形。

**两个 H 形相同，当且仅当两个 H 形的 $x_1,x_2,y_1,y_2$ 均相同。**

## 说明/提示

**【样例 1 解释】**

$(x_1,x_2,y_1,y_2)=(1,3,3,4)$ 的 H 形符合。

**【样例 2 解释】**

$(x_1,x_2,y_1,y_2)=(1,5,1,3),(2,4,1,3)$ 的 H 形符合。

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（1 point）：$n=2$。
- Subtask 2（9 points）：$ n,m\le 50$。
- Subtask 3（10 points）：$ n,m\le 100$，**时限为 $500ms$**。
- Subtask 4（30 points）：$ n,m\le 500$。
- Subtask 5（50 points）：无特殊限制。

对于 $100\%$ 的数据，$2\le n,m\le 2\times 10^3$。

## 样例 #1

### 输入

```
3 4
1 0 0 0
1 1 0 0
1 0 0 0```

### 输出

```
1```

## 样例 #2

### 输入

```
5 3
0 1 0
0 1 0
0 0 0
0 1 0
0 1 0```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：
    - 这些题解针对计算网格中H形数量问题，从暴力枚举到逐步优化。多数题解先预处理每个格子向上、下延伸的距离，再通过不同方式统计H形。有的直接暴力枚举判断，有的利用横线上格子延伸距离关系，有的借助树状数组等数据结构优化。
    - 各题解思路和方法不同，质量也有差异，主要区别在于算法复杂度、实现的简洁性和思路清晰度。
    - 最优关键思路是通过预处理每个格子向上、向下延伸的最大距离，利用横线上格子延伸距离的大小关系，通过排序计算匹配对数统计H形数量，这样能将复杂度控制在O(nm log m)。
    - 可拓展到类似在矩阵中寻找特定形状或模式的计数问题，通常可通过预处理关键信息，利用形状特性优化枚举方式。
• 所选的题解：
  - 作者：_Arahc_ （5星）
    - 关键亮点：思路清晰，先分析枚举竖线的困难，转向枚举横线。通过预处理每个格子向上、向下延伸距离，利用横线上格子延伸距离的大小匹配关系，用排序计算H形数量，复杂度O(nm log m)。
    - 个人心得：考场上用优先队列TLE，后发现sort整体常数小可过，建议若用优先队列TLE可尝试数组排序。
    - 重点代码核心实现思想：先预处理每个格子向上、向下延伸距离并存于up、dn数组，取两者最小值存于s数组。然后遍历每一行，对于每行白色横线部分，将横线上各点的s值存入数组p，排序后按规则计算H形数量累加至答案。
```cpp
// a 数组为输入的 0-1 矩阵
for(register int j=1;j<=m;++j){
    for(register int i=1;i<=n;++i){
        if(a[i][j]) up[i][j]=0;
        else up[i][j]=up[i-1][j]+1;
    }// 向上
    for(register int i=n;i>=1;--i){
        if(a[i][j]) dn[i][j]=0;
        else dn[i][j]=dn[i+1][j]+1;
    }// 向下
}
for(register int i=1;i<=n;++i)
    for(register int j=1;j<=m;++j)
        s[i][j]=min(up[i][j],dn[i][j]);
// 取 min
// 注意 H 的真正高度为 s[i][j]*2-1
// 因为中间那一个白格子在这里也算进去了

int i=1,j=1;
while(i<n){
    while(a[i][j] && j<=m) ++j;

    if(j>m){ // 避免 j 越界
        ++i,j=1;
        continue;
    }

    tot=0;
    while(!a[i][j] && j<=m){ // 不要忘记 j<=m，会越界
        p[++tot]=s[i][j]-1; // 这里要-1（参见上面预处理代码注释）
        ++j;
    }

    std::sort(p+1,p+1+tot); // 小到大排序

    for(register int k=1;k<=tot;++k) ans+=p[k]*(tot-k);
    // 对于每一个 k 一共 tot-k 个 H 可以匹配

    if(j>m){ // 越界判断
        ++i,j=1;
        continue;
    }
}
```
  - 作者：Eason_AC （4星）
    - 关键亮点：按Subtask逐步讲解，从暴力枚举到优化。先预处理每个点向上、向下延伸距离，在正解中利用栈处理每行数据，将符合条件的延伸距离值存入栈，遇到黑色格子或行尾时，排序栈内元素并按规则计算对答案的贡献，复杂度O(nm log m)。
    - 重点代码核心实现思想：先预处理出每个点向上、向下延伸距离s、d数组，取两者最小值存于f数组。遍历每行，遇到黑色格子或行尾时，对栈内元素排序，计算每个元素对答案的贡献并累加，最后输出答案。
```cpp
namespace sub4 {
    int st[N], top;
    ll ans = 0;
    iv work() {
        F(int, i, 1, n) {
            top = 0;
            F(int, j, 1, m + 1) if(a[i][j] == 1 || j == m + 1) {
                if(top) {
                    sort(st + 1, st + top + 1);
                    F(int, k, 1, top - 1) ans += 1ll * st[k] * (top - k);
                    top = 0; 
                }
            } else st[++top] = f[i][j];
        }
        return write(ans), void();
    }
}
```
  - 作者：Ecrade_ （4星）
    - 关键亮点：按Subtask分别给出解法，思路清晰。在正解中，先预处理每个点向上下延伸的最大距离f数组，然后枚举每段极长横杠，将横杠上各点的f值排序，按规则计算横杠的总贡献，复杂度O(nm log m)。
    - 重点代码核心实现思想：先预处理f数组，然后遍历每行，通过记录极长横杠的起止位置，对横杠上各点的f值排序，计算每段极长横杠的贡献并累加至答案。
```cpp
ll calc(ll x,ll l,ll r){
    if (l > r) return 0;
    ll cnt = 0,res = 0;
    for (ll i = l;i <= r;i += 1) a[cnt ++] = f[x][i];
    sort(a,a + cnt);
    for (ll i = 0;i < cnt;i += 1) res += a[i] * (cnt - i - 1);
    return res;
}
for (ll i = 1;i <= n;i += 1){
    ll pre = 1;
    for (ll j = 1;j <= m;j += 1) if (ch[i][j]) ans += calc(i,pre,j - 1),pre = j + 1;
    ans += calc(i,pre,m);
}
```
• 相似知识点洛谷题目：
  - P1387 最大正方形：在矩阵中找最大正方形，需预处理信息结合动态规划。
  - P1169 棋盘制作：在棋盘找最大黑白交替的矩形，类似预处理和枚举优化。
  - P2701 小B的询问：区间颜色段数量统计，可类比预处理和利用数据结构优化。 

---
处理用时：64.61秒
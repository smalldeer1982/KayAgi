# 题目信息

# 『JROI-5』Autumn

## 题目背景

感谢 @[王熙文](/user/353688) 提供了一种优于标算的做法。

## 题目描述

**本题读入量较大，建议使用较快的读入方式，可以参考 [赛时公告板](https://www.luogu.com.cn/paste/lueudpd5)**


给定 $n$ 个数列，每个数列有 $m$ 个元素，第 $i$ 个数列第 $j$ 个元素为正整数 $a_{i,j}$。

你每次可以选择 $i_1,j_1$ 和 $i_2,j_2$，交换 $a_{i_1,j_1}$ 和 $a_{i_2,j_2}$。你至多可以进行 $x$ 次交换。

定义 $d_i$ 为第 $i$ 个数列中第 $k$ 大的元素。

请最小化 $\max\limits_{i=1}^n \{d_i\}$。（表示 $d_1,d_2,\cdots,d_n$ 中的最大值）

## 说明/提示

对于样例 1，将 $a_{2,5}$ 和 $a_{1,5}$ 交换，可以证明，没有更优策略。
***
对于 $30\%$ 的数据，$x = 10^6,1\leq k\leq m$。

对于另外 $10\%$ 的数据，**所有的数都相等**。

对于另外 $30\%$ 的数据，$1\leq n,m\leq 2\times 10^3,1\leq k\leq m,a_{i,j}\leq 10^6,0\leq x\leq n\times m$。

对于 $100\%$ 的数据，$1\leq n,m\leq 2\times 10^3,1\leq k\leq m,1\leq a_{i,j}\leq 10^{18},0\leq x\leq n\times m$。



## 样例 #1

### 输入

```
5 5
1 2 3 4 5
6 7 8 9 10
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
2 1```

### 输出

```
8```

## 样例 #2

### 输入

```
5 5
1 2 3 4 5
6 7 8 9 10
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
2 2```

### 输出

```
7```

## 样例 #3

### 输入

```
见附件```

### 输出

```
见附件```

# AI分析结果

• 综合分析与结论：这些题解主要围绕两种思路。其一为二分答案，先对每行排序，确定每行第k大元素位置，二分答案d，将数字按与d大小关系分类，通过比较特定位置不同类数字个数及交换次数限制判断d是否可行，如囧仙、Cocoly1990、Moya_Rao、karanoli、_Emperorpenguin_的题解；其二是通过优先队列维护两个集合，不断交换集合最值，如MichaelWong的题解。二分答案思路常规但需优化，维护集合思路较新颖。整体看，各题解在思路清晰度、代码可读性、优化程度上各有优劣。
• 所选的题解：
  - 囧仙（5星）：
    - 关键亮点：不仅提出二分答案常规思路，还利用单调性优化，将判断部分复杂度从\(\mathcal O(\log v\cdot nm)\)降为\(\mathcal O(nm)\)，整体复杂度降为\(\mathcal O(\log (nm)\cdot nm)\)，且常数较小。
    - 重点代码（核心实现思想：从大到小枚举可能的答案d，单调维护p和q值判断可行性）：
```cpp
dn(t,1,i){
    i64 d=W[I[i]][0];
    while(x>0&&W[I[x]][0]>d) p-=(W[I[x]][1]> k),--x;
    while(y>0&&W[I[y]][0]>d) q+=(W[I[y]][1]<=k),--y;
    if(q>u||q>p) break; ans=d;
}
```
  - MichaelWong（4星）：
    - 关键亮点：另辟蹊径，不采用二分答案，而是通过将元素分成两个集合，利用优先队列维护，不断交换集合最值，思路独特且实现简洁。
    - 重点代码（核心实现思想：用优先队列分别维护两个集合，不断交换集合最值直至无需交换）：
```cpp
while(x) {
    if(S.top()<T.top()) {
        int a1=S.top(),a2=T.top();
        S.pop();T.pop();
        S.push(a2);T.push(a1);
        x--;
    }
    else break;
}
```
  - Moya_Rao（4星）：
    - 关键亮点：详细阐述二分答案思路，从二分条件、`check`函数写法到优化快读，逻辑清晰，代码注释详细，便于理解。
    - 重点代码（`check`函数核心实现思想：统计特定位置与二分答案大小关系的数字个数，判断是否满足交换条件）：
```cpp
bool check(int id){
    long long x=s[id];
    int right_small=0;
    int left_big=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(j<=k&&a[i][j]>x)left_big++;
            if(j>k&&a[i][j]<=x)right_small++;
        }
    }
    if( right_small>=left_big && left_big<=num )return 1;
    else return 0;
}
```
• 最优关键思路或技巧：二分答案时利用单调性优化，或采用非二分的集合维护与交换策略。
• 可拓展思路：此类题目可拓展到其他矩阵元素操作并求最值问题，类似算法套路有通过合理分类元素、利用数据结构维护集合来简化操作和判断。
• 相似知识点洛谷题目：
  - P1873 砍树：二分答案经典题目，通过二分查找合适的砍树高度。
  - P2678 [NOIP2015 提高组] 跳石头：同样是二分答案，求满足条件的最小跳跃距离。
  - P3853 [TJOI2007] 路标设置：也是二分答案，解决在公路上设置路标使相邻路标距离最大值最小的问题。
• 个人心得：无。 

---
处理用时：37.25秒
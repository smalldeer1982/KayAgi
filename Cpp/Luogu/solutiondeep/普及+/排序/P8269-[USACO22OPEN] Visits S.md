# 题目信息

# [USACO22OPEN] Visits S

## 题目描述

Bessie 的 $N$（$2\le N\le 10^5$）个奶牛伙伴（编号为 $1\cdots N$）每一个都拥有自己的农场。对于每个 $1\le i\le N$，伙伴 i 想要访问伙伴 $a_i$（$a_i\neq i$）。

给定 $1\ldots N$ 的一个排列 $(p_1,p_2,\ldots, p_N)$，访问按以下方式发生。

对于 $1$ 到 $N$ 的每一个 $i$：

- 如果伙伴 $a_{p_i}$ 已经离开了她的农场，则伙伴 $p_i$ 仍然留在她的农场。
- 否则，伙伴 $p_i$ 离开她的农场去访问伙伴 $a_{p_i}$ 的农场。这次访问会产生快乐的哞叫 $v_{p_i}$ 次（$0\le v_{p_i}\le 10^9$）。


对于所有可能的排列 $p$，计算所有访问结束后可能得到的最大哞叫次数。

## 说明/提示

【样例解释】


如果 $p=(1,4,3,2)$，则

- 伙伴 $1$ 访问伙伴 $2$ 的农场，产生 $10$ 次哞叫。
- 伙伴 $4$ 看到伙伴 $1$ 已经离开了农场，所以无事发生。
- 伙伴 $3$ 访问伙伴 $4$ 的农场，又产生 $30$ 次哞叫。
- 伙伴 $2$ 看到伙伴 $3$ 已经离开了农场，所以无事发生。

这样总计得到了 $10+30=40$ 次哞叫。

另一方面，如果 $p=(2,3,4,1)$，则

- 伙伴 $2$ 访问伙伴 $3$ 的农场，产生 $20$ 次哞叫。
- 伙伴 $3$ 访问伙伴 $4$ 的农场，产生 $30$ 次哞叫。
- 伙伴 $4$ 访问伙伴 $1$ 的农场，产生 $40$ 次哞叫。
- 伙伴 $1$ 看到伙伴 $2$ 已经离开了农场，所以无事发生。

这样总计得到了 $20+30+40=90$ 次哞叫。可以证明这是所有可能的排列 $p$ 中访问结束后得到的最大可能的哞叫次数。

## 样例 #1

### 输入

```
4
2 10
3 20
4 30
1 40```

### 输出

```
90```

# AI分析结果

### 综合分析与结论
这些题解均将题目转化为图论问题，利用给定图的性质（$n$ 个点 $n$ 条边且每个点出度为1，形成基环森林）来解题。思路上，都意识到环上会有一个点无法产生贡献，要找出环上贡献最小的点，非环上点的贡献可全部获取。算法要点在于找到环及环上最小贡献值，不同题解采用了拓扑排序、Tarjan算法、Kruskal算法等不同方法。解决难点主要在于对基环森林结构的理解和处理。

### 所选的题解
- **作者：YBaggio (赞：18)  星级：4星**
    - **关键亮点**：思路清晰，结合拓扑排序和DFS解决问题。先通过拓扑排序找出不在环上的点并累加其贡献，再用DFS找出每个环并减去环上最小贡献值。
    - **重点代码 - 核心实现思想**：`topo`函数通过拓扑排序处理非环上节点，将其贡献累加到`ans`。`dfs`函数用于找出环并找到环上最小贡献值`minn`。
```cpp
void topo(){
    for(int i=1;i<=n;i++){
        if(!rd[i])q.push(i);
    }
    while(!q.empty()){
        int x=q.front();q.pop();
        ans+=v[x];rd[a[x]]--;
        vis[x]=1;
        if(!rd[a[x]])q.push(a[x]);
    }
    return;
}
void dfs(int x){
    vis[x]=1;
    minn=min(minn,v[x]);
    if(vis[a[x]])return;
    dfs(a[x]);
    return;
}
```
- **作者：enucai (赞：10)  星级：4星**
    - **关键亮点**：简洁清晰地阐述基于基环树的解题思路，代码简洁高效。明确指出不在环上的点按$dep$值从大到小加入排列可保证贡献，环上找贡献最小的点。
    - **重点代码 - 核心实现思想**：`dfs`函数标记访问节点。主函数中先累加所有点贡献，再通过循环找到每个环并减去环上最小贡献值。
```cpp
void dfs(int u){
	vis[u]=1;
	for(int v:e[u]) if(!vis[v]) dfs(v);
}
signed main(){
	cin>>n;
	For(i,1,n){
		cin>>a[i]>>val[i];
		e[a[i]].push_back(i);
	}
	int ans=0;
	For(i,1,n) ans+=val[i];
	For(i,1,n) if(!vis[i]){
		int u=i,mn=1e10;
		while(!vis2[u]) vis2[u]=1,u=a[u];
		int v=u;
		do mn=min(mn,val[v]),v=a[v]; while(v!=u);
		ans-=mn;
		dfs(u);
	}
	cout<<ans<<endl;
}
```
- **作者：Mars_Dingdang (赞：4)  星级：4星**
    - **关键亮点**：详细解释思路，利用Tarjan算法找出强连通分量（环），贪心选择环上点权最小的点不贡献。对非成环节点按拓扑序获取贡献。
    - **重点代码 - 核心实现思想**：`tarjan`函数实现Tarjan算法，找出环并记录环上最小点权`mi`。主函数中先累加所有点权，再减去每个环上最小点权。
```cpp
inline void tarjan(ll u) {
	dfn[u] = low[u] = ++timer;
	stk[++top] = u;
	for(int i = hd[u]; i; i = nxt[i]) {
		int v = ver[i];
		if(!dfn[v]) {
			tarjan(v);
			low[u] = min(low[u], low[v]);
		}
		else if(!scc[v]) 
			low[u] = min(low[u], dfn[v]);
	}
	if(low[u] == dfn[u]) {
		mi[++cnt] = inf;
		while(1) {
			int v = stk[top --];
			scc[v] = cnt;
			sz[cnt] ++; 
			mi[cnt] = min(mi[cnt], val[v]);
			if(u == v) break;
		}
	}
}
int main () {
	ll sum = 0;
	read(n);
	rep(i, 1, n) {
		ll u; 
		read(u); read(val[i]);
		add(i, u);
		sum += val[i];
	}
	rep(i, 1, n)
		if(!dfn[i]) tarjan(i);
	rep(i, 1, cnt) 
		if(sz[i] > 1) sum -= mi[i];
	writeln(sum);	
	return 0;
}
```

### 最优关键思路或技巧
将实际问题转化为基环森林的图论模型，利用贪心策略，即环上选择贡献最小的点不产生贡献，非环上点贡献全部获取。实现方法上，拓扑排序、Tarjan算法等能有效处理基环森林结构，找到环和非环部分。

### 可拓展思路
同类型题常涉及有向图的特殊结构（如基环树）和贪心策略结合。类似算法套路是先分析图的结构特点，再针对不同部分（如环和非环）采用合适算法处理。例如给定有向图，根据节点出度入度特点构建图，分析环和树状结构部分对结果的影响。

### 洛谷相似题目推荐
- P2661 [NOIP2015 提高组] 信息传递：同样是有向图找环问题，求最小环长度。
- P3386 【模板】二分图匹配：虽然是二分图匹配问题，但涉及图的构建和性质分析，与本题图论思维有相似处。
- P1345 [USACO5.4] 奶牛的电信Telecowmunication：关于网络流和图的连通性问题，锻炼图论综合应用能力。

### 个人心得摘录与总结
部分作者提到在解题过程中通过手玩样例找规律，从而发现环上点的贡献规律。还有作者感慨题目难度超出预期，在分析和解决问题过程中花费较多时间。总结来看，对于复杂图论问题，从简单样例入手，分析特殊结构（如环）的性质是解题关键。 

---
处理用时：57.76秒
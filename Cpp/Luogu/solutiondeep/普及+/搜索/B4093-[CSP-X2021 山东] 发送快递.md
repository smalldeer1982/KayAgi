# 题目信息

# [CSP-X2021 山东] 发送快递

## 题目背景

**原题为错题，不可做。数据范围修改如下，请以题目背景中的为准：**

【数据范围和限制】

对于 $40\%$ 的数据，$1 \leq n \leq 23$，$1 \leq a_i \leq 100$，$s=0$，$m$ 的值保证有解。

对于 $100\%$ 的数据，$1 \leq n \leq 23$，$1 \leq a_i \leq 100$，$0 \leq s \leq 15$，$m$ 的值保证有解。

**为了防止无意义的钻牛角尖的 hack，本题认为 $m$ 不超过 $2^{31}-1$。**

## 题目描述

小华有 $n$ 本不同的书（编号为 $1,2,3,\dots,n$），重量分别是 $a_1,a_2,\dots,a_n$ 公斤（重量可以相同）。他想把这些书以快递的方式发给自己的好朋友，要求每个包裹的重量不能超过 $m$ 公斤（可以等于 $m$ 公斤），并且小华想把其中一些书（一组书，用书的编号给出来）放在一个包裹里，应该如何打包才能使得快递件数最少。

## 说明/提示

【输入输出样例 1 说明】

第 $1$ 本和第 $4$ 本打包，重量是 $10$ 公斤。第 $2$ 本和第 $5$ 本打包，重量是 $9$ 公斤。第 $3$ 本单独打包，重量是 $8$ 公斤。所以一共 $3$ 件快递。

【输入输出样例 2 说明】

第 $1$ 本和第 $5$ 本打包，第 $2$ 本、第 $4$ 本、第 $8$ 本和第 $10$ 本打包，第 $3$ 本和第 $7$ 本打包，第 $6$ 本和第 $9$ 本打包。所以一共 $4$ 件快递。

【数据范围和限制】

对于 $40\%$ 的数据，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 100$，$s=0$，$m$ 的值保证有解。

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 100$，$0 \leq s \leq 100$，$m$ 的值保证有解。

## 样例 #1

### 输入

```
5 10
8 4 8 2 5
0```

### 输出

```
3```

## 样例 #2

### 输入

```
10 80
49 11 44 18 28 24 19 10 27 29
2
1 5
4 8 2```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
本题核心为处理必须捆绑的书组，并通过搜索剪枝求解最小包裹数。最优解法均采用 DFS + 贪心排序 + 剪枝优化，时间复杂度约 O(k·n!)（k为剪枝效率），因 n≤23 而可行。关键优化点在于预处理合并组、按重量降序搜索、最优性剪枝。

---

### 高星题解推荐

#### 1. Yxy7952（4.5星）
**核心亮点**  
- 并查集处理强制捆绑组，逻辑严密  
- 双贪心策略：先处理大重量物品 + 优先尝试合并包裹  
- 预处理已有包裹的初始状态  
- 输入处理细节完备（换行符判断）

**代码核心思想**  
预处理合并组后降序排列，DFS尝试将当前书放入已有包裹或新建包裹，配合最优性剪枝。

```cpp
void dfs(int x, int sum) {
    if (sum >= ans) return; // 最优性剪枝
    if (x == n + 1) {
        ans = min(sum, ans);
        return;
    }
    if (vis[a[x].id]) { // 跳过已处理组
        dfs(x + 1, sum);
        return;
    }
    // 尝试放入已有包裹
    for (int i = 1; i <= sum; i++) {
        if (h[i] + a[x].s <= m) {
            h[i] += a[x].s;
            dfs(x + 1, sum);
            h[i] -= a[x].s;
        }
    }
    // 新建包裹
    h[sum + 1] = a[x].s;
    dfs(x + 1, sum + 1);
    h[sum + 1] = 0;
}
```

#### 2. xinxin2022（5星）
**核心亮点**  
- 图遍历合并强制组，直观高效  
- 代码简洁，变量命名清晰  
- 动态维护包裹数组，复用空间  
- 最优性剪枝与排序策略结合完美

**代码核心思想**  
通过邻接表合并强制组后降序排列，DFS时动态维护包裹数组，优先尝试合并。

```cpp
void dfs(int now, int val) {
    if (val >= ans) return;
    if (now == p + 1) {
        ans = val;
        return;
    }
    // 尝试放入现有包裹
    for (int i = 1; i <= k; i++) {
        if (c[i] + a[now] <= m) {
            c[i] += a[now];
            dfs(now + 1, val);
            c[i] -= a[now];
        }
    }
    // 新建包裹
    k++;
    c[k] += a[now];
    dfs(now + 1, val + 1);
    c[k] -= a[now];
    k--;
}
```

---

### 最优技巧总结
1. **预处理强制组**：通过并查集/图遍历合并必须同包裹的书  
2. **降序贪心**：先处理大重量物品，减少后续分支可能性  
3. **最优性剪枝**：当前包裹数≥已有最优解时立即回溯  
4. **包裹复用策略**：优先尝试合并到现有包裹，最后新建包裹

---

### 拓展与举一反三
- **同类题目**  
  1. [P3052 [USACO12MAR]摩天大楼里的奶牛](https://www.luogu.com.cn/problem/P3052)（相同DFS剪枝框架）  
  2. [P2320 [HNOI2006] 鬼谷子的钱袋](https://www.luogu.com.cn/problem/P2320)（分组策略优化）  
  3. [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379)（状态空间搜索优化）

- **个人心得摘录**  
  > "排序只能放这里，可以思考一下为什么" —— Yxy7952  
  （答：预处理强制组后，需保证后续DFS处理顺序为降序）  

  > "质量大的书选择空间比较小，先处理能有效剪枝" —— xinxin2022  
  （体现贪心策略与搜索顺序优化的紧密关联）

---
处理用时：78.19秒
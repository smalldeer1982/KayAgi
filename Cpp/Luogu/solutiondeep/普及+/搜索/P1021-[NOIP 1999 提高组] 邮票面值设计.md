# 题目信息

# [NOIP 1999 提高组] 邮票面值设计

## 题目背景

除直接打表外，本题不保证存在**正确且时间复杂度可以通过全部数据**做法。由于测试数据过水，部分错误做法可以通过此题，通过不代表做法正确。本题不接受 hack 数据。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

给定一个信封，最多只允许粘贴 $N$ 张邮票，计算在给定 $K$（$N+K \le 15$）种邮票的情况下（假定所有的邮票数量都足够），如何设计邮票的面值，能得到最大值 $\mathsf{MAX}$，使在 $1$ 至 $\mathsf{MAX}$ 之间的每一个邮资值都能得到。

例如，$N=3$，$K=2$，如果面值分别为 $1$ 分、$4$ 分，则在 $1\sim 6$ 分之间的每一个邮资值都能得到（当然还有 $8$ 分、$9$ 分和 $12$ 分）；如果面值分别为 $1$ 分、$3$ 分，则在 $1\sim 7$ 分之间的每一个邮资值都能得到。可以验证当 $N=3$，$K=2$ 时，$7$ 分就是可以得到的连续的邮资最大值，所以 $\mathsf{MAX}=7$，面值分别为 $1$ 分、$3$ 分。


## 样例 #1

### 输入

```
3 2
```

### 输出

```
1 3
MAX=7
```

# AI分析结果



### 综合分析与结论
本题需通过DFS生成邮票面值组合，并用动态规划验证其最大连续覆盖值。各题解核心思路一致：**DFS枚举面值组合+DP计算连续范围**，但剪枝策略与实现细节存在差异。最优解法需结合以下要点：
1. **必须包含面值1**以确保覆盖起点；
2. **剪枝策略**：下一张面值范围为`[last+1, 当前最大连续值+1]`；
3. **DP状态优化**：`f[i]`表示组成面值i的最小邮票数，通过状态转移快速验证连续性。

---

### 高星题解推荐
#### 1. 包子入侵（★★★★★）
**关键亮点**：  
- 思路清晰，注释详细，适合初学者理解  
- 剪枝范围明确（`a[t-1]+1`到`当前最大连续值+1`）  
- 动态规划实现简洁，用`f[j] = min(f[j], f[j-a[i]]+1)`高效计算  

**核心代码**：
```cpp
int dp(int t, int mx){
    int f[50000]; // f[i]为拼i所需的最少邮票数
    memset(f, 0x3f, sizeof(f)); f[0] = 0;
    for(int i=1; i<=t; i++)
        for(int j=a[i]; j<=a[t]*n; j++)
            f[j] = min(f[j], f[j - a[i]] + 1);
    for(int i=1; ;i++)
        if(f[i] > n) return i-1;
}
```

#### 2. Celebrate（★★★★☆）
**关键亮点**：  
- 剪枝策略逆向枚举（从`t+1`到`a[k-1]+1`），可能更快收敛  
- 代码模块化，`solve()`函数分离DP逻辑  
- 明确强调面值1的必要性  

**个人心得**：  
> "剪枝3是本题难点，确定枚举上界为`t+1`，若超过则无法组成连续值。"

**核心剪枝逻辑**：
```cpp
for(int i=a[k-1]+1; i<=t+1; i++){
    a[k] = i;
    int x = dp(...);
    dfs(...);
}
```

#### 3. Lynx（★★★★☆）
**关键亮点**：  
- 状态设计简洁，`dp[i]`直接表示最少邮票数  
- 双重循环剪枝，外层枚举面值，内层更新DP  
- 变量命名清晰，如`lst2`表示历史最大连续值  

**代码片段**：
```cpp
for(int i=1; i<=dep; i++)
    for(int j=tmp[i]; j<=n*sum; j++)
        dp[j] = min(dp[j], dp[j-tmp[i]]+1);
```

---

### 最优思路总结
1. **DFS生成面值**：从1开始，每层递归确定下一张面值的范围，确保连续性。
2. **动态规划验证**：计算当前面值组合能覆盖的最大连续值，核心方程为：
   ```cpp
   f[j] = min(f[j], f[j - a[i]] + 1);
   ```
3. **剪枝优化**：下一张面值上限为当前连续最大值+1，避免无效搜索。

---

### 拓展与相似题目
1. **P1092 虫食算**（DFS+剪枝）  
2. **P1379 八数码难题**（状态搜索+哈希优化）  
3. **P1120 小木棍**（DFS剪枝+贪心策略）  

**套路延伸**：类似“组合生成+验证”的题目常结合DFS/回溯与高效DP/BFS，需重点掌握剪枝与状态压缩技巧。

---
处理用时：57.09秒
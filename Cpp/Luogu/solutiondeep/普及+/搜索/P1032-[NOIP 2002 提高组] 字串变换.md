# 题目信息

# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论
本题属于隐式图搜索问题，核心难点在于状态空间爆炸控制。各题解呈现以下共性：
1. 主流解法为BFS（含双向BFS），辅以迭代加深搜索
2. 关键优化点：字符串匹配优化、状态判重、剪枝策略
3. 字符串处理技巧（如find+replace组合）直接影响效率

### 高星题解推荐（评分≥4）

#### 1. [双向BFS解法] 作者：BrandonSoong（5星）
**关键亮点**：
- 双向BFS大幅缩减搜索空间，用两个队列分别从起点终点扩展
- 交替扩展策略保持队列平衡，优先扩展较小队列
- 引入双map判重，相遇时步数相加得到总步数
**核心代码**：
```cpp
void bfs(){
    while(!q1.empty() && !q2.empty()){
        // 交替扩展两个队列
        if(q1.size() <= q2.size()) expand(q1, q2, 0);
        else expand(q2, q1, 1);
    }
}
void expand(queue<string>& q, queue<string>& other, int dir){
    // 实现双向扩展逻辑，判断相遇条件
}
```

#### 2. [BFS+map判重] 作者：ShawnZhou（4.5星）
**关键亮点**：
- 标准BFS框架清晰易理解
- 使用map<string,bool>实现高效状态判重
- 利用string::find遍历所有匹配位置
**调试心得**：
> "第五个点一直TLE，发现必须对同一规则下的多个匹配位置分别处理，用while循环替代单次find"

#### 3. [迭代加深+剪枝] 作者：Time_Rune（4星）
**关键亮点**：
- 迭代加深避免DFS爆栈，通过限制深度逐步试探
- 结合map记录步数进行剪枝
- 适合步数限制严格（10步）的场景

### 关键优化技巧总结
1. **双向BFS**：将时间复杂度从O(b^d)降为O(b^(d/2))，适合目标状态明确的情形
2. **字符串匹配优化**：
   - KMP预处理模式串（coyangjr解法）
   - 利用string::find的start参数实现全匹配扫描
3. **状态判重**：
   - 双向搜索时使用双map分别记录
   - 单BFS时用全局map记录已访问状态
4. **剪枝策略**：
   - 步数超过10立即剪枝
   - 长度可行性剪枝（预估最大可能长度）

### 拓展练习推荐
1. P1126 机器人搬重物（BFS+状态表示）
2. P1379 八数码难题（双向BFS经典应用）
3. P2324 骑士精神（迭代加深搜索典型题）

### 核心代码示例（双向BFS相遇判断）
```cpp
// 检查两个队列是否相遇
void check(int x){
    for(int i=1;i<=tail[1-x];i++){
        if(q[x][tail[x]] == q[1-x][i]){
            cout<<step[x][tail[x]] + step[1-x][i];
            exit(0);
        }
    }
}
```

注：实际编码需处理字符串替换细节，建议结合题解完整代码理解实现。优先掌握双向BFS框架，再逐步优化匹配效率。

---
处理用时：68.68秒
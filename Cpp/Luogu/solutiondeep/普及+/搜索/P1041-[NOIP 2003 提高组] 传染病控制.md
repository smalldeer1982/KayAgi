# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论
本题考察树形结构下的最优策略搜索。所有题解均围绕DFS/BFS+剪枝展开，核心在于分层处理与子树预处理。关键难点在于避免重复切断和高效回溯。部分题解尝试贪心/随机化但稳定性不足，DFS分层剪枝是更可靠的选择。

#### 精选题解分析
1. **RikoHere（4星）**  
   **亮点**：清晰的层次化处理思路，通过BFS预处理节点层级，DFS按层枚举切断点。代码模块化（clean/reclean函数）增强可读性。  
   **代码核心**：  
   ```cpp
   void dfs(int cen, int tot) {
       maxx = max(maxx, tot); // 更新最大保护数
       for (所有当前层节点) {
           if (!被保护) {
               int num = clean(节点); // 标记子树
               dfs(下一层, tot + num); // 递归
               reclean(节点); // 回溯
   }}}
   ```

2. **基础不牢（4星）**  
   **亮点**：结构体存储父子关系，预处理每层节点集合。引入`work/rework`函数处理子树标记，利用`vis`数组优化状态管理。  
   **调试经验**：处理链状结构时发现必须增加层空判断，否则无法正确更新答案。

3. **欧鹰（4星）**  
   **亮点**：极简实现（仅60行），通过`tag`数组快速判断祖先状态，`pushdown`函数处理子树标记。预处理每个节点的`size`加速计算。

---

### 关键思路总结
1. **分层预处理**  
   - BFS/DFS预处理每个节点的深度和所在层
   - 用`vector<int> level[]`存储各层节点集合
2. **子树快速计算**  
   - 预处理`size[i]`表示以i为根的子树节点数
   - 切断时直接累加`size`值，避免重复计算
3. **回溯剪枝**  
   ```cpp
   void 标记子树(int u) { 
       vis[u] = 1;
       for (所有子节点v) 标记(v); 
   }
   void 恢复子树(int u) { 
       vis[u] = 0; 
       for (所有子节点v) 恢复(v);
   }
   ```

---

### 拓展训练
1. **同类型题**  
   - [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)（树形DP）  
   - [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)（树形DP+背包）  
   - [P2014 选课](https://www.luogu.com.cn/problem/P2014)（树形依赖问题）

2. **优化技巧**  
   - **记忆化搜索**：对重复状态缓存结果（如`f[层数][已选节点]`）
   - **启发式剪枝**：优先处理大子树，提前终止劣解路径

---

### 经典代码片段
**欧鹰题解核心**（极简实现）：
```cpp
void dfs(int dep, int sum) {
    ans = max(ans, sum); // 更新最优解
    vector<int> cur_layer;
    for (auto u : level[dep]) {
        if (find(u的父节点未被标记)) 
            cur_layer.push_back(u);
    }
    for (auto u : cur_layer) {
        tag[u] = 1;
        dfs(dep+1, sum + size[u]);
        tag[u] = 0;
    }
}
```

---
处理用时：62.87秒
# 题目信息

# [NOIP 2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# AI分析结果



### 综合分析与结论
本题考察栈操作序列计数问题，本质是卡特兰数的经典应用。各题解围绕四种核心思路展开：记忆化搜索、动态规划、组合数公式、递推公式。最优解为卡特兰数的递推公式实现（O(n)时间+O(1)空间），其次为动态规划（O(n²)时间空间）。关键难点在于建立卡特兰数模型与状态转移方程的推导。

---

### 高星题解推荐

#### 题解作者：xiejinhao（5星）
**关键亮点**  
- 提供4种解法（记忆化搜索/DP/组合数/递推公式）的完整实现  
- 包含高精度打表拓展思路  
- 对比不同公式的适用场景（取模、高精度等）  
**核心代码**  
递推公式法（最优解）：
```cpp
for(int i=2; i<=n; i++)
    f[i] = f[i-1]*(4*i-2)/(i+1);
```
**个人心得**  
"当需要取模时，组合数差公式是最优选择，避免除法与溢出问题"

---

#### 题解作者：Shmily_389704（4星）
**关键亮点**  
- 清晰定义状态f[i][j]（栈内i元素，未处理j元素）  
- 直观解释转移方程：`f[i][j] = f[i-1][j]（push） + f[i+1][j-1]（pop）`  
**核心代码**  
动态规划实现：
```cpp
for(int j=1; j<=n; j++)
    for(int i=0; i<=n; i++)
        f[i][j] = (i==0) ? f[i+1][j-1] : f[i-1][j] + f[i+1][j-1];
```

---

#### 题解作者：jiangXxin（4星）  
**关键亮点**  
- 折线法证明卡特兰数的几何意义  
- 给出Python高精度实现方案  
**核心思路**  
将入栈出栈视为坐标系中的步行动作，合法路径数=总路径数-跨过对角线的非法路径数

---

### 关键思路总结
1. **状态定义技巧**：用二维状态描述栈内外元素数量（如f[未进栈数][栈内数]）
2. **递推优化**：发现结果符合卡特兰数后，直接应用闭式公式可极大优化效率
3. **组合数计算优化**：利用递推式`C(n,k) = C(n,k-1)*(n-k+1)/k`避免阶乘溢出
4. **记忆化剪枝**：在DFS中缓存中间结果，将指数复杂度降为多项式级

---

### 拓展训练题目
1. [P1976 鸡蛋饼](https://www.luogu.com.cn/problem/P1976) - 卡特兰数的变形应用  
2. [P3200 [HNOI2009]有趣的数列](https://www.luogu.com.cn/problem/P3200) - 组合数性质与卡特兰数  
3. [P1754 球迷购票问题](https://www.luogu.com.cn/problem/P1754) - 二维限制的卡特兰数变种

---

### 调试经验摘录
1. **边界处理**："当所有数已入栈时，出栈顺序唯一，此时直接返回1"（易漏判i==0的边界）
2. **数据类型选择**："计算组合数时必须用long long，36!会爆int"  
3. **递推方向**："从i=0开始递推，保证每个状态的前驱都已计算"  
4. **公式选择**："当n>15时，递归会超时，必须转用DP或闭式公式"

---
处理用时：62.64秒
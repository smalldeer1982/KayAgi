# 题目信息

# [NOIP 2007 普及组] 守望者的逃离

## 题目背景

NOIP2007 普及组 T3

## 题目描述

恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。

守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。

为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。

守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。

现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。

注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。


## 说明/提示

对于 $30\%$ 的数据，$1  \le  T   \le  10$，$ 1   \le   S   \le  100$；

对于 $50\%$ 的数据，$1   \le  T   \le   10^3$，$ 1   \le  S  \le   10^4$；

对于 $100\%$ 的数据，$1   \le   T   \le   3\times  10^5$，$0   \le   M   \le   10^3$，$ 1   \le  S   \le   10^8$。


## 样例 #1

### 输入

```
39 200 4
```

### 输出

```
No
197
```

## 样例 #2

### 输入

```
36 255 10```

### 输出

```
Yes
6```

# AI分析结果



### 综合分析与结论
本题需在时间限制内选择最优移动策略（闪现/跑步），核心在于动态规划与贪心的结合。各题解主要分为两类：  
1. **贪心+双状态维护**：实时比较闪现与跑步的距离，取最大值作为当前最优。时间复杂度 O(T)，高效且简洁。  
2. **动态规划预处理**：分两次处理闪现和跑步的最优值，正确性高但空间复杂度略高。  

以下为评分较高的题解：

---

### 精选题解列表

#### 1. 作者：wzr1125 (★★★★☆)
**关键亮点**：  
- **双变量动态维护**：用 `fla` 和 `run` 分别记录闪现和跑步的距离，每次取最大值更新。  
- **代码极简高效**：仅需单次循环，时间复杂度 O(T)。  
- **思路直观**：模拟两种策略的实时最优选择。  

**核心代码**：  
```cpp
int fla=0, run=0;
for(int i=1; i<=t; i++) {
    if(m>=10) m-=10, fla+=60;
    else m+=4;
    run = max(run+17, fla);  // 取当前最优
    if(run>=s) { /*输出并退出*/ }
}
```

#### 2. 作者：Cold_Eyes_bystander (★★★★☆)
**关键亮点**：  
- **双状态贪心**：维护两人分别代表闪现与跑步，实时同步最优路径。  
- **逻辑清晰**：通过 `max()` 直接比较两种策略。  

**核心代码**：  
```cpp
int s1=0, s2=0;
for(int i=1; i<=t; i++) {
    s1 += 17;
    if(m>=10) { m-=10; s2+=60; }
    else m+=4;
    if(s2>s1) s1 = s2;  // 同步最优状态
    if(s1>=s) { /*输出并退出*/ }
}
```

#### 3. 作者：GLr137 (★★★★☆)
**关键亮点**：  
- **动态规划预处理**：先计算纯闪现的路径，再用跑步优化。  
- **两次遍历处理**：分离闪现与跑步的决策，确保全面覆盖。  

**核心代码**：  
```cpp
int dp[300005] = {0};
for(int i=1; i<=t; i++) {  // 预处理闪现
    if(m>=10) dp[i]=dp[i-1]+60, m-=10;
    else dp[i]=dp[i-1], m+=4;
}
for(int i=1; i<=t; i++) {  // 用跑步优化
    dp[i] = max(dp[i], dp[i-1]+17);
    if(dp[i]>=s) { /*输出并退出*/ }
}
```

---

### 最优思路总结
**关键技巧**：  
- **贪心双状态法**：每时刻维护闪现和跑步的最优值，取最大值作为当前最优。  
- **时间复杂度优化**：通过单次循环 O(T) 避免复杂分情况讨论，适合大数据规模。  

**同类型题目推荐**：  
1. [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)（贪心+路径选择）  
2. [P1944 最长前缀](https://www.luogu.com.cn/problem/P1944)（动态规划预处理）  
3. [P1510 精卫填海](https://www.luogu.com.cn/problem/P1510)（资源分配与最优决策）  

---

### 个人心得摘录
- **wpy233**：通过分魔法值区间处理，需注意边界条件（如时间不足以完成完整策略时需回退到跑步）。  
- **Asurudo**：调试中发现某些“礼包”策略在特定距离下不优，需结合剩余距离灵活切换策略。  
- **Danny_chan**：代码简洁性的重要性，避免过度复杂的分支判断。

---
处理用时：78.57秒
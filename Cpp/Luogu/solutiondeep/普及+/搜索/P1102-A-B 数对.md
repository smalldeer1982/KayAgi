# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题核心在于高效统计满足差值的数对，需避免O(n²)暴力。主流解法围绕哈希映射、二分查找、双指针展开，时间复杂度均为O(n log n)或更低。最优解需兼顾效率与代码简洁性。

### 精选题解与评分

#### 1. 作者：OsvaldoAsensioLopez (★★★★★)
**关键亮点**：  
- 使用`map`将问题转化为A-C=B的映射统计，思路简洁直观  
- 代码仅15行，利用STL特性高效统计出现次数  
- 正确处理不同位置的重复数值，符合题意要求  

**核心代码**：
```cpp
map<LL,LL> m;
for(int i=1;i<=n;i++) m[a[i]]++;
for(int i=1;i<=n;i++) ans += m[a[i]-c];
```

#### 2. 作者：樱花飞舞 (★★★★☆)
**关键亮点**：  
- 利用排序后二分查找上下界，精确统计目标值数量  
- 通过`upper_bound - lower_bound`计算区间长度，避免重复遍历  
- 适用于需要严格空间控制的场景（无哈希表开销）

**核心代码**：
```cpp
sort(a+1, a+N+1);
ans += upper_bound(a+1, a+N+1, a[i]+C) - lower_bound(...);
```

#### 3. 作者：jins3599 (★★★★☆)
**关键亮点**：  
- 双指针维护滑动窗口，O(n)时间完成扫描  
- 利用有序性避免重复计算，适合大数据量场景  
- 通过分离左右区间指针实现高效统计

**核心代码**：
```cpp
while(r1 <= n && a[r1] - a[l] <= c) r1++;
while(r2 <= n && a[r2] - a[l] < c) r2++;
ans += r1 - r2;
```

### 最优技巧总结
1. **哈希映射**：通过`map/unordered_map`实现O(1)查找，代码最简洁  
2. **二分边界**：排序后查找目标值边界，空间效率更优  
3. **双指针扫描**：在线性时间内完成统计，适合严格时间要求  

### 同类题目推荐
1. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102)（本题原型）  
2. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)（双指针滑动窗口经典）  
3. [P1496 火烧赤壁](https://www.luogu.com.cn/problem/P1496)（区间统计与合并）

### 调试心得摘录
- **map陷阱**：用户"attack"指出更新数据后需用long long防止溢出  
- **边界处理**：用户"ysj1173886760"强调需处理C=0时`a[i]-c == a[i]`的特殊情况  
- **哈希优化**：用户"fallenangel"对比gp_hash_table比map快3倍，提供底层实现差异的实践认知  

---

**最佳实践建议**：  
- 小规模数据优先map实现，快速开发  
- 大规模数据采用排序+双指针，平衡效率与内存  
- 注意数值范围，使用long long防止计数溢出

---
处理用时：60.54秒
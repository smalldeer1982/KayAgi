# 题目信息

# 删数问题

## 题目描述

键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。

## 说明/提示

用 $\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \leq k < \operatorname{len}(n) \leq 250$。

## 样例 #1

### 输入

```
175438 
4
```

### 输出

```
13```

# AI分析结果



### 综合分析与结论
本题核心为贪心策略：通过局部最优（高位尽可能小）推导全局最优。主流解法分为两类：① 遍历删除递减区间的首字符 ② 逆向思维转换为保留最优数字。关键难点在于处理前导零与极端情况（如全零结果）。时间复杂度多为O(nk)或优化至O(n)。以下精选高质量题解：

---

### 精选题解与评分

#### 1. 作者：expin（★★★★★）
**关键亮点**：
- 分块贪心策略：每次在允许范围内找最小数字作为当前位，直接处理前导零
- 数学证明严谨，代码简洁高效（时间复杂度O(n)）
- 创新性地通过`flag`标记解决前导零问题

**核心代码**：
```cpp
while(cnt<rest) {
    minp = t;
    for(int i=t; i<=k+t; ++i) 
        if(a[minp]>a[i]) minp = i;
    if(a[minp]) flag=1;
    if(flag) cout<<a[minp];  // 动态输出避免存储前导零
    k -= minp - t;
    t = minp + 1;
    cnt++;
}
```

---

#### 2. 作者：saxiy（★★★★☆）
**关键亮点**：
- 结合ST算法实现O(nlogn)复杂度
- 使用RMQ快速查询区间最小值
- 预计算last数组优化查找过程

**优化技巧**：
```cpp
void init() {
    *last[n] = n; // 边界处理
    for(int i=n-1; ~i; i--) {
        memcpy(last[i], last[i+1], sizeof(int)*10); // 状态转移
        last[i][a[i]] = i; // 记录最近位置
    }
}
```

---

#### 3. 作者：Sol1（★★★★☆）
**关键亮点**：
- 双向链表实现O(n)时间复杂度
- 动态维护可删除节点，避免数组移位
- 巧妙处理降序序列的连续删除

**链表实现**：
```cpp
while(n && q.size() && q.top() > f(a[i])) {
    q.pop();  // 删除比当前大的栈顶元素
    n--;
}
q.push(f(a[i])); // 维护单调递增栈
```

---

### 关键思路总结
1. **贪心策略**：在允许删除的窗口内选择最小数字作为当前位（expin），或删除第一个递减区间的首字符（多数解法）
2. **前导零处理**：动态输出时跳过前导零，或最后统一删除
3. **极端情况处理**：特判全零结果，如`if(!flag) cout<<0`
4. **数据结构优化**：链表（O(n)）、ST表（RMQ）、单调栈等提升效率

---

### 同类题目推荐
1. [P1323 删数游戏](https://www.luogu.com.cn/problem/P1323) - 动态规划+贪心
2. [P1799 数列分段](https://www.luogu.com.cn/problem/P1799) - 类似的最优分段策略
3. [P1284 三角形牧场](https://www.luogu.com.cn/problem/P1284) - 贪心策略的变形应用

---

### 调试经验摘录
1. **前导零陷阱**：多题解提到未处理`10删1→0`导致WA（如KillerXu题解）
2. **降序特判**：需处理完全递增时删除末尾数字（如TLE_ooo题解）
3. **输出截断**：当剩余位数不足时要及时终止（如蒟蒻365题解）

> "最后一次提交才意识到必须特判全删后输出0，否则会空输出" —— Lydia_Moon题解

这些经验凸显了边界测试的重要性，建议编码时优先编写极端测试用例。

---
处理用时：60.10秒
# 题目信息

# 数字生成游戏

## 题目描述

小明完成了这样一个数字生成游戏，对于一个不包含 $0$ 的数字 $s$ 来说，有以下 $3$ 种生成新的数的规则：

1.    将 $s$ 的任意两位对换生成新的数字，例如 $143$ 可以生成 $314,413,134$；

2.    将 $s$ 的任意一位删除生成新的数字，例如 $143$ 可以生成 $14,13,43$；

3.    在 $s$ 的相邻两位之间 $s_i,s_{i + 1}$ 之间插入一个数字 $x$，$x$ 需要满足 $s_i<x<s_{i + 1}$。例如 $143$ 可以生成 $1243,1343$，但是不能生成 $1143,1543$ 等。

现在小明想知道，在这个生成法则下，从 $s$ 开始，每次生成一个数，可以用然后用新生成的数生成另外一个数，不断生成直到生成 $t$ 至少需要多少次生成操作。

另外，小明给规则 $3$ 又加了一个限制，即生成数的位数不能超过初始数 $s$ 的位数。若 $s$ 是 $143$，那么 $1243$ 与 $1343$ 都是无法生成的；若 $s$ 为 $1443$，那么可以将 $s$ 删除变为 $143$，再生成 $1243$ 或 $1343$。

## 说明/提示

**样例解释**

$143\to 134$

$133$ 无法得到

$143\to13\to123\to23\to32$

**数据范围**

对于 $20\%$ 的数据，$s < 100$；  
对于 $40\%$ 的数据，$s < 1000$；  
对于 $40\%$ 的数据，$m < 10$；  
对于 $60\%$ 的数据，$s < 10000$；  
对于 $100\%$ 的数据，$s < 100000,m ≤ 50000$。

## 样例 #1

### 输入

```
143
3
134
133
32
```

### 输出

```
1
-1
4
```

# AI分析结果



### 综合分析与结论
题目核心是通过三种数字变换规则求解最小生成步数，所有题解均采用BFS预处理所有可达状态。关键难点在于高效处理数字交换、删除、插入操作，以及正确处理位数限制。以下题解在代码优化和思路清晰度上表现突出。

---

### 高星题解推荐

#### 1. 作者：Alarm5854（⭐⭐⭐⭐⭐）
**关键亮点**  
① 极简代码风格（不足50行）  
② 巧妙利用 `stoi/to_string` 完成数字与字符串的转换  
③ 严格遵循BFS层序扩展特性，保证首次访问即最短路径  
④ 使用整型数组判重，性能优于map

**核心实现思想**  
```cpp
void bfs(int s) {
    queue<int> q; 
    q.push(s); 
    while (!q.empty()) {
        int x = q.front(); q.pop();
        string t = to_string(x);  // 整型转字符串处理
        // 交换、删除、插入三种操作均通过字符串处理
        for (int i=0;i<t.size();i++) 
        for (int j=i+1;j<t.size();j++) { // 交换操作
            string u = t; swap(u[i],u[j]);
            int k = stoi(u);  // 转换回整型判重
        }
        // 类似处理删除和插入
    }
}
```

#### 2. 作者：冰糖鸽子（⭐⭐⭐⭐）
**关键亮点**  
① 利用字符串截取函数简化插入/删除操作  
② 预处理时统一答案偏移量（所有结果+1），简化输出逻辑  
③ 使用 `map<string,int>` 实现自然判重

**个人心得摘录**  
> "初始答案设为1而非0，使得不可达状态输出时恰好为-1，简化了边界条件处理"

#### 3. 作者：破忆（⭐⭐⭐⭐）
**关键亮点**  
① 完全基于数字运算（非字符串），性能更优  
② 使用数学方法实现数字截取/合并操作  
③ 通过快速幂预计算10的幂次提升效率

**关键代码片段**  
```cpp
inline int swap(int base, int x, int y) {
    int px = powerOf10(digit(base)-x-1);  // 计算位权
    int nx = get(base,x), ny = get(base,y); 
    return base - nx*px - ny*py + nx*py + ny*px; // 位运算交换
}
```

---

### 最优思路总结
1. **预处理所有状态**：通过单次BFS生成所有可达数字的最小步数，应对多查询场景  
2. **字符串与整型互转**：利用 `to_string/stoi` 简化数位操作，提高代码可读性  
3. **分层BFS扩展**：严格按操作步数分层，保证首次访问即最短路径  
4. **位运算优化**：对纯数字解法，通过预计算10的幂次加速数位操作

---

### 拓展建议
1. **同类题目推荐**  
   - [P1131 潜伏者](https://www.luogu.com.cn/problem/P1131)（BFS状态转换）  
   - [P1126 机器人搬重物](https://www.luogu.com.cn/problem/P1126)（复杂状态BFS）  
   - [P1271 重建道路](https://www.luogu.com.cn/problem/P1271)（树形DP与状态生成）

2. **算法套路延伸**  
   - 当操作步骤具有可逆性时，可尝试双向BFS优化  
   - 若状态空间极大（如10^18），考虑A*启发式搜索或剪枝策略  
   - 类似数位操作问题可优先考虑字符串处理简化代码

---
处理用时：55.67秒
# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



### 综合分析与结论
本题核心是解决无权图的最短路计数问题。所有题解均围绕BFS/SPFA/Dijkstra算法，在松弛过程中维护最短路数量。由于边权为1，BFS是最优解法（时间复杂度O(n)），而SPFA和Dijkstra在此场景下效率略低。关键优化点在于：分层更新计数数组、避免重复计数、正确处理模运算。

---

### 高星题解推荐（评分≥4星）

#### 1. 岸芷汀兰（★★★★★）
**关键亮点**：
- 明确指出无权图特性，采用BFS分层处理，保证每个节点只入队一次
- 正确处理自环和重边（无需特殊处理）
- 代码简洁，使用vector邻接表，可读性强

**核心代码思想**：
```cpp
void bfs() {
    queue<Node> q; 
    q.push(make(1, 0));
    ans[1] = 1;
    while (q.size()) {
        int u = q.front().node; 
        for (auto v : linker[u]) {
            if (!vis[v]) { // 第一次访问
                ans[v] = ans[u];
                q.push(v);
            } else if (dis[v] == dis[u] + 1) { // 同层累加
                ans[v] += ans[u];
            }
        }
    }
}
```

#### 2. ZiDing_ByronFinlso（★★★★☆）
**关键亮点**：
- 提供SPFA和Dijkstra两种实现，对比性能
- 代码规范，包含快速读入优化
- 正确处理松弛时的覆盖和累加逻辑

**SPFA核心逻辑**：
```cpp
while (q.size()) {
    x = q.front(); q.pop();
    for (所有邻接点y) {
        if (d[y] > d[x]+1) { // 松弛成功
            ans[y] = ans[x]; // 覆盖计数
        } else if (d[y] == d[x]+1) { // 找到等长路径
            ans[y] = (ans[y] + ans[x]) % mod; // 累加计数
        }
    }
}
```

#### 3. 神之右大臣（★★★★☆）
**关键亮点**：
- 强调BFS的严格分层特性，避免SPFA的重复入队问题
- 使用双数组分别记录当前层和累计结果，防止覆盖
- 代码包含详细注释，适合新手学习

**个人心得摘录**：
> "BFS的队列中节点距离严格递增，每个节点只需处理一次，天然保证计数正确性，而SPFA需要额外判断重复入队情况"

---

### 关键思路总结
1. **分层计数**：BFS天然分层，首次访问节点时初始化计数，后续同层访问累加。
2. **动态维护**：使用 `dis[]` 数组记录最短路长度，`ans[]` 数组在松弛时更新。
3. **模运算处理**：每次累加操作后立即取模，避免溢出。
4. **数据结构选择**：邻接表存储图，队列使用普通队列而非优先队列。

---

### 推荐相似题目
1. [P1608 路径统计](https://www.luogu.com.cn/problem/P1608)（带权最短路计数）
2. [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)（DAG拓扑排序+计数）
3. [P1144 最短路计数 加强版](https://www.luogu.com.cn/problem/P1144)（同题大数据版，测试优化能力）

---

### 核心代码片段示例（BFS版本）
```cpp
vector<int> g[N];
int dis[N], ans[N], vis[N];

void bfs() {
    queue<int> q;
    q.push(1);
    dis[1] = 0; ans[1] = 1; vis[1] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : g[u]) {
            if (!vis[v]) { // 首次访问
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                vis[v] = 1;
                q.push(v);
            } else if (dis[v] == dis[u] + 1) { // 同层累加
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
}
```

---
处理用时：82.35秒
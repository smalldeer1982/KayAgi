# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果



### 综合分析与结论
本题核心在于枚举所有可能的排列组合与旋转状态，并对每种情况应用6种基础布局计算最小包围矩形。关键难点在于：
1. 正确覆盖所有排列组合（4!×2⁴=384种情况）
2. 精准实现6种布局的几何关系判断
3. 高效去重和结果处理

### 高分题解推荐

#### 1. 七喜（★★★★☆）
**关键亮点**：
- 使用DFS生成排列组合，自然处理旋转状态
- 通过check函数集中处理6种布局情况，逻辑模块化
- alter函数统一处理结果更新，代码复用性高

**核心代码**：
```cpp
void dfs(int yj) {
    if(yj==4) { check(); return; }
    for(int i=1;i<5;i++) if(!vis[i]) {
        tmpx[yj+1]=x[i], tmpy[yj+1]=y[i], vis[i]=1; // 不旋转
        dfs(yj+1);
        tmpx[yj+1]=y[i], tmpy[yj+1]=x[i]; // 旋转
        dfs(yj+1);
        vis[i]=0;
    }
}
```
**个人心得**："每个矩形有横竖两种状态，必须用DFS穷举" —— 强调全状态枚举的重要性

#### 2. Chiesl（★★★★☆）
**关键亮点**：
- 使用结构体存储结果，便于排序去重
- 对第6种布局进行详细分支判断
- 双指针法处理结果输出

**核心判断逻辑**：
```cpp
// 第六种布局的分支判断
if(rw(2) >= rw(1)+rw(3)) x = max(max(rl(0),rl(1)+rl(2)),rl(2)+rl(3));
else if(...) // 其他分支
...
```

#### 3. ChampionCyan（★★★★☆）
**关键亮点**：
- 使用next_permutation处理排列
- 通过order数组管理排列顺序
- 使用set自动去重

**关键结构**：
```cpp
int order[4] = {0,1,2,3};
do {
    work(1); // 处理当前排列
} while(next_permutation(order, order+4));
```

### 最优关键思路
1. **全状态枚举**：通过DFS或排列组合生成所有可能的矩形方向（4!×2⁴种情况）
2. **布局模板化**：将6种基础布局转化为独立计算模块
3. **结果统一处理**：使用集合结构去重，排序后输出

### 拓展训练推荐
1. P1099 树网的核 - 类似的最优覆盖问题
2. P1661 扩散 - 多物体的同步扩展模拟
3. P1502 窗口的星星 - 二维空间中的最优布局

### 相似题目推荐
1. [P1099 树网的核](https://www.luogu.com.cn/problem/P1099) - 几何覆盖问题
2. [P1661 扩散](https://www.luogu.com.cn/problem/P1661) - 多物体扩展模拟 
3. [P1502 窗口的星星](https://www.luogu.com.cn/problem/P1502) - 二维空间布局优化

---
处理用时：63.55秒
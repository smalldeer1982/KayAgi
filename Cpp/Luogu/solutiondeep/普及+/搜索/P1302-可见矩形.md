# 题目信息

# 可见矩形

## 题目描述

给定平面上 $n$ 个互不相交（指公共面积为零）的正方形，它们的顶点坐标均为整数。设坐标原点为 $O(0,0)$。对于任一正方形 $R$，如果可以找到 $R$ 的边上 $2$ 个不同的点 $A$ 和 $B$，使 $\triangle OAB$ 的内部与其他正方形无公共点，则称正方形 $R$ 是从 $O$ 点可见的正方形。

对于给定的 $n$ 个互不相交的正方形，计算从坐标原点 $O$ 可见的正方形个数。

## 样例 #1

### 输入

```
3

2 6 4

1 4 1

2 4 1

```

### 输出

```
3

```

# AI分析结果



### 综合分析与结论
题目本质是判断哪些正方形的斜率区间未被完全覆盖。各题解核心思路都是通过排序确定处理顺序，并维护不可见区间集合。最优解法基于几何排序与区间合并，时间复杂度约为O(nlogn)。

---

### 精选题解（4星及以上）

#### 题解作者：WZWZWZWY（4星）
**关键亮点**：
1. 按`x+y+l`排序确保处理顺序正确性，避免后效性。
2. 使用区间合并维护不可见区域，逻辑清晰高效。
3. 代码结构简洁，可读性强，通过set实现区间动态维护。

**个人心得**：
- 通过分析正方形遮挡规律得出排序依据，强调`x+y+l`的正确性。
- 使用数学推导证明极值斜率来自正方形左上/右下顶点。

**核心代码**：
```cpp
struct squ { 
    int x, y, l;
    double mink, maxk; 
} a[1005];

bool cmp(squ a, squ b) { 
    return a.x + a.y + a.l < b.x + b.y + b.l;
}

set <ks> k; // 存储不可见区间
for (int i = 2; i <= n; i++) {
    // 检查当前区间是否被完全覆盖
    bool covered = false;
    for (auto &interval : k) {
        if (a[i].mink >= interval.lk && a[i].maxk <= interval.rk) {
            covered = true;
            break;
        }
    }
    if (covered) res--;
    else k.insert({a[i].mink, a[i].maxk});
}
```

---

### 最优思路总结
**关键技巧**：
1. **几何排序**：按`x+y+l`升序处理正方形，确保后续正方形不会影响已处理区间。
2. **极值斜率**：取正方形左上角与右下角顶点计算最小/最大斜率。
3. **区间合并**：动态维护不可见区间集合，使用集合操作高效判断覆盖情况。

**拓展应用**：
- 类似遮挡问题可考虑极值点排序与区间覆盖。
- 扫描线算法在几何问题中的应用，如矩形覆盖、光线投射等。

---

### 推荐习题
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886) - 区间极值与单调队列
2. [P2280 激光炸弹](https://www.luogu.com.cn/problem/P2280) - 二维前缀和与几何覆盖
3. [P1496 火烧赤壁](https://www.luogu.com.cn/problem/P1496) - 区间合并经典问题

---
处理用时：61.75秒
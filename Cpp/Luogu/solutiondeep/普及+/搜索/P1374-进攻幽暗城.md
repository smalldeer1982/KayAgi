# 题目信息

# 进攻幽暗城

## 题目背景

由于震惊海内外的 “愤怒门投毒事件” 的发生，部落为了对抗皇家药剂师协会的叛乱，所有的外交工作完成后，部落大酋长萨尔带领着小 A 穿过传送门到达幽暗城平叛。


## 题目描述

幽暗城的地图是一个 $n \times m$ 的 $01$ 串。$a_{i, j} = 1$ 时表示 $(i, j)$ 的位置是障碍，无法通过；$a_{i, j} = 0$ 时表示 $(i, j)$ 的位置可以进入。

小 A 与萨尔的初始位置是 $(x_1, y_1)$，而恐惧魔王的初始位置是 $(x_2, y_2)$。小 A 的目标就是到达恐惧魔王的位置。

萨尔会按照一个特定的路线行走，该路线是一个数字串，由 $0 \sim 4$ 组成。

第 $i$ 秒，若数字串第（$i \bmod {}$数字串的长度）位等于 $0$，则表示这一秒萨尔将会原地不动；   
等于 $1$，则表示这一秒萨尔会向上走一格；   
等于 $2$，则表示这一秒萨尔会向下走一格；   
等于 $3$，则表示这一秒萨尔会向左走一格；   
等于 $4$，则表示这一秒萨尔会向右走一格。

若萨尔将要移动的位置是墙或者超出迷宫的范围，则萨尔会原地不动。恐惧魔王也是这样。（换句话说，你可以认为如果将数字串是重复无限次，第 $i$ 秒就是字符串第 $i$ 位）

小A每秒可以选择从上下左右四个方向中选择一个方向，朝那个方向走一格，前提是那个位置不是墙并且没有超出迷宫的范围；或者原地不动。不过，由于幽暗城的诡异环境，小 A 只能持续脱离萨尔的光环 $s$ 秒，若超过 $s$ 秒小 A 则会死亡。光环的有效半径为 $d$ ，表示当小 A 与萨尔之间的距离 $\sqrt{(x-xx)^2+(y-yy)^2}$ 小于等于 $d$ 时小 A 才能受到萨尔光环的效果。若小 A 脱离萨尔的光环又重新进入光环有效区域，则再次离开光环时持续时间归零重记。

小 A 想知道最少需要几秒他才能到达恐惧魔王所在的位置。

## 说明/提示

**【题目来源】**

kiro 原创

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n,m \le 50$，$0 \le s \le 1000$，$0 \le d \le 100$，$1 \le $ 数字串长度 $ \le 100$，$0 \le $ 答案 $ \le 100$。

## 样例 #1

### 输入

```
3 4 7 3
1010
0000
0101
1 2 3 3
0132401
12131
```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论
本题核心为动态移动路径下的状态搜索，需处理双角色移动规则、光环限制及路径合法性。各题解普遍采用BFS或迭代加深搜索，核心优化点在于预处理移动路径、状态剪枝及高效判重。

### 评分较高题解推荐
#### 1. 作者：world_execute（⭐️⭐️⭐️⭐️⭐️）
**关键亮点**：  
- 预处理萨尔与魔王100秒内的移动路径，避免每次状态扩展重新计算。  
- 使用迭代加深搜索（IDDFS）限制搜索深度，避免无限循环。  
- 代码结构清晰，完整注释，可读性高。  

**核心代码片段**：
```cpp
void Search(int Max_Deep, int now, int nx, int ny, int Leave_Time) {
    if (now > Max_Deep || Leave_Time > s) return;
    if (nx == Lorx[now] && ny == Lory[now]) { // 到达目标
        printf("%d\n", now);
        exit(0);
    }
    for (int i = 0; i < 5; i++) { // 五种移动方向
        int tx = nx + dx[i], ty = ny + dy[i];
        if (非法位置跳过) continue;
        int new_leave = (距离超限) ? Leave_Time+1 : 0;
        Search(Max_Deep, now+1, tx, ty, new_leave);
    }
}
```

#### 2. 作者：wzmzmhk（⭐️⭐️⭐️⭐️）
**关键亮点**：  
- 结构体保存三人坐标及离开时间，完整模拟动态状态。  
- 移动前后两次特判相遇，避免漏解。  
- 采用欧式距离计算与光环判据。  

**个人心得**：  
> "讨论区中有人提到x/y坐标顺序问题，实际需注意题目中x对应行、y对应列，与常规坐标系不同。"

**核心代码片段**：
```cpp
struct coord {
    int Ax, Ay, sx, sy, demx, demy, t, t1;
};
queue<coord> q;

void bfs() {
    while (!q.empty()) {
        coord l = q.front(); q.pop();
        // 移动萨尔和魔王后检查相遇
        if (u.Ax == u.demx && u.Ay == u.demy) { ... }
        // 小A移动后再次检查
        if (Dis(uu.Ax, uu.Ay, uu.sx, uu.sy) <= d) { ... }
    }
}
```

#### 3. 作者：Seauy（⭐️⭐️⭐️⭐️）
**关键亮点**：  
- 使用Taxi几何距离剪枝，提前排除无效状态。  
- 动态计算离开时间，减少冗余判断。  
- 代码简洁，包含可视化调试函数。  

**关键技巧**：  
```cpp
// 出租车距离剪枝
if (Taxi_Dis(now.A, now.Sar) - d > s - now.Out) continue;
```

---

### 最优思路总结
1. **路径预处理**：提前计算萨尔与魔王100秒内的所有位置，避免重复模拟移动。
2. **状态压缩**：结构体保存当前位置、时间、离开时间，结合BFS/IDDFS扩展。
3. **距离优化**：使用欧式距离判断光环范围，Taxi距离辅助剪枝。
4. **特判机制**：移动前后两次检查相遇，确保不漏解。

---

### 相似题目推荐
1. **P1443 马的遍历** - BFS基础训练（[题目链接](https://www.luogu.com.cn/problem/P1443)）
2. **P1126 机器人搬重物** - 动态障碍与方向控制（[题目链接](https://www.luogu.com.cn/problem/P1126)）
3. **P1825 [USACO11OPEN]Corn Maze S** - 多状态迷宫与传送机制（[题目链接](https://www.luogu.com.cn/problem/P1825)）

---
处理用时：62.17秒
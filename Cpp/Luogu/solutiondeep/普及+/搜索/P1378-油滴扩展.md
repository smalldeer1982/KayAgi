# 题目信息

# 油滴扩展

## 题目描述

在一个长方形框子里，最多有 $N$ 个相异的点，在其中任何一个点上放一个很小的油滴，那么这个油滴会一直扩展，直到接触到其他油滴或者框子的边界。必须等一个油滴扩展完毕才能放置下一个油滴。那么应该按照怎样的顺序在这 $N$ 个点上放置油滴，才能使放置完毕后所有油滴占据的总面积最大呢？（不同的油滴不会相互融合）

注：圆的面积公式 $S = \pi r^2$，其中 $r$ 为圆的半径。

## 说明/提示

对于 $100\%$ 的数据，$1 \le N \le 6$，坐标范围在 $[-1000, 1000]$ 内。

## 样例 #1

### 输入

```
2
20 0 10 10
13 3
17 7
```

### 输出

```
50
```

# AI分析结果



### 综合分析与结论
本题核心在于枚举油滴顺序并计算每个油滴的最大扩展半径。由于 n≤6，主流解法采用暴力搜索（全排列/DFS）配合几何计算。关键难点在于处理油滴与边界、已扩展油滴的半径限制，以及浮点精度问题。最优解法通过预处理距离矩阵和合理剪枝提升效率。

#### 高星题解推荐
1. **ylsoi（4.5星）**
   - **核心思路**：DFS回溯+实时半径计算，代码简洁易读，利用`cal()`函数动态计算当前油滴半径。
   - **关键亮点**：维护已选油滴状态，动态更新半径，避免冗余计算。
   - **个人心得**：强调油滴被覆盖时的半径归零处理，避免负数影响。
   ```cpp
   void dfs(int k,double sum) {
     if(k>n) { ansmax=max(ansmax,sum); return; }
     for(int i=1;i<=n;i++) if(!s[i]) {
         r[i]=cal(i); // 计算当前油滴半径
         s[i]=1;
         dfs(k+1,sum+r[i]*r[i]*PI);
         s[i]=0;
     }
   }
   ```

2. **青珹（4星）**
   - **核心思路**：DFS遍历+坐标平移处理负数，通过标记数组管理油滴状态。
   - **关键亮点**：坐标统一平移为正数简化计算，详细注释提升可读性。
   - **代码片段**：
   ```cpp
   void find(int now,double sum) {
     if(now==n+1) { ans=Max(ans,sum); return; }
     for(int i=1;i<=n;i++) if(!b[i]) {
         // 计算半径并处理覆盖情况
         b[i]=1; dfs(now+1,sum+pi*r[i]*r[i]);
         b[i]=0; r[i]=0;
     }
   }
   ```

3. **agicy（4星）**
   - **核心思路**：预处理所有点间距，DFS中快速计算半径。
   - **优化技巧**：预处理距离矩阵减少重复计算，提升运行效率。
   ```cpp
   for(i=1;i<=n;i++) 
     for(j=i+1;j<=n;j++) 
       d[i][j]=d[j][i]=sqrt((x[i]-x[j])^2 + (y[i]-y[j])^2);
   ```

### 关键思路与技巧总结
1. **半径计算模型**：每个油滴的半径取边界距离和已扩展油滴圆心距-半径的最小值。
2. **顺序枚举优化**：DFS回溯法优于全排列，可结合剪枝（如当前面积已无法超越最优解时提前返回）。
3. **浮点精度处理**：使用高精度π值（3.1415926535），结果四舍五入用`(int)(val + 0.5)`。
4. **坐标处理**：将坐标平移至非负区间，避免边界判断错误。

### 拓展题目推荐
1. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706) - 全排列枚举基础训练。
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036) - 组合枚举与剪枝实践。
3. [P1515 计算几何](https://www.luogu.com.cn/problem/P1515) - 几何计算与覆盖问题。

---
处理用时：75.30秒
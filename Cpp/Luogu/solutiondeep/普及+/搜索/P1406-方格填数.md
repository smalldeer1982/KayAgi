# 题目信息

# 方格填数

## 题目描述

给一个 $n\times n$ 的方格矩阵，还有 $n\times n$ 个整数，让你将这些整数填入矩阵，使得每行每列每个对角线上整数的和都相等。下面给出几个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/6m0pbzzu.png)

## 说明/提示

### 数据范围及约定

- 对于 $80\%$ 的数据，保证 $1 \le n \le 3$；
- 对于 $100\%$ 的数据，保证 $1 \le n \le 4$。


## 样例 #1

### 输入

```
3

1 2 3 4 5 6 7 8 9

```

### 输出

```
15

2 7 6

9 5 1

4 3 8



```

# AI分析结果



### 综合分析与结论
本题需在回溯框架下通过剪枝优化处理 $n=4$ 的极端情况，核心思路为：通过预计算每行目标值、排序保证字典序、关键位置剪枝判断、及时终止搜索。各题解均基于DFS，差异主要体现在剪枝时机与代码实现细节。

---

### 精选题解推荐

#### 1. 作者：wzmzmhk（⭐⭐⭐⭐⭐）
**关键亮点**：
- 模块化剪枝逻辑：通过 `judge` 函数统一处理行列及对角线的剪枝判断
- 三目运算符优化递归入口，减少代码冗余
- 使用 `exit(0)` 直接终止程序提升效率

**核心代码**：
```cpp
void dfs(int x, int y) {
    if (x == n + 1) { print(); exit(0); } // 找到解立即终止
    for (int i = 1; i <= n*n; i++) {
        if (t[i] == 0) {
            if (judge(x, y, i)) continue; // 剪枝判断
            t[i] = 1;
            ans[x][y] = a[i];
            y != n ? dfs(x, y+1) : dfs(x+1, 1); // 三目优化递归
            t[i] = 0;
        }
    }
}
```

#### 2. 作者：Mingoal（⭐⭐⭐⭐）
**关键亮点**：
- 动态计算行/列和：在递归参数中携带当前行累计值
- 按列、对角线位置提前剪枝
- 代码简洁高效，实测24ms

**核心剪枝逻辑**：
```cpp
for (int i=1; i<=n*n; i++) {
    if (y==n && z+b[i]!=sum) continue; // 行剪枝
    if (x==n) { // 列剪枝
        int s = 0;
        for (int j=1; j<n; j++) s += a[j][y];
        if (s + b[i] != sum) continue;
    }
}
```

#### 3. 作者：llzzxx712（⭐⭐⭐⭐）
**关键亮点**：
- 一维数组模拟二维存储，通过宏定义 `sft` 转换坐标
- 多维度剪枝（行、列、双对角线）
- 排序后提前终止无效分支

**坐标转换技巧**：
```cpp
#define sft(x,y) ((x-1)*n+y) // 二维转一维
void dfs(int x, int y) {
    b[sft(x,y)] = a[i]; // 使用一维数组存储矩阵
}
```

---

### 关键思路总结
1. **数学预计算**：sum = ∑a[i]/n，所有行列必须满足此值
2. **字典序控制**：输入排序后按序尝试，保证首个解即最小字典序解
3. **分层剪枝**：
   - 行末检查行和
   - 列末检查列和
   - 对角线终点检查对角线
4. **立即终止**：使用 `exit(0)` 而非标志位回溯

---

### 同类题目推荐
1. P1433 - 吃奶酪（回溯剪枝）
2. P1092 - 虫食算（数位约束剪枝）
3. P1074 - 靶形数独（复杂剪枝条件）

---

### 调试经验摘录
> "样例图片未按字典序排列导致多次WA，排序后解决"  
> —— 作者：quest_2  
> **启示**：仔细审题，明确排序维度（数值序 vs 字符串序）

> "使用exit(0)比return快5倍"  
> —— 作者：Mingoal  
> **启示**：找到解后立即终止可避免无效回溯

---
处理用时：72.43秒
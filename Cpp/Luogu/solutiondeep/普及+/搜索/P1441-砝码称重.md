# 题目信息

# 砝码称重

## 题目描述

现有 $n$ 个砝码，重量分别为 $a_i$，在去掉 $m$ 个砝码后，问最多能称量出多少不同的重量（不包括 $0$）。

请注意，砝码只能放在其中一边。

## 说明/提示

【样例说明】

在去掉一个重量为 $2$ 的砝码后，能称量出 $1, 2, 3$ 共 $3$ 种重量。


【数据规模】

对于 $20\%$ 的数据，$m=0$。

对于 $50\%$ 的数据，$m\leq 1$。

对于 $50\%$ 的数据，$n\leq 10$。

对于 $100\%$ 的数据，$n\leq 20$， $m\leq 4$，$m < n$，$a_i\leq 100$。


## 样例 #1

### 输入

```
3 1
1 2 2```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题核心在于枚举保留的砝码组合后统计能构成的重量数。题解主要分为两类：**DFS剪枝+背包DP**与**状态压缩+bitset位运算优化**。前者的优势在于思路直观且剪枝有效，后者利用位运算大幅提升计算效率。最优解法应结合高效的枚举方式与快速的状态合并技巧。

---

### 高分题解精选（评分≥4★）

#### 1. 作者：stfst（5★）
**核心亮点**：  
- 利用二进制枚举子集，通过`bitset`快速合并重量状态  
- 代码极简（仅20行核心逻辑），时间复杂度O(2ⁿ·n)  
- 巧妙使用STL特性，`b |= b << w[j]`实现状态转移  

**核心代码**：
```cpp
bitset<2010> b; // 表示可称出的重量集合
for(int i=0; i<=(1<<n)-1; i++) {
    if(__builtin_popcount(i) == n-m) {
        b.reset(); b[0] = 1;
        for(int j=0; j<n; j++) 
            if(i & (1<<j)) b |= b << w[j];
        ans = max(ans, (int)b.count()-1);
    }
}
```

#### 2. 作者：hsfzLZH1（4.5★）
**核心亮点**：  
- DFS剪枝策略：优先枚举删除而非保留，及时剪枝无效路径  
- 动态维护背包最大值(`tot`变量)，减少DP范围  
- 代码结构清晰，适合教学理解  

**DFS剪枝关键**：
```cpp
void dfs(int cur, int now) { // now:已删除数
    if(now > m) return; // 剪枝1：删除数超额
    if(cur == n) { if(now == m) dp(); return; }
    dfs(cur+1, now); // 不删当前
    tf[cur] = true;  // 删当前
    dfs(cur+1, now+1);
}
```

#### 3. 作者：pantw（5★）
**核心亮点**：  
- 预计算popcount优化枚举效率  
- 极简bitset操作（仅需7行核心逻辑）  
- 兼容C++98标准，避免使用非标函数  

**关键实现**：
```cpp
std::bitset<2010> S;
for(int i=0; i<(1<<n); i++) {
    if(popcount(i) == n-m) {
        S.reset(); S[0] = 1;
        for(int j=0; j<n; j++) 
            if(i & (1<<j)) S |= S << w[j];
        ans = max(ans, (int)S.count()-1);
    }
}
```

---

### 关键优化思路总结
1. **状态压缩**：用二进制位表示砝码选择，结合`bitset`快速合并状态  
2. **剪枝策略**：DFS时优先处理删除操作，及时终止无效分支  
3. **滚动背包**：动态维护当前最大重量，减少DP迭代范围  
4. **位运算加速**：`bitset`的位并行特性大幅提升状态计算效率  

---

### 举一反三训练
1. **P2347 砝码称重**（基础背包+多重组合）  
2. **P2392 背包问题**（状态压缩优化经典题）  
3. **P2831 愤怒的小鸟**（状压DP+几何判断）  

---

### 调试经验摘录
> "在DFS中记录`last`变量避免重复组合，排序后通过`if(w[i] != w[last])`跳过相同元素，将运行时间从1900ms优化至700ms" —— 作者Ch4rc0al  
> **启示**：预处理排序+去重能显著优化搜索效率  

> "原题解状态转移方程错误，应为`f[i][j] = f[i-1][j] | f[i-1][j-a[i]]`，直接使用滚动数组需倒序枚举" —— 作者xiangling  
> **教训**：背包DP的状态转移必须严格推导，避免想当然简化

---
处理用时：73.00秒
# 题目信息

# [NOI1999] 生日蛋糕

## 题目背景

[数据加强版 link](https://www.luogu.com.cn/problem/T148457)

## 题目描述

7 月 17 日是 Mr.W 的生日，ACM-THU 为此要制作一个体积为 $N\pi$ 的 $M$ 层生日蛋糕，每层都是一个圆柱体。

设从下往上数第 $i$（$1 \leq i \leq M$）层蛋糕是半径为 $R_i$，高度为 $H_i$ 的圆柱。当 $i \lt M$ 时，要求 $R_i \gt R_{i+1}$ 且 $H_i \gt H_{i+1}$。

由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积 $Q$ 最小。

请编程对给出的 $N$ 和 $M$，找出蛋糕的制作方案（适当的 $R_i$ 和 $H_i$ 的值），使 $S=\dfrac{Q}{\pi}$ 最小。

（除 $Q$ 外，以上所有数据皆为正整数）

## 样例 #1

### 输入

```
100
2
```

### 输出

```
68```

# AI分析结果



### 综合分析与结论
本题为典型DFS剪枝优化问题，核心挑战在于如何通过多层剪枝减少搜索空间。各题解普遍采用以下优化策略：
1. **预处理最小体积/表面积**：计算各层理论最小体积和侧面积，用于可行性剪枝
2. 上下界剪枝：利用半径/高度的递减特性确定枚举范围
3. 数学推导剪枝：通过体积与表面积的关系估算剩余层最小表面积
4. 搜索顺序优化：倒序枚举半径和高度，更快触发剪枝条件

### 优质题解推荐（评分≥4星）

#### 1. 作者：pyyyyyy（⭐⭐⭐⭐⭐）
**核心亮点**：
- 完整阐述四种关键剪枝策略
- 清晰代码结构配合详细注释
- 引入体积与表面积的数学关系剪枝
- 预处理最小体积/表面积数组

**关键代码**：
```cpp
void dfs(int now,int S,int V,int lasth,int lastr) {
    if(now==0) {
        if(V==n) ans=min(ans,S);
        return;
    }
    if(S+2*(n-V)/lastr>=ans) return; // 数学剪枝
    for(int i=lastr-1;i>=now;--i) {
        if(now==m) S=i*i;
        int Maxh=min((n-V)/i/i, lasth-1);
        for(int j=Maxh;j>=now;--j) {
            dfs(now-1,S+2*i*j,V+i*i*j,j,i);
        }
    }
}
```

#### 2. 作者：Fellyhosn（⭐⭐⭐⭐）
**核心亮点**：
- 创新性体积-表面积转换公式推导
- 三层递进式剪枝结构清晰
- 优化搜索起点（sqrt(n)）

**数学剪枝推导**：
```
剩余表面积 ≥ 2*(剩余体积)/当前半径
当 当前表面积 + 估算最小表面积 ≥ 已知最优解时剪枝
```

#### 3. 作者：碳六灵（⭐⭐⭐⭐）
**核心亮点**：
- 预处理数组命名清晰（minv/mins）
- 倒序搜索（从底层向上）更易确定边界
- 变量命名规范（lasth/lastr）

**调试心得**：
> "发现把一个t打成了t-1导致WA多次，调试时输出中间变量发现枚举层数异常，提醒重要参数需仔细检查"

### 关键优化技巧总结
1. **体积-表面积转换剪枝**：通过公式推导将体积约束转换为表面积约束
2. **倒序枚举策略**：从最大可能值开始枚举，更快触发剪枝条件
3. **层间约束传递**：通过lasth/lastr参数传递上层尺寸，自然形成递减约束
4. **预处理加速**：O(1)时间完成可行性判断

### 扩展练习推荐
1. P1731 [NOI1999] 生日蛋糕（本题）
2. P1120 小木棍（经典DFS剪枝）
3. P1074 靶形数独（复杂状态剪枝）
4. P1464 Function（记忆化搜索+剪枝）

### 关键代码片段（pyyyyyy版）
```cpp
// 预处理最小体积和侧面积
for(int i=1;i<=m;i++) {
    mins[i]=mins[i-1]+2*i*i; // 侧面积
    minv[i]=minv[i-1]+i*i*i; // 体积
}

// 核心DFS函数
void dfs(int now,int S,int V,int lasth,int lastr) {
    if(S+2*(n-V)/lastr>=ans) return; // 数学剪枝
    for(int i=lastr-1;i>=now;--i) {  // 倒序枚举半径
        int Maxh=min((n-V)/i/i, lasth-1);
        for(int j=Maxh;j>=now;--j) { // 倒序枚举高度
            dfs(now-1,S+2*i*j,V+i*i*j,j,i);
        }
    }
}
```

---
处理用时：70.48秒
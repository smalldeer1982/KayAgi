# 题目信息

# 矩形分割

## 题目描述

有一个长为 $a$，宽为 $b$ 的矩形（$1 \le a \le 6$，$2 \le b \le 6$）。可以把这个矩形看作是 $a\times b$ 个小方格。

我们现在接到了这样的一个任务：请你计算出，把这个矩形分割成两个部分的方法总数。

你不是可以任意地分割这个大的矩形，必须满足：

分割后，每个部分，至少各自均有一个方格是在大矩形的最外边上（即大矩形最外面一环的方格）。



## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/buv0992j.png)

## 样例 #1

### 输入

```
3 2```

### 输出

```
15```

# AI分析结果



### 综合分析与结论
各题解核心思路为将矩形分割问题转化为点图的路径搜索问题，通过DFS枚举分割线。关键难点在于处理无效分割（如单边切割）和避免重复计数。打表解法在数据范围小时可行，但通用性不足。最优解法的核心技巧是：将网格转换为点图，通过限制起点（排除顶点）、手动走第一步避免无效分割，DFS搜索到另一边缘点的路径。

---

### 精选题解分析

#### 1. 作者：yyyyyyyf（★★★★★）
**关键亮点**：
- 点图转换思路清晰，预处理起点排除顶点
- 手动走第一步避免无效分割的边界处理
- 代码结构简洁，回溯逻辑明确
**核心代码**：
```cpp
void dfs(int x,int y) {
    vis[x][y]=1;
    if(x==1 || y==m || x==n || y==1) { // 到达边界点
        ans++;
        vis[x][y]=0;
        return;
    }
    for(int i=0;i<4;++i) { // 四方向搜索
        int xx=x+movex[i], yy=y+movey[i];
        if(边界检查) continue;
        dfs(xx,yy);
    }
    vis[x][y]=0;
}
```
**实现思想**：将矩形转为(n+1)*(m+1)的点图，从非顶点的边缘点出发，手动先走一步到内部点，再DFS搜索所有到达另一边缘点的路径。

#### 2. 作者：君玘（★★★★☆）
**关键亮点**：
- 对称性处理（答案除以2避免重复计数）
- 四边统一处理逻辑
**个人心得**：
> "四个角是产生不了分割线的，手动让它往中间走一步"  
> "从一端搜出的线必然会在另一端被重复计算，答案需/2"

#### 3. 作者：SBofGaySchool（★★★☆☆）
**创新思路**：
- 不依赖点图转换，直接枚举边缘填涂情况
- 使用状压+记忆化优化暴力搜索
**独特价值**：当无法想到标准解法时，提供了一种可行的暴力思路

---

### 最优技巧总结
1. **点图转换法**：将格子问题转为点图问题，把分割线视为点之间的路径
2. **起点限制**：只从非顶点的边缘点出发，手动走第一步到内部点
3. **对称处理**：每个分割线会被正反方向计算两次，最终答案需除以2
4. **回溯框架**：标准DFS模板，每次搜索后恢复访问状态

---

### 同类题目推荐
1. **P1817 棋盘分割**（二维区间分割，类似DFS+剪枝）
2. **P4537 [CQOI2007]矩形**（本题双倍经验，数据范围更大需优化）
3. **P1378 能量项链**（环形结构的分割问题，需处理环状边界）

---

### 调试经验摘录
1. 来自骗分过样例：
> "将起点手动移动到内部点后，一定要记得恢复访问状态，否则会漏算"  
> **总结**：回溯时要清除手动设置的访问标记

2. 来自yzh_Error404：
> "打表生成代码中，n和m对应数组索引要仔细验证，否则会WA一片"  
> **总结**：打表时建议用(n-1)*k+(m-2)等公式化索引计算

3. 来自light_ght：
> "been数组必须每次循环重置，否则会累计错误路径"  
> **总结**：多测试用例时需注意全局变量的初始化

---
处理用时：58.54秒
# 题目信息

# 小 K 的农场

## 题目描述

小 K 在 MC 里面建立很多很多的农场，总共 $n$ 个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共 $m$ 个），以下列三种形式描述：  
- 农场 $a$ 比农场 $b$ 至少多种植了 $c$ 个单位的作物；
- 农场 $a$ 比农场 $b$ 至多多种植了 $c$ 个单位的作物；
- 农场 $a$ 与农场 $b$ 种植的作物数一样多。  

但是，由于小 K 的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。  


## 说明/提示

对于 $100\%$ 的数据，保证 $1 \le n,m,a,b,c \le 5 \times 10^3$。

## 样例 #1

### 输入

```
3 3
3 1 2
1 1 3 1
2 2 3 2
```

### 输出

```
Yes
```

# AI分析结果



### 综合分析与结论  
本题为典型的差分约束问题，需将三种约束转化为不等式，构建有向图后通过SPFA检测负环判断解的存在性。所有题解均采用差分约束+SPFA框架，核心差异在于约束转换细节与SPFA优化技巧。关键在于正确建模约束条件并处理图的连通性（如超级源点）。

---

### 高星题解推荐  

#### 1. SDqwq（五星）  
**关键亮点**：  
- 详细推导约束转换过程，解释清晰，适合新手理解差分约束原理。  
- 代码结构规范，变量命名合理，链式前向星建图高效。  
- 明确超级源点的必要性，确保图连通性。  

**代码核心**：  
```cpp
void add(int u, int v, int w) { ... } // 建边函数
// 约束转换：
switch(opt) {
    case 1: add(a, b, -c); // a比b多至少c → a→b权-c
    case 2: add(b, a, c);  // a比b多至多c → b→a权c
    case 3: add双向0边;    // a与b相等
}
// 添加超级源点边：
for(int i=1; i<=n; i++) add(n+1, i, 0);
bool has负环 = !spfa(n+1); // SPFA返回是否有解
```

#### 2. 一只书虫仔（四星）  
**关键亮点**：  
- 用数学公式明确展示约束转换逻辑，推导严谨。  
- 注释详实，代码模块化，突出SPFA判负环的核心逻辑。  
- 附相关题目链接，便于拓展学习。  

**个人心得引用**：  
> "SPFA的递推式与差分约束的不等式形式完美对应，建图后只需判断负环即可。"

#### 3. Stinger（四星）  
**关键亮点**：  
- 使用双端队列SLF优化SPFA，显著提升效率（103ms→500ms+）。  
- 代码简洁，适合需要性能优化的场景。  

**核心优化代码**：  
```cpp
deque<int> q;
if (dis[q.front()] > dis[v]) q.push_front(v); // SLF优化
else q.push_back(v);
```

---

### 关键思路与技巧总结  
1. **约束转换**：  
   - `a-b≥c` → `b→a`边权`-c`  
   - `a-b≤c` → `a→b`边权`c`  
   - `a=b` → 双向0边  
2. **超级源点**：添加虚拟节点连接所有点，确保图的连通性。  
3. **负环检测**：SPFA中记录节点入队次数，超过n次则存在负环。  

---

### 拓展与同类题目推荐  
1. **差分约束基础**：  
   - [P5960](https://www.luogu.com.cn/problem/P5960) 差分约束模板  
   - [P1260](https://www.luogu.com.cn/problem/P1260) 工程规划  

2. **SPFA与负环**：  
   - [P3385](https://www.luogu.com.cn/problem/P3385) 负环检测模板  

3. **图论建模**：  
   - [P2474](https://www.luogu.com.cn/problem/P2474) 天平（差分约束变形）  

--- 

### 代码实现要点  
以SDqwq的代码为例，核心逻辑如下：  
```cpp
bool spfa(int s) {
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (遍历邻接边) {
            if (松弛成功) {
                if (入队次数≥n+1) return false; // 存在负环
                if (!vis[v]) q.push(v);
            }
        }
    }
    return true; // 无负环
}
```

---
处理用时：63.86秒
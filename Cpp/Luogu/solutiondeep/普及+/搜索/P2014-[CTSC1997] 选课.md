# 题目信息

# [CTSC1997] 选课

## 题目描述

在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？


## 样例 #1

### 输入

```
7  4
2  2
0  1
0  4
2  1
7  1
7  6
2  2
```

### 输出

```
13```

# AI分析结果



### 题目分析与结论
本题考察树形DP与背包问题的结合，核心难点在于处理多叉树的依赖关系与资源分配。题解主要围绕以下思路展开：
1. **虚拟根节点技巧**：通过添加虚拟节点0将森林转化为单树，简化问题
2. 树形DP状态设计：`dp[u][j]`表示以u为根的子树选j门课的最大学分
3. **多叉树转二叉树**：利用左儿子右兄弟表示法简化依赖关系
4. **DFS序优化**：通过后序遍历序列实现线性DP
5. **背包问题结合**：在树结构上进行分组背包的状态转移

### 优质题解推荐

#### 1. He_Ren（4.5星）
**核心亮点**：
- 虚拟根节点技巧清晰演示森林转树过程
- 结合01背包思想的三层循环实现简洁
- 代码包含关键优化注释（倒序循环避免重复更新）
```cpp
for(int i=head[u]; i; i=e[i].next) {
    int v = e[i].to;
    for(int j=m; j>0; --j)
        for(int k=0; k<j; ++k)
            dp[u][j] = max(dp[u][j], dp[u][j-k] + dp[v][k]);
}
```

#### 2. Macesuted（4星）
**关键优化**：
- 引入子树大小剪枝，优化时间复杂度至O(NM)
- 记忆化搜索实现树形背包的清晰写法
```cpp
void dfs(int x) {
    for(auto v : G[x]) {
        dfs(v);
        for(int j=min(m,sz[x]);j>=1;j--)
            for(int k=1; k<=min(j-1,sz[v]);k++)
                f[x][j] = max(f[x][j], f[x][j-k]+f[v][k]);
    }
}
```

#### 3. 天泽龟（4星）
**思维突破**：
- 提出将父节点必须选择的特性转化为泛化物品概念
- 明确树形DP与分组背包的对应关系
```cpp
for(int j=m+1;j>=1;j--)
    for(int k=0;k<j;k++)
        f[x][j] = max(f[x][j], f[x][j-k-1] + f[v][k])
```

### 关键技巧总结
1. **虚拟节点技巧**：处理森林问题时添加虚拟根节点（如节点0）
2. **后序遍历DP**：`dp[i] = max(dp[i+size], dp[i+1]+val)`利用DFS序线性处理
3. **左儿子右兄弟**：多叉转二叉时，`l[u]`存第一个子节点，`r[u]`存兄弟节点
4. **倒序背包循环**：避免状态覆盖，确保每个子节点只被处理一次

### 推荐练习题目
1. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015) - 树形DP基础
2. [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273) - 树形背包的扩展
3. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352) - 树形DP经典模型

### 个人心得摘录
> "树形DP的核心是从子节点合并信息。处理时要想象每个子树是一个独立的背包，合并时注意循环顺序避免状态污染" —— He_Ren

> "将树视为递归结构，从叶节点开始向上推导，每个节点的处理都基于已处理的子树" —— Macesuted

> "调试时发现f[x][j]必须初始化为极小值，否则不选节点的情况会影响正确性" —— 天泽龟

---
处理用时：64.19秒
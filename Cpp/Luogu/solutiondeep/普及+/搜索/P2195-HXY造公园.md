# 题目信息

# HXY造公园

## 题目描述

现在有一个现成的公园，有 $n$ 个休息点和 $m$ 条双向边连接两个休息点。众所周知，HXY 是一个 SXBK 的强迫症患者，所以她打算施展魔法来改造公园并即时了解改造情况。她可以进行以下两种操作：

1. 对某个休息点 $x$，查询公园中可以与该点互相到达的休息点组成的路径中的最长路径。
2. 对于两个休息点 $x,y$，如果 $x,y$ 已经可以互相到达则忽略此次操作。否则，在 $x$ 可到达的所有休息点和 $y$ 可到达的所有休息点（包括 $x,y$ 自身）分别选择一个休息点，然后在这两个休息点之间连一条边，并且这个选择应该满足对于连接后的公园，$x$ 和 $y$ 所在的区域（即 $x,y$ 可达到的所有休息点和边组成的集合）中的最长路径的长度最小。

HXY打算进行 $q$ 个操作，请你回答她的对于公园情况的询问（操作 1）或者执行她的操作（操作 2）。

注：所有边的长度皆为 $1$。保证不存在环。最长路径定义为：对于点 $v_1,v_2\cdots v_k$，如果对于其中任意的 $v_i$ 和 $v_{i+1}\quad (1\le i\le k-1)$，都有边相连接，那么 $v_j\quad(1\le j\le k)$ 所在区域的最长路径就是 $k-1$。


## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据，只存在操作 1。
- 对于 $30\%$ 的数据，$1\le m<n\le 20$，$1\le q\le5$。
- 对于 $60\%$ 的数据，$1\le m<n \le 2000$，$1\le q\le 1000$。
- 对于 $100\%$ 的数据，$1 \le m<n \le 3\times 10^5$，$1\le q\le 3\times 10^5$。


## 样例 #1

### 输入

```
6 0 6
2 1 2
2 3 4
2 5 6
2 3 2
2 5 3
1 1```

### 输出

```
4
```

# AI分析结果



### 综合分析与结论  
本题核心为动态维护森林的直径，结合并查集与树的直径性质。各题解均采用以下核心思路：  
1. **预处理直径**：通过两次DFS/BFS或树形DP求初始每棵树的直径  
2. **并查集维护连通性**：合并时用并查集快速判断连通块  
3. **合并策略优化**：连接两树中点，新直径取 `max(原直径最大值, ⌈d1/2⌉+⌈d2/2⌉+1)`  
关键难点在于正确推导合并后的直径公式，并注意需与原直径取最大值避免错误。

---

### 高星题解推荐

#### 题解1. Priori_Incantatem（⭐⭐⭐⭐⭐）  
**关键亮点**：  
- 清晰推导合并公式，强调必须与原直径比较  
- 代码中巧妙使用 `(c[x]+1)>>1` 实现上取整  
- 完整注释说明树形DP求直径过程  
**核心代码**：  
```cpp
void merge(int x, int y) {
    int tmp = ((c[x]+1)>>1) + ((c[y]+1)>>1) + 1;
    c[find(x)] = max(tmp, max(c[x], c[y]));
}
```

#### 题解2. noall（⭐⭐⭐⭐）  
**关键亮点**：  
- 强调避免全量`memset`导致TLE的调试经验  
- 在DFS回溯时局部重置`vis`数组提升效率  
- 详细图示说明中点选择策略  
**调试心得**：  
> "在递归返回时`vis[x]=false`代替`memset`，避免每次初始化整个数组的O(n)开销"

#### 题解3. caozy623（⭐⭐⭐⭐）  
**关键亮点**：  
- 使用两次BFS标准方法求直径，代码结构清晰  
- 合并时显式处理三种可能情况  
- 代码包含完整路径压缩并查集实现  
**核心代码**：  
```cpp
int find(int x) {
    int q[Maxn], head=0, tail=1; // BFS队列实现
    while(...) // 遍历所有节点求最长路径
}
```

---

### 关键思路总结  
1. **数据结构选择**：  
   - 并查集维护连通块，根节点存储该树直径  
   - 预处理时独立计算各初始树的直径  

2. **合并优化公式**：  
   ```math
   new\_d = \max\left(\left\lceil\frac{d_1}{2}\right\rceil + \left\lceil\frac{d_2}{2}\right\rceil + 1, d_1, d_2\right)
   ```  
3. **实现技巧**：  
   - 避免全量初始化数组（如`vis`）  
   - 使用位运算 `(d+1)>>1` 代替上取整计算  

---

### 相似题目推荐  
1. [CF455C Civilization](https://www.luogu.com.cn/problem/CF455C)（本题双倍经验）  
2. [P3304 [SDOI2013] 直径](https://www.luogu.com.cn/problem/P3304)（求直径必经边）  
3. [P4381 [IOI2008] Island](https://www.luogu.com.cn/problem/P4381)（基环树直径综合应用）  

---

### 调试经验摘录  
- **noall**：  
  > "在3e5数据规模下，每次`memset(vis)`会导致O(nq)复杂度，必须改为DFS回溯时局部重置"  
- **walk_alone**：  
  > "合并时必须保持并查集根节点的直径信息更新顺序，先计算新值再修改父节点指针"

---
处理用时：74.94秒
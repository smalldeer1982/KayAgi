# 题目信息

# [SCOI2008] 着色方案

## 题目描述

有 $n$ 个木块排成一行，从左到右依次编号为 $1$ 至 $n$。

你有 $k$ 种颜色的油漆，第 $i$ 种颜色的油漆足够涂 $c_i$ 个木块。

所有油漆刚好足够涂满所有木块，即 $\sum_{i=1}^kc_i=n$。

由于相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。

由于答案可能很大，请输出对 $10^9+7$ 取模的结果。

## 说明/提示

- 对于 $50\%$ 的数据，$1 \leq k \leq 5$，$1 \leq c_i \leq 3$；
- 对于 $100\%$ 的数据，$1 \leq k \leq 15$，$1 \leq c_i \leq 5$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
10```

## 样例 #2

### 输入

```
5
2 2 2 2 2```

### 输出

```
39480```

## 样例 #3

### 输入

```
10
1 1 2 2 3 3 4 4 5 5
```

### 输出

```
85937576```

# AI分析结果



### 综合分析与结论
本题核心难点在于高效表示颜色使用状态并处理相邻限制。最优解法为多维状态DP结合记忆化搜索，将颜色按剩余次数分组，通过记录最后一次使用的颜色类型来避免相邻冲突。

---

### 高星题解推荐

#### 1. Bartholomew（五星）
**关键亮点**：五维状态+last记忆化搜索  
- 状态设计`dp[a][b][c][d][e][last]`表示各剩余次数的颜色数量及上次使用的类型  
- 转移时根据last进行冲突扣除，极大压缩状态空间  
- 代码简洁，可读性强  
**核心代码**：
```cpp
ll DFS(int a,int b,int c,int d,int e,int last){
    if(dp[a][b][c][d][e][last]!=-1) return dp[...];
    ll res = 0;
    if(a) res += (a - (last==2)) * DFS(a-1,b,c,d,e,1);
    // 类似处理b,c,d,e的转移
    return dp[...] = res % MOD;
}
```

#### 2. 逃离地球（四星）
**关键亮点**：系统分析多种解法  
- 详细阐述组合数学DP、容斥、FFT优化等多种思路  
- 提供清晰的数学推导，具有较高拓展价值  
**核心思路**：  
- 算法四通过二项式反演计算恰好0个相邻的方案  
- 预处理组合数后用背包式转移，复杂度O(n²)

#### 3. Log_x（四星）
**关键亮点**：状态转移方程清晰  
- 与Bartholomew思路一致但注释更详尽  
- 使用`long long`防溢出，代码鲁棒性强  
**个人心得**：  
> "颜色种类不重要，重要的是剩余次数，这样状态数被压缩到可接受范围"

---

### 关键思路与技巧
1. **状态压缩**：将颜色按剩余次数（1-5次）分组，避免记录具体颜色  
2. **冲突处理**：通过`last`参数记录上次颜色类型，在转移时扣除冲突情况  
3. **记忆化搜索**：自然处理多维状态转移，避免迭代DP的复杂顺序问题  
4. **组合优化**：当颜色数较多时，可结合容斥原理或FFT加速计算  

---

### 推荐练习题目
1. [P2704 炮兵阵地](https://www.luogu.com.cn/problem/P2704)（状态压缩DP）  
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)（记忆化搜索+状态压缩）  
3. [P3959 宝藏](https://www.luogu.com.cn/problem/P3959)（多维状态DP+剪枝）

---
处理用时：57.86秒
# 题目信息

# [ZJOI2012] 旅游

## 题目描述

到了难得的暑假，为了庆祝小白在数学考试中取得的优异成绩，小蓝决定带小白出去旅游~~

经过一番抉择，两人决定将 T 国作为他们的目的地。T 国的国土可以用一个凸 $n$ 边形来表示，$n$ 个顶点表示 $n$ 个入境/出境口。T 国包含 $n-2$ 个城市，每个城市都是顶点均为 $n$ 边形顶点的三角形（换而言之，**城市组成了关于 T 国的一个三角剖分**）。**两人的旅游路线可以看做是连接 $n$ 个顶点中不相邻两点的线段**。

![](https://cdn.luogu.com.cn/upload/pic/1409.png) 

为了能够买到最好的纪念品，小白希望旅游路线上经过的城市尽量多。作为小蓝的好友，你能帮帮小蓝吗？

## 说明/提示

对于 $20\%$ 的数据，$n\le 2000$。

对于 $100\%$ 的数据，$4\le n \le 200000$。

## 样例 #1

### 输入

```
6

1 2 4

2 3 4

1 4 5

1 5 6```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
题目核心是建立三角剖分的对偶图（树结构），求树的最长路径（直径）。各题解主要围绕以下关键点展开：
1. **建图方式**：用map/unordered_map存储三角形的邻接边，将共享边的三角形连边
2. **算法选择**：两次DFS/BFS求树直径
3. **优化关键**：通过排序顶点保证边的唯一性，避免重复建边

### 高星题解推荐（≥4★）
#### 1. Dr_Gears（4.5★）
**关键亮点**：
- 清晰证明树结构的正确性
- 代码中巧用三元组排序避免重复建边
- 采用链式前向星存图保证效率
**核心代码思想**：
```cpp
// 排序顶点后存入map
sort(a[i]+1,a[i]+4);
if(!ys[pair<int,int>(p,q)]) ys[...] = i;
else add(i, ys[...]);
// 两次DFS求直径
dfs(1,0); // 第一次找最远点
dfs(root,0); // 第二次计算深度
```

#### 2. Equfix（4★）
**关键亮点**：
- 详细图示解释树结构
- 独立实现map存储逻辑
- 完整注释关键步骤
**核心实现**：
```cpp
sort(a, a+3); // 必须排序保证边唯一性
if(mapt[make_pair(a,b)]) 
    add_edge对应三角形;
// BFS求直径部分
int bfs()两次调用获取最长路径
```

#### 3. Yingluosanqian（4★）
**优化亮点**：
- 用long long合并顶点对代替pair，提升哈希效率
- 使用unordered_map替代map优化常数
- 完整保留链式存图结构
```cpp
// 将边转化为long long存储
tmp=ip[0]*1e6 + ip[1]; 
if(M.count(tmp)) add_edge;
```

### 关键思路与技巧总结
1. **树结构转换**：将共享边的三角形视为相邻节点，利用三角剖分无环性形成树
2. **高效建边**：对三角形的三个边进行排序后存储，确保边表示唯一性
3. **直径求法**：两次DFS/BFS的时间复杂度O(n)最优
4. **哈希优化**：用数值型键值替代结构体提升存取效率

### 拓展训练推荐
1. [P5536 核心城市](https://www.luogu.com.cn/problem/P5536) - 树的直径性质应用
2. [P4408 逃学的小孩](https://www.luogu.com.cn/problem/P4408) - 树直径的变形问题
3. [P3629 巡逻](https://www.luogu.com.cn/problem/P3629) - 树直径的综合应用

### 题解中的启示录
1. **调试经验**：Dr_Gears强调顶点排序是避免建边错误的关键（"少写了3个if+else"的教训）
2. **优化意识**：Yingluosanqian通过long long合并坐标解决map效率问题
3. **思维突破**：多篇题解指出"看似几何问题，实则是树论问题"的转化思路
4. **STL使用**：PanH提醒map在不开O2时可能超限，需注意常数优化

---

**核心模板代码参考**（以Dr_Gears版为例）：
```cpp
void add(int x,int y) {
    e[++cur] = (edg){head[x],y}; // 链式前向星
    head[x] = cur;
}

for(int i=1; i<=n-2; i++) {
    sort三角形顶点;
    for 三条边 {
        if(map存在边) add邻接三角形;
        else 存入map;
    }
}

// 求直径模板
void dfs(int u,int fa) {
    if(dis[u] > maxd) { maxd = dis[u]; pos = u; }
    for(所有邻接点v) {
        if(v != fa) dfs(v,u);
    }
}
```

---
处理用时：57.13秒
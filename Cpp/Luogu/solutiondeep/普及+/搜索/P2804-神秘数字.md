# 题目信息

# 神秘数字

## 题目背景

在公元XXXX年，侦探小明收到了组织的神秘信息，在Y市的某个地方有一道神秘的门。小明到达了那个门后，发现门上有一行字：“这个门需要密码才能解锁。”小明左找右找，终于找到了一张字条：“现在给你n个数，请你求出这n个数里面，有多少个连续的数的平均数大于某个给定的数M？注意：这个数可能会很大，请输出这个数对92084931取模的结果。最终的结果即是这个门的密码。”小明苦思冥想了半天，但始终找不到答案。于是他来求助于你。请你帮他解决这个问题。由于小明十分着急，他最多只能等1秒。


## 题目描述

给定n个数，请你帮助小明求出里面有多少个连续的数的平均数大于给定的某个数M.并将这个方案数输出。注意：这个数可能会很大，所以请输出这个数对92084931取模的结果。


## 说明/提示

【样例解释】

①对于这4个数，问题的解有{5}，{4}，{5,4}，{1,5,4}，{5,4,2}共5组。

②对于这4个数，问题的解有{5}，{7}，{2,7}，{7,3}，{5,2,7}，{5,2,7,3}共6组。

【数据规模】

对于10%的数据，1＜n≤10.

对于30%的数据，1＜n≤1000.

对于50%的数据，1＜n≤30000.

对于100%的数据，1＜n≤200000，1＜M≤3000，每个数均为正整数且不大于5000.


## 样例 #1

### 输入

```
4 3
1 5 4 2```

### 输出

```
5```

## 样例 #2

### 输入

```
4 4
5 2 7 3```

### 输出

```
6```

# AI分析结果



### 综合分析与结论
题目核心是将平均数问题转换为前缀和数组的顺序对计数。各题解主要采用归并排序、树状数组、权值线段树三种方法，核心思路一致但实现方式不同。归并排序法通过分治策略高效统计顺序对，树状数组法则结合离散化处理负数与大数，权值线段树则直接维护值域。

---

### 精选题解及评分

#### 1. 作者：cabasky ⭐⭐⭐⭐⭐
**关键亮点**：  
- 将问题转化为逆序对统计，通过降序归并排序巧妙统计顺序对数目  
- 代码简洁高效，无需离散化，时间复杂度稳定O(n log n)  
**核心代码**：  
```cpp
int merge(int l, int mid, int r){
    int p1=l, p2=mid+1, k=l-1;
    while(p1<=mid && p2<=r){
        if(sum[p1]<sum[p2]){ // 左半元素 < 右半元素时统计
            ans += (mid-p1+1); // 左半剩余元素均形成顺序对
            temp[++k] = sum[p2++]; 
        } else {
            temp[++k] = sum[p1++];
        }
    }
    // 合并剩余元素...
}
```
**个人心得**：  
作者通过反向思考，在归并时按降序排列，使得统计左半剩余元素数即可得到顺序对数目。此实现方式避免了离散化的复杂度。

#### 2. 作者：JackMerryYoung ⭐⭐⭐⭐⭐  
**关键亮点**：  
- 明确顺序对计算逻辑，归并排序正向实现  
- 代码结构清晰，注释完整便于理解  
**核心代码**：  
```cpp
void merge(int l, int r) {
    // 合并逻辑与cabasky类似，但变量命名更清晰
    if(sum[lp] < sum[rp]) {
        ans += (mid - lp + 1); // 统计顺序对
        tmp[++p] = sum[rp++];
    } else {
        tmp[++p] = sum[lp++];
    }
}
```

#### 3. 作者：StupidSeven ⭐⭐⭐⭐  
**关键亮点**：  
- 将原数组反转，将顺序对转换为逆序对  
- 利用树状数组标准逆序对模板实现  
**核心代码**：  
```cpp
// 反转前缀和索引后统计逆序对
for(int i=1;i<=n+1;i++) num[i].idx = n-i+2; 
sort(num+1, num+n+2); // 离散化后插入树状数组
ans = (ans + i - Query(num[i].idx)) % Mod; // 逆序对数目即原顺序对
```

---

### 关键思路总结
1. **问题转换**：将每个数减去M，求前缀和数组的顺序对数目（i<j且sum[i]<sum[j]）。  
2. **高效统计**：  
   - **归并排序**：通过降序合并，统计左半剩余元素数。  
   - **树状数组**：离散化后动态维护元素出现次数，查询比当前值小的元素数。  
3. **离散化技巧**：处理负数与大数，常用排序去重后二分映射。

---

### 拓展与相似题目
1. **逆序对基础**：  
   - [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)  
2. **前缀和转换**：  
   - [P2717 寒假作业](https://www.luogu.com.cn/problem/P2717)（平均数问题）  
3. **树状数组应用**：  
   - [CF1042D Subarray Sums](https://codeforces.com/problemset/problem/1042/D)（区间和小于给定值）  

---

### 举一反三
- **类似套路**：当遇到区间和/平均数相关条件时，可尝试转换为前缀和数组的二元关系问题（如顺序对、逆序对）。  
- **数据结构选择**：大数据量优先考虑分治（归并），带更新操作则考虑树状数组/线段树。

---
处理用时：194.85秒
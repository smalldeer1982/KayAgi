# 题目信息

# [USACO15DEC] Switching on the Lights S

## 题目背景

来源：usaco-2015-dec

Farm John 最近新建了一批巨大的牛棚。这些牛棚构成了一个 $N \times N$ 的矩形网络 $(1 < N < 100)$。

然而 Bessie 十分怕黑，他想计算可以把多少个牛棚的灯打开。

## 题目描述

有 $N \times N$ 个房间，组成了一张 $N \times N$ 的网格图，Bessie 一开始位于左上角 $(1,1)$，并且只能上下左右行走。


一开始，只有 $(1,1)$ 这个房间的灯是亮着的，Bessie 只能在亮着灯的房间里活动。


有另外 $M$ 条信息，每条信息包含四个数 $a,b,c,d$，表示房间 $(a,b)$ 里有房间 $(c,d)$ 的灯的开关。


请计算出最多有多少个房间的灯可以被打开。

## 说明/提示

Bessie 可以使用 $(1,1)$ 的开关打开 $(1,2),(1,3)$ 的灯，然后走到 $(1,3)$ 并打开 $(2,1)$ 的灯，走到 $(2,1)$ 并打开 $(2,2)$ 的灯。$(2,3)$ 的开关无法到达。因此可以点亮 $5$ 个房间。

## 样例 #1

### 输入

```
3 6
1 1 1 2
2 1 2 2
1 1 1 3
2 3 3 1
1 3 1 2
1 3 2 1
```

### 输出

```
5```

# AI分析结果



### 综合分析与结论
本题核心在于动态处理「开灯」与「可达性」的相互影响，需确保新开灯的房间若与已访问区域连通则立即加入搜索。主流解法采用BFS/DFS结合状态维护，部分题解通过多次遍历或队列分层处理确保不漏解。关键难点在于及时将新开灯的可达房间加入搜索队列。

---

### 高分题解推荐

#### 1. JMercury（5星）
**关键亮点**：  
- 使用类SPFA队列分层处理，同时维护「灯状态」与「可达性」  
- 在开灯后检查四周已访问区域，动态更新队列  
- 代码简洁高效，逻辑清晰  

**核心代码思想**：  
```cpp
void spfa() {
    queue<P> q; 
    q.push({1,1}); 
    vis[1][1] = MAP[1][1] = true;
    while (!q.empty()) {
        P u = q.front(); q.pop();
        // 处理相邻可达点
        for (移动方向) if (相邻点未访问且灯亮) 加入队列;
        // 处理当前点控制的开关
        for (auto v : 当前点的开关列表) {
            if (!MAP[v.x][v.y]) {
                MAP[v.x][v.y] = true; ans++;
                // 检查新开灯点四周是否有已访问点
                for (移动方向) 
                    if (存在相邻已访问点) 加入队列并标记访问;
            }
        }
    }
}
```

#### 2. vani_prcups（4星）
**关键亮点**：  
- DFS结合即时触发机制，开灯后检查周围是否连通  
- 使用二维邻接表优化开关存储  
- 代码结构清晰，递归逻辑紧凑  

**核心技巧**：  
```cpp
void dfs(int x, int y) {
    v[x][y] = 1; // 标记访问
    // 处理当前点所有开关
    for (开关链表遍历) {
        if (目标灯未亮) {
            点亮并计数;
            if (目标灯四周有已访问点) dfs(目标灯坐标); 
        }
    }
    // 尝试扩展四个方向
    for (移动方向) 
        if (相邻点灯亮且未访问) dfs(相邻点);
}
```

#### 3. BoAn（4星）
**关键亮点**：  
- 多次DFS直到无新增，确保处理延迟可达的灯  
- 使用临时队列存储中间状态，避免重复搜索  
- 思路直观，适合理解动态更新过程  

**核心机制**：  
```cpp
while (ans != last_ans) { // 直到两次结果相同
    last_ans = ans;
    重置访问标记;
    DFS(1,1); // 重新搜索可能新增的路径
    统计新结果;
}
```

---

### 最优关键思路总结
1. **状态分层处理**：将「灯已开」与「房间可达」分离维护，优先处理可达性再更新灯光状态  
2. **动态队列扩展**：每当新开灯时，检查其四周是否与已访问区域连通，若连通立即加入搜索队列  
3. **多次遍历保险**：对于可能延迟连通的场景（如先开灯后建路），采用多次搜索确保稳定性  

---

### 类似题目推荐
1. P2895 [USACO08FEB]Meteor Shower S（动态地图BFS）  
2.  P1135 奇怪的电梯（状态空间搜索）  
3. P3956 棋盘（带条件的状态转移）  

---

### 题解个人心得摘录
- **Dirt**：  
  > "所求的是能打开的灯数量而非能到达的点数量，之前因此WA"  
  → **教训**：仔细审题，明确统计目标  

- **LDlornd**：  
  > "被卡因未处理新开灯点与旧路径的连通性"  
  → **关键**：开灯后必须检查四周已访问区域  

- **chenxuanting**：  
  > "使用三维状态标记（0未开灯/1已访问开灯/2未访问开灯）"  
  → **优化**：通过状态细分提升逻辑清晰度

---
处理用时：72.70秒
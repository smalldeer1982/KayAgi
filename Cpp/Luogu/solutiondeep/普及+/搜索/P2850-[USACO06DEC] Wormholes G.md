# 题目信息

# [USACO06DEC] Wormholes G

## 题目背景

[英文题面见此链接](https://www.luogu.com.cn/paste/mxuf6zpl)

## 题目描述

John 在他的农场中闲逛时发现了许多虫洞。虫洞可以看作一条十分奇特的有向边，并可以使你返回到过去的一个时刻（相对你进入虫洞之前）。

John 的每个农场有 $m$ 条小路（无向边）连接着 $n$ 块地（从 $1 \sim n$ 标号），并有 $w$ 个虫洞。

现在 John 希望能够从某块地出发，走过一条路径回到出发点，且同时也回到了出发时刻以前的某一时刻。请你告诉他能否做到。

## 说明/提示

#### 样例 2 解释

John 只需要沿着 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$ 的路径一直转圈即可，每转完一圈，时间就会减少一秒。

#### 数据范围与约定

对于 $100\%$ 的数据，$1 \le T \le 5$，$1 \le n \le 500$，$1 \le m \le 2500$，$1 \le w \le 200$，$1 \le p \le 10^4$。

## 样例 #1

### 输入

```
2
3 3 1
1 2 2
1 3 4
2 3 1
3 1 3
3 2 1
1 2 3
2 3 4
3 1 8```

### 输出

```
NO
YES```

# AI分析结果



### 综合分析
题目本质是判断图中是否存在负权环。各题解主要围绕 SPFA 判负环、Floyd 全源最短路、Bellman-Ford 松弛次数三种思路展开。DFS 版 SPFA 在判负环时效率最高，Floyd 代码最简洁但时间复杂度过高，BFS 版 SPFA 需记录入队次数。最优解法的核心在于高效检测负环，重点在于选择合适的数据结构与终止条件。

---

### 精选题解与评分

#### 1. wjy666 题解（★★★★☆）
**核心亮点**：  
- 使用 DFS 版 SPFA 快速检测负环，递归中遇到重复访问节点立即返回  
- 每个节点作为起点独立检测，保证覆盖所有可能  
- 代码结构清晰，利用 vector 存图易于理解  

**关键代码**：
```cpp
void spfa(int k) { 
    if (fl[k]==1) { fl[k]=0; flag=1; return; } 
    fl[k]=1; 
    for (auto e : mp[k]) 
        if (sum[e.nex] > e.dis + sum[k]) {
            sum[e.nex] = e.dis + sum[k];
            spfa(e.nex); 
            if(flag) return;
        }
    fl[k]=0; 
}
```
**实现思想**：递归遍历时维护访问标记，若某节点在递归栈中被二次访问即存在负环。

#### 2. kczno1 题解（★★★★☆）
**核心亮点**：  
- 提出 DFS 判环的理论依据（路径重复即存在环）  
- 初始距离设为 0 的优化，加速负环检测  
- 使用前向星存图节省空间  

**关键代码**：
```cpp
void dfs(int x) {
    if(vis[x]) { flag=1; return; }
    vis[x] = 1;
    for(Edge e : edges[x]) {
        if(dis[e.to] > dis[x] + e.w) {
            dis[e.to] = dis[x] + e.w;
            dfs(e.to);
            if(flag) return;
        }
    }
    vis[x] = 0;
}
```
**实现思想**：所有节点初始距离设为 0，仅负权边能触发松弛，极大减少无效计算。

#### 3. 动态WA 题解（★★★☆☆）
**核心亮点**：  
- Bellman-Ford 的简洁实现，适合理解算法本质  
- 无需复杂数据结构，适合边数较少的情况  

**关键代码**：
```cpp
bool bellman(){
    for(int i=1; i<=h; i++)
        if(d[e[j].x] + e[j].v < d[e[j].y]) 
            return true;
    return false;
}
```
**不足**：时间复杂度 O(NM) 在本题数据边缘，可能超时。

---

### 关键思路总结
1. **DFS SPFA 判环**：利用递归栈检测重复访问节点，时间复杂度最优  
2. **初始距离归零**：针对负环特性优化，跳过正权边的无效松弛  
3. **多起点检测**：通过遍历所有起点或建立超级源点（虚拟节点连接所有点）确保全覆盖  
4. **前向星存图**：高效处理稀疏图，节省内存空间  

---

### 拓展建议
- **同类型题推荐**：  
  1. [P3385 负环模板](https://www.luogu.com.cn/problem/P3385)  
  2. [P2868 观光奶牛](https://www.luogu.com.cn/problem/P2868)（分数规划+负环）  
  3. [P3199 最小圈](https://www.luogu.com.cn/problem/P3199)（有向图最小环）  

- **调试技巧**：  
  - 对拍时构造链式负环和分散负环两种极端数据  
  - 使用 `memset(dis,0)` 初始化可快速验证负环检测逻辑  
  - 在递归版 SPFA 中加入递归深度限制防止栈溢出  

- **优化方向**：  
  - 结合 Tarjan 算法预处理强连通分量，仅在 SCC 内检测负环  
  - 使用双端队列优化 BFS 版 SPFA 的入队顺序

---
处理用时：87.60秒
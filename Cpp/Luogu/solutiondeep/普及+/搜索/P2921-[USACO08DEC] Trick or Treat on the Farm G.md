# 题目信息

# [USACO08DEC] Trick or Treat on the Farm G

## 题目描述

每年，在威斯康星州，奶牛们都会穿上衣服，收集农夫约翰在 $N(1\le N\le 100,000)$ 个牛棚隔间中留下的糖果，以此来庆祝美国秋天的万圣节。

由于牛棚不太大，FJ 通过指定奶牛必须遵循的穿越路线来确保奶牛的乐趣。为了实现这个让奶牛在牛棚里来回穿梭的方案，FJ 在第 $i$ 号隔间上张贴了一个 “下一个隔间：$next_i(1\le next_i\le N)$” 的标语，告诉奶牛要去的下一个隔间。这样，为了收集它们的糖果，奶牛就会在牛棚里来回穿梭了。

FJ 命令奶牛 $i$ 应该从 $i$ 号隔间开始收集糖果。如果一只奶牛回到某一个她已经去过的隔间，她就会停止收集糖果。

在被迫停止收集糖果之前，计算一下每头奶牛要前往的隔间数（包含起点）。

## 样例 #1

### 输入

```
4 
1 
3 
2 
3 
```

### 输出

```
1 
2 
2 
3 
```

# AI分析结果



### 综合分析与结论
本题核心为处理单出度有向图的环结构，各题解围绕环的检测与路径长度计算展开。最优解法需利用每个点出度唯一的特性，通过颜色标记、时间戳或记忆化搜索高效处理，避免复杂算法。非递归遍历与DFS回溯是最高效的两种思路，Tarjan缩点虽正确但冗余，拓扑排序适用于预处理链结构。

---
### 高星题解精选

#### 1. cjrsacred的非递归解法（⭐⭐⭐⭐⭐）
**关键亮点**：  
- **双标记法**：用`color`标记路径起点，`dfn`记录步数，通过判断颜色一致性检测环  
- **入环时间戳**：区分环内外的贡献，计算总步数时只需`入环步数+环大小`  
- **时间复杂度O(n)**：每个点至多遍历两次，无递归栈开销

**核心代码思想**：
```cpp
for(int cow=1; cow<=n; ++cow) {
    for(int i=cow, cnt=0; ; i=nxt[i], ++cnt) {
        if(!color[i]) { // 首次访问
            color[i] = cow;
            dfn[i] = cnt;
        } else if(color[i] == cow) { // 发现环
            minc[cow] = cnt - dfn[i]; // 环大小
            cout << cnt << endl;
            break;
        } else { // 进入其他路径的环
            cout << minc[color[i]] + max(0, sucdfn[color[i]] - dfn[i]) << endl;
            break;
        }
    }
}
```

#### 2. 一剑缥缈的DFS回溯法（⭐⭐⭐⭐）
**关键亮点**：  
- **回溯标记环**：发现环时逆向标记环上节点，避免重复计算  
- **记忆化优化**：非环节点答案继承后继节点值+1  
- **代码简洁**：仅需DFS函数与两个标记数组

**调试心得**：  
> "TLE后发现需要标记回溯路径，用`vis`数组动态维护访问状态，避免全局memset"

**核心代码思想**：
```cpp
int dfs(int now,int nowc) {
    if(h[now]) return nowc-1 + h[now]; // 已计算
    if(vis[now]) { // 发现环
        h[now] = nowc - s[now];
        int v = now;
        do { // 回溯标记环
            h[v] = h[now];
            v = to[v];
        } while(v != now);
        return nowc-1;
    }
    vis[now] = 1; s[now] = nowc;
    int res = dfs(to[now], nowc+1);
    if(!h[now]) h[now] = h[to[now]] + 1; // 非环节点继承
    vis[now] = 0; // 回溯
    return res;
}
```

#### 3. 万弘的拓扑排序法（⭐⭐⭐⭐）
**关键亮点**：  
- **拓扑预处理链**：去除所有非环节点，剩余环直接计算大小  
- **记忆化搜索链节点**：拓扑序处理后，链节点答案=后继答案+1  
- **无需复杂数据结构**：仅用入度数组和队列实现

**核心代码**：
```cpp
void topo() {
    queue<int> q;
    for(int i=1; i<=n; i++) 
        if(!din[i]) q.push(i);
    while(!q.empty()) { // 去除所有链节点
        int u = q.front(); q.pop();
        if(--din[to[u]] == 0) q.push(to[u]);
    }
}
void calc(int u) { // 处理环
    int cnt=1, t=to[u];
    while(t != u) cnt++, t=to[t];
    f[u] = cnt; // 环大小
}
```

---
### 关键技巧总结
1. **环检测优化**：利用单出度特性，通过步数差直接计算环大小，避免传统算法开销  
2. **路径贡献分离**：将答案分解为`入环步数 + 环大小`，分别处理环内外节点  
3. **记忆化传递**：非环节点答案继承其后继节点值，实现O(n)复杂度  
4. **回溯标记法**：发现环时逆向标记，避免重复访问  

---
### 举一反三训练
1. [NOIP2015 信息传递](https://www.luogu.com.cn/problem/P2661)（最小环检测）  
2. [USACO12JAN Bovine Alliance](https://www.luogu.com.cn/problem/P3040)（基环树计数）  
3. [SCOI2012 滑雪](https://www.luogu.com.cn/problem/P2573)（拓扑排序+路径统计）

---
处理用时：81.80秒
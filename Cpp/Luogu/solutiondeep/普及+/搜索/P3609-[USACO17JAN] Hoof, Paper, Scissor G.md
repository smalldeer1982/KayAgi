# 题目信息

# [USACO17JAN] Hoof, Paper, Scissor G

## 题目背景

*本题与 [银组同名题目](/problem/P6120) 在题意上一致，唯一的差别在于对变手势次数的限制。*


## 题目描述

你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。

“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。

现在 FJ 和 Bassie 要进行 $N$ 轮对抗。Bassie 已经预测了 FJ 每一轮要出的手势。然而 Bassie 很懒，她最多只想变换 $K$ 次手势。

现在请你帮 Bassie 求出她最多能赢多少轮。

## 样例 #1

### 输入

```
5 1
P
P
H
P
S```

### 输出

```
4
```

# AI分析结果



### 综合分析与结论
本题核心为动态规划，通过状态设计记录当前轮次、变换次数及手势，结合手势胜负关系求解最大胜利次数。关键难点在于高效处理手势变换次数与状态转移的优化。最优解法采用三维DP，时间复杂度O(NK)，空间可通过滚动数组优化。

---

### 精选题解

#### 1. 作者：zgf519orz（5星）
**关键亮点**  
- 状态定义清晰：`f[i][j][k]`表示前i轮变换j次且手势为k时的最大胜利次数。
- 优化转移思路：将O(N²K)优化为O(NK)，通过仅考虑前一状态避免枚举历史轮次。
- 前缀和思想：预处理每轮的胜负情况，简化累计计算。

**核心代码**  
```cpp
for(int i=1;i<=n;i++){
    for(int j=0;j<=m;j++){
        f[i][j][0] = max(f[i-1][j][0] + h[i], 
                        max(f[i-1][j-1][1], f[i-1][j-1][2]) + h[i]);
        // 类似处理其他手势
    }
}
```

#### 2. 作者：Del_Your_Heart（4星）
**关键亮点**  
- 滚动数组优化：减少空间占用至O(K)，适合大N场景。
- 模运算简化判断：通过`(x+1)%3 == y`直接判断胜负关系，代码更简洁。
- 状态转移紧凑：结合手势变换与胜利条件，逻辑清晰。

**核心代码**  
```cpp
for(int j=k;j>=0;j--)
    for(int v=2;v>=0;v--)
        if((v+1)%3 == o)  // 胜负判断
            dp[j][v] = max(dp[j][v], max(dp[j+1][(v+1)%3], dp[j+1][(v+2)%3]) + 1);
```

#### 3. 作者：2017gangbazi（4星）
**关键亮点**  
- 记忆化搜索实现：更符合直觉，适合递归思维。
- 状态剪枝优化：通过`j`限制变换次数，避免无效状态扩展。

**核心代码**  
```cpp
int dfs(int x,int b,int w) {
    if(x>n) return 0;
    int p=dp(x-1,b,w);
    if(b>0) 
        p=max(p, max(dfs(x-1,b-1,0), max(dfs(x-1,b-1,1), dfs(x-1,b-1,2))));
    return p + (w==s[x]);
}
```

---

### 关键思路与技巧
1. **三维状态设计**：核心为`f[i][j][k]`，分别表示轮次、变换次数和手势。
2. **滚动数组优化**：减少空间复杂度，适用于N较大的场景。
3. **模运算简化判断**：将手势胜负关系转化为数学公式，提升代码简洁性。
4. **记忆化搜索剪枝**：通过限制变换次数避免无效递归分支。

---

### 拓展与相似题目
1. **编辑距离（LeetCode 72）**：状态设计类似，记录操作次数与字符串位置。
2. **打家劫舍 II（LeetCode 213）**：环形DP，需处理首尾状态转移。
3. **赛车（LeetCode 818）**：结合速度与位置变化的状态DP。

推荐洛谷题目：
- P1352 没有上司的舞会（树形DP）
- P1048 采药（01背包变种）
- P1433 吃奶酪（状压DP）

---
处理用时：75.00秒
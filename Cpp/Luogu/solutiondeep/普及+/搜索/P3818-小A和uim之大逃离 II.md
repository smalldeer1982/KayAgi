# 题目信息

# 小A和uim之大逃离 II

## 题目背景

话说上回……还是参见 <https://www.luogu.com.cn/problem/P1373> 吧

小 a 和 uim 再次来到雨林中探险。突然一阵南风吹来，一片乌云从南部天边急涌过来，还伴着一道道闪电，一阵阵雷声。刹那间，狂风大作，乌云布满了天空，紧接着豆大的雨点从天空中打落下来，只见前方出现了一个牛头马面的怪物，低沉着声音说：“呵呵，既然你们来到这，两个都别活了！”。小 a 和他的小伙伴再次惊呆了！


## 题目描述

瞬间，地面上出现了一个 $H$ 行 $W$ 列的巨幅矩阵，矩阵的每个格子上要么是空地 `.` 或者障碍 `#`。

他们起点在 $(1,1)$，要逃往 $(H,W)$ 的出口。他们可以一次向上下左右移动一格，这个算一步操作。不过他们还保留着上次冒险时收集的魔液，一口气喝掉后可以瞬移到相对自己位置的 $(D,R)$ 向量；也就是说，原来的位置是 $(x,y)$，然后新的位置是 $(x+D,y+R)$，这个也算一步操作，不过他们仅能至多进行一次这种操作（当然可以不喝魔液）。

这个地方是个是非之地。所以他们希望知道最小能有几步操作可以离开这个鬼地方。不过他们可能逃不出这个鬼地方，遇到这种情况，只能等死，别无他法。


## 说明/提示

样例解释 $1$

$(1,1) \to (1,2)\to (1,3)\to$ 喝魔液 $\to (3,4)\to (3,5)\to (3,6)$。

样例解释 $2$

因为只有一瓶魔液所以他们没办法逃出来。

样例解释 $3$

$D$ 和 $R$ 还可以是 $0$或者负数。

数据范围与约定

$40\%$ 的测试数据 $2\leq H,W\leq 5$。

$70\%$ 的测试数据 $2\leq H,W\leq 100$。

$100\%$ 的测试数据 $2\leq H,W\leq 1000,|D|<H,|R|<W$。

## 样例 #1

### 输入

```
3 6 2 1
...#..
..##..
..#...```

### 输出

```
5
```

## 样例 #2

### 输入

```
3 7 2 1
..#..#.
.##.##.
.#..#..```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 6 -2 0
.#....
.#.#..
.####.
.#..#.
.##.#.
....#.```

### 输出

```
21```

# AI分析结果



### 综合分析与结论
本题核心在于BFS处理带状态转移的最短路问题。所有题解均采用三维状态（坐标+是否使用瞬移）进行BFS，区别在于状态转移的实现细节与代码结构优化。其中双向BFS、双向预处理等思路提供了更优的时间复杂度可能，但三维状态BFS仍为最直观且普适性最强的解法。

---

### 高星题解推荐（评分≥4星）

#### 1. [作者：x_faraway_x] ⭐⭐⭐⭐
**关键亮点**：
- **三维状态建模**：通过`step[x][y][0/1]`清晰区分是否使用瞬移的状态。
- **分层处理转移**：在普通移动后，若未使用瞬移则追加瞬移转移，逻辑简洁。
- **代码规范**：结构清晰，使用结构体`Point`管理队列节点。

**核心代码**：
```cpp
struct Point { int x,y,u; }; // u表示是否用过瞬移
queue<Point> Q;
// BFS核心转移逻辑
for(int i=0; i<4; i++) {
    int x = dx[i]+f.x, y=dy[i]+f.y;
    if (valid(x,y) && st[x][y][f.u]==-1) {
        Q.push({x,y,f.u});
        st[x][y][f.u] = st[f.x][f.y][f.u]+1;
        // 未使用瞬移时尝试瞬移
        if (f.u==0 && check(x+d,y+r) && st[x+d][y+r][1]==-1) {
            Q.push({x+d,y+r,1});
            st[x+d][y+r][1] = st[x][y][0]+1;
        }
    }
}
```

#### 2. [作者：AuCloud] ⭐⭐⭐⭐
**关键亮点**：
- **双向BFS优化**：预处理起点和终点的单源最短路，枚举瞬移点组合计算最优解。
- **数学化建模**：将瞬移视为连接两个图的边，通过`dis1[i][j] + dis2[i+d][j+r] + 1`计算总步数。

**核心思路**：
```cpp
// 预处理起点和终点的最短路
bfs(1,1,dis1); 
bfs(h,w,dis2);
// 枚举所有瞬移点组合
for(int i=1; i<=h; i++)
    for(int j=1; j<=w; j++)
        if (valid(i,j) && dis1[i][j]!=-1 && dis2[i+d][j+r]!=-1)
            ans = min(ans, dis1[i][j] + dis2[i+d][j+r] + 1);
```

#### 3. [作者：amstar] ⭐⭐⭐⭐
**关键亮点**：
- **显式状态分离**：通过`v[x][y][0/1]`严格区分访问状态，避免重复。
- **队列设计优化**：独立处理普通移动与瞬移的入队逻辑，增强可读性。

**核心代码**：
```cpp
while (!q.empty()) {
    auto cur = q.front(); q.pop();
    // 普通移动
    for (int i=0; i<4; i++) {
        int xx = cur.x+dx[i], yy=cur.y+dy[i];
        if (valid(xx,yy) && !v[xx][yy][cur.flag]) {
            v[xx][yy][cur.flag] = true;
            q.push({xx, yy, cur.step+1, cur.flag});
        }
    }
    // 瞬移（仅未使用时触发）
    if (cur.flag==0 && valid(x+d,y+r) && !v[x+d][y+r][1]) {
        q.push({x+d, y+r, cur.step+1, 1});
        v[x+d][y+r][1] = true;
    }
}
```

---

### 关键思路总结
1. **三维状态BFS**：通过增加状态维度（是否使用瞬移）实现状态空间扩展。
2. **分层转移逻辑**：先处理常规移动，再在未使用瞬移时生成瞬移后的新状态。
3. **双向预处理优化**：通过双向BFS减少搜索空间，适用于大规模网格。

---

### 拓展与同类题目
1. **状态分层BFS**：类似问题如P1126 机器人搬重物（方向+速度状态）、P1379 八数码（状态哈希）。
2. **瞬移/传送机制**：P1825 [USACO11OPEN]Corn Maze S（传送门机制）。
3. **双向BFS应用**：P1379 八数码难题、P1032 字变换。

**推荐练习**：
1. **P1379 八数码难题**（状态哈希+BFS）
2. **P1126 机器人搬重物**（多维状态BFS）
3. **P1825 Corn Maze S**（传送门机制BFS）

---

### 个人心得摘录
1. **数组大小陷阱**：amstar提到数组开小导致RE，强调根据数据范围（如负坐标）合理设计数组。
2. **终点合法性检查**：AuCloud指出需特判终点是否为障碍物，避免无效搜索。
3. **状态剪枝**：x_faraway_x在入队时立即更新步数，确保首次访问即为最短路径。

---
处理用时：77.46秒
# 题目信息

# 肮脏的牧师

## 题目背景

@Yumis 出题人在这里哦~


## 题目描述

Yumis最近在玩炉石传说。

在炉石传说中脏牧有一张一费卡片（一费就是使用要消耗1点法力水晶），叫做疯狂药水，这个的效果是将一个敌方场上攻击小于等于2的随从拉到自己的战场内。

还有一张四费卡片叫做暗影狂乱，这个的效果是将一个敌方场上攻击小于等于3的随从拉到自己的战场内。

还有一张一费卡片就是缩小药水，这个的效果是将敌人全场的随从攻击力下降3点。


你PY了炉石的GM所以你有了无数张的这三种卡片，但是GM告诉你缩小药水是这个牌比较不好创建，为了为GM着想你必须在使用**最少的缩小药水**的情况下A爆对手的脸。


现在你的对手场上有n个随从，每个随从的攻击力是ki点。

你的对手有m点血量。


而你现在要做的就是将敌方的场上的随从拉过来自己的场上并攻击对手（每一个随从只能攻击一次，攻击力为你拉过来的时候随从剩余的攻击力），A爆对面的脸（将对面的血打到0点及以下）。


## 说明/提示

样例说明1：

敌方场上有3只随从，敌方有5点血量

我们把3攻随从和2攻随从拉过来花费0个缩小药水和5点耗费（一张疯狂药水一个暗影狂乱（1+4 = 5））伤害足够击杀对方。


样例说明2：

使用16个缩小药水（下面数据后面第一个括号指拉过来的时候伤害为多高 ，第二个括号表示拉过来的时候使用多少的缩小药水）

拿10（1）（3）、20（2）（6）、30（3）（9）、50（2）（16）攻的怪物总共造成8点伤害 刚好A爆！



Easy : 保证 0 < n <= 10  并且不存在用到暗影狂乱和缩小药水的情况    20%


Normal ：保证 0 < n <= 10  并且不存在用到缩小药水的情况           20%


Hard ：保证 0 < n <= 10                                                 30%


Extra：保证0 <= n <= 5000000(6个0)，最大攻击力小于30000                  30%


保证 0 < n <= 5000000     0 < ki <=30000    0<=m<=5000000 (6个0)


## 样例 #1

### 输入

```
3 5
1 2 3 
```

### 输出

```
0 5```

## 样例 #2

### 输入

```
8 8
10 20 30 40 50 60 70 80
```

### 输出

```
16 23```

## 样例 #3

### 输入

```
8 80
10 20 30 40 50 60 70 80
```

### 输出

```
Human Cannot Win Dog```

# AI分析结果



### 题解综合分析结论
各题解核心思路均为贪心策略结合排序优化，核心差异体现在数据结构选择与溢出处理细节。最优解法需满足：
1. **桶排序处理大数据**：应对500w数据规模时桶排序效率显著优于快速排序。
2. **分层缩小策略**：按每层缩小药水效果（+3攻击阈值）批量处理随从，统计各层可拉取的1/2/3攻随从数量。
3. **费用最小化调整**：优先返还高费用低性价比（3攻）的随从，再处理低费高性价比（1/2攻）的溢出伤害。

### 高星题解推荐
#### 1. 题解作者：Yumis（★★★★☆）
**关键亮点**：
- **桶排序高效处理大数据**，直接按攻击值分桶，避免常规排序耗时。
- **分层统计攻击类型**：通过遍历每3点攻击区间，累加各层1/2/3攻随从数量。
- **三阶段溢出调整**：优先剔除3攻随从（费用最高），再处理1攻（性价比最低），最后2攻。
  
**代码核心逻辑**：
```cpp
for (int i = 1; i+2 <= 30001; i +=3) { // 按每层缩小药水效果遍历
    ans += to[i] + to[i+1]*2 + to[i+2]*3; // 累加当前层伤害
    if (ans >= m) break; // 达到伤害阈值时停止
}
// 调整多余伤害
while (ans >= m+3 && at3) { ans -=3; at3--; } // 优先还3攻
while (ans >= m+1 && at1) { ans -=1; at1--; } // 其次还1攻
while (ans >= m+2 && at2) { ans -=2; at2--; } // 最后还2攻
```

#### 2. 题解作者：AirCnt（★★★★☆）
**关键亮点**：
- **模3分组优化**：将随从攻击力按模3余数分组，统一处理同类攻击。
- **动态调整缩小次数**：通过预计算缩小药水次数，直接定位到最优缩小层数。
  
**核心代码片段**：
```cpp
int clac(int x, int num) { // 处理缩小后的攻击力并计数
    x -= cnt * 3; // cnt为已用缩小药水次数
    if (x > 3) { // 需额外缩小
        int new_cnt = (x - (x % 3 ? x % 3 : 3)) / 3; // 计算所需缩小次数
        cnt += new_cnt; // 更新总缩小次数
    }
    used[x % 3] += num; // 按模3余数分组
    return x * num;
}
```

### 关键思路总结
1. **桶排序优先**：针对大数据量（ki≤3e4）使用桶排序，时间复杂度降至O(n)。
2. **攻击分层处理**：将攻击力按每3点分层，批量计算各层可贡献的伤害。
3. **费用贪心调整**：伤害溢出时，按费用高低（3攻>1攻>2攻）顺序返还随从。
4. **模运算简化计算**：通过模3快速定位缩小后的等效攻击值，减少重复计算。

### 同类题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子** - 贪心+优先队列，类似费用最小化思想。
2. **P3817 小A的糖果** - 贪心策略处理相邻元素约束，与攻击调整类似。
3. **P1223 [JSOI2007] 书架** - 桶排序优化大规模数据排序问题。

---
处理用时：90.08秒
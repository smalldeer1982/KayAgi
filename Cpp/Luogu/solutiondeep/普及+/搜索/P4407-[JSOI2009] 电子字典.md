# 题目信息

# [JSOI2009] 电子字典

## 题目描述


人们在英文字典中查找某个单词的时候可能不知道该单词的完整拼法，而只知道该单词的一个错误的近似拼法，这时人们可能陷入困境，为了查找一个单词而浪费大量的时间。带有模糊查询功能的电子字典能够从一定程度上解决这一问题：用户只要输入一个字符串，电子字典就返回与该单词编辑距离最小的几个单词供用户选择。

字符串 $a$ 与字符串 $b$ 的编辑距离是指：允许对 $a$ 或 $b$ 串进行下列“编辑”操作，将 $a$ 变为 $b$ 或 $b$ 变为 $a$，最少“编辑”次数即为距离。

1. 删除串中某个位置的字母；
2. 添加一个字母到串中某个位置；
3. 替换串中某一位置的一个字母为另一个字母。

JSOI 团队正在开发一款电子字典，你需要帮助团队实现一个用于模糊查询功能的计数部件：对于一个待查询字符串，如果它是单词，则返回 $-1$；如果它不是单词，则返回字典中有多少个单词与它的编辑距离为 $1$。

## 说明/提示

### 样例解释

- `abcd` 在单词表中出现过；
- `abc` 与单词 `abcd`、`aabc` 的编辑距离都是 $1$；
- `abcdd` 与单词 `abcd`、`abcde`、`abced` 的编辑距离都是 $1$。

### 数据范围与约定

- 所有单词互不相同，但是查询字符串可能有重复；
- 对 $50\%$ 的数据范围，$N,M\le 10^3$；
- 对 $100\%$ 的数据范围，$N,M\le 10^4$。

## 样例 #1

### 输入

```
4 3
abcd
abcde
aabc
abced
abcd
abc
abcdd```

### 输出

```
-1
2
3```

# AI分析结果



### 综合分析与结论
本题核心在于高效处理字符串编辑距离为1的查询。题解主要分两类：**Trie树DFS搜索**与**哈希预处理**。Trie方法通过DFS模拟三种编辑操作，复杂度取决于字典树深度；哈希法暴力枚举所有可能的编辑情况并预处理，空间换时间。优化关键在于去重和剪枝。

### 高星题解推荐
#### 1. 作者：Utsuji_risshū（★★★★★）
**关键亮点**：  
- **Trie树DFS统一处理三种操作**，通过`f`标记控制编辑次数，逻辑清晰。  
- **去重机制**：用`vis`数组记录已访问节点，避免重复计数。  
- **代码简洁**：合并添加和替换的枚举逻辑，减少冗余代码。  
**核心代码思想**：  
```cpp
void DFS(int rt, int l, bool f) {
    // 基础匹配与终止条件处理
    if (!f) {
        // 删除当前字符（l+1跳过当前字符）
        if (l < len) DFS(rt, l+1, 1);
        // 枚举所有可能的添加/替换操作
        for (int i=0; i<26; ++i) {
            if (Trie[rt][i]) {
                DFS(Trie[rt][i], l, 1);      // 添加
                if (i != c) DFS(...);        // 替换（排除原字符）
            }
        }
    }
    // 正常匹配逻辑
}
```
**个人心得**：在题解评论区提到“替换字母不能和后一位字符相同”的细节，避免无效操作。

#### 2. 作者：Iscream2001（★★★★☆）
**关键亮点**：  
- **哈希预处理所有编辑情况**，利用多个哈希表分类存储删除、添加、替换后的子串。  
- **离散化去重**：排序后去重哈希值，减少重复查询。  
- **数学优化**：通过前缀哈希和后缀哈希快速计算中间修改。  
**核心代码思想**：  
```cpp
// 预处理删除操作的哈希
for (int j=1; j<=len; ++j) 
    h[j] = l[j-1] * bin[len-j] + r[j+1];
// 查询时统计三类哈希的命中次数
ans += b[len-1][j][h[j]]; // 删除
ans += a[len-1][h[j]];    // 添加
ans += c[len][l[len]];    // 替换
```

#### 3. 作者：Cry_For_theMoon（★★★★☆）
**关键亮点**：  
- **分治式DFS**：将删除、添加、替换拆分为独立DFS函数，逻辑更易调试。  
- **剪枝优化**：在替换时跳过原字符，删除时检查后续字符匹配。  
**核心代码思想**：  
```cpp
void dfs1(...) { /* 处理删除 */ }
void dfs2(...) { /* 处理添加 */ }
void dfs3(...) { /* 处理替换 */ }
```

### 关键思路与技巧总结
1. **Trie树DFS剪枝**：通过递归参数控制编辑次数，结合哈希路径匹配避免暴力枚举。  
2. **哈希离散化**：预处理所有可能的编辑结果，利用排序去重降低查询复杂度。  
3. **去重机制**：无论是Trie的`vis`数组还是哈希排序，核心在于避免重复统计同一单词的不同编辑路径。

### 相似题目推荐
1. [P1688 单词接龙](https://www.luogu.com.cn/problem/P1688) - 编辑距离扩展  
2. [P2922 Secret Message](https://www.luogu.com.cn/problem/P2922) - Trie树前缀匹配  
3. [P3763 DNA](https://www.luogu.com.cn/problem/P3763) - 允许错误匹配的字符串计数  

### 调试经验摘录
- **Cry_For_theMoon**提到“修改后的字符不能是本来这一位的字符”，否则等价于未修改。  
- **Utsuji_risshū**在注释中强调“vis数组要在完全匹配时更新”，避免误判前缀节点。  
- **creation_hy**指出“必须重置vis数组”，否则不同查询间会产生干扰。

---
处理用时：56.57秒
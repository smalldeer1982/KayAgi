# 题目信息

# [BJOI2018] 求和

## 题目描述

master 对树上的求和非常感兴趣。他生成了一棵有根树，并且希望多次询问这棵树上一段路径上所有节点深度的 $k$ 次方和，而且每次的 $k$ 可能是不同的。此处节点深度的定义是这个节点到根的路径上的边数。他把这个问题交给了 pupil，但 pupil 并不会这么复杂的操作，你能帮他解决吗？

## 说明/提示

### 样例解释

以下用 $d (i)$ 表示第 $i$ 个节点的深度。

对于样例中的树，有 $d (1) = 0, d (2) = 1, d (3) = 1, d (4) = 2, d (5) = 2$。

因此第一个询问答案为 $(2^5 + 1^5 + 0^5) \bmod 998244353 = 33$，第二个询问答案为$(2^{45} + 1^{45} + 2^{45}) \bmod 998244353 = 503245989$。

### 数据范围

对于 $30\%$ 的数据，$1 \leq n,m \leq 100$。

对于 $60\%$ 的数据，$1 \leq n,m \leq 1000$。

对于 $100\%$ 的数据，$1 \leq n,m \leq 300000$，$1 \leq k \leq 50$。

另外存在 5 个不计分的 hack 数据。

### 提示

数据规模较大，请注意使用较快速的输入输出方式。

## 样例 #1

### 输入

```
5
1 2
1 3
2 4
2 5
2
1 4 5
5 4 45```

### 输出

```
33
503245989```

# AI分析结果



### 综合分析与结论
题目本质是树上的路径查询问题，核心解法围绕LCA展开。所有题解均采用以下核心思路：
1. **预处理前缀和**：维护每个节点到根的k次方和（O(nk)预处理）
2. **LCA分解路径**：将路径和转化为两个到根路径之和减去公共部分
3. **取模优化**：处理负数取模时先加模数再取模

### 高分题解推荐（≥4星）

#### 1. shadowice1984（⭐⭐⭐⭐⭐）
**关键亮点**：
- 采用倍增LCA实现，时空复杂度最优（O(nlogn + nk)预处理，O(1)查询）
- 公式推导清晰：`ans = val[u][k] + val[v][k] - val[lca][k] - val[fa[lca]][k]`
- 代码简洁高效，包含快速IO优化提示

**核心代码片段**：
```cpp
// 预处理部分
for(int j=1;j<=50;j++) 
    val[v][j] = (mi[j] + val[u][j])%mod;

// 查询公式
ans = (val[u][k] + val[v][k] + 2*mod 
      - val[fa[l][0]][k] - val[l][k])%mod;
```

#### 2. 米奇奇米（⭐⭐⭐⭐）
**关键亮点**：
- 使用更易理解的倍增LCA模板
- 包含完整的公式推导图示说明
- 预处理时采用显式幂次计算，便于理解

**核心思想**：
```cpp
// 前缀和公式推导
ans = pre[u][k] + pre[v][k] 
    - pre[lca][k] - pre[fa[lca]][k];
```

#### 3. NaCly_Fish（⭐⭐⭐⭐）
**关键亮点**：
- 采用树链剖分实现LCA
- 包含预处理时的深度修正细节
- 显式处理LCA重复计算的边界情况

**调试经验引用**：
> "注意进行减法运算时，结果有可能小于0，+p再模p就好了"

### 关键思路总结
1. **树上差分公式**：
   ```math
   ans = sum(u) + sum(v) - sum(lca) - sum(fa[lca])
   ```
2. **预处理优化**：对1~50次方分别维护前缀和数组
3. **负数取模技巧**：`(a - b + MOD) % MOD`

### 举一反三练习
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P3258 松鼠的新家](https://www.luogu.com.cn/problem/P3258)（树上差分应用）
3. [P4211 LNOI2014]LCA](https://www.luogu.com.cn/problem/P4211)（深度相关区间查询）

### 特别提醒
**易错点**：所有题解均强调取模时负数处理。如某题解所述：
> "进行减法运算时，结果有可能小于0，+p再模p就好了"

建议在代码中统一使用：
```cpp
ans = (a - b + MOD) % MOD;
```
而非直接取模，以避免出现负数结果。

---
处理用时：50.62秒
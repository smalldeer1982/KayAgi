# 题目信息

# [CQOI2007] 三角形

## 题目描述

画一个等边三角形，把三边的中点连接起来，得到四个三角形，把它们称为 $T_1,T_2,T_3,T_4$，如图1。

把前三个三角形也这样划分，得到 $12$ 个更小的三角形，$T_{11},T_{12},T_{13},T_{14},T_{21},T_{22},T_{23},T_{24},T_{31},T_{32},T_{33},T_{34}$，如图2。

把编号以 $1,2,3$ 结尾的三角形又继续划分……最后得到的分形称为 Sierpinski 三角形。

![](https://cdn.luogu.com.cn/upload/pic/18501.png)

如果三角形 $B$ 不包含三角形 $A$，且 $A$ 的某一条完整的边是 $B$ 的某条边的一部分，则我们说 $A$ 靠在 $B$ 的边上。例如 $T_{12}$ 靠在 $T_{14}$ 和 $T_4$ 上，但不靠在 $T_{32}$ 上。

给出 Spierpinski 三角形中的一个三角形，找出它靠着的所有三角形。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 50$。

## 样例 #1

### 输入

```
T312```

### 输出

```
T314
T34
T4```

# AI分析结果



### 题解综合分析结论

各题解核心思路均围绕三角形编号的递归结构与相邻关系展开，核心解法可归纳为两类：**逐层递推法**（正序/倒序处理每一位字符）与**递归方向标记法**。其中，倒序处理首次出现数字的方法在代码简洁性与效率上表现最优。

---

### 精选高分题解（评分≥4星）

#### 1. 作者：xiaozeyu（5星）
**关键亮点**：
- **倒序处理+标记去重**：倒序遍历字符，仅处理每个数字首次出现的位置，生成对应层级的相邻三角形，时间复杂度优化至O(n)。
- **提前终止机制**：当所有方向均已找到时提前退出，减少冗余计算。
- **代码简洁高效**，逻辑清晰易懂。

**核心代码**：
```cpp
for(int j=len-1;j>0;j--) {
    if(!flag[a[j]-'0']) {
        cout<<前缀+"4"<<endl;
        flag[a[j]-'0']=true;
    }
    if(flag[1]&&flag[2]&&flag[3]) break;
}
```

#### 2. 作者：RedreamMer（4星）
**关键亮点**：
- **逐位方向记录**：正序处理字符，记录每个数字对应的相邻三角形方向。
- **特判末尾4**直接生成三个相邻编号，逻辑直观。

**核心代码**：
```cpp
for(int i=1; i<=len; i++) {
    if(s[i]=='1') ss[0]=前缀+"4"; //下边
    else if(s[i]=='2') ss[1]=前缀+"4"; //右边
    else if(s[i]=='3') ss[2]=前缀+"4"; //左边
}
sort后输出非空结果
```

#### 3. 作者：iorit（4星）
**关键亮点**：
- **正推+动态剪枝**：遍历时动态删除不符合条件的三角形，确保结果正确。
- **利用分形层级性质**，结合字符串操作实现高效判断。

---

### 最优思路提炼与代码实现
**关键技巧**：
1. **末尾4特判**：若输入以4结尾，直接输出前三位+1/2/3。
2. **倒序首次标记**：从后向前遍历字符，仅处理每个数字第一次出现的位置，生成对应层级的4结尾三角形，确保不重复且覆盖所有可能相邻情况。

**完整核心代码**：
```cpp
string s;
bool flag[5] = {0};
cin >> s;
if(s.back() == '4') {
    cout << 修改末尾为1/2/3的三种情况;
    return;
}
for(int i = s.size()-1; i > 0; --i) {
    char c = s[i];
    if(!flag[c-'0']) {
        string ans = s.substr(0, i) + "4";
        cout << ans << endl;
        flag[c-'0'] = true;
    }
    if(flag[1] && flag[2] && flag[3]) break;
}
```

---

### 拓展与相似题目推荐
1. **分形结构**：[P1498 南蛮图腾](https://www.luogu.com.cn/problem/P1498)（递归绘制分形）
2. **字符串递归分解**：[P1010 幂次方](https://www.luogu.com.cn/problem/P1010)（递归表达式构建）
3. **坐标变换与分形**：[P1227 分形之城](https://www.luogu.com.cn/problem/P1227)（分形中的坐标计算）

---

### 题解中的个人心得摘录
- **xiaozeyu**：  
  > "一个三角形相邻的三角形中，最后的数字永远不会重复，这是重点，最后只会是1,2,3,4，且每个最多一次"  
  → 通过观察分形规律发现关键性质，避免无效计算。

- **AE酱**：  
  > "递归地找即可，方向标记法需要维护三个边的状态"  
  → 调试中发现方向标记需细致处理递归层级间的状态传递。

---
处理用时：79.96秒
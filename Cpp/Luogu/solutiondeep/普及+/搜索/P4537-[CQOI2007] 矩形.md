# 题目信息

# [CQOI2007] 矩形

## 题目描述

给一个a\*b矩形，由a\*b个单位正方形组成。你需要沿着网格线把它分成非空的两部分，每部分所有格子连通，且至少有一个格子在原矩形的边界上。“连通”是指任两个格子都可以通过水平或者竖直路径连在一起。 求方案总数。例如3*2的矩形有15种方案。

![](https://cdn.luogu.com.cn/upload/pic/18502.png)

## 样例 #1

### 输入

```
3 2```

### 输出

```
15```

# AI分析结果



### 综合分析与结论
题目要求在矩形中寻找满足条件的连通分割线，本质是统计从边界出发到达另一边的路径数。关键点在于理解分界线的连通性要求和边界接触条件。题解主要采用DFS暴搜（适合小数据）和插头DP（通用但复杂）两种思路，其中对称性剪枝是重要优化手段。

---

### 精选题解与评分

#### 1. hhoppitree（★★★★☆）
**关键亮点**：  
- 将原问题转化为(n+1)×(m+1)网格图上的路径统计，思路清晰  
- 代码简洁易懂，通过DFS枚举所有可能路径  
- 正确性有保障，直接对应题目要求的边界条件  

**核心实现**：  
```cpp
void dfs(int x,int y){
    if(x==0 || y==0 || x==n || y==m) ans++;
    else {
        vis[x][y] = 1;
        for(四方向移动) if(!vis[新坐标]) dfs(新坐标);
        vis[x][y] = 0;
    }
}
```

#### 2. panyf（★★★★☆）  
**关键亮点**：  
- 利用对称性优化，减少50%搜索量  
- 处理奇偶情况严谨，代码效率显著提升  
- 注释清晰，代码风格简洁  

**核心优化**：  
```cpp
for(int i=1; i+i<a; i++){ // 只枚举前一半
    dfs(i,1); 
    ans *= 2; // 对称部分直接乘2
}
if(a是奇数) 单独处理中间行 // 补充中间未被计算的路径
```

#### 3. crashed（★★★★☆）  
**关键亮点**：  
- 插头DP解法，展示高阶算法思路  
- 详细解释状态设计（3类插头、边界计数）  
- 适合作为扩展学习，解决更大规模数据  

**状态设计**：  
- 用4进制记录插头类型（普通路径端点、边界端点）  
- 额外维度记录已使用的边界端点数量（0/1/2）  

---

### 关键思路总结
1. **网格图转化**：将原a×b方格转化为(a+1)×(b+1)的网格点，分割线转化为点之间的路径  
2. **对称性剪枝**：仅遍历半数起点，结果乘2后处理中间情况，减少50%计算量  
3. **插头DP扩展**：用连通性状态压缩处理更大数据，状态包含路径类型和边界接触情况  

---

### 拓展与相似题目
1. **P1790 矩形分割**（双倍经验，完全一致）  
2. **P1817 棋盘分割**（插头DP应用，连通性统计）  
3. **P2285 地砖铺设**（网格路径计数，需状态压缩）  

---

### 核心代码片段
**DFS+对称性优化（panyf版）**：  
```cpp
for(int i=1; i<=b/2; i++){ // 只枚举一半
    memset(vis,0,sizeof(vis));
    vis[0][i] = 1;
    dfs(1,i); // 起点在左边界
    ans += 2 * cnt; // 对称点方案相同
}
if(b%2) dfs(1,b/2+1); // 处理奇数列中间
```

**插头DP状态转移（crashed版）**：  
```cpp
// 处理边界端点连接
if(当前是边界格子){
    if(插头类型为普通路径端点){
        更新状态为边界端点，计数器+1
    }
}
// 普通格子连接两个插头
else if(左、上均有插头){
    合并连通块，避免形成环路
}
```

---
处理用时：71.29秒
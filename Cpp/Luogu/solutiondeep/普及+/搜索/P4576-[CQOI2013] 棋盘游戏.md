# 题目信息

# [CQOI2013] 棋盘游戏

## 题目描述

一个n*n（n>=2）棋盘上有黑白棋子各一枚。游戏者A和B轮流移动棋子，A先走。

 * A的移动规则：只能移动白棋子。可以往上下左右四个方向之一移动一格。
 
 * B的移动规则：只能移动黑棋子。可以往上下左右四个方向之一移动一格或者两格。
 
和通常的“吃子”规则一样，当某游戏者把自己的棋子移动到对方棋子所在的格子时，他就赢了。

两个游戏者都很聪明，当可以获胜时会尽快获胜，只能输掉的时候会尽量拖延时间。你的任务是判断谁会赢，需要多少回合。


比如$n=2$，白棋子在$(1,1)$，黑棋子在$(2,2)$，那么虽然A有两种走法，第二个回合B总能取胜。

## 说明/提示

$n<=20$

## 样例 #1

### 输入

```
2 1 1 2 2```

### 输出

```
BLACK 2```

# AI分析结果



### 综合分析与结论

本题属于博弈论中的对抗搜索问题，核心在于通过极大极小算法模拟双方最优策略。所有题解均采用记忆化搜索实现状态转移，其中白棋试图最大化步数，黑棋试图最小化步数。关键难点在于合理剪枝（步数上限设为3n）和正确处理胜负态。最优思路为：特判初始相邻情况，其余情况黑棋必胜，通过对抗搜索计算最小回合数。

---

### 精选题解及评分

#### 1. **作者：Tenshi（评分：★★★★☆）**
- **关键亮点**：  
  - 对抗搜索理论解释清晰，代码结构简洁易懂。  
  - 使用方向数组预处理移动逻辑，增强可维护性。  
  - 记忆化数组初始化合理（-1表示未访问），状态表示明确（`bool`区分当前玩家）。  
- **个人心得**：  
  > “对抗搜索问题中，状态的定义和转移方向需要明确，白棋选择最大值，黑棋选择最小值，这与零和博弈的输赢策略完全一致。”

**核心代码**：
```cpp
int dfs(bool ok, int cnt, int x1, int y1, int x2, int y2) {
    if (~f[ok][cnt][x1][y1][x2][y2]) return f[ok][cnt][x1][y1][x2][y2];
    if (cnt > 3 * n) return INF;
    if (x1 == x2 && y1 == y2) return ok ? 0 : INF;

    int res;
    if (ok) { // 白棋回合：最大化步数
        res = -1;
        for (每个移动方向) res = max(res, 递归调用);
    } else {   // 黑棋回合：最小化步数
        res = INF;
        for (每个移动方向及距离) res = min(res, 递归调用);
    }
    return f[ok][cnt][x1][y1][x2][y2] = res + 1;
}
```

#### 2. **作者：JRhhdj（评分：★★★★）**
- **关键亮点**：  
  - 代码简洁高效，直接通过递归实现对抗搜索。  
  - 状态压缩合理（六维数组存储玩家、步数、坐标）。  
- **实现技巧**：  
  - 步数限制剪枝（`y>3*n`返回`inf`）避免无限递归。  
  - 胜负态处理（坐标重合时根据当前玩家返回0或`inf`）。

**核心代码**：
```cpp
int dfs(int x, int y, int r1, int c1, int r2, int c2) {
    if (y > 3 * n) return inf;
    if (r1 == r2 && c1 == c2) return x ? inf : 0;
    
    if (!x) { // 白棋回合：选最大步数
        ans = max(各个方向移动后的递归结果);
    } else {   // 黑棋回合：选最小步数
        ans = min(各个方向及距离的递归结果);
    }
    return f[x][y][r1][c1][r2][c2] = ans + 1;
}
```

#### 3. **作者：Exiler（评分：★★★★）**
- **关键亮点**：  
  - 使用结构体封装坐标，提高代码可读性。  
  - 详细注释和逻辑分块，便于理解状态转移。  
- **剪枝优化**：  
  > “步数最多为3n（构造方法详见题解），超过则返回极大值，避免无效搜索。”

**核心代码**：
```cpp
int dfs(bool isw, int s, point p, point h) {
    if (s > 3 * n) return INF;
    if (p与h重合) return isw ? 0 : INF;
    
    if (isw) { // 白棋：找最大步数
        for (方向i) ret = max(ret, 递归结果);
    } else {    // 黑棋：找最小步数
        for (方向及距离j) ret = min(ret, 递归结果);
    }
    return 记忆化存储结果;
}
```

---

### 关键思路总结
1. **胜负特判**：初始曼哈顿距离≤1时白棋一步必胜，否则黑棋必胜。  
2. **对抗搜索框架**：  
   - 白棋回合（极大层）：选择后续状态的最大值。  
   - 黑棋回合（极小层）：选择后续状态的最小值。  
3. **记忆化剪枝**：六维数组存储状态（当前玩家、步数、坐标），避免重复计算。  
4. **步数上限**：设3n为最大回合数，防止无限递归。

---

### 拓展建议
- **类似题目**：  
  - [P2734 USACO3.3游戏](https://www.luogu.com.cn/problem/P2734)：博弈树模型。  
  - [P2542 [AHOI2005]棋盘游戏](https://www.luogu.com.cn/problem/P2542)：对抗搜索变种。  
  - [P1514 NOIP2010引水入城](https://www.luogu.com.cn/problem/P1514)：记忆化搜索与状态覆盖。  
- **思维训练**：尝试将对抗搜索应用于其他双人零和游戏（如五子棋、井字棋）。

---
处理用时：84.85秒
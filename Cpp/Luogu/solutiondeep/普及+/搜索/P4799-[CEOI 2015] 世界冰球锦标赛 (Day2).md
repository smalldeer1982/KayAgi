# 题目信息

# [CEOI 2015] 世界冰球锦标赛 (Day2)

## 题目描述

 **译自 [CEOI2015](https://ceoi2015.fi.muni.cz/tasks.php) Day2 T1「[Ice Hockey World Championship](https://ceoi2015.fi.muni.cz/day2/eng/day2task1-eng.pdf)」**

> 今年的世界冰球锦标赛在捷克举行。Bobek 已经抵达布拉格，他不是任何团队的粉丝，也没有时间观念。他只是单纯的想去看几场比赛。如果他有足够的钱，他会去看所有的比赛。不幸的是，他的财产十分有限，他决定把所有财产都用来买门票。

给出 Bobek 的预算和每场比赛的票价，试求：如果总票价不超过预算，他有多少种观赛方案。如果存在以其中一种方案观看某场比赛而另一种方案不观看，则认为这两种方案不同。

## 说明/提示

#### 样例解释
八种方案分别是：

 - 一场都不看，溜了溜了  
 - 价格 $100$ 的比赛  
 - 第一场价格 $500$ 的比赛  
 - 第二场价格 $500$ 的比赛  
 - 价格 $100$ 的比赛和第一场价格 $500$ 的比赛  
 - 价格 $100$ 的比赛和第二场价格 $500$ 的比赛  
 - 两场价格 $500$ 的比赛  
 - 价格 $1000$ 的比赛

有十组数据，每通过一组数据你可以获得 10 分。各组数据的数据范围如下表所示：

|数据组号|$1-2$|$3-4$|$5-7$|$8-10$|
|-|:-:|:-:|:-:|:-:|
|$N \leq$|$10$|$20$|$40$|$40$|
|$M \leq$|$10^6$|$10^{18}$|$10^6$|$10^{18}$|

## 样例 #1

### 输入

```
5 1000
100 1500 500 500 1000```

### 输出

```
8```

# AI分析结果



### 综合分析与结论
本题核心为利用折半搜索（meet-in-the-middle）解决大规模子集和问题。所有题解均围绕该算法展开，核心思路为将40个元素分为两半，分别DFS枚举子集和，通过排序+二分或双指针合并答案。不同题解在代码实现细节（如剪枝方式、二分写法、预处理排序）上存在差异，但算法框架一致。

---

### 高分题解推荐

#### 1. ZAGER（★★★★★）
**关键亮点**：  
- 图文并茂解释折半搜索原理，结合示意图清晰展示算法流程  
- 代码结构简洁，包含分数据范围的优化策略（前20用爆搜、中间用背包）  
- 提供完整代码及测试用例，注释规范  
**核心代码**：
```cpp
void dfs(int l, int r, ll sum, ll a[], ll &cnt){
    if(sum > m) return;
    if(l > r) { a[++cnt] = sum; return; }
    dfs(l+1, r, sum + w[l], a, cnt);
    dfs(l+1, r, sum, a, cnt);
}
```
**优化点**：将数组分为n/2的前后两半，使用upper_bound快速查找合法区间。

#### 2. jink3599（★★★★☆）
**关键亮点**：  
- 采用双指针替代二分，时间复杂度降为O(n)  
- 预处理排序优化剪枝效率  
**核心代码**：
```cpp
sort(sum1, sum1 + cnt1);
sort(sum2, sum2 + cnt2);
int l = cnt1, r = 1;
for(r = 1; r <= cnt2; r++) {
    while(sum1[l] + sum2[r] > m) l--;
    ans += (l - 1);
}
```
**技巧**：利用有序数组的单调性，通过移动指针替代二分查找。

#### 3. NKU_AI_HMX（★★★★☆）
**关键亮点**：  
- 详细分析算法复杂度，解释为何折半搜索有效  
- 提供推荐习题（P3067、P5194）帮助举一反三  
**核心优化**：  
```cpp
sort(a+1,a+n+1); // 预处理排序加速剪枝
hdfs(n,0); // 从高价比赛开始搜索优化剪枝
```

---

### 关键思路与技巧
1. **折半搜索框架**：  
   - 将元素分为两半（一般取n/2）  
   - 分别DFS枚举子集和存入两个数组  
   - 排序一个数组，遍历另一个数组用二分/双指针统计合法组合数

2. **合并答案优化**：  
   ```cpp
   sort(a); // 预处理排序
   ans += upper_bound(a.begin(), a.end(), m - b[i]) - a.begin();
   ```

3. **剪枝技巧**：  
   - 搜索时提前终止`if(sum > m) return`  
   - 预处理元素降序排列加速剪枝

---

### 拓展与相似题目
1. [P3067 Balanced Cow Subsets G](https://www.luogu.com.cn/problem/P3067)  
   （折半搜索+状态哈希）
2. [P5194 Scales S](https://www.luogu.com.cn/problem/P5194)  
   （带权值约束的折半搜索）
3. [P5691 [NOI2001] 方程的解数](https://www.luogu.com.cn/problem/P5691)  
   （多维折半搜索）

---

### 调试经验摘录
1. **joker_m**：  
   > "十年OI一场空，不开long long见祖宗" → 必须全程使用long long避免溢出。

2. **newbie666**：  
   > "第一次提交只开了1e6数组导致RE，折半后数组大小应为2^20=1048576"

3. **Ofnoname**：  
   > "合并时注意vector下标从0开始，upper_bound返回值直接对应元素个数，无需-1"

---
处理用时：58.42秒
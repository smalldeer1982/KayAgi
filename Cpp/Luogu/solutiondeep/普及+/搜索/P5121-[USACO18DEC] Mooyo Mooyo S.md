# 题目信息

# [USACO18DEC] Mooyo Mooyo S

## 题目描述

由于手上（更确实的，蹄子上）有大把的空余时间，Farmer John 的农场里的奶牛经常玩电子游戏消磨时光。她们最爱的游戏之一是基于一款流行的电子游戏 Puyo Puyo 的奶牛版；名称当然叫做 Mooyo Mooyo。

Mooyo Mooyo 是在一块又高又窄的棋盘上进行的游戏，高 $N$（$1\le N\le 100$）格，宽 $10$ 格。 这是一个 $N=6$ 的棋盘的例子：

```
0000000000
0000000300
0054000300
1054502230
2211122220
1111111223
```

每个格子或者是空的（用 $0$ 表示），或者是九种颜色之一的干草捆（用字符 $1\dots 9$ 表示）。重力会使得干草捆下落，所以没有干草捆的下方是 $0$。

如果两个格子水平或垂直方向直接相邻，并且为同一种非 $0$ 颜色，那么这两个格子就属于同一个连通区域。任意时刻出现至少 $K$ 个格子构成的连通区域，其中的干草捆就会全部消失，变为 $0$。如果同时出现多个这样的连通区域，它们同时消失。随后，重力可能会导致干草捆向下落入某个变为 $0$ 的格子。由此形成的新的布局中，又可能出现至少 $K$ 个格子构成的连通区域。若如此，它们同样也会消失（如果又有多个这样的区域，则同时消失），然后重力又会使得剩下的方块下落，这一过程持续进行，直到不存在大小至少为 $K$ 的连通区域为止。

给定一块 Mooyo Mooyo 棋盘的状态，输出这些过程发生之后最终的棋盘的图案。



## 说明/提示

在上面的例子中，如果 $K=3$，那么存在一个大小至少为 $K$ 的颜色 $1$ 的连通区域，同样有一个颜色 $2$ 的连通区域。当它们同时被移除之后，棋盘暂时成为了这样：

```
0000000000
0000000300
0054000300
1054500030
2200000000
0000000003
```

然后，由于重力效果，干草捆下落形成这样的布局：

```
0000000000
0000000000
0000000000
0000000000
1054000300
2254500333
```

再一次地，出现了一个大小至少为 $K$ 地连通区域（颜色 $3$）。移除这个区域就得到了最终的棋盘布局：

```
0000000000
0000000000
0000000000
0000000000
1054000000
2254500000
```

## 样例 #1

### 输入

```
6 3
0000000000
0000000300
0054000300
1054502230
2211122220
1111111223```

### 输出

```
0000000000
0000000000
0000000000
0000000000
1054000000
2254500000```

# AI分析结果



### 综合分析与结论
本题核心是模拟"消除-下落"循环过程，需解决连通块检测、消除后下落处理。所有题解均采用DFS/BFS检测连通块，差异主要在下落实现。最优思路为：按列处理下落，从下往上填充非零元素到列底，极大减少移动次数。多数解法能达到要求，但部分存在冗余循环或标记处理问题。

---

### 精选题解推荐

#### 1. 作者：houzhiyuan（4星）
**关键亮点**：  
- 采用DFS检测连通块，逻辑清晰易懂  
- 下落处理从下往上遍历，符合重力逻辑  
- 代码结构简洁，适合初学者理解  
**核心代码思路**：  
```cpp
void xialuo() {
    for (int i = n; i >= 1; i--) { // 倒序处理每列
        for (int j = 1; j <= 10; j++) {
            if (ch[i][j] != '0') {
                int k = i; // 寻找可下落位置
                while (ch[k+1][j] == '0' && k <= n) k++;
                if (k != i) { // 执行下落
                    ch[k][j] = ch[i][j];
                    ch[i][j] = '0';
                }
            }
        }
    }
}
```
**个人心得**：  
> "注意每次dfs前都要把数组清空，否则会导致错误标记" —— 强调标记数组的初始化重要性

#### 2. 作者：hhoppitree（4星）
**关键亮点**：  
- 按列处理下落，直接定位填充位置  
- 独立函数分离消除与下落逻辑，模块化清晰  
**核心代码思路**：  
```cpp
void fall() {
    for (int j = 1; j <= 10; j++) { // 逐列处理
        int pos = n; // 当前列最底可填充位置
        for (int i = n; i >= 1; i--) {
            if (dta[i][j]) {
                dta[pos--][j] = dta[i][j]; // 非零元素下移
                if (pos + 1 != i) dta[i][j] = 0;
            }
        }
        for (; pos >= 1; pos--) dta[pos][j] = 0; // 剩余位置补零
    }
}
```
**优化点**：  
- 单次遍历完成整列下落，时间复杂度O(n)每列

---

### 最优思路总结
1. **连通块检测**：DFS/BFS标记同色相邻区域，统计大小后消除  
2. **高效下落**：按列从下到上扫描，将非零元素紧凑排列在列底  
3. **循环终止条件**：当一轮消除后无任何操作时退出循环  

---

### 拓展与相似题目
1. **P1156 矩阵中的块**（连通块基础应用）  
2. **P1505 消木块**（消除类游戏进阶版）  
3. **P1312 Mayan游戏**（复杂下落与消除模拟）  

**共性套路**：二维网格的连通性处理 + 元素位置调整，常用于消除类游戏模拟。

---
处理用时：62.09秒
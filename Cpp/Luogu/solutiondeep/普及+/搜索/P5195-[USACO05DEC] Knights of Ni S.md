# 题目信息

# [USACO05DEC] Knights of Ni S

## 题目描述

贝茜遇到了一件很麻烦的事：她无意中闯入了森林里的一座城堡，如果她想回家，就必须穿过这片由骑士们守护着的森林。为了能安全地离开，贝茜不得不按照骑士们的要求，在森林寻找一种特殊的灌木并带一棵给他们。

当然，贝茜想早点离开这可怕的森林，于是她必须尽快完成骑士们给的任务，贝茜随身带着这片森林的地图，地图上的森林被放入了直角坐标系，并按 $x,y $ 轴上的单位长度划分成了 $ W \times H\  ( 1 \leq W,H \leq 1000 )$ 块，贝茜在地图上查出了她自己以及骑士们所在的位置，当然地图上也标注了她所需要的灌木生长的区域。某些区域是不能通过的（比如说沼泽地，悬崖，以及食人兔的聚居地）。在没有找到灌木之前，贝茜不能通过骑士们所在的那个区域，为了确保她自己不会迷路，贝茜只向正北、正东、正南、正西四个方向移动（注意，她不会走对角线）。她要走整整一天，才能从某块区域走到与它相邻的那块区域。

贝茜希望你能帮她计算一下，她最少需要多少天才可脱离这可怕的地方？输入数据保证贝茜一定能完成骑士的任务。

## 说明/提示

这片森林的长为 $8$，宽为 $4$．贝茜的起始位置在第 $3$ 行，离骑士们不远。

贝茜可以按这样的路线完成骑士的任务：北，西，北，南，东，东，北，东，东，南，南。她在森林的西北角得到一株她需要的灌木，然后绕过障碍把它交给在东南方的骑士。

## 样例 #1

### 输入

```
8 4
4 1 0 0 0 0 1 0
0 0 0 1 0 1 0 0
0 2 1 1 3 0 4 0
0 0 0 4 1 1 1 0
```

### 输出

```
11```

# AI分析结果



### 综合分析与结论
该题核心是求解带条件的最短路径（需先经过特定点），各题解主要围绕以下思路展开：
1. **两次BFS**：分别从起点和终点出发，计算到所有灌木的最短路径，取最小值之和。
2. **分层状态BFS**：将是否取得灌木作为状态扩展，单次BFS即可求解。
3. **分层图建模**：将取得灌木视为状态切换，构建分层图后跑最短路。
4. **双向BFS**：优化搜索过程，平衡两棵搜索树规模。

关键优化点包括：状态压缩、路径条件处理、避免重复搜索。

---

### 高星题解推荐
#### 1. Wenoide（⭐⭐⭐⭐⭐）
**核心亮点**：
- **单次BFS+状态分治**：通过增加`tag`状态记录是否取得灌木，将问题转化为带状态的最短路径搜索。
- **代码简洁高效**：用队列同时处理两种状态，时空复杂度均为O(WH)。
- **边界处理巧妙**：通过预填充边界值避免越界判断。

**代码核心**：
```cpp
struct Node{ int x,y; bool tag; }; // 状态结构体
bool w = tag || (map[u][v]==4); // 判断是否取得灌木
if(!vis[u][v][w] && map[u][v]!=1) { 
    // 更新距离并加入队列 
}
```

#### 2. vеctorwyx（⭐⭐⭐⭐）
**核心亮点**：
- **两次独立BFS**：分别从起点和终点搜索，最后枚举灌木取最小值。
- **错误处理经验**：强调灌木标记恢复的重要性（如搜索后需还原灌木状态）。

**调试心得**：
> "搜索到一个灌木丛要标记成路（一开始标记成障碍了[哭]），但在第二次搜索前要恢复"

#### 3. 那一条变阻器（⭐⭐⭐⭐）
**核心亮点**：
- **分层图建模**：将取得灌木视为跳转到第二层图，通过建图技巧简化状态处理。
- **坐标压缩技巧**：使用`id(x,y)`将二维坐标映射为一维节点。

**关键代码**：
```cpp
if(a[i][j] == 4) add(id(i,j), id(i,j)+n*m); // 灌木处连接两层
add(u, v); add(u+n*m, v+n*m); // 每层独立建边
```

---

### 关键思路与技巧总结
1. **状态分治**：将是否满足路径条件（如取得物品）作为状态维度，扩展BFS的节点结构。
2. **分层图应用**：适用于需要改变移动规则的场景（如取得钥匙后可通过门）。
3. **双向搜索优化**：当起点终点固定时，可显著减少搜索空间。
4. **坐标压缩**：二维坐标映射为一维ID，简化图结构的存储与处理。

---

### 拓展练习推荐
1. [P1606 [USACO07JAN]白银莲花池](https://www.luogu.com.cn/problem/P1606) - 分层图+BFS应用
2. [P4011 孤岛营救问题](https://www.luogu.com.cn/problem/P4011) - 状态压缩+多维BFS
3. [P1332 血色先锋队](https://www.luogu.com.cn/problem/P1332) - 多源双向BFS优化

---

### 核心代码实现示例
**Wenoide的单状态BFS核心逻辑**：
```cpp
while(l!=r){
    Node t=que[l++];
    if(t.tag && t.x==ex && t.y==ey) break; // 终止条件
    for(int i=0;i<4;i++){
        int u=t.x+dx[i], v=t.y+dy[i];
        bool new_tag = t.tag || (map[u][v]==4); // 状态转移
        if(!vis[u][v][new_tag] && map[u][v]!=1){
            dis[u][v][new_tag] = dis[t.x][t.y][t.tag] + 1;
            vis[u][v][new_tag] = true;
            que[r++] = {u, v, new_tag};
        }
    }
}
```

---
处理用时：59.31秒
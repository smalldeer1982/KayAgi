# 题目信息

# [NOI2001] 方程的解数

## 题目描述

已知一个 $n$ 元高次方程：         
$$\sum\limits_{i=1}^n k_ix_i^{p_i} = 0$$
其中：$x_1, x_2, \dots ,x_n$ 是未知数，$k_1,k_2, \dots ,k_n$ 是系数，$p_1,p_2,…p_n$ 是指数。且方程中的所有数均为整数。

假设未知数 $x_i \in [1,m] \space ( i \in [1,n])$，求这个方程的整数解的个数。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le n \le 6$，$1\le m \le 150$，且
$$\sum\limits_{i=1}^n |k_im^{p_i}| < 2^{31}$$  
答案不超过 $2^{31}-1$，$p_i \in \mathbb N^*$。

## 样例 #1

### 输入

```
3
150
1 2
-1 2
1 2```

### 输出

```
178```

# AI分析结果



### 综合分析与结论
本题核心在于通过折半搜索（meet-in-middle）将指数级复杂度降为平方根级。各题解均采用将方程拆分为两半，分别搜索并合并结果的思路，差异主要体现在存储结构和合并方式：哈希表（O(1)查询）、排序+双指针（线性合并）、排序+二分（带log复杂度）。最优解法需在时间与空间效率间权衡。

---

### 优质题解推荐

#### 1. LawrenceSivan 题解（★★★★☆）
**核心亮点**：  
- 双指针合并技术避免哈希冲突，空间效率高  
- 详细讲解折半搜索原理及合并逻辑，代码注释清晰  
- 预处理快速幂优化时间复杂度  
**关键代码**：  
```cpp
void dfs(int l,int r,int sum,int *arr,int &cnt){
    if(l>r) arr[++cnt]=sum;
    for(int i=1;i<=m;i++)
        dfs(l+1,r,sum+k[l]*pow(i,p[l]),arr,cnt);
}
```
**合并逻辑**：排序后双指针统计相同值数量，利用乘法原理计数。

#### 2. nofall 题解（★★★★☆）
**核心亮点**：  
- 手写哈希表实现高效查询（模数+链式处理）  
- 代码简洁高效，实测最优解  
- 利用负号直接转换方程形式，逻辑巧妙  
**关键代码**：  
```cpp
int hash(int x) {
    int v = x % mod;
    while(t[v] && table[v] != x) v = (v+1)%mod;
    return v;
}
void dfs1(int dep, int sum) {
    int v = hash(sum); t[v]++; table[v] = sum;
}
```
**哈希设计**：二次探测法处理冲突，链式存储相同哈希值。

#### 3. 蓝莲花__ 题解（★★★☆☆）
**核心亮点**：  
- 分治后排序+双指针合并，思路直观  
- 独立统计重复值的出现次数  
**核心逻辑**：  
```cpp
sort(a, a+cnt1); sort(b, b+cnt2, greater<int>());
while(i<=cnt1 && j<=cnt2) {
    if(a[i]+b[j]==0) ans += cnt_a * cnt_b;
    else if(a[i]+b[j]>0) j++; else i++;
}
```

---

### 关键思路总结
1. **折半拆分**：将方程拆分为两半，分别计算所有可能的和。  
2. **哈希优化**：利用哈希表（或手写哈希）存储前半结果，后半直接查询相反数。  
3. **合并技巧**：  
   - 双指针法需先排序，统计相同值数量后乘法原理合并  
   - 快速幂预处理避免重复计算指数  

---

### 拓展练习推荐
1. [P4799 世界冰球锦标赛](https://www.luogu.com.cn/problem/P4799)（折半+双指针）  
2. [P3067 Balanced Cow Subsets](https://www.luogu.com.cn/problem/P3067)（折半+状态压缩）  
3. [CF888E Maximum Subsequence](https://www.luogu.com.cn/problem/CF888E)（模意义下最大值）  

---

### 调试经验摘录
- **哈希冲突**：nofall题解中强调必须严格比较键值，避免伪命中。  
- **重复计数**：LawrenceSivan使用`while(l<cnta && a[l]==a[l+1])x++`处理相同值连续出现。  
- **类型溢出**：多个题解使用`long long`存储中间结果，防止int溢出。

---
处理用时：68.29秒
# 题目信息

# Ryoku 的探索

## 题目背景

Ryoku 对自己所处的世界充满了好奇，她希望能够在她「死」之前尽可能能多地探索世界。

这一天，Ryoku 得到了一张这个世界的地图，她十分高兴。然而，Ryoku 并不知道自己所处的位置到底在哪里，她也不知道她会什么时候死去。她想要知道如何才能尽可能多的探索这个世界。

## 题目描述

Ryoku 所处的世界可以抽象成一个有 $n$ 个点， $n$ 条边的带权无向连通图 $G$。每条边有美观度和长度。

Ryoku 会使用这样一个策略探索世界：在每个点寻找一个**端点她未走过**的边中**美观度最高**的走，如果没有边走，就沿着她前往这个点的边返回，类似于图的**深度优先遍历**。

探索的一个方案的长度是这个方案所经过的所有边长度的和（返回时经过的长度不用计算）。

她想知道，对于每一个起点 $s=1,2,\cdots,n$，她需要走过的长度是多少？



## 说明/提示

**【样例 1 说明】**

以下为输入输出样例 1 中的图： （边上红色数组为 $p$，黑色为 $w$）

![](https://cdn.luogu.com.cn/upload/image_hosting/rmk07281.png)

若起点为 $1$，顺序为 $1\to3\to5\to2\to4$，长度之和为 $7$。  
若起点为 $2$，顺序为 $2\to3\to5\to1\to4$，长度之和为 $7$。  
若起点为 $3$，顺序为 $3\to5\to1\to2\to4$，长度之和为 $8$。  
若起点为 $4$，顺序为 $4\to1\to3\to5\to2$，长度之和为 $7$。  
若起点为 $5$，顺序为 $5\to3\to1\to2\to4$，长度之和为 $8$。  

---

**【数据规模与约定】**

对于 $40\%$ 的数据，$n\le 10^3$。    
对于 $100\%$ 的数据，$3 \le n \le 10^6$，$1 \le u,v,p \le n$，$0\le w\le 10^9$，保证 $p$ 互不相同。

## 样例 #1

### 输入

```
5
4 1 2 1
1 2 3 2
3 1 1 4
3 5 2 5
2 3 2 3
```

### 输出

```
7
7
8
7
8```

# AI分析结果



### 综合分析与结论
题目要求基环树遍历时计算各起点出发的路径总长度。所有题解均基于以下关键点：
1. 基环树性质：n点n边必有且仅有一个环
2. 遍历路径长度 = 总边权和 - 环上某条边的权值
3. 环外节点的答案继承其所在子树的环上节点答案

### 高星题解推荐
#### 1. 作者：xiejinhao（★★★★★）
**关键亮点**：
- 采用双DFS策略：第一次找环并计算环上节点答案，第二次为子树赋值
- 巧妙处理环上节点相邻边的美观度比较
- 代码结构清晰，注释完整

**核心代码**：
```cpp
bool dfs(int x, int fa, int fp, int fe) {
    if(vis[x]) { // 发现环时处理
        End = x, Ep = fp, Ee = fe;
        return true;
    }
    vis[x] = 1;
    for(int i = head[x]; i; i = Next[i]) {
        int y = ver[i];
        if(y == fa) continue;
        if(dfs(y, x, p[i], e[i])) {
            // 回溯时处理环边
            ans[x] -= fp > p[i] ? e[i] : fe;
            ring.push_back(x);
            return x != End;
        }
    }
    return false;
}
```

#### 2. 作者：NBest（★★★★）
**关键亮点**：
- 使用拓扑排序快速找环
- 简洁的子树答案传递实现
- 代码简洁高效，适合大规模数据

**核心思路**：
```cpp
// 拓扑找环后处理
for(int i=1;i<=n;i++){
    if(!p[i]){ // 环上节点
        int minn=1e9,flag;
        for(auto j:edges[i]) 
            if(环边中找最小美观度边)
        ans[i] = tot - flag;
        dfs传递子树答案;
    }
}
```

#### 3. 作者：xia0ji233（★★★★）
**个人心得**：
> "从环的起点开始，假如顺时针跑出环，下一条边会逆时针跑环。仅仅限制v!=pre无法避免重复遍历，需要额外标记in_stack"

**关键实现**：
```cpp
int dfs(int u, int pre) {
    if(visited[u]) return u; // 环检测
    visited[u] = 1;
    for(auto &e : edge[u]) {
        if(e.to == pre || in_stack[e.to]) continue;
        int tmp = dfs(e.to, u);
        if(tmp) { // 回溯记录环路径
            s.push_back(u);
            in_stack[u] = 1;
            return (tmp == u) ? 0 : tmp;
        }
    }
    return 0;
}
```

### 关键思路总结
1. **环处理核心**：每个环上节点会舍弃相邻环边中美观度较小的一条
2. **子树继承**：以环为根进行DFS，子树节点答案与对应环节点相同
3. **高效实现**：总时间复杂度O(n)，空间O(n)

### 推荐相似题目
1. [P4381 Island](https://www.luogu.com.cn/problem/P4381) - 基环树直径
2. [P2607 骑士](https://www.luogu.com.cn/problem/P2607) - 基环树DP 
3. [P3533 驿站](https://www.luogu.com.cn/problem/P3533) - 基环树路径查询

### 调试经验摘录
1. "环上节点的两条环边需要特殊处理终点判断" —— xiejinhao
2. "美观度比较需严格处理相等情况" —— Zvelig1205
3. "子树标记时需排除环上节点，防止重复计算" —— 老官童鞋gogo

---
处理用时：56.70秒
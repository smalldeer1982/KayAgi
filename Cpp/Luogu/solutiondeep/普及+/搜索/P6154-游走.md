# 题目信息

# 游走

## 题目背景

zbw 在 B 城游走。

## 题目描述

B 城可以看作一个有 $n$ 个点 $m$ 条边的**有向无环图**。**可能存在重边**。

zbw 在 B 城随机游走，他会在所有路径中随机选择一条路径，选择所有路径的概率相等。路径的起点和终点可以相同。

定义一条路径的长度为经过的边数，你需要求出 zbw 走的路径长度的期望，答案对 $998244353$ 取模。

## 说明/提示

样例说明：样例的答案分别为 $\dfrac{2}{5}$，$\dfrac{25}{19}$ 和 $\dfrac{11}{9}$。

| 测试点编号 | $n$ | $m$ | 特殊性质 | 每测试点分数 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1,2$ | $\le 10$ | $\le 10$ | 无 | $2$ |
| $3,4,5$ | $\le 15$ | $\le 100$ | 无 | $2$ |
| $6,7,8$ | $\le 100$ | $\le 10^3$ | 无 | $2$ |
| $9,10$ | $\le 10^3$ | $\le 10^4$ | 无 | $2$ |
| $11,12$ | $\le 10^4$ | $\le 10^5$ | 无 | $5$ |
| $13,14$ | $\le 10^5$ | $\le 2\times10^5$ | 无 | $5$ |
| $15,16$ | $\le 10^5$ | $\le 7\times10^5$ | 无 | $10$ |
| $17$ | $\le 10$ | $=n-1$ | 有向树 | $10$ |
| $18$ | $\le 10^3$ | $=n-1$ | 有向树 | $10$ |
| $19$ | $\le 10^4$ | $=n-1$ | 有向树 | $10$ |
| $20$ | $\le 10^5$ | $=n-1$ | 有向树 | $10$ |

其中，“有向树”的定义是：若把图视为无向图，则为一棵树（如样例 $1,2$）。

保证所有数据均按照某种方式随机，这意味着你可以认为算法执行过程中，你可以放心执行模意义下除法操作而不用担心除以零。

## 样例 #1

### 输入

```
3 2
1 2
3 2```

### 输出

```
199648871```

## 样例 #2

### 输入

```
6 5
1 3
2 3
3 4
4 5
4 6```

### 输出

```
630470119```

## 样例 #3

### 输入

```
5 6
1 2
1 3
4 5
3 4
3 5
2 4```

### 输出

```
887328315```

# AI分析结果



### 综合分析与结论
题目核心是求 DAG 中所有路径长度的期望。所有题解均将问题拆解为计算路径总长度（sum）和路径总数（cnt），通过动态规划维护路径数及长度。算法核心分为两种方向：
1. **起点方向**：用记忆化搜索维护从节点出发的路径（gyh20、Graphcity）
2. **终点方向**：用拓扑排序维护以节点为终点的路径（zsaskk、Hexarhy）
时间复杂度均为 O(n+m)，关键难点在于状态转移方程的设计和取模运算处理。

---

### 高星题解推荐
#### 1. 作者：gyh20（⭐⭐⭐⭐⭐）
**关键亮点**：
- 最简洁的记忆化搜索实现，逻辑清晰易懂
- 直接维护起点方向的路径信息，状态转移公式简洁
- 代码包含完整的逆元计算模板

**核心代码**：
```cpp
void DP(int now) {
    if(g[now]) return;
    g[now] = 1;
    for (遍历 now 的后继节点 y) {
        DP(y);
        g[now] += g[y];     // 路径数累加
        f[now] += f[y] + g[y]; // 路径长度累加（原长度 + 新增边数）
    }
}
```

#### 2. 作者：Hexarhy（⭐⭐⭐⭐）
**关键亮点**：
- 拓扑排序的标准模板实现，适合 DAG 处理
- 清晰注释解释状态转移意义
- 初始化每个节点的路径数为 1（自身作为单点路径）

**状态转移方程**：
```cpp
f[v] = (f[v] + f[u] + g[u]) % MOD; // 长度累加（原长度 + 新增边数）
g[v] = (g[v] + g[u]) % MOD;        // 路径数累加
```

#### 3. 作者：zsaskk（⭐⭐⭐⭐）
**关键亮点**：
- 使用栈进行拓扑排序，代码风格简洁
- 将路径统计与长度计算合并到拓扑过程中
- 强调初始化每个节点为起点（`num[i] = 1`）

---

### 关键思路与技巧总结
1. **动态规划方向选择**：
   - 起点方向：`f[i]` 表示从 i 出发的路径总长度，`g[i]` 为路径数
   - 终点方向：`f[i]` 表示以 i 结尾的路径总长度，`g[i]` 为路径数
2. **状态转移公式**：
   - 起点方向：`f[u] += f[v] + g[v]`（每条路径延长 1）
   - 终点方向：`f[v] += f[u] + g[u]`（每条路径新增 1 边）
3. **逆元处理**：利用费马小定理快速幂求模意义下的倒数。

---

### 相似题目推荐
1. [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)（DAG 最长路径）
2. [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)（DAG 路径计数）
3. [P3388 【模板】拓扑排序](https://www.luogu.com.cn/problem/P3388)（拓扑排序基础）

---

### 题解中的实用心得
1. **数据类型**：多篇题解强调开 `long long` 并每次运算取模，避免溢出（如 wangjinbo 的代码注释）。
2. **初始化陷阱**：Hexarhy 指出每个节点需初始化为单点路径（`g[i] = 1`），否则会漏计自身路径。
3. **调试经验**：TYxxj 提到暴力解法仅 50 分，强调记忆化搜索的必要性。

---
处理用时：85.02秒
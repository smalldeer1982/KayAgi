# 题目信息

# [SBCOI2020] 时光的流逝

## 题目背景

时间一分一秒的过着，伴随着雪一同消融在了这个冬天，  
或许，要是时光能停留在这一刻，该有多好啊。  
......    
“这是...我在这个小镇的最后一个冬天了吧。”  
“嗯，你可不能这辈子都呆在这个小镇吧。外面的世界很大呢，很大很大...”  
“唔...外面的世界...突然有点期待呢！”  
“总有一天，你会走得很远很远。以后你可不要忘记这个小镇那。”  
“不会的，至少...这里曾经是我最快乐的一段回忆呢！你也一定不要忘记我呀。”   
“你看，这雪花。传说，每当世界上有一份思念，便会化成一片雪花在这里飘落。”   
“那...以后你可一定要找到我的那片雪花啊......”  
![](https://cdn.luogu.com.cn/upload/image_hosting/orzntcy6.png)    
“嗯，不如我们一起在这个冬天创造最后一段回忆吧。”  
“好呀，我们玩个游戏吧......”  

## 题目描述

这个游戏是在一个有向图（不保证无环）上进行的。每轮游戏开始前，她们先在图上选定一个起点和一个终点，并在起点处放上一枚棋子。

然后两人轮流移动棋子，每次可以将棋子按照有向图的方向移动至相邻的点。

如果谁先将棋子移动至终点，那么谁就胜利了。同样，如果谁无法移动了，那么谁就失败了。

两人轮流操作，请问，他们是否有必胜策略呢？  

答案为一个整数 `0` 或 `1` 或 `-1`，其中 `1` 表示（先手）有必胜策略，`-1` 表示后手有必胜策略，`0` 表示两人均无必胜策略。

## 说明/提示

#### 样例解释 $#1$

![](https://cdn.luogu.com.cn/upload/image_hosting/k7q0qjrb.png)

为描述题意，假设两人为 A（先手）和 B

如图，A 先走，走到 $2$，B 走到 $3$，接下去 A 可以选择走到 $4$ 或 $6$，若走到 $4$，接下去 B 可以走到终点，故不可取。若选择走到 $6$，那么 B 只能走到 $7$，A 可以走到终点。所以 A 有必胜策略。

#### 样例解释 $#2$

![](https://cdn.luogu.com.cn/upload/image_hosting/9yjnyye3.png)

如图，起点为 $1$，终点为 $5$ 时， A 和 B 会沿着 $1-2-3-1$ 的顺序轮流走。因为如果谁先走到 $4$，那么下一个人就可以走到终点。故谁都没有必胜策略。

起点为 $4$，终点为 $3$ 时，A 先走到 $5$，B 无路可走，故 B 失败。

#### 数据范围

对于 $10\%$ 的数据，保证图是一条链。

对于 $50\%$ 的数据，$1\leq n\leq 10^3$，$1\leq m\leq 2\times10^3$，$1\leq q\leq 10$。

对于 $70\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 2\times10^5$，$1\leq q\leq 10$。

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 5\times10^5$，$1\leq q\leq 500$。

## 样例 #1

### 输入

```
7 7 1
1 2
2 3
3 4
4 5
3 6
7 5
6 7
1 5```

### 输出

```
1```

## 样例 #2

### 输入

```
5 5 2
1 2
2 3
3 1
3 4
4 5
1 5
4 3```

### 输出

```
0
1```

# AI分析结果



### 综合分析与结论

本题是在有向图上进行博弈论判定，核心在于通过反向拓扑排序确定每个节点的必胜/必败状态。关键点包括终点和出度为0节点的初始必败标记，以及通过反向边递推状态。环的处理是难点，未被标记的节点视为平局。各题解均采用反向图拓扑排序思路，主要差异在代码实现细节与优化程度。

---

### 精选题解（评分≥4星）

#### 1. 作者：犇犇犇犇（★★★★★）
**关键亮点**  
- 详细讲解反向图拓扑排序的原理与实现步骤  
- 引入出度统计和队列优化，通过提前终止搜索减少冗余计算  
- 代码中通过`del()`函数统一处理节点状态确定后的逻辑  
**核心代码**  
```cpp
void del(int u) {
    f[u] = 1; // 标记已处理
    for (遍历u的反向边v) {
        d[v]--; // 减少v的剩余未处理出度
        if (d[v] == 0) q.push(v); // 入度清零时入队
    }
}
while (!q.empty()) {
    int u = q.front();
    if (vic[x] != 0) break; // 起点状态确定时提前终止
    ...
}
```

#### 2. 作者：duyi（★★★★☆）  
**关键亮点**  
- 代码简洁高效，通过统一状态转移逻辑减少分支判断  
- 使用独立数组维护临时入度，避免多组询问间的干扰  
- 清晰注释说明必胜必败状态转换条件  
**核心逻辑**  
```cpp
if (f[u] == 1) { // u是必胜点，v的入度减一
    cur_deg[v]--;
    if (!cur_deg[v]) f[v] = -1;
} else { // u是必败点，直接标记v为必胜
    f[v] = 1;
}
```

#### 3. 作者：Mine_King（★★★★☆）  
**核心技巧**  
- 使用链式前向星反向建图，优化内存访问效率  
- 通过`memcpy`快速复制入度数组，适应多组查询  
- 代码结构模块化，便于调试和扩展  
**关键实现**  
```cpp
memcpy(in, kk, sizeof(kk)); // 快速复制入度
q.push(y); // 强制将终点加入初始队列
if (f[x] == 1) // 直接根据父节点状态更新子节点
```

---

### 关键思路与技巧总结

1. **反向图拓扑排序**  
   - 建反向边后从终点/出度为0节点开始递推  
   - 必胜点条件：存在至少一个后继是必败点  
   - 必败点条件：所有后继都是必胜点  

2. **入度动态维护**  
   - 使用`cur_deg`数组跟踪剩余未处理边数  
   - 当节点入度降为0时触发状态判定  

3. **多查询优化**  
   - 独立维护每组查询的状态数组  
   - 提前终止机制（如起点状态确定后跳出）  

4. **环处理**  
   - 未被标记的节点默认视为平局（返回0）  
   - 通过入度清零机制避免无限循环  

---

### 相似题目推荐

1. [P2734 [USACO3.3] 游戏 A Game](https://www.luogu.com.cn/problem/P2734)  
   **考察点**：双人博弈决策与区间DP  

2. [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)  
   **考察点**：DAG拓扑排序与路径统计  

3. [P2149 [SDOI2009] Elaxia的路线](https://www.luogu.com.cn/problem/P2149)  
   **考察点**：有向图最短路与拓扑排序结合  

---

### 个人心得摘录

> "在处理有环图时，未被标记的节点状态应保持为0，这相当于博弈论中的无限循环平局状态。关键在于确保队列处理逻辑不会遗漏强制终止条件。"  
> —— 作者：犇犇犇犇  

> "反向建图后，入度的动态维护是拓扑排序的核心。每次查询时需深拷贝原入度数组以避免污染。"  
> —— 作者：duyi  

> "代码中频繁使用`memcpy`会导致性能瓶颈，但实际测试中由于询问次数少，仍可通过。优化时考虑使用滚动数组。"  
> —— 作者：Mine_King  

这些经验强调了状态隔离和动态维护的重要性，对处理类似图论问题具有普适参考价值。

---
处理用时：69.40秒
# 题目信息

# [USACO21OPEN] Maze Tac Toe S

## 题目描述

奶牛 Bessie 喜欢玩走迷宫。她同样喜欢玩井字棋（更准确地说，奶牛版的井字棋，马上会进行介绍）。Farmer John 找到了一种全新的方式，可以使她同时玩到这两种游戏！

首先，奶牛井字棋：与在 $3 \times 3$ 棋盘内放置 `X` 和 `O` 不同，奶牛当然是在 $3 \times 3$ 棋盘内放置 `M` 和 `O`。在一方的回合内，玩家可以选择将一个 `M` 或一个 `O` 放在任意一个空格内（这是另一个与标准井字棋的不同之处，标准的井字棋中一名玩家始终放 `X` 而另一名玩家始终放 `O`）。奶牛井字棋的胜利方是首位拼出 `MOO` 的玩家，可以是同行、同列或对角线。倒着拼出也是可以的，例如一名玩家在棋盘的一行内拼出 `OOM` 也可以获胜。如同标准井字棋一样，有可能最后没有玩家取得胜利。奶牛井字棋的一次行动通常用 3 个字符表示，`Mij` 或 `Oij`，其中 $i$ 和 $j$ 在范围 $1 \ldots 3$ 之间，表示放置 `M` 或 `O` 的行与列。

为了给 Bessie 增加一些挑战，Farmer John 设计了一个由 $N \times N$ 个方格组成的正方形迷宫（$3 \leq N \leq 25$）。某些方格，包括所有的边界方格，有巨大的草堆，使得 Bessie 不能移动到这些方格。Bessie 可以沿东南西北四个方向在迷宫内的所有其他方格内自由行动。某些方格内有一张纸，上面写有奶牛井字棋的一次行动。当 Bessie 在迷宫中移动时，任何时刻她停留在这样的方格上，她都必须于迷宫中移动之时在同时进行的奶牛井字棋游戏内做出对应的行动（除非奶牛井字棋中对应的方格已经被填上了，在这种情况下她不进行行动）。在奶牛井字棋游戏内没有与她对阵的玩家，但迷宫中的某些方格可能会不利于她最终拼出 `MOO`。

如果 Bessie 在获胜之时就会立刻停止奶牛井字棋，请求出她可以通过适当的方式在迷宫中移动而完成的不同的胜利状态棋盘数量。

## 说明/提示

#### 样例说明

在这个样例中，Bessie 最终可能达成 $8$ 种胜利的棋盘状态：

```plain
O.M
.O.
MOM

O..
.O.
.OM

O.M
.O.
.OM

O..
.O.
MOM

O..
...
OOM

..M
.O.
OOM

...
.O.
OOM

...
...
OOM
```

对其中一种情况进行说明：

```plain
O..
...
OOM
```

在这里，Bessie 可以先移动到 `O11` 方格，然后移动到下方并通过 `O32`、`M33` 和 `O31`。此时游戏结束，因为她获得了胜利（例如她不能再前往位于她当前所在的 `O31` 方格北面的 `M11` 方格）。

#### 说明

供题：Brian Dean

## 样例 #1

### 输入

```
7
#####################
###O11###...###M13###
###......O22......###
###...######M22######
###BBB###M31###M11###
###...O32...M33O31###
#####################```

### 输出

```
8```

# AI分析结果



### 综合分析与结论
本题核心在于**状态压缩+记忆化搜索**，将井字棋的3x3棋盘状态压缩为三进制数（共3^9种状态），结合迷宫坐标进行BFS/DFS。关键优化点包括：预处理所有可能胜利状态、避免重复访问相同状态、高效处理棋盘状态转换。所有题解均采用三进制状态压缩，但实现方式略有差异。

---

### 精选题解与评分

#### 1. 作者：tiger2005（⭐⭐⭐⭐⭐）
**关键亮点**：
- **预处理胜利状态**：提前计算所有3^9种状态是否胜利，大幅减少运行时判断开销。
- **递归DFS+状态剪枝**：使用`dp[x][y][k]`记录位置(x,y)与状态k是否已访问，避免重复搜索。
- **高效状态转换**：通过数学运算直接计算棋盘位置的三进制权值，代码简洁高效。
  
**核心代码思路**：
```cpp
// 预处理所有状态是否胜利
for(int i=0;i<pw[9];i++) isP[i]=isWin(i);

// 状态转换：将当前位置操作应用到棋盘
int Draw(int k, char q, int x, int y) {
    x = 3*x + y;
    int u = (k / pw[x]) % 3;
    if(u != 0) return k;
    return k + (q=='M'?1:2)*pw[x];
}
```

#### 2. 作者：CrTsIr400（⭐⭐⭐⭐）
**关键亮点**：
- **BFS队列优化**：使用队列显式管理搜索顺序，避免递归栈溢出风险。
- **即时状态生成**：在扩展状态时动态计算新棋盘状态，减少预处理开销。
- **高效胜利判断**：独立函数`chk`通过位运算快速判断行列对角线是否满足条件。

**核心代码思路**：
```cpp
// BFS状态扩展
void ext(int ST, int sx, int sy) {
    while(l <= r) {
        int x=X[l], y=Y[l], S=SQ[l];
        for(四个方向) {
            int SS = nws(S, a[xx][yy]); // 生成新状态
            if(!f[SS][xx][yy]) 加入队列;
        }
        l++;
    }
}
```

---

### 关键思路总结
1. **三进制状态压缩**：将3x3棋盘映射为0-2（空/M/O），通过`3^i`权值计算唯一状态编码。
2. **预处理胜利状态**：将3^9种可能状态的胜利情况预先计算并存储，极大优化运行时性能。
3. **记忆化搜索**：使用三维数组`vis[x][y][state]`记录位置与状态的访问情况，避免重复搜索。
4. **DFS/BFS选择**：递归DFS代码简洁，BFS更适合大规模状态空间，需根据具体实现选择。

---

### 拓展与举一反三
1. **类似状态压缩题**：
   - [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)：状态记录+剪枝
   - [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379)：三进制状态+BFS
   - [P2831 愤怒的小鸟](https://www.luogu.com.cn/problem/P2831)：状态压缩DP
2. **调试技巧**：
   - **状态可视化**：将三进制数解码为棋盘格式输出，便于验证状态转换逻辑。
   - **边界检查**：特别注意迷宫移动时的越界判断（如`Maz[xx][3*yy+1]!='#'`）。

---

### 个人心得摘录
> "预处理胜利状态后，搜索时直接查表而不是实时计算，这是通过空间换时间的经典优化。" —— tiger2005  
> "BFS队列扩展时，一旦发现胜利状态立即停止该路径的后续搜索，这是避免无效操作的关键。" —— CrTsIr400

这两条心得体现了**预处理优化**和**及时剪枝**在搜索问题中的重要性，值得在类似题目中应用。

---
处理用时：72.32秒
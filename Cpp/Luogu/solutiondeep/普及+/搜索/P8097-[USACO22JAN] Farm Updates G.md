# 题目信息

# [USACO22JAN] Farm Updates G

## 题目描述

Farmer John 经营着总共 $N$ 个农场（$1\le N\le 10^5$），编号为 $1\ldots N$。最初，这些农场之间没有道路连接，并且每个农场都在活跃地生产牛奶。

由于经济的动态性，Farmer John 需要根据 $Q$ 次更新操作（$0\le Q\le 2\cdot 10^5$）对他的农场进行改造。更新操作有三种可能的形式：

- `(D x)` 停用一个活跃的农场 $x$，使其不再生产牛奶。

- `(A x y)` 在两个活跃的农场 $x$ 和 $y$ 之间添加一条道路。

- `(R e)` 删除之前添加的第 $e$ 条道路（$e = 1$ 是添加的第一条道路）。

一个农场 $x$ 如果正在活跃地生产牛奶，或者可以通过一系列道路到达另一个活跃的农场，则称之为一个「有关的」农场。对于每个农场 $x$，计算最大的 $i$（$0\le i\le Q$），使得农场 $x$ 在第 $i$ 次更新后是有关的。

## 说明/提示

【样例解释】

在这个例子中，道路以顺序 $(2,3), (1,2), (2,4)$ 被删除。

- 农场 $1$ 在道路 $(1,2)$ 被删除之前是有关的。

- 农场 $2$ 在道路 $(2,4)$ 被删除之前是有关的。

- 农场 $3$ 在道路 $(2,3)$ 被删除之前是有关的。

- 农场 $4$ 和 $5$ 在所有更新结束后仍然是活跃的。所以它们一直保持为有关的，两者的输出均应为 $Q$。

【数据范围】

- 测试点 2-5 满足 $N\le 10^3$，$Q\le 2\cdot 10^3$。

- 测试点 6-20 没有额外限制。


## 样例 #1

### 输入

```
5 9
A 1 2
A 2 3
D 1
D 3
A 2 4
D 2
R 2
R 1
R 3```

### 输出

```
7
8
6
9
9```

# AI分析结果



### 综合分析与结论

本题核心在于处理动态图的连通性问题，难点在于删除操作与时间维度的结合。各题解普遍采用逆向思维，将破坏性操作（删边、停用）转化为建设性操作（加边、激活），从而利用并查集/BFS高效处理。最优解法的时间复杂度为线性或近似线性。

---

### 高星题解推荐

#### 1. 作者：zhiyangfan（★★★★★）
**关键亮点**：逆向处理操作，并查集维护连通性，时间复杂度O(n+q)  
**核心思路**：
- 倒序处理操作，将停用操作转为激活
- 合并连通块时，若其中一个块已激活，则整个块被激活
- 使用启发式合并，每个点仅被处理一次

**核心代码**：
```cpp
void link(int u, int v, int now) {
    u = getf(u), v = getf(v);
    if ((!vis[u]) ^ (!vis[v])) { // 仅一側激活时才更新答案
        if (!vis[u]) for (auto x : vec[u]) vis[x] = now;
        else for (auto x : vec[v]) vis[x] = now;
    }
    // 启发式合并
}
```

#### 2. 作者：耶梦加得（★★★★☆）
**关键亮点**：逆向BFS传播答案，O(n)时间复杂度  
**核心思路**：
- 初始构建最终有效图的连通性
- 倒序处理时，激活操作触发BFS传播答案
- 用vis数组避免重复计算

**核心代码**：
```cpp
void dfs(int x, int t) {
    if(vis[x]) return;
    vis[x] = 1; ans[x] = t;
    for(int to : G[x]) dfs(to, t);
}
// 倒序处理激活时调用dfs(x, i-1)
```

#### 3. 作者：DengDuck（★★★★☆）
**关键亮点**：优先队列维护最大存活时间，类似Dijkstra  
**核心思路**：
- 每个点维护最大存活时间，初始为停用时间
- 优先队列传播相邻点的最小边删除时间
- 时间复杂度O(n log n)

**核心代码**：
```cpp
priority_queue<pair<int,int>> pq;
while (!pq.empty()) {
    auto [t, u] = pq.top(); pq.pop();
    for (auto [v, eid] : edges[u]) {
        int new_t = min(t, edge_end[eid]);
        if (new_t > ans[v]) {
            ans[v] = new_t;
            pq.push({ans[v], v});
        }
    }
}
```

---

### 最优关键思路总结

1. **逆向时间处理**：将破坏性操作转化为建设性操作，避免动态删边难题。
2. **连通性传播**：利用并查集/BFS在激活时一次性传播答案，每个点仅处理一次。
3. **启发式合并**：在合并连通块时选择较小集合合并，保证线性时间复杂度。

---

### 相似题目推荐

1. [P3224 [HNOI2012]永无乡](https://www.luogu.com.cn/problem/P3224)  
   - 连通块合并与查询，需维护排名信息
2. [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)  
   - 逆向处理删点操作，维护连通块数量
3. [P4185 [USACO18JAN]MooTube G](https://www.luogu.com.cn/problem/P4185)  
   - 离线处理+并查集，按边权阈值排序

---

### 调试心得摘录

**清小秋ovo**：  
> "赛时发现并查集难以处理删边，果断换逆向BFS思路，调试时发现边表大小没开够导致RE，切记无向图边数要×2！"  
**总结**：注意无向图的边表存储需双倍空间。

**Alex_Wei**：  
> "线段树分治+整体二分调试3小时未过，最终放弃改用逆向并查集。"  
**总结**：复杂数据结构需谨慎评估代码实现难度与常数。

---
处理用时：72.14秒
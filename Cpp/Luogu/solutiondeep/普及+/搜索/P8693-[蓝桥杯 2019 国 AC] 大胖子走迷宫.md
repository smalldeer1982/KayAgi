# 题目信息

# [蓝桥杯 2019 国 AC] 大胖子走迷宫

## 题目描述

小明是个大胖子，或者说是个大大胖子，如果说正常人占用 $1\times1$ 的面积，小明要占用 $5\times5$ 的面积。

由于小明太胖了，所以他行动起来很不方便。当玩一些游戏时，小明相比小伙伴就吃亏很多。小明的朋友们制定了一个计划，帮助小明减肥。计划的主要内容是带小明玩一些游戏，让小明在游戏中运动消耗脂肪。走迷宫是计划中的重要环节。

朋友们设计了一个迷宫，迷宫可以看成是一个由 $n\times n$ 个方阵组成的方阵，正常人每次占用方阵中 $1\times1$ 的区域，而小明要占用 $5\times5$ 的区域。小明的位置定义为小明最正中的一个方格。迷宫四周都有障碍物。为了方便小明，朋友们把迷宫的起点设置在了第 $3$ 行第 $3$ 列，终点设置在了第 $n-2$ 行第 $n-2$ 列。

小明在时刻 $0$ 出发，每单位时间可以向当前位置的上、下、左、右移动单位 $1$ 的距离，也可以停留在原地不动。小明走迷宫走得很辛苦，如果他在迷宫里面待的时间很长，则由于消耗了很多脂肪，他会在时刻 $k$ 变成一个胖子，只占用 $3\times3$ 的区域。如果待的时间更长，他会在时刻 $2\times k$ 变成一个正常人，只占用 $1\times1$ 的区域。注意，当小明变瘦时迷宫的起点和终点不变。

请问，小明最少多长时间能走到迷宫的终点。注意，小明走到终点时可能变瘦了也可能没有变瘦。

## 说明/提示

对于 $30 \%$ 的评测用例, $1 \leq n \leq 50$。

对于 $60 \%$ 的评测用例, $1 \leq n \leq 100$。

对于所有评测用例, $1 \leq n \leq 300$，$1 \leq k \leq 1000$。

蓝桥杯 2019 年国赛 A 组 F 题（C 组 I 题）。

## 样例 #1

### 输入

```
9 5
+++++++++
+++++++++
+++++++++
+++++++++
+++++++++
***+*****
+++++++++
+++++++++
+++++++++
```

### 输出

```
16```

# AI分析结果



### 综合分析与结论
该题核心为带状态变化的 BFS，需处理体型变化与障碍物检测。各题解均采用 BFS，但在状态表示、优化技巧（如前缀和）、队列处理上存在差异。最优解法需兼顾时间复杂度与代码简洁性，利用状态压缩或预处理提升效率。

### 高星题解推荐

#### 1. 作者：HHYQ_07（★★★★★）
**关键亮点**：
- 使用二维前缀和 O(1) 判断障碍物区域，大幅提升效率。
- 结构体清晰记录位置、时间、体型，代码可读性强。
- 原地停留优化：仅在未达最小体型时入队等待。

**核心代码**：
```cpp
struct node { int t,now,x,y; };
void bfs() {
    // 前缀和预处理
    for (int i=1;i<=n;i++) 
        for (int j=1;j<=n;j++) 
            sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + a[i][j];
    
    // BFS核心
    while(q.size()) {
        node s = q.front(); q.pop();
        if (到达终点) { cout << s.t; exit(0); }
        int noww = (s.t < k ? 2 : (s.t < 2*k ? 1 : 0)); // 计算当前体型
        // 移动判断使用前缀和快速检查区域
        for (移动方向) {
            int sum = 前缀和查询(x±noww, y±noww);
            if (sum==0) 入队;
        }
    }
}
```

#### 2. 作者：DreamLand_zcb（★★★★☆）
**关键亮点**：
- 结构体包含时间与体型，状态转移逻辑清晰。
- 原地停留处理：非最小体型时允许停留，自动更新体型。
- 利用函数动态计算体型，减少冗余存储。

**核心实现**：
```cpp
int work(int Time) { // 根据时间返回体型
    if(Time < k) return 2;
    else if(Time < 2*k) return 1;
    else return 0;
}
void bfs() {
    while(!q.empty()) {
        node t = q.front(); q.pop();
        // 终点判断与移动处理
        if (t.size != 0) q.push({t.x, t.y, t.Time+1, work(t.Time+1)}); // 停留
        for (四方向移动) {
            if (check(X, Y, t.size)) { // 检查区域障碍
                vis[X][Y] = 1;
                q.push({X, Y, t.Time+1, work(t.Time+1)});
            }
        }
    }
}
```

#### 3. 作者：qiuqiuming（优化版本）（★★★★☆）
**关键亮点**：
- 分阶段 BFS（三次处理不同体型），减少状态判断复杂度。
- 原地等待优化：直接跳转到下一个体型阶段的时间点。
- 使用三个队列分别处理不同体型，逻辑解耦。

**核心代码**：
```cpp
void bfs() {
    queue<node> q[3]; // 0:1x1, 1:3x3, 2:5x5
    q[2].push({3,3,0});
    for (int j=2; j>=0; j--) { // 按体型倒序处理
        while (!q[j].empty()) {
            node now = q[j].front(); q[j].pop();
            // 处理移动与等待
            if (now.t < (3-j)*k) // 压入下一阶段队列
                q[j-1].push({now.x, now.y, (3-j)*k});
        }
    }
}
```

### 关键思路与技巧总结
1. **状态表示**：BFS节点需包含坐标、时间、体型，或通过时间计算当前体型。
2. **障碍物检测优化**：二维前缀和预处理，实现O(1)区域查询。
3. **原地等待优化**：直接跳转到变体时间点（k或2k），避免逐秒入队。
4. **队列分层**：分体型阶段处理队列，减少状态判断分支。

### 相似题目推荐
1. **P1443 马的遍历**（BFS基础，状态为坐标+步数）
2. **P1126 机器人搬重物**（带方向状态的BFS）
3. **P1162 填涂颜色**（二维区域处理，类似障碍检测）

### 调试经验与心得
- **体型边界检查**：需确保体型变化后的坐标不越界，如5x5体型下中心点需距边界≥2。
- **前缀和索引**：注意前缀和数组从1开始，避免越界。
- **状态去重**：同一坐标不同时间可能需重复访问，vis数组需结合时间或体型判断。

---
处理用时：81.69秒
# 题目信息

# 「DTOI-4」行走

## 题目背景

小 L 感到无聊，于是希望在树上行走。

## 题目描述

小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。

他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。

他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：

- $P$ 是一条**可以为空**的**简单有向路径**。
- 设 $P$ 中依次经过的点为 $P_1, P_2, \cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。
- 设 $f(P) = \displaystyle\sum_{i = 1}^{|P|} \frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。
- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。

请你求出符合上述条件的路径 $P$。 

------------

关于本题中字典序的定义：

设有两条待比较的路径 $P \neq Q$。

- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。
- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。

## 说明/提示

#### 样例 #1 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)

$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \frac{1}{4} = \frac{5}{4}$。可以证明不存在更优的 $P$。
#### 数据范围
| $\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |
| :------: | :------: | :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 50$ | 无特殊限制 | 无 | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 500$ | 同上 | $1$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 5 \times 10^3$ | 同上 | $1, 2$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^5$ | 同上 | $1 \sim 3$ | $20 \operatorname{pts}$ |
| $5$ | 无特殊限制 | $a_i \in \{-1, 1\}$ | 无 | $20 \operatorname{pts}$ |
| $6$ | 同上 | 无特殊限制 | $1 \sim 5$ | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$a_i \in \{-1, 0, 1\}$，$1 \leq u, v \leq n$，保证给出的边可以构成一棵**无根树**。

## 样例 #1

### 输入

```
5
1 0 -1 1 -1
1 2
2 3
2 4
1 5```

### 输出

```
1 2 4```

# AI分析结果



### 综合分析与结论
本题核心在于处理分数权重下的贪心策略与字典序双重约束。关键突破点：①排除所有-1节点（后续收益无法覆盖损失）②优先选1节点（权重衰减下早期决策更关键）③末尾0的剪枝处理（不影响f值但影响字典序）④通过邻接表排序实现字典序最小路径选择。

---

### 高星题解推荐

#### 1. xiaoqian02（★★★★☆）
**核心亮点**：  
- 采用DFS贪心策略，分层维护二进制权重数组qz[]
- 优先遍历1节点，动态更新最大深度并重置后续位
- 邻接表预排序实现字典序最小
- 处理末尾0的剪枝逻辑清晰

**调试心得**：  
> "发现末尾0会影响字典序，必须在确定最大深度后清除尾部0"

**核心代码逻辑**：
```cpp
bool dfs(int p, int fr, int dep) {
    int mx = -1;
    bool bg = 0;
    for (auto k : ed[p]) { // 已排序的邻接表
        if (k == fr) continue;
        if (a[k] == 1) {
            if (qz[dep] == 0) { // 发现更优的1节点
                qz[dep] = 1;
                nxt[p] = k; // 更新路径
                for (int j = dep+1; j<=mxd; j++) qz[j] = 0; // 重置低位
            }
            if (dfs(k,p,dep+1)) nxt[p] = k; // 递归探索
        }
    }
    // 处理0节点情况...
}
```

#### 2. elbissoPtImaerD（★★★★★）
**核心亮点**：
- BFS分层处理，维护每层可能的最优节点集合
- 使用优先队列动态淘汰非最优路径
- 通过父指针逆向构建路径，空间效率优异
- 代码简洁（仅40行）且时间复杂度O(n)

**关键实现**：
```cpp
void bfs() {
    _[0].push_back(1); // 初始化层0
    for (int i=0; _[i].size(); ++i) {
        for (int u : _[i]) 
            for (int v : G[u]) 
                if (!pa[v] && a[v]) // 排除-1节点
                    _[i+1].push_back(v), pa[v]=u;
        // 处理0节点层...
    }
    for (int u : _[m]) f[u] = 1; // 标记终点
}
```

#### 3. Leasier（★★★★☆）
**创新点**：
- 双队列机制（当前层q与下一层q2）
- 分层淘汰策略，先处理1节点再处理0
- 通过vis数组逆向追踪路径

**路径构建技巧**：
```cpp
void dfs3(int x) {
    int minn = INF;
    for (auto y : ed[x]) { // 已排序的邻接表
        if (vis[y] && sondep[y] == maxdep) 
            minn = min(minn, y); // 找最小编号节点
    }
    ans.push_back(x);
    if (a[x] == 0) zr++; else zr = 0; // 统计末尾0
}
```

---

### 关键优化技巧总结
1. **权重衰减特性**：利用Σ(1/2^i) < 1/2^(i-1)的性质，证明-1节点和次优节点的可淘汰性
2. **分层处理**：BFS按深度处理，每层独立决策最优节点集合
3. **字典序保证**：预处理时将邻接表按节点编号排序，遍历时自然获得最小字典序
4. **末尾0剪枝**：逆向遍历结果数组，删除不影响f值的尾部0节点

---

### 相似题目推荐
1. [P2656 采蘑菇](https://www.luogu.com.cn/problem/P2656)（环处理+分数衰减）
2. [P3953 逛公园](https://www.luogu.com.cn/problem/P3953)（图论中的路径决策与字典序）
3. [P3830 [SHOI2012]随机树](https://www.luogu.com.cn/problem/P3830)（树结构中的期望计算与路径选择）

---
处理用时：62.56秒
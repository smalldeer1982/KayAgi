# 题目信息

# 「DTOI-5」校门外的枯树

## 题目背景

某天放学，你走出了校门，发现校门外又双叒叕出现了一排树。只不过因为正值寒冬时节，树的叶子都掉光了，树们在寒风中瑟瑟发抖，让人担心它们会不会在某一时刻失去平衡，然后倒下来。

## 题目描述

给你校门外的一排 $T$ 棵无向有根树（每棵树的根节点编号均为 $1$），每棵树的每条边有其重量 $m_i$，现在请你算出每棵树的不平衡度 **或** 该树的**每个节点的子树**的不平衡度，好让校方帮忙加固。$\color{white}\sout{\text{不要问我为什么重量的字母是 }m\text。}$

注意这里的**树的边是有顺序的**，~~你总不可能把树枝掰断然后嫁接到另一个地方吧，这可是枯树啊喂~~。

---

对于一颗有根树，定义其不平衡度为该树被在根节点与某一叶子节点的一条最短路径分割为左右两部分（两个边集）后（两个边集均不含该最短路径中的边）两部分的边的总重之差的最小值。特别地，**单个点作为树的不平衡度为 $0$**；空边集内边的总重为 $0$。

## 说明/提示

**【数据范围】**

**不捆绑测试**，同一 $\text{Subtask}$ 内每个测试点等分。

$$
%\def\or{\operatorname{or}}
%这 arraystretch 咋老是拼错/oh
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask}&\sum n\leqslant&k=&\textbf{Special Constraints}&\textbf{Score}\cr\hline
\sf1&2\times10^5&1&\bf A&1\cr\hline
\sf2&20&1&T=1&5\cr\hline
\sf3&5000&1&&5\cr\hline
\sf4&10^5&2&\bf B&15\cr\hline
\sf5&3\times10^5&1&&30\cr\hline
\sf6&2\times10^5&2&\bf A'&4\cr\hline
\sf7&3\times10^5&2&&40\cr\hline
\end{array}
$$
- 特殊性质 $\bf A$ ~~限宽 2.6m~~：保证每棵树只有一个叶子节点（$n\geqslant2$）。
- 特殊性质 $\bf B$ ~~限高 4.5m~~：保证每棵树都为菊花图（根节点有 $n-1$ 个儿子）。
- 特殊性质 $\bf A'$：保证每棵树都是链（每个节点的度数不超过 $2$）。

关于 $\bf A$ 和 $\bf A'$ 的区别：$\bf A'$ 中有可能树的根的度数为 $2$，而 $\bf A$ 中根的度数显然为 $1$。

对于 $100\%$ 的数据，$T \leqslant 4000$，${\color{red}\textbf1}\leqslant n\leqslant 10^5$，$\sum n\leqslant 3\times10^5$，$1 \leqslant m_i \leqslant10^4$，$1\leqslant u, v\leqslant n$，$k\in\{1,2\}$。

---
叶子节点为没有儿子的节点，即除根节点以外在树中的度为 $1$ 的点。

样例输入中为方便阅读加上了空行，实际数据中没有空行。


**【样例 $\bm1-\bm1$ 解释】**


该树如下图所示，边权即边的重量。

![](https://cdn.luogu.com.cn/upload/image_hosting/h5t1mz7x.png)

最优解为选择 $1\to2\to7$ 作为分割路径，不平衡度为 ${\large\vert}(2+19+19)-7{\large\vert}=33$。

如果选择 $1\to2\to6$ 作为分割路径，那么两部分的边的总重之差为 ${\large\vert}(2+19)-(7+514){\large\vert}=500$，不为最小值。

$\color{transparent}\sout{不知道你们发现没有\begin{cases}114+2+19+19=154\\114+514+19+19=666\end{cases}}$

**【样例 $\bm1-\bm2$ 解释】**

该树如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/14a0rhpe.png)

最优解为选择 $1\to7$ 作为分割路径，不平衡度为 ${\large\vert}(4+8+3+6)-(1+7+5+10){\large\vert}=2$。

## 样例 #1

### 输入

```
2 1
7
3 3 2 2 114 4 7
3 5 19 6 19 7 514
0
0
0
0
0

11
5 2 4 3 9 8 1 9 7 11 10
0
3 4 8 5 3 7 2
0
1 6 6
0
0
0
1 10 5
0
0```

### 输出

```
33
2```

## 样例 #2

### 输入

```
2 2
7
3 3 2 2 114 4 7
3 5 19 6 19 7 514
0
0
0
0
0

11
5 2 4 3 9 8 1 9 7 11 10
0
3 4 8 5 3 7 2
0
1 6 6
0
0
0
1 10 5
0
0```

### 输出

```
33 38 0 0 0 0 0
2 0 6 0 0 0 0 0 0 0 0```

# AI分析结果



### 综合分析与结论
本题核心在于如何高效计算树的分割路径左右边权差最小值。各解法主要采用前缀和预处理+二分优化的思路，针对不同数据规模设计了分层策略。最优解法通过DFS维护路径累计值，利用单调性进行二分查找，达到线性或线性对数复杂度。

---

### 精选题解列表

#### 1. 作者：y_kx_b（★★★★★）
**关键亮点**  
- 分层处理不同子任务，思路清晰  
- 对k=1用简单DFS维护左右累计值，时间复杂度O(n)  
- 对k=2巧妙利用DFS序划分子树范围，结合前缀和二分实现O(n log n)  
**个人心得**  
> "前向星遍历顺序与输入顺序相反，但本题左右对称不影响结果"  
> "五点七边二分法有效处理零点查找"  

**核心代码思想**  
```cpp
// 预处理每个子树的范围和累计值
void dfs0(int u, int W2) {
    if(叶子节点) 记录当前累计值到数组;
    for(所有子节点) {
        递归处理子树;
        维护子树边权和wsum[u];
    }
}

// 二分查找最优解
int l = 子树左边界, r = 子树右边界;
while(l+1 < r) {
    int mid = (l+r)>>1;
    if(差值函数>=0) l=mid; else r=mid;
}
ans = min(abs(f(l)), abs(f(r)));
```

#### 2. 作者：tokitsukaze（★★★★☆）
**关键亮点**  
- 提出启发式合并优化暴力解法  
- 使用懒标记处理子树合并的权值偏移  
- 将时间复杂度优化至O(n log²n)  

**核心实现技巧**  
```cpp
// 启发式合并子树集合
void mer(int x,int y) {
    if(x集合较小) 合并到y集合，并更新懒标记;
    合并后保留大集合;
}

// 维护带懒标记的权值集合
lazy[find_set(v.fi)] += 当前分割偏移量;
ans通过lower_bound查找最接近零点的值;
```

---

### 最优关键思路总结
1. **前缀和预处理**：通过DFS维护路径累计值(w1左累计，w2路径累计)  
2. **单调性利用**：左右差值函数随叶子顺序单调变化，允许二分查找  
3. **子树范围划分**：通过DFS序确定子树叶子区间，实现子树独立计算  
4. **启发式合并**：对k=2的大规模数据，采用带懒标记的集合合并策略  

---

### 相似题目推荐
1. [P1395 会议](https://www.luogu.com.cn/problem/P1395) - 树的重心与路径统计  
2. [P3178 [HAOI2015]树上操作](https://www.luogu.com.cn/problem/P3178) - 树上前缀和与子树操作  
3. [P3384 【模板】轻重链剖分](https://www.luogu.com.cn/problem/P3384) - 子树区间划分与操作  

---

### 调试经验与技巧
1. **避免全局memset**：大规模数据时使用局部初始化（y_kx_b的upd1）  
2. **懒标记传递**：启发式合并时注意标记叠加顺序（tokitsukaze代码）  
3. **链式前向星特性**：注意遍历顺序与输入顺序的镜像关系  
4. **边界处理**：空子树、单节点树需特殊处理（如wsum初始化为0）

---
处理用时：66.50秒
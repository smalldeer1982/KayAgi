# 题目信息

# [KMOI R1] 军事行动

## 题目背景

$$\blue{他们来了。}$$

$$\purple{集结军队，干掉他们，一个不留。}$$

$$\blue{是！}$$

## 题目描述

喵星边境局势愈发紧张，导致发生边境冲突。喵星军队总司令小袁立即对 $Y$ 星采取军事行动。

整个宇宙可以看作一个平面直角坐标系，城市 $1,2,\dots,n$ 的坐标分别为 $(x_1,y_1),(x_2,y_2),\dots(x_n,y_n)$。

现在小袁率领的**若干支**舰队（可以理解为小袁的军事力量是无限的）驻扎在边境要塞，城市 $1$ 处。他的舰队会进行以下移动：

- 如果舰队的坐标为 $(x,y)$，那么一天之后它可以移动到 $(x-1,y+2)$ 或 $(x+1,y+2)$ 或 $(x+2,y+1)$ 或 $(x-2,y+1)$ 或 $(x-1,y-2)$ 或 $(x+1,y-2)$ 或 $(x+2,y-1)$ 或 $(x-2,y-1)$ 处。

其中环绕在外的还有一条小行星带，当舰队的坐标  $(x,y)$ 且 $x\le 0$ 或 $y\le 0$ 或 $m < x$ 或 $m < y$ 时，舰队就会撞到小行星带。这是小袁所不想看到的。

现在小袁要攻打城市 $2,3,\dots,n$，每一次他都会从一个**已经占领**的城市（城市 $1$ 也算），派出舰队前往城市 $i$ 并攻打它，舰队**到达之后的第二天**城市 $i$ 就被攻占了。

特别的，小袁在一个舰队**前往攻打或攻打一个城市**的时候不会派出另外一支舰队，在**攻占一座城市后当天**可以立即派出另外一支舰队。

小袁想问，最少要花多少时间才能攻占所有的城市。

**攻打顺序可以不按照 $2,3\dots n$ 的顺序。**

## 说明/提示

## 样例一解释：

舰队在第一天来到了 $(3,2)$ 的位置，第二天到达了城市 $2$ 的位置，第三天占领了城市 $2$。总共花了 $3$ 天。

## 样例二解释：

舰队在第一天到达了城市 $2$ 的位置，第二天占领了城市 $2$。第三天到达了城市 $3$ 的位置，第四天占领了城市 $3$。总共花了 $4$ 天。

## 数据范围

**本题采用 Subtask 捆绑测试。**

|子任务编号|  测试点编号| $n$ | $m$ |特殊性质|分值|
|:-----:| :----------: | :----------: | :----------: | :----------: |:---:|
|$1$| $1\sim2$ | $1\le n\le 7$ |$4\le m\le 7$|无|$10$|
|$2$| $3\sim7$ | $1\le n\le 200$ |$4\le m\le 70$|无|$25$|
|$3$| $8\sim9$ | $1\le n\le 150$ |$4\le m\le 150$|有|$15$|
|$4$| $10\sim20$ | $1\le n\le 2000$ |$4\le m\le 150$|无|$50$|

特殊性质：对于每一个 $1\le i\le n-1$，都有 $x_i = x_{i+1}$。

**数据严格保证不会有不同的城市拥有相同的坐标。**

## 样例 #1

### 输入

```
2 20
1 1
1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
3 150
1 2
2 4
4 3```

### 输出

```
4```

## 样例 #3

### 输入

```
10 10
1 4
2 3
2 6
3 6
10 3
1 5
4 2
5 3
2 8
9 2```

### 输出

```
23```

## 样例 #4

### 输入

```
查看附件的 example4.in```

### 输出

```
查看附件的 example4.out```

# AI分析结果



### 综合分析与结论
题目核心是通过类似"马走日"的移动方式，求攻占所有城市的最小时间。所有题解均采用**最小生成树（MST）**思想，核心步骤为：
1. **预处理点间最短距离**：通过BFS计算每个城市到其他城市的马步距离
2. **构建完全图**：将每个城市视为节点，边权为移动天数
3. **求解MST**：总边权加上(n-1)天攻占时间即为答案

关键优化点在于对完全图选择Prim算法更优（O(n²)），而Kruskal在边数过多时效率较低（O(n² logn)）。部分题解尝试数学推导距离但存在错误风险，BFS预处理更为可靠。

---

### 优质题解推荐

#### 1. 作者：Fire_flame（Kruskal版本） ★★★★☆
**核心亮点**：
- 清晰的BFS预处理框架
- 标准化Kruskal实现易理解
- 完整处理移动方向与越界判断
**关键代码**：
```cpp
void bfs(int sx, int sy) {
    queue<step> q;
    q.push({sx, sy, 0});
    memset(f, 0, sizeof(f));
    f[sx][sy] = 1;
    while(!q.empty()) {
        // 遍历8个方向，记录首次到达时的步数
        if(mp[px][py])e[++cnt] = {mp[sx][sy], mp[px][py], tl + 1}; 
        f[px][py] = 1; // 入队即标记避免重复
        q.push({px, py, tl + 1});
    }
}
```

#### 2. 作者：Night_sea_64（Prim版本） ★★★★★  
**核心亮点**：
- 针对完全图选择Prim算法更优
- 动态BFS更新距离数组
- 空间优化（二维坐标映射）
**关键实现**：
```cpp
void bfs(int s) {
    // BFS后更新所有点到当前集合的最小距离
    for(int j=1;j<=n;j++) 
        g[i][j] = dis[xx[j]][yy[j]]; 
}

// Prim核心
for(int i=1;i<=n;i++) {
    int minn=1e9,minid;
    for(int j=1;j<=n;j++) // 选取最近点
        if(d[j]<minn && !f[j]) minid=j;
    for(int j=1;j<=n;j++) // 松弛相邻点
        d[j] = min(d[j], g[minid][j]);
}
```

#### 3. 作者：TruchyR（优化版Prim） ★★★★☆
**创新点**：
- 增量式BFS更新距离
- 优先队列优化松弛过程
**核心技巧**：
```cpp
priority_queue<node,vector<node>,greater<node>> q;
while(!q.empty()) {
    // 每次从优先队列取最小距离点
    if(mp[x][y]==2) continue; // 已占领剪枝
    for(8方向扩展新点) {
        if(新距离 < 当前记录) 更新并入队
    }
}
```

---

### 关键思路与技巧
1. **BFS预处理优化**：
   - 入队时立即标记访问状态（防止重复入队）
   - 对每个起点独立进行BFS，记录二维坐标最短步数
   - 空间换时间：使用二维数组存储各点最短距离

2. **MST算法选择**：
   - **稠密图优先Prim**：完全图边数n²时，Prim的O(n²)优于Kruskal的O(n² logn)
   - **动态更新距离**：部分题解在Prim过程中动态BFS更新距离，减少预处理时间

3. **时间计算细节**：
   - 移动天数 = BFS步数
   - 总时间 = MST边权和 + (n-1)（每个城市攻占耗时）

---

### 拓展与举一反三
1. **同类问题**：
   - 棋盘类最短路径（P1746 离开中山路）
   - 动态更新的MST问题（P1265 公路修建）
   - 多维空间距离计算（P7883 平面最近点对）

2. **推荐练习题**：
   - P3366 【模板】最小生成树（基础MST）
   - P2330 [SCOI2005] 繁忙的都市（MST应用）
   - P1991 无线通讯网（MST+最远距离）

---

### 题解心得摘录
1. **作者sbno333**：  
   > "比赛时担心MST超时改用优先队列搜索，结果比MST快10倍。调试中发现攻占时间计算错误，漏加n-1导致WA"

2. **作者_Flame_**：  
   > "尝试数学公式推导距离，但发现无法覆盖所有情况，最终回归BFS预处理"

3. **作者lovely_hyzhuo**：  
   > "BFS建边时忘记处理坐标越界，导致RE。建议增加边界判断：if(vx<1||vy<1||vx>m||vy>m)" 

总结：调试重点应关注边界条件与时间计算细节，数学推导需谨慎验证所有情况。

---
处理用时：82.75秒
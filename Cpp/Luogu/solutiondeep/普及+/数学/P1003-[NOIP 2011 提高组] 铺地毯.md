# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何高效地找到覆盖某个点的最上层地毯。由于数据范围较大（$n \le 10^4$，坐标范围 $0 \le a, b, g, k \le 10^5$），直接使用二维数组存储每个点的地毯编号会导致内存溢出（MLE）。因此，大多数题解采用了以下两种优化思路：

1. **存储地毯信息并逐个检查**：通过存储每张地毯的左上角坐标和尺寸，逐个检查目标点是否被该地毯覆盖。这种方法避免了二维数组的内存开销，时间复杂度为 $O(n)$。
2. **逆序遍历地毯**：由于后铺的地毯覆盖先铺的地毯，可以从后向前遍历地毯，找到第一个覆盖目标点的地毯即可。这种方法在平均情况下可以减少遍历次数。

### 所选高星题解

#### 1. 作者：智子 (5星)
**关键亮点**：
- 清晰指出了二维数组的内存问题，并提出了优化方案。
- 代码简洁，使用了四个数组分别存储地毯的左上角坐标和尺寸，逐个检查目标点是否被覆盖。
- 代码可读性强，注释清晰。

**核心代码**：
```cpp
int a[MAXN], b[MAXN], g[MAXN], k[MAXN];

int main() {
    int n, x, y;
    scanf("%d", &n);
    for(int i = 0; i < n; i++) {
        scanf("%d%d%d%d", &a[i], &b[i], &g[i], &k[i]);
    }
    scanf("%d%d", &x, &y);
    
    int ans = -1;
    for(int i = 0; i < n; i++) {
        if(x >= a[i] && y >= b[i] && x <= a[i] + g[i] && y <= b[i] + k[i]) {
            ans = i + 1;
        }
    }
    
    printf("%d\n", ans);
    return 0;
}
```

#### 2. 作者：FreedomKing (4星)
**关键亮点**：
- 思路清晰，直接枚举所有地毯，判断是否覆盖目标点。
- 代码简洁，使用了结构体数组存储地毯信息，逐个检查目标点是否被覆盖。
- 代码可读性强，注释清晰。

**核心代码**：
```cpp
struct dt{
    int a,b,g,k;
}c[542457];

int main(){
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        cin>>c[i].a>>c[i].b>>c[i].g>>c[i].k;
    }
    int ans=-1;
    int x,y;cin>>x>>y;
    for(int i=1;i<=n;i++){
        if(x>=c[i].a&&x<=c[i].a+c[i].g && y>=c[i].b&&y<=c[i].b+c[i].k){
            ans=i;
        }
    }
    cout<<ans;
    return 0;
}
```

#### 3. 作者：谁懂谁伤心 (4星)
**关键亮点**：
- 采用逆序遍历地毯，找到第一个覆盖目标点的地毯即可。
- 代码简洁，使用了两个数组分别存储地毯的左上角和右下角坐标，逐个检查目标点是否被覆盖。
- 代码可读性强，注释清晰。

**核心代码**：
```cpp
int a[10001][2],b[10001][2],x,y,i,n,m;

int main() {
    scanf ("%d",&i); 
    for (int j=1;j<=i;j++) {
        scanf("%d%d%d%d",&a[j][0],&a[j][1],&n,&m); 
        b[j][0]=a[j][0]+n; 
        b[j][1]=a[j][1]+m;
    }
    scanf ("%d%d",&x,&y);
    for (int j=i;j>=1;j--) {
        if (x>=a[j][0]&&x<=b[j][0]&&y>=a[j][1]&&y<=b[j][1]) {
            printf("%d",j);  
            return 0;
        }
    }
    cout <<-1;  
    return 0;
}
```

### 最优关键思路与技巧

1. **避免二维数组**：由于数据范围较大，直接使用二维数组会导致内存溢出。通过存储地毯的左上角坐标和尺寸，逐个检查目标点是否被覆盖，可以有效减少内存开销。
2. **逆序遍历**：由于后铺的地毯覆盖先铺的地毯，逆序遍历可以减少平均情况下的遍历次数，提高效率。

### 可拓展之处

- **类似问题**：类似的问题可以扩展到三维空间，或者多个查询点的情况。可以通过空间索引（如四叉树、R树）来优化查询效率。
- **算法套路**：在处理覆盖问题时，可以考虑使用逆序遍历或空间索引来优化查询效率。

### 推荐相似题目

1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3372 线段树 1](https://www.luogu.com.cn/problem/P3372)

### 个人心得总结

- **调试经历**：在调试过程中，发现二维数组的内存开销过大，导致内存溢出。通过优化存储结构，成功解决了问题。
- **踩坑教训**：在处理大数据范围时，应避免使用高维数组，考虑使用更高效的数据结构。
- **顿悟感想**：通过逆序遍历地毯，可以快速找到覆盖目标点的最上层地毯，这种方法在类似问题中具有通用性。

---
处理用时：35.23秒
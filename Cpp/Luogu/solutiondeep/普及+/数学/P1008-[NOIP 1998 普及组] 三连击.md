# 题目信息

# [NOIP 1998 普及组] 三连击

## 题目背景

本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。

## 题目描述

将 $1, 2, \ldots , 9$ 共 $9$ 个数分成 $3$ 组，分别组成 $3$ 个三位数，且使这 $3$ 个三位数构成 $1 : 2 : 3$ 的比例，试求出所有满足条件的 $3$ 个三位数。

## 说明/提示

NOIP1998 普及组 第一题

## 样例 #1

### 输入

```
无```

### 输出

```
192 384 576
* * *
...

* * *
（剩余部分不予展示）```

# AI分析结果

### 综合分析与结论

本题的核心任务是找到三个三位数，满足1:2:3的比例，并且这三个数的每一位数字都是1到9且不重复。题解中主要采用了以下几种思路：

1. **枚举法**：通过枚举第一个数，计算第二个和第三个数，再检查是否满足条件。这是最常见的解法，复杂度较低。
2. **全排列法**：生成1到9的所有排列，再检查是否满足比例关系。这种方法虽然直观，但复杂度较高（O(9!)）。
3. **数学优化**：利用数字和与积的唯一性，减少不必要的枚举。这种方法在数学上有一定优化，但代码实现较为复杂。

大多数题解都采用了枚举法，结合一些优化手段（如提前判断数字是否重复、利用数字和与积的唯一性等）来提高效率。整体来看，枚举法是最优的解决方案，代码简洁且效率较高。

### 所选高星题解

#### 1. **Kelin (5星)**
- **关键亮点**：代码简洁，逻辑清晰，通过提前计算数字的每一位并统计是否重复，避免了复杂的判断逻辑。代码中使用了`memset`来清零数组，提升了代码的可读性。
- **个人心得**：作者提到“其实不知道的情况下简单来说是从123-329的但是算出来是最值就稍微改了下下”，表明通过计算优化了枚举范围，减少了不必要的计算。

```cpp
for(i=192;i<=327;i++) {
    memset(a,0,sizeof(a));v=0;
    a[i%10]=a[i/10%10]=a[i/100]=a[i*2%10]=a[i*2/10%10]=a[i*2/100]=a[i*3%10]=a[i*3/10%10]=a[i*3/100]=1;
    for(j=1;j<=9;j++) v+=a[j];
    if(v==9) printf("%d %d %d\n",i,i*2,i*3);
}
```

#### 2. **鸩羽 (4星)**
- **关键亮点**：通过函数拆分数字的每一位，并使用计数器统计数字是否重复，代码结构清晰，易于理解。
- **个人心得**：作者提到“其实可以用memset重置，但是懒得修改了”，表明在代码优化上有一定的思考，但未完全实现。

```cpp
void cf(int x){
    while(x!=0){        
        gw=x%10;
        x=(x-gw)/10;
        d[gw]++;
    }
}
```

#### 3. **Drug__Lover (4星)**
- **关键亮点**：利用数字和与积的唯一性进行判断，减少了重复枚举的次数，代码简洁且高效。
- **个人心得**：作者提到“因为1~9这些数加起来和乘起来之后是一定的，所以可以用这个判断哈”，表明通过数学优化减少了计算量。

```cpp
if(a[1]*a[2]*a[3]*b[1]*b[2]*b[3]*c[1]*c[2]*c[3]==362880&&a[1]+a[2]+a[3]+b[1]+b[2]+b[3]+c[1]+c[2]+c[3]==45) {
    cout<<i<<" "<<i*2<<" "<<i*3<<endl;
}
```

### 最优关键思路与技巧

1. **枚举法**：通过枚举第一个数，计算第二个和第三个数，再检查是否满足条件。这是最优的解决方案，复杂度较低。
2. **数字统计**：通过统计每个数字的出现次数，判断是否重复，避免复杂的逻辑判断。
3. **数学优化**：利用数字和与积的唯一性，减少不必要的枚举，提升效率。

### 可拓展之处

本题可以拓展到其他比例关系（如1:3:5）或更多位数的组合（如四位数）。类似的题目可以通过枚举法结合数学优化来解决。

### 推荐题目

1. **P1008 三连击**（本题）
2. **P1036 选数**（枚举与组合）
3. **P1217 [USACO1.5]回文质数 Prime Palindromes**（枚举与数学优化）

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中发现枚举范围可以优化，减少了不必要的计算。
- **踩坑教训**：一些作者提到在代码优化时未完全实现（如使用`memset`），表明在代码优化上仍有改进空间。
- **顿悟感想**：通过数学优化（如数字和与积的唯一性）可以显著减少计算量，提升代码效率。

---
处理用时：31.73秒
# 题目信息

# [NOIP 1998 普及组] 阶乘之和

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题

## 样例 #1

### 输入

```
3
```

### 输出

```
9```

# AI分析结果

### 综合分析与结论

本题的核心在于高精度计算，涉及阶乘和累加操作。由于阶乘增长迅速，普通的数据类型无法存储大数，因此需要使用高精度算法。题解中主要采用了以下几种思路：

1. **高精度乘法与加法结合**：大多数题解通过高精度乘法计算阶乘，再通过高精度加法累加结果。
2. **重载运算符**：部分题解通过重载运算符简化了高精度计算的代码，提升了可读性。
3. **递推与记忆化**：部分题解通过递推或记忆化优化了阶乘的计算过程，减少了重复计算。
4. **Python自带高精度**：部分题解利用Python自带的高精度特性，简化了代码实现。

### 所选高星题解

#### 1. **作者：C_Z_C (4星)**
- **关键亮点**：代码结构清晰，高精度乘法和加法的实现较为简洁，适合初学者理解。
- **个人心得**：作者提到“昨天用了半天才写完了这篇橙题代码”，体现了调试过程中的耐心与坚持。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,a[90],b[90],c[90],f[90],d=0,len_a,len_b=1,len_c=1,len_ans,m=1;
string s;
int main(){
    cin>>n;
    b[0]=1; //初始化
    for(int i=1;i<=n;i++){ //计算i的阶乘，已经算好了i-1的阶乘
        len_a=0; //i的长度
        int p=i;
        while(p>0){ //把i存进a数组
            a[len_a++]=p%10;
            p/=10;
        }
        for(int j=0;j<len_a;j++) //计算a*b（i*（i-1）的阶乘），即i的阶乘
            for(int k=0;k<=len_b;k++)
                c[j+k]+=a[j]*b[k];
        for(int j=0;j<len_c;j++) //需要进位的就进位
            if(c[j]>9) c[j+1]+=c[j]/10,c[j]%=10;
        if(c[len_c]) len_c++; //看最高位要不要进位
        len_ans=len_b,len_b=len_c,m=max(m,len_c); //把len_b赋值给len_ans，修改len_b的值
        for(int k=len_c-1;k>=0;k--) b[k]=c[k]; //把c存进b数组，即存进i的阶乘
        len_c=len_a+len_ans;
        memset(c,0,sizeof(c)); //清零c数组，准备计算下个阶乘
        for(int j=0;j<m;j++){ //高精加，直接套模板
            f[j]+=b[j];
            if(f[j]>9) f[j+1]+=f[j]/10,f[j]%=10; //进位
        }
    }
    while(!f[m]&&m>0) m--; //去掉首导零
    for(int i=m;i>=0;i--) cout<<f[i]; //倒序输出
    return 0; //圆满结束
}
```

#### 2. **作者：wuhao1027 (4星)**
- **关键亮点**：代码简洁，高精度乘法和加法的实现较为高效，适合有一定基础的读者。
- **个人心得**：作者强调“注意代码风格”，体现了对代码质量的重视。

```cpp
#include<stdio.h>
int main()
{
    int i,A[1005]={0},B[1005]={0},n,j;
    scanf("%d", &n);
    A[0]=B[0]=1;
    for (i=2;i<=n;i++){
        for (j=0;j<100;j++)
            B[j]*=i;
        for (j=0;j<100;j++)
            if (B[j]>9){
                B[j+1] += B[j]/10;
                B[j]%=10;
            }
        for (j=0;j<100;j++){
            A[j]+=B[j];
            if (A[j]>9) {
                A[j+1] += A[j]/10;
                A[j]%=10;
            }
        }
    }
    for (i=100;i>=0&&A[i]==0;i--);
    for (j=i;j>=0;j--) printf("%d", A[j]);
    return 0;
}
```

#### 3. **作者：Nortrom (4星)**
- **关键亮点**：将高精度乘法和加法封装成函数，代码结构清晰，便于复用。
- **个人心得**：作者提到“拒绝复制粘贴的做题法”，强调了独立思考和代码原创的重要性。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,a[101]={0},s[101]={0};
void change(int x)
{
    int g=0;
    for(int i=100;i>=0;i--)
    {
        a[i]=a[i]*x+g;
        g=a[i]/10;
        a[i]=a[i]%10;
    }
}
void qh()
{
    int g=0;
    for(int i=100;i>=0;i--)
    {
        s[i]=s[i]+a[i]+g;
        g=s[i]/10;
        s[i]=s[i]%10;
    }
}
int main()
{
    scanf("%d",&n);
    s[100]=a[100]=1;
    for(int i=2;i<=n;i++)
    {
        change(i);
        qh();
    }
    for(int i=0;i<=100;i++)
    {
        if(s[i]!=0)
        {
            for(int j=i;j<=100;j++)
               printf("%d",s[j]);
            break;
        }
    }
    return 0;
}
```

### 最优关键思路与技巧

1. **高精度乘法的优化**：通过逐位相乘并处理进位，避免了直接使用大数乘法的复杂性。
2. **高精度加法的优化**：通过逐位相加并处理进位，确保结果的正确性。
3. **递推与记忆化**：通过递推计算阶乘，减少重复计算，提升效率。
4. **重载运算符**：通过重载运算符简化高精度计算的代码，提升可读性。

### 推荐相似题目

1. **P1009 阶乘之和**：本题的变种，考察高精度计算。
2. **P1045 麦森数**：涉及大数计算与高精度乘法。
3. **P1255 数楼梯**：考察高精度加法与递推。

### 个人心得总结

- **调试与坚持**：多位作者提到调试过程中的耐心与坚持，体现了编程中的常见挑战与应对策略。
- **代码风格与质量**：部分作者强调代码风格的重要性，提醒读者在编写代码时注重可读性与规范性。
- **独立思考与原创**：拒绝复制粘贴，强调独立思考和代码原创，是提升编程能力的关键。

---
处理用时：49.16秒
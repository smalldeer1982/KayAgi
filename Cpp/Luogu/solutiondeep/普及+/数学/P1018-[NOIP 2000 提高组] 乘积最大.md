# 题目信息

# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在数字串中插入乘号以最大化乘积。由于数字串长度可能达到40位，直接使用普通整数类型无法处理，因此必须使用高精度算法。大多数题解采用了动态规划（DP）或深度优先搜索（DFS）的思路，结合高精度乘法来实现。DP解法通过状态转移方程逐步计算最大乘积，而DFS则通过枚举乘号位置并剪枝来优化搜索过程。

### 所选高星题解

#### 1. 题解作者：liar_white (赞：416)
- **星级**：★★★★★
- **关键亮点**：
  - 使用DP结合高精度乘法，思路清晰，代码结构良好。
  - 通过`cut[i][j]`数组存储在第i个数字后放第j个乘号的最大乘积，状态转移方程明确。
  - 高精度乘法和比较函数实现简洁，易于理解。
- **个人心得**：
  - 作者提到直接写`lastans=Max(lastans,ans[i])`会出错，通过中间变量解决，体现了调试中的细节处理。

**核心代码片段**：
```cpp
node mul(node e1,node e2){//高精度乘法
    node emul;
    emul.exi=true;emul.v=e1.v+e2.v-1;
    for(int i=1;i<=emul.v;i++) emul.c[i]=0;
    for(int i=1;i<=e1.v;i++)
        for(int j=1;j<=e2.v;j++)
            emul.c[i+j-1]+=e1.c[i]*e2.c[j];
    int q=0;        
    for(int i=1;i<=emul.v;i++){
        emul.c[i]+=q;
        q=emul.c[i]/10;
        emul.c[i]%=10;
    }
    while(q>0){
        emul.c[++emul.v]=q%10;
        q/=10;
    }
    return emul;
}
```

#### 2. 题解作者：FastIO_DP (赞：1)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用DP结合高精度乘法，状态定义和转移方程清晰。
  - 通过`dp[i][j]`表示前i个数字分成j+1部分的最大乘积，状态转移方程明确。
  - 高精度乘法实现简洁，代码可读性高。
- **个人心得**：
  - 作者提到答案可能超`long long`，必须使用高精度，体现了对数据范围的敏感。

**核心代码片段**：
```cpp
BI operator*(const BI& o) const {
    BI res;
    for (int i = 0; i < len; ++i) {
        int c = 0;
        for (int j = 0; j < o.len; ++j) {
            int p = d[i] * o.d[j] + res.d[i + j] + c;
            res.d[i + j] = p % 10;
            c = p / 10;
        }
        if (c) {
            res.d[i + o.len] += c;
        }
    }
    res.len = len + o.len;
    while (res.len > 1 && res.d[res.len - 1] == 0) {
        res.len--;
    }
    return res;
}
```

#### 3. 题解作者：kuaiCreator (赞：1)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用DP结合高精度乘法，状态定义和转移方程清晰。
  - 通过`f(i,j)`表示前i个数字字符插入j个乘号的最大乘积，状态转移方程明确。
  - 高精度乘法实现简洁，代码可读性高。
- **个人心得**：
  - 作者提到初始化状态和边界状态的处理，体现了对DP初始化的重视。

**核心代码片段**：
```cpp
for (int i = 1; i <= n; i++)          //初始化边界状态
    dp[i][0] = num[1][i]; 

for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {     //j<i表示i个数最多插入i-1个乘号
        if (j >= i) break;  //前i个元素不能被插入j个隔板分成j+1份
        for (int k = j; k < i; k++)    //前k个元素最多插入j-1个符号故k从j开始枚举
            dp[i][j] = max(dp[i][j], dp[k][j - 1] * num[k + 1][i]);
    }
```

### 最优关键思路与技巧

1. **高精度乘法**：由于数字串长度可能达到40位，必须使用高精度乘法来处理大数运算。
2. **动态规划**：通过定义状态`dp[i][j]`表示前i个数字分成j+1部分的最大乘积，逐步计算最大乘积。
3. **DFS剪枝**：在DFS解法中，通过剪枝优化搜索过程，减少不必要的计算。

### 可拓展之处

1. **类似题目**：可以扩展到其他需要高精度计算的题目，如大数加法、减法、除法等。
2. **DP优化**：可以进一步优化DP的状态转移方程，减少时间复杂度。

### 推荐题目

1. [P1009 阶乘之和](https://www.luogu.com.cn/problem/P1009)
2. [P1010 幂次方](https://www.luogu.com.cn/problem/P1010)
3. [P1011 大整数加法](https://www.luogu.com.cn/problem/P1011)

### 个人心得总结

- **调试细节**：在实现高精度乘法时，注意进位处理和位数调整，避免出错。
- **状态初始化**：在DP解法中，初始化状态和边界状态的处理非常重要，确保状态转移的正确性。
- **剪枝优化**：在DFS解法中，通过剪枝减少不必要的计算，提高算法效率。

---
处理用时：39.20秒
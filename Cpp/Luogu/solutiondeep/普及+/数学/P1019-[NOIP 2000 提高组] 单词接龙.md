# 题目信息

# [NOIP 2000 提高组] 单词接龙

## 题目背景

注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

NOIP2000 提高组 T3

## 题目描述

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。


## 说明/提示

样例解释：连成的“龙”为 `atoucheatactactouchoose`。

$n \le 20$。

## 样例 #1

### 输入

```
5
at
touch
cheat
choose
tact
a
```

### 输出

```
23
```

# AI分析结果

### 综合分析与结论

这两篇题解都采用了深度优先搜索（DFS）来解决单词接龙问题，核心思路相似，但在代码实现和细节处理上有所不同。RyanLi的题解代码简洁，直接通过DFS枚举所有可能的单词连接方式，并在搜索过程中处理单词的重合部分。SuyctidohanQ的题解则更加详细，引入了额外的函数 `check` 来验证两个单词是否可以连接，代码结构较为复杂，但逻辑清晰。

### 所选高星题解

#### 1. RyanLi的题解（4星）
- **关键亮点**：代码简洁，直接通过DFS枚举所有可能的单词连接方式，并在搜索过程中处理单词的重合部分。使用了 `substr` 方法来截取字符串，处理边界问题。
- **核心代码**：
  ```cpp
  void dfs(const string &tmp) {
      ans = max(ans, int(tmp.size()));
      for (int i = 1; i <= n; ++i) {
          if (vis[i] >= 2) continue;
          for (int j = 1; j < min(tmp.size(), s[i].size()); ++j)
              if (tmp.substr(tmp.size() - j) == s[i].substr(0, j)) {
                  ++vis[i];
                  dfs(tmp + s[i].substr(j));
                  --vis[i];
              }
      }
  }
  ```

#### 2. SuyctidohanQ的题解（4星）
- **关键亮点**：引入了 `check` 函数来验证两个单词是否可以连接，代码结构较为复杂但逻辑清晰。使用了 `cnt` 数组来记录每个单词的使用次数，确保每个单词最多使用两次。
- **核心代码**：
  ```cpp
  int check (string x, string y) {
      string a = "", b = "";
      rep(i, 1, min (x.size (), y.size ()) - 1) {
          a = x.substr (x.size () - i, i);
          b = y.substr (0, i);
          if (a == b) return i;
      }
      return 0;
  }

  void dfs (str s, int len) {
      ans = max (ans, len);
      int x;
      for (int i = 1; i <= n; i ++) {
          x = check (s, S[i]);
          if (cnt[i] < 2 && x != 0) {
              cnt[i] ++;
              dfs (S[i], len + S[i].size () - x);
              cnt[i] --;
          }
      }
  }
  ```

### 最优关键思路与技巧

- **DFS搜索**：通过深度优先搜索枚举所有可能的单词连接方式，确保找到最长的“龙”。
- **字符串处理**：使用 `substr` 方法截取字符串，处理单词的重合部分，确保连接的正确性。
- **使用次数限制**：通过 `vis` 或 `cnt` 数组记录每个单词的使用次数，确保每个单词最多使用两次。

### 可拓展之处

- **类似题目**：可以拓展到其他需要枚举所有可能组合的题目，如排列组合问题、路径搜索问题等。
- **优化思路**：可以考虑使用剪枝技术优化搜索过程，减少不必要的搜索路径。

### 推荐题目

1. **P1018 [NOIP 2000 提高组] 乘积最大**：考察字符串处理和动态规划。
2. **P1020 [NOIP 2000 提高组] 导弹拦截**：考察动态规划和搜索算法。
3. **P1021 [NOIP 2000 提高组] 统计单词个数**：考察字符串处理和搜索算法。

### 个人心得总结

- **调试经历**：在处理字符串边界问题时，容易出现越界错误，需要仔细检查 `substr` 方法的参数。
- **踩坑教训**：在DFS中，忘记回溯会导致结果错误，必须确保在每次递归调用后恢复状态。
- **顿悟感想**：通过DFS枚举所有可能的组合，虽然时间复杂度较高，但在数据范围较小的情况下是可行的。

---
处理用时：24.71秒
# 题目信息

# [NOIP 2001 提高组] 统计单词个数

## 题目描述

给出一个长度不超过 $200$ 的由小写英文字母组成的字母串（该字串以每行 $20$ 个字母的方式输入，且保证每行一定为 $20$ 个）。要求将此字母串分成
 $k$ 份，且每份中包含的单词个数加起来总数最大。  

每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串 `this` 中可包含 `this` 和 `is`，选用 `this` 之后就不能包含
 `th`。

单词在给出的一个不超过 $6$ 个单词的字典中。

要求输出最大的个数。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$2 \le k \le 40$，$1 \le s \le 6$。

【样例解释】
划分方案为 this / isabookyoua / reaoh

**【题目来源】**

NOIP 2001 提高组第三题

## 样例 #1

### 输入

```
1 3
thisisabookyouareaoh
4
is
a
ok
sab
```

### 输出

```
7
```

# AI分析结果

### 综合分析与结论

本题解通过动态规划（DP）的思路，将问题转化为在字符串中放置分割线，并计算每个区间对答案的贡献。题解的核心在于如何高效地统计每个区间内包含的单词数量，并利用DP进行状态转移。虽然思路清晰，但代码实现较为复杂，尤其是`query`函数的实现，涉及到多重循环和字符串匹配，可能会导致性能问题。整体上，题解的思路是正确的，但在代码优化和可读性上还有提升空间。

### 所选题解

#### 题解：千反田 (赞：5)
- **星级**: 4星
- **关键亮点**: 
  - 使用动态规划（DP）进行状态转移，思路清晰。
  - 通过`query`函数统计区间内单词数量，考虑了单词重叠的限制。
  - 代码结构完整，包含初始化、DP转移和最终答案统计。
- **个人心得**: 
  - 作者提到第一次提交时忘记注释掉调试代码，但仍然获得了部分分数，说明评测机在某些情况下对代码的容错性较高。
  - 通过手写`max`和`min`函数来提高代码效率，体现了对性能的重视。

### 核心代码片段

```cpp
inline int cnt(int index, int l, int r) {
    int len = r - l - strlen(word[index] + 1) + 2, res = 0;
    rep(i, 0, len - 1)
        rep(j, 1, strlen(word[index] + 1))
            if ((word[index][j] ^ str[l + i + j - 1]) || (trace[l + i]))
                break;
            else
                if (j == strlen(word[index] + 1))
                    ++res, trace[l + i] = true;
    return res;
}

inline int query(int l, int r) {
    rep(i, l, r)
        trace[i] = false;
    int res = 0;
    rep(i, 1, s)
        if (r - l + 1 >= strlen(word[i] + 1))
            res += cnt(i, l, r);
    return res;
}

void calc() {
    rep(i, 1, n - 1)
        f[i][1] = query(1, i);
    rep(j, 2, k)
        rep(i, j, n - 1)
            rep(l, j - 1, i - 1)
                f[i][j] = max(f[i][j], f[l][j - 1] + query(l + 1, i));
    rep(i, k, n - k)
        ans = max(ans, f[i][k] + query(i + 1, n));
}
```

### 最优关键思路或技巧

1. **动态规划（DP）**: 将问题转化为在字符串中放置分割线，并利用DP进行状态转移，计算每个区间对答案的贡献。
2. **区间统计**: 通过`query`函数统计每个区间内包含的单词数量，考虑单词重叠的限制。
3. **代码优化**: 手写`max`和`min`函数，提高代码效率。

### 可拓展之处

1. **字符串匹配优化**: 可以使用更高效的字符串匹配算法（如KMP算法）来优化`query`函数的性能。
2. **DP状态压缩**: 如果字符串长度较大，可以考虑使用状态压缩技巧来减少DP数组的空间复杂度。

### 推荐题目

1. [P1018 乘积最大](https://www.luogu.org/problem/P1018) - 类似的分割问题，考察DP的应用。
2. [P1040 加分二叉树](https://www.luogu.org/problem/P1040) - 考察DP和树形结构的结合。
3. [P1052 过河](https://www.luogu.org/problem/P1052) - 考察DP和状态压缩的应用。

### 总结

本题解通过动态规划的思路解决了字符串分割问题，虽然在代码实现上还有优化空间，但整体思路清晰，值得学习。通过优化字符串匹配和DP状态转移，可以进一步提升代码的性能和可读性。

---
处理用时：25.96秒
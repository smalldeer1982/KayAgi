# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果

### 综合分析与结论

本题的核心是通过拓扑排序模拟神经网络的信号传递过程，难点在于处理输入层、中间层和输出层的状态计算，以及阈值的处理。大部分题解都采用了拓扑排序的思路，但在细节处理上有所不同，尤其是输入层的阈值处理和输出层的判断。部分题解还通过优化代码结构、减少冗余操作来提升效率。

### 评分较高的题解

#### 1. 作者：Lucaster_ (赞：783)
- **星级**: 5星
- **关键亮点**: 
  - 代码结构清晰，注释详细，易于理解。
  - 通过队列实现拓扑排序，处理信号传递时直接减去阈值，简化了计算。
  - 使用了邻接表存储图结构，提高了空间效率。
  - 提供了详细的调试经历和优化过程，帮助读者理解代码的改进思路。
- **个人心得**: 
  - "调了一天终于调出来了，不得不说坑点还真不少。" —— 强调了调试过程中的挑战和最终的成功。

**核心代码片段**:
```cpp
while(!q.empty()) {
    h = q.front(); q.pop();
    for(i = hd[h]; i; i = e[i].next) {
        if(c[e[i].from] <= 0) continue;
        t = e[i].to;
        c[t] += (e[i].val * c[h]);
        if(!vis[t]) {
            q.push(t);
            vis[t] = true;
        }
    }
}
```
**核心思想**: 通过队列进行拓扑排序，确保每个节点的状态在计算时已经得到更新。

#### 2. 作者：zzlzk (赞：125)
- **星级**: 4星
- **关键亮点**: 
  - 通过栈实现拓扑排序，代码简洁。
  - 在输入时直接减去阈值，减少了后续计算的复杂度。
  - 详细解释了公式的推导过程，帮助读者理解题目要求。
- **个人心得**: 
  - "这道题并不是很难，就是细(keng)节(dian)有点多。" —— 强调了题目中的细节处理。

**核心代码片段**:
```cpp
void topo() {
    while(top != 0) {
        int u = st[top--];
        if(C[u] <= 0) continue;
        for(int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].v;
            C[v] += C[u] * edge[i].w;
            indeg[v]--;
            if(indeg[v] == 0) st[++top] = v;
        }
    }
}
```
**核心思想**: 通过栈实现拓扑排序，确保每个节点的状态在计算时已经得到更新。

#### 3. 作者：ghj1222 (赞：47)
- **星级**: 4星
- **关键亮点**: 
  - 通过暴力搜索入度为0的节点进行拓扑排序，代码简单易懂。
  - 在输入时直接减去阈值，减少了后续计算的复杂度。
  - 详细解释了输出层的判断条件，帮助读者理解题目要求。
- **个人心得**: 
  - "本题坑点较多，注意只输出大于0的输出层神经元状态，从小到大输出，如果都为0输出NULL。" —— 强调了输出层的判断条件。

**核心代码片段**:
```cpp
for(int tmp = 1; tmp <= n; tmp++) {
    for(int i = 1; i <= n; i++) {
        if(in[i] == 0 && v[i] == 0) {
            v[i] = 1;
            if(u[i] != -1) c[i] -= u[i];
            for(int j = h[i]; j > 0; j = a[j].ne) {
                if(c[i] > 0) c[a[j].v] += c[i] * a[j].w;
                in[a[j].v]--;
            }
            break;
        }
    }
}
```
**核心思想**: 通过暴力搜索入度为0的节点进行拓扑排序，确保每个节点的状态在计算时已经得到更新。

### 最优关键思路与技巧

1. **拓扑排序**: 通过拓扑排序确保每个节点的状态在计算时已经得到更新，避免重复计算。
2. **阈值处理**: 在输入时直接减去阈值，减少后续计算的复杂度。
3. **输出层判断**: 通过出度为0的节点判断输出层，确保输出结果的正确性。

### 可拓展之处

- **类似算法套路**: 拓扑排序在处理依赖关系问题时非常有效，如任务调度、编译顺序等。
- **同类型题目**: 可以尝试解决其他依赖关系问题，如任务调度、编译顺序等。

### 推荐题目

1. **P1113 杂务** - 考察拓扑排序在任务调度中的应用。
2. **P1137 旅行计划** - 考察拓扑排序在路径规划中的应用。
3. **P1268 树的重量** - 考察拓扑排序在树结构中的应用。

---
处理用时：39.42秒
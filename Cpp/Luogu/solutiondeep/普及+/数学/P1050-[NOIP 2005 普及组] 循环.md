# 题目信息

# [NOIP 2005 普及组] 循环

## 题目描述

乐乐是一个聪明而又勤奋好学的孩子。他总喜欢探求事物的规律。一天，他突然对数的正整数次幂产生了兴趣。


众所周知，$2$ 的正整数次幂最后一位数总是不断的在重复 $2,4,8,6,2,4,8,6…$ 我们说 $2$ 的正整数次幂最后一位的循环长度是 $4$（实际上 $4$ 的倍数都可以说是循环长度，但我们只考虑最小的循环长度）。类似的，其余的数字的正整数次幂最后一位数也有类似的循环现象：

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c}\hline
\textbf{数字}& \textbf{循环} & \textbf{循环长度} \cr\hline\hline
2 & 2,4,8,6 & 4\cr\hline
3 & 3,9,7,1 & 4\cr\hline
4 & 4,6 & 2\cr\hline
5 & 5 &  1\cr\hline
6 & 6 & 1\cr\hline
7 & 7,9,3,1 & 4\cr\hline
8 & 8,4,2,6 & 4\cr\hline
9 & 9,1 & 2\cr\hline
\end{array}
$$

这时乐乐的问题就出来了：是不是只有最后一位才有这样的循环呢？对于一个整数 $n$ 的正整数次幂来说，它的后 $k$ 位是否会发生循环？如果循环的话，循环长度是多少呢？

注意：

1. 如果 $n$ 的某个正整数次幂的位数不足 $k$，那么不足的高位看做是 $0$。
2. 如果循环长度是 $L$，那么说明对于任意的正整数 $a$，$n$ 的 $a$ 次幂和 $a+L$ 次幂的最后 $k$ 位都相同。


## 说明/提示

**【数据范围】**

对于 $30 \%$ 的数据，满足 $k \le 4$；  
对于$100 \%$ 的数据，满足 $1 \le n < {10}^{100}$，$1 \le k \le 100$。

**【题目来源】**

NOIP 2005 普及组第四题

## 样例 #1

### 输入

```
32 2```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

本题的核心在于求解一个数的后 $k$ 位在正整数次幂下的循环长度。题解中主要采用了递推法、欧拉定理、以及高精度运算等思路。递推法通过逐位计算循环长度，利用前 $i-1$ 位的循环长度推导出第 $i$ 位的循环长度，时间复杂度为 $O(k^2 \times N^2)$，其中 $N$ 为 $n$ 的位数。欧拉定理则通过枚举 $\varphi(10^k)$ 的因子来寻找循环长度，但需要进一步优化以避免超时。高精度运算则是处理大数乘法和取模的关键。

### 所选高星题解

#### 1. 作者：_Life_ (5星)
- **关键亮点**：逐位递推，利用前 $i-1$ 位的循环长度推导第 $i$ 位的循环长度，时间复杂度较低，代码清晰易读。
- **个人心得**：通过手玩数据 `198123 4`，逐步推导出循环长度的计算方法，帮助理解递推过程。
- **核心代码**：
  ```cpp
  bignum operator *(bignum a,bignum b) {
      bignum ans;
      for(int i=0;i<k;i++)
          for(int j=0;j<k;j++)
              ans.x[i+j]+=a.x[i]*b.x[j];
      for(int i=0;i<k;i++)ans.x[i+1]+=ans.x[i]/10,ans.x[i]%=10;
      for(int i=k;i<205;i++)ans.x[i]=0;
      return ans;
  }
  ```

#### 2. 作者：MyukiyoMekya (4星)
- **关键亮点**：使用欧拉定理，通过枚举 $\varphi(10^k)$ 的因子来寻找循环长度，优化了快速幂的计算。
- **核心代码**：
  ```cpp
  Bigint fastpow(Bigint a,int b) {
      Bigint res;res.clear();
      res.a[1]=1;
      for(;b;b>>=1,a=a*a)
          if(b&1)
              res=res*a;
      return res;
  }
  ```

#### 3. 作者：Shadow_Soldier (4星)
- **关键亮点**：详细推导了递推法的数学原理，通过引理证明了循环长度的递推关系，代码实现清晰。
- **核心代码**：
  ```cpp
  Number operator * (Number p, Number q) {
      Number rhs;
      rhs.Clear();
      for(int i = 1; i <= p.l; i ++) {
          for(int j = 1; j <= q.l; j ++) {
              rhs.a[i + j - 1] += (p.a[i] * q.a[j]);
              rhs.a[i + j] += (rhs.a[i + j - 1] / 10);
              rhs.a[i + j - 1] %= 10;
          }
      }
      if(rhs.a[p.l + q.l]) rhs.l = p.l + q.l;
      else rhs.l = p.l + q.l - 1;
      rhs.Resize();
      return rhs;
  }
  ```

### 最优关键思路与技巧
1. **递推法**：通过逐位计算循环长度，利用前 $i-1$ 位的循环长度推导第 $i$ 位的循环长度，时间复杂度较低。
2. **高精度运算**：处理大数乘法和取模，确保计算过程中的精度。
3. **欧拉定理**：通过枚举 $\varphi(10^k)$ 的因子来寻找循环长度，优化了快速幂的计算。

### 可拓展之处
- **同类型题**：类似的问题可以扩展到其他进制下的循环长度计算，或者扩展到更高维度的循环结构。
- **算法套路**：递推法和高精度运算可以应用于其他需要处理大数或复杂循环结构的问题。

### 推荐题目
1. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)
2. [P1068 循环数](https://www.luogu.com.cn/problem/P1068)
3. [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)

### 个人心得总结
- **调试经历**：通过手玩数据逐步推导出循环长度的计算方法，帮助理解递推过程。
- **踩坑教训**：在处理高精度运算时，需要注意进位和取模的细节，避免精度丢失。
- **顿悟感想**：递推法的关键在于利用前 $i-1$ 位的循环长度推导第 $i$ 位的循环长度，这一思路可以推广到其他类似问题。

---
处理用时：29.86秒
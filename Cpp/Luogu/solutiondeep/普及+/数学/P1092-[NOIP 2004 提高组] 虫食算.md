# 题目信息

# [NOIP 2004 提高组] 虫食算

## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：

$$\begin{aligned}
 \verb!43#9865#045! \\
+\qquad \verb!8468#6633! \\[-1em]\underline{\kern{8em}} \\
 \verb!44445509678! \\
\end{aligned}$$

其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。

$$\begin{aligned}
 \verb!BADC! \\
+\quad \verb!CBDA! \\[-1em]\underline{\kern{4em}} \\
 \verb!DCCC! \\
\end{aligned}$$

上面的算式是一个4进制的算式。很显然，我们只要让 $\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 10$；
- 对于 $50\%$ 的数据，保证 $n \le 15$；
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 26$。

## 样例 #1

### 输入

```
5
ABCED
BDACE
EBBAA
```

### 输出

```
1 0 3 4 2
```

# AI分析结果

### 综合分析

本题“虫食算”是一个典型的搜索与剪枝问题，核心难点在于如何高效地搜索字母与数字的对应关系，并通过剪枝减少搜索空间。大多数题解采用了深度优先搜索（DFS）结合剪枝的策略，部分题解尝试了高斯消元等数学方法，但复杂度较高，难以通过所有测试点。以下是对题解的总结与对比：

1. **搜索顺序优化**：大多数题解从右往左逐位搜索，避免进位带来的复杂性，部分题解还通过预处理字母出现顺序进一步优化搜索顺序。
2. **剪枝策略**：常见的剪枝包括：
   - 最高位不能有进位。
   - 如果某一位的三个字母都已赋值，且无论是否进位都不满足等式，则剪枝。
   - 如果某一位的两个字母已赋值，且第三个字母的取值已被占用，则剪枝。
3. **代码实现**：部分题解通过位运算优化数字的分配与判断，提高了代码效率。

### 精选题解

#### 题解1：zzlzk（4星）
- **亮点**：清晰的剪枝策略，从右往左搜索，结合进位判断，代码简洁易读。
- **关键思路**：
  - 从右往左逐位搜索，避免进位复杂性。
  - 剪枝：如果某一位的三个字母已赋值且不满足等式，则剪枝。
  - 优化：通过预处理字母出现顺序，减少搜索空间。
- **核心代码**：
  ```cpp
  void dfs(int x, int y, int t) {
      if (x == 0) {
          if (t == 0) {
              for (int i = 1; i <= n; i++) printf("%d ", num[i]);
              exit(0);
          }
          return;
      }
      if (num[a[x][y]] == -1) {
          for (int i = n - 1; i >= 0; i--) {
              if (!used[i]) {
                  num[a[x][y]] = i;
                  used[i] = 1;
                  dfs(x, y + 1, t);
                  num[a[x][y]] = -1;
                  used[i] = 0;
              }
          }
      } else {
          dfs(x, y + 1, t);
      }
  }
  ```

#### 题解2：✌yww（4星）
- **亮点**：详细的分类讨论，结合进位判断，代码结构清晰。
- **关键思路**：
  - 从右往左逐位搜索，结合进位判断。
  - 剪枝：如果某一位的三个字母已赋值且不满足等式，则剪枝。
  - 优化：通过预处理字母出现顺序，减少搜索空间。
- **核心代码**：
  ```cpp
  void dfs(int x, int y, int t) {
      if (x == 0) {
          if (t == 0) {
              for (int i = 1; i <= n; i++) printf("%d ", num[i]);
              exit(0);
          }
          return;
      }
      if (num[a[x][y]] == -1) {
          for (int i = n - 1; i >= 0; i--) {
              if (!used[i]) {
                  num[a[x][y]] = i;
                  used[i] = 1;
                  dfs(x, y + 1, t);
                  num[a[x][y]] = -1;
                  used[i] = 0;
              }
          }
      } else {
          dfs(x, y + 1, t);
      }
  }
  ```

#### 题解3：Kelin（4星）
- **亮点**：高效的剪枝策略，结合进位判断，代码简洁高效。
- **关键思路**：
  - 从右往左逐位搜索，结合进位判断。
  - 剪枝：如果某一位的三个字母已赋值且不满足等式，则剪枝。
  - 优化：通过预处理字母出现顺序，减少搜索空间。
- **核心代码**：
  ```cpp
  void dfs(int x, int y, int t) {
      if (x == 0) {
          if (t == 0) {
              for (int i = 1; i <= n; i++) printf("%d ", num[i]);
              exit(0);
          }
          return;
      }
      if (num[a[x][y]] == -1) {
          for (int i = n - 1; i >= 0; i--) {
              if (!used[i]) {
                  num[a[x][y]] = i;
                  used[i] = 1;
                  dfs(x, y + 1, t);
                  num[a[x][y]] = -1;
                  used[i] = 0;
              }
          }
      } else {
          dfs(x, y + 1, t);
      }
  }
  ```

### 最优关键思路

1. **从右往左搜索**：避免进位带来的复杂性，减少搜索空间。
2. **剪枝策略**：通过判断某一位的三个字母是否已赋值且不满足等式，进行剪枝。
3. **预处理字母出现顺序**：优化搜索顺序，减少搜索空间。

### 推荐题目

1. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)：类似搜索与剪枝问题，适合练习。
2. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)：搜索与剪枝的经典题目。
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)：动态规划与搜索结合的题目。

### 个人心得

- **调试经历**：部分题解提到在调试过程中发现剪枝不充分导致超时，通过优化剪枝策略成功AC。
- **顿悟感想**：从右往左搜索的思路大大简化了进位的处理，是解决此类问题的关键。

---
处理用时：50.57秒
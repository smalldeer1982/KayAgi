# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心是统计满足 \(A - B = C\) 的数对个数，且不同位置的相同数对视为不同的数对。题解中主要采用了以下几种思路：

1. **哈希表（Map）**：通过 `map` 或 `unordered_map` 记录每个数的出现次数，然后遍历数组，统计满足条件的数对。时间复杂度为 \(O(n \log n)\) 或 \(O(n)\)，空间复杂度为 \(O(n)\)。
2. **二分查找**：先对数组排序，然后对每个元素进行二分查找，找到满足 \(A - B = C\) 的数对。时间复杂度为 \(O(n \log n)\)，空间复杂度为 \(O(1)\)。
3. **双指针**：排序后使用双指针维护满足条件的区间，时间复杂度为 \(O(n \log n)\)，空间复杂度为 \(O(1)\)。
4. **桶排序**：通过数组记录每个数的出现次数，时间复杂度为 \(O(n)\)，但空间复杂度较高，可能无法处理大数据范围。

最优解法是 **哈希表**，因其时间复杂度较低且代码简洁。**二分查找**和**双指针**虽然时间复杂度与哈希表相近，但代码实现稍复杂，适合对空间复杂度有要求的场景。

### 所选高分题解

#### 1. **题解作者：OsvaldoAsensioLopez (赞：789)**
- **星级**：★★★★★
- **关键亮点**：使用 `map` 记录每个数的出现次数，思路清晰，代码简洁，时间复杂度为 \(O(n \log n)\)。
- **核心代码**：
  ```cpp
  map<LL,LL> m;
  for(int i=1;i<=n;i++) {
      cin >> a[i];
      m[a[i]]++;
      a[i]-=c;    
  } 
  for(int i=1;i<=n;i++) ans+=m[a[i]];
  ```
- **个人心得**：通过将 \(A - B = C\) 转化为 \(A - C = B\)，简化了问题，直接通过 `map` 查找满足条件的数对。

#### 2. **题解作者：樱花飞舞 (赞：536)**
- **星级**：★★★★☆
- **关键亮点**：使用 `lower_bound` 和 `upper_bound` 进行二分查找，时间复杂度为 \(O(n \log n)\)，适合对空间复杂度有要求的场景。
- **核心代码**：
  ```cpp
  for(int i=1;i<=N;i++) {
      ans+=((upper_bound(a+1,a+N+1,a[i]+C)-a)-(lower_bound(a+1,a+N+1,a[i]+C)-a));
  }
  ```
- **个人心得**：通过二分查找避免了哈希表的空间开销，适合处理大数据范围。

#### 3. **题解作者：jins3599 (赞：460)**
- **星级**：★★★★☆
- **关键亮点**：使用双指针维护满足条件的区间，时间复杂度为 \(O(n \log n)\)，空间复杂度为 \(O(1)\)。
- **核心代码**：
  ```cpp
  for(l = 1 ; l <= n ; l ++) {
      while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
      while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
      if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
          ans += r1 - r2;
  }
  ```
- **个人心得**：通过双指针避免了二分查找的重复计算，适合处理大数据范围。

### 最优关键思路与技巧

1. **哈希表**：通过 `map` 或 `unordered_map` 记录每个数的出现次数，然后遍历数组，统计满足条件的数对。时间复杂度为 \(O(n \log n)\) 或 \(O(n)\)，空间复杂度为 \(O(n)\)。
2. **二分查找**：先对数组排序，然后对每个元素进行二分查找，找到满足 \(A - B = C\) 的数对。时间复杂度为 \(O(n \log n)\)，空间复杂度为 \(O(1)\)。
3. **双指针**：排序后使用双指针维护满足条件的区间，时间复杂度为 \(O(n \log n)\)，空间复杂度为 \(O(1)\)。

### 可拓展之处

1. **类似题目**：可以扩展到统计满足 \(A + B = C\) 或 \(A \times B = C\) 的数对个数。
2. **算法套路**：哈希表、二分查找、双指针等算法套路可以应用于类似的统计问题。

### 推荐题目

1. **P1102 A-B 数对**（本题）
2. **P1496 火烧赤壁**（统计区间覆盖问题）
3. **P1631 序列合并**（双指针应用）

### 个人心得总结

- **调试经历**：在使用哈希表时，注意 `map` 和 `unordered_map` 的时间复杂度差异，`unordered_map` 在平均情况下更快。
- **踩坑教训**：在使用二分查找时，注意数组的有序性，否则会导致查找失败。
- **顿悟感想**：通过将问题转化为 \(A - C = B\)，可以简化问题，直接通过哈希表或二分查找解决。

---
处理用时：37.97秒
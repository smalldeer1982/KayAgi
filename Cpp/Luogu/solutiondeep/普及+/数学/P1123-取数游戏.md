# 题目信息

# 取数游戏

## 题目描述

一个 $N\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。

## 说明/提示

### 样例解释

对于第一组数据，取数方式如下：

$$\begin{matrix}
[67] & 75 & 63 & 10 \\
29 & 29 & [92] & 14 \\
[21] & 68 & 71 & 56 \\
8 & 67 & [91] & 25 \\
\end{matrix}$$


### 数据范围及约定

- 对于$20\%$的数据，$1\le N, M \le 3$；
- 对于$40\%$的数据，$1\le N, M\le 4$；
- 对于$60\%$的数据，$1\le N, M\le 5$；
- 对于$100\%$的数据，$1\le N, M\le 6$，$1\le T\le 20$。


## 样例 #1

### 输入

```
3
4 4
67 75 63 10
29 29 92 14
21 68 71 56
8 67 91 25
2 3
87 70 85
10 3 17
3 3
1 1 1
1 99 1
1 1 1

```

### 输出

```
271
172
99
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地枚举所有可能的取数方案，并确保取出的数字不相邻。由于数据范围较小（N, M ≤ 6），大多数题解采用了**深度优先搜索（DFS）**或**状压动态规划（DP）**来解决。DFS通过回溯和标记来避免相邻取数，而状压DP则通过二进制状态表示每行的取数情况，优化了状态转移。

#### 最优关键思路与技巧：
1. **DFS回溯与标记**：通过标记当前取数的相邻格子，确保后续取数不会冲突，回溯时撤销标记。
2. **状压DP**：利用二进制状态表示每行的取数情况，预处理合法状态，优化状态转移。
3. **剪枝优化**：在DFS中通过剪枝减少无效搜索，如提前判断当前和是否可能超过最大值。

#### 可拓展之处：
- **类似问题**：如棋盘覆盖、互不侵犯问题等，均可使用DFS或状压DP解决。
- **优化思路**：对于更大范围的数据，可以考虑启发式搜索或更高效的剪枝策略。

### 所选高星题解

#### 1. 作者：绿萧 (5星)
- **关键亮点**：思路清晰，代码简洁，通过DFS回溯和标记数组实现高效搜索。
- **个人心得**：作者提到贪心和动态规划不适用，转而选择DFS，体现了对问题本质的深刻理解。
- **核心代码**：
```cpp
void dfs(int x, int y) {
    if (y == m + 1) { dfs(x + 1, 1); return; }
    if (x == n + 1) { mx = max(ans, mx); return; }
    
    dfs(x, y + 1); // 不取此数
    
    if (mark[x][y] == 0) { // 取此数
        ans += s[x][y];
        for (int fx = 0; fx < 8; ++fx) ++mark[x + d[fx][0]][y + d[fx][1]];
        dfs(x, y + 1);
        for (int fx = 0; fx < 8; ++fx) --mark[x + d[fx][0]][y + d[fx][1]];
        ans -= s[x][y];
    }
}
```

#### 2. 作者：IntrepidStrayer (4星)
- **关键亮点**：使用状压DP，预处理合法状态，优化状态转移，思路清晰。
- **核心代码**：
```cpp
void solve() {
    init();
    for (int j = 1; j <= m; j++)
        for (int i = 1; i <= tot; i++) {
            int s = fun[i], sum = 0;
            for (int p = 1; p <= n; p++) if (s & (1 << (p - 1))) sum += a[p][j];
            for (int k = 1; k <= tot; k++)
                if (!(fun[k] & s) && !(fun[k] & (s << 1)) && !(fun[k] & (s >> 1)))
                    f[j][i] = max(f[j][i], f[j - 1][k] + sum);
        }
    int ans = 0;
    for (int i = 1; i <= tot; i++) ans = max(ans, f[m][i]);
    printf("%d\n", ans);
}
```

#### 3. 作者：回头是岸 (4星)
- **关键亮点**：状压DP结合预处理，代码结构清晰，状态转移优化得当。
- **核心代码**：
```cpp
void work() {
    for (int i = 0; i < (1 << m); i++) if (!(i & (i >> 1)) && !(i & (i << 1))) t.push_back(i);
}
```

### 推荐相似题目
1. **P1896 [SCOI2005] 互不侵犯**：考察状压DP在棋盘问题中的应用。
2. **P1879 [USACO06NOV] Corn Fields G**：类似状压DP，要求不相邻的取数方案。
3. **P2704 [NOI2001] 炮兵阵地**：复杂状压DP，涉及多行状态转移。

---
处理用时：30.89秒
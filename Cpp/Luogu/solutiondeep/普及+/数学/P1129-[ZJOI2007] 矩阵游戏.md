# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果

### 综合分析与结论

本题的核心是通过行交换和列交换操作，使得矩阵的主对角线上的所有格子均为黑色。大多数题解都采用了二分图匹配或网络流（如Dinic算法）来解决该问题。主要思路是将行和列分别视为二分图的两个部分，矩阵中的每个黑色格子表示行和列之间的匹配关系。通过求最大匹配，判断是否能够通过交换操作使得每行和每列都匹配到对应的对角线位置。

### 题解精选

#### 1. **俾斯麦（5星）**
   - **关键亮点**：详细分析了二分图匹配和网络流（Dinic算法）的解法，思路清晰，代码实现完整且优化了多组数据的初始化操作。
   - **代码核心**：
     ```cpp
     bool dfs(int x) {
         for (int i = head[x]; i; i = next[i]) {
             int y = to[i];
             if (!vis[y]) {
                 vis[y] = 1;
                 if (!match[y] || dfs(match[y])) {
                     match[y] = x;
                     return true;
                 }
             }
         }
         return false;
     }
     ```
   - **个人心得**：强调了多组数据初始化时避免使用`memset`，而是通过手动清零来优化时间。

#### 2. **Night_Aurora（4.5星）**
   - **关键亮点**：从匹配的角度出发，解释了行交换和列交换对匹配数的影响，思路简洁明了，代码实现清晰。
   - **代码核心**：
     ```cpp
     bool dfs(int x) {
         for (int i = head[x]; i; i = next[i]) {
             int y = to[i];
             if (!vis[y]) {
                 vis[y] = 1;
                 if (!match[y] || dfs(match[y])) {
                     match[y] = x;
                     return true;
                 }
             }
         }
         return false;
     }
     ```
   - **个人心得**：通过匹配边的方式，解释了如何通过交换操作使得每行和每列都匹配到对应的对角线位置。

#### 3. **cmwqf（4星）**
   - **关键亮点**：通过二分图匹配的思路，详细解释了如何将行和列匹配到对角线位置，代码实现简洁。
   - **代码核心**：
     ```cpp
     bool dfs(int x) {
         for (int i = 1; i <= n; i++) {
             if (G[x][i] && !vis[i]) {
                 vis[i] = true;
                 if (!match[i] || dfs(match[i])) {
                     match[i] = x;
                     return true;
                 }
             }
         }
         return false;
     }
     ```
   - **个人心得**：通过匹配的方式，解释了如何通过交换操作使得每行和每列都匹配到对应的对角线位置。

### 最优关键思路与技巧

1. **二分图匹配**：将行和列分别视为二分图的两个部分，矩阵中的每个黑色格子表示行和列之间的匹配关系。通过求最大匹配，判断是否能够通过交换操作使得每行和每列都匹配到对应的对角线位置。
2. **网络流（Dinic算法）**：通过建立源点和汇点，将行和列分别连接到源点和汇点，矩阵中的每个黑色格子表示行和列之间的流量关系。通过求最大流，判断是否能够通过交换操作使得每行和每列都匹配到对应的对角线位置。
3. **优化初始化**：在多组数据的情况下，避免使用`memset`，而是通过手动清零来优化时间。

### 可拓展之处

- **类似题目**：类似的二分图匹配问题可以扩展到其他矩阵操作问题，如通过交换操作使得矩阵满足某种特定条件。
- **算法套路**：二分图匹配和网络流算法可以应用于其他需要匹配或流量分配的问题，如任务分配、资源调度等。

### 推荐题目

1. **P3386 【模板】二分图最大匹配**：考察二分图匹配的基本实现。
2. **P2763 试题库问题**：考察网络流算法的应用。
3. **P2764 最小路径覆盖问题**：考察二分图匹配与路径覆盖的结合。

### 个人心得总结

- **调试经历**：多组数据初始化时，避免使用`memset`，而是通过手动清零来优化时间。
- **踩坑教训**：数组大小要开足够大，避免因数组过小导致运行时错误。
- **顿悟感想**：通过匹配边的方式，可以清晰地解释如何通过交换操作使得每行和每列都匹配到对应的对角线位置。

---
处理用时：31.38秒
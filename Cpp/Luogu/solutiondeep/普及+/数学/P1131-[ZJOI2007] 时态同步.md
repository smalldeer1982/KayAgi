# 题目信息

# [ZJOI2007] 时态同步

## 题目描述

小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。

在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。

激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？

## 说明/提示

- 对于 $40\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 5\times 10^5$。

对于所有的数据，$1\le t_e\le 10^6$。

## 样例 #1

### 输入

```
3
1
1 2 1
1 3 3
```

### 输出

```
2
```

# AI分析结果

### 综合分析与结论

本题的核心目标是通过增加边权，使得所有叶子节点到根节点的路径长度相同。大多数题解采用了树形DP或贪心的思路，核心思想是从叶子节点向上回溯，逐步调整边权，确保每个节点的子树内的叶子节点路径长度一致。关键在于如何高效地计算每个节点的最大路径长度，并通过调整边权来达到同步。

### 所选高星题解

#### 1. **作者：Mathison (赞：187)**
- **星级**：5星
- **关键亮点**：
  - 思路清晰，通过深度类比距离，直观易懂。
  - 代码简洁，使用DFS遍历树，计算每个节点的最大路径长度，并累加调整代价。
  - 优化程度高，时间复杂度为O(n)，适合大规模数据。
- **核心代码**：
  ```cpp
  void dfs(int x, int fa) {
      for(int i=head[x];i;i=next[i]) {
          int y=ver[i], z=edge[i];
          if(y==fa) continue;
          dfs(y,x);
          dis[x]=max(dis[x],dis[y]+z);
      }
      for(int i=head[x];i;i=next[i]) {
          int y=ver[i], z=edge[i];
          if(y==fa) continue;
          ans+=dis[x]-(dis[y]+z);
      }
  }
  ```
  **核心思想**：通过DFS计算每个节点的最大路径长度，并在回溯时累加调整代价。

#### 2. **作者：crazydave (赞：127)**
- **星级**：4.5星
- **关键亮点**：
  - 从叶子节点向上维护，确保每个节点的子节点信号同时到达该节点。
  - 代码结构清晰，使用DFS进行回溯，维护最大边权和答案。
  - 优化程度较高，时间复杂度为O(n)。
- **核心代码**：
  ```cpp
  void dfs(int x, int fa) {
      for(int i=head[x]; i; i=edge[i].next) {
          int v=edge[i].to;
          if(v==fa) continue;
          dfs(v,x);
          maxn[x]=max(maxn[x], edge[i].dis);
      }
      for(int i=head[x]; i; i=edge[i].next) {
          int v=edge[i].to;
          if(v==fa) continue;
          ans+=(maxn[x]-edge[i].dis);
      }
  }
  ```
  **核心思想**：通过DFS维护每个节点的最大边权，并在回溯时计算调整代价。

#### 3. **作者：Social_Zhao (赞：19)**
- **星级**：4星
- **关键亮点**：
  - 使用树形DP，定义状态转移方程，计算每个节点的最小操作次数。
  - 代码结构清晰，使用DFS进行状态转移，适合理解树形DP的初学者。
  - 优化程度较高，时间复杂度为O(n)。
- **核心代码**：
  ```cpp
  void dfs(int u, int fa) {
      f[u] = 0; maxn[u] = 0;
      int sum = 0, cnt = 0;
      for(int i = head[u]; i; i = edge[i].nxt) {
          int v = edge[i].v;
          if(v == fa) continue;
          dfs(v, u);
          cnt++;
          f[u] += f[v];
          maxn[u] = max(maxn[v] + edge[i].w, maxn[u]);
          sum += maxn[v] + edge[i].w;
      }
      f[u] += maxn[u] * cnt - sum;
  }
  ```
  **核心思想**：通过DFS计算每个节点的最大路径长度，并通过状态转移方程计算最小操作次数。

### 最优关键思路与技巧

1. **树形DP与贪心结合**：从叶子节点向上回溯，逐步调整边权，确保每个节点的子树内的叶子节点路径长度一致。
2. **DFS遍历**：通过DFS计算每个节点的最大路径长度，并在回溯时累加调整代价。
3. **状态转移方程**：定义状态转移方程，计算每个节点的最小操作次数，确保时间复杂度为O(n)。

### 可拓展之处

1. **类似问题**：可以扩展到其他树形结构的问题，如最小生成树、树的重心等。
2. **优化技巧**：可以使用更高效的数据结构（如线段树）来优化某些操作。

### 推荐题目

1. **P1352 没有上司的舞会**：树形DP的经典问题，考察如何选择节点使得权值和最大。
2. **P2014 选课**：树形DP问题，考察如何选择课程使得学分最大。
3. **P2015 二叉苹果树**：树形DP问题，考察如何选择边使得苹果数量最大。

### 个人心得总结

- **调试经历**：在实现树形DP时，确保状态转移方程的正确性非常重要，尤其是在处理父子节点关系时。
- **踩坑教训**：注意边权的处理，避免重复计算或遗漏某些边。
- **顿悟感想**：树形DP的核心在于从叶子节点向上回溯，逐步解决问题，这种思维方式可以应用到其他树形结构的问题中。

---
处理用时：41.31秒
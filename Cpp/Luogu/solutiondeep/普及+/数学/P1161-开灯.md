# 题目信息

# 开灯

## 题目描述

在一条无限长的路上，有一排无限长的路灯，编号为 $1,2,3,4,\dots$。

每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。

在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：

指定两个数，$a,t$（$a$ 为实数，$t$ 为正整数）。将编号为 $\lfloor a\rfloor,\lfloor 2 \times a\rfloor,\lfloor3 \times a\rfloor,\dots,\lfloor t  \times a\rfloor$ 的灯的开关各按一次。其中 $\lfloor k \rfloor$ 表示实数 $k$ 的整数部分。

在小明进行了 $n$ 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。

幸好，小明还记得之前的 $n$ 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？


## 说明/提示

记 $T=\sum \limits_{i=1}^n t_i = t_1+t_2+t_3+\dots+t_n$。

- 对于 $30\%$ 的数据，满足 $T \le 1000$；
- 对于 $80\%$ 的数据，满足 $T \le 200000$；
- 对于 $100\%$ 的数据，满足 $T \le 2000000$；
- 对于 $100\%$ 的数据，满足 $n \le 5000$，$1 \le a_i<1000$，$1 \le t_i \le T$。

数据保证，在经过 $n$ 次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的 $i$ 来说，$t_i\times a_i$ 的最大值不超过 $2000000$。

## 样例 #1

### 输入

```
3
1.618034 13
2.618034 7
1.000000 21```

### 输出

```
20```

# AI分析结果

### 综合分析与结论

本题的核心在于模拟路灯的开关操作，并最终找到唯一一盏亮着的灯。题解中主要分为两种思路：**模拟法**和**位运算法**。

- **模拟法**：通过数组记录每盏灯的状态，模拟开关操作，最后遍历数组找到亮着的灯。这种方法直观易懂，但时间和空间复杂度较高，适合数据规模较小的情况。
  
- **位运算法**：利用异或运算的性质，将所有操作的路灯编号进行异或，最终结果即为亮着的灯编号。这种方法时间复杂度低，空间复杂度为O(1)，适合大规模数据。

### 所选高星题解

#### 1. 作者：Hamster_Air (赞：222)  
**星级：★★★★★**  
**关键亮点**：使用位运算（异或）高效解决问题，代码简洁，时间复杂度低。  
**个人心得**：作者提到“异或轻松解决”，强调了位运算的简洁性和高效性。  
**核心代码**：
```cpp
int ans = 0;
for (int i = 1; i <= n; i++) {
    cin >> a >> t;
    for (int j = 1; j <= t; j++) {
        ans ^= int(j * a); // 异或运算
    }
}
cout << ans << endl;
```
**实现思想**：通过异或运算，将所有操作的路灯编号进行异或，最终结果即为亮着的灯编号。

#### 2. 作者：雨竹 (赞：187)  
**星级：★★★★☆**  
**关键亮点**：详细解释了异或运算的原理，代码清晰，适合初学者理解。  
**个人心得**：作者提到“异或就是把两个数拆成二进制，一位一位比较”，帮助读者理解位运算的本质。  
**核心代码**：
```cpp
int ans = 0;
while (n--) {
    scanf("%lf", &a);
    scanf("%d", &t);
    for (int i = 1; i <= t; i++) {
        int x = (int)floor(a * i);
        ans ^= x;
    }
}
printf("%d", ans);
```
**实现思想**：与Hamster_Air类似，使用异或运算解决问题，代码结构清晰。

#### 3. 作者：williamllk (赞：1782)  
**星级：★★★★☆**  
**关键亮点**：使用模拟法，代码直观易懂，适合初学者理解问题。  
**个人心得**：作者提到“只能用模拟做”，强调了模拟法的直观性。  
**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    cin >> x >> y;
    for (double j = 1; j <= y; ++j) {
        if (a[int(j * x)] == 0) a[int(j * x)] = 1;
        else a[int(j * x)] = 0;
    }
}
for (int i = 1;; i++) {
    if (a[i] == 1) {
        cout << i;
        break;
    }
}
```
**实现思想**：通过数组记录每盏灯的状态，模拟开关操作，最后遍历数组找到亮着的灯。

### 最优关键思路与技巧

- **位运算（异或）**：利用异或运算的性质，将所有操作的路灯编号进行异或，最终结果即为亮着的灯编号。这种方法时间复杂度低，空间复杂度为O(1)，适合大规模数据。
  
- **模拟法**：通过数组记录每盏灯的状态，模拟开关操作，最后遍历数组找到亮着的灯。这种方法直观易懂，适合数据规模较小的情况。

### 可拓展之处

- **类似算法套路**：位运算在解决“唯一出现一次的元素”问题时非常有效，如LeetCode中的“Single Number”问题。
  
- **数据结构优化**：对于更大规模的数据，可以考虑使用哈希表或位图来进一步优化空间复杂度。

### 推荐相似题目

1. **P1161 开灯**（本题）
2. **P1001 A+B Problem**（位运算基础题）
3. **P1042 乒乓球**（模拟题，适合练习模拟思路）

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中遇到的问题，如数据类型转换错误、数组大小不足等，提醒读者在编写代码时要注意细节。
  
- **顿悟感想**：使用位运算解决问题的作者提到“异或轻松解决”，强调了位运算的简洁性和高效性，帮助读者理解位运算的优势。

通过对比不同题解，可以看出位运算在解决此类问题时的优势，而模拟法则更适合初学者理解和实现。

---
处理用时：32.46秒
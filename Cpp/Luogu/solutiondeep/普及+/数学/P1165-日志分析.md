# 题目信息

# 日志分析

## 题目描述

M 海运公司最近要对旗下仓库的货物进出情况进行统计。目前他们所拥有的唯一记录就是一个记录集装箱进出情况的日志。该日志记录了两类操作：第一类操作为集装箱入库操作，以及该次入库的集装箱重量；第二类操作为集装箱的出库操作。这些记录都严格按时间顺序排列。集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为当前在仓库里所有集装箱中最晚入库的集装箱。

出于分析目的，分析人员在日志中随机插入了若干第三类操作――查询操作。分析日志时，每遇到一次查询操作，都要报告出当前仓库中最大集装箱的重量。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，有 $N \le 10$；
- 对于 $40\%$ 的数据，有 $N \le 1000$；
- 对于 $100\%$ 的数据，有 $1 \le N \le 200000$，$1 \le X \le 10^8$。


## 样例 #1

### 输入

```
13
0 1
0 2
2
0 4
0 2
2
1
2
1
1
2
1
2
```

### 输出

```
2
4
4
1
0
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过栈数据结构模拟集装箱的进出操作，并高效查询当前栈中的最大重量。大部分题解都采用了栈的基本操作，但如何在O(1)时间内查询最大值是难点。常见的优化思路包括：

1. **辅助栈法**：维护一个辅助栈，记录当前栈中的最大值，入栈时更新辅助栈，出栈时同步弹出。
2. **数组记录法**：使用数组记录每个位置的最大值，入栈时更新当前最大值，出栈时直接减少栈顶指针。
3. **单调栈法**：通过单调栈维护当前栈中的最大值，确保栈顶始终是最大值。

这些方法都能在O(1)时间内完成查询操作，且时间复杂度为O(n)，适用于大规模数据。

### 所选高星题解

#### 1. 作者：medusa (5星)
- **关键亮点**：使用数组记录每个位置的最大值，入栈时更新最大值，出栈时直接减少栈顶指针。思路清晰，代码简洁，时间复杂度为O(n)。
- **核心代码**：
  ```cpp
  int f[200001],n,x,y,t=0;
  int main() {
      cin>>n;
      f[0]=0;
      for (int i=1; i<=n; i++) {
          cin>>x;
          if (x==0) {
              cin>>y;
              t++;
              f[t]=max(f[t-1],y);
          }
          if (x==1) if (t!=0) t--;
          if (x==2) cout<<f[t]<<endl;
      }
      return 0;
  }
  ```

#### 2. 作者：buickboy (4星)
- **关键亮点**：使用辅助栈记录当前栈中的最大值，入栈时更新辅助栈，出栈时同步弹出。思路清晰，代码可读性强。
- **核心代码**：
  ```cpp
  stack<int>a;
  stack<int>b;
  int main() {
      scanf("%d",&n);
      while(n--) {
          scanf("%d",&m);
          if(m==0) {
              scanf("%d",&x);
              a.push(x);
              if(b.empty()||x>b.top()) b.push(x);
              else b.push(b.top());
          }
          else if(m==1) {
              a.pop();
              b.pop();
          }
          else {
              if(b.empty()) printf("0\n");
              else printf("%d\n",b.top());
          }
      }
      return 0;
  }
  ```

#### 3. 作者：引领天下 (4星)
- **关键亮点**：通过单调栈维护当前栈中的最大值，确保栈顶始终是最大值。思路简洁，代码实现高效。
- **核心代码**：
  ```cpp
  int steak[200001],top=0;
  int main() {
      scanf("%d",&n);
      for(;n--;) {
          scanf("%d",&a);
          switch(a) {
              case 0:
                  scanf("%d",&steak[++top]);
                  steak[top]=max(steak[top],steak[top-1]);
                  break;
              case 1:
                  top=max(0,top-1);
                  break;
              case 2:
                  printf("%d\n",steak[top]);
          }
      }
      return 0;
  }
  ```

### 最优关键思路与技巧

1. **辅助栈法**：通过维护一个辅助栈，确保栈顶始终是当前栈中的最大值，入栈和出栈时同步更新辅助栈。
2. **数组记录法**：使用数组记录每个位置的最大值，入栈时更新当前最大值，出栈时直接减少栈顶指针。
3. **单调栈法**：通过单调栈维护当前栈中的最大值，确保栈顶始终是最大值。

### 可拓展之处

- **类似题目**：可以扩展到其他需要维护最大值或最小值的栈问题，如滑动窗口最大值、最小栈等。
- **算法套路**：单调栈、辅助栈等技巧在处理需要维护极值的问题时非常有用，可以举一反三。

### 推荐题目

1. **P1886 滑动窗口**：考察单调队列的应用，与本题的单调栈思路类似。
2. **P1449 后缀表达式**：考察栈的基本操作，适合练习栈的应用。
3. **P1044 栈**：考察栈的基本操作和组合数学，适合练习栈的应用。

### 个人心得摘录

- **medusa**：通过数组记录最大值，避免了每次查询时的遍历操作，极大提高了效率。
- **buickboy**：辅助栈的思路清晰，代码实现简洁，适合大规模数据处理。
- **引领天下**：单调栈的思路简洁高效，确保栈顶始终是最大值，适合快速查询。

这些心得体现了在解决类似问题时，选择合适的优化思路和数据结构的重要性。

---
处理用时：33.21秒
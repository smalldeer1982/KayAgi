# 题目信息

# [NOIP 2011 提高组] 聪明的质监员

## 题目描述

`小T` 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 $n$ 个矿石，从 $1$ 到 $n$ 逐一编号，每个矿石都有自己的重量 $w_i$ 以及价值 $v_i$ 。检验矿产的流程是：

1. 给定$ m$ 个区间 $[l_i,r_i]$；
2. 选出一个参数 $W$；
3. 对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：

$$y_i=\sum\limits_{j=l_i}^{r_i}[w_j \ge W] \times \sum\limits_{j=l_i}^{r_i}[w_j \ge W]v_j$$  

其中 $j$ 为矿石编号。

这批矿产的检验结果 $y$ 为各个区间的检验值之和。即：$\sum\limits_{i=1}^m y_i$  

若这批矿产的检验结果与所给标准值 $s$ 相差太多，就需要再去检验另一批矿产。`小T` 不想费时间去检验另一批矿产，所以他想通过调整参数 $W$ 的值，让检验结果尽可能的靠近标准值 $s$，即使得 $|s-y|$ 最小。请你帮忙求出这个最小值。


## 说明/提示

【输入输出样例说明】

当 $W$ 选 $4$ 的时候，三个区间上检验值分别为 $20,5 ,0$ ，这批矿产的检验结果为 $25$，此时与标准值 $S$ 相差最小为 $10$。

【数据范围】

对于 $10\% $ 的数据，有 $1 ≤n ,m≤10$；

对于 $30\% $的数据，有 $1 ≤n ,m≤500$ ；

对于 $50\% $ 的数据，有 $ 1 ≤n ,m≤5,000$；
 
对于 $70\%$ 的数据，有 $1 ≤n ,m≤10,000$ ；

对于 $100\%$ 的数据，有 $ 1 ≤n ,m≤200,000$，$0 < w_i,v_i≤10^6$，$0 < s≤10^{12}$，$1 ≤l_i ≤r_i ≤n$ 。


## 样例 #1

### 输入

```
5 3 15 
1 5 
2 5 
3 5 
4 5 
5 5 
1 5 
2 4 
3 3 ```

### 输出

```
10
```

# AI分析结果

### 综合分析与结论

本题的核心是通过调整参数 \( W \) 使得检验结果 \( y \) 尽可能接近标准值 \( s \)。由于 \( y \) 随 \( W \) 的增大而单调递减，因此可以使用二分法来快速找到最优的 \( W \)。为了高效计算每个区间的检验值，大多数题解都采用了前缀和优化，将时间复杂度从 \( O(nm) \) 降低到 \( O((n+m)\log W) \)。

### 所选高星题解

#### 1. 作者：An_Aholic (赞：10)  
**星级：5星**  
**关键亮点：**  
- 详细解释了题目的数学表达式，帮助读者理解题意。
- 使用了二分法结合前缀和优化，代码清晰且高效。
- 提供了完整的代码实现，并附有注释，易于理解。

**核心代码：**
```cpp
bool check(ll wq) {
    y = 0;
    memset(qzh1, 0, sizeof(qzh1));  
    memset(qzh2, 0, sizeof(qzh2));
    for (int i = 1; i <= n; i++) {
        if (w[i] > wq) 
            qzh1[i] = qzh1[i - 1] + 1, qzh2[i] = qzh2[i - 1] + v[i]; 
        else
            qzh1[i] = qzh1[i - 1], qzh2[i] = qzh2[i - 1];  
    }
    for (int i = 1; i <= m; i++) {
        y += (qzh1[r[i]] - qzh1[l[i] - 1]) * (qzh2[r[i]] - qzh2[l[i] - 1]);  
    }
    return y > s;
}
```

#### 2. 作者：WsW_ (赞：2)  
**星级：4星**  
**关键亮点：**  
- 思路清晰，详细解释了二分法的应用和前缀和的优化。
- 代码简洁，逻辑明确，易于实现。

**核心代码：**
```cpp
ll check(int W) {
    memset(cnt, 0, sizeof(cnt));
    memset(sumv, 0, sizeof(sumv));
    for (int i = 1; i <= n; i++) {
        if (w[i] >= W) {
            cnt[i] = cnt[i - 1] + 1;
            sumv[i] = sumv[i - 1] + v[i];
        } else {
            cnt[i] = cnt[i - 1];
            sumv[i] = sumv[i - 1];
        }
    }
    ll sum = 0;
    for (int i = 1; i <= m; i++) {
        sum += (cnt[r[i]] - cnt[l[i] - 1]) * (sumv[r[i]] - sumv[l[i] - 1]);
    }
    return sum;
}
```

#### 3. 作者：Shunpower (赞：0)  
**星级：4星**  
**关键亮点：**  
- 详细解释了二分法的单调性，并提供了完整的代码实现。
- 代码中包含了调试和优化的思考过程，适合进阶学习。

**核心代码：**
```cpp
bool check(int wans) {
    x = sum = 0;
    memset(sumw, 0, sizeof(sumw));
    memset(sumv, 0, sizeof(sumv));
    for (int i = 1; i <= n; i++) {
        if (w[i] >= wans) {
            sumw[i] = sumw[i - 1] + 1;
            sumv[i] = sumv[i - 1] + v[i];
        } else {
            sumw[i] = sumw[i - 1];
            sumv[i] = sumv[i - 1];
        }
    }
    for (int i = 1; i <= m; i++) {
        x += (sumw[r[i]] - sumw[l[i] - 1]) * (sumv[r[i]] - sumv[l[i] - 1]);
    }
    sum = llabs(x - s);
    return x > s;
}
```

### 最优关键思路与技巧

1. **二分法**：利用 \( y \) 随 \( W \) 单调递减的性质，通过二分法快速找到最优的 \( W \)。
2. **前缀和优化**：通过预处理前缀和，将每个区间的检验值计算复杂度从 \( O(n) \) 降低到 \( O(1) \)，从而大幅提升整体效率。
3. **代码优化**：在实现时注意清空前缀和数组，避免多组数据之间的干扰。

### 可拓展之处

- **类似题目**：可以扩展到其他需要调整参数以优化结果的题目，如 P1083 借教室。
- **算法套路**：二分法结合前缀和的优化思路可以应用于其他区间查询问题，如区间和、区间最大值等。

### 推荐题目

1. **P1083 借教室**：考察二分法和前缀和的应用。
2. **P3382 线段树 1**：涉及区间查询和更新，适合练习前缀和和二分法。
3. **P3374 树状数组 1**：树状数组的应用，适合进一步学习区间查询的优化。

### 个人心得摘录

- **调试经历**：在实现二分法时，注意边界条件的处理，避免死循环或遗漏最优解。
- **踩坑教训**：多组数据时，务必清空前缀和数组，否则会导致错误结果。
- **顿悟感想**：二分法结合前缀和的优化思路非常高效，适合处理大规模数据查询问题。

---
处理用时：40.83秒
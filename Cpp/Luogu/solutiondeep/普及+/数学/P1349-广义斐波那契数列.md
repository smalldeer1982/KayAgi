# 题目信息

# 广义斐波那契数列

## 题目描述

广义的斐波那契数列是指形如 $a_n=p\times a_{n-1}+q\times a_{n-2}$ 的数列。

今给定数列的两系数 $p$ 和 $q$，以及数列的最前两项 $a_1$ 和 $ a_2$，另给出两个整数 $n$ 和 $m$，试求数列的第 $n$ 项 $a_n$ 对 $m$ 取模后的结果。



## 说明/提示

数列第 $10 $ 项是 $55$，$55 \bmod 7 = 6$。

【数据范围】  
对于 $100\%$ 的数据，$p,q,a_1,a_2 \in [0,2^{31}-1]$，$1\le n,m \le 2^{31}-1$。

---

$\text{upd 2023.8.23}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
1 1 1 1 10 7
```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

本题的核心在于求解广义斐波那契数列的第 \( n \) 项，且 \( n \) 和 \( m \) 的范围都很大（\( 1 \le n, m \le 2^{31}-1 \)）。直接递推或利用循环性质均不可行，因此需要借助矩阵快速幂或其他优化手段来高效计算。

从题解中可以看出，矩阵快速幂是最常用的解法，因为它能够在 \( O(\log n) \) 的时间复杂度内完成计算。此外，部分题解还尝试了其他优化思路，如通过递推公式推导出数列中相隔较远的项之间的关系，从而减少计算量。

### 所选高星题解

#### 1. 作者：奔波儿霸 (赞：63)  
**星级：5星**  
**关键亮点：**
- 使用矩阵快速幂，时间复杂度为 \( O(\log n) \)，适合大范围数据。
- 详细推导了广义斐波那契数列的矩阵形式，思路清晰。
- 代码结构清晰，矩阵乘法和快速幂的实现简洁高效。

**核心代码：**
```cpp
inline mat mul(mat a, mat b) {
    mat res;
    memset(res.m, 0, sizeof(res.m));
    for(int i=1; i<=2; i++) {
        for(int j=1; j<=2; j++) {
            for(int k=1; k<=2; k++) {
                res.m[i][j] += (a.m[i][k] % Mod) * (b.m[k][j] % Mod);
                res.m[i][j] %= Mod;
            }
        }
    }
    return res;
}

inline void Qmat_pow(int p) {
    while (p) {
        if(p & 1) Ans = mul(Ans, base);
        base = mul(base, base);
        p >>= 1;
    }
}
```

#### 2. 作者：ljc20020730 (赞：33)  
**星级：4星**  
**关键亮点：**
- 通过递推公式推导出数列中相隔较远的项之间的关系，减少计算量。
- 采用分段计算的方式，先计算大跨度的项，再逐步逼近目标项。
- 代码实现较为复杂，但思路独特，适合对矩阵快速幂不熟悉的读者。

**核心代码：**
```cpp
while(n>30000) {
    n-=30000;
    a[1]=(nextc*a[2]+nextd*a[1])%m;
    a[2]=(nextc*a[3]+nextd*a[2])%m;
    a[3]=(p*a[2]+q*a[1])%m;
}
```

#### 3. 作者：邓布利多6 (赞：8)  
**星级：4星**  
**关键亮点：**
- 使用矩阵快速幂，代码简洁，易于理解。
- 通过结构体和运算符重载实现矩阵乘法，代码可读性高。
- 快速幂的实现方式较为标准，适合初学者学习。

**核心代码：**
```cpp
matrix pow(matrix a,long long int k) {
    matrix b=a;
    k--;
    while(k) {
        if(k%2)b=b*a;
        a=a*a;
        k/=2;
    }
    return b;
}
```

### 最优关键思路与技巧

1. **矩阵快速幂**：通过将递推关系转化为矩阵乘法，利用快速幂算法在 \( O(\log n) \) 时间内求解，适用于大范围数据。
2. **递推公式优化**：通过推导数列中相隔较远的项之间的关系，减少计算量，适合对矩阵快速幂不熟悉的场景。
3. **结构体与运算符重载**：通过结构体和运算符重载实现矩阵乘法，提升代码的可读性和可维护性。

### 可拓展之处

- **同类型题**：类似的问题包括求解其他递推数列的第 \( n \) 项，如卢卡斯数列、佩尔数列等。
- **矩阵快速幂的应用**：矩阵快速幂不仅适用于斐波那契数列，还可以用于求解线性递推关系、图论中的路径计数等问题。

### 推荐题目

1. **P1939 【模板】矩阵加速（数列）**：考察矩阵快速幂的应用。
2. **P1962 斐波那契数列**：经典的斐波那契数列问题，适合练习矩阵快速幂。
3. **P3390 【模板】矩阵快速幂**：矩阵快速幂的模板题，适合初学者练习。

### 个人心得总结

- **调试经历**：部分题解中提到在推导矩阵形式时遇到困难，建议通过小规模数据验证矩阵的正确性。
- **踩坑教训**：在处理大范围数据时，注意避免溢出问题，尤其是在矩阵乘法中。
- **顿悟感想**：矩阵快速幂的核心在于将递推关系转化为矩阵乘法，理解这一点后，类似问题可以迎刃而解。

---
处理用时：31.84秒
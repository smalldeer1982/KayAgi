# 题目信息

# 数列的整除性

## 题目描述

对于任意一个整数数列，我们可以在每两个整数中间任意放一个符号 `+` 或 `-`，这样就可以构成一个表达式，也就可以计算出表达式的值。对于一个整数数列来说，我们能通过如上的方法构造出不同的表达式，从而得到不同的数值，如果其中某一个数值能够被 $k$ 整除的话，我们就称该数列能被 $k$ 整除。现在你的任务是判断某个数列是否能被某数整除。

## 说明/提示

#### 样例输入输出 1 解释

对于整数数列：$17,5,-21,-15$，可以构造出 $8$ 个表达式：

- $17+5+(-21)+15=16$
- $17+5+(-21)-15=-14$
- $17+5-(-21)+15=58$
- $17+5-(-21)-15=28$
- $17-5+(-21)+15=6$
- $17-5+(-21)-15=-24$
- $17-5-(-21)+15=48$
- $17-5-(-21)-15=18$


该数列能被 $7$ 整除（$17+5+(-21)-15=-14$），但不能被 $5$ 整除。

#### 数据规模与约定
对于全部的测试点，保证 $1 \le n \le 10^4,2 \le k \le 100,\left| a_i \right| \le 10^4$。

- $\text{upd 2022.9.27}$：新增加一组 Hack 数据。
- $\text{upd 2023.11.29}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
2
4 7
17 5 -21 15
4 5
17 5 -21 15
```

### 输出

```
Divisible
Not divisible

```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）来判断一个数列是否可以通过加减操作得到能被k整除的结果。所有题解都采用了DP的思路，但在实现细节、优化程度和代码可读性上有所不同。以下是各题解的主要特点和评分：

1. **LJC00118 (4星)**：使用了链表思想优化DP，代码简洁且内存占用小，适合大规模数据处理。
2. **courage (4星)**：状态转移方程清晰，代码结构简单，易于理解。
3. **Chloris (3星)**：详细解释了DP的状态转移和边界条件，但代码略显冗长。
4. **greenheadstrange (3星)**：通过01背包的思路解决问题，但转化过程稍显复杂。
5. **梧桐灯 (3星)**：使用了滚动数组优化空间，但代码实现较为复杂。
6. **彼岸归航 (3星)**：通过二维数组避免更新冲突，但代码复杂度较高。
7. **ljc20020730 (3星)**：思路清晰，但代码实现较为冗长。

### 所选高星题解

#### 1. LJC00118 (4星)
**关键亮点**：
- 使用链表思想优化DP，减少内存占用。
- 边加边模k，避免了大数计算。
- 代码简洁，适合大规模数据处理。

**个人心得**：
- 通过链表思想优化DP，避免了重复计算，提高了效率。

**核心代码**：
```cpp
for(int j=e;j>=1;j--) {
    f[(opt[j][1]+tmp)%k]=opt[j][0]+1; // 选择加这个数，边加边模k
    f[(opt[j][1]-tmp+k)%k]=opt[j][0]+1; // 选择减这个数，边减边模k
}
```

#### 2. courage (4星)
**关键亮点**：
- 状态转移方程清晰，代码结构简单。
- 使用函数p(x)处理负数取模，代码可读性强。

**核心代码**：
```cpp
for (int i=1;i<n;i++) {
    scanf("%d",&x);
    for (int j=0;j<k;j++) f[i][j]=f[i-1][p(j-x)]|f[i-1][p(j+x)];
}
```

### 最优关键思路与技巧

1. **动态规划**：通过DP记录前i个数通过加减操作得到的余数，最终判断是否能得到余数为0。
2. **模运算优化**：边加边模k，避免了大数计算，提高了效率。
3. **滚动数组**：使用滚动数组优化空间复杂度，适用于大规模数据处理。

### 可拓展之处

- **类似问题**：可以扩展到其他需要判断数列通过某种操作能否满足特定条件的问题，如能否得到某个特定值等。
- **算法套路**：DP+模运算的套路可以应用于其他需要处理大数或需要优化空间的问题。

### 推荐题目

1. **P1048 采药**：经典的01背包问题，与本题的DP思路相似。
2. **P1060 开心的金明**：通过DP解决物品选择问题，与本题的DP思路相似。
3. **P1077 摆花**：通过DP解决组合问题，与本题的DP思路相似。

### 个人心得总结

- **调试经历**：在处理负数取模时，需要特别注意避免负数结果，可以通过加k再模k的方式解决。
- **踩坑教训**：在更新DP状态时，需要注意避免重复更新，可以通过二维数组或链表思想优化。
- **顿悟感想**：通过模运算优化DP，可以大幅提高算法的效率和适用性。

---
处理用时：24.72秒
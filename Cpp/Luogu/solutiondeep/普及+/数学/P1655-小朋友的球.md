# 题目信息

# 小朋友的球

## 题目描述

@发源于 小朋友最近特别喜欢球。有一天他脑子抽了，从口袋里拿出了 $N$ 个不同的球，想把它们放到 $M$ 个相同的盒子里，并且要求每个盒子中至少要有一个球，他好奇有几种放法，于是尝试编程实现，但由于他天天不好好学习，只会上 B 站看游泳教练，于是他向你求助。

## 说明/提示

- 对于 $20\%$ 的数据，满足 $N,M \leq 10$；
- 对于 $100\%$ 的数据，满足 $1 \leq N,M \leq 100$，一个测试文件最多有 $10$ 组测试数据。


## 样例 #1

### 输入

```
4 2
1 1```

### 输出

```
7
1```

# AI分析结果

### 综合分析与结论

本题的核心是计算第二类斯特林数，即将 $N$ 个不同的球放入 $M$ 个相同的盒子中，且每个盒子至少有一个球的方案数。由于 $N$ 和 $M$ 的范围较大（$1 \leq N, M \leq 100$），直接使用递归或简单的动态规划会导致数值溢出，因此必须引入高精度运算。所有题解都采用了动态规划的思路，并在此基础上实现了高精度加法或乘法。以下是各题解的要点总结：

1. **算法思路**：所有题解都基于第二类斯特林数的递推公式 $f[i][j] = f[i-1][j-1] + f[i-1][j] \times j$，并通过动态规划实现。
2. **高精度处理**：由于结果可能非常大，题解中均实现了高精度加法或乘法，部分题解还通过运算符重载简化了代码。
3. **代码实现**：部分题解代码较为冗长，尤其是高精度部分的实现，而部分题解通过结构体或类封装了高精度运算，提升了代码的可读性和复用性。

### 所选高星题解

#### 1. 作者：Heartlessly (5星)
- **关键亮点**：
  - 代码结构清晰，高精度运算部分封装良好。
  - 使用了字符串处理高精度，避免了复杂的数组操作。
  - 初始化部分简洁明了，状态转移方程直接应用。
- **核心代码**：
  ```cpp
  string add(string a,string b) {
      string ans;
      int na[L]={0},nb[L]={0};
      int la=a.size(),lb=b.size();
      for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';
      for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';
      int lmax=la>lb?la:lb;
      for(int i=0;i<lmax;i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;
      if(na[lmax]) lmax++;
      for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';
      return ans;
  }
  ```
  **核心思想**：通过字符串实现高精度加法，避免了复杂的数组操作，代码简洁易读。

#### 2. 作者：李若谷 (4星)
- **关键亮点**：
  - 使用结构体封装高精度运算，代码复用性高。
  - 动态规划部分逻辑清晰，初始化简洁。
  - 通过运算符重载简化了高精度运算的调用。
- **核心代码**：
  ```cpp
  struct Wint:vector<int> {
      Wint(int n=0) { push_back(n); check(); }
      Wint& check() {
          while(!empty()&&!back()) pop_back();
          if(empty()) return *this;
          for(int i=1; i<size(); ++i) {
              (*this)[i]+=(*this)[i-1]/10;
              (*this)[i-1]%=10;
          }
          while(back()>=10) {
              push_back(back()/10);
              (*this)[size()-2]%=10;
          }
          return *this;
      }
  };
  ```
  **核心思想**：通过结构体封装高精度运算，简化了代码的调用和实现。

#### 3. 作者：HPXXZYY (4星)
- **关键亮点**：
  - 高精度运算部分通过结构体实现，代码结构清晰。
  - 动态规划部分逻辑清晰，初始化简洁。
  - 通过运算符重载简化了高精度运算的调用。
- **核心代码**：
  ```cpp
  struct node {
      int len,num[1100];
      node() { len=0; memset(num,0,sizeof(num)); }
      node operator + (node a) {
          node c; c.len=max(this->len,a.len);
          for(int i=1;i<=c.len;i++) {
              c.num[i]=a.num[i]+this->num[i];
              if(c.num[i]>=10) { c.num[i+1]+=c.num[i]/10; c.num[i]%=10; }
          }
          if(c.num[c.len+1]) c.len++;
          return c;
      }
  };
  ```
  **核心思想**：通过结构体封装高精度运算，简化了代码的调用和实现。

### 最优关键思路与技巧

1. **高精度运算的封装**：通过结构体或类封装高精度运算，可以显著提升代码的可读性和复用性。
2. **动态规划的状态转移**：第二类斯特林数的递推公式 $f[i][j] = f[i-1][j-1] + f[i-1][j] \times j$ 是核心，理解其背后的组合意义有助于解决类似问题。
3. **初始化与边界处理**：合理的初始化和边界处理（如 $n < m$ 时直接输出 0）可以避免不必要的计算。

### 拓展与举一反三

1. **类似题目**：
   - **洛谷 P2386**：放苹果问题，与本题类似，但盒子可以空着。
   - **洛谷 P1025**：数的划分，与本题类似，但元素相同。
   - **洛谷 P1044**：栈的序列数，与本题类似，涉及组合数学。

2. **调试与顿悟**：
   - **作者：ergeda**：提到“当 $m > n$ 或 $m == 0$ 时直接输出 0”，强调了边界条件的重要性，避免了许多不必要的错误。

### 推荐题目
1. **洛谷 P2386**：放苹果
2. **洛谷 P1025**：数的划分
3. **洛谷 P1044**：栈的序列数

---
处理用时：36.75秒
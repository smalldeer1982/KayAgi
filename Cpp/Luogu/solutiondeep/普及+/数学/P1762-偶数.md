# 题目信息

# 偶数

## 题目描述

给定一个正整数 $n$，请输出杨辉三角形前 $n$ 行的偶数个数对 $1000003$ 取模后的结果。


## 说明/提示

对于 $30\%$ 的数据，$n\le 4\times 10^3$。

对于 $70\%$ 的数据，$n\le 4\times 10^9$。

对于 $100\%$ 的数据，$1\le n\le 10^{15}$。

杨辉三角形的前七行：

```plain
       1
      1 1
     1 2 1
    1 3 3 1
   1 4 6 4 1
 1 5 10 10 5 1
1 6 15 20 15 6 1
```

## 样例 #1

### 输入

```
6
```

### 输出

```
6
```

# AI分析结果

### 综合分析与结论

本题要求计算杨辉三角形前 $n$ 行的偶数个数，并对结果取模 $1000003$。由于 $n$ 的范围很大（$1 \leq n \leq 10^{15}$），直接暴力计算或生成杨辉三角形是不可行的。因此，题解主要集中在寻找杨辉三角形中奇偶数的分布规律，并通过数学推导或递归分治的方法来优化计算。

大多数题解都利用了杨辉三角形在模 $2$ 下的分形性质，即奇数在杨辉三角形中的分布具有自相似性。通过将问题分解为更小的子问题，结合快速幂和递归等技巧，能够在 $O(\log n)$ 的时间复杂度内解决问题。

### 所选高星题解

#### 1. **作者：笨笨猪 (赞：112)**
- **星级：5星**
- **关键亮点：**
  - 通过观察杨辉三角形的奇偶分布，发现了奇数个数的规律，即每行奇数个数为 $2^k$，且当行数为 $2^k$ 时，奇数个数为 $2^k$，偶数个数为 $0$。
  - 利用二进制分解将问题转化为若干个 $2^k$ 的子问题，结合快速幂和预处理，实现了高效的递归计算。
  - 提供了详细的数学推导和表格，帮助理解规律。
- **核心代码：**
  ```cpp
  long long n, d, z, ans, a[55], b[55], v, p;
  int i, t;
  int main() {
      scanf("%lld",&v);
      n = v;
      z = 1;
      d = z << 50; // 2^50 > 10^15
      t = 50;
      while (n != 0) {
          if (n >= d) {
              n = n-d;
              a[++a[0]] = t; // 将2^t 的t存入数组中
          }
          d /= 2;
          t--;
      }
      b[0] = 1;
      for (i=1; i<=a[1]; ++i)
          b[i]=(b[i-1]*3)%mo; // 预处理3^t
      for (i=1; i<=a[0]; ++i)
          ans += b[a[i]]*(long long)(z << i-1); // 求所有奇数个数的和
      p = (((z+v%mo)*(v%mo))/2); // 求和公式
      p %= mo;
      ans %= mo;
      if (p<ans) p += mo;
      p = (p-ans)%mo; // 总个数减去所有奇数个数就是偶数个数了
      printf("%lld\n",p);
      return 0;
  }
  ```

#### 2. **作者：codecode (赞：3)**
- **星级：4星**
- **关键亮点：**
  - 通过卢卡斯定理，将问题转化为计算二进制表示下各位数字和为 $F(n)$ 的数的个数。
  - 利用二进制拆分和预处理 $3$ 的幂次，实现了高效的递归计算。
  - 代码简洁，逻辑清晰，适合理解二进制分解和递归的结合。
- **核心代码：**
  ```cpp
  const int mod=1e6+3;
  int n,ans,cnt,cnt2,a[55]={1},c[55]={1},b[35];
  signed main(){
      cin>>n;
      int n1=n%mod,n2=(n1*(n1+1)/2)%mod;
      for(int i=1;i<=50;i++)
          a[i]=(a[i-1]*3)%mod;
      for(int i=1;i<=50;i++)
          c[i]=(c[i-1]*2)%mod;
      while(n)b[cnt]=n&1,cnt++,n/=2;
      for(int i=cnt-1;i>=0;i--){
          if(!b[i])continue;
          ans+=c[cnt2]*a[i],ans%=mod;
          cnt2++;
      }
      cout<<((n2-ans)%mod+mod)%mod;
      return 0;
  }
  ```

#### 3. **作者：i207M (赞：3)**
- **星级：4星**
- **关键亮点：**
  - 利用卢卡斯定理和数位DP，计算二进制下有 $i$ 个 $1$ 的数字个数，并结合快速幂计算贡献。
  - 通过数位DP将问题转化为二进制位的处理，适合理解数位DP的应用。
- **核心代码：**
  ```cpp
  int dfs(int x,int num,bool jud) {
      if(num<0) return 0;
      if(x<=0) return num==0;
      if(!jud&&~f[x][num]) return f[x][num];
      int res=dfs(x-1,num,jud&&(dig[x]==0));
      if(!jud||dig[x]==1)
          (res+=dfs(x-1,num-1,jud&&(dig[x]==1)))%=md;
      if(!jud) f[x][num]=res;
      return res;
  }
  ```

### 最优关键思路与技巧
1. **二进制分解与递归**：通过将问题分解为若干个 $2^k$ 的子问题，结合递归和快速幂，能够在 $O(\log n)$ 的时间复杂度内解决问题。
2. **卢卡斯定理**：利用卢卡斯定理将问题转化为二进制位的处理，结合数位DP或二进制分解，进一步优化计算。
3. **预处理与快速幂**：通过预处理 $3$ 的幂次和快速幂，减少重复计算，提升效率。

### 可拓展之处
- **类似问题**：类似的问题可以考察二进制分解、递归、数位DP等技巧，如计算某些特定条件下的组合数或数的性质。
- **同类型题**：可以尝试解决其他涉及分形、二进制分解或数位DP的问题，如计算某些数列的特定性质或组合数的奇偶性。

### 推荐题目
1. **P1357 组合数问题**：考察组合数的性质及其在模意义下的计算。
2. **P2602 数字计数**：利用数位DP计算数字在某个范围内的出现次数。
3. **P2657  windy数**：通过数位DP计算满足特定条件的数的个数。

---
处理用时：46.85秒
# 题目信息

# [SDOI2008] 烧水问题

## 题目描述

把总质量为 $1\ \rm kg$ 的水分装在 $n$ 个杯子里，每杯水的质量均为 $(1/n)\ \rm kg$，初始温度均为 $0$ 度。现需要把每一杯水都烧开。我们可以对任意一杯水进行加热。把一杯水的温度升高 $t$ 度所需的能量为 $(4200\times t/n)\rm J$，其中，$\rm J$ 是能量单位“焦耳”。如果一旦某杯水的温度达到 $100$ 度，那么这杯水的温度就不能再继续升高，此时我们认为这杯水已经被烧开。显然地，如果直接把水一杯一杯地烧开，所需的总能量为 $(4200\times 100)\rm J$。

在烧水的过程中，我们随时可以在两杯温度不同的水之间进行热传递操作。热量只能从温度较高的那杯水传递到温度较低的那杯水。由于两杯水的质量相同，所以进行热传递操作之后，原来温度较高的那杯水所降低的温度总是等于原来温度较低的那杯水所升高的温度。

一旦两杯水的温度相同，热传递立刻停止。

为了把问题简化，我们假设：

1. 没有进行加热或热传递操作时，水的温度不会变化。
2. 加热时所花费的能量全部被水吸收，杯子不吸收能量。
3. 热传递总是隔着杯子进行，$n$ 杯水永远不会互相混合。
4. 热传递符合能量守恒，而且没有任何的热量损耗。

在这个问题里，只要求把每杯水都至少烧开一遍就可以了，而不要求最终每杯水的温度都是 $100$ 度。我们可以用如下操作把两杯水烧开：先把一杯水加热到 $100$ 度，花费能量 $(4200\times 100/2)\rm J$，然后两杯水进行热传递，直到它们的温度都变成 $50$ 度为止，最后把原来没有加热到 $100$ 度的那杯水加热到 $100$ 度，花费能量 $(4200\times 50/2)\rm J$，此时两杯水都被烧开过了，当前温度一杯 $100$ 度，一杯 $50$ 度，花费的总能量为 $(4200\times 75)\rm J$，比直接烧开所需的 $(4200\times 100)\rm J$ 少花费了 $25\%$ 的能量。

你的任务是设计一个最佳的操作方案使得 $n$ 杯水都至少被烧开一遍所需的总能量最少。


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le n \le 3000000$。

## 样例 #1

### 输入

```
2```

### 输出

```
315000.00```

# AI分析结果

### 综合分析与结论

本题的核心在于通过热传递优化烧水所需的能量，目标是找到一种策略使得所有杯子都被烧开且总能量最小。大部分题解都通过找规律或数学推导得出了递推公式，并利用该公式实现了O(n)的时间复杂度。题解的关键在于发现每杯水所需的能量与前一杯水所需的能量之间存在固定的比例关系，从而避免了O(n²)的暴力计算。

### 所选高星题解

#### 1. 作者：jimi1999 (5星)
- **关键亮点**：通过数学推导得出了每杯水所需能量的递推公式，代码简洁且时间复杂度为O(n)。
- **个人心得**：通过手动推导样例，发现了每杯水所需能量的比例关系，避免了复杂的数学证明。
- **核心代码**：
  ```cpp
  int main(){
      int n;
      double res,now;
      cin>>n;
      now = 420000.00/n;
      for(int i=1;i<=n;i++){
          res+=now;
          now*=(1-0.5/i);
      }    
      printf("%.2lf\n", res);
      return 0;
  } 
  ```
  **核心思想**：通过递推公式 `now *= (1 - 0.5 / i)` 计算每杯水所需的能量，累加得到总能量。

#### 2. 作者：夜刀神十香ღ (4星)
- **关键亮点**：通过找规律得出了每杯水所需能量的递推关系，代码简洁且易于理解。
- **个人心得**：通过手动模拟样例，发现了每杯水所需能量的比例关系，避免了复杂的数学推导。
- **核心代码**：
  ```cpp
  int main()
  {
      scanf("%d",&n);double cost=420000.00/n;
      for(int i=1;i<n;i++)
      {
          ans+=cost;
          cost*=(double)(2*i-1)/(double)(2*i);
      }
      printf("%.2lf",ans+cost);
      return 0;
  }
  ```
  **核心思想**：通过递推公式 `cost *= (2 * i - 1) / (2 * i)` 计算每杯水所需的能量，累加得到总能量。

#### 3. 作者：傅思维666 (4星)
- **关键亮点**：通过数学推导得出了每杯水所需能量的递推公式，并提供了详细的推导过程。
- **个人心得**：通过手推样例，发现了每杯水所需能量的比例关系，避免了复杂的数学证明。
- **核心代码**：
  ```cpp
  int main()
  {
      scanf("%d",&n);
      double tot=100.0;
      t[1]=100.0;
      for(int i=2;i<=n;i++)
      {
          t[i]=t[i-1]*(2*(i-1)-1)/(2*(i-1));
          tot+=t[i];
      }
      double ans=4200*tot/n;
      printf("%.2lf\n",ans);
      return 0;
  }
  ```
  **核心思想**：通过递推公式 `t[i] = t[i-1] * (2 * (i-1) - 1) / (2 * (i-1))` 计算每杯水所需的能量，累加得到总能量。

### 最优关键思路与技巧

1. **递推公式**：通过数学推导或找规律，发现每杯水所需能量与前一杯水所需能量之间存在固定的比例关系，从而避免了O(n²)的暴力计算。
2. **贪心策略**：每次尽量利用热传递来减少加热所需的能量，确保每杯水都被烧开且总能量最小。
3. **数学归纳法**：通过数学归纳法验证递推公式的正确性，确保算法的准确性。

### 可拓展之处

1. **类似问题**：可以拓展到其他需要优化能量或资源分配的问题，如加热不同质量的水、加热不同初始温度的水等。
2. **算法套路**：类似的递推公式和贪心策略可以应用于其他需要优化资源分配的问题，如任务调度、资源分配等。

### 推荐题目

1. [P1984 [SDOI2008]烧水问题](https://www.luogu.org/problem/P1984)
2. [P1886 滑动窗口](https://www.luogu.org/problem/P1886)
3. [P1880 [NOI1995]石子合并](https://www.luogu.org/problem/P1880)

### 个人心得总结

- **调试经历**：通过手动模拟样例，发现了每杯水所需能量的比例关系，避免了复杂的数学推导。
- **踩坑教训**：在推导递推公式时，需要注意比例关系的准确性，避免因精度问题导致计算结果错误。
- **顿悟感想**：通过找规律和数学推导，可以简化复杂问题的求解过程，提高算法的效率。

---
处理用时：33.29秒
# 题目信息

# L 国的战斗续之多路出击

## 题目背景

广而告之：背景见其他L国的战斗！！大家一起刷


## 题目描述

这一次，L 国决定军队分成 $n$ 组，分布在各地，若以 L 国为原点，可以看作在一个直角坐标系内。但是他们都受统一的指挥，指令部共发出 $m$ 个命令。命令有移动、上下转移和左右转移，但是由于某些奇奇怪怪的原因，军队收到命令总是有延迟，为了方便，军方已经写好一个栈，所以你要处理的顺序，应该是从后往前。


## 说明/提示

对于 $30\%$ 的数据，$1\leqslant n,m\leqslant 1000$。

对于 $100\%$ 的数据，$1\leqslant n,m\leqslant 5\times 10^5$，$x_i,y_i$ 在 `int` 范围内。

## 样例 #1

### 输入

```
3 3
0 0
4 -3
6 7
x
m -1 2
y
```

### 输出

```
1 2
-3 5
-5 -5
```

# AI分析结果

### 综合分析与结论

本题的核心在于处理多个操作对坐标系的影响，且操作顺序是逆序的。大多数题解采用了**标记化思想**或**矩阵乘法**来优化操作的处理，避免了对每个点进行逐个操作的O(nm)复杂度。标记化思想通过维护翻转标记和位移量，最终统一应用到所有点上，时间复杂度为O(n+m)。矩阵乘法则通过将操作转化为矩阵，利用矩阵的结合律，最终将矩阵应用到每个点上，时间复杂度同样为O(n+m)。

### 所选高星题解

#### 1. 作者：sSay (赞：23)  
**星级：5星**  
**关键亮点：**  
- 采用标记化思想，维护翻转标记和位移量，最终统一应用到所有点上。
- 代码简洁，思路清晰，时间复杂度为O(n+m)。

**核心代码：**
```cpp
ll deltax = 0, deltay = 0;
for(int i = m; i >= 1; --i) {
    if(ch[i] == 'x') flag1 ^= 1;
    else if(ch[i] == 'y') flag2 ^= 1;
    else {
        deltax += Get(flag1) * a[i];
        deltay += Get(flag2) * b[i];
    }
}
for(int i = 1; i <= n; ++i) {
    cout << Get(flag1) * (deltax + x[i]) << ' ' << Get(flag2) * (deltay + y[i]) << endl;
}
```
**实现思想：**  
通过维护`flag1`和`flag2`来记录x轴和y轴的翻转状态，`deltax`和`deltay`记录位移量。最终根据翻转状态和位移量统一应用到所有点上。

#### 2. 作者：1沃尔克 (赞：8)  
**星级：4星**  
**关键亮点：**  
- 同样采用标记化思想，维护翻转标记和位移量。
- 代码简洁，思路清晰，时间复杂度为O(n+m)。

**核心代码：**
```cpp
long long xx=0,sx=1,yy=0,sy=1;
for(int i=m;i>=1;i--) {
    if(c[i]=='y') { sy=-sy; yy=-yy; }
    if(c[i]=='m') { xx+=a[i]; yy+=b[i]; }
    if(c[i]=='x') { sx=-sx; xx=-xx; }
}
for(int i=1;i<=n;i++) {
    printf("%lld %lld\n",lc[i].x*sx+xx,lc[i].y*sy+yy);
}
```
**实现思想：**  
通过维护`sx`和`sy`来记录x轴和y轴的翻转状态，`xx`和`yy`记录位移量。最终根据翻转状态和位移量统一应用到所有点上。

#### 3. 作者：Kisaragi_77 (赞：2)  
**星级：4星**  
**关键亮点：**  
- 采用标记化思想，维护翻转标记和位移量。
- 代码简洁，思路清晰，时间复杂度为O(n+m)。

**核心代码：**
```cpp
int add_x =0,add_y =0,mul_x =1,mul_y =1;
for(int i=m;i>=1;--i) {
    if(s[i].op=='x')  add_x *=-1,mul_x *=-1;
    else if(s[i].op=='y') add_y *=-1,mul_y *=-1;
    else add_x +=s[i].x,add_y +=s[i].y;
}
for(int i=1;i<=n;++i) {
    printf("%d %d\n",x[i]*mul_x+add_x,y[i]*mul_y+add_y);
}
```
**实现思想：**  
通过维护`mul_x`和`mul_y`来记录x轴和y轴的翻转状态，`add_x`和`add_y`记录位移量。最终根据翻转状态和位移量统一应用到所有点上。

### 最优关键思路或技巧

- **标记化思想**：通过维护翻转标记和位移量，最终统一应用到所有点上，避免了逐个操作的O(nm)复杂度。
- **矩阵乘法**：将操作转化为矩阵，利用矩阵的结合律，最终将矩阵应用到每个点上，时间复杂度为O(n+m)。

### 可拓展之处

- **类似算法套路**：在处理多个操作对数据结构的影响时，标记化思想和矩阵乘法是常见的优化手段，适用于需要批量处理操作的场景。
- **同类型题目**：类似的操作处理问题可以通过标记化思想或矩阵乘法进行优化，如区间修改、区间查询等问题。

### 推荐题目

1. **P3373 【模板】线段树 2** - 考察区间加法和乘法操作的处理。
2. **P2023 【模板】维护序列** - 考察区间修改和查询操作的处理。
3. **P2129 L国的战斗续之多路出击** - 本题的变种，考察多操作对坐标系的影响。

### 个人心得总结

- **调试经历**：在处理翻转操作时，需要注意翻转对位移量的影响，避免直接应用位移量导致错误。
- **踩坑教训**：在处理逆序操作时，确保操作的顺序正确，避免顺序错误导致结果不正确。
- **顿悟感想**：标记化思想和矩阵乘法在处理批量操作时非常高效，能够显著降低时间复杂度。

---
处理用时：41.74秒
# 题目信息

# 最小和

## 题目背景

RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。所以今天只有短的RSA钥匙才可能被强力方式解破。


## 题目描述

已知 $a$，$b$ 是正整数且 $a \leq b$。

求满足条件且 $x+y$ 的值最小的 $x$，$y$。

条件：

- $\gcd(x,y) = a$
- $\mathrm{lcm}(x,y) = b$
- $x \leq y$


## 说明/提示

$3 \leq a, b < 2^{63}$。

EOF 结束，没有代表行数的 $n$，第一行就是数据。

数据随机生成。


## 样例 #1

### 输入

```
3 60```

### 输出

```
12 15```

## 样例 #2

### 输入

```
200 20000
300 30000
400 40000```

### 输出

```
800 5000
1200 7500
1600 10000```

# AI分析结果

### 综合分析与结论

本题的核心问题是在给定最大公约数（GCD）和最小公倍数（LCM）的情况下，找到满足条件且和最小的两个数 \(x\) 和 \(y\)。各题解的思路主要集中在以下几点：

1. **数学转化**：将问题转化为求 \(x\) 和 \(y\) 的表达式，通常设 \(x = a \times n\)，\(y = a \times m\)，其中 \(a\) 是 GCD，\(n\) 和 \(m\) 互质，且 \(n \times m = \frac{b}{a}\)。
2. **质因数分解**：对 \(\frac{b}{a}\) 进行质因数分解，然后将质因数分配给 \(n\) 和 \(m\)，确保它们互质。
3. **搜索与优化**：通过 DFS 或背包算法，将质因数分配给 \(n\) 和 \(m\)，使得 \(n + m\) 最小。

各题解的主要区别在于质因数分解的方法（如 Pollard-Rho 或暴力分解）以及搜索策略（如 DFS 或背包）。由于数据随机生成，暴力分解在大多数情况下是可行的。

### 所选高星题解

#### 1. **Flandre_495 (4星)**
- **关键亮点**：使用背包算法将质因数分配给 \(n\) 和 \(m\)，确保 \(n + m\) 最小。代码清晰，思路明确。
- **个人心得**：指出贪心算法在某些情况下不适用，必须使用背包算法来确保正确性。
- **核心代码**：
  ```cpp
  for(int i=1;i<=cnt;i++) {
      int len = ans.size();
      for(int j=0;j<len;j++) {
          if(ans[j]*pre[i] > sqrt(c)) continue;
          ans.push_back( ans[j]*pre[i] );
      }
  }
  sort(ans.begin(),ans.end());
  x = ans[ans.size()-1];
  y = c / x;
  ```

#### 2. **critnos (4星)**
- **关键亮点**：使用 DFS 枚举质因数的分配，确保 \(n + m\) 最小。代码简洁，逻辑清晰。
- **核心代码**：
  ```cpp
  void dfs(ll d,ll s) {
      if(d==len) {
          if(s+kc/s<mn) {
              mn=s+kc/s;
              xx=s;
              yy=kc/s;
          }
          return;
      }
      dfs(d+1,s);
      dfs(d+1,s*zyx[d]);
  }
  ```

#### 3. **Leasier (4星)**
- **关键亮点**：使用 Pollard-Rho 进行质因数分解，结合 DFS 枚举质因数的分配，确保 \(n + m\) 最小。代码结构清晰，优化程度高。
- **核心代码**：
  ```cpp
  ll dfs(ll n, int cnt, ll cur, int depth) {
      if (cur > n) return 0;
      if (depth > cnt) return cur;
      int depth_i = depth + 1;
      return max(dfs(n, cnt, cur, depth_i), dfs(n, cnt, cur * p_pow_k[depth], depth_i));
  }
  ```

### 最优关键思路与技巧

1. **数学转化**：将问题转化为求互质的 \(n\) 和 \(m\)，使得 \(n \times m = \frac{b}{a}\)，且 \(n + m\) 最小。
2. **质因数分解**：对 \(\frac{b}{a}\) 进行质因数分解，确保每个质因数只能分配给 \(n\) 或 \(m\)。
3. **搜索策略**：使用 DFS 或背包算法，将质因数分配给 \(n\) 和 \(m\)，确保 \(n + m\) 最小。

### 可拓展之处

- **类似问题**：在给定 GCD 和 LCM 的情况下，求满足条件的 \(x\) 和 \(y\) 的其他性质（如差最小、积最大等）。
- **算法优化**：在质因数分解时，可以进一步优化分解算法，如使用 Pollard-Rho 或 Miller-Rabin 算法。

### 推荐题目

1. **P1075 [NOIP2012 提高组] 质因数分解**（考察质因数分解）
2. **P1069 [NOIP2009 提高组] 细胞分裂**（考察 GCD 和 LCM 的应用）
3. **P1082 [NOIP2012 提高组] 同余方程**（考察数论中的扩展欧几里得算法）

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现贪心算法在某些情况下不适用，必须使用背包算法来确保正确性。
- **踩坑教训**：在质因数分解时，需要注意分解的效率和正确性，尤其是在处理大数时。
- **顿悟感想**：通过将问题转化为数学表达式，可以简化问题的复杂度，使得搜索和优化更加高效。

---
处理用时：38.12秒
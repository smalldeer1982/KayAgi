# 题目信息

# 正妹吃月饼

## 题目描述

今天是中秋节。uim 带来了一堆大小不同且味道各异的月饼。

这些月饼的质量分别是 $1g,2g,4g,8g,16g$....后面一个是前面的 $2$ 倍。每种只有一个。

uim 让正妹随便吃。

正妹希望尝试尽可能多的口味，所以会吃尽可能多数量的月饼（不是重量）。而且她的确有些饿了，至少总共要吃掉 $A\text{g}$ 的月饼才能满足。

然而正妹怕长胖，所以吃月饼不能合计超过 $B\text{g}$ 。

她希望知道自己最多能吃多少个月饼


## 说明/提示

**样例解释**：

正妹可以吃 $1,2,4,16$ 这 $4$ 个月饼（吃法可能不唯一）。

**数据范围**：

对于 $30\%$ 数据，$1\le A,B \le 1000$；

对于 $60\%$ 数据，$1 \le A,B \le 100000$；

对于 $100\%$ 数据，$1 \le A,B \le 2^{63}-1$。


## 样例 #1

### 输入

```
16 25```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在给定的重量范围 `[A, B]` 内，选择尽可能多的月饼，且这些月饼的总重量不超过 `B`。由于月饼的重量是 2 的幂次方，问题可以转化为在 `[A, B]` 范围内找到一个二进制表示中 1 的个数最多的数。多位题解通过位运算、贪心算法、二进制分解等方法解决了这一问题。

### 所选高星题解

#### 1. 题解作者：Invoker (5星)
**关键亮点**：
- 使用位运算从最低位开始贪心地填充 1，确保在不超过 `B` 的情况下尽可能多地增加 1 的个数。
- 代码简洁高效，直接通过 `while((l|(l+1))<=r)` 和 `l|=l+1` 实现贪心策略。

**核心代码**：
```cpp
while((l|(l+1))<=r) l|=l+1;
while(l) ans+=l&1, l>>=1;
```
**实现思想**：通过不断将 `l` 的最低位的 0 变为 1，确保在不超过 `r` 的情况下，`l` 的二进制表示中 1 的个数最多。

#### 2. 题解作者：Dog_Two (4星)
**关键亮点**：
- 从高位到低位逐步减去 2 的幂次方，确保在总重量不低于 `A` 的情况下，尽可能多地保留月饼。
- 通过全 1 的二进制数作为初始值，确保解的正确性和最优性。

**核心代码**：
```cpp
while(val<B) val=(val<<1)+1;
for(;val>B;Bit>>=1){
    val=val-Bit<A?val:val-Bit;
}
```
**实现思想**：通过从高位到低位逐步减去 2 的幂次方，确保在总重量不低于 `A` 的情况下，尽可能多地保留月饼。

#### 3. 题解作者：zrzluck99 (4星)
**关键亮点**：
- 通过异或操作找到 `A` 和 `B` 的最高不同位，然后在该位之后填充 1，确保在 `[A, B]` 范围内 1 的个数最多。
- 代码简洁，思路清晰，适合理解位运算的初学者。

**核心代码**：
```cpp
while (t>0) t>>=1, x|=t;
while (x>0) x&=x-1, q++;
```
**实现思想**：通过异或操作找到 `A` 和 `B` 的最高不同位，然后在该位之后填充 1，确保在 `[A, B]` 范围内 1 的个数最多。

### 最优关键思路与技巧
1. **位运算与贪心结合**：通过位运算从最低位或最高位开始贪心地填充或删除 1，确保在 `[A, B]` 范围内 1 的个数最多。
2. **二进制分解**：将问题转化为二进制表示中 1 的个数最多的问题，利用二进制的特性简化问题。
3. **全 1 二进制数作为初始值**：确保解的正确性和最优性，避免遗漏可能的解。

### 可拓展之处
- **类似问题**：可以扩展到其他进制或权重不同的组合问题，如三进制、四进制等。
- **算法套路**：贪心算法与位运算结合，适用于类似的组合优化问题。

### 推荐题目
1. **P1048 采药**：考察贪心算法的经典题目。
2. **P1060 开心的金明**：涉及二进制分解与贪心算法的结合。
3. **P1077 摆花**：类似组合优化问题，适合练习贪心与位运算的结合。

### 个人心得摘录
- **Invoker**：通过不断将最低位的 0 变为 1，确保在不超过 `B` 的情况下，`l` 的二进制表示中 1 的个数最多。
- **Dog_Two**：从高位到低位逐步减去 2 的幂次方，确保在总重量不低于 `A` 的情况下，尽可能多地保留月饼。
- **zrzluck99**：通过异或操作找到 `A` 和 `B` 的最高不同位，然后在该位之后填充 1，确保在 `[A, B]` 范围内 1 的个数最多。

---
处理用时：31.65秒
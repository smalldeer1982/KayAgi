# 题目信息

# 角色属性树

## 题目描述

绪萌同人社是一个有趣的组织，该组织结构是一个树形结构。有一个社长，直接下属一些副社长。每个副社长又直接下属一些部长……。

每个成员都有一个萌点的属性，萌点属性是由一些质数的萌元素乘积构成（例如，猫耳的值是 $2$，弱气的值是 $3$，黄毛的值是 $5$，病娇的值是 $7$，双马尾的值是 $11$ 等等）

举个例子，正妹是双份的猫耳，而且有一份弱气，她的属性值为 $2\times 2\times 3=12$。

现在组员关心一个问题，希望知道离自己最近且有相同萌元素上司是谁，例如，属性值为 $2、4、6、45$ 这样的属性值都算是和正妹有相同的属性。


然而，组员可能会随时变化自己的属性。啊。。感觉好麻烦啊。。


## 说明/提示

对于 $20\%$ 的数据，没有修改的操作。

对于 $50\%$ 的数据，$n\le 100$，修改次数 $<10$。

对于 $100\%$ 的数据，$n\le 200000$，$k<100000$，修改次数 $\le 50,a\_i\le 2^{31}-1$

UPD：本题测试数据随机，可能是假题。

## 样例 #1

### 输入

```
4 6

10 8 4 3

1 2

2 3

3 4

1 1

1 2

1 3

1 4

2 1 9

1 4```

### 输出

```
-1

1

2

-1

1```

# AI分析结果

### 综合分析与结论

本题的核心问题是在树形结构中快速查找某个节点的最近祖先，且该祖先与当前节点的属性值有相同的质因数（即 `gcd > 1`）。由于数据随机，且树高较小，暴力解法在实际测试中表现良好。大多数题解采用了暴力搜索的方式，通过递归或循环从当前节点向上遍历祖先，直到找到满足条件的节点或到达根节点。

尽管暴力解法在随机数据下表现良好，但其时间复杂度在最坏情况下为 `O(n * k)`，对于大规模数据可能无法通过。因此，如果数据不随机或树高较大，可能需要更高效的算法，如倍增法或预处理质因数分解。

### 所选高星题解

#### 1. 作者：WZKQWQ (4星)
**关键亮点**：  
- 解释了为什么暴力解法在随机数据下可行，给出了 `gcd(a, b) > 1` 的概率分析。
- 代码简洁，逻辑清晰，使用了 `__gcd` 函数进行快速计算。

**个人心得**：  
- 提到“数据随机”是暴力解法可行的关键，提醒了读者在类似题目中注意数据特性。

**核心代码**：
```cpp
int dfs(int x,int y){
    if(x == 0) return -1;
    if(__gcd(a[x],a[y]) > 1) return x;
    return dfs(fa[x],y);
}
```
**实现思想**：通过递归从当前节点向上遍历祖先，直到找到 `gcd > 1` 的节点或到达根节点。

#### 2. 作者：quanjun (4星)
**关键亮点**：  
- 强调了数据水（随机）是暴力解法通过的关键，提醒了读者在实际比赛中注意数据特性。
- 代码简洁，直接使用循环进行祖先遍历。

**核心代码**：
```cpp
int solve(int u) {
    for (int v = fa[u]; v; v = fa[v]) if (__gcd(a[u], a[v]) > 1) return v;
    return -1;
}
```
**实现思想**：通过循环从当前节点向上遍历祖先，直到找到 `gcd > 1` 的节点或到达根节点。

#### 3. 作者：tobie (4星)
**关键亮点**：  
- 分析了树高约为 `log(n)`，解释了暴力解法在随机数据下的可行性。
- 代码简洁，逻辑清晰，使用了 `gcd` 函数进行快速计算。

**核心代码**：
```cpp
int solve(int x){
    int now=fa[x];
    while(now!=0){
        if(gcd(a[x],a[now])>1) return now;
        now=fa[now];
    }
    return -1;
}
```
**实现思想**：通过循环从当前节点向上遍历祖先，直到找到 `gcd > 1` 的节点或到达根节点。

### 最优关键思路或技巧

1. **暴力搜索的可行性**：在随机数据下，暴力搜索的时间复杂度较低，且实现简单，适合快速通过题目。
2. **`gcd` 函数的应用**：通过 `__gcd` 函数快速判断两个数是否有相同的质因数，简化了代码实现。
3. **数据特性的利用**：在类似题目中，注意数据的随机性和树高，选择合适的算法。

### 可拓展之处

1. **倍增法**：如果数据不随机或树高较大，可以使用倍增法预处理每个节点的祖先，快速找到满足条件的节点。
2. **质因数分解预处理**：可以预处理每个节点的质因数，利用质因数集合的交集来判断 `gcd > 1`，提高查询效率。

### 推荐相似题目

1. **P3379 【模板】最近公共祖先（LCA）**：考察树的基本操作和LCA算法。
2. **P1967 货车运输**：考察树的重构和路径查询。
3. **P3384 【模板】树链剖分**：考察树链剖分和路径查询。

### 个人心得总结

- **数据特性**：在类似题目中，注意数据的随机性和树高，选择合适的算法。
- **暴力解法的可行性**：在数据随机的情况下，暴力解法往往能够通过，且实现简单。
- **`gcd` 函数的应用**：通过 `__gcd` 函数快速判断两个数是否有相同的质因数，简化了代码实现。

---
处理用时：30.33秒
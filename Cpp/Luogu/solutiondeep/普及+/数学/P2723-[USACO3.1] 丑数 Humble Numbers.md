# 题目信息

# [USACO3.1] 丑数 Humble Numbers

## 题目描述

对于一给定的素数集合 $S = \{ p_1, p_2, ..., p_k \}$, 考虑一个正整数集合，该集合中任一元素的质因数全部属于 $S$。这个正整数集合包括，$p_1$、$p_1 \times p_2$、$p_1 \times p_1$、$p_1 \times p_2 \times p_3$ ...(还有其它)。该集合被称为 $S$ 集合的“丑数集合”。注意：我们认为 $1$不是一个丑数。

你的工作是对于输入的集合 $S$ 去寻找“丑数集合”中的第 $n$ 个“丑数”。保证答案可以用 32 位有符号整数表示。

补充：丑数集合中每个数从小到大排列，每个丑数都是素数集合中的数的乘积，第 $n$ 个“丑数”就是在能由素数集合中的数相乘得来的（包括它本身）第 $n$ 小的数。


## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq k \leq 100$。
- $1 \leq n \leq 10^5$。
- $2 \leq p_i < 2^{31}$，且 $p_i$ 一定为质数。

---
#### 说明

题目翻译来自 NOCOW。

USACO Training Section 3.1


## 样例 #1

### 输入

```
4 19
2 3 5 7```

### 输出

```
27```

# AI分析结果



### 综合分析与结论
本题核心在于高效生成按序排列的丑数。各解法主要分为两类：动态规划维护指针（O(nk)最优解）和基于堆/平衡树的生成法（易超时）。最优解法通过维护每个质数对应的最小候选位置，保证线性时间复杂度，显著优于基于数据结构的暴力生成法。

---

### 高星题解推荐

#### 1. Mark_ZZY（★★★★★）
**关键亮点**：动态规划+指针维护  
- 维护每个质数对应丑数数组的指针，确保每次生成最小候选  
- 时间复杂度O(nk)，空间效率极佳  
- 代码简洁，无冗余操作  

**核心代码**：
```cpp
int s[100001], b[101]; // s存储丑数，b记录质数指针
for(int i=1; i<=m; i++){
    int min = INT_MAX;
    for(int j=1; j<=n; j++){
        while(a[j]*s[b[j]] <= s[i-1]) b[j]++;
        if(a[j]*s[b[j]] < min) min = a[j]*s[b[j]];
    }
    s[i] = min;
}
```

#### 2. Celebrate（★★★★★）
**关键亮点**：同思路优化版  
- 添加了数据类型优化（long long防溢出）  
- 完整处理文件输入输出，适合竞赛场景  

**个人心得**：  
> "需注意s[j]指针的初始化，必须从0开始逐步推进，否则会遗漏候选数"

#### 3. iftest614（★★★★☆）
**关键亮点**：暴力优化思路解析  
- 详细解释指针维护的单调性原理  
- 伪代码形式突出算法核心，便于理解  

---

### 最优思路提炼
**动态规划指针法**：  
1. 用数组记录每个质数当前乘的丑数位置  
2. 每次各质数用当前指针位置生成候选值  
3. 取候选值最小者为新丑数，并更新对应指针  
**关键技巧**：利用丑数序列的单调性，确保指针只需单向移动。

---

### 拓展与举一反三
1. **同类问题**：  
   - 多路归并思想（如合并k个有序链表）  
   - 超级丑数（LeetCode 313）  
2. **推荐题目**：  
   - 洛谷 P2723 丑数（同题）  
   - 洛谷 P1445 樱花（质因数分解应用）  
   - 洛谷 P1621 集合（质数筛法结合合并操作）  

---

### 关键代码实现（Mark_ZZY版核心）
```cpp
int main() {
    scanf("%d %d", &k, &n);
    for(int i=1; i<=k; i++) scanf("%d", &a[i]);
    s[0] = 1;
    for(int i=1; i<=n; i++){
        int min = 2147483647;
        for(int j=1; j<=k; j++) {
            while(a[j]*s[b[j]] <= s[i-1]) b[j]++;
            if(a[j]*s[b[j]] < min) min = a[j]*s[b[j]];
        }
        s[i] = min;
    }
    printf("%d", s[n]);
}
```

---
处理用时：60.62秒
# 题目信息

# [USACO4.1] 麦香牛块Beef McNuggets

## 题目描述

农夫布朗的奶牛们正在进行斗争，因为它们听说麦当劳正在考虑引进一种新产品：麦香牛块。奶牛们正在想尽一切办法让这种可怕的设想泡汤。奶牛们进行斗争的策略之一是“劣质的包装”。“看，”奶牛们说，“如果你只用一次能装 $3$ 块、 $6$ 块或者 $10$ 块的三种包装盒包装麦香牛块，你就不可能满足一次只想买 $1$ 、 $2$ 、 $4$ 、 $5$ 、 $7$ 、 $8$ 、 $11$ 、 $14$ 或者 $17$ 块麦香牛块的顾客了。劣质的包装意味着劣质的产品。”。

你的任务是帮助这些奶牛。给出包装盒的种类数 $N(1 \le N \le 10)$ 和 $N$ 个代表不同种类包装盒容纳麦香牛块个数的正整数 $(1 \le i \le 256)$，输出顾客不能用上述包装盒（每种盒子数量无限）买到麦香牛块的最大块数。如果所有购买方案都能得到满足或者不存在不能买到块数的上限，则输出 $0$。不能买到的最大块数（倘它存在）不超过 $2\times 10^9$。

## 说明/提示

题目翻译来自 NOCOW。

USACO Training Section 4.1


## 样例 #1

### 输入

```
3

3

6

10```

### 输出

```
17```

# AI分析结果



### 综合分析与结论
本题需解决无限背包组合数的最大不可达值问题，核心难点在于确定枚举上界与高效验证。题解主要分为两类：基于数论上界分析的完全背包解法，以及图论最短路模型转换。最优解法通过模运算确定合理上界（如255×256），结合动态规划验证。

### 精选题解推荐

#### 1. 作者：_rqy（★★★★★）
**关键亮点**  
- 严谨数学证明：通过模运算与鸽巢原理推导上界（255×256），避免盲目枚举  
- 高效实现：基于完全背包的简洁代码，时间复杂度可控  
- 深入分析：指出其他题解滥用小凯结论的问题，给出正确理论支撑  

**核心代码**  
```cpp
bool dp[MAXLIM + 1] = {1};
for (int i = 1; i <= n; i++)
    for (int j = a[i]; j <= MAXLIM; j++)
        dp[j] |= dp[j - a[i]];
// 逆向遍历找最大不可达值
```

#### 2. 作者：cabasky（★★★★☆）
**关键亮点**  
- 创新建模：将余数转化为图节点，用最短路求最小可达值  
- 数学与图论结合：通过边权转移实现余数覆盖分析  
- 高效处理大范围：避免直接大数组枚举，复杂度O(n·min(a))  

**核心代码**  
```cpp
// 构建余数转移图
for (int i = 0; i < min_a; i++)
    for (auto x : a) 
        add_edge(i, (i + x) % min_a, x);
// SPFA求最短路后计算最大gap
max_val = max(dis[i]) - min_a;
```

#### 3. 作者：HigHwind（★★★★☆）
**关键亮点**  
- 实用优化：基于256²的经验上界，平衡效率与正确性  
- 边界处理：针对特殊测试数据调整阈值（65025）  
- 代码简洁：清晰展现完全背包核心逻辑  

**调试心得**  
> "发现256²边界在特定数据下失效，故调整上限为65025，通过反向遍历避免漏解"

### 最优思路总结
1. **数论分析先行**：检查所有数的gcd，非1直接输出0  
2. **模运算定上界**：取最小数a₁的余数分组，推导出上界为(a₁-1)*max_a - a₁  
3. **动态规划验证**：完全背包标记可达值，逆序找最大空缺  
4. **最短路替代思路**：将余数状态建模为图节点，BFS求最小可达值  

### 拓展与相似题目
1. **小凯的疑惑**（P3951）：两数互质时的最大不可达值  
2. **货币系统**（P5020）：完全背包求极大无关组  
3. **裴蜀定理**（P4549）：验证线性组合覆盖性  

### 关键代码片段
**完全背包核心实现**  
```cpp
vector<bool> dp(upper_bound, false);
dp[0] = true;
for (int num : nums) {
    for (int j = num; j < upper_bound; ++j) {
        dp[j] = dp[j] || dp[j - num];
    }
}
// 逆向扫描找答案
for (int i = upper_bound - 1; i >= 0; --i) {
    if (!dp[i]) return (i > threshold) ? 0 : i;
}
```

---
处理用时：69.80秒
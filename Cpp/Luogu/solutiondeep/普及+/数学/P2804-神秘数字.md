# 题目信息

# 神秘数字

## 题目背景

在公元XXXX年，侦探小明收到了组织的神秘信息，在Y市的某个地方有一道神秘的门。小明到达了那个门后，发现门上有一行字：“这个门需要密码才能解锁。”小明左找右找，终于找到了一张字条：“现在给你n个数，请你求出这n个数里面，有多少个连续的数的平均数大于某个给定的数M？注意：这个数可能会很大，请输出这个数对92084931取模的结果。最终的结果即是这个门的密码。”小明苦思冥想了半天，但始终找不到答案。于是他来求助于你。请你帮他解决这个问题。由于小明十分着急，他最多只能等1秒。


## 题目描述

给定n个数，请你帮助小明求出里面有多少个连续的数的平均数大于给定的某个数M.并将这个方案数输出。注意：这个数可能会很大，所以请输出这个数对92084931取模的结果。


## 说明/提示

【样例解释】

①对于这4个数，问题的解有{5}，{4}，{5,4}，{1,5,4}，{5,4,2}共5组。

②对于这4个数，问题的解有{5}，{7}，{2,7}，{7,3}，{5,2,7}，{5,2,7,3}共6组。

【数据规模】

对于10%的数据，1＜n≤10.

对于30%的数据，1＜n≤1000.

对于50%的数据，1＜n≤30000.

对于100%的数据，1＜n≤200000，1＜M≤3000，每个数均为正整数且不大于5000.


## 样例 #1

### 输入

```
4 3
1 5 4 2```

### 输出

```
5```

## 样例 #2

### 输入

```
4 4
5 2 7 3```

### 输出

```
6```

# AI分析结果



### 综合分析与结论  
本题核心是将原问题转化为前缀和数组的顺序对计数问题。所有题解均遵循以下步骤：  
1. **问题转化**：将每个元素减M，转化为求区间和>0的子数组数目  
2. **前缀和转换**：构造前缀和数组S，问题等价于求满足S[j] > S[i-1]的(i,j)对数  
3. **顺序对计数**：等价于求前缀和数组的逆序对（或顺序对，取决于遍历方式）  

主要解法差异在于顺序对的统计方式：  
- 归并排序法（O(n logn)）：通过分治过程统计逆序对  
- 树状数组/权值线段树（O(n logn)）：离散化后单点更新+区间查询  
- 分块法（O(n√n)）：适用于特殊场景，但效率较低  

---

### 精选题解与评分  

#### 1. cabasky（⭐⭐⭐⭐⭐）  
**关键亮点**：  
- 最简洁的归并排序实现  
- 明确指出需要包含S[0]的细节  
- 直接给出数学推导过程  
```cpp
void merge(int l,int mid,int r) {
    int p1=l,p2=mid+1,k=l-1;
    while(p1<=mid&&p2<=r) {
        if(sum[p1]<sum[p2]) { // 发现顺序对
            ans += (mid-p1+1); // 统计左侧剩余元素数
            temp[++k]=sum[p2++];
        } else {
            temp[++k]=sum[p1++];
        }
    }
    // 合并剩余元素...
}
```

#### 2. 郑翰（⭐⭐⭐⭐）  
**关键亮点**：  
- 清晰的树状数组实现  
- 包含离散化处理的完整代码  
**调试心得**：  
> "注意要追加S[0]=0，否则会少算从第一个元素开始的区间"

```cpp
// 离散化处理
sort(b+1,b+1+c[0]);
c[0]=unique(b+1,b+1+c[0])-(b+1);
// 树状数组查询
ans = (ans + Query(_find(sum[i])-1)) % MOD;
```

#### 3. waOooo（⭐⭐⭐）  
**关键亮点**：  
- 指出顺序对与逆序对的思考误区  
- 提供权值线段树实现  
```cpp
void add(int k){ // 动态维护值域
    if(tree[k].l==tree[k].r){
        tree[k].w++; return;
    }
    if(z<=mid) add(lson);
    else add(rson);
    tree[k].w=tree[lson].w+tree[rson].w;
}
```

---

### 关键技巧总结  
1. **前缀和偏移法**：通过整体偏移（减M）将平均数问题转化为区间和问题  
2. **顺序对转化**：将二维区间查询转化为一维前缀和的顺序对计数  
3. **离散化技巧**：处理负数和大范围值域时，需对前缀和进行离散化  
4. **边界处理**：必须包含S[0]（对应从第一个元素开始的区间）  

---

### 同类题目推荐  
1. [P2717 寒假作业](https://www.luogu.com.cn/problem/P2717) - 完全相同的模型  
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908) - 基础逆序对计数  
3. [CF1042D Petya and Array](https://www.luogu.com.cn/problem/CF1042D) - 求区间和小于目标的子数组数  

---

### 调试经验摘录  
1. **离散化陷阱**：  
   > "数据有非正数，必须重构值域" —— SCKer  
   解决方法：将所有前缀和离散化后，用排名代替原值  

2. **边界遗漏**：  
   > "忘记处理S[0]导致漏算首元素区间" —— 多篇题解提及  
   正确做法：初始化时包含sum[0] = 0  

3. **顺序对误解**：  
   > "这明明是顺序对，为什么要用逆序对？" —— waOooo  
   本质：归并时统计右侧元素贡献的方式不同，两种方法均可实现

---
处理用时：62.00秒
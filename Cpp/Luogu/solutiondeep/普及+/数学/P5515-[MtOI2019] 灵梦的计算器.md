# 题目信息

# [MtOI2019] 灵梦的计算器

## 题目背景

**注: 该背景部分改编自 disangan233 中考前买计算器的真实事件。**  

博丽 灵梦 (Hakurei Reimu) 在成功抢回八云 紫 (Yakumo Yukari) 用隙间偷走的香火钱后，她和依神 紫苑 (Yorigami Shion) 去香霖堂买东西啦！  

灵梦想买一个计算器来计算神社的香火钱，但是因为香霖堂的东西太贵了，她选择使用河童重工网络 (Kawashiro Nitori's Network,KNN) 网购一个 Casio 计算器。

但出人意料的是，灵梦使用 KNN 买回来的 Casio 是个假货，最多只能显示整数部分（即向下取整）。   

灵梦很苦恼，因为这个计算器可能会导致一些特别大的误差。所以灵梦想让拥有外界的式神(指电脑)的你帮她解决一个问题。

## 题目描述

灵梦得到了3个实数 $n$ ，$a$ ，$b$ ( $4\le n\le 5,5 \le a,b \le 10$ ) ，她成功地计算了 $n^a+n^b$，得到了一个只显示整数部分的结果。  

灵梦想知道，若存在一个实数 $n'(n' \geq 0)$，使得 ${n'}^a+{n'}^b$ 的结果在计算器上与 $n^a+n^b$ 的结果显示出来**完全一致**时，$n'$ 的变化范围，即 $n'$ 的最大值与最小值之差。  

如果你不知道如何计算 $n^k$，请使用`cmath`库的`pow()`函数，`pow(n,k)`的结果即为 $n^k$ 的结果。    

---

为了提高本题的难度，灵梦给你设置了 $T$ 组询问。而为了在某种程度上减少你的输入和输出量，我们采用以下的代码来生成询问(代码来自河童重工)：  

~~~cpp
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#define uint unsigned int
	uint sd;int op;
	inline void init() {scanf("%u %d", &sd, &op);}
	inline uint uint_rand()
	{
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b)
	{
		n = get_n(); a = get_k();
		if (op) b = a;
		else b = get_k(); 
	}
}
~~~

在调用 `Mker::init()` 函数之后，你第 $i$ 次调用 `Mker::read(n,a,b)` 函数后得到的便是第 $i$ 次询问的 $n_i$, $a_i$ 和 $b_i$。     

为了减少你的输出量，令第 $i$ 次询问的答案为 $s_i$，你只需要输出 $\sum^{T}_{i=1} s_i$ 。如果你的答案与标准答案的绝对误差在 $10^{-2}$ 以内，你的答案则被视为是正确答案。

本题数据的生成采用时间复杂度**远远劣于**普通算法的高 (da) 精 (bao) 度 (li) 算法来保证精度，本题数据保证**单次询问的误差**小于 $10^{-10}$，**所以本题的SPJ范围对于正解来说是完全足够的。**

---

为了让你更好地做题，这里给出了关于 $op$ 的说明：   

* 当 $op=1$ 时，有 $a=b$，否则无特殊限定。  

## 说明/提示

### 子任务

![QQ图片20190707214000.png](https://i.loli.net/2019/07/07/5d21f64bc09c827059.png)


### 题目来源

[迷途之家2019联赛](https://www.luogu.org/contest/20135)(MtOI2019) T2

出题人：disangan233

验题人：suwakow


## 样例 #1

### 输入

```
500 233 0```

### 输出

```
0.00503```

## 样例 #2

### 输入

```
10000 3141592653 0```

### 输出

```
0.10166```

## 样例 #3

### 输入

```
50000 1314159 0```

### 输出

```
0.50722```

## 样例 #4

### 输入

```
50000 1314159 1```

### 输出

```
1.51676```

## 样例 #5

### 输入

```
1000000 5201314 0```

### 输出

```
10.30487```

# AI分析结果



### 综合分析与结论
本题要求求解实数范围变化量，核心思路是利用导数的线性近似。各题解均围绕以下关键点展开：
1. **导数近似法**：利用函数在给定点的导数值（斜率）来估计当函数值变化1时的x轴变化量。
2. **数学推导**：通过 $\Delta x \approx \frac{1}{f'(n)} = \frac{1}{a n^{a-1} + b n^{b-1}}$ 直接计算结果。
3. **代码优化**：避免复杂迭代，直接单次计算导数，时间复杂度 $O(T)$。

最优解法为导数近似法，精度满足题目要求且计算高效。

---

### 精选题解与评分

#### 1. 作者：RiverFun (★★★★★)
**关键亮点**：
- 清晰图解函数增长特性，直观展示线性近似合理性
- 完整数学推导，从几何观察到微分公式转换严谨
- 代码简洁高效，直接计算导数倒数

**核心代码**：
```cpp
k = a * pow(n, a - 1) + b * pow(n, b - 1);
ans += 0.9999999 / k;  // 近似处理边界条件
```

#### 2. 作者：disangan233 (★★★★★)
**关键亮点**：
- 全面分析多种解法（枚举、二分、牛顿迭代），最终收敛到最优解
- 误差分析严谨，验证导数近似法的可行性
- 提供特判优化（当 $a=b$ 时简化计算）

**核心公式**：
$$
\Delta x \approx \frac{1}{a n^{a-1} + b n^{b-1}}
$$

#### 3. 作者：FLYC飘云 (★★★★☆)
**关键亮点**：
- 通过牛顿迭代优化过程展示解法等价性
- 代码中缓存中间变量（如 `pow(n, a-1)`）优化计算速度
- 针对 `op=1` 的特化处理提升效率

**调试心得**：
> "比赛时尝试多次迭代发现一次即够，最终简化公式与导数法一致，说明数学本质相同。"

---

### 关键思路与技巧
1. **导数近似法**：当函数在某点附近近似线性时，用导数斜率计算 $\Delta x = \frac{\Delta y}{f'(x)}$。
2. **数值优化**：避免重复计算，例如预计算 `pow(n, a-1)` 和 `pow(n, b-1)`。
3. **边界处理**：通过调整系数（如 0.9999999）补偿浮点误差，确保结果在精度范围内。

---

### 拓展与举一反三
1. **类似问题**：求解函数值微小变化对应的输入范围（如物理中的灵敏度分析）。
2. **算法套路**：导数的数值应用（最优化、方程近似解）。
3. **推荐题目**：
   - [P1025 数的划分](https://www.luogu.com.cn/problem/P1025)（数学分析）
   - [P1037 产生数](https://www.luogu.com.cn/problem/P1037)（数值变化范围）
   - [P2119 魔法阵](https://www.luogu.com.cn/problem/P2119)（函数特性分析）

---

### 个人心得摘录
- **zzy2333**：从二分法到牛顿迭代，最终发现"单次迭代即等价于导数法"，体现优化过程的本质洞察。
- **Doveqise**：通过对比暴力与优化算法，验证"代码中的数学优化往往比算法选择更关键"。
- **FLYC飘云**："比赛时优先考虑数值方法，但数学推导可大幅简化代码"，强调理论分析的重要性。

---
处理用时：65.33秒
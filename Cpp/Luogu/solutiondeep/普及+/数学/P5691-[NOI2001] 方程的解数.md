# 题目信息

# [NOI2001] 方程的解数

## 题目描述

已知一个 $n$ 元高次方程：         
$$\sum\limits_{i=1}^n k_ix_i^{p_i} = 0$$
其中：$x_1, x_2, \dots ,x_n$ 是未知数，$k_1,k_2, \dots ,k_n$ 是系数，$p_1,p_2,…p_n$ 是指数。且方程中的所有数均为整数。

假设未知数 $x_i \in [1,m] \space ( i \in [1,n])$，求这个方程的整数解的个数。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le n \le 6$，$1\le m \le 150$，且
$$\sum\limits_{i=1}^n |k_im^{p_i}| < 2^{31}$$  
答案不超过 $2^{31}-1$，$p_i \in \mathbb N^*$。

## 样例 #1

### 输入

```
3
150
1 2
-1 2
1 2```

### 输出

```
178```

# AI分析结果



### 综合分析与结论
该题核心是**折半搜索（Meet-in-the-middle）**，通过将方程拆分为前后两半，分别计算可能的值并合并答案。各题解均采用此思路，差异主要体现在数据结构和合并方式：
1. **前半结果存储**：哈希表（开放寻址/链式）、排序数组、`map`等。
2. **后半结果查询**：哈希查表、双指针统计、二分查找。
3. **优化点**：预处理幂运算、哈希冲突处理、相同值合并技巧。

### 高星题解推荐
#### 1. LawrenceSivan（★★★★★）
**亮点**：
- 双指针合并法，处理相同值的乘法原理，避免重复查询。
- 详细讲解折半搜索适用条件及同类题目（如P4799、P3067）。
- 代码清晰，注释完整，预处理幂运算优化性能。

**核心代码**：
```cpp
void dfs(int l,int r,int sum,int *arr,int &cnt) {
    if(l>r) { arr[++cnt]=sum; return; }
    for(int i=1;i<=m;i++) 
        dfs(l+1,r,sum+k[l]*qpow(i,p[l]),arr,cnt);
}

// 合并答案：排序后双指针统计相同值的组合数
sort(a+1,a+cnta+1); sort(b+1,b+cntb+1);
int l=1, r=cntb, ans=0;
for(;l<=cnta && r>=1; l++) {
    while(a[l]+b[r]>0) r--;
    int x=1, y=0;
    for(int j=r; a[l]+b[j]==0 && j>0; j--) y++;
    while(l<cnta && a[l]==a[l+1]) x++, l++;
    ans += x*y;
}
```

#### 2. nofall（★★★★☆）
**亮点**：
- 哈希表实现高效查询，代码简洁，理论时间复杂度更低。
- 手写哈希函数处理冲突，避免`map`性能瓶颈。
- 预处理幂运算减少重复计算。

**核心代码**：
```cpp
int hash(int x) { /* 开放寻址处理冲突 */ }
void dfs1(int dep, int sum) {
    if(dep>mid) { hinsert(sum); return; }
    for(int i=1; i<=m; i++) 
        dfs1(dep+1, sum+k[dep]*P[i][p[dep]]);
}
void dfs2(int dep, int sum) {
    if(dep>n) { ans += hfind(-sum); return; }
    for(int i=1; i<=m; i++) 
        dfs2(dep+1, sum -k[dep]*P[i][p[dep]]);
}
```

### 关键技巧总结
1. **折半搜索**：将指数级复杂度降为平方根级，适用n≤40的问题。
2. **合并策略选择**：
   - 双指针法需排序，但可线性统计相同值组合。
   - 哈希表查询O(1)，但需处理冲突和内存。
3. **预处理优化**：预先计算所有可能的`x^p`值，避免重复计算。

### 拓展题目推荐
1. [P4799 [CEOI2015] 世界冰球锦标赛](https://www.luogu.com.cn/problem/P4799)（折半搜索+双指针）
2. [P3067 [USACO12OPEN] Balanced Cow Subsets G](https://www.luogu.com.cn/problem/P3067)（状态压缩+折半）
3. [CF888E Maximum Subsequence](https://www.luogu.com.cn/problem/CF888E)（模数优化+折半）

### 题解个人心得摘录
- **LawrenceSivan**：强调“双指针需注意相同值的乘法原理”，调试中发现未去重导致错误。
- **Viktley**：手写哈希表时因模数过小导致冲突，最终选择`4000037`作为质数模数。
- **abruce**：尝试直接使用`map`在n=6时MLE，改用开放寻址哈希表优化内存。

---
处理用时：68.26秒
# 题目信息

# [USACO20FEB] Swapity Swapity Swap S

## 题目描述

Farmer John 的 $N$ 头奶牛（$1\leq N\leq 10^5$）站成一排。对于每一个 $1\leq i\leq N$，从左往右数第 $i$ 头奶牛的编号为 $i$。

Farmer John 想到了一个新的奶牛晨练方案。他给奶牛们 $M$ 对整数 $(L_1,R_1)\ldots (L_M,R_M)$，其中 $1\leq M\leq 100$。他让她们重复以下包含 $M$ 个步骤的过程 $K$（$1\leq K\leq 10^9$）次：

对于从 $1$ 到 $M$ 的每一个 $i$：
- 当前从左往右数在位置 $L_i\ldots R_i$ 的奶牛序列反转她们的顺序。
- 当奶牛们重复这一过程 $K$ 次后，请对每一个 $1\leq i\leq N$ 输出从左往右数第 $i$ 头奶牛的编号。

## 说明/提示

#### 样例解释：
初始时，奶牛们的顺序从左往右为 [$1,2,3,4,5,6,7$]。在这一过程的第一步过后，顺序变为 [$1,5,4,3,2,6,7$]。在这一过程的第二步过后，顺序变为 [$1,5,7,6,2,3,4$]。再重复这两个步骤各一次可以得到样例的输出。

#### 子任务：
- 测试点 $2$ 满足 $N=K=100$。
- 测试点 $3$-$5$ 满足 $K\leq 10^3$。
- 测试点 $6$-$10$ 没有额外限制。

## 样例 #1

### 输入

```
7 2 2
2 5
3 7```

### 输出

```
1
2
4
3
5
7
6```

# AI分析结果



### 综合分析与结论
本题核心在于高效处理重复操作，主要思路分为两类：  
1. **置换合成法**（快速幂/倍增）：将M次操作视为一个置换，通过快速幂或倍增合并K次操作，时间复杂度O(NM + N logK)。  
2. **循环节分解法**：找出每个位置的独立循环节，利用取模快速计算最终位置，时间复杂度O(NM + N)，更优。

### 高星题解推荐（≥4星）

#### 1. 作者：tuxiaobei（5星）  
**关键亮点**：  
- 基于循环节分解的最优解法，时间复杂度O(NM)  
- 预处理每个位置的映射关系后，独立处理每个环，利用取模快速计算最终位置  
- 代码简洁高效，适合大规模数据  

**核心代码**：  
```cpp
// 预处理每个位置一轮后的映射关系
for (int i=1; i<=n; i++) a[i] = i;
for (int i=1; i<=m; i++) {
    reverse(a + l[i], a + r[i] + 1);
}
// 找循环节并处理
for (int i=1; i<=n; i++) {
    if (visited[i]) continue;
    vector<int> cycle;
    int p = i;
    do {
        cycle.push_back(p);
        visited[p] = true;
        p = a[p];
    } while (p != i);
    int len = cycle.size();
    for (int j=0; j<len; j++) {
        res[cycle[(j+k)%len]] = cycle[j];
    }
}
```

#### 2. 作者：Diaоsi（4星）  
**关键亮点**：  
- 将置换视为矩阵，通过快速幂合并K次操作  
- 代码结构清晰，使用置换乘法实现快速幂  
- 时间复杂度O(NM + N logK)，适合中等规模K  

**核心代码**：  
```cpp
struct Permu { int m[N]; };
Permu Mul(Permu x, Permu y) { // 置换乘法
    Permu res;
    for (int i=1; i<=n; i++) res.m[i] = x.m[y.m[i]];
    return res;
}
void Qpow(int k) { // 快速幂
    while (k) {
        if (k&1) a = Mul(a, e);
        e = Mul(e, e); k >>= 1;
    }
}
```

#### 3. 作者：kradcigam（4星）  
**关键亮点**：  
- 基于倍增的预处理方法，构建2^i次操作的映射表  
- 二进制拆分K后快速跳转，思路类似LCA倍增  
- 代码易理解，适合快速实现  

**核心代码**：  
```cpp
// 预处理倍增表
for (int i=1; i<=30; i++)
    for (int j=1; j<=n; j++)
        f[i][j] = f[i-1][f[i-1][j]];
// 二进制分解执行
int x = i, rem = k;
for (int j=30; j>=0; j--) {
    if (rem >= (1<<j)) {
        rem -= (1<<j);
        x = f[j][x];
    }
}
```

### 关键思路总结
1. **置换快速幂**：将重复操作视为置换的合成，利用快速幂合并K次操作。  
2. **循环节分解**：独立处理每个位置的循环节，通过取模直接计算最终位置，时间复杂度最优。  
3. **倍增预处理**：预计算每个位置经过2^i次操作后的状态，通过二进制拆分快速合并。

### 同类型题目推荐
1. [P6148 [USACO20FEB] Swapity Swapity Swap S](https://www.luogu.com.cn/problem/P6148)（本题，练习置换与循环节）  
2. [P1709 隐藏口令](https://www.luogu.com.cn/problem/P1709)（循环节与字符串变换）  
3. [P3582 [POI2015] KIN](https://www.luogu.com.cn/problem/P3582)（置换快速幂的变式应用）  

### 个人心得摘录
- **Diaоsi**："置换符合结合律"——明确数学性质是解题关键。  
- **泥土笨笨**："考试时没想到倍增，后来发现其与矩阵快速幂的相似性"——经验迁移的重要性。  
- **tuxiaobei**："每个位置的循环独立，无需考虑整体循环节"——独立分析局部性质可简化问题。

---
处理用时：94.59秒
# 题目信息

# 出生点

## 题目背景

小 L、小 W 和小 H 在一起van♂游戏。

~~由于小 L 太菜了所以导致他一直在看着小 W 和小 H 打游戏。~~

## 题目描述

这款游戏的地图可以抽象成一张有 $n$ 行 $m$ 列的网格图，网格图上有 $k$ 个障碍点，相邻两点间边长为 $1$。游戏开始时~~小 L~~、小 W 和小 H 会**各自**随机出生在一个点。当然，他们**不会出生在障碍点**。

~~经常开局死的~~小 L 看着小 W 和小 H 每次在地图上汇合时经过的路径，很想知道他们每次出生后两个人之间的期望距离。（这里的距离指两点间[曼哈顿距离](https://www.luogu.com.cn/blog/xuxing/Distance-Algorithm)，即 $\left|x_1-x_2\right|+\left|y_1-y_2\right|$）

由于小 L 可以非常容易算出有多少种出生点安排方案，所以你实际上**只需要告诉他所有情况中他们两人距离之和**。

**注意**：小 W 出生在点 $A$，小 H 出生在点 $B$，跟小 W 出生在点 $B$，小 H 出生在点 $A$，这两种情况**视作同一种情况**。

## 说明/提示

对于样例一，地图样式如下（其中蓝点为障碍点，红点为可能的出生点）：  
![](https://cdn.luogu.com.cn/upload/image_hosting/3bq78rx7.png)

+ 出生点为 $(1,1)$ 和 $(1,1)$，距离为 $0$。
+ 出生点为 $(1,1)$ 和 $(1,2)$，距离为 $1$。
+ 出生点为 $(1,1)$ 和 $(1,3)$，距离为 $2$。
+ 出生点为 $(1,1)$ 和 $(2,2)$，距离为 $2$。
+ 出生点为 $(1,1)$ 和 $(2,3)$，距离为 $3$。
+ 出生点为 $(1,1)$ 和 $(3,1)$，距离为 $2$。
+ 出生点为 $(1,1)$ 和 $(3,2)$，距离为 $3$。
+ 出生点为 $(1,2)$ 和 $(1,2)$，距离为 $0$。
+ 出生点为 $(1,2)$ 和 $(1,3)$，距离为 $1$。
+ 出生点为 $(1,2)$ 和 $(2,2)$，距离为 $1$。
+ 出生点为 $(1,2)$ 和 $(2,3)$，距离为 $2$。
+ 出生点为 $(1,2)$ 和 $(3,1)$，距离为 $3$。
+ 出生点为 $(1,2)$ 和 $(3,2)$，距离为 $2$。
+ 出生点为 $(1,3)$ 和 $(1,3)$，距离为 $0$。
+ 出生点为 $(1,3)$ 和 $(2,2)$，距离为 $2$。
+ 出生点为 $(1,3)$ 和 $(2,3)$，距离为 $1$。
+ 出生点为 $(1,3)$ 和 $(3,1)$，距离为 $4$。
+ 出生点为 $(1,3)$ 和 $(3,2)$，距离为 $3$。
+ 出生点为 $(2,2)$ 和 $(2,2)$，距离为 $0$。
+ 出生点为 $(2,2)$ 和 $(2,3)$，距离为 $1$。
+ 出生点为 $(2,2)$ 和 $(3,1)$，距离为 $2$。
+ 出生点为 $(2,2)$ 和 $(3,2)$，距离为 $1$。
+ 出生点为 $(2,3)$ 和 $(2,3)$，距离为 $0$。
+ 出生点为 $(2,3)$ 和 $(3,1)$，距离为 $3$。
+ 出生点为 $(2,3)$ 和 $(3,2)$，距离为 $2$。
+ 出生点为 $(3,1)$ 和 $(3,1)$，距离为 $0$。
+ 出生点为 $(3,1)$ 和 $(3,2)$，距离为 $1$。
+ 出生点为 $(3,2)$ 和 $(3,2)$，距离为 $0$。

总和为 $42$。

### 数据范围

**本题采用捆绑测试。**

+ Subtask 1( $10\%$ )：$n,m\leq 80$。
+ Subtask 2( $20\%$ )：$n,m\leq 5000$。
+ Subtask 3( $15\%$ )：$k=0$。
+ Subtask 4( $15\%$ )：$m=1$。
+ Subtask 5( $40\%$ )：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,m\leq 10^9,1\leq x_i\leq n,1\leq y_i\leq m,0\leq k\leq 5\times 10^5,k<n\times m$，**保证所有障碍点各不相同**。

## 样例 #1

### 输入

```
3 3 2
2 1
3 3
```

### 输出

```
42```

## 样例 #2

### 输入

```
9 8 8
3 2
4 6
7 3
9 5
3 7
2 2
1 6
6 4
```

### 输出

```
11552```

# AI分析结果



### 综合分析与结论
各题解均采用容斥原理，将问题分解为三部分计算：全量点距离总和、减去障碍点影响、加上障碍点间距离。关键优化点在于将曼哈顿距离拆分为行列独立计算，利用数学公式（等差数列、平方和）将时间复杂度降为 $O(1)$，障碍点间距离采用排序+递推优化。核心难点在于大数运算溢出处理和模运算中的除法逆元转换。

---

### 精选题解推荐

#### 题解1：lndjy（5星）
**关键亮点**：  
- 使用 `__int128` 彻底解决大数溢出问题  
- 代码模块化清晰，分三部分对应核心公式  
- 注释明确，变量命名规范  
**个人心得**：  
> "我之前就是忘记除以2了" → 强调数学公式实现时细节的重要性  

**核心代码思路**：
```cpp
// 第一部分：计算全量点距离总和
ans += ((m*m*n)%p)*sum(n-1) - ((m*m)%p)*sqr(n-1) + ... ;
// 第二部分：减去障碍点影响
for(int i=1;i<=k;i++) ans -= m*sum(x_i-1) + ... ;
// 第三部分：障碍点间距离
sort后递推计算 f[i] = f[i-1] + (i-1)*(x[i]-x[i-1])
```

#### 题解2：lzy20091001（5星）
**关键亮点**：  
- 数学推导最严谨，给出完整公式变形过程  
- 代码封装求和函数，提升可读性  
- 处理模运算负数时的边界条件  

**核心代码片段**：
```cpp
int sum1(int n) { // 等差数列求和
    return 1ll * n * (n + 1) / 2 % MOD;
}
int sum2(int n) { // 平方和求和（含模3特判）
    if (n%3 == 1) return ... ;
    return ... ;
}
// 障碍点距离递推
for(int i=2; i<=k; i++) {
    f += (i-1)*(x[i]-x[i-1]);
    ans += f;
}
```

---

### 关键思路与技巧总结
1. **曼哈顿距离拆分**：将行列贡献独立计算，利用对称性降低复杂度。  
2. **数学公式优化**：  
   - 等差数列和 $\sum i = \frac{n(n+1)}{2}$  
   - 平方和 $\sum i^2 = \frac{n(n+1)(2n+1)}{6}$  
3. **排序递推法**：对障碍点坐标排序后，通过 $f[i] = f[i-1] + (i-1)\Delta x$ 递推求绝对值和。  
4. **大数处理**：使用 `__int128` 或及时取模避免溢出。  
5. **模运算除法**：通过费马小定理 $a/b \equiv a \cdot b^{mod-2} \pmod{mod}$ 转换。  

---

### 拓展与相似题目
1. **P3964 [TJOI2013]松鼠聚会**  
   （曼哈顿距离与切比雪夫距离转换）  
2. **P1450 [HAOI2008]硬币购物**  
   （容斥原理经典题）  
3. **P3188 [HNOI2007]梦幻岛宝珠**  
   （大范围数据下的动态规划优化）  

---

### 调试经验摘录
- **ynxynx**：实现时忘记等差数列的除以2导致错误 → **启示**：公式转代码时需逐项核对运算符。  
- **littleKtian**：强调排序后递推的数学证明 → **启示**：复杂递推需先进行数学验证。

---
处理用时：71.04秒
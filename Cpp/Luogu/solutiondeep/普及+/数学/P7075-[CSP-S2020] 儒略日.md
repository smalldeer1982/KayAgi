# 题目信息

# [CSP-S2020] 儒略日

## 题目描述

为了简便计算，天文学家们使用儒略日（Julian day）来表达时间。所谓儒略日，其定义为从**公元前 4713 年 1 月 1 日正午 12 点到此后某一时刻间所经过的天数**，不满一天者用小数表达。若利用这一天文学历法，则每一个时刻都将被均匀的映射到数轴上，从而得以很方便的计算它们的差值。

现在，给定一个不含小数部分的儒略日，请你帮忙计算出该儒略日（一定是某一天的中午 12 点）所对应的公历日期。

我们现行的公历为格里高利历（Gregorian calendar），它是在公元 1582 年由教皇格里高利十三世在原有的儒略历（Julian calendar）的基础上修改得到的（注：儒略历与儒略日并无直接关系）。具体而言，现行的公历日期按照以下规则计算：

1. 公元 1582 年 10 月 15 日（含）以后：适用格里高利历，每年一月 $31$ 天、 二月 $28$ 天或 $29$ 天、三月 $31$ 天、四月 $30$ 天、五月 $31$ 天、六月 $30$ 天、七月 $31$ 天、八月 $31$ 天、九月 $30$ 天、十月 $31$ 天、十一月 $30$ 天、十二月 $31$ 天。其中，闰年的二月为 $29$ 天，平年为 $28$ 天。当年份是 $400$ 的倍数，或日期年份是 $4$ 的倍数但不是 $100$ 的倍数时，该年为闰年。
2. 公元 1582 年 10 月 5 日（含）至 10 月 14 日（含）：不存在，这些日期被删除，该年 10 月 4 日之后为 10 月 15 日。
3. 公元 1582 年 10 月 4 日（含）以前：适用儒略历，每月天数与格里高利历相同，但只要年份是 $4$ 的倍数就是闰年。
4. 尽管儒略历于公元前 45 年才开始实行，且初期经过若干次调整，但今天人类习惯于按照儒略历最终的规则反推一切 1582 年 10 月 4 日之前的时间。注意，**公元零年并不存在**，即公元前 1 年的下一年是公元 1 年。因此公元前 1 年、前 5 年、前 9 年、前 13 年……以此类推的年份应视为闰年。

## 说明/提示

**【数据范围】**

| 测试点编号 | $Q =$ | $r_i \le$ |
|:-:|:-:|:-:|
| $1$ | $1000$ | $365$ |
| $2$ | $1000$ | $10^4$ |
| $3$ | $1000$ | $10^5$ |
| $4$ | $10000$ | $3\times 10^5$ |
| $5$ | $10000$ | $2.5\times 10^6$ |
| $6$ | $10^5$ | $2.5\times 10^6$ |
| $7$ | $10^5$ | $5\times 10^6$ |
| $8$ | $10^5$ | $10^7$ |
| $9$ | $10^5$ | $10^9$ |
| $10$ | $10^5$ | 年份答案不超过 $10^9$ |

## 样例 #1

### 输入

```
3
10
100
1000```

### 输出

```
11 1 4713 BC
10 4 4713 BC
27 9 4711 BC```

## 样例 #2

### 输入

```
3
2000000
3000000
4000000```

### 输出

```
14 9 763
15 8 3501
12 7 6239```

## 样例 #3

### 输入

```
见附件中的 julian/julian3.in```

### 输出

```
见附件中的 julian/julian3.ans```

# AI分析结果



### 综合分析与结论

本题解的核心难点在于处理不同历法的转换规则、闰年判断规则变化以及1582年10月的日期缺失。通过分析题解，最优解法普遍采用以下思路：

1. **预处理周期性数据**：利用格里高利历400年周期的天数规律（146097天），将大范围年份计算转换为模400的快速计算。
2. **分阶段处理历法转换**：将时间轴分为儒略历时期、1582年特殊时期和格里高利历时期，针对性处理。
3. **避免逐日计算**：通过年份二分、周期跳跃等方式减少计算量，时间复杂度优化至O(1)或O(Q)。

### 优质题解推荐

#### 1. 作者「已注销」（⭐️⭐️⭐️⭐️⭐️）
**关键亮点**：
- 预处理格里高利历400年所有日期，直接通过取模快速定位
- 巧妙处理公元前年份表示（用负数+BC后缀）
- 代码简洁高效，时间复杂度O(1) per query

**核心代码**：
```cpp
// 预处理400年日期
const int N=146097;
int y[N],m[N],d[N];
for(int i=1;i<N;++i){
    d[i]=d[i-1]+1; m[i]=m[i-1]; y[i]=y[i-1];
    if(d[i]>md(y[i],m[i])) ++m[i],d[i]=1;
    if(m[i]>12) ++y[i],m[i]=1;
}

// 主查询逻辑
if(n>2299160){ // 格里高利历
    n-=2159351;
    t=n/N*400+1200;
    n%=N;
} else {        // 儒略历
    t=n/1461*4-4712;
    n%=1461;
}
```

#### 2. 囧仙（⭐️⭐️⭐️⭐️）
**关键亮点**：
- 分阶段暴力预处理+周期跳跃
- 对1600年前日期全预处理，之后利用400年周期
- 使用二分法快速定位年份

**核心代码**：
```cpp
// 预处理到1600年
for(int i=1;i<=2305447;i++){ // 暴力计算到1600年
    // 日期递增逻辑...
}

// 处理大范围查询
dn(30,0,i){ // 二分年份
    if(clc(y|(1<<i),m,d)-clc(1600,1,1)<=t) y|=1<<i;
}
```

#### 3. OMG_wc（⭐️⭐️⭐️⭐️）
**关键亮点**：
- 二分年份后模拟剩余天数
- 单独处理1582年10月特殊日期
- 代码结构清晰，易于调试

**核心代码**：
```cpp
// 二分年份
int l=-4712, r=1e9+5;
while(l<r){
    int mid=l+r>>1;
    if(cal(mid)>=n) r=mid;
    else l=mid+1;
}

// 处理1582年10月
if(l==1582 && m==10 && d>=5) d+=10;
```

### 关键优化技巧总结
1. **周期预处理**：格里高利历400年周期固定为146097天，预处理后可直接模运算定位。
2. **历法分段处理**：将时间轴分为儒略历、过渡期和格里高利历，分别采用不同计算规则。
3. **数学代替模拟**：通过年份二分、除法取余等数学方法避免逐日计算。

### 相似题目推荐
1. [P1202 USACO1.1] 黑色星期五 - 日期循环计算
2. [P1516 青蛙的约会] - 模运算与周期性
3. [P1024 科学计数法] - 大数分段处理

### 调试心得摘录
> "被官方数据hack了一个点，发现是在处理公元前的闰年时忘记将年份-1取模。公元前1年视为闰年需要特殊处理。" —— 作者Macesuted  
> "关闭O2后TLE一个点，最终通过将100年周期拆分为更小循环解决。优化常数是关键。" —— 作者Zskioaert1106  
> "用计算器验证时发现400年周期计算错误，将146097误写成164097导致WA，调试2小时后发现。" —— 作者qiuby123456

---
处理用时：84.21秒
# 题目信息

# 移花接木

## 题目背景


遥远的圣地生长着一棵不为人知的灵树，或有万山之高。

但有一日，藏匿于根系的腐朽力量爆发，灵树已无法支撑往日屹立冲天的高度。

## 题目描述

灵树最初的形态可以看作一棵高度为 ${10}^{{10}^{{10}^{10}}}$ 的满 $a$ 叉树，高度定义为根结点到叶子结点之间的边数。

受腐朽力量影响，灵树只能维持高度**恰好**为 $h$ 的满 $b$ 叉树形态。为了转换至该形态，灵树有两种魔法：

- 移花：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点），移除这条边以及以 $v$ 为根的**整棵子树**。
- 接木：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点）和一个结点 $w$（$w$ 不能是 $v$ 子树中或已移除的结点），将这条边原先 $u$ 一端**改接**到 $w$。**该魔法只能在根结点到** $\boldsymbol{u}$ **之间的边数** $\le 10^{10^{10}}$ **时使用。**

灵树累积的魔法力量有限，它不得不用最少次数的魔法完成转换。这是个漫长的过程，即使次数最少也会显得异常大，你只需要求出最少次数对 $10^9 + 7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**

下为 $a=1$，$b=2$，$h=1$ 时的两步转换过程，图中高度极大的冗余子树已用省略号代替。

![](https://cdn.luogu.com.cn/upload/image_hosting/p32s9v96.png)

可以证明，该数据的答案不可能低于 $2$。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (3 points)：$h = 0$。
- Subtask #2 (4 points)：$a = b$。
- Subtask #3 (8 points)：$a = 1$。
- Subtask #4 (8 points)：$b = 1$。
- Subtask #5 (17 points)：$h \le 10$。
- Subtask #6 (15 points)：$h \le 10^6$，各测试点存在 $\overline{a},\overline{b}$，其数据满足 $a=\overline{a}$，$b=\overline{b}$。
- Subtask #7 (15 points)：$h \le 10^6$。
- Subtask #8 (30 points)：无特殊限制。

所有测试点（样例除外）均含有 $10^6$ 组数据，即 $T = 10^6$。请务必采用较快的 IO（输入/输出）方式。

对于所有的数据，保证 $1 \le a,b \le 10^9$，$0 \le h \le 10^9$。

## 样例 #1

### 输入

```
2
1 2 1
3 2 1
```

### 输出

```
2
7
```

# AI分析结果



### 综合分析与结论
本题核心是数学推导与分情况处理，关键在于对满叉树结构的层间节点数分析。所有题解均基于以下核心思路：
1. **分类讨论**：按a与b的大小关系分为a>b、a<b、a=b三种情况
2. **等比数列求和**：处理层间操作次数的累加
3. **快速幂优化**：计算b^h等大指数幂值
4. **特判处理**：针对b=1等边界情况

### 优质题解推荐

#### 1. 作者：AsunderSquall ⭐⭐⭐⭐⭐
**关键亮点**：
- 完整覆盖所有子任务推导过程
- 附带手绘示意图辅助理解
- 代码简洁高效（仅需25行）
- 包含调试经验（提及卡常问题）

**核心代码**：
```cpp
if(b==1) cout<<(((a-1)*h+a)%mod);
else if(a<=b) cout<<ksm(b,h,mod)*a%mod;
else {
    int S = (ksm(b,h,mod)-1)*INV(b-1)%mod;
    cout<<(a*ksm(b,h,mod)+(a-b)*S)%mod;
}
```
**实现思想**：通过快速幂计算b^h，利用逆元处理等比数列求和，分类输出结果

#### 2. 作者：AuCloud ⭐⭐⭐⭐
**关键亮点**：
- 详细推导每一步操作数计算
- 提供字符画帮助理解树形变换
- 独立处理所有边界情况

**个人心得**：
> "当b=1时，每层删除(a-1)个枝条，这个推导过程让我卡了很久，最后通过画图验证才确定公式"

#### 3. 作者：gzlmr ⭐⭐⭐⭐
**关键亮点**：
- 给出23分部分解法的独立推导
- 使用数学归纳法解释操作次数
- 附带动图演示树结构变化

### 关键思路与技巧
1. **等比数列优化**：将层间操作数之和转化为 (b^h-1)/(b-1)
2. **接木-移花平衡**：当a<b时，利用要删除的子树进行接木，将总操作数优化为a*b^h
3. **逆元处理**：使用费马小定理求模下逆元，避免浮点运算
4. **统一公式**：最终表达式可合并为：
   ```ans = a*b^h + (a>b)*(a-b)*(b^h-1)/(b-1)```

### 拓展练习
1. **P1226** 【模板】快速幂 - 练习快速幂实现
2. **P1306** 斐波那契公约数 - 结合快速幂与数论性质
3. **P1044** 栈 - 卡特兰数中的分情况递推思想

### 调试经验摘录
- **AsunderSquall**："推出式子时被卡常，发现是快速幂实现不够优化"
- **AuCloud**："在b=1的特判推导中，通过绘制多层级树结构验证公式正确性"
- **Create_Random**："最初忽略b=1的情况导致WA，添加特判后通过"

建议在类似数学题中，优先用小数据验证特判情况，再通过数学归纳法推导通式。

---
处理用时：59.30秒
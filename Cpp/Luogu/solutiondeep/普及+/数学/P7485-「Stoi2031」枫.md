# 题目信息

# 「Stoi2031」枫

## 题目背景

> 缓缓飘落的枫叶像思念 为何挽回要赶在冬天来之前 爱你穿越时间 两行来自秋末的眼泪 让爱渗透了地面 我要的只是你在我身边 ——《枫》

## 题目描述

冬很喜欢枫叶。她家门前有一棵枫树，树上落下了 $n$ 片叶子。冬将它们编号为 $1$ 到 $n$。她希望这些枫叶不要这样被人踩碎后烂在地里，所以决定把它们捡起来。她称将剩余未捡起来的枫叶按编号从小到大或从大到小的顺序排序后，先捡起第一片枫叶，然后每隔 $k$ 片捡起一片称为一次 **挽回**。她会一直进行 **挽回**，第一次 **挽回** 从小到大，之后每次 **挽回** 的顺序都和上次不同（即上次从小到大这次就从大到小，反之亦然），直到最后一片枫叶也被捡起。她认为最后一片捡起的枫叶代表了 **思念**，能带来幸福。她希望获得更多的幸福，所以她会很多次地问你 $n$ 和 $k$ 取某两个值时她得到的 **思念** 的编号。

## 说明/提示

#### 简述版题意：

给定 $n,k$，对 $1,2,\dots,n$ 一直操作，每次操作交替从小到大或从大到小的顺序取走当前的第 $(k+1)x+1$ 个数（$x \in \mathbb{Z_{\ge 0}}$ 且 $(k+1)x+1$ 不超过剩余数总数），求最后一个取走的数的编号。多次询问。

#### 样例解释：

限于篇幅，只对样例 $2$ 作解释。

对于第 $2$ 行：

对于第一次询问，地上只有 $1$ 片枫叶，此即 **思念**。

对于第二次询问，冬第一次 **挽回** 时依次捡起了 $1,3$ 两片枫叶，转身后只剩下 $2$，即 **思念**。

对于第 $3$ 行：

对于第一次询问，冬第一次 **挽回** 时捡起了 $1$ 号枫叶，转身后剩下 $2$，即 **思念**。

对于第二次询问，冬第一次 **挽回** 时捡起了 $1,4$ 两片枫叶，第二次 **挽回** 捡起了 $3$，剩下 $2$，即 **思念**。

对于第三次询问，冬第一次捡起了 $1,4,7$，第二次捡起了 $6,2$，第三次捡起了 $3$，此时剩下 $5$，即 **思念**。

#### 数据范围：

**本题每个数据点（除第 $1$ 个外）输入数据除数据组数 $t$ 以及最后一行（第 $t+1$ 行）外与前一个数据点输入数据完全相同。各个数据点的数据范围及特殊限制如下。**

| Testdata No. | $q \le$ | $m \le$ | 特殊限制 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $2$ | $3$ | 为样例 $1$ | $3$ |
| $2$ | $3$ | $7$ | 为样例 $2$ | $7$ |
| $3$ | $7$ | $10$ | 为样例 $3$ | $3$ |
| $4$ | $10$ | $30$ | 无 | $3$ |
| $5$ | $30$ | $70$ | 无 | $7$ |
| $6$ | $70$ | $100$ | 无 | $7$ |
| $7$ | $100$ | $300$ | 无 | $7$ |
| $8$ | $300$ | $700$ | 无 | $10$ |
| $9$ | $700$ | $10^3$ | 无 | $3$ |
| $10$ | $10^3$ | $3 \times 10^3$ | 无 | $3$ |
| $11$ | $3 \times 10^3$ | $7 \times 10^3$ | 无 | $1$ |
| $12$ | $7 \times 10^3$ | $10^4$ | 无 | $13$ |
| $13$ | $10^4$ | $3 \times 10^4$ | 无 | $3$ |
| $14$ | $3 \times 10^4$ | $7 \times 10^4$ | 无 | $3$ |
| $15$ | $7 \times 10^4$ | $10^5$ | 无 | $10$ |
| $16$ | $10^5$ | $3 \times 10^5$ | 无 | $13$ |
| $17$ | $3 \times 10^5$ | $7 \times 10^5$ | 无 | $1$ |
| $18$ | $7 \times 10^5$ | $10^6$ | 无 | $3$ |

**本题读入量较大，可以选择使用比赛描述中的快速读入模板以加快读入速度。**

## 样例 #1

### 输入

```
1
2 3 1 3
```

### 输出

```
1 2
```

## 样例 #2

### 输入

```
2
2 3 1 3
3 7 2 4 7
```

### 输出

```
1 2
2 2 5
```

## 样例 #3

### 输入

```
3
2 3 1 3
3 7 2 4 7
7 10 1 2 3 6 7 8 10
```

### 输出

```
1 2
2 2 5
1 2 2 3 4 6 6
```

# AI分析结果



### 综合分析与结论
本题核心是建立递推关系，将当前问题转化为子问题，并正确处理方向反转带来的位置转换。所有题解均采用逆向递推法，通过计算每次操作后的剩余元素数目，反推原问题的答案。关键点在于正确推导位置转换公式，并处理方向反转后的相对位置关系。

---

### 精选题解与评分

#### 1. 作者：fengwu（★★★★★）
**关键亮点**  
- 思路清晰，代码简洁高效（仅20行）  
- 直接通过剩余元素数目建立递推关系，用 `last = i - (i-1)/(k+1)-1` 计算子问题规模  
- 巧妙处理方向反转：`pos = last - ans[last] + 1` 将子问题答案映射到原问题  
**核心代码**  
```cpp
int las = i - (i-1)/(k+1) - 1;
int pos = las - ans[las] + 1;
ans[i] = pos + (pos-1)/k + 1;
```

#### 2. 作者：Lagerent（★★★★☆）
**关键亮点**  
- 详细推导位置转换公式，结合图示解释更直观  
- 时间复杂度明确分析（$O(T×(m+q))$），适用于大数据  
**个人心得**  
"被这题折磨一上午" → 强调正确推导位置转换公式的重要性，需仔细验证边界情况。

#### 3. 作者：User_Authorized（★★★★☆）
**关键亮点**  
- 提供数学公式推导：$f_n = b + \lceil \frac{b}{k} \rceil$  
- 使用预处理数组快速响应查询，代码结构清晰  

---

### 最优思路总结
1. **递推转换**：每次操作后剩余元素形成子问题，方向反转，通过 `last = n - ⌈n/(k+1)⌉` 计算子问题规模。  
2. **位置映射**：子问题答案反向映射到原问题位置 `pos = last - ans[last] + 1`。  
3. **补偿删除数**：在原序列中，`ans[i] = pos + ⌈(pos-1)/k⌉` 补偿被删除元素的数量。  

---

### 相似题目推荐
1. **约瑟夫问题**（P1996）  
   - 经典递推解法，理解环形删除的基本思路。  
2. **约瑟夫环·加强版**（P8670）  
   - 数据规模更大，需优化递推公式。  
3. **火柴棒等式**（P1145）  
   - 递推与数学建模结合，训练逆向思维。  

---

### 调试与踩坑经验
- **边界验证**：当 `k=1` 或 `n=1` 时需单独处理（如题解中 `ans[1] = 1` 的初始条件）。  
- **方向反转**：多次操作后方向交替变化，需在递推时持续跟踪当前方向。  
- **公式推导**：需严格验证 `pos` 与 `ans[i]` 的关系，避免±1误差。

---
处理用时：54.37秒
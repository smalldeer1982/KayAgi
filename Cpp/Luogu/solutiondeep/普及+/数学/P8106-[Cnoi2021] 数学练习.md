# 题目信息

# [Cnoi2021] 数学练习

## 题目背景

「Cnoi2021」Cirno's Easy Round II 热身赛开始了。

## 题目描述

为了让选手们重视文化课，Cirno 特意加入了一道 Kamishirasawa Keine 老师的数学练习：

> 求将一个集合 $\texttt{U}=\{1,2,3,\cdots,n\}$ 划分成两个子集 $S,T$，使得 $|S|\notin S,|T|\notin T$ 的方案数。

由于选手都不会高精度，所以答案只需要对 $998244353$ 取模即可。

## 说明/提示

**样例解释** 

#1: 两种合法的划分方案为 $\{1,3\},\{2\}$ 与 $\{2\},\{1,3\}$ 。

**数据范围**

对于 $100\%$ 的数据，保证 $1 \le n \le 10^5$。


## 样例 #1

### 输入

```
3```

### 输出

```
2```

## 样例 #2

### 输入

```
6```

### 输出

```
10```

## 样例 #3

### 输入

```
65535```

### 输出

```
459810767```

# AI分析结果



### 综合分析与结论
本题核心是组合计数与容斥原理的结合应用。关键思路为：
1. 确定两个集合大小的位置约束（|S|∈T且|T|∈S）
2. 剩余n-2个元素自由分配，方案数为2^(n-2)
3. 当n为偶数时需排除s1 = t1的非法情况，扣除组合数C(n-2, (n-2)/2)

最优解法采用预处理阶乘与逆元快速计算组合数，时间复杂度O(n)预处理+O(1)查询。

---

### 精选题解（评分≥4星）

#### 题解1：3a51_（★★★★☆）
**关键亮点**：
- 预处理阶乘数组，利用费马小定理计算逆元
- 代码结构清晰，包含特判n=1的边界情况
- 处理负数模数时通过加mod保证结果非负

**核心代码**：
```cpp
int C(int a,int b) {
    return jc[a]%Mod * qpow(jc[b],Mod-2,Mod)%Mod * qpow(jc[a-b],Mod-2,Mod)%Mod;
}
signed main() {
    int ans = qpow(2, n-2);
    if(n%2==0) ans = (ans - C(n-2, (n-2)/2) + Mod) % Mod;
}
```

#### 题解2：TernaryTree（★★★★☆）
**关键亮点**：
- 预处理阶乘与逆元数组，组合数计算高效
- 数学推导完整，明确指出二项式定理的转化
- 代码中逆元数组的递推计算方式优化空间

**核心代码**：
```cpp
int C(int n, int m) {
    return fac[n] * inv[m] % mod * inv[n - m] % mod;
}
int main() {
    if(n%2 == 0) 
        cout << (power(2,n-2,mod) - C(n-2, (n-2)/2) + mod) % mod;
}
```

---

### 关键技巧总结
1. **组合数预处理**：阶乘与逆元数组预处理可将组合数计算降至O(1)
2. **容斥思想**：总方案减去非法情况是处理约束条件的常用方法
3. **模数处理技巧**：负数取模时需加模数再取余，避免结果错误
4. **特判优化**：对n=1等边界情况的处理能避免运行错误

---

### 推荐练习题
1. [P3811 乘法逆元](https://www.luogu.com.cn/problem/P3811)（逆元计算基础）
2. [P4071 [SDOI2016]排列计数](https://www.luogu.com.cn/problem/P4071)（错位排列与组合数）
3. [P1350 车的放置](https://www.luogu.com.cn/problem/P1350)（组合数分情况讨论）

---

### 题解心得摘录
- **特判教训**：多题解提到n=1时直接输出0，若漏判会导致WA
- **调试技巧**：样例2验证了偶数情况的容斥必要性
- **思维突破**：将自由分配转化为2的幂次是简化计算的关键步骤

> "当自信满满地放上去快速幂却WA时，意识到必须处理n偶数的特殊情况" —— 题解中的典型调试经验

---
处理用时：73.09秒
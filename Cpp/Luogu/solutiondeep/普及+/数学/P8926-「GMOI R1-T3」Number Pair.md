# 题目信息

# 「GMOI R1-T3」Number Pair

## 题目描述

我们定义满足如下条件的数对 $(x,y)$ 叫做奇妙数对：

$k \times \gcd(x,y)=\operatorname{lcm}(x,y)$ 并且 $P \le \gcd(x,y) \le Q$（保证 $P \le Q$）。

有 $T$ 组数据，对于每一组数据，给定 $k,P,Q$ 三个数，求符合条件的数对 $(x,y)$ 的对数。

**答案对 $10^9+7$ 取模。**

## 说明/提示

**注意并不寻常的时间限制。**

对于 $100\%$ 的数据 $1 \le k \le 10^{16}$，$1 \le T \le 50$，$1 \le P \le Q \le 2\times 10^9$。

| 测试点 | $k$ | $T$ | $P$ | $Q$ | 总分 |
| :----------: | :----------: | :----------: | :-------------: | :----------: | :----------: |
| $1\sim 3$ | $k \le 3$ | $T=1$ | $P=1$ | $Q=1$ | $15$ |
| $4\sim 8$ | $k \le 100$ | $T \le 8$ | $P \le 30$ |  $Q \le 30$ |$15$ |
| $9\sim 13$ | $k \le 10^3$ | $T \le 50$ | $P \le 500$ | $Q \le 500$ | $25$ |
| $14\sim 18$ | $k \le 10^{12}$ | $T \le 50$ | $P \le 10^4$ | $Q \le 10^4$ | $15$ |
| $19\sim 22$ | $k \le 10^{13}$ | $T \le 50$ | $P \le 10^6$ | $Q \le 10^6$ | $12$ |
| $23\sim 28$ | $k \le 10^{16}$ | $T \le 50$ | $P \le 2\times10^9$ | $Q \le 2\times10^9$ | $18$ |

**本题保证 $k$ 随机生成，并不存在极限卡人数据，时限已经开到 std 两倍，请各位选手放心。**

## 样例 #1

### 输入

```
5
10 1 3
30 1 5
997 24 35
34 39 99
210 1000 1001```

### 输出

```
12
40
24
244
32```

# AI分析结果



### 综合分析与结论
题目核心是将条件转化为质因数分解问题：计算k的不同质因子数n，答案即2ⁿ×(Q-P+1)。各题解均基于此思路，差异在于质因数分解的优化方式。主流做法是预处理1e8内的质数，试除分解k；部分题解结合Miller-Rabin处理大质数。

---

### 精选题解及评分

#### 1. 作者：Tx_Lcy（4.5星）
**关键亮点**  
- 预处理1e8内的质数，极大加速分解过程  
- 代码简洁，包含提前终止条件（质数平方>k时break）优化时间  
- 快速幂计算答案，处理取模细节  

**代码片段**  
```cpp
// 预处理质数部分
void work(int n){ //线性筛
    for(int i=2;i<=n;++i){
        if(!vis[i]) prime[++cnt]=i;
        for(int j=1;j<=cnt && i*prime[j]<=n;++j){
            vis[i*prime[j]]=1;
            if(i%prime[j]==0) break;
        } 
    }
}

// 分解质因数部分
for(int i=1;i<=cnt && prime[i]*prime[i]<=k;++i){
    if(k%prime[i]==0) ++ans; //统计不同质因子
    while(k%prime[i]==0) k/=prime[i];
}
if(k!=1) ++ans; //处理剩余的大质数
```

#### 2. 作者：Daidly（4星）
**关键亮点**  
- 使用bitset优化空间，处理1e8质数存储  
- 分解循环中加入质数平方判断优化  
- 预处理2的幂次避免重复计算  

**代码片段**  
```cpp
// 预处理2的幂次
p2[0]=1;
for(int i=1;i<=20;++i)p2[i]=(p2[i-1]<<1);

// 分解逻辑
for(int i=1;i<=num && p[i]*p[i]<=k;++i){
    if(k%p[i]==0) cnt++;
    while(k%p[i]==0)k/=p[i];
}
if(k>1) cnt++;
cout<<p2[cnt]*(Q-P+1)%mod<<'\n';
```

#### 3. 作者：tobie（4星）
**关键亮点**  
- 筛至3次根号k的质数，结合Miller-Rabin处理剩余情况  
- 数学推导完整，处理平方数和两个不同质数的情况  
- 适合超大质数分解，扩展性强  

**核心逻辑**  
```cpp
// 处理剩余k的情况
if(k>1){
    if(ispr(k)) cnt++; //Miller-Rabin判质数
    else if(issq(k)) cnt++; //判平方数
    else cnt+=2; //两个不同质数
}
```

---

### 最优思路与技巧总结
1. **质数预处理**：筛出1e8或3次根号k范围内的质数，加速试除分解。  
2. **提前终止条件**：当质数平方>k时终止循环，减少无效计算。  
3. **剩余处理**：分解后若k>1，需判是否为质数、平方数或两质数之积。  
4. **快速幂取模**：答案需计算2ⁿ，用快速幂避免溢出。  

---

### 推荐相似题目
1. [P3653 小清新数学题](https://www.luogu.com.cn/problem/P3653) - 质因数分解与数学推导  
2. [P4718 Pollard-Rho算法](https://www.luogu.com.cn/problem/P4718) - 高效大数分解  
3. [P4446 根式化简](https://www.luogu.com.cn/problem/P4446) - 质因数分解应用  

---

### 题解中的个人心得摘录
- **取模注意**：多篇题解提到需最后答案取模，否则得82分。  
- **特殊处理k=1**：当k=1时直接输出Q-P+1。  
- **质数平方优化**："prime[i]*prime[i]>k时break"显著减少循环次数。  
- **调试经验**：先写暴力再优化，验证数学推导的正确性。

---
处理用时：64.37秒
# 题目信息

# 「TERRA-OI R1」别得意，小子

## 题目背景

战至中途，蓝紫色天空瞬间变为黑压压一片，噬神者身上一些紫色外壳开始脱落，化为更小的蟒蛇，这些小家伙从出现开始便不要命的向你冲过来，刚清理掉这些小家伙，迷雾中忽然涌现出一张血盆大口，噬神者正向你冲击而来......

## 题目描述

现给定一个有 $n$ 段的分段函数，每一段可能是一个一次函数或者一个二次函数，并有 $q$ 次询问，每次询问 $x=k$ 时 $y$ 的取值或是 $y=k$ 与函数有多少个交点。



## 说明/提示

#### 【样例解释 #1】

三段函数分别为 $y=x+2$，$y=x^2-2x+1$，$y=x$。

对于当 $x=4$ 时套入第二段函数可以得到结果为 $9$。

而直线 $y=5$ 只与第一段与第二段函数相交，并且各只有一个交点，所以结果为 $2$。

显而易见，第三个询问对应的直线不与函数相交。

第四个询问虽然与第一段函数交于 $x=0$ 的位置，但 $0$ 不在该函数区间内，故舍去。

------------

#### 【数据范围】

**本题采用捆绑测试。**

| Subtask | Score | $n,q\le$ | limit |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $100$ | 无 |
| $2$ | $15$ | $10^3$ | $r_n\le 5\times 10^3$ |
| $3$ | $20$ | $2\times 10^5$ | 不存在询问 $2$ |
| $4$ | $25$ | $2\times 10^5$ | 不存在二次函数 |
| $5$ | $30$ | $2\times 10^5$ | 无 |

对于 $100\%$ 的数据，$1\le n,q\le 2\times 10^5$，$0\le l_i,r_i\le10^9$，$\forall i\in [1,n],r_i>l_i$ 。

所有的函数系数均在 **$64$ 位有符号整型变量**存储范围内，并且运算结果与每个函数式中任何一项的最大值与最小值不会超过 **$64$ 位有符号整型变量**存储范围。所有询问参数均在 **$32$ 位有符号整型变量**范围内。

（即 $-4\times 10^{18}\le k,a,b,c\le 4\times 10^{18}$，$-10^9\le x\le 10^9$）

------------
#### 【提示】

采用浮点数据时建议使用 long double，避免产生精度问题。

upd：添加一组 hack 数据，未通过会显示为“Unaccepted 100pts”。

## 样例 #1

### 输入

```
3 4
0 3 1 1 2
3 6 2 1 -2 1
6 10 1 1 0
1 4
2 5
2 114514
2 2```

### 输出

```
9
2
0
0```

## 样例 #2

### 输入

```
6 8
0 4 2 1 -4 0 
4 6 1 2 -10 
6 11 1 1 -19 
11 19 2 -1 -30 559 
19 29 1 1 -58 
29 38 1 1 -68 
1 11
2 4
2 -1
1 21
2 -5
2 2
1 34
2 1
```

### 输出

```
-8
1
4
-37
1
2
-34
2
```

# AI分析结果



### 综合分析与结论
本题核心在于高效处理二次函数的值域区间统计。最优解法采用**差分+离散化**的思路，通过拆分二次函数单调区间并标记值域范围，结合二分查找实现高效查询。动态开点线段树思路新颖但时空效率不足，推荐以差分方案为主。

---

### 精选题解列表

#### 1. MCRS_lizi（★★★★☆）
**关键亮点**：  
- 使用`map`维护离散化差分点，避免存储冗余区间  
- 对二次函数顶点进行精密的浮点精度判断（`fabs(...) <= e`）  
- 通过对称轴拆分区间，处理开口方向的影响  

**个人心得**：  
> "二次函数顶点不一定是整点，需要三四天的精密思考... 这就是困扰我三四天的部分"  
> —— 体现二次函数分类讨论的复杂性  

**核心代码**：  
```cpp
void tag(int x) { // 二次函数标记处理
    long double mid = -1.0*bb/(2*aa);
    if(顶点在区间内){
        int top = ceil(顶点值); // 关键精度处理
        if(fabs(顶点值 - top) <= e) // 判断是否为整数顶点
            upd(top+1, -1); // 调整差分标记
    }
}
```

---

#### 2. kbtyyds（★★★★☆）
**关键亮点**：  
- 显式分离一次/二次函数处理逻辑  
- 使用离散化三连（sort+unique+lower_bound）优化差分  
- 通过函数图像分析给出清晰数学推导  

**核心思路**：  
```cpp
struct func {
    void solve() { // 二次函数值域拆分
        if(对称轴在区间内){
            long double top = ...; // 计算顶点
            if(a>0) 处理上升/下降区间
            else 处理反向区间
        }
    }
}
```

---

#### 3. jifbt（★★★★☆）
**关键亮点**：  
- 极简代码风格（仅1.5KB）  
- 统一处理单调区间，利用STL快速排序查询  
- 将二次函数拆分逻辑抽象为通用`add`函数  

**代码亮点**：  
```cpp
void add(ll i, db l, db r) { // 统一处理区间
    db x=calc(l), y=calc(r);
    if(x<y) 打正向差分标记
    else 打反向差分标记
}
```

---

### 关键技巧总结
1. **差分离散化**：将连续值域转化为离散标记点，通过排序+二分实现高效查询  
2. **二次函数拆分**：按对称轴将区间拆分为两段单调区间处理  
3. **精度控制**：使用`long double`和`epsilon`判断整数顶点  
4. **STL优化**：利用`map`或`upper_bound`快速定位离散化点  

---

### 拓展训练
1. [P1471 方差](https://www.luogu.com.cn/problem/P1471) - 区间统计与数学公式推导  
2. [P5490 矩形面积并](https://www.luogu.com.cn/problem/P5490) - 离散化+扫描线经典问题  
3. [P3384 函数求和](https://www.luogu.com.cn/problem/P3384) - 分段函数的区间处理  

---

### 调试经验摘录
1. **动态开点陷阱**（聊机）：  
> "数组大小我试了两次才开过... 这里开longlong的高效就体现出来了"  
> —— 动态开点需预估节点数，类型转换影响性能  

2. **离散化细节**（kbtyyds）：  
> "tmp数组多存相邻点以确保连续"  
> —— 离散化需考虑区间连续性

---
处理用时：74.96秒
# 题目信息

# The Da Vinci Code

## 题目背景

> 圣杯在罗斯琳教堂下静待。  
> 大师杰作掩映中相拥入眠。  
> 剑刃圣杯守护着她的门宅。  
> 星空下她可安息无碍。

好的题目不需要花里胡哨的背景。

## 题目描述

给定一个长度为 $n$ 的数列 $a$，初始情况下 $a_i=i$。

另有一个取值在 $[1,n]$ 内的随机的整数 $x$，它取 $i$ 的概率为 $b_i$。

接下来进行 $k$ 次操作，每次**均匀随机**地选两个 $[1,n]$ 中的整数 $i,j$（允许 $i=j$），交换 $a_i,a_j$ 的值（如果 $i=j$ 则什么也不干）。问最后 $x$ 在位置 $i$ 上的概率，你需要对所有 $1\leq i\leq n$ 求出答案。你需要输出答案模 $3221225473$ 的值。

我们定义 $x$ 在位置 $i$ 上指 $a_i=x$。

## 说明/提示

#### 【样例解释】

对于样例 #1：

$b$ 数组为 $\{2134949164 ,1086276310\}$，操作 $9$ 次后 $x$ 在两个位置的概率均为 $\dfrac12$。

对于样例 #2：

$b$ 数组为 $\{1863763622,1043615898,1055155266,1556793106,1763540175,1239801170,1141007183\}$。

#### 【数据范围】
对于 $100\%$ 的数据：

* $2\leq n\leq2\times10^7$，$0\leq k,seed<2^{64}$。
* $1<b_i<3221225473$，$\sum\limits_{i=1}^n b_i\equiv 1\pmod{3221225473}$。
* 数据保证 $1<b_n<3221225473$ 且 $3221225473$ 是质数。

---

**本题采用捆绑测试**。

| $\text{Subtask}$ |$n\le$|$k\le$|分值|
|:-:|:-:|:-:|:-:|
|$0$|$2$|$2^{64}-1$|$1$|
|$1$|$5$|$5$|$4$|
|$2$|$200$|$200$|$6$|
|$3$|$200$|$2^{64}-1$|$9$|
|$4$|$2000$|$2000$|$7$|
|$5$|$2\times10^7$|$1$|$5$|
|$6$|$10^6$|$10^6$|$8$|
|$7$|$2\times10^7$|$10^7$|$10$|
|$8$|$10^6$|$2^{64}-1$|$15$|
|$9$|$2\times10^7$|$2^{64}-1$|$35$|

## 样例 #1

### 输入

```
2 9 998244353
```

### 输出

```
2684354563
```

## 样例 #2

### 输入

```
7 3 123456789
```

### 输出

```
24313281849
```

## 样例 #3

### 输入

```
10 9000000000000000000 1000000000000000000
```

### 输出

```
20026214895
```

## 样例 #4

### 输入

```
4 0 123456789
```

### 输出

```
12357556560
```

# AI分析结果



### 综合分析与结论

本题核心在于通过数学推导将每个位置的概率变化转化为线性递推，从而利用快速幂高效求解。关键点包括：

1. **线性变换观察**：每次交换操作后，每个位置的概率变化是线性的，形式为 $p_i' = a \cdot p_i + b$。
2. **不动点与等比数列**：通过求不动点将递推式转化为等比数列形式，利用快速幂计算 $k$ 次后的系数。
3. **独立处理每个位置**：每个位置的概率变化独立于其他位置，可直接应用线性变换，无需考虑状态间的相互影响。

### 精选题解

#### 1. 作者：cyffff（⭐⭐⭐⭐⭐）
**关键亮点**：
- 直接推导出线性变换公式，利用等比数列求和与快速幂高效计算。
- 代码简洁高效，时间复杂度 $O(n + \log k)$，适用于大规模数据。
- 通过预处理逆元优化计算，避免重复运算。

**核心代码**：
```cpp
uint in = qpow(n, mod-2), in2 = (ull)in * in % mod;
uint k1 = (ull)(n-2) * in % mod, b1 = (ull)2 * in2 % mod;
uint k2 = qpow(k1, k % (mod-1)), b2 = ...; // 等比数列求和
for (int i=1; i<=n; i++)
    ans ^= ((ull)k2 * b[i] % mod + b2) % mod * i;
```

#### 2. 作者：Missa（⭐⭐⭐⭐⭐）
**关键亮点**：
- 通过不动点法简化推导，直接得到指数衰减形式，代码更简洁。
- 显式处理溢出问题，使用 `unsigned long long` 确保正确性。

**核心代码**：
```cpp
LL invn = inv(n), s = qpow(invn * (n-2) % mod, k);
for (int i=1; i<=n; i++) {
    LL t = (b[i] - invn + mod) % mod * s % mod + invn;
    ans ^= t % mod * i;
}
```

### 关键思路与技巧
1. **线性变换与快速幂**：将递推式转化为 $p^{(k)} = A^k p^{(0)} + B \cdot \frac{A^k - 1}{A - 1}$，其中 $A$ 和 $B$ 为常数。
2. **逆元预处理**：利用费马小定理快速计算模意义下的逆元。
3. **独立概率处理**：每个位置独立计算，避免矩阵运算的高复杂度。

### 相似题目推荐
1. [P5104 红包发红包](https://www.luogu.com.cn/problem/P5104)：概率的线性变换与递推。
2. [P1365 WJMZBMR打osu!](https://www.luogu.com.cn/problem/P1365)：期望的递推处理与动态规划。
3. [P6154 游走](https://www.luogu.com.cn/problem/P6154)：期望计算与快速幂结合。

### 个人心得摘录
- **调试教训**（Missa）：需注意模数较大时使用足够大的数据类型（如 `unsigned long long`）避免溢出。
- **数学洞察**（cyffff）：将复杂交换操作转化为线性变换是解题关键，利用等比数列性质简化计算。

---
处理用时：291.43秒
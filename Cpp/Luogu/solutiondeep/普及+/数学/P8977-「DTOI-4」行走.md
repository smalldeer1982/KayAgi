# 题目信息

# 「DTOI-4」行走

## 题目背景

小 L 感到无聊，于是希望在树上行走。

## 题目描述

小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。

他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。

他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：

- $P$ 是一条**可以为空**的**简单有向路径**。
- 设 $P$ 中依次经过的点为 $P_1, P_2, \cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。
- 设 $f(P) = \displaystyle\sum_{i = 1}^{|P|} \frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。
- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。

请你求出符合上述条件的路径 $P$。 

------------

关于本题中字典序的定义：

设有两条待比较的路径 $P \neq Q$。

- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。
- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。

## 说明/提示

#### 样例 #1 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)

$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \frac{1}{4} = \frac{5}{4}$。可以证明不存在更优的 $P$。
#### 数据范围
| $\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |
| :------: | :------: | :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 50$ | 无特殊限制 | 无 | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 500$ | 同上 | $1$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 5 \times 10^3$ | 同上 | $1, 2$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^5$ | 同上 | $1 \sim 3$ | $20 \operatorname{pts}$ |
| $5$ | 无特殊限制 | $a_i \in \{-1, 1\}$ | 无 | $20 \operatorname{pts}$ |
| $6$ | 同上 | 无特殊限制 | $1 \sim 5$ | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$a_i \in \{-1, 0, 1\}$，$1 \leq u, v \leq n$，保证给出的边可以构成一棵**无根树**。

## 样例 #1

### 输入

```
5
1 0 -1 1 -1
1 2
2 3
2 4
1 5```

### 输出

```
1 2 4```

# AI分析结果



### 综合分析与结论
题目核心是求从根出发的权值最大且字典序最小的路径，关键点包括：
1. 排除权值-1的节点（后续无法补偿负贡献）
2. 优先选择权值1的节点（当前层贡献远大于后续层总和）
3. 字典序处理需结合邻接表排序和末尾0截断
4. 深度对权值的影响呈指数级衰减，需分层处理

### 高分题解推荐

#### 1. 作者：xiaoqian02（★★★★☆）
**关键亮点**：
- 基于DFS的贪心策略，动态维护二进制位权值
- 邻接表排序保证字典序优先选择编号小的子节点
- 通过`nxt`数组记录最优路径，避免重复计算
- 处理末尾0截断逻辑简洁

**核心代码思路**：
```cpp
bool dfs(int p,int fr,int dep) {
    int mx = -1;
    for (按字典序遍历子节点) {
        if (子节点是1) 尝试更新当前二进制位为1
        if (子节点是0) 在无法选1时再处理
    }
    return 是否更新最优路径
}
```

#### 2. 作者：Leasier（★★★★☆）
**关键亮点**：
- 分层处理策略，将节点按深度划分到不同层级的容器
- 通过两个容器交替处理，分离1和0的选择阶段
- 最终路径构造时使用字典序优先的DFS

**关键实现**：
```cpp
void bfs() {
    q[1].push_back(1); // 初始层
    while (!q.empty()) {
        sort当前层节点按权值降序排列;
        保留最大权值节点并淘汰其他;
        生成下一层节点;
    }
}
```

#### 3. 作者：Hovery（★★★☆☆）
**关键亮点**：
- BFS逐层计算每个节点的最大可能权值
- 通过`mx`数组记录每层最优解阈值
- 最后通过DFS反向构造路径

**优化点**：
- 使用优先队列维护当前层最优解
- 路径构造时结合父节点回溯

---

### 最优思路总结
1. **分层贪心策略**：将树按深度分层，优先在每层选择权值最大的节点（1 > 0）
2. **邻接表排序**：预处理时对每个节点的子节点按编号排序，保证字典序选择
3. **二进制位维护**：用数组模拟二进制位，通过覆盖高位0实现快速比较
4. **末尾0截断**：最终路径生成后逆向扫描删除末尾连续的0节点

---

### 相似题目推荐
1. [P1131 时态同步](https://www.luogu.com.cn/problem/P1131) - 树形贪心
2. [P1270 访问美术馆](https://www.luogu.com.cn/problem/P1270) - 树形路径选择
3. [P2668 斗地主](https://www.luogu.com.cn/problem/P2668) - 复杂贪心策略与剪枝

---

### 题解心得摘录
1. **xiaoqian02**：  
   > "DFS函数返回布尔值表示是否更新路径，通过动态覆盖低位0实现高效比较"  
   （通过返回值的传递优化路径选择）

2. **是青白呀**：  
   > "BFS中优先队列淘汰0节点时，发现必须同时处理同一父节点的兄弟节点才能正确剪枝"  
   （强调同层节点间的相互影响）

3. **LiYomi**：  
   > "路径生成阶段发现必须用栈反向输出，否则无法处理父节点回溯时的顺序问题"  
   （数据结构选择对最终输出形式的影响）

---
处理用时：70.69秒
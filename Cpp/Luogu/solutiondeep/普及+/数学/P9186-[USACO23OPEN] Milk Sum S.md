# 题目信息

# [USACO23OPEN] Milk Sum S

## 题目描述

**注意：本题的时间限制为 4 秒，是默认时间限制的 2 倍。**

Farmer John 的 $N$ 头奶牛的产奶量为整数 $a_1, \dots, a_N$。也就是说，第 $i$ 头奶牛每分钟产 $a_i$ 单位的牛奶。

每天早上，Farmer John 会将所有 $N$ 头奶牛连接到谷仓的挤奶机上。他需要依次断开连接，将奶牛送去进行日常锻炼。第一头奶牛在挤奶 1 分钟后被断开连接，第二头奶牛在再挤奶 1 分钟后被断开连接，依此类推。由于第一头奶牛（假设是奶牛 $x$）只在挤奶机上停留了 1 分钟，她总共贡献了 $a_x$ 单位的牛奶。第二头奶牛（假设是奶牛 $y$）在挤奶机上停留了总共 2 分钟，因此贡献了 $2a_y$ 单位的牛奶。第三头奶牛（假设是奶牛 $z$）贡献了 $3a_z$ 单位的牛奶，依此类推。设 $T$ 表示 Farmer John 以最优顺序断开奶牛连接时，可以收集到的最大总牛奶量。

Farmer John 很好奇，如果某些奶牛的产奶量发生变化，$T$ 会如何变化。对于每个由两个整数 $i$ 和 $j$ 指定的 $Q$ 个查询，请计算如果将 $a_i$ 设置为 $j$，新的 $T$ 值会是多少。注意，每个查询都是独立的临时变化，即在考虑下一个查询之前，$a_i$ 会恢复为原始值。

## 说明/提示

对于第一个查询，$a$ 将变为 $[1,1,4,2,6]$，此时 $T = 1 \cdot 1 + 2 \cdot 1 + 3 \cdot 2 + 4 \cdot 4 + 5 \cdot 6 = 55$。

对于第二个查询，$a$ 将变为 $[1,8,4,2,6]$，此时 $T = 1 \cdot 1 + 2 \cdot 2 + 3 \cdot 4 + 4 \cdot 6 + 5 \cdot 8 = 81$。

对于第三个查询，$a$ 将变为 $[1,10,4,5,6]$，此时 $T = 1 \cdot 1 + 2 \cdot 4 + 3 \cdot 5 + 4 \cdot 6 + 5 \cdot 10 = 98$。

$1 \leq N \leq 1.5 \cdot 10^5$，$0 \leq a_i \leq 10^8$，$1 \leq Q \leq 1.5 \cdot 10^5$，$0 \leq j \leq 10^8$。

- 输入 2-4：$N, Q \leq 1000$。
- 输入 5-11：没有额外限制。

## 样例 #1

### 输入

```
5
1 10 4 2 6
3
2 1
2 8
4 5
```

### 输出

```
55
81
98
```

# AI分析结果



### 综合分析与结论

题目核心在于快速处理动态修改后的最大加权和，关键思路为预处理排序数组及前缀和，通过二分确定新元素位置并计算影响。难点在于高效处理位置变化对总和的贡献调整，需细致处理下标偏移与分类讨论。最优解法时间复杂度为 O(N log N + Q log N)，利用二分与前缀和优化。

---

### 精选题解

#### 1. 作者：DreamLand_zcb ⭐⭐⭐⭐⭐
**关键亮点**：
- 详细图解辅助理解，逻辑清晰，全面覆盖各类边界情况。
- 利用`upper_bound`精确计算插入位置，处理元素移动贡献变化。
- 代码简洁高效，维护前缀和数组快速计算区间贡献。
**个人心得**：
- 强调必须使用`upper_bound`而非`lower_bound`避免下标错误。
- 通过图示明确展示元素删除与插入对排列的影响，辅助推导公式。

**核心代码**（处理查询部分）：
```cpp
ll ans = sum;
ans -= a[x] * P[a[x]];  // 删除原元素贡献
ans -= s[n] - s[P[a[x]]]; // 左移导致后续元素贡献减少
ll pos = upper_bound(b+1, b+n+1, y) - b;
ans += y * (pos - (pos > P[a[x]])); // 插入新元素贡献（考虑位置偏移）
ans += s[n] - s[pos-1]; // 右移导致后续元素贡献增加
if (pos <= P[a[x]]) ans -= b[P[a[x]]]; // 处理重复计算情况
```

#### 2. 作者：Nuyoah_awa ⭐⭐⭐⭐
**关键亮点**：
- 分改大/改小两种情况讨论，公式推导清晰。
- 预处理原位置信息，利用二分动态调整新位置。
**不足**：代码条件分支较多，部分边界需谨慎处理。

**核心逻辑**：
```cpp
if (x < a[opt].val) { // 改小情况
    int l = 1, r = opt - 1;
    // 二分找到插入点后计算区间和调整
    ans += (s[opt-1] - s[l-1]) - a[opt]*opt + x*l;
}
```

#### 3. 作者：technopolis_2085 ⭐⭐⭐⭐
**关键亮点**：
- 通过`map`记录原排序位置，简化查找过程。
- 明确分改大/改小两类处理，代码结构清晰。

---

### 关键思路与技巧
1. **排序预处理**：最优排列为升序，预处理排序数组及前缀和。
2. **二分定位**：使用`upper_bound`或`lower_bound`快速确定新元素插入位置。
3. **贡献调整公式**：通过前缀和快速计算元素移动导致的区间贡献变化。
4. **分类讨论**：根据新旧位置关系分情况处理下标偏移，避免重复或遗漏。

---

### 拓展练习
1. **P1972 [SDOI2009]HH的项链**（离线查询与树状数组）
2. **P1908 逆序对**（分治/树状数组处理动态排序问题）
3. **P1182 数列分段 Section II**（二分答案结合前缀和优化）

---

### 个人心得摘录
- **DreamLand_zcb**：调试中发现必须用`upper_bound`，且需注意元素移动后下标偏移带来的双重影响。
- **Nuyoah_awa**：强调开`long long`的重要性，避免溢出导致WA。
- **Sirkey**：临时修改无需维护数据结构，直接通过原数组与排序数组的关系计算。

---
处理用时：96.83秒
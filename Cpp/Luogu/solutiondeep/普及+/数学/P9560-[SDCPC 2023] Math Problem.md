# 题目信息

# [SDCPC 2023] Math Problem

## 题目描述

给定两个正整数 $n$ 和 $k$，您可以进行以下两种操作任意次（包括零次）：

- 选择一个整数 $x$ 满足 $0 \leq x < k$，将 $n$ 变为 $k\cdot n+x$。该操作每次花费 $a$ 枚金币。每次选择的整数 $x$ 可以不同。
- 将 $n$ 变为 $\lfloor \frac{n}{k} \rfloor$。该操作每次花费 $b$ 枚金币。其中 $\lfloor \frac{n}{k} \rfloor$ 表示小于等于 $\frac{n}{k}$ 的最大整数。

给定正整数 $m$，求将 $n$ 变为 $m$ 的倍数最少需要花费几枚金币。请注意：$0$ 是任何正整数的倍数。

## 样例 #1

### 输入

```
4
101 4 207 3 5
8 3 16 100 1
114 514 19 19 810
1 1 3 1 1```

### 输出

```
11
2
0
-1```

# AI分析结果



### 综合分析与结论
各题解核心思路一致：先枚举除操作次数，再对每个中间值计算最小乘操作次数，使数值区间包含m的倍数。关键优化点包括：  
1. **操作顺序**：先执行所有除操作（操作二），再执行乘操作（操作一）。  
2. **区间判断**：通过动态维护区间端点或模运算快速判断是否存在m倍数。  
3. **数据类型**：使用`__int128`处理大数避免溢出。  

### 高分题解推荐
#### 1. 作者：WhitD（★★★★☆）  
**关键亮点**：  
- 清晰枚举除操作次数，每次处理后动态扩展乘操作区间。  
- 使用`__int128`处理大数，代码简洁高效。  
- 完整处理特例（k=1时无解）。  

**核心代码**：  
```cpp
for(ll i=0,d=0;;i++,n/=k,d=i*b) {
    if(!n) { ans=min(ans,b*i); break; }
    __int128 l=n, r=n;
    while(l%m && (r/m==l/m)) { // 区间未覆盖m倍数时继续乘
        r = r*k +k-1;
        l *=k;
        d +=a;
    }
    ans = min(ans, d);
}
```

#### 2. 作者：Auto_Accepted（★★★★☆）  
**关键亮点**：  
- 类似区间扩展思路，代码逻辑紧凑。  
- 强调`__int128`的必要性，避免数据溢出。  

**核心代码**：  
```cpp
int l = n, r = n, tmp = cnt*b;
while(l/m == r/m && l%m) {
    r = r*k +k-1;
    l *=k;
    tmp +=a;
}
ans = min(ans, tmp);
```

#### 3. 作者：One_JuRuo（★★★★☆）  
**优化技巧**：  
- 通过模运算代替显式区间计算，减少数值规模。  
- 判断条件`(m-l)%m <= len`快速验证区间覆盖。  

**核心代码**：  
```cpp
l = n%m, len = 1;
for(int i=1;;++i) {
    if(len > (m-l)%m) { // 模运算判断区间覆盖
        ans = min(ans, res);
        break;
    }
    l = (l*k) % m; // 仅维护模值
    len *=k;
    res +=a;
}
```

### 关键思路与技巧总结
1. **操作顺序优化**：先除后乘，避免无效操作。  
2. **区间动态维护**：通过乘k扩展区间，直接判断是否覆盖m倍数。  
3. **模运算替代**：用`n%m`代替实际数值，减少计算量。  
4. **大数处理**：使用`__int128`或模运算避免溢出。  

### 同类题目推荐
1. **P1462** 通往奥格瑞玛的道路（二分答案+最短路）  
2. **P1226** 快速幂（操作顺序与数位处理）  
3. **P2114** 起床困难综合症（位运算与最优操作策略）  

### 题解中的个人心得
- **特例处理**：多位作者强调k=1时需特判（如WhitD的代码）。  
- **数据类型选择**：Auto_Accepted提到“上下界记得开__int128”，反映调试中溢出问题的教训。  
- **操作顺序顿悟**：One_JuRuo通过数学推导明确“先除后乘”的必然性，避免无效尝试。

---
处理用时：63.05秒
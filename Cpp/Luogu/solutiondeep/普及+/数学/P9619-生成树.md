# 题目信息

# 生成树

## 题目背景

> 我们是未成熟的斗士 现在绝不认输
>
> 我们是未成熟的梦想家 现在绝不哭泣

## 题目描述

现给定一个无向完全图 $G(V,E)$ 和一个长度为 $|V|$ 的权值数组 $a$．$a_i$ 表示编号为 $i$ 的节点的权值．

定义一条边 $e(u,v)$ 的边值为 $val(e)$，满足 $val(e)=a_u\oplus a_v$，也就是边连接的两个节点的权值的异或和；定义 $G$ 的一个生成树 $T(V,E_t)$ 的权值为 $Val(T)$，满足 $Val(T)=\sum_{e\in E_t}val(e)$，也就是树上边的边权和．

您需要求出 $\sum_{T}Val(T)$．即 $G$ 中所有不同生成树的权值的和．

我们认为两棵生成树是不同的，当且仅当两棵树的边集 $E_t$ 不完全相同，即至少存在一条边，满足其仅属于两棵生成树中的其中一棵．

## 说明/提示

### 样例 #1 说明：
考虑一共存在三个生成树 $\{1-2-3\},\{1-3-2\},\{3-1-2\}$．

它们的权值分别为 $(1\oplus 2)+(2\oplus 3)=4,(1\oplus 3)+(3\oplus 2)=3,(3\oplus 1)+(1\oplus 2)=5$．

有 $4+3+5=12$．

### 数据点约束
保证对于所有数据，$1\le n\le 10^6$，$0\le a_i\le 10^9$．
|测试点编号|数据范围|特殊性质|
|:-:|:-:|:-:|
|$1$||所有 $a_i$ 相等|
|$2\sim 5$|$n\le 4$||
|$6\sim 10$|$n\le 300$||
|$11\sim 12$|$n\le 5\times 10^4$|$a_i=[i=1]$|
|$11\sim 15$|$n\le 5\times 10^4$||
|$16\sim 20$|||

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
12```

## 样例 #2

### 输入

```
6
1 1 4 5 1 4```

### 输出

```
19008```

## 样例 #3

### 输入

```
10
1 1 4 5 1 4 1 9 1 9```

### 输出

```
567022588```

# AI分析结果



### 综合分析与结论
本题的核心在于利用完全图的生成树性质与异或运算的拆位处理。所有题解均基于两个关键点：1）通过Cayley定理推导每条边的出现次数；2）按位统计异或贡献。大部分解法思路正确，但实现方式与优化程度存在差异。

### 高星题解推荐

#### 1. 作者：hjqhs (★★★★★)
**关键亮点**：  
- 思路简洁清晰，直接统计每位0的个数，避免前缀和复杂度。
- 代码可读性强，正确处理边界条件（如n=1或n=2）。
- 快速幂与模运算处理规范，复杂度严格O(n log a)。

**核心代码片段**：
```cpp
for(int j=0;j<=31;j++) 
    t[j] += (((1<<j)&x)?0:1); // 统计该位0的总数
ans = sum * 2 * qpow(n, n-3) % mod; // 统一乘系数
```

#### 2. 作者：_Aurore_ (★★★★☆)
**关键亮点**：  
- 前缀和优化每位贡献计算，适合大规模数据。
- 详细推导边出现次数公式，数学严谨性高。
- 代码结构清晰，但前缀和部分稍显复杂。

**核心思路**：
```cpp
// 前缀和统计每位1的数目，逆序计算贡献
for (int j=1; j<=n; j++) {
    if (a[j]&(1ll<<i)) cnt += (n-j - (sum[n]-sum[j])) * (1ll<<i);
    else cnt += (sum[n] - sum[j]) * (1ll<<i);
}
```

#### 3. 作者：lfxxx (★★★★☆)
**关键亮点**：  
- 代码极简，直接遍历统计每位贡献。
- 显式处理n<3的情况，逻辑直观。
- 快速幂函数简洁高效，无冗余操作。

**核心代码**：
```cpp
for(int i=1;i<=n;i++) 
    for(int j=0;j<=30;j++) 
        cnt[j] += ((1<<j)&a[i]) ? 1 : 0; 
sum += (cnt[j] * (n-cnt[j])) * (1<<j); // 计算每位总贡献
```

### 关键思路与技巧
1. **Cayley定理应用**：完全图生成树数为n^(n-2)，每条边出现次数为2n^(n-3)。
2. **异或拆位统计**：对每个二进制位，统计0和1的个数，贡献为cnt0*cnt1*2^bit。
3. **快速幂优化**：模意义下高效计算n^k，注意处理n=0或负数指数的情况。

### 拓展与相似题目
1. **P6178 【模板】Matrix-Tree定理**（生成树计数基础）  
2. **P3317 [SDOI2014] 重建**（生成树概率与期望）  
3. **P4336 [SHOI2016] 黑暗前的幻想乡**（生成树容斥与位运算结合）

### 个人心得摘录
- **hjqhs**提到“拆位是经典trick”，强调此类问题应优先考虑位独立贡献。
- **Arghariza**的调试经验：注意n=2时公式的特殊处理，避免快速幂错误。
- **lfxxx**提醒自实现快速幂以避免浮点误差，强调模运算的严格性。

---
处理用时：115.70秒
# 题目信息

# 种树

## 题目背景

小 Rf 不是很喜欢种花，但是他喜欢种树。

## 题目描述

路边有 $n$ 棵树，每棵树的 **高度** 均为正整数，记作 $p_1, p_2 \dots p_n$。

定义一棵树的 **宽度** 为它高度的正因数个数，这些树能覆盖的距离为它们宽度的乘积，你想请你的朋友们来乘凉，但你发现这些树能覆盖的距离不够多。

于是你买了总量为 $w$ 单位的神奇化肥。你可以施若干次肥，每次你可以使用 $k$ 单位化肥（**要求 $k$ 必须为当前化肥量的正因数**），让任意一棵树的高度乘上 $k$，同时你剩余的化肥量也会除以 $k$。每次施肥的树可任意选择，且每次施肥选择的树不需相同。

你需要最大化这些树所能覆盖的距离，并输出这个最大距离。答案对 $998244353$ 取模。

## 说明/提示

**【样例 1 解释】**

+ 第一次施肥，向第一棵树施 $15$ 单位的肥，使其高度变成 $120$，剩余 $4$ 单位的化肥。
+ 第二次施肥，向第二棵树施 $4$ 单位的肥，使其高度变成 $972$，剩余 $1$ 单位的化肥。
+ 这时候，三棵树的宽度分别为 $16, 18, 8$，所能覆盖的距离为 $2304$，为最优解。

---

**【样例 2】**

见附件下的 $\texttt{plant/plant2.in}$ 与 $\texttt{plant/plant2.ans}$。

---

**【样例 3】**

见附件下的 $\texttt{plant/plant3.in}$ 与 $\texttt{plant/plant3.ans}$。

---

**【数据范围】**

| 测试点编号 | $n \leq$ | $p_i$ | $w$ | 单点分值 |
| :--------: | :------: | :---: | :---: | :------: |
| $1 \sim 5$ | $10^4$ | $=1$ | $=1$ | $1$ |
| $6 \sim 10$ | $10^4$ | $\leq 10^4$ | $=1$ | $3$ |
| $11 \sim 15$ | $1$ | $\leq 10^4$ | $\leq 10^4$ | $3$ |
| $16 \sim 20$ | $5$ | $\leq 10^4$ | $\leq 10^4$ | $6$ |
| $21 \sim 25$ | $10^4$ | $\leq 10^4$ | $\leq 10^4$ | $7$ |

对于 $100 \%$ 的数据，保证 $1 \leq n \leq 10^4$，$1 \leq p_i \leq 10^4$，$1 \leq w \leq 10^4$。

## 样例 #1

### 输入

```
3 60
8 243 250```

### 输出

```
2304```

# AI分析结果



### 综合分析与结论
各题解的核心思路均围绕质因数分解与贪心策略展开。核心算法要点如下：
1. **质因数独立处理**：将问题分解到每个质因数维度，各质因数的贡献独立计算。
2. **贪心分配**：对每个质因数的分配，优先增加当前指数最小的树，以最大化乘积。
3. **数据结构优化**：使用优先队列（最小堆）维护各质因数的指数，实现高效最小值查询。

### 高分题解推荐

#### 1. 樱雪喵（★★★★★）
**关键亮点**：
- 代码结构清晰，采用优先队列独立处理每个质因数
- 完整处理初始树的质因数分解和剩余未分配质因数
- 时间复杂度优化到O(n log n)级别

**核心代码思想**：
```cpp
void solve(int x, int sum) {
    priority_queue<int, vector<int>, greater<int>> q;
    // 初始化各树当前质因数的指数
    for (int i = 1; i <= n; i++) {
        int cnt = 0;
        while (a[i] % x == 0) cnt++, a[i] /= x;
        q.push(cnt + 1); // +1转为因数个数
    }
    // 贪心分配剩余次数
    while (sum--) {
        int t = q.top(); q.pop();
        q.push(t + 1);
    }
    // 计算该质因数的总贡献
    while (!q.empty()) {
        ans = ans * q.top() % mod;
        q.pop();
    }
}
```

#### 2. 佬头（★★★★☆）
**关键亮点**：
- 预处理所有质数的小根堆
- 对每个质数单独维护堆结构
- 处理未分配的质因数时自动补1

**优化点**：
```cpp
// 预处理所有可能的质数堆
for (int i = 2; i <= 10000; ++i) {
    if (!prime[i]) {
        k[i].push(0); // 初始化为0次方
    }
}
// 分配w的质因数
while (w % 2 == 0) {
    w /= 2;
    if (k[2].size() < n) k[2].push(1);
    else {
        int mn = k[2].top();
        k[2].pop();
        k[2].push(mn + 1);
    }
}
```

#### 3. EmptyAlien（★★★☆☆）
**关键缺陷**：
- 每次遍历所有树寻找最小值，时间复杂度O(n^2)
- 未处理初始树中不包含质因数的情况
- 只能通过部分测试点，大数据会超时

### 关键技巧总结
1. **质因数分解独立性**：将复杂问题拆解为独立质因数的优化问题
2. **贪心数学证明**：当且仅当每次选择最小指数时，乘积增幅最大
3. **优先队列优化**：用最小堆实现O(1)取最小元素和O(log n)插入
4. **预处理质数表**：加速质因数分解过程

### 同类题目推荐
1. [P1495 曹冲养猪](https://www.luogu.com.cn/problem/P1495)（质因数分解应用）
2. [P2043 质因数分解](https://www.luogu.com.cn/problem/P2043)（质因数统计训练）
3. [P2444 病毒](https://www.luogu.com.cn/problem/P2444)（因数相关性质应用）

### 调试心得摘录
1. **樱雪喵**：强调独立处理质因数的重要性，避免交叉影响
2. **Crsuh2er0**：在未初始化的质因数堆中补充1的指数，解决RE问题
3. **sbno333**：因未完全分解剩余质因数导致WA，添加二次分解代码
> "不开这个11分，别问我怎么知道的，问就是掉等级分" —— 体现未完全分解的致命性

---
处理用时：65.72秒
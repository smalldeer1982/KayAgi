# 题目信息

# [NOIP 2001 提高组] Car 的旅行路线

## 题目描述

又到暑假了，住在城市 A 的 Car 想和朋友一起去城市旅游。  
她知道每个城市都有 $4$ 个飞机场，分别位于一个矩形的 $4$ 个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第 $i$ 个城市中高速铁路的单位里程价格为 $T_i$，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为 $t$。


![](https://cdn.luogu.com.cn/upload/image_hosting/odqxn9sz.png)

**注意**：图中并没有标出所有的铁路与航线。


那么 Car 应如何安排到城市 B 的路线才能尽可能的节省花费呢？她发现这并不是一个简单的问题，于是她来向你请教。


找出一条从城市 A 到 B 的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10$，$1\le S \le 100$，$1\le A,B \le S$。

**【题目来源】**

NOIP 2001 提高组第四题

## 样例 #1

### 输入

```
1
3 10 1 3
1 1 1 3 3 1 30
2 5 7 4 5 2 1
8 6 8 8 11 6 3```

### 输出

```
47.5```

# AI分析结果

### 综合分析与结论
这些题解均围绕如何解决从城市 A 到城市 B 的最小花费路线问题，核心在于建图与求最短路。在处理矩形第四个点坐标时，都运用了几何知识；求最短路时，分别采用了 Floyd、Dijkstra 和 SPFA 算法。
- **思路**：各题解先根据输入的三个点求出矩形第四个点坐标，再构建图，最后使用不同的最短路算法求解。
- **算法要点**：
    - **Floyd**：适用于稠密图，时间复杂度为 $O(n^3)$。
    - **Dijkstra**：适用于无负权边的图，使用堆优化后时间复杂度为 $O(n^2log_n)$。
    - **SPFA**：可处理负权边，平均时间复杂度为 $O(km)$，k 为常数，m 为边数。
- **难点解决**：通过几何知识（如中点公式、勾股定理）求出矩形第四个点坐标；通过点的编号与城市编号的对应关系判断两点是否在同一城市。

### 所选题解
- **作者：_jimmywang_**（5 星）
    - **关键亮点**：思路清晰，详细解释了建图和求最短路的过程；代码简洁，使用 Floyd 算法解决问题。
    - **个人心得**：提到题目好写但也不好写，难点在于处理矩形只给三个点和代码长、变量多的问题。
- **作者：ShineEternal**（4 星）
    - **关键亮点**：考虑到 $O(n^3)$ 可能超时，使用 $n$ 遍堆优化的 Dijkstra 算法，时间复杂度为 $O(n^2log_n)$；详细解释了求矩形第四个点坐标的过程。
    - **个人心得**：分享了结构体存储方式对代码编写的影响，提醒要想好结构体的存储方式。
- **作者：LiJunze0501**（4 星）
    - **关键亮点**：采用 Floyd 算法，思路清晰，详细解释了如何通过勾股定理求矩形直角点和第四个点坐标。

### 重点代码及核心思想
#### _jimmywang_
```cpp
// 求两点距离
double diss(double x1,double y1,double x2,double y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
// 求两点距离的平方
double ds(double x1,double y1,double x2,double y2){return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);}
// 主函数
int main() {
    // 输入数据
    scanf("%lld",&TTT);
    while(TTT--){
        memset(dis,0,sizeof(dis)),ans=inf;
        scanf("%lld%lf%lld%lld",&s,&t,&A,&B);
        // 求矩形第四个点坐标
        f(i,1,s){
            scanf("%lf%lf%lf%lf%lf%lf%lf",&x[(i-1)*4+1],&y[(i-1)*4+1],&x[(i-1)*4+2],&y[(i-1)*4+2],&x[(i-1)*4+3],&y[(i-1)*4+3],&T[i]);
            double dab=ds(x[(i-1)*4+1],y[(i-1)*4+1],x[(i-1)*4+2],y[(i-1)*4+2]);
            double dac=ds(x[(i-1)*4+1],y[(i-1)*4+1],x[(i-1)*4+3],y[(i-1)*4+3]);
            double dbc=ds(x[(i-1)*4+2],y[(i-1)*4+2],x[(i-1)*4+3],y[(i-1)*4+3]);
            if(dab+dac==dbc)x[i*4]=x[(i-1)*4+2]+x[(i-1)*4+3]-x[(i-1)*4+1],y[i*4]=y[(i-1)*4+2]+y[(i-1)*4+3]-y[(i-1)*4+1];else
            if(dab+dbc==dac)x[i*4]=x[(i-1)*4+1]+x[(i-1)*4+3]-x[(i-1)*4+2],y[i*4]=y[(i-1)*4+1]+y[(i-1)*4+3]-y[(i-1)*4+2];else
            if(dbc+dac==dab)x[i*4]=x[(i-1)*4+2]+x[(i-1)*4+1]-x[(i-1)*4+3],y[i*4]=y[(i-1)*4+2]+y[(i-1)*4+1]-y[(i-1)*4+3];
        }
        // 建图
        f(i,1,s*4)f(j,1,s*4)if(i!=j){
                if((i-1)/4!=(j-1)/4)dis[i][j]=t*diss(x[i],y[i],x[j],y[j]);
                else dis[i][j]=T[(i-1)/4+1]*diss(x[i],y[i],x[j],y[j]);
            }
        // Floyd 算法求最短路
        f(k,1,s*4)f(i,1,s*4)f(j,1,s*4)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
        // 求最小花费
        f(i,1,4)f(j,1,4)ans=min(ans,dis[(A-1)*4+i][(B-1)*4+j]);
        printf("%.1lf\n",ans);
    }
	return 0;
}
```
核心思想：先根据输入的三个点求出矩形第四个点坐标，再根据两点是否在同一城市构建图，最后使用 Floyd 算法求最短路，找出 A 城市到 B 城市的最小花费。

#### ShineEternal
```cpp
// 求矩形第四个点坐标
void find(double a,double b,double c,double d,double e,double f)
{
    cnt++;
    dis[1].num=sqrt(Sqr(a-c)+Sqr(b-d)); 
    dis[1].id=1;
    dis[2].num=sqrt(Sqr(e-c)+Sqr(f-d)); 
    dis[2].id=2;
    dis[3].num=sqrt(Sqr(a-e)+Sqr(b-f));
    dis[3].id=3;
    sort(dis+1,dis+4,cmp);
    if(dis[1].id==1)
    {
        double x=min(a,c)+Abs(a-c)/2;
        double y=min(b,d)+Abs(b-d)/2;
        double xn=x+x-e;
        double yn=y+y-f;
        p[cnt].x=xn;
        p[cnt].y=yn;
    }
    if(dis[1].id==2)
    {
        double x=min(c,e)+Abs(e-c)/2;
        double y=min(f,d)+Abs(f-d)/2;
        double xn=x+x-a;
        double yn=y+y-b;
        p[cnt].x=xn;
        p[cnt].y=yn;
    }
    if(dis[1].id==3)
    {
        double x=min(a,e)+Abs(a-e)/2;
        double y=min(b,f)+Abs(b-f)/2;
        double xn=x+x-c;
        double yn=y+y-d;
        p[cnt].x=xn;
        p[cnt].y=yn;
    }
}
// Dijkstra 算法求最短路
void dijkstra(int s)
{
    memset(vis,0,sizeof(vis));
    d[s][s]=0;
    q.push(make_pair(0,s));
    while(!q.empty())
    {
        int x=q.top().second;
        q.pop();
        if(vis[x]==1)
        continue;
        vis[x]=1;
        for(int i=1;i<=cnt;i++)
        {
            if(d[s][x]+dist[x][i]<d[s][i])
            {
                d[s][i]=d[s][x]+dist[x][i];
                q.push(make_pair(d[s][i],i));
            }
        }
    }
}
```
核心思想：通过找出三个点中距离最远的两个点，取中点，再根据中点和另一个点求出矩形第四个点坐标；使用堆优化的 Dijkstra 算法求最短路。

#### LiJunze0501
```cpp
// 求第四个机场的坐标
void getair4(int id){
    double d12=pf(air[4*(id-1)+1].x-air[4*(id-1)+2].x)+pf(air[4*(id-1)+1].y-air[4*(id-1)+2].y);
    double d23=pf(air[4*(id-1)+2].x-air[4*(id-1)+3].x)+pf(air[4*(id-1)+2].y-air[4*(id-1)+3].y);
    double d13=pf(air[4*(id-1)+1].x-air[4*(id-1)+3].x)+pf(air[4*(id-1)+1].y-air[4*(id-1)+3].y);
    if(d12+d13==d23){//1是直角点
        air[4*id].x=air[4*(id-1)+2].x+air[4*(id-1)+3].x-air[4*(id-1)+1].x;
        air[4*id].y=air[4*(id-1)+2].y+air[4*(id-1)+3].y-air[4*(id-1)+1].y;	
    }
    if(d12+d23==d13){//2是直角点
        air[4*id].x=air[4*(id-1)+1].x+air[4*(id-1)+3].x-air[4*(id-1)+2].x;
        air[4*id].y=air[4*(id-1)+1].y+air[4*(id-1)+3].y-air[4*(id-1)+2].y;	
    }
    if(d23+d13==d12){//3是直角点
        air[4*id].x=air[4*(id-1)+1].x+air[4*(id-1)+2].x-air[4*(id-1)+3].x;
        air[4*id].y=air[4*(id-1)+1].y+air[4*(id-1)+2].y-air[4*(id-1)+3].y;	
    }
}
// 主函数
int main(){
    cin>>n;
    while(n--){
        cin>>s>>t>>a>>b;
        // 花费初始化为最大值 
        for(int i=1;i<=4*s;i++)
            for(int j=1;j<=4*s;j++)
                if(i!=j) cost[i][j]=INT_MAX;
        for(int i=1;i<=s;i++){
            cin>>air[4*(i-1)+1].x>>air[4*(i-1)+1].y;
            cin>>air[4*(i-1)+2].x>>air[4*(i-1)+2].y;
            cin>>air[4*(i-1)+3].x>>air[4*(i-1)+3].y;
            cin>>Tp[i-1];
            getair4(i);
        }
        // 初始化花费
        for(int i=1;i<=4*s;i++)
            for(int j=1;j<=4*s;j++)
                if(i!=j) cost[i][j]=cost[j][i]=((i-1)/4==(j-1)/4)?dis(i,j)*Tp[(i-1)/4]:dis(i,j)*t;
        // Floyd 算法求最短路
        for(int k=1;k<=4*s;k++)
            for(int i=1;i<=4*s;i++)
                for(int j=1;j<=4*s;j++)
                    if(i!=j&&j!=k&&i!=k) cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);
        // 求最小花费
        double ans=INT_MAX;
        for(int i=1;i<=4;i++)
            for(int j=1;j<=4;j++) ans=min(ans,cost[4*(a-1)+i][4*(b-1)+j]);
        printf("%.1lf\n",ans);
    }
}
```
核心思想：通过勾股定理判断直角点，进而求出矩形第四个点坐标；使用 Floyd 算法求最短路，找出 A 城市到 B 城市的最小花费。

### 最优关键思路或技巧
- **几何知识运用**：利用中点公式和勾股定理求出矩形第四个点坐标。
- **编号对应关系**：通过点的编号与城市编号的对应关系判断两点是否在同一城市。
- **算法选择**：根据数据范围选择合适的最短路算法，如 Floyd、Dijkstra 或 SPFA。

### 可拓展之处
同类型题或类似算法套路：
- 其他涉及图的最短路问题，如带权有向图、带负权边的图等。
- 几何问题与图论结合的问题，如求多边形顶点坐标、判断点与多边形的位置关系等。

### 推荐题目
- P3371 【模板】单源最短路径（弱化版）
- P4779 【模板】单源最短路径（标准版）
- P2888 [USACO07NOV]Cow Hurdles S

### 个人心得总结
- _jimmywang_：意识到题目实现时可能遇到处理矩形只给三个点和代码长、变量多的问题。
- ShineEternal：强调结构体存储方式对代码编写的重要性，不合适的存储方式会增加代码复杂度。 

---
处理用时：80.94秒
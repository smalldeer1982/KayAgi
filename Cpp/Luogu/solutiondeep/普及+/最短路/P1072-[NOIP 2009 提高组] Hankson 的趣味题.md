# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何求解满足特定最大公约数和最小公倍数条件的正整数 $x$ 的个数展开。整体思路可分为两类：一类是通过数学推理缩小 $x$ 的可能范围，再进行枚举判断；另一类是利用唯一分解定理，对质因数的指数进行分类讨论。各题解在复杂度和实现细节上有所差异，多数题解通过枚举 $b_1$ 的因数来优化暴力枚举，部分题解还进行了进一步的优化，如去除共有的质因数等。

### 所选题解
- **作者：zzlzk (赞：468)，4星**
    - **关键亮点**：思路清晰，通过数学推导得出 $x$ 是 $a_1$ 的整数倍且是 $b_1$ 的因子，然后枚举 $b_1$ 的因子进行判断，代码简洁易懂。
- **作者：KesdiaelKen (赞：103)，4星**
    - **关键亮点**：不仅详细推导了结论，还对算法进行了优化，通过去除共有的质因数降低复杂度，同时考虑了特判情况，逻辑严谨。
- **作者：皎月半洒花 (赞：60)，4星**
    - **关键亮点**：提出了用唯一分解定理的毒瘤解法，对质因数的指数进行分类讨论，考虑了各种情况，虽然代码复杂，但思路独特。

### 重点代码及核心实现思想
#### zzlzk 的题解
```cpp
#include<cstdio>
using namespace std;
int gcd(int a,int b) {
    return b==0?a:gcd(b,a%b);
}
int main() {
    int T;
    scanf("%d",&T);
    while(T--) {
        int a0,a1,b0,b1;
        scanf("%d%d%d%d",&a0,&a1,&b0,&b1);
        int p=a0/a1,q=b1/b0,ans=0;
        for(int x=1;x*x<=b1;x++) 
            if(b1%x==0){
                if(x%a1==0&&gcd(x/a1,p)==1&&gcd(q,b1/x)==1) ans++;
                int y=b1/x;
                if(x==y) continue; 
                if(y%a1==0&&gcd(y/a1,p)==1&&gcd(q,b1/y)==1) ans++;
            }
        printf("%d\n",ans);
    }
    return 0;
}
```
**核心实现思想**：先根据数学推导得出 $x$ 是 $a_1$ 的整数倍且是 $b_1$ 的因子，然后枚举 $b_1$ 的因子 $x$，判断 $x$ 是否满足条件，同时考虑 $b_1/x$ 这个因子，避免重复计算。

#### KesdiaelKen 的题解
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<string>
using namespace std;
int ssqrt;
int cf(int a,int b) {
    ssqrt=sqrt(b);
    for(int i=2;i<=ssqrt;i++) {
        if(b%i==0)while(a%i==0)a/=i;
        while(b%i==0)b/=i;
    }
    if(b!=1)while(a%b==0)a/=b;
    return a;
}
int gcd(int a,int b){return b==0?a:gcd(b,a%b);}
int main()
{
    int a0,a1,b0,b1;
    int gs;
    int m,n,s,l,q;
    scanf("%d",&gs);
    int cnt;
    while(gs--)
    {
        scanf("%d%d%d%d",&a0,&a1,&b0,&b1);
        if(a0%a1|b1%b0|b1%a1){printf("0\n");continue;}
        m=a0/a1,n=b1/b0,s=b1/a1;l=cf(s,n);
        if(gcd(max(s/l,m),min(s/l,m))!=1){printf("0\n");continue;}
        q=cf(l,m);cnt=0,ssqrt=sqrt(q);
        for(int i=1;i<=ssqrt;i++)if(q%i==0)cnt+=i==q/i?1:2;
        printf("%d\n",cnt);
    }
    return 0;
}
```
**核心实现思想**：先根据条件推导出相关结论，然后通过 `cf` 函数去除共有的质因数，降低复杂度，最后枚举剩余数的因数，统计满足条件的个数，同时进行特判，避免不必要的计算。

#### 皎月半洒花的题解
```cpp
inline void work(int ST, int ED){
    for(i = ST; i <= ED ; ++ i){
        N1 = N2 = N3 = N4 = 0;
        while (!(A0 % P[i])) A0 /= P[i], ++ N1;
        while (!(A1 % P[i])) A1 /= P[i], ++ N2;
        while (!(B0 % P[i])) B0 /= P[i], ++ N3;
        while (!(B1 % P[i])) B1 /= P[i], ++ N4;
        if (N1 > N2 && N3 < N4){
            if (N2 == N4) A[i] = B[i] = 1;
            else {mark = 0; break ;}
            continue ;
        }
        if (N1 > N2){
            if (N4 >= N2) A[i] = B[i] = N2;
            else {mark = 0; break ;}
            continue ;
        }
        if (N3 < N4){
            if (N4 >= N2) A[i] = B[i] = N3;
            else {mark = 0; break ;}
            continue ;
        }
        else {
            if (N4 >= N2) A[i] = N2, B[i] = N4;
            else {mark = 0; break ;}
        }
    }
}
```
**核心实现思想**：利用唯一分解定理，对质因数的指数进行分类讨论，根据不同情况判断是否有解，同时考虑了各种边界情况，最后将每个质因数的指数取值情况相乘得到最终结果。

### 最优关键思路或技巧
- **缩小枚举范围**：根据最大公约数和最小公倍数的性质，得出 $x$ 是 $b_1$ 的因数，从而将枚举范围从 $1$ 到 $b_1$ 缩小到 $1$ 到 $\sqrt{b_1}$，降低了时间复杂度。
- **数学推导**：通过数学推导得出一些结论，如 $x$ 是 $a_1$ 的整数倍，以及一些互质关系，减少不必要的判断。
- **去除共有的质因数**：在一些题解中，通过去除共有的质因数，进一步优化算法，降低复杂度。

### 可拓展之处
同类型题或类似算法套路：
- 其他涉及最大公约数、最小公倍数的逆问题，可采用类似的数学推导和枚举优化思路。
- 质因数分解相关的题目，可利用唯一分解定理对质因数的指数进行分类讨论。

### 推荐题目
- [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)
- [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)
- [P2152 [SDOI2009]SuperGCD](https://www.luogu.com.cn/problem/P2152)

### 个人心得摘录与总结
- **皎月半洒花**：提到 work 函数是在事先考虑清楚，事中如同做梦，事后不可思议的情况下写出来的，说明在写代码时可能会有灵感突发的情况。还提到自由不自由的定义是突发奇想，这样可以使文字阐述更简练。另外，指出如果不找另一个比较大的质数，只能得 90 分，说明在处理数据时要考虑全面，注意边界情况。
- **Kexi_**：指出暴力枚举效率不高，可通过将 $x$ 的取值限制在 $\sqrt{b1}$ 内，一起枚举两个量，优化复杂度，强调了剪枝优化的重要性。

---
处理用时：51.74秒
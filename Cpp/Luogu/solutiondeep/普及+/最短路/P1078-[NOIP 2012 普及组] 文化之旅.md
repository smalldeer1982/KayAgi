# 题目信息

# [NOIP 2012 普及组] 文化之旅

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。由于测试数据过水，可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）。本题题目和数据仅供参考。本题不接受添加 hack 数据。

本题为错题。**不建议尝试或提交本题。**[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。

现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。


## 说明/提示

输入输出样例说明$1$

由于到国家 $2$ 必须要经过国家$ 1$，而国家$ 2 $的文明却排斥国家 $1$ 的文明，所以不可能到达国家 $2$。


输入输出样例说明$2$

路线为$ 1$ ->$ 2$

【数据范围】

对于 100%的数据，有$ 2≤N≤100$

$1≤K≤100$ 

$1≤M≤N^2$

$1≤k_i≤K$

$1≤u, v≤N$ 

$1≤d≤1000,S≠T,1≤S,T≤N$

NOIP 2012 普及组 第四题


## 样例 #1

### 输入

```
2 2 1 1 2 
1 2 
0 1 
1 0 
1 2 10 
```

### 输出

```
-1```

## 样例 #2

### 输入

```
2 2 1 1 2 
1 2 
0 1 
0 0 
1 2 10 ```

### 输出

```
10```

# AI分析结果

### 综合分析与结论
本题是一个带有文化排斥和文化不重复学习限制的图论最短路问题。各题解主要围绕深度优先搜索（DFS）、广度优先搜索（如SPFA）、Floyd算法和Dijkstra算法展开，并通过不同的剪枝和标记方法来处理文化限制条件。

### 所选题解
1. **作者：Created_equal1（5星）**
    - **关键亮点**：采用启发式搜索，先跑一遍无视文化排斥的最短路，利用该结果进行剪枝，有效减少搜索空间，思路清晰，代码规范。
    - **核心代码**：
```cpp
void Spfa()
{
    memset(Dist, 0X7F, sizeof(Dist));
    queue<unsigned int> Q;
    Q.push(S);
    In_Q[S] = true;
    Dist[S] = 0;
    unsigned int Top;
    while (Q.size())
    {
        Top = Q.front();
        Q.pop();
        In_Q[Top] = false;
        for (size_t i = Head[Top];i;i = Next[i])
            if (Dist[To[i]] > Dist[Top] + Weight[i])
            {
                Dist[To[i]] = Dist[Top] + Weight[i];
                if (!In_Q[To[i]])
                {
                    In_Q[To[i]] = true;
                    Q.push(To[i]);
                }
            }
    }
}
void Dfs(const size_t &Now, const unsigned int &D)
{
    Went[Now] = true;
    culture.insert(C[Now]);
    if (Now == S)
    {
        Ans = min(Ans, D);
        return;
    }
    if (D + Dist[Now] > Ans)
        return;
    for (size_t i = Head[Now];i;i = Next[i])
        if (!Went[To[i]] && check(C[To[i]]))
            Dfs(To[i], D + Weight[i]);
    Went[Now] = false;
    culture.erase(C[Now]);
}
```
    - **核心思想**：`Spfa`函数计算无视文化排斥的最短路，`Dfs`函数进行深度优先搜索，在搜索过程中使用剪枝条件`D + Dist[Now] > Ans`减少不必要的搜索。

2. **作者：wjyyy（4星）**
    - **关键亮点**：使用Floyd算法，通过对插点过程进行标记，处理文化排斥和重复问题，代码简洁易懂。
    - **核心代码**：
```cpp
void floyd()//求最短路并判断是否排斥或重复
{
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(!a[c[k]][c[i]]&&!a[c[j]][c[k]]&&!used[i][k][c[j]]&&!used[k][j][c[i]]&&f[i][k]+f[k][j]<f[i][j])
                {
                    for(int t=1;t<=n;t++)
                        used[i][j][t]=used[i][k][t]||used[k][j][t];//有一个式子为真则表达式值为真
                    used[i][j][c[k]]=true;
                    f[i][j]=f[i][k]+f[k][j];
                }
}
```
    - **核心思想**：在Floyd算法的基础上，增加文化排斥和重复的判断条件，更新路径信息和文化标记。

3. **作者：grard4（4星）**
    - **关键亮点**：使用A*算法，对估价函数进行合理定义，同时通过去除无用边和使用`bitset`优化判断过程，提高搜索效率。
    - **核心代码**：
```cpp
struct node{
    int u,w;bitset<MAXN> ok;
    friend bool operator<(const node &x, const node &y){
        //估价小的优先
        return 1ll*x.w+dis[x.u]>1ll*y.w+dis[y.u];
    }
};
priority_queue<node> q;
void spfa(){           //对终点跑一遍最短路
    memset(dis,0x7f,sizeof(dis));
    queue<int> Q;
    dis[t]=0;Q.push(t);
    while(!Q.empty()){
        int u=Q.front();Q.pop();
        vis[u]=false;
        for (int i=h2[u];i;i=e2[i].nxt){
            int v=e2[i].to,w=e2[i].val;
            if (dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                if (!vis[v]) vis[v]=true,Q.push(v);
            }
        }
    }
    return;
}
```
    - **核心思想**：`spfa`函数计算终点到各点的最短路，用于A*算法的估价函数。`node`结构体定义了状态和估价函数，优先队列按估价从小到大排序。

### 最优关键思路或技巧
- **剪枝优化**：如Created_equal1的题解，先计算无视文化排斥的最短路，在搜索过程中利用该结果进行剪枝，减少不必要的搜索。
- **去除无用边**：grard4的题解中，在建边时去除与起点文化相同的点、文化排斥的边和文化相同的边，优化搜索复杂度。
- **状态标记**：使用数组或`bitset`记录已学习的文化，方便判断是否可以到达下一个国家。

### 可拓展之处
同类型题可能会有更多的限制条件，如时间限制、资源限制等。类似算法套路包括在图论算法中加入额外的状态标记和剪枝策略，以处理复杂的限制条件。

### 推荐题目
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：考察最短路算法和路径计数。
2. [P1339 [USACO09OCT]Heat Wave G](https://www.luogu.com.cn/problem/P1339)：经典的单源最短路问题。
3. [P2820 局域网](https://www.luogu.com.cn/problem/P2820)：涉及图的最小生成树和最短路的综合应用。

### 个人心得摘录与总结
- **yedalong**：在做标记时不能直接赋值，需要加1或减1，不然回溯时会把标记直接覆盖掉，导致调试困难。总结：在使用回溯算法时，要注意标记的更新和恢复方式，避免出现覆盖问题。

---
处理用时：43.76秒
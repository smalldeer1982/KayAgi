# 题目信息

# 杂务

## 题目描述

John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。

当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。

John 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。

写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。


## 样例 #1

### 输入

```
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
```

### 输出

```
23
```

# AI分析结果

### 综合分析与结论
本题主要围绕杂务完成的最短时间展开，由于杂务之间存在依赖关系，解题的关键在于处理这些依赖，确定每个杂务的最早开始时间。众多题解提供了多种思路，主要可分为拓扑排序、动态规划和记忆化搜索三类。

拓扑排序类题解通过维护入度、队列等结构，确保在计算某个杂务的完成时间时，其所有前置杂务都已完成。动态规划类题解则依据杂务的依赖顺序，直接计算每个杂务的最早完成时间。记忆化搜索类题解利用递归和记忆数组，避免重复计算。

### 所选题解
- **作者：Nishikino_Curtis（5星）**
  - **关键亮点**：代码简洁，思路清晰。利用任务编号的顺序特性，边读入边计算，直接从前驱中选取最大完成时间更新当前任务的完成时间，巧妙地解决了任务依赖问题。
  - **个人心得**：无
- **作者：Keith_2006（4星）**
  - **关键亮点**：详细介绍了拓扑排序和记忆化搜索两种方法，对拓扑排序的原理和实现步骤讲解透彻，配有图示和证明，适合初学者学习。
  - **个人心得**：作者在2024年重新学习拓扑排序时修改笔误，体现了对知识的不断回顾和完善。
- **作者：SW_Wind（4星）**
  - **关键亮点**：代码简洁高效，用`f[i]`表示完成第`i`件任务的最早时间，通过比较前提任务的完成时间，确定当前任务的最早起始时间，进而得到最早完成时间。
  - **个人心得**：作者认为自己的代码短，且能一次AC，体现了对解题思路的自信。

### 重点代码
#### Nishikino_Curtis的题解
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,l,t,ans[10005],maxans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&i);
        scanf("%d",&l);
        int tmp=0;
        while(scanf("%d",&t)&&t)
            tmp=max(ans[t],tmp);
        ans[i]=tmp+l;
        maxans=max(ans[i],maxans);
    } 
    printf("%d\n",maxans);
    return 0;
 } 
```
**核心实现思想**：在循环中读入每个任务的信息，对于每个任务，找到其所有前驱任务中的最大完成时间`tmp`，当前任务的完成时间为`tmp + l`，并更新全局最大完成时间`maxans`。

#### Keith_2006的拓扑排序题解
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cctype>
#include <vector>
#include <queue>

#define ll long long

using namespace std;

inline int read() {
    // 读入优化，省略具体实现
}

const int N=500005;

int ind[N],f[N],a[N];  //ind--入度   f--答案   a--时间
vector <int> edge[N];
queue <int> q;

int main() {
    int n=read();
    for (int i=1;i<=n;i++) {
        int x=read();
        a[i]=read();
        while (int y=read()) {
            if (!y) break;
            edge[y].push_back(x);
            ind[x]++;
        }
    }
    for (int i=1;i<=n;i++) {
        if (ind[i]==0) {
            q.push(i);
            f[i]=a[i];
        }
    }
    while (!q.empty()) {
        int rhs=q.front();
        q.pop();
        for (int i=0;i<edge[rhs].size();i++) {
            int u=edge[rhs][i];
            ind[u]--;
            if (ind[u]==0) q.push(u);
            f[u]=max(f[u],f[rhs]+a[u]);
        }
    }
    int ans=0;
    for (int i=1;i<=n;i++) {
        ans=max(ans,f[i]);
    }
    printf("%d\n",ans);
    return 0;
}
```
**核心实现思想**：首先读入任务信息，构建图并统计每个任务的入度。将入度为0的任务加入队列，在队列不为空时，取出队首任务，更新其后续任务的入度和完成时间，当某个后续任务的入度变为0时，将其加入队列。最后找出所有任务中的最大完成时间。

#### SW_Wind的题解
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[10005], n, k, ans, t;
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        scanf("%d%d", &k, &t);
        while(scanf("%d", &k) && k)
            f[i] = max(f[k], f[i]);
        f[i] += t;
        ans = max(ans, f[i]);
    }
    printf("%d", ans);
}
```
**核心实现思想**：在循环中读入每个任务的信息，对于每个任务，找到其所有前提任务中的最大完成时间，作为当前任务的最早起始时间，加上当前任务的耗时得到最早完成时间，并更新全局最大完成时间。

### 最优关键思路或技巧
- **利用任务编号顺序**：由于杂务`k (k>1)`的准备工作只可能在杂务`1`至`k - 1`中，部分题解利用这个特性，边读入边计算，避免了复杂的图构建和拓扑排序过程。
- **拓扑排序**：对于存在依赖关系的任务，拓扑排序是一种有效的处理方法。通过维护入度和队列，确保在计算某个任务的完成时间时，其所有前置任务都已完成。
- **记忆化搜索**：对于递归计算中存在大量重复计算的情况，使用记忆化数组可以避免重复计算，提高效率。

### 可拓展之处
同类型题或类似算法套路包括：
- **AOE网中的关键路径问题**：与本题类似，需要处理任务之间的依赖关系，计算完成所有任务的最短时间。
- **DAG上的最长路问题**：可以将本题转化为DAG上的最长路问题，通过拓扑排序或记忆化搜索求解。
- **项目管理中的任务调度问题**：在实际项目管理中，需要合理安排任务的执行顺序，以确保项目能够在最短时间内完成，本题的解题思路可以应用到此类问题中。

### 推荐题目
- [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)
- [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)
- [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

### 个人心得摘录与总结
- **Keith_2006**：作者在2024年重新学习拓扑排序时修改笔误，体现了对知识的不断回顾和完善，强调了温故知新的重要性。
- **SW_Wind**：作者认为自己的代码短且能一次AC，体现了对解题思路的自信，同时也说明简洁的代码往往能更高效地解决问题。
- **_无v名_**：作者承认自己的代码能水过是因为数据太水，且意识到在某些特殊情况下会爆，体现了对自身代码的清醒认识和对算法复杂度的重视。

---
处理用时：48.08秒
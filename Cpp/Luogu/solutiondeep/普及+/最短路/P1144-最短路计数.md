# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论
本题是无向无权图的最短路计数问题，题解主要围绕广度优先搜索（BFS）、最短路径快速算法（SPFA）、堆优化的迪杰斯特拉（Dijkstra）算法展开，通过在这些算法基础上添加计数操作来解决问题。各题解的核心思路都是在更新最短路的过程中，根据不同情况更新到每个点的最短路的数量。

### 所选题解
- **作者：ZiDing_ByronFinlso（5星）**
    - **关键亮点**：思路清晰，详细给出了 SPFA 和堆优化 Dijkstra 两种解法，并给出了运行时间对比。代码规范，使用了快读优化输入。
    - **个人心得**：无

### 重点代码
```cpp
// SPFA 核心代码
while(q.size())
{
    x=q.front();q.pop();
    p[x]=0;
    for(int i=head[x];i;i=nxt[i])
    {
        y=to[i];
        if(d[y]>d[x]+1)
        {
            d[y]=d[x]+1;
            ans[y]=ans[x];
            if(!p[y])
            {
                q.push(y);
                p[y]=1;
            }
        }
        else if(d[y]==d[x]+1)
        {
            ans[y]+=ans[x];
            ans[y]%=mod;
        }
    }
}
```
**核心实现思想**：在 SPFA 算法的基础上，增加了 `ans` 数组来记录到每个点的最短路的数量。当找到更短的路径时，更新 `d` 数组和 `ans` 数组；当找到相同长度的最短路时，将 `ans` 数组的值累加并取模。

```cpp
// 堆优化 Dijkstra 核心代码
while(q.size())
{
    x=q.top().second;
    q.pop();
    if(p[x]) continue;
    p[x]=1;
    for(int i=head[x];i;i=nxt[i])
    {
        y=to[i];
        if(d[y]>d[x]+1)
        {
            d[y]=d[x]+1;
            ans[y]=ans[x];
            q.push(make_pair(-d[y],y));
        }
        else if(d[y]==d[x]+1)
        {
            ans[y]+=ans[x];
            ans[y]%=mod;
        }
    }
}
```
**核心实现思想**：在堆优化的 Dijkstra 算法基础上，同样增加 `ans` 数组来记录最短路的数量。利用优先队列保证每次取出的是距离最小的点，更新 `d` 数组和 `ans` 数组的逻辑与 SPFA 类似。

### 最优关键思路或技巧
- **计数逻辑**：在更新最短路的过程中，若找到更短的路径，则将该点的最短路数量更新为前驱节点的最短路数量；若找到相同长度的最短路，则将该点的最短路数量加上前驱节点的最短路数量，并取模防止溢出。
- **数据结构**：使用邻接表存储图，能有效减少空间复杂度，同时方便遍历边。
- **算法选择**：对于无向无权图，BFS 可以作为一种稳定且高效的最短路算法，其时间复杂度为 $O(n)$；SPFA 和堆优化的 Dijkstra 也可用于解决该问题，但在某些情况下可能会被卡。

### 可拓展之处
- **同类型题**：对于有向图、带权图的最短路计数问题，可在上述算法基础上，根据边权的不同调整更新最短路和计数的逻辑。
- **类似算法套路**：在其他图论问题中，如拓扑排序、最小生成树等，也可在算法过程中添加额外的信息记录，以解决相关的计数或统计问题。

### 推荐题目
- [P1608 路径统计](https://www.luogu.com.cn/problem/P1608)：有向带权图的最短路计数问题。
- [P2136 拉近距离](https://www.luogu.com.cn/problem/P2136)：涉及最短路和路径选择的问题。
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：最短路算法的基础模板题。

### 个人心得摘录与总结
- **XZYQvQ**：发现很多人写的 SPFA 代码在本题能 AC，但在其他类似题目会出错，推测可能存在问题，但不清楚具体原因。总结：在使用算法时，要注意算法的适用范围，不能盲目套模板。
- **KesdiaelKen**：指出普通 SPFA 计数方式在边权不同时可能会出现重复计数的问题，并给出了调整后的计数方式。总结：对于不同的图结构和边权情况，需要对算法进行相应的调整和优化。
- **Utsuji_risshū**：提到本题中由于没有边权，SPFA 其实就是一个 BFS，和 Dijkstra 过程几乎一样，但 Dijkstra 要花时间处理优先队列，所以一般比 SPFA 慢。总结：在选择算法时，要考虑数据特点和算法复杂度，选择最适合的算法。 

---
处理用时：33.80秒
# 题目信息

# 佳佳的魔法药水

## 题目背景

发完了 $k$ 张照片，佳佳却得到了一个坏消息：他的 MM 得病了！佳佳和大家一样焦急万分！治好 MM 的病只有一种办法，那就是传说中的 $0$ 号药水…… 怎么样才能得到 $0$ 号药水呢？你要知道佳佳的家境也不是很好，成本得足够低才行……

## 题目描述

**存在 ab 相同 c 不同的情况，与题意相悖**。题还是可以做，但数据待修正。

得到一种药水有两种方法：可以按照魔法书上的指导自己配置，也可以到魔法商店里去买——那里对于每种药水都有供应，虽然有可能价格很贵。在魔法书上有很多这样的记载：

$1$ 份 A 药水混合 $1$ 份 B 药水就可以得到 $1$ 份 C 药水。（至于为什么 $1 + 1 = 1$，因为……这是魔法世界）好了，现在你知道了需要得到某种药水，还知道所有可能涉及到的药水的价格以及魔法书上所有的配置方法，现在要问的就是：

1. 最少花多少钱可以配制成功这种珍贵的药水；

2. 共有多少种不同的花费最少的方案（两种可行的配置方案如果有任何一个步骤不同则视为不同的）。假定初始时你手中并没有任何可以用的药水。


## 说明/提示

数据范围：

每一种药水的价格均 $\ge 1$ 且 $\le 2.8\times 10^4$。

样例说明：

最优方案有 $3$ 种，分别是：

- 直接买 $0$ 号药水；
- 买 $4$ 号药水、$5$ 号药水配制成 $1$ 号药水，直接买 $2$ 号药水，然后配制成 $0$ 号药水；
- 买 $4$ 号药水、$5$ 号药水配制成 $1$ 号药水，买 $3$ 号药水、$6$ 号药水配制成 $2$ 号药水，然后配制成 $0$ 号药水。

## 样例 #1

### 输入

```
7 
10 5 6 3 2 2 3 
1 2 0 
4 5 1 
3 6 2
```

### 输出

```
10 3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算配制特定药水的最小花费及方案数展开，多数采用 Dijkstra 算法，也有使用 SPFA 算法结合记忆化搜索的。各题解在思路上基本一致，但在实现细节和优化方式上有所不同。
- **思路**：将药水看作节点，药水合成关系看作边，通过不断更新节点的最小花费和方案数来求解。
- **算法要点**：
    - Dijkstra 算法：每次选择未确定最小花费的节点中花费最小的节点，用其更新与之相关的节点。
    - SPFA 算法：将所有节点入队，不断更新节点的最小花费，若节点花费变小则将其相关节点入队。
    - 记忆化搜索：用于计算最短路径的条数。
- **解决难点**：
    - 处理环形依赖：通过 Dijkstra 的贪心思想或 SPFA 的迭代求解来解决。
    - 计算方案数：根据不同情况更新方案数，如花费相等时累加，花费变小时更新。

### 所选题解
- **作者：半仙胡小桃（5星）**
    - **关键亮点**：思路清晰，代码简洁易懂，详细说明了方案数的更新情况。
    - **个人心得**：吐槽题目没有数据范围，导致 RE 一次。
    - **核心代码**：
```cpp
for(int i=1;i<n;i++)
{
    int maxn=0x7fffffff;
    for(int j=1;j<=n;j++)
        if(!f[j]&&cost[j]<maxn) 
            b=j,maxn=cost[j];
    f[b]=1;
    for(int j=1;j<=n;j++)
        if(f[j]&&soc[b][j])
        {
            if(cost[b]+cost[j]==cost[soc[b][j]])
                ans[soc[b][j]]+=ans[b]*ans[j];
            if(cost[b]+cost[j]<cost[soc[b][j]]) 
                cost[soc[b][j]]=cost[b]+cost[j],ans[soc[b][j]]=ans[b]*ans[j];
        }
}
```
核心思想：每次选择未确定最小花费的节点中花费最小的节点，标记为已确定，然后用其与已确定最小花费的节点更新合成药水的最小花费和方案数。

- **作者：Seg_Tree（5星）**
    - **关键亮点**：使用小根堆优化和链式前向星，提高了算法效率，详细说明了优化的注意事项。
    - **核心代码**：
```cpp
while(!q.empty()){
    int c=q.top().first,u=q.top().second;
    q.pop();
    if(c!=ptn[u].cst)continue;
    ptn[u].v=1;
    for(int i=head[u]; i; i=edg[i].nxt){
        int x=edg[i].u2,v=edg[i].v;
        if(ptn[x].v){
            if(ptn[v].cst>c+ptn[x].cst){
                ptn[v].ans=ptn[u].ans*ptn[x].ans;
                ptn[v].cst=c+ptn[x].cst;
                q.push(make_pair(ptn[v].cst,v));
            }
            else if(ptn[v].cst==c+ptn[x].cst){
                ptn[v].ans+=ptn[u].ans*ptn[x].ans;
            }
        }
    }
}
```
核心思想：使用小根堆存储节点，每次取出花费最小的节点，标记为已确定，然后用其与已确定最小花费的节点更新合成药水的最小花费和方案数。

- **作者：KKKZOZ（4星）**
    - **关键亮点**：从 DP 角度思考问题，采用 SPFA 算法结合记忆化搜索求解，提供了另一种解题思路。
    - **核心代码**：
```cpp
void spfa() {
    queue<int> q;
    for (int i = 0; i <= n - 1; i++) {
        q.push(i);
        f[i] = w[i];
        vis[i] = 1;
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for (int i = head[u]; i!= -1; i = e[i].next) {
            int a = e[i].a, b = e[i].b;
            if (f[u] > f[a] + f[b]) {
                f[u] = f[a] + f[b];
                for (auto v: belongs[u])
                    if (vis[v] == 0)
                        vis[v] = 1, q.push(v);
            }
        }
    }
}

int dfs(int u) {
    if (tot[u]!= 0) return tot[u];
    if (f[u] == w[u]) tot[u]++;
    for (int i = head[u]; i!= -1; i = e[i].next) {
        int a = e[i].a, b = e[i].b;
        if (f[u] == f[a] + f[b]) {
            tot[a] = dfs(a);
            tot[b] = dfs(b);
            tot[u] += tot[a] * tot[b];
        }
    }
    return tot[u];
}
```
核心思想：SPFA 算法不断更新节点的最小花费，若节点花费变小则将其相关节点入队；记忆化搜索用于计算最短路径的条数。

### 最优关键思路或技巧
- **Dijkstra 算法**：利用贪心思想，每次选择未确定最小花费的节点中花费最小的节点，确保节点的最小花费一旦确定就不会再改变。
- **小根堆优化**：使用小根堆存储节点，加快选择最小花费节点的速度。
- **链式前向星**：存储图的信息，节省空间，提高遍历效率。
- **记忆化搜索**：避免重复计算，提高计算最短路径条数的效率。

### 可拓展之处
同类型题或类似算法套路：
- 分层图问题：从 DP 角度看是二维 DP 问题，可参考[P4042](https://www.luogu.com.cn/problem/P4042)。
- 图的最短路问题：可使用 Dijkstra、SPFA 等算法求解。
- 动态规划问题：遇到环形依赖时，可采用 Dijkstra 的贪心思想或 SPFA 的迭代求解。

### 推荐题目
- [P1339 热浪](https://www.luogu.com.cn/problem/P1339)：考察 Dijkstra 算法求最短路。
- [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：考察 Dijkstra 算法和 SPFA 算法。
- [P4779 单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：考察 Dijkstra 算法的堆优化。

### 个人心得总结
- 半仙胡小桃：题目没有数据范围会导致 RE，做题时要注意数据范围。
- Seg_Tree：小根堆优化和链式前向星是 Dijkstra 算法的标配，可提高算法效率；注意题面中未提到的坑点，如两瓶相同的药可以混成一瓶新药。

---
处理用时：47.43秒
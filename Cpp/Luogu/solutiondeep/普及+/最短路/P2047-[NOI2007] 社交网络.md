# 题目信息

# [NOI2007] 社交网络

## 题目描述

在社交网络 ( Social Network ) 的研究中，我们常常使用图论概念去解释一些社会现象。不妨看这样的一个问题:   
在一个社交圈子里有 $n$ 个人，人与人之间有不同程度的关系。我们将这个关系网络对应到一个 $n$ 个结点的无向图上，两个不同的人若互相认识，则在他们对应的结点之间连接一条无向边，并附上一个正数权值 $c$ ，$c$ 越小，表示两个人之间的关系越密切。我们可以用对应结点之间的最短路长度来衡量两个人 $s$ 和 $t$ 之间的关系密切程度，注意到最短路径上的其他结点为 $s$ 和 $t$ 的联系提供了某种便利，即这些结点对于 $s$ 和 $t$ 之间的联系有一定的重要程度。我们可以通过统计经过一个结点 $v$ 的最短路径的数目来衡量该结点在社交网络中的重要程度。考虑到两个结点 $A$ 和 $B$ 之间可能会有多条最短路径。我们修改重要程度的定义如下：令 $C_{s,t}$ 表示从s到t的不同的最短路的数目，$C_{s,t}(v)$ 表示经过 $v$ 从 $s$ 到 $t$ 的最短路的数目；则定义：

$$ I(v)=\sum_{s \ne v,t\ne v} \frac{C_{s,t}(v)}{C_{s,t}}$$

为结点 $v$ 在社交网络中的重要程度。为了使 $I(v)$ 和 $C_{s,t}(v)$ 有意义，我们规定需要处理的社交网络都是连通的无向图，即任意两个结点之间都有一条有限长度的最短路径。现在给出这样一幅描述社交网络的加权无向图，请你求出每一个结点的重要程度。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/1136.png) 

对于1号结点而言，只有2号到4号结点和4号到2号结点的最短路经过1号结点，而2号结点和4号结点之间的最短路又有2条。因而根据定义，1号结点的重要程度计算为1/2+1/2=1。由于图的对称性，其他三个结点的重要程度也都是1。

对于 $50\%$ 的数据， $n \le 10 , m \le 45$。     
对于 $100\%$ 的数据， $n \le 100 , m \le 4500$ ，任意一条边的权值 $c$ 是正整数且 $1 \leqslant c \leqslant 1000$ 。    
所有数据中保证给出的无向图连通，且任意两个结点之间的最短路径数目不超过 $10^{10}$。     



## 样例 #1

### 输入

```
4 4
1 2 1
2 3 1
3 4 1
4 1 1```

### 输出

```
1.000
1.000
1.000
1.000```

# AI分析结果

### 综合分析与结论
这些题解主要围绕计算社交网络中各节点的重要程度展开，因数据范围小（\(n \le 100\)），多数题解采用 Floyd 算法求多源最短路，同时计算最短路的条数，再依据公式计算各节点的重要程度。部分题解使用 Dijkstra、SPFA 等算法。

### 所选题解
- **作者：Ning_Mew (赞：51)，5星**
    - **关键亮点**：思路清晰，步骤详细，对代码中关键部分有解释，提供了两种计算最短路条数的思路，并给出整体 AC 代码。
    - **个人心得**：提到用拓扑排序时要注意重边和入度为 0 才能入队列，否则会使条数计算错误，自己没改对该点只得了 60 分。
- **作者：Register (赞：12)，4星**
    - **关键亮点**：思路简洁明了，对 Floyd 算法中更新最短路条数的过程解释清晰，代码注释详细。
- **作者：人殇物已非 (赞：9)，4星**
    - **关键亮点**：指出数据类型要使用 long long，避免数据溢出，代码结构清晰。

### 重点代码及核心实现思想
#### 计算最短路及最短路条数（Floyd 算法）
```cpp
for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            if(dis[i][k]==INF&&dis[k][j]==INF)continue;
            if(dis[i][j]>dis[i][k]+dis[k][j])
            {
                dis[i][j]=dis[i][k]+dis[k][j];
                edge[i][j]=edge[i][k]*edge[k][j];
                continue;
            }
            if(dis[i][j]==dis[i][k]+dis[k][j])
            {edge[i][j]+=edge[i][k]*edge[k][j];}
        }
```
**核心思想**：在 Floyd 算法的基础上，当发现更短路径时，更新最短路径长度和路径条数；当路径长度相等时，累加路径条数。

#### 计算节点重要程度
```cpp
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=n;j++)
        for(int k=1;k<=n;k++)
        {
            if(i==j||j==k||i==k)continue;
            if(dis[j][i]+dis[i][k]==dis[j][k])
                ans[i]+=(1.0*edge[j][i]*edge[i][k])/edge[j][k];
        }
}
```
**核心思想**：枚举所有的起点 \(s\) 和终点 \(t\)，若 \(s\) 到 \(v\) 的最短距离加上 \(v\) 到 \(t\) 的最短距离等于 \(s\) 到 \(t\) 的最短距离，则 \(v\) 在 \(s\) 到 \(t\) 的最短路上，累加重要程度。

### 最优关键思路或技巧
- **Floyd 算法结合乘法原理**：在 Floyd 算法求最短路的同时，利用乘法原理计算最短路的条数，当发现更短路径时更新路径条数，当路径长度相等时累加路径条数。
- **数据类型使用 long long**：由于题目中最短路径数目可能较大，使用 long long 避免数据溢出。

### 可拓展之处
同类型题或类似算法套路：
- **多源最短路问题**：可使用 Floyd 算法解决，如计算图中任意两点间的最短距离。
- **路径计数问题**：在求最短路的过程中，结合乘法原理和加法原理计算路径的条数。

### 推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：涉及 Floyd 算法在动态图中的应用。
- [P2910 [USACO08OPEN]Clear And Present Danger S](https://www.luogu.com.cn/problem/P2910)：多源最短路问题，可使用 Floyd 算法解决。
- [P1346 电车](https://www.luogu.com.cn/problem/P1346)：图论问题，可使用最短路算法求解。

### 个人心得总结
- **Ning_Mew**：用拓扑排序时要注意重边和入度为 0 才能入队列，否则会使条数计算错误。
- **人殇物已非**：有些地方要使用 long long 数据类型，习惯用 int 开中间变量可能会导致错误。
- **xzyxzy**：由于代码中遗漏乘法运算而调试了半个小时，提醒在编写代码时要仔细检查。

---
处理用时：30.11秒
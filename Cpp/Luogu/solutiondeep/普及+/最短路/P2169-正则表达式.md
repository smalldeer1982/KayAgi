# 题目信息

# 正则表达式

## 题目背景

小Z童鞋一日意外的看到小X写了一个正则表达式的高级程序，这个正则表达式程序仅仅由字符“0”,“1”，“.”和“\*”构成，但是他能够匹配出所有在OJ上都AC的程序的核心代码！小Z大为颇感好奇，于是他决定入侵小X的电脑上去获得这个正则表达式的高级程序。


## 题目描述

在 Internet 网络中的每台电脑并不是直接一对一连通的，而是某些电脑之间存在单向的网络连接，也就是说存在 $A$ 到 $B$ 的连接不一定存在 $B$ 到 $A$ 的连接，并且有些连接传输速度很快，有些则很慢，所以不同连接传输所花的时间是有大有小的。另外，如果存在 $A$ 到 $B$ 的连接的同时也存在 $B$ 到 $A$ 的连接的话，那么 $A$ 和 $B$ 实际上处于同一局域网内，可以通过本地传输，这样花费的传输时间为 $0$。

现在小 Z 告诉你整个网络的构成情况，他希望知道从他的电脑（编号为 $1$），到小 X 的电脑（编号为 $n$）所需要的最短传输时间。

## 说明/提示

- 对于  $40\%$ 的数据，$1\leq n\leq 10^3$, $1\leq m\leq 10^4$；
- 对于  $70\%$ 的数据，$1\leq n\leq 5 \times 10^3$， $1\leq m\leq 10^5$；
- 对于  $100\%$ 的数据，$1\leq n\leq 2 \times 10^5$， $1\leq m\leq 10^6$。

保证答案在 `int` 范围内。

## 样例 #1

### 输入

```
3 2
1 2 1
2 3 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5
1 2 1
2 3 6
3 4 1
4 2 1
3 5 2
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
本题的核心在于求解带权有向图中从节点 1 到节点 n 的最短路，且同一强连通分量内节点间距离为 0。各题解普遍采用缩点 + 最短路的思路，先通过 Tarjan 或 Kosaraju 算法找出强连通分量进行缩点，将图转化为有向无环图（DAG），再运用 Dijkstra、SPFA 或拓扑排序等算法求解最短路。

### 高评分题解
- **作者：Diamiko（5 星）**
    - **关键亮点**：思路清晰，详细解释了缩点的原因和作用，代码注释丰富，易于理解。
    - **核心实现思想**：使用 Tarjan 算法缩点，将强连通分量视为一个点，再用 Dijkstra + 堆优化求最短路。
    - **核心代码片段**：
```cpp
void Tarjan(int u)
{
    s.push(u);
    node[u].dfn=node[u].low=++deep;
    node[u].vis=1;
    for(int e=node[u].head;e;e=edge[e].next)
    {
        int v=edge[e].to;
        if(!node[v].dfn)
        {
            Tarjan(v);
            node[u].low=min(node[u].low,node[v].low);
        }
        else
        {
            if(node[v].vis)
            {
                node[u].low=min(node[u].low,node[v].dfn);
            }
        }
    }
    if(node[u].dfn==node[u].low)
    {
        int tmp;
        color_cnt++;
        do
        {
            tmp=s.top();
            s.pop();
            node[tmp].color=color_cnt;
            node[tmp].vis=0;
        }while(tmp!=u);
    }
}
void Dijkstra()
{
    for(int i=1;i<=n;i++)
    {
        node[i].dis=INF;
    }
    int S=node[1].color;
    node[S].dis=0;
    priority_queue<pii,vector<pii>,greater<pii> >q;
    q.push({0,S});
    while(q.size())
    {
        pii tmp=q.top();
        q.pop();
        int d=tmp.first,u=tmp.second;
        if(d!=node[u].dis)continue;
        for(int e=node[u].head;e;e=edge[e].next)
        {
            int v=edge[e].to;
            if(node[v].dis>d+edge[e].len)
            {
                node[v].dis=d+edge[e].len;
                q.push({node[v].dis,v});
            }
        }
    }
}
```
- **作者：subarude（4 星）**
    - **关键亮点**：详细说明了缩点的原因和作用，代码结构清晰，采用拓扑排序求最短路。
    - **核心实现思想**：通过 Tarjan 算法缩点，将图转化为 DAG，再用拓扑排序求最短路。
    - **核心代码片段**：
```cpp
void Tarjan(int u) {
    dfn[u] = low[u] = ++Time;
    s[++r] = u; vis[u] = 1;
    int R = r;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (!dfn[v]) {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        num++;
        for (int i = R; i <= r; i++) {
            belong[s[i]] = num;
            vis[s[i]] = 0;
        }
        r = R - 1;
    }
}
void Topo(int s) {
    memset(dis, 0x3f, sizeof dis);
    queue<int> q;
    q.push(s);
    dis[s] = 0;
    for (; q.size(); ) {
        int u = q.front();
        q.pop();
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            dis[v] = min(dis[v], dis[u] + e[i].w);
            q.push(v);
        }
    }
}
```
- **作者：PrincessQi（4 星）**
    - **关键亮点**：思路简洁明了，代码实现简洁，采用 Dijkstra 堆优化求最短路。
    - **核心实现思想**：使用 Tarjan 算法缩点，再用 Dijkstra 堆优化求最短路。
    - **核心代码片段**：
```cpp
void tarjan(int x){
    dfn[x]=low[x]=++dd;
    s[++top]=x;
    ins[x]=1;
    for(int i=beg[x];i;i=nex[i]){
        int y=to[i];
        if(dfn[y]==0){
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(ins[y])
            low[x]=min(low[x],dfn[y]);
    }
    if(low[x]==dfn[x]){
        cnt++;
        do{
            k=s[top--];
            ins[k]=0;
            b[k]=cnt;
        }while(x!=k);
    }
}
while(!q.empty()){
    int x=q.top().second;
    q.pop();
    if(p[x])
        continue;
    p[x]=1;
    for(int i=beg[x];i;i=nex[i]){
        int y=to[i],z=w[i];
        if(d[y]>d[x]+z){
            d[y]=d[x]+z;
            q.push(make_pair(-d[y],y));
        }		
    }
}
```

### 最优关键思路或技巧
- **缩点思想**：将强连通分量视为一个点，将有向有环图转化为有向无环图（DAG），简化问题。
- **Tarjan 算法**：高效找出图中的强连通分量，时间复杂度为 $O(n + m)$。
- **堆优化 Dijkstra**：在求最短路时，使用优先队列优化 Dijkstra 算法，时间复杂度为 $O((n + m)logn)$。

### 拓展思路
同类型题或类似算法套路：
- 求解有向图中的最小环问题，可先缩点，再在 DAG 上求解。
- 求解有向图中的最长路问题，可先缩点，再在 DAG 上进行拓扑排序，然后进行动态规划求解。

### 推荐题目
- [P3387 缩点](https://www.luogu.org/problem/P3387)：缩点模板题，可用于练习 Tarjan 算法。
- [P4779 单源最短路径（标准版）](https://www.luogu.org/problem/P4779)：Dijkstra 算法模板题，可用于练习堆优化 Dijkstra 算法。
- [P1113 杂务](https://www.luogu.org/problem/P1113)：拓扑排序 + 动态规划题，可用于练习拓扑排序和动态规划。

### 个人心得摘录与总结
- **作者：睿屿青衫**：间谍网络 45 分卡了两个小时，本题一遍过，强调注意单向边和环的处理，使用 Tarjan 算法和 SPFA 模板求解。
- **作者：Kwork**：吐槽洛谷数据审核问题，自己用 Kosaraju 算法求解，认为该算法容易记忆。在调试过程中发现早期 AC 记录使用错误算法，手动构造数据卡掉该算法。 

---
处理用时：50.74秒
# 题目信息

# 金字塔

## 题目描述

有一盗墓者潜入一金字塔盗宝。当她（难道是 Lara Croft ?）打开一个宝箱的时候，突然冒出一阵烟（潘多拉的盒子？），她迅速意识到形势不妙，三十六计走为上计……由于她盗得了金字塔的地图，所以她希望能找出最佳逃跑路线。地图上标有 $N$ 个室，她现在就在 $1$ 室，金字塔的出口在 $N$ 室。她知道一个秘密：那阵烟会让她在直接连接某两个室之间的通道内的行走速度减半。她希望找出一条逃跑路线，使得在最坏的情况下所用的时间最少。

## 说明/提示

样例解释 Sample Explan：

基本上有三种路线：

（1）$1 \to 2 \to 3 \to 4 \to 7$。

总时间为：$10$ ＋ $12$ ＋ $20$ ＋ $8$ ＝ $50$，最坏的情况是“ $3 \to 4$ ”那一段，要多花 $20$ 秒（因为行走速度减半），所以这条路选最坏需要 $70$ 秒；

（2）$1 \to 2 \to 5 \to 6 \to 4 \to 7$。

总时间为：$10$ ＋ $10$ ＋ $12$ ＋ $13$ ＋ $8$ ＝ $53$，最坏的情况是“ $6 \to 4$ ”那一段，要多花 $13$ 秒，所以这条路选最坏需要 $66$ 秒；

（3）$1 \to 7$。

总时间为：$34$ ＝ $34$，最坏的情况是“ $1 \to 7$ ”那一段，要多花 $34$ 秒，所以这条路选最坏需要 $68$ 秒。

## 样例 #1

### 输入

```
7 8
1 2 10
2 3 12
3 4 20
4 7 8
1 7 34
2 5 10
5 6 12
6 4 13```

### 输出

```
66```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找金字塔中从起点到终点的特殊最短路问题展开，需考虑路径上最长边翻倍的情况。不同题解采用了多种算法，包括魔改的 Floyd、Dijkstra、DFS 和 SPFA 等。

### 所选题解
- **作者：Sata_moto（5星）**
    - **关键亮点**：思路清晰，详细展示了对 Floyd 算法的多次改进过程，逐步分析错误原因并给出解决方案，最终通过增加状态维度解决问题。
    - **个人心得**：最初尝试简单的 Floyd 算法无法通过样例，发现最短路径与最大权值不配套问题；改进后仍有错误，意识到结果不一定由最短路拼接而成，最终采用增加状态维度的方法。
    - **核心代码**：
```cpp
for(register int k = 1; k <= n; k++)
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            if(k!= i && i!= j && k!= j)
                for(int c = 0; c <= 260; c++)
                {
                    if(c!= 0) f[i][j][c] = min(f[i][j][c], f[i][j][c - 1]);
                    f[i][j][c] = min(f[i][j][c], f[i][k][c] + f[k][j][c]);
                }
```
核心思想：增加一维状态 `f(i,j,k)` 表示从 `i` 到 `j` ，路径上最长边长度小于等于 `k` 的最短路的长度，通过两层转移更新状态。

- **作者：大头冲锋车丶（4星）**
    - **关键亮点**：使用 Dijkstra 算法，通过维护 `pre[i]` 数组记录路径上的最大权值，思路简洁明了，代码可读性高。
    - **个人心得**：指出不能使用 `vis[]` 标记已处理节点，否则会导致答案出错，通过样例说明了原因。
    - **核心代码**：
```cpp
while(!q.empty())
{
    int u=q.top().to;
    ll t=dist[u];
    q.pop();
    for(int i=head[u];i;i=edge[i].next){
        int v=edge[i].to;
        if((dist[v]+pre[v]>t+edge[i].val+max(edge[i].val,pre[u]))){
            pre[v]=max(pre[u],edge[i].val);
            dist[v]=edge[i].val+t;
            q.push(Node(dist[v],v));
        }
    }
}
```
核心思想：在 Dijkstra 算法的基础上，更新 `dist` 数组时同时更新 `pre` 数组记录最大权值，保证结果的正确性。

- **作者：AlicX（4星）**
    - **关键亮点**：提出“限制”思路，枚举每条边作为最长边，每次跑 Dijkstra 算法，保证使用的边不大于该最长边，思路新颖。
    - **核心代码**：
```cpp
void dij(int p){
    priority_queue<pii> q;
    memset(st,false,sizeof st);
    memset(dis,0x3f,sizeof dis);
    int inf=dis[0];
    dis[1]=0,q.push({0,1});
    while(!q.empty()){
        int t=q.top().y;
        q.pop();
        if(st[t]) continue;
        st[t]=true;
        for(int i=h[t];i!=-1;i=tr[i].ne){
            int to=tr[i].to;
            if(dis[to]>dis[t]+tr[i].w&&tr[i].w<=p){
                dis[to]=dis[t]+tr[i].w;
                q.push({-dis[to],to});
            }
        }
    }
    if(dis[n]!=inf) ans=min(ans,dis[n]+p);
}
```
核心思想：在 Dijkstra 算法中增加对边权的限制，只使用不大于枚举的最长边的边，更新最短路径。

### 最优关键思路或技巧
- **增加状态维度**：如 Sata_moto 的题解，通过增加一维状态解决最短路径与最大权值不配套的问题。
- **维护额外信息**：大头冲锋车丶的题解中，使用 `pre[i]` 数组维护路径上的最大权值，保证结果的正确性。
- **枚举限制**：AlicX 的题解提出“限制”思路，枚举每条边作为最长边，简化问题。

### 可拓展之处
同类型题可能会有更多的限制条件，如多条边翻倍、不同类型的边有不同的影响等。可以采用类似的思路，增加状态维度或维护额外信息来解决。

### 推荐题目
1. [P1339 [USACO09OCT]Heat Wave G](https://www.luogu.com.cn/problem/P1339)：基础的最短路问题，可巩固最短路算法的使用。
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：标准的单源最短路径问题，可练习 Dijkstra 算法。
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：在最短路的基础上增加计数的要求，拓展最短路算法的应用。

---
处理用时：34.60秒
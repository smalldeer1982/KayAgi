# 题目信息

# 小A和uim之大逃离 II

## 题目背景

话说上回……还是参见 <https://www.luogu.com.cn/problem/P1373> 吧

小 a 和 uim 再次来到雨林中探险。突然一阵南风吹来，一片乌云从南部天边急涌过来，还伴着一道道闪电，一阵阵雷声。刹那间，狂风大作，乌云布满了天空，紧接着豆大的雨点从天空中打落下来，只见前方出现了一个牛头马面的怪物，低沉着声音说：“呵呵，既然你们来到这，两个都别活了！”。小 a 和他的小伙伴再次惊呆了！


## 题目描述

瞬间，地面上出现了一个 $H$ 行 $W$ 列的巨幅矩阵，矩阵的每个格子上要么是空地 `.` 或者障碍 `#`。

他们起点在 $(1,1)$，要逃往 $(H,W)$ 的出口。他们可以一次向上下左右移动一格，这个算一步操作。不过他们还保留着上次冒险时收集的魔液，一口气喝掉后可以瞬移到相对自己位置的 $(D,R)$ 向量；也就是说，原来的位置是 $(x,y)$，然后新的位置是 $(x+D,y+R)$，这个也算一步操作，不过他们仅能至多进行一次这种操作（当然可以不喝魔液）。

这个地方是个是非之地。所以他们希望知道最小能有几步操作可以离开这个鬼地方。不过他们可能逃不出这个鬼地方，遇到这种情况，只能等死，别无他法。


## 说明/提示

样例解释 $1$

$(1,1) \to (1,2)\to (1,3)\to$ 喝魔液 $\to (3,4)\to (3,5)\to (3,6)$。

样例解释 $2$

因为只有一瓶魔液所以他们没办法逃出来。

样例解释 $3$

$D$ 和 $R$ 还可以是 $0$或者负数。

数据范围与约定

$40\%$ 的测试数据 $2\leq H,W\leq 5$。

$70\%$ 的测试数据 $2\leq H,W\leq 100$。

$100\%$ 的测试数据 $2\leq H,W\leq 1000,|D|<H,|R|<W$。

## 样例 #1

### 输入

```
3 6 2 1
...#..
..##..
..#...```

### 输出

```
5
```

## 样例 #2

### 输入

```
3 7 2 1
..#..#.
.##.##.
.#..#..```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 6 -2 0
.#....
.#.#..
.####.
.#..#.
.##.#.
....#.```

### 输出

```
21```

# AI分析结果

### 综合分析与结论
本题的核心是在带有特殊移动规则（可使用一次魔液瞬移）的迷宫中求从起点到终点的最短路径，各题解大多采用广度优先搜索（BFS）算法，部分采用图论算法（如SPFA）。主要难点在于处理魔液的使用，确保只使用一次且能正确记录不同状态下的最短路径。

### 所选题解
- **作者：x_faraway_x (赞：19)，4星**
    - **关键亮点**：思路清晰，代码简洁，通过添加一维数组 `step[x][y][0/1]` 分别记录未喝药和已喝药状态下到达 `(x, y)` 的最少步数，很好地处理了魔液使用的限制。
    - **个人心得**：无

### 重点代码及核心实现思想
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int N=1005;
int h,w,d,r,st[N][N][2];
char s[N][N];
struct Point
{
    int x,y,u;
};
queue<Point> Q;
int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};
bool check(int x, int y)
{
    return x>=1&&y>=1&&x<=h&&y<=w&&s[x][y]=='.';
}
int main()
{
    scanf("%d%d%d%d",&h,&w,&d,&r);
    for(int i=1;i<=h;i++)
        scanf("%s",s[i]+1);
    memset(st,-1,sizeof(st));
    st[1][1][0]=0;
    Q.push((Point){1,1,0});
    while(!Q.empty()&&st[h][w][0]==-1&&st[h][w][1]==-1)
    {
        Point f=Q.front();
        Q.pop();
        for(int i=0;i<4;i++)
        {
            int x=dx[i]+f.x,y=dy[i]+f.y;
            if(check(x,y)&&st[x][y][f.u]==-1)
            {
                Q.push((Point){x,y,f.u});
                st[x][y][f.u]=st[f.x][f.y][f.u]+1;
                if(f.u==0&&check(x+d,y+r)&&st[x+d][y+r][1]==-1)
                {
                    Q.push((Point){x+d,y+r,1});
                    st[x+d][y+r][1]=st[x][y][0]+1;
                }
            }
        }
    }
    if(st[h][w][0]==-1&&st[h][w][1]==-1) puts("-1");
    else 
    printf("%d",min(st[h][w][0]==-1?1<<30:st[h][w][0],
                    st[h][w][1]==-1?1<<30:st[h][w][1]));
}
```
**核心实现思想**：
1. 定义 `st[x][y][0/1]` 数组，`st[x][y][0]` 表示走到 `(x, y)` 且没有喝药的最少步数，`st[x][y][1]` 表示走到 `(x, y)` 且已经喝药的最小步数。
2. 使用队列进行 BFS 搜索，每次取出队首元素，枚举上下左右的点，若该点可行且未被访问过，则更新步数并入队。
3. 若当前状态未喝药，还需考虑使用魔液瞬移的情况，更新瞬移后的状态并入队。
4. 最后比较未喝药和已喝药状态下到达终点的步数，取最小值输出，若都无法到达则输出 -1。

### 最优关键思路或技巧
- **状态记录**：使用三维数组记录不同状态（是否使用魔液）下到达每个点的最少步数，有效处理了魔液只能使用一次的限制。
- **BFS 算法**：利用 BFS 按层遍历的特性，保证第一次到达终点的路径即为最短路径。

### 可拓展之处
同类型题或类似算法套路：
- 带有特殊技能或道具的迷宫问题，如有限次飞行、传送等，可采用类似的状态记录方法。
- 多状态的最短路问题，如不同时间、不同能量状态下的路径规划，可通过增加状态维度来处理。

### 推荐题目
- P1135 奇怪的电梯：在电梯中可进行特定层数的跳跃，与本题的魔液瞬移类似。
- P1605 迷宫：经典的迷宫搜索问题，可作为基础练习。
- P2895 [USACO08FEB]Meteor Shower S：在地图上有陨石坠落，需在陨石到达前找到安全点，有时间状态的限制，可拓展状态记录的思路。

### 个人心得摘录与总结
- **maomao9173**：最初认为是 DP 问题，但发现 DP 会出现值更新不到的情况，无法进行状态转移，而 BFS 按层遍历，搜到的一定是最小值，不需要更新。总结：对于存在状态限制和路径搜索的问题，要谨慎选择算法，BFS 更适合求最短路径。
- **attack**：提到 `vis` 数组开小会 RE 第 2 个点，开大了会 RE 第 7 个点，比较莫名其妙。总结：在处理数组大小时要注意边界情况，避免因数组越界导致运行错误。
- **AuCloud**：指出 D 和 R 可能是负数，嗑药时要特判坐标是否小于零，出口可能是墙，且要注意数组大小。总结：在处理特殊规则和输入时，要考虑全面，避免遗漏边界情况。 

---
处理用时：37.91秒
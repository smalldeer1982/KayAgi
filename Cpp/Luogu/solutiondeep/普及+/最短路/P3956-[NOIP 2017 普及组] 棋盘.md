# 题目信息

# [NOIP 2017 普及组] 棋盘

## 题目背景

NOIP2017 普及组 T3

## 题目描述

有一个 $m \times m$ 的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。

任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、下、左、右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 $1 $ 个金币。

另外， 你可以花费 $2$ 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。

现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？


## 说明/提示

**样例 1 说明**

棋盘的颜色如下表格所示，其中空白的部分表示无色。

| $\color{red}\text{红}$ | $\color{red}\text{红}$ |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  | $\color{yellow}\text{黄}$ |  |  |  |
|  |  | $\color{yellow}\text{黄}$ | $\color{red}\text{红}$ |  |
|  |  |  | $\color{yellow}\text{黄}$ |  |
|  |  |  |  | $\color{red}\text{红}$ |


从 $(1,1)$ 开始，走到 $(1,2)$ 不花费金币。

从 $(1,2)$ 向下走到 $(2,2)$ 花费 $1$ 枚金币。

从 $(2,2)$ 施展魔法，将 $(2,3)$ 变为黄色，花费 $2$ 枚金币。

从 $(2,2)$ 走到 $(2,3)$ 不花费金币。

从 $(2,3)$ 走到 $(3,3)$ 不花费金币。

从 $(3,3)$ 走到 $(3,4)$ 花费 $1$ 枚金币。

从 $(3,4)$ 走到 $(4,4)$ 花费 $1$ 枚金币。

从 $(4,4)$ 施展魔法，将 $(4,5)$ 变为黄色，花费 $ 2$ 枚金币。

从 $(4,4)$ 走到 $(4,5)$ 不花费金币。

从 $(4,5)$ 走到 $(5,5)$ 花费 $1$ 枚金币。

共花费 $8 $ 枚金币。

**样例 2 说明**

棋盘的颜色如下表格所示，其中空白的部分表示无色。

| $\color{red}\text{红}$ | $\color{red}\text{红}$ |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  | $\color{yellow}\text{黄}$ |  |  |  |
|  |  | $\color{yellow}\text{黄}$ |  |  |
|  |  |  | $\color{white}\text{　}$ |  |
|  |  |  |  | $\color{red}\text{红}$ |

从 $( 1, 1)$ 走到 $( 1, 2)$，不花费金币。

从 $( 1, 2)$ 走到 $( 2, 2)$，花费 $ 1 $ 金币。

施展魔法将 $( 2, 3)$ 变为黄色，并从 $( 2, 2)$ 走到 $( 2, 3)$ 花费 $ 2$ 金币。

从 $( 2, 3)$ 走到 $( 3, 3)$ 不花费金币。

从 $( 3, 3)$ 只能施展魔法到达 $( 3, 2),( 2, 3),( 3, 4),( 4, 3)$。

而从以上四点均无法到达 $( 5, 5)$，故无法到达终点，输出$-1$。

**数据规模与约定**

对于 $30\%$ 的数据，$1 ≤ m ≤ 5, 1 ≤ n ≤ 10$。

对于 $60\%$ 的数据，$1 ≤ m ≤ 20, 1 ≤ n ≤ 200$。

对于 $100\%$ 的数据，$1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000$。


## 样例 #1

### 输入

```
5 7
1 1 0
1 2 0
2 2 1
3 3 1
3 4 0
4 4 1
5 5 0```

### 输出

```
8```

## 样例 #2

### 输入

```
5 5
1 1 0
1 2 0
2 2 1
3 3 1
5 5 0```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕棋盘行走求最小代价的问题展开，解题思路可分为搜索和最短路两类。搜索类包括 `DFS` 和 `BFS`，通过遍历所有可能路径找到最小代价；最短路类则将问题转化为图论问题，使用 `Dijkstra`、`SPFA` 等算法求解。各题解的核心在于处理魔法使用规则和颜色变化带来的代价，部分题解通过转化问题简化了处理过程。

### 所选题解
- **作者：ZigZagKmp（5星）**
    - **关键亮点**：思路清晰，详细分析题意并将其转化为经典走迷宫模型，提供 `BFS` + 优先队列优化和 `Dijkstra` 两种解法，代码注释详细，还给出卡掉 `dfs` + 记忆化优化的方法。
    - **个人心得**：作者分享了自己参加 `NOIP2017` 普及组比赛时该题的经历，当时最暴力的 `dfs` 都写不对，考后和同学想到代替魔法的算法。还提到 `CSP - S 2019` 时同学因不会开大栈空间丢分严重的情况。
- **作者：览遍千秋（4星）**
    - **关键亮点**：提出独特的魔法转换思路，将魔法本质转化为走到距离为两格的有色格子，通过 `dfs` 搜索并使用剪枝优化，代码实现较为清晰。
- **作者：dxzier（4星）**
    - **关键亮点**：建图思路清晰，考虑到稀疏矩阵存储优化空间复杂度，还介绍了特殊条件下的线性单源最短路算法，如 `0/1 BFS`、`1/2 BFS` 等，对不同边权情况进行了详细分析。

### 重点代码及核心思想
#### ZigZagKmp - BFS + 优先队列优化
```cpp
struct node{
    int x,y,c,w; 
    bool operator <(node b)const{
        return w>b.w;
    }
};
priority_queue<node>q;
int dx[]={0,1,0,-1,1,1,-1,-1,0,2,0,-2};
int dy[]={1,0,-1,0,1,-1,1,-1,2,0,-2,0};
int dw[]={0,0,0,0,2,2,2,2,2,2,2,2};
int a[105][105],dis[105][105];
void bfs(){
    memset(dis,0x3f,sizeof(dis));dis[1][1]=0;
    q.push((node){1,1,a[1][1],dis[1][1]});
    node cur,nxt;
    while(!q.empty()){
        cur=q.top();q.pop();
        if(dis[cur.x][cur.y]<cur.w)continue;
        for(int i=0;i<12;i++){
            nxt.x=cur.x+dx[i];
            nxt.y=cur.y+dy[i];
            nxt.w=cur.w+dw[i];
            if(nxt.x<=0||nxt.x>m||nxt.y<=0||nxt.y>m)continue;
            nxt.c=a[nxt.x][nxt.y];
            if(!nxt.c)continue;
            if(cur.c!=nxt.c)nxt.w++;
            if(dis[nxt.x][nxt.y]>nxt.w){
                dis[nxt.x][nxt.y]=nxt.w;
                q.push(nxt);
            }
        }
    }
}
```
**核心思想**：使用优先队列存储状态，每次取出代价最小的状态进行扩展，考虑 12 个方向的转移，更新最小代价。

#### 览遍千秋 - DFS 搜索
```cpp
#define maxm 107
int m,n,x,y,c,color[maxm][maxm],ans=0x7fffffff,opt[maxm][maxm];
bool vis[maxm][maxm];
void f(int x,int y,int q){
    if(opt[x][y]&&opt[x][y]<=q) return;
    opt[x][y]=q; 
    if(x==m&&y==m){
        ans=min(ans,q);
        return;
    }
    if(x==m-1&&y==m||x==m&&y==m-1&&!color[m][m])
    {
        ans=min(ans,q+2);
        return;
    }
    vis[x][y]=0;
    // 常规四个方向扩展
    if(vis[x][y-1]&&color[x][y-1]){
        if(color[x][y]==color[x][y-1]){
            f(x,y-1,q);
        }
        else{
            f(x,y-1,q+1);
        }
    }
    // 魔法转化的 8 个方向扩展
    if(vis[x+1][y+1]&&color[x+1][y+1]){
        if(color[x][y]==color[x+1][y+1]){
            f(x+1,y+1,q+2);
        }
        else{
            f(x+1,y+1,q+3);
        }
    }
    vis[x][y]=1;
}
```
**核心思想**：通过 `dfs` 搜索每个格子，可向周围 12 个方向拓展，使用 `opt` 数组进行剪枝，记录最小代价。

#### dxzier - 建图 + 多边权 BFS
```cpp
unordered_map<int,unordered_map<int,int>> M;
unordered_map<int,std::vector<edge>> v;
void add(int s1,int s2,int w0){
    int id1=s1>>1,c1=(s1&1);
    int id2=s2>>1,c2=(s2&1);
    if(!(s2==t&&t==0)){
        if(c1!=c2)
            w0++;
    }
    (v[id1]).push_back({id1,id2,w0});
    return;
}
void buildmap(){
    // 遍历所有有效点建图
    unordered_map<int,unordered_map<int,int>>::iterator it1=M.begin();
    while(it1!=M.end()){
        unordered_map<int,int>::iterator it2=(it1->second).begin();
        while(it2!=(it1->second).end()){
            int x=it1->first,y=it2->first;
            // 处理相邻和间隔一格的点的连边
            //...
            it2++;
        }
        it1++;
    }
    return;
}
std::vector<int> h;
std::queue<point> q[4];
point getq(){
    int j=-1;
    point ret={-1,2147483647};
    for(int i=0;i<=3;i++){
        if(!q[i].empty()){
            point f=q[i].front();
            if(f.W<ret.W){
                ret=f;
                j=i;
            }
        }
    }
    if(j==-1) return {-1,0};
    q[j].pop();
    return ret;
}
long long BFS(){
    long long ans=-1;
    q[0].push({s,0});
    while(1){
        point tp=getq();
        if(tp.id==t){
            ans=tp.W;
            break;
        }
        if(tp.id<0) break;
        if(h[tp.id]!=0) continue;
        h[tp.id]=1;
        unordered_map<int,std::vector<edge>>::iterator v0=v.find(tp.id);
        if(v0!=v.end()){
            for(int i=0;i<(v0->second).size();i++){
                edge tedge=(v0->second)[i];
                q[tedge.W].push({tedge.V,tp.W+tedge.W});
            }
        }
    }
    return ans;
}
```
**核心思想**：使用 `unordered_map` 存储有效点，对每个有效点建图，考虑相邻和间隔一格的点的连边，边权根据颜色和魔法使用情况确定。使用多个队列实现多边权 `BFS` 求解最短路。

### 最优关键思路或技巧
- **问题转化**：将魔法使用规则转化为特殊的移动方式，如 ZigZagKmp 和览遍千秋的题解，将魔法转化为走到距离为两格的有色格子，简化了搜索和建图的过程。
- **剪枝优化**：在搜索过程中使用记忆化数组记录最小代价，如览遍千秋的 `opt` 数组和 __galaxy_1202__ 的 `dict` 数组，避免重复搜索。
- **数据结构优化**：对于稀疏矩阵使用 `unordered_map` 存储，如 dxzier 的题解，降低空间复杂度。

### 可拓展之处
- **同类型题**：涉及多条件限制的路径搜索或最短路问题，如带有特殊道具使用规则、状态变化的迷宫问题。
- **类似算法套路**：分层图思想可用于解决多限制条件的最短路问题；特殊边权的最短路问题可使用相应的优化算法，如 `0/1 BFS`、`1/2 BFS` 等。

### 推荐题目
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：考察最短路算法和路径计数。
- [P1346 电车](https://www.luogu.com.cn/problem/P1346)：涉及图的构建和最短路求解。
- [P2850 [USACO06DEC]River Hopscotch S](https://www.luogu.com.cn/problem/P2850)：可使用二分查找和贪心思想解决，与路径选择和优化有关。

### 个人心得总结
- ZigZagKmp 分享了自己在比赛中的经历，包括 `NOIP2017` 普及组该题的失败和 `CSP - S 2019` 时同学因不会开大栈空间丢分的情况，提醒我们在比赛中要注意细节和调试技巧。
- __galaxy_1202__ 提到 `dict` 第一个点没初始化调了半天，强调了初始化的重要性。
- Night_sea_64 因没删调试输出爆零，提醒我们提交代码前要仔细检查。 

---
处理用时：68.51秒
# 题目信息

# 小明的游戏

## 题目描述

小明最近喜欢玩一个游戏。给定一个 $n \times m$ 的棋盘，上面有两种格子 `#` 和 `@`。游戏的规则很简单：给定一个起始位置和一个目标位置，小明每一步能向上，下，左，右四个方向移动一格。如果移动到同一类型的格子，则费用是 $0$，否则费用是 $1$。请编程计算从起始位置移动到目标位置的最小花费。

## 说明/提示

对于20%的数据满足：$1 \le n, m \le 10$。   
对于40%的数据满足：$1 \le n, m \le 300$。   
对于100%的数据满足：$1 \le n, m \le 500$。   

## 样例 #1

### 输入

```
2 2
@#
#@
0 0 1 1
2 2
@@
@#
0 1 1 0
0 0```

### 输出

```
2
0```

# AI分析结果

### 综合分析与结论
这些题解主要围绕最短路算法解决问题，涉及的算法有双端队列BFS（01BFS）、Dijkstra、SPFA等，还有通过联通块缩点简化问题的做法。不同算法在复杂度、实现难度和适用场景上各有特点。双端队列BFS在处理边权只有0和1的图时效率较高，复杂度为 $\Theta(nm)$；Dijkstra算法借助优先队列优化，适用于一般图的最短路问题；SPFA算法在某些情况下可能会超时，但在本题中可以通过。联通块缩点的方法将相同类型的格子合并为一个点，使图的结构更简单。

### 所选题解
- **作者：NaCly_Fish (赞：29)  ★★★★★**
    - **关键亮点**：详细介绍双端队列BFS的原理，思路清晰，代码注释详细，复杂度低，在构造数据和大数据量情况下比SPFA和Dijkstra都快。
- **作者：pipiispig (赞：11)  ★★★★**
    - **关键亮点**：简洁介绍01BFS的概念和应用，代码实现简单易懂。
- **作者：Eleven谦 (赞：9)  ★★★★**
    - **关键亮点**：提供二维最短路和常规最短路两种做法，对二维最短路实现中遇到的问题进行详细说明，有助于理解和掌握不同的实现方式。

### 重点代码与核心实现思想
#### 双端队列BFS（NaCly_Fish）
```cpp
void bfs(){
    int x,y,nx,ny,w;
    memset(d,inf,sizeof(d));
    memset(vis,0,sizeof(vis));
    d[x1][y1] = 0;
    deque<node> q; //新建一只双端队列
    q.push_back(node(x1,y1));
    while(!q.empty()){
        x = q.front().x;
        y = q.front().y;
        q.pop_front();
        if(vis[x][y]) continue; //由于是bfs,所以要判断有没有来过,来过了就不用再来了
        vis[x][y] = true;
        for(int i=0;i<4;++i){ //遍历周围格子
            nx = x+dx[i];
            ny = y+dy[i];
            if(nx>n||nx<1||ny>m||ny<1) continue; //判断是否越界
            w = a[nx][ny]!=a[x][y]; //确定边权,一样为1,不一样为0
            if(d[x][y]+w>=d[nx][ny]) continue; //松弛操作
            d[nx][ny] = d[x][y]+w;
            if(w==0) q.push_front(node(nx,ny)); //0权放前面
            else q.push_back(node(nx,ny)); //1权放后面
        }
    }
}
```
**核心思想**：利用双端队列，将边权为0的点插入队头，边权为1的点插入队尾，保证队列中距离小的点在前面，减少不必要的比较，提高效率。

#### 01BFS（pipiispig）
```cpp
while(!q.empty())
{
    node w=q.front();q.pop_front();//是pop_front()!!!不是pop_back()；
    if(w.x==x2&&w.y==y2)
    {
        cout<<w.z<<endl;
        break;
    }
    for(int i=0;i<4;i++)
    {
        int xx=w.x+dx[i];
        int yy=w.y+dy[i];
        if(xx>n||yy>m||xx<1||yy<1||vis[xx][yy])continue;
        vis[xx][yy]=1;
        if(s[xx][yy]==w.c)q.push_front((node){xx,yy,w.z,w.c});//根据边权的值分开判断呀
        else q.push_back((node){xx,yy,w.z+1,s[xx][yy]});//与上一句一样的废话QwQ;
    }
}
```
**核心思想**：同样基于双端队列，根据边权将节点插入队头或队尾，直到找到目标节点。

#### 二维最短路（Eleven谦）
```cpp
struct node {
    int val,tx,ty,net;   //val是花费，tx是下一个点的横坐标，ty是纵坐标
    bool operator < (const node &x )const {  //重载运算符
        return val>x.val;
    }
} e[5200010];

priority_queue<node> q;

inline void add(int fx,int fy,int nx,int ny,int w) {  //连边 
    e[++tot].tx=nx;
    e[tot].ty=ny;
    e[tot].val=w;
    e[tot].net=head[fx][fy];
    head[fx][fy]=tot;
}

inline void dijkstra(int fx,int fy) {
    for(register int i=1;i<=n;i++) {
        for(register int j=1;j<=m;j++) {
            vis[i][j]=0;
            dis[i][j]=20050206;
        }
    }
    dis[fx][fy]=0;
    q.push((node) {
        0,fx,fy
    });
    while(!q.empty()) {
        int x=q.top().tx;
        int y=q.top().ty;
        q.pop();
        if(vis[x][y]) continue;
        vis[x][y]=1;
        for(register int i=head[x][y];i;i=e[i].net) {
            int vx=e[i].tx;
            int vy=e[i].ty;
            if(dis[vx][vy]>dis[x][y]+e[i].val) {
                dis[vx][vy]=dis[x][y]+e[i].val;
                q.push((node) {
                    dis[vx][vy],vx,vy  //这里dis[]就不用取反啦 
                });
            }
        }
    }
}
```
**核心思想**：使用优先队列优化的Dijkstra算法，通过重载运算符对二维节点进行排序，实现二维最短路的求解。

### 最优关键思路或技巧
- **双端队列BFS（01BFS）**：对于边权只有0和1的图，利用双端队列的特性，将边权为0的节点插入队头，边权为1的节点插入队尾，避免使用堆优化的 $\Theta(\log n)$ 复杂度，将复杂度降低到 $\Theta(1)$。
- **联通块缩点**：将相同类型的格子合并为一个点，减少图的节点数量，简化图的结构，使问题更易于处理。
- **坐标转换**：将二维坐标转换为一维编号，将二维最短路问题转换为常规最短路问题，方便使用传统的最短路算法。

### 可拓展之处
同类型题或类似算法套路：
- **边权只有0和1的最短路问题**：可以使用双端队列BFS（01BFS）高效解决，如 [BalticOI 2011 Day1] Switch the Lamp On（P4667）。
- **联通块问题**：可以通过缩点的方法简化问题，将相同属性的节点合并为一个点，再进行图的操作。
- **最短路问题的优化**：根据图的特点选择合适的最短路算法，如Dijkstra、SPFA等，并结合优先队列、双端队列等数据结构进行优化。

### 推荐题目
- [P4667 [BalticOI 2011 Day1] Switch the Lamp On](https://www.luogu.org/problem/P4667)：边权只有0和1的最短路问题，可使用双端队列BFS解决。
- [P4473 飞飞侠](https://www.luogu.org/problem/P4473)：最短路问题，需要根据题目特点选择合适的算法和优化方法。
- [SPOJ KATHTHI - KATHTHI](https://www.spoj.com/problems/KATHTHI/)：与本题类似的最短路问题，可使用01BFS或其他最短路算法解决。

### 个人心得摘录与总结
- **LitShone**：debug一个小时后终于AC，提醒要注意题目中坐标从0开始的细节，以及变量名冲突的问题（y1不能用）。总结：做题时要仔细阅读题目，注意细节，避免因小错误导致调试时间过长。
- **Eleven谦**：二维实现最短路遇到建图连边方向和Dijkstra优先队列对二维最短路存储和排序的问题。总结：在实现复杂算法时，要理清思路，注意细节，对于不熟悉的部分要深入研究。
- **zhengrunzhe**：刚开始没有清零head数组一直出错。总结：在多组数据的题目中，要注意数组的初始化，避免数据残留导致错误。

---
处理用时：61.79秒
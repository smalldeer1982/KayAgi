# 题目信息

# [JLOI2011] 飞行路线

## 题目描述

Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。

Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？

## 说明/提示

#### 数据规模与约定

对于 $30\%$ 的数据，$2 \le n \le 50$，$1 \le m \le 300$，$k=0$。

对于 $50\%$ 的数据，$2 \le n \le 600$，$1 \le m \le 6\times10^3$，$0 \le k \le 1$。

对于 $100\%$ 的数据，$2 \le n \le 10^4$，$1 \le m \le 5\times 10^4$，$0 \le k \le 10$，$0\le s,t,a,b < n$，$a\ne b$，$0\le c\le 10^3$。

另外存在一组 hack 数据。

## 样例 #1

### 输入

```
5 6 1
0 4
0 1 5
1 2 5
2 3 5
3 4 5
2 3 3
0 2 100```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解主要围绕分层图最短路的思路来解决问题，将原问题转化为分层图模型，通过建图和跑最短路算法（如 Dijkstra、SPFA 等）来找到最少花费。各题解的主要区别在于建图方式、最短路算法的选择以及代码实现细节。部分题解使用了二维数组来记录状态，部分则通过实际建多层图来处理。整体来看，分层图的思想是解决本题的关键，不同的实现方式在时间复杂度和空间复杂度上可能会有细微差异，但核心思路一致。

### 所选题解
- **作者：SuperJvRuo（5星）**
    - **关键亮点**：思路清晰，通过分层图的方式将问题转化为普通最短路问题，代码实现规范，使用了堆优化的 Dijkstra 算法，注释详细，易于理解。
    - **个人心得**：无

### 重点代码
```cpp
// 建边函数
void add_edge(int u,int v,int c=0)
{
    edge[++cnt]=(Edge){v,head[u],c};
    head[u]=cnt;
}

// Dijkstra 算法
void Dijkstra(int s)
{
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > points;
    points.push(make_pair(0,s));
    while(!points.empty())
    {
        int u=points.top().second;
        points.pop();
        if(!vis[u])
        {
            vis[u]=1;
            for(int i=head[u];i;i=edge[i].next)
            {
                int to=edge[i].to;
                if(dis[to]>dis[u]+edge[i].cost) 
                {
                    dis[to]=dis[u]+edge[i].cost;
                    points.push(make_pair(dis[to],to));
                }
            }
        }
    }
}

// 主函数
int main()
{
    int n=Read(),m=Read(),k=Read(),s=Read(),t=Read();
    int u,v,c;
    for(int i=0;i<m;++i)
    {
        u=Read(),v=Read(),c=Read();
        add_edge(u,v,c);
        add_edge(v,u,c);
        for(int j=1;j<=k;++j)
        {
            add_edge(u+(j-1)*n,v+j*n);
            add_edge(v+(j-1)*n,u+j*n);
            add_edge(u+j*n,v+j*n,c);
            add_edge(v+j*n,u+j*n,c);
        }
    }
    for(int i=1;i<=k;++i)
    {
        add_edge(t+(i-1)*n,t+i*n);
    }
    Dijkstra(s);
    printf("%d",dis[t+k*n]);
    return 0;
}
```
**核心实现思想**：首先通过 `add_edge` 函数进行建图，将原问题转化为分层图。每层内部正常连边，层与层之间从上到下连权值为 0 的边，表示使用一次免费机会。然后使用 `Dijkstra` 函数进行最短路计算，使用优先队列优化，最后输出从起点到终点在第 `k` 层的最短距离。

### 最优关键思路或技巧
- **分层图思想**：将原问题转化为分层图模型，通过建多层图和层间连边来处理免费乘坐的情况，将有条件的最短路问题转化为普通最短路问题。
- **状态记录**：使用二维数组 `dis[i][j]` 记录到达节点 `i` 使用 `j` 次免费机会的最短路径，方便状态转移和更新。
- **堆优化 Dijkstra**：使用优先队列优化 Dijkstra 算法，将时间复杂度从 $O(V^2)$ 优化到 $O((

---
处理用时：30.18秒
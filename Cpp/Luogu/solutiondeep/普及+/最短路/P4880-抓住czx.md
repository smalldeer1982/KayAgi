# 题目信息

# 抓住czx

## 题目背景

蒟蒻 lty 出了一道题，但是由于太弱了，所以希望喜欢鸽子的 czx 来帮他写一个 std 。由于 czx 又放鸽子去了，所以没有写 std。蒟蒻 lty 觉得受到了学长的鄙视，所以决定去 czx 放鸽子的地方找他。

## 题目描述

 czx 放鸽子的地方是一个公园，公园珂以看作是由 $n$ 个点 $m$ 条边组成的无向图(保证无自环）， lty 将从公园的入口（ $b$ 号节点）进去寻找 czx ， czx 刚开始的位置为 $e$ ，而 czx 会在 $a_i$ 个单位时间时变化位置到第 $x$ 个节点去，在此之前 lty 已经知道了 czx 的具体位置和接下来他位置的变化方案，蒟蒻 lty 现在想知道他至少需要花多少时间找到 czx 。

UPD:

保证图联通， czx 最后会待在一个地方不动

## 说明/提示

**样例解释：**

在开始的时候就直接走到 $2$ 号节点，然后等到 czx过来。总花费时间 $9$ 个单位时间。

对于 30% 的数据，$n\le 100,m\le 1000,T\le 100$

对于另外 30% 的数据，$T=0$

对于 100% 的数据，$n \le 10^5,m \le 5\times10^5,T \le 10^5$

数据保证所有时间在 int 范围内

注意：在任意一个 czx 开始移动的时间点，都是 czx 先瞬移，然后 lty 再行走，也就是说， lty 不能在 czx 瞬移的时候到他瞬移前的点抓住他，但是 lty 可以在他瞬移到的点等着抓他。

## 样例 #1

### 输入

```
6 9 1 6
1 2 1
1 3 3
1 4 4
2 3 2
3 6 6
4 5 6
2 5 9
3 5 7
5 6 2
3
10 3
8 5
9 2```

### 输出

```
9```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先通过单源最短路算法（Dijkstra 或 SPFA）计算出从起点到各个点的最短时间，再对 czx 的瞬移时间和位置进行排序，然后根据不同情况判断 lty 抓住 czx 的最短时间。各题解的差异主要体现在使用的最短路算法、代码实现细节和处理特殊情况的方式上。

### 所选题解
- **作者：Eleven谦 (赞：5)，4星**
    - **关键亮点**：思路清晰，对不同情况的分析详细，代码注释丰富，可读性高。
    - **个人心得**：作者分享了自己的调试经历，从最初只得到 30 分，到卡在 90 分，最后在同桌帮助下意识到缺少一种情况，还因手贱多写一个“=”导致反复出错，最终才艰难 A 掉题目，提醒大家注意细节。
- **作者：Wolfycz (赞：4)，4星**
    - **关键亮点**：使用 SPFA 算法，代码简洁，对题目理解准确，直接指出题目没卡 SPFA。
- **作者：Tiffany_Tendering (赞：3)，4星**
    - **关键亮点**：在 SPFA 基础上进行小操作，思路独特，对 czx 所在位置的起始时间和终止时间进行记录和判断。

### 重点代码及核心实现思想
#### Eleven谦的题解
```cpp
// Dijkstra求最短路
inline void dijkstra(int s) { 
    for(register int i=1;i<=n;i++) {
        vis[i]=0;
        dis[i]=2005020600;
    }
    dis[s]=0;
    q.push(make_pair(0,s));
    while(!q.empty()) {
        int x=q.top().second;
        q.pop();
        if(vis[x]) continue;
        vis[x]=1;
        for(register int i=head[x];i;i=e[i].net) {
            int v=e[i].to;
            if(dis[v]>dis[x]+e[i].val) {
                dis[v]=dis[x]+e[i].val;
                q.push(make_pair(-dis[v],v));
            }
        }
    }
}

// 主函数中判断部分
if(dis[E]<a[1].t||t==0) {  //不用管瞬移的两种情况 
    printf("%d",dis[E]);
    return 0;
}
for(register int i=1;i<=t;i++) {  //枚举瞬移找答案 
    if(dis[a[i].p]<=a[i].t) {  //守株待兔或正好抓住的情况 
        printf("%d",a[i].t);
        return 0;
    }
    else {
        if(dis[a[i].p]<a[i+1].t) {  //在下一次瞬移前抓住的情况 
            printf("%d",dis[a[i].p]);
            return 0;
        }
    }
}
```
**核心思想**：先通过 Dijkstra 算法求出从起点到各点的最短时间，再根据 czx 的瞬移情况进行判断，分不用考虑瞬移、守株待兔或正好抓住、在下一次瞬移前抓住三种情况。

#### Wolfycz 的题解
```cpp
// SPFA算法
void SPFA(int x){
    int head=0,tail=1;
    memset(deep,63,sizeof(deep));
    h[1]=x,vis[x]=1,deep[x]=0;
    while (head!=tail){
        if (++head>N)	head=1;
        int Now=h[head];
        for (int p=now[Now],son=child[p];p;p=pre[p],son=child[p]){
            if (deep[son]>deep[Now]+val[p]){
                deep[son]=deep[Now]+val[p];
                if (!vis[son]){
                    if (++tail>N)	tail=1;
                    vis[h[tail]=son]=1;
                }
            }
        }
        vis[Now]=0;
    }
}

// 主函数中判断部分
sort(A,A+1+T);
for (int i=0;i<=T;i++){
    if (deep[A[i].x]<A[i+1].T){
        printf("%d\n",max(deep[A[i].x],A[i].T));
        break;
    }
}
```
**核心思想**：使用 SPFA 算法求出最短路，对 czx 的瞬移时间排序后，判断 lty 到达时间是否小于 czx 下一次瞬移时间，若是则输出较大时间。

#### Tiffany_Tendering 的题解
```cpp
// SPFA算法
void spfa(int s) {
    queue< int >q ;
    for(int i = 1;i <= n ;++i) dis[i] = 1e9,vis[i] = 0 ;
    dis[s] = 0;
    q.push(s) ; vis[s] = 1;
    while(!q.empty()) {
        int u = q.front() ;
        q.pop() ;
        vis[u] = 0;
        for(int i = head[u]; i ;i = e[i].next) 
            if(dis[e[i].to] > dis[u] + e[i].value) {
                dis[e[i].to] = dis[u] + e[i].value;
                if(!vis[e[i].to]) {q.push(e[i].to) ; vis[e[i].to] = 1;}
            }
    }
}

// 主函数中判断部分
sort(t + 1,t + tttt + 1, cmp) ;
for(int i = 2;i <= tttt; ++i) 
    t[i - 1].timen = t[i].timst - 1; //更新终止时间 
t[tttt].timen = 1e9; //czx在最后一个点不动 所以终止时间无限大 
for(int i = 1;i <= tttt ;++i) 
    if(dis[t[i].node] <= t[i].timen) {printf("%d\n",max(dis[t[i].node], t[i].timst) ) ;return 0;} //取max输入 直接return即可 
```
**核心思想**：用 SPFA 预处理最短路，对 czx 的瞬移时间排序并记录每个位置的起始和终止时间，若 lty 到达时间小于等于终止时间，则输出较大时间。

### 最优关键思路或技巧
- **排序处理**：将 czx 的瞬移时间按从小到大排序，方便后续判断。
- **最短路算法**：使用 Dijkstra 或 SPFA 算法计算从起点到各点的最短时间。
- **分类讨论**：根据不同情况（不用考虑瞬移、守株待兔、在下一次瞬移前抓住等）进行分类判断。

### 可拓展之处
同类型题或类似算法套路：
- 带有时间限制的路径规划问题，如在规定时间内到达目标点，且目标点会移动。
- 动态图的最短路问题，图的边权或结构会随时间变化。

### 推荐题目
- P3371 【模板】单源最短路径（弱化版）
- P4779 【模板】单源最短路径（标准版）
- P1144 最短路计数

---
处理用时：48.65秒
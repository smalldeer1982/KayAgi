# 题目信息

# 密室

## 题目背景

NOIP2018 原创模拟题 T2

NOIP DAY1 T2 or DAY2 T2 难度

题目背景改编自小说《哈利波特与密室》。

## 题目描述

**密室被打开了。**

哈利与罗恩进入了密室，他们发现密室由n个小室组成，所有小室编号分别为：$1,2,...,n$ 。所有小室之间有 $m$ 条通道，对任意两个不同小室最多只有一条通道连接，而每通过一条通道都需要 $C_i$ 的时间。

开始时哈利与罗恩都在编号为 $1$ 的小室里，他们的目标是拯救金妮和寻找日记，但是他们发现金妮和日记可能在两个不同的小室里，为了尽快发现真相，他们决定以最少的时间到达两个目标小室。但是某些小室只有会与蛇对话的人才能进入，也就是只有哈利一个人可以进入。

现在，哈利告诉你密室的结构，请你计算他们到达两个目标小室的最短时间。

## 说明/提示

**样例解释：**

**样例一：**

哈利：$1->5->6$ 花费时间为 $5$

罗恩：$1->3->4$ 花费时间为 $5$

所以最短时间为 $5$

**样例二：**

![图1](https://cdn.luogu.com.cn/upload/pic/31438.png)

如图，橙色表示目标小室，绿色只有哈利可以通过

哈利：$1->2->3->4->6$ 花费时间为 $9$

罗恩：$1->9->8$ 花费时间为 $16$

所以最短时间为 $16$

**数据范围：**

$10\%$ 数据满足：$n\leq 5$

$30\%$ 数据满足：$n\leq 20$

$50\%$ 数据满足：$n\leq 1000$

$70\%$ 数据满足：$n\leq 10000$

$100\%$数据满足：$n\leq 50000$ ; $a,b,k\leq n$ ;  $c\leq 1000$ ; $m\leq 100000$，保证罗恩可以在密室 $1$

**特殊约定：**

$30\%$ 数据满足：$k=0$

## 样例 #1

### 输入

```
6 8 1
5
1 2 3
2 3 2
1 3 4
3 4 1
4 6 5
5 6 2
1 6 6
1 5 3
4 6```

### 输出

```
5```

## 样例 #2

### 输入

```
10 13 3
3 4 10
1 2 1
2 3 2
3 4 3
4 5 4
5 6 5
6 7 10
7 8 5
8 9 10
9 10 3
10 1 2
1 9 6
3 8 10
4 6 3
6 8```

### 输出

```
16```

# AI分析结果

### 综合分析与结论
这些题解主要围绕密室问题，通过不同的最短路算法（如SPFA、Dijkstra）来解决。思路上，大家普遍将情况分为两人分别前往不同目标和一人前往两个目标这几类，通过多次跑最短路算法来计算各种情况的时间，最后取最小值得到结果。

### 所选题解
- 作者：丨Sky灬丨无惧，5星
    - 关键亮点：思路清晰，详细列举了四种走法，代码注释丰富，使用链式前向星存储图，同时对多次SPFA的情况进行了合理处理，减少不必要的计算。
    - 个人心得：无
- 作者：MZ_CXQ，4星
    - 关键亮点：准确分析出四种情况，仅跑三次Dijkstra就解决问题，代码结构清晰，使用模板函数进行输入输出处理，提高代码复用性。
    - 个人心得：无
- 作者：xcyy，4星
    - 关键亮点：思路简单明了，对两种最短路的区别解释清晰，同时提到了初始化值的坑点，有一定的参考价值。
    - 个人心得：“另外还有一个坑点，我一开始初始化给inf的值是0x7f就只有90分，但改成了0x3f3f3f3f就过了，目前还不是很明白为什么，但网上有个ACM的朋友和我这么说的”。总结：初始化值的选择可能会影响代码的正确性，要谨慎选择合适的初始化值。

### 重点代码及核心实现思想
#### 丨Sky灬丨无惧
```cpp
// 链式前向星添加边
void ctt(int u,int v,int w) {
    a[++k].u=u;
    a[k].v=v;
    a[k].w=w;
    a[k].next=b[u];
    b[u]=k;
    return;
}
// SPFA算法
void SPFA() {
    for(int i=1; i<=n; i++)ans[i]=1e9;
    r=0;
    l=1;
    memset(c,0,sizeof(c));
    if(check!=2) {
        q[++r]=1;
        ans[1]=0;
    }
    else {
        q[++r]=x;
        ans[x]=0;
    }
    while(l<=r) {
        int u=q[l++];
        c[u]=0;
        if(!check&&vis[u])continue;
        for(int i=b[u]; i; i=a[i].next) {
            int v=a[i].v;
            if(ans[v]>ans[u]+a[i].w) {
                ans[v]=ans[u]+a[i].w;
                if(c[v]==0) {
                    c[v]=1;
                    q[++r]=v;
                }
            }
        }
    }
}
```
核心思想：使用链式前向星存储图，通过SPFA算法计算不同情况下的最短路径。根据`check`的值判断是两人一起行动还是哈利单独行动，同时在罗恩行动时跳过有蛇的房间。

#### MZ_CXQ
```cpp
// Dijkstra算法
void dijkstra(int p,int s) {
    priority_queue <node> q;
    memset(dis,0x3f,sizeof(dis)); 
    memset(vis,0,sizeof(vis));
    q.push(node(s,0)); dis[s] = 0;
    while(!q.empty()) {
        node _u = q.top(); q.pop();
        int u = _u.pos; 
        if(vis[u]) continue; vis[u] = 1;
        for(int i = head[u]; i;i = e[i].nxt) {
            int v = e[i].v; if(p == 2 && h[v]) continue; 
            if(dis[v] > dis[u]+e[i].w) {
                dis[v] = dis[u]+e[i].w;
                q.push(node(v,dis[v]));
            }
        }
    }
}
```
核心思想：使用优先队列优化的Dijkstra算法，根据参数`p`判断是哈利还是罗恩行动，若为罗恩则跳过只有哈利能去的房间。

#### xcyy
```cpp
// 罗恩的SPFA算法
inline void spfa1(int x) {
    memset(dis1,inf,sizeof(dis1));
    memset(vis,0,sizeof(vis));
    vis[x]=1;
    dis1[x]=0;
    queue<int> q;
    q.push(x);
    while(q.size()) {
        int u=q.front();
        vis[u]=0;
        q.pop();
        for(int i=head[u];i;i=nxt[i]) {
            int v=to[i];int w=val[i];
            if(dis1[v]>dis1[u]+w&&!nb[v]) {
                dis1[v]=dis1[u]+w;
                if(!vis[v]) 
                    vis[v]=1,q.push(v);
            }
        }
    }
}
// 哈利的SPFA算法
inline void spfa2(int x) {
    queue<int> q;
    memset(dis2,inf,sizeof(dis2));
    memset(vis,0,sizeof(vis));
    q.push(x);
    dis2[x]=0;
    vis[x]=1;
    while(q.size()) {
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=head[u];i;i=nxt[i]) {
            int v=to[i];int w=val[i];
            if(dis2[v]>dis2[u]+w) {
                dis2[v]=dis2[u]+w;
                if(!vis[v])
                    vis[v]=1,q.push(v);
            }
        }
    }
}
```
核心思想：分别实现罗恩和哈利的SPFA算法，罗恩的算法中需要判断房间是否只有哈利能去，哈利则无此限制。

### 最优关键思路或技巧
- **情况分析**：将所有可能的走法进行分类讨论，清晰地列出不同情况，避免遗漏。
- **减少计算次数**：如部分题解通过合理分析，减少不必要的最短路计算，提高效率。
- **数据结构选择**：使用链式前向星或邻接表存储图，适合处理稀疏图，减少空间复杂度。

### 可拓展之处
同类型题如多源最短路问题，可使用Floyd算法；或者在图中加入更多限制条件，如时间窗口、资源消耗等。类似算法套路可用于解决物流配送、路径规划等实际问题。

### 推荐题目
- P3371 【模板】单源最短路径（弱化版）
- P4779 【模板】单源最短路径（标准版）
- P1144 最短路计数

---
处理用时：42.67秒
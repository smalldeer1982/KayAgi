# 题目信息

# [CSP-J2019] 加工零件

## 题目描述

凯凯的工厂正在有条不紊地生产一种神奇的零件，神奇的零件的生产过程自然也很神奇。工厂里有 $n$ 位工人，工人们从 $1 \sim n$ 编号。某些工人之间存在双向的零件传送带。保证每两名工人之间最多只存在一条传送带。

如果 $x$ 号工人想生产一个被加工到第 $L\,(L \gt 1)$ 阶段的零件，则**所有**与 $x$ 号工人有传送带**直接**相连的工人，都需要生产一个被加工到第 $L - 1$ 阶段的零件（但 $x$ 号工人自己**无需**生产第 $L - 1$ 阶段的零件）。

如果 $x$ 号工人想生产一个被加工到第 $1$ 阶段的零件，则**所有**与 $x$ 号工人有传送带**直接**相连的工人，都需要为 $x$ 号工人提供一个原材料。

轩轩是 $1$ 号工人。现在给出 $q$ 张工单，第 $i$ 张工单表示编号为 $a_i$ 的工人想生产一个第 $L_i$ 阶段的零件。轩轩想知道对于每张工单，他是否需要给别人提供原材料。他知道聪明的你一定可以帮他计算出来！

## 说明/提示

**样例 1 说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/5dbepjmh.png)

编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。

编号为 2 的工人想生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。

编号为 3 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。

编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零 件，需要编号为 1 和 3 的工人提供原材料。

编号为 2 的工人想生产第 2 阶段的零件，需要编号为 1 和 3 的工人生产第 1 阶段的零件，他/她们都需要编号为 2 的工人提供原材料。

编号为 3 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。

**样例 2 说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/tfom5z2s.png)

编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 和 5 的工人提供原材料。

编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 和 5 的工人生产第 1 阶段的零件，需要编号为 1,3,4 的工人提供原材料。

编号为 1 的工人想生产第 3 阶段的零件，需要编号为 2 和 5 的工人生产第 2 阶段的零件，需要编号为 1,3,4 的工人生产第 1 阶段的零件，需要编号为 2,3,4,5 的工人提供原材料。

编号为 1 的工人想生产第 4 阶段的零件，需要编号为 2 和 5 的工人生产第 3 阶段的零件，需要编号为 1,3,4 的工人生产第 2 阶段的零件，需要编号为 2,3,4,5 的工人生产第 1 阶段的零件，需要全部工人提供原材料。

编号为 1 的工人想生产第 5 阶段的零件，需要编号为 2 和 5 的工人生产第 4 阶段的零件，需要编号为 1,3,4 的工人生产第 3 阶段的零件，需要编号为 2,3,4,5 的工人生产第 2 阶段的零件，需要全部工人生产第 1 阶段的零件，需要全部工人提供原材料。

**数据规模与约定**

共 $20$ 个测试点。

对所有测试点保证 $1 \leq u, v, a \leq n$。

测试点 $1\sim4$，$1 \leq n, m \leq 1000$，$q = 3$，$L = 1$。

测试点 $5\sim8$，$1 \leq n, m \leq 1000$，$q = 3$，$1 \leq L \leq 10$。

测试点 $9\sim12$，$1 \leq n, m, L \leq 1000$，$1 \leq q \leq 100$。

测试点 $13\sim16$，$1 \leq n, m, L \leq 1000$，$1 \leq q \leq 10^5$。

测试点 $17\sim20$，$1 \leq n, m, q \leq 10^5$，$1 \leq L \leq 10^9$。

## 样例 #1

### 输入

```
3 2 6
1 2
2 3
1 1
2 1
3 1
1 2
2 2
3 2```

### 输出

```
No
Yes
No
Yes
No
Yes```

## 样例 #2

### 输入

```
5 5 5
1 2
2 3
3 4
4 5
1 5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
No
Yes
No
Yes
Yes```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何判断在给定的无向图中，从节点 1 到指定节点是否存在长度为特定值的路径展开。核心思路是将问题转化为求奇数和偶数长度的最短路问题，通过预处理出每个节点到节点 1 的最短奇数路径和最短偶数路径长度，再根据询问的阶段数的奇偶性进行判断。

算法要点在于使用广度优先搜索（BFS）或 Dijkstra、SPFA 等最短路算法，部分题解采用分层图的思想来处理奇偶路径。难点在于理解路径长度的奇偶性对结果的影响，以及处理图中可能存在的孤立点和环的情况。

### 所选题解
- **kradcigam（5星）**
    - **关键亮点**：思路清晰，详细阐述了从递归到最短路的思考过程，对特殊情况有详细说明，代码注释丰富，可读性高。
    - **个人心得**：最初想到递归但复杂度高，后考虑最短路；使用第一次的 BFS 代码在民间数据中 WA 一个点，经分析发现是 1 号点为孤点的情况，从而改进了代码。
    - **核心代码**
```cpp
void bfw(){
    memset(ji,0x3f,sizeof(ji));//奇数最短路径
    memset(ou,0x3f,sizeof(ou));//偶数最短路径
    queue<pair<int,int> >q;
    for(int i=0;i<v[1].size();i++){
        ji[v[1][i]]=1;
        q.push(make_pair(v[1][i],1));
    }
    while(q.size()){
        int x=q.front().first,y=q.front().second;
        for(int i=0;i<v[x].size();i++){
            if(y%2==1){//奇数+1=偶数
                if(y+1<ou[v[x][i]]){
                    ou[v[x][i]]=y+1;//更新答案
                    q.push(make_pair(v[x][i],y+1));
                }
            }else{//偶数+1=奇数
                if(y+1<ji[v[x][i]]){
                    ji[v[x][i]]=y+1;//更新答案
                    q.push(make_pair(v[x][i],y+1));
                }
            }
        }
        q.pop();
    }
}
```
核心实现思想：使用 BFS 算法，分别记录每个节点到节点 1 的最短奇数路径和最短偶数路径。从节点 1 的相邻节点开始入队，根据当前路径长度的奇偶性更新相邻节点的奇偶路径长度，并将更新后的节点入队。

- **kuaiCreator（4星）**
    - **关键亮点**：提供了分层建图和拆分点权两种解法，思路清晰，配有图示，代码简洁易懂。
    - **核心代码（分层建图）**
```cpp
void bfs(int st) {
    memset(dis, 0x3f, sizeof dis);
    queue<int> q;
    q.push(st);
    dis[st] = 0;
    while (q.size()) {
        int hx = q.front();
        q.pop();
        for (auto to : G[hx]) {
            if (dis[to] > dis[hx] + 1) {
                dis[to] = dis[hx] + 1;
                q.push(to);
            }
        }
    }
}
```
核心实现思想：将原图拆分为两层，偶数层和奇数层，通过分层建图的方式，使用 BFS 算法求出节点 1 到各节点的最短路径。根据询问的阶段数的奇偶性选择对应的终点编号，判断最短路径长度是否小于等于阶段数。

- **Kexi_（4星）**
    - **关键亮点**：先给出了 40 分的 DFS 代码，再逐步分析思路得到满分的 BFS 代码，思路讲解详细，适合初学者理解。
    - **个人心得**：初学时没做出来，看别人代码没看懂，自己写时发现和别人代码类似；之前没想到奇数路径不一定要是最短路径，只要比阶段数短即可。
    - **核心代码**
```cpp
void bfs()
{
    memset(d,inf,sizeof(d));
    queue<int> q;
    q.push(1);
    int dis=0;
    d[0][1]=0;//自己到自己距离是0，偶数
    while(!q.empty())
    {
        int now=q.front();
        q.pop();
        for(r int i=head[now];i;i=e[i].n)
        {
            int t=e[i].t;
            if(d[0][t]>d[1][now]+1)
            {
                d[0][t]=d[1][now]+1;
                q.push(t);
            }
            if(d[1][t]>d[0][now]+1)
            {
                d[1][t]=d[0][now]+1;
                q.push(t);
            }
        }
    }
}
```
核心实现思想：使用 BFS 算法，用二维数组 `d` 分别记录每个节点到节点 1 的最短奇数路径和最短偶数路径。从节点 1 开始入队，根据当前节点的奇偶路径长度更新相邻节点的奇偶路径长度，并将更新后的节点入队。

### 最优关键思路或技巧
- **奇偶路径分离**：将每个节点到节点 1 的路径按长度的奇偶性分开处理，使用两个数组或二维数组记录最短奇数路径和最短偶数路径。
- **分层图思想**：将原图拆分为奇数层和偶数层，通过分层建图的方式，将奇偶路径问题转化为普通的最短路问题。
- **BFS 算法**：由于边权为 1，使用 BFS 算法可以高效地求出最短路径。

### 可拓展之处
同类型题或类似算法套路：
- 涉及图中路径长度奇偶性判断的问题，如判断两点间是否存在特定长度的路径。
- 分层图最短路问题，可用于解决需要区分不同状态的最短路问题。

### 推荐题目
- P1144 最短路计数：考察最短路算法和路径计数。
- P3371 单源最短路径（弱化版）：基础的单源最短路问题，可使用多种最短路算法求解。
- P4779 单源最短路径（标准版）：更复杂的单源最短路问题，对算法的效率有一定要求。

---
处理用时：44.73秒
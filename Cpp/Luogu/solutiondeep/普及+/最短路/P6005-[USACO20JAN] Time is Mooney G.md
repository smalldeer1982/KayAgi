# 题目信息

# [USACO20JAN] Time is Mooney G

## 题目描述

Bessie 正在安排前往牛尼亚的一次出差，那里有 $N$（$2 \leq N \leq 1000$）个编号为 $1 \ldots N$ 的城市，由 $M$（$1 \leq M \leq 2000$）条单向的道路连接。Bessie 每次访问城市 $i$ 都可以赚到 $m_i$ 哞尼（$0 \leq m_i \leq 1000$）。从城市 $1$ 出发，Bessie 想要赚到尽可能多的哞尼，最后回到城市 $1$。为了避免争议，$m_1=0$。

沿着两个城市之间的道路移动需要消耗一天。出差的准备工作十分费钱；旅行 $T$ 天需要花费 $C \times T^2$ 哞尼（$1 \leq C \leq 1000$）。

Bessie 在一次出差中最多可以赚到多少哞尼？注意有可能最优方案是 Bessie 不访问城市 $1$ 之外的任何城市，在这种情况下结果应当为 $0$。

## 说明/提示

最优的旅行方案是 $1 \to 2 \to 3 \to 1 \to 2 \to 3 \to1$。Bessie 总共赚到了 $10+20+10+20-1 \times 6^2=24$ 哞尼。

## 样例 #1

### 输入

```
3 3 1
0 10 20
1 2
2 3
3 1```

### 输出

```
24```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何在有向图中规划路径以获取最大收益展开，使用了多种算法，包括动态规划、广度优先搜索（BFS）、分层图最短路（SPFA）和 Dijkstra 算法等。

- **思路对比**：多数题解采用动态规划，通过定义状态表示第 $i$ 天到达城市 $j$ 的最大收益；部分题解使用图搜索算法，如 BFS 和 SPFA，结合分层图的思想处理时间维度；还有题解使用 Dijkstra 算法。
- **算法要点**：动态规划题解的关键在于状态定义和转移方程；BFS 题解通过队列进行搜索，并加入搜索时间限制和最优性剪枝；SPFA 题解构建分层图并使用队列更新状态；Dijkstra 题解进行多次迭代更新状态。
- **解决难点**：主要难点在于处理时间成本和确定搜索范围。多数题解通过数学推导确定时间上限，避免无限搜索；部分题解使用剪枝策略减少不必要的搜索。

### 所选题解
1. **作者：奇米 (赞：12)，5星**
    - **关键亮点**：思路清晰，代码可读性高，详细解释了动态规划的状态定义、转移方程和时间范围的确定。
    - **核心代码**：
```cpp
//f[i][j]表示第i天到达第j座城市的最大收益
memset(f,-1,sizeof(f));
f[0][1]=0;
for ( int i=1;i<=1000;i++ ) {
    for ( int j=1;j<=n;j++ )
        for ( int k=head[j];k;k=e[k].nex ) {
            int v=e[k].to;
            if(~f[i-1][v]) 
                f[i][j]=max(f[i][j],f[i-1][v]+M[j]);
        }
    if(ans<f[i][1]-C*i*i) ans=f[i][1]-C*i*i;
}
```
    - **核心思想**：通过三层循环更新状态，外层循环枚举天数，中层循环枚举城市，内层循环枚举到达当前城市的前一个城市。每次更新状态时，取最大值。最后更新答案。

2. **作者：UltiMadow (赞：6)，4星**
    - **关键亮点**：使用 BFS 算法，并加入搜索时间限制和最优性剪枝，减少搜索空间。
    - **核心代码**：
```cpp
void bfs()
{
    queue<Nodex>Q;
    Q.push((Nodex){1,0,0});
    while(!Q.empty())
    {
        Nodex tmp=Q.front();Q.pop();
        int u=tmp.now,t=tmp.tim,w=tmp.dis;
        for(int i=Head[u];i;i=Edge[i].next)
        {
            int v=Edge[i].to,nowt=t+1,noww=w+val[v];
            if(v==1)ans=max(ans,w-c*nowt*nowt);
            bool fl=true;
            for(int j=nowt;j>=1;j--)
                if(ear[v][j]>=noww-c*nowt*nowt)
                {
                    fl=false;
                    break;
                }
            if(!fl)continue;
            ear[v][nowt]=noww-c*nowt*nowt;
            if(nowt<T)Q.push((Nodex){v,nowt,noww});
        }
    }
}
```
    - **核心思想**：使用队列进行 BFS 搜索，每次取出队首元素，扩展其邻接节点。对于每个邻接节点，进行最优性剪枝和搜索时间限制判断，若满足条件则加入队列。

3. **作者：Jayun (赞：4)，4星**
    - **关键亮点**：明确给出动态规划的状态定义和转移方程，代码简洁。
    - **核心代码**：
```cpp
memset(f, -1, sizeof f);
f[0][1] = 0;
for (int i = 1; i <= N - 10; i++)
    for (int j = 1; j <= n; j++)
        for (int I = head[j]; I; I = e[I].next)
            if(f[i - 1][e[I].to]!= -1)
                f[i][j] = max(f[i][j], f[i - 1][e[I].to] + a[j]);

for (int i = 1; i < N - 10; i++)
    ans = max(f[i][1] - c * i * i, ans);
```
    - **核心思想**：通过三层循环更新状态，外层循环枚举天数，中层循环枚举城市，内层循环枚举到达当前城市的前一个城市。每次更新状态时，取最大值。最后更新答案。

### 最优关键思路或技巧
- **动态规划**：通过定义二维状态 $f_{i,j}$ 表示第 $i$ 天到达城市 $j$ 的最大收益，利用转移方程更新状态。
- **时间范围确定**：通过数学推导，确定时间上限，避免无限搜索。
- **剪枝策略**：使用最优性剪枝和搜索时间限制，减少不必要的搜索。

### 可拓展之处
- **同类型题**：涉及图的路径规划和收益计算的问题，如带有时间成本的旅行商问题、带有资源消耗的路径搜索问题等。
- **类似算法套路**：分层图最短路、动态规划结合图搜索、剪枝优化搜索算法等。

### 推荐题目
1. [P1854 花店橱窗布置](https://www.luogu.com.cn/problem/P1854)：动态规划问题，需要考虑多个维度的状态转移。
2. [P2758 编辑距离](https://www.luogu.com.cn/problem/P2758)：经典的动态规划问题，通过状态转移方程求解编辑距离。
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：图论问题，结合广度优先搜索和动态规划求解最短路的数量。

### 个人心得
- **作者：UltiMadow**：考场上看到题没有思路，后来分析数据范围，使用暴力加优化通过。总结为遇到问题可先分析数据范围，尝试使用暴力方法并加入优化。
- **作者：wmy_goes_to_thu**：原认为 Dijkstra 算法可行，后发现错误。提醒在使用算法时要确保其正确性，避免想当然。 

---
处理用时：38.97秒
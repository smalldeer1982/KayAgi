# 题目信息

# [W1] 团

## 题目描述

我有一张 $n$ 个节点的无向边带权图。它的边很多，用这个方法表示：

 - 有 $k$ 个集合；第 $i$ 个集合可以表示为 $S_i=\{(T_1,W_1),(T_2,W_2),\dots,(T_{|S_i|},W_{|S_i|})\}$。
 - 对于任何两对 $(T_i,W_i),(T_j,W_j)$ 在同一个集合里面，图中会形成一条连 $T_i$ 和 $T_j$ 的边，边权为 $W_i+W_j$。

请对于所有节点 $i$ 找到 $1$ 到 $i$ 的最短路，即从 $1$ 到 $i$ 的边权和最小的简单路径。

## 说明/提示

对于前 $10\%$ 的数据，$|S_i|=2$；  
对于前 $20\%$ 的数据，$|S_i|\le10$；  
对于前 $50\%$ 的数据，$|N|\le1000,\sum|S_i|\le2000$;  
对于 $100\%$ 的数据，$1\le|N|\le2\cdot10^5,\sum|S_i|\le4\cdot10^5,0\le W_i\le10^9$。

## 样例 #1

### 输入

```
5 2
3
1 1
2 1
5 3
3
2 1
3 2
4 1```

### 输出

```
0 2 5 4 4```

# AI分析结果

### 综合分析与结论
本题主要难点在于图的边数过多，直接暴力建图会导致时间和空间复杂度过高。各题解的核心思路均围绕减少边数展开，普遍采用在每个集合中引入虚点（或“交换机”）的方法，将边数从 $O(\sum |S_i|^2)$ 优化到 $O(\sum |S_i|)$，再使用最短路算法（如 Dijkstra）求解。

### 所选题解
- **作者：SDqwq（5星）**
    - **关键亮点**：思路清晰，步骤详细，先给出暴力解法，再逐步优化得到正解，代码注释完善，可读性高。
- **作者：Mr_think（4星）**
    - **关键亮点**：通过图文结合的方式解释建图过程，对暴力建图和优化建图的对比清晰，给出了正确性证明。
- **作者：PigAunt（4星）**
    - **关键亮点**：以网络通信中的“交换机”类比虚点，形象易懂，代码实现简洁明了。

### 重点代码
#### SDqwq 的核心代码
```cpp
// 加边函数
void add (int u, int v, ll w) {
    e[++cnt].to = v;
    e[cnt].len = w;
    e[cnt].next = elast[u];
    elast[u] = cnt;
}

// Dijkstra 算法
void dijkstra (int x) {
    for (int i = 1; i <= tot; i++)
        dis[i] = inf;
    dis[x] = 0;
    pq.push(node(0, x));
    while (!pq.empty()) {
        node u = pq.top();
        pq.pop();
        if (vis[u.id])
            continue;
        vis[u.id] = true;
        for (int i = elast[u.id]; i != 0; i = e[i].next)
            if (dis[e[i].to] > dis[u.id] + e[i].len) {
                dis[e[i].to] = dis[u.id] + e[i].len;
                pq.push(node(dis[e[i].to], e[i].to));
            }
    }
}

// 主函数
int main () {
    scanf("%d %d", &n, &k);
    tot = n;
    for (int i = 1; i <= k; i++) {
        scanf("%d", &S);
        tot++;
        for (int j = 1; j <= S; j++) {
            scanf("%d %lld", &T[j], &W[j]);
            add(T[j], tot, W[j]);
            add(tot, T[j], W[j]);
        }
    }
    dijkstra(1);
    for (int i = 1; i <= n; i++)
        printf("%lld ", dis[i]);
    return 0;
}
```
**核心思想**：先通过 `add` 函数添加边，在每个集合中引入虚点，虚点与集合内的点连边，边权为点的权值。然后使用 `dijkstra` 函数求解最短路，最后输出结果。

#### Mr_think 的核心思路
在每个集合中新添一个虚拟节点 $T_{n+i}$，其点权为 0，再向其他点 $T_j$ 连边，将边数从 $O(k|S_i^2|)$ 优化到 $O(k|S_i|)$，最后使用最短路模板（Dijkstra 堆优化或 SPFA）求解。

#### PigAunt 的核心代码
```cpp
// 加边函数
void Add(int a, int b, int c)
{
    edges[total].to = b;
    edges[total].w = c;
    edges[total].next = head[a];
    head[a] = total++;
}

// Dijkstra 算法
void Dijkstra(int start)
{
    std::priority_queue<PLI, std::vector<PLI>, std::greater<PLI> > heap;
    for (int i = 0; i < N; i++)
    {
        vis[i] = false;
        dis[i] = PosInf;
    }
    dis[start] = 0;
    heap.push({0, start});
    
    while (!heap.empty())
    {
        PLI t = heap.top();
        heap.pop();
        
        if (vis[t.second])
            continue;
        vis[t.second] = true;
        
        for (int i = head[t.second]; i != -1; i = edges[i].next)
        {
            int v = edges[i].to, w = edges[i].w;
            if (dis[v] > dis[t.second] + w)
            {
                dis[v] = dis[t.second] + w;
                heap.push({dis[v], v});
            }
        }
    }
}

// 主函数
int main()
{
    for (int i = 0; i < N; i++)
        head[i] = -1;
    
    std::cin >> n >> k;
    for (int i = 1; i <= k; i++)
    {
        int g = 0;
        std::cin >> g;
        for (int j = 1; j <= g; j++)
        {
            int a, b;
            std::cin >> a >> b;
            Add(a, n + i, b);
            Add(n + i, a, b);
        }
    }
    
    Dijkstra(1);
    
    for (int i = 1; i <= n; i++)
        std::cout << dis[i] << " ";
    std::cout << std::endl;
    return 0;
}
```
**核心思想**：使用 `Add` 函数添加边，引入“交换机”（虚点）减少边数，然后使用 `Dijkstra` 函数求解最短路，最后输出结果。

### 最优关键思路或技巧
- **引入虚点优化建图**：在每个集合中引入一个虚点，虚点与集合内的点连边，边权为点的权值，这样可以将边数从 $O(\sum |S_i|^2)$ 优化到 $O(\sum |S_i|)$，避免了暴力建图的高复杂度。
- **使用堆优化的 Dijkstra 算法**：可以在 $O((n + m)\log m)$ 的时间复杂度内求解最短路，提高了算法效率。

### 可拓展之处
同类型题或类似算法套路：
- **分层图最短路**：当图的状态可以分层表示时，可以通过引入虚点将不同层的图连接起来，然后使用最短路算法求解。
- **虚拟源点**：在一些问题中，可以引入一个虚拟源点，将其与所有起点或终点连边，从而将多源最短路问题转化为单源最短路问题。

### 推荐题目
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
- [P1629 邮递员送信](https://www.luogu.com.cn/problem/P1629)

### 个人心得
- **Kalium**：提到如果 RE 可以看看[这个帖子](https://www.luogu.com.cn/discuss/show/314181)，注意 long long，详情见 $w_i$ 的范围。总结：在做题时要注意数据范围，避免因数据类型问题导致错误，遇到 RE 可以参考相关帖子排查问题。

---
处理用时：45.51秒
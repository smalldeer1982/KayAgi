# 题目信息

# [WFOI - 01]  刷题 （problem）

## 题目背景

简化题意：[$\texttt{Link}$](https://www.luogu.com.cn/paste/ievt77rm)。

## 题目描述

你初始能力为 $0$。

现在有 $n$ 个题库，每个题库的题有同一个难度 $a_i$，并且题目数量可以视为无限多。现在你要刷 $m$ 道题，每道题都是所有题中你选择出来的一道。

假设你目前做到的题目难度是 $x$，则：

当你的能力比这个题大或等于此题时，你将花费你的能力以攻破此题（此时你的能力减去 $x$）；否则，你将认真钻研此题，钻研出此题后能力增加 $x$（此时不会导致能力减少）。

现在你想知道你做 $m$ 题后能力最大值。由于你的小伙伴也要刷题，所以**有多次询问**，询问之间相互独立，也就是说每次询问的能力初值为 $0$。

## 说明/提示

- **样例 $1$ 解释：**
	
    当 $m=1$ 时，依次选择 $6$；

	当 $m=2$ 时，依次选择 $4,6$；
    
    当 $m=3$ 时，依次选择 $1,4,6$；
- **样例 $2$ 解释：** 

    当 $m=1$ 时，依次选择 $1$；

	当 $m=2$ 时，依次选择 $1,1$；

**本题采用 Subtask 捆绑测试。**

  Subtask 编号 | $n\le$ | $m\le$ | $T\le$
  :-: | :-: | :-: | :-: |
  **Subtask #0 ($5\texttt{pts}$)** | $5$ | $5$ | $100$ |
  **Subtask #1 ($10\texttt{pts}$)** | $5$ | $5$ | $10^5$ |
  **Subtask #2 ($10\texttt{pts}$)** | $200$ | $200$ | $100$ |
  **Subtask #3 ($15\texttt{pts}$)** | $200$ | $200$ | $10^5$ |
  **Subtask #4 ($10\texttt{pts}$)** | $200$ | $10^{18}$ | $10^5$ |
  **Subtask #5 ($50\texttt{pts}$)** | $2000$ | $10^{18}$ | $10^5$ |
  
对于 $100\%$ 的数据，$1 \le T \le 10^5$，$1 \le n\le 2000$，$1 \le m \le 10^{18}$，$\forall i,0 \le a_i \le 2000$。

## 样例 #1

### 输入

```
5 3
1 2 3 4 6
1
2
3```

### 输出

```
6
10
11```

## 样例 #2

### 输入

```
1 2
1
1
2```

### 输出

```
1
0```

# AI分析结果

### 综合分析与结论
这些题解大多围绕建图和最短路展开，核心思路是将能力值作为节点，根据刷题规则建边，然后利用奇偶性处理最短路，以应对多次询问和 $m$ 可能很大的情况。

### 所选题解
- **作者：Wf_yjqd（5星）**
    - **关键亮点**：思路清晰，详细说明了建图和处理最短路的过程，代码中包含快读快写优化，且有调试时的踩坑记录。
    - **个人心得**：“说的简单，写起来还是很出错的。。”“没必要快读快写，调试的时候TLE了，原因不在此”“罪魁祸首，3999->1e9，TLE + MLE -> AC”，总结为写代码时易出错，调试时需注意边界值设置。
- **作者：YellowBean_Elsa（4星）**
    - **关键亮点**：将问题转化为动态规划和最短路问题，思路明确，代码注释详细。
    - **个人心得**：“经历了NOIp2021的洗礼，看啥都像dp。。。”，体现出竞赛经历对解题思维的影响。
- **作者：伟大的王夫子（4星）**
    - **关键亮点**：指出本题与其他题的相似性，思路清晰，代码简洁。
    - **个人心得**：“然而我比赛时却没有做出P7997。”，说明比赛时的发挥可能受多种因素影响。

### 重点代码及核心实现思想
#### 作者：Wf_yjqd
```cpp
// 建图
for(int i=0;i<=3999;i++)
    for(int j=1;j<=n;j++)
        if(i>=a[j])
            add(i,i-a[j]);
        else if(i+a[j]<=3999)
            add(i,i+a[j]);
// bfs处理最短路
bfs(0);
// 维护前缀最大值
for(int i=2;i<=3999;i++)
    ans[i]=max(ans[i],ans[i-2]);
// 回答询问
while(T--){
    read(m);
    if(m>3999)
        print(ans[m&1?3999:3998]);
    else
        print(ans[m]);
    putchar('\n');
}
```
核心思想：先根据能力值和题库难度建图，然后用bfs处理奇偶最短路，再维护前缀最大值，最后根据询问的 $m$ 输出答案。

#### 作者：YellowBean_Elsa
```cpp
// spfa处理最短路
memset(dp,0x7f,sizeof(dp));
dp[0][0]=0;
q.push(0);
while(!q.empty()){
    int x=q.front();
    q.pop();
    fu(i,1,n){
        if(x<a[i]){
            flg=0;
            if(dp[x+a[i]][0]>dp[x][1]+1){
                dp[x+a[i]][0]=dp[x][1]+1;
                q.push(x+a[i]);flg=1;
            }if(dp[x+a[i]][1]>dp[x][0]+1){
                dp[x+a[i]][1]=dp[x][0]+1;
                if(!flg)q.push(x+a[i]);
            }
        }else{
            flg=0;
            if(dp[x-a[i]][0]>dp[x][1]+1){
                dp[x-a[i]][0]=dp[x][1]+1;
                q.push(x-a[i]);flg=1;
            }if(dp[x-a[i]][1]>dp[x][0]+1){
                dp[x-a[i]][1]=dp[x][0]+1;
                if(!flg)q.push(x-a[i]);
            }
        }
    }
}
// 回答询问
while(T--){
    scanf("%lld",&m);
    fd(i,a[n]<<1,0)
        if(dp[i][m&1LL]<=m){
            printf("%d\n",i);
            break;
        }
}
```
核心思想：用spfa算法处理奇偶最短路，记录得到每个能力值的最小步数，最后根据询问的 $m$ 找到最大可达的能力值。

#### 作者：伟大的王夫子
```cpp
// 建图
for (int i = 0; i <= 2 * maxa - 1; ++i)
    for (int j = 1; j <= n; ++j) 
        e[i].push_back(i >= a[j]? i - a[j] : i + a[j]);
// bfs处理最短路
memset(f, 0x3f, sizeof f);
f[0][0] = 0;
queue<pair<int, bool> > q;
v[0][0] = 1;
q.push(make_pair(0, 0));
while (q.size()) {
    int x = q.front().first;
    bool p = q.front().second;
    q.pop();
    for (int i = 0; i < e[x].size(); ++i) {
        int y = e[x][i];
        if (v[y][p ^ 1]) continue;
        f[y][p ^ 1] = f[x][p] + 1;
        v[y][p ^ 1] = 1;
        q.push(make_pair(y, p ^ 1));
    } 
}
// 回答询问
while (Q--) {
    ll m;
    Rd(m);
    for (int i = 2 * maxa - 1; i >= 0; --i)
        if (f[i][m & 1] <= m) {
            printf("%d\n", i);
            break;
        }	
}
```
核心思想：先建图，再用bfs处理奇偶最短路，最后根据询问的 $m$ 找到最大可达的能力值。

### 最优关键思路或技巧
- **建图思想**：将能力值作为节点，根据刷题规则建边，把问题转化为图论问题。
- **奇偶性处理**：考虑到连续做两次最难的题能力值不变，利用奇偶性处理最短路，减少计算量。
- **预处理**：提前处理好最短路和前缀最大值，实现 $O(1)$ 或 $O(\log n)$ 查询。

### 拓展思路
同类型题可参考图论中的路径规划问题，如给定一些状态转移规则，求经过一定步数后能达到的最优状态。类似算法套路包括建图、最短路算法（如BFS、Dijkstra、SPFA）、动态规划等。

### 推荐题目
- [P5663 [CSP - J2019] 加工零件](https://www.luogu.com.cn/problem/P5663)
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)

---
处理用时：44.77秒
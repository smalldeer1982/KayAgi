# 题目信息

# [蓝桥杯 2019 国 AC] 大胖子走迷宫

## 题目描述

小明是个大胖子，或者说是个大大胖子，如果说正常人占用 $1\times1$ 的面积，小明要占用 $5\times5$ 的面积。

由于小明太胖了，所以他行动起来很不方便。当玩一些游戏时，小明相比小伙伴就吃亏很多。小明的朋友们制定了一个计划，帮助小明减肥。计划的主要内容是带小明玩一些游戏，让小明在游戏中运动消耗脂肪。走迷宫是计划中的重要环节。

朋友们设计了一个迷宫，迷宫可以看成是一个由 $n\times n$ 个方阵组成的方阵，正常人每次占用方阵中 $1\times1$ 的区域，而小明要占用 $5\times5$ 的区域。小明的位置定义为小明最正中的一个方格。迷宫四周都有障碍物。为了方便小明，朋友们把迷宫的起点设置在了第 $3$ 行第 $3$ 列，终点设置在了第 $n-2$ 行第 $n-2$ 列。

小明在时刻 $0$ 出发，每单位时间可以向当前位置的上、下、左、右移动单位 $1$ 的距离，也可以停留在原地不动。小明走迷宫走得很辛苦，如果他在迷宫里面待的时间很长，则由于消耗了很多脂肪，他会在时刻 $k$ 变成一个胖子，只占用 $3\times3$ 的区域。如果待的时间更长，他会在时刻 $2\times k$ 变成一个正常人，只占用 $1\times1$ 的区域。注意，当小明变瘦时迷宫的起点和终点不变。

请问，小明最少多长时间能走到迷宫的终点。注意，小明走到终点时可能变瘦了也可能没有变瘦。

## 说明/提示

对于 $30 \%$ 的评测用例, $1 \leq n \leq 50$。

对于 $60 \%$ 的评测用例, $1 \leq n \leq 100$。

对于所有评测用例, $1 \leq n \leq 300$，$1 \leq k \leq 1000$。

蓝桥杯 2019 年国赛 A 组 F 题（C 组 I 题）。

## 样例 #1

### 输入

```
9 5
+++++++++
+++++++++
+++++++++
+++++++++
+++++++++
***+*****
+++++++++
+++++++++
+++++++++
```

### 输出

```
16```

# AI分析结果

### 综合分析与结论
这些题解主要围绕蓝桥杯 2019 国 AC 大胖子走迷宫问题展开，核心是求小明从起点到终点的最短时间。大部分题解采用广度优先搜索（BFS）算法，因为这是求最短路径的常用方法。本题的难点在于小明的体型会随时间变化，不同体型占用的空间不同，这增加了判断能否移动的复杂度。各题解在处理体型变化、判断移动合法性以及优化算法等方面有不同的实现方式。

### 所选题解
- **作者：DreamLand_zcb（5星）**
  - **关键亮点**：思路清晰，代码可读性高，对体型变化和移动合法性的判断逻辑明确，且有小优化，如当小明占地是 $1 \times 1$ 时不考虑原地不动的情况。
- **作者：qiuqiuqzm（4星）**
  - **关键亮点**：不仅使用 BFS 算法，还对算法进行了多次优化，如用二维前缀和优化判断障碍物的时间复杂度，新增 $stay$ 变量优化原地等待的逻辑，最后用三个队列进一步优化，时间复杂度较低。
- **作者：_Yonder_（4星）**
  - **关键亮点**：采用跑三遍 BFS 的独特思路，从体型大到体型小依次 BFS，将上一次体型能到达的位置加入下一次的队列，思路新颖，时间复杂度为 $O(n^2)$。

### 重点代码及核心实现思想
#### DreamLand_zcb 的代码
```cpp
bool check(int x, int y, int size)
{
    if(vis[x][y]) return false;
    for(int i=x-size;i<=x+size;i++)
        for(int j=y-size;j<=y+size;j++)
            if(i < 1 || i > n || j < 1 || j > n || a[i][j])
                return false;
    return true;
}
int work(int Time)
{
    if(Time < k) return 2;
    else if(Time < 2 * k) return 1;
    else return 0;
}
void bfs()
{
    queue <node> q;
    vis[3][3] = 1;
    q.push((node){3, 3, 0, 2});
    while(!q.empty())
    {
        node t = q.front();
        q.pop();
        if(t.x == n - 2 && t.y == n - 2)
        {
            cout << t.Time;
            return ;
        }
        if(t.size != 0) q.push((node){t.x, t.y, t.Time+1, work(t.Time+1)});
        for(int i=0;i<4;i++)
        {
            int X = t.x + dx[i];
            int Y = t.y + dy[i];
            if(check(X, Y, t.size))
            {
                vis[X][Y] = 1;
                q.push((node){X, Y, t.Time+1, work(t.Time+1)});
            }
        }
    }
}
```
**核心实现思想**：`check` 函数用于判断小明能否站在指定位置，通过遍历小明占用的区域检查是否越界或有障碍物。`work` 函数根据当前时间返回小明的体型。`bfs` 函数进行广度优先搜索，将合法的位置加入队列，同时处理小明原地不动的情况。

#### qiuqiuqzm 的代码
```cpp
bool pd(int nx,int ny,int nstep,bool mode) //mode=1判断是否可以走,mode=0判断是否有障碍物
{
    bool flag=true;
    if(nstep<k)
    {
        if(!(nx+2<=n&&nx-2>0&&ny-2>0&&ny+2<=n)&&mode)
            flag=false;
        else
            if(pre[nx+2][ny+2]-pre[nx+2][ny-3]-pre[nx-3][ny+2]+pre[nx-3][ny-3]!=0)
                flag=false;
    }
    else if(nstep<2*k)
    {
        if(!(nx+1<=n&&nx-1>0&&ny-1>0&&ny+1<=n)&&mode)
            flag=false;
        else
            if(pre[nx+1][ny+1]-pre[nx+1][ny-2]-pre[nx-2][ny+1]+pre[nx-2][ny-2]!=0)
                flag=false;
    }
    else
        flag=(!(a[nx][ny])&&((nx<=n&&nx>0&&ny>0&&ny<=n)));
    return flag;
}
void bfs()
{
    vis[3][3]=1;
    q.push((node){3,3,0});
    while(!q.empty())
    {
        node now=q.front();
        q.pop();
        if(now.x==n-2&&now.y==n-2)
        {
            cout<<now.step;
            return;
        }
        bool flag=now.stay;
        if(now.step>=2*k||!now.stay||now.step>=k&&now.stay==1)
            for(int i=1;i<=4;i++)
            {
                int xx=now.x+dx[i],yy=now.y+dy[i];
                if(pd(xx,yy,now.step,1)&&!vis[xx][yy])
                    vis[xx][yy]=1,q.push((node){xx,yy,now.step+1,0});
                if(now.step<2*k&&!pd(xx,yy,now.step,0))
                    flag=true;
            }
        if(flag)
        {
            if(now.step<k)
                q.push((node){now.x,now.y,now.step+1,1});
            else
                q.push((node){now.x,now.y,now.step+1,2});
        }
    }
    return;
}
```
**核心实现思想**：`pd` 函数用于判断小明在指定时间能否走到指定位置或该位置周围是否有障碍物，使用二维前缀和优化判断。`bfs` 函数进行广度优先搜索，通过 `stay` 变量优化原地等待的逻辑，只有在有障碍物时才考虑原地等待。

#### _Yonder_ 的代码
```cpp
inline bool check(int x,int y,int v){
    if(x-v<=0||x+v>n||y-v<=0||y+v>n||f[x][y][v]>-1) return false;
    for(register int i=-v;i<=v;i++)
        for(register int j=-v;j<=v;j++)
            if(c[i+x][j+y]=='*') return false;
    return true;
}
inline void BFS(int v){
    queue<node> Q;
    if(v==2) Q.push({3,3,f[3][3][2]=0});
    else
        for(register int i=1;i<=n;i++)
            for(register int j=1;j<=n;j++)
                if(f[i][j][v+1]>-1&&f[i][j][v+1]<=(2-v)*k)
                    Q.push({i,j,f[i][j][v]=(2-v)*k});
    while(Q.size()){
        node q=Q.front();Q.pop();
        if(q.i==n-2&&q.j==n-2) return;
        for(register int k=1;k<=4;k++){
            int l=X[k]+q.i,r=Y[k]+q.j;
            if(check(l,r,v)) Q.push({l,r,f[l][r][v]=q.ans+1});
        }
    }f[n-2][n-2][v]=1e9;
}
```
**核心实现思想**：`check` 函数用于判断小明在指定体型下能否站在指定位置。`BFS` 函数进行广度优先搜索，根据不同的体型进行三次 BFS，将上一次体型能到达的位置加入当前队列。

### 最优关键思路或技巧
- **使用 BFS 算法**：BFS 是求最短路径的常用算法，能保证找到的路径是最短的。
- **体型变化处理**：通过时间判断小明的体型，不同体型采用不同的判断逻辑。
- **二维前缀和优化**：用于快速判断小明占用的区域是否有障碍物，将判断时间复杂度从 $O(n^2)$ 优化到 $O(1)$。
- **原地等待优化**：当小明体型为 $1 \times 1$ 时不考虑原地等待，或只有在有障碍物时才考虑原地等待，避免无意义的操作。

### 可拓展之处
同类型题可能会有更多的状态变化，如不同的移动规则、更多的体型变化等。类似算法套路可用于解决其他状态变化的最短路径问题，如在不同天气条件下的路径规划，不同天气对应不同的移动限制。

### 推荐题目
- [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)：涉及状态变化的 BFS 问题，电梯有不同的层数和移动规则。
- [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)：经典的迷宫问题，可使用 BFS 或 DFS 求解。
- [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)：马在棋盘上的最短路径问题，需要考虑马的移动规则。

### 个人心得摘录与总结
- **WegestGao**：在做 BFS 题时可能会遇到思路混乱、调试困难的问题，需要仔细分析问题，考虑各种情况，如本题中要考虑大胖子或胖子在走的过程中可能没有可走的区域，需要让升级版的人探路。
- **qiuqiuqzm**：直接的 BFS 可能会超时，需要进行优化，如用二维前缀和优化判断障碍物的时间复杂度，合理处理原地等待的情况。

---
处理用时：62.63秒
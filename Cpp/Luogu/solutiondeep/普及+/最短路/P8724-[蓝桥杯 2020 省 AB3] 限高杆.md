# 题目信息

# [蓝桥杯 2020 省 AB3] 限高杆

## 题目描述

某市有 $n$ 个路口，有 $m$ 段道路连接这些路口，组成了该市的公路系统。其中一段道路两端一定连接两个不同的路口。道路中间不会穿过路口。

由于各种原因，在一部分道路的中间设置了一些限高杆，有限高杆的路段货车无法通过。

在该市有两个重要的市场 $A$ 和 $B$，分别在路口 $1$ 和 $n$ 附近，货车从市场 $A$ 出发，首先走到路口 $1$，然后经过公路系统走到路口 $n$，才能到达市场 $B$。两个市场非常繁华，每天有很多货车往返于两个市场之间。

市长发现，由于限高杆很多，导致货车可能需要绕行才能往返于市场之间，这使得货车在公路系统中的行驶路程变长，增加了对公路系统的损耗，增加了能源的消耗，同时还增加了环境污染。

市长决定要将两段道路中的限高杆拆除，使得市场 $A$ 和市场 $B$ 之间的路程变短。请问最多能减少多长的距离?

## 说明/提示

**【样例说明】**

只有两段道路有限高杆，全部拆除后，$1$ 到 $n$ 的路程由原来的 $17$ 变为了 $11$，减少了 $6$。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测样例，$2 \leq n \leq 10,1 \leq m \leq 20,1 \leq c \leq 100$。

对于 $50 \%$ 的评测样例，$2 \leq n \leq 100,1 \leq m \leq 1000,1 \leq c \leq 1000$。

对于 $70 \%$ 的评测样例，$2 \leq n \leq 1000,1 \leq m \leq 10000,1 \leq c \leq 10000$。

对于所有评测样例，$2 \leq n \leq 10000,2 \leq m \leq 10^5,1 \leq c \leq 10000$，至少 有两段道路有限高杆。

蓝桥杯 2020 第三轮省赛 AB 组 H 题。

## 样例 #1

### 输入

```
5 7
1 2 1 0
2 3 2 1
1 3 9 0
5 3 8 0
4 3 5 1
4 3 9 0
4 5 4 0```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
这些题解大多采用分层图或动态规划结合最短路的思路来解决问题。分层图的核心思想是将原图复制多份，根据拆除限高杆的不同情况在各层之间连边；动态规划则是在最短路过程中记录拆除不同数量限高杆的状态。各题解在实现细节上有所差异，但整体思路相似。

### 所选题解
- **作者：carp_oier (赞：14)，4星**
    - **关键亮点**：思路清晰，从集合角度分析决策情况，代码注释详细，将问题转化为动态规划 + 最短路问题，易于理解。
    - **个人心得**：提醒读者注意拆限高杆后路径可能变长的情况，要在拆一个和拆两个里面取最小值，再用不拆的最小值减去该值得到答案。
- **作者：Shanganze (赞：8)，4星**
    - **关键亮点**：明确指出是分层图板题，建图思路清晰，代码结构简洁，对建图过程有详细说明。
- **作者：Eleveslaine (赞：3)，4星**
    - **关键亮点**：对分层图的概念和应用有详细解释，给出样例建图的图示，帮助理解，还提到了一些细节和可能的 hack 数据。

### 重点代码
#### carp_oier 的核心代码
```cpp
inline void dij(ll s)
{
    memset(dis, 0x3f, sizeof dis);
    memset(st, 0, sizeof st);
    dis[s][0] = dis[s][1] = dis[s][2] = 0;
    q.push({s, 0, 0});
    while(q.size())
    {
        node asd = q.top();
        q.pop();
        ll u = asd.id, t = asd.type, dist = asd.dis;
        if(st[u][t]) continue;
        st[u][t] = 1;
        for(rl i=h[u]; ~i; i = ne[i])
        {
            ll v = e[i];
            if(sta[i] && t <= 1)
            {
                if(dis[v][t + 1] > dis[u][t] + w[i])
                {
                    dis[v][t + 1] = dis[u][t] + w[i];
                    q.push({v, dis[v][t + 1], t + 1});
                }
                else continue;
            }
            else if(!sta[i]) 
            {
                if(dis[v][t] > dis[u][t] + w[i])
                {
                    dis[v][t] = dis[u][t] + w[i];
                    q.push({v, dis[v][t], t});
                }
            }
        }
    }
}
```
**核心实现思想**：使用 Dijkstra 算法，`dis[u][t]` 表示到达节点 `u` 且拆除 `t` 个限高杆的最短距离。根据边是否有限高杆以及当前拆除限高杆的数量进行状态转移。

#### Shanganze 的核心代码
```cpp
for(int q=1;q<=m;q++){
    int a,b,c,d;
    a=read();b=read();c=read();d=read();
    if(d==1){//有限高杆
        add(a,b+n,c);
        add(b,a+n,c);
        add(b+n,a+n+n,c);
        add(a+n,b+n+n,c);
    }
    else{//无限高杆
        add(a,b,c);
        add(b,a,c);
        add(b+n,a+n,c);
        add(a+n,b+n,c);
        add(b+n+n,a+n+n,c);
        add(a+n+n,b+n+n,c);
    }
}
```
**核心实现思想**：建图时，对于有限高杆的边，在相邻两层图之间连边；对于无限高杆的边，在每一层图内部连边。

#### Eleveslaine 的核心代码
```cpp
while(m--)
{
    cin >> u >> v >> w >> d;
    if(d==0)
        for(int i=0;i<3;++i)
            add(u+n*i,v+n*i,w,d),add(v+n*i,u+n*i,w,d);
    else
        for(int i=0;i<2;++i)
            add(u+n*i,v+n*(i+1),w,d),add(v+n*i,u+n*(i+1),w,d);
}
```
**核心实现思想**：同样是建图，根据边是否有限高杆，在不同层之间或层内连边。

### 最优关键思路或技巧
- **分层图思想**：将原图复制多份，根据特殊条件（如本题的限高杆）在各层之间连边，将问题转化为普通的最短路问题。
- **动态规划结合最短路**：在最短路过程中记录不同状态（如拆除不同数量限高杆）的最短距离，通过状态转移更新答案。

### 可拓展之处
同类型题如涉及边的特殊操作（如免费通过、限时通过等）都可以考虑使用分层图或动态规划结合最短路的方法。类似算法套路包括在最短路过程中增加额外状态，根据不同条件进行状态转移。

### 推荐题目
- [P4568 [JLOI2011]飞行路线](https://www.luogu.com.cn/problem/P4568)：典型的分层图最短路问题，有免费乘坐的特殊条件。
- [P1849 [USACO12MAR]Cows in a Skyscraper G](https://www.luogu.com.cn/problem/P1849)：与本题思路类似，可使用分层图或动态规划结合最短路解决。
- [P3119 [USACO15JAN]Grass Cownoisseur G](https://www.luogu.com.cn/problem/P3119)：涉及图的特殊操作，可通过分层图或状态记录来解决。

### 个人心得总结
- carp_oier 提醒注意拆限高杆后路径可能变长的情况，要合理取最小值得到正确答案。
- ryf_loser 提到分层图板子题调试花费了一个小时，说明分层图建图和实现细节需要仔细处理。
- allqpsi 感谢 Franz_Liszt 提供的 hack 数据，强调了测试数据和边界情况的重要性。

---
处理用时：40.44秒
# 题目信息

# [NOIP 1999 普及组] 回文数

## 题目描述

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。

又如：对于十进制数 $87$：

STEP1：$87+78=165$  
STEP2：$165+561=726$  
STEP3：$726+627=1353$   
STEP4：$1353+3531=4884$  

在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。

写一个程序，给定一个 $N$（$2 \le N \le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。

## 样例 #1

### 输入

```
10
87
```

### 输出

```
STEP=4
```

# AI分析结果

• 综合分析与结论：
    - 思路：多数题解采用模拟思路，先读入N进制数，通过循环不断进行该数与其反转数的N进制加法，每次加法后判断结果是否为回文数，若30步内得到回文数则输出步数，否则输出“Impossible!”。
    - 算法要点：涉及高精度加法（因数字达100位）、进制转换（主要是16进制特殊处理）、回文数判断。高精度加法需按N进制规则处理进位；16进制要将字母转为对应数字；回文数判断可通过比较数字首尾对应位是否相等实现。
    - 解决难点：主要难点在于高精度加法的实现及16进制处理。高精度加法需注意进位规则按N进制调整；16进制要准确将字符转为数字及处理运算结果转回字符。
    - 整体来看，多数题解思路清晰，但部分题解代码可读性欠佳或存在优化空间。

所选的题解：
  - 作者：Haishu (赞：507)  星级：5星
    - 关键亮点：思路清晰，强调标准化、模块化编程思维，将判断回文、数字翻转与加法分别写成函数，主程序组织调用，代码结构清晰，便于理解与维护。同时对利用数据范围漏洞解题行为进行反思，具有教育意义。
    - 个人心得：作者认识到早期题解利用数据范围漏洞的错误，进行自我检讨，强调应按题目要求规范解题。
    - 重点代码 - 核心实现思想：`add`函数实现高精度加法，先反转数字存入`d`数组，再与原数组`c`相加并处理进位；`pd`函数通过比较数组两端对应元素判断是否为回文数。
```cpp
inline void add()
{
    for (int i = 0; i < l; ++i)
        d[l - i - 1] = c[i];
    l += 2;
    for (int i = 0; i < l; ++i)
    {
        c[i] += d[i];
        if (c[i] >= n) c[i + 1]++, c[i] -= n;
    }
    while (!c[l - 1]) --l;
}
inline bool pd()
{
    for (int i = 0; i < l; ++i)
        if (c[i]!= c[l - 1 - i]) return false;
    return true;
}
```
  - 作者：Strong_Jelly (赞：294)  星级：4星
    - 关键亮点：详细地给出了高精度加法、反转、判断回文数及数组存高精度数的具体实现代码，每个功能模块清晰，对初学者友好。
    - 重点代码 - 核心实现思想：`add`函数实现高精度加法，按位相加并按N进制处理进位；`turn`函数将数组反转；`f`函数通过比较数组两端元素判断是否为回文数。
```cpp
void add(int a[], int b[])//高精加 
{
    for(int i = 1; i <= l; i++)
    {
        a[i] += b[i];
        a[i + 1] += a[i] / n;
        a[i] %= n;
    }
    if(a[l + 1] > 0) 
    {
        l++; 
    }
}
void turn(int a[])//反转数字 
{
    int j = 0;
    for(int i = l; i >= 1; i--) 
    { 
        w[++j] = a[i]; 
    }
}
bool f(int a[])//判断是否是回文数 
{
    int ln = l;
    int i = 1;
    int j = l;
    while(ln--)
    {
        if(ln < l / 2) 
        {
            break;
        }
        if(a[i]!= a[j])
        {
            return false; 
        }
        i++;
        j--;
    }
    return true;
}
```
  - 作者：hawa130 (赞：125)  星级：4星
    - 关键亮点：利用C++ STL自带的`reverse`函数简化字符串翻转操作，代码简洁明了，同时对高精度加法推广到N进制的实现过程清晰。
    - 重点代码 - 核心实现思想：`hw`函数利用`reverse`函数反转字符串并判断是否与原字符串相等来判断回文；`add`函数实现N进制高精度加法，将字符转为数字相加并按N进制处理进位。
```cpp
bool hw(string a) { 
    string s = a; 
    reverse(s.begin(), s.end()); 
    return s == a; 
}
string add(int k, string b) { 
    string a = b;
    reverse(a.begin(), a.end());
    int numa[maxN], numb[maxN], numc[maxN];
    int len = a.length(), lenc = 1;
    string ans;
    for (int i = 0; i < len; i++) {
        if (isdigit(a[i])) numa[len - i] = a[i] - '0'; 
        else numa[len - i] = a[i] - 'A' + 10; 
        if (isdigit(b[i])) numb[len - i] = b[i] - '0';
        else numb[len - i] = b[i] - 'A' + 10;
    }
    int x = 0;
    while (lenc <= len) {
        numc[lenc] = numa[lenc] + numb[lenc] + x;
        x = numc[lenc] / k; 
        numc[lenc] %= k; 
        lenc++;
    }
    numc[lenc] = x;
    while (numc[lenc] == 0) lenc--;
    for (int i = lenc; i >= 1; i--) ans += sixt[numc[i]];
    return ans;
}
```

最优的关键思路或技巧：
    - 模块化编程：将不同功能封装成函数，如将高精度加法、回文判断、数字翻转等操作分别写成独立函数，提高代码可读性与维护性。
    - 合理利用STL：如使用`reverse`函数简化字符串翻转操作，减少代码量。
    - 处理16进制：通过ASCII码值转换，简洁地将16进制字符与数字相互转换。

可拓展之处：同类型题可涉及不同进制间的复杂运算、更大数据范围的高精度处理等。类似算法套路为对于涉及大数运算且数据范围较大时，考虑高精度算法；对于判断对称结构，采用双指针法从两端向中间比较。

推荐题目：
    - [P1601 A+B Problem（高精）](https://www.luogu.com.cn/problem/P1601)：基础高精度加法题目，帮助巩固高精度运算。
    - [P2142 高精度减法](https://www.luogu.com.cn/problem/P2142)：高精度减法练习，与本题高精度运算知识点相关。
    - [P1009 阶乘之和](https://www.luogu.com.cn/problem/P1009)：结合高精度乘法与加法，锻炼综合高精度运算能力。

个人心得摘录与总结：
    - Haishu提到利用数据范围漏洞解题不可取，应按题目要求规范解题，强调了公平竞赛与正确学习态度的重要性。 

---
处理用时：41.65秒
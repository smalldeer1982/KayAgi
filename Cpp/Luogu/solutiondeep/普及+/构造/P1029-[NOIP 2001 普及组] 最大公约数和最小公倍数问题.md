# 题目信息

# [NOIP 2001 普及组] 最大公约数和最小公倍数问题

## 题目描述

输入两个正整数 $x_0, y_0$，求出满足下列条件的 $P, Q$ 的个数：

1. $P,Q$ 是正整数。

2. 要求 $P, Q$ 以 $x_0$ 为最大公约数，以 $y_0$ 为最小公倍数。

试求：满足条件的所有可能的 $P, Q$ 的个数。

## 说明/提示

$P,Q$ 有 $4$ 种：

1. $3, 60$。
2. $15, 12$。
3. $12, 15$。
4. $60, 3$。

对于 $100\%$ 的数据，$2 \le x_0, y_0 \le {10}^5$。

**【题目来源】**

NOIP 2001 普及组第二题

## 样例 #1

### 输入

```
3 60
```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕利用最大公约数（$\gcd$）和最小公倍数（$\operatorname{lcm}$）的关系来解题，即对于任意两个正整数 $a$ 和 $b$，有 $a\times b = \gcd(a,b) \times \operatorname{lcm}(a,b)$。各题解思路相似，主要差异在于实现细节和优化方式。
1. **思路**：多数题解通过枚举因数来寻找满足条件的 $P$ 和 $Q$。先根据已知条件确定 $P\times Q = x_0\times y_0$，然后枚举 $1$ 到 $\sqrt{x_0\times y_0}$ 的数 $i$，判断 $i$ 和 $\frac{x_0\times y_0}{i}$ 是否满足以 $x_0$ 为最大公约数的条件，若满足则答案增加，同时注意处理 $x_0 = y_0$ 时的重复情况。部分题解还从素因数分解角度分析问题。
2. **算法要点**：关键在于有效利用 $\gcd$ 和 $\operatorname{lcm}$ 的关系，通过枚举因数减少计算量。计算 $\gcd$ 时，部分题解使用 C++ 自带的 `__gcd` 函数，部分题解自行实现辗转相除法。
3. **解决难点**：难点在于优化枚举过程以避免超时，以及处理可能出现的重复计数情况。通过只枚举到 $\sqrt{x_0\times y_0}$，并对 $x_0 = y_0$ 的情况进行特判来解决。

### 所选的题解
1. **作者：樱雪喵 (赞：678) - 5星**
    - **关键亮点**：思路清晰，简洁明了地阐述了核心思路及优化点，代码简短且注释详细，还对评论区常见问题进行了回答。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long m,n,ans;
int main(){
    cin>>m>>n;
    if(m==n) ans--;
    n*=m;
    for(long long i=1;i<=sqrt(n);i++){
        if(n%i==0&&__gcd(i,n/i)==m) ans+=2;
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：先处理 $m = n$ 的特殊情况，将 $m$ 和 $n$ 的乘积存入 $n$，然后枚举 $1$ 到 $\sqrt{n}$ 的数 $i$，若 $i$ 是 $n$ 的因数且 $i$ 与 $\frac{n}{i}$ 的最大公约数为 $m$，则答案 $ans$ 增加 $2$，最后输出答案。
2. **作者：sochiji (赞：259) - 5星**
    - **关键亮点**：从算术基本定理出发，深入分析最大公因数和最小公倍数与素数分解式的联系，给出独特的计算方法，代码简洁易懂。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <iostream>
int main()
{
    int x, y;
    std::cin >> x >> y;
    if (y % x!= 0)
        std::cout << 0;
    else
    {
        int quotient = y / x;
        int count = 0;
        int currentFactor = 2;
        while (quotient > 1)
        {
            if (quotient % currentFactor == 0)
            {
                count++;
                while (quotient % currentFactor == 0)
                    quotient /= currentFactor;
            }
            currentFactor++;
        }
        std::cout << (1 << count);
    }
    return 0;
}
```
    - **核心实现思想**：先判断 $x$ 能否整除 $y$，若不能则输出 $0$。否则，对 $\frac{y}{x}$ 进行素因数分解，统计指数大于 $0$ 的素因子个数 $count$，最后通过位运算 $1 << count$ 得到满足条件的 $P$ 和 $Q$ 的组合数。
3. **作者：zhangboju (赞：61) - 4星**
    - **关键亮点**：详细证明了辗转相除法求 $\gcd$ 以及两数乘积与 $\gcd$ 和 $\operatorname{lcm}$ 乘积关系的定理，代码实现逐步优化，考虑了数据类型可能溢出的问题。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long x,y;
inline long long gcd(long long x,long long y)
{
    if(y==0) return x;
    return gcd(y,x%y);
}
int main()
{
    cin>>x>>y;
    long long ans=0;
    for(long long i=1;i<=sqrt(x*y);i++)
    {
        if(x*y%i==0&&gcd(i,x*y/i)==x) ans++;
    }
    ans*=2;
    if(x==y) ans--;
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：自定义辗转相除法求 $\gcd$ 的函数，枚举 $1$ 到 $\sqrt{x\times y}$ 的数 $i$，若 $i$ 是 $x\times y$ 的因数且 $i$ 与 $\frac{x\times y}{i}$ 的最大公约数为 $x$，则答案 $ans$ 增加 $1$，最后将 $ans$ 乘 $2$ 并处理 $x = y$ 的重复情况后输出。

### 最优的关键思路或技巧
1. **优化枚举范围**：只枚举 $1$ 到 $\sqrt{x_0\times y_0}$ 的数，利用 $P$ 和 $Q$ 的对称性，每找到一组满足条件的 $(P, Q)$，答案增加 $2$，避免重复计算，有效降低时间复杂度。
2. **利用数论性质**：深刻理解并运用 $\gcd$ 和 $\operatorname{lcm}$ 的关系，以及素因数分解与 $\gcd$ 和 $\operatorname{lcm}$ 的联系，从本质上分析和解决问题。

### 可拓展之处
同类型题通常围绕数论中最大公约数、最小公倍数、素因数分解等知识点，常见套路是利用数论性质简化枚举过程，优化算法。例如给定一些数论条件，求满足条件的数的组合个数或具体数值。

### 相似知识点洛谷题目
1. **P1890 [USACO03NOV] 滑雪课程设计 Ski Course Design**：涉及数论和贪心思想，通过对数据进行处理，利用数论知识优化计算。
2. **P2613 【模板】有理数取余**：考查数论中的取模运算、最大公约数等知识，需要运用数论性质解决有理数取余问题。
3. **P1072 Hankson 的趣味题**：同样围绕最大公约数和最小公倍数的性质，通过枚举和判断来求解满足条件的数，与本题思路相似。 

---
处理用时：54.14秒
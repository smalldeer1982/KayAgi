# 题目信息

# 高低位交换

## 题目描述

给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。

例如，数 $1314520$ 用二进制表示为 $0000\,0000\,0001\,0100\,0000\,1110\,1101\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\,0000\,0001\,0100$；后 $16$ 位为低位，即 $0000\,1110\,1101\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\,1110\,1101\,1000\,0000\,0000\,0001\,0100$。它即是十进制的 $249036820$。


## 样例 #1

### 输入

```
1314520
```

### 输出

```
249036820
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕高低位交换这一核心需求，采用了不同的思路和方法，大致可分为以下几类：
1. **位运算类**：利用位运算符（如`&`、`|`、`<<`、`>>`）直接对二进制位进行操作，实现高低位交换。此类方法效率高，代码简洁。
2. **模拟类**：将十进制数转换为二进制，通过数组或字符串存储二进制位，再进行高低位交换，最后转回十进制输出。这种方法思路直观，但代码相对冗长，效率较低。
3. **其他语言特性类**：如Pascal语言中的`swap`函数可直接实现高低位交换，利用语言特定功能简化操作。

难点主要在于理解位运算的原理及规则，避免数据类型溢出问题。从质量上看，位运算类题解在思路清晰度、代码可读性和优化程度上表现较好，模拟类题解相对较差。

### 所选的题解
1. **作者：HenryHuang (赞：354) - 5星**
    - **关键亮点**：详细介绍位运算知识，代码简洁高效，通过位运算精准实现高低位交换。
    - **个人心得**：最初用模拟做写了30行，后学习到老师用位运算不到10行的代码，意识到位运算的简洁性。
    - **核心代码**：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
    unsigned long long x;
    cin>>x;
    cout<<((x&0x0000ffff)<<16|(x&0xffff0000)>>16)<<endl;
}
```
    - **核心思想**：通过`&`运算符分别获取原数的高低位，再通过`<<`和`>>`运算符将高低位移动到新位置，最后用`|`运算符合并得到结果。

2. **作者：月影困 (赞：95) - 4星**
    - **关键亮点**：思路清晰，直接利用左移和右移操作实现高低位交换，代码简洁明了，同时指出读入方法和运算符优先级的注意点。
    - **核心代码**：
```cpp
#include <cstdio>
unsigned int n;

int main()
{
    scanf("%u", &n); 
    printf("%u\n", (n >> 16) + (n << 16)); 
    return 0;
}
```
    - **核心思想**：左移16位将低位转到高位，右移16位将高位转到低位，两者相加得到交换后的结果。

3. **作者：离散小波变换° (赞：54) - 4星**
    - **关键亮点**：提供两种C++解法，一种基于简单的移位相加，另一种利用位运算`&`拆分再移位组合，对知识点讲解详细。
    - **核心代码（解法一）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	unsigned int n;
	cin>>n;
	cout<<(n>>16)+(n<<16);
	return 0;
} 
```
    - **核心思想**：左移16位和右移16位后相加，利用C++运算的取模特性处理溢出问题。
    - **核心代码（解法二）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	unsigned int n;
	cin>>n;
	cout<<((n&0xffff0000)>>16)+((n&0x0000ffff)<<16);
	return 0;
} 
```
    - **核心思想**：通过`&`运算分别获取高低位，移位后相加得到交换结果。

### 最优关键思路或技巧
位运算是解决此类问题的最优思路，它直接操作二进制位，效率高且代码简洁。关键技巧在于熟练掌握位运算符`&`（与）、`|`（或）、`^`（异或）、`<<`（左移）、`>>`（右移）的用法，以及十六进制表示法（如`0x0000ffff`）在提取特定二进制位时的应用。

### 可拓展之处
同类型题通常围绕二进制位操作展开，如求二进制中1的个数、判断两个数二进制位不同的位数等。类似算法套路是深入理解位运算原理，根据题目要求灵活运用位运算符对二进制位进行提取、移位、合并等操作。

### 推荐题目
1. **P1876 [USACO06NOV]玉米田Corn Fields**：涉及位运算优化的状态压缩动态规划问题，可加深对二进制状态表示和位运算操作的理解。
2. **P1164 小A点菜**：通过二进制枚举解决背包问题，锻炼位运算在实际问题中的应用能力。
3. **P1469 [USACO2.1]数字三角形Number Triangles**：可利用位运算进行状态压缩，优化动态规划的空间复杂度，进一步掌握位运算技巧。 

---
处理用时：28.20秒
# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效求解满足 \(A - B = C\) 的数对个数展开，涉及多种思路与算法：
1. **映射（map）法**：将 \(A - B = C\) 转化为 \(A - C = B\)，用 `map` 统计每个数出现的次数，遍历数组，每次累加 `map[A - C]` 的值得到答案。此方法实现简单，但 `map` 基于平衡树实现，时间复杂度 \(O(nlogn)\)，常数较大。
2. **二分查找法**：先对数组排序，利用 `lower_bound` 和 `upper_bound` 函数（或自行实现二分查找），对于每个数 \(A\)，查找 \(A + C\) 在数组中的位置范围，差值即为满足条件的 \(B\) 的个数，累加得到答案。时间复杂度 \(O(nlogn)\)。
3. **双指针法**：排序后，通过维护两个指针，利用序列有序性，移动指针找到满足 \(A - B = C\) 的区间，统计区间内数对个数。时间复杂度 \(O(n)\)。
4. **哈希（Hash）法**：通过取模将数映射到哈希表中，解决了桶数组空间浪费问题，记录每个数出现次数，类似映射法统计答案，时间复杂度 \(O(n)\)，但需注意哈希冲突。

综合来看，双指针法和哈希法理论上时间复杂度更优，但哈希法实现稍复杂且需处理哈希冲突；映射法和二分查找法实现相对简单，实际运行效率受数据规模和具体实现影响。

### 所选的题解
- **作者：OsvaldoAsensioLopez (赞：791)  星级：5星**
    - **关键亮点**：思路清晰简洁，直接将原等式转化为便于统计的形式，利用 `map` 快速统计数的出现次数，代码可读性高。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include <iostream>
#include <map>
using namespace std;
typedef long long LL;
LL a[200001];
map<LL,LL> m;
int main() {
    int n;
    LL c;
    LL ans=0;
    cin >> n >> c;
    for(int i=1;i<=n;i++) {
        cin >> a[i];
        m[a[i]]++;
        a[i]-=c;    
    } 
    for(int i=1;i<=n;i++) ans+=m[a[i]];
    cout << ans << endl;
    return 0;
}
```
    - **核心实现思想**：先将每个数 \(A\) 出现的次数记录到 `map` 中，同时将 \(A\) 减去 \(C\)，之后遍历处理后的数组，累加每个数在 `map` 中的出现次数，即为满足条件的数对个数。
- **作者：樱花飞舞 (赞：539)  星级：5星**
    - **关键亮点**：详细介绍了二分查找相关函数 `lower_bound` 和 `upper_bound` 的用法，并巧妙运用到解题中，对算法原理阐述清晰。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long a[200001];
long N,C,ans;
int main()
{
    cin>>N>>C;
    for(int i=1;i<=N;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+N+1);
    for(int i=1;i<=N;i++)
    {
        ans+=((upper_bound(a+1,a+N+1,a[i]+C)-a)-(lower_bound(a+1,a+N+1,a[i]+C)-a));
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：先对数组排序，然后遍历数组，对于每个数 \(a[i]\)，通过 `upper_bound` 和 `lower_bound` 函数获取 \(a[i] + C\) 在数组中的位置差，累加该差值得到满足条件的数对个数。
- **作者：jins3599 (赞：461)  星级：5星**
    - **关键亮点**：提出双指针法这一高效解法，利用排序后序列的有序性，通过移动指针找到满足条件的区间，优化了时间复杂度，代码简洁明了。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2e5 + 10;
int n, c;
int a[N];
int main () 
{
	cin >> n >> c;
	for(int i = 1 ; i <= n ; i ++) cin >> a[i];
	sort(a + 1, a + 1 + n);
	int l = 1, r1 = 1, r2 = 1;
	ll ans = 0;
	for(l = 1 ; l <= n ; l ++) {
		while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
		while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
		if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
			ans += r1 - r2;
	}
	cout << ans;
	return 0;
}
```
    - **核心实现思想**：排序后，通过双指针维护满足 \(a[r1] - a[l] <= c\) 和 \(a[r2] - a[l] < c\) 的区间，当找到满足 \(a[r2] - a[l] == c\) 和 \(a[r1 - 1] - a[l] == c\) 的情况时，统计区间内数对个数并累加。

### 最优关键思路或技巧
1. **等式转化**：将 \(A - B = C\) 转化为 \(A - C = B\) 或 \(B + C = A\)，方便利用数据结构统计数对。
2. **数据结构选择**：根据数据规模和特点选择合适的数据结构，如大规模数据下，哈希表相比普通数组能更好地平衡空间和时间复杂度；`map` 可方便地统计数的出现次数。
3. **利用有序性**：对数组排序后，无论是二分查找还是双指针法，都能利用序列有序性优化查找过程，降低时间复杂度。

### 可拓展思路
同类型题常涉及等式关系的数对或组合查找，可举一反三的算法套路包括：
1. **基于排序和双指针**：适用于需要在有序序列中查找满足特定条件的元素对或区间的问题。
2. **哈希映射**：当需要快速判断元素是否存在或统计元素出现次数时，哈希表是常用手段，注意处理哈希冲突。
3. **二分查找**：在有序数组中查找特定值或满足条件的区间，可优化暴力查找的时间复杂度。

### 推荐题目
1. **P1873 砍树**：通过二分查找确定满足条件的最大砍树高度，考察二分查找的应用。
2. **P3370 【模板】字符串哈希**：利用哈希算法解决字符串匹配问题，加深对哈希算法的理解和应用。
3. **P1106 删数问题**：可使用双指针或贪心策略解决，与本题双指针思路有相似之处，锻炼优化算法的能力。

### 个人心得摘录与总结
无。 

---
处理用时：41.44秒
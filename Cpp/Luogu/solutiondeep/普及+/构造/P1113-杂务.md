# 题目信息

# 杂务

## 题目描述

John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。

当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。

John 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。

写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。


## 样例 #1

### 输入

```
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
```

### 输出

```
23
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算完成所有杂务的最短时间，由于杂务间存在先后依赖关系，形成有向无环图（DAG）。多数题解采用拓扑排序或动态规划思路：
 - **拓扑排序**：构建图结构，记录各杂务入度，将入度为0的杂务入队，通过队列遍历更新后续杂务完成时间，同时维护入度变化，当入度为0时再次入队，直至队空。
 - **动态规划**：利用杂务序号顺序，在输入时从其前驱杂务中挑选完成时间最晚的，加上自身耗时，更新当前杂务完成时间，同时更新全局最大完成时间。

### 所选4星及以上题解
 - **作者：Nishikino_Curtis（5星）**
    - **关键亮点**：思路简洁清晰，代码短小精悍，直接利用题目中杂务序号顺序特性，在输入时完成状态转移，无需复杂图结构构建与遍历。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,l,t,ans[10005],maxans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&i);
        scanf("%d",&l);
        int tmp=0;
        while(scanf("%d",&t)&&t)
            tmp=max(ans[t],tmp);
        ans[i]=tmp+l;
        maxans=max(ans[i],maxans);
    } 
    printf("%d\n",maxans);
    return 0;
 } 
```
    - **核心思想**：每次读入一个杂务的耗时`l`及其前驱杂务编号，从其前驱杂务的完成时间`ans[t]`中取最大值`tmp`，当前杂务完成时间`ans[i]`为`tmp + l`，并不断更新全局最大完成时间`maxans`。
 - **作者：Keith_2006（4星）**
    - **关键亮点**：详细介绍拓扑排序实现方法，包括记忆化搜索和BFS式拓扑排序两种方式，对拓扑排序原理及实现步骤讲解清晰，适合初学者理解。
    - **个人心得**：作者在不同时间对代码进行更新，修正笔误和初始化错误，体现对知识的不断回顾与完善。
    - **BFS式拓扑排序核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cctype>
#include <vector>
#include <queue>

#define ll long long

using namespace std;

inline int read() {
    // 读入优化函数
}

const int N=500005;

int ind[N],f[N],a[N]; 
vector <int> edge[N];
queue <int> q;

int main() {
    int n=read();
    for (int i=1;i<=n;i++) {
        int x=read();
        a[i]=read();
        while (int y=read()) {
            if (!y) break;
            edge[y].push_back(x);
            ind[x]++;
        }
    }
    for (int i=1;i<=n;i++) {
        if (ind[i]==0) {
            q.push(i);
            f[i]=a[i];
        }
    };
    while (!q.empty()) {
        int rhs=q.front();
        q.pop();
        for (int i=0;i<edge[rhs].size();i++) {
            int u=edge[rhs][i];
            ind[u]--;
            if (ind[u]==0) q.push(u);
            f[u]=max(f[u],f[rhs]+a[u]);
        }
    }
    int ans=0;
    for (int i=1;i<=n;i++) {
        ans=max(ans,f[i]);
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心思想**：首先读入杂务信息并构建图结构，记录各杂务入度`ind`。将入度为0的杂务入队，每次取出队首杂务`rhs`，遍历其出边更新后续杂务`u`的完成时间`f[u]`，同时将`u`的入度减1，若入度为0则将`u`入队，最后取所有杂务完成时间的最大值。
 - **作者：Silicon（4星）**
    - **关键亮点**：采用动态规划思路，代码简洁明了，通过状态转移方程`dp[i]=max(dp[j])+time[i]`计算各杂务最早完成时间，其中`j`是`i`的所有依赖项。
    - **核心代码**：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=10100;
int n,value,number,max,to,f[maxn],num;
int main()
{
    scanf("%d",&n);
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&num);
        scanf("%d",&value);
        max=0;
        scanf("%d",&to);
        while(to)
        {
            if(f[to]>max) max=f[to];
            scanf("%d",&to);
        }
        f[i]=max+value;
    }
    max=0;
    for(int i=1;i<=n;i++)
        if(f[i]>max)
            max=f[i];
    printf("%d\n",max);
    return 0;
}
```
    - **核心思想**：每次读入杂务`i`的耗时`value`及其前驱杂务编号，从其前驱杂务的完成时间`f[to]`中取最大值`max`，当前杂务完成时间`f[i]`为`max + value`，最后取所有杂务完成时间的最大值。

### 最优关键思路或技巧
 - **利用杂务序号顺序**：如Nishikino_Curtis的题解，利用杂务`k`的准备工作只在杂务`1`至`k - 1`中的特性，在输入时直接从已处理的前驱杂务中获取信息进行状态转移，简化代码实现。
 - **拓扑排序与动态规划结合**：在拓扑排序过程中，通过动态规划思想维护每个杂务的最早完成时间，利用图结构清晰展现杂务依赖关系，准确计算结果。

### 可拓展思路
此类题目属于DAG上的动态规划问题，常见拓展方向为增加条件或改变限制，如杂务存在资源限制、杂务间有收益关系等。类似算法套路包括在DAG上进行最长路径、最短路径、关键路径计算等，以及结合其他算法如缩点算法解决更复杂的图结构问题。

### 推荐相似题目
 - **P4017 最大食物链计数**：同样基于有向无环图，通过拓扑排序统计食物链数量，考察对图结构和拓扑排序应用的理解。
 - **P1983 车站分级**：利用拓扑排序确定车站等级关系，需要根据题目条件构建合适的图结构并进行处理。
 - **P3387 【模板】缩点**：涉及有向图强连通分量缩点后进行拓扑排序，综合考察图论多个知识点，难度相对较高。 

---
处理用时：37.46秒
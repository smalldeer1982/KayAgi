# 题目信息

# [ZJOI2007] 时态同步

## 题目描述

小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。

在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。

激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？

## 说明/提示

- 对于 $40\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 5\times 10^5$。

对于所有的数据，$1\le t_e\le 10^6$。

## 样例 #1

### 输入

```
3
1
1 2 1
1 3 3
```

### 输出

```
2
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何使树中所有叶子节点到根节点的距离在通过增加边权操作后达到相等，且使操作次数最少。多数题解采用树形DP或贪心结合DFS的方法。树形DP思路通过状态转移方程计算每个节点相关值，进而得出答案；贪心思路基于越靠近根节点调整边权代价越小原则，在DFS过程中进行处理。各题解在思路清晰度、代码可读性、优化程度上存在差异。
- Mathison题解（5星）
  - 关键亮点：思路清晰，先点明调整靠近根节点树枝代价小的核心思想，并用节点深度类比距离辅助理解，代码简洁明了，直接通过DFS实现核心逻辑。
  - 个人心得：无
  - 核心代码实现思想：通过`dfs`函数，先递归更新子树中根节点和叶子节点的最大距离`dis[x]`，再累加每次调整的代价`ans += dis[x] - (dis[y] + z)`。
```cpp
void dfs(int x,int fa)
{
    for(int i=head[x];i;i=next[i])
    {
        int y=ver[i],z=edge[i];
        if(y==fa) continue;
        dfs(y,x);
        dis[x]=max(dis[x],dis[y]+z);
    }
    for(int i=head[x];i;i=next[i])
    {
        int y=ver[i],z=edge[i];
        if(y==fa) continue;
        ans+=dis[x]-(dis[y]+z);
    }
}
```
- Social_Zhao题解（4星）
  - 关键亮点：定义清晰的状态变量，如`f[i]`表示以`i`为根的子树上至少增加多少权值才能完成统一，`maxn[i]`表示以`i`为根的子树到叶节点的最长链长度，动规方程推导详细，并对动规方程进行化简以优化计算。
  - 个人心得：无
  - 核心代码实现思想：在`dfs`函数中，先递归处理儿子节点，更新`maxn[u]`和`sum`，最后通过`f[u] += maxn[u] * cnt - sum`进行状态转移。
```cpp
void dfs(int u, int fa) 
{
    f[u] = 0; 
    maxn[u] = 0;
    int sum = 0, cnt = 0;
    for(int i = head[u]; i; i = edge[i].nxt) {
        int v = edge[i].v;
        if(v == fa) continue;
        dfs(v, u); 
        cnt++;	
        int w = edge[i].w; 
        f[u] += f[v]; 
        maxn[u] = max(maxn[v] + w, maxn[u]); 
        sum += maxn[v] + w; 
    }
    f[u] += maxn[u] * cnt - sum; 
}
```
- eros1on题解（4星）
  - 关键亮点：明确为树形DP板子题，状态定义简洁，`dp_x`为叶子结点到`x`结点的最大时间，状态转移方程和答案计算式清晰，代码结构完整。
  - 个人心得：无
  - 核心代码实现思想：通过`dfs`函数，先递归更新`dp[u]`为子树中的最大时间，再累加`ans += (dp[u] - dp[v] - p->w)`计算答案。
```cpp
void dfs(int u) {
    int v; vis[u] = true;
    for(edge *p = h[u]; p; p = p->next)
        if(!vis[v = p->v]) {
            fa[v] = u, dfs(v);
            dp[u] = max(dp[u], dp[v] + p->w);
        }
    for(edge *p = h[u]; p; p = p->next)
        if((v = p->v)!= fa[u])
            ans += (dp[u] - dp[v] - p->w);
}
```
• 最优关键思路或技巧：普遍利用树形结构特点，从叶子节点向根节点进行处理。通过DFS遍历树，在回溯过程中进行状态更新和答案计算。利用贪心思想，优先在靠近根节点的边进行权值调整，以达到最小操作次数。在代码实现上，通过合理定义状态变量和状态转移方程简化计算过程。
• 可拓展之处：此类题目属于树形结构上的优化问题，类似套路可应用于其他树相关的权值调整、路径优化等问题。例如，在一些需要对树中路径长度进行统一或优化的场景中，可借鉴这种从叶子到根的处理方式和贪心思想。
• 相似知识点洛谷题目：
  - P2015 二叉苹果树：在二叉树上进行剪枝操作，保留一定数量树枝使总权值最大，考察树形DP。
  - P1352 没有上司的舞会：在有向无环图（树结构）上进行DP，每个节点有权值，选择节点使总权值最大且父子节点不能同时选。
  - P3398 仓鼠找sugar：树上两点间距离、LCA（最近公共祖先）相关问题，结合树的遍历和距离计算。 

---
处理用时：31.08秒
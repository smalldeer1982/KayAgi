# 题目信息

# 连续自然数和

## 题目描述

对一个给定的正整数 $M$，求出所有的连续的正整数段（每一段至少有两个数），这些连续的自然数段中的全部数之和为 $M$。

例子：$1998+1999+2000+2001+2002 = 10000$，所以从 $1998$ 到 $2002$ 的一个自然数段为 $M=10000$ 的一个解。


## 样例 #1

### 输入

```
10000
```

### 输出

```
18 142 
297 328 
388 412 
1998 2002
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何找出所有连续自然数段，使其和为给定正整数M。思路可分为以下几类：
1. **暴力枚举**：枚举首项和末项，通过等差数列求和公式判断是否满足和为M。如chy010827的题解，直接双重循环枚举，但时间复杂度高，为$O(n^2)$，易超时。
2. **优化枚举**：
    - **枚举因数**：将$2M$分解为两个因数$k_1,k_2$，通过解方程组得到首项和末项。如gzw2005的题解，利用$k_1,k_2$一奇一偶保证首末项为整数，时间复杂度$O(\sqrt M)$。
    - **枚举长度**：枚举连续自然数段的长度，根据等差数列求和公式判断是否存在满足条件的首项和末项。如fighter_OI的题解，分奇数和偶数长度讨论，判断首项是否越界。
3. **双指针法（尺取法）**：用两个指针代表区间的左右端点，根据当前区间和与M的大小关系移动指针。如Frenix的题解，指针单调向右移动，时间复杂度$O(n)$。
4. **前缀和**：先计算前缀和数组，再通过枚举区间端点或二分查找找到满足和为M的区间。如Log_x的题解，直接枚举区间端点判断；feecle6418的题解则利用二分查找优化，时间复杂度$O(nlog_2n)$。
5. **数学推导**：通过等差数列求和公式推导，利用一元二次方程求根公式或其他数学性质求解。如lamboo的题解，通过求解一元二次方程判断是否存在满足条件的末项。

综合来看，gzw2005的题解思路清晰，代码简洁且优化程度高，通过因数分解和奇偶性判断高效求解；Frenix的尺取法思路巧妙，时间复杂度较低；feecle6418的二分查找法在前缀和基础上进行优化，也有较高的质量。

### 所选的题解
1. **作者：gzw2005 (赞：526)  星级：5星**
    - **关键亮点**：通过将$2M$分解因数，利用奇偶性快速确定满足条件的连续自然数段，时间复杂度低至$O(\sqrt M)$，思路清晰，代码简洁高效。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m;
int main(){
    cin>>m;
    for(int k1=sqrt(2*m);k1>1;k1--)//枚举k1(注意是k1>1而不是k1>=1)
        if(2*m%k1==0 && (k1+2*m/k1)%2){//如果K2是整数而且与K1一奇一偶
            int k2=2*m/k1;
            cout<<(k2-k1+1)/2<<" "<<(k1+k2-1)/2<<endl;//输出答案
        }
    return 0;
}
```
    - **核心实现思想**：先对$2M$进行因数分解，枚举其中一个因数$k_1$，计算出另一个因数$k_2 = 2M / k_1$。通过判断$k_1,k_2$一奇一偶，确保由方程组解得的首项和末项为整数，从而找到满足条件的连续自然数段。
2. **作者：Frenix (赞：151)  星级：4星**
    - **关键亮点**：运用尺取法，通过双指针移动动态调整连续自然数段，时间复杂度为$O(n)$，直观且高效。
    - **重点代码**：
```cpp
#include<cstdio>
int m;
int main()
{
    scanf("%d",&m);
    int sum=3;
    for(int i=1,j=2;i<=m/2;)
    {
        if(sum==m)
        {
            printf("%d %d\n",i,j);
            sum-=i;
            i++;
        }
        else if(sum<m)
        {
            j++;
            sum+=j;
        }
        else 
        {
            sum-=i;
            i++;
        } 
    }
    return 0;
}
```
    - **核心实现思想**：用$i,j$分别表示区间的左右端点，$sum$记录当前区间和。根据$sum$与$m$的大小关系移动指针，当$sum == m$时输出区间，通过动态调整区间来找到所有满足条件的连续自然数段。
3. **作者：feecle6418 (赞：14)  星级：4星**
    - **关键亮点**：利用前缀和数组的有序性，结合二分查找优化暴力枚举，时间复杂度优化到$O(nlog_2n)$。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
LL n,a[2000001]={0,1};
int search(int l,int r,LL kk){//直接替换掉原来暴力代码的第二层循环就好啦！
    if(l>r)return -1;
    int m=(l+r)/2;
    if(a[m]-kk==n)return m;
    else if(a[m]-kk>n)search(l,m-1,kk);
    else if(a[m]-kk<n)search(m+1,r,kk);
}
int main(){
    cin>>n;
    for(int i=2;i<=n;i++){
        a[i]=a[i-1]+i;
    }
    for(int i=0;i<n-1;i++){
        int j=search(i+1,n,a[i]);
        if(j!=-1)cout<<i+1<<' '<<j<<'\n';
    }
    return 0;
}
```
    - **核心实现思想**：先计算前缀和数组$a$，对于每个前缀和$a[i]$，通过二分查找找到满足$a[j] - a[i] = n$的$j$，即找到满足条件的连续自然数段。

### 最优关键思路或技巧
1. **因数分解与奇偶性判断**：将$2M$分解因数，利用因数的奇偶性确定首项和末项为整数，有效降低时间复杂度。
2. **尺取法**：通过双指针动态调整区间，在$O(n)$时间内找到所有解，直观且高效。
3. **前缀和结合二分查找**：利用前缀和数组的有序性，通过二分查找优化暴力枚举，平衡了时间复杂度和代码实现难度。

### 可拓展之处
同类型题或类似算法套路：
1. **子数组和问题**：给定一个数组，找出和为特定值的连续子数组。可采用类似的尺取法或前缀和结合二分查找的方法。
2. **等差数列相关问题**：如已知等差数列的和及部分项，求其他项或项数等问题，可利用等差数列的性质和公式求解。

### 推荐题目
1. **P1439 【模板】最长公共子序列**：涉及动态规划和序列处理，与本题在处理连续序列问题上有相似之处，可锻炼对序列的操作和优化能力。
2. **P2032 扫描**：可使用尺取法解决，通过移动窗口来满足特定条件，与本题尺取法思路类似。
3. **P1115 最大子段和**：通过前缀和与动态规划求解，与本题前缀和的应用有一定关联，可加深对前缀和优化的理解。

### 个人心得摘录与总结
1. **lamboo**：在使用一元二次方程求根公式时，注意要先保存变量值，否则在计算过程中可能因数据类型暂存问题导致错误。总结：在涉及复杂计算时，要注意变量的存储和数据类型转换，避免因细节问题出错。
2. **feecle6418**：二分查找虽然优化了时间复杂度，但在本题中仍可能因数据规模导致效率问题，看到别人更高效的8ms代码感到惭愧。总结：算法优化不仅要考虑理论复杂度，还需结合实际数据规模和运行效率，不断探索更优解法。 

---
处理用时：47.14秒
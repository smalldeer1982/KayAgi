# 题目信息

# 拱猪计分

## 题目描述

「拱猪」是一种很有趣的扑克牌游戏。即使你不知道它的玩法，你也可以由它的计分方式来了解它的趣味性。假设在此我们仅考虑四个人的拱猪牌局，本题要求你根据下面的计分规则，在牌局结束时计算四位玩家所得分数。

1. 我们分别以 $\texttt S, \texttt H, \texttt D, \texttt C$ 来代表黑桃、红心、方块及梅花，并以数字 $1$ 至 $13$ 来代表 $\texttt A, \texttt 2, \dots, \texttt Q, \texttt K$ 等牌点，例如：$H_1$ 为红心 $\texttt A$，$S_{13}$ 为黑桃 $\texttt K$；
2. 牌局结束时，由各玩家持有的有关计分的牌（计分牌）仅有「猪」$S_{12}$，所有红心牌，「羊」$D_{11}$ 及「加倍」$C_{10}$ 等 $16$ 张牌，其它牌均弃置不计，若一位玩家未持有这 $16$ 张牌中任意一张，则以得零分计算；
3. 若持有 $C_{10}$ 牌的玩家只有该张牌而没有任何其它牌则得 $+50$ 分，否则将其它计分牌所得分数加倍计算；
4. 若红心牌不在同一家，则 $H_1$ 至 $H_{13}$ 等 $13$ 张牌均以负分计，其数值依次为 $-50, -2, -3, -4, -5, -6, -7, -8, -9, -10, -20, -30, -40$，且 $S_{12}$ 与 $D_{11}$ 的分值分别以 $-100$ 及 $+100$ 分计算；
5. 若红心牌 $H_1$ 至 $H_{13}$ 均在同一家，则有下列情形：

+ 所有红心牌以 $+200$ 分计算。
+ 若 $S_{12}, D_{11}$ 皆在吃下所有红心牌之一家，则此玩家得 $+500$ 分。
+ $C_{10}$ 牌依旧以前文所述原则计算。

例一：若各玩家持有计分牌如下：

1. `S12 H3 H5 H13`
2. `D11 H8 H9`
3. `C10 H1 H2 H4 H6 H7`
4. `H10 H11 H12`

则各家之得分依序为：$-148, +83, -138$ 及 $-60$。

例二：若各玩家持有计分牌如下：

1. `H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13`
2. `S12 C10`
3. `D11`
4. 无

则各家之得分依序为：$+200, -200, +100$ 及 $0$。

例三：若有一玩家持有所有 $16$ 张计分牌，则得 $+1000$ 分，其余三家均得零分。

## 样例 #1

### 输入

```
4  S12  H3  H5  H13
3  D11  H8  H9
6  C10  H1  H2  H4  H6  H7
3  H10  H11 H12
13 H1  H2  H3  H4  H5  H6  H7  H8  H9  H10  H11  H12  H13  
2  S12  C10
1  D11
0
0
0
0
0
```

### 输出

```
-148 +83 -138 -60
+200 -200 +100 0
```

# AI分析结果

这是一道关于拱猪计分规则的模拟题，题解主要围绕如何根据给定规则计算玩家得分展开。

### 综合分析与结论
- **思路**：多数题解采用逐个处理玩家手牌的方式，通过判断手牌中各类计分牌（如红心牌、猪牌S12、羊牌D11、加倍牌C10）的情况，依据规则计算得分。部分题解先统计所有玩家手牌后统一计算，部分则是单个玩家处理后直接计算得分。
- **算法要点**：利用数组、结构体等数据结构存储手牌信息，通过循环遍历手牌判断牌的类型和数量，根据红心牌是否集齐、其他特殊牌的持有情况等，按照规则进行分数计算。
- **解决难点**：规则复杂，需准确处理不同条件下的计分逻辑，如红心牌集齐与未集齐的不同计分方式，加倍牌C10的特殊计分规则等。同时，要注意输出格式，正数前需加“+”号。

综合来看，各题解思路相近，主要差异在于代码实现的细节和方式，如数据结构的选择、判断逻辑的组织等。

### 题解评分
1. **作者：Diaоsi (赞：24)**：4星
    - **关键亮点**：思路清晰，代码结构完整，详细注释了代码实现过程，并指出题目中易混淆点，如输出格式、题目条件表述不清之处等，对读者理解题目和代码有较大帮助。
    - **个人心得**：指出题目不支持动态输出，需预存答案再输出；正数前要加符号；H牌拿满后若单独存在D11、S12牌也要扣分；H牌拿满只加200分；数据太弱，A了之后才发现持满16张牌加1000分的条件。
```cpp
// 计算得分函数
int score(){
    int ans = 0;
    int cntH = 0, cntC10 = 0;
    int cntS12 = 0, cntD11 = 0;
    int bothS12D11 = 0;
    for (int i = 0; i < s.size(); i++){
        if (s[i][0] == 'H')cntH++;
        if (s[i][0] == 'C' && s[i][1] == '1' && s[i][2] == '0')cntC10++;
        if (s[i][0] == 'S' && s[i][1] == '1' && s[i][2] == '12')cntS12++;
        if (s[i][0] == 'D' && s[i][1] == '1' && s[i][2] == '11')cntD11++;
        if (cntD11 && cntS12)bothS12D11++;
    }
    if (cntH == 13 &&!bothS12D11)ans += 200;
    else if (cntH == 13 && bothS12D11)ans += 500;
    if (s.size() == 1 && cntC10)ans += 50;
    if (cntS12 &&!bothS12D11)ans += S12;
    if (cntD11 &&!bothS12D11)ans += D11;
    if (cntH < 13){
        for (int i = 0; i < s.size(); i++){
            if (s[i][0] == 'H' && s[i][1] == '1' && s[i].size() == 2)ans += H[1];
            if (s[i][0] == 'H' && s[i][1] == '2' && s[i].size() == 2)ans += H[2];
            // 类似判断其他红心牌
        }
    }
    if (s.size() > 1 && cntC10)ans <<= 1;
    return ans;
}
```
核心实现思想：通过遍历玩家手牌，统计各类计分牌数量，根据红心牌是否集齐、猪牌和羊牌是否同时存在等条件，按照规则计算得分。若有加倍牌C10且不止一张牌时，分数加倍。

2. **作者：juruo_zjc (赞：12)**：4星
    - **关键亮点**：详细分析题目条件，将计分牌分值存入数组，使用二维数组sum记录玩家手牌情况，代码逻辑清晰，对循环和判断语句的解释详细，便于理解。
    - **个人心得**：无
```cpp
// 主函数核心部分
for (int i = 1; i <= 4; i++){
    int ok = 1;
    curans = 0;
    for (int j = 1; j <= 13; j++)
        if (sum[i][j] == 0){
            ok = 0;
            break;
        }
    if (ok){
        if (sum[i][14] && sum[i][15])curans += 500;
        else curans += 200 + ((sum[i][14])? 1 : 0)*Fs[14]
                         + ((sum[i][15])? 1 : 0)*Fs[15];
        if (sum[i][16])curans *= 2;
        if (curans > 0)printf("+%d ", curans);
        else printf("%d ", curans);
    }
    else{
        ok = 1;
        for (int j = 1; j <= 15; j++)
            if (sum[i][j]){
                ok = 0;
                break;
            }
        if (ok == 1){
            if (sum[i][16])printf("+50 ");
            else printf("0 ");
        }
        else{
            for (int j = 1; j <= 15; j++)curans += ((sum[i][j])? 1 : 0)*Fs[j];
            if (sum[i][16])curans *= 2;
            if (curans > 0)printf("+%d ", curans);
            else printf("%d ", curans);
        }
    }
}
```
核心实现思想：通过遍历判断玩家是否集齐红心牌，若集齐，再根据猪牌和羊牌的持有情况计算得分，有加倍牌则分数加倍；若未集齐，判断是否仅有加倍牌，否则按各计分牌分值计算得分。

3. **作者：uniqueharry (赞：5)**：4星
    - **关键亮点**：提出一个数据一个数据处理的思路，减少数组使用，通过设置多个标志变量判断手牌情况，代码简洁明了，对输入输出处理细致。
    - **个人心得**：无
```cpp
// 主函数核心部分
while (cin >> num){
    time++;
    for (int i = 1; i <= num; i++)
        cin >> c[i].type >> c[i].point;
    for (int i = 1; i <= num; i++)
        if (c[i].type == 'H')t++;
    if (t == 13)hflag = 1;
    for (int i = 1; i <= num; i++)
        if (c[i].type == 'S' && c[i].point == 12)sflag = 1;
    for (int i = 1; i <= num; i++)
        if (c[i].type == 'D' && c[i].point == 11)dflag = 1;
    for (int i = 1; i <= num; i++){
        if (c[i].type == 'C' && c[i].point == 10)
            swap(c[i], c[num]);
        if (hflag == 1){
            if (sflag == 1 && dflag == 1)sco = 500;
            else{
                sco = 200;
                if (sflag == 1)sco -= 100;
                if (c[i].type == 'D' && c[i].point == 11)sco += 100;
            }
        }
        else{
            if (c[i].type == 'H'){
                // 根据不同红心牌点数计分
            }
            if (c[i].type == 'S' && c[i].point == 12)sco -= 100;
            if (c[i].type == 'D' && c[i].point == 11)sco += 100;
        }
        if (c[i].type == 'C' && c[i].point == 10){
            if (num == 1)sco = 50;
            else sco *= 2;
        }
    }
    ans[time] = sco;
    // 重置变量
}
```
核心实现思想：读入每个玩家手牌，通过标志变量判断红心牌是否集齐、是否有猪牌和羊牌，根据不同情况计分，处理加倍牌C10的特殊计分规则，最后将得分存入数组统一输出。

### 最优关键思路或技巧
- **数据结构选择**：使用数组或结构体存储手牌信息，方便统计和判断。如用数组记录每种牌是否存在，或用结构体存储牌的花色和点数。
- **条件判断优化**：在判断红心牌是否集齐时，部分题解通过设置标志变量，在遍历手牌过程中直接判断，减少重复遍历。例如遍历红心牌时，若发现有一张不存在则直接判定未集齐，提高效率。
- **代码模块化**：部分题解将计分逻辑封装成函数，使代码结构更清晰，易于维护和调试。如将计算单个玩家得分的过程封装成函数，主函数中只需调用该函数进行计算。

### 可拓展之处
此类题目属于模拟类算法题，类似套路是仔细梳理题目规则，将复杂规则拆解为多个简单判断条件，利用合适的数据结构存储数据，通过循环和条件判断实现规则。同类型题可考察不同游戏计分规则、任务调度规则等模拟场景。

### 相似知识点洛谷题目推荐
- **P1085 [NOIP2004 普及组] 不高兴的津津**：通过模拟每天的活动安排，根据给定规则计算津津的不高兴程度，考察对简单规则的模拟实现。
- **P1909 买铅笔**：根据不同包装铅笔的价格和数量，以及所需铅笔总数，模拟计算购买铅笔的最小花费，涉及多种情况的判断和计算。
- **P5717 【深基3.例8】三位数排序**：通过模拟排序过程，对输入的三个三位数进行排序输出，考察基本的逻辑判断和代码实现能力。 

---
处理用时：50.85秒
# 题目信息

# 树的重量

## 题目描述

树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重构相应的“进化树”。

令 $N=\{1,2,3,\cdots ,n\}$，用一个 $N$ 上的矩阵 $M$ 来定义树 $T$。其中，矩阵 $M$ 满足：对于任意的 $i$，$j$，$k$，有 $M[i,j]+M[j,k] \ge M[i,k]$。树 $T$ 满足：

1. 叶节点属于集合 $N$；
2. 边权均为非负整数；
3. $d_T(i,j)=M[i,j]$，其中 $d_T(i,j)$ 表示树上 $i$ 到 $j$ 的最短路径长度。

如下图，矩阵 $M$ 描述了一棵树。

$$M=\begin{bmatrix}
0 & 5 & 9 & 12 & 8 \\
5 & 0 & 8 & 11 & 7 \\
9 & 8 & 0 & 5 & 1 \\
12 & 11 & 5 & 0 & 4 \\
8 & 7 & 1 & 4 & 0 \\
\end{bmatrix}$$

树的重量是指树上所有边权之和。对于任意给出的合法矩阵 $M$，它所能表示树的重量是惟一确定的，不可能找到两棵不同重量的树，它们都符合矩阵 $M$。你的任务就是，根据给出的矩阵 $M$，计算 $M$ 所表示树的重量。下图是上面给出的矩阵 $M$ 所能表示的一棵树，这棵树的总重量为 $15$。

![](https://cdn.luogu.com.cn/upload/image_hosting/dnk8ys2t.png)


## 样例 #1

### 输入

```
5
5 9 12 8
8 11 7
5 1
4
```

### 输出

```
15

```

## 样例 #2

### 输入

```
4
15 36 60
31 55
36```

### 输出

```
71```

# AI分析结果

• **综合分析与结论**：这些题解主要围绕通过给定的表示叶节点间距离的矩阵来计算树的重量这一问题。思路核心在于利用树的性质和节点间距离关系逐步构建树并累加边权。算法要点是从简单情况（n=2, n=3）推导通用公式，通过枚举节点找到新节点加入树时增加的最小边权。解决难点在于理解如何确定新节点在已有树结构中的最佳插入位置及对应边权计算。大部分题解思路相近，部分题解在证明和代码实现上有差异。
• **所选的题解**：
  - **作者：TsReaper (赞：160)  星级：4星**
    - **关键亮点**：思路清晰，从简单情况逐步推导复杂情况，通过图形辅助说明节点分叉和边权计算方式，易于理解。
  - **作者：Mathison (赞：47)  星级：4星**
    - **关键亮点**：明确指出算法具有贪心性质，给出详细的公式推导和简洁的代码实现，逻辑连贯。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dis[35][35];
int main()
{
    while(~scanf("%d",&n))
    {
        if(!n) break; 
        for(int i=1;i<n;i++)
            for(int j=i+1;j<=n;j++)
                scanf("%d",&dis[i][j]);
        int ans=dis[1][2];
        for(int i=3;i<=n;i++)
        {
            int tmp=0x7fffffff;
            for(int j=2;j<i;j++) 
                tmp=min(tmp,(dis[1][i]-dis[1][j]+dis[j][i])/2);
            ans+=tmp;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```
核心实现思想：先读入距离矩阵，初始化答案为dis[1][2]，然后对于从3到n的每个节点i，枚举已在树中的节点j，计算新节点i从1到j路径上分叉出来的边权并取最小值，累加到答案中。
  - **作者：dzz1537568241 (赞：25)  星级：4星**
    - **关键亮点**：详细分析树上最短路性质，通过引理证明取最小距离的正确性，代码实现与分析紧密结合。
```cpp
#include <iostream>
#define INF 0x3f3f3f
using namespace std;
int ans = 0, N = 0;
const int maxn = 45;
int d[maxn][maxn];
int main(){
	cin>> N;
	while(N){
		ans = 0;
		for(int i = 1; i <= N; i++){
			for(int j = i + 1; j <= N; j++){
				cin>>d[i][j];
				d[j][i] = d[i][j];
			}
		}
		
		int v = 1;
		for(int u = 1; u <= N; u++){
			int len = INF;
			for(int t = 1; t < u; t++){
				len = min(len, (d[u][v] + d[u][t] - d[v][t]) >> 1);
			}
			if(len!= INF)ans += len; 
		}
		cout<< ans<< endl;
		cin>>N;
	}
}
```
核心实现思想：读入距离矩阵后，假想一个根节点v，对每个节点u，枚举已在树中的节点t，计算u到树的距离（取最小值）并累加到答案中。
• **最优关键思路或技巧**：从简单情况（n=2, n=3）入手，推导得出新节点加入树时边权的计算方法，即通过枚举已在树中的节点对，利用节点间距离关系计算新节点到树的最小距离，采用贪心策略保证每次加入新节点时增加的边权最小，从而得到树的最小重量。
• **同类型题或类似算法套路**：此类题目通常围绕树的结构和节点间距离关系，通过给定的距离信息反推树的某些属性（如边权和）。类似算法套路是从简单情况找规律，利用贪心思想确定最优的节点连接方式。
• **推荐洛谷题目**：
  - [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)：根据给定的遍历序列构建二叉树并计算相关值，考察树的构建和遍历。
  - [P1030 求先序排列](https://www.luogu.com.cn/problem/P1030)：通过中序和后序遍历序列确定先序遍历序列，涉及树的遍历和结构推导。
  - [P2006 赵神的游戏](https://www.luogu.com.cn/problem/P2006)：利用树的性质和节点关系进行路径长度计算，与本题在树的性质运用上有相似之处。
• **个人心得摘录与总结**：部分作者提到思考过程中对题目性质的推导和理解花费较多时间，如理解如何通过节点间距离确定边权，以及证明贪心策略的正确性。还有作者分享了看错题面或对某些概念理解有误导致解题困难的经历，强调仔细审题和深入理解题意的重要性。 

---
处理用时：29.79秒
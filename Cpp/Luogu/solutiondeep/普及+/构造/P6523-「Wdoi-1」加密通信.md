# 题目信息

# 「Wdoi-1」加密通信

## 题目背景

自月战之后，八云紫在槐安通道中设立了一重结界，使得从地面传向月都的信息全部会被拦截和破译。  

为了维持正常的通讯，八意永琳同月兔们研究出了一种全新的加密方式。

## 题目描述

首先，八意永琳会写出需要被加密的明文 $A$ ，此段明文由 $n-1$ 个正整数构成。

之后，她会构造出一个由 $n$ 个**质数**构成的密文 $B$，满足对  $\forall  i \in [1,n),B_i \times B_{i + 1} = A_i$。

为了提高信息的利用率，八意永琳规定 $B$ 中出现的所有质数的值必须在 $[1,M]$ 范围内。

## 说明/提示

#### 数据规模

- 对于 $20\%$ 的数据，$n \le 5,M \le 10$。

- 对于 $40\%$ 的数据，$A_i \le 10 ^ {12}$。

- 对于 $70\%$ 的数据， $A_i \neq A_{i + 1}$。

- 对于$100\%$的数据，$3 \le n \le 10 ^ 5$，$1 \le A_i,M \le 10 ^ {18}$，$1 \le T \le 5$。

- 以上几档部分分呈**包含关系**，$100\%$ 包含 $70\%$，$70\%$ 包含 $40\%\ \ldots\ldots$以此类推。

#### 数据保证：

- 若不考虑 $b_i$ 在 $[1,M]$ 范围内的条件，必然有至少一组合法解。

- 有至少一对 $(i,j)$，使得 $A_i \neq A_j$。

#### 后置资料

**本段资料与答题相关性不大**。

[百度百科 - 质数](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fr=aladdin)

## 样例 #1

### 输入

```
2
4 233
55 35 77
4 5
55 35 77 ```

### 输出

```
11 5 7 11 
-1```

# AI分析结果

### 综合分析与结论
这些题解思路大致相同，均利用了题目给定的两个关键条件：不考虑范围限制一定有解，且至少存在一对 $(i,j)$ 使得 $A_i\neq A_j$。通过分析 $A_i = B_i\times B_{i + 1}$ 和 $A_{i + 1} = B_{i + 1}\times B_{i + 2}$ 的关系，得出 $B_{i + 1} = \gcd(A_i, A_{i + 1})$ 的结论。解题关键在于找到 $A_i\neq A_{i + 1}$ 的位置，求出对应的 $B_i$，再向两侧递推得到整个密文 $B$ 数组，并判断是否有元素大于 $M$。

### 所选的题解
1. **作者：Aw顿顿 (赞：16)  星级：4星**
    - **关键亮点**：思路清晰，简洁阐述了题意和解题思路，强调从题目条件找到突破口，利用最大公因数关系解题，虽未给出代码但逻辑完整。
2. **作者：pigstd (赞：8)  星级：4星**
    - **关键亮点**：代码实现清晰，详细展示了从寻找 $A_i\neq A_{i + 1}$ 的位置，到求最大公因数确定一个密文元素，再向两端递推密文数组，最后判断输出结果的完整过程。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int M=1e5+10;
int T;
int a[M],ans[M];

int gcd(int a,int b)
{
    return b==0?a:gcd(b,a%b);
}//求最大公因数

inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}

signed main()
{
    T=read();
    while(T--)
    {
        memset(a,0,sizeof(a));
        memset(ans,0,sizeof(ans));
        int n=read(),m=read(),ooo;
        for (int i=1;i<n;i++)
            a[i]=read();
        for (int i=1;i<n-1;i++)
            if (a[i]!=a[i+1])
                {int k=gcd(a[i],a[i+1]);ans[i+1]=k,ooo=i+1;break;}//找到其中的一个密文，ooo作为标记改密文的位置
        for (int j=ooo-1;j>=1;j--)
            ans[j]=a[j]/ans[j+1];//向前推密文
        for (int j=ooo+1;j<=n;j++)
            ans[j]=a[j-1]/ans[j-1];//向后推密文
        int flag=1;
        for (int i=1;i<=n;i++)
            if (ans[i]>m)
                {flag=0;break;}//判断是否有质数大于m
        if (!flag)
            printf("-1\n");
        else
            for (int i=1;i<=n;i++)
                printf("%lld ",ans[i]);
        printf("\n");//输出
    }
    return 0;
}
```
    - **核心实现思想**：通过 `read` 函数读入数据，在 `main` 函数中，先找到 `a[i]!=a[i + 1]` 的位置，计算其最大公因数确定 `ans[i + 1]`，再分别向前和向后递推得到整个 `ans` 数组，最后判断 `ans` 数组元素是否有大于 `m` 的，根据结果输出相应内容。
3. **作者：bifanwen (赞：0)  星级：4星**
    - **关键亮点**：对不同数据范围进行了详细算法分析，从低分到满分算法逐步讲解，思路清晰，对理解题目本质和解题方法很有帮助。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int num[102444], b[123232], t, n, m, di;

signed main() {
    cin >> t;
    while (t--) {
        int fl = 1, fla = 1;
        cin >> n >> m;
        --n;
        cin >> num[1];
        for (int i = 2; i <= n; i++) {
            cin >> num[i];
            if (num[i]!= num[i - 1] && fla) {
                di = i - 1;
                fla = 0;
            }
        }
        b[di + 1] = __gcd(num[di], num[di + 1]);
        ++di;
        for (int i = di + 1; i <= n + 1; i++) b[i] = num[i - 1] / b[i - 1];
        for (int i = di - 1; i >= 1; i--) b[i] = num[i] / b[i + 1];
        for (int i = 1; i <= n + 1; i++)
            if (b[i] > m && fl) {
                puts("-1");
                fl = 0;
            }
        if (!fl) continue;
        for (int i = 1; i <= n + 1; i++) cout << b[i] << " ";
        cout << "\n";
    }
}
```
    - **核心实现思想**：读入数据后，找到 `num[i]!=num[i - 1]` 的位置，计算对应最大公因数确定 `b[di + 1]`，然后分别向前后递推得到整个 `b` 数组，最后判断 `b` 数组元素是否有大于 `m` 的，根据结果输出。

### 最优关键思路或技巧
利用题目所给条件，通过分析相邻 $A_i$ 的关系，得出利用最大公因数确定密文元素的方法，避免对大数字进行质因数分解，再通过递推得到整个密文数组，这是解题的关键思路。同时，注意到数据中至少存在一组 $A_i\neq A_{i + 1}$ 是找到解题突破口的关键。

### 可拓展思路
此类题目属于构造类型题目，关键在于挖掘题目条件隐藏的性质，利用这些性质进行构造。类似套路如根据给定等式关系，寻找特殊位置或特殊值，通过这个特殊点向其他位置推导结果。同类型题可考虑一些需要根据特定条件构造数列或数组的题目。

### 相似知识点洛谷题目
1. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：通过给定的数字构造新数字，考察递推思想。
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)：根据八皇后规则构造满足条件的摆放方案，考察搜索与条件判断。
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)：根据奶酪位置构造最优路径，涉及到状态压缩和动态规划思想。

### 个人心得摘录与总结
 - **作者：Utilokasteinn**：提到不能从第一个数开始找质因数，否则在有两个相同数挨在一起时会出错，应先找到第一个与后一个数不相等的数，从该数开始向前向后推导，避免错误。总结为解题要注意数据特点，不能盲目从起始位置处理，需结合题目条件找到正确切入点。 

---
处理用时：38.73秒
# 题目信息

# [W1] 团

## 题目描述

我有一张 $n$ 个节点的无向边带权图。它的边很多，用这个方法表示：

 - 有 $k$ 个集合；第 $i$ 个集合可以表示为 $S_i=\{(T_1,W_1),(T_2,W_2),\dots,(T_{|S_i|},W_{|S_i|})\}$。
 - 对于任何两对 $(T_i,W_i),(T_j,W_j)$ 在同一个集合里面，图中会形成一条连 $T_i$ 和 $T_j$ 的边，边权为 $W_i+W_j$。

请对于所有节点 $i$ 找到 $1$ 到 $i$ 的最短路，即从 $1$ 到 $i$ 的边权和最小的简单路径。

## 说明/提示

对于前 $10\%$ 的数据，$|S_i|=2$；  
对于前 $20\%$ 的数据，$|S_i|\le10$；  
对于前 $50\%$ 的数据，$|N|\le1000,\sum|S_i|\le2000$;  
对于 $100\%$ 的数据，$1\le|N|\le2\cdot10^5,\sum|S_i|\le4\cdot10^5,0\le W_i\le10^9$。

## 样例 #1

### 输入

```
5 2
3
1 1
2 1
5 3
3
2 1
3 2
4 1```

### 输出

```
0 2 5 4 4```

# AI分析结果

• 综合分析与结论：本题主要难点在于按题意暴力建图边数过多，会导致存储困难和超时。多数题解思路是通过引入虚点（或“交换机”）优化建图，减少边数后使用最短路算法求解。算法要点是利用虚点使集合内点间接相连，满足边权要求，同时配合Dijkstra等最短路算法。
- **作者：SDqwq (赞：16)**
  - **星级**：5星
  - **关键亮点**：思路清晰，先阐述暴力解法及时间复杂度，再点明正解思路为引入虚点优化建图，并给出详细代码实现，对虚点建图的原理和优势解释到位。
  - **重点代码核心思想**：通过结构体和链式前向星存储图，利用优先队列实现堆优化的Dijkstra算法，在主函数中按虚点建图思路构建图后执行Dijkstra算法求最短路。
  - **核心代码**：
```cpp
void add (int u, int v, ll w) {
    e[++cnt].to = v;
    e[cnt].len = w;
    e[cnt].next = elast[u];
    elast[u] = cnt;
}
struct node {
    ll dis;
    int id;
    node (ll _dis, int _id) {
        dis = _dis;
        id = _id;
    }
};
bool operator < (node x, node y) {
    return x.dis > y.dis;
}
priority_queue<node> pq;
void dijkstra (int x) {
    for (int i = 1; i <= tot; i++)
        dis[i] = inf;
    dis[x] = 0;
    pq.push(node(0, x));
    while (!pq.empty()) {
        node u = pq.top();
        pq.pop();
        if (vis[u.id])
            continue;
        vis[u.id] = true;
        for (int i = elast[u.id]; i!= 0; i = e[i].next)
            if (dis[e[i].to] > dis[u.id] + e[i].len) {
                dis[e[i].to] = dis[u.id] + e[i].len;
                pq.push(node(dis[e[i].to], e[i].to));
            }
    }
}
int main () {
    scanf("%d %d", &n, &k);
    tot = n;
    for (int i = 1; i <= k; i++) {
        scanf("%d", &S);
        tot++;
        for (int j = 1; j <= S; j++) {
            scanf("%d %lld", &T[j], &W[j]);
            add(T[j], tot, W[j]);
            add(tot, T[j], W[j]);
        }
    }
    dijkstra(1);
    for (int i = 1; i <= n; i++)
        printf("%lld ", dis[i]);
    return 0;
}
```
- **作者：Mr_think (赞：8)**
  - **星级**：4星
  - **关键亮点**：以通俗易懂的语言阐述题目大意和建图思路，通过对比暴力建图和优化建图的图示，直观展示虚点建图的过程，并对其正确性进行证明，还提及可使用Dijkstra或SPFA算法，给出SPFA代码链接。
  - **重点代码核心思想**：（因未给Dijkstra代码，以SPFA思路说明）通过结构体和链式前向星存图，利用队列实现SPFA算法，在主函数中按虚点建图思路构建图后执行SPFA算法求最短路。
  - **核心代码**：（未提供，可参考链接https://www.luogu.com.cn/paste/y02t1j2k）
- **作者：PigAunt (赞：3)**
  - **星级**：4星
  - **关键亮点**：简洁明了地指出减少边数是关键，以网络通信中的“交换机”类比虚点建图，形象生动，代码实现清晰，对细节问题如虚点编号不重复有提及。
  - **重点代码核心思想**：通过结构体和链式前向星存储图，利用优先队列实现堆优化的Dijkstra算法，在主函数中按虚点建图思路构建图后执行Dijkstra算法求最短路。
  - **核心代码**：
```cpp
void Add(int a, int b, int c) {
    edges[total].to = b;
    edges[total].w = c;
    edges[total].next = head[a];
    head[a] = total++;
}
void Dijkstra(int start) {
    std::priority_queue<PLI, std::vector<PLI>, std::greater<PLI> > heap;
    for (int i = 0; i < N; i++) {
        vis[i] = false;
        dis[i] = PosInf;
    }
    dis[start] = 0;
    heap.push({0, start});
    while (!heap.empty()) {
        PLI t = heap.top();
        heap.pop();
        if (vis[t.second])
            continue;
        vis[t.second] = true;
        for (int i = head[t.second]; i!= -1; i = edges[i].next) {
            int v = edges[i].to, w = edges[i].w;
            if (dis[v] > dis[t.second] + w) {
                dis[v] = dis[t.second] + w;
                heap.push({dis[v], v});
            }
        }
    }
}
int main() {
    for (int i = 0; i < N; i++)
        head[i] = -1;
    std::cin >> n >> k;
    for (int i = 1; i <= k; i++) {
        int g = 0;
        std::cin >> g;
        for (int j = 1; j <= g; j++) {
            int a, b;
            std::cin >> a >> b;
            Add(a, n + i, b);
            Add(n + i, a, b);
        }
    }
    Dijkstra(1);
    for (int i = 1; i <= n; i++)
        std::cout << dis[i] << " ";
    std::cout << std::endl;
    return 0;
}
```
• **最优关键思路或技巧**：引入虚点优化建图，将集合内两两相连的边转化为各点与虚点相连，在满足边权要求的同时大幅减少边数，降低时间和空间复杂度，再结合堆优化的Dijkstra算法高效求解最短路。
• **可拓展之处**：此类题属于图论中优化建图结合最短路求解的问题。类似套路是在复杂图结构下，通过合理引入辅助点或边，简化图的连接关系，同时保证路径性质不变，进而高效求解。同类型题常涉及对特殊图结构的处理，通过挖掘图的性质优化建图方式。
• **相似知识点洛谷题目**：
  - P3371 【模板】单源最短路径（弱化版）：基础的单源最短路模板题，用于巩固Dijkstra等最短路算法。
  - P1339 热浪：单源最短路应用，通过实际场景考查最短路算法的实现。
  - P4779 【模板】单源最短路径（标准版）：相比弱化版，数据范围更大，可进一步提升对最短路算法优化和应用能力。
• **个人心得摘录与总结**：
  - **作者Kalium**：提到如果RE可以参考特定帖子，强调注意long long类型，因$w_i$范围较大。总结为在实现过程中要注意数据类型范围避免溢出，同时对于常见运行错误可参考相关讨论寻找解决方案。 

---
处理用时：44.62秒
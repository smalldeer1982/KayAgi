# 题目信息

# [THUPC 2017] 母亲节的礼物

## 题目描述

小 B 喜欢图，尤其是边数不太多的无向简单图。

母亲节快到了，小 B 在纸上画了一张有 $n$ 个节点、$m$ 条边的无向简单图（即，不存在重边、自环），保证每个点只和**最多 $7$ 个点**相邻。接着，他想用 $4$ 种不同的颜色给图中的节点进行染色，作为妈妈的母亲节礼物送给她。

小 B 希望染色之后的图尽量漂亮，他觉得相同颜色的点连成一片不好看。所以，他希望能给每对相邻的节点染上不同的颜色。遗憾的是，小 B 很快发现，在有些图中，这是不可能做到的。他不得不降低要求：每个点相邻的点中，**至多**有一个点和它的颜色相同。

限制条件放松了，问题也就变得简单了；但是小 B 忙着做大作业，所以来找你帮忙。现在，请你告诉小 B，是否能给图中每个点染上一个恰当的颜色，恰好满足小 B 的要求？如果可以，请你给他指出一种染色方案；否则，只好残忍地告诉小 B：`impossible`。

## 说明/提示

#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

## 样例 #1

### 输入

```
1
8 28
1 2
1 3
1 4
1 5
1 6
1 7
1 8
2 3
2 4
2 5
2 6
2 7
2 8
3 4
3 5
3 6
3 7
3 8
4 5
4 6
4 7
4 8
5 6
5 7
5 8
6 7
6 8
7 8```

### 输出

```
abcdabcd```

# AI分析结果

### 综合分析与结论
- **思路方面**：多道题解先通过观察样例（8个点的完全图）猜测不存在无解情况。然后采用类似的方法，即先随机染色，再对不满足条件（相邻点同色数大于1）的点进行调整。
- **算法要点**：将不满足条件的点放入队列，每次从队列取点，改变其颜色为相邻点中最稀有颜色，再更新相邻点状态，重复此过程直到队列为空。
- **解决难点**：核心在于如何调整颜色使所有点满足条件，各题解都采用了贪心策略，但未严格证明其正确性。

### 题解分析
1. **作者：happy_dengziyue（4星）**
    - **关键亮点**：思路清晰，代码实现简洁明了，详细注释。先找出不满足要求的点入队，每次取队首点，将其颜色改成相邻点中最稀有颜色，并用容斥原理简单说明合理性。
    - **重点代码**：
```cpp
while (!q.empty()) {
    int u = q.front();
    q.pop();
    if (asksame(u, col[u]) <= 1) continue;
    micnt = 8;
    for (int i = 0, k; i < 4; ++i) {
        k = asksame(u, i);
        if (k < micnt) {
            micnt = k;
            micol = i;
        }
    }
    col[u] = micol;
    for (int i = fir[u], v; i; i = e[i].nx) {
        v = e[i].v;
        if (col[v] == micol && asksame(v, micol) > 1) q.push(v);
    }
}
```
    - **核心实现思想**：从队列取点，若不满足条件，找相邻点中最稀有颜色染色，更新相邻点，若相邻点因此次染色不满足条件则入队。
2. **作者：Rosick（4星）**
    - **关键亮点**：对本题一定有解进行了详细证明，从完全图和非完全图两方面分析。完全图通过颜色数量和点数关系证明有解，非完全图通过假设由完全图或完全子图删边得来，说明删边减少约束从而有解。
    - **重点代码**：无（主要是证明过程）
    - **核心实现思想**：无（主要贡献为证明）
3. **作者：Hoks（3星）**
    - **关键亮点**：提出随机染色并调整的思路，但时间复杂度未严格保证，更多基于猜想。代码实现有一定注释。
    - **重点代码**：
```cpp
while (!q.empty()) {
    int x = q.front();q.pop();
    for (int i = head[x];i;i = e[i].nxt) if (color[x] == color[e[i].v]) d[x]--, d[e[i].v]--;
    for (int i = 0;i <= 3;i++) num[i] = 0;
    for (int i = head[x];i;i = e[i].nxt) num[color[e[i].v]]++;
    int tt = 8, cl;for (int i = 0;i <= 3;i++) if (tt > num[i]) tt = num[i], cl = i;color[x] = cl;
    for (int i = head[x];i;i = e[i].nxt) {
        if (color[x] == color[e[i].v]) d[x]++, d[e[i].v]++;
        if (d[e[i].v] > 1) q.push(e[i].v);
    }
}
```
    - **核心实现思想**：与其他题解类似，从队列取不满足条件点，找相邻点最稀有颜色染色，更新相邻点状态。

### 最优关键思路或技巧
采用贪心策略，先随机染色，再通过队列调整不满足条件的点，每次将点颜色改为相邻点中最稀有颜色，逐步使所有点满足条件。虽然未严格证明，但在本题数据下有效。

### 可拓展思路
此类图染色问题，可拓展到不同颜色数量、不同相邻点同色限制的情况。相似算法套路是先随机或初始染色，再对不满足条件的点进行调整，可使用队列等数据结构辅助。

### 相似知识点洛谷题目
1. P1129 [ZJOI2007] 矩阵游戏：涉及图的匹配与染色相关知识。
2. P1525 关押罪犯：类似图染色思想解决冲突问题。
3. P2880 [USACO07MAR]Face The Right Way G：通过类似调整思路解决序列方向问题。

### 个人心得摘录与总结
无明显个人心得相关内容。 

---
处理用时：21.80秒
# 题目信息

# [THUPC 2022 初赛] 造计算机

## 题目描述

小R和小C听说贵系有一门造计算机的课之后吓得连夜提交了退学申请。

开玩笑的啦！正处于大一的他们对这门课不但不害怕，甚至有些想笑。他们超强的动手能力甚至驱使他们想造一个玩意玩玩。

当然由于他们毕竟才大一，计算机专业课基本上都没上过，经过长时间的艰苦奋战，他们终于造出了一个奇怪的玩意：

这台计算机只有 $n$ 个内存单元，反而有足够多个寄存器。内存单元的编号从 $1$ 到 $n$ ，寄存器从 $n+1$ 开始往上编号。每个内存单元和寄存器可以存储一个整数。

目前他们已经设计好了一类指令：`swap i, j`，表示交换编号为 $i$ 和 $j$ 的单元里的数，其中 $i$ 和 $j$ 均为正整数且 $i \neq j$ 。他们打算写一段程序来测试这条指令。

最开始， $n$ 个内存单元中乱序存放着 $1\thicksim n$ 这些数，且每个数恰好出现一次。而每个寄存器里存放的是它的编号。

两人打算设计一段指令序列，使得计算机依次执行完这些指令后，所有内存和寄存器中的数都归位，也就是恰好等于它自己的编号。

虽然没学过计算机专业课，小R和小C还是懂一点皮毛的，因此他们规定每条 `swap` 指令操作的两个位置至少有一个需要是寄存器，也就是 $i$ 和 $j$ 至少有一者应当大于 $n$。

然而，正当他们写完程序开始运行时，却发现系统崩溃了！在查找了半天原因后，他们发现了一个奇怪的 bug：他们设计出来的计算机不能运行两条相同的指令！也就是说，他们不能在一段程序里出现两条相同的 `swap i, j` 指令。更进一步他们发现即使出现一条 `swap i, j` 一条 `swap j, i` 也不行，因为计算机会自动将这两条指令视为同一条。

然后可怜的小R和小C就斯巴达了。不过他们在弃疗之前还是打算利用现有的架构把程序写出来。不仅如此，他们还希望用到的寄存器数量尽可能少。你能帮帮他们吗？

## 说明/提示

【样例解释】

最初，前 $4$ 个单元的值依次为 $(2,1,3,4)$ 。

执行指令 `swap 3, 4`，各单元的值变为 $(2,1,4,3)$ 。

执行指令 `swap 1, 3`，各单元的值变为 $(4,1,2,3)$ 。

执行指令 `swap 2, 4`，各单元的值变为 $(4,3,2,1)$ 。

执行指令 `swap 1, 4`，各单元的值变为 $(1,3,2,4)$ 。

执行指令 `swap 2, 3`，各单元的值变为 $(1,2,3,4)$ 。

可以证明 $m=1$ 是不行的。


## 样例 #1

### 输入

```
2
2 1```

### 输出

```
2 5
3 4
1 3
2 4
1 4
2 3```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解先特判数组初始是否有序，若有序则无需操作。对于无序情况，通过将数组元素与其目标位置连边，发现会形成若干个环，且各环相互独立，可分别处理。
    - 算法要点在于利用寄存器对环内元素进行交换操作，使所有元素归位。大家普遍猜测并证明了除初始有序外，最少需要2个寄存器即可完成任务。
    - 解决难点主要在于如何设计交换顺序，既能满足每个环内元素正确归位，又要保证不出现重复指令，同时处理好寄存器最终值的归位。
    - 整体来看，各题解思路相近，主要区别在于代码实现的细节和表述清晰度。

- 所选的题解：
  - **作者：破壁人五号 (5星)**
    - **关键亮点**：不仅给出本题常规做法，还提及最小化 \(k\) 的加强版做法，并给出论文链接及详细证明过程，思路清晰，代码规范。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+10;
int getint(){ int x;scanf("%d",&x);return x; }
int a[N];
bool vis[N];
vector<int>r[N];int cnt=0;
vector<pair<int,int> >ans;
void swp(int x,int y){
    ans.emplace_back(min(x,y),max(x,y));
    swap(a[x],a[y]);
}

int main(){
    int n=getint();
    for(int i=1;i<=n;i++)a[i]=getint();
    a[n+1]=n+1;a[n+2]=n+2;
    for(int i=1;i<=n;i++){
        if(!vis[i]){
            int u=i;
            while(!vis[u]){
                vis[u]=1;
                r[cnt].push_back(u);
                u=a[u];
            }
            // reverse(r[cnt].begin(),r[cnt].end());
            ++cnt;
        }
    }
    vector<int>cy;
    for(int i=0;i<cnt;i++)if(r[i].size()>1)cy.push_back(i);
    if(cy.empty())return puts("0 0"),0;

    for(int i=cy.size()-1;i;--i)swp(r[cy[i]].back(),n+2);
    swp(r[cy[0]].back(),n+1);
    for(int i:r[cy[0]])swp(i,n+2);
    swp(r[cy[0]].front(),n+1);
    for(int i=1;i<cy.size();i++)for(int j:r[cy[i]])swp(j,n+1);
    swp(n+1,n+2);
    
    printf("%d %d\n",2,(int)ans.size());
    for(auto i:ans)
        printf("%d %d\n",i.first,i.second);
    // for(int i=1;i<=n+2;i++)cerr<<"> "<<a[i];cerr<<endl;
    return 0;
}
```
    - **核心实现思想**：先找出所有环，对于非空环，按特定顺序对环内元素与寄存器进行交换操作，最后根据寄存器值的情况决定是否交换两个寄存器。
  - **作者：_Diu_ (4星)**
    - **关键亮点**：清晰阐述思路，从猜测答案 \(m\) 为常数出发，详细说明利用两个寄存器对每个环进行操作的具体步骤，代码简洁易懂。
    - **个人心得**：赛事压哨过，特来水一发题解纪念。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,m,k,a[N],st[N],tp,vis[N];
struct upt{
	int x,y;
}ans[N];
void dfs(int x){
	st[++tp]=x,vis[x]=1;
	if(!vis[a[x]])dfs(a[x]);
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	a[n+1]=n+1,a[n+2]=n+2;
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			if(i==a[i])continue;//只有一个就没必要了
			tp=0;
			dfs(i);
			m=2;
			ans[++k]={st[1],n+1};swap(a[st[1]],a[n+1]);
			for(int j=2;j<tp;j++)ans[++k]={st[j],n+1},swap(a[st[j]],a[n+1]);
			ans[++k]={st[tp],n+2},swap(a[st[tp]],a[n+2]);
			ans[++k]={st[tp],n+1},swap(a[st[tp]],a[n+1]);
			ans[++k]={st[1],n+2},swap(a[st[1]],a[n+2]);
		}
	}
	if(a[n+1]!=n+1)ans[++k]={n+1,n+2};
	for(int i=1;i<=k;i++)printf("%d %d\n",ans[i].x,ans[i].y);
}
```
    - **核心实现思想**：通过深度优先搜索找到每个环，对每个环按特定顺序与两个寄存器交换元素，最后检查寄存器值是否需要交换。
  - **作者：RedreamMer (4星)**
    - **关键亮点**：思路明确，简洁地描述了利用两个寄存器处理每个置换环的构造方法，代码实现较为紧凑。
    - **个人心得**：无
    - **重点代码**：
```cpp
const int N = 1e6;
int a, s[N + 5], p[N + 5], top, now;
bool vis[N + 5];
struct pii {int x, y;};
vector<pii> ans;

void ins(int n, int m) {
	ans.PB((pii) {n, m});
	assert(siz(ans) <= 1e6);
	swap(p[n], p[m]);
}

signed main() {
	// freopen("in2.in", "r", stdin);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> a;
	rep(i, 1, a) cin >> s[i], p[i] = s[i];
	p[a + 1] = a + 1, p[a + 2] = a + 2;
	bool o = 1;
	rep(i, 1, a) if(s[i]!= i) o = 0;
	if(o) return cout << "0 0", 0;
	rep(i, 1, a) {
		if(vis[i] || s[i] == i) continue;
		int x = i;
		for(;!vis[x]; x = s[x]) {
			vis[x] = 1;
			if(s[x] == i) ins(a + 2, x);
			ins(a + 1, x);
		}
		ins(a + 2, i);
	}
	if(p[a + 1]!= a + 1) ins(a + 1, a + 2);
	rep(i, 1, a + 2) assert(p[i] == i);
	cout << 2 << ' ' << siz(ans) << '\n';
	rep(i, 0, siz(ans) - 1) cout << ans[i].x << ' ' << ans[i].y << '\n';
	return 0;
}
```
    - **核心实现思想**：遍历数组找到未访问且不在正确位置的元素，以其为起点处理所在环，按特定顺序与两个寄存器交换，最后检查寄存器是否需要交换。

• 最优关键思路或技巧：
    - **思维方式**：通过将元素与目标位置连边转化为环的问题，利用环的独立性分别处理，简化问题。
    - **代码实现技巧**：在处理环时，精心设计与两个寄存器的交换顺序，保证元素正确归位且不重复操作，同时注意对寄存器最终状态的处理。

• 可拓展之处：
同类型题常涉及置换、环的概念以及构造性算法。类似套路是将问题转化为图论中的环问题，通过对环的操作来解决。例如给定一种操作规则，要求将一个排列变成另一个排列，可尝试分析元素移动形成的环结构。

• 相似知识点洛谷题目：
    - P1993 小 K 的农场：涉及图论中差分约束系统，通过建边形成环来判断是否有解，与本题将问题转化为环结构思路类似。
    - P2371 [国家集训队]墨墨的等式：利用同余类建图，将问题转化为图上最短路问题，其中对同余类的处理类似于本题对环的独立处理思想。
    - P3387 缩点：通过强连通分量缩点，将复杂图转化为有向无环图进行处理，与本题处理环结构后进一步操作有相似之处。

• 个人心得摘录与总结：
    - **作者：_Diu_**：在赛事压哨通过本题，发题解纪念。总结为比赛紧张完成题目后，通过分享题解巩固知识并纪念比赛经历。 

---
处理用时：49.68秒
# 题目信息

# 「MCOI-08」Fill In REMATCH

## 题目描述

Dream 有一个长度为 $n$（$1\le n\le 10^5$）的整数数组 $a_1,a_2,\dots,a_n$，其中对于 $i=1,2,\dots,n$，满足 $0\le a_i<2^{60}$。

他计算了前缀异或数组 $p_i=a_1\oplus a_2\oplus\dots\oplus a_i$ 以及后缀异或数组 $s_i=a_i\oplus a_{i+1}\oplus\dots\oplus a_n$。

现在 Tommy **一共**将 $p$ 和 $s$ 的 $n$ 个元素换成 $-1$。给定当前的 $p$ 与 $s$ 数组，请恢复任意一组可能为原数组的 $a_1,a_2,\dots,a_n$。

保证存在一组合法解。

## 说明/提示

对于 $100\%$ 的数据，$1\le n,\sum n\le 10^5$，$\sum [p_i=-1]+\sum [s_i=-1]=n$，**保证有合法解。**

 - Subtask 1（10 pts）：$n\le 4$，$p_i,s_i<2$；
 - Subtask 2（10 pts）：$n\le 100$；
 - Subtask 3（20 pts）：$p_i,s_i<2$；
 - Subtask 4（60 pts）：无特殊限制。


## 样例 #1

### 输入

```
1
4
-1 34 367 -1
3178 -1 -1 3333```

### 输出

```
3 33 333 3333```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均基于异或运算的性质来还原原数组。通过推导得出关键等式 \(p_i \oplus s_{i + 1} = \bigoplus_{j = 1}^n a_j\)，利用此等式及已知条件求出所有数的异或和，进而还原 \(p\) 和 \(s\) 数组，最终得到原数组 \(a\)。

各题解在细节处理和代码实现上略有不同，如寻找异或和的方式、对未知值的处理等。整体来看，大部分题解思路清晰，主要差异在于代码的可读性和优化程度。

### 所选的题解
1. **作者：Anxiomgh (5星)**
    - **关键亮点**：思路阐述极为清晰，先明确给出异或运算的重要性质，再逐步推导得出关键引理，对每个步骤的证明和分析详细且严谨，代码实现与思路紧密结合，变量命名规范，可读性高。
    - **个人心得**：无
    - **重点代码**：
```cpp
ll find(int n) //查找 
{
    for (int i = 0; i <= n; i++)
        if (p[i]!= -1 && s[i + 1]!= -1)
            return p[i] ^ s[i + 1];
}

void update(ll val, int n) //还原 
{
    for (int i = 0; i <= n; i++)
    {
        if (p[i]!= -1 && s[i + 1] == -1) 
            s[i + 1] = val ^ p[i];
        else if (p[i] == -1 && s[i + 1]!= -1) 
            p[i] = val ^ s[i + 1];
        else if (p[i] == -1 && s[i + 1] == -1)
        {
            p[i] = p[i - 1];
            s[i + 1] = val ^ p[i];
        }
    }
}
```
核心实现思想：`find` 函数用于找到一组非 `-1` 的 \(p_i\) 和 \(s_{i + 1}\) 并求出异或和。`update` 函数根据异或和还原 \(p\) 和 \(s\) 数组，分三种情况处理不同的 `p[i]` 和 `s[i + 1]` 取值。
2. **作者：我是逍逍 (4星)**
    - **关键亮点**：简洁明了地阐述思路，通过性质推导得出 \(a_i, p_i, s_i\) 知二求三的关系，对未知量的处理给出合理证明，代码简洁，逻辑清晰。
    - **个人心得**：无
    - **重点代码**：
```cpp
for (int i = 0; i <= n; i++) 
    if (p[i]!= -1 && s[i + 1]!= -1) {
        E = p[i] ^ s[i + 1];
        break;
    }

for (int i = 0; i <= n; i++) {
    if (p[i] == -1 && s[i + 1]!= -1)
        p[i] = E ^ s[i + 1];
    else if (p[i]!= -1 && s[i + 1] == -1) 
        s[i + 1] = E ^ p[i];
    else if (p[i] == -1 && s[i + 1] == -1) 
        p[i] = 1;
    if (i)
        printf("%lld ", p[i] ^ p[i - 1]);
}
```
核心实现思想：先找到一组非 `-1` 的 \(p_i\) 和 \(s_{i + 1}\) 求出异或和 \(E\)，然后根据 \(E\) 还原 \(p\) 和 \(s\) 数组，对不同情况分别处理，最后根据 \(p\) 数组求出原数组。
3. **作者：stntn (4星)**
    - **关键亮点**：对题意和思路的分析简洁准确，明确指出解题的关键步骤，代码采用模板形式，对常见操作进行封装，具有一定的通用性。
    - **个人心得**：无
    - **重点代码**：
```cpp
rep(i,1,n+1) if(~s[i]&&~p[i-1]) p[n]=s[1]=s[i]^p[i-1];
rep(i,1,n+1)
{
    if(~p[i-1]) s[i]=s[1]^p[i-1];
    if(~s[i]) p[i-1]=s[1]^s[i];
}
rep(i,1,n)
{
    if(~p[i]&&~p[i-1]) a[i]=p[i]^p[i-1];
    if(~s[i+1]&&~s[i]) a[i]=s[i+1]^s[i];
}
```
核心实现思想：通过遍历找到一组非 `-1` 的 \(s[i]\) 和 \(p[i - 1]\) 求出异或和并赋值给 \(p[n]\) 和 \(s[1]\)，然后利用异或和还原 \(s\) 和 \(p\) 数组，最后根据 \(p\) 或 \(s\) 数组求出原数组 \(a\)。

### 最优关键思路或技巧
1. **利用异或运算性质推导关键等式**：通过前缀异或数组 \(p\) 和后缀异或数组 \(s\) 的定义，结合异或运算的归零律、恒等律和结合律，推导出 \(p_i \oplus s_{i + 1} = \bigoplus_{j = 1}^n a_j\) 这一关键等式，为解题奠定基础。
2. **利用已知条件确定异或和**：根据题目中“一共将 \(p\) 和 \(s\) 的 \(n\) 个元素换成 \(-1\)”这一条件，通过分析得出必然存在一组 \(p_i\) 和 \(s_{i + 1}\) 都不为 \(-1\)，从而可以 \(O(n)\) 遍历找到并求出所有数的异或和。
3. **分类讨论还原数组**：对 \(p_i\) 和 \(s_{i + 1}\) 的不同取值情况（都不为 \(-1\)、其中一个为 \(-1\)、都为 \(-1\)）进行分类讨论，逐步还原 \(p\) 和 \(s\) 数组，进而得到原数组。

### 可拓展之处
此类题目主要考察对异或运算性质的理解和运用，类似套路可用于解决涉及位运算、数组变换及还原的问题。例如，给定数组经过某种位运算得到新数组，再给出新数组部分值，要求还原原数组。

### 相似知识点洛谷题目
1. **P1508 Likecloud-吃、吃、吃**：涉及数组元素间的异或运算关系，通过已知条件推导并求解未知元素。
2. **P4151 [WC2011]最大XOR和路径**：在图上进行异或运算相关的路径问题，需要利用异或性质找到最大异或和路径。
3. **P3128 [USACO15DEC]Max Xor P**：同样围绕异或运算，通过对数据的处理和异或性质的运用来解决问题。 

---
处理用时：35.69秒
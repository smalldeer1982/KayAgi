# 题目信息

# 「SWTR-8」15B03

## 题目背景

15B03 获得了 ION2064 的承办权。

## 题目描述

15B03 的座位非常拥挤，可以看成一张 $n\times m$ 的网格，每个小正方形 $(i, j)$ 代表一张桌子。

根据规定，考场上任何两张桌子不得相邻。这里相邻指含有 **公共点**。严格定义两张桌子 $(i, j)$ 和 $(i', j')$ 相邻当且仅当 $|i - i'|\leq 1$ 且 $|j - j'|\leq 1$。

布置考场的任务落在小 A 头上，他希望撤去最少的桌子满足上述要求。

小 A 认为这样太简单了，因此他添加了限制：在保证撤去桌子最少的前提下，最大化剩余每张桌子到距离它最远的桌子的距离之和。这里距离指 **欧几里得** 距离：桌子 $(a, b)$ 和 $(c, d)$ 的距离为 $\sqrt{(a - c) ^ 2 + (b - d) ^ 2}$。

平行时空中 15B03 的规模不尽相同：多组测试数据。

**请选手认真阅读本题的评分方式。**

## 说明/提示

**「样例解释」**

对于第一组询问，选择 $(1, 1), (1, 3), (3, 1)$ 和 $(3, 3)$ 最优。撤去了 $3\times 3 - 4 = 5$ 张桌子，且每张桌子到距离它最远的桌子的距离均为 $\sqrt{2 ^ 2 + 2 ^ 2} = 2\sqrt 2$，因此第二问答案为 $8\sqrt 2$。如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/y8fi4qhr.png)

对于第二组询问，选择 $(1, 1)$ 和 $(2, 4)$ 最优。撤去了 $2\times 4 - 2 = 6$ 张桌子，且每张桌子到距离它最远的桌子的距离均为 $\sqrt{1 ^ 2 + 3 ^ 2} = \sqrt {10}$，因此第二问答案为 $2\sqrt {10}$。

如果选择 $(1, 1)$ 和 $(2, 3)$，则第二问答案为 $2\sqrt 5$，不优。

**「评分方式」**

对于每组测试数据：

- 若你第一问的答案错误，得 0 分。
- 否则，若你第二问的答案错误，得 0.8 分。
- 否则，得 1 分。

每个测试点的得分为测试点内所有测试数据的得分的最小值乘以该测试点的分值。

注意，**若你输出的格式错误，得 0 分**。因此，如果你只希望获得第一问的分数，请在第二问输出任意合理范围内的实数。

**「数据范围与约定」**

- 测试点 #1（15 points）：$n, m$ 均为奇数。
- 测试点 #2（20 points）：$n = 1$。
- 测试点 #3（25 points）：$n = 2$。
- 测试点 #4（30 points）：$n$ 为奇数。
- 测试点 #5（10 points）：无特殊限制。

对于 $100\%$ 的数据：

- $1\leq T\leq 57$。
- $1\leq n, m\leq 1064$。

**「帮助与提示」**

- 你可以使用 `cmath` 中的 `sqrt(x)` 函数计算 $x$ 的平方根。它返回 `double` 类型的值。`sqrtl(x)` 精度更高，它返回 `long double` 类型的值。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) A
- Idea & Solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。
- Tester：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
4
3 3
2 4
15 57
1064 822```

### 输出

```
5 11.313708499
6 6.324555320
623 10206.135788972
655956 222400384.677931725
```

# AI分析结果

### 综合分析与结论
这些题解在解决本题时，思路和方法上有诸多相似之处。对于第一问，都通过贪心策略，将问题转化为计算最多能放置的桌子数量，进而得出需撤去的桌子数，公式为 \(n\times m - \left\lceil \dfrac{n}{2} \right\rceil \times \left\lceil \dfrac{m}{2} \right\rceil\)。对于第二问，多数题解考虑到桌子距离四个角（\((1,1)\)，\((1,m)\)，\((n,1)\)，\((n,m)\)）的距离最远，通过分类讨论不同的 \(n\) 和 \(m\) 的奇偶性情况来构造最优解。

各题解的主要差异在于对第二问的具体实现和分析的详细程度。部分题解通过直观的图形观察和推理得出结论，部分则从理论上进行了更深入的证明。在代码实现上，有的注重简洁性，有的则更详细地处理各种边界情况。

### 所选的题解
- **作者：iiiiiyang (5星)**
    - **关键亮点**：思路清晰，对每个性质进行详细分析并配有大量配图，便于理解。代码实现简洁明了，对不同情况分别处理，可读性强。
    - **个人心得**：“作为一道非常好的有思维深度的题，必须写篇题解记录一下。谨以此篇献给我的第一道构造题。”体现了对该题的重视以及从解题中获得的收获。
    - **重点代码 - 第一问**：
```cpp
bool p=1,q=1;
cin>>n>>m;
r=n*m;
if(n%2==0) n--,p=0;
if(m%2==0) m--,q=0;
r-=(n/2+1)*(m/2+1);
cout<<r<<" ";
```
**核心实现思想**：先判断 \(n\) 和 \(m\) 的奇偶性，若为偶数则减 1，然后计算最多可放置桌子数并得出需撤去的桌子数。
    - **重点代码 - 第二问**：
```cpp
if(n*m-r==1) {cout<<"0.000000000"<<endl; continue;}
if(n==1&&(q)) 
{
    for(int i=0;i<(m+1)/2/2;i++)
        ans+=(m-2*i);
    ans*=2;
    if((m/2)%2==0) ans=ans+m-(m-1)/2;
    cout<<fixed<<setprecision(9)<<ans<<endl; 
}
else if(n==1&&(!q)) 
{
    for(int i=0;i<=m/4;i++)
        ans+=(m-2*i);
    ans*=2;
    if((m/2)%2==1) ans=ans+(m+2)/2;
    cout<<fixed<<setprecision(9)<<ans<<endl; 
}
```
**核心实现思想**：特判只有一张桌子时输出 0。对于 \(n = 1\) 的情况，根据 \(m\) 的奇偶性分别讨论，通过对折长条计算桌子到最远点的距离和。
- **作者：Alex_Wei (5星)**
    - **关键亮点**：作为出题人，对解法的阐述准确清晰，不仅给出构造方法，还对其进行理论上的证明。代码简洁高效，对特殊情况处理得当。
    - **重点代码 - 第二问核心片段**：
```cpp
if(n > 2 || m > 2) {
    if(m == 2) swap(n, m);
    for(int i = 1; i <= n + 1 >> 1; i++)
        for(int j = 1; j <= m + 1 >> 1; j++) {
            int x = i * 2 - 1, y = j * 2 - 1;
            if(n % 2 == 0 && x > n / 2) x++;
            if(m % 2 == 0 && y > m / 2) y++;
            int dx = max(x - 1, n - x);
            int dy = max(y - 1, m - y);
            ans += sqrt(dx * dx + dy * dy);
        }
}
```
**核心实现思想**：先特判 \(n\) 和 \(m\) 较小的情况，对于一般情况，通过循环遍历桌子位置，根据 \(n\) 和 \(m\) 的奇偶性调整桌子位置，计算每个桌子到最远点的距离并累加。
- **作者：snail2956 (4星)**
    - **关键亮点**：思路独特，将矩阵分成四份分别考虑，代码实现简洁明了，无需对 \(n\) 和 \(m\) 的特殊值进行复杂特判。
    - **重点代码 - 第二问**：
```cpp
if(n>2||m>2){
    for(int i=1;i<=(n+1)/2;i+=2){
        for(int j=1;j<=(m+1)/2;j+=2){
            d+=sqrtl((i-n)*(i-n)+(j-m)*(j-m));
        }
    }
    for(int i=n;i>n/2+1;i-=2){
        for(int j=m;j>m/2+1;j-=2){
            d+=sqrtl((i-1)*(i-1)+(j-1)*(j-1));
        }
    }
    for(int i=1;i<=(n+1)/2;i+=2){
        for(int j=m;j>m/2+1;j-=2){
            d+=sqrtl((i-n)*(i-n)+(j-1)*(j-1));
        }
    }
    for(int i=n;i>n/2+1;i-=2){
        for(int j=1;j<=(m+1)/2;j+=2){
            d+=sqrtl((i-1)*(i-1)+(j-m)*(j-m));
        }
    }
}
```
**核心实现思想**：当 \(n\) 和 \(m\) 较大时，将矩阵分成四份，分别计算每份中桌子到其最远点的距离并累加。

### 最优关键思路或技巧
1. **贪心策略**：在第一问中，通过贪心选择隔行隔列放置桌子，以达到撤去最少桌子的目的。
2. **分类讨论**：针对第二问，根据 \(n\) 和 \(m\) 的奇偶性进行细致分类讨论，构造出最大化距离和的方案。
3. **对称性利用**：利用桌子分布的对称性，减少计算量，如只计算矩阵的一部分桌子到最远点的距离，再通过对称关系得出整体结果。

### 可拓展思路
此类题目属于网格布局优化问题，类似的套路包括通过分析问题的对称性、单调性等性质，利用贪心、动态规划等算法解决。可以拓展到其他在网格中进行元素放置并优化某种指标的问题，例如在网格中放置障碍物使两点间最短路径最长等。

### 相似知识点洛谷题目
1. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：通过贪心策略解决问题，与本题第一问的贪心思路类似。
2. [P1199 三国游戏](https://www.luogu.com.cn/problem/P1199)：需要对不同情况进行分析讨论，与本题第二问分类讨论的思想相符。
3. [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)：同样运用贪心策略，并对策略进行证明，有助于加深对贪心算法的理解和应用。 

---
处理用时：37.51秒
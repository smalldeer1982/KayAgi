# 题目信息

# 「SWTR-8」美元巨大

## 题目背景

#### 输出不允许有前导零。

原题目名称为「美元巨大二的二的二的二的二」。

小 A 喜欢用形如
$$
\Huge 2 ^ {2 ^ {2 ^ {2 ^ {2}}}}
$$
的幂塔把小 T 的博客炸掉。

## 题目描述

小 A 有 $n$ 个 $2$ 的幂 $a_1, a_2, \cdots, a_n$。他要在这些数之间插入 $x$ 个异或运算符和 $y$ 个或运算符，组成一个表达式。保证 $x + y = n - 1$。

表达式越大，越有可能炸掉小 T 的博客。小 A 希望 **从左往右** 计算表达式时它的值最大。他想知道表达式最大可能的取值是多少，用二进制表示。他还希望你构造出这样的表达式，因为他懒得自己构造了。

若存在多组构造方案，输出任意一组。

多组测试数据。

## 说明/提示

**「评分方式」**

对于每组测试数据：

- 若你输出的第一行比标准答案劣，得 0 分。
- 若你输出的第一行比标准答案优，则 checker 将检查你的构造方案是否正确。若正确，则返回 `_fail`，表现为测试点 UKE；否则得 0 分。
- 否则，你输出的第一行和标准答案一样。若构造方案不正确，得 0.6 分；否则得 1 分。

每个测试点的得分为测试点内所有测试数据的得分的最小值乘以该测试点的分值。

注意，checker 能检测出你的答案比标准答案优的前提是输出完全符合格式。**一旦输出不符合格式，得 0 分**。格式限制包括但不限于：

- 第一行不得输出除 `0` 和 `1` 以外的字符。
- 第二行不得输出除 `^` 和 `|` 以外的字符，且字符串长度恰为 $n - 1$。
- `^` 的个数恰为 $x$，`|` 的个数恰为 $y$。

**「数据范围与约定」**

- 测试点 #1（10 points）：所有 $b_i$ 互不相等。
- 测试点 #2（20 points）：所有 $b_i$ 相等。
- 测试点 #3（30 points）：$n \leq 8$。
- 测试点 #4（25 points）：$n \leq 10 ^ 3$。
- 测试点 #5（15 points）：无特殊限制。

对于 $100\%$ 的数据：

- $1\leq T\leq 20$。
- $1 \leq n \leq 2.5 \times 10 ^ 4$。
- $0 \leq x, y < n$，$x + y = n - 1$。
- $1\leq a_i < 2 ^ {2 ^ {2 ^ {2 ^ 2}}}$，即 $0\leq b_i < 65536$。

**「帮助与提示」**

- 关于 [位运算](https://oi-wiki.org/math/bit/)。
- 请注意 IO 优化。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) B
- Idea & Solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。
- Tester：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
4
4 0 3
1 0 6 4
8 5 2
1 5 5 7 1 5 5 7
1 0 0
15
4 3 0
65535 65535 57 57
```

### 输出

```
1010011
|||
10100000
^|^^^^|
1000000000000000

0
^^^
```

# AI分析结果

### 综合分析与结论
这些题解均采用贪心策略解决问题。核心思路是利用或运算和异或运算的性质，按二进制位从高到低贪心，使高位尽可能为1以获取最大值。
 - **思路**：基于或运算能使结果变大或不变，异或运算使结果变大或变小的性质，优先使用异或运算，在必要时用或运算保证高位为1。
 - **算法要点**：统计每个二进制位出现的次数，根据奇偶性决定运算符的使用。对于奇数次出现的位，尽量用异或；偶数次出现的位，在最后一次出现前用或（若有剩余或运算符）。
 - **解决难点**：如何合理分配异或和或运算符，既能满足数量要求又能使结果最大。同时要注意处理第一个数无前导运算符、输出无前列零以及构造方案需符合要求等细节。

综合来看，多数题解思路清晰，但部分代码可读性欠佳或优化不足。

### 所选的题解
1. **作者：Alex_Wei (5星)**
    - **关键亮点**：思路清晰简洁，直接点明或比异或更能使结果变大，按位从大到小贪心，代码实现简洁高效，注释清晰。
    - **个人心得**：无
    - **重点代码**：
```cpp
for(int i = W - 1; ~i; i--)
    if(buc[i] & 1) ans[i] = 1;
    else if(y && buc[i]) ans[i] = op[lst[i]] = 1, y--;
for(int i = n; y; i--) if(!op[i]) op[i] = 1, y--;
```
    **核心实现思想**：从高位到低位遍历，若某一位出现奇数次则直接置1；若为偶数次且有剩余或运算符，则在该位最后一次出现位置置或并将该位置1，同时减少或运算符数量。最后处理剩余的或运算符，从后往前填充。
2. **作者：jiangxiaohai (4星)**
    - **关键亮点**：详细阐述贪心思路，对每一步操作解释清晰，代码实现逻辑明确，通过多个数组辅助记录信息，便于理解。
    - **个人心得**：无
    - **重点代码**：
```cpp
for(int i=maxbit;i>=0;i--)
{
    if(ket[i]%2==0&&ket[i]>0) 
    {
        if(o>=1) 
        {
            o--;
            keep[i]=1;
        }
        else
            buc[i]=0;
    }
}
```
    **核心实现思想**：从最高位开始遍历，若某一位出现偶数次且不为零，若有剩余或运算符，则标记该位需要一个或运算，否则该位舍弃。
3. **作者：zhenjianuo2025 (4星)**
    - **关键亮点**：将题意转化清晰，贪心策略描述准确，代码简洁明了，对每个步骤的操作在代码注释中有详细说明。
    - **个人心得**：无
    - **重点代码**：
```cpp
for (int i = 65536; i >= 0; i--)
    if (cnt[i] % 2) ans[i] = 1;
    else if (y && cnt[i]) ans[i] = 1, opr[lst[i]] = '|', y--;
for (int i = n; y; i--)
    if (opr[i] == '^') opr[i] = '|', y--;
```
    **核心实现思想**：从高位到低位遍历二进制位，奇数个1的位直接置1；偶数个1且有或运算符时，在最后一个1的位置置或并将该位置1。最后处理剩余或运算符，随意填充剩余位置。

### 最优的关键思路或技巧
 - **思维方式**：按二进制位独立考虑，利用或运算和异或运算性质，从高位到低位贪心，优先保证高位为1。
 - **代码实现技巧**：通过数组记录每个二进制位出现次数、最后出现位置等信息，方便运算符的分配和结果计算。

### 可拓展之处
此类题目属于位运算与贪心策略结合的问题。同类型题常涉及不同位运算组合，需分析运算性质并结合贪心策略求解。类似算法套路是先分析运算对结果的影响，再按位或按特定顺序贪心。

### 相似知识点的洛谷题目
 - [P1876 开灯](https://www.luogu.com.cn/problem/P1876)：涉及位运算和逻辑推理，通过位运算模拟开关灯操作。
 - [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：简单贪心问题，根据不同包装铅笔价格和需求数量，选择最优购买方案。
 - [P2678 [NOIP2015 普及组] 跳石头](https://www.luogu.com.cn/problem/P2678)：二分答案结合贪心，通过调整距离判断能否满足条件。 

---
处理用时：32.92秒
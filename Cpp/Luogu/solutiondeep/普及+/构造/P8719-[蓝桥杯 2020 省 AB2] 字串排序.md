# 题目信息

# [蓝桥杯 2020 省 AB2] 字串排序

## 题目描述

小蓝最近学习了一些排序算法, 其中冒泡排序让他印象深刻。

在冒泡排序中, 每次只能交换相邻的两个元素。

小蓝发现, 如果对一个字符串中的字符排序, 只允许交换相邻的两个字符, 则在所有可能的排序方案中, 冒泡排序的总交换次数是最少的。

例如, 对于字符串 lan 排序, 只需要 $1$ 次交换。对于字符串 qiao 排序, 总共需要 $4$ 次交换。

小蓝的幸运数字是 $V$, 他想找到一个只包含小写英文字母的字符串, 对这个串中的字符进行冒泡排序, 正好需要 $V$ 次交换。请帮助小蓝找一个这样的字符串。如果可能找到多个, 请告诉小蓝最短的那个。如果最短的仍然有多个, 请告诉小蓝字典序最小的那个。请注意字符串中可以包含相同的字符。


## 说明/提示

对于 $30 \%$ 的评测用例, $1 \leq V \leq 20$。

对于 $50 \%$ 的评测用例, $1 \leq V \leq 100$。

对于所有评测用例, $1 \leq V \leq 10000$。

蓝桥杯 2020 第二轮省赛 A 组 J 题（B 组 J 题）。

## 样例 #1

### 输入

```
4```

### 输出

```
bbaa```

## 样例 #2

### 输入

```
100```

### 输出

```
jihgfeeddccbbaa```

# AI分析结果

• 综合分析与结论：这几道题解都围绕构造满足冒泡排序交换次数为V的最短且字典序最小字符串展开。核心思路都是先确定字符串最短长度，再贪心构造字典序最小的字符串。不同点在于确定最大逆序对个数及构造字符串的具体方式。

所选的题解：
 - 作者：梅子酒 (5星)
   - 关键亮点：思路清晰，详细阐述了确定字符串长度和构造字典序最小字符串的方法。利用递推求解不同长度字符串能构造的最大逆序对数，构造字符串时从前向后暴力枚举字符，贪心策略运用巧妙。
   - 重点代码核心思想：`get_max`函数通过递推计算不同长度字符串的最大逆序对数。`get_add`函数计算新增字符产生的逆序对。`check`函数判断剩余字符能否构造出足够逆序对。`solve`函数贪心构造字符串。
   ```cpp
   int get_max(){ // 获取长度为m的字符串的最大逆序对数
       for(int i = 2; i <= 26; i ++) f[i] = f[i - 1] + i - 1; // 长度小于26的字符串最大逆序对数
       int sum = 26, vis[30];
       for(int i = 0; i < 26; i ++) vis[i] = 1; // 记录当前字符串已经各个字符串各一个了
       for(int i = 27; f[i - 1] < n; i ++, sum ++){ 
           int ch = (i % 26 - 1 + 26) % 26; // 新增的字符按abc……的顺序新增，插入到逆序的位置，例如zyx……a,下一个接着插入a zyx……aa
           f[i] = f[i - 1] + sum - vis[ch]; vis[ch] ++; //新增逆序对字符总数 - 和自己相同的字符数
       }
   }

   int cnt[30], vis[30]; // cnt 代表已经确定的构造字符，vis代表后续按最大方法构造的字符
   int get_add(int ch){
       int add = 0;
       for(int i = 0; i < ch; i ++) add += vis[i]; // vis 是还未确定的可以按任意顺序排列所以都可以计算进来
       for(int i = ch + 1; i < 26; i ++) add += cnt[i] + vis[i]; // 因为cnt已经确定了，后续字符只能在其后，所以新增的只能是 > ch 的字符数
       return add; 
   }
   bool check(int id, int m, int ch, int sum){
       for(int i = id + 1; i <= m; i ++){
           int maxadd = 0, ch1 = 0;
           for(int j = 0; j < 26; j ++){ // 和上述fi的求解过程同理，只是枚举字符选择最优解的那一个
               int add = get_add(j);
               if(maxadd < add){
                   maxadd = add;
                   ch1 = j;
               }
           }
           vis[ch1] ++;
           sum += maxadd;
       }
       memset(vis, 0, sizeof vis);
       if(sum >= n) return true; // 当剩余字符能构造出 >= n 的即返回true
       return false;
   }

   void solve(int m){
       int sum = 0;
       string ans;
       for(int i = 1; i <= m; i ++){
           for(int j = 0; j < 26; j ++){ // 每个位置都从'a' 开始枚举，看是否剩下的字符最大情况下仍然能构造出大于等于n的字符，若可以则使用当前的ch
               int initadd = get_add(j);
               cnt[j] ++;
               sum += initadd;
               if(check(i, m, j, sum)){
                   ans += ('a' + j);
                   break;
               }
               cnt[j] --; // 不满足，于是回溯枚举新的字符
               sum -= initadd;
           }
       }
       cout << ans;
   }
   ```
 - 作者：huyangmu (5星)
   - 关键亮点：将问题拆分为确定最小长度和构造字典序最小字符串两个子问题。通过推导公式计算不同长度字符串的最多逆序对个数，构造字符串时通过枚举和判断可行性来确定每个位置的字符。
   - 重点代码核心思想：`check`函数通过公式判断当前长度能否产生足够逆序对。`check2`函数判断当前位置放某个字母是否可行，计算已确定部分和后续部分的逆序对总和。
   ```cpp
   bool check (int x){
       int tmp = ((x - (x / 26 + 1)) * (x / 26 + 1) * (x % 26) + (x - x / 26) * (x / 26) * (26 - x % 26) ) >> 1;
       return tmp < n;	
   }
   bool check2 (int x,int len){
       mp2.clear();
       int sum1 = 0,sum2 = 0;
       for (int i = 26; i >= x + 1; --i) sum1 += mp[i];
       ++mp[x];
       for (int i = 1; i <= len; ++i){
           int maxn = -1,pos,sum = 0;
           for (int j = 26; j >= 1; --j){
               if (i - 1 - mp2[j] + sum > maxn){
                   maxn = i - 1 - mp2[j] + sum;
                   pos = j;
               } 
               sum += mp[j];
           }
           sum2 += maxn;
           ++mp2[pos];
       }
       int tmp = sum1 + sum2 + sum3;
       if (tmp >= n){
           sum3 += sum1;
           return 1;
       }else{
           --mp[x];
           return 0;
       }
   }
   ```
 - 作者：DailyPracticeAnn (4星)
   - 关键亮点：同样采用贪心策略，先确定所需字母个数，再通过贪心策略构造字符串。利用数组记录前缀信息，通过计算前缀和后缀的冒泡次数来确定每个位置的字符。
   - 重点代码核心思想：`getlen`函数确定所需字母个数。`max_mod`函数判断当前字符放入后能否满足总冒泡次数要求，计算前缀和后缀的冒泡次数总和。
   ```cpp
   bool max_mod(int let,int rem) {
       now1 = 0;now2 = 0;
       for (int i = let + 1;i < 26;i++) now1 += sum[i];
       sum[let]++;
       int tmpsum[26];
       memset(tmpsum, 0, sizeof(tmpsum));
       for(int i = 0;i < rem;i++) {
           int max = -1, tmp1 = 0,ops = 0;
           for (int j = 25;j >= 0;j--) {
               if (i - tmpsum[j] + tmp1 > max) {
                   max = i - tmpsum[j] + tmp1;
                   ops = j; 
               }
               tmp1 += sum[j];
           }
           now2 += max;
           tmpsum[ops]++;
       }
       if (now + now1 + now2 >= V) {
           now += now1;
           return 1;
       }
       else {
           sum[let]--;
           return 0;
       }
   }

   void getlen() {
       int tmp1 = 0,tmp2=0,tmp3=0;
       while (1) {
           tmp2 = tmp3;
           tmp3 += (2 * tmp1 + 25) * 13;
           if(tmp3 >= V) break;
           tmp1 += 25;
       }
       int num = tmp1 / 25 * 26;
       for (; tmp2 < V; tmp1++) {
           tmp2 += tmp1;
           num++;
       }
       let_num = num;
   }
   ```

最优关键思路或技巧：利用贪心策略，先确定字符串最短长度，再从前往后枚举字符，每次选择能使剩余字符按最大逆序对构造仍满足总逆序对要求的最小字典序字符。

可拓展之处：此类题目属于构造类问题，相似套路是先分析问题性质找到关键条件（如本题中最大逆序对与字符串长度关系），再利用贪心等策略逐步构造。

洛谷相似题目：
 - P1094 [NOIP2007 普及组] 纪念品分组
 - P1181 数列分段 Section II
 - P1223 排队接水

个人心得：无。 

---
处理用时：43.41秒
# 题目信息

# 「DPOI-1」道路规划

## 题目背景

不可以，总司令。

## 题目描述

战场上有 $n$ 个据点，从 $1\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。

一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。

## 说明/提示

#### 样例 #1 解释
下面是第 $1$ 组数据中一种可行的方案：

![](https://cdn.luogu.com.cn/upload/image_hosting/2uvwlydw.png)

#### 样例 #2 解释
该样例满足测试点 $3 \sim 6$ 的限制。
#### 数据范围
**本题测试点分数不等分。**

|  测试点编号  | $n \le$ | 特殊条件 |每个测试点分数|
| :----------: | :-----------: | :------: | :----: |
|     $1\sim 2$      |     $10$     |   无   |$5$|
|     $3\sim 6$      |     $1000$     |    无     |$5$|
|     $7\sim 8$      |     $10^5$     |    所有 $l_i = i-1$ 或所有 $l_i \geq \min (i, n - 1)$    |$5$|
| $9 \sim 10$  | $10^5$ | $l_i=0$ 或 $r_i=n-1$ |$5$|
| $11 \sim 15$ | $10^5$ | 无 |$10$|

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq l_i \leq r_i < n$，$1 \leq T \leq 10$。

## 样例 #1

### 输入

```
2
5
0 1 4 0 0
3 4 4 1 3
3
1 2 2
2 2 2```

### 输出

```
YES
NO```

## 样例 #2

### 输入

```
见下发文件 road2.in```

### 输出

```
见下发文件 road2.out```

# AI分析结果

### 综合分析与结论
这些题解思路相近，都基于将原问题转化为区间匹配问题来求解。核心是利用有向无环图（DAG）的拓扑序特性，把完全图边定向问题转化为给定区间寻找合适排列的问题，再用贪心算法解决。

算法要点在于对每个数，将左端点符合条件的区间右端点放入优先队列（或类似结构），取最小右端点匹配，若无法匹配则无解。

解决难点主要是证明贪心策略的正确性，以及理解如何从图的问题转化为区间匹配问题。

### 所选的题解
1. **作者：kevinchw (5星)**
    - **关键亮点**：思路清晰，先点明题目是“诈骗题”，强调不能建图，通过拓扑序将问题转化为区间匹配问题，并详细证明了贪心策略的正确性。代码简洁明了，变量命名规范。
    - **核心代码**：
``` C++
priority_queue<int,vector<int>,greater<int> > q;
struct node
{
    int l,r;
}a[100005];
vector<int> v[100005];
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        q=priority_queue<int,vector<int>,greater<int> >();
        int n;
        cin>>n;
        for(int i=1;i<=n;i++)
        {
            v[i].clear();
            int x;
            scanf("%d",&x);
            a[i].r=n-x;
        }
        for(int i=1;i<=n;i++)
        {
            int x;
            scanf("%d",&x);
            a[i].l=n-x;
            v[a[i].l].pb(a[i].r);
        }
        int now=1,op=0;
        for(int i=1;i<=n;i++)
        {
            for(int j=0;j<(int)v[i].size();j++)q.push(v[i][j]);
            if(q.empty())
            {
                cout<<"NO\n";
                op=1;
                break;
            }
            int x=q.top();q.pop();
            if(x<i)
            {
                cout<<"NO\n";
                op=1;
                break;
            }
        }
        if(!op)cout<<"YES\n";
    }
    return 0;
}
```
    - **核心实现思想**：先读入数据并处理出每个区间的左右端点，将左端点相同的区间右端点存入 `v` 数组。遍历 `1` 到 `n`，每次将左端点为当前 `i` 的区间右端点入优先队列 `q`，若队列为空或队首元素小于 `i` 则输出 `NO`，否则弹出队首元素继续循环，遍历结束若未出现不满足情况则输出 `YES`。
2. **作者：lngym (4星)**
    - **关键亮点**：从找规律入手，分析不同 `n` 值下的情况，化简题意得到区间匹配问题。代码注释详细，对重载运算符等细节有说明，适合初学者理解。
    - **核心代码**：
```cpp
typedef struct node
{
    int l;
    int r;
    inline bool operator <(const node x) const
    {
        return this->l<x.l;
    } 
}Node;
Node a[MAX];
int flag=1;
priority_queue<int,vector<int>,greater<int> > q;
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int n;
        scanf("%d",&n);
        for(re int i=1;i<=n;i++)
        {
            scanf("%d",&a[i].l);
            a[i].l++;
        }
        for(re int i=1;i<=n;i++)
        {
            scanf("%d",&a[i].r);
            a[i].r++;
        }
        sort(a+1,a+n+1);
        while(q.size()) q.pop();
        int now=1;
        for(re int i=1;i<=n;i++)
        {
            while(a[now].l<=i&&now<=n)
            {
                q.push(a[now].r);
                now++;
            }
            if(q.empty()||q.top()<i)
            {
                flag=0;
                break;    
            } 
            else q.pop();
        }
        if(flag==1) printf("YES");
        else printf("NO");
        putchar('\n');
        flag=1;
    }
    return 0;
}
```
    - **核心实现思想**：定义结构体 `Node` 存储区间左右端点并重载 `<` 运算符用于按左端点排序。读入数据并将区间端点加 `1` 便于操作，排序后遍历，将左端点小于等于当前 `i` 的区间右端点入队，若队空或队首小于 `i` 则标记无解，否则弹出队首，最后根据标记输出结果。
3. **作者：DengDuck (4星)**
    - **关键亮点**：先证明了 DAG 竞赛图拓扑序唯一，从入度为 `0` 的点的唯一性入手，逻辑严谨。代码简洁，变量命名合理。
    - **核心代码**：
```cpp
void Work()
{
    scanf("%lld",&n);
    for(int i=0;i<=n;i++)V[i].clear();
    priority_queue<LL,vector<LL>,greater<LL> >Q;
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&A[i].L);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&A[i].R);
        V[A[i].L].pb(A[i].R);
    }
    for(int i=0;i<n;i++)
    {
        while(!Q.empty()&&Q.top()<i)Q.pop();
        for(LL j:V[i])Q.push(j);
        if(Q.empty())
        {
            puts("NO");
            return;
        }
        Q.pop();
    }    
    puts("YES");
}
```
    - **核心实现思想**：在 `Work` 函数中，先清空存储右端点的数组 `V`，读入区间左右端点并将左端点相同的区间右端点存入 `V`。遍历 `0` 到 `n - 1`，每次先弹出小于当前 `i` 的队首元素，再将左端点为 `i` 的区间右端点入队，若队空则输出 `NO`，否则弹出队首元素，遍历结束输出 `YES`。

### 最优关键思路或技巧
1. **思维方式**：通过对有向无环图拓扑序特性的深入理解，将图的边定向问题巧妙转化为区间匹配问题，简化问题求解难度。
2. **算法技巧**：使用优先队列维护区间右端点，贪心选择最小右端点进行匹配，高效解决区间匹配问题。

### 可拓展之处
同类型题可涉及其他图结构性质与约束条件下的边定向或节点操作问题，类似算法套路是利用图的特定性质（如拓扑序、连通性等）转化为更易处理的组合问题（如区间、序列问题），再用贪心、动态规划等算法求解。

### 相似知识点洛谷题目
1. [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)：涉及拓扑排序相关知识，通过分析车站之间的等级关系构建拓扑图求解。
2. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)：需要对有向图进行缩点操作，利用强连通分量和拓扑序等知识解决问题。
3. [P1347 排序](https://www.luogu.com.cn/problem/P1347)：可通过拓扑排序判断能否确定唯一的序列顺序，与本题利用拓扑序转化问题有相似之处。

### 个人心得摘录与总结
暂无题解包含个人心得。 

---
处理用时：41.61秒
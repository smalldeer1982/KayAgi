# 题目信息

# [USACO22DEC] Range Reconstruction S

## 题目描述

Bessie 有一个数组 $a_1, \cdots, a_N$，其中 $1 \le N \le 300$ 并对于所有 $i$ 有 $0 \le a_i \le 10^9$。她不会告诉你数组 $a$ 本身，但她会告诉你 $a$ 的每个子数组的全距。也就是说，对于每对索引 $i \le j$，Bessie 告诉你 $r_{i,j}= \max a[i \cdots j]− \min a[i \cdots j]$。给定这些 $r$ 的值，构造一个可以作为 Bessie 的原始数组的数组。你的数组中的数值应在 $[−10^9,10^9]$ 范围内。 

## 说明/提示

### 样例 1 解释

例如，$r_{1,3}=\max a[1 \cdots 3]−\min a[1\cdots 3]=3−1=2$。

### 样例 2 解释

这个样例满足子任务 $1$ 的限制。

### 样例 3 解释

这个样例满足子任务 2 的限制。 

### 测试点性质

- 测试点 $5$ 满足 $r_{1,N} \le 1$。
- 测试点 $6-8$ 满足对于所有 $1 \le i<N$ 均有 $r_{i,i+1}=1$。
- 测试点 $9-14$ 没有额外限制。

## 样例 #1

### 输入

```
3
0 2 2
0 1
0```

### 输出

```
1 3 2```

## 样例 #2

### 输入

```
3
0 1 1
0 0
0```

### 输出

```
0 1 1```

## 样例 #3

### 输入

```
4
0 1 2 2
0 1 1
0 1
0```

### 输出

```
1 2 3 2```

## 样例 #4

### 输入

```
4
0 1 1 2
0 0 2
0 2
0```

### 输出

```
1 2 2 0```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解利用相邻元素极差 \(r_{i, i + 1}\) 来确定相邻元素差值关系。如设 \(a_1\) 为某值（常为0），通过 \(a_i = a_{i - 1} \pm r_{i - 1, i}\) 来确定 \(a_i\)，并利用已知的子数组极差 \(r_{i, j}\) 验证。部分题解针对特殊测试点有优化思路，如测试点5中序列最多两种数，测试点6 - 8利用 \(r_{i, i + 2}\) 辅助判断。
    - 算法要点：核心是利用子数组极差信息构造原数组，关键在于确定每个元素与前一个元素的关系，不同题解在判断符号的方式上有所不同，有的通过暴力枚举符号并验证，有的利用相邻三个数极差与相邻两个数差的关系，有的利用前缀和快速验证等。
    - 解决难点：难点在于如何根据给定的子数组极差准确确定每个元素的值，特别是确定 \(a_i = a_{i - 1} \pm r_{i - 1, i}\) 中的符号。不同题解通过不同方式验证，如利用其他子数组极差验证、利用相邻三个数极差关系等。

    - 整体质量：多数题解思路清晰，但部分题解代码可读性欠佳，部分题解有优化空间。没有题解达到5星，有3道题解可评为4星。

• 所选4星题解：
  - **作者：Mikefeng (赞：12)**
    - **星级**：4星
    - **关键亮点**：发现利用相邻两个数的极差 \(r_{i, i + 1}\) 及相邻三个数极差与相邻两个数差的关系确定元素相对关系，代码简洁。
    - **个人心得**：先假定前两个数关系推出后续数，WA后发现前两个数相同时需推广做法，找到相邻三组不一样的数求解。
    - **重点代码核心思想**：先设 \(ans[1] = 0\)，\(ans[2] = ans[1] + a[1][2]\)，之后通过判断 \(a[lst - 1][i]\) 与 \(a[lst - 1][lst] + a[lst][i]\) 的关系确定 \(ans[i]\) 与 \(ans[lst]\) 的关系，最后调整数组使所有元素非负。
    ```cpp
    const ll N = 305;
    const ll inf = 1e18;
    ll n, lst, minn = inf;
    ll ans[N];
    ll a[N][N];
    int main() {
        n = read();
        F(i, 1, n) F(j, i, n) a[i][j] = read();
        ans[1] = 0; ans[2] = ans[1] + a[1][2];
        lst = 2;
        F(i, 3, n) {
            if (a[lst - 1][i] == a[lst - 1][lst] + a[lst][i]) {
                if (ans[lst] < ans[lst - 1]) ans[i] = ans[lst] - a[lst][i];
                else ans[i] = ans[lst] + a[lst][i];
            } else {
                if (ans[lst] < ans[lst - 1]) ans[i] = ans[lst] + a[lst][i];
                else ans[i] = ans[lst] - a[lst][i];
            }
            if (a[i - 1][i]!= 0) lst = i;
        }
        F(i, 1, n) minn = min(minn, ans[i]);
        F(i, 1, n) ans[i] -= minn;
        F(i, 1, n) {
            printf("%lld", ans[i]);
            if (i!= n) putchar(' ');
        }
        printf("\n");
        return 0;
    }
    ```
  - **作者：Timmy_ (赞：7)**
    - **星级**：4星
    - **关键亮点**：思路直接，通过公式 \(a_i = a_{i - 1} \pm r_{i - 1, i}\) 先假设一种情况，利用前缀和数组快速验证 \(r_{1, i}\) 到 \(r_{i - 1, i}\) 是否符合给定极差，不符合则换另一种情况。
    - **个人心得**：死磕T1三小时最后发现没开long long，T2博弈论看不懂，T3赛后才发现是简单构造题。
    - **重点代码核心思想**：初始化 \(a[1] = 0\) 及前缀和数组，对于 \(i\) 从2到 \(n\)，先设 \(a[i] = a[i - 1] + r[i - 1, i]\)，验证不符合则设 \(a[i] = a[i - 1] - r[i - 1, i]\)，同时更新前缀和数组。
    ```cpp
    #include <iostream>
    using namespace std;
    const int N = 305;
    int n;
    int r[N][N];//输入
    int a[N];//构造数组
    int maxn[N], minx[N];//前缀和
    int main() {
        int i, j;
        cin >> n;
        for (i = 1; i <= n; i++)
            for (j = i; j <= n; j++)
                cin >> r[i][j];
        for (i = 1; i <= n; i++)//初始化前缀和maxn[j]代表从j到i的最大值，minx则相反
            maxn[i] = -1e9, minx[i] = 1e9;
        a[1] = 0;
        maxn[1] = 0;//注意a[1]的初始化
        minx[1] = 0;
        for (i = 2; i <= n; i++) {
            a[i] = a[i - 1] + r[i - 1][i];//先试正
            for (j = 1; j < i; j++) {
                if (max(a[i], maxn[j]) - min(a[i], minx[j])!= r[j][i])
                    break;//不符合
            }
            if (j!= i)
                a[i] = a[i - 1] - r[i - 1][i];//换成负
            for (j = 1; j <= i; j++) {
                maxn[j] = max(maxn[j], a[i]);//更新前缀和数组
                minx[j] = min(minx[j], a[i]);
            }
        }
        for (i = 1; i <= n; i++)
            cout << a[i] << " ";
        return 0;
    }
    ```
  - **作者：yemuzhe (赞：4)**
    - **星级**：4星
    - **关键亮点**：提出两种方法，法一暴力枚举符号验证，法二通过观察样例总结出根据当前方向及特定行的极差判断 \(a_i = a_{i - 1} \pm r_{i - 1, i}\) 中符号的方法，时间复杂度低。
    - **重点代码核心思想**：初始化 \(a_1 = 0\)，根据当前 \(ans[i - 1]\) 与 \(ans[pos]\) 的大小关系确定方向，根据方向和 \(r_{pos, i}\) 与 \(a_i\) 和 \(a_{pos}\) 差值关系确定 \(a_i\) 的值，并更新 \(pos\)。
    ```cpp
    #include <cstdio>
    #define N 305
    using namespace std;

    int n, pos = 1, c[N], ans[N], a[N][N];

    int main() {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j++) {
                scanf("%d", &a[i][j]);
            }
            if (i < n) {
                c[i + 1] = a[i][i + 1]; // 处理 c 数组
            }
        }
        for (int i = 2; i <= n; i++) {
            if (ans[i - 1] >= ans[pos]) // 正方向
            {
                if (ans[i - 1] + c[i] - ans[pos] == a[pos][i]) {
                    ans[i] = ans[i - 1] + c[i]; // 符号为“+”
                } else {
                    ans[i] = ans[i - 1] - c[i], pos = i - 1; // 符号为“-”，并将 k 调为 i - 1
                }
            } else // 负方向
            {
                if (ans[pos] - (ans[i - 1] - c[i]) == a[pos][i]) {
                    ans[i] = ans[i - 1] - c[i]; // 符号为“-”
                } else {
                    ans[i] = ans[i - 1] + c[i], pos = i - 1; // 符号为“+”，并将 k 调为 i - 1
                }
            }
        }
        for (int i = 1; i < n; i++) {
            printf("%d ", ans[i]);
        }
        printf("%d", ans[n]);
        return 0;
    }
    ```

• 最优关键思路或技巧：利用相邻元素极差 \(r_{i, i + 1}\) 确定相邻元素差值关系，通过分析相邻三个数极差与相邻两个数差的关系，或利用前缀和快速验证假设的元素值是否符合给定的子数组极差。

• 可拓展之处：此类题目属于根据数组衍生信息构造原数组类型，类似套路有利用前缀和、后缀和、相邻元素关系等信息来推导原数组。例如给定数组的前缀和数组，构造原数组；给定相邻元素和构造原数组等。

• 推荐洛谷题目：
    - P1990 覆盖墙壁：涉及利用递推关系构造方案数数组，与本题利用关系构造数组类似。
    - P1028 数的计算：通过给定规则构造数字序列，锻炼根据条件推导元素关系能力。
    - P1216 数字三角形：利用子问题的最优解构造全局最优解，类似本题通过局部关系构造整体数组。 

---
处理用时：43.46秒
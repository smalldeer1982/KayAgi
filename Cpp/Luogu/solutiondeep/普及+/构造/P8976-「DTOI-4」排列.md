# 题目信息

# 「DTOI-4」排列

## 题目背景

**Update on 2023.2.1：新增一组针对 @[yuanjiabao](https://www.luogu.com.cn/user/455558) 的 Hack 数据，放置于 #21。**

**Update on 2023.2.2：新增一组针对 @[CourtesyWei](https://www.luogu.com.cn/user/664070) 和 @[bizhidaojiaosha](https://www.luogu.com.cn/user/613616) 的 Hack 数据，放置于 #22。**

------------

~~构造一个排列 $p$，使得~~$\small\color{white}{下标为奇数的项之和 \geq a 且下标为偶数的项之和 \geq b。}$

## 题目描述

小 L 给你一个**偶数** $n$ 和两个整数 $a, b$，请你构造一个长为 $n$ 的排列 $p$，使得其满足 $\displaystyle\sum_{i = 1}^{\frac{n}{2}} p_i \geq a$ 且 $\displaystyle\sum_{i = \frac{n}{2} + 1}^{n} p_i \geq b$。

## 说明/提示

**本题开启 Special Judge。**

| $\textbf{Subtask}$ | $n$ | $a, b$ | 分值 |
| :------: | :------: | :------: | :------: |
| $1$ | $2 \leq n \leq 10$ | 无特殊限制 | $20 \operatorname{pts}$ |
| $2$ | 无特殊限制 | $a = b = 0$ | $10 \operatorname{pts}$ |
| $3$ | 同上 | $a = 0$ 或 $b = 0$ | $10 \operatorname{pts}$ |
| $4$ | 同上 | 无特殊限制 | $60 \operatorname{pts}$ |

对于 $100\%$ 的数据，$2 \leq n, \sum n \leq 10^5$，$0 \leq a, b \leq \frac{n(n + 1)}{2}$，$1 \leq T \leq 10$，$n$ 为**偶数**。

## 样例 #1

### 输入

```
2
6 6 12
6 8 14```

### 输出

```
1 6 2 5 3 4
-1```

# AI分析结果

• **综合分析与结论**：这些题解思路主要围绕判断无解情况和构造满足条件的排列。多数题解先通过判断 \(a + b > \frac{n(n + 1)}{2}\) 确定无解情况。构造排列时，有的从贪心角度，先满足前半段和为 \(a\) 并保证后半段尽量大；有的通过交换左右两半元素来调整和。算法要点在于合理利用排列数字总和固定这一特性，难点是如何在满足前半段和要求的同时，保证后半段和也满足要求。
- **作者：是青白呀**：
  - **星级**：4星
  - **关键亮点**：思路清晰，通过分析和的取值范围，利用贪心策略，从特定区间选取数字构造满足和为 \(a\) 的前半段排列，同时解释详细并给出示例辅助理解。
  - **个人心得**：无
  - **核心代码片段**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int t;
signed main(){
    int t;
    read(t);
    while(t--){
        int n,a,b;
        read(n),read(a),read(b);
        int sum=(1+n/2)*n/4;
        if(sum>=a){//a选择1~n/2
            if((1+n)*n/2-sum<b)printf("-1\n");
            else{
                for(int i=1;i<=n;i++)
                    printf("%d ",i);
                printf("\n");
            }
            continue;
        }
        int movnum=(a-sum)/(n/2);//增加n/2的次数
        if(movnum>n/2||(movnum==n/2&&(a-sum)%(n/2))){//总操作次数不能大于n/2
            printf("-1\n");
            continue;
        }
        bool vis[N]={};//标记哪些数属于前半部分
        int suma=0;
        for(int i=1;i<(n/2)-movnum;i++)
            suma+=i,vis[i]=1;
        suma+=(n/2)-movnum+(a-sum)%(n/2);
        vis[(n/2)-movnum+(a-sum)%(n/2)]=1;
        for(int i=(n/2)-movnum+1;i<=n/2;i++)
            suma+=i+n/2,vis[i+n/2]=1;
        if((1+n)*n/2-suma<b)printf("-1\n");
        else{
            for(int i=1;i<=n;i++)
                if(vis[i])printf("%d ",i);
            for(int i=1;i<=n;i++)
                if(!vis[i])printf("%d ",i);
            printf("\n");
        }
    }
    return 0;
}
```
  - **核心实现思想**：先计算初始和 \(sum\) ，若 \(sum \geq a\) ，直接判断后半段和是否满足 \(b\) 。否则计算移动次数 \(movnum\) ，标记前半段选取的数，计算前半段和 \(suma\) ，再判断后半段和是否满足 \(b\) ，最后按标记输出排列。
- **作者：lcbridge**：
  - **星级**：4星
  - **关键亮点**：思路独特，通过计算差值 \(d\) ，利用贪心策略，每次交换能使前半段和增加最大的两个数，详细分析交换过程及无解情况。
  - **个人心得**：赛时调很久，发题解纪念。
  - **核心代码片段**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int T,n,p[100005],a,b;
signed main(){ 
    scanf("%lld",&T);  
    while(T--){
        scanf("%lld%lld%lld",&n,&a,&b); 
        for(int i=1;i<=n;i++)p[i]=i; 
        int d=a; 
        for(int i=1;i<=n/2;i++)d-=p[i]; 
        int cnt=1; 
        while(d>0&&cnt<=n/2){ 
            if(d-(p[n-cnt+1]-p[cnt])<=0)break; 
            d-=(p[n-cnt+1]-p[cnt]);
            swap(p[cnt],p[n-cnt+1]); 
            cnt++;
        }
        int len=n/2-cnt+1;
        if(len*2<=d){
            printf("-1\n");
            continue;
        }
        if(d>len)swap(p[cnt],p[cnt+d]); 
        if(d<=len&&d>0)swap(p[n/2],p[n/2+d]);
        int tmp1=0;
        for(int i=n/2+1;i<=n;i++)tmp1+=p[i];
        if(tmp1>=b)for(int i=1;i<=n;i++)printf("%lld ",p[i]);
        else printf("-1");
        printf("\n");
    }
    return 0;
}
```
  - **核心实现思想**：初始化排列 \(p_i = i\) ，计算与 \(a\) 的差值 \(d\) ，通过贪心交换使前半段和增加，根据不同条件判断无解或继续交换，最后判断后半段和是否满足 \(b\) 并输出结果。
- **作者：Leasier**：
  - **星级**：4星
  - **关键亮点**：分 \(a < b\) 和 \(a \geq b\) 两种情况讨论，利用等差数列求和公式，简洁明了地构造出满足条件的排列。
  - **个人心得**：无
  - **核心代码片段**：
```cpp
#include <stdio.h>
typedef long long ll;
int ans[100007];
bool vis[100007];
inline ll sum1(int n){
    return (ll)n * (n + 1) / 2;
}
int main(){
    int t;
    scanf("%d", &t);
    for (int i = 1; i <= t; i++){
        int n;
        ll a, b, t1;
        scanf("%d %lld %lld", &n, &a, &b);
        t1 = sum1(n);
        if (a + b > t1){
            printf("-1\n");
            continue;
        }
        int m = n / 2;
        if (a < b){
            ll sum = sum1(m);
            if (t1 - sum < b){
                printf("-1\n");
                continue;
            }
            for (int j = 1; j <= m; j++){
                ans[j] = j;
            }
            if (sum < a){
                ll t2 = (a - sum) / m;
                a = (a - sum) % m;
                for (int j = 1; j <= m; j++){
                    ans[j] += t2;
                }
                for (ll j = 1; j <= a; j++){
                    ans[m - j + 1]++;
                }
            }
        } else {
            ll sum = t1 - sum1(m);
            if (sum < a){
                printf("-1\n");
                continue;
            }
            for (int j = 1; j <= m; j++){
                ans[j] = n - j + 1;
            }
            if (t1 - sum < b){
                ll t2 = (sum - a) / m;
                a = (sum - a) % m;
                for (int j = 1; j <= m; j++){
                    ans[j] -= t2;
                }
                for (ll j = 1; j <= a; j++){
                    ans[m - j + 1]--;
                }
            }
        }
        for (int j = 1; j <= n; j++){
            vis[j] = false;
        }
        for (int j = 1; j <= m; j++){
            vis[ans[j]] = true;
        }
        for (int j = m + 1, k = 1; j <= n; j++, k++){
            while (vis[k]) k++;
            ans[j] = k;
        }
        for (int j = 1; j <= n; j++){
            printf("%d ", ans[j]);
        }
        printf("\n");
    }
    return 0;
}
```
  - **核心实现思想**：先判断无解情况，根据 \(a\) 和 \(b\) 的大小关系分别构造排列，利用等差数列求和公式计算和并调整，最后通过标记数组确定后半段排列。

**最优关键思路或技巧**：利用排列数字总和固定的特性，通过贪心策略，优先满足前半段和的要求，并在满足前半段和的基础上，保证后半段和也能满足条件。如通过计算差值，合理交换元素来调整前半段和，同时考虑后半段和的变化。

**可拓展思路**：同类型题可涉及不同的区间划分方式，或对排列元素有其他限制条件。类似算法套路是先确定无解情况，再利用贪心或其他策略进行构造，同时要注意数据结构的合理使用来辅助构造过程。

**推荐洛谷题目**：
- P1223 排队接水：贪心算法，根据每个元素的属性进行排序，合理安排顺序以满足某种最优条件。
- P1094 纪念品分组：贪心策略，通过对数据排序，从两端向中间遍历，分组以满足特定条件。
- P1199 三国游戏：贪心与博弈结合，通过分析局势，利用贪心策略选取最优决策。 

---
处理用时：42.34秒
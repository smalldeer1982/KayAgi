# 题目信息

# 「GMOI R2-T2」猫耳小（加强版）

## 题目背景

**本题与 [原题](https://www.luogu.com.cn/problem/P9199) 的区别在于数据范围和输出格式。在这一版本中，$n\le 10^6$，值域为 $10^9$，你需要给出构造。**

![](https://cdn.luogu.com.cn/upload/image_hosting/r8a6ylx3.png)

## 题目描述

小 R 是一个可爱的猫耳女孩子，她喜欢研究数列的 $\operatorname{mex}\text{*}$。

现在她有一个长度为 $n$ 的数列 $a$。她讨厌整数 $k$，因此她希望修改数列 $a$ 的若干个元素为任意**自然数**，使得 $a$ 的任意**连续非空子串**的 $\operatorname{mex}$ 都不等于 $k$。

请你求出最少需要修改多少个元素，并给出方案。

$\text{*}$ 本题中，数列的 $\operatorname{mex}$ 被定义为数列中最小未出现的**自然数**，例如：

- $\operatorname{mex}\{1,2,3\}=0$，因为 $0$ 是自然数。
- $\operatorname{mex}\{0,1,3\}=2$。
- $\operatorname{mex}\{0,1,2\}=3$。

## 说明/提示

**样例解释**

一种方案是将 $\{1,0,1,3,0\}$ 改为 $\{1,1,1,3,2\}$，共改动两个元素。

可以证明不存在更优的方案。

---

**评分方式**

本题采用自定义校验器（Special Judge）进行评测。

对于每个测试点，如果你的最小步数正确，可以得到 $30\%$ 的分数。在此基础上，如果方案也正确，可以得到满分。

请注意：即使你不会给出方案，也请按照输出格式在第二行输出 $n$ 个整数。

---

**本题采用捆绑测试，数据无梯度。**

对于 $100\%$ 的数据，$1\le n\le 10^6$，$0\le k,a_i\le 10^9$。

本题读写量较大，建议使用效率较高的读写方式。

## 样例 #1

### 输入

```
5 2
1 0 1 3 0```

### 输出

```
2
1 1 1 3 2```

# AI分析结果

• 综合分析与结论：这些题解的核心思路都是基于贪心策略。关键在于认识到若子串包含k，其mex一定不为k，大于k的数对判断mex是否为k无影响。算法要点在于遍历数组，通过不同方式记录0到k - 1数字的出现情况，当出现0到k - 1所有数字且当前数不为k时，将当前数改为k。难点主要在于处理大数据范围下的时间复杂度优化，部分题解通过避免对大数组频繁清零等方式优化。

所选的题解：
  - 作者：sto_5k_orz (5星)
    - 关键亮点：思路清晰简洁，利用set判断区间内是否包含0到k - 1所有数，代码实现高效，读写采用自定义优化函数。
    ```cpp
    // 核心代码片段
    for(int i = 1; i <= n; i++) {
        if(a[i] == k) {
            st.clear();
            continue;
        }
        if(a[i] < k) st.insert(a[i]);
        if(st.size() == k) {
            ans++; a[i] = k;
            st.clear();
        }
    }
    ```
    核心实现思想：遍历数组，遇到k清空set；小于k的数插入set，当set大小为k时，说明0到k - 1都出现了，将当前数改为k并清空set。
  - 作者：QianRan_GG (4星)
    - 关键亮点：对k进行分类讨论，逻辑严谨，用cnt数组记录0到k - 1数字出现次数，代码可读性较好。
    ```cpp
    // 核心代码片段
    for(int l = 0, i = 1; i <= n; ++ i) {
        b[i] = a[i];
        if(a[i] > k) continue;
        else if(a[i] == k) {
            while( ++ l < i) if(a[l] < k) cnt[a[l]] --; 
            mex = 0;
        }
        else {
            cnt[a[i]] ++;
            while(cnt[mex]) mex ++;
            if(mex == k) {
                ans ++;
                while( ++ l < i) if(a[l] < k) cnt[a[l]] --;
                cnt[a[i]] --; 
                b[i] = k;
                mex = 0;
            }
        }
    }
    ```
    核心实现思想：遍历数组，大于k跳过；等于k时重置cnt数组；小于k时计数，当mex为k时，修改当前数为k并重置cnt数组。
  - 作者：GeorgeAAAADHD (4星)
    - 关键亮点：同样对特殊情况分类讨论，详细阐述贪心策略，代码注释详细，易于理解。
    ```cpp
    // 核心代码片段
    int l=0;
    f(r,1,n){
        cin>>a[r];
        b[r]=a[r];
        if(a[r]>k)continue;
        if(a[r]==k){
            while(++l<r)if(a[l]<k)tp[a[l]]--;
            mex=0;
            continue;
        }
        else{
            tp[a[r]]++;
            while(tp[mex])mex++;
            if(mex==k){
                ans++;
                fill(tp,tp+k,0);
                l=r;
                b[l]=k;
                mex=0;
            }
        }
    }
    ```
    核心实现思想：遍历数组，大于k跳过；等于k时重置计数数组；小于k时计数，mex为k时修改当前数为k并重置计数数组。

最优关键思路或技巧：利用贪心策略，将需要修改的数改为k，通过巧妙的数据结构（如set）或数组计数方式，高效判断区间内是否包含0到k - 1所有数，同时注意避免大数据范围下的时间复杂度陷阱，如避免对大数组的频繁清零操作。

可拓展之处：此类题目属于序列修改与mex相关的问题，类似套路可应用于其他涉及序列性质维护与修改的题目，例如在满足特定子序列条件下最小化修改次数等。

推荐题目：
  - P1449 后缀表达式
  - P2672 推销员
  - P1080 国王游戏 

---
处理用时：21.44秒
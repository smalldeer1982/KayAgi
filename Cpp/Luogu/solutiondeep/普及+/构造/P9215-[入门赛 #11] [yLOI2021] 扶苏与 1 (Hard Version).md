# 题目信息

# [入门赛 #11] [yLOI2021] 扶苏与 1 (Hard Version)

## 题目背景

**本题与 Easy Version 的区别是：$x$ 的范围不同，$y$ 的长度限制不同**。

**请注意 Easy Version 和 Hard Version 不是严格的包含关系。**

扶苏在 ICPC2022 EC Final 的比赛里，开局不到五分钟，就读假了一道题，把一道数位 DP 开成了简单签到，狠狠地演了队友一把。

为了不让读假了的题被浪费，所以这道题出现在了这里。

## 题目描述

扶苏给了你一个数字 $x$，你需要给她一个数字 $y$，使得在列竖式计算 $x + y$ 时，能恰好产生 $k$ 个进位。

**你给出的 $y$ 的长度不能超过 $x$ 的长度。**（注意，这条要求与 Easy Version 不同）

**进位**的含义是：在进行竖式加法运算时，如果位于同一列上的数字之和（加上低位向上可能存在的进位）比 $9$ 大，则在结果的这一列上只保留这个和的个位数字，同时称这一位向它的高位产生了一个**进位**。

下图是一个竖式加法的例子，结果中标红的两位都向上产生了进位。

![](https://cdn.luogu.com.cn/upload/image_hosting/sxkzrk4i.png)

## 说明/提示

### 数据规模与约定

对全部的测试点，保证 $0 \leq x < 10^{(10^4)}$，$1 \leq T \leq 5000$，$1 \leq k \leq 1+\log_{10}\max(1,x)$。输入的 $x$ 不含前导 $0$。

### 提示

输入的 $x$ 可能会很大。如果说 $x < 10^t$，则输入 $x$ 的**长度**不会超过 $t$。数据规模中式子 $k \leq 1 + \log_{10}\max(1,x) $ 的含义是：$k$ 不会超过 $x$ 的长度。

## 样例 #1

### 输入

```
5
1
1
14
1
514
2
1234
1
123456
6```

### 输出

```
9
8
516
7
877777```

# AI分析结果

• 综合分析与结论：这些题解的核心都是围绕如何构造满足条件的数字 $y$ 使得 $x + y$ 产生 $k$ 个进位。思路上，多数题解先考虑删除 $x$ 末尾无进位作用的 $0$ 并统计其个数，判断 $x$ 剩余长度与 $k$ 的关系以确定是否无解。构造 $y$ 时，利用 $9$ 与非零数相加易进位的特点，根据 $x$ 中 $0$ 和非零数的分布及 $k$ 的要求来确定 $y$ 各位数字。算法要点在于对 $x$ 按 $0$ 分段或寻找关键位置（如第 $k$ 位是否为 $0$ 等）进行针对性构造。解决难点主要是处理 $x$ 中 $0$ 的位置对进位的影响，确保准确构造出 $k$ 个进位。

从质量上看，“一扶苏一”和“Big_Dinosaur”的题解思路清晰，对构造方法有详细证明或解释，代码可读性较好，可评为4星；“离散小波变换°”思路独特，按 $0$ 分段构造，但代码稍复杂，可读性略逊，可评为3星；其他题解在思路清晰度或代码规范性上存在不足，多为2星或以下。

最优关键思路或技巧：利用 $9$ 与非零数相加进位的特性，结合 $x$ 中 $0$ 的分布来构造 $y$。如找到 $x$ 中关键位置（如第 $k$ 位、$0$ 段前后的非零数位置等），根据这些位置与 $k$ 的关系确定 $y$ 各位数字，使构造的 $y$ 能准确产生 $k$ 个进位。

可拓展之处：同类型题可拓展到其他高精度运算的构造问题，类似算法套路是先分析关键数字对运算结果的影响（如本题中 $0$ 和 $9$ 对进位的影响），再根据给定条件（如进位次数、数字长度限制等）对数字进行分段或定位关键位置，从而构造出满足要求的数字。

推荐题目：
  - P1018 [NOIP2000 提高组] 乘积最大，涉及数字组合与贪心策略，与本题构造数字思路类似。
  - P1036 [NOIP2002 普及组] 选数，通过组合数字满足特定条件，锻炼构造思维。
  - P1106 删数问题，同样是对数字进行操作以满足某种要求，与本题构造数字思想有相通之处。

个人心得摘录与总结：
  - “shiranui”：最初正着做没调试出来，后采用倒着做的方法。总结出产生进位的相关结论，从后往前按位考虑，根据数字是否为 $0$ 及进位情况抉择是否进位，若进位引发的连环进位超过剩余进位次数则不进位。此心得强调了做题时换个角度思考可能会有新突破，同时对进位规律的总结有助于解决问题。

所选4星题解：
  - “一扶苏一”（4星）
    - 关键亮点：思路清晰，先给出简单情况下的构造及证明，再详细分析复杂情况（第 $k$ 位为 $0$ 时）的构造方法，通过找关键位置 $p$ 和 $q$ 构造出满足 $k$ 个进位的 $y$，并配有示例图辅助理解。
    - 核心代码：
```cpp
#include <assert.h>
#include <string>
#include <iostream>
#include <algorithm>

int T;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    for (std::cin >> T; T; --T) {
        int k;
        std::string s; std::cin >> s >> k;
        if (s == "0") {
            std::cout << "-1\n";
            continue;
        }
        std::string ans;
        assert(k <= s.length());
        int endp = k - 1;
        while (s[endp] == '0') --endp;
        for (int i = 0; i <= endp; ++i) {
            ans.push_back('9');
        }
        if (endp!= k - 1) {
            int q = k - 1;
            while (q < s.size() && s[q] == '0') ++q;
            if (q == s.size()) {
                std::cout << "-1\n";
                continue;
            }
            int p = k - endp - 1;
            p = q - p + 1;
            for (int i = endp + 1; i < p; ++i) ans.push_back('0');
            for (int i = p; i <= q; ++i) ans.push_back('9');

        }
        while(s.size() > ans.size()) ans.push_back('0');
        std::cout << ans << '\n';
    }
}
```
核心实现思想：先判断 $x$ 是否为 $0$ 及 $k$ 是否超过 $x$ 长度。找到第 $k$ 位之前最后一个非零位置 $endp$，前 $endp$ 位构造为 $9$。若第 $k$ 位为 $0$，找到第 $k$ 位之后第一个非零位置 $q$，根据 $q$ 与 $k$ 的关系在相应位置填充 $0$ 和 $9$，最后补齐 $0$ 使 $y$ 与 $x$ 长度相同。
  - “Big_Dinosaur”（4星）
    - 关键亮点：思路简洁明了，先删除 $x$ 末尾 $0$ 并统计个数，根据剩余 $x$ 长度与 $k$ 的关系判断无解情况。通过对 $x$ 中 $0$ 和非零数的分析，直接确定 $y$ 各位数字，逻辑清晰。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,k,a;string x,s;
void doit(){
    s="";a=0;
    while(x[x.size()-1]=='0'){
        x.erase(x.size()-1);++a;
    }
    if(x.size()<k){
        puts("-1");return;
    }
    for(int i=0;i<x.size();++i)if(x[i]=='0'||!k)s+='0';else{
        s+='9';--k;
    }
    for(int i=x.size()-1;i>=0;--i)if(x[i]=='0'&&k){
        s[i]='9';--k;
    }
    cout<<s;
    for(int i=1;i<=a;++i)putchar('0');puts("");
}
int main(){
    scanf("%d",&t);
    while(t--){
        cin>>x>>k;
        doit();
    }
}
```
核心实现思想：删除 $x$ 末尾 $0$ 并记录个数 $a$，若剩余 $x$ 长度小于 $k$ 则无解。遍历 $x$，非零数对应位设为 $9$ 并减少 $k$，遇到 $0$ 或 $k$ 为 $0$ 则设为 $0$。再从后往前遍历，若 $x$ 为 $0$ 且 $k$ 不为 $0$，则设为 $9$ 并减少 $k$，最后输出 $y$ 并补上 $a$ 个 $0$。 

---
处理用时：35.57秒
# 题目信息

# 夕阳西下几时回

## 题目背景

随着夕阳从山间落下，最后一丝余晖逐渐暗淡；美丽的晚霞，终究还是化作一片黑夜。在这番景象中，一阵又一阵的乡愁涌上心头；远离家乡的游子，就算不是病死他乡，又何时能回还？

## 题目描述

夕阳可以被视作由 $n$ 种不同颜色组成的一副图，其中第 $i$ 种的颜色为 $a_i$，满足 $a$ 是长度为 $n$ 的排列。

定义一个排列的乡愁度为：

+ 对于所有 $1\le i\le n$，记 $b_i=\gcd(a_i,a_{i+1})$。特别地，我们认为 $a_{n+1}=a_1$。
+ 排列 $a$ 的乡愁度为序列 $b$ 中**不同**元素的个数。

求是否有一个长度为 $n$，乡愁度为 $k$ 的排列 $p$。若有解，请输出任意一个排列。

## 说明/提示

**【提示】**

一个长度为 $n$ 的排列是一个满足 $1$ 到 $n$ 中的所有正整数恰好出现 $1$ 次的数组。例如，$[3,1,2]$ 是一个长度为 $3$ 的排列，而 $[5,5,1,2,3]$ 不是一个排列。

**【样例 1 解释】**

- 对于第一组数据，$b=[1,1,1,1,1,1,1]$，故 $p$ 的乡愁度为 $1$。
- 对于第二组数据，可以证明不存在这样的序列。
- 对于第三组数据，$b=[1,1,3,3,1,1,2,1,5,2,1]$，包含 $4$ 个不同的元素 — $1,2,3$ 和 $5$，故 $p$ 的乡愁度为 $4$。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（4 points）：$n\le 9$，$\sum n\le 100$。
-  Subtask 2（5 points）：$k=1$。
-  Subtask 3（13 points）：$\sum n\le 200$。
-  Subtask 4（30 points）：对于所有测试数据，保证有解。
-  Subtask 5（48 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$3\le n\le 3\times 10^5$，$1\le k\le n$，$\sum n \le 6\times 10^5$。

## 样例 #1

### 输入

```
3
7 1
6 5
11 4
```

### 输出

```
Yes
1 2 3 4 5 6 7
No
Yes
1 11 9 3 6 7 8 2 5 10 4
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是基于数论知识，先判断 $k$ 的取值范围，当 $k > \lfloor\frac{n}{2}\rfloor$ 时无解，因为 $1$ 到 $n$ 中任意两个不同正整数的最大公约数至多为 $\lfloor\frac{n}{2}\rfloor$。对于有解的情况，通过构造特定排列来满足乡愁度为 $k$ 的要求。多数题解采用将数字与它的倍数相连的方式构造排列，不同之处在于具体构造过程和代码实现细节。

### 所选的题解
- **作者：Ecrade_ (5星)**
    - **关键亮点**：思路清晰简洁，先明确 $k$ 的理论上界，然后针对 $k$ 达到上界和小于上界的情况分别给出构造方法，代码实现简洁高效。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll t,n,k;
inline ll read(){
    ll s = 0,w = 1;
    char ch = getchar();
    while (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}
    while (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
    return s * w;
}
int main(){
    t = read();
    while (t --){
        n = read(),k = read();
        if (k > n / 2){puts("No"); continue;}
        puts("Yes"),printf("1 ");
        for (ll i = n;i >= k * 2 + 1;i -= 1) printf("%lld ",i);
        for (ll i = 1;i <= k * 2;i += 2) for (ll j = max(2ll,i);j <= k * 2;j *= 2) printf("%lld ",j);
        puts("");
    }
    return 0;
}
```
    - **核心实现思想**：先判断 $k$ 是否大于理论上界，若大于则无解。有解时，先输出 $1$，接着倒序输出 $2k + 1$ 到 $n$ 的数，再按特定规律输出能构造出不同最大公约数的数。
- **作者：SXqwq (4星)**
    - **关键亮点**：对构造思路的分析详细，从证明 $b$ 数组中不同数字的上限，到考虑如何最大化不同数字的构造，再到针对 $k$ 个不同数字的构造，逻辑连贯，代码简洁明了。
    - **重点代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int T;
int main()
{
    cin>>T;
    while(T--)
    {
        int n,k;
        scanf("%d%d",&n,&k);
        if(k > n/2) 
        {
            cout<<"No"<<endl;
            continue;
        }
        cout<<"Yes"<<endl;
        cout<<"1 ";
        for(int i=n;i>=2*k+1;i--) cout<<i<<" "; 
        for(int i=2;i<=2*k;i*=2) cout<<i<<" "; 
        for(int i=3;i<=2*k;i+=2) 
        {
            for(int j=i;j<=2*k;j*=2) cout<<j<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```
    - **核心实现思想**：与 Ecrade_ 的思路类似，先判断无解情况，有解时先输出 $1$ 和 $2k + 1$ 到 $n$ 的倒序数字，然后分别构造 $2$ 的整次幂和奇数相关的序列。
- **作者：_Weslie_ (4星)**
    - **关键亮点**：对思路的阐述详细，从分析 $k$ 的理论上界，到构造过程中对重复情况的考虑以及如何满足 $k$ 的限制，都有清晰说明，代码实现也较为简洁。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,k,a[300005];
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&k);
        if(k>n/2){
            printf("No\n");
            continue;
        }
        cout<<"Yes\n1 ";
        for(int i=n;i>=2*k+1;i--)cout<<i<<' ';
        for(int i=1;i<=2*k;i+=2){
            for(int j=max(2,i);j<=k*2;j*=2)cout<<j<<' ';
        }
        cout<<endl;
    }
}
```
    - **核心实现思想**：同样先判断无解情况，有解时输出 $1$ 及 $2k + 1$ 到 $n$ 的倒序数字，再通过特定循环构造满足条件的排列。

### 最优关键思路或技巧
1. **利用数论性质判断无解情况**：通过分析 $1$ 到 $n$ 中两数最大公约数的上限，快速判断 $k > \lfloor\frac{n}{2}\rfloor$ 时无解，缩小问题规模。
2. **基于倍数关系构造排列**：利用 $\gcd(x, 2x) = x$ 的性质，将数字与它的倍数相连构造排列，以产生不同的最大公约数，满足乡愁度要求。

### 可拓展思路
此类题目属于数论构造类型，常见拓展方向是改变排列的约束条件或最大公约数的计算方式。例如，将环改为线性排列，或者考虑多个数的最大公约数等。类似算法套路是先通过数论分析找到关键限制条件，再基于数论性质构造满足条件的解。

### 相似知识点题目推荐
1. **P1072 [NOIP2009 普及组]  Hankson 的趣味题**：涉及数论中最大公约数和最小公倍数的计算与推理。
2. **P2152 [SDOI2009]  SuperGCD**：专注于大整数的最大公约数计算，考察数论知识与高精度运算。
3. **P1572 [NOIP2016 提高组]  朋友圈**：结合图论与数论，通过判断数之间的整除关系构建图，进而解决问题。 

---
处理用时：31.92秒
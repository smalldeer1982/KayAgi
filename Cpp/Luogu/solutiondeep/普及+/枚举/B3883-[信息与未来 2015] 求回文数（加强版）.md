# 题目信息

# [信息与未来 2015] 求回文数（加强版）

## 题目描述

一个正整数，正读和反读都相同的数为回文数，例如 $22,131,2442,37073,6,\cdots$。所有的 $1$ 位数都是回文数。

现给出一个正整数 $n$，求出 $[1,n]$ 中的回文数的个数。

## 说明/提示

### 样例解释
在 $1$ 至 $24$ 中，回文数有 $1\sim 9,11,22$，共 $11$ 个。
### 数据范围
$1\le n\le10^{100}$。

## 样例 #1

### 输入

```
24```

### 输出

```
11```

# AI分析结果

### 综合分析与结论
这两道题解均围绕计算 $[1,n]$ 中回文数个数的问题展开。zjh114514 的题解运用数位 dp 算法，先计算不足 $n$ 位的回文数个数，再对 $n$ 位数采用记忆化搜索优化的暴力枚举法；沉石鱼惊旋的题解将问题分为 $len < |n|$ 和 $len = |n|$ 两部分，前者通过公式计算，后者先找出最大比 $n$ 小的回文串，再统计个数。

### 所选题解
- **zjh114514 的题解（4星）**
    - **关键亮点**：思路清晰，详细阐述了数位 dp 的应用，代码实现规范，有详细注释，方便理解。
    - **核心代码**：
```cpp
int dfs(bool lim,int pos){
    if(pos==(len>>1)){
        if(!lim) return 1;
        return check();
    }
    if(~dp[lim][pos]) return dp[lim][pos];
    int res=0;
    for(int i=0;i<=9;i++){
        if(pos==len&&!i) continue;
        if(lim&&i>a[pos]) break;
        temp[++total]=i;
        res=(res+dfs(lim&&i==a[pos],pos-1))%MOD;
        total--;
    }
    return dp[lim][pos]=res;
}

int solve(){
    for(int i=1;i<=len;i++) a[i]=s[len-i+1]-48;
    int res=0;
    for(int i=len-1;i;i--){
        int res2=9;
        for(int j=i-1;j>(i>>1);j--) res2=(res2*10)%MOD;
        res=(res+res2)%MOD;
    }
    memset(dp,-1,sizeof(dp));
    res=(res+dfs(1,len))%MOD;
    return res;
}
```
    - **核心实现思想**：`dfs` 函数进行记忆化搜索，`lim` 标记前面高位是否和原数相同，`pos` 为当前下标。`solve` 函数先将输入字符串转为数字，计算不足 $n$ 位的回文数个数，再调用 `dfs` 函数计算 $n$ 位的回文数个数。

### 最优关键思路或技巧
- 数位 dp 结合记忆化搜索，可有效处理大数字范围的计数问题。
- 先计算不足 $n$ 位的回文数个数，再单独处理 $n$ 位的情况，降低问题复杂度。

### 可拓展之处
同类型题如计算给定区间 $[l,r]$ 内满足特定条件（如回文、数字和为某值等）的数字个数，可采用类似的数位 dp 思路，通过预处理和记忆化搜索优化。

### 推荐题目
- P2602 [ZJOI2010] 数字计数
- P3413 SAC#1 - 萌数
- P4127 [AHOI2009] 同类分布

### 个人心得
题解中未包含个人心得内容。 

---
处理用时：20.78秒
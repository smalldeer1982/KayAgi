# 题目信息

# [NOIP 1998 普及组] 三连击

## 题目背景

本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。

## 题目描述

将 $1, 2, \ldots , 9$ 共 $9$ 个数分成 $3$ 组，分别组成 $3$ 个三位数，且使这 $3$ 个三位数构成 $1 : 2 : 3$ 的比例，试求出所有满足条件的 $3$ 个三位数。

## 说明/提示

NOIP1998 普及组 第一题

## 样例 #1

### 输入

```
无```

### 输出

```
192 384 576
* * *
...

* * *
（剩余部分不予展示）```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是找出满足 1:2:3 比例且由 1 - 9 组成无重复数字的三个三位数。主要方法有枚举第一个数，再计算另外两个数并检查数字是否重复；生成 1 - 9 的全排列，将其拆分为三个数并检查比例关系。

在算法要点上，部分题解通过限制第一个数的范围（如 123 - 333）减少枚举量；使用数组或集合记录数字是否出现来判断重复；还有利用 1 - 9 的和与积的固定值来判断数字是否完整且无重复。

难点在于如何高效地判断数字是否重复以及如何减少不必要的枚举。不同题解在实现细节和优化程度上有所差异。

### 所选题解
- **作者：Kelin (赞：1105)，4星**
    - **关键亮点**：代码简洁，通过 `memset` 快速清零数组，直接统计数字是否出现，逻辑清晰。
    - **核心代码**：
```cpp
#include<cstdio>
#include<cstring>
int i,j,v;bool a[10];//ai表示第i个数已经用过了
int main()
{
    for(i=192;i<=327;i++)//第一个数最小192，最大327
    {
        memset(a,0,sizeof(a));v=0;//清零
        a[i%10]=a[i/10%10]=a[i/100]=a[i*2%10]=a[i*2/10%10]=a[i*2/100]=a[i*3%10]=a[i*3/10%10]=a[i*3/100]=1;//统计数字
        for(j=1;j<=9;j++) v+=a[j];//v表示1-9这些数字是否全部齐了
        if(v==9) printf("%d %d %d\n",i,i*2,i*3);//如果齐了就输出
    }
    return 0;
}
```
- **作者：usercjh123 (赞：30)，4星**
    - **关键亮点**：巧妙利用 `next_permutation` 函数生成全排列，代码简洁且思路清晰。
    - **核心代码**：
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long ll;
const ll maxn = 9;
ll num[9];//存储每一位
ll get_num(ll l, ll r){
    ll temp = 0;
    for(int i = l ; i < r ; i++){
        temp += num[i];
        temp *= 10;
    }
    temp += num[r];
    return temp;
}//返回[l,r]区间内的数字
int main(){
    for(int i = 0 ; i < 9 ; i++){
        num[i] = i + 1;
    }
    do{
        ll a = get_num(0,2);
        ll b = get_num(3,5);
        ll c = get_num(6,8);
        if(a * 2 == b && a * 3 == c){
            cout << a << " " << b << " " << c << endl; 
        }//判断是否合法
    }while(next_permutation(num,num+9));//下一个排列
}
```
- **作者：liuyubobobo (赞：18)，4星**
    - **关键亮点**：同样使用 `next_permutation` 生成全排列，代码简洁易读。
    - **核心代码**：
```cpp
#include <vector>
#include <algorithm>
#include <cstdio>
using namespace std;
int main(){
    vector<int> v = vector<int>();
    for( int i = 1 ; i <= 9 ; i ++ )
        v.push_back(i);
    do{
        int a = v[0]*100+v[1]*10+v[2];
        int b = v[3]*100+v[4]*10+v[5];
        int c = v[6]*100+v[7]*10+v[8];
        if( a*2 == b && a*3 == c )
            printf("%d %d %d\n",a , b , c );
    }while( next_permutation( v.begin() , v.end() ) );
    return 0;
}
```

### 最优关键思路或技巧
- **范围限制**：通过分析可知第一个数的范围在 123 - 333 之间，可减少不必要的枚举。
- **数组标记**：使用数组记录每个数字是否出现，判断数字是否重复。
- **STL 函数**：利用 `next_permutation` 函数生成全排列，简化代码实现。

### 可拓展之处
同类型题如数字组合、排列问题，可使用类似的枚举、全排列生成、数组标记等方法。例如，给定一组数字，要求找出满足特定比例或条件的数字组合。

### 推荐题目
- P1008 [NOIP1998 普及组] 三连击（本题）
- P1012 [NOIP1998 提高组] 拼数：给定一组整数，要求将它们拼接成最大的整数，涉及数字排列和比较。
- P1042 [NOIP2003 普及组] 乒乓球：根据比赛记录，计算不同赛制下的比赛结果，需要对数据进行处理和判断。

### 个人心得摘录与总结
- **鸩羽**：提到题目对新人不友好，一开始手动筛选，说明该题对于新手有一定难度。
- **静沐暖阳**：提到班级有大佬用 `next_permutation` 函数，表明该函数在解决排列问题上的有效性和便捷性。 

---
处理用时：39.24秒
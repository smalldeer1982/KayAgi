# 题目信息

# [NOIP 1998 提高组] 车站

## 题目描述

火车从始发站（称为第 $1$ 站）开出，在始发站上车的人数为 $a$，然后到达第 $2$ 站，在第 $2$ 站有人上、下车，但上、下车的人数相同，因此在第 $2$ 站开出时（即在到达第 $3$ 站之前）车上的人数保持为 $a$ 人。从第 $3$ 站起（包括第 $3$ 站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第 $n-1$ 站），都满足此规律。现给出的条件是：共有 $n$ 个车站，始发站上车的人数为 $a$，最后一站下车的人数是 $m$（全部下车）。试问 $x$ 站开出时车上的人数是多少？


## 说明/提示

对于全部的测试点，保证 $1 \leq a \leq 20$，$1 \leq x \leq n \leq 20$，$1 \leq m \leq 2 \times 10^4$。

NOIP1998 提高组 第一题

## 样例 #1

### 输入

```
5 7 32 4
```

### 输出

```
13
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕火车各站上下车人数规律来计算指定站开出时车上的人数。整体可分为两类思路：一是通过找规律，利用斐波那契数列相关知识，推导出人数与斐波那契数列系数的关系，进而求解；二是采用暴力模拟的方法，枚举第二站上车人数，根据规则递推到最后一站，找到满足条件的人数，再计算指定站的人数。

找规律的方法时间复杂度低，代码简洁，但需要较强的数学思维和找规律能力；暴力模拟方法思路简单直接，但时间复杂度相对较高，不过对于本题较小的数据范围可以通过。

### 所选题解
- **xiejinhao（4星）**
    - **关键亮点**：思路清晰，详细地列出了各站上下车人数和车上人数的规律，将\(a\)和\(u\)分开处理，利用斐波那契数列计算系数，对不同情况进行分类讨论，代码注释详细，有助于理解。
- **Jack2015633（4星）**
    - **关键亮点**：通过列表的方式直观呈现各站上下车人数的关系，清晰地总结出斐波那契数列的规律，推导出相关公式，代码实现简洁明了，对特殊情况进行了特判。
- **ykuouzf（4星）**
    - **关键亮点**：抓住斐波那契数列这一精髓，快速推导出上车人数、车上人数与斐波那契数列系数的关系，列出关键方程求解，代码简洁高效。

### 重点代码及核心实现思想
#### xiejinhao
```cpp
if(n <= 5) {
    if(n == 2||n == 3)
        printf("%d", a);
    else if(n == 4) {
        if(x == 1 || x == 2) printf("%d", a);
        else if(x == 3) printf("%d", a * 2);
    }
    else if(n == 5) {
        if(x == 1 || x == 2) printf("%d", a);
        else if(x == 3) printf("%d", a * 2);
        else if(x == 4) 
            printf("%d", (m - a * 3) / 2 + a * 2);
    }
}
else {
    int p = 1, q = 0, k = 0, sum1 = 0;
    for(int i = 1; i <= n - 5; i++) { 	
        k = p + q;
        sum1 += k;
        p = q;
        q = k;
    }
    int s1 = sum1 + 2;
    int e = 0, t = 1, g = 0,sum2 = 0;
    for(int i = 1; i <= n - 5; i++) {
        g = e + t;
        sum2 += g;
        e = t;
        t = g;
    }
    int s2 = sum2 + 1;
    int S = (m - s1 * a) / s2;
    q = k = e = g = sum1 = sum2 = 0;
    p = t = 1;
    if(x <= 5) {
        if(x == 1 || x == 2) printf("%d", a);
        else if(x == 3)  printf("%d", a * 2);
        else if(x == 4) printf("%d", S + a * 2);
        else printf("%d", S * 2 + a * 3);
    }
    else {
        for(int i = 1; i <= x - 4; i++) {
            k = p + q;
            sum1 += k;
            p = q;
            q = k;
        }
        sum1 += 2;
        for(int i = 1; i <= x - 4; i++) {
            g = e + t;
            sum2 += g;
            e = t;
            t = g;
        }
        sum2 += 1;
        printf("%d", sum1 * a + sum2 * S);
    }
}
```
核心思想：先对\(n\leq5\)的情况进行分类讨论并直接输出结果。对于\(n>5\)的情况，分别计算\(a\)和\(u\)（这里用\(S\)表示）的斐波那契数列系数，通过最后一站下车人数\(m\)求出\(S\)，再根据\(x\)的值分类计算并输出结果。

#### Jack2015633
```cpp
cin>>a>>n>>m>>x;
ans=a;
if(x>=3)
    ans+=a;
if(x>=4)
{
    f[1]=f[2]=1;	
    for(int i=3;i<=n-4;i++)
        f[i]=f[i-1]+f[i-2];
    for(int i=1;i<=n-4;i++)
        sum[i]=sum[i-1]+f[i];
    int y=(m-sum[n-5]*a-ans)/sum[n-4];
    ans+=sum[x-4]*a+sum[x-3]*y; 
}
cout<<ans<<endl;
```
核心思想：先对\(x\)较小的情况进行特判。对于\(x\geq4\)的情况，计算斐波那契数列及其前缀和，通过最后一站下车人数\(m\)求出未知量\(y\)，再计算并输出结果。

#### ykuouzf
```cpp
scanf("%d%d%d%d",&a,&n,&m,&x);
f[1]=1;
for(int _=2;_<=n-1;f[_]=f[_-1]+f[_-2],_++);
b=(m-(f[n-3]+1)*a)/(f[n-2]-1);
cout<<(f[x-2]+1)*a+(f[x-1]-1)*b<<endl;
```
核心思想：先计算斐波那契数列，通过最后一站下车人数\(m\)列出方程求出未知量\(b\)，再根据公式计算并输出第\(x\)站车上的人数。

### 最优关键思路或技巧
- **找规律利用斐波那契数列**：通过列出各站上下车人数的表格，发现上车人数、下车人数、车上人数中\(a\)和未知量（如\(u\)、\(y\)、\(b\)等）的系数满足斐波那契数列规律，从而推导出相关公式求解。
- **分开处理变量**：将\(a\)和未知量分开处理，分别计算它们的系数，便于后续计算和求解。
- **分类讨论**：对不同的\(n\)和\(x\)值进行分类讨论，简化计算过程，避免复杂情况的干扰。

### 可拓展之处
同类型题可能会改变上下车人数的规律，或者增加更多的条件，但解题的关键思路仍然是找规律、列方程求解。类似算法套路包括：
- 对于有规律的递推问题，先列出前几项，寻找其中的规律，可能是等差数列、等比数列、斐波那契数列等。
- 对于有未知量的问题，可以通过设未知数，根据已知条件列出方程，求解未知数。

### 推荐题目
- P1999 高维正方体：考察找规律和递推的能力。
- P1255 数楼梯：经典的斐波那契数列应用问题。
- P1028 数的计算：通过找规律和递推来解决问题。

### 个人心得摘录与总结
- **仁和_童博扬**：一开始提交只有50分，调试发现数据中第二站有人上车后马上又下车的情况，不符合常规。总结：做题时要仔细分析数据，注意边界情况和特殊情况。
- **lcx64579**：之前从1枚举第二站上车人数导致第三个点TLE，后来发现第二站也可能一个人也不上车，修改后通过。总结：枚举时要考虑全面，注意边界值的情况。

---
处理用时：53.80秒
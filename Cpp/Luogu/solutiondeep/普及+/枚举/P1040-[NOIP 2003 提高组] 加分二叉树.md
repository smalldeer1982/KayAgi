# 题目信息

# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕加分二叉树问题展开，核心思路均是使用动态规划来解决。通过设计状态表示子树的最大加分，利用状态转移方程计算出最大加分，并记录根节点信息以输出前序遍历。不同题解在实现细节、代码风格和复杂度上存在差异，但整体思路一致。

### 所选题解
- **冒泡ioa（5星）**
    - **关键亮点**：思路清晰，对动态规划的概念和本题的分析详细，代码简洁易懂，注释清晰，适合初学者学习。
    - **核心代码**：
```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN = 50;
typedef long long ll;
ll n;
ll f[MAXN][MAXN], root[MAXN][MAXN];

void print(ll l, ll r) {
    if (l > r) return;
    printf("%lld ", root[l][r]);
    if (l == r) return;
    print(l, root[l][r] - 1);
    print(root[l][r]+1,r);
}

int main() {
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++) scanf("%lld", &f[i][i]), f[i][i-1]=1, root[i][i] = i;
    for (int len = 1; len < n; ++len) {
        for (int i = 1; i + len <= n; ++i) {
            int j = i + len;
            f[i][j] = f[i + 1][j] + f[i][i];
            root[i][j] = i;
            for (int k = i + 1; k < j; ++k) {
                if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                    f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                    root[i][j] = k;
                }
            }
        }
    }
    cout << f[1][n] << endl;
    print(1, n);
    return 0;
}
```
**核心实现思想**：使用二维数组 `f[i][j]` 表示节点 `i` 到节点 `j` 成树的最大加分，`root[i][j]` 记录该子树的根节点。通过枚举区间长度、起点和根节点，利用状态转移方程更新 `f` 数组和 `root` 数组。最后输出 `f[1][n]` 作为最大加分，并通过递归函数 `print` 输出前序遍历。

- **winmt（4星）**
    - **关键亮点**：采用记忆化搜索的方式实现动态规划，对状态转移方程的解释详细，同时给出了 CPP 和 Pascal 两种代码，适合不同语言的学习者。
    - **核心代码**：
```cpp
long long search(int L, int r)    // 递归计算f[L][r]
{
    int  k;
    long long  now, ans;    // 当前分值
    if (L > r) return 1;
    if (f[L][r]== -1)     // 若尚未计算出顶点L..顶点r对应子树的最高分值
        for(k=L; k<=r; k++) {     // 穷举每一个可能的子根k
            now = search(L, k-1) * search(k+1, r) + f[k][k];  
            // 计算以k为根的子树的分值
            if(now > f[L][r])  {
                //若该分值为目前最高，则记入状态转移方程，并记下子根
                f[L][r] = now; 
                root[L][r] = k;
            }
        }
    return  f[L][r];   // 返回顶点L..顶点r对应子树的最高分值
}
```
**核心实现思想**：使用递归函数 `search` 计算 `f[L][r]`，若 `f[L][r]` 未计算过，则枚举子根 `k`，计算以 `k` 为根的子树的分值，更新 `f[L][r]` 和 `root[L][r]`。通过记忆化搜索避免重复计算。

- **噬月（4星）**
    - **关键亮点**：对状态设计、状态转移方程的推导和边界情况的讨论详细，通过实验对代码中的等号问题进行分析，有助于深入理解问题。
    - **核心代码**：
```cpp
for (int range = 1; range <= n; ++ range ) {
    for (int i = 1; i + range <= n; ++ i ) {
        int j = i  + range;
        for (int k = i ; k <= j; ++ k ) {
            if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                root[i][j] = k;
            }
        }
    }
}
```
**核心实现思想**：通过枚举区间长度、起点和根节点，利用状态转移方程更新 `f` 数组和 `root` 数组，与冒泡ioa 的思路类似。

### 最优关键思路或技巧
- **状态设计**：使用二维数组 `f[i][j]` 表示节点 `i` 到节点 `j` 成树的最大加分，利用区间动态规划的思想，将问题分解为子问题。
- **记忆化搜索**：通过记录已经计算过的子问题的解，避免重复计算，提高效率。
- **记录根节点**：使用另一个二维数组 `root[i][j]` 记录节点 `i` 到节点 `j` 成树的最大加分所选的根节点，方便输出前序遍历。

### 可拓展之处
同类型题或类似算法套路：
- **区间合并问题**：如石子合并问题，通过枚举区间的分割点，将区间合并为更大的区间，计算最优解。
- **树形动态规划问题**：在树结构上进行动态规划，通过状态转移方程计算子树的最优解，再合并得到整棵树的最优解。

### 推荐题目
- [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)
- [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)
- [P2858 [USACO06FEB]Treats for the Cows G](https://www.luogu.com.cn/problem/P2858)

### 个人心得摘录与总结
- **噬月**：对代码中不等号改为等号的情况进行实验分析，发现修改后最高分不变但前序遍历改变，结合枚举根节点的思路，认识到枚举根的过程反映到图上是在枚举不同的树型。总结：在处理动态规划问题时，要注意细节对结果的影响，通过实验和分析深入理解问题。

---
处理用时：51.32秒
# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何求解满足特定最大公约数和最小公倍数条件的正整数 $x$ 的个数展开。整体思路可分为两类：一是通过数学推理缩小 $x$ 的可能范围，如利用结论得出 $x$ 是 $a_1$ 的整数倍且是 $b_1$ 的因子，然后枚举 $b_1$ 的因子进行判断；二是运用唯一分解定理，对质因数的指数进行分类讨论来确定 $x$ 的个数。

### 所选题解
- **zzlzk（4星）**
    - **关键亮点**：思路清晰，通过数学推导得出 $x$ 是 $a_1$ 的整数倍且是 $b_1$ 的因子这一关键结论，然后利用 $\sqrt{b_1}$ 枚举 $b_1$ 的因子，结合最大公约数的性质进行判断，代码简洁易懂。
    - **核心代码**：
```cpp
#include<cstdio>
using namespace std;
int gcd(int a,int b) {
    return b==0?a:gcd(b,a%b);
}
int main() {
    int T;
    scanf("%d",&T);
    while(T--) {
        int a0,a1,b0,b1;
        scanf("%d%d%d%d",&a0,&a0,&b0,&b1);
        int p=a0/a1,q=b1/b0,ans=0;
        for(int x=1;x*x<=b1;x++) 
            if(b1%x==0){
                if(x%a1==0&&gcd(x/a1,p)==1&&gcd(q,b1/x)==1) ans++;
                int y=b1/x;
                if(x==y) continue; 
                if(y%a1==0&&gcd(y/a1,p)==1&&gcd(q,b1/y)==1) ans++;
            }
        printf("%d\n",ans);
    }
    return 0;
}
```
    - **核心实现思想**：先计算 $p = a0 / a1$ 和 $q = b1 / b0$，然后枚举 $b1$ 的因子 $x$，对于每个因子 $x$，判断其是否是 $a1$ 的倍数，并且满足 $gcd(x / a1, p) == 1$ 和 $gcd(q, b1 / x) == 1$，若满足则答案加 1。同时，对于另一个因子 $y = b1 / x$ 也进行同样的判断，但要注意避免重复计算。

- **KesdiaelKen（4星）**
    - **关键亮点**：对思路进行了详细的推算，不仅给出了初步的解题思路，还进一步优化算法，通过去掉 $s$ 与 $n$、$l$ 与 $m$ 相同的质因数，降低了时间复杂度，并且考虑了特判情况，代码实现较为严谨。
    - **核心代码**：
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<string>
using namespace std;
int ssqrt;
int cf(int a,int b) {
    ssqrt=sqrt(b);
    for(int i=2;i<=ssqrt;i++) {
        if(b%i==0)while(a%i==0)a/=i;
        while(b%i==0)b/=i;
    }
    if(b!=1)while(a%b==0)a/=b;
    return a;
}
int gcd(int a,int b){return b==0?a:gcd(b,a%b);}
int main() {
    int a0,a1,b0,b1;
    int gs;
    int m,n,s,l,q;
    scanf("%d",&gs);
    int cnt;
    while(gs--) {
        scanf("%d%d%d%d",&a0,&a1,&b0,&b1);
        if(a0%a1|b1%b0|b1%a1){printf("0\n");continue;}
        m=a0/a1,n=b1/b0,s=b1/a1;l=cf(s,n);
        if(gcd(max(s/l,m),min(s/l,m))!=1){printf("0\n");continue;}
        q=cf(l,m);cnt=0,ssqrt=sqrt(q);
        for(int i=1;i<=ssqrt;i++)if(q%i==0)cnt+=i==q/i?1:2;
        printf("%d\n",cnt);
    }
    return 0;
}
```
    - **核心实现思想**：先计算 $m = a0 / a1$，$n = b1 / b0$，$s = b1 / a1$，然后通过 $cf$ 函数去掉 $s$ 与 $n$ 相同的质因数得到 $l$，再判断 $s / l$ 与 $m$ 是否互质，若不互质则输出 0。接着去掉 $l$ 与 $m$ 相同的质因数得到 $q$，枚举 $q$ 的因子并统计个数。

- **皎月半洒花（4星）**
    - **关键亮点**：采用唯一分解定理的思路，引入自由未知数和自由区间的概念，对质因数的指数进行分类讨论，虽然代码复杂度较高，但思路独特，并且解决了数据范围过大无法直接筛的问题。
    - **核心代码**：
```cpp
inline void work(int ST, int ED){
    for(i = ST; i <= ED ; ++ i){
        N1 = N2 = N3 = N4 = 0 ;
        while (!(A0 % P[i])) A0 /= P[i], ++ N1 ;
        while (!(A1 % P[i])) A1 /= P[i], ++ N2 ;
        while (!(B0 % P[i])) B0 /= P[i], ++ N3 ;
        while (!(B1 % P[i])) B1 /= P[i], ++ N4 ;
        if (N1 > N2 && N3 < N4){
            if (N2 == N4) A[i] = B[i] = 1 ;
            else {mark = 0; break ;}
            continue ;
        }
        if (N1 > N2){
            if (N4 >= N2) A[i] = B[i] = N2 ;
            else {mark = 0; break ;}
            continue ;
        }
        if (N3 < N4){
            if (N4 >= N2) A[i] = B[i] = N3 ;
            else {mark = 0; break ;}
            continue ;
        }
        else {
            if (N4 >= N2) A[i] = N2, B[i] = N4 ;
            else {mark = 0; break ;}
        }
    }
}
```
    - **核心实现思想**：对每个质数 $P[i]$，计算 $A0$、$A1$、$B0$、$B1$ 中该质数的指数 $N1$、$N2$、$N3$、$N4$，然后根据这些指数的大小关系进行分类讨论，更新 $A[i]$ 和 $B[i]$ 的值，若出现矛盾则标记 $mark = 0$ 并退出。

### 最优关键思路或技巧
- **缩小枚举范围**：利用最大公约数和最小公倍数的性质，得出 $x$ 是 $b_1$ 的因子，从而将枚举范围从 $1$ 到 $b_1$ 缩小到 $1$ 到 $\sqrt{b_1}$，时间复杂度从 $O(b_1)$ 降低到 $O(\sqrt{b_1})$。
- **数学推理优化**：通过数学推导得出一些结论，如 $gcd(a/k, b/k) = 1$ 等，结合这些结论进行判断，减少不必要的计算。
- **唯一分解定理**：将数分解为质因数的乘积，对质因数的指数进行分类讨论，从而确定满足条件的 $x$ 的个数。

### 可拓展之处
同类型题可能会涉及更多的数论知识，如欧拉函数、中国剩余定理等。类似算法套路可以应用于求解满足多个数论条件的整数个数问题，通过数学推理缩小范围，然后进行枚举或分类讨论。

### 推荐题目
- P1044 [NOIP2003 普及组] 栈
- P1069 [NOIP2009 普及组] 细胞分裂
- P1075 [NOIP2012 普及组] 质因数分解

### 个人心得摘录与总结
- **皎月半洒花**：提到 work 函数是在事先考虑清楚，事中如同做梦，事后不可思议的情况下写出来的，说明在解题过程中可能会有灵感突发的情况，同时也强调了码力的重要性。还提到关于自由不自由的定义是突发奇想，这种创新的思维方式有助于简化问题的阐述。另外，指出不找另一个比较大的质数可以得 90 分，说明在解题时要注意数据的特殊性和边界情况。

---
处理用时：61.97秒
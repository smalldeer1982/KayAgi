# 题目信息

# [NOIP 2012 普及组] 文化之旅

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。由于测试数据过水，可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）。本题题目和数据仅供参考。本题不接受添加 hack 数据。

本题为错题。**不建议尝试或提交本题。**[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。

现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。


## 说明/提示

输入输出样例说明$1$

由于到国家 $2$ 必须要经过国家$ 1$，而国家$ 2 $的文明却排斥国家 $1$ 的文明，所以不可能到达国家 $2$。


输入输出样例说明$2$

路线为$ 1$ ->$ 2$

【数据范围】

对于 100%的数据，有$ 2≤N≤100$

$1≤K≤100$ 

$1≤M≤N^2$

$1≤k_i≤K$

$1≤u, v≤N$ 

$1≤d≤1000,S≠T,1≤S,T≤N$

NOIP 2012 普及组 第四题


## 样例 #1

### 输入

```
2 2 1 1 2 
1 2 
0 1 
1 0 
1 2 10 
```

### 输出

```
-1```

## 样例 #2

### 输入

```
2 2 1 1 2 
1 2 
0 1 
0 0 
1 2 10 ```

### 输出

```
10```

# AI分析结果

### 综合分析与结论
这些题解主要围绕文化之旅问题展开，目标是在考虑文化排斥和不重复学习文化的条件下，求出从起点到终点的最短路径。题解中使用的算法主要有深度优先搜索（DFS）、广度优先搜索（BFS）的变种（如 SPFA）、Floyd 算法和 Dijkstra 算法，部分还结合了 A* 启发式搜索。各题解的主要区别在于处理文化排斥和路径选择的方式，以及剪枝优化的策略。

### 所选题解
- **作者：Created_equal1（4星）**
    - **关键亮点**：采用启发式搜索，先跑一遍无视文化排斥的最短路，利用该结果进行剪枝，有效减少搜索空间。思路清晰，代码结构合理。
    - **个人心得**：无

### 重点代码及核心实现思想
#### Created_equal1 的题解
```cpp
// 跑无视文化排斥的最短路
void Spfa()
{
    memset(Dist, 0X7F, sizeof(Dist));
    queue<unsigned int> Q;
    Q.push(S);
    In_Q[S] = true;
    Dist[S] = 0;
    unsigned int Top;
    while (Q.size())
    {
        Top = Q.front();
        Q.pop();
        In_Q[Top] = false;
        for (size_t i = Head[Top];i;i = Next[i])
            if (Dist[To[i]] > Dist[Top] + Weight[i])
            {
                Dist[To[i]] = Dist[Top] + Weight[i];
                if (!In_Q[To[i]])
                {
                    In_Q[To[i]] = true;
                    Q.push(To[i]);
                }
            }
    }
}

// 深度优先搜索
void Dfs(const size_t &Now, const unsigned int &D)
{
    Went[Now] = true;
    culture.insert(C[Now]);
    if (Now == S)
    {
        Ans = min(Ans, D);
        return;
    }
    if (D + Dist[Now] > Ans)
        return;
    for (size_t i = Head[Now];i;i = Next[i])
        if (!Went[To[i]] && check(C[To[i]]))
            Dfs(To[i], D + Weight[i]);
    Went[Now] = false;
    culture.erase(C[Now]);
}
```
**核心实现思想**：先通过 SPFA 算法求出无视文化排斥的最短路，存储在 `Dist` 数组中。然后进行深度优先搜索，在搜索过程中，使用 `culture` 集合记录已经学习过的文化，通过 `check` 函数检查是否存在文化排斥。同时，利用 `Dist` 数组进行剪枝，如果当前路径长度加上从当前点到终点的无视文化排斥的最短路长度大于当前答案，则不再继续搜索。

### 最优关键思路或技巧
- **启发式搜索**：先求出无视文化排斥的最短路，以此作为启发信息进行剪枝，减少不必要的搜索。
- **剪枝优化**：在搜索过程中，根据当前路径长度和已知的最短路信息，提前排除不可能得到最优解的路径。
- **状态记录**：使用集合或数组记录已经学习过的文化，方便进行文化排斥的判断。

### 可拓展之处
同类型题或类似算法套路包括：
- **带限制条件的最短路问题**：如带有时间限制、资源限制等，可采用类似的剪枝和状态记录方法。
- **图的遍历问题**：在遍历过程中需要满足一定的条件，可使用深度优先搜索或广度优先搜索结合剪枝优化。

### 推荐题目
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：考察最短路算法和路径计数。
- [P1346 电车](https://www.luogu.com.cn/problem/P1346)：带特殊规则的图的最短路问题。
- [P2829 大逃离](https://www.luogu.com.cn/problem/P2829)：涉及状态转移和最短路的问题。

### 个人心得摘录与总结
- **yedalong**：在做标记时不能直接赋值，需要加 1 或减 1，不然回溯时它会把标记直接覆盖掉，因为这个调了一个多小时。总结：在使用回溯算法时，要注意标记的更新和恢复方式，避免出现覆盖问题。

---
处理用时：32.07秒
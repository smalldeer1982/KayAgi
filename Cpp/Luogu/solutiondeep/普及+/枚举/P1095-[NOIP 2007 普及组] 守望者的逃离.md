# 题目信息

# [NOIP 2007 普及组] 守望者的逃离

## 题目背景

NOIP2007 普及组 T3

## 题目描述

恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。

守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。

为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。

守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。

现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。

注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。


## 说明/提示

对于 $30\%$ 的数据，$1  \le  T   \le  10$，$ 1   \le   S   \le  100$；

对于 $50\%$ 的数据，$1   \le  T   \le   10^3$，$ 1   \le  S  \le   10^4$；

对于 $100\%$ 的数据，$1   \le   T   \le   3\times  10^5$，$0   \le   M   \le   10^3$，$ 1   \le  S   \le   10^8$。


## 样例 #1

### 输入

```
39 200 4
```

### 输出

```
No
197
```

## 样例 #2

### 输入

```
36 255 10```

### 输出

```
Yes
6```

# AI分析结果

### 综合分析与结论
这些题解主要围绕守望者逃离荒岛的问题展开，核心在于合理利用守望者的跑步、闪烁和恢复魔法值的能力，在给定时间内达到最远的距离，判断是否能逃离荒岛。题解的思路大致可分为模拟和动态规划两类。模拟类思路是根据魔法值的不同情况，制定不同的行动策略；动态规划类思路则是通过维护不同状态下的距离，不断更新最优解。

### 所选题解
- **作者：wzr1125（4星）**
  - **关键亮点**：思路清晰，用两个变量分别模拟闪现和跑步的距离，并用闪现距离维护跑步距离，使跑步距离最优，代码简洁易懂。
- **作者：GLr137（4星）**
  - **关键亮点**：使用动态规划思想，定义`dp[i]`表示第`i`秒最多可以逃离的米数，先计算每点用闪烁法术可逃离的最大距离，再根据前面状态更新，逻辑清晰。
- **作者：Cold_Eyes_bystander（4星）**
  - **关键亮点**：采用贪心策略，通过假设两个人跑步，一个正常走路，一个使用魔法，在某一时间点根据两人的距离情况更新策略，思路巧妙。

### 重点代码
#### 作者：wzr1125
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,s,t,fla,run;
int main(){
    cin>>m>>s>>t; 
    for(int i=1;i<=t;i++){ 
        if(m>=10)m-=10,fla+=60,run+=17;
        else{if(fla>run)run=fla; 
            m+=4,run+=17;} 
        if(max(fla,run)>=s){
            printf("Yes\n%d\n",i);return 0;} 
    }
    cout<<"No"<<endl<<max(fla,run)<<endl; 
    return 0;
}
```
**核心实现思想**：用`fla`记录闪现的距离，`run`记录跑步的距离。蓝够时进行闪现并同时跑步，蓝不够时若闪现距离大于跑步距离则更新跑步距离，然后恢复蓝并继续跑步，每次判断是否能逃离。

#### 作者：GLr137
```cpp
# include <bits/stdc++.h>
using namespace std;
int main (){
    int m, s, t, z, dp[300005] = {0};
    cin >> m >> s >> t;
    for (int i = 1; i <= t; i++){
        dp[i] = dp[i - 1] + (60 * (m >= 10));    
        z = m;
        m -= (10 * (z >= 10));   
        m += (4 * (z < 10));    
    }
    for (int i = 1; i <= t; i++){
        dp[i] = max(dp[i], dp[i - 1] + 17);
        if (dp[i] >= s){
            cout << "Yes\n" << i;
            return 0;
        }
    }
    cout << "No\n" << dp[t];
    return 0;
}
```
**核心实现思想**：先计算每一秒仅使用闪烁法术能到达的距离存入`dp`数组，再遍历`dp`数组，比较当前闪烁距离和前一秒跑步距离加17的大小，取最大值更新`dp`数组，若某一秒的距离大于等于目标距离则输出结果。

#### 作者：Cold_Eyes_bystander
```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int m,s,t;
    cin>>m>>s>>t;
    int s1=0,s2=0;
    for(int i=1;i<=t;i++)
    {
        s1+=17;
        if(m>=10)
        {
            s2+=60;
            m-=10;
        }
        else
        {
            m+=4;
        }
        if(s2>s1)
        {
            s1=s2;
        }
        if(s1>s)
        {
            cout<<"Yes"<<endl<<i;
            return 0;
        }
    }
    cout<<"No"<<endl<<s1;
    return 0;
}
```
**核心实现思想**：用`s1`表示正常走路的距离，`s2`表示使用魔法的距离。每一秒正常走路，魔法值够时使用魔法，若使用魔法的距离超过正常走路的距离，则更新正常走路的距离，若某一秒的距离大于等于目标距离则输出结果。

### 最优关键思路或技巧
- **贪心策略**：优先使用闪烁法术，因为其速度快。在魔法值不足时，通过比较不同策略下的前进距离，选择最优策略。
- **动态规划**：定义状态数组`dp[i]`表示第`i`秒最多能走的距离，通过状态转移方程更新数组，最终得到最优解。
- **双变量维护**：用两个变量分别记录跑步和闪现的距离，通过比较和更新，使跑步距离最优。

### 可拓展之处
同类型题或类似算法套路：
- **资源分配问题**：如在有限的资源（如时间、金钱等）下，选择不同的行动方案以达到最优结果。
- **状态转移问题**：在不同状态之间进行转移，通过比较不同状态下的收益，选择最优转移路径。

### 推荐题目
- P1216 [USACO1.5] 数字三角形 Number Triangles
- P1048 [NOIP2005 普及组] 采药
- P1060 [NOIP2006 普及组] 开心的金明

### 个人心得摘录与总结
- **作者：Asurudo**：最初贪心策略出现错误，原因是之前认为某些策略一定最优的想法不准确，需要时刻关注剩余时间和剩余距离，根据实际情况选择最优策略。总结：在贪心算法中，不能想当然地认为某些策略一定最优，要全面考虑各种情况。

---
处理用时：45.64秒
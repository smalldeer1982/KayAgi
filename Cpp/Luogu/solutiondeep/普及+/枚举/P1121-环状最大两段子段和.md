# 题目信息

# 环状最大两段子段和

## 题目描述

给出一段长度为 $n$ 的环状序列 $a$，即认为 $a_1$ 和 $a_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
9```

# AI分析结果

### 综合分析与结论
这些题解围绕环状最大两段子段和问题，提出多种思路与方法。多数题解将问题分为两段不跨环和至少一段跨环两种情况讨论，通过预处理最大/最小子段和、枚举断点等方式求解。部分题解使用线段树、动态规划等数据结构与算法，复杂度多为 $O(n)$。

### 所选题解
1. **作者：Develop（5星）**
    - **关键亮点**：系统性总结最大子段和及其多种变式，对本题给出 $O(n^2)$ 和 $O(n)$ 两种解法，思路清晰且全面，为理解和解决此类问题提供完整框架。
    - **核心代码**：
```cpp
// O(n) 解法核心思路
// 先求一遍两段最大子段和
// 再对整个序列取反，求两段最小子段和，用总和减去得到跨过端点的两段最大子段和
// 最后取两种情况的最大值
```
2. **作者：I_AM_HelloWord（4星）**
    - **关键亮点**：思路清晰，代码简洁，对特殊情况（只有一个正数）进行特判，保证算法正确性。
    - **个人心得**：考虑到将数字负过来求最大子序列时可能出现只选一个序列的特殊情况，通过特判只有一个正数时不进行该操作，避免错误。
    - **核心代码**：
```cpp
int query(){
    int res=-INF;
    for (int i=1;i<=n;i++)f[i]=max(f[i-1],0)+a[i];
    for (int i=n;i>0;i--)g[i]=max(g[i+1],0)+a[i];
    for (int i=1;i<=n;i++)f[i]=max(f[i-1],f[i]);
    for (int i=n;i>0;i--)g[i]=max(g[i+1],g[i]);
    for (int i=1;i<n;i++)res=max(res,f[i]+g[i+1]);
    return res;
}
// 主函数中处理特殊情况
if (tot==1){
    printf("%d",t1);
} else {
    for (int i=1;i<=n;i++)a[i]=-a[i];
    int t2=sum+query();
    if (!t2)t2=-INF;
    printf("%d",max(t1,t2));
}
```
3. **作者：zhy137036（4星）**
    - **关键亮点**：从最大子段和逐步推导到环状最大子段和、最大双子段和及环状最大双子段和，逻辑连贯，代码实现详细，便于理解。
    - **核心代码**：
```cpp
// 环状最大双子段和核心代码
int getmin(int*arr,int l){
    mf[1]=arr[1];
    for(int i=2;i<=l;i++)mf[i]=min(mf[i-1]+arr[i],min(arr[i],0));
    for(int i=2;i<=l;i++)mf[i]=min(mf[i-1],mf[i]);
    mb[l]=arr[l];
    for(int i=l-1;i>0;i--)mb[i]=min(mb[i+1]+arr[i],min(arr[i],0));
    for(int i=l-1;i>0;i--)mb[i]=min(mb[i+1],mb[i]);
    int ans=(1ll<<31ll)-1ll;
    for(int i=2;i<l;i++)ans=min(ans,mf[i-1]+mb[i+1]);
    return ans;
}
// 主函数中计算结果
ans=max(ans,sum-getmin(a,n-1));
ans=max(ans,sum-getmin(a+1,n-1));
```

### 最优关键思路与技巧
- **分类讨论**：将问题分为两段不跨环和至少一段跨环两种情况，分别求解后取最大值。
- **取反转化**：求最小子段和时，将数组元素取反，转化为求最大子段和问题。
- **预处理前缀和**：通过预处理最大/最小子段和，枚举断点，降低时间复杂度。

### 可拓展之处
同类型题如求环状最大 $m$ 段子段和，可参考本题思路，使用动态规划或线段树维护更多状态；类似算法套路包括破环成链、分类讨论、取反转化等，可用于解决其他环形序列问题。

### 推荐题目
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P2642 双子序列最大和](https://www.luogu.com.cn/problem/P2642)
3. [P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)

### 个人心得总结
- **I_AM_HelloWord**：意识到将数字负过来求最大子序列时可能出现只选一个序列的特殊情况，通过特判只有一个正数时不进行该操作，避免错误。
- **gravf**：注意题目中“连续不重叠且非空的两段”条件，在选择两个最小子段和时可能出现空子段问题，需对全部负数和只有一个非负整数的情况进行特判。
- **神之右大臣**：当整个串都是负数时，由于题中要求两段非空字串，应特判选择最大的两个值相加作为答案。 

---
处理用时：39.59秒
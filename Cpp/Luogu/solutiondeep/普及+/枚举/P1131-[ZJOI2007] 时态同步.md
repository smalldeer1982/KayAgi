# 题目信息

# [ZJOI2007] 时态同步

## 题目描述

小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。

在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。

激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？

## 说明/提示

- 对于 $40\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 5\times 10^5$。

对于所有的数据，$1\le t_e\le 10^6$。

## 样例 #1

### 输入

```
3
1
1 2 1
1 3 3
```

### 输出

```
2
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕树形 DP 或贪心算法来解决问题，核心目标是让树中所有叶子节点到根节点的距离相等，且增加边权的操作次数最少。多数题解采用深度优先搜索（DFS）来遍历树结构，通过维护节点到叶子节点的最大距离等信息，自底向上计算需要增加的边权总和。

### 所选题解
- **作者：Mathison (赞：187)，4星**
    - **关键亮点**：思路清晰，通过类比节点深度来解释调整边权的过程，易于理解。代码实现简洁明了，注释详细。
    - **核心代码**：
```cpp
void dfs(int x, int fa)
{
    for(int i=head[x];i;i=next[i])
    {
        int y=ver[i],z=edge[i];
        if(y==fa) continue;
        dfs(y,x);
        dis[x]=max(dis[x],dis[y]+z);
    }
    for(int i=head[x];i;i=next[i])
    {
        int y=ver[i],z=edge[i];
        if(y==fa) continue;
        ans+=dis[x]-(dis[y]+z);
    }
}
```
    - **核心实现思想**：先递归搜索子树，更新当前节点到叶子节点的最大距离 `dis[x]`，再累加调整边权的代价。

- **作者：ZORO (赞：5)，4星**
    - **关键亮点**：详细解释了树形 DP 的过程，通过图示辅助理解，代码结构清晰，状态转移方程明确。
    - **核心代码**：
```cpp
void dfs1(int u,int fa)
{
    for(int i=head[u];i;i=e[i].nxt)
    {
        int ev=e[i].v;
        if(ev==fa) continue;
        dfs1(ev,u);
        maxx[u]=max(maxx[ev]+e[i].w,maxx[u]);
    }
}
void dfs2(int u,int fa)
{
    for(int i=head[u];i;i=e[i].nxt)
    {
        int ev=e[i].v;
        if(ev==fa) continue;
        dfs2(ev,u);
        dp[u]+=(maxx[u]-(maxx[ev]+e[i].w));
        dp[u]+=dp[ev];
    }
}
```
    - **核心实现思想**：`dfs1` 预处理每个节点到子树中叶子节点的最大距离 `maxx[u]`，`dfs2` 进行树形 DP 计算答案。

- **作者：eee_hoho (赞：3)，4星**
    - **关键亮点**：明确给出状态转移方程，代码使用 `vector` 存储边信息，实现简洁。
    - **核心代码**：
```cpp
void dfs(int u,int fa)
{
    vector <node>::iterator it;
    int maxx = 0;
    for (it = d[u].begin();it != d[u].end();it++)
    {
        int v = (*it).to,w = (*it).cost;
        if (v == fa)
            continue;
        maxx = max(maxx,w);
        dfs(v,u);
        f[u] += f[v];
        dis[u] = max(dis[v] + w,dis[u]);
    }
    for (it = d[u].begin();it != d[u].end();it++)
    {
        int v = (*it).to,w = (*it).cost;
        if (v == fa)
            continue;
        f[u] += dis[u] - dis[v] - w;
    }
}
```
    - **核心实现思想**：在 DFS 过程中，更新 `dis[u]` 为当前节点到子树中叶子节点的最大距离，同时累加子树的答案 `f[v]`，并计算当前节点的调整代价。

### 最优关键思路或技巧
- **贪心策略**：调整越靠近根节点的边，影响的叶子节点越多，能使增加边权的操作次数最少。
- **树形 DP**：通过自底向上的方式，维护节点到叶子节点的最大距离，计算每个子树需要增加的边权。
- **深度优先搜索（DFS）**：用于遍历树结构，方便实现自底向上的计算过程。

### 可拓展之处
同类型题或类似算法套路包括树的路径问题、树的子树问题等。例如，求树中节点到其他节点的最大距离、树的重心等问题，都可以使用树形 DP 或贪心算法结合 DFS 来解决。

### 推荐题目
- [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)：经典的树形 DP 问题，通过状态转移方程计算最大快乐值。
- [P2014 选课](https://www.luogu.com.cn/problem/P2014)：树形依赖的背包问题，结合树形 DP 和背包算法。
- [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)：树形 DP 问题，计算保留一定数量树枝时苹果的最大数量。

### 个人心得摘录与总结
- **作者：DDOSvoid**：提到感觉自己没写明白，说明在实现复杂算法时，准确表达思路和代码逻辑有一定难度，需要更加清晰地阐述。
- **作者：Dispwnl**：指出似乎要用 `long long`，在 `codevs` 上可能要用高精度，提醒在处理数据时要注意数据范围，避免溢出。

---
处理用时：40.34秒
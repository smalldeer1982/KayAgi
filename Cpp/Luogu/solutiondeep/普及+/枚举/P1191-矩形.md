# 题目信息

# 矩形

## 题目描述

给出一个 $n \times n$ 的矩阵，矩阵中，有些格子被染成白色，有些格子被染成黑色，现要求矩阵中白色**矩形**的数量。

## 说明/提示

对于$30\%$的数据，$n ≤ 50$；

对于$100\%$的数据，$n ≤ 150$；


## 样例 #1

### 输入

```
4
WWBW
BBWB
WBWW
WBWB```

### 输出

```
15```

# AI分析结果

### 综合分析与结论
本题主要求给定矩阵中白色矩形的数量，各题解思路多样，复杂度从 $O(n^4)$ 到 $O(n^2)$ 不等。常见思路有枚举矩形的角点、边，结合预处理（如前缀和、连续白格计数），部分题解使用单调栈优化。

### 所选题解
- **作者：3493441984zz（4星）**
    - **关键亮点**：思路清晰，通过枚举矩形左下角点和向右长度，结合向上扩展高度计算矩形数量，代码简洁易懂。
- **作者：tong_xz（4星）**
    - **关键亮点**：在 $O(n^3)$ 基础上使用单调栈优化，将复杂度降为 $O(n^2)$，有一定创新性。
- **作者：Lates（4星）**
    - **关键亮点**：考虑每行的方案数，用单调栈维护左右边界，思路巧妙，复杂度为 $O(n^2)$。

### 重点代码及核心思想
#### 作者：3493441984zz
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 157
using namespace std;
int n,now,ans;
int high[N];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=n;++j)
        {
            char in;
            scanf(" %c",&in);
            if(in=='W')
                ++high[j];
            else
                high[j]=0;
        }
        for(int j=1;j<=n;++j)
        {
            now=high[j];
            for(int k=j;k<=n;++k)
            {
                if(!high[k])
                    break;
                now=min(now,high[k]);
                ans+=now;
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```
**核心思想**：按行处理，记录每列向上连续白格的高度，枚举左下角点和向右长度，以能向上扩展的最小高度作为矩形数量累加。

#### 作者：tong_xz
```cpp
#include<cstdio>
#define N 155
using namespace std;
int min(int a,int b){
    return a<b?a:b;
}
char get_a_char(){
    char c=getchar();
    while(c!='W'&&c!='B'){
        c=getchar();
    }
    return c;
}
int b[N][N],dp[N][N];
int s[N];
int e;
int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;++i){
        for(int j=0;j<n;++j){
            b[i][j]=(get_a_char()=='W');
        }
    }
    for(int i=n-1;i>=0;--i){
        for(int j=0;j<n;++j){
            if(b[i][j]){
                b[i][j]+=b[i+1][j];
            }
        }
    }
    int ans=0;
    s[0]=n;
    for(int i=0;i<n;++i){
        e=0;
        for(int j=n-1;j>=0;--j){
            while(b[i][s[e]]>b[i][j]){
                --e;
            }
            dp[i][j]=b[i][j]*(s[e]-j)+dp[i][s[e]];
            ans+=dp[i][j];
            s[++e]=j;
        }
    }
    printf("%d",ans);
}
```
**核心思想**：先预处理每格向下连续白格的高度，再用单调栈维护当前点往右第一个比它小的数的位置，通过状态转移方程计算矩形数量。

#### 作者：Lates
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define int long long 
inline int read(){
    register int x=0,f=0,ch=getchar();
    while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
    while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
    return f?-x:x;
}
const int MAX=155;
int n,h[MAX];char x[MAX][MAX];
int s[MAX],top,ans,l[MAX],r[MAX];
inline void solve(){
    top=0;
    for(register int i=1;i<=n;++i){
        while(top&&h[s[top]]>h[i])--top;
        l[i]=top?s[top]:0;
        s[++top]=i;
    }
    top=0;
    for(register int i=n;i;--i){
        while(top&&h[s[top]]>=h[i])--top;
        r[i]=top?s[top]:n+1;
        s[++top]=i;
    }
    for(register int i=1;i<=n;++i){
        ans+=(i-l[i])*(r[i]-i)*h[i];
    }
}
signed main(){
    n=read();
    for(register int i=1;i<=n;++i){
        for(register int j=1;j<=n;++j){
            cin>>x[i][j];
        }
    }
    for(register int i=1;i<=n;++i){
        for(register int j=1;j<=n;++j){
            ++h[j];
            if(x[i][j]=='B')h[j]=0;
        } 
        solve();
    }
    printf("%lld\n",ans);
    return 0;
}
```
**核心思想**：按行处理，记录每列向上连续白格的高度，用单调栈维护每个点左右第一个高度小于它的点，根据乘法原理计算以该点为高的矩形数量。

### 最优关键思路或技巧
- **预处理**：记录每列连续白格的高度，方便后续计算矩形数量。
- **单调栈优化**：在 $O(n^3)$ 基础上，使用单调栈维护左右边界，将复杂度降为 $O(n^2)$。

### 可拓展之处
同类型题可考虑不同形状的图形计数，如三角形、梯形等，类似算法套路可用于处理二维平面上的区域计数问题，可结合前缀和、单调栈等数据结构优化。

### 推荐题目
- [P1504 积木城堡](https://www.luogu.com.cn/problem/P1504)
- [P1736 创意吃鱼法](https://www.luogu.com.cn/problem/P1736)
- [P2701 巨大的牛棚](https://www.luogu.com.cn/problem/P2701)

### 个人心得
- **EternalAlexander**：庆祝第一次没看题解没听过讲没任何提示过蓝题，确定用 dp 做后，状态设计简单但转移复杂，需专门编写函数辅助转移。 

---
处理用时：47.39秒
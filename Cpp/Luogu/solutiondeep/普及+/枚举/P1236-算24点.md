# 题目信息

# 算24点

## 题目描述

几十年前全世界就流行一种数字游戏，至今仍有人乐此不疲．在中国我们把这种游戏称为“算 $24$ 点”。您作为游戏者将得到 $4$ 个 $1 \sim 9$ 之间的自然数作为操作数，而您的任务是对这 $4$ 个操作数进行适当的算术运算，要求运算结果等于 $24$。

您可以使用的运算只有：$\verb!+!,\verb!-!,\verb!*!,\verb!/!$，您还可以使用 $\verb!()!$ 来改变运算顺序。注意：所有的中间结果须是整数，所以一些除法运算是不允许的（例如，$(2\ \times 2)/4$ 是合法的，$2\times (2/4)$ 是不合法的）。下面我们给出一个游戏的具体例子：

若给出的 $4$ 个操作数是：$1$ 、 $2$ 、 $3$ 、 $7$，则一种可能的解答是 $1+2+3\ \times 7=24$。

## 说明/提示

感谢 chenyy 提供 special judge

---

$\text{upd 2022.8.1}$：新增加一组 Hack 数据。


## 样例 #1

### 输入

```
1 2 3 7
```

### 输出

```
2+1=3
7*3=21
21+3=24
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是通过枚举或搜索来找出四个数经过四则运算得到 24 的组合。具体实现上，主要有全排列枚举、深度优先搜索（DFS）、后缀表达式枚举等方法。各题解的差异在于枚举的方式、处理运算顺序的手段以及代码实现的细节。

在处理难点方面，大家都关注到了运算过程中不能出现小数、负数和 0，以及输出时操作数的大小顺序等问题。部分题解还针对可能出现的重复计算、边界情况等进行了特殊处理。

### 所选题解
- **作者：razx (赞：108)，4星**
    - **关键亮点**：代码简洁，仅 42 行，使用 `next_permutation` 枚举全排列，且指出实际上只需要判断 `((a?b)?c)?d` 和 `(a?b)?(c?d)` 两种状态即可，减少了不必要的枚举。
    - **核心代码**：
```cpp
int F(int x,int k, int y) {
  if(k==1) return x+y;
  if(k==2) return max(x,y)-min(x,y);
  if(k==3) return x*y;
  return (y==0 || x<y || x%y!=0) ? -999999 : x/y;
}

void Out(int a,int b,int c,int d,int e,int f,int k1,int k2,int k3) {
  printf("%d%c%d=%d\n",max(a,b),opt[k1],min(a,b),F(max(a,b),k1,min(a,b)));
  printf("%d%c%d=%d\n",max(c,d),opt[k2],min(c,d),F(max(c,d),k2,min(c,d)));
  printf("%d%c%d=%d\n",max(e,f),opt[k3],min(e,f),F(max(e,f),k3,min(e,f)));
  exit(0);
}

int main() {
  scanf("%d%d%d%d", &a[1],&a[2],&a[3],&a[4]);
  sort(a+1,a+5);
  do {
    for (int i = 1; i <= 4; i++)
      for (int j = 1; j <= 4; j++)
        for (int k = 1; k <= 4; k++)
          if (F(F(F(a[1],i,a[2]),j,a[3]),k,a[4])==24)
            Out(a[1],a[2],F(a[1],i,a[2]),a[3],F(F(a[1],i,a[2]),j,a[3]),a[4],i,j,k);
          else if (F(F(a[1],i,a[2]),k,F(a[3],j,a[4])) == 24)
            Out(a[1],a[2],a[3],a[4],F(a[1],i,a[2]),F(a[3],j,a[4]),i,j,k);
  }  while (next_permutation(a + 1, a + 5));
  puts("No answer!");
  return 0;
}
```
    - **核心实现思想**：`F` 函数用于执行四则运算，`Out` 函数用于输出运算步骤。在 `main` 函数中，先对输入的四个数进行排序，然后使用 `next_permutation` 枚举全排列，对于每种排列，枚举三个运算符，判断是否能得到 24，若能则输出结果并退出程序。

- **作者：stoorz (赞：51)，4星**
    - **关键亮点**：使用深度优先搜索（DFS），通过不断选择两个数进行四则运算，将结果加入可选数字中，再继续搜索，保证枚举了所有可能的情况，且声称能通过所有已知的 hack 数据。
    - **核心代码**：
```cpp
bool check() {
    for (int i=1;i<=4;i++)
        if (a[i]==24) return 1;
    return 0;
}

void dfs(int k) {
    if (k==4) {
        if (check()) {
            print();
            ok=1;
        }
        return;
    }
    int x,y;
    for (int i=1;i<=4;i++)
        for (int j=1;j<=4;j++)
            if (i!=j&&a[i]>0&&a[j]>0) {
                ans[k][1]=a[i]; ans[k][2]=1; ans[k][3]=a[j];
                x=a[i],y=a[j]; a[i]=x+y; a[j]=-1; dfs(k+1); a[i]=x; a[j]=y; if (ok) return;
                
                ans[k][1]=a[i]; ans[k][2]=2; ans[k][3]=a[j];
                x=a[i],y=a[j]; a[i]=x-y; a[j]=-1; dfs(k+1); a[i]=x; a[j]=y; if (ok) return;
                
                ans[k][1]=a[i]; ans[k][2]=3; ans[k][3]=a[j];
                x=a[i],y=a[j]; a[i]=x*y; a[j]=-1; dfs(k+1); a[i]=x; a[j]=y; if (ok) return;
                
                if (a[j]>0&&a[i]%a[j]==0) {
                    ans[k][1]=a[i]; ans[k][2]=4; ans[k][3]=a[j];
                    x=a[i],y=a[j]; a[i]=x/y; a[j]=-1; dfs(k+1); a[i]=x; a[j]=y; if (ok) return;
                }
            }
}
```
    - **核心实现思想**：`check` 函数用于检查是否得到 24。`dfs` 函数中，当搜索到第 4 层时，检查是否得到 24，若是则输出结果。在每一层，枚举两个数，对它们进行四则运算，将结果更新到数组中，然后继续搜索，搜索结束后回溯。

- **作者：ysner (赞：23)，4星**
    - **关键亮点**：详细指出了多个易错点，如处理相同数运算、保证整除、判断 24 的位置等，对新手有很大的帮助。
    - **核心代码**：
```cpp
void check() {
  for(int i=0;i<4;i++)
    if(a[i]==24) {f=1;break;}
  if(f==1) {
    for(int i=0;i<3;i++) {
      cout<<a1[i];
      if(fh[i]==1) cout<<"+"<<a2[i]<<"="<<a1[i]+a2[i]<<endl;
      if(fh[i]==2) cout<<"-"<<a2[i]<<"="<<a1[i]-a2[i]<<endl;
      if(fh[i]==3) cout<<"*"<<a2[i]<<"="<<a1[i]*a2[i]<<endl;
      if(fh[i]==4) cout<<"/"<<a2[i]<<"="<<a1[i]/a2[i]<<endl;
    }
    exit(0);
  }
}

void dfs(int t) {
  if(t==1) {check();return;}
  if(t>1)
    for(int i=0;i<4;i++)
      if(a[i]==24) return;
  for(int i=0;i<4;i++)
    for(int j=0;j<4;j++)
      if(vis[j]==0&&a[i]>=a[j]&&i!=j) {
        a1[4-t]=a[i]; a2[4-t]=a[j];
        a[i]=a[i]+a[j]; vis[j]=1; fh[4-t]=1;
        if(a[i]>0&&vis[i]==0) dfs(t-1);
        vis[j]=0; a[i]-=a[j];
        
        a1[4-t]=a[i]; a2[4-t]=a[j];
        a[i]=a[i]-a[j]; vis[j]=1; fh[4-t]=2;
        if(a[i]>0&&vis[i]==0) dfs(t-1);
        vis[j]=0; a[i]+=a[j];
        
        a1[4-t]=a[i]; a2[4-t]=a[j];
        a[i]=a[i]*a[j]; vis[j]=1; fh[4-t]=3;
        if(a[i]>0&&vis[i]==0) dfs(t-1);
        vis[j]=0; a[i]/=a[j];
        
        if(a[i]%a[j]==0) {
          a1[4-t]=a[i]; a2[4-t]=a[j];
          a[i]=a[i]/a[j]; vis[j]=1; fh[4-t]=4;
          if(a[i]>0&&vis[i]==0) dfs(t-1);
          vis[j]=0; a[i]*=a[j];
        }
      }
}
```
    - **核心实现思想**：`check` 函数用于检查是否得到 24，若是则输出结果。`dfs` 函数中，当剩余一个数时检查是否为 24。在每一层，枚举两个数，对它们进行四则运算，更新数组并标记已访问，若结果合法则继续搜索，搜索结束后回溯。

### 最优关键思路或技巧
- **全排列枚举**：使用 `next_permutation` 函数可以方便地枚举所有可能的数字排列，减少手动枚举的复杂度。
- **深度优先搜索（DFS）**：通过递归的方式，不断选择两个数进行运算，将结果加入可选数字中，继续搜索，能保证枚举所有可能的情况。
- **后缀表达式**：将中缀表达式转换为后缀表达式，使用栈进行计算，避免了括号优先级的问题，枚举后缀表达式的组合可以不重不漏地覆盖所有运算顺序。

### 可拓展之处
同类型题如“算 24 点”的变种，如改变目标值、增加操作数或运算符等，都可以使用类似的枚举或搜索方法解决。类似算法套路包括全排列枚举、深度优先搜索、广度优先搜索等，在处理组合问题、路径问题等方面都有广泛应用。

### 推荐洛谷题目
- P1036 选数：从 n 个数中选 k 个数，使它们的和为素数，可使用深度优先搜索解决。
- P1135 奇怪的电梯：在一个电梯中，每层有一个数字表示可上升或下降的层数，求从起点到终点的最少步数，可使用广度优先搜索解决。
- P1433 吃奶酪：有 n 个奶酪，求从起点出发，经过所有奶酪的最短路径，可使用全排列枚举或状态压缩动态规划解决。

### 个人心得摘录与总结
- **Vocalise**：一开始只考虑顺序计算配合全排列，结果 WA 了一个点，后来发现是运算只支持左偏表达式树，不支持另一种形态，于是用暴力的方法特判两两算出再相运算的情况才通过。总结：在枚举运算顺序时，要考虑全面，不能遗漏可能的情况。
- **ysner**：详细指出了多个易错点，如处理相同数运算、保证整除、判断 24 的位置等。总结：在实现过程中，要注意细节，特别是边界情况和特殊情况的处理。

---
处理用时：76.87秒
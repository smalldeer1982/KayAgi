# 题目信息

# 树的重量

## 题目描述

树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重构相应的“进化树”。

令 $N=\{1,2,3,\cdots ,n\}$，用一个 $N$ 上的矩阵 $M$ 来定义树 $T$。其中，矩阵 $M$ 满足：对于任意的 $i$，$j$，$k$，有 $M[i,j]+M[j,k] \ge M[i,k]$。树 $T$ 满足：

1. 叶节点属于集合 $N$；
2. 边权均为非负整数；
3. $d_T(i,j)=M[i,j]$，其中 $d_T(i,j)$ 表示树上 $i$ 到 $j$ 的最短路径长度。

如下图，矩阵 $M$ 描述了一棵树。

$$M=\begin{bmatrix}
0 & 5 & 9 & 12 & 8 \\
5 & 0 & 8 & 11 & 7 \\
9 & 8 & 0 & 5 & 1 \\
12 & 11 & 5 & 0 & 4 \\
8 & 7 & 1 & 4 & 0 \\
\end{bmatrix}$$

树的重量是指树上所有边权之和。对于任意给出的合法矩阵 $M$，它所能表示树的重量是惟一确定的，不可能找到两棵不同重量的树，它们都符合矩阵 $M$。你的任务就是，根据给出的矩阵 $M$，计算 $M$ 所表示树的重量。下图是上面给出的矩阵 $M$ 所能表示的一棵树，这棵树的总重量为 $15$。

![](https://cdn.luogu.com.cn/upload/image_hosting/dnk8ys2t.png)


## 样例 #1

### 输入

```
5
5 9 12 8
8 11 7
5 1
4
```

### 输出

```
15

```

## 样例 #2

### 输入

```
4
15 36 60
31 55
36```

### 输出

```
71```

# AI分析结果

### 综合分析与结论
这些题解大多围绕贪心算法展开，核心思路是从简单情况（$n = 2$）开始，逐步加入节点构建树，通过计算新节点到已构建树的最小距离来累加树的重量。不同题解在实现细节和证明方式上存在差异，但整体思路一致。

### 所选题解
- **作者：Mathison（4星）**
  - **关键亮点**：思路清晰，代码简洁，对$n$不同取值的情况分析详细，公式推导明确。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dis[35][35];
int main()
{
    while(~scanf("%d",&n))
    {
        if(!n) break; 
        for(int i=1;i<n;i++)
            for(int j=i+1;j<=n;j++)
                scanf("%d",&dis[i][j]);
        int ans=dis[1][2];
        for(int i=3;i<=n;i++)
        {
            int tmp=0x7fffffff;
            for(int j=2;j<i;j++) 
                tmp=min(tmp,(dis[1][i]-dis[1][j]+dis[j][i])/2);
            ans+=tmp;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```
  - **核心实现思想**：先处理$n = 2$的情况，答案为$dis(1, 2)$。对于$n > 2$，依次加入节点$i$，枚举$j$（$2 \leq j < i$），计算新节点$i$到已构建树的最小距离$tmp$，并累加到答案$ans$中。

- **作者：APTX_4869（4星）**
  - **关键亮点**：结合图形解释思路，通俗易懂，代码规范。
  - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 35;
int n,ans,len,dis[N][N];
int main()
{
    scanf("%d",&n);
    while(n!=0)
    {
        ans=0;
        for(int i=1;i<=n;i++)
            for(int j=i+1;j<=n;j++)
                scanf("%d",&dis[i][j]);
        ans=dis[1][2];
        for(int i=3;i<=n;i++)
        {
            len=1054612165;
            for(int j=2;j<i;j++)
            {
                len=min(len,(dis[1][i]+dis[j][i]-dis[1][j])>>1);
            }
            ans+=len;
        }
        printf("%d\n",ans);
        scanf("%d",&n);
    }
    return 0;
}
```
  - **核心实现思想**：同样先处理$n = 2$的情况，对于$n > 2$，在加入节点$i$时，枚举$j$（$2 \leq j < i$），计算新节点$i$到已构建树的最小距离$len$，累加到答案$ans$中。

- **作者：Tofu（4星）**
  - **关键亮点**：对贪心算法的正确性进行了详细证明，优化了时间复杂度。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int dis[40][40];
int n,m,i,j,x,tmp,ans;
int main(){
    while(true){
        cin>>n;
        if(n==0) break;
        ans=0;
        for(i=1;i<=n-1;i++){
            for(j=1;j<=n-i;j++){
                cin>>x;
                dis[i][j+i]=dis[j+i][i]=x;
            }
        }
        if(n>=2) ans=dis[1][2];
        for(i=3;i<=n;i++){
            int now=100000000;
            for(j=2;j<=i-1;j++){
                now=min(now,dis[1][i]+dis[i][j]-dis[1][j]);
            }
            ans+=(now/2);
        }   
        cout<<ans<<endl;
    }
    return 0;
}
```
  - **核心实现思想**：先处理输入，对于$n \geq 2$，答案初始化为$dis(1, 2)$。对于$n > 2$，加入节点$i$时，枚举$j$（$2 \leq j < i$），计算新节点$i$到已构建树的最小距离$now$，累加到答案$ans$中。

### 最优关键思路或技巧
- **贪心策略**：从简单情况开始，逐步加入节点，每次选择新节点到已构建树的最小距离，保证树的重量最小。
- **固定端点优化**：固定一个端点（如点1），枚举另一个端点，将三维循环优化为二维循环，降低时间复杂度。

### 可拓展之处
同类型题或类似算法套路：
- **最小生成树问题**：如Kruskal算法和Prim算法，通过贪心策略构建最小生成树。
- **图的最短路径问题**：如Dijkstra算法和Floyd算法，计算图中节点间的最短路径。

### 推荐题目
- [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)

### 个人心得摘录与总结
- **作者：Rbrq**：做了5个小时，看了90分钟才理解题目，说明本题有一定难度，需要深入思考。
- **作者：QWsin**：开始看题解不认真，对如何确定分支位置感到困惑，后来发现可以枚举，说明解题时要认真理解题意，多尝试不同方法。

---
处理用时：47.18秒
# 题目信息

# [NOIP 2010 提高组] 乌龟棋

## 题目背景

NOIP2010 提高组 T2

## 题目描述

小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。

乌龟棋的棋盘是一行 $N$ 个格子，每个格子上一个分数（非负整数）。棋盘第 $1$ 格是唯一的起点，第 $N$ 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。

乌龟棋中 $M$ 张爬行卡片，分成 $4$ 种不同的类型（$M$ 张卡片中不一定包含所有 $4$ 种类型的卡片，见样例），每种类型的卡片上分别标有 $1,2,3,4$ 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。


游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。


很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。


现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？


## 说明/提示

每个测试点 1s。

小明使用爬行卡片顺序为 $1,1,3,1,2$，得到的分数为 $6+10+14+8+18+17=73$。注意，由于起点是 $1$，所以自动获得第 $1$ 格的分数 $6$。


对于 $30\%$ 的数据有 $1≤N≤30,1≤M≤12$。


对于 $50\%$ 的数据有 $1≤N≤120,1≤M≤50$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $20$。


对于 $100\%$ 的数据有 $1≤N≤350,1≤M≤120$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $40$；$0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M$。


## 样例 #1

### 输入

```
9 5
6 10 14 2 8 8 18 5 17
1 3 1 2 1
```

### 输出

```
73
```

# AI分析结果

### 综合分析与结论
这些题解大多采用动态规划算法解决乌龟棋问题。核心思路是定义一个四维数组来记录使用不同数量的四种卡片时所能获得的最大分数，通过状态转移方程不断更新数组元素，最终得到使用完所有卡片后的最大分数。各题解在思路阐述、代码实现和优化程度上有所差异，但整体思路一致。

### 所选题解
- **作者：吃瓜群众syc (赞：415)  ★★★★**
  - **关键亮点**：思路清晰，详细解释了动态规划的过程，将问题与背包思想联系起来，易于理解。代码实现规范，注释详细。
  - **个人心得**：作者提到因为忘记在计算当前位置时加 1 而调试了一个小时，提醒读者在实现时要注意边界条件。
- **作者：Time_Rune (赞：130)  ★★★★**
  - **关键亮点**：先分析了搜索算法的不可行性，然后重点推导状态转移方程，对动态规划的理解和解题步骤讲解详细，有助于读者掌握动态规划的解题思路。
  - **个人心得**：作者一开始想用搜索 + 回溯配记忆化的方法解题，但发现会超时，从而转向动态规划，提醒读者在选择算法时要考虑数据规模和时间复杂度。
- **作者：ikunTLE (赞：11)  ★★★★**
  - **关键亮点**：使用数学公式清晰地表达了状态转移方程，代码简洁，实现了核心思路。

### 重点代码及核心实现思想
以下是“吃瓜群众syc”题解的核心代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=41;
int F[MAXN][MAXN][MAXN][MAXN],num[351],g[5],n,m,x;
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>num[i];
    F[0][0][0][0]=num[1];
    for(int i=1;i<=m;i++)
    {
        cin>>x;
        g[x]++;
    }
    for(int a=0;a<=g[1];a++)
        for(int b=0;b<=g[2];b++)
            for(int c=0;c<=g[3];c++)
                for(int d=0;d<=g[4];d++)
                {
                    int r=1+a+b*2+c*3+d*4;
                    if(a!=0)	F[a][b][c][d]=max(F[a][b][c][d],F[a-1][b][c][d]+num[r]);
                    if(b!=0)    F[a][b][c][d]=max(F[a][b][c][d],F[a][b-1][c][d]+num[r]);
                    if(c!=0)    F[a][b][c][d]=max(F[a][b][c][d],F[a][b][c-1][d]+num[r]);
                    if(d!=0)	F[a][b][c][d]=max(F[a][b][c][d],F[a][b][c][d-1]+num[r]);
                }	
    cout<<F[g[1]][g[2]][g[3]][g[4]];
    return 0;
}
```
**核心实现思想**：
1. 定义四维数组 `F[a][b][c][d]` 表示使用 `a` 张爬行牌 1，`b` 张爬行牌 2，`c` 张爬行牌 3，`d` 张爬行牌 4 时的得分。
2. 初始化 `F[0][0][0][0]` 为起点的分数。
3. 统计每种卡片的数量。
4. 通过四重循环枚举每种卡片的使用数量，根据状态转移方程更新 `F` 数组。
5. 最终结果为 `F[g[1]][g[2]][g[3]][g[4]]`。

### 最优关键思路或技巧
- **状态定义**：用四维数组记录使用不同数量的四种卡片时的最大分数，避免了记录当前位置带来的空间浪费。
- **状态转移**：当前状态可以由前一个状态转移而来，通过比较不同转移路径的得分，取最大值更新当前状态。
- **边界处理**：注意初始化起点的分数，以及在状态转移时判断卡片数量是否为 0，避免数组越界。

### 可拓展之处
同类型题或类似算法套路：
- **多维动态规划**：当问题涉及多个变量的状态变化时，可以考虑使用多维数组进行动态规划，如不同类型的资源分配问题。
- **状态压缩**：如果状态维度过高，导致空间复杂度较大，可以考虑使用状态压缩技巧，如滚动数组，减少空间开销。

### 推荐题目
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的 0 - 1 背包问题，与本题的动态规划思想类似。
- [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)：也是 0 - 1 背包问题的变种，通过动态规划求解最大价值。
- [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：同样是动态规划问题，通过状态转移方程求解方案数。

### 个人心得总结
- **调试经历**：“吃瓜群众syc”作者因忘记在计算当前位置时加 1 而调试了一个小时，提醒我们在实现时要注意边界条件。
- **算法选择**：“Time_Rune”作者一开始想用搜索 + 回溯配记忆化的方法解题，但发现会超时，从而转向动态规划，提醒我们在选择算法时要考虑数据规模和时间复杂度。

---
处理用时：43.30秒
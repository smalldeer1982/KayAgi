# 题目信息

# 液体滴落

## 题目描述

在平面中有若干线段 $L_i$（**不一定互不相交**），组成一个又一个轨道，有一滴液体从上方滴落下来，如果碰到轨道就沿着轨道向下滚，从轨道较低的一端离开轨道，在轨道中不受任何影响，否则就垂直滴落，问最后液滴从什么位置落出整个系统。

相信这个题目一定难不倒你。

## 说明/提示

对于 $50\%$ 的数据，$1\le n\le100$，$|x|,|y|,|S| \le500$；

对于 $100\%$ 的数据，$1\le n\le 10^5$，$|x|,|y|,|S|≤10^9$。

![](https://cdn.luogu.com.cn/upload/image_hosting/gclp58tq.png)


## 样例 #1

### 输入

```
4 2
1 4 3 2
5 4 2 1
-2 -1 0 -2
-1 -3 4 -4```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解核心思路都是模拟液体滴落过程，先求出线段的一次函数解析式，再不断寻找液体能落到的最高线段，更新液体位置直至无法落到线段为止。大部分题解采用 $O(n^2)$ 的暴力枚举，B612Dusk 的题解使用分块思想优化到 $O(n\sqrt{n})$。

### 所选题解
- **作者：B612Dusk（5星）**
    - **关键亮点**：采用分块思想对算法进行优化，将时间复杂度从 $O(n^2)$ 降低到 $O(n\sqrt{n})$，避免了大量无意义的重复运算。详细阐述了分块的过程和排序规则，思路清晰。
    - **核心代码**：
```cpp
// 分块预处理
sort(a + 1,a + n + 1, sort_l);
for(reg int i = 1;i <= n;i ++) {
    vec[area[i]].push_back(a[i]);
    Ln[area[i]] = min(a[i].lx, Ln[area[i]]);
    Rx[area[i]] = max(a[i].rx, Rx[area[i]]);
}
for(reg int i = 1;i <= area[n];i ++)	
    sort(vec[i].begin(), vec[i].end(), sort_r);

// 模拟滴落过程
void work(int x, int h) {
    int high = -9999999999;
    int f = 0;
    int blo = lower_bound(Ln + 1, Ln + area[n], x) - Ln;
    for(reg int i = 1;i <= blo;i ++) {
        for(reg int j = 0;j < vec[i].size();j ++) {
            if(x >= vec[i][j].rx) break;
            int Y = vec[i][j].k * x + vec[i][j].b;
            if(x < vec[i][j].rx && x > vec[i][j].lx && Y <= h && Y > high) {
                high = Y;
                f = 1;
                if(vec[i][j].ly > vec[i][j].ry) pos = vec[i][j].rx, py = vec[i][j].ry;
                else pos = vec[i][j].lx, py = vec[i][j].ly;
            }
        }
    }
    if(f) work(pos, py);
    return;
}
```
- **作者：Zhou_SY（4星）**
    - **关键亮点**：详细推导了直线解析式的求解过程，代码注释清晰，适合初学者理解。
    - **核心代码**：
```cpp
while(1) {
    int l = 0;
    double k = -1000000010;
    for(int i = 1;i <= n;i++)
        if(Y > min(y[1][i],y[2][i]) && min(x[1][i],x[2][i]) <= X && X <= max(x[1][i],x[2][i])) {
            double YYY = (y[1][i] - y[2][i]) / (x[1][i] - x[2][i]) * X + (x[1][i] * y[2][i] - x[2][i] * y[1][i]) / (x[1][i] - x[2][i]);
            if(Y <= YYY) continue;
            if(YYY > k) {
                l = i;
                k = YYY;
            }
        }
    if(l == 0) {
        printf("%.0lf\n",X);
        break;
    } else {
        if(y[1][l] < y[2][l]) {
            X = x[1][l];
            Y = y[1][l];
        } else {
            X = x[2][l];
            Y = y[2][l];
        }
    }
}
```

### 最优关键思路或技巧
- **分块优化**：B612Dusk 的题解使用分块思想，将线段存入块中，记录每个块的左右端点最值，通过二分查找缩小扫描范围，避免了大量无意义的重复运算，将时间复杂度从 $O(n^2)$ 优化到 $O(n\sqrt{n})$。
- **解析式推导**：各题解都详细推导了直线的一次函数解析式，通过已知两点坐标求出斜率 $k$ 和截距 $b$，方便后续计算液体滴落位置。

### 可拓展之处
同类型题可拓展到三维空间的物体下落碰撞问题，或者增加液体在轨道上的物理效果（如摩擦力、速度变化等）。类似算法套路可用于处理几何图形的碰撞检测、光线追踪等问题。

### 推荐题目
1. [P1328 生活大爆炸版石头剪刀布](https://www.luogu.com.cn/problem/P1328)：模拟类型题目，通过模拟游戏过程求解结果。
2. [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)：需要对多项式的各项系数和次数进行模拟处理。
3. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)：模拟乒乓球比赛过程，根据比赛规则输出结果。

### 个人心得摘录与总结
- **作者：Y_B_Y**：一开始把“不一定互不相交”看成了“一定互不相交”，导致后续判断错误，花费了很多时间修改。总结为读题要仔细，注意题目中的关键条件。
- **作者：Aisaka_Taiga**：使用结构体时不断添加变量导致代码混乱，认为用数组更好。提醒在选择数据结构时要考虑代码的可维护性和扩展性。 

---
处理用时：33.13秒
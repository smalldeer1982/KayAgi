# 题目信息

# 符文之语

## 题目背景

传说中珠穆朗玛峰下有座古代人修建的神庙，神庙的地下室里有古代王室的遗产，但数千年来从未有人到达过……探险者小 FF 一直梦想成为世界上最富有的人和最杰出的探险家并被永载史册。在证明了这个洞确实存在后，小 FF 做好了充足准备，来到了神庙。

## 题目描述

当小 FF 来到神庙时，神庙已经破败不堪了。但神庙的中央有一个光亮如新的石台。小 FF 走近石台，发现石台上有一个数串，而数串的上方刻着一串古老的符文之语。精通古符文之语的小 FF 不费吹灰之力就读懂了文章的意思，其大意是：

对于石台上的一串数字，你可以在适当的位置加入乘号（设加了 $k$ 个，当然也可不加，即分成 $k+1$ 个部分），设这 $k+1$ 个部分的乘积（如果 $k=0$，则乘积即为原数串的值）对 $m$ 的余数（即 $\bmod\ m$）为 $x$；

现求 $x$ 能达到的最小值及该情况下 $k$ 的最小值，以及 $x$ 能达到的最大值及该情况下的 $k$ 的最小值（可以存在 $x$ 的最小值与最大值相同的情况）。

小 FF 还知道，如果他找到了正确的答案，那么就可以通往神庙的下层了。但这个问题似乎不太好解决，小 FF 就找到了你，并答应找到财宝以后和你二八分（当然你拿二……）。

## 说明/提示

记 $L$ 表示字符串的长度。

- 对于 $30\%$ 的数据：$2 \le L \le 50$；
- 对于 $100\%$ 的数据：$2 \le L \le 1000$，$2 \le m \le 50$。

NOI 导刊 $2010$ 提高（$02$）

## 样例 #1

### 输入

```
4421

22

```

### 输出

```
0 1 21 0```

# AI分析结果

### 综合分析与结论
这些题解均采用动态规划（DP）来解决符文之语问题。核心思路是通过定义合适的 DP 数组，枚举不同状态并进行状态转移，最终找到最小和最大余数及其对应的最小乘号数量。各题解在状态定义、转移方程推导、预处理和代码实现细节上略有差异，但整体思路一致。
### 所选题解
- **作者：2018李泽明（4星）**
  - **关键亮点**：思路清晰，对状态定义和转移过程有详细解释，代码注释丰富，便于理解。
  - **个人心得**：作者表示这道题状态难设，自己肝了一个晚上，考试时也被虐得很惨，强调了攻克 DP 状态设计的重要性。
- **作者：asdfghjkl123（4星）**
  - **关键亮点**：对代码进行了详细解释，包括变量定义、读入取模、状态转移和输出等各个环节，有助于读者理解。
  - **个人心得**：作者称自己对题解代码纠结了很长时间，通过参考题解代码才 AC，体现了学习他人思路的重要性。
- **作者：Mine_King（4星）**
  - **关键亮点**：对状态转移方程的推导过程有详细说明，还指出了除法在模意义下的问题并给出解决方案，对细节把握较好。
  - **个人心得**：无。
### 重点代码及核心实现思想
#### 作者：2018李泽明
```cpp
// 状态定义：f[i][j] 表示到第 i 个数字，满足最小乘积（对 m 取余后的）所需要划分的阶段（要加的括号）
// sum[i][j] 表示从第 i 个数字到第 j 个数字的乘积对 m 取余
memset(f,0x7F,sizeof(f));
scanf("%s\n%d",zfc,&m);
lon=strlen(zfc);
for(int i=1;i<=lon;i++)
    sum[i][i]=zfc[i-1]-'0';
for(int i=lon;i>=1;i--)
    for(int j=i+1;j<=lon;j++)
        sum[i][j]=(sum[i][j-1]*10%m+sum[j][j])%m;
for(int i=1;i<=lon;i++)
    f[i][sum[1][i]]=0;
for(int i=1;i<=lon;i++)
    for(int j=1;j<i;j++)
        for(int k=0;k<m;k++)
            if(f[j][k]+1<f[i][k*sum[j+1][i]%m])
                f[i][k*sum[j+1][i]%m]=f[j][k]+1;
for(int i=0;i<m;i++)
    if(f[lon][i]<0x7F)
    {
        printf("%d %d ",i,f[lon][i]);
        break;
    }
for(int i=m;i>=0;i--)
    if(f[lon][i]<0x7F)
    {
        printf("%d %d",i,f[lon][i]);
        break;
    }
```
**核心实现思想**：先预处理出每个区间的数字对 m 取余的结果，然后初始化边界状态，接着通过三重循环进行状态转移，最后从小到大和从大到小枚举余数，找到最小和最大余数及其对应的最小乘号数量。
#### 作者：asdfghjkl123
```cpp
// 状态定义：dp[i][j] 前 i 个字符能够达到模为 j 的操作数
// M[i][j] 从 i 位到 j 位组成的数字对于 mod 的模
cin>>a+1;
int n=strlen(a+1);
scanf("%d",&mod);
for(int i=1;i<=n;i++)M[i][i]=(a[i]-='0')%mod;
for(int l=n;l>=1;l--)for(int r=l+1;r<=n;r++)M[l][r]=(M[l][r-1]*(10%mod)+M[r][r])%mod;
for(int i=1;i<=n;i++)for(int j=0;j<=mod;j++)dp[i][j]=INF;
for(int i=1;i<=n;i++)dp[i][M[1][i]]=0;
for(int i=1;i<=n;i++)
{
    for(int j=1;j<i;j++)
    {
        for(int k=0;k<mod;k++)
        {
            dp[i][(k*M[j+1][i])%mod]=min(dp[i][(k*M[j+1][i])%mod],dp[j][k]+1);
        }
    }
}
for(int i=0;i<mod;i++)if(dp[n][i]<INF){cout<<i<<" "<<dp[n][i]<<" ";break;}
for(int i=mod-1;i>=0;i--)if(dp[n][i]<INF){cout<<i<<" "<<dp[n][i]<<endl;return 0;}
```
**核心实现思想**：先读入数据并预处理每个区间的数字对 mod 取余的结果，然后初始化 DP 数组，通过三重循环进行状态转移，最后枚举余数找到最小和最大余数及其对应的最小乘号数量。
#### 作者：Mine_King
```cpp
// 状态定义：dp[i][x] 表示前 i 个数，最少用 dp[i][x] 个乘号能凑出 x
// mul[i][j] 表示截取 i 到 j 这一段的数值对 m 取余的结果
cin>>s;
n=s.length();
for(int i=1;i<=n;i++) a[i]=s[i-1]-'0';
scanf("%d",&m);
for(int i=1;i<=n;i++)
    for(int j=i;j<=n;j++)
        mul[i][j]=(mul[i][j-1]*10+a[j])%m;
memset(dp,0x3f,sizeof(dp));
int INF=dp[0][0];
for(int i=1;i<=n;i++) dp[i][mul[1][i]]=0;
for(int i=1;i<=n;i++)
    for(int x=0;x<m;x++)
        for(int j=i+1;j<=n;j++)
            dp[j][x*mul[i+1][j]%m]=min(dp[j][x*mul[i+1][j]%m],dp[i][x]+1);
for(int i=0;i<m;i++)
    if(dp[n][i]!=INF){printf("%d %d ",i,dp[n][i]);break;}
for(int i=m-1;i>=0;i--)
    if(dp[n][i]!=INF){printf("%d %d\n",i,dp[n][i]);break;}
```
**核心实现思想**：先读入数据并预处理每个区间的数字对 m 取余的结果，然后初始化 DP 数组，通过三重循环进行状态转移，最后枚举余数找到最小和最大余数及其对应的最小乘号数量。
### 最优关键思路或技巧
- **状态设计**：利用二维 DP 数组，一维表示处理到的数字位置，另一维表示余数，存储达到该余数所需的最小乘号数量。
- **预处理**：预先计算每个区间的数字对模数取余的结果，避免重复计算，提高效率。
- **状态转移**：通过枚举乘号的位置和前一个状态的余数，进行状态转移，更新 DP 数组。
### 可拓展之处
同类型题或类似算法套路：
- **区间划分问题**：如将一个序列划分为若干段，求每段的某种运算结果的最值。
- **余数相关问题**：涉及对某个数取余的动态规划问题，可参考本题的状态设计和转移思路。
### 推荐题目
- [P1018 乘积最大](https://www.luogu.com.cn/problem/P1018)
- [P1043 数字游戏](https://www.luogu.com.cn/problem/P1043)
- [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)
### 个人心得总结
- 部分作者表示本题状态设计较难，需要花费较多时间思考和调试，强调了攻克 DP 状态设计的重要性。
- 一些作者通过参考他人题解才成功 AC，体现了学习他人思路和代码的重要性。

---
处理用时：53.51秒
# 题目信息

# [NOIP 2014 提高组] 飞扬的小鸟

## 题目背景

NOIP2014 提高组 D1T3

## 题目描述

Flappy Bird 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。

为了简化问题，我们对游戏规则进行了简化和改编:

游戏界面是一个长为 $n$，高为 $m$ 的二维平面，其中有 $k$ 个管道（忽略管道的宽度）。 

小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。

小鸟每个单位时间沿横坐标方向右移的距离为 $1$，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度 $x$，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度 $y$。小鸟位于横坐标方向不同位置时，上升的高度 $x$ 和下降的高度 $y$ 可能互不相同。

小鸟高度等于 $0$ 或者小鸟碰到管道时，游戏失败。小鸟高度为 $m$ 时，无法再上升。

现在,请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。

## 说明/提示

 
【输入输出样例说明】

如下图所示，蓝色直线表示小鸟的飞行轨迹，红色直线表示管道。

![](https://cdn.luogu.com.cn/upload/image_hosting/59alxbqi.png)

【数据范围】

对于 $30\%$ 的数据：$5 \leq n \leq 10, 5 \leq m \leq 10, k=0$，保证存在一组最优解使得同一单位时间最多点击屏幕 $3$ 次；

对于 $50\%$ 的数据：$5 \leq n \leq 20, 5 \leq m \leq 10$，保证存在一组最优解使得同一单位时间最多点击屏幕 $3$ 次；

对于 $70\%$ 的数据：$5 \leq n \leq 1000, 5 \leq m \leq 100$；

对于 $100\%$ 的数据：$5 \leq n \leq 10000$，$5 \leq m \leq 1000$，$0 \leq k < n$，$0 < x,y < m$，$0 < p < n$，$0 \leq l < h \leq m$， $l + 1 < h$。

## 样例 #1

### 输入

```
10 10 6 
3 9  
9 9  
1 2  
1 3  
1 2  
1 1  
2 1  
2 1  
1 6  
2 2  
1 2 7 
5 1 5 
6 3 5 
7 5 8 
8 7 9 
9 1 3 
```

### 输出

```
1
6

```

## 样例 #2

### 输入

```
10 10 4 
1 2  
3 1  
2 2  
1 8  
1 8  
3 2  
2 1  
2 1  
2 2  
1 2  
1 0 2 
6 7 9 
9 1 4 
3 8 10  ```

### 输出

```
0
3```

# AI分析结果

### 综合分析与结论
这些题解均围绕“飞扬的小鸟”这一动态规划问题展开。核心思路是定义状态 $dp[i][j]$ 表示到达横坐标 $i$、纵坐标 $j$ 所需的最少点击数，将上升视为完全背包问题，下降视为 0 - 1 背包问题。各题解的差异主要体现在状态转移方程的推导、复杂度优化以及边界条件处理上。

### 所选题解
- **作者：蒟蒻zExNocs（5星）**
    - **关键亮点**：思路详细，从基础状态定义逐步推导，结合背包思想，且有详细的初始化、特判和优化说明，代码注释丰富。
    - **个人心得**：因忽略“可以多次点击，效果累加”这一条件写错多次；写题解时将数字记错，提醒注意细节。
- **作者：依然wtm（4星）**
    - **关键亮点**：从朴素 DP 方程逐步优化，详细记录了调试过程和错误分析，最终优化到 $O(nm)$ 复杂度。
    - **个人心得**：最初代码只拿 50 分，去掉 $j = 0$ 的情况后得 70 分，发现 $j - k * lift[i - 1] >= 0$ 条件在 $j = m$ 时可能出错，修正后拿 80 分，最后优化上升更新部分 AC。
- **作者：Mr_Wu（4星）**
    - **关键亮点**：先给出 $O(nm^2)$ 复杂度的算法，再分析复杂度高的原因并优化到 $O(nm)$，代码实现清晰。

### 重点代码及核心思想
#### 蒟蒻zExNocs
```cpp
for(int i=1;i<=n;i++)
{
    for(int j=0;j<=m;j++)
        dp[i%2][j]=inf;
    for(int j=x[i]+1;j<=x[i]+m;j++)
        dp[i%2][j]=min(dp[i%2^1][j-x[i]]+1,dp[i%2][j-x[i]]+1);
    for(int j=m+1;j<=x[i]+m;j++)
        dp[i%2][m]=min(dp[i%2][m],dp[i%2][j]);
    for(int j=1;j<=m-y[i];j++)
        dp[i%2][j]=min(dp[i%2][j],dp[i%2^1][j+y[i]]);
    if(i==o[cnt].id)
    {
        ans=inf;
        for(int j=0;j<=o[cnt].l;j++)
            dp[i%2][j]=inf;
        for(int j=o[cnt].h;j<=m;j++)
            dp[i%2][j]=inf;
        for(int j=1;j<=m;j++)
            ans=min(dp[i%2][j],ans);
        if(ans==inf)
        {
            pr(0);pc('\n');pr(cnt-1);return 0;
        }
        cnt++;
    }
}
```
**核心思想**：使用滚动数组优化空间，先初始化当前列的状态为无穷大，再进行上升和下降的状态转移，遇到管道时将管道位置的状态置为无穷大，若当前列无法通过则输出结果。

#### 依然wtm
```cpp
for (int i = 1; i <= n; i++) {
    int lower = 1, upper = m;
    if (pipe[nump].pos == i) {
        upper = pipe[nump].up - 1;
        lower = pipe[nump++].bottom + 1;
    }
    for (int j = lower; j <= upper; j++) {
        if (j == m) {
            for (int k = 1; k <= m; k++) {
                f[i][j] = min(f[i][j], f[i - 1][k] + ((m - k) / lift[i - 1]) + (((m - k) % lift[i - 1] || k == m)? 1 : 0));
            }
        } else {
            for (int k = 1; j - k * lift[i - 1] >= 0; k++) {
                f[i][j] = min(f[i][j], f[i - 1][j - k * lift[i - 1]] + k);
            } 
        }
        if (j + down[i - 1] <= m) f[i][j] = min(f[i][j], f[i - 1][j + down[i - 1]]);
    }
}
```
**核心思想**：枚举每一列和高度，根据是否为最高点进行不同的上升状态转移，同时进行下降状态转移，遇到管道时更新上下边界。

#### Mr_Wu
```cpp
for (i = 1; i <= N; ++i)
{
    ans[i] = INF;
    for (j = 1; j <= M; ++j) dp[i][j] = INF;
    for (j = X[i - 1] + 1; j < M; ++j) dp[i][j] = min(dp[i][j], min(dp[i - 1][j - X[i - 1]], dp[i][j - X[i - 1]]) + 1);
    for (j = M - X[i - 1]; j <= M; ++j) dp[i][M] = min(dp[i][M], min(dp[i - 1][j], dp[i][j]) + 1);
    for (j = 1; j + Y[i - 1] <= M; ++j) dp[i][j] = min(dp[i][j], dp[i - 1][j + Y[i - 1]]);
    if (W[i])
    {
        for (j = 1; j <= L[i]; ++j) dp[i][j] = INF;
        for (j = H[i]; j <= M; ++j) dp[i][j] = INF;
    }
    for (j = 1; j <= M; ++j) ans[i] = min(ans[i], dp[i][j]);
    if (ans[i] == INF)
    {
        ll ac = 0;
        for (j = 1; j < i; ++j) if (W[j]) ++ac;
        printf("0\n%lld\n", ac);
        return 0;
    }
}
```
**核心思想**：先初始化当前列的状态为无穷大，通过优化上升状态转移方程减少复杂度，进行下降状态转移，遇到管道时将管道位置的状态置为无穷大，若当前列无法通过则输出结果。

### 最优关键思路或技巧
- **背包思想**：将上升视为完全背包，下降视为 0 - 1 背包，简化状态转移方程的推导。
- **复杂度优化**：分析状态转移的重复计算部分，通过优化状态转移方程将时间复杂度从 $O(nm^2)$ 降低到 $O(nm)$。
- **滚动数组**：利用状态转移只与上一列有关的特点，使用滚动数组将空间复杂度从 $O(nm)$ 降低到 $O(m)$。

### 可拓展之处
同类型题或类似算法套路：
- 其他涉及状态转移和背包问题的动态规划题目，如多重背包、分组背包等。
- 带有障碍物或边界条件限制的路径规划问题，可通过类似的状态定义和转移方程解决。

### 推荐题目
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)：基础的 0 - 1 背包问题。
- [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)：完全背包问题。
- [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)：多重背包问题。

### 个人心得总结
多位作者在解题过程中都遇到了细节问题，如忽略条件、边界判断错误等，导致代码得分不高。通过仔细分析数据、调试代码，逐步修正错误并优化算法，最终得到正确结果。这提醒我们在解题时要注意细节，认真分析题目条件，同时在调试过程中要善于利用数据和输出信息找出问题所在。 

---
处理用时：53.56秒
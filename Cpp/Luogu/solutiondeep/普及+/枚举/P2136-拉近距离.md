# 题目信息

# 拉近距离

## 题目背景

我是源点，你是终点。我们之间有负权环。 ——小明

## 题目描述

在小明和小红的生活中，有 $N$ 个关键的节点。有 $M$ 个事件，记为一个三元组 $(S_i,T_i,W_i)$，表示从节点 $S_i$ 有一个事件可以转移到 $T_i$，事件的效果就是使他们之间的距离减少 $W_i$。

这些节点构成了一个网络，其中节点 $1$ 和 $N$ 是特殊的，节点 $1$ 代表小明，节点 $N$ 代表小红，其他代表进展的阶段。所有事件可以自由选择是否进行，但每次只能进行当前节点邻接的。请你帮他们写一个程序，计算出他们之间可能的最短距离。

## 说明/提示

对于 $20\%$ 数据，$N \le 10$，$M \le 50$。

对于 $50\%$ 数据，$N \le 300$，$M \le 5000$。

对于 $100\%$ 数据，$1\le N \le 10^3$，$1\le M \le 10^4$，$|W_i|\le 100$，保证从节点 $1$ 到 $2 \dots N$ 有路径，从节点 $N$ 到 $1 \dots N - 1$ 有路径。

## 样例 #1

### 输入

```
3 3
1 2 3
2 3 -1
3 1 -10```

### 输出

```
-2```

# AI分析结果

### 综合分析与结论
本题是一个带负权边和负权环判断的最短路问题。各题解的核心思路较为一致，都是先将边权取反，再使用能处理负权边和负权环的算法（主要是 SPFA 和 Bellman - Ford），并且都强调要分别以节点 1 和节点 N 为源点跑最短路，取最小值作为结果。若图中存在负权环，则输出 “Forever love”。

### 所选题解
- **作者：Dijkspfa (赞：42)，4星**
    - **关键亮点**：思路清晰，明确指出题目中未明确源点汇点，需分别以 1 和 n 为源点各做一遍 SPFA 取最小值，对坑点分析到位。
    - **个人心得**：第一次 A 这道题时刚学 SPFA，n = 999 的点和其他题解一样特判过，一直以为是数据错了，后来发现坑点，不用特判就能 A 题。

### 重点代码
```cpp
inline void adde(int u,int v,int w){e[++cnte].w = w,e[cnte].v = v,e[cnte].nxt = pre[u],pre[u] = cnte;}
void spfa(int x){
    queue<int> q;
    memset(dis,0x3f,sizeof(dis));
    dis[x] = 0;q.push(x);vis[x] = 1;
    while(!q.empty())
    {
        int t=q.front();q.pop();
        vis[t] = 0;
        if(cnt[t] > n){puts("Forever love");exit(0);}
        for(int i = pre[t];i;i = e[i].nxt)
            if(dis[t] + e[i].w < dis[e[i].v])
            {
                dis[e[i].v] = dis[t] + e[i].w;
                if(!vis[e[i].v]) q.push(e[i].v),cnt[e[i].v]++,vis[e[i].v] = 1;
            }
    }
    return;
}
int main(){
    int s,t,w;
    cin>>n>>m;
    for(int i = 1;i <= m;i++)
    {
        scanf("%d%d%d",&s,&t,&w);
        adde(s,t,-w);
    }
    spfa(1);
    int ans = dis[n];
    spfa(n);
    printf("%d",min(ans,dis[1]));
    return 0;
}
```
**核心实现思想**：
1. `adde` 函数用于链式前向星建边，将边权取反存储。
2. `spfa` 函数是核心的 SPFA 算法实现，通过队列不断更新节点的最短距离，若某个节点入队次数超过 n，则判定存在负权环，输出 “Forever love” 并退出程序。
3. `main` 函数中先读入数据并建边，然后分别以 1 和 n 为源点调用 `spfa` 函数，最后取两次结果的最小值输出。

### 最优关键思路或技巧
1. **边权取反**：由于题目中事件效果是使距离减少，将边权取反后就可以将问题转化为常见的最短路问题。
2. **双向求解**：考虑到小明和小红都可能主动拉近距离，分别以 1 和 n 为源点跑最短路，取最小值，避免遗漏最优解。
3. **负权环判断**：使用节点入队次数来判断负权环，若某个节点入队次数超过节点总数 n，则判定存在负权环。

### 可拓展之处
同类型题如涉及负权边和负权环的最短路问题，都可以使用 SPFA 或 Bellman - Ford 算法。类似算法套路包括在有向图中求最长路时可以将边权取反后求最短路，在判断负权环时可以记录节点的入队次数或松弛次数。

### 推荐题目
1. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)
2. [P1807 最长路](https://www.luogu.com.cn/problem/P1807)
3. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

### 个人心得总结
部分题解作者分享了调试经历，如一开始因为未考虑双向最短路而 WA 部分点，或者误判数据有问题进行特判，后来发现是题目条件理解不全面，需要分别以 1 和 n 为源点跑最短路。这提醒我们在做题时要仔细审题，全面考虑问题，不能轻易认为是数据问题。 

---
处理用时：39.65秒
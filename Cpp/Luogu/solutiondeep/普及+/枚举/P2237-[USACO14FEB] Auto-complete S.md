# 题目信息

# [USACO14FEB] Auto-complete S

## 题目描述

有 $w$ 个由小写字符构成的字典和 $n$ 个询问。每个询问由一个字符串 $s$ 和一个整数 $k$ 构成，求在字典序排序下字典内由 $s$ 为前缀的第 $k$ 字符串在输入字典的位置。若不存在，则输出 $-1$

## 说明/提示

对于 $100\%$ 的数据，$w \le 30000$，$1\le n \le 1000$，字典内每个字符串的长度均小于等于 $1000$，且字典的单词总长不超过 $10 ^ 6$。

样例解释：

对于第 $1$ 个询问，含义为在字典中找到以 ```a``` 为前缀且按字典序排序后第 $4$ 个字符串，而字典中以 ```a``` 为前缀且按字典序排序后为 $\{$  ```aa```，```aaa```，```aab```，```ab```，```abc```，```ac``` $\}$，第 $4$ 个是 ```ab```，其在输入中为第 $3$ 个，故输出为 $3$

同理，对于第 $2$ 个和第 $3$ 个询问是在字典中找到以 ```da``` 为前缀且按字典序排序后的第 $2$ 和第 $4$ 个字符串。而以 ```da``` 为前缀的字符串按字典序排序后为 $\{$```daa```，```dab```，```dadba``` $\}$，故第 $2$ 个为 ```dab``` ，其在输入中为第 $1$ 个，故第 $2$ 个输出为 $1$，而该序列中没有第 $4$ 个，故第 $3$ 个询问无解，输出 $-1$

来源：USACO 2014 Feburary Contest Silver

翻译：@[zymooll](/user/289296)

## 样例 #1

### 输入

```
10 3
dab
ba
ab
daa
aa
aaa
aab
abc
ac
dadba
4 a
2 da
4 da```

### 输出

```
3
1
-1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕排序和查找展开，核心是先对字典进行排序，再根据询问查找以给定字符串为前缀的第 $k$ 个字符串在原字典中的位置。各题解使用的算法有暴力法、二分查找、字典树等。暴力法简单但效率低，二分查找和字典树效率较高。

### 所选题解
- **作者：Expecto (赞：11)，4星**
  - **关键亮点**：思路简洁，利用 `lower_bound` 快速定位前缀位置，代码可读性高。
  - **个人心得**：无

### 重点代码
```cpp
#include<bits/stdc++.h>
using namespace std;
pair<string ,int> a[90030];
bool match(string x,string y){
    if (y.length()>x.length()) return 0;
    return x.substr(0,y.size())==y;
}
int main(){
    int w,n;
    cin>>w>>n;
    for (int i=0;i<w;i++){
        cin>>a[i].first;
        a[i].second=i;
    }
    sort(a,a+w);
    while (n--){
        string pre;
        int k;
        cin>>k>>pre;
        int pos=k-1+lower_bound(a,a+w,make_pair(pre,0))-a;
        if (pos>=w || !match(a[pos].first,pre)) {
            cout<<"-1\n";
            continue;
        }
        cout<<a[pos].second+1<<'\n';
    }
    return 0;
}
```
**核心实现思想**：先将字典中的字符串及其原始位置存储在 `pair` 数组中并排序，对于每个询问，使用 `lower_bound` 找到以询问字符串为前缀的第一个字符串的位置，加上 $k - 1$ 得到目标位置，最后检查该位置是否合法及是否满足前缀条件。

### 最优关键思路或技巧
- **排序**：对字典中的字符串按字典序排序，使前缀相同的字符串相邻，便于后续查找。
- **二分查找**：使用 `lower_bound` 或手动实现二分查找，快速定位前缀的起始位置，将查找复杂度从 $O(n)$ 降低到 $O(log n)$。
- **字典树**：对于前缀相关的问题，字典树是一种高效的数据结构，可在 $O(|s|)$ 时间内完成插入和查找操作。

### 可拓展之处
同类型题如字符串匹配、前缀查询等，可使用类似的排序、二分查找或字典树算法。例如，给定一组字符串，查询以某个前缀开头的所有字符串；或者在大量字符串中查找某个字符串的所有前缀。

### 推荐题目
- [P1481 魔族密码](https://www.luogu.com.cn/problem/P1481)：涉及字符串前缀和字典树的应用。
- [P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)：典型的字典树应用，用于字符串的插入和查找。
- [P3879 [TJOI2010] 阅读理解](https://www.luogu.com.cn/problem/P3879)：需要对多个字符串进行前缀查询，可使用字典树或排序二分的方法。

### 个人心得摘录与总结
- **一只野生蒟蒻**：原使用 `substr` 在洛谷能过，但在其他 OJ 超时，后改用逐个字符比较通过所有点。总结：不同 OJ 对代码性能要求不同，对于字符串比较，逐个字符比较可能比 `substr` 更高效。
- **Hexarhy**：暴力法在未开 O2 时超时，开 O2 后能 AC，体现了编译器优化对代码性能的影响。总结：在某些情况下，编译器优化可显著提升代码性能，但在竞赛中应优先考虑算法优化。 

---
处理用时：31.54秒
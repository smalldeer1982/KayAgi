# 题目信息

# [NOIP 2015 提高组] 子串

## 题目背景

NOIP2015 Day2T2

## 题目描述

有两个仅包含小写英文字母的字符串 $A$ 和 $B$。

现在要从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 $B$ 相等？

注意：子串取出的位置不同也认为是不同的方案。

## 说明/提示

**样例解释**

所有合法方案如下：（加下划线的部分表示取出的字串）

样例 1：$\texttt{\underline{aab}\,aab,aab\,\underline{aab}}$。  
样例 2：$\texttt{\underline{a}\,\underline{ab}\,aab,\underline{a}\,aba\,\underline{ab},a\,\underline{a}\,ba\,\underline{ab},aab\,\underline{a}\,\underline{ab},\underline{aa}\,\underline{b}\,aab,\underline{aa}\,baa\,\underline{b},aab\,\underline{aa}\,\underline{b}}$。  
样例 3：$\texttt{\underline{a}\,\underline{a}\,\underline{b}\,aab,\underline{a}\,\underline{a}\,baa\,\underline{b},\underline{a}\,ab\,\underline{a}\,a\,\underline{b},\underline{a}\,aba\,\underline{a}\,\underline{b},a\,\underline{a}\,b\,\underline{a}\,a\,\underline{b},a\,\underline{a}\,ba\,\underline{a}\,\underline{b},aab\,\underline{a}\,\underline{a}\,\underline{b}}$。

**数据范围**

对于第 1 组数据：$1≤n≤500,1≤m≤50,k=1$;  
对于第 2 组至第 3 组数据：$1≤n≤500,1≤m≤50,k=2$;   
对于第 4 组至第 5 组数据：$1≤n≤500,1≤m≤50,k=m$;   
对于第 1 组至第 7 组数据：$1≤n≤500,1≤m≤50,1≤k≤m$;  
对于第 1 组至第 9 组数据：$1≤n≤1000,1≤m≤100,1≤k≤m$;   
对于所有 10 组数据：$1≤n≤1000,1≤m≤200,1≤k≤m$。  


## 样例 #1

### 输入

```
6 3 1 
aabaab 
aab```

### 输出

```
2```

## 样例 #2

### 输入

```
6 3 2 
aabaab 
aab```

### 输出

```
7```

## 样例 #3

### 输入

```
6 3 3 
aabaab 
aab```

### 输出

```
7```

# AI分析结果

### 综合分析与结论
这些题解均围绕动态规划解决从字符串 $A$ 取 $k$ 个不重叠子串拼接成字符串 $B$ 的方案数问题。多数题解状态设计类似，通过记录 $A$、$B$ 串匹配位置、子串数量及是否选取当前字符来构建状态，再依据字符是否相等分类讨论转移方程。部分题解还涉及时间和空间复杂度优化，如前缀和优化、滚动数组优化等。

### 所选题解
- **作者：frankchenfu (赞：398)  ★★★★**
  - **关键亮点**：思路清晰，详细阐述状态设计、转移过程及空间优化思路，代码注释简洁明了。
  - **核心代码**：
```cpp
#include<cstdio>
#include<cstring>
const int MAXN=1010;
const int MAXM=210;
const int MOD=(int)(1e9)+7;
int f[2][MAXM][MAXM][2];
char a[MAXN],b[MAXM];
int n,m,k;bool val=1;

void dp(){
    f[0][0][0][0]=f[1][0][0][0]=1;
    for(int i=1;i<=n;i++,val^=1)
        for(int j=1;j<=m;j++)
            for(int p=1;p<=k;p++){
                if(a[i]==b[j]){
                    f[val][j][p][0]=(f[val^1][j][p][0]+f[val^1][j][p][1])%MOD;
                    f[val][j][p][1]=(f[val^1][j-1][p][1]+\
                                    (f[val^1][j-1][p-1][0]+f[val^1][j-1][p-1][1])%MOD)%MOD;
                }
                else{
                    f[val][j][p][0]=(f[val^1][j][p][0]+f[val^1][j][p][1])%MOD;
                    f[val][j][p][1]=0;
                }
            }
}

int main(){
    scanf("%d%d%d",&n,&m,&k);
    scanf("%s%s",a+1,b+1);
    dp();
    printf("%d\n",(f[n&1][m][k][0]+f[n&1][m][k][1])%MOD);
    return 0;
}
```
  - **核心实现思想**：`f[i][j][p][v]` 表示到 $a$ 串的第 $i$ 个位置为止使用 $p$ 个子串匹配 $b$ 串前 $j$ 位字符且第 $i$ 个位置选或不选（$v$）的方案数。根据 $a[i]$ 与 $b[j]$ 是否相等分类讨论转移方程，利用滚动数组优化空间。

- **作者：八重樱飞 (赞：164)  ★★★★**
  - **关键亮点**：从动态规划三要素详细讲解，对转移方程解释细致，适合新手理解。
  - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int md=1000000007;
int n,m,k,f[2][222][222][2];
char a[1001],b[201];
int main()
{
    int i,j,p;
    scanf("%d%d%d",&n,&m,&k);
    for(i=1;i<=n;i++)
        cin>>a[i];
    for(i=1;i<=m;i++)
        cin>>b[i];
    f[0][0][0][0]=1;
    f[1][0][0][0]=1;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            for(p=1;p<=k;p++)
            {
                if(a[i]==b[j])
                {
                    f[i%2][j][p][1]=(f[(i-1)%2][j-1][p][1]+f[(i-1)%2][j-1][p-1][0])%md+f[(i-1)%2][j-1][p-1][1]%md;
                    f[i%2][j][p][1]%=md;
                    f[i%2][j][p][0]=f[(i-1)%2][j][p][1]+f[(i-1)%2][j][p][0];
                    f[i%2][j][p][0]%=md;
                }
                else
                {
                    f[i%2][j][p][0]=f[(i-1)%2][j][p][1]+f[(i-1)%2][j][p][0];
                    f[i%2][j][p][0]%=md;
                    f[i%2][j][p][1]=0;
                 } 
            }
    printf("%d",(f[n%2][m][k][1]+f[n%2][m][k][0])%md);
    return 0;
}
```
  - **核心实现思想**：状态设计与上一题解类似，根据字符是否相等分类讨论转移方程，同样使用滚动数组优化空间。

- **作者：啊嘞嘞嘞嘞 (赞：161)  ★★★★**
  - **关键亮点**：先给出 70pts 做法，再逐步优化到 100pts，展示了优化思路，代码简洁。
  - **核心代码**：
```cpp
#include <cstdio>
#define MAXN 1010
#define MAXM 210
using namespace std;
const int MOD=1e9+7;
int n,m,k;
char a[MAXN],b[MAXM];
int f[MAXM][MAXM]; 
int g[MAXM][MAXM]; 
inline int min(int a,int b) { return a<b ? a : b; }
int main() {
    scanf("%d%d%d",&n,&m,&k);
    scanf("%s%s",a+1,b+1);
    g[0][0]=1;
    for (int i=1;i<=n;i++) {
        for (int j=min(m,i);j>=1;j--) {
            for (int p=min(k,j);p>=1;p--) {
                f[j][p]=a[i]==b[j] ? (f[j-1][p]+g[j-1][p-1])%MOD : 0;
                g[j][p]=(g[j][p]+f[j][p])%MOD;
            }
        }
    }
    printf("%d\n",g[m][k]);
    return 0;
}
```
  - **核心实现思想**：$f[i][j][p]$ 表示 $A$ 到 $i$，$B$ 用完了前 $j$ 个，分成了 $p$ 段，并且 $A_i$ 是最后一个匹配的字符。先通过枚举断点转移，再优化去掉枚举 $L$ 的过程，最后使用滚动数组优化空间。

### 最优关键思路或技巧
- **状态设计**：多数题解通过记录 $A$、$B$ 串匹配位置、子串数量及是否选取当前字符来设计状态，保证无后效性。
- **滚动数组优化**：由于转移只与前一个状态有关，通过滚动数组将空间复杂度从 $O(nmk)$ 优化到 $O(mk)$。
- **前缀和优化**：部分题解使用前缀和优化时间复杂度，减少不必要的枚举。

### 可拓展之处
同类型题多为字符串匹配与动态规划结合的问题，如求子序列匹配方案数、字符串编辑距离等。类似算法套路包括状态设计时考虑多维度信息，依据条件分类讨论转移方程，利用滚动数组、前缀和等优化时空复杂度。

### 推荐题目
- [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)：经典 01 背包问题，考察动态规划基础。
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：一维动态规划，求最大连续子段和。
- [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)：考察最长公共子序列的动态规划解法。

### 个人心得摘录与总结
- **作者：啊嘞嘞嘞嘞**：做这题一开始大部分时间做的都是无用功，选择一种合适的方法入手才相当于真正开始做这题，当然找对了切入点这题就一点不难。总结：做动态规划题时，找到合适的状态设计和转移方法是关键，不要盲目尝试。
- **作者：八重樱飞**：蒟蒻表示研究 DP 方程很久的说，尽管各位大佬都觉得此题 DP 方程很简单，但是可能也会有像我这样的蒟蒻看的不是很懂。总结：动态规划方程理解有难度，需要耐心研究，多分析不同情况。 

---
处理用时：62.41秒
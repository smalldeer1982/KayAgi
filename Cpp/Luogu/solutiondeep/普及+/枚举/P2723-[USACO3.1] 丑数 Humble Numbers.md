# 题目信息

# [USACO3.1] 丑数 Humble Numbers

## 题目描述

对于一给定的素数集合 $S = \{ p_1, p_2, ..., p_k \}$, 考虑一个正整数集合，该集合中任一元素的质因数全部属于 $S$。这个正整数集合包括，$p_1$、$p_1 \times p_2$、$p_1 \times p_1$、$p_1 \times p_2 \times p_3$ ...(还有其它)。该集合被称为 $S$ 集合的“丑数集合”。注意：我们认为 $1$不是一个丑数。

你的工作是对于输入的集合 $S$ 去寻找“丑数集合”中的第 $n$ 个“丑数”。保证答案可以用 32 位有符号整数表示。

补充：丑数集合中每个数从小到大排列，每个丑数都是素数集合中的数的乘积，第 $n$ 个“丑数”就是在能由素数集合中的数相乘得来的（包括它本身）第 $n$ 小的数。


## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq k \leq 100$。
- $1 \leq n \leq 10^5$。
- $2 \leq p_i < 2^{31}$，且 $p_i$ 一定为质数。

---
#### 说明

题目翻译来自 NOCOW。

USACO Training Section 3.1


## 样例 #1

### 输入

```
4 19
2 3 5 7```

### 输出

```
27```

# AI分析结果

### 综合分析与结论
这些题解围绕寻找给定素数集合的丑数集合中第 `n` 个丑数展开，采用了多种思路和算法。主要思路是利用丑数的生成规则，即丑数由之前的丑数乘以素数集合中的素数得到。算法实现上，有直接枚举、使用优先队列、集合、平衡树等数据结构，以及单调队列等方法。

解决的难点在于如何高效地生成丑数并避免重复计算，同时在给定的数据规模下保证时间和空间复杂度的合理性。部分题解通过记录指针、判重、剪枝等优化手段提高效率。

### 所选题解
- **作者：Mark_ZZY (赞：102)，4星**
  - **关键亮点**：思路清晰，代码简洁，通过枚举质数和丑数，利用指针记录每个质数当前乘的丑数位置，避免重复计算，时间复杂度较低。
  - **核心代码**：
```cpp
#include<cstdio>
int n,m;
int a[101],b[101];
int s[100001];
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    s[0]=1;
    for(int i=1;i<=m;i++)
    {
        int min=2147483647;
        for(int j=1;j<=n;j++)
        {
            while(a[j]*s[b[j]]<=s[i-1]) b[j]++;
            if(a[j]*s[b[j]]<min) min=a[j]*s[b[j]];
        }
        s[i]=min;
    }
    printf("%d",s[m]);
}
```
  - **核心实现思想**：用数组 `s` 存储丑数，`b` 数组记录每个质数当前乘的丑数位置。每次生成新丑数时，枚举质数，找到大于前一个丑数的最小乘积作为新丑数。

- **作者：Celebrate (赞：14)，4星**
  - **关键亮点**：先给出暴力解法，再逐步优化，通过记录指针避免重复查找，易于理解，优化思路清晰。
  - **核心代码（优化后）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[110],f[110000],bk[110];
int minn;
int main()
{
    int i,j,t;
    scanf("%d%d",&k,&n);
    for(i=1;i<=k;i++) scanf("%d",&a[i]);
    f[0]=1;
    for(i=1;i<=n;i++)
    {
        minn=2147483647;
        for(j=1;j<=k;j++)
        {
            while(a[j]*f[bk[j]]<=f[i-1]) bk[j]++;
            minn=min(minn,a[j]*f[bk[j]]);
        }
        f[i]=minn;
    }
    printf("%d\n",f[n]);
    return 0;
}
```
  - **核心实现思想**：与 Mark_ZZY 的思路类似，用 `bk` 数组记录每个质数满足条件的最小丑数位置，避免每次从头查找。

- **作者：Ikari_Shinji (赞：5)，4星**
  - **关键亮点**：通过指针数组记录每个素数当前最大倍数的丑数下标，简洁地实现丑数的生成，代码逻辑清晰。
  - **核心代码**：
```cpp
#include <cstdio>
#include <cstring>
#define ll long long
#define min(a,b) (a<b?a:b)

const int N=100005;
ll a[N],k,n,p[105],s[105],num;
int main(){
    scanf("%lld %lld",&k,&n);
    a[0]=1;
    memset(p,0,sizeof(p));
    for(int i=1;i<=k;i++){
        scanf("%lld",&s[i]);
    }
    for(int i=1;i<=n;i++){
        num=2147483647;
        for(int j=1;j<=k;j++){
            num=min(num,a[p[j]]*s[j]);
        }
        a[i]=num;
        for(int j=1;j<=k;j++){
            if(num==a[p[j]]*s[j])
                p[j]++;
        }
    }
    printf("%lld\n",a[n]);
    return 0;
}
```
  - **核心实现思想**：用 `p` 数组记录每个素数当前最大倍数的丑数下标，每次找到最小乘积作为新丑数，更新相应指针。

### 最优关键思路或技巧
- **指针记录**：通过记录每个质数当前乘的丑数位置，避免每次从头枚举丑数，利用丑数的单调性，减少不必要的计算。
- **判重**：使用集合、标记等方法避免重复计算丑数，减少时间和空间开销。
- **剪枝优化**：当生成的丑数超过所需范围或不可能成为最终答案时，及时停止计算，提高效率。

### 可拓展之处
同类型题如求超级丑数、特定规则下的第 `n` 个数等。类似算法套路可用于处理具有递推关系的序列生成问题，通过记录关键信息避免重复计算，利用数据结构（优先队列、集合、平衡树等）优化查找和排序操作。

### 推荐洛谷题目
- P1323 删数问题
- P1020 导弹拦截
- P1090 合并果子

### 个人心得摘录与总结
- **Mizuhara**：最初用优先队列生成丑数，但生成过多丑数导致接近时限。后来发现找最小新丑数的单调性，使用第二个单调性解决了问题，强调了发现和利用单调性优化算法的重要性。
- **狂犇**：尝试用 BFS+Treap、STL 的 priority_queue 解题，遇到内存不足的问题，提示在解题时要考虑数据规模和空间复杂度。
- **msy66**：用堆维护丑数时因重复元素消耗资源，改用 set 并进行优化，体现了根据数据特点选择合适数据结构的重要性。 

---
处理用时：46.37秒
# 题目信息

# [USACO06NOV] Big Square S

## 题目背景

[English version](https://www.luogu.com.cn/paste/x781adew)

## 题目描述

农民 John 的牛参加了一次和农民 Bob 的牛的竞赛。他们在区域中画了一个$N\times N$ 的正方形点阵，两个农场的牛各自占据了一些点。当然不能有两头牛处于同一个点。农场的目标是用自己的牛作为$4$个顶点，形成一个面积最大的正方形 （不必须和边界平行） 。 除了 Bessie 以外，John其他的牛都已经放到点阵中去了，要确定Bessie放在哪个位置，能使得John的农场得到一个最大的正方形(Bessie不是必须参与作为正方形的四个顶点之一)。

## 样例 #1

### 输入

```
6
J*J***
******
J***J*
******
**B***
******```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是通过枚举来寻找最大正方形，由于数据范围较小（$N\leq100$），暴力枚举是可行的。不同题解的区别在于枚举的方式和计算另外两个顶点坐标的方法。有的题解枚举正方形的对角线，有的枚举同一条边的两个顶点。在计算另外两个顶点坐标时，主要利用几何关系和向量知识。

### 所选题解
- 作者：_____hzf_____ (赞：22)，4星
  - 关键亮点：思路清晰，通过图示详细说明了以对角线枚举正方形的方法，代码注释详细，易于理解。
  - 个人心得：无
- 作者：tzyt (赞：1)，4星
  - 关键亮点：不仅给出了完整的解题思路和代码，还分享了调试过程和优化思路，具有学习价值。
  - 个人心得：第一次尝试代码有两个点超时，通过分析发现存在重复枚举和无用计算的问题，将判断条件改为 `if ((p1.x == p2.x && p1.y == p2.y) || (p1.y < p2.y) || (((p1.y - p2.y) * (p1.y - p2.y) + (p1.x - p2.x) * (p1.x - p2.x)) <= ans))` 减少了计算量，最终AC。

### 重点代码
#### _____hzf_____ 的核心代码
```c
F(i,1,n)/*枚举右下的点的横坐标*/
    F(j,1,n)/*枚举右下的点的纵坐标*/
        F(k,1,i)/*枚举左上的点的横坐标*/
            F(tt,1,j){/*枚举左上的点的纵坐标*/
                if(a[i][j]=='B'||a[k][tt]=='B')/*如果有Bob的牛就continue*/
                    continue;
                int Sum=max(i-k,j-tt),Minus=min(i-k,j-tt);
                if((Sum&1)!=(Minus&1))/*细节！判断奇偶性是否相同*/ 
                    continue;
                int px=solve(Sum,Minus,'+'),py=solve(Sum,Minus,'-');/*计算出两式和与差*/
                int p=k+px,q1=tt+py,u=i-px,v=j-py;/*得出剩下两点*/
                if(((p-u)*(p-u)+(q1-v)*(q1-v))!=(Sum*Sum+Minus*Minus))/*考虑轴对称的情况*/
                    p=k+py,q1=tt+px,u=i-py,v=j-px;
                if(p>=1&&q1>=1&&u>=1&&v>=1&&p<=n&&q1<=n&&u<=n&&v<=n)
                    if(a[i][j]!='B'&&a[k][tt]!='B'&&a[p][q1]!='B'&&a[u][v]!='B'){
                        s=0;
                        if(a[i][j]=='J')
                            s++;
                        if(a[k][tt]=='J')
                            s++;
                        if(a[p][q1]=='J')
                            s++;
                        if(a[u][v]=='J')
                            s++;
                        if(s>=3&&px*px+py*py>ans){
                            ans=px*px+py*py;
                            a1=i;a2=j;a3=u;a4=v;
                            a5=k;a6=tt;a7=p;a8=q1;
                        }
                    }
            }
```
核心实现思想：通过四重循环枚举正方形的对角线的两个顶点，根据几何关系计算出另外两个顶点的坐标，判断顶点是否在地图内且不被Bob的牛占据，统计顶点中John的牛的数量，若数量大于等于3且面积大于当前最大面积，则更新最大面积。

#### tzyt 的核心代码
```cpp
for (auto p1 : jc)
{
    for (auto p2 : jc)//通过枚举两个点来实现对于边的枚举
    {
        if ((p1.x == p2.x && p1.y == p2.y) || (p1.y < p2.y) || (((p1.y - p2.y) * (p1.y - p2.y) + (p1.x - p2.x) * (p1.x - p2.x)) <= ans))
        {
            continue;
        }
        //通过一条边确定的第一种正方形
        node p3;
        p3.x = (p2.x + (p1.y - p2.y));
        p3.y = (p2.y - (p1.x - p2.x));
        node p4;
        p4.x = (p1.x + (p1.y - p2.y));
        p4.y = (p1.y - (p1.x - p2.x));
        if (p3.x >= 0 && p3.y >= 0 && p4.x >= 0 && p4.y >= 0 && p3.x < n && p3.y < n && p4.x < n && p4.y < n)//判断合法性
        {
            if ((mp[p3.x][p3.y] == 1 && mp[p4.x][p4.y] != -1) || (mp[p3.x][p3.y] != -1 && mp[p4.x][p4.y] == 1))
            {
                ans = max(ans, (p1.y - p2.y) * (p1.y - p2.y) + (p1.x - p2.x) * (p1.x - p2.x));
            }
        }
        //通过一条边确定的第二种正方形
        p3.x = (p2.x - (p1.y - p2.y));
        p3.y = (p2.y + (p1.x - p2.x));
        p4.x = (p1.x - (p1.y - p2.y));
        p4.y = (p1.y + (p1.x - p2.x));
        if (p3.x >= 0 && p3.y >= 0 && p4.x >= 0 && p4.y >= 0 && p3.x < n && p3.y < n && p4.x < n && p4.y < n)//判断合法性
        {
            if ((mp[p3.x][p3.y] == 1 && mp[p4.x][p4.y] != -1) || (mp[p3.x][p3.y] != -1 && mp[p4.x][p4.y] == 1))
            {
                ans = max(ans, (p1.y - p2.y) * (p1.y - p2.y) + (p1.x - p2.x) * (p1.x - p2.x));
            }
        }
    }
}
```
核心实现思想：通过两层循环枚举正方形同一条边的两个顶点，根据几何关系计算出另外两个顶点的坐标，判断顶点是否在地图内且不被Bob的牛占据，若满足条件且面积大于当前最大面积，则更新最大面积。同时通过优化判断条件减少了重复计算和无用计算。

### 最优关键思路或技巧
- **枚举方式**：枚举正方形的对角线或同一条边的两个顶点，可确定整个正方形。
- **坐标计算**：利用几何关系（全等三角形、向量等）计算另外两个顶点的坐标。
- **优化技巧**：在枚举过程中，通过判断面积是否小于当前最大面积、避免重复枚举等方式减少计算量。

### 可拓展之处
同类型题：在网格中寻找满足特定条件的几何图形（如矩形、菱形等），可采用类似的枚举和坐标计算方法。

### 推荐题目
- P1387 最大正方形：在一个由 0 和 1 组成的矩阵中，找出只包含 1 的最大正方形。
- P2730 [USACO3.2] 魔板 Magic Squares：通过操作魔板，使其达到目标状态，可使用广度优先搜索。
- P1002 [NOIP2002 普及组] 过河卒：在棋盘上，卒从起点走到终点，计算不同走法的数量，可使用动态规划。

---
处理用时：54.34秒
# 题目信息

# [USACO10JAN] Cheese Towers S

## 题目描述

FJ 要建一个奶酪塔，高度最大为 $T\ (1 \le T \le 10^3)$ 。他有 $N\ (1 \le N \le 10^2)$ 种奶酪。第 $i$ 种奶酪的高度为 $H_i\ (5\le H_i \le T\text{ 且 }5 \mid H_i)$ ，价值为 $V_i\ (1 \le V_i \le 10^6)$ 。一块高度 $H_i\ge K\ (1 \le K \le T)$ 的奶酪被称为大奶酪，如果一个奶酪上方有大奶酪（如果有多块就只算一次），这个奶酪的高度 $H_i$ 就会变成原来的 $\frac{4}{5}$。FJ 想让他的奶酪塔价值和最大。请你求出这个最大值。

例如，考虑一种奶酪塔，其最大高度可以是 $53$，可以用三种类型的奶酪块建造。大块是大于或等于 $25$ 的块。下面是他堆叠的各种奶酪块的值和高度的图表：

|类型|价值|高度|
| :----------: | :----------: | :----------: |
|1|100|25|
|2|20|5|
|3|40|10|

FJ建造了以下奶酪塔：

|类型|价值|高度|
| :----------: | :----------: | :----------: |
|1|100|25|
|2|20|4|
|3|40|8|
|3|40|8|
|3|40|8|

总高度是 $25 + 4 + 8 + 8 + 8 = 53$，除塔顶奶酪外，其余高度均被压低。总价值是 $100 + 20 + 40 + 40 + 40 = 240$。

## 样例 #1

### 输入

```
3 53 25 
100 25 
20 5 
40 10 
```

### 输出

```
240 
```

# AI分析结果

### 综合分析与结论
本题核心是在完全背包基础上，处理大奶酪对下方奶酪高度的压缩问题。多数题解思路类似，先明确最优解仅两种情况：无大奶酪或最顶端为大奶酪。对于无大奶酪情况，直接用完全背包求解；对于顶端为大奶酪情况，枚举大奶酪并结合完全背包结果更新答案。

### 所选题解
- **作者：reek（5星）**
    - **关键亮点**：思路清晰简洁，代码精炼，准确把握问题本质，直接点明两种最优情况并给出对应解法。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,T,k,ans,f[2000],v[1000],h[1000];
int main() {
    scanf("%d%d%d",&n,&T,&k);
    for (int i=1;i<=n;i++) {
        scanf("%d%d",&v[i],&h[i]);
        for (int j=h[i];j<=T*5/4;j++)
            f[j]=max(f[j],f[j-h[i]]+v[i]);
    }
    ans=f[T];
    for (int i=1;i<=n;i++)
        if (h[i]>=k) ans=max(ans,f[(T-h[i])*5/4]+v[i]);
    printf("%d\n",ans);
    return 0;
}
```
    - **核心思想**：先对所有奶酪做一次完全背包，背包容量扩展到 `T * 5 / 4` ，以应对有大奶酪时下方奶酪高度压缩的情况。然后将无大奶酪时的最大价值 `f[T]` 赋给 `ans` ，再枚举大奶酪，用 `f[(T - h[i]) * 5 / 4] + v[i]` 更新 `ans` ，最后输出 `ans` 。

- **作者：Cxs3（4星）**
    - **关键亮点**：详细解释思路，对每种情况的处理和细节都有清晰说明，有助于理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
const int N=100+10;
const int T=5000;
using namespace std;

int n,t,k,ans;
int v[N],h[N],f[T];

int main()
{
    int i,j,now;
    cin>>n>>t>>k;
    for(i=1;i<=n;i++) cin>>v[i]>>h[i];
    for(i=1;i<=n;i++)
        for(j=h[i];j<=t*5/4;j++) f[j]=max(f[j],f[j-h[i]]+v[i]);//完全背包 
    ans=f[t];//ans初始化为f[t] 
    for(i=1;i<=n;i++)
    {
        if(h[i]<k) continue;//不是大奶酪就不做 
        now=v[i]+f[(t-h[i])*5/4];//用now求当前答案 
        ans=max(ans,now);//更新 
    }
    cout<<ans<<endl;
    return 0;
}
```
    - **核心思想**：先读入数据，接着进行完全背包，背包容量同样扩展到 `t * 5 / 4` 。将无大奶酪时的最大价值 `f[t]` 赋给 `ans` ，然后枚举大奶酪，计算 `v[i] + f[(t - h[i]) * 5 / 4]` 并更新 `ans` ，最后输出结果。

- **作者：linyinuo2008（4星）**
    - **关键亮点**：详细讲解题意和算法实现步骤，代码有注释，适合初学者理解。
    - **核心代码**：
```cpp
#include <iostream>
using namespace std;

const int NR=105;
const int MR=1400;//最大容量必须开到5/4倍
int n,t,k;
int v[NR],h[NR],ans;
int f[MR];

int max(int a,int b)//手写max更快
{
    return a>b?a:b;
}

int main()
{
    f[0]=0;
    cin>>n>>t>>k;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>h[i];
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];j<=t*5/4;j++)//枚举到容量的5/4倍
        {
            f[j]=max(f[j],f[j-h[i]]+v[i]);//上一边完全背包
        }
    }
    ans=f[t];//先把ans设为f[t]
    for(int i=1;i<=n;i++)
    {
        if(h[i]>=k)//如果它是块大奶酪
            ans=max(ans,f[(t-h[i])*5/4]+v[i]);//那么尝试把它放在最顶上
    }
    cout<<ans;//输出
    return 0;
}
```
    - **核心思想**：先初始化 `f[0] = 0` ，读入数据后进行完全背包，背包容量扩展到 `t * 5 / 4` 。将无大奶酪时的最大价值 `f[t]` 赋给 `ans` ，枚举大奶酪，用 `f[(t - h[i]) * 5 / 4] + v[i]` 更新 `ans` ，最后输出结果。

### 最优关键思路或技巧
- **贪心思想**：通过分析得出最优解只有无大奶酪或最顶端为大奶酪两种情况，简化问题。
- **背包容量扩展**：将背包容量扩展到 `T * 5 / 4` ，方便处理有大奶酪时下方奶酪高度压缩的情况。

### 可拓展之处
同类型题可拓展到其他有条件限制的背包问题，如某些物品会影响其他物品的属性（重量、价值等）。类似算法套路可用于处理有特殊条件的动态规划问题，关键在于分析特殊条件对状态转移的影响，合理划分情况并设计状态转移方程。

### 推荐题目
- P1616 疯狂的采药（完全背包模板题）
- P1833 樱花（混合背包问题）
- P2722 [USACO3.1] 总分 Score Inflation（完全背包问题）

### 个人心得摘录与总结
- **MilkyCoffee**：
    - **摘录**：“计算完无大奶酪之后要保存答案！不要忘了有大奶酪的情况是 `dp[j - h[i] / 5 * 4 + v[i]` ！不要忘了乘五分之四！最后有大奶酪的答案是算出来的答案是要减去大奶酪的高度再加上大奶酪的价值的！不是直接的 `dp[t]` ！”
    - **总结**：强调在处理本题时，要注意保存无大奶酪时的答案，处理有大奶酪情况时要正确考虑奶酪高度压缩，以及最终答案的计算方式。
- **Kirisame_Marisa_**：
    - **摘录**：“就算之前的奶酪被我们枚举的奶酪压扁了，那么我们在最后的循环中枚举的时候，之前放置的所有奶酪都会被压扁。这时候已经将之前没有做的事（压扁）一起做完了。如果我们在最后枚举的时候，除去当前的大奶酪，我们剩下奶酪的总体积不就是 `T - h[i]` 吗？很遗憾这是错误的，因为此时的 `T - h[i]` 应当是目前剩下的奶酪被压缩之后的总体积。它们的原始体积应当乘以 `5 / 4` （因为你压缩的时候乘了 `4 / 5` ）。最坏情况下，乘法的结果会接近 `5 / 4 * T` （ `h[i] = 1` 时），如果你只处理到了 `T` ，那么恭喜 `63pts` 。”
    - **总结**：解释了完全背包时不判大奶酪和将背包容量扩展到 `5 / 4 * T` 的原因，提醒要正确处理奶酪高度压缩问题，否则会导致答案错误。 

---
处理用时：48.97秒
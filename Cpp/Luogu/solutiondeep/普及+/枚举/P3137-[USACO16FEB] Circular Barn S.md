# 题目信息

# [USACO16FEB] Circular Barn S

## 题目背景

*本题与 [金组同名题目](/problem/P6170) 在题意上一致，唯一的差别是数据范围。*

## 题目描述

作为当代建筑的爱好者，Farmer John 建造了一个圆形新谷仓，谷仓内部 $n$ 个房间排成环形（$3 \leq n \leq 1000$），按顺时针顺序编号为 $1\ldots n$，每个房间都有通往与其相邻的左右房间的门，还有一扇门通往外面。

现在 FJ 有 $n$ 头奶牛，他的目标是让每个房间恰好有一头奶牛。然而不幸的是，现在奶牛们随意呆在某个房间里，第 $i$ 个房间里有 $c_i$ 头奶牛。保证 $\sum c_i =n$。

FJ 决定采用这样的方法来解决这个问题：让某些奶牛**顺时针**穿过某些房间到达指定的位置。如果一头奶牛穿过了 $d$ 扇门，他消耗的能量为 $d^2$。你需要帮 FJ 算出所有奶牛消耗的能量和最小值是多少。

## 样例 #1

### 输入

```
10
1
0
0
2
0
0
1
2
2
2```

### 输出

```
33```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何让奶牛按顺时针移动，使每个房间恰好有一头奶牛并计算最小能量消耗展开。思路大致可分为暴力枚举起点模拟移动过程、利用性质优化起点选择、将环转化为链处理等几类。

暴力枚举类通过枚举所有可能的起点，模拟奶牛移动来计算能量和，时间复杂度较高；优化起点选择类则通过最大子段和等方法确定较优起点，减少不必要的枚举；环转链类将环形结构转化为链式结构方便处理。

各题解在思路清晰度、代码可读性和优化程度上有所差异。部分题解思路清晰但代码复杂，部分题解代码简洁但思路阐述不够详细。

### 所选题解
- **Zelotz（4星）**
    - **关键亮点**：思路清晰，先阐述基础的枚举起点模拟移动的方法，再对加强数据进行优化，通过最大子段和确定起点，给出了详细的证明和分类讨论。
    - **个人心得**：作者提到自己写得不好希望被指出，还表示对最大子段和的证明感觉自己很菜，体现了谦虚的学习态度。
- **Orion_Rigel（4星）**
    - **关键亮点**：思路简洁巧妙，通过对奶牛初始位置排序，确定最终位置，避免了复杂的模拟过程，代码实现简单。
    - **个人心得**：无
- **Vin_1999（4星）**
    - **关键亮点**：对 Orion_Rigel 的代码进行详细注释和思路解读，帮助读者更好理解，对逆差等关键概念解释清晰。
    - **个人心得**：作者表示想了一天才理解 Orion_Rigel 的代码，说明该题有一定难度，同时也体现了深入思考的过程。

### 重点代码及核心思想
#### Zelotz
```cpp
// 枚举起点模拟移动
for (int start = 1; start <= n; ++start) {
    for (int now = start; ; ++now) {
        if (now > n) now %= n;
        if (now == start && flg == 0) break;
        if (a[now].empty()) continue;
        flg = 0;
        int sz = a[now].size();
        int p = now + 1;
        if (p > n) p %= n;
        for (int i = 0; i < sz - 1; ++i) {
            a[p].push_back(a[now][i]);
            d[a[now][i]]++;
        }
        int endnum = a[now][sz - 1];
        a[now].clear();
        a[now].push_back(endnum);
    }
    // 计算能量和
    for (int i = 1; i <= n; ++i) {
        if (a[i].size() != 1) { ans = -1; break; } 
        ans += d[i] * d[i]; 
    }
    if (ans ^ -1) result = min(result, ans);
    // 还原数据
    msz(d); msz(vis); ans = 0;
    for (int i = 1; i <= n; ++i) a[i].clear();
    for (int i = 1; i <= n; ++i)
        for (int j = 0; j < (int)b[i].size(); ++j)
            a[i].push_back(b[i][j]); 
}
```
核心思想：枚举所有可能的起点，模拟奶牛从起点开始的移动过程，将多余的奶牛依次移动到下一个房间，最后计算能量和并取最小值。

#### Orion_Rigel
```cpp
// 读取奶牛初始位置
for (int i = 0; i < n; ++i) {
    scanf("%d", &x);
    while (x) {
        a[cnt++] = i;
        x--;
    }
}
// 计算逆差
for (int i = 0; i < n; ++i) b[i] = a[i] - i;
// 找到逆差最大的位置
for (int i = 0; i < n; ++i)
    if (b[i] > maxx) maxx = b[i], p = i;
// 确定最终位置
c[p] = a[p];
for (int i = p - 1; i >= 0; --i)
    c[i] = c[i + 1] - 1, c[i] %= n;
for (int i = p + 1; i < n; ++i)
    c[i] = c[i - 1] + 1, c[i] %= n;
// 计算能量和
for (int i = 0; i < n; ++i) {
    if (c[i] < a[i]) c[i] += n;
    ans += ((ll)c[i] - a[i]) * ((ll)c[i] - a[i]);
}
```
核心思想：对奶牛初始位置排序，计算逆差，找到逆差最大的位置确定为不动的奶牛，然后依次确定其他奶牛的最终位置，最后计算能量和。

#### Vin_1999
```cpp
// 读取奶牛初始位置
for (int i = 0; i < n; ++i) {
    scanf("%d", &x);
    while (x) {
        a[cnt++] = i;
        x--;
    }
}
// 计算逆差
for (int i = 0; i < n; ++i) b[i] = a[i] - i;
// 找到逆差最大的位置
for (int i = 0; i < n; ++i)
    if (b[i] > maxx) maxx = b[i], p = i;
// 确定最终位置
c[p] = a[p];
for (int i = p - 1; i >= 0; --i)
    c[i] = c[i + 1] - 1, c[i] %= n;
for (int i = p + 1; i < n; ++i)
    c[i] = c[i - 1] + 1, c[i] %= n;
// 计算能量和
for (int i = 0; i < n; ++i) {
    if (c[i] < a[i]) c[i] += n;
    ans += ((ll)c[i] - a[i]) * ((ll)c[i] - a[i]);
}
```
核心思想：与 Orion_Rigel 类似，通过对奶牛初始位置排序和计算逆差确定最终位置，计算能量和。

### 最优关键思路或技巧
- **利用性质优化**：如 Orion_Rigel 和 Vin_1999 利用奶牛移动路径不交叉的性质，通过排序和计算逆差确定最终位置，减少了模拟过程。
- **最大子段和确定起点**：Zelotz 利用最大子段和确定较优起点，避免了不必要的枚举，优化了时间复杂度。

### 可拓展之处
同类型题如环形的资源分配问题，可将环形结构转化为链式结构处理，利用贪心、动态规划等算法求解。类似算法套路包括破环为链、枚举起点、利用性质优化等。

### 推荐题目
- P1880 [NOI1995] 石子合并
- P2672 [NOIP2015 普及组] 推销员
- P1063 [NOIP2006 提高组] 能量项链

---
处理用时：49.63秒
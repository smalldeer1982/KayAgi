# 题目信息

# [USACO17JAN] Balanced Photo G

## 题目描述

FJ 正在安排他的 $N$ 头奶牛站成一排来拍照（$1\le N \le 10^5$）。序列中的第 $i$ 头奶牛的高度是 $h_i$，且序列中所有的奶牛的身高都不同。

就像他的所有牛的照片一样，FJ希望这张照片看上去尽可能好。他认为，如果 $L_i$ 和 $R_i$ 的数目相差 $1$ 倍以上，第 $i$ 头奶牛就是不平衡的（$L_i$ 和 $R_i$ 分别代表第 $i$ 头奶牛左右两边比她高的奶牛的数量）。也就是说，如果 $L_i$ 和 $R_i$ 中的较大数大于较小数的 $2$ 倍，第 $i$ 头奶牛就是不平衡的。FJ 不希望他有太多的奶牛不平衡。

请帮助 FJ 计算不平衡的奶牛数量。

## 样例 #1

### 输入

```
7
34
6
23
0
5
99
2```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
本题的核心在于计算每头奶牛左右两边比其高的奶牛数量，判断是否不平衡并统计不平衡奶牛的数量。各题解主要围绕暴力枚举和使用数据结构优化展开。暴力枚举复杂度高，会超时；使用树状数组、主席树、平衡树等数据结构可将复杂度优化到 $O(nlogn)$ 。

### 所选题解
- **作者：nihanchu (赞：19)，4星**
  - **关键亮点**：思路清晰，详细解释了使用树状数组优化的过程，代码注释丰富，易于理解。
  - **个人心得**：作者表示是翻译官网题解后弄懂题目，讲解可能繁琐或有错误请见谅，体现了学习和分享的认真态度。
- **作者：小蒟蒻皮皮鱼 (赞：13)，4星**
  - **关键亮点**：明确指出题目翻译可能存在的问题，对思路的阐述简洁明了，代码简洁。
  - **个人心得**：无。
- **作者：曹老师 (赞：3)，4星**
  - **关键亮点**：点明知识点为 BIT 求逆序对，时间复杂度分析准确，代码规范。
  - **个人心得**：无。

### 重点代码
#### nihanchu 的题解
```cpp
// 单点更新
void update(int x,int v)
{
    while (x<=n)
    {
        f[x]+=v;
        x+=lowbit(x);
    }
}
// 查询前缀和
int query(int x)
{
    int sum=0;
    while (x>0) 
    {
      sum+=f[x];
      x-=lowbit(x);
    }
    return sum;
}
int main()
{
  scanf("%d",&n);
  for (int i=1;i<=n;i++) 
  {
       a[i].v=read();// 输入奶牛的身高
    a[i].t=i;// 奶牛在原序列中的编号    
  }
  sort(a+1,a+1+n,cmp);// 身高从大到小排序
  for (int i=1;i<=n;i++) b[a[i].t]=i;// 记录这头奶牛在排序后的编号
  for (int i=1;i<=n;i++)
  {
      l=query(b[i]);// 查询左边比它大的奶牛数量
      r=b[i]-l-1;// 右边比它大的数量
      if ((l*2<r)||(r*2<l)) ans++;// 记录不平衡数量
      update(b[i],1);// 更新，这头奶牛已经被枚举过了
  }
  printf("%d\n",ans);
  return 0;
}
```
**核心实现思想**：先将奶牛按身高从大到小排序，用树状数组维护每个奶牛是否被枚举过。枚举奶牛时，通过查询前缀和得到左边比它高的奶牛数量，进而算出右边比它高的奶牛数量，判断是否不平衡并更新树状数组。

#### 小蒟蒻皮皮鱼的题解
```cpp
int lowbit(int x) {return x & -x;}
void Add(int x, int k){for(; x <= n; x += lowbit(x)) iSum[x] += k;}
int Query(int x){int ans = 0;for(; x; x -= lowbit(x)) ans += iSum[x];return ans;}
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) scanf("%d", &Cow[i].iH), Cow[i].iBh = i;
	sort(Cow + 1, Cow + 1 + n, cmp);
	int iAns = 0;
	for(int i = 1; i <= n; i++)
	{
		Add(Cow[i].iBh, 1);
		int l = Query(Cow[i].iBh - 1);
		int r = i - l - 1;
		if(max(l, r) > 2 * min(l, r)) iAns++;
	}
	cout<<iAns;
}
```
**核心实现思想**：同样使用树状数组，按身高从大到小排序后，每次插入一个奶牛，查询其左边比它高的奶牛数量，算出右边比它高的奶牛数量，判断是否不平衡。

#### 曹老师的题解
```cpp
int query(int x)
{
	int sum=0;
	for(int i=x;i>=1;i-=lowbit(i))
		sum+=bit[i];
	return sum;
}
void update(int x,int v)
{
	for(int i=x;i<=n;i+=lowbit(i))
		bit[i]+=v;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&cow[i].high);
		cow[i].num=i;
	}
	sort(cow+1,cow+n+1,cmp);
	for(int i=1;i<=n;i++)
		c[cow[i].num]=i;// 离散化
	for(int i=1;i<=n;i++)
	{
		int l=query(c[i]),r=c[i]-l-1;
		update(c[i],1);
		if(l>r*2||r>2*l)
			ans++;
	}
    printf("%d",ans);
	return 0;
}
```
**核心实现思想**：先对奶牛按身高从大到小排序并离散化，使用树状数组查询左边比它高的奶牛数量，算出右边比它高的奶牛数量，判断是否不平衡并更新树状数组。

### 最优关键思路或技巧
- **排序与离散化**：将奶牛按身高从大到小排序，方便后续计算比当前奶牛高的奶牛数量。离散化可处理数据范围大的问题。
- **树状数组**：利用树状数组进行单点修改和区间查询，高效计算前缀和，从而得到左边比当前奶牛高的奶牛数量，进而算出右边的数量。

### 可拓展之处
同类型题如求逆序对数量、区间第 $k$ 大等问题，可使用树状数组、线段树、主席树、平衡树等数据结构解决。类似算法套路包括先排序再利用数据结构维护信息，通过查询和更新操作计算所需结果。

### 推荐题目
- P1908 逆序对
- P3374 【模板】树状数组 1
- P3369 【模板】普通平衡树

### 个人心得摘录与总结
- **nihanchu**：通过翻译官网题解弄懂题目，提醒自己讲解可能存在不足，体现了学习过程中的认真和谦逊。
- **Shikita**：从暴力枚举开始尝试，逐步优化，先骗到部分分数，再思考算法优化，最终想到树状数组，展示了调试和优化代码的过程。 

---
处理用时：50.03秒
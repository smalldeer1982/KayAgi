# 题目信息

# [USACO17JAN] Hoof, Paper, Scissor G

## 题目背景

*本题与 [银组同名题目](/problem/P6120) 在题意上一致，唯一的差别在于对变手势次数的限制。*


## 题目描述

你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。

“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。

现在 FJ 和 Bassie 要进行 $N$ 轮对抗。Bassie 已经预测了 FJ 每一轮要出的手势。然而 Bassie 很懒，她最多只想变换 $K$ 次手势。

现在请你帮 Bassie 求出她最多能赢多少轮。

## 样例 #1

### 输入

```
5 1
P
P
H
P
S```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕动态规划（DP）和记忆化搜索两种方法来解决“蹄子，剪刀，布”问题。大部分题解都定义了三维状态数组 `f[i][j][k]` 来表示不同状态下的最优解，其中 `i` 表示轮数，`j` 表示变换手势的次数，`k` 表示当前的手势。

在状态转移方面，主要考虑两种情况：不改变手势和改变手势。对于不改变手势，直接继承上一轮相同手势的状态；对于改变手势，需要枚举上一轮的不同手势状态并更新当前状态。

不同题解的区别在于状态定义、转移方程的表达方式以及代码实现细节。部分题解还进行了优化，如省略不必要的循环、使用滚动数组等，以减少时间和空间复杂度。

### 所选题解
- **作者：zgf519orz（5星）**
  - **关键亮点**：思路清晰，先给出朴素的 DP 解法，再分析其时间复杂度高的问题并进行优化，详细解释了优化的思路和过程。代码注释丰富，可读性强。
  - **个人心得**：意识到朴素 DP 会超时，通过分析发现当前状态只与 `i - 1` 的状态有关，从而省略了枚举 `k` 的循环，优化了算法。

### 重点代码
```cpp
// 优化后的代码
#include <cstdio>
#include <algorithm>
#include <iostream>
using namespace std;

int n,m;
bool h[100005],s[100005],p[100005];
int f[100005][25][3];

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        char tmp;
        cin >> tmp;
        if(tmp=='H'){
            p[i]=1;
        }
        if(tmp=='S'){
            h[i]=1;
        }
        if(tmp=='P'){
            s[i]=1;
        }
    }
    f[1][0][0]=h[1];
    f[1][0][1]=s[1];
    f[1][0][2]=p[1];
    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            f[i][j][0]=max(f[i][j][0],
                           max(f[i-1][j][0]+h[i],
                               max(f[i-1][j-1][1]+h[i],f[i-1][j-1][2]+h[i])));
            f[i][j][1]=max(f[i][j][1],
                           max(f[i-1][j][1]+s[i],
                               max(f[i-1][j-1][0]+s[i],f[i-1][j-1][2]+s[i])));
            f[i][j][2]=max(f[i][j][2],
                           max(f[i-1][j][2]+p[i],
                               max(f[i-1][j-1][0]+p[i],f[i-1][j-1][1]+p[i])));
        }
    }
    int ans=0;
    for(int i=0;i<=m;i++){
        ans=max(ans,max(f[n][i][0],max(f[n][i][1],f[n][i][2])));
    }
    printf("%d",ans);
    return 0;
}
```
**核心实现思想**：通过定义三维数组 `f[i][j][k]` 表示前 `i` 轮，严格变换了 `j` 次手势，并且最后一次出的是 `k` 手势所赢的最多次数。在状态转移时，考虑当前轮不改变手势和改变手势两种情况，取最大值更新当前状态。最后枚举所有可能的变换次数和手势，取最大值作为最终答案。

### 最优关键思路或技巧
- **状态定义**：使用三维数组 `f[i][j][k]` 来表示不同状态下的最优解，清晰地记录了轮数、变换次数和当前手势的信息。
- **状态转移优化**：分析状态之间的关系，发现当前状态只与 `i - 1` 的状态有关，从而省略了不必要的循环，降低了时间复杂度。
- **记忆化搜索**：对于部分题解使用的记忆化搜索方法，通过记录已经计算过的状态，避免了重复计算，提高了效率。

### 可拓展之处
同类型题或类似算法套路：
- **背包问题**：如 0 - 1 背包、完全背包等，通过定义状态和状态转移方程来求解最优解。
- **区间 DP**：在区间上进行动态规划，通过枚举区间端点和分割点来更新状态。
- **树形 DP**：在树结构上进行动态规划，利用树的递归性质进行状态转移。

### 推荐题目
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)：0 - 1 背包问题的经典题目，通过动态规划求解最大价值。
- [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)：区间 DP 问题，通过枚举区间和分割点来求解最小或最大得分。
- [P2014 选课](https://www.luogu.com.cn/problem/P2014)：树形 DP 问题，在树结构上进行动态规划，求解最大学分。

### 个人心得摘录与总结
- **zgf519orz**：意识到朴素 DP 会超时，通过分析状态之间的关系，发现当前状态只与 `i - 1` 的状态有关，从而省略了枚举 `k` 的循环，优化了算法。这启示我们在遇到时间复杂度高的问题时，要仔细分析状态之间的关系，寻找优化的方法。
- **南城忆潇湘**：在写代码时，发现只用 `f[i - 1]` 来表示 `f[i]` 会出现错误，因为缺少必要的数据，于是增加维度来记录更多信息。这提醒我们在设计状态时，要确保状态能够包含足够的信息，以便正确进行状态转移。

---
处理用时：39.53秒
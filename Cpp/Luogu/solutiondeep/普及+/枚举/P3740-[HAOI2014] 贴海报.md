# 题目信息

# [HAOI2014] 贴海报

## 题目描述

Bytetown 城市要进行市长竞选，所有的选民可以畅所欲言地对竞选市长的候选人发表言论。为了统一管理，城市委员会为选民准备了一个张贴海报的 electoral 墙。

张贴规则如下：

1. electoral 墙是一个长度为 $N$ 个单位的长方形，每个单位记为一个格子；

2. 所有张贴的海报的高度必须与 electoral 墙的高度一致的；

3. 每张海报以 `A B` 表示，即从第 $A$ 个格子到第 $B$ 个格子张贴海报；

4. 后贴的海报可以覆盖前面已贴的海报或部分海报。

现在请你判断，张贴完所有海报后，在 electoral 墙上还可以看见多少张海报。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/5209.png) 

**约束条件**

$10\le N \le 10000000,1\le M\le 1000,1\le A_i \le B_i \le 10000000$

所有的数据都是正整数，数据之间有一个空格。

## 样例 #1

### 输入

```
100 5
1 4
2 6
8 10
3 4
7 10
```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
本题是一个区间染色问题，要求计算张贴完所有海报后还能看见的海报数量。各位作者提供了多种解题思路，涵盖线段树、浮水法、珂朵莉树、分块、并查集、暴力等多种算法。

线段树类解法通过维护区间是否被染色来判断海报是否可见；浮水法利用递归让线段上浮，判断线段是否能上浮到最顶端来确定海报是否可见；珂朵莉树则是维护拥有相同元素的区间，通过染色和计数操作得出结果；分块算法将数组分块，用标记处理染色；并查集通过维护序列连通性，反转时间轴染色；暴力解法通过模拟或枚举判断海报是否被覆盖。

不同算法在时间复杂度、空间复杂度和代码实现难度上各有优劣，需根据数据范围和题目特点选择合适的算法。

### 所选题解
- **作者：SovietPower✨ (赞：40)，4星**
    - **关键亮点**：提供线段树和浮水法两种解法，思路清晰，代码注释详细。
    - **个人心得**：提到不会离散化，但好在数据还用不到，并且指出还可以暴力，cogs上加强了数据暴力只能80分。
- **作者：yzhang (赞：25)，4星**
    - **关键亮点**：使用珂朵莉树解题，有对珂朵莉树的介绍链接，代码有优化。
    - **个人心得**：考前刷水题，担心AFO，希望通过写珂朵莉树++rp。
- **作者：心灵间的跳跃 (赞：17)，4星**
    - **关键亮点**：详细讲解线段树的区间树和点树解法，对离散化的处理和区别讲解细致。
    - **个人心得**：在老师和同学的讲解下才会线段树的解题方法。

### 重点代码及核心实现思想
#### 线段树（SovietPower✨）
```cpp
// 线段树修改操作
void Modify(int l,int r,int rt,int L,int R)
{
    if(colored[rt]) return;
    if(L<=l && r<=R)
    {
        flag=1;colored[rt]=1;
        return;
    }
    int m=(l+r)>>1;
    if(L<=m) Modify(l,m,rt<<1,L,R);
    if(m<R) Modify(m+1,r,rt<<1|1,L,R);
    PushUp(rt);
}
```
**核心思想**：从后往前枚举海报，若区间未被完全染色，则标记该区间并答案加1，通过递归更新线段树。

#### 珂朵莉树（yzhang）
```cpp
// 珂朵莉树分裂操作
IT split(int pos)
{
    IT it = s.lower_bound(node(pos));
    if (it != s.end() && it->l == pos) 
        return it;
    --it;
    int L = it->l, R = it->r, V = it->v;
    s.erase(it);
    s.insert(node(L, pos-1, V));
    return s.insert(node(pos, R, V)).first;
}
// 珂朵莉树赋值操作
void assign_val(int l,int r,int val)
{
    IT itr=split(r+1),itl=split(l);
    s.erase(itl,itr);
    s.insert(node(l,r,val));
}
```
**核心思想**：每贴一张海报进行赋值操作，最后用桶排思想统计不同颜色的数量。

#### 线段树（心灵间的跳跃）
```cpp
// 线段树插入操作
void ins(int rt,int l,int r,int k)
{
 if(l>=a[rt].r || r<=a[rt].l)    
     return;
 if(l<=a[rt].l && a[rt].r<=r)
    {
      a[rt].c=k;         
      return;
    }    
 pushd(rt);
 ins(rt<<1,l,r,k);
 ins(rt<<1|1,l,r,k);
 pushup(rt);
}
```
**核心思想**：先离散化处理数据，再从后往前插入海报，通过延迟操作更新线段树，最后查询不同颜色的数量。

### 最优关键思路或技巧
- **倒序处理**：从后往前处理海报，因为后面的海报会覆盖前面的海报，倒序处理可以避免重复判断。
- **离散化**：当数据范围较大时，通过离散化将数据范围缩小，减少空间和时间复杂度。
- **数据结构的选择**：根据题目特点选择合适的数据结构，如线段树、珂朵莉树、并查集等，提高算法效率。

### 可拓展之处
同类型题如区间覆盖、区间查询等问题，可使用类似的算法套路。例如，对于区间覆盖问题，可以使用线段树、珂朵莉树等数据结构；对于区间查询问题，可以使用树状数组、分块等算法。

### 推荐题目
1. [P1816 忠诚](https://www.luogu.com.cn/problem/P1816)：区间最值问题，可使用线段树或ST表解决。
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：线段树的基础应用，区间修改和区间查询。
3. [P2023 [AHOI2009] 维护序列](https://www.luogu.com.cn/problem/P2023)：涉及区间乘法和加法操作，需要使用线段树维护。

### 个人心得总结
- **SovietPower✨**：认识到数据特点对算法选择的影响，暴力算法在部分数据下也能取得较好成绩。
- **yzhang**：考前刷水题的心态和希望通过特定操作提升rp的想法。
- **心灵间的跳跃**：强调在他人帮助下学习算法的过程，体现了学习过程中交流的重要性。

---
处理用时：44.18秒
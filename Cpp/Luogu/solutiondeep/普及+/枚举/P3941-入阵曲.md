# 题目信息

# 入阵曲

## 题目背景

pdf题面和大样例链接：http://pan.baidu.com/s/1cawM7c 密码：xgxv

```cpp
丹青千秋酿，一醉解愁肠。 
无悔少年枉，只愿壮志狂。 
```

## 题目描述

 
小 F 很喜欢数学，但是到了高中以后数学总是考不好。

有一天，他在数学课上发起了呆；他想起了过去的一年。一年前，当他初识算法竞赛的 时候，觉得整个世界都焕然一新。这世界上怎么会有这么多奇妙的东西？曾经自己觉得难以 解决的问题，被一个又一个算法轻松解决。

小 F 当时暗自觉得，与自己的幼稚相比起来，还有好多要学习的呢。

一年过去了，想想都还有点恍惚。

他至今还能记得，某天晚上听着入阵曲，激动地睡不着觉，写题写到鸡鸣时分都兴奋不 已。也许，这就是热血吧。


 
  ![](https://cdn.luogu.com.cn/upload/pic/9810.png) 

也就是在那个时候，小 F 学会了矩阵乘法。让两个矩阵乘几次就能算出斐波那契数列的 第 $10^{100}$ 项，真是奇妙无比呢。

不过，小 F 现在可不想手算矩阵乘法——他觉得好麻烦。取而代之的，是一个简单的小 问题。他写写画画，画出了一个 $n \times m$ 的矩阵，每个格子里都有一个不超过 $k$ 的正整数。

小 F 想问问你，这个矩阵里有多少个不同的子矩形中的数字之和是 $k$ 的倍数？ 如果把一个子矩形用它的左上角和右下角描述为 $(x_1,y_1,x_2,y_2)$，其中$x_1 \le x_2,y_1 \le y_2$； 那么，我们认为两个子矩形是不同的，当且仅当他们以 $(x_1,y_1,x_2,y_2)$ 表示时不同；也就是 说，只要两个矩形以 $(x_1,y_1,x_2,y_2)$ 表示时相同，就认为这两个矩形是同一个矩形，你应该 在你的答案里只算一次。


## 说明/提示

【样例 1 说明】

这些矩形是符合要求的： (1, 1, 1, 3)，(1, 1, 2, 2)，(1, 2, 1, 2)，(1, 2, 2, 3)，(2, 1, 2, 1)，(2, 3, 2, 3)。


子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。

每个测试点的数据规模及特点如下表：

 
  ![](https://cdn.luogu.com.cn/upload/pic/9811.png) 

特殊性质：保证所有 $a_{i,j}$ 均相同。


## 样例 #1

### 输入

```
2 3 2 
1 2 1 
2 1 2```

### 输出

```
6 
```

# AI分析结果

### 综合分析与结论
本题核心是求矩阵中元素和为 k 倍数的子矩形数量。各题解普遍采用二维前缀和优化子矩形求和，将问题转化为一维数组子区间和为 k 倍数的问题。关键思路是枚举子矩形上下边界，把对应列元素和视为一维数组元素，利用前缀和余数相同则区间和为 k 倍数的性质，用桶记录余数出现次数来统计答案。

### 所选题解
- **作者：fstqwq（5星）**
    - **关键亮点**：代码简洁高效，思路清晰，直接给出标准解法。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

#define N 405

int n, m, K;
int a[N][N], b[N], cnt[1000005];
LL ans = 0;

int main() {
    scanf("%d%d%d", &n, &m, &K);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            scanf("%d", a[i] + j);
            (a[i][j] += a[i - 1][j] + a[i][j - 1] + K - a[i - 1][j - 1]) %= K;
        }
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j <= n; j++) {
            cnt[0] = 1;
            for (int k = 1; k <= m; k++) ans += cnt[(b[k] = a[j][k] + K - a[i][k]) %= K]++;
            for (int k = 1; k <= m; k++) cnt[b[k]] = 0;
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```
    - **实现思想**：先计算二维前缀和并取模，再枚举上下边界，将对应列的前缀和差值取模后用桶统计，更新答案并清空桶。

- **作者：why1123（4星）**
    - **关键亮点**：思路详细，先解决一维子区间问题再扩展到二维，对错误点有详细说明。
    - **个人心得**：在实现过程中，犯了枚举范围错误、前缀和计算错误等，提醒要注意枚举边界和前缀和的计算逻辑。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,k;
int qwq[405][405];
long long sum[405][405]={0},ssum[405]={0};
int vis[1000005]={0};
long long ans=0;
int main(){
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&qwq[i][j]);
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+qwq[i][j];
        }
    }
    for(int i=0;i<n;i++){
        for(int j=i+1;j<=n;j++){
            for(int mm=1;mm<=m;mm++){
                ssum[mm]=(sum[j][mm]-sum[i][mm]+k)%k;
                ans+=vis[ssum[mm]]++;
            }
            ans+=vis[0];
            for(int mm=1;mm<=m;mm++){
                vis[ssum[mm]]=0;
            }
            vis[0]=0;
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```
    - **实现思想**：先计算二维前缀和，枚举上下边界，将对应列的前缀和差值取模后用桶统计，更新答案并清空桶，最后加上模为 0 的数量。

### 最优关键思路或技巧
- **二维前缀和**：快速计算子矩形元素和，时间复杂度从 $O(n^4)$ 优化到 $O(1)$。
- **降维处理**：枚举上下边界将二维问题转化为一维子区间问题，复杂度降为 $O(n^2m)$。
- **余数统计**：利用前缀和余数相同则区间和为 k 倍数的性质，用桶记录余数出现次数统计答案。

### 可拓展之处
同类型题或类似算法套路：
- 求矩阵中元素和满足其他条件（如大于某值、等于某值）的子矩形数量，可调整判断条件。
- 求高维空间中满足特定条件的子空间数量，可类比降维处理思路。

### 推荐题目
- P1387 最大正方形：考察二维前缀和与动态规划，求矩阵中最大正方形的边长。
- P2004 领地选择：求矩阵中指定大小子矩阵的最大元素和。
- P1719 最大加权矩形：求矩阵中元素和最大的子矩形。

### 个人心得总结
部分作者在实现过程中遇到枚举范围错误、前缀和计算错误等问题，提醒我们在使用枚举和前缀和时要注意边界条件和计算逻辑，避免因粗心导致错误。同时，对于复杂问题可先从简单情况入手，逐步扩展到复杂情况。 

---
处理用时：33.03秒
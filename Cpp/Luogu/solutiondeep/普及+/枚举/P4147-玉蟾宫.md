# 题目信息

# 玉蟾宫

## 题目背景

有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。


## 题目描述

这片土地被分成 $N\times M$ 个格子，每个格子里写着 'R' 或者 'F'，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。

现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 'F' 并且面积最大。

但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为 $S$，它们每人给你 $S$ 两银子。


## 说明/提示

对于 $50\%$ 的数据，$1 \leq N, M \leq 200$。  
对于 $100\%$ 的数据，$1 \leq N, M \leq 1000$。

## 样例 #1

### 输入

```
5 6 
R F F F F F 
F F F F F F 
R R R F F F 
F F F F F F 
F F F F F F```

### 输出

```
45```

# AI分析结果

### 综合分析与结论
本题主要是在给定的字符矩阵中寻找全为 'F' 的最大矩形面积。题解中涉及多种算法，包括单调栈、悬线法、并查集、暴力枚举等。

单调栈做法通过维护一个单调递增的栈来计算以每行为底的最大矩形面积；悬线法通过预处理每个点向上、向左、向右的最大延伸长度来计算最大矩形面积；并查集做法通过合并相邻列来计算最大矩形面积；暴力枚举则通过三重循环直接计算所有可能的矩形面积。

从复杂度和实现难度来看，单调栈和悬线法的时间复杂度较低，为 $O(nm)$，是比较优的解法；暴力枚举的时间复杂度较高，为 $O(n^3)$，但实现简单；并查集做法的时间复杂度为 $O(nm\log m)$，实现相对复杂。

### 所选题解
- **作者：假假 (赞：120)，4星**
    - **关键亮点**：思路清晰，详细阐述了单调栈的做法，包括预处理和栈操作的具体步骤，代码实现规范，有详细的注释。
    - **个人心得**：无
- **作者：Plus_Ultra (赞：89)，4星**
    - **关键亮点**：对单调栈的原理和操作过程解释详细，通过图文结合的方式帮助理解，代码简洁易懂。
    - **个人心得**：看到很多题解都看不懂，于是回去复习lyd大佬的书，弄明白之后就A了这道题，想借题解加深一下记忆，同时也想帮助一下和我一样的萌新。
- **作者：XG_Zepto (赞：54)，4星**
    - **关键亮点**：指出本题是最大子矩形问题的板子题，并推荐了相关论文，详细介绍了悬线法的思路和代码实现。
    - **个人心得**：无

### 重点代码
#### 单调栈做法（假假）
```cpp
void calc(int x){
    int top=1,temp=0;
    maxs=0;
    stack[1].height=pos[x][1];
    stack[1].length=1;
    for(i=2;i<=m;++i){
        temp=0;
        while(stack[top].height>=pos[x][i]&&top>0){
            temp+=stack[top].length;
            maxs=max(maxs,stack[top--].height*temp);
        }
        stack[++top].height=pos[x][i];
        stack[top].length=temp+1;
    }
    temp=0;
    while(top>0){
        temp+=stack[top].length;
        maxs=max(maxs,stack[top--].height*temp);
    }
    ans=max(ans,maxs);
}
```
**核心实现思想**：对于每一行，维护一个单调递增的栈，栈中存储每个柱子的高度和可控宽度。当遇到比栈顶矮的柱子时，弹出栈顶并计算以栈顶柱子为高的矩形面积，更新最大面积。

#### 单调栈做法（Plus_Ultra）
```cpp
void ask(int x)
{
    memset(a,0,sizeof(a));
    a[1].h=f[x][1],a[1].len=1;
    while(S.size())  S.pop();
    S.push(a[1]);//初始化
    for(int i=2;i<=m;i++)
    {
        int w=0;
        while(S.size()&&f[x][i]<=S.top().h)//需要弹栈
        {
            w+=S.top().len;
            maxx=max(maxx,w*S.top().h);
            S.pop();//更新答案并弹栈
        }
        a[i].h=f[x][i],a[i].len=w+1;//已入栈的比他高的矩形个数加1
        S.push(a[i]);
    }
    int w=0;
    while(S.size())//用剩余矩形更新答案
    {
        w+=S.top().len;
        maxx=max(maxx,S.top().h*w);
        S.pop();
    }
}
```
**核心实现思想**：与假假的做法类似，使用 STL 栈来维护单调递增的柱子，通过弹栈和入栈操作计算最大矩形面积。

#### 悬线法做法（XG_Zepto）
```cpp
for(int i=1;i<=n;i++){
    t=0;
    for(int j=1;j<=m;j++)//枚举左边的障碍
        if(a[i][j])l[i][j]=t;
        else L[i][j]=0,t=j;
    t=m+1;
    for(int j=m;j>=1;j--)//枚举右边的障碍
        if(a[i][j])r[i][j]=t;  
        else R[i][j]=m+1,t=j;      
}
for(int i=1;i<=m+1;i++) R[0][i]=m+1;
for(int i=1;i<=n;i++)  
for(int j=1;j<=m;j++){
    if(a[i][j]){
        h[i][j]=h[i-1][j]+1;//如果这个点是合法的，对应的悬线长度应当比它下面的点对应的悬线长大1  
        L[i][j]=max(l[i][j]+1, L[i-1][j]);
        R[i][j]=min(r[i][j]-1, R[i-1][j]);
        ans=max((R[i][j]-L[i][j]+1)*h[i][j], ans); //求出最大的面积          
    }
}
```
**核心实现思想**：预处理每个点向左和向右能扩展到的最近障碍，然后通过悬线的向上延伸和左右扩展来计算最大矩形面积。

### 最优关键思路或技巧
- **单调栈**：通过维护单调递增的栈，在 $O(m)$ 的时间复杂度内计算以每行为底的最大矩形面积，避免了暴力枚举的高复杂度。
- **悬线法**：通过预处理每个点的向上、向左、向右延伸长度，利用动态规划的思想在 $O(nm)$ 的时间复杂度内计算最大矩形面积。

### 可拓展之处
同类型题或类似算法套路：
- **最大子矩阵和问题**：可以使用悬线法在 $O(nm)$ 的时间复杂度内解决。
- **直方图中的最大矩形问题**：可以使用单调栈在 $O(n)$ 的时间复杂度内解决。

### 推荐题目
- [P1169 棋盘制作](https://www.luogu.com.cn/problem/P1169)
- [P2701 [USACO5.3]巨大的牛棚Big Barn](https://www.luogu.com.cn/problem/P2701)
- [P4147 玉蟾宫](https://www.luogu.com.cn/problem/P4147)（本题）

### 个人心得总结
- Plus_Ultra：遇到看不懂的题解时，不要放弃，可以通过复习相关知识来加深理解，同时可以通过写题解来巩固所学知识。
- Forever_Lin：读入字符时要注意判断读的是字符还是换行符，避免出现错误。在使用悬线法时，要注意边界条件的判断，避免出现逻辑错误。

---
处理用时：53.78秒
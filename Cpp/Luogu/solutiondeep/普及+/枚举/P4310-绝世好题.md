# 题目信息

# 绝世好题

## 题目描述

给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i \& b_{i-1} \ne 0 $，其中 $2\leq i\leq k$， $\&$ 表示位运算取与。

## 说明/提示

对于100%的数据，$1\leq n\leq 100000$，$a_i\leq 10^9$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕动态规划（DP）来解决问题，部分题解还涉及图论和暴力枚举。

#### 思路对比
- **暴力枚举**：类比最长上升子序列，直接 $O(n^2)$ 暴力枚举当前要添加的数以及序列结尾的数，可拿 80 - 90 分。
- **优化 DP**：利用位运算特性，枚举新添加数的二进制上的 1 位，记录此二进制位全为 1 的数组成的子序列的最大长度，优化到 $O(31 \times n)$。
- **图论解法**：按位分解每个数，对每一位相邻最近的两个该位为 1 的序号由小序号往大序号连边，形成 DAG 图，通过拓扑排序求最长路。

#### 算法要点
- **暴力枚举**：设 $f[i]$ 表示以 $a[i]$ 结尾的 $b$ 序列的最长长度，状态转移方程为 $f[i] = max(f[i], f[j]+1)\ (a[i]\ \&\ a[j] \not=0)$。
- **优化 DP**：设 $f[i]$ 表示最后一位为 $i$ 的 $b$ 数列的最长长度，$bit[j]$ 表示二进制第 $j$ 位为 1 的数组成的子序列 $b$ 的最长长度，状态转移方程为 $f[i] =  max(f[i], bit[k]+1)$。
- **图论解法**：建图后进行拓扑排序，在拓扑排序过程中更新最长路长度。

#### 解决难点
- **暴力枚举**：时间复杂度高，数据规模大时会超时。
- **优化 DP**：需要发现新添加的数只能由同一二进制位上同为 1 的数转移而来这一特性。
- **图论解法**：将问题转化为图论模型，建图和拓扑排序的实现。

### 高评分题解
1. **作者：winxp_qwq（5星）**
    - **关键亮点**：思路清晰，代码简洁，直接使用优化后的 DP 算法，复杂度为 $nlogn$。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[32];
int main(){
    int n;
    scanf("%d",&n);
    int a,b,c,i,j,k,ans=0;
    for(a=1;a<=n;a++)
    {
        scanf("%d",&b);
        k=1;
        for(c=0;c<=30;c++)
            if((1<<c)&b) k=max(dp[c]+1,k);
        for(c=0;c<=30;c++)
            if((1<<c)&b) dp[c]=max(dp[c],k);
        ans=max(ans,k);
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心思想**：用 $dp[i]$ 表示数列到目前为止最后一项第 $i$ 位为 1 的最大子序列长度，每读入一个数，先找出其所有二进制位为 1 对应的 $dp$ 值加 1 的最大值，再用该最大值更新这些二进制位对应的 $dp$ 值。

2. **作者：灵乌路空（4星）**
    - **关键亮点**：详细介绍了暴力思路和优化思路，给出了两种复杂度不同的代码，有助于理解算法的优化过程。
    - **核心代码（优化后）**：
```cpp
#include<cstdio>
#include<algorithm>
#include<map>
#include<ctype.h>
#define lowbit(x) (x)&-(x)
const int MARX = 1e5+10;
int n,ans,a[MARX]; 
int bit[40], f[MARX];  
std::map <int,int> log_2;
signed main()
{
    for(int i=0,sum=1;i<=31;i++,sum<<=1) log_2[sum]=i; 
    n=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1;i<=n;i++)
    {
        for(int j=a[i],low=lowbit(j);j;j-=low,low=lowbit(j)) 
            f[i]=std::max(f[i],bit[log_2[low]]+1);
        for(int j=a[i],low=lowbit(j);j;j-=low,low=lowbit(j)) 
            bit[log_2[low]]=std::max(bit[log_2[low]],f[i]);	
        ans=std::max(f[i],ans); 
    }
    printf("%d",ans);
}
```
    - **核心思想**：用 $f[i]$ 表示以 $a[i]$ 结尾的 $b$ 序列的最长长度，$bit[j]$ 表示二进制第 $j$ 位为 1 的数组成的子序列 $b$ 的最长长度，通过枚举 $a[i]$ 二进制上为 1 的位数更新 $f[i]$ 和 $bit[k]$。

3. **作者：Vocanda（4星）**
    - **关键亮点**：详细分析了暴力解法和正解的思路，给出了两种代码，有助于理解算法的优化过程。
    - **核心代码（正解）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 32;
int dp[maxn];
int Max,ans;
int main(){
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        int b;
        scanf("%d",&b);
        for(int c=0;c<=31;++c){
            if((1<<c)&b)Max=max(Max,dp[c]+1);
        }
        for(int c=0;c<=31;++c){
            if((1<<c)&b)dp[c]=max(Max,dp[c]);
        }
        ans=max(ans,Max);
    }
    cout<<ans<<"\n";
    return 0;
}
```
    - **核心思想**：用 $dp[c]$ 表示二进制第 $c$ 位时最大的长度，枚举每个数的二进制位，找出满足条件的最大长度 $Max$，再用 $Max$ 更新满足条件的二进制位的 $dp$ 值。

### 最优关键思路或技巧
- **位运算优化**：利用位运算特性，将时间复杂度从 $O(n^2)$ 优化到 $O(31 \times n)$。
- **状态定义**：通过合理定义状态，如 $dp[i]$ 表示最后一项第 $i$ 位为 1 的最大子序列长度，简化状态转移过程。

### 拓展思路
同类型题或类似算法套路：
- 涉及位运算和动态规划结合的题目，如求满足某种位运算条件的最大子数组和等。
- 可以将问题转化为图论模型，通过建图和拓扑排序解决的题目。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)：考察最长上升子序列和最长不上升子序列的动态规划算法。
2. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)：区间动态规划问题，与本题的动态规划思想有一定关联。
3. [P2758 编辑距离](https://www.luogu.com.cn/problem/P2758)：经典的动态规划问题，涉及状态转移和最优子结构。

### 个人心得摘录与总结
- **作者：jacklee10086**：一开始想用按位分解后的每个二进制位为 1 的数量取最大值来解题，但发现该做法错误，意识到对于任意两段可行序列，只要有交集就可以合并，从而考虑用图论解决问题。
总结：在解题时，若初步思路错误，要深入分析问题，尝试从不同角度思考，将问题转化为其他模型求解。
- **作者：sdgzy**：刚开始状态转移错了，吃饭时猛地想起来状态的缺失，然后成功 AC。
总结：解题过程中可能会出现思路偏差，适当放松后可能会有新的灵感，要及时修正状态转移方程。 

---
处理用时：50.55秒
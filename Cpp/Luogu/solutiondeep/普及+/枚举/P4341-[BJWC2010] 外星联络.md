# 题目信息

# [BJWC2010] 外星联络

## 题目描述

小 P 在看过电影《超时空接触》(Contact)之后被深深的打动，决心致力于寻找外星人的事业。于是，他每天晚上都爬在屋顶上试图用自己的收音机收听外星人发来的信息。

虽然他收听到的仅仅是一些噪声，但是他还是按照这些噪声的高低电平将接收到的信号改写为由 `0` 和 `1` 构成的串， 并坚信外星人的信息就隐藏在其中。他认为，外星人发来的信息一定会在他接受到的 01 串中重复出现，所以他希望找到他接受到的 01 串中所有重复出现次数大于 $1$ 的子串。

但是他收到的信号串实在是太长了，于是，他希望你能编一个程序来帮助他。

## 说明/提示

对于 100%的数据，满足 $0 \le N \le 3000$

## 样例 #1

### 输入

```
7
1010101```

### 输出

```
3
3
2
2
4
3
3
2
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找给定 01 串中重复出现次数大于 1 的子串并输出其出现次数展开，使用了多种算法和数据结构，包括 Trie 树、后缀数组、后缀自动机和后缀树。
- **Trie 树类**：通过枚举子串插入 Trie 树，记录每个子串的出现次数，最后遍历树输出结果，思路简单直接，代码实现相对容易，时空复杂度为 $O(n^2)$。
- **后缀数组类**：先构建后缀数组和 height 数组，再根据 height 数组计算子串出现次数，复杂度也是 $O(n^2)$，但实现和理解难度较大。
- **后缀自动机类**：构建后缀自动机，在 parent 树上统计子串出现次数，最后按字典序遍历输出，复杂度同样为 $O(n^2)$，理解有一定难度。
- **后缀树类**：使用 Ukkonen 算法构建后缀树，统计子树中叶节点个数得到子串出现次数，代码复杂，实现难度高。

### 所选题解
- **作者：EternalAlexander（5 星）**
    - **关键亮点**：思路清晰，直接暴力枚举子串插入 Trie 树，代码简洁易懂，是最简单、代码最短的做法。
    - **核心代码**：
```cpp
#include <cstdio>

int ch[9000000][2]={0}; 
int cnt[9000000]={0};
int tail=0;
char s[4000];

int dfs(int root) {
    if (cnt[root]>1) printf("%d\n",cnt[root]);
    if (ch[root][0]) dfs(ch[root][0]);
    if (ch[root][1]) dfs(ch[root][1]);
    return 0;
}

int main() {
    int n;
    scanf("%d %s", &n, &s);
    for (int i=n;i>=1;--i) s[i]=s[i-1];
    for (int i=1;i<=n;++i) {
        int p=0;
        for (int j=i;j<=n;++j) {
            if (!ch[p][s[j]-'0']) ch[p][s[j]-'0']=++tail;
            p=ch[p][s[j]-'0']; cnt[p]++;
        }
    }dfs(0);
    return 0;
}
```
    - **核心思想**：枚举所有子串插入 Trie 树，每个子串对应节点的 `cnt` 值加 1，最后先序遍历 Trie 树，输出 `cnt` 值大于 1 的节点的 `cnt` 值。

- **作者：ywy_c_asm（4 星）**
    - **关键亮点**：使用后缀自动机解决问题，思路清晰，代码规范，有详细的函数封装。
    - **核心代码**：
```cpp
void ywymain()
{
    int eee;
    cin>>eee;
    scanf("%s",str+1);
    int n=strlen(str+1);
    int p=1;
    for(register int i=1; i<=n; i++)p=zhuanyi(p,str[i]-'0');
    for(register int i=2; i<gn; i++)add(fa[i],i);
    dfs(1);
    efs(1);
}
```
    - **核心思想**：构建后缀自动机，在 parent 树上进行 dfs 统计每个节点的 `size`（即子串出现次数），最后按字典序对后缀自动机进行 dfs 输出结果。

- **作者：Jμdge（4 星）**
    - **关键亮点**：使用后缀数组解决问题，有一定的优化，将时间从 80ms 减到 0ms，思路朴素且有详细解释。
    - **核心代码**：
```cpp
int main() {
    scanf("%d",&n), m=127;
    for(int i=1; i<=n; ++i)
        s[i]=cread();
    build_sa(), build_hi();
    for(int i=2; i<=n; ++i) {
        for(int j=hi[i-1]+1; j<=hi[i]; ++j) {
            int k=i;
            while(hi[k]>=j) ++k;
            printf("%d\n",k-i+1);
        }
    }
    return 0;
}
```
    - **核心思想**：先构建后缀数组和 height 数组，然后按排名枚举后缀子串，对于每个子串，枚举其长度，根据 height 数组计算该长度子串的出现次数并输出。

### 最优关键思路或技巧
- **Trie 树的使用**：利用 Trie 树可以方便地插入和统计子串出现次数，且能自然保证字典序输出。
- **后缀数组和 height 数组的结合**：通过构建后缀数组和 height 数组，可以高效地计算子串的最长公共前缀，从而统计子串出现次数。
- **后缀自动机的应用**：后缀自动机可以将所有子串信息压缩到有限个状态中，通过在 parent 树上统计子树大小得到子串出现次数。

### 可拓展之处
- **同类型题**：字符串匹配、字符串计数、最长公共子串等问题都可以使用这些算法和数据结构解决。
- **类似算法套路**：对于字符串问题，可以考虑使用 Trie 树、后缀数组、后缀自动机和后缀树等数据结构，根据数据范围和问题特点选择合适的方法。

### 推荐题目
- [P3809 【模板】后缀排序](https://www.luogu.com.cn/problem/P3809)
- [P3796 【模板】AC 自动机（加强版）](https://www.luogu.com.cn/problem/P3796)
- [P4070 [SDOI2016]生成魔咒](https://www.luogu.com.cn/problem/P4070)

### 个人心得摘录与总结
- **作者：bztMinamoto**：刚学后缀数组，通过此题对其有了更深刻的认识。一开始想用 map 记录子串出现次数，但考虑到时间复杂度会爆掉，后来想到只考虑包含后缀数组首字母的子串，避免重复计算，还从大到小枚举子串长度倒序输出答案，避免重复搜索。
总结：学习新算法后通过实际题目加深理解，在解题时要考虑算法复杂度，合理优化思路。
- **作者：Jμdge**：基本思路和楼下大佬一样，但有一点小优化可以让 80ms 的时间减成 0ms，思路很朴素。
总结：在已有思路基础上进行小优化可以显著提高程序效率。 

---
处理用时：41.80秒
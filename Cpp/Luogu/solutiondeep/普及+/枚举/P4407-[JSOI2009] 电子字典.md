# 题目信息

# [JSOI2009] 电子字典

## 题目描述


人们在英文字典中查找某个单词的时候可能不知道该单词的完整拼法，而只知道该单词的一个错误的近似拼法，这时人们可能陷入困境，为了查找一个单词而浪费大量的时间。带有模糊查询功能的电子字典能够从一定程度上解决这一问题：用户只要输入一个字符串，电子字典就返回与该单词编辑距离最小的几个单词供用户选择。

字符串 $a$ 与字符串 $b$ 的编辑距离是指：允许对 $a$ 或 $b$ 串进行下列“编辑”操作，将 $a$ 变为 $b$ 或 $b$ 变为 $a$，最少“编辑”次数即为距离。

1. 删除串中某个位置的字母；
2. 添加一个字母到串中某个位置；
3. 替换串中某一位置的一个字母为另一个字母。

JSOI 团队正在开发一款电子字典，你需要帮助团队实现一个用于模糊查询功能的计数部件：对于一个待查询字符串，如果它是单词，则返回 $-1$；如果它不是单词，则返回字典中有多少个单词与它的编辑距离为 $1$。

## 说明/提示

### 样例解释

- `abcd` 在单词表中出现过；
- `abc` 与单词 `abcd`、`aabc` 的编辑距离都是 $1$；
- `abcdd` 与单词 `abcd`、`abcde`、`abced` 的编辑距离都是 $1$。

### 数据范围与约定

- 所有单词互不相同，但是查询字符串可能有重复；
- 对 $50\%$ 的数据范围，$N,M\le 10^3$；
- 对 $100\%$ 的数据范围，$N,M\le 10^4$。

## 样例 #1

### 输入

```
4 3
abcd
abcde
aabc
abced
abcd
abc
abcdd```

### 输出

```
-1
2
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕电子字典的模糊查询功能展开，解决给定字符串与字典中单词编辑距离为 1 的计数问题。题解思路主要分为两类：一是使用 Trie 树，通过 DFS 或暴力模拟来查找编辑距离为 1 的单词；二是使用 Hash 方法，通过预处理和枚举操作来判断编辑距离。

### 所选题解
- **作者：Utsuji_risshū（5 星）**
  - **关键亮点**：思路清晰，使用 Trie 树结合 DFS 实现，对三种编辑操作的 DFS 过程解释详细，代码可读性高。
  - **个人心得**：提到用循环模拟枚举较繁琐，选择用 DFS 实现。
- **作者：Cry_For_theMoon（4 星）**
  - **关键亮点**：补充了 DFS 的细节说明，对删除、添加、修改操作在 Trie 树上的路径分析透彻，帮助理解题意和避免错误。
  - **个人心得**：样例调了 1h 才发现 DFS 的问题，提醒注意删除、添加、修改操作中枚举字符的细节，以及 DFS 爆搜时枚举到头要判 tag。
- **作者：creation_hy（4 星）**
  - **关键亮点**：思路简洁，直接指出 Trie 上爆搜的思路，对 DFS 参数和注意事项解释清楚，代码注释详细。
  - **个人心得**：提醒注意只有在完全匹配到某个串时才改 $vis$ 数组，不要一碰到 `vis[cur]==true` 的情况就 `return`，否则会喜提 30 分。

### 重点代码
#### Utsuji_risshū 的核心代码
```cpp
void DFS(int rt,int l,bool f){
    if(l==len&&p[rt]&&!f){
        word=1;return;
    }
    if(l==len&&p[rt]&&f){
        if(!vis[rt]) vis[visx[++vistot]=rt]=1;
        return;
    }
    int c=s[l]-'a';
    if(!f){
        if(l<len) DFS(rt,l+1,1);
        for(register int i=0;i<26;++i)
            if(Trie[rt][i]){
                DFS(Trie[rt][i],l,1);
                if(i!=c) DFS(Trie[rt][i],l+1,1);
            }
    }
    if(l>=len) return;
    if(Trie[rt][c]) DFS(Trie[rt][c],l+1,f);
}
```
**核心实现思想**：使用 DFS 在 Trie 树上查找，`f` 表示是否使用过编辑机会。若未使用过，进行删除、添加、替换操作的 DFS；若已使用过，直接按原字符串查找。

#### Cry_For_theMoon 的核心代码
```cpp
void dfs1(char* s,int u,int len,int now,bool flag){
    if(now == len && val[u] && flag){cnt++;return;}
    if(now == len-1 && val[u] && !flag){cnt++;return;} 
    if(flag){
        int c = idx(s[now]);
        if(next[u][c]){
            dfs1(s,next[u][c],len,now+1,1);
        }
        return; 
    } 
    int c = idx(s[now]);
    if(next[u][c]){
        dfs1(s,next[u][c],len,now+1,0); 
    }
    for(int i=0;i<26;i++){
        if(!next[u][i])continue;
        if(i==c)continue;
        if(i == idx(s[now+1])){
            dfs1(s,next[u][i],len,now+2,1); 
        }
    } 
}
// dfs2 和 dfs3 代码类似，分别处理添加和修改操作
```
**核心实现思想**：分别用 `dfs1`、`dfs2`、`dfs3` 处理删除、添加、修改操作，`flag` 表示是否使用过编辑机会，根据不同情况进行递归。

#### creation_hy 的核心代码
```cpp
inline int dfs(string s, int cur, int x, bool changed)
{
    if (x == s.size() && !vis[cur] && tag[cur] && changed)
    {
        vis[cur] = true;
        return tag[cur];
    }
    int res = 0;
    if (t[cur][s[x]])
        res += dfs(s, t[cur][s[x]], x + 1, changed); 
    if (changed)
        return res;
    res += dfs(s, cur, x + 1, 1); 
    for (int i = 0; i < 26; i++)
        if (t[cur][i])
        {
            res += dfs(s, t[cur][i], x + 1, 1); 
            res += dfs(s, t[cur][i], x, 1);     
        }
    return res;
}
```
**核心实现思想**：DFS 函数带四个参数，`changed` 表示是否使用过修改操作。若未使用过，进行删除、添加、修改操作的递归；若已使用过，按原字符串查找。

### 最优关键思路或技巧
- **数据结构**：Trie 树是处理字符串查询问题的有效数据结构，能快速判断字符串是否存在。
- **算法优化**：使用 DFS 结合标记数组去重，避免重复计算。
- **思维方式**：将编辑距离问题转化为在 Trie 树上的搜索问题，通过枚举三种编辑操作来查找满足条件的单词。

### 可拓展之处
同类型题或类似算法套路：
- 编辑距离相关问题，如计算两个字符串的编辑距离（不限于 1）。
- 字符串模糊匹配问题，如给定一个模式串和一些文本串，找出编辑距离在一定范围内的文本串。

### 推荐题目
- [P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)：Trie 树模板题，练习 Trie 树的插入和查询操作。
- [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)：Trie 树与异或运算结合的题目，拓展 Trie 树的应用。
- [P8306 【模板】字典树](https://www.luogu.com.cn/problem/P8306)：Trie 树模板题，进一步巩固 Trie 树的实现。

### 个人心得总结
- **调试经历**：Cry_For_theMoon 样例调了 1h 才发现 DFS 的问题，提醒注意删除、添加、修改操作中枚举字符的细节，以及 DFS 爆搜时枚举到头要判 tag。
- **踩坑教训**：creation_hy 提醒注意只有在完全匹配到某个串时才改 $vis$ 数组，不要一碰到 `vis[cur]==true` 的情况就 `return`，否则会喜提 30 分。

---
处理用时：52.26秒
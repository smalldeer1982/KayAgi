# 题目信息

# [AHOI2018初中组] 根式化简

## 题目描述

小可可在学习“立方根”的知识时碰到这样的问题：

将下面根式化简为最简根式：

(1) $\sqrt[3]{125}$ (2) $\sqrt[3]{81}$ (3) $\sqrt[3]{52}$

这个问题对于小可可来说太简单了，他很快就算出了答案：

(1) $5$ (2) 3$\sqrt[3]{3}$ (3) $\sqrt[3]{52}$

小可可知道任意形如$\sqrt[3]{x}$ 的根式，化简后一定可以被写成形如$a\sqrt[3]{b}$的最简根式。他觉得这很有趣，就仿照出了不少题，但没一会儿就被密密麻麻的根式绕晕了，于是他向你求助：

给定 $n$ 个形如 $\sqrt[3]{x}$ 的根式，请你将它们化简为形如$a\sqrt[3]{b}$的最简形式，为了方便，你只需要输出其中的$a$ 即可。

如果你没有学过这部分数学知识，你可以认为题意是：给你$n$ 个正整数$x$，对于每一个$x$，你需要求出整数$a,b$ 使得$a^3 \times b = x$，输出最大的整数$a$ 即可。

## 说明/提示

对于100%的数据满足：$1≤n≤10000$，$1≤x≤10^{18}$。

本题共10 个测试点，编号为1~10，每个测试点额外保证如下：

测试点编号n 的范围x 的范围  
1~2 $n≤10, x≤10^6$  
3~4 $n≤10, x≤10^9$  
5~6 $n≤100, x≤10^{18}$ 且$x$ 为完全立方数  
7~8 $n≤500, x≤10^{18}$  
9~10 $n≤10000, x≤10^{18}$

## 样例 #1

### 输入

```
3
125 81 52```

### 输出

```
5
3
1```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是围绕将数 $x$ 分解，找出最大的 $a$ 使得 $a^3 \times b = x$。多数题解采用了预处理素数表，筛去 $x^{\frac{1}{4}}$ 以内素因子，再判断剩余部分是否为完全立方数的方法。不同题解在素数筛选方法、立方数判断方式和代码实现细节上有所差异。

### 所选题解
- **作者：hongzy（5星）**
    - **关键亮点**：思路清晰，先证明了筛掉 $x^{\frac{1}{4}}$ 以内素因子后剩余数的性质，再给出具体算法步骤。代码实现简洁，使用埃氏筛法预处理素数，同时预处理立方表，通过二分查找判断剩余数是否为立方数。
    - **个人心得**：无

- **作者：KesdiaelKen（4星）**
    - **关键亮点**：循序渐进地分析不同数据范围的解法，从简单枚举到结合枚举与二分，通过多个例子详细阐述思路，易于理解。
    - **个人心得**：总结了数论题的套路，强调思路要清晰，善于举例子，思考问题要循序渐进。

- **作者：ziiidan（4星）**
    - **关键亮点**：对筛掉 $x^{\frac{1}{4}}$ 以内约数后剩余数的情况进行了严谨证明，代码注释详细，方便理解。
    - **个人心得**：无

### 重点代码
#### hongzy 题解核心代码
```cpp
// 埃氏筛法
void prime() {        
    int sq = sqrt(n) + 0.5;
    for(int i=2; i<=n; i++) p[i] = true;
    p[1] = false;
    for(int i=2; i<=sq; i++) if(p[i])
        for(int j=i*i; j<=n; j+=i) p[j] = false;
    for(int i=1; i<=n; i++) if(p[i]) plist[++ cnt] = i;
}

int main() {
    prime(); // 预处理素数 
    for(LL i=1; i<=m; i++) pow3[i] = i*i*i; // 预处理立方表 
    int T; LL x; 
    scanf("%d", &T);
    while(T --) {
        LL ans = 1, c;
        scanf("%lld", &x);
        for(int i=1; i<=cnt && plist[i] <= x; i++) {
            c = 0;  // 记录此素因子的出现次数 
            while(x % plist[i] == 0) { // 此素数是因子 
                c ++; x /= plist[i];
                if(c == 3) ans *= plist[i], c = 0; // 每次出现素因子立方就累积到答案 
            }
        }
        LL k = lower_bound(pow3+1, pow3+m+1, x) - pow3; // 查看剩下的x是不是立方 
        printf("%lld\n", ans*(k*k*k == x ? k : 1)); 
    }
    return 0;
}
```
**核心实现思想**：先预处理素数表和立方表，对于每个输入的 $x$，筛去 $x^{\frac{1}{4}}$ 以内的素因子，每出现三次相同素因子就累乘到答案中，最后判断剩余的 $x$ 是否为立方数，若是则将其立方根乘到答案中。

#### KesdiaelKen 题解核心代码
```cpp
long long scf(long long a) { // 开三次方
    long long zuo=sqrt(sqrt(a)),you=min((long long)1000000,(long long)sqrt(a)),mid;
    while(zuo!=you) {
        mid=(zuo+you+1)/2;
        if(mid*mid*mid<=a)zuo=mid;
        else you=mid-1;
    }
    return zuo;
}

int main() {
    for(long long i=2;i<=32000;i++) { // Step 1
        if(!visit[i])zs[++gs]=i;
        for(long long j=1;j<=gs&&zs[j]*i<=32000;j++) {
            visit[zs[j]*i]=true;
            if(i%zs[j]==0)break;
        }
    }
    int lr;scanf("%d",&lr);
    while(lr--) {
        scanf("%lld",&shu);bj=sqrt(sqrt(shu));a=1;
        for(int i=1;i<=gs&&zs[i]<=bj;i++) { // Step 2
            b=0;
            while(shu%zs[i]==0) {
                shu/=zs[i];b++;
                if(b%3==0)a*=zs[i];
            }
        }
        b=scf(shu);if(b*b*b==shu)a*=b; // Step 3
        printf("%lld\n",a); // Step 4
    }
    return 0;
}
```
**核心实现思想**：先筛出小于 32000 的质数，对于每个输入的 $x$，筛去小于等于 $x^{\frac{1}{4}}$ 的质因数，每出现三次相同质因数就累乘到答案中，最后判断剩余的 $x$ 是否为立方数，若是则将其立方根乘到答案中。

#### ziiidan 题解核心代码
```cpp
void Euler(int num) { // 线性筛素数 
    check[1] = true;
    for(int i = 2; i <= num; i++) {
        if(!check[i]) prime[++cnt] = i;
        for(int j = 1; j <= cnt && i * prime[j] <= num; j++) {
            check[i * prime[j]] = true;
            if(i % prime[j] == 0) break;
        }
    }
}

int main() {
    n = read();
    for(register int i = 1; i <= maxn - 5; i++) p[i] = 1ll * i * i * i; // 完全立方数的预处理 
    Euler(maxm - 3); // 线性筛素数 
    for(; n; n--) {
        x = read();
        ans = 1;
        for(int i = 1; i <= cnt && prime[i] <= x; i++) { // 枚举小于等于 x 的四分之一次方的素数来去除部分因子 
            for(; x % prime[i] == 0; ) {
                x /= prime[i];
                tot++;
                if(tot == 3) { // 如果这个因子的指数达到了 3 那么他可以对答案产生贡献 
                    ans *= prime[i]; // 算上这部分贡献 
                    tot = 0; // 复原指数 
                }
            }
            tot = 0; // 复原指数 
        }
        int pos = lower_bound(p + 1, p + maxn - 4, x) - p; // 二分查找小于等于它的最大的完全平方数 
        if(p[pos] == x) cout << ans * pos << '\n'; // 如果等于，即此时的 x 为一个完全平方数， 要加上它开立方后的贡献 
        else cout << ans << '\n'; // 否则没有贡献 
    }
    return 0;
}
```
**核心实现思想**：先线性筛出素数，预处理完全立方数表，对于每个输入的 $x$，筛去 $x^{\frac{1}{4}}$ 以内的素因子，每出现三次相同素因子就累乘到答案中，最后二分查找判断剩余的 $x$ 是否为立方数，若是则将其立方根乘到答案中。

### 最优关键思路或技巧
- **预处理素数表**：减少后续素数判断的时间复杂度。
- **筛去 $x^{\frac{1}{4}}$ 以内素因子**：利用数的性质，减少不必要的计算。
- **二分查找判断立方数**：提高判断效率。

### 可拓展之处
同类型题可能会涉及更高次根式化简，或在不同数域下的因式分解问题。类似算法套路可用于解决其他数论问题，如分解质因数、判断完全平方数等。

### 推荐题目
- P1075 [NOIP2012 普及组] 质因数分解
- P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题
- P1306 斐波那契公约数

### 个人心得总结
- KesdiaelKen 总结了数论题的套路，强调思路要清晰，善于举例子，思考问题要循序渐进。
- _MRCMRC_ 分享了做题过程中的调试经历，从简单枚举到优化算法，不断尝试改进，最终通过更优秀的算法解决问题。
- critnos 分享了代码优化的过程，通过简单剪枝和避免不必要的计算，显著提高了代码效率。

---
处理用时：64.66秒
# 题目信息

# 偷上网

## 题目描述

Alice 和 Bob 生活在一个 $l \times l$ 的正方形房子里，由于 Bob 最近沉迷隔膜，Alice 决定要限制 Bob 上网的频率。

Alice 建造了 $n$ 个无线信号屏蔽器，第 $i$ 个位于 $(x_i, y_i)$，屏蔽范围为 $\frac{l}{n}$。

Bob 网瘾发作按捺不住上网的冲动，找到了你，帮他找到一个位置 $(x, y)$，使得没有被 Alice 的无线信号屏蔽器覆盖。

## 样例 #1

### 输入

```
1 1
0.000 0.000```

### 输出

```
0.999 0.999```

## 样例 #2

### 输入

```
1 2
1.000 1.000```

### 输出

```
GG```

## 样例 #3

### 输入

```
2 2
0.000 0.000
2.000 2.000```

### 输出

```
1.000 1.000```

# AI分析结果

### 综合分析与结论
这些题解主要围绕在正方形区域内寻找未被圆覆盖的点展开，多数采用随机算法，部分使用模拟退火算法。随机算法通过不断随机生成点并判断其是否在圆内来寻找符合条件的点；模拟退火算法则是在随机的基础上，以一定概率接受更差的解，从而跳出局部最优。各题解的差异主要体现在随机数的生成方式、随机次数的设定以及判断点是否在圆内的具体实现上。

### 所选题解
- **作者：Garen (赞：17)  ★★★★**
    - **关键亮点**：思路清晰，代码简洁，详细介绍了随机算法的实现和随机数的生成方法，且提到了随机算法的优点和种子的选择方式。
    - **个人心得**：随机算法即使运算100000次也根本不会超时，发现100000次还WA了一个点，直接再添一个0就可以，并不会慢太多。

### 重点代码
```cpp
#include<cstdio>
#include<cmath>
#include<cstdlib>
using namespace std;
const int maxn = 15;
double x[maxn], y[maxn];
double n, l;
int main()
{
    srand(19260817);
    scanf("%lf%lf", &n, &l);
    for(int i = 1; i <= n; i++) scanf("%lf%lf", &x[i], &y[i]);
    for(int i = 1; i <= 1000000; i++)
    {
        double tx = rand(), ty = rand();
        while(tx > l) tx /= 10;
        while(ty > l) ty /= 10;
        bool ok = true;
        for(int j = 1; j <= n; j++)
        {
            if(pow(tx - x[j], 2) + pow(ty - y[j], 2) < pow(l / n, 2))
            {
                ok = false;
                break;
            }
        }
        if(ok)
        {
            printf("%.3lf %.3lf\n", tx, ty);
            return 0;
        }
    }
    printf("GG\n");
    return 0;
}
```
**核心实现思想**：先初始化随机数种子，然后读取输入数据。接着进行1000000次随机，每次随机生成一个点，判断该点是否在所有圆的覆盖范围之外，如果是则输出该点并结束程序，若1000000次都未找到则输出“GG”。

### 最优关键思路或技巧
- **随机算法**：对于此类寻找满足条件的点的问题，随机算法是一种简单有效的方法，通过大量随机尝试可以在较短时间内找到解。
- **随机数种子的选择**：可以选择一些特殊的数作为随机数种子，增加随机性，让出题人难以hack。

### 可拓展之处
同类型题或类似算法套路：在二维平面上寻找满足特定条件的点的问题，都可以考虑使用随机算法或模拟退火算法。例如在给定多个障碍物的地图中寻找一条可行路径，或者在多个圆形区域内寻找一个未被覆盖的最大圆形等问题。

### 推荐题目
- P1652 圆
- P2313 汤姆的游戏
- P4703 偷上网（本题）

---
处理用时：24.42秒
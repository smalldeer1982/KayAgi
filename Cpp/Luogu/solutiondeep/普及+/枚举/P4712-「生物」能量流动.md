# 题目信息

# 「生物」能量流动

## 题目描述

生物课上，小 F 学习到了食物链、食物网的相关内容。

他学到，能量是逐级递减的。比如在食物链上，两个链接起来的生物 $A \rightarrow B$（意思是 $B$ 吃 $A$）之间的能量传递效率最多只有 $\frac 1 5$；而研究种间关系，能够使能量流向对人类最有益的部分。

现在，小 F 想研究一下能量流动的关系，于是他在脑海里创造了一个生态的系统。

在这个生态的系统里，有 $n+2$ 种生物，其中 $0$ 是生产者，整个生态系统所流经的能量由它固定；你是贪婪的顶级掠食者 $n + 1$，可以捕食所有生物；其他的掠食者 $[1, n]$ 各有各的喜好，只会捕食编号在 $[0, r_i]$ 的生物。由于天然形成的强弱顺序，上述关系满足 $r_i \leq r_{i + 1}(1 \leq i < n),$ $r_i < i(1 \leq i \leq n)$。

每种动物需要摄取至少 $a_i$ 单位能量才能存活；一个生物摄取到的能量可以传递给捕食者，但传递效率都不超过 $\frac 1 5$。也就是说，假设该动物捕获了 $b_i$ 单位的能量，所有捕食它的掠食者得到的能量总和 $c_i$，那么有：
* $b_i \geq a_i$
* $c_i \leq \frac 1 5 b_i$

你希望知道，在所有生物都存活的情况下，在最优情况下你能获取到的最大能量是多少。

## 说明/提示

### 样例 1 解释

最优情况下：
* 1 号掠食者捕食生产者 0，捕食 5 点能量，传递效率为 $\frac 1 5$，得到 1 点能量。
* 2 号掠食者捕食生产者 0，捕食 4 点能量，传递效率为 $\frac 1 5$，得到 0.8 点能量。
* 2 号掠食者捕食掠食者 1，捕食 1 点能量，传递效率为 $\frac 1 5$，得到 0.2 点能量。

可怜的你只能捕获 2 号掠食者的能量，捕食 1 点能量，得到 0.2 点能量。

### 样例 2, 3 解释

由于 2 号掠食者开始减肥不吃肉了（也有可能是打不过 1 了），所以所需的生产者能量从 9 点变成了 10 点。

### 子任务

子任务 $1(21 \mathrm{pts}) : n \leq 100$；

子任务 $2(89 \mathrm{pts}) : n \leq 10 ^ 5$。

## 样例 #1

### 输入

```
2 9
1 0
1 1```

### 输出

```
0.2000000```

## 样例 #2

### 输入

```
2 9
1 0
1 0```

### 输出

```
-1```

## 样例 #3

### 输入

```
2 10
1 0
1 0```

### 输出

```
0.4000000```

# AI分析结果

### 综合分析与结论
本题主要围绕生态系统中能量流动问题，需在满足所有生物存活的条件下，求出顶级掠食者能获取的最大能量。各题解核心思路均为贪心策略，即让每种生物尽量从最小等级的生物获取能量，减少能量传递损耗。

### 评分较高的题解
- **作者：caidd（5星）**
    - **关键亮点**：思路清晰，代码注释详细，使用 `vis` 数组优化，避免重复遍历能量为零的低等级生物，时间复杂度低。
    - **核心代码**：
```cpp
for(R int i=1;i<=n;++i)
{
    k=read(),d[i]=k,r=read();
    for(int j=vis/*vis记录最小*/;j<=r;++j)
    {
        if(!d[j]) vis=j;
        if(d[j]*0.2>=k) {d[j]=(d[j]-(k*5));k=0;break;}
        else k=(k-d[j]*0.2),d[j]=0;
    }
    if(k>0) {cout<<"-1"<<endl;return 0;}
}
for(int i=vis;i<=n;++i) sum+=d[i]*0.2;
```
    - **核心思想**：遍历每种生物，从 `vis` 开始寻找可捕食的生物，若能量足够则满足需求，不足则继续寻找，最后累加剩余生物的能量。

- **作者：qqvq（4星）**
    - **关键亮点**：利用 $r_i≤r_{i + 1}$ 的性质，用指针记录扫到的位置，维护前缀和，代码简洁，复杂度为 $O(n)$。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; ++i) {
    scanf("%d %d", a+i, &b);
    for(j = last+1; j <= b; ++j) pre+=a[j]; last = j-1;
    pre -= a[i] * 5; 
    if (pre < 0) return puts("-1"), 0;
}
for(int i = last+1; i <= n; ++i) pre += a[i];
printf("%lf", pre/5.0);
```
    - **核心思想**：遍历每种生物，更新前缀和，减去当前生物所需能量，若前缀和小于零则无解，最后输出剩余能量的五分之一。

- **作者：star_magic_young（4星）**
    - **关键亮点**：同样利用 $r_i$ 单调不减的性质，将下标在 $r_i$ 之前的能量加在一起，每次处理 $i$ 时更新总能量，复杂度为 $O(n)$。
    - **核心代码**：
```cpp
for(int h=1;h<=n;h++)
{
    int x=rd(),y=rd();
    while(p<=y) a+=b[p++];
    if(a/5-(double)x<-eps) {p=-1;break;}
    a-=x*5;
    b[h]=x;
}
if(p<0) puts("-1");
else
{
    for(;p<=n;p++) a+=b[p];
    printf("%.9lf\n",a/5);
}
```
    - **核心思想**：遍历每种生物，累加能量，判断是否满足需求，不满足则无解，最后输出剩余能量的五分之一。

### 最优关键思路与技巧
- **贪心策略**：让每种生物尽量从最小等级的生物获取能量，减少能量传递次数，从而使顶级掠食者获得最大能量。
- **利用单调性优化**：利用 $r_i≤r_{i + 1}$ 的性质，用指针记录扫到的位置，维护前缀和，避免重复计算，将时间复杂度优化到 $O(n)$。

### 可拓展之处
同类型题可能涉及不同的能量传递规则或生物关系，可使用类似的贪心策略，结合数据结构（如线段树、树状数组）进行优化。

### 推荐题目
- P1223 排队接水：贪心算法，通过合理安排顺序使总等待时间最短。
- P1090 合并果子：贪心算法，每次合并最小的两堆果子，使总代价最小。
- P1803 凌乱的yyy / 线段覆盖：贪心算法，选择结束时间最早的线段，使覆盖的线段数最多。

### 个人心得摘录与总结
- **作者：philosopherchang**：强调不要用 `float` 类型，否则会出现 `Unknown error`，提醒在处理浮点数时要注意精度问题。
- **作者：ViXbob**：表示自己只能想出复杂度为 $O(nlog^2n)$ 的算法，欢迎讨论更好的方法，体现了对算法优化的追求。
- **作者：star_magic_young**：认为其他做法过于复杂，本题可做到 $O(n)$ 复杂度，提醒我们在解题时要寻找更优的解法。

---
处理用时：33.63秒
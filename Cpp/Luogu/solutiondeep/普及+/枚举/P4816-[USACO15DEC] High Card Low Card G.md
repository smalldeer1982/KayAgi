# 题目信息

# [USACO15DEC] High Card Low Card G

## 题目描述

奶牛 Bessie 是卡牌游戏的狂热爱好者，尽管她没有对生拇指，但这并不影响她的热情。遗憾的是，她的同伴们在卡牌游戏方面水平堪忧，甚至出牌顺序都完全可预测！尽管如此，Bessie 仍需精心策划才能获胜。

Bessie 和她的朋友 Elsie 正在玩一个简单的卡牌游戏。她们使用一副包含 $2N$ 张卡牌的牌组（编号为 $1 \ldots 2N$），并将牌分成各 $N$ 张。随后进行 $N$ 轮比赛：每轮双方各打出一张牌。在前 $N/2$ 轮中，打出较大数字的玩家得 1 分；在后 $N/2$ 轮中，规则反转，打出较小数字的玩家得 1 分。

已知 Bessie 可以预知 Elsie 每轮出牌的顺序，请计算 Bessie 能够获得的最大分数。

## 说明/提示

在此样例中，Bessie 手中的卡牌为 $2$、$5$、$6$ 和 $7$。她可以通过在比赛后半段保留 $2$ 这张牌，从而最多获得 2 分。

题目提供者：Brian Dean

## 样例 #1

### 输入

```
4
1
8
4
3
```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解均采用贪心算法解决问题，核心思路是将游戏分为前半段（牌大获胜）和后半段（牌小获胜）两部分，分别对 Elsie 和 Bessie 的牌进行排序，然后通过比较出牌来争取最大得分。各题解在具体实现上略有差异，如存储牌的方式、排序顺序、比较逻辑等，但整体思路一致。

### 所选题解
- **liyilin2004 的题解（4星）**
  - **关键亮点**：思路清晰，代码简洁易懂，通过标记数组区分 Elsie 和 Bessie 的牌，分别处理前半段和后半段的比较逻辑。
  - **核心代码**：
```cpp
for(int i=1;i<=n/2;i++)
{
    cin>>a[i];
    b[a[i]]=1;
}
for(int i=1;i<=n/2;i++)
{
    cin>>c[i];
    b[c[i]]=1;
}
sort(a+1,a+1+n/2);
sort(c+1,c+1+n/2);
int j=2*n;
for(int i=n/2;i>=1;i--)
{
    while(b[j]&&j>=1)
        j--;
    if(j<a[i])
        continue;
    else
        b[j]=1,ans++;
}
j=1;
for(int i=1;i<=n/2;i++)
{
    while(b[j]&&j<=2*n)
        j++;
    if(j>c[i])
        continue;
    else
        b[j]=1,ans++;
}
```
  - **核心实现思想**：先将 Elsie 的牌读入并标记，然后对前半段和后半段的牌分别排序。对于前半段，从大到小枚举 Elsie 的牌，找到 Bessie 未用的最大牌进行比较；对于后半段，从小到大枚举 Elsie 的牌，找到 Bessie 未用的最小牌进行比较。

- **onepeople666 的题解（4星）**
  - **关键亮点**：详细阐述了解题步骤，将贪心思路与田忌赛马进行类比，易于理解，通过自定义比较函数实现不同的排序顺序。
  - **核心代码**：
```cpp
bool cmp(int a,int b)
{
    return a>b;
}
sort(e+1,e+n/2+1,cmp);
sort(e+n/2+1,e+n+1);
c=n/2+1,v=n;
for(int i=1; i<=n/2; i++) 
{
    if(b[v]>e[i])
        ans++,v--;
    else
        c++;
}
c=n/2,v=1;
for(int i=n/2+1; i<=n; i++)
{
    if(b[v]<e[i])
        ans++,v++;
    else
        c--;
}
```
  - **核心实现思想**：先将 Elsie 的牌读入并标记，然后将 1 到 2n 中未标记的牌存入 Bessie 的牌数组。对 Elsie 的前半段牌从大到小排序，后半段牌从小到大排序。使用两个指针分别记录 Bessie 最小和最大的牌，在前半段中用最大的牌与 Elsie 比较，若赢则得分并移动指针，否则用最小的牌“怼掉”；后半段同理。

- **__Hacheylight__ 的题解（4星）**
  - **关键亮点**：代码规范，使用宏定义简化代码，对贪心思路进行了正确性证明，逻辑严谨。
  - **核心代码**：
```cpp
sort(a + 1, a + n / 2 + 1, cmp1); sort(a + n / 2 + 1, a + n + 1, cmp2);
rep(i, 1, n) app[a[i]] = 1;
per(i, n * 2, 1) if (!app[i]) b[++cnt] = i;
sort(b + 1, b + n / 2 + 1, cmp1); sort(b + n / 2 + 1, b + n + 1, cmp2);
int l = 1, r = n / 2, ll = 1, rr = n / 2;
while (l <= r && ll <= rr) {
    if (a[l] < b[ll]) {
        l++, ll++, ans++;
    }
    else {
        l++, rr--;
    }
}
l = n / 2 + 1, r = n, ll = n / 2 + 1, rr = n;
while (l <= r && ll <= rr) {
    if (a[l] > b[ll]) {
        l++, ll++, ans++;
    }
    else {
        l++, rr--;
    }
}
```
  - **核心实现思想**：先将 Elsie 的牌读入并排序，前半段从大到小，后半段从小到大。标记 Elsie 的牌，找出 Bessie 的牌并同样排序。使用双指针分别对前半段和后半段进行比较，若能赢则得分并移动指针，否则用“最劣马”怼掉“良马”。

### 最优关键思路或技巧
- **贪心策略**：前半段用较大的牌，后半段用较小的牌，并且在比较时尽量让每张牌发挥最大作用，类似于田忌赛马的思想。
- **标记数组**：使用标记数组区分 Elsie 和 Bessie 的牌，方便查找和使用。
- **排序优化**：对 Elsie 和 Bessie 的牌进行合理排序，便于贪心比较。

### 可拓展之处
同类型题或类似算法套路：
- **其他博弈类问题**：如石子游戏、取数游戏等，通常可以采用贪心或动态规划的思想。
- **区间问题**：涉及区间的选择和比较，需要根据具体规则制定贪心策略。

### 推荐题目
- [P1650 田忌赛马](https://www.luogu.com.cn/problem/P1650)
- [P3129 [USACO15DEC]High Card Low Card S](https://www.luogu.com.cn/problem/P3129)
- [P6179 [USACO16OPEN]Diamond Collector S](https://www.luogu.com.cn/problem/P6179)

### 个人心得摘录与总结
- **Level_Down**：直接暴力判断会有 2 个点超时，通过对对方手牌的前半部分从小到大排序，后半部分从大到小排序进行优化。总结：在遇到超时问题时，要分析算法的时间复杂度，通过合理排序等方法进行优化。
- **MC_Launcher**：在打代码时，不仅要知道算法是对的，更要知道为什么是对的，知其然，更要知其所以然。总结：对于算法题，要深入理解算法的正确性，这样才能更好地运用和优化算法。

---
处理用时：46.78秒
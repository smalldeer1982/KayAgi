# 题目信息

# 大师

## 题目背景

建筑大师最近在跟着数学大师 ljt12138 学数学，今天他学了等差数列，ljt12138 决定给他留一道练习题。

## 题目描述

ljt12138 首先建了 $n$ 个特斯拉电磁塔，这些电塔排成一排，从左到右依次标号为 $1$ 到 $n$，第 $i$ 个电塔的高度为 $h[i]$。

建筑大师需要从中选出一些电塔，然后这些电塔就会缩到地下去。这时候，如果留在地上的电塔的高度，从左向右构成了一个等差数列，那么这个选择方案就会被认为是美观的。

建筑大师需要求出，一共有多少种美观的选择方案，答案模 $998244353$。

注意，如果地上只留了一个或者两个电塔，那么这种方案也是美观的。地上没有电塔的方案被认为是不美观的。

同时也要注意，等差数列的公差也可以为负数。

## 说明/提示

设 $v$ 为最高的电塔高度。

对于前 $30\%$ 的数据，$n \le 20 $。

对于前 $60\%$ 的数据，$n \le 100$，$v \le 2 \times 10^3$。

对于另外 $20\%$ 的数据，所有电塔的高度构成一个等差数列。

对于 $100\%$ 的数据，$n \le 10^3$，$v \leq2 \times 10^4$。

## 样例 #1

### 输入

```
8
13 14 6 20 27 34 34 41 
```

### 输出

```
50
```

## 样例 #2

### 输入

```
100
90 1004 171 99 1835 108 81 117 141 126 135 144 81 153 193 81 962 162 1493 171 1780 864 297 180 532 1781 189 1059 198 333 1593 824 207 1877 216 270 225 1131 336 1875 362 234 81 288 1550 243 463 1755 252 406 261 270 279 288 1393 261 1263 297 135 333 872 234 881 180 198 81 225 306 180 90 315 81 81 198 252 81 297 1336 1140 1238 81 198 297 661 81 1372 469 1132 81 126 324 333 342 81 351 481 279 1770 1225 549 
```

### 输出

```
11153
```

# AI分析结果

### 综合分析与结论
本题主要求解从给定的电塔高度序列中选出构成等差数列的子序列的方案数。各位大神的题解主要围绕动态规划展开，通过不同的状态定义和转移方式来解决问题，时间复杂度从 $O(2^n * n)$ 到 $O(n^2)$ 不等。

### 所选题解
- **作者：chengni (赞：261)，4星**
  - **关键亮点**：思路清晰，直接枚举第 $i$ 个数前面的数得到公差进行转移，避免了枚举公差，时间复杂度为 $O(n^2)$，代码简洁。
  - **个人心得**：“我感觉我被题解限制了思路，其实这道题是 $O(n^2)$ 的”，体现了突破常规思维的重要性。
- **作者：Ivystorm (赞：55)，4星**
  - **关键亮点**：同样采用二维 DP，通过枚举当前点和前面转移点，去除了标准 60 分题解的 $k$，复杂度为 $O(n^2)$，代码实现较为巧妙。
- **作者：魂逝_秦月歌 (赞：39)，4星**
  - **关键亮点**：状态定义和转移方程明确，代码中包含了快速幂等模板，虽然模板部分可忽略，但整体逻辑清晰。

### 重点代码及核心实现思想
#### chengni 的题解
```cpp
int p = 20000;
for(int i = 1; i <= n; i++){
    ans++;
    for(int j = i - 1; j; j--){
        f[i][a[i] - a[j] + p] += f[j][a[i] - a[j] + p] + 1;
        f[i][a[i] - a[j] + p] %= mod;
        ans += f[j][a[i] - a[j] + p] + 1;
        ans %= mod;
    }
}
```
**核心思想**：用 $f[i][j]$ 表示以 $i$ 结尾公差为 $j$ 的等差数列个数，通过枚举 $i$ 前面的数 $j$ 得到公差，更新 $f$ 数组和答案。

#### Ivystorm 的题解
```cpp
void getx(int nowi){
    for(int i = nowi - 1; i >= 1; i--){
        if(!vis[i][num[i] - num[nowi] + 20200]){
            f[i][num[i] - num[nowi] + 20200]++;
            vis[i][num[i] - num[nowi] + 20200] = 1;
        }
        ans = (long long)(ans + f[i][num[i] - num[nowi] + 20200]) % 998244353;
        f[nowi][num[i] - num[nowi] + 20200] = (long long)(f[nowi][num[i] - num[nowi] + 20200] + f[i][num[i] - num[nowi] + 20200]) % 998244353;
    }
}
```
**核心思想**：$f[i][j]$ 表示第 $i$ 个点之前（包括自己）公差为 $j$ 的数列长度，通过枚举当前点和前面转移点，更新答案和 $f$ 数组。

#### 魂逝_秦月歌的题解
```cpp
for(int i = 1; i <= n; i++) {
    ans = (ans + i) % mod;
    for(int j = i - 1; j >= 1; j--) {
        now = a[i] - a[j];
        ans = (ans + f[j][now + N]) % mod;
        f[i][N + now] = (f[i][now + N] + f[j][now + N] + 1) % mod;
    }
}
```
**核心思想**：$f[i][j]$ 表示等差数列最后一个数位置为 $i$，等差数列差值为 $j$ 的数列个数，通过枚举 $i$ 和 $j$ 得到公差，更新答案和 $f$ 数组。

### 最优关键思路或技巧
- **状态定义**：多数题解采用二维 DP，通过不同的状态定义来表示等差数列的信息，如以某个点结尾、公差为某个值的等差数列个数。
- **避免枚举公差**：直接枚举前面的数得到公差，避免了枚举所有可能的公差，将时间复杂度从 $O(nv)$ 优化到 $O(n^2)$。
- **处理负数下标**：通过将数组下标加上一个偏移量，避免了负数下标带来的问题。

### 可拓展之处
同类型题可能会改变数据范围、增加条件或改变问题形式，但动态规划的核心思想不变。例如，可以考虑在二维平面上的点中找出构成等差数列的点集，或者在有多个属性的序列中找出满足特定条件的等差数列子序列。

### 推荐洛谷题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)：简单的 0 - 1 背包问题，考察动态规划的基本思想。
2. [P1216 [USACO1.5] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：经典的动态规划入门题，通过状态转移求解路径最大值。
3. [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)：完全背包问题，进一步巩固动态规划的应用。

### 个人心得总结
- chengni 提到被题解限制思路，提醒我们在解题时要敢于突破常规，尝试不同的方法。
- zrzluck99 提到公差可能重复，f 数组和 s 数组的计算需要叠加，这是调试过程中需要注意的细节。

---
处理用时：40.15秒
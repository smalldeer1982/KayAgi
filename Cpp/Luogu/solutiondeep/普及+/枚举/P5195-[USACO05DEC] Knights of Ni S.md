# 题目信息

# [USACO05DEC] Knights of Ni S

## 题目描述

贝茜遇到了一件很麻烦的事：她无意中闯入了森林里的一座城堡，如果她想回家，就必须穿过这片由骑士们守护着的森林。为了能安全地离开，贝茜不得不按照骑士们的要求，在森林寻找一种特殊的灌木并带一棵给他们。

当然，贝茜想早点离开这可怕的森林，于是她必须尽快完成骑士们给的任务，贝茜随身带着这片森林的地图，地图上的森林被放入了直角坐标系，并按 $x,y $ 轴上的单位长度划分成了 $ W \times H\  ( 1 \leq W,H \leq 1000 )$ 块，贝茜在地图上查出了她自己以及骑士们所在的位置，当然地图上也标注了她所需要的灌木生长的区域。某些区域是不能通过的（比如说沼泽地，悬崖，以及食人兔的聚居地）。在没有找到灌木之前，贝茜不能通过骑士们所在的那个区域，为了确保她自己不会迷路，贝茜只向正北、正东、正南、正西四个方向移动（注意，她不会走对角线）。她要走整整一天，才能从某块区域走到与它相邻的那块区域。

贝茜希望你能帮她计算一下，她最少需要多少天才可脱离这可怕的地方？输入数据保证贝茜一定能完成骑士的任务。

## 说明/提示

这片森林的长为 $8$，宽为 $4$．贝茜的起始位置在第 $3$ 行，离骑士们不远。

贝茜可以按这样的路线完成骑士的任务：北，西，北，南，东，东，北，东，东，南，南。她在森林的西北角得到一株她需要的灌木，然后绕过障碍把它交给在东南方的骑士。

## 样例 #1

### 输入

```
8 4
4 1 0 0 0 0 1 0
0 0 0 1 0 1 0 0
0 2 1 1 3 0 4 0
0 0 0 4 1 1 1 0
```

### 输出

```
11```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何在给定地图中找到从起点经过灌木丛再到终点的最短路径展开，大多采用广度优先搜索（BFS）或分层图最短路算法。各题解的核心思路都是将问题拆解为起点到灌木丛、灌木丛到终点两部分，通过不同方式计算这两段路径之和的最小值。

### 所选题解
- **作者：Wenoide（5星）**
  - **关键亮点**：只需一次 BFS，通过增加状态维度 `dis(x,y,0)` 和 `dis(x,y,1)` 分别表示未取得灌木和已取得灌木的最短时间，减少搜索次数，代码简洁高效。
- **作者：vеctorwyx（4星）**
  - **关键亮点**：思路清晰，采用两次 BFS 分别从起点和终点出发，详细说明了搜索过程中的注意事项，如标记灌木丛和恢复状态等。
  - **个人心得**：作者表示被这道题坑了很久，一开始标记灌木丛为障碍、忘记恢复状态等，最后发现其实就是简单的广搜，不要想太多。
- **作者：那一条变阻器（4星）**
  - **关键亮点**：使用分层图最短路算法，在找到灌木时向骑士那一层连边，从起点跑一遍最短路即可，提供了不同的解题思路。

### 重点代码及核心思想
#### Wenoide 的题解
```cpp
// 增加状态维度 dis(x,y,0) 和 dis(x,y,1) 分别表示未取得灌木和已取得灌木的最短时间
int dis[MAXN][MAXN][2];
bool vis[MAXN][MAXN][2];
// BFS 过程中更新状态
while(l!=r){
    Node t=que[l++];
    int x=t.x,y=t.y;
    bool tag=t.tag;
    if(x==ex&&y==ey&&tag){
        break;
    }
    for(int i=0;i<4;++i){
        int u=x+dx[i],v=y+dy[i];
        bool w=tag||(map[u][v]==4);
        if(!vis[u][v][w]&&map[u][v]!=1){
            dis[u][v][w]=dis[x][y][tag]+1;
            vis[u][v][w]=true;
            que[r++]=make(u,v,w);
        }
    }
}
```
核心思想：通过一次 BFS，在搜索过程中根据是否取得灌木更新状态，避免了多次搜索。

#### vеctorwyx 的题解
```cpp
// 第一次 BFS 从起点出发
while(!q.empty()){
    qwq=q.front();
    if(a[qwq.x][qwq.y]==4&&ji1[qwq.x][qwq.y]==0){
        ji1[qwq.x][qwq.y]=qwq.tim;
        a[qwq.x][qwq.y]=0;
        q.pop();
        continue;
    }
    for(int i=1;i<=4;i++){
        qwq=q.front();
        qwq.x+=dx[i];
        qwq.y+=dy[i];
        qwq.tim++;
        if(qwq.x>0&&qwq.x<=n&&qwq.y>0&&qwq.y<=m&&(a[qwq.x][qwq.y]==0||a[qwq.x][qwq.y]==4)&&b[qwq.x][qwq.y]==0){
            q.push(qwq);
            b[qwq.x][qwq.y]=1;
        }
    }
    q.pop();
}
// 第二次 BFS 从终点出发
while(!q.empty()){
    qwq=q.front();
    if(a[qwq.x][qwq.y]==4&&ji2[qwq.x][qwq.y]==0){
        ji2[qwq.x][qwq.y]=qwq.tim;
        a[qwq.x][qwq.y]=0;
        q.pop();
        continue;
    }
    for(int i=1;i<=4;i++){
        qwq=q.front();
        qwq.x+=dx[i];
        qwq.y+=dy[i];
        qwq.tim++;
        if(qwq.x>0&&qwq.x<=n&&qwq.y>0&&qwq.y<=m&&(a[qwq.x][qwq.y]!=1)&&b[qwq.x][qwq.y]==0){
            q.push(qwq);
            b[qwq.x][qwq.y]=1;
        }
    }
    q.pop();
}
```
核心思想：通过两次 BFS 分别计算起点和终点到灌木丛的最短路径，最后枚举灌木丛取最短路径之和。

#### 那一条变阻器的题解
```cpp
// 建图
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++){
        if(a[i][j] == 1) continue;
        if(a[i][j] == 2) s = id(i , j);
        if(a[i][j] == 3) p = id(i , j);
        if(a[i][j] == 4) add(id(i , j) , id(i , j) + n * m);
        if((a[i - 1][j] == 0 || a[i - 1][j] == 2 || a[i - 1][j] == 4) && i != 1) add(id(i , j) , id(i - 1 , j));
        if((a[i + 1][j] == 0 || a[i + 1][j] == 2 || a[i + 1][j] == 4) && i != n) add(id(i , j) , id(i + 1 , j));
        if((a[i][j - 1] == 0 || a[i][j - 1] == 2 || a[i][j - 1] == 4) && j != 1) add(id(i , j) , id(i , j - 1));
        if((a[i][j + 1] == 0 || a[i][j + 1] == 2 || a[i][j + 1] == 4) && j != m) add(id(i , j) , id(i , j + 1));
        if((a[i - 1][j] == 0 || a[i - 1][j] == 2 || a[i - 1][j] == 4 || a[i - 1][j] == 3) && i != 1) add(id(i , j) + n * m , id(i - 1 , j) + n * m);
        if((a[i + 1][j] == 0 || a[i + 1][j] == 2 || a[i + 1][j] == 4 || a[i + 1][j] == 3) && i != n) add(id(i , j) + n * m , id(i + 1 , j) + n * m);
        if((a[i][j - 1] == 0 || a[i][j - 1] == 2 || a[i][j - 1] == 4 || a[i][j - 1] == 3) && j != 1) add(id(i , j) + n * m , id(i , j - 1) + n * m);
        if((a[i][j + 1] == 0 || a[i][j + 1] == 2 || a[i][j + 1] == 4 || a[i][j + 1] == 3) && j != m) add(id(i , j) + n * m , id(i , j + 1) + n * m);
    }
// SPFA 求最短路
spfa(s);
```
核心思想：构建分层图，在找到灌木时向骑士那一层连边，通过 SPFA 算法从起点跑一遍最短路。

### 最优关键思路或技巧
- **状态压缩**：如 Wenoide 的题解，通过增加状态维度减少搜索次数。
- **分层图**：使用分层图最短路算法，将问题转化为图论问题，提供不同的解题思路。
- **双向搜索**：部分题解采用双向 BFS，降低搜索树的规模，提高效率。

### 拓展思路
同类型题可参考有中间点的最短路问题，如在有向图中求经过特定中间点的最短路径。类似算法套路包括增加状态维度、构建分层图、双向搜索等，可根据具体问题灵活运用。

### 推荐题目
- P1144 最短路计数
- P1608 路径统计
- P3371 单源最短路径（弱化版）

---
处理用时：61.33秒
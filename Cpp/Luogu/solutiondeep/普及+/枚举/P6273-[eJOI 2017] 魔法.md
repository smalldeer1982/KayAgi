# 题目信息

# [eJOI 2017] 魔法

## 题目描述

给定一个长度为 $n$ 的字符串 $S$。设 $S$ 中不同的字符数为 $k$ 。

定义字符串的子串为该字符串某一连续段。

而 ***有魔法的子串*** 被定义为 $S$ **的某一非空子串，满足该子串中不同的字符数为** $k$ **，且每个字符的出现的次数都相同**。

你需要求出给定字符串 $S$ 的不同的 有魔法的子串 的个数。

若两个子串的左右端点不同，则这两个子串不同。

## 说明/提示

#### 【输入输出样例解释】

**样例 1 解释**

- 满足条件的子串有： $\texttt{abc},\texttt{cba},\texttt{abc},\texttt{abccba}$

**样例 2 解释**

- 仅子串 $\texttt{abcABC}$ 为 有魔法的子串（区分大小写，即 $\texttt{a}\ne \texttt{A}$）。

**样例 3 解释**

- 其中一个是 $\texttt{SwSwwS}$。

#### 【数据规模与约定】

**本题采用多测试点捆绑测试，共有 4 个子任务**。

- Subtask 1（10 points）：$2\le n\le 100$。
- Subtask 2（20 points）：$2\le n\le 2\times 10^3$。
- Subtask 3（30 points）：$2\le n\le 10^5,k=2$ （即 $S$ 中只有两种字符）。
- Subtask 4（40 points）：无其他限制。

对于所有数据，保证 $2\le n\le 10^5$，字符集为 $ [\texttt{a},\texttt{z}] \cup [\texttt{A},\texttt{Z}]$

#### 【说明】

原题来自：[eJOI 2017](www.ejoi.org) Problem A [Magic](http://ejoi.org/wp-content/themes/ejoi/assets/pdfs/tasks_day_1/EN/magic_statement-en.pdf)

翻译提供：@[```_Wallace_```](https://www.luogu.com.cn/user/61430)

## 样例 #1

### 输入

```
8
abccbabc```

### 输出

```
4```

## 样例 #2

### 输入

```
7
abcABCC```

### 输出

```
1```

## 样例 #3

### 输入

```
20
SwSSSwwwwSwSwwSwwwwS```

### 输出

```
22```

# AI分析结果

### 综合分析与结论
这些题解围绕求字符串中有魔法的子串个数展开，核心在于判断子串中不同字符数为 $k$ 且各字符出现次数相同。多数题解采用前缀和思想，通过对前缀和进行变形和处理，将问题转化为判断某些值是否相等，再利用 `map` 或哈希表统计满足条件的子串数量。不同题解在具体实现和优化程度上有所差异，部分题解还针对不同子任务给出了特定的优化策略。

### 所选题解
- **作者：5k_sync_closer (4星)**
  - **关键亮点**：思路清晰，提供小常数 $O(nk\log n)$ 实现，代码简洁，对细节处理有详细说明。
  - **个人心得**：感觉其他题解都把代码写复杂了。

### 重点代码
```cpp
#include <bits/stdc++.h>
#define h(x) lower_bound(a, a + k, x) - a
using namespace std;
vector<int> v;map<vector<int>, int> m;
int n, k;long long q;char a[100050], s[100050];
int main()
{
    scanf("%d%s", &n, s);strcpy(a, s);sort(a, a + n);
    m[v = vector<int>(k = unique(a, a + n) - a, 0)] = 1;
    for (int i = 0; i < n; ++i)
    {
        if (s[i] != a[0]) ++v[h(s[i])];
        else {for (auto &x : v) --x;++v[0];}
        (q += m[v]++) %= 1000000007;
    }
    return printf("%lld", q), 0;
}
```
**核心实现思想**：维护前缀和，将字符离散化，用 `map<vector<int>, int>` 存储状态。正序枚举 $r$，计算 $v_r$ 后，将答案加上 `map` 中 $v_r$ 的个数，再将 $v_r$ 加入 `map`。

### 最优关键思路或技巧
- **前缀和变形**：通过对前缀和进行变形，将判断子串是否有魔法转化为判断某些值是否相等，简化了判断过程。
- **利用 `map` 或哈希表**：用 `map` 或哈希表存储状态，方便统计满足条件的子串数量，时间复杂度较低。
- **离散化**：将字符离散化，方便作为数组下标使用。

### 可拓展之处
同类型题可能涉及其他字符串子串的性质判断，如子串中字符的特定排列、字符频率的特定关系等。类似算法套路包括利用前缀和、哈希表等数据结构，通过对条件的变形和转化来简化问题。

### 推荐题目
- P1117 [NOI2016] 优秀的拆分
- P2587 [ZJOI2008] 泡泡堂
- P3181 [HAOI2016] 找相同字符

### 个人心得摘录与总结
- **5k_sync_closer**：认为其他题解代码写复杂了，强调自己题解的简洁性。这提醒我们在解题时要注重代码的简洁性和效率，避免不必要的复杂实现。
- **chenxia25**：忘记取模且模数抄错多次，交了好几发才过。这告诫我们在做题时要仔细，注意题目中的细节要求，如取模等。 

---
处理用时：28.53秒
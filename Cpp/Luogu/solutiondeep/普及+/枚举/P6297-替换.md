# 题目信息

# 替换

## 题目描述

Daniel13265 有一串由各种漂亮的贝壳组成的项链，但由于各种原因，这个项链不是环形的，而仅仅是用一根普通的丝线串起来的。项链上的每个贝壳都有一个好看程度 $a_i$，相同种类的贝壳有着相同的好看程度，而不同种类的贝壳有着不同的好看程度。

Danie13265 定义， 第 $l$ 个至第 $r$ 个这一段贝壳是对称的，当且仅当

$$\sum_{i=l}^r\left(a_i-a_{l+r-i}\right)^2=0$$

Daniel13265 经常从中取出一段贝壳。如果这一段贝壳是对称的，他就会非常高兴；如果这一段贝壳不是对称的，那么他会将其中的某些贝壳替换成新的，以使得这一段贝壳成为对称的。一次替换可以任意地改变任何一个位置上贝壳的好看程度，但是过多的替换会使这一段贝壳脱离原本的模样，所以 Daniel13265 至多会进行 $k$ 次替换。如果一段贝壳在进行至多 $k$ 次替换后能够成为对称的，那么 Daniel13265 就称这一段贝壳是「可观赏的」。

Daniel13265 简单地将第 $l$ 个至第 $r$ 个这一「可观赏的」的贝壳段的「观赏指数」定义为

$$\prod_{i=l}^ra_i$$

其中 $a_i$ 表示第 $i$ 个贝壳**原本的好看程度**。

他现在很好奇，在这个贝壳组成的项链中，「可观赏的」贝壳段中「观赏指数」的最大值。但是由于这个值可能很大，所以你只需要求出它对 $10^9+7$ 取模后的结果即可。

## 说明/提示

### 样例解释 #1

「可观赏的」贝壳段有 $[1],[2],[3],[4],[1,2],[2,3],[2,4],[3,3],[3,4],[4,2],[1,2,4],[2,3,3],[2,4,2],[3,3,4],[4,2,3],[2,3,3,4],[4,2,3,3,4]$，其中「观赏指数」最大的贝壳段为 $[4,2,3,3,4]$。

### 样例解释 #2

「可观赏的」的贝壳段中「观赏指数」最大的为 $[2,250000002,1,2]$，其值为 $10^9+8$，对 $10^9+7$ 取模后结果为 $1$。

### 数据范围

**本题采用捆绑测试。你每通过一个子任务的所有数据点，就能得到该子任务的全部分数。**

| 子任务编号 | $n\le$ | $k\le$ | 分值 |
|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $10$ | $10$ |
| $2$ | $100$ | $100$ | $20$ |
| $3$ | $1000$ | $0$ | $20$ |
| $4$ | $1000$ | $1000$ | $50$ |
| $5$ | $10^6$ | $0$ | $0$ |

对于 $100\%$ 的数据，满足 $1\le n\le1000$，$0\le k\le n$，$1\le a_i<10^9+7$。

## 样例 #1

### 输入

```
7 1
1 2 4 2 3 3 4
```

### 输出

```
288
```

## 样例 #2

### 输入

```
6 1
3 1 2 250000002 1 2
```

### 输出

```
1
```

# AI分析结果

### 综合分析与结论
这三道题解均围绕如何找出满足条件的回文串并计算其最大观赏指数展开。核心思路是枚举回文中心并向两边扩展，同时利用对数将乘法转化为加法以解决大数存储问题。

奇米的题解直接分奇偶情况枚举回文串，通过前缀和数组 `b` 存储对数和，逻辑清晰但代码稍显冗余。chenly8128 的题解将偶串转换为奇串，减少了枚举情况，代码简洁。Hexarhy 的题解同样采用插入 1 的方法避免分奇偶枚举，还提供了分奇偶和不分奇偶两种实现方式，并使用 `pair` 存储取模后的乘积和对数区间和。

### 所选题解
- **奇米的题解**：★★★★
    - 关键亮点：思路清晰，详细解释了对数转换的思维，代码实现中对取对数做前缀和的处理很直观。
    - 个人心得：无
- **chenly8128 的题解**：★★★★★
    - 关键亮点：将偶串转换为奇串的思路很巧妙，简化了枚举过程，代码简洁高效。
    - 个人心得：无
- **Hexarhy 的题解**：★★★★
    - 关键亮点：提供了分奇偶和不分奇偶两种实现方式，使用 `pair` 存储信息方便更新答案，对细节的注意事项有详细说明。
    - 个人心得：无

### 重点代码及核心实现思想
#### chenly8128 的题解
```cpp
n = read();k = read();
for (int i = 0;i < n;i++) {
    a[(i<<1)+1] = read();
    a[(i<<1)+2] = 1;
}
n = (n<<1)-1;
ll ans = 1;long double rr = 0;
for (int i = 1;i <= n;i++) {
    ll sum = 0,res = a[i];
    long double res2 = log(a[i]);
    for (int j = 1;j <= min(i-1,n-i);j++) {
        if (a[i-j]!= a[i+j] && ++sum > k) break;
        res = res * a[i-j] % mod * a[i+j] % mod;
        res2 += log(a[i-j]) + log(a[i+j]);
    }
    if (res2 > rr) {
        rr = res2;
        ans = res;
    }
}
```
核心实现思想：先将原数组转换，在相邻元素间插入 1，将偶串变为奇串。然后枚举回文中心，向两边扩展，记录更改次数、乘积取模和对数和，根据对数和更新答案。

#### Hexarhy 的题解（不分奇偶）
```cpp
cin>>n>>k;
int cnt=1;
a[cnt]=1LL;
for(int i=1;i<=n;i++)
{
    ll x;cin>>x;
    a[++cnt]=x;a[++cnt]=1LL;
}
for(int i=1;i<=cnt;i++)
    s[i]=s[i-1]+log2(a[i]);
for(int i=1;i<=cnt;i++)
{
    int t=0,l=i-1,r=i+1;
    pll sum=pll{a[i],0LL};
    while(1<=l && r<=cnt)
    {
        if(a[l]!=a[r])    t++;
        if(t>k)            break;
        sum.val=sum.val*a[l]%MOD*a[r]%MOD;
        sum.logg=s[r]-s[l-1];
        l--;r++;
    }
    if(sum.logg>ans.logg || (sum.logg==ans.logg && sum.val>ans.val))
        ans=sum;
}
```
核心实现思想：在原数列首和两两之间插入 1，避免分奇偶枚举。预处理对数前缀和，枚举回文中心，向两边扩展，使用 `pair` 存储取模后的乘积和对数区间和，根据条件更新答案。

### 最优关键思路或技巧
- **对数转换**：利用对数的性质 $\log(a\times b)=\log(a)+\log(b)$，将乘法转换为加法，解决大数存储问题。
- **插入 1 避免分奇偶枚举**：借鉴 manacher 算法，在原数列中插入 1，将偶串转换为奇串，简化枚举过程。

### 可拓展之处
同类型题或类似算法套路：
- 寻找满足特定条件的子串问题，如寻找和最大的子串、长度最长的子串等，可采用枚举中心扩展的方法。
- 处理大数计算问题时，可考虑使用对数转换或高精度算法。

### 推荐题目
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：考察子串和的计算与最大值求解。
- [P3805 【模板】manacher 算法](https://www.luogu.com.cn/problem/P3805)：专门考察 manacher 算法，与本题插入 1 的思路相关。
- [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)：涉及大数计算和数论知识，可锻炼处理大数的能力。

---
处理用时：34.58秒
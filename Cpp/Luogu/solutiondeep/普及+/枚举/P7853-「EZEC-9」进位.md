# 题目信息

# 「EZEC-9」进位

## 题目背景

规定 $\text{popcount}(x)$ 表示 $x$ 在二进制表示下所含 $1$ 的个数。

## 题目描述

您有一个二进制数 $B$（以一个长为 $n$ 的 $01$ 字符串形式给出）和长为 $m$ 的序列 $a$。

同时，您还需要对 $B$ 进行 $m$ 次操作。

其中，第 $i$ 个操作为 $B \gets B + 2^{a_i}$，其价值 $v_i$ 为 $B$ 在操作前后变化的位置数量，即 $v_i = \operatorname{popcount}(B \mathbin{\mathrm{xor}} (B + 2^{a_i}))$。

您需要解决两个问题：

- 您可以**任意**安排操作顺序，问在执行**所有**操作后，$\displaystyle \sum_{i=1}^mv_i$ 最大为多少？

- 您可以**任意**安排操作顺序，问在执行**所有**操作后，$\displaystyle \max_{i=1}^mv_i$ 最大为多少？

## 说明/提示

**【样例解释 #1】**

对于第一问，依次执行第 $1,2,6,5,4,3$ 个操作可得到 $\displaystyle \sum\limits_{i=1}^mv_i=14$。

对于第二问，依次执行第 $6,5,4,3,1,2$ 个操作可得到 $\displaystyle \max\limits_{i=1}^mv_i=6$。

[详细过程](https://www.luogu.com.cn/paste/ycx4xov7)

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（20 points）：$n,m\leq 10$。
- Subtask 2（30 points）：$n,m\leq 1000$。
- Subtask 3（20 points）：$B$ 中全为 $0$，且 $a_1=0$，$\forall i>1, a_{i-1}\leq a_i\leq a_{i-1}+1$。
- Subtask 4（20 points）：$n,m\leq 10^5$。
- Subtask 5（10 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,m\leq 10^6$，$0\leq a_i< n$。

## 样例 #1

### 输入

```
5 6
10110
1 0 2 2 2 2
```

### 输出

```
14
6
```

## 样例 #2

### 输入

```
10 10
0101010110
0 1 2 3 4 5 5 4 3 2
```

### 输出

```
21
9
```

## 样例 #3

### 输入

```
10 3
1111101111
5 5 0
```

### 输出

```
13
11
```

# AI分析结果

### 综合分析与结论
这三道题解均围绕二进制数操作及价值计算问题展开，核心在于解决操作价值总和的最大值与单次操作最大价值这两个问题。

- **思路对比**：
    - **gyh20**：对于第一问，证明操作顺序不影响结果，按位模拟计算；第二问先提出枚举思路，后给出优化方案，如贪心进位、找最长连续进位段等。
    - **nanzjz1**：第一问先加当前位价值，再处理进位；第二问通过搜索大于 1 的值进行连续进位计算最大价值。
    - **超级玛丽王子**：第一问依据操作顺序不影响进位总数的结论暴力模拟；第二问找最长的连续 1 段。
- **算法要点对比**：
    - **gyh20**：复杂度分析较详细，给出不同复杂度的实现方案，如 $O(n + m)$ 并查集实现。
    - **nanzjz1**：代码实现较为基础，按常规思路模拟操作和进位。
    - **超级玛丽王子**：注意到进位可能产生新位，数组开两倍大小，通过简单循环模拟操作和统计最长段。
- **解决难点对比**：
    - **gyh20**：重点在于证明第一问结论和优化第二问算法复杂度。
    - **nanzjz1**：主要解决第二问中最大价值计算的逻辑问题，证明计算互不影响。
    - **超级玛丽王子**：处理好进位产生的新位和统计最长段的细节。

### 所选题解
- **gyh20（4星）**
    - **关键亮点**：思路清晰，对第一问结论有详细证明，复杂度分析到位，且给出多种第二问的优化方案及参考代码。
    - **个人心得**：无

### 重点代码及核心实现思想
```cpp
#include<cstdio>
char s[1000032];
int n,m,a[1000032],ans,len,x,ans1;
int main(){
    scanf("%d%d%s",&n,&m,s);
    for(int i=0;i<n;++i)s[i]-='0';n+=30;
    while(m--){
        scanf("%d",&x),++s[x],++ans1;
        while(s[x]>=2)a[x]=1,++s[x+1],s[x]-=2,++x,++ans1;
    }
    for(int i=0;i<n;++i)
        if(a[i]){++len;if(len>ans)ans=len;}
        else len=0;
    printf("%d\n%d",ans1,ans+1);
}
```
**核心实现思想**：
1. 第一问：按顺序模拟操作，每次操作增加当前位的值并更新总价值，处理进位时也更新总价值。
2. 第二问：标记出现进位的位置，最后遍历找出最长的连续进位段，加 1 即为单次操作的最大价值。

### 最优关键思路或技巧
- **结论推导**：证明第一问中操作顺序不影响结果，按位分析进位情况，简化计算。
- **贪心思想**：第二问中通过贪心进位，让操作产生尽可能多的连续进位，从而得到最大价值。
- **找连续段**：通过标记进位位置，找出最长的连续进位段，确定单次操作的最大价值。

### 可拓展之处
同类型题或类似算法套路：
- 涉及二进制操作的题目，如二进制加法、减法、位运算等，可考虑按位分析和进位处理。
- 贪心算法的应用，在一些需要求最大值或最小值的问题中，通过合理的贪心策略优化计算。

### 推荐题目
- [P1017 进制转换](https://www.luogu.com.cn/problem/P1017)
- [P1143 进制转换](https://www.luogu.com.cn/problem/P1143)
- [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)

---
处理用时：31.41秒
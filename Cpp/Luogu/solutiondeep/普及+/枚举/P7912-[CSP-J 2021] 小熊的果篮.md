# 题目信息

# [CSP-J 2021] 小熊的果篮

## 题目描述

小熊的水果店里摆放着一排 $n$ 个水果。每个水果只可能是苹果或桔子，从左到右依次用正整数 $1, 2, \ldots, n$ 编号。连续排在一起的同一种水果称为一个“块”。小熊要把这一排水果挑到若干个果篮里，具体方法是：每次都把每一个“块”中最左边的水果同时挑出，组成一个果篮。重复这一操作，直至水果用完。注意，每次挑完一个果篮后，“块”可能会发生变化。比如两个苹果“块”之间的唯一桔子被挑走后，两个苹果“块”就变成了一个“块”。请帮小熊计算每个果篮里包含的水果。

## 说明/提示

**【样例解释 #1】**

这是第一组数据的样例说明。

所有水果一开始的情况是 $[1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0]$，一共有 $6$ 个块。

在第一次挑水果组成果篮的过程中，编号为 $1, 3, 5, 8, 9, 11$ 的水果被挑了出来。

之后剩下的水果是 $[1, 0, 1, 1, 1, 0]$，一共 $4$ 个块。

在第二次挑水果组成果篮的过程中，编号为 $2, 4, 6, 12$ 的水果被挑了出来。

之后剩下的水果是 $[1, 1]$，只有 $1$ 个块。

在第三次挑水果组成果篮的过程中，编号为 $7$ 的水果被挑了出来。

最后剩下的水果是 $[1]$，只有 $1$ 个块。

在第四次挑水果组成果篮的过程中，编号为 $10$ 的水果被挑了出来。

**【数据范围】**

对于 $10 \%$ 的数据，$n \le 5$。  
对于 $30 \%$ 的数据，$n \le 1000$。  
对于 $70 \%$ 的数据，$n \le 50000$。  
对于 $100 \%$ 的数据，$1 \le n \le 2 \times {10}^5$。

**【提示】**

由于数据规模较大，建议 C/C++ 选手使用 `scanf` 和 `printf` 语句输入、输出。

## 样例 #1

### 输入

```
12
1 1 0 0 1 1 1 0 1 1 0 0
```

### 输出

```
1 3 5 8 9 11
2 4 6 12
7
10
```

## 样例 #2

### 输入

```
20
1 1 1 1 0 0 0 1 1 1 0 0 1 0 1 1 0 0 0 0
```

### 输出

```
1 5 8 11 13 14 15 17
2 6 9 12 16 18
3 7 10 19
4 20
```

## 样例 #3

### 输入

```
见附件中的 fruit/fruit3.in。```

### 输出

```
见附件中的 fruit/fruit3.ans。```

# AI分析结果

### 综合分析与结论
这些题解的核心都是模拟小熊挑选水果组成果篮的过程，关键在于如何高效地维护“块”的信息以及处理块的合并。不同题解采用了多种数据结构和算法，包括队列、链表、集合（set）、线段树等。

时间复杂度方面，有 $O(n)$、$O(n\log n)$ 和 $O(n\sqrt{n})$ 等不同复杂度的实现。$O(n)$ 的解法通常使用链表来维护块，能高效处理块的删除和合并；$O(n\log n)$ 的解法多使用集合（set）或平衡树，利用其查找和删除的 $\log n$ 复杂度；$O(n\sqrt{n})$ 的解法则在处理块合并时需要多次扫描，效率相对较低。

### 所选题解
- **vegetable_king（5星）**
    - **关键亮点**：思路清晰，使用队列维护块，对块的合并处理明确，代码注释详细，便于理解。
    - **核心代码**：
```cpp
struct kuai{ // 块
    int st, ed, th;
};
queue<kuai> q, q2;
bool used[200001]; // 记录是否被取出
//...
while (cnt){
    while (q.size()){
        f = q.front();
        q.pop();
        while (used[f.st] && f.st <= f.ed) f.st ++; // 如果已经被取了
        if (f.st > f.ed) continue;
        printf("%d ", f.st), cnt --;
        used[f.st] = 1; // 将块的开头元素去掉并输出
        if (f.ed == f.st) continue; // 如果这个块被取完了
        f.st ++;
        q2.push(f); // 先临时存到 q2 里进行合并
    }
    putchar('\n');
    while (q2.size()){
        ad = q2.front();
        q2.pop();
        while (q2.size()){
            x = q2.front();
            if (x.th == ad.th){ // 能合并就合并
                ad.ed = x.ed;
                q2.pop();
            }
            else break;
        }
        q.push(ad); // 丢回 q 里
    }
}
```
    - **核心思想**：将连续相同元素合成一个块存入队列，每次从队列取出块，去掉块的开头元素并输出，将剩余部分存入临时队列，合并相邻且元素相同的块后再放回原队列，直到所有水果被取出。
- **_StarBird_（4星）**
    - **关键亮点**：思路新颖，使用 set 维护苹果和橘子的位置，交替取最小值，复杂度为 $O(n\log n)$，对水果种类多的情况有较好的扩展性。
    - **核心代码**：
```cpp
set<int>s1,s2; // 把下标扔在两个 set 里 
//...
while(!p && s1.size()>1 || p && s2.size()>1){
    if (!p){
        nw=*s1.upper_bound(nw);
        if (nw==INF){
            nw=0;
            p=*s1.begin()<*s2.begin()?0:1;
            puts("");
            continue;
        }
        printf("%d ",nw);
        s1.erase(nw);
        p=!p;
    }
    else{
        nw=*s2.upper_bound(nw);
        if (nw==INF){
            nw=0;
            p=*s1.begin()<*s2.begin()?0:1;
            puts("");
            continue;
        }
        printf("%d ",nw);
        s2.erase(nw);
        p=!p;
    }
}
```
    - **核心思想**：将苹果和橘子的下标分别存入两个 set，找到两种水果最小下标的小值，交替取大于之前所取数的最小值，取完一轮换行，直到所有水果被取出。
- **lcyxds（4星）**
    - **关键亮点**：使用双向链表维护“假块”头和水果，通过链表的删除元素操作模拟吃水果，时间复杂度为 $O(n)$，代码逻辑清晰。
    - **核心代码**：
```cpp
struct Node{
    int prev;
    int val;
    int next;
};
//...
void EatOne(int pos) {
    int prev = shuiguoList[pos].prev;
    int next = shuiguoList[pos].next;
    shuiguoList[prev].next = next;
    shuiguoList[next].prev = prev;
    printf("%d ", pos);
}
void Del(int pos) {
    int prev = headList[pos].prev;
    int next = headList[pos].next;
    headList[prev].next = next;
    headList[next].prev = prev;
}
void Chi() {
    int solo = headList[0].next;
    int nowcolor = shuiguo[headList[solo].val];
    while (solo!=cc+1) {
        if (shuiguo[headList[solo].val]!=nowcolor) {
            Del(solo);
            solo = headList[solo].next;
            continue;
        }
        EatOne(headList[solo].val);
        headList[solo].val = shuiguoList[headList[solo].val].next;
        if (shuiguo[headList[solo].val]!=nowcolor) {
            Del(solo);
        }
        solo = headList[solo].next;
        nowcolor^=1;
    }
    putchar('\n');
}
```
    - **核心思想**：建立双向链表维护水果和“假块”头，遍历“假块”头链表，若块头指向的水果与上一个被吃水果种类相同则合并块，不同则吃掉水果并更新块头指向，直到所有水果被吃完。

### 最优关键思路或技巧
- **数据结构选择**：链表是处理这类需要频繁删除和合并操作的高效数据结构，能在 $O(1)$ 时间内完成节点的删除和合并。队列可用于按顺序处理块，保证操作的有序性。集合（set）或平衡树可利用其查找和删除的 $\log n$ 复杂度，适用于需要快速查找最小值的情况。
- **块的合并处理**：在处理块的合并时，可通过比较相邻块的元素或颜色，将相同的块合并为一个，减少不必要的操作。

### 可拓展之处
同类型题可能涉及更多种类的元素或更复杂的合并规则，类似算法套路可用于处理区间合并、序列删除等问题。例如，在处理多个区间的合并时，可使用链表或线段树维护区间信息，根据条件进行区间的合并和删除。

### 推荐题目
- [P1160 队列安排](https://www.luogu.com.cn/problem/P1160)：考察链表的使用，需要对链表进行插入和删除操作。
- [P2234 [HNOI2002]营业额统计](https://www.luogu.com.cn/problem/P2234)：可使用 set 维护数据，利用其查找和插入的特性解决问题。
- [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：线段树的基础模板题，掌握线段树的基本操作有助于解决更复杂的区间问题。

### 个人心得摘录与总结
- **_StarBird_**：考场上想到链表正解但写挂且没调出来，写暴力得 70 分，因 T3 没判前导 0 只拿 65 分，强调了代码实现和细节处理的重要性。
- **BreakPlus**：考场误将查找第一个非 $2$ 元素的操作写成 $O(n)$，导致问题，提醒在实现算法时要注意复杂度的优化。 

---
处理用时：51.06秒
# 题目信息

# [ONTAK2015] Cięcie

## 题目描述

给定一个长度为 $k$ 的数字串 $N$ 以及三个**质数** $p, q, r$，请你将 $N$ 划分为三段非空字符串，使得第一段能被 $p$ 整除，第二段能被 $q$ 整除，第三段能被 $r$ 整除，且每一段都不含前导 $0$。

注：**单独的 $0$ 是允许的**。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq k \leq 10^6$，$2015 < p, q, r \leq 10^5$，$p, q, r$ 为**质数**。

## 样例 #1

### 输入

```
19 2017 2027 2029
2017202741127832029```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这三道题解的核心思路都是先分别找出满足被 $p$ 整除的第一段和被 $r$ 整除的第三段的所有可能位置，再判断中间的第二段是否能被 $q$ 整除。不同的是在判断第二段是否被 $q$ 整除的方法上有所差异，并且在代码实现和优化细节上各有特点。

### 所选题解
- **wjr_jok 的题解（4星）**
  - **关键亮点**：思路清晰，将解题过程分为多个步骤，易于理解。使用前缀和来 $O(1)$ 求取余数，优化了时间复杂度，并且对枚举过程进行了优化，避免了不必要的计算。
- **_EternalRegrets_ 的题解（4星）**
  - **关键亮点**：采用类似哈希的方法，用 $pre_i$ 记录前 $i$ 个数码组成的数字模 $q$ 的余数，同样实现了 $O(1)$ 检验，代码逻辑较为清晰。

### 重点代码及核心实现思想
#### wjr_jok 的题解
```cpp
// 预处理余数，qzh 记录由 1~i 位组成的数取余 q 的结果，ac 记录 10^i 取余 q 的结果
ac[0]=1;
for(int i=1;i<=k;i++){
    qzh[i]=(qzh[i-1]*10+xl[i])%q;
    ac[i]=(ac[i-1]*10)%q;
}
// 枚举第一段
for(int i=1;i<=k;i++){
    cnt=(cnt*10+xl[i])%p;
    if(!cnt){
        fst[++fst[0]]=i;
    }
}
// 枚举第三段
cnt=0,jl=1;
for(int i=k;i>=1;i--){
    cnt=(cnt+xl[i]*cf(k-i))%r; 
    if(!cnt&&(xl[i]||i==k)){
        lst[++lst[0]]=i;
    }
}
// 判断第二段
for(int i=1;i<=fst[0];i++){
    for(int j=lst[0];j>=1;j--){
        if(fst[i]>=lst[j]-1){
            lst[0]--;
            continue;
        }
        if(!xl[fst[i]+1]&&fst[i]<lst[j]-2){
            break;
        }
        if(!((qzh[lst[j]-1]-qzh[fst[i]]*ac[lst[j]-fst[i]-1]+q)%q)){
            ans++;
        }
    }
}
```
核心思想：先预处理出前 $i$ 位组成的数字对 $q$ 取余的结果和 $10^i$ 对 $q$ 取余的结果，方便后续 $O(1)$ 计算第二段对 $q$ 取余的结果。然后分别枚举第一段和第三段的可能位置，最后判断第二段是否满足条件。

#### _EternalRegrets_ 的题解
```cpp
// 处理第一段
if(s[1]!='0'){
    for(int i=1;i<=k;i++){
        num=((num*10%p)+s[i]-'0')%p;
        if(num==0){
            pp.push_back(i);
        }
    }
}
else{
    pp.push_back(1);
}
// 处理第三段
num=0;
for(int i=k;i>=1;i--){
    num=(num+(s[i]-'0')*qpow(10,k-i,r)%r)%r;
    if(num==0 && (s[i]!='0' || i==k)){
        rr.push_back(i);
    } 
}
// 预处理前 i 个数码组成的数字模 q 的余数
for(int i=1;i<=k;i++){
    pre[i]=((pre[i-1]*10%q)+s[i]-'0')%q;
} 
// 判断第二段
for(int i=0;i<pp.size();i++){
    for(int j=rr.size()-1;j>=0;j--){
        if(pp[i]>=rr[j]-1){
            continue;
        }
        if(s[pp[i]+1]=='0' && pp[i]<rr[j]-2){
            break;
        }
        if((pre[rr[j]-1]-pre[pp[i]]*qpow(10,rr[j]-pp[i]-1,q)+q)%q==0){
            ans++;
        }
    }
}
```
核心思想：先分别找出满足被 $p$ 整除的第一段和被 $r$ 整除的第三段的所有可能位置，再预处理前 $i$ 个数码组成的数字模 $q$ 的余数，最后 $O(1)$ 检验中间的第二段是否被 $q$ 整除。

### 最优关键思路或技巧
- **前缀和取余优化**：通过预处理前 $i$ 位组成的数字对 $q$ 取余的结果和 $10^i$ 对 $q$ 取余的结果，实现 $O(1)$ 计算任意区间数字对 $q$ 取余的结果，大大优化了时间复杂度。
- **枚举优化**：在枚举第一段和第三段的过程中，通过判断是否相交以及是否有前导 0 等条件，避免了不必要的计算。

### 可拓展之处
同类型题可以是将数字串划分为更多段，每段满足不同的整除条件，或者改变整除条件为其他数学条件。类似算法套路可以是先预处理一些关键信息，然后枚举部分区间，最后利用预处理信息快速判断剩余区间是否满足条件。

### 推荐题目
- [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)
- [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)
- [P2613 有理数取余](https://www.luogu.com.cn/problem/P2613)

### 个人心得
这些题解中均未包含个人心得（调试经历、踩坑教训、顿悟感想等）。

---
处理用时：43.30秒
# 题目信息

# 『JROI-5』Interval

## 题目背景

小 C 喜欢带有区间操作的数据结构，因为这样的题总会有一档好写的 $\mathcal{O}\left(n^2\right)$ 部分分。

## 题目描述


**本题读入量较大，建议使用较快的读入方式，可以参考 [赛时公告板](https://www.luogu.com.cn/paste/lueudpd5)**

小 C 有一个长度为 $n$ 的序列 $a$，第 $i$ 项为 $a_i$。

$a$ 是一个 $1\sim n$ 的排列（即 $1\sim n$ 在 $a$ 中各出现一次）。

定义 $\operatorname{Mex}_{l,r}$ 为 $\{a_l,a_{l+1},
\cdots,a_{r-1},a_r\}$ 中**没有出现过的最小正整数**。

例如，$\operatorname{Mex}\{2,3\}=1,\operatorname{Mex}\{1,2,3\}=4$。

小 C 还有一个长度为 $n$ 的数列 $f$。

定义一个区间 $\left[l,r\right]$ 是合法的当且仅当 
$$f_{r-l+1}< \operatorname{Mex}_{l,r}$$

小 C 希望你告诉他，最短的合法区间的长度是多少，特别的，如果没有区间合法，则输出 `0`。

## 说明/提示

【样例解释】

对于 #1，容易发现 $\left[1,3\right]$ 是最短的合法区间。

对于 #2，容易发现 $\left[3,3\right]$ 是最短的合法区间。

对于 #3，容易发现没有合法的区间。

---

对于 $10\%$ 的数据，满足 $1\leq n\leq 100$。

对于 $20\%$ 的数据，满足 $1\leq n\leq 1000$。

对于另外 $10\%$ 的数据，满足 $f$ 不升，即满足 $f_1\geq f_2\geq\cdots\geq f_n$，且 $1\leq n\leq 10^6$。

对于 $100\%$ 的数据，满足 $1\leq n\leq 4\times 10^6,1\leq f_i\leq 10^9$。


## 样例 #1

### 输入

```
5
2 3 1 5 4
2 2 3 4 5```

### 输出

```
3```

## 样例 #2

### 输入

```
5
2 3 1 5 4
1 2 2 4 5```

### 输出

```
1```

## 样例 #3

### 输入

```
5
1 3 4 2 5
6 7 8 9 10```

### 输出

```
0```

## 样例 #4

### 输入

```
见附件```

### 输出

```
见附件```

# AI分析结果

### 综合分析与结论
这些题解的核心思路大多围绕如何高效计算不同区间长度下的最大 $\text{Mex}$ 值，并与 $f$ 数组比较来确定最短合法区间长度。主要方法有枚举区间长度、枚举 $\text{Mex}$ 值等，通过记录数字位置、维护前缀最值等技巧来优化计算过程。各题解在思路清晰度、代码可读性和优化程度上存在差异。

### 所选题解
- **作者：caibet (赞：12)  ★★★★**
    - **关键亮点**：思路清晰，利用差分优化计算最大 $\text{Mex}$ 值的过程，代码简洁高效。
    - **核心代码**：
```cpp
namespace{
    const int lim=4e6+2;
    int n,a[lim],f[lim],p[lim],b[lim],L=0x7f7f7f7f,R=0;
    void work(){
        n=read();
        F(i,1,<=n) a[i]=read(),p[a[i]]=i;
        F(i,1,<=n) f[i]=read();
        b[1]=1;
        F(i,1,<=n){
            L=min(L,p[i]);
            R=max(R,p[i]);
            ++b[R-L+1];
        }
        F(i,1,<=n){
            b[i]+=b[i-1];
            if(f[i]<b[i]){
                cout<<i;
                return;
            }
        }
        cout<<0;
    }
}
```
    - **核心实现思想**：先记录每个数字的位置，然后通过不断扩展区间更新差分数组 $b$，最后通过前缀和还原出最大 $\text{Mex}$ 值，与 $f$ 数组比较得到结果。

- **作者：蒟蒻炒扇贝 (赞：8)  ★★★★**
    - **关键亮点**：思路易懂，通过维护前缀最值数组实现 $\mathcal{O}(1)$ 时间复杂度验证区间合法性，代码结构清晰。
    - **核心代码**：
```cpp
const int MAXN=4e6+5;
int f[MAXN],a[MAXN],n,pos[MAXN],qmin[MAXN],qmax[MAXN];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)a[i]=read(),pos[a[i]]=i;
    for(int i=1;i<=n;i++)f[i]=read();
    qmin[0]=2e9,qmax[0]=-2e9;
    for(int i=1;i<=n;i++)qmin[i]=min(qmin[i-1],pos[i]),qmax[i]=max(qmax[i-1],pos[i]);
    for(int i=1;i<=n;i++)
    {
        if(f[i]>n)continue;
        int l=qmin[f[i]],r=qmax[f[i]];
        if(r-l+1<=i)
        {
            cout<<i;
            return 0;
        }
    }
    cout<<0;
    return 0;
}
```
    - **核心实现思想**：记录每个数字的位置，维护前缀最小值数组 $qmin$ 和前缀最大值数组 $qmax$，枚举区间长度，通过 $qmin$ 和 $qmax$ 快速判断是否存在合法区间。

- **作者：Cocoly1990 (赞：8)  ★★★★**
    - **关键亮点**：官方题解，思路严谨，通过改写条件和利用 $\text{Mex}$ 单调性优化枚举过程，时间复杂度为 $\mathcal{O}(n)$。
    - **核心代码**：
```c++
for(int i = 1; i <= n; i ++)
    pos[a[i]] = i;
_min[0] = n + 1;
for(int i = 1; i <= n; i ++){
    _max[i] = max(_max[i - 1], pos[i]);
    _min[i] = min(_min[i - 1], pos[i]);
}
for(int i = 1; i <= n; i ++)
    g[i] = _max[i] - _min[i] + 1;
int ans = 0;
for(int i = 1; i <= n; i ++){
    if(f[i] <= n && g[f[i]] <= i){
        ans = i;
        break; 
    } 
}
```
    - **核心实现思想**：记录每个数字的位置，维护前缀最值数组，计算满足 $\text{Mex} = i + 1$ 的最短区间长度 $g[i]$，枚举区间长度判断是否合法。

### 最优关键思路或技巧
- **记录数字位置**：通过记录每个数字在序列中的位置，方便后续快速确定包含特定数字集合的最短区间。
- **维护前缀最值**：利用前缀最大值和最小值数组，实现 $\mathcal{O}(1)$ 时间复杂度获取特定区间的边界，优化计算过程。
- **差分优化**：利用差分思想，将区间取较大值替换转换为区间覆盖，减少计算量。

### 可拓展之处
同类型题可能涉及不同的区间操作和条件判断，如计算区间的 $\text{GCD}$、$\text{LCM}$ 等，可采用类似的记录位置、维护前缀信息等方法优化计算。类似算法套路包括利用单调性、贪心策略等简化问题。

### 推荐题目
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：考察区间和的计算与优化。
- [P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)：涉及区间最值的维护。
- [P2036 [COCI2008-2009#2] PERKET](https://www.luogu.com.cn/problem/P2036)：需要对不同组合的区间进行计算和比较。

### 个人心得摘录与总结
- **caibet**：发现之前代码多写 6 行给算法加了个 $\log$，进行了优化，体现了对算法复杂度的关注和优化意识。
- **Iam1789**：一开始直接枚举 $\text{MEX}$ 出现错误，重新思考后发现需要检查更新前后区间长度之间的值，强调了在调试过程中要仔细分析边界情况和特殊情况。 

---
处理用时：46.96秒
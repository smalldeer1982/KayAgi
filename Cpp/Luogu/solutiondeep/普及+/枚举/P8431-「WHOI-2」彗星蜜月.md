# 题目信息

# 「WHOI-2」彗星蜜月

## 题目背景

![](bilibili:BV11x411Q7PY)

看完这首 mv 的前奏之后你应该知道 $f$ 是什么鬼了（误）。

## 题目描述

定义 $f(x)$ 是 $x$ 的各位数码翻转以后形成的数。

例如：

- $f(12323)=32321$
- $f(114514)=415411$
- $f(250)=52$
---

给定一个 $n$。求最大的 $k$，使得对于所有处于 $[1,k]$ 区间中的正整数 $m$，有 $f(m)\leq n$。

## 说明/提示

对于测试样例 $1$：
$f(1)=1,f(2)=2,f(3)=3,f(4)=4,f(5)=5,f(6)=6,f(7)=7,f(8)=8,f(9)=9,f(10)=1,f(11)=11,f(12)=21$。所以 $k$ 最大为 $11$。

---
**本题采用捆绑测试**

- $\text{subtask1(10pts)}:1\leq T,n\leq10^3$。
- $\text{subtask2(30pts)}:1\leq n\leq10^6$。
- $\text{subtask3(40pts)}:1\leq n\leq10^9$。
- $\text{subtask4(20pts)}:$ 无特殊限制。

对于 $100\%$ 的数据，$1\leq T\leq10^5,1\leq n\leq10^{18}$。

提示：`unsigned long long` 可以储存 $0$ 到 $18,446,744,073,709,551,615(2^{64}-1)$ 的自然数。 

## 样例 #1

### 输入

```
3
12
991
114514```

### 输出

```
11
298
100001```

## 样例 #2

### 输入

```
2
99999
99998```

### 输出

```
100000
99998```

# AI分析结果

### 综合分析与结论
本题要求找出最大的 $k$，使得对于所有处于 $[1,k]$ 区间中的正整数 $m$，有 $f(m)\leq n$，其中 $f(x)$ 是 $x$ 的各位数码翻转以后形成的数。各题解主要思路为找到最小的 $p$ 使得 $f(p)>n$，则 $(p - 1)$ 就是答案。不同题解采用了贪心、分类讨论、二分查找等方法来实现。

### 所选题解
- **作者：liangbowen（5星）**
    - **关键亮点**：思路清晰，采用贪心思想，通过枚举 $f(p)$ 来构造满足条件的数，时间复杂度为 $O(T \times len(n))$，代码实现简单易懂。
    - **个人心得**：作者表示题解都写得复杂，自己补了一篇简单的贪心题解，体现了对题目的深入理解和对简单解法的追求。

### 重点代码
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long LL;
int LEN(LL n) //计算 n 的位数。 
{
    int cnt = 0;
    while (n) cnt++, n /= 10;
    return cnt;	
}
LL f(LL n) //如题的 f(x) 函数。 
{
    LL ans = 0;
    while (n) ans = ans * 10 + (n % 10), n /= 10;
    return ans;
}
void solve()
{
    LL n, minn = 9e18;
    scanf("%lld", &n);
    int len = LEN(n);
    for (int i = 0; i <= len; i++)
    {
        LL p = pow(10, (LL)i); //第 i 位加一。 
        LL ni = n - (n % p) + p; //后面的位全部变成 0。 
        if (ni % 10 == 0) ni++;  // 最后一位变成 1。 
        minn = min(minn, f(ni));
        //printf("ni = %lld;\n", f(ni));
    }
    printf("%lld\n", minn - 1);
}
int main()
{
    int T;
    scanf("%d", &T);
    while (T--) solve();
    return 0;
}
```
**核心实现思想**：先计算 $n$ 的位数，然后枚举每一位，将该位加一，后面的位变为 $0$，最后一位变为 $1$，得到一个数 $ni$，取 $f(ni)$ 的最小值，最后将最小值减一即为答案。

### 最优关键思路或技巧
- **转换思路**：将求最大的 $k$ 转换为求最小的 $p$ 使得 $f(p)>n$，然后 $k = p - 1$，简化了问题。
- **贪心策略**：在构造满足条件的数时，采用贪心思想，让末尾不存在 $0$，保证反转后相对较小。

### 可拓展之处
同类型题可能会改变 $f(x)$ 的定义，或者增加其他条件，解题思路仍然可以考虑转换问题、分类讨论和贪心策略。类似算法套路可以应用于其他需要寻找边界值的问题。

### 推荐题目
- [P1024 一元三次方程求解](https://www.luogu.com.cn/problem/P1024)：需要通过二分查找来确定方程的根，与本题的二分查找思路类似。
- [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：可以使用贪心或动态规划来解决，与本题的贪心思想有一定关联。
- [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)：涉及到回文数和质数的判断，与本题对数字的处理有相似之处。

---
处理用时：32.73秒
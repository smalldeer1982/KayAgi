# 题目信息

# [蓝桥杯 2016 国 B] 机器人塔

## 题目描述

X 星球的机器人表演拉拉队有两种服装，A 和 B。

他们这次表演的是搭机器人塔。

类似：

```
     A
    B B
   A B A
  A A B B
 B B B A B
A B A B B A
```

队内的组塔规则是：

A 只能站在 AA 或 BB 的肩上。

B 只能站在 AB 或 BA 的肩上。

你的任务是帮助拉拉队计算一下，在给定 A 与 B 的人数时，可以组成多少种花样的塔。

## 说明/提示

时限 1 秒, 256M。蓝桥杯 2016 年第七届

## 样例 #1

### 输入

```
1 2```

### 输出

```
3```

## 样例 #2

### 输入

```
3 3```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕机器人塔问题展开，核心思路多为枚举最底层的状态，再根据规则推算出整个塔的情况，最后判断是否满足给定的 A、B 人数。具体实现上，部分使用位运算优化，部分采用深搜等方法。

### 所选题解
- **作者：Kevin911（5星）**
    - **关键亮点**：利用异或运算的性质巧妙表示 A、B 的关系，使用位运算枚举底层情况，代码简洁高效。
    - **核心代码**：
```cpp
int cal(int x)
{
    int res=0;
    for(;x;x-=(x&(-x))) res++;
    return res; 
}
int main()
{
    int n,m,h;
    cin>>n>>m;
    for(int i=1;i<=21;i++)
        if((i*(i+1)/2)==n+m)
        {
            h=i;
            break; 
        }
    int ans=0;
    for(int i=0;i<(1<<h);i++)//位运算枚举底层情况
    {
        int cnt=cal(i),k=i;//统计B的数量即可 
        for(int j=h-1;j>=1;j--)
        {
            k=k^(k>>1);
            k&=((1<<j)-1);
            cnt+=cal(k);
        }
        if(cnt==m) ans++;
    }
    cout<<ans;
}
```
    - **核心实现思想**：`cal` 函数用于计算二进制中 1 的个数，通过枚举底层的所有可能状态，利用异或运算逐层计算上一层的状态，统计 B 的数量，若与输入的 B 数量相等则答案加 1。

- **作者：qiuzijin2026（4星）**
    - **关键亮点**：思路清晰，通过公式计算塔的层数，枚举底层情况并推算整个塔，及时剪枝提高效率。
    - **核心代码**：
```cpp
bool pd(int x){
    memset(a,false,sizeof(a));
    s1=0;
    s0=c;
    int tmp=x;
    int tp=c;
    while(tmp!=0){
        a[c][tp]=tmp%2;
        if(a[c][tp]){
            s1++;
            s0--;
        } 
        tmp/=2;
        tp--;
    }
    if(s0>m || s1>n) return false;
    for(int i=c-1;i>=1;i--){
        for(int j=1;j<=i;j++){
            a[i][j]=a[i+1][j]^a[i+1][j+1];
            if(a[i][j]) s1++;
            else s0++;
        } 
        if(s0>m || s1>n) return false;
    }
    if(s0==m && s1==n) return true;
}
int main(){
    scanf("%d%d",&m,&n);
    c=(sqrt(8.0*n+8.0*m+1)-1)/2;
    for(int i=0;i<=(1<<c)-1;i++) if(pd(i)) ans++;
    printf("%d",ans);
    return 0;
}
```
    - **核心实现思想**：`pd` 函数用于判断一种底层状态是否合法，先初始化底层，若 A、B 数量超出范围则直接返回 false，再逐层计算上一层状态，若过程中超出范围也返回 false，最后判断是否满足条件。

- **作者：foryou_（4星）**
    - **关键亮点**：明确指出最底层确定后上层就确定，使用二进制状压枚举底层状态，分析了时间复杂度。
    - **核心思路**：最下面的一层定下之后，上面所有层就能全部定下，因此考虑枚举最下面一层的状态，用二进制状压表示，根据每个二进制位判断其下层相邻的两个数的异或值确定上层状态。

### 最优关键思路或技巧
- **二进制枚举**：利用二进制的特性枚举最底层的所有可能状态，简洁高效。
- **异或运算**：通过异或运算表示 A、B 的关系，快速计算上一层的状态。
- **剪枝优化**：在计算过程中，若发现 A、B 数量超出范围，及时停止计算，提高效率。

### 可拓展之处
同类型题或类似算法套路：
- 数独问题：通过枚举某些位置的可能状态，再根据规则推算其他位置，判断是否满足条件。
- 八皇后问题：枚举皇后的放置位置，根据规则判断是否冲突。

### 推荐题目
- [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
- [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)
- [P2089 烤鸡](https://www.luogu.com.cn/problem/P2089)

### 个人心得摘录与总结
- **作者：YangXiaopei**：尝试使用 `dfs` 暴力求解，发现最后一个点超时，计算时间复杂度后采用打表的方法解决问题，提醒我们在数据范围较小时可考虑打表优化。 

---
处理用时：38.91秒
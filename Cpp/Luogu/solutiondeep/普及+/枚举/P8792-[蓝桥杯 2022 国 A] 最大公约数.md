# 题目信息

# [蓝桥杯 2022 国 A] 最大公约数

## 题目描述

给定一个数组，每次操作可以选择数组中任意两个相邻的元素 $x, y$ 并将其中的一个元素替换为 $\gcd(x, y)$，其中 $\gcd(x, y)$ 表示 $x$ 和 $y$ 的最大公约数。请问最少需要多少次操作才能让整个数组只含 $1$。

## 说明/提示

**【评测用例规模与约定】**

- 对于 $30\%$ 的评测用例，$n \leq 500$，$a_i \leq 1000$；
- 对于 $50\%$ 的评测用例，$n \leq 5000$，$a_i \leq 10^6$；
- 对于所有评测用例，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^9$。

蓝桥杯 2022 国赛 A 组 D 题。

## 样例 #1

### 输入

```
3
4 6 9```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
本题核心在于找出最少操作次数使数组元素全变为 1，关键思路是先判断数组中是否有 1，若有则操作次数为 `n - 1 的个数`；若没有则需找到最短区间使区间 gcd 为 1，再进行后续操作。各题解思路大体一致，但在实现细节和优化方式上有所不同，主要差异在于使用的数据结构（如线段树、ST 表）和算法技巧（如双指针、二分查找）。

### 所选题解
- **作者：gesong（5星）**
    - **关键亮点**：思路清晰，先给出暴力枚举的思路和代码，在发现超时后，详细阐述使用线段树优化的方法，代码注释丰富，易于理解。
    - **核心代码**：
```cpp
// 线段树建树
void build(int k,int l,int r){
    t[k].l=l,t[k].r=r;
    if (l==r){
        t[k].mx=a[l];
        return ;
    }
    int mid=(l+r)/2;
    build(lc,l,mid);
    build(rc,mid+1,r);
    t[k].mx=__gcd(t[lc].mx,t[rc].mx);
}
// 求区间gcd
int ask(int k,int l,int r){
    if (l<=t[k].l&&r>=t[k].r) return t[k].mx;
    int ans=0;
    int mid=(t[k].l+t[k].r)/2;
    if (l<=mid) ans=__gcd(ans,ask(lc,l,r));
    if (r>mid) ans=__gcd(ans,ask(rc,l,r));
    return ans;
}
```
- **作者：Register_int（5星）**
    - **关键亮点**：准确抓住问题本质，将问题转化为拼出一个 1 的最少步数，使用 ST 表维护区间 gcd，结合双指针求解，时间复杂度优化到 `O(n log n + n)`。
    - **核心代码**：
```cpp
// ST表初始化
void init() {
    for (int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;
    for (int i = 1; i <= n; i++) st[0][i] = a[i];
    for (int i = 1; i <= lg[n]; i++) {
        for (int j = 1; j + (1 << i) - 1 <= n; j++) {
            st[i][j] = gcd(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);
        }
    }
}
// 区间查询
int query(int l, int r) {
    int k = lg[r - l + 1];
    return gcd(st[k][l], st[k][r - (1 << k) + 1]);
}
```
- **作者：Infinite_Eternity（5星）**
    - **关键亮点**：思路清晰，详细分析了有 1 和无 1 两种情况的处理方法，使用线段树查询区间 gcd，结合二分查找找出最短区间，时间复杂度为 `O(n log n)`。
    - **核心代码**：
```cpp
// 线段树建树
inline void build(int u, int l, int r) {
    if (l == r) tr[u] = {l, r, a[r]};
    else {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}
// 区间查询
inline int query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) return tr[u].g;
    int mid = tr[u].l + tr[u].r >> 1;
    if(r<=mid) return query(u<<1,l,r);
    else if(l>mid) return query(u<<1|1,l,r);
    else return __gcd(query(u<<1,l,r),query(u<<1|1,l,r));
}
```

### 最优关键思路或技巧
- **数据结构**：使用线段树或 ST 表维护区间 gcd，可将区间 gcd 查询的时间复杂度从暴力的 `O(n)` 优化到 `O(log n)` 或 `O(1)`。
- **算法优化**：双指针和二分查找的运用，双指针可在枚举区间时减少不必要的计算，二分查找可快速找到满足条件的最短区间。
- **思维方式**：将问题转化为寻找最短区间使区间 gcd 为 1，简化问题求解过程。

### 可拓展之处
同类型题可考察不同操作规则下使数组元素满足特定条件的最少操作次数，类似算法套路可用于解决需要频繁查询区间信息的问题，如区间和、区间最值等。

### 推荐题目
- [P3865 【模板】ST 表](https://www.luogu.com.cn/problem/P3865)
- [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
- [CF891A Pride](https://www.luogu.com.cn/problem/CF891A)

### 个人心得
- **作者：Watanabe**：提到模拟赛上采用思路一的暴力过不去，但洛谷可以过，分享思路二的做法，还提出在迭代 `b` 数组时可进行优化，避免被卡数据。这表明不同平台的数据强度可能不同，做题时可考虑对暴力算法进行优化以应对更复杂的数据。 

---
处理用时：35.86秒
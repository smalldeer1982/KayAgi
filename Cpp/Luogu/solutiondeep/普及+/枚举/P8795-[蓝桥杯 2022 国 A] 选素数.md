# 题目信息

# [蓝桥杯 2022 国 A] 选素数

## 题目描述

小蓝有一个数 $x$，每次操作小蓝会选择一个小于 $x$ 的素数 $p$，然后在 $x$ 成为 $p$ 的倍数前不断将 $x$ 加 $1$，（如果 $x$ 一开始就是 $p$ 的倍数则 $x$ 不变）。

小乔看到了小蓝进行了 $2$ 次上述操作后得到的结果 $n$，他想知道 $x$ 在一开始是多少。如果有多种可能，他想知道 $x$  一开始最小可以是多少，而如果不存在任何解，说明小乔看错了，此时请输出 $-1$。

## 说明/提示

**【评测用例规模与约定】**

- 对于 $60\%$ 的评测用例，$1 \leq n \leq 5000$；
- 对于所有评测用例，$1 \leq n \leq 10^6$。

蓝桥杯 2022 国赛 A 组 G 题。

## 样例 #1

### 输入

```
22```

### 输出

```
8```

# AI分析结果

### 分析与结论
这些题解的核心思路都是先找出一次操作后结果与初始值的关系，再通过枚举可能的中间值来求解两次操作的初始最小值。主要的算法要点在于质因数分解和线性筛的运用，难点在于如何高效地找出最大质因数以及处理无解的情况。

### 所选题解
- **AfterFullStop（4星）**
    - **关键亮点**：思路清晰，详细阐述了一次操作和二次操作的做法，对线性筛的运用和最大质因数的求解有深入分析，代码注释丰富。
    - **个人心得**：无
- **lemon2021（4星）**
    - **关键亮点**：思路明确，按照正向思路逐步推导，对操作过程的解释通俗易懂，代码复杂度低。
    - **个人心得**：本蒟蒻刚开始还以为这是一道比较简单的数论模拟题，可没想到后面却来了反转，意识到不能用暴力模拟，体现了对题目的深入理解过程。
- **HHH6666666666（4星）**
    - **关键亮点**：对一次操作时 $x$ 的范围证明详细，线性筛和枚举的复杂度分析清晰，代码实现简洁。
    - **个人心得**：无

### 重点代码及核心实现思想
#### AfterFullStop
```cpp
// 线性筛求最大质因数
void init(){
    for(ri i=2;i<=n;i++){
        if(!np[i]){
            pri.push_back(i);
            np[i]=i;
        }
        for(auto j:pri){
            if(i*j>n)break;
            np[i*j]=max(max(np[i*j],j),np[i]);
            if(!(i%j))break;
        }
    }
}
// 主函数部分
signed main(){
    n=read();
    init();
    for(ri i=2;i<=n;i++){
        if(np[i]^i)zy[i]=i-np[i]+1;
        else zy[i]=i;
    }
    int mini=inf;
    if(np[n]==n||!np[n])write(-1);
    else{
        for(ri i=n-np[n]+1;i<=n;i++)if(np[i]!=i)mini=min(mini,zy[i]);
        write(mini);
    }
    return 0;
}
```
**核心思想**：通过线性筛预处理出每个数的最大质因数，然后根据一次操作的结论计算每个数对应的最小初始值，最后枚举可能的中间值，找出最小的初始值。

#### lemon2021
```cpp
// 线性筛
void Linear_sieve()//线性筛(欧拉筛)
{
    for(int i=2;i<=n;i++)
    {
        isprime[i]=true;
    }
    for(int i=2;i<=n;i++)
    {
        if(isprime[i])
        {
            t++;
            prime[t]=p[i]=i;
        }
        for(int j=1;j<=t&&i*prime[j]<=n;j++)
        {
            p[i*prime[j]]=max(p[i],prime[j]);
            isprime[i*prime[j]]=false;
            if(i%prime[j]==0)
            {
                break;
            }
        }
    }
}
// 主函数部分
int main()
{
    cin>>n;
    Linear_sieve();
    for(int i=f(n);i<=n;i++)
    {
        ans=min(ans,f(i));
    }
    if(ans!=1e9)
    {
        cout<<ans<<endl;
    }
    else
    {
        cout<<"-1"<<endl;
    }
    return 0;
}
```
**核心思想**：利用线性筛求出每个数的最大质因子，定义函数 $f(m)$ 计算一次操作到 $m$ 的最小初始值，然后枚举可能的中间值，更新最小答案。

#### HHH6666666666
```cpp
// 线性筛
for (int i = 2; i <= N; ++i){
    if (!b[i]) prime[++idx] = f[i] = i;
    for (int j = 1; j <= idx && (ll) i * prime[j] <= N; ++j){
        b[i * prime[j]] = true;
        f[i * prime[j]] = max(f[i], prime[j]);
        if (i % prime[j] == 0) break;
    }
}
// 主函数部分
for (int i = get(n); i <= n; ++i)
    ans = min(ans, get(i));
if (ans == INT_MAX) puts("-1");
else printf("%d\n", ans);
```
**核心思想**：通过线性筛预处理每个数的最大质因子，定义函数 `get(x)` 计算一次操作到 $x$ 的最小初始值，枚举可能的中间值，更新最小答案。

### 最优关键思路或技巧
- **线性筛求最大质因数**：利用线性筛的性质，在筛数的过程中同时求出每个数的最大质因数，时间复杂度为 $O(n)$。
- **一次操作结论**：当只有一次操作时，若结果为 $n$，$n$ 的最大质因数为 $p$，则初始值的最小值为 $n - p + 1$。

### 可拓展之处
同类型题可能会增加操作次数或改变操作规则，类似算法套路可以运用线性筛、质因数分解等方法来解决数论相关的问题。

### 推荐题目
- P1865  A % B Problem（质数判断）
- P3383  线性筛素数（线性筛模板题）
- P1075  质因数分解（质因数分解）

---
处理用时：41.34秒
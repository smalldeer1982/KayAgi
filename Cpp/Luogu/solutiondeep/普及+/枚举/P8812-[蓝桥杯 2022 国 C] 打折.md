# 题目信息

# [蓝桥杯 2022 国 C] 打折

## 题目描述

小蓝打算采购 $n$ 种物品，每种物品各需要 $1$ 个。

小蓝所住的位置附近一共有 $m$ 个店铺，每个店铺都出售着各种各样的物品。

第 $i$ 家店铺会在第 $s_i$ 天至第 $t_i$ 天打折，折扣率为 $p_i$，对于原件为 $b$ 的物品，折后价格为 $\lfloor\frac {b\cdot p_j}{100}\rfloor$。其它时间需按原价购买。

小蓝很忙，他只能选择一天的时间去采购这些物品。请问，他最少需要花多少钱才能买到需要的所有物品。

题目保证小蓝一定能买到需要的所有物品。

## 说明/提示

对于 $40\%$ 的评测用例，$n,m≤500，s_i ≤t_i ≤100，\sum c_i ≤2000$；

对于 $70\%$ 的评测用例，$n,m≤5000，\sum c_i ≤20000$；

对于所有评测用例，$1 ≤ n,m ≤ 10^5，1 ≤ c_i ≤ n，\sum c_i ≤ 4\times10^5，1 ≤ s_i ≤t_i ≤10^9，1 < p_i < 100，1≤a_j ≤n，1≤b_j ≤10^9$。

蓝桥杯 2022 国赛 C 组 I 题。

## 样例 #1

### 输入

```
2 2
1 2 89 1
1 97
3 4 77 1
2 15```

### 输出

```
101```

# AI分析结果

### 综合分析与结论
两位作者的题解都围绕找到小蓝采购所有物品的最少花费展开。tmp_get_zip_diff 的题解采用离散化时间的方法，结合 multiset 来维护物品价格，通过枚举每一天计算花费最小值；Sweet_2013 的题解运用贪心思想，选择物品打折开始时间点，用平衡树维护物品价格集合，树状数组维护每棵平衡树最小值。tmp_get_zip_diff 的题解代码实现更详细，思路也较清晰；Sweet_2013 的题解思路简洁但缺乏代码实现。

### 所选题解
- **tmp_get_zip_diff 的题解（5星）**
    - **关键亮点**：思路清晰，代码注释详细，运用离散化时间和 multiset 高效解决问题。
    - **重点代码及核心实现思想**：
```cpp
// 离散化时间
sort(time.begin(), time.end());
time.resize(unique(time.begin(), time.end()) - time.begin());
auto get = [&](int t) {
    return lower_bound(time.begin(), time.end(), t) - time.begin();
};
// 记录开始和结束打折信息
for (int i = 0 ; i < m ; i++) {
    int starts = get(s[i]), ends = get(t[i] + 1);
    for (auto& [x, y] : v[i]) {
        int t = 1LL * y * p[i] / 100;
        st[x].insert(y);
        startD[starts].emplace_back(x, t);
        endD[ends].emplace_back(x, t);
    }
}
// 计算不打折时的花费
long long temp = 0;
for (int i = 1 ; i <= n ; i++) temp += *st[i].begin();
long long ans = temp;
// 枚举每一天，计算贡献
for (int i = 0 ; i < len ; i++) {
    long long k = 0;
    for (auto& [x, y] : startD[i]) {
        k -= *st[x].begin();
        st[x].insert(y);
        k += *st[x].begin();
    }
    for (auto& [x, y] : endD[i]) {
        k -= *st[x].begin();
        int t = st[x].count(y);
        st[x].erase(y);
        for (int j = 1 ; j < t ; j++) st[x].insert(y);
        k += *st[x].begin();
    }
    temp += k;
    ans = min(ans, temp);
}
```
核心思想是先离散化所有出现的时间点，记录每个物品在各商店的原价以及开始和结束打折的信息。计算不打折时的总花费，然后枚举每一天，根据当天开始和结束打折的物品更新 multiset 中的价格，计算价格变化的贡献，不断更新最小花费。

### 最优关键思路或技巧
- **离散化时间**：当时间范围很大但实际用到的时间点较少时，离散化可以将时间范围缩小，便于处理。
- **使用 multiset**：可以快速插入、删除元素，并能方便地获取最小值，适合维护物品价格集合。

### 可拓展之处
同类型题可能会有更多的限制条件，如物品有数量需求、商店有库存限制等。类似算法套路可以用于处理区间优惠、区间价格变化等问题，关键在于记录区间的起始和结束信息，以及维护每个物品的价格集合。

### 洛谷推荐题目
- P1908 逆序对：涉及树状数组的使用，可用于维护区间信息。
- P3369 【模板】普通平衡树：考察平衡树的基本操作，与本题中平衡树维护物品价格集合的思路类似。
- P1972 [SDOI2009]HH的项链：可以使用离散化和树状数组解决区间计数问题。

### 个人心得
tmp_get_zip_diff 提到“注意事项: 打折时间为 $[s,t]$，意味着第 $t + 1$ 天才结束打折”，提醒我们在处理区间问题时要注意区间的开闭性，避免因边界问题导致错误。 

---
处理用时：26.42秒
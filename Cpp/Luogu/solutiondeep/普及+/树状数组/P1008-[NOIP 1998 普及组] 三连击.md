# 题目信息

# [NOIP 1998 普及组] 三连击

## 题目背景

本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。

## 题目描述

将 $1, 2, \ldots , 9$ 共 $9$ 个数分成 $3$ 组，分别组成 $3$ 个三位数，且使这 $3$ 个三位数构成 $1 : 2 : 3$ 的比例，试求出所有满足条件的 $3$ 个三位数。

## 说明/提示

NOIP1998 普及组 第一题

## 样例 #1

### 输入

```
无```

### 输出

```
192 384 576
* * *
...

* * *
（剩余部分不予展示）```

# AI分析结果

### 综合分析与结论
这些题解的核心思路大多是通过枚举第一个三位数，再根据 1:2:3 的比例关系得到另外两个三位数，然后判断这三个数是否由 1 - 9 这 9 个数字无重复组成。不同题解在枚举范围、判断重复的方法上有所差异。

枚举范围方面，部分题解通过分析确定第一个数的范围在 123 - 333 或 192 - 327 之间，减少不必要的枚举。判断重复的方法多样，常见的有使用数组标记数字是否出现、计算数字的和与积是否符合 1 - 9 的和与积、利用集合去重等。

### 所选题解
- **作者：Kelin (赞：1108)，4星**
    - **关键亮点**：代码简洁，通过 `memset` 快速清零数组，直接标记数字是否出现，判断 1 - 9 是否全部出现。
```cpp
#include<cstdio>
#include<cstring>
int i,j,v;bool a[10];//ai表示第i个数已经用过了
int main()
{
    for(i=192;i<=327;i++)//第一个数最小192，最大327
    {
        memset(a,0,sizeof(a));v=0;//清零
        a[i%10]=a[i/10%10]=a[i/100]=a[i*2%10]=a[i*2/10%10]=a[i*2/100]=a[i*3%10]=a[i*3/10%10]=a[i*3/100]=1;//统计数字
        for(j=1;j<=9;j++) v+=a[j];//v表示1-9这些数字是否全部齐了
        if(v==9) printf("%d %d %d\n",i,i*2,i*3);//如果齐了就输出
    }
    return 0;
}
```
- **作者：鸩羽 (赞：610)，4星**
    - **关键亮点**：思路清晰，通过自定义函数拆分数字并计数，判断每个数字是否只出现一次。
```cpp
#include<iostream>
using namespace std;
int gw; //个位 
int d[9];//用来计数
int cf(int x){//拆分每一位数
    while(x!=0){        
        gw=x%10;
        x=(x-gw)/10; 
        d[gw]++;//计数器加1
    }
}
int main(){
    int a,b,c;
    for (int i=1;i<=9;i++)
        for (int j=1;j<=9;j++)
            for (int k=1;k<=9;k++){
                a=i*100+j*10+k;
                b=a*2;
                c=a*3;
                cf(a);
                cf(b);
                cf(c);
                if(d[1]==1&&d[2]==1&&d[3]==1&&d[4]==1&&d[5]==1&&d[6]==1&&d[7]==1&&d[8]==1&&d[9]==1){//判断是否满足条件
                    cout<<a<<" "<<b<<" "<<c<<endl;
                }
                for (int e=1;e<=9;e++){//重置计数数组
                    d[e]=0;
                }
            }
    return 0;
}
```
- **作者：usercjh123 (赞：30)，4星**
    - **关键亮点**：巧妙利用 `next_permutation` 函数生成 1 - 9 的全排列，简化了枚举过程。
```c++
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long ll;
const ll maxn = 9;
ll num[9];
ll get_num(ll l, ll r){
    ll temp = 0;
    for(int i = l ; i < r ; i++){
        temp += num[i];
        temp *= 10;
    }
    temp += num[r];
    return temp;
}
int main(){
    for(int i = 0 ; i < 9 ; i++){
        num[i] = i + 1;
    }
    do{
        ll a = get_num(0,2);
        ll b = get_num(3,5);
        ll c = get_num(6,8);
        if(a * 2 == b && a * 3 == c){
            cout << a << " " << b << " " << c << endl; 
        }
    }while(next_permutation(num,num+9));
}
```

### 最优关键思路或技巧
- **合理确定枚举范围**：通过分析题目条件，确定第一个三位数的范围，减少不必要的枚举，提高效率。
- **使用数组标记**：利用数组标记数字是否出现，方便判断数字是否重复。
- **利用库函数**：如 `next_permutation` 函数可以快速生成全排列，简化代码实现。

### 可拓展之处
同类型题目可能涉及数字的组合、排列，判断是否满足特定条件等。类似算法套路包括枚举、回溯、剪枝等。例如，给定一组数字，要求找出满足特定比例关系或数字和、积条件的组合。

### 推荐洛谷题目
- P1036 [NOIP2002 普及组] 选数
- P1047 [NOIP2005 普及组] 校门外的树
- P1059 [NOIP2006 普及组] 明明的随机数

### 个人心得摘录与总结
- **鸩羽**：提到题目对新人不友好，自己一开始手动筛选，说明该题对于初学者有一定难度，需要通过模拟和计数来解决。
- **静沐暖阳**：提到班里有大佬用 `next_permutation` 函数，说明利用库函数可以简化问题的解决过程。 

---
处理用时：37.40秒
# 题目信息

# [NOIP 2000 普及组] 税收与补贴问题

## 题目背景

每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）

对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）


## 题目描述

你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。

- 总利润 $=$ 单位商品利润 $\times$ 销量
- 单位商品利润 $=$ 单位商品价格 $-$ 单位商品成本（减去税金 或者 加上补贴）


## 说明/提示

### 数据范围及约定

保证输入的所有数字均小于 $10^5$。

### 样例解释（2023/6/22 更新）

如下图所示是输入样例所对应的价格变化图，横轴表示销售价格，纵轴表示销量。

![](https://cdn.luogu.com.cn/upload/image_hosting/21mhtm5i.png)

根据题意，$28$ 元是商品的成本。销售价格不应该低于 $28$ 元；当销售价格大于给出的价格的最大值 $31$ 元后，按照售价每提高一元，销量降低 $15$ 计算，例如当售价为 $33$ 元时，销量为 $110-15\times (33-31)=80$。在给出来的价位之间，销量呈线性变化。

当政府给该商品补贴 $4$ 元后，企业将该商品定价为 $31$ 元时，取得的利润为 $31-28+4=7$ 元，销量为 $110$ 件，总利润为 $7\times 110=770$ 元，是企业在所有定价下能够取得的最大的总利润。此时企业的售价为政府的期望售价，因此是一个合法方案。

## 样例 #1

### 输入

```
31
28 130
30 120
31 110
-1  -1
15```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕税收与补贴问题展开，核心目标是确定政府应收税或补贴的最少金额，使商家在政府预期价格上获取最大总利润。解题的关键在于处理价格 - 销量数据，包括线性插值和超出最大价格后的递减处理，以及通过不同方式确定合适的税收或补贴金额。

各题解的思路和方法可分为以下几类：
1. **暴力枚举类**：通过枚举所有可能的补贴或税收金额，计算每种情况下的最大利润价格，判断是否为政府预期价。
2. **不等式求解类**：通过解不等式确定补贴或税收的取值范围，再从中选取绝对值最小的解。
3. **模拟与二分查找类**：先模拟计算不补贴或收税时的最大利润价格，根据其与预期价的关系枚举补贴或税收；或使用二分查找来优化查找过程。

### 所选题解
- **作者：Mitch谜团（5星）**
    - **关键亮点**：思路清晰，采用暴力枚举法，代码短小精悍，通俗易懂。详细处理了价格 - 销量数据，包括线性插值和超出最大价格后的递减处理。
    - **个人心得**：作者强调计算机适合暴力枚举，认为自己的题解最通俗易懂。
- **作者：Ofnoname（4星）**
    - **关键亮点**：通过解不等式确定补贴或税收的取值范围，思路严谨。代码中对输入数据的处理和不等式的求解有详细解释，取整问题处理得当。
    - **个人心得**：作者表示理解题意和题解花费了很多时间，在细节上出过问题，通过写题解进行总结。
- **作者：majorli（4星）**
    - **关键亮点**：对问题进行了深入的数学分析，指出了其他题解中存在的一些问题，如线性插值区域的处理、是否只模拟目标价格前后两点、题目是否一定有解等，并给出了详细的证明和反例。代码逻辑清晰，使用了 STL 库的 vector 类和 algorithm 库的 max_element 算法。
    - **个人心得**：作者详细分析了题目中的不明确之处，如插值点是否会得到小数销量、确保指定价格的总利润最高是指严格最高还是可以有其他价格点和它一样高，并给出了相应的处理方法。

### 重点代码及核心实现思想
#### Mitch谜团的题解
```cpp
#include <iostream>
#include <cmath>
using namespace std;
int a[100010][3];//用于存放价格和销量的数组
int main()
{
    int i=1,j=1,k,expect,down,max,temp,cha,xl,num,s,price,p;
    cin>>expect;//读入预期价
    while(cin>>a[i][1]>>a[i][2]&&a[i][1]!=-1&&a[i] [2]!=-1)//如果输入的两个数不是-1，-1
    {
        i++;//循环变量i++
        if(i>2&&a[i-1][1]-a[i-2][1]>1)//如果两个价格之间差大于一
        {
            i--;//回到上一个读入的销量
            cha=(a[i-1][2]-a[i][2])/(a[i][1]-a[i-1][1]);//求出每次销量减少多少：销量差/价格差
            temp=a[i][1];//记录下价格
            for(j=a[i-1][1]+1;j<=temp;j++)//按价格递增顺序依次写入
            {
                a[i][1]=j;//写入价格
                a[i][2]=a[i-1][2]-cha;//按销量差写入销量
                i++;
            }
        }
    }
    cin>>down;//输入超过最大价格之后每次销量降低多少
    i--;//因为上面的while循环最后有i++所以用i--抵消……
    xl=a[i][2];//记录目前的销量
    while(xl>0)
    {
        if(xl-down<0)break;//如销量小于零则退出
        else//否则
        {
            xl-=down;//销量每次减掉down
            i++;//循环变量++
            a[i][1]=a[i-1][1]+1;//每次价格+1
            a[i][2]=xl;//销量就是xl
        }
    }
    for(j=1;j<=10000;j++)//该遍历了，因为收税相当于补贴*-1所以记录一下符号即可
    {
        max=-99999;//用于存储最大的总利润
        for(k=1;k<=i;k++)//每次扫一遍每一种价格
        {
            num=(a[k][1]-a[1][1]+j)*a[k][2];//套公式算出总利润
            if(num>=max)//如果总利润比目前最大的大
            {
                max=num;//更新max
                price=a[k][1];//记录下价格
                p=1;//记录下符号
            }
        }
        if(price==expect){cout<<j*p;return 0;}//如果价格就是政府预期价则打印出来，因为本身就是从小到大遍历所以不用求绝对值最小的
        max=-99999;//后面是收税，原理同上
        for(k=1;k<=i;k++)
        {
            num=(a[k][1]-a[1][1]-j)*a[k][2];
            if(num>=max)
            {
                max=num;
                price=a[k][1];	
                p=-1;
            }
        }
        if(price==expect){cout<<j*p;return 0;}
    }
    return 0;
}
```
**核心实现思想**：
1. 读取输入的价格和销量数据，存储在数组中。
2. 对未输入的价格和销量进行线性插值。
3. 处理超出最大价格后的销量递减。
4. 枚举所有可能的补贴或税收金额，计算每种情况下的最大利润价格，判断是否为政府预期价。

#### Ofnoname的题解
```cpp
#include <bits/stdc++.h>
#define MAX (100000+100)
using namespace std;

int x,r,m,n,p,d[MAX];//r代表成本价,x代表期望价格，d代表价位
double Min=-1e9,Max=1e9;//答案区间，开始无穷大

inline void read(int &a)
{
    register char c=getchar(); bool f=0; 
    for (a=0; c<'0'||'9'<c; c=getchar())
        if (c=='-') f=1;//要写快读记得判负数，有-1
    for (; '0'<=c && c<='9'; c=getchar())
        a=(a<<3)+(a<<1)+(c^48);
    if (f) a=-a;
}

int main()
{
    read(x); read(m); read(n); r=m;//记录成本价
    while (m!=-1 && n!=-1)
    {
        d[m]=n; 
        for (int i=p+1; i<m; i++)
            d[i]=d[i-1]+(n-d[p])/(m-p);//此处递推、未知价格销量，(n-d[p])/(m-p)是公差
        p=m;//记录上一次的m。
        read(m); read(n);
    }read(m);//此时m是最后输入的数
    while (d[p]>m)
        p++,d[p]=d[p-1]-m;//继续递推，递推完成后p就是d>0的范围
    for (register int i=r; i<=p; i++)//从成本到p的递推
    {
        double ans=(d[x]*(x-r)-d[i]*(i-r))*1.0/(d[i]-d[x]);
        //求(x+d[i])*(i-r)<=（x+d[x_])+(x_-r)的通解，x_是期望价格
        double g=d[i]-d[x];//判断解的符号,g为正是小于，反之为大于。
        if (g>0) Max=min(Max,ans);//取所有"x<=..."中的最小值
        else Min=max(Min,ans);//取所有"x>=..."中的最大值
    }
    //此时[Min,Max]就是答案的范围，取绝对值最小的输出。
    if (Min>0) printf("%d",(int)ceil(Min));//Max>Min>0，答案为Min上取整
    else if (Max<0) printf("%d",(int)floor(Max));//Min<Max<0，答案为Max下取整
    else puts("0");//Min<0<Max，显然是0绝对值最小
    return 0;
}
```
**核心实现思想**：
1. 读取输入的期望价格和价格 - 销量数据，对未输入的价格和销量进行线性插值。
2. 处理超出最大价格后的销量递减。
3. 对于每个价格，列出不等式，求解补贴或税收的取值范围。
4. 取所有不等式解集的交集，得到最终的取值范围，从中选取绝对值最小的解。

#### majorli的题解
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
    vector<int> sales;
    int target_price, tail_speed;

    cin >> target_price;
    int target_p = -1, len = 0;
    int price, sale, last_price, last_sale;
    cin >> price >> sale;
    sales.push_back(sale);
    last_price = price;
    last_sale = sale;
    if (price == target_price)
        target_p = len;
    len++;
    while ((cin >> price >> sale) && price!= -1 && sale!= -1) {
        int delta_sale = (sale - last_sale) / (price - last_price);
        for (int p = last_price + 1; p < price; p++) {
            last_sale += delta_sale;
            sales.push_back(last_sale);
            if (p == target_price)
                target_p = len;
            len++;
        }
        sales.push_back(sale);
        last_price = price;
        last_sale = sale;
        if (price == target_price)
            target_p = len;
        len++;
    }
    cin >> tail_speed;
    while (last_sale > tail_speed) {
        last_price++;
        last_sale -= tail_speed;
        sales.push_back(last_sale);
        if (last_price == target_price)
            target_p = len;
        len++;
    }

    vector<int> total;
    for (int i = 0; i < len; i++)
        total.push_back(i * sales[i]);

    int max_forward, max_backward, x = 0;
    while (true) {
        max_forward = *max_element(total.begin(),
                total.begin() + target_p);
        max_backward = *max_element(total.begin() + target_p + 1,
                total.end());
        int t = total[target_p];
        if (max_forward <= t && max_backward <= t) {
            cout << x << endl;
            break;
        } else if (max_forward >= t && max_backward >= t) {
            cout << "NO SOLUTION" << endl;
            break;
        }
        if (max_forward > t) {
            for (int i = 0; i < len; i++)
                total[i] -= sales[i];
            x--;
        } else {
            for (int i = 0; i < len; i++)
                total[i] += sales[i];
            x++;
        }
    }

    return 0;
}
```
**核心实现思想**：
1. 读取输入的目标价格和价格 - 销量数据，对未输入的价格和销量进行线性插值。
2. 处理超出最大价格后的销量递减。
3. 计算每种价格下的初始总利润。
4. 以目标价格为分界点，分别找出价格低于和高于目标价格的两部分的最大总利润。
5. 根据两部分最大总利润与目标价格总利润的大小关系，调整补贴或税收金额，直到满足条件或无解。

### 最优关键思路或技巧
- **暴力枚举**：简单直接，适合计算机处理，通过从小到大枚举补贴或税收金额，可直接得到绝对值最小的解。
- **线性插值**：处理未输入的价格和销量，根据相邻价格和销量的关系，按线性规则计算中间价格的销量。
- **不等式求解**：通过列出不等式，确定补贴或税收的取值范围，再从中选取绝对值最小的解，思路严谨。
- **二分查找**：在数据量较大时，可使用二分查找优化查找过程，提高效率。

### 可拓展之处
同类型题或类似算法套路：
- 其他经济类问题，如成本控制、利润最大化等，可通过建立数学模型，使用枚举、不等式求解等方法解决。
- 线性插值在其他领域也有广泛应用，如数据处理、图像处理等，可用于填充缺失数据。

### 推荐题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：动态规划问题，通过状态转移方程计算路径数量，与本题的数学建模思想类似。
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)：0 - 1 背包问题，通过枚举和状态转移方程求解最大价值，与本题的枚举思想类似。
3. [P1216 [USACO1.5] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：动态规划问题，通过状态转移方程计算最大路径和，与本题的数学建模思想类似。

### 个人心得摘录与总结
- **Mitch谜团**：强调计算机适合暴力枚举，认为自己的题解最通俗易懂。
- **Ofnoname**：理解题意和题解花费了很多时间，在细节上出过问题，通过写题解进行总结。
- **majorli**：详细分析了题目中的不明确之处，如插值点是否会得到小数销量、确保指定价格的总利润最高是指严格最高还是可以有其他价格点和它一样高，并给出了相应的处理方法。提醒在解题时要注意题目细节，避免被样例数据误导。

---
处理用时：86.30秒
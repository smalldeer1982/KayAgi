# 题目信息

# [NOIP 2012 提高组] 开车旅行

## 题目描述

小 $\text{A}$ 和小 $\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。
 
旅行过程中，小 $\text{A}$ 和小 $\text{B}$ 轮流开车，第一天小 $\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    

小 $\text{A}$ 和小 $\text{B}$ 的驾驶风格不同，小 $\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。

在启程之前，小 $\text{A}$ 想知道两个问题：

1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值最小（如果小 $\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。

2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\text{A}$ 开车行驶的路程总数以及小 $\text B$ 行驶的路程总数。


## 说明/提示

【样例1说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)

各个城市的海拔高度以及两个城市间的距离如上图所示。

如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。

如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\text B$ 会直接在城市 $3$ 结束旅行。

如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。

如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。


【样例2说明】

当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \to 2 \to 3 \to 8 \to 9$，小 $\text A$ 走的距离为 $1+2=3$，小 $\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）

如果从城市 $2$ 出发，则路线为 $2 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $3$ 出发，则路线为 $3 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $4$ 出发，则路线为 $4 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $5$ 出发，则路线为 $5 \to 7 \to 8$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $5,1$。

如果从城市 $6$ 出发，则路线为 $6 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$5,1$。

如果从城市 $7$ 出发，则路线为 $7 \to 9 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $8$ 出发，则路线为 $8 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,0$。

如果从城市 $9$ 出发，则路线为 $9$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。

如果从城市 $10$ 出发，则路线为 $10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$0,0$。

从城市 $2$ 或者城市 $4$ 出发小 $\text A$ 行驶的路程总数与小 $\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。

【数据范围与约定】  

对于 $30\%$ 的数据，有$1\le n \le 20,1\le m\le 20$；  
对于$40\%$ 的数据，有$1\le n \le 100,1\le m\le 100$；  
对于 $50\%$ 的数据，有$1\le n \le 100,1\le m\le 1000$；  
对于 $70\%$ 的数据，有$1\le n \le 1000,1\le m\le 10^4$；   
对于 $100\%$ 的数据：$1\le n,m \le 10^5$，$-10^9 \le h_i≤10^9$，$1 \le s_i \le n$，$0 \le x_i \le 10^9$   
数据保证 $h_i$ 互不相同。


## 样例 #1

### 输入

```
4 
2 3 1 4 
3 
4 
1 3 
2 3 
3 3 
4 3
```

### 输出

```
1 
1 1 
2 0 
0 0 
0 0 ```

## 样例 #2

### 输入

```
10 
4 5 6 1 2 3 7 8 9 10 
7 
10 
1 7 
2 7 
3 7 
4 7 
5 7 
6 7 
7 7 
8 7 
9 7 
10 7```

### 输出

```
2 
3 2 
2 4 
2 1 
2 4 
5 1 
5 1 
2 1 
2 0 
0 0 
0 0```

# AI分析结果

### 综合分析与结论
本题的核心在于解决两个问题：一是找出给定距离下，使小 A 和小 B 行驶路程比值最小的出发城市；二是计算任意给定出发城市和距离时，小 A 和小 B 各自的行驶路程。各题解的整体思路均为先预处理出每个城市小 A 和小 B 下次到达的城市，再运用倍增算法优化查询过程。

### 所选题解
- **作者：yangrunze（5星）**
    - **关键亮点**：思路清晰，详细阐述了倍增思想在本题中的应用，对预处理和状态转移方程的推导解释细致，代码注释丰富，可读性强。
    - **个人心得**：双向链表实现时细节和坑较多，作者调了一晚上，提醒要注意判定当前元素的前驱和后继不存在的情况。
- **作者：Neumann（4星）**
    - **关键亮点**：提出将小 A 和小 B 开车的两天看作“一天”，简化了程序实现细节，同时给出了使用 set 实现预处理的方法。
    - **个人心得**：一开始认为搞定 pre 就能轻松解题，但后来发现倍增有很多技巧，还提到 set 常数极大，在学校机房的 cena 上运行时最后一个点需要调整时间限制才能通过。
- **作者：algo_h（4星）**
    - **关键亮点**：借助 STL `map` 维护每个城市后续所有城市的海拔和编号，实现较为简单方便，代码结构清晰。

### 重点代码及核心实现思想
#### yangrunze 的代码
```cpp
// 预处理 ga 和 gb
for(int i=1;i<n;i++){
    int p=pos[i],p1=h[p].pre,p2=h[p].nxt;                                  
    if(p1&&(h[p].hi-h[p1].hi<=h[p2].hi-h[p].hi||!p2))      
        gb[i]=h[p1].id,ga[i]=choose(h[p1].pre,p2,p);
    else gb[i]=h[p2].id,ga[i]=choose(p1,h[p2].nxt,p);	
    del(p);
}

// 倍增推出 f, da, db
for(int i=1;i<=t;i++){
    for(int j=1;j<=n;j++){
        for(int k=0;k<=1;k++){
            int l=(i==1)?k^1:k;
            if(f[i-1][j][k])f[i][j][k]=f[i-1][f[i-1][j][k]][l];
            if(f[i][j][k]){
                da[i][j][k]=da[i-1][j][k]+da[i-1][f[i-1][j][k]][l];
                db[i][j][k]=db[i-1][j][k]+db[i-1][f[i-1][j][k]][l];
            }
        }
    }
}

// 计算 calc 得到答案
void calc(int s,long long x){
    la=lb=0;
    int k=0;
    for(int i=t;i>=0;i--){
        if(f[i][s][k]&&da[i][s][k]+db[i][s][k]<=x){
            x-=da[i][s][k]+db[i][s][k];
            la+=da[i][s][k],lb+=db[i][s][k];
            if(!i)k^=1;
            s=f[i][s][k];
        }
    }
}
```
**核心实现思想**：先通过双向链表预处理出每个城市小 A 和小 B 下次到达的城市，再利用倍增算法预处理出从每个城市出发，行驶 $2^i$ 天到达的城市以及小 A 和小 B 行驶的路程，最后根据倍增结果计算答案。

#### Neumann 的代码
```cpp
// 预处理
void pre(){
    int cnt;
    for(int i=n;i>=1;i--){
        s.insert(h[i]);
        it=s.find(h[i]);
        cnt=0;
        // 寻找最近和次近城市
        if(it!=s.begin()){
            it--;
            temp[++cnt]=(node2){abs((*it).height-h[i].height),(*it).id};
            if(it!=s.begin()){
                it--;
                temp[++cnt]=(node2){abs((*it).height-h[i].height),(*it).id};
                it++;
            }
            it++;
        }
        if((++it)!=s.end()){
            temp[++cnt]=(node2){abs((*it).height-h[i].height),(*it).id};
            if((++it)!=s.end()){
                temp[++cnt]=(node2){abs((*it).height-h[i].height),(*it).id};
                it--;
            }
            it--;
        }
        sort(temp+1,temp+cnt+1);
        if(temp[1].id){
            Db[i]=temp[1].delt;
            Fb[i]=temp[1].id;
        }
        if(temp[2].id){
            Da[i]=temp[2].delt;
            Fa[i]=temp[2].id;
        }
    }
    for(int i=1;i<=n;i++){
        int f1=Fa[i],f2=Fb[Fa[i]];
        DDa[i][0]=f1!=0?Da[i]:0;
        DDb[i][0]=f2!=0?Db[f1]:0;
        fa[i][0]=f2;
    }
    for(int k=1;k<=16;k++)
        for(int i=1;i<=n;i++){
            if(fa[fa[i][k-1]][k-1]){
                fa[i][k]=fa[fa[i][k-1]][k-1];
                DDa[i][k]=DDa[i][k-1]+DDa[fa[i][k-1]][k-1];
                DDb[i][k]=DDb[i][k-1]+DDb[fa[i][k-1]][k-1];
            }
        }
}
```
**核心实现思想**：使用 set 实现的平衡树预处理出每个城市小 A 和小 B 下次到达的城市，将小 A 和小 B 开车的两天看作“一天”，然后进行倍增预处理，最后根据倍增结果查询答案。

#### algo_h 的代码
```cpp
// 预处理 A 和 B 在每个位置处的选择
void init()
{
    A.resize(n), B.resize(n);
    A[n - 1] = B[n - 1] = -1;
    map<int, int> heights;
    heights.emplace(H[n - 1], n - 1);
    for(int i = n - 2; i >= 0; --i) {
        vector<pair<long, int>> cands;
        auto r = heights.upper_bound(H[i]), l = r;
        if(r!= heights.end()) ++r;
        if(r!= heights.end()) ++r;
        if(l!= heights.begin()) --l;
        if(l!= heights.begin()) --l;
        for(; l!= r; ++l) {
            long dist = (labs(l->first - H[i]) << 1) | (l->first > H[i]);
            cands.emplace_back(dist, l->second);
        }
        if(cands.size() > 1) nth_element(cands.begin(), cands.begin() + 1, cands.end());
        B[i] = cands[0].second;
        A[i] = cands.size() > 1? cands[1].second : -1;
        heights.emplace(H[i], i);
    }

    // 倍增起点：走 2^0 步
    int log_l = 31 - __builtin_clz(max(n - 1, 1));
    AD.resize(log_l + 1), BD.resize(1);
    AD[0].assign(n, { -1, 0, 0 }), BD[0].assign(n, { -1, 0, 0 });
    for(int j = 0; j < n - 1; ++j) {
        if(A[j] >= 0) AD[0][j] = { A[j], abs(H[j] - H[A[j]]), 0 };
        if(B[j] >= 0) BD[0][j] = { B[j], 0, abs(H[j] - H[B[j]]) };
    }

    // 倍增
    for(int i = 1; i <= log_l; ++i) {
        AD[i].assign(n, { -1, 0, 0 });
        for(int j = 0; j < n - (1 << i); ++j) {
            auto [at, aa, ab] = AD[i - 1][j];
            if(at < 0) continue;
            auto [bt, ba, bb] = i == 1? BD[i - 1][at] : AD[i - 1][at];
            AD[i][j] = { bt, aa + ba, ab + bb };
        }
    }
}
```
**核心实现思想**：借助 STL `map` 维护每个城市后续所有城市的海拔和编号，预处理出每个城市小 A 和小 B 下次到达的城市，然后进行倍增预处理，最后根据倍增结果查询答案。

### 最优关键思路或技巧
- **预处理优化**：使用双向链表或 set 等数据结构，将预处理的时间复杂度优化到 $O(n)$ 或 $O(n\log n)$。
- **倍增算法**：利用二进制分组的思想，将查询的时间复杂度优化到 $O(\log n)$。
- **简化问题**：将小 A 和小 B 开车的两天看作“一天”，简化程序实现细节。

### 可拓展之处
同类型题或类似算法套路：
- 涉及路径规划和距离计算的问题，可考虑使用倍增算法优化查询过程。
- 需要预处理大量信息的问题，可使用双向链表、set、map 等数据结构优化预处理过程。

### 推荐题目
- [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
- [P1811 数列操作](https://www.luogu.com.cn/problem/P1811)
- [P2880 [USACO07JAN]Balanced Lineup G](https://www.luogu.com.cn/problem/P2880)

### 个人心得总结
- **yangrunze**：双向链表实现时要注意判定当前元素的前驱和后继不存在的情况，细节较多，调试时间长。
- **Neumann**：倍增有很多技巧，set 常数极大，在某些评测环境下可能需要调整时间限制。

---
处理用时：65.19秒
# 题目信息

# 三元上升子序列

## 题目描述

Erwin 最近对一种叫 `thair` 的东西巨感兴趣。。。

在含有 $n$ 个整数的序列 $a_1,a_2,\ldots,a_n$ 中，三个数被称作`thair`当且仅当 $i<j<k$ 且 $a_i<a_j<a_k$。

求一个序列中 `thair` 的个数。

## 说明/提示

#### 样例2 解释

$7$ 个 `thair` 分别是：

- 1 2 3
- 1 2 4
- 1 2 3
- 1 2 4
- 1 3 4
- 2 3 4
- 2 3 4

#### 数据规模与约定

- 对于 $30\%$ 的数据 保证 $n\le100$；
- 对于 $60\%$ 的数据 保证 $n\le2000$；
- 对于 $100\%$ 的数据 保证 $1 \leq n\le3\times10^4$，$1\le a_i\leq 10^5$。

## 样例 #1

### 输入

```
4
2 1 3 4```

### 输出

```
2```

## 样例 #2

### 输入

```
5
1 2 2 3 4```

### 输出

```
7```

# AI分析结果

### 综合分析与结论
这些题解主要围绕三元上升子序列的计数问题展开，核心思路多是枚举中间元素，利用乘法原理，通过计算每个元素左边比它小的元素个数和右边比它大的元素个数，将两者相乘并累加得到结果。为了高效计算这两个数量，大部分题解采用了树状数组或线段树等数据结构，同时为避免因数据范围大导致的空间问题，普遍使用了离散化处理。

### 所选题解
- **紫题（4星）**
    - **关键亮点**：思路清晰，先提出可拓展到M元上升子序列，采用DP结合树状数组优化的方法，给出了详细的状态转移方程推导和树状数组的使用说明，代码规范且注释完善。
    - **核心代码**：
```cpp
for(int i = 2; i <= 3; i++) {
    memset(c, 0, sizeof(c));
    for(int j = 1; j <= n; j++) {
        f[i][j] = ask(a[j]-1);
        add(a[j], f[i-1][j]);
    }
}
for(int i = 1; i <= n; i++) ans += f[3][i];
```
核心思想：通过外层循环枚举子序列长度，内层循环遍历数组元素，利用树状数组维护以`a[k]`为下标存储`f[i - 1][k]`的值，实现状态转移。

- **Dog_Two（4星）**
    - **关键亮点**：思路巧妙，直接枚举中间元素，详细阐述了如何利用树状数组计算左右两侧符合条件的元素个数，对离散化的必要性和实现方法解释清晰，代码简洁且有详细注释。
    - **核心代码**：
```cpp
for(int i=1;i<=n;++i){
    add(c1,_Q(A[i]),1);
    Lef[i]=sum(c1,_Q(A[i])-1);
}
for(int i=n;i>=1;--i){
    add(c2,_Q(A[i]),1);
    Rit[i]=n-i-(sum(c2,_Q(A[i]))-1);
}
long long ans=0;
for(int i=2;i<n;++i) ans+=Lef[i]*Rit[i];
```
核心思想：先正序遍历数组，利用树状数组`c1`计算每个元素左边比它小的元素个数；再逆序遍历数组，利用树状数组`c2`计算每个元素右边比它大的元素个数，最后根据乘法原理累加结果。

- **windows250（4星）**
    - **关键亮点**：提供了线段树的解法，对于初学者友好，详细说明了如何利用线段树维护每个元素前后符合条件的元素个数，通过离散化处理数据，代码结构清晰。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++)
{
    if(num[i]>1) smaller[i]=query(1,1,n,1,num[i]-1);
    update(1,1,n,num[i]);
}
memset(sum,0,sizeof(sum));
for(int i=n;i>=1;i--)
{
    if(num[i]<n) bigger[i]=query(1,1,n,num[i]+1,n);
    update(1,1,n,num[i]);
}
for(int i=1;i<=n;i++) ans+=(bigger[i]*smaller[i]);
```
核心思想：先正序遍历数组，利用线段树查询每个元素左边比它小的元素个数；清空线段树后逆序遍历数组，查询每个元素右边比它大的元素个数，最后根据乘法原理累加结果。

### 最优关键思路或技巧
- **枚举中间元素**：通过枚举中间元素，将问题转化为计算其左右两侧符合条件的元素个数，利用乘法原理求解，简化了问题的复杂度。
- **树状数组与线段树**：利用树状数组或线段树高效地维护前缀和，在 $O(\log n)$ 的时间复杂度内完成查询和更新操作，提高了算法效率。
- **离散化**：当数据范围较大时，通过离散化将数据映射到较小的区间，避免了因数组下标过大导致的空间问题。

### 可拓展之处
同类型题目如求多元上升子序列问题，可参考紫题的题解思路，将状态转移方程推广到M元上升子序列。类似算法套路包括利用树状数组或线段树解决逆序对、区间查询等问题。

### 推荐题目
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：考察树状数组或归并排序求逆序对的知识点。
- [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)：树状数组的基础模板题，可用于巩固树状数组的基本操作。
- [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：线段树的基础模板题，可用于学习线段树的基本操作。

### 个人心得摘录与总结
- **MuYC**：一开始不会用树状数组维护比当前元素大的元素，尝试求当前元素后面比它小的元素再用总数减去，但因存在重复元素不可行，后来将标准树状数组反过来用解决了问题。总结：在遇到问题时可尝试对已有算法进行变形和创新。
- **SNiFe**：改着改着就AC了，一开始看不懂自己的代码，仔细思考后才想通。总结：在编程过程中可能会意外得到正确结果，此时需要深入思考，理解代码的原理，才能真正掌握知识。 

---
处理用时：39.62秒
# 题目信息

# 守墓人

## 题目背景

 ![](https://cdn.luogu.com.cn/upload/pic/1406.png) 

在一个荒凉的墓地上，有一个令人尊敬的守墓人， 他看守的墓地从来没有被盗过， 所以人们很放心的把自己的先人的墓安顿在他那

守墓人能看好这片墓地是必然而不是偶然……

因为……守墓人懂风水 0.0

## 题目描述

他把墓地分为主要墓碑和次要墓碑， 主要墓碑只能有 $1$ 个， 守墓人把他记为 $1$ 号， 而次要墓碑有 $n-1$ 个，守墓人将之编号为 $2,3\dots n$，所以构成了一个有 $n$ 个墓碑的墓地。

而每个墓碑有一个初始的风水值，这些风水值决定了墓地的风水的好坏，所以守墓人需要经常来查询这些墓碑。

善于运用风水的守墓人，通过一次次逆天改命，使得自己拥有了无限寿命，没人知道他活了多久。这天，你幸运的拜访到了他，他要求你和他共同见证接下来几年他的战果，但不过他每次统计风水值之和都需要你来帮他计算，算错了他会要你命 QAQ

风水也不是不可变，除非遭遇特殊情况，已知在接下来的 $2147483647$ 年里，会有 $f$ 次灾难，守墓人会有几个操作：

1. 将 $[l,r]$ 这个区间所有的墓碑的风水值增加 $k$。

2.将主墓碑的风水值增加 $k$

3.将主墓碑的风水值减少 $k$

4.统计 $[l,r]$ 这个区间所有的墓碑的风水值之和

5.求主墓碑的风水值

上面也说了，很多人会把先人的墓安居在这里，而且守墓人活了很多世纪→\_→，墓碑的数量会多的你不敢相信= =

守墓人和善的邀请你帮他完成这些操作，要不然哪天你的旅馆爆炸了，天上下刀子.....

为了活命，还是帮他吧


## 说明/提示

$20\%$ 的数据满足：$1\leq n\leq 100$

$50\%$ 的数据满足：$1\leq n\leq 6000$

$100\%$ 的数据满足：$1\leq n,f\leq 2 \times 10^5$，答案不超过 64 位整数。


## 样例 #1

### 输入

```
5 7
0 0 0 0 0
1 1 5 1
1 1 3 3
2 3
3 1
4 1 5
2 1
5```

### 输出

```
16
7```

# AI分析结果

### 综合分析与结论
本题主要涉及区间修改和区间查询操作，题解中使用了线段树、树状数组和分块三种数据结构来解决问题。

- **线段树**：大多数题解采用线段树，它能高效处理区间修改和查询。通过懒标记优化，避免不必要的节点更新，提高效率。将主墓碑操作看作特殊区间处理，简化代码逻辑。
- **树状数组**：利用差分思想，结合两个树状数组分别维护差分数组及其与下标的乘积，实现区间修改和查询。代码简洁，常数较小。
- **分块**：将数组分成若干块，对每块进行标记和维护，通过暴力枚举和块的整体操作实现区间修改和查询。实现简单，但效率相对较低。

### 所选题解
- **顾z（5星）**
    - **关键亮点**：提供树状数组和线段树两种解法，详细介绍差分思想和树状数组原理，代码注释清晰，运行时间短。
    - **个人心得**：提到感谢troubler给予树状数组AC此题的机会，体现了交流学习的重要性。
- **rainygame（4星）**
    - **关键亮点**：默认读者有树状数组基础，推导差分查询前缀和公式，清晰阐述两个树状数组的维护方法。
    - **个人心得**：无
- **Minecraft万岁（4星）**
    - **关键亮点**：思路清晰，将主墓操作统一为区间操作，给出线段树模板代码，还提供学习线段树的参考资料。
    - **个人心得**：强调使用位运算和注意数据范围，避免常见错误。

### 重点代码及核心思想
#### 顾z - 树状数组解法
```cpp
IL void add(int pos,int x)
{
	for(RI i=pos;i<=n;i+=lowbit(i))
		sum1[i]+=x,sum2[i]+=pos*x;
}
IL long long query(int pos)
{
	long long res=0;
	for(RI i=pos;i;i-=lowbit(i))
		res+=(pos+1)*sum1[i]-sum2[i];
	return res;
} 
```
核心思想：利用差分思想，通过两个树状数组`sum1`和`sum2`分别维护差分数组和差分数组与下标的乘积，实现区间修改和查询。

#### rainygame - 树状数组解法
```cpp
void add(int i, long long k){  // 维护树状数组 
    int x = i-1;
    while(i <= n){
        c1[i] += k;
        c2[i] += x*k;
        i += lowbit(i);
    }
}
void add(int l, int r, long long k){  // 将[l,r]的的全部+k 
	add(l, k);
	add(r+1, -k);
}
long long get_sum(int i){  // 计算[1,i]的和 
    long long ans = 0;
    int x = i;
    while (i){
        ans += x*c1[i] - c2[i];
        i -= lowbit(i);
    }
    return ans;
}
```
核心思想：同样基于差分，通过两个树状数组`c1`和`c2`维护，对区间修改时在区间端点进行操作，查询时利用公式计算前缀和。

#### Minecraft万岁 - 线段树解法
```cpp
inline void update(ll nl,ll nr,ll l,ll r,ll p,ll k)
{
    if(nl<=l&&r<=nr)
    {
        ans[p]+=k*(r-l+1);
		lazy[p]+=k;
		return ;
    } 
    push_down(p,l,r);
	ll mid=(l+r)>>1;
    if(nl<=mid) update(nl,nr,l,mid,p<<1,k);
    if(nr>mid) update(nl,nr,mid+1,r,p<<1|1,k);
    push_up(p);
}
inline ll query(ll q_x,ll q_y,ll l,ll r,ll p)
{
    ll res=0;
    if(q_x<=l&&r<=q_y)return ans[p];
    ll mid=(l+r)>>1;
	push_down(p,l,r);
    if(q_x<=mid) res+=query(q_x,q_y,l,mid,p<<1);
    if(q_y>mid) res+=query(q_x,q_y,mid+1,r,p<<1|1);
    return res;
}
```
核心思想：使用线段树进行区间修改和查询，通过懒标记`lazy`优化，减少不必要的节点更新。

### 最优关键思路或技巧
- **差分思想**：结合树状数组，将区间修改转化为端点操作，简化问题。
- **懒标记优化**：在线段树中使用懒标记，避免频繁更新节点，提高效率。
- **统一操作**：将主墓碑操作看作特殊区间，统一处理，减少代码复杂度。

### 拓展思路
同类型题或类似算法套路：
- 区间最值查询：可使用线段树或ST表。
- 区间染色问题：线段树结合懒标记。
- 动态区间和问题：树状数组或线段树。

### 推荐题目
- P3372 【模板】线段树 1
- P3368 【模板】树状数组 2
- P2068 统计和

### 个人心得总结
- **顾z**：感谢交流带来的新解题思路，体现学习中交流的重要性。
- **Minecraft万岁**：强调使用位运算和注意数据范围，避免常见错误。
- **tcswuzb**：分享调试过程中的RE、TLE、WA问题及解决方法，提醒注意特殊情况处理。 

---
处理用时：37.75秒
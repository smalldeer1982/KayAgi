# 题目信息

# 寒假作业

## 题目背景

zzs 和 zzy 正在被寒假作业折磨，然而他们有答案可以抄啊。


## 题目描述

他们共有 $n$ 项寒假作业。zzy 给每项寒假作业都定义了一个疲劳值 $a_i$，表示抄这个作业所要花的精力。

zzs 现在想要知道，有多少组连续的寒假作业的疲劳值的平均值不小于 $k$？

简单地说，给定一个长度为 $n$ 的正整数序列 $\{a_i\}$，求出有多少个**连续**子序列的平均值不小于 $k$。


## 说明/提示

#### 样例 1 解释

共有 $6$ 个连续的子序列，分别是 $(1)$、$(2)$、$(3)$、$(1,2)$、$(2,3)$、$(1,2,3)$，平均值分别为 $1$、$2$、$3$、$1.5$、$2.5$、$2$，其中平均值不小于 $2$ 的共有 $4$ 个。

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 100$。
- 对于 $50\%$ 的数据，保证 $n \leq 5000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq a_i,k \leq 10^4$。

## 样例 #1

### 输入

```
3 2
1
2
3
```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
本题主要求解连续子序列平均值不小于 $k$ 的数量，核心思路是通过数学转化将问题简化，再利用多种算法求解。各题解大多先将所有数减去 $k$，把问题转化为求区间和不小于 $0$ 的连续子序列数量，进而转化为顺序对问题。常见的解决算法有树状数组、cdq 分治、归并排序、平衡树等。

### 所选题解
- **作者：ghj1222 (赞：28)  ★★★★**
    - **关键亮点**：思路清晰，通过 cdq 分治解决问题，代码简洁易懂，对分治过程的处理逻辑明确。
    - **核心实现思想**：先将所有数减去 $k$，转化为区间和不小于 $0$ 的问题。对于区间 $[l, r]$，先递归计算 $[l, mid]$ 和 $[mid + 1, r]$ 的贡献，再计算跨过中点的区间贡献，通过后缀和、前缀和及双指针统计答案。
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int n, k, a[100010];
int tmp[100010];

long long cdq(int l, int r)
{
    if (l == r) return a[l] >= 0;
    int mid = (l + r) / 2;
    long long ans = cdq(l, mid) + cdq(mid + 1, r);
    tmp[mid] = a[mid];
    tmp[mid + 1] = a[mid + 1];
    for (int i = mid - 1; i >= l; i--)
        tmp[i] = tmp[i + 1] + a[i];
    for (int i = mid + 2; i <= r; i++)
        tmp[i] = tmp[i - 1] + a[i];
    sort(tmp + l, tmp + mid + 1);
    sort(tmp + mid + 1, tmp + r + 1);
    for (int i = l, j = r; i <= mid; i++)
    {
        while (j > mid && tmp[i] + tmp[j] >= 0) j--;
        ans += r - j;
    }
    return ans;
}

int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]), a[i] -= k;
    printf("%lld\n", cdq(1, n));
    return 0;
}
```
- **作者：WanderingTrader (赞：16)  ★★★★**
    - **关键亮点**：详细介绍了树状数组和 cdq 分治两种解法，对思路的分析和代码的解释都很清晰，还对两种解法的优缺点进行了对比。
    - **核心实现思想 - 树状数组**：将所有数减去 $k$ 后求前缀和，问题转化为二维偏序问题。通过离散化处理可能为负的前缀和，利用树状数组统计顺序对数量。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn=1e5+5;
int a[maxn],id[maxn],rk[maxn],bit[maxn],n,k;
LL ans;
bool cmpID(int u,int v){return a[u]<a[v]||(a[u]==a[v]&&u<v);}
int LSB(int x){return x&-x;}
void add(int x){for(;x<=n+1;x+=LSB(x)) ++bit[x];}
int query(int x)
{
    int sum=0;
    for(;x;x-=LSB(x)) sum+=bit[x];
    return sum;
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;++i) scanf("%d",a+i); 
    for(int i=1;i<=n;++i) {a[i]+=a[i-1]-k; id[i]=i;}
    sort(id,id+n+1,cmpID);
    for(int i=0;i<=n;++i) rk[id[i]]=i+1;
    for(int i=0;i<=n;++i)
    {
        ans+=query(rk[i]);
        add(rk[i]);
    }
    printf("%lld\n",ans);
    return 0;
}
```
    - **核心实现思想 - cdq 分治**：将原序列划分为 $[l, mid]$ 和 $(mid, r]$ 两部分，递归求解两部分内部的偏序，在合并序列时计算跨区间的偏序，通过双指针提高效率。
```cpp
void cdq(int l,int r)
{
    if(l==r) return;
    int mid=(l+r)>>1,i=l,j=mid+1,k=l;
    cdq(l,mid); cdq(mid+1,r);
    for(j=mid+1;j<=r;)
    {
        while(i<=mid&&a[i]<=a[j]) t[k++]=a[i++];
        t[k++]=a[j++];
        ans+=i-l;
    }
    for(;i<=mid;) t[k++]=a[i++];
    for(i=l;i<=r;++i) a[i]=t[i];
}
```
- **作者：Tenshi (赞：7)  ★★★★**
    - **关键亮点**：通过数学推导将问题转化为二维偏序问题，利用分治和归并排序统计贡献，思路简洁明了。
    - **核心实现思想**：推导出 $S_r - kr \geq S_l - kl$ 的关系，记 $v[x] = S_x - kx$，通过分治和归并排序统计满足条件的数对数量。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

typedef long long ll;
const int N=1e5+5;
int n,k;
int v[N], tmp[N];

ll res=0;
void cdq(int l,int r){
    if(l>=r) return;
    int mid=l+r>>1;
    cdq(l,mid), cdq(mid+1,r);
    
    ll sum=0;
    for(int i=l, j=mid+1, k=l; k<=r; k++)
        if(j>r || i<=mid && v[i]<=v[j]) sum++, tmp[k]=v[i++];
        else res+=sum, tmp[k]=v[j++];
    for(int k=l; k<=r; k++) v[k]=tmp[k];	
}

int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>v[i], v[i]+=v[i-1];
    
    for(int i=1;i<=n;i++) v[i]-=k*i;
    
    cdq(0,n);
    
    cout<<res<<endl;
    
    return 0;
}
```

### 最优关键思路或技巧
- **数学转化**：将求平均值不小于 $k$ 的连续子序列数量问题，通过将所有数减去 $k$，转化为求区间和不小于 $0$ 的连续子序列数量，再进一步转化为顺序对问题，简化了问题的复杂度。
- **数据结构与算法结合**：利用树状数组、cdq 分治、归并排序等算法和数据结构，高效地解决顺序对问题，时间复杂度大多能达到 $O(n\log n)$。
- **离散化处理**：当数据范围较大或存在负数时，通过离散化将数据映射到较小的范围，方便使用树状数组等数据结构进行处理。

### 可拓展之处
- **同类型题**：涉及区间平均值、区间和的统计问题，以及二维偏序、顺序对、逆序对的求解问题。
- **类似算法套路**：对于涉及区间统计和偏序关系的问题，可以考虑使用树状数组、cdq 分治、归并排序等算法，通过数学转化将问题简化为可处理的形式。

### 推荐题目
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：考察逆序对的求解，与本题中顺序对的求解思路类似。
- [P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)：涉及三维偏序问题，可使用 cdq 分治等算法解决。
- [P2804 最短路](https://www.luogu.com.cn/problem/P2804)：与本题有双倍经验关联，可能涉及区间和、平均值等相关知识点。

### 个人心得摘录与总结
- **WanderingTrader**：提到树状数组好想、好写、不易写挂，但因要离散化，时间和空间复杂度相对较高，cdq 分治虽然效率更高，但容易写挂，提醒在实际解题中要根据情况选择合适的算法。 

---
处理用时：53.68秒
# 题目信息

# 红色的幻想乡

## 题目背景

蕾米莉亚的红雾异变失败后，很不甘心。


## 题目描述

经过上次失败后，蕾米莉亚决定再次发动红雾异变，但为了防止被灵梦退治，她决定将红雾以奇怪的阵势释放。

我们将幻想乡看做是一个 $n \times m$的方格地区，一开始没有任何一个地区被红雾遮盖。蕾米莉亚每次站在某一个地区上，向东南西北四个方向各发出一条无限长的红雾，可以影响到整行/整列，但不会影响到她所站的那个地区。如果两阵红雾碰撞，则会因为密度过大而沉降消失。灵梦察觉到了这次异变，决定去解决它。但在解决之前，灵梦想要了解一片范围红雾的密度。可以简述为两种操作:

``1 x y`` 蕾米莉亚站在坐标 $(x,y)$ 的位置向四个方向释放无限长的红雾。

``2 x1 y1 x2 y2`` 询问左上点为$(x1,y1)$，右下点为 $(x2,y2)$ 的矩形范围内，被红雾遮盖的地区的数量。


## 说明/提示

#### 样例输入输出 1 解释

用``o``表示没有红雾，``x``表示有红雾，两次释放红雾后幻想乡地图如下:

```
oxox
xoxo
oxox
xoxo
```

---

#### 数据规模与约定

- 对于 $20\%$ 的数据，$1 \le n,m,q \le 200$。
- 对于 $40\%$ 的数据，$1 \le n,m,q \le 10^3$。
- 对于 $100\%$ 的数据，$1 \le n,m,q \le 10^5$，$1 \le x_1,x_2,x \le n$，$x_1 \le x_2$，$1 \le y_1,y_2,y \le m$，$y_1 \le y_2$。

## 样例 #1

### 输入

```
4 4 3
1 2 2
1 4 4
2 1 1 4 4
```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是将二维问题转化为一维问题，通过维护行和列的状态来解决问题。具体做法是使用线段树或树状数组进行单点修改和区间查询，利用容斥原理计算红雾覆盖的区域数量。不同题解在数据结构选择、代码实现风格和细节处理上有所差异，但整体思路一致。

### 所选题解
- **作者：Hurricane、 (赞：41)，4星**
  - **关键亮点**：思路清晰，通过图形辅助理解，对容斥原理的推导较为详细，代码简洁且有注释，使用数组指针避免代码重复。

### 重点代码
```cpp
// 线段树更新函数
void update(int *a,int num){
    a[num]=a[num<<1]+a[num<<1|1];
}
// 线段树单点修改函数
void change(int *a,int p,now){
    if(l==r){
        a[num]^=1;
        return;
    }
    int mid=l+r>>1;
    if(p<=mid)change(a,p,ls);
    else change(a,p,rs);
    update(a,num);
}
// 线段树区间查询函数
int que(int *a,int al,int ar,now){
    if(al<=l&&r<=ar)
        return a[num];
    int mid=l+r>>1,ans=0;
    if(al<=mid)ans+=que(a,al,ar,ls);
    if(mid<ar)ans+=que(a,al,ar,rs);
    return ans;
}
// 主函数
int main(){
    scanf("%d%d%d",&n,&m,&q);
    while(q--){
        int cmd;
        scanf("%d",&cmd);
        if(cmd==1){
            int x0,y0;
            scanf("%d%d",&x0,&y0);
            change(x,x0,1,n,1);
            change(y,y0,1,m,1);
        }
        else{
            scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
            long long xx=que(x,x1,x2,1,n,1),
                      yy=que(y,y1,y2,1,m,1);
            printf("%lld\n",xx*(long long)(y2-y1+1)+
                    yy*(long long)(x2-x1+1)-
                    (long long)(xx*yy<<1));
        }
    }
    return 0;
}
```
**核心实现思想**：使用两个线段树分别维护行和列的状态，单点修改时将对应位置异或1，区间查询时返回区间内状态为1的数量，最后根据容斥原理计算红雾覆盖的区域数量。

### 最优关键思路或技巧
- **降维思想**：将二维问题转化为一维问题，通过维护行和列的状态来解决问题，降低了问题的复杂度。
- **容斥原理**：利用容斥原理计算红雾覆盖的区域数量，避免了重复计算。
- **线段树或树状数组**：使用线段树或树状数组进行单点修改和区间查询，提高了操作的效率。

### 可拓展之处
同类型题或类似算法套路：
- 二维矩阵的区间修改和查询问题，可以使用二维线段树或树状数组解决。
- 涉及行列操作的问题，如矩阵的旋转、翻转等，可以通过维护行和列的状态来解决。

### 推荐题目
- [P3913 车的攻击](https://www.luogu.com.cn/problem/P3913)
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
- [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

### 个人心得
- **作者：Zzxpy**：三个月前做这道题时，没有学数据结构，找到了正解的思路，但没有树状数组或线段树的辅助，打了半个暴力。这说明掌握合适的数据结构对于解决问题的重要性。

---
处理用时：25.22秒
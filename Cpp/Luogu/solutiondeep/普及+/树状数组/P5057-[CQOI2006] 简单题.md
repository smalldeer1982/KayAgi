# 题目信息

# [CQOI2006] 简单题

## 题目描述

有一个 $n$ 个元素的数组，每个元素初始均为 $0$。有 $m$ 条指令，每条指令为两种操作中的一种：
1. 让其中一段连续序列数字反转；（即 $0$ 变 $1$，$1$ 变 $0$）
2. 询问某个元素的值。

例如当 $n=20$ 时，$10$ 条指令如下：

![](https://cdn.luogu.com.cn/upload/pic/44663.png)


## 说明/提示

对于 $50\%$ 的数据，$1 \le n \le 10^3$，$1 \le m \le 10^4$；

对于 $100\%$ 的数据，$1 \le n \le 10^5$，$1 \le m \le 5 \times 10^5$，保证 $L \le R$。

## 样例 #1

### 输入

```
20 10
1 1 10
2 6
2 12
1 5 12
2 6
2 15
1 6 16
1 11 17
2 12
2 6```

### 输出

```
1
0
0
0
1
1```

# AI分析结果

### 综合分析与结论
这些题解提供了多种解决区间反转和单点查询问题的思路，主要运用了树状数组、线段树、分块、`bitset` 等数据结构和算法。树状数组和线段树是较为常见的方法，利用差分思想可以将区间修改转化为单点修改，从而用树状数组高效处理；线段树则通过懒标记实现区间修改和单点查询。分块和 `bitset` 方法相对更直观，但复杂度稍高。

### 所选题解
- **作者：小粉兔 (赞：227)  5星**
    - **关键亮点**：思路简洁清晰，利用差分序列（异或代替减法）将问题转化为单点修改和区间查询，用树状数组高效解决，代码简洁。
- **作者：Knight_Master (赞：48)  4星**
    - **关键亮点**：详细解释了差分的思想，结合树状数组和取模运算解决问题，代码注释详细，易于理解。
- **作者：Refined_heart (赞：44)  4星**
    - **关键亮点**：使用线段树解决问题，对线段树的区间修改和单点查询操作进行了详细的注释，适合学习线段树的同学参考。

### 重点代码及核心实现思想
#### 小粉兔的题解
```cpp
#include <cstdio>

int N, M, B[100001];
inline void A(int i) { for (; i <= N; i += i & -i) B[i] ^= 1; }
inline int Q(int i) { int A = 0; for (; i; i -= i & -i) A ^= B[i]; return A; }

int main() {
    scanf("%d%d", &N, &M);
    while (M--) {
        int opt, l, r;
        scanf("%d%d", &opt, &l);
        if (opt == 1) A(l), scanf("%d", &r), A(r + 1);
        else printf("%d\n", Q(l));
    }
    return 0;
}
```
**核心实现思想**：利用差分序列，每个元素的真实值是差分序列的异或前缀和。修改时只需要修改区间左右端点对应的差分序列的值，用树状数组维护差分序列的异或前缀和。

#### Knight_Master 的题解
```cpp
#include <bits/stdc++.h>
using namespace std;
long long d[100010], n ,m;

long long lowbit( long long x ){
    return x & (-x);
}

void add(long long x,long long v){
    while(x<=n){
        d[x]+=v;
        x+=lowbit(x);
    }
}
                
long long res;
                
long long ask(long long a){
    res=0;
    while(a!=0){
        res+=d[a];
        a-=lowbit(a);
    }
    return res;
}
                
long long h,x,y;
                
int main(){
    cin>>n>>m;
    while(m--){
        cin>>h;
        if(h==1) {
            cin>>x>>y;
            add(x,1); 
            add(y+1,1);
        }
        if(h==2){
            cin>>x;
            cout<<ask(x)%2<<endl;
        }	
    }
}
```
**核心实现思想**：使用差分思想，通过树状数组维护前缀和。每次区间修改时，在区间左端点加 1，右端点的下一个位置加 1，查询时求前缀和并对 2 取模。

#### Refined_heart 的题解
```cpp
struct node{
    long long l,r,w,f;
}tree[MAXN<<2];
long long n,m,ans,x,y;

void build(long long l,long long r,long long k){
    tree[k].l=l;
    tree[k].r=r;
    if(l==r){
        tree[k].w=0;
        return;
    }
    long long mid=(l+r)>>1;
    build(l,mid,k<<1);
    build(mid+1,r,k<<1|1);
    tree[k].w=tree[k<<1].w+tree[k<<1|1].w;
}

void down(long long k){
    tree[k<<1].f+=tree[k].f;
    tree[k<<1|1].f+=tree[k].f;
    tree[k<<1].w+=tree[k].f*(tree[k<<1].r-tree[k<<1].l+1);
    tree[k<<1|1].w+=tree[k].f*(tree[k<<1|1].r-tree[k<<1|1].l+1);
    tree[k].f=0;
}

void add(long long k){
    if(tree[k].l>=x&&tree[k].r<=y){
        tree[k].w+=(tree[k].r-tree[k].l+1);
        tree[k].f++;
        return;
    }
    if(tree[k].f)
      down(k);
    long long mid=(tree[k].l+tree[k].r)>>1;
    if(x<=mid)
      add(k<<1);
    if(y>mid)
      add(k<<1|1);
    tree[k].w=tree[k<<1].w+tree[k<<1|1].w;
}

void ask(long long k){
    if(tree[k].l==tree[k].r){
        ans=tree[k].w&1;
        return;
    }
    if(tree[k].f)
      down(k);
    int mid=(tree[k].l+tree[k].r)>>1;
    if(x<=mid)
      ask(k<<1);
    else
      ask(k<<1|1);
}

int main(){
    n=read();
    m=read();
    build(1,n,1);
    for(register int i=1;i<=m;i++){
        int p=read();
        ans=-1;
        if(p==1){
            x=read();
            y=read();
            add(1);
        }
        else{
            x=read();
            ask(1);
            printf("%lld\n",ans);
        }
    }
    return 0;
}
```
**核心实现思想**：使用线段树维护区间信息，通过懒标记实现区间修改，单点查询时将懒标记下传，最终结果对 2 取模。

### 最优关键思路或技巧
- **差分思想**：将区间修改转化为单点修改，降低时间复杂度。
- **树状数组**：高效维护前缀和或异或前缀和，适合处理单点修改和区间查询问题。
- **线段树**：通过懒标记实现区间修改和单点查询，可处理更复杂的区间操作。
- **`bitset`**：节省空间，可用于处理 01 序列的操作。

### 可拓展之处
同类型题或类似算法套路：
- 区间修改、区间查询问题，可使用线段树的区间更新和区间查询操作。
- 动态区间最值问题，可使用线段树或树状数组维护区间最值。
- 区间染色问题，可使用线段树的懒标记实现区间染色和单点查询。

### 推荐题目
- [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
- [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
- [P2572 [SCOI2010]序列操作](https://www.luogu.com.cn/problem/P2572)

### 个人心得摘录与总结
- **Refined_heart**：这是第一道用线段树 A 过的紫题，卡了三四次，在区间修改的地方卡了几次，感谢他人指导。总结：线段树的区间修改操作需要仔细处理懒标记。
- **EarthGiao**：用树状数组做这道题是为了练习，用线段树做调试了两个小时。总结：数据结构的实现需要耐心调试，多练习才能熟练掌握。

---
处理用时：50.56秒
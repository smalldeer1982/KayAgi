# 题目信息

# [USACO04OPEN] MooFest G 加强版

## 题目描述

每一年，约翰的 $ N $ 只奶牛参加奶牛狂欢节。这是一个全世界奶牛都参加的大联欢。狂欢节包括很多有趣的活动，比如干草堆叠大赛、跳牛栏大赛，奶牛之间有时还相互扎屁股取乐。当然，她们会排成一列嚎叫，来欢庆她们的节日。奶牛们的叫声实在刺耳，以致于每只奶牛的听力都受到不同程度的损伤。现在告诉你奶牛 $ i $ 的听力为 $ v_i $ ，这表示如果奶牛 $ j $ 想说点什么让她听到，必须用高于 $ v_i \times dis(i,j) $ 的音量。因此，如果奶牛 $ i $ 和 $ j $ 想相互交谈，她们的音量必须不小于 $ \max (v_i,v_j) \times dis(i,j) $。其中 $ dis(i,j) $ 表示她们间的距离。

现在 $ N $ 只奶牛都站在一条直线上了，每只奶牛还有一个坐标 $ x_i $。如果每对奶牛都在交谈，并且使用最小音量，那所有 $ N(N-1)/2 $ 对奶牛间谈话的音量之和为多少？

## 说明/提示

### 数据范围

因为原数据下 $O(N^2)$ 算法可以通过，所以新添加了一些增强数据。

原数据作为子任务 $1$，新添加的数据作为子任务 $2$。

- 子任务 $1$（$1$ 分）：$1 \leq N,V_i,x_i \leq 2 \times 10^4$。
- 子任务 $2$（$99$ 分）：$1 \leq N,V_i,x_i \leq 5 \times 10^4$。

## 样例 #1

### 输入

```
4
3 1
2 5
2 6
4 3```

### 输出

```
57```

# AI分析结果

### 综合分析与结论
本题的核心在于计算每对奶牛间谈话的音量之和，关键难点在于处理 `max(v_i, v_j)` 和 `|x_i - x_j|`。各位大神提供了多种解法，涵盖暴力枚举、分治、树状数组、线段树等。暴力枚举简单直接但时间复杂度高，适合小数据；分治、树状数组和线段树等方法通过排序和数据结构优化，时间复杂度较低，能处理大数据。

### 所选题解
- **作者：一只书虫仔 (赞：39)，4星**
    - **关键亮点**：采用分治思想，将问题拆分为 `max(v_i, v_j)` 和 `|x_i - x_j|` 两部分分别计算，通过预处理前缀和实现 $O(1)$ 计算，思路清晰。
- **作者：Laser_Crystal (赞：30)，4星**
    - **关键亮点**：使用树状数组维护坐标小于当前奶牛坐标的数量和坐标之和，推导出简洁的计算公式，代码实现简洁高效。
- **作者：EDqwq (赞：18)，4星**
    - **关键亮点**：对 `v` 值排序解决 `max` 问题，分情况处理 `|x_i - x_j|`，维护两个树状数组，思路清晰，代码逻辑明确。

### 重点代码
#### 一只书虫仔的分治代码
```cpp
int mid = (l + r) / 2;
solve(l, mid);
solve(mid + 1, r);
memset(sum, 0, sizeof(sum));
for (int i = l; i <= r; i++) sum[i] = sum[i - 1] + a[i].x;
int i = l - 1;
for (int j = mid + 1; j <= r; j++) {
    while (a[i + 1].x <= a[j].x && i < mid)
        i++;
    ans += a[j].v * ((i - l + 1) * a[j].x - sum[i] + sum[mid] - sum[i] - (mid - i) * a[j].x);
}
```
**核心思想**：将区间分为两半，递归计算两部分贡献，再计算跨区间贡献，通过前缀和优化计算。

#### Laser_Crystal 的树状数组代码
```cpp
for(register ll i=1; i<=n; i++)
{
    ll cnt=count_cnt(a[i].pos),sum=count_sum(a[i].pos);
    ans+=(cnt*a[i].pos-sum)*a[i].v;
    ans+=((z-sum)-(i-1-cnt)*a[i].pos)*a[i].v;
    add_cnt(a[i].pos,1);add_sum(a[i].pos,a[i].pos);
    z+=a[i].pos;
}
```
**核心思想**：对奶牛按音量排序，用树状数组维护坐标小于当前奶牛坐标的数量和坐标之和，推导出计算公式计算贡献。

#### EDqwq 的树状数组代码
```cpp
for(int i = 1;i <= n;i ++){
    int num = query1(a[i].x);
    int sum = query2(a[i].x);
    ans += (num * a[i].x - sum) * a[i].v;
    ans += ((summ - sum) - (i - num - 1) * a[i].x) * a[i].v;
    update1(a[i].x,1);
    update2(a[i].x,a[i].x);
    summ += a[i].x;
}
```
**核心思想**：对 `v` 值排序，分情况处理 `|x_i - x_j|`，维护两个树状数组分别记录数量和坐标和，计算贡献。

### 最优关键思路或技巧
- **排序优化**：对 `v` 或 `x` 进行排序，可简化 `max(v_i, v_j)` 的处理。
- **数据结构优化**：使用树状数组或线段树维护坐标数量和坐标和，降低时间复杂度。
- **分治思想**：将问题拆分为子问题，分别计算贡献，再合并结果。

### 可拓展之处
同类型题可参考涉及区间统计、最值计算、距离计算等问题，如逆序对、区间和查询等。类似算法套路包括排序优化、数据结构维护、分治思想等。

### 推荐题目
- P1908 逆序对
- P3374 树状数组 1
- P3372 线段树 1

### 个人心得摘录与总结
- **Laser_Crystal**：提到 `StudyingFather` 增加数据后 `O(n^2)` 算法无法通过，反映出数据增强对算法复杂度的要求。
- **Martini**：作为萌新分享二分思路，虽代码复杂、常数大，但提供了不同的思考方向。
- **船医**：强调树状数组长度设置的重要性，避免因设置错误导致死循环 TLE，提醒注意树状数组的细节。 

---
处理用时：31.71秒
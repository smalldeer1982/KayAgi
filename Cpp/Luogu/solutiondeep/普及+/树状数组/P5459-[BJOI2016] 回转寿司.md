# 题目信息

# [BJOI2016] 回转寿司

## 题目描述

酷爱日料的小Z经常光顾学校东门外的回转寿司店。在这里，一盘盘寿司通过传送带依次呈现在小Z眼前。  

不同的寿司带给小Z的味觉感受是不一样的，我们定义小Z对每盘寿司都有一个满意度。  

例如小Z酷爱三文鱼，他对一盘三文鱼寿司的满意度为 $10$；小Z觉得金枪鱼没有什么味道，他对一盘金枪鱼寿司的满意度只有 $5$；小Z最近看了电影《美人鱼》，被里面的八爪鱼恶心到了，所以他对一盘八爪鱼刺身的满意度是 $-100$。   

特别地，小Z是个著名的吃货，他吃回转寿司有一个习惯，我们称之为“狂吃不止”。具体地讲，当他吃掉传送带上的一盘寿司后，他会毫不犹豫地吃掉它后面的寿司，直到他不想再吃寿司了为止。  

今天，小Z再次来到了这家回转寿司店，$N$ 盘寿司将依次经过他的面前。其中，小Z对第 $i$ 盘寿司的满意度为$a_i$。  

小Z可以选择从哪盘寿司开始吃，也可以选择吃到哪盘寿司为止。他想知道共有多少种不同的选择，使得他的满意度之和不低于 $L$，且不高于 $R$。

注意，虽然这是回转寿司，但是我们不认为这是一个环上的问题，而是一条线上的问题。即，小Z能吃到的是输入序列的一个连续子序列；最后一盘转走之后，第一盘并不会再出现一次。

## 说明/提示

【数据范围】  

$1\le N \le 10^5$  
$|a_i| \le 10^5$   
$0\le L,R \le 10^9$

## 样例 #1

### 输入

```
5 5 9
1 2 3 4 5```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
本题要求找出序列中满足区间和在 $[L, R]$ 范围内的连续子序列的数量。各题解普遍先通过前缀和将问题转化为对于每个前缀和 $sum[r]$，找出满足 $sum[r] - R \leq sum[l - 1] \leq sum[r] - L$ 的 $sum[l - 1]$ 的数量。不同题解采用了多种数据结构和算法来解决该问题，主要包括 CDQ 分治、线段树、树状数组、平衡树等。

### 高评分题解
1. **作者：shentao1（5星）**
    - **关键亮点**：思路清晰，利用 CDQ 分治解决问题，代码简洁易懂，对问题的转化和处理过程有明确的说明。
    - **核心代码**：
```cpp
void cdq(int l,int r)
{
    if(l==r)return ;
    int mid=(l+r)/2;
    cdq(l,mid),cdq(mid+1,r);
    int head=l,tail=l-1;
    for(int i=mid+1;i<=r;i++)
    {
        while(tail+1<=mid && s[i]>=s[tail+1]+L)tail++;
        while(head<=mid && s[i]>s[head]+R)head++;
        ans+=tail-head+1;
    }
    sort(s+l,s+r+1);
}
```
    - **核心思想**：将序列分成左右两部分，先递归处理左右子问题，然后在合并过程中，使用双指针维护满足条件的区间，统计答案，最后对合并后的区间进行排序。

2. **作者：神眷之樱花（4星）**
    - **关键亮点**：详细解释了线段树的做法，对问题的分析和转化过程清晰，代码注释丰富。
    - **核心代码**：
```cpp
void insert(int p,LL val,int add,LL L = -MAXN,LL R = MAXN) {
    if(L == R) {
        tr[p].dat += add;
        return;
    }
    LL mid = (L + R) >> 1;
    if(val <= mid) {
        if(!tr[p].lc) tr[p].lc = build();
        insert(tr[p].lc,val,add,L,mid);
    }
    else {
        if(!tr[p].rc) tr[p].rc = build();
        insert(tr[p].rc,val,add,mid + 1,R);
    }
    tr[p].dat = tr[tr[p].lc].dat + tr[tr[p].rc].dat;
}

int query(int p,LL lf,LL rg,LL L = -MAXN,LL R = MAXN) {
    if(lf <= L && R <= rg) return tr[p].dat;
    LL mid = (L + R) >> 1; int ans = 0;
    if(lf <= mid) {
        if(!tr[p].lc) tr[p].lc = build();
        ans += query(tr[p].lc,lf,rg,L,mid);
    }
    if(rg >  mid) {
        if(!tr[p].rc) tr[p].rc = build();
        ans += query(tr[p].rc,lf,rg,mid + 1,R);
    }
    return ans;
}
```
    - **核心思想**：构建动态开点线段树，枚举右端点 $i$，查询满足 $pre[i] - R \leq pre[j] \leq pre[i] - L$ 的 $pre[j]$ 的数量，然后将 $pre[i]$ 插入线段树。

3. **作者：Heartlessly（4星）**
    - **关键亮点**：使用动态开点线段树解决问题，对问题的分析和算法复杂度有明确的说明，代码结构清晰。
    - **核心代码**：
```cpp
void update(int &x, LL q, LL p, LL l = -MAXM, LL r = MAXM) {
    if (!x) x = ++tot;
    if (l == r) {
        sum[x] += p;
        return;
    }
    LL mid = (l + r) >> 1;
    if (q <= mid) update(lson[x], q, p, l, mid);
    else update(rson[x], q, p, mid + 1, r);
    pushUp(x);
}

int query(int &x, LL ql, LL qr, LL l = -MAXM, LL r = MAXM) {
    if (!x) x = ++tot;
    if (ql <= l && qr >= r) return sum[x];
    LL res = 0, mid = (l + r) >> 1;
    if (ql <= mid) res += query(lson[x], ql, qr, l, mid);
    if (qr > mid) res += query(rson[x], ql, qr, mid + 1, r);
    return res;
}
```
    - **核心思想**：动态开点线段树维护前缀和，枚举右端点 $i$，查询满足 $pre[i] - R \leq pre[j] \leq pre[i] - L$ 的 $pre[j]$ 的数量，然后将 $pre[i]$ 插入线段树。

### 最优关键思路或技巧
- **前缀和转化**：将区间和问题转化为前缀和的差值问题，简化了问题的处理。
- **数据结构选择**：根据问题的特点，选择合适的数据结构（如 CDQ 分治、线段树、树状数组、平衡树等）来高效地解决问题。
- **动态开点**：在处理大规模数据时，使用动态开点的方式可以节省空间。

### 拓展思路
同类型题或类似算法套路：
- 区间和问题：可以使用前缀和、线段树、树状数组等数据结构来解决。
- 二维区间和问题：可以使用二维前缀和、二维线段树等数据结构来解决。
- 偏序问题：可以使用 CDQ 分治、树套树等算法来解决。

### 推荐题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：考察归并排序或树状数组求逆序对。
2. [P3374 树状数组 1](https://www.luogu.com.cn/problem/P3374)：基础的树状数组单点修改、区间查询问题。
3. [P3810 三维偏序](https://www.luogu.com.cn/problem/P3810)：考察 CDQ 分治解决三维偏序问题。

### 个人心得摘录与总结
- **作者：神眷之樱花**：感谢Nerovix大佬的及时回复，帮我找出了我爆零代码的问题。总结：在调试过程中，寻求他人的帮助可以更快地发现问题。
- **作者：Piwry**：因为满意度是有可能为负数的，这代表区间和不是递增的，因此我们需要边插入边查询。总结：在处理问题时，要考虑数据的特殊性，避免因为数据的特点导致算法出错。

---
处理用时：42.19秒
# 题目信息

# [eJOI 2019] 异或橙子

## 题目描述

Janez 喜欢橙子！他制造了一个橙子扫描仪，但是这个扫描仪对于扫描的每个橙子的图像只能输出一个  $32$ 位整数。

他一共扫描了 $n$ 个橙子，但有时他也会重新扫描一个橙子，导致这个橙子的 $32$ 位整数发生更新。

Janez 想要分析这些橙子，他觉得异或操作非常有趣，他每次选取一个区间从 $l$  至 $u$，他想要得到这个区间内所有子区间的异或和的异或和。

例如 $l=2,u=4$ 的情况，记橙子序列 $A$ 中第 $i$ 个橙子的整数是 $a_i$，那么他要求的就是：

$$a_2 \oplus a_3 \oplus a_4 \oplus (a_2\oplus a_3)\oplus(a_3\oplus a_4)\oplus(a_2\oplus a_3 \oplus a_4)$$

-------------------------------------

注：式子中的 $\oplus$ 代表按位异或运算。异或的运算规则如下。

对于两个数的第 $i$ 位，记为 $x,y$，那么：

|$x$|$y$|$x\oplus y$|
| :-----------: | :-----------: | :-----------: |
|$0$|$1$|$1$|
|$1$|$0$|$1$|
|$0$|$0$|$0$|
|$1$|$1$|$0$|

例：$13\oplus 23=26$

|$13=$|$0\cdots 001101$|
| --------: | :------: |
|$23=$|$0\cdots 010111$|
|$13\oplus 23=$|$0\cdots 011010$|

## 说明/提示

#### 输入输出样例 1 解释

- 最初，$A=[1,2,3]$，询问结果为 $1\oplus 2\oplus 3\oplus(1\oplus 2)\oplus (2\oplus 3)\oplus(1\oplus 2\oplus 3)=2$

- 修改后，第一个位置被修改为 $3$ ，询问的结果是 $3\oplus 2\oplus 3\oplus(3\oplus 2)\oplus (2\oplus 3)\oplus(3\oplus 2\oplus 3)=0$。

----------------------------

#### 数据规模与约定：

**本题采用多测试点捆绑测试，共有 5 个子任务**。

- Subtask 1(12 points)：$1\le n,q\le 10^2$，无特殊限制
- Subtask 2(18 points)：$1\le n,q\le 5\times 10^2$，且没有修改操作。
- Subtask 3(25 points)：$1\le n,q\le 5\times 10^3$，无特殊限制
- Subtask 4(20 points)：$1\le n,q\le 2\times 10^5$，且没有修改操作。
- Subtask 5(25 points)：$1\le n,q\le 2\times 10^5$，无特殊限制

对于所有数据，$0\le a_i\le 10^9,1\le n,q\le 2\times 10^5$

--------------------------

#### 说明

原题来自：[eJOI2019](http://ejoi2019.si/) Problem A. [XORanges](https://www.ejoi2019.si/static/media/uploads/tasks/xoranges-isc(1).pdf)

题面&数据来自：[LibreOJ](https://loj.ac/problem/3195)

## 样例 #1

### 输入

```
3 3
1 2 3
2 1 3
1 1 3
2 1 3```

### 输出

```
2
0```

## 样例 #2

### 输入

```
5 6
1 2 3 4 5
2 1 3
1 1 3
2 1 5
2 4 4
1 1 1
2 4 4```

### 输出

```
2
5
4
4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕异或橙子问题展开，核心思路均是利用异或运算的性质（$a \oplus a = 0$，$a \oplus 0 = a$）简化区间异或和的计算，再结合树状数组或线段树解决单点修改和区间查询问题。具体来说，当区间左右端点奇偶性不同时，答案为 0；当奇偶性相同时，答案是区间内与端点奇偶性相同位置元素的异或和。大部分题解使用两个树状数组分别维护奇数和偶数位置的信息，囧仙的题解使用一颗线段树进行维护。

### 所选题解
- **作者：Lice（5星）**
    - **关键亮点**：思路清晰，通过手玩样例得出结论，代码简洁明了，易于理解。
    - **核心代码**：
```cpp
struct bit{
    int dat[N];
    inline void update(int x,int p){
        for(;p<=n;p+=lowbit(p)) dat[p]^=x;
    }
    inline int xor_sum(int p){
        int x=0;
        for(;p;p-=lowbit(p)) x^=dat[p];
        return x;
    }
};
bit tree[2];
while(q--)
{
    int opt,x,y;
    scanf("%d%d%d",&opt,&x,&y);
    if(opt==1) tree[x&1].update(a[x]^y,x),a[x]=y;
    else
    {
        if((x+y)&1) printf("0\n");
        else printf("%d\n",tree[x&1].xor_sum(y)^tree[x&1].xor_sum(x-1));
    }
}
```
核心实现思想：使用两个树状数组分别维护奇数和偶数位置的异或和。单点修改时，异或上原数与新数的异或结果；区间查询时，根据左右端点奇偶性判断答案是否为 0，若不为 0 则通过树状数组计算异或和。

- **作者：Warriors_Cat（4星）**
    - **关键亮点**：详细推导了区间内元素出现次数的计算公式，逻辑严谨，代码结构清晰。
    - **核心代码**：
```cpp
struct BIT{
    int c[200010];
    inline int lowbit(int x){return x & (-x);}
    inline void change(int x, int y){
        while(x <= n){
            c[x] ^= y;
            x += lowbit(x);
        }
    }
    inline int query(int x){
        int ans = 0;
        while(x){
            ans ^= c[x];
            x -= lowbit(x);
        } 
        return ans;
    }
}tree[2];
for(int i = 1; i <= m; ++i){
    scanf("%d%d%d", &opt, &x, &y);
    if(opt == 1) tree[x & 1].change(x, a[x] ^ y), a[x] = y;
    else{
        if((x & 1) ^ (y & 1)) puts("0");
        else printf("%d\n", tree[x & 1].query(y) ^ tree[x & 1].query(x - 1));
    }
}
```
核心实现思想：同样使用两个树状数组分别维护奇数和偶数位置的异或和。通过推导得出区间内元素出现次数的计算公式，根据其奇偶性判断元素是否对答案有贡献。

- **作者：Hexarhy（4星）**
    - **关键亮点**：明确指出按位异或的常见性质，对修改和查询操作的解释详细，代码注释丰富。
    - **核心代码**：
```cpp
class BIT
{
private:
    int tree[MAXN];
public:
    int lowbit(const int x)
    {
        return x&-x;
    }
    void modify(int pos,const int x)
    {
        for(;pos<=n;pos+=lowbit(pos))
            tree[pos]^=x;
    }
    int query(int pos)
    {
        int res=0;
        for(;pos;pos-=lowbit(pos))
            res^=tree[pos];
        return res;
    }
}tree[2];
while(Q--)
{
    int opt,x,y;cin>>opt>>x>>y;
    if(opt==1)
    {
        tree[x&1].modify(x,a[x]^y);
        a[x]=y;
    }
    if(opt==2)
    {
        int ans=0;
        if(!((x&1)^(y&1)))
            ans=tree[x&1].query(y)^tree[x&1].query(x-1);
        cout<<ans<<endl; 
    }
}
```
核心实现思想：使用两个树状数组分别维护奇数和偶数位置的异或和。单点修改时，利用异或性质更新树状数组；区间查询时，根据左右端点奇偶性判断答案。

### 最优关键思路或技巧
- **利用异或性质简化计算**：通过 $a \oplus a = 0$ 和 $a \oplus 0 = a$ 的性质，将复杂的区间异或和计算简化。
- **分奇偶维护数据结构**：使用两个树状数组或一颗线段树分别维护奇数和偶数位置的信息，降低问题复杂度。

### 可拓展之处
同类型题或类似算法套路：
- 其他涉及区间异或和查询和单点修改的问题，可采用类似的数据结构维护。
- 对于一些需要根据元素出现次数的奇偶性来计算结果的问题，也可借鉴本题的思路。

### 推荐洛谷题目
- P3374 【模板】树状数组 1
- P3368 【模板】树状数组 2
- P1908 逆序对

### 个人心得
囧仙提到本题其他题解多使用树状数组分奇偶维护，而自己用一颗线段树维护，虽本题中该做法劣于树状数组，但在某些题目中更具拓展性，如处理动态修改点权，查询前缀内最多选 $k$ 个不相邻点的最大点权和问题时，需对线段树节点分类讨论。这表明在解决问题时，要根据具体情况选择合适的数据结构，同时关注算法的拓展性。 

---
处理用时：37.24秒
# 题目信息

# 「EZEC-10」Shape

## 题目背景

规定 $(x,y)$ 表示第 $x$ 行第 $y$ 列的格子。

## 题目描述

小 A 有一个 $n\times m$ 的网格，一些为白色格子，剩余为黑色格子。

小 A 选择四个整数 $x_1,x_2,y_1,y_2$，满足如下条件：

1. $1\le x_1<x_2\le n$ 且 $1\le y_1<y_2\le m$。
2. $x_1+x_2$ 为偶数。

若 $(x_1,y_1)\to (x_2,y_1),(x_1,y_2)\to (x_2,y_2),(\frac{x_1+x_2}{2},y_1)\to (\frac{x_1+x_2}{2},y_2)$ 这三段中的格子均为白色，则称这三段构成的图形为 H 形。

小 A 想知道，这个网格中存在多少不同的 H 形。

**两个 H 形相同，当且仅当两个 H 形的 $x_1,x_2,y_1,y_2$ 均相同。**

## 说明/提示

**【样例 1 解释】**

$(x_1,x_2,y_1,y_2)=(1,3,3,4)$ 的 H 形符合。

**【样例 2 解释】**

$(x_1,x_2,y_1,y_2)=(1,5,1,3),(2,4,1,3)$ 的 H 形符合。

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（1 point）：$n=2$。
- Subtask 2（9 points）：$ n,m\le 50$。
- Subtask 3（10 points）：$ n,m\le 100$，**时限为 $500ms$**。
- Subtask 4（30 points）：$ n,m\le 500$。
- Subtask 5（50 points）：无特殊限制。

对于 $100\%$ 的数据，$2\le n,m\le 2\times 10^3$。

## 样例 #1

### 输入

```
3 4
1 0 0 0
1 1 0 0
1 0 0 0```

### 输出

```
1```

## 样例 #2

### 输入

```
5 3
0 1 0
0 1 0
0 0 0
0 1 0
0 1 0```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解围绕在 $n\times m$ 的 $0 - 1$ 矩阵中统计由 $0$ 组成的 H 形数量展开。大部分题解先分析了暴力枚举的不可行性，然后通过预处理每个点向上、向下延伸的最大距离，利用不同方法来计算 H 形的数量。常见的做法是枚举横线，对横线上的点按延伸距离排序，根据点之间的匹配关系计算贡献。各题解的复杂度多在 $O(nm\log m)$ 左右，部分题解还针对不同数据范围给出了分情况处理的策略。

### 所选题解
- **作者：_Arahc_ (赞：7)，4星**
    - **关键亮点**：思路清晰，图文并茂地阐述了从枚举竖线不可行到枚举横线的转变过程，详细解释了如何预处理每个格子的延伸距离以及如何根据排序计算 H 形数量，还分享了使用优先队列 TLE 后改用 `sort` 优化的经验。
    - **个人心得**：考场上用优先队列 `priority_queue` 惨遭 TLE，可能是因为其每次插入和删除都是 $\log n$，整体带了一个常数，而 `sort` 是一个 $n\log n$，后续处理是 $n$ 的，整体常数小一些。如果用优先队列 TLE 的话，如果算法没有错误可以改成直接存数组里再排序。

### 重点代码
```cpp
// 预处理每个格子向上、向下延伸的距离，并取最小值
for(register int j=1;j<=m;++j){
    for(register int i=1;i<=n;++i){
        if(a[i][j]) up[i][j]=0;
        else up[i][j]=up[i-1][j]+1;
    }
    for(register int i=n;i>=1;--i){
        if(a[i][j]) dn[i][j]=0;
        else dn[i][j]=dn[i+1][j]+1;
    }
    for(register int i=1;i<=n;++i)
        for(register int j=1;j<=m;++j)
            s[i][j]=min(up[i][j],dn[i][j]);
}

// 枚举横线，计算 H 形数量
int i=1,j=1;
while(i<n){
    while(a[i][j] && j<=m) ++j;
    if(j>m){
        ++i,j=1;
        continue;
    }
    tot=0;
    while(!a[i][j] && j<=m){
        p[++tot]=s[i][j]-1;
        ++j;
    }
    std::sort(p+1,p+1+tot);
    for(register int k=1;k<=tot;++k) ans+=p[k]*(tot-k);
    if(j>m){
        ++i,j=1;
        continue;
    }
}
```
**核心实现思想**：先预处理每个格子向上、向下延伸的最大距离，取最小值得到该格子作为横线端点时可能形成的 H 形的最大高度的一半。然后枚举横线，将横线上的点按延伸距离排序，根据排序后的顺序计算每个点与后续点匹配形成的 H 形数量并累加。

### 最优关键思路或技巧
- **转换枚举对象**：从枚举竖线转变为枚举横线，降低了问题的复杂度，因为 H 形中横线的两端刚好是竖线的中点，通过枚举横线可以更方便地确定 H 形。
- **预处理延伸距离**：预处理每个格子向上、向下延伸的最大距离，避免了在后续计算中重复判断，提高了效率。
- **排序计算贡献**：对横线上的点按延伸距离排序，利用排序后的顺序计算每个点与后续点匹配形成的 H 形数量，保证了计算的不重不漏。

### 可拓展之处
同类型题可能涉及在矩阵中寻找其他特定形状（如矩形、三角形等）的数量，解题思路可以类似，先分析形状的特征，找到合适的枚举对象，预处理相关信息，再根据对象之间的关系计算数量。类似算法套路包括利用前缀和优化区间判断，通过排序或数据结构（如树状数组）优化统计过程。

### 推荐题目
- P1387 最大正方形：在矩阵中寻找最大的正方形，与本题类似，需要在矩阵中寻找特定形状。
- P2736 “破锣摇滚”乐队 Raucous Rockers：在给定条件下安排物品，需要考虑物品之间的关系和限制条件，与本题中判断 H 形的条件类似。
- P1004 方格取数：在矩阵中寻找路径并计算路径上的数值和，需要考虑路径的选择和数值的累加，与本题中计算 H 形数量的思路有一定相似性。

---
处理用时：30.92秒
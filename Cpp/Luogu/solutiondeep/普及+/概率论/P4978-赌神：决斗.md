# 题目信息

# 赌神：决斗

## 题目背景

**赌神 $\mathcal{CYJian}$，他回来了！**


## 题目描述

**$\mathcal{tomoo}$** 决定与 **$\mathcal{CYJian}$** 进行决斗！

已知 **$\mathcal{tomoo}$** 有 $\mathcal{N}$ 张扑克牌，每张扑克牌有一个$\mathcal{RP}$值$\mathcal{A_i}$， **$\mathcal{CYJian}$** 有$\mathcal{M}$张扑克牌，每张扑克牌有一个$\mathcal{RP}$值$\mathcal{B_i}$。

**$\mathcal{CYJian}$** 与 **$\mathcal{tomoo}$** 将会各自从他们的牌里任意取一段**连续区间**的牌决斗，谁的区间内的牌的$\mathcal{RP}$值的和更大，谁就赢了，请你帮忙求出 **$\mathcal{tomoo}$** 赢的概率。

## 说明/提示

### 样例解释
- 样例 $3$：不管怎么抽都是平均，胜率为 $0$
- 样例 $5$：共有 $9$ 种方案，其中 $3$ 次 **tomoo** 会赢，胜率为 $1/3$

### 数据范围
- 对于 $20\%$ 的数据，$0<N,M\le50$
- 对于另外 $20\%$ 的数据，$\sum_{i=1}^NA_i\le10^6,\sum_{j=1}^MB_j\le10^6$
- 对于$100\%$的数据，$0<N,M\le2000,0<A_i,B_i\le10^9$

## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 3 5 7 9```

### 输出

```
754229067```

## 样例 #2

### 输入

```
10 15
7 8 5 1 2 3 6 5 4 1 
52 10 5 6 3 2 1 4 5 8 7 4 5 6 3```

### 输出

```
181952721```

## 样例 #3

### 输入

```
1 1
5
5```

### 输出

```
0```

## 样例 #4

### 输入

```
5 5
1254125 36521421 25362142 12514221 25362142
857412252 36322411 2236232 1254112 36224125```

### 输出

```
261761853```

## 样例 #5

### 输入

```
2 2
2 4
2 5```

### 输出

```
332748118```

# AI分析结果

• 综合分析与结论：该题目要求计算从两个给定数组中选取连续区间，使得第一个数组选取区间的和大于第二个数组选取区间和的概率。多数题解思路围绕计算所有可能的区间和，再通过排序结合双指针、二分等方法统计满足条件的情况数。各题解在实现细节和优化程度上有所差异，如排序方式、统计答案的具体操作等。

所选的题解：
  - 作者：Hope2075 (5星)
    - 关键亮点：提供双指针和二分两种解法，并对时间复杂度进行分析，还提到将排序改为基数排序可优化时间复杂度，代码实现完整。
    - 个人心得：提到使用基数排序后总用时1749ms，但内存开销比较大，成为最优解第一名。
    - 双指针法核心代码：
```cpp
#include<cstdio>
using namespace std;
const int N=2048;
const long long M=998244353;
int n,m;
long long a[N],b[N];
long long p[N*N/2],q[N*N/2];
int read(){
    int n=0;char c;
    c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9'){
        n=n*10+c-'0';
        c=getchar();
    }
    return n;
}
void sort(long long *beg,long long *end){
    long long* s=new long long[end-beg];
    long long* t=s+(end-beg);
    long long*ss;
    int* cnt=new int[65537];
    for(int p=0;p<4;p++){
        long long r=((1ll<<((p+1)*16))-1);
        for(int i=0;i<=65536;i++)cnt[i]=0;
        cnt++;
        for(long long *i=beg;i<end;i++)cnt[((*i)&r)>>(p*16)]++;
        cnt--;
        for(int i=1;i<65536;i++)cnt[i]+=cnt[i-1];
        for(long long *i=beg;i<end;i++)s[cnt[((*i)&r)>>(p*16)]++]=(*i);
        ss=beg;beg=s;s=ss;
        ss=end;end=t;t=ss;
    }
    delete[] s;
    delete[] cnt;
}
long long cnt;
long long arc(long long a){
    int p=M-2;
    long long ans=1;
    while(p){
        if(p&1)ans=ans*a%M;
        p>>=1;
        a=a*a%M;
    }
    return ans;
}
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++){
        a[i]=read()+a[i-1];
    }
    for(int i=1;i<=m;i++){
        b[i]=read()+b[i-1];
    }
    int t1=0;
    for(int i=0;i<=n;i++){
        for(int j=0;j<i;j++){
            p[t1++]=a[i]-a[j];
        }
    }
    int t2=0;
    for(int i=0;i<=m;i++){
        for(int j=0;j<i;j++){
            q[t2++]=b[i]-b[j];
        }
    }
    sort(p,p+t1);
    sort(q,q+t2);
    int i,j;
    i=0;j=0;
    while(i<t1){
        while(p[i]>q[j]&&j<t2)j++;
        cnt+=j;
        cnt%=M;
        i++;
    }
    printf("%lld\n",cnt);
    cnt=cnt*arc(t1)%M*arc(t2)%M;
    printf("%lld\n",cnt);
}
```
核心实现思想：先通过前缀和求出两人所有可能的区间和并存入数组，再对数组进行基数排序，然后使用双指针法，枚举一个数组，移动另一个数组的指针，统计满足条件的情况数，最后计算概率。
  - 作者：liaoxingrui (4星)
    - 关键亮点：思路清晰，代码简洁，使用结构体存储区间和并标记所属数组，排序后通过遍历统计满足条件的情况数。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+5;
const int mod=998244353;
int x,sum,tot;
long long n,m,ans;
long long sum1[N],sum2[N];
struct node{
    bool flag;
    long long val;
}cnt[N*N<<1];
bool cmp(node x,node y){
    return x.val==y.val?x.flag:x.val<y.val;
}
int Pow(int a,int b){
    long long cnt=a,ans=1;
    while(b){
        if(b&1)
            ans=cnt*ans%mod;
        cnt=cnt*cnt%mod;
        b>>=1;
    }
    return ans;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>x;
        sum1[i]=sum1[i-1]+x;
        for(int j=1;j<=i;j++){
            tot++;
            cnt[tot].flag=true;
            cnt[tot].val=sum1[i]-sum1[j-1];
        }
    }
    for(int i=1;i<=m;i++){
        cin>>x;
        sum2[i]=sum2[i-1]+x;
        for(int j=1;j<=i;j++){
            tot++;
            cnt[tot].val=sum2[i]-sum2[j-1];
        }
    }
    sort(cnt+1,cnt+tot+1,cmp);
    for(int i=1;i<=tot;i++)
        if(cnt[i].flag){
            sum++;
            ans=(ans+i-sum)%mod;
        }
    cout<<ans*Pow(n*(n+1)/2%mod*m*(m+1)/2%mod,mod-2)%mod;
    return 0;
}
```
核心实现思想：利用前缀和求出所有区间和，存入结构体数组并排序，遍历数组，对于属于第一个数组的区间和，统计前面小于它的区间和个数，最后计算概率。
  - 作者：桐间纱路 (4星)
    - 关键亮点：提供暴力、装桶、排序&尺取三种算法思路及对应代码，对每种算法的时间复杂度和预计得分有清晰分析。
    - 排序&尺取核心代码：
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long ll;
const ll mod=998244353;
const ll size=2e3+10;
ll n,m,ans,num,tb,ta,a[size],b[size],sa[size*size/2],sb[size*size/2];
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
ll power(ll x,ll y){
    ll sum=1;
    for(;y;y>>=1){
        if(y&1) sum=sum*x%mod;
        x=x*x%mod;
    }
    return sum;
}
int main(){
    n=read();m=read();
    num=n*(n+1)/2%mod;num=num*m%mod*(m+1)%mod;num=num*power(2,mod-2)%mod;
    for(ll i=1;i<=n;i++) a[i]=read(),a[i]+=a[i-1];
    for(ll i=1;i<=m;i++) b[i]=read(),b[i]+=b[i-1];
    for(ll l=1;l<=m;l++){
        for(ll r=l;r<=m;r++){
            sb[++tb]=b[r]-b[l-1];
        }
    }
    for(ll l=1;l<=n;l++){
        for(ll r=l;r<=n;r++){
            sa[++ta]=a[r]-a[l-1];
        }
    }
    sort(sa+1,sa+1+ta);
    sort(sb+1,sb+1+tb);
    ll l=0;
    for(ll i=1;i<=ta;i++){
        while(sb[l+1]<sa[i]&&l+1<=tb) l++;
        ans=ans+l;if(ans>=mod) ans-=mod;
    }
    printf("%lld\n",ans*power(num,mod-2)%mod);
    return 0;
}
```
核心实现思想：通过前缀和计算所有区间和并存入数组，对数组排序后，利用尺取法枚举一个数组，统计另一个数组中小于当前值的元素个数，从而得到满足条件的情况数，最后计算概率。

最优关键思路或技巧：利用前缀和快速计算所有可能的区间和，通过排序（可优化为基数排序）使数据有序，再结合双指针、尺取或二分查找的方法，高效统计满足条件的区间对数，进而计算出概率。

可拓展之处：同类型题常涉及区间和的计算与比较，类似算法套路包括利用前缀和优化区间和计算，排序后使用双指针、二分等方法处理有序数据。

推荐题目：
  - P1115 最大子段和，考察对连续子区间和的处理。
  - P3146 [USACO16OPEN]248 G，涉及区间合并与最值计算。
  - P1419 寻找段落，同样是关于区间和相关的问题。

个人心得摘录与总结：Hope2075提到使用基数排序优化时间复杂度，但会增加内存开销，在追求速度时需权衡内存使用。 

---
处理用时：49.11秒
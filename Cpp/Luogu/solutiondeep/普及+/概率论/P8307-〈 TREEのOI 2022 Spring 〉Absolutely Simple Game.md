# 题目信息

# 〈 TREEのOI 2022 Spring 〉Absolutely Simple Game

## 题目背景

rin 和 len 在玩一个绝对简单的游戏，pcq 为裁判。

## 题目描述

初始时给定范围 $[l,r]=[1,n]$，pcq 从中均匀随机选出一个自然数 $t$，之后 rin 和 len 两人轮流进行操作，rin 先行。

每次操作方猜测一个整数 $x\in[l,r]$，若 $x=t$，则游戏结束，该方负；若 $x<t$，则调整范围 $[l,r]$ 为 $[x+1,r]$；若 $x>t$，则调整范围 $[l,r]$ 为 $[l,x-1]$。

rin 和 len 两人均充分了解规则且无比可爱聪明（都会最大化自己的胜率），过程中谁都知道场上除了 $t$ 以外的一切信息，求 rin 的胜率。

## 说明/提示

**样例解释1：**  

rin 的胜率为 $\dfrac 23$（一开始猜 $2$），$\bmod~998244353$ 后输出为 $665496236$。

***

**本题采用 SubTask 捆绑测试。**

| SubTask 编号 | 分值 | 特殊限制 |
| :-----------: | :-----------: | :-----------: |
| $0$ | $10$ | $n\equiv 0\ \pmod 2$ |
| $1$ | $20$ | $n\le 100$ |
| $2$ | $30$ | $n\le 10^9$ |
|$3$|$40$|$n\le 10^{18}$|

对于 $100\%$ 的数据，$1 \le n\le 10^{18}$。

---
**如何对有理数取模？**  

$\dfrac {x}{y} \bmod m$ 定义为 $xy^{m-2}\bmod~m$。

$m$ 必须为质数。  

保证答案约分后分母不为 $998244353$ 的倍数。

## 样例 #1

### 输入

```
3```

### 输出

```
665496236```

# AI分析结果

### 综合分析与结论
这几道题解主要围绕求解rin在特定游戏规则下的胜率展开。思路上，多通过先计算较小 \( n \) 值找规律，部分题解还运用归纳法证明。算法要点在于依据规律得出胜率公式，并按题目要求对有理数取模。解决难点主要是发现胜率规律以及处理大数值计算。

### 所选的题解
1. **作者：retep（4星）**
    - **关键亮点**：通过手算小数据找规律，清晰阐述推导过程，代码实现简洁且包含快速乘法与快速幂计算逆元。
    - **个人心得**：先通过观察数据范围猜测是数学题，手算数据发现 \( n \) 为偶数时胜率规律，进而得到完整规律。
    - **核心代码**：
```cpp
ll mult(ll a,ll b){ //快速乘法
    if(!b)return 0;
    if(b==1)return a;
    if(b&1)return (mult(a,b-1)+a)%mod;
    return 2*mult(a,b/2)%mod;
}

ll power(ll a,ll b){ //快速幂
    if(b==1)return a;
    if(!b)return 1;
    if(b&1)return mult(power(a,b-1),a)%mod;
    ll buf=power(a,b/2);
    return mult(buf,buf)%mod;
}

int main(){
    cin>>n;
    ll m=power(n,mod-2); //n的逆元
    if(n%2==0)cout<<499122177<<endl;  //这玩意儿就是0.5取模
    else if(n%4==1)cout<<mult((n-1),499122177)%mod*m%mod<<endl;
    else if(n%4==3)cout<<mult(n+1,499122177)%mod*m%mod<<endl;
    return 0;
}
```
    - **核心思想**：快速乘法函数 `mult` 通过递归与位运算实现类似乘法功能，避免直接乘法爆 `long long`。快速幂函数 `power` 利用快速乘法计算幂次。主函数根据 \( n \) 对 \( 2 \) 和 \( 4 \) 取模结果，结合逆元计算并输出胜率。

2. **作者：TernaryTree（4星）**
    - **关键亮点**：通过打表详细计算前几个 \( n \) 的rin胜率，推导出通用公式，逻辑清晰。
    - **核心代码**：无（题解主要是思路推导）
    - **核心思想**：对 \( n \) 从 \( 1 \) 开始逐个打表，计算不同 \( t \) 值下rin每次选择的胜率，得出 \( a_n \) 公式，进而得到 \( s_n=\frac{a_n}{n} \) 用于有理数取余运算。

3. **作者：ylch（4星）**
    - **关键亮点**：手算小数据找规律，简单易懂，代码使用 `__int128_t` 处理大数值，考虑全面。
    - **核心代码**：
```cpp
ll Pow(ll a, ll b){
	if(b == 1) return a;
	if(b == 0) return 1;
	ll temp = Pow(a, b / 2);
	if(b & 1){
		return temp * temp % mod * a % mod;
	}
	return temp * temp % mod;
}

signed main()
{
	ll n; cin >> n;
	if(n % 2 == 0){
		cout << 1 * Pow(2, mod - 2) % mod;
	}
	else if(n % 4 == 1){
		cout << (n - 1) * Pow(2 * n, mod - 2) % mod;
	}
	else if(n % 4 == 3){
		cout << (n + 1) * Pow(2 * n, mod - 2) % mod;
	}
	return 0;
}
```
    - **核心思想**：`Pow` 函数通过递归与位运算计算幂次。主函数根据 \( n \) 对 \( 2 \) 和 \( 4 \) 取模结果，结合幂次计算并输出胜率。

### 最优关键思路或技巧
通过手算或打表小数据找规律是解决此类数学规律题的重要方法。在处理大数值计算时，采用快速幂、快速乘法以及合适的数据类型（如 `__int128_t`）来避免数据溢出。

### 可拓展之处
此类题目属于博弈论与数学规律结合的题型。类似算法套路是先通过简单情况找规律，再尝试用归纳法等方式证明。同类型题可关注博弈策略、概率计算与数学规律推导结合的题目。

### 相似知识点洛谷题目
1. [P1288 取数游戏II](https://www.luogu.com.cn/problem/P1288)
2. [P2197 模板 - Nim游戏](https://www.luogu.com.cn/problem/P2197)
3. [P1976 鸡蛋的硬度](https://www.luogu.com.cn/problem/P1976) 

---
处理用时：24.22秒
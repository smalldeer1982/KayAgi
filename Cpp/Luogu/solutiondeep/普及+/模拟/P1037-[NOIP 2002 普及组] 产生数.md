# 题目信息

# [NOIP 2002 普及组] 产生数

## 题目描述

给出一个整数 $n$ 和 $k$ 个变换规则。

规则：
- 一位数可变换成另一个一位数。
- 规则的右部不能为零。

例如：$n=234,k=2$。有以下两个规则：

- $2\longrightarrow 5$。  
- $3\longrightarrow 6$。 

上面的整数 $234$ 经过变换后可能产生出的整数为（包括原数）:

- $234$。
- $534$。
- $264$。
- $564$。

共 $4$ 种不同的产生数。

现在给出一个整数 $n$ 和 $k$ 个规则。求出经过任意次的变换（$0$ 次或多次），能产生出多少个不同整数。

仅要求输出个数。

## 说明/提示

对于 $100\%$ 数据，满足 $n \lt 10^{30}$，$k \le 15$。

**【题目来源】**

NOIP 2002 普及组第三题

## 样例 #1

### 输入

```
234 2
2 5
3 6
```

### 输出

```
4
```

# AI分析结果

• 综合分析与结论：
    - 这些题解主要围绕深度优先搜索（DFS）、广度优先搜索（BFS）、弗洛伊德（Floyd）算法以及乘法原理来解决问题。多数题解利用乘法原理，将原数每位数字可变换的情况数相乘得到最终结果。
    - 由于原数较大（$n < 10^{30}$），答案可能超出常规数据类型范围，需用高精度计算或`__int128`处理。部分题解还涉及图论知识，将数字变换关系抽象为图结构，用邻接矩阵或邻接表存储。
    - 思路清晰度、代码可读性、优化程度等方面，不同题解各有差异。有的题解详细阐述算法原理与实现细节，有的代码简洁但解释相对简略。
• 所选的题解：
  - 作者：认真的Ben (赞：146)  星级：5星
    - 关键亮点：详细讲解弗洛伊德算法原理及应用场景，结合本题将数字变换关系构建为有向图，用弗洛伊德算法判断数字间可达性，清晰阐述高精度乘法实现细节，思路和代码注释详细。
    - 个人心得：“Debug写了一个下午，写写题解纪念一下，顺便复习刚学的Floyed。本题解是针对初学Floyed的同学写的”，强调通过本题对弗洛伊德算法的复习与巩固。
    - 重点代码（核心实现思想：用弗洛伊德算法更新数字变换关系，统计每位数字可变换数量，通过高精度乘法计算最终结果）：
```cpp
for(int k=0;k<=9;k++)
{
    for(int i=0;i<=9;i++)
    {
        for(int j=0;j<=9;j++)
        {
            if(dis[i][j] || (dis[i][k]&&dis[k][j])) dis[i][j]=1;
        }
    }
}
for(int i=0;i<=9;i++)
    dis[i][i]=0; 
for(int i=0;i<=9;i++) 
{
    int tmp=1;
    for(int j=0;j<=9;j++)
    {
        if(dis[i][j] && check[i]) tmp++;
    }
    if(s[0]-'0'==i && dis[i][0]) tmp--;
    t[i]=tmp;
}
for(int i=0;i<L;i++) if(t[s[i]-'0']) times(t[s[i]-'0']);
```
  - 作者：communist (赞：55)  星级：4星
    - 关键亮点：利用`map`进行映射，将数字变换关系存储为`map<char, vector<char>>`，通过DFS搜索每位数字可变换的情况，运用乘法原理和高精度计算答案，代码简洁且思路清晰。
    - 重点代码（核心实现思想：通过DFS遍历数字变换关系，统计每种数字出现次数，用高精度乘法计算结果）：
```cpp
void dfs(char th)
{
    c[th-'0']=1;
    int sz=mp[th].size();
    for(int i=0;i<sz;i++)
        if(!c[mp[th][i]-'0'])
            dfs(mp[th][i]);
}
signed main()
{
    cin>>st>>k;
    l=st.length();
    for(int i=1;i<=k;i++)
    {
        char x,y;
        cin>>x>>y;
        mp[x].push_back(y);
    }
    mul[0]=1;
    for(int i=0;i<l;i++)
    {
        memset(c,0,sizeof(c));
        dfs(st[i]);
        int sum=0;
        for(int i=0;i<=9;i++)
            sum+=c[i];
        int x=0;
        for(int i=0;i<100;i++)
        {
            mul[i]=mul[i]*sum+x;
            x=mul[i]/10;
            mul[i]%=10;
        }
    }
    int i=99;
    while(i>0&&!mul[i])
        i--;
    for(;i>=0;i--)
        cout<<mul[i];
    cout<<endl;
    return 0;
}
```
  - 作者：yangrunze (赞：39)  星级：4星
    - 关键亮点：先尝试纯暴力搜索发现不足，后引入乘法原理和图论知识，使用链式前向星存储图结构，结合DFS和高精度乘法解决问题，代码注释详细，对算法知识点有较好的讲解。
    - 重点代码（核心实现思想：用链式前向星存储图，DFS遍历计算每位数字可变换数量，通过高精度乘法得出答案）：
```cpp
void add(int a,int b)
{
    tot++;
    e[tot].v=b;
    e[tot].next=head[a];
    head[a]=tot;
}
bool vis[10];
void dfs(int x)
{
    if(vis[x])return;
    vis[x]=1;
    ans++;
    for(int i=head[x];i;i=e[i].next)
    {
        dfs(e[i].v);    
    }
}
void gjcf(int x)
{
    int jw=0;
    for(int i=1;i<=30;i++)
    {
        qwq[i]=qwq[i]*x+jw;
        jw=qwq[i]/10;
        qwq[i]%=10;
    }
}
int main()
{
    string s;
    cin>>s>>n;
    for(int i=1;i<=n;i++)
    {
        int x,y;
        cin>>x>>y;
        add(x,y);
    }
    qwq[1]=1;
    for(int i=0;i<s.size();i++)
    {
        ans=0;
        for(int j=0;j<10;j++)
        vis[j]=0;
        dfs(s[i]-'0');
        gjcf(ans);
    }
    int pos=30;
    while(!qwq[pos]&&pos>1)pos--;
    for(int i=pos;i>0;i--)cout<<qwq[i];
    return 0;
} 
```
• 最优关键思路或技巧：
    - **运用乘法原理**：将问题分解为计算原数每位数字的可变换情况数，再相乘得到总情况数，大大简化问题。
    - **图论思想**：把数字变换关系抽象为图，用邻接矩阵、邻接表（如`vector`实现、链式前向星）或`map`存储，方便利用图的遍历算法解决问题。
    - **算法选择**：根据数据规模和问题特点选择合适算法，如本题用弗洛伊德算法可处理数字间复杂变换关系，DFS用于搜索可达数字。
    - **高精度计算**：因答案数值大，采用高精度乘法，通过数组模拟竖式乘法实现。
• 可拓展之处：
    - 同类型题常涉及数字变换、组合计数，结合图论、搜索算法与高精度计算。类似算法套路是先分析数字间关系构建图结构，再用搜索算法遍历图求各节点可达情况，最后用乘法原理或其他计数方法得出结果。
• 推荐题目：
    - [P1303 计算系数](https://www.luogu.com.cn/problem/P1303)：涉及高精度乘法与二项式定理，与本题高精度计算和计数思路类似。
    - [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：用递推结合高精度算法解决路径计数问题，可锻炼计数与高精度处理能力。
    - [P1149 火柴棒等式](https://www.luogu.com.cn/problem/P1149)：通过枚举和计数解决等式组合问题，与本题计数思路有相通处，可拓展思维。 

---
处理用时：60.67秒
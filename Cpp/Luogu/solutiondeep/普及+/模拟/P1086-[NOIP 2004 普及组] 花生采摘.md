# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均是按照题目要求，从花生数量最多的植株开始依次采摘，并通过计算曼哈顿距离来判断在限定时间内是否能够完成采摘并返回路边。主要差异在于数据存储结构和排序方式的选择。

1. **算法要点**：
    - **数据存储**：有的使用结构体数组存储花生植株的坐标和花生数量（如jiangXxin、MC_long_live、yedalong、qhr2023、buickboy）；有的使用map和priority queue（_Arahc_）；还有用Java内部类和TreeMap（Forgetter）。
    - **排序**：多数通过自定义比较函数对结构体数组进行排序（jiangXxin、MC_long_live、yedalong、qhr2023、buickboy）；_Arahc_利用priority queue实现自动排序；Forgetter通过TreeMap结合数组实现从大到小排序。
2. **解决难点**：
    - **时间判断**：准确计算从当前位置到下一个花生植株的时间，包括移动和采摘时间，并判断剩余时间是否足够返回路边。
    - **边界情况**：考虑初始位置、第一株花生采摘的特殊情况，以及最后一株花生采摘后无需判断前往下一株的情况，避免数组越界等问题。

### 所选题解
- **作者：jiangXxin（5星）**
    - **关键亮点**：思路清晰，代码注释详细。使用结构体数组存储花生信息，通过自定义比较函数排序，利用曼哈顿距离计算移动时间，逻辑简洁明了。
    - **个人心得**：原本想用BFS，发现花生地无障碍物后改用曼哈顿距离算法，体现了根据题目条件灵活调整算法的能力。
    - **重点代码**：
```cpp
struct dire//记忆花生地址 
{
    int x,y,sum;
}stu[N*N];
bool comp(struct dire a,struct dire b)//比较，大的在前，小的在后 
{
    return a.sum>b.sum;
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>mp[i][j];
            if(mp[i][j]>0)
            {
                stu[++pn].sum=mp[i][j];
                stu[pn].x=i;
                stu[pn].y=j;
            }
        }
    }
    sort(stu+1,stu+pn+1,comp);
    fx=1;
    fy=stu[1].y;
    k--;
    for(int i=1;i<=pn;i++)
    {
        tm=0;
        ex=stu[i].x;
        ey=stu[i].y;
        tm=abs(fx-ex)+abs(fy-ey);
        k--;
        k-=tm;
        if(k>=ex)
        {
            ans+=mp[ex][ey];
            fx=ex;
            fy=ey;
        }
        else
        {
            cout<<ans<<endl;
            return 0;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
核心实现思想：先将所有花生植株信息存入结构体数组并按花生数量从大到小排序，初始化起点，每次循环计算到下一个植株的曼哈顿距离及采摘时间，判断剩余时间能否返回路边，若能则更新答案和起点，否则结束循环输出答案。

- **作者：_Arahc_（4星）**
    - **关键亮点**：利用map和priority queue简化了数据存储和排序过程，代码简洁高效，展现了对STL容器的熟练运用。
    - **个人心得**：总结了题目中的多个坑点，如采摘耗时、不能抄近道、数组大小、特殊数据点等，对理解题意和避免错误有很大帮助。
    - **重点代码**：
```cpp
int n,m,k,a[23][23];
map<int,pair<int,int> >c;
priority_queue<int> q;
n=read(),m=read(),k=read();
for(register int i=1;i<=n;++i) for(register int j=1;j<=m;++j){
    a[i][j]=read();
    c[a[i][j]]=make_pair(i,j);
    q.push(a[i][j]);
}
int j=q.top();q.pop();
int x=c[j].first;
int y=c[j].second;
int w=x+1;
while(w+x<=k){
    s+=j;
    if(q.empty()) break;
    j=q.top();q.pop();
    w+=abs(c[j].first-x)+abs(c[j].second-y)+1;
    x=c[j].first,y=c[j].second;
}
```
核心实现思想：输入时将花生数量与坐标通过map绑定，并将花生数量存入priority queue。取出堆顶元素作为当前采摘的花生，判断能否采摘，若能则更新已用时间、采摘数量和当前位置，继续循环判断下一个花生。

- **作者：buickboy（4星）**
    - **关键亮点**：提出“降维大法”，用结构体实现二维数组的降维排序，简化了数据处理过程，同时对各种边界情况（如一株也采不了、采最后一株等）处理得当。
    - **重点代码**：
```cpp
struct pea{
    int a,b,s;
}p[600];
bool cmp(pea x,pea y){
    return x.s>y.s;
}
int main()
{
    int m,n,k,i,j,r=0,t,ans=0;
    scanf("%d%d%d",&m,&n,&k);
    for(i=1;i<=m;++i)
    for(j=1;j<=n;++j)
    {
        ++r;
        scanf("%d",&p[r].s);
        p[r].a=i,p[r].b=j;
    }
    sort(p+1,p+1+r,cmp);
    if(k>=1+2*p[1].a)
        k-=p[1].a+1,ans+=p[1].s;
    else {printf("0");return 0;}
    for(i=1;i<r;++i)
    {
        t=abs(p[i].a-p[i+1].a)+abs(p[i].b-p[i+1].b);
        if(k>=t+1+p[i+1].a)
            k-=t+1,ans+=p[i+1].s;
        else break;
    }
    printf("%d",ans);
    return 0;
}
```
核心实现思想：用结构体数组存储花生信息并排序，先特判第一次采摘是否可行，然后在循环中计算与下一个植株的距离，判断能否去、采、回路边，能则更新答案和剩余时间，否则退出循环输出答案。

### 最优关键思路或技巧
1. **数据结构选择**：根据题目需求合理选择数据结构，如结构体数组方便存储和排序，map结合priority queue可简化操作并实现自动排序，提高代码效率和简洁性。
2. **边界情况处理**：充分考虑各种边界情况，如初始位置、第一次采摘、最后一株采摘等，避免因边界问题导致错误。

### 拓展思路
同类型题目通常围绕在给定限制条件下的资源获取或路径规划问题，可使用类似的模拟和贪心策略解决。例如在一个方格地图中，角色按特定规则移动并收集物品，同时要满足时间、体力等限制条件。

### 相似知识点洛谷题目
1. [P1094 [NOIP2007 普及组] 纪念品分组](https://www.luogu.com.cn/problem/P1094)：涉及贪心策略，与本题按花生数量从大到小采摘的思路类似，需根据给定条件对数据进行合理分组。
2. [P1199 [NOIP2010 普及组] 三国游戏](https://www.luogu.com.cn/problem/P1199)：同样需要根据题目规则进行模拟和策略选择，在双方博弈的情境下寻找最优解。
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：运用贪心算法，按照接水时间从小到大排序，计算总等待时间，与本题按某种属性排序并计算相关值的思路相近。

### 个人心得摘录与总结
1. **jiangXxin**：做题过程中根据题目条件（花生地无障碍物）及时调整算法（从BFS改为曼哈顿距离算法），体现了灵活应变的能力。
2. **_Arahc_**：详细总结了题目中的坑点，包括算法要求、采摘耗时、抄近道规则、特殊数据点、数组大小等，对全面理解题意和避免错误十分关键。 

---
处理用时：60.67秒
# 题目信息

# 小木棍

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。

现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。

给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。


## 说明/提示

对于全部测试点，$1 \leq n \leq 65$，$1 \leq a_i \leq 50$。

## 样例 #1

### 输入

```
9
5 2 1 5 2 1 5 2 1
```

### 输出

```
6```

# AI分析结果

这是一道搜索剪枝类型的题目，解题关键在于通过各种剪枝策略优化搜索过程，找到原始木棍的最小可能长度。

### 综合分析与结论
1. **思路**：大多题解先明确原始木棍长度范围（最长小木棍长度到所有小木棍长度之和），再通过枚举该范围内能整除所有小木棍长度总和的长度值，利用深度优先搜索（DFS）判断能否用给定小木棍拼出该长度的原始木棍，第一个满足条件的值即为答案。
2. **算法要点**：
    - **排序**：对小木棍按长度从大到小排序，方便后续剪枝。
    - **剪枝**：包括过滤长度大于50的木棍、只枚举能整除总长度的原始木棍长度、避免重复搜索相同长度木棍、利用vis数组标记已用木棍、从大到小选择木棍拼接等。
    - **DFS**：设计合适的DFS函数，通过参数记录当前拼接状态，如正在拼第几根原始木棍、当前木棍剩余长度等。
3. **解决难点**：主要难点在于各种剪枝策略的运用。如当前长棍剩余未拼长度等于当前木棍长度或原始长度时，继续拼失败则回溯；用next数组记录相同长度木棍位置以跳过重复搜索等。

### 所选的题解
1. **作者：Kaori (赞：1363) - 5星**
    - **关键亮点**：思路阐述极为详细，对每个优化点都有清晰解释，代码注释详尽，涵盖多种有效剪枝策略，如二分查找符合条件的木棍、预处理next数组等。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：通过dfs函数递归搜索，利用used数组标记木棍使用情况，在dfs中结合多种剪枝条件判断是否继续搜索，找到符合条件的原始木棍长度则更新全局变量ok并返回。
```cpp
bool used[66],ok; 
bool cmp(int a,int b){return a>b;}
void dfs(int k,int last,int rest){ 
    int i;
    if(!rest){ 
        if(k==m){ok=1; return;} 
        for(i=1;i<=cnt;i++) 
            if(!used[i]) break;
        used[i]=1; 
        dfs(k+1,i,len-a[i]);
        used[i]=0;
        if(ok) return; 
    }
    int l=last+1, r=cnt, mid;
    while(l<r){
        mid=(l+r)>>1;
        if(a[mid]<=rest) r=mid;
        else l=mid+1;
    }
    for(i=l;i<=cnt;i++){
        if(!used[i]){ 
            used[i]=1;
            dfs(k,i,rest-a[i]);
            used[i]=0;
            if(ok) return; 
            if(rest==a[i] || rest==len) return; 
            i=next[i]; 
            if(i==cnt) return;
        }
    }
}
```
2. **作者：林则徐 (赞：402) - 4星**
    - **关键亮点**：代码简洁明了，采用桶存储木棍长度，在dfs中运用多种剪枝策略，如根据已拼接长度和当前枚举长度判断是否继续枚举。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：dfs函数根据剩余未拼木棍数、当前已拼长度、目标长度和当前可选择的最大木棍长度进行递归搜索，通过tm数组记录每种长度木棍数量，结合剪枝条件判断是否继续搜索。
```cpp
void dfs( int res, int sum, int target, int p ) {
    if( res == 0 ) {
        printf("%d", target  );
        exit( 0 );
    }
    if( sum == target ) {
        dfs( res - 1, 0, target, maxn );
        return;
    }
    for( int i = p ; i >= minn ; i -- ) { 
        if( tm[ i ] && i + sum <= target ) {
            tm[ i ] -- ;
            dfs( res, sum + i, target, i );
            tm[ i ] ++ ;
            if ( sum == 0 || sum + i == target ) 
                break;
        }
    }
    return;
}
```
3. **作者：NoyException (赞：351) - 4星**
    - **关键亮点**：对剪枝的讲解细致，从基础剪枝到普通剪枝再到进阶剪枝逐步深入，易于理解，代码实现对应各个剪枝点。
    - **个人心得**：作者表示花了半天才完成题目，见到AC很激动，强调剪枝的重要性。
    - **重点代码 - 核心实现思想**：通过perm函数进行深度优先搜索，利用vis数组标记木棍使用情况，在搜索过程中结合各种剪枝条件，如判断剩余长度、避免重复搜索相同长度木棍等，判断是否能成功拼接。
```cpp
bool perm(int pre,int fromp)
{
    int i;
    if(pre%len==0)
    {
        if(sum-pre==len) return true;
        for(i=2;i<=end && vis[i];i++) ;
        vis[i]=true;
        if(perm(pre+line[i],2)) return true;
        vis[i]=false;
    }
    else for(;fromp<=end;fromp++)
    {
       	if(!vis[fromp])
       	{
       		if(pre%len+line[fromp]<=len)
       		{
       			vis[fromp]=true;
   				if(perm(pre+line[fromp],fromp)) return true;
				vis[fromp]=false;
				if(pre%len+line[fromp]==len) return false; 
			}
			fromp=nxt[line[fromp]];
		}
	}
    return false;
}
```

### 最优的关键思路或技巧
1. **排序与剪枝**：对小木棍按长度从大到小排序，不仅能使搜索更高效，还为多种剪枝策略提供基础，如避免重复搜索相同长度木棍、优先选择长木棍拼接等。
2. **预处理**：通过预处理记录木棍相关信息，如next数组记录相同长度木棍的最后一根位置，减少搜索时的重复操作。
3. **可行性剪枝**：当前长棍剩余未拼长度等于当前木棍长度或原始长度时，若继续拼失败则回溯，避免无效搜索。

### 同类型题或类似算法套路
同类型题通常为搜索剪枝类题目，常见套路是明确搜索范围，通过排序、记录状态、避免重复等剪枝策略优化搜索过程。例如在一些拼图、组合问题中，可通过类似方法减少搜索空间。

### 推荐题目
1. **P1433 吃奶酪**：搜索算法题，需合理剪枝优化搜索路径，与本题优化搜索过程思路相似。
2. **P1731 营救**：同样是搜索题，可运用剪枝策略优化搜索过程，确定最优救援方案。
3. **P2324 骑士精神**：深度优先搜索结合剪枝，通过合理优化找到最小步数，与本题搜索剪枝思路相符。 

---
处理用时：65.98秒
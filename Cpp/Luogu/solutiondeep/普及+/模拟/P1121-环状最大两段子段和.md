# 题目信息

# 环状最大两段子段和

## 题目描述

给出一段长度为 $n$ 的环状序列 $a$，即认为 $a_1$ 和 $a_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
9```

# AI分析结果

• 综合分析与结论：这些题解主要围绕环状最大两段子段和问题展开，核心思路是分类讨论。一类情况是两段都不跨越端点，可通过预处理从前往后和从后往前的最大子段和，枚举分界点来求解；另一类是有一段跨越端点，可转化为求最小两段子段和，用总和减去它得到结果。算法要点在于熟练运用动态规划、前缀和等方法。难点在于全面考虑各种情况，避免遗漏，如处理最小两段子段和时可能出现的特殊情况。

所选的题解：
  - 作者：Develop (5星)
    - 关键亮点：全面且系统地阐述了最大子段和及其多种变式的解法，包括本题的详细思路，对各种情况的分析透彻，涵盖多种复杂度的解法，具有很强的学习价值。
  - 作者：zhy137036 (4星)
    - 关键亮点：先从最大子段和、环状最大子段和、最大双子段和逐步引入到环状最大双子段和，思路清晰，代码简洁明了，对每种情况的代码实现都有详细展示。
  - 作者：Lates (4星)
    - 关键亮点：简洁清晰地分析两种情况，不跨环时通过维护前后最大子段和枚举断点求解，跨环时转化为求最小子序列两段子段和，代码实现简洁高效。

Develop题解重点代码：无核心代码，主要是思路阐述。

zhy137036题解重点代码：
```cpp
// 求最大子段和
f[1]=a[1];
for(int i=2;i<=n;i++)f[i]=max(f[i-1],0)+a[i];
g[1]=f[1];
for(int i=2;i<=n;i++)g[i]=max(g[i-1],f[i]);
// 求环状最大子段和
int getmax(int*arr,int l,int(*cmp)(int,int)){
    f[1]=arr[1];
    for(int i=2;i<=l;i++)f[i]=cmp(f[i-1],0)+arr[i];
    g[1]=f[1];
    for(int i=2;i<=l;i++)g[i]=cmp(g[i-1],f[i]);
    return g[l];
}
// 求环状最大双子段和
af[1]=a[1];
for(int i=2;i<=n;i++)af[i]=max(af[i-1],0)+a[i];
for(int i=2;i<=n;i++)af[i]=max(af[i-1],af[i]);
ab[n]=a[n];
for(int i=n-1;i>0;i--)ab[i]=max(ab[i+1],0)+a[i];
for(int i=n-1;i>0;i--)ab[i]=max(ab[i+1],ab[i]);
int ans=1ll<<31ll;
for(int i=1;i<n;i++)ans=max(ans,af[i]+ab[i+1]);
ans=max(ans,sum-getmin(a,n-1));
ans=max(ans,sum-getmin(a+1,n-1));
```
核心实现思想：通过动态规划分别求出最大子段和、环状最大子段和，在求环状最大双子段和时，分情况讨论，不跨环时通过预处理前后最大子段和枚举断点，跨环时通过求最小子段和来计算。

Lates题解重点代码：
```cpp
// 不跨环情况
ans=-INF;
f[0]=h[0]=-INF;
for(register int i=1;i<=n;++i)h[i]=max(h[i-1]+a[i],a[i]),f[i]=max(f[i-1],h[i]);
g[n+1]=h[n+1]=-INF;
for(register int i=n;i;--i)h[i]=max(h[i+1]+a[i],a[i]),g[i]=max(g[i+1],h[i]);
for(register int i=1;i<=n;++i)ans=max(ans,f[i]+g[i+1]);
// 跨环情况
res=INF;
f[0]=h[0]=INF;
for(register int i=1;i<=n;++i)h[i]=min(h[i-1]+a[i],a[i]),f[i]=min(f[i-1],h[i]);
g[n+1]=h[n+1]=INF;
for(register int i=n;i;--i)h[i]=min(h[i+1]+a[i],a[i]),g[i]=min(g[i+1],h[i]);
for(register int i=1;i<=n;++i)res=min(res,f[i]+g[i+1]);
printf("%d\n",max(ans,sum-res));
```
核心实现思想：不跨环时，正向和反向分别动态规划求出最大子段和，枚举断点求最大和；跨环时，同样正向和反向动态规划求出最小子段和，用总和减去最小和得到结果。

最优关键思路或技巧：分类讨论思想，将环状最大两段子段和问题分为两段都不跨越端点和有一段跨越端点两种情况分别处理；动态规划方法，通过状态转移方程高效求解最大子段和与最小子段和。

可拓展之处：此类问题可拓展到求环状多段子段和，或者对序列有其他限制条件的情况，同样可通过分类讨论和动态规划等方法解决。

推荐题目：
  - P1115 最大子段和
  - P2642 最大双子段和
  - P4513 小白逛公园

个人心得：
  - 作者I_AM_HelloWord提到需特判只有一个正数的情况，否则将数字取负求最小子段和时会出现只选一个序列的错误。这表明在处理特殊数据时要全面考虑，不能遗漏边界情况。 

---
处理用时：50.66秒
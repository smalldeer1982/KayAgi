# 题目信息

# 取数游戏

## 题目描述

一个 $N\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。

## 说明/提示

### 样例解释

对于第一组数据，取数方式如下：

$$\begin{matrix}
[67] & 75 & 63 & 10 \\
29 & 29 & [92] & 14 \\
[21] & 68 & 71 & 56 \\
8 & 67 & [91] & 25 \\
\end{matrix}$$


### 数据范围及约定

- 对于$20\%$的数据，$1\le N, M \le 3$；
- 对于$40\%$的数据，$1\le N, M\le 4$；
- 对于$60\%$的数据，$1\le N, M\le 5$；
- 对于$100\%$的数据，$1\le N, M\le 6$，$1\le T\le 20$。


## 样例 #1

### 输入

```
3
4 4
67 75 63 10
29 29 92 14
21 68 71 56
8 67 91 25
2 3
87 70 85
10 3 17
3 3
1 1 1
1 99 1
1 1 1

```

### 输出

```
271
172
99
```

# AI分析结果

### 综合分析与结论
这些题解主要采用深度优先搜索（DFS）和状态压缩动态规划（状压DP）两种算法。DFS思路直观，遍历每个点的取与不取状态，难点在于处理取数后对相邻点的影响及回溯。状压DP利用二进制表示每行取数状态，通过预处理合法状态优化，难点在于状态设计和转移方程推导。

多数DFS题解思路和代码较清晰，但部分未充分优化；状压DP题解虽复杂度理论较高，但因数据范围小也能有效解决，不过代码理解难度稍大。

### 所选的题解
- **作者：绿萧 (赞：200) - 5星**
    - **关键亮点**：思路清晰，先排除贪心和普通DP，点明因数据范围小适合DFS。详细阐述每个数的状态表示及代码实现细节，注释丰富。
    - **个人心得**：无
    - **核心代码**：
```cpp
void dfs(int x,int y){//搜索函数，表示搜索点(x,y) 
    if(y==m+1){//当y到边界时，搜索下一行 
        dfs(x+1,1);
        return;
    }
    if(x==n+1){//当x到边界时，搜索结束，刷新最大值 
        mx=max(ans,mx);
        return;
    }
    
    dfs(x,y+1);// 不取此数的情况 
    
    if(mark[x][y]==0){ //取此数的情况（需保证此数周围没有取其他数，即mark[i][j]==0）
        ans+=s[x][y];
        for(int fx=0;fx<8;++fx){ //标记周围的数 
            ++mark[x+d[fx][0]][y+d[fx][1]];
        }
        dfs(x,y+1);
        for(int fx=0;fx<8;++fx){ //回溯 
            --mark[x+d[fx][0]][y+d[fx][1]];
        }
        ans-=s[x][y];
    }
    
}
```
    - **核心思想**：通过`dfs`函数递归搜索每个点，`mark`数组记录周围点状态，决定当前点是否可取，取数后标记周围点并回溯。
- **作者：zhi_zhang (赞：37) - 4星**
    - **关键亮点**：详细展示DFS剪枝过程，从普通DFS开始，逐步分析剪枝点及优化方式，对理解剪枝技巧有帮助。
    - **个人心得**：通过每次剪枝观察AC点数变化，直观体现剪枝效果。
    - **核心代码**：
```cpp
void Dfs(int X,int x,int y)
{
    bool poi_rem=false;
    for(int i=y+1;i<=M;i++)//先搜完当前行
    {
        if(!vis[x][i])
        {
            poi_rem=true;
            Vis(x,i);
            Dfs(X+sq[x][i],x,i);
            D_vis(x,i);
        }
    }
    for(int i=x+1;i<=N;i++)
    {
        for(int j=1;j<=M;j++)
        {
            if(!vis[i][j])
            {
                poi_rem=true;
                Vis(i,j);
                Dfs(X+sq[i][j],i,j);
                D_vis(i,j);
            }
        }
    }
    if(!poi_rem&&ans<X)
    {
        ans=X;
    }
}
```
    - **核心思想**：在`Dfs`函数中，通过剪枝减少搜索范围，`vis`数组标记已访问点，避免重复搜索和非法取数。
- **作者：IntrepidStrayer (赞：23) - 4星**
    - **关键亮点**：清晰阐述状压DP思路，包括状态设计、预处理合法状态、状态转移方程推导及时间复杂度分析。
    - **个人心得**：无
    - **核心代码**：
```cpp
bool check1(int x){
    for(;x;x>>=1)if((x&3)==3)return false;
    return true;
}
bool check2(int x,int y){
    return!(x&(y<<1))&&!(x&y)&&!(x&(y>>1));
}
int calc(int i,int x){
    int res=0;
    for(rei j=m;j>=1&&x;--j,x>>=1)if(x&1)res+=a[i][j];
    return res;
}
//...
for(rei i=1;i<=n;++i)
    for(rei j=1;j<=cnt;++j){
        v=0;
        for(rei k=1;k<=cnt;++k)
            if(check2(c[j],c[k]))
                v=max(v,f[i-1][k]);
        f[i][j]=calc(i,c[j])+v;
    }
```
    - **核心思想**：`check1`函数预处理每行合法状态，`check2`函数判断相邻两行状态是否合法，`calc`函数计算当前行取数和，通过状态转移方程更新`f`数组得到最大值。

### 最优关键思路或技巧
- **DFS方面**：利用方向数组标记取数后周围点状态，搜索时判断该点是否可取，同时通过剪枝优化，如限制搜索范围在当前行及以下、减少不必要的标记操作等。
- **状压DP方面**：用二进制表示每行取数状态，预处理合法状态减少重复判断，通过状态转移方程计算不同状态下的最大值。

### 可拓展之处
同类型题常涉及在有约束条件下的最值求解，类似算法套路有：
 - **对于小数据范围**：可考虑暴力搜索，如DFS、BFS，注意状态记录和回溯。
 - **对于满足无后效性问题**：尝试动态规划，复杂约束条件下可采用状态压缩技巧。

### 相似知识点洛谷题目
 - [P1896 互不侵犯](https://www.luogu.com.cn/problem/P1896)：与本题类似，在棋盘放置棋子，有相邻限制，可用状压DP解决。
 - [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)：涉及状态压缩思想，求遍历所有点的最短路径。
 - [P2704 [NOI2001] 炮兵阵地](https://www.luogu.com.cn/problem/P2704)：在地图布置炮兵，有放置位置限制，适合状压DP。

### 个人心得摘录与总结
 - **zhi_zhang**：通过逐步剪枝并观察AC点数变化，直观感受剪枝对算法效率的提升，强调剪枝在优化DFS算法中的重要性。 

---
处理用时：53.74秒
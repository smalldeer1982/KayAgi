# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解利用图的遍历算法来求解从顶点1到其他各点的最短路数量。由于是无向无权图，BFS、SPFA和Dijkstra算法都可用于求最短路，在此基础上统计最短路数量。具体做法是在遍历过程中，若找到更短路径则更新距离和路径数量；若找到相同长度路径，则累加路径数量。
    - 算法要点：需正确初始化距离数组和路径计数数组，ans[1]初始化为1；采用合适的数据结构存储图，如邻接表；在遍历算法中，根据不同情况更新距离和路径计数。
    - 解决难点：处理重边和自环，多数题解表明自环可忽略，重边按正常无向边处理；部分题解提到在不同算法下准确统计最短路数量，如SPFA在一般带权图中统计最短路数量时可能出现重复计数问题。
    - 整体来看，各题解思路相似，主要区别在于采用的算法（BFS、SPFA、Dijkstra）以及代码实现的细节，如输入输出优化、数据结构定义等。

所选的题解：
  - 作者：ZiDing_ByronFinlso (星级：4星)
    - 关键亮点：提供了SPFA和Dijkstra堆优化两种解法，思路清晰，代码规范且有详细注释，对输入输出进行了快读优化。
    - 个人心得：无
    - 重点代码（SPFA）：
```cpp
inline int read()
{
    char ch=getchar(); 
    int x=0,f=1;
    while((ch>'9'||ch<'0')&&ch!='-')
        ch=getchar();
    if(ch=='-')
    {
        f=-1;
        ch=getchar();
    }
    while('0'<=ch&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
int mod=100003;
int n,m,x,y,tot=0;
const int N=1000005,M=4000005;
int head[N],to[M],nxt[M],d[N],ans[N];
bool p[N];
queue< int > q;
void add(int x,int y)
{
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;i++)
    {
        x=read();y=read();
        add(x,y);
        add(y,x);
    }
    for(int i=1;i<=n;i++)
    {
        d[i]=1e9;p[i]=0;
    }
    d[1]=0;
    p[1]=1;
    ans[1]=1;
    q.push(1);
    while(q.size())
    {
        x=q.front();q.pop();
        p[x]=0;
        for(int i=head[x];i;i=nxt[i])
        {
            y=to[i];
            if(d[y]>d[x]+1)
            {
                d[y]=d[x]+1;
                ans[y]=ans[x];
                if(!p[y])
                {
                    q.push(y);
                    p[y]=1;
                }
            }
            else if(d[y]==d[x]+1)
            {
                ans[y]+=ans[x];
                ans[y]%=mod;
            }
        }
    }
    for(int i=1;i<=n;i++)
        printf("%d\n",ans[i]);
    return 0;   
} 
```
核心实现思想：通过SPFA算法遍历图，在更新距离时同步更新最短路数量。若找到更短路径，更新距离并将该点的最短路数量设为前驱点的数量；若找到相同长度路径，累加前驱点的最短路数量。
    - 重点代码（Dijkstra堆优化）：
```cpp
inline int read()
{
    char ch=getchar(); 
    int x=0,f=1;
    while((ch>'9'||ch<'0')&&ch!='-')
        ch=getchar();
    if(ch=='-')
    {
        f=-1;
        ch=getchar();
    }
    while('0'<=ch&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
int mod=100003;
int n,m,x,y,tot=0;
const int N=1000005,M=4000005;
int head[N],to[M],nxt[M],d[N],ans[N];
bool p[N];
priority_queue< pair< int,int > > q;
void add(int x,int y)
{
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;i++)
    {
        x=read();y=read();
        add(x,y);
        add(y,x);
    }
    for(int i=1;i<=n;i++)
    {
        d[i]=1e9;p[i]=0;
    }
    d[1]=0;ans[1]=1;
    q.push(make_pair(0,1));
    while(q.size())
    {
        x=q.top().second;
        q.pop();
        if(p[x])    continue;
        p[x]=1;
        for(int i=head[x];i;i=nxt[i])
        {
            y=to[i];
            if(d[y]>d[x]+1)
            {
                d[y]=d[x]+1;
                ans[y]=ans[x];
                q.push(make_pair(-d[y],y));
            }
            else if(d[y]==d[x]+1)
            {
                ans[y]+=ans[x];
                ans[y]%=mod;
            }
        }
    }
    for(int i=1;i<=n;i++)
        printf("%d\n",ans[i]);
    return 0;
}
```
核心实现思想：利用Dijkstra堆优化算法，每次从优先队列中取出距离最小的点进行扩展。在扩展过程中，类似SPFA的处理方式更新距离和最短路数量。
  - 作者：岸芷汀兰 (星级：4星)
    - 关键亮点：明确指出本题用BFS的原因，对自环和重边的处理进行了详细分析，代码结构清晰，有输入输出的读写优化。
    - 个人心得：无
    - 重点代码：
```cpp
inline int read(void) {
    int x = 0, f = 1; char ch = getchar();
    while (ch<'0' || ch>'9') {
        if (ch == '-')f = -1;
        ch = getchar();
    }
    while (ch >= '0'&&ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return f * x;
}

inline void write(int x) {
    int y = 10, len = 1;
    while (y <= x) {
        y *= 10; len++;
    }
    while (len--) {
        y /= 10; putchar(x / y + 48); x %= y;
    }
}

const int maxn = 1000005, mod = 100003;
int n, m, ans[maxn], d[maxn];
bool vis[maxn];

vector<int>linker[maxn];

struct Node {
    int node, dis;
};

inline Node make(int first, int second) {
    Node ans; ans.node = first; ans.dis = second;
    return ans;
}

inline void connect(int x, int y) {
    linker[x].push_back(y);
}

inline void bfs(void) {
#define cur linker[u][i]

    queue<Node>q; q.push(make(1, 0));
    memset(d, 0x3f, sizeof(d)); d[1] = 0;
    vis[1] = true;
    ans[1] = 1;
    while (q.size()) {
        int u = q.front().node, dis = q.front().dis; 
        q.pop();
        for (register int i = 0; i<int(linker[u].size()); i++) {
            if (!vis[cur]) {
                q.push(make(cur, dis + 1)); vis[cur] = true; d[cur] = dis + 1; 
                ans[cur] += ans[u]; /*重点*/ans[cur] %= mod;
            }
            else {
                if (dis + 1 == d[cur]) { ans[cur] += ans[u]; /*重点*/ans[cur] %= mod; }
            }
        }
    }
}

int main()
{
    n = read(); m = read();
    for (register int i = 1; i <= m; i++) {
        int x = read(), y = read();
        if (x == y)continue;//删除自环
        connect(x, y); connect(y, x);
    }
    bfs();
    for (register int i = 1; i <= n; i++) {
        write(ans[i] % mod); putchar('\n');
    }
    return 0;
}
```
核心实现思想：使用BFS遍历图，对于每个访问到的节点，若该节点首次被访问，则更新距离和最短路数量，并将其加入队列；若已被访问且当前距离等于之前记录的距离，则累加最短路数量。
  - 作者：King丨帝御威 (星级：4星)
    - 关键亮点：采用堆优化的Dijkstra算法，代码注释详细，对算法思路和实现细节进行了清晰解释，适合初学者理解。
    - 个人心得：无
    - 重点代码：
```cpp
inline int qread()                      //依然是快读。。。 
{
    char c=getchar();int num=0,f=1;
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) num=num*10+c-'0';
    return num*f;
}
int n,m,dis[maxn],head[maxn],s,js[maxn],num;     //dis数组表示起点到某点的最短路大小，js表示起点到某点的最短路条数。 
struct Edge
{
    int v,w,nxt;
}edge[maxn1];
inline void ct(int u,int v,int w)           //链式前向星存图。 
{
    edge[++num].v=v;
    edge[num].w=w;
    edge[num].nxt=head[u];
    head[u]=num;
}
struct node
{
    int x,y;
    bool operator < (const node &a) const            //堆优化重载运算符，使大根堆变成小根堆。 
    {
        return y>a.y;
    }
};
void dijkstra()
{
    memset(dis,0x3f,sizeof(dis));                //初始化。 
    dis[1]=0;
    priority_queue<node>q;
    js[1]=1;                            //起点到自己的最短路条数一定是1。 
    q.push((node){1,0});
    node a;
    while(!q.empty())                             //dijkstra经典套路操作。 
    {
        a=q.top();                              //用这个node类型变量提取队首元素。 
        int u=a.x,d=a.y;                       
        q.pop();
        if(d!=dis[u]) continue;                   //一个小优化。 
        for(int i=head[u];i;i=edge[i].nxt)
        {
            int v=edge[i].v;
            if(d+edge[i].w==dis[v])
              js[v]=(js[u]+js[v])%mod;             //一边计算一边模。 
            if((dis[v]>dis[u]+edge[i].w))
            {
                dis[v]=dis[u]+edge[i].w;
                js[v]=js[u];                      //找到一条更短的路径是，用它的前驱的js换它。 
                q.push((node){v,dis[v]});
            }
        }
    }
}
int main()
{
    n=qread(),m=qread();
    for(int i=1,u,v;i<=m;++i)
    {
        u=qread(),v=qread();
        ct(u,v,1);                           //无向边存两遍。 
        ct(v,u,1);
    }
    dijkstra();
    for(int i=1;i<=n;++i)
        cout<<js[i]<<'\n';                   //依次输出就好了。 
    cout<<'\n';
    return 0;
}
```
核心实现思想：在堆优化的Dijkstra算法过程中，每次取出堆顶元素进行扩展。若找到更短路径，更新距离和最短路数量；若找到相同长度路径，累加最短路数量，并在计算过程中进行取模操作。

• 最优的关键思路或技巧：
    - **数据结构**：采用邻接表存储图结构，在大规模数据下能有效减少内存占用，提高遍历效率。
    - **算法优化**：对于Dijkstra算法使用堆优化，降低时间复杂度；部分题解对输入输出进行快读优化，提升程序运行速度。
    - **思维方式**：在图的遍历过程中，同步维护距离和最短路数量，通过比较距离的不同情况（更短、相同）来正确更新最短路数量。

• 可拓展之处：
    - 同类型题：可拓展到带权图的最短路计数问题，但需注意在SPFA等算法中避免重复计数问题，如[P1608 路径统计](https://www.luogu.org/problemnew/show/P1608)。
    - 类似算法套路：对于无权图的最短路相关问题，BFS是一种高效稳定的算法；对于有权图，Dijkstra和SPFA是常用算法。在统计最短路数量时，基本思路都是在最短路算法的基础上，根据距离更新情况同步更新路径数量。

• 推荐题目：
    - [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.org/problemnew/show/P3371)：经典的单源最短路问题，可练习Dijkstra和SPFA算法。
    - [P4779 【模板】单源最短路径（标准版）](https://www.luogu.org/problemnew/show/P4779)：同样是单源最短路模板题，但数据规模更大，更考验算法优化。
    - [P1608 路径统计](https://www.luogu.org/problemnew/show/P1608)：带权图的最短路计数问题，能进一步加深对最短路计数的理解和处理能力。

• 个人心得摘录与总结：
    - **XZYQvQ**：发现很多人在SPFA过程中统计答案在本题能AC，但在其他类似题目中不行，通过先跑SPFA得到最短路长度，再跑记忆化搜索遍历最短路图得到答案，可AC另一道vjudge上的题目。总结：不同题目对算法细节要求不同，通用的做法可能需要进一步优化以适应多变的题目条件。
    - **KesdiaelKen**：指出在一般带权图中用SPFA统计最短路条数可能出现重复计数问题，并通过具体例子和代码调整进行说明。总结：在使用算法时要深入理解其适用场景，对于特殊情况（如带权图的最短路计数）需谨慎处理，防止出现逻辑错误。 

---
处理用时：106.49秒
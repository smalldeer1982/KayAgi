# 题目信息

# [ZJOI2007] 棋盘制作

## 题目描述

国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 $8 \times 8$ 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。

而我们的主人公 `小Q`，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友 `小W` 决定将棋盘扩大以适应他们的新规则。

`小Q` 找到了一张由 $N \times M$ 个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。`小Q` 想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。

不过 `小Q` 还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。

于是 `小Q` 找到了即将参加全国信息学竞赛的你，你能帮助他么？


## 说明/提示

对于 $20\%$ 的数据，$N, M ≤ 80$

对于 $40\%$ 的数据，$N, M ≤ 400$

对于 $100\%$ 的数据，$N, M ≤ 2000$


## 样例 #1

### 输入

```
3 3
1 0 1
0 1 0
1 0 0
```

### 输出

```
4
6
```

# AI分析结果

这些题解主要围绕如何在给定的黑白相间棋盘（01棋盘）中找出最大的正方形和矩形展开，大部分题解采用悬线法，部分使用动态规划、单调栈等方法。

1. **思路与算法要点**
    - **悬线法**：通过维护三个数组`left[i][j]`（从`(i,j)`能到达的最左位置）、`right[i][j]`（从`(i,j)`能到达的最右位置）、`up[i][j]`（从`(i,j)`向上扩展最长长度），利用动态规划递推求解。先预处理`left`和`right`数组，再结合`up`数组更新答案。例如：
```cpp
for(RI i=1;i<=n;i++)
    for(RI j=2;j<=m;j++)
        if(res[i][j]!=res[i][j-1])
            left[i][j]=left[i][j-1];//预处理左边界
for(RI i=1;i<=n;i++)
    for(RI j=m-1;j>0;j--)
        if(res[i][j]!=res[i][j+1])
            right[i][j]=right[i][j+1];//预处理右边界
for(RI i=1;i<=n;i++)
    for(RI j=1;j<=m;j++)
    {
        if(i>1&&res[i][j]!=res[i-1][j])
        {
            left[i][j]=max(left[i][j],left[i-1][j]);
            right[i][j]=min(right[i][j],right[i-1][j]);
            up[i][j]=up[i-1][j]+1;
        }
        int a=right[i][j]-left[i][j]+1;
        int b=min(a,up[i][j]);
        ans1=max(ans1,b*b);//正方形
        ans2=max(ans2,a*up[i][j]);//长方形
    }
```
    - **动态规划**：定义状态`dp[i][j]`表示以`(i,j)`为右下角的最大棋盘的长度和宽度，通过对`(i,j)`与周围点颜色关系进行分类讨论，更新`dp`数组并得出答案。如：
```cpp
if(g[i][j]==g[i-1][j]){
    if(g[i][j]==g[i][j-1])
        dp[i][j]=(point){1,1};
    else dp[i][j]=(point)
        {1,dp[i][j-1].y+1};
} else {
    if(g[i][j]==g[i][j-1])
        dp[i][j]=(point)
        {dp[i-1][j].x+1,1};
    else if(dp[i][j-1].x<dp[i-1][j].x+1
    &&dp[i-1][j].y<dp[i][j-1].y+1){
        point tmp1,tmp2;
        tmp1=(point)
        {dp[i-1][j].x+1,dp[i-1][j].y};
        tmp2=(point)
        {dp[i][j-1].x,dp[i][j-1].y+1};
        if(tmp1.siz()>tmp2.siz())
            dp[i][j]=tmp1;
        else dp[i][j]=tmp2;
    } else {
        dp[i][j]=(point){dp[i-1]
        [j].x+1,dp[i][j-1].y+1};
    }
}
```
    - **单调栈**：先预处理出每个点能向上延伸的高度，然后对每一行利用单调栈求出以该行元素为底的最大矩形面积。对于正方形，在计算过程中进行判断更新。例如：
```cpp
for(j=0; j<m; j++){
    cin>>a[i][j];
    if(!i || a[i][j]^a[i-1][j])t1[j]=t[j]=h[j]=h[j]+1;
    else t1[j]=t[j]=h[j]=1;
}
t[m]=-1;top=0;
for(j=0; j<=m; j++){
    int tmp=j;flg=0;
    if(j &&!(a[i][j]^a[i][j-1]))flg=1;
    while(top && ((t[sta[top]]>t[j]) || flg))
        ans=max(ans,(j-(tmp=sta[top]))*t[sta[top]]),top--;
    t[sta[++top]=(flg?j:tmp)]=t[j];
}
```
2. **解决难点**
    - **状态定义与转移**：如何合理定义状态（如悬线法中的三个数组、动态规划中的`dp`数组），并根据题目条件准确写出状态转移方程是关键。
    - **单调性维护**：在单调栈方法中，维护栈的单调性以及正确处理元素入栈、出栈操作，从而准确计算最大矩形（正方形）面积。
3. **题解评分**
    - **顾z**：5星。思路清晰，对悬线法的用途、做法、定义及递推公式解释详细，代码简洁且注释丰富，还对可能的疑问进行解答，并给出相关悬线法题目。
    - **Felis**：4星。对悬线法的讲解详细，从悬线定义、性质到具体步骤逐步展开，代码实现清晰，且指出代码注意事项。
    - **lzoi_lhy**：4星。提出用单调栈解决问题的思路，代码实现简洁明了，通过维护`h`数组结合单调栈扫描，同时处理正方形和矩形的求解。

4. **最优关键思路或技巧**
悬线法是较为通用和高效的方法，通过维护特定数组记录每个点的扩展信息，利用动态规划思想递推，有效降低时间复杂度。同时，部分题解通过坐标奇偶性取反，将黑白相间问题转化为求最大同色矩阵问题，简化思考过程。

5. **拓展**
同类型题可考虑一些求满足特定条件的最大子矩阵问题，类似算法套路包括悬线法、单调栈优化等。例如在处理一些具有连续性、单调性条件限制的子矩阵求解问题中可应用。

6. **相似知识点题目**
    - **P4147 玉蟾宫**：同样是求最大子矩阵问题，可使用悬线法解决。
    - **P2701 巨大的牛棚**：与本题类似，涉及求满足条件的最大正方形和矩形。
    - **P1387 最大正方形**：专注于求满足条件的最大正方形，可通过动态规划或悬线法求解。

7. **个人心得摘录**
    - **George1123**：调了半个上午，循序渐进想出较难的动态规划思路，通过大分类中小分类的递归思想帮助解题。总结出遇到难题可逐步分析，从简单情况入手找到规律。 

---
处理用时：64.14秒
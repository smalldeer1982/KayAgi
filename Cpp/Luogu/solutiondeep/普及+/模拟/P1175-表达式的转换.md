# 题目信息

# 表达式的转换

## 题目描述

平常我们书写的表达式称为中缀表达式，因为它将运算符放在两个操作数中间，许多情况下为了确定运算顺序，括号是不可少的，而后缀表达式就不必用括号了。

后缀标记法：书写表达式时采用运算紧跟在两个操作数之后，从而实现了无括号处理和优先级处理，使计算机的处理规则简化为：从左到右顺序完成计算，并用结果取而代之。

例如：`8-(3+2*6)/5+4` 可以写为：`8 3 2 6 * + 5 / - 4 +`

其计算步骤为：

```
8 3 2 6 * + 5 / - 4 +
8 3 12 + 5 / - 4 +
8 15 5 / - 4 +
8 3 - 4 +
5 4 +
9
```

编写一个程序，完成这个转换，要求输出的每一个数据间都留一个空格。

## 说明/提示

运算的结果可能为负数，`/` 以整除运算。并且中间每一步都不会超过 $2^{31}$。字符串长度不超过 $100$。

注意乘方运算 `^` 是从右向左结合的，即 `2 ^ 2 ^ 3` 为 `2 ^ (2 ^ 3)`，后缀表达式为 `2 2 3 ^ ^`。

其他同优先级的运算是从左向右结合的，即 `4 / 2 / 2 * 2` 为 `((4 / 2) / 2) * 2`，后缀表达式为 `4 2 / 2 / 2 *`。

保证不会出现计算乘方时幂次为负数的情况，故保证一切中间结果为整数。

## 样例 #1

### 输入

```
8-(3+2*6)/5+4
```

### 输出

```
8 3 2 6 * + 5 / - 4 + 
8 3 12 + 5 / - 4 + 
8 15 5 / - 4 + 
8 3 - 4 + 
5 4 + 
9
```

## 样例 #2

### 输入

```
2^2^3
```

### 输出

```
2 2 3 ^ ^
2 8 ^
256
```

# AI分析结果

这组题解均围绕将中缀表达式转换为后缀表达式并计算这一问题。整体思路类似，均先处理中缀转后缀，再计算后缀表达式，但在具体实现上各有不同。

### 思路与要点
1. **sunyizhe**：定义函数判断运算符优先级，使用两个栈，一个存后缀表达式，一个存符号。遍历中缀表达式，数字直接入栈，运算符按优先级处理，括号特殊处理，乘方运算符遇栈顶为乘方也入栈。计算后缀表达式时，定义计算函数，用两个栈，一个存计算过程，一个临时存放数据。
2. **xuhanxi_dada117**：通过建树解决问题。找根节点时，有加减找最后一个加减，有乘除找最后一个乘除，否则找第一个幂，注意括号内为整体且要处理形如$(xxxxx)$的式子。建好树后，从根节点开始计算，后序遍历输出。
3. **ShenTianYi_**：写函数计算运算符优先级，用两个栈分别存符号和结果。遍历字符数组，按数字、乘方、普通运算符、括号的不同情况处理。计算后缀表达式时，用结构体将数字和字符存于同一数组，按顺序处理。
4. **rui_er**：定义优先级函数，遍历原字符串，按数字、括号、运算符的规则处理，用结构体和向量容器存储后缀表达式。计算后缀表达式时，按顺序读取，数字入栈，运算符弹出两数运算后压回。
5. **icaijy**：用双向队列代替栈存储，定义符号对照表，按数字、括号、运算符规则将中缀转后缀。计算后缀表达式时，循环处理，遇运算符弹出两数运算，更新栈并输出。
6. **NeosKnight**：中转后，数字直接输出，算符按规则入栈出栈并输出。计算时，预先计算算符个数，从前往后扫，遇算符找前两数运算，处理负数。
7. **technopolis_2085**：采用分治思想将中缀转后缀，每次找优先级最低的运算，分成两半递归处理。计算时，用两个字符串交替模拟，找第一个运算符及前两数运算，结果放回字符串。

### 难点解决
1. **运算符优先级与结合性**：多数题解通过定义优先级函数处理，乘方从右向左结合单独处理。如sunyizhe题解中，乘方运算符遇栈顶为乘方也入栈；technopolis_2085题解找运算符时对乘方特殊判断。
2. **括号处理**：左括号直接入栈，右括号弹出栈顶到左括号。如sunyizhe、ShenTianYi_等题解均是如此处理。
3. **后缀表达式计算**：用栈存储数字，遇运算符弹出计算。如rui_er题解按顺序读取后缀表达式处理。

### 题解评分
1. **sunyizhe**：思路清晰，代码完整且注释详细，对过程模拟细致。★★★★☆
2. **xuhanxi_dada117**：采用建树方法较新颖，但代码注释可更详细，思路理解有一定难度。★★★☆☆
3. **ShenTianYi_**：思路和代码都较基础，适合初学者理解，表述清晰。★★★★☆
4. **rui_er**：思路常规，代码简洁，对异常处理有考虑。★★★★☆
5. **icaijy**：代码长，用双向队列代替栈有一定特点，但整体实现较繁琐。★★★☆☆
6. **NeosKnight**：代码长且复杂，实现方式较繁琐。★★★☆☆
7. **technopolis_2085**：分治思想有特色，但代码复杂，计算部分易错。★★★☆☆

### 高星题解
1. **sunyizhe**
    - **星级**：★★★★☆
    - **关键亮点**：思路清晰，详细模拟转换和计算过程，对特殊情况（如乘方、括号）处理说明详细，代码注释丰富。
    - **核心代码**：
```cpp
int check(char c) {
    switch(c) {
        case '+':return 1;
        case '-':return 1;
        case '*':return 2;
        case '/':return 2;
        case '^':return 3;
        case '(':return 0;
        case ')':return 0;
        default:return -1;
    }
}
int js(int x,int y,char t) {
    switch(t) {
        case '+':return x+y;
        case '-':return x-y;
        case '*':return x*y;
        case '/':return x/y;
        case '^':return pow(x,y);
        default:return -0x3f3f3f3f;
    }
}
void change(string s) {
    int len=s.size();
    for(int i=0;i<len;i++) {
        if(isdigit(s[i]))dat.push(s[i]);
        else if(s[i]=='(')op.push(s[i]);
        else if(s[i]==')') {
            char t=op.top();
            while(t!='(') {
                op.pop();
                dat.push(t);
                t=op.top();
            }
            op.pop();
        }
        else if(check(s[i])>=1&&check(s[i])<=3) {
            if(!op.empty()) {
                char t=op.top();
                while(!op.empty()&&check(s[i])<=check(t)) {
                    if(check(s[i])==check(t)&&s[i]=='^')break;
                    op.pop();
                    dat.push(t);
                    if(!op.empty())t=op.top();
                }
            }
            op.push(s[i]);
        }
    }
    while(!op.empty()) {
        char t=op.top();
        op.pop();
        dat.push(t);
    }
    while(!dat.empty()) {
        char t=dat.top();
        dat.pop();
        op.push(t);
    }
    while(!op.empty()) {
        char t=op.top();
        cout<<t<<' ';
        op.pop();
        dat.push(t);
    }
    cout<<endl;
}
void calc() {
    while(!dat.empty()) {
        char t=dat.top();
        dat.pop();
        op.push(t);
    }
    while(!op.empty()) {
        char t=op.top();
        op.pop();
        if(isdigit(t))num.push(t-'0');
        else {
            int x=num.top();
            num.pop();
            int y=num.top();
            num.pop();
            num.push(js(y,x,t));
            while(!num.empty()) {
                int t=num.top();
                num.pop();
                dat2.push(t); 
            }
            while(!dat2.empty()) {
                int t=dat2.top();
                cout<<t<<' ';
                dat2.pop();
                num.push(t);
            }
            while(!op.empty()) {
                char t=op.top();
                cout<<t<<' ';
                op.pop();
                dat.push(t);
            }
            while(!dat.empty()) {
                char t=dat.top();
                dat.pop();
                op.push(t);
            }
            cout<<endl;
        }
    }
}
```
    - **核心思想**：`check`函数确定运算符优先级，`change`函数遍历中缀表达式，按规则将字符存入对应栈，完成中缀到后缀转换并输出。`calc`函数从后缀表达式栈中取字符，数字入栈，运算符取栈顶两数计算，输出计算过程。
2. **ShenTianYi_**
    - **星级**：★★★★☆
    - **关键亮点**：思路简单直接，代码基础且详细，对每个步骤解释清晰，适合初学者理解后缀表达式转换与计算原理。
    - **核心代码**：
```cpp
int pr(char x) {
    if(x=='^') {
        return 3;
    }
    else if(x=='*' || x=='/') {
        return 2;
    }
    else if(x=='+' || x=='-') {
        return 1;
    }
    else {
        return 0;
    }
}
// 省略栈操作函数
void print() {
    for(int i=1;i<=lenf;i++) {
        cout<<f[i]<<" ";
    }
    cout<<endl;
}
void print2(int ii) {
    for(int i=1;i<=lencalc;i++) {
        if(calc[i].is_digit) {
            cout<<calc[i].dg<<" ";
        }
        else {
            cout<<calc[i].ch<<" ";
        }
    }
    for(int i=ii;i<=lenc;i++) {
        if(c[i].is_digit) {
            cout<<c[i].dg<<" ";
        }
        else {
            cout<<c[i].ch<<" ";
        }
    }
    cout<<endl;
}
int main() {
    init.ch=0;
    init.dg=0;
    init.is_digit=0;
    cin>>s+1;
    n=strlen(s+1);
    for(int i=1;i<=n;i++) {
        if(s[i]>='0' && s[i]<='9') {
            pushf(s[i]);
        }
        else if(s[i]=='^' || s[i]=='(') {
            pushs(s[i]);
        }
        else if(s[i]=='+' || s[i]=='-' || s[i]=='*' || s[i]=='/') {
            int t=pr(s[i]);
            for(int j=lens;j>=1;j--) {
                if(pr(stack[j])<t) {
                    break;
                }
                else {
                    pushf(pops());
                }
            }
            pushs(s[i]);
        }
        else if(s[i]==')') {
            for(int j=lens;j>=1;j--) {
                if(stack[j]=='(') {
                    pops();
                    break;
                }
                else {
                    pushf(pops());
                }
            }
        }
    }
    while(lens) {
        pushf(pops());
    }
    for(int i=1;i<=lenf;i++) {
        char x=f[i];
        Node m;
        if(x=='+' || x=='-' || x=='*' || x=='/' || x=='^') {
            m.is_digit=0;
            m.ch=x;
            m.dg=0;
        }
        else {
            m.is_digit=1;
            m.ch=0;
            m.dg=x-48;
        }
        pushc(m);
    }
    print();
    for(int i=1;i<=lenc;i++) {
        Node m=c[i];
        if(m.is_digit) {
            pushcalc(m);
        }
        else {
            int x1,x2;
            Node r;
            r.is_digit=1;
            r.ch=0;
            x1=popcalc().dg;
            x2=popcalc().dg;
            switch(m.ch) {
                case '+':
                    r.dg=x2+x1;
                    break;
                case '-':
                    r.dg=x2-x1;
                    break;
                case '*':
                    r.dg=x2*x1;
                    break;
                case '/':
                    r.dg=x2/x1;
                    break;
                case '^':
                    r.dg=1;
                    for(int j=0;j<x1;j++) {
                        r.dg*=x2;
                    }
            }
            pushcalc(r);
            print2(i+1);
        }
    }
    return 0;
}
```
    - **核心思想**：`pr`函数确定运算符优先级。主函数中，遍历中缀表达式，按字符类型进行不同栈操作，完成中缀转后缀。之后将后缀表达式转为结构体数组，遍历该数组，数字入计算栈，运算符取栈顶两数计算并输出计算过程。
3. **rui_er**
    - **星级**：★★★★☆
    - **关键亮点**：代码简洁，逻辑清晰，对中缀转后缀和后缀计算步骤明确，异常处理有体现。
    - **核心代码**：
```cpp
int priority(char c) {
    if(c == '^') return 3;
    if(c == '*' || c == '/') return 2;
    if(c == '+' || c == '-') return 1;
    if(c == '(' || c == ')') return 0;
    throw "WA! Unexpected operator";
}
struct Node {
    int type;
    union {
        int x;
        char op;
    }data;
    Node() {}
    Node(int x) : type(1) {data.x = x;}
    Node(char c) : type(0) {data.op = c;}
};
void toSuffix() {
    rep(i, 0, n-1) {
        if(isdigit(c[i])) v.push_back(Node(int(c[i]^'0')));
        else {
            if(c[i] == '(') op.push(c[i]);
            else if(c[i] == ')') {
                while(op.top()!= '(') {
                    v.push_back(Node(char(op.top())));
                    op.pop();
                }
                op.pop();
            }
            else if(c[i] == '^') op.push(c[i]);
            else {
                while(!op.empty() && priority(op.top()) >= priority(c[i])) {
                    v.push_back(Node(char(op.top())));
                    op.pop();
                }
                op.push(c[i]);
            }
        }
    }
    while(!op.empty()) {
        v.push_back(Node(char(op.top())));
        op.pop();
    }
}
void prtall() {
    int sz = v.size();
    rep(i, 0, sz-1) {
        if(v[i].type) printf("%d%c", v[i].data.x, " \n"[i==sz-1]);
        else printf("%c%c", v[i].data.op, " \n"[i==sz-1]);
    }
}
void prtsec(int u) {
    int sz = v.size();
    while(!s.empty()) {t.push(s.top()); s.pop();}
    while(!t.empty()) {printf("%d ", t.top()); s.push(t.top()); t.pop();}
    rep(i, u, sz-1) {
        if(v[i].type) printf("%d ", v[i].data.x);
        else printf("%c ", v[i].data.op);
    }
    puts("");
}
void calc() {
    prtall();
    int sz = v.size();
    rep(i, 0, sz-1) {
        if(v[i].type) s.push(v[i].data.x);
        else {
            int a, b; char _;
            b = s.top(); s.pop();
            a = s.top(); s.pop();
            _ = v[i].data.op;
            if(_ == '+') s.push(a+b);
            else if(_ == '-') s.push(a-b);
            else if(_ == '*') s.push(a*b);
            else if(_ == '/') s.push(a/b);
            else s.push(qpow(a, b));
            prtsec(i+1);
        }
    }
}
```
    - **核心思想**：`priority`函数确定运算符优先级。`toSuffix`函数遍历中缀表达式，按字符类型处理，将后缀表达式存入向量容器。`calc`函数遍历后缀表达式，数字入栈，运算符取栈顶两数运算并输出计算过程。

### 最优思路技巧
1. **栈的运用**：多数题解利用栈存储数字和运算符，方便按顺序处理表达式，如处理运算符优先级和括号时，栈顶元素可直接对比和操作。
2. **优先级函数**：定义函数确定运算符优先级，简化比较过程，使代码逻辑清晰，如sunyizhe、ShenTianYi_、rui_er题解中的优先级函数。

### 拓展
1. **同类型题或算法套路**：此类题目核心是表达式处理，常见套路是利用栈处理运算符优先级和结合性。可拓展到前缀表达式处理，思路类似，只是扫描顺序和处理细节不同。
2. **推荐题目**：
    - [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)：计算后缀表达式的值，与本题后缀表达式计算部分相似。
    - [P3399 丝绸之路](https://www.luogu.com.cn/problem/P3399)：涉及表达式计算和模拟，可锻炼表达式处理能力。
    - [P2032 扫描](https://www.luogu.com.cn/problem/P2032)：通过中缀表达式转后缀表达式解决，考查相关转换和计算。

### 个人心得摘录
1. **rui_er**：做题

---
处理用时：129.20秒
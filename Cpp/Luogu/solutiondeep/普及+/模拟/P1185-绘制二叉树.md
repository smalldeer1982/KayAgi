# 题目信息

# 绘制二叉树

## 题目描述

二叉树是一种基本的数据结构，它要么为空，要么由根结点，左子树和右子树组成，同时左子树和右子树也分别是二叉树。

当一颗二叉树高度为 $m-1$ 时，共有 $m$ 层。若一棵二叉树除第 $m$ 层外，其他各层的结点数都达到最大，且叶子结点都在第 $m$ 层时，则其为一棵满二叉树。

现在，需要你用程序来绘制一棵二叉树，它由一棵满二叉树去掉若干结点而成。对于一棵满二叉树，我们需要按照以下要求绘制：

1. 结点用小写字母 `o` 表示，对于一个父亲结点，用 `/` 连接左子树，用 `\` 连接右子树。

2. 定义 $[i,j]$ 为位于第 $i$ 行第 $j$ 列的某个字符。若 $[i,j]$ 为 `/` ，那么 $[i-1,j+1]$ 与 $[i+1,j-1]$ 要么为 `o` ，要么为 `/`。若 $[i,j]$ 为 `\` ，那么 $[i-1,j-1]$ 与 $[i+1,j+1]$ 要么为 `o`，要么为 `\` 。同样，若 $[i,j]$ 为第 $1\sim m-1$ 层的某个结点 `o` ，那么 $[i+1,j-1]$ 为 `/`，$[i+1,j+1]$ 为 `\`。

3. 对于第 $m$ 层结点也就是叶子结点点，若两个属于同一个父亲，那么它们之间由 $3$ 个空格隔开；若两个结点相邻但不属于同一个父亲，那么它们之间由 $1$ 个空格隔开。第 $m$ 层左数第 $1$ 个结点之前没有空格。

最后需要在一棵绘制好的满二叉树上删除 $n$ 个结点（包括这个结点的左右子树，以及与父亲的连接），原有的字符用空格替换（空格为 `ASCII 32`，若输出 `ASCII 0` 会被算作错误答案）。

## 说明/提示

$30\%$ 的数据满足：$n=0$；

$50\%$ 的数据满足：$2\le m\le 5$；

$100\%$ 的数据满足：$2\le m\le10,0\le n\le 10,1<i\le M,j\le 2^{i-1}$。

## 样例 #1

### 输入

```
2 0
```

### 输出

```
  o  
 / \ 
o   o
```

## 样例 #2

### 输入

```
4 0```

### 输出

```
           o           
          / \          
         /   \         
        /     \        
       /       \       
      /         \      
     o           o     
    / \         / \    
   /   \       /   \   
  o     o     o     o  
 / \   / \   / \   / \ 
o   o o   o o   o o   o```

## 样例 #3

### 输入

```
4 3
3 2
4 1
3 4
```

### 输出

```
           o           
          / \          
         /   \         
        /     \        
       /       \       
      /         \      
     o           o     
    /           /      
   /           /       
  o           o        
   \         / \       
    o       o   o      ```

# AI分析结果

### 综合分析与结论
这些题解主要围绕绘制并删除节点的满二叉树问题，思路上多采用找规律的方式确定二叉树各部分位置及关系。算法要点包括确定画布大小、节点和树枝规律、递归绘制与删除节点。解决难点在于找出树枝长度、节点位置分布规律以及正确处理节点删除操作。

从质量上看，ailanxier的题解思路清晰，详细分析规律并给出注释丰富的代码，代码可读性高；巨型方块的题解虽代码简短，但规律推导过程阐述稍欠清晰；AzusagawaKaede的题解采用递归画图，思路较明确，但代码注释相对较少。整体而言，ailanxier的题解质量较高。

### 所选的题解
- **ailanxier（5星）**
    - **关键亮点**：通过打表分析出树枝长度和同层节点分布规律，代码注释详细，对数组定义、各函数功能及可能遇到的坑都有清晰说明。
    - **个人心得**：提到数组大小要开大，避免因数组过小出现运行错误；使用清晰变量名便于理解；还指出在本题中用`cin`比快读更合适，避免TLE。
    - **核心代码**：
```cpp
//预处理
void prepare(){
    int sum = 1;            //记录树枝长的前缀和
    len[1] = 1;pos[1] = 1;  //第一层树枝长为1，第一个节点水平位置为1
    FOR(i,2,m) {
        len[i] = sum + i-1; //递推式子
        sum += len[i];
        pos[i] = len[i] + 1;//顺便得到第i层第一个节点的水平位置
    }
    h[m] = 1;
    for(int i = m-1; i ;i --) h[i] = h[i+1]+len[i]+1;//得到第i层的竖直位置
    memset(a,' ',sizeof(a)); //全都铺满空格
}

//绘制
void draw(int x,int y,int depth){
    a[x][y] = 'o'; //画节点
    if(depth == 1) return;  //到叶子节点了，返回
    //开始画树枝，lx,ly定位左树枝，rx,ry定位右树枝
    int lx = x+1,ly = y-1,rx = x+1,ry = y+1;
    FOR(i,1,len[depth-1]){ //注意画的树枝长度为下一层的树枝长度
        a[lx][ly] = '/';
        a[rx][ry] = '\\';
        lx = lx+1,ly = ly-1,rx = rx+1,ry = ry+1;
    }
    draw(lx,ly,depth-1);   //画下一层节点
    draw(rx,ry,depth-1);
}

//删点
void destroy(int x,int y){
    a[x][y] = ' ';           //将该点置为空格
    if(a[x-1][y-1] == '\\') destroy(x-1,y-1);         //左上角
    if(a[x-1][y+1] == '/') destroy(x-1,y+1);          //右上角
    if(a[x+1][y-1] == '/' || a[x+1][y-1] == 'o') destroy(x+1,y-1); //左下角，因为往下还要删除孩子节点，要多一个判断
    if(a[x+1][y+1] == '\\'|| a[x+1][y+1] == 'o') destroy(x+1,y+1); //右下角同理
}
```
    - **核心实现思想**：`prepare`函数通过递推计算树枝长度`len`数组、节点水平位置`pos`数组和竖直位置`h`数组，并初始化画布为空格。`draw`函数采用前序遍历递归绘制二叉树，根据`len`数组确定树枝长度。`destroy`函数递归删除节点及其子树和与父节点的连接。

### 最优关键思路或技巧
通过打表找规律确定二叉树的树枝长度和节点位置分布，利用数组记录相关信息，采用递归方式进行二叉树的绘制与节点删除，这种思维方式和代码实现技巧能有效解决此类问题。同时，在处理输入输出时，根据数据范围合理选择输入方式，避免因不当优化导致TLE。

### 可拓展之处
同类型题可涉及不同形状图形的绘制及修改，类似算法套路是先找图形规律，确定各部分位置关系，用合适数据结构存储，再通过递归或迭代进行绘制和修改操作。

### 相似知识点洛谷题目
- **P1498 南蛮图腾**：通过递归绘制具有特定规律的图形，与本题找规律绘图思路相似。
- **P1058 立体图**：同样是图形绘制问题，需处理三维图形的投影和绘制，考察空间想象和规律寻找能力。
- **P2190 小Z的队伍排列**：涉及到根据特定规则对序列进行操作，与本题根据规则处理二叉树节点有相似之处。 

---
处理用时：37.07秒
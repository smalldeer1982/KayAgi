# 题目信息

# 单词背诵

## 题目描述

灵梦有 $n$ 个单词想要背，但她想通过一篇文章中的一段来记住这些单词。

文章由 $m$ 个单词构成，她想在文章中找出连续的一段，其中包含最多的她想要背的单词（重复的只算一个）。并且在背诵的单词量尽量多的情况下，还要使选出的文章段落尽量短，这样她就可以用尽量短的时间学习尽可能多的单词了。

## 说明/提示

### 数据规模与约定

- 对于 $30\%$ 的数据，$n \le 50$，$m \le 500$；
- 对于 $60\%$ 的数据，$n \le 300$，$m \le 5000$；
- 对于 $100\%$ 的数据，$n \le 1000$，$m \le 10^5$。

## 样例 #1

### 输入

```
3

hot

dog

milk

5

hot

dog

dog

milk

hot

```

### 输出

```
3

3

```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何在给定文章段落中找出包含最多要背单词且长度最短的子段落。常见思路有哈希结合尺取法、二分查找等。多数题解先通过哈希或map标记要背单词，再用不同方法遍历文章段落。
1. **思路**：
    - **哈希+尺取法**：用哈希或map记录要背单词，通过尺取法移动左右端点，动态更新包含要背单词的子段落及长度。
    - **二分查找**：二分区间长度，在固定长度区间内统计要背单词数量判断是否满足条件。
2. **算法要点**：
    - **哈希**：将字符串转为数字，便于快速判断单词是否为要背单词。
    - **尺取法**：维护左右端点，根据条件移动端点，更新最优解。
    - **二分查找**：利用答案单调性，缩小搜索范围。
3. **解决难点**：
    - **高效查找**：通过哈希、map等减少字符串比较时间。
    - **最优子段落求解**：尺取法通过动态调整区间，二分查找通过固定区间统计判断，都有效解决该问题。

### 所选的题解
1. **作者：louhao088（5星）**
    - **关键亮点**：思路清晰，使用map + string实现哈希，代码简洁易懂，时间复杂度$O(m \log m)$较优。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>sum;
map<string,bool>flag;
int ans1,ans2,n,m,l;
string s[100005],s1; 
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>s1,flag[s1]=1;
    cin>>m;l=1;
    for(int i=1;i<=m;i++)
    {
        cin>>s[i];
        if(flag[s[i]])sum[s[i]]++;
        if(sum[s[i]]==1)ans1++,ans2=i - l + 1;
        while(l<=i)
        {
            if(!flag[s[l]]){l++;continue;}
            if(sum[s[l]]>=2){sum[s[l]]--,l++;continue;}
            break;
        }
        ans2=min(ans2,i - l + 1);
    }
    cout<<ans1<<endl<<ans2<<endl;
    return 0;
}
```
    - **核心思想**：用flag标记要背单词，遍历文章单词，若为要背单词且首次出现则更新单词数和长度，通过while循环调整左端点，保证区间最短。
2. **作者：早右昕（4星）**
    - **关键亮点**：明确指出是尺取法模板题，详细描述尺取法过程，代码实现简洁，有特判。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int P = 10000019;
int str_hash(char* a) {
    int ln = strlen(a);
    long long res = 0;
    for(int i = 0; i < ln; i++) {
        res *= 31, res += a[i] - 'a';
        res %= P;
    }
    return res % P;
}
int n, m, p1, p2 = 1 << 30;
int a[1001], b[100010];
int vis[P];
bool need[P];
int main() {
    char in[101];
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) {
        scanf("%s", in);
        a[i] = str_hash(in);
        need[a[i]] = 1;
    }
    scanf("%d", &m);
    for(int i = 1; i <= m; i++) {
        scanf("%s", in);
        b[i] = str_hash(in);
        if(need[b[i]] &&!vis[b[i]]) {
            p1++, vis[b[i]] = 1;  
        }
    }
    if(p1 == 0) {
        printf("0\n0\n");
        return 0;
    }
    memset(vis, 0, sizeof vis);
    int l = 1, r = 1, cnt = p1;
    while(1) {
        if(!cnt) {
            while(!need[b[l]]) l++;
            if(l == m + 1) break;
            p2 = min(p2, r - l);
            if(vis[b[l]] == 1) cnt++;
            if(vis[b[l]] >= 1) vis[b[l]]--, l++; 
        } else {
            if(r == m + 1) break;
            if(need[b[r]]) {
                if(!vis[b[r]]) cnt--;
                vis[b[r]]++;
            }
            r++;
        }
    }
    printf("%d\n%d\n", p1, p2);
    return 0;
}
```
    - **核心思想**：通过哈希标记要背单词，初始化左右端点，根据是否包含所有要背单词移动端点，更新最短长度。
3. **作者：梧桐灯（4星）**
    - **关键亮点**：推荐使用unordered_map提高效率，代码简洁，逻辑清晰。
    - **个人心得**：无
    - **核心代码**：
```cpp
#pragma GCC optimize("Ofast")
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <string>
#include <unordered_map> 
using namespace std;

const int N = 1003, M = 100003;
unordered_map <string, int> w, k; 
int n, m;
string a[N], b[M];

int main () {
    scanf ("%d", &n);
    int i, j; for (i = 1; i <= n; ++i) {
        cin >> a[i];
        ++w[a[i]];
    }
    scanf ("%d", &m);
    for (i = 1; i <= m; ++i) cin >> b[i];
    i = j = 1;
    int now = 0;
    int ans = 0, minlen = (1 << 30);
    while (j <= m) {
        if (w[b[j]] &&!k[b[j]]) {
            ++now;
            k[b[j]] = 1;
        } 
        else ++k[b[j]]; 
        while (i <= j && (!w[b[i]] || k[b[i]] > 1)) {
            --k[b[i]];
            ++i;
        } 
        if (now > ans) {
            ans = now;
            minlen = j - i + 1;
        }
        else if (now == ans) minlen = min (minlen, j - i + 1);
        ++j;
    }
    printf ("%d\n%d\n", ans, minlen);
    return 0;
}
```
    - **核心思想**：用unordered_map标记要背单词，通过双指针遍历文章段落，根据条件移动指针，更新最多单词数和最短长度。

### 最优的关键思路或技巧
1. **数据结构**：使用哈希表（如map、unordered_map）可高效判断单词是否为要背单词，降低查找时间复杂度。
2. **算法优化**：尺取法能在线性时间内动态维护包含要背单词的最优子段落，避免暴力枚举所有子区间。

### 可拓展之处
同类型题常涉及在序列中寻找满足特定条件的最短或最长子序列，类似算法套路有滑动窗口、单调队列等。如在一些字符串匹配、数组元素统计问题中可应用。

### 相似知识点的洛谷题目
1. **P1886 滑动窗口**：考察滑动窗口思想，与本题尺取法类似，在序列中寻找最值。
2. **P3957 [NOIP2017 普及组] 跳房子**：可使用二分查找答案，结合前缀和优化判断，与本题二分查找思路相关。
3. **P1387 最大正方形**：通过动态规划解决在矩阵中寻找满足条件的最大正方形，与本题在序列中找最优子段有相似思维方式。

### 个人心得摘录与总结
1. **作者：Merak**：强调细节重要性，因细节问题WA多次。总结为做题时需仔细处理边界条件、变量更新等细节。
2. **作者：傅思维666**：分享学习字符串哈希和尺取法解决本题的过程，强调对知识点的学习与运用能力。 

---
处理用时：60.11秒
# 题目信息

# 序列变换

## 题目描述

给定一个由 $n$ 个整数构成的序列 $a_1, a_2, \ldots , a_n$，你需要对它进行如下操作：

1. 输入格式 `1 x y`，表示把所有 $a_{k x}$（$k$ 为正整数，$k x \le n$）都加上 $y$。
2. 输入格式 `2 j`，表示输出 $a_j$。

## 说明/提示

对于 $40 \%$ 的数据，$n \le 100$。  
对于 $100 \%$ 的数据，$1 \le n \le {10}^6$，$1 \le m \le {10}^5$，$|a_i| \le {10}^6$，$|y| \le {10}^6$，$1 \le x\le n$，$0\le j \le n$，操作 2 不超过 ${10}^4$ 条。

## 样例 #1

### 输入

```
5 4
6 9 9 8 1 
2 4
1 2 5
1 3 1
2 4
```

### 输出

```
8
13```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何优化对序列操作的时间复杂度展开。大部分题解利用操作2数量有限（不超过10000条）这一特点，采用记录操作1的增量，在操作2时通过枚举约数来计算最终值的方法。少数题解尝试了不同的优化思路，如线性筛求约数、根号分治等。

### 所选的题解
- **作者：小小怪下士___ (赞：28)  星级：4星**
    - **关键亮点**：思路清晰，直接利用操作2次数限制，通过map记录操作1的增量，操作2时枚举约数计算结果，代码简洁明了。
    - **个人心得**：一开始以为要用线段树，后发现数据范围特点，采用更简单方法，先暴力得60分后根据数据范围优化。
```c
#include<bits/stdc++.h>
using namespace std;
const int ch=1000010;
int a[ch],n,m,ans;
map<int,int>t;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    while(m--)
    {
        int x;
        scanf("%d",&x);
        if(x==1)
        {
            int y,z;
            scanf("%d%d",&y,&z);
            t[y]+=z;//标记起来 
        }
        if(x==2)
        {
            int z,zhi=0;
            scanf("%d",&z);
            for(int i=1;i<=z/i;i++)//快速判断约数 
            {
                if(z%i==0)//如果这个数的约数 
                {
                    if(t[i]){zhi+=t[i];}//且出现过不为0就累加 
                    if(i!=z/i&&t[z/i])zhi+=t[z/i];//同上 
                }
            }
            printf("%d\n",a[z]+zhi);//原来的值加上增加的值 
        }
    }
}
```
核心实现思想：操作1时，将增量y记录在map t中以x为键的值上；操作2时，枚举z的约数i，若t[i]存在则累加到zhi，同时处理i!= z/i时的z/i情况，最后输出a[z]与zhi之和。

- **作者：pikabi (赞：9)  星级：4星**
    - **关键亮点**：提出线性筛求约数的优化方法，适用于操作2无次数限制的情况，理论复杂度更优。
```
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cctype>
//#define int long long
#define ll long long
#define inf 1023456789

using namespace std;

inline int read(){
    int x=0,w=0;char ch=getchar();
    while (!isdigit(ch))w|=ch=='-',ch=getchar();
    while (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return w?-x:x;
}

int n, m, prime[1000005], cnt, min_prime[1000005];
ll a[1000005], b[1000005], res;
bool vis[1000005];
int que[1005], num[1005], now;

inline void dfs(int p, int u){
    if(p == now + 1) {
        res += b[u];
        return ;
    }
    int w = 1;
    for(int i = 0; i <= num[p]; i++){
        dfs(p + 1, u * w);
        w *= que[p];
    }
}

signed main(){
    n = read(), m = read();
    for(int i = 2; i <= n; i++){
        if(!vis[i]){
            prime[++cnt] = i;
            min_prime[i] = i;
        }
        for(int j = 1; j <= cnt && prime[j] * i <= n; j++){
            vis[i * prime[j]] = 1;
            min_prime[i * prime[j]] = prime[j];
            if(i % prime[j] == 0) break;
        }
    }
    for(int i = 1; i <= n; i++) a[i] = read();
    for(int i = 1; i <= m; i++){
        int op = read();
        if(op == 1){
            int x = read(), y = read();
            b[x] += y;
        }
        else {
            int x = read();
            if(!x) {
                puts("0");
                continue;
            }
            int xx = x;
            res = 0;
            now = 0;
            while(x > 1){
                now++;
                int w = min_prime[x];
                que[now] = w;
                num[now] = 0;
                while(x % w == 0){
                    num[now]++;
                    x /= w;
                }
            }
            dfs(1, 1);
            printf("%lld\n",a[xx]+res);
        }
    }
}
```
核心实现思想：先通过线性筛预处理出每个数的最小质因子，操作1时记录增量，操作2时分解质因数，通过dfs枚举所有约数并累加对应增量。

### 最优关键思路或技巧
利用操作2次数有限，将操作1的增量记录下来，在操作2时通过枚举约数（利用约数成对出现特性，只枚举到平方根）来计算最终值，避免对所有数进行实时更新，有效降低时间复杂度。

### 可拓展思路
此类题目核心是处理对序列特定位置的批量操作与查询。类似套路可应用于其他具有类似操作模式的题目，如对数组某些下标倍数位置进行修改，之后查询特定位置值。可拓展到二维数组或更高维数据结构的类似操作。

### 推荐题目
- P2361 yyy loves Maths VI (mode版)
- P2155 [SDOI2008]沙拉公主的困惑
- P3912 素数个数

---
处理用时：45.88秒
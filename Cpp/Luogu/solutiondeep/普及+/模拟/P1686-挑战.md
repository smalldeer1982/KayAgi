# 题目信息

# 挑战

## 题目描述

桃花岛其实也没什么好玩的，黄蓉经常偷偷跑到江湖上与洪七公等人玩。于是，黄药师就经常想一些游戏与女儿玩，为了是把黄蓉留在身边，江湖险恶啊！

这次黄药师又想了一种模拟游戏，游戏是这样的：她把整个桃花岛划分成一个坐标系。游戏开始前，黄蓉站在平面坐标系的一个点上，而她的闺房在坐标系的另一个点上，任何时候，她可以从当前所在点跨一步达到她周围的上、下、左、右四个点，黄药师不断地说四个字“东（E）”、“南（S）”、“西（W）”、“北（N）”，则黄蓉就想象着不断地从一个点走到另一个点，直至到自己的闺房为止。

![](https://cdn.luogu.com.cn/upload/image_hosting/gso383g9.png)

比如，黄蓉开始时站在 $\rm A$ 点，她的家在 $\rm B$ 点，黄药师连续说了一串：$\verb!NNNENNWWWSSW!$，则走了如下一个线路。然后，黄药师会问黄蓉：中间有没有走“弯路”了？即有没有捷径好走？比如，下图中就有多条捷径，可以从 $\rm C$ 走 $\verb!NN!$ 而到 $\rm E$，或走 $\verb!WW!$ 直接到 $\rm D$。

注意：捷径必须是直线。

黄药师听说你是一个程序设计高手，就想请你编个程序帮他测测这个游戏的难度，以便改进游戏规则后再让黄蓉挑战。

你的任务是：找一条最短的捷径。


## 样例 #1

### 输入

```
12

NNNENNWWWSSW

```

### 输出

```
2 3 11 W```

# AI分析结果

### 综合分析与结论
所有题解都基于同一核心思路：利用捷径必须是直线这一条件，通过对横纵坐标分别排序，查找横坐标或纵坐标相同且编号不相邻的点对，计算其距离以找出最短捷径。

算法要点在于对每个移动点的坐标及编号记录，排序后遍历相邻点对判断是否构成捷径，并按题目要求更新最短捷径的长度、起点、终点和方向。

解决难点主要是如何有效筛选出符合条件的捷径，避免将已存在路径误判为捷径，以及在多种符合条件的捷径中按要求选择最优解。

整体来看，各题解思路清晰，但在代码实现的简洁性、可读性及优化程度上存在差异。

### 所选的题解
1. **作者：Ice_Kissღ（5星）**
    - **关键亮点**：思路阐述极为清晰，从题目分析入手，逐步引导出解题思路，并特别提醒关键易错点，代码注释详尽，可读性强。
    - **个人心得**：强调模拟题的重要性，通过本题练习模拟题手感。
    - **重点代码及核心思想**：
```cpp
// 结构体记录点的坐标和编号
struct node
{
    int x;
    int y;
    int bian;
} rong[250005];
// 横坐标排序比较函数
bool cmp1(node a, node b)
{
    return a.x < b.x || (a.x == b.x && a.y < b.y);
}
// 纵坐标排序比较函数
bool cmp2(node a, node b)
{
    return a.y < b.y || (a.y == b.y && a.x < b.x);
}
// 查找横坐标相同点对的捷径
void jx()
{
    int tmp, a, b;
    char er;
    for (int i = 1; i <= n - 1; i++)
    {
        if (rong[i].x == rong[i + 1].x)
        {
            tmp = abs(rong[i].y - rong[i + 1].y);
            if (rong[i].bian < rong[i + 1].bian)
            {
                a = rong[i].bian;
                b = rong[i + 1].bian;
                if (rong[i].y < rong[i + 1].y)
                    er = 'N';
                else
                    er = 'S';
            }
            else
            {
                a = rong[i + 1].bian;
                b = rong[i].bian;
                if (rong[i + 1].y < rong[i].y)
                    er = 'N';
                else
                    er = 'S';
            }
            if (a + 1 == b)
                continue;
            if (minn == tmp)
            {
                if (here > a)
                {
                    minn = tmp;
                    here = a;
                    to = b;
                    xiang = er;
                }
                else if (here == a)
                {
                    if (b > to)
                    {
                        minn = tmp;
                        here = a;
                        to = b;
                        xiang = er;
                    }
                }
            }
            if (minn > tmp)
            {
                minn = tmp;
                here = a;
                to = b;
                xiang = er;
            }
        }
    }
}
// 查找纵坐标相同点对的捷径
void jy()
{
    int tmp, a, b;
    char er;
    for (int i = 1; i <= n - 1; i++)
    {
        if (rong[i].y == rong[i + 1].y)
        {
            tmp = abs(rong[i].x - rong[i + 1].x);
            if (rong[i].bian < rong[i + 1].bian)
            {
                a = rong[i].bian;
                b = rong[i + 1].bian;
                if (rong[i].x < rong[i + 1].x)
                    er = 'E';
                else
                    er = 'W';
            }
            else
            {
                a = rong[i + 1].bian;
                b = rong[i].bian;
                if (rong[i + 1].x < rong[i].x)
                    er = 'E';
                else
                    er = 'W';
            }
            if (a + 1 == b)
                continue;
            if (minn == tmp)
            {
                if (here > a)
                {
                    minn = tmp;
                    here = a;
                    to = b;
                    xiang = er;
                }
                else if (here == a)
                {
                    if (b > to)
                    {
                        minn = tmp;
                        here = a;
                        to = b;
                        xiang = er;
                    }
                }
            }
            if (minn > tmp)
            {
                minn = tmp;
                here = a;
                to = b;
                xiang = er;
            }
        }
    }
}
```
核心思想是通过两个函数 `jx` 和 `jy` 分别处理横坐标和纵坐标相同的情况，在遍历相邻点对时，计算距离、判断起点终点及方向，按要求更新最短捷径信息。

2. **作者：__shadow__（4星）**
    - **关键亮点**：代码结构清晰，将查找横纵方向捷径的功能封装成独立函数，便于理解和维护，对思路的分析和代码注释也较为详细。
    - **重点代码及核心思想**：
```cpp
struct node
{
    int x, y, id;
} a[N];
bool cmpx(node a, node b)
{
    return a.x == b.x? a.y < b.y : a.x < b.x;
}
bool cmpy(node a, node b)
{
    return a.y == b.y? a.x < b.x : a.y < b.y;
}
struct stsearr
{
    int lenth;
    int head, tail;
    char fang;
} ans;
void do_x()
{
    stsearr t;
    for (int i = 2; i <= n; i++)
    {
        if (a[i].x == a[i - 1].x)
        {
            t.lenth = a[i].y - a[i - 1].y;
            if (a[i].id < a[i - 1].id)
            {
                t.fang = 'S';
                t.head = a[i].id;
                t.tail = a[i - 1].id;
            }
            else
            {
                t.fang = 'N';
                t.head = a[i - 1].id;
                t.tail = a[i].id;
            }
            if (t.head + 1 == t.tail)
                continue;
            if (t.lenth < ans.lenth)
                ans = t;
            else if (t.lenth == ans.lenth)
            {
                if (t.head < ans.head)
                    ans = t;
                else if (t.head == ans.head)
                    if (t.tail > ans.tail)
                        ans = t;
            }
        }
    }
}
void do_y()
{
    stsearr t;
    for (int i = 2; i <= n; i++)
    {
        if (a[i].y == a[i - 1].y)
        {
            t.lenth = a[i].x - a[i - 1].x;
            if (a[i].id < a[i - 1].id)
            {
                t.fang = 'W';
                t.head = a[i].id;
                t.tail = a[i - 1].id;
            }
            else
            {
                t.fang = 'E';
                t.head = a[i - 1].id;
                t.tail = a[i].id;
            }
            if (t.head + 1 == t.tail)
                continue;
            if (t.lenth < ans.lenth)
                ans = t;
            else if (t.lenth == ans.lenth)
            {
                if (t.head < ans.head)
                    ans = t;
                else if (t.head == ans.head)
                    if (t.tail > ans.tail)
                        ans = t;
            }
        }
    }
}
```
核心思想是定义两个排序函数 `cmpx` 和 `cmpy` 分别用于横纵坐标排序，`do_x` 和 `do_y` 函数分别查找横纵方向上的捷径，通过比较距离、起点和终点编号来更新最优捷径。

3. **作者：miao5（4星）**
    - **关键亮点**：代码简洁明了，逻辑清晰，通过两个自定义函数分别处理横坐标和纵坐标相同的情况，对每个步骤的实现都有清晰的代码体现。
    - **重点代码及核心思想**：
```cpp
struct node
{
    int x;
    int y;
    int e;
} m[250005];
bool cmp1(node a, node b) { return a.x < b.x || (a.x == b.x && a.y < b.y); }
bool cmp2(node a, node b) { return a.y < b.y || (a.y == b.y && a.x < b.x); }
void find_x()
{
    int num, a, b;
    char p;
    for (int i = 1; i <= n - 1; i++)
    {
        if (m[i].x == m[i + 1].x)
        {
            num = abs(m[i].y - m[i + 1].y);
            if (m[i].e < m[i + 1].e)
            {
                a = m[i].e;
                b = m[i + 1].e;
                if (m[i].y < m[i + 1].y)
                    p = 'N';
                else
                    p = 'S';
            }
            else
            {
                a = m[i + 1].e;
                b = m[i].e;
                if (m[i + 1].y < m[i].y)
                    p = 'N';
                else
                    p = 'S';
            }
            if (a + 1 == b)
                continue;
            if (ans1 == num)
            {
                if (ans2 > a)
                {
                    ans1 = num;
                    ans2 = a;
                    ans3 = b;
                    ans4 = p;
                }
                else if (ans2 == a)
                {
                    if (b > ans3)
                    {
                        ans1 = num;
                        ans2 = a;
                        ans3 = b;
                        ans4 = p;
                    }
                }
            }
            if (ans1 > num)
            {
                ans1 = num;
                ans2 = a;
                ans3 = b;
                ans4 = p;
            }
        }
    }
}
void find_y()
{
    int num, a, b;
    char p;
    for (int i = 1; i <= n - 1; i++)
    {
        if (m[i].y == m[i + 1].y)
        {
            num = abs(m[i].x - m[i + 1].x);
            if (m[i].e < m[i + 1].e)
            {
                a = m[i].e;
                b = m[i + 1].e;
                if (m[i].x < m[i + 1].x)
                    p = 'E';
                else
                    p = 'W';
            }
            else
            {
                a = m[i + 1].e;
                b = m[i].e;
                if (m[i + 1].x < m[i].x)
                    p = 'E';
                else
                    p = 'W';
            }
            if (a + 1 == b)
                continue;
            if (ans1 == num)
            {
                if (ans2 > a)
                {
                    ans1 = num;
                    ans2 = a;
                    ans3 = b;
                    ans4 = p;
                }
                else if (ans2 == a)
                {
                    if (b > ans3)
                    {
                        ans1 = num;
                        ans2 = a;
                        ans3 = b;
                        ans4 = p;
                    }
                }
            }
            if (ans1 > num)
            {
                ans1 = num;
                ans2 = a;
                ans3 = b;
                ans4 = p;
            }
        }
    }
}
```
核心思想是利用 `cmp1` 和 `cmp2` 对结构体数组按横纵坐标排序，`find_x` 和 `find_y` 函数分别遍历查找横纵方向符合条件的捷径，并按题目要求更新最短捷径的相关信息。

### 最优关键思路或技巧
- **排序优化查找**：通过对横纵坐标分别排序，将寻找捷径的范围缩小到相邻点对，大大降低了时间复杂度，从暴力的 $O(n^2)$ 优化到 $O(nlogn)$。
- **结构体封装数据**：使用结构体记录点的坐标和编号，使数据处理更为方便和清晰，增强了代码的可读性和维护性。

### 可拓展思路及类似算法套路
同类型题通常围绕路径规划、几何图形中的最短路径等场景，给定一些移动规则和条件，要求找出满足特定条件的最短路径或最优路径。类似算法套路是先明确路径的限制条件（如本题的直线捷径），将问题转化为对特定数据（如坐标点）的处理，通过排序、遍历等操作筛选出符合条件的路径，并按要求进行优化选择。

### 推荐题目
- **P1162 填涂颜色**：涉及对二维图形的遍历和处理，与本题处理平面上点的思路有相似之处，需根据一定规则判断和操作。
- **P1255 数楼梯**：通过分析路径的不同走法，寻找满足条件的方案数，锻炼对路径问题的逻辑分析能力，与本题在路径规划的思考方式上类似。
- **P1308 统计单词数**：虽然看似与路径问题不同，但在字符串处理中按特定规则查找和统计信息，与本题按条件筛选数据的思路一致，可强化条件判断和数据处理能力。 

---
处理用时：81.32秒
# 题目信息

# 词编码

## 题目描述

一个发送机可以通过一条隧道发送一些以二进制代码组成的单词。在其尽头的接收机可以使用特殊技术恢复到最初的单词。每个单词最初都由0和1组成。所有的单词最初长度都为n（4<=n<=1000）。当穿过隧道之后单词可能发生以下几种情况之一：

1. 任意（一个）0被1取代
2. 任意（一个）符号被删除
3. 一个符号（0或1）被插入到任何位置
4. 不改变

我们知道最初的单词都具有以下性质：有1的位置号的总和是n+1的倍数，或者是0.


## 样例 #1

### 输入

```
4
0000
011
1011
11011```

### 输出

```
0000
0110
1001
1111```

# AI分析结果

• 综合分析与结论：这些题解思路大致相同，均基于对题目中四种操作逆过程的模拟。首先判断输入字符串长度是否在合理范围（n - 1 到 n + 1），之后针对不同长度分别处理。长度为n时，判断是否符合条件或尝试将1变为0；长度小于n则尝试插入0或1；长度大于n则尝试删除0或1。算法要点在于利用前缀和或后缀和记录1的个数及位置和，以快速判断操作后的结果是否满足条件。解决难点主要是理解各操作对位置和的影响，并按题目要求的操作优先级实现。大部分题解都能清晰阐述思路，但在代码可读性和优化程度上有所差异。
• 所选的题解：
  - **作者：Trinity (5星)**
    - **关键亮点**：思路阐述极为详细，不仅分析暴力解法的复杂度，还提出优化思路，对各操作逆过程的原理证明清晰，代码中对关键步骤有注释，且给出暴力和AC两份代码便于对比学习。
    - **个人心得**：强调对题目理解的重要性，指出题面表述存在不清晰之处。
    - **核心代码片段（AC代码）**：
```cpp
int n,sum,cnt,pre[N],x;
string s;
inline string solve(string str)
{
    sum=cnt=x=0;
    memset(pre,0,sizeof(pre));
    int len=str.length();
    if(len<n-1&&len>n+1)return "-1";//长度错误。
    for(int i=0;i<=len-1;i++)
    {
        if(str[i]=='1')cnt++,sum+=i+1,pre[i+1]=pre[i]+1;
        else pre[i+1]=pre[i];//cnt->1的个数，sum->要求值，pre->前缀和，有多少个1.
    }
    x=sum%(n+1);
    if(len==n)
    {
        if(!x||!sum)return str;
        else if(str[x-1]=='1'){str[x-1]='0';return str;}//如以上所说。
        return "-1";
    }
    if(len<n)
    {
        for(int i=0;i<=len;i++)
            if((sum+(cnt-pre[i]))%(n+1)==0){str.insert(i,"0");return str;}//题目要求0优先，两个循环一定不要写在一起，否则···
        for(int i=0;i<=len;i++)
            if((sum+(cnt-pre[i])+i+1)%(n+1)==0){str.insert(i,"1");return str;}
        return "-1";
    }
    if(len>n)
    {
        for(int i=0;i<=len-1;i++)
        {
            if((sum-(cnt-pre[i+1]))%(n+1)==0&&str[i]=='0'){str.erase(i,1);return str;}//一定要带上str【i】的条件，否则···
            if((sum-(cnt-pre[i+1])-i-1)%(n+1)==0&&str[i]=='1'){str.erase(i,1);return str;}
        }
        return "-1";
    }
}
```
    - **核心实现思想**：先通过循环计算字符串中1的个数、位置和以及前缀和。根据字符串长度进行分类讨论，长度为n时，判断当前字符串是否满足条件或尝试修改特定位置的1为0；长度小于n时，按顺序尝试插入0或1；长度大于n时，按顺序尝试删除0或1，每次操作通过前缀和判断是否满足条件。
  - **作者：StevenYan (4星)**
    - **关键亮点**：代码结构清晰，对每个操作的逆过程分别实现，且在代码中有详细注释，便于理解。对插入和删除操作利用STL函数降低修改复杂度，并对操作中的细节进行说明。
    - **个人心得**：提到多组数据和不能下载测试点数据对解题的影响，强调题目理解和细节处理的重要性。
    - **核心代码片段**：
```cpp
string ans(string s) {
    int sum = 0;//表示原串所有1的编号和
    int sum_1 = 0;//表示原串含1的总数
    int sum_t1 = 0;//表示对当前位置进行增或删会影响到的1的个数
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '1')
            sum += i + 1, sum_1++;
    }//分别记录
    //此处也可以采取建立一个pre[]数组记录上面各处的sun_t1
    if (s.length() > n + 1 || s.length() < n - 1)
        return "-1";
    sum_t1 = sum_1;
    if (s.length() == n) {
        if (sum % (n + 1) == 0)
            return s;//可以不变就不变
        for (int i = 0; i < n; i++)
            if (s[i] == '1' && (sum - i - 1) % (n + 1) == 0) {
                s[i] = '0';
                return s;
            }
    } else {
        if (s.length() == n - 1) {
            for (int i = 0; i < n; i++) {
                if (i > 0)
                    if (s[i - 1] == '1')
                        sum_t1--;
                if ((sum + sum_t1) % (n + 1) == 0) {
                    s.insert(i, "0");//插入一个0
                    return s;
                }
            }
            sum_t1 = sum_1;
            for (int i = 0; i < n; i++) {
                if (i > 0)
                    if (s[i - 1] == '1')
                        sum_t1--;
                if ((sum + sum_t1 + i + 1) % (n + 1) == 0) {
                    s.insert(i, "1");//插入一个1
                    return s;
                }
            }
        } else if (s.length() == n + 1) {
            sum_t1 = sum_1;
            for (int i = 0; i < n + 1; i++) {
                if (s[i] == '1')
                    sum_t1--;
                if ((sum - sum_t1) % (n + 1) == 0 && s[i] == '0') {
                    s.erase(i, 1);//删去一位就好
                    return s;
                }
                if ((sum - sum_t1 - i - 1) % (n + 1) == 0 && s[i] == '1') {
                    s.erase(i, 1);
                    return s;
                }
            }
        }
    }
    return "-1";
}
```
    - **核心实现思想**：先统计字符串中1的编号和、总数等信息，根据字符串长度判断。长度为n时，判断是否满足条件或尝试修改1为0；长度为n - 1时，尝试插入0或1；长度为n + 1时，尝试删除0或1，通过计算影响的1的个数判断操作后是否满足条件。
  - **作者：lym12 (4星)**
    - **关键亮点**：思路清晰，对每种情况的判断和处理步骤明确，代码结构简洁，注释清晰，自认为码风良好，便于读者理解和学习。
    - **核心代码片段**：
```cpp
void solve(){
    int sv = 0, cnt = 0, len = s.size();
    memset(hre, 0, sizeof(hre));
    
    if (len < n - 1 || len > n + 1){
        puts("-1");
        return ;
    }

    for (int i = 0; i < len; i ++){
        if (s[i] == '1'){
            cnt ++;
            sv += (i + 1);
            hre[i + 1] = hre[i] + 1;
        }else hre[i + 1] = hre[i];
    }
    
    if (len == n){
        if (!(sv % (n + 1)) ||!sv){
            cout << s << '\n';
            return ;
        }else if (s[(sv % (n + 1)) - 1] == '1'){
            s[(sv % (n + 1)) - 1] --;
            cout << s << '\n';
            return ;
        }else{
            puts("-1");
            return ;
        }
    }
    
    if (len < n){
        for (int i = 0; i <= len; i ++){
            if ((sv + cnt - hre[i]) % (n + 1) == 0){
                s.insert(i, "0");
                cout << s << '\n';
                return ;
            }
        }

        for (int i = 0; i <= len; i ++){
            if ((sv + (cnt - hre[i]) + i + 1) % (n + 1) == 0){
                s.insert(i, "1");
                cout << s << '\n';
                return ;
            }
        }
        
        puts("-1");
        return ;
    }
    
    if (len > n){
        for (int i = 0; i < len; i ++){
            if ((sv - (cnt - hre[i + 1])) % (n + 1) == 0 && s[i] == '0'){
                s.erase(i, 1);
                cout << s << '\n';
                return ;
            }else if ((sv - (cnt - hre[i + 1]) - i - 1) % (n + 1) == 0 && s[i] == '1'){
                s.erase(i, 1);
                cout << s << '\n';
                return ;
            }
        }
        
        puts("-1");
        return ;
    }
}
```
    - **核心实现思想**：首先初始化变量并判断字符串长度是否合法。然后遍历字符串统计1的相关信息及后缀和。根据长度分类，长度为n时判断是否满足条件或修改1为0；长度小于n尝试插入0或1；长度大于n尝试删除0或1，通过后缀和判断操作结果是否符合要求。
• 最优关键思路或技巧：利用前缀和或后缀和记录1的数量及位置和，这样在进行插入或删除操作时，能快速计算出操作后位置和的变化，从而判断是否满足条件，避免每次都重新计算整个字符串的位置和，优化了时间复杂度。
• 可拓展思路：同类型题通常围绕字符串操作及特定条件判断展开，类似算法套路是在处理字符串修改操作时，通过记录关键信息（如本题的前缀和）来快速判断操作后的结果是否符合条件。例如涉及字符串的替换、插入、删除操作并需要满足某种数值规律的题目。
• 相似知识点洛谷题目：
  - [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)：涉及字符串处理及校验和计算，与本题对字符串特定条件判断有相似之处。
  - [P1593 因子和阶乘](https://www.luogu.com.cn/problem/P1593)：虽然主要是数论问题，但在处理过程中也涉及对数字的分解与条件判断，与本题对字符串操作后满足特定条件的思路类似。
  - [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：通过不同方案的计算与比较选择最优解，与本题对不同操作方案进行判断选择有相似的思维方式。
• 个人心得摘录与总结：多位作者提到对题目理解的重要性，题面表述有时不清晰，需要仔细分析。同时，在处理多组数据及复杂操作时，要注意细节处理，如边界条件判断、操作优先级等。调试过程中，像未对数组初始化导致多组数据出错等问题也时有发生，需要严谨对待代码中的细节。 

---
处理用时：68.93秒
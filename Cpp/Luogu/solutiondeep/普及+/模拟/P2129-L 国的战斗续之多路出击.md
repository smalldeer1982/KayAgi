# 题目信息

# L 国的战斗续之多路出击

## 题目背景

广而告之：背景见其他L国的战斗！！大家一起刷


## 题目描述

这一次，L 国决定军队分成 $n$ 组，分布在各地，若以 L 国为原点，可以看作在一个直角坐标系内。但是他们都受统一的指挥，指令部共发出 $m$ 个命令。命令有移动、上下转移和左右转移，但是由于某些奇奇怪怪的原因，军队收到命令总是有延迟，为了方便，军方已经写好一个栈，所以你要处理的顺序，应该是从后往前。


## 说明/提示

对于 $30\%$ 的数据，$1\leqslant n,m\leqslant 1000$。

对于 $100\%$ 的数据，$1\leqslant n,m\leqslant 5\times 10^5$，$x_i,y_i$ 在 `int` 范围内。

## 样例 #1

### 输入

```
3 3
0 0
4 -3
6 7
x
m -1 2
y
```

### 输出

```
1 2
-3 5
-5 -5
```

# AI分析结果

• 综合分析与结论：
    - 本题要求处理在直角坐标系内的多组军队根据特定命令移动的问题，暴力模拟的时间复杂度为O(nm)，会超时，需进行优化。
    - 各题解思路主要分为以下几类：
        - **移动坐标系法**：通过移动坐标系来减少对每个点的重复操作，将操作统计到坐标系上，对于翻转操作，通过翻转坐标系并反向统计第一种操作来实现。
        - **简化操作法**：将末位置分为原始坐标（考虑正负变化）和坐标变化量两部分，通过遍历操作确定原始坐标的正负和坐标变量，进而得出最终位置。
        - **矩阵乘法法**：利用矩阵乘法的结合律，将操作转化为3*3矩阵相乘，先将所有操作对应的矩阵按序相乘，再将结果与每个点对应的矩阵相乘，得到点经过一系列移动后的位置。
        - **线段树法**：使用线段树维护乘法标记和加法标记，根据操作更新标记，通过下传标记实现区间加和区间乘操作，模拟题目要求。
        - **标记化模拟法**：维护四个值（$Add_x,Add_y,Mul_x,Mul_y$），利用懒标记思想，根据操作更新这些值，最后结合标记计算每个点的最终坐标。
    - 解决难点在于优化暴力模拟，减少重复计算，提高算法效率。
    - 综合思路清晰度、代码可读性、优化程度等方面，以下3条题解评分较高：
  - **作者：sSay (赞：23)**
    - **星级**：5星
    - **关键亮点**：提出移动坐标系的独特思路，代码简洁明了，时间复杂度为O(n)，高效解决问题。
    - **核心代码**：
```cpp
int Get(int p) {return (p? -1 : 1);}
int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++i) cin >> x[i] >> y[i];
    for(int i = 1; i <= m; ++i) {
        cin >> ch[i];
        if(ch[i] == 'm') cin >> a[i] >> b[i];    
    }
    ll deltax = 0, deltay = 0;
    for(int i = m; i >= 1; --i) {
        if(ch[i] == 'x') flag1 ^= 1;
        else if(ch[i] == 'y') flag2 ^= 1;
        else {
            deltax += Get(flag1) * a[i];
            deltay += Get(flag2) * b[i];
        }
    }
    for(int i = 1; i <= n; ++i) {
        cout << Get(flag1) * (deltax + x[i]) << ' ' << Get(flag2) * (deltay + y[i]) << endl;
    }
    return 0;
}
```
    - **核心思想**：通过`Get`函数确定符号，遍历操作指令，根据`x`、`y`指令更新标志位，根据`m`指令累加坐标变化量，最后根据标志位和坐标变化量计算并输出每个点的最终坐标。
  - **作者：1沃尔克 (赞：8)**
    - **星级**：4星
    - **关键亮点**：思路清晰，将末位置分解为原始坐标和坐标变化量两部分，通过简单的模拟和数学运算解决问题，代码实现简洁易懂。
    - **核心代码**：
```cpp
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%lld%lld",&lc[i].x,&lc[i].y);
    for(int i=1;i<=m;i++)
    {
        cin>>c[i];
        if(c[i]=='m') 
        scanf("%lld%lld",&a[i],&b[i]);
    }
    long long xx=0,sx=1,yy=0,sy=1;
    for(int i=m;i>=1;i--)
    {
        if(c[i]=='y')
        {
            sy=-sy;yy=-yy;
        }
        if(c[i]=='m')
        {
            xx+=a[i];yy+=b[i];
        }
        if(c[i]=='x')
        {
            sx=-sx;xx=-xx;
        }
    }
    for(int i=1;i<=n;i++)
        printf("%lld %lld\n",lc[i].x*sx+xx,lc[i].y*sy+yy);
    return 0;
}
```
    - **核心思想**：遍历操作指令，根据`x`、`y`指令改变坐标正负和坐标变化量的正负，根据`m`指令累加坐标变化量，最后结合原始坐标和坐标变化量计算并输出每个点的最终坐标。
  - **作者：wanglichao1121 (赞：8)**
    - **星级**：4星
    - **关键亮点**：运用矩阵乘法的结合律解决问题，理论性强，时间复杂度为O(n + m)，算法效率高。
    - **核心代码**：
```cpp
procedure cf;            //3*3矩阵a乘上3*3矩阵b，得到3*3矩阵c
var i,j,k:longint;
begin
  for i:=1 to 3 do
  for j:=1 to 3 do
  begin
  s:=0;
  for k:=1 to 3 do s:=s+a[i,k]*b[k,j];
  c[i,j]:=s;
  end;
end;
procedure cff;           //3*3矩阵a乘上 3*1矩阵d，得到3*1矩阵c
var i,j,k:longint;
begin
  for i:=1 to 3 do
  for j:=1 to 1 do
  begin
  s:=0;
  for k:=1 to 3 do
  s:=s+a[i,k]*d[k,j];
  c[i,j]:=s;
  end;
end;
begin
  assign(input,'army.in');reset(input);
  assign(output,'army.out');rewrite(output);
  readln(n,m);
  for i:=1 to n do
  readln(x[i],y[i]);
  read(ch);
  case ch of
'm':
  begin
  readln(p,q);
  a[1,1]:=1;a[1,2]:=0;a[1,3]:=p;
  a[1,2]:=0;a[2,2]:=1;a[2,3]:=q;
  a[3,1]:=0;a[3,2]:=0;a[3,3]:=1;
  end;
'y':
  begin
  readln;
  a[1,1]:=1;a[1,2]:=0;a[1,3]:=0;
  a[2,1]:=0;a[2,2]:=-1;a[2,3]:=0;
  a[3,1]:=0;a[3,2]:=0;a[3,3]:=1;
  end;
'x':
  begin
  readln;
  a[1,1]:=-1;a[1,2]:=0;a[1,3]:=0;
  a[2,1]:=0;a[2,2]:=1;a[2,3]:=0;
  a[3,1]:=0;a[3,2]:=0;a[3,3]:=1;
  end;
  end;
  for i:=2 to m do
  begin
  read(ch);
  case ch of
'm':
  begin
  readln(p,q);
  b[1,1]:=1;b[1,2]:=0;b[1,3]:=p;
  b[1,2]:=0;b[2,2]:=1;b[2,3]:=q;
  b[3,1]:=0;b[3,2]:=0;b[3,3]:=1;
  end;
'y':
  begin
  readln;
  b[1,1]:=1;b[1,2]:=0;b[1,3]:=0;
  b[2,1]:=0;b[2,2]:=-1;b[2,3]:=0;
  b[3,1]:=0;b[3,2]:=0;b[3,3]:=1;
  end;
'x':
  begin
  readln;
  b[1,1]:=-1;b[1,2]:=0;b[1,3]:=0;
  b[2,1]:=0;b[2,2]:=1;b[2,3]:=0;
  b[3,1]:=0;b[3,2]:=0;b[3,3]:=1;
  end;
  end;
  cf;
  a:=c;
  end;                          //先把所有矩阵按序乘上
  for i:=1 to n do                 //再一个点一个点处理位置
  begin
  d[1,1]:=x[i];d[2,1]:=y[i];d[3,1]:=1;
  cff;
  writeln(c[1,1],' ',c[2,1]);
  end;
  close(input);close(output);
end.
```
    - **核心思想**：定义矩阵乘法函数`cf`和`cff`，根据操作指令构建相应的矩阵，通过循环将所有操作对应的矩阵相乘，最后将每个点对应的矩阵与结果矩阵相乘，得到并输出每个点的最终坐标。

• 最优关键思路或技巧：
    - **移动坐标系法**：巧妙地将对每个点的操作转化为对坐标系的操作，减少重复计算，极大地优化了时间复杂度。
    - **矩阵乘法法**：利用矩阵乘法的结合律，将复杂的操作序列转化为矩阵运算，逻辑清晰，算法效率高。

• 拓展思路：
    - 同类型题通常涉及对大量数据点进行相同的几何变换操作，如平移、旋转、缩放等。类似算法套路包括利用矩阵来表示变换，通过矩阵乘法来组合多个变换；或者利用懒标记思想，将重复操作合并，减少实际计算次数。

• 洛谷相似题目推荐：
    - P3390 【模板】矩阵快速幂
    - P1962 斐波那契数列
    - P1349 广义斐波那契数列

• 个人心得摘录与总结：
    - **作者：辰星凌**：提到自己作为不会矩阵和模拟的初学者选择线段树方法解题，虽方法较为复杂，但对于理解线段树的区间操作有帮助，同时指出题目中指令需倒着处理这一坑点。总结为初学者在面对难题时可尝试从熟悉的知识入手，同时要仔细审题，注意细节。 

---
处理用时：68.16秒
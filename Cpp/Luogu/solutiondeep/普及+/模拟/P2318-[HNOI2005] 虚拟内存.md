# 题目信息

# [HNOI2005] 虚拟内存

## 题目描述

操作系统中一种重要的存储管理技术就是虚拟内存技术。操作系统中允许进程同时运行，也就是并行。每个进程都有其相对独立的数据块（进程运行的过程中将对其进行读写操作）。理想的情况下，这些数据块都应该存放在内存中，这样才能实现高效的读写操作。但事实上，内存的容量有限，每个进程只能把一部分数据放在内存中，为了解决这个矛盾，提出了虚拟内存技术。

虚拟内存技术的基本原理是：对进程而言，内存空间是无限大的，进程可以随意地读写数据，而对操作系统内部而言，利用外存来模拟扩充的内存空间，进程要求访问某个内存单元时，交由操作系统处理，操作系统首先在内存中查找该单元是否存在，如果存在，查找成功，否则转入外存查找（一定存在于外存中）。

就存储介质的物理性质而言，内存的访问速度相对于外存要快得多，因此对于每个进程来说操作系统应该把那些访问次数较多的数据存放在内存中，而把那些访问次数很少的数据放在外存中。如何选择内存中暂留的数据是一个很值得研究的问题，下面介绍一个内存管理中比较常用的算法：

内存中的数据以页为基本存储单位，进程的读写操作都针对页来进行。实际内存空间被分割成n页，虚拟内存空间的页数往往要多得多。某一时刻，进程需要访问虚存编号为P的页，该算法的执行步骤如下：

a.    首先在内存中查找，如果该页位于内存中，查找成功，转d，否则继续下面的操作；

b.    寻找内存中是否存在空页（即没有装载任何数据页的页面），若有，则从外存中读入要查找页，并将该页送至内存中的空页进行存储，然后转d，否则继续下面的操作；

c.    在内存中寻找一个访问次数最少的页面（如果存在多个页面的访问次数同时为最少，则选取最早读入数据进入内存的那个页面），从外存中读入要查找页，替换该页。

d.    结束

所谓访问次数是指从当前页面进入内存到该时刻被访问的次数，如果该页面以前进入过内存并被其它页面替换，那么前面的访问次数不应计入这个时刻的访问次数中。

你的任务是设计一个程序实现上述算法。

测试数据将会提供 $m$ 条读写内存的命令，每条命题提供要求访问的虚拟内存页的编号 $P$ 。你的程序要求能够模拟整个 $m$ 条命令的全部执行过程，所有的命令是按照输入的先后执行的，最开始的时候内存中的 $n$ 页全为空。



## 样例 #1

### 输入

```
3 8 

1

1

2

3

4

2

5

4

```

### 输出

```
1```

# AI分析结果

• 综合分析与结论：
    - 本题主要考查对虚拟内存管理算法的实现，涉及数据结构的运用。各题解思路主要围绕如何高效实现内存页的查找、替换等操作。
    - 算法要点包括使用不同数据结构维护内存页信息，如优先队列、map、线段树、set等，同时要处理好访问次数、进入时间等因素。
    - 解决难点在于如何在内存已满时，快速找到并替换访问次数最少且最早进入内存的页面，以及如何动态更新数据结构以反映内存页状态变化。
    - 整体来看，各题解质量参差不齐，部分题解思路清晰、代码简洁，部分则存在代码可读性差、未充分优化等问题。

所选的题解：
  - 作者：liunian (赞：15)  星级：4星
    - 关键亮点：仅使用优先队列解决问题，代码简洁高效，通过离散化处理大编号问题，对优先队列排序优先级设置合理。
    - 个人心得：强调排序优先级设置时大于小于符号易错，调试花费较多时间。
    - 重点代码核心实现思想：定义结构体表示内存页信息，用优先队列维护，根据内存是否已满及页面是否存在进行相应操作，更新优先队列和访问次数。
    - 核心代码片段：
```cpp
struct node {
    int xu,t;
    bool operator<(const node &a)const {
        if(t==a.t)return xu>a.xu;
        return t>a.t;
    }
};
priority_queue<node>q;
int a[maxn],b[maxn];
int num[maxn];
int main() {
    int n,m;
    scanf("%d %d",&n,&m);
    for(int i=1; i<=m; i++)scanf("%d",&a[i]),b[i]=a[i];
    sort(b+1,b+m+1);
    int k=unique(b+1,b+m+1)-b-1;
    int tot=0,ans=0;
    for(int i=1; i<=m; i++) {
        a[i]=lower_bound(b+1,b+k+1,a[i])-b;
        if(num[a[i]])num[a[i]]++,ans++;
        else if(tot<n)tot++,num[a[i]]=1;
        else {
            node res=q.top();
            q.pop();
            while(num[a[res.xu]]!=res.t)res=q.top(),q.pop();
            num[a[i]]++,num[a[res.xu]]=0;
        }
        q.push((node){i,num[a[i]]});
    }
    printf("%d\n",ans);
    return 0;
}
```
  - 作者：Lysea (赞：5)  星级：4星
    - 关键亮点：采用MAP + 优先队列的方法，思路清晰，通过延迟处理解决优先队列难以频繁更新访问次数的问题，代码结构清晰。
    - 重点代码核心实现思想：用map记录页面访问次数，优先队列维护页面信息，根据页面是否在内存及内存是否已满进行操作，操作C时通过延迟处理更新优先队列找到访问次数最少的页面。
    - 核心代码片段：
```cpp
struct node{
    int v,t,idx;
    //v代表访问次数,t代表时间,idx代表编号 
    bool operator<(const node& a)const{
        if(v!=a.v) return v>a.v;
        return t>a.t;
    }
};
int n,m,ans;
map<int,int>h;
priority_queue<node>q;
signed main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1,a;i<=m;i++){
        cin>>a;
        if(h[a]){
            //目前编号在内存里 
            //累计答案并更新访问次数 
            ans++;
            h[a]++;
        }
        else if(q.size()==n){
            //内存已满且目前编号不在内存里
            //延迟处理 
            node k=q.top();
            q.pop();
            while(h[k.idx]!=k.v){//如果优先队列顶端的值与 MAP中的值不同
                k.v=h[k.idx];//更新访问次数 
                q.push(k);
                k=q.top();//一直重复上述操作,直至优先队列内的访问次数为真实值,此时的访问次数即最小值 
                q.pop();
            }
            h[k.idx]=0,h[a]=1;
            q.push(node{1,i,a});
        }else{
            //内存未满且目前编号不在内存里
            //更新优先队列与访问次数 
            q.push(node{1,i,a});
            h[a]=1;
        }
    } 
    cout<<ans;
    return 0;
}
```
  - 作者：忘怜城羡 (赞：5)  星级：4星
    - 关键亮点：使用线段树维护内存页信息，能直观地处理区间内访问次数最少且最早出现的页面，时间复杂度为 \(O(m \log n)\)，逻辑较为清晰。
    - 重点代码核心实现思想：线段树节点维护内存页的访问次数、最早出现时间和内存页编号，通过map记录页面在内存中的位置，根据操作类型进行相应的查询和修改操作。
    - 核心代码片段：
```cpp
struct node{
    int sum,mino,minn;
}tree[maxn<<5];
int s,ans,i=1;
unordered_map<int,int> mp;
void pushdown(int p)
{
    if(tree[p*2].mino!=-1)
    {
        tree[p].sum=tree[p*2].sum;
        tree[p].mino=tree[p*2].mino;
        tree[p].minn=tree[p*2].minn;
    }
    if(tree[p*2+1].mino!=-1)
    {
        if(tree[p].sum==-1)
        {
            tree[p].sum=tree[p*2+1].sum;
            tree[p].mino=tree[p*2+1].mino;
            tree[p].minn=tree[p*2+1].minn;
        }
        else
        {
            if(tree[p].sum>tree[p*2+1].sum)
            {
                tree[p].sum=tree[p*2+1].sum;
                tree[p].mino=tree[p*2+1].mino;
                tree[p].minn=tree[p*2+1].minn;
            }
            else
            if(tree[p].sum==tree[p*2+1].sum)
            {
                if(tree[p].minn>tree[p*2+1].minn)
                {
                    tree[p].mino=tree[p*2+1].mino;
                    tree[p].minn=tree[p*2+1].minn;
                }
            }
        }
    }
}
void build(int p,int l,int r)
{
    if(l==r)
    {
        tree[p].sum=-1;
        tree[p].mino=-1;
        return ;
    }
    int mid=(l+r)>>1;
    build(p*2,l,mid);
    build(p*2+1,mid+1,r);
    tree[p].sum=-1;
    tree[p].mino=-1;
}
int find(int p,int l,int r,int x)
{
    int cnt;
    if(l==r)
    {
        if(tree[p].mino==x)
        {
        tree[p].sum++;
        return 1;
        }
        else
        return 0;
    }
    int mid=(l+r)>>1;
    if(mp[x]<=mid)
    cnt=find(p*2,l,mid,x);
    if(mid<mp[x])
    cnt=find(p*2+1,mid+1,r,x);
    pushdown(p);
    return cnt;
}
void modify(int p,int l,int r,int x)
{
    if(l==r)
    {
        tree[p].mino=x;
        tree[p].sum=1;
        tree[p].minn=i;
        return ;
    }
    int mid=(l+r)>>1;
    if(mp[x]<=mid)
    modify(p*2,l,mid,x);
    if(mid<mp[x])
    modify(p*2+1,mid+1,r,x);
    pushdown(p);
}
void change(int p,int l,int r,int x,int y)
{
    if(l==r)
    {
        tree[p].sum=1;
        tree[p].mino=y;
        tree[p].minn=i;
        return ;
    }
    int mid=(l+r)>>1;
    if(x<=mid)
    change(p*2,l,mid,x,y);
    if(mid<x)
    change(p*2+1,mid+1,r,x,y);
    pushdown(p);
}
signed main()
{
    int n,m;
    scanf("%lld%lld",&n,&m);
    build(1,1,n);
    s=n;
    for(;i<=m;++i)
    {
        int x;
        scanf("%lld",&x);
        if(mp[x]!=0&&find(1,1,n,x))
            ans++;
        else
        if(s>0)
        {
            mp[x]=s;
            modify(1,1,n,x);
            s--;
        }
        else
        {
            int p=tree[1].mino;
            change(1,1,n,mp[p],x);
            mp[x]=mp[p];
        }
    }
    printf("%lld",ans);
    return 0;
}
```

最优关键思路或技巧：
    - 数据结构选择上，优先队列能简洁地维护访问次数和进入时间的优先级，结合map或离散化处理，可高效实现题目要求。如liunian的题解，仅用优先队列和数组巧妙解决问题。
    - 延迟处理技巧，Lysea题解中通过map记录访问次数变化，在需要时再更新优先队列，避免频繁操作优先队列导致的效率问题。
    - 线段树可直观维护区间内的最小访问次数等信息，如忘怜城羡的题解，通过线段树节点存储多种信息，实现对内存页的有效管理。

可拓展之处：
    - 同类型题常涉及缓存替换策略、资源分配等场景，类似算法套路为使用合适数据结构维护元素状态和优先级，根据条件进行查找、插入和替换操作。

推荐洛谷题目：
    - P1442 小马过河 - 加强版，涉及优先队列等数据结构的运用，与本题在数据结构使用上有相似之处。
    - P3372 【模板】线段树 1，可巩固线段树基本操作，为理解本题中线段树解法打基础。
    - P2571 [SCOI2010] 传送带，结合数学计算和优先队列优化，锻炼对优先队列的灵活运用。

个人心得摘录与总结：
    - liunian提到在设置优先队列排序优先级时，大于小于符号易弄反，导致调试时间长。这提醒在实现过程中，对数据结构的关键操作细节需格外注意，小错误可能导致结果错误且难以排查。 

---
处理用时：54.19秒
# 题目信息

# yyy 棋

## 题目描述

uim 最近在研究一种游戏，叫做“ yyy 棋”。

这种游戏的规则很简单，就是有一个 $A \times B$ 的棋盘和黑白两色的棋子，两个人轮流在下在格子里面。你可以下黑棋或者白棋，中途可以更换颜色，可以下在任何你喜欢的地方，但是要符合以下条件：

1. 这个位置不能已经被别的棋子占用。

2. 你准备下的地方，上下左右一格范围中不能有和你准备下的颜色一样的棋子。

3. 第一个下的人必须出黑子。


当谁没有地方可以放子，谁就输了。


uim 把你拉了出来，希望你好好地陪他玩。

由于你很忙不太情愿，uim 就让步了，允许你选择先手或者后手。


你突然灵光一现，想到了你小学奥数做到的一个问题：两个人坐在一张桌子的两边，轮流往桌子上放硬币，硬币不能重叠，谁放不下谁就输了。感觉有点类似，所以，你打算借鉴这个办法。

你知道，通过某种策略，你一定是 $100\%$ 赢的。

既然如此，就让 uim 输个痛快吧。

## 说明/提示

$40\%$ 数据，$2 \le A, B \le 3$。

$100\%$ 数据，$2 \le A, B \le 9$。

然而作为月赛的第一题，自然是简单的。因为标程的核心代码只有 $6$ 行。并不需要使用什么复杂算法就可以得到答案。


## 样例 #1

### 输入

```
2 2

1 2 1

1 1 1```

### 输出

```
Second

2 1 0

Buwanle```

# AI分析结果

• 综合分析与结论：这些题解思路基本一致，都基于对称策略解题。算法要点在于根据棋盘长宽的奇偶性确定先后手及棋子颜色。难点在于理解为何长宽均为奇数时同色下子、长宽有偶数时异色下子。通过对不同情况的模拟分析得出此结论。
• 所选的题解：
  - 作者：Zhou_yu (5星)
    - 关键亮点：思路阐述详细，不仅说明了对称下子策略及根据奇偶性确定颜色，还给出了详细注释的AC代码，代码可读性高。
    - 重点代码核心实现思想：通过结构体记录棋盘每个格子状态，根据长宽奇偶性确定先后手并输出第一步。在循环中，每次读取对手落子后，检查是否违规，更新棋盘状态，根据奇偶性确定己方落子颜色及位置并输出，同时更新对应位置状态。
```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b;
struct node
{
	bool is_full=0;
	int color=-1;
	bool can_be_1=1;
	bool can_be_0=1;
}f[10][10];
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
void out()
{
	cout<<"Buwanle";
	exit(0);
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>a>>b;
	int t=0,flag=1;
	if(a%2)t++;
	if(b%2)t++;
	if(t==2)cout<<"First";
	else
	{
		cout<<"Second";
		flag=0;
	}
	cout<<'\n';
	if(t==2)
	{
		cout<<a/2+1<<' '<<b/2+1<<' '<<1<<'\n';
		for(int i=0;i<4;i++)
		{
			int tx=dx[i]+a/2+1;
			int ty=dy[i]+b/2+1;
			if(tx<1||ty<1||tx>a||ty>b)continue;
			f[tx][ty].can_be_1=0;
		}
	}
	int x,y,c;
	while(cin>>x>>y>>c)
	{
		if(f[x][y].is_full)out();
		if(c==1&&f[x][y].can_be_1==0)out();
		if(c==0&&f[x][y].can_be_0==0)out();
		f[x][y].is_full=1;
		f[x][y].color=c;
		for(int i=0;i<4;i++)
		{
			int tx=dx[i]+x;
			int ty=dy[i]+y;
			if(tx<1||ty<1||tx>a||ty>b)continue;
			if(c==1)f[tx][ty].can_be_1=0;
			else f[tx][ty].can_be_0=0;
		}
		int will_color=c;
		if(!flag)
		{
			if(c==1)will_color=0;
			else will_color=1;
		}
		int will_choose_x=a-x+1;
		int will_choose_y=b-y+1;
		cout<<will_choose_x<<' '<<will_choose_y<<' '<<will_color<<'\n';
		for(int i=0;i<4;i++)
		{
			int tx=dx[i]+will_choose_x;
			int ty=dy[i]+will_choose_y;
			if(tx<1||ty<1||tx>a||ty>b)continue;
			if(will_color==1)f[tx][ty].can_be_1=0;
			else f[tx][ty].can_be_0=0;
		}
	}
	return 0;
}
```
  - 作者：小恐 (4星)
    - 关键亮点：以初一学生视角，用通俗易懂语言结合图形示例说明策略，代码简洁，可读性较好。
    - 重点代码核心实现思想：通过字符数组记录棋盘状态，根据长宽乘积奇偶性确定先后手并输出第一步。循环读取对手落子，检查是否违规，更新棋盘状态，根据奇偶性确定己方落子颜色及位置并输出，同时更新对应位置状态。
```cpp
#include<stdio.h>
using namespace std;
char a[15][15];
int dx[5]={0,0,1,-1};
int dy[5]={1,-1,0,0};
int m,n,x,y,c,tx,ty;
bool read(int &s)
{
	s=0;
	int bei=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch==EOF)
			return 0;
		if(ch=='-')
			bei=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		s=s*10+ch-'0';
		ch=getchar();
	}
	s*=bei;
	return 1;
}
int main()
{
    bool ji;
	read(m),read(n);
	if((m*n)%2)
		printf("First\n%d %d 1\n",(m+1)/2,(n+1)/2),ji=1;
	else
		printf("Second\n"),ji=0;
	while(read(x)&&read(y)&&read(c))
	{
		if(x>m||x<1||y>n||y<1)
		{
			printf("Buwanle");
			break;
		}
		bool flag=1;
		for(int i=0;i<4;++i)
		{
			tx=dx[i]+x,ty=dy[i]+y;
			if(a[tx][ty]=='a'+c)
			{
				flag=0;
				break;
			}
		}
		if(!flag)
		{
			printf("Buwanle");
			break;
		}
		a[x][y]='a'+c;
		a[m-x+1][n-y+1]='a'+c;
		if(ji)
		    printf("%d %d %d\n",m-x+1,n-y+1,c),a[m-x+1][n-y+1]='a'+c;
		else
		    printf("%d %d %d\n",m-x+1,n-y+1,1-c),a[m-x+1][n-y+1]='a'+1-c;
	}
	return 0;
}
```
  - 作者：封禁用户 (4星)
    - 关键亮点：思路清晰，通过图文结合展示不同奇偶性下颜色选择原因，代码有详细注释。
    - 重点代码核心实现思想：定义结构体存储输入数据，用二维数组记录棋盘状态。根据长宽奇偶性确定先后手并输出第一步。循环读取对手落子，检查是否违规，更新棋盘状态，根据奇偶性确定己方落子颜色及位置并输出，同时更新对应位置状态。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
struct st
{
	ll x,y,z;
};
const ll N=110,INF=0x3f3f3f3f3f3f3f3f;
ll n,m,k,x,y,z,d[4][2]={{-1,0},{0,-1},{1,0},{0,1}},dx,dy,tu[N][N];
st a[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	memset(tu,0x3f,sizeof(tu));
	cin>>n>>m;
	while(cin>>x>>y>>z)
	{
		a[++k]={x,y,z};
	}
	if(n%2&&m%2)
	{
		cout<<"First\n";
		dx=n/2+1;
		dy=n/2+1;
		cout<<dx<<" "<<dy<<" "<<"1\n";
		tu[dx][dy]=1;
		for(int i=1;i<=k;i++)
		{
			if(tu[a[i].x][a[i].y]!=INF)
			{
				cout<<"Buwanle\n";
				return 0;
			}
			for(int j=0;j<4;j++)
			{
				if(tu[a[i].x+d[j][0]][a[i].y+d[j][1]]==a[i].z)
				{
					cout<<"Buwanle\n";
					return 0;
				}
			}
			tu[a[i].x][a[i].y]=a[i].z;
			dx=n-a[i].x+1;
			dy=m-a[i].y+1;
			cout<<dx<<" "<<dy<<" "<<a[i].z<<"\n";
			tu[dx][dy]=a[i].z;
		}
	}
	else
	{
		cout<<"Second\n";
		for(int i=1;i<=k;i++)
		{
			if(tu[a[i].x][a[i].y]!=INF)
			{
				cout<<"Buwanle\n";
				return 0;
			}
			for(int j=0;j<4;j++)
			{
				if(tu[a[i].x+d[j][0]][a[i].y+d[j][1]]==a[i].z)
				{
					cout<<"Buwanle\n";
					return 0;
				}
			}
			tu[a[i].x][a[i].y]=a[i].z;
			dx=n-a[i].x+1;
			dy=m-a[i].y+1;
			cout<<dx<<" "<<dy<<" "<<!a[i].z<<"\n";
			tu[dx][dy]=!a[i].z;
		}
	}
    return 0;
}
```
• 最优关键思路或技巧：利用中心对称策略，根据棋盘长宽奇偶性确定先后手及落子颜色。通过模拟小棋盘情况，理解并得出奇偶性不同时颜色选择规律。
• 可拓展之处：此类题目属于博弈论中的对称博弈类型，相似套路是找到某种对称关系，依据条件确定策略。例如一些在特定区域放置物品的博弈题，可通过寻找区域的对称点，结合题目规则制定策略。
• 相似知识点洛谷题目：
  - P1288 取数游戏II
  - P2148 [SDOI2009]E&D
  - P1199 [NOIP2010 普及组] 三国游戏
• 个人心得摘录与总结：无。 

---
处理用时：65.61秒
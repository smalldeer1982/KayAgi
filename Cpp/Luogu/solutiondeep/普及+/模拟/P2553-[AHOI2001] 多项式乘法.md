# 题目信息

# [AHOI2001] 多项式乘法

## 题目描述

请编程序把含有乘法运算的代数多项式表达式改写成不含乘法的代数多项式。为简化计算，特做以下约定：

1. 代数多项式表达式中只涉及一个代数符号 `a`；
2. 保证输入的「含乘法运算的代数多项式」有且仅有一个「代数多项式」与「代数多项式」的乘法。形式化地讲，每一个测试点的输入数据中，一定有且仅有一行 `(...)*(...)`，其中 `...` 为不含乘法运算的代数多项式。
3. 一个「不含乘法运算的代数多项式」会被写作 `XXXa^YYY+XXXa^YYY+XXXa^YYY+...+XXX`（代表 $\text{XXX}a ^ \text{YYY} + \text{XXX}a ^ \text{YYY} + \text{XXX}a ^ \text{YYY} + \cdots + \text{XXX}$），其中 `XXX`、`YYY` 均为正整数，且保证除第一项外每一项的 `YYY` 比上一项的 `YYY` 少 $1$。例如，一个合法的「不含乘法运算的代数多项式」为 `142a^4+9a^3+4a^2+1a^1+3`。

> 对于约定 3，原题目给予了这样一个表述：常数项以外的各项都是 $xa^y$ 的形式，写作 `xa^y`，其中 $x$ 为该项的系数，而 $y$ 是该项的指数。$x = 1$ 时，不得简写成 `a^y`，应写成 `1a^y`。而 $y = 1$ 时，不得简写成 `xa`，应写成 `xa^1`。

## 说明/提示

关于数据范围以及数据若干格式的说明：

* 系数范围和指数范围均为 $[0,30]$。

## 样例 #1

### 输入

```
(5a^2+3a^1+2)*(4a^1+1)
(5a^1+1)* (5a^1+1)```

### 输出

```
20a^3+17a^2+11a^1+2
25a^2+10a^1+1```

# AI分析结果

• 综合分析与结论：这些题解主要围绕多项式乘法展开，结合字符串处理。部分题解使用暴力算法直接计算多项式乘法，复杂度为$O(n^2)$，适用于本题较小的数据范围；部分题解采用FFT（快速傅里叶变换）或NTT（快速数论变换）算法，虽在本题中因数据规模小优势不明显，但在大数据量下可优化时间复杂度。字符串处理是共同难点，需从输入字符串中准确提取多项式的系数和指数。

• 所选的题解：
  - 作者：vocaloid (赞：6)  星级：4星
    - 关键亮点：思路清晰，先阐述FFT和字符串处理的重要性，详细描述字符串处理步骤，代码结构清晰，使用`getline`处理输入字符串，代码可读性较高。
    - 个人心得：无
    - 重点代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct Complex
{
    double x,y;
    friend Complex operator + (Complex a,Complex b)
    {
        return (Complex){a.x+b.x,a.y+b.y};
    }
    friend Complex operator - (Complex a,Complex b)
    {
        return (Complex){a.x-b.x,a.y-b.y};
    }
    friend Complex operator * (Complex a,Complex b)
    {
        return (Complex){a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x};
    }
}f[1000005],g[1000005];
const double Pi=acos(-1.0);
int n,m,maxn,L,R[1000005],ans[1000005];
string s;
void FFT(Complex *x,int Type)
{
    for(int i=0;i<maxn;i++) if(i<R[i]) swap(x[i],x[R[i]]);
    for(int i=1;i<maxn;i<<=1)
    {
        Complex W=(Complex){cos(Pi/i),Type*sin(Pi/i)};
        for(int j=0;j<maxn;j+=(i<<1))
        {
            Complex w=(Complex){1,0};
            for(int k=0;k<i;k++)
            {
                Complex a=x[j+k],b=w*x[i+j+k];
                x[j+k]=a+b;
                x[i+j+k]=a-b;
                w=W*w;
            }
        }
    }
}
void CalcWithFFT()
{
    n+=m;
    maxn=1;
    while(maxn<=n)
    {
        maxn<<=1;
        L++;
    }
    for(int i=0;i<maxn;i++) R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));
    FFT(f,1);
    FFT(g,1);
    for(int i=0;i<maxn;i++) f[i]=f[i]*g[i];
    FFT(f,-1);
    bool fg=0;
    for(int i=n;i>=0;i--)
    {
        ll x=(ll)(f[i].x/maxn+0.5);
        if(x)
        {
            if(!fg) fg=1;
            else printf("+");
            if(i) printf("%llda^%d",x,i);
            else printf("%lld\n",x);
        }
    }
}
int main()
{
    while(getline(cin,s))
    {
        L=n=m=0;
        memset(f,0,sizeof(f));
        memset(g,0,sizeof(g));
        bool fg=0;
        int len=s.size();
        for(int i=0;i<len;i++)
        {
            if(isdigit(s[i]))
            {
                int x=0;
                while(isdigit(s[i]))
                {
                    x=(x<<3)+(x<<1)+(s[i]-48);
                    i++;
                }
                i--;
                int y=0;
                if(s[i+1]=='a')
                {
                    i+=3;// a + ^ + num
                    while(isdigit(s[i]))
                    {
                        y=(y<<3)+(y<<1)+(s[i]-48);
                        i++;
                    }
                    i--;
                }
                if(!fg)
                {
                    n=max(n,y);
                    f[y].x=x;
                }
                else
                {
                    m=max(m,y);
                    g[y].x=x;
                }
            }
            else if(s[i]==')')
            {
                fg^=1;
                if(!fg) CalcWithFFT();
            }
        }
    }
    return 0;
}
```
核心实现思想：通过`getline`读入字符串，遍历字符串提取系数和指数存入`f`和`g`数组，利用FFT进行多项式乘法，最后输出结果。

  - 作者：徐致远 (赞：4)  星级：4星
    - 关键亮点：针对本题数据范围小的特点，直接采用$O(n^2)$暴力算法，代码简洁明了，易于理解，同时指出可能存在的空格及不完整表达式的处理要点。
    - 个人心得：无
    - 重点代码：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int len,a1[50],a2[50],ans[100];char exp[1000];
int main()
{
    while(gets(exp),exp[0])
    {
        len=strlen(exp);memset(a1,0,sizeof(a1));memset(a2,0,sizeof(a2));memset(ans,0,sizeof(ans));
        int i=1;
        while(exp[i]!=')'&&i<len)
        {
            int x=0,z=0;
            while(exp[i]<'0'||exp[i]>'9') i++;
            x=exp[i]-'0';
            if('0'<=exp[i+1]&&exp[i+1]<='9'){i++;x=x*10+exp[i]-'0';}
            i++;
            if(exp[i]=='a')
            {
                i++;i++;z=exp[i]-'0';
                if('0'<=exp[i+1]&&exp[i+1]<='9'){i++;z=z*10+exp[i]-'0';}
                i++;
            }
            a1[z]+=x;
        }
        i++;
        while(exp[i]!=')'&&i<len)
        {
            int x=0,z=0;
            while(exp[i]<'0'||exp[i]>'9') i++;
            x=exp[i]-'0';
            if('0'<=exp[i+1]&&exp[i+1]<='9'){i++;x=x*10+exp[i]-'0';}
            i++;
            if(exp[i]=='a')
            {
                i++;i++;z=exp[i]-'0';
                if('0'<=exp[i+1]&&exp[i+1]<='9'){i++;z=z*10+exp[i]-'0';}
                i++;
            }
            a2[z]+=x;
        }
        for(int i=0;i<=30;i++)
            for(int j=0;j<=30;j++)
                ans[i+j]+=a1[i]*a2[j];
        bool first=false;
        for(int j=60;j>=0;j--)
        {
            if(!ans[j]) continue;
            if(first) putchar('+');
            else first=true;
            if(j>0) printf("%da^%d",ans[j],j);
            else printf("%d",ans[j]);
        }
        putchar('\n');
        memset(exp,0,sizeof(exp));
    }
    return 0;
}
```
核心实现思想：利用`gets`读入字符串，分别提取两个多项式的系数和指数存入`a1`和`a2`数组，通过双重循环暴力计算多项式乘法，最后输出结果。

  - 作者：Xqbk (赞：0)  星级：4星
    - 关键亮点：同样针对数据范围小采用暴力模拟，代码注释详细，对字符串处理和多项式乘法的每一步都有清晰解释，便于初学者理解。
    - 个人心得：无
    - 重点代码：
```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
string s;
int x[40]; //乘号左侧多项式各项系数
int y[40]; //乘号右侧多项式各项系数
int a[100]; //答案
int f=0;
void work(string s)
{
    memset(x,0,sizeof(x));
    memset(y,0,sizeof(y));
    memset(a,0,sizeof(a));
    for(int i=0;i<s.length();i++)
    {
        if(s[i]=='('||s[i]=='+') //跳到某项
        {
            i++;
            int c=0,d=0;
            while(s[i]>='0'&&s[i]<='9') //输入系数
            {
                c*=10;
                c+=s[i]-'0';
                i++;
            }
            if(s[i]=='a') //没有a的话说明是常数，d=0
            {
                while(!(s[i]>='0'&&s[i]<='9'))i++; //跳到指数
                while(s[i]>='0'&&s[i]<='9') //输入指数
                {
                    d*=10;
                    d+=s[i]-'0';
                    i++;
                }
                i--;
            }
            if(!f)x[d]=c; //f表示乘号左右侧
            else y[d]=c;
        }
        if(s[i]=='*')f=1;
    }
    if(!f)
    {
        cout<<s<<endl;
        return;
    }
    for(int i=0;i<=30;i++) //相乘
    {
        for(int j=0;j<=30;j++)
        {
            a[i+j]+=x[i]*y[j];
        }
    }
    f=1;
    for(int i=60;i>0;i--) //输出
    {
        if(a[i]>0)
        {
            if(f)f=0;
            else cout<<"+";
            cout<<a[i]<<"a^"<<i;
        }
    }
    if(a[0]>0)
    {
        if(f)f=0;
        else cout<<"+";
        cout<<a[0];
    }
    cout<<endl;
    return;
}
int main()
{
    while(getline(cin,s))
    {
        work(s);
    }
    return 0;
}
```
核心实现思想：通过`getline`读入字符串，遍历字符串根据`*`号区分左右多项式，提取系数和指数存入`x`和`y`数组，暴力计算多项式乘法并输出结果。

• 最优关键思路或技巧：对于本题小数据范围，暴力算法简单直接且高效，通过仔细处理字符串输入，准确提取系数和指数进行多项式乘法计算。若数据范围增大，FFT或NTT算法可优化时间复杂度。字符串处理时，利用数字与字母的特征以及特定符号（如`*`、`a`、`^`）来提取系数和指数是关键技巧。

• 可拓展之处：同类型题可涉及多个多项式相乘、多项式的其他运算（如加法、减法、除法），或在更复杂的表达式中处理多项式。类似算法套路包括在处理符号表达式时，通过状态机或标志变量来区分不同部分，利用字符串的特征提取有效信息。

• 推荐题目：
  - [P1919 【模板】A*B Problem升级版（FFT快速傅里叶变换）](https://www.luogu.com.cn/problem/P1919)
  - [P3803 【模板】多项式乘法（FFT）](https://www.luogu.com.cn/problem/P3803)
  - [P4245 【模板】任意模数多项式乘法](https://www.luogu.com.cn/problem/P4245)

• 个人心得摘录与总结：
  - 作者Dispwnl提到因输入字符串中没有`*`时未处理好输出导致WA多次，最后通过添加判断解决问题。总结为处理输入时要严格按照题目要求，对特殊情况（如无乘法运算）进行正确处理。 

---
处理用时：78.83秒
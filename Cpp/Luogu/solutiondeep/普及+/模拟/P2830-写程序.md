# 题目信息

# 写程序

## 题目背景

zrz在写程序，他叫你帮他看看他的程序有没有问题。


## 题目描述

有一个若干行的程序，每一行只有一个命令，可能出现的命令有一下几种


int a[maxn]    声明一个数组，开头一定是int，不会是别的什么longlong之类的，a是指一个数组的名称（不一定是a，也有可能是别的字母或者多个字母，总之长度不超过10），后面是一个中括号和一个数字或一个变量，表示数组大小（从0到maxn-1，maxn<=100），数组声明之后里面的数均为0。




a[i] h  把h赋给a[i]（也就是a[i]=h），同样h可能是一个数字或者是一个变量，i代表一个数字或者是一个变量。


cout h 输出h，h一定是个变量。


## 说明/提示

行数不会太多的，变量可能嵌套，如 a[a[b[0]]]等等，也有可能出现大写字母，所有的出现的数字不会超过10^9，也不会是负数，更不会是小数。


## 样例 #1

### 输入

```
int a[10]
a[a[0]] 2
cout a[0]```

### 输出

```
2```

## 样例 #2

### 输入

```
int a[10]
a[0] 10
cout a[0]
a[a[0]] 1
cout a[0]```

### 输出

```
10
-1```

# AI分析结果

这道题要求模拟一个简单程序的执行，涉及数组声明、赋值和输出操作，且变量可能嵌套，需处理数组越界情况。各题解思路和方法基本围绕如何存储变量、处理嵌套及判断越界展开。
1. **思路与要点**
    - **存储变量**：多数题解使用`map<string, vector<int>>`或`map<string, map<int, int>>`来存储数组信息，将数组名与数组内容或大小建立映射关系；部分使用`struct`封装相关操作。
    - **处理嵌套**：主要有递归和分割字符串两种方式。递归方式通过不断深入解析字符串，直到获取到常量下标；分割字符串方式则是从左括号处分割，倒序求值。
    - **判断越界**：在访问数组元素时，检查下标是否在合法范围内，若越界则输出`-1`并终止程序。
2. **题解评分**
    - **1124828077ccj**：思路清晰，通过递归判断变量嵌套合法性，但代码中变量命名不够直观，整体可读性稍弱。评分：3星。
    - **Exschawasion**：详细分析题目要素，利用`map`和`struct`封装操作，代码结构清晰，对嵌套处理解释详细。评分：4星。
    - **AIH_NUI233**：使用`map<string, vector<int>>`存储数组，代码实现较为基础，部分代码重复较多，可读性一般。评分：3星。
    - **LIXE_115**：通过两个`map`分别存储数组值和大小，采用从右向左扫描字符串处理嵌套，思路独特但代码稍复杂。评分：3星。
    - **_Spectator_**：利用`struct`和`map`存储数组，通过递归展开嵌套数组，代码简洁，注释详细，对关键操作解释清晰。评分：4星。
    - **Raymondzll**：用`map<string, vector<int>>`存储数组，通过自定义函数处理字符串和解析表达式，代码简洁高效。评分：4星。
    - **huangx607087**：详细介绍了`substr`函数及字符串操作，使用`map`存储数组信息，代码实现过程较详细但稍冗长。评分：3星。
    - **FJ_OIer**：使用`map<string, vector<int>>`存储数组，通过递归函数处理变量嵌套并检验合法性，代码逻辑清晰。评分：4星。
    - **Argon_Cube**：提出用`vector`的`at`函数结合`try-catch`处理越界，使用`unordered_map`提高效率，代码量小但部分实现较玄学。评分：3星。
    - **七碳烷烃**：自定义`Array`结构体结合`map`存储数组，通过递归解析表达式，利用`try-catch`处理异常，代码结构完整。评分：3星。
    - **Alarm5854**：使用`map`存储数组名与编号，`vector`存储数组，通过自定义函数处理嵌套和越界，代码实现较常规。评分：3星。
    - **jqQt0220**：使用`map`和自定义`arr`结构体存储数组，通过递归和字符串处理找变量值，代码逻辑较清晰但细节较多。评分：3星。
    - **huangzhixia**：思路与其他题解类似，使用`map`存储数组信息，通过自定义函数处理嵌套和操作，代码注释较少。评分：3星。
    - **_zuoqingyuan_**：利用结构体和`map`存储数组，通过统一函数求变量和常量值，在递归中处理越界，代码简洁明了。评分：3星。
    - **HowardWang**：使用`map`模拟数组，通过递归处理嵌套数组值，利用全局`flag`判断越界，代码逻辑清晰但稍冗长。评分：3星。
    - **xujingyu**：使用`map`和二维数组存储数组信息，通过递归处理嵌套和越界，代码实现较常规。评分：3星。
    - **allqpsi**：使用`map`存储数组，通过递归访问输入处理嵌套，在递归中检查越界，代码实现较详细。评分：3星。
    - **nvqlfi214**：分析了题目操作，提出用结构体存储数组，通过类似题目思路处理变量嵌套，但未给出完整代码。评分：2星。
    - **Mine_King**：使用`map`和结构体存储数组，通过递归处理变量下标，将操作封装在函数中，代码结构较清晰。评分：3星。
3. **优质题解**
    - **Exschawasion**：
        - **星级**：4星
        - **关键亮点**：详细分析题目要素，利用`map`和`struct`封装变量操作，对处理嵌套的方法解释细致，代码结构清晰。
        - **个人心得**：无
        - **核心代码**：
```cpp
//A struct that holds variables.
struct Binding {
    map<string, vector<int> > vars;

    //Check the sub return true if it is vaild.
    bool CheckAccess(string name, int loc) {
        if(loc < 0) return false;
        else if(loc >= vars[name].size()) return false;
        return true;
    }

    //Security holder, throw exceptions when accesses are invaild.
    void Security(string name, int loc) {
        if(!CheckAccess(name, loc)) ThrowException(); 
    }

    //Get the values.
    int GetVal(string name, int loc) {
        Security(name, loc);
        return vars[name][loc];
    }

    //Set the values.
    void SetVal(string name, int loc, int value) {
        Security(name, loc);
        vars[name][loc] = value;
    }

    //Make an array with given size and name.
    void MakeArray(string name, int size) {
        vars[name].resize(size);
    }
};

Binding bind;

//Get the value of expression.
int EvalExpression(string expr) {
    vector<string> names;
    int last = 0;

    if(isdigit(expr[0])) return atoi(expr.c_str());

    //Split the given expression to tokens.
    for(int i = 0; i < expr.length(); i++) {
        if(expr[i] == '[') {
            names.push_back(expr.substr(last, i - last));
            last = i + 1;
        }
        if(expr[i] == ']') {
            names.push_back(expr.substr(last, i - last));
            break;
        }
    }

    //Get the each value.
    int lastVal = atoi(names[names.size() - 1].c_str());
    for(int i = names.size() - 2; i >= 0; i--) {
        lastVal = bind.GetVal(names[i], lastVal); 
    }

    return lastVal;
}

//Run the command.
void Command(string command) {
    stringstream ss(command);
    vector<string> str;
    string s;
    while(ss >> s) str.push_back(s);

    if(str[0] == "int") {
        string token = str[1];
        string locs;
        string name;
        for(int i = 0; i < str[1].length(); i++) {
            if(str[1][i] == '[') {
                name = str[1].substr(0, i);
                locs = str[1].substr(i + 1, str[1].length() - i - 2);
                break;
            }
        }
        bind.MakeArray(name, EvalExpression(locs));
    }
    else if(str[0] == "cout") {
        cout << EvalExpression(str[1]) << endl;
    }
    else {
        string token = str[0];
        string locs;
        string name;
        for(int i = 0; i < str[0].length(); i++) {
            if(str[0][i] == '[') {
                name = str[0].substr(0, i);
                locs = str[0].substr(i + 1, str[0].length() - i - 2);
                break;
            }
        }
        bind.SetVal(name, EvalExpression(locs), EvalExpression(str[1]));
    }
}
```
        - **核心思想**：定义`Binding`结构体封装变量操作，`EvalExpression`函数通过分割字符串处理嵌套表达式，`Command`函数根据不同命令调用相应操作。
    - **_Spectator_**：
        - **星级**：4星
        - **关键亮点**：利用`struct`和`map`存储数组，通过递归实现嵌套数组展开，代码简洁，注释详细。
        - **个人心得**：无
        - **核心代码**：
```cpp
struct stu//使用结构体和map控制数组 
{   
    int size,a[100];
    int& operator[](int p)//重载下标运算符方便访问，同时判断越界问题 
    {   
        if(p>=size)cout<<-1,exit(0);//exit(0)可以直接终止程序 
        return a[p];
    }    
};    
map<string,stu>arr;
int s2i(string st)//将字符串转化为整形数字 
{   
    int ans=0;
    for(int i=0;i<st.size();i++)
        ans=ans*10+st[i]-48;
    return ans;
}    
int& calc(string st)//拆解嵌套数组，返回地址既方便直接赋值又可以作数值参与运算 
{   
    string name,num;int i;
    for(i=0;st[i]!='[';i++)name+=st[i];//将数组名称提取出来 
    for(i++;i<st.size()-1;i++)num+=st[i];//将数组的下标提取出来 
    if(isdigit(num[0]))return arr[name][s2i(num)];//如果下标为纯数字，直接返回 
    else return arr[name][calc(num)];//否则递归继续拆解 
}    
int main()
{   
    ios::sync_with_stdio(false);
    while(cin>>st1>>st2)
    {   
        if(st1=="int")//定义，与calc函数相似，不展开说明 
        {   
            string name,num;int i;
            for(i=0;st2[i]!='[';i++)name+=st2[i];
            for(i++;i<st2.size()-1;i++)num+=st2[i];
            if(isdigit(num[0]))arr[name].size=s2i(num);
            else arr[name].size=calc(num);
        }   
        else if(st1=="cout")//输出，题目保证输出一定是变量就不用分开判断了 
            cout<<calc(st2)<<endl;
        else //赋值，要分开纯数字与变量分开判断 
            if(isdigit(st2[0]))calc(st1)=s2i(st2);    
            else calc(st1)=calc(st2);    
    }   
    return 0;
}
```
        - **核心思想**：定义`stu`结构体结合`map`存储数组，`calc`函数通过递归拆解嵌套数组，根据不同命令进行相应操作。
    - **Raymondzll**：
        - **星级**：4星
        - **关键亮点**：用`map<string, vector<int>>`存储数组，通过自定义函数处理字符串和解析表达式，代码简洁高效。
        - **个人心得**：无
        - **核心代码**：
```cpp
void getson(string s,string& s1,string& s2){
    int i; 
    for(i=0;i<s.size();i++){
        if(s[i]=='[')break;
        else s1+=s[i];
    }
    i++;//跳过[
    for(;i<s.size()-1;i++)s2+=s[i];
}
int toint(string s){
    int res=0;
    for(int i=0;i<s.size();i++){
        res=res*10+s[i]-'0';
        if(res>1000000000)return -1;
    }
    return res;
}
int expl(string s){
    string tmp="",tmp2="";
    getson(s,tmp,tmp2);
    if(tmp2=="")return toint(s);//整个字符串都是数字
    int tmpp=expl(tmp2);//递归调用
    if(tmpp<0||tmpp>=mp[tmp].size())bad();
    return mp[tmp][tmpp];
}
int main(){
    while(cin>>a){
        cin>>b;
        if(a=="int"){
            string tmp="",tmp2="";
            getson(b,tmp,tmp2);
            int tmpp=expl(tmp2);
            mp[tmp]=vector<int>(tmpp);
        }else if(a=="cout"){
            cout<<expl(b)<<endl;
        }else{
            int k=expl(b);
            string tmp="",tmp2="";
            getson(a,tmp,tmp2);
            int tmpp=expl(tmp2);
            if(tmpp>=mp[tmp].size())bad();
            mp[tmp][tmpp]=k;
        }
    }
    return 0;
}
```
        - **核心思想**：`getson`函数分割字符串，`toint`函数转换字符串为数字，`expl`函数递归解析表达式，`main`函数根据不同命令调用相应函数操作数组。
4. **最优思路技巧**
    - **数据结构选择**：使用`map`来存储数组信息，能够方便地通过字符串类型的数组名访问和操作数组，是解决本题的关键数据结构。
    - **递归处理嵌套**：对于变量嵌套的处理，递归方式简洁有效，通过不断深入解析字符串获取最终的常量下标，从而实现对嵌套数组的操作。
5. **拓展思路**
    - **同类型题**：此类题目通常围绕对特定语法规则的模拟，可拓展到更复杂的编程语言语法模拟，如增加函数定义、条件语句等。
    - **类似算法套路**：在处理具有层次结构的数据或操作时，递归是常用的方法；同时，合理选择数据结构来存储和管理数据，能大大简化操作过程。
6. **相似题目**
    - **P1036 [NOIP2002 普及组] 选数**：涉及对数据的筛选和组合，可类比本题对不同操作的处理和组合。
    - **P1161 开灯**：通过模拟开关灯的操作，与本题模拟程序命令执行类似。
    - **P1909 [NOIP2016 普及组] 买铅笔**：根据不同条件进行计算和选择，与本题根据不同命令进行相应操作思路相似。
7. **个人心得摘录**
    - **AIH_NUI233**：踩了很多坑，如读题不仔细，未考虑到各处数值为变量的情况，导致多次提交错误。总结了注意点，包括使用`while(cin>>s)`、处理`int`语句数组大小为变量及循环嵌套、赋值语句值为变量等情况，以及检查`-1`判定等。
    - **LIXE_115**：调了很久，把所有坑踩了一遍，主要是对题目细节处理不当，如变量嵌套和数组越界的情况。
    - **huangx607087**：花了3个小时，提交17次，主要在理解和处理题目细节上遇到困难，通过学习`substr`函数及字符串操作，结合`map`完成题目。 

---
处理用时：110.89秒
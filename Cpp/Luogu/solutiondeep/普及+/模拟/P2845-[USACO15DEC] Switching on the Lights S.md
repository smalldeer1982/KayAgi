# 题目信息

# [USACO15DEC] Switching on the Lights S

## 题目背景

来源：usaco-2015-dec

Farm John 最近新建了一批巨大的牛棚。这些牛棚构成了一个 $N \times N$ 的矩形网络 $(1 < N < 100)$。

然而 Bessie 十分怕黑，他想计算可以把多少个牛棚的灯打开。

## 题目描述

有 $N \times N$ 个房间，组成了一张 $N \times N$ 的网格图，Bessie 一开始位于左上角 $(1,1)$，并且只能上下左右行走。


一开始，只有 $(1,1)$ 这个房间的灯是亮着的，Bessie 只能在亮着灯的房间里活动。


有另外 $M$ 条信息，每条信息包含四个数 $a,b,c,d$，表示房间 $(a,b)$ 里有房间 $(c,d)$ 的灯的开关。


请计算出最多有多少个房间的灯可以被打开。

## 说明/提示

Bessie 可以使用 $(1,1)$ 的开关打开 $(1,2),(1,3)$ 的灯，然后走到 $(1,3)$ 并打开 $(2,1)$ 的灯，走到 $(2,1)$ 并打开 $(2,2)$ 的灯。$(2,3)$ 的开关无法到达。因此可以点亮 $5$ 个房间。

## 样例 #1

### 输入

```
3 6
1 1 1 2
2 1 2 2
1 1 1 3
2 3 3 1
1 3 1 2
1 3 2 1
```

### 输出

```
5```

# AI分析结果

这道题主要是在一个 $N \times N$ 的网格图中，从初始亮灯的 $(1, 1)$ 房间出发，依据给定的开关信息，通过搜索算法找出最多能打开灯的房间数量。各题解思路、要点及难点解决方式如下：
1. **vani_prcups**：使用深度优先搜索（DFS）。用二维邻接表存储开关信息，visited数组标记访问过的点，b数组标记灯已打开的点。当点亮一间房时，若其旁边有已到达点，直接DFS该点亮房间。
2. **BoAn**：采用DFS，从 $(1, 1)$ 房间开始搜索，打开当前房间能开的灯后继续搜。针对可能出现漏开灯的情况，通过反复DFS且不清零mark数组，比较本次与上次结果，不同则更新并继续DFS。
3. **JMercury**：类似SPFA思想的广度优先搜索（BFS）。将可达点按顺序加入队列，每次对队首点进行操作：一是将其四周可达且灯开的点入队；二是打开其管理房间的灯，若该房间四周有可达房间，则将其入队。
4. **bobxie**：BFS思路。在房间间连边，定义若房间 $(x1, y1)$ 有房间 $(x2, y2)$ 的开关，则连一条从 $(x1, y1)$ 指向 $(x2, y2)$ 的边。BFS时，正常上下左右遍历后，将该点能连到且未访问的点加入队列。
5. **chenxuanting**：BFS算法。用vector存储房间能开的灯，vis数组判断访问状态，light数组判断灯的状态（0未开，1开且访问过，2开但未访问）。通过判断开灯房间周围是否有访问过的房间，决定该开灯房间是否可访问及能否打开其他灯。
6. **WCG2025**：BFS结合哈希处理。运用链式前向星思想存储映射关系，广搜遍历并判断开灯房间能否遍历到，从而更新可到达房间及开灯房间数量。
7. **zylll**：使用BFS，用二维vector + pair储存开关信息。对队列中的点，若其周围有已点亮但未入队的点，则将其入队；尝试扩充该点，若点亮其他灯，统计答案，并判断新点亮灯的房间周围是否有已点亮灯，有则入队。
8. **XG_Zepto**：改进的BFS。将可访问和点亮的房间入队，对队首元素，若其相邻房间被标记可访问，则将其也标记；寻找队首可点亮的未点亮、未标记可访问的房间，入队、点亮并更新答案；将与队首相邻但未标记可访问、已点亮的房间入队并标记。
9. **Twilight_**：使用三条队列的BFS。q记录灯已打开且能到达的房间，常规BFS；q1记录能到达但灯未打开的房间；q2作为临时容器。遍历完q后遍历q1，能进队的进队，不能进队的存于q2再塞回q1。
10. **dph754132771**：加补丁的BFS。BFS节点入列，将未开灯房间视为墙，开了灯的视为路。每次开灯时，搜索开灯房间四个方向上是否有可行房间，解决因房间开灯时间不同导致的漏搜问题。
11. **LDlornd**：优化的BFS。通过记录打开灯却不能走到的房间，下次仅在该队列搜索，保证每个开灯房间只访问一次；搜索终止条件为队列中的房间都不能走到；采用降维优化，将二维地图映射为一维，并添加特判避免跨行。
12. **xun薰**：裸搜索结合“骗分”思想，不及时删除队列元素，多遍遍历图以期望遍历到所有可开灯房间。
13. **Dirt、**：BFS算法。用 $canv[i][j]$ 表示点 $(i, j)$ 是否可到达，对当前队头，其周围点一定可到达；灯打开时，若该位置可到达则入队。
14. **lshhhhhh**：通过简单逻辑判断，若一个房间灯亮且可走到，则其旁边房间可走到；若一个房间灯亮且可走到，则其内部灯可打开，反复循环直到无新灯打开，统计亮灯房间数。

综合各题解的思路清晰度、代码可读性、优化程度等方面进行评分：
 - **vani_prcups**：4星。关键亮点在于使用DFS并结合二维邻接表优化存储，能有效处理开关信息，代码简洁明了。个人心得无。
 - **JMercury**：4星。关键亮点是类似SPFA的BFS思路，清晰地将点的扩展和灯的控制操作分开，逻辑清晰，代码易读。个人心得无。
 - **LDlornd**：4星。关键亮点在于对BFS的优化，通过记录特定房间避免重复搜索，采用降维操作提高效率，同时详细阐述了优化思路。个人心得：调了两三天才AC，分享了优化搜索过程及确定搜索终止条件的思考过程。

**vani_prcups题解核心代码**：
```cpp
void dfs(int x, int y) {
    if (x < 1 || x > n || y < 1 || y > n) return;
    v[x][y] = 1;
    for (int i = head[x][y]; i!= 0; i = a[i].nt)
        if (b[a[i].tx][a[i].ty] == 0) {
            b[a[i].tx][a[i].ty] = 1;
            c++;
            if (v[a[i].tx + 1][a[i].ty] == 1 || v[a[i].tx][a[i].ty + 1] == 1 || v[a[i].tx - 1][a[i].ty] == 1 || v[a[i].tx][a[i].ty - 1] == 1)
                dfs(a[i].tx, a[i].ty);
        }
    if (v[x + 1][y] == 0 && b[x + 1][y] == 1) dfs(x + 1, y);
    if (v[x][y + 1] == 0 && b[x][y + 1] == 1) dfs(x, y + 1);
    if (v[x - 1][y] == 0 && b[x - 1][y] == 1) dfs(x - 1, y);
    if (v[x][y - 1] == 0 && b[x][y - 1] == 1) dfs(x, y - 1);
}
```
核心实现思想：递归进行深度优先搜索，标记当前访问点，遍历当前点的邻接表，若邻接表中的点灯未开，则开灯并判断其周围是否有已访问点，有则递归搜索该点；同时向当前点的上下左右四个方向继续搜索，若方向上的点灯开且未访问，则递归搜索。

**JMercury题解核心代码**：
```cpp
void spfa() {
    queue<P> q; q.push((P){1, 1}); vis[1][1] = true; MAP[1][1] = true; ans++;
    while (!q.empty()) {
        P u = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            int vx = u.x + dx[i], vy = u.y + dy[i];
            if (!Inside(vx, vy) || vis[vx][vy]) continue;
            if (MAP[vx][vy]) q.push((P){vx, vy}), vis[vx][vy] = true;
        }
        for (int i = 0; i < Lamp[u.x][u.y].size(); i++) {
            P v = Lamp[u.x][u.y][i];
            if (vis[v.x][v.y] || MAP[v.x][v.y]) continue;
            MAP[v.x][v.y] = true; ans++;
            for (int i = 0; i < 4; i++)
                if (vis[v.x + dx[i]][v.y + dy[i]]) {
                    q.push((P){v.x, v.y}), vis[v.x][v.y] = true;
                    break;
                }
        }
    }
}
```
核心实现思想：使用队列进行广度优先搜索，初始化起点入队并标记已访问和灯已开。每次取出队首元素，向其四个方向扩展，若扩展点在图内、未访问且灯开，则将其入队；遍历队首元素管理的房间，若该房间未访问且灯未开，则开灯并判断其周围是否有已访问房间，有则将该房间入队。

**LDlornd题解核心代码**：
```cpp
inline void bfs() {
    bool flag = false;
    head2 = tail2 = 1;
    while (head1 < tail1) {
        int nv = dl1[head1++]; indl[nv] = 0;
        if (check(nv) == false && vis[nv] == false) {
            dl2[tail2++] = nv;
            continue;
        }
        vis[nv] = true; flag = true;
        for (edge *p = con[nv]; p; p = p->NEXT) {
            int vv = p->v;
            if (light_up[vv] == false) {
                light_up[vv] = true; ++ans;
            }
            if (check(vv))
                if (indl[vv] == 0 && vis[vv] == false) {
                    dl1[tail1++]=vv; indl[vv]=1;
                }
                else continue;
            else if (indl[vv] == 0 && vis[vv] == false) {
                dl2[tail2++]=vv; indl[vv]=2;
            }
        }
    }
    if (flag) {
        for (int i = head2; i <= tail2; i++)
            dl1[i] = dl2[i];
        head1 = head2; tail1 = tail2;
        bfs();
    }
}
```
核心实现思想：通过两个队列实现优化的BFS。一个队列用于常规BFS遍历，另一个队列记录打开灯但当前不可到达的房间。每次从遍历队列取出元素，判断其是否可到达，不可到达则放入记录队列；可到达则标记访问，遍历其可打开灯的房间，开灯并根据房间是否可到达决定放入哪个队列。若本次遍历有房间可到达，则将记录队列覆盖遍历队列，继续进行BFS。

**最优关键思路或技巧**：
 - **数据结构方面**：使用邻接表（如二维邻接表、链式前向星等）或vector存储开关信息，能有效降低查找开关的时间复杂度，提高效率。
 - **算法优化方面**：部分题解通过记录特定状态的房间（如打开灯但未到达的房间），避免重复搜索，减少搜索空间；还有题解采用降维操作，将二维地图转换为一维，在一定程度上提高运算速度。
 - **思维方式方面**：在搜索过程中，充分考虑房间开灯状态与可到达性之间的关系，通过合理的条件判断和处理，保证搜索的完整性，避免遗漏可能打开的灯。

**可拓展之处**：此类题目属于图的搜索与状态更新问题，类似套路可应用于其他具有类似条件限制的迷宫、路径搜索等问题。例如，在一些地图中，某些区域需要满足特定条件（如收集特定道具、触发特定事件等）才能进入，可类比本题思路，通过记录状态、合理搜索来解决。

**推荐相似知识点洛谷题目**：
 - **P1332 血色先锋队**：同样涉及在一定限制条件下的地图搜索，需要根据特定规则更新状态并寻找最优路径或数量。
 - **P1141 01迷宫**：通过搜索不同区域，根据相邻区域状态进行判断和操作，与本题在搜索与状态判断上有相似之处。
 - **P2736 [USACO3.3] 骑马修栅栏 Riding the Fences**：需要在图中按照一定规则遍历路径，与本题通过搜索解决地图相关问题的思路类似。

**个人心得摘录与总结**：
 - **LDlornd**：调了两三天才AC。最初思路是不断对原图BFS，碰到房间就打开其能开的灯，直到某次搜索没打开任何灯为止，但这样会TLE。之后优化搜索过程，通过记录打开灯却不能走到的房间，保证每个开灯房间只访问一次；同时修正搜索终止条件，应为队列中的房间都不能走到；还采用降维优化。总结了优化BFS算法的思考过程及遇到的问题和解决方法。 

---
处理用时：118.76秒
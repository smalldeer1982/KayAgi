# 题目信息

# [USACO07JAN] Tallest Cow S

## 题目描述

FarmerJohn 有n头牛，它们按顺序排成一列。FarmerJohn 只知道其中最高的奶牛的序号及它的高度，其他奶牛的高度都是未知的。现在 FarmerJohn 手上有 $R$ 条信息，每条信息上有两头奶牛的序号（$a$ 和 $b$），其中 $b$ 奶牛的高度一定大于等于 $a$ 奶牛的高度，且 $a, b$之间的所有奶牛的高度都比 $a$ 小。现在 FarmerJohn 想让你根据这些信息求出每一头奶牛的可能的最大的高度。（数据保证有解）

## 说明/提示

$1 \le n \le 10000$，$1 \le h \le 1000000$，$0 \le R \le 10000$

Translate provided by @酥皮

## 样例 #1

### 输入

```
9 3 5 5
1 3
5 3
4 3
3 7
9 8```

### 输出

```
5
4
5
3
4
4
5
5
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何根据给定的奶牛高度关系信息，求出每头奶牛可能的最大高度。思路可分为以下几类：
1. **暴力模拟**：初始化所有奶牛高度为最高值，遍历每对关系，将中间奶牛高度减1。此方法简单直接，但时间复杂度高，如作者Teddy_Di的题解。
2. **差分优化**：利用差分思想，将区间操作转化为端点操作，通过前缀和得到最终结果，同时使用map等方式判重，优化了时间复杂度，多位作者采用此思路，如追梦_Chen、小年轻w等。
3. **拓扑排序与线段树优化**：通过建图和拓扑排序求解，因直接建边边数过多，利用线段树优化建边，如作者suxxsfe的题解。

整体来看，差分优化的方法更为常用和高效，多数题解在代码实现上都注意到了数据去重以避免重复操作。

### 所选4星及以上题解
1. **追梦_Chen（4星）**
    - **关键亮点**：清晰解释了差分数组的原理及应用，通过将区间操作转化为对两个端点的操作，利用前缀和得到每头牛的高度，同时巧妙运用map进行判重，代码简洁明了，思路清晰。
    - **核心代码**：
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <map>	
#include <utility>
using namespace std;
int d[100005];      			 //牛
int n,l,h,r;
int x,y;
map<pair<int,int>,bool>book;   //由两个Int类型的映射bool数组

int main(){
    scanf("%d%d%d%d",&n,&l,&h,&r);
    for(int i=1;i<=r;i++){
        scanf("%d%d",&x,&y);    
        if(x>y)  swap(x,y);   //当x>y时记得交换
        if(book[make_pair(x,y)])    continue;  //判重
        d[x+1]--;   //前缀和操作
        d[y]++;    
        book[make_pair(x,y)]=true;
    }
    for(int i=1;i<=n;i++){
        d[i]=d[i-1]+d[i];            
        printf("%d\n",h+d[i]);
    }
    return 0;
}
```
    - **核心思想**：定义数组d表示相邻奶牛高度差，读入每对奶牛关系(x, y)，若未处理过则对x + 1处减1，y处加1，最后通过前缀和计算每头奶牛相对于最高奶牛高度的差值，加上初始高度h得到每头奶牛高度。
2. **小年轻w（4星）**
    - **关键亮点**：将问题类比为括号序列，形象地阐述了差分操作的逻辑，同样使用map判重，代码实现简洁，对差分的理解独特且易于理解。
    - **核心代码**：
```cpp
#include <stdio.h>
#include <algorithm>
#include <map>
using namespace std;
const int maxn = 100001 ;
map<int,int> mp[maxn] ;
int n,m,id,h,x,y ;
int f[maxn] ;
int main()
{
    scanf("%d%d%d%d",&n,&id,&h,&m ) ;
    for(int i=1;i<=m;i++) 
    {
        scanf("%d%d",&x,&y) ;
        if(x>y) swap(x,y) ; 
        if(mp[x][y]) continue ;
            else mp[x][y]=1 ;
        f[x+1]--;   f[y]++;
    }
    for(int i=1;i<=n;i++) 
    {
        f[i] = f[i]+f[i-1] ;
        printf("%d\n",f[i]+h) ;
    }
    return 0;
}
```
    - **核心思想**：用f数组记录每头牛的操作，对于每对可对视奶牛(x, y)，在x + 1处减1，y处加1，最后通过前缀和得到每头奶牛相对于最高奶牛高度的变化量，加上h得到最终高度。
3. **maple_tzc（4星）**
    - **关键亮点**：详细说明了数组c和d的含义及作用，利用前缀和优化区间操作，代码逻辑清晰，对差分优化的解释到位，参考资料也为读者提供了进一步学习的方向。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int c[10010],d[10010];
map<pair<int,int>,bool> eee;
int main(){
	int n,p,h,m;
	scanf("%d%d%d%d",&n,&p,&h,&m);
	for (int i=1; i<=m; i++){
		int a,b;
		scanf("%d%d",&a,&b);
		if(a>b) swap(a,b);
		if (eee[make_pair(a,b)]) continue;
		d[a+1]--,d[b]++;
		eee[make_pair(a,b)]=true;
	}
	for (int i=1; i<=n; i++){
		c[i]=c[i-1]+d[i];
		printf("%d\n",h+c[i]);
	}
	cout<<endl;
	return 0;
}
```
    - **核心思想**：数组d用于记录每对奶牛关系对区间的操作，通过对a + 1处减1，b处加1，再利用数组c计算前缀和得到每头奶牛相对于最高奶牛高度的变化，加上h得到每头奶牛的高度。

### 最优关键思路或技巧
差分优化是本题的关键思路，通过将区间操作转化为端点操作，大大降低了时间复杂度。同时，使用map、set等数据结构进行判重，避免重复处理相同关系，也是优化算法的重要技巧。

### 可拓展之处
此类题目属于区间关系处理问题，类似套路可应用于其他涉及区间增减操作、偏序关系求解等问题。例如在一些统计区间覆盖次数、根据区间关系求最值等场景中，差分和前缀和的方法都可能适用。

### 相似知识点洛谷题目
1. **P1972 [SDOI2009]HH的项链**：涉及区间查询和去重操作，可通过类似的前缀和思想优化。
2. **P3374 【模板】树状数组 1**：树状数组是一种特殊的前缀和结构，用于高效处理区间查询和单点修改，与本题差分优化思路相关。
3. **P1115 最大子段和**：通过前缀和与动态规划思想求解最大子段和，与本题利用前缀和处理区间信息有相似之处。

### 个人心得摘录
暂无。 

---
处理用时：58.16秒
# 题目信息

# 松江 1843 路

## 题目描述

涞坊路是一条长 $L$ 米的道路，道路上的坐标范围从 $0$ 到 $L$，路上有 $N$ 座房子，第 $i$ 座房子建在坐标为 $x_i$ 的地方，其中住了 $r_i$ 人。

松江 1843 路公交车要在这条路上建一个公交站，市政府希望让最多的人得到方便，因此希望所有的每一个的居民，从家到车站的距离的**总和**最短。

公交站应该建在哪里呢？

## 说明/提示

### 样例解释 1

当建在坐标 $40$ 的时候，所有人距离车站的距离总和为 $|20-40| \times 3+|50-40| \times 2+|70-40| \times 1=110$。

### 数据范围和约定

对于 $10\% $的数据，$1\le N \le 50$，$R_i=1$。

对于 $30\%$ 的数据，$1 \le N \le 100$，$R_i \le 10$，$1 \le L \le 1000$。

对于 $70\%$ 的数据，$1 \le N \le 1000$，$R_i \le 100$，$1 \le L \le 10^6$。

对于全部数据，$1 \le L \le 10^{10}$，$1 \le N \le 10^5$，$0 \le x_i \le L$，$1 \le r_i \le 1000$。

## 样例 #1

### 输入

```
100 3
20 3
50 2
70 1
```

### 输出

```
110
```

## 样例 #2

### 输入

```
100 2
0 1
100 10
```

### 输出

```
100
```

## 样例 #3

### 输入

```
10000000000 5
3282894320 391
4394338332 929
6932893249 181
7823822843 440
9322388365 623
```

### 输出

```
5473201404068
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何找到使居民到公交站距离总和最短的位置展开，涉及多种思路和算法：
1. **中位数法**：多数题解通过证明或分析得出公交站应建在居民点上，且与中位数相关。将问题转化为求带权中位数，通过排序和统计人数找到中位数对应的居民点，计算距离总和。如作者BlueArc、MSM2004等。
2. **模拟法**：作者_Lemon_通过模拟逐步更新车站位置，每次比较两端房屋人数，将人数少的那间清空，指针更新，直到只剩一间房屋有人。
3. **函数法**：作者hanzhongtlx将距离和表示为分段函数，通过分析斜率和截距的变化规律，利用前缀和优化，$O(n)$计算每个区间的最值。
4. **换根DP + 贪心**：作者Z_M__把道路看作树，贪心认为公交站建在房子坐标处有最优解，通过换根思想预处理和转移计算每个房子作为公交站时的距离和。
5. **模拟退火**：作者Forgive_Me通过模拟退火算法，以一定概率接受较差解，逐步逼近最优解。
6. **暴力枚举与优化**：部分作者先暴力枚举所有点或一定范围内的点计算距离和找最优解，如Celebrate；有的通过前缀和优化减少计算量，如BFSDFS123。还有通过三分查找函数最小值，如lin_rany和s_a_b_e_r，但该函数并非严格二次函数，三分不一定准确。

多数题解思路围绕中位数展开，部分题解在优化和证明上有独特之处。综合来看，中位数法相对简洁高效，是解决本题的关键思路。

### 所选的题解
1. **作者：BlueArc（4星）**
    - **关键亮点**：思路清晰，先将问题转化为常见的数轴上找距离和最小点问题，通过直观的画图分析证明最优点为中位数，代码实现简洁明了，先给出朴素做法，再针对大数据量优化找到中位数。
    - **重点代码核心思想**：先读入数据并将每个房子的人数展开为多个相同点存入数组，排序后找到中位数，计算所有点到中位数的距离和。优化后，通过结构体存储房子坐标和人数，排序后累加人数找到中位数所在房子，计算总距离。
    ```cpp
    #include"cstdio"
    #include"iostream"
    #include"algorithm"
    using namespace std;
    typedef long long ll;
    struct People
    {
        ll x,r;
        bool operator <(const People& a) const{
            return x<a.x;
        }
    }a[100005];
    int main()
    {
        ll len,n,tot=0;
        cin>>len>>n;
        for(int i=1;i<=n;i++)
        {
            cin>>a[i].x>>a[i].r;
            tot+=a[i].r;
        }
        tot=(tot+1)/2;
        sort(a+1,a+n+1);
        ll sum=0,mid,ans=0;
        for(int i=1;i<=n;i++)
        {
            sum+=a[i].r;
            if(sum>=tot) {mid=i;break;}
        }
        for(int i=1;i<=n;i++)
        {
            ans=ans+abs(a[i].x-a[mid].x)*a[i].r;
        }
        cout<<ans;
        return 0;
    }
    ```
2. **作者：MSM2004（4星）**
    - **关键亮点**：快速抓住问题本质，类比初中奥数求多个绝对值和最小值问题，直接得出本题需找中位数，代码简洁，逻辑连贯。
    - **重点代码核心思想**：定义结构体存储房子坐标和人数，读入数据并累加总人数，排序后通过循环找到中位数对应下标，计算所有房子到该中位数房子的距离和。
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    const int M=1e5+100;
    struct f
    {
        long long x;
        int r;
    }s[M];
    bool comp(const f &a,const f &b)
    {
        return a.x<b.x;
    }
    int main()
    {
        long long m;
        long long ans=0,sum=0;
        int n;
        cin>>m>>n;
        for(int i=1;i<=n;i++)
        {
            cin>>s[i].x>>s[i].r;
            ans+=s[i].r;
        }
        sort(s+1,s+n+1,comp);
        long long mid=ans/2;
        int j=1;
        while(mid>0)
        {
            mid-=s[j].r;
            j++;
        }
        j--;
        long long k=s[j].x;
        for(int i=1;i<=n;i++)
            sum+=abs(s[i].x-k)*s[i].r;
        cout<<sum;
        return 0;
    }
    ```
3. **作者：hanzhongtlx（4星）**
    - **关键亮点**：从函数角度出发，将距离和表示成分段函数，详细分析斜率和截距变化规律，利用前缀和优化到$O(n)$时间复杂度，同时还证明了中位数做法的正确性。
    - **重点代码核心思想**：定义结构体存储房子信息，读入数据并排序，先初始化斜率和截距，通过循环利用前缀和更新斜率和截距，计算每个区间端点的函数值并取最小值。
    ```cpp
    #include<iostream>
    #include<cstdio>
    #include<cmath>
    #include<algorithm>
    using namespace std;
    long long n,m;
    struct node
    {
        long long x,r;
    }e[500005];
    long long ans,b,k;
    bool cmp(node n,node m)
    {
        return n.x<m.x;
    }
    int main()
    {
        scanf("%lld%lld",&n,&m);
        for(int i=1;i<=m;i++)
        {
            scanf("%lld%lld",&e[i].x,&e[i].r);
        }
        sort(e+1,e+m+1,cmp);
        e[m+1].x=n;
        for(int i=1;i<=m;i++)
        {
            k-=e[i].r;
        }
        for(int i=1;i<=m;i++)
        {
            b+=e[i].x*e[i].r;
        }
        ans=k*e[1].x+b;
        for(int i=1;i<=m;i++)
        {
            b-=2*e[i].x*e[i].r;
            k+=2*e[i].r;
            long long now=k*e[i+1].x+b;
            if(now>0) ans=min(ans,now);
        }
        printf("%lld",ans);
        return 0;
    }
    ```

### 最优关键思路或技巧
1. **思维方式**：将实际问题转化为数学模型，如数轴上找距离和最小点问题，通过分析几何意义或函数性质找到解题方向。
2. **算法优化**：利用排序和前缀和等技巧优化计算，如在找中位数过程中通过排序和累加人数快速定位，在计算距离和时利用前缀和减少重复计算。

### 可拓展之处
此类问题属于选址优化问题，类似的还有在平面上找一点使到多个点距离和最小等问题，可考虑用类似的中位数思想或模拟退火等算法解决。常见套路是先分析问题的几何或函数特性，找到关键的最优解位置特征，再通过合适的数据结构和算法优化实现。

### 相似知识点洛谷题目
1. **P1169 棋盘制作**：涉及在棋盘上寻找满足条件的最大子矩阵，需分析问题特点，利用动态规划和一些优化技巧解决，与本题分析问题找最优解思路类似。
2. **P2014 选课**：通过树形DP解决选课问题，在树形结构上进行状态转移和优化，与本题换根DP + 贪心思路有一定相似性，锻炼对树形结构问题的处理能力。
3. **P1220 关路灯**：在一条路上有关路灯的操作，需考虑如何选择关灯顺序使消耗能量最小，与本题在一条路上找最优位置思路类似，可通过动态规划或贪心算法解决。 

---
处理用时：80.54秒
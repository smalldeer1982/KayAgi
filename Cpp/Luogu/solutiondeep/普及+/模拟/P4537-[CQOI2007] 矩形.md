# 题目信息

# [CQOI2007] 矩形

## 题目描述

给一个a\*b矩形，由a\*b个单位正方形组成。你需要沿着网格线把它分成非空的两部分，每部分所有格子连通，且至少有一个格子在原矩形的边界上。“连通”是指任两个格子都可以通过水平或者竖直路径连在一起。 求方案总数。例如3*2的矩形有15种方案。

![](https://cdn.luogu.com.cn/upload/pic/18502.png)

## 样例 #1

### 输入

```
3 2```

### 输出

```
15```

# AI分析结果

• 综合分析与结论：这些题解主要分为暴力搜索和插头DP两种思路。暴力搜索思路是从矩形边界出发，通过DFS寻找分割线，遇到边界则方案数加1，部分题解利用矩形对称性减少搜索量以优化。插头DP则用于处理较大数据，通过状态压缩和分类讨论转移状态来计算方案数。整体来看，暴力搜索代码简单易懂，插头DP实现复杂但能应对更大数据。

所选的题解：
  - 作者：hhoppitree (5星)
    - 关键亮点：思路清晰，先重新编号将原问题转化为网格图问题，再针对不同数据范围给出不同解法，代码注释详细。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int res=0;
    char c;
    bool zf=0;
    while(((c=getchar())<'0'||c>'9')&&c!= '-');
    if(c=='-')zf=1;
    else res=c-'0';
    while((c=getchar())>='0'&&c<='9')res=(res<<3)+(res<<1)+c-'0';
    if(zf)return -res;
    return res;
}
int n,m;
bool vis[7][8];
int ans;
const int dx[]={0,0,-1,1},dy[]={-1,1,0,0};
void dfs(int x,int y){
	if(!x||!y||x==n||y==m){
		ans++;
		return;
	}
	vis[x][y]=1;
	for(register int i=0;i<4;i++){
		int xx=x+dx[i],yy=y+dy[i];
		if(vis[xx][yy]){
			continue;
		}
		dfs(xx,yy);
	}
	vis[x][y]=0;
	return;
}
signed main(){
	n=read(),m=read();
	for(register int i=1;i<n;i++){
		vis[i][0]=1;
		dfs(i,1);
		vis[i][0]=0;
	}
	for(register int i=1;i<m;i++){
		vis[0][i]=1;
		dfs(1,i);
		vis[0][i]=0;
	}
	cout<<ans<<'\n';
	return 0;
}
```
    - 核心实现思想：从矩形两条边出发进行DFS，标记已访问节点，当到达边界时方案数加1，最后输出总方案数。

  - 作者：panyf (4星)
    - 关键亮点：利用矩形对称性剪枝优化，代码简洁，运行效率较高。
    - 核心代码：
```cpp
#include<cstdio>
const int nx[4]={0,0,-1,1},ny[4]={1,-1,0,0};
bool v[9][9];
int s,a,b;
void dfs(int x,int y){
	if(!x||!y||x==a||y==b){//出界就更新答案
		++s;
		return;
	}
	v[x][y]=1;
	for(register int i=0,j,k;i!=4;++i){
		j=x+nx[i],k=y+ny[i];
		if(!v[j][k])dfs(j,k);
	}
	v[x][y]=0;//记得回溯
}
int main(){
	register int i;
	scanf("%d%d",&a,&b);
	for(i=1;i+i<a;++i)v[i][0]=1,dfs(i,1),v[i][0]=0;//i为搜索起点，由于与之对称的点答案相同，只需枚举到a/2即可
	for(i=1;i+i<b;++i)v[0][i]=1,dfs(1,i),v[0][i]=0;
	s<<=1;//答案要乘2，因为少枚举了一半
	if(!(a&1))i=a>>1,v[i][0]=1,dfs(i,1),v[i][0]=0;//处理中间没有搜到的部分
	if(!(b&1))i=b>>1,v[0][i]=1,dfs(1,i),v[0][i]=0;
	printf("%d",s);
	return 0;
}
```
    - 核心实现思想：从矩形两条边出发DFS，利用对称性只枚举一半起点，最后根据奇偶性处理中间未枚举部分，得出方案总数。

  - 作者：Seauy (4星)
    - 关键亮点：同样利用矩形对称性优化，通过简洁代码实现，对优化部分有详细说明。
    - 核心代码：
```cpp
const int MAXA=6;
const int MAXB=7;

const short direx[]={0,1,0,-1};//四个方向
const short direy[]={1,0,-1,0}; 

struct Point//其实就是把坐标放进结构体里了
{
	int x,y;
	const bool operator == (Point ob)//坐标相同
	{return x==ob.x && y==ob.y;}
	void Walk(short dire)//移动
	{x+=direx[dire],y+=direy[dire];} 
};

int a,b,ans;
bool visit[MAXA+5][MAXB+5];
bool AtEdge(Point ob)//在边界，这条线就画完了
{return ob.x==1 || ob.x==b+1 || ob.y==1 || ob.y==a+1;}

int DFS(Point now)
{
	if(visit[now.y][now.x]) return 0;
	visit[now.y][now.x]=1;
	//Print_map(now);
	if(AtEdge(now))
	{
		visit[now.y][now.x]=0;
		return 1;
	}
	int cnt=0;
	for(short i=0;i<4;i++)
	{
		Point rear=now;
		rear.Walk(i);
		cnt+=DFS(rear);
	}
	visit[now.y][now.x]=0;
	return cnt;
}
for(int i=2;i<=(((b+1)>>1)+(b+1)%2);i++)//如果是奇数，那中间的情况（在对称轴上）还是要再算一遍的
{
  	visit[1][i]=1;
  	if(i<=((b+1)>>1)) ans+=2*DFS(Point{i,2});
  	else ans+=DFS(Point{i,2});//在对称轴
  	visit[1][i]=0;
}
for(int i=2;i<=(((a+1)>>1)+(a+1)%2);i++)//形如上面
{
	visit[i][1]=1;
	if(i<=((a+1)>>1)) ans+=2*DFS(Point{2,i});
	else ans+=DFS(Point{2,i});
	visit[i][1]=0;
}
```
    - 核心实现思想：从边界特定点出发DFS，利用对称性，根据对称轴位置计算方案数，避免重复计算。

最优关键思路或技巧：利用矩形对称性减少搜索量是优化暴力搜索的关键技巧，可有效降低时间复杂度。插头DP则通过状态压缩和合理分类讨论解决较大数据问题。

可拓展之处：同类型题可考虑一些连通性相关的图形分割问题，类似算法套路有利用对称性优化搜索、状态压缩DP等。

推荐题目：
  - P1817 传送带：涉及连通性和路径搜索，与本题搜索思路相关。
  - P1790 花匠：同样可通过搜索或DP解决，考察连通块相关知识。
  - P3146 [USACO16OPEN]248 G：利用DP解决类似的合并与计数问题。

个人心得：无。 

---
处理用时：66.95秒
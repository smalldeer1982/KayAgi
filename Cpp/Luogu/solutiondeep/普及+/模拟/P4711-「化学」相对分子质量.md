# 题目信息

# 「化学」相对分子质量

## 题目描述

做化学题时，小 F 总是里算错相对分子质量，这让他非常苦恼。

小 F 找到了你，请你来帮他算一算给定物质的相对分子质量。

如果你没有学过相关内容也没有关系，你可以从样例和提示里理解该题所求内容。

## 说明/提示

### 样例解释
金 $Au : 197$

二氧化铪 $HfO_{2}: 178.5 + 2 \times 16= 210.5$

氢氧化钙（熟石灰）$Ca(OH)_2 : 40 + (1 + 16) \times 2 = 74$

五水硫酸铜（胆矾）$CuSO_4 \cdot 5H_2O: 64 + 32 + 16 \times 4 + 5 \times (1 \times 2 + 16) = 250$

十二水合硫酸铝钾（明矾）$KAl(SO_{4})_{2} \cdot 12H_{2}O$ （嗯 用心感受 $474$ 是对的）

### 附表：可能用到的相对原子质量

|元素|相对原子质量|
|:-:|:-:|
|H|1|
|C|12|
|N|14|
|O|16|
|F|19|
|Na|23|
|Mg|24|
|Al|27|
|Si|28|
|P|31|
|S|32|
|Cl|35.5|
|K|39|
|Ca|40|
|Mn|55|
|Fe|56|
|Cu|64|
|Zn|65|
|Ag|108|
|I|127|
|Ba|137|
|Hf|178.5|
|Pt|195|
|Au|197|
|Hg|201|

### 提示

如果你没有学习过相关内容，下面的内容可能有帮助：

> zcy 教你算相对分子质量

1. 每个元素以大写开头；
2. 计算分子质量的方法就是对每个原子出现的次数乘对应的相对原子质量求和；
3. ~( $\cdot$ ) 相当于加；
4. 下标相当于乘。

## 样例 #1

### 输入

```
Au```

### 输出

```
197```

## 样例 #2

### 输入

```
HfO_{2}```

### 输出

```
210.5```

## 样例 #3

### 输入

```
Ca(OH)_{2}```

### 输出

```
74```

## 样例 #4

### 输入

```
CuSO_{4}~5H_{2}O```

### 输出

```
250```

## 样例 #5

### 输入

```
KAl(SO_{4})_{2}~12H_{2}O```

### 输出

```
474```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何通过模拟计算给定化学式的相对分子质量展开。思路上，基本都是对输入的化学式字符串进行逐字符或分段处理，利用打表存储元素相对原子质量，根据不同字符（如大写字母、括号、下划线、~等）判断元素、下标、原子团及水合物等，并按规则计算质量。

算法要点在于准确识别各类化学结构并正确运用计算规则，难点主要有：
1. **元素识别**：区分单字母和双字母元素。
2. **下标处理**：正确获取并应用下标系数。
3. **原子团处理**：处理括号内的化学式计算及可能的下标。
4. **水合物处理**：注意水合物系数的有无及计算。

从质量上看，部分题解思路清晰、代码规范，部分存在代码冗长、逻辑不够清晰等问题。

### 所选4星及以上题解
1. **作者：Iowa_BattleShip（4星）**
    - **关键亮点**：思路清晰，代码简洁明了。采用map存储元素相对原子质量，通过自定义函数`cs`和`js`分别处理数字读取和元素质量计算，主函数中按字符类型分类处理，逻辑清晰。
    - **个人心得**：无
    - **核心代码片段**
```cpp
int cs(int &i) {
    int x = 0;
    for (; a[i] >= '0' && a[i] <= '9'; i++)
        x = x * 10 + (a[i] - '0');
    return x;
}
double js(int &i) {
    double s = 0;
    memset(b, 0, sizeof(b));
    for (ll = -1; ((a[i] >= 'A' && a[i] <= 'Z') || (a[i] >= 'a' && a[i] <= 'z')) && (ll < 0 || (ll >= 0 && (a[i] >= 'a' && a[i] <= 'z'))); i++)
        b[++ll] = a[i];
    if (a[i] == '_') {
        i += 2;
        s += mp[b] * cs(i);
    } else {
        s += mp[b];
        i--;
    }
    return s;
}
int main() {
    // 初始化map
    mp["H"] = 1;
    //...
    mp["Hg"] = 201;
    scanf("%s", a);
    l = strlen(a);
    for (i = 0; i < l; i++) {
        if (a[i] >= 'A' && a[i] <= 'Z')
            s += js(i);
        if (a[i] == '(') {
            i++;
            for (k = 0; a[i]!= ')'; i++)
                k += js(i);
            if (a[i + 1] == '_')
                s += k * cs(i += 3);
            else
                s += k;
        }
        if (a[i] == '~') {
            i++;
            if (a[i] == 'H')
                s += 18;
            else
                s += cs(i) * 18;
            break;
        }
    }
    // 输出处理
    if (o == s)
        printf("%d", o);
    else
        printf("%.1f", s);
    return 0;
}
```
    - **核心实现思想**：`cs`函数用于快速读取数字，`js`函数负责识别元素并根据有无下标计算其质量。主函数中，根据字符类型分别调用`js`函数处理元素、括号内化学式及水合物，最后按要求输出结果。

2. **作者：引领天下（4星）**
    - **关键亮点**：思路清晰，对元素、下标、原子团和水合物的处理方法明确，代码简洁高效。使用map存储元素质量，通过多个自定义函数分别处理不同部分的计算，逻辑清晰，易于理解。
    - **个人心得**：无
    - **核心代码片段**
```cpp
inline void start() {
    mp["H"] = 1;
    //...
    mp["Hg"] = 201;
}
int ys(int k) {
    string s = "";
    int j = k + 1;
    s += a[k];
    for (; a[j] >= 'a' && a[j] <= 'z'; j++) s += a[j];
    ans += last = mp[s];
    return j;
}
int xb(int k) {
    int j = k + 2;
    int s = 0;
    for (; a[j] >= '0' && a[j] <= '9'; j++) s = s * 10 + a[j] - '0';
    ans -= last, ans += last * s;
    return j;
}
int xbk(int k) {
    int j = k + 2;
    int s = 0;
    for (; a[j] >= '0' && a[j] <= '9'; j++) s = s * 10 + a[j] - '0';
    tmp -= tlast, tmp += tlast * s;
    return j;
}
int ysk(int k) {
    string s = "";
    int j = k + 1;
    s += a[k];
    for (; a[j] >= 'a' && a[j] <= 'z'; j++) s += a[j];
    tmp += tlast = mp[s];
    return j;
}
inline int kh(int k) {
    int j = k + 1, h = 1;
    while (h!= 0) {
        if (a[j] == ')') h--;
        if (!h) break;
        if (a[j] >= 'A' && a[j] <= 'Z') {
            j = ysk(j);
            if (a[j] == '_') j = xbk(j) + 1;
        } else if (a[j] == '(') h++, j = kh(j);
    }
    if (a[j + 1] == '_') ans += tmp, last = tmp, j = xb(j + 1);
    tmp = 0;
    return j;
}
void sh(int k) {
    int j = k + 1, f = 0;
    for (; a[j] >= '0' && a[j] <= '9'; j++) f = f * 10 + a[j] - '0';
    if (!f) f++;
    ans += f * 18;
}
int main() {
    start();
    cin >> a;
    for (int i = 0; i < a.size(); i++) {
        if (a[i] >= 'A' && a[i] <= 'Z') i = ys(i) - 1;
        else if (a[i] == '_') i = xb(i);
        else if (a[i] == '(') i = kh(i);
        else if (a[i] == '~') {
            sh(i);
            break;
        }
    }
    printf("%g", ans);
    return 0;
}
```
    - **核心实现思想**：`start`函数初始化元素质量map。`ys`函数处理单个元素，`xb`函数处理外部下标，`xbk`函数处理括号内下标，`ysk`函数处理括号内元素，`kh`函数递归处理原子团，`sh`函数处理水合物。主函数根据字符类型调用相应函数完成计算。

3. **作者：info___tion（4星）**
    - **关键亮点**：采用递归方式处理字符串，逻辑清晰，代码简洁，对不同字符情况分类明确，易于理解和扩展。通过自定义函数`col`获取元素质量，`solve`函数递归解析化学式，结构清晰。
    - **个人心得**：无
    - **核心代码片段**
```cpp
double col(string s) {
    if (s == "H") return 1;
    //...
    if (s == "Hg") return 201;
}
double solve(string s) {
    double ret = 0.0;
    int cur = 0;
    while (cur < s.size()) {
        if (isupper(s[cur])) {
            string tmp;
            tmp += s[cur];
            int p = cur + 1;
            while (islower(s[p])) tmp += s[p], p++;
            double base = col(tmp);
            if (s[p] == '_') {
                p += 2;
                int num = 0;
                while (isdigit(s[p])) num = num * 10 + s[p] - '0', p++;
                p++;
                ret += base * num;
            } else ret += base;
            cur = p;
        } else if (s[cur] == '(') {
            int p = ++cur;
            while (s[p]!= ')') p++;
            double base = solve(s.substr(cur, p - cur));
            p++;
            if (s[p] == '_') {
                p += 2;
                int num = 0;
                while (isdigit(s[p])) num = num * 10 + s[p] - '0', p++;
                p++;
                ret += base * num;
            } else ret += base;
            cur = p;
        } else if (s[cur] == '~') {
            int p = cur + 1;
            int num = 0;
            while (isdigit(s[p])) num = num * 10 + s[p] - '0', p++;
            if (!num) num = 1;
            ret += H_2O * num;
            break;
        }
    }
    return ret;
}
```
    - **核心实现思想**：`col`函数根据元素名称返回其相对原子质量。`solve`函数中，通过`cur`指针扫描字符串，根据字符类型分别处理元素（包括单双字母元素及下标）、括号（递归处理括号内化学式及下标）和水合物（计算水合物质量），最后返回总质量。

### 最优关键思路或技巧
1. **数据结构选择**：使用`map<string, double>`存储元素及其相对原子质量，方便快速查找和匹配。
2. **字符处理逻辑**：对不同类型的字符（大写字母、括号、下划线、~等）进行分类处理，清晰明确地实现元素识别、下标处理、原子团计算和水合物处理。
3. **递归应用**：对于原子团的处理，部分题解采用递归方式，将括号内的化学式作为一个整体递归计算，使代码逻辑更清晰，易于实现和维护。

### 可拓展之处
同类型题通常围绕字符串处理和特定规则的模拟计算，类似算法套路包括：
1. **复杂规则模拟**：如更复杂的化学表达式计算，可能涉及括号嵌套、更多特殊符号等。
2. **特定格式字符串处理**：如数学表达式计算、特定语言语法解析等，都可通过类似的字符分类处理和递归方式实现。

### 相似知识点洛谷题目
1. **P1046 [NOIP2005 普及组] 陶陶摘苹果**：涉及简单的条件判断和模拟，与本题处理不同条件下的计算有相似之处。
2. **P1080 [NOIP2012 提高组] 国王游戏**：需要对数据进行处理和模拟计算，同时涉及一些逻辑判断，和本题在处理数据和逻辑判断上类似。
3. **P1161 开灯**：通过模拟开关灯的过程解决问题，与本题通过模拟化学表达式计算相对分子质量类似，都需要按照一定规则对过程进行模拟。

### 个人心得摘录与总结
1. **作者：cym_233**：强调模拟题代码长时调试要细心，避免被自己代码绕晕，如在NOIP 2017中因代码复杂调试不出导致失败。总结为模拟题要注重调试，保持清晰思路。
2. **作者：一扶苏一**：提到注意浮点数运算，防止因数据类型错误导致结果出错；还指出STL的string型拼接字符的方法及使用前调用`clear()`清零的注意点。强调了数据类型和STL使用的细节。
3. **作者：huangx607087**：通过学长建议意识到多练习高难度模拟题的重要性，花2小时分析完成本题，强调了练习对提升能力的作用。 

---
处理用时：146.56秒
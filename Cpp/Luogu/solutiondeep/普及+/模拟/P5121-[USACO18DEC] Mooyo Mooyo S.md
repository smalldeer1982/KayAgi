# 题目信息

# [USACO18DEC] Mooyo Mooyo S

## 题目描述

由于手上（更确实的，蹄子上）有大把的空余时间，Farmer John 的农场里的奶牛经常玩电子游戏消磨时光。她们最爱的游戏之一是基于一款流行的电子游戏 Puyo Puyo 的奶牛版；名称当然叫做 Mooyo Mooyo。

Mooyo Mooyo 是在一块又高又窄的棋盘上进行的游戏，高 $N$（$1\le N\le 100$）格，宽 $10$ 格。 这是一个 $N=6$ 的棋盘的例子：

```
0000000000
0000000300
0054000300
1054502230
2211122220
1111111223
```

每个格子或者是空的（用 $0$ 表示），或者是九种颜色之一的干草捆（用字符 $1\dots 9$ 表示）。重力会使得干草捆下落，所以没有干草捆的下方是 $0$。

如果两个格子水平或垂直方向直接相邻，并且为同一种非 $0$ 颜色，那么这两个格子就属于同一个连通区域。任意时刻出现至少 $K$ 个格子构成的连通区域，其中的干草捆就会全部消失，变为 $0$。如果同时出现多个这样的连通区域，它们同时消失。随后，重力可能会导致干草捆向下落入某个变为 $0$ 的格子。由此形成的新的布局中，又可能出现至少 $K$ 个格子构成的连通区域。若如此，它们同样也会消失（如果又有多个这样的区域，则同时消失），然后重力又会使得剩下的方块下落，这一过程持续进行，直到不存在大小至少为 $K$ 的连通区域为止。

给定一块 Mooyo Mooyo 棋盘的状态，输出这些过程发生之后最终的棋盘的图案。



## 说明/提示

在上面的例子中，如果 $K=3$，那么存在一个大小至少为 $K$ 的颜色 $1$ 的连通区域，同样有一个颜色 $2$ 的连通区域。当它们同时被移除之后，棋盘暂时成为了这样：

```
0000000000
0000000300
0054000300
1054500030
2200000000
0000000003
```

然后，由于重力效果，干草捆下落形成这样的布局：

```
0000000000
0000000000
0000000000
0000000000
1054000300
2254500333
```

再一次地，出现了一个大小至少为 $K$ 地连通区域（颜色 $3$）。移除这个区域就得到了最终的棋盘布局：

```
0000000000
0000000000
0000000000
0000000000
1054000000
2254500000
```

## 样例 #1

### 输入

```
6 3
0000000000
0000000300
0054000300
1054502230
2211122220
1111111223```

### 输出

```
0000000000
0000000000
0000000000
0000000000
1054000000
2254500000```

# AI分析结果

• 综合分析与结论：这些题解思路大致相同，均将问题拆解为找连通块并删除、使方块下落两个主要操作。算法要点在于利用深度优先搜索（DFS）或广度优先搜索（BFS）来寻找连通块，通过循环模拟方块下落。解决难点主要集中在如何正确实现连通块搜索及处理下落逻辑，同时要注意每次操作前后对标记数组等的初始化。
- 思路方面：多数题解采用先搜索连通块判断大小，若满足条件则删除，再进行下落操作，循环直至无满足条件的连通块。
- 算法要点：DFS或BFS用于连通块搜索，暴力循环实现方块下落。
- 解决难点：确保连通块搜索的准确性，处理下落时避免逻辑错误，注意数组初始化。

所选的题解：
  - 作者：houzhiyuan (赞：26)  星级：4星
    - 关键亮点：思路清晰，代码简洁明了，详细注释了关键步骤，对DFS和下落操作的实现易于理解。
    - 重点代码及核心思想：
```cpp
void dfs(int x,int y,int s) {
    biaoji[x][y]=1;
    for(int i=0; i<=3; i++) {
        int xx=x+q[i];
        int yy=y+w[i];
        if(biaoji[xx][yy]==0&&ch[xx][yy]==s) {
            sum++;
            dfs(xx,yy,s);
        }
    }
}
// 用DFS标记连通块，sum统计连通块大小

void xialuo() {
    for(int i=n; i>=1; i--) {
        for(int j=1; j<=10; j++) {
            if(ch[i][j]!='0') {
                int k=i;
                while(ch[k+1][j]=='0'&&k<=n) {
                    k++;
                }
                if(k!=i) {
                    ch[k][j]=ch[i][j];
                    ch[i][j]='0';
                }
            }
        }
    }
}
// 从下往上遍历，实现方块下落
```
  - 作者：hhoppitree (赞：17)  星级：4星
    - 关键亮点：代码结构清晰，将各个功能封装成独立函数，逻辑明确，便于理解和维护。
    - 重点代码及核心思想：
```cpp
void dfs(int x,int y){
    vis[x][y]=1;
    ++cnt;
    for(register int i=0;i<4;++i){
        int xx=x+dx[i],yy=y+dy[i];
        if(xx<1||xx>n||yy<1||yy>10||vis[xx][yy]||dta[xx][yy]!=dta[x][y])continue;
        dfs(xx,yy);
    }
    return;
}
// DFS统计连通块大小

void _clear(int x,int y){
    vis[x][y]=1;
    for(register int i=0;i<4;++i){
        int xx=x+dx[i],yy=y+dy[i];
        if(xx<1||xx>n||yy<1||yy>10||vis[xx][yy]||dta[xx][yy]!=dta[x][y])continue;
        _clear(xx,yy);
    }
    dta[x][y]=0;
    return;
}
// DFS清除符合条件的连通块

inline bool _remove(){
    bool f=0;
    for(register int i=1;i<=n;++i)
        for(register int j=1;j<=10;++j){
            if(dta[i][j]){
                cnt=0;
                memset(vis,0,sizeof(vis));
                dfs(i,j);
                if(cnt>=p){
                    f=1;
                    memset(vis,0,sizeof(vis));
                    _clear(i,j);
                }
            }
        }
    return f;
}
// 判断并移除符合条件的连通块

inline void fall(){
    bool f=1;
    while(f){
        f=0;
        for(register int i=n-1;i>=1;--i)
            for(register int j=1;j<=10;++j){
                if(dta[i][j]&&!dta[i+1][j]){
                    dta[i+1][j]=dta[i][j];
                    dta[i][j]=0;
                    f=1;
                }
            }
    }
    return;
}
// 实现方块下落
```
  - 作者：Akoasm_X (赞：12)  星级：4星
    - 关键亮点：代码注释详细，对每个功能模块的实现都有清晰解释，方便读者理解其思路。
    - 重点代码及核心思想：
```cpp
int dfs(int x,int y) {
    int ans = 1;
    for(int i=1;i<=4;i++) {
        int xn = dx[i]+x;
        int yn = dy[i]+y;
        if(in(xn,yn)&&mp[x][y]==mp[xn][yn]&&vis[xn][yn]==0) {
            vis[xn][yn] = 1;
            ans += dfs(xn,yn);
        }
    }
    return ans;
}
// DFS统计连通块大小

void get0(int x,int y) {
    for(int i=1;i<=4;i++) {
        int xn = dx[i]+x;
        int yn = dy[i]+y;
        if(in(xn,yn)&&mp[x][y]==mp[xn][yn]&&!v[xn][yn]) {
            v[xn][yn] = 1;
            get0(xn,yn);
        }
    }
}
// 标记要删除的连通块位置

bool judge() {
    bool fa = 0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=10;j++)
            if(mp[i][j]!='0'&&!vis[i][j]) {
                vis[i][j] = 1;
                if(dfs(i,j)>=m) {
                    fa = 1;
                    v[i][j] = 1;
                    get0(i,j);
                }
            }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=10;j++)
            if(v[i][j])
                mp[i][j] = '0';
    return fa; 
}
// 判断并删除符合条件的连通块

// 下落操作代码
for(int i=1;i<=10;i++) {
    int tot = n;
    for(int j=n;j>=1;j--) {
        if(mp[j][i]!='0') {
            mp[tot--][i] = mp[j][i];
        }
    }
    for(int j=1;j<=tot;j++)    
        mp[j][i] = '0';    
}
// 按列处理方块下落
```

最优关键思路或技巧：
- 利用DFS或BFS搜索连通块，通过标记数组避免重复访问，准确统计连通块大小。
- 下落操作采用按列从下往上遍历，遇到非零方块则将其移至该列下方的空闲位置，简单直观地实现重力效果。

可拓展之处：此类题目属于连通块搜索与模拟结合的类型，类似算法套路可应用于其他涉及图形中元素连通关系及状态变化的问题，如扫雷游戏模拟、地图区域划分等。

推荐题目：
- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：同样涉及连通块的判断与处理，不过重点在于对封闭区域的填充。
- [P2746 校园网络](https://www.luogu.com.cn/problem/P2746)：通过连通块相关知识解决有向图中节点连通性及最小点集问题。
- [P3392 涂国旗](https://www.luogu.com.cn/problem/P3392)：在矩阵中寻找满足条件的连通区域并进行调整，与本题思路有相似之处。

个人心得摘录与总结：
- 作者raincity提到本题码量大，调试花费时间长，强调了在处理复杂模拟问题时，要注意细节，如数组清零等操作，否则容易出错。这表明在解决此类问题时，细致的代码检查和调试能力很重要。 

---
处理用时：60.22秒
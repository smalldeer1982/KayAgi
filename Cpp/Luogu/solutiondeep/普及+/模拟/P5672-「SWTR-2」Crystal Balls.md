# 题目信息

# 「SWTR-2」Crystal Balls

## 题目背景

$\mathrm{Ethan}$ 有一些可以释放强大能量的水晶球，他将要用这些水晶球合成可以消灭敌人的魔法。

- $a\equiv b\mathrm{\ (mod\ m)}$ 表示 $a$ 和 $b$ 对模 $m$ 同余，即 $(a-b)/m$ 为整数。

## 题目描述

$\mathrm{Ethan}$ 有 $n$ 个水晶球，现在他将这些水晶球排成一行，每一个水晶球上面有一个能量值，且**要么是绿色，要么是紫色**。

- 下文中，$P$ 代表紫色，$G$ 代表绿色。

$\mathrm{Ethan}$ 现在要按以下方式取走这些水晶球：

1. 取走**最左端**的水晶球。

2. 假设取走的水晶球的颜色为 $c_1$，能值为 $x_1$，**剩余最左端**的水晶球的颜色为 $c_2$，能量为 $x_2$，取出水晶的次数为 $cnt$（包括这一次）。

- 如果 $c_1=c_2$，那么 $\mathrm{Ethan}$ 会将这两个水晶球合成为一个大水晶球（本次取出的水晶球仍计入答案总数内，详情见样例），颜色为 $c_1$，能量值为 $x_1 \times x_2$，放在水晶球序列的**最左端**。

- 如果，$c_1=P,c_2=G,cnt\equiv 1\mathrm{\ (mod\ 2)}$，那么 $\mathrm{Ethan}$ 会将剩下的水晶球的**颜色反转**（即绿色变紫色，紫色变绿色）。

- 如果仍不能满足上面的条件，那么 $\mathrm{Ethan}$ 会将剩下的水晶球**序列翻转**。

就这样，直到最后只剩下一个球，此时 $\mathrm{Ethan}$ 会直接取走最后一个球，求取走的水晶球的**能量值之和**。

由于答案很大，请对 $p$ 取模。

## 说明/提示

---

### 样例说明

**样例 $1$：**

$\mathrm{Ethan}$ 首先会取出最左端的水晶球，颜色为 ```G```，答案加上它上面所写上的数字，即 $1$，剩下的水晶球翻转，序列变为 $4\ 3\ 2$ ```GGP```。（因为 $c_1=G,c_2=P$，取出水晶球的次数为奇数，不满足条件 $1,2$，所以序列翻转）。

再取出最左端的水晶球，颜色为 ```G```，答案加上 $4$，接着把剩下来最左端的水晶球与取走的水晶球合并成一个大的水晶球，写上的数字为 $12$，序列变为 $12\ 2$ ```GP```。

取出最左边的水晶球，颜色为 ```G```，答案加上 $12$，剩下的水晶球序列翻转，序列变为 $2$ ```P```。

取出最后一个的水晶球，答案加上 $2$，最终答案为 $1+4+12+2=19$。

**样例 $2$：**

先取出 $3$，$c_1=P,c_2=G,cnt=1$，颜色翻转

取出 $7$，$c_2=c_3=P$，将 $x_3$ 乘上 $x_2$，得到 $x_3=35$

取出 $35$，最终答案为 $3+7+35=45$

---

### 数据范围与约定

本题采用 $\mathrm{Subtask}$ 制。

$\mathrm{Subtask}\ 1:n\leq 2000,a_i\leq 10^9,p\leq 10^9,15\%$。

$\mathrm{Subtask}\ 2:n\leq 5\times 10^4,a_i\leq 10^9,p\leq 10^9,15\%$。

$\mathrm{Subtask}\ 3:n\leq 5\times 10^4,a_i\leq 10^{18},p\leq 10^{18},20\%$。

$\mathrm{Subtask}\ 4:n\leq 10^6,a_i\leq 10^9,p\leq 10^9,20\%$。

$\mathrm{Subtask}\ 5:n\leq 10^6,a_i\leq 10^{18},p\leq 10^{18},30\%$。

---

对于所有测试点，时间限制 $1s$，空间限制 $16MB$。

## 样例 #1

### 输入

```
4 998244353
1 2 3 4
GPGG```

### 输出

```
19```

## 样例 #2

### 输入

```
3 998244353
3 7 5
PGG```

### 输出

```
45```

## 样例 #3

### 输入

```
10 998244353
12345 23456 34567 45678 56789 67890 78901 89012 90123 101234
GPPGPGGGPG```

### 输出

```
104157290```

# AI分析结果

• 综合分析与结论：
    - 思路方面，所有题解都明确采用模拟的思路来解决该问题，依据题目给定的三种操作规则，逐步处理水晶球序列直至剩下一个球，并累加能量值。
    - 算法要点：一是使用变量标记来处理颜色反转和序列翻转情况，如用一个变量表示颜色是否反转，一个变量表示序列是否反转或遍历方向；二是用双指针或类似首尾部变量来模拟序列的操作，避免实际的数组翻转操作以减少时间复杂度。
    - 难点解决：针对两数相乘可能溢出的问题，题解主要通过快速乘算法或使用__int128类型来处理。

    - 综合质量来看，Alex_Wei和mlvx的题解相对更优，思路清晰，代码简洁且有较好的注释。

所选的题解：
  - Alex_Wei的题解：★★★★
    - 关键亮点：思路清晰，对颜色反转和序列翻转的表示方法简洁明了，通过mask变量表示颜色是否反转，dir变量表示序列方向，head和tail表示序列首尾，且代码注释详细，还提及了出题背景。
    - 个人心得：无
    - 核心代码片段：
```cpp
inline void mult(ll &x,ll y){x=(x*y-(ll)((ld)x/mod*y)*mod+mod)%mod;}
inline void add(ll &x,ll y){x=(x+y)%mod;}
bool id(char x){return x=='G';}
int main()
{
    n=read(),mod=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
    scanf("%s",s+1);
    head=1,tail=n;
    for(int i=1;i<n;i++){
        add(ans,a[head]);
        ll c1=id(s[head])^mask,c2=id(s[head+dir])^mask;
        if(c1==c2){
            mult(a[head+dir],a[head]);
            head+=dir;
        }
        else if(c1==0&&c2==1&&i%2){
            mask^=1;
            head+=dir;
        }
        else{
            head+=dir;
            dir=-dir;
            swap(head,tail);
        }
    }
    add(ans,a[head]);
    print(ans);
    return 0;
}
```
核心实现思想：通过read函数读入数据，在循环中，每次取出首端水晶球，根据颜色和操作次数等条件，判断执行合并、颜色反转或序列翻转操作，使用mult和add函数进行乘法和加法并取模运算。

  - mlvx的题解：★★★★
    - 关键亮点：对三种操作的分析清晰，针对每种操作给出具体实现思路，使用flag标记颜色是否翻转，rev标记序列是否翻转，代码逻辑清晰，易于理解。
    - 个人心得：无
    - 核心代码片段：
```cpp
while(l<r){
    cnt++;
    if(rev){//翻转过
        ans=(ans+a[r])%mod;//记录答案 
        if(c[r]==c[r-1])a[r-1]=(__int128)a[r]*a[r-1]%mod;
        else if((cnt&1)&&(!flag&&c[r]=='P'&&c[r-1]=='G'||flag&&c[r]=='G'&&c[r-1]=='P'))flag^=1;//颜色翻转
        else rev^=1;//序列翻转
        a[r--]=0;//被拿走
    }else{//未翻转
        ans=(ans+a[l])%mod;//记录答案
        if(c[l]==c[l+1])a[l+1]=(__int128)a[l]*a[l+1]%mod;
        else if((cnt&1)&&(!flag&&c[l]=='P'&&c[l+1]=='G'||flag&&c[l]=='G'&&c[l+1]=='P'))flag^=1;//颜色翻转
        else rev^=1;//序列翻转
        a[l++]=0;//被拿走
    } 
}
return cout<<(ans+a[l])%mod,0;
```
核心实现思想：通过while循环模拟操作，根据rev判断序列是否翻转，分别处理翻转和未翻转情况下的操作，如记录答案、判断合并、颜色反转或序列翻转条件，并更新相应变量。

最优关键思路或技巧：
    - 用简单变量标记颜色反转和序列翻转状态，避免复杂操作，减少时间和空间开销。
    - 利用双指针或类似首尾部变量结合方向变量，模拟序列操作，避免实际数组翻转。
    - 对于大数相乘，采用快速乘算法或__int128类型防止溢出。

可拓展之处：此类题目属于模拟与条件判断结合的类型，类似套路可用于解决一些按特定规则进行状态转移或序列操作的问题，例如一些游戏规则模拟、数据处理规则模拟等题目。

推荐题目：
    - P1036 [NOIP2002 普及组] 选数，涉及枚举和取模运算。
    - P1161 开灯，需要模拟开关灯的操作和状态判断。
    - P1996 约瑟夫问题，通过模拟报数和出圈规则解决问题。

个人心得摘录与总结：
    - pomelo_nene：做本题时一开始用高精导致MLE爆零，之后尝试优化到部分数据点通过，最后发现程序瓶颈在乘法阶段，使用快速乘解决问题。总结为做题时要注意数据范围和操作的复杂度，避免因不合理的数据类型或算法导致超时或内存超限。 

---
处理用时：40.26秒
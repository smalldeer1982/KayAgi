# 题目信息

# 『MdOI R1』Decrease

## 题目描述

给定一个 $n \times n$ 的矩阵，你可以进行若干次操作。

每次操作，你可以将一个 $k \times k$ 的 **连续** 子矩阵里的所有数全都加上 $1$ 或者全都减去 $1$。

初始时，矩阵中有 $m$ 个位置上的数不为 $0$，其它位置上的数均为 $0$。

请你求出至少需要多少次操作，可以将矩形中所有数都变为 $0$。

## 说明/提示

【样例 1 解释】:  

给出的矩阵为：  

```plain
1 1 1 0
1 3 3 2
1 3 3 2
0 2 2 2
```

具体步骤：  

先将以第一行第一列为左上角的连续子矩阵执行 **减 1 操作** 一次；

再将以第二行第二列为左上角的连续子矩阵执行 **减 1 操作** 两次。

总共三次。

```plain
1 1 1 0  0 0 0 0  0 0 0 0  0 0 0 0
1 3 3 2  0 2 2 2  0 1 1 1  0 0 0 0
1 3 3 2  0 2 2 2  0 1 1 1  0 0 0 0
0 2 2 2  0 2 2 2  0 1 1 1  0 0 0 0
```

【样例 2 解释】：  

给出的矩阵为：  

```plain
1 0 0
0 0 0
0 0 0
```

只通过 $2\times 2$ 的连续子矩阵操作不可能使得所有格子上的数都变为 $0$。

【数据范围】   

**本题采用捆绑测试。**

| 子任务编号 |    $n\leq$     | $k\leq$ | 分值 |
| :--------: | :------------: | :-----: | :--: |
|     1      |     $10^3$     |   $1$   |  11  |
|     2      |      $20$      |  $20$   |  14  |
|     3      |     $100$      |  $100$  |  17  |
|     4      |     $10^3$     | $10^3$  |  34  |
|     5      | $5\times 10^3$ | $10^3$  |  24  |

对于所有数据，$1\leq n\leq 5\times 10^3$，$1\leq m\leq \min(n^2,5\times 10^5)$，$1\leq k\leq \min(n,10^3)$，$1\leq x,y\leq n$，每对 $(x,y)$ 至多出现一次，$1 \le |z| \leq 10^9$。

数据保证如果有解，答案不超过 $2^{63}-1$。

---

【提示】

本题读入量较大，建议使用较快的读入方式。  

## 样例 #1

### 输入

```
4 14 3
1 1 1
1 2 1
1 3 1
2 1 1
2 2 3
2 3 3
2 4 2
3 1 1
3 2 3
3 3 3
3 4 2
4 2 2
4 3 2
4 4 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3 1 2
1 1 1
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
4 5 1
1 1 5
2 2 -3
2 3 -4
3 3 1
4 4 2
```

### 输出

```
15
```

# AI分析结果

• **综合分析与结论**：这些题解均围绕通过二维差分解决矩阵操作次数最小化问题。思路要点为利用二维差分特性优化对\(k×k\)子矩阵操作。难点在于理解二维差分原理及如何通过差分实现子矩阵的高效修改与统计操作次数。多数题解思路清晰，部分代码可读性稍弱。

  - **作者George1123**：
    - **星级**：4星
    - **关键亮点**：先介绍暴力做法及得分，再引入差分优化。思路清晰，逐步讲解从暴力到差分的过程，代码注释详细。
    - **个人心得**：分享比赛时从想到暴力做法到最终未做出题的经历，强调审题和暴力做法的重要性。
    - **核心代码片段**：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
        cf[i][j]=a[i][j]-a[i][j-1];//行差分
for(int i=1;i<=n-k+1;i++)
    for(int j=1,num=0;j<=n-k+1;j++){
        num=cf[i][j];
        if(num!=0){
            ans+=abs(num);
            for(int t=i;t<=i+k-1;t++)
                cf[t][j]-=num,cf[t][j+k]+=num;
        }
    }
```
    - **核心实现思想**：先对每行进行差分得到差分数组\(cf\)，然后枚举覆盖正方形左上角端点，若端点值不为零，更新差分数组并累加操作次数。

  - **作者风急风也清**：
    - **星级**：4星
    - **关键亮点**：开篇强调数据类型，结合图示解释二维差分概念，代码简洁明了。
    - **核心代码片段**：
```cpp
void f(int x,int y,int c)
{
    if(x+k>n+1 || y+k>n+1)
    { cout<<"-1"; exit(0); }
    d[x][y]-=c;
    d[x+k][y]+=c;
    d[x][y+k]+=c;
    d[x+k][y+k]-=c;
}
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=n;j++)
    {
        d[i][j]=d[i-1][j]+d[i][j-1]-d[i-1][j-1]+d[i][j];
        long long t=d[i][j]+a[i][j];
        if(t) { ans+=abs(t); f(i,j,t); }
    }
}
```
    - **核心实现思想**：定义函数\(f\)实现二维差分操作，在遍历矩阵时，通过前缀和得到当前位置需修改的值，若不为零则进行差分操作并累加操作次数。

  - **作者ILLENIUM_DOOR**：
    - **星级**：4星
    - **关键亮点**：结合图示详细解释二维差分在本题中的应用思路，对修改过程讲解细致。
    - **核心代码片段**：
```cpp
void cf(int x,int y,int c){
    int xx=x+k,yy=y+k;
    if(xx>n+1||yy>n+1){
        cout<<"-1";
        exit(0);
    }
    d[x][y]-=c;
    d[xx][y]+=c;
    d[x][yy]+=c;
    d[xx][yy]-=c;
}
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++){
        d[i][j]+=d[i-1][j]+d[i][j-1]-d[i-1][j-1];
        ll k=d[i][j]+f[i][j];
        if(k){
            ans+=abs(k);
            cf(i,j,k);
        }
    }
```
    - **核心实现思想**：与风急风也清题解类似，定义函数\(cf\)实现二维差分操作，遍历矩阵时通过前缀和得到当前位置差值，若不为零则进行差分并累加操作次数。

• **最优关键思路或技巧**：利用二维差分将对\(k×k\)子矩阵的修改操作转化为对差分数组的局部修改，从而将每次\(O(k^2)\)的矩阵修改复杂度优化为\(O(1)\)，同时通过前缀和还原原矩阵状态，高效统计操作次数。

• **可拓展之处**：此类题目可拓展到不同形状子矩阵的修改操作，或对矩阵有多种不同类型操作的情况，同样可尝试利用差分思想优化。类似算法套路常用于处理区间修改、查询问题，如一维数组的区间加减、求区间和等问题可使用一维差分。

• **相似知识点洛谷题目**：
  - P3397 地毯：二维前缀和基础应用。
  - P1387 最大正方形：结合动态规划与二维前缀和。
  - P2004 领地选择：二维前缀和与最值问题结合。 

---
处理用时：39.94秒
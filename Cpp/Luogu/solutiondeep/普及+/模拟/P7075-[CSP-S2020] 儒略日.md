# 题目信息

# [CSP-S2020] 儒略日

## 题目描述

为了简便计算，天文学家们使用儒略日（Julian day）来表达时间。所谓儒略日，其定义为从**公元前 4713 年 1 月 1 日正午 12 点到此后某一时刻间所经过的天数**，不满一天者用小数表达。若利用这一天文学历法，则每一个时刻都将被均匀的映射到数轴上，从而得以很方便的计算它们的差值。

现在，给定一个不含小数部分的儒略日，请你帮忙计算出该儒略日（一定是某一天的中午 12 点）所对应的公历日期。

我们现行的公历为格里高利历（Gregorian calendar），它是在公元 1582 年由教皇格里高利十三世在原有的儒略历（Julian calendar）的基础上修改得到的（注：儒略历与儒略日并无直接关系）。具体而言，现行的公历日期按照以下规则计算：

1. 公元 1582 年 10 月 15 日（含）以后：适用格里高利历，每年一月 $31$ 天、 二月 $28$ 天或 $29$ 天、三月 $31$ 天、四月 $30$ 天、五月 $31$ 天、六月 $30$ 天、七月 $31$ 天、八月 $31$ 天、九月 $30$ 天、十月 $31$ 天、十一月 $30$ 天、十二月 $31$ 天。其中，闰年的二月为 $29$ 天，平年为 $28$ 天。当年份是 $400$ 的倍数，或日期年份是 $4$ 的倍数但不是 $100$ 的倍数时，该年为闰年。
2. 公元 1582 年 10 月 5 日（含）至 10 月 14 日（含）：不存在，这些日期被删除，该年 10 月 4 日之后为 10 月 15 日。
3. 公元 1582 年 10 月 4 日（含）以前：适用儒略历，每月天数与格里高利历相同，但只要年份是 $4$ 的倍数就是闰年。
4. 尽管儒略历于公元前 45 年才开始实行，且初期经过若干次调整，但今天人类习惯于按照儒略历最终的规则反推一切 1582 年 10 月 4 日之前的时间。注意，**公元零年并不存在**，即公元前 1 年的下一年是公元 1 年。因此公元前 1 年、前 5 年、前 9 年、前 13 年……以此类推的年份应视为闰年。

## 说明/提示

**【数据范围】**

| 测试点编号 | $Q =$ | $r_i \le$ |
|:-:|:-:|:-:|
| $1$ | $1000$ | $365$ |
| $2$ | $1000$ | $10^4$ |
| $3$ | $1000$ | $10^5$ |
| $4$ | $10000$ | $3\times 10^5$ |
| $5$ | $10000$ | $2.5\times 10^6$ |
| $6$ | $10^5$ | $2.5\times 10^6$ |
| $7$ | $10^5$ | $5\times 10^6$ |
| $8$ | $10^5$ | $10^7$ |
| $9$ | $10^5$ | $10^9$ |
| $10$ | $10^5$ | 年份答案不超过 $10^9$ |

## 样例 #1

### 输入

```
3
10
100
1000```

### 输出

```
11 1 4713 BC
10 4 4713 BC
27 9 4711 BC```

## 样例 #2

### 输入

```
3
2000000
3000000
4000000```

### 输出

```
14 9 763
15 8 3501
12 7 6239```

## 样例 #3

### 输入

```
见附件中的 julian/julian3.in```

### 输出

```
见附件中的 julian/julian3.ans```

# AI分析结果

这道题主要是将儒略日转换为公历日期，涉及不同历法规则及多个特殊时间点的处理。各题解思路大致围绕分段处理、利用历法周期规律优化计算。以下是具体分析：
1. **思路与算法要点**：
    - **按时间段模拟**：根据公元前、公元1582年10月4日（含）以前、1582年10月5 - 14日（不存在）、1582年10月15日（含）以后进行分段，按各段历法规则逐年、逐月模拟计算日期。如“wsm52”的题解，先划分时间段，再按不同规则处理各段。
    - **利用周期规律优化**：注意到儒略历4年一周期，格里高利历400年一周期，通过取模运算快速定位年份范围，减少模拟次数。像“「已注销」”的题解，预处理400年内情况，利用周期快速得出答案。
    - **二分查找**：通过二分年份，结合计算到某年的总天数，确定目标年份，再模拟剩余日期得到月和日。比如“OMG_wc”的题解采用此方法。
2. **解决难点**：
    - **闰年判断**：公元前、公元1582年前和后的闰年判断规则不同，需分别处理。
    - **特殊日期处理**：1582年10月5 - 14日不存在，计算时要跳过这10天。
    - **时间复杂度优化**：数据中年份范围大，直接模拟会超时，需利用周期规律或二分法优化。
3. **题解评分**：
    - **「已注销」**：思路清晰，利用历法周期简化计算，代码简洁高效。通过预处理400年内情况，将年份模400快速得到答案，并给出简化代码的技巧。★★★★
    - **OMG_wc**：详细阐述思路与多种实现方法及可能遇到的坑点，如闰年判定、公元0年处理、消失10天的特判等，对理解题目有很大帮助。★★★★
    - **vectorwyx**：先通过二分查找确定年份，再枚举月份得到日期，对闰年计算和特殊日期处理清晰，代码逻辑明确。★★★★
4. **最优关键思路与技巧**：利用历法周期规律优化计算，如以400年为周期处理格里高利历部分，减少模拟量。同时，在处理复杂日期计算时，合理分段并针对各段特点设计算法，可有效降低复杂度。
5. **拓展**：同类型题可涉及不同历法转换、时间日期计算等，类似算法套路是根据不同阶段规则特点，寻找周期规律或其他优化方式简化计算。
6. **相似知识点题目**：
    - [P1307 数字反转](https://www.luogu.com.cn/problem/P1307)：涉及数字处理，与本题对日期各部分处理类似。
    - [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：通过分析不同购买方案，选择最优解，与本题根据不同条件选择合适算法类似。
    - [P2670 扫雷游戏](https://www.luogu.com.cn/problem/P2670)：根据给定规则处理二维数组元素，与本题按历法规则处理日期元素类似。
7. **个人心得摘录**：
    - **囧仙**：做题要细心，不贪多，可先解决题面特殊情况，如闰年判定规则、特殊日期处理等。
    - **Piwry**：毒瘤大模拟题调试困难，可找便于实现的做法，如预处理关键日期范围，利用周期规律简化讨论。
    - **dear_deer_land**：暴力模拟易踩坑，如闰年判断、公元0年处理等，可通过找规律优化，如利用400年周期循环节。

### 「已注销」题解
- **星级**：★★★★
- **关键亮点**：利用历法周期简化计算，代码简洁高效。
```cpp
#include<bits/stdc++.h>
typedef long long ll;
const int N = 146097;
int T, y[N], m[N], d[N];
ll n, t;
inline int md(int y, int m) {
    if (m == 2) return y % 4? 28 : y % 100? 29 : y % 400? 28 : 29;
    return m == 4 || m == 6 || m == 9 || m == 11? 30 : 31;
}
int main() {
    m[0] = d[0] = 1;
    for (int i = 1; i < N; ++i) {
        d[i] = d[i - 1] + 1; m[i] = m[i - 1]; y[i] = y[i - 1];
        if (d[i] > md(y[i], m[i])) ++m[i], d[i] = 1;
        if (m[i] > 12) ++y[i], m[i] = 1;
    }
    scanf("%d", &T);
    while (T--) {
        scanf("%lld", &n);
        if (n > 2299160) {
            n -= 2159351;
            t = n / N * 400 + 1200;
            n %= N;
        } else {
            t = n / 1461 * 4 - 4712;
            n %= 1461;
        }
        if (t + y[n] > 0) printf("%d %d %lld\n", d[n], m[n], t + y[n]);
        else printf("%d %d %lld BC\n", d[n], m[n], 1 - t - y[n]);
    }
}
```
核心实现思想：先预处理400年内从0年1月1日开始每天对应的年月日。对于输入的儒略日，根据其与2299160的大小关系，判断使用的历法，通过取模运算确定在周期内位置，进而得出对应公历日期。

### OMG_wc题解
- **星级**：★★★★
- **关键亮点**：详细阐述思路与多种实现方法及可能遇到的坑点。
```cpp
int a[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
LL cal(LL x) {
    int sb = -4712;
    if (x < sb) return 0;
    LL res = (x - sb + 1) * 365;
    if (x < 1582) {
        res += (x - sb) / 4 + 1;
    } else {
        res -= 10;
        res += (1581 - sb) / 4 + 1;
        res += (x - 1580) / 4 - (x - 1500) / 100 + (x - 1200) / 400;
    }
    return res;
}
bool pd(int x) {
    if (x > 1582) {
        return x % 4 == 0 && x % 100!= 0 || x % 400 == 0;
    } else {
        return x % 4 == 0;
    }
}
int main() {
    int _;
    scanf("%d", &_);
    while (_--) {
        LL n;
        scanf("%lld", &n);
        n++;
        int l = -4712, r = 1e9 + 5;
        while (l < r) {
            int mid = l + r >> 1;
            if (cal(mid) >= n) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        n -= cal(l - 1);
        a[2] = 28 + pd(l);
        a[10] = l == 1582? 21 : 31;
        int m;
        for (int i = 1; i <= 12; i++) {
            if (n > a[i]) {
                n -= a[i];
            } else {
                m = i;
                break;
            }
        }
        if (l == 1582 && m == 10) {
            if (n >= 5) n += 10;
            printf("%lld %d %d\n", n, m, l);
        } else {
            if (l > 0)
                printf("%lld %d %d\n", n, m, l);
            else
                printf("%lld %d %d BC\n", n, m, -l + 1);
        }
    }
    return 0;
}
```
核心实现思想：通过`cal`函数计算到某一年的总天数，利用二分查找确定年份，再根据年份调整每月天数，通过循环确定月份和日期，同时处理1582年10月特殊情况。

### vectorwyx题解
- **星级**：★★★★
- **关键亮点**：先二分确定年份，再枚举月份得到日期，逻辑清晰。
```cpp
ll count_year(int year) {
    if (year < 0) {
        int cnt = year + 4713 + 1;
        return 1ll * cnt * 365 + ceil(cnt / 4.0);
    } else if (year < 1582) {
        return count_year(-1) + year * 365 + year / 4;
    } else if (year == 1582) {
        return count_year(1581) + 355;
    } else if (year == 1583) {
        return count_year(1581) + 355 + 365;
    } else if (year <= 1600) {
        int cnt = year - 1583;
        return count_year(1583) + cnt * 365 + (cnt - 1) / 4 + 1;
    } else {
        int cnt = year - 1600;
        return count_year(1600) + 1ll * cnt * 365 + cnt / 4 - cnt / 100 + cnt / 400;
    }
}
bool check(int x) {
    if (x < 0) return ((-x) % 4 == 1);
    if (x <= 1582) return x % 4 == 0;
    return ((x % 4 == 0 && x % 100!= 0) || (x % 400 == 0));
}
int mo[30] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int sum[30];
int count_month(int year, int month) {
    return sum[month] + (check(year) && (month >= 2)) - (year == 1582 && month >= 10) * 10;
}
int main() {
    fo(i, 1, 12) sum[i] = sum[i - 1] + mo[i];
    int T = read();
    while (T--) {
        ll ri = read() + 1;
        int L, R, mid, Year, Month, Day;
        L = -4713, R = 1e9 + 5;
        while (L <= R) {
            mid = (L + R) >> 1;
            if (count_year(mid) >= ri) Year = mid, R = mid - 1;
            else L = mid + 1;
        }
        ri -= count_year(Year - 1);
        fo(i, 1, 12) {
            int cm = count_month(Year, i);
            if (cm >= ri) {
                Month = i;
                Day = ri - count_month(Year, i - 1);
                break;
            }
        }
        if (Year == 1582 && Month == 10 && Day > 4) Day += 10;
        if (Year < 0) printf("%d %d %d BC\n", Day, Month, -Year);
        else printf("%d %d %d\n", Day, Month, Year);
    }
    return 0;
}
```
核心实现思想：通过`count_year`函数计算到某一年的总天数，利用二分查找确定年份。再通过`count_month`函数计算到某一月的总天数，枚举月份确定日期，最后处理1582年10月特殊情况。 

---
处理用时：113.81秒
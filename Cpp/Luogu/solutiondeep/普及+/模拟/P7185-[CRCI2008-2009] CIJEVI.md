# 题目信息

# [CRCI2008-2009] CIJEVI

## 题目描述

为了帮助设计天然气管道，克罗地亚和莫斯科正在使用电脑游戏「管道狂热」。

在游戏中，欧洲分为 $R$ 行和 $C$ 列。每个单元格可以为空，也可以包含七个基本管道构建块之一：

![](https://cdn.luogu.com.cn/upload/image_hosting/r3k1hpsp.png)
气体可以通过构建块沿任一方向流动。 构建块 `+` 的特殊之处在于气体必须沿两个方向（一个垂直方向，一个水平方向）流动，如以下示例所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/te8dolym.png)

当黑客从计划中删除了一个构建块时，但新管道已经开始投入使用。

编写一个程序，确定被删除构建块的位置和它的类型。

## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据，$1 \le R, C \le 25$。
#### 说明
- 本题满分 $70$ 分。
- Subtask 1 为 hack 数据，不计分。
- 本题译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CRCI2008-2009](https://hsin.hr/coci/archive/2008_2009/regional_tasks.pdf) CIJEVI，译者 @[tearing](https://www.luogu.com.cn/user/219791)。
- 2023.11.17 添加一组 hack 数据。
- 2024.02.16 再添加一组 hack 数据。

## 样例 #1

### 输入

```
3 7
.......
.M-.-Z.
....... 
```

### 输出

```
2 4 - 
```

## 样例 #2

### 输入

```
3 5
..1-M
1-+..
Z.23. 
```

### 输出

```
2 4 4
```

## 样例 #3

### 输入

```
6 10
Z.1----4..
|.|....|..
|..14..M..
2-+++4....
..2323....
.......... 
```

### 输出

```
3 3 |```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找被删除的管道构建块这一核心任务，思路可归纳为两类：
 - **搜索枚举类**：从起点（`M`）或终点（`Z`）出发，通过深度优先搜索（DFS）或广度优先搜索（BFS）遍历管道，找到断点后，枚举断点处可能的管道类型，判断能否使管道从起点到终点连通且无冗余构建块。例如，_xiaxii 先通过一次搜索找到断点坐标，再枚举 7 种管道类型进行验证；2011FYCCCTA 从 `M` 深搜找断点，再枚举断点处管道类型判断能否到达 `Z`。
 - **直接判断类**：遍历整个地图，根据空白地块（`.`）与周围构建块的连接情况，直接判断该空白地块是否为断点以及应填充的管道类型。比如，Xie2Yue 通过判断空白地块四个方向与构建块的连通性确定断点及类型；All_In_Atom 采用类似方法，通过函数判断空白地块各方向开口情况确定管道类型。

各题解在解决难点方面，主要针对特殊情况（如起点或终点附近为断点、图中无管道构建块等）进行特判处理。在质量上，部分题解思路清晰、代码实现完整且考虑到边界情况，但有些题解在代码可读性和优化程度上有所欠缺。

### 所选的题解
- **作者：_xiaxii（5 星）**
    - **关键亮点**：思路清晰，先通过搜索确定断点坐标，再枚举管道类型验证，代码实现详细，对方向变换处理细致，并考虑到标记已使用管道避免错误，还对特殊输入情况进行了 Hack 处理。
    - **个人心得**：“看似已经没有问题了，交上去，[错了两个点](https://www.luogu.com.cn/record/96034428)。仔细思考，就会发现一个问题……用一个 `book` 数组标记每个管道是否用过就行了。”总结出通过标记数组解决判断管道使用情况的问题。
    - **核心代码**：
```cpp
void f(int x,int y,int d)
{
    book[x][y]=1;
    int p=d;
    if(e[x][y]==bl[3])
    {
        p=d==1?2:3; 
    }
    // 其他管道方向变换处理类似
    if(e[x][y]==bl[0]&&((d==1&&k(x,y,d))||(d==2&&k(x,y,d))||(d==3&&k(x,y,d))||(d==4&&k(x,y,d))))
    {
        f(x+nt[d-1][0],y+nt[d-1][1],d);
    }
    // 其他管道走法处理类似
    else if(x+nt[p-1][0]==fx&&y+nt[p-1][1]==fy)
    {
        bool flag2=true;
        for(int i=1;i<=r;i++)
        {
            for(int j=1;j<=m;j++)
            {
                if(e[i][j]!='.'&&e[i][j]!='M'&&e[i][j]!='Z')
                {
                    if(!book[i][j])
                        flag2=false;
                }
            }
        }
        if(flag2)
        {
            if(hack) --block;
            cout<<fixx<<" "<<fixy<<" "<<bl[block];
            exit(0);
        }
    }
    else if(flag)
    {
        flag=false;
        fixx=x+nt[p-1][0],fixy=y+nt[p-1][1];
    }
}
```
    - **核心思想**：`f` 函数实现管道遍历，通过 `book` 数组标记已访问的管道，根据当前管道类型（`e[x][y]`）更新方向 `p`，模拟不同管道走法。若走到终点，检查所有管道是否都被访问，若满足则输出结果；若首次进入，记录断点坐标。
- **作者：Xie2Yue（4 星）**
    - **关键亮点**：从地图整体出发，通过判断空白地块与周围构建块的连通性确定断点及管道类型，代码简洁，还对特殊输入情况（Hack）进行了处理，并采用状压优化判断过程。
    - **核心代码**：
```cpp
bool left( int r, int s ) {
    return s >  1  && (a[r][s-1]=='+' || a[r][s-1]=='-' || a[r][s-1]=='1' || a[r][s-1]=='2');
}
bool right( int r, int s ) {
    return s < S   && (a[r][s+1]=='+' || a[r][s+1]=='-' || a[r][s+1]=='3' || a[r][s+1]=='4');
}
bool up( int r, int s ) {
    return r >  1  && (a[r-1][s]=='+' || a[r-1][s]=='|' || a[r-1][s]=='1' || a[r-1][s]=='4');
}
bool down( int r, int s ) {
    return r < R   && (a[r+1][s]=='+' || a[r+1][s]=='|' || a[r+1][s]=='2' || a[r+1][s]=='3');
}
// 判断被删掉构建块的形态
if( left(r,s) && right(r,s) && up(r,s) && down(r,s) ) printf( "%d %d +\n", r, s );
else if( left(r,s) && right(r,s) ) printf( "%d %d -\n", r, s );
// 其他情况判断类似
```
    - **核心思想**：通过 `left`、`right`、`up`、`down` 四个函数判断空白地块四个方向与构建块的连通性，根据不同连通情况确定应填充的管道类型。
- **作者：2011FYCCCTA（4 星）**
    - **关键亮点**：思路直接，先从 `M` 出发深搜找断点，针对断点可能在 `M` 相邻处的特殊情况，通过枚举可能的断点位置解决，再枚举断点处管道类型判断能否到达 `Z`，代码逻辑清晰。
    - **核心代码**：
```cpp
void dfs1(int x, int y, int d)
{
    if (mp[x][y] == '.') {bx = x; by = y; return;}
    d = get_d(x, y, d);
    int nx = x + dx[d], ny = y + dy[d];
    dfs1(nx, ny, d);
    return;
}
void dfs2(int x, int y, int d)
{
    if (mp[x][y] == 'Z') {printf("%d %d %c", bx, by, mp[bx][by]); exit(0);}
    int nx = x + dx[d], ny = y + dy[d];
    if (check(nx, ny) && 
    (mp[nx][ny] == 'Z' || 
    (mp[nx][ny] == '|' && d % 2 == 0) || 
    (mp[nx][ny] == '-' && d % 2 == 1) || 
    mp[nx][ny] == '+' || 
    (mp[nx][ny] == '1' && (d == 2 || d == 3)) || 
    (mp[nx][ny] == '2' && (d == 3 || d == 0)) || 
    (mp[nx][ny] == '3' && (d == 0 || d == 1)) || 
    (mp[nx][ny] == '4' && (d == 1 || d == 2))
    )) dfs2(nx, ny, get_d(nx, ny, d));
    return;
}
```
    - **核心思想**：`dfs1` 函数从 `M` 出发深搜找断点，记录断点坐标。`dfs2` 函数在断点处枚举填充不同管道类型后，从 `M` 出发判断能否到达 `Z`，若能到达则输出结果。

### 最优关键思路或技巧
 - **搜索与标记结合**：如 _xiaxii 的题解，在搜索过程中使用标记数组记录已访问的管道，确保每个管道都被使用且仅使用一次，有效避免错误结果。
 - **方向处理技巧**：定义方向数组和方向变换规则，清晰处理管道中气体流动方向的变化，使代码逻辑更清晰，如 _xiaxii 和 2011FYCCCTA 的题解。
 - **状压优化**：Xie2Yue 的题解中，通过给上下左右四个方向附上不同权值，将判断管道类型的多个条件合并为一个整数判断，简化代码并提高效率。

### 可拓展之处
此类题目属于图的模拟与搜索问题，可拓展到其他涉及路径寻找、缺失元素判断的图相关题目。类似算法套路包括：
 - **基于搜索的方法**：在复杂图形或网络中，通过 DFS 或 BFS 遍历寻找特定路径或元素，同时标记已访问节点避免重复访问。
 - **条件判断与枚举**：根据题目给定的条件，对可能的情况进行枚举和判断，确定符合要求的解。

### 相似知识点洛谷题目
 - **P1308 统计单词数**：涉及字符串匹配与统计，需遍历字符串并根据特定条件判断，与本题遍历地图判断管道情况类似，考察字符串处理和条件判断能力。
 - **P1036 [NOIP2002 普及组] 选数**：需要通过枚举和判断来找出符合条件的数的组合，与本题枚举管道类型判断是否符合要求的思路相似，锻炼枚举与条件判断的能力。
 - **P1162 填涂颜色**：通过对二维数组的遍历和标记，判断区域的连通性，与本题判断管道连通性有相似之处，考察二维数组操作和连通性判断的知识点。 

---
处理用时：76.56秒
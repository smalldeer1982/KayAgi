# 题目信息

# [USACO21FEB] Comfortable Cows S

## 题目描述

Farmer Nhoj 的草地可以被看作是一个由正方形方格组成的巨大的二维方阵（想象一个巨大的棋盘）。初始时，草地上是空的。

Farmer Nhoj 将会逐一地将 $N$（$1\le N\le 10^5$）头奶牛加入到草地上。第 $i$ 头奶牛将会占据方格 $(x_i,y_i)$，不同于所有已经被其他奶牛占据的方格（$0\le x_i,y_i\le 1000$）。

一头奶牛被称为是「舒适的」，如果它水平或竖直方向上与恰好三头其他奶牛相邻。然而，太舒适的奶牛往往产奶量落后，所以 Farmer Nhoj 想要额外加入一些奶牛直到没有奶牛（包括新加入的奶牛）是舒适的。注意加入的奶牛的 $x$ 和 $y$ 坐标并不一定需要在范围 $0 \ldots 1000$ 内。

对于 $1 \ldots N$ 中的每个 $i$，输出当初始时草地上有奶牛 $1\ldots i$ 时，Farmer Nhoj 为使得没有奶牛舒适，需要加入的奶牛的最小数量。


## 说明/提示


对于 $i=4$，Farmer Nhoj 需要在 $(2,1)$ 加入一头奶牛使得位于 $(1,1)$ 的奶牛不再舒适。

对于 $i=9$，Farmer Nhoj 的最优方案是在 $(2,0)$、$(3,0)$、$(2,-1)$ 和 $(2,3)$ 加入奶牛。

供题：Benjamin Qi

## 样例 #1

### 输入

```
9
0 1
1 0
1 1
1 2
2 1
2 2
3 1
3 2
4 1```

### 输出

```
0
0
0
1
0
0
1
2
4```

# AI分析结果

### 综合分析与结论
这些题解思路相近，均围绕动态添加奶牛并处理舒适奶牛问题。核心思路是每次添加奶牛后，检查其自身及周边奶牛是否舒适，若舒适则添加奶牛使其不舒适，并递归处理新添加奶牛周边情况。主要算法为深度优先搜索（DFS）或广度优先搜索（BFS）。

解决的难点在于处理坐标可能为负的情况，各题解通过给坐标加上常数避免数组越界，对所需添加常数的大小分析略有不同。部分题解还考虑到已添加奶牛可能再次被添加的情况，通过标记或判断避免重复计算。

### 所选的题解
1. **作者：_zy_ (5星)**
    - **关键亮点**：思路清晰，代码简洁明了，直接采用动态加点和递归处理的方式，清晰展示了每步操作。
    - **核心代码**：
```cpp
void dfs(int x,int y)
{
    int flag=0;
    int t_x,t_y;
    if(!map[x][y])    return ;
    for(int i=1;i<=4;i++) {
        int xx=x+dx[i];
        int yy=y+dy[i];
        if(map[xx][yy]) flag++;
        else t_x=xx,t_y=yy;
    }
    if(flag!=3)    return ;
    else {
        map[t_x][t_y]=1;
        cnt++;
        for(int i=0;i<=4;i++)
            dfs(t_x+dx[i],t_y+dy[i]);
    }
}
```
    - **核心思想**：在 `dfs` 函数中，先判断当前点是否为奶牛，若不是则返回。接着检查其四周奶牛数量，若为3则在空缺处添加奶牛，并递归处理新添加奶牛及其周边点。
2. **作者：Sheng_Horizon (4星)**
    - **关键亮点**：对算法选用和性质分析详细，不仅提到BFS和DFS两种思路，还深入分析被动添加牛的性质，对坐标偏移量计算详细。
    - **个人心得**：详细讨论了数组下标处理问题，通过分析图形得出坐标至少加501的结论。
    - **核心代码**：
```cpp
void update(int a,int b){
    for(int i=1;i<=4;i++){
        if(cow[a+dx[i]][b+dy[i]]){
            cnt[a][b]++;
            cnt[a+dx[i]][b+dy[i]]++;
        }
    }
}

void add_cow(int a,int b){
    queue<PII> que;
    for(int i=0;i<=4;i++){
        if (cnt[a+dx[i]][b+dy[i]]==3) que.push({a+dx[i],b+dy[i]});
    }
    while(!que.empty()){
        PII t=que.front();que.pop();
        int x=t.first,y=t.second;
        if(cnt[x][y]!=3) continue;
        int xx,yy;
        for(int i=1;i<=4;i++){
            if(!cow[x+dx[i]][y+dy[i]]){
                xx=x+dx[i];
                yy=y+dy[i];
                cow[xx][yy]=2;
                update(xx,yy);
                ans++;
                for(int i=0;i<=4;i++){
                    if (cnt[xx+dx[i]][yy+dy[i]]==3) que.push({xx+dx[i],yy+dy[i]});
                }
                break;
            }
        }
    }
}
```
    - **核心思想**：`update` 函数用于记录每个点周围奶牛数量。`add_cow` 函数采用BFS，将舒适奶牛加入队列，处理队列中的奶牛，在其空缺处添加奶牛，更新相关奶牛周围数量，若新添加奶牛导致其他奶牛舒适则加入队列继续处理。
3. **作者：Mars_Dingdang (4星)**
    - **关键亮点**：思路阐述清晰，结合图示说明，对时间复杂度分析合理，代码注释详细。
    - **核心代码**：
```cpp
inline void dfs(int x, int y) {
    if(!mp[x][y]) return ;
    int res = 0;
    PII rest;
    rep(k, 1, 4) {
        int nx = x + dx[k], ny = y + dy[k];
        if(mp[nx][ny]) res ++;
        else rest = {nx, ny};
    }
    if(res!= 3) return;
    mp[x = rest.first][y = rest.second] = 1;
    cnt ++;
    rep(k, 0, 4) {
        int nx = x + dx[k], ny = y + dy[k];
        dfs(nx, ny);
    }
}
```
    - **核心思想**：`dfs` 函数先判断当前点是否有奶牛，若无则返回。统计四周奶牛数量，若为3则在空缺处添加奶牛，增加计数器并递归处理新添加奶牛及其周边点。

### 最优关键思路或技巧
1. **动态处理**：根据每次添加奶牛动态更新状态，利用前一步结果计算下一步，减少重复计算。
2. **递归或迭代**：使用DFS或BFS处理新添加奶牛对周边的影响，确保所有奶牛都不舒适。
3. **坐标处理**：通过给坐标加上合适常数避免数组越界，同时考虑常数大小对空间利用的影响。

### 同类型题或类似算法套路
此类题目属于动态图维护问题，类似套路包括：
1. 动态添加或删除元素，维护某种图的性质（如连通性、特定节点关系等）。
2. 利用递归或迭代处理新元素对已有元素的影响，确保满足题目要求。

### 推荐题目
1. **P1330 封锁阳光大学**：涉及图的动态染色，保证相邻节点颜色不同，与本题动态维护奶牛状态类似。
2. **P2038 无线网络发射器选址**：在二维平面上动态计算信号覆盖情况，和本题在二维平面处理奶牛位置有相似之处。
3. **P1162 填涂颜色**：通过对二维数组的遍历和递归处理，确定区域边界，与本题递归处理奶牛状态思路相近。 

---
处理用时：47.42秒
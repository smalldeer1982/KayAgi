# 题目信息

# [USACO22FEB] Email Filing S

## 题目描述

Farmer John 在整理他的收件箱时落后了。他的屏幕布局如下：屏幕左侧是文件夹的垂直列表，右侧是邮件的垂直列表。总共有 $M$ 个文件夹，编号为 $1 \ldots M$（$1 \leq M \leq 10^4$）。他的收件箱目前包含 $N$ 封邮件，编号为 $1 \ldots N$（$1 \leq N \leq 10^5$）；第 $i$ 封邮件需要归档到文件夹 $f_i$（$1 \leq f_i \leq M$）。

FJ 的屏幕很小，因此他一次只能查看 $K$ 个文件夹和 $K$ 封邮件（$1 \leq K \leq \min(N, M)$）。初始时，他的屏幕显示左侧的文件夹 $1 \ldots K$ 和右侧的邮件 $1 \ldots K$。为了访问其他文件夹和邮件，他需要滚动这些列表。例如，如果他在文件夹列表中向下滚动一个位置，屏幕将显示文件夹 $2 \ldots K+1$，再向下滚动一个位置则显示文件夹 $3 \ldots K+2$。当 FJ 将一封邮件拖入文件夹时，该邮件会从邮件列表中消失，其后的邮件会向前移动一个位置。例如，如果当前显示的邮件是 $1, 2, 3, 4, 5$，而 FJ 将邮件 $3$ 拖入其对应的文件夹，邮件列表将显示 $1, 2, 4, 5, 6$。FJ 只能将邮件拖入其需要归档的文件夹。

不幸的是，FJ 的鼠标滚轮坏了，他只能向下滚动，不能向上滚动。唯一能实现类似向上滚动的效果是，当他查看邮件列表的最后 $K$ 封邮件时，如果他归档了其中一封邮件，邮件列表将再次显示尚未归档的最后 $K$ 封邮件，从而将最上面的邮件向上滚动一个位置。如果剩余的邮件少于 $K$ 封，则显示所有剩余的邮件。

请帮助 FJ 判断是否能够归档所有邮件。

## 说明/提示

- 在输入 2-10 中，所有子用例的 $M$ 之和不超过 $10^3$。
- 在输入 11-12 中，没有额外限制。

## 样例 #1

### 输入

```
6
5 5 1
1 2 3 4 5
5 5 1
1 2 3 5 4
5 5 1
1 2 4 5 3
5 5 2
1 2 4 5 3
3 10 2
1 3 2 1 3 2 1 3 2 1
3 10 1
1 3 2 1 3 2 1 3 2 1```

### 输出

```
YES
YES
NO
YES
YES
NO```

# AI分析结果

• 综合分析与结论：这几道题解均围绕如何判断能否归档所有邮件展开。思路上都基于贪心思想，即保证一个文件夹的所有邮件都归档后，才滑动文件夹列表。算法要点在于合理使用数据结构来模拟邮件和文件夹的操作过程。解决难点主要是处理邮件和文件夹列表的滑动以及邮件归档的逻辑。
- sprads的题解：
  - 星级：4星
  - 关键亮点：思路清晰，详细阐述性质和流程。使用`set`维护屏幕，`queue`维护每个文件夹在屏幕中的邮件，`stack`维护滚出屏幕邮件，逻辑严谨。
  - 核心代码实现思想：枚举文件夹，处理新进入屏幕文件夹的邮件，通过两种情况（屏幕下方有邮件和无邮件）处理邮件归档，判断是否能成功枚举完所有文件夹。
```cpp
bool check(){
    int j = 1,t;
    set<int>::iterator it;
    for(int i = 1;i <= m;i++){
        t = i + K - 1;
        if(t <= m){
            c[t] -= q[t].size();
            while(!q[t].empty()){
                int x = q[t].front(); 
                q[t].pop();
                sce.erase(x);
            }
        }
        while(c[i]){
            int x = j <= n? j : st[top--];
            if(sce.size() == K){
                if(j <= n){
                    it = sce.begin();
                    st[++top] = *it;
                    q[f[*it]].pop();
                    sce.erase(*it);
                }
                else return 0;
            }
            if(f[x] <= t)
                c[f[x]]--;
            else{
                sce.insert(x);
                q[f[x]].push(x);
            }
            if(j <= n)j++;
        }
    }
    return 1;
}
```
- dino的题解：
  - 星级：4星
  - 关键亮点：使用`list`处理邮件屏幕（因有删除操作），`stack`处理屏幕上方未归类邮件，思路简洁明了，通过三步走实现模拟+贪心。
  - 核心代码实现思想：先铺满邮件屏幕，枚举文件夹屏幕开头位置，在`list`中能归就归，不能归则下移邮件，栈中文件下落，最后判断邮件是否全部归档。
```cpp
for(int i = 1; i <= m - k + 1; ++i){ 
    list<int>::iterator it, tmp;
    for(it = lst.begin(); it!= lst.end();){
        tmp = it;
        ++it; 
        if(*tmp >= i && *tmp <= i + k - 1){
            lst.erase(tmp);
            vis[*tmp]--;
        }
    }
    while(j <= n && vis[i]){
        if(lst.size() == k){
            st.push(lst.front());
            lst.pop_front();
        }
        if(!(d[j] >= i && d[j] <= i + k - 1)) 
            lst.push_back(d[j]);
        else
            vis[d[j]]--;
        j++;
    }
    if(j > n){
        while(lst.size() < k && st.size() > 0){
            if(!(st.top() >= i && st.top() <= i + k - 1))
                lst.push_back(st.top());
            else
                vis[st.top()]--;
            st.pop();
        }
    }
}
```
- 内拉组里的题解：
  - 星级：4星
  - 关键亮点：采用双指针维护邮件列表，思路直接，通过优化减少无效遍历次数，给出时间和空间复杂度分析。
  - 核心代码实现思想：用双指针保证区间内未被删除邮件有`k`条，能归档就归档，文件夹无邮件可归则下移，挪动双指针，判断是否所有邮件都已归档。
```cpp
while (cnt < n)
{
    int flag = 0;
    for (int i = l; i <= r; i++) if (!vis[i])
    {
        if (now <= f[i] && f[i] <= now + k - 1)
        {
            cnt++;
            buc[f[i]]--;
            flag = 1;
            vis[i] = 1;
            if (r < n)
                while (vis[++r]);
            else
                while (vis[--l]);
        }
    }
    while (!buc[now])
    {
        flag = 1;
        now++;
    }
    while (vis[l])
        l++;
    if (!flag)
    {
        if (r < n)
        {
            int tmp = r;
            while (l <= tmp)
            {
                while (vis[++l]);
                while (vis[++r]);
            }
        }
        else
            break;
    }
}
```
• 最优关键思路或技巧：利用贪心策略，保证文件夹所有邮件归档后才滑动文件夹列表。在数据结构选择上，根据操作特点选择合适的数据结构，如`set`用于快速查找和删除（sprads），`list`处理频繁删除操作（dino），双指针优化遍历（内拉组里）。
• 可拓展之处：同类型题可拓展到其他具有类似滑动窗口和元素操作限制的场景，类似算法套路是基于贪心思想，结合合适的数据结构模拟操作过程。
• 洛谷相似题目推荐：
  - P1241 括号序列
  - P1080 [NOIP2012 提高组] 国王游戏
  - P2123 皇后游戏
• 个人心得摘录与总结：
  - dino：发现代码中一处`m`写成`n`的错误，拖了半年才修改，提醒注意代码细节，及时检查修改错误。 

---
处理用时：44.80秒
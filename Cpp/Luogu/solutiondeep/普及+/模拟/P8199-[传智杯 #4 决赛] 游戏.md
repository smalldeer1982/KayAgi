# 题目信息

# [传智杯 #4 决赛] 游戏

## 题目背景

小智正在看 B 站非著名 up 主脚踢喷火幼儿园（下称喷火）和他的朋友 ATA_Radio_STN 和 sltheen 正在游玩著名游戏《PLAYERUNKNOWN’S BATTLEGROUNDS》（绝地求生：大逃杀）。

## 题目描述

喷火刚刚跳伞落地，周围危机四伏，他的手中有一个初始背包，他捡到的所有物资都会装在这个背包里，游戏地图被简化为一个 $n \times m$ 的网格图，每个格子里要么是物资，要么是敌人。

物资分为主/副武器和弹药，其中弹药又分为子弹与投掷物。每种武器会对应使用某种子弹。例如：Beryl M762 突击步枪使用 7.62mm 子弹，M416 突击步枪使用 5.56mm 子弹，而 AKM 突击步枪也使用 7.62mm 子弹。

当喷火走到一个含有物资的格子的时候，他会拾起地上的物资并放入背包。但背包容量有限，因此当背包装满的时候，他将会扔掉一部分物资以装下新的物资。他将按照以下规则丢弃物资：
1.	如果捡到的是武器，那么按照霰弹枪>突击步枪>射手步枪>栓动步枪>空手的优先级进行替换。优先替换主武器，且主武器优先级必须严格高于副武器。如果替换主武器，那么替换下来的主武器被**直接丢弃**，不再用其替换副武器。
2.	若有不需要的子弹（指主副武器均不使用的子弹），最优先丢掉这些子弹，直至空间足够装下新的物资。
3.	若丢掉全部不需要子弹后空间仍旧不足，或有多种不需要的子弹，优先丢掉最晚拾取时间最早的弹药（包括主副武器使用的子弹和投掷物），直至空间足够装下新的物资（需要注意的是，即使新物资是「不需要的子弹」，在丢掉所有原有的「不需要的子弹」后如果背包空间还是不够，则喷火依然会丢掉其他弹药直到捡起所有「不需要的子弹」）。
4.	无论捡到的是新物资，还是已经有的物资，该物资的最晚拾取时间都将被更新为当前时间点。
5.	武器最多同时持有两种，即主/副武器，同优先级的主/副武器不进行替换。

每个格子的物资只会拾取一次。当第二次进入某个格子的时候，物品不会刷新，即不会捡起上次在这个格子丢掉的物品，也不会再次捡到初始时的物品。

当喷火走到含有敌人的格子的时候，他会与敌人进行战斗，他的战斗力很强悍，只需要有足够的子弹即可消灭敌人。每个敌人有两个参数 $a,b$，代表需要消耗 $a$ 发主武器子弹，若主武器子弹不够，则不消耗主武器子弹，而消耗 $b$ 发副武器子弹。若主副武器均没有足够子弹，则喷火被敌人反杀，然后敌人会在喷火的盒子上做蹲起嘲讽他。

每个格子的敌人只会出现一次。如果第二次进入某一个有敌人的格子，则什么都不会发生。

现在，喷火跳在了第一行第一列的格子上，ATA_Radio_STN 已经为喷火摸清了地图形势，而 sltheen 会给喷火下指示，喷火想知道，当他执行完最后一条指示之后，他是否还存活，若存活，按照最晚拾取时间时间从早到晚，输出背包内物品种类和数量，若死亡，输出他死亡格子的坐标。

下附可能出现的物资、物资类别、物资使用的子弹种类、物资所需空间以及物资对应编号。

武器：
| 武器名称 | 武器类型| 使用的子弹类型 | 编号 |
| --- | --- | ---  | ---|
| 空手 | 空手 | N/A | 0|
|BerylM762|突击步枪|7.62mm子弹|1|
|AKM|突击步枪|7.62mm子弹|2|
|SKS|射手步枪|7.62mm子弹|3|
|Kar98K|栓动步枪|7.62mm子弹|4|
|M416|突击步枪|5.56mm子弹|5|
|MK12|射手步枪|5.56mm子弹|6|
|Mini14|射手步枪|5.56mm子弹|7|
|S686|霰弹枪|12号霰弹|8|
|DBS|霰弹枪|12号霰弹|9|

弹药
|弹药名称| 类型 | 占用空间 | 编号 |
| - | - | - | - |
|FragGrenade|投掷物| 5  |   10|
|SmokeGrenade| 投掷物 |    4|    11|
|MolotovCocktail |投掷物  | 3 |    12|
|Flashbang |投掷物        | 2    | 13|
|7.62mm |子弹 |0.2|                14|
|5.56mm| 子弹| 0.1                |15|
|3in（12号霰弹）| 子弹| 0.5|                     16|

请注意，上表中子弹的「占用空间」表示一发子弹所占用的空间。

另外，敌人在地图上的编号为 17。



## 说明/提示

### 数据规模与约定

对于全部的测试点，保证：
- $1 \leq n, m \leq 100$，且 $1 \leq  n \times m \leq 100$。
- $1 \leq k \leq 500$，$1 \leq t,a,b  \leq 200$。
- $1 \leq x \leq 16$，$1 \leq y \leq 5000$。
- $1 \leq op \leq 4$。
- 数据保证每个格子内只有一种物资（或一个敌人），且背包能够装下任意一格的物资。

## 样例 #1

### 输入

```
3 3 60 8
1 1
14 300
15 30
5 1
10 1
17 11 10
17 10 10
17 10 10
15 10
4
4
2
3
3
2
4
4
```

### 输出

```
1
0
14 254
10 1
15 12
```

# AI分析结果

### 综合分析与结论
这些题解均围绕游戏场景的模拟展开，核心思路是依据题目给定的规则，对角色在地图中的行动、物资拾取、武器替换、弹药处理及战斗过程进行模拟。

算法要点包括：
1. **数据存储**：用数组存储地图信息、背包状态、武器优先级及所需子弹类型等。
2. **物资处理**：按规则替换武器、处理背包空间不足时丢弃物资的情况。
3. **战斗模拟**：根据背包子弹数量判断能否战胜敌人。

难点在于：
1. **精确实现规则**：如严格按照武器优先级替换武器，按特定顺序丢弃弹药。
2. **避免浮点误差**：子弹占用空间的处理。

多数题解思路清晰，通过合理的数据结构和逻辑判断实现模拟，但在代码可读性和优化程度上存在差异。

### 所选的题解
#### 作者：一扶苏一 (5星)
- **关键亮点**：思路清晰简洁，代码结构紧凑。利用数组存储各类数据，通过定义函数判断弹药是否 “有用”，并依据规则进行物资的拾取与丢弃。对浮点误差处理巧妙，将容量和占用空间乘10转换为整数运算。
- **个人心得**：无
```cpp
// 核心代码片段
const int maxn = 105;
int n, m, s, t, w1, w2, lst;
std::array<std::array<int, maxn>, maxn> type, a, b, vis;
std::array<int, maxn> tm, arr, cnt;
const std::array<int, 5> dx{0, -1, 1, 0, 0}, dy{0, 0, 0, -1, 1};
const std::array<int, 10> use{0,  14, 14, 14, 14, 15, 15, 15, 16, 16}, level{5, 2, 2, 3, 4, 2, 3, 3, 1, 1};
const std::array<int, 17> weight{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 40, 30, 20, 2, 1, 5};

inline bool used(int x) { return x && ((x <= 13)? true : (use[w1] == x || use[w2] == x)); }
inline bool cmp(const int x, const int y) { return tm[x] > tm[y]; }

void work(int curx, int cury) {
    vis[curx][cury] = true;
    if (type[curx][cury] == 17) {
        if (cnt[use[w1]] >= a[curx][cury]) {
            cnt[use[w1]] -= a[curx][cury];
            lst += a[curx][cury] * weight[use[w1]];
        } else if (cnt[use[w2]] >= b[curx][cury]) {
            cnt[use[w2]] -= b[curx][cury];
            lst += b[curx][cury] * weight[use[w2]];
        } else {
            std::cout << curx << ' ' << cury << '\n';
            exit(0);
        }
    } else if (type[curx][cury] < 10) {
        if (level[w1] > level[type[curx][cury]]) w1 = type[curx][cury];
        else if (level[w1] < level[type[curx][cury]] && level[w2] > level[type[curx][cury]]) w2 = type[curx][cury];
    } else {
        lst -= a[curx][cury] * weight[type[curx][cury]];
        for (int i = 0; lst < 0; i = 0) {
            for (int p = 10; p < 17; ++p) if (cnt[p]) 
                if ((!cnt[i]) || (used(p) < used(i)) || ((used(p) == used(i)) && (tm[p] > tm[i]))) i = p;
            int tmp = std::min(cnt[i], (-lst) / weight[i] + ((lst % weight[i])? 1 : 0));
            lst += tmp * weight[i];
            cnt[i] -= tmp;
        }
        tm[type[curx][cury]] = t;
        cnt[type[curx][cury]] += a[curx][cury];
    }
}
```
核心实现思想：`work`函数处理每个格子的情况，遇到敌人根据主副武器子弹判断能否战胜；遇到武器按优先级替换；遇到弹药先尝试捡起，空间不足时按规则丢弃已有弹药。

#### 作者：wuhan1234 (4星)
- **关键亮点**：编程思路阐述详细，对每个数组的定义和用途说明清晰。代码逻辑严谨，通过多个函数分别处理拾取、战斗等不同场景，增强了代码可读性。
- **个人心得**：对题目中投掷类弹药的作用提出疑问，认为可改进题目设定。
```cpp
// 核心代码片段
void pickUp()          // 捡起格子(x,y)中的弹药
{
    int space=needSpace[map[x][y][0]]*map[x][y][1];  // 计算格子(x,y)处弹药需占用空间
    int need1=needBullet[mw];
    int need2=needBullet[sw];
    if (used+space<=k)        // 背包剩余空间可以装下格子(x,y)处的弹药
    {
        used+=space;
        bp[map[x][y][0]][1]+=map[x][y][1];
        bp[map[x][y][0]][2]=times;
    }
    else                      // 背包剩余空间不够，需要先腾出空间，再装格子(x,y)处的弹药
    {
        int flag1=1,flag2=0;  // flag1=1表示找的是主副武器均不需要的子弹
        int i,mint,id,loss;
        while (used+space>k)
        {
            if (flag1)
            {
                flag2=1;
                mint=1e9;
                for (i=14;i<=16;i++)  // 找主副武器均不需要的最晚拾取时间最早的弹药
                {
                    if (bp[i][1] && i!=need1 && i!=need2)
                    {
                        if (mint>bp[i][2])
                        {
                            mint=bp[i][2];   id=i;
                            flag2=0;
                        }
                    }
                }
                if (flag2)    // 背包中找不到主副武器均不需要的子弹
                {
                    flag1=0;  continue;
                }
                loss=(used+space-k+needSpace[id]-1)/needSpace[id];// 计算需要丢掉的弹药数量
                loss=loss<bp[id][1]?loss:bp[id][1];      // 背包中实际可以丢掉的弹药数量
                used-=needSpace[id]*loss;
                bp[id][1]=bp[id][1]-loss;
            }
            else
            {
                mint=1e9;
                for (i=10;i<=16;i++)
                {
                    if (bp[i][1])
                    {
                        if (mint>bp[i][2])
                        {
                            mint=bp[i][2];  id=i;
                        }
                    }
                }
                loss=(used+space-k+needSpace[id]-1)/needSpace[id];  // 计算需要丢掉的弹药数量
                loss=loss<bp[id][1]?loss:bp[id][1];      // 背包中实际可以丢掉的弹药数量
                used-=needSpace[id]*loss;
                bp[id][1]=bp[id][1]-loss;
            }
        }
        used+=space;      // 捡起格子中的弹药装入背包
        bp[map[x][y][0]][1]+=map[x][y][1];
        bp[map[x][y][0]][2]=times;
    }
}

void fight()           // 在格子(x,y)中与敌人战斗
{
    int a,b;
    a=bp[needBullet[mw]][1];
    b=bp[needBullet[sw]][1];
    if (a>=map[x][y][1])    // 有足够的主武器子弹，消耗a发主武器子弹
    {
        bp[needBullet[mw]][1]-=map[x][y][1];
        used-=needSpace[needBullet[mw]]*map[x][y][1];
    }
    else if (b>=map[x][y][2])  // 主武器子弹不够，有足够的副武器子弹，消耗b发副武器子弹
    {
        bp[needBullet[sw]][1]-=map[x][y][2];
        used-=needSpace[needBullet[sw]]*map[x][y][2];
    }
    else KO=1;   // 主副武器均没有足够子弹，被敌人反杀
}

void deal()   // 进入格子(x,y)后进行相应的处理
{
    if (vis[x][y]) return;
    vis[x][y]=1;
    if (map[x][y][0]>=1&&map[x][y][0]<=9)  // 格子(x,y)中是武器,进行武器替换
    {
        int l1,l2,l3;
        l1=level[mw];
        l2=level[sw];
        l3=level[map[x][y][0]];
        if (l3>l1)    mw=map[x][y][0];
        else if (l3<l1 && l3>l2) sw=map[x][y][0];
    }
    else if (map[x][y][0]>=10&&map[x][y][0]<=16)  // 格子(x,y)中是弹药,腾出空间捡起弹药
        pickUp();
    else if (map[x][y][0]==17)                   // 格子(x,y)中是敌人，进行战斗
        fight();
}
```
核心实现思想：`pickUp`函数处理弹药拾取，空间不足时按规则丢弃弹药；`fight`函数处理战斗，根据子弹数量判断战斗结果；`deal`函数根据格子类型调用相应函数处理。

#### 作者：kardsOI (4星)
- **关键亮点**：详细列举了容易出错的点，对理解题目和实现代码有很大帮助。代码中通过注释对优化技巧进行说明，增强了可读性。
- **个人心得**：无
```cpp
// 核心代码片段
void attack()
{
    if(buln[needn[zgun]]>map2[ny][nx])
    {
        buln[needn[zgun]]-=map2[ny][nx];
        used-=map2[ny][nx]*v[needn[zgun]];
    }
    else if(buln[needn[fgun]]>map3[ny][nx])
    {
        buln[needn[fgun]]-=map3[ny][nx];
        used-=map3[ny][nx]*v[needn[fgun]];
    }
    else 
    {
        killed=1;
        dx=nx;
        dy=ny;
    }
    map1[ny][nx]=0;
}

void bullet()
{
    map1[ny][nx]-=9;//编号-9以适应记录的代号
    need=v[map1[ny][nx]]*map2[ny][nx];
    if(need+used<=kn)
    {
        buln[map1[ny][nx]]+=map2[ny][nx];
        bult[map1[ny][nx]]=++cn;
        used+=need;
        map1[ny][nx]=0;
        return;
    }
    used+=need;
    do//超过背包容量,先从非武器弹药找 
    {
        id=0;//用来替换的子弹 
        for(int i=5;i<=7;i++)
        {
            if(buln[i]&&needn[zgun]!=i&&needn[fgun]!=i&&bult[i]<bult[id]) id=i;
        }
        goal=used-kn;//需要空间数量 
        if(buln[id]*v[id]<=goal)//退完还不够或者刚好，全退了 
        {
            used-=buln[id]*v[id];
            buln[id]=0;
            continue;
        }
        if(goal%v[id]==0)
        {
            used=kn;
            buln[id]-=goal/v[id];
        }
        else
        {
            used=used-(goal/v[id]+1)*v[id];//不整除则多抛弃一发弹药 
            buln[id]-=goal/v[id]+1;
        }
    }
    while(used>kn&&id!=0);
    if(used>kn)
    do//还超过背包容量,全局找！ 
    {
        id=0;//用来替换的子弹 
        for(int i=1;i<=7;i++)
        {
            if(buln[i]&&bult[i]<bult[id]) id=i;
        }
        goal=used-kn;//需要空间数量 
        if(buln[id]*v[id]<=goal)//退完还不够或者刚好，全退了 
        {
            used-=buln[id]*v[id];
            buln[id]=0;
            continue;
        }
        if(goal%v[id]==0)
        {
            used=kn;
            buln[id]-=goal/v[id];
        }
        else
        {
            used=used-(goal/v[id]+1)*v[id];//不整除则多抛弃一发弹药 
            buln[id]-=goal/v[id]+1;
        }
    }
    while(used>kn&&id!=0);
    buln[map1[ny][nx]]+=map2[ny][nx];
    bult[map1[ny][nx]]=++cn;
    map1[ny][nx]=0;
}

void gun()
{
    if(par[map1[ny][nx]]>par[zgun]) zgun=map1[ny][nx];
    else if(par[map1[ny][nx]]>par[fgun]&&par[map1[ny][nx]]<par[zgun]) fgun=map1[ny][nx];
    map1[ny][nx]=0;
}
```
核心实现思想：`attack`函数处理战斗，`bullet`函数处理弹药拾取及背包空间不足时丢弃弹药，`gun`函数处理武器替换。

### 最优关键思路或技巧
1. **整数运算避免浮点误差**：将子弹占用空间等数据乘以10，转换为整数运算，有效避免浮点误差。
2. **合理使用数组存储数据**：通过数组存储地图信息、武器优先级、所需子弹类型等，方便数据的管理和调用。
3. **模块化处理逻辑**：将不同功能（如拾取、战斗、武器替换）封装成函数，使代码结构更清晰，可读性增强。

### 可拓展之处
此类模拟题通常围绕特定场景的规则展开，可拓展到其他游戏场景模拟、生产调度模拟等。类似算法套路是先明确规则，然后设计合适的数据结构存储信息，再按照规则逐步实现模拟过程。

### 相似知识点洛谷题目
1. **P1032 [NOIP2002 普及组] 字串变换**：通过模拟字符串变换规则解决问题，考察对复杂规则的模拟实现。
2. **P1880 [NOI1995] 石子合并**：在一定规则下模拟石子合并过程，涉及数据结构的运用和逻辑模拟。
3. **P2036 [COCI2008-2009#2] PERKET**：根据给定规则模拟食材组合，计算属性值，需要合理处理数据和实现规则。

### 个人心得摘录与总结
1. **wuhan1234**：对题目中投掷类弹药的设定提出疑问，认为可优化为宝物类物资，以增加题目的合理性和趣味性。这提示在解题时不仅要关注代码实现，还可思考题目本身的合理性和可改进之处。
2. **qusia_MC**：分享了多个调试中遇到的坑点，如出生点拾取、主副武器优先级、走过格子的处理、走法对应关系、投掷物属性及子弹数量更新等。这些经验强调了仔细读题和全面考虑各种情况的重要性，在解决类似模拟题时，需对每个细节进行严格处理，避免遗漏或误解规则。 

---
处理用时：120.67秒
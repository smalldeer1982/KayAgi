# 题目信息

# 「WHOI-2」彗星蜜月

## 题目背景

![](bilibili:BV11x411Q7PY)

看完这首 mv 的前奏之后你应该知道 $f$ 是什么鬼了（误）。

## 题目描述

定义 $f(x)$ 是 $x$ 的各位数码翻转以后形成的数。

例如：

- $f(12323)=32321$
- $f(114514)=415411$
- $f(250)=52$
---

给定一个 $n$。求最大的 $k$，使得对于所有处于 $[1,k]$ 区间中的正整数 $m$，有 $f(m)\leq n$。

## 说明/提示

对于测试样例 $1$：
$f(1)=1,f(2)=2,f(3)=3,f(4)=4,f(5)=5,f(6)=6,f(7)=7,f(8)=8,f(9)=9,f(10)=1,f(11)=11,f(12)=21$。所以 $k$ 最大为 $11$。

---
**本题采用捆绑测试**

- $\text{subtask1(10pts)}:1\leq T,n\leq10^3$。
- $\text{subtask2(30pts)}:1\leq n\leq10^6$。
- $\text{subtask3(40pts)}:1\leq n\leq10^9$。
- $\text{subtask4(20pts)}:$ 无特殊限制。

对于 $100\%$ 的数据，$1\leq T\leq10^5,1\leq n\leq10^{18}$。

提示：`unsigned long long` 可以储存 $0$ 到 $18,446,744,073,709,551,615(2^{64}-1)$ 的自然数。 

## 样例 #1

### 输入

```
3
12
991
114514```

### 输出

```
11
298
100001```

## 样例 #2

### 输入

```
2
99999
99998```

### 输出

```
100000
99998```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找最大的 $k$，使得对于所有处于 $[1,k]$ 区间中的正整数 $m$，有 $f(m)\leq n$ 这一问题。大部分题解思路是先找到最小的 $m$ 使得 $f(m)>n$，然后输出 $m - 1$。不同题解在寻找这个最小 $m$ 的方法上有所差异，有的通过分类讨论 $n$ 的不同形式找规律，有的采用贪心策略，有的利用二分查找等。

### 所选的题解
1. **作者：liangbowen（5星）**
    - **关键亮点**：思路清晰，采用贪心策略。通过保证构造的数 $p$ 末尾不存在 $0$，利用 $f(f(p)) = p$ 的性质，贪心地枚举 $f(p)$，构造出满足条件且相对较小的数，时间复杂度为 $O(T \times len(n))$，代码实现简洁明了。
    - **核心代码片段**：
```cpp
void solve()
{
    LL n, minn = 9e18;
    scanf("%lld", &n);
    int len = LEN(n);
    for (int i = 0; i <= len; i++)
    {
        LL p = pow(10, (LL)i); //第 i 位加一。 
        LL ni = n - (n % p) + p; //后面的位全部变成 0。 
        if (ni % 10 == 0) ni++;  // 最后一位变成 1。 
        minn = min(minn, f(ni));
    }
    printf("%lld\n", minn - 1);
}
```
    - **核心实现思想**：遍历 $n$ 的每一位，对每一位进行加一操作并将其后的位变为 $0$，同时保证最后一位为 $1$，构造出可能的 $f(p)$，取其中最小的 $f(ni)$ 减 $1$ 作为答案。

2. **作者：Error_Yuan（5星）**
    - **关键亮点**：思路严谨，通过分类讨论 $n$ 的各种情况，给出了清晰的构造最小 $m$ 使得 $f(m)>n$ 的方法，时间复杂度为 $O(T\log W)$，代码简洁高效。
    - **核心代码片段**：
```cpp
void work() {
    if (tot == 1 && a[1] == 9) {
        printf("10");
        return;
    }
    if (tot == 1) {
        putchar(a[1] + '0');
        return;
    }
    int cur = 1;
    while (a[cur] == 9) cur++;
    if (cur > tot) {
        putchar('1');
        for (int i = 1; i <= tot; i++) putchar('0');
        return;
    }
    if (cur == tot) {
        a[tot] += 1;
        reverse(a + 1, a + tot + 1);
        a[tot] -= 1;
        for (int i = 1; i <= tot; i++) putchar(a[i] + '0');
        return;
    }
    int tmp = cur + 1;
    while (a[tmp] == 0 && tmp <= tot) tmp++;
    if (tmp > tot) {
        a[tot] = 1;
        reverse(a + 1, a + tot + 1);
        a[tot] -= 1;
        for (int i = 1; i <= tot; i++) putchar(a[i] + '0');
        return;
    }
    a[cur] += 1;
    for (int i = cur + 1; i < tot; i++) a[i] = 0;
    a[tot] = 1;
    reverse(a + 1, a + tot + 1);
    a[tot] -= 1;
    for (int i = 1; i <= tot; i++) putchar(a[i] + '0');
    return;
}
```
    - **核心实现思想**：根据 $n$ 的位数、首位数字、是否全为 $9$ 等情况分别构造 $m$。如 $n$ 只有一位且为 $9$ 时，$m = 10$；$n$ 全为 $9$ 时，$m = n + 2$ 等，最后输出 $m - 1$。

3. **作者：rzh123（4星）**
    - **关键亮点**：通过预处理 $n$ 中开头连续 $9$ 的个数和结尾连续 $0$ 的个数，对 $n$ 的不同情况进行细致分类讨论，每种情况分析清晰，逻辑严谨。
    - **核心代码片段**：
```cpp
while(t--){
    int c9=0,c0=0;
    scanf("%s",s+1);
    len=strlen(s+1);
    if(len==1){
        if(s[1]=='9'){
            puts("10");
        }
        else{
            puts(s+1);
        }
        continue;
    }
    for(int i=1;i<=len;++i){
        if(s[i]!='9'){
            break;
        }
        ++c9;
    }
    for(int i=len;i>=1;--i){
        if(s[i]!='0'){
            break;
        }
        ++c0;
    }
    if(c9==len){
        pc('1');
        for(int i=1;i<=len;++i) pc('0');
        puts("");
    }
    else if(c9==0){
        pc('1');
        for(int i=2;i<len;++i){
            pc('0');
        }
        if(c0==len-1) pc(s[1]-1);
        else pc(s[1]);
        puts("");
    }
    else if(c9==len-1){
        pc(s[len]+1);
        for(int i=2;i<len;++i) pc('9');
        pc('8');
        puts("");
    }
    else{
        pc('1');
        for(int i=2;i<=len-c9-1;++i) pc('0');
        if(c0+c9+1>=len) pc(s[c9+1]);
        else pc(s[c9+1]+1);
        for(int i=len-c9+1;i<len;++i) pc('9');
        pc('8');
        puts("");
    }
}
```
    - **核心实现思想**：根据 $n$ 的长度 $l$，开头连续 $9$ 的个数 $c_9$ 和结尾连续 $0$ 的个数 $c_0$ 进行分类，如 $l = 1$ 时，直接判断输出；$c_9 = l$ 时，输出 $1$ 后接 $l$ 个 $0$ 等，不同情况分别构造答案。

### 最优关键思路或技巧
- **分类讨论与贪心策略**：通过对 $n$ 的不同形式（如是否以 $9$ 开头、是否全为 $9$、是否为整十等）进行分类讨论，利用贪心思想构造出满足条件的最小 $m$，使得 $f(m)>n$，进而得到答案 $m - 1$。这种方法能有效利用数字的特性，减少不必要的计算，提高算法效率。

### 可拓展之处
同类型题可考察对数字各位的操作及规律寻找，类似算法套路是先观察数字操作后的规律，然后通过分类讨论或贪心策略解决问题。例如对于一些定义了特殊数字变换规则，求满足某种条件的最大或最小数字的题目，可以借鉴这种思路。

### 推荐题目
- [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：通过对数字操作规则的分析，寻找满足条件的数字个数，考察对数字规律的探索。
- [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)：根据数字 $0$ 和 $1$ 的分布及移动规则，求解满足条件的路径相关问题，涉及对数字组合和规则的分析。
- [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)：结合斐波那契数列和公约数的性质，通过寻找规律解决问题，锻炼对数字性质和规律的运用能力。

### 个人心得摘录与总结
暂无个人心得相关内容。 

---
处理用时：67.69秒
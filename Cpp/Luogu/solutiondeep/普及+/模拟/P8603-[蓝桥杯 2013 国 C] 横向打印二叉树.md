# 题目信息

# [蓝桥杯 2013 国 C] 横向打印二叉树

## 题目背景

二叉树可以用于排序。

## 题目描述

其原理很简单：对于一个排序二叉树添加新节点时，先与根节点比较，若小则交给左子树继续处理，否则交给右子树。

当遇到空子树时，则把该节点放入那个位置。

比如，`10 8 5 7 12 4` 的输入顺序，应该建成二叉树如图 $1$ 所示。

本题目要求：根据已知的数字，建立排序二叉树，并在标准输出中横向打印该二叉树。


## 说明/提示

样例解释 1：

![](https://cdn.luogu.com.cn/upload/image_hosting/4z42ybq4.png)

时限 1 秒, 64M。蓝桥杯 2013 年第四届国赛

## 样例 #1

### 输入

```
10 8 5 7 12 4```

### 输出

```
...|-12
10-|
...|-8-|
.......|...|-7
.......|-5-|
...........|-4```

## 样例 #2

### 输入

```
10 5 20```

### 输出

```
...|-20
10-|
...|-5```

## 样例 #3

### 输入

```
5 10 20 8 4 7```

### 输出

```
.......|-20
..|-10-|
..|....|-8-|
..|........|-7
5-|
..|-4```

# AI分析结果

• **综合分析与结论**：
    - **思路**：所有题解都将题目分为构建二叉搜索树和横向打印两部分。构建二叉搜索树时，依据输入数字与当前节点值比较，决定插入左子树或右子树，递归或循环实现。横向打印时，通过观察样例输出格式，多采用递归方式，按右根左顺序处理节点，确定每个节点在输出中的位置及周边字符。
    - **算法要点**：建树部分，明确节点插入规则；打印部分，重点在于确定节点输出位置、周边字符及父子节点间连接字符的处理。
    - **解决难点**：难点主要是处理横向打印的格式，包括确定节点前导字符数量、非根非叶节点前后特定字符添加、父子节点间竖线连接位置等。各题解通过不同方式记录节点位置、计算字符偏移量等解决。

    - **整体结论**：各题解思路相近，实现细节有差异，如插入方式（递归/循环）、打印时处理位置和字符方式。部分题解代码可读性和注释详细度更好。

• **所选的题解**：
  - **作者：LaDeX (5星)**
    - **关键亮点**：思路清晰，详细分析输出格式并通过中序遍历递归处理。代码注释详尽，利于理解。使用字符数组存储输出结果，通过计算每层增加空格数确定节点位置，对根节点和叶子节点特殊处理，最后处理父子节点间竖线连接。
    - **个人心得**：无
    - **重点代码**：
```cpp
// 插入函数
void insert(LL x, LL p){
    if (tree[p] == -1){
        tree[p] = x;
        return ;
    }
    if (x < tree[p])
        insert(x, ls(p));
    else
        insert(x, rs(p));
    return ;
}

// 数字转字符串函数
string trans(LL x){
    string res;
    while (x > 0)
        res = ((char)(x % 10 + '0')) + res, x /= 10;
    return res;
}

// 处理输出函数
void output(LL p, LL space){
    if (tree[p] == -1)
        return ;
    LL val = tree[p];

    string num = trans(val);
    LL Add = (p == 1? 0 : 2) + (LL)num.size() + 1;

    output(rs(p), space + Add);

    ++ nowL;
    line[p] = nowL;
    LL ind = 0;

    for (LL i = 1; i <= space; i ++){
        if (mp[nowL][++ ind]!= '|')
            mp[nowL][ind] = '.';
    }

    if (p!= 1){
        mp[nowL][++ ind] = '|'; mp[nowL][++ ind] = '-';
    }

    for (LL i = 0; i < (LL)num.size(); i ++)
        mp[nowL][++ ind] = num[i];

    if (tree[ls(p)]!= -1 || tree[rs(p)]!= -1)
        mp[nowL][++ ind] = '-', mp[nowL][++ ind] = '|';

    mp[nowL][++ ind] = '@';
    output(ls(p), space + Add);

    if (tree[ls(p)]!= -1){
        LL L = line[ls(p)], now = line[p];
        for (LL i = L; i >= now; i --)
            mp[i][ind - 1] = '|';
    }
    if (tree[rs(p)]!= -1){
        LL R = line[rs(p)], now = line[p];
        for (LL i = now; i >= R; i --)
            mp[i][ind - 1] = '|';
    }

    return ;
}
```
  - **作者：Wing_ (4星)**
    - **关键亮点**：分析细致，将过程清晰分为建树和横向打印。建树用引用方便更新节点编号，打印通过右根左递归确定节点行数和列数，先存储到字符数组再输出，最后处理父子节点间竖线连接。
    - **个人心得**：无
    - **重点代码**：
```cpp
// 插入函数
void insert(int &u, int x) {
    if (!u) {
        u = ++ idx;
        tr[u].val = x;
        return;
    }
    else if (x < tr[u].val) insert(tr[u].l, x);
    else if (x > tr[u].val) insert(tr[u].r, x);
}

// 打印函数
void print(int u, int sum) {
    if (!u) return;
    int t = tr[u].val, cnt = 0;
    char num[10];
    while (t) num[++ cnt] = t % 10 + '0', t /= 10;
    reverse(num + 1, num + cnt + 1);
    print(tr[u].r, sum + 3 + cnt);
    h ++;
    tr[u].h = h;
    if (sum) {
        for (int i = 1; i <= sum - 2; i++) c[h][i] = '.';
        c[h][sum - 1] = '|', c[h][sum] = '-';
    }
    tr[u].z = sum + 1;
    for (int i = 1; i <= cnt; i++) c[h][sum + i] = num[i];
    if (tr[u].l || tr[u].r) c[h][sum + cnt + 1] = '-', c[h][sum + cnt + 2] = '|';
    print(tr[u].l, sum + 3 + cnt);
}

// 连接父子节点竖线函数
void work(int u) {
    if (!u) return;
    int uh = tr[u].h;
    if (tr[u].r) {
        int rh = tr[tr[u].r].h, rz = tr[tr[u].r].z;
        for (int i = rh; i <= uh; i++) c[i][rz - 2] = '|';
    }
    if (tr[u].l) {
        int lh = tr[tr[u].l].h, lz = tr[tr[u].l].z;
        for (int i = uh; i <= lh; i++) c[i][lz - 2] = '|';
    }
    work(tr[u].l), work(tr[u].r);
}
```
  - **作者：ChampionCyan (4星)**
    - **关键亮点**：步骤明确，分为初始化与输入、插入数据、处理数据、输出答案。插入数据用循环替代递归提高效率，处理数据函数按右根左顺序递归，详细处理节点自身及与子节点连接部分。
    - **个人心得**：无
    - **重点代码**：
```cpp
// 插入函数
inline void insert(int x, int p) {
    while (node[p]!= -1) {
        if (x < node[p])
            p = lc(p);
        else
            p = rc(p);
    }
    node[p] = x;
}

// 数字转字符串函数
inline string str(int x) {
    string s;
    while (x > 0)
        s = ((char)(x % 10 + '0')) + s, x /= 10;
    return s;
}

// 处理数据函数
inline void work(int p, int len) {
    if (node[p] == -1)
        return;
    int val = node[p];
    string num = str(val);
    int front = (p == 1? 0 : 2) + (int)num.size() + 1;
    work(rc(p), len + front);
    ++ tot;
    line[p] = tot;
    int idx = 0;
    for (int i = 1; i <= len; i++)
        if (ans[tot][++ idx]!= '|')
            ans[tot][idx] = '.';
    if (p!= 1)
        ans[tot][++ idx] = '|', ans[tot][++ idx] = '-';
    for (int i = 0; i < (int)num.size(); i++)
        ans[tot][++ idx] = num[i];
    if (node[lc(p)]!= -1 || node[rc(p)]!= -1)
        ans[tot][++ idx] = '-', ans[tot][++ idx] = '|';
    ans[tot][++ idx] = eof;
    work(lc(p), len + front);
    if (node[lc(p)]!= -1) {
        int L = line[lc(p)], now = line[p];
        for (int i = L; i >= now; i--)
            ans[i][idx - 1] = '|';
    }
    if (node[rc(p)]!= -1) {
        int R = line[rc(p)], now = line[p];
        for (int i = now; i >= R; i--)
            ans[i][idx - 1] = '|';
    }
}
```

• **最优关键思路或技巧**：
    - **递归处理**：通过递归实现二叉树的构建和横向打印，利用递归特性简化代码逻辑，方便处理树的层次结构。
    - **记录位置**：用数组记录每个节点所在行数或列数，辅助确定节点在输出中的位置，便于处理父子节点间连接关系。
    - **特殊处理**：对根节点和叶子节点进行特殊处理，满足题目特定输出格式要求。

• **可拓展之处**：
同类型题常考察二叉树的各种遍历方式及特定格式输出。类似算法套路为通过观察输出格式找规律，利用递归或循环处理树节点，用数组等数据结构记录节点信息辅助输出。

• **推荐题目**：
    - [P1030 [NOIP2001 普及组] 求先序排列](https://www.luogu.com.cn/problem/P1030)
    - [P1086 [NOIP2009 普及组] 花生采摘](https://www.luogu.com.cn/problem/P1086)
    - [P1127 [NOIP2008 提高组] 重建道路](https://www.luogu.com.cn/problem/P1127)

• **个人心得摘录与总结**：无

---
处理用时：80.97秒
# 题目信息

# [CSP-J 2022] 逻辑表达式

## 题目描述

逻辑表达式是计算机科学中的重要概念和工具，包含逻辑值、逻辑运算、逻辑运算优先级等内容。

在一个逻辑表达式中，元素的值只有两种可能：$0$（表示假）和 $1$（表示真）。元素之间有多种可能的逻辑运算，本题中只需考虑如下两种：“与”（符号为 `&`）和“或”（符号为 `|`）。其运算规则如下：

$0 \mathbin{\&} 0 = 0 \mathbin{\&} 1 = 1 \mathbin{\&} 0 = 0$，$1 \mathbin{\&} 1 = 1$；  
$0 \mathbin{|} 0 = 0$，$0 \mathbin{|} 1 = 1 \mathbin{|} 0 = 1 \mathbin{|} 1 = 1$。

在一个逻辑表达式中还可能有括号。规定在运算时，括号内的部分先运算；两种运算并列时，`&` 运算优先于 `|` 运算；同种运算并列时，从左向右运算。

比如，表达式 `0|1&0` 的运算顺序等同于 `0|(1&0)`；表达式 `0&1&0|1` 的运算顺序等同于 `((0&1)&0)|1`。

此外，在 C++ 等语言的有些编译器中，对逻辑表达式的计算会采用一种“短路”的策略：在形如 `a&b` 的逻辑表达式中，会先计算 `a` 部分的值，如果 $a = 0$，那么整个逻辑表达式的值就一定为 $0$，故无需再计算 `b` 部分的值；同理，在形如 `a|b` 的逻辑表达式中，会先计算 `a` 部分的值，如果 $a = 1$，那么整个逻辑表达式的值就一定为 $1$，无需再计算 `b` 部分的值。

现在给你一个逻辑表达式，你需要计算出它的值，并且统计出在计算过程中，两种类型的“短路”各出现了多少次。需要注意的是，如果某处“短路”包含在更外层被“短路”的部分内则不被统计，如表达式 `1|(0&1)` 中，尽管 `0&1` 是一处“短路”，但由于外层的 `1|(0&1)` 本身就是一处“短路”，无需再计算 `0&1` 部分的值，因此不应当把这里的 `0&1` 计入一处“短路”。

## 说明/提示

**【样例解释 \#1】**

该逻辑表达式的计算过程如下，每一行的注释表示上一行计算的过程：

```plain
0&(1|0)|(1|1|1&0)
=(0&(1|0))|((1|1)|(1&0)) //用括号标明计算顺序
=0|((1|1)|(1&0))   //先计算最左侧的 &，是一次形如 a&b 的“短路”
=0|(1|(1&0))       //再计算中间的 |，是一次形如 a|b 的“短路”
=0|1               //再计算中间的 |，是一次形如 a|b 的“短路”
=1
```

**【样例 \#3】**

见附件中的 `expr/expr3.in` 与 `expr/expr3.ans`。

**【样例 \#4】**

见附件中的 `expr/expr4.in` 与 `expr/expr4.ans`。

**【数据范围】**

设 $\lvert s \rvert$ 为字符串 $s$ 的长度。

对于所有数据，$1 \le \lvert s \rvert \le {10}^6$。保证 $s$ 中仅含有字符 `0`、`1`、`&`、`|`、`(`、`)` 且是一个符合规范的逻辑表达式。保证输入字符串的开头、中间和结尾均无额外的空格。保证 $s$
中没有重复的括号嵌套（即没有形如 `((a))` 形式的子串，其中 `a` 是符合规范的逻辑表
达式）。

| 测试点编号 | $\lvert s \rvert \le$ | 特殊条件 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $3$ | 无 |
| $3 \sim 4$ | $5$ | 无 |
| $5$ | $2000$ | 1 |
| $6$ | $2000$ | 2 |
| $7$ | $2000$ | 3 |
| $8 \sim 10$ | $2000$ | 无 |
| $11 \sim 12$ | ${10}^6$ | 1 |
| $13 \sim 14$ | ${10}^6$ | 2 |
| $15 \sim 17$ | ${10}^6$ | 3 |
| $18 \sim 20$ | ${10}^6$ | 无 |

其中：  
特殊性质 1 为：保证 $s$ 中没有字符 `&`。  
特殊性质 2 为：保证 $s$ 中没有字符 `|`。  
特殊性质 3 为：保证 $s$ 中没有字符 `(` 和 `)`。

**【提示】**

以下给出一个“符合规范的逻辑表达式”的形式化定义：

- 字符串 `0` 和 `1` 是符合规范的；
- 如果字符串 `s` 是符合规范的，且 `s` 不是形如 `(t)` 的字符串（其中 `t` 是符合规范的），那么字符串 `(s)` 也是符合规范的；
- 如果字符串 `a` 和 `b` 均是符合规范的，那么字符串 `a&b`、`a|b` 均是符合规范的；
- 所有符合规范的逻辑表达式均可由以上方法生成。

## 样例 #1

### 输入

```
0&(1|0)|(1|1|1&0)
```

### 输出

```
1
1 2
```

## 样例 #2

### 输入

```
(0|1&0|1|1|(1|1))&(0&1&(1|0)|0|1|0)&0
```

### 输出

```
0
2 3
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕逻辑表达式求值及统计短路次数展开，思路和方法各有不同，涵盖分治、直接扫描、中缀转后缀结合表达式树等多种方式。不同题解在算法复杂度、实现难度及代码可读性上存在差异。

### 所选的题解
- **作者：SkyWave (5星)**
    - **关键亮点**：采用分治思想模拟人脑计算中缀表达式过程，无需构建表达式树或使用栈进行复杂操作，且通过预处理优化时间复杂度至O(n)，思路清晰，代码简洁高效。
    - **个人心得**：作者在看到众多复杂解法后，思考能否有更简洁方式，通过分析人脑计算过程找到分治思路，强调思考过程对解题的重要性。
    - **核心代码**：
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
#define N (int)1e6 + 1
char str[N];
int c1[N];
int c2[N];
int l1[N];
int l2[N];
int cnt1;
int cnt2;
int dfs(int l,int r) {
    if (c1[r] >= l) {
        int ans = dfs(l, c1[r] - 1);
        if (ans == 1) {
            ++cnt1;
            return 1;
        }
        return (ans | dfs(c1[r] + 1, r));
    }
    if (c2[r] >= l) {
        int ans = dfs(l, c2[r] - 1);
        if (ans == 0) {
            ++cnt2;
            return 0;
        }
        return (ans & dfs(c2[r] + 1, r));
    }
    if (str[l] == '(' && str[r] == ')') {
        return dfs(l + 1, r - 1);
    }
    return str[l] - '0';
}
int main(int argc, const char * argv[]) {
    scanf("%s",str + 1);
    int len = strlen(str + 1);
    int x = 0;
    for (int i = 1; i<=len; ++i) {
        if (str[i] == '(') {
            ++x;
        }else if (str[i] == ')') {
            --x;
        }else if (str[i] == '|') {
            l1[x] = i;
        }else if (str[i] == '&') {
            l2[x] = i;
        }
        c1[i] = l1[x];
        c2[i] = l2[x];
    }
    int ans = dfs(1, len);
    printf("%d\n%d %d\n",ans,cnt2,cnt1);
    return 0;
}
```
    - **核心思想**：`dfs`函数实现分治，通过预处理数组`c1`和`c2`快速定位同层运算符，递归计算表达式值并统计短路次数。`main`函数负责读入表达式和预处理。
- **作者：OI_AKed_me (5星)**
    - **关键亮点**：直接从左到右扫描表达式，通过巧妙判断跳过无贡献部分，避免复杂的表达式树构建或转换，代码简短且高效，运行效率高。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
bool st;
string str;
bool val;
int ans1,ans2,off;
bool ed;
int main(){
    ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
    cin>>str;
    for(int i=0;i<str.size();i++){
        if(off){
            if(str[i]=='('){
                int x=1;
                while(x){
                    i++;
                    if(str[i]=='(') x++;
                    if(str[i]==')') x--;
                }
            }else if(off==1&&str[i]=='|'){
                off=0;
            }else if(str[i]==')'){
                off=0;
            }else if(off==1&&str[i]=='&'){
                ans1++;
            }else if(off==2&&str[i]=='|'){
                ans2++;
            }
        }else{
            if(str[i]=='1') val=1;
            if(str[i]=='0') val=0;
            if(str[i]=='&'&&val==0){
                off=1;
                ans1++;
            }
            if(str[i]=='|'&&val==1){
                off=2;
                ans2++;
            } 
        }
    }
    cout<<val<<endl<<ans1<<' '<<ans2<<endl;
    return 0;
}
```
    - **核心思想**：通过`off`变量标记是否跳过当前部分，扫描时根据`off`状态及字符类型处理，同时统计短路次数，最后输出结果。
- **作者：Imken (4星)**
    - **关键亮点**：运用递归下降的语法分析方法，通过几个按优先级递归的函数构建表达式树（AST），代码逻辑清晰，易理解，有助于理解编译器语法分析过程。
    - **核心代码**：
```cpp
struct Expr {
    enum exptype { OR, AND, VALUE };
    exptype type;
    Expr *lvalue, *rvalue;
    int value;
};
class Parser {
public:
    Parser(const std::string& input): input(input), index(0) { }
    Expr* parse() { return parse_or(); }
private:
    Expr* parse_or() {
        Expr* left = parse_and();
        while (index < input.length() && input[index] == '|') {
            index++;
            auto right = parse_and(), new_expr = new Expr;
            new_expr->type = Expr::OR;
            new_expr->lvalue = left, new_expr->rvalue = right;
            left = new_expr;
        }
        return left;
    }
    Expr* parse_and() {
        Expr* left = parse_value();
        while (index < input.length() && input[index] == '&') {
            index++;
            auto right = parse_value(), new_expr = new Expr;
            new_expr->type = Expr::AND;
            new_expr->lvalue = left, new_expr->rvalue = right;
            left = new_expr;
        }
        return left;
    }
    Expr* parse_value() {
        if (index < input.length() && input[index] == '(') {
            index++;
            auto expr = parse_or();
            if (index < input.length() && input[index] == ')') {
                index++;
                return expr;
            } else {
                throw std::runtime_error("Missing closing parenthesis.");
            }
        } else if (index < input.length() && (input[index] == '0' || input[index] == '1')) {
            Expr* expr = new Expr;
            expr->type = Expr::VALUE;
            expr->value = input[index] - '0';
            index++;
            return expr;
        } else {
            throw std::runtime_error("Invalid character.");
        }
    }
    std::string input;
    size_t index;
};
int or_circuit, and_circuit;
void dfs(Expr* expr) {
    switch (expr->type) {
    case Expr::OR: {
        dfs(expr->lvalue);
        if (expr->lvalue->value == 1) {
            or_circuit++;
            expr->type = Expr::VALUE; expr->value = 1;
            break;
        }
        dfs(expr->rvalue);
        expr->value = expr->lvalue->value | expr->rvalue->value;
        expr->type = Expr::VALUE;
        break;
    }
    case Expr::AND: {
        dfs(expr->lvalue);
        if (expr->lvalue->value == 0) {
            and_circuit++;
            expr->type = Expr::VALUE; expr->value = 0;
            break;
        }
        dfs(expr->rvalue);
        expr->value = expr->lvalue->value & expr->rvalue->value;
        expr->type = Expr::VALUE;
        break;
    }
    case Expr::VALUE: { break; }
    }
}
int main() {
    std::string input;
    std::cin >> input;
    Parser parser(input);
    Expr* result = parser.parse();
    dfs(result);
    std::cout << result->value << "\n"
              << and_circuit << ' ' << or_circuit << '\n';
    return 0;
}
```
    - **核心思想**：`Parser`类中的`parse_or`、`parse_and`、`parse_value`函数按优先级递归构建表达式树，`dfs`函数遍历树求值并统计短路次数。

### 最优关键思路或技巧
- **分治与模拟**：如SkyWave的题解，通过分治模拟人脑计算中缀表达式过程，将复杂问题分解为相似子问题，利用递归和预处理优化，高效解决问题。
- **直接扫描优化**：像OI_AKed_me的做法，直接从左到右扫描，根据逻辑判断跳过无贡献部分，简化计算过程，提高效率。

### 可拓展之处
此类题目可拓展到更复杂的表达式求值，如包含多种运算符、函数调用等。类似算法套路包括利用栈实现中缀转后缀、构建表达式树等，可用于解决不同类型的表达式处理问题。

### 相似知识点洛谷题目
- [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)：通过后缀表达式求值，考察栈的应用及表达式处理。
- [P3399 丝绸之路](https://www.luogu.com.cn/problem/P3399)：结合表达式求值与贪心策略，处理带有条件的表达式计算。
- [P1981 表达式求值](https://www.luogu.com.cn/problem/P1981)：经典的表达式求值问题，涵盖多种运算符和括号处理。 

---
处理用时：66.21秒
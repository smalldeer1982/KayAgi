# 题目信息

# [USACO23OPEN] Rotate and Shift B

## 题目描述

**注意：本题的时间限制为 4 秒，是默认时间限制的 2 倍。**

为了庆祝春天的到来，Farmer John 的 $N$ 头奶牛发明了一种有趣的舞蹈，她们围成一个圆圈，并以一种可预测的方式重新排列自己。

具体来说，圆圈上有 $N$ 个位置，编号从 $0$ 到 $N-1$，其中位置 $0$ 紧接着位置 $N-1$。每个位置上有一头奶牛。奶牛的编号也从 $0$ 到 $N-1$。初始时，奶牛 $i$ 位于位置 $i$。你会被告知一组 $K$ 个“活跃”位置 $0 = A_1 < A_2 < \dots < A_K < N$，这意味着这些位置上的奶牛是下一批要移动的。

在舞蹈的每一分钟，会发生两件事。首先，活跃位置上的奶牛会旋转：位置 $A_1$ 的奶牛移动到位置 $A_2$，位置 $A_2$ 的奶牛移动到位置 $A_3$，依此类推，位置 $A_K$ 的奶牛移动到位置 $A_1$。所有这些 $K$ 次移动同时发生，因此在旋转完成后，所有活跃位置仍然恰好有一头奶牛。接下来，活跃位置本身会移动：$A_1$ 变为 $A_1 + 1$，$A_2$ 变为 $A_2 + 1$，依此类推（如果某个活跃位置 $A_i = N-1$，则 $A_i$ 会循环回到 $0$）。

请计算舞蹈进行 $T$ 分钟后奶牛的顺序。

## 说明/提示

对于上述样例，以下是前四个时间步的奶牛顺序和活跃位置 $A$：
```
初始，T = 0：顺序 = [0 1 2 3 4]，A = [0 2 3]
T = 1：顺序 = [3 1 0 2 4]
T = 1：A = [1 3 4]
T = 2：顺序 = [3 4 0 1 2]
T = 2：A = [2 4 0]
T = 3：顺序 = [2 4 3 1 0]
T = 3：A = [3 0 1]
T = 4：顺序 = [1 2 3 4 0]
```

$1 \leq K \leq N \leq 2 \cdot 10^5$，$1 \leq T \leq 10^9$。

- 输入 2-7：$N \leq 1000$，$T \leq 10000$。
- 输入 8-13：没有额外限制。

## 样例 #1

### 输入

```
5 3 4
0 2 3
```

### 输出

```
1 2 3 4 0
```

# AI分析结果

### 综合分析与结论
这些题解主要分为暴力解法和优化解法。暴力解法直接按题意模拟，时间复杂度为 \(O(tk)\)，只能通过部分测试点。优化解法主要有两种思路：
 - **找规律法**：通过观察样例，发现对于 \(a_i\) 和 \(a_{i + 1}\) 之间的数，从第一次被移动后，每 \(a_{i + 1} - a_i\) 秒会向后移动 \(a_{i + 1} - a_i\) 个数。利用此规律直接计算每个数 \(t\) 秒后的位置，时间复杂度 \(O(n)\)。
 - **倍增优化法**：将操作进行等价变换，把将 \(A\) 向后挪再进行 \(C\) 操作等价为先逆时针转、进行 \(C\) 操作、再顺时针转。通过抵消顺逆时针旋转操作，定义新操作 \(D\)，利用倍增数组 \(jmp[i][j]\) 记录进行 \(2^j\) 次 \(D\) 操作后 \(b_i\) 的位置，将时间复杂度从 \(O(nT)\) 优化到 \(O(n\log_{2}{T})\)。

### 所选的题解
1. **作者：HyB_Capricornus（5星）**
    - **关键亮点**：思路清晰，巧妙地对操作进行等价变换，通过定义新操作并利用倍增优化，有效降低时间复杂度，代码简洁高效。
    - **个人心得**：强调最后不要忘了顺时针转 \(n\) 次，且 \(y\) 很大时需要取模，否则会变成负数（赛时被卡）。
    - **核心代码实现思想**：通过预处理倍增数组 \(jmp[i][j]\)，记录进行 \(2^j\) 次特定操作后元素的位置，最后通过枚举 \(2\) 的幂次进行操作并还原。
```cpp
// 预处理 jmp 数组
for(int i=0;i<n;i++) jmp[sor2[i]][0]=i; 
for(int j=1;j<=40;j++) 
    for(int i=0;i<n;i++)
        jmp[i][j]=jmp[jmp[i][j-1]][j-1];
for(int i=40;i>=0;i--){ 
    if((1ll<<i)<=t){
        t-=(1ll<<i);
        for(int j=0;j<n;j++) tmp[jmp[j][i]]=sor1[j]; 
        memcpy(sor1,tmp,sizeof(tmp));
    }
}
```
2. **作者：player_1_Z（4星）**
    - **关键亮点**：从暴力解法入手，通过打表观察样例找规律，详细解释了规律背后的原理，并给出了完整的代码实现。
    - **核心代码实现思想**：先处理活跃位置的间隔差 \(x\) 及每个位置距离下一个活跃位置的偏移量，然后根据规律计算每个数 \(t\) 秒后的位置并存储在新数组中。
```cpp
for(int i=0;i<n;i++){
    if(i==b[k1]){
        if(k1==k) x=n-b[k1];
        else{
            k1++;
            x=b[k1]-b[k1-1];
        }
    }
    a[i][1]=x;
}
k1=1;
for(int i=0;i<n;i++,x++){
    if(i==b[k1]){x=0;k1++;}
    a[i][2]=x;
}
for(int i=0;i<n;i++){
    int y;
    if(a[i][2]==0)
        y=i+int(ceil(t*1.0/a[i][1]))*a[i][1];
    else
        y=i+int(ceil((t-a[i][2])*1.0/a[i][1]))*a[i][1];
    c[y%n]=i;
}
```
3. **作者：Yxy7952（4星）**
    - **关键亮点**：同样通过找规律解决问题，代码简洁，对规律的描述清晰，并在代码注释中详细解释了每一步的含义。
    - **核心代码实现思想**：利用活跃位置的间隔差 \(x\)，计算每个数的偏移量 \(p\)，从而得到每个数 \(t\) 秒后的位置并记录在答案数组中。
```cpp
for(ll i=0;i<k;i++){
    ll x=a[i+1]-a[i];
    for(ll j=a[i];j<a[i+1];j++){
        int p=xs(t-(j-a[i]),x)*x;
        ll b=(j+p)%n;
        ans[b]=j;
    } 
}
```

### 最优关键思路或技巧
找规律法和倍增优化法是本题的关键技巧。找规律法通过观察数据特点，挖掘出数据移动的周期性规律，直接计算最终位置，效率高且代码简洁；倍增优化法将复杂操作进行等价转化，利用倍增思想记录多次操作后的结果，避免重复计算，有效降低时间复杂度。

### 可拓展之处
此类题目属于模拟与规律结合的题型，类似套路有：
 - 对于复杂的操作序列，可以尝试对操作进行等价变换，简化操作流程。
 - 当数据规模较大时，考虑使用倍增、分治等优化技巧降低时间复杂度。
 - 对于有规律的移动或变换问题，通过观察样例数据找规律，直接计算最终状态。

### 相似知识点洛谷题目
 - [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)：考察数论中的同余知识，需要通过找规律和数学推导解决问题。
 - [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)：可使用矩阵快速幂优化，与本题倍增优化思路类似。
 - [P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)：直接考察矩阵快速幂这一优化算法，与倍增思想相关。 

---
处理用时：50.99秒
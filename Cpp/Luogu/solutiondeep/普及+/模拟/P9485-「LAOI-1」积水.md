# 题目信息

# 「LAOI-1」积水

## 题目描述



地表坑洼不平，每当暴雨来临地面上都会有一个个水洼。   
又有一场暴雨即将来临，你决定改造地面来减少积水。     
地面可抽象为一个长度为 $n$ 的正整数序列 $a$，其中 $a_i$ 表示当地的海拔高度。       
下暴雨时将会汇聚在低洼处无法向两侧流走，比如一个序列 $a=[3,1,5,1,2,3]$。     
在下雨后的积水如图所示（有 $5$ 格积水）：

![](https://cdn.luogu.com.cn/upload/image_hosting/79on2oe3.png)

由于人手不足，现在只来得及改变一个地方的海拔高度为任意正整数。

问改造后积水最少有几格。






## 说明/提示

对于前 $5\%$ 的数据，$1\le n\le 5$。       
对于前 $20\%$ 的数据，$1\le \sum  n\le 550$，$1\le a_i\le 500$。     
对于前 $35\%$ 的数据，$1\le \sum n\le 5050$，$1\le a_i\le 5000$。    
对于前 $50\%$ 的数据，$1\le \sum n\le 5050$，$1\le a_i \le 10^9$。  
对于 $100\%$ 的数据，$1\le n,\sum n\le 10^6$，$1\le a_i\le 10^9$。

保证 $1\le T\le 10^4$。

## 样例 #1

### 输入

```
3
6
3 2 1 1 2 3
6
1 1 4 5 1 4
6
1 9 1 9 8 10```

### 输出

```
2
0
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算积水以及通过改变一处海拔高度来减少积水这两个核心问题展开。思路上，大多先计算初始积水，再考虑抬高或降低某点海拔对积水的影响。算法要点包括使用前缀后缀最大值数组、单调栈、线段树、ST表等数据结构辅助计算。难点在于精确分析改变海拔后积水的变化情况，避免重复计算或遗漏情况。

### 所选的题解
1. **作者：EdenSky (5星)**
    - **关键亮点**：思路清晰，详细阐述积水计算原理及两种改变海拔情况的分析，结合图示说明，代码注释详尽，使用RMQ问题求解，时间复杂度较优。
    - **个人心得**：提到线性做法较难想，着重讲述RMQ求解方法，还分享了卡常经验及调试中遇到的`memset()`问题。
    - **核心代码**：
```cpp
// 计算左右峰位置
l[0]=0,l[1]=0;
for(register int i=2;i<=n;i++)
  if(a[i-1]>=a[l[i-1]]) l[i]=i-1;
  else l[i]=l[i-1];
r[n+1]=0,r[n]=0;
for(register int i=n-1;i>=1;i--)
  if(a[i+1]>=a[r[i+1]]) r[i]=i+1;
  else r[i]=r[i+1];
// 计算积水相关值
s=0;
for(register int i=1;i<=n;i++){
  p[i]=min(a[l[i]],a[r[i]]);
  if(p[i]-a[i]>0) w[i]=p[i]-a[i];
  else w[i]=0;
  s+=w[i];
}
// 处理降低峰高度减少积水情况
for(register int i=1;i<=n;i++){
  if(p[i]>=a[i]){
    to=max(a[l[l[i]]],query(l[i]+1,i-1));
    v[l[i]]+=(p[i]-max(to,a[i])>0?
      p[i]-max(to,a[i]):0);
    to=max(a[r[r[i]]],query(i+1,r[i]-1));
    v[r[i]]+=(p[i]-max(to,a[i])>0?
      p[i]-max(to,a[i]):0);
  }
}
// 求最终答案
ans=s;
for(register int i=1;i<=n;i++)
  ans=min(ans,s-w[i]),
  ans=min(ans,s-v[i]);
```
核心实现思想：先通过循环确定每个位置左右峰的位置，再据此计算每个位置积水相关值。对于降低峰高度减少积水的情况，通过查询区间最大值等操作计算可减少的积水格数，最后通过比较不同情况下积水减少量得出最终答案。

2. **作者：CZ_7 (4星)**
    - **关键亮点**：不使用复杂数据结构，思路简洁易懂，通过前缀后缀最大值数组计算积水，详细分析抬高和降低海拔两种情况，代码简洁且有注释。
    - **个人心得**：纪念在机房调试2.5小时的题目，强调了对关键图示的理解有助于分析问题。
    - **核心代码**：
```cpp
// 计算前缀后缀最大值
for(int i=1;i<=n;i++){
  maxl[i]=max(maxl[i-1],a[i]);
}
for(int i=n;i>=1;i--){
  maxr[i]=max(maxr[i+1],a[i]);
}
// 计算总积水和抬高海拔减少的积水
for(int i=1;i<=n;i++){
  ll t=min(maxl[i-1],maxr[i+1]);
  if(t>a[i]){
    sum+=t-a[i];
    cut=max(cut,t-a[i]);
  }
}
// 计算降低海拔减少的积水（从左往右）
int l=1,r=2;
while(r<=n){
  ll low=maxl[l-1],cnt=0;
  while(a[r]<a[l]){
    ll w=min(maxl[r-1],maxr[r+1]);
    if(w>max(low,a[r]))cnt+=w-max(low,a[r]);
    low=max(low,a[r]);
    r++;
    if(r==n+1)break;
  }
  cut=max(cut,cnt);
  l=r;r++;
}
// 计算降低海拔减少的积水（从右往左）
r=n,l=n-1;
while(l>=1){
  ll low=maxr[r+1],cnt=0;
  while(a[l]<a[r]){
    ll w=min(maxl[l-1],maxr[l+1]);
    if(w>max(low,a[l]))cnt+=w-max(low,a[l]);
    low=max(low,a[l]);
    l--;
    if(l==0)break;
  }
  cut=max(cut,cnt);
  r=l;l--;
}
```
核心实现思想：先利用循环求出前缀后缀最大值数组，接着遍历计算总积水和抬高海拔可减少的积水。然后通过双指针法，从左往右和从右往左分别遍历计算降低海拔可减少的积水，最终得出答案。

3. **作者：__LYY_p (4星)**
    - **关键亮点**：使用线段树维护区间最大值，思路独特，详细分析抬高和降低海拔的策略，复杂度分析清晰，代码有注释。
    - **核心代码**：
```cpp
// 线段树构建
void build(int o=1,int l=1,int r=n){
  if(l==r){maxv[o]=h[l];return;}
  int mid=(l+r)>>1;
  build(o<<1,l,mid);
  build(o<<1|1,mid+1,r);
  maxv[o]=max(maxv[o<<1],maxv[o<<1|1]);
}
// 线段树修改
void modify(int x,int k,int o=1,int l=1,int r=n){
  if(l==r){maxv[o]=k;return;}
  int mid=(l+r)>>1;
  if(x<=mid)modify(x,k,o<<1,l,mid);
  else modify(x,k,o<<1|1,mid+1,r);
  maxv[o]=max(maxv[o<<1],maxv[o<<1|1]);
}
// 线段树查询
int query(int ql,int qr,int o=1,int l=1,int r=n){
  if(ql<=l&&r<=qr){return maxv[o];}
  int mid=(l+r)>>1,ans=0;
  if(ql<=mid)ans=max(ans,query(ql,qr,o<<1,l,mid));
  if(mid+1<=qr)ans=max(ans,query(ql,qr,o<<1|1,mid+1,r));
  return ans;
}
// 初始化并计算水深d和LR
void init(){
  build();sum_d=0;
  for(int i=2;i<n;i++){
    d[i]=max(0,min(query(1,i-1),query(i+1,n))-h[i]);
    sum_d+=d[i];
  }
  ans=sum_d;
  h[0]=h[n+1]=inf;
  for(int i=1;i<=n;i++){
    L[i]=i;
    while(h[i]>h[L[i]-1])L[i]=L[L[i]-1];
  }
  for(int i=n;i>=1;i--){
    R[i]=i;
    while(h[i]>h[R[i]+1])R[i]=R[R[i]+1];
  }
  h[0]=h[n+1]=0;
}
// 重新计算积水值
ll recalc(int p,int k){
  ll res=sum_d;
  modify(p,k);
  for(int i=L[p];i<=R[p];i++){
    if(i==p||i==1||i==n)continue;
    int now_d=max(0,min(query(1,i-1),query(i+1,n))-h[i]);
    res-=d[i]-now_d;
  }
  modify(p,h[p]);
  return res;
}
```
核心实现思想：通过线段树的构建、修改和查询操作维护区间最大值，利用循环计算每个位置积水值及左右边界。在重新计算积水值时，先修改线段树中对应位置的值，再遍历受影响区间重新计算积水变化，最后恢复原值。

### 最优关键思路或技巧
1. **利用前缀后缀最大值数组**：快速确定每个位置左右两侧的最高海拔，方便计算积水高度及分析改变海拔后的积水变化。
2. **双指针法**：在分析降低海拔减少积水时，通过双指针移动，有效遍历区间并计算可减少的积水量，降低时间复杂度。
3. **数据结构辅助**：如使用线段树、ST表维护区间最大值，高效解决RMQ问题，优化计算积水相关值的时间复杂度。

### 可拓展思路
此类题目属于地形积水问题，类似算法套路可应用于其他涉及地形、高度相关的积水、水流模拟问题。可拓展到二维地形积水问题，或者考虑多次改变海拔高度等条件变化的情况。

### 推荐题目
1. [P1318 积水面积](https://www.luogu.com.cn/problem/P1318)：基础的积水面积计算问题，可作为此类题型的入门练习。
2. [P2444 奶牛浴场](https://www.luogu.com.cn/problem/P2444)：涉及二维平面上的区域积水问题，与本题思路有一定关联。
3. [P3957 [NOIP2017 提高组] 跳房子](https://www.luogu.com.cn/problem/P3957)：虽不是直接的积水问题，但在处理地形相关条件和动态规划结合上有相似之处。 

---
处理用时：71.27秒
# 题目信息

# 「PHOI-1」路虽远

## 题目背景

$update$ $on$ $2023.8.17$ $12:25$ 
**数据修复&加强完成，可重新提交代码。**

路虽远，行则将至。

![](https://cdn.luogu.com.cn/upload/image_hosting/ugqt01zi.png)

## 题目描述

**请注意本题特殊的时限。**

小 X 来到了 Z 市，Z 市有 $n$ 个交通路口，$m$ 条马路。其中第 $i$ 条马路连接着第 $u_i$ 个交通路口和第 $v_i$ 个交通路口（可以从 $u_i$ 到 $v_i$，也可以从 $v_i$ 到 $u_i$），小 X 通过这条马路时要花费 $p_i$ 秒，若有限速，则通过这条马路时要花费 $q_i$ 秒。

现在，市长要在 $k$ 条马路上添加限速，然而，要在哪 $k$ 条马路上限速是小 X 自己规定的。

同时，市长会在每个交通路口处添加红绿灯。第 $i$ 个交通路口的红绿灯先亮绿灯 $x_i$ 秒，再亮黄灯 $y_i$ 秒，之后亮红灯 $z_i$ 秒，然后再亮绿灯，黄灯，红灯，如此往复。如果一个交通路口的红绿灯不是红灯，小 X 可以从这个交通路口出发，到达另一个交通路口。若到达交通路口时，灯的颜色瞬间变了，则按照变了之后的灯计算，灯的黄灯和红灯的持续时间可能为 $0$。并且，小 X 最多只能闯 $g$ 次黄灯。

过了一会儿，市长突然发现，所有的红绿灯在某一刻都变成了绿灯。与此同时，小 X 从第 $1$ 个路口出发，前往第 $n$ 个路口。他想问你，他至少要花多少时间才能到达第 $n$ 个路口？

因为路虽远，行则将至，数据保证一定可以到达，即 $1\sim n$ 一定连通。

## 说明/提示

**本题采用捆绑测试。**

| Subtask | $n,m$ | $y_i,z_i$ | $k,g$ | 分值 |
| :-: | :-: | :-: | :-: | :-: |
| $0$ | $1 \le n,m \le 5$ | 无特殊限制 | 无特殊限制 | $20$ |
| $1$ | 无特殊限制 | $y_i=z_i=0$ | $k=g=0$ | $5$ |
| $2$ | 无特殊限制 | $y_i=0,0 \le z_i \le 10^9$ | 无特殊限制 | $25$ | 
| $3$ | 无特殊限制 | 无特殊限制 | 无特殊限制 | $50$ |

对于 $100\%$ 的数据，保证 $1 \le n,m \le 100$，$0 \le k,g \le m$，$1 \le x_i \le 10^9$，$0 \le y_i,z_i \le 10^9$，$1 \le u,v \le n$，$0 \leq p_i \leq q_i \leq 10^9$。
### 样例解释 #1：


$1 \to 3 \to 4 \to 5$ 并在编号为 $1,2,4,6,7,8$ 的马路上添加限速，到 $3$ 时闯黄灯，到 $4$ 时绿灯直接过，这时候，$1 \to 3$ 花费 $1$ 秒，$3 \to 4$ 花费 $0$ 秒，$4 \to 5$ 花费 $3$ 秒，共花费 $4$ 秒。

### 样例解释 #2：

$1 \to 2 \to 5 \to 6 \to 9$ 并在编号为 $2,3,4,5,6,7,8,9,10,11,13,14,15,16$ 的马路上添加限速，到 $2,5$ 时闯黄灯，到 $4$ 时绿灯直接过，到 $6$ 时等 $1$ 秒红灯，这时候，$1 \to 2$ 花费 $1$ 秒，$2 \to 5$ 花费 $4$ 秒，$5 \to 6$ 花费 $9$ 秒，$6 \to 9$ 花费 $3$ 秒，加上等红灯的 $1$ 秒共花费 $18$ 秒。

## 样例 #1

### 输入

```
5 8 6 1
1 2 2
1 0 3
1 1 4
3 1 0
5 1 4
1 2 1 4
2 4 2 4
3 4 0 2
1 5 7 8
1 3 1 2
5 4 2 3
2 5 2 4
1 4 4 7```

### 输出

```
4```

## 样例 #2

### 输入

```
9 16 14 2
1 7 2
1 5 3
1 6 4
3 5 0
1 6 5
1 0 4
1 7 5
3 8 8
3 8 6
1 2 1 4
8 5 2 6
2 4 2 4
8 6 3 5
3 4 0 2
6 7 1 4
1 5 7 8
5 9 16 21
1 3 2 2
7 6 2 3
5 4 2 3
6 9 3 5
2 5 2 4
8 9 4 7
1 4 4 7
6 5 6 9```

### 输出

```
18```

# AI分析结果

• **综合分析与结论**：
    - **思路**：各题解均围绕从起点到终点在不同条件限制下求最短时间展开。对于不同子任务，采用不同策略。Subtask0 可直接爆搜；Subtask1 因只有绿灯且无限速直接跑最短路；Subtask2 用分层图解决限速问题；Subtask3 普遍采用三维 Dijkstra，三维分别表示当前点、不限速边数量、闯黄灯次数，在转移时根据当前灯状态、是否限速、是否闯黄灯进行决策。
    - **算法要点**：都基于图论中的最短路算法，主要是 Dijkstra 算法，通过记录不同状态来更新最短路径。
    - **解决难点**：难点在于如何综合考虑红绿灯状态、限速条件以及闯黄灯次数对路径时间的影响。各题解通过合理设计状态转移和边权计算来解决。

    - **总体结论**：各题解思路相近，主要差异体现在代码实现的细节和风格上。

• **所选的题解**：
  - **作者：FiraCode (5星)**
    - **关键亮点**：思路清晰，对每个子任务分别阐述解法，代码实现规范，注释详细，对 Dijkstra 算法的三维状态转移处理得当。
    - **核心代码片段**：
```cpp
void dijkstra() {
    for (int i = 1; i <= n; ++i)
        for (int j = 0; j <= k; ++j)
            for (int k = 0; k <= g; ++k)
                dist[i][j][k] = INF;

    dist[1][0][0] = 0;
    q1.push({1, 0, 0, 0});

    while (!q1.empty()) {
        auto u = q1.top();
        q1.pop();
        int x = u.x, y = u.y, z = u.z, w = u.w, now = w % (a[x] + b[x] + c[x]);
        if (dist[x][y][z] < w) continue;
        for (int i = h[x]; ~i; i = ne[i]) {
            int v = e[i];
            if (y < k) {
                if (now < a[x]) update(v, y + 1, z, w + p[i]);
                else update(v, y + 1, z, w + a[x] + b[x] + c[x] - now + p[i]);
                if (z < g) {
                    if (now < (a[x] + b[x])) update(v, y + 1, z + 1, w + p[i]);
                    else update(v, y + 1, z + 1, w + a[x] + b[x] + c[x] - now + p[i]);
                }
            }
            if (now < a[x]) update(v, y, z, w + q[i]);
            else update(v, y, z, w + a[x] + b[x] + c[x] - now + q[i]);
            if (z < g) {
                if (now < (a[x] + b[x])) update(v, y, z + 1, w + q[i]);
                else update(v, y, z + 1, w + a[x] + b[x] + c[x] - now + q[i]);
            }
        }
    }
}
```
核心实现思想：在 Dijkstra 算法框架内，根据当前状态（所在点、剩余不限速边数、剩余闯黄灯次数）和当前点的红绿灯状态，分情况更新到下一个点的状态和距离。

  - **作者：Night_sea_64 (4星)**
    - **关键亮点**：代码简洁明了，通过 flag 数组标记状态避免重复计算，在状态转移时对每种灯的情况分类清晰。
    - **核心代码片段**：
```cpp
void dij()
{
    qq.push({1,0,0,0});
    memset(d,999999,sizeof(d));
    d[1][0][0]=0;
    while(!qq.empty())
    {
        int x=qq.top().x,lim=qq.top().lim;
        int cnt=qq.top().cnt,dis=qq.top().dis;
        qq.pop();
        int t=a[x]+b[x]+c[x],now=dis%t;
        if(x==n)
        {
            cout<<dis<<endl;
            exit(0);
        }
        if(flag[x][lim][cnt])continue;
        flag[x][lim][cnt]=1;
        for(auto e:v[x])
        {
            int p=e.p,q=e.q;
            if(now<a[x])//绿灯
            {
                //限速
                go(x,lim,cnt,e.x,lim,cnt,q);
                //不限速
                if(lim<m-k)go(x,lim,cnt,e.x,lim+1,cnt,p);
            }
            else if(now<a[x]+b[x])//黄灯
            {
                //不闯黄灯，限速
                go(x,lim,cnt,e.x,lim,cnt,t-now+q);
                //不闯黄灯，不限速
                if(lim<m-k)go(x,lim,cnt,e.x,lim+1,cnt,t-now+p);
                //闯黄灯，限速
                if(cnt<g)go(x,lim,cnt,e.x,lim,cnt+1,q);
                //闯黄灯，不限速
                if(cnt<g&&lim<m-k)
                    go(x,lim,cnt,e.x,lim+1,cnt+1,p);
            }
            else//红灯
            {
                //限速
                go(x,lim,cnt,e.x,lim,cnt,t-now+q);
                //不限速
                if(lim<m-k)go(x,lim,cnt,e.x,lim+1,cnt,t-now+p);
            }
        }
    }
}
```
核心实现思想：利用优先队列实现 Dijkstra 算法，在每次取出节点后，根据当前灯状态和是否限速、闯黄灯的不同组合，更新到相邻节点的状态和距离。

  - **作者：DerrickLo (4星)**
    - **关键亮点**：同样采用三维 Dijkstra，代码逻辑清晰，通过 add 函数简洁地处理状态更新。
    - **核心代码片段**：
```cpp
while(!qu.empty()){
    auto ft=qu.top();qu.pop();
    int nw=ft.dis%(x[ft.u]+y[ft.u]+z[ft.u]);
    if(vis[ft.u][ft.cnt1][ft.cnt2])continue;
    vis[ft.u][ft.cnt1][ft.cnt2]=1;
    for(auto v:ve[ft.u]){
        int dd=x[ft.u]+y[ft.u]+z[ft.u]-nw;
        if(nw<x[ft.u]){
            add({v.v,0,ft.cnt1,ft.cnt2+1},ft,v.p);//不限速
            add({v.v,0,ft.cnt1,ft.cnt2},ft,v.q);//限速
        }
        else if(nw<x[ft.u]+y[ft.u]){
            add({v.v,0,ft.cnt1,ft.cnt2+1},ft,dd+v.p);//不限速，不闯
            if(ft.cnt1<g)add({v.v,0,ft.cnt1+1,ft.cnt2+1},ft,v.p);//不限速，闯
            add({v.v,0,ft.cnt1,ft.cnt2},ft,dd+v.q);//限速，不闯
            if(ft.cnt1<g)add({v.v,0,ft.cnt1+1,ft.cnt2},ft,v.q);//限速，闯
        }
        else{
            add({v.v,0,ft.cnt1,ft.cnt2+1},ft,dd+v.p);//不限速
            add({v.v,0,ft.cnt1,ft.cnt2},ft,dd+v.q);//限速
        }
    }
}
```
核心实现思想：在 Dijkstra 循环中，根据当前节点的灯状态，分情况通过 add 函数更新到相邻节点的不同状态（闯黄灯次数、不限速边数）下的距离。

• **最优关键思路或技巧**：采用三维 Dijkstra 记录状态，将通过路口的灯状态、限速情况、闯黄灯次数纳入状态考虑，在每次状态转移时，细致地根据不同条件组合更新到下一个状态的距离。

• **可拓展之处**：同类型题可拓展到更多限制条件的图上最短路问题，例如增加不同类型的道路（如单行线、收费道路等），或者不同时间段道路权值变化等。类似算法套路是遇到多种限制条件影响路径权值时，合理设计状态维度，利用最短路算法（如 Dijkstra、SPFA 等）求解。

• **推荐题目**：
  - **P1339 热浪**：基础的最短路问题，可作为巩固最短路算法的练习。
  - **P4779 【模板】单源最短路径（标准版）**：标准的单源最短路模板题，用于熟悉算法实现。
  - **P3371 【模板】单源最短路径（弱化版）**：同样是单源最短路问题，可进一步加深对算法的理解。

• **个人心得摘录与总结**：
  - **作者：iakioi114514**：开始认为题目简单，做的过程中发现有难度，最后做完发现因忘记取反而卡了两小时。总结为做题时要仔细，避免因小失误浪费大量时间。 

---
处理用时：89.93秒
# 题目信息

# 「TAOI-2」Break Through the Barrier

## 题目描述

有一个由 $\tt B$ 和 $\tt T$ 组成的字符串。

你可以进行如下操作：选择一个长度为 $4$ 的子串，其恰好等于 $\texttt{BTTB}$，并将其修改为 $\texttt{TBBT}$。你可以进行这种操作任意多次（也可以不操作）。

定义一个字符串的权值为最长的 $\texttt{T}$ 连续段长度。你需要通过如上操作使得字符串的权值尽可能大。输出这个最大值。

+ 子串的定义：一个字符串 $b$ 被称为字符串 $a$ 的子串，当且仅当可以通过删除 $a$ 开头若干个（可以是 $0$ 个，下同）字符和结尾若干个字符得到 $b$。
+ $\texttt{T}$ 连续段的定义：一个原字符串的仅由 $\texttt{T}$ 构成的子串。

## 说明/提示

**本题采用捆绑测试。**

记 $\sum n$ 为所有数据中的 $n$ 的和。

+ Subtask 0（5 pts）：$n \leq 7$。
+ Subtask 1（20 pts）：$T \leq 10$，$n \leq 10$。
+ Subtask 2（25 pts）：$\sum n \leq 5000$。
+ Subtask 3（5 pts）：保证给定的字符串无法进行任何操作。
+ Subtask 4（45 pts）：无特殊限制。

对于所有数据，$1 \leq T \leq 10^3$，$1 \leq n \leq 10^5$，$1 \leq \sum n \leq 5\times 10^5$，字符串只包含字符 `B` 和 `T`。

## 样例 #1

### 输入

```
6
3
TTT
4
BTTB
5
TBBTT
6
BTBTBB
7
BTTBTTB
17
TTBTBTTBTBTTTBTTB
```

### 输出

```
3
2
2
1
3
5
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是围绕对字符串中 `T` 连续段的分析与操作展开，利用 `BTTB` 与 `TBBT` 转换的特性来扩展 `T` 连续段长度。
1. **思路**：大多题解先找出所有 `T` 连续段，再判断其左右两侧能否通过操作增加 `T` 的个数。如EdenSky题解通过分析操作的传递性，得出连续 `T` 区块最多左右各增加一个 `T`；light_searcher等题解也基于类似思路，通过不同方式判断连续 `T` 段两侧是否满足扩展条件。
2. **算法要点**：主要通过双指针、预处理数组、状态机、动态规划等方法实现。如dino题解利用双指针找连续段，并用数组记录能否扩展；Register_int题解通过动态规划判断能否在某位置进行变换。
3. **解决难点**：关键在于准确判断每个 `T` 连续段左右两侧可扩展的条件，并优化算法避免超时。如一些题解通过剪枝（如light_searcher题解中忽略长度为1的 `T` 串）、预处理（如Defy_HeavenS题解预处理标记可扩展位置）等优化方法。

### 所选的题解
- **作者EdenSky（5星）**
    - **关键亮点**：思路清晰，通过详细分析操作的传递性得出重要推论，为解题提供了简洁高效的方法。代码实现巧妙利用双指针查找有连续性的区间，并通过标记数组记录传递性方向，最后枚举连续 `T` 区块计算答案。
    - **个人心得**：无
    - **重点代码**：
```cpp
while(r<=n){//通过双指针查找有连续性的区间
    l++,r++;
    if(c[l]=='B'&&c[l+1]=='T'&&c[l+2]=='T'&&c[l+3]=='B'){
        ri[r]++,le[l]++;//发现存在，则在两端打上标记，le的标记方向向左，ri向右
        while(c[r+1]=='T'&&c[r+2]=='B') r+=2,ri[r]++;//向左右扩展区块并打上标记（找尾巴）
        while(c[l-1]=='T'&&c[l-2]=='B') l-=2,le[l]++;
        l=r-1,r=l+3;//l跳到r的位置，在本次操作后l和r都会++，提前减1
    }
}
l=1,r=l;
while(r<=n){
    l=r,l++,r++;
    if(c[l]!='T') continue;//查询连续T区间
    while(c[r+1]=='T') r++;//扩展连续T区间
    ans=max(r-l+1+ri[l-1]+le[r+1],ans);//查询是否存在标记，注意方向
}
```
核心实现思想：通过双指针遍历字符串，找到 `BTTB` 及其扩展形式，标记其两端；再遍历连续 `T` 区间，根据两端标记判断是否能扩展并更新答案。
- **作者light_searcher（4星）**
    - **关键亮点**：先提出 $50pts$ 的贪心 + 模拟思路，再通过剪枝优化（忽略长度为1的 `T` 串）得到 $100pts$ 解法，思路循序渐进，易于理解。代码实现通过函数封装，逻辑清晰。
    - **个人心得**：无
    - **重点代码**：
```cpp
void find_out_T(){
    int bgin=0,len=0,tmp=0;
    for(int i=1;i<=n;i++)
        if(s[i]=='T'){
            tmp++;
            maxlen=max(maxlen,tmp);
        }
        else tmp=0;
    ans=maxlen;
    for(int i=1;i<=n;i++)
        if(s[i]=='T'){
            if(s[i-1]!='T') bgin=i;
            len++;
        }
        else{
            if(s[i-1]=='T'&&len>=maxlen-1)
                g.push_back({bgin,bgin+len-1});
            len=0;
        }
    if(len>=maxlen-1) g.push_back({bgin,bgin+len-1});
}
bool search_l(int pos){
    for(int i=pos;i>=1;i-=2)
        if(s[i]=='T'&&s[i-1]=='B') return i!=pos;
        else if(s[i]!='B'||s[i-1]!='T') return 0;
    return 0;
}
bool search_r(int pos){
    for(int i=pos;i<=n;i+=2)
        if(s[i]=='T'&&s[i+1]=='B') return i!=pos;
        else if(s[i]!='B'||s[i+1]!='T') return 0;
    return 0;
}
for(int i=0;i<g.size();i++){
    int l=g[i].first,r=g[i].second;
    if(l==r) continue;
    ans=max(ans,r-l+1+search_l(l-1)+search_r(r+1));
}
```
核心实现思想：`find_out_T` 函数找出长度大于等于 `maxlen - 1` 的 `T` 连续段；`search_l` 和 `search_r` 函数分别判断某位置左右两侧是否满足扩展条件；最后遍历这些 `T` 连续段更新答案。
- **作者dino（4星）**
    - **关键亮点**：先提出 $n^2$ 的朴素算法思路，再通过预处理优化，利用动态规划思想记录每个位置是否能通过操作扩展，时间复杂度优化到 $O(n)$。代码实现简洁明了，通过数组记录状态并进行状态转移。
    - **个人心得**：无
    - **重点代码**：
```cpp
for(int i = 2; i <= n; i++){
    if(s[i]!= s[i - 1]){//为bt或tb
        if(s[i] == 'T') ltb[i] = ltb[i - 2], lbt[i] = 1;
        else lbt[i] = lbt[i - 2], ltb[i] = 1;
    }
}
for(int i = n - 1; i >= 1; i--){
    if(s[i]!= s[i + 1]){
        if(s[i] == 'T') rbt[i] = rbt[i + 2], rtb[i] = 1;
        else rtb[i] = rtb[i + 2], rbt[i] = 1;
    }
}
int l = 0, r = 0, mx = 0;
while(r <= n){
    if(s[r] == 'T') r++;
    else{
        int cnt = r - l - 1;
        if(lbt[l]) cnt++;//左边能增加一个
        if(rtb[r]) cnt++;//右边能增加一个
        mx = max(mx, cnt);
        l = r;
        r++;
    }
}
```
核心实现思想：通过两个循环分别从前往后和从后往前遍历字符串，利用动态规划更新数组 `ltb`、`lbt`、`rtb`、`rbt` 记录每个位置能否扩展；最后通过双指针遍历字符串，根据记录的状态计算连续 `T` 段扩展后的最大长度。

### 最优的关键思路或技巧
1. **思维方式**：深入分析操作对 `T` 连续段的影响，如传递性（EdenSky题解），明确每个 `T` 连续段最多左右各增加一个 `T`，为解题提供方向。
2. **算法优化**：通过剪枝（light_searcher题解忽略长度为1的 `T` 串）、预处理（dino题解预处理可扩展状态）等方法优化暴力算法，降低时间复杂度。
3. **代码实现技巧**：利用双指针查找连续段（dino题解、EdenSky题解），用数组记录状态（dino题解记录可扩展状态、EdenSky题解记录传递性方向），使代码逻辑清晰，实现高效。

### 可拓展之处
此类题目属于字符串操作与优化问题，类似套路可应用于其他字符串变换求最值问题。例如，给定字符串和一些字符变换规则，求经过若干次变换后某种子串的最大长度或数量。解题时可先分析变换规则对目标子串的影响，找出关键特征和限制条件，再通过合适的数据结构（如数组、哈希表）或算法（如动态规划、贪心）进行求解。

### 相似知识点洛谷题目
1. [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)：涉及字符串查找与统计，可类比本题中查找特定子串的过程。
2. [P2758 编辑距离](https://www.luogu.com.cn/problem/P2758)：通过动态规划解决字符串变换问题，与本题利用动态规划记录状态思想类似。
3. [P1923 【深基9.例4】求第 k 小的数](https://www.luogu.com.cn/problem/P1923)：虽然是求第k小数问题，但其中的优化思路（如剪枝）可与本题优化思路相互借鉴。

### 个人心得摘录与总结
1. **作者_3Zinc_**：比赛时做题方向错误，浪费大量时间在DP和暴搜上，应更灵活思考，避免局限。总结在解题时需全面分析题目，不要过早固定思路，要善于尝试不同方法。
2. **作者dino**：在优化算法时，通过处理冗余操作，发现每个位置是否能增加是固定的，进而推导出动态规划状态转移方程。强调优化算法时要深入分析问题本质，挖掘潜在规律。 

---
处理用时：81.20秒
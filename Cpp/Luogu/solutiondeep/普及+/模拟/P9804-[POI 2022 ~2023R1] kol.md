# 题目信息

# [POI 2022 ~2023R1] kol

## 题目背景

题目译自 [POI2022~2023R1 kol](https://sio2.mimuw.edu.pl/c/oi30-1/p/kol/)。

注意：原题时限为 32s，为避免卡评测，此题时限改为 3s。


## 题目描述

你在一个 $m \times m$ 的棋盘上玩贪吃蛇游戏，已知原本蛇长度为 $1$，内容为 `0`，在 $(1,1)$ 处，棋盘上存在 $p$ 个“食物点”，当一条蛇吃了一个“食物点”时，它将会在其头部增加一个食物点对应数值的部分，下图可以更清楚的演示吃食物的过程（红色数字为蛇身）：

![](https://cdn.luogu.com.cn/upload/image_hosting/8t9pu2br.png)

现在你进行了 $n$ 个操作，存在移动操作（上下左右）和查询操作（询问一个点是否被蛇覆盖），请编写一个程序求出它。

## 说明/提示

子任务分配如下：

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $m \leq 300$ 且 $p,n \leq 2000$ | $20$ |
| $2$ | $m \leq 800$ 且 $p,n \leq 50000$ | $20$ |
| $3$ | $c_i=0$ | $20$ |
| $4$ | 无附加限制 | $40$ |

本题中，子任务 $0$ 为样例。

## 样例 #1

### 输入

```
6 5 14
1 3 1
5 1 5
2 3 2
3 4 1
3 5 3
Z 1 1
Z 1 2
P
P
D
D
P
Z 3 5
P
Z 3 5
D
Z 3 5
L
Z 3 5```

### 输出

```
0
-1
-1
3
1
2```

# AI分析结果

• 综合分析与结论：这些题解都围绕贪吃蛇在棋盘上的移动及查询操作展开，核心思路是通过时间戳来优化模拟过程，解决判断某点是否被蛇覆盖及获取对应蛇身数值的问题。各题解在实现细节上略有不同，有的通过数组维护蛇身数值，有的用动态数组，有的利用差分思想记录访问情况。在优化程度、思路清晰度和代码可读性上存在差异。

所选的题解：
  - 作者：佬头 (5星)
    - 关键亮点：思路清晰，详细阐述了时间戳的运用原理，通过给运动过的点打时间戳，结合蛇身长度判断点是否被蛇覆盖及获取对应数值，代码简洁明了。
    - 重点代码核心思想：用数组 `mmp` 记录食物点，`val` 存储蛇身数值，`t` 记录时间戳。移动时更新蛇头位置、时间戳及蛇身数值，查询时根据时间戳与蛇身长度关系判断并输出结果。
```cpp
#include <iostream>
using namespace std;
const int M = 2003, N = 1000006;
int m, p, n, w, k, mmp[M][M], x, y, val[N], tim = 1, len, t[M][M];
int read(){
    int x = 0;
    char a = getchar();
    while(a < '0' || '9' < a) a = getchar();
    while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
    return x;
}
void write(int x){
    if(x > 9) write(x / 10);
    putchar(x % 10 | 48);
}
int main(){
    m = read(), p = read(), n = read();
    for(int i = 1; i <= p; ++ i){
        w = read(), k = read();
        mmp[w][k] = read() + 1;
    }
    t[x = 1][y = 1] = 1, len = 1;
    for(int i = 1; i <= n; ++ i){
        char a = getchar();
        while(a < 'A' || 'Z' < a) a = getchar();
        if(a == 'Z'){
            w = read(), k = read();
            if(tim - t[w][k] >= len) fputs("-1\n", stdout);
            else write(val[len - (tim - t[w][k])]), putchar('\n');
        }
        else{
            if(a == 'G') x --;
            else if(a == 'D') ++ x;
            else if(a == 'L') y --;
            else ++ y;
            if(!t[x][y] && mmp[x][y]) val[++ len] = mmp[x][y] - 1;
            t[x][y] = ++ tim;
        }
    }
    return 0;
}
```
  - 作者：zhuweiqi (4星)
    - 关键亮点：提出两种优化方案并分析其时间复杂度，最终采用维护每个点被经过时间及蛇身数值数组的方法，代码简洁且有较好的时间复杂度。
    - 重点代码核心思想：用数组 `f` 记录点被经过时间，`num` 存储蛇身数值，`b` 记录食物点。移动时更新蛇头位置、时间及蛇身长度和数值，查询时根据时间与蛇身长度关系判断输出。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=2002,N=1e6+2;
int sx,sy;
int f[M][M];
int b[M][M];
int num[N];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    memset(b,-1,sizeof(b));
    int m,p,n,cnt=1,len=1;
    cin>>m>>p>>n;
    while(p--){
        int x,y,z;
        cin>>x>>y>>z;
        b[x][y]=z;
    }
    f[1][1]=1;
    num[1]=0;
    sx=1,sy=1;
    while(n--){
        char op;
        cin>>op;
        if(op=='Z'){
            int x,y;
            cin>>x>>y;
            if(!f[x][y] || cnt-f[x][y]+1>len) cout<<"-1\n";
            else cout<<num[len-(cnt-f[x][y])]<<"\n";
        }
        else {
            int nx,ny;
            if(op=='G') nx=sx-1,ny=sy;
            if(op=='D') nx=sx+1,ny=sy;
            if(op=='L') nx=sx,ny=sy-1;
            if(op=='P') nx=sx,ny=sy+1;
            f[nx][ny]=++cnt;
            if(b[nx][ny]!=-1){
                num[++len]=b[nx][ny];
                b[nx][ny]=-1;
            }
            sx=nx,sy=ny;
        }
    }
    return 0;
}
```
  - 作者：yr409892525 (4星)
    - 关键亮点：思路直接，利用时间戳和数组记录蛇身数值，简洁实现题目要求的操作，代码逻辑清晰。
    - 重点代码核心思想：用数组 `t` 记录时间戳，`a` 记录食物点，`s` 存储蛇身数值。移动时更新蛇头位置、时间戳及蛇身长度和数值，查询时根据时间戳与蛇身长度关系判断输出。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2005;
int m,p,n;
int t[N][N];
int a[N][N];
int x,y,k,now=1,nx=1,ny=1;
int s[N*N],l=1; 
int main(){
    cin>>m>>p>>n;
    while(p--){
        cin>>x>>y>>k;
        a[x][y]=k+1;
    }
    t[1][1]=1;
    while(n--){
        char c;
        cin>>c;
        if(c=='Z'){
            cin>>x>>y;
            if(now-t[x][y]>=l) cout<<"-1\n";
            else cout<<s[l-now+t[x][y]]<<"\n";
        }else{
            if(c=='G') nx--;
            if(c=='D') nx++;
            if(c=='L') ny--;
            if(c=='P') ny++;
            if(a[nx][ny]){
                l++;
                s[l]=a[nx][ny]-1;
                a[nx][ny]=0;
            }
            now++;
            t[nx][ny]=now;
        }
    }
    return 0;
}
```
最优关键思路或技巧：利用时间戳记录每个点被蛇经过的时间，结合蛇身长度，快速判断某点是否被蛇覆盖及获取对应蛇身数值，避免每次查询都遍历蛇身，优化时间复杂度。

可拓展之处：同类型题常涉及模拟物体在特定空间内的移动及状态查询，类似算法套路是通过记录关键信息（如时间戳、位置等）来优化模拟过程，减少不必要的遍历。

推荐洛谷题目：
  - P1036 [NOIP2002 普及组] 选数：涉及简单模拟与组合问题。
  - P1423 小玉在游泳：简单的模拟计算问题。
  - P1909 [NOIP2016 普及组] 买铅笔：模拟购物场景下的最优选择问题。

个人心得摘录及总结：
  - 作者佬头：强调时间戳与查询操作无关，因忽视这点导致提交错误，提醒注意细节。
  - 作者xuan_gong_dong：访问到有食物的点后应将该点修改为无食物；无食物的点应赋值为 -1；样例与题目图不一致；要记录初始蛇身。这些细节易出错，需谨慎处理。 

---
处理用时：65.85秒
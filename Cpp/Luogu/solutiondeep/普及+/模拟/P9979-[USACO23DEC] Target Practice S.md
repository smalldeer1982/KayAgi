# 题目信息

# [USACO23DEC] Target Practice S

## 题目描述

Bessie 是一只仿生牛。在一条数轴上，她正尝试命中 $T$（$1 \leq T \leq 10^5$）个位于不同位置的靶子。Bessie 在位置 $0$ 开始行动，并遵循一个长度为 $C$（$1 \leq C \leq 10^5$）的命令序列，序列由 `L`、`F` 和 `R` 组成：

- `L`：Bessie 向左移动一个单位距离。
- `R`：Bessie 向右移动一个单位距离。
- `F`：Bessie 开枪。如果有一个靶子在 Bessies 当前的位置，这个靶子将被命中并摧毁。它不可以再次被命中。

如果在 Bessie 开始前，你被允许修改序列中的至多一条命令，Bessie 最多可以命中多少靶子？

## 说明/提示

### 样例解释 1

如果你对命令序列不做任何修改，Bessie 将命中两个靶子。

| 命令 | 位置 | 命中的靶子数目 |
| :----------- | :----------- | :----------- |
| Start | 0 | 0 |
| L | -1 | 0 |
| F | -1 | 1 |
| F | -1 | 1（无法摧毁靶子超过 1 次） |
| R | 0 | 1 |
| F | 0 | 2 |
| R | 1 | 2 |
| R | 2 | 2 |

如果你将最后一条命令由 `R` 修改为 `F`，Bessie 将命中三个靶子：

| 命令 | 位置 | 命中的靶子数目 |
| :----------- | :----------- | :----------- |
| Start | 0 | 0 |
| L | -1 | 0 |
| F | -1 | 1 |
| F | -1 | 1（无法摧毁靶子超过 1 次） |
| R | 0 | 1 |
| F | 0 | 2 |
| R | 1 | 2 |
| F | 1 | 3 |

### 样例解释 2

如果命令序列不修改，在位置 $0$ 的唯一一个靶子将被命中。

由于一个靶子不能被多次摧毁，答案为 $1$。

### 测试点性质

- 测试点 $4-6$ 满足 $T,C \le 1000$。
- 测试点 $7-15$ 没有额外限制。

## 样例 #1

### 输入

```
3 7
0 -1 1
LFFRFRR```

### 输出

```
3```

## 样例 #2

### 输入

```
1 5
0
FFFFF```

### 输出

```
1```

## 样例 #3

### 输入

```
5 6
1 2 3 4 5
FFRFRF```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是基于枚举修改命令的位置和类型来计算最多命中靶子数。因为修改一条命令后，后续操作位置偏移量有限，所以重点关注偏移量为 -2、-1、1、2 及不偏移的情况。
1. **算法要点**：
    - **预处理**：计算不修改命令时的答案及各操作位置，记录靶子位置及命中情况。
    - **枚举修改**：枚举每个命令位置，考虑将其修改为其他类型命令后的影响，计算新答案。
    - **计算答案**：根据修改后操作位置偏移，结合靶子位置和命中记录，计算新的命中靶子数。
2. **解决难点**：
    - **避免重复命中**：通过记录靶子命中次数或使用数据结构标记已命中靶子，防止重复计算。
    - **高效计算偏移影响**：利用数据结构（如 bitset、set、数组等）维护操作位置偏移后的命中情况，快速更新答案。

### 题解推荐
1. **作者：naoliaok_lovely (5星)**
    - **关键亮点**：思路清晰，将每种命令修改情况分开处理，代码逻辑明确，使用指针技巧简化下标处理。
    - **个人心得**：无
```cpp
// 核心代码片段
void get()
{
    pos = res = 0;
    memset(Cnt, 0, sizeof(Cnt));
    for(int i = 1; i <= m; i++)
        if(c[i] == 'L') pos--;
        else if(c[i] == 'R') pos++;
        else if(++cnt[pos] == 1 && x[pos]) res++;
    ans = max(res, ans);
}
```
此函数计算不修改命令序列时命中的靶子数。

2. **作者：Nuyoah_awa (4星)**
    - **关键亮点**：利用 set 和 map 维护操作位置及靶子命中情况，考虑多种细节，如修改点前后的处理及重复命中判断。
    - **个人心得**：注意到维护 set 时要删除之前打过及“过期”的点，否则只能得部分分数。
```cpp
// 核心代码片段
for(int i = 1;i <= c;i++)
{
    if(s[i] == 'L')
    {
        now--;
    }
    else if(s[i] == 'R')
    {
        now++;
    }
    else
    {
        if(mp[now - 2]) st[1][now - 2]++, se[1].insert(now - 2);
        if(mp[now - 1]) st[2][now - 1]++, se[2].insert(now - 1);
        if(mp[now]) st[3][now]++, se[3].insert(now);
        if(mp[now + 1]) st[4][now + 1]++, se[4].insert(now + 1);
        if(mp[now + 2]) st[5][now + 2]++, se[5].insert(now + 2);
    }
}
```
这段代码预处理出偏移量为 -2 到 2 的开火点集合。

3. **作者：0000pnc (4星)**
    - **关键亮点**：通过预处理和从右往左扫描线的方式，分别计算不同偏移量下的答案，代码结构清晰，时间复杂度为 $\mathcal{O}(c)$。
    - **个人心得**：无
```cpp
// 核心代码片段
int work2() { // 2
    init(); int ans = 0;
    for (int i = c; i; i--) {
        if (s[i] == 'F') {
            buc[pos[i]]--;
            if (!buc[pos[i]]) cnt--;
            if (vis[pos[i] + 2]) {
                if (!buc[pos[i] + 2]) cnt++;
                buc[pos[i] + 2]++;
            }
        }
        if (s[i] == 'L') ans = max(ans, cnt);
    }
    return ans;
}
```
此函数计算偏移量为 2 时的答案。

### 最优关键思路与技巧
1. **数据结构选择**：根据题目需求选择合适数据结构，如用 bitset 高效处理位置状态，set 维护不重复元素，数组记录命中次数等。
2. **预处理与扫描线**：预处理出初始状态及不同偏移量下的部分结果，通过扫描线方式从右往左枚举修改位置，动态更新答案，减少重复计算。

### 拓展思路
此类题目属于模拟与枚举优化类型，相似套路是分析操作对结果的有限影响，通过预处理和合理枚举来优化计算。同类型题可考虑增加操作类型、改变操作限制或扩大数据规模等。

### 相似知识点洛谷题目
1. **P1162 填涂颜色**：涉及对图形的模拟操作，与本题模拟移动和命中类似。
2. **P1308 统计单词数**：需枚举字符串位置并进行判断，类似本题枚举命令位置判断修改影响。
3. **P1439 【模板】最长公共子序列**：同样需要通过枚举和状态维护来求解，锻炼枚举优化能力。 

---
处理用时：44.87秒
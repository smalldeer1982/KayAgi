# 题目信息

# [NOIP 2002 普及组] 过河卒

## 题目描述

棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)

现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。

**【题目来源】**

NOIP 2002 普及组第四题

## 样例 #1

### 输入

```
6 6 3 3
```

### 输出

```
6
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕“过河卒”问题，多采用动态规划（DP）方法解题。思路上，先确定卒行走规则下的状态转移方程，再处理马的控制点。算法要点为利用状态转移方程 $f(i,j) = f(i - 1,j) + f(i,j - 1)$ 计算路径条数，难点在于如何准确标记马的控制点并避免数组越界。部分题解还进行了空间优化，将二维数组优化为一维数组。矩阵乘法和小学奥数方法虽复杂度较高，但提供了不同视角。

所选的题解：
  - 作者：Chiaro (赞：3922)  星级：5星
    - 关键亮点：思路清晰，从基础DP解法开始，逐步介绍滚动数组优化和去掉二维数组的方法，还探讨了去掉判断马控制点的二维数组的多种方法，对每种优化的原理讲解详细。
    - 个人心得：无
    - 重点代码：
```cpp
// 基础DP
for(int i = 2; i <= bx; i++){
    for(int j = 2; j <= by; j++){
        if(s[i][j]) continue; 
        f[i][j] = f[i - 1][j] + f[i][j - 1];
    }
}
// 滚动数组优化
for(int i = 2; i <= bx; i++){
    for(int j = 2; j <= by; j++){
        if(s[i][j]){
            f[i & 1][j] = 0; 
            continue;
        }
        f[i & 1][j] = f[(i - 1) & 1][j] + f[i & 1][j - 1]; 
    }
}
// 一维数组优化
for(int i = 2; i <= bx; i++){
    for(int j = 2; j <= by; j++){
        if(s[i][j]){
            f[j] = 0; 
            continue;
        }
        f[j] += f[j - 1];
    }
}
// 利用切比雪夫距离和曼哈顿距离去掉s数组
inline bool check(int x, int y) {
    if(x == mx && y == my) return 1;
    return (std::abs(mx - x) + std::abs(my - y) == 3) && (std::max ((std::abs(mx - x)), std::abs(my - y)) == 2);
}
for(int i = 2; i <= bx; i++){
    for(int j = 2; j <= by; j++){
        if(check(i, j)){
            f[j] = 0;
            continue;
        }
        f[j] += f[j - 1];
    }
}
```
核心实现思想：基础DP通过状态转移方程计算路径条数；滚动数组优化利用取模运算保留两行数据；一维数组优化巧妙利用未更新的 $f(j)$ 保存上一行数据；利用切比雪夫距离和曼哈顿距离判断点是否被马控制，避免使用二维数组。

  - 作者：yummy (赞：252)  星级：4星
    - 关键亮点：提供矩阵乘法和小学奥数两种非递推思路，拓宽解题视野，对小学奥数方法中的情况分类讨论详细。
    - 个人心得：无
    - 重点代码：
```cpp
// 矩阵乘法
void ta()//将tot乘上a
{
    for(int i1=0;i1<=n;i1++)
        for(int i2=0;i2<=m;i2++)
            for(int j1=i1;j1<=n;j1++)
                for(int j2=i2;j2<=m;j2++)
                    for(int k1=i1;k1<=j1;k1++)
                        for(int k2=i2;k2<=j2;k2++)
                            tmp[i1][i2][j1][j2]+=tot[i1][i2][k1][k2]*a[k1][k2][j1][j2];
    memcpy(tot,tmp,sizeof tmp);
}
void tt()//将tot平方
{
    for(int i1=0;i1<=n;i1++)
        for(int i2=0;i2<=m;i2++)
            for(int j1=i1;j1<=n;j1++)
                for(int j2=i2;j2<=m;j2++)
                    for(int k1=i1;k1<=j1;k1++)
                        for(int k2=i2;k2<=j2;k2++)
                            tmp[i1][i2][j1][j2]+=tot[i1][i2][k1][k2]*tot[k1][k2][j1][j2];
    memcpy(tot,tmp,sizeof tmp);
}
void pw(int ci)//求a的ci次方
{
    if(ci==0)
        return;
    pw(ci>>1);
    tt();
    if(ci&1)
        ta();
}
// 小学奥数
ll C(int m,int n)
{
    if(n<0 || m<0 || n<m)
        return 0;
    ll tot=1;
    for(int i=1;i<=m;i++)
    {
        tot*=n-i+1;
        tot/=i;
    }
    return tot;
}
```
核心实现思想：矩阵乘法通过连接可达点构建矩阵，利用矩阵快速幂计算方法数；小学奥数方法利用组合数公式，通过分类讨论计算经过特殊格子和不经过特殊格子的路径数。

  - 作者：kradcigam (赞：458)  星级：4星
    - 关键亮点：先介绍标数法思路，结合例子清晰易懂，后给出从二维数组优化到一维数组的代码实现，逻辑连贯。
    - 个人心得：无
    - 重点代码：
```cpp
// 二维数组
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
      	if(i==1&&j==1)continue;
       	if(ma[i][j]==0)x[i][j]=x[i-1][j]+x[i][j-1];
    }
}
// 一维数组
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
		if(i==1&&j==1)continue;
        	if(ma[i][j]==0)f[j]+=f[j-1];
        }
```
核心实现思想：二维数组通过状态转移方程计算每个点的路径数；一维数组利用下一行比上一行大的值是其左边格子的值这一规律，简化为一维数组计算。

• 最优关键思路或技巧：
    - **动态规划优化**：如Chiaro题解中，利用滚动数组和巧妙的一维数组优化，减少空间复杂度，同时保持时间复杂度不变。
    - **数学方法运用**：yummy题解中的小学奥数方法，通过组合数公式和分类讨论，从数学角度解决问题，提供了不同于DP的思路。

• 可拓展之处：此类题目属于路径计数问题，类似套路为确定状态转移方程和处理限制条件。同类型题可涉及不同的行走规则、障碍分布或地图形状，解题时需灵活调整状态转移方程和处理限制的方式。

• 相似知识点洛谷题目：
    - P1216 [USACO1.5]数字三角形 Number Triangles，通过动态规划求数字三角形的最大路径和。
    - P1006 传纸条，利用动态规划求矩阵中两点间不重复路径的最大权值和。
    - P1434 [SHOI2002]滑雪，动态规划求滑雪的最长路径长度。 

---
处理用时：106.76秒
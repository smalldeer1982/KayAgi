# 题目信息

# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# AI分析结果

• 综合分析与结论：这些题解都基于区间动态规划解决该问题，思路核心为利用每行取数互不影响的特性，对每行分别进行区间DP。算法要点在于定义合适的状态表示，如$f[i][j]$表示取区间$[i,j]$的最大得分，并据此推出状态转移方程。解决难点主要是高精度计算或使用`__int128`处理大数，以及确定正确的DP转移顺序。不同题解在状态转移方程的推导、初始化、边界处理及代码实现方式上略有差异。

所选的题解：
  - **作者：Jack_Homes_Huang (5星)**
    - **关键亮点**：思路清晰，详细阐述了最优子结构和区间DP的应用，对DP流程（状态、转移、终值）讲解细致，代码使用高精度运算且采用四位压缩优化输出，结构清晰。
    - **个人心得**：强调高精度运算的必要性及繁琐性，提到调试时将`m`写成`n`的失误。
    ```cpp
    // 状态转移核心代码
    for (int i = 1; i <= m; i++)
        for (int j = m; j >= i; j--) { 
            f[i][j] = max(f[i][j], f[i - 1][j] + base[m - j + i - 1] * ar[i - 1]); 
            f[i][j] = max(f[i][j], f[i][j + 1] + base[m - j + i - 1] * ar[j + 1]);
        } 
    ```
  - **作者：zhylj (4星)**
    - **关键亮点**：转移方程推导独特且清晰，代码简洁明了，使用`__int128`简化大数处理，给出了完整AC代码及`__int128`的输入输出函数。
    ```cpp
    // 状态转移核心代码
    __int128 solve(__int128 a[])
    {
        memset(f,0,sizeof(f));
        for(int len=0;len<=m;++len)
            for(int i=1;i+len<=m;++i)
                f[i][i+len]=max(2*f[i+1][i+len]+2*a[i],2*f[i][i+len-1]+2*a[i+len]);
        return f[1][m];
    }
    ```
  - **作者：Tomwsc (4星)**
    - **关键亮点**：题意理解透彻，思路讲解详细，对状态转移方程的推导及最终答案的计算阐述清晰，代码实现规范，使用`__int128`并给出了完整的读写函数。
    ```cpp
    // 状态转移核心代码
    for(register int i = 1;i <= m;i ++)
        for(register int j = m;j >= i;j --)
            dp[i][j] = max(dp[i - 1][j] + a[i - 1] * poww[m - j + i - 1], dp[i][j + 1] + a[j + 1] * poww[m - j + i - 1]);
    int maxn = -inf;
    for(register int i = 1;i <= m;i ++)
        maxn = max(maxn, dp[i][i] + a[i] * poww[m]);
    ans += maxn;
    ```

最优关键思路或技巧：利用每行取数相互独立的性质，将问题简化为对每行进行区间DP。在状态转移方程推导中，考虑每次取数在区间端点且结合取数次数对应的$2$的幂次来确定状态转移关系。处理大数时，可选择高精度运算（如四位压缩优化）或使用`__int128`。

可拓展之处：此类题目属于区间动态规划类型，类似套路为分析问题是否具有最优子结构性质，确定状态表示及状态转移方程，注意边界条件和初始化。常见同类型题如石子合并等。

推荐洛谷题目：
  - P1880 [NOI1995] 石子合并
  - P4170 [CQOI2007] 涂色
  - P3146 [USACO16OPEN]248 G 

---
处理用时：64.93秒
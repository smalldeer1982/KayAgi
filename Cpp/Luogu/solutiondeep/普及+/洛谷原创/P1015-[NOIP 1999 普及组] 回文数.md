# 题目信息

# [NOIP 1999 普及组] 回文数

## 题目描述

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。

又如：对于十进制数 $87$：

STEP1：$87+78=165$  
STEP2：$165+561=726$  
STEP3：$726+627=1353$   
STEP4：$1353+3531=4884$  

在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。

写一个程序，给定一个 $N$（$2 \le N \le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。

## 样例 #1

### 输入

```
10
87
```

### 输出

```
STEP=4
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是通过模拟来寻找给定N进制数经过最少步数得到回文数，主要涉及高精度加法、判断回文数以及处理不同进制的运算。算法要点在于正确实现高精度加法并将其推广到N进制，以及高效判断回文数。解决难点主要是对16进制的处理和高精度运算的细节。

多数题解使用数组或字符串来存储数字，以实现高精度运算。部分题解尝试使用`long long`类型绕过高精度，但这利用了数据范围漏洞，并非正解。题解的质量差异主要体现在思路清晰度、代码可读性和优化程度上。

### 所选的题解
- **作者：Haishu (赞：507)  星级：5星**
    - **关键亮点**：思路清晰，先强调正解为高精度+模拟，批判利用数据范围漏洞的做法。代码模块化程度高，将判断回文、数字翻转和加法操作分别写成函数，增强了代码的可读性和维护性。
    - **个人心得**：作者认识到早期题解利用漏洞的错误，进行自我检讨，强调应杜绝主观利用题目漏洞获取AC的行为。
    - **重点代码 - 判断回文函数**：
```cpp
inline bool pd()
{
    for (int i = 0; i < l; ++i)
        if (c[i]!= c[l - 1 - i]) return false;
    return true;
}
```
核心思想：遍历数组，比较对称位置的元素是否相等，若都相等则为回文数。
    - **重点代码 - 加法函数**：
```cpp
inline void add()
{
    for (int i = 0; i < l; ++i)
        d[l - i - 1] = c[i];
    l += 2;
    for (int i = 0; i < l; ++i)
    {
        c[i] += d[i];
        if (c[i] >= n) c[i + 1]++, c[i] -= n;
    }
    while (!c[l - 1]) --l;
}
```
核心思想：先将数组`c`翻转存入`d`，为加法做准备。然后进行逐位相加，处理进位情况，最后去除前导0。
- **作者：Strong_Jelly (赞：294)  星级：4星**
    - **关键亮点**：详细阐述了每个功能模块，对高精加、高精反转、高精判断回文数和数组存高精度都给出了清晰的代码实现，适合初学者理解。
    - **重点代码 - 高精加函数**：
```cpp
void add(int a[], int b[])//高精加 
{
    for(int i = 1; i <= l; i++)
    {
        a[i] += b[i];
        a[i + 1] += a[i] / n;//进位 
        a[i] %= n;
    }
    if(a[l + 1] > 0)//考虑从最高位进位到最高位的下一位 
    {
        l++;//长度++ 
    }
}
```
核心思想：从低位到高位逐位相加，通过`/ n`处理进位，若最高位有进位则增加数字长度。
    - **重点代码 - 高精判断回文数函数**：
```cpp
bool f(int a[])//判断是否是回文数 
{
    int ln = l;
    int i = 1;//从两边判断
    int j = l;
    while(ln--)
    {
        if(ln < l / 2)//判一般就可以啦QAQ 
        {
            break;
        }
        if(a[i]!= a[j])
        {
            return false;//有一位不相等就不是回文数 
        }
        i++;
        j--;
    }
    return true;
}
```
核心思想：从数字两端向中间遍历，比较对应位置元素，若出现不相等则不是回文数。
- **作者：hawa130 (赞：125)  星级：4星**
    - **关键亮点**：利用C++ STL自带的`reverse`函数简化字符串翻转操作，代码简洁明了，同时对十六进制数的判断处理清晰。
    - **重点代码 - 判断回文函数**：
```cpp
bool hw(string a) { //判断回文
    string s = a; //把 a 赋值给 s
    reverse(s.begin(), s.end()); //反转字符串 s
    return s == a; //判断 a 和 s 是否相等
}
```
核心思想：通过`reverse`函数反转字符串，然后比较原字符串和反转后的字符串是否相等来判断回文。
    - **重点代码 - 高精度加法函数**：
```cpp
string add(int k, string b) { //高精度加法过程，推广到 k 进制
    string a = b;
    reverse(a.begin(), a.end());
    int numa[maxN], numb[maxN], numc[maxN];
    int len = a.length(), lenc = 1;
    string ans;
    for (int i = 0; i < len; i++) {
        if (isdigit(a[i])) numa[len - i] = a[i] - '0'; 
        else numa[len - i] = a[i] - 'A' + 10; 
        if (isdigit(b[i])) numb[len - i] = b[i] - '0';
        else numb[len - i] = b[i] - 'A' + 10;
    }
    int x = 0;
    while (lenc <= len) {
        numc[lenc] = numa[lenc] + numb[lenc] + x;
        x = numc[lenc] / k; 
        numc[lenc] %= k; 
        lenc++;
    }
    numc[lenc] = x;
    while (numc[lenc] == 0) lenc--;
    for (int i = lenc; i >= 1; i--) ans += sixt[numc[i]];
    return ans;
}
```
核心思想：先反转字符串，将字符转换为数字存储在数组中进行逐位相加，处理进位后再将结果转换回字符串。

### 最优关键思路或技巧
- **模块化编程**：将不同功能封装成独立函数，如判断回文、数字翻转和高精度加法，使代码结构清晰，易于维护和理解。
- **利用STL库**：如使用`reverse`函数简化字符串翻转操作，减少代码量，提高开发效率。
- **处理不同进制**：将高精度加法中的`10`改为`n`，以适应不同进制的运算，同时针对16进制的特殊字符进行合理处理。

### 可拓展之处
同类型题或类似算法套路：此类题目主要考察高精度运算和模拟过程，可以拓展到其他高精度运算场景，如高精度乘法、除法等，以及不同进制间的转换和运算。类似算法套路是将复杂操作模块化，利用已有库函数简化代码实现。

### 推荐题目
- **P1601 A+B Problem（高精）**：基础的高精度加法题目，可用于巩固高精度运算的实现。
- **P1009 阶乘之和**：涉及高精度乘法和加法的综合应用，锻炼对高精度运算的灵活运用能力。
- **P2142 高精度减法**：专注于高精度减法的练习，加深对高精度运算细节的理解。 

---
处理用时：107.94秒
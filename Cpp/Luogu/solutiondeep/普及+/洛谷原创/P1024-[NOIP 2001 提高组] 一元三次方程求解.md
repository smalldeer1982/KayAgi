# 题目信息

# [NOIP 2001 提高组] 一元三次方程求解

## 题目描述

有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。

提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。

## 说明/提示

**【题目来源】**

NOIP 2001 提高组第一题

## 样例 #1

### 输入

```
1 -5 -4 20
```

### 输出

```
-2.00 2.00 5.00
```

# AI分析结果

### 综合分析与结论
这些题解主要采用了暴力枚举、二分法、牛顿迭代法、割线法以及公式法（盛金公式、卡尔丹公式）来求解一元三次方程。暴力枚举直接在给定范围内以一定步长遍历寻找根；二分法利用根的区间特性，通过二分查找根；牛顿迭代法基于函数切线逼近根；割线法是对牛顿法的改进，用割线代替导数；公式法则直接利用数学公式计算根。

暴力枚举简单直接，但效率较低；二分法相对高效且稳定；牛顿迭代法和割线法收敛速度有差异；公式法理论性强，但可能涉及复杂计算与精度问题。从质量上看，部分题解思路清晰、代码规范且有优化，部分则较为简略。

### 所选的题解
1. **北街的九命貓**：
    - **星级**：4星
    - **关键亮点**：思路清晰，先分析出二分法的可行性，利用根的范围及根间距条件，通过枚举长度为1的区间，在区间内二分查找根，代码实现简洁明了。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<cstdio>
double a,b,c,d;
double fc(double x)
{
    return a*x*x*x+b*x*x+c*x+d;
}
int main()
{
    double l,r,m,x1,x2;
    int s=0,i;
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
    for (i=-100;i<100;i++)
    {
        l=i; 
        r=i+1;
        x1=fc(l); 
        x2=fc(r);
        if(!x1) 
        {
            printf("%.2lf ",l); 
            s++;
        }
        if(x1*x2<0) 
        {
            while(r-l>=0.001) 
            {
                m=(l+r)/2;
                if(fc(m)*fc(r)<=0) 
                   l=m; 
                else 
                   r=m; 
            }
            printf("%.2lf ",r);  
            s++;
        }
        if (s==3) 
            break;             
    }
    return 0;
}
```
    - **核心思想**：定义函数`fc`计算方程值，通过循环枚举长度为1的区间，判断区间端点函数值，若左端点为0则输出，若两端点函数值异号则在区间内二分查找，找到根后输出，找到3个根即结束。
2. **GGN_2015**：
    - **星级**：4星
    - **关键亮点**：使用牛顿迭代法，详细解释了方法原理，通过构造函数类实现函数求值与求导，代码结构清晰，利用`set`保证根的唯一性。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<cstdio>
#include<complex>
#include<algorithm>
#include<set>
using namespace std;

struct func3
{
    double a,b,c,d;
    func3(double A=0,double B=0,double C=0,double D=0){a=A;b=B;c=C;d=D;}
    double operator()(double x){return ((a*x+b)*x+c)*x+d;}
    double dvt(double x){return (3.0*a*x+2.0*b)*x+c;}
};

void func3solve(func3 f,double st,double& val,double& sol)
{
    for(int i=1;!(abs(f(st))<1e-6) && i<=100;i++)
    {
        st=st-f(st)/f.dvt(st);
    }
    val=f(st);sol=st;
}

double fix2(double sol)
{
    return (double)int(sol*100.0+(sol>0?0.5:-0.5))/100.0;
}

set<double>solutions;
int main()
{
    double a,b,c,d;
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
    func3 f(a,b,c,d);
    for(double i=-100.0;i<=100.0;i+=0.5)
    {
        double val,sol;
        func3solve(f,i,val,sol);
        sol=fix2(sol);
        if(abs(val)<1e-6 && solutions.find(sol)==solutions.end())
            solutions.insert(sol);
    }
    for(set<double>::iterator it=solutions.begin();it!=solutions.end();it++)
    {
        double x=(*it);
        printf("%.2lf ",x);
    }
    return 0;
}
```
    - **核心思想**：定义`func3`类，重载`()`运算符计算函数值，`dvt`方法计算导数。`func3solve`函数实现牛顿迭代法，在给定范围内以0.5步长迭代寻找根，利用`set`去重并按序输出根。
3. **ryf2011**：
    - **星级**：4星
    - **关键亮点**：思路清晰，详细阐述二分法过程，代码注释丰富，对边界条件和精度控制处理得当。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const double eps=0.001; 
double a,b,c,d; 
int cnt; 
double f(double x){ 
    return a*x*x*x+b*x*x+c*x+d;
}
double binary_search(double l,double r){ 
    double mid=(l+r)/2.0; 
    if(l>=r-eps){ 
        return mid;
    }
    if(f(l)*f(mid)<0){ 
        return binary_search(l,mid);
    }
    else{ 
        return binary_search(mid,r);
    }
} 
int main(){
    scanf("%lf %lf %lf %lf",&a,&b,&c,&d); 
    for(int i=-100;i<100;i++){ 
        double l=i; 
        double r=i+1; 
        if(fabs(f(l))<=eps){ 
            printf("%.2lf ",l); 
            cnt++; 
        }
        else if(fabs(f(r))<=eps){
            continue; 
        }
        else if(f(l)*f(r)<0){ 
            printf("%.2lf ",binary_search(l,r)); 
            cnt++; 
        }
        if(cnt==3){ 
            break;
        }
    }
    return 0;
}
```
    - **核心思想**：定义`f`函数计算方程值，`binary_search`函数实现二分查找根，主函数中枚举长度为1的区间，根据区间端点函数值情况，判断是否找到根或进行二分查找，找到3个根后结束。

### 最优关键思路或技巧
1. **二分法**：利用根的范围及根间距条件，通过枚举小区间并在区间内二分查找，能高效准确找到根，避免暴力枚举的大量无效计算。
2. **牛顿迭代法**：通过构造函数切线逼近根，收敛速度较快，但需准确计算函数导数。

### 可拓展思路
1. 同类型题可涉及不同次数方程求解，或对方程根有不同限制条件的题目，可根据方程特点选择合适方法。
2. 类似算法套路如在数值计算领域，对于求解非线性方程，迭代法是常用思路，可根据具体问题选择不同迭代公式和优化策略。

### 相似知识点洛谷题目
1. [P1116 车厢重组](https://www.luogu.com.cn/problem/P1116)：涉及排序算法，与本题部分代码中的排序思路类似，可锻炼对数据处理和算法应用能力。
2. [P1083 借教室](https://www.luogu.com.cn/problem/P1083)：二分查找应用，与本题二分法思路相似，通过二分解决满足条件的最值问题。
3. [P2249 查找普及组](https://www.luogu.com.cn/problem/P2249)：考查查找算法，包括顺序查找、二分查找等，可巩固查找算法的应用。 

---
处理用时：120.03秒
# 题目信息

# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# AI分析结果

• 综合分析与结论：
    - 这些题解均采用动态规划方法解决该问题。核心思路是通过设计状态表示子树的最大加分，利用状态转移方程计算并更新最大加分，同时记录根节点以输出前序遍历。
    - 算法要点在于合理设计状态，如用二维数组 `f[i][j]` 表示节点 `i` 到 `j` 成树的最大加分；确定状态转移方程，通过枚举根节点 `k` 计算 `f[i][j] = max(f[i][k - 1] * f[k + 1][j] + f[k][k])`；并在计算过程中处理好边界情况，如空子树加分设为1。
    - 解决难点主要体现在对动态规划概念的理解与应用，确保状态设计满足无后效性，以及正确处理边界条件避免错误结果。
    - 整体来看，各题解思路相近，差异主要在代码实现细节与表述清晰度上。

所选的题解：
  - **作者：冒泡ioa (5星)**
    - **关键亮点**：思路清晰，先回顾动态规划概念，逐步推导状态设计与转移方程，代码简洁明了，注释详细。
    - **个人心得**：无
    - **重点代码**：
```cpp
void print(ll l, ll r) {
    if (l > r)return;
    printf("%lld ", root[l][r]);
    if (l == r)return;
    print(l, root[l][r] - 1);
    print(root[l][r]+1,r);
}

int main() {
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++)scanf("%lld", &f[i][i]),f[i][i-1]=1, root[i][i] = i;
    for (int len = 1; len < n; ++len) {
        for (int i = 1; i + len <= n; ++i) {
            int j = i + len;
            f[i][j] = f[i + 1][j] + f[i][i];//默认它的左子树为空，如果有的话，这肯定不是最优解
            root[i][j] = i;//默认从起点选根
            for (int k = i + 1; k < j; ++k) {
                if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                    f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                    root[i][j] = k;
                }
            }
        }
    }
    cout << f[1][n] << endl;
    print(1, n);
    return 0;
}
```
    - **核心实现思想**：`print` 函数递归输出前序遍历。`main` 函数中先初始化 `f` 数组和 `root` 数组，通过三层循环枚举区间长度、起点和根节点，更新 `f` 数组和 `root` 数组，最后输出最大加分和前序遍历。

  - **作者：winmt (4星)**
    - **关键亮点**：将问题拆解为三个任务，分别阐述计算最大分值、输出前序遍历及主程序的实现，逻辑清晰，给出多种语言代码片段。
    - **个人心得**：无
    - **重点代码**：
```cpp
long long search(int L, int r)    // 递归计算f[L][r]
{
    int  k;
    long long  now, ans;    // 当前分值
    if (L > r) return 1;
    if (f[L][r]== -1)     // 若尚未计算出顶点L..顶点r对应子树的最高分值
        for(k=L; k<=r; k++) {     // 穷举每一个可能的子根k
            now = search(L, k-1) * search(k+1, r) + f[k][k];  
// 计算以k为根的子树的分值
            if(now > f[L][r])  {
//若该分值为目前最高，则记入状态转移方程，并记下子根}
                f[L][r] = now; 
                root[L][r] = k;
            }
        }
    return  f[L][r];   {返回顶点L..顶点r对应子树的最高分值}
}

// 前序遍历顶点L..顶点r对应的子树
void  preorder(int L, int r)
{
    if (L > r)  return;
    if (firstwrite)
        firstwrite = false;
    else
        cout<<‘ ‘;      // 顶点间用空格分开
    cout << root[L][r];             // 输出子树的根
    preorder(L, root[L][r]-1);     // 前序遍历左子树
    preorder(root[L][r]+1, r);     // 前序遍历右子树
}

int main()
{
    int n, i;
    bool  firstwrite;
    cin >> n;    // 读顶点数
    for(i=1; i<=n; i++)      // 状态转移方程初始化
        for(j=i; j<=n; j++)
            f[i][j] = -1;
    for (i=1; i<=n; i++) {
        cin >> f[i][i];       // 读顶点i的分值
        root[i][i] = i;        // 顶点i单独成一棵子树
    }
    cout << search(1, n) << endl;      // 计算和输出最高加分
    firstwrite = true;                   // 设立首顶点标志
    preorder(1, n);                       // 前序遍历二叉树
    return 0;
}
```
    - **核心实现思想**：`search` 函数递归计算子树最大分值，通过记忆化减少重复计算。`preorder` 函数递归输出前序遍历。`main` 函数初始化数据，调用 `search` 计算最大加分，调用 `preorder` 输出前序遍历。

  - **作者：噬月 (4星)**
    - **关键亮点**：详细分析问题的最优子结构和无后效性，对状态转移方程、边界处理及等号讨论细致入微，帮助理解问题本质。
    - **个人心得**：无
    - **重点代码**：
```cpp
void print(long long l, long long r) {
    if (l > r) {
        return;
    }
    printf("%lld ", root[l][r]);
    if (l == r) {
        return;
    }
    print(l, root[l][r] - 1);
    print(root[l][r] + 1, r);
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++ i ) {
        cin >> f[i][i];//node
        f[i][i - 1] = 1;//left subtree error handling②
        f[i + 1][i] = 1;//right subtree error handling
        root[i][i] = i;
    }
    for (int range = 1; range <= n; ++ range ) {
        for (int i = 1; i + range <= n; ++ i ) {
            int j = i  + range;
            for (int k = i ; k <= j; ++ k ) {
                if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                    f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                    root[i][j] = k;
                }
            }
        }
    }
    cout << f[1][n] << endl;
    print(1, n);
    return 0;
}
```
    - **核心实现思想**：`print` 函数递归输出前序遍历。`main` 函数初始化 `f` 数组和 `root` 数组，通过三层循环枚举区间长度、起点和根节点，更新 `f` 数组和 `root` 数组，最后输出最大加分和前序遍历。

• 最优关键思路或技巧：
    - **状态设计**：使用二维数组 `f[i][j]` 表示节点 `i` 到 `j` 成树的最大加分，能有效利用子问题重叠性质，减少计算量。
    - **状态转移方程**：通过枚举根节点 `k`，计算 `f[i][j] = max(f[i][k - 1] * f[k + 1][j] + f[k][k])`，准确计算最大加分。
    - **边界处理**：将空子树加分设为1，保证计算的完整性。

• 可拓展之处：
    - 同类型题通常围绕树形结构或区间问题展开，类似算法套路是利用动态规划，设计合适状态和转移方程，处理好边界条件。如合并石子问题，通过区间DP计算合并的最小或最大代价。

• 推荐洛谷题目：
    - [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
    - [P4170 [CQOI2007] 涂色](https://www.luogu.com.cn/problem/P4170)
    - [P3146 [USACO16OPEN]248 G](https://www.luogu.com.cn/problem/P3146)

• 个人心得摘录与总结：无

---
处理用时：122.45秒
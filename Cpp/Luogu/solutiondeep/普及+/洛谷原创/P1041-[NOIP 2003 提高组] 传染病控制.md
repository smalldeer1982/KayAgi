# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果

这道题要求在给定树形传播途径的情况下，通过每次切断一条传播途径，使得最终被感染人数最少。由于题目数据范围小，大部分题解采用搜索算法。以下是对各题解的综合分析：
1. **思路**：多数题解先建树，再按深度分层处理。通过搜索枚举每层切断的节点，计算被感染人数。部分题解尝试贪心策略，但因存在反例而失败，少数题解采用随机化优化贪心。
2. **算法要点**：
    - **建图与分层**：使用邻接表、结构体数组等方式存储树结构，并通过深度优先搜索（DFS）或广度优先搜索（BFS）确定每个节点的深度，将节点按深度分层。
    - **搜索与回溯**：从根节点所在层的下一层开始，枚举每层的节点，假设切断该节点与父节点的边，标记该节点及其子树为安全（不被感染），递归搜索下一层，搜索完成后回溯恢复标记。
    - **统计与更新**：记录当前被感染人数或安全人数，在搜索过程中不断更新最少被感染人数。
3. **解决难点**：
    - **确定搜索方向**：部分题解尝试从拓扑排序或贪心角度入手，发现不可行后确定采用搜索算法，并确定以节点深度为搜索方向。
    - **处理树结构**：输入的边未明确父子关系，需通过预处理（如最短路算法、DFS等）确定树结构，并保证处理过程中树的父子关系正确。
    - **避免重复计算**：通过预处理子树大小、节点深度等信息，减少搜索过程中的重复计算。同时，在搜索过程中进行剪枝优化，如最优化剪枝，避免不必要的搜索。

综合来看，各题解质量参差不齐，思路清晰度、代码可读性和优化程度差异较大。以下是对各题解的简要评分：
1. **作者RikoHere**：3星。思路清晰，详细阐述了从分析题目到确定搜索算法的过程，分模块处理代码，便于调试。但代码实现相对复杂，部分命名随意。
2. **作者基础不牢**：4星。思路清晰，详细介绍了树的存储、标记深度、切断问题和搜索等步骤，代码注释详细，对搜索代码的优化有详细说明。
3. **作者欧鹰**：3星。详细描述了建图、预处理和搜索的过程，代码简单易懂，但缺乏对时间复杂度的分析和优化。
4. **作者流逝丶**：3星。思路明确，通过DFS求出节点相关信息，按深度进行搜索求解答案，但代码注释较少。
5. **作者majt**：4星。对题目贪心策略的分析到位，搜索框架清晰，代码实现简洁，有最优化剪枝。
6. **作者Ciyang**：3星。不仅给出了搜索的正解，还详细分析了错误的DP思路，有助于理解题意，但代码注释较少。
7. **作者Makasukaka**：2星。采用随机化思路，通过较大概率选取子孙节点多的点进行删边，但未对随机化原理和效果进行深入分析，代码较乱。
8. **作者山水一程_**：3星。思路独特，从倒着求解最多能保护多少个节点的角度出发，但代码实现过程中部分变量命名不够清晰。
9. **作者onglu**：3星。采用暴力模拟的方法，代码简单直接，但未进行优化，可能在大数据下效率较低。
10. **作者薄荷凉了夏**：3星。按层搜索思路清晰，详细描述了记录内容和更新答案条件，但代码实现过程中部分变量作用不够明确。
11. **作者早右昕**：3星。详细描述了搜索思路和优化方法，代码有一定注释，但整体表述较为繁琐。
12. **作者windows250**：3星。采用深搜+剪枝的方法，代码注释详细，但在处理边的存储和搜索过程中，代码结构相对复杂。
13. **作者blackzebra**：3星。思路清晰，通过vector存图，利用节点指向父节点判断祖先是否被保护，但代码实现过程中部分变量命名不够直观。
14. **作者1124828077ccj**：3星。通过搜索枚举每层删除的节点，代码实现较为简单，但缺乏对搜索过程的详细注释和优化。
15. **作者顾z**：2星。贪心思路虽被卡，但代码实现了贪心算法，可作为错误思路参考，未涉及正确解法。
16. **作者zi小眼聚光**：3星。采用A*搜索算法，通过估价函数进行剪枝，但对A*算法的原理和实现细节解释不够清晰。
17. **作者万弘**：3星。分层搜索思路明确，代码实现了建树和搜索过程，但代码注释较少，不利于理解。
18. **作者sun123zxy**：2星。采用贪心+随机化的方法，但随机化部分实现较为简单，未对随机化效果进行分析。
19. **作者翠竹叶飞**：3星。采用dfs+剪枝的方法，对dfs过程有一定优化，但代码实现过程中部分变量命名不够清晰，注释较少。
20. **作者Expecto**：2星。采用随机化方法，代码实现简单，但未对随机化原理和效果进行分析，多次随机得到正确答案的方式较依赖运气。
21. **作者lian_sama**：2星。采用随机数题解，通过链表存图和多次随机得到答案，但未对随机化原理和效果进行分析，代码实现过程中部分变量命名不够清晰。
22. **作者henry_y**：3星。采用贪心+随机化的方法，对贪心的错误原因进行了分析，随机化部分有一定思路，但代码实现过程中部分变量命名不够清晰。
23. **作者清尘**：3星。通过暴力dfs枚举方案，代码实现了预处理和搜索过程，但代码注释较少，不利于理解。
24. **作者灼眼的夏娜**：3星。详细描述了搜索思路和过程，对特殊情况进行了特判，但代码实现过程中部分变量命名不够清晰。
25. **作者吴国铨**：3星。采用搜索算法，详细描述了构建有向树和递归计算被感染最少人数的过程，但代码采用Pascal语言，且未给出完整代码。
26. **作者封禁用户**：3星。采用搜索算法，按层搜索并记录一定不会被传染的人数，但代码采用Pascal语言，且部分变量命名不够清晰。
27. **作者ljcljc**：3星。采用深搜算法，详细描述了算法思路和优化方法，代码实现简洁，但注释较少。

评分较高（≥4星）的题解：
- **作者基础不牢**：
  - **星级**：4星
  - **关键亮点**：思路清晰，步骤详细，从树的存储、标记深度、切断问题到搜索，每个环节都有详细说明，代码注释丰富，对搜索代码的优化有具体解释。
  - **个人心得**：无
  - **重点代码**：
```cpp
void Input(void)
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)//初始化
    {
        node[i].number=0;
        count[i]=1;
    }
    for(i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        if(x>y) swap(x,y);
        node[y].father=x;
        node[x].number++;
        node[x].child[node[x].number]=y;
    }
}
void Deep(int tree,int now)//当前的节点标号是tree，层数是now
{
    maxx=max(maxx,now);//标记一共有几层
    for(int i=1;i<=node[tree].number;i++)
    {
        deep[now][0]++;//个数+1
        deep[now][deep[now][0]]=node[tree].child[i];//把这个节点放到第i层的数组中
        Deep(node[tree].child[i],now+1);//以这个点为父节点继续标记它的儿子。每个节点的深度等于它父节点的深度+1
    }
    return ;

}
int Count(int tree)
{
    for(int i=1;i<=node[tree].number;i++)
    {
        count[tree]+=Count(node[tree].child[i]);
    }
    return count[tree];
}
void work(int tree,int tag)
{
    for(int i=1;i<=node[tree].number;i++)
    {
        vis[node[tree].child[i]]=tag;
        work(node[tree].child[i],tag);
    }
    return ;
}
void dfs(int now,int cnt) 
{
    if(now==maxx)
    {
        ans=min(ans,cnt);
        return ;
    }
    int f=0;
    for(int i=1;i<=deep[now][0];i++)
    {
        if(vis[deep[now][i]]>0)
        {
            f++;
            continue;
        }
        vis[deep[now][i]]=1;
        work(deep[now][i],1);
        dfs(now+1,cnt-count[deep[now][i]]);
        vis[deep[now][i]]=0;
        work(deep[now][i],0);
    }
    if(f==deep[now][0]) ans=min(ans,cnt);
}
```
  - **核心实现思想**：`Input`函数用于读入数据并构建树结构；`Deep`函数标记每个节点的深度，并将同一深度的节点存入数组；`Count`函数计算以某个节点为根的子树节点数；`work`函数标记或清除以某个节点为根的子树的感染状态；`dfs`函数为搜索核心，枚举每层节点，标记子树，递归搜索下一层，更新最少感染人数。
- **作者majt**：
  - **星级**：4星
  - **关键亮点**：对题目贪心策略分析准确，搜索框架清晰，采用最优化剪枝，代码简洁。
  - **个人心得**：无
  - **重点代码**：
```cpp
void build(){//build up the tree
    queue <int> q;
    q.push(1),stor[1].pb(1),deep[1]=1;
    while(!q.empty()){
        int cur=q.front();
        maxdep=max(maxdep,deep[cur]);
        q.pop();
        for(int i=0;i<g[cur].size();++i)
            if(g[cur][i]!=fa[cur]){
                deep[g[cur][i]]=deep[cur]+1;
                fa[g[cur][i]]=cur;
                stor[deep[g[cur][i]]].pb(g[cur][i]);
                q.push(g[cur][i]);
            }
    }
}
void dfs(int st,int sum){
    if(sum>ans) return;
    if(st>maxdep){
        ans=min(ans,sum);
        return;
    }
    int tmp=0;
    for(int i=0;i<stor[st].size();++i)
        if(tag[fa[stor[st][i]]])
            tmp++,tag[stor[st][i]]=st;
    if(tmp==stor[st].size()){
        ans=min(ans,sum);
        return;
    }
    for(int i=0;i<stor[st].size();++i){
        if(tag[stor[st][i]]) continue;
        tag[stor[st][i]]=true;
        dfs(st+1,sum+stor[st].size()-tmp-1);
        tag[stor[st][i]]=false;
    }
    for(int i=1;i<=n;++i)
        if(tag[i]==st) tag[i]=0;    
}
```
  - **核心实现思想**：`build`函数通过BFS对树进行分层，记录每个节点的深度和父节点；`dfs`函数为搜索过程，若当前感染人数大于已有答案则剪枝，若到达最大深度则更新答案。在每层中，先标记父节点已被保护的节点，若该层所有节点都已被保护则更新答案，否则枚举每个未被保护的节点，标记该节点，递归搜索下一层，搜索结束后回溯。

最优的关键思路或技巧：
1. **按深度分层搜索**：将节点按到根节点的距离分层，从根节点所在层的下一层开始枚举每层切断的节点，简化搜索空间。
2. **预处理信息**：提前计算每个节点的子树大小、深度等信息，减少搜索过程中的重复计算。
3. **剪枝优化**：在搜索过程中，通过最优化剪枝（如当前感染人数大于已有答案则剪枝），避免不必要的搜索，提高搜索效率。

可拓展之处：
1. **同类型题**：此类题目通常涉及树形结构上的决策问题，通过搜索或动态规划求解。例如，在树形结构上进行资源分配、路径选择等问题。
2. **类似算法套路**：对于树形结构问题，常采用DFS或BFS遍历树，获取节点信息。在搜索过程中，通过剪枝优化搜索空间。对于小规模数据，暴力搜索可能是可行的方法；对于大规模数据，可能需要更高效的算法或优化技巧。

推荐题目：
1. **P1314 聪明的质检员**：通过二分答案和前缀和优化搜索过程，与本题类似，需要对问题进行分析和优化。
2. **P1135 奇怪的电梯**：可以使用BFS解决，与本题在搜索思想上有相似之处，涉及状态转移和搜索空间的处理。
3. **P1433 吃奶酪**：搜索算法的应用，通过合理的状态表示和剪枝优化搜索过程，与本题在算法优化方面有一定的相似性。

个人心得摘录与总结：
1. **作者Ciyang**：尝试用DP解决问题，但因不符合题目中每个疾病传播周期只能切断一条传播途径的要求而失败。通过分析错误的DP思路，加深了对题意的理解。总结出在解决问题时，要仔细分析题目条件，确保算法符合题意。
2. **作者Makasukaka**：一开始采用贪心策略，构造数据发现错误后，采用随机化思路解决问题。反映出在解题过程中，要对自己的算法进行严格验证，遇到错误及时调整思路。
3. **作者顾z**：采用贪心策略得到90分，但意识到贪心是错解。说明在解题时不能仅满足于部分正确的解法，要深入思考算法的正确性。 

---
处理用时：224.42秒
# 题目信息

# [NOIP 2008 普及组] 排座椅

## 题目描述

上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 $D$ 对同学上课时会交头接耳。

同学们在教室中坐成了 $M$ 行 $N$ 列，坐在第 $i$ 行第 $j$ 列的同学的位置是 $(i,j)$，为了方便同学们进出，在教室中设置了 $K$ 条横向的通道，$L$ 条纵向的通道。

于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 $2$ 个会交头接耳的同学，那么他们就不会交头接耳了。

请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。


## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/0z0p5x1i.png)

上图中用符号\*、※、+标出了 $3$ 对会交头接耳的学生的位置，图中 $3$ 条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。

2008 年普及组第二题


## 样例 #1

### 输入

```
4 5 1 2 3
4 2 4 3
2 3 3 3
2 5 2 4
```

### 输出

```
2
2 4
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均为贪心算法，旨在让每一条通道隔开尽可能多的交头接耳同学对数，从而实现整体交头接耳对数最少。具体步骤为：先统计每行、每列能阻断的交头接耳同学对数，再通过排序选取阻断对数最多的前K条横向通道和前L条纵向通道。
各题解在实现细节上略有差异，例如数据结构的选择、排序方式及具体代码实现。整体来看，多数题解思路清晰，但在代码可读性和优化程度上存在一定提升空间。

### 所选的题解
- **作者：chrispang (赞：12)  星级：4星**
    - **关键亮点**：思路清晰，代码简洁明了。使用结构体分别记录横向和纵向通道的坐标及可分开人数，两次排序分别按分开人数和坐标进行，逻辑清晰易懂。
    - **重点代码**：
```cpp
struct node{
    int x, n; 
}x[1010], y[1010];

bool cmp1(node a, node b) { 
    return a.n > b.n;
}

bool cmp2(node a, node b) { 
    return a.x < b.x;
}

int main() {
    cin >> m >> n >> k >> l >> d;
    for (int i = 1; i <= d; i++) {
        int x1, y1, p1, q1;
        cin >> x1 >> y1 >> p1 >> q1;
        if(x1 == p1) {
            y[min(y1, q1)].x = min(y1, q1); 
            y[min(y1, q1)].n++; 
        }
        if(y1 == q1) {
            x[min(x1, p1)].x = min(x1, p1); 
            x[min(x1, p1)].n++; 
        }
    }
    sort(x + 1, x + 1 + 1000, cmp1); 
    sort(y + 1, y + 1 + 1000, cmp1);
    sort(x + 1, x + 1 + k, cmp2); 
    sort(y + 1, y + 1 + l, cmp2);
    for (int i = 1; i <= k; i++)
        cout << x[i].x << " ";
    cout << endl;
    for (int i = 1; i <= l; i++)
        cout << y[i].x << " ";
    return 0;
}
```
    - **核心实现思想**：定义结构体记录通道信息，输入时统计各通道可分开人数，先按人数从大到小排序，再按坐标从小到大排序，最后输出结果。
- **作者：Feuer (赞：11)  星级：4星**
    - **关键亮点**：利用类似桶排序的思想，通过数组存储每个过道可分开的对数，借助两次sort选出最佳的K个/L个过道的临界值，输出时只输出大于等于临界值的过道，代码简洁高效。
    - **重点代码**：
```cpp
int rowpos[1005];  
int rowcopy[1005];  
int colpos[1005];
int colcopy[1005];

int main(void)
{
    int m,n,k,l,d;  

    for(int i=0;i<1005;i++)
    {
        rowpos[i] = 0;
        rowcopy[i] = 0;
        colpos[i] = 0;
        colcopy[i] = 0;
    }

    cin>>m>>n>>k>>l>>d;

    while(d--)
    {
        int x,y,p,q;
        int pos = 0;  

        cin>>x>>y>>p>>q;

        if(x==p)
        {
            pos = min(y,q);
            colpos[pos]++;
            colcopy[pos]++;
        }
        else
        {
            pos = min(x,p);
            rowpos[pos]++;
            rowcopy[pos]++;
        }

    }

    sort(rowpos, rowpos+m);
    sort(colpos, colpos+n);
    int rowlim = rowpos[m-k];
    int collim = colpos[n-l];

    for(int i=1; i<=m; i++)
        if(rowcopy[i] >= rowlim)
            cout<<i<<' ';
    cout<<endl;
    for(int i=1; i<=n; i++)
        if(colcopy[i] >= collim)
            cout<<i<<' ';
    cout<<endl;

    return 0;
}
```
    - **核心实现思想**：初始化数组记录每行、列可分开对数，输入时统计，排序后获取临界值，根据临界值输出最终结果。
- **作者：ggpw_XNW (赞：6)  星级：4星**
    - **关键亮点**：对贪心算法的应用讲解详细，结构体设计巧妙，通过排序确定最佳通道位置，对贪心算法的适用性进行了分析。
    - **重点代码**：
```cpp
struct Node{
    int num, p;
}a[10005], b[10005];

bool cmp1(Node x, Node y){
    return x.num > y.num;
}
bool cmp2(Node x, Node y){
    return x.p < y.p;
}

int main()
{
    cin >> m >> n >> k >> l >> d;
    for(int i=1;i<=d;i++){
        int x, y, xx, yy;
        cin >> x >> y >> xx >> yy;
        if(x==xx)b[min(y,yy)].p = min(y,yy), b[min(y,yy)].num++;
        else a[min(x,xx)].p = min(x,xx), a[min(x,xx)].num++;
    }
    sort(a+1,a+m+1,cmp1);sort(b+1,b+n+1,cmp1);
    sort(a+1,a+k+1,cmp2);sort(b+1,b+l+1,cmp2);
    for(int i = 1; i <= k; i++) cout << a[i].p << " ";
    cout << endl;
    for(int i = 1; i <= l; i++) cout << b[i].p << " ";
    return 0;
}
```
    - **核心实现思想**：定义结构体记录通道信息，输入时统计各通道分开对数，先按分开对数排序，再按位置排序，最后输出结果。

### 最优关键思路或技巧
1. **贪心策略**：优先选择能隔开最多交头接耳同学对数的通道位置，确保每一步选择都是局部最优，从而达到整体最优。
2. **数据结构选择**：使用结构体或数组记录通道位置及其能隔开的同学对数，方便数据处理和排序。
3. **两次排序**：第一次按能隔开的同学对数从大到小排序，选出最优通道；第二次按通道位置从小到大排序，满足输出要求。

### 可拓展之处
此类题目属于贪心策略在矩阵布局优化问题中的应用。相似套路是分析每个决策点对目标的影响，通过贪心选择局部最优决策逐步构建全局最优解。同类型题通常围绕资源分配、布局规划等场景，在给定限制条件下求最优方案。

### 相似知识点洛谷题目
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：考查贪心策略，根据物品重量限制进行分组。
2. [P1181 数列分段 Section I](https://www.luogu.com.cn/problem/P1181)：通过贪心确定数列分段方式，使每段和满足一定条件。
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：利用贪心算法，根据接水时间安排排队顺序，使总等待时间最短。

### 个人心得摘录与总结
作者RedContritio提到不要使用快排，因为快排不稳定，容易造成ID混乱，对于本题数据量，使用冒泡排序可避免此问题。总结为在排序时需关注排序算法的稳定性，根据题目需求选择合适排序方法。 

---
处理用时：107.68秒
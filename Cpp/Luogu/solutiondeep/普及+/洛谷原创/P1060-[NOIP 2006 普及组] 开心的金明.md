# 题目信息

# [NOIP 2006 普及组] 开心的金明

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $N$ 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $N$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1-5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过 $N$ 元（可以等于 $N$ 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第$j$件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,…,j_k$，则所求的总和为：

$$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2} …+v_{j_k} \times w_{j_k}$$

请你帮助金明设计一个满足要求的购物单。

## 说明/提示

NOIP 2006 普及组 第二题


## 样例 #1

### 输入

```
1000 5
800 2
400 5
300 5
400 3
200 2
```

### 输出

```
3900```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解都识别出本题为01背包问题，将物品价格与重要度乘积作为价值，价格作为重量，通过状态转移方程求解。部分题解还提供了DFS和二进制枚举等暴力解法。
    - 算法要点：01背包问题的状态转移方程为$f[i][j] = \max(f[i - 1][j], f[i - 1][j - w[i]] + v[i])$，其中$f[i][j]$表示前$i$个物品在背包容量为$j$时的最大价值。部分题解使用滚动数组优化空间，将二维数组优化为一维数组。
    - 解决难点：理解01背包问题的本质及状态转移方程的推导，以及如何根据题目条件正确建模。暴力解法需注意数据范围，避免超时。
    - 评分情况：多数题解思路清晰，但在代码可读性和优化程度上有所差异。部分题解代码简洁，注释详细，对背包问题的讲解深入；部分题解代码稍显冗长，注释较少。
    - 综合来看，以下题解在思路清晰度、代码可读性和优化程度上表现较好：
  - 作者：oier1459078309 (5星)
    - 关键亮点：不仅给出本题的01背包解法，还详细列举了01背包、完全背包、多重背包等多种背包问题的模板，对读者学习背包问题有很大帮助。代码简洁明了，注释详细。
    - 个人心得：无
  - 作者：phigy (4星)
    - 关键亮点：先给出常规的01背包动态规划解法，又针对不会DP的读者提供了DFS解法，并分析了数据范围说明DFS的可行性，代码注释详细。
    - 个人心得：无
  - 作者：superLouis (4星)
    - 关键亮点：解题思路清晰，详细阐述了如何将题目转化为经典背包问题，并给出状态转移方程。代码简洁，使用了快速读入优化，且对变量含义注释清晰。
    - 个人心得：无

### 重点代码及核心实现思想
#### oier1459078309题解代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int w[30],v[30],f[50000];//w数组为重要度，v数组为money，f是用来dp的数组
int n,m;//n是总物品个数，m是总钱数
int main()
{
    cin>>m>>n;//输入
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
        w[i]*=v[i];//w数组在这里意义变为总收获（重要度*money）
    }
       //01背包（参照第二类模板“一维数组优化”）
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=v[i];j--)//注意从m开始
        {
            if(j>=v[i])
            {
                f[j]=max(f[j],f[j-v[i]]+w[i]);//dp
            }
        }
    }
    cout<<f[m]<<endl;//背包大小为m时最大值
    return 0;
} 
```
核心实现思想：先读入物品价格和重要度，将两者乘积作为价值存入`w`数组。然后使用一维数组优化的01背包算法，通过双重循环遍历物品和背包容量，根据状态转移方程更新`f`数组，最终输出背包容量为`m`时的最大价值。

#### phigy题解代码（01背包部分）
```cpp
#include <iostream>
using namespace std;
int f[30][100000];
int w[10000];
int v[10000];
int main()
{
    int n,m;
    int i,j,k;
    cin>>m>>n;
    //提前相乘
    for(i=1;i<=n;i++)
    {
        cin>>w[i]>>v[i];
        v[i]*=w[i];
    }
    for(int i=1;i<=n;i++)
    {
        //01背包最关键的位置,为防止反复加同一物品，需要倒着搜，这也是01背包与完全背包的不同之处
        for(int c=0;c<=m;c++)
        {
            f[i][c]=f[i-1][c];
            if(c>=w[i])
            f[i][c]=max(f[i][c],f[i-1][c-w[i]]+v[i]);
        }
    }
    cout<<f[n][m];
    return 0;
}
```
核心实现思想：先读入物品价格和重要度并计算乘积作为价值存入`v`数组。通过二维数组`f`记录状态，外层循环遍历物品，内层循环遍历背包容量，根据状态转移方程更新`f`数组，最终输出前`n`个物品在背包容量为`m`时的最大价值。

#### superLouis题解代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
constexpr int maxn = 30;
constexpr int maxm = 3e4 + 10;
int n, m, v[maxn], w[maxn];
int f[maxm];
// f[i] 表示花费钱数 ≤ i 的重要度乘积的总和的最大值
inline int read() {
    register int x = 0, f = 1;
    char c = getchar();
    if (c == '-') f = -1;
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + c - '0';
        c = getchar();
    }
    return x * f;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    m = read(); n = read();
    for (int i = 1; i <= n; i++) {
        w[i] = read();
        int p = read();
        v[i] = w[i] * p;
    }
    for (int i = 1; i <= n; i++) 
        for (int j = m; j >= w[i]; j--) 
            f[j] = max(f[j], f[j - w[i]] + v[i]);
    cout << f[m] << "\n";
    return 0;
}
```
核心实现思想：通过快速读入优化输入，将物品价格与重要度乘积作为价值存入`v`数组，价格作为重量存入`w`数组。使用一维数组`f`记录状态，通过双重循环遍历物品和背包容量，根据状态转移方程更新`f`数组，最终输出背包容量为`m`时的最大价值。

### 最优关键思路或技巧
- **滚动数组优化空间**：许多题解使用滚动数组将01背包问题的二维状态数组优化为一维，降低空间复杂度，同时注意内层循环从大到小遍历，防止同一物品多次放入背包。
- **问题转化**：将题目中的物品价格与重要度乘积作为价值，价格作为重量，成功将原问题转化为经典的01背包问题，体现了对问题建模的重要性。

### 可拓展之处
同类型题或类似算法套路：背包问题有多种变体，如完全背包（每种物品数量无限）、多重背包（每种物品有固定数量）、分组背包（物品分为多组，每组只能选一个）等。解决这些问题的关键在于理解每种背包问题的特点，正确推导状态转移方程，并根据实际情况进行优化。

### 推荐题目
- [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)：典型的01背包问题，通过采药时间和价值的限制，求解最大价值。
- [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)：完全背包问题，每种草药数量无限，根据采药时间限制求最大价值。
- [P2602 [ZJOI2010] 数字计数](https://www.luogu.com.cn/problem/P2602)：可通过数位DP转化为类似背包问题的思路，统计数字出现次数。 

---
处理用时：119.19秒
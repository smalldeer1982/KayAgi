# 题目信息

# [NOIP 2004 普及组] FBI 树

## 题目描述

我们可以把由 0 和 1 组成的字符串分为三类：全 0 串称为 B 串，全 1 串称为 I 串，既含 0 又含 1 的串则称为 F 串。

FBI 树是一种二叉树，它的结点类型也包括 F 结点，B 结点和 I 结点三种。由一个长度为 $2^N$ 的 01 串 $S$ 可以构造出一棵 FBI 树 $T$，递归的构造方法如下：

1. $T$ 的根结点为 $R$，其类型与串 $S$ 的类型相同；
2. 若串 $S$ 的长度大于 $1$，将串 $S$ 从中间分开，分为等长的左右子串 $S_1$ 和 $S_2$；由左子串 $S_1$ 构造 $R$ 的左子树 $T_1$，由右子串 $S_2$ 构造 $R$ 的右子树 $T_2$。

现在给定一个长度为 $2^N$ 的 01 串，请用上述构造方法构造出一棵 FBI 树，并输出它的后序遍历序列。


## 说明/提示

对于 $40\%$ 的数据，$N \le 2$；

对于全部的数据，$N \le 10$。


noip2004普及组第3题


## 样例 #1

### 输入

```
3
10001011
```

### 输出

```
IBFBBBFIBFIIIFF
```

# AI分析结果

这道题要求根据给定的长度为\(2^N\)的01串构造FBI树，并输出其后序遍历序列。各题解主要围绕递归建树、后序遍历输出以及节点类型判断展开。

1. **思路**：多数题解采用递归方式，依据题目给定的规则构造树，在递归过程中实现后序遍历输出。部分题解利用满二叉树性质，通过数组模拟树结构，减少实际建树操作。
2. **算法要点**：
    - **建树**：按照题目规则，将字符串从中间分开，递归构造左右子树。
    - **后序遍历**：先递归处理左右子树，再处理根节点，实现后序遍历输出。
    - **节点类型判断**：判断子串中0和1的情况，确定节点类型为F、B或I。
3. **解决难点**：如何在递归过程中准确实现建树与后序遍历的结合，以及高效判断节点类型。部分题解通过将建树和输出过程集成，减少代码复杂度；部分利用满二叉树性质优化空间和时间复杂度。

综合来看，各题解质量参差不齐，思路清晰度、代码可读性和优化程度差异较大。部分题解代码冗长复杂，部分则简洁高效。以下是评分较高的题解：

### 作者：ingu (赞：262)
- **星级**：5星
- **关键亮点**：思路清晰，将建树、后序遍历和节点类型判断分别阐述，代码简洁明了，可读性高。把建树过程看作树的先序遍历，输出过程与建树集成，通过在递归调用之后放置输出代码实现后序遍历。
- **个人心得**：无
```cpp
#include <iostream>
using namespace std;
char s[1050];
void maketree(int x,int y){
    if(y>x){
        maketree(x,(x+y)/2);
        maketree((x+y+1)/2,y);
    }    
    int B=1,I=1;
    for(int i=0;i<=y-x;i++){
        if(s[x+i]=='1'){
            B=0;
        }else if(s[x+i]=='0'){
            I=0;
        }
    }
    if(B){
        cout<<'B';
    }else if(I){
        cout<<'I';
    }else{
        cout<<'F';
    }
}
int main() {
    int n;
    cin>>n>>s;
    maketree(0,(1<<n)-1);
    return 0;
}
```
核心实现思想：`maketree`函数通过递归实现建树与后序遍历，先递归构建左右子树，再根据子串中0和1的情况判断并输出当前节点类型。

### 作者：_somnambulist_ (赞：11)
- **星级**：4星
- **关键亮点**：代码极简，通过递归边构造边输出，利用字符串截取和自定义函数判断节点类型，思路巧妙。
- **个人心得**：无
```cpp
char get_TYPE(string x){//x是需要判断的字符串
    char y;
    y=x[0];
    for(int i=1;i<x.size();i++)
        if(x[i]!=y) return 'F';
    if(y=='0') return 'B';
    else return 'I';
}
void FBI(int beg,int end){//beg是串的开头，end是结尾
    if(beg==end)
    {
        cout<<get_TYPE(a.substr(beg,end-beg+1));//截取子串
        return;
    }
    FBI(beg,(beg+end)/2);//遍历左子树
    FBI((beg+end)/2+1,end);//右子树，别忘了加1
    cout<<get_TYPE(a.substr(beg,end-beg+1));
    return;
}
```
核心实现思想：`get_TYPE`函数判断字符串类型，`FBI`函数递归遍历左右子树，并在每次递归结束时判断并输出当前子串类型。

### 作者：zhengrunzhe (赞：4)
- **星级**：4星
- **关键亮点**：利用`string`的相关函数，代码简洁。通过`find`函数判断子串中0和1的存在情况确定节点类型，递归实现后序遍历输出。
- **个人心得**：无
```cpp
char fbi(int L,int R)   //返回是F还是B还是I
{
    if (find(s.begin()+L,s.begin()+R+1,'1')==s.begin()+R+1)return 'B';   //如果没找到'1'，那么就是只有'0'，就是一棵B树
    if (find(s.begin()+L,s.begin()+R+1,'0')==s.begin()+R+1)return 'I';    //如果没找到'0'，那么就是只有'1'，是I树
    return 'F';   //如果找到了'0'也找到了'1'，那么就是F树
}
void bl(int l,int r)   //后序遍历
{
    if (l!=r)   //如果可以分割
    {
        bl(l,(l+r)/2);   //左边
        bl((l+r)/2+1,r);   //右边
    }
    cout<<fbi(l,r);   输出
}
```
核心实现思想：`fbi`函数判断节点类型，`bl`函数递归进行后序遍历，先递归处理左右子树，再输出当前节点类型。

### 最优关键思路或技巧
1. **递归与后序遍历结合**：许多题解通过递归实现建树和后序遍历，在递归函数中，先处理左右子树，再处理根节点，自然实现后序遍历。
2. **利用满二叉树性质**：部分题解利用满二叉树节点编号规律，通过数组模拟树结构，减少实际建树的空间和时间开销。
3. **字符串处理技巧**：如使用`string`的`substr`、`find`等函数，方便地截取子串和判断字符存在情况，简化节点类型判断过程。

### 同类型题或类似算法套路
1. **同类型题**：涉及二叉树的构造与遍历，如根据特定规则构造二叉树，并输出某种遍历序列。通常需要理解树的递归定义和各种遍历方式的实现。
2. **类似算法套路**：在处理具有递归结构的数据时，可考虑递归算法，将大问题分解为小问题。同时，利用数据结构的特性（如满二叉树性质）优化算法。在判断数据特征时，注意使用合适的方法（如字符串查找函数）提高效率。

### 相似知识点洛谷题目
1. **P1030 [NOIP2001 普及组] 求先序排列**：根据中序和后序遍历序列求先序遍历序列，考察二叉树遍历知识。
2. **P1086 [NOIP2004 普及组] 花生采摘**：虽不是二叉树问题，但同样需要理解递归和贪心思想，与本题递归思路有相似之处。
3. **P1305 [NOIP2011 普及组] 新二叉树**：根据给定的表达式构造二叉树并进行遍历，涉及二叉树的构造与遍历操作。 

---
处理用时：131.89秒
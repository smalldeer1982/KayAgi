# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效求解满足A - B = C的数对个数展开，涉及多种算法思路，包括基于映射（map）、二分查找、双指针、哈希（HASH）等方法。各题解在思路清晰度、代码可读性、优化程度上存在差异。

### 所选的题解
- **作者：OsvaldoAsensioLopez (赞：789)**
  - **星级**：5星
  - **关键亮点**：思路清晰简洁，将A - B = C转化为A - C = B，利用map统计每个元素出现次数，通过一次遍历计算满足条件数对，代码简洁高效。
  - **重点代码**：
```cpp
#include <iostream>
#include <map>
using namespace std;
typedef long long LL;
LL a[200001];
map<LL,LL> m;
int main() {
    int n;
    LL c;
    LL ans=0;
    cin >> n >> c;
    for(int i=1;i<=n;i++) {
        cin >> a[i];
        m[a[i]]++;
        a[i]-=c;    
    } 
    for(int i=1;i<=n;i++) ans+=m[a[i]];
    cout << ans << endl;
    return 0;
}
```
  - **核心思想**：先将输入数存入数组并在map中记录其出现次数，同时将该数减去C。之后遍历数组，累加map中对应差值的出现次数，即为满足条件的数对个数。

- **作者：樱花飞舞 (赞：536)**
  - **星级**：4星
  - **关键亮点**：巧妙运用二分查找的lower_bound和upper_bound函数，通过对数组排序后，利用这两个函数确定每个A对应的满足A - B = C的B的位置范围，进而计算数对个数，时间复杂度为O(NlogN)。
  - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long a[200001];
long N,C,ans;
int main()
{
    cin>>N>>C;
    for(int i=1;i<=N;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+N+1);
    for(int i=1;i<=N;i++)
    {
        ans+=((upper_bound(a+1,a+N+1,a[i]+C)-a)-(lower_bound(a+1,a+N+1,a[i]+C)-a));
    }
    cout<<ans;
    return 0;
}
```
  - **核心思想**：先对数组排序，然后遍历数组，对每个元素a[i]，用upper_bound和lower_bound函数计算a[i] + C在数组中的出现次数，累加得到满足条件的数对总数。

- **作者：jins3599 (赞：461)**
  - **星级**：4星
  - **关键亮点**：采用双指针法，利用排序后数组的有序性，通过维护两个右端点指针，找到每个数对应的满足条件的连续区间，从而计算数对个数，避免了不必要的重复计算，代码简洁且高效。
  - **重点代码**：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2e5 + 10;
int n, c;
int a[N];
int main () 
{
	cin >> n >> c;
	for(int i = 1 ; i <= n ; i ++) cin >> a[i];
	sort(a + 1, a + 1 + n);
	int l = 1, r1 = 1, r2 = 1;
	ll ans = 0;
	for(l = 1 ; l <= n ; l ++) {
		while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
		while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
		if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
			ans += r1 - r2;
	}
	cout << ans;
	return 0;
}
```
  - **核心思想**：对数组排序后，通过双指针l、r1、r2，移动r1、r2指针找到满足a[r1] - a[l] <= c和a[r2] - a[l] < c的位置，若满足条件则计算该区间内满足A - B = C的数对个数并累加。

### 最优关键思路或技巧
- **转换思路**：将A - B = C转化为A - C = B，便于通过查找B的数量来确定数对个数。
- **数据结构运用**：利用map映射统计元素出现次数，能快速查询和计数，降低时间复杂度。
- **二分查找**：对有序数组使用二分查找相关函数（如lower_bound和upper_bound），高效确定满足条件的元素位置范围，从而计算数对个数。
- **双指针法**：利用数组有序性，通过移动指针维护满足条件的区间，避免重复计算，提高算法效率。

### 可拓展之处
同类型题可涉及两数之和、三数之和等问题，类似算法套路包括利用排序和双指针来优化暴力枚举，或使用哈希表来降低查找时间复杂度。例如在两数之和问题中，可通过哈希表快速查找目标值与当前数的差值是否存在。

### 相似知识点洛谷题目
- **P1160 队列安排**：涉及链表和双指针的运用，与本题双指针思路有相似之处，需根据条件移动指针维护队列。
- **P2678 [NOIP2015 普及组] 跳石头**：考查二分查找的应用，通过二分查找合适的跳跃距离，与本题二分查找思路类似。
- **P3370 【模板】字符串哈希**：与本题哈希思路相关，通过字符串哈希算法解决字符串匹配等问题，可加深对哈希算法的理解。

### 个人心得摘录与总结
部分作者提到在处理本题时，一开始采用暴力枚举但因数据规模大而超时，之后通过转换思路、运用合适的数据结构或算法（如map、二分、双指针等）成功优化。这表明在面对算法题时，需充分考虑数据规模，不能局限于简单暴力解法，要善于转换思维，灵活运用各种数据结构和算法进行优化。 

---
处理用时：93.40秒
# 题目信息

# 小木棍

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。

现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。

给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。


## 说明/提示

对于全部测试点，$1 \leq n \leq 65$，$1 \leq a_i \leq 50$。

## 样例 #1

### 输入

```
9
5 2 1 5 2 1 5 2 1
```

### 输出

```
6```

# AI分析结果

这道题是搜索剪枝类型题目，核心是通过剪枝优化搜索过程，找到原始木棍的最小可能长度。
1. **思路**：先读入小木棍长度并过滤大于50的，计算总长度、最大长度等。然后在最大长度到总长度一半（或总长度）范围内枚举原始木棍长度，判断能否用给定小木棍拼成该长度的若干根木棍，找到第一个可行长度即为答案。
2. **算法要点**：
    - **排序**：对小木棍按长度从大到小排序，方便后续剪枝。
    - **剪枝优化**：如原始长度需是总长度因数；避免重复搜索相同长度木棍；当前长棍剩余未拼长度等于当前木棍长度或原始长度，继续拼失败则回溯；拼新长棍选最大未用木棍等。
    - **状态记录**：用数组标记木棍使用情况，搜索过程记录已拼长度、已拼木棍数等状态。
3. **解决难点**：难点在于各种剪枝策略的设计与实现，减少搜索空间和时间复杂度，避免超时。

### 题解评分
 - **作者Kaori**：5星。思路清晰详细，全面阐述搜索思路与多种剪枝策略及原理，代码注释详尽，对每个优化点有细致解释。
 - **作者NoyException**：4星。详细介绍暴搜思路与多种剪枝方法，名词说明清晰，代码有注释，能帮助理解。
 - **作者DLYJ**：4星。阐述搜索过程与剪枝方法，代码有注释，对剪枝解释较清楚。

### 所选题解
 - **作者Kaori**
    - **星级**：5星
    - **关键亮点**：全面且深入地讲解思路与优化，包括对输入数据处理、搜索范围确定、dfs函数设计及七种优化策略，对每个优化点解释细致，代码注释完整。
    - **个人心得**：无
    - **重点代码**：核心是dfs函数，通过参数记录当前拼的长棍编号、上一根短棍编号、当前长棍剩余未拼长度，在函数内实现各种剪枝策略，如二分查找合适短棍、跳过相同长度短棍等。
```cpp
void dfs(int k,int last,int rest){ 
    int i;
    if(!rest){ 
        if(k==m){ok=1; return;} 
        for(i=1;i<=cnt;i++) 
            if(!used[i]) break;
        used[i]=1; 
        dfs(k+1,i,len-a[i]);
        used[i]=0;
        if(ok) return; 
    }
    int l=last+1, r=cnt, mid;
    while(l<r){
        mid=(l+r)>>1;
        if(a[mid]<=rest) r=mid;
        else l=mid+1;
    }
    for(i=l;i<=cnt;i++){
        if(!used[i]){ 
            used[i]=1;
            dfs(k,i,rest-a[i]);
            used[i]=0;
            if(ok) return; 
            if(rest==a[i] || rest==len) return; 
            i=next[i]; 
            if(i==cnt) return;
        }
    }
}
```
 - **作者NoyException**
    - **星级**：4星
    - **关键亮点**：从暴搜思路出发，详细介绍基础、普通、进阶三类剪枝方法，名词说明清晰，代码有注释，便于理解。
    - **个人心得**：无
    - **重点代码**：perm函数实现搜索，通过参数记录已拼长度和搜索起始位置，在函数内实现剪枝，如跳过相同长度木棍、判断剩余长度能否拼成等。
```cpp
bool perm(int pre,int fromp)
{
    int i;
    if(pre%len==0)
    {
        if(sum-pre==len) return true;
        for(i=2;i<=end && vis[i];i++) ;
        vis[i]=true;
        if(perm(pre+line[i],2)) return true;
        vis[i]=false;
    }
    else for(;fromp<=end;fromp++)
    {
       	if(!vis[fromp])
       	{
       		if(pre%len+line[fromp]<=len)
       		{
       			vis[fromp]=true;
   				if(perm(pre+line[fromp],fromp)) return true;
				vis[fromp]=false;
				if(pre%len+line[fromp]==len) return false;
			}
			fromp=nxt[line[fromp]];
		}
	}
    return false;
}
```
 - **作者DLYJ**
    - **星级**：4星
    - **关键亮点**：讲解搜索过程与重要剪枝方法，代码有注释，对剪枝解释清晰，如优化顺序、整除判断、搜索范围等。
    - **个人心得**：无
    - **重点代码**：dfs函数实现搜索，通过参数记录剩余长度、根数、组数，在函数内实现剪枝，如跳过相同长度木棍、判断剩余长度能否拼成等。
```cpp
bool dfs(int len,int sta,int now) 
{
    if(now==res) return 1; 
    if(len==0) if(dfs(ans,1,now+1)) return 1; 
    for(int i=sta;i<=cnt;++i)
    {
        if(!vis[i]&&a[i]<=len) 
        {
            vis[i]=1;
            if(dfs(len-a[i],i+1,now)) return 1;
            vis[i]=0;
            if(len==ans||len==a[i]) break; 
            while(a[i]==a[i+1]) ++i; 
        }
    }
    return 0;
}
```

### 最优关键思路与技巧
 - **排序优化搜索顺序**：对小木棍按长度从大到小排序，优先使用长木棍，使短木棍更灵活，减少搜索分支。
 - **剪枝策略**：
    - **整除剪枝**：原始木棍长度必须是所有小木棍长度总和的因数，减少无效枚举。
    - **避免重复搜索**：记录已尝试的相同长度木棍，避免重复尝试。
    - **特殊情况剪枝**：当前长棍剩余未拼长度等于当前木棍长度或原始长度，继续拼失败则回溯，因为这些情况在最优解中应能成功拼接。

### 可拓展思路
同类型题常涉及搜索与剪枝优化，如经典的八皇后问题、迷宫问题等。类似算法套路是先确定搜索框架，再通过分析问题特性设计剪枝策略，减少搜索空间。

### 相似知识点题目
 - [P1731 单词覆盖还原](https://www.luogu.com.cn/problem/P1731)：字符串搜索与剪枝。
 - [P2324 骑士精神](https://www.luogu.com.cn/problem/P2324)：棋盘搜索与优化。
 - [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)：搜索与状态压缩优化。

### 个人心得摘录与总结
 - **作者NoyException**：花半天完成题目，通过不断尝试剪枝解决问题，体现搜索剪枝题需耐心尝试不同优化策略。
 - **作者SNiFe**：做题花5小时，因数组大小问题多次出错，强调做题要注意边界条件与细节。 

---
处理用时：129.26秒
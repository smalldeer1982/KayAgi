# 题目信息

# 词链

## 题目描述

如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。

另外还有一些例子：
- `dog.gopher`
- `gopher.rat`
- `rat.tiger`
- `aloha.aloha`
- `arachnid.dog`

连接成的词可以与其他单词相连，组成更长的词链，例如：

`aloha.arachnid.dog.gopher.rat.tiger`

注意到，`.` 两边的字母一定是相同的。

现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。

## 说明/提示

- 对于 $40\%$ 的数据，有 $n \leq 10$；
- 对于 $100\%$ 的数据，有 $n \leq 1000$。


## 样例 #1

### 输入

```
6
aloha
arachnid
dog
gopher
rat
tiger```

### 输出

```
aloha.arachnid.dog.gopher.rat.tiger```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解将单词视为边，字母视为顶点，通过判断是否存在欧拉路（包括欧拉通路和欧拉回路）来解决问题。部分题解也尝试直接搜索，但暴力搜索效率较低，需优化起始点选择。
    - 算法要点：建图时，以单词首末字母为顶点连边，并统计各顶点的入度和出度。利用并查集判断图的连通性，根据欧拉路存在条件确定是否有解，并找出起始点。最后通过深度优先搜索（DFS）寻找字典序最小的词链。
    - 解决难点：关键在于确定起始点和判断欧拉路是否存在。不同题解通过分析首末字母出现次数、入度出度关系等方式解决。同时，为满足字典序最小要求，需对单词排序后建图和搜索。
    - 评分情况：综合思路清晰度、代码可读性、优化程度等，loc_equinox、zzr8178541919、fls233666的题解相对质量较高。

所选的题解：
  - 作者：loc_equinox (5星)
    - 关键亮点：思路清晰，详细阐述从普通DFS到利用欧拉路求解的转变原因。代码结构完整，分模块实现读入建图、寻找欧拉路起始点和DFS求欧拉路，每个模块功能明确。
    - 个人心得：提到当时因数据问题，过审题解多可被Hack，强调本题解的正确性与实用性。
    - 重点代码 - 核心实现思想：通过并查集判断图的连通性，在建边时统计顶点入度出度，根据欧拉路条件判断是否有解并确定起始点，最后DFS寻找欧拉路并记录答案。
```cpp
//读入，建图部分
int n,i,letter[27],in[27],out[27],fa[27],set_count;
string s[1002];
int ch_start,ch_end,stf,edf;
vector<vector<node> >E;
bool cmp(string a,string b)
{
    return a<b;
}
int find(int x)
{
    if(fa[x]!=x)return fa[x]=find(fa[x]);
    return fa[x];
}
void unionn(int x,int y)
{
    fa[y]=x;
    return;
}
struct node
{
    int to,ord;
    string word;
};
int main()
{
    cin>>n;
    E.resize(27);
    for(i=1;i<=n;i++)cin>>s[i];
    sort(s+1,s+n+1,cmp);
    for(i=1;i<=n;i++)
    {
        ch_start=s[i][0]-'a'+1;
        ch_end=s[i][s[i].length()-1]-'a'+1;
        out[ch_start]++;
        in[ch_end]++;
        if(!letter[ch_start])
        {
            set_count++;
            letter[ch_start]=1;
            fa[ch_start]=ch_start;
        }
        if(!letter[ch_end])
        {
            set_count++;
            letter[ch_end]=1;
            fa[ch_end]=ch_end;
        }
        if(ch_start!=ch_end)
        {
            stf=find(ch_start);
            edf=find(ch_end);
            if(stf!=edf)
            {
                set_count--;
                unionn(stf,edf);
            }
        }
        node tmp;
        tmp.to=ch_end;
        tmp.ord=i;
        tmp.word=s[i];
        E[ch_start].push_back(tmp);
    }
    if(set_count!=1)
    {
        cout<<"***";
        return 0;
    }
    //寻找欧拉路起始点部分
    int Eular_start,Eular_end;
    for(i=1;i<=26;i++)
    {
        if(!letter[i])continue;
        if(out[i]==in[i]+1)
        {
            if(Eular_start)
            {
                cout<<"***";
                return 0;
            }
            Eular_start=i;
        }
        else if(in[i]==out[i]+1)
        {
            if(Eular_end)
            {
                cout<<"***";
                return 0;
            }
            Eular_end=i;
        }
        else if(in[i]==out[i])continue;
        else
        {
            cout<<"***";
            return 0;
        }
    }
    if((Eular_start&&!Eular_end)||(!Eular_start&&Eular_end))
    {
        cout<<"***";
        return 0;
    }
    if(!Eular_start)Eular_start=s[1][0]-'a'+1;
    //DFS求欧拉路部分
    int vis[1002];
    string res[1002];
    void dfs(int st,int now,int pre_edge)
    {
        if(st==n)
        {
            for(i=1;i<=n;i++)
            {
                cout<<res[i];
                if(i<n)cout<<".";
            }
            exit(0);
        }
        for(int k=0;k<E[now].size();k++)
        {
            if(!vis[E[now][k].ord])
            {
                vis[E[now][k].ord]=1;
                res[st+1]=E[now][k].word;
                dfs(st+1,E[now][k].to,E[now][k].ord);
            }
        }
        vis[pre_edge]=0;
        return;
    }
    dfs(0,Eular_start,0);
}
```
  - 作者：zzr8178541919 (4星)
    - 关键亮点：从字符串相连的性质出发，详细分析出不同情况下词链起点的确定方法，对搜索过程中的注意事项阐述清晰。
    - 个人心得：提到更新题解是为修正之前明显错误，体现对知识的严谨态度。
    - 重点代码 - 核心实现思想：先统计每个字母在单词首位和末尾出现的次数，根据出现次数关系确定起点。从起点开始DFS搜索词链，搜索过程中标记已使用单词，找到答案后及时返回。
```cpp
#include<cmath>
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<map>
using namespace std;
const int maxn=1e5+5;
string a[maxn];
string ans[maxn];
string now[maxn];
int sum=0;
int len[maxn];
int book[maxn];
map<char,int> s1,s2;
int n;
int flag=0;
void dfs(int last,int step)
{
	if(flag==1)
	return;
	if(step==n)
	{
		flag=1;
		for(int i=1;i<=sum;i++)
		{
			ans[i]=now[i];
		}
		return;
	}
	for(int i=1;i<=n;i++)
	{
		if(book[i]==1)
		continue;
		if(a[last][a[last].length()-1]==a[i][0])
		{
			now[++sum]=a[i];
			book[i]=1;
			dfs(i,step+1);
			sum--;
			book[i]=0;
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		len[i]=a[i].length();
		s1[a[i][0]]++;
		s2[a[i][len[i]-1]]++;
	}	
	int start=1;
	sort(a+1,a+1+n);
	char s,t;
	for(char c='a';c<='z';c++)
	{
		if(abs(s1[c]-s2[c])==1)
		{
			if(s1[c]-s2[c]==1)
			s=c;
			else
			if(s2[c]-s1[c]==1)
			t=c;
		}
	}
	int cnt=s2[t];
	for(int i=1;i<=n;i++)
	{
		if(a[i][0]==s && (a[i][len[i]-1]!=t || cnt!=1))
		{
			start=i;
			break;
		}
	}
	book[start]=1;
	now[++sum]=a[start];
	dfs(start,1);
	if(flag==0)
	{
		printf("***\n");
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		if(i!=n)
		cout<<ans[i]<<".";
		else
		cout<<ans[i];
	}
	printf("\n");
	return 0;
}
```
  - 作者：fls233666 (4星)
    - 关键亮点：清晰阐述从暴力搜索到利用欧拉路径求解的思路转变，详细说明数学建模过程，对无解情况判断和字典序最小处理方法讲解细致。
    - 个人心得：无
    - 重点代码 - 核心实现思想：将单词首字母向尾字母连边构建有向图，计算各点度判断是否存在欧拉路径及确定起点。排序单词后倒序连边保证字典序最小，DFS搜索路径并记录答案，最后判断是否所有边都被搜索过以确定是否有解。
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
#define ll long long
#define rgt register int
using namespace std;
const int mxn = 1010;
string str[mxn],outans[mxn];
int tot,lst[30],nxt[mxn],to[mxn],bh[mxn],d[mxn],lans;
bool use[mxn];

inline void add(int x,int y,int b){
	tot++;
	to[tot]=y;
	bh[tot]=b;
	d[x]++;
	d[y]--;
	nxt[tot]=lst[x];
	lst[x]=tot;
}

void dfs(int g){
	for(rgt i=lst[g];i;i=nxt[i]){
		if(!use[bh[i]]){
			use[bh[i]]=true;
			dfs(to[i]);
			lans++;
			outans[lans]=str[bh[i]];
		}
	}
}

int main(){
	ios::sync_with_stdio(false);
	int n,st;
	cin>>n;
	for(rgt i=1;i<=n;i++)
		cin>>str[i];

	sort(str+1,str+1+n);
	st=str[1][0]-'a'+1;

	for(rgt hd,tl,i=n;i>=1;i--){
		hd=str[i][0]-'a'+1;
		tl=str[i][str[i].size()-1]-'a'+1;
		add(hd,tl,i);
	}

	for(rgt i=1;i<=26;i++)
		if(d[i]==1){
			st=i;
			break;
		}

	dfs(st);

	for(rgt i=1;i<=n;i++)
		if(!use[i]){
			cout<<"***";
			return 0; 
		}

	for(rgt i=lans;i>1;i--)
		cout<<outans[i]<<".";
	cout<<outans[1];

	return 0;
}
```

最优的关键思路或技巧：
    - **数学建模**：将单词建模为有向图的边，字母作为顶点，把寻找词链问题转化为求欧拉路问题，利用图论知识解决。
    - **排序优化**：对输入单词排序，无论是建图还是搜索过程，都有助于得到字典序最小的结果。
    - **利用度数判断**：通过统计顶点的入度和出度，结合欧拉路存在条件，准确判断是否有解以及确定起始点，避免无效搜索。

可拓展之处：
此类题属于图论中与欧拉路相关的字符串拼接问题。类似算法套路是先将实际问题抽象为图论模型，通过分析图的连通性、顶点度数等性质来解决。例如，给定一些有向线段，要求一笔画完所有线段且每个线段仅画一次，可类似建图并利用欧拉路知识求解。

推荐题目：
    - P2731 [USACO3.3]骑马修栅栏 Riding the Fences ：经典的无向图欧拉路问题，通过寻找一条经过所有边且仅一次的路径，锻炼对欧拉路条件的应用和代码实现能力。
    - P1341 无序字母对 ：需要构建无向图，判断是否存在欧拉回路，并输出路径，与本题类似，强化对图的构建和欧拉回路判断的掌握。
    - P7771 [CSP-J2021] 分糖果 ：结合图论与贪心思想，虽然不是直接的欧拉路问题，但在分析问题和建立模型方面有相似之处，可拓展思维。 

---
处理用时：177.88秒
# 题目信息

# [ZJOI2007] 时态同步

## 题目描述

小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。

在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。

激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？

## 说明/提示

- 对于 $40\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 5\times 10^5$。

对于所有的数据，$1\le t_e\le 10^6$。

## 样例 #1

### 输入

```
3
1
1 2 1
1 3 3
```

### 输出

```
2
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕树形结构展开，核心思路是通过调整边权使叶子节点到根节点的距离相等，以实现时态同步。算法要点多采用深度优先搜索（DFS）结合贪心或动态规划思想。难点在于如何确定最优的边权调整策略，保证在满足时态同步的前提下操作次数最少。多数题解思路相近，差异主要体现在状态定义、转移方程及实现细节上。

所选的题解：
  - 作者：Mathison (赞：187)  星级：5星
    - 关键亮点：思路清晰，通过类比节点深度与距离，直观地阐述了贪心策略——调整越靠根节点的树枝代价越少。代码简洁明了，直接基于DFS实现，易于理解。
    - 重点代码核心实现思想：先通过DFS找到每个节点与叶子节点的最大距离`dis[x]`，然后再次遍历子节点，计算调整当前节点到子节点边权的代价并累加。
```cpp
void dfs(int x,int fa)
{
    for(int i=head[x];i;i=next[i])
    {
        int y=ver[i],z=edge[i];
        if(y==fa) continue;
        dfs(y,x);
        dis[x]=max(dis[x],dis[y]+z);
    }
    for(int i=head[x];i;i=next[i])
    {
        int y=ver[i],z=edge[i];
        if(y==fa) continue;
        ans+=dis[x]-(dis[y]+z);
    }
}
```
  - 作者：crazydave (赞：127)  星级：4星
    - 关键亮点：反向思考，将问题转化为叶子节点信号同时到达根节点，自下而上维护。代码注释详细，对维护过程的各个步骤解释清晰。
    - 重点代码核心实现思想：DFS搜索到叶子节点后回溯，依次维护节点到子节点的最大边权`maxn[x]`、答案`ans`以及父节点到该节点的边权。
```cpp
void dfs(int x, int fa) 
{
    for(int i=head[x]; i; i=edge[i].next)
        if(edge[i].to!=fa) dfs(edge[i].to, x);
    for(int i=head[x]; i; i=edge[i].next)
        if(edge[i].to!=fa) maxn[x]=max(maxn[x], edge[i].dis);
    for(int i=head[x]; i; i=edge[i].next)
        if(edge[i].to!=fa) ans+=(maxn[x]-edge[i].dis);
    for(int i=head[fa]; i; i=edge[i].next)
        if(edge[i].to==x) edge[i].dis+=maxn[x];
}
```
  - 作者：Social_Zhao (赞：19)  星级：4星
    - 关键亮点：采用一维树形DP，定义明确的状态变量`f[i]`和`maxn[i]`，并给出简洁的动规方程。代码通过变量化简优化计算过程，同时注意到一些实现细节如开`long long`、建双向边等。
    - 重点代码核心实现思想：DFS过程中，先递归处理儿子节点，更新`maxn[u]`和`sum`，最后根据动规方程`f[u] += maxn[u] * cnt - sum`计算`f[u]`。
```cpp
void dfs(int u, int fa) 
{
    f[u] = 0; 
    maxn[u] = 0;
    int sum = 0, cnt = 0;
    for(int i = head[u]; i; i = edge[i].nxt) {
        int v = edge[i].v;
        if(v == fa) continue;
        dfs(v, u); 
        cnt++;
        int w = edge[i].w; 
        f[u] += f[v]; 
        maxn[u] = max(maxn[v] + w, maxn[u]); 
        sum += maxn[v] + w; 
    }
    f[u] += maxn[u] * cnt - sum; 
}
```

最优的关键思路或技巧：利用树形结构的特性，采用贪心思想，优先调整靠近根节点的边权。通过DFS遍历树，在回溯过程中处理节点状态，同时注意无向图需双向加边，答案用`long long`存储以防止溢出。

可拓展之处：此类题目属于树形结构上的优化问题，类似套路可用于解决如树上路径最值、树上资源分配等问题。

推荐题目：
  - [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)
  - [P3398 仓鼠找sugar](https://www.luogu.com.cn/problem/P3398)
  - [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)

个人心得：无。 

---
处理用时：72.60秒
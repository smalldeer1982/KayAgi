# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕无向无权图中从顶点1到其他各点的最短路计数问题，采用了BFS、SPFA、Dijkstra等算法。思路上，大多通过在求最短路过程中，根据距离更新情况来统计最短路的条数。算法要点在于初始化起点的最短路条数为1，在更新最短路距离时相应更新计数，遇到相同最短路径则累加计数。解决难点在于处理重边（部分题解认为对本题无影响）以及避免重复计数（如部分SPFA解法考虑边权不同时的重复计数问题）。

### 所选的题解
- **作者：ZiDing_ByronFinlso（5星）**
    - **关键亮点**：思路清晰，同时给出了SPFA和Dijkstra堆优化两种解法，并配有图片辅助理解。代码规范，有详细的读入优化，对更新最短路和计数操作的处理简洁明了。
    - **个人心得**：无
    - **SPFA核心代码**：
```cpp
while(q.size())
{
    x=q.front();q.pop();
    p[x]=0;
    for(int i=head[x];i;i=nxt[i])
    {
        y=to[i];
        if(d[y]>d[x]+1)
        {
            d[y]=d[x]+1;
            ans[y]=ans[x];
            if(!p[y])
            {
                q.push(y);
                p[y]=1;
            }
        }
        else if(d[y]==d[x]+1)
        {
            ans[y]+=ans[x];
            ans[y]%=mod;
        }
    }
}
```
    - **核心思想**：从队列中取出顶点x，遍历其邻接顶点y，若y的距离大于x的距离加1，则更新y的距离和最短路计数，并将y入队；若y的距离等于x的距离加1，则累加y的最短路计数。
    - **Dijkstra堆优化核心代码**：
```cpp
while(q.size())
{
    x=q.top().second;
    q.pop();
    if(p[x])    continue;
    p[x]=1;
    for(int i=head[x];i;i=nxt[i])
    {
        y=to[i];
        if(d[y]>d[x]+1)
        {
            d[y]=d[x]+1;
            ans[y]=ans[x];
            q.push(make_pair(-d[y],y));
        }
        else if(d[y]==d[x]+1)
        {
            ans[y]+=ans[x];
            ans[y]%=mod;
        }
    }
}
```
    - **核心思想**：从优先队列中取出距离最小的顶点x，若x已访问过则跳过。遍历x的邻接顶点y，若y的距离大于x的距离加1，则更新y的距离和最短路计数，并将y加入优先队列；若y的距离等于x的距离加1，则累加y的最短路计数。
- **作者：岸芷汀兰（4星）**
    - **关键亮点**：明确指出本题符合BFS特点，详细分析了自环和重边对题目的影响。代码实现中使用了vector存储图结构，代码逻辑清晰，注释详细。
    - **个人心得**：无
    - **BFS核心代码**：
```cpp
queue<Node>q; q.push(make(1, 0));
memset(d, 0x3f, sizeof(d)); d[1] = 0;
vis[1] = true;
ans[1] = 1;
while (q.size()) {
    int u = q.front().node, dis = q.front().dis; 
    q.pop();
    for (register int i = 0; i<int(linker[u].size()); i++) {
        if (!vis[cur]) {
            q.push(make(cur, dis + 1)); vis[cur] = true; d[cur] = dis + 1; 
            ans[cur] += ans[u]; /*重点*/ans[cur] %= mod;
        }
        else {
            if (dis + 1 == d[cur]) { ans[cur] += ans[u]; /*重点*/ans[cur] %= mod; }
        }
    }
}
```
    - **核心思想**：初始化队列并将起点入队，设置起点距离和计数。每次从队列取出顶点u，遍历其邻接顶点cur，若cur未访问过，则更新其距离、计数并将其入队；若cur已访问且距离等于u的距离加1，则累加其计数。
- **作者：King丨帝御威（4星）**
    - **关键亮点**：强调了Dijkstra算法相对于SPFA的优势（复杂度低且不易被卡），代码结构清晰，有详细的注释说明，对Dijkstra算法结合最短路计数的实现讲解详细。
    - **个人心得**：无
    - **Dijkstra核心代码**：
```cpp
void dijkstra()
{
    memset(dis,0x3f,sizeof(dis));                //初始化。 
    dis[1]=0;
    priority_queue<node>q;
    js[1]=1;                            //起点到自己的最短路条数一定是1。 
    q.push((node){1,0});
    node a;
    while(!q.empty())                             //dijkstra经典套路操作。 
    {
        a=q.top();                              //用这个node类型变量提取队首元素。 
        int u=a.x,d=a.y;                       
        q.pop();
        if(d!=dis[u]) continue;                   //一个小优化。 
        for(int i=head[u];i;i=edge[i].nxt)
        {
            int v=edge[i].v;
            if(d+edge[i].w==dis[v])
              js[v]=(js[u]+js[v])%mod;             //一边计算一边模。 
            if((dis[v]>dis[u]+edge[i].w))
            {
                dis[v]=dis[u]+edge[i].w;
                js[v]=js[u];                      //找到一条更短的路径是，用它的前驱的js换它。 
                q.push((node){v,dis[v]});
            }
        }
    }
}
```
    - **核心思想**：初始化距离数组和优先队列，将起点入队并设置起点距离和计数。每次从优先队列取出顶点u，若取出的距离与u的当前距离不一致则跳过。遍历u的邻接顶点v，若v的距离等于u的距离加边权，则累加v的计数；若v的距离大于u的距离加边权，则更新v的距离和计数，并将v加入优先队列。

### 最优关键思路或技巧
1. **数据结构**：使用邻接表（链式前向星）存储图结构，节省空间且便于遍历。
2. **算法优化**：在Dijkstra算法中使用堆优化，降低时间复杂度；在输入时采用快读优化，提高数据读取效率。
3. **思维方式**：在求最短路的同时，通过记录前驱节点的最短路计数来更新当前节点的最短路计数，巧妙解决计数问题。

### 可拓展之处
同类型题或类似算法套路：对于有向或无向图，边权相同或不同的最短路计数问题，都可考虑在经典最短路算法（如Dijkstra、SPFA、BFS）基础上，结合计数更新操作来解决。例如，当边权不同时，需更细致地处理重复计数问题（如部分题解中提到的改进SPFA计数方式）。

### 推荐题目
1. **P1339 热浪**：通过Dijkstra算法求最短路，可加深对最短路算法的理解与应用。
2. **P3371 【模板】单源最短路径（弱化版）**：模板题，用于巩固Dijkstra和SPFA等最短路算法。
3. **P1608 路径统计**：与本题类似，求从起点到终点的最短路的方案数，可进一步练习最短路计数问题。

### 个人心得摘录与总结
无。 

---
处理用时：114.02秒
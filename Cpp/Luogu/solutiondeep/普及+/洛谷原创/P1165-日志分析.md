# 题目信息

# 日志分析

## 题目描述

M 海运公司最近要对旗下仓库的货物进出情况进行统计。目前他们所拥有的唯一记录就是一个记录集装箱进出情况的日志。该日志记录了两类操作：第一类操作为集装箱入库操作，以及该次入库的集装箱重量；第二类操作为集装箱的出库操作。这些记录都严格按时间顺序排列。集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为当前在仓库里所有集装箱中最晚入库的集装箱。

出于分析目的，分析人员在日志中随机插入了若干第三类操作――查询操作。分析日志时，每遇到一次查询操作，都要报告出当前仓库中最大集装箱的重量。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，有 $N \le 10$；
- 对于 $40\%$ 的数据，有 $N \le 1000$；
- 对于 $100\%$ 的数据，有 $1 \le N \le 200000$，$1 \le X \le 10^8$。


## 样例 #1

### 输入

```
13
0 1
0 2
2
0 4
0 2
2
1
2
1
1
2
1
2
```

### 输出

```
2
4
4
1
0
```

# AI分析结果

• 综合分析与结论：这些题解都围绕栈结构来解决日志分析问题，难点在于如何高效获取栈内最大值。多数题解通过维护辅助数据结构或在栈操作时同步更新最大值来解决。思路和实现方法各有不同，质量也有所差异。
  - **medusa题解**：★★★★
    - **关键亮点**：思路清晰，通过数组f[i]记录栈中从下到上i个元素中的最大值，入栈时更新，出栈和查询时直接输出对应值，代码简洁明了。
    - **重点代码**：
```cpp
int f[200001],n,x,y,t=0;   
int main()   
{   
    cin>>n;   
    f[0]=0;   
    for (int i=1; i<=n; i++)   
    {   
        cin>>x;   
        if (x==0)    
        {   
            cin>>y;   
            t++;   
            f[t]=max(f[t-1],y);   
        }   
        if (x==1) if (t!=0) t--;   
        if (x==2) cout<<f[t]<<endl;   
    }   
    return 0;   
}  
```
    - **核心思想**：利用数组f记录栈内不同位置的最大值，入栈时根据前一个最大值更新当前最大值，出栈时不改变数组结构，查询时直接输出对应位置的最大值。
  - **buickboy题解**：★★★★
    - **关键亮点**：引入辅助栈记录栈当前的最大值，主栈和辅助栈同步操作，逻辑清晰，易于理解。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
stack<int>a;
stack<int>b;
int n,m,x;
int main()
{
    scanf("%d",&n);
    while(n--)
    {
        scanf("%d",&m);
        if(m==0)
        {
            scanf("%d",&x);
            a.push(x);
            if(b.empty()||x>b.top())
                b.push(x);
            else b.push(b.top());
        }
        else if(m==1)
        {
            a.pop();
            b.pop();
        }
        else
        {
            if(b.empty()) printf("0\n");
            else printf("%d\n",b.top());
        }
    }
    return 0;
}
```
    - **核心思想**：主栈正常存储数据，辅助栈在每次入栈时判断新元素与辅助栈栈顶元素大小，决定是否更新辅助栈栈顶，出栈时两栈同步操作，查询时直接输出辅助栈栈顶元素。
  - **felixwu题解**：★★★★
    - **关键亮点**：代码简洁，用数组q模拟栈，数组a维护包括栈顶元素的最大值，操作简单直接。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int q[1000001],top,a[1000001],m,n,k;
void push(int x){q[++top]=x;}
void pop(){top--;}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&m);
        if(m==0) {
            scanf("%d",&k);
            push(k);
            a[top]=max(a[top-1],k);
        }
        if(m==1) pop(); 
        if(m==2) printf("%d\n",a[top]);
    }
    return 0;
}
```
    - **核心思想**：数组q模拟栈的入栈和出栈操作，数组a在每次入栈时更新当前栈顶的最大值，出栈时不改变a数组结构，查询时输出a数组对应栈顶位置的最大值。

• 最优关键思路或技巧：维护一个与主栈同步操作的辅助数据结构（辅助栈或数组），在入栈时更新辅助结构记录当前栈内最大值，出栈时同步更新，这样查询最大值时可在O(1)时间复杂度内完成。

• 可拓展之处：同类型题常围绕栈、队列等数据结构，结合特定操作需求考察。类似算法套路是在基本数据结构操作基础上，通过维护额外数据结构或信息来满足特殊查询或操作要求。

• 推荐题目：
  - **P1449**：高精度加法，涉及栈在高精度运算中的应用。
  - **P1308**：统计单词数，可利用栈处理字符串匹配问题。
  - **P1739**：表达式括号匹配，考察栈对表达式括号匹配的处理。

• 个人心得摘录与总结：
  - **Garrison**：在洛谷编译器中++tot;a[tot]=a[tot-1];和a[++tot]=a[tot-1]不是等价的，部分评测系统计算顺序不同，编写代码时需注意运算符顺序。 

---
处理用时：66.36秒
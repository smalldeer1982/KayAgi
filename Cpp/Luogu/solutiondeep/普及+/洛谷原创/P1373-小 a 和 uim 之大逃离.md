# 题目信息

# 小 a 和 uim 之大逃离

## 题目背景

小 a 和 uim 来到雨林中探险。突然一阵北风吹来，一片乌云从北部天边急涌过来，还伴着一道道闪电，一阵阵雷声。刹那间，狂风大作，乌云布满了天空，紧接着豆大的雨点从天空中打落下来，只见前方出现了一个披头散发、青面獠牙的怪物，低沉着声音说：“呵呵，既然你们来到这，只能活下来一个！”。小 a 和他的小伙伴都惊呆了！


## 题目描述

瞬间，地面上出现了一个 $n\times m$ 的巨幅矩阵，矩阵的每个格子上有一坨 $0\sim k$ 不等量的魔液。

怪物各给了小 a 和 uim 一个魔瓶，说道，你们可以从矩阵的任一个格子开始，每次向右或向下走一步，从任一个格子结束。开始时小 a 用魔瓶吸收地面上的魔液，下一步由 uim 吸收，如此交替下去，并且要求最后一步必须由 uim 吸收。魔瓶只有 $k$ 的容量，也就是说，如果装了 $k+1$ 那么魔瓶会被清空成零，如果装了 $k+2$ 就只剩下 $1$，依次类推。

怪物还说道，最后谁的魔瓶装的魔液多，谁就能活下来。小 a 和 uim 感情深厚，情同手足，怎能忍心让小伙伴离自己而去呢？沉默片刻，小 a 灵机一动，如果他俩的魔瓶中魔液一样多，不就都能活下来了吗？小 a 和他的小伙伴都笑呆了！

现在他想知道他们都能活下来有多少种方法。

## 说明/提示

【题目来源】

lzn 改编

【样例解释】

样例解释：四种方案是：$(1,1)\to (1,2)$，$(1,1)\to (2,1)$，$(1,2)\to (2,2)$，$(2,1)\to (2,2)$。

【数据范围】

对于 $20\%$ 的数据，$n,m\leq 10$，$k\leq2$；

对于 $50\%$ 的数据，$n,m\leq 100$，$k\leq5$；

对于 $100\%$ 的数据，$1 \leq n,m\leq 800$，$1\leq k\leq 15$。


## 样例 #1

### 输入

```
2 2 3
1 1
1 1
```

### 输出

```
4
```

# AI分析结果

• 综合分析与结论：这些题解均采用动态规划（DP）方法解决问题。思路核心是通过状态转移方程，利用之前计算的状态来推导新状态，从而得到最终答案。算法要点在于合理定义状态，几乎所有题解都定义了一个四维数组 `dp[i][j][k][0/1]`，其中 `i` 和 `j` 表示矩阵坐标，`k` 表示两人魔液量的差值（模 `k + 1`），`0/1` 表示当前是小 `a` 还是 `uim` 取魔液。难点在于处理差值为负数的情况，多数题解通过将负数差值加上 `k + 1` 转化为正差值来解决。
• 所选的题解：
  - 作者：kkksc03（5星）
    - 关键亮点：思路清晰简洁，直接阐述动态规划思路，明确给出状态定义、状态转移方程及初始条件，未涉及复杂实现细节，使读者快速把握核心。
    - 重点代码及核心实现思想：
```cpp
// 状态转移方程
f[i][j][p][0]+=f[i-1][j][(p-mapp[i][j]+k)%k][1]   (i-1>=1);
f[i][j][p][0]+=f[i][j-1][(p-mapp[i][j]+k)%k][1]   (j-1>=1);
f[i][j][p][1]+=f[i-1][j][(p+mapp[i][j])%k][0]   (i-1>=1);
f[i][j][p][1]+=f[i][j-1][(p+mapp[i][j])%k][0]   (j-1>=1);
// 初始条件
for all i, j:
    f[i][j][mapp[i][j]][0]=1;
```
核心实现思想是依据状态转移方程更新状态数组，通过初始条件确定起始状态，最终累加符合条件的状态得到答案。
  - 作者：SkyRainWind（4星）
    - 关键亮点：不仅给出思路和代码，还指出题目卡内存和数据类型选择的坑点，对读者有实际指导意义。
    - 个人心得：“卡内存！例如，我的dp数组开的是 `dp[805][805][25][2]`，4个点MLE，换成 `dp[805][805][20][2]` 就过了。还有就是这道题不用开long long，最后记录答案开个long long就行了（我全没开long long还过了），否则数组开个long long，内存直接变两倍，呵呵。。。”总结了调试中遇到内存超限（MLE）问题及数据类型选择对内存的影响。
    - 重点代码及核心实现思想：
```cpp
// 状态转移
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        for(int h=0;h<=k;h++){
            dp[i][j][h][0]=(dp[i][j][h][0]+dp[i-1][j][(h-a[i][j]+k)%k][1])%mod;
            dp[i][j][h][0]=(dp[i][j][h][0]+dp[i][j-1][(h-a[i][j]+k)%k][1])%mod;
            dp[i][j][h][1]=(dp[i][j][h][1]+dp[i-1][j][(h+a[i][j])%k][0])%mod;
            dp[i][j][h][1]=(dp[i][j][h][1]+dp[i][j-1][(h+a[i][j])%k][0])%mod;
        }
    }
}
// 初始条件
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
        scanf("%d",&a[i][j]);
        dp[i][j][a[i][j]%k][0]=1; 
    } 
```
核心实现思想与其他题解类似，通过循环遍历更新状态数组，依据初始条件和状态转移方程求解。
  - 作者：桑梓暖阳（4星）
    - 关键亮点：详细阐述从直接思路到优化思路的过程，对状态降维的原因和过程解释清晰，帮助读者理解优化思路。
    - 重点代码及核心实现思想：
```cpp
// 状态转移
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        for(int h=0;h<K;h++){
            if(i+1<=n){
                f[i+1][j][(h+a[i+1][j])%K][0]=(f[i+1][j][(h+a[i+1][j])%K][0]+f[i][j][h][1])%mod;
                f[i+1][j][(h-a[i+1][j]+K)%K][1]=(f[i+1][j][(h-a[i+1][j]+K)%K][1]+f[i][j][h][0])%mod;
            }
            if(j+1<=m){
                f[i][j+1][(h+a[i][j+1])%K][0]=(f[i][j+1][(h+a[i][j+1])%K][0]+f[i][j][h][1])%mod;
                f[i][j+1][(h-a[i][j+1]+K)%K][1]=(f[i][j+1][(h-a[i][j+1]+K)%K][1]+f[i][j][h][0])%mod;
            }
            if(h==0)ans=(ans+f[i][j][h][1])%mod;
        }
// 初始条件
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
        scanf("%d",&a[i][j]);
        f[i][j][a[i][j]%K][0]=1;
    }
```
核心实现思想同样是利用状态转移方程和初始条件，通过循环更新状态数组并统计答案。
• 最优关键思路或技巧：
    - **状态定义优化**：不记录两人具体魔液量，而是记录魔液量差值，有效降低状态维度，减少空间和时间复杂度。
    - **处理负数差值**：利用魔瓶容量循环特性，将负数差值加上 `k + 1` 转化为正差值，便于状态转移计算。
• 可拓展思路：此类题目属于动态规划在路径问题上的应用，可拓展到其他类似路径行走且需要记录状态的题目。类似算法套路是根据题目条件合理定义状态，确定状态转移方程，注意边界条件和特殊情况处理。
• 推荐题目：
    - [P1282 多米诺骨牌](https://www.luogu.org/problem/show?pid=1282)：同样涉及路径行走，需考虑状态记录和转移，与本题思路相似。
    - [P1006 传纸条](https://www.luogu.org/problem/P1006)：也是路径问题，通过动态规划求解，可锻炼对状态定义和转移的能力。
    - [P1434 [SHOI2002]滑雪](https://www.luogu.org/problem/P1434)：在二维空间中通过动态规划寻找最长路径，与本题在空间处理和状态转移上有相通之处。 

---
处理用时：109.60秒
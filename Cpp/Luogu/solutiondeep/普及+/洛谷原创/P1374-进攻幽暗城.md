# 题目信息

# 进攻幽暗城

## 题目背景

由于震惊海内外的 “愤怒门投毒事件” 的发生，部落为了对抗皇家药剂师协会的叛乱，所有的外交工作完成后，部落大酋长萨尔带领着小 A 穿过传送门到达幽暗城平叛。


## 题目描述

幽暗城的地图是一个 $n \times m$ 的 $01$ 串。$a_{i, j} = 1$ 时表示 $(i, j)$ 的位置是障碍，无法通过；$a_{i, j} = 0$ 时表示 $(i, j)$ 的位置可以进入。

小 A 与萨尔的初始位置是 $(x_1, y_1)$，而恐惧魔王的初始位置是 $(x_2, y_2)$。小 A 的目标就是到达恐惧魔王的位置。

萨尔会按照一个特定的路线行走，该路线是一个数字串，由 $0 \sim 4$ 组成。

第 $i$ 秒，若数字串第（$i \bmod {}$数字串的长度）位等于 $0$，则表示这一秒萨尔将会原地不动；   
等于 $1$，则表示这一秒萨尔会向上走一格；   
等于 $2$，则表示这一秒萨尔会向下走一格；   
等于 $3$，则表示这一秒萨尔会向左走一格；   
等于 $4$，则表示这一秒萨尔会向右走一格。

若萨尔将要移动的位置是墙或者超出迷宫的范围，则萨尔会原地不动。恐惧魔王也是这样。（换句话说，你可以认为如果将数字串是重复无限次，第 $i$ 秒就是字符串第 $i$ 位）

小A每秒可以选择从上下左右四个方向中选择一个方向，朝那个方向走一格，前提是那个位置不是墙并且没有超出迷宫的范围；或者原地不动。不过，由于幽暗城的诡异环境，小 A 只能持续脱离萨尔的光环 $s$ 秒，若超过 $s$ 秒小 A 则会死亡。光环的有效半径为 $d$ ，表示当小 A 与萨尔之间的距离 $\sqrt{(x-xx)^2+(y-yy)^2}$ 小于等于 $d$ 时小 A 才能受到萨尔光环的效果。若小 A 脱离萨尔的光环又重新进入光环有效区域，则再次离开光环时持续时间归零重记。

小 A 想知道最少需要几秒他才能到达恐惧魔王所在的位置。

## 说明/提示

**【题目来源】**

kiro 原创

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n,m \le 50$，$0 \le s \le 1000$，$0 \le d \le 100$，$1 \le $ 数字串长度 $ \le 100$，$0 \le $ 答案 $ \le 100$。

## 样例 #1

### 输入

```
3 4 7 3
1010
0000
0101
1 2 3 3
0132401
12131
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何让小A在满足不能长时间脱离萨尔光环的条件下，以最短时间到达恐惧魔王位置这一问题展开。思路上，大部分题解采用搜索算法，其中广度优先搜索（BFS）较为常见，也有题解提到迭代加深搜索（IDDFS）。算法要点在于模拟萨尔、恐惧魔王的固定移动路线，同时通过搜索确定小A的移动路径，并判断小A是否在规定时间内处于萨尔光环范围内。难点主要是避免搜索陷入死循环、处理人物移动时撞墙或出界情况以及准确判断小A脱离萨尔光环的时间。

### 所选的题解
- **world_execute（5星）**
    - **关键亮点**：思路清晰，对题目分析全面，从初步确定算法到解决搜索中可能遇到的死循环、人物位置处理、离开时间判断等难点逐步展开。代码实现部分详细，对输入、预处理及搜索过程都有注释说明。
    - **个人心得**：提到输入部分有难度，机房巨佬也易写错，强调了对输入细节的重视。
    - **核心代码**：
```cpp
// 预处理萨尔与恐惧魔王位置
for (int i=1; i<=100; ++i) {
    int tx = Lorx[i - 1]+bak[st_Lor[(i - 1)%st_Lor.length()]-48];
    int ty = Lory[i - 1]+bak[st_Lor[(i - 1)%st_Lor.length()]-43];
    if ((tx<1)||(tx>n)||(ty<1)||(ty>m))
        tx = Lorx[i - 1],ty = Lory[i - 1];
    else if (Map[tx][ty] == 1)
        tx = Lorx[i - 1],ty = Lory[i - 1];
    Lorx[i] = tx,Lory[i] = ty;

    tx = Salx[i - 1]+bak[st_Sal[(i - 1)%st_Sal.length()]-48];
    ty = Saly[i - 1]+bak[st_Sal[(i - 1)%st_Sal.length()]-43];
    if ((tx<1)||(tx>n)||(ty<1)||(ty>m))
        tx = Salx[i - 1],ty = Saly[i - 1];
    else if (Map[tx][ty] == 1)
        tx = Salx[i - 1],ty = Saly[i - 1];
    Salx[i] = tx,Saly[i] = ty;
}

// 搜索函数
void Search(int Max_Deep,int now,int nx,int ny,int Leave_Time) {
    if (现在层数大于最大层数 或 离开时间大于s)
        return;
    if (到达魔王的位置) {
        printf("%d\n", now);
        exit(0);
    }
    now ++;
    for (int i=0; i<5; ++i) {
        int tx = nx+bak[i];
        int ty = ny+bak[i+5];
        int tk = Leave_Time;
        if ((tx<1)||(tx>n)||(ty<1)||(ty>m))
            continue;
        if (Map[tx][ty] == 1)
            continue;
        if (dist(tx,ty,Salx[now],Saly[now]) > r)
            tk++;
        else tk = 0;
        Search(Max_Deep,now,tx,ty,tk);
    }
}
```
核心实现思想：通过循环预处理出100次内萨尔与恐惧魔王的位置，搜索函数中以最大深度和离开时间为限制条件，枚举小A的移动方向，递归搜索满足条件的最短路径。

- **wzmzmhk（4星）**
    - **关键亮点**：采用BFS算法，代码结构清晰，详细注释了每一步操作。对人物移动模拟、小A与萨尔距离判断、小A离开光环时间记录等细节处理得当。
    - **核心代码**：
```cpp
struct coord {
    int Ax, Ay;
    int sx, sy;
    int demx, demy;
    int t;
    int t1 = 0;
};

coord Sal(coord x, int s) {
    if (s == 0)
        return x;
    else if (s == 1) {
        int ux = x.sx - 1, uy = x.sy;
        if (ux <= 0 || c[ux][uy] == '1')
            return x;
        x.sx = ux;
        return x;
    }
    // 其他方向移动类似
}

coord Dem(coord x, int m1) {
    if (m1 == 0)
        return x;
    // 与Sal函数类似实现恐惧魔王移动
}

int main() {
    cin >> n >> m >> s >> d;
    // 输入地图及相关信息
    coord l;
    l.Ax = l.sx = x, l.Ay = l.sy = y;
    l.demx = x1, l.demy = y1;
    l.t = 0;
    q.push(l);
    while (!q.empty()) {
        coord l = q.front();
        q.pop();
        l.t++;
        coord u;
        int s1 = S[(l.t - 1)%S.size()] - '0';
        int m1 = M[(l.t - 1)%M.size()] - '0';
        u = Sal(l, s1), u = Dem(l, m1);
        if (u.Ax == u.demx && u.Ay == u.demy) {
            cout << u.t;
            return 0;
        }
        for (int i = 0; i < 4; i++) {
            int ux = l.Ax + dx[i], uy = l.Ay + dy[i];
            if (ux <= 0 || uy <= 0 || ux > n || uy > m || c[ux][uy] == '1' || flag[ux][uy] == true)
                continue;
            u.Ax = ux, u.Ay = uy;
            if (dis(u) <= d) {
                flag[ux][uy] = true;
                coord uu = u;
                uu.t1 = 0;
                q.push(uu);
                if (uu.Ax == uu.demx && uu.Ay == uu.demy) {
                    cout << uu.t;
                    return 0;
                }
            }
            else if (l.t1 + 1 <= s) {
                coord uu = u;
                uu.t1 = l.t1 + 1;
                q.push(uu);
                flag[ux][uy] = true;
                if (uu.Ax == uu.demx && uu.Ay == uu.demy) {
                    cout << uu.t;
                    return 0;
                }
            }
        }
    }
    return 0;
}
```
核心实现思想：定义结构体存储小A、萨尔和恐惧魔王的位置及相关时间信息。通过BFS遍历，每次取出队首元素，更新萨尔和恐惧魔王位置，然后枚举小A的移动方向，判断是否满足条件并更新队列。

### 最优关键思路或技巧
- **预处理人物位置**：预先计算出萨尔和恐惧魔王在一定时间内的位置，避免在搜索过程中重复计算，提高效率。
- **合理使用数据结构**：如使用结构体存储人物位置、时间等信息，便于管理和操作；使用队列实现BFS，确保搜索的广度优先特性。
- **边界与特殊情况处理**：对人物移动时撞墙、出界以及小A脱离光环时间等边界和特殊情况进行细致处理，保证算法的正确性。

### 可拓展思路
此类题目属于在一定限制条件下的路径搜索问题。拓展方向可包括增加更多复杂限制条件，如不同区域有不同的移动规则；或者改变地图结构，如采用三维地图。类似算法套路是先明确各元素的运动规则，然后选择合适的搜索算法（BFS、DFS或IDDFS等），并在搜索过程中严格处理各种限制条件。

### 相似知识点洛谷题目
- **P1443 马的遍历**：同样是在地图上的搜索问题，涉及到马的固定移动规则，与本题中萨尔和恐惧魔王的固定移动有相似之处，可锻炼对搜索算法和移动规则模拟的能力。
- **P1141 01迷宫**：通过搜索求解迷宫问题，需要处理不同的条件限制，与本题在搜索结合条件判断方面类似。
- **P1332 血色先锋队**：在地图上进行搜索，且有时间相关的限制条件，与本题中小A受时间限制的情况类似。 

---
处理用时：117.15秒
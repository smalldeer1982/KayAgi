# 题目信息

# 又是毕业季II

## 题目背景

“叮铃铃铃”，随着高考最后一科结考铃声的敲响，三年青春时光顿时凝固于此刻。毕业的欣喜怎敌那离别的不舍，憧憬着未来仍毋忘逝去的歌。一千多个日夜的欢笑和泪水，全凝聚在毕业晚会上，相信，这一定是一生最难忘的时刻！


## 题目描述

彩排了一次，老师不太满意。当然啦，取每位同学的号数来找最大公约数显然不太合理。于是老师给每位同学评了一个能力值。于是现在问题变为，从 $n$ 个学生中挑出 $k$ 个人使得他们的默契程度（即能力值的最大公约数）最大。但因为节目太多了，而且每个节目需要的人数又不知道。老师想要知道所有情况下能达到的最大默契程度是多少。这下子更麻烦了，还是交给你吧~

PS：一个数的最大公约数即本身。


## 说明/提示

【题目来源】

lzn 原创

【数据范围】

记输入数据中能力值的最大值为 $\textit{inf}$。

- 对于 $20\%$ 的数据，$n \leq 5$，$\textit{inf}\leq 10^3$；
- 对于另 $30\%$ 的数据，$n \leq 100$，$\textit{inf} \leq 10$；
- 对于 $100\%$ 的数据，$n \leq 10^4$，$\textit{inf} \leq 10^6$。

## 样例 #1

### 输入

```
4
1 2 3 4
```

### 输出

```
4
2
1
1
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕从n个学生能力值中找出挑出k个人时能力值最大公约数的问题。核心思路是通过统计各因数出现次数来求解，不同题解在具体实现和优化上有差异。
1. **思路方面**：多数题解先求出所有数的因数，统计各因数出现次数，再根据出现次数确定不同k值下的最大公约数。暴力做法是枚举所有组合求最大公约数，但复杂度高不满足要求。
2. **算法要点**：利用数论中因数与公约数的关系，通过分解因数、统计因数出现次数，结合逆向递推或后缀最大值等操作得出结果。
3. **解决难点**：关键在于高效统计因数出现次数及根据不同k值确定最大公约数。如避免重复统计因数（处理完全平方数情况），利用因数出现次数与k的关系优化求解。

### 所选的题解
1. **作者：lzn（5星）**
    - **关键亮点**：思路清晰简洁，直接阐述核心思路，先求每个因数出现次数，再记录每个次数对应的最大因数，最后逆向递推，算法复杂度为O(n * sqrt(inf))。
    - **重点代码**：无代码，但核心思路如下：
```
1、求出每个因数出现的次数。
2、对于每个次数记录最大的因数。
3、根据f[k]=max(f[k],f[k+1])逆向递推。
```
2. **作者：夜刀神十香ღ（4星）**
    - **关键亮点**：基于lzn思路给出完整代码，代码简洁易懂，通过数组c记录因子次数，利用i的答案大于等于i + 1的答案这一性质，从大到小扫描找出答案。
    - **重点代码**：
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int n,t = 0,c[1000010];
//c[i]表示i作为因子的次数
int main()
{
    cin>>n;
    for(int i = 1;i <= n;i++)
    {
        int x; cin>>x;
        t = max(t,x);
        //记录目前最大能力值
        int m = sqrt(x);
        //能力值的开方
        for(int i = 1;i <= m;i++)
            if(x % i == 0)
            //有约数
            {
                c[i]++;
                //i作为因子的次数++
                if(x!= i * i) c[x / i]++;
                //如果x不是i的平方，x/i也是x的因子
                //如果x是i的平方只记录i作为一次因子
            }
    }
    int x = t;
    for(int i = 1;i <= n;i++)
    {
        while(c[x] < i) x--;
        //找出最大的默契值（本题专有名词好烦QwQ）
        cout<<x<<endl;
        //输出
    }
    return 0;
    //华丽丽的结束
}
```
核心实现思想：先读入数据，对每个数分解因数并统计各因数出现次数，然后从最大能力值开始，对于每个k值，找到满足因数出现次数大于等于k的最大因数并输出。
3. **作者：影辰（4星）**
    - **关键亮点**：提供一种暴力优化思路，通过桶记录所有值，枚举1到n及它们的倍数，统计倍数个数并更新答案数组，最后做后缀最大值操作，复杂度O(nlog n)。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf = 1e6 + 1;
int n,x,sum;
int t[inf];
int ans[10005];
int main(){
    scanf("%d",&n);
    for(int i = 1;i <= n;i++) scanf("%d",&x),t[x]++;
    for(int i = 1;i < inf;i++){
        sum = 0;
        for(int j = 1;i * j < inf;j++) sum += t[i * j];
        ans[sum] = i;
    }
    for(int i = n - 1;i >= 1;i--) ans[i] = max(ans[i],ans[i + 1]);
    for(int i = 1;i <= n;i++) printf("%d\n",ans[i]);
} 
```
核心实现思想：先将读入值存入桶t，然后枚举1到1e6，统计每个数倍数的个数，将该数存入对应倍数个数的答案数组位置，最后通过后缀最大值操作得到不同k值下的最大公约数。

### 最优关键思路或技巧
1. **因数分解优化**：利用数的因数成对出现性质，只需枚举到sqrt(x)，减少因数分解时间复杂度。如`for(int i = 1;i <= sqrt(x);i++)`，同时处理完全平方数避免重复统计。
2. **逆向递推或后缀最大值**：利用k个数最大公约数与(k + 1)个数最大公约数关系，通过逆向递推（如`f[k]=max(f[k],f[k+1])`）或后缀最大值操作，快速确定不同k值下的最大公约数。

### 可拓展之处
同类型题常出现在数论相关的组合问题中，如给定一组数，求满足特定条件（如最大公约数、最小公倍数等）的子数组或子集问题。类似算法套路是先分析问题与数论概念（如因数、倍数、公约数等）的联系，通过统计相关数论量（如因数出现次数），再结合数据大小和时间复杂度要求进行优化。

### 洛谷相似题目
1. **P1890 [USACO03NOV] 滑雪课程设计 Ski Course Design**：涉及数据处理和优化问题，与本题优化思路有相似之处。
2. **P2392 kkksc03考前临时抱佛脚**：通过合理安排任务求最优解，和本题在寻找最优值思路上有共通点。
3. **P1094 [NOIP2007 普及组] 纪念品分组**：同样是根据给定数据进行分组求最优解，对数论和贪心思想有一定考察。 

---
处理用时：92.09秒
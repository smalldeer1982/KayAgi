# 题目信息

# 无聊的数列

## 题目背景

无聊的 YYB 总喜欢搞出一些正常人无法搞出的东西。有一天，无聊的 YYB 想出了一道无聊的题：无聊的数列。。。

## 题目描述

维护一个数列 $a_i$，支持两种操作：

 - `1 l r K D`：给出一个长度等于 $r-l+1$ 的等差数列，首项为 $K$，公差为 $D$，并将它对应加到 $[l,r]$ 范围中的每一个数上。即：令 $a_l=a_l+K,a_{l+1}=a_{l+1}+K+D\ldots a_r=a_r+K+(r-l) \times D$。

 - `2 p`：询问序列的第 $p$ 个数的值 $a_p$。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 数据，$0\le n,m \le 10^5,-200\le a_i,K,D\le 200, 1 \leq l \leq r \leq n, 1 \leq p \leq n$。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5
1 2 4 1 2
2 3
```

### 输出

```
6```

# AI分析结果

• 综合分析与结论：
    - 这些题解主要围绕如何高效处理区间等差数列加法和单点查询展开，运用了线段树、树状数组、差分等数据结构和算法思想。
    - 思路上，有的通过差分将区间等差数列加法转化为差分序列上的操作（如AC_Automation、__stdcall）；有的直接用线段树维护首项和公差来处理（如Alloverzyt）；还有用二阶差分结合树状数组（ll_dio）、建两棵线段树分别处理常数和等差数列部分（Allons—y）、分块暴力处理（wjr_jok）以及对每个点维护特殊标记（kkxhh）等方法。
    - 解决难点在于如何优化区间操作和查询的时间复杂度，以及正确处理边界条件。
    - 综合质量来看，AC_Automation的题解思路清晰，详细阐述了差分与线段树结合的方法及易错点，代码注释详细，可读性强；kkxhh提供了独特的标记维护思路，代码简洁；ll_dio的二阶差分与树状数组结合思路新颖且对原理分析透彻。这三篇题解相对质量较高。

所选的题解：
  - **AC_Automation（5星）**
    - **关键亮点**：清晰阐述线段树结合差分的解题思路，通过实例说明差分处理等差数列加法的原理，对代码错误及修正详细说明，代码注释丰富。
    - **个人心得**：调题过程发现r + 1可能越界，l + 1可能>r的问题，提示注意边界条件。
    - **核心代码**：
```cpp
// 线段树相关函数
inline int ls(int root){return root<<1;}
inline int rs(int root){return root<<1|1;}
inline void up(int root){a[root].sum=a[ls(root)].sum+a[rs(root)].sum;}
void build(int root,int l,int r){
    a[root].tag=0;int mid=(l+r)>>1;
    if(l==r){a[root].sum=data[l];return;}
    build(ls(root),l,mid);build(rs(root),mid+1,r);
    up(root);
}
inline void pd(int root,int l,int r){
    int mid=(l+r)>>1;
    a[ls(root)].tag+=a[root].tag;
    a[rs(root)].tag+=a[root].tag;
    a[ls(root)].sum+=a[root].tag*(mid-l+1);
    a[rs(root)].sum+=a[root].tag*(r-mid);
    a[root].tag=0;
}
void add(int root,int l,int r,int ql,int qr,ll x){
    if(ql<=l&&qr>=r){a[root].tag+=x;a[root].sum+=(r-l+1)*x;return;}
    int mid=(l+r)>>1;
    pd(root,l,r);
    if(ql<=mid)add(ls(root),l,mid,ql,qr,x);
    if(qr>mid) add(rs(root),mid+1,r,ql,qr,x);
    up(root);
    return;
}
ll query(int root,int l,int r,int ql,int qr){
    if(ql<=l&&qr>=r)
        return a[root].sum;
    int mid=(l+r)>>1,ret=0;
    pd(root,l,r);
    if(ql<=mid)ret+=query(ls(root),l,mid,ql,qr);
    if(qr>mid)ret+=query(rs(root),mid+1,r,ql,qr);
    return ret;
}
// 主函数部分
int main()
{
    int n,m,opt,l,r,k,d,t;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>data[i];
    for(int i=n-1;i>0;i--)
        data[i+1]=data[i+1]-data[i];//将原序列差分
    build(1,1,n);
    for(int i=0;i<m;i++){
        cin>>opt;
        if(opt==1){
            cin>>l>>r>>k>>d;
            add(1,1,n,l,l,k);
            if(l+1<=r)add(1,1,n,l+1,r,d);
            if(r<n)add(1,1,n,r+1,r+1,-(k+d*(r-l)));//注意这里加了判断
        }
        else{
            cin>>t;
            cout<<query(1,1,n,1,t)<<endl;
        }
        
    }
    return 0;
}
```
    - **核心思想**：先将原序列差分，利用线段树维护差分序列。区间加等差数列时，在差分序列相应位置进行操作，单点查询时查询差分序列前缀和得到原序列值。
  - **kkxhh（4星）**
    - **关键亮点**：提出独特的标记维护思路，对每个点维护两个标记，简化区间操作，且提到可标记永久化优化常数。
    - **核心代码**：
```cpp
void modify(ll o,ll l,ll r,ll ql,ll qr,ll t1,ll t2){
    if(ql<=l && qr>=r) {t[o].tag+=t1,t[o].tag2+=t2; return;}
    ll mid=(l+r)>>1;
    if(ql<=mid) modify(lt,l,mid,ql,qr,t1,t2);
    if(qr>=mid+1) modify(rt,mid+1,r,ql,qr,t1,t2);
}

ll query(ll o,ll l,ll r,ll q,ll t1,ll t2){
    if(l==r) {return t1+t[o].tag+l*(t2+t[o].tag2);}
    ll mid=(l+r)>>1;
    if(q<=mid) return query(lt,l,mid,q,t1+t[o].tag,t2+t[o].tag2);
    else return query(rt,mid+1,r,q,t1+t[o].tag,t2+t[o].tag2);
}

int main(){
    n=read(); m=read();
    for(ll i=1;i<=n;i++) a[i]=read();
    while(m--){
        ll opt=read();
        if(opt==1){
            ll l=read(),r=read(),k=read(),d=read();
            modify(1,1,n,l,r,k-d*l,d);
        }
        else{
            ll q=read();
            printf("%lld\n",query(1,1,n,q,0,0)+a[q]);
        }
    }
    return 0;
}
```
    - **核心思想**：修改区间时，给区间加上k - d×l，再给每个位置加上下标×d ，通过维护这两个标记实现区间操作，查询时加上标记值得到结果。
  - **ll_dio（4星）**
    - **关键亮点**：采用二阶差分结合树状数组的方法，对二阶差分原理及操作分析详细，通过数学推导将二阶前缀和转化为维护两个树状数组，且说明无需特判越界的原因。
    - **核心代码**：
```cpp
void add(ll x,ll delta){
    ll id=x;
    while(x<=n){
        bit1[x]+=delta;
        bit2[x]+=delta*id;
        x+=LSB(x);
    }
}
ll query(ll x){
    ll id=x,sum=0;
    while(x){
        sum+=(id+1)*bit1[x]-bit2[x];
        x-=LSB(x);
    }
    return sum;
}
void solve(){
    for(ll i=1;i<=m;i++){
        ll op;
        scanf("%lld",&op);
        if(op==1){
            ll l,r,K,D;
            scanf("%lld %lld %lld %lld",&l,&r,&K,&D);
            add(l,K); add(l+1,D-K); add(r+1,-(r-l+1)*D-K); add(r+2,K+(r-l)*D);
        }else{
            ll p;
            scanf("%lld",&p);
            printf("%lld\n",query(p));
        }
    }
}
```
    - **核心思想**：对区间加等差数列操作分析二阶差分变化，得到点更新操作，利用树状数组维护二阶差分数组的前缀和与二阶差分数组乘下标的前缀和，实现高效查询。

**最优关键思路或技巧**：利用差分思想将区间等差数列加法转化为更易处理的操作，结合线段树或树状数组等数据结构优化时间复杂度。如通过一阶差分将区间操作转化为差分序列上的点操作，用线段树维护差分序列；二阶差分将段更新转化为点更新，用树状数组维护相关前缀和。

**拓展思路**：此类题目属于区间修改、单点查询类型，类似套路可用于处理其他具有特定规律的区间修改操作，如区间加等比数列等。可先分析操作在差分序列上的变化，转化为可高效处理的形式，再选择合适的数据结构维护。

**推荐题目**：
  - P3372 【模板】线段树 1 ，基础线段树区间修改、单点查询题目，可巩固线段树基本操作。
  - P1972 [SDOI2009]HH的项链 ，结合线段树与离散化处理区间查询问题，与本题有相似的数据结构运用思路。
  - P3368 【模板】树状数组 2 ，树状数组区间修改、单点查询模板题，可加深对树状数组处理此类问题的理解。 

---
处理用时：131.28秒
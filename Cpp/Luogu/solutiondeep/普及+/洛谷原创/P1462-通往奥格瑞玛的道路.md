# 题目信息

# 通往奥格瑞玛的道路

## 题目背景

在艾泽拉斯大陆上有一位名叫歪嘴哦的神奇术士，他是部落的中坚力量。

有一天他醒来后发现自己居然到了联盟的主城暴风城。

在被众多联盟的士兵攻击后，他决定逃回自己的家乡奥格瑞玛。

## 题目描述

在艾泽拉斯，有 $n$ 个城市。编号为 $1,2,3,\ldots,n$。

城市之间有 $m$ 条双向的公路，连接着两个城市，从某个城市到另一个城市，会遭到联盟的攻击，进而损失一定的血量。

每次经过一个城市，都会被收取一定的过路费（包括起点和终点）。路上并没有收费站。

假设 $1$ 为暴风城，$n$ 为奥格瑞玛，而他的血量最多为 $b$，出发时他的血量是满的。如果他的血量降低至负数，则他就无法到达奥格瑞玛。

歪嘴哦不希望花很多钱，他想知道，在所有可以到达奥格瑞玛的道路中，对于每条道路所经过的城市收费的最大值，最小值为多少。

## 说明/提示

对于 $60\%$ 的数据，满足 $n\leq 200$，$m\leq 10^4$，$b\leq 200$；

对于 $100\%$ 的数据，满足 $1\leq n\leq 10^4$，$1\leq m\leq 5\times 10^4$，$1\leq b\leq 10^9$；

对于 $100\%$ 的数据，满足 $1\leq c_i\leq 10^9$，$0\leq f_i\leq 10^9$，可能有两条边连接着相同的城市。

## 样例 #1

### 输入

```
4 4 8
8
5
6
10
2 1 2
2 4 1
1 3 4
3 4 3
```

### 输出

```
10
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均为二分答案结合最短路算法。通过二分经过城市收费的最大值，在每次二分中，限制经过城市的收费不超过该二分结果，再利用最短路算法（主要为Dijkstra和SPFA）判断在此限制下能否从起点到达终点且血量足够。难点在于如何合理地二分以及在最短路算法中正确处理收费限制。

### 所选的题解
- **作者：George1123 (赞：80)  星级：4星**
    - **关键亮点**：思路清晰，代码注释详细。先确定二分范围，再二分答案并在每次二分中调用Dijkstra算法判断可行性。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
void Dijkstra(int maxn){
    for(int i=1;i<=n;i++){
        dis[i]=inf;
        vis[i]=0;
    } 
    dis[1]=0;
    while(!q.empty()) q.pop();
    q.push((node){1,dis[1]});
    while(!q.empty()){
        node now=q.top(); q.pop();
        int x=now.a;
        if(vis[x]) continue;
        vis[x]=1;
        for(int i=g[x];i;i=e[i].nex){
            int p=e[i].adj;
            if(f[p]>maxn) continue;
            if(dis[x]+e[i].w<dis[p]){
                dis[p]=dis[x]+e[i].w;
                q.push((node){p,dis[p]});
            }
        }
    }
} 
```
核心思想：在Dijkstra算法中，跳过收费超过maxn的城市，更新到其他城市的最短距离。
- **作者：Atlicd (赞：44)  星级：4星**
    - **关键亮点**：思路阐述简洁明了，代码实现规范，详细分析了时间复杂度。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
inline bool judge(int x)
{
    memset(dis,-1,sizeof(dis));
    dis[1]=k;
    q.push(make_pair(dis[1],1));
    while(!q.empty())
    {
        int u=q.top().second;
        int d=q.top().first;
        q.pop();
        if(dis[u]!=d) continue;
        for(int i=head[u];i;i=nex[i])
        {
            int v=to[i];
            if(num[v]>x) continue;
            if(dis[v]<dis[u]-val[i] && dis[u]-val[i]>=0)
            {
                dis[v]=dis[u]-val[i];
                q.push(make_pair(dis[v],v));
            }
        }
    }
    return dis[n]!=-1;
}
```
核心思想：judge函数中，使用优先队列优化的Dijkstra算法，跳过收费超过x的城市，判断能否到达终点。
- **作者：shenbear (赞：21)  星级：4星**
    - **关键亮点**：详细梳理思路，强调二分的单调性以及最短路算法选择的原因。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
bool djstl(int mid)
{
    for(int i=2;i<=n;i++) dis[i]=1e9;
    q.push(vs(1,0));
    while(!q.empty())
    {
        vs u=q.top();
        q.pop();
        if(u.vl>dis[u.x]) continue;
        for(int i=head[u.x];i;i=p[i].next)
        {
            int v=p[i].to;
            if(a[v]>mid) 
                continue;
            if(dis[v]>dis[u.x]+p[i].vl)
            {
                dis[v]=dis[u.x]+p[i].vl;
                q.push(vs(v,dis[v]));
            }
        }
    }
    return dis[n]<b;
}
```
核心思想：djstl函数实现Dijkstra算法，以mid为收费上限，跳过收费超上限的城市，判断能否在血量限制内到达终点。

### 最优的关键思路或技巧
- **二分答案**：将求“最大值最小”这类较难直接求解的问题，转化为判断合法性问题，通过二分答案缩小范围。
- **结合最短路算法**：在二分的每一步中，利用最短路算法（如Dijkstra或SPFA）判断在当前收费限制下能否到达终点。
- **优化**：部分题解通过对城市收费值排序后二分，将对数二分优化为对数组下标二分，降低时间复杂度。

### 可拓展之处
同类型题常涉及在满足某些限制条件下求最优解，常见套路为二分答案结合图论算法（如最短路、最小生成树等）或其他贪心算法。例如，在带权图中，限制经过点的某些属性值，求满足条件的最优路径。

### 相似知识点洛谷题目
- [P1937 【模板】最近公共祖先2](https://www.luogu.com.cn/problem/P1937)：涉及树结构与二分答案，通过二分距离，结合最近公共祖先算法求解。
- [P2678 [NOIP2015 提高组] 跳石头](https://www.luogu.com.cn/problem/P2678)：典型的二分答案题目，通过二分跳跃距离，贪心判断可行性。
- [P3849 【模板】树链剖分](https://www.luogu.com.cn/problem/P3849)：树链剖分结合二分等操作，解决树上路径相关问题。

### 个人心得摘录与总结
无。 

---
处理用时：111.00秒
# 题目信息

# 计算e

## 题目背景

《爱与愁的故事第二弹·compute》最终章。

自然对数的底数 $e$ 是一个著名的无理数，其近似值为 $2.718281828\cdots$ 有计算 $e$ 的公式如下：

$$e=\sum_{n=0}^{\infty}\frac{1}{n!}$$

其中 $n!$ 表示 $n$ 的阶乘，即 $n!=1\times 2\times 3\times \cdots \times n$。


## 题目描述

月落乌啼竟然这么快就回复了圆周率小数点后10000位？！不可能，他肯定求了别人。爱与愁大神再次为难月落乌啼：“帮我算一算 $e$ 后 $n(n \le 10000)$ 位，速度！！！”月落乌啼想求别人，结果他发现由于刚才跟你通话已经用完了手机的所有电。关键时刻只能靠自己。如果现在你是他，你会怎么编这个程序？


## 说明/提示

$30\%$ 数据：$n \le 1000$  
$100\%$ 数据：$n \le 10000$

时限：全部1秒


## 样例 #1

### 输入

```
100```

### 输出

```
2.
7182818284 5904523536 0287471352 6624977572 4709369995
9574966967 6277240766 3035354759 4571382178 5251664274```

# AI分析结果

### 综合分析与结论
这些题解主要围绕计算自然对数底数 $e$ 展开，思路可分为打表法和高精度计算法。高精度计算法又基于公式 $e=\sum_{n=0}^{\infty}\frac{1}{n!}$ 衍生出不同做法，难点在于如何在满足精度要求下优化时间复杂度以避免超时。

### 所选的题解
1. **作者：TBB_Nozomi（5星）**
    - **关键亮点**：思路清晰，详细分析了两种非打表高精度解法。做法一利用通分和高精度除法，通过理论分析确定计算项数，优化累加和的计算；做法二通过实现高精度浮点数的 $\exp$ 函数，利用泰勒展开和误差分析优化乘法次数。
    - **个人心得**：无
    - **重点代码 - 做法一核心代码**：
```cpp
int main()	{
    int k;
    cin>>k;
    tbb::_LFloat_prec= (k/4)+2; //万进位高精
    LInt S= 1, P= 1, T= 1;
    int N;
    for(N=1; T.digit()<=tbb::_LFloat_prec*4; )	T*= (++N); //先估计分母阶乘的位数
    for(int i=N; i>0; i--)	{
        P*= i;	S+= P;
    }
    LFloat F=S;	F/=T; //做高精度浮点数除法
    string ans= F.print_str();
    const char* out= ans.c_str();
    putchar('2');	putchar('.');	putchar('\n');
    for(int T=1; T<=k; ++T)	{
        putchar(out[1+T]);
        if(T%50==0)	putchar('\n');
        else	if(T%10==0)	putchar(' ');
    }
    return 0;
}
```
    - **核心思想**：先估计分母阶乘位数确定 $N$，计算分子分母后做高精度浮点数除法得到结果并格式化输出。
2. **作者：TobyFlenderson（4星）**
    - **关键亮点**：先引用前人结论确定计算 $e$ 所需精度对应的 $n$ 值，通过通分将多次高精度除法降为一次，还提出两种优化思路，包括分块处理和优化高精度除法，并给出详细优化过程和实现代码。
    - **个人心得**：无
    - **重点代码 - 优化后核心代码**：
```cpp
int MIN_SPLIT = 128;
static void euler_split(int n, int m, LInt& p, LInt& q)
{
    if (m - n < MIN_SPLIT)
    {
        p = 1;
        q = 1;
        for (int i = m; i > n; i--)
        {
            q *= i;
            p += q;
        }
        q *= n;
        return;
    }
    LInt p1, p2, q1, q2;
    euler_split(n, (n + m) >> 1, p1, q1);
    euler_split((n + m + 2) >> 1, m, p2, q2);
    p = p1 * q2 + p2;
    q = q1 * q2;
}

int main()
{
    int k;
    cin >> k;
    LInt p, q;
    int n = get_n(k);
    euler_split(1, n, p, q);
    p += q;
    p <<= k / 4 + 2;
    p /= q;
    string ans = p.print_str();
    const char* out = ans.c_str();
    putchar('2');    putchar('.');    putchar('\n');
    for (int T = 1; T <= k; ++T) {
        putchar(out[T]);
        if (T % 50 == 0)    putchar('\n');
        else if (T % 10 == 0)    putchar(' ');
    }
    return 0;
}
```
    - **核心思想**：通过递归分块处理，当块长度小于阈值时采用通分计算，合并时使用低于 $O(n^2)$ 的大整数乘法优化计算。
3. **作者：iwprc（4星）**
    - **关键亮点**：代码简洁，直接利用高除单和高精度加法实现，通过数组一位存5个数字的方式优化空间和时间。
    - **个人心得**：无
    - **重点代码 - 核心代码**：
```cpp
#include<cstdio>
const int N=2005;
const int M=100000;
int a[N],s[N],t[N],i,k,p,n;
//a数组存答案，1位存5个数字
//s数组存(1/n!),也是1位存5个数字
//t数组用来过渡
int f=true;
int main(){
    i=2;
    a[1]=s[1]=50000;
    //初始化：a数组和s数组都赋值为0.5，下面从1/3!算起
    while(f){
        i++;
        //当前算1/i!
        p=0;
        for(k=0;k<N;k++){
            p=p*M+s[k];
            t[k]=p/i;
            p%=i;
        }
        //高除单，i!=(1/(i-1)!)/i
        f=false;
        for(k=0;k<N;k++){
            a[k]+=s[k]=t[k];
            if(s[k])
                f=true;
            //当s数组为空时，退出循环
            if(a[k]>=M)
                a[k-1]+=a[k]/M,a[k]%=M;
        }
        //高精度加法，把s加进a
    }
    scanf("%d",&n);
    printf("2.\n");
    for(i=1;i*5<=n;i++){
        printf("%05d",a[i]);
        if(!(i%10))
            printf("\n");
        else
            if(!(i%2))
                printf(" ");
    }
    //输出
    if(i*5-n==4)printf("%d",a[i]/10000);
    if(i*5-n==3)printf("%02d",a[i]/1000);
    if(i*5-n==2)printf("%03d",a[i]/100);
    if(i*5-n==1)printf("%04d",a[i]/10);    
    //因为是5位5位输出，最后几位单独输出    
    return 0;
}
```
    - **核心思想**：通过循环依次计算 $1/i!$ 并累加到结果数组，利用高除单和高精度加法实现，最后格式化输出。

### 最优关键思路或技巧
1. **理论分析确定计算项数**：通过拉格朗日余项或不等式分析确定计算 $e$ 达到指定精度所需的项数 $N$，避免不必要计算。
2. **通分优化计算**：将公式通分，减少高精度除法次数，降低时间复杂度。
3. **分块处理与乘法优化**：对表达式分块，在合适阈值下采用不同计算方式，并结合低于 $O(n^2)$ 的大整数乘法优化整体计算。
4. **压位存储**：采用一位存储多个数字的方式，优化空间和时间。

### 可拓展之处
同类型题常涉及高精度计算和级数求和，类似算法套路包括利用数学公式优化计算、分块处理、选择合适数据结构存储大数等。例如计算其他常数（如 $\pi$ ）的高精度值，或求解收敛级数的和。

### 相似知识点洛谷题目
1. **P1517 高精度小数的正整数幂**：考察高精度小数运算，与本题高精度计算相关。
2. **P5432 A/B problem**：高精度除法问题，本题部分解法涉及相关知识。
3. **P1727 计算π**：同样是高精度计算常数问题，与本题计算 $e$ 思路类似。 

---
处理用时：119.94秒
# 题目信息

# 通天之潜水

## 题目背景

直达通天路·小 A 历险记第三篇


## 题目描述

在猴王的帮助下，小 A 终于走出了这篇荒山，却发现一条波涛汹涌的河拦在了自己的面前。河面上并没有船，但好在小 A 有 $n$ 个潜水工具。由于他还要背重重的背包，所以他只能背 $m$ 重的工具，又因为他的力气并不是无限的，河却很宽，所以他只能背有 $v$ 阻力的工具。但是这条河下有非常重要的数据，所以他希望能够停留的时间最久。于是他找到了你，让你告诉他方案。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le m, v \le 200$，$1 \le n \le 100$。

数据保证一定有方案。

若有多种方案，输出前面尽量小的方案。


## 样例 #1

### 输入

```
100 100 3
50 60 289
40 10 116
50 50 106
```

### 输出

```
405 
1 2
```

# AI分析结果

• 综合分析与结论：这些题解均明确该题为二维费用的01背包问题。思路上，都通过定义二维状态数组 `dp` 表示在不同重量和阻力限制下能获得的最大价值（或最长停留时间），状态转移方程核心为 `dp[i][j] = max(dp[i][j], dp[i - a][j - b] + c)`，其中 `a`、`b`、`c` 分别为物品的重量、阻力和价值。难点在于记录方案并保证在多种方案下输出前面尽量小（字典序最小）的方案，各题解普遍通过二维字符串数组记录方案，在更新 `dp` 时同时更新字符串数组，并在价值相等时比较字典序。代码实现上整体思路相似，部分差异在于变量命名、输入输出方式及一些细节处理。

所选的题解：
  - 作者WaterSky (5星)
    - 关键亮点：思路清晰，先给出常规背包解法，再针对 “输出前面尽量小的方案” 这一难点进行修正，代码注释详细。
    - 个人心得：一开始被Hack掉，仔细读题后发现遗漏 “若有多种方案，输出前面尽量小的方案” 这一条件，通过在判断条件中加入价值相等时挑选字典序更小的方案得以AC。
    - 重点代码（核心实现思想：通过三重循环遍历物品、重量和阻力，依据状态转移方程更新 `dp` 数组和记录方案的字符串数组）：
```cpp
for(int i=1;i<=n;i++)
    for(int j=m;j>=a[i].a;j--)
        for(int k=v;k>=a[i].b;k--)
        {
            if(dp[j-a[i].a][k-a[i].b]+a[i].c>dp[j][k] || dp[j-a[i].a][k-a[i].b]+a[i].c==dp[j][k] && ans[j-a[i].a][k-a[i].b]+char(a[i].t)<ans[j][k])
                dp[j][k]=dp[j-a[i].a][k-a[i].b]+a[i].c,ans[j][k]=ans[j-a[i].a][k-a[i].b]+char(a[i].t);
        }
```
  - 作者dsy2022 (4星)
    - 关键亮点：对问题分析全面，从问题分析、解决思路到状态定义、转移方程、初始化、状态转移及输出结果都有详细说明，并给出时间和空间复杂度分析。
    - 重点代码（核心实现思想：通过三重循环更新 `dp` 数组记录最长停留时间，同时更新三维数组 `ans` 记录选择方案，在价值相等时通过比较已有方案确定是否更新）：
```cpp
fo(i,1,n) {
    for(j=m;j>=g[i];j--) {
        for(k=t;k>=f[i];k--) {
            if(dp[j-g[i]][k-f[i]]+v[i]>dp[j][k]) {
                dp[j][k]=dp[j-g[i]][k-f[i]]+v[i];
                fo(p,1,i) 
                    ans[j][k][p]=ans[j-g[i]][k-f[i]][p];
                ans[j][k][i]=1;
            }
            else if(dp[j-g[i]][k-f[i]]+v[i]==dp[j][k]) {
                bool flag=0;
                fo(p,1,i) {
                    if(ans[j][k][p] &&!ans[j-g[i]][k-f[i]][p])
                        break;
                    else if(!ans[j][k][p] && ans[j-g[i]][k-f[i]][p]) {
                        flag=1;
                        break;
                    }
                }
                if(flag) {
                    fo(p,1,i) 
                        ans[j][k][p]=ans[j-g[i]][k-f[i]][p],
                        ans[j][k][i]=1;
                }
            }
        }
    }
}
```
  - 作者2011FYCCCTA (4星)
    - 关键亮点：简洁明了，先点明是01背包问题并给出状态转移方程，针对记录方案且保证字典序最小的难点，详细说明了使用字符串数组记录方案的思路。
    - 重点代码（核心实现思想：通过三重循环，依据状态转移方程更新 `f` 数组记录最大价值，同时更新字符串数组 `s` 记录方案，价值相等时比较字典序更新方案）：
```cpp
for (int i = 1 ; i <= n ; i++)
    for (int j = m ; j >= a[i] ; j--)
        for (int k = v ; k >= b[i] ; k--)
        {
            char ci = (char)i;
            if (f[j][k] < f[j - a[i]][k - b[i]] + c[i])
            {
                f[j][k] = f[j - a[i]][k - b[i]] + c[i];
                s[j][k] = s[j - a[i]][k - b[i]] + ci;
            }
            else if (f[j][k] == f[j - a[i]][k - b[i]] + c[i] && s[j - a[i]][k - b[i]] + ci < s[j][k])
                s[j][k] = s[j - a[i]][k - b[i]] + ci;
        }
```

最优关键思路或技巧：利用二维数组记录状态解决二维费用背包问题，使用字符串数组记录方案，在更新状态时同时更新方案数组，并通过比较字典序保证输出方案前面尽量小。

可拓展之处：此类二维费用背包问题可拓展到更多维度费用限制的背包问题，思路类似，增加状态维度并相应调整状态转移方程。类似算法套路还可用于资源分配、任务调度等场景，需根据具体问题定义状态和转移方程。

推荐题目：
  - P1048 [NOIP2005 普及组] 采药
  - P1833 樱花
  - P2679 子串

---
处理用时：76.01秒
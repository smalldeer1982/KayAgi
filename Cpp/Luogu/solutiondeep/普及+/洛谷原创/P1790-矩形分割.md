# 题目信息

# 矩形分割

## 题目描述

有一个长为 $a$，宽为 $b$ 的矩形（$1 \le a \le 6$，$2 \le b \le 6$）。可以把这个矩形看作是 $a\times b$ 个小方格。

我们现在接到了这样的一个任务：请你计算出，把这个矩形分割成两个部分的方法总数。

你不是可以任意地分割这个大的矩形，必须满足：

分割后，每个部分，至少各自均有一个方格是在大矩形的最外边上（即大矩形最外面一环的方格）。



## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/buv0992j.png)

## 样例 #1

### 输入

```
3 2```

### 输出

```
15```

# AI分析结果

### 综合分析与结论
这些题解主要分为打表和搜索两种思路。打表利用数据范围小的特点，预先算出结果存储，时间复杂度为O(1)，但缺乏通用性。搜索思路则将矩形分割问题转化为从边缘点出发到另一边缘点的路径搜索问题，关键在于处理无效切割。不同题解在细节处理和代码实现上有所差异。

### 所选的题解
- **作者：yyyyyyyf (5星)**
    - **关键亮点**：思路清晰，详细阐述将矩形问题转化为点图搜索问题，以及如何避免无效切割的具体方法，代码实现简洁明了。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 10
int n,m;
int ans=0;
int movex[4]={1,0,-1,0};
int movey[4]={0,1,0,-1};
int vis[N][N];
void dfs(int x,int y)
    {
        vis[x][y]=1;
        if(x==1 || y==m || x==n || y==1) //到达另一个边缘点
            {
                ans++;
                vis[x][y]=0;
                return;
            }
        for(int i=0;i<4;++i)
            {
                int xx=x+movex[i],yy=y+movey[i];
                if(xx<1 || yy<1 || xx>n || yy>m || vis[xx][yy]) continue;
                dfs(xx,yy);
            }
        vis[x][y]=0;
    }
int main()  
    {
        scanf("%d%d",&n,&m);
        n++;m++; //转换为点图
        memset(vis,0,sizeof(vis));
        for(int i=2;i<n;++i) //这么写就是为了去掉交点
            {
                vis[i][1]=1;//手动将出发点设为已访问
                dfs(i,2);//然后手动走第一步，防止无效切割
                vis[i][1]=0;//回溯
            }
        for(int i=2;i<m;++i) //同上
            {
                vis[1][i]=1;
                dfs(2,i);
                vis[1][i]=0;
            }
        printf("%d",ans);
        return 0;
    }
```
    - **核心思想**：将矩形转化为(a + 1)(b + 1)个点组成的点图，从最左及最上边缘非顶点的点出发，手动走一步后进行深度优先搜索，当再次到达边缘点时答案加1并回溯。

- **作者：linyinuo2008 (4星)**
    - **关键亮点**：详细解释为什么采用暴搜以及将格子图转化为点图的原因和具体方法，帮助理解问题本质。
    - **核心思想**：由于数据范围小，暴搜可行。将格子图转化为点图，把符合要求的矩形看成从大矩形内部点指向边缘点，从一个点深搜直到边缘，添加答案并返回，同时要注意分割与判重细节。

- **作者：君玘 (4星)**
    - **关键亮点**：代码简洁，在理解将分割矩形转化为搜索分割线思路基础上，清晰处理无效分割和重复计算问题。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define gc ch=getchar()
using namespace std;
template <class T>void read(T &s){
	s=0;T f=1;char gc;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;gc;}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';gc;}
	s*=f;	
}
template <class T>void put(T s){
	if(s<0) putchar('-'),s=-s;
	if(s>9) put(s/10);
	putchar(s%10+'0');
}
int a,b,ans,vis[505][505],v[505][505],dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};
void dfs(int x,int y){
	//到边界意味着分割完毕，答案+1 
	if(x==1||x==a||y==1||y==b){++ans;return;}
	v[x][y]=1;
	for(int i=0;i<4;++i){
		int nx=x+dx[i],ny=y+dy[i];
		if(v[nx][ny]) continue;
		dfs(nx,ny);
	} 
	v[x][y]=0;
}
int main(){
	read(a),read(b);++a,++b;//变成点图 
	//这个2就是手动往下走一步，1的位置记得先记录 
	for(int i=2;i<b;++i) v[1][i]=1,dfs(2,i),v[1][i]=0;
	for(int i=2;i<b;++i) v[a][i]=1,dfs(a-1,i),v[a][i]=0;
	for(int i=2;i<a;++i) v[i][1]=1,dfs(i,2),v[i][1]=0;
	for(int i=2;i<a;++i) v[i][b]=1,dfs(i,b-1),v[i][b]=0;
	//从一端搜出的线必然会在搜令一端的时候再次被搜出，所以答案/2 
	put(ans/2);
}
```
    - **核心思想**：将矩形转化为点图，从四边非顶点位置手动往中间走一步后进行深度优先搜索，由于从两端搜会有重复，最后答案除2。

### 最优关键思路或技巧
将矩形分割问题转化为点图中从边缘点到边缘点的路径搜索问题，通过合理处理出发点（避开顶点、手动走一步）来避免无效切割，利用深度优先搜索遍历所有可能路径。

### 可拓展之处
此类问题可拓展到更大数据范围，可能需要更高效算法如插头DP。类似算法套路是将几何图形的分割或组合问题转化为图的搜索问题，通过合理定义节点和边，以及搜索规则来解决。

### 推荐题目
- [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)：搜索与剪枝，尝试将小木棍拼成原始长度的大木棍，与本题搜索思路类似。
- [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)：全排列与搜索，遍历所有可能的路径顺序，与本题通过搜索遍历所有情况类似。
- [P1118 数字三角形](https://www.luogu.com.cn/problem/P1118)：动态规划与搜索思想结合，从顶部到底部寻找最大路径和，与本题搜索路径并计数有相似之处。

### 个人心得摘录与总结
暂无个人心得相关内容。 

---
处理用时：123.25秒
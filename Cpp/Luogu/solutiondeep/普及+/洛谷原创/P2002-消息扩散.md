# 题目信息

# 消息扩散

## 题目背景

本场比赛第一题，给个简单的吧，这 100 分先拿着。

## 题目描述

有 $n$ 个城市，中间有单向道路连接，消息会沿着道路扩散，现在给出 $n$ 个城市及其之间的道路，问至少需要在几个城市发布消息才能让这所有 $n$ 个城市都得到消息。

## 说明/提示

**【样例解释 #1】**

样例中在 $4, 5$ 号城市中发布消息。

**【数据范围】**

对于 $20 \%$ 的数据，$n \le 200$；  
对于 $40 \%$ 的数据，$n \le 2000$；  
对于 $100 \%$ 的数据，$1 \le n \le {10}^5$，$1 \le m \le 5 \times {10}^5$。

## 样例 #1

### 输入

```
5 4
1 2
2 1
2 3
5 1
```

### 输出

```
2
```

# AI分析结果

• 综合分析与结论：这些题解主要思路是通过缩点将有向图转化为有向无环图（DAG），再统计入度为0的强连通分量个数来求解。算法要点在于使用Tarjan或Kosaraju算法求强连通分量并缩点。解决难点主要是理解和实现强连通分量的求解以及缩点后入度的统计。大部分题解思路清晰，但在代码可读性和优化程度上有所差异。

所选的题解：
  - 作者：唔啊唔 (赞：29)  星级：4星
    - 关键亮点：详细解释了Tarjan算法中各数组含义，代码注释丰富，对Tarjan基本思路有讲解。
    - 个人心得：提到本题和另一道题相似，在其代码基础上修改完成。
    - 重点代码 - Tarjan算法核心实现：
```cpp
inline void tarjan(int x){
    cnt++;
    dfn[x]=low[x]=cnt;
    s.push(x);
    vis[x]=1;
    for(register int i=head[x];i;i=edge[i].next){
        int y=edge[i].to;
        if(dfn[y]==0){
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(vis[y]==1){
            low[x]=min(low[x],dfn[y]);
        }
    }
    if(low[x]==dfn[x]){
        int z;
        tot++;
        while(s.top()!=x){
            sum[tot]++;
            z=s.top();
            vis[z]=0;
            bj[z]=tot;
            s.pop();
        }
        sum[tot]++;
        z=s.top();
        vis[z]=0;
        bj[z]=tot;
        s.pop();
    }
    return;
}
```
核心思想：通过深度优先搜索，利用dfn记录访问顺序，low记录能追溯到最早的栈中节点的次序号，当low[x] == dfn[x]时找到一个强连通分量并出栈。

  - 作者：Amessal (赞：14)  星级：4星
    - 关键亮点：代码简洁明了，逻辑清晰，在构建图时处理自环，直接统计强连通分量缩点后的入度。
    - 重点代码 - 统计入度核心实现：
```cpp
for(int i=1;i<=n;i++)
  for(int e=first[i];e;e=nxt[e])
    if(belong[i]!=belong[to[e]])
      ru[belong[to[e]]]++;
```
核心思想：遍历原图每条边，若边两端点属于不同强连通分量，则目标端点所在强连通分量入度加1。

  - 作者：PrincessYR✨～ (赞：4)  星级：4星
    - 关键亮点：详细讲解强连通分量和Tarjan算法原理，用vector存图，代码可读性较好。
    - 个人心得：分享学习强连通分量和缩点的经历。
    - 重点代码 - Tarjan算法及缩点后统计入度核心实现：
```cpp
void tarjan(int now)
{
	dfn[now]=low[now]=++num;
	atack.push(now);
	inst[now]=true;
	for(int i=0;i<map[now].size();i++)
	{
		int next=map[now][i];
		if(dfn[next]==0)
		{
			tarjan(next);
		    low[now]=min(low[now],low[next]);
		}else if(inst[next]==1)
	    {
		low[now]=min(low[now],dfn[next]);
	    }
	}
	if(dfn[now]==low[now])
	{
		numb++;
		int q;
		do
		{
			q=atack.top();
			inst[q]=0;
			atack.pop();
			bl[q]=numb;
			nums[numb]++;
		}while(q!=now);
	}
}
for(int i=1;i<=a;i++)
{
	for(int j=0;j<map[i].size();j++)
	{
		int p=map[i][j];
		if(bl[i]!=bl[p])
		{
			ru[bl[p]]++;
		}
	}
}
```
核心思想：Tarjan算法部分同上述，统计入度部分遍历每个点及其邻接边，若两端点所属强连通分量不同则目标端点所在强连通分量入度加1。

最优关键思路或技巧：使用Tarjan算法求强连通分量并缩点，在缩点后通过遍历原图边统计入度为0的强连通分量个数，避免重新构图，降低时间复杂度。

可拓展之处：同类型题通常涉及有向图的连通性分析，类似算法套路是先判断图的连通性情况，若有环则考虑缩点转化为DAG后再进行相关操作。

推荐题目：
  - [P1262 间谍网络](https://www.luogu.org/problem/P1262)
  - [P2341 [HAOI2006]受欢迎的牛](https://www.luogu.org/problem/P2341)
  - [P3627 [APIO2009]抢掠计划](https://www.luogu.org/problem/P3627)

个人心得摘录与总结：部分作者分享了学习强连通分量和缩点算法的经历，以及在类似题目基础上修改代码完成本题的过程，强调了理解算法原理和积累相似题型经验的重要性。 

---
处理用时：87.34秒
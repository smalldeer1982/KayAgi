# 题目信息

# 选学霸

## 题目描述

老师想从 $n$ 名学生中选 $m$ 人当学霸，但有 $k$ 对人实力相当，如果实力相当的人中，一部分被选上，另一部分没有，同学们就会抗议。所以老师想请你帮他求出他该选多少学霸，才能既不让同学们抗议，又与原来的 $m$ 尽可能接近。

## 说明/提示

对于 $100\%$ 的数据，满足 $1 \le n,m \le 2 \times 10^4$。

## 样例 #1

### 输入

```
4 3 2
1 2
3 4```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均是先利用并查集将实力相当的学生合并为一个集合，统计每个集合的人数，再通过背包问题找出与目标人数 \( m \) 最接近的选择方案。
1. **思路**：用并查集处理实力相当的学生分组，将每个组看作背包中的一个物品，组内人数视为物品重量或价值，通过背包算法求解与 \( m \) 最接近的人数。
2. **算法要点**：
    - **并查集**：初始化每个学生为独立集合，读入实力相当的学生对，利用并查集的合并操作将其归为同一集合，并统计每个集合的人数。
    - **背包问题**：多采用01背包，部分题解将背包容量设为 \( 2m \) 或 \( n \)，通过状态转移方程计算不同背包容量下能选取的最大人数或判断能否达到该人数。
3. **解决难点**：如何将原问题转化为并查集与背包问题的组合，以及在背包问题中准确找到与 \( m \) 最接近的结果。部分题解通过扩大背包容量、枚举结果等方式解决。

### 所选的题解
1. **作者：望眼浮云 (赞：38)  星级：5星**
    - **关键亮点**：思路清晰，代码简洁明了。先详细阐述并查集合并及人数统计，再清晰说明背包问题的实现，特别指出为使结果接近 \( m \) 需扩大背包容量为 \( 2m \)。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：利用并查集合并实力相当的学生，统计每组人数，再通过01背包在扩大的容量范围内寻找最接近 \( m \) 的结果。
```cpp
int find(int u)
{
    if(f[u]==u) return u;
    else return f[u]=find(f[u]);
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(i=1;i<=n;i++)
        f[i]=i,p[i]=1; 
    for(i=1;i<=k;i++)
    {
        scanf("%d%d",&x,&y);
        int u=find(x);int v=find(y); 
        if(u!=v) f[u]=v,p[v]+=p[u]; 
    }
    for(i=1;i<=n;i++) 
        if(f[i]==i)
        {
            tot++;
            s[tot]=p[i];
        }
    for(i=1;i<=tot;i++) 
        for(j=2*m;j>=s[i];j--)
            dp[j]=max(dp[j],dp[j-s[i]]+s[i]);
    int ans=999999999,minn=999999999;
    for(i=1;i<=2*m;i++)	
    {
        if(minn>abs(dp[i]-m)) minn=abs(dp[i]-m),ans=dp[i];
    }
    if(ans==999999999) printf("0");
    else	printf("%d",ans);
    return 0;
}
```
2. **作者：蒟蒻zExNocs (赞：19)  星级：4星**
    - **关键亮点**：不仅给出代码，还对背包问题的应用及背包容量设置原因进行详细解释，对理解算法原理有很大帮助，同时提到特判 \( M = 0 \) 的情况。
    - **个人心得**：作者分享了自己思考为何用背包及背包内存设置的过程，引发读者共鸣。
    - **重点代码 - 核心实现思想**：与上一题解类似，通过并查集处理学生分组，用背包算法求解，最后枚举寻找最接近 \( m \) 的结果。
```cpp
ll find(ll x)
{
    return f[x]==x? x:f[x]=find(f[x]);
}
int main()
{
    n=read(),m=read(),k=read();
    for(int i=1;i<=n;i++)
        f[i]=i,a[i]=1;
    for(int u,v,i=1;i<=k;i++)
    {
        u=read(),v=read();
        if(find(u)!=find(v))
        {
            a[find(v)]+=a[find(u)];
            f[find(u)]=find(v);
        }
    }
    for(int i=1;i<=n;i++)
        if(i==f[i])	b[++cnt]=a[i];
    for(int i=1;i<=cnt;i++)
        for(int j=n;j>=b[i];j--)
            dp[j]=max(dp[j],dp[j-b[i]]+b[i]);
    for(int i=0;i<=n;i++)
        if(amin>abs(dp[i]-m))
            amin=abs(dp[i]-m),ans=dp[i];
    if(ans==maxx) pr(0);
    else pr(ans);
    return qwq;
}
```
3. **作者：LlLlCc (赞：13)  星级：4星**
    - **关键亮点**：将原问题巧妙转化为熟悉的背包问题场景，即N个班选M个班参加活动使人数与K最接近，对理解问题本质有很好的引导作用，同时给出简单的转移方程。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：通过并查集合并相关学生，转化为背包问题后，利用状态转移方程判断能否选出对应人数，最后枚举寻找最接近 \( m \) 的结果。
```cpp
inline int getfa(int x){
    if (fa[x]==x) return x;
    return fa[x]=getfa(fa[x]);
}
int main(){
    n=read(),allv=read(),m=read();
    for (int i=1;i<=n;i++) fa[i]=i;
    for (int i=1;i<=m;i++){
        x=read(),y=read();
        int fx=getfa(x),fy=getfa(y);
        if (fx==fy) continue;
        fa[fy]=fx;
    }
    for (int i=1;i<=n;i++){
        if (!lnk[getfa(i)]) lnk[fa[i]]=++tot;
        v[lnk[fa[i]]]++;
    }
    f[0]=1;
    for (int i=1;i<=tot;i++) 
        for (int j=allv<<1;j>=v[i];j--) f[j]|=f[j-v[i]];
    for (int i=0;i<=allv;i++){    
        if (f[allv-i]){printf("%d",allv-i);return 0;}
        if (f[allv+i]){printf("%d",allv+i);return 0;}
    }
}
```

### 最优的关键思路或技巧
1. **数据结构**：并查集高效处理学生分组问题，快速判断和合并实力相当的学生集合。
2. **算法优化**：部分题解通过扩大背包容量到 \( 2m \) 来确保能找到与 \( m \) 最接近的结果，避免遗漏可能的最优解。
3. **思维方式**：将实际问题抽象为经典的并查集与背包问题，通过转化问题场景加深对问题本质的理解，从而找到解决方案。

### 可拓展之处
此类题目属于组合优化问题，常见拓展方向是增加限制条件，如不同组学生有不同优先级，或背包有多重限制等。类似算法套路是先分析问题中的约束关系，利用合适的数据结构处理约束，再转化为经典的优化问题（如背包、线性规划等）求解。

### 相似知识点的洛谷题目
1. [P1197 星球大战](https://www.luogu.com.cn/problem/P1197)：涉及并查集与图的连通性问题，与本题利用并查集处理元素关系类似。
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)：典型的01背包问题，可作为背包算法基础练习，与本题背包部分知识点相同。
3. [P2014 [CTSC1997] 选课](https://www.luogu.com.cn/problem/P2014)：树形背包问题，在本题基础上增加了树形结构的限制，拓展了背包问题的应用场景。

### 个人心得摘录与总结
1. **作者：Miri**：分享了调试过程中因手误导致错误的经历，强调了代码实现中细节的重要性。
2. **作者：蒟蒻zExNocs**：讲述自己思考为何用背包及背包内存设置的过程，体现了理解算法原理的重要性，鼓励读者深入思考算法背后的逻辑。 

---
处理用时：105.86秒
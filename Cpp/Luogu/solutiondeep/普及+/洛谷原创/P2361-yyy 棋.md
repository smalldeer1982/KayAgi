# 题目信息

# yyy 棋

## 题目描述

uim 最近在研究一种游戏，叫做“ yyy 棋”。

这种游戏的规则很简单，就是有一个 $A \times B$ 的棋盘和黑白两色的棋子，两个人轮流在下在格子里面。你可以下黑棋或者白棋，中途可以更换颜色，可以下在任何你喜欢的地方，但是要符合以下条件：

1. 这个位置不能已经被别的棋子占用。

2. 你准备下的地方，上下左右一格范围中不能有和你准备下的颜色一样的棋子。

3. 第一个下的人必须出黑子。


当谁没有地方可以放子，谁就输了。


uim 把你拉了出来，希望你好好地陪他玩。

由于你很忙不太情愿，uim 就让步了，允许你选择先手或者后手。


你突然灵光一现，想到了你小学奥数做到的一个问题：两个人坐在一张桌子的两边，轮流往桌子上放硬币，硬币不能重叠，谁放不下谁就输了。感觉有点类似，所以，你打算借鉴这个办法。

你知道，通过某种策略，你一定是 $100\%$ 赢的。

既然如此，就让 uim 输个痛快吧。

## 说明/提示

$40\%$ 数据，$2 \le A, B \le 3$。

$100\%$ 数据，$2 \le A, B \le 9$。

然而作为月赛的第一题，自然是简单的。因为标程的核心代码只有 $6$ 行。并不需要使用什么复杂算法就可以得到答案。


## 样例 #1

### 输入

```
2 2

1 2 1

1 1 1```

### 输出

```
Second

2 1 0

Buwanle```

# AI分析结果

• 综合分析与结论：
    - 这些题解思路基本一致，均利用对称策略解题。要点在于根据棋盘长宽的奇偶性决定先后手及棋子颜色。若长宽均为奇数，先手占中心点，之后与对手下相同颜色且对称位置的棋子；若长或宽有偶数，选择后手，与对手下相反颜色且对称位置的棋子。难点在于理解为何如此选择先后手及颜色，通过小棋盘模拟可辅助理解。
    - 从思路清晰度、代码可读性、优化程度等方面看，多数题解思路清晰，但部分代码可读性欠佳，如部分代码使用万能头文件、变量命名不规范等。整体无复杂优化。

所选的题解：
  - **作者：Zhou_yu (5星)**
    - **关键亮点**：思路阐述详细，对先后手选择、棋子位置及颜色确定均有清晰解释，代码结构完整，变量命名易懂，注释丰富。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>a>>b;
    int t=0,flag=1;
    if(a%2)t++;
    if(b%2)t++;
    if(t==2)cout<<"First";
    else
    {
        cout<<"Second";
        flag=0;
    }
    cout<<'\n';
    if(t==2)
    {
        cout<<a/2+1<<' '<<b/2+1<<' '<<1<<'\n';
        for(int i=0;i<4;i++)
        {
            int tx=dx[i]+a/2+1;
            int ty=dy[i]+b/2+1;
            if(tx<1||ty<1||tx>a||ty>b)continue;
            f[tx][ty].can_be_1=0;
        }
    }
    int x,y,c;
    while(cin>>x>>y>>c)
    {
        if(f[x][y].is_full)out();
        if(c==1&&f[x][y].can_be_1==0)out();
        if(c==0&&f[x][y].can_be_0==0)out();
        f[x][y].is_full=1;
        f[x][y].color=c;
        for(int i=0;i<4;i++)
        {
            int tx=dx[i]+x;
            int ty=dy[i]+y;
            if(tx<1||ty<1||tx>a||ty>b)continue;
            if(c==1)f[tx][ty].can_be_1=0;
            else f[tx][ty].can_be_0=0;
        }
        int will_color=c;
        if(!flag)
        {
            if(c==1)will_color=0;
            else will_color=1;
        }
        int will_choose_x=a-x+1;
        int will_choose_y=b-y+1;
        cout<<will_choose_x<<' '<<will_choose_y<<' '<<will_color<<'\n';
        for(int i=0;i<4;i++)
        {
            int tx=dx[i]+will_choose_x;
            int ty=dy[i]+will_choose_y;
            if(tx<1||ty<1||tx>a||ty>b)continue;
            if(will_color==1)f[tx][ty].can_be_1=0;
            else f[tx][ty].can_be_0=0;
        }
    }
    return 0;
}
```
    - **核心实现思想**：先判断棋盘长宽奇偶性确定先后手，先手时输出中心点。读入对手下棋位置后，判断其是否合规，更新棋盘状态，根据奇偶性确定自己下棋颜色及位置并输出，同时更新对应位置下棋限制。

  - **作者：小恐 (4星)**
    - **关键亮点**：思路讲解结合具体例子和图示，易于理解，代码简洁，变量命名较清晰。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
int main()
{
    bool ji;
    read(m),read(n);
    if((m*n)%2)
        printf("First\n%d %d 1\n",(m+1)/2,(n+1)/2),ji=1;
    else
        printf("Second\n"),ji=0;
    while(read(x)&&read(y)&&read(c))
    {
        if(x>m||x<1||y>n||y<1)
        {
            printf("Buwanle");
            break;
        }
        bool flag=1;
        for(int i=0;i<4;++i)
        {
            tx=dx[i]+x,ty=dy[i]+y;
            if(a[tx][ty]=='a'+c)
            {
                flag=0;
                break;
            }
        }
        if(!flag)
        {
            printf("Buwanle");
            break;
        }
        a[x][y]='a'+c;
        a[m-x+1][n-y+1]='a'+c;
        if(ji)
            printf("%d %d %d\n",m-x+1,n-y+1,c),a[m-x+1][n-y+1]='a'+c;
        else
            printf("%d %d %d\n",m-x+1,n-y+1,1-c),a[m-x+1][n-y+1]='a'+1-c;
    }
    return 0;
}
```
    - **核心实现思想**：通过乘积判断棋盘奇偶性确定先后手，读入对手下棋位置，检查合法性后更新棋盘，根据奇偶性决定自己下棋颜色及位置并输出。

  - **作者：koreyoshi_lemon (4星)**
    - **关键亮点**：对奇偶情况分别分析，解释选择颜色原因，代码简洁，利用位运算判断奇偶，函数封装较好。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
int main(void)
{
    memset(v,-1,sizeof(v));
    scanf("%d%d",&n,&m);
    if(n*m&1)
    {
        printf("First\n");
        printf("%d %d %d\n",n+1>>1,m+1>>1,1);
    }
    else printf("Second\n");
    int x,y,z;
    while(cin>>x>>y>>z)
    {
        if(judge(x,y,z))
        {
            printf("Buwanle\n");
            return 0;
        }
        v[x][y]=z;
        v[n+1-x][m+1-y]=cal(z);
        printf("%d %d %d\n",n+1-x,m+1-y,v[n+1-x][m+1-y]);
    }
    return 0;
}
```
    - **核心实现思想**：初始化棋盘，通过位运算判断奇偶确定先后手，读入对手下棋位置，经合法性判断后更新棋盘，根据奇偶性计算并输出自己下棋位置和颜色。

• 最优关键思路或技巧：利用对称策略，根据棋盘长宽奇偶性分类讨论先后手及棋子颜色，通过小棋盘模拟辅助理解策略原理。

• 可拓展之处：此类题属于博弈论中的对称博弈类型，类似套路是找到对称中心或对称关系，根据条件确定应对策略。

• 相似知识点洛谷题目：
    - P1247 取火柴游戏
    - P2197 模板 - Nim游戏
    - P2252 取石子游戏II

• 个人心得摘录与总结：无

---
处理用时：90.35秒
# 题目信息

# 正妹吃月饼

## 题目描述

今天是中秋节。uim 带来了一堆大小不同且味道各异的月饼。

这些月饼的质量分别是 $1g,2g,4g,8g,16g$....后面一个是前面的 $2$ 倍。每种只有一个。

uim 让正妹随便吃。

正妹希望尝试尽可能多的口味，所以会吃尽可能多数量的月饼（不是重量）。而且她的确有些饿了，至少总共要吃掉 $A\text{g}$ 的月饼才能满足。

然而正妹怕长胖，所以吃月饼不能合计超过 $B\text{g}$ 。

她希望知道自己最多能吃多少个月饼


## 说明/提示

**样例解释**：

正妹可以吃 $1,2,4,16$ 这 $4$ 个月饼（吃法可能不唯一）。

**数据范围**：

对于 $30\%$ 数据，$1\le A,B \le 1000$；

对于 $60\%$ 数据，$1 \le A,B \le 100000$；

对于 $100\%$ 数据，$1 \le A,B \le 2^{63}-1$。


## 样例 #1

### 输入

```
16 25```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕在给定区间[A, B]内找出二进制表示中1的个数最多的数这一核心问题。多数题解利用了二进制特性和贪心策略，部分采用位运算优化。
1. **思路**：
    - **二进制贪心类**：从A的二进制表示出发，通过位运算改变0位为1，使结果在区间内且1的个数最多。如将A二进制分解后从最低位找0，贪心判断变为1后是否小于等于B；或从最高位考虑，减去某位后判断是否满足区间条件。
    - **模拟遍历类**：先计算出不超过B的所有月饼重量和，再通过循环调整，减去或加上月饼使重量满足区间，统计月饼个数。
2. **算法要点**：
    - **位运算操作**：左移（<<）、右移（>>）、与（&）、或（|）等操作，用于处理二进制数。
    - **贪心策略**：在满足区间条件下，尽可能增加二进制表示中的1。
3. **解决难点**：
    - **数据范围大**：使用`long long`或`unsigned long long`类型，部分通过位运算优化避免暴力遍历超时。
    - **寻找最优解**：通过合理的贪心策略和对二进制数的操作，找到区间内1最多的数。

### 所选的题解
1. **作者：Invoker（5星）**
    - **关键亮点**：思路简洁清晰，利用位运算快速求解。通过`(l|(l + 1)) <= r`判断能否将A的某一位从0变为1，优化了寻找最优解过程。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#define LL long long
using namespace std;
int main()
{
    int ans = 0;
    LL l, r;
    cin >> l >> r;
    while ((l|(l + 1)) <= r) l|= l + 1;
    while (l) ans += l & 1, l >>= 1;
    cout << ans << endl;
    return 0;
}
```
    - **核心思想**：第一个`while`循环不断将A（即`l`）二进制表示中低位的0变为1，只要结果不超过B（即`r`）；第二个`while`循环统计最终结果中1的个数。
2. **作者：Dog_Two（4星）**
    - **关键亮点**：从倒序减的角度，利用全1二进制数表示初始月饼集合，通过减去2的幂次调整集合，证明了算法正确性。
    - **个人心得**：对初始月饼集合取值和算法流程进行详细正确性证明。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
ULL A, B;
int main() {
    cin >> A >> B;
    ULL val = 1;
    while (val < B) val = (val << 1)+1;
    ULL Bit = (val + 1) >> 1;
    for (; val > B; Bit >>= 1) {
        val = val - Bit < A? val : val - Bit;
    }
    int cnt = 0;
    for (; val; val >>= 1) if (val & 1) ++cnt;
    cout << cnt;
    return 0;
}
```
    - **核心思想**：首先找到第一个恰好不小于B的二进制全1数字`val`，然后从其最高位开始，判断减去该位后是否小于A，若不小于则减去该位，最后统计剩余`val`中1的个数。
3. **作者：zrzluck99（4星）**
    - **关键亮点**：通过找A和B二进制表示的异位，将A异位后的位全填1，特殊情况判断取A或B中1多的，思路新颖且高效。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    long long x, y;
    scanf("%lld %lld", &x, &y);
    long long t = x ^ y;
    while (t > 0) t >>= 1, x|= t;
    long long q = 0;
    while (x > 0) x &= x - 1, q++;
    long long r = 0;
    while (y > 0) y &= y - 1, r++;
    printf("%lld\n", max(q, r));
    return 0;
}
```
    - **核心思想**：先通过异或找到A和B的异位`t`，将`x`（即A）异位后的位填1，然后分别统计此时`x`和`y`（即B）中1的个数，取较大值输出。

### 最优关键思路或技巧
1. **位运算优化**：利用位运算操作（如`|`、`&`、`>>`）对二进制数高效处理，避免暴力枚举，降低时间复杂度。
2. **贪心策略**：基于二进制数特性，从低位或高位贪心调整二进制位，使结果在区间内且1的个数最多。

### 可拓展之处
同类型题常考察在特定数值区间内，基于某种数字表示（如二进制）的最优解问题。类似算法套路是结合位运算和贪心策略，根据题目条件对数字的二进制表示进行调整。

### 洛谷相似题目
1. [P1088 火星人](https://www.luogu.com.cn/problem/P1088)：涉及到数字的排列和变换，可通过类似贪心策略解决。
2. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)：利用贪心思想删除数字得到最小数，与本题贪心思路类似。
3. [P1268 树的重量](https://www.luogu.com.cn/problem/P1268)：通过分析数据特性，结合贪心策略求解树的重量，考察对数据规律的挖掘和应用。 

---
处理用时：90.59秒
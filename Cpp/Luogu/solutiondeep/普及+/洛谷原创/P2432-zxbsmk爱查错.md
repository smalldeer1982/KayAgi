# 题目信息

# zxbsmk爱查错

## 题目背景

zxbsmk 在暑假回了一趟老家，见到了自己的外婆。然而他遇到了一个问题。

## 题目描述

外婆很喜欢给别人写信，然而因为年纪大了，信里面充斥着各种错误。所以 zxbsmk 打算帮外婆修正每个错误的句子。

因为外婆的文化水平很高，所以她写的句子都是英文句子，并且句子内的字母都是小写字母。然而 zxbsmk 的英语水平非常低，所以他买来了一本英语词典，词典里一共有 $W (1 \leq W \leq 600)$ 个单词，每个单词的长度都不超过 $25$ 个字母，而且都是由小写字母组成的。

那么再来看一下外婆的句子都有什么错误。例如，外婆写的一个句子是 `catotail`，这并没有什么意义，因为一个多余的字母 `o` 出现了，所以正确的句子应该是 `cattail`。

已知外婆的句子是由 $L (2 \leq L \leq 300)$ 个字母组成的。其中有一些字母是多余的。现在，请你借助 zxbsmk 的词典，帮助他修正外婆的句子。而且你必须尽量少地去除多余的字母，使剩余的字母是一个合法的句子。

## 说明/提示

`catotail` $\to$ `cattail`

## 样例 #1

### 输入

```
2 8
catotail
cat
tail```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这几道题解均围绕如何修正外婆含多余字母的英文句子展开，核心思路都是利用动态规划（DP）求解最少需删除的字母数。不同之处在于对状态转移方程的具体描述和代码实现细节。
1. **思路方面**：多数题解设 `dp[i]` 表示主串前 `i` 位最少需删除的字母数，通过枚举单词，从主串后往前匹配单词，若匹配成功则更新 `dp[i]`。木木！的题解将问题转化为建图求最短路，利用拓扑序已知的DAG图进行DP。
2. **算法要点**：关键在于确定状态转移方程和匹配单词的具体实现。状态转移方程一般为 `dp[i]=min{dp[i - 1]+1,dp[k]+(i - k - len[j])}`，其中 `k` 为匹配单词的最大左端点 - 1。匹配单词时，常使用双指针从后往前遍历主串和单词串。
3. **解决难点**：难点在于如何准确找到匹配单词的区间，以及如何构建合理的状态转移方程。木木！的建图方法需巧妙构建边关系，理解和实现相对复杂。

### 所选的题解
#### 作者：lsroi (5星)
- **关键亮点**：思路清晰，直接点明用DP求解，详细解释状态转移方程各部分含义，代码简洁明了，变量命名规范，易于理解。
```cpp
// 核心代码片段
for(i=0;i<len;i++)
{
    if(!i)f[i+1]=1;
    else f[i+1]=f[i]+1;
    for(j=1;j<=n;j++)
    {
        int l=i,l1=len1[j]-1;
        while(l>=0&&l1>=0)
        {
            if(s[l]==s1[j][l1])l--,l1--;
            else l--;
        }
        if(l1<0)f[i+1]=min(f[i+1],f[l+1]+(i-l-len1[j]));
    }
}
```
核心实现思想：外层循环遍历主串，初始化 `f[i + 1]` 为最劣情况，即 `f[i] + 1`。内层循环枚举所有单词，用双指针 `l` 和 `l1` 从主串和单词串末尾开始匹配，若匹配成功则更新 `f[i + 1]`。

#### 作者：rsdbk_husky (4星)
- **关键亮点**：详细分析问题性质，指出符合无后效性和子问题重叠性，适合用DP。通过配图详细解释状态转移方程中各变量含义，代码注释详细。
```cpp
// 核心代码片段
for (int i = 1; i <= txtlen; ++i) {
    d[i] = d[i - 1] + 1;
    for (int j = 1; j <= wordcnt; ++j) {
        int wordidx = strlen(word[j] + 1);
        int txtidx;
        int delcnt = 0;
        bool seccessmatch = 0;
        for (txtidx = i; txtidx >= 1; --txtidx) {
            if (wordidx == 0) {
                seccessmatch = 1;
                break;
            }
            if (txt[txtidx] == word[j][wordidx]) {
                --wordidx;
            } else {
                ++delcnt;
            }
        }
        if (wordidx == 0) {
            seccessmatch = 1;
        }
        if (seccessmatch) {
            d[i] = min(d[i], d[txtidx] + delcnt);
        }
    } 
}
```
核心实现思想：外层循环遍历文本串，初始化 `d[i]` 为 `d[i - 1] + 1`。内层循环枚举单词，从文本串当前位置 `i` 往前匹配单词，记录匹配过程中的失配次数 `delcnt` 和匹配成功标志 `seccessmatch`，若匹配成功则更新 `d[i]`。

#### 作者：quarmer (4星)
- **关键亮点**：简洁明了地简化题意，清晰阐述DP思路和状态转移方程，代码实现简洁，利用指针思想匹配单词，易理解。
```cpp
// 核心代码片段
for(int i = 1 ; i <= m ; i++) {
    f[i] = f[i - 1] + 1;
    for(int j = 1 ; j <= n ; j++) {
        int r1 = i, r2 = d[j].size();
        int flag = 1;
        while(r1 && r2) {
            if(d[j][r2 - 1] == s[r1 - 1]) r1--, r2--;
            else r1--;
            if(!r2) flag = 0;
        }
        if(!flag) f[i] = min(f[r1] + i - r1 - (int)d[j].size(), f[i]);
    }
}
```
核心实现思想：外层循环遍历主串，初始化 `f[i]` 为 `f[i - 1] + 1`。内层循环枚举单词，用双指针 `r1` 和 `r2` 从主串和单词串末尾开始匹配，若匹配成功则更新 `f[i]`。

### 最优关键思路或技巧
1. **动态规划思想**：通过定义合适的状态 `dp[i]`，利用子问题重叠性和无后效性，构建状态转移方程求解。
2. **双指针匹配技巧**：在匹配单词时，使用双指针从主串和单词串末尾开始遍历，有效判断单词是否能在主串中匹配，优化匹配过程。

### 可拓展之处
此类题目属于字符串处理与动态规划结合的问题，相似类型题有：
1. 给定一组单词和一个字符串，判断字符串能否由这些单词拼接而成，可拓展为能否用最少单词拼接等。
2. 给定一个字符串和多个子串，求字符串中包含子串的最大数量等。

### 洛谷相似题目推荐
1. P1048 [NOIP2005 普及组] 采药
2. P1270 “访问”美术馆
3. P1470 [USACO2.3]最长前缀Longest Prefix

### 个人心得摘录与总结
无。 

---
处理用时：84.22秒
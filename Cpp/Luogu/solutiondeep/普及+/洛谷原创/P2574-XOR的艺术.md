# 题目信息

# XOR的艺术

## 题目描述

AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下：

1. 拥有一个伤害串，是一个长度为 $n$ 的只含字符 ``0`` 和字符 ``1`` 的字符串。规定这个字符串的首字符是第一个字符，即下标从 $1$ 开始。
2. 给定一个范围 $[l,~r]$，伤害为伤害串的这个范围内中字符 ``1`` 的个数。
3. 会修改伤害串中的数值，修改的方法是把 $[l,~r]$ 中所有原来的字符 ``0`` 变成 ``1``，将 ``1`` 变成 ``0``。

AKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。

## 说明/提示

#### 样例输入输出 $1$ 解释

原伤害串为 ``1011101001``。

对于第一次操作，改变 $[2,~4]$ 的字符，伤害串变为 ``1100101001``。

对于第二次操作，查询 $[1,~5]$ 内 ``1`` 的个数，共有 $3$ 个。

对于第三次操作，改变 $[3,~7]$ 的字符，伤害串变为 ``1111010001``。

对于第四次操作，查询 $[1,~10]$ 内 ``1`` 的个数，共有 $6$ 个。

对于第五次操作，改变 $[1,~4]$ 的字符，伤害串变为 ``0000010001``。

对于第六次操作，查询 $[2,~6]$ 内 ``1`` 的个数，共有 $1$ 个。

#### 数据范围与约定

对于 $10\%$ 的数据，保证 $n, m \leq 10$。

另有 $30\%$ 的数据，保证 $n, m \leq 2 \times 10^3$。

对于 $100\%$ 的数据，保证 $2 \leq n, m \leq 2 \times 10^5$，$0 \leq op \leq 1$，$1 \leq l \leq r \leq n$，$S$ 中只含字符 ``0`` 和字符 ``1``。

## 样例 #1

### 输入

```
10 6
1011101001
0 2 4
1 1 5
0 3 7
1 1 10
0 1 4
1 2 6
```

### 输出

```
3
6
1
```

# AI分析结果

### 综合分析与结论
该题要求对长度为 \(n\) 的01串进行区间修改（将区间内0和1互换）和区间查询（查询区间内1的个数）操作，数据范围较大。题解主要采用线段树和分块两种算法，少数使用压位暴力。
 - **线段树**：利用线段树维护区间信息，通过懒标记处理区间修改。关键在于理解01串异或1操作后，区间内1的个数变化规律（变为区间长度减去原1的个数），以及懒标记的传递和处理。不同题解在代码实现细节上有差异，如结构体定义、函数命名、下传标记方式等。
 - **分块**：将数组分为 \(\sqrt{n}\) 块，记录块的相关信息。修改和查询操作都分两边和中间部分处理，两边暴力操作，中间利用懒标记。时间复杂度为 \(O(m\sqrt{n})\)。
 - **压位暴力**：将32个二进制位压入一个 `unsigned int` 中，暴力修改并统计1的个数，依赖O2优化。

综合来看，线段树和分块是较优解法，线段树时间复杂度 \(O(n \log n)\) 更适合大数据规模；分块代码相对简洁，理解和实现难度稍低。

### 所选题解
1. **作者：H2O3 (赞：39)  星级：5星**
    - **关键亮点**：思路清晰，详细阐述线段树原理及实现细节，包括建树、更新、查询过程，代码规范，注释详尽。
    - **重点代码 - 建树**：
```cpp
inline void bulid(int l,int r,int rt)//建树 
{
    if(l==r)
    {
        sum[rt]=a[l];//赋值 
        return ;
    }
    int mid=(l+r)>>1;
    bulid(l,mid,rt<<1);
    bulid(mid+1,r,rt<<1|1);
    getup(rt);
}
```
    - **重点代码 - 更新**：
```cpp
inline void update(int L,int R,int l,int r,int rt)//更新 
{
    pushdown(rt,r-l+1);
    if(l>=L&&r<=R)
    {
        add[rt]^=1;
        sum[rt]=r-l+1-sum[rt];
        return;
    }
    int mid=(l+r)>>1;
    if(L<=mid) update(L,R,l,mid,rt<<1);
    if(mid+1<=R) update(L,R,mid+1,r,rt<<1|1);  
    getup(rt);
} 
```
    - **重点代码 - 查询**：
```cpp
inline ll query(int L,int R,int l,int r,int rt)//分区间查询 
{//LR是要查询的区间，lr是给定的区间。update同理。 
    if(l>=L&&r<=R)return sum[rt];
    pushdown(rt,r-l+1);
    int mid=(r+l)>>1;
    ll tot=0;
    if(L<=mid) tot+=query(L,R,l,mid,rt<<1);
    if(mid+1<=R) tot+=query(L,R,mid+1,r,rt<<1|1);
    return tot;
}
```
2. **作者：Holy_Push (赞：20)  星级：4星**
    - **关键亮点**：采用分块算法，详细讲解分块思路、预处理及操作实现过程，代码结构清晰，注释完整。
    - **重点代码 - 预处理**：
```cpp
h=(int)sqrt(n);
for (int i=1;i<=n;i++) blk[i]=(i-1)/h+1;
for (int i=1;i<=n;i++)
    if (blk[i]!=blk[i-1]) fst[blk[i]]=i,lst[blk[i-1]]=i-1;
lst[blk[n]]=n;
```
    - **重点代码 - 修改**：
```cpp
void update(int l,int r)
{
    int bl=blk[l],br=blk[r];
    if (bl==br) 
    {
        for (int i=l;i<=r;i++) sum[bl][a[i]]--,a[i]^=1,sum[bl][a[i]]++;
        return;
    }
    for (int i=bl+1;i<br;i++) tag[i]^=1;
    for (int i=l;i<=lst[bl];i++) sum[bl][a[i]]--,a[i]^=1,sum[bl][a[i]]++;
    for (int i=fst[br];i<=r;i++) sum[br][a[i]]--,a[i]^=1,sum[br][a[i]]++;
}
```
    - **重点代码 - 查询**：
```cpp
int query(int l,int r)
{
    int bl=blk[l],br=blk[r],ans=0;
    if (bl==br) 
    {
        for (int i=l;i<=r;i++) if (a[i]^tag[bl]==1) ans++;
        return ans;
    }
    for (int i=bl+1;i<br;i++) ans+=sum[i][1^tag[i]];
    for (int i=l;i<=lst[bl];i++) if (a[i]^tag[bl]==1) ans++;
    for (int i=fst[br];i<=r;i++) if (a[i]^tag[br]==1) ans++;
    return ans;
}
```
3. **作者：llzzxx712 (赞：19)  星级：4星**
    - **关键亮点**：详细分析题目，从题意到线段树各部分实现（建树、修改、查询）逐步讲解，代码简洁明了，注释丰富。
    - **重点代码 - 建树**：
```cpp
void build(int p,int le,int r){
    le(p)=le,r(p)=r;
    if(le==r){
        sum(p)=b[le];
        return ;
    }
    int mid=(le+r)/2;
    build(p*2,le,mid);
    build(p*2+1,mid+1,r);
    sum(p)=sum(p*2)+sum(p*2+1); 
}
```
    - **重点代码 - 修改**：
```cpp
void spread(int p){    
    if(!la2(p)) return;
    sum(p*2)=r(p*2)-le(p*2)+1-sum(p*2);
    sum(p*2+1)=r(p*2+1)-le(p*2+1)+1-sum(p*2+1);
    la2(p*2)=!la2(p*2);la2(p*2+1)=!la2(p*2+1);
    la2(p)=0;
}
void change(int p,int le,int r){
    if(le<=le(p)&&r>=r(p)){
        sum(p)=r(p)-le(p)+1-sum(p);
        la2(p)=!la2(p);
        return;
    }
    spread(p);
    int mid=(le(p)+r(p))/2;
    if(mid>=le) change(p*2,le,r);
    if(mid<r) change(p*2+1,le,r);
    sum(p)=sum(p*2+1)+sum(2*p);
}
```
    - **重点代码 - 查询**：
```cpp
int ask(int p,int le,int r){
    int ans=0;
    if(le(p)>=le&&r(p)<=r){
        return sum(p);     
    }
    spread(p);
    int mid=(le(p)+r(p))/2;
    if(mid>=le) ans=ans+ask(p*2,le,r);
    if(mid<r) ans=ans+ask(p*2+1,le,r);
    return ans;
}
```

### 最优关键思路或技巧
 - **线段树**：利用线段树高效处理区间问题，通过懒标记优化区间修改操作，减少时间复杂度。关键在于理解01串异或1操作后区间和的变化规律，以及懒标记的正确传递和处理。
 - **分块**：分块算法将数据分块，通过预处理和懒标记，实现对区间操作的优化。在处理大数据时，分块算法代码相对简洁，理解和实现难度较低。

### 可拓展之处
同类型题或类似算法套路：
 - **区间操作类**：如区间加、区间乘、区间最值查询等，可通过线段树或分块算法解决，关键在于根据操作特点设计合适的懒标记和更新策略。
 - **数据结构应用**：除线段树和分块外，树状数组也可处理一些区间查询和单点修改问题，可根据具体题目特点选择合适的数据结构。

### 相似知识点洛谷题目
 - **P3372 【模板】线段树 1**：基础线段树模板题，包括区间修改和区间查询操作，可巩固线段树基本实现。
 - **P3373 【模板】线段树 2**：在基础线段树操作上增加区间乘法，进一步加深对线段树懒标记处理的理解。
 - **P1903 [国家集训队]数颜色 / 维护队列**：结合分块算法和莫队算法，处理区间查询和修改问题，锻炼分块算法应用能力。

### 个人心得摘录与总结
 - **秋日私语**：做该题时在 `tot` 数组处理上出错，意识到异或操作在区间里是总数减去 `sum` 值。总结出在处理区间异或操作时，要准确把握数据变化规律，细致处理数组相关操作。 

---
处理用时：112.17秒
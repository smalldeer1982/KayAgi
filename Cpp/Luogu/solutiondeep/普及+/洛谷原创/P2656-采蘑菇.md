# 题目信息

# 采蘑菇

## 题目描述

小胖和 ZYR 要去 ESQMS 森林采蘑菇。

ESQMS 森林间有 $N$ 个小树丛，$M$ 条小径，每条小径都是单向的，连接两个小树丛，上面都有一定数量的蘑菇。小胖和 ZYR 经过某条小径一次，可以采走这条路上所有的蘑菇。由于 ESQMS 森林是一片神奇的沃土，所以一条路上的蘑菇被采过后，又会长出一些新的蘑菇，数量为原来蘑菇的数量乘上这条路的“恢复系数”，再下取整。

比如，一条路上有 $4$ 个蘑菇，这条路的“恢复系数”为 $0.7$，则第一~四次经过这条路径所能采到的蘑菇数量分别为 $4,2,1,0$。

现在，小胖和 ZYR 从 $S$ 号小树丛出发，求他们最多能采到多少蘑菇。


## 说明/提示

对于 $30\%$ 的数据，$N\le 7$，$M\le15$

另有 $30\%$ 的数据，满足所有“恢复系数”为 $0$。

对于 $100\%$ 的数据，$1
\le N\le 8\times 10^4$，$1\le M\le 2\times 10^5$，$0\le\text{恢复系数}\le 0.8$ 且最多有一位小数， $1\le S\le N$。

## 样例 #1

### 输入

```
3 3
1 2 4 0.5
1 3 7 0.1
2 3 4 0.6
1```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均是先通过Tarjan算法对有向图进行缩点，将强连通分量缩成点，处理每个强连通分量内可获取的蘑菇总数（考虑恢复系数），再在缩点后的有向无环图（DAG）上求最长路径，从而得出从起点出发能采到的最多蘑菇数。主要差异在于求最长路径的方式及一些实现细节。
1. **思路与算法要点**：
    - **Tarjan缩点**：利用Tarjan算法找出图中的强连通分量，并将其缩成点，这是解决本题的基础。
    - **处理恢复系数**：将恢复系数乘10转化为整数处理，避免浮点数精度问题，同时计算每条边在强连通分量内可获取的蘑菇总数。
    - **求最长路径**：在缩点后的DAG上，部分题解使用SPFA求最长路（如银杉水杉秃杉、Gao_yc等），部分使用DFS或拓扑排序结合DP（如Demon_master、Erinyes等）。
2. **解决难点**：
    - **缩点后边权处理**：将同一强连通分量内的边权转化为点权，不同强连通分量间按原路径连接建边。
    - **恢复系数处理**：通过整数运算避免浮点数精度问题，同时准确计算重复经过边时获取的蘑菇总数。

### 所选的题解
1. **银杉水杉秃杉（5星）**
    - **关键亮点**：思路清晰，代码简洁明了，严格按照题目标签“缩点 + spfa”实现。详细注释了Tarjan缩点和SPFA求最长路的模板代码，对恢复系数的处理方法说明清晰，便于理解和学习。
    - **个人心得**：无
    - **重点代码 - Tarjan缩点**：
```cpp
void tarjan(int u)
{
    dfn[u] = low[u] = ++cnt;
    vis[u] = 1;
    st.push(u);
    for (int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (!dfn[v])
        {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v])
            low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u])
    {
        tot++;
        int v;
        do
        {
            v = st.top();
            st.pop();
            col[v] = tot;
            vis[v] = 0;
        } while (v!= u);
    }
}
```
核心思想：通过深度优先搜索，利用时间戳dfn和追溯值low标记节点，当dfn[u] == low[u]时找到一个强连通分量，将栈中节点出栈并染色。
    - **重点代码 - SPFA求最长路**：
```cpp
void spfa(int s)
{
    memset(dis, -1, sizeof(dis));
    memset(V, 0, sizeof(V));
    dis[s] = sum[s];
    V[s] = 1;
    q.push(s);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        V[u] = 0;
        for (int i = H[u]; i; i = E[i].next)
        {
            int v = E[i].to, w = E[i].val;
            if (dis[v] < dis[u] + w + sum[v])
            {
                dis[v] = dis[u] + w + sum[v];
                if (!V[v])
                {
                    V[v] = 1;
                    q.push(v);
                }
            }
        }
    }
}
```
核心思想：初始化距离数组dis，将起点s的距离设为其点权sum[s]，通过队列不断更新节点的最长距离。
2. **Erinyes（4星）**
    - **关键亮点**：对算法分析详细，分步骤阐述了Tarjan缩点、处理边权、拓扑排序结合DP的过程，逻辑严谨。代码结构清晰，每个功能模块都有详细注释。
    - **个人心得**：无
    - **重点代码 - Tarjan缩点**：与银杉水杉秃杉的Tarjan缩点代码思路一致，此处省略。
    - **重点代码 - 处理边权并建图**：
```cpp
for(int x=1;x<=n;x++){ 
    for(int i=h[x];i;i=t[i].next){ 
        int y=t[i].to;
        if(c[x]!=c[y]){ 
            addc(c[x],c[y],t[i].v); 
            rd[c[y]]++; 
        }else{
            int s=0,a=t[i].v;
            while(a){ 
                s+=a;
                a*=t[i].g; 
                a/=10;
            }
            sum[c[x]]+=s; 
        }
    }
}
```
核心思想：枚举每条边，若边的两端点不在同一强连通分量，则在新图中连接两点并统计入度；若在同一强连通分量，则计算该边可获取的蘑菇总数并累加到对应强连通分量的点权sum中。
    - **重点代码 - 拓扑排序结合DP**：
```cpp
void toposort()
{
    queue<int> q; 
    for(int i=1;i<=cnt;i++){
        if(!rd[i]) q.push(i); 
        f[i]=-INF; 
    }
    f[c[s]]=sum[c[s]]; 
    while(!q.empty()){
        int x=q.front(); q.pop(); 
        for(int i=hc[x];i;i=tc[i].next){ 
            int y=tc[i].to;
            f[y]=max(f[y],f[x]+tc[i].v+sum[y]); 
            rd[y]--; 
            if(!rd[y]) q.push(y); 
        }
    }
}
```
核心思想：初始化DP数组f为负无穷，将起点所在强连通分量的DP值设为其点权。通过拓扑排序，利用队列依次更新每个强连通分量的DP值。
3. **Aryper（4星）**
    - **关键亮点**：从DP的角度出发，先将图缩点为DAG，再在DAG上进行DP，思路独特。对恢复系数的处理通过计算边最多经过次数保证正确性，同时提到了记忆化优化，代码实现简洁。
    - **个人心得**：提到读入系数时因未考虑系数为0的情况导致读入超时，提醒注意边界情况。
    - **重点代码 - Tarjan缩点**：与上述题解的Tarjan缩点代码思路一致，此处省略。
    - **重点代码 - 处理边权并建图**：与Erinyes题解中处理边权并建图的思路一致，此处省略。
    - **重点代码 - DAG上DP**：
```cpp
ll dp(ll p) {
    if(vis[p]) return f[p];vis[p]=1;
    ll ma=0;
    for(ll i=hc[p];i;i=nc[i]) {
        ma=max(ma,dp(vc[i])+wc[i]);
    }
    return f[p]=ma+val[p];
}
```
核心思想：通过记忆化搜索，递归计算从起点到当前点p的最大蘑菇数，利用vis数组避免重复计算。

### 最优关键思路或技巧
1. **整数处理恢复系数**：将恢复系数乘10转化为整数，在计算中使用整数运算，避免浮点数精度问题，这是处理恢复系数的有效技巧。
2. **Tarjan缩点与DAG处理**：利用Tarjan算法缩点，将强连通分量内的边权转化为点权，在缩点后的DAG上通过SPFA、拓扑排序结合DP等方法求最长路径，是解决此类有环图路径问题的常用思路。

### 拓展思路
同类型题或类似算法套路通常围绕有向图的环处理及路径问题，例如在一些涉及资源收集、任务调度的场景中，若存在可重复执行的任务（类似环），可通过缩点将其转化为DAG，再进行后续的最优解计算。

### 相似知识点洛谷题目
1. **P3387 【模板】缩点**：纯Tarjan缩点模板题，用于巩固缩点算法的理解和实现。
2. **P1196 [NOI2002] 银河英雄传说**：结合并查集和Tarjan缩点，考察对图结构的处理和分析。
3. **P2341 [USACO03FALL]Beauty Contest G**：通过缩点将复杂图简化，再进行距离计算，与本题处理思路类似。

### 个人心得摘录与总结
1. **Aryper**：读入系数时未考虑系数为0的情况导致读入超时，提醒在处理输入数据时要全面考虑边界情况，避免因特殊值导致程序出错。 

---
处理用时：112.34秒
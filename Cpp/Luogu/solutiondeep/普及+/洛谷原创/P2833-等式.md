# 题目信息

# 等式

## 题目背景

ZKC 有一天突发奇想，望着天空想出一道很好的问题，但是绞尽脑汁又不会做，所以请你来帮他解决。


## 题目描述

给出 $a,b,c,x_1,x_2,y_1,y_2$，求满足 $ax+by+c=0$，且 $x\in [x_1,x_2]$，$y\in [y_1,y_2]$ 的整数解有多少对。


## 说明/提示

对于 $30\%$ 的数据，$a,b,c,x_1,x_2,y_1,y_2$ 的绝对值不超过 $1000$。

对于 $100\%$ 的数据，$a,b,c,x_1,x_2,y_1,y_2$ 的绝对值不超过 $10^8$。


## 样例 #1

### 输入

```
1 1 -3 0 4 0 4```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解主要分为暴力解法和利用扩展欧几里得算法的解法。暴力解法通过枚举x或y，根据方程计算另一个变量并判断是否在给定范围内，需注意精度和特殊情况（如a = b = 0等），优点是思路简单，缺点是时间复杂度高，对于大数据范围可能超时。利用扩展欧几里得算法的解法，先求出方程ax + by = gcd(a, b)的特解，再根据条件得到通解，通过通解确定满足范围的解的个数，需处理多种特殊情况，优点是效率高，适用于大数据范围。

### 所选的题解
- **作者：saxiy（5星）**
    - **关键亮点**：思路清晰，详细介绍扩展欧几里得算法及应用，对各种特殊情况分析全面，代码简洁高效并给出详细注释。
    - **个人心得**：“本蒟蒻de了一下午的bug终于A了”，强调调试过程的不易。
    - **核心代码**：
```cpp
void exgcd(ll a, ll b, ll &x, ll &y, ll &gcd) {
    if(!b) { x = 1; y = 0; gcd = a; return; }
    exgcd(b, a % b, y, x, gcd); y -= a / b * x;
}
int main() {
    scanf("%lld%lld%lld%lld%lld%lld%lld",
        &a, &b, &c, &_x1, &_x2, &_y1, &_y2);
    if(_x1 > _x2 || _y1 > _y2) ans(0);
    c = -c;
    if(!a &&!b) {
        if(c) ans(0);
        else ans((_x2 - _x1 + 1) * (_y2 - _y1 + 1));
    }
    if(a < 0 && b < 0) a = -a, b = -b, c = -c;
    else if(a < 0) swap(_x1, _x2), _x1 = -_x1, _x2 = -_x2, a = -a;
    else if(b < 0) swap(_y1, _y2), _y1 = -_y1, _y2 = -_y2, b = -b;
    ll x, y, gcd;
    exgcd(a, b, x, y, gcd);
    if(c % gcd) ans(0);
    c /= gcd; x *= c; y *= c;
    if(!a) (_y1 <= y && y <= _y2)? ans(_x2 - _x1 + 1) : ans(0);
    if(!b) (_x1 <= x && x <= _x2)? ans(_y2 - _y1 + 1) : ans(0);
    double l = double(gcd * (_x1 - x)) / b;
    double r = double(gcd * (_x2 - x)) / b;
    l = fmax(l, double(gcd * (y - _y2)) / a);
    r = fmin(r, double(gcd * (y - _y1)) / a);
    int ansl = ceil(l), ansr = floor(r);
    ans(ansr >= ansl? ansr - ansl + 1 : 0);
    return 0;
}
```
    - **核心思想**：先通过exgcd函数求ax + by = gcd(a, b)的解，根据条件对a、b、c及范围进行处理，判断方程是否有解，再通过特解求通解，利用通解确定满足范围的解的个数。

- **作者：winmt（4星）**
    - **关键亮点**：清晰阐述解题思路，将原式化为标准形式，利用扩展欧几里得算法求解，代码结构清晰，对特殊情况判断全面。
    - **核心代码**：
```cpp
long long ext_euc(long long a, long long b, long long &x, long long &y) {
    if(b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    long long n = ext_euc(b, a % b, x, y);
    long long t = x;
    x = y;
    y = t - (a / b) * y;
    return n;
}
inline bool one_ans(long long a, long long b, long long c, long long &x, long long &y, long long &gcd) {
    c = -c;
    gcd = ext_euc(a, b, x, y);
    if(c % gcd!= 0)
        return false;
    long long k = c / gcd;
    x *= k;
    y *= k;
    return true;
}
int main() {
    ios::sync_with_stdio(false);
    long long a, b, c, x1, x2, y1, y2;
    cin >> a >> b >> c >> x1 >> x2 >> y1 >> y2;
    if(x1 > x2 || y1 > y2) {
        cout << "0\n";
        return 0;
    }
    if(a == 0 && b == 0) {
        if(c!= 0) {
            cout << "0\n";
        } else {
            cout << (x2 - x1 + 1) * (y2 - y1 + 1) << '\n';
        }
        return 0;
    }
    long long x, y, gcd;
    bool solved = one_ans(a, b, c, x, y, gcd);
    if(!solved) {
        cout << "0\n";
        return 0;
    }
    if(a == 0) {
        if(y1 <= y && y <= y2) {
            cout << "1\n";
            return 0;
        } else {
            cout << "0\n";
            return 0;
        }
    }
    if(b == 0) {
        if(x1 <= x && x <= x2) {
            cout << "1\n";
            return 0;
        } else {
            cout << "0\n";
            return 0;
        }
    }
    long long b_div_gcd = b / gcd;
    long long a_div_gcd = a / gcd;
    long long k1 = (x1 - x) / b_div_gcd;
    if(x + k1 * b_div_gcd < x1) {
        k1++;
    } else if(x + k1 * b_div_gcd > x2) {
        k1--;
    }
    if(x + k1 * b_div_gcd < x1 || x + k1 * b_div_gcd > x2) {
        cout << "0\n";
        return 0;
    }
    long long k2 = (x2 - x) / b_div_gcd;
    if(x + k2 * b_div_gcd < x1) {
        k2++;
    } else if(x + k2 * b_div_gcd > x2) {
        k2--;
    }
    if(x + k2 * b_div_gcd < x1 || x + k2 * b_div_gcd > x2) {
        cout << "0\n";
        return 0;
    }
    long long k3 = (y - y1) / a_div_gcd;
    if(y - k3 * a_div_gcd < y1) {
        k3--;
    } else if(y - k3 * a_div_gcd > y2) {
        k3++;
    }
    if(y - k3 * a_div_gcd < y1 || y - k3 * a_div_gcd > y2) {
        cout << "0\n";
        return 0;
    }
    long long k4 = (y - y2) / a_div_gcd;
    if(y - k4 * a_div_gcd < y1) {
        k4--;
    } else if(y - k4 * a_div_gcd > y2) {
        k4++;
    }
    if(y - k4 * a_div_gcd < y1 || y - k4 * a_div_gcd > y2) {
        cout << "0\n";
        return 0;
    }
    if(k1 > k2) swap(k1, k2);
    if(k3 > k4) swap(k3, k4);
    long long k_min = max(k1, k3);
    long long k_max = min(k2, k4);
    if(k_min <= k_max) {
        cout << k_max - k_min + 1 << '\n';
    } else {
        cout << "0\n";
    }
    return 0;
}
```
    - **核心思想**：通过ext_euc函数实现扩展欧几里得算法，one_ans函数求解方程ax + by + c = 0，根据条件判断方程是否有解，再通过通解确定满足范围的解的个数。

### 最优关键思路或技巧
利用扩展欧几里得算法求解不定方程的特解，再根据特解推出通解，通过对通解中参数k的范围限制来确定满足给定区间的整数解个数，同时要全面考虑a、b、c为0等特殊情况。

### 可拓展之处
同类型题可涉及求解线性同余方程、中国剩余定理等相关问题。类似算法套路是先利用扩展欧几里得算法求出特解，再根据题目条件确定通解及解的范围。

### 推荐题目
- [P1082 同余方程](https://www.luogu.org/problem/P1082)：求解ax ≡ 1 (mod b)的最小正整数解，需用到扩展欧几里得算法。
- [P1516 青蛙的约会](https://www.luogu.org/problem/P1516)：求两个点在环形路径上相遇的步数，可转化为线性同余方程求解。
- [P2421 楼兰图腾](https://www.luogu.org/problem/P2421)：通过计算逆序对和顺序对的数量，可运用树状数组或线段树优化暴力算法。

### 个人心得摘录与总结
- **作者：saxiy**：调试过程花费大量时间，强调了处理复杂逻辑和边界情况时调试的重要性。
- **作者：Tari**：调题过程中发现细节很重要，如左右端点的取整问题，反映出在实现算法时对细节处理不当会导致结果错误。 

---
处理用时：109.69秒
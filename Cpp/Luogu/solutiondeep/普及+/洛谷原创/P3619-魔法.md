# 题目信息

# 魔法

## 题目描述

cjwssb 知道是误会之后，跟你道了歉。你为了逗笑他，准备和他一起开始魔法。不过你的时间不多了，但是更惨的是你还需要完成 $n$ 个魔法任务。假设你当前的时间为 $T$，每个任务需要有一定的限制 $t_i$ 表示只有当你的 $T$ 严格大于 $t_i$ 时你才能完成这个任务，完成任务并不需要消耗时间。当你完成第 $i$ 个任务时，你的时间 $T$ 会加上 $b_i$，此时要保证 $T$ 在任何时刻都大于 $0$，那么请问你是否能完成这 $n$ 个魔法任务，如果可以，输出 $\texttt{+1}\texttt{s}$，如果不行，输出 $\texttt{-1}\texttt{s}$。


## 说明/提示

对于 $20\%$ 的数据，$n\leq10$；

对于 $100\%$ 的数据，$n\leq10^5,Z\leq10,t_i\leq10^5,T\leq10^5,-10^5\leq b_i\leq 10^5$。

By lantian

$\LaTeX$ By ⚡炭治郎⚡

## 因为历史遗留问题，博客讨论可能无法发出样例输出的字符串，可以考虑使用其他方式规避。


## 样例 #1

### 输入

```
1
2 13
1 -9
5 -3
```

### 输出

```
+1s
```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解都采用贪心策略，先将任务按$b$的正负分为两组，优先处理$b>0$的任务，再处理$b<0$的任务。
    - 算法要点：对于$b>0$的任务，按$t$从小到大排序；对于$b<0$的任务，按$t + b$从大到小排序，然后依次判断能否完成任务。
    - 解决难点：核心在于证明$b<0$时按$t + b$从大到小排序的正确性，不同题解通过不同方式推导该结论。
    - 整体来看，各题解思路相近，主要差异在证明过程、代码实现方式及细节处理上。

所选的题解：
  - 作者：lwz2002 (5星)
    - 关键亮点：思路清晰，先阐述初步想法，再通过具体数据指出误区，详细推导$b<0$时按$t + b$从大到小排序的原因，并给出完整且注释详细的代码。
    - 个人心得：提到这题82分卡了一个多小时，暗示在解题过程中遇到过问题并花费时间解决。
    - 重点代码及核心实现思想：
```cpp
// 定义结构体存储任务
struct node
{
    int tim;
    int b;
}a[100010];    //b大于0的任务
struct ss
{
    int tim;
    int b;
}f[100010];    //b小于等于0的任务
// 比较函数，b>0时按tim从小到大排序
int cmp(node &a,node &b)
{
    return a.tim<b.tim;
}
// 比较函数，b<0时按tim + b从大到小排序
int comp(ss &a,ss &b)
{
    return a.b+a.tim>b.b+b.tim;
}
int main()
{
    scanf("%d",&z);
    for(int i=1;i<=z;i++)
    {
        int s=0,cnt=0,num=0;
        scanf("%d%d",&n,&t);
        // 分类存储任务
        for(int j=1;j<=n;j++)
        {
        	int x,y;
        	scanf("%d%d",&x,&y);
        	if(y>0) a[++cnt].tim=x,a[cnt].b=y;
        	else f[++num].tim=x,f[num].b=y;
		}
        // 分别排序
        sort(a+1,a+cnt+1,cmp);
        sort(f+1,f+num+1,comp);
        // 依次处理b>0的任务
        for(int j=1;j<=cnt;j++)
        {
            if(t>a[j].tim) t+=a[j].b;
            else{
                s=1;
                break;
            }
		}
        // 依次处理b<0的任务
        for(int j=1;j<=num;j++)
        {
            if(t>f[j].tim) t+=f[j].b;
            else{
                s=1;
                break;
            }
            if(t<=0){
                s=1;
                break;
            }
        }
        // 根据结果输出
        if(s==0) printf("+1s\n");
        else printf("-1s\n");
    }
    return 0;
}
```
核心实现思想是先将任务按$b$的正负分类存储，再分别按特定规则排序，依次判断能否完成任务并根据结果输出。

  - 作者：风中の菜鸡 (4星)
    - 关键亮点：简洁清晰地阐述贪心思路，对$b>0$和$b<0$任务的排序依据给出详细不等式推导，虽未给出代码但思路完整。
    - 重点代码及核心实现思想：无代码，核心思想为将任务按$b$正负分类，$b>0$按$t$从小到大排序，$b<0$按$t + b$从大到小排序完成任务。

  - 作者：紊莫 (4星)
    - 关键亮点：详细讲解贪心思路和证明过程，对$b\le0$的任务采用临项交换方法证明贪心策略，逻辑严谨。
    - 重点代码及核心实现思想：无代码，核心思想同其他题解，先按$b$正负分类任务，$b>0$按$t$升序，$b\le0$按$t + b$降序排列后判断能否完成任务。

最优的关键思路或技巧：采用贪心策略，通过合理分组和特定排序方式，将复杂任务选择问题简化，利用不等式推导证明排序依据的正确性。

可拓展之处：同类型题通常涉及资源分配、任务调度等场景，可通过类似贪心策略解决，关键在于找到合适的排序依据和贪心选择标准。

推荐题目：
  - P1080 [NOIP2012 提高组] 国王游戏
  - P1199 [NOIP2010 普及组] 三国游戏
  - P1094 [NOIP2007 普及组] 纪念品分组 

---
处理用时：61.11秒
# 题目信息

# 语言普查

## 题目背景

Yugo国的人民在进行一次人口普查，由于Yugo国是典型的多民族国家，所以拥有许多种语言。


## 题目描述

“Kiaosmaonsnai Assi fi wais

"Kjamqosoaksi mais pas?"

"Oci! Asia olo mnai naso!"

"2333在说什么啊根本听不懂。。。”

这是Yugo国的日常。。。

Yugo国有许多不同的种族，这些不同的种族不同的语言，但是主席扔给了你几本字典，这样，你就知道他们在说什么语了。你的任务就是判断他们在说什么语并填上户口本（？）。


## 样例 #1

### 输入

```
4
Qzrian yy ghy qzr
Yugoslavian mihailova petrozavodsk saint-petersburg
Suissvia yugoslavia korse mais kohnin
Mohaian Jzm Wallace Zhangbaohua djh 

yy,qzr and ghy are i don't know
mihailova saZk amOmlio
mais c'est pas Ca
wallace is good
```

### 输出

```
Qzrian
Yugoslavian
Suissvia
Mohaian

```

# AI分析结果

• 综合分析与结论：
    - 思路：各题解思路一致，均是用映射（map 或 unordered_map）存储单词与语言的对应关系，读入文本后按规则分割单词，通过映射判断文本使用的语言。
    - 算法要点：核心在于准确按题目规则分割单词，处理单词的大小写，并正确建立和使用映射关系。
    - 解决难点：题目难点主要是复杂的输入格式和单词分割规则。如出现标点符号、换行、空格通常视为分隔符，但连接线、引号两端单词视为一个单词；输入格式存在数据点异常，如 n 未单独占一行、换行符不一致等。各题解通过不同方式处理这些难点，如使用 stringstream 处理输入、对字符串进行格式化处理等。

    评分：
    - 作者 w_____：5 星。思路清晰，代码简洁，通过自定义函数处理单词分割和字符转换，利用 stringstream 和 getline 处理输入，整体结构紧凑，可读性高。
    - 作者 hexuchen：4 星。详细列举了题目坑点，代码实现中规中矩，对每种情况处理较为详细，但代码稍显冗长。
    - 作者 rickyxrc：3 星。介绍了思路和坑点，但代码实现中读入部分较为繁琐，整体代码可读性一般。
    - 作者 yx666：4 星。通过函数式编程对字符串进行格式化处理，将分隔符替换为空格，简化单词分割过程，代码运行效率较高。
    - 作者 苏打青柠水：3 星。采用字典树实现，但代码为 Java 语言，且字典树实现相对复杂，对于本题使用字典树优势不明显。

  所选题解：
  - 作者 w_____：
    - 星级：5 星
    - 关键亮点：自定义 check 函数准确判断分隔符，convert 函数统一字符大小写。利用 stringstream 和 getline 结合处理复杂输入格式，代码简洁高效。
    - 重点代码：
```cpp
bool check(char c) {
    return!islower(c) &&!isupper(c) && c!= '\'' && c!= '-';
}

void convert(string &s) {
    for (auto &c : s)
        if (isupper(c))
            c += 'a' - 'A';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    map <string, string> mp;
    string s, a, b;
    getline(cin, s);
    stringstream ss(s);

    int n;
    ss >> n;
    while (n--) {
        getline(cin, s);
        s += ' ';
        a = "";
        int flag = 0;
        for (auto &c : s) {
            if (check(c)) {
                if (flag++ && b.size())
                    convert(b), mp[b] = a;
                b = "";
            } else {
                if (flag)
                    b += c;
                else
                    a += c;
            }
        }
    }
    getline(cin, s);
    while (getline(cin, s)) {
        s += ' ';
        a = "";
        for (auto &c: s) {
            if (check(c)) {
                convert(a);
                if (mp.count(a)) b = mp[a];
                a = "";
            } else {
                a += c;
            }
        }
        cout << b << '\n';
    }
    return 0;
}
```
    - 核心实现思想：通过 check 函数判断字符是否为分隔符，在读取每种语言及其单词时，根据分隔符分割单词并建立映射；读取文本时同样按分隔符分割单词，通过映射找到对应的语言并输出。

  - 作者 hexuchen：
    - 星级：4 星
    - 关键亮点：详细列举所有坑点，对每个坑点在代码中都有对应处理方式，代码注释详细，适合初学者理解。
    - 重点代码：
```cpp
int main(){
    getline(cin, s);
    stringstream ss(s); 
    ss>>n;
	for(int i=1;i<=n;i++){
		getline(cin,s); 
		s.erase(remove(s.begin(),s.end(),char(13)),s.end()); 
		bool flag=true; 
		string word="",kind; 
		for(int i=0;i<s.size();i++){
			if(s[i]=='.' || s[i]==',' || s[i]=='!' || s[i]=='?' || s[i]==';' || s[i]=='(' || s[i]=='(' || s[i]==' '){ 
				if(flag){ 
					flag=false;
					kind=word;
				}
				else{ 
					d[word]=kind;
				}
				word="";
			}
			else{
				if('A'<=s[i] && 'Z'>=s[i] &&!flag){ 
					word+=s[i]+32;
				}
				else{
					word+=s[i];
				}
				word.erase(remove(word.begin(),word.end(),char(13)),word.end()); 
			}
		}
		d[word]=kind;
	}
	getline(cin,s); 
	while(getline(cin,s)){ 
		string word=""; 
		bool flag=true;
		for(int i=0;i<s.size() && flag;i++){
			s.erase(remove(s.begin(),s.end(),char(13)),s.end());
			if(s[i]=='.' || s[i]==',' || s[i]=='!' || s[i]=='?' || s[i]==';' || s[i]=='(' || s[i]=='(' || s[i]==' '){
				if(d[word]!="" && word!=""){
					flag=false;
					cout<<d[word]<<endl; 
				}
				word="";
			}
			else{
				if('A'<=s[i] && 'Z'>=s[i]){
					word+=s[i]+32;
				}
				else{
					word+=s[i];
				}
				word.erase(remove(word.begin(),word.end(),char(13)),word.end());
			}
		}
		if(flag){ 
			cout<<d[word]<<endl;
		}
	}
	return 0; 
}
```
    - 核心实现思想：利用 stringstream 读取 n，对每种语言的输入行，按分隔符分割单词并建立单词与语言的映射。读取文本行时，同样按分隔符分割单词，通过映射判断语言并输出，同时处理了输入中可能存在的 \r 字符。

  - 作者 yx666：
    - 星级：4 星
    - 关键亮点：使用函数式编程对字符串进行格式化处理，将分隔符替换为空格，简化单词分割过程，利用 unordered_map 提高查找效率。
    - 重点代码：
```cpp
// 字符格式化
inline char check(char ch){
	switch (ch) {
	case '.':
	case ',':
	case '?':
	case '!':
	case ';':
	case '(':
	case '\n':
	case '\r':
	case ')':
		return ' ';
	default:
		return tolower(ch);
	}
}

// 字符串格式化
inline string cg(string&s){
	for(auto&it:s)
		it=check(it);
	return s;
}

signed main(){
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	
	cin>>n;
	string s,token;
	stringstream ss;
	for(int i=1;i<=n;++i){
		cin>>s;
		sample[i]=s;
		
		getline(cin,s);
		
		ss.clear();
		ss.str(cg(s));
		while(getline(ss,token,' ')){
			if(token.empty()) continue;
			mp[token]=i;
		}
	}
	
	while(cin.peek()=='\n'){
		getline(cin,s);
	}
	while(getline(cin,s)){
		ss.clear();
		ss.str(cg(s));
		while(getline(ss,token,' ')){
			if(mp.count(token)){
				cout<<sample[mp[token]]<<'\n';
				break;
			}
		}
	}
	return 0;
}
```
    - 核心实现思想：通过 check 函数将分隔符转换为空格并统一字符为小写，对每种语言输入行格式化后，用 stringstream 和 getline 按空格分割单词建立映射。对输入文本同样格式化后分割单词，通过映射判断语言并输出。

• 最优关键思路或技巧：
    - 字符串格式化：将复杂的分隔符统一处理为空格，简化单词分割逻辑，如 yx666 的题解中通过自定义函数实现。
    - 输入处理：使用 stringstream 处理复杂输入格式，如 n 未单独占一行等情况，多个题解都采用此方法。

• 拓展思路：同类型题通常涉及字符串处理、按特定规则解析文本、建立映射关系并查询。类似算法套路是先对输入字符串按规则预处理，再利用合适的数据结构（如 map、unordered_map）存储和查询信息。

• 推荐题目：
    - P1308 统计单词数：涉及字符串查找与统计，需按规则分割单词并判断。
    - P2000 拯救世界：字符串处理与匹配问题，类似本题按特定规则处理字符串。
    - P1055 ISBN 号码：对输入字符串按特定格式解析和校验，考察字符串处理能力。

• 个人心得摘录与总结：
    - hexuchen：详细列举了题目中多个坑点，如数据点中特殊字符显示异常、输入格式与题目描述不符、换行符不一致等，强调处理输入细节的重要性。总结为在处理复杂输入格式的字符串题目时，要仔细检查每个数据点可能出现的异常情况。 

---
处理用时：113.39秒
# 题目信息

# 国事访问

## 题目背景

这是战火纷飞的2333年，世界被分为XC联盟和WJ联盟，两个联盟互相开火。


## 题目描述

这是战火纷飞的2333年，世界被分为XC联盟和WJ联盟，两个联盟互相开火。Q国总统ZR想到Yugo国进行十分紧急的国事访问，但不能坐飞机，只能坐车。由于路上有许多不同的国家而且有些无政府国，所以有许多路是坏的。路没有从自己通向自己的（作死吗。。。）。你需要确定一条具体的路线，并且由于WJ联盟的人随时可能过来，你需要把这条路线经过的所有城市周围的其他路都毁掉。你是上帝视角，你需要帮助ZR总统到达Yugo，你可以毁掉一些原本是好的路，也可以把坏的路修好，但不能新修路。给你一份地图，地图上，ZR国坐落在1城，Yugo首都在n城。帮助ZR总统尽快到达Yugo，你可以获得ZR总统在WJ联邦银行的30亿存款和1000万人的军队，和ZR总统一起瓜分地球（以上是诈骗内容。。。）。


## 说明/提示

把 1 2 1 路径变成不可用

把 1 3 0 路径变成可用

把 2 3 1 路径变成不可用

即可

## 样例 #1

### 输入

```
4 4
1 2 1
1 3 0
2 3 1
3 4 1```

### 输出

```
3
```

# AI分析结果

• 综合分析与结论：这些题解的核心思路均为在求最短路的同时，通过合理设置边的费用来统计修改边状态的最小代价。算法要点在于根据边的初始状态（0或1）设置不同费用，如将0边费用设为1，1边费用设为 - 1，以满足题目中修路和毁路的要求。难点主要在于对题意的准确理解，部分题解作者因题意不清导致初次提交得分较低。各题解在实现上主要采用SPFA、Dijkstra、BFS等最短路算法，整体思路相近，质量差异主要体现在思路清晰度、代码可读性和优化程度上。

所选的题解：
 - 作者：天南月 (赞：7)
   - 星级：4星
   - 关键亮点：思路清晰，详细阐述了从误解题意到正确理解后的思路转变，代码注释详细。
   - 个人心得：“在看到这一道题的一开始，我对照样例和题目看了老久，以为出题人的意思是选择一条最短路，使得除了这条路径上的所有边，这条路上的其他点的其他出边都要被损毁，这样的话就是一个费用计算方式比较与众不同的最小费用最短路，为此我还推了1个小时费用计算公式。满怀信心的交上去，结果......20分?!仅过了样例！！！把数据点2下下来一看：原来不是路径上的经过点的出边，而是所有非最短路上的边都要求损毁！！！”总结了因题意理解偏差导致的错误。
```cpp
void Spfa(){
    memset(dis,0x3f,sizeof(dis));
    memset(cost,0x3f,sizeof(cost));
    queue<int>q;
    q.push(1);
    dis[1]=0;
    vis[n]=true;
    cost[1]=0;
    while(!q.empty()){
        int now=q.front();
        q.pop();
        vis[now]=false;
        for(int i=head[now],nxt;i;i=e[i].next){
            if(dis[nxt=e[i].to]>dis[now]+1){
                dis[nxt]=dis[now]+1;
                if(e[i].opt)cost[nxt]=cost[now]-1;
                else cost[nxt]=cost[now]+1;
                if(!vis[nxt])vis[nxt]=true,q.push(nxt);
            }
            else if(dis[nxt]==dis[now]+1){
                if(e[i].opt){
                    if(cost[nxt]>cost[now]-1){
                        cost[nxt]=cost[now]-1;
                        if(!vis[nxt])vis[nxt]=true,q.push(nxt);
                    }
                }
                else{
                    if(cost[nxt]>cost[now]+1){
                        cost[nxt]=cost[now]+1;
                        if(!vis[nxt])vis[nxt]=true,q.push(nxt);
                    }
                }
            }
        }
    }
}
```
核心实现思想：使用SPFA算法求最短路，在更新距离的同时，根据边的状态更新到达该点的最小费用。

 - 作者：mot1ve (赞：4)
   - 星级：4星
   - 关键亮点：思路阐述简洁明了，先强调确保距离最小前提下让花费尽可能小的核心思路，代码简洁且注释清晰。
```cpp
void spfa(int s)
{
    memset(dis,0x3f,sizeof(dis));
    memset(val,0x3f,sizeof(val));
    queue<int> q;
    q.push(s);
    vis[s]=1;
    dis[s]=0;
    val[s]=0;
    while(q.size())
    {
        int x=q.front();
        q.pop();
        vis[x]=0;
        for(int i=head[x];i;i=edge[i].nxt)
        {
            int y=edge[i].to;
            if(dis[x]+1<dis[y])
            {
                dis[y]=dis[x]+1;
                val[y]=val[x]+edge[i].w;
                if(!vis[y])
                {
                    q.push(y);
                    vis[y]=1;
                }
            }
            if(dis[x]+1==dis[y])
            {
                if(val[x]+edge[i].w<val[y])
                val[y]=val[x]+edge[i].w;
            } 
        }
    }
}
```
核心实现思想：同样使用SPFA算法，在更新最短路距离时，同步更新价值数组val，以记录最小花费。

 - 作者：WZKQWQ (赞：2)
   - 星级：4星
   - 关键亮点：以广搜为切入点，详细解释了边权设置的原因，对题意理解和转化的描述清晰。
```cpp
while(!q.empty()){
        int x = q.front();
        q.pop();
        for(int i = 0;i < e[x].size();i++){
            node tmp = e[x][i];
            if(dis[tmp.to] > dis[x] + 1){
                dis[tmp.to] = dis[x] + 1;
                num[tmp.to] = num[x] + tmp.p;
                q.push(tmp.to);
            }
            if(dis[tmp.to] == dis[x] + 1)
                if(num[tmp.to] > num[x] + tmp.p){
                    num[tmp.to] = num[x] + tmp.p;
                    q.push(tmp.to);
                }
        }
    }
```
核心实现思想：利用广搜求最短路，在更新距离的同时，根据边的价值更新从起点到该点的最小价值。

最优关键思路或技巧：将边根据初始状态设置不同费用（0边费用为1，1边费用为 - 1），在求最短路过程中同步统计最小费用，这样可以巧妙地解决修路和毁路的代价计算问题。同时，对于边权为1的图，使用BFS求最短路效率较高。

可拓展之处：此类题目属于图论中最短路结合费用统计的问题，类似套路是根据题目条件合理设置边权或点权，在最短路算法中同步更新其他信息。同类型题可考虑一些带限制条件的最短路问题，如限制经过点数、边的类型限制等。

推荐题目：
 - P1339 热浪：经典的单源最短路问题，可加深对最短路算法的理解。
 - P3371 【模板】单源最短路径（弱化版）：最短路模板题，用于巩固基础。
 - P4779 【模板】单源最短路径（标准版）：相比弱化版，数据范围更大，可考察对最短路算法的优化能力。 

---
处理用时：63.68秒
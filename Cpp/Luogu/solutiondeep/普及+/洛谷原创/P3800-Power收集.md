# 题目信息

# Power收集

## 题目背景

据说在红雾异变时，博丽灵梦单身前往红魔馆，用十分强硬的手段将事件解决了。

然而当时灵梦在 Power 达到 MAX 之前，不具有“上线收点”的能力，所以她想要知道她能收集多少 P 点，然而这个问题她答不上来，于是她找到了学 OI 的你。

## 题目描述

可以把游戏界面理解成一个 $N$ 行 $M$ 列的棋盘，有 $K$ 个格子上有 $P$ 点，其价值为 $\operatorname{val}(i,j)$。

初始灵梦可以选择在第一行的任意一个格子出发，每秒她必须下移一格。

灵梦具有一个左右移动的速度 $T$，可以使她每秒向左或右移动至多 $T$ 格，也可以不移动，并且不能折返。移动可视为瞬间完成，不经过路途上的点，只能获得目标格子的 P 点。

求最终她能获得的 POWER 值最大是多少？

## 说明/提示

对于 $40\%$ 的测试点，$1 \le N,M,T,K \le 200$。

对于 $100\%$ 的测试点，$1 \le N,M,T,K \le 4000$。

$v \le 100$，$N,M,K,T$ 均为整数。

by-szc

## 样例 #1

### 输入

```
3 3 4 1
1 1 3
1 2 1
2 2 3
3 3 3
```

### 输出

```
9```

# AI分析结果

这道题是在给定的矩阵中，从第一行出发，按特定移动规则获取最大价值，主要解题思路是动态规划（DP）结合单调队列优化。

### 各题解分析
1. **灵乌路空**：
    - **思路**：用DP，状态转移方程 `f[i][j] = max(f[i - 1][k]) + v[i][j] (k∈[j - T, j + T])`，用单调队列优化求 `max(f[i - 1][k])` 过程。
    - **算法要点**：将相邻两行单独考虑，利用单调队列维护滑动窗口内最大值。
    - **难点解决**：通过类比滑动窗口问题，明确单调队列维护方式。
    - **评分**：4星
    - **亮点**：思路清晰，结合图示说明，代码用手写数组模拟队列，常数小。
2. **xcxc82**：
    - **思路**：类似“琪露诺”题，设 `a[i][j]` 为点价值，`dp[i][j]` 为到该点最大价值，通过单调队列优化状态转移。
    - **算法要点**：用数组模拟队列，实现队列初始化、插入元素等功能辅助DP。
    - **难点解决**：通过图示展示滑动窗口求最值过程。
    - **评分**：3星
    - **亮点**：有详细思路分析和代码分析，配GIF展示过程。
3. **_edge_**：
    - **思路**：先爆搜、记忆化搜索，后转循环DP并用单调队列优化，还考虑内存优化及依赖 `k` 的复杂度优化。
    - **算法要点**：利用指针维护地图优化内存；将条件转化为二维偏序用树状数组优化到 `O(k log k)`。
    - **难点解决**：深入挖掘条件进行转化，采用多种优化方式。
    - **评分**：5星
    - **亮点**：优化全面深入，不仅时间还有内存，给出多种优化代码。
4. **Seanq**：
    - **思路**：指出部分题解初始化错误，提出40分暴力DP和100分单调队列或线段树维护思路，还提及类似“打鼹鼠”思路。
    - **算法要点**：按点更新思路，排序后判断点间可达性更新。
    - **难点解决**：通过分析错误案例强调初始化重要性。
    - **评分**：3星
    - **亮点**：强调初始化问题，提供多种解题思路方向。
5. **囧仙**：
    - **思路**：类似经典DP题，设 `dp[i][j]` 为到该点最大权值和，用单调队列优化转移。
    - **算法要点**：利用单调队列维护滑动窗口求最大值。
    - **难点解决**：明确单调队列在本题的应用方式。
    - **评分**：4星
    - **亮点**：思路清晰，代码简洁明了。
6. **szr666**：
    - **思路**：设 `dp[i][j]` 为到该点最大值，用单调队列优化转移。
    - **算法要点**：用循环队列节省空间，实现单调队列三个关键操作。
    - **难点解决**：详细阐述单调队列在本题的操作方式。
    - **评分**：3星
    - **亮点**：对单调队列优化原理阐述详细，介绍循环队列节省空间。
7. **comando**：
    - **思路**：提出朴素DP、单调队列优化和只考虑有权点的DP三种解法。
    - **算法要点**：对有权点排序后按条件更新最大权值。
    - **难点解决**：从数据特点出发，只关注有权点减少计算量。
    - **评分**：3星
    - **亮点**：提供多种解法思路，分析数据特点优化。
8. **Seg_Tree**：
    - **思路**：用 `dp[i][j]` 储存最大 `p` 值，通过单调队列优化，用STL双端队列实现。
    - **算法要点**：实现单调队列插入和查询操作辅助DP更新。
    - **难点解决**：详细解释单调队列在本题的操作逻辑。
    - **评分**：3星
    - **亮点**：用STL双端队列，思路清晰，对单调队列操作解释详细。
9. **y2823774827y**：
    - **思路**：用单调队列，两次进队列得到 `dp[i][j]`。
    - **算法要点**：按规则进队列实现单调队列优化DP。
    - **难点解决**：强调进队列的方式。
    - **评分**：3星
    - **亮点**：针对单调队列进队列操作有独特说明。
10. **s_a_b_e_r**：
    - **思路**：先暴力枚举超时，后按出题人思路对power点排序后枚举更新。
    - **算法要点**：结构体存储点信息并排序，按条件更新最大点数。
    - **难点解决**：参考出题人思路改变枚举方式。
    - **评分**：2星
    - **亮点**：给出暴力和参考出题人思路两种做法。
11. **Jerrycyx**：
    - **思路**：设 `f[i][j]` 为最大 POWER 值，用ST表处理静态RMQ问题优化转移。
    - **算法要点**：对每一行上一行建ST表，查询区间最大值更新。
    - **难点解决**：利用ST表优化求区间最大值过程。
    - **评分**：3星
    - **亮点**：提供用ST表优化的新思路。
12. **devout**：
    - **思路**：先DP后单调队列优化，再通过排序和二分查找优化空间。
    - **算法要点**：滚动数组优化 `f` 数组，二分查找判断点是否有权值。
    - **难点解决**：通过特定方法减少空间使用。
    - **评分**：3星
    - **亮点**：重点在空间优化，给出详细空间优化思路和代码。
13. **Dispwnl**：
    - **思路**：对power按横坐标排序，枚举点并根据横纵坐标关系更新最大值。
    - **算法要点**：按规则判断点间可达性更新最大权值。
    - **难点解决**：从点的关系出发更新权值。
    - **评分**：2星
    - **亮点**：思路简单直接。
14. **Priori_Incantatem**：
    - **思路**：设 `f[i][j]` 为最大权值，用单调队列维护区间最大值，用辅助数组保证移动规则。
    - **算法要点**：实现单调队列操作并结合辅助数组。
    - **难点解决**：用辅助数组满足移动限制条件。
    - **评分**：2星
    - **亮点**：考虑移动限制并通过辅助数组解决。
15. **wawcac**：
    - **思路**：提出类似经典题的DP思路，用单调队列或ST表优化，还提出类似“打鼹鼠”思路。
    - **算法要点**：按不同思路实现DP和优化。
    - **难点解决**：类比经典题找到优化方向。
    - **评分**：3星
    - **亮点**：提供多种思路并分析各思路复杂度等。
16. **pluszero**：
    - **思路**：先推出DP方程，后用单调队列优化。
    - **算法要点**：实现单调队列优化DP过程。
    - **难点解决**：利用单调队列优化求最大值过程。
    - **评分**：3星
    - **亮点**：思路和代码简单直接展示单调队列优化DP。
17. **嚯呀嚯呀**：
    - **思路**：推出DP公式，用单调队列优化找最大值过程。
    - **算法要点**：维护单调递减队列找最大值更新DP值。
    - **难点解决**：详细说明单调队列维护和使用方式。
    - **评分**：3星
    - **亮点**：对单调队列在本题的操作解释详细。
18. **zhaoyifan**：
    - **思路**：通过转移方程，对上一行建立单调队列优化。
    - **算法要点**：实现单调队列提前入队和超出范围出队操作。
    - **难点解决**：利用单调队列优化转移。
    - **评分**：3星
    - **亮点**：代码简单展示单调队列优化过程。

### 高质量题解
1. **_edge_** - 5星
    - **关键亮点**：优化全面，不仅有常见的单调队列时间优化，还深入进行内存优化，提出依赖 `k` 的复杂度优化并实现到 `O(k log k)`。
    - **核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define int long long
using namespace std;
const int INF=4005;
int n,m,k1,t,f[5][INF],q[INF],ql,qr;
struct _node_data {
        int x,y,z;
} a[INF];
bool cmp(_node_data xx,_node_data yy) {
        if (xx.x!=yy.x) return xx.x<yy.x;
        else return xx.y<yy.y;
}
signed main()
{
        scanf("%lld %lld %lld %lld",&n,&m,&k1,&t);
        for (int i=1; i<=k1; i++)  {
                int x=0,y=0,z=0;
                scanf("%lld %lld %lld",&x,&y,&z);
                a[i].x=x; a[i].y=y; a[i].z=z;
        }
        for (int i=1; i<=m; i++) f[0][i]=0;
        sort(a+1,a+1+k1,cmp); int ll=1;
        for (int i=1; i<=n; i++) {
                int u=(i&1),v=(i&1)^1;
                ql=1,qr=0; int rr=1;
                for (int j=1; j<=m; j++) {
                        int l=max(1ll,j-t),r=min(m,j+t);
                        while (ql<=qr && q[ql]<l) ql++;
                        for (int k=rr; k<=r; k++) {
                                while (ql<=qr && f[v][q[qr]]<=f[v][k]) qr--;
                                q[++qr]=k;
                        }
                        rr=r+1;
                        int Map1=0;
                        while (ll+1<=k1 && a[ll+1].y<=j && a[ll+1].x==i) ll++;
                        if (a[ll].x==i && a[ll].y==j) Map1=a[ll].z,ll++;
                        if (ql<=qr) f[u][j]=f[v][q[ql]]+Map1;
                }
        }
        int ans=0;
        for (int i=1; i<=m; i++)
                ans=max(ans,f[n&1][i]);
        cout<<ans<<"\n";
        return 0;
}
```
        - **核心思想**：先读入数据并排序，利用滚动数组 `f` 记录状态，通过单调队列维护滑动窗口内的最大值，在更新每一行每个位置时，根据单调队列得到上一行对应范围内最大值并加上当前点权值。
2. **灵乌路空** - 4星
    - **关键亮点**：思路清晰，结合图示详细解释题意和单调队列优化原理，代码使用手写数组模拟队列，常数吊打 `deque`。
    - **核心代码**：
```cpp
#include<cstdio>
#include<ctype.h>
#include<cstring>
#define int long long
#define max(a,b) a>b?a:b
const int MARX = 4e3+10;
int n,m,k,t, now,ans;
int f[MARX][MARX];
int head=1,tail=1;
int q[MARX]={9223372036854775807};
inline int read()
{
	int fl=1,w=0;char ch=getchar();
	while(!isdigit(ch) && ch!='-') ch=getchar();
	if(ch=='-') fl=-1;
	while(isdigit(ch)){w=w*10+ch-'0',ch=getchar();}
	return fl*w;
}
void in(int x)
{
	while(f[now-1][x]>f[now-1][q[tail]] && tail>=head) 
	  tail--;
	q[++tail]=x; 
}
int find(int x)
{
	if(x+t<=m)in(x+t);
	while(q[head]+t<x) head++;
	return q[head]; 
}
signed main()
{
	n=read(),m=read(),k=read(),t=read();
	while(k--)
	{
	  int x=read(),y=read(),w=read();
	  f[x][y]=w;
	}
	for(now=2;now<=n;now++)
	{
	  for(int i=1;i<=t;i++) in(i);
	  for(int j=1;j<=m;j++) f[now][j]+=f[now-1][find(j)];
	  head=tail=1, q[1]=0;
	}
	for(int i=1;i<=m;i++)
	  ans=max(ans,f[n][i]);
	printf("%lld",ans);
}
```
        - **核心思想**：通过 `read` 函数读入数据，`in` 函数向单调队列插入元素并维护单调性，`find` 函数查询元素并更新队列，在主函数中先读入数据初始化 `f` 数组，然后逐行通过单调队列更新 `f` 数组，最后找出最后一行的最大值。
3. **囧仙** - 4星
    - **关键亮点**：简洁清晰地阐述思路，类比经典入门题，代码实现简洁明了。
    - **核心代码**：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n,m,k,t;
int c[4005][4005];
int dp[4005][4005];

int h = 1,r = 1;
struct node{
	int id,val;
}que[4005];

void pop(int id){
	while(h!= r){
		if(que[h].id < id){
			h++;
		}else{
			return;
		}
	}
}

void push(int id,int val){
	while(h!= r){
		if(que[r - 1].val <= val){
			r--;
		}else{
			break;
		}
	}
	que[r++] = {id,val};
}

int main(){
	scanf("%d%d%d%d",&n,&m,&k,&t);
	for(int i = 1;i <= k;i++){
		int x,y,val;
		scanf("%d%d%d",&x,&y,&val);
		c[x][y] += val;
	}
	for(int i = 1;i <= n;i++){
		h = r = 1;
		for(int j = 1;j <= t;j++){
			push(j,dp[i - 1][j]);
		}
		for(int j = 1;j <= m;j++){
			pop(j - t);
			if(j + t <= m) push(j + t,dp[i - 1][j + t]);
			dp[i][j] = que[h].val + c[i][j];
		}
	}
	int ans = 0;
	for(int j = 1;j <= m;j++){
		ans = max(ans,dp[n][j]);
	}
	printf("%d\n",ans);
	return 0;
}
```
        - **核心思想**：通过 `push` 函数将元素按规则插入单调队列，`pop` 函数弹出不符合条件元素，在主函数中读入数据初始化 `c` 数组，逐行通过单调队列更新 `dp` 数组，最后找出最后一行的最大值。

### 最优关键思路技巧
1. **数据结构**：利用单调队列维护滑动窗口内的最大值，高效解决每次转移时在固定区间内求最大值的问题。
2. **算法优化**：在内存优化方面，通过滚动数组减少 `f` 数组空间使用，还可利用指针维护地图优化到仅依赖 `k` 的内存。在时间优化上，将条件转化为二维偏序问题，使用树状数组或CDQ分治优化到 `O(k log k)` 复杂度。
3. **思维方式**：从数据特点出发，如矩阵中大部分点权值为0，只考虑有权点进行计算，减少不必要计算量。

### 可拓展方向
同类型题通常是在矩阵或序列上，按特定移动规则获取最值

---
处理用时：167.14秒
# 题目信息

# 红色的幻想乡

## 题目背景

蕾米莉亚的红雾异变失败后，很不甘心。


## 题目描述

经过上次失败后，蕾米莉亚决定再次发动红雾异变，但为了防止被灵梦退治，她决定将红雾以奇怪的阵势释放。

我们将幻想乡看做是一个 $n \times m$的方格地区，一开始没有任何一个地区被红雾遮盖。蕾米莉亚每次站在某一个地区上，向东南西北四个方向各发出一条无限长的红雾，可以影响到整行/整列，但不会影响到她所站的那个地区。如果两阵红雾碰撞，则会因为密度过大而沉降消失。灵梦察觉到了这次异变，决定去解决它。但在解决之前，灵梦想要了解一片范围红雾的密度。可以简述为两种操作:

``1 x y`` 蕾米莉亚站在坐标 $(x,y)$ 的位置向四个方向释放无限长的红雾。

``2 x1 y1 x2 y2`` 询问左上点为$(x1,y1)$，右下点为 $(x2,y2)$ 的矩形范围内，被红雾遮盖的地区的数量。


## 说明/提示

#### 样例输入输出 1 解释

用``o``表示没有红雾，``x``表示有红雾，两次释放红雾后幻想乡地图如下:

```
oxox
xoxo
oxox
xoxo
```

---

#### 数据规模与约定

- 对于 $20\%$ 的数据，$1 \le n,m,q \le 200$。
- 对于 $40\%$ 的数据，$1 \le n,m,q \le 10^3$。
- 对于 $100\%$ 的数据，$1 \le n,m,q \le 10^5$，$1 \le x_1,x_2,x \le n$，$x_1 \le x_2$，$1 \le y_1,y_2,y \le m$，$y_1 \le y_2$。

## 样例 #1

### 输入

```
4 4 3
1 2 2
1 4 4
2 1 1 4 4
```

### 输出

```
8```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何将二维的红雾覆盖问题转化为一维问题求解。核心思路是利用容斥原理，通过维护行和列的红雾覆盖情况来计算矩形区域内红雾遮盖地区数量。算法要点在于使用线段树或树状数组实现单点修改和区间查询。难点在于理解容斥原理的推导及应用，以及如何用合适的数据结构高效维护数据。
• 所选的题解：
  - 作者：Hurricane、 (5星)
    - 关键亮点：思路清晰，通过图形展示帮助理解红雾抵消原理，简洁推导出计算红雾数量公式，代码实现简洁明了，还特别提醒数据范围易踩坑点。
    - 个人心得：无
    - 重点代码及核心思想：利用线段树实现单点修改和区间查询。`update`函数用于更新线段树节点值，`change`函数实现单点修改，`que`函数实现区间查询。在`main`函数中，根据操作类型分别调用修改和查询函数，并按公式计算输出结果。
```cpp
void update(int *a,int num){
    a[num]=a[num<<1]+a[num<<1|1];
    }
void change(int *a,int p,now){
    if(l==r){
        a[num]^=1;
        return;
        }
    int mid=l+r>>1;
    if(p<=mid)change(a,p,ls);
    else change(a,p,rs);
    update(a,num);
    }

int que(int *a,int al,int ar,now){
    if(al<=l&&r<=ar)
        return a[num];
    int mid=l+r>>1,ans=0;
    if(al<=mid)ans+=que(a,al,ar,ls);
    if(mid<ar)ans+=que(a,al,ar,rs);
    return ans;
    }
int main(){
    scanf("%d%d%d",&n,&m,&q);
    while(q--){
        int cmd;
        scanf("%d",&cmd);
        if(cmd==1){
            int x0,y0;
            scanf("%d%d",&x0,&y0);
            change(x,x0,1,n,1);
            change(y,y0,1,m,1);
            }
        else{
            scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
            long long xx=que(x,x1,x2,1,n,1),
                      yy=que(y,y1,y2,1,m,1);
            printf("%lld\n",xx*(long long)(y2-y1+1)+
                    yy*(long long)(x2-x1+1)-
                    (long long)(xx*yy<<1));
            }
        }
    return 0;
    }
```
  - 作者：C_Zn (4星)
    - 关键亮点：直接点明线段树 + 容斥原理解题，代码结构清晰，详细实现线段树的构建、修改和查询操作。
    - 个人心得：无
    - 重点代码及核心思想：定义两个线段树结构体`node`，分别维护行和列。`pushup`函数用于更新节点和，`build`函数构建线段树，`change`函数实现单点修改，`query`函数实现区间查询。在`main`函数中，根据操作类型调用相应函数，并按容斥原理公式计算输出。
```cpp
struct node
{
    int l,r;
    int sum;
}t1[100001<<6],t2[100001<<6];

void pushup1(int tr)
{
    t1[tr].sum=t1[tr<<1].sum+t1[tr<<1|1].sum;
    return;
}

void build1(int l,int r,int tr)
{
    t1[tr].l=l;
    t1[tr].r=r;
    if(l==r)
    {
        t1[tr].sum=0;
        return;
    }
    int mid=l+r>>1;
    build1(l,mid,tr<<1);
    build1(mid+1,r,tr<<1|1);
    pushup1(tr);
    return;
}

void change1(int l,int r,int tr)
{
    if(t1[tr].l==t1[tr].r)
    {
        t1[tr].sum^=1;
        return;
    }
    int mid=t1[tr].l+t1[tr].r>>1;
    if(l<=mid)change1(l,r,tr<<1);
    else change1(l,r,tr<<1|1);
    pushup1(tr);
    return;
} 

int query1(int l,int r,int tr)
{
    if(t1[tr].l>=l&&r>=t1[tr].r)
    {
        return t1[tr].sum;
    }
    int ret=0,mid=t1[tr].l+t1[tr].r>>1;
    if(l<=mid)ret+=query1(l,r,tr<<1); 
    if(mid<r)ret+=query1(l,r,tr<<1|1);
    return ret;
}
// 列的线段树操作与行类似
int main()
{
    long long n,m,q;
    cin>>n>>m>>q;
    build1(1,n,1);
    build2(1,m,1);
    for(int i=1;i<=q;i++)
    {
        int zb;
        scanf("%d",&zb);
        if(zb==1)
        {
            long long x,y;
            cin>>x>>y;
            change1(x,x,1);
            change2(y,y,1);
        }
        else
        {
            long long x1,x2,y1,y2;
            cin>>x1>>y1>>x2>>y2;
            long long a1,a2;
            a1=query1(x1,x2,1);
            a2=query2(y1,y2,1);
            cout<<a1*(long long)(y2-y1+1)+a2*(long long)(x2-x1+1)-(long long)(a1*a2<<1)<<endl;
        }
    }
}
```
  - 作者：Misaka_Mik0t0 (4星)
    - 关键亮点：提出用降维思想，使用树状数组解题，指出树状数组比线段树常数更低、更省空间、代码更短，并说明注意事项。
    - 个人心得：无
    - 重点代码及核心思想：用两个树状数组`treex`和`treey`分别维护列与行的红雾覆盖情况。`add`函数实现单点修改，`ask`函数实现区间查询。在`main`函数中，根据操作类型调用相应函数，并按容斥原理公式计算输出。
```cpp
void add(int *tree,RI s,RI num){
	RI ceil;
	if(tree==treex)ceil=n;
	else ceil=m;
	for(;s<=ceil;s+=lowbit(s))tree[s]+=num;
}
int ask(int *tree,RI s){
	RI res=0;
	for(;s;s-=lowbit(s))res+=tree[s];
	return res;
}
int main(){
	n=read();m=read();q=read();
	while(q--){
		RI op,x,y,x_,y_;
		op=read();x=read();y=read();
		if(op==1){
			if(mx[x]==false)mx[x]=true,add(treex,x,1);
			else mx[x]=false,add(treex,x,-1);
			if(my[y]==false)my[y]=true,add(treey,y,1);
			else my[y]=false,add(treey,y,-1);
		}
		else{
			x_=read();y_=read();
			long long xnum=ask(treex,x_)-ask(treex,x-1),xx=x_-x+1;
			long long ynum=ask(treey,y_)-ask(treey,y-1),yy=y_-y+1;
			printf("%lld\n",xnum*yy+ynum*xx-xnum*ynum*2);
		}
	}
	return 0;
} 
```
• 最优关键思路或技巧：将二维问题降维，通过两个一维数据结构（线段树或树状数组）分别维护行和列的红雾覆盖状态，利用容斥原理计算矩形区域内红雾遮盖地区数量。在实现时，注意单点修改操作（如使用异或改变状态）和区间查询的结合，以及数据范围导致的类型溢出问题。
• 可拓展之处：同类型题常涉及二维平面上的区域操作与查询，类似算法套路是将二维问题转化为一维，用数据结构维护行列信息，再结合容斥原理计算。例如处理矩形区域的染色、覆盖、统计等问题。
• 推荐题目：
  - P3372 【模板】线段树 1，基础的线段树单点修改和区间查询题目，帮助巩固线段树基础。
  - P3368 【模板】树状数组 2，用于熟悉树状数组的区间修改和单点查询操作。
  - P1972 [SDOI2009]HH的项链，结合了树状数组与离散化技巧，锻炼综合应用能力。
• 个人心得摘录与总结：无。 

---
处理用时：91.71秒
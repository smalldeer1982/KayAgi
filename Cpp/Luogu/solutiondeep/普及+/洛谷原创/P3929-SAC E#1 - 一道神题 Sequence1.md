# 题目信息

# SAC E#1 - 一道神题 Sequence1

## 题目背景

小强和阿米巴是好朋友。


## 题目描述

小强很喜欢数列。有一天，他心血来潮，写下了一个数列。

阿米巴也很喜欢数列。但是他只喜欢其中一种：波动数列。

一个长度为 $n$ 的波动数列满足对于任何 $i\ (1 \le i < n)$，均满足以下两个条件至少一个：

- $a_{2i-1} \le a_{2i}$ 且 $a_{2i} \ge a_{2i+1}$（若存在）。
- $a_{2i-1} \ge a_{2i}$ 且 $a_{2i} \le a_{2i+1}$（若存在）。

阿米巴把他的喜好告诉了小强。小强便打算稍作修改，以让这个数列成为波动数列。他想知道，能否通过仅修改一个数（或不修改），使得原数列变成波动数列。


## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$1\le n \le 10$。
- 对于另外 $30\%$ 的数据，$1\le m \le 1000$。
- 对于 $100\%$ 的数据，$1\le n \le 10^5$，$m \le 10^9$。

其中 $m = \max|a_i|$（数列中绝对值的最大值）


## 样例 #1

### 输入

```
5
1 2 3 2 1
5
1 2 3 4 5
```

### 输出

```
Yes
No```

# AI分析结果

### 综合分析与结论
所有题解思路核心均为利用波动序列只有两种形式这一特性，通过贪心策略，在遍历序列过程中，将不符合波动序列条件的元素修改为极大值（如`0x3f3f3f3f`）或极小值（如`-0x3f3f3f3f`），同时记录每种波动序列形式下的修改次数，最后判断两种修改次数中是否有小于2的情况，若有则输出“Yes”，否则输出“No”。时间复杂度均为O(n)，空间复杂度均为O(1)。区别主要在于代码实现的细节和表述清晰度。

### 所选题解
#### 作者：kkksc03 (赞：31)
- **星级**：5星
- **关键亮点**：思路阐述清晰，先介绍部分分做法（O(n^2)），再给出AC做法（O(n)），对波动序列的本质理解深刻，先分析出波动序列只有两种形式，进而将问题转化为求原序列变为每种波动序列的最小修改次数。
- **核心代码**：
```cpp
// 核心思路：遍历序列，判断元素是否符合波动序列要求，不符合则修改并计数
// 假设已经定义好输入输出及相关变量
for (int i = 2; i <= n; ++i) {
    int now;
    scanf("%d", &now);
    if ((i & 1) && now > pre1) {
        ++cnt1;
        pre1 = -0x3f3f3f3f;
    } else if ((i & 1 ^ 1) && now < pre1) {
        ++cnt1;
        pre1 = 0x3f3f3f3f;
    } else pre1 = now;
    if ((i & 1) && now < pre2) {
        ++cnt2;
        pre2 = 0x3f3f3f3f;
    } else if ((i & 1 ^ 1) && now > pre2) {
        ++cnt2;
        pre2 = -0x3f3f3f3f;
    } else pre2 = now;
}
if (cnt1 < 2 || cnt2 < 2) puts("Yes"); else puts("No");
```

#### 作者：mrsrz (赞：6)
- **星级**：4星
- **关键亮点**：代码简洁明了，直接通过位运算判断奇偶位置，在遍历过程中同时处理两种波动序列的修改计数，逻辑清晰。
- **核心代码**：
```cpp
// 核心思路：利用位运算判断位置奇偶，对两种波动序列分别计数修改次数
while (~scanf("%d", &n)) {
    int cnt1 = 0, pre1, pre2, cnt2 = 0;
    scanf("%d", &pre2);
    pre1 = pre2;
    for (int i = 2; i <= n; ++i) {
        int now;
        scanf("%d", &now);
        if ((i & 1) && now > pre1) {
            ++cnt1;
            pre1 = -0x3f3f3f3f;
        } else if ((i & 1 ^ 1) && now < pre1) {
            ++cnt1;
            pre1 = 0x3f3f3f3f;
        } else pre1 = now;
        if ((i & 1) && now < pre2) {
            ++cnt2;
            pre2 = 0x3f3f3f3f;
        } else if ((i & 1 ^ 1) && now > pre2) {
            ++cnt2;
            pre2 = -0x3f3f3f3f;
        } else pre2 = now;
    }
    if (cnt1 < 2 || cnt2 < 2) puts("Yes"); else puts("No");
}
```

#### 作者：Elegy_of_Green_Kite (赞：4)
- **星级**：4星
- **关键亮点**：通过类比简单的01交替序列问题，帮助读者理解本题思路，代码实现参考他人较好写法，逻辑清晰。
- **核心代码**：
```cpp
// 核心思路：类似上述做法，遍历判断并计数修改次数
while (~scanf("%d", &n)) {
    int cnt1 = 0, cnt2 = 0, pre1, pre2;
    scanf("%d", &pre2), pre1 = pre2;
    for (int i = 2; i <= n; ++i) {
        int now;
        scanf("%d", &now);
        if ((i & 1) && now > pre1)  cnt1++, pre1 = -inf;
        else if ((i & 1 ^ 1) && now < pre1)  cnt1++, pre1 = inf;
        else  pre1 = now;
        if ((i & 1) && now < pre2)  cnt2++, pre2 = inf;
        else if ((i & 1 ^ 1) && now > pre2)  cnt2++, pre2 = -inf;
        else  pre2 = now;
    }
    if (cnt1 < 2 || cnt2 < 2)  printf("Yes\n");
    else  printf("No\n");
}
```

### 最优关键思路或技巧
1. **利用波动序列特性**：波动序列只有两种形式，通过分别计算原序列转化为这两种波动序列的最小修改次数，简化问题。
2. **贪心策略**：将不符合条件的元素修改为极大值或极小值，这样能保证在满足后续元素条件的同时，达到最优修改次数。
3. **位运算优化**：使用位运算（如`i & 1`判断奇偶），在一定程度上简化代码并提高效率。

### 可拓展思路
同类型题通常围绕序列的特定性质展开，如判断序列能否通过有限次操作满足某种单调性或其他规律。类似算法套路是先分析目标序列的特性，确定可能的形式，再通过贪心、模拟等策略遍历原序列进行判断或修改。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法，与本题类似，通过特定策略处理序列以达到最优解。
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：同样是贪心思想的应用，根据题目条件对序列进行排序处理。
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)：利用贪心策略解决区间覆盖问题，与本题在思维方式上有相似之处。

### 个人心得摘录
无。 

---
处理用时：64.44秒
# 题目信息

# SAC E#1 - 一道难题 Tree

## 题目背景

冴月麟和魏潇承是好朋友。


## 题目描述

冴月麟为了守护幻想乡，而制造了幻想乡的倒影，将真实的幻想乡封印了。任何人都无法进入真实的幻想乡了，但是她给前来救她的魏潇承留了一个线索。

她设置了一棵树（有根）。树的每一条边上具有割掉该边的代价。

魏潇承需要计算出割开这棵树的最小代价，这就是冴月麟和魏潇承约定的小秘密。

帮帮魏潇承吧。


注：所谓割开一棵有根树，就是删除若干条边，使得任何任何叶子节点和根节点不连通。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，$n\le 10$；
- 对于 $50\%$ 的数据，$n \le 1000$；
- 对于 $100\%$ 的数据，$2\le n \le 100000$，且边权是不大于 $10^6$ 的非负整数。


## 样例 #1

### 输入

```
4 1
1 2 1 
1 3 1
1 4 1```

### 输出

```
3```

## 样例 #2

### 输入

```
4 1
1 2 3
2 3 1
3 4 2```

### 输出

```
1```

# AI分析结果

这道题主要求解割开有根树使叶子节点与根节点不连通的最小代价，题解涵盖DFS、树形DP和网络流等多种解法。
1. **思路与要点**
    - **DFS**：通过深度优先搜索遍历树，对每个节点，计算断开其子节点到根节点路径的最小代价。如遇到叶子节点，返回无穷大或到父节点的边权。
    - **树形DP**：定义状态表示以某节点为根的子树割边的最小价值，状态转移方程通常涉及比较割掉当前节点与父节点的连边，和在子节点中选择割边的代价。
    - **网络流**：将问题转化为最小割问题，通过建立网络流模型，如添加超级汇点，把叶子节点连接到该汇点，再跑最大流算法（如Dinic、EK）求解。
2. **难点**
    - **DFS和树形DP**：正确处理节点类型（叶子、枝节点、根节点），设计合理的递归或状态转移方式。
    - **网络流**：无向图到有向图的转换、确定源点和汇点、处理叶子节点与汇点的连接，以及理解最大流最小割定理在本题的应用。
3. **评分**
    - **_louhc_**：思路清晰，代码简短且注释详细，DFS解法直切要点。**5星**
    - **皎月半洒花**：提供独特思路，结合DFS序设计状态转移，复杂度分析详细。**4星**
    - **mrsrz**：树形DP思路表述简洁，代码清晰展示状态转移过程。**4星**
4. **最优思路技巧**：树形DP和DFS解法直接针对树结构进行处理，避免复杂的网络流建模。通过自底向上的递归或状态转移，利用树的父子关系计算最小割代价，简洁高效。
5. **拓展**：此类题目核心是图的连通性与最小代价问题，类似套路包括将实际问题转化为图论模型，利用树的特性简化算法。同类型题可涉及不同图结构（如仙人掌图、二分图）的最小割、连通性维护等。
6. **相似题目**
    - [P1361 小M的作物](https://www.luogu.com.cn/problem/P1361)
    - [P2762 太空飞行计划问题](https://www.luogu.com.cn/problem/P2762)
    - [P4016 负载平衡问题](https://www.luogu.com.cn/problem/P4016)
7. **个人心得**：部分题解提到网络流做法中，无向图转有向图及建图细节易错，需注意边的方向和权值设置；还有从不同角度思考问题，如尝试多种算法（DFS、DP、网络流）解决同一问题，开拓思路。

### 所选题解
- **_louhc_（5星）**
    - **关键亮点**：以简洁DFS解决问题，思路直接，代码简短且注释丰富。
    - **核心代码**
```cpp
LL DFS( int x, int fa ){
    LL ans(0); bool flg(0);
    for ( int i = hd[x]; i; i = nxt[i] )
        if ( to[i]!= fa ) ans += min( DFS( to[i], x ), val[i] ), flg = 1;
    if (!flg ) return LONG_LONG_MAX;
    return ans;
}
```
    - **核心思想**：递归计算每个节点的最小割代价，对非叶子节点，累加其子节点到根路径的最小割边权，叶子节点返回无穷大。
- **皎月半洒花（4星）**
    - **关键亮点**：借助DFS序设计独特的状态转移方程，详细分析复杂度。
    - **核心代码**
```cpp
void dfs(int u, int fr){
    bool fg = 1 ;
    dfn[u] = ++ Id, sz[u] = 1, fa[u] = fr ;
    for (int k = head[u] ; k ; k = next(k)){
        if (to(k) == fr) continue ;
        fg = 0, cost[to(k)] = val(k) ;
        dfs(to(k), u), sz[u] += sz[to(k)], ctn[u] += ctn[to(k)] ; 
    }
    if (fg) Ls[++ tot] = u, ctn[u] = 1 ;
}
int main(){
    cin >> N >> rt ; int i, j, u, v ;
    for (i = 1 ; i < N ; ++ i) 
        u = qr(), v = qr(), j = qr(), add(u, v, j) ; 
    dfs(rt, 0) ; 
    for (i = 1 ; i <= tot ; ++ i){
        int n = Ls[i], nid = dfn[n] ; 
        f[i] = f[i - 1] + cost[Ls[i]] ; 
        while (fa[n]){
            if (fa[n]!= rt && nid == dfn[fa[n]] + sz[fa[n]] - 1) 
                f[i] = min(f[i], f[i - ctn[fa[n]]] + cost[fa[n]]) ; 
            else break ;
            n = fa[n] ;
        }
    }
    cout << f[tot] << endl ; return 0 ;
}
```
    - **核心思想**：先通过DFS获取节点DFS序等信息，然后基于DFS序和子树叶子数量进行状态转移，计算割掉前i个叶子的最小代价。
- **mrsrz（4星）**
    - **关键亮点**：树形DP思路简洁明了，代码清晰体现状态转移。
    - **核心代码**
```cpp
void dfs(int u,int en,int fa){
    int sum=0;
    for(int i=head[u];i;i=e[i].nxt)
    if(e[i].to!=fa){
        dfs(e[i].to,i,u);
        sum+=dp[e[i].to];
    }
    dp[u]=e[en].dis;
    if(sum&&sum<dp[u])dp[u]=sum;
}
```
    - **核心思想**：递归计算以每个节点为根的子树割边价值，比较割掉当前节点与父节点连边和子节点割边价值之和，取较小值。 

---
处理用时：70.83秒
# 题目信息

# [MtOI2019] 灵梦的计算器

## 题目背景

**注: 该背景部分改编自 disangan233 中考前买计算器的真实事件。**  

博丽 灵梦 (Hakurei Reimu) 在成功抢回八云 紫 (Yakumo Yukari) 用隙间偷走的香火钱后，她和依神 紫苑 (Yorigami Shion) 去香霖堂买东西啦！  

灵梦想买一个计算器来计算神社的香火钱，但是因为香霖堂的东西太贵了，她选择使用河童重工网络 (Kawashiro Nitori's Network,KNN) 网购一个 Casio 计算器。

但出人意料的是，灵梦使用 KNN 买回来的 Casio 是个假货，最多只能显示整数部分（即向下取整）。   

灵梦很苦恼，因为这个计算器可能会导致一些特别大的误差。所以灵梦想让拥有外界的式神(指电脑)的你帮她解决一个问题。

## 题目描述

灵梦得到了3个实数 $n$ ，$a$ ，$b$ ( $4\le n\le 5,5 \le a,b \le 10$ ) ，她成功地计算了 $n^a+n^b$，得到了一个只显示整数部分的结果。  

灵梦想知道，若存在一个实数 $n'(n' \geq 0)$，使得 ${n'}^a+{n'}^b$ 的结果在计算器上与 $n^a+n^b$ 的结果显示出来**完全一致**时，$n'$ 的变化范围，即 $n'$ 的最大值与最小值之差。  

如果你不知道如何计算 $n^k$，请使用`cmath`库的`pow()`函数，`pow(n,k)`的结果即为 $n^k$ 的结果。    

---

为了提高本题的难度，灵梦给你设置了 $T$ 组询问。而为了在某种程度上减少你的输入和输出量，我们采用以下的代码来生成询问(代码来自河童重工)：  

~~~cpp
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#define uint unsigned int
	uint sd;int op;
	inline void init() {scanf("%u %d", &sd, &op);}
	inline uint uint_rand()
	{
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b)
	{
		n = get_n(); a = get_k();
		if (op) b = a;
		else b = get_k(); 
	}
}
~~~

在调用 `Mker::init()` 函数之后，你第 $i$ 次调用 `Mker::read(n,a,b)` 函数后得到的便是第 $i$ 次询问的 $n_i$, $a_i$ 和 $b_i$。     

为了减少你的输出量，令第 $i$ 次询问的答案为 $s_i$，你只需要输出 $\sum^{T}_{i=1} s_i$ 。如果你的答案与标准答案的绝对误差在 $10^{-2}$ 以内，你的答案则被视为是正确答案。

本题数据的生成采用时间复杂度**远远劣于**普通算法的高 (da) 精 (bao) 度 (li) 算法来保证精度，本题数据保证**单次询问的误差**小于 $10^{-10}$，**所以本题的SPJ范围对于正解来说是完全足够的。**

---

为了让你更好地做题，这里给出了关于 $op$ 的说明：   

* 当 $op=1$ 时，有 $a=b$，否则无特殊限定。  

## 说明/提示

### 子任务

![QQ图片20190707214000.png](https://i.loli.net/2019/07/07/5d21f64bc09c827059.png)


### 题目来源

[迷途之家2019联赛](https://www.luogu.org/contest/20135)(MtOI2019) T2

出题人：disangan233

验题人：suwakow


## 样例 #1

### 输入

```
500 233 0```

### 输出

```
0.00503```

## 样例 #2

### 输入

```
10000 3141592653 0```

### 输出

```
0.10166```

## 样例 #3

### 输入

```
50000 1314159 0```

### 输出

```
0.50722```

## 样例 #4

### 输入

```
50000 1314159 1```

### 输出

```
1.51676```

## 样例 #5

### 输入

```
1000000 5201314 0```

### 输出

```
10.30487```

# AI分析结果

• 综合分析与结论：
    - 这些题解主要围绕求满足\(\lfloor n^a + n^b \rfloor = \lfloor n'^a + n'^b \rfloor\)时\(n'\)的取值范围差值这一核心问题。
    - 思路上，部分题解采用枚举、二分等暴力或优化的搜索方法，期望获得部分分数；多数题解利用函数导数相关知识，将函数局部曲线近似看作直线，通过导数求斜率来计算\(n'\)的变化范围，以得到正解。
    - 算法要点在于对函数\(f(x) = x^a + x^b\)求导，得到\(f'(x) = ax^{a - 1} + bx^{b - 1}\)，再结合\(y\)值变化范围（\(\Delta y = 1\)）来计算\(x\)的变化范围\(\Delta x \approx \frac{\Delta y}{f'(x)}\)。
    - 解决难点在于如何处理函数曲线与直线近似的合理性，以及如何高效求解方程。不同方法在精度控制、时间复杂度优化等方面各有不同。

所选的题解：
  - **作者：RiverFun (赞：25)  星级：5星**
    - **关键亮点**：思路清晰，先通过几何画板模拟函数，直观展示函数特性，进而说明可将函数局部曲线近似为直线，利用导数求斜率得出答案，代码简洁明了。
    - **重点代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
namespace Mker {
#define uint unsigned int
	uint sd;
	int op;
	inline void init() {
		scanf("%u %d", &sd, &op);
	}
	inline uint uint_rand() {
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n() {
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k() {
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b) {
		n = get_n();
		a = get_k();
		if (op) b = a;
		else b = get_k();
	}
}
using namespace Mker;
int T;
double n, a, b, k, ans;
int main() {
	scanf("%d", &T);
	init();
	while (T--) {
		read(n, a, b);
		k = a * pow(n, a - 1) + b * pow(n, b - 1);
		ans += 0.9999999 / k;
	}
	printf("%0.5f", ans);
}
```
    - **核心实现思想**：利用给定数据范围，将函数\(f(x)\)在相关区间的曲线近似为直线，通过求\(f(x)\)在\(n\)处的导数\(f'(n)\)作为直线斜率，根据\(\Delta x \approx \frac{\Delta y}{f'(n)}\)（这里\(\Delta y\)取接近1的值）计算每次询问的结果并累加，最后输出总和。

  - **作者：disangan233 (赞：16)  星级：5星**
    - **关键亮点**：全面列举多种解法，从暴力枚举到二分优化，再到牛顿迭代法和利用微分近似等正解思路，对不同解法的时间复杂度、期望得分有详细分析，能让读者全面了解本题的求解角度。
    - **重点代码（Sol 6）**：
```cpp
int main()
{
    long long t, seed, op;
    cin >> t >> seed >> op;
    double n, a, b, ans = 0;
    if (op) {
        while (t--) {
            Mker::read(n, a, b);
            ans += 0.5 / (a * pow(n, a - 1));
        }
    }
    else {
        while (t--) {
            Mker::read(n, a, b);
            ans += 1 / (a * pow(n, a - 1) + b * pow(n, b - 1));
        }
    }
    cout << ans;
    return 0;
}
```
    - **核心实现思想**：对于\(a = b\)和\(a \neq b\)的情况分别讨论。利用函数\(f(x)\)单调递增的性质，通过分析\(g(x)=bx^k\)逼近\(f(x)\)时\(\Delta y = 1\)对应的\(\Delta x\)很小这一特点，使用微分近似公式\(\Delta x \approx \frac{\mathrm dy}{f'(x)}\)，计算出\(\Delta n'\)的表达式，进而求解。

  - **作者：lzkAK2009 (赞：2)  星级：4星**
    - **关键亮点**：简洁清晰地阐述题意和思路，直接利用导数公式求出\(f(n)\)的导数，结合\(y\)的变化范围，通过微分快速得出\(n\)的变化范围，代码实现简洁明了。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
double n,a,b,ans;
int t;
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#define uint unsigned int
	uint sd;int op;
	inline void init() {scanf("%u %d", &sd, &op);}
	inline uint uint_rand()
	{
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b)
	{
		n = get_n(); a = get_k();
		if (op) b = a;
		else b = get_k(); 
	}
}
using namespace Mker;
int main(){
	scanf("%d",&t);
	init();
	for(int i=1;i<=t;i++){
		read(n,a,b);
		ans+=1.0/(a*pow(n,a-1)+b*pow(n,b-1));
	}
	printf("%.5lf",ans);
	return 0;
}
```
    - **核心实现思想**：根据函数\(y = f(n)\)求出导数\(f'(n)\)，已知\(\Delta y = 1\)，利用微分公式\(\Delta y\approx dy=f'(n)\Delta n\)得出\(\Delta n\)的表达式，对每次询问结果累加并输出。

最优关键思路或技巧：利用函数在给定数据范围内增长速度快，曲线在题目精度要求内可近似为直线这一特性，通过对函数\(f(x) = x^a + x^b\)求导，结合\(y\)值变化范围（\(\Delta y = 1\)），利用微分近似公式\(\Delta x \approx \frac{\Delta y}{f'(x)}\)高效求解\(n'\)的变化范围。

可拓展之处：同类型题可能涉及不同函数形式，同样需分析函数性质（单调性、凹凸性等），利用导数、微分等知识解决关于函数值取整相等时自变量的变化范围问题。类似算法套路如在一些几何问题中，对于复杂曲线在局部范围内近似为直线进行计算。

推荐题目：
  - [P1498 南蛮图腾](https://www.luogu.com.cn/problem/P1498)：涉及递归与图形规律，与本题类似在于需要分析问题规律并通过代码实现。
  - [P2196 挖地雷](https://www.luogu.com.cn/problem/P2196)：考查动态规划，在分析问题和寻找最优解思路上与本题有相似之处。
  - [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：通过找规律递推求解，锻炼分析问题和算法设计能力，与本题分析函数特性求解有类似思维过程。

个人心得摘录与总结：
  - **作者：Doveqise**：从二分答案开始尝试，逐步尝试牛顿迭代法，在迭代次数、精度控制、卡常等方面不断调试优化，最终AC。总结出在做题时要多尝试不同方法，并且注意细节优化，如函数调用对时间复杂度的影响。
  - **作者：zzy2333**：先用二分法求解得到部分分数，后尝试牛顿迭代法，在优化过程中发现初始值设置、pow函数效率等对结果有影响，通过优化这些细节最终AC。强调了做题时要注意算法复杂度，同时关注代码实现中函数的效率问题。 

---
处理用时：95.71秒
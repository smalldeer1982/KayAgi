# 题目信息

# 移花接木

## 题目背景


遥远的圣地生长着一棵不为人知的灵树，或有万山之高。

但有一日，藏匿于根系的腐朽力量爆发，灵树已无法支撑往日屹立冲天的高度。

## 题目描述

灵树最初的形态可以看作一棵高度为 ${10}^{{10}^{{10}^{10}}}$ 的满 $a$ 叉树，高度定义为根结点到叶子结点之间的边数。

受腐朽力量影响，灵树只能维持高度**恰好**为 $h$ 的满 $b$ 叉树形态。为了转换至该形态，灵树有两种魔法：

- 移花：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点），移除这条边以及以 $v$ 为根的**整棵子树**。
- 接木：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点）和一个结点 $w$（$w$ 不能是 $v$ 子树中或已移除的结点），将这条边原先 $u$ 一端**改接**到 $w$。**该魔法只能在根结点到** $\boldsymbol{u}$ **之间的边数** $\le 10^{10^{10}}$ **时使用。**

灵树累积的魔法力量有限，它不得不用最少次数的魔法完成转换。这是个漫长的过程，即使次数最少也会显得异常大，你只需要求出最少次数对 $10^9 + 7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**

下为 $a=1$，$b=2$，$h=1$ 时的两步转换过程，图中高度极大的冗余子树已用省略号代替。

![](https://cdn.luogu.com.cn/upload/image_hosting/p32s9v96.png)

可以证明，该数据的答案不可能低于 $2$。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (3 points)：$h = 0$。
- Subtask #2 (4 points)：$a = b$。
- Subtask #3 (8 points)：$a = 1$。
- Subtask #4 (8 points)：$b = 1$。
- Subtask #5 (17 points)：$h \le 10$。
- Subtask #6 (15 points)：$h \le 10^6$，各测试点存在 $\overline{a},\overline{b}$，其数据满足 $a=\overline{a}$，$b=\overline{b}$。
- Subtask #7 (15 points)：$h \le 10^6$。
- Subtask #8 (30 points)：无特殊限制。

所有测试点（样例除外）均含有 $10^6$ 组数据，即 $T = 10^6$。请务必采用较快的 IO（输入/输出）方式。

对于所有的数据，保证 $1 \le a,b \le 10^9$，$0 \le h \le 10^9$。

## 样例 #1

### 输入

```
2
1 2 1
3 2 1
```

### 输出

```
2
7
```

# AI分析结果

### 综合分析与结论
这些题解均围绕将满\(a\)叉树转化为高度为\(h\)的满\(b\)叉树的最少操作次数问题，通过分类讨论\(a\)与\(b\)的大小关系求解。思路上，先对特殊情况（\(h = 0\)、\(a = b\)、\(a = 1\)、\(b = 1\)）进行分析得出结论，再针对\(a > b\)和\(a < b\)一般情况分别推导操作次数公式。算法要点在于利用快速幂计算幂次，部分涉及等比数列求和及逆元求解。解决难点主要是通过合理分析每一层的操作，推导通用公式，并注意\(b = 1\)时的特判。

### 所选的题解
1. **作者：AsunderSquall（5星）**
    - **关键亮点**：思路清晰，对每个子任务（Subtask）分别详细分析，结合图形辅助理解，公式推导过程完整，代码简洁且注释清晰。
    - **个人心得**：提到推出式子后被卡常的调试经历，虽未详述解决方法，但给读者敲响优化代码的警钟。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
#define rd(x) x=read()
using namespace std;
const int mod=1e9+7;
inline int read(){int x=0,f=1;char ch=getchar();while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
int ksm(int x,int y,int z){int ret=1;while (y){if (y&1) ret=(ret*x)%z;x=(x*x)%z;y>>=1;}return ret;}
int INV(int x){return ksm(x,mod-2,mod);}
int a,b,h;
int T;
signed main()
{
    rd(T);
    while (T--)
    {
        rd(a);rd(b);rd(h);
        if (b==1) cout<<(((a-1)*h+a)%mod);else
		if (a<=b) cout<<ksm(b,h,mod)*a%mod;
        else cout<<(a*ksm(b,h,mod)%mod+(ksm(b,h,mod)-1)*(a-b)%mod*INV(b-1)%mod)%mod;
        putchar('\n');
    }
}
```
核心实现思想：通过`read`函数快速读入数据，`ksm`函数实现快速幂计算，根据不同条件（\(b == 1\)、\(a <= b\)、\(a > b\)）分别计算并输出结果。
2. **作者：AuCloud（4星）**
    - **关键亮点**：通过画图和详细的柿子推导，逐步得出各情况下的答案，过程详细，易于理解，代码虽未全贴，但关键部分展示清晰。
    - **重点代码（关键部分）**：
```cpp
int ksm(int x, int mi)
{
    int ret = 1;
    while(mi)
    {
        if(mi & 1) ret = ret * x % mo;
        x = x * x % mo;
        mi >>= 1;
    }
    return ret;
}
// h==0
if(h == 0) printf("%lld\n", a % mo);
// a==b
else if(a == b)
{
    printf("%lld\n", ksm(a, h + 1));
}
// a==1
else if(a == 1)
{
    printf("%lld\n", ksm(b, h));
}
// b==1
else if(b == 1)
{
    printf("%lld\n", (a - 1) * (h + 1) % mo + 1);
}
// a < b
if(a < b)
{
    printf("%lld\n", a * ksm(b, h) % mo);
}
// a > b
else if(a > b)
{
    int ans = (ksm(b, h) - 1 + mo) % mo * ksm(b - 1, mo - 2) % mo * (a - b) % mo;
    ans = (ans + ksm(b, h) * a) % mo;
    printf("%lld\n", ans);
}
```
核心实现思想：`ksm`函数实现快速幂，针对不同条件（\(h == 0\)、\(a == b\)、\(a == 1\)、\(b == 1\)、\(a < b\)、\(a > b\)）分别计算并输出最少操作次数。
3. **作者：y0y68（4星）**
    - **关键亮点**：简洁明了地阐述前置知识和大致思路，通过图形辅助说明，核心代码部分给出逆元和等比数列求和的实现，整体逻辑连贯。
    - **重点代码**：
```cpp
inline ll ny(ll x){//逆元
    return qpow(x,mod-2);
}
inline ll db(ll x,ll y){//等比数列求和，即求x^0+x^1+⋯+x^y
    if(x==1)return y+1;//特判
    return (x*(qpow(x,y)-1)%mod*ny(x-1)%mod+1)%mod;
}

if(a>b)out((a*qpow(b,h)%mod+db(b,h-1)*(a-b)%mod)%mod);
else out(a*qpow(b,h)%mod);
```
核心实现思想：`ny`函数利用快速幂求逆元，`db`函数实现等比数列求和并处理\(x = 1\)的特判，根据\(a\)与\(b\)的大小关系计算并输出结果。

### 最优关键思路或技巧
1. **分类讨论**：根据\(a\)与\(b\)的大小关系进行分类，分别分析每种情况下树的变换操作，使问题简化。
2. **合理利用树的结构特点**：分析每一层节点的操作，如\(a > b\)时计算每层需删除的多余子树数量，\(a < b\)时计算每层需补充的子树数量。
3. **数学知识运用**：利用等比数列求和公式简化计算，通过快速幂和逆元优化计算过程。

### 可拓展思路
此类题目可拓展到不同类型树的转换，或增加操作限制等。类似算法套路是先分析特殊情况，再针对一般情况根据条件分类讨论，结合树的结构和数学知识推导公式。

### 相似知识点洛谷题目
1. **P1226 【模板】快速幂||取余运算**：基础的快速幂运算题目，可巩固快速幂知识点。
2. **P3390 【模板】矩阵快速幂**：在矩阵运算中运用快速幂，提升对快速幂应用场景的理解。
3. **P2144 [FJOI2007]轮状病毒**：涉及递推数列和数学推导，与本题分析过程和数学运用有相似之处。 

---
处理用时：76.48秒
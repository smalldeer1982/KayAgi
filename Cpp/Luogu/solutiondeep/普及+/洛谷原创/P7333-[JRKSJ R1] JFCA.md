# 题目信息

# [JRKSJ R1] JFCA

## 题目描述

给出一个环，上面有 $n$ 个点，每个相邻的点对之间的距离为 $1$。

每个点有两个属性 $a_i$ 和 $b_i$，对于点 $i$，定义 $f_i$ 为它与满足 $a_j\ge b_i$ 的最近的点 $j$ 与 $i$ 在环上距离较短一边的长度，其中 $i\ne j$。如果没有满足条件的 $j$，其 $f_i=-1$。

## 说明/提示

对于 $20\%$ 的数据，$1\le n \le 10^3$；\
对于 $100\%$ 的数据，$1\le n \le 10^5$，$1\le a_i,b_i\le 10^9$。

我们对于测试点 $4$ 至 $11$ 采用捆绑测试。

#### 样例 1 解释
对于 $i=1$，$a_3=3= b_1=3$, $1$ 和 $3$ 的距离是 $1$，所以 $f_1=1$。\
对于 $i=2$，$a_3=3> b_2=2$, $2$ 和 $3$ 的距离是 $1$，所以 $f_2=1$。\
对于 $i=3$，$a_2=2> b_3=1$, $2$ 和 $3$ 的距离是 $1$，所以 $f_3=1$。

$\text{upd2021.3.30}$：增加一组 hack 数据，卡掉了@[wu0615](https://www.luogu.com.cn/user/133037) 的提交。



## 样例 #1

### 输入

```
3
1 2 3
3 2 1```

### 输出

```
1 1 1```

## 样例 #2

### 输入

```
5
5 4 3 5 6
7 6 5 4 3```

### 输出

```
-1 2 1 1 1```

## 样例 #3

### 输入

```
5
1 1 2 1 1
2 2 2 2 2```

### 输出

```
2 1 -1 1 2```

# AI分析结果

• 综合分析与结论：
    - 思路方面：大部分题解针对 $100\%$ 数据，利用二分查找与维护区间最大值的思路。由于数据范围为 $1\leq n\leq 10^5$，$O(n^2)$ 暴力不可行，需优化。通过观察发现，随着区间扩大，区间内 $a$ 的最大值非严格单调递增，满足二分单调性条件。同时，为处理环结构，普遍采用断环为链的方法，一般开三倍空间存储数据以避免数组越界。
    - 算法要点：用 ST 表维护区间最大值，实现 $O(1)$ 查询，结合二分查找距离，时间复杂度为 $O(n\log n)$。少数题解采用单调栈和优先队列优化暴力、分块等方法，但主流是二分 + ST 表。
    - 解决难点：主要难点在于处理环结构以及优化查找满足条件点的复杂度。断环为链解决环结构问题，利用区间最大值单调性进行二分查找优化复杂度。

    - 整体来看，多数题解围绕二分和 ST 表展开，核心思路较为统一。

• 所选的题解：
  - 作者cyffff (5星)
    - 关键亮点：思路清晰，先介绍暴力做法及适用范围，再详细阐述二分 + ST 表的正解思路，包括断环为链原因、二分方式及 ST 表使用，代码简洁且注释详细。
    - 重点代码及核心实现思想：
```cpp
// 用ST表预处理区间最大值
for(int i=1;i<=ln;i++){
    for(int j=1;j+(1<<i)-1<=n+n+n;j++){
        st[j][i]=max(st[j][i-1],st[j+(1<<i-1)][i-1]);
    }
}
// 二分查找满足条件的最近距离
inline int ef(int x,int i){
    int l=1,r=n;
    while(l<r){
        int mid=l+r>>1;
        if(max(query(i-mid,i-1),query(i+1,i+mid))>=x){
            r=mid;
        }else{
            l=mid+1;
        }
    }
    return l==n?-1:l;
}
```
核心思想是先利用 ST 表预处理出所有区间的最大值，然后通过二分查找满足 $a_j\geq b_i$ 的最近距离。

  - 作者Durancer (4星)
    - 关键亮点：详细阐述思路，从劣弧查找范围、寻找最小长度方法，到利用区间最大值单调性和 ST 表维护，逐步推导，对二分易错点有详细说明。
    - 重点代码及核心实现思想：
```cpp
// RMQ函数用于查询区间最大值
int RMQ(int l,int r){
    int k=Log[r-l+1];
    return max(Max[l][k],Max[r-(1ll<<k)+1][k]);
}
// 二分查找左右两侧满足条件的最近距离
void erfen()
{
    int len=n/2;
    for(int i=n+1;i<=n+n;i++)
    {
        int ans=0x3f3f3f3f;
        if(RMQ(i-len,i-1)>=b[i]){
            int l=i-len;
            int r=i-1;
            while(l<=r)
            {
                int mid=(l+r)>>1;
                int cal=RMQ(mid,i-1);
                if(cal>=b[i]){
                    ans=min(ans,i-mid);
                    l=mid+1;
                }
                else r=mid-1;
            }
        }
        if(RMQ(i+1,i+len)>=b[i]){
            int l=i+1;
            int r=i+len;
            while(l<=r)
            {
                int mid=(l+r)>>1;
                int cal=RMQ(i+1,mid);
                if(cal>=b[i]){
                    ans=min(ans,mid-i);
                    r=mid-1;
                }
                else l=mid+1; 
            }
        }
        if(ans!=0x3f3f3f3f)
            printf("%d ",ans);
        else printf("-1 ");
    }
}
```
核心是通过 RMQ 函数查询区间最大值，在二分查找中，分别在左右两侧寻找满足条件的最近点，记录最小距离。

  - 作者Light_Star_RPmax_AFO (4星)
    - 关键亮点：思路连贯，从数据范围出发想到二分，阐述利用 ST 表保证二分单调性及断环为链原因，代码结构清晰。
    - 重点代码及核心实现思想：
```cpp
// 初始化ST表
void init(){
    for(int i = 2;i <= 3 * n;i++)
        LOG2[i] = LOG2[i >> 1] + 1; 
    for(int i = 1;i <= n;i++)
        st[i][0] = st[i + n][0] = st[i + n + n][0] = a[i];
    int k = LOG2[3 * n];
    for(int i = 1;i <= k;i++)
        for(int j = 1;j + (1 << i) - 1 <= 3 * n;j++){
            st[j][i] = max(st[j][i - 1],st[j + (1 << i - 1)][i - 1]); 
        }    
}    
// 二分查找满足条件的最近距离
int two(int x,int y){
    int l = 1,r = n;
    while(l < r){
        int mid = (l + r) >> 1;
        if(max(num(y - mid,y - 1),num(y + 1,y + mid)) >= x)
            r = mid;
        else
            l = mid + 1;
    }
    return l == n? -1 : l;
} 
```
先通过 init 函数初始化 ST 表，然后 two 函数二分查找满足 $a_j\geq b_i$ 的最近距离，若遍历一圈未找到则返回 -1。

• 最优关键思路或技巧：
    - **数据结构**：使用 ST 表维护静态区间最大值，能在 $O(1)$ 时间内查询区间最大值，为二分查找提供高效支持。
    - **算法优化**：利用区间最大值随区间扩大非严格单调递增的性质，进行二分查找，将查找满足条件点的时间复杂度从 $O(n)$ 优化到 $O(\log n)$，整体时间复杂度达到 $O(n\log n)$。
    - **思维方式**：将环结构转化为链结构，通过开三倍空间存储数据，简化问题处理，避免数组越界等问题。

• 可拓展之处：
同类型题常考察对环形数据结构的处理以及利用数据单调性进行优化。类似算法套路是遇到环形问题考虑断环为链，对于查找满足某种条件的最近元素问题，分析是否存在单调性，若存在则可结合合适的数据结构（如 ST 表、线段树等）进行二分查找优化。

• 推荐题目：
    - [P3865 【模板】ST 表](https://www.luogu.com.cn/problem/P3865)：基础 ST 表模板题，用于熟练掌握 ST 表的构建和查询操作。
    - [P1816 忠诚](https://www.luogu.com.cn/problem/P1816)：结合 ST 表和其他算法思想解决实际问题，可加深对 ST 表应用的理解。
    - [P2880 [USACO07MAR]Face The Right Way G](https://www.luogu.com.cn/problem/P2880)：涉及到数据单调性分析和优化，与本题利用单调性进行二分查找思路类似。

• 个人心得摘录与总结：
  - 作者Durancer提到二分查找时要注意区间不能包含自身点 $i$，否则会出现错误，这是在实现过程中容易忽略的细节，提醒在处理类似问题时要严格按照题目条件编写代码。 

---
处理用时：91.91秒
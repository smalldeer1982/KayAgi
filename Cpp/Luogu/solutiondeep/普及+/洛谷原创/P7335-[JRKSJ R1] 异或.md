# 题目信息

# [JRKSJ R1] 异或

## 题目描述

给你 $n,k$ 和序列 $a_{1,2\dots n}$，选出 $k$ 个**不交**区间 $[l_i,r_i]\subseteq[1,n]$，求出
$$\max_{l_i,r_i}\sum_{i=1}^k\bigoplus_{j=l_i}^{r_i}a_j$$

式中 $\oplus$ 表示二进制异或运算。

**保证数据随机。**

## 说明/提示

对于 $100\%$ 的数据，$1\le k\le n\le 3000$，$0\le a_i\le 10^{9}$。**保证数据随机。**

本题采用捆绑测试。

| $\text{Subtask}$ | $n\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $30$ | $k\le3$ | $5$ |
| $2$ | $500$ | $a_i\le10^7$|  $10$ |
| $3$ | $1000$ | 无 |  $10$ |
| $4$ | $1500$ | 无 |  $15$ |
| $5$ | $2000$ | 无 |  $15$ |
| $6$ | $2500$ | 无 | $20$ |
| $7$ | $3000$ |  无|  $25$ |
#### 样例 1 解释
序列的三个区间分别为:
$$2,1,[3,4],[4],[4]$$
所得的三个区间的异或和之和为 $7+4+4=15$.

## 样例 #1

### 输入

```
6 3
2 1 3 4 4 4```

### 输出

```
15```

## 样例 #2

### 输入

```
7 2
3 4 5 6 7 8 9```

### 输出

```
24```

# AI分析结果

• 综合分析与结论：
    - 这些题解均围绕动态规划（DP）展开。基本思路是通过定义状态来表示前i个数选j个区间的最大异或和，转移方程涉及到枚举区间端点并结合区间内最大异或和。
    - 算法要点在于处理前缀异或和以将区间异或和转化为两个数的异或和，以及针对数据随机的特点进行优化。
    - 解决难点主要是优化DP转移的时间复杂度，不同题解采用了不同的优化策略，如利用数据随机时某些值连续相同的特性进行压缩处理，或限制转移枚举范围等。
    - 整体来看，各题解质量参差不齐，部分题解思路和代码较清晰，部分稍显简略或代码可读性欠佳。

所选的题解：
  - **作者：cyffff (5星)**
    - **关键亮点**：思路清晰，对每个子任务分别阐述解法，从暴力到优化逐步深入。利用01Trie树高效处理异或问题，通过打表观察到数据随机时某些值的特性，进而压缩相同值区间优化复杂度，给出详细的复杂度分析和代码实现。
    - **重点代码**：
```cpp
struct trie{//01-Trie
    int cnt;
    int son[90005][2];
    trie(){
        cnt=1;
    }
    void clear(){
        for(int i=1;i<=cnt;i++){
            son[i][0]=son[i][1]=0;
        }
        cnt=1;
    }
    void insert(int x){
        int rt=1;
        for(int i=29;i>=0;i--) {
            if(!son[rt][(x>>i)&1])
                son[rt][(x>>i)&1]=++cnt;
            rt=son[rt][(x>>i)&1];
        }
    }
    int find(int x){
        int rt=1,ans=0;
        for(int i=29;i>=0;i--){
            if(son[rt][!((x>>i)&1)]) rt=son[rt][!((x>>i)&1)],ans+=1<<i;
            else rt=son[rt][(x>>i)&1];
        }
        return ans;
    }
}t;
```
核心实现思想：构建01Trie树，insert函数用于插入数，find函数用于在树中查找与给定数异或值最大的数。
```cpp
void init(){//预处理ans
    for(int i=0;i<=n;i++){
        t.clear();
        t.insert(a[i]);
        ans[i].init(i);
        for(int j=i+1;j<=n;j++){
            int now=t.find(a[j]);
            ans[i].insert(j,max(ans[i].top(),t.find(a[j])));
            t.insert(a[j]);
        }
    }    
}
```
核心实现思想：对每个位置i，通过01Trie树预处理出i到后续位置j的最大异或值，并压缩相同值区间。
```cpp
for(int d=k-1;d;d--){//dp
    int s=d&1;//滚动数组优化
    for(int l=n;l>=0;l--){
        ll mx=0;
        int r=1;
        mx=ans[l][r]+dp[l][!s];
        for(r++;r<=ans[l].len;r++){
            if(dp[ans[l].s[r].l][!s]+ans[l].top()<mx) break;//剪枝
            mx=max(mx,dp[ans[l].s[r].l][!s]+ans[l][r]);
        }
        dp[l][s]=mx;
    }
}
```
核心实现思想：利用滚动数组进行动态规划转移，在转移过程中通过剪枝优化计算。
  - **作者：hegm (4星)**
    - **关键亮点**：思路直接，先给出暴力DP思路，再针对数据随机时mx数组有连续相同值的特点进行压缩优化，代码简洁明了，注释详细，对空间优化也有提及。
    - **重点代码**：
```cpp
for(int i=1;i<=n;i++)
{
    for(int j=i-1,p=0;j>=0;j--)
    {
        if((a[i]^a[j])>p)p=(a[i]^a[j]);
        mx[j][i]=max(mx[j][i-1],p);
    }
}
```
核心实现思想：从后向前枚举，计算每个区间i到j的最大异或值mx[j][i]。
```cpp
for(int i=1;i<=n;i++)
{
    s[i][1].l=0;s[i][1].r=0;
    s[i][1].w=mx[0][i];num[i]=1;
    for(int j=1;j<i;j++)
    {
        if(mx[j][i]==mx[j-1][i])s[i][num[i]].r++;
        else 
        {
            s[i][++num[i]].l=j;
            s[i][num[i]].r=j;
            s[i][num[i]].w=mx[j][i];
        }
    }
}
```
核心实现思想：压缩mx数组中相同值的区间。
```cpp
for(int j=1;j<=k;j++)
{
    for(int i=1;i<=n;i++)
    {
        f[i][j%2]=0;
        for(int x=1;x<=num[i];x++)
        {
            f[i][j%2]=max(f[i][j%2],f[s[i][x].r][(j%2)^1]+s[i][x].w);
        }
    }
}
```
核心实现思想：利用滚动数组进行动态规划转移，在转移中利用压缩后的mx数组计算最大异或和。
  - **作者：tribool4_in (4星)**
    - **关键亮点**：先给出常规DP思路及求区间内最大异或和的方法，通过打表发现数据随机时f数组的特性，利用其连续相同值区间进行优化，代码逻辑清晰。
    - **重点代码**：
```cpp
for (int i = 1; i <= n; i++) {
    int x = 0;
    for (int j = i - 1; j >= 0; j--) {
        x = max(x, s[i] ^ s[j]);
        mx[j + 1][i] = max(mx[j + 1][i - 1], x);
    }
}
```
核心实现思想：通过倒序枚举计算每个区间内的最大异或值mx[j + 1][i]。
```cpp
for (int i = 1, r; i <= n; i++) {
    r = i;
    for (int j = i - 1; j >= 1; j--)
        if (mx[j][i]!= mx[j + 1][i]) v[i].emplace_back(j + 1, r), r = j;
    v[i].emplace_back(1, r);
}
```
核心实现思想：预处理出mx数组中相同值的连续区间。
```cpp
for (int p = 1; p <= k; p++) {
    for (int i = 1; i <= n; i++) {
        for (auto [l, r] : v[i]) dp[i][p & 1] = max(dp[i][p & 1], dp[r - 1][p & 1 ^ 1] + mx[r][i]);
    }
}
```
核心实现思想：利用滚动数组结合预处理的连续区间进行动态规划转移。

最优关键思路或技巧：利用数据随机的特性，观察到某些数组（如mx、f等）存在大量连续相同值的区间，通过压缩这些区间来减少动态规划转移过程中的计算量，从而优化时间复杂度。同时，利用前缀异或和将区间异或和问题转化为两个数的异或和问题，部分题解还借助01Trie树高效处理异或问题。

可拓展之处：同类型题可涉及更多关于区间选择并计算特定运算结果的最大化或最小化问题，类似算法套路包括利用数据特性进行优化，如数据随机时某些值的分布特点，以及通过数据结构（如Trie树）优化特定运算。

推荐洛谷题目：
  - P3859 [TJOI2008]彩灯：涉及区间操作和异或运算，与本题在异或运算处理上有相似之处。
  - P4551 最长异或值路径：同样是关于异或值的问题，不过场景是在树上，可拓展对异或问题的处理能力。
  - P1450 [HAOI2008] 硬币购物：与本题类似，需要通过动态规划解决问题，且在优化过程中也可利用数据特点。

个人心得：无。 

---
处理用时：83.65秒
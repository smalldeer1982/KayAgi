# 题目信息

# 「Wdsr-2.5」琪露诺的算数游戏

## 题目描述

#### 游戏概况

《琪露诺的算数游戏》（诨名“⑨牌”），是一款轻松快乐的多玩家卡牌回合制游戏。

**注意：这里的规则与市面上的⑨牌规则不尽相同**。由于⑨牌种类太多不大容易处理，所以这里的规则更类似于 $\text{NEU}$ 游戏。

游戏中有 $n$ 名玩家，围成一圈。一共会进行 $m$ 轮。每个玩家初始时有 $3$ 张手牌。游戏有一个 $k$ 张牌的牌堆。在本题中，你可以认为**不会出现牌堆抽完的情况**（真的）。此外，根据该题给出的规则，你不需要考虑选手手牌的顺序。

为了简述游戏规则，你可以认为每一轮游戏中有一个整型变量（类似于 $\text{int}$ 类型寄存器） $p$ 。玩家打出的牌本质上是对 $p$ 进行操作。

**注**：请注意下文中“局”、“轮”、“回合”的关系。本题你只会进行一局游戏，每局有 $m$ 轮，每一轮会有若干回合，每一回合会有一名玩家出牌。

每一轮开始时，$p$ 会被初始化为 $0$ ，然后从初始玩家开始，按照**顺时针顺序**（$1,2,3,\cdots n-1,n,1,2,\cdots$ ，逆时针同理），依次出牌。如果这是第一轮，那么初始玩家就是 $1$ 号玩家。当某个玩家出完某张牌后，如果此时 $p> 99$ ，视作该玩家成为该局的**失败者**；否则她就会**立刻从牌堆顶部取出一张牌**并进入到下一回合。失败者会丢失手上其余的两张牌，并从牌堆顶部依次摸三张牌放入自己的手牌中。同时，失败者会成为**下一轮初始玩家**。在一局游戏当中，牌堆里的牌只减不增。被使用的牌不会回到牌堆当中。

下面介绍该魔改版游戏的牌型。

#### 基本牌

基本牌可以分为五类：加法牌、减法牌、乘法牌、除法牌、固定牌。

- 加法牌，一共有 $7$ 种： $A_{1},A_{2},A_{5},A_{9},A_{19},A_{49},A_{99}$ 。其中， $A_x$ 的作用效果是，使 $p$ 加上牌面上的数字。即 $p\gets p+x$ 。  
- 减法牌，一共有 $3$ 种： $B_{1},B_{9},B_{19}$ 。作用效果与加法牌类似，只不过会使 $p$ 减去牌面上的数字。  
- 乘法牌，一共只有 $1$ 种： $C_2$ 。它的作用效果是令 $p$ 乘上对应的数字，即 $p\gets p\times x$ 。  
- 除法牌，同样只有 $1$ 种： $D_2$ 。会令 $p$ 除以对应的数字，**向下取整**。即 $p\gets \lfloor p\div x\rfloor$ 。  
- 固定牌，一共有 $3$ 种： $E_{0},E_{49},E_{99}$ ，会将 $p$ 直接设置为牌面上的数字。

#### 解牌

解牌是可以使一名玩家跳过该回合，并附加一些特殊效果的一类牌。

- $\tt{PASS}$ ，跳过你，转到下一个玩家。
- $\tt{TURN}$ ，跳过你，出牌顺序反转（顺时针变为逆时针，逆时针变为顺时针。在下一轮游戏开始时会重置为顺时针）。
- $\tt{DOUBLE}$ ，跳过你，然后给下一名玩家施加 $\verb!"DOUBLE"!$ 效果，也即要出两张牌（先打一摸一，再打一摸一，需要保持全程总数不超过 $99$ 才能保证不失败）。

$\tt{DOUBLE}$ 效果的一些说明：如果你被施加了 $\tt{DOUBLE}$ 的效果，但是你第一张出了解牌（三种解牌都可以），那么你就会立即解除 $\tt{DOUBLE}$ 效果，跳过这一回合，**并且将效果转移到下一名玩家**。 $\tt{DOUBLE}$ 效果不能叠加。

--- 

在输入文件中，卡牌名会形如 $\colorbox{#f0f0f0}\verb!A1 A99 D2 PASS DOUBLE!$ 等等。

#### 策略

这一部分将会讲述本题中所有玩家的运行逻辑。

如果无论怎么出都会失败，那么玩家就会随便打出一张牌并成为失败者（显然，打出哪张牌不会对游戏结局产生实质上的影响）。否则会有两种情形：

1. 如果此时没有被施加 $\tt{DOUBLE}$ 效果：
   - 每名玩家会优先考虑普通牌，并且选择在不成为失败者的前提下使 $p$ 变得**尽可能大**的那种方案（如果有多种方案可以使得 $p$ 最大，那就会按照**乘法牌、加法牌、减法牌、除法牌、固定牌**的顺序优先选择。显然，同一类普通牌中的不同种类的牌不会使 $p$ 产生相同的值）。
   - 如果没有普通牌，或者出牌后会成为失败者，那么就考虑使用解牌。玩家会依次考虑手头是否有 $\tt{PASS,TURN,DOUBLE}$ 牌。如果有，就打出这张牌。
2. 如果被施加了 $\tt{DOUBLE}$ 效果：
   - 优先考虑使用解牌。依次考虑$\tt{PASS,TURN,DOUBLE}$ 。如果有，就打出这张牌。
   - 否则，选择在不成为失败者的前提下使 $p$ 变得**尽可能小**的那种方案（如果有多种方案可以使得 $p$ 最小，那就会按照**除法牌、减法牌、加法牌、乘法牌、固定牌**的顺序优先选择）。此时玩家会被解除 $\tt{DOUBLE}$ 状态，于是她会按照情形 $1$ 来决策。

## 说明/提示

#### 样例 1 说明

牌的使用情况都在输出样例中。这里仅说明每出一张牌后每名玩家当前手牌的情况。具体为什么要使用某张牌，可以参考题目描述。

$$
\def{\c}#1{\texttt{#1}}
\def\arraystretch{1.5}
\begin{matrix}
\begin{gathered}
\textbf{\textsf{初始}}\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{B9} & \c{A99} & \c{PASS} \cr\hline
\text{Cirno} & \c{C2} & \c{D2} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\textbf{\textsf{第一回合}}\quad (p: 0\to 99)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{B9} & \c{E49} & \c{PASS} \cr\hline
\text{Cirno} & \c{C2} & \c{D2} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\textbf{\textsf{第二回合}}\quad (p:99\to 49)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{B9} & \c{E49} & \c{PASS} \cr\hline
\text{Cirno} & \c{C2} & \c{DOUBLE} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\textbf{\textsf{第三回合}}\quad (p:49\to 49)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{B9} & \c{PASS} & \c{PASS} \cr\hline
\text{Cirno} & \c{C2} & \c{DOUBLE} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\end{gathered}
&
\begin{gathered}
\textbf{\textsf{第四回合}}\quad (p:49\to 98)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{B9} & \c{PASS} & \c{PASS} \cr\hline
\text{Cirno} & \c{A19} & \c{DOUBLE} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\textbf{\textsf{第五回合}}\quad (p:98\to 89)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{A49} & \c{PASS} & \c{PASS} \cr\hline
\text{Cirno} & \c{A19} & \c{DOUBLE} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\textbf{\textsf{第六回合}}\quad (p:89\to 89)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{A49} & \c{PASS} & \c{PASS} \cr\hline
\text{Cirno} & \c{A19} & \c{A99} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\textbf{\textsf{第七回合}}\quad (p:89\to 89)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{A49} & \c{A99} & \c{PASS} \cr\hline
\text{Cirno} & \c{A19} & \c{A99} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\end{gathered}
\end{matrix}
$$

**注**：初始回合以及第 $2,4,6$ 回合都是 $\text{JoesSR}$ 出牌；第 $1,3,5,7$ 回合都是琪露诺出牌。值得注意的是，尽管第 $5$ 回合琪露诺使用了 $\tt{DOUBLE}$ ，但因为下一回合被 $\tt{PASS}$ 了，所以第 $7$ 回合仍然是琪露诺出牌。

此时琪露诺无论如何都会失败，于是琪露诺成为了失败者。

#### 样例 3

见下发附件。

#### 数据规模与约定

- 对于 $30\%$ 的数据，仅包含普通牌，并且 $n\le 3$ 。
- 对于另外 $15\%$ 的数据，不包含 $\tt{TURN}$ 牌和 $\tt{PASS}$ 牌。
- 对于另外 $15\%$ 的数据，不包含 $\tt{DOUBLE}$ 牌。
- 对于 $100\%$ 的数据， 满足 $1\le n\le 30;1\le m\le 100;1\le k\le 3\times 10^5$ 。保证任何时候 $|p|<10^4$ 。

#### 参考资料

[【东方桌游考古】NEU，“⑨牌”，与十年前的同人](https://www.bilibili.com/read/cv9951620)

## 样例 #1

### 输入

```
2 1 10
JoesSR B9 A99 PASS
Cirno C2 D2 A49
E49 DOUBLE PASS A19 A49 A99 A99 A99 A99 A99  ```

### 输出

```
Round 1:
JoesSR used A99,now p=99.
Cirno used D2,now p=49.
JoesSR used E49,now p=49.
Cirno used C2,now p=98.
JoesSR used B9,now p=89.
Cirno used DOUBLE,now p=89.
JoesSR used PASS,now p=89.
Cirno lost the game.```

## 样例 #2

### 输入

```
3 2 25
Cirno A9 A19 B1
Reimu TURN A9 C2
Marisa DOUBLE D2 D2
A9 B9 C2 PASS PASS A9 A1 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99
```

### 输出

```
Round 1:
Cirno used A19,now p=19.
Reimu used C2,now p=38.
Marisa used D2,now p=19.
Cirno used A9,now p=28.
Reimu used A9,now p=37.
Marisa used C2,now p=74.
Cirno used A9,now p=83.
Reimu used B9,now p=74.
Marisa used A9,now p=83.
Cirno used A1,now p=84.
Reimu used PASS,now p=84.
Marisa used D2,now p=42.
Cirno used B1,now p=41.
Reimu used TURN,now p=41.
Cirno used PASS,now p=41.
Marisa used DOUBLE,now p=41.
Reimu lost the game.
Round 2:
Reimu used A99,now p=99.
Marisa lost the game.
```

# AI分析结果

这是一道关于《琪露诺的算数游戏》的C++模拟题，核心在于模拟游戏中玩家的出牌过程及相关规则。各题解思路、要点及难点对比如下：
1. **思路**：均围绕模拟游戏流程展开，根据玩家状态（是否有DOUBLE效果）和手牌类型（普通牌或解牌），按特定优先级出牌，判断每轮游戏的失败者。
2. **算法要点**：存储玩家手牌、牌堆信息，实现出牌操作及效果计算，按规则判断失败者并更新状态。
3. **解决难点**：处理负数下取整、DOUBLE效果传递、出牌顺序改变等细节，确保模拟的准确性。

各题解评分如下：
1. **囧仙**：5星。思路清晰，将牌型操作映射为数学表达式，利用map存储和处理数据，代码结构合理，逻辑严谨。
2. **2011FYCCCTA**：4星。定义结构体存储卡牌信息，详细分析各种卡牌操作及策略，代码实现详细但稍显冗长。
3. **0tAp**：3星。代码实现模拟过程，但部分代码逻辑较复杂，可读性稍差。
4. **ppllxx_9G**：4星。暴力模拟思路，分别处理普通牌和解牌，通过预处理优先级简化判断过程，代码注释详细。
5. **NaOH_Frog**：4星。将正常和“被施加double”状态的出牌顺序分别处理，通过排序选择合适手牌，代码注释丰富。
6. **hbhz_zcy**：3星。使用数组和结构体设计数据结构，代码压行严重，可读性欠佳。
7. **Ratio_Y**：3星。对两种出牌策略分别排序模拟，代码较长，部分逻辑可进一步优化。

### 推荐题解
1. **囧仙**：5星。关键亮点在于将普通牌操作统一表示为$p \gets \left\lfloor p\cdot a + b\right\rfloor$的形式，利用map进行高效映射，使代码简洁且逻辑清晰。
```cpp
// 映射牌型到操作的参数
g("A1",1, 1);g("A2", 1, 2);g("A5",1, 5);g("A9",1, 9);g("A19",1, 19);
g("A49",1,49);g("A99", 1,99);g("B1",1,-1);g("B9",1,-9);g("B19",1,-19);
g("C2",2, 0);g("D2",.5, 0);g("E0",0, 0);g("E49",0,49);g("E99",0, 99);

// 删除手牌函数
bool del(string c){
    if(!H[o][c]) return 0;
    cout<<N[o]<<" used "<<c<<",now p="<<p<<".\n",--H[o][c],H[o][K[++kk]]++;
    return 1;
}

// 使用普通牌函数
bool useA(bool v){
    int W[5],r,t,y,w=v?-INF:INF; string F[5],s; fill(W,W+5,w); bool e=1;
    for(auto x:H[o]) if((s=x.first)!=TR&&s!=DB&&s!=PS&&x.second){
        t=s[0]-'A',y=floor(M[s].first*p+1e-9+M[s].second);
        if(y<h&&(v?y>W[t]:y<W[t])) W[t]=y,F[t]=s,e=0;
    }
    // 根据v选择使p最大或最小的牌
    if(v){
        if(W[MUL]>w) w=W[MUL],r=MUL; if(W[ADD]>w) w=W[ADD],r=ADD;
        if(W[MIN]>w) w=W[MIN],r=MIN; if(W[DIV]>w) w=W[DIV],r=DIV;
        if(W[SET]>w) w=W[SET],r=SET;
    }
    else{
        if(W[DIV]<w) w=W[DIV],r=DIV; if(W[MIN]<w) w=W[MIN],r=MIN;
        if(W[ADD]<w) w=W[ADD],r=ADD; if(W[MUL]<w) w=W[MUL],r=MUL;
        if(W[SET]<w) w=W[SET],r=SET;
    }
    if(e) return 0; p=w,del(F[r]),f=0; return 1;
}

// 使用解牌函数
bool useB(){
    if(del(PS)) return 1; if(del(TR)) {d=-d; return 1;} if(del(DB)) {f=1;return 1;}
    return 0;
}
```
核心实现思想：通过`map`将牌型映射到操作参数，在`useA`函数中根据是否要使`p`最大或最小，遍历手牌找到合适的普通牌；`useB`函数按顺序判断并使用解牌。`del`函数负责删除手牌并从牌堆取牌。
2. **2011FYCCCTA**：4星。关键亮点是定义结构体全面存储卡牌信息，详细处理每种卡牌效果及策略，对负数下取整处理有详细注释。
```cpp
// 存储卡牌的结构体
struct Card
{
    string all, type;
    int x;
};

// 处理卡牌
pair<string, int> processCard(string c)
{
    pair<string, int> pc;
    if (c[c.length() - 1] >= '0' && c[c.length() - 1] <= '9')
    {
        int num = 0;
        for (int k = 1; k < c.length(); k++) num = num * 10 + (c[k] - '0');
        pc = make_pair(c.substr(0, 1), num); 
    }
    else pc = make_pair(c, -1);
    return pc;
}

// 得到使用1张普通牌后p的值
int getChange(Card c)
{
    int np = p;
    if (c.type == "A") np += c.x;
    else if (c.type == "B") np -= c.x;
    else if (c.type == "C") np *= c.x;
    else if (c.type == "D")
    {
        if (np % 2 == 0) np /= c.x;
        else
        {
            if (np >= 0) np /= c.x;
            else np = np / c.x - 1;
        }
    }
    else np = c.x;
    return np;
}

// 出牌
void outCard(int pn, int cn)
{
    if (pc[pn][cn].x > -1)
        p = getChange(pc[pn][cn]);
    else
    {
        if (pc[now][cn].type == "PASS");
        else if (pc[now][cn].type == "TURN") dir =!dir;
        else
        {
            if (!dir) d = (now + 1) % n;
            else d = (now - 1 + n) % n;
        }
    }
    cout << t2[pn] << " used " << pc[pn][cn].all << ",now p=" << p << '.' << endl;
    pc[pn][cn] = h.front();
    h.pop();
    return;
}
```
核心实现思想：通过`processCard`函数将输入的卡牌字符串处理为结构体`Card`，`getChange`函数计算使用普通牌后`p`的值，`outCard`函数根据卡牌类型执行操作并更新`p`、输出信息及从牌堆取牌。
3. **ppllxx_9G**：4星。关键亮点是暴力模拟思路清晰，通过预处理优先级map简化出牌优先级判断，多函数实现各功能模块，结构清晰。
```cpp
// 注意优先级 
map<char, int> mp[2] = {{{'C', 1}, {'A', 2}, {'B', 3}, {'D', 4}, {'E', 5}}, { {'D', 1}, {'B', 2}, {'A', 3}, {'C', 4}, {'E', 5}}};

// 计算使用牌后的p值
int cal(int x, string c)
{
    int len = c.length(), tmp = 0;
    if (len == 2) tmp = c[1] - 48;
    else tmp = (c[1] - 48) * 10 + c[2] - 48;
    if (c[0] == 'A') return x + tmp;
    else if (c[0] == 'B') return x - tmp;
    else if (c[0] == 'C') return x * 2;
    else if (c[0] == 'D' && c[1]!= 'O') return x >>= 1;
    else if (c[0] == 'E') return tmp; 
    else return 10000000;
}

// 查找解牌
bool jd(int i)
{
    for (int j = 0; j < 3; j++) if (a[i].c[j] == "PASS")
    {
        cout << a[i].name << " used " << a[i].c[j] << ",now p=" << p << ".\n";
        a[i].c[j] = d[++now]; return 1;    
    }
    for (int j = 0; j < 3; j++) if (a[i].c[j] == "TURN")
    {
        cout << a[i].name << " used " << a[i].c[j] << ",now p=" << p << ".\n";
        a[i].c[j] = d[++now];fl *= -1; return 1;            
    }    
    for (int j = 0; j < 3; j++) if (a[i].c[j] == "DOUBLE")
    {
        cout << a[i].name << " used " << a[i].c[j] << ",now p=" << p << ".\n";
        a[i].c[j] = d[++now]; dou = 1; return 1;
    }
    return 0;
}

// 选择普通牌
pair<int, int> work(int i, bool op)
{
    int tm, id;
    if (op == 0)
    {
        tm = -1e9, id = -1;
        for (int j = 0; j < 3; j++)
        {
            int tmp = cal(p, a[i].c[j]);
            if (tmp > 99) continue;
            else if (tmp > tm) tm = tmp, id = j;
            else if (tmp == tm)
            {
                if (mp[op][a[i].c[id][0]] > mp[op][a[i].c[j][0]]) id = j;
            }
        }        
    }
    else
    {
        tm = 1e9, id = -1;
        for (int j = 0; j < 3; j++)
        {
            int tmp = cal(p, a[i].c[j]);
            if (tmp > 99) continue;
            else if (tmp < tm) tm = tmp, id = j;
            else if (tmp == tm)
            {
                if (mp[op][a[i].c[id][0]] > mp[op][a[i].c[j][0]]) id = j; 
            }
        }        
    }
    return make_pair(tm, id);
}
```
核心实现思想：`mp`存储不同状态下出牌优先级，`cal`函数计算使用牌后`p`值，`jd`函数按顺序查找解牌，`work`函数根据是否有DOUBLE效果选择使`p`最大或最小的普通牌。

### 最优思路技巧
将牌型操作抽象为统一表达式（如囧仙题解），简化代码逻辑；利用结构体（如2011FYCCCTA题解）或map（如囧仙、ppllxx_9G题解）存储数据，方便处理和查询；预处理优先级（如ppllxx_9G题解）优化出牌策略判断过程。

### 拓展思路
此类模拟题关键在于准确理解规则，将复杂规则拆解为具体操作。可拓展到其他回合制游戏模拟，如扑克牌游戏、棋类游戏等，重点仍是处理好各种状态和规则细节。

### 相似知识点题目
1. **P1036 [NOIP2002 普及组] 选数**：涉及组合数计算和条件判断，与本题类似之处在于需按特定规则遍历数据并进行判断。
2. **P1162 填涂颜色**：通过模拟图形填色过程，考察对二维数组的操作和逻辑判断，与本题同样需要处理各种条件和状态。
3. **P1443 马的遍历**：利用广度优先搜索模拟马在棋盘上的遍历，与本题类似之处在于按特定规则移动并更新状态。

### 个人心得摘录
1. **2011FYCCCTA**：强调处理负数下取整的重要性，在C++中负数除以正数会向上取整，需手动调整，否则易出错。同时提到解牌效果传递时要注意出牌顺序，这些细节处理不当会导致结果错误。
2. **NaOH_Frog**：表示本题关键在于模拟每个人的出牌过程且不能出错，采用分别编写“被施加double”和正常状态的出牌顺序来确保准确性，同时注意到`D2`效果下取整在C++中的特殊处理。 

---
处理用时：117.70秒
# 题目信息

# 魔力滋生

## 题目背景

Source：[八仙敬酒](/paste/78f1vlm0)，这是可以点的。

- 吕洞宾——醉酒提壶力千钧；
- 铁拐李——旋肘膝撞醉还真；
- 汉钟离——跌步抱坛兜心顶；
- **蓝采和——单提敬酒拦腰破**；
- 张果老——醉酒抛杯踢连环；
- 曹国舅——仙人敬酒锁喉扣；
- 韩湘子——擒腕击胸醉吹箫；
- 何仙姑——弹腰献酒醉荡步。

## 题目描述

现有一个 $n$ 个点的树 $T$，满足任意一个结点的所连接的结点个数不超过 $2$。

现在依次对结点 $u=1\sim n$ 进行操作：

- 随机一个整数 $x(\ge k)$；
- 新建 $x$ 个结点，每个结点与 $u$ 之间连一条边。

显然操作完成后仍是一棵树 $T'$，其结点数为 $m=n+\sum x$。

已知操作后的树 $T'$ 及其结点数 $m$，请还原原树 $T$，若有多种方案，输出 **任意一组** 使得 $\color{black}n$ **最大** 的。

值得注意的是，我们进行还原和输出时，只关心树的形状，而不关心结点的相对编号。

## 说明/提示

#### 样例说明

样例 $\#1$ 中，只有结点 $1$ 可能在树 $T$ 中：它对应的 $x$ 是 $4$。

样例 $\#2$ 中，结点 $1,2,3$ 在树 $T$ 中：结点 $1$ 对应的 $x$ 是 $4$，结点 $2,3$ 对应的 $x$ 是 $0$。

样例 $\#3$ 中，结点 $1,2,3$ 在树 $T$ 中：它们随机的 $x$ 均为 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/4mug6pzd.png)

样例 $\#3$ 给出一张示意图，图中红色结点表示树 $T$ 中的结点，图中所有结点都在树 $T'$ 上。

#### 数据范围

| Subtask | Score | $x=$ |
| :----------: | :----------: | :----------: |
| $1$ | $30$ | $0$ |
| $2$ | $30$ | $1$ |
| $3$ | $40$ |  |
| $4$ | $0$ | Hack |

说明：Subtask4 为不计分 Hack 数据，只有通过全部的 Subtask $1\sim4$ 才算 AC。

对于 $100\%$ 的数据：$1\le m\le10^5,k\in[0,m)$，数据输入保证有解。

---

### 后记

极光魔花好可爱 $\sim$

![](https://cdn.luogu.com.cn/upload/image_hosting/o0gdk38a.png)

## 样例 #1

### 输入

```
5 1
1 2
1 3
1 4
1 5```

### 输出

```
1```

## 样例 #2

### 输入

```
7 0
1 2
1 3
1 4
1 5
1 6
1 7```

### 输出

```
3
1 2
1 3```

## 样例 #3

### 输入

```
9 1
1 2
2 3
1 4
1 5
2 6
2 7
3 8
3 9```

### 输出

```
3
1 2
2 3```

# AI分析结果

### 综合分析与结论
- **思路**：所有题解都基于对原树性质及操作特点进行分析。当 $k = 0$ 时，原树为最长链；当 $k \neq 0$ 时，需去除一些新增点。
- **算法要点**：有的通过找树的直径求解，有的通过度数判断直接删除新增点。
- **解决难点**：主要难点在于理解原树与操作后树的关系，以及如何根据 $k$ 值准确还原原树。

### 所选的题解
#### 作者：言琢დ (5星)
- **关键亮点**：思路清晰，先从部分分提示引入，再详细阐述满分做法，结合树的直径概念，代码实现简洁高效。
```cpp
// 核心代码片段：求树直径并根据k值输出结果
dfs(1);
register int root=0;
for(register int i=1;i<=m;++i)
    if(dep[i]>dep[root])
        root=i;
memset(dep,0,sizeof(dep));
memset(fa,0,sizeof(fa));
dfs(root);
register int tail=0;
for(register int i=1;i<=m;++i)
    if(dep[i]>dep[tail])
        tail=i;
if(m==1){
    wr(1),putchar('\n');
    return 0;
}
//only one node
if(!k){
    while(tail!=root){
        q[++q[0]]=tail;
        tail=fa[tail];
    }
    q[++q[0]]=tail;
    wr(q[0]),putchar('\n');
    for(register int i=1;i<q[0];++i)
        wr(i),putchar(' '),wr(i+1),putchar('\n');
}
else{
    tail=fa[tail];
    if(root==tail){
        wr(1),putchar('\n');
        return 0;
    }
    while(fa[tail]!=root){
        q[++q[0]]=tail;
        tail=fa[tail];
    }
    q[++q[0]]=tail;
    wr(q[0]),putchar('\n');
    for(register int i=1;i<q[0];++i)
        wr(i),putchar(' '),wr(i+1),putchar('\n');
}
```
核心实现思想：先通过两次dfs找到树的直径端点，根据 $k$ 值决定是否去掉直径两端点，最后输出原树的链结构。

#### 作者：CPPfive (4星)
- **关键亮点**：补充出题人思路，直接根据度数判断删除新增点，代码逻辑清晰。
```cpp
// 核心代码片段：根据k值处理并输出结果
if(!K){
    dfs(1,1);
    int mx=0,id=0;
    for(int i=1;i<=M;++i){
        if(dis[i]>mx) mx=dis[i],id=i;
    }
    memset(dis,0,sizeof(dis));
    dfs(id,id);
    mx=0;
    for(int i=1;i<=M;++i){
        if(dis[i]>mx) mx=dis[i];
    }
    printf("%d\n",mx);
    for(int i=1;i<mx;++i){
        printf("%d %d\n",i,i+1);
    }
    return 0;
}
else{
    for(int i=1;i<=M;++i){
        if(degree[i]==1) ++cnt;
    }
    if(cnt==M){
        printf("1\n");
        return 0;
    }
    printf("%d\n",M-cnt);
    bool flag=0;
    for(int i=1;i<M;++i){
        if(degree[from[i]]==1||degree[to[i]]==1) continue;
        flag=1;
        if(!too[from[i]]) too[from[i]]=++use;
        if(!too[to[i]]) too[to[i]]=++use;
        printf("%d %d\n",too[from[i]],too[to[i]]);
    }
    return 0;
}
```
核心实现思想：$k = 0$ 时，通过两次dfs找树直径；$k \neq 0$ 时，统计度数为1的点并删除，输出剩余点构成的原树。

#### 作者：Lyco_Reco (4星)
- **关键亮点**：提供一种不依赖树直径的简单思路，通过遍历边和度数判断删除新增边或点。
```cpp
// 核心代码片段：根据k值处理并输出结果
if(k==0){
    for(int i=1;i<m;i++){
        if(d[u[i]]==1&&d[v[i]]>2||d[v[i]]==1&&d[u[i]]>2){
            d[u[i]]--;
            d[v[i]]--;
            vis[i]=1;
        }
    }
    for(int i=1;i<m;i++){
        if(vis[i]){
            continue;
        }
        n++;
    }
    wrt(n+1);
    putchar('\n');
    for(int i=1;i<m;i++){
        if(!vis[i]){
            if(!hs[u[i]]){
                hs[u[i]]=++idx;
            }
            if(!hs[v[i]]){
                hs[v[i]]=++idx;
            }
            wrt(hs[u[i]]);
            putchar(' ');
            wrt(hs[v[i]]);
            putchar('\n');
        }
    }
}
else{
    for(int i=1;i<m;i++){
        if(d[u[i]]==1||d[v[i]]==1){
            vis[i]=1;
        }
    }
    for(int i=1;i<m;i++){
        if(vis[i]){
            continue;
        }
        n++;
    }
    wrt(n+1);
    putchar('\n');
    for(int i=1;i<m;i++){
        if(!vis[i]){
            if(!hs[u[i]]){
                hs[u[i]]=++idx;
            }
            if(!hs[v[i]]){
                hs[v[i]]=++idx;
            }
            wrt(hs[u[i]]);
            putchar(' ');
            wrt(hs[v[i]]);
            putchar('\n');
        }
    }
}
```
核心实现思想：$k = 0$ 时，遍历边删除一端度数为1且另一端度数大于2的边；$k \neq 0$ 时，删除度数为1的点，输出剩余边构成的原树。

### 最优关键思路或技巧
- **思维方式**：抓住原树是链且每个点按规则新增点的特点，根据 $k$ 值分类讨论。
- **代码实现技巧**：利用树的直径或度数判断来确定原树结构，减少不必要计算。

### 可拓展之处
同类型题可考察对树结构变化的逆向推导，类似算法套路是根据操作后结果及操作规则，通过分析特殊点（如度数为1的点）或特殊结构（如最长链）来还原原结构。

### 相似知识点洛谷题目
- [P2669 金币](https://www.luogu.com.cn/problem/P2669)：涉及对数列规律的分析与逆向推导。
- [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)：关于二叉树结构的构建与还原。
- [P2196 挖地雷](https://www.luogu.com.cn/problem/P2196)：在树形结构上进行策略分析与结果推导。

### 个人心得摘录
无。 

---
处理用时：70.33秒
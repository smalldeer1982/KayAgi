# 题目信息

# [JRKSJ R2] 01 序列

## 题目背景

$\text{upd2021.8.16}$：增加两组 hack 数据，并缩小时限至 1.2s。

## 题目描述

给你一个长度为 $n$ 的 $01$ 序列 $a$，$m$ 次询问，支持 $2$ 种询问：

- `1 l r` 表示询问 $l$ 到 $r$ 区间的最长不下降子序列的长度。
- `2 l r` 表示询问 $l$ 到 $r$ 区间的最长上升子序列的长度。

## 说明/提示

本题采用捆绑测试。

| $\text{Subtask}$ | $n\le$ | $m\le$ | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $\text{1}$ | $10^6$ | $10^6$ | 所有 $a_i$ 均相等 | $5$ |
| $\text{2}$ | $10^3$ | $10^3$ | 无 | $10$ |
| $\text{3}$ | $10^4$ | $10^4$ | 无 | $15$ |
| $\text{4}$ | $10^5$ | $10^5$ | 无 | $30$ |
| $\text{5}$ | $10^6$ | $5\times10^6$ | 无 | $40$ |
| $\text{6}$ | $10^6$ | $5\times10^6$ | hack 数据 | $0$ |

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le m\le 5\times10^6$，$0\le a_i\le 1$。
****
本题输入输出量极大，这里给出出题人使用的快读快写。（当然，使用您自己编写的大概率也能通过）
```cpp
namespace IO{//by cyffff
	int len=0;
	char ibuf[(1<<20)+1],*iS,*iT,out[(1<<26)+1];
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
	#define reg register
	inline int read(){
		reg char ch=gh();
		reg int x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
	inline void putc(char ch){
		out[len++]=ch;
	}
	template<class T>
	inline void write(T x){
		if(x<0)putc('-'),x=-x;
		if(x>9)write(x/10);
		out[len++]=x%10+48;
	}
	inline void flush(){
		fwrite(out,1,len,stdout);
		len=0;
	}
}
using IO::read;
using IO::write;
using IO::flush;
using IO::putc;
```
使用这种快读快写读入一个数 $x$ 时请使用语句 `x=read();`，输出时使用语句 `write(x);`。注意，换行时需使用语句 `putc('\n');`，程序执行结束时使用语句 `flush();`。

在使用此快读时请加上 `#include<bits/stdc++.h>`。

如果本地无法输入，可以尝试使用 [这里的快读快写](https://www.luogu.com.cn/paste/6za5gs1z)。

若仍看不懂，请在赛时答疑帖回复/私信出题人。

由于出题人只会 `C++`，本处无法给出其他语言的快读快写，深感歉意。
****
#### 样例解释:
对于第一个询问，满足的序列有：$\{0,1,1,1,1\},\{0,0,0,0,1\}$。\
对于第二个询问，满足的序列有：$\{0,1\}$。\
对于第三个询问，满足的序列有：$\{0,0\},\{0,1\},\{1,1\}$。\
对于第四个询问，满足的序列有：$\{0\},\{1\}$。

本题时限、空限保证为出题人所用的两倍以上。\
如果您仍认为卡常，则请私信出题人或者发帖并 @ 出题人。

## 样例 #1

### 输入

```
8 4
0 1 1 0 1 0 0 1
1 1 8
2 1 8
1 3 6
2 5 6```

### 输出

```
5
2
2
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何利用01序列的特殊性质来高效解决最长不下降子序列和最长上升子序列的区间查询问题。对于最长上升子序列，多数题解利用前缀和判断区间内是否存在“01”子串，若存在则长度为2，否则为1。对于最长不下降子序列，通过枚举“0”和“1”的分割点，利用前缀和计算不同分割情况下的子序列长度，并借助ST表等数据结构优化查询。

### 所选的题解
- **作者：cyffff（5星）**
    - **关键亮点**：思路清晰，从简单子任务逐步推导到正解，不仅给出了暴力解法，还详细说明了优化过程，如利用前缀和转化问题、用ST表优化查询，且提供了减小常数的方法和完整代码。
    - **个人心得**：无
    - **重点代码及核心思想**：
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO{//by cyffff
    // 快读快写部分
}
const int N=1e6+10;
int n,m,st[20][N],lg[N],a[N],pre[N],pp[N];
inline int query(int l,int r){
    int q=lg[r-l+1];
    return max(st[q][l],st[q][r-(1<<q)+1]);
}
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
    }
    a[0]=2;
    int sum=0,o=0,z=0;
    for(int i=1;i<=n;i++){
        if(a[i]) sum--,o++;
        else sum++,z++;
        st[0][i]=z-o;
        pp[i]=o;
        pre[i]=pre[i-1]+(a[i]==1&&a[i-1]==0);
    }
    for(int i=2;i<=n;i++)
        lg[i]=lg[i>>1]+1;
    for(int i=1;i<=19;i++)
        for(int j=1;j+(1<<i)-1<=n;j++)
            st[i][j]=max(st[i-1][j],st[i-1][j+(1<<i-1)]);
    for(int i=1;i<=m;i++){
        int opt=read(),l=read(),r=read();
        if(opt==1)
            write(max(pp[r]-pp[l-1],query(l,r)-(l-1-pp[l-1])+pp[r]));
        else
            write(1+!(pre[l]==pre[r]));
        putc('\n');
    }
    flush();
    return 0;
}
```
核心思想是通过预处理前缀和数组`pre`记录“01”子串出现次数，利用`st`表维护特定值的最大值，从而快速回答两种类型的查询。

- **作者：Mars_Dingdang（4星）**
    - **关键亮点**：对题目大意和思路的阐述详细，先分析01序列特殊性质，再分别针对最长上升和不下降子序列给出具体解法及推导过程，代码结构清晰。
    - **个人心得**：无
    - **重点代码及核心思想**：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
typedef double db;
const int maxn = 1e6 + 5;
namespace IO_ReadWrite {
    // 快读快写部分
}
using namespace IO_ReadWrite;
int n, m, a[maxn], f[maxn][25], L[maxn], pre[maxn], lst[maxn], sum[maxn];
inline void init() {// ST表预处理
    L[0] = -1;
    rep(i, 1, n) f[i][0] = pre[i] + lst[i], L[i] = L[i >> 1] + 1;
    rep(j, 1, 22)
        for(int i = 1; i + (1 << j) - 1 <= n; i ++)
            f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
}
inline int Max(int x, int y) {// 处理问询 
    int k = L[y - x + 1];
    return max(f[x][k], f[y - (1 << k) + 1][k]);
}
int main () {
    read(n); read(m);
    rep(i, 1, n) {
        read(a[i]);
        pre[i] = pre[i - 1] + (a[i] == 0);
        if(i > 1) sum[i] = sum[i - 1] + (a[i] == 1 && a[i - 1] == 0);
    }
    Rep(i, n, 1) lst[i] = lst[i + 1] + (a[i] == 1);// 统计前、后缀和 
    init();
    while(m --) {
        int op, x, y;
        read(op); read(x); read(y);
        if(op == 1) {
            writeln(Max(x, y) - pre[x - 1] - lst[y + 1]);
        } else writeln((sum[y] == sum[x]? 1 : 2));
    }
    return 0;
}
```
核心思想是通过前缀和数组`pre`、`lst`分别记录0和1的出现次数，`sum`记录“01”子串出现次数，利用ST表`f`维护`pre[i]+lst[i]`的最大值，以实现高效查询。

- **作者：言琢დ（4星）**
    - **关键亮点**：通过预处理`lstOne_i`和`firZero_i`两个数组，清晰地分析了最长不下降子序列的三种情况，并利用ST表优化查询，代码简洁明了。
    - **个人心得**：无
    - **重点代码及核心思想**：
```cpp
#include<cstdio>
inline int in();
inline void wr(int);
const int N=(int)3e6+5;
int a[N],Log[N],rmq[N][20],firZero[N],lstOne[N];
inline int mx(int,int);
inline int Query(int,int);
int main(int argc,char**argv){
#ifndef ONLINE_JUDGE
    freopen("A.in","r",stdin);
    freopen("A.out","w",stdout);
#endif
    register int n=in(),m=in();
    for(register int i=1;i<=n;++i){
        a[i]=in();
        if(a[i])lstOne[i]=i;
        else lstOne[i]=lstOne[i-1];
    }
    firZero[n+1]=n+1;
    for(register int i=n;i>=1;--i){
        if(!a[i])firZero[i]=i;
        else firZero[i]=firZero[i+1];
    }
    for(register int i=1;i<=n;++i)
        a[i]+=a[i-1];
    for(register int i=1;i<=n;++i)
        rmq[i][0]=i-2*a[i];
    for(register int j=1;j<20;++j)
        for(register int i=1;i<=n;++i)
            rmq[i][j]=mx(rmq[i][j-1],rmq[i+(1<<(j-1))][j-1]);
    register int j=0;
    for(register int i=1;i<=n;++i)
        if(1<<(j+1)<=i)
            Log[i]=++j;
        else
            Log[i]=j;
    for(register int i=1;i<=m;++i){
        register int tp=in(),l=in(),r=in();
        register int cnt1=a[r]-a[l-1];
        register int cnt0=r-l+1-cnt1;
        if(tp==1){
            register int ans=mx(cnt0,cnt1);
            register int s1=Query(l,r-1)-l+1+a[l-1]+a[r];
            wr(mx(ans,s1)),putchar('\n');
        }
        else
            wr(firZero[l]<=lstOne[r]?2:1),putchar('\n');
    }
}
inline int Query(int l,int r){
    register int ch=r-l+1;
    register int j=Log[ch];
    return mx(rmq[l][j],rmq[r-(1<<j)+1][j]);
}
inline int mx(int x,int y){
    return x>y?x:y;
}
inline int in(){
    register char c=getchar();
    register int x=0,f=1;
    for(;c<'0'||c>'9';c=getchar())
        if(c=='-')f=-1;
    for(;c>='0'&&c<='9';c=getchar())
        x=(x<<1)+(x<<3)+(c&15);
    return x*f;
}
inline void wr(int x){
    if(x<0)putchar('-'),x=-x;
    if(x/10)wr(x/10);
    putchar(x%10+'0');
}
```
核心思想是利用`lstOne_i`和`firZero_i`数组确定最长不下降子序列的情况，通过ST表`rmq`维护特定值的最大值，进而快速得出查询结果。

### 最优关键思路或技巧
 - **利用序列特殊性质**：01序列使得最长上升子序列长度只可能为1或2，通过判断“01”子串是否存在即可确定；最长不下降子序列则呈现“00...11”的形式，便于通过前缀和等方式计算。
 - **ST表优化**：对于最长不下降子序列，通过ST表维护前缀和相关值的最大值，实现O(1)查询，大大提高效率。

### 可拓展思路
此类题型可拓展到其他具有特殊性质的序列，如仅包含少量不同值的序列，同样可通过分析序列特性，利用前缀和、后缀和以及合适的数据结构（如ST表、线段树等）来优化区间查询问题。

### 相似知识点洛谷题目
 - **P3865 【模板】ST表**：基础的ST表模板题，用于练习ST表的构建与查询。
 - **P1816 忠诚**：同样涉及区间最值查询问题，可通过ST表解决，加深对ST表应用的理解。
 - **P1198 [JSOI2008]最大数**：结合了数据插入与区间最大值查询，可进一步锻炼对数据结构的综合运用能力。 

---
处理用时：105.36秒
# 题目信息

# [WFOI - 01]  刷题 （problem）

## 题目背景

简化题意：[$\texttt{Link}$](https://www.luogu.com.cn/paste/ievt77rm)。

## 题目描述

你初始能力为 $0$。

现在有 $n$ 个题库，每个题库的题有同一个难度 $a_i$，并且题目数量可以视为无限多。现在你要刷 $m$ 道题，每道题都是所有题中你选择出来的一道。

假设你目前做到的题目难度是 $x$，则：

当你的能力比这个题大或等于此题时，你将花费你的能力以攻破此题（此时你的能力减去 $x$）；否则，你将认真钻研此题，钻研出此题后能力增加 $x$（此时不会导致能力减少）。

现在你想知道你做 $m$ 题后能力最大值。由于你的小伙伴也要刷题，所以**有多次询问**，询问之间相互独立，也就是说每次询问的能力初值为 $0$。

## 说明/提示

- **样例 $1$ 解释：**
	
    当 $m=1$ 时，依次选择 $6$；

	当 $m=2$ 时，依次选择 $4,6$；
    
    当 $m=3$ 时，依次选择 $1,4,6$；
- **样例 $2$ 解释：** 

    当 $m=1$ 时，依次选择 $1$；

	当 $m=2$ 时，依次选择 $1,1$；

**本题采用 Subtask 捆绑测试。**

  Subtask 编号 | $n\le$ | $m\le$ | $T\le$
  :-: | :-: | :-: | :-: |
  **Subtask #0 ($5\texttt{pts}$)** | $5$ | $5$ | $100$ |
  **Subtask #1 ($10\texttt{pts}$)** | $5$ | $5$ | $10^5$ |
  **Subtask #2 ($10\texttt{pts}$)** | $200$ | $200$ | $100$ |
  **Subtask #3 ($15\texttt{pts}$)** | $200$ | $200$ | $10^5$ |
  **Subtask #4 ($10\texttt{pts}$)** | $200$ | $10^{18}$ | $10^5$ |
  **Subtask #5 ($50\texttt{pts}$)** | $2000$ | $10^{18}$ | $10^5$ |
  
对于 $100\%$ 的数据，$1 \le T \le 10^5$，$1 \le n\le 2000$，$1 \le m \le 10^{18}$，$\forall i,0 \le a_i \le 2000$。

## 样例 #1

### 输入

```
5 3
1 2 3 4 6
1
2
3```

### 输出

```
6
10
11```

## 样例 #2

### 输入

```
1 2
1
1
2```

### 输出

```
1
0```

# AI分析结果

• 综合分析与结论：这些题解主要围绕通过建图和最短路算法解决该问题。思路要点在于发现能力值上限不超过 \(2 \times \max a_i - 1\) ，且存在奇偶性规律，即若能在 \(x\) 步到达某点，也能在 \(x + 2\) 步到达。算法上多采用建图后进行BFS求奇偶图最短路。难点在于处理 \(m\) 取值较大的情况，通过利用上述规律将问题简化。
- **作者：Wf_yjqd (赞：10)** ：
  - **星级**：4星
  - **关键亮点**：思路清晰，详细阐述建图、BFS维护奇偶最短路及利用前缀最大值处理询问的过程，代码实现完整且有注释。
  - **个人心得**：提到写起来容易出错，强调实际编码时的注意事项。
```cpp
// 核心代码实现BFS求奇偶最短路
void bfs(int x){
    memset(dis,0x7f,sizeof(dis));
    dis[x][0]=0;
    q.push({x,0});
    p t;
    while(!q.empty()){
        t=q.front();
        q.pop();
        for(int i=head[t.first];i;i=e[i].ne){
            if(e[i].to!=x&&dis[e[i].to][t.second^1]>1e9){
                dis[e[i].to][t.second^1]=dis[t.first][t.second]+1;
                q.push({e[i].to,t.second^1});
            }
        }
    }
    return ;
}
```
- **作者：YellowBean_Elsa (赞：10)** ：
  - **星级**：4星
  - **关键亮点**：从dp思路引入，将问题转化为最短路问题，通过排序和unique进行小优化，代码逻辑清晰。
```cpp
// spfa处理最短路
memset(dp,0x7f,sizeof(dp));
dp[0][0]=0;
q.push(0);
while(!q.empty()){
    int x=q.front();
    q.pop();
    fu(i,1,n){
        if(x<a[i]){
            flg=0;
            if(dp[x+a[i]][0]>dp[x][1]+1){
                dp[x+a[i]][0]=dp[x][1]+1;
                q.push(x+a[i]);flg=1;
            }if(dp[x+a[i]][1]>dp[x][0]+1){
                dp[x+a[i]][1]=dp[x][0]+1;
                if(!flg)q.push(x+a[i]);
            }
        }else{
            flg=0;
            if(dp[x-a[i]][0]>dp[x][1]+1){
                dp[x-a[i]][0]=dp[x][1]+1;
                q.push(x-a[i]);flg=1;
            }if(dp[x-a[i]][1]>dp[x][0]+1){
                dp[x-a[i]][1]=dp[x][0]+1;
                if(!flg)q.push(x-a[i]);
            }
        }
    }
}
```
- **作者：伟大的王夫子 (赞：4)** ：
  - **星级**：4星
  - **关键亮点**：指出本题与另一道题思路相似，利用奇偶性和最短路求解，代码简洁明了。
```cpp
// 核心代码实现BFS求奇偶最短路
memset(f, 0x3f, sizeof f);
f[0][0] = 0;
queue<pair<int, bool> > q;
v[0][0] = 1;
q.push(make_pair(0, 0));
while (q.size()) {
    int x = q.front().first;
    bool p = q.front().second;
    q.pop();
    for (int i = 0; i < e[x].size(); ++i) {
        int y = e[x][i];
        if (v[y][p ^ 1]) continue;
        f[y][p ^ 1] = f[x][p] + 1;
        v[y][p ^ 1] = 1;
        q.push(make_pair(y, p ^ 1));
    } 
}
```
• 最优关键思路或技巧：利用能力值上限和奇偶性规律，将复杂的多步操作问题简化为建图后求奇偶图最短路问题，在建图和最短路求解过程中可进行适当优化，如排序去重等。
• 可拓展之处：同类型题常考察对状态转移关系的抽象建模，转化为图论问题求解。类似算法套路是先分析问题中的状态变化规律，利用规律简化问题规模，再通过建图和图论算法求解。
• 相似知识点洛谷题目：
  - P5663 [CSP - J2019] 加工零件：同样涉及利用奇偶性和最短路思想解决问题。
  - P3371 【模板】单源最短路径（弱化版）：基础的单源最短路问题，可巩固最短路算法的理解。
  - P1339 热浪：单源最短路的应用，通过实际场景加深对最短路算法的运用。
• 个人心得摘录与总结：Wf_yjqd提到写起来容易出错，说明此类问题虽然思路明确，但编码实现细节较多，需仔细处理。 

---
处理用时：46.98秒
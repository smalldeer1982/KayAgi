# 题目信息

# 「Wdoi-1.5」魔理沙的计算器

## 题目背景

魔理沙是普通而平凡的魔法使。在解决了大大小小的异变后，她终于攒足了足够多的钱在香霖堂里购置了一台 $\verb!Carno!$ 计算器，用来计算魔女之汤各种配料的含量之比。

魔理沙早就听闻灵梦通过河童重工网络[入手了一部 $\verb!Casio!$ 计算器](https://www.luogu.com.cn/problem/P5515)，来计算神社的香火钱，却买到了假货，最多只能显示整数部分（下取整）。而魔理沙的这部可以精确到小数点后面若干位（下取整）的计算器。更高级的是，这部计算器还可以支持其他的进制，其强大的功能高出了灵梦一大截。因此作为灵梦真挚的朋友，魔理沙希望向灵梦表达真挚的遗憾之情。

正当魔理沙打算出发之时，她发现虽然 $\verb!Carno!$ 计算器不会导致一些特别大的误差，但是在计算除法时仍然会出现一定的问题。考虑将计算器的进制调整为 $10$ 进制，而计算器屏幕上最多可以显示 $5$ 位数字（小数点不计入显示位数）。比如，魔理沙希望计算 $1\div 3$ 的值，那么真正显示在屏幕上的则是：

$$
0.3333
$$

按照道理上来讲，$1\div(1\div 3)$ 结果应当等于 $3$。但出乎意料的是，当魔理沙输入 $1\div 0.3333$ 后，得到的结果却是：

$$
3.0003
$$

这当然只是一个个例。当魔理沙计算 $1\div(1\div 4)$ 时，屏幕上显示出了正确的数字。

为了防止在表达遗憾之情的时候自己的计算器也出了漏子，魔理沙希望找到有多少个数字使得计算出的结果是正确的，因此她向你求助了。

## 题目描述

魔理沙的计算器可以进行 $b$ 进制的运算，屏幕上可以显示 $k$ 个数字（不包含小数点）。进行计算后，若某个数字超出了屏幕，就会被**直接舍去**（例如 $b=10$ 时 $1\div 7=0.142857\cdots$，若屏幕大小为 $4$，那么最终显示为 $0.142$）。

魔理沙用计算器计算了 $1\div n=n'$，再计算 $1\div n'=n''$（$n'$ 和 $n''$ 均为显示在屏幕上的结果）。魔理沙希望知道，有多少个正整数 $n$ 使得 $n=n''$。你只需要输出这个答案对 $998,244,353$ 取模后的结果即可。

## 说明/提示

### 样例解释

- 对于第一组询问，符合条件的数（转换成十进制）为 $1,2,4$。
- 对于第二组询问，符合条件的数（转换成十进制）为 $1,5,25$。

### 数据范围及约定

$$
\def{\arraystretch}{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{subtask}&\textbf{分值} & \bm{b\le} & \bm {k\le } & \textbf{特殊性质} & \textbf{subtask 依赖} \cr\hline
1 & 20 & 10 & 7 & - &-\cr\hline
2 & 20 & 10^5 & 2 & k=2&-\cr\hline
3 & 10 & 10^5 & 3 & k=3&- \cr\hline
4 & 50& 10^5 & 500 & -&1,2,3\cr\hline
\end{array}
$$

对于 $100\%$ 的数据，满足 $1\le T\le 10$，$2\le b\le 10^5$，$1\le k\le 500$。

## 样例 #1

### 输入

```
3
4 2
5 3
12 99```

### 输出

```
3
3
19503```

# AI分析结果

• **综合分析与结论**：
    - 这些题解的核心思路均是证明满足 \(n'' = n\) 的条件是 \(n \mid b^{k - 1}\)，进而通过对 \(b\) 分解质因数，利用乘法原理求 \(b^{k - 1}\) 的因子数来解题。
    - 各题解的主要区别在于对 \(n \mid b^{k - 1}\) 这一结论的证明过程。有的通过严谨的数学推导，有的借助直观的例子和感性理解。
    - 在代码实现上，基本都是对 \(b\) 进行质因数分解，根据分解结果计算 \(b^{k - 1}\) 的因子数并取模。

• **所选的题解**：
  - **作者：囧仙 (5星)**
    - **关键亮点**：思路清晰，先给出核心结论，通过证明引理，严谨地从数学角度推导得出 \(n \mid b^{k - 1}\) 时满足条件，且代码简洁明了。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MOD =998244353;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(){
    up(1,qread(),T){
        int b=qread(),k=qread(),ans=1;
        if(k==1){puts("1");continue;}
        for(int i=2;i*i<=b;++i){
            int c=0; while(b%i==0) ++c,b/=i; ans=1ll*ans*((k-1)*c+1)%MOD;
        }
        if(b!=1) ans=1ll*ans*k%MOD; printf("%lld\n",ans);
    }
    return 0;
}
```
    - **核心实现思想**：通过 `qread` 函数读入数据，对 \(b\) 从 \(2\) 到 \(\sqrt{b}\) 进行遍历分解质因数，统计每个质因数的次数 \(c\)，根据公式计算因子数并对 \(MOD\) 取模，最后处理 \(b\) 分解完后剩余大于 \(1\) 的情况。
  - **作者：minstdfx (4星)**
    - **关键亮点**：提供了另一种严格证明方式，对引理及命题必要性证明详细，逻辑连贯。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
#include "wdoi-fastio.hpp" // 省略快读头文件
using namespace std;
const int maxn=1e7+9;
#define int long long
const int mod=998244353;
int gs[maxn],p[maxn],v[maxn],pt;
void init(int n,int k)
{
    pt=0;
    gs[1]=1;
    for(int i=2;i<=n;++i)
    {
        if(!v[i]) // prime 
        {
            v[i]=i;
            p[++pt]=i;
            gs[i]=k;
        }
        for(int j=1;j<=pt && i*p[j]<=n;++j)
        {
            v[i*p[j]]=p[j];
            if(i%p[j]==0){
                gs[i*p[j]]=gs[i]*2+mod-gs[i/p[j]];
                gs[i*p[j]]%=mod;
                break;
            }
            gs[i*p[j]]=gs[i]*gs[p[j]]%mod;
        }
    }
} 
signed main()
{
    int n,k,t;
    fio>>t;
    while(t--)
    {
        fio>>n>>k;
        pt=0;
        memset(gs,0,sizeof(gs));
        memset(v,0,sizeof(v));
        init(n,k); 
        fio<<gs[n]<<_fios::endl;
    }
}
```
    - **核心实现思想**：`init` 函数利用埃氏筛法标记质数并预处理每个数的因子数相关值，在 `main` 函数中读入数据，调用 `init` 函数并输出对应结果。
  - **作者：Yusani_huh (4星)**
    - **关键亮点**：用通俗易懂的语言阐述思路，通过具体例子辅助理解，从感性角度说明满足条件的 \(n\) 的范围，最后转化为求 \(b^{k - 1}\) 的因子个数。
    - **重点代码**：
```c++
#include<bits/stdc++.h>
using namespace std;
#define N 100003
#define LL long long
#define INF 0x3f3f3f3f
#define MOD 998244353
int t,b,k;
LL h[N];
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d%d",&b,&k);
        LL ans=1;
        int a=b,ct=0;
        for(int i=2;i*i<=b;++i)
            if(a%i==0){
                ct++;
                while(a%i==0) a/=i,h[ct]++;
                h[ct]=h[ct]*(k-1)%MOD;
            }
        if(a>1) h[++ct]=k-1;
        for(int i=1;i<=ct;++i)
            ans=ans*(h[i]+1)%MOD,h[i]=0;
        printf("%lld\n",ans);
    }
    return 0;
}
```
    - **核心实现思想**：读入数据后，对 \(b\) 从 \(2\) 到 \(\sqrt{b}\) 分解质因数，记录每个质因数次数，计算 \(b^{k - 1}\) 中对应质因数次数并取模，最后根据乘法原理计算因子数并输出。

• **最优关键思路或技巧**：通过对计算器显示特性及除法运算的分析，将问题转化为数学上判断 \(n\) 与 \(b^{k - 1}\) 的整除关系，利用质因数分解和乘法原理求解因子个数。这种将实际问题抽象为数学模型的思维方式是解题关键。

• **可拓展之处**：同类型题可涉及不同进制下的数学运算、精度处理等问题，类似算法套路为遇到与进制、小数精度相关问题，可尝试从数学本质出发，建立数学模型，通过数论知识如质因数分解、约数等求解。

• **推荐题目**：
    - [P1072  Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)：涉及数论中最大公约数和最小公倍数的计算，与本题同样需要利用数论知识建立数学模型求解。
    - [P2568 GCD](https://www.luogu.com.cn/problem/P2568)：通过对最大公约数的分析，结合数论知识解决问题，锻炼数论思维。
    - [P3327 [SDOI2015]约数个数和](https://www.luogu.com.cn/problem/P3327)：重点考察约数个数相关知识，与本题在求因子数上有相似之处。

• **个人心得**：无。 

---
处理用时：78.04秒
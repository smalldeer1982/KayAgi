# 题目信息

# [JRKSJ R4] BBWWBB

## 题目描述

数轴上有 $6$ 个棋子。初始，第 $i$ 个棋子摆在 $a_i$，$a$ 单调递增。

其中第 $1,2,5,6$ 个棋子是黑色的，第 $3,4$ 个棋子是白色的。

游戏过程中，同一个位置上可以同时存在任意个同样颜色的棋子。

有两方：黑方和白方。两方轮流进行操作：

* 选择己方颜色的棋子，向左或向右移动一步。
* 若准备移动到的位置上存在另一方的棋子且仅存在 $1$ 个，那么可以移动同时将该棋子移除。
* 若准备移动到的位置上存在多个另一方的棋子，那么不可以移动到这个位置。
* 当一方不存在可以移动的棋子，该方被判输，游戏结束。

两方的目标都是在己方不输的前提下，尽可能的令对方输。两方均采取最优策略。

给定一方作为先手和每个棋子的位置，请判断，游戏是否会无限进行下去。

## 说明/提示

### 数据规模

对于 $15\%$ 的数据，$c=\texttt B$。\
对于 $100\%$ 的数据，$T\le10^5$，$|a_i| \le 10^9$，$c\in\{\texttt B,\texttt W\}$。保证 $a$ 单调递增。

### 样例解释

对于第 $1$ 组数据，其中一种局面变化如下：

```cpp
B:
1 4 6 8 9
B B W B B
W:
1 4 5 8 9
B B W B B
B:
1 5 8 9
B B B B
```
对于第 $2$ 组数据，其中一种局面变化如下：

```cpp
W:
1 3 6 8 9
B W W B B
B:
1 3 6 8 8
B W W B B
W:
1 3 5 8 8
B W W B B
B:
1 3 5 7 8
B W W B B
W:
1 3 4 7 8
B W W B B
B:
1 3 4 7 7
B W W B B
W:
1 3 3 7 7
B W W B B
B:
1 3 3 6 7
B W W B B
W:
1 2 3 6 7
B W W B B
B:
2 3 6 7
B W B B
W:
2 6 7
W B B
```
此后白方每一步均控制 `W` 往左边走一步。无论黑方如何操作，游戏均可以无限进行下去。

## 样例 #1

### 输入

```
2
B 1 3 4 6 8 9
W 1 3 4 6 8 9```

### 输出

```
No
Yes```

# AI分析结果

• 综合分析与结论：这些题解的核心思路均围绕判断游戏是否会无限进行下去展开，由于白方棋子少，目标是逃脱从而使游戏无限进行，黑方则是阻止白方逃脱。各题解普遍通过分情况讨论白方或黑方先手，以及棋子相邻情况来判断游戏走向。算法要点在于依据规则，分析不同局面下双方的最优策略。难点在于全面且准确地考虑各种可能情况，避免遗漏。

所选的题解：
 - **作者：stntn (赞：14)  星级：5星**
   - **关键亮点**：思路清晰，先通过观察样例猜测结果只有W被消灭或W逃脱两种情况，然后详细分情况讨论，得出W逃脱的条件，代码简洁明了，直接根据结论实现判断。
   - **重点代码**：
```cpp
#include<bits/stdc++.h>
int pos[7],T;char c;
signed main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);std::cout.tie(0);
    std::cin>>T;
    while(T--)
    {
        std::cin>>c;
        for(int i=1;i<=6;i++) std::cin>>pos[i];
        if ((c=='W')//W 先手
        && ((pos[3]-pos[2]==1&&pos[2]-pos[1]>1)
        ||  (pos[5]-pos[4]==1&&pos[6]-pos[5]>1))//有
        &&(!(pos[3]-pos[2]==1&&pos[5]-pos[4]==1)))//且仅有一侧与W相邻
                std::cout<<"Yes\n";
        else std::cout<<"No\n";
    }
    return 0;
}
```
核心实现思想：先判断是否W先手，再判断是否有且仅有一侧的白棋与黑棋相邻，满足则输出“Yes”，否则输出“No”。

 - **作者：lailai0916 (赞：3)  星级：4星**
   - **关键亮点**：明确指出游戏无限进行需同时满足白方先手、白方第一次能吃掉一个黑方棋子、白方吃完后不能被黑方吃掉棋子这三个条件，逻辑清晰，代码简洁。
   - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[10];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin>>T;
    while(T--)
    {
        char c;
        cin>>c;
        for(int i=1;i<=6;i++)
        {
            cin>>a[i];
        }
        bool b1=c=='W';
        bool b2=a[3]-a[2]==1&&a[2]-a[1]!=1&&a[5]-a[4]!=1;
        bool b3=a[5]-a[4]==1&&a[6]-a[5]!=1&&a[3]-a[2]!=1;
        cout<<(b1&&(b2||b3)?"Yes":"No")<<'\n';
    }
    return 0;
}
```
核心实现思想：分别判断三个条件是否满足，通过逻辑与运算得出最终结果并输出。

 - **作者：critnos (赞：3)  星级：4星**
   - **关键亮点**：先提出基础情况，即特定局面下白方必败，然后详细推论黑方先手和白方先手时各种情况，通过分类讨论严谨证明结论，代码基于结论实现判断。
   - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define Misaka namespace
#define Mikoto std
using Misaka Mikoto;
int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') w=ch=='-'?-1:w,ch=getchar();
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
int main()
{
    int T=read(),i,a[7];
    char s[5];
    while(T--)
    {
        scanf("%s",s);
        for(i=1;i<=6;i++)
            a[i]=read();
        puts(*s=='W'&&(a[3]-a[2]==1)+(a[5]-a[4]==1)==1&&(a[3]-a[2]==1&&a[1]+1!=a[2]||a[5]-a[4]==1&&a[5]+1!=a[6])?"Yes":"No");
    }
}
```
核心实现思想：根据白方先手且满足特定相邻条件的判断结果输出相应答案。

**最优关键思路或技巧**：通过对样例和规则的深入分析，抓住白方逃脱使游戏无限进行这一关键，分情况细致讨论白方和黑方先手时的各种局面，总结出简洁有效的判断条件。

**可拓展之处**：此类题属于博弈策略类型，类似套路是先分析双方目标，找出关键局面和最优策略，通过分情况讨论得出通用结论。

**相似知识点洛谷题目**：
 - P1288 取数游戏II，通过分析双方取数策略判断胜负。
 - P2148 [SDOI2009]E&D，涉及双方博弈的策略分析。
 - P1199 [NOIP2010 普及组] 三国游戏，同样是博弈类问题，需考虑双方最优策略。

**个人心得摘录与总结**：无。 

---
处理用时：49.20秒
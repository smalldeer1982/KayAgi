# 题目信息

# 「Wdoi-5」模块化核熔炉

## 题目背景

为了通过使用核聚变获得能源，守矢神社在旧地狱修建了巨大的核融合控制中心。控制中心形如双层八卦炉，通过各种电路紧密地调控着核融合的精密运行。获得了八咫鸟力量的阿空会在核反应炉的中心点燃神火。

但是正八边形的八卦炉并不利于进行拓展与维护。为了方便地实现电路，河童打算对核控制中心进行模块化改造，以实现核熔炉的维护。具体而言，河童打算将核控制中心设计成由若干个正六边形组成的巨大结构。

![](https://cdn.luogu.com.cn/upload/image_hosting/ohyfxv02.png)

被赋予了神力的阿空可以依次激发其中的一些模块，而这些被激发的模块会快速影响到一定范围内的其他的模块。通过模块间的链接实现能量的产生。

但是因为阿空脑袋空空，由于它已经激发了多次模块，它已经记不清每个模块当中产生的核融合程度了。你能帮帮它吗？

## 题目描述

核控制中心可以看作由若干个正六边形模块组成的六边形阵列。阵列当中每个模块都可以储存核融合能量（一个非负整数）。左图就是一个核控制中心示意图。

![](https://cdn.luogu.com.cn/upload/image_hosting/78y7b98x.png)

我们使用如下方式对控制中心中每个模块进行标号。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ffz2m5o.png)

以阵列中心为原点延伸出三根射线作为三根轴，每两根轴之间的夹角为 $120\degree$。这三根轴将平面划分为了三个部分。每个模块都可以使用一个三元组 $(x,y,z)$ 描述它的坐标，表示从原点开始按如图所示的 $x,y,z$ 方向各走若干步之后到达的地方。为了防止出现多个坐标表示同一个模块的情况，做出如下规定：原点的坐标为 $(0,0,0)$；对于中心在坐标轴上的模块，它的坐标就是从原点向所在轴走过的距离；对于其他情况，我们将平面划分为了三个区域（如第二张图的红蓝绿三个区域），一个模块的坐标就是沿着它两侧的轴分别需要走的距离。例如模块 $P$ 的坐标为 $(2,4,0)$。容易发现，每个坐标唯一对应一个模块，一个模块唯一对应一个坐标。

同时定义，两个模块的**距离**为从一个模块到另一个模块需要经过模块（包括起点和终点）的最少个数。在第一张图中，红色部分的模块到其中心距离均不超过 $3$，绿色部分的模块到其中心距离均不超过 $3$，而蓝色部分的模块到其中心距离均不超过 $2$。

核控制中心可以视为到达原点距离不超过 $n$ 的模块组成的阵列。现在阿空会执行以下操作 $m$ 次：

- $\colorbox{f0f0f0}{\verb!x y z r k!}$ ：激活坐标为 $(x,y,z)$ 的模块。它会使控制中心中到它距离不超过 $r$ 的**所有**的模块的核融合能量增加 $k$。保证 $(x,y,z)$ 在控制中心当中。

现在需要求出，执行完 $m$ 个操作后，每个模块里核融合能量值。

## 说明/提示

样例 $2$ 见下发的附件 $\textbf{\textit{nuclear2.in/nuclear2.ans}}$。  
样例 $3$ 见下发的附件 $\textbf{\textit{nuclear3.in/nuclear3.ans}}$。满足特殊性质 $\text{A}$（见下文）。  
样例 $4$ 见下发的附件 $\textbf{\textit{nuclear4.in/nuclear4.ans}}$。满足特殊性质 $\text{B}$（见下文）。  
样例 $5$ 见下发的附件 $\textbf{\textit{nuclear5.in/nuclear5.ans}}$。

#### 样例 1 解释

如图所示（所有未标出数字的模块的核融合能量值均为 $0$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/6y7bm2eb.png)



按照从左往右、从上往下的顺序依次输出每个数值，即可得到答案。

#### 数据范围及约定

本题共有 $20$ 个测试点，每个测试点 $5$ 分。最终分数为所有测试点分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Task} & \bm{n\le } & \bm{m\le} & \textbf{特殊性质} \cr\hline
1\sim 3 & 10 & 10 & \text{A} \cr\hline
4\sim 7 & 100 & 300 & - \cr\hline
8\sim 10 & 800 & 3\times 10^5 & \text{B} \cr\hline
11\sim 14 & 800 & 3\times 10^5 & \text{A} \cr\hline
15\sim 20 & 800 & 3\times 10^5 & - \cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证对于第 $i$ 次操作，被激活的模块到控制中心边缘上的模块的距离不小于 $r_i$。  
**特殊性质** $\textbf{B}$：保证对于第 $i$ 次操作，被激活的模块均为 $(0,0,0)$。

对于全部数据，保证 $n\le 800$，$m\le 3\times 10^5$，$1\le k_i\le 5\times 10^3$，$1\le r_i\le 10^9$。每次激活的模块都在控制中心里。

## 样例 #1

### 输入

```
4 3
0 1 1 3 4
3 0 3 3 3
1 0 0 2 2```

### 输出

```
4 4 4 0 4 4 4 4 3 4 4 4 4 7 3 0 4 4 6 9 3 3 0 4 6 6 5 3 0 0 2 2 3 0 0 0 0```

# AI分析结果

• 综合分析与结论：
    - 思路：各题解均采用将六边形区域操作转化为更易处理的矩形区域操作，并结合差分和前缀和的思想来降低时间复杂度。
    - 算法要点：通过坐标转换，将六边形网格中的正六边形区域加法转换为矩形区域加法，在转换后的坐标系中进行差分操作，记录每次操作对相关矩形区域边界的影响，最后通过前缀和还原得到每个模块的最终能量值。
    - 解决难点：核心难点在于找到合适的坐标转换方式，将复杂的六边形区域操作简化为矩形操作，并正确处理边界情况。
    - 评分：囧仙和zhongcy的题解思路清晰，代码完整且有注释辅助理解，可评为4星；WYXkk题解思路清晰但未给出代码，评为3星；minstdfx题解使用Python且代码复杂，评为3星。

所选的题解：
  - 囧仙（4星）
    - 关键亮点：详细阐述了从正方形网格矩形加法引入差分和前缀和思想，再通过坐标转换将六边形网格转换为左系和右系，把六边形区域加法转化为左系和右系中的矩形加法，代码实现完整。
    - 重点代码核心实现思想：通过`cnv1`和`cnv2`函数进行坐标转换，在`main`函数中对每次操作在左系和右系对应的矩形边界进行差分操作，最后通过两次前缀和操作得到最终结果。
```cpp
void cnv1(int a,int b,int c,int &x,int &y){  //左系
    x=a-c+n,y=b-a+n;
}
void cnv2(int a,int b,int c,int &x,int &y){  //右系
    x=a-c+n,y=b-c+n;
}
int main(){
    n=qread(),m=qread(),k=2*n-1;
    up(1,m,i){
        int x=qread(),y=qread(),z=qread(),r=qread(),w=qread();
        int u,v;
        cnv1(x,y,z,u,v);
        A[u][min(k,v+r-1)]-=w,A[max(1,u-r+1)][min(k,v+r-1)]+=w;
        A[u][max(0,v-r  )]-=w,A[min(k+1,u+r)][max(0,v-r  )]+=w;
        cnv2(x,y,z,u,v);
        B[u][min(k,v+r-1)]+=w,B[min(k+1,u+r)][min(k,v+r-1)]-=w;
        B[u][max(0,v-r  )]+=w,B[max(1,u-r+1)][max(0,v-r  )]-=w;
    }
    up(1,k,i) up(1,k,j) A[i][j]+=A[i-1][j];
    up(1,k,i) up(1,k,j) B[i][j]+=B[i-1][j];
    up(1,k,i) dn(k,1,j) A[i][j]+=A[i][j+1];
    up(1,k,i) dn(k,1,j) B[i][j]+=B[i][j+1];
    up(-n+1,n-1,i) dn(n-1,-n+1+abs(i),j){
        int x=0,y=j,z=0,u,v,w=0; if(i<0) z=-i; else x=i;
        cnv1(x,y,z,u,v),w+=A[u][v];
        cnv2(x,y,z,u,v),w+=B[u][v];
        printf("%d ",w);
    }
    return 0;
}
```
  - zhongcy（4星）
    - 关键亮点：先介绍二维差分的基本用法，再引入本题的坐标转换方法，将六边形转换为矩形进行差分和前缀和操作，代码简洁明了。
    - 重点代码核心实现思想：与囧仙类似，通过坐标转换函数将原坐标转换到新坐标系，对每次操作在新坐标系的矩形边界进行差分，最后通过前缀和得到最终答案。
```cpp
while(m--)
{
    int x,y,z,r,k,p,q;
    cin>>x>>y>>z>>r>>k;
    
    p=x-z+n;q=y-x+n;
    a[p][min(d,q+r-1)]-=k;
    a[max(1,p-r+1)][min(d,q+r-1)]+=k;
    a[p][max(0,q-r)]-=k;
    a[min(d+1,p+r)][max(0,q-r)]+=k;
    
    p=x-z+n;q=y-z+n;
    b[p][min(d,q+r-1)]+=k;
    b[min(d+1,p+r)][min(d,q+r-1)]-=k;
    b[p][max(0,q-r)]+=k;
    b[max(1,p-r+1)][max(0,q-r)]-=k;
}

for(int i=1;i<=d;i++)
    for(int j=1;j<=d;j++)
        a[i][j]+=a[i-1][j];
for(int i=1;i<=d;i++)
    for(int j=d;j>=1;j--)
        a[i][j]+=a[i][j+1];
for(int i=1;i<=d;i++)
    for(int j=1;j<=d;j++)
        b[i][j]+=b[i-1][j];
for(int i=1;i<=d;i++)
    for(int j=d;j>=1;j--)
        b[i][j]+=b[i][j+1];
        
for(int i=-n+1;i<=n-1;i++)
    for(int j=n-1;j>=1-n+abs(i);j--)
    {
        ll x=0,y=j,z=0;
        (i<0)?z-=i:x=i;
        cout<<a[x-z+n][y-x+n]+b[x-z+n][y-z+n]<<' ';
    }
```
• 最优关键思路或技巧：通过巧妙的坐标转换，将六边形网格中的复杂操作转化为矩形网格中的操作，利用差分和前缀和优化时间复杂度，降低问题求解难度。
• 可拓展之处：同类型题可涉及其他不规则图形区域的操作，类似算法套路为寻找合适的坐标变换将不规则区域转化为规则区域，再结合差分、前缀和等方法求解。
• 相似知识点洛谷题目：
    - P3397 地毯：二维差分基础题。
    - P2004 领地选择：二维差分与前缀和应用。
    - P1387 最大正方形：结合动态规划与二维前缀和。
• 个人心得：无。 

---
处理用时：60.19秒
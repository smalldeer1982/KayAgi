# 题目信息

# 「MCOI-08」Fill In REMATCH

## 题目描述

Dream 有一个长度为 $n$（$1\le n\le 10^5$）的整数数组 $a_1,a_2,\dots,a_n$，其中对于 $i=1,2,\dots,n$，满足 $0\le a_i<2^{60}$。

他计算了前缀异或数组 $p_i=a_1\oplus a_2\oplus\dots\oplus a_i$ 以及后缀异或数组 $s_i=a_i\oplus a_{i+1}\oplus\dots\oplus a_n$。

现在 Tommy **一共**将 $p$ 和 $s$ 的 $n$ 个元素换成 $-1$。给定当前的 $p$ 与 $s$ 数组，请恢复任意一组可能为原数组的 $a_1,a_2,\dots,a_n$。

保证存在一组合法解。

## 说明/提示

对于 $100\%$ 的数据，$1\le n,\sum n\le 10^5$，$\sum [p_i=-1]+\sum [s_i=-1]=n$，**保证有合法解。**

 - Subtask 1（10 pts）：$n\le 4$，$p_i,s_i<2$；
 - Subtask 2（10 pts）：$n\le 100$；
 - Subtask 3（20 pts）：$p_i,s_i<2$；
 - Subtask 4（60 pts）：无特殊限制。


## 样例 #1

### 输入

```
1
4
-1 34 367 -1
3178 -1 -1 3333```

### 输出

```
3 33 333 3333```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均基于异或运算的性质，通过已知的前缀异或数组 \(p\) 和后缀异或数组 \(s\) 来还原原数组 \(a\)。主要利用了 \(a_i = p_i \oplus p_{i - 1} = s_i \oplus s_{i + 1}\) 以及 \(p_i \oplus s_{i + 1} = \bigoplus_{j = 1}^n a_j\) 这两个关键等式。解决难点在于如何根据题目中“一共将 \(p\) 和 \(s\) 的 \(n\) 个元素换成 \(-1\)”这一条件，求出所有数的异或和，进而还原数组 \(p\) 和 \(s\)，最终得到原数组 \(a\)。

各题解的差异主要体现在具体实现细节和代码风格上。部分题解详细推导了异或运算性质及相关引理，部分题解则直接运用关键结论进行求解。

### 所选的题解
1. **作者：Anxiomgh (5星)**
    - **关键亮点**：思路清晰，先详细阐述异或运算的三个性质，由此推导出三个关键引理，对每个引理都进行了严谨证明。代码结构清晰，将求解过程封装为查找和还原两个函数，可读性强。
    - **个人心得**：无
    - **核心代码**：
```cpp
ll find(int n) //查找 
{
    for (int i = 0; i <= n; i++)
        if (p[i]!= -1 && s[i + 1]!= -1)
            return p[i] ^ s[i + 1];
}

void update(ll val, int n) //还原 
{
    for (int i = 0; i <= n; i++)
    {
        if (p[i]!= -1 && s[i + 1] == -1) 
            s[i + 1] = val ^ p[i];
        else if (p[i] == -1 && s[i + 1]!= -1) 
            p[i] = val ^ s[i + 1];
        else if (p[i] == -1 && s[i + 1] == -1)
        {
            p[i] = p[i - 1];
            s[i + 1] = val ^ p[i];
        }
    }
}
```
核心实现思想：`find` 函数通过遍历找到一组已知的 \(p_i\) 和 \(s_{i + 1}\) 求出所有数的异或和。`update` 函数根据异或和，分三种情况更新数组 \(p\) 和 \(s\) 中值为 \(-1\) 的元素。

2. **作者：我是逍逍 (4星)**
    - **关键亮点**：简洁地列举异或运算性质，快速推出关键等式 \(p_i \oplus s_{i + 1} = E\) 以及 \(a_i, p_i, s_i\) 知二求三的关系。代码简洁明了，逻辑清晰。
    - **个人心得**：无
    - **核心代码**：
```cpp
for (int i = 0; i <= n; i++) 
    if (p[i]!= -1 && s[i + 1]!= -1) {
        E = p[i] ^ s[i + 1];
        break;
    }

for (int i = 0; i <= n; i++) {
    if (p[i] == -1 && s[i + 1]!= -1)
        p[i] = E ^ s[i + 1];
    else if (p[i]!= -1 && s[i + 1] == -1) 
        s[i + 1] = E ^ p[i];
    else if (p[i] == -1 && s[i + 1] == -1) 
        p[i] = 1;
    if (i)
        printf("%lld ", p[i] ^ p[i - 1]);
}
```
核心实现思想：先找到一组已知的 \(p_i\) 和 \(s_{i + 1}\) 求出异或和 \(E\)，再根据 \(E\) 分情况更新数组 \(p\) 和 \(s\)，最后根据 \(p\) 数组求出原数组 \(a\)。

3. **作者：Otomachi_Una_ (4星)**
    - **关键亮点**：直接点明关键结论 \(a_i = p_i \bigoplus p_{i - 1} = s_i \bigoplus s_{i + 1}\)，并由此推出 \(p_i \bigoplus s_{i + 1} = p_{i - 1} \bigoplus s_i\)，进而得出必然能找到一个 \(i\) 使得 \(p_i \not= -1, s_{i + 1} \not = -1\)，思路连贯清晰。代码简洁易懂。
    - **个人心得**：考场上思考30分钟，感慨自身能力不足。
    - **核心代码**：
```cpp
for(int i=0;i<=n;i++) if(s[i]!=-1&&t[i+1]!=-1) xx=s[i]^t[i+1];
if(xx==-1) xx=0;
for(int i=0;i<=n;i++)
    if(s[i]!=-1) t[i+1]=xx^s[i];
    else if(t[i+1]!=-1) s[i]=xx^t[i+1];
    else s[i]=0,t[i+1]=xx;
for(int i=1;i<=n;i++)
    cout<<(s[i]^s[i-1])<<" ";
```
核心实现思想：先找到一组已知的 \(s_i\) 和 \(t_{i + 1}\)（即 \(p\) 和 \(s\) 数组）求出异或值 \(xx\)，再根据 \(xx\) 分情况更新数组 \(s\) 和 \(t\)，最后根据 \(s\) 数组求出原数组 \(a\)。

### 最优关键思路或技巧
1. **利用异或运算性质**：归零律 \(a \oplus a = 0\)、恒等律 \(a \oplus 0 = a\)、结合律 \(a \oplus b \oplus c = a \oplus (b \oplus c) = (a \oplus b) \oplus c\) 来推导关键等式，这是解决本题的基础。
2. **确定所有数的异或和**：根据题目条件“\(\sum [p_i = -1] + \sum [s_i = -1] = n\)”，利用鸽巢原理可知必然存在一组 \(i\) 使得 \(p_i \neq -1\) 且 \(s_{i + 1} \neq -1\)，从而求出所有数的异或和，这是还原数组的关键步骤。
3. **分情况讨论还原数组**：根据 \(p_i\) 和 \(s_{i + 1}\) 是否为 \(-1\) 分情况讨论，利用异或和来还原数组 \(p\) 和 \(s\)，进而得到原数组 \(a\)。

### 可拓展之处
同类型题或类似算法套路：此类题目主要考察对异或运算性质的理解和运用，类似套路是通过已知的部分信息（如前缀、后缀的某种运算结果），结合运算性质，找出关键值（如所有元素的某种运算和），再分情况还原原数组。例如，可能会将异或运算换成其他满足特定性质的运算，或者改变已知信息的形式和限制条件，但核心思路类似。

### 相似知识点洛谷题目推荐
1. **P1508 Likecloud-吃、吃、吃**：通过前缀和与异或运算来解决问题，与本题对前缀信息的运用有相似之处。
2. **P3904 三只小猪**：涉及到对数据进行异或处理，利用异或的性质来满足题目要求，和本题运用异或运算性质解题思路类似。
3. **P4195 【模板】扩展欧几里得算法**：虽然主要考察扩展欧几里得算法，但在数论相关运算中，对各种运算性质的运用与本题对异或运算性质的运用在思维方式上有相通之处，都是利用运算特性解决问题。 

---
处理用时：69.69秒
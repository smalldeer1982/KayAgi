# 题目信息

# Two Operations

## 题目背景

**本题时限较小，请采用较快的读入方式，以下是出题人提供的快读模板：**

```cpp
typedef long long LL;
inline LL read(){
	register LL x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
```

当然你也可以采用自己的读入方法。

## 题目描述

在一次聚会上，一共有 $n$ 名学生，他们的编号分别为 $1,2,3,\cdots,n$，他们被分成 $k$ 组，组的编号分别为 $1,2,3,\ldots,k$。

小 V 老师负责组织这场聚会，在聚会的开始，第 $i$ 名学生被分到了第 $a_i$ 组，并拿到了 $b_i$ 颗糖果。（小 V 既不属于任何组别，也没有任何糖果。在接下来的活动中，小 V 作为组织者的身份。） 

这一次聚会一共有 $m$ 轮活动，对于每一轮活动，可能发生以下两种情况之一：

1.  `Change X Y`，表示把所有组别为 $X$ 的学生的组别改为 $Y$（修改后 $X$ 即为空组），并把组 $X$ **删除**。
2.  `Query`，表示小 V 想要知道，如果把**剩下**的组合并（定义见下） 成一大组，那么这一大组内**拥有最多糖果的学生的糖果数最少可能是多少**。

定义一个组 $G_i$ 的大小就是这个组内含有学生的个数，记为 $S_i$。

**合并**：将大小为 $S_1(S_1>0)$ 的组 $G_1$ 合并到大小为 $S_2(S_2>0)$ 的组 $G_2$，其中 $G_1$ 组内所有学生拥有糖果数之和为 $f$，则：

1. 第一步，将原先 $G_1$ 中所有学生的糖果数都变为 $0$，并将他们的组别改为 $G_2$。
2. 第二步，将目前 $G_2$ 中每位学生（包括原先 $G_1$ 中的学生）的糖果数加上 $\dfrac{f}{S_1+S_2}$（糖果数不一定为整数块）。

**注意：**

1. $G_1$ 合并到 $G_2$ 的最后结果可能会与 $G_2$ 合并到 $G_1$ 的最后结果不同。
2. `Query` 中的合并不会真实发生。即在这一次情况过后，所有学生的糖果数与所在组与此次操作未发生前一致。

请将每次 `Query` 中的答案对 $10^9+7$ 取模。（可能是分数取模，如果不知道如何取模请见**提示说明**）

## 说明/提示

【样例解释】

第一次 `Query` 时，将第二组合并到第一组，此时三名学生的糖果数分别为 $\dfrac{14}{3},\dfrac{17}{3},\dfrac{5}{3}$，糖果数最多的同学有 $\dfrac{17}{3}$ 块糖果，取到了最小值，对 $10^9+7$ 取模后为 $666666677$。

第二次 `Query` 时，所有学生都在同一组，而糖果数最多的同学有 $5$ 块糖果。

---

【数据范围】

| 数据点 | $n$  | $m$  | $k$  | $a_i$ | $b_i$  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $1$ | $\le 10$ |无特殊限制 | $\le 10$ | $\le 10$ | $\le 100$ |
| $2$ | $\le 100$ | $\le 10$ | $\le 100$ | $\le 100$ | $\le 100$ |
| $3$ | $\le 10^5$ | $=1$ | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ |
| $4$ | $\le 10^5$ | 无特殊限制 | $=1$ | $=1$ | $\le10^5$ |
| $5$ | $\le 10^3$ |无特殊限制 | $\le 5$ | $\le 5$ | $\le 100$ |
| $6$ | $\le 10^4$ | $\le 10^3$ | $\le 10^4$ | $\le 10^4$ | $\le 10^5$ |
| $7$ | $\le 10^4$ | $\le 5\times10^3$ | $\le 10^4$ | $\le 10^4$ | $\le 10^5$ |
| $8$ | $\le 10^5$ | 无特殊限制 | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ |
| $9 $| $\le 5\times10^5$ | 无特殊限制 | $5\times10^5$ | $5\times10^5$ | $\le 10^5$ |
| $10$ | $\le 10^6$ | 无特殊限制 | $\le 10^6$ | $\le 10^6$ | $\le 10^5$ |

对于 $100\%$ 的数据，满足 $1 \leq n \leq 10^6,\ 1\leq m \leq 2\times k-1,\ 1 \leq a_i\leq k \leq n,\ 1 \leq b_i \leq 10^5$。**数据保证合法，初始时每组是非空的。**


不熟悉有理数取模的请看[此处](/problem/solution/P2613)。


## 样例 #1

### 输入

```
3 3 2
1 1 2
3 4 5
Query
Change 2 1
Query```

### 输出

```
666666677
5```

# AI分析结果

### 综合分析与结论
三道题解均围绕聚会学生分组及糖果操作问题展开，核心是处理两种操作：Change（改变组别）和Query（查询合并后最大糖果数的最小值）。
1. **Anxiomgh题解**：
    - **思路**：先通过引理得出将所有组合并到某一组可使该组合并后最大值最小，预处理计算出将所有组合并到每组后的最大值最小值 \( w_i \)，用优先队列维护 \( w \) 的最小值，在Change操作时更新相关值并处理优先队列。
    - **算法要点**：优先队列维护 \( w \) 数组，通过数组记录淘汰的 \( v_x \) 下标，在优先队列访问到该下标元素时弹出。
    - **解决难点**：分析Change操作对 \( w \) 数组的影响，保证优先队列维护值的正确性。
2. **gyc18题解**：
    - **思路**：先证明 \( G_1→G_2→G_3 \) 优于 \( G_1→(G_2→G_3) \) 及相关引理，得出最终合并情况，设 \( M_i \) 表示特定合并序列下的最大值，通过预处理计算 \( M_i \)，用并查集处理Change操作。
    - **算法要点**：利用引理简化合并情况分析，通过并查集维护元素处理Change操作。
    - **解决难点**：证明相关引理，合理运用并查集维护数据。
3. **qiucr题解**：
    - **思路**：推出每组最终贡献式子，将问题转化为找区间最小值，用线段树维护区间最小值，在Change操作时更新相关状态并修改线段树节点。
    - **算法要点**：线段树的构建、单点修改和查询操作。
    - **解决难点**：正确利用线段树维护和更新数据。

三道题解从不同数据结构和算法角度解决问题，Anxiomgh的优先队列、gyc18的并查集、qiucr的线段树各有特点。从思路清晰度和代码可读性综合考虑，Anxiomgh和qiucr题解相对较好。

### 所选的题解
1. **Anxiomgh题解**：★★★★
    - **关键亮点**：思路清晰，通过引理简化问题，优先队列的运用巧妙，代码实现详细。
    - **核心代码片段**：
```cpp
void init() // 读入并初始化 
{
    n = read(), m = read(), k = read();
    for (int i = 1; i <= n; i++) a[i] = read();
    for (int i = 1; i <= n; i++) b[i] = read();

    for (int i = 1; i <= n; i++)
        S[a[i]]++, f[a[i]] += b[i], v[a[i]] = max(v[a[i]], b[i]), sum += b[i];

    for (int i = 1; i <= n; i++) 
        w[i] = v[i] * n + sum - f[i]; // 计算 w（分子部分） 

    for (int i = 1; i <= k; i++) 
        q.push({i, w[i]}); // 将所有 w push 进队列里 
    for (int i = 1; i <= n; i++) fa[i] = i; // 初始化所有组中的最大值下标 
}

int main()
{
    init();
    while (m--)
    {
        string op;
        cin >> op;
        if (op == "Change")
        {
            int x, y;
            x = read(), y = read();
            f[y] += f[x];   //update
            S[y] += S[x];
            if (max(v[x], v[y]) == v[x])
                flag[fa[y]] = true, fa[y] = fa[x]; // 更新 G_{y} 中的最大值下标
            else
                flag[fa[x]] = true; // G_{x} 被删除，不用更新 fa_{x} 
            v[y] = max(v[x], v[y]); // 更新最大值 
            ll z = v[y] * n + sum - f[y]; // 计算 w'（分子部分） 
            q.push({fa[y], z}); // 将 G_{y} 中最大值的原下标和 w' push 进队列 
        }
        else if (op == "Query")
        {
            while (flag[q.top().pos] == true) // 如果队头元素中包含的最大值已被淘汰
            {
                q.pop(); 
            }
            ll ans = ((q.top().val % p) * pow(n, p - 2)) % p; // 有理数取余
            cout << (ans % p + p) % p << endl;
        }
    }
}
```
    - **核心实现思想**：init函数完成数据读入与初始化，计算每组相关值并将 \( w \) 数组元素放入优先队列。在main函数中，Change操作更新组的相关信息并将新的 \( w' \) 放入优先队列，Query操作弹出已淘汰的队头元素，输出当前队列最小值的取模结果。
2. **qiucr题解**：★★★★
    - **关键亮点**：通过推导式子将问题转化为线段树经典应用，代码简洁明了。
    - **核心代码片段**：
```cpp
void build(int u, int l, int r)
{
    tr[u] = {l, r};
    tr[u].minn = 1e18;
    if (l == r)
    {
        tr[u].minn = w[l];
        return;
    }
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    pushup(u);
}

void modify(int u, int x, ll k)
{
    if (tr[u].l == tr[u].r)
    {
        tr[u].minn = k;
        return;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    if (x <= mid)
        modify(u << 1, x, k);
    else
        modify(u << 1 | 1, x, k);
    pushup(u);
}

signed main()
{
    ios::sync_with_stdio(false);
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++)
    {
        cin >> id[i];
    }
    for (int i = 1; i <= n; i++)
    {
        ll x;
        cin >> x;
        v[id[i]] = max(v[id[i]], x);
        sum[id[i]] += x;
        tot += x;
    }
    for (int i = 1; i <= k; i++)
        w[i] = n * v[i] - sum[i] + tot;
    build(1, 1, k);
    ll inv = qmi(n, mod - 2) % mod;
    while (m--)
    {
        string s;
        cin >> s;
        if (s == "Query")
        {
            cout << tr[1].minn % mod * inv % mod << endl;
        }
        else
        {
            int x, y;
            cin >> x >> y;
            v[y] = max(v[x], v[y]), sum[y] = sum[x] + sum[y];
            v[x] = 0, sum[x] = 0;
            modify(1, x, 1e18);
            modify(1, y, n * v[y] - sum[y] + tot);
        }
    }
    return 0;
}
```
    - **核心实现思想**：build函数构建线段树，modify函数实现单点修改。main函数读入数据并初始化相关数组，构建线段树。在操作循环中，Query操作输出线段树维护的最小值取模结果，Change操作更新组的状态并修改线段树对应节点。

### 最优关键思路或技巧
1. **数学推导简化问题**：通过推导得出将所有组合并到某一组能使该组合并后最大值最小，以及每组最终贡献式子，简化了问题处理。
2. **数据结构巧妙运用**：如优先队列维护最小值、线段树维护区间最小值，高效处理操作。

### 可拓展之处
此类题目属于动态数据维护与查询问题，类似套路是通过数学分析简化问题，选择合适数据结构处理动态操作。同类型题可考虑涉及动态区间查询、修改，以及集合合并与查询的题目。

### 相似知识点洛谷题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：线段树基础区间修改、查询问题。
2. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)：并查集经典应用题目。
3. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)：虽然是素数筛题目，但在数据维护和高效计算上与本题有相似思维方式，可锻炼优化代码和数据处理能力。

### 个人心得
三道题解均未提及个人心得。 

---
处理用时：77.35秒
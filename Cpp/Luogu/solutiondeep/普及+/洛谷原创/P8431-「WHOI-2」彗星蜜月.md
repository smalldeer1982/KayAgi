# 题目信息

# 「WHOI-2」彗星蜜月

## 题目背景

![](bilibili:BV11x411Q7PY)

看完这首 mv 的前奏之后你应该知道 $f$ 是什么鬼了（误）。

## 题目描述

定义 $f(x)$ 是 $x$ 的各位数码翻转以后形成的数。

例如：

- $f(12323)=32321$
- $f(114514)=415411$
- $f(250)=52$
---

给定一个 $n$。求最大的 $k$，使得对于所有处于 $[1,k]$ 区间中的正整数 $m$，有 $f(m)\leq n$。

## 说明/提示

对于测试样例 $1$：
$f(1)=1,f(2)=2,f(3)=3,f(4)=4,f(5)=5,f(6)=6,f(7)=7,f(8)=8,f(9)=9,f(10)=1,f(11)=11,f(12)=21$。所以 $k$ 最大为 $11$。

---
**本题采用捆绑测试**

- $\text{subtask1(10pts)}:1\leq T,n\leq10^3$。
- $\text{subtask2(30pts)}:1\leq n\leq10^6$。
- $\text{subtask3(40pts)}:1\leq n\leq10^9$。
- $\text{subtask4(20pts)}:$ 无特殊限制。

对于 $100\%$ 的数据，$1\leq T\leq10^5,1\leq n\leq10^{18}$。

提示：`unsigned long long` 可以储存 $0$ 到 $18,446,744,073,709,551,615(2^{64}-1)$ 的自然数。 

## 样例 #1

### 输入

```
3
12
991
114514```

### 输出

```
11
298
100001```

## 样例 #2

### 输入

```
2
99999
99998```

### 输出

```
100000
99998```

# AI分析结果

• 综合分析与结论：这些题解主要围绕寻找最大的 $k$，使得对于所有处于 $[1,k]$ 区间中的正整数 $m$，有 $f(m)\leq n$ 展开。多数题解思路是先找出最小的 $m$ 使得 $f(m)>n$，然后输出 $m - 1$。不同题解在寻找这个最小 $m$ 的方式上有所不同，有的通过分类讨论数字 $n$ 的不同形式找规律，有的采用贪心策略，还有的使用二分查找等方法。

  1. **思路对比**：
     - **分类讨论找规律类**：如EthanC_、JackMerryYoung、rzh123等题解，对 $n$ 按是否以 $9$ 开头、是否全为 $9$、是否以 $0$ 结尾等情况进行分类，分别得出答案的构造形式。
     - **贪心策略类**：liangbowen题解通过贪心构造 $f(p)$，保证 $p$ 末尾不为 $0$ 且 $f(f(p)) = p$，从而找到最小的不满足条件的数。
     - **二分查找类**：baiABC题解对值域二分找到最大的满足条件的 $k$，同时通过贪心解决求 $\max\limits_{i = 1}^{m}f(i)$ 的问题。
  2. **算法要点对比**：
     - **分类讨论找规律类**：关键在于准确分析不同类型数字的特征，总结出答案的构造规则，代码实现主要是根据不同分类进行相应的输出构造。
     - **贪心策略类**：重点是按特定规则构造 $f(p)$，通过枚举 $p$ 的每一位加一、处理进位及末尾为 $1$ 等操作，找到最小的不满足条件的数。
     - **二分查找类**：核心是对值域二分，并结合贪心求 $f(i)$ 的最大值来判断当前值是否满足条件。
  3. **解决难点对比**：
     - **分类讨论找规律类**：难点在于全面且准确地对数字进行分类，不遗漏特殊情况，同时要证明每种分类下答案构造的正确性。
     - **贪心策略类**：难点在于设计合理的贪心构造方式，确保找到的数是最小的不满足条件的数，且要理解构造过程中各步骤的意义。
     - **二分查找类**：难点在于设计合适的判断函数用于二分过程中的条件判断，同时要考虑如何优化以避免超时。

  综合来看，不同题解各有优劣，分类讨论找规律类思路直观但情况复杂易遗漏；贪心策略类思路巧妙但理解难度稍大；二分查找类实现相对复杂且对优化要求高。

  以下为3条评分较高(≥4星)的题解：
  - **作者：liangbowen (4星)**
    - **关键亮点**：采用贪心策略，思路清晰独特。通过将问题转化为求最小的 $p$ 使得 $f(p)>n$，然后贪心地枚举 $f(p)$ 的构造方式，时间复杂度为 $O(T \times len(n))$，效率较高。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
void solve()
{
    LL n, minn = 9e18;
    scanf("%lld", &n);
    int len = LEN(n);
    for (int i = 0; i <= len; i++)
    {
        LL p = pow(10, (LL)i); //第 i 位加一。 
        LL ni = n - (n % p) + p; //后面的位全部变成 0。 
        if (ni % 10 == 0) ni++;  // 最后一位变成 1。 
        minn = min(minn, f(ni));
    }
    printf("%lld\n", minn - 1);
}
```
    - **核心实现思想**：通过循环枚举 $n$ 的每一位，将该位加一并把后面的位清 $0$ 且最后一位设为 $1$，构造出可能使 $f(p)>n$ 的数 $ni$，取所有 $f(ni)$ 的最小值减 $1$ 作为答案。
  - **作者：JackMerryYoung (4星)**
    - **关键亮点**：对不同子任务采用不同策略，从暴力到二分再到找规律，逐步优化。对以连续的 $9$ 开头和不以连续的 $9$ 开头等情况进行详细分类讨论并证明，逻辑严谨。
    - **个人心得**：赛时写挂只拿了10分，感慨题目有难度。
    - **核心代码片段**：
```cpp
if(is_all_nine)
    cout << tmpN + 1 << endl;
else
{
    if(tmp[cnt] == 9)
    {
        ull T, pos = 0;
        for(ull i = cnt; i >= 1; -- i)
        {
            if(tmp[i]!= 9)
            {
                T = tmp[i];
                pos = i;
                break;
            }
        }
        if(pos == 1)
        {
            printf("%d", T + 1);
            for(ull i = 1; i <= cnt - 2; ++ i)
                putchar('9');
            puts("8");
            continue;
        }
        putchar('1');
        for(ull i = 1; i <= pos - 2; ++ i)
            putchar('0');
        putchar('0' + T + 1);
        for(ull i = 1; i <= cnt - pos - 1; ++ i)
            putchar('9');
        puts("8");
    }
    else
    {
        cout << 1;
        for(ull i = 1; i <= cnt - 2; ++ i)
            cout << 0;
        cout << tmp[cnt] << endl;
    }
}
```
    - **核心实现思想**：先判断 $n$ 是否全为 $9$，若是则直接输出 $n + 1$。否则，找到第一个非 $9$ 的位，根据其位置和值按不同规则构造答案。
  - **作者：Error_Yuan (4星)**
    - **关键亮点**：通过合理分类讨论，给出了 $O(T\log W)$（$W$ 是值域）的高效做法。对 $n$ 按不同形式分类，如首位是否为 $9$、是否全为 $9$、是否为整十等情况，分别处理得到答案。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
void work() {
    if (tot == 1 && a[1] == 9) {
        printf("10");
        return;
    }
    if (tot == 1) {
        putchar(a[1] + '0');
        return;
    }
    int cur = 1;
    while (a[cur] == 9) cur++;
    if (cur > tot) {
        putchar('1');
        for (int i = 1; i <= tot; i++) putchar('0');
        return;
    }
    if (cur == tot) {
        a[tot] += 1;
        reverse(a + 1, a + tot + 1);
        a[tot] -= 1;
        for (int i = 1; i <= tot; i++) putchar(a[i] + '0');
        return;
    }
    int tmp = cur + 1;
    while (a[tmp] == 0 && tmp <= tot) tmp++;
    if (tmp > tot) {
        a[tot] = 1;
        reverse(a + 1, a + tot + 1);
        a[tot] -= 1;
        for (int i = 1; i <= tot; i++) putchar(a[i] + '0');
        return;
    }
    a[cur] += 1;
    for (int i = cur + 1; i < tot; i++) a[i] = 0;
    a[tot] = 1;
    reverse(a + 1, a + tot + 1);
    a[tot] -= 1;
    for (int i = 1; i <= tot; i++) putchar(a[i] + '0');
    return;
}
```
    - **核心实现思想**：先处理 $n$ 为一位数的特殊情况，然后找 $n$ 中第一个非 $9$ 的位，根据其位置及后续位的情况，按不同规则构造出最小的不满足条件的数减 $1$ 作为答案。

• 最优关键思路或技巧：分类讨论和贪心策略是解决本题的重要思路。分类讨论时要全面考虑数字的各种特征，如开头是否为 $9$、是否全为 $9$、是否以 $0$ 结尾等，准确总结每种情况下答案的构造规律。贪心策略通过合理构造可能的解，直接找到最小的不满足条件的数，避免了不必要的枚举，提高效率。

• 可拓展之处：同类型题通常围绕数字的特殊变换或性质，通过分类讨论、贪心、二分等策略解决。类似算法套路是对数字按特定特征分类，分析每种情况下目标值的特点，从而找到解题方法。

• 推荐洛谷题目：
  - [P1085 不高兴的津津](https://www.luogu.com.cn/problem/P1085)：通过对数据进行简单分析和判断解决问题，可锻炼分类讨论的思维。
  - [P1116 车厢重组](https://www.luogu.com.cn/problem/P1116)：运用贪心策略，通过交换相邻元素使序列有序，与本题贪心找最小不满足条件数思路类似。
  - [P2678 [NOIP2015 普及组] 跳石头](https://www.luogu.com.cn/problem/P2678)：采用二分答案的方法解决问题，与本题二分查找类题解思路相关。 

---
处理用时：88.71秒
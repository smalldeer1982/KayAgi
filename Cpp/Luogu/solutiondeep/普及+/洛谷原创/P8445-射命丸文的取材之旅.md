# 题目信息

# 射命丸文的取材之旅

## 题目背景

射命丸文（Syameimaru Aya）是一只鸦天狗。她不定期制作名为「文文。新闻」的报纸，而为此，她需要对她收集到的新闻进行剪裁。

## 题目描述

射命丸文现在收集到了 $2n$ 条新闻。她想要将其刊登于自己的报刊之上。然而，自己的报刊最多只能刊登 $n$ 条新闻。

为了能在 $n$ 条新闻的篇幅中让自己的报刊得到最大的吸引力，她将这 $2n$ 条新闻**等分**成**两份**，即每一份中均有 $n$ 条新闻。

每一条新闻自然有着其吸引力。在**第一份**中，第 $i$ 条新闻有着吸引力 $a_i$，而在**第二份**中，第 $i$ 条新闻有着吸引力 $b_i$。这两份新闻的划分在输入时已经给定。

现在射命丸文要从中选取新闻放入自己的报刊。报刊上的第 $i$ 条新闻，将选择**第一份**新闻的第 $i$ 条或**第二份**新闻的第 $i$ 条。这样，报刊上的新闻就可以构成一个长度为 $n$ 的序列，第 $i$ 项也就是第 $i$ 条新闻有着吸引力 $c_i \in \{a_i,b_i\}$。

而这样的一份报刊有着其综合影响力。根据射命丸文的经验，对于她这样的一份含有 $n$ 条新闻的报刊，其综合影响力为：

$$\max\{r-l+1-\operatorname{mex}\{c_l,c_{l+1},\dots, c_{r-1},c_r\}\}(1\le l\le r\le n)$$

其中 $\operatorname{mex}\{c_l,c_{l+1},\dots,c_{r-1},c_r\}$ 指的是 $c_l,c_{l+1},\dots,c_{r-1},c_r$ 中没有出现过的**最小非负整数**。

现在她希望知道，在进行这些操作之后，自己的报刊的**最大**的综合影响力会是多少呢？由于她还要继续取材，因此她把这个任务交付给了你。

【形式化题意】

给定序列 $\{a_n\},\{b_n\}$，求一个序列 $\{c_n\}$ 满足 $\forall i\in[1,n],c_i\in\{a_i,b_i\}$，最大化

$$\max\{r-l+1-\operatorname{mex}\{c_l,c_{l+1},\dots, c_{r-1},c_r\}\}(1\le l\le r\le n)$$

并输出该式子可能的最大值。

## 说明/提示

**【样例解释和说明】**

射命丸文可以让自己的 $5$ 条新闻分别取第二份的第 $1$ 条，第一份的第 $2$ 条，第一份的第 $3$ 条，第一份的第 $4$ 条和第二份的第 $5$ 条。这样一来，她的报刊每条新闻的吸引力 $c_i$ 分别为 $0,1,0,1,0$。令 $l=1,r=5$，则 $\operatorname{mex}\{c_1,c_2,c_3,c_4,c_5\}=2$，$r-l+1-\operatorname{mex}\{c_1,c_2,c_3,c_4,c_5\}=3$，不难证明其为数列 $c$ 的综合影响力，也是**所有的可能的** $c$ 的最大综合影响力。

**【数据范围】**

对于 $20\%$ 的数据，满足 $1 \leq n\leq 10$。

另外 $40\%$ 的数据满足 $a_i=b_i$。

对于 $100\%$ 的数据，满足 $1 \leq n\le 10^6$，$0
\leq a_i,b_i\leq n$。

## 样例 #1

### 输入

```
5
0 1 0 1 2
0 2 0 1 0```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
所有题解都基于对 $\text{mex}$ 值进行枚举这一核心思路，利用数据范围 $0\le a_i,b_i \le n$ 的特性，避免直接枚举区间带来的高复杂度。不同之处在于实现细节和对边界情况的处理。

### 所选的题解
- **作者：retep (5星)**
    - **关键亮点**：思路清晰，对枚举 $\text{mex}$ 后计算最大区间长度的原理阐述详细，通过记录 “屏障” 位置来划分区间，代码简洁高效。
    - **核心代码片段**：
```cpp
int n,a[N],ans=-1e9;
vector<int> pos[N];
// 读入略
n=read();
for(int i=1;i<=n;i++)a[i]=read();
for(int i=1,b;i<=n;i++){
    b=read();
    if(b==a[i])pos[b].push_back(i); 
}
for(int i=0;i<=n;i++){
    pos[i].push_back(n+1); 
    for(int j=0,before=1;j<pos[i].size();j++){
        ans=max(ans,pos[i][j]-before-i);
        before=pos[i][j]+1;
    }
}
cout<<ans;
```
    - **核心实现思想**：先读入数据，将 $a_i = b_i$ 的位置记录在 `pos` 数组中，代表 “屏障” 位置。然后对每个可能的 $\text{mex}$ 值（$0$ 到 $n$），在末尾添加一个 “屏障” 方便计算，遍历 “屏障” 划分的区间，更新最大的 $r - l + 1 - \text{mex}$ 值。

- **作者：5k_sync_closer (4星)**
    - **关键亮点**：分情况讨论，先解决特殊子任务，再推广到一般情况，对每种情况的证明和实现步骤详细。
    - **核心代码片段（Subtask 3）**：
```cpp
int n, q, a[1000050], b[1000050], p[1000050], s[1000050];
// 读入略
scanf("%d", &n);
for(int i = 1;i <= n;++i) scanf("%d", a + i);
for(int i = 1;i <= n;++i) scanf("%d", b + i);
for(int i = 1;i <= n;++i) if(a[i] == b[i])
    s[a[i]] = max(s[a[i]], i - p[a[i]] - 1), p[a[i]] = i;
for(int k = 0;k <= n;++k) s[k] = max(s[k], n - p[k]);
for(int x = 0;x <= n;++x) q = max(q, s[x] - x);
return printf("%d", q), 0;
```
    - **核心实现思想**：读入数据后，遍历数组，当 $a_i = b_i$ 时，更新当前值对应的最大区间长度 `s` 和上次出现位置 `p`。遍历结束后，再次更新 `s` 考虑 $r = n$ 的情况，最后枚举 $\text{mex}$ 值 $x$，计算并更新最大的 $r - l + 1 - \text{mex}$ 值。

### 最优关键思路或技巧
枚举 $\text{mex}$ 值而非直接枚举区间，利用 $a_i = b_i$ 作为 “屏障” 划分区间，通过预处理记录这些 “屏障” 位置或更新最大区间长度，从而在 $O(n)$ 时间复杂度内解决问题。

### 可拓展思路
此类题目核心在于利用值域范围优化枚举方式，类似套路可应用于其他涉及 $\text{mex}$ 计算且值域有限的最优化问题。例如，给定多个序列，按特定规则选取元素组成新序列，求新序列满足某种与 $\text{mex}$ 相关的最值。

### 相似知识点洛谷题目
1. [P1595 信封问题](https://www.luogu.com.cn/problem/P1595)：涉及序列元素选择和最值求解，可类比本题枚举思路。
2. [P2671 求和](https://www.luogu.com.cn/problem/P2671)：同样是对序列操作并求最值，有助于理解如何利用数据特性优化算法。
3. [P3951 小凯的疑惑 加强版](https://www.luogu.com.cn/problem/P3951)：通过枚举和分析解决数论相关的最值问题，与本题枚举 $\text{mex}$ 值的思维类似。 

---
处理用时：43.22秒
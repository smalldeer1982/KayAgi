# 题目信息

# 「SWTR-8」美元巨大

## 题目背景

#### 输出不允许有前导零。

原题目名称为「美元巨大二的二的二的二的二」。

小 A 喜欢用形如
$$
\Huge 2 ^ {2 ^ {2 ^ {2 ^ {2}}}}
$$
的幂塔把小 T 的博客炸掉。

## 题目描述

小 A 有 $n$ 个 $2$ 的幂 $a_1, a_2, \cdots, a_n$。他要在这些数之间插入 $x$ 个异或运算符和 $y$ 个或运算符，组成一个表达式。保证 $x + y = n - 1$。

表达式越大，越有可能炸掉小 T 的博客。小 A 希望 **从左往右** 计算表达式时它的值最大。他想知道表达式最大可能的取值是多少，用二进制表示。他还希望你构造出这样的表达式，因为他懒得自己构造了。

若存在多组构造方案，输出任意一组。

多组测试数据。

## 说明/提示

**「评分方式」**

对于每组测试数据：

- 若你输出的第一行比标准答案劣，得 0 分。
- 若你输出的第一行比标准答案优，则 checker 将检查你的构造方案是否正确。若正确，则返回 `_fail`，表现为测试点 UKE；否则得 0 分。
- 否则，你输出的第一行和标准答案一样。若构造方案不正确，得 0.6 分；否则得 1 分。

每个测试点的得分为测试点内所有测试数据的得分的最小值乘以该测试点的分值。

注意，checker 能检测出你的答案比标准答案优的前提是输出完全符合格式。**一旦输出不符合格式，得 0 分**。格式限制包括但不限于：

- 第一行不得输出除 `0` 和 `1` 以外的字符。
- 第二行不得输出除 `^` 和 `|` 以外的字符，且字符串长度恰为 $n - 1$。
- `^` 的个数恰为 $x$，`|` 的个数恰为 $y$。

**「数据范围与约定」**

- 测试点 #1（10 points）：所有 $b_i$ 互不相等。
- 测试点 #2（20 points）：所有 $b_i$ 相等。
- 测试点 #3（30 points）：$n \leq 8$。
- 测试点 #4（25 points）：$n \leq 10 ^ 3$。
- 测试点 #5（15 points）：无特殊限制。

对于 $100\%$ 的数据：

- $1\leq T\leq 20$。
- $1 \leq n \leq 2.5 \times 10 ^ 4$。
- $0 \leq x, y < n$，$x + y = n - 1$。
- $1\leq a_i < 2 ^ {2 ^ {2 ^ {2 ^ 2}}}$，即 $0\leq b_i < 65536$。

**「帮助与提示」**

- 关于 [位运算](https://oi-wiki.org/math/bit/)。
- 请注意 IO 优化。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) B
- Idea & Solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。
- Tester：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
4
4 0 3
1 0 6 4
8 5 2
1 5 5 7 1 5 5 7
1 0 0
15
4 3 0
65535 65535 57 57
```

### 输出

```
1010011
|||
10100000
^|^^^^|
1000000000000000

0
^^^
```

# AI分析结果

• 综合分析与结论：这些题解均采用贪心算法解决该问题，核心思路是利用或运算和异或运算的性质，从高位到低位贪心构造表达式以获取最大值。思路上，都认识到或运算在使结果变大上的优势，对于出现偶数次的位，尽量在最后一次出现时用或运算保留该位为1；对于奇数次的位，用异或运算也能使该位为1。算法要点在于统计每个二进制位出现的次数，并根据奇偶性和剩余运算符情况进行处理。解决难点主要在于合理分配异或和或运算符，同时满足输出格式要求。

所选的题解：
  - 作者：Alex_Wei (5星)
    - 关键亮点：思路清晰简洁，直接点明或比异或更能使结果变大的核心性质，按位从大到小贪心，代码实现简洁高效，对每个出现偶数次的位，在最后分配一个或就能变为1，对多于的或从后往前填入所有空隙，不影响答案。
    - 重点代码及核心实现思想：
```cpp
// 统计每个数出现次数及最后出现位置
for(int i = 1; i <= n; i++) cin >> a[i], buc[a[i]]++, lst[a[i]] = i;
// 按位从大到小贪心
for(int i = W - 1; ~i; i--)
    if(buc[i] & 1) ans[i] = 1;
    else if(y && buc[i]) ans[i] = op[lst[i]] = 1, y--;
// 处理多余的或
for(int i = n; y; i--) if(!op[i]) op[i] = 1, y--;
// 输出结果
bool flag = 0;
for(int i = W - 1; ~i; i--) if(ans[i] || flag) cout << ans[i], flag = 1;
if(!flag) cout << '0';
cout << '\n';
for(int i = 2; i <= n; i++) cout << (op[i]? '|' : '^');
```
此段代码先统计每个数出现次数及最后出现位置，然后按位从大到小贪心处理，根据位出现次数的奇偶性和剩余或运算符的数量确定该位是否为1及对应位置的运算符，最后处理多余的或运算符并输出结果。
  - 作者：jiangxiaohai (4星)
    - 关键亮点：思路阐述详细，从异或和或运算性质出发，逐步推导贪心策略，代码实现中对每个细节都有清晰的注释说明，易于理解。
    - 重点代码及核心实现思想：
```cpp
// 读入数据并统计相关信息
for(int i=1;i<=n;i++)
{
    input[i]=read();
    ket[input[i]]++;
    buc[input[i]]=1;
    maxbit=max(maxbit,input[i]);
    last[input[i]]=i;
}
// 从高位到低位判断每一位是否需要使用|
for(int i=maxbit;i>=0;i--)
{
    if(ket[i]%2==0&&ket[i]>0) 
    {
        if(o>=1) 
        {
            o--;
            keep[i]=1;
        }
        else
            buc[i]=0;
    }
}
// 输出最大值
bool baba=false;
for(int i=maxbit;i>=1;i--)
{
    if(buc[i]!=0)
    baba=true;
    if(baba==true)
    putchar(buc[i]+48);
}
putchar(buc[0]+48);
printf("\n");
// 输出操作方案
for(int i=2;i<=n;i++)
{
    if(xo==0)
        putchar('|');
    else
    {
        if(keep[input[i]]==1&&i==last[input[i]])
        putchar('|');
        else
        {
            xo--;
            putchar('^');
        }
    }
}
```
代码先读入数据并统计每个数出现次数、标记该位是否可能保留、记录最高位及每个数最后出现位置。接着从高位到低位判断每一位是否需要使用或运算来保留该位为1。最后输出最大值和操作方案。
  - 作者：zhenjianuo2025 (4星)
    - 关键亮点：将题意转化清晰，把问题看作二进制高精数每一位的运算，贪心思路明确，按位独立考虑，从高位到低位贪心构造，代码简洁明了。
    - 重点代码及核心实现思想：
```cpp
// 读入数据并统计1出现次数和最后出现位置
for (int i = 1; i <= n; i++) {
    cin >> a[i];
    cnt[a[i]]++, lst[a[i]] = i;   
}
// 按位从高到低贪心
for (int i = 65536; i >= 0; i--)
    if (cnt[i] % 2) ans[i] = 1;   
    else if (y && cnt[i]) ans[i] = 1, opr[lst[i]] = '|', y--;   
// 处理多余的或
for (int i = n; y; i--)
    if (opr[i] == '^') opr[i] = '|', y--;   
// 输出结果
int i = 65536;
while (i >= 0 && ans[i] == 0) i--;
bool flag = false;
for (; i >= 0; i--)
    cout << ans[i], flag = true;
if (!flag) cout << "0";
cout << endl;
for (int i = 2; i <= n; i++)
    cout << opr[i];
cout << endl;
```
先读入数据并统计每一位上1出现的次数和最后出现的位置，然后按位从高到低贪心，根据位上1出现次数的奇偶性和剩余或运算符情况确定该位结果及对应位置运算符，再处理多余的或运算符，最后输出结果和操作方案。

最优的关键思路或技巧：利用位运算性质，按位独立考虑，从高位到低位贪心。通过统计每个二进制位出现的次数，对于出现奇数次的位用异或运算保证该位为1，对于偶数次的位在最后一次出现时用或运算使其为1，多余的或运算符从后往前填充。

可拓展之处：同类型题可涉及更多不同运算符组合的表达式求值问题，类似算法套路是分析不同运算符对结果的影响，按位或按某种顺序贪心处理。

推荐题目：
  - P1080 [NOIP2012 提高组] 国王游戏，涉及贪心策略和高精度计算。
  - P1223 排队接水，典型的贪心算法应用题目。
  - P1199 [NOIP2010 普及组] 三国游戏，考察贪心思想与策略。

个人心得摘录及总结：
  - 作者zhenjianuo2025：%%% Alex巨佬orz orz，让本蒟蒻恍然大悟（还是我弱啊……）。总结：表达对优秀解题思路的赞叹，意识到自身与大佬的差距，激励自己学习。 

---
处理用时：65.43秒
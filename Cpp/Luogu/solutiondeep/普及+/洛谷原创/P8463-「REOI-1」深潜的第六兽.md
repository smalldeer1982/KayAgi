# 题目信息

# 「REOI-1」深潜的第六兽

## 题目背景

“〈十七兽〉全都不会飞。因此，在它们毁灭大地以后，悬浮大陆群还能像这样浮在天空。

“可是，只有〈深潜的第六兽〉在本身留在大地的同时，还能对悬浮大陆群发动攻击。它有两种能力，『分裂增生』和『快速茁壮』。

“留在地表的本体会让身体分裂出几万个碎块，然后随风飞扬，等待碰巧飘流到某座悬浮岛。抵达岛上以后，它会当场发育茁壮，大约六到八小时过后就能占据并毁灭整座岛。”

## 题目描述

现在有一只〈第六兽〉，在某一次的「分裂增生」时分裂出了 $n$ 个碎块，这些碎块会笔直向上飞去，如果其中一块碎块遇到了一座浮空岛（为了研究方便，我们不妨将它当成一条二维空间中的线段处理），便会迅速占据它，并一分为二，再次从浮空岛的两端笔直向上飞去。

不过好在，那些只是一些无关紧要最为荒凉毫无人烟的岛屿，但如果就这样放任它们继续肆虐，势必会给那些至关重要的浮空岛带来毁灭性的打击。于是乎，负责清理〈第六兽〉的军官们，决定以他们所在的岛屿为直线建立 $x$ 轴，并以重力的方向为正方向建立 $y$ 轴，他们总共监测到了 $m$ 座浮空岛，并确定了那些碎块分裂出的位置（距离 $x$ 轴的位置视作无限远），于是他们想知道，如果放任这些碎块，那么当它们到达军官的位置时，最终会有多少碎块。

注意，若一座浮空岛的 $ l_i $ 与 $ r_i $ 相同，即为一个点， 〈第六兽〉占据后仍然会分裂成两只，从这个点向上飞去。

**提示：浮空岛作为实体显然不会重叠。**

**简要题意：**

在一个平面直角坐标系上有 $m$ 条平行于 x 轴的线段，第 $i$ 条线段为 $(l_i,h_i)$ 与 $(r_i,h_i)$ 的连线。特别注意 $l_i$ 可与 $r_i$ 相等，此时线段变为一个点。

在直线 $y=10^9$ 上有 $n$ 个点，分别位于 $(x_i,10^9)$。

现在，这些点逐渐向下（y轴负方向）移动。若触碰到线段，则会一分为二，分裂出的两个点分别从线段的两端继续向下移动。

特别地，若线段为一个点，则会原地分裂成 2 个。

问所有初始点在经历了线段的分裂后，在最后会有多少个点掉在 $ x $ 轴上

## 说明/提示

样例解释：

注意， $y$ 轴正方向为重力方向。
在坐标轴中，横坐标为 $x$ 的碎块，先掉到纵坐标为2的线段上，然后分成两个从 $1$ 和 $3$ 往下掉，$3$ 的那个掉到了纵坐标为1的线段上，分成两个从 $2$ 和 $6$ 往下掉，第一个碎块一共变成了 $3$ 块，分别掉在 $1，2，6$ ，第二个碎块一共变成了两个碎块，分别掉在 $2，6$。

| 子问题 | 特殊限制条件 | 分值 |
| :-----------: | :-----------: | :-----------: |
| 1 | $ 1\leq n,m \leq 10 $ | 10 |
| 2 | $ 1\leq n,m \leq 100 $ | 5 |
| 3 | $ 1\leq n\leq 10^4， 1\leq m \leq 5\times 10^5 $ | 35 |
| 4 |$ 1\leq n,m \leq 5\times 10^5 $|50|

本题各个子问题之间不捆绑测试。

对于 $100\%$ 的数据 $ 1\leq n,m \leq 5\times 10^5 $，所有数字均为非负整数。


## 样例 #1

### 输入

```
2 2
1 3 2
2 6 1
3 5```

### 输出

```
5```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解利用线段按高度排序的特性，通过不同方式计算碎块经过线段分裂后的数量。一种是用线段树维护区间信息，如区间修改和单点查询，模拟碎块分裂过程；另一种是通过记忆化搜索或动态规划，递推计算每个线段对答案的贡献。
    - 算法要点在于如何高效处理线段对碎块的分裂影响。线段树解法重点是利用线段树实现区间赋值、单点查询等操作；DP解法关键是定义合适的状态和转移方程。
    - 解决难点主要是避免重复计算以及高效实现区间操作。暴力解法会因重复计算导致复杂度高，优化方法是利用数据结构（如线段树）或动态规划思想减少冗余计算。

    - 综合质量来看，bsTiat、Disjoint_cat和stntn的题解相对较好，思路清晰，代码实现也较简洁，在复杂度优化和讲解详细度上表现出色。

• 所选的题解：
  - 作者：bsTiat (赞：23)  星级：5星
    - 关键亮点：思路简洁清晰，直接点明用线段树维护贡献值，通过区间修改和单点查询操作解决问题，对操作描述准确，无需复杂代码实现即可理解核心思路。
  - 作者：Disjoint_cat (赞：4)  星级：4星
    - 关键亮点：从暴力解法逐步分析到DP，再到线段树优化，思路推导过程详细，对每种解法的复杂度分析清晰，代码实现规范，还提及数据范围变化时的处理方法。
  - 作者：stntn (赞：4)  星级：4星
    - 关键亮点：从暴力思路出发，详细分析优化方向，最终得出正解，对线段树操作的原理结合题目进行阐述，代码注释清晰，利于理解。

**bsTiat题解核心代码**：无具体代码，思路为将所有线段按纵坐标从小到大排序，用线段树维护掉到每个位置对答案的贡献，初始全部为1。对于排好序的每条线段，先分别询问线段两个端点处的贡献值，然后把这整个线段所覆盖的区间赋值为两个端点处贡献值之和，最后对每个点单点查询，答案累加。

**Disjoint_cat题解核心代码**：
```cpp
// 线段树相关操作
void build(int l,int r,int id)
{
    tr[id].l=l,tr[id].r=r,tr[id].val=1,tr[id].lz=0;
    if(l==r)return;
    int mid=l+r>>1;
    build(l,mid,lid);
    build(mid+1,r,rid);
}
void pd(int id)
{
    if(!tr[id].lz)return;
    tr[lid].lz=tr[rid].lz=1,tr[id].lz=0;
    tr[lid].val=tr[rid].val=tr[id].val;
}
void mdf(int l,int r,int id,ll val)
{
    if(tr[id].l==l&&tr[id].r==r)
    {
        tr[id].val=val,tr[id].lz=1;
        return;
    }
    pd(id);
    if(tr[lid].r>=l)
        if(tr[rid].l<=r)
        {
            mdf(l,tr[lid].r,lid,val);
            mdf(tr[rid].l,r,rid,val);
        }
        else mdf(l,r,lid,val);
    else mdf(l,r,rid,val);
}
ll query(int pos,int id)
{
    if(tr[id].l==tr[id].r)return tr[id].val;
    pd(id);
    if(tr[lid].r>=pos)return query(pos,lid);
    return query(pos,rid);
}
// 主函数部分
int main()
{
    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>a[i].l>>a[i].r>>a[i].h;
        ma=max(ma,a[i].r);
    }
    sort(a+1,a+m+1);
    build(1,ma,1);
    for(int i=m;i>=1;i--)
        mdf(a[i].l,a[i].r,1,(query(a[i].l,1)+query(a[i].r,1))%MOD);
    for(int i=1;i<=ma;i++)an[i]=query(i,1);
    for(int i=1;i<=n;i++)
    {
        cin>>q;
        ans=(ans+an[q])%MOD;
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：先构建线段树，每个节点初始值为1。按高度从大到小遍历线段，对每条线段，查询其两端点贡献值并相加，然后将该线段覆盖区间赋值为这个和，最后对每个初始点进行单点查询累加得到答案。

**stntn题解核心代码**：
```cpp
// 线段树相关操作
inline int pushup(int rt){(sum[rt]=sum[lc]+sum[rc])%=mod;}
inline void pushdown(int rt){if(!cov[rt]) return;cov[rt]=sum[lc]=sum[rc]=0;cov[lc]=cov[rc]=1;}
inline void update_pos(int rt,int l,int r,int pos,int val)
{
    if(l==r){sum[rt]+=val;return;}
    pushdown(rt);
    if(pos<=mid) update_pos(lc,l,mid,pos,val);
    else update_pos(rc,mid+1,r,pos,val);
    pushup(rt);
}
inline void clear(int rt,int l,int r,int L,int R)
{
    if(L<=l&&r<=R){cov[rt]=1;sum[rt]=0;return;}
    pushdown(rt);
    if(L<=mid) clear(lc,l,mid,L,R);
    if(mid<R) clear(rc,mid+1,r,L,R);
    pushup(rt);
}
inline int query(int rt,int l,int r,int L,int R)
{
    if(L<=l&&r<=R) return sum[rt];
    pushdown(rt);int res=0;
    if(L<=mid) (res+=query(lc,l,mid,L,R))%=mod;
    if(mid<R) (res+=query(rc,mid+1,r,L,R))%=mod;
    return res;
}
// 主函数部分
signed main()
{
    read(n,m);
    rep(i,1,m) read(line[i].l,line[i].r,line[i].h);
    rep(i,1,n){int x;read(x);t.update_pos(1,1,M,x,1);}
    sort(line+1,line+1+m);
    rep(i,1,m)
    {
        int l=line[i].l,r=line[i].r;
        int sum=t.query(1,1,M,l,r);
        t.clear(1,1,M,l,r);
        t.update_pos(1,1,M,l,sum);
        t.update_pos(1,1,M,r,sum);
    }
    printf("%lld\n",t.query(1,1,M,1,M)%mod);
    return 0;
}
```
核心实现思想：构建线段树后，按高度从高到低遍历线段，查询线段覆盖区间的碎块数量，清空该区间，然后在线段两端点增加相应数量的碎块，最后查询整个区间的碎块总数得到答案。

• 最优关键思路或技巧：
    - 数据结构选择：使用线段树维护区间信息，能高效实现区间修改和单点查询操作，大大降低时间复杂度。
    - 排序处理：将线段按高度排序，使得处理过程具有顺序性，避免重复计算，同时能清晰地模拟碎块下落分裂的过程。

• 可拓展之处：同类型题通常涉及平面上物体的碰撞、分裂等动态过程，类似算法套路是利用排序将问题按某一维度顺序化，再结合合适的数据结构（如线段树、树状数组等）处理区间操作。

• 相似知识点洛谷题目：
    - P3372 【模板】线段树 1
    - P3373 【模板】线段树 2
    - P1828 [USACO3.4] 香甜的黄油 Sweet Butter 

---
处理用时：85.75秒
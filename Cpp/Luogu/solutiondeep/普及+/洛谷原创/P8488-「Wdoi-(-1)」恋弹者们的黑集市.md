# 题目信息

# 「Wdoi-(-1)」恋弹者们的黑集市

## 题目背景

> 天弓千亦有言：「能力卡终将大势所趋归于陈腐，集市终将回归日常，这是发展规律。」但不知为何和神明所说相悖，卡片的价值遭到了炒作。有人在炒作卡的价值吗废话？又或者说，有倒爷在囤积这些卡片吗？卡片市场秩序完全陷入混乱之时，即便是神明也无法介入的集市，就此出现。

$$\quad\tag*{\small\textit{---TH18.5 恋弹者们的黑集市}}$$

魔理沙正在调查妖怪之山的高地，来收集逸散在各地的能力卡片。就在此时，她遇到了住在此处的驹草山如。

在河童与天狗间游刃有余的驹草山如，掌握着此地大量的资源。显而易见的，她掌握着大量的能力卡片——这正是魔理沙探访的目标。

「想要这些卡片吗，那就让我们玩一个游戏吧」

「赢了，这些卡片就都归你；输了，你可要交出身上所有的卡片。」



## 题目描述

### 原始题意



驹草山如将一个六面写满权值的骰子放在了棋盘上。棋盘上花花绿绿写着很多数字。第 $i$ 行第 $j$ 列写有数字 $a_{i-1,j-1}$。

「你能否获得这些能力卡片，取决于你获得的分数。」

魔理沙有两种方法移动这个骰子：将骰子向下一列**翻转**，或者向下一行**翻转**。值得注意的是，翻转骰子后，骰子每面上的数字就会随着翻滚而改变。现在魔理沙需要将骰子滚动至第 $n$ 行第 $m$ 列。

魔理沙的分数被定义为，所有时刻，骰子与棋盘上的数字接触的那一面的数字，乘上棋盘上该数字，再累加起来的和。只有魔理沙最大化这个和，她才能获取她所需要的卡片。

你能帮帮魔理沙吗？

### 简要题意

有一个 $n\times m$ 大小的棋盘，第 $i$ 行第 $j$ 列写有数字 $a_{i-1,j-1}$。

现在有一个骰子，六个面按照前、后、左、右、上、下的顺序，依次写有数字 $w_0,w_1,w_2,w_3,w_4,w_5$。现在骰子摆放在 $(0,0)$ 位置，需要将它**滚动**至 $(n-1,m-1)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/2l378eln.png)

骰子只有两种方式滚动：向下一行翻滚、向下一列翻滚。我们记一种方案的权值为，整个过程中（包括骰子在起点和终点时），骰子**最底面**上写着的数字，与此时骰子所在格子上写着的数字的乘积之和。

![](https://cdn.luogu.com.cn/upload/image_hosting/4jwvxax5.png)

（为了方便读者阅读，骰子上的数字已经隐去）

现在你需要最大化这个乘积之和。

## 说明/提示

### 样例解释

#### 样例 1 解释

一种最优的方案为，$(0,0)\to(0,1)\to(1,1)\to(1,2)\to(1,3)\to(2,3)\to(3,3)\to(3,4)\to(4,4)$。

总权值为 $2+8+19+19+3+8+8+17+13=97$。

#### 样例 2 解释

一种最优的方案为，$(0,0)\to(0,1)\to(1,1)\to(1,2)\to(1,3)\to(1,4)$。

### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n,m\le} & \textbf{特殊性质} & \textbf{分值} \\\hline
1 & 10 & - & 10 \\\hline
2 & 100 & - & 30 \\\hline
3 & 10^3 & \textbf{A} & 10 \\\hline
4 & 10^3 & - & 50 \\\hline
\end{array}$$

- **特殊性质** $\textbf{A}$：保证 $w_i=1,i=0,1,2,\cdots 5$。

对于全部数据，保证 $1\le n,m\le 10^3$，$|a_i|\le 10^3$，$|w_i|\le 10^3$。

## 样例 #1

### 输入

```
5 5
2 8 15 1 10
5 19 19 3 5
6 6 2 8 2
12 16 3 8 17
12 5 3 14 13
1 1 1 1 1 1
```

### 输出

```
97```

## 样例 #2

### 输入

```
2 5
2 8 15 3 10
5 19 19 3 5
1 2 3 4 5 6```

### 输出

```
194```

# AI分析结果

• 综合分析与结论：这些题解均采用动态规划（DP）算法解决问题。思路核心是通过记录骰子在棋盘不同位置时的状态，来计算能获得的最大分数。算法要点在于合理定义DP数组状态，利用骰子滚动的规律进行状态转移。解决难点主要集中在如何用最少维度表示骰子状态，因为骰子有六个面，若直接用六维表示状态复杂度太高。各题解普遍通过确定骰子两个面（如前面和右面、上面和前面等）来确定整个骰子状态，从而降低复杂度至$O(6^2×nm)$。

- **作者：蒟蒻炒扇贝 (4星)**
  - **关键亮点**：思路清晰，详细阐述了从朴素六维DP数组优化到四维的过程，代码注释详细，易于理解。
  - **个人心得**：无
  - **核心代码片段**：
```cpp
int get_down(int x,int y){//x:front y:right
    if(x==0){
        if(y==2)return 4;
        else if(y==3)return 5;
        else if(y==4)return 3;
        else if(y==5)return 2;
    }
    // 其他情况类似
    return 6;
}
signed main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)a[i][j]=read();
    for(int i=0;i<6;i++)w[i]=read();
    memset(f,-0x3f,sizeof(f));
    f[1][1][0][3]=a[1][1]*w[5];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            if(i==1&&j==1)continue;
            for(int nx=0;nx<6;nx++)for(int ny=0;ny<6;ny++){
                if(get_down(nx,ny)==6)continue;
                int tx=nx,ty=-1;
                // 根据底面状态计算新的front和right状态
                f[i][j][tx][ty]=max(f[i][j][tx][ty],f[i][j-1][nx][ny]+a[i][j]*w[td]);//向下一行翻滚
                ty=ny,tx=-1;
                // 另一种翻滚情况
                f[i][j][tx][ty]=max(f[i][j][tx][ty],f[i-1][j][nx][ny]+a[i][j]*w[td]);//向下一列翻滚 
            }
        }
    int ans=-1e9;
    for(int i=0;i<6;i++)for(int j=0;j<6;j++)ans=max(ans,f[n][m][i][j]);
    printf("%d",ans);
}
```
  - **核心实现思想**：通过`get_down`函数根据骰子当前的front和right状态获取底面状态，在循环中通过模拟两种翻滚方式更新DP数组，最后从终点的所有骰子状态中取最大值。

- **作者：lyt_awa (4星)**
  - **关键亮点**：简洁明了地阐述状态定义、转移方程和初始化，代码简洁，逻辑清晰。
  - **个人心得**：无
  - **核心代码片段**：
```cpp
int U(int q, int y) {
    if (q == 0) {
        if (y == 2) return 5;if (y == 3) return 4;
        if (y == 4) return 2;if (y == 5) return 3;
    }
    // 其他情况类似
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            scanf("%d", &a[i][j]);
    scanf("%d%d%d%d%d%d", &w[0], &w[1], &w[2], &w[3], &w[4], &w[5]);
    memset(f, 0xcf, sizeof(f));
    f[1][1][0][3] = a[1][1] * w[5];
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            for (int q = 0; q < 6; ++q)
                for (int y = 0; y < 6; ++y)
                    if (f[i][j][q][y]!= 0xcfcfcfcf) {
                        f[i + 1][j][U(q, y)][y] = max(f[i + 1][j][U(q, y)][y], f[i][j][q][y] + a[i + 1][j] * w[q]);
                        f[i][j + 1][q][U(q, y)] = max(f[i][j + 1][q][U(q, y)], f[i][j][q][y] + a[i][j + 1] * w[y]);
                    }
    int ans = 0xcfcfcfcf;
    for (int q = 0; q < 6; ++q)
        for (int y = 0; y < 6; ++y)
            ans = max(ans, f[n][m][q][y]);
    printf("%d\n", ans);
    return 0;
}
```
  - **核心实现思想**：`U`函数根据当前骰子前面和右面状态确定上面状态，在循环中利用刷表法更新DP数组，最后从终点所有状态中取最大值。

- **作者：__K2FeO4 (4星)**
  - **关键亮点**：通过打表方式确定骰子底面状态，状态转移方程简洁明了，代码结构清晰。
  - **个人心得**：无
  - **核心代码片段**：
```cpp
const int dw[6][6]={
{0,0,4,5,3,2},
{0,0,5,4,2,3},
{5,4,0,0,0,1},
{4,5,0,0,1,0},
{2,3,1,0,0,0},
{3,2,0,1,0,0}};
signed main(){
    memset(f,0xc0,sizeof(f));
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d",&a[i][j]);
    for(int i=0;i<6;i++)
        scanf("%d",w+i);
    f[1][1][0][3]=a[1][1]*w[5];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            for(int fr=0;fr<6;fr++)
                for(int rt=0;rt<6;rt++){
                    if(fr==rt||(fr^1)==rt||(i==1&&j==1))continue;
                    f[i][j][fr][rt]=max(f[i-1][j][dw[fr][rt]][rt],f[i][j-1][fr][dw[fr][rt]])+w[dw[fr][rt]]*a[i][j];
                }
    int ans=0xc0c0c0c0;
    for(int fr=0;fr<6;fr++)
        for(int rt=0;rt<6;rt++)
            ans=max(ans,f[n][m][fr][rt]);
    printf("%d",ans);
    return 0;
}
```
  - **核心实现思想**：利用`dw`表根据骰子前方和右侧下标确定底面下标，在循环中根据状态转移方程更新DP数组，最后从终点所有状态中取最大值。

• 最优关键思路或技巧：利用骰子只需确定两个面（非相对面）就能确定整体状态的特性，将DP数组维度从六维优化到四维，降低时间复杂度。同时，通过打表或函数计算方式确定骰子翻滚后的状态，简化代码逻辑。

• 可拓展之处：此类题目属于动态规划结合空间物体状态转移问题。类似套路是在复杂状态转移问题中，寻找能确定整体状态的最小信息集合，从而优化DP数组维度。同类型题常涉及物体在特定空间按规则移动并获取最值。

• 推荐题目：
  - [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)：基础的方格移动取数DP问题，可作为此类题目的入门练习。
  - [P1734 最大约数和](https://www.luogu.com.cn/problem/P1734)：通过分析数字间约数关系进行状态转移的DP题，锻炼状态定义和转移方程推导能力。
  - [P2782 友好城市](https://www.luogu.com.cn/problem/P2782)：涉及二维平面上点的配对与路径规划，与本题类似，需合理定义状态和转移方程解决问题。

• 个人心得摘录与总结：无。 

---
处理用时：84.66秒
# 题目信息

# 如何得到 npy

## 题目背景

作为年级第一大风流人物，Steve 总会给自己找很多东西，包括但不限于 npy。Steve 看上了 Ada，并试图接近她，然而 Ada 并不是那么乐意。

## 题目描述

**提示：你可以阅读题目描述末尾的形式化题面。**

Steve 所在的校园有 $n$ 间教室，编号为 $1$ 到 $n$，有 $n-1$ 条走廊将其连通。也就是说，教室和走廊构成了一棵树。每条走廊都有一定的长度 $w_i$，经过这条走廊的时间等于其长度的数值。

Steve 喜欢在校园里游荡。当然，他希望最后能走到自己的教室 $s$ 或 Ada 的教室 $t$。但由于学校过于错综复杂，且 Steve 不想走回头路，所以他想到了如下方案：

对于每个教室（Steve 和 Ada 的教室除外，这两个教室周围不应该有任何标牌），在一条与其相连的边立上标牌。每次走到这个教室，就从立了标牌的边出。

Steve 可能会在学校的任何一个教室出现，所以一方面，Steve 需要让他从每个教室都能跟着标牌回到他的或 Ada 的教室。另一方面，他希望从学校所有教室走到目的地的**时间总和**尽可能小。

由于 Steve 又要去找 Ada 了，所以请你帮他完成这个任务。

#### 形式化题意

给定一棵 $n$ 个节点的无根树和两个关键点 $s,t$，要求对所有边定向，满足：

- 每条边要么是有向边，要么被删除；
- 每个点（除 $s,t$）出度恰好为 $1$，$s,t$ 出度为 $0$；
- 每个点都可以顺着有向边到达 $s$ 或 $t$。

求每个点到 $s$ 或 $t$ 的距离总和最小值。

## 说明/提示

#### 样例 1 解释

`2011` 也是合法的答案，但 `2211`，`1102` 等都不是。

#### 样例 2 解释

下图是取到样例中最优解的状态（$(8,13)$ 这条边没有画出）:

![](https://cdn.luogu.com.cn/upload/image_hosting/78tlf89y.png)

#### 样例 3 解释

该样例满足子任务 2 的限制条件。

#### 样例 4 解释

该样例满足子任务 5 的限制条件。

---

下发文件中还有 `checker.cpp` 可判定答案是否合法。使用时，先编译（设二进制文件为 `checker`（Linux/MacOS）或 `checker.exe`（Windows）），然后在终端输入如下命令：

```
./checker in.txt out.txt ans.txt
```

如果你使用了 Windows 系统且无法运行上述命令，请尝试：

```
checker.exe in.txt out.txt ans.txt
```

其中 `in.txt`、`out.txt`、`ans.txt` 分别是放在同一目录下的输入文件、选手输出、标准答案。

结果可能有如下中的一种：

- `ok`：结果正确，可以得到满分；
- `wrong answer`：第一行答案错误；
- `points 0.60`：第一行答案正确，第二行答案错误。

对于所有非满分情况，会有附加消息，意义如下：

- `A x y`：第一行答案错误，标准答案是 $x$，选手答案是 $y$；
- `B`：第二行长度不符合条件；
- `C`：第二行出现非法字符；
- `D`：第二行给出的构造不满足题目中关于度数的限制；
- `E x y`：第二行给出的构造产生的答案是 $y$，而实际上答案是 $x$。

该校验器和最终评测时采用的校验器可能有所不同。

注意下发文件的输出样例中只有最优答案，没有构造方案。

### 数据规模与约定

**本题捆绑测试**。对于所有数据，$3\le n\le 3\times 10^5$，$1\le w_i\le2\times 10^8$，$1\le s,t\le n$，$s\neq t$。

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c||c|c}\hline

\bf 子任务 & \bf 分值 & \bf 依赖 & n\le & \bf特殊性质
\\
\hline
\hline
1 & 10 & / & 10 & /\\\hline
2 & 15 & 1 & 18 & /\\\hline
3 & 15 & / & / & v_i=u_i+1\\\hline
4 & 10 & / & / & u_i=1\\\hline
5 & 20 & / & / & 存在边\ (s,t)\\\hline
6 & 30 & 2\sim5 &/ & /
\end{array}
$$

如果你计算出了正确的答案，但是你的构造是错误的，那你将得到该测试点 $60\%$ 的分数。注意即使你只实现了第一小问，请依旧在第二行输出任意一个非空字符串，否则可能会不计分。

本题中的依赖指：某子任务的得分占比不能超过其所依赖的子任务得分占比。比如，一选手子任务 $1$ 得到 $60\%$ 的分数，则他的子任务 $2$ 就不会超过对应的 $60\%$ 分数，即不超过 $9$ 分。

答案可能很大，请注意你使用的数据类型。

---

到毕业为止，Steve 也没有追到 Ada。What a sad story. :-(

## 样例 #1

### 输入

```
5 1 5
1 2 1
2 3 1
3 4 1
4 5 1```

### 输出

```
4
2201```

## 样例 #2

### 输入

```
13 4 5
1 3 3
2 3 2
6 4 5
7 4 10
4 8 2
11 8 3
5 13 6
8 13 5
8 3 4
10 5 8
12 10 3
13 9 9```

### 输出

```
85
111121202112```

## 样例 #3

### 输入

```
见下发文件 corridor/corridor3.in```

### 输出

```
见下发文件 corridor/corridor3.ans```

## 样例 #4

### 输入

```
见下发文件 corridor/corridor4.in```

### 输出

```
见下发文件 corridor/corridor4.ans```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均围绕将题目转化为求树上各点到 \(s\) 和 \(t\) 的距离，进而确定边的定向以达到距离总和最小。算法要点多为通过深度优先搜索（DFS）或广度优先搜索（BFS）计算距离，难点在于证明方案的最优性及确定边的定向方式。

### 所选的题解
#### 作者：5ab_juruo (5星)
- **关键亮点**：对各子任务分别分析，思路清晰。先证明答案为 \(\sum_i\min(d(i,s),d(i,t))\)，通过两次DFS分别计算各点到 \(s\) 和 \(t\) 的距离及相关信息，再枚举 \(s\) 到 \(t\) 路径上的边确定最优定向，代码实现简洁高效。
- **个人心得**：无

核心代码片段：
```cpp
void add(int s, int t, int v)
{
    des[e_cnt] = t, val[e_cnt] = v;
    nxt[e_cnt] = hd[s], hd[s] = e_cnt++;
}

ll *sm, *dep;
void dfs(int id, int fa)
{
    siz[id] = 1, sm[id] += dep[id], f[id] = fa;
    for (int p = hd[id]; p!= -1; p = nxt[p])
        if (des[p]!= fa)
        {
            dep[des[p]] = dep[id] + val[p];
            fi[des[p]] = (p >> 1);
            dfs(des[p], id);
            siz[id] += siz[des[p]];
            sm[id] += sm[des[p]];
        }
}

void dfs2(int id, int fa)
{
    for (int p = hd[id]; p!= -1; p = nxt[p])
        if (des[p]!= fa && (p >> 1)!= bne)
        {
            ans[p>>1] = '2' - (p & 1);
            dfs2(des[p], id);
        }
}
```
核心实现思想：`add` 函数用于添加边；`dfs` 函数通过递归计算节点的子树大小、到根节点的距离等信息；`dfs2` 函数用于根据之前确定的最优边来定向其他边。

#### 作者：xwh_Marvelous (4星)
- **关键亮点**：通过直观的图示辅助理解，清晰阐述确定各点到 \(s\) 或 \(t\) 走向的三种情况，两次DFS分别求各点到 \(s\) 和 \(t\) 的距离，再根据距离确定边的定向，代码逻辑清晰。
- **个人心得**：无

核心代码片段：
```cpp
void dfs1(int x, int f, long long d)
{
    a[x]=d;
    for(int i=ls[x].bc;i;i=ls[i].bc)
    {
        if(ls[i].x==f)continue;
        dfs1(ls[i].x,x,d+ls[i].y);
    }
}

void dfs2(int x, int f, long long d)
{
    b[x]=d;
    for(int i=ls[x].bc;i;i=ls[i].bc)
    {
        if(ls[i].x==f)continue;
        dfs2(ls[i].x,x,d+ls[i].y);
    }
}

void dfs3(int x, int f, long long d)
{
    for(int i=ls[x].bc;i;i=ls[i].bc)
    {
        if(ls[i].x==f)continue;
        if(a[ls[i].x]<=b[ls[i].x])hs[ls[i].x]=x,ans+=a[ls[i].x];
        dfs3(ls[i].x,x,d+ls[i].y);
    }
}

void dfs4(int x, int f, long long d)
{
    for(int i=ls[x].bc;i;i=ls[i].bc)
    {
        if(ls[i].x==f)continue;
        if(a[ls[i].x]>b[ls[i].x])hs[ls[i].x]=x,ans+=b[ls[i].x];
        dfs4(ls[i].x,x,d+ls[i].y);
    }
}
```
核心实现思想：`dfs1` 和 `dfs2` 分别从 \(s\) 和 \(t\) 出发DFS计算各点到 \(s\) 和 \(t\) 的距离；`dfs3` 和 `dfs4` 根据距离确定各点的走向并计算总距离。

#### 作者：邈云汉 (4星)
- **关键亮点**：先证明方案的最优性和可行性，思路严谨。通过两次DFS记录各点到 \(s\) 和 \(t\) 的距离，根据距离大小确定边的定向，代码实现简洁明了。
- **个人心得**：无

核心代码片段：
```cpp
void dfs1(int x)
{
    for(int i=head[x];i;i=Next[i])
    {
        if(dis1[ver[i]])continue;
        dis1[ver[i]]=dis1[x]+edge[i];
        ans1[ver[i]]=(i^1)/2;
        dfs1(ver[i]);
    }
}

void dfs2(int x)
{
    for(int i=head[x];i;i=Next[i])
    {
        if(dis2[ver[i]])continue;
        dis2[ver[i]]=dis2[x]+edge[i];
        ans2[ver[i]]=(i^1)/2;
        dfs2(ver[i]);
    }
}
```
核心实现思想：`dfs1` 和 `dfs2` 分别从 \(s\) 和 \(t\) 出发进行DFS，记录各点到 \(s\) 和 \(t\) 的距离以及到达该点的边，后续根据距离确定边的定向。

### 最优关键思路或技巧
1. **思维方式**：将边定向问题转化为求树上各点到 \(s\) 和 \(t\) 的距离问题，利用树的性质简化问题。
2. **算法优化**：通过两次DFS分别计算各点到 \(s\) 和 \(t\) 的距离，避免复杂的图算法，时间复杂度为 \(O(n)\)，高效解决问题。

### 可拓展之处
此类题目属于树上路径与图定向的结合问题，类似套路可应用于其他树上路径优化、图的连通性及定向问题。例如，给定不同限制条件下求树上节点到特定点集的最优路径等。

### 推荐题目
1. [P3478 [POI2008]STA-Station](https://www.luogu.com.cn/problem/P3478)：同样是关于树的路径和距离问题，通过树形DP求解。
2. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)：树型DP经典题目，涉及树上节点的选择与最优值求解。
3. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)：在二叉树上进行决策，删除边以满足特定条件下的最优值问题。 

---
处理用时：61.05秒
# 题目信息

# 「Wdoi-2」来自地上的支援

## 题目背景

波光粼粼的山顶湖与庄严神圣的神社之下，是一座复合型活火山。  
沿幻想风穴而下，便能到达火山之下，废弃已久的地狱原址。   
>在旧地狱中，有一座大都市。那里是旧地狱还是地狱的时候在那工作的众鬼们居住的地方，只有那里亡者们是无法踏入去的。后来地狱体制改革，机构搬离了这个地方。  
因为这个缘故这块地狱变成了废墟，但却有一部分看上了那里的妖怪擅作主张占领了那里，于是就成了如今的旧地狱了。
这里比地上更没有秩序可言。悍匪恶霸，特别是惹人类讨厌的家伙都喜欢搬到这边定居下来。

自旧地狱喷泻而出的间歇泉，给妖怪之山带来了优良的温泉，也喷出了大量的怨灵。

为了解决这次异变，乐园的巫女和普通的魔法使结伴而行，在来自地上的支援下，自幻想风穴直冲地底。

先后结（bao）识（da）了黑暗洞窟中的明亮之网、地壳下的嫉妒心、人们所谈论的怪力乱神后，二人来到了遗址中心的洋馆，地灵殿。

受这里主人的指引，二人来到了位于深处的间歇泉地下中心。

## 题目描述

### 简要题意
给定正整数 $n$、$v$ 和长度为 $n$ 的数组 $\{A_i\}$。

有一个长度为 $n$ 的数组 $B$，初始值与 $A$ 相同。 
执行 $n$ 次操作，第 $i$ 次操作在 $[1,i]$ 中按如下规则选取一个正整数 $j$，然后把 $B_j$ 变成 $B_j+v$：
- 选取 $B_j$ 最大的 $j$。
- $B_j$ 相同时选择 $A_j$ 最大的 $j$。
- $A_j,B_j$ 均相同，选择较小的 $j$。

我们称这是选中了一次 $j$。

有 $m$ 次询问，每次询问给定 $x_i,k_i$。表示求最小的 $s$，使得**若**将 $A_{x_i}$ 的初始值改为 $s$（注意此时 $B_{x_i}$ 的初始值也会跟着改变），$x_i$ 至少被选中 $k_i$ 次，或报告不存在（**结果为** $0$）。请注意，$s$ 不存在最小值时也是报告不存在（**结果为** $0$）。

询问之间互相独立，也就是每次询问不会对 $A_{x_i}$ 和 $B_{x_i}$ 产生实质性更改。

### 原始题意

到达控制中心之后，主角组和灵乌路空进行了激烈的狗斗大赛。负责技术维护的河童需要接受荷取来自地上指挥部的指令，保障生产安全。

具体地，有 $n$ 个核反应机组依次排开，第 $i$ 个机组的活动强度为 $A_i$。为了维护平衡，控制系统依次操作 $n$ 次，第 $i$ 次操作会在前 $i$ 个机组中找到一个**当前活动度最高的**机组，进行一次调节平衡操作，并将其活动度增加 $v$。倘若有多个机组活动度最高，就应当选择初始活动度**最大**的，若还是无法比较，则取编号最小。

为了在自动控制系统的基础上调节平衡，荷取会发出 $m$ 条指令，形如她每次会给出两个整数 $x_i,k_i$，表示她会修改第 $x_i$ 个机组的初始活动度。她希望通过修改（必须改成一个**非负整数** $s$）后，$x_i$ 号机组至少被平衡 $k_i$ 次。如果无论如何都无法达到要求，那么结果就是 $0$；否则请求出满足条件的**最小的** $s$。

## 说明/提示

### 样例 1 解释

对于第一次询问，我们将 $A_3$ 修改为 $7$。

- 第一次操作选择了位置 $1$，于是 $B_1$ 变为 $4$。
- 第二次操作选择了位置 $2$，于是 $B_2$ 变为 $7$。虽然操作前 $B_1=B_2$，但是 $A_2>A_1$，因此选择位置 $2$。
- 第三次操作选择了位置 $3$，于是 $B_3$ 变为 $10$。
- 第四次操作选择了位置 $3$，于是 $B_3$ 变为 $13$。
- 第五次操作选择了位置 $3$，于是 $B_3$ 变为 $16$。
- 第六次操作选择了位置 $3$，于是 $B_3$ 变为 $19$。
- 第七次操作选择了位置 $3$，于是 $B_3$ 变为 $22$。

于是位置 $3$ 一共被选择了 $5$ 次，满足题意。可以证明，如果把 $A_3$ 的初始值设为 $6$，无法达成要求。于是该询问结果为 $7$。

对于第二个询问，容易发现不可能有 $4$ 次以上操作选择位置 $6$。因此该询问结果为 $0$。

$7\oplus 0=7$，$7+0=7$，因此输出 $7,7$。

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n,m\le} & \bm {a_i\le } & \bm{v\le} & \textbf{分值} \cr\hline
1 & 10 & 100 & 10 & 10 \cr\hline
2 & 100 & 5\times 10^3 & 50 & 20 \cr\hline
3 & 10^3 & 10^9 & 100 & 10 \cr\hline
4 & 10^5 & 10^9 & 100 & 25 \cr\hline
5 & 2\times 10^6 & 10^9 & 100 & 35 \cr\hline
\end{array}$$

对于全部数据，满足 $1 \le n,m \le 2\times 10^6$，$1 \le v \le 100$，$1 \le a_i \le 10 ^ 9$，$1 \le x,k \le n$。

**本题 IO 量较大，请选择合适的输入方式。**

## 样例 #1

### 输入

```
7 2 3
1 4 1 5 4 1 1
3 3
6 4```

### 输出

```
7 7```

## 样例 #2

### 输入

```
10 10 9
14 91 84 13 97 92 23 64 31 10 
5 2
5 5
9 1
2 6
9 1
5 4
3 5
2 8
8 2
5 4
```

### 输出

```
245 1177
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效解决给定数组操作及多次询问的问题。核心思路多基于对操作性质的挖掘，利用数据结构优化查询。
1. **离散小波变换°的题解**：发现操作选择值构成公差为\(v\)的等差数列这一性质，提出\(O(n\log n)\)和\(O(n)\)两种做法。前者将等差数列压段维护，指针从右向左扫，均摊\(O(1)\)更新，查询时二分；后者通过移项转化条件，利用前缀最值数组求解。
2. **Dregen_Yor的题解**：先得出选中数的操作区间规律，朴素做法用前缀数组维护前\(x - 1\)次操作最大值，向后枚举\(k - 1\)个数更新答案得部分分。优化时用线段树维护区间最大值及坐标，通过比较大小确定答案。
3. **MarchKid_Joe的题解**：将询问拆为\([1, x - 1]\)和\([x + 1, x + k - 1]\)两区间贡献。前者用优先队列预处理模拟得到区间最大值，后者预处理\(c_i = a_i - v\times i\)并用线段树维护其区间最大值，综合两部分取最大值得答案。
4. **littlez_meow的题解**：先\(O(n)\)预处理未修改时每次选中的数，得出数被选的规律。分析出不同情况下\(s\)的取值，因相等情况未处理好只能得部分分，后通过二分优化，最坏时间复杂度\(O(n + mk)\)。
5. **NianFeng的题解**：分析操作特点，得出要让\(x_i\)被取到及取到\(k_i\)次的条件。通过预处理将初始数组统一减少，用线段树维护\(A_i - v\times i\)的区间最大值，结合递推式统计答案。
6. **E1_de5truct0r的题解**：观察到数若未成为最大值则不再可能成为最大值的性质。通过维护\(pre\)数组判断\(a_i\)是否为\(1\sim i\)的最大值，用线段树维护\(a_i - i\times v\)的区间最大值判断\(a_i\)比后面\(k\)个数大，同时考虑线段树维护最大值位置及\(a\)值大小关系调整答案。

整体来看，离散小波变换°的题解思路清晰，给出两种不同复杂度做法且对性质挖掘深入；NianFeng和E1_de5truct0r的题解也较为清晰，通过合理预处理和线段树维护解决问题。

### 所选的题解
1. **离散小波变换°的题解**：★★★★★
    - **关键亮点**：深入挖掘操作性质，提出两种时间复杂度不同的做法，对问题分析透彻，代码简洁高效。
    - **核心代码片段**：
```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN =1e7+3;
int n,m,v,w,l,F[MAXN],G[MAXN],A[MAXN],X[MAXN],K[MAXN];
i64 ans1,ans2; char _file[256];
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(int argc,char **argv){
    n=qread(),m=qread(),v=qread();
    up(1,n,i) A[i]=qread();
    up(1,m,i) X[i]=qread(),K[i]=qread();    
    A[0]=-INF;
    up(1,n,i){
        A[i]=w=A[i]-i*v;
        if(w>=A[F[i-1]]) G[i]=F[i-1],F[i]=i; else
        if(w>=A[G[i-1]]) G[i]=i,F[i]=F[i-1]; else
        G[i]=G[i-1],F[i]=F[i-1];
    }
    up(1,m,i){
        int x=X[i],k=K[i],y=x+k-1; l=0;
        if(y<n) l=max(0,x*v+(F[y]==x?A[G[y]]+(G[y]>x):A[F[y]]+(F[y]>x)));
        ans1^=l,ans2+=l;
    }
    printf("%lld %lld\n",ans1,ans2);
    return 0;
}
```
    - **核心实现思想**：先对数组\(A\)进行预处理，减去\(i\times v\)得到\(w\)，通过比较\(w\)与之前记录的最值相关值更新\(F\)和\(G\)数组。对于每次询问，根据\(F\)和\(G\)数组及相关条件计算答案。
2. **NianFeng的题解**：★★★★
    - **关键亮点**：思路清晰，通过对操作和询问的细致分析，合理预处理并用线段树维护关键值，代码简洁明了。
    - **核心代码片段**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
namespace io{
    inline int read(){
        int x=0;
        bool flag=true;
        char c=getchar();
        while(c<'0'||c>'9'){
            if(c=='-')
                flag=false;
            c=getchar();
        }
        while(c>='0'&&c<='9'){
            x=(x<<1)+(x<<3)+c-'0';
            c=getchar();
        }
        return (flag?x:~(x-1));
    }
}
using namespace io;
const int N=2000100;
int n,m,v,a[N];
int low[N];
int tree[N<<2]; 
void build(int root,int l,int r){
    if(l==r){
        tree[root]=a[l]-v*l;
        return;
    }
    int mid=l+r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    build(leftroot,l,mid);
    build(rightroot,mid+1,r);
    tree[root]=max(tree[leftroot],tree[rightroot]);
}
int query(int root,int l,int r,int L,int R){
    if(L<=l&&r<=R){
        return tree[root];
    }
    int mid=l+r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    int ans=-1e9;
    if(L<=mid) ans=max(ans,query(leftroot,l,mid,L,R));
    if(mid<R) ans=max(ans,query(rightroot,mid+1,r,L,R));
    return ans;
}
signed main(){
    n=read(),m=read(),v=read();
    for(int i=1;i<=n;i++) a[i]=read();
    low[1]=0; for(int i=2;i<=n;i++){
        low[i]=max(low[i-1]+v,a[i-1]+v);
    }
    build(1,1,n);
    int ans1=0,ans2=0;
    while(m--){
        int x=read(),k=read();
        if(x+k-1>n) continue;
        int tmp=max(low[x],(query(1,1,n,x+1,x+k-1)+v*x+1));
        ans1^=tmp,ans2+=tmp;
    }
    cout<<ans1<<" "<<ans2<<endl;
    return 0;
}
```
    - **核心实现思想**：通过线段树维护\(a_i - v\times i\)的区间最大值，利用递推式计算取到\(x\)位置的下限\(low\)数组。对于每次询问，结合\(low\)数组和线段树查询结果计算答案。
3. **E1_de5truct0r的题解**：★★★★
    - **关键亮点**：观察到关键性质，通过维护前缀最大值数组和线段树分别处理前后区间条件，思路较清晰。
    - **核心代码片段**：（因原代码需点击链接查看，此处假设关键部分如下）
```cpp
// 假设维护pre数组
for (int i = 1; i <= n; i++) {
    pre[i] = max(pre[i - 1] + v, a[i]);
}
// 线段树部分假设类似其他题解
void build(int root, int l, int r) {
    if (l == r) {
        tree[root] = a[l] - l * v;
        return;
    }
    int mid = l + r >> 1;
    build(root << 1, l, mid);
    build(root << 1 | 1, mid + 1, r);
    tree[root] = max(tree[root << 1], tree[root << 1 | 1]);
}
int query(int root, int l, int r, int L, int R) {
    if (L <= l && r <= R) {
        return tree[root];
    }
    int mid = l + r >> 1;
    int ans = -1e9;
    if (L <= mid) ans = max(ans, query(root << 1, l, mid, L, R));
    if (mid < R) ans = max(ans, query(root << 1 | 1, mid + 1, r, L, R));
    return ans;
}
// 询问部分假设如下
while (m--) {
    int x, k;
    cin >> x >> k;
    if (x + k - 1 > n) continue;
    int maxAfter = query(1, 1, n, x + 1, x + k - 1) + x * v;
    int res = max(pre[x - 1], maxAfter);
    // 处理最大值位置及a值大小关系调整答案（假设部分代码如下）
    if (maxPosAfter && a[maxPosAfter] > res) {
        res++;
    }
    ans1 ^= res;
    ans2 += res;
}
```
    - **核心实现思想**：先维护\(pre\)数组记录到\(i\)位置的最大值。通过线段树维护\(a_i - i\times v\)的区间最大值，在询问时，结合\(pre\)数组和线段树查询结果，并根据最大值位置及\(a\)值关系调整答案。

### 最优关键思路或技巧
1. **性质挖掘**：如离散小波变换°发现操作选择值构成等差数列的性质，为优化解法提供基础。
2. **预处理与转化**：将原数组通过减去\(v\times i\)进行预处理，简化比较操作，如NianFeng和E1_de5truct0r的题解。
3. **数据结构应用**：利用线段树维护区间最大值，高效处理区间查询问题，多数题解都采用此方法。

### 可拓展思路
此类题目可拓展到更多基于数组操作及多次查询的场景，类似算法套路是挖掘操作性质，通过预处理简化问题，选择合适数据结构（如线段树、单调队列等）优化查询。例如，当操作规则变化或查询类型改变时，依然可从这几个方面入手分析。

### 相似知识点洛谷题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：基础线段树模板题，用于巩固线段树的基本操作。
2. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)：涉及区间操作和动态规划，与本题分析操作性质及处理区间问题有相似之处。
3. [P2824 [HEOI2016/TJOI2016]排序](https://www.luogu.com.cn/problem/P2824)：通过分析操作对数据的影响，结合二分等方法解决问题，与本题思维方式类似。

### 个人心得摘录与总结
**littlez_meow**：比赛时调了很久，最初做法因未考虑下标\(\min\)情况只能得部分分，后通过观察\(s\)与是否选取的单调性，采用二分得到最优解。总结为做题时要全面考虑条件，注意边界情况，善于观察性质进行优化。 

---
处理用时：116.63秒
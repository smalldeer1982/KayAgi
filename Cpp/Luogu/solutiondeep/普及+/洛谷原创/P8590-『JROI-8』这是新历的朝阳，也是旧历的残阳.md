# 题目信息

# 『JROI-8』这是新历的朝阳，也是旧历的残阳

## 题目背景

![1663764375173.png](https://img-kysic-1258722770.file.myqcloud.com/8c10be566f21cceb653f209300936b97/68a6764e14651.png)

>少女于海边伫立，凝视着落日最后的余晖\
“已然过去了呢，旧历的一年......”

**已获得转载授权。**

## 题目描述

给定序列 $\{a_n\}$，满足每一项都不小于前一项。对于所有不超过 $k$ 的正整数 $m$，询问如果将 $a$ 分成 $m$ 段（可以有空段），并给从前往后第 $i$ 段内的每个数都加上 $i$，增加后的 $\sum\limits_{j=1}^n a_j^2$ 最大是多少。询问相互独立，即每次询问时给每个数加的值不保留到下一次询问。

例如，对于序列 $\{-3,1,2,2\}$，若 $m=5$，则一种分段方式是 $[-3][][1,2][][2]$，增加后的序列是 $-2,4,5,7$，此时 $\sum\limits_{j=1}^n a_j^2=94$。

记 $m=i$ 时的答案（即此时最大的 $\sum\limits_{j=1}^n a_j^2$）为 $q_i$，出于良心考虑，你只需要输出 $\left(\sum\limits_{i=1}^k q_i\right) \bmod 998244353$ 即可。标准程序不基于特殊的输出方式，即能独立求出每一个 $q_i$。


## 说明/提示

#### 【样例解释】

当 $m=1$ 时，最优策略是 $[-3,1,2,2]$，$q_1=(-2)^2+2^2+3^2+3^2=26$。

当 $m=2$ 时，最优策略是 $[-3][1,2,2]$，$q_2=(-2)^2+3^2+4^2+4^2=45$。

当 $m=3$ 时，最优策略是 $[-3][][1,2,2]$，$q_3=(-2)^2+4^2+5^2+5^2=70$。

则 $\left(\sum\limits_{i=1}^k q_i\right) \bmod 998244353=(q_1+q_2+q_3)\bmod 998244353=(26+45+70)\bmod 998244353=141$。

#### 【数据范围与约束】

| 测试点编号 | 分数 | $n\leq$ | $k\leq$ | $\lvert a_i\rvert \leq$ | 特殊性质 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $1\sim 3$ | $15$ | $12$ | $12$ | $1000$ | 无 |
| $4\sim 6$ | $15$ | $1000$ | $1000$ | $1000$ | 无 |
| $7\sim 8$ | $10$ | $10^6$ | $10^6$ | $10^7$ | $a_i\geq0$ |
| $9 \sim 12$ | $20$ | $10^6$ | $1000$ | $10^7$ | 无 |
| $13\sim 20$ | $40$ | $10^6$ | $10^7$ | $10^7$ | 无 |


## 样例 #1

### 输入

```
4 3
-3 1 2 2```

### 输出

```
141```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均基于贪心策略，并结合数学推导与优化来解决问题。
1. **思路**：利用序列单调不减且可有空段的性质，贪心认为每个数要么放第一段要么放最后一段。负数在满足一定条件（如\((a_i + 1)^2 \leq (a_i + m)^2\)）时放最后一段，否则放第一段；正数放最后一段。
2. **算法要点**：通过前缀和维护平方和与一次项和，优化计算平方和的过程。部分题解通过推导相邻分段结果的差值，实现\(O(1)\)时间复杂度更新答案。
3. **解决难点**：处理负数在不同分段情况下的归属问题，以及优化计算过程以满足大数据范围。部分题解在推导过程中注意取模防止溢出，以及数组类型和大小避免空间超限。

综合质量来看，wdgm4、ScottSuperb、xwh_Marvelous 的题解相对较好，思路清晰、代码有注释且优化到位。

### 所选的题解
1. **作者：wdgm4（5星）**
    - **关键亮点**：先给出暴力思路辅助理解，再详细阐述AC思路。通过转换求和顺序，利用前缀和优化，分正负情况讨论，思路清晰，对取模、数据类型等细节有详细说明。
    - **个人心得**：考试时因未考虑爆long long痛失30分，强调取模和数据类型处理的重要性。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define XD 114514
using namespace std;
long long n,k;
long long m,f;
const long long mod=998244353;
const int MAXN=20000000;
long long a[1000010];
long long ans,num;
int b[20000010];//前缀和
int main(){
    cin>>n>>k;
    for(long long i=1;i<=MAXN;i++){
        b[i]=(b[i-1]+i*i%mod)%mod;//计算前缀和
    }
    for(register int i=1;i<=n;i++){
        num=0;
        scanf("%lld",&a[i]);
        if(a[i]<0){//分情况讨论
            m=(a[i]+1)*(-2)+1;
            f=-(a[i]+1);
            num+=min(m,k)*1ll*f%mod*f;//注意这里一定要取模一次，不然会爆long long
            num%=mod;
            if(k>m){
                num+=(b[k-m+f]*1ll-b[f]+mod)%mod;
                num%=mod;
            }
        }else{
            num+=(b[a[i]+k]*1ll-b[a[i]]+mod)%mod;
            num%=mod;
        }
        ans+=num;
        ans%=mod;
    } 
    cout<<ans%mod;
    return 0;
}
```
    - **核心实现思想**：预先计算平方和前缀和数组`b`。遍历数组`a`，对负数通过计算临界值`m`，分情况计算其对答案的贡献；对正数直接利用前缀和计算贡献，累加所有数的贡献得到最终答案。
2. **作者：ScottSuperb（4星）**
    - **关键亮点**：从贪心角度出发，详细分析正负数情况，结合完全平方公式推导每轮结果的变化，代码实现简洁明了，变量命名有一定自解释性。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 998244353
ll a[1000005];
int main() {
    int n = read(), k = read(), b = 0;
    ll q = 0, ans = 0, psum = 0, del;
    for (int i = 0; i < n; ++i)
        a[i] = read(), b += a[i] < 0, q = (q + (a[i] + 1) * (a[i] + 1) % mod) % mod;
    ans += q;
    for (int i = b; i < n; ++i) psum = (psum + a[i] + 1 % mod) % mod;
    n = n - b;
    for (int m = 2; m <= k; ++m) {
        ans = (ans + (q = (q + psum * 2 % mod + n) % mod)) % mod,
        psum = (psum + n) % mod;
        while (b > 0 && a[b - 1] + m > abs(a[b - 1] + 1)) {
            --b, ++n;
            del = (a[b] + m) * (a[b] + m) % mod - (a[b] + 1) * (a[b] + 1) % mod;
            ans = (ans + del) % mod, q = (q + del) % mod, psum = (psum + (a[b] + m) % mod) % mod;
        }
    }
    write(ans);
    fls();
    return 0;
}
```
    - **核心实现思想**：先统计第一轮各变量值，`b`记录负数个数，`q`记录第一轮平方和。循环中，根据正数的规律更新`q`和`psum`，同时检查负数是否满足移动到最后一段的条件，若满足则更新相关变量和答案。
3. **作者：xwh_Marvelous（4星）**
    - **关键亮点**：通过分析数的绝对值与平方的关系，得出数要么在第一段要么在最后一段的结论。进一步推导数在不同段的条件，并利用单调性优化，代码实现简洁高效。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=998244353;
int n,k,pos;
ll a[1000005],ans,tot1,tot2,tot3;
int main(){
    scanf("%d%d",&n,&k);
    pos=n;
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]),tot3+=(a[i]+1)*(a[i]+1),tot3%=mod;
    for(int i=1;i<=k;i++){
        tot2+=2*tot1+(n-pos),tot2%=mod;
        tot1+=(n-pos),tot1%=mod;
        while(pos>0&&abs(a[pos]+i)>abs(a[pos]+1)){
            tot3-=(a[pos]+1)*(a[pos]+1),tot3%=mod,tot3+=mod,tot3%=mod;
            tot1+=a[pos]+i,tot1%=mod;
            tot2+=(a[pos]+i)*(a[pos]+i),tot2%=mod;
            pos--;
        }
        ans+=tot2+tot3;
        ans%=mod;
    }
    printf("%lld",ans);
    return 0;
}
```
    - **核心实现思想**：初始化`pos`为数组末尾，`tot3`记录初始平方和。循环中，根据`pos`位置数的绝对值比较结果，决定是否移动`pos`，同时更新`tot1`、`tot2`、`tot3`，累加得到最终答案。

### 最优的关键思路或技巧
1. **贪心策略**：基于题目条件，利用数的正负性及平方函数性质，贪心确定数在第一段或最后一段放置，简化问题。
2. **数学推导与优化**：通过完全平方公式展开，推导相邻分段结果的差值，实现\(O(1)\)更新答案。利用前缀和优化平方和及一次项和的计算。
3. **单调性利用**：利用序列单调不减的性质，确定负数移动到最后一段的位置具有单调性，减少计算量。

### 可拓展之处
此类题目属于序列分段与最值求解结合的问题，相似套路为利用序列性质（单调性等）进行贪心决策，通过数学推导优化计算过程。类似题目可考虑拓展到不同的序列操作（如乘法、异或等）、不同的最值目标（如最小化差值等）。

### 推荐题目
1. **P1223 排队接水**：贪心算法经典题目，通过对数据的排序和贪心策略求解最优方案。
2. **P1094 纪念品分组**：利用贪心策略，结合数据排序解决分组问题，考察对贪心思想的应用。
3. **P1199 三国游戏**：涉及贪心和博弈思想，通过分析游戏规则，运用贪心策略寻找最优解。 

---
处理用时：79.45秒
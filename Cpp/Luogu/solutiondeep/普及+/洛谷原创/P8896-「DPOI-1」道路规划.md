# 题目信息

# 「DPOI-1」道路规划

## 题目背景

不可以，总司令。

## 题目描述

战场上有 $n$ 个据点，从 $1\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。

一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。

## 说明/提示

#### 样例 #1 解释
下面是第 $1$ 组数据中一种可行的方案：

![](https://cdn.luogu.com.cn/upload/image_hosting/2uvwlydw.png)

#### 样例 #2 解释
该样例满足测试点 $3 \sim 6$ 的限制。
#### 数据范围
**本题测试点分数不等分。**

|  测试点编号  | $n \le$ | 特殊条件 |每个测试点分数|
| :----------: | :-----------: | :------: | :----: |
|     $1\sim 2$      |     $10$     |   无   |$5$|
|     $3\sim 6$      |     $1000$     |    无     |$5$|
|     $7\sim 8$      |     $10^5$     |    所有 $l_i = i-1$ 或所有 $l_i \geq \min (i, n - 1)$    |$5$|
| $9 \sim 10$  | $10^5$ | $l_i=0$ 或 $r_i=n-1$ |$5$|
| $11 \sim 15$ | $10^5$ | 无 |$10$|

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq l_i \leq r_i < n$，$1 \leq T \leq 10$。

## 样例 #1

### 输入

```
2
5
0 1 4 0 0
3 4 4 1 3
3
1 2 2
2 2 2```

### 输出

```
YES
NO```

## 样例 #2

### 输入

```
见下发文件 road2.in```

### 输出

```
见下发文件 road2.out```

# AI分析结果

### 综合分析与结论
所有题解均先将原问题转化为：给定\(n\)个区间\([l_i, r_i]\)，求是否存在一个\(0\)到\(n - 1\)（或\(1\)到\(n\) ）的排列\(a\)，使得\(\forall 1\leq i \leq n, l_i\leq a_i\leq r_i\)，然后采用贪心策略解决。
- **思路**：利用有向无环图（DAG）具有拓扑序的性质，由于原图是完全图，转化后的DAG中节点出度呈现一定规律，从而与给定区间建立联系。
- **算法要点**：通过优先队列（小根堆）或集合来维护区间右端点，按照一定顺序遍历数字，尝试将其放入合适区间。
- **解决难点**：证明贪心策略的正确性。如选择最小右端点的区间放入当前数字，若有解，交换选择仍有解，说明选择最小右端点不劣于其他选择。

### 所选的题解
- **作者：kevinchw (赞：8)  星级：5星**
    - **关键亮点**：思路清晰，先明确将问题转化为区间匹配问题，再详细证明贪心策略的正确性，代码简洁明了。
    - **核心代码实现思想**：用小根堆维护区间右端点，遍历\(1\)到\(n\)，将左端点等于当前值的区间右端点加入堆，每次从堆中取出最小右端点，判断是否能放入当前值，若不能则无解。
``` C++
priority_queue<int,vector<int>,greater<int> > q;
struct node
{
    int l,r;
}a[100005];
vector<int> v[100005];
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        q=priority_queue<int,vector<int>,greater<int> >();
        int n;
        cin>>n;
        for(int i=1;i<=n;i++)
        {
            v[i].clear();
            int x;
            scanf("%d",&x);
            a[i].r=n - x;
        }
        for(int i=1;i<=n;i++)
        {
            int x;
            scanf("%d",&x);
            a[i].l=n - x;
            v[a[i].l].pb(a[i].r);
        }
        int now = 1,op = 0;
        for(int i=1;i<=n;i++)
        {
            for(int j=0;j<(int)v[i].size();j++)q.push(v[i][j]);
            if(q.empty())
            {
                cout<<"NO\n";
                op = 1;
                break;
            }
            int x = q.top();q.pop();
            if(x<i)
            {
                cout<<"NO\n";
                op = 1;
                break;
            }
        }
        if(!op)cout<<"YES\n";
    }
    return 0;
}
```
- **作者：lngym (赞：4)  星级：4星**
    - **关键亮点**：在不会拓扑排序情况下通过找规律化简题意，最终也采用贪心策略解决问题，代码有详细注释。
    - **核心代码实现思想**：重载结构体比较函数按左端点排序，用优先队列维护右端点，遍历过程中若左端点小于等于当前值，将右端点入队，判断队空或队头小于当前值则无解。
```cpp
typedef struct node
{
    int l;
    int r;
    inline bool operator <(const node x) const
    {
        return this->l<x.l;
    } 
}Node;
Node a[MAX];
int flag = 1;
priority_queue<int,vector<int>,greater<int> > q;
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int n;
        scanf("%d",&n);
        for(re int i=1;i<=n;i++)
        {
            scanf("%d",&a[i].l);
            a[i].l++;
        }
        for(re int i=1;i<=n;i++)
        {
            scanf("%d",&a[i].r);
            a[i].r++;
        }
        sort(a + 1,a + n + 1);
        while(q.size()) q.pop();
        int now = 1;
        for(re int i=1;i<=n;i++)
        {
            while(a[now].l<=i&&now<=n)
            {
                q.push(a[now].r);
                now++;
            }
            if(q.empty()||q.top()<i)
            {
                flag = 0;
                break;
            } 
            else q.pop();
        }
        if(flag == 1) printf("YES");
        else printf("NO");
        putchar('\n');
        flag = 1;
    }
    return 0;
}
```
- **作者：WDY_Hodur (赞：1)  星级：4星**
    - **关键亮点**：从拓扑排序角度详细阐述问题转化过程，思路连贯，代码简洁。
    - **核心代码实现思想**：与其他题解类似，用小根堆维护区间右端点，遍历\(0\)到\(n - 1\)，将左端点符合的右端点入堆，判断堆状态及队头元素决定是否有解。
```cpp
struct node{
    int l,r;
}x[N];
priority_queue<int,vector<int>,greater<int> >q;
vector<int>g[N]; 
signed main(){
    cin>>T;
    while(T--){
        cin>>n;
        for(int i=0;i<=n;i++)g[i].clear();
        for(int i=1;i<=n;i++)cin>>x[i].l;
        for(int i=1;i<=n;i++){
            cin>>x[i].r;
            g[x[i].l].push_back(x[i].r); 
        }
        while(!q.empty())q.pop();
        int f = 0;
        for(int i=0;i<n;i++){
            for(int y:g[i])q.push(y);
            if(q.empty()){
                f = 1;
                break;
            }
            int x = q.top();
            q.pop();
            if(x<i){
                f = 1;
                break;
            }
        }
        if(f)cout<<"NO\n";
        else cout<<"YES\n";
    }
    return 0;
}
```

### 最优关键思路或技巧
利用有向无环图的拓扑序性质，将图的边定向问题转化为区间匹配问题，通过贪心策略，借助优先队列（小根堆）维护区间右端点，高效解决问题。

### 可拓展思路
此类问题属于图论与贪心结合的问题，类似套路是将复杂的图结构问题通过性质转化为简单的序列或区间问题，再用贪心、排序等方法解决。例如对于一些特殊图结构的边权、点权分配问题，可尝试分析图的性质，转化为更易处理的问题。

### 相似知识点洛谷题目
- [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：涉及贪心策略，通过分析数据间关系确定最优顺序。
- [P1248 加工生产调度](https://www.luogu.com.cn/problem/P1248)：结合贪心与排序，解决生产调度中的最优安排问题。
- [P2859 [USACO06DEC]Milk Patterns G](https://www.luogu.com.cn/problem/P2859)：利用后缀数组等知识，结合贪心思想解决字符串相关问题。

### 个人心得摘录与总结
无。 

---
处理用时：66.44秒
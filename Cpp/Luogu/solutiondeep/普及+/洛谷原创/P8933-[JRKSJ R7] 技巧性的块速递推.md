# 题目信息

# [JRKSJ R7] 技巧性的块速递推

## 题目背景

充分必要，切比雪夫。

原来还是，不需要了。

## 题目描述

一个 $n\times m$ 的棋盘，对每个格子染上黑白两色之一。

询问有多少种染色方式，使得不存在横、竖、斜连续四个格子中存在至少三个相同颜色的格子，并且不存在横、竖、斜连续三个格子的颜色相同。

若设棋盘的左上角为 $(1,1)$，右下角为 $(n,m)$，则称 $\{(x,y),(x+1,y),(x+2,y)\}$ 为横的连续三个格子，$\{(x,y),(x,y+1),(x,y+2)\}$ 为竖的连续三个格子、$\{(x,y),(x+1,y+1),(x+2,y+2)\}$ 和 $\{(x,y),(x+1,y-1),(x+2,y-2)\}$ 为斜的连续三个格子（以上格子均在棋盘内）。

连续四个格子同理。

## 说明/提示

### 样例解释

样例 $1$：显然任意染色均合法，答案为 $2^4=16$。

样例 $2$：

```
101
110
010
```

这是合法方案之一。

```
111
110
011
```

这是不合法方案之一，因为 $\{(1,1),(1,2),(1,3)\}$、$\{(1,2),(2,2),(3,2)\}$ 和 $\{(1,1),(2,2),(3,3)\}$ 均不满足条件。

### 数据规模

本题采用捆绑测试。
| $\text{Subtask}$ | $n,m\le$ | $\text{Score}$ |
| :----------: | :----------: | :----------: | 
| $1$ | $30$ | $40$ |
| $2$ | $10^9$ | $60$ |

对于 $100\%$ 的数据，$1\le T\le 10^5$，$1\le n,m\le 10^9$。

## 样例 #1

### 输入

```
1
2 2```

### 输出

```
16```

## 样例 #2

### 输入

```
1
3 3```

### 输出

```
32```

# AI分析结果

### 综合分析与结论
这几道题解均围绕棋盘染色方案数问题展开，核心思路都是利用题目中颜色分布限制条件，发现棋盘的循环规律，从而简化计算。主要差异在于对循环规律的具体分析、剪枝策略以及预处理范围。

### 所选的题解
- **作者：__ex (5星)**
    - **关键亮点**：思路清晰，通过图形直观展示确定格子颜色的原理，详细分析斜向扩展可能出现的问题，得出以\(4\times4\)为周期循环及用\(7\times7\)棋盘涵盖所有斜向问题情况的结论，代码实现了完整的爆搜预处理。
    - **重点代码 - 核心实现思想**：`check`函数用于检查当前棋盘状态是否满足题目条件，`dfs`函数通过深度优先搜索遍历所有可能的染色情况，在`dfs`中当横坐标\(x\geq4\)时进行剪枝，根据左边三个格子颜色确定当前格子颜色，避免不必要搜索。
```cpp
bool check(int x,int y){
    if(x+2<=n && a[x][y]==a[x+1][y] && a[x][y]==a[x+2][y])return 0;
    if(y+2<=m && a[x][y]==a[x][y+1] && a[x][y]==a[x][y+2])return 0;
    if(x+3<=n){
        int t=0;
        for(int i=x;i<=x+3;i++)
            if(a[i][y])t++;
        if(t!=2)return 0;
    }
    if(y+3<=m){
        int t=0;
        for(int i=y;i<=y+3;i++)
            if(a[x][i])t++;
        if(t!=2)return 0;
    }
    if(x+3<=n && y+3<=m){
        int t=0;
        for(int i=0;i<4;i++)
            if(a[x+i][y+i])t++;
        if(t!=2)return 0;
    }
    if(x+3<=n && y-3>=1){
        int t=0;
        for(int i=0;i<4;i++)
            if(a[x+i][y-i])t++;
        if(t!=2)return 0;
    }
    if(x+2<=n && y+2<=m){
        int t=0;
        for(int i=0;i<3;i++)
            if (a[x+i][y+i])t++;
        if(t==0 || t==3)return 0;
    }
    if(x+2<=n && y-2>=1){
        int t=0;
        for(int i=0;i<3;i++)
            if(a[x+i][y-i])t++;
        if(t==0 || t==3)return 0;
    }
    return 1;
}
void dfs(int x,int y){
    if(x>n)x=1,y++;
    if(y>m){
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                if(!check(i,j))return ;
        ans++;
        return;
    }
    if(x>=4){
        int sum=0;
        for(int i=x-3;i<=x-1;i++)
            sum+=a[i][y];
        if(!sum || sum==3)return;
        if(sum==1)a[x][y]=1;
        else a[x][y]=0;
        dfs(x+1,y);
        return;
    }
    a[x][y]=0;dfs(x+1,y);
    a[x][y]=1;dfs(x+1,y);
}
```
 - **作者：zhangxiao666 (4星)**
    - **关键亮点**：题意阐述清晰，逐步推导棋盘以\(4\times4\)循环及斜向问题在\(7\times7\)范围解决的思路，代码结构完整，在搜索时通过横坐标\(\geq4\)进行剪枝优化。
    - **重点代码 - 核心实现思想**：`check`函数全面检查棋盘合法性，`dfs`函数实现搜索，当纵坐标\(y\geq4\)时，依据左边三个格子颜色确定当前格子颜色，减少搜索分支。
```cpp
inline bool check()//判断当前填法是否合法 
{
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(i+2<=n)
            {
                if(a[i][j]==a[i+1][j]&&a[i][j]==a[i+2][j]) return 0;
            }
            if(j+2<=m)
            {
                if(a[i][j]==a[i][j+1]&&a[i][j]==a[i][j+2]) return 0;
            }
            if(i+2<=n&&j+2<=m)
            {
                if(a[i][j]==a[i+1][j+1]&&a[i][j]==a[i+2][j+2]) return 0;
            }
            if(i-2>=1&&j+2<=m)
            {
                if(a[i][j]==a[i-1][j+1]&&a[i][j]==a[i-2][j+2]) return 0;
            }
            if(i+3<=n)
            {
                int sum1=0,sum2=0;
                for(int k=i;k<=i+3;k++)
                {
                    if(a[k][j]) sum1++;
                    else sum2++;
                } 
                if(sum1>=3||sum2>=3) return 0; 
            }
            if(j+3<=m)
            {
                int sum1=0,sum2=0;
                for(int k=j;k<=j+3;k++)
                {
                    if(a[i][k]) sum1++;
                    else sum2++;
                } 
                if(sum1>=3||sum2>=3) return 0; 
            }
            if(i+3<=n&&j+3<=m)
            {
                int sum1=0,sum2=0;
                for(int k=0;k<=3;k++)
                {
                    if(a[i+k][j+k]) sum1++;
                    else sum2++;
                } 
                if(sum1>=3||sum2>=3) return 0;
            }
            if(i-3>=1&&j+3<=m)
            {
                int sum1=0,sum2=0;
                for(int k=0;k<=3;k++)
                {
                    if(a[i-k][j+k]) sum1++;
                    else sum2++;
                } 
                if(sum1>=3||sum2>=3) return 0;
            }
        }
    }
    return 1;
}
inline void dfs(int x,int y)
{
    if(y>m) y=1,x++;
    if(x>n)
    {
        if(check()) ans++;//合法则方案数加1 
        return;
    }
    if(y>=4)
    {
        int sum1=0,sum2=0;
        for(int i=y-3;i<=y-1;i++)
        {
            if(a[x][i]) sum1++;
            else sum2++;
        }
        if(!sum1||!sum2) return;
        if(sum1==1) a[x][y]=1;
        if(sum2==1) a[x][y]=0;
        dfs(x,y+1);
        return;
    }
    a[x][y]=1;dfs(x,y+1);
    a[x][y]=0;dfs(x,y+1);
}
```

### 最优关键思路或技巧
利用连续格子颜色限制推出棋盘的循环规律，通过剪枝优化深度优先搜索，减少不必要的计算。具体为根据已确定的连续三个格子颜色确定下一个格子颜色，并且发现棋盘以\(4\times4\)为周期循环，斜向问题在\(7\times7\)范围内可涵盖，从而缩小预处理范围。

### 可拓展思路
此类题目属于基于条件限制的计数问题，类似套路是通过分析条件找到数据的重复性或规律性，减少暴力搜索空间。例如对于其他具有特定排列限制的棋盘染色、数字排列等问题，都可尝试寻找循环节或递推关系简化计算。

### 相似知识点洛谷题目
 - [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)：经典的棋盘放置问题，通过深度优先搜索并结合剪枝策略解决。
 - [P1036 [NOIP2002 普及组] 选数](https://www.luogu.com.cn/problem/P1036)：利用深度优先搜索枚举组合，并通过剪枝优化搜索过程。
 - [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)：同样是搜索类题目，通过合理剪枝减少搜索量，优化算法时间复杂度。 

---
处理用时：73.69秒
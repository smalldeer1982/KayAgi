# 题目信息

# The Da Vinci Code

## 题目背景

> 圣杯在罗斯琳教堂下静待。  
> 大师杰作掩映中相拥入眠。  
> 剑刃圣杯守护着她的门宅。  
> 星空下她可安息无碍。

好的题目不需要花里胡哨的背景。

## 题目描述

给定一个长度为 $n$ 的数列 $a$，初始情况下 $a_i=i$。

另有一个取值在 $[1,n]$ 内的随机的整数 $x$，它取 $i$ 的概率为 $b_i$。

接下来进行 $k$ 次操作，每次**均匀随机**地选两个 $[1,n]$ 中的整数 $i,j$（允许 $i=j$），交换 $a_i,a_j$ 的值（如果 $i=j$ 则什么也不干）。问最后 $x$ 在位置 $i$ 上的概率，你需要对所有 $1\leq i\leq n$ 求出答案。你需要输出答案模 $3221225473$ 的值。

我们定义 $x$ 在位置 $i$ 上指 $a_i=x$。

## 说明/提示

#### 【样例解释】

对于样例 #1：

$b$ 数组为 $\{2134949164 ,1086276310\}$，操作 $9$ 次后 $x$ 在两个位置的概率均为 $\dfrac12$。

对于样例 #2：

$b$ 数组为 $\{1863763622,1043615898,1055155266,1556793106,1763540175,1239801170,1141007183\}$。

#### 【数据范围】
对于 $100\%$ 的数据：

* $2\leq n\leq2\times10^7$，$0\leq k,seed<2^{64}$。
* $1<b_i<3221225473$，$\sum\limits_{i=1}^n b_i\equiv 1\pmod{3221225473}$。
* 数据保证 $1<b_n<3221225473$ 且 $3221225473$ 是质数。

---

**本题采用捆绑测试**。

| $\text{Subtask}$ |$n\le$|$k\le$|分值|
|:-:|:-:|:-:|:-:|
|$0$|$2$|$2^{64}-1$|$1$|
|$1$|$5$|$5$|$4$|
|$2$|$200$|$200$|$6$|
|$3$|$200$|$2^{64}-1$|$9$|
|$4$|$2000$|$2000$|$7$|
|$5$|$2\times10^7$|$1$|$5$|
|$6$|$10^6$|$10^6$|$8$|
|$7$|$2\times10^7$|$10^7$|$10$|
|$8$|$10^6$|$2^{64}-1$|$15$|
|$9$|$2\times10^7$|$2^{64}-1$|$35$|

## 样例 #1

### 输入

```
2 9 998244353
```

### 输出

```
2684354563
```

## 样例 #2

### 输入

```
7 3 123456789
```

### 输出

```
24313281849
```

## 样例 #3

### 输入

```
10 9000000000000000000 1000000000000000000
```

### 输出

```
20026214895
```

## 样例 #4

### 输入

```
4 0 123456789
```

### 输出

```
12357556560
```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解发现交换\(a_i\)和交换\(b_i\)等价，从而考虑对\(b_i\)进行操作分析。部分题解采用概率\(dp\)，通过设状态表示操作后数在原位或不在原位的概率，推出转移方程求解。
    - 算法要点：主要涉及概率计算、递推关系推导、矩阵快速幂优化（部分题解）以及快速幂、求逆元等基本运算。
    - 解决难点：难点在于准确推导每次操作后概率的变化情况，以及处理高精度运算防止溢出。

    - 整体来看，cyffff和Missa的题解思路清晰，代码简洁且优化较好，Register_int题解思路正确但代码可读性稍逊。

  - cyffff题解（5星）
    - 关键亮点：思路清晰，直接推导每次操作后\(b_i\)的期望更新公式，通过定义函数\(f(x)\)及其\(k\)次迭代形式，利用等比数列求和与快速幂求解，时间复杂度\(O(n + \log\bmod)\)，代码简洁高效。
    - 重点代码核心思想：先计算\(n\)和\(n^2\)的逆元，根据推导出的\(b_i\)更新公式确定\(f(x)\)中的系数\(k1\)和\(b1\)，特判\(k = 1\)情况，最后通过循环将每个\(b_i\)代入\(f^{(k)}(x)\)计算并异或得到答案。
```cpp
inline uint qpow(uint a,uint b){
    uint res=1;
    while(b){
        if(b&1) res=(ull)res*a%mod;
        a=(ull)a*a%mod;
        b>>=1;
    }
    return res;
}
int main() {
    n=read(),k=read(),seed=read();
    ull sum = 0;
    for (int i = 1; i < n; ++ i) b[i] = rd(2u, mod - 1), (sum += b[i]) %= mod;
    b[n] = mod + 1 - sum;
    uint in=qpow(n,mod-2),in2=(ull)in*in%mod;
    uint k1=(ull)(n-2)*in%mod,b1=(ull)2*in2%mod;
    uint k2,b2;
    if(k==1){k2=k1,b2=b1;}
    else{
        uint ki=qpow(((ull)k1%mod+mod-1)%mod,mod-2);
        k2=qpow(k1,k%(mod-1)),b2=((ull)k2+mod-1)%mod*ki%mod*b1%mod;
    }
    for(int i=1;i<=n;i++)
        b[i]=((ull)k2*b[i]%mod+b2)%mod,ans^=(ull)b[i]*i;
    write(ans);
    flush();
}
```
  - Missa题解（5星）
    - 关键亮点：通过分析一次变换中单点概率变化，列出不同情况的概率转移，化简后得到线性递推关系，利用不动点知识进一步简化计算，最终通过快速幂算出\((\frac{n - 2}{n})^k\)实现\(O(1)\)求\(ans_i\)，总复杂度线性，代码简洁，常数较小。
    - 重点代码核心思想：先计算\(n\)的逆元，通过快速幂算出\((\frac{n - 2}{n})^k\)，遍历\(b_i\)，根据递推关系计算每个位置最终概率并异或得到答案。
```cpp
LL qpow(LL a, ull b){
    long long ans = 1ll;
    for(; b; b >>= 1) {if(b & 1) ans = 1ll * ans * a % mod; a = 1ll * a * a % mod;}
    return ans;
}
LL inv(LL n) {return qpow(n, mod-2);}
int main() {
    scanf("%d%llu%llu", &n, &k, &seed);
    ull sum = 0;
    for (int i = 1; i < n; ++ i) b[i] = rd(2u, mod - 1), (sum += b[i]) %= mod;
    b[n] = mod + 1 - sum;
    LL ans = 0;
    LL invn = inv(n), s = qpow(invn * (n-2) % mod, k);
    for(int i = 1; i <= n; i++) {
        LL t = (long long)b[i] + mod - invn; t %= mod;
        t = t * s % mod;
        t += invn; t %= mod;
        ans ^= (t * i);
    }
    printf("%lld\n", ans);
}
```
  - Register_int题解（4星）
    - 关键亮点：采用概率\(dp\)，设\(dp_{i,0}\)和\(dp_{i,1}\)分别表示\(i\)次操作后数在原位和不在原位的概率，通过计算交换方案数得到转移方程，利用矩阵快速幂优化到\(O(\log k)\)。
    - 重点代码核心思想：定义矩阵结构体实现矩阵乘法和快速幂，根据转移方程初始化矩阵\(dp\)和\(base\)，通过矩阵快速幂计算\(k\)次操作后的概率，最后遍历计算每个位置的最终答案。
```cpp
struct matrix {
    ull a[2][2];
    matrix(ull k = 0) { a[0][0] = a[1][1] = k, a[1][0] = a[0][1] = 0; }
    ull* operator [] (const int k) { return a[k]; }
    matrix operator * (const matrix &rhs) const {
        matrix res = 0;
        for (int k = 0; k < 2; k++) {
            for (int i = 0; i < 2; i++) {
                for (int j = 0; j < 2; j++) res[i][j] = (res[i][j] + a[i][k] * rhs.a[k][j] % mod) % mod;
            }
        }
        return res;
    }
} dp, base;

inline 
matrix qpow(matrix b, ull p) {
    matrix res = 1;
    while (p) {
        if (p & 1) res = res * b;
        b = b * b, p >>= 1;
    }
    return res;
}

int main() {
    scanf("%llu%llu%llu", &n, &k, &seed), x = inv(n * n % mod) % mod;
    dp[0][1] = 2 * x % mod, dp[1][1] = mod + 1 - dp[0][1];
    dp[1][0] = (2 * n - 2) % mod * x % mod, dp[0][0] = mod + 1 - dp[1][0];
    dp = qpow(dp, k);
    for (int i = 1; i < n; i++) {
        b = randint(2, mod - 1), sum = (sum + b) % mod;
        ans ^= (b * dp[0][0] % mod + (mod + 1 - b) * dp[0][1] % mod) % mod * i;
    }
    printf("%llu", ans ^ ((mod + 1 - sum) * dp[0][0] % mod + sum * dp[0][1] % mod) % mod * n);
}
```
• 最优关键思路或技巧：发现交换\(a_i\)和\(b_i\)的等价性，从而简化问题为对\(b_i\)概率变化的分析。利用不动点简化线性递推关系，或者通过矩阵快速幂优化递推过程，同时注意高精度运算防止溢出。
• 可拓展之处：同类型题可涉及更多复杂的概率转移场景，类似算法套路可用于解决其他具有线性递推关系的概率问题，通过分析单次操作对状态概率的影响，建立递推方程求解。
• 相似知识点洛谷题目：
    - P1290 [USACO2.3] 最长前缀 Longest Prefix：涉及字符串匹配和递推关系，类似本题分析状态转移。
    - P3951 [NOIP2017 提高组] 小凯的疑惑：通过数论和递推解决问题，与本题递推思想类似。
    - P1962 斐波那契数列：经典的递推问题，可使用矩阵快速幂优化，与本题部分优化思路一致。
• 个人心得摘录与总结：
    - Missa提到出题人使用的模数和\(k\)范围导致数据类型需全开`unsigned long long`，否则容易出错，强调了数据范围对代码实现的影响，提醒注意数据类型选择防止溢出。 

---
处理用时：77.54秒
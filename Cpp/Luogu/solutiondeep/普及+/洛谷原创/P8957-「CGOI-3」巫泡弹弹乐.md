# 题目信息

# 「CGOI-3」巫泡弹弹乐

## 题目背景

mc 正在挑战弹弹乐。

![](https://cdn.luogu.com.cn/upload/image_hosting/yaye0cgu.png)

## 题目描述

弹弹乐由 $n$ 个弹力菇组成，每个弹力菇有 $a,b$ 两个属性。

对于弹力菇 $i$ 会向弹力菇 $j$ 连一条边权为 $\max(a_i,a_j)+\max(b_i,b_j)$ 的双向弹力通道。现在 mc 想知道弹力菇组成的图的最小生成树，以便他打破记录。

## 说明/提示

#### 数据范围

**「本题采用捆绑测试」**

$$\def{\arraystretch}{1.5}\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n} & \textbf{特殊性质} & \textbf{分值}\cr\hline
1 & n\le 500 & \text{无} & 20 \cr\hline
2 & n\le 5\times 10^4 & \text{无} & 20\cr\hline
3 & \text{无特殊限制} & \text{数据随机} & 20\cr\hline
4 & \text{无特殊限制} & \text{无} & 40 \cr\hline
\end{array}$$

- 对于 $100\%$ 的数据，满足：$1\le n\le 10^6$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
3
1 2 1
3 2 3```

### 输出

```
9
1 2
1 3```

# AI分析结果

### 综合分析与结论
这些题解均采用贪心策略解决该最小生成树问题，核心思路是按a值排序后，让每个点与b值前缀最小的点相连，使边权和最小。
1. **思路**：多数题解先考虑仅a变量时，按a排序让权值最小点连所有点为最优，扩展到a、b二元时，按a排序保证a最优，贪心地连b最小点保证b最优。部分题解通过证明这种贪心方式能使a、b分别取到最小贡献值，从而证明其正确性。
2. **算法要点**：对输入数据按a值升序排序，遍历排序后的数据，维护b值的最小值及对应点，每次将当前点与b值最小点连边，并更新b值最小值及对应点。
3. **解决难点**：难点在于证明贪心策略的正确性，不同题解从不同角度进行证明，如分析b值的计算情况、从树的结构和边权贡献角度等。

### 所选的题解
1. **作者：MCRS_lizi (5星)**
    - **关键亮点**：思路清晰，先阐述贪心思路，再详细证明贪心的正确性，代码简洁且注释清晰。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans;
struct edge
{
    int u,v;
}l[1000010];
struct num
{
    int a,b,xh;
}p[1000010],minn;
bool cmp(num u,num v)
{
    return u.a<v.a;
}
signed main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>p[i].a;
        p[i].xh=i;
    }
    for(int i=1;i<=n;i++)
    {
        cin>>p[i].b;
        p[i].xh=i;
    }
    sort(p+1,p+n+1,cmp);
    minn=p[1];
    for(int i=2;i<=n;i++)
    {
        ans+=p[i].a;
        num u=minn;
        ans+=max(u.b,p[i].b);
        if(p[i].b<minn.b)
        {
            minn=p[i];
        }
        l[i].u=p[i].xh,l[i].v=u.xh;
    }
    cout<<ans<<"\n";
    for(int i=2;i<=n;i++)
    {
        cout<<l[i].u<<" "<<l[i].v<<"\n";
    }
    return 0;
}
```
    - **核心实现思想**：先按a值对结构体数组p排序，初始化minn为第一个点。遍历从第二个点开始，每次累加当前点a值与minn点b值和当前点b值的较大值，更新minn，记录连边信息，最后输出最小生成树的边权和与具体连边。
2. **作者：irris (4星)**
    - **关键亮点**：不仅给出贪心思路和证明，还提供两种证明方法，分别从b值代价最小和树结构角度证明，代码简洁规范。
    - **个人心得**：证明1是考场上思路，证明2是官方题解，两种做法本质相同。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>

#define MAXN 1000001
struct Node { int a, b, id; const bool operator < (const Node& k) const { return a < k.a; } } T[MAXN];

std::vector<std::pair<int, int>> vec;
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int N, p = 1; std::cin >> N;
    for (int i = 1; i <= N; ++i) T[i].id = i;
    for (int i = 1; i <= N; ++i) std::cin >> T[i].a;
    for (int i = 1; i <= N; ++i) std::cin >> T[i].b;
    std::sort(T + 1, T + N + 1);
    long long ans = 0;
    for (int i = 2; i <= N; ++i) {
        vec.push_back({i, p}), ans += T[i].a + std::max(T[i].b, T[p].b);
        if (T[i].b < T[p].b) p = i;
    }
    std::cout << ans << '\n';
    for (int i = 0; i < N - 1; ++i) 
        std::cout << T[vec[i].first].id << ' ' << T[vec[i].second].id << '\n';
    return 0;
}
```
    - **核心实现思想**：定义结构体Node存储a、b值和编号，重载小于号按a值升序排序。读入数据后排序，遍历从第二个点开始，每次将当前点与p点（b值最小点）连边，更新ans和p，最后输出最小生成树的边权和与具体连边。
3. **作者：dci66666 (4星)**
    - **关键亮点**：先从一维变量情况入手分析贪心策略，再详细阐述扩展到二维的过程及证明，逻辑连贯，代码有注释辅助理解。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+50;
struct node{
    int a,b,id;
    friend bool operator<(const node &x,const node &y){
        if(x.a!=y.a)return x.a<y.a;
        return x.id<y.id;
    }
}t[N];
int n;
inline int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-48;
        c=getchar();
    }
    return x*f;
}
struct Edge{
    int u,v;
}edge[N];
int minb,minid,tot;
#define ll long long
ll ans=0;
int main(){
    n=read(); 
    for(int i=1;i<=n;i++)t[i].a=read(),t[i].id=i;
    for(int i=1;i<=n;i++)t[i].b=read();
    sort(t+1,t+1+n);
    minb=t[1].b,minid=t[1].id;
    for(int i=2;i<=n;i++){
        edge[++tot]={t[i].id,minid};
        ans+=t[i].a+max(minb,t[i].b);
        if(t[i].b<minb){
            minid=t[i].id;minb=t[i].b;
        }
    }
    printf("%lld\n",ans);
    for(int i=1;i<=tot;i++){
        printf("%d %d\n",edge[i].u,edge[i].v);
    }
    return 0;
}
```
    - **核心实现思想**：定义结构体node存储a、b值和编号，重载小于号按a值升序排序。读入数据后排序，初始化minb和minid为第一个点的b值和编号。遍历从第二个点开始，每次将当前点与minid点连边，更新ans、minb和minid，最后输出最小生成树的边权和与具体连边。

### 最优关键思路或技巧
1. **思维方式**：将复杂的二维变量问题先简化为一维变量分析贪心策略，再扩展到二维，通过证明贪心对a、b分别最优来证明整体最优。
2. **代码实现技巧**：利用结构体存储数据并通过重载比较运算符实现按a值排序，遍历过程中简洁地维护b值最小值及对应点。

### 可拓展之处
同类型题或类似算法套路：此类题目可拓展到更多维度变量的图的最小生成树问题，或改变边权计算方式，仍可尝试从简化问题、分析贪心策略及证明正确性角度入手。

### 相似知识点洛谷题目
1. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)：基础的最小生成树模板题，可巩固最小生成树算法基础。
2. [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195)：最小生成树应用，在保证连通块数量条件下求最小生成树。
3. [P2820 [NOIP2016 提高组] 运输计划](https://www.luogu.com.cn/problem/P2820)：结合最小生成树与二分查找，有一定综合性。 

---
处理用时：84.47秒
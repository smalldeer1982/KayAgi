# 题目信息

# 「DTOI-4」排列

## 题目背景

**Update on 2023.2.1：新增一组针对 @[yuanjiabao](https://www.luogu.com.cn/user/455558) 的 Hack 数据，放置于 #21。**

**Update on 2023.2.2：新增一组针对 @[CourtesyWei](https://www.luogu.com.cn/user/664070) 和 @[bizhidaojiaosha](https://www.luogu.com.cn/user/613616) 的 Hack 数据，放置于 #22。**

------------

~~构造一个排列 $p$，使得~~$\small\color{white}{下标为奇数的项之和 \geq a 且下标为偶数的项之和 \geq b。}$

## 题目描述

小 L 给你一个**偶数** $n$ 和两个整数 $a, b$，请你构造一个长为 $n$ 的排列 $p$，使得其满足 $\displaystyle\sum_{i = 1}^{\frac{n}{2}} p_i \geq a$ 且 $\displaystyle\sum_{i = \frac{n}{2} + 1}^{n} p_i \geq b$。

## 说明/提示

**本题开启 Special Judge。**

| $\textbf{Subtask}$ | $n$ | $a, b$ | 分值 |
| :------: | :------: | :------: | :------: |
| $1$ | $2 \leq n \leq 10$ | 无特殊限制 | $20 \operatorname{pts}$ |
| $2$ | 无特殊限制 | $a = b = 0$ | $10 \operatorname{pts}$ |
| $3$ | 同上 | $a = 0$ 或 $b = 0$ | $10 \operatorname{pts}$ |
| $4$ | 同上 | 无特殊限制 | $60 \operatorname{pts}$ |

对于 $100\%$ 的数据，$2 \leq n, \sum n \leq 10^5$，$0 \leq a, b \leq \frac{n(n + 1)}{2}$，$1 \leq T \leq 10$，$n$ 为**偶数**。

## 样例 #1

### 输入

```
2
6 6 12
6 8 14```

### 输出

```
1 6 2 5 3 4
-1```

# AI分析结果

### 综合分析与结论
这些题解的核心思路围绕判断无解情况和构造满足条件的排列展开。多数题解先判断 \(a + b > \frac{n(n + 1)}{2}\) 时无解，然后尝试构造满足前半段和 \(\geq a\) 且后半段和 \(\geq b\) 的排列。
 - **思路方面**：部分题解采用贪心策略，如优先满足前半段和为 \(a\) 以确保后半段和尽量满足 \(b\)；部分通过交换前后半段元素来调整和。
 - **算法要点**：涉及计算排列总和、前半段和的范围，以及根据差值调整排列元素。
 - **解决难点**：主要是如何在满足前半段和要求的同时，保证后半段和也满足要求，以及处理交换元素时的重复和边界情况。

### 所选的题解
- **作者：是青白呀 (5星)**
    - **关键亮点**：思路清晰，通过详细的数学推导得出和为 \(a\) 时所选数的范围及替换策略，贪心思想运用巧妙，代码实现简洁明了。
    - **个人心得**：无
    ```cpp
    // 核心代码片段
    int sum=(1+n/2)*n/4;
    if(sum>=a){//a选择1~n/2
        if((1+n)*n/2-sum<b)printf("-1\n");
        else{
            for(int i=1;i<=n;i++)
                printf("%d ",i);
            printf("\n");
        }
        continue;
    }
    int movnum=(a-sum)/(n/2);//增加n/2的次数
    if(movnum>n/2||(movnum==n/2&&(a-sum)%(n/2))){//总操作次数不能大于n/2
        printf("-1\n");
        continue;
    }
    bool vis[N]={};//标记哪些数属于前半部分
    int suma=0;
    for(int i=1;i<(n/2)-movnum;i++)
        suma+=i,vis[i]=1;
    suma+=(n/2)-movnum+(a-sum)%(n/2);
    vis[(n/2)-movnum+(a-sum)%(n/2)]=1;
    for(int i=(n/2)-movnum+1;i<=n/2;i++)
        suma+=i+n/2,vis[i+n/2]=1;
    if((1+n)*n/2-suma<b)printf("-1\n");
    else{
        for(int i=1;i<=n;i++)
            if(vis[i])printf("%d ",i);
        for(int i=1;i<=n;i++)
            if(!vis[i])printf("%d ",i);
        printf("\n");
    }
    ```
    - **核心实现思想**：先计算初始和 \(sum\)，判断 \(a\) 能否直接取 \(1\) 到 \(n/2\) 这些数。若不能，计算需要替换的次数 \(movnum\)，并通过标记数组 \(vis\) 确定前半部分所选数字，最后判断后半部分和是否满足要求并输出排列。
 - **作者：lcbridge (4星)**
    - **关键亮点**：思路独特，详细分析了交换元素的过程，通过贪心策略每次选择最大差值进行交换，并结合多种情况判断是否有解，代码注释详细。
    - **个人心得**：赛时调了很久，发题解纪念。
    ```cpp
    // 核心代码片段
    int d=a;
    for(int i=1;i<=n/2;i++)d-=p[i];
    int cnt=1;
    while(d>0&&cnt<=n/2){
        if(d-(p[n-cnt+1]-p[cnt])<=0)break;
        d-=(p[n-cnt+1]-p[cnt]);
        swap(p[cnt],p[n-cnt+1]);
        cnt++;
    }
    int len=n/2-cnt+1;
    if(len*2<=d){
        printf("-1\n");
        continue;
    }
    if(d>len)swap(p[cnt],p[cnt+d]);
    if(d<=len&&d>0)swap(p[n/2],p[n/2+d]);
    int tmp1=0;
    for(int i=n/2+1;i<=n;i++)tmp1+=p[i];
    if(tmp1>=b)for(int i=1;i<=n;i++)printf("%lld ",p[i]);
    else printf("-1");
    printf("\n");
    ```
    - **核心实现思想**：先计算初始排列前半部分与 \(a\) 的差值 \(d\)，通过贪心循环交换前后半段元素缩小差值 \(d\)，根据剩余差值 \(d\) 和剩余长度 \(len\) 的关系进一步交换元素，最后判断后半部分和是否满足 \(b\) 并输出结果。
 - **作者：Leasier (4星)**
    - **关键亮点**：分情况讨论清晰，根据 \(a\) 和 \(b\) 的大小关系，分别通过对前半部分数字的调整来构造满足条件的排列，逻辑严谨。
    - **个人心得**：无
    ```cpp
    // 核心代码片段
    if (a < b){
        ll sum = sum1(m);
        if (t1 - sum < b){
            printf("-1\n");
            continue;
        }
        for (int j = 1; j <= m; j++){
            ans[j] = j;
        }
        if (sum < a){
            ll t2 = (a - sum) / m;
            a = (a - sum) % m;
            for (int j = 1; j <= m; j++){
                ans[j] += t2;
            }
            for (ll j = 1; j <= a; j++){
                ans[m - j + 1]++;
            }
        }
    } else {
        ll sum = t1 - sum1(m);
        if (sum < a){
            printf("-1\n");
            continue;
        }
        for (int j = 1; j <= m; j++){
            ans[j] = n - j + 1;
        }
        if (t1 - sum < b){
            ll t2 = (sum - a) / m;
            a = (sum - a) % m;
            for (int j = 1; j <= m; j++){
                ans[j] -= t2;
            }
            for (ll j = 1; j <= a; j++){
                ans[m - j + 1]--;
            }
        }
    }
    ```
    - **核心实现思想**：以 \(a < b\) 为例，先计算前半部分初始和 \(sum\)，判断是否无解。若有解，当前半部分和小于 \(a\) 时，先将前半部分每个数加上 \(\lfloor \frac{a - S_1(\frac{n}{2})}{\frac{n}{2}} \rfloor\)，再把后 \((a - S_1(\frac{n}{2})) \bmod \frac{n}{2}\) 个数加一，从而构造出满足条件的排列。

### 最优关键思路或技巧
 - **贪心策略**：在构造排列时，优先满足前半段和为 \(a\)，以保证后半段和尽量满足 \(b\)，通过合理选择交换元素或调整数字来实现。
 - **数学推导**：通过计算排列总和、前半段和的范围，确定无解条件以及构造排列时数字调整的依据。

### 可拓展之处
此类题目属于构造类问题，常见套路是先判断无解情况，再利用贪心、模拟等策略进行构造。相似类型题可能会改变排列的约束条件，如对排列的奇偶项、特定位置元素和等有不同要求。

### 相似知识点洛谷题目
 - **P1031 均分纸牌**：通过模拟和贪心策略解决纸牌分配问题，与本题构造排列思路类似，需考虑如何调整元素满足特定条件。
 - **P1094 纪念品分组**：运用贪心思想对数据进行分组，满足分组和的限制，与本题判断和构造满足条件的排列有相似思维方式。
 - **P1181 数列分段 Section I**：通过贪心策略对数列进行分段，使每段和满足一定条件，与本题构造满足和条件的排列在思路上有共通之处。 

---
处理用时：71.21秒
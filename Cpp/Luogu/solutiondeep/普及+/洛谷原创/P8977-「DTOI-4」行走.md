# 题目信息

# 「DTOI-4」行走

## 题目背景

小 L 感到无聊，于是希望在树上行走。

## 题目描述

小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。

他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。

他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：

- $P$ 是一条**可以为空**的**简单有向路径**。
- 设 $P$ 中依次经过的点为 $P_1, P_2, \cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。
- 设 $f(P) = \displaystyle\sum_{i = 1}^{|P|} \frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。
- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。

请你求出符合上述条件的路径 $P$。 

------------

关于本题中字典序的定义：

设有两条待比较的路径 $P \neq Q$。

- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。
- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。

## 说明/提示

#### 样例 #1 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)

$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \frac{1}{4} = \frac{5}{4}$。可以证明不存在更优的 $P$。
#### 数据范围
| $\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |
| :------: | :------: | :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 50$ | 无特殊限制 | 无 | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 500$ | 同上 | $1$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 5 \times 10^3$ | 同上 | $1, 2$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^5$ | 同上 | $1 \sim 3$ | $20 \operatorname{pts}$ |
| $5$ | 无特殊限制 | $a_i \in \{-1, 1\}$ | 无 | $20 \operatorname{pts}$ |
| $6$ | 同上 | 无特殊限制 | $1 \sim 5$ | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$a_i \in \{-1, 0, 1\}$，$1 \leq u, v \leq n$，保证给出的边可以构成一棵**无根树**。

## 样例 #1

### 输入

```
5
1 0 -1 1 -1
1 2
2 3
2 4
1 5```

### 输出

```
1 2 4```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解都基于对题目条件的分析，发现不能经过权值为 -1 的点，且能走 1 时走 1 比走 0 优。在此基础上，通过不同搜索方式来寻找满足条件的路径。
    - 算法要点：多数题解采用 DFS 或 BFS 遍历树结构。利用数组或 vector 存储树的边信息，通过排序保证字典序最小。同时在搜索过程中维护路径的最优值及相关状态。
    - 解决难点：主要难点在于如何在满足路径权值最大的同时保证字典序最小，以及处理路径末尾可能出现的多余 0。不同题解通过不同的数据结构操作和搜索策略来解决这些问题。

    - 结论：各题解在思路和实现上有相似之处，但在代码实现细节、数据结构使用和优化程度上存在差异。

• 所选的题解：
  - 作者：xiaoqian02 (4星)
    - 关键亮点：思路清晰，详细解释了不选 -1 的原因及字典序处理方式。采用 DFS 实现，代码注释详细，对初学者友好。
    - 个人心得：一开始误以为可从任意点开始走，浪费了时间。
    - 核心代码实现思想：通过 DFS 遍历树，在遍历过程中根据节点权值和当前路径状态更新最优路径。利用 vector 存储边并排序保证字典序。
```cpp
bool dfs(int p,int fr,int dep)
{
    int mx=-1;
    bool bg=0;
    for(int i=0;i<ed[p].size();i++)
    {
        int k=ed[p][i];
        if(k==fr) continue;
        mx=max(mx,a[k]);
        if(a[k]==-1) continue;
        if(a[k]==1)
        {
            if(qz[dep]==0)
            {
                if(mxd<dep) mxd=dep;
                qz[dep]=1;
                nxt[p]=k;
                bg=1;
                for(int j=dep+1;j<=mxd;j++) qz[j]=0;
            }
            bool pp=dfs(k,p,dep+1);
            if(pp) nxt[p]=k,bg=1;
        }
    }
    if(mx==-1) return 0;
    if(mx==0)
    {
        if(qz[dep]==1) return 0;
        for(int i=0;i<ed[p].size();i++)
        {
            int k=ed[p][i];
            if(k==fr) continue;
            if(a[k]==-1) continue;
            bool pp=dfs(k,p,dep+1);
            if(pp) nxt[p]=k,bg=1;
        }
    }
    return bg;
}
```
  - 作者：Hovery (4星)
    - 关键亮点：采用 BFS 算法，通过维护每个点的访问顺序及路径上 1 的数量来确定最优路径，代码简洁明了。
    - 核心代码实现思想：使用队列进行 BFS，在遍历过程中根据当前点的状态和子节点的权值更新路径信息，通过比较不同路径上 1 的数量来确定最优路径。
```cpp
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;
    for (int i = 1;i <= n;i++)
    {
        cin >> a[i];
    }
    if (a[1] == -1)
    {
        return 0;
    }
    for (int i = 1;i < n;i++)
    {
        int x, y;
        cin >> x >> y;
        G[x].pb(y);
        G[y].pb(x);
    }
    for (int i = 1;i <= n;i++)
    {
        sort(G[i].begin(), G[i].end());
    }
    q.push({1, 0, a[1] == 1});
    ans = {1, a[1] == 1};
    while (!q.empty())
    {
        auto [x, dep, val] = q.front();
        q.pop();
        vis[x] = 1;
        if (val < mx[dep])
        {
            continue;
        }
        if (val > ans.second)
        {
            ans = {x, val};
        }
        for (auto i : G[x])
        if (!vis[i] && a[i]!= -1)
        {
            int _ = val + (a[i] == 1);
            mx[dep + 1] = max(mx[dep + 1], _);
            q.push({i, dep + 1, _});
        }
    }
    if (ans.second == 0)
    {
        return 0;
    }
    dfs(1, 0);
    int now = ans.first;
    while (now!= 1)
    {
        anss.pb(now);
        now = f[now];
    }
    anss.pb(1);
    reverse(anss.begin(), anss.end());
    for (auto i : anss)
    cout << i << ' ';
}
```
  - 作者：Leasier (4星)
    - 关键亮点：详细证明了不选 -1 和优先选 1 的策略。通过自定义数据结构和多次 DFS 实现，思路独特，对路径选择策略的实现较为细致。
    - 核心代码实现思想：先通过一次 DFS 标记节点相关状态，然后通过循环和条件判断确定可能的最优路径节点，再通过后续 DFS 确定最终路径，同时处理末尾 0 的问题。
```cpp
void dfs1(int u, int father){
    fa[u] = father;
    for (register int i = head[u]; i!= 0; i = edge[i].nxt){
        int x = edge[i].end;
        if (x!= father){
            mark1[u] |= a[x] == 1;
            mark2[u] |= a[x]!= -1;
            dfs1(x, u);
        }
    }
}

void dfs2(int u){
    for (register int i = head[u]; i!= 0; i = edge[i].nxt){
        int x = edge[i].end;
        if (x!= fa[u]){
            dfs2(x);
            vis[u] |= vis[x];
        }
    }
}

void dfs3(int u, int &len){
    int nxt = 0x7fffffff;
    ans[++len] = u;
    for (register int i = head[u]; i!= 0; i = edge[i].nxt){
        int x = edge[i].end;
        if (x!= fa[u] && vis[x] && nxt > x) nxt = x;
    }
    if (nxt!= 0x7fffffff) dfs3(nxt, len);
}
```

• 最优的关键思路或技巧：
    - **思维方式**：通过数学分析得出不选权值为 -1 的点以及优先选 1 的结论，简化问题搜索空间。
    - **代码实现技巧**：利用 vector 存储边并排序来保证字典序最小，在搜索过程中巧妙维护路径状态（如当前路径深度、路径上 1 的数量等）以确定最优路径。

• 可拓展之处：
此类题目属于树上路径搜索与优化问题，类似套路包括根据题目条件分析出剪枝策略，减少搜索空间。同类型题可能会改变权值计算方式、路径限制条件或树的结构特点等。

• 相似知识点洛谷题目：
    - P1330 封锁阳光大学：涉及树的遍历与节点状态选择，与本题在树结构处理上有相似之处。
    - P2016 战略游戏：同样是在树结构上进行决策，通过分析节点关系确定最优策略。
    - P1272 重建道路：需要在树结构中进行路径调整与优化，与本题思路有一定相关性。 

---
处理用时：73.77秒
# 题目信息

# 「SvR-2」音符

## 题目描述

>本题中「子串」指：
>
>若字符串 $s$ 中有一段**连续的**字符构成字符串 $p$，则 $p$ 是 $s$ 的子串。

我们用一个字符串代替一份乐谱，用字符代替每一个音符。

我们定义「重音」表示乐谱中出现了两个**连续**的相同字符，如 $\tt eeeee$ 中存在 $4$ 个「重音」。

现在 Sept 准备写一份长度为 $n$ 的乐谱给 Tpes 看，他对乐谱的评价标准如下：

- 乐谱中每出现一个「重音」，他的愤怒值就会增加 $a$。
- 乐谱中每有一段长度为 $k$ 的**子串**中不存在「重音」，他的愤怒值就会增加 $b$。

现在已知 $n,k,a,b$，请你帮 Sept 构造出一份乐谱，使得 Tpes 的愤怒值 $x$ **最小**。

## 说明/提示

#### 数据规模与约定

**本题采用捆绑测试。**

| $\bf{Subtask}$ | $\bm{n\le}$ | $\bm{\sum n\le}$ | $\bm{T\le}$ | $\bf{Score}$ |
| :-: | :-: | :-: | :-: | :-: |
| $\sf 1$ | $6$ | $10$ | $3$ | $\tt 10$ |
| $\sf 2$ | $10^3$ | $2\times 10^3$ | 无特殊限制 | $\tt 30$ |
| $\sf 3$ | 无特殊限制 | 无特殊限制 | 无特殊限制 | $\tt 60$ |

对于 $100\%$ 的数据，有 $2\le T\le 100$，$2\le n,k\le 10^5$，$1\le a,b\le 10^9$。单组数据内保证 $\sum n\le 2\times 10^5$。

#### 输出注意事项

输出 $x$ 和构造乐谱可以看作是两个子问题，如果你只会完成其中的一个，请在另一个子问题对应的地方用**符合要求的字符或数字**占位。

乐谱中你可以输出任意字符，包括数字、大小写字母等，但**不能出现空格**。

#### Special Judge 返回信息说明

本题采用 Special Judge 判断你的答案是否正确。

checker.cpp 将会以 $\texttt{Score=}\text A,\texttt{Type=}\text B$ 的方式返回信息。

$\tt Score$ 类表示你的得分情况，$\text A$ 有以下取值：

- $\text A=1$，表示含义如下：\
  $\underline\text{Accepted.} \texttt{ Your Ans and SM are both proper.}$\
  代表 $T$ 组答案全部符合要求。
- $\text A=2$，表示含义如下：\
  $\underline\text{Partially Correct.}\texttt{ All Ans are right.}$\
  表示该测试点中你的回答中 $x$ 全部正确，你能得到该测试点 $20\%$ 的分数。
- $\text A=3$，表示含义如下：\
  $\underline\text{Partially Correct.}\texttt{ You pass 70\% tests!}$\
  表示该测试点中你的回答正确的组数**不少于**$\lfloor0.7\times T\rfloor$（$x$ 与乐谱均符合要求），你能得到该测试点 $10\%$ 的分数。
- $\text A=4$，表示该测试点你只能拿到 $0$ 分。

$\tt Type$ 类表示你的得分情况，$\text B$ 有以下取值：

- $\text B=0$，表示你的答案全部正确，与 $\text A=1$ 配对。
- $\text B=1$，表示含义如下：\
  $\underline\text{Wrong Answer.}\texttt{ The length of your SM is not right!}$\
  代表你在一组数据中构造的乐谱的长度不为 $n$。
- $\text B=2$，表示含义如下：\
  $\underline\text{Wrong Answer.}\texttt{ Your Ans is not right!}$\
  代表你在一组数据中 $x$ 的值错误。
- $\text B=3$，表示含义如下：\
  $\underline\text{Wrong Answer.}\texttt{ Your Ans and SM are not matched!}$\
  代表你在一组数据中构造的乐谱使 Tpes 产生的愤怒值不为 $x$。

这里 $\text{Ans, SM}$ 分别表示 Answer（$x$ 的值）和 Sheet Music（乐谱）。

注意到 $\tt Type$ 只会反映你在该测试点中**第一次错误**的类型。

## 样例 #1

### 输入

```
2
4 5 2 2
8 6 3 2```

### 输出

```
0
Sept
3
2023yyds```

# AI分析结果

• **综合分析与结论**：
    - **思路方面**：多数题解都意识到只需关注相邻字符是否相同，可将问题简化为对01串的构造。部分题解采用动态规划（DP），通过状态转移方程计算最小愤怒值并记录方案；部分题解通过贪心策略，分析不同情况下的最优构造方式。
    - **算法要点**：DP解法需合理定义状态与转移方程，如`f(i)`或`f(i, 0/1)`表示考虑到第`i`个字符时的最小愤怒值，转移时考虑重音和无重音子串的代价；贪心解法通过分析`a`与`b`以及`k`的关系，确定如全0、特定重复模式等最优构造。
    - **解决难点**：难点在于如何平衡重音产生的代价`a`和无重音子串产生的代价`b`。DP解法要优化转移以降低时间复杂度，贪心解法要证明构造方式的最优性。

    - **整体结论**：从质量上看，部分题解思路清晰但代码复杂，部分题解代码简洁但思路阐述不够详细。

• **所选的题解**：
  - **作者：CSP_Sept (5星)**
    - **关键亮点**：思路清晰简洁，直接分析出最优解的三种可能情况，并对结论进行了证明。无需复杂计算，通过简单的“平铺”特定字符串即可得到最优解。
    - **核心代码**：无具体代码，但思路为构造长为`(n - 1)`的01串，有三种“平铺”方式：全0、`000…0001`、`000…0001`最后一个1改0。
  - **作者：MarchKid_Joe (4星)**
    - **关键亮点**：先特判`k = 2`的简单情况，再深入分析`XX`（重音）对代价的影响，通过比较`a`与`b * (k - 1)`来决定构造含或不含重音的字符串，思路清晰且代码实现简洁。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 5;
char s[N];
char name[10] = "Nahida";
char same[10] = "AC";
int T, n, k, a, b;
signed main()
{
    cin >> T;
    while (T --> 0)
    {
        int ans = 0, cnt = 0, m = 0;
        cin >> n >> k >> a >> b; s[n + 1] = '\0';
        for (int i = 1; i <= n; i++) s[i] = (k == 2 && a < b)? 'Q' : name[(i - 1) % 6];
        if (k == 2) {ans = (n - 1) * min(a, b);goto print;}
        if (a >= (k - 1) * b) {ans = b * (n - k + 1);goto print;}
        for (int l = 1, r; m = l + k - 1, (r = m + k - 2) <= n; l = m)
            s[m] = s[m - 1] = same[(++cnt) & 1];
        if (a < (n - m + 1) * b)
            s[m] = s[m - 1] = same[(++cnt) & 1];
        else
            ans = (n - m + 1) * b;
        print: cout << max(ans + a * cnt, 0ll) << '\n' << (s + 1) << '\n';
    }
    return 0;
}
```
    - **核心实现思想**：先初始化字符串，特判`k = 2`情况。若`a >= (k - 1) * b`，构造无重音字符串；否则按每隔`k - 1`位置放置重音，最后比较放置与不放置重音的剩余子串代价。
  - **作者：qzhwlzy (4星)**
    - **关键亮点**：通过分类讨论`a`和`b`的大小关系，得出不同情况下的最优`b`数组（表示相邻字符是否相同）构造方式，思路清晰，代码简洁高效。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#define maxn 100005
#define ll long long
using namespace std;
int T,n,k,a,b,out=0,las; ll ans1=0; bool outp[maxn];
int main(){
    scanf("%d",&T); while(T--){
        scanf("%d%d%d%d",&n,&k,&a,&b); out=ans1=las=0;

        for(int i=1;i<n;i++){outp[i]=(i%(k - 1)==0); if(outp[i]) las=i,ans1+=a;}
        if(las&&ans1 - a+1LL*(n - las)*b<ans1){ans1=ans1 - a+1LL*(n - las)*b; outp[las]=0;}

        if(ans1>max(1LL*(n - k + 1)*b,0LL)){
            printf("%lld\n",max(1LL*(n - k + 1)*b,0LL));
            for(int i=1;i<=n;i++,out^=1) printf("%d",out);
        }else{
            printf("%lld\n1",ans1);
            for(int i=1;i<n;i++,out^=1){if(outp[i]) out^=1; printf("%d",out);}
        } printf("\n");
    }
    return 0;
}
```
    - **核心实现思想**：先按`(i%(k - 1)==0)`构造`outp`数组并计算代价`ans1`，再判断最后一个可能的重音位置是否应去除，最后比较两种构造的代价输出结果。

• **最优关键思路或技巧**：
    - **贪心策略**：通过分析`a`与`b * (k - 1)`的大小关系，直接确定最优的字符串构造方式，避免复杂的动态规划计算。
    - **简化问题**：将原字符串问题转化为01串的构造问题，只关注相邻字符是否相同，大大简化了问题的处理。

• **可拓展思路**：此类题目属于构造优化类问题，常见套路是通过分析代价关系确定贪心策略，或通过状态转移方程解决。类似题目常涉及字符串、数组的构造，使某些条件最优。

• **相似知识点洛谷题目**：
    - [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)
    - [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)
    - [P3162 [CQOI2012]组装电脑](https://www.luogu.com.cn/problem/P3162)

• **个人心得**：无。 

---
处理用时：60.93秒
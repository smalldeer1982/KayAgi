# 题目信息

# 「GMOI R2-T2」猫耳小（加强版）

## 题目背景

**本题与 [原题](https://www.luogu.com.cn/problem/P9199) 的区别在于数据范围和输出格式。在这一版本中，$n\le 10^6$，值域为 $10^9$，你需要给出构造。**

![](https://cdn.luogu.com.cn/upload/image_hosting/r8a6ylx3.png)

## 题目描述

小 R 是一个可爱的猫耳女孩子，她喜欢研究数列的 $\operatorname{mex}\text{*}$。

现在她有一个长度为 $n$ 的数列 $a$。她讨厌整数 $k$，因此她希望修改数列 $a$ 的若干个元素为任意**自然数**，使得 $a$ 的任意**连续非空子串**的 $\operatorname{mex}$ 都不等于 $k$。

请你求出最少需要修改多少个元素，并给出方案。

$\text{*}$ 本题中，数列的 $\operatorname{mex}$ 被定义为数列中最小未出现的**自然数**，例如：

- $\operatorname{mex}\{1,2,3\}=0$，因为 $0$ 是自然数。
- $\operatorname{mex}\{0,1,3\}=2$。
- $\operatorname{mex}\{0,1,2\}=3$。

## 说明/提示

**样例解释**

一种方案是将 $\{1,0,1,3,0\}$ 改为 $\{1,1,1,3,2\}$，共改动两个元素。

可以证明不存在更优的方案。

---

**评分方式**

本题采用自定义校验器（Special Judge）进行评测。

对于每个测试点，如果你的最小步数正确，可以得到 $30\%$ 的分数。在此基础上，如果方案也正确，可以得到满分。

请注意：即使你不会给出方案，也请按照输出格式在第二行输出 $n$ 个整数。

---

**本题采用捆绑测试，数据无梯度。**

对于 $100\%$ 的数据，$1\le n\le 10^6$，$0\le k,a_i\le 10^9$。

本题读写量较大，建议使用效率较高的读写方式。

## 样例 #1

### 输入

```
5 2
1 0 1 3 0```

### 输出

```
2
1 1 1 3 2```

# AI分析结果

• 综合分析与结论：
    - 这些题解思路总体一致，均基于贪心策略。核心要点是利用“若子串包含k，其mex必不为k”这一性质，在遍历数列过程中，通过维护0到k - 1数字的出现情况，当发现子串中0到k - 1数字齐全且不含k时，将当前数字改为k以避免mex为k。
    - 解决难点主要在于高效处理大规模数据（n ≤ 10^6，k ≤ 10^9），不同题解采取了不同优化手段，如避免对大数组频繁清零等。
    - 从思路清晰度、代码可读性、优化程度综合评分，sto_5k_orz、QianRan_GG、GeorgeAAAADHD题解相对较好。
• 所选的题解：
  - 作者：sto_5k_orz（5星）
    - 关键亮点：思路简洁清晰，直接利用set来判断0到k - 1数字是否齐全，代码实现简洁高效。
    - 重点代码核心思想：遍历数组，将小于k的数插入set，当set大小为k时，说明0到k - 1数字齐全，将当前数改为k并清空set。遇到k时直接清空set。
```cpp
signed main() {
    cin >> n >> k; int ans = 0;
    for(int i = 1; i <= n; i++) Read(a[i]);
    for(int i = 1; i <= n; i++) {
        if(a[i] == k) {
            st.clear();
            continue;
        }
        if(a[i] < k) st.insert(a[i]);
        if(st.size() == k) {
            ans++; a[i] = k;
            st.clear();
        }
    }
    cout << ans << endl;
    for(int i = 1; i <= n; i++) Write(a[i]);
    return 0;
}
```
  - 作者：QianRan_GG（4星）
    - 关键亮点：对k进行分类讨论，使思路更全面，利用cnt数组记录0到k - 1数字出现个数，逻辑清晰。
    - 重点代码核心思想：根据k的不同情况分别处理。k = 0时，将所有非零数改为0；k > n时，无需修改。1 ≤ k ≤ n时，遍历数组，根据数字与k的大小关系更新cnt数组，当0到k - 1数字都出现时，修改当前数为k并重置cnt数组。
```cpp
if(!k)
{
    for(int i = 1; i <= n; ++ i)
    {
        if(a[i]) ans ++;
        b[i] = 0;
    }
}

else if(k > n) 
{
    for(int i = 1; i <= n; ++ i) b[i] = a[i];
    ans = 0;
}

else
{
    for(int l = 0, i = 1; i <= n; ++ i)
    {
        b[i] = a[i];
        if(a[i] > k) continue;
        else if(a[i] == k)
        {
            while( ++ l < i) if(a[l] < k) cnt[a[l]] --; 
            mex = 0;
        }
        else
        {
            cnt[a[i]] ++;
            while(cnt[mex]) mex ++;
            if(mex == k)
            {
                ans ++;
                while( ++ l < i) if(a[l] < k) cnt[a[l]] --;
                cnt[a[i]] --; 
                b[i] = k;
                mex = 0;
            }
        }
    }
}
```
  - 作者：GeorgeAAAADHD（4星）
    - 关键亮点：同样对特殊情况（k = 0，n < k）进行特判，贪心策略阐述详细，代码注释丰富，可读性强。
    - 重点代码核心思想：与其他题解类似，遍历数组，根据数字与k的大小关系操作计数数组tp，当mex等于k时，修改当前数为k并重置相关变量。
```cpp
else{//正题
    int l=0;
    f(r,1,n){
        cin>>a[r];
        b[r]=a[r];
        if(a[r]>k)continue;//大于k的数无意义
        if(a[r]==k){
            while(++l<r)if(a[l]<k)tp[a[l]]--;//等于k时重置计数数组
            mex=0;//重置mex
            continue;
        }
        else{
            tp[a[r]]++;//计数
            while(tp[mex])mex++;//由于mex具有单调性，因此可以从上一次的计数数组下标为mex的值进行查找
            if(mex==k){//mex等于k
                ans++;//答案加上1
                fill(tp,tp+k,0);//重置计数数组
                l=r;//修改左区间
                b[l]=k;//修改输出数组
                mex=0;//重置mex
            }
        }
    }
}
```
• 最优关键思路或技巧：利用贪心策略，将需要修改的数改为k，通过维护0到k - 1数字的出现情况来判断是否需要修改。在处理大规模数据时，避免对大数组频繁清零操作以优化时间复杂度。
• 可拓展之处：同类型题可涉及其他关于mex概念的运用，类似算法套路是在处理子串相关性质时，通过维护特定数据结构（如set、数组计数等）来优化时间复杂度。
• 推荐洛谷题目：
    - P1440 求mex值
    - P3959 宝藏
    - P5367 [Ynoi2017]由乃的玉米田
• 个人心得：无。 

---
处理用时：53.78秒
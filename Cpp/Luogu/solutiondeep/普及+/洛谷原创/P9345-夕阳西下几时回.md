# 题目信息

# 夕阳西下几时回

## 题目背景

随着夕阳从山间落下，最后一丝余晖逐渐暗淡；美丽的晚霞，终究还是化作一片黑夜。在这番景象中，一阵又一阵的乡愁涌上心头；远离家乡的游子，就算不是病死他乡，又何时能回还？

## 题目描述

夕阳可以被视作由 $n$ 种不同颜色组成的一副图，其中第 $i$ 种的颜色为 $a_i$，满足 $a$ 是长度为 $n$ 的排列。

定义一个排列的乡愁度为：

+ 对于所有 $1\le i\le n$，记 $b_i=\gcd(a_i,a_{i+1})$。特别地，我们认为 $a_{n+1}=a_1$。
+ 排列 $a$ 的乡愁度为序列 $b$ 中**不同**元素的个数。

求是否有一个长度为 $n$，乡愁度为 $k$ 的排列 $p$。若有解，请输出任意一个排列。

## 说明/提示

**【提示】**

一个长度为 $n$ 的排列是一个满足 $1$ 到 $n$ 中的所有正整数恰好出现 $1$ 次的数组。例如，$[3,1,2]$ 是一个长度为 $3$ 的排列，而 $[5,5,1,2,3]$ 不是一个排列。

**【样例 1 解释】**

- 对于第一组数据，$b=[1,1,1,1,1,1,1]$，故 $p$ 的乡愁度为 $1$。
- 对于第二组数据，可以证明不存在这样的序列。
- 对于第三组数据，$b=[1,1,3,3,1,1,2,1,5,2,1]$，包含 $4$ 个不同的元素 — $1,2,3$ 和 $5$，故 $p$ 的乡愁度为 $4$。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（4 points）：$n\le 9$，$\sum n\le 100$。
-  Subtask 2（5 points）：$k=1$。
-  Subtask 3（13 points）：$\sum n\le 200$。
-  Subtask 4（30 points）：对于所有测试数据，保证有解。
-  Subtask 5（48 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$3\le n\le 3\times 10^5$，$1\le k\le n$，$\sum n \le 6\times 10^5$。

## 样例 #1

### 输入

```
3
7 1
6 5
11 4
```

### 输出

```
Yes
1 2 3 4 5 6 7
No
Yes
1 11 9 3 6 7 8 2 5 10 4
```

# AI分析结果

• 综合分析与结论：
    - 思路方面：所有题解均先判断当 \( k > \lfloor\frac{n}{2}\rfloor \) 时无解，原因是 \( 1\) 到 \(n\) 中任意两个不同正整数的最大公约数至多为 \(\lfloor\frac{n}{2}\rfloor\)。对于有解情况，大多题解利用数的倍数关系构造排列，使相邻数的最大公约数有不同取值。
    - 算法要点：通过将数与其倍数相连构造链，如将 \(i\) 与 \(2i\) 连边形成链，再将这些链组合成排列。部分题解根据 \(k\) 值调整排列，如将 \((2k + 1)\sim n\) 倒序接在 \(1\) 后面。
    - 解决难点：难点在于构造出满足乡愁度为 \(k\) 的排列。各题解通过不同方式构造排列并证明其合理性，如利用数学推导证明构造出的排列能产生所需数量不同的最大公约数。
    - 整体质量：多数题解思路清晰，代码实现围绕核心思路展开，但部分题解代码可读性欠佳，一些复杂推导过程未详细阐述。

    最优关键思路或技巧：利用数的倍数关系构造排列，通过连边形成链并组合。同时，根据 \(k\) 值灵活调整排列，如舍去 \((2k + 1)\sim n\) 这些数的影响，且证明剩余数相邻放置不会影响最大公约数种类数。

    可拓展思路：此类题目属于数论构造类型，常见套路是基于数论性质（如最大公约数、倍数关系等）进行排列构造。类似题目可通过分析数的性质，寻找满足特定条件的构造方式。

    推荐题目：
        - P1072 [NOIP2009 普及组] Hankson 的趣味题，考察数论中最大公约数和最小公倍数的计算与应用。
        - P2613 【模板】有理数取余，涉及数论中的同余方程、逆元等知识点。
        - P1463 [POI2002][HAOI2007] 反素数，需深入理解数论中约数个数等性质进行求解。

    个人心得：部分题解提到在处理大数据范围时，手动将标记数组归零比使用 `memset` 效率更高，避免复杂度达到 \(O(\max n)\)。

以下为≥4星题解：
  - 作者：Ecrade_ (5星)
    - 关键亮点：思路清晰简洁，先指出 \(k\) 的理论上界，然后分别针对达到上界和小于上界的情况给出构造方法，代码简洁明了，逻辑连贯。
    - 重点代码及核心思想：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll t,n,k;
inline ll read(){
    ll s = 0,w = 1;
    char ch = getchar();
    while (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}
    while (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
    return s * w;
}
int main(){
    t = read();
    while (t --){
        n = read(),k = read();
        if (k > n / 2){puts("No"); continue;}
        puts("Yes"),printf("1 ");
        for (ll i = n;i >= k * 2 + 1;i -= 1) printf("%lld ",i);
        for (ll i = 1;i <= k * 2;i += 2) for (ll j = max(2ll,i);j <= k * 2;j *= 2) printf("%lld ",j);
        puts("");
    }
    return 0;
}
```
核心思想：先判断 \(k\) 是否大于理论上界，若不大于则先输出 \(1\)，接着倒序输出 \((2k + 1)\sim n\) 的数，最后通过嵌套循环输出构造的链，形成满足乡愁度为 \(k\) 的排列。

  - 作者：SXqwq (4星)
    - 关键亮点：详细分析了构造思路，从证明 \(b\) 数组中不同数字的上限，到考虑最大化不同数字时的构造方式，再到针对 \(k\) 个不同数字的构造，逻辑严谨，代码简洁易懂。
    - 重点代码及核心思想：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int T;
int main()
{
    cin>>T;
    while(T--)
    {
        int n,k;
        scanf("%d%d",&n,&k);
        if(k > n/2) 
        {
            cout<<"No"<<endl;
            continue;
        }
        cout<<"Yes"<<endl;
        cout<<"1 ";
        for(int i=n;i>=2*k+1;i--) cout<<i<<" "; 
        for(int i=2;i<=2*k;i*=2) cout<<i<<" "; 
        for(int i=3;i<=2*k;i+=2) 
        {
            for(int j=i;j<=2*k;j*=2) cout<<j<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```
核心思想：先判断无解情况，有解时先输出 \(1\)，然后倒序输出 \((2k + 1)\sim n\) 的数，接着分别输出 \(2\) 的整次幂和奇数的倍数构造的链，从而得到满足乡愁度为 \(k\) 的排列。

  - 作者：_Weslie_ (4星)
    - 关键亮点：详细阐述思路，从分析 \(k\) 的理论上界，到考虑构造满足条件的排列时遇到的重复问题及解决办法，最后给出针对 \(k\) 值调整排列的方式，逻辑清晰，代码简洁。
    - 重点代码及核心思想：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,k,a[300005];
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&k);
        if(k>n/2){
            printf("No\n");
            continue;
        }
        cout<<"Yes\n1 ";
        for(int i=n;i>=2*k+1;i--)cout<<i<<' ';
        for(int i=1;i<=2*k;i+=2){
            for(int j=max(2,i);j<=k*2;j*=2)cout<<j<<' ';
        }
        cout<<endl;
    }
}
```
核心思想：先判断无解情况，有解时先输出 \(1\)，再倒序输出 \((2k + 1)\sim n\) 的数，最后通过嵌套循环输出构造的链，形成满足乡愁度为 \(k\) 的排列。 

---
处理用时：65.40秒
# 题目信息

# 「LAOI-1」积水

## 题目描述



地表坑洼不平，每当暴雨来临地面上都会有一个个水洼。   
又有一场暴雨即将来临，你决定改造地面来减少积水。     
地面可抽象为一个长度为 $n$ 的正整数序列 $a$，其中 $a_i$ 表示当地的海拔高度。       
下暴雨时将会汇聚在低洼处无法向两侧流走，比如一个序列 $a=[3,1,5,1,2,3]$。     
在下雨后的积水如图所示（有 $5$ 格积水）：

![](https://cdn.luogu.com.cn/upload/image_hosting/79on2oe3.png)

由于人手不足，现在只来得及改变一个地方的海拔高度为任意正整数。

问改造后积水最少有几格。






## 说明/提示

对于前 $5\%$ 的数据，$1\le n\le 5$。       
对于前 $20\%$ 的数据，$1\le \sum  n\le 550$，$1\le a_i\le 500$。     
对于前 $35\%$ 的数据，$1\le \sum n\le 5050$，$1\le a_i\le 5000$。    
对于前 $50\%$ 的数据，$1\le \sum n\le 5050$，$1\le a_i \le 10^9$。  
对于 $100\%$ 的数据，$1\le n,\sum n\le 10^6$，$1\le a_i\le 10^9$。

保证 $1\le T\le 10^4$。

## 样例 #1

### 输入

```
3
6
3 2 1 1 2 3
6
1 1 4 5 1 4
6
1 9 1 9 8 10```

### 输出

```
2
0
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算积水格数以及通过改变一个地方的海拔高度来使积水最少。思路上，大多先求出初始积水格数，再分别考虑抬高和降低海拔两种方式对减少积水的影响。算法要点包括利用前缀/后缀最大值数组、单调栈、RMQ问题（如ST表、线段树）等。解决难点在于准确分析改变海拔后积水变化情况，避免出现新的积水或计算错误。

各题解质量参差不齐，部分题解思路清晰、代码可读性较好且有优化，部分题解存在思路阐述不清晰、代码复杂难读等问题。

### 所选的题解
1. **作者：EdenSky (5星)**
    - **关键亮点**：思路清晰，详细阐述了用RMQ问题求解的过程，通过图片辅助理解，代码注释详细。先通过DP求出每个位置左右峰的位置，进而计算积水格数。对于改变海拔，分存在积水和是峰两种情况讨论，利用ST表解决降低峰高度时计算减少积水格数的复杂问题。
    - **个人心得**：提到线性做法较难想，着重讲述RMQ求解；还分享了卡常经验，如注意`memset()`可能导致的问题。
    - **核心代码片段**：
```cpp
// 计算左右峰位置
l[0]=0,l[1]=0;
for(register int i=2;i<=n;i++)
  if(a[i-1]>=a[l[i-1]]) l[i]=i-1;
  else l[i]=l[i-1];
r[n+1]=0,r[n]=0;
for(register int i=n-1;i>=1;i--)
  if(a[i+1]>=a[r[i+1]]) r[i]=i+1;
  else r[i]=r[i+1];
// 计算积水格数
s=0;
for(register int i=1;i<=n;i++){
  p[i]=min(a[l[i]],a[r[i]]);
  if(p[i]-a[i]>0) w[i]=p[i]-a[i];
  else w[i]=0;
  s+=w[i];
}
// 处理降低峰高度减少积水格数
for(register int i=1;i<=n;i++){
  if(p[i]>=a[i]){
    to=max(a[l[l[i]]],query(l[i]+1,i-1));
    v[l[i]]+=(p[i]-max(to,a[i])>0?
      p[i]-max(to,a[i]):0);
    to=max(a[r[r[i]]],query(i+1,r[i]-1));
    v[r[i]]+=(p[i]-max(to,a[i])>0?
      p[i]-max(to,a[i]):0);
  }
}
// 求最终答案
ans=s;
for(register int i=1;i<=n;i++)
  ans=min(ans,s-w[i]),
  ans=min(ans,s-v[i]);
```
2. **作者：CZ_7 (4星)**
    - **关键亮点**：用简洁的思路和代码解决问题，不依赖复杂数据结构。通过前缀/后缀最大值数组计算每个位置积水，考虑抬高和降低海拔两种方式减少积水。降低海拔时，通过巧妙的条件判断和循环计算从某位置开始能流出的水量，保证复杂度为\(O(n)\)。
    - **个人心得**：分享了在机房调试2个半小时的经历。
    - **核心代码片段**：
```cpp
// 计算前缀和后缀最大值
for(int i=1;i<=n;i++){
  maxl[i]=max(maxl[i-1],a[i]);
}
for(int i=n;i>=1;i--){
  maxr[i]=max(maxr[i+1],a[i]);
}
// 计算总积水和抬高海拔减少的积水
for(int i=1;i<=n;i++){
  ll t=min(maxl[i-1],maxr[i+1]);
  if(t>a[i]){
    sum+=t-a[i];
    cut=max(cut,t-a[i]);
  }
}
// 计算降低海拔减少的积水（从左往右）
int l=1,r=2;
while(r<=n){
  ll low=maxl[l-1],cnt=0;
  while(a[r]<a[l]){
    ll w=min(maxl[r-1],maxr[r+1]);
    if(w>max(low,a[r]))cnt+=w-max(low,a[r]);
    low=max(low,a[r]);
    r++;
    if(r==n+1)break;
  }
  cut=max(cut,cnt);
  l=r;r++;
}
// 从右往左同理
r=n,l=n-1;
while(l>=1){
  ll low=maxr[r+1],cnt=0;
  while(a[l]<a[r]){
    ll w=min(maxl[l-1],maxr[l+1]);
    if(w>max(low,a[l]))cnt+=w-max(low,a[l]);
    low=max(low,a[l]);
    l--;
    if(l==0)break;
  }
  cut=max(cut,cnt);
  r=l;l--;
}
cout<<sum-cut<<'\n';
```
3. **作者：__LYY_p (4星)**
    - **关键亮点**：给出使用线段树的\(\Theta(n\log n)\)解法，思路清晰。利用线段树维护区间最大值计算每个格子积水值，治水方法分抬高和降低海拔。抬高积水格子海拔到水面平行；降低“峰顶”海拔到两侧水面较小者，通过重新计算受影响区间积水情况得到答案。
    - **核心代码片段**：
```cpp
// 线段树构建
void build(int o=1,int l=1,int r=n){
  if(l==r){maxv[o]=h[l];return;}
  int mid=(l+r)>>1;
  build(o<<1,l,mid);
  build(o<<1|1,mid+1,r);
  maxv[o]=max(maxv[o<<1],maxv[o<<1|1]);
}
// 线段树修改
void modify(int x,int k,int o=1,int l=1,int r=n){
  if(l==r){maxv[o]=k;return;}
  int mid=(l+r)>>1;
  if(x<=mid)modify(x,k,o<<1,l,mid);
  else modify(x,k,o<<1|1,mid+1,r);
  maxv[o]=max(maxv[o<<1],maxv[o<<1|1]);
}
// 线段树查询
int query(int ql,int qr,int o=1,int l=1,int r=n){
  if(ql<=l&&r<=qr){return maxv[o];}
  int mid=(l+r)>>1,ans=0;
  if(ql<=mid)ans=max(ans,query(ql,qr,o<<1,l,mid));
  if(mid+1<=qr)ans=max(ans,query(ql,qr,o<<1|1,mid+1,r));
  return ans;
}
// 初始化并计算水深d和LR
void init(){
  build();sum_d=0;
  for(int i=2;i<n;i++){
    d[i]=max(0,min(query(1,i-1),query(i+1,n))-h[i]);
    sum_d+=d[i];
  }
  ans=sum_d;
  h[0]=h[n+1]=inf;
  for(int i=1;i<=n;i++){
    L[i]=i;
    while(h[i]>h[L[i]-1])L[i]=L[L[i]-1];
  }
  for(int i=n;i>=1;i--){
    R[i]=i;
    while(h[i]>h[R[i]+1])R[i]=R[R[i]+1];
  }
  h[0]=h[n+1]=0;
}
// 重新计算积水值
ll recalc(int p,int k){
  ll res=sum_d;
  modify(p,k);
  for(int i=L[p];i<=R[p];i++){
    if(i==p||i==1||i==n)continue;
    int now_d=max(0,min(query(1,i-1),query(i+1,n))-h[i]);
    res-=d[i]-now_d;
  }
  modify(p,h[p]);
  return res;
}
// 主函数中调用
for(int i=1;i<=n;i++){
  if(d[i]==0&&h[i-1]<h[i]&&h[i]>h[i+1])
    ans=min(ans,recalc(i,min(h[i-1]+d[i-1],h[i+1]+d[i+1])));
  ans=min(ans,sum_d-d[i]);
}
```

### 最优关键思路或技巧
1. **利用前缀/后缀最大值数组**：如CZ_7的题解，简洁地计算每个位置的积水情况，降低代码复杂度和理解难度。
2. **RMQ问题的应用**：EdenSky的题解中，通过将问题转化为RMQ问题，利用ST表解决降低峰高度时复杂的积水变化计算，优化了时间复杂度。
3. **分情况讨论改变海拔**：各题解普遍采用分抬高和降低海拔两种情况讨论，全面分析对积水的影响，保证答案准确性。

### 可拓展之处
同类型题可考虑地形积水问题的变体，如改变多个地方海拔、不同地形条件下积水计算等。类似算法套路包括利用单调栈、单调队列解决与地形高低相关的问题，以及用RMQ相关方法优化区间最值查询问题。

### 相似知识点洛谷题目
1. **P1318 积水面积**：与本题计算积水面积思路相似，可作为基础练习。
2. **P3865 【模板】ST表**：专门考察RMQ问题中ST表的应用，有助于理解相关数据结构。
3. **P4185 [USACO18JAN]MooTube G**：涉及区间查询和最大值问题，可锻炼类似的算法思维。 

---
处理用时：91.98秒
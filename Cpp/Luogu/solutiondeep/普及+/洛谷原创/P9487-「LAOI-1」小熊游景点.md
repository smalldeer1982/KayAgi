# 题目信息

# 「LAOI-1」小熊游景点

## 题目描述

小熊的地图上有 $n$ 个景点，每个景点有分数 $s_i$。

$n-1$ 个点对之间有双向直达的公交线路，每条线路有收费 $w_i$。

现在小熊在 $a$ 景点，总司令在 $b$ 景点，他们要**沿简单路径**在 $a\to b$ 路径上的 $p$ 景点汇合，然后**沿简单路径**一起去 $q$ 景点。（$q$ 为任意点，每个人不会游览两次 $p$ 景点）

$m$ 次询问，给定 $a,b$，求 $p,q$，使得小熊和总司令花费之和最小的前提下他们经过的景点分数之和最大，输出他们经过的景点分数之和。（指小熊经过的景点分数之和 $+$ 总司令经过的景点分数之和）

**重复经过的线路收费重复计算，重复经过的景点分数重复计算。**

## 说明/提示

### 样例说明
对于第一组样例，小熊的地图如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ktyzyrx7.png)

其中 $a=4,b=7$，令 $p=3,q=6$。

小熊的路径为 $4\to2\to1\to3\to6$，花费之和为 $1+3+6+(-4)=6$，景点分数之和为 $1+1+1+1+1=5$。

总司令的路径为 $7\to3\to6$，花费之和为 $5+(-4)=1$，景点分数之和为 $1+1+1=3$。

小熊和总司令花费之和为 $6+1=7$，经过的景点分数之和为 $5+3=8$。

可以证明此时小熊和总司令花费之和最小的前提下他们经过的景点分数之和最大。

------------

### 数据范围
**本题采用捆绑测试。**

| Subtask | $n,m$ | $s_i,w_i$ | 特殊性质 | 分数 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $=3\times10^5$ | $\in\lbrack0,10^6\rbrack$ | 无 | $10$ |
| $2$ | $=3\times10^5$ | $\in\lbrack-10^6,10^6\rbrack$ | 小熊的地图是一条链 | $10$ |
| $3$ | $=3\times10^2$ | $\in\lbrack-10^6,10^6\rbrack$ | 无 | $5$ |
| $4$ | $=3\times10^3$ | $\in\lbrack-10^6,10^6\rbrack$ | 无 | $15$ |
| $5$ | $\le 3\times10^5$ | $\in\lbrack-10^6,10^6\rbrack$ | 无 | $60$ |

对于 $100\%$ 的数据，$1\le n,m\le 3\times 10^5$，$\vert s_i\vert,\vert w_i\vert\le10^6$，小熊的地图是一棵树。

（小熊都可以游览景点了，公交价格和景点分数怎么不可以是负数呢？）

## 样例 #1

### 输入

```
7 1
1 1 1 1 1 1 1
1 2 3
3 6 -4
2 5 2
1 3 6
2 4 1
3 7 5
4 7```

### 输出

```
8```

## 样例 #2

### 输入

```
10 10
786755 -687509 368192 154769 647117 -713535 337677 913223 -389809 -824004 
1 2 -785875
1 3 -77082
1 4 -973070
3 5 -97388
2 6 -112274
3 7 657757
4 8 741733
3 9 5656
4 10 -35190
3 3
3 10
7 3
5 1
2 10
10 10
1 6
7 2
8 9
9 1
```

### 输出

```
971424
-1257332
1309101
3420605
-2313033
-2567048
-2467802
352646
759321
1368370
```

# AI分析结果

• 综合分析与结论：
    - 思路方面：这四道题解思路基本一致，都认识到 \(a \rightarrow b\) 路径确定，关键在于对路径上每个 \(p\) 找到使 \(p \rightarrow q\) 路径边权和最小且点权和最大的 \(q\)。
    - 算法要点：均采用树形DP结合树上倍增的方法。树形DP用于预处理每个点相关的最优值，树上倍增用于在 \(a \rightarrow b\) 路径上快速查找最优解。
    - 解决难点：难点主要在于树形DP状态转移方程的推导与实现。要考虑多种情况，如子树内、子树外、父亲节点和兄弟节点的影响等，还需处理好点权和边权的重复计算问题。
    - 质量对比：
        - “OrezTsim”题解思路清晰，详细阐述了DP数组维护的两种情况及实现细节，代码注释较完善，但提到`#define int long long`会导致常数大而TLE，整体质量较高。
        - “5k_sync_closer”题解作为出题人题解，通过数学式子清晰转化问题，详细给出状态转移方程，但代码使用较多自定义结构体和位运算等，可读性稍逊。
        - “sjr3065335594”题解思路阐述详细，代码结构清晰，详细说明了DP数组转移的两种情况，但整体表述和代码简洁度略欠。
        - “262620zzj”题解详细分析DP预处理和询问处理过程，代码实现思路清晰，但代码中部分变量命名较简单，可读性一般。

所选的题解：
  - “OrezTsim”  星级：4星
    - 关键亮点：对树形DP数组维护的两种情况（向子树内走和向父亲走）分析详细，思路清晰，代码注释丰富。
    - 个人心得：维护DP数组时初始值很重要；树上跳祖先时要注意1号节点父亲的特殊处理；`#define int long long`会导致常数大从而TLE。
    - 核心代码片段（关键函数）：
```cpp
inline void dfs0(int cur, int f) {
    fa[0][cur] = f, ch[cur] = {0, s[cur]};
    dep[cur] = dep[f] + 1, pt[cur] = pt[f] + s[cur];
    for (int i = 1; i < 19; ++i) fa[i][cur] = fa[i - 1][fa[i - 1][cur]];
    if (g[cur].size() == 1 && (*g[cur].begin()).fi == f) return ;
    for (auto it: g[cur]) {
        int to = it.fi, v = it.se;
        if (to == f) continue; dfs0(to, cur);
        if (ch[to].fi + v < ch[cur].fi || (ch[to].fi + v == ch[cur].fi && ch[to].se + s[cur] > ch[cur].se))
            ch[cur] = {ch[to].fi + v, ch[to].se + s[cur]};
    }
    for (pii it: g[cur]) {
        int to = it.fi, v = it.se;
        if (to ^ f) val[cur].push_back({ch[to].fi + v, -ch[to].se - s[cur]});
    }
    sort(val[cur].begin(), val[cur].end());
}
```
核心实现思想：此函数用于初始化树形DP数组`ch`，表示从当前点向子树内走的最小边权和与最大点权和。同时处理父亲节点所有儿子的`son`数组，排序后用于后续计算。

  - “5k_sync_closer”  星级：4星
    - 关键亮点：通过数学式子将原问题转化为求静态树链最小值问题，状态转移方程推导详细。
    - 核心代码片段（关键函数）：
```cpp
void D1(int u) {
    for (int i = h[u], v; i; i = e[i].t)
        if (!d[v = e[i].v]) {
            d[v] = d[u] + 1;
            f[v][0] = u;
            for (int i = 1; f[v][i - 1]; ++i)
                f[v][i] = f[f[v][i - 1]][i - 1];
            s[v] = s[u] + a[v];
            D1(v);
            S X = F[v][0] + S{e[i].w, a[v] << 1};
            X.p = v;
            if (X < F[u][0])
                F[u][1] = F[u][0], F[u][0] = X;
            else if (X < F[u][1])
                F[u][1] = X;
        }
}
```
核心实现思想：通过深度优先搜索计算`F`数组，表示从当前点向子树内走的最小边权和与最大点权和，同时记录路径长度和点权和，用于后续状态转移。

  - “sjr3065335594”  星级：4星
    - 关键亮点：对树形DP转移的两种情况（距离`p`最近的点在`p`的子树内和不在子树内）描述清晰，代码结构完整。
    - 核心代码片段（关键函数）：
```cpp
void dfs1(int u) {
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v;
        if (d[v]) continue;
        d[v] = d[u] + 1;
        f[v][0] = u;
        for (int j = 1; f[v][j - 1]; j++)
            f[v][j] = f[f[v][j - 1]][j - 1];
        sum[v] = sum[u] + a[v];
        dfs1(v);
        Node x = dp[v][0] + (Node){edge[i].c, a[v] << 1};
        x.id = v;
        if (x < dp[u][0]) {
            dp[u][1] = dp[u][0]; dp[u][0] = x;
        }
        else if (x < dp[u][1]) {
            dp[u][1] = x;
        }
    }
}
```
核心实现思想：该函数通过深度优先搜索计算`dp`数组，表示当`p = i`时，所能到达的所有点路径的最短和次短值，同时更新点权最大值，考虑了距离`p`最近的点在`p`子树内的情况。

最优的关键思路或技巧：
    - **树形DP状态设计**：通过设计合适的DP状态，如从当前点向子树内走和向父亲走的最小边权和与最大点权和，来解决问题。
    - **换根DP**：利用换根DP处理从不同方向（子树内、子树外）的最优值计算，全面考虑所有情况。
    - **树上倍增优化**：使用树上倍增在树链上快速查找最优解，将时间复杂度优化到 \(O((n + m)\log n)\)。

可拓展之处：
    - 同类型题或类似算法套路：此类问题属于树上路径最值问题，常见套路是结合树形DP和树上数据结构（如树上倍增、树链剖分等）。对于其他树上路径相关的最值、计数等问题，也可尝试用类似方法解决。例如给定树上两点路径，求满足一定条件的子路径最值等。

推荐题目：
    - [P3398 仓鼠找sugar](https://www.luogu.com.cn/problem/P3398)：涉及树上两点路径相关问题，需要结合树上倍增等知识。
    - [P2495 [SDOI2011]消耗战](https://www.luogu.com.cn/problem/P2495)：树形DP与树上倍增结合，通过动态规划解决树上最优决策问题。
    - [P4219 大森林](https://www.luogu.com.cn/problem/P4219)：综合了树链剖分、线段树和动态规划，对树上路径问题处理能力要求较高。 

---
处理用时：80.67秒
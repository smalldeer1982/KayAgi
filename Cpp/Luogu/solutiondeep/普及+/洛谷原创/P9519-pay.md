# 题目信息

# pay

## 题目描述

今天是 L 公司发工资的一天。

$n$ 名员工排成一排准备领工资，编号为 $1\sim n$，第 $i$ 名员工有一个期望快乐值 $a_i$。

老板非常扣，在这 $n$ 名员工中只选择了 $m$ 名员工 $b_1,b_2,\cdots,b_m$ 发 $k$ 元工资。

员工们都非常具有同理心，不仅自己获得工资时会增加快乐值，当周围的员工获得工资时自己也会增加快乐值。

具体地，当与一名员工 A 距离为 $d$ 的员工获得了工资，A 的快乐值会增加 $\max(0, k - d)$。特别地，如果 A 本身就获得了工资，A 的快乐值会增加 $k$。

老板希望，你能找到最小的整数 $k$，使得所有员工的快乐值不低于他的期望。

## 说明/提示

**【样例说明】**

样例 $1$ 中，$k=2$ 时，每个人的快乐值分别为 $3,4,4,4,3$，满足要求。

样例 $2$ 中，$k=5$ 时，每个人的快乐值分别为 $5,7,7,7,7$，满足要求。

**【数据范围】**

对于 $10\%$ 的数据，满足 $n=1$。

对于 $30\%$ 的数据，满足 $n\le 300$。

对于 $60\%$ 的数据，满足 $n\le 5000$。

对于另外 $10\%$ 的数据，满足 $m=1$。

对于 $100\%$ 的数据，满足 $1\le m\le n\le 10^6$，$0\le a_i\le 10^9$，$1\le b_i\le n$ 且 $b_i$ 互不相同。

**本题输入量较大，请注意使用合理的输入方式。**

## 样例 #1

### 输入

```
5 5
3 3 3 3 3
1 2 3 4 5```

### 输出

```
2```

## 样例 #2

### 输入

```
5 2
5 2 6 3 1
2 5```

### 输出

```
5```

# AI分析结果

• 综合分析与结论：这些题解都采用二分答案的方法，将原问题转化为判断给定的k是否能满足所有员工快乐值不低于期望。主要难点在于如何在O(n)时间复杂度内完成这个判断。不同题解在判断方法上各有差异，有的通过维护队列、前缀和等方式计算贡献值，有的利用差分甚至二阶差分来处理等差数列形式的贡献。

所选的题解：
  - 作者：引领天下 (赞：24)  星级：5星
    - 关键亮点：思路清晰，利用队列巧妙维护对当前位置有贡献的位置，通过两次遍历（顺序和逆序）在线性时间内计算出每个员工的快乐值，算法总复杂度O(n log n)，代码简洁明了。
    - 核心代码片段：
```cpp
inline bool check(int k){
    queue<int> q;
    long long sum=0;
    memset(c,0,sizeof(c));
    for(int i=1;i<=n;i++){
        sum-=q.size();
        if(!q.empty()&&i-q.front()>=k)q.pop();
        if(s[i])sum+=k,q.push(i);
        c[i]+=sum;
    }
    while(!q.empty())q.pop();sum=0;
    for(int i=n;i;i--){
        sum-=q.size();
        if(!q.empty()&&q.front()-i>=k)q.pop();
        if(s[i])sum+=k,q.push(i);
        c[i]+=sum;
        if(s[i])c[i]-=k;
    }
    for(int i=1;i<=n;i++)if(c[i]<a[i])return 0;
    return 1;
}
```
核心实现思想：顺序遍历计算前面发工资的人对当前位置的贡献，逆序遍历计算后面发工资的人对当前位置的贡献，两者相加并处理自身发工资的情况后与期望快乐值比较。

  - 作者：Register_int (赞：16)  星级：4星
    - 关键亮点：同样基于二分答案，通过维护三个指针i, p, cnt动态计算每个员工从左边和右边获得的贡献，思路独特，时间复杂度为O(n log V)，代码逻辑清晰。
    - 核心代码片段：
```cpp
inline 
bool check(ll x) {
	ll s = 0;
	for (int i = 1, j = 1, k = 0; i <= n; i++) {
		for (s -= k; k > 0 && i - b[j] >= x; k--, j++);
		v[i] && (k++, s += x), t[i] = s;
	}
	s = 0;
	for (int i = n, j = m, k = 0; i; i--) {
		for (s -= k; k > 0 && b[j] - i >= x; k--, j--);
		v[i] && (k++, s += x, t[i] -= x), t[i] += s;
	}
	for (int i = 1; i <= n; i++) if (t[i] < a[i]) return 0; return 1;
}
```
核心实现思想：正向遍历计算左边贡献，反向遍历计算右边贡献，过程中通过指针移动和变量维护贡献值变化，最后判断是否满足期望。

  - 作者：ShwStone (赞：9)  星级：4星
    - 关键亮点：提供了两种判断方法，一种是维护差分，通过二阶差分处理区间加等差数列的操作，另一种是统计贡献，从左到右扫一遍员工，用变量维护左右区间的工资数目来计算贡献，方法多样。
    - 维护差分核心代码片段：
```cpp
bool check(long long x) {
    memset(d, 0, sizeof d);
    for (int i = 1; i <= m; i++) {
        if (b[i] < x) {
            d[1] += x - b[i] + 1;
            d[2] -= x - b[i];
            d[b[i] + 1]--;
        }
        else {
            d[b[i] - x + 1]++;
            d[b[i] + 1]--;
        }

        d[b[i] + 1]--;
        if (b[i] + x <= n) d[b[i] + x + 1]++;
    }
    for (int i = 1; i <= n; i++) d[i] += d[i - 1];
    for (int i = 1; i <= n; i++) d[i] += d[i - 1];
    for (int i = 1; i <= n; i++) {
        if (d[i] < a[i]) return false;
    }
    return true;
}
```
核心实现思想：对每个发工资的位置进行二阶差分操作，通过两次前缀和还原出每个员工的快乐值并与期望比较。

最优关键思路或技巧：利用二分答案将问题简化，再通过维护队列、指针、差分等方式在O(n)时间内判断二分的k是否满足条件，是解决此类问题的关键技巧。

可拓展之处：同类型题常涉及具有单调性的最值求解，可使用二分答案结合线性时间的判断方法。类似算法套路如在处理区间影响问题时，利用差分或维护相关变量来优化计算。

推荐题目：
 - P2678 [NOIP2015 提高组] 跳石头：二分答案结合贪心判断。
 - P3853 [TJOI2007] 路标设置：同样二分答案，判断是否满足条件。
 - P1873 砍树：二分查找合适的砍树高度。 

---
处理用时：49.53秒
# 题目信息

# 「TAOI-2」Break Through the Barrier

## 题目描述

有一个由 $\tt B$ 和 $\tt T$ 组成的字符串。

你可以进行如下操作：选择一个长度为 $4$ 的子串，其恰好等于 $\texttt{BTTB}$，并将其修改为 $\texttt{TBBT}$。你可以进行这种操作任意多次（也可以不操作）。

定义一个字符串的权值为最长的 $\texttt{T}$ 连续段长度。你需要通过如上操作使得字符串的权值尽可能大。输出这个最大值。

+ 子串的定义：一个字符串 $b$ 被称为字符串 $a$ 的子串，当且仅当可以通过删除 $a$ 开头若干个（可以是 $0$ 个，下同）字符和结尾若干个字符得到 $b$。
+ $\texttt{T}$ 连续段的定义：一个原字符串的仅由 $\texttt{T}$ 构成的子串。

## 说明/提示

**本题采用捆绑测试。**

记 $\sum n$ 为所有数据中的 $n$ 的和。

+ Subtask 0（5 pts）：$n \leq 7$。
+ Subtask 1（20 pts）：$T \leq 10$，$n \leq 10$。
+ Subtask 2（25 pts）：$\sum n \leq 5000$。
+ Subtask 3（5 pts）：保证给定的字符串无法进行任何操作。
+ Subtask 4（45 pts）：无特殊限制。

对于所有数据，$1 \leq T \leq 10^3$，$1 \leq n \leq 10^5$，$1 \leq \sum n \leq 5\times 10^5$，字符串只包含字符 `B` 和 `T`。

## 样例 #1

### 输入

```
6
3
TTT
4
BTTB
5
TBBTT
6
BTBTBB
7
BTTBTTB
17
TTBTBTTBTBTTTBTTB
```

### 输出

```
3
2
2
1
3
5
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是围绕操作的特性，即通过对“BTTB”和“TBBT”的转换规律分析，来确定如何使字符串中最长“T”连续段的长度最大化。
- **思路方面**：多数题解发现一次操作最多使某连续“T”段长度增加2，且需特定子串结构（如“BTTBTBTB...TB”或“BTBTBT...BTTB”）辅助转移“T”。
- **算法要点**：通常先找出原字符串中所有连续“T”段，再判断各段左右两侧是否存在可使该段增长的子串结构。
- **解决难点**：关键在于高效判断连续“T”段两侧能否通过操作增加“T”，不同题解采用了不同优化方法，如预处理标记、状态机、动态规划等。

### 所选的题解
- **作者EdenSky（5星）**
    - **关键亮点**：思路清晰，通过详细分析样例得出操作具有传递性的重要结论，并据此推出多个推论，如连续“T”区块最多增加2个“T”等，为解题提供了坚实理论基础。代码实现巧妙利用双指针查找有连续性的区间并标记，最后通过遍历连续“T”区间得出答案。
    - **个人心得**：无
    - **重点代码**：
```cpp
while(r<=n){//通过双指针查找有连续性的区间
    l++,r++;
    if(c[l]=='B'&&c[l+1]=='T'&&c[l+2]=='T'&&c[l+3]=='B'){
        ri[r]++,le[l]++;//发现存在，则在两端打上标记，le的标记方向向左，ri向右
        while(c[r+1]=='T'&&c[r+2]=='B') r+=2,ri[r]++;//向左右扩展区块并打上标记（找尾巴）
        while(c[l-1]=='T'&&c[l-2]=='B') l-=2,le[l]++;
        l=r-1,r=l+3;//l跳到r的位置，在本次操作后l和r都会++，提前减1
    }
}
l=1,r=l;
while(r<=n){
    l=r,l++,r++;
    if(c[l]!='T') continue;//查询连续T区间
    while(c[r+1]=='T') r++;//扩展连续T区间
    ans=max(r-l+1+ri[l-1]+le[r+1],ans);//查询是否存在标记，注意方向
}
```
核心实现思想：利用双指针遍历字符串，当找到“BTTB”子串时，向左右扩展并标记具有传递性的端点。之后再次遍历字符串，统计连续“T”区间长度并结合端点标记计算可能增加的“T”数量，得出最大长度。
- **作者light_searcher（4星）**
    - **关键亮点**：先提出$50pts$的贪心 + 模拟思路，筛选长度≥maxlen - 1的“T”串判断左右是否可增长，后发现长度为1的串无需考虑这一优化点，使代码通过全部测试点，思路具有层次感和优化意识。
    - **个人心得**：无
    - **重点代码**：
```cpp
void find_out_T(){
    int bgin=0,len=0,tmp=0;
    for(int i=1;i<=n;i++)
        if(s[i]=='T'){
            tmp++;
            maxlen=max(maxlen,tmp);
        }
        else tmp=0;
    ans=maxlen;
    for(int i=1;i<=n;i++)
        if(s[i]=='T'){
            if(s[i-1]!='T') bgin=i;
            len++;
        }
        else{
            if(s[i-1]=='T'&&len>=maxlen-1)    
                g.push_back({bgin,bgin+len-1});
            len=0;
        }
    if(len>=maxlen-1) g.push_back({bgin,bgin+len-1});
}
bool search_l(int pos){
    for(int i=pos;i>=1;i-=2)
        if(s[i]=='T'&&s[i-1]=='B') return i!=pos;
        else if(s[i]!='B'||s[i-1]!='T') return 0;
    return 0;
}
bool search_r(int pos){
    for(int i=pos;i<=n;i+=2)
        if(s[i]=='T'&&s[i+1]=='B') return i!=pos;
        else if(s[i]!='B'||s[i+1]!='T') return 0;
    return 0;
}
for(int i=0;i<g.size();i++){
    int l=g[i].first,r=g[i].second;
    if(l==r) continue;
    ans=max(ans,r-l+1+search_l(l-1)+search_r(r+1));
}
```
核心实现思想：`find_out_T`函数找出长度≥maxlen - 1的连续“T”串存入向量`g`。`search_l`和`search_r`函数分别判断某位置左侧和右侧是否存在可使对应连续“T”串增长的结构。最后遍历向量`g`，计算并更新最大长度。
- **作者dino（4星）**
    - **关键亮点**：先提出$n^2$暴力思路，即利用双指针查找连续“T”段并判断左右是否可增加“T”，后通过DP优化，用四个布尔数组记录从左往右和从右往左是否能变成“TB”或“BT”，从而优化判断过程，思路清晰且有优化步骤展示。
    - **个人心得**：在清空数组时因多清几个位置的问题卡了半天，强调边界处理的重要性。
    - **重点代码**：
```cpp
for(int i = 2; i <= n; i++){
    if(s[i]!= s[i - 1]){//为bt或tb
        if(s[i] == 'T') ltb[i] = ltb[i - 2], lbt[i] = 1;
        else lbt[i] = lbt[i - 2], ltb[i] = 1;
    }
}
for(int i = n - 1; i >= 1; i--){
    if(s[i]!= s[i + 1]){
        if(s[i] == 'T') rbt[i] = rbt[i + 2], rtb[i] = 1;
        else rtb[i] = rtb[i + 2], rbt[i] = 1;
    }
}
int l = 0, r = 0, mx = 0;
while(r <= n){
    if(s[r] == 'T') r++;
    else{
        int cnt = r - l - 1;
        if(lbt[l]) cnt++;//左边能增加一个
        if(rtb[r]) cnt++;//右边能增加一个
        mx = max(mx, cnt);
        l = r;
        r++;
    }
}
```
核心实现思想：通过两个循环进行DP，利用状态转移记录每个位置从左或从右是否能形成特定子串结构。之后利用双指针遍历字符串，统计连续“T”段长度，并结合DP结果判断左右是否可增加“T”，更新最大长度。

### 最优关键思路或技巧
- **传递性分析**：如EdenSky题解，深入分析操作的传递性，得出连续“T”区间长度最多增加2及相关传递性规则，为解题提供清晰逻辑框架。
- **预处理与标记**：不少题解通过预处理标记可能使连续“T”段增长的位置，减少重复判断，提高效率，如EdenSky和light_searcher的代码实现。
- **动态规划优化**：dino题解利用动态规划记录状态，优化判断连续“T”段两侧能否增长的过程，降低时间复杂度。

### 可拓展思路
此类题目属于字符串操作与优化类型，关键在于分析操作对字符串结构的影响规律。类似算法套路包括深入挖掘操作特性、利用预处理和状态记录优化判断过程。同类型题可考虑字符串在特定规则下的变换、合并等操作，目标为最大化或最小化某个指标。

### 相似知识点洛谷题目
- [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：涉及贪心策略在序列操作中的应用，与本题分析操作特性并据此优化结果思路相似。
- [P1247 取火柴游戏](https://www.luogu.com.cn/problem/P1247)：需通过分析游戏规则找到必胜策略，类似本题对字符串操作规则的分析与应用。
- [P2048 游戏](https://www.luogu.com.cn/problem/P2048)：关于在特定游戏规则下对数字矩阵进行操作以达到最优结果，与本题通过操作字符串达到最优指标思路相仿。 

---
处理用时：90.71秒
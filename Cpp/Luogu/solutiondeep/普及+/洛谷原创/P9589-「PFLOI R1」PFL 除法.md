# 题目信息

# 「PFLOI R1」PFL 除法

## 题目背景

[有必要把所有比赛题的背景连在一起](https://www.luogu.com.cn/paste/enzfvjum)。

就这样，新世界的大门向它们敞开了……  

“喵！”一只可爱的花猫向它们问好。  

“你们刚来到这？”  

“嗯。”  

“我带你们去转转吧，谁叫我这么可爱呢！”  

“……” 花猫突然止住，打量一番手中的序列，俶尔又微笑着说：  

“但你们要先答出我的问题哦。”

## 题目描述

花猫有一个长度为 $n$ 的序列 $A$ 和另一个长度为 $m$ 的序列 $B$。你可以进行若干次以下操作：

+ 选择两个整数 $i$ 和 $j$，满足 $1\le i\le n$，$1\le j\le m$ 且 $B_j \mid A_i$，然后将 $A_i$ 变为 $\frac{A_i}{B_j}$。

**注意**：$A$ 和 $B$ 中的每个元素都可以选择并被**操作多次**。

最终要使得 $A$ 中的元素都相等，请求出最少的操作次数；若无解，输出 `-1`。

## 说明/提示

**本题采用捆绑测试**。

| 子任务编号 | 特殊性质 | 分值 | 
| :----------: | :----------: | :-----:| 
| $1$ | $A$ 中所有元素相等 | $5$ |
| $2$ | $n=2$ | $15$ |
| $3$ | $n,m\le10^3$ | $20$ | 
| $4$ | $n,m\le10^4$ | $20$ | 
| $5$ | 无 | $40$ |

对于所有数据，$1\le n,m\le5\times10^5$，$1\le A_i,B_i\le5\times10^5$。

## 样例 #1

### 输入

```
4 5
16 24 28 36
11 4 7 3 2```

### 输出

```
6```

## 样例 #2

### 输入

```
2 3
11 13
13 1 11```

### 输出

```
2```

## 样例 #3

### 输入

```
2 2
2 3
4 5```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论
所有题解思路均基于枚举最终所有数要变成的值 \(D\)，且 \(D\) 是 \(\gcd(A_1,A_2,\cdots,A_n)\) 的因数，然后将每个 \(A_i\) 变为 \(D\) 的问题转化为用 \(B\) 中的数构成 \(\frac{A_i}{D}\) 的最小次数问题。
 - **算法要点**：多数题解采用动态规划预处理出用 \(B\) 中的数构成某个数的最小次数，部分题解提到对 \(B\) 数组去重优化时间复杂度，时间复杂度多为 \(O(n\log n)\) 级别。
 - **解决难点**：难点在于如何高效地处理将每个 \(A_i\) 变为目标值 \(D\) 的操作次数计算。通过将问题转化为背包问题或类似宽搜的方式解决。

### 所选的题解
 - **作者：qwq___qaq（5星）**
    - **关键亮点**：思路清晰，先阐述正向求解困难从而转换思路枚举最终值，详细说明了问题转化过程，对背包优化及时间复杂度分析到位，代码简洁且注释清晰。
    - **重点代码及核心思想**：
```cpp
// 计算将所有数变为x的操作次数
inline int get(int x){
    int s = 0;
    for(int i = 1; i <= n; ++i){
        if(a[i] % x)
            return inf;
        if(dp[a[i] / x] == inf)
            return inf;
        s += dp[a[i] / x];
    }
    return s;
}
// 主函数
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for(int i = 1; i <= n; ++i)
        cin >> a[i], V = max(V, a[i]);
    for(int i = 1; i <= m; ++i)
        cin >> b[i], V = max(V, b[i]);
    sort(a + 1, a + n + 1);
    sort(b + 1, b + m + 1);
    m = unique(b + 1, b + m + 1) - b - 1;
    memset(dp, inf, sizeof(dp)), dp[1] = 0;
    // 背包预处理
    for(int i = 1; i <= m; ++i)
        for(int s = b[i]; s <= V; s += b[i])
            dp[s] = min(dp[s], dp[s / b[i]] + 1);
    // 枚举最终值
    for(int i = 1; i <= a[1] / i; ++i)
        if(a[1] % i == 0)
            ans = min({ans, get(i), get(a[1] / i)});
    if(ans == inf)
        ans = -1;
    cout << ans << endl;
    return 0;
}
```
核心思想是先通过背包预处理出每个数变为1的最小操作次数，再枚举最终可能相等的值，计算将所有数变为该值的总操作次数并取最小。
 - **作者：LCat90（4星）**
    - **关键亮点**：思路阐述清晰，对时间复杂度分析详细，代码结构清晰，有明确的变量定义和注释。
    - **重点代码及核心思想**：
```cpp
signed main() {
    cin >> n >> m;
    for(int i = 1;i <= n; ++i) scanf("%d", &a[i]), V = max(V, a[i]), Gcd = __gcd(Gcd, a[i]);
    for(int i = 1, y;i <= m; ++i) {
        scanf("%d", &y);
        if(y!= 1) b[++mx] = y, V = max(V, y);  
    } m = mx;
    sort(b + 1, b + m + 1);
    m = unique(b + 1, b + m + 1) - b - 1;
    memset(dp, 0x3f, sizeof dp);
    dp[1] = 0;
    // 预处理
    for(int i = 1;i <= m; ++i)
        for(int j = 1;j * b[i] <= V;j ++) dp[j * b[i]] = min(dp[j * b[i]], dp[j] + 1);
    // 枚举最终值
    for(int i = 1;i * i <= Gcd; ++i)
        if(Gcd % i == 0) {
            int s = 0;
            for(int j = 1;j <= n; ++j) {
                if(dp[a[j] / i] == 0x3f3f3f3f) { s = 1e9; break ; }
                s += dp[a[j] / i];
            }
            ans = min(ans, s);
            s = 0;
            for(int j = 1;j <= n; ++j) {
                if(dp[a[j] / (Gcd / i)] == 0x3f3f3f3f) { s = 1e9; break ; }
                s += dp[a[j] / (Gcd / i)];
            }
            ans = min(ans, s);
        } 
    cout << (ans == 1e9? -1 : ans);
    return 0;
}
```
核心思想是先预处理出用 \(B\) 中的数将一个值变为1的最少操作次数，再枚举 \(\gcd(A)\) 的因数作为最终相等的值，计算将 \(A\) 中所有数变为该值的总操作次数取最小。
 - **作者：yanhao40340（4星）**
    - **关键亮点**：通过证明 \(f(A_i,x)=f(mA_i,mx)\) 简化问题，采用类似宽搜的方法预处理，对时间复杂度分析详细且打表验证。
    - **重点代码及核心思想**：
```cpp
sort(b+1,b+m+1);
m=unique(b+1,b+m+1)-b-1; //去重
for (int i=1;i<=m;++i) if (b[i]^1) //特判 1 的情况
    q.push(b[i]),cnt[b[i]]=1;
while (!q.empty()){
    int fr=q.front();q.pop();
    for (int i=1;i<=m;++i){
        if (b[i]==1) continue; //剪枝
        int tmp=fr*b[i]; //这里会爆 int
        if (tmp>=maxn) break; //剪枝
        else if (cnt[tmp]==inf) q.push(tmp),cnt[tmp]=cnt[fr]+1;
    }
}
```
核心思想是利用类似宽搜的方式，从 \(B\) 中的数出发，更新每个数变为1的最小操作次数，后续枚举 \(\gcd(A)\) 的因数计算总操作次数。

### 最优关键思路或技巧
 - **逆向思维**：不直接正向求解所有情况的最小次数，而是枚举最终所有数相等的情况，求每种情况的最小次数。
 - **问题转化**：将将 \(A_i\) 变为 \(D\) 的问题转化为用 \(B\) 中的数构成 \(\frac{A_i}{D}\) 的最小次数问题，类似背包问题求解。
 - **优化技巧**：对 \(B\) 数组去重，降低时间复杂度，利用调和级数优化到 \(O(n\log n)\)。

### 拓展思路
此类题目属于数论与动态规划结合的问题，类似套路是先分析最终结果与初始数据的数论关系（如因数、倍数、最大公约数等），再通过动态规划解决操作次数或路径问题。同类型题可考虑一些涉及数字变换并求最优解，且操作基于数的整除关系的题目。

### 相似知识点洛谷题目
 - [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)：考察数论中的扩展欧几里得算法。
 - [P1463 [POI2002][HAOI2007]反素数](https://www.luogu.com.cn/problem/P1463)：涉及数论中反素数的性质及因数相关知识。
 - [P2152 [SDOI2009]SuperGCD](https://www.luogu.com.cn/problem/P2152)：主要考察高精度运算与数论中最大公约数的求解。

### 个人心得摘录与总结
 - **作者：哈哈人生**：提到赛事中数据有个毒瘤点，正常求最大公因数会导致有解变无解，需要往次大公因数等取值。总结为做题时不能只依赖常规思路，数据可能存在特殊情况，需考虑全面。 

---
处理用时：78.69秒
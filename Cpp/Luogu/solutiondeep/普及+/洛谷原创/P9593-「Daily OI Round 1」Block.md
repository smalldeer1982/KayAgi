# 题目信息

# 「Daily OI Round 1」Block

## 题目描述

给定一棵树，节点有颜色，在树上距离为 $2$ 的点连边（仍保留原来的边），求新图中颜色相同且连通的非空点集数量。由于答案可能非常大，您只需输出答案对 $10^9+7$ 取模的值。

点集连通的定义：对于图 $G(V,E)$，$V$ 的一个子集 $V'$ 是连通点集，当且仅当 $G(V',E')$ 是一个连通图，其中边集 $E'=\{(u,v)|(u,v)\in E\land u \in V'\land v\in V'\}$。

## 说明/提示

样例 1 中，原树如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/zmgrnwkh.png)

树上距离为 $2$ 的点连边后，新图如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/id3xc54a.png)

则 $8$ 个颜色相同且连通的非空点集分别是：$\{1\},\{2\},\{3\},\{4\},\{1,3\},\{1,4\},\{3,4\},\{1,3,4\}$。

**本题开启捆绑测试。**



|$\text{Subtask}$|分值|$n \le$| 特殊性质 | 子任务依赖 |
| :-----------: | :-------------:|:-----------: |:-----------: |:-----------: |
|$0$|$5$|$10^5$| A | 无 |
|$1$|$5$|$16$| 无 | 无 |
|$2$|$5$|$10^5$| B | 无 |
|$3$|$15$|$10^5$| C | 无 |
|$4$|$20$|$10^5$| D | 无 |
|$5$|$50$|$10^5$| 无 | $0\sim4$ |

- 特殊性质 A：所有节点的颜色不相同。
- 特殊性质 B：给出的树是菊花，具体地，第 $i$ 条边连接节点 $1$ 和节点 $i+1$。
- 特殊性质 C：给出的树是链，具体地，第 $i$ 条边连接节点 $i$ 和节点 $i+1$。
- 特殊性质 D：所有节点的颜色相同。


对于全部数据，满足 $2\leq n\leq 10^5$，$1\leq c_i\leq n$。

## 样例 #1

### 输入

```
4
1 2 1 1
1 2
2 3
2 4
```

### 输出

```
8```

## 样例 #2

### 输入

```
6
1 2 2 2 1 2
5 3
2 1
4 5
6 3
3 1
```

### 输出

```
14```

## 样例 #3

### 输入

```
16
1 1 2 1 1 2 2 2 1 1 2 1 1 1 2 1
12 8
14 9
10 8
1 16
7 12
6 1
14 8
3 1
12 5
1 13
12 2
1 12
15 8
11 5
4 12
```

### 输出

```
442```

## 样例 #4

### 输入

```
16
11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11
4 14
4 15
12 13
2 5
7 15
10 2
15 8
15 13
9 11
13 11
3 15
8 16
6 13
1 4
10 4```

### 输出

```
27454```

## 样例 #5

### 输入

```
9
3 3 2 3 2 4 2 3 3
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9```

### 输出

```
16```

# AI分析结果

• 综合分析与结论：
    - 这几道题解均采用树形DP解决问题。核心思路是通过定义合适的状态，利用树的递归结构进行状态转移，从而统计新图中颜色相同且连通的非空点集数量。
    - 算法要点在于准确描述状态，如是否选择当前节点、子树内的选择情况等，并据此构建状态转移方程。解决难点在于考虑各种情况的完整性，例如选择当前节点时子树的选择方式，不选择当前节点时儿子节点的选择组合等。
    - 从思路清晰度、代码可读性和优化程度来看，“recollect_i”和“by_chance”的题解相对较好，“一只绝帆”的题解在思路表述上稍显复杂，“MrPython”的题解代码使用了较多自定义结构，可读性略逊一筹。

所选的题解：
  - 作者：recollect_i (5星)
    - 关键亮点：思路清晰，状态定义明确，$f_u$表示只考虑原树中$u$的子树中的点、选择点$u$的方案数，$g_{u,c}$表示考虑$u$的子树，不选择$u$，选择至少两个颜色为$c$的儿子节点的方案数。通过两个状态转移方程分别计算这两个值，最后累加得到答案。
    - 核心代码（dp函数部分）：
```cpp
void dp(int u, int fa)
{
    f[u] = 1;
    for(int i = la[u]; i; i = ne[i])
    {
        int v = en[i];
        if(v == fa) continue ;
        dp(v, u);
        
        LL t = 1;
        for(int j = la[v]; j; j = ne[j])
        {
            int w = en[j];
            if(w == u) continue ;
            if(c[w] == c[u]) t = t * (f[w] + 1) % P;
        }
        if(c[v] == c[u]) t = (t + f[v]) % P;
        f[u] = f[u] * t % P;
    }
    for(int i = la[u]; i; i = ne[i])
    {
        int v = en[i];
        if(v == fa) continue ;
        g[c[v]] = g[c[v]] * (f[v] + 1) % P;
    }
    for(int i = la[u]; i; i = ne[i])
    {
        int v = en[i];
        if(v == fa) continue ;
        res = (res + g[c[v]] - 1) % P;
        g[c[v]] = 1;
    }
}
```
核心实现思想：先递归处理子节点的DP值，然后根据子节点的情况更新$f[u]$，再通过遍历儿子节点更新$g$数组，最后统计答案。

  - 作者：by_chance (4星)
    - 关键亮点：状态定义简洁，$dp_u$为在$u$子树内，包含$u$的合法点集数目。通过对儿子节点两种情况（包含儿子和不包含儿子）的讨论构建转移方程，统计答案时思路清晰。
    - 核心代码（dfs函数部分）：
```cpp
void dfs(int u,int fa){
    for(int v:G[u])if(v!=fa)dfs(v,u);
    dp[u]=1;
    for(int v:G[u])if(v!=fa)
        g[c[v]]=1ll*g[c[v]]*(dp[v]+1)%P;
    f[u]=g[c[fa]];
    for(int v:G[u])if(v!=fa)
        dp[u]=1ll*dp[u]*(f[v]+dp[v]*(c[v]==c[u]))%P;
    for(int v:G[u])if(v!=fa)
        ans=(ans+g[c[v]]-1)%P,g[c[v]]=1;
}
```
核心实现思想：先递归处理子节点，接着根据子节点更新$dp[u]$，同时利用$g$数组统计不包含$u$的点集方案数，最后累加答案。

最优关键思路或技巧：
    - 树形DP中状态的准确设计，通过定义不同状态表示选择或不选择当前节点以及子树内的选择情况，使得问题能够逐步解决。
    - 在状态转移时，充分考虑儿子节点及其子树的各种选择情况，保证答案的完整性。

可拓展之处：
    - 同类型题可涉及不同的图结构（如仙人掌图等）或更复杂的点边关系，类似算法套路是利用图的结构特点进行状态定义和转移，关键在于准确描述状态以覆盖所有情况。

推荐洛谷题目：
    - P1352 没有上司的舞会：经典树形DP，通过选择或不选择节点来计算最大价值。
    - P2015 二叉苹果树：在二叉树上进行DP，根据保留的边数计算最大价值。
    - P3177 [HAOI2015]树上染色：在树上通过染色节点，根据染色规则计算最大收益，同样是树形DP问题。 

---
处理用时：46.61秒
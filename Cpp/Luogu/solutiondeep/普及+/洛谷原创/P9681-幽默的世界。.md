# 题目信息

# 幽默的世界。

## 题目背景

@【数据删除】 : 大家觉得呢 || @【数据删除】 : oi 生活总是充满了幽默。 不过学文化课或许也好不了多少？

## 题目描述

给定一个长为 $n$ 的序列 $a_1,a_2,\cdots,a_n$，定义 $a$ 的一个连续子序列 $a_l,a_{l+1},\cdots,a_r$ 是幽默的，当且仅当：

- $\sum\limits_{i=l}^ra_i>0$；
- 对于所有 $l\le x\le y<r$，满足 $\sum\limits_{i=x}^y a_i\le 0$。

$q$ 次询问，每次给定两个整数 $l,r$，查询满足以下条件的数对 $(l',r')$ 个数：

- $l\le l'\le r'\le r$；
- 连续子序列 $a_{l'},a_{l'+1},\cdots a_{r'}$ 是幽默的。

## 说明/提示

对于所有数据，保证 $1\le n,q\le 2\times 10^5$，$1\le l\le r\le n$，$|a_i|\le 10^9$。

### 子任务

|  #   |       特殊性质        | 分值 |
| :--: | :-------------------: | :--: |
|  0   |         样例          |  0   |
|  1   |      $n,q\le 50$      |  15  |
|  2   | $n,q\le 3\times 10^3$ |  20  |
|  3   |  对于所有询问，$r=n$  |  15  |
|  4   |  对于所有询问，$l=1$  |  15  |
|  5   |           -           |  35  |


## 样例 #1

### 输入

```
4 3
3 -4 -1 2
1 2
3 4
1 4
```

### 输出

```
1
2
3
```

## 样例 #2

### 输入

```
7 6
-1 2 -1 -1 -1 2 -1
2 5
4 7
1 7
5 5
1 3
2 4
```

### 输出

```
1
2
4
0
2
1
```

# AI分析结果

• 综合分析与结论：
    - 这些题解都围绕如何高效统计满足特定条件的连续子序列个数展开。核心思路是利用幽默子序列“除最后一个数为正数外其余为非正数且总和大于0”的性质。
    - 算法要点包括预处理、二分查找、离线处理、使用数据结构（如树状数组、线段树）等优化查询效率。
    - 解决难点在于如何在大规模数据下快速找到符合条件的子序列，并处理好询问区间与子序列的关系。
    - 整体来看，各题解在思路清晰度、代码可读性、优化程度上有所差异。

所选的题解：
  - 作者：HFanGDoDM (5星)
    - 关键亮点：对每个子任务逐步分析，思路清晰，从暴力枚举到利用二分、前缀和、离线处理等优化，全面且深入，代码注释详细。
    - 个人心得：无
    - 核心代码片段（子任务5）：
```cpp
int now=0;
for(i=1;i<=n;i++){
    lef[i]=now;
    if(a[i]>0)
        now=i;
}
now=n+1;
for(i=n;i>=1;i--){
    rig[i]=now;
    if(a[i]>0)
        now=i;
}
// 预处理num数组及前缀和
int l=R(),r=R(),pos=rig[l-1];
if(pos>r){
    puts("0");
    continue;
}
printf("%d\n",sumn[r]-sumn[l-1]-num[pos]+min(num[pos],pos-l+1));
```
核心实现思想：先预处理出每个位置左边和右边第一个正数的位置，再预处理以每个位置为右端点的符合题意子序列个数及其前缀和。查询时，根据询问区间找到相关位置，结合前缀和计算答案。

  - 作者：Aakkosetsumussa (5星)
    - 关键亮点：代码简洁明了，分析透彻，通过观察序列中每个数对答案的贡献，从后往前计算贡献并前缀和，预处理相关信息实现O(n + q)时间复杂度。
    - 个人心得：无
    - 核心代码片段：
```cpp
ll n, q, a[N];
ll lst[N], pre[N], sum[N];

void init() {
    for(ll i=n, p=1e15, s=0; i>=1; i--) {
        if(a[i]>0) p=i, s=a[i];
        lst[i]=p;
        if(i!=p && p!=1e15) s+=a[i];
        if(s>0) sum[i]=1;
    }
    for(ll i=1, p=1e15; i<=n; i++) {
        if(a[i]>0) p=i;
        pre[i]=p;
    }
    for(ll i=1; i<=n; i++) sum[i]+=sum[i-1];
}

int main() {
    n=rd(), q=rd();
    for(ll i=1; i<=n; i++) a[i]=rd();

    init();

    for(ll i=1; i<=q; i++) {
        ll u=rd(), v=rd();
        if(pre[v]==1e15) printf("0\n");
        else {
            if(lst[v]>v) v=pre[v];
            if(v<u) printf("0\n");
            else printf("%lld\n", sum[v]-sum[u-1]);
        }
    }
    return 0;
}
```
核心实现思想：通过init函数预处理出每个数后面第一个正数的位置lst、前面第一个正数的位置pre以及每个数对答案的贡献sum（并前缀和）。查询时，根据预处理信息判断并计算答案。

  - 作者：Accelessar (4星)
    - 关键亮点：先得出合法区间的重要结论，基于结论预处理出所有合法区间，再利用树状数组优化查询，将复杂度降到O((n + q)log n)。
    - 个人心得：从不同角度思考同一结论对解题有帮助。
    - 核心代码片段：
```cpp
#define fr(i,l,r) for(int i(l);i<=r;i++)
int n,q,l,r,c[N];
ll a[N],s[N];

// 树状数组单点加区间查
inline void add(int k,int x){for(;k<=n;k+=k&-k)c[k]+=x;}
inline int ask(int l,int r){
    int res=0;
    for(;r;r&=r-1)res+=c[r];
    for(--l;l;l&=l-1)res-=c[l];
    return res;
}

int main(){
    rd(n,q);
    vector<int>b;
    fr(i,1,n)s[i]=s[i-1]+rd(a[i]),a[i]>0&&b.eb(i);

    vector<pii>t;
    fr(i,1,n){
        auto it=lower_bound(all(b),i);
        if(it!=end(b)&&s[*it]-s[i-1]>0)t.eb(i,*it);
    }reverse(all(t));

    vector<array<int,4>>query;
    fr(i,1,q)rd(l,r),query.push_back({l,r,i,0});
    sort(all(query),greater());
    for(int pos=0;auto&[l,r,i,ans]:query){
        while(pos<(int)t.size()&&t[pos].first>=l)add(t[pos].second,1),pos++;
        ans=ask(l,r);
    }sort(all(query),[](auto x,auto y){return x[2]<y[2];});
    for(auto[l,r,i,ans]:query)cout<<ans<<'\n';
    return 0;
}
```
核心实现思想：先记录所有正数位置，对每个位置二分查找后面第一个正数构成合法区间。将询问离线排序，利用树状数组，在处理询问时加入左端点满足条件的合法区间，通过树状数组查询区间和得到答案。

最优关键思路或技巧：
    - 利用幽默子序列的性质，将问题转化为对正数及其前后非正数的处理。
    - 预处理相关信息，如前缀和、前后第一个正数位置等，减少重复计算。
    - 采用离线处理，结合二分查找、数据结构（树状数组等）优化查询复杂度。

可拓展之处：同类型题常考察对序列性质的挖掘和利用，通过预处理和数据结构优化查询。类似算法套路有扫描线算法解决区间统计问题、利用单调性二分查找等。

推荐题目：
    - P3372 【模板】线段树 1
    - P3368 【模板】树状数组 2
    - P1972 [SDOI2009]HH的项链 

---
处理用时：77.87秒
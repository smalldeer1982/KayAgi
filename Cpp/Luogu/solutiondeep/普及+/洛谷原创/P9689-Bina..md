# 题目信息

# Bina.

## 题目描述

小 J 家门前有两棵树，一棵是二叉树，一棵是三叉树。

你被小 J 叫来修剪他的二叉树，使得他的二叉树的“美丽值”最大，所谓一棵树的美丽值 $=$ 这棵树的点的编号之和 $\div$ 这棵树的深度（结果向下取整）。

这棵二叉树有一个构建参数 $n$，构建方式如下：

```cpp
void build(int s,int t,int p){
  if(s==t) return ;
  build(s,(s+t)/2,2*p);
  build((s+t)/2+1,t,2*p+1);
  add_edge(p,2*p),add_edge(p,2*p+1);
}

int main(){
  build(1,n,1);
  return 0;
}
```

其中 `build(s,t,p)` 函数参数中的 $p$ 是当前点的编号，`add_edge(x,y)` 函数是指将编号为 $x$ 的点向编号为 $y$ 的点连接一条有向边。

容易发现这棵树的根节点是 $1$，并且我们规定节点的深度为节点到根节点路径上经过的点的个数（包括自己和根节点），这棵树的深度即为所有节点深度的最大值。

对于 $n=3$ 的情况，最后构建出来的结果如下，这棵树的深度为 $3$，你需要选择一个深度 $k$ 把深度大于 $k$ 的点都剪掉，但是 $k$ 必须**大于等于** $1$ 且**小于等于**这棵树的深度。

![](https://cdn.luogu.com.cn/upload/image_hosting/ueggbyn8.png)

小 J 还给了你一个要求，你剪去的节点个数一定得大于等于 $m$ 他才会高兴，你需要保证让他高兴的同时树的“美丽值”最大。

现在小 J 给了你构建树的参数 $n$ 和至少剪的节点个数 $m$，要你求出来他的树在你修剪后最大的美丽值是多少，如果无论如何你也不可能让小 J 高兴，输出 $-1$。

## 说明/提示

#### 【样例解释 #1】

对于第一组样例，$n$ 都等于 $3$，构建出来的树同题面所示。

如果我们选择把深度大于 $1$ 的节点全部剪掉，那么我们剪掉了 $2,3,4,5$ 共 $4$ 个节点，美丽值为 $1$。

如果我们选择把深度大于 $2$ 的节点全部剪掉，那么我们剪掉了 $4,5$ 共 $2$ 个节点，美丽值为 $\lfloor \dfrac{1+2+3}{2}\rfloor = 3$。

如果我们选择把深度大于 $3$ 的节点全部剪掉，那么我们没有剪掉任何节点，美丽值为 $\lfloor \dfrac{1+2+3+4+5}{3}\rfloor = 5$。

所以对于 $m=0$ 的情况，答案为 $5$；对于 $1 \le m \le 2$ 的情况，答案为 $3$；对于 $3 \le m \le 4$ 的情况，答案为 $1$；其它情况，无解输出 $-1$。

#### 【数据范围】

对于所有测试数据，满足 $1 \le T \le 10^5$，$1 \le n \le 10^9$，$0 \le m \le 2 \times 10^9$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n \le$ | $m \le$ | $T \le$ | 特殊限制 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1 \sim 2$ | $10^3$ | $10^5$ | $10^3$ | 无 |
| $3 \sim 4$ | $10^6$ | $2 \times 10^6$ | $10^5$ | 无 |
| $5$ | $10^9$ | $1$ | $10^5$ | 无 |
| $6$ | $10^9$ | $2$ | $10^5$ | 无 |
| $7 \sim 8$ | $10^9$ | $3$ | $10^5$ | 无 |
| $9 \sim 10$ | $10^9$ | $2 \times 10^9$ | $10^5$ | $m \ge 1$ |
| $11 \sim 12$ | $10^9$ | $10^3$ | $10^5$ | 无 |
| $13 \sim 16$ | $10^9$ | $2 \times 10^9$ | $10$ | 无 |
| $17 \sim 20$ | $10^9$ | $2 \times 10^9$ | $10^5$ | 所有 $n$ 均相同 |
| $21 \sim 25$ | $10^9$ | $2 \times 10^9$ | $10^5$ | 无 |

## 样例 #1

### 输入

```
6
3 0
3 1
3 2
3 3
3 4
3 5```

### 输出

```
5
3
3
1
1
-1```

## 样例 #2

### 输入

```
10
5 5
10 0
999 155
135 92
1000232 234255
10293845 1239485
123948 1239454
12394 2131094
1000000000 98765432
1000000000 999999999```

### 输出

```
3
40
52377
1161
27487764480
5864061665280
-1
-1
19215358392218419
4969489234738635```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何计算给定构建方式的二叉树在修剪后最大美丽值的问题。思路上，多数题解先分析出树的结构特点，如除最后一层外为满二叉树，再通过枚举保留层数计算美丽值。算法要点包括利用树的结构特性计算节点编号和与节点数，部分题解还用到记忆化搜索、分治等优化。解决难点在于如何高效计算最后一层节点编号和以及优化计算过程以满足时间复杂度要求。

所选的题解：
  - 作者：离散小波变换° (赞：13)  星级：4星
    - 关键亮点：指出构建的树为线段树，利用线段树区间长度本质不同的节点个数只有\(\mathcal O(\log n)\)种的结论，通过归纳法证明并计算子树节点编号和为关于根节点编号的一次函数，先暴力计算再优化至\(\mathcal O(T\log n)\)复杂度。
    - 个人心得：提到出题人卡常数。
    - 重点代码：
```cpp
// 计算子树节点编号和相关函数
void solve(int n, int d){
    if(n <= o && d <= g)
        return;
    if(M[d].count(n))
        return;
    if(n == 1 || d == 1){
        M[d][n] = {1, 1, 0};
        return;
    }
    const int n1 = (n + 1) / 2, n2 = n - n1;
    solve(n1, d - 1);
    solve(n2, d - 1);
    const auto &[c1, u1, v1] = n1 <= o? H[n1][min(g, d - 1)] : M[d - 1][n1];
    const auto &[c2, u2, v2] = n2 <= o? H[n2][min(g, d - 1)] : M[d - 1][n2];
    M[d][n] = {
        c1 + c2 + 1, 1 + 2 * u1 + 2 * u2, v1 + u2 + v2
    };
}
```
核心实现思想：通过递归计算不同长度和深度的子树节点编号和相关的系数，利用记忆化避免重复计算。
  - 作者：qczrz6v4nhp6u (赞：10)  星级：4星
    - 关键亮点：观察建树代码得出树的结构特点，通过枚举删掉层数计算贡献，对于最后一层节点编号和，通过分析节点分布规律，利用二进制翻转等知识得出计算式，时间复杂度\(O(T\log n)\)。
    - 个人心得：考场上没调出来，后添加计算\(cnt\)的说明。
    - 重点代码：
```cpp
// 主函数中计算相关部分
int main(){
    int T;read(T);
    while(T--){
        read(n,m);
        int dep=__lg(n);
        for(int i=0;i<=dep;i++){
            cnt[i]=1<<i;
            sum[i]=(((3ll<<i)-1)<<i)>>1;
        }
        if((1<<dep)<n){
            cnt[dep+1]=(n-(1<<dep))<<1;
            ll k=n-(1<<dep)-1,res=0;
            for(int i=dep-1;i>=0;i--){
                ll tmp=(k&~((2ll<<i)-1))+(2ll<<i);
                res+=((tmp>>1)-min(tmp-k-1,1ll<<i))<<(dep-i-1);
            }
            sum[dep+1]=(k+1)*((1ll<<(dep+2))+1)+(res<<2);
            dep++;
        }
        ll ans=-1;
        for(int i=0;i<=dep;i++){
            if(i>0){
                sum[i]+=sum[i-1];
                cnt[i]+=cnt[i-1];
            }
            if(cnt[i]<=2*n-1-m)ckmax(ans,sum[i]/(i+1));
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```
核心实现思想：先预处理每层节点数和编号和，根据\(n\)的情况调整最后一层的计算，最后枚举层数判断是否满足剪枝条件并求最大美丽值。
  - 作者：zct_sky (赞：9)  星级：4星
    - 关键亮点：根据树的结构特点，分\(m = 0\)与\(m \neq 0\)两种情况讨论。对于\(m \neq 0\)，按规则减去节点计算美丽值；对于\(m = 0\)，用分治计算最后一层节点之和，通过观察节点和规律优化计算，预计时间复杂度\(\mathcal{O}(T\log n)\)。
    - 个人心得：赛时没取最大值只得了80分。
    - 重点代码：
```cpp
// 分治计算最后一层节点和函数
ll f(ll a,ll b){
    //特判小数据时情况 
    if(b<=1||a==1)return 0;
    if(a==2)return 1;
    //特判满时的情况 
    if(a==b)return (a-1)*a/2;
    //判断是 全偶+奇 还是 只有偶 
    if(b>a/2)return 2*f(a/2,a/2)/*全偶数：上一层总和*2 */+2*f(a/2,b-a/2)+b-a/2/*奇数：在偶数基础上+奇数个数个1*/;
    
    return 2*f(a/2,b)/*偶数*/;
}
```
核心实现思想：通过分治，根据不同条件递归计算最后一层节点和，利用特判减少计算量。

最优的关键思路或技巧：利用树的特殊结构（除最后一层为满二叉树），结合记忆化搜索、分治等方法优化计算节点编号和与节点数的过程，从而高效求解最大美丽值。

可拓展之处：同类型题可涉及其他特殊结构树的相关计算，类似算法套路如利用树的层次结构特点，通过递推、递归方式计算节点属性，以及使用记忆化优化重复计算。

推荐题目：
  - [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)，考察树结构与最近公共祖先算法。
  - [P1111 修复公路](https://www.luogu.com.cn/problem/P1111)，结合图论与树的知识解决实际问题。
  - [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)，关于二叉树的动态规划问题，与本题对树结构的分析利用有相似之处。

个人心得摘录与总结：
  - 离散小波变换°：提到出题人卡常数，说明在优化代码时需注意常数对性能的影响。
  - qczrz6v4nhp6u：考场上代码未调通，反映出在竞赛中调试代码的重要性与难度，同时添加计算说明，强调了解题思路清晰阐述的必要性。
  - zct_sky：赛时因未取最大值丢分，提醒在解题时要全面考虑各种情况，避免遗漏关键步骤。 

---
处理用时：51.18秒
# 题目信息

# 「KDOI-06-J」贡献系统

## 题目描述

洛谷贡献系统上线了！

现在有 $n$ 个人即将参加一场洛谷月赛，每个人的等级分**互不相同**。第 $i$ 个人的等级分是 $r_i$，贡献值是 $c_i$。

假设第 $i$ 个人的等级分在这 $n$ 个人中的排名是 $a_i$（排名按等级分从大到小排序），且在月赛中的排名是 $b_i$，没有两个人的排名相同。也就是说，$a$ 和 $b$ 都是 $1$ 到 $n$ 的排列。比赛结束后，每个人都会执行以下操作：

+ 若 $a_i=b_i$，则第 $i$ 个人的等级分不会发生任何变化，因此第 $i$ 个人不会进行任何操作；
+ 若 $a_i>b_i$，则第 $i$ 个人的等级分会上升，因此第 $i$ 个人会给出题人点赞，导致出题人的贡献值上升 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值下降）；
+ 若 $a_i<b_i$，则第 $i$ 个人的等级分会下降，因此第 $i$ 个人会给出题人点踩，导致出题人的贡献值下降 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值上升）。

作为这场月赛唯一的出题人，初始时你的贡献值为 $0$。你想知道，对于所有可能的排列 $b$（显然，排列 $a$ 在比赛前已经被确定），在比赛结束后你的贡献值最大是多少。

## 说明/提示

**【样例解释 #1】**

对于第一组测试数据，设五个人按输入顺序分别为 A，B，C，D，E，则当月赛中的排名顺序为 ABECD 时贡献值最大，为 $0+0-(-50)-(-22)+208=280$。可以证明，这是唯一能使贡献值达到最大的排名顺序。

对于第二组测试数据，设八个人按输入顺序分别为 A，B，C，D，E，F，G，H，则当月赛中的排名顺序为 ABCDEGFH 时可以使贡献值达到最大值 $1$，注意此时有多种可能的使贡献值最大的排名顺序。

**【样例 #2】**

见选手目录下的 `contrib/contrib2.in` 与 `contrib/contrib2.ans`。

**【样例 #3】**

见选手目录下的 `contrib/contrib3.in` 与 `contrib/contrib3.ans`。



***

**【数据范围】**

对于所有数据保证：$1\le T\le 5$，$1\le n\le 2\times 10^5$，$0\le r_i\le 10^9$，$-10^9\le c_i\le 10^9$，且对于任意 $1\le i<n$，$r_i>r_{i+1}$。

| 测试点编号  |    $n\le $     | 特殊限制 |
| :---------: | :------------: | :------: |
|  $1\sim3$   |      $8$       |    无    |
|     $4$     |     $100$      |   ABC    |
|     $5$     |     $100$      |    C     |
|  $6\sim 7$  |     $100$      |    无    |
|  $8\sim 9$  | $5\times 10^3$ |    AB    |
| $10\sim 11$ | $5\times 10^3$ |    C     |
| $12\sim 14$ | $5\times 10^3$ |    无    |
|    $15$     | $2\times10^5$  |    AB    |
| $16\sim 18$ | $2\times10^5$  |    B     |
| $19\sim 21$ | $2\times10^5$  |    C     |
| $22\sim 25$ | $2\times 10^5$ |    无    |

+ 特殊性质 A：对于任意 $1\le i<n$，保证 $c_i=c_{i+1}$；
+ 特殊性质 B：对于任意 $1\le i<n$，保证 $c_i\le c_{i+1}$；
+ 特殊性质 C：对于任意 $1\le i\le n$，保证 $c_i\ge 0$。

## 样例 #1

### 输入

```
3
5
3816 3738 3726 3621 3582
111 109 -50 -22 208
8
8 7 6 5 4 3 2 1
128 1 0 0 0 0 1 0
10
10 9 8 7 6 5 4 3 2 1
1 1 4 5 1 4 1 9 1 9
```

### 输出

```
280
1
34
```

# AI分析结果

• 综合分析与结论：
    - 思路：多数题解将原数列按贡献值正负分成三段，分别处理。对于全正数段和全负数段，通过枚举断点移动元素位置来使贡献最大化；对于正负混杂段，将正数放前负数放后，使该段贡献为所有元素绝对值之和。部分题解还讨论了特殊性质下的解法。
    - 算法要点：利用前缀和优化计算，通过贪心策略确定元素移动方式以获取最大贡献值。
    - 解决难点：如何在多种排名变化可能性中找到使贡献值最大的排列方式，通过合理分段和贪心策略解决。

    - 整体来看，各题解思路相近，主要差异在于代码实现细节和对思路的阐述清晰度。

• 所选的题解：
  - 作者：zjpwdyf (赞：35)  星级：5星
    - 关键亮点：思路阐述清晰，先讨论特殊情况（$c_i$ 全正、全负），再给出一般情况的正解，将数列分成三段分别处理，并利用前缀和优化，代码简洁明了。
    - 重点代码及核心实现思想：
```cpp
#include<bits/stdc++.h>
#define gsum(l,r) (sum[r]-sum[l-1])
using namespace std;
typedef long long ll;
const int N=2e5+5;
ll T,n,c[N],tmp,lft,rgt,sum[N],ans1,ans2;
int main(){
    cin>>T;
    while(T--){
        ans1=ans2=0;
        cin>>n;
        for(int i=1;i<=n;i++) scanf("%lld",&tmp);
        for(int i=1;i<=n;i++){
            scanf("%lld",c+i);
            sum[i]=sum[i-1]+abs(c[i]);
        }
        for(lft=1;c[lft]>0&&lft<=n;lft++);
        for(rgt=n;c[rgt]<0&&rgt>=1;rgt--);
        for(int i=1;i<lft;i++) ans1=max(ans1,-c[i]+gsum(i+1,lft-1));
        for(int i=n;i>rgt;i--) ans2=max(ans2,c[i]+gsum(rgt+1,i-1));
        cout<<ans1+ans2+gsum(lft,rgt)<<'\n';
    }
    return 0;
}
```
核心实现思想是先读入数据并计算绝对值前缀和，然后找到正数段和负数段的边界，通过枚举断点计算两段的最大贡献值，再加上中间段的绝对值和得到最终答案。

  - 作者：引领天下 (赞：17)  星级：4星
    - 关键亮点：思路表述清晰，从贪心角度出发，考虑让正贡献的人上分，负贡献的人下分，通过具体分析不同段的处理方式得出解法，代码逻辑连贯。
    - 重点代码及核心实现思想：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,t,x,a[200005];
signed main(){
    ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=1;i<=n;i++)cin>>x;
        for(int i=1;i<=n;i++)cin>>a[i];
        int l=1,r=n;
        while(l<=n&&a[l]>0)l++;
        while(r>=1&&a[r]<=0)r--;
        int sum=0,mx=0,ans=0;
        for(int i=1;i<l;i++)sum+=a[i];
        for(int i=1;i<l;i++)sum-=a[i],mx=max(mx,sum-a[i]);
        ans+=mx;
        sum=0,mx=0;
        for(int i=n;i>r;i--)sum-=a[i];
        for(int i=n;i>r;i--)sum+=a[i],mx=max(mx,sum+a[i]);
        ans+=mx;
        for(int i=l;i<=r;i++)ans+=abs(a[i]);
        cout<<ans<<"\n";
    }
    return 0;
}
```
核心实现思想为先确定正负段边界，然后分别处理正段和负段，通过枚举断点计算两段的最大贡献值，最后加上中间段绝对值和得到答案。

  - 作者：lzy20091001 (赞：7)  星级：4星
    - 关键亮点：先分析特殊性质下的解法，再推导一般情况，对一般情况的构造和证明详细，思路严谨，代码注释清晰。
    - 重点代码及核心实现思想：
```cpp
#include <cmath>
#include <iostream>

int c[200005];
long long s[200005]; // 前缀和

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int t;
    std::cin >> t;
    while (t--)
    {
        int n, x, y;
        long long ans1 = 0, ans2 = 0, ans3 = 0;

        s[1] = 0; // 前缀和注意初始化

        std::cin >> n;
        for (int i = 1; i <= n; i++)
        {
            int r;
            std::cin >> r;
        }
        for (int i = 1; i <= n; i++)
        {
            std::cin >> c[i];
            s[i] = s[i - 1] + c[i];
        }

        x = n + 1, y = 0;            // 初始化，防止找不到
        for (int i = 1; i <= n; i++) // 寻找 x
            if (c[i] <= 0)
            {
                x = i;
                break;
            }
        for (int i = n; i >= 1; i--) // 寻找 y
            if (c[i] >= 0)
            {
                y = i;
                break;
            }

        // 计算答案
        for (int i = 1; i < x - 1; i++)
            ans1 = std::max(ans1, s[x - 1] - s[i] - c[i]);
        for (int i = n; i > y + 1; i--)
            ans3 = std::max(ans3, 0 - (s[i - 1] - s[y]) + c[i]);
        for (int i = x; i <= y; i++)
            ans2 += abs(c[i]);

        std::cout << ans1 + ans2 + ans3 << "\n";
    }

    return 0;
}
```
核心实现思想是先读入数据并计算前缀和，找到正负段边界，分别计算三段的贡献值，最后累加得到最终答案。

• 最优的关键思路或技巧：
    - **思维方式**：通过合理分段，将复杂问题简单化，分别考虑不同段的最优排列方式。
    - **算法优化**：利用前缀和优化计算，减少时间复杂度。

• 可拓展之处：
同类型题可考虑拓展到更多条件限制下的排名调整与贡献计算问题，类似算法套路是遇到复杂排列与贡献关系问题，尝试通过合理分类和贪心策略解决。

• 推荐题目：
    - [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：通过贪心策略解决与顺序相关的乘积最大化问题。
    - [P1199 三国游戏](https://www.luogu.com.cn/problem/P1199)：涉及贪心和博弈策略，与本题类似需考虑多种情况找到最优解。
    - [P2048 游戏](https://www.luogu.com.cn/problem/P2048)：通过模拟和贪心思想解决数字合并与得分最大化问题。

• 个人心得：无。 

---
处理用时：71.97秒
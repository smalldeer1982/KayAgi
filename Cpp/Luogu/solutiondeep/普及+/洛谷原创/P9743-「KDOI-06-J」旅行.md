# 题目信息

# 「KDOI-06-J」旅行

## 题目描述

小 C 在 C 国旅行。

C 国有 $n\times m$ 个城市，可以看做 $n\times m$ 的网格。定义 $(i,j)$ 表示在网格中第 $i$ 行第 $j$ 列的城市。

该国有 $2$ 种交通系统：

* 对于所有 $1\leq i<n,1\leq j\leq m$，$(i,j)$ 到 $(i+1,j)$ 有一段由 L 公司修的单向铁路；
* 对于所有 $1\leq i\leq n,1\leq j<m$，$(i,j)$ 到 $(i,j+1)$ 有一段由 Z 公司修的单向铁路；

在每一个城市有一个售票口，$(i,j)$ 城市的售票口可以用 $a_{i,j}$ 元购买一张 L 公司的铁路票，$b_{i,j}$ 元购买一张 Z 公司的铁路票。当你拥有一个公司的一张铁路票时，你可以乘坐这个公司的任意一段铁路，并消耗掉这张铁路票。注意，一张铁路票可以且仅可以使用一次。

小 C 原来在城市 $(1,1)$。他想要在 C 国旅游，但是他不想浪费任何的钱（即，当他旅游完毕时手上不应该有多余的车票）。对于所有 $1\leq x\leq n,1\leq y\leq m$，求他花 $k$ 元钱并在城市 $(x,y)$ 结束旅行的方案数，对 $998\ 244\ 353$ 取模。

两种旅行方案不同，当且仅当小 C 经过的城市不同，或他在某一个城市购买的某家公司的铁路票数量不同。

## 说明/提示

**【样例解释 #1】**

到 $(3,1)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,1)$。

到 $(2,2)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(2,2)$。

到 $(3,2)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $2$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,2)$；乘坐 L 公司的铁路到 $(3,2)$。
* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；乘坐 L 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。
* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；乘坐 Z 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。

到 $(2,3)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $2$ 张 Z 公司的铁路票。在此之后，有 $3$ 种方案可以从 $(1,1)$ 乘坐两公司的铁路到 $(2,3)$。
* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票。在此之后，有 $2$ 种方案可以从 $(1,2)$ 乘坐两公司的铁路到 $(2,3)$。

**【样例 #2】**

见选手目录下的 `travel/travel2.in` 与 `travel/travel2.ans`。这个样例满足测试点 $7\sim 8$ 的条件限制。

**【样例 #3】**

见选手目录下的 `travel/travel3.in` 与 `travel/travel3.ans`。这个样例满足测试点 $11$ 的条件限制。

**【数据范围】**

对于所有数据保证：$1\leq n,m\leq45$，$1\leq k,a_{i,j},b_{i,j}\leq90$。

| 测试点编号 | $n,m$ | $k$ | $a_{i,j}$ | $b_{i,j}$ |
|:--:|:--:|:--:|:--:|:--:|
| $1\sim3$ | $\leq3$ | $\leq5$ | $=1$ | $=1$ |
| $4\sim6$ | $\leq10$ | $\leq10$ | $=1$ | $=40$ |
| $7\sim8$ | $\leq40$ | $\leq30$ | $=1$ | $=45$ |
| $9\sim10$ | $\leq15$ | $\leq15$ | $\leq15$ | $\leq15$ |
| $11$ | $\leq15$ | $\leq30$ | $\leq30$ | $\leq30$ |
| $12$ | $\leq20$ | $\leq40$ | $\leq40$ | $\leq40$ |
| $13\sim15$ | $\leq25$ | $\leq50$ | $\leq50$ | $\leq50$ |
| $16$ | $\leq30$ | $\leq60$ | $\leq60$ | $\leq60$ |
| $17$ | $\leq35$ | $\leq70$ | $\leq70$ | $\leq70$ |
| $18\sim19$ | $\leq40$ | $\leq80$ | $\leq80$ | $\leq80$ |
| $20$ | $\leq45$ | $\leq90$ | $\leq90$ | $\leq90$ |

## 样例 #1

### 输入

```
3 3 5
3 2 1
2 1 3
1 3 2
1 2 3
2 3 1
3 1 2```

### 输出

```
0 0 0
0 1 5
1 3 5```

# AI分析结果

• **综合分析与结论**：这些题解均采用动态规划算法解决问题。思路上，通过定义多维状态表示走到某点、花费金额、剩余不同公司车票数量的方案数，再根据买票和移动操作进行状态转移。算法要点在于确定合适的状态定义和转移方程，难点主要是避免状态转移时的重复计算以及解决空间复杂度过高的问题。部分题解通过滚动数组优化空间，有的还在转移计算上进行优化以减少时间复杂度，同时在取模操作上也有不同程度的优化以提高效率。

  - **作者：uid_310801 (赞：13) - 5星**
    - **关键亮点**：思路清晰，先给出朴素的转移方程，再通过类似二维前缀和的容斥优化转移过程，减少枚举次数，将时间复杂度从\(O(n^7)\)优化到\(O(n^5)\)。同时使用滚动数组优化空间，并在代码中对不可能贡献的情况进行剪枝优化。
    - **重点代码核心思想**：通过五维数组\(f\)记录状态，利用滚动数组优化第一维，在循环中根据容斥原理进行状态转移，并在转移过程中进行剪枝，最后根据最终状态得到答案。
    - **核心代码片段**：
```cpp
f[1][1][0][0][0]=1;
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(i!=1) f[i&1][j][0][0][0]=0;
        for(int c=1;c<=k;c++){
            for(int la=0;la+i<=n;la++){
                for(int lb=0;lb+j<=m;lb++){ 
                    ll res=mod;
                    if(la!=0&&c>=a[i][j]) res+=f[i&1][j][c-a[i][j]][la-1][lb];
                    if(lb!=0&&c>=b[i][j]) res+=f[i&1][j][c-b[i][j]][la][lb-1];
                    if(la!=0&&lb!=0&&c>=a[i][j]+b[i][j]) res-=f[i&1][j][c-a[i][j]-b[i][j]][la-1][lb-1];
                    if(i!=1) res+=f[(i-1)&1][j][c][la+1][lb];
                    if(j!=1) res+=f[i&1][j-1][c][la][lb+1];
                    f[i&1][j][c][la][lb]=res%mod;
                    if(c==k&&la==0&&lb==0) ans[i][j]=res%mod;
                }
            }
        }
    }
}
```
  - **作者：cqbzlzm (赞：5) - 4星**
    - **关键亮点**：状态定义清晰，详细分析了每一步的转移情况，并指出直接转移会出现算重的问题及解决方法，代码实现较为直观。
    - **重点代码核心思想**：用五维数组\(dp\)记录状态，通过滚动数组优化第一维，在五层循环中根据不同的转移情况进行状态更新，并处理算重情况，最后输出结果。
    - **核心代码片段**：
```cpp
dp[1][1][0][0][k] = 1;
for (int i = 1; i <= n; i ++) { bool I = i % 2;
    for (int j = 1; j <= m; j ++) {
        for (int l = 0; l < n; l ++) {
            for (int z = 0; z < m; z ++) {
                for (int p = 0; p <= k; p ++) {
                    if (i!= 1) dp[I][j][l][z][p] += dp[I ^ 1][j][l + 1][z][p];
                    if (j!= 1) dp[I][j][l][z][p] += dp[I][j - 1][l][z + 1][p];
                    if (l!= 0 && p + L[i][j] <= k) dp[I][j][l][z][p] += dp[I][j][l - 1][z][p + L[i][j]];
                    if (z!= 0 && p + Z[i][j] <= k) dp[I][j][l][z][p] += dp[I][j][l][z - 1][p + Z[i][j]];
                    if (l!= 0 && z!= 0 && p + L[i][j] + Z[i][j] <= k) dp[I][j][l][z][p] -= dp[I][j][l - 1][z - 1][p + L[i][j] + Z[i][j]];
                    (dp[I][j][l][z][p] += mod) %= mod;
                }
            }
        }
    }
    for (int j = 1; j <= m; j ++)
        printf("%lld ", dp[I][j][0][0][0]);
    printf("\n");
    memset(dp[I ^ 1], 0, sizeof(dp[I ^ 1]));
}
```
  - **作者：_O_v_O_ (赞：3) - 4星**
    - **关键亮点**：先给出朴素的转移方程，分析其复杂度后，通过将转移过程转化为求二维前缀和的形式简化转移方程，有效降低时间复杂度，同时利用滚动数组优化空间。
    - **重点代码核心思想**：利用五维数组\(dp\)记录状态，通过滚动数组优化第一维，在循环中根据简化后的转移方程进行状态转移，最后得到答案。
    - **核心代码片段**：
```cpp
dp[1][1][0][0][0]=1;
for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
    if(i!=1) dp[i&1][j][0][0][0]=0;
    for(int c=1;c<=k;c++){
        for(int x=0;i+x<=n;x++) for(int y=0;j+y<=m;y++){
            int res=mod;
            if(x!=0&&c>=a[i][j]) res+=dp[i&1][j][c-a[i][j]][x-1][y];
            if(y!=0&&c>=b[i][j]) res+=dp[i&1][j][c-b[i][j]][x][y-1];
            if(x!=0&&y!=0&&c>=a[i][j]+b[i][j]) res-=dp[i&1][j][c-a[i][j]-b[i][j]][x-1][y-1];
            if(i!=1) res+=dp[(i-1)&1][j][c][x+1][y];
            if(j!=1) res+=dp[i&1][j-1][c][x][y+1];
            dp[i&1][j][c][x][y]=res%mod;
            if(c==k&&x==0&&y==0) ans[i][j]=res%mod;
        }
    }
}
```

• **最优关键思路或技巧**：
  - **状态转移优化**：通过类似二维前缀和的容斥原理简化状态转移方程，减少枚举次数，降低时间复杂度。
  - **空间优化**：利用滚动数组，由于每次转移只涉及当前行和上一行的状态，将第一维滚动掉，有效降低空间复杂度。
  - **剪枝优化**：在循环枚举时，根据剩余步数限制购买车票的数量，减少无效状态的计算。

• **同类型题或类似算法套路**：此类题目属于网格上的动态规划问题，通常涉及在网格中移动并进行资源管理（如本题中的金钱和车票）。类似套路包括合理定义状态，考虑所有可能的转移情况并避免重复计算，以及根据数据范围进行空间和时间复杂度的优化，如使用滚动数组、剪枝等技巧。

• **洛谷相似题目推荐**：
  - [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)：网格上的动态规划，涉及路径规划与最优值求解。
  - [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)：状态压缩动态规划，在网格上放置元素并满足一定限制条件。
  - [P3216 [HNOI2011] 数学作业](https://www.luogu.com.cn/problem/P3216)：通过合理定义状态和转移方程解决网格路径与数值计算结合的问题。

• **个人心得摘录与总结**：
  - **紊莫**：在实现动态规划时，直接写出的转移代码可能会出现算重的问题，需要仔细分析题目条件。同时，在不进行本质优化的前提下，可以通过优化取模操作、合理使用数据类型、避免不必要的内存初始化（如不用`memset`）等方式进行常数优化，提高算法效率。 

---
处理用时：79.38秒
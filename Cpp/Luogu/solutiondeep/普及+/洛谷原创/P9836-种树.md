# 题目信息

# 种树

## 题目背景

小 Rf 不是很喜欢种花，但是他喜欢种树。

## 题目描述

路边有 $n$ 棵树，每棵树的 **高度** 均为正整数，记作 $p_1, p_2 \dots p_n$。

定义一棵树的 **宽度** 为它高度的正因数个数，这些树能覆盖的距离为它们宽度的乘积，你想请你的朋友们来乘凉，但你发现这些树能覆盖的距离不够多。

于是你买了总量为 $w$ 单位的神奇化肥。你可以施若干次肥，每次你可以使用 $k$ 单位化肥（**要求 $k$ 必须为当前化肥量的正因数**），让任意一棵树的高度乘上 $k$，同时你剩余的化肥量也会除以 $k$。每次施肥的树可任意选择，且每次施肥选择的树不需相同。

你需要最大化这些树所能覆盖的距离，并输出这个最大距离。答案对 $998244353$ 取模。

## 说明/提示

**【样例 1 解释】**

+ 第一次施肥，向第一棵树施 $15$ 单位的肥，使其高度变成 $120$，剩余 $4$ 单位的化肥。
+ 第二次施肥，向第二棵树施 $4$ 单位的肥，使其高度变成 $972$，剩余 $1$ 单位的化肥。
+ 这时候，三棵树的宽度分别为 $16, 18, 8$，所能覆盖的距离为 $2304$，为最优解。

---

**【样例 2】**

见附件下的 $\texttt{plant/plant2.in}$ 与 $\texttt{plant/plant2.ans}$。

---

**【样例 3】**

见附件下的 $\texttt{plant/plant3.in}$ 与 $\texttt{plant/plant3.ans}$。

---

**【数据范围】**

| 测试点编号 | $n \leq$ | $p_i$ | $w$ | 单点分值 |
| :--------: | :------: | :---: | :---: | :------: |
| $1 \sim 5$ | $10^4$ | $=1$ | $=1$ | $1$ |
| $6 \sim 10$ | $10^4$ | $\leq 10^4$ | $=1$ | $3$ |
| $11 \sim 15$ | $1$ | $\leq 10^4$ | $\leq 10^4$ | $3$ |
| $16 \sim 20$ | $5$ | $\leq 10^4$ | $\leq 10^4$ | $6$ |
| $21 \sim 25$ | $10^4$ | $\leq 10^4$ | $\leq 10^4$ | $7$ |

对于 $100 \%$ 的数据，保证 $1 \leq n \leq 10^4$，$1 \leq p_i \leq 10^4$，$1 \leq w \leq 10^4$。

## 样例 #1

### 输入

```
3 60
8 243 250```

### 输出

```
2304```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均基于数论中质因数分解的知识。先将树的初始高度和肥料总量进行质因数分解，由于每个质因子对答案的贡献相互独立，所以对于肥料的每个质因子，贪心选择当前树中该质因子指数最小的树进行施肥，这样能使最终所有树宽度乘积最大。

各题解在算法要点和难点解决上大同小异，主要差异体现在代码实现细节，如数据结构的选择（优先队列、桶排序等）以及质因数分解和答案计算的具体方式。

### 所选的题解
- **作者：樱雪喵 (赞：45) - 5星**
    - **关键亮点**：思路清晰，先将原问题转化为经典贪心问题，证明每次贪心操作最小值是最优的，代码简洁明了。
    - **重点代码**：
```cpp
#define int long long
const int N=1e4+5,mod=998244353;
int n,w;
int a[N],cnt[N],ans=1;
priority_queue<int,vector<int>,greater<int> >q;
il void solve(int x,int sum)
{
    for(int i=1;i<=n;i++)
    {
        cnt[i]=1;
        while(a[i]%x==0) cnt[i]++,a[i]/=x;
        q.push(cnt[i]);
    }
    while(sum) 
    {
        int x=q.top(); q.pop();
        q.push(x+1),sum--;
    }
    for(int i=1;i<=n;i++) ans=ans*q.top()%mod,q.pop();
}
signed main()
{
    n=read(),w=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=2;i*i<=w;i++) 
        if(w%i==0)
        {
            int now=0;
            while(w%i==0) now++,w/=i;
            solve(i,now);
        }
    if(w>1) solve(w,1);
    for(int i=1;i<=n;i++)
    {
        for(int j=2;j*j<=a[i];j++)
        {
            int now=1;
            while(a[i]%j==0) a[i]/=j,now++;
            ans=ans*now%mod;
        }
        if(a[i]>1) ans=ans*2%mod;
    }
    printf("%lld\n",ans);
    return 0;
}
```
    - **核心实现思想**：`solve`函数针对每个质因子，统计每棵树中该质因子的个数并存入优先队列，通过优先队列贪心选择最小个数进行增加，最后计算该质因子对答案的贡献。主函数中先对`w`质因数分解，调用`solve`函数处理每个质因子，最后计算剩余未处理的树的宽度乘积得到答案。
- **作者：佬头 (赞：17) - 4星**
    - **关键亮点**：对问题的转化和贪心策略阐述详细，代码实现使用优先队列维护每个质因子在各树中的指数，时间复杂度分析清晰。
    - **重点代码**：
```cpp
#include <iostream>
#include <queue>
using namespace std;
const int N = 10004, mod = 998244353;
int n, w, ans = 1;
priority_queue <int, vector <int>, greater <int>> k[N];
int read(){
    int x = 0;
    char a = getchar();
    while(a < '0' || '9' < a) a = getchar();
    while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
    return x;
}
void write(int x){
    if(x > 9) write(x / 10);
    putchar(x % 10 | 48);
}
int main(){
    n = read(), w = read();
    for(int i = 1, p, cnt; i <= n; ++ i){
        p = read();
        if(p & 1 ^ 1){ //p%2==0
            for(cnt = 0; p & 1 ^ 1; p >>= 1, ++ cnt);
            k[2].push(cnt);
        }
        for(int j = 3; j * j <= p; j += 2)
            if(p % j == 0){
                for(cnt = 0; p % j == 0; p /= j, ++ cnt);
                k[j].push(cnt);
            }
        if(p > 1) k[p].push(1);
    }
    while(w & 1 ^ 1){
        w >>= 1;
        if(k[2].size() < n) k[2].push(1);
        else k[2].push(k[2].top() + 1), k[2].pop();
    }
    for(int i = 3; i * i <= w; i += 2)
        while(w % i == 0){
            w /= i;
            if(k[i].size() < n) k[i].push(1);
            else k[i].push(k[i].top() + 1), k[i].pop();
        }
    if(w > 1){
        if(k[w].size() < n) k[w].push(1);
        else k[w].push(k[w].top() + 1), k[w].pop();
    }
    while(!k[2].empty()) ans = (long long)ans * (k[2].top() + 1) % mod, k[2].pop();
    for(int i = 3; i < N; i += 2) while(!k[i].empty()) ans = (long long)ans * (k[i].top() + 1) % mod, k[i].pop();
    write(ans);
    return 0;
}
```
    - **核心实现思想**：先对每棵树进行质因数分解，将每个质因子的指数存入对应的优先队列`k`。然后对`w`质因数分解，针对每个质因子，从对应的优先队列中取出最小指数并加1，再放回队列。最后遍历所有优先队列，计算所有树宽度乘积得到答案。
- **作者：EmptyAlien (赞：9) - 4星**
    - **关键亮点**：解题思路从数论基础知识出发，逐步推导得出贪心策略，代码实现简洁易懂。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 5;
const int MOD = 998244353;
int n, w;
int p[MAXN];

int calc(int x, int p) {
    int cnt = 0;
    while (x % p == 0)
        x /= p, cnt++;
    return cnt;
}

long long t(long long n) {
    long long res = 1;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            int cnt = 1;
            while (n % i == 0) {
                n /= i;
                cnt++;
            }
            res = res * cnt % MOD;
        }
    }
    if (n > 1)
        res = res * 2 % MOD;
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> w;
    for (int i = 1; i <= n; i++)
        cin >> p[i];

    for (int x = 2; x * x <= w; x++) {
        while (w % x == 0) {
            int mn = INF, mnx;
            for (int i = 1; i <= n; i++) {
                if (calc(p[i], x) < mn) {
                    mn = calc(p[i], x);
                    mnx = i;
                }
            }
            p[mnx] *= x;
            w /= x;
        }
    }

    if (w!= 1) {
        int mn = INF, mnx;
        for (int i = 1; i <= n; i++) {
            if (calc(p[i], w) < mn) {
                mn = calc(p[i], w);
                mnx = i;
            }
        }
        p[mnx] *= w;
        w /= w;
    }

    long long res = 1;
    for (int i = 1; i <= n; i++) {
        res = res * t(p[i]) % MOD;
    }
    cout << res << endl;

    return 0;
}
```
    - **核心实现思想**：`calc`函数计算数`x`中质因子`p`的个数，`t`函数计算数`n`的正因子个数。主函数先对`w`质因数分解，每次找到树中该质因子个数最少的树进行施肥，最后计算所有树的宽度乘积得到答案。

### 最优关键思路或技巧
1. **质因数分解与贡献独立分析**：将树的高度和肥料总量进行质因数分解，利用每个质因子对答案贡献独立的特性，分别处理每个质因子的分配。
2. **贪心策略**：对于肥料的每个质因子，选择当前树中该质因子指数最小的树进行施肥，保证每次施肥对答案的贡献最大。
3. **优先队列优化**：使用优先队列维护每棵树中每个质因子的指数，高效获取和更新最小值，优化时间复杂度。

### 可拓展之处
此类题目属于数论与贪心结合的问题，类似套路是先通过数论知识（如质因数分解、约数个数公式等）将原问题转化，再利用贪心策略解决。同类型题通常围绕数的因数、倍数、质因数等性质展开，结合一些操作（如分配、选择等），求最值或满足特定条件的方案。

### 相似知识点洛谷题目
1. **P1072 [NOIP2009 普及组]  Hankson 的趣味题**：通过数论知识，利用最大公约数和最小公倍数的性质解决方程求解问题。
2. **P2568 GCD**：结合数论知识，利用前缀和优化，统计满足最大公约数条件的数对数量。
3. **P3327 [SDOI2015]约数个数和**：需要掌握数论中约数个数和的相关知识，通过莫比乌斯反演等技巧解决问题。 

---
处理用时：94.11秒
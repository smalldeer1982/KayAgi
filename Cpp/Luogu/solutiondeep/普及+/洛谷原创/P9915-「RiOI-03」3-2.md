# 题目信息

# 「RiOI-03」3-2

## 题目背景

> Heart beat to death[.](https://www.luogu.com.cn/problem/P9304)

## 题目描述

给定一个正整数 $n$。将 $[0,2^n)$ 中每个整数的二进制最低 $n$ 位**从低到高**依次写在一个 $2^n\times n$ 的矩阵上。**矩阵两维的下标都从 $0$ 开始。** 如，当 $n=3$ 时，矩阵是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/5f6v9pru.png?x-oss-process=image/resize,m_lfit,h_200,w_265)

给定 $q$ 次询问，每次询问这个矩阵下标为 $(x,y)$ 的格子所在的四连通块大小对 $998244353$ 取模的值。


## 说明/提示

#### 【样例 #1 解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/4mglp4cn.png?x-oss-process=image/resize,m_lfit,h_200)

图为 $n=2$ 时的矩阵，其中同一个颜色的为一个四连通块。

***

#### 【数据范围】

**本题开启捆绑测试。**

| $\text{SubTask}$ | 分值 | $n\le$ | $q\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $0$ | $5$ | $15$ | $15$ |
| $1$ | $20$ | $15$ | $5\times 10^5$ |
| $2$ | $25$ | $5\times 10^3$ | $5\times 10^3$ |
| $3$ | $50$ | $10^{18}$ | $5\times 10^5$ |

对于 $100\%$ 的数据，$0\le y\lt n\le 10^{18}$，$0\le x\lt \min(2^n, 10^{18})$，$1\le q\le 5\times 10^5$。

**请选用较快的输入输出方式。**

## 样例 #1

### 输入

```
2 2
1 1
2 0```

### 输出

```
3
1```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是通过观察矩阵规律，找到四连通块大小与坐标的关系。算法要点在于利用位运算、快速幂等操作，结合矩阵性质快速计算答案。难点在于如何优化暴力查找过程，以满足大数据范围的要求。多数题解通过利用 \(x \leq 10^{18}\) 这一条件，当 \(y\) 大于一定值（如60、62、64等）时进行特判，将时间复杂度优化到 \(O(q \log n)\) 。

### 所选的题解
1. **作者：TernaryTree (5星)**
    - **关键亮点**：思路清晰，先通过观察矩阵得出每列元素规律以及连通块可拆分为若干个 \(2^j\) 之和的结论，再利用等比数列求和公式计算连通块大小。代码实现简洁明了，对边界条件处理得当。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 998244353;
int power(int base, int freq, int mod) {
    int ans = 1, tmp = base;
    while (freq > 0) {
        if (freq % 2 == 1) ans = ans * tmp % mod;
        freq /= 2;
        tmp = tmp * tmp % mod;
    }
    return ans;
}
int n, q, x, y;
int find(int x, int y) {
    if (y > 62) return n;
    x >>= y;
    if (!x) return n;
    int d = x & 1;
    do x >>= 1, ++y;
    while ((x & 1) == d);
    return y;
}
signed main() {
    cin >> n >> q;
    while (q--) {
        cin >> x >> y;
        cout << (power(2, find(x, y), mod) - 1 + mod) % mod << endl;
    }
    return 0;
}
```
    - **核心思想**：`find` 函数用于找到当前位置右侧与当前值相同的最长连续段的终点列数，利用位运算不断右移 `x` 并判断当前位是否与起始位相同，若不同则返回当前列数。`power` 函数通过快速幂计算 \(2\) 的幂次方。主函数中通过调用这两个函数计算并输出连通块大小。
2. **作者：喵仔牛奶 (4星)**
    - **关键亮点**：将矩阵逆时针旋转 \(90^{\circ}\) 后类比为线段树，形象地描述了连通块的结构，易于理解。代码实现简洁，对超出 \(x\) 最高位的情况处理巧妙。
    - **个人心得**：吐槽题目难度评级，认为在机房15分钟左右就切了，相比之下2A题花费时间更多。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb push_back
using namespace std;
namespace Milkcat {
    typedef long long LL;
    typedef pair<LL, LL> pii;
    const int N = 1e6 + 5, mod = 998244353;
    LL n, q, x, y;
    LL qpow(LL b, LL k) { LL r = 1; for (; k; b = b * b % mod, k >>= 1) if (k & 1) r = r * b % mod; return r; }
    int main() {
        cin >> n >> q;
        REP(test, 1, q) {
            cin >> x >> y;
            if (__lg(x) < y) {
                cout << (qpow(2, n) - 1 + mod) % mod << '\n';
            } else {
                int p = x >> y & 1;
                while ((x >> y & 1) == p) y ++;
                cout << (qpow(2, y) - 1 + mod) % mod << '\n';
            }
        }
        return 0;
    }
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int T = 1;
    while (T --) Milkcat::main();
    return 0;
}
```
    - **核心思想**：`qpow` 函数通过快速幂计算 \(2\) 的幂次方。主函数中先判断 \(y\) 是否超出 \(x\) 的最高位（通过 `__lg(x) < y` 判断），若超出则直接输出 \(2^n - 1\) ；否则通过位运算找到与当前位置值不同的下一位，计算并输出连通块大小。
3. **作者：Expert_Dream (4星)**
    - **关键亮点**：从简单情况入手，先分析第 \(1\) 列的连通块规律，再逐步推导其他列情况，思路具有引导性。对时间复杂度的优化阐述清晰，指出由于 \(n \leq 10^{18}\) ，\(\log(n)\) 最多为 \(64\) ，从而对 \(y\) 大于 \(64\) 的情况进行特判。
    - **个人心得**：感谢他人在求助贴中告知需要特判。
    - **核心代码**：无（未贴出完整核心代码，仅给出链接）
    - **核心思想**：从第 \(1\) 列出发，得出 \(1\) 到 \(y\) 列连通块数量是 \(2^y - 1\) 。对于其他列，通过循环判断当前位置与下一个位置的值是否相同，若相同则增加 \(2^{y - 1}\) 个连通块，不断更新连通块数量。当 \(y\) 大于 \(64\) 时特判处理。

### 最优关键思路或技巧
1. **利用矩阵规律**：通过观察矩阵，发现每列元素的分布规律（如每一列都是 \(2^j\) 个 \(0\)、\(1\) 交替出现）以及连通块的形状特点（类似三角形，可拆分为若干个 \(2^j\) 之和），从而找到计算连通块大小的方法。
2. **位运算优化**：利用位运算（如右移、按位与）快速获取二进制位的值，从而判断当前位置与相邻位置的值是否相同，减少计算量。
3. **数据范围优化**：根据 \(x \leq 10^{18}\) 这一条件，当 \(y\) 大于一定值（如60 - 64）时，直接进行特判，避免不必要的计算，将时间复杂度从 \(O(n)\) 优化到 \(O(\log n)\) 。

### 可拓展之处
此类题目属于找规律结合位运算的题型，类似套路可应用于其他涉及二进制矩阵、图形连通性等问题。例如，对于一些需要处理大规模二进制数据的题目，可通过观察数据规律，利用位运算和适当的优化技巧来解决。

### 相似知识点洛谷题目
1. **P1010 幂次方**：通过观察数字与二进制的关系，利用位运算将整数表示为幂次方的形式，与本题利用二进制性质解题思路相似。
2. **P1876 开灯**：涉及位运算和逻辑推理，通过对开关状态的二进制表示进行操作，解决实际问题，与本题在运用位运算处理数据方面有共通之处。
3. **P3390 【模板】矩阵快速幂**：虽然重点在矩阵快速幂，但同样需要对幂运算有深刻理解，并且在处理大规模数据时需要考虑优化，与本题优化思路类似。 

---
处理用时：72.84秒
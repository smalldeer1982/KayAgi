# 题目信息

# [NOIP 2002 普及组] 过河卒

## 题目描述

棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)

现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。

**【题目来源】**

NOIP 2002 普及组第四题

## 样例 #1

### 输入

```
6 6 3 3
```

### 输出

```
6
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕“过河卒”问题，核心思路多基于动态规划（DP），少数采用矩阵乘法和小学奥数组合数学方法。多数题解先标记马的控制点，再通过状态转移方程计算卒到各点路径数。不同题解在初始化、边界处理、空间优化及判断马控制点方式上有差异。

### 所选的题解
- **作者：Chiaro (赞：3922) - 5星**
    - **关键亮点**：思路清晰，从基础DP逐步优化到滚动数组，再到一维数组，还探讨了去除判断马控制点的二维数组的多种方法，对每种优化的原理和实现细节讲解详细。
    - **个人心得**：无
    - **重点代码 - 一维数组优化版**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;

// 快速读入
template <class I>
inline void read(I &num){
    num = 0; char c = getchar(), up = c;
    while(!isdigit(c)) up = c, c = getchar();
    while(isdigit(c)) num = (num << 1) + (num << 3) + (c ^ '0'), c = getchar();
    up == '-'? num = -num : 0; return;
}
template <class I>
inline void read(I &a, I &b) {read(a); read(b);}
template <class I>
inline void read(I &a, I &b, I &c) {read(a); read(b); read(c);}

const int fx[] = {0, -2, -1, 1, 2, 2, 1, -1, -2};
const int fy[] = {0, 1, 2, 2, 1, -1, -2, -2, -1};

int bx, by, mx, my;
ll f[40];   //这次只需要一维数组啦
bool s[40][40];

int main(){
    read(bx, by); read(mx, my);
    bx += 2; by += 2; mx += 2; my += 2;
    f[2] = 1;   //初始化
    s[mx][my] = 1;
    for(int i = 1; i <= 8; i++) s[mx + fx[i]][my + fy[i]] = 1;
    for(int i = 2; i <= bx; i++){
        for(int j = 2; j <= by; j++){
            if(s[i][j]){
                f[j] = 0; // 还是别忘了清零
                continue;
            }
            f[j] += f[j - 1];
            //全新的 简洁的状态转移方程
        }
    }
    printf("%lld\n", f[by]);
    return 0;
} 
```
    - **核心实现思想**：通过对状态转移方程分析，利用数组更新前保留上一轮结果的特性，将二维DP数组优化为一维。同时在遍历过程中，判断当前点是否被马拦住，若拦住则将该点路径数清零，否则按转移方程累加路径数。

- **作者：yummy (赞：252) - 4星**
    - **关键亮点**：提供矩阵乘法和小学奥数两种非传统DP的独特解法，对每种解法的原理和实现步骤有详细推导，还考虑到特殊情况的特判。
    - **个人心得**：无
    - **重点代码 - 小学奥数版**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll C(int m,int n)
{
    if(n<0 || m<0 || n<m)
        return 0;
    ll tot=1;
    for(int i=1;i<=m;i++)
    {
        tot*=n-i+1;
        tot/=i;
    }
    return tot;
}
int n,m,x,y;
int rt[5][5]={
0,0,1,0,0,
0,0,1,1,0,
0,0,0,1,1};//我们记录下哪些节点作为起点时，可以从右边的口子出去，其中(2,2)为马的位置
int dw[5][5]={
{},
{},
1,1,0,0,0,
0,1,1,0,0,
0,0,1,0,0};//同理，哪些可以从下边口子出去
int main()
{
    cin>>n>>m>>x>>y;
    if(n-x<3 && m-y<3)
    {
        x=n-x;
        y=m-y;
    }//为了不想把特判代码写两遍，如果终点离得太近就旋转180度，变成起点离得太近的情况
    if(x<3 && y<3)
    {
        int nx=2-x;
        int ny=2-y;//起点相对于马的坐标而言的位置
        ll tot=0;
        tot+=C(n-x,m+n-x-y-3)*rt[nx][ny];//右边出去的方法数
        tot+=C(n-x-3,m+n-x-y-3)*dw[nx][ny];//同理
        cout<<tot;
        return 0;
    }
    ll tot=C(n,n+m);
    for(int i=-2;i<=2;i++)
        tot-=C(x-i,x+y)*C(n-x+i,n+m-x-y);
    //情况1
    tot+=C(x+2,x+y-1)*C(n-x-3,n+m-x-y-1);//情况2
    tot+=C(x-3,x+y-1)*C(n-x+2,n+m-x-y-1);//情况3
    tot+=C(x,x+y-3)*C(n-x-3,n+m-x-y-3);//情况4
    tot+=C(x-3,x+y-3)*C(n-x,n+m-x-y-3);//情况5
    cout<<tot;
    return 0;
}
```
    - **核心实现思想**：利用组合数学公式计算从起点到终点的路径数，通过减去经过马控制的特殊格子的路径数得到最终结果。针对起点或终点离马太近的特殊情况，通过旋转棋盘简化特判。

- **作者：kradcigam (赞：458) - 4星**
    - **关键亮点**：先介绍标数法思路，清晰阐述状态转移方程的推导，再给出二维和一维数组实现代码，逻辑连贯，对优化思路有一定讲解。
    - **个人心得**：无
    - **重点代码 - 一维数组优化版**：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a,b,n,m,f[23],ma[23][23];
void work(long long x,long long y){
    ma[x][y]=1;
    ma[x-1][y-2]=1;
    ma[x-2][y-1]=1;
    ma[x-2][y+1]=1;
    ma[x-1][y+2]=1;
    ma[x+1][y-2]=1;
    ma[x+2][y-1]=1;
    ma[x+2][y+1]=1;
    ma[x+1][y+2]=1;
}
int main(){
    scanf("%lld %lld %lld %lld",&n,&m,&a,&b);
    a++;
    b++;
    n++;
    m++;
    work(a,b);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
			if(i==1&&j==1)continue;
        	if(ma[i][j]==0)f[j]+=f[j-1];
        }
    printf("%lld",f[m]);
    return 0;
}
```
    - **核心实现思想**：基于标数法，认识到每一行的结果只依赖上一行，从而将二维数组优化为一维数组。在遍历过程中，判断当前点是否被马拦住，未拦住则按转移方程累加路径数。

### 最优关键思路或技巧
- **空间优化技巧**：如Chiaro题解中，通过对状态转移方程的观察，利用滚动数组和一维数组优化空间复杂度，减少内存使用。
- **数学方法应用**：yummy题解中运用组合数学知识，通过计算组合数来求解路径数，提供了不同于DP的新颖视角。

### 可拓展思路
此类题目属于路径规划与计数问题，可拓展到其他具有特定移动规则和限制条件的网格路径问题。类似算法套路包括：
- 利用动态规划解决具有重叠子问题和最优子结构性质的路径计数问题。
- 对于小规模数据，可尝试矩阵乘法等暴力但直观的方法。
- 运用组合数学知识，通过排列组合公式计算路径数，简化计算过程。

### 相似知识点洛谷题目
- **P1216 [USACO1.5]数字三角形 Number Triangles**：同样是在特定形状的网格中，按规则移动并计算路径相关值，考察动态规划思想。
- **P1006 [NOIP2008 提高组] 传纸条**：在矩阵网格中传递纸条，求最大路径和，涉及动态规划及边界处理。
- **P1260 动态规划之数字三角形**：与数字三角形类似，通过动态规划求解从顶到底的最大路径和。 

---
处理用时：90.97秒
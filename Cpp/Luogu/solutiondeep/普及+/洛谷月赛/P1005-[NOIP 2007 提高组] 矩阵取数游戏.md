# 题目信息

# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# AI分析结果

• 综合分析与结论：这些题解均采用区间动态规划解决该问题，核心思路是利用每行取数互不影响的特性，对每行分别进行区间DP。状态表示多为$f[i][j]$，代表处理区间$[i, j]$时的最大得分，转移方程基于从区间两端取数的不同情况构建，同时考虑取数顺序与$2$的幂次关系。由于数据范围较大，需使用高精度算法或`__int128`类型处理数据。不同题解在状态定义、转移方程细节、实现方式（如高精度运算实现、循环顺序）上存在差异。
- **作者：Jack_Homes_Huang（5星）**
  - **关键亮点**：思路清晰，详细阐述状态定义、转移方程推导及终值确定，对高精度运算的使用及类型有明确说明，代码采用结构体重载运算符，可读性强。
  - **个人心得**：强调高精度运算的繁琐，尤其提到在预处理$2$的幂时将$m$误写成$n$导致调试困难。
  - **重点代码 - 核心实现思想**：通过重载运算符实现高精度加法、乘法及比较大小操作，利用`BaseTwo`函数预处理$2$的幂，在`main`函数中对每行进行区间DP，通过状态转移方程更新`f`数组，最后累加每行结果得到答案。
```cpp
HP operator + (const HP &a, const HP &b) {
    HP c; c.len = max(a.len, b.len); int x = 0;
    for (int i = 1; i <= c.len; i++) {
        c.p[i] = a.p[i] + b.p[i] + x;
        x = c.p[i] / Mod;
        c.p[i] %= Mod;
    }
    if (x > 0)
        c.p[++c.len] = x;
    return c;
} 
HP operator * (const HP &a, const int &b) {
    HP c; c.len = a.len; int x = 0;
    for (int i = 1; i <= c.len; i++) {
        c.p[i] = a.p[i] * b + x;
        x = c.p[i] / Mod;
        c.p[i] %= Mod;
    }
    while (x > 0)
        c.p[++c.len] = x % Mod, x /= Mod;
    return c;
} 
HP max(const HP &a, const HP &b) {
    if (a.len > b.len)
        return a;
    else if (a.len < b.len)
        return b;
    for (int i = a.len; i > 0; i--)
        if (a.p[i] > b.p[i])
            return a;
        else if (a.p[i] < b.p[i])
            return b;
    return a;
} 
void BaseTwo() {
    base[0].p[1] = 1, base[0].len = 1;
    for (int i = 1; i <= m + 2; i++){ 
        base[i] = base[i - 1] * 2;
    }
} 
int main(void) {
    scanf("%d%d", &n, &m);
    BaseTwo();
    while (n--) {
        memset(f, 0, sizeof f);
        for (int i = 1; i <= m; i++)
            scanf("%d", &ar[i]);
        for (int i = 1; i <= m; i++)
            for (int j = m; j >= i; j--) { 
                f[i][j] = max(f[i][j], f[i - 1][j] + base[m - j + i - 1] * ar[i - 1]); 
                f[i][j] = max(f[i][j], f[i][j + 1] + base[m - j + i - 1] * ar[j + 1]);
            } 
        HP Max;
        for (int i = 1; i <= m; i++)
            Max = max(Max, f[i][i] + base[m] * ar[i]);
        ans = ans + Max; 
    }
    ans.print(); 
    return 0;
}
```
- **作者：zhylj（4星）**
  - **关键亮点**：转移方程独特，从不同角度推导，代码简洁明了，使用`__int128`类型简化高精度运算，通过自定义输入输出函数解决`__int128`输入输出问题。
  - **重点代码 - 核心实现思想**：`solve`函数通过双重循环遍历区间长度和起始位置，依据转移方程更新`f`数组，最终返回该行最大得分，在`main`函数中累加每行得分得到答案。
```cpp
__int128 solve(__int128 a[])
{
    memset(f,0,sizeof(f));
    for(int len=0;len<=m;++len)
    	for(int i=1;i+len<=m;++i)
            f[i][i+len]=max(2*f[i+1][i+len]+2*a[i],2*f[i][i+len-1]+2*a[i+len]);
    return f[1][m];
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            input(game[i][j]);
    for(int i=1;i<=n;i++)
        ans+=solve(game[i]);
    output(ans);
    return 0;
}
```
- **作者：Tomwsc（4星）**
  - **关键亮点**：题意理解清晰，详细推导状态转移方程，指出从大区间到小区间的枚举顺序，利用快速幂预处理$2$的幂优化转移复杂度，代码注释详细。
  - **重点代码 - 核心实现思想**：`ksm`函数实现快速幂运算，预处理`poww`数组存储$2$的幂，在`main`函数中对每行进行区间DP，通过状态转移方程更新`dp`数组，最后累加每行结果得到答案。
```cpp
inline int ksm(int base, int x) {
    int result = 1;
    while(x) {
        if(x & 1)
            result *= base;
        x >>= 1;
        base *= base;
    }
    return result;
}
signed main() {
    n = read();
    m = read();
    for(register int i = 1;i <= m;i ++)
        poww[i] = ksm(2, i);
    while(n --) {
        for(register int i = 1;i <= m;i ++)
            a[i] = read();
        memset(dp, 0, sizeof(dp));
        for(register int i = 1;i <= m;i ++)
            for(register int j = m;j >= i;j --)
                dp[i][j] = max(dp[i - 1][j] + a[i - 1] * poww[m - j + i - 1], dp[i][j + 1] + a[j + 1] * poww[m - j + i - 1]);
        int maxn = -inf;
        for(register int i = 1;i <= m;i ++)
            maxn = max(maxn, dp[i][i] + a[i] * poww[m]);
        ans += maxn;
    }
    write(ans);
    return 0;
}
```
• **最优关键思路或技巧**：利用每行取数独立的特性，将二维矩阵问题转化为每行的一维区间DP问题。在状态转移方程设计上，充分考虑取数位置（行首或行尾）与取数顺序（影响$2$的幂次）。实现上，可选择高精度算法或`__int128`类型处理大数据；通过预处理$2$的幂优化转移过程。
• **可拓展思路**：此类题目属于区间DP范畴，常见套路是根据问题特性定义区间状态，依据操作规则推导转移方程，同时注意边界条件和数据范围。相似类型题常涉及在区间上进行选择、合并等操作，并根据操作顺序产生不同收益，通过动态规划求解最优收益。
• **洛谷相似题目**：
  - [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)：经典区间DP，在环形区间上合并石子求最小/最大得分。
  - [P4170 [CQOI2007] 涂色](https://www.luogu.com.cn/problem/P4170)：对区间进行涂色操作，求最少涂色次数，考察区间DP状态定义与转移。
  - [P2858 [USACO06DEC] Milk Patterns G](https://www.luogu.com.cn/problem/P2858)：通过区间DP解决字符串重复子串相关问题，与本题在利用区间特性求解最优值上思路相似。 

---
处理用时：84.59秒
# 题目信息

# [NOIP 2000 普及组] 税收与补贴问题

## 题目背景

每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）

对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）


## 题目描述

你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。

- 总利润 $=$ 单位商品利润 $\times$ 销量
- 单位商品利润 $=$ 单位商品价格 $-$ 单位商品成本（减去税金 或者 加上补贴）


## 说明/提示

### 数据范围及约定

保证输入的所有数字均小于 $10^5$。

### 样例解释（2023/6/22 更新）

如下图所示是输入样例所对应的价格变化图，横轴表示销售价格，纵轴表示销量。

![](https://cdn.luogu.com.cn/upload/image_hosting/21mhtm5i.png)

根据题意，$28$ 元是商品的成本。销售价格不应该低于 $28$ 元；当销售价格大于给出的价格的最大值 $31$ 元后，按照售价每提高一元，销量降低 $15$ 计算，例如当售价为 $33$ 元时，销量为 $110-15\times (33-31)=80$。在给出来的价位之间，销量呈线性变化。

当政府给该商品补贴 $4$ 元后，企业将该商品定价为 $31$ 元时，取得的利润为 $31-28+4=7$ 元，销量为 $110$ 件，总利润为 $7\times 110=770$ 元，是企业在所有定价下能够取得的最大的总利润。此时企业的售价为政府的期望售价，因此是一个合法方案。

## 样例 #1

### 输入

```
31
28 130
30 120
31 110
-1  -1
15```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何确定政府对商品的税收或补贴金额，使商品在政府预期价格下总利润最大。整体思路可分为暴力枚举和数学推导两类。
 - **暴力枚举**：通过遍历所有可能的税收或补贴金额，计算每种情况下各价格的总利润，判断预期价格是否为利润最大的价格。如Mitch谜团、dodo、dingcx、2011hym、LINYUHENG2、JustinRochester的题解。此方法思路直接，但可能效率较低。
 - **数学推导**：利用利润公式构建不等式或通过分析直线斜率关系来求解。如Ofnoname通过解不等式确定答案区间，majorli从直线方程角度分析并模拟寻找解。这类方法需较强数学能力，但可能优化计算过程。

各题解在处理销量计算（线性插值及最高价格后递减）、利润计算及判定预期价格利润最大等关键问题上方法相似。部分题解考虑了特殊情况，如majorli指出题目可能无解及插值点处理的不确定性。

### 所选4星及以上题解
 - **Mitch谜团（4星）**
    - **关键亮点**：思路通俗易懂，采用暴力枚举法，先完善价格 - 销量表，再从最小补贴或税收开始枚举，找到使预期价格利润最大的数值。代码简短，逻辑直接。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <iostream>
#include <cmath>
using namespace std;
int a[100010][3];//用于存放价格和销量的数组
int main()
{
    int i = 1, j = 1, k, expect, down, max, temp, cha, xl, num, s, price, p;
    cin >> expect;//读入预期价
    while (cin >> a[i][1] >> a[i][2] && a[i][1]!= -1 && a[i][2]!= -1)
    {
        i++;
        if (i > 2 && a[i - 1][1] - a[i - 2][1] > 1)
        {
            i--;
            cha = (a[i - 1][2] - a[i][2]) / (a[i][1] - a[i - 1][1]);
            temp = a[i][1];
            for (j = a[i - 1][1] + 1; j <= temp; j++)
            {
                a[i][1] = j;
                a[i][2] = a[i - 1][2] - cha;
                i++;
            }
        }
    }
    cin >> down;
    i--;
    xl = a[i][2];
    while (xl > 0)
    {
        if (xl - down < 0) break;
        else
        {
            xl -= down;
            i++;
            a[i][1] = a[i - 1][1] + 1;
            a[i][2] = xl;
        }
    }
    for (j = 1; j <= 10000; j++)
    {
        max = -99999;
        for (k = 1; k <= i; k++)
        {
            num = (a[k][1] - a[1][1] + j) * a[k][2];
            if (num >= max)
            {
                max = num;
                price = a[k][1];
                p = 1;
            }
        }
        if (price == expect) { cout << j * p; return 0; }
        max = -99999;
        for (k = 1; k <= i; k++)
        {
            num = (a[k][1] - a[1][1] - j) * a[k][2];
            if (num >= max)
            {
                max = num;
                price = a[k][1];
                p = -1;
            }
        }
        if (price == expect) { cout << j * p; return 0; }
    }
    return 0;
}
```
    - **核心思想**：先读入数据并补齐价格 - 销量表，然后分别枚举补贴和税收，计算各价格总利润，判断预期价格是否利润最大，若是则输出。
 - **majorli（4星）**
    - **关键亮点**：从数学角度深入分析问题，将总利润表示为直线方程，通过分析直线斜率关系进行模拟求解。详细讨论了线性插值、模拟点选择及是否有解等问题，考虑全面。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
    vector<int> sales;
    int target_price, tail_speed;
    cin >> target_price;
    int target_p = -1, len = 0;
    int price, sale, last_price, last_sale;
    cin >> price >> sale;
    sales.push_back(sale);
    last_price = price;
    last_sale = sale;
    if (price == target_price)
        target_p = len;
    len++;
    while ((cin >> price >> sale) && price!= -1 && sale!= -1) {
        int delta_sale = (sale - last_sale) / (price - last_price);
        for (int p = last_price + 1; p < price; p++) {
            last_sale += delta_sale;
            sales.push_back(last_sale);
            if (p == target_price)
                target_p = len;
            len++;
        }
        sales.push_back(sale);
        last_price = price;
        last_sale = sale;
        if (price == target_price)
            target_p = len;
        len++;
    }
    cin >> tail_speed;
    while (last_sale > tail_speed) {
        last_price++;
        last_sale -= tail_speed;
        sales.push_back(last_sale);
        if (last_price == target_price)
            target_p = len;
        len++;
    }
    vector<int> total;
    for (int i = 0; i < len; i++)
        total.push_back(i * sales[i]);
    int max_forward, max_backward, x = 0;
    while (true) {
        max_forward = *max_element(total.begin(), total.begin() + target_p);
        max_backward = *max_element(total.begin() + target_p + 1, total.end());
        int t = total[target_p];
        if (max_forward <= t && max_backward <= t) {
            cout << x << endl;
            break;
        }
        else if (max_forward >= t && max_backward >= t) {
            cout << "NO SOLUTION" << endl;
            break;
        }
        if (max_forward > t) {
            for (int i = 0; i < len; i++)
                total[i] -= sales[i];
            x--;
        }
        else {
            for (int i = 0; i < len; i++)
                total[i] += sales[i];
            x++;
        }
    }
    return 0;
}
```
    - **核心思想**：读入数据并补齐销量，以预期价格为界分两部分，通过比较两部分最大值与预期价格利润大小，调整税收或补贴值，直至找到解或判断无解。
 - **Ofnoname（4星）**
    - **关键亮点**：通过解不等式确定税收或补贴的取值范围，进而得出答案。对解不等式及取整问题有详细分析，逻辑清晰。
    - **个人心得**：花费较多时间理解题意和处理细节问题。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define MAX (100000+100)
using namespace std;
int x, r, m, n, p, d[MAX];
double Min = -1e9, Max = 1e9;
inline void read(int &a)
{
    register char c = getchar(); bool f = 0;
    for (a = 0; c < '0' || '9' < c; c = getchar())
        if (c == '-') f = 1;
    for (; '0' <= c && c <= '9'; c = getchar())
        a = (a << 3) + (a << 1) + (c ^ 48);
    if (f) a = -a;
}
int main()
{
    read(x); read(m); read(n); r = m;
    while (m!= -1 && n!= -1)
    {
        d[m] = n;
        for (int i = p + 1; i < m; i++)
            d[i] = d[i - 1]+(n - d[p]) / (m - p);
        p = m;
        read(m); read(n);
    }
    read(m);
    while (d[p] > m)
        p++, d[p] = d[p - 1] - m;
    for (register int i = r; i <= p; i++)
    {
        double ans = (d[x] * (x - r)-d[i] * (i - r)) * 1.0 / (d[i] - d[x]);
        double g = d[i] - d[x];
        if (g > 0) Max = min(Max, ans);
        else Min = max(Min, ans);
    }
    if (Min > 0) printf("%d", (int)ceil(Min));
    else if (Max < 0) printf("%d", (int)floor(Max));
    else puts("0");
    return 0;
}
```
    - **核心思想**：读入数据并补齐销量，对每个价格解关于税收或补贴的不等式，根据不等式符号确定取最大或最小值，最终根据取值范围确定答案。

### 最优关键思路或技巧
 - **暴力枚举优化**：如JustinRochester在枚举税收时，利用已得到的补贴解优化枚举范围，减少不必要计算。
 - **数学分析**：majorli从直线方程角度分析问题，清晰阐述模拟过程及特殊情况，为复杂问题提供严谨解决思路；Ofnoname通过解不等式确定答案范围，数学性强。

### 可拓展之处
此类题目属于经济决策优化问题，常涉及线性关系、函数最值等知识点。类似算法套路可用于资源分配、生产规划等场景，如给定不同产量下的成本和收益，确定最优产量及政府调控策略。

### 相似知识点洛谷题目
 - **P1084 [NOIP2012 提高组] 疫情控制**：涉及二分答案、贪心策略及树上问题，与本题在寻找最优解思路上有相似处。
 - **P1182 数列分段 Section II**：考查二分查找和贪心思想，通过二分确定最优分段方案，与本题确定最优税收或补贴金额思路类似。
 - **P2678 [NOIP2015 提高组] 跳石头**：同样运用二分查找确定满足条件的最优解，与本题优化求解过程有相通点。

### 个人心得摘录与总结
 - Ofnoname：理解题意花费较多时间，且在细节上易出问题。强调理解题意和关注细节对解题的重要性。 

---
处理用时：101.31秒
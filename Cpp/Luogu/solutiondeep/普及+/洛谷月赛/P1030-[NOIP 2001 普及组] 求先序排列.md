# 题目信息

# [NOIP 2001 普及组] 求先序排列

## 题目描述

给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \le 8$）。


## 说明/提示

**【题目来源】**

NOIP 2001 普及组第三题

## 样例 #1

### 输入

```
BADC
BDCA
```

### 输出

```
ABCD
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕已知二叉树的中序和后序排列求先序排列展开。多数题解思路基于后序遍历最后一个节点为根节点，利用中序遍历确定左右子树，通过递归实现。算法要点在于找到根节点、划分左右子树并递归处理。难点是准确划分中序和后序遍历中的左右子树部分。多数题解思路清晰，但在代码可读性和优化程度上有所差异。

所选的题解：
  - **作者：sunyufei (5星)**
    - **关键亮点**：思路阐述清晰，先点明后序遍历最后一个是根这一关键性质，再通过示例详细说明解题步骤，代码简洁明了，直接使用字符串操作实现递归。
    - **重点代码**：
```cpp
void beford(string in,string after){
    if (in.size()>0){
        char ch=after[after.size()-1];
        cout<<ch;
        int k=in.find(ch);
        beford(in.substr(0,k),after.substr(0,k));
        beford(in.substr(k+1),after.substr(k,in.size()-k-1));
    }
}
```
    - **核心实现思想**：函数`beford`接收中序和后序字符串，找到后序的最后一个字符作为根输出，通过`find`函数在中序中找到根的位置，将中序和后序字符串按此位置分割为左右子树部分，递归调用自身处理左右子树。

  - **作者：NeosKnight (4星)**
    - **关键亮点**：详细解释了递归思路和确定子树后序遍历序列的方法，代码采用字符数组和自定义函数实现，对边界条件有清晰判断。
    - **重点代码**：
```cpp
void dfs(int l1,int r1,int l2,int r2)
{
    int m=find(s2[r2]);
    cout<<s2[r2];
    if(m>l1) dfs(l1,m-1,l2,r2-r1+m-1);
    if(m<r1) dfs(m+1,r1,l2+m-l1,r2-1);
}
```
    - **核心实现思想**：`dfs`函数通过四个参数表示中序和后序遍历的左右边界，找到后序右边界对应的字符在中序中的位置，输出该字符，根据该位置和边界条件递归处理左右子树。

  - **作者：UNDERTALE_RS (4星)**
    - **关键亮点**：不仅给出解题代码，还详细介绍了二叉树先序、中序、后序遍历的概念和过程，帮助初学者理解。代码结构清晰，先建树再输出先序序列。
    - **重点代码**：
```cpp
int buildTree(string InOd,string PostOd){
    int len = InOd.size();
    if(len == 0) return 0;
    
    char c = PostOd[len-1];
    int root = ++pos;
    tree[root].val = c;
    
    int k = InOd.find(c); 
    
    tree[root].l = buildTree(InOd.substr(0,k),PostOd.substr(0,k));
    tree[root].r = buildTree(InOd.substr(k+1),PostOd.substr(k,len-k-1)); 
    return root;
}

void printPreOd(int root){
    cout << tree[root].val; 
    if(tree[root].l) printPreOd(tree[root].l); 
    if(tree[root].r) printPreOd(tree[root].r); 
}
```
    - **核心实现思想**：`buildTree`函数递归建树，找到后序的根，在中序中确定位置，划分左右子树递归构建。`printPreOd`函数按根左右顺序输出先序序列。

**最优关键思路或技巧**：利用后序遍历最后元素为根节点，结合中序遍历确定左右子树范围，通过递归不断分解问题，实现高效求解。

**可拓展之处**：同类型题可涉及已知其他两种遍历求第三种遍历，或在此基础上增加对二叉树节点的操作等。类似算法套路适用于与二叉树结构和遍历相关的问题。

**推荐题目**：
  - P1030 [NOIP2001 普及组] 求先序排列（本题）
  - P1827 [USACO3.4] 美国血统 American Heritage
  - P2196 [NOIP1996 提高组] 挖地雷

**个人心得摘录与总结**：无。 

---
处理用时：47.23秒
# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！



## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何通过枚举和逻辑判断来解决侦探推理问题。多数题解采用枚举罪犯和日期的方式，结合人物话语的真假判断来确定最终结果。解题的关键在于准确处理人物话语，判断其真实性，并根据说真话和说假话的人数限制来筛选出符合条件的结果。

### 所选的题解
- **作者：Drifterming (赞：89)  星级：5星**
    - **关键亮点**：思路清晰，代码结构完整，通过定义结构体和函数，将判断过程模块化，易于理解和实现。对每句话的真假判断逻辑明确，且考虑了各种可能出现的矛盾情况。
    - **个人心得**：无
    - **核心代码**：
```cpp
bool judgeTF(int id,bool flag) {
    if(TF[id]==-1) {
        TF[id]=flag;
        if(flag) ++T;
        else ++F;
    }
    else return TF[id]!=flag;
    if(F>n||T>m-n) return 1;
    return 0;
}

void judge(int id,string day) {
    memset(TF,-1,sizeof(TF));
    T=F=0;
    string tmp;
    for(int i=1;i<=p;++i) {
        int pos=sen[i].s.find("I am guilty.");
        if(~pos) {
            if(judgeTF(sen[i].id,sen[i].id==id)) return;
        }
        pos=sen[i].s.find("I am not guilty");
        if(~pos) {
            if(judgeTF(sen[i].id,sen[i].id!=id)) return;
        }
        pos=sen[i].s.find(" is guilty.");
        if(~pos) {
            tmp=sen[i].s;
            tmp.erase(pos,11);
            if(judgeTF(sen[i].id,ma[tmp]==id)) return;
        }
        pos=sen[i].s.find(" is not guilty.");
        if(~pos) {
            tmp=sen[i].s;
            tmp.erase(pos,15);
            if(judgeTF(sen[i].id,ma[tmp]!=id)) return;
        }
        pos=sen[i].s.find("Today is ");
        if(~pos) {
            if(judgeTF(sen[i].id,sen[i].s==day)) return;
        }
    }
    if(ans&&ans!=id) {
        puts("Cannot Determine");
        exit(0);
    }
    ans=id;
}
```
    - **核心思想**：`judgeTF`函数用于判断当前说话者的话与之前判断的真假状态是否冲突，并更新说真话和说假话的人数。`judge`函数通过查找不同类型的话语，调用`judgeTF`函数判断每句话的真假，若出现矛盾则返回，若成功且之前已有不同罪犯则输出“Cannot Determine”，否则记录当前罪犯。
- **作者：wjyyy (赞：18)  星级：4星**
    - **关键亮点**：利用`std::map`和`std::vector`等STL容器，简化了数据的存储和处理过程，代码简洁明了。对不确定说话真假的人进行特殊处理，通过设置波动范围来判断是否符合说假话人数的要求。
    - **个人心得**：无
    - **核心代码**：
```cpp
for(int i=1;i<=n;++i) {
    for(int j=1;j<=7;++j) {
        int flag=0,cnt=n,ran=0;
        for(int k=1;!flag&&k<=n;++k) {
            vector<sta>::iterator it=v[k].begin();
            if(!v[k].size()) {
                ++ran;
                continue;
            }
            sta tmp=*it;
            bool rea;
            if(tmp.to) rea=(tmp.u==j);
            else rea=((tmp.u==i)^(!tmp.is));
            ++it;
            for(;!flag&&it!=v[k].end();++it) {
                if(it->to) {
                    if(rea!=(it->u==j)) flag=1;
                }
                else {
                    if(rea==((it->u==i)^it->is)) flag=1;
                }
            }
            cnt-=rea;
        }
        if(!flag&&cnt>=m&&cnt-ran<=m) {
            if(ans=="") ans=nm[i];
            else if(ans!=nm[i]) {
                cout<<"Cannot Determine"<<endl;
                return 0;
            }
        }
    }
}
```
    - **核心思想**：枚举罪犯`i`和日期`j`，对于每个人，根据其话语判断真假，若出现矛盾则标记`flag`。统计说假话的人数`cnt`和不确定的人数`ran`，若满足说假话人数的范围要求，则根据是否已有答案来确定输出结果。
- **作者：Setsugesuka (赞：1)  星级：4星**
    - **关键亮点**：对人物状态和证言状态进行详细定义，使得逻辑判断更加清晰。预处理部分对证言的类型判断和信息提取较为细致，完整代码逻辑连贯，易于理解。
    - **个人心得**：无
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++) {
    for(int j=1;j<=7;j++) {
        ans1=0;
        ans2=0;
        init();
        for(int k=1;k<=p;k++) {
            if(b[k].lx==1) (b[k].whosaid==i)?a[b[k].whosaid].saidtrue=true:a[b[k].whosaid].saidfalse=true;
            else if(b[k].lx==2) (b[k].whosaid!=i)?a[b[k].whosaid].saidtrue=true:a[b[k].whosaid].saidfalse=true;
            else if(b[k].lx==3) (b[k].XXX==i)?a[b[k].whosaid].saidtrue=true:a[b[k].whosaid].saidfalse=true;
            else if(b[k].lx==4) (b[k].XXX!=i)?a[b[k].whosaid].saidtrue=true:a[b[k].whosaid].saidfalse=true;
            else if(b[k].lx==5) (b[k].date==j)?a[b[k].whosaid].saidtrue=true:a[b[k].whosaid].saidfalse=true;
            else continue;
        }
        bool ERR=false;
        for(int k=1;k<=n;k++) {
            if(a[k].saidtrue==true&&a[k].saidfalse==true) ERR=true;
            else if(a[k].saidfalse==true) ans1++;
            else if(a[k].saidfalse==false&&a[k].saidtrue==false) ans2++;
        }
        if(ERR==true) continue;
        if(ans1<=m&&ans2+ans1>=m&&ans1+ans2<=n) a[i].isg=true;
    }
}
```
    - **核心思想**：枚举罪犯`i`和日期`j`，根据证言类型判断每个人说的话是真话还是假话，标记`saidtrue`或`saidfalse`。检查是否有人既说真话又说假话，统计说假话的人数`ans1`和不确定的人数`ans2`，若满足人数范围要求，则标记当前罪犯可能为真。

### 最优的关键思路或技巧
- **枚举法**：由于数据范围较小，通过枚举罪犯和日期，结合人物话语的真假判断来确定最终结果，简单直接且有效。
- **状态记录与判断**：定义合适的数据结构记录人物状态（如是否说真话、说假话）和证言状态（如证言类型、涉及人物、涉及日期），便于进行逻辑判断和矛盾检测。
- **字符串处理技巧**：利用`string`的相关函数（如`find`、`substr`等）对人物话语进行解析，提取关键信息，以判断话语的真假。

### 可拓展之处
此类题目属于逻辑推理与模拟类型，可拓展到其他需要通过条件判断和枚举来解决的问题，例如一些基于规则的解谜游戏、逻辑电路状态判断等。解题套路通常是明确问题中的变量和条件，通过枚举变量的可能取值，结合条件进行逻辑判断，筛选出符合要求的结果。

### 相似知识点的洛谷题目
- **P1036 [NOIP2002 普及组] 选数**：通过枚举组合判断是否满足素数条件，与本题枚举罪犯和日期判断是否符合真假人数限制类似。
- **P1157 组合的输出**：涉及枚举组合的问题，与本题中通过不同组合情况（罪犯和日期的组合）进行判断有相似之处。
- **P1219 [USACO1.5]八皇后 Checker Challenge**：通过枚举皇后的位置并进行合法性判断，与本题枚举并判断真假情况的思路类似。

### 个人心得摘录与总结
- **作者：cmd2001**：强调了换行符在不同系统下的差异可能导致WA，建议使用`fgets`读取一整行并手动处理换行符，避免因换行符问题出错。总结为在处理输入输出时，要注意不同系统下换行符的差异，选择合适的输入函数并做好处理。
- **作者：Ebola**：在输入处理上遇到困难，`getline`、`gets`、`getchar`均出现莫名错误，最终选择`cin`按单词读入并处理标点符号。心得为在输入处理时，若一种方法出现问题，可尝试其他输入方式，同时要注意处理特殊字符。 

---
处理用时：123.01秒
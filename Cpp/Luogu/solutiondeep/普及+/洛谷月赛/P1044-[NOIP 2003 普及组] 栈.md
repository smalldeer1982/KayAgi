# 题目信息

# [NOIP 2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# AI分析结果

这道题主要求解由操作数序列\(1,2,\ldots,n\)经过特定栈操作可能得到的输出序列的总数，多数题解围绕卡特兰数展开，部分采用递归、递推或搜索的方法。

1. **思路与算法要点**
    - **卡特兰数**：众多题解指出本题是卡特兰数的应用。卡特兰数的递推公式如\(h(n)=h(0)h(n - 1)+h(1)h(n - 2)+\cdots+h(n - 1)h(0)\) \((n\geq2)\)，还有其他等价公式如\(h(n)=h(n - 1)(4n - 2)/(n + 1)\) ，\(h(n)=C(2n,n)/(n + 1)\) ，\(h(n)=C(2n,n)-C(2n,n - 1)\) 。通过这些公式，利用循环计算可得出结果。
    - **递归/记忆化搜索**：定义状态\(f[i][j]\)表示队列里还有\(i\)个待排的数，栈里有\(j\)个数时的情况数。递归时，若\(i = 0\)返回\(1\)；否则分栈空和栈不空讨论，栈空时只能进栈，栈不空时有出栈或进栈再出栈等情况。为避免重复计算，使用记忆化存储已计算的状态。
    - **递推/DP**：类似递归思路定义\(f[i][j]\) ，\(i = 0\)时\(f[i][j]\)值为\(1\)作为递推边界。通过分析进栈和出栈操作对状态的影响得到递推式，如\(f[i][j]=f[i - 1][j + 1]+f[i][j - 1]\) ，且当\(i = j\)时，\(f[i][j]=f[i - 1][j]\) 。
    - **暴力搜索优化**：暴力搜索每个操作（进栈或出栈），通过剪枝和卡常优化。如判断所有数都入栈后出栈顺序唯一，以及最后只剩一个数未进栈时可直接算出方案数等。
2. **解决难点**
    - **卡特兰数理解与应用**：需理解卡特兰数与本题栈操作序列计数的联系，掌握卡特兰数不同公式的推导和适用场景。例如在取模运算时，不同公式表现不同，\(h(n)=C(2n,n)-C(2n,n - 1)\)更适合取模。
    - **递归与递推的设计**：递归要准确设定边界条件和递归关系，记忆化搜索要合理存储中间结果；递推需明确递推边界和递推式，确保状态转移的正确性。
    - **暴力搜索的优化**：找到合适的剪枝条件，利用问题的特性减少不必要的计算，如利用栈操作的特性优化边界判断。
3. **题解评分**
    - **xiejinhao**：5星。关键亮点是提供了多种解法，包括递归/记忆化搜索、递推/DP、卡特兰数的多种公式及高精/打表，对每种解法思路阐述详细，代码完整且有注释。
    - **inexistent**：4星。关键亮点是清晰解释了卡特兰数在本题中的原理，通过分析出栈序列最后一个数将问题拆分为两部分，得出卡特兰数的递推公式，代码简洁明了。
    - **Nepenthe**：4星。关键亮点是对卡特兰数的四个公式进行了详细分析，比较各公式在不同场景（如大数据取模）下的优劣，帮助读者理解公式适用范围，代码实现对应公式。

### 所选高星题解
- **xiejinhao**：5星
    - **关键亮点**：全面涵盖多种解法，思路与代码结合紧密，对各解法解释细致。
    - **个人心得**：无
    - **重点代码 - 记忆化搜索**：
```cpp
//记忆化搜索/递归 做法 
#include<cstdio>
#define MAX_N 20
#define ll long long
using namespace std;
int n;
ll f[MAX_N][MAX_N];
ll dfs(int i,int j)
{
    if(f[i][j]) return f[i][j]; 
    if(i==0)return 1; //边界 
    if(j>0) f[i][j]+=dfs(i,j-1);
    f[i][j]+=dfs(i-1,j+1);
    return f[i][j];
}
int main()
{
    scanf("%d",&n);
    printf("%lld",dfs(n,0));
    return 0;
}
```
核心实现思想：通过`dfs`函数递归计算不同状态下的方案数，`f[i][j]`记忆化存储已计算状态，避免重复计算。边界条件为`i == 0`时返回\(1\)，根据栈是否为空进行不同的递归调用。
    - **重点代码 - 卡特兰数公式4**：
```cpp
//公式4： 
#include<cstdio>
#define MAX_N 20
#define ll long long
using namespace std;
int n;
ll c[MAX_N*2][MAX_N];
int main(){

    scanf("%d",&n);
    for(int i=1;i<=2*n;i++)
    {
        c[i][0]=c[i][i]=1;
        for(int j=1;j<i;j++)
        {
            c[i][j]=c[i-1][j]+c[i-1][j-1];
        }
    }
    printf("%lld",c[2*n][n]-c[2*n][n-1]);
    return 0;
}
```
核心实现思想：先通过双重循环计算组合数`c[i][j]`，利用杨辉三角性质\(c[i][j]=c[i - 1][j]+c[i - 1][j - 1]\) ，最后根据卡特兰数公式\(h(n)=C(2n,n)-C(2n,n - 1)\)得出结果。
- **inexistent**：4星
    - **关键亮点**：对卡特兰数原理在本题的应用解释清晰，代码简洁体现核心思路。
    - **个人心得**：无
    - **重点代码**：
```cpp
//This program is written by QiXingZhi 

#include <cstdio>

int n, f[30];
int main()
{
    //递推实现卡特兰数 
    scanf("%d", &n);
    f[0] = 1, f[1] = 1;
    for(int i=2; i<=n; i++)              
        for(int j=0; j<i; j++) 
            f[i] += f[j] * f[i-j-1];     //递推公式 
    printf("%d", f[n]);
    return 0;
}
```
核心实现思想：利用卡特兰数递推公式\(h(n)=h(0)h(n - 1)+h(1)h(n - 2)+\cdots+h(n - 1)h(0)\) ，通过两层循环，外层控制\(n\)，内层遍历\(j\)计算每一项\(f[i]\) 。
- **Nepenthe**：4星
    - **关键亮点**：详细分析卡特兰数不同公式优缺点，为选择合适公式提供依据。
    - **个人心得**：通过思考总结出在不同场景下卡特兰数公式的适用性，强调思考的重要性。
    - **重点代码**：
```cpp
#include<cstdio>
#define siz 20
using namespace std;
int n;
int c[siz*2][siz];
int main(){

    scanf("%d",&n);
    for(int i=1;i<=2*n;i++) c[i][1]=c[i][i]=1;
    for(int i=3;i<=2*n;i++)
        for(int j=2;j<i;j++)
            c[i][j]=c[i-1][j]+c[i-1][j-1];
    printf("%d",c[2*n][n]-c[2*n][n-1]);
    return 0;
}
```
核心实现思想：同xiejinhao题解中卡特兰数公式4的代码，先计算组合数，再根据公式\(h(n)=C(2n,n)-C(2n,n - 1)\)得到结果。

### 最优关键思路或技巧
- **数学模型应用**：将栈操作序列计数问题转化为卡特兰数问题，利用卡特兰数的成熟公式和性质求解，简化问题复杂度。在众多卡特兰数公式中，根据题目具体要求（如是否有取模运算）选择合适公式，如涉及取模时\(h(n)=C(2n,n)-C(2n,n - 1)\)更具优势。
 - **状态定义与转移**：无论是递归/记忆化搜索还是递推/DP，合理定义状态（如\(f[i][j]\)表示队列和栈中不同数量元素时的情况数），并依据操作规则准确确定状态转移关系是解决问题的关键。
 - **剪枝优化**：对于暴力搜索，深入挖掘问题特性进行剪枝，如利用栈操作的边界情况（所有数入栈后出栈顺序固定等）减少不必要的计算，提高算法效率。

### 拓展与同类型题
 - **相似算法套路**：此类问题通常涉及计数，关键在于找到问题与已知数学模型（如卡特兰数）的联系，或通过合理定义状态和状态转移构建递推关系。对于搜索算法，要善于发现可剪枝的条件优化搜索过程。
 - **同类型题**：
     - **P1722 矩阵 II**：同样是计数问题，通过分析行列操作与卡特兰数的联系求解，锻炼对卡特兰数在不同场景的应用能力。
     - **P2532 [AHOI2012]树屋阶梯**：利用卡特兰数解决与阶梯划分相关的计数问题，进一步加深对卡特兰数原理的理解。
     - **P6620 [省选联考 2020 A 卷] 树树的数字游戏**：结合树的结构和计数问题，部分思路可能涉及类似卡特兰数的递推思想，提升综合运用能力。

### 个人心得摘录与总结
 - **Nepenthe**：通过对卡特兰数四个公式的思考分析，意识到在解决问题时要根据具体任务需求选择最合适的方法，不能死记公式，要深入理解其适用场景。这体现了在算法学习中深入思考、总结归纳的重要性，避免盲目套用公式，而是根据题目条件灵活运用知识。 

---
处理用时：107.64秒
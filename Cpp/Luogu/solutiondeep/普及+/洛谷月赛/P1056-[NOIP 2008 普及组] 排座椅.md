# 题目信息

# [NOIP 2008 普及组] 排座椅

## 题目描述

上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 $D$ 对同学上课时会交头接耳。

同学们在教室中坐成了 $M$ 行 $N$ 列，坐在第 $i$ 行第 $j$ 列的同学的位置是 $(i,j)$，为了方便同学们进出，在教室中设置了 $K$ 条横向的通道，$L$ 条纵向的通道。

于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 $2$ 个会交头接耳的同学，那么他们就不会交头接耳了。

请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。


## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/0z0p5x1i.png)

上图中用符号\*、※、+标出了 $3$ 对会交头接耳的学生的位置，图中 $3$ 条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。

2008 年普及组第二题


## 样例 #1

### 输入

```
4 5 1 2 3
4 2 4 3
2 3 3 3
2 5 2 4
```

### 输出

```
2
2 4
```

# AI分析结果

• 综合分析与结论：这些题解思路相近，均采用贪心算法解决问题。先统计每行、每列通道能分隔的交头接耳学生对数，再分别选取分隔对数最多的前K条横向通道和前L条纵向通道。算法要点在于准确统计各通道分隔对数，并按要求排序。解决难点在于理解贪心策略的正确性，即每对学生只能被一条通道分隔，优先选取分隔对数多的通道能保证整体最优。在实现上，不同题解在数据结构使用、排序方式及细节处理上存在差异。
  - 作者chrispang（4星）
    - 关键亮点：思路清晰，代码简洁。定义结构体记录通道坐标和分隔人数，两次排序分别按分隔人数和坐标排序，逻辑清晰易懂。
    - 重点代码核心思想：定义结构体存储通道信息，输入时统计各通道分隔人数，两次排序分别按分隔人数从多到少、坐标从小到大，最后输出结果。
    ```cpp
    struct node{
        int x, n; 
    }x[1010], y[1010];
    bool cmp1(node a, node b) { 
        return a.n > b.n;
    }
    bool cmp2(node a, node b) { 
        return a.x < b.x;
    }
    cin >> m >> n >> k >> l >> d;
    for (int i = 1; i <= d; i++) {
        int x1, y1, p1, q1;
        cin >> x1 >> y1 >> p1 >> q1;
        if(x1 == p1) {
            y[min(y1, q1)].x = min(y1, q1); 
            y[min(y1, q1)].n++; 
        }
        if(y1 == q1) {
            x[min(x1, p1)].x = min(x1, p1); 
            x[min(x1, p1)].n++; 
        }
    }
    sort(x + 1, x + 1 + 1000, cmp1); 
    sort(y + 1, y + 1 + 1000, cmp1);
    sort(x + 1, x + 1 + k, cmp2); 
    sort(y + 1, y + 1 + l, cmp2);
    for (int i = 1; i <= k; i++)
        cout << x[i].x << " ";
    cout << endl;
    for (int i = 1; i <= l; i++)
        cout << y[i].x << " ";
    ```
  - 作者ggpw_XNW（4星）
    - 关键亮点：对贪心算法的原理阐述清晰，代码结构分明，分定义、读入、排序、输出四部分，便于理解。
    - 重点代码核心思想：定义结构体存储通道信息，读入时判断学生位置关系统计分隔对数，两次排序分别按分隔对数和坐标排序，最后输出结果。
    ```cpp
    struct Node{
        int num, p;
    }a[10005], b[10005];
    bool cmp1(Node x, Node y){
        return x.num > y.num;
    }
    bool cmp2(Node x, Node y){
        return x.p < y.p;
    }
    cin >> m >> n >> k >> l >> d;
    for(int i=1;i<=d;i++){
        int x, y, xx, yy;
        cin >> x >> y >> xx >> yy;
        if(x==xx)b[min(y,yy)].p = min(y,yy), b[min(y,yy)].num++;
        else a[min(x,xx)].p = min(x,xx), a[min(x,xx)].num++;
    }
    sort(a+1,a+m+1,cmp1);sort(b+1,b+n+1,cmp1);
    sort(a+1,a+k+1,cmp2);sort(b+1,b+l+1,cmp2);
    ```
  - 作者Ryan114（4星）
    - 关键亮点：代码注释详细，对题意简化和思路阐述清晰，使用vector辅助记录相邻学生位置，逻辑连贯。
    - 重点代码核心思想：定义结构体存储通道信息，用vector记录相邻学生位置，遍历统计各通道分隔对数，两次排序分别按分隔对数和坐标排序，最后输出结果。
    ```cpp
    struct Line
    {
        int id,cut; 
    } hd[1005],ld[1005]; 
    bool cmp1(Line a,Line b)
    {
        return a.cut>b.cut;
    }
    bool cmp2(Line a,Line b)
    {
        return a.id<b.id;
    }
    vector<int>hv,lv; 
    cin>>m>>n>>k>>l>>d;
    for(int i=1;i<=d;i++)
    {
        int h1,l1,h2,l2;
        cin>>l1>>h1>>l2>>h2;
        if(l1==l2) hv.push_back(min(h1,h2)); 
        else lv.push_back(min(l1,l2)); 
    }
    for(int i=1;i<=m;i++) 
    {
        hd[i].id=i; 
        for(auto j : lv) if(i==j) hd[i].cut++; 
    }
    for(int i=1;i<=n;i++) 
    {
        ld[i].id=i; 
        for(auto j : hv) if(i==j) ld[i].cut++; 
    }
    sort(hd+1,hd+1+m,cmp1); 
    sort(ld+1,ld+1+n,cmp1);
    sort(hd+1,hd+1+k,cmp2); 
    sort(ld+1,ld+1+l,cmp2);
    for(int i=1;i<=k;i++) cout<<hd[i].id<<" ";
    cout<<endl;
    for(int i=1;i<=l;i++) cout<<ld[i].id<<" ";
    ```
• 最优关键思路或技巧：使用结构体存储通道的位置和能分隔的学生对数，方便统计和排序。通过贪心策略，每次选择能分隔最多学生对数的通道，保证整体最优。排序时先按分隔对数从大到小，再按位置从小到大，满足题目要求。
• 可拓展思路：此类题目属于贪心策略在二维布局优化中的应用。类似套路可用于资源分配、路径规划等场景，例如在地图上规划道路使经过的关键点最多等。解题关键在于明确贪心选择标准，并证明其正确性。
• 相似知识点洛谷题目：
  - P1094 [NOIP2007 普及组] 纪念品分组
  - P1223 排队接水
  - P1080 [NOIP2012 提高组] 国王游戏
• 个人心得摘录与总结：
  - 作者RedContritio提到不要使用快排，因为快排不稳定，容易造成ID混乱，对于本题数据量可使用冒泡排序。总结为在对结构体排序且需保证元素原有顺序关系时，要注意选择稳定的排序算法。 

---
处理用时：77.68秒
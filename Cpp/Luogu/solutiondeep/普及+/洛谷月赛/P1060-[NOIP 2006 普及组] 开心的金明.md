# 题目信息

# [NOIP 2006 普及组] 开心的金明

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $N$ 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $N$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1-5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过 $N$ 元（可以等于 $N$ 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第$j$件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,…,j_k$，则所求的总和为：

$$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2} …+v_{j_k} \times w_{j_k}$$

请你帮助金明设计一个满足要求的购物单。

## 说明/提示

NOIP 2006 普及组 第二题


## 样例 #1

### 输入

```
1000 5
800 2
400 5
300 5
400 3
200 2
```

### 输出

```
3900```

# AI分析结果

• 综合分析与结论：这些题解主要围绕01背包问题展开，思路上均将题目转化为01背包模型，把物品价格与重要度乘积作为价值，价格作为重量，目标是在总钱数限制下求最大价值和。算法要点为状态转移方程的应用，难点在于理解01背包的原理及状态转移过程。部分题解还提供了搜索和二进制枚举等方法。从质量上看，多数题解思路清晰、代码较简洁，但在优化程度和创新性上有所不足。

所选的题解：
  - 作者：oier1459078309 (赞：841)  星级：5星
    - 关键亮点：先总结多种背包模板，包括01背包无优化、一维数组优化及常数优化，完全背包和多重背包模板，然后针对本题准确建模为01背包，代码采用一维数组优化，简洁明了。
    - 重点代码核心实现思想：利用一维数组优化的01背包模板，外层循环遍历物品，内层循环从背包容量最大值开始递减，判断当前容量能否放下物品，能则更新最大价值。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int w[30],v[30],f[50000];//w数组为重要度，v数组为money，f是用来dp的数组
int n,m;//n是总物品个数，m是总钱数
int main()
{
    cin>>m>>n;//输入
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
        w[i]*=v[i];//w数组在这里意义变为总收获（重要度*money）
    }
       //01背包（参照第二类模板“一维数组优化”）
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=v[i];j--)//注意从m开始
        {
            if(j>=v[i])
            {
                f[j]=max(f[j],f[j-v[i]]+w[i]);//dp
            }
        }
    }
    cout<<f[m]<<endl;//背包大小为m时最大值
    return 0;
} 
```
  - 作者：phigy (赞：164)  星级：4星
    - 关键亮点：不仅给出常规01背包动态规划解法，还考虑到数据范围较小，提供了深度优先搜索（DFS）的方法，并给出两种方法的完整代码，对不同基础的读者有很好的参考价值。
    - 重点代码核心实现思想：
      - 01背包：利用二维数组记录状态，外层循环遍历物品，内层循环遍历背包容量，根据能否放入物品更新最大价值。
```cpp
#include <iostream>
using namespace std;
int f[30][100000];
int w[10000];
int v[10000];
int main()
{
    int n,m;
    int i,j,k;
    cin>>m>>n;
    //提前相乘
    for(i=1;i<=n;i++)
    {
        cin>>w[i]>>v[i];
        v[i]*=w[i];
    }
    for(int i=1;i<=n;i++)
    {
        //01背包最关键的位置,为防止反复加同一物品，需要倒着搜，这也是01背包与完全背包的不同之处
        for(int c=0;c<=m;c++)
        {
            f[i][c]=f[i-1][c];
            if(c>=w[i])
            f[i][c]=max(f[i][c],f[i-1][c-w[i]]+v[i]);
        }
    }
    cout<<f[n][m];
    return 0;
}
```
      - DFS：通过递归实现，每个物品有选和不选两种情况，递归到底后计算总价值并更新最大值。
```cpp
#include <iostream>
using namespace std;
int a[30],w[30],v[30],ans,s,N,m;
void dfs(int i,int s)
{
    if (i>=m+1)///选择数量到达
    {
        int t=0;
        for (int i=1;i<=m;i++)///计算体积和 
        {
            t=t+v[i]*a[i];
        }
        if (t<=N) ///体积是否小于背包体积
        {   
            if (s>=ans) ///价值和是否大于当前最大价值和
            {
                ans=s;///答案更新 
            }
        }
    }
    else
    {
        a[i]=0;
        dfs(i+1,s); ///不选
        a[i]=1;
        dfs(i+1,s+v[i]*w[i]);///选
    }
}
int main()
{
   cin>>N>>m;
   for (int i=1; i<=m; i++)
   {
       cin>>v[i]>>w[i];
   }
   dfs(1,0);
   cout<<ans;
   return ^.^;
}
```
  - 作者：superLouis (赞：2)  星级：4星
    - 关键亮点：清晰阐述解题思路，明确转移方程，代码实现中使用了快速读入优化，并且对数组进行了合理的定义和初始化，整体代码简洁高效。
    - 重点代码核心实现思想：利用一维数组记录状态，外层循环遍历物品，内层循环从背包容量最大值开始递减，根据能否放入物品更新最大价值。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
constexpr int maxn = 30;
constexpr int maxm = 3e4 + 10;
int n, m, v[maxn], w[maxn];
int f[maxm];
// f[i] 表示花费钱数 ≤ i 的重要度乘积的总和的最大值
inline int read() {
    register int x = 0, f = 1;
    char c = getchar();
    if (c == '-') f = -1;
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + c - '0';
        c = getchar();
    }
    return x * f;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    m = read(); n = read();
    for (int i = 1; i <= n; i++) {
        w[i] = read();
        int p = read();
        v[i] = w[i] * p;
    }
    for (int i = 1; i <= n; i++) 
        for (int j = m; j >= w[i]; j--) 
            f[j] = max(f[j], f[j - w[i]] + v[i]);
    cout << f[m] << "\n";
    return 0;
}
```

最优关键思路或技巧：将物品价格与重要度乘积作为价值，价格作为重量，转化为01背包问题求解。在实现上，采用一维数组优化的01背包算法，不仅空间复杂度更优，且代码简洁，通过从背包容量最大值开始递减遍历，避免同一物品多次放入背包。

可拓展之处：同类型题可涉及不同条件限制的背包问题，如完全背包（每种物品无限个）、多重背包（每种物品有限个）等。类似算法套路是分析题目条件，将实际问题转化为经典背包模型，确定状态转移方程，再根据数据范围选择合适的优化方法。

推荐题目：
  - [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)
  - [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)
  - [P2602 [ZJOI2010] 数字计数](https://www.luogu.com.cn/problem/P2602)

个人心得：无。 

---
处理用时：86.96秒
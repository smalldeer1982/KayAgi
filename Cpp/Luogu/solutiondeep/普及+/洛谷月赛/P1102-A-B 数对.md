# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效计算满足A - B = C的数对个数展开，由于数据规模较大，暴力枚举（$O(n^2)$）会超时，所以题解采用了不同的优化算法。
1. **基于映射的方法**：将A - B = C转换为A - C = B，使用map（或类似哈希结构）来统计每个数出现的次数，遍历数组时通过查找映射表来计算满足条件的数对个数，时间复杂度为$O(nlogn)$（map查找复杂度为$logn$）。
2. **二分查找法**：先对数组排序，然后对于每个元素A，通过二分查找（如lower_bound和upper_bound函数）在数组中找到A + C的位置，计算该位置与前一个位置的差值，即为满足条件的B的个数，累加这些个数得到结果，时间复杂度为$O(nlogn)$。
3. **双指针法**：排序后，利用双指针维护每个数A对应的B的连续区间，通过移动指针找到满足A - B = C的区间，统计区间内的数对个数，时间复杂度为$O(n)$。

### 所选的题解
- **作者：OsvaldoAsensioLopez (赞：789)**
    - **星级**：5星
    - **关键亮点**：思路清晰简洁，直接将原等式转化为便于统计的形式，利用map映射统计次数，代码简洁明了，易于理解。
    - **重点代码**：
```cpp
#include <iostream>
#include <map>
using namespace std;
typedef long long LL;
LL a[200001];
map<LL,LL> m;
int main() {
    int n;
    LL c;
    LL ans=0;
    cin >> n >> c;
    for(int i=1;i<=n;i++) {
        cin >> a[i];
        m[a[i]]++;
        a[i]-=c;    
    } 
    for(int i=1;i<=n;i++) ans+=m[a[i]];
    cout << ans << endl;
    return 0;
}
```
    - **核心实现思想**：先将每个数A及其出现次数记录到map中，同时将数组中的每个元素A减去C，然后遍历数组，累加每个A - C在map中的出现次数，得到满足条件的数对个数。

- **作者：樱花飞舞 (赞：536)**
    - **星级**：5星
    - **关键亮点**：详细介绍了二分查找函数lower_bound和upper_bound的用法，并巧妙应用于本题，通过排序后利用这两个函数快速找到满足条件的数对，逻辑清晰。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long a[200001];
long N,C,ans;
int main()
{
    cin>>N>>C;
    for(int i=1;i<=N;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+N+1);
    for(int i=1;i<=N;i++)
    {
        ans+=((upper_bound(a+1,a+N+1,a[i]+C)-a)-(lower_bound(a+1,a+N+1,a[i]+C)-a));
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：先对输入数组排序，然后遍历数组，对于每个元素a[i]，使用upper_bound和lower_bound函数找到a[i] + C在数组中的位置差，该差值即为满足A - B = C的数对中B的个数，累加这些个数得到结果。

- **作者：jins3599 (赞：461)**
    - **星级**：4星
    - **关键亮点**：采用双指针法，利用排序后数组的有序性，通过维护两个指针来确定满足条件的数对区间，时间复杂度为线性，优化程度较高。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2e5 + 10;
int n, c;
int a[N];
int main () 
{
	cin >> n >> c;
	for(int i = 1 ; i <= n ; i ++) cin >> a[i];
	sort(a + 1, a + 1 + n);
	int l = 1, r1 = 1, r2 = 1;
	ll ans = 0;
	for(l = 1 ; l <= n ; l ++) {
		while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
		while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
		if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
			ans += r1 - r2;
	}
	cout << ans;
	return 0;
}
```
    - **核心实现思想**：排序后，通过双指针l、r1和r2，l遍历数组，r1右移到a[r1] - a[l] <= c的最后位置的下一位，r2右移到满足a[r2] - a[l] < c最后一位，若a[r2] - a[l] == c且a[r1 - 1] - a[l] == c，则累加r1 - r2得到满足条件的数对个数。

### 最优关键思路或技巧
1. **转换思路**：将A - B = C转化为A - C = B，这样更便于通过统计和查找来解决问题。
2. **数据结构选择**：使用map等映射结构可以方便地统计数字出现的次数，虽然时间复杂度为$O(nlogn)$，但实现简单。而哈希表在空间利用上更优，时间复杂度可达到$O(n)$。
3. **二分查找优化**：对数组排序后利用二分查找函数（如lower_bound和upper_bound），能快速定位满足条件的数的位置，从而高效计算数对个数。
4. **双指针技巧**：利用排序后数组的单调性，通过双指针维护区间，线性时间内解决问题，在时间复杂度上有优势。

### 可拓展之处
同类型题通常围绕数组中元素关系的统计，常见套路是根据等式关系转化问题，选择合适的数据结构（如哈希表、map）或算法（二分查找、双指针）来优化暴力解法。例如，给定数组和目标值，求满足特定运算关系（如加法、乘法等）的元素组合个数。

### 相似知识点洛谷题目
1. **P1873 砍树**：通过二分查找确定合适的砍树高度，考察二分查找的应用。
2. **P2678 [NOIP2015 普及组] 跳石头**：利用二分查找优化搜索过程，找到满足条件的最小跳跃距离。
3. **P3957 [NOIP2017 普及组] 跳房子**：同样运用二分查找来确定可行的跳跃方案，与本题二分查找优化思路类似。

### 个人心得摘录与总结
部分作者提到在解题过程中遇到数据类型问题，如未开long long导致答案错误，强调了在处理大数据时要注意数据类型范围。还有作者分享了不同算法的时间复杂度分析以及对数据结构的选择思考，有助于理解不同解法的优缺点，在实际应用中选择最优解法。 

---
处理用时：82.32秒
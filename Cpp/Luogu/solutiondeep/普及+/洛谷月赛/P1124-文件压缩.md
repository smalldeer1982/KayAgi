# 题目信息

# 文件压缩

## 题目背景

提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。


## 题目描述

该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。

举例：$S$ 是 `example`

1. 构造 $n$ 个字符串。

```plain
example
xamplee
ampleex
mpleexa
pleexam
leexamp
eexampl
```

2. 将字符串排序。

```plain
ampleex
example
eexampl
leexamp
mpleexa
pleexam
xamplee
```
3. 压缩结果。

$S' = \texttt{xelpame}$，$p = 7$

由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。

请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。

保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。

## 样例 #1

### 输入

```
7
xelpame
7
```

### 输出

```
example
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是通过对给定的压缩后字符串 \(S'\) 进行排序得到原字符串各排列的首字母序列，利用首字母与尾字母（即 \(S'\) 中的字符）的对应关系，通过递推还原出原字符串 \(S\)。由于正向推导可能因 \(S'\) 无序导致字符错位，所以多数题解选择从后往前倒推，确保每次在有序的排序后序列中查找字符，避免错误。

### 题解评分
1. **作者：MC_Launcher (赞：143) - 4星**
    - **关键亮点**：思路阐述清晰，通过配图辅助理解，代码注释详细，明确指出正着写会出错及原因，强调倒推和倒序输出的重要性。
    - **个人心得**：“我第一眼看到这题就懵了，自己模拟一下，诶，有个规律！”“但是呢，我们正着写虽然直观易懂，但是会有错，可能有些字母会错位，我第一次正着排就才10分，所以我们要倒着找，最后反着输出，如果不理解，可以输出中间变量，然后也就懂了。”强调模拟找规律以及正向推导的易错点。
    - **核心代码**：
```cpp
for(int i=0;i<n;i++)b[i]=a[i];
sort(b,b+n);
for(int i=0;i<n;i++)
{
    if(b[i]==a[shou-1])
    {
        now=i;
        b[i]=')';
        break;
    }
}
ans[0]=a[now];
for(int i=1;i<n;i++)
{
    for(int j=n-1;j>=0;j--)
    {
        if(b[j]==a[now])
        {
            now=j;
            ans[i]=a[now];
            b[j]=')';
            break;
        }
    }   
}
for(int i=n-1;i>=0;i--)cout<<ans[i];
```
    - **核心思想**：先将输入的压缩串 \(a\) 复制给 \(b\) 并排序，找到与原串首字母位置对应的字符位置，确定答案第一个字符，之后通过从后往前遍历已排序的 \(b\) 串，找到与当前字符匹配的字符，确定答案后续字符，最后倒序输出答案。

2. **作者：liuzhaoxu (赞：43) - 4星**
    - **关键亮点**：详细解释了不能正着推的原因，并通过具体反例说明，代码结构清晰，注释完整，逻辑严谨。
    - **个人心得**：“正着推的话，我们先由给出的p确定出第一个字符，与其对应的字符串首位是下一个字符，然后再在给出的字符串 \(S1\) 中找出该字符，通过下标相等得到 \(S2\) 中对应的字符，即他后一位的字符，就这样不断循环，直到确定出原字符串的所有字符。但是这有一个问题，每次在 \(S1\) 中找字符时候， \(S1\) 是无序的，所以找到 \(S1\) 中的某个字符时可能并不能接上已经确定的答案字符串。”详细阐述正向推导错误原因。
    - **核心代码**：
```cpp
scanf("%d%s%d",&n,s+1,&p);
memcpy(ss+1,s+1,sizeof s);
sort(ss+1,ss+1+n); 
int cnt=n+1; 
for(int i=1;i<=n;++i) if(ss[i]==s[p]) { p=i;break; } 
while(cnt>1){ 
    ans[--cnt]=s[p]; 
    ss[p]='#';
    for(int i=n;i>=1;--i) if(ss[i]==s[p]) {p=i;break;} 
}
printf("%s\n",ans+1); 
```
    - **核心思想**：输入数据后，将原字符串复制并排序得到首位序列，找到原串首字母对应位置，从后往前循环，每次确定一个答案字符，同时标记已使用的字符，避免重复选择。

3. **作者：Elgo87 (赞：15) - 4星**
    - **关键亮点**：思路清晰，通过图文结合的方式详细说明了具体实现步骤，代码简洁明了，注释完整。
    - **核心代码**：
```cpp
cin >> len >> a >> p;
strcpy(b,a); sort(b,b+len);

for (int i=0; i<len; i++)   
{
    if (b[i] == a[p-1])
    {
        x = i;
        b[i] = '!'; 
        break;
    }
}

c[0] = a[x];
for (int i=1; i<len; i++) 
{
    for (int j=len-1; j>=0; j--)
    {
        if (b[j] == a[x])
        {
            x = j;
            c[i] = a[x]; 
            b[j] = '!';
            break;
        }
    }
}

for (int i=len-1; i>=0; i--)
    cout << c[i]; 
```
    - **核心思想**：输入数据后，将原串复制并排序，找到原串首字母对应位置，标记已用字符，从后往前循环匹配字符确定答案字符，最后倒序输出答案。

### 最优关键思路或技巧
倒推的思维方式是解决本题的关键技巧，通过从后往前在有序的排序后序列中查找匹配字符，避免了正向推导因原序列无序导致的字符错位问题。同时，利用排序获取原字符串各排列的首字母序列，建立首字母与尾字母的对应关系来逐步还原原字符串。

### 同类型题或类似算法套路拓展
此类题目属于字符串模拟与逆向推导类型，常见套路是根据给定的字符串变换规则，通过逆向操作还原原始字符串。关键在于理解变换规则中字符间的对应关系，利用排序等手段辅助建立这种关系，在推导过程中注意避免因原序列无序导致的错误。

### 洛谷相似知识点题目推荐
1. **P1055 [NOIP2008 普及组] ISBN 号码**：通过对ISBN号码的校验规则模拟，考查字符串处理和简单数学运算。
2. **P1914 小书童——密码**：涉及字符串的加密与解密模拟，与本题类似，需根据给定规则逆向推导。
3. **P2672 [NOIP2015 普及组] 推销员**：虽然不是单纯的字符串题，但同样需要根据题目给定的复杂规则进行模拟和推导，锻炼逻辑思维。 

---
处理用时：86.44秒
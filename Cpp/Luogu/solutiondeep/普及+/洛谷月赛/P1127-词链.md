# 题目信息

# 词链

## 题目描述

如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。

另外还有一些例子：
- `dog.gopher`
- `gopher.rat`
- `rat.tiger`
- `aloha.aloha`
- `arachnid.dog`

连接成的词可以与其他单词相连，组成更长的词链，例如：

`aloha.arachnid.dog.gopher.rat.tiger`

注意到，`.` 两边的字母一定是相同的。

现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。

## 说明/提示

- 对于 $40\%$ 的数据，有 $n \leq 10$；
- 对于 $100\%$ 的数据，有 $n \leq 1000$。


## 样例 #1

### 输入

```
6
aloha
arachnid
dog
gopher
rat
tiger```

### 输出

```
aloha.arachnid.dog.gopher.rat.tiger```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解都意识到将单词间的连接关系转化为图结构问题，部分题解采用直接搜索，部分则利用欧拉路（包括通路和回路）的性质来求解。直接搜索的方法通常会遍历所有可能起点，时间复杂度较高；而利用欧拉路性质的方法，通过分析入度、出度及图的连通性来确定起点，从而优化搜索过程。
    - 算法要点：都涉及对单词的处理，如排序以满足字典序要求；部分题解使用并查集判断图的连通性；利用数组统计每个字母作为首字母和尾字母的出现次数（即入度和出度），以此判断是否存在欧拉路及确定起点。
    - 解决难点：难点在于高效确定词链的起始点。直接搜索法需尝试每个单词作为起点，效率低；利用欧拉路性质的方法通过分析度数关系准确找到起点，优化了搜索过程。同时，还需处理无解情况，如不连通图或度数关系不符合欧拉路条件的图。

    - 综合质量来看，loc_equinox、zzr8178541919、fls233666 的题解相对更优，思路清晰，代码实现有较好的注释且对算法优化有详细说明。

所选的题解：
  - 作者：loc_equinox (5星)
    - 关键亮点：将单词作为有向边，字母作为顶点构建图，利用并查集判断图的连通性，依据有向图中欧拉通路和回路的存在条件准确判断并寻找起始点，代码结构清晰，各部分功能明确。
    - 个人心得：提到当时数据存在问题，过审题解多可被Hack，强调该题解的正确性与实用性。
    - 重点代码 - 建图部分：
```cpp
//注意：这只是部分代码
int n,i,letter[27],in[27],out[27],fa[27],set_count;
string s[1002];
int ch_start,ch_end,stf,edf;
vector<vector<node> >E;
bool cmp(string a,string b)
{
    return a<b;
}
int find(int x)
{
    if(fa[x]!=x)return fa[x]=find(fa[x]);
    return fa[x];
}
void unionn(int x,int y)
{
    fa[y]=x;
    return;
}
struct node
{
    int to,ord;
    string word;
};
int main()
{
    cin>>n;
    E.resize(27);//E数组存边
    for(i=1;i<=n;i++)cin>>s[i];
    sort(s+1,s+n+1,cmp);//排序
    for(i=1;i<=n;i++)
    {
        ch_start=s[i][0]-'a'+1;//第i个词的首字母
        ch_end=s[i][s[i].length()-1]-'a'+1;//第i个词的末字母
        out[ch_start]++;//首字母出度加1
        in[ch_end]++;//末字母入度加1
        if(!letter[ch_start])//如果这个首字母（节点）没有出现过
        {
            set_count++;//集合数加1
            letter[ch_start]=1;//标记一下
            fa[ch_start]=ch_start;//并查集初始化
        }
        if(!letter[ch_end])//同上
        {
            set_count++;//集合数加1
            letter[ch_end]=1;
            fa[ch_end]=ch_end;
        }
        if(ch_start!=ch_end)//如果不是自环
        {
            stf=find(ch_start);
            edf=find(ch_end);
            //找代表元
            if(stf!=edf)//如果不在同一集合内
            {
                set_count--;//集合数减1
                unionn(stf,edf);
            }
        }
        node tmp;//新建一条边
        tmp.to=ch_end;
        tmp.ord=i;
        tmp.word=s[i];
        E[ch_start].push_back(tmp);//vector存图
    }
    if(set_count!=1)//如果存在多个集合（连通块），那么一定没有欧拉路
    {
        cout<<"***";
        return 0;
    }
```
核心实现思想：读入单词并排序，遍历每个单词，获取首末字母并更新其入度和出度。同时利用并查集记录字母所属集合，判断图的连通性，若连通块不为1则不存在欧拉路。
    - 重点代码 - 寻找欧拉路起始点部分：
```cpp
int Eular_start,Eular_end;
//...
    for(i=1;i<=26;i++)//最多只有26个点
    {
        if(!letter[i])continue;//如果这个字母没有出现就跳过
        if(out[i]==in[i]+1)//这个点出度比入度大1
        {
            if(Eular_start)//如果有多个起点，那么无解
            {
                cout<<"***";
                return 0;
            }
            Eular_start=i;//标记起点
        }
        else if(in[i]==out[i]+1)//同上
        {
            if(Eular_end)
            {
                cout<<"***";
                return 0;
            }
            Eular_end=i;
        }
        else if(in[i]==out[i])continue;
        else
        {
            cout<<"***";
            return 0;
        }
    }
    if((Eular_start&&!Eular_end)||(!Eular_start&&Eular_end))//如果“有始无终”或“有终无始”，则无解
    {
        cout<<"***";
        return 0;
    }
    if(!Eular_start)Eular_start=s[1][0]-'a'+1;//如果是回路（无起点），则选字典序最小的点出发
```
核心实现思想：遍历所有字母节点，根据入度和出度关系判断是否符合欧拉通路或回路的条件，确定起始点和终点，若条件不满足则无解。
    - 重点代码 - DFS求欧拉路部分：
```cpp
int vis[1002];
string res[1002];
void dfs(int st,int now,int pre_edge)//st表示词链中有几个单词，now表示现在到达了哪一个点,pre_edge表示上一条边的序号，方便回溯
{
    if(st==n)//如果到达终点
    {
        for(i=1;i<=n;i++)//输出结果
        {
            cout<<res[i];
            if(i<n)cout<<".";
        }
        exit(0);
    }
    for(int k=0;k<E[now].size();k++)
    {
        if(!vis[E[now][k].ord])//如果未被标记过
        {
            vis[E[now][k].ord]=1;
            res[st+1]=E[now][k].word;
            dfs(st+1,E[now][k].to,E[now][k].ord);
        }
    }
    vis[pre_edge]=0;//回溯
    return;
}
//...
    dfs(0,Eular_start,0);//从Part 2中找到的起点开始
```
核心实现思想：从确定的起始点开始深度优先搜索，标记已访问的边，记录路径上的单词，当路径包含所有单词时输出结果，搜索失败则回溯。

  - 作者：zzr8178541919 (4星)
    - 关键亮点：通过分析词链两端字母与中间字母出现次数的性质，确定起始点。搜索过程中注意标记已使用单词、及时返回最优解等细节，代码逻辑清晰。
    - 个人心得：提到更新题解以修正之前明显错误，表明对知识的不断学习与完善。
    - 重点代码 - 确定起始点部分：
```cpp
int start=1;
char s,t;
for(char c='a';c<='z';c++)
{
    if(abs(s1[c]-s2[c])==1)
    {
        if(s1[c]-s2[c]==1)
        s=c;
        else
        if(s2[c]-s1[c]==1)
        t=c;
    }
}
int cnt=s2[t];
for(int i=1;i<=n;i++)
{
    if(a[i][0]==s && (a[i][len[i]-1]!=t || cnt!=1))
    {
        start=i;
        break;
    }
}
book[start]=1;
now[++sum]=a[start];
dfs(start,1);
```
核心实现思想：统计每个字母作为首字母和尾字母的出现次数，根据出现次数差值确定起始字母和结束字母，进而找到起始单词。
    - 重点代码 - 搜索部分：
```cpp
void dfs(int last,int step)
{
	if(flag==1)
	return;
	if(step==n)
	{
		flag=1;
		for(int i=1;i<=sum;i++)
		{
			ans[i]=now[i];
		}
		return;
	}
	for(int i=1;i<=n;i++)
	{
		if(book[i]==1)
		continue;
		if(a[last][a[last].length()-1]==a[i][0])
		{
			now[++sum]=a[i];
			book[i]=1;
			dfs(i,step+1);
			sum--;
			book[i]=0;
		}
	}
}
```
核心实现思想：从起始点开始深度优先搜索，若找到符合条件的单词则继续搜索，标记已使用单词，找到完整词链则记录结果并标记找到答案，搜索失败则回溯。

  - 作者：fls233666 (4星)
    - 关键亮点：将单词建模为有向图，通过计算点的度来判断欧拉路径起点，利用边链表存边并倒序连边保证字典序最小，对无解情况判断清晰。
    - 重点代码 - 加边部分：
```cpp
inline void add(int x,int y,int b){
	tot++;
	to[tot]=y;
	bh[tot]=b;   //存这条边对应的字符串编号
	d[x]++;
	d[y]--;   //计算点度
	nxt[tot]=lst[x];
	lst[x]=tot;
}
```
核心实现思想：向图中添加从x到y的有向边，记录边对应的字符串编号，并更新顶点x和y的度。
    - 重点代码 - 搜索部分：
```cpp
void dfs(int g){  //搜索函数
	for(rgt i=lst[g];i;i=nxt[i]){
		if(!use[bh[i]]){  //找到一条未使用的边
			use[bh[i]]=true;  //标记
			dfs(to[i]);
			lans++;  //倒序存答案
			outans[lans]=str[bh[i]];
		}
	}
}
```
核心实现思想：从顶点g开始深度优先搜索，标记已使用的边，递归搜索相邻顶点，并倒序记录路径上的单词。

最优的关键思路或技巧：
    - **数学建模**：将单词间的连接关系转化为有向图，单词作为边，字母作为顶点，把寻找词链问题转化为求有向图的欧拉路问题，这是解决本题的关键思路。
    - **度数分析**：通过统计每个字母作为首字母和尾字母的出现次数（即入度和出度），依据欧拉路的性质判断是否存在欧拉路以及确定起始点，有效优化搜索过程。
    - **排序与连边**：对单词进行排序，并在存边时采用合适方式（如倒序连边）保证得到字典序最小的答案。

可拓展之处：此类题目属于图论中关于欧拉路应用的问题，类似套路可用于解决一些涉及路径规划、任务顺序安排等实际场景问题，只要能抽象成图结构且满足欧拉路条件即可。例如，在一些物流配送路线规划中，若地点间的连接关系能构成欧拉路，可利用此方法规划出遍历所有路线且不重复的最优路径。

推荐题目：
    - P2731 [USACO3.3]骑马修栅栏 Riding the Fences：同样是求无向图的欧拉路，需要根据给定的边构建图并寻找字典序最小的欧拉路，与本题类似但图的类型不同。
    - P1341 无序字母对：通过构建无向图，判断图的连通性和顶点度数来确定是否存在欧拉回路，并输出路径，可进一步巩固对欧拉路相关知识的理解。
    - P7771 [CSP-J2021] 分糖果：虽然不是直接求欧拉路，但涉及到图的构建和遍历，在分析问题和算法设计上与本题有相似之处，有助于锻炼图论相关的思维能力。 

---
处理用时：147.98秒
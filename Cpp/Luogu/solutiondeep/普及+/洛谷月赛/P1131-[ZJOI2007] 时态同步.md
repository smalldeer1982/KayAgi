# 题目信息

# [ZJOI2007] 时态同步

## 题目描述

小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。

在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。

激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？

## 说明/提示

- 对于 $40\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 5\times 10^5$。

对于所有的数据，$1\le t_e\le 10^6$。

## 样例 #1

### 输入

```
3
1
1 2 1
1 3 3
```

### 输出

```
2
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕树形结构展开，核心思路是通过某种方式确定如何在树上增加边权，使所有叶子节点到根节点的距离相等且操作次数最少。多数题解采用树形DP或贪心策略，结合深度优先搜索（DFS）进行实现。各题解的主要差异在于状态定义、转移方程的推导以及具体实现细节。

### 所选的题解
#### 作者：Mathison (赞：187)
- **星级**：5星
- **关键亮点**：思路清晰，先明确调整靠近根节点的树枝代价更小，通过类比节点深度与距离，以DFS实现。代码简洁明了，直接计算每次调整的代价并累加。
```cpp
void dfs(int x,int fa)
{
    for(int i=head[x];i;i=next[i])
    {
        int y=ver[i],z=edge[i];
        if(y==fa) continue;
        dfs(y,x);
        dis[x]=max(dis[x],dis[y]+z);
    }
    for(int i=head[x];i;i=next[i])
    {
        int y=ver[i],z=edge[i];
        if(y==fa) continue;
        ans+=dis[x]-(dis[y]+z);
    }
}
```
核心实现思想：先递归搜索子树更新节点到叶子节点的最大距离，再计算并累加调整当前节点到子节点边权的代价。

#### 作者：crazydave (赞：127)
- **星级**：4星
- **关键亮点**：反向思考，将问题转化为叶子节点信号同时到达根节点，自下而上维护。代码注释详细，对细节把控较好，如双向加边、避免计算父节点边等。
```cpp
void dfs(int x, int fa) 
{
    for(int i=head[x]; i; i=edge[i].next)
        if(edge[i].to!=fa) dfs(edge[i].to, x);
    for(int i=head[x]; i; i=edge[i].next)
        if(edge[i].to!=fa) maxn[x]=max(maxn[x], edge[i].dis);
    for(int i=head[x]; i; i=edge[i].next)
        if(edge[i].to!=fa) ans+=(maxn[x]-edge[i].dis);
    for(int i=head[fa]; i; i=edge[i].next)
        if(edge[i].to==x) edge[i].dis+=maxn[x];
}
```
核心实现思想：先递归到叶子节点，回溯时依次维护节点到子节点的最大边权、答案以及父节点到该节点的边权。

#### 作者：ZORO (赞：5)
- **星级**：4星
- **关键亮点**：对树形DP的思路阐述清晰，通过画图辅助理解，证明了使根到所有叶子节点距离等于初始最大距离的合理性，以及在节点处保证到子树内叶子节点距离相等的必要性。
```cpp
void dfs1(int u,int fa)
{
    for(int i=head[u];i;i=e[i].nxt)
    {
        int ev=e[i].v;
        if(ev==fa) continue;
        dfs1(ev,u);
        maxx[u]=max(maxx[ev]+e[i].w,maxx[u]);
    }
}
void dfs2(int u,int fa)
{
    for(int i=head[u];i;i=e[i].nxt)
    {
        int ev=e[i].v;
        if(ev==fa) continue;
        dfs2(ev,u);
        dp[u]+=(maxx[u]-(maxx[ev]+e[i].w));
        dp[u]+=dp[ev];
    }
}
```
核心实现思想：先通过dfs1预处理每个节点到子树中叶子节点的最大距离，再通过dfs2进行DP统计答案，累加子树答案以及计算对齐需要的花费。

### 最优关键思路或技巧
1. **贪心思想**：优先调整靠近根节点的边权，因为这样能影响更多叶子节点，减少总体操作次数。
2. **树形DP**：通过定义合适的状态（如节点到叶子节点的最大距离、子树时态同步的最小代价等），利用DFS进行状态转移，自下而上解决问题。
3. **反向思考**：将从根到叶子的时态同步问题，转化为从叶子到根的信号传递问题，简化思路。

### 可拓展思路
此类题目属于树形结构上的优化问题，类似套路可用于解决树上的其他最值问题，如最小化路径和、最大化节点收益等。关键在于根据题目要求合理定义状态和转移方程，结合贪心策略优化。

### 相似知识点题目推荐
1. **P2015 二叉苹果树**：在二叉树上进行树形DP，通过保留一定数量的边来最大化苹果数量。
2. **P1352 没有上司的舞会**：经典的树形DP问题，在树形结构上根据节点的选择与否进行状态转移，求最大价值。
3. **P2014 选课**：基于树形结构的背包问题，需要合理定义状态和转移方程，结合树形结构特点解决问题。 

---
处理用时：55.03秒
# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕无向无权图中从顶点1到其他各点的最短路计数问题展开，多数题解采用经典最短路算法（如Dijkstra、SPFA、BFS）并结合计数操作。
1. **思路**：
    - **Dijkstra**：在传统堆优化Dijkstra基础上，更新距离时同步更新最短路计数。若找到更短路径，更新计数为前驱节点计数；若路径长度相同，则累加前驱节点计数。
    - **SPFA**：类似Dijkstra，在松弛操作时，根据距离更新情况处理计数。但需注意，普通SPFA在本题（边权为1）可行，在一般带权图中可能因重复计数出错。
    - **BFS**：利用无权图中BFS搜索树深度即最短路长度的特性，在BFS过程中更新计数。首次访问某点，计数设为前驱节点计数；再次访问且深度符合，累加前驱节点计数。
2. **算法要点**：
    - **初始化**：将起点的最短路计数设为1，距离设为0。
    - **更新规则**：根据不同算法的松弛或拓展操作，按距离更新情况调整最短路计数。
    - **数据结构**：常使用邻接表存图，优先队列优化Dijkstra，普通队列用于SPFA和BFS。
3. **解决难点**：
    - **计数更新**：确保在找到新的最短路或相同长度最短路时，正确更新计数，避免重复或遗漏。
    - **算法适用性**：如SPFA在本题与一般带权图中的差异，需考虑算法通用性。

### 题解评分
1. **作者：ZiDing_ByronFinlso（5星）**：
    - **关键亮点**：思路清晰，详细阐述Dijkstra堆优化和SPFA两种解法，并给出完整代码及注释，代码可读性高。
    - **个人心得**：无
    - **核心代码（SPFA）**：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
inline int read() {
    char ch = getchar();
    int x = 0, f = 1;
    while ((ch > '9' || ch < '0') && ch!= '-')
        ch = getchar();
    if (ch == '-') {
        f = -1;
        ch = getchar();
    }
    while ('0' <= ch && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
int mod = 100003;
int n, m, x, y, tot = 0;
const int N = 1000005, M = 4000005;
int head[N], to[M], nxt[M], d[N], ans[N];
bool p[N];
queue<int> q;
void add(int x, int y) {
    to[++tot] = y;
    nxt[tot] = head[x];
    head[x] = tot;
}
int main() {
    n = read(); m = read();
    for (int i = 1; i <= m; i++) {
        x = read(); y = read();
        add(x, y);
        add(y, x);
    }
    for (int i = 1; i <= n; i++) {
        d[i] = 1e9; p[i] = 0;
    }
    d[1] = 0;
    p[1] = 1;
    ans[1] = 1;
    q.push(1);
    while (q.size()) {
        x = q.front(); q.pop();
        p[x] = 0;
        for (int i = head[x]; i; i = nxt[i]) {
            y = to[i];
            if (d[y] > d[x] + 1) {
                d[y] = d[x] + 1;
                ans[y] = ans[x];
                if (!p[y]) {
                    q.push(y);
                    p[y] = 1;
                }
            }
            else if (d[y] == d[x] + 1) {
                ans[y] += ans[x];
                ans[y] %= mod;
            }
        }
    }
    for (int i = 1; i <= n; i++)
        printf("%d\n", ans[i]);
    return 0;
}
```
    - **核心实现思想**：通过SPFA算法，在每次从队列取出节点拓展时，若发现更短路径，更新距离和计数；若路径长度相同，累加计数。
2. **作者：岸芷汀兰（4星）**：
    - **关键亮点**：明确指出本题可用BFS解决，详细分析解题思路，包括自环和重边处理，代码注释详细，可读性好。
    - **个人心得**：无
    - **核心代码（BFS）**：
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>

using namespace std;
inline int read(void) {
    int x = 0, f = 1; char ch = getchar();
    while (ch<'0' || ch>'9') {
        if (ch == '-')f = -1;
        ch = getchar();
    }
    while (ch >= '0'&&ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return f * x;
}

inline void write(int x) {
    int y = 10, len = 1;
    while (y <= x) {
        y *= 10; len++;
    }
    while (len--) {
        y /= 10; putchar(x / y + 48); x %= y;
    }
}

const int maxn = 1000005, mod = 100003;
int n, m, ans[maxn], d[maxn];
bool vis[maxn];

vector<int>linker[maxn];

struct Node {
    int node, dis;
};

inline Node make(int first, int second) {
    Node ans; ans.node = first; ans.dis = second;
    return ans;
}

inline void connect(int x, int y) {
    linker[x].push_back(y);
}

inline void bfs(void) {
#define cur linker[u][i]

    queue<Node>q; q.push(make(1, 0));
    memset(d, 0x3f, sizeof(d)); d[1] = 0;
    vis[1] = true;
    ans[1] = 1;
    while (q.size()) {
        int u = q.front().node, dis = q.front().dis;
        q.pop();
        for (register int i = 0; i<int(linker[u].size()); i++) {
            if (!vis[cur]) {
                q.push(make(cur, dis + 1)); vis[cur] = true; d[cur] = dis + 1;
                ans[cur] += ans[u]; /*重点*/ans[cur] %= mod;
            }
            else {
                if (dis + 1 == d[cur]) { ans[cur] += ans[u]; /*重点*/ans[cur] %= mod; }
            }
        }
    }
}

int main()
{
    n = read(); m = read();
    for (register int i = 1; i <= m; i++) {
        int x = read(), y = read();
        if (x == y)continue;//删除自环
        connect(x, y); connect(y, x);
    }
    bfs();
    for (register int i = 1; i <= n; i++) {
        write(ans[i] % mod); putchar('\n');
    }
    return 0;
}
```
    - **核心实现思想**：利用BFS遍历图，在遍历过程中，根据节点是否首次访问及距离情况更新最短路计数。
3. **作者：King丨帝御威（4星）**：
    - **关键亮点**：强调堆优化Dijkstra的优势，代码结构清晰，注释详细，对Dijkstra算法结合计数操作讲解详细。
    - **个人心得**：无
    - **核心代码（Dijkstra堆优化）**：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#define maxn 1000000 + 1
#define maxn1 4000000 + 1
#define mod 100003
using namespace std;
inline int qread() {
    char c = getchar(); int num = 0, f = 1;
    for (;!isdigit(c); c = getchar()) if (c == '-') f = -1;
    for (;isdigit(c); c = getchar()) num = num * 10 + c - '0';
    return num * f;
}
int n, m, dis[maxn], head[maxn], s, js[maxn], num;
struct Edge {
    int v, w, nxt;
}edge[maxn1];
inline void ct(int u, int v, int w) {
    edge[++num].v = v;
    edge[num].w = w;
    edge[num].nxt = head[u];
    head[u] = num;
}
struct node {
    int x, y;
    bool operator < (const node& a) const {
        return y > a.y;
    }
};
void dijkstra() {
    memset(dis, 0x3f, sizeof(dis));
    dis[1] = 0;
    priority_queue<node>q;
    js[1] = 1;
    q.push((node){1, 0});
    node a;
    while (!q.empty()) {
        a = q.top();
        int u = a.x, d = a.y;
        q.pop();
        if (d!= dis[u]) continue;
        for (int i = head[u]; i; i = edge[i].nxt) {
            int v = edge[i].v;
            if (d + edge[i].w == dis[v])
                js[v] = (js[u] + js[v]) % mod;
            if ((dis[v] > dis[u] + edge[i].w)) {
                dis[v] = dis[u] + edge[i].w;
                js[v] = js[u];
                q.push((node){v, dis[v]});
            }
        }
    }
}
int main()
{
    n = qread(), m = qread();
    for (int i = 1, u, v; i <= m; ++i)
    {
        u = qread(), v = qread();
        ct(u, v, 1);
        ct(v, u, 1);
    }
    dijkstra();
    for (int i = 1; i <= n; ++i)
        cout << js[i] << '\n';
    cout << '\n';
    return 0;
}
```
    - **核心实现思想**：运用堆优化Dijkstra，每次从优先队列取出距离最小节点，更新其邻接节点距离和最短路计数。

### 最优关键思路或技巧
1. **利用已有算法框架**：在经典最短路算法（Dijkstra、SPFA、BFS）基础上，巧妙添加计数逻辑，通过距离更新判断决定计数更新方式。
2. **数据结构选择**：使用邻接表存图，减少空间复杂度；利用优先队列优化Dijkstra，提高算法效率。

### 可拓展之处
1. **同类型题**：对于带权图的最短路计数，需更谨慎处理SPFA中的重复计数问题，可参考题解中对一般带权图SPFA计数的调整。
2. **类似算法套路**：在其他图论问题中，可结合搜索或动态规划思想，根据节点间关系更新特定属性（如路径数量、最大流等）。

### 推荐题目
1. **P1608 路径统计**：同样是最短路计数问题，但涉及带权图，需注意算法适用性。
2. **P3371 【模板】单源最短路径（弱化版）**：可用于巩固Dijkstra和SPFA等最短路算法基础。
3. **P4779 【模板】单源最短路径（标准版）**：强化版单源最短路径问题，可进一步提升对最短路算法的理解和应用能力。

### 个人心得摘录与总结
1. **作者：XZYQvQ**：发现普通SPFA统计答案在某些题目中存在问题，通过先跑SPFA得到最短路长度，再记忆化搜索遍历最短路图得到答案，解决了类似vjudge上题目的正确性问题。总结出在不同题目条件下，需注意算法的适用性和正确性，不能仅依赖在某题上的AC结果。 

---
处理用时：129.04秒
# 题目信息

# 逃离僵尸岛

## 题目描述

小 a 住的国家被僵尸侵略了！小 a 打算逃离到该国唯一的国际空港逃出这个国家。


该国有 $N$ 个城市，城市之间有道路相连。一共有 $M$ 条双向道路。保证没有自环和重边。


其中 $K$ 个城市已经被僵尸控制了，如果贸然闯入就会被感染 TAT...所以不能进入。由其中任意城市经过不超过 $S$ 条道路就可以到达的别的城市，就是危险城市。换句话说只要某个城市到任意被僵尸控制的城市距离不超过 $S$，就是危险的。

小 a 住在 $1$ 号城市，国际空港在 $N$ 号城市，这两座城市没有被侵略。小a走每一段道路（从一个城市直接到达另外一个城市）得花一整个白天，所以晚上要住旅店。安全的的城市旅馆比较便宜要 $P$ 元，而被危险的城市，旅馆要进行安保措施，所以会变贵，为 $Q$ 元。所有危险的城市的住宿价格一样，安全的城市也是。在 $1$ 号城市和 $N$ 城市，不需要住店。


小 a 比较抠门，所以他希望知道从 $1$ 号城市到 $N$ 号城市所需要的最小花费。

输入数据保证存在路径，可以成功逃离。输入数据保证他可以逃离成功。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/2681.png) 

对于 $20\%$ 数据，$N\le 50$。

对于 $100\%$ 数据，$2\le N\le 10^5$，$1\le M\le 2\times 10^5$，$0\le K\le N - 2$，$0\le S\le 10^5$，$1\le P< Q\le 10^5$。


## 样例 #1

### 输入

```
13 21 1 1
1000 6000
7
1 2
3 7
2 4
5 8
8 9
2 5
3 4
4 7
9 10
10 11
5 9
7 12
3 6
4 5
1 3
11 12
6 7
8 11
6 13
7 8
12 13```

### 输出

```
11000```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何确定危险城市以及将点权转化为边权来计算最短路。多数题解先通过BFS确定危险城市，再使用不同最短路算法求解。
1. **思路**：
    - **确定危险城市**：将被僵尸控制的城市作为源点，通过BFS标记距离这些源点不超过S的城市为危险城市。
    - **计算最短路**：根据城市是否危险赋予不同边权，再使用如Dijkstra、SPFA等最短路算法计算从1号城市到N号城市的最小花费。
2. **算法要点**：
    - **BFS**：用于快速标记危险城市，时间复杂度为O(N + M)。
    - **最短路算法**：Dijkstra算法结合优先队列优化，时间复杂度为O((N + M)logN)；SPFA算法时间复杂度在随机图上接近O(N + M)，但最坏情况为O(NM)。
3. **解决难点**：
    - **多源最短路问题**：将多个被僵尸控制的城市作为源点，可通过将所有源点归纳到一个外加点，或直接多源BFS来解决。
    - **点权转边权**：常见方法有将一条边的边权设为连接的两个点权之和（最后结果除2），或拆点，或根据点权直接为边赋权。

### 题解推荐
1. **作者：fyfy (赞：35)**
    - **星级**：4星
    - **关键亮点**：思路清晰，先将所有“被占点”归纳在0这一个外加点上，用SPFA求出危险点，再以1为源点求最短路，代码简洁明了，注释详细。
    - **核心代码**：
```cpp
// 以0为源点求危险点
inline void spfa(int now) {
    memset(vis, 0, sizeof(vis));
    for (int i = 1; i <= n; ++i) dis[i] = inf;
    while (!q.empty()) q.pop();
    q.push(now); dis[now] = 0; vis[now] = 1;
    while (!q.empty()) {
        int x = q.front();
        for (int i = o[x]; i; i = s[i][1]) {
            int y = s[i][0];
            if (dis[y] > dis[x] + w[i]) {
                dis[y] = dis[x] + w[i];
                if (!vis[y])
                    vis[y] = 1, q.push(y);
            }
        }
        vis[x] = 0; q.pop();
    }
}
// 以1为源点求最短路
spfa(0);
for (int i = 1; i <= n; ++i)
    if (dis[i] <= ss) dgs[i] = 1;
for (int i = 1; i <= cnt; ++i) {
    if (dgs[s[i][0]]) w[i] = Q;
    else if (ocp[s[i][0]]) w[i] = inf;
    else w[i] = P;
    if (s[i][0] == 1 || s[i][0] == n) w[i] = 0;
}
spfa(1);
```
2. **作者：浮梦若生 (赞：8)**
    - **星级**：4星
    - **关键亮点**：采用DIJKSTRA（堆优化） + BFS的算法组合，先BFS求出危险城市，再将点权转化为边权，最后用堆优化的Dijkstra求最短路，代码逻辑清晰，有详细的注释和读入优化。
    - **核心代码**：
```cpp
// BFS求出危险城市
void BFS(int SUM) {
    HEHE(Q2.size()) {
        int X = Q2.front();
        Q2.pop();
        if (DIS[X] == SUM)
            continue;
        for (register int I = HEAD[X]; I; I = NEXT[I]) {
            int Y = TO[I];
            if (!DIS[Y]) {
                DIS[Y] = DIS[X] + 1;
                Q2.push(Y);
            }
        }
    }
    for(register int I = 1;I <= CNT;I++){
        int Y = TO[I];
        if(Y == M)continue;
        if(F2[Y]!= 0)continue;
        if(DIS[Y] == 0)W[I] = U;
        else W[I] = V;
    }
}
// 优先队列（堆优化）DIJKSTRA
void DIJKSTRA(int S) {
    for(register int I = 1;I <= M;I++)
        DIS[I] = INF;
    Q1.push(make_pair(0, S));
    DIS[S] = 0;
    while(Q1.size()) {
        int X = Q1.top().second;
        Q1.pop();
        if (F1[X])continue;
        F1[X] = 1;
        for(register int I = HEAD[X]; I; I = NEXT[I]) {
            int Y = TO[I], K = W[I];
            if (DIS[Y] > DIS[X] + K && F2[Y]!= 1) {
                DIS[Y] = DIS[X] + K;
                Q1.push(make_pair(-DIS[Y], Y));
            }
        }
    }
}
```
3. **作者：顾z (赞：8)**
    - **星级**：4星
    - **关键亮点**：分析详细，定义明确，先BFS处理出安全与否的城市，再用Dijkstra求最短路，注意到跑完最短路后需减去n点的价值，代码结构清晰，有详细注释。
    - **核心代码**：
```cpp
// BFS处理城市安全性
inline void bfs() {
    while (!q1.empty()) {
        int u = q1.front().u, dis = q1.front().dis;
        q1.pop();
        for (R int i = head[u]; i; i = edge[i].u) {
            if (dis < S and safe[edge[i].v] == 1) {
                safe[edge[i].v] = 0;
                q1.push((coc){edge[i].v, dis + 1});
            }
        }
    }
}
// Dijkstra求最短路
inline void dij() {
    for (R int i = 1; i <= n; i++) dis[i] = 21474836476666;
    priority_queue<hop> q;
    q.push((hop){1, 0}); dis[1] = 0;
    while (!q.empty()) {
        int u = q.top().u; q.pop();
        if (vis[u])continue;
        vis[u] = true;
        for (R int i = head[u]; i; i = edge[i].u) {
            if (safe[edge[i].v] == -1)continue;
            if (safe[edge[i].v] == 0)
                if (dis[edge[i].v] > dis[u] + Q) {
                    dis[edge[i].v] = dis[u] + Q;
                    q.push((hop){edge[i].v, dis[edge[i].v]});
                }
            if (safe[edge[i].v] == 1)
                if (dis[edge[i].v] > dis[u] + p) {
                    dis[edge[i].v] = dis[u] + p;
                    q.push((hop){edge[i].v, dis[edge[i].v]});
                }
        }
    }
}
```

### 最优关键思路或技巧
1. **多源BFS**：将多个被僵尸控制的城市同时作为BFS的起点，能高效地标记出危险城市，避免对每个源点单独进行BFS带来的高时间复杂度。
2. **点权转边权技巧**：如将边权设为连接两点的点权之和（最后结果除2），或根据点的属性直接为边赋权，巧妙地将点权问题转化为边权问题，便于使用最短路算法求解。

### 可拓展思路
此类题目属于图论中结合点权和最短路的问题。类似套路包括先通过某种搜索确定点的属性（如危险或安全），再根据属性处理边权，最后用最短路算法求解。同类型题可涉及不同的图结构（如带权有向图）或点权、边权的不同定义方式。

### 相似知识点洛谷题目
1. **P1339 热浪**：同样是在图中求最短路，可用于巩固最短路算法的应用。
2. **P3371 【模板】单源最短路径（弱化版）**：单源最短路径模板题，加深对最短路算法的理解。
3. **P1144 最短路计数**：在求最短路的基础上，增加了对最短路数量的统计，锻炼对图论问题的综合处理能力。

### 个人心得摘录与总结
1. **作者：顾z**：强调需要注意跑完最短路后在n点居住的费用处理，要判断n点是否安全来决定减去哪个费用，同时要将极大值赋得足够大，并且记得开long long，否则可能导致WA。总结了该题容易出错的细节。
2. **作者：Lynx**：提到要用long long，dfs时要用到类似spfa的思想，不能仅以是否搜过来判断，还需考虑能否更新，同时在处理cst数组时不能边搜索边赋值，否则可能给n赋值导致错误，总结了代码实现中的关键注意事项。
3. **作者：Euplectella**：分享了自己从一开始对每个感染城市跑spfa找危险城市，最后再对全图跑spfa只得到28分，到发现对全图的spfa在距离超过s时可停止，进而基于spfa思想对僵尸控制城市进行bfs标记危险城市的思路转变过程，强调了优化思路在解题中的重要性。 

---
处理用时：81.96秒
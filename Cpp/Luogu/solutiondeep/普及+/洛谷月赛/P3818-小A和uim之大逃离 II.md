# 题目信息

# 小A和uim之大逃离 II

## 题目背景

话说上回……还是参见 <https://www.luogu.com.cn/problem/P1373> 吧

小 a 和 uim 再次来到雨林中探险。突然一阵南风吹来，一片乌云从南部天边急涌过来，还伴着一道道闪电，一阵阵雷声。刹那间，狂风大作，乌云布满了天空，紧接着豆大的雨点从天空中打落下来，只见前方出现了一个牛头马面的怪物，低沉着声音说：“呵呵，既然你们来到这，两个都别活了！”。小 a 和他的小伙伴再次惊呆了！


## 题目描述

瞬间，地面上出现了一个 $H$ 行 $W$ 列的巨幅矩阵，矩阵的每个格子上要么是空地 `.` 或者障碍 `#`。

他们起点在 $(1,1)$，要逃往 $(H,W)$ 的出口。他们可以一次向上下左右移动一格，这个算一步操作。不过他们还保留着上次冒险时收集的魔液，一口气喝掉后可以瞬移到相对自己位置的 $(D,R)$ 向量；也就是说，原来的位置是 $(x,y)$，然后新的位置是 $(x+D,y+R)$，这个也算一步操作，不过他们仅能至多进行一次这种操作（当然可以不喝魔液）。

这个地方是个是非之地。所以他们希望知道最小能有几步操作可以离开这个鬼地方。不过他们可能逃不出这个鬼地方，遇到这种情况，只能等死，别无他法。


## 说明/提示

样例解释 $1$

$(1,1) \to (1,2)\to (1,3)\to$ 喝魔液 $\to (3,4)\to (3,5)\to (3,6)$。

样例解释 $2$

因为只有一瓶魔液所以他们没办法逃出来。

样例解释 $3$

$D$ 和 $R$ 还可以是 $0$或者负数。

数据范围与约定

$40\%$ 的测试数据 $2\leq H,W\leq 5$。

$70\%$ 的测试数据 $2\leq H,W\leq 100$。

$100\%$ 的测试数据 $2\leq H,W\leq 1000,|D|<H,|R|<W$。

## 样例 #1

### 输入

```
3 6 2 1
...#..
..##..
..#...```

### 输出

```
5
```

## 样例 #2

### 输入

```
3 7 2 1
..#..#.
.##.##.
.#..#..```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 6 -2 0
.#....
.#.#..
.####.
.#..#.
.##.#.
....#.```

### 输出

```
21```

# AI分析结果

这道题是在矩阵地图中从起点到终点的路径搜索问题，关键在于处理仅能使用一次的魔液瞬移操作。多数题解采用广度优先搜索（BFS），少数通过建图跑最短路或双向BFS实现。

1. **思路与要点对比**
    - **主流BFS思路**：多数题解用BFS遍历矩阵。为处理魔液限制，通过三维数组（如`step[x][y][0/1]`）记录到达点的步数及魔液使用状态。遍历点时，先按常规走迷宫方式处理相邻点，若该点未使用魔液，再处理使用魔液可转移的点。
    - **双向BFS思路**：从起点和终点分别进行BFS，记录每个点到起点和终点的距离，通过枚举嗑药点，计算经过跳跃到达终点的距离，取最小值。
    - **建图跑最短路思路**：将矩阵每个点编号，用链式前向星存边，区分普通移动和嗑药移动，通过SPFA算法求起点到终点的最短路。
2. **难点处理**
    - **魔液使用限制**：通过增加维度标记魔液使用状态，保证仅能使用一次。
    - **状态判重**：使用三维数组记录访问状态，避免重复访问已遍历的状态。
3. **题解评分**
    - **x_faraway_x**：思路清晰，直接点明用BFS并解释如何处理魔液，代码简洁明了。 5星
    - **zpf_13516358919**：对魔液作用分析详细，代码逻辑清晰，但代码量相对较多。4星
    - **amstar**：思路和代码都较清晰，强调判重，但对魔液使用的处理描述稍简略。4星
4. **最优思路技巧**：用三维数组记录状态是处理本题魔液使用限制的关键技巧，既简单又高效。BFS按层遍历的特性保证了第一次到达某状态时的步数即为最少步数，无需额外更新最小值。
5. **拓展**：此类题目属于带特殊条件的迷宫搜索问题，相似套路是遇到特殊操作（如瞬移、飞行等），通过增加维度记录状态来处理。相似题目有：
    - **P1141 01迷宫**：涉及在01矩阵中的搜索，可类比本题处理不同状态的思路。
    - **P1387 最大正方形**：同样在矩阵中搜索，可借鉴本题BFS处理状态的方法。
    - **P1596 湖计数**：矩阵搜索问题，可参考本题BFS遍历及状态记录方式。
6. **个人心得摘录**
    - **amstar**：提到数据范围`<=1000`，数组开`1010`会`RE`，直接开`2010`可`AC`，强调了数组大小设置的重要性。
    - **attack**：指出`vis`数组开小会`RE`第2个点，开大了会`RE`第7个点，说明数组大小调试的复杂性。

### 5星题解
- **x_faraway_x**
    - **星级**：5星
    - **关键亮点**：思路阐述简洁清晰，直接点明裸BFS及魔液处理方法，代码简洁无冗余注释，利于读者自行思考实现。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int N=1005;
int h,w,d,r,st[N][N][2];
char s[N][N];
struct Point
{
    int x,y,u;
};
queue<Point> Q;
int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};
bool check(int x, int y)
{
    return x>=1&&y>=1&&x<=h&&y<=w&&s[x][y]=='.';
}
int main()
{
    scanf("%d%d%d%d",&h,&w,&d,&r);
    for(int i=1;i<=h;i++)
        scanf("%s",s[i]+1);
    memset(st,-1,sizeof(st));
    st[1][1][0]=0;
    Q.push((Point){1,1,0});
    while(!Q.empty()&&st[h][w][0]==-1&&st[h][w][1]==-1)
    {
        Point f=Q.front();
        Q.pop();
        for(int i=0;i<4;i++)
        {
            int x=dx[i]+f.x,y=dy[i]+f.y;
            if(check(x,y)&&st[x][y][f.u]==-1)
            {
                Q.push((Point){x,y,f.u});
                st[x][y][f.u]=st[f.x][f.y][f.u]+1;
                if(f.u==0&&check(x+d,y+r)&&st[x+d][y+r][1]==-1)
                {
                    Q.push((Point){x+d,y+r,1});
                    st[x+d][y+r][1]=st[x][y][0]+1;
                }
            }
        }
    }
    if(st[h][w][0]==-1&&st[h][w][1]==-1) puts("-1");
    else 
    printf("%d",min(st[h][w][0]==-1?1<<30:st[h][w][0],
                    st[h][w][1]==-1?1<<30:st[h][w][1])); 
}
```
核心思想：利用三维数组`st[x][y][u]`记录到达`(x,y)`且魔液使用状态为`u`的最少步数。BFS过程中，先处理普通移动，若当前点未使用魔液，再处理魔液瞬移操作。

### 4星题解
- **zpf_13516358919**
    - **星级**：4星
    - **关键亮点**：对魔液作用分析详细，先通过`bfs1`搜索出不用喝药能到达的地方，为后续判断魔液使用情况提供依据，代码逻辑清晰。
```cpp
void bfs1()//搜索出不用喝药能到达的地方 
{
    q[0].x=1;q[0].y=1;
    past0[1][1]=1;
    int head=0,tail=1;
    while(head<tail)
    {
        cur=q[head++];
        for(int i=1;i<=4;i++)
        {
            nxt.x=cur.x+dx[i];
            nxt.y=cur.y+dy[i];
            if(nxt.x>=1&&nxt.x<=n&&nxt.y>=1&&nxt.y<=m&&!ma[nxt.x][nxt.y]&&!past0[nxt.x][nxt.y])
            {
                past0[nxt.x][nxt.y]=1;
                q[tail++]=nxt;
            }
        }
    }
}
void bfs()
{
    memset(q,0,sizeof(q));
    q[0].x=1;q[0].y=1;q[0].step=0;q[0].f=0;
    past1[1][1]=1;
    int head=0,tail=1;
    while(head<tail)
    {
        cur=q[head++];
        if(cur.x==n&&cur.y==m)
        {
            cout<<cur.step;
            return;
        }
        for(int i=0;i<=4;i++)
        {
            nxt.f=cur.f;
            if(i==0)
            {
                if(!nxt.f)//没喝过药
                {
                    nxt.x=cur.x+dx[0];
                    nxt.y=cur.y+dy[0];
                    if(!past0[n][m])//不喝药不能走到终点
                    {
                        if(past0[nxt.x][nxt.y])
                                       //喝药之后,再走到不喝药能走到的地方,喝药就没有意义
                    continue;//略过这种情况
                    }
                }
                else continue;
            }
            else
            {
                nxt.x=cur.x+dx[i];
                nxt.y=cur.y+dy[i];
            }
            if(nxt.x>=1&&nxt.x<=n&&nxt.y>=1&&nxt.y<=m&&!ma[nxt.x][nxt.y]&&!past1[nxt.x][nxt.y])
            {
                if(i==0)nxt.f=1;//本次喝药,标记为使用
                past1[nxt.x][nxt.y]=1;//标记为走过
                nxt.step=cur.step+1;//步数+1
                q[tail++]=nxt;
            }
        }
    }
    cout<<-1;
}
```
核心思想：`bfs1`标记不喝药能到达的点，`bfs`中根据是否能不喝药到终点及当前点是否喝过药，决定魔液使用及搜索方向，同时用数组记录访问状态。

- **amstar**
    - **星级**：4星
    - **关键亮点**：代码简洁，清晰阐述用三维数组判重及BFS过程中魔液使用的处理，即若点用过魔液，其扩展点状态均为喝过药。
```cpp
void bfs()
{
    cur.flag = 0;cur.step = 0;
    cur.x = 1;cur.y = 1;
    q.push(cur);
    v[1][1][0] = true;
    while (!q.empty())
    {
        cur = q.front();
        q.pop();
        if (cur.flag == 1) f = 1;
        else f = 0;
        for (int i=0; i<4; ++i)
        {
            int xx = dx[i]+cur.x;
            int yy = dy[i]+cur.y;
            if (xx>0&&xx<=n&&yy>0&&yy<=m&&mp[xx][yy]!='#'&&!v[xx][yy][f])    //是否出界 
            {
                if (xx==n&&yy==m)
                {
                    printf("%d",cur.step+1);
                    return ;
                }
                v[xx][yy][f] = true;
                nxt.flag = f;nxt.step = cur.step+1;
                nxt.x = xx;nxt.y = yy;
                q.push(nxt);
            }
        }
        int xx = cur.x+dx[4], yy = cur.y+dy[4];
        if (f==0&&!v[xx][yy][1]&&xx>0&&xx<=n&&yy>0&&yy<=m&&mp[xx][yy]!='#')
        {
            if (xx==n&&yy==m)
            {
                printf("%d",cur.step+1);
                return ;
            }
            v[xx][yy][1] = true;
            nxt.flag = 1;nxt.step = cur.step+1;
            nxt.x = xx;nxt.y = yy;
            q.push(nxt);
        }
    }
    printf("-1");    
}
```
核心思想：通过`v[xx][yy][f]`三维数组记录访问状态，`f`表示魔液使用情况。BFS遍历中，先处理普通移动，若当前点未用魔液，再处理魔液瞬移操作并更新状态。 

---
处理用时：123.17秒
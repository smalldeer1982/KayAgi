# 题目信息

# 松江 1843 路

## 题目描述

涞坊路是一条长 $L$ 米的道路，道路上的坐标范围从 $0$ 到 $L$，路上有 $N$ 座房子，第 $i$ 座房子建在坐标为 $x_i$ 的地方，其中住了 $r_i$ 人。

松江 1843 路公交车要在这条路上建一个公交站，市政府希望让最多的人得到方便，因此希望所有的每一个的居民，从家到车站的距离的**总和**最短。

公交站应该建在哪里呢？

## 说明/提示

### 样例解释 1

当建在坐标 $40$ 的时候，所有人距离车站的距离总和为 $|20-40| \times 3+|50-40| \times 2+|70-40| \times 1=110$。

### 数据范围和约定

对于 $10\% $的数据，$1\le N \le 50$，$R_i=1$。

对于 $30\%$ 的数据，$1 \le N \le 100$，$R_i \le 10$，$1 \le L \le 1000$。

对于 $70\%$ 的数据，$1 \le N \le 1000$，$R_i \le 100$，$1 \le L \le 10^6$。

对于全部数据，$1 \le L \le 10^{10}$，$1 \le N \le 10^5$，$0 \le x_i \le L$，$1 \le r_i \le 1000$。

## 样例 #1

### 输入

```
100 3
20 3
50 2
70 1
```

### 输出

```
110
```

## 样例 #2

### 输入

```
100 2
0 1
100 10
```

### 输出

```
100
```

## 样例 #3

### 输入

```
10000000000 5
3282894320 391
4394338332 929
6932893249 181
7823822843 440
9322388365 623
```

### 输出

```
5473201404068
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕在给定道路上有若干房子及居住人数的情况下，如何找到使所有人到公交站距离总和最短的位置这一问题展开。
- **思路与算法要点**：
    - **中位数法**：多数题解通过证明或直观理解，得出公交站应建在按坐标排序后房子的中位数位置（考虑人数权重）能使距离总和最小。如将每个房子按人数拆成多个点，或直接通过前缀和等方式找到中位数对应的房子位置，再计算距离总和。
    - **模拟法**：通过模拟移动公交站位置，比较移动前后距离总和的变化来确定最优位置。例如从第一个房子位置开始，计算每次向右移动一个坐标时距离总和的增减情况，当向右移动使距离总和开始增大时，当前位置即为最优。
    - **函数法**：将距离总和表示为关于公交站位置的分段函数，通过分析函数斜率和截距的变化规律，利用前缀和优化计算每个区间的最值，从而找到全局最小值。
    - **其他方法**：还有换根DP、模拟退火、三分、二分等方法。换根DP通过状态设置和转移方程计算每个房子作为公交站时的距离和；模拟退火是一种随机搜索算法；三分和二分则基于函数的单调性来寻找最小值。
- **解决难点**：主要难点在于如何高效地找到使距离总和最小的位置，避免暴力枚举带来的时间复杂度问题。不同方法通过数学证明、优化计算过程或利用函数性质等方式来解决该难点。

综合来看，中位数法相对简洁直观且高效，多数基于此思路的题解质量较高。

### 所选的题解
- **作者：_Lemon_ (赞：27)  星级：4星**
    - **关键亮点**：思路清晰，通过模拟逐步清空人数少的房子，更新指针和人数，最终确定公交站位置，代码简洁明了。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long s[100001],people[100001];
int main()
{
    long long n,l,k,i,end,tou;
    long long ans=0;
    cin>>l>>n;
    for(i=1;i<=n;i++)
      cin>>s[i]>>people[i];
    end=n;
    tou=1;
    while(end>tou)
    {
        k=min(people[tou],people[end]);
        people[tou]-=k;
        people[end]-=k;
        ans+=k*(s[end]-s[tou]);
        if(people[end]==0) end--;
        if(people[tou]==0) tou++;
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：初始化首尾房子指针，每次取首尾房子人数的最小值，将该人数从首尾房子中减去，并更新距离总和，同时根据人数是否为0更新指针，直到只剩下一个有人的房子，此时的房子位置即为公交站位置，其距离总和即为答案。
- **作者：hanzhongtlx (赞：9)  星级：4星**
    - **关键亮点**：将问题转化为分段函数，通过分析函数斜率和截距的变化规律，利用前缀和优化计算每个区间的最值，独特且有深度的解题思路。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
long long n,m;
struct node
{
	long long x,r;
}e[500005];
long long ans,b,k;
bool cmp(node n,node m)
{
	return n.x<m.x;
}
int main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%lld%lld",&e[i].x,&e[i].r);
	}
	sort(e+1,e+m+1,cmp);
	e[m+1].x=n;
	for(int i=1;i<=m;i++)
	{
		k-=e[i].r;
	}
	for(int i=1;i<=m;i++)
	{
		b+=e[i].x*e[i].r;
	}
	ans=k*e[1].x+b;
	for(int i=1;i<=m;i++)
	{
		b-=2*e[i].x*e[i].r;
		k+=2*e[i].r;
		long long now=k*e[i+1].x+b;
		if(now>0) ans=min(ans,now);
	}
	printf("%lld",ans);
	return 0;
}
```
    - **核心实现思想**：先对房子按坐标排序，初始化斜率k和截距b，通过前缀和计算第一段函数的斜率和截距，然后在循环中根据规律更新斜率和截距，计算每个区间端点的函数值并取最小值作为答案。
- **作者：BlueArc (赞：8)  星级：4星**
    - **关键亮点**：先将问题转化为经典的数轴上点到某点距离之和最小的问题，通过证明得出中位数的结论，再优化算法避免因人数过多导致的超时问题，思路连贯且有优化意识。
    - **个人心得**：通过画图分析左右两侧点的数量对移动点后距离和变化的影响，从而证明中位数的正确性，这种通过直观方式理解问题的方法值得借鉴。
    - **核心代码**：
```cpp
#include"cstdio"
#include"iostream"
#include"algorithm"
using namespace std;
typedef long long ll;
struct People
{
 ll x,r;
 bool operator <(const People& a) const{
  return x<a.x;    
 }     
}a[100005];
int main()
{
 ll len,n,tot=0;
 cin>>len>>n;
 for(int i=1;i<=n;i++)
  {cin>>a[i].x>>a[i].r;tot+=a[i].r;}
  tot=(tot+1)/2;
  sort(a+1,a+n+1);
  ll sum=0,mid,ans=0;
  for(int i=1;i<=n;i++)
  {
   sum+=a[i].r;
   if(sum>=tot) {mid=i;break;}
  }
  for(int i=1;i<=n;i++)
  {
   ans=ans+abs(a[i].x-a[mid].x)*a[i].r;
  } 
  cout<<ans;
  return 0;      
}
```
    - **核心实现思想**：先读入数据并计算总人数，求出中位数所在的位置（按人数算），对房子按坐标排序后，通过遍历找到中位数对应的房子位置，最后计算所有房子到该中位数位置房子的距离总和。

### 最优的关键思路或技巧
- **中位数思路**：通过数学证明或直观分析得出公交站建在按坐标排序且考虑人数权重后的中位数位置能使距离总和最小，这是一种高效的思维方式，避免了复杂的计算和搜索过程。
- **前缀和优化**：在计算过程中，利用前缀和来快速计算距离总和、斜率、截距等，大大降低了时间复杂度，提高了算法效率。

### 可拓展之处
同类型题或类似算法套路：此类问题属于在一维空间上的选址优化问题，类似的还有在数轴上给定多个带权点，求到这些点距离之和最小的点；或者在二维平面上给定多个带权点，求到这些点距离之和最小的点（此时可能涉及到更复杂的算法如模拟退火、三分法等）。

### 推荐题目
- **P1080 [NOIP2012 提高组] 国王游戏**：涉及贪心算法和中位数相关思想，通过对数据的排序和分析找到最优解。
- **P2672 [NOIP2015 普及组] 推销员**：同样需要考虑距离和权重等因素，通过贪心策略解决问题，与本题在思维方式上有相似之处。
- **P3957 [NOIP2017 普及组] 跳房子**：结合了动态规划和二分查找等知识，在解决问题的过程中需要对数据进行分析和优化，与本题在算法运用和思维拓展上有一定联系。 

---
处理用时：97.37秒
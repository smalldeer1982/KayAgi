# 题目信息

# SAC E#1 - 一道难题 Tree

## 题目背景

冴月麟和魏潇承是好朋友。


## 题目描述

冴月麟为了守护幻想乡，而制造了幻想乡的倒影，将真实的幻想乡封印了。任何人都无法进入真实的幻想乡了，但是她给前来救她的魏潇承留了一个线索。

她设置了一棵树（有根）。树的每一条边上具有割掉该边的代价。

魏潇承需要计算出割开这棵树的最小代价，这就是冴月麟和魏潇承约定的小秘密。

帮帮魏潇承吧。


注：所谓割开一棵有根树，就是删除若干条边，使得任何任何叶子节点和根节点不连通。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，$n\le 10$；
- 对于 $50\%$ 的数据，$n \le 1000$；
- 对于 $100\%$ 的数据，$2\le n \le 100000$，且边权是不大于 $10^6$ 的非负整数。


## 样例 #1

### 输入

```
4 1
1 2 1 
1 3 1
1 4 1```

### 输出

```
3```

## 样例 #2

### 输入

```
4 1
1 2 3
2 3 1
3 4 2```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
本题要求计算割开有根树的最小代价，使叶子节点与根节点不连通。题解主要分为树形DP和网络流（最小割最大流）两种思路：
 - **树形DP**：通过状态转移方程，从叶子节点向上递推，计算以每个节点为根的子树割边的最小代价。常见状态定义为`dp[i]`表示根节点为`i`的子树割边的价值，转移时考虑割掉当前节点与父节点的边或在子节点中选择边割掉。
 - **网络流（最小割最大流）**：将根节点作为源点，创建一个超级汇点，所有叶子节点与超级汇点连边，边权设为无穷大，将问题转化为最小割问题，通过最大流算法求解。

综合来看，树形DP思路和代码相对简单，网络流方法理解和实现相对复杂，但都是解决此类问题的有效方法。题解质量参差不齐，部分题解思路清晰、代码规范，部分题解在思路阐述或代码注释上有所欠缺。

### 所选的题解
- **作者：_louhc (5星)**
    - **关键亮点**：思路清晰简洁，直接采用DFS解决问题，代码简短且注释详细，易理解。
    - **个人心得**：无
    - **核心代码**：
```cpp
LL DFS( int x, int fa ){
    LL ans(0); bool flg(0);
    for ( int i = hd[x]; i; i = nxt[i] )
        if ( to[i]!= fa ) ans += min( DFS( to[i], x ), val[i] ), flg = 1;
    if (!flg ) return LONG_LONG_MAX;
    return ans;
}
```
    - **核心实现思想**：通过DFS遍历树，对于每个节点`x`，计算其所有子节点`to[i]`的`min(DFS(to[i], x), val[i])`之和，其中`val[i]`是`x`到`to[i]`的边权。若`x`为叶子节点，返回无穷大。最终返回根节点的DFS结果。

- **作者：mrsrz (4星)**
    - **关键亮点**：采用树形DP，状态转移方程定义明确，代码结构清晰，注释较为详细。
    - **个人心得**：无
    - **核心代码**：
```cpp
void dfs(int u,int en,int fa){
    int sum=0;
    for(int i=head[u];i;i=e[i].nxt)
    if(e[i].to!=fa){
        dfs(e[i].to,i,u);
        sum+=dp[e[i].to];
    }
    dp[u]=e[en].dis;
    if(sum&&sum<dp[u])dp[u]=sum;
}
```
    - **核心实现思想**：通过`dfs`函数进行树形DP，对于每个节点`u`，先递归计算其子节点的`dp`值并累加，然后比较割掉`u`与父节点的边的权值`e[en].dis`和子节点`dp`值之和`sum`，取较小值作为`dp[u]`。

- **作者：haooo (4星)**
    - **关键亮点**：树形DP思路清晰，对状态转移方程的解释详细，代码简洁明了，有详细注释。
    - **个人心得**：无
    - **核心代码**：
```cpp
inline void dfs(int x,int fa){
    bool judge=true;
    for(int i=head[x];i;i=nex[i]){
        int y=ver[i];
        if(y==fa)  continue;
        dfs(y,x);
        dp[x]+=min(edge[i],dp[y]);
        judge=false;
    }
    if(judge)
        dp[x]=f[x];
}
```
    - **核心实现思想**：在`dfs`函数中，遍历节点`x`的子节点，对于每个子节点`y`，递归计算`dp[y]`，并取`min(edge[i], dp[y])`累加到`dp[x]`中。若`x`为叶子节点（`judge`为`true`），则`dp[x]`设为到父节点的边权`f[x]`。

### 最优的关键思路或技巧
树形DP中，合理定义状态和状态转移方程是关键。将问题分解为以每个节点为根的子问题，通过比较割掉当前节点与父节点的边和子树内割边的代价来进行状态转移，这种自底向上的递推方式能够高效解决问题。对于网络流方法，巧妙构建网络流模型，将叶子节点连接到超级汇点，转化为标准的最小割问题，利用最大流算法求解。

### 可拓展之处
同类型题可考虑树上的其他割边、连通性问题，类似算法套路包括在树形结构上运用动态规划解决最优解问题，或通过构建网络流模型解决最小割、最大流相关问题。

### 推荐题目
 - [P2495 [SDOI2011]消耗战](https://www.luogu.com.cn/problem/P2495)：同样是树上的最小代价问题，需要运用树形DP和倍增等知识。
 - [P3376 【模板】网络最大流](https://www.luogu.com.cn/problem/P3376)：网络流的模板题，可用于巩固网络流的实现。
 - [P4016 负载平衡问题](https://www.luogu.com.cn/problem/P4016)：通过构建网络流模型解决负载平衡问题，与本题网络流思路有相似之处。

### 个人心得摘录与总结
 - **作者：chdy**：在解决问题时，不能盲目跟从题解思路，要深入思考题目本质。如本题虽看似最小割问题，但由于树结构的特殊性，增广路唯一，反向流不必要，可优化算法复杂度。这提醒在解题时要深入分析题目条件和结构特性，避免过度依赖常规解法。 

---
处理用时：62.59秒
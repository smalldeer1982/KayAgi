# 题目信息

# 偷上网

## 题目描述

Alice 和 Bob 生活在一个 $l \times l$ 的正方形房子里，由于 Bob 最近沉迷隔膜，Alice 决定要限制 Bob 上网的频率。

Alice 建造了 $n$ 个无线信号屏蔽器，第 $i$ 个位于 $(x_i, y_i)$，屏蔽范围为 $\frac{l}{n}$。

Bob 网瘾发作按捺不住上网的冲动，找到了你，帮他找到一个位置 $(x, y)$，使得没有被 Alice 的无线信号屏蔽器覆盖。

## 样例 #1

### 输入

```
1 1
0.000 0.000```

### 输出

```
0.999 0.999```

## 样例 #2

### 输入

```
1 2
1.000 1.000```

### 输出

```
GG```

## 样例 #3

### 输入

```
2 2
0.000 0.000
2.000 2.000```

### 输出

```
1.000 1.000```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是利用随机化算法来解决在正方形区域内寻找未被给定圆覆盖的点的问题。各题解的主要差异在于随机化的具体方式、判断点是否被覆盖的实现细节以及对无解情况的处理。

1. **思路与算法要点**：
    - **简单随机法**：多数题解采用在正方形区域内随机生成点，然后通过计算点到各圆心的距离，判断该点是否在某个圆内（即被屏蔽器覆盖）。如果在规定次数内找到未被覆盖的点，则输出该点；否则输出“GG”表示无解。
    - **模拟退火法**：有两篇题解使用模拟退火算法，通过不断调整随机点的位置，以一定概率接受较差解，从而更有可能找到全局最优解（即未被覆盖的点）。
2. **解决难点**：
    - **随机数生成**：包括选择合适的随机数种子以避免被出题人hack，以及使用合适的分布生成在正方形区域内的随机点。
    - **判断点是否被覆盖**：通过勾股定理计算点到圆心的距离，并与圆的半径比较。
    - **处理无解情况**：在多次随机尝试后仍未找到符合要求的点，则判定为无解。

### 题解推荐
1. **作者：Garen (赞：17) - 5星**
    - **关键亮点**：思路清晰，简洁明了地阐述了随机算法的原理和实现方法，代码可读性高。先针对\(n = 1\)的特殊情况进行枚举四个角处理，\(n \geq 2\)时采用随机算法，对随机数的生成和种子选择有详细说明。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<cstdio>
#include<cmath>
#include<cstdlib>
using namespace std;
const int maxn = 15;
double x[maxn], y[maxn];
double n, l;
int main()
{
    srand(19260817);
    scanf("%lf%lf", &n, &l);
    for(int i = 1; i <= n; i++) scanf("%lf%lf", &x[i], &y[i]);
    for(int i = 1; i <= 1000000; i++)
    {
        double tx = rand(), ty = rand();
        while(tx > l) tx /= 10;
        while(ty > l) ty /= 10;
        bool ok = true;
        for(int j = 1; j <= n; j++)
        {
            if(pow(tx - x[j], 2) + pow(ty - y[j], 2) < pow(l / n, 2))
            {
                ok = false;
                break;
            }
        }
        if(ok)
        {
            printf("%.3lf %.3lf\n", tx, ty);
            return 0;
        }
    }
    printf("GG\n");
    return 0;
}
```
    - **核心思想**：先设定随机种子，循环生成随机点并调整到正方形区域内，对每个随机点检查是否被任何圆覆盖，若未被覆盖则输出该点，尝试一定次数后仍未找到则输出“GG”。

2. **作者：Link_Space (赞：5) - 4星**
    - **关键亮点**：使用模拟退火算法解决问题，对模拟退火算法在本题中的应用有清晰的阐述，特别是对`calc`函数和`SA`函数的实现和作用解释详细，代码注释丰富。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<ctime>
#include<cstdlib>
using namespace std;
const int N = 1e5 + 5;
struct Node{
    double x, y;
} pos[N], ans, result;
double n, l;
bool calc(Node now)
{
    double xx = now.x, yy = now.y;
    for (int i = 1; i <= n;i++)
    {
        double dx = xx - pos[i].x;
        double dy = yy - pos[i].y;
        if(sqrt(dx*dx+dy*dy)<=(double)l/n)
            return false;
    }
    return true;
}
void SA()
{
    for (double t = l; t > 1e-15;t*=0.9975)
    {
        Node now;
        now.x = fmod(ans.x + fabs(((double)2 * rand() - RAND_MAX) * t), l);
        now.y = fmod(ans.y + fabs(((double)2 * rand() - RAND_MAX) * t), l);
        if(calc(now))
        {
            result = now;
            ans = now;
        }
        else 
        {
            if((double)rand()/RAND_MAX<0.5)
                ans = now;
        }
    }
}
int main()
{
    scanf("%lf%lf", &n, &l);
    for (int i = 1; i <= n;i++)
    {
        scanf("%lf%lf", &pos[i].x, &pos[i].y);
        ans.x += pos[i].x, ans.y += pos[i].y;
    }
    ans.x /= n;
    ans.y /= n;
    while((double)clock()/CLOCKS_PER_SEC<0.8)
        SA();
    if (!calc(result))
        puts("GG");
    else
        printf("%.3lf %.3lf\n", result.x, result.y);
}
```
    - **核心思想**：`calc`函数判断点是否满足条件，`SA`函数通过模拟退火不断调整点的位置，以一定概率接受较差解，在卡时内寻找符合要求的点，最后根据结果输出相应信息。

3. **作者：su226 (赞：3) - 4星**
    - **关键亮点**：详细介绍了C++11的`chrono`、`random`和`iomanip`标准库的使用方法，代码利用这些库实现随机数生成和格式化输出，具有学习价值。
    - **个人心得**：无
    - **核心代码**：
```cpp
// cin/cout
#include <iostream>
// 特色头文件
#include <chrono>
#include <random>
#include <iomanip>
// sqrt
#include <cmath>
using namespace std;
using namespace std::chrono;
double ax[10], ay[10];
inline double pow2(const double& a) {
  return a * a;
}
inline double dis(const double& x, const double& y, const int& i) {
  return sqrt(pow2(ax[i] - x) + pow2(ay[i] - y));
}
int main() {
  default_random_engine rnd(steady_clock::now().time_since_epoch().count());
  int n, l;
  double lim;
  cin >> n >> l;
  lim = 1.0 * l / n + 0.000001;
  uniform_real_distribution<double> uni(0, l);
  for (int i = 0; i < n; i++) {
    cin >> ax[i] >> ay[i];
  }
  for (int i = 0; i < 10000; i++) {
    double x = uni(rnd), y = uni(rnd);
    bool flag = true;
    for (int j = 0; j < n; j++) {
      if (dis(x, y, j) < lim) {
        flag = false;
      }
    }
    if (flag) {
      cout << fixed << setprecision(3) << x << ' ' << y;
      return 0;
    }
  }
  cout << "GG";
  return 0;
}
```
    - **核心思想**：利用`chrono`库获取随机数种子初始化`default_random_engine`，`uniform_real_distribution`生成正方形区域内的随机点，通过`dis`函数计算点到圆心距离判断是否被覆盖，找到未覆盖点则格式化输出，否则输出“GG”。

### 最优关键思路或技巧
随机化算法是解决此类寻找可行解问题的有效方法，其优点在于实现简单且在一定次数的尝试后有较大概率找到解。在实现过程中，合理选择随机数种子、生成符合要求的随机点以及高效判断点是否满足条件是关键。对于模拟退火算法，它通过以一定概率接受较差解，能在更复杂的空间中搜索到全局最优解，适用于一些普通随机化较难解决的情况。

### 可拓展思路
此类问题属于在给定约束条件下寻找可行解的范畴，相似的算法套路可应用于如在多边形区域内寻找未被多个圆形或多边形覆盖的点、在满足某些条件的图中寻找特定节点等问题。

### 相似知识点洛谷题目推荐
1. **P1652 圆**：涉及圆与点的位置关系判断，与本题判断点是否在圆内的知识点相似。
2. **P2313 汤姆的游戏**：同样需要根据给定的圆的信息，判断点与圆的位置关系，与本题核心判断逻辑一致。
3. **P3817 小A的糖果**：虽然场景不同，但也运用到随机化思想来解决问题，可加深对随机算法的理解。

### 个人心得摘录与总结
1. **作者：破壁人五号**：做题时因某些细节未AC，发现错因后意识到问题。该心得强调了做题时注意细节的重要性。
2. **作者：Leap_Frog**：做本题时开始忘记考虑无解情况导致TLE，之后发现随机种子对结果有影响，换用他人的随机种子后AC，说明在随机算法中随机种子的选择不容忽视。 

---
处理用时：100.28秒
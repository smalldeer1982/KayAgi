# 题目信息

# 「化学」相对分子质量

## 题目描述

做化学题时，小 F 总是里算错相对分子质量，这让他非常苦恼。

小 F 找到了你，请你来帮他算一算给定物质的相对分子质量。

如果你没有学过相关内容也没有关系，你可以从样例和提示里理解该题所求内容。

## 说明/提示

### 样例解释
金 $Au : 197$

二氧化铪 $HfO_{2}: 178.5 + 2 \times 16= 210.5$

氢氧化钙（熟石灰）$Ca(OH)_2 : 40 + (1 + 16) \times 2 = 74$

五水硫酸铜（胆矾）$CuSO_4 \cdot 5H_2O: 64 + 32 + 16 \times 4 + 5 \times (1 \times 2 + 16) = 250$

十二水合硫酸铝钾（明矾）$KAl(SO_{4})_{2} \cdot 12H_{2}O$ （嗯 用心感受 $474$ 是对的）

### 附表：可能用到的相对原子质量

|元素|相对原子质量|
|:-:|:-:|
|H|1|
|C|12|
|N|14|
|O|16|
|F|19|
|Na|23|
|Mg|24|
|Al|27|
|Si|28|
|P|31|
|S|32|
|Cl|35.5|
|K|39|
|Ca|40|
|Mn|55|
|Fe|56|
|Cu|64|
|Zn|65|
|Ag|108|
|I|127|
|Ba|137|
|Hf|178.5|
|Pt|195|
|Au|197|
|Hg|201|

### 提示

如果你没有学习过相关内容，下面的内容可能有帮助：

> zcy 教你算相对分子质量

1. 每个元素以大写开头；
2. 计算分子质量的方法就是对每个原子出现的次数乘对应的相对原子质量求和；
3. ~( $\cdot$ ) 相当于加；
4. 下标相当于乘。

## 样例 #1

### 输入

```
Au```

### 输出

```
197```

## 样例 #2

### 输入

```
HfO_{2}```

### 输出

```
210.5```

## 样例 #3

### 输入

```
Ca(OH)_{2}```

### 输出

```
74```

## 样例 #4

### 输入

```
CuSO_{4}~5H_{2}O```

### 输出

```
250```

## 样例 #5

### 输入

```
KAl(SO_{4})_{2}~12H_{2}O```

### 输出

```
474```

# AI分析结果

这道题主要是通过模拟化学物质相对分子质量的计算过程，涉及字符串处理和基本数学运算。各题解思路大致相同，都是对输入字符串按字符或子串进行扫描处理，根据不同字符类型（元素、下标、括号、水合物标识等）计算相对分子质量。

### 思路与算法要点
1. **打表存储元素质量**：多数题解使用`map`容器（少数用数组）存储元素及其相对原子质量，方便查询。
2. **扫描字符串**：从左到右扫描输入字符串，根据字符类型分别处理。
    - **元素**：识别大写字母开头的元素，可能跟小写字母组成双字母元素，查询表获取质量。
    - **下标**：遇到`_`后提取大括号内数字作为下标，乘以前面元素或原子团质量。
    - **括号**：处理括号内原子团，递归（或类似递归逻辑）计算其质量，再考虑括号外下标。
    - **水合物**：遇到`~`，计算后面水的系数（无系数默认为1），乘以水的相对分子质量（18）加到总质量。
3. **计算输出**：累加各部分质量得到相对分子质量，根据结果是否含小数决定输出格式。

### 解决难点
 - **括号处理**：部分题解采用递归处理括号内表达式，部分通过记录状态和临时变量处理，确保括号内原子团质量正确计算及与外部下标结合。
 - **下标提取**：准确识别`_`后的数字并转换为整数，与对应元素或原子团质量相乘。
 - **水合物系数**：注意水合物系数可能省略，需默认为1处理。

### 题解评分
1. **作者Iowa_BattleShip**：4星
    - **关键亮点**：思路清晰，代码结构良好。通过自定义函数`cs`和`js`分别处理数字转换和元素质量计算，主函数逻辑简洁明了。对各种情况分类处理，注释详细。
    - **个人心得**：认为题目难度不大，无括号嵌套降低难度，直接扫一遍字符串即可。
    ```cpp
    int cs(int &i) {
        int x = 0;
        for (; a[i] >= '0' && a[i] <= '9'; i++)
            x = x * 10 + (a[i] - '0');
        return x;
    }
    double js(int &i) {
        double s = 0;
        memset(b, 0, sizeof(b));
        for (ll = -1; ((a[i] >= 'A' && a[i] <= 'Z') || (a[i] >= 'a' && a[i] <= 'z')) && (ll < 0 || (ll >= 0 && (a[i] >= 'a' && a[i] <= 'z'))); i++)
            b[++ll] = a[i];
        if (a[i] == '_') {
            i += 2;
            s += mp[b] * cs(i);
        }
        else {
            s += mp[b];
            i--;
        }
        return s;
    }
    ```
2. **作者一扶苏一**：4星
    - **关键亮点**：详细分析各种情况及处理方法，使用栈和数组分别保存元素分子量和下标，逻辑清晰。对字符串读入、元素判断、下标处理、原子团处理等步骤讲解详细。
    - **个人心得**：强调浮点数运算注意事项，以及`STL`中`string`拼接和清零操作。
    ```cpp
    inline void newlet(int l, int r) {
        std::string temp;
        temp.clear();
        if (l ^ r) {
            temp += str[l]; temp += str[r];
        }
        else temp += str[l];
        a[++top] = che[temp];
    }
    inline int getnum(int k) {
        int t = k + 2, temp = 0;;
        while (str[t] >= '0' && str[t] <= '9') temp = (temp << 3) + (temp << 1) + (str[t] ^ 48), ++t;
        if (!temp) temp = 1;
        b[top] = temp;
        return t;
    }
    inline int getset(int k) {
        double temp = 0; std::string t; int p = 1;
        for (int i = k + 1; i; ++i) {
            t.clear();
            if (str[i] == ')') {
                a[++top] = temp; return i;
            }
            if (str[i + 1] >= 'a' && str[i + 1] <= 'z') {
                t += str[i]; t += str[i + 1]; ++i;
            }
            else t += str[i];
            if (str[i + 1] == '_') {
                int te = i + 3, tem = 0;
                while (str[te] >= '0' && str[te] <= '9') tem = (tem << 3) + (tem << 1) + (str[te] ^ 48), ++te;
                if (!tem) tem = 1;
                p = tem; i = te;
            }
            temp += che[t] * p; p = 1;
        }
    }
    ```
3. **作者info___tion**：4星
    - **关键亮点**：采用递归方式处理字符串，逻辑直观清晰。对不同字符情况（元素、括号、水合物）分类讨论，代码结构紧凑，注释详细。
    - **个人心得**：认为递归方式比循环直观性高，出错可能性小。
    ```cpp
    double solve(string s) {
        double ret = 0.0;
        int cur = 0;
        while (cur < s.size()) {
            if (isupper(s[cur])) {
                string tmp;
                tmp += s[cur];
                int p = cur + 1;
                while (islower(s[p])) tmp += s[p], p++;
                double base = col(tmp);
                if (s[p] == '_') {
                    p += 2;
                    int num = 0;
                    while (isdigit(s[p])) num = num * 10 + s[p] - '0', p++;
                    p++;
                    ret += base * num;
                }
                else ret += base;
                cur = p;
            }
            else if (s[cur] == '(') {
                int p = ++cur;
                while (s[p]!= ')') p++;
                double base = solve(s.substr(cur, p - cur));
                p++;
                if (s[p] == '_') {
                    p += 2;
                    int num = 0;
                    while (isdigit(s[p])) num = num * 10 + s[p] - '0', p++;
                    p++;
                    ret += base * num;
                }
                else ret += base;
                cur = p;
            }
            else if (s[cur] == '~') {
                int p = cur + 1;
                int num = 0;
                while (isdigit(s[p])) num = num * 10 + s[p] - '0', p++;
                if (!num) num = 1;
                ret += H_2O * num;
                break;
            }
        }
        return ret;
    }
    ```

### 最优关键思路或技巧
 - **使用`map`存储元素质量**：方便快速查询元素相对原子质量，代码简洁易读。
 - **递归处理括号**：对于括号内表达式计算，递归方式逻辑清晰，易于理解和实现，避免复杂状态记录。
 - **模块化编程**：将不同功能（如数字提取、元素质量计算）封装成函数，使主函数逻辑简洁，提高代码可读性和维护性。

### 可拓展之处
此类题目属于字符串模拟计算类型，类似套路包括处理数学表达式（如四则运算表达式求值）、特定格式文本解析等。关键在于根据给定规则，对字符串按字符或子串扫描处理，结合数据结构存储中间结果，完成计算或解析。

### 相似知识点洛谷题目
 - [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：字符串处理，按规则对字符串操作。
 - [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)：涉及字符串查找、计数，与本题字符串处理类似。
 - [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)：虽为树形动态规划，但包含对树结构按规则处理，与本题按规则处理字符串结构有相似思维方式。 

---
处理用时：104.03秒
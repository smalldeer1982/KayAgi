# 题目信息

# 「生物」能量流动

## 题目描述

生物课上，小 F 学习到了食物链、食物网的相关内容。

他学到，能量是逐级递减的。比如在食物链上，两个链接起来的生物 $A \rightarrow B$（意思是 $B$ 吃 $A$）之间的能量传递效率最多只有 $\frac 1 5$；而研究种间关系，能够使能量流向对人类最有益的部分。

现在，小 F 想研究一下能量流动的关系，于是他在脑海里创造了一个生态的系统。

在这个生态的系统里，有 $n+2$ 种生物，其中 $0$ 是生产者，整个生态系统所流经的能量由它固定；你是贪婪的顶级掠食者 $n + 1$，可以捕食所有生物；其他的掠食者 $[1, n]$ 各有各的喜好，只会捕食编号在 $[0, r_i]$ 的生物。由于天然形成的强弱顺序，上述关系满足 $r_i \leq r_{i + 1}(1 \leq i < n),$ $r_i < i(1 \leq i \leq n)$。

每种动物需要摄取至少 $a_i$ 单位能量才能存活；一个生物摄取到的能量可以传递给捕食者，但传递效率都不超过 $\frac 1 5$。也就是说，假设该动物捕获了 $b_i$ 单位的能量，所有捕食它的掠食者得到的能量总和 $c_i$，那么有：
* $b_i \geq a_i$
* $c_i \leq \frac 1 5 b_i$

你希望知道，在所有生物都存活的情况下，在最优情况下你能获取到的最大能量是多少。

## 说明/提示

### 样例 1 解释

最优情况下：
* 1 号掠食者捕食生产者 0，捕食 5 点能量，传递效率为 $\frac 1 5$，得到 1 点能量。
* 2 号掠食者捕食生产者 0，捕食 4 点能量，传递效率为 $\frac 1 5$，得到 0.8 点能量。
* 2 号掠食者捕食掠食者 1，捕食 1 点能量，传递效率为 $\frac 1 5$，得到 0.2 点能量。

可怜的你只能捕获 2 号掠食者的能量，捕食 1 点能量，得到 0.2 点能量。

### 样例 2, 3 解释

由于 2 号掠食者开始减肥不吃肉了（也有可能是打不过 1 了），所以所需的生产者能量从 9 点变成了 10 点。

### 子任务

子任务 $1(21 \mathrm{pts}) : n \leq 100$；

子任务 $2(89 \mathrm{pts}) : n \leq 10 ^ 5$。

## 样例 #1

### 输入

```
2 9
1 0
1 1```

### 输出

```
0.2000000```

## 样例 #2

### 输入

```
2 9
1 0
1 0```

### 输出

```
-1```

## 样例 #3

### 输入

```
2 10
1 0
1 0```

### 输出

```
0.4000000```

# AI分析结果

### 综合分析与结论
这些题解均围绕该能量流动问题的贪心解法展开。思路核心是让每个生物尽量从等级低的生物获取能量，以减少能量传递损耗，使顶级掠食者获得最多能量。
1. **思路**：多数题解利用\(r_i \leq r_{i + 1}\)这一性质，从前向后处理每个生物的能量获取。
2. **算法要点**：维护生物能量状态，按规则分配能量并判断是否满足所有生物生存，最后计算顶级掠食者所得能量。
3. **解决难点**：如何在满足各生物能量需求前提下，使能量传递损耗最小。多数题解通过贪心策略，让生物优先捕食能量低的猎物解决该问题。同时，部分题解利用数据结构优化查找和计算过程。

### 所选的题解
#### 作者：caidd (5星)
 - **关键亮点**：思路清晰，贪心策略明确，利用`vis`数组记录已为零能量的低等级生物标号，优化查找过程。代码实现简洁，有详细注释且使用位运算快读提升效率。
 - **个人心得**：比赛时写出8ms程序，认为速度较慢，可看出对效率有追求。
 - **核心代码**：
```cpp
int main()
{
    n=read();a=read();d[0]=a;
    for(R int i=1;i<=n;++i)
    {
        k=read(),d[i]=k,r=read();
        for(int j=vis/*vis记录最小*/;j<=r;++j)
        {
            if(!d[j]) vis=j;
            if(d[j]*0.2>=k) {d[j]=(d[j]-(k*5));k=0;break;}
            else k=(k-d[j]*0.2),d[j]=0;
        }
        if(k>0) {cout<<"-1"<<endl;return 0;}
    }
    for(int i=vis;i<=n;++i) sum+=d[i]*0.2;
    printf("%lf\n",sum);
    return 0;
}
```
 - **核心思想**：从生产者开始，对每个生物，从`vis`开始遍历其可捕食生物，若当前生物能量能满足需求则扣除相应能量，否则消耗完当前生物能量并更新`vis`，若最终需求未满足则输出 -1，最后累加剩余生物能量的0.2倍作为答案。

#### 作者：qqvq (4星)
 - **关键亮点**：利用前缀和`pre`与指针`last`优化计算，代码简洁高效。利用题目中\(r_i\)的单调性，在更新前缀和时减少不必要计算。
 - **核心代码**：
```cpp
int main() {
    scanf("%d %lld", &n, &pre);
    for(int i = 1; i <= n; ++i) {
        scanf("%d %d", a+i, &b);
        for(j = last+1; j <= b; ++j) pre+=a[j]; last = j-1;
        pre -= a[i] * 5; 
        if (pre < 0) return puts("-1"), 0;
    }
    for(int i = last+1; i <= n; ++i) pre += a[i];
    printf("%lf", pre/5.0);
    return 0;
}
```
 - **核心思想**：遍历每个生物，通过指针`last`确定新增可捕食生物范围并更新前缀和`pre`，扣除当前生物所需能量的5倍，若`pre`小于0则输出 -1，最后加上剩余生物能量并除以5输出答案。

#### 作者：star_magic_young (4星)
 - **关键亮点**：利用\(r_i\)单调性，通过简单变量维护能量总和，以\(O(n)\)时间复杂度解决问题，代码简洁易懂。
 - **核心代码**：
```cpp
int main()
{
    n=rd();
    a+=rd();
    int p=1;
    for(int h=1;h<=n;h++)
    {
        int x=rd(),y=rd();
        while(p<=y) a+=b[p++];
        if(a/5-(double)x<-eps) {p=-1;break;}
        a-=x*5;
        b[h]=x;
    }
    if(p<0) puts("-1");
    else
    {
        for(;p<=n;p++) a+=b[p];
        printf("%.9lf\n",a/5);
    }
    return 0;
}
```
 - **核心思想**：遍历每个生物，将其可捕食范围内新增生物能量累加到`a`，判断`a`的1/5是否满足当前生物需求，不满足则标记无解，满足则扣除相应能量，最后处理剩余生物能量并输出答案。

### 最优关键思路或技巧
1. **贪心策略**：让每个生物优先从低等级生物获取能量，减少能量传递损耗。
2. **利用单调性**：借助\(r_i \leq r_{i + 1}\)性质，通过维护指针、前缀和等方式优化计算，减少不必要遍历。

### 可拓展思路
此类题目属于贪心策略结合特定条件优化的问题。类似套路是利用题目给定的有序性或其他限制条件，简化状态维护与计算过程。同类型题常涉及资源分配、任务调度等场景，需在满足一定条件下最大化或最小化某个目标。

### 相似知识点洛谷题目
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：考查贪心策略，根据数据特点合理分组以满足题目要求。
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：通过贪心思想对任务进行排序，以优化总等待时间。
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)：利用贪心解决区间覆盖问题，与本题利用单调性优化思路类似。 

---
处理用时：54.75秒
# 题目信息

# [1007] Scarlet的字符串不可能这么可爱

## 题目描述

Scarlet妄图构造字符集为$k$，长度为$L$的字符串，满足没有任何一个长度超过$1$的回文连续子串。

看起来这样的字符串太多了，Scarlet随手加了个限制：她指定了字符串的第$s$位为$w$。

这下Scarlet不会做了，请你来帮她计算究竟有多少满足条件的字符串。按照套路，你只要求出答案对$p$取模后的结果。

## 说明/提示

字符集：一个字符串中不同字符的数量。例如，字符集是3的话，你可以认为字符串仅由“A”、“B”、“C”三个字母组成。

样例解释：第一个字符固定A，那么符合要求的字符串是ABC,ACB。而AAB字符串包括AA这个回文子串，ACA本身就是回文串，一次类推。

对于50%的数据，$k\leq5,L\leq10$

对于另30%的数据，$s=0$

对于100%的数据$1\leq k,L\leq 10^{18},0\leq s\leq L,1\leq w\leq k,1\leq p\leq 10^9$


## 样例 #1

### 输入

```
3 3 233
1 1```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：这些题解思路大致相同，均先分析无限制条件下的情况，通过乘法原理得出方案数公式 \(k\times(k - 1)\times(k - 2)^{L - 2}\) ，即第一位 \(k\) 种选择，第二位 \(k - 1\) 种选择，从第三位起均为 \(k - 2\) 种选择。对于有限制条件，多数题解认为指定字符位置和值不影响本质，将无限制情况答案除以 \(k\) 或通过分类讨论、逆向构造字符串等方式得出方案数为 \((k - 1)\times(k - 2)^{L - 2}\) 。所有题解都意识到要用快速幂解决幂运算，并强调对 \(k\) 提前取模防止数据过大。整体质量差异主要在思路阐述清晰度、代码可读性等方面。

所选的题解：
  - 作者：VenusM1nT (5星)
    - 关键亮点：思路清晰，先说明指定字符位置和值无用，然后分别推导无限制和有限制情况的公式，结合具体例子，易于理解，代码实现完整且注释详细。
    - 重点代码：
```cpp
ll poww(ll a,ll b)//快速幂
{
    ll sum=1;
    a%=Mod;
    while(b!=0)
	{
        if(b&1!=0) sum=sum*a%Mod;
        b=b >> 1;
        a=a*a%Mod;
	}
    return sum;
}
int main()
{
	scanf("%lld %lld %lld %lld %lld",&k,&l,&Mod,&s,&w);
	k%=Mod;//先膜为敬
	if(l==1)//特判特殊情况
	{
		if(s) printf("1");
		else printf("%lld",k);
	}
	if(s) ans=ans*(k-1)%Mod;
	else ans=ans*k*(k-1)%Mod;//根据有没有指定字符进行分别计算
	k-=2;
	ans=(ans*poww(k,l-2))%Mod;
	printf("%lld",ans);//输出答案
	return 0;
}
```
核心实现思想：快速幂函数 `poww` 实现高效幂运算，在 `main` 函数中先对 \(k\) 取模，根据 \(l\) 是否为1进行特判，再依据有无指定字符计算答案，最后用快速幂计算并输出结果。
  - 作者：WYXkk (4星)
    - 关键亮点：先明确无回文连续子串等价于任意两个相邻或间隔一个字符的字符不相等，清晰推导无限制和有限制情况的公式，表述简洁明了。
  - 作者：Y_B_Y (4星)
    - 关键亮点：详细地逐步构造字符串来推导无限制情况公式，对于有限制情况，通过从指定字符左右两边分别构造字符串得出公式，思路独特且清晰，代码注释详细。
    - 重点代码：
```cpp
ll qpow(ll x,ll y,ll z)//(x^{y})%z,快速幂
{
	ll s=1;
	x%=z;
    while(y>0)
    {
      if(y%2) s=s*x%z;
      x=x*x%z;
      y>>=1;
    }
    return s%z; 
}
int main()
{
	cin>>k>>n>>p>>s>>w;
	k%=p;
	if(n==1) return s? printf("%lld",1%p),0:printf("%lld",k%p),0;
	ll ans=(k-1)%p;
	if(!s) ans=(ans*k)%p;
	ans=(ans*qpow(k-2,n-2,p))%p;
	return printf("%lld",ans),0;
}
```
核心实现思想：`qpow` 函数实现快速幂，在 `main` 函数中先对 \(k\) 取模，对 \(n = 1\) 进行特判，根据有无指定字符确定初始答案，再结合快速幂计算并输出最终结果。

最优关键思路或技巧：利用乘法原理，通过分析每个位置字符选择的限制来确定方案数公式，使用快速幂优化幂运算时间复杂度，提前对 \(k\) 取模防止数据溢出。

可拓展之处：此类题目属于组合数学中的字符串构造计数问题，类似套路是先分析无限制情况，再考虑限制条件对结果的影响。同类型题可关注涉及特定字符串性质（如无重复子串、无回文子串等）的计数问题。

推荐题目：
 - [P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226)
 - [P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)
 - [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)

个人心得：
  - 作者lgswdn_SA提到被状压标签吸引进来，发现是结论题，意识到不能仅看标签解题。同时强调 \(k\) 取模后若小于2要加回 \(2\) ，否则会出错。总结了要注意题目数据特点，不能被标签误导，同时要关注取模细节。 

---
处理用时：57.03秒
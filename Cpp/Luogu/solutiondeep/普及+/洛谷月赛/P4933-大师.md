# 题目信息

# 大师

## 题目背景

建筑大师最近在跟着数学大师 ljt12138 学数学，今天他学了等差数列，ljt12138 决定给他留一道练习题。

## 题目描述

ljt12138 首先建了 $n$ 个特斯拉电磁塔，这些电塔排成一排，从左到右依次标号为 $1$ 到 $n$，第 $i$ 个电塔的高度为 $h[i]$。

建筑大师需要从中选出一些电塔，然后这些电塔就会缩到地下去。这时候，如果留在地上的电塔的高度，从左向右构成了一个等差数列，那么这个选择方案就会被认为是美观的。

建筑大师需要求出，一共有多少种美观的选择方案，答案模 $998244353$。

注意，如果地上只留了一个或者两个电塔，那么这种方案也是美观的。地上没有电塔的方案被认为是不美观的。

同时也要注意，等差数列的公差也可以为负数。

## 说明/提示

设 $v$ 为最高的电塔高度。

对于前 $30\%$ 的数据，$n \le 20 $。

对于前 $60\%$ 的数据，$n \le 100$，$v \le 2 \times 10^3$。

对于另外 $20\%$ 的数据，所有电塔的高度构成一个等差数列。

对于 $100\%$ 的数据，$n \le 10^3$，$v \leq2 \times 10^4$。

## 样例 #1

### 输入

```
8
13 14 6 20 27 34 34 41 
```

### 输出

```
50
```

## 样例 #2

### 输入

```
100
90 1004 171 99 1835 108 81 117 141 126 135 144 81 153 193 81 962 162 1493 171 1780 864 297 180 532 1781 189 1059 198 333 1593 824 207 1877 216 270 225 1131 336 1875 362 234 81 288 1550 243 463 1755 252 406 261 270 279 288 1393 261 1263 297 135 333 872 234 881 180 198 81 225 306 180 90 315 81 81 198 252 81 297 1336 1140 1238 81 198 297 661 81 1372 469 1132 81 126 324 333 342 81 351 481 279 1770 1225 549 
```

### 输出

```
11153
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效求解给定数组中构成等差数列的非空子序列个数这一问题。大部分题解采用动态规划（DP）方法，通过合理设计状态表示和状态转移方程来解决问题。主要差异在于状态设计、转移方式以及对公差处理的优化。

### 所选的题解
- **作者：chengni (5星)**
    - **关键亮点**：思路清晰，直接采用二维数组 `f[i][j]` 表示以 `i` 结尾公差为 `j` 的等差数列个数，通过枚举第 `i` 个数前面的数来确定公差并进行转移，时间复杂度优化到 $O(n^2)$，代码简洁明了。
    - **重点代码**：
```cpp
int p = 20000;
for(int i = 1; i <= n; i++){
    ans++;
    for(int j = i - 1; j; j--){
        f[i][a[i] - a[j] + p] += f[j][a[i] - a[j] + p] + 1;
        f[i][a[i] - a[j] + p] %= mod;
        ans += f[j][a[i] - a[j] + p] + 1;
        ans %= mod;
    }
}
```
    - **核心实现思想**：外层循环遍历每个数作为结尾，内层循环枚举其前面的数，根据两数差值确定公差并更新对应状态的等差数列个数，同时更新答案。

- **作者：__stdcall (4星)**
    - **关键亮点**：对不同数据范围给出了相应的解法思路，从暴力枚举到DP优化，逐步引导解题方向，具有很好的学习参考价值。
    - **重点代码（100分部分）**：
```cpp
// 状态转移部分
f(i) = g(h_i - d);
g(h_i) = g(h_i) + f(i);
```
    - **核心实现思想**：在60分DP算法基础上，通过维护数组 `g` 来记录特定高度的DP值之和，从而优化转移过程，将时间复杂度降为 $O(nv)$。

- **作者：Ivystorm (4星)**
    - **关键亮点**：同样采用二维DP，通过从两个数得到公差而非枚举公差来优化，去除了标准60分题解中的一层循环，时间复杂度为 $O(n^2)$，代码实现中对边界处理清晰。
    - **重点代码**：
```cpp
void getx(int nowi){
    for(int i = nowi - 1; i >= 1; i--){
        if(!vis[i][num[i] - num[nowi] + 20200]){
            f[i][num[i] - num[nowi] + 20200]++;
            vis[i][num[i] - num[nowi] + 20200] = 1;
        }
        ans = (long long)(ans + f[i][num[i] - num[nowi] + 20200]) % 998244353;
        f[nowi][num[i] - num[nowi] + 20200] = (long long)(f[nowi][num[i] - num[nowi] + 20200] + f[i][num[i] - num[nowi] + 20200]) % 998244353;
    }
}
```
    - **核心实现思想**：在 `getx` 函数中，对当前数 `nowi`，枚举其前面的数 `i`，根据两数差值更新对应公差的数列长度和答案，并标记已更新的状态。

### 最优关键思路或技巧
- **状态设计**：利用二维数组表示以某个位置结尾且具有特定公差的等差数列个数，能有效记录和更新状态。
- **公差处理**：通过枚举两个数的差值确定公差，避免直接枚举所有可能公差带来的高复杂度。
- **优化转移**：如维护辅助数组记录特定高度的DP值之和，减少转移时间复杂度。

### 可拓展之处
同类型题常考察对数列性质的理解和动态规划的应用，类似套路包括合理设计状态表示以适应不同条件，以及优化状态转移以降低时间复杂度。例如，在一些序列问题中，可根据序列特点（如单调性、周期性等）设计状态，利用前缀和、哈希表等数据结构优化转移。

### 推荐洛谷题目
- [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)：考察动态规划在序列问题中的应用，与本题类似，需合理设计状态和转移方程。
- [P1140 相似基因](https://www.luogu.com.cn/problem/P1140)：同样是序列相关的动态规划题目，通过设计合适的状态和代价函数来求解。
- [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)：涉及最长不上升子序列和最长上升子序列的求解，与本题在序列分析和动态规划应用上有相似之处。

### 个人心得摘录与总结
- **作者：zrzluck99**：强调了对状态转移方程理解和实现的重要性，特别是在处理公差重复时，`f` 数组计算需叠加以及 `s` 数组直接加上转移值的细节。总结为在状态转移实现过程中，要深入理解状态之间的关系，准确处理重复情况。 

---
处理用时：62.99秒
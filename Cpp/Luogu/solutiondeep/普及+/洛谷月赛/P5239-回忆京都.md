# 题目信息

# 回忆京都

## 题目背景

第十五届东方人气投票 音乐部门 106名 

第四次国内不知道东方的人对东方原曲的投票调查 51名

回忆京都副歌我tm吹爆，东方文花帖我tm吹爆！

## 题目描述

射命丸文在取材中发现了一个好玩的东西，叫做组合数。

组合数的定义如下：从$n$个不同元素中，任取$m(m \leq n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合。所有组合的数量，就是组合数。

组合数的计算公式如下：$C^m_n=\dfrac{n!}{m! \times (n-m)!}$，其中保证$m \leq n$，表示在$n$个元素中选出$m$个元素的组合数。

为了方便理解，举一个例子：在th16.5秘封噩梦日记的第三周目中，每一天的战斗都有$4$个角色两两组合出场，那么很显然就有$C^2_4=6$种组合方式。

关于这方面的更详细解释，请看样例说明。

由于她对新事物都存在着好奇，因此她想要知道$C^m_n$是多少。这对她来说是个很简单的事情，因此她看了一眼就秒了，因此她决定求出下列式子：

$\sum_{i=1}^n \sum_{j=1}^m C^i_j$，其中当$i>j$的时候，钦定$C^i_j$为$0$

她也很快就算出来了，不过对自己的答案不是很充满信心，因此你决定帮助她。然而没事找事的她一下子算了$q$次对于不同的$n,m$的结果，因此这只能劳烦你了。由于你不打算真正地帮助她，你无需把答案对$998244353$取模，也无需对$64123$取模，只要告诉她对$19260817$取模之后的答案即可。

## 说明/提示

![](https://i.loli.net/2018/12/15/5c148dbe83f11.jpg)

关于组合数的样例说明。

例如有蕾米莉亚 芙兰朵露 圣白莲 丰聪耳神子在这一天组合出场，会有六种情况：

1、蕾米莉亚x芙兰朵露 $\text{\color{white}背德组}$

2、丰聪耳神子x圣白莲 $\text{\color{white}宗教组}$

3、蕾米莉亚x丰聪耳神子

4、芙兰朵露x丰聪耳神子

5、蕾米莉亚x圣白莲

6、芙兰朵露x圣白莲

## 样例 #1

### 输入

```
5
2 3
1 4
4 3
2 5
3 5```

### 输出

```
10
10
11
35
50```

# AI分析结果

### 综合分析与结论
这些题解主要围绕计算组合数的和$\sum_{i = 1}^n \sum_{j = 1}^m C^i_j$展开，多数题解采用杨辉三角结合二维前缀和的方法来优化计算。不同题解在思路阐述、代码实现和优化程度上存在差异。

### 所选的题解
- **作者：Social_Zhao（5星）**
    - **关键亮点**：通过打表观察出递推公式$ans[i][j]=ans[i - 1][j - 1]+ans[i - 1][j]+i$，并详细推导了该递推式的来源，代码简洁高效。
    - **个人心得**：通过暴力打表找规律得出递推式，后经大佬解释获得递推式的推导方法。
    - **核心代码**：
```cpp
#include<iostream>
using namespace std;
int ans[1005][1005],q,n,m;
int main() {
    for(int i = 1; i <= 1000; i++)
        for(int j = 1; j <= 1000; j++) {
            ans[i][j]=(ans[i - 1][j - 1]+ans[i - 1][j]+i)%19260817;
        }
    cin>>q;
    while(q--) {
        cin>>n>>m;
        cout<<ans[m][n]<<endl;
    }
    return 0;
}
```
    - **核心思想**：利用递推公式$ans[i][j]=ans[i - 1][j - 1]+ans[i - 1][j]+i$，对所有可能的$i$和$j$进行递推计算，预处理出结果，最后根据输入的$n$和$m$直接输出对应的$ans[m][n]$。

- **作者：xcxc82（4星）**
    - **关键亮点**：先详细介绍了组合数的多个基本恒等式，如对称恒等式、吸收恒等式、加法公式等，再利用加法公式结合二维前缀和解决问题，思路清晰，对组合数知识讲解全面。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long mo = 19260817;
int n,a[1005][1005];
int sum[1005][1005];
int main() {
    a[0][0]=1;
    for(int i = 1; i <= 1002; i++) {
        for(int j = 1; j <= 1002; j++) {
            a[i][0]=a[i][i]=1;
            a[i][j]=(a[i - 1][j]+a[i - 1][j - 1])%mo;
        }
    }
    for (int i = 1; i <= 1002; i++)
        for (int j = 1; j <= 1002; j++) {
            sum[i][j]=(sum[i - 1][j]+sum[i][j - 1]+a[i][j]-sum[i - 1][j - 1]+mo)%mo;
        }
    cin>>n;
    for(int i = 1; i <= n; i++) {
        int l,r;
        cin>>l>>r;
        cout<<sum[r][l]<<endl;
    }
    return 0;
}
```
    - **核心思想**：首先利用杨辉三角的递推式$a[i][j]=(a[i - 1][j]+a[i - 1][j - 1])%mo$计算组合数，然后通过二维前缀和公式$sum[i][j]=(sum[i - 1][j]+sum[i][j - 1]+a[i][j]-sum[i - 1][j - 1]+mo)%mo$进行预处理，最后根据输入的$n$和$m$输出$sum[r][l]$。

- **作者：ylwang（4星）**
    - **关键亮点**：分Subtask进行讲解，从暴力解法逐步优化到利用杨辉三角和前缀和优化，适合初学者理解，对不同数据范围的解法分析清晰。
    - **核心代码（Subtask4）**：
```cpp
#pragma GCC optimize(3)
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i, k, j) for(int i = (k); i <= (j); i++)
using namespace std;
inline int read() {
    int num = 0, flag = 1;
    char c=' ';
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') flag = -1;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return num * flag;
}
#define MOD 19260817
#define MAXN 1005
int c[MAXN][MAXN];
int sum[MAXN][MAXN];
signed main() {
    c[0][0] = 1;
    For(i, 1, 1000) {
        For(j, 0, i) {
            if(j == 0) c[i][j] = 1;
            else {
                c[i][j] = (c[i - 1][j]+c[i - 1][j - 1])%MOD;
            }
        }
    }
    For(i, 0, 1000) {
        For(j, 0, 1000) {
            if(j == 0) sum[i][j] = 1;
            else sum[i][j] = (sum[i][j - 1]+c[i][j])%MOD;
        }
    }
    int Qnum = read();
    while(Qnum--) {
        int ans = 0;
        int n = read(), m = read();
        For(j, 1, m) {
            ans = (ans+sum[j][n]-1)%MOD;
        }
        printf("%d\n", ans);
    }
    return 0;
}
```
    - **核心思想**：先通过杨辉三角递推式$c[i][j] = (c[i - 1][j]+c[i - 1][j - 1])%MOD$计算组合数，再对每行计算前缀和$sum[i][j] = (sum[i][j - 1]+c[i][j])%MOD$，最后对于每次询问，通过累加$sum[j][n]$并减去多余的1（因为前缀和初始化时多算了1）得到结果。

### 最优关键思路或技巧
 - **递推优化**：通过打表找规律得出递推公式（如Social_Zhao的$ans[i][j]=ans[i - 1][j - 1]+ans[i - 1][j]+i$），减少计算量，优化时间复杂度。
 - **二维前缀和**：利用杨辉三角计算组合数后，通过二维前缀和进行预处理，使得每次查询能在$O(1)$时间内完成，提高查询效率。

### 可拓展思路
此类题目拓展方向主要是组合数的各种应用，如排列组合相关的计数问题、动态规划中涉及组合数的状态转移等。类似算法套路包括利用组合数的性质进行化简、通过递推或预处理优化计算等。

### 相似知识点洛谷题目
 - **P1313 计算系数**：涉及组合数与多项式展开系数的计算。
 - **P2822 [NOIP2016 提高组] 组合数问题**：同样是关于组合数的计算，结合取模运算和前缀和优化。
 - **P3807 【模板】卢卡斯定理**：考察组合数计算的卢卡斯定理，与本题组合数计算相关。

### 个人心得摘录与总结
 - **Social_Zhao**：通过暴力打表找规律得出递推式，在解题过程中获得大佬对递推式推导方法的指导。总结为在面对复杂问题时，可通过简单打表找规律，同时积极与他人交流获取思路。
 - **Jelly_Goat**：在推导过程中发现组合数与杨辉三角的联系，且在实现前缀和时注意到可能出现负数导致取模错误的问题。强调了深入分析问题本质以及注意细节的重要性。
 - **于丰林**：最初采用暴力枚举结合费马小定理求逆元的方法，因超时进行优化，最终发现二维前缀和的优化方式。说明在解题时要善于分析算法瓶颈，并针对性地进行优化。 

---
处理用时：75.80秒
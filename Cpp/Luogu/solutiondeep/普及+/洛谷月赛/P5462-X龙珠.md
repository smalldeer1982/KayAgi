# 题目信息

# X龙珠

## 题目描述

“X龙珠”是一款益智小游戏。游戏中有 $n(2|n)$ 个编号互不相同龙珠按照给定的顺序排成一个队列，每个龙珠上面都有一个编号。每次操作时，选择并取出龙珠队列中**相邻**的两个龙珠，放到目标队列的末尾（目标队列最开始是空的，且这两个龙珠的前后顺序不变），然后去除原龙珠队列的空隙。反复多次，直到原龙珠队列为空。可见，因为决策不一样导致目标队列顺序不一样。现在请求出所有方案中、目标队列字典序最大的方案。只需要给出目标队列即可。

例如，当原龙珠队列是 [1,3,2,4] 时，可以先取出 3 和 2，此时目标队列是 [3,2]，原龙珠队列是 [1,4]；再将剩下两个龙珠放入目标队列，得到目标队列是 [3,2,1,4]

## 说明/提示

对于 20% 的数据，$n\le10$。  
对于 60% 的数据，$n\le10^3$。  
对于 100% 的数据，$n\le10^5$，龙珠编号不超过 n。


## 样例 #1

### 输入

```
4 
3 1 4 2```

### 输出

```
4 2 3 1```

## 样例 #2

### 输入

```
6 
6 5 4 1 3 2```

### 输出

```
6 5 4 1 3 2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何使目标队列字典序最大展开，核心思路为贪心策略，即每次选取尽可能大的数及其相邻数。实现过程中，不同题解采用了多种数据结构辅助，各有优劣。

### 所选的题解
1. **作者：叫我DJ (赞：79)**
    - **星级**：5星
    - **关键亮点**：思路清晰简洁，使用链表存储数据，通过一次从大到小枚举，直接确定并输出目标队列，时间复杂度低，代码实现高效简洁。
    - **重点代码**：
```cpp
#include <cstdio>

int n,a[100001],k[100001],x[100001],i;

int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;++i){
        scanf("%d",&a[i]);
        k[a[i-1]]=a[i];
        x[a[i]]=a[i-1];}
    for(i=n;i>=1;--i)
        if(k[i])printf("%d %d ",i,k[i]),k[x[i]]=k[k[i]],x[k[x[i]]]=x[i],k[k[i]]=0;
    return 0;
}
```
    - **核心思想**：先通过数组`k`和`x`构建链表关系，然后从大到小遍历数字，若当前数字在链表中有后继，则输出当前数字及其后继，并更新链表结构。
2. **作者：LesterYu (赞：10)**
    - **星级**：4星
    - **关键亮点**：巧妙利用栈来组合数对，通过观察发现数对在初始时就已确定，将数用栈存放，按规则组成数对，最后排序输出，复杂度为O（nlogn），思路独特且易于理解。
    - **重点代码**：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define MAX 100001
using namespace std;
struct node{
    int t,m;
}k[MAX];
int n,cnt,knt,a[MAX],q[MAX];

bool cmp(node x,node y){
    return x.t<y.t;
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        if(a[i]>q[cnt]) q[++cnt]=a[i];
        else{
            k[++knt].t=q[cnt];
            k[knt].m=a[i];
            cnt--;
        }
    }
    while(cnt){
        k[++knt].t=q[cnt-1];
        k[knt].m=q[cnt],cnt-=2;
    }
    sort(k+1,k+n/2+1,cmp);
    for(int i=n/2;i;i--){
        printf("%d %d ",k[i].t,k[i].m);
    }
}
```
    - **核心思想**：遍历输入数组，将大于栈顶的数入栈，小于栈顶的数与栈顶数组成数对并弹出栈顶，最后处理栈中剩余数组成数对，再对所有数对按规则排序后输出。
3. **作者：_Atyou (赞：7)**
    - **星级**：4星
    - **关键亮点**：采用并查集维护位置信息，从大到小按顺序两个两个取数，通过并查集合并操作快速确定下一个未取数字的位置，解决了在已删除数字的队列中定位的难点，算法巧妙。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

#define reg register
const int N = 100000 + 5;

int n, pos[N], v[N], a[N], fa[N], ans[N], m;

inline int get(int x) {
    if (fa[x]==x) return x;
    return fa[x]=get(fa[x]);
}

int main() {
    scanf("%d", &n);
    fa[n+1]=n+1;
    for (reg int i=1; i<=n; ++i) {
        fa[i]=i;
        scanf("%d", &a[i]); pos[a[i]]=i;
    }
    for (reg int i=n; i; --i) {
        if (v[i]) continue;
        int nxtpos=get(pos[i]+1);
        if (nxtpos==n+1) continue;
        v[i]=v[a[nxtpos]]=1;
        fa[get(pos[i])]=get(nxtpos); fa[get(nxtpos)]=get(nxtpos+1);
        ans[++m]=i; ans[++m]=a[nxtpos];
    }
    for (reg int i=1; i<=n; ++i) printf("%d ", ans[i]);
    return 0;
}
```
    - **核心思想**：初始化并查集，每个位置的父节点为自身。从大到小遍历数字，若当前数字未被取过，通过`get`函数获取其下一个未取数字的位置，若存在则标记并合并相关位置，将这两个数字存入答案数组。

### 最优关键思路或技巧
1. **贪心策略**：为使目标队列字典序最大，每次操作选取尽可能大的数及其相邻数，这是解决本题的核心思想。
2. **数据结构辅助**：使用链表、栈、并查集等数据结构优化操作。如链表可方便地删除和查找相邻元素；栈能巧妙地组合数对；并查集可快速维护元素位置关系，解决在动态变化的序列中定位的问题。

### 可拓展之处
同类型题通常围绕贪心策略与数据结构结合，如给定序列进行特定规则的合并操作求最值。类似算法套路为：先确定贪心策略，明确每次操作的最优选择；再根据题目条件和操作特点，选择合适的数据结构辅助实现，降低时间复杂度。

### 相似知识点洛谷题目
1. **P1090 [NOIP2004 提高组] 合并果子**：通过贪心策略选择最小的两堆果子合并，可使用优先队列优化。
2. **P1199 [NOIP2010 普及组] 三国游戏**：涉及贪心思想，根据武将武力值关系进行策略选择。
3. **P2859 [USACO06DEC]Milk Patterns G**：利用贪心和后缀数组解决字符串相关问题。

### 个人心得摘录与总结
1. **作者：万弘**：提到先尝试暴力解法，再考虑优化，如用线段树维护最大值，但因未正确处理“去除原龙珠队列的空隙”问题导致错误，最终使用链表解决。总结出遇到问题应先分析暴力思路，再逐步优化，同时要注意细节处理，避免算法实现与题目要求不符。
2. **作者：detect**：强调要专心比赛，因各种原因耽误时间导致未按时提交本题，得到深刻教训，提醒大家比赛时合理安排时间，专注解题。 

---
处理用时：70.51秒
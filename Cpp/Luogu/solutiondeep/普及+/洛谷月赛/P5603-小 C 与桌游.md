# 题目信息

# 小 C 与桌游

## 题目背景

小 C 是一个热爱桌游的高中生，现在他被一个桌游难住了，快来帮帮他！

## 题目描述

这个桌游的地图可以被抽象成一个 $n$ 个点，$m$ 条边的**有向无环图**（**不保证连通**），小 C 在这个地图上行走，小 C 能走到某个点当且仅当能够到达这个点的所有点都已经被小 C 走到。小 C 会走到每个点恰好 $1$ 次，并且他能走到哪些点与他当前所在的点没有关系（即可以走到与当前所在的点没有连边的点，只要满足之前的条件）。

小 C 每走到一个标号比之前走到的点都大的点，他就会有 $\frac{1}{2}$ 的概率从对手那里拿到 $1$ 块筹码，有 $\frac{1}{2}$ 的概率给对手 $1$ 块筹码，双方初始各有 $1919810$ 个筹码。

小 C 的运气时好时坏，所以他希望你帮他计算出：

- 在最优情况下，即他每次都能从对手那里拿到筹码时，他采取最优的行走方式能得到的筹码数。
- 在最劣情况下，即对手每次都能从他那里拿到筹码时，他采取最优的行走方式会失去的筹码数。



## 说明/提示

**样例解释**

最优情况下的行走方式是 $1-2-3$，最劣情况下的行走方式是 $1-3-2$。

**计分方式**

对于每一个测试点：

- 如果你输出格式错误或者两行都不正确，将会得到 $0$ 分。
- 如果你的输出第一行正确，第二行错误或第二行正确，第一行错误，将会得到这个测试点 $40 \%$ 的分数。
- 否则，你将会得到这个测试点 $100 \%$ 的分数。

**数据范围**

对于 $20\%$ 的数据，$1 \le n, m \le 10$。

对于 $40\%$ 的数据，$1 \le n, m \le 2000$。

对于 $100\%$ 的数据，$1 \le n, m \le 5 \times 10^5$，$1 \le u, v \le n$。


## 样例 #1

### 输入

```
3 2
1 2
1 3```

### 输出

```
3
2```

# AI分析结果

### 综合分析与结论
这些题解都围绕利用拓扑排序解决在有向无环图中按特定规则行走，求最优和最劣情况下筹码数变化的问题。思路上，最优情况（每次从对手拿筹码）大家普遍采用贪心策略，选取编号最小的入度为0的点扩展，用小根堆维护；最劣情况（每次给对手筹码）较复杂，简单贪心选编号最大的点扩展会出错，需考虑编号小的点对后续扩展的影响。

算法要点在于对拓扑排序的灵活运用，结合优先队列、set等数据结构优化节点选择过程。解决难点主要是针对最劣情况设计正确的贪心策略，如先处理编号小于当前最大值的可访问点，再选编号最大的点扩展。

### 所选的题解
- **作者：Sweetlemon (5星)**
    - **关键亮点**：思路清晰全面，不仅详细分析最优、最劣情况的贪心策略及反例，还给出动态规划解法及多种实现方式（贪心、树状数组优化dp、set单调优化dp），并对各方法进行时间复杂度分析和对比。
    - **个人心得**：无
    - **重点代码（贪心）核心思想**：先通过小根堆实现最优情况的拓扑排序统计答案；再用两个堆（最大堆和最小堆）实现最劣情况，每次从最大堆取顶，若大于当前最大值则更新答案，然后从最小堆取元素直到堆顶大于“最大标号”，利用标记数组防止重复访问。
```cpp
// 贪心
#include <cstdio>
#include <cctype>
#include <functional>
#include <algorithm>
#include <queue>
#define MAXIOLG 25
#define MAXN 500005
#define MAXM 1000005
#define INf 114514
#define INF 1919810

using namespace std;

typedef long long ll;
typedef long double ld;
typedef ll io_t;

io_t shin[MAXIOLG];
io_t seto(void); //快读
void ayano(io_t x,char spliter='\n'); //快写

priority_queue<int,vector<int>,greater<int> > q; //小根堆
priority_queue<int,vector<int>,less<int> > q2; //大根堆

int fst[MAXN],nxt[MAXM],edges=0; //存图
int g[MAXM];
int ind[MAXN],visited[MAXN]; //入度, 访问标记

void addedge(int u,int v); //加边

int main(void){
    int n,m;
    n=seto(),m=seto();
    while (m--){
        int u,v;
        u=seto(),v=seto();
        addedge(u,v),ind[v]++;
    }
    
    int ans1=0,ans2=0;
    //先计算尽可能大情况的答案 ans1
    for (int i=1;i<=n;i++)
        (!ind[i])?(q.push(i)):(void());
    int tx=0; //当前访问过的最大的节点
    while (!q.empty()){
        int nowv=q.top(); //要访问的节点
        q.pop();
        if (nowv>tx)
            tx=nowv,ans1++; //更新答案
        for (int ei=fst[nowv];ei;ei=nxt[ei]){
            int v=g[ei];
            ind[v]--;
            (!ind[v])?(q.push(v)):(void());
        }
    }
    ayano(ans1); //输出第一个答案
    //再计算尽可能小情况的答案 ans2
    for (int i=1;i<=n;i++)
        for (int ei=fst[i];ei;ei=nxt[ei])
            ind[g[ei]]++; //重新统计入度
    for (int i=1;i<=n;i++)
        (!ind[i])?(q.push(i),q2.push(i)):(void()),
        visited[i]=0; //注意要同时插入到两个堆里
    tx=0;
    while (!q2.empty()){
        //取大根堆堆顶, 买票
        int nowv=q2.top();
        q2.pop();
        if (visited[nowv])
            continue;
        visited[nowv]=1;
        (nowv>tx)?(ans2++,tx=nowv):(0);
        //访问这个节点
        for (int ei=fst[nowv];ei;ei=nxt[ei]){
            int v=g[ei];
            ind[v]--;
            (!ind[v])?(q.push(v),q2.push(v)):(void());
        }
        while ((!q.empty()) && (nowv=q.top())<=tx){
            //取小根堆堆顶进行访问, 充分利用票
            q.pop();
            if (visited[nowv])
                continue;
            visited[nowv]=1;
            for (int ei=fst[nowv];ei;ei=nxt[ei]){
                int v=g[ei];
                ind[v]--;
                (!ind[v])?(q.push(v),q2.push(v)):(void());
            }
        }
    }
    ayano(ans2); //输出第二个答案
    return 0;
}

void addedge(int u,int v){
    edges++;
    g[edges]=v;
    nxt[edges]=fst[u],fst[u]=edges;
}

io_t seto(void){
    io_t x=0;
    char ch=getchar();
    int symbol=0;
    while (!isdigit(ch))
        (ch=='-')?(symbol=1):(0),ch=getchar();
    while (isdigit(ch))
        x=(x*10)+(ch-'0'),ch=getchar();
    return (symbol)?(-x):(x);
}
void ayano(io_t x,char spliter){
    if (!x){
        putchar('0'),putchar(spliter);
        return;
    }
    if (x<0)
        putchar('-'),x=-x;
    int len=0;
    while (x){
        io_t d=x/10;
        shin[len++]=x-d*10;
        x=d;
    }
    while (len--)
        putchar(shin[len]+'0');
    putchar(spliter);
}
```
- **作者：EternalEpic (4星)**
    - **关键亮点**：对拓扑序列中贪心策略分析详尽，通过具体样例指出最劣情况简单用大根堆贪心的错误之处，并给出正确的贪心思路及实现代码。
    - **个人心得**：无
    - **重点代码核心思想**：最优情况用小根堆维护拓扑排序；最劣情况先将入度为0的点放入大根堆，每次取堆顶，若大于当前最大值则更新答案，然后对堆中剩余点进行深度优先搜索，将新解锁的入度为0的点按规则处理后重新放入堆。
```cpp
enum {
	Maxn = 500005,
	Maxm = 500005
};

int n, m, cnt = 0, head[Maxn], ver[Maxm], nxt[Maxm], deg[Maxn][2];
inline void AddEdge(int u, int v) { ver[++cnt] = v, nxt[cnt] = head[u], head[u] = cnt; }
priority_queue <int> h2; priority_queue <int, vector<int>, greater <int> > h1;
int max1, max2, ans1 = 0, ans2 = 0; stack <int> st;
inline void dfs(int u) {
	for (int i = head[u]; i; i = nxt[i]) {
		deg[ver[i]][1]--;
		if (!deg[ver[i]][1]) {
			if (ver[i] <= max2) dfs(ver[i]);
			else st.push(ver[i]);
		}
	}
}

signed main(void) {
//	file("");
	read(n), read(m);
	for (int i = 1, u, v; i <= m; i++)
		read(u), read(v), AddEdge(u, v), deg[v][0]++, deg[v][1]++;
	for (int i = 1; i <= n; i++) {
		if (!deg[i][0]) h1.push(i);
		if (!deg[i][1]) h2.push(i);
	}
	
	max1 = 0;
	while (h1.size()) {
		int u = h1.top(); h1.pop();
		if (u > max1) {
			max1 = u; ++ans1;
		}
		for (int i = head[u]; i; i = nxt[i]) {
			deg[ver[i]][0]--;
			if (!deg[ver[i]][0]) h1.push(ver[i]);
		}
	}
	
	max2 = 0;
	while (h2.size()) {
		int u = h2.top();
		if (u > max2) {
			max2 = u; ++ans2;
		} while (h2.size()) { dfs(h2.top()); h2.pop(); }
		while (st.size()) { h2.push(st.top()); st.pop(); }
	} writeln(ans1), writeln(ans2);
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```
- **作者：miao5 (4星)**
    - **关键亮点**：先点明题目需用拓扑排序求两个答案，对最优和最劣情况分别分析，通过具体例子说明最劣情况不能简单用大根堆贪心，给出详细的代码实现及注释。
    - **个人心得**：无
    - **重点代码核心思想**：最优情况用小根堆实现拓扑排序，每次取出节点若大于当前最大值则答案加一；最劣情况用大根堆，每次先将堆中元素放入队列，从队列取元素，若大于当前最大值则答案加一，处理该点后将新解锁的入度为0的点按规则放入堆或队列。
```cpp
#include<algorithm>
#include<cstdio>
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
const int N=500005;
priority_queue<int,vector<int>,greater<int> > q1;
//此处q1为“最多可以获得的”所使用的堆。 
priority_queue<int,vector<int>,less<int> > q2;
//此处q2为“最少可以失去的”所使用的堆。
queue<int> a;
int head[N];
struct Edge{
	int to,nxt;
} e[N];
int sum;
void add(int x,int y){
	e[++sum].nxt=head[x];
	e[sum].to=y;
	head[x]=sum;
}//典型链式前向星存图。 
int n,m;
int ru[N],ru2[N];
void best_(){//最好状态下可以获得最多的筹码 
	int x=0,ans=0;
    while(!q1.empty()){
    	int u=q1.top();
    	q1.pop();
    	if(u>x){
    		ans++;
		}//由于本函数计算的是运气好的情况，只要大于目前max就答案加一 
		x=max(x,u);
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].to;
			ru[v]--;
			if(ru[v]==0) q1.push(v);
		}//遍历这个点 
	}
	cout<<ans<<endl;
}
void worst_(){//最坏状态下可以失去最少的筹码 
	int x=0,ans=0;
	while(!q2.empty()){
		int u=q2.top();
		if(u>x){
			ans++;
		}//由于本函数计算的是运气坏的情况，只要大于目前max就答案加一
		while(!q2.empty()){
			a.push(q2.top());
			q2.pop();
		}
		while(!a.empty()){
			int b=a.front();
			a.pop();
			x=max(x,b);
			for(int j=head[b];j;j=e[j].nxt){
				int v=e[j].to;
				ru2[v]--;
				if(ru2[v]==0){
					if(v>x) q2.push(v);
					else a.push(v);
				}
			}
		}
	}
	cout<<ans;
}
int main(){

	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
		ru1[v]++;
		ru2[v]++;
	}//输入并存图
	for(int i=1;i<=n;i++){
		if(ru1[i]==0){
			q1.push(i);
			q2.push(i);
		}
	}//插入
	Best_();
	Worst_();//找到最优，最劣
}
```

### 最优关键思路或技巧
- **数据结构**：利用优先队列（小根堆、大根堆）优化拓扑排序过程中节点的选择，快速获取当前可访问节点中的最值。如在最优情况中用小根堆取编号最小的点，在最劣情况结合大小根堆或用特殊比较规则的优先队列实现正确贪心。
 - **算法优化**：在最劣情况贪心策略中，先处理编号小于当前最大值的可访问点，充分利用已有的“代价”，避免大的点被小的点掩盖，从而优化答案。
 - **思维方式**：通过具体反例分析简单贪心策略的错误原因，深入理解题目条件对拓扑排序的影响，进而调整贪心策略。

### 拓展思路
此类题目属于在有向无环图上结合特定规则的路径规划与最值求解问题。类似算法套路是在拓扑排序基础上，根据具体规则设计合理的贪心策略或动态规划方程。同类型题可能会改变图的性质（如带权图）、行走规则（如不同的得分机制）等。

### 推荐题目
 - **P1983 车站分级**：通过拓扑排序确定车站等级，与本题都涉及拓扑排序及根据特定条件进行分析。
 - **P3387 【模板】缩点**：先对有向图缩点转化为DAG，再在DAG上进行动态规划，与本题在DAG上求解问题思路类似。
 - **P1347 排序**：利用拓扑排序判断能否唯一确定序列顺序，锻炼对拓扑排序应用场景的理解。 

---
处理用时：143.32秒
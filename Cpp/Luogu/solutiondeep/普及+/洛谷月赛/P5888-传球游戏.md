# 题目信息

# 传球游戏

## 题目背景

羊城有善蹴鞠者。会足协之杯，于校园之东北角，施两球场，蹴鞠者站球场中，$n$ 人，一球，二门，三裁判而已。观众团坐。少倾，但闻球场中哨声一响，满坐寂然，无敢哗者。

当是时，传球声，微微风声，队员疾跑声，教练呼喊声，拉拉队助威声，一时齐发，众妙毕备。满场观众无不伸颈，侧目，微笑，默叹，以为妙绝。

未几，我球员施一长传，彼球员截之，望我龙门冲来。

但见守门员 oql 立于门，若有所思——

## 题目描述

**原来他在想这么一个问题：**

场上的 $n$ 个球员围成一圈，编号从 $1$ 到 $n$ ，刚开始球在 $1$ 号球员手中。一共 $m$ 次传球，每次传球必须传给一个人，但不能传到自己手中。求第 $m$ 次传球以后传回 $1$ 号球员的方案数。

但他觉得这个问题太简单了，于是加了 $k$ 条限制，每条限制形如 $a,b$，表示 $a$ 号球员不能将球传给 $b$ 号球员。

为了使得 oql 的注意力转移回球场上，你需要在最短的时间内告诉他这个方案数是多少。

你只需要告诉他答案对 $998244353$ 取模后的结果。

## 说明/提示

对于 $10\%$ 的数据，$k=0$。

对于另外 $15\%$ 的数据，$n\leq 500$。

对于另外 $20\%$ 的数据，$n\leq 5\times 10^4$。

对于另外 $20\%$ 的数据，$k\leq 300$。

对于 $100\%$ 的数据，$1\leq n\leq 10^9$，$0\leq m\leq 200$，$0\leq k \leq \min(n\times(n-1),5\times 10^4)$，$1\leq a_i,b_i\leq n$，**不保证 $a_i,b_i$ 不相等**。

## 样例 #1

### 输入

```
2 1 0```

### 输出

```
0```

## 样例 #2

### 输入

```
3 3 0```

### 输出

```
2```

## 样例 #3

### 输入

```
7 13 5
1 3
4 5
5 4
6 1
2 2```

### 输出

```
443723615```

# AI分析结果

• 综合分析与结论：
    - 思路方面：所有题解都基于动态规划（DP）思想。部分分阶段，对于$k = 0$的情况，通过简单递推求解；对于$n$较小的情况，采用暴力DP。对于$100\%$数据，利用$n$大$k$小的特点，将不受限制的大量球员合并为一个“自由人”状态处理，从而降低复杂度。
    - 算法要点：通过状态转移方程$f[i][j]=\sum_{k->j}f[i - 1][k]$（$k->j$表示$k$能传球给$j$）来计算方案数。优化时，先统计上一轮总方案数，再减去不能传给当前球员的方案数。同时，利用滚动数组优化空间。
    - 解决难点：主要难点在于如何处理大规模的$n$和有限制条件的情况。通过离散化限制条件中的球员编号，并将无限制球员合并，有效降低了时间和空间复杂度。

    - 总体来看，各题解思路相似，差异主要体现在代码实现的细节和清晰度上。

• 所选的题解：
  - 作者：破忆 (5星)
    - 关键亮点：思路清晰，从部分分逐步推导到正解，详细阐述了每个阶段的解法和优化思路，代码注释详细。
    - 个人心得：无
    - 核心代码实现思想：先对限制条件涉及的球员离散化，然后利用滚动数组，通过统计上一轮总方案数和减去不合法方案数来更新当前状态的方案数。
    - 核心代码片段：
```cpp
f[0][1]=1;
RE LL el=0;
for(RE int i=1;i<=m;i++){
    RE bool A=i&1,B=1-A;
    RE LL sum=0,now=el*(n-num-1)%TT;
    for(RE  int j=1;j<=num;j++){
        sum+=f[B][j];
        f[A][j]=0;
    }
    sum%=TT;
    (now+=sum)%=TT;
    (sum+=el*(n-num)%TT)%=TT;
    for(RE int j=1;j<=num;j++){
        f[A][j]=(sum-f[B][j]+TT)%TT;
        for(RE  int k=lnk[j];k;k=e[k].nxt){
            RE  int y=e[k].to;
            if(y==j) continue;
            f[A][j]+=-f[B][y]+TT;
        }
        f[A][j]%=TT;
    }
    el=now;
}
```
  - 作者：Rainybunny (4星)
    - 关键亮点：对DP状态转移和优化思路阐述详细，尤其是对“自由人”点的性质分析透彻，代码结构清晰。
    - 个人心得：无
    - 核心代码实现思想：通过哈希表离散化球员编号，定义“自由人”点并单独处理其转移，利用滚动数组记录状态，通过总方案减去不合法方案实现状态转移。
    - 核心代码片段：
```cpp
for (Int i = 1, t = 1; i <= m; ++ i, t ^= 1 ) {
    Outs[t] = 0;
    for ( int p: Player ) {
        int& now = F[t][p];
        now = ( ( F[t ^ 1][idf] + Outs[t ^ 1] - F[t ^ 1][p] ) % MOD + MOD ) % MOD; 
        for (Int j = Head[p]; j; j = Graph[j]._nxt ) now = ( now - F[t ^ 1][Graph[j].To] + MOD ) % MOD;
        Outs[t] = ( Outs[t] + now ) % MOD;
    }
    F[t][idf] = ( 1LL * F[t ^ 1][idf] * ( Free - 1 ) % MOD + 1LL * Outs[t ^ 1] * Free % MOD ) % MOD; 
}
```
  - 作者：Weakest_Konjac (4星)
    - 关键亮点：对不同数据范围的解法分析清晰，代码简洁明了，通过滚动数组和对普通球员与特殊球员的区分处理，有效解决问题。
    - 个人心得：无
    - 核心代码实现思想：先统计上一轮所有球员持球方案数，然后减去自身和不合法的方案数来更新当前球员的方案数，对特殊球员和普通球员分别处理。
    - 核心代码片段：
```cpp
while (m--){
    last=sum,sum=1ll*last*(n-1)%MOD;
    for (register int i=1;i<=cnt;++i) dp[cur^1][i]=mod(last-dp[cur][i]);
    for (register int i=1;i<=k;++i)
        if (edge[i].x!=edge[i].y)
            dp[cur^1][edge[i].y]=mod(dp[cur^1][edge[i].y]-dp[cur][edge[i].x]),sum=mod(sum-dp[cur][edge[i].x]);
    cur^=1;
}
```
• 最优关键思路或技巧：
    - **状态压缩与合并**：将大量无限制的球员合并为一个状态（“自由人”），减少状态数量，降低时间和空间复杂度。
    - **正难则反的转移优化**：通过统计上一轮总方案数，再减去不合法方案数来计算当前球员的方案数，避免了直接枚举所有合法转移的复杂操作。
    - **离散化**：对限制条件中涉及的球员编号进行离散化处理，方便统一管理和处理限制条件。

• 可拓展之处：
    - 同类型题或类似算法套路：此类问题属于有条件限制的状态转移问题，类似套路可应用于路径规划、资源分配等场景，在这些场景中存在某些限制条件，可通过状态合并、正难则反等思路优化DP解法。

• 推荐题目：
    - [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：经典的棋盘路径规划问题，存在障碍限制，与本题类似，可通过DP并结合状态转移优化求解。
    - [P1216 [USACO1.5]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：同样是基于DP的问题，通过对状态转移的分析和优化来解决，有助于巩固此类算法思想。
    - [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)：区间DP问题，虽然场景不同，但在状态定义、转移方程推导和优化方面有相似之处，可加深对DP算法的理解。

• 个人心得摘录与总结：
    - 无 

---
处理用时：78.07秒
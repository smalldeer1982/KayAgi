# 题目信息

# [加油武汉] 七步洗手法

## 题目背景

现在正处于疫情防控的关键时期，大家要经常洗手，防止接触感染。

[正确的洗手方法](https://dxy.com/column/4473)

## 题目描述

给定一张含有 $n$ 个点的无向完全图，其中 $m$ 条边是白边，其余是黑边。

现在需要你求出同色的三元环（或者说，三角形）的个数。

## 说明/提示

 - 对于 $20\%$ 的数据，满足 $n \leq 200$；
 - 对于 $50\%$ 的数据，满足 $n \leq 2000$；
 - 对于 $100\%$ 的数据，满足 $1 \leq n \leq 10^5,1 \leq m \leq 3\times 10^5$。

## 样例 #1

### 输入

```
5 3
1 5
2 5
3 5```

### 输出

```
4```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解采用补集转化思想，通过计算三角形总数减去异色三角形数目得到同色三角形数目。少数题解尝试直接计算同色三角形，但处理较为复杂。
    - 算法要点：计算三角形总数利用组合数公式\(C_n^3 = \frac{n(n - 1)(n - 2)}{6}\)。计算异色三角形时，通过对每个点统计异色角（两边颜色不同的角）数目，由于每个异色三角形含两个异色角，将异色角总数除以2得到异色三角形数目。
    - 解决难点：难点在于如何高效计算异色三角形数目。不同题解在具体实现统计异色角或处理白边相关情况时方法略有不同。
    - 评分：
        - 未见堇开：思路清晰，直接点明补集转化思想，代码简洁明了，时间复杂度最优，得5星。
        - _Freedom_ ：思路独特，分步骤阐述，但表述稍显繁琐，且对“几乎”的处理不够严谨，得4星。
        - Star_Wind ：思路与未见堇开类似，但代码注释较少，可读性稍逊，得4星。
        - Fairicle ：思路清晰，但代码只有核心部分，完整性欠佳，得3星。
        - Skyjoy ：思路常规，代码有详细的错误提示，但整体中规中矩，得3星。
        - 一叶知秋。：思路复杂，处理方式不够简洁，代码可读性一般，得2星。
    - 最优关键思路或技巧：补集转化思想，将难以直接计算的同色三角形数目转化为容易计算的三角形总数与异色三角形数目的差，并且通过统计异色角数目巧妙计算异色三角形数目。
    - 可拓展之处：此类题目属于图论中关于特定子图计数问题，类似套路可用于计算其他特定子结构（如四边形等）的数目，关键在于找到合适的转化方式和高效的统计方法。
    - 相似知识点洛谷题目：
        - P1330 封锁阳光大学：涉及图的连通性和点的覆盖问题，与本题同样需要对图的结构进行分析。
        - P2746 [USACO5.1]校园网Network of Schools：图论中的强连通分量问题，分析图的性质和结构，与本题思路有相似之处。
        - P3387 【模板】缩点：通过缩点处理有向图，与本题对图结构分析和转化思路类似。
    - 个人心得摘录与总结：
        - Skyjoy提到“十年OI一场空，不开long long见祖宗”，强调在处理较大数据时，数据类型选择不当容易导致错误，需注意结果数据范围。
        - 一叶知秋。表示看到题面与数据范围，意识到直接求不行，转换为求不合法个数，体现了面对问题时灵活转变思路的重要性。

所选题解：
  - 作者：未见堇开 (5星)
    - 关键亮点：清晰阐述补集转化思想，时间复杂度\(\Theta (n)\)最优，代码简洁高效。
    - 核心代码：
```cpp
#include<cstdio>
#define reg register
#define MAXN 100001
using namespace std;

typedef long long ll;

int deg[MAXN];
ll ans=0;
int n,m;

int main()
{
    scanf("%d %d",&n,&m);
    for(reg int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d %d",&u,&v);
        ++deg[u],++deg[v];
    }
    for(reg int i=1;i<=n;i++)
        ans+=(1ll*deg[i]*(n-1-deg[i]));
    printf("%lld",1ll*n*(n-1)*(n-2)/6-(ans>>1));
    return(0);
}
```
核心实现思想：通过读入白边更新每个点的度数，遍历每个点，计算该点的异色角数目（即与该点相连的白边数乘以黑边数），累加得到所有异色角总数，除以2得到异色三角形数目，用三角形总数（组合数\(C_n^3\)）减去异色三角形数目得到同色三角形数目。
  - 作者：_Freedom_ (4星)
    - 关键亮点：分步骤详细讲解思路，从数三元环、删异色三元环到补回多减的三元环，思路独特。
    - 个人心得：对白色同色三元环进行补充讨论，之前不知道什么是自环。
    - 核心代码：
```cpp
long long a[100010];//a[i]记录有多少条白边连在节点i上 
	
for(i=1; i<=m; i++) {
	scanf("%d%d",&u,&v);
	ans+=a[u]+a[v];//a[u]+a[v]即为当前与这条交于一点的白边数 
	a[u]++;//u,v节点都多连了一条白边 
	a[v]++;
}
```
核心实现思想：遍历每条白边，累加当前白边与之前已加入白边交于一点的次数（通过记录每个点连接白边的数量实现），以此补回之前多减去的同色三元环数目。
  - 作者：Star_Wind (4星)
    - 关键亮点：思路清晰，利用vector存储白色边信息，实现较为简洁。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
vector<int> v[300023];
int n,m,a,b;
ll sum;
int main()
{
	cin>>n>>m;
	for(register int i=1;i<=m;i++)
	{
		scanf("%d%d",&a,&b);
		v[a].push_back(b);
		v[b].push_back(a);
	}
	for(register int i=1;i<=n;i++)
	  sum+=(v[i].size()*(n-v[i].size()-1));
	cout<<(ll)n*(n-1)*(n-2)/6-sum/2;
	return 0;
}
```
核心实现思想：通过vector数组记录每个点连接的白色边的另一端点，遍历每个点，计算该点连接的白色边数与黑色边数的乘积，累加得到所有异色角总数，除以2得到异色三角形数目，用三角形总数（组合数\(C_n^3\)）减去异色三角形数目得到同色三角形数目。 

---
处理用时：58.71秒
# 题目信息

# [EER1] 代价

## 题目背景

> 个人的遭遇，命运的多舛都使我被迫成熟，这一切的代价都当是日后活下去的力量。
——  三毛

小 Z 喜欢玩数字游戏。

## 题目描述

给出一个长度为 $n+2$ 的序列 $a_i$，其中第 $1$ 个数和第 $n+2$ 个数固定为 $1$。你每次可以选择序列中间的一个数删除（不能是第一个和最后一个），删除位置 $p$ 上的数的代价为 $a_{p-1} \times a_p \times a_{p+1}$。你需要执行这个操作直到无法操作为止。求最小的代价和。

## 说明/提示

样例一解释：

先删除 $3$，代价为 $6$，再删除 $2$，代价为 $2$，再删除 $1$，代价为 $1$。

总代价为 $6+2+1=9$。

---

**本题采用捆绑测试。**

对于 $100\%$ 的测试点：$1 \leq n \leq 10^6$，$1 \leq a_i \leq 10^4$。

本题共 $6$ 个子任务，各子任务的分值及约定如下：

子任务 $1$（$1$ 分）：$a_i = 1$。

子任务 $2$（$14$ 分）：$1 \leq n \leq 10$。

子任务 $3$（$5$ 分）：$1 \leq a_i \leq 2$。

子任务 $4$（$14$ 分）：$1 \leq n \leq 40$。

子任务 $5$（$26$ 分）：$1 \leq n \leq 500$。

子任务 $6$（$40$ 分）：无特殊限制。

#### 特别感谢

idea：smrsky

solu：CYJian

data：iostream

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
9
```

## 样例 #2

### 输入

```
4
19 26 8 17```

### 输出

```
846```

## 样例 #3

### 输入

```
6
1 1 1 1 1 1```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
这些题解主要围绕贪心策略展开。多数题解先分析特殊情况，如Subtask 1中\(a_i = 1\)时答案为\(n\) ，Subtask 3中对\(a_i \leq 2\)情况的探讨。关键思路在于发现以\(1\)为界将序列分段，每段从两边向中间删除数字，且将每段中最小数留到最后删除代价最小，最后再删除所有\(1\)。

不同题解在思路阐述清晰度、代码可读性及优化程度上存在差异。部分题解通过暴力搜索找规律得出结论，部分先从区间DP入手分析再过渡到贪心策略。

### 所选的题解
- **作者：xht (赞：33)  5星**
    - **关键亮点**：思路清晰，先提出较优解，再逐步分析如何转化为最优解，对贪心策略的证明和推导详细。
    - **重点代码**：
```cpp
const int N = 1e6 + 7;
int n, a[N];
ll ans = -1;

int main() {
    rd(n), rda(a, n);
    for (int i = 0, j = 1; i <= n; i = j, j = i + 1) {
        while (j <= n && a[j]!= 1) ++j;
        ++ans;
        if (i + 1!= j) ans += *min_element(a + i + 1, a + j);
        for (int k = i + 1; k < j - 1; k++)
            ans += a[k] * a[k + 1];
    }
    print(ans);
    return 0;
}
```
    - **核心实现思想**：以\(1\)为界划分序列，对每段计算相邻数字乘积之和并加上该段最小数，最后加上\(1\)的个数。
- **作者：StudyingFather (赞：27)  4星**
    - **关键亮点**：先分析各子任务，从简单情况入手，逐步引导到正解的贪心策略，逻辑连贯。
    - **重点代码**：
```cpp
#include <iostream>
int a[1000005];
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    int n;
    long long ans=0;
    cin>>n;
    a[1]=a[n+2]=1;
    for(int i=2;i<=n+1;i++)
        cin>>a[i];
    int mina=100000;
    for(int i=2;i<=n+1;i++)
    {
        if(a[i]==1)ans++;
        else if(a[i+1]==1)
        {
            ans+=min(mina,a[i]);
            mina=100000;
        }
        else ans+=a[i]*a[i+1],mina=min(mina,a[i]);
    }
    cout<<ans<<endl;
}
```
    - **核心实现思想**：遍历序列，以\(1\)为界，对每段计算相邻数字乘积之和并适时加上段内最小数，最后加上\(1\)的个数。
- **作者：Warriors_Cat (赞：1)  4星**
    - **关键亮点**：先给出考场的部分分代码及思路，再引出正解，对思路转变的过程有较好呈现，代码简洁明了。
    - **重点代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define int long long 
#define R register
inline int read(){
    int x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
        if(ch == '-') f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9'){
        x = (x << 3) + (x << 1) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}
int n, a[1000010], l, r, ans, num;
inline int work(int l, int r){
    int sum = 0, x = 0x7fffffff;
    for(R int i = l; i < r; ++i) sum += a[i] * a[i + 1], x = min(x, a[i]);
    sum += min(x, a[r]);
    return sum;
}
signed main(){
    n = read();
    for(R int i = 1; i <= n; ++i){
        a[i] = read();
        if(a[i] == 1){
            if(l == i - 1){
                l = i;
                num++;
                continue;
            }
            ans += work(l + 1, i - 1);
            l = i;
            num++;
        }
    }
    if(l < n) ans += work(l + 1, n);
    printf("%lld", ans + num);
    return 0;
}
```
    - **核心实现思想**：定义函数计算每段的代价，以\(1\)为界划分序列，对每段调用函数计算代价并累加，最后加上\(1\)的个数。

### 最优关键思路或技巧
1. **贪心策略**：利用\(1\)的特殊性，以\(1\)为界将序列分段，每段从两边向中间删数且把最小数留到最后删除，这样能保证每段代价最小，最后再删除所有\(1\)。
2. **前缀后缀和优化**：部分题解通过前缀后缀和来维护从两边删除数的代价，从而快速计算每段的最小代价，优化时间复杂度。

### 可拓展思路
此类题目属于序列操作求最优值问题，常见类似套路是先分析特殊情况找规律，再确定贪心策略。同类型题可考虑序列删除、合并等操作并求最值的场景，关键在于发现操作中的不变量或可利用的特殊元素（如本题中的\(1\)）。

### 相似知识点洛谷题目
1. **P1063 能量项链**：同样是对序列元素进行操作（合并）并求最优值，与本题思路类似，可锻炼区间DP及贪心策略应用。
2. **P1880 [NOI1995] 石子合并**：通过区间DP解决序列合并的最优值问题，与本题在分析子问题及动态规划思想上有相似之处。
3. **P4017 最大食物链计数**：虽然涉及拓扑排序，但同样是处理序列相关问题，在分析问题和寻找解决策略上能提供类似思路。 

---
处理用时：63.23秒
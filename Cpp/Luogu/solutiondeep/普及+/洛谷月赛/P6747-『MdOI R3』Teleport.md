# 题目信息

# 『MdOI R3』Teleport

## 题目背景

凯瑞甘从帝国的围攻下，击毁了大天使号，乘着雷诺的飞船逃了出来，到了休伯利安号上。

“吉米？”凯瑞甘着急地四处寻找着。

“很抱歉，我们没能救出他”马特·霍纳向凯瑞甘走来。

“你丢下了他？”凯瑞甘回想起曾经的自己被蒙斯克丢下，便起了杀心，用灵能将马特抓了起来。

“不是的，凯瑞甘，我们受到了帝国的伏击，现在必须，马上离开，过会可以回头来找他”马特解释道。

“这里没有我们！你走吧，我自己去找他。”凯瑞甘放下了马特，回头坐着雷诺的回到了星球上。

“警告，警告，敌军突破能量场。”帝国的舰队突破了马特舰队设下的能量场，控制着钢铁舰队折越到了这里，并对休伯利安号发起猛烈的攻击。

“立即进行折越，我们必须马上离开！”马特·霍纳下令道。

## 题目描述

马特·霍纳想要控制休伯利安号进行折越，想要进行折越，就要激活休伯利安号上的所有 $n$ 个位点。

休伯利安号上有 $n$ 个位点，每个位点有 $a_i$ 点能量，为了激活，马特·霍纳会消耗 $k\times n$ 点地嗪，这 $k\times n$ 点地嗪会平均分给 $n$ 个位点，每个位点在接受 $k$ 点地嗪后会激发，得到 $a_i \operatorname{xor} k$ 点高能，所有位点的高能总和为这次折越的消耗 $S$。

为了能够快速的进行折越，马特·霍纳决定用最多的 $k\times n$ 点地嗪，但可惜的是，如果地嗪使用太多，使得消耗 $S$ 超过限制值 $m$ ，那么休伯利安号就会不堪重负，最终爆炸。

现在，你的任务是帮助马特·霍纳找到这个最大的 $k$ ，使得休伯利安号能在安全的前提下尽可能快的折越走。如果任何情况下都不能安全的折越走，则输出 $-1$ 。

这里的 $\operatorname{xor}$ 表示的是位运算中的按位异或运算。

## 说明/提示

对于第一个询问，最大的 $k$ 为 $3$ ，此时 $S=2+1+0=3 \le 10$ ，可证没有更大的 $k$ 满足条件。

对于第二个询问，没有任何 $k$ 满足条件。
|数据点  |$n$  |$a_i$  | $m$ | $q$ |
| :------: | :------: | :-------: | :-------: | :----------: |
|$1$|$\le 10$|$\le 2^{20}$| $\le 2^{20}$| $=1$ |
|$2$| $\le 10^3$|$\le10^3$|$\le10^3$|$\le 10^3$|
|$3$|$\le 10^3$  | $\le 2^{30}$ | $\le 10^3$ | $\le 10^3$ |
|$4\sim 6$| $\le 10^5$| $\le 2^{20}$ | $\le 10^6$ | $\le 10^5$ |
|$7\sim 10$| $\le 10^5$ | $\le 2^{30}$ | $\le 2^{30}\times10^6$ | $\le 10^5$ |
**本题不进行捆绑测试。**

所有测试点的数据范围如上所示。对于所有数据，$0<n,q\leq 10^5,\ 0\leq a_i\leq 2^{30},\ 0\leq m\leq 2^{30}\times 10^6$。

## 样例 #1

### 输入

```
3
1 2 3 
2 
10 
1```

### 输出

```
3
-1```

## 样例 #2

### 输入

```
1
0
1
1073741824000000```

### 输出

```
1073741824000000```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均为按位贪心，利用异或运算中每位的独立性，通过统计 \(a_i\) 二进制下每一位 \(1\) 的个数，从高位到低位贪心确定 \(k\) 的每一位，使 \(k\) 在满足 \(\sum_{i = 1}^{n}a_i \text{ xor } k \leq m\) 的条件下最大。

各题解的不同之处主要体现在细节处理和代码实现上。如判断无解的方式，有的先计算最小消耗 \(S\) 与 \(m\) 比较，有的在贪心过程中逐步判断；在处理可能的溢出问题上，有的采用化乘为除、位移操作避免，有的直接使用 `__int128` 类型。

### 所选的题解
- **作者：infinities (5星)**
    - **关键亮点**：思路清晰，详细阐述按位贪心的具体过程，包括统计 \(a_i\) 每一位 \(0\) 和 \(1\) 的个数、从高到低贪心判断每一位能否变为 \(1\) 等，代码注释详细。
    - **个人心得**：提到代码实现中有一些小细节，如特判 \(a_i\) 为 \(0\) 的情况等。
    ```cpp
    // 统计每一位的0/1个数
    for(int i = 1; i <= n; i++){
        a[i] = read();
        int aa = a[i];
        if(aa == 0)maxsize = max(maxsize, 1ll);
        for(int i = 1; aa; aa = aa >> 1, i++){
            maxsize = max(maxsize, i);
            ++num01[i][aa & 1];
        }
    }
    for(int i = 1; i <= maxsize; i++){
        num01[i][0] = n - num01[i][1];
    }
    // 贪心过程
    for(int j = maxsize - 1; j >= 0; j--){
        if(min(num01[j + 1][1], num01[j + 1][0]) * (1ll << j) > m){
            cout << -1 << "\n";
            fl = 1;
            break;
        }
    }
    if(fl == 1)continue;
    for(int j = maxsize; j >= 1; j--){
        if(num01[j][1] > num01[j][0])k = (k ^ (1ll << (j - 1)));
        qwq = qwq + min(num01[j][1], num01[j][0]) * (1ll << (j - 1));
    }
    if(qwq > m){
        cout << -1 << "\n";
        fl = 1;
    }
    if(fl == 1)continue;
    kmax = maxsize;
    for(int j = maxsize; ; j++){
        if(qwq + n * (1ll << j) <= m)kmax = j + 1;
        else break;
    }
    if(kmax > maxsize)k = (k ^ (1ll << (kmax - 1))), qwq += n * (1ll << (kmax - 1));
    for(int j = kmax; j >= 1; j--){
        if(!(k & (1ll << (j - 1)))){
            if(j > maxsize){
                if(qwq + n * (1ll << (j - 1)) <= m){
                    qwq += n * (1ll << (j - 1));
                    k = k ^ (1ll << (j - 1));
                }
            }else
            if(j <= maxsize){
                if(qwq + (num01[j][0] - num01[j][1]) * (1ll << (j - 1)) <= m){
                    qwq += (num01[j][0] - num01[j][1]) * (1ll << (j - 1));
                    k = k ^ (1ll << (j - 1));
                }
            }
        }
    }
    ```
- **作者：Rubidium_Chloride (4星)**
    - **关键亮点**：对算法分析详细，定义并解释了 \(s_{i,1}\) 和 \(s_{i,0}\) 表示 \(k\) 第 \(i + 1\) 位取 \(1\) 或 \(0\) 时该位提供的高能值总和，预处理数组 \(mn\) 判断方案可行性，代码结构清晰。
    ```cpp
    // 预计算2的次幂
    for(int i = 1;i <= 61;i++) p[i]=p[i - 1]*2;
    // 预先统计这一位能够获得多少高能值
    for(int i = 1;i <= n;i++){
        a[i]=read();
        for(int j = 0;j <= 51;j++) s[j][!((a[i]&p[j])>>(ll)j)]+=p[j];
    }
    // 统计前缀最小值的和
    mn[0]=min(s[0][0], s[0][1]);
    for(int i = 1;i <= 51;i++) mn[i]=min(s[i][0], s[i][1])+mn[i - 1];
    // 按位贪心
    ll solve(ll k){
        ll ans = 0,tot = 0;
        for(int i = 51;i >= 0;i--){
            if(tot + mn[i]>k) return -1;
            if(i && s[i][1]+mn[i - 1]+tot <= k){tot += s[i][1],ans += p[i];continue;}
            if(i && s[i][0]+mn[i - 1]+tot <= k){tot += s[i][0];continue;}
            if(!i && s[i][1]+tot <= k){return ans + 1;}
        }
        return ans;
    }
    ```
- **作者：Mophie (4星)**
    - **关键亮点**：提出两个常数优化点，一是先计算最优情况即消耗最小值，若 \(m\) 小于该最小值直接跳出；二是当 \(m\) 很大时，通过计算最小值与 \(m\) 的差值，判断是否可在高位放入数字，优化代码效率。
    ```cpp
    // 计算最小值
    cal[0]=min(p[0][0], p[0][1]);
    for(int i = 1;i <= qwq;i++)
        cal[i]=cal[i - 1]+min(p[i][0], p[i][1])*mult[i];
    // 处理m很大的情况
    if(m >= cal[qwq]+mult[qwq + 1]*n){
        kkk=(m - cal[qwq])/(n*mult[qwq + 1]);
        ans += kkk*mult[qwq + 1];
        m -= kkk*n*mult[qwq + 1];
    }
    // 普通贪心过程
    for(int i = qwq;i >= 0;i--){
        if(m - p[i][0]*mult[i]>=cal[i - 1])ans += mult[i],m -= p[i][0]*mult[i];
        else m -= p[i][1]*mult[i];
    }
    ```

### 最优关键思路或技巧
1. **按位贪心**：利用异或运算每位独立的特性，按二进制位从高到低贪心确定 \(k\) 的每一位，保证 \(k\) 最大且满足条件。
2. **预处理优化**：通过预处理统计 \(a_i\) 二进制每一位 \(1\) 的个数，计算每一位取 \(0\) 或 \(1\) 时的贡献及最小消耗，减少重复计算，提高效率。
3. **避免溢出**：对于可能出现的乘法溢出问题，采用化乘为除、位移操作或使用 `__int128` 类型等方法解决。

### 可拓展思路
此类题目通常围绕位运算和贪心策略展开。类似的算法套路还包括在其他位运算（如与、或等）场景下，利用按位处理的方式优化时间复杂度。同类型题一般会给定一些整数集合，通过位运算操作满足特定条件（如最大化、最小化结果等），解题时可优先考虑按位分析和贪心策略。

### 相似知识点洛谷题目
1. **P1876 [USACO06NOV]玉米田Corn Fields**：涉及状态压缩动态规划和位运算，通过二进制表示土地状态，按位处理判断是否满足条件。
2. **P2671 [NOIP2015 提高组] 求和**：需要运用位运算和前缀和思想，按位统计不同位上的贡献。
3. **P3164 [CQOI2014]危桥**：通过位运算标记不同路径状态，结合图论知识解决问题，考察对二进制状态的处理能力。 

---
处理用时：80.14秒
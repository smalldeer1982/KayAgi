# 题目信息

# 移花接木

## 题目背景


遥远的圣地生长着一棵不为人知的灵树，或有万山之高。

但有一日，藏匿于根系的腐朽力量爆发，灵树已无法支撑往日屹立冲天的高度。

## 题目描述

灵树最初的形态可以看作一棵高度为 ${10}^{{10}^{{10}^{10}}}$ 的满 $a$ 叉树，高度定义为根结点到叶子结点之间的边数。

受腐朽力量影响，灵树只能维持高度**恰好**为 $h$ 的满 $b$ 叉树形态。为了转换至该形态，灵树有两种魔法：

- 移花：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点），移除这条边以及以 $v$ 为根的**整棵子树**。
- 接木：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点）和一个结点 $w$（$w$ 不能是 $v$ 子树中或已移除的结点），将这条边原先 $u$ 一端**改接**到 $w$。**该魔法只能在根结点到** $\boldsymbol{u}$ **之间的边数** $\le 10^{10^{10}}$ **时使用。**

灵树累积的魔法力量有限，它不得不用最少次数的魔法完成转换。这是个漫长的过程，即使次数最少也会显得异常大，你只需要求出最少次数对 $10^9 + 7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**

下为 $a=1$，$b=2$，$h=1$ 时的两步转换过程，图中高度极大的冗余子树已用省略号代替。

![](https://cdn.luogu.com.cn/upload/image_hosting/p32s9v96.png)

可以证明，该数据的答案不可能低于 $2$。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (3 points)：$h = 0$。
- Subtask #2 (4 points)：$a = b$。
- Subtask #3 (8 points)：$a = 1$。
- Subtask #4 (8 points)：$b = 1$。
- Subtask #5 (17 points)：$h \le 10$。
- Subtask #6 (15 points)：$h \le 10^6$，各测试点存在 $\overline{a},\overline{b}$，其数据满足 $a=\overline{a}$，$b=\overline{b}$。
- Subtask #7 (15 points)：$h \le 10^6$。
- Subtask #8 (30 points)：无特殊限制。

所有测试点（样例除外）均含有 $10^6$ 组数据，即 $T = 10^6$。请务必采用较快的 IO（输入/输出）方式。

对于所有的数据，保证 $1 \le a,b \le 10^9$，$0 \le h \le 10^9$。

## 样例 #1

### 输入

```
2
1 2 1
3 2 1
```

### 输出

```
2
7
```

# AI分析结果

• 综合分析与结论：
    - 思路：各题解均通过分类讨论来解题，主要依据a和b的大小关系，同时针对h = 0、a = 1、b = 1等特殊情况单独分析。当a = b时，只需删除多余子树；a > b时，主要是删除操作，计算每层需删除的子树数量；a < b时，涉及接木和移花操作，通过合理安排减少操作次数。
    - 算法要点：利用快速幂计算幂次，等比数列求和公式计算相关和式，部分题解还用到逆元处理除法取模问题。
    - 解决难点：对于a < b的情况，如何通过合理贪心策略，用最少操作次数完成转换是难点。各题解通过分析每层需补充或删除的子树数量，结合操作特点得出最优解。
    - 总体来看，各题解思路相近，差异主要体现在表述清晰度、代码可读性及细节处理上。

所选的题解：
  - 作者：AsunderSquall (5星)
    - 关键亮点：思路清晰，对每个子任务分别详细分析，结合图形辅助理解，公式推导详细，代码简洁且有注释说明关键函数。
    - 个人心得：声明中提到分不清“结点”和“节点”，虽不影响解题但可看出作者严谨态度；还提到推出式子后被卡常，暗示优化代码的重要性。
    - 重点代码及核心思想：
```cpp
#include<bits/stdc++.h>
#define int long long
#define rd(x) x=read()
using namespace std;
const int mod=1e9+7;
inline int read(){int x=0,f=1;char ch=getchar();while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
int ksm(int x,int y,int z){int ret=1;while (y){if (y&1) ret=(ret*x)%z;x=(x*x)%z;y>>=1;}return ret;}
int INV(int x){return ksm(x,mod-2,mod);}
int a,b,h;
int T;
signed main()
{
    rd(T);
    while (T--)
    {
        rd(a);rd(b);rd(h);
        if (b==1) cout<<(((a-1)*h+a)%mod);else
		if (a<=b) cout<<ksm(b,h,mod)*a%mod;
        else cout<<(a*ksm(b,h,mod)%mod+(ksm(b,h,mod)-1)*(a-b)%mod*INV(b-1)%mod)%mod;
        putchar('\n');
    }
}
```
核心思想：通过快速幂函数ksm计算幂次，INV函数计算逆元。主函数中根据不同条件分支计算答案，简洁高效。

  - 作者：AuCloud (4星)
    - 关键亮点：用字符画辅助理解不同情况下的操作过程，公式推导详细，对每种情况分别给出思路和代码片段，整体结构清晰。
    - 个人心得：文中提到画图难，体现解决问题过程中寻找直观表达方式的不易，也强调了可视化对理解问题的帮助。
    - 重点代码及核心思想：代码略（文中未给出完整代码）。核心思想是对每种情况分别推导操作次数公式，如a = 1时，通过分析每层补齐分支数量推出总操作次数为\(b^h\)；a < b时，通过分析每层补分支和最后删除多余枝杈得出答案为\(a\times b^h\)等，并结合快速幂计算。

  - 作者：WarningQAQ (4星)
    - 关键亮点：分析部分对a >= b和a < b两种主要情况，详细列举每层操作次数，思路清晰，代码实现简洁明了，对特殊情况b = 1处理得当。
    - 个人心得：开头提到高度无穷是防止想多考虑嫁接是否够用，点明理解题意对解题的重要性。
    - 重点代码及核心思想：
```cpp
#include "cstdio"
#include "cctype"
#include "algorithm"
#define mod 1000000007
#define ll long long
ll ans, t, a, b, h;
char buffer[1 << 28], *S = buffer, puffer[1 << 28], *T = puffer;
inline ll read() {
    int x(0), f(0);
    while (!isdigit(*S))
        f |= (*S++ == '-');
    while (isdigit(*S))
        x = (x << 1) + (x << 3) + (*S++ ^ 48);
    return f? -x : x;
}
inline void write(ll x) {
    int num[28], sp = 0;
    if (x < 0)
        *T++ = '-', x = -x;
    if (!x)
        *T++ = 48;
    while (x)
        num[++sp] = x % 10, x /= 10;
    while (sp)
        *T++ = num[sp--] + 48;
}
inline ll power(ll x, ll y) {
    ll res = 1;
    while (y) {
        if (y & 1)
            res = res * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return res;
}
inline ll pomod(ll x) {
    return power(x, mod - 2);
}
int main() {
    fread(buffer, 1, 1 << 28, stdin);
    t = read();
    while (t--) {
        a = read(), b = read(), h = read();
        int k = power(b, h);
        if (a > b) {
            if (b == 1)
                write(((a - b)*h % mod + a * k % mod) % mod);
            else
                write(((a - b) * (k - 1) % mod * pomod(b - 1) % mod + a * k % mod) % mod);
        } else
            write(a * k % mod);
        *T++ = '\n';
    }
    fwrite(puffer, 1, T - puffer, stdout);
    return 0;
}
```
核心思想：通过自定义的read和write函数实现快速输入输出，power函数实现快速幂，pomod函数计算逆元。主函数根据a和b的关系及b是否为1的特殊情况计算并输出答案。

最优的关键思路或技巧：
 - 思维方式：通过分类讨论，将复杂问题拆解为不同简单情况分别处理，特别是依据a和b的大小关系，清晰界定不同操作策略。
 - 算法优化：利用快速幂优化幂次计算，等比数列求和公式简化和式计算，减少计算量。
 - 代码实现技巧：对于可能出现的除零情况（如b = 1时等比数列求和公式分母为0）进行特判处理，增强代码鲁棒性。

可拓展之处：同类型题通常涉及树形结构的变换操作及操作次数优化，类似算法套路是先分析不同条件下树结构的变化规律，再通过数学方法（如数列求和、递推公式等）计算操作次数。

推荐题目：
 - P1226 【模板】快速幂||取余运算，考察快速幂基本应用。
 - P3811 【模板】乘法逆元，练习逆元的求解及应用。
 - P1962 斐波那契数列，涉及递推公式与快速幂优化，与本题通过分析规律得出公式并优化计算的思路类似。 

---
处理用时：75.16秒
# 题目信息

# 『MdOI R4』Kotori

## 题目背景

『「因为」？所以呢？』

『因为我是你的妹妹，所以你要叫我别阻止你胡来么？』

『因为我是你的妹妹，所以你要叫我看着你赴死么？』

『因为我是你的妹妹，所以你要叫我默默看着你可能被杀死么？』

『不要开玩笑了，这算什么啊！还以为好不容易和平下来了，还以为士道终于不用再受伤了。』

『我——我不希望士道死掉，不想再看到士道受伤了，已经受不了再让士道感到痛苦了啊……』

『因为我——』

『喜欢士道呀——』

![](https://cdn.luogu.com.cn/upload/image_hosting/s0f5nxk0.png)

## 题目描述

一年一度的世界最萌大会开始了。作为曾经的「萌王」，Kotori 自然无需参赛。但她希望帮助自己的哥哥  Shido 获得「燃王」的头衔。

本届 ISML 共有 $n=2^k$ 名参赛选手，编号为 $1,2\ldots n$，其中 Shido 的编号是 $1$，赛制为淘汰赛。每一轮比赛之后剩余选手中编号最小的两人为对手，编号第 $3,4$ 小的两人为对手，依次类推。每场比赛的胜负取决于粉丝的投票数，获得票数较多的一方晋级下一轮比赛，票数较少的一方淘汰。

例如共有 $4$ 名选手，则第一轮编号为 $1,2$ 的选手进行一场比赛，编号 $3,4$ 的选手进行一场比赛，然后两场比赛的胜者进行一场比赛，争夺总冠军。获得总冠军的选手将获得「燃王」头衔。

每个角色有一个厨团，$i$ 号选手的厨团人数为 $a_i$。每轮投票时，所有厨团的成员**会且仅会**为对应的选手投票。

此外，Kotori 拥有一个人数为 $m$ 人的团队，他们会永远跟随 Kotori 投票。也就是说，每场比赛 Kotori 都可以为对战双方的任意一者增加 $m$ 张得票。注意在一轮比赛中可能有多场比赛，每场比赛一定只有两名选手。

另外，Kotori 还拥有一项特权：当某场比赛双方的票数相同时，作为萌王的她可以决定这场比赛的胜者。

现在，Kotori 希望知道，她是否有能力帮助哥哥成为冠军，获得「燃王」的头衔。

## 说明/提示

【样例解释 #1】

对于 $1$ 组数据，并不存在让 Shido 成为燃王的方案。

对于第 $2$ 组数据，考虑以下方案：

第 $1$ 轮：
- $1$ 号和 $2$ 号比赛，把票给 $1$ 号，$2$ 号淘汰。
- $3$ 号和 $4$ 号比赛，把票给 $3$ 号，$4$ 号淘汰。
- $5$ 号和 $6$ 号比赛，把票给 $6$ 号，$5$ 号淘汰。
- $7$ 号和 $8$ 号比赛，把票给 $7$ 号，$7$ 号淘汰。

第 $2$ 轮：
- $1$ 号和 $3$ 号比赛，把票给 $1$ 号，$3$ 号淘汰。
- $6$ 号和 $8$ 号比赛，把票给 $6$ 号，$8$ 号淘汰。

第 $3$ 轮：
- $1$ 号和 $6$ 号比赛，把票给 $1$ 号，$6$ 号淘汰。

【数据规模与约定】

**本题采用捆绑测试**

| 子任务编号 | $k\le$    |$\sum n\le$ | $m\le $    | 分值  |
| -----|------ | ---------- | ---------- | ----- |
| $1$        | $0$  |$1$      | 无特殊限制 | $1$   |
| $2$        | $1$     |$2^{11}$   | 无特殊限制 | $9$   |
| $3$        | $4$  |$2^{14} $     | 无特殊限制 | $15$  |
| $4$        | 无特殊限制 |$2^{20}$| $0$        | $10 $ |
| $5$        | $9$   |   $2^{11}$| 无特殊限制 | $20$  |
| $6$        | $15$   |$2^{17}$    | 无特殊限制 | $20$  |
| $7$        | $18$   |$2^{20} $   | 无特殊限制 | $25$  |

对于 $100\%$ 的数据，$\sum n\le 2^{20}$，$0\le k\le 18$，$0\le m,a_i\le 10^9$。

【提示与帮助】

本题读入量较大，请选手选择较快的读入方式。

本题中的“世界最萌大会”与真正的“世界最萌大会”有所不同，在本题中请以本题为准。

## 样例 #1

### 输入

```
3
3 6
2 0 0 5 0 9 0 9
3 6
2 0 5 0 0 5 0 9
2 6
2 0 0 5
```

### 输出

```
Yoshino
Kotori
Kotori
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何判断在给定的淘汰赛制和特殊条件下，1号选手能否获胜。大部分题解意识到贪心策略不可行，主要采用分治思想来解决问题。不同题解在实现细节和优化方式上有所差异，有的通过递归合并区间胜者，有的使用动态规划转移状态，还有的利用归并排序辅助处理数据。

### 所选的题解
- **作者：BFqwq (4星)**
    - **关键亮点**：按子任务逐步分析，从简单情况入手，思路清晰，详细阐述了从暴力搜索到分治优化的过程，易于理解。
    - **个人心得**：无
    - **核心代码实现思想**：对于Subtask 3，直接爆搜每场比赛所有可能结果；Subtask 4，在m = 0时模拟比赛过程；Subtask 5，递归求出每个子区间所有可能胜者并存储，通过枚举右子区间判断左子区间胜者是否可行；Subtask 6 - 7，利用归并排序优化，每次删除最小不满足条件的选手，合并区间，以O(nlogn)复杂度解决问题。
```cpp
// 以Subtask 6 - 7归并排序优化部分核心代码示意
// 假设a数组存选手票数，b数组存子区间胜者在a数组的下标，c数组为归并辅助数组
int merge(int l, int r) {
    if (l == r) return 1;
    int mid = (l + r) >> 1;
    int tl = merge(l, mid) + l - 1;
    int tr = merge(mid + 1, r) + mid;
    int nl = l, nr = mid + 1;
    if (a[b[nl]] < a[b[nr]]) {
        while (nl <= tl && a[b[nl]] + k < a[b[nr]]) nl++;
    } else {
        while (nr <= tr && a[b[nr]] + k < a[b[nl]]) nr++;
    }
    int top = l - 1;
    while (nr <= tr && nl <= tl) {
        if (a[b[nl]] < a[b[nr]]) c[++top] = b[nl++];
        else c[++top] = b[nr++];
    }
    while (nl <= tl) c[++top] = b[nl++];
    while (nr <= tr) c[++top] = b[nr++];
    for (int i = l; i <= top; i++) b[i] = c[i];
    return top - l + 1;
}
```
- **作者：Caesium (4星)**
    - **关键亮点**：先介绍分治概念，结合题目详细分析分治策略的应用，代码注释详细，对分治与其他算法的对比有清晰阐述。
    - **个人心得**：考试时想贪心未做出，考完才做出，强调了本题贪心不可行。
    - **核心代码实现思想**：通过分治递归分割区间，在合并区间时，利用归并排序的过程，同时判断每个子区间的胜者能否在当前区间胜出，最终判断1号选手是否在所有可能胜者中。
```cpp
// 主归并函数
int merge(int l, int r) {
    if (l == r) {
        return 1;
    }
    int mid = (l + r) >> 1;
    int tl = merge(l, mid) + l - 1;
    int tr = merge(mid + 1, r) + mid;
    int nl = l, nr = mid + 1;
    if (a[b[nl]] < a[b[nr]]) {
        while (nl <= tl && a[b[nl]] + k < a[b[nr]]) {
            nl++;
        }
    } else {
        while (nr <= tr && a[b[nr]] + k < a[b[nl]]) {
            nr++;
        }
    }
    int top = l - 1;
    while (nr <= tr && nl <= tl) {
        if (a[b[nl]] < a[b[nr]]) {
            c[++top] = b[nl++];
        } else {
            c[++top] = b[nr++];
        }
    }
    while (nl <= tl) {
        c[++top] = b[nl++];
    }
    while (nr <= tr) {
        c[++top] = b[nr++];
    }
    for (int i = l; i <= top; i++) {
        b[i] = c[i];
    }
    return top - l + 1;
}
```
- **作者：Warriors_Cat (4星)**
    - **关键亮点**：使用动态规划，定义状态简洁明了，通过枚举对局次数和组内选手，利用每次取票数最少的优胜者这一结论进行状态转移，代码量小且思路清晰。
    - **个人心得**：无
    - **核心代码实现思想**：定义DP状态$f_{i, j}$表示在第$i$次对局中，$j$这个人是否能胜利。通过枚举对局次数$i$，对于每一组，处理出所有可能优胜者中票数最少的那个票数，再枚举每个人判断能否战胜对手，实现状态转移，最后判断$f_{k, 0}$是否为1。
```cpp
// 核心DP过程
rep(i, 0, k - 1) {
    int t = (1 << i);
    rep(j, 0, n / t - 1) d[j] = 0x7f7f7f7f;
    rep(j, 0, n / t - 1) rep(o, 0, t - 1) {
        if (f[i][j * t + o]) d[j] = min(d[j], a[j * t + o]);
    }
    rep(j, 0, n / t - 1) rep(o, 0, t - 1) {
        if (f[i][j * t + o] && a[j * t + o] + m >= d[j ^ 1]) f[i + 1][j * t + o] = 1;
    }
}
```

### 最优关键思路或技巧
1. **分治思想**：将问题不断分割为子问题，在本题中通过递归处理每个区间的可能胜者，最后合并结果。利用归并排序辅助合并区间，能同时完成排序和判断胜者的操作，优化时间复杂度。
2. **动态规划**：合理定义状态，如$f_{i, j}$表示第$i$次对局中$j$能否胜利，通过分析状态转移条件，利用每次选择票数最少的优胜者这一特性，高效解决问题。

### 同类型题或类似算法套路拓展
同类型题通常围绕比赛晋级、区间合并等场景，可考虑分治、动态规划方法。类似算法套路有：
1. 对于具有明显层次结构或可分割性的问题，优先考虑分治策略，递归处理子问题并合并结果。
2. 当问题存在重叠子问题和最优子结构性质时，动态规划是有效的解决方法，关键在于定义合适的状态和状态转移方程。

### 推荐题目
1. **P1229 遍历问题**：涉及二叉树遍历和状态转移，可通过分治或动态规划解决，与本题在利用子问题结果合并求解上思路相似。
2. **P1880 [NOI1995] 石子合并**：经典的区间动态规划题目，通过合并区间元素求最优值，和本题分治合并区间判断结果的思路有相通之处。
3. **P3146 [USACO16OPEN]248 G**：同样是区间合并问题，利用动态规划记录区间合并结果，与本题在处理区间相关问题上技巧类似。 

---
处理用时：75.55秒
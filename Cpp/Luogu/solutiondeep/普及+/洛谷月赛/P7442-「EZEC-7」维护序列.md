# 题目信息

# 「EZEC-7」维护序列

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/lo9tuyl9.png)](https://www.luogu.com.cn/paste/tdqr0sto)

可怜的 dead_X 收不了歌，于是他出了个水题并给参赛者送了 $100$ 分。

2022 Update: 已经收了，很水。

## 题目描述

你需要维护一个序列。

这个序列开始时有 $2^n$ 个数，下标从 $0$ 开始。第 $i$ 个数初始值为 $i$，需要支持以下三种操作：

* 定义 $a$ 为所有下标为偶数的数组成的子序列，$b$ 为所有下标为奇数的数组成的子序列，将 $a,b$ 连接，构成新的序列。
* 定义 $a$ 为所有下标为奇数的数组成的子序列，$b$ 为所有下标为偶数的数组成的子序列，将 $a,b$ 连接，构成新的序列。
* 查询下标为 $x$ 的数。

总共将进行 $m$ 次操作。

## 说明/提示

**【样例解释】**

所有操作前后的序列从左至右的数如下：
$$\{0,1,2,3\}$$
下标为 $0$ 的数为 $0$。
$$\{0,2\},\{1,3\}$$
$$\{0,2,1,3\}$$
下标为 $1$ 的数为 $2$。
$$\{2,3\},\{0,1\}$$
$$\{2,3,0,1\}$$
下标为 $2$ 的数为 $0$。
$$\{2,0\},\{3,1\}$$
$$\{2,0,3,1\}$$
下标为 $3$ 的数为 $1$。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（10 points）：不存在 $op=1$ 的操作。
- Subtask 2（10 points）：$n\leq 10，m\leq 10^3$。
- Subtask 3（20 points）：$n\leq 10$。
- Subtask 4（20 points）：$m\leq 10^3$。
- Subtask 5（20 points）：对于 $op=1$ 的操作，$x=0$。
- Subtask 6（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 32$，$1\leq m\leq 10^6$。

若 $op=1$，$x\in\{0,1\}$，若 $op=2$，$0\leq x<2^n$。

## 样例 #1

### 输入

```
2 7
2 0
1 0
2 1
1 1
2 2
1 0
2 3```

### 输出

```
0
2
0
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕对序列操作规律的挖掘，通过观察操作对下标的影响，利用二进制位运算特性来优化计算，避免直接维护庞大序列导致的超时问题。各题解思路相近，均从操作对下标的变换入手，以位运算和记录操作状态实现高效查询。

### 所选的题解
- **作者：0x3F（5星）**
    - **关键亮点**：思路清晰，对两种操作的二进制规律分析透彻，明确指出操作一是将二进制首位移到末位，类似环的逆时针旋转一格；操作二是在此基础上对末位异或1。代码简洁高效，使用位运算实现，时间复杂度为 Θ(m)，并注意到数据范围使用 `unsigned int`。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, o;
unsigned x, y;

inline unsigned read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}

inline void write(unsigned x)
{
    if(x>9) write(x/10);
    putchar(x%10+48);
}

int cnt;
int main() {
	n = read();
	m = read();
	while (m--) {
		o = read();
		x = read();
		if (o == 1) {
			if (x) {
				y = y ^ (1<<cnt);
			}
			cnt++;
			if (cnt == n) cnt = 0;
		} else {
			if (cnt) write(((x>>(n-cnt))|((x&((1<<(n-cnt))-1))<<cnt))^y);
			else write(x^y);
			putchar(10);
		}
	}
	return 0;
}
```
    - **核心实现思想**：用 `cnt` 记录操作1的旋转次数，`y` 记录操作2需要异或的值。操作1根据 `x` 值决定是否对 `y` 进行异或操作并更新 `cnt`；查询操作根据 `cnt` 值对 `x` 进行位运算并与 `y` 异或后输出。

- **作者：dead_X（4星）**
    - **关键亮点**：先针对不同子任务给出简单思路，后深入分析操作对下标变化的规律，将下标变化抽象为环结构，通过指针思想和异或操作维护。代码实现简洁明了，有效代码长度短。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define ull unsigned long long 
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline ull read64()
{
	ull s=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9') s=s*10+(ch&15),ch=getchar();
    return s;
} 
signed main()
{
	int n=read(),m=read(),cnt=0;
	ull t=0,g=(1ull<<n)-1;
	for(;m--;)
	{
		int op=read();
		ull x=read64();
		if(op==1) (x==1)&&(t^=1ull<<(cnt%n)),(++cnt>=n)&&(cnt-=n);
		else printf("%llu\n",(((x+(x<<n))>>((n-cnt)%n))&g)^t);
	}
    return 0;
}
```
    - **核心实现思想**：`cnt` 记录操作1次数，`t` 记录异或值。操作1根据 `x` 判断是否更新 `t` 并调整 `cnt`；查询操作通过位运算将 `x` 还原并与 `t` 异或后输出。

- **作者：water_tomato（4星）**
    - **关键亮点**：详细解析操作实质，对二进制下标的变换描述清晰，通过提前处理全1数简化位运算，代码注释详细，便于理解。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=60;
int n,m,t[N],v,x,opt,cnt;
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) t[i]=(t[i-1]<<1)+1;
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&opt,&x);
		if(opt==1){
			v^=x<<cnt;
            cnt++;
			if(cnt==n) cnt=0;
		}
		else{
			printf("%lld\n",(((x&t[n-cnt])<<cnt)|(x>>(n-cnt)))^v);
		}
	}
	return 0;
}
```
    - **核心实现思想**：用 `t` 数组提前处理全1数，`cnt` 记录操作1次数，`v` 记录异或标记。操作1更新 `v` 和 `cnt`；查询操作通过与 `t` 数组配合位运算还原 `x` 并与 `v` 异或后输出。

### 最优关键思路或技巧
将序列操作转化为二进制下标的位运算，通过记录操作次数和异或值，避免直接维护序列，从而优化时间复杂度。利用位运算特性，如循环移位和异或操作，高效实现下标变换的还原。

### 可拓展思路
此类题目可拓展到其他涉及序列重排并查询的场景，关键在于挖掘操作对下标的数学规律，利用位运算、数组记录等方式优化。类似算法套路可应用于一些数据位置变换后查询的问题，通过分析变换规律，建立映射关系来解决。

### 相似知识点洛谷题目
- [P1096 明明的随机数](https://www.luogu.com.cn/problem/P1096)：涉及数据的去重与排序，可类比本题对数据位置的处理思路。
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：通过归并排序等方法统计逆序对，与本题挖掘操作规律优化计算有相似思维方式。
- [P3377 【模板】左偏树（可并堆）](https://www.luogu.com.cn/problem/P3377)：在维护数据结构时利用特定性质优化操作，与本题利用位运算优化序列操作类似。

### 个人心得摘录与总结
 - **作者：0x3F**：最开始认为本题较难，花费半小时解题，却在5分钟内解出后续题目。启示在解题时不能因初始困难而放弃，需深入思考挖掘规律。 

---
处理用时：71.02秒
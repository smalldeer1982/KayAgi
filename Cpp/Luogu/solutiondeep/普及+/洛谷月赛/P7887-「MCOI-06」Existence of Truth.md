# 题目信息

# 「MCOI-06」Existence of Truth

## 题目描述

可能存在一个非负整数数序列 $a_1,a_2,\dots,a_n$ 使得 $0\le a_i<10^9+7$。

给定 $x_1,x_2,\dots,x_n$，$y_1,y_2,\dots,y_n$，$z_1,z_2,\dots,z_n$，已知对于 $1\le i\le n$ 满足：

$$x_i\left(\sum_{j=1}^ia_j\right)+y_i\left(\sum_{j=i}^na_j\right)\equiv z_i\pmod{10^9+7}$$

求 $a_1,a_2,\dots,a_n$。

## 说明/提示

#### 数据规模与约定

**本题采用捆绑测试。**

 - Subtask 1（10 pts）：$n=1$。
 - Subtask 2（19 pts）：$\sum n\le100$。
 - Subtask 3（19 pts）：$x_i=y_i=1$。
 - Subtask 4（22 pts）：保证有**唯一解。**
 - Subtask 5（30 pts）：无特殊限制。

对于所有数据：

 - $1\le n,\sum n\le 2\times10^5$；
 - $1\le x_i,y_i<10^9+7$；
 - $0\le z_i<10^9+7$。

## 样例 #1

### 输入

```
2
3
3 1 9
2 2 16
1 3 15
6
3 6 246
5 7 283
2 7 179
4 6 214
8 7 337
3 5 151```

### 输出

```
1
1 2 3
1
8 8 0 6 7 8```

# AI分析结果

### 综合分析与结论
1. **思路对比**：
    - **一只书虫仔**：通过引入前缀和\(S_i\)将原方程转化，推导出\(S_i\)关于\(a_1\)的线性表达式\(A_ia_1 + B_i\)，通过对\(a_1\)的特殊情况分类讨论得出解的情况。
    - **TonyYin**：针对不同子任务采用不同方法。\(n = 1\)时直接解方程并分类讨论；\(x_i = y_i = 1\)时通过方程相加求出总和再代入求解；\(n\leq100\)时用高斯消元；保证唯一解时利用前缀和简化系数矩阵消元；最后对所有数据综合处理并判断解的个数。
    - **Remake_**：先对式子变形，通过相邻式子差分，将\(a_i\)逐步表示为\(ka_1 + b\)的形式，最后代入化简得到关于\(a_1\)的方程，分类讨论得出解的情况。
2. **算法要点**：
    - **一只书虫仔**：主要是前缀和的运用以及线性表达式系数的推导。
    - **TonyYin**：针对不同数据范围合理运用解方程、高斯消元等方法。
    - **Remake_**：式子变形、差分以及递推表示\(a_i\)。
3. **解决难点**：
    - 难点在于处理含有多个未知数且与区间和相关的同余方程。
    - **一只书虫仔**通过前缀和转化方程，简化形式来求解。
    - **TonyYin**针对不同子任务特点，利用特殊性质或高斯消元来突破。
    - **Remake_**通过差分和递推将复杂方程转化为关于一个未知数的方程求解。

4. **评分**：
    - **一只书虫仔**：思路较清晰，但缺少代码，对一些推导步骤解释稍欠详细，3星。
    - **TonyYin**：思路清晰，针对不同子任务逐步分析，代码完整且有注释，4星。
    - **Remake_**：思路有创新性，但表述稍显口语化，推导过程细节可更完善，3星。

综合来看，TonyYin的题解质量较高，不仅思路清晰，还针对不同子任务详细阐述并给出完整代码。

### 所选的题解
#### TonyYin - 4星
- **关键亮点**：针对不同数据范围的子任务分别给出有效解法，从简单到复杂逐步推进，最后综合处理所有数据。代码实现完整且有注释，可读性强。
- **个人心得**：提到在处理多组测试数据时，对\(n = 1\)的情况若不分类讨论可能会被卡且难以排查错误。

#### 重点代码及核心实现思想
```cpp
// 计算快速幂
inline int power(int x, int k) {
    int ret = 1;
    while(k) {
        if(k & 1) ret = ret * x % mod;
        x = x * x % mod;
        k >>= 1;
    }
    return ret;
}
// 计算乘法逆元
inline int inv(int x) {return power(x, mod - 2);}

// 主函数部分
signed main() {
    T = read();
    while(T--) {
        n = read();
        for(int i = 1; i <= n; i++) {
            x[i] = read(); y[i] = read(); z[i] = read();
        }
        //对每个x,y,z，x[i]s[i] - y[i]s[i-1] + y[i]s[n] = z[i]
        for(int i = 1; i < n; i++) {
            a[i] = mod - y[i]; b[i] = x[i]; c[i] = y[i];
        } 
        a[n] = mod - y[n]; c[n] = (x[n] + y[n]) % mod;
        // 高斯消元解前缀和
        for(int i = 1; i < n; i++) {
            int k = a[i + 1] * inv(b[i]) % mod;
            (a[i + 1] -= k * b[i] % mod) %= mod;
            (c[i + 1] -= k * c[i] % mod) %= mod;
            (z[i + 1] -= k * z[i] % mod) %= mod;
        }
        int roots = 1;
        if(c[n] == 0 && z[n]!= 0) {
            putchar('0'); putchar('\n');
            continue;
        }
        else if(c[n] == 0 && z[n] == 0) roots = mod;
        else s[n] = z[n] * inv(c[n]) % mod;
        // 根据消元结果判断解的情况并求解
        for(int i = 1; i <= n - 1; i++) {
            int right = (z[i] - c[i] * s[n] % mod) % mod;
            if(b[i] == 0 && right!= 0) {roots = 0; break;}
            else if(b[i] == 0 && right == 0) roots += mod;
            else s[i] = ((z[i] - c[i] * s[n] % mod) * inv(b[i]) % mod + mod) % mod;
        }
        if(roots!= 1) {printf("%lld\n", roots); continue;}
        else {putchar('1'); putchar('\n');}
        for(int i = 1; i <= n; i++) 
            printf("%lld ", ((s[i] - s[i - 1]) % mod + mod) % mod);
        putchar('\n');
    }
    return 0;
}
```
核心实现思想：先预处理方程系数，然后通过高斯消元法将方程化为上三角形式，根据最后一行系数和常数项判断解的情况，若有唯一解则回代求解前缀和数组\(s\)，进而得到\(a_i\)的值。

### 最优关键思路或技巧
1. **针对不同数据范围采用不同策略**：如\(n = 1\)时直接解方程，\(x_i = y_i = 1\)时利用方程相加的特殊性质，这种对数据特点的挖掘和利用能简化问题求解。
2. **利用前缀和简化方程**：将原方程通过前缀和转化，减少每个方程中未知数的数量，使系数矩阵更有规律，便于高斯消元。

### 可拓展之处
同类型题或类似算法套路：此类题目通常涉及多个未知数的线性同余方程，可拓展到其他需要处理线性方程组或利用区间和性质的题目。类似算法套路包括利用特殊条件简化方程（如系数相等、特定区间和关系等），以及运用高斯消元、矩阵运算等方法求解。

### 推荐题目
1. **P3389 【模板】高斯消元法**：经典的高斯消元模板题，用于巩固高斯消元的基本实现。
2. **P2455 [SDOI2006]线性方程组**：通过解线性方程组判断解的情况，与本题部分思路相似。
3. **P1313 计算系数**：结合二项式定理和线性方程求解，锻炼综合运用知识解决问题的能力。 

---
处理用时：63.50秒
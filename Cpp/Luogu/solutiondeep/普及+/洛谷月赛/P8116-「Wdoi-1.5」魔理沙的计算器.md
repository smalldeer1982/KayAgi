# 题目信息

# 「Wdoi-1.5」魔理沙的计算器

## 题目背景

魔理沙是普通而平凡的魔法使。在解决了大大小小的异变后，她终于攒足了足够多的钱在香霖堂里购置了一台 $\verb!Carno!$ 计算器，用来计算魔女之汤各种配料的含量之比。

魔理沙早就听闻灵梦通过河童重工网络[入手了一部 $\verb!Casio!$ 计算器](https://www.luogu.com.cn/problem/P5515)，来计算神社的香火钱，却买到了假货，最多只能显示整数部分（下取整）。而魔理沙的这部可以精确到小数点后面若干位（下取整）的计算器。更高级的是，这部计算器还可以支持其他的进制，其强大的功能高出了灵梦一大截。因此作为灵梦真挚的朋友，魔理沙希望向灵梦表达真挚的遗憾之情。

正当魔理沙打算出发之时，她发现虽然 $\verb!Carno!$ 计算器不会导致一些特别大的误差，但是在计算除法时仍然会出现一定的问题。考虑将计算器的进制调整为 $10$ 进制，而计算器屏幕上最多可以显示 $5$ 位数字（小数点不计入显示位数）。比如，魔理沙希望计算 $1\div 3$ 的值，那么真正显示在屏幕上的则是：

$$
0.3333
$$

按照道理上来讲，$1\div(1\div 3)$ 结果应当等于 $3$。但出乎意料的是，当魔理沙输入 $1\div 0.3333$ 后，得到的结果却是：

$$
3.0003
$$

这当然只是一个个例。当魔理沙计算 $1\div(1\div 4)$ 时，屏幕上显示出了正确的数字。

为了防止在表达遗憾之情的时候自己的计算器也出了漏子，魔理沙希望找到有多少个数字使得计算出的结果是正确的，因此她向你求助了。

## 题目描述

魔理沙的计算器可以进行 $b$ 进制的运算，屏幕上可以显示 $k$ 个数字（不包含小数点）。进行计算后，若某个数字超出了屏幕，就会被**直接舍去**（例如 $b=10$ 时 $1\div 7=0.142857\cdots$，若屏幕大小为 $4$，那么最终显示为 $0.142$）。

魔理沙用计算器计算了 $1\div n=n'$，再计算 $1\div n'=n''$（$n'$ 和 $n''$ 均为显示在屏幕上的结果）。魔理沙希望知道，有多少个正整数 $n$ 使得 $n=n''$。你只需要输出这个答案对 $998,244,353$ 取模后的结果即可。

## 说明/提示

### 样例解释

- 对于第一组询问，符合条件的数（转换成十进制）为 $1,2,4$。
- 对于第二组询问，符合条件的数（转换成十进制）为 $1,5,25$。

### 数据范围及约定

$$
\def{\arraystretch}{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{subtask}&\textbf{分值} & \bm{b\le} & \bm {k\le } & \textbf{特殊性质} & \textbf{subtask 依赖} \cr\hline
1 & 20 & 10 & 7 & - &-\cr\hline
2 & 20 & 10^5 & 2 & k=2&-\cr\hline
3 & 10 & 10^5 & 3 & k=3&- \cr\hline
4 & 50& 10^5 & 500 & -&1,2,3\cr\hline
\end{array}
$$

对于 $100\%$ 的数据，满足 $1\le T\le 10$，$2\le b\le 10^5$，$1\le k\le 500$。

## 样例 #1

### 输入

```
3
4 2
5 3
12 99```

### 输出

```
3
3
19503```

# AI分析结果

• 综合分析与结论：
    - 思路：多数题解先得出满足\(n'' = n\)的条件是\(n \mid b^{k - 1}\)，然后通过对\(b\)分解质因数，根据乘法原理计算\(b^{k - 1}\)的因子数得到答案。不同之处在于对\(n \mid b^{k - 1}\)这个结论的证明方式。
    - 算法要点：核心是质因数分解和利用乘法原理计算因子个数。通过对\(b\)从\(2\)到\(\sqrt{b}\)遍历进行质因数分解，再根据\(b^{k - 1}\)中各质因子指数计算因子个数并对\(998244353\)取模。
    - 解决难点：难点在于证明\(n \mid b^{k - 1}\)与\(n'' = n\)的等价性。不同题解从不同角度证明，如通过分析计算过程中舍去部分的值、从有限小数的性质出发、利用等式变换等。

    - 整体来看，各题解思路较为集中，主要差异在证明过程的严谨性和表述清晰度上。

- 所选的题解：
  - 作者：囧仙 (5星)
    - 关键亮点：思路清晰，先给出核心结论，然后通过证明引理，分情况详细论证结论的正确性，逻辑连贯，代码简洁明了。
    - 重点代码核心实现思想：通过`qread`函数读取输入，对每个测试用例，从\(2\)到\(\sqrt{b}\)遍历分解\(b\)的质因数，计算每个质因数的指数\(c\)，根据公式`ans = 1ll * ans * ((k - 1) * c + 1) % MOD`计算因子个数，若\(b\)分解完不为\(1\)，再对结果乘以\(k\)取模。
```cpp
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(){
    up(1,qread(),T){
        int b=qread(),k=qread(),ans=1;
        if(k==1){puts("1");continue;}
        for(int i=2;i*i<=b;++i){
            int c=0; while(b%i==0) ++c,b/=i; ans=1ll*ans*((k-1)*c+1)%MOD;
        }
        if(b!=1) ans=1ll*ans*k%MOD; printf("%lld\n",ans);
    }
    return 0;
}
```
  - 作者：minstdfx (4星)
    - 关键亮点：对核心结论给出了严格证明，特别是在引理证明和必要性证明部分，通过详细的等式推导和逻辑分析，使证明过程严谨。同时提供了一种不同实现方式的代码。
    - 重点代码核心实现思想：代码通过预处理计算出\(1\)到\(n\)每个数的某种与因子个数相关的值`gs`，在主函数中读取输入，调用预处理函数，输出对应\(n\)的`gs`值。虽然代码未详细解释`gs`含义，但整体提供了一种不同思路的实现。
```cpp
void init(int n,int k)
{
    pt=0;
    gs[1]=1;
    for(int i=2;i<=n;++i)
    {
        if(!v[i]) // prime 
        {
            v[i]=i;
            p[++pt]=i;
            gs[i]=k;
        }
        for(int j=1;j<=pt && i*p[j]<=n;++j)
        {
            v[i*p[j]]=p[j];
            if(i%p[j]==0){
                gs[i*p[j]]=gs[i]*2+mod-gs[i/p[j]];
                gs[i*p[j]]%=mod;
                break;
            }
            gs[i*p[j]]=gs[i]*gs[p[j]]%mod;
        }
    }
} 
signed main()
{
    int n,k,t;
    fio>>t;
    while(t--)
    {
        fio>>n>>k;
        pt=0;
        memset(gs,0,sizeof(gs));
        memset(v,0,sizeof(v));
        init(n,k); 
        fio<<gs[n]<<_fios::endl;
    }
}
```
  - 作者：Yusani_huh (4星)
    - 关键亮点：从感性角度出发，先通过具体例子说明无限小数不满足条件，缩小范围到能得到有限小数的数，再形式化描述并转化问题为求\(b^{k - 1}\)的因子个数，思路自然，容易理解。
    - 重点代码核心实现思想：通过`scanf`读取输入，对每个测试用例，从\(2\)到\(\sqrt{b}\)遍历分解\(b\)的质因数，记录每个质因数的指数`h[ct]`，计算\(b^{k - 1}\)的因子个数并对\(998244353\)取模。
```cpp
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d%d",&b,&k);
        LL ans=1;
        int a=b,ct=0;
        for(int i=2;i*i<=b;++i)
            if(a%i==0){
                ct++;
                while(a%i==0) a/=i,h[ct]++;
                h[ct]=h[ct]*(k-1)%MOD;
            }
        if(a>1) h[++ct]=k-1;
        for(int i=1;i<=ct;++i)
            ans=ans*(h[i]+1)%MOD,h[i]=0;
        printf("%lld\n",ans);
    }
    return 0;
}
```
• 最优关键思路或技巧：
    - 思维方式上，通过分析计算器显示特性，将问题转化为数学上判断\(n\)与\(b^{k - 1}\)的整除关系，从而简化问题。
    - 算法实现上，利用质因数分解和乘法原理计算因子个数是高效解决问题的关键。

• 可拓展之处：
    - 同类型题常考察在不同进制下，对数值运算结果的分析和处理，类似算法套路是将问题转化为整数的整除关系或质因数分解等数学问题求解。

• 推荐题目：
    - P1072 [NOIP2009 普及组]  Hankson 的趣味题，考察数论中最大公约数和最小公倍数相关知识，与本题类似需分析数的整除关系。
    - P2568 GCD，通过对质因数分解的运用来解决最大公约数相关问题，和本题在质因数分解运用上类似。
    - P3390 【模板】矩阵快速幂，虽涉及矩阵运算，但在算法实现和对问题的分析转化上，与本题有相似之处，都需要通过一定的数学分析找到高效解法。

• 个人心得：无。 

---
处理用时：74.41秒
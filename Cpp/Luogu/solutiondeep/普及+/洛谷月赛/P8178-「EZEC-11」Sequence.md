# 题目信息

# 「EZEC-11」Sequence

## 题目描述

已知数列 $f$ 满足 $f_n=a_nf_{n-1}+b_n\ (n\ge 1)$。

问是否存在非负整数 $f_0$，使得 $\forall 1\le i\le k$，$f_i$ 为**质数** $p_i$ 的倍数。

## 说明/提示

**【样例 1 解释】**

对于第一组测试数据，一个可行的解为 $f_0=1$，此时 $f_1=3,f_2=5,f_3=7$。

对于第二组测试数据，没有满足条件的 $f_0$。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（10 points）：$k=1$。
-  Subtask 2（20 points）：$k\le 2$。
-  Subtask 3（20 points）：$k\le 5$，$p_i\le 20$。
-  Subtask 4（50 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le 10$，$1\le k\le 10^3$，$0\le a_i,b_i\le 10^9$，$2\le p_i\le 10^9$，**$p$ 为质数**。

## 样例 #1

### 输入

```
2
3
1 1 1
2 2 2
3 5 7
3
1 1 1
2 2 2
3 3 3```

### 输出

```
Yes
No```

# AI分析结果

• 综合分析与结论：这些题解的核心思路都是将数列递推式转化为关于\(f_0\)的同余方程，通过判断同余方程是否有解来确定是否存在满足条件的\(f_0\)。算法要点在于利用递推关系求出同余方程的系数和常数项，难点在于处理系数为\(0\)的情况以及判断不同模数下方程解的一致性。

所选的题解：
  - Sky_Maths (5星)
    - 关键亮点：思路清晰，逐步优化，从暴力枚举到利用递推关系优化，再到处理系数为\(0\)的情况，最后通过判断模数相同情况下解的一致性得出结论。代码实现简洁明了，注释详细。
    - 个人心得：无
    - 重点代码核心实现思想：通过两层循环递推求出\(c_i\)和\(d_i\)，并对系数为\(0\)的情况进行特殊处理，利用扩展欧几里得算法求逆元，最后通过哈希表判断模数相同情况下解是否一致。
```cpp
for(int i=1; i<=n; i++) {
    c[i]=1;
    d[i]=0;
    for(int j=1; j<=i; j++) {
        c[i]=c[i]*a[j]%p[i];
        d[i]=(d[i]*a[j]+b[j])%p[i];
    }
    if(!c[i]&&d[i]) {
        puts("No");
        flag=1;
        break;
    }
    if(!c[i]) {
        p[i]=1e9;
        d[i]=1e9;
        continue;
    }
    int t;
    exgcd(c[i],p[i],c[i],t);
    d[i]=(((-d[i])%p[i]+p[i])%p[i])*c[i]%p[i];
    d[i]=(d[i]+p[i])%p[i];
}
if(!flag) {
    for(int i=1; i<=n; i++) {
        if(ma[p[i]]&&ma[p[i]]!=d[i]+1) {
            puts("No");
            break;
        } else {
            ma[p[i]]=d[i]+1;
        }
        if(i==n) {
            puts("Yes");
        }
    }
}
```
  - BqtMtsZDnlpsT (4星)
    - 关键亮点：同样清晰地将原问题转化为同余方程组问题，利用快速幂求逆元，通过离散化质数方便统计模数相同的方程，代码结构清晰。
    - 个人心得：无
    - 重点代码核心实现思想：先读入数据并离散化质数，通过循环递推更新\(s1[i]\)（对应\(A_i\)）和\(s2[i]\)（对应\(B_i\)），对无解情况进行判断，将方程转化为\(f_0\)的同余形式并存入数组，最后判断模同一个质数得到的解是否相同。
```cpp
for(int T=read();T;T--){
    n=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=n;i++)b[i]=read();
    for(int i=1;i<=n;i++)p[i]=q[i]=read();
    sort(q+1,q+1+n);int l=unique(q+1,q+1+n)-q-1;

    for(int i=1;i<=l;i++)s1[i]=a[1]%q[i],s2[i]=b[1]%q[i];

    bool fl=0;
    for(int i=1;i<=n;i++){
        int pp=lower_bound(q+1,q+1+l,p[i])-q;
        if(!s1[pp]&&s2[pp])fl=1;
        if(!s2[pp]&&!s1[pp]){
            for(int j=1;j<=l;j++)s1[j]=1ll*s1[j]*a[i+1]%q[j],s2[j]=(1ll*s2[j]*a[i+1]+b[i+1])%q[j];
            continue;
        }
        P[pp].push_back(1ll*((p[i]-s2[pp])%p[i])*qp(s1[pp],p[i]-2,p[i])%p[i]);
        for(int j=1;j<=l;j++)s1[j]=1ll*s1[j]*a[i+1]%q[j],s2[j]=(1ll*s2[j]*a[i+1]+b[i+1])%q[j];
    }
    for(int i=1;i<=l;i++){
        for(int j=1;j<(int)P[i].size();j++)
            if(P[i][j]!=P[i][j-1])fl=1;
        P[i].clear();
    }
    puts(!fl?"Yes":"No");
}
```
  - 2huk (4星)
    - 关键亮点：简洁地推导出\(f_i = A_if_0 + B_i\)的形式，将条件转化为同余方程组，利用费马小定理求逆元，通过哈希表判断解的一致性，代码简洁高效。
    - 个人心得：无
    - 重点代码核心实现思想：读入数据后，通过循环递推求出\(A_i\)和\(B_i\)，对\(A_i = 0\)的情况进行特殊处理，利用费马小定理求逆元并判断在同一模数下\(f_0\)的值是否相同。
```cpp
for (int i = 1; i <= n; ++ i ) {
    A[0] = 1;
    for (int j = 1; j <= n; ++ j ) {
        A[j] = A[j - 1] * a[j] % p[i];
        B[j] = (a[j] * B[j - 1] % p[i] + b[j]) % p[i];
    }

    if (A[i] == 0) {
        if (B[i]) return false;
    }
    else {
        int y = (p[i] - B[i]) * fpm(A[i], p[i] - 2, p[i]) % p[i];
        if (mp.count(p[i]) && mp[p[i]]!= y) return false;
        mp[p[i]] = y;
    }
}
return true;
```

最优关键思路或技巧：将数列递推式转化为关于\(f_0\)的同余方程，通过递推求出同余方程的系数和常数项，并对系数为\(0\)的情况进行特殊处理，利用数论知识（如扩展欧几里得算法、费马小定理）求逆元，最后通过判断同一模数下解的一致性来确定是否存在满足条件的\(f_0\)。

可拓展之处：同类型题通常围绕数列递推与数论结合，类似算法套路为将递推关系转化为同余方程，利用数论知识求解和判断。

推荐题目：
 - P1495 【模板】中国剩余定理(CRT)/曹冲养猪，考察中国剩余定理的基本应用。
 - P3868 [TJOI2009]猜数字，结合了同余方程和中国剩余定理的运用。
 - P2421 楼兰图腾，需要利用数论知识优化对数列的处理。

个人心得摘录与总结：无。 

---
处理用时：58.45秒
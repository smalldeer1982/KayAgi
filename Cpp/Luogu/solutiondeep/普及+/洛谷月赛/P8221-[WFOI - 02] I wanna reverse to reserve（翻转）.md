# 题目信息

# [WFOI - 02] I wanna reverse to reserve（翻转）

## 题目背景

> 君子不器

“我最擅长解谜了，你说是吧，kid。”

“嗯...”

## 题目描述

kid 走进了一个 $n$ 行 $m$ 列的矩阵，**不**保证矩阵中有 $n$ 个数字 $1$，$n$ 个数字 $2$，$\dots$ , $n$ 个数字 $m$ 但 $n,m$ 均为偶数。

现有两种改变矩阵的方式：

- 选择任意一行，将这一行上的数翻转；
- 选择任意一列，将这一列上的数翻转。

每次操作可以选择任意一种方式。

现在需要通过若干次操作，将矩阵变为：

$$
n\;行\left\{
\begin{array}{l}
1\quad2\quad3\quad\cdots\quad m\\
\\
1\quad2\quad3\quad\cdots\quad m\\

\\
\cdots\\
\\
1\quad2\quad3\quad\cdots\quad m\\
\end{array}
\right.

$$

这样才会出现下一个存档点。

你需要帮 kid 解决这个问题。

你只需要给出答案，剩下的操作就交给 Uvocde 吧！

## 说明/提示

**【数据范围】**

**本题采用 Subtask 捆绑测试**。

- $\texttt{Subtask \#0 (20pts)}$：最多只有 $2$ 个数不在规定位置上；
- $\texttt{Subtask \#1 (20pts)}$：$n=2$；
- $\texttt{Subtask \#2 (20pts)}$：$m=2$；
- $\texttt{Subtask \#3 (40pts)}$：$1\le n\le 100$，$1\le m\le 100$；

全部数据满足 $1\le n\le 100$，$1\le m\le 100$。

## 样例 #1

### 输入

```
2 4
1 2 3 4
4 3 2 1```

### 输出

```
YES
1
0 2```

## 样例 #2

### 输入

```
2 4
1 2 3 4
4 1 3 2```

### 输出

```
NO```

# AI分析结果

• **综合分析与结论**：这些题解的核心思路均基于矩阵翻转操作的性质，即矩阵中每个元素最多只能翻转到四个特定位置（原位置、水平翻转后位置、竖直翻转后位置、水平且竖直翻转后位置），将这四个位置称为一个置换环或轮换位。通过分析轮换位内数字的分布情况来判断是否有解，并对有解情况进行分类讨论，构造出不超过 $n×m$ 次操作的复原方案，且保证每次操作不影响已复原的轮换位。各题解的差异主要体现在对轮换位情况的分类方式、操作方案的构造以及代码实现的细节上。

• **所选的题解**：
  - **作者：Cocoly1990 (5星)**
    - **关键亮点**：思路清晰，通过两个引理简洁明了地阐述了问题的本质，对轮换位的分类讨论全面且操作构造详细，易于理解。
  - **作者：Icyfires18 (4星)**
    - **关键亮点**：类比魔方思路，形象生动，对操作方案的设计考虑到了操作次数的限制，代码实现中运用位运算等技巧处理数据，较为巧妙。
    - **个人心得**：赛时灵感来源于魔方，部分解释与魔方相关，虽表述复杂但实际思路简单。
  - **作者：Eafoo (4星)**
    - **关键亮点**：对无解情况的判断全面且详细，对复原矩阵的操作方案构造结合具体例子说明，便于理解，代码实现完整且注释详细。
    - **个人心得**：构造题较恶心，因题解格式问题被打回多次，心态快崩。

**最优关键思路或技巧**：利用矩阵翻转操作后元素位置的对称性，将矩阵划分为多个轮换位进行分析。在构造操作方案时，重点保证行翻转次数为偶数，以避免影响已复原的轮换位，同时控制操作次数，确保总操作数不超过 $n×m$。

**可拓展思路**：此类题目属于矩阵变换与构造类问题，类似套路为分析变换操作的性质，找到不变量（如本题中的轮换位），根据不变量判断可行性并进行构造。同类型题可考虑增加操作类型或改变目标矩阵形式，增加难度。

**相似知识点洛谷题目**：
  - P1162 填涂颜色：涉及矩阵的遍历与状态改变，与本题对矩阵元素的操作有相似之处。
  - P1330 封锁阳光大学：同样是在矩阵结构上进行操作，判断是否能达到某种状态，考察对矩阵操作的理解。
  - P1433 吃奶酪：虽不是矩阵问题，但同样需要分析操作的可行性与构造方案，锻炼构造思维。

**Cocoly1990题解重点代码**：本题解未给出代码，核心实现思想为按轮换位分类讨论，根据不同情况构造行、列翻转操作序列，使轮换位内元素达到目标状态。

**Icyfires18题解重点代码**：
```cpp
// 变换位处理
void deal(int x0,int y0,int x1,int y1){
    register int s=0;
    s|=(a[x0][y0]==y0? 0:1),s<<=1;
    s|=(a[x1][y0]==y0? 0:1),s<<=1;
    s|=(a[x0][y1]==y0? 0:1),s<<=1;
    s|=(a[x1][y1]==y0? 0:1);
    if(s==0x3)return;//0011
    else cnt+=4;
    switch(s){
        case 0x5:str[x0][y0]="DRDR";return;//0101
        case 0x6:str[x0][y0]="RDRD";return;//0110
        case 0x9:str[x0][y0]="RURU";return;//1001
        case 0xA:str[x0][y0]="URUR";return;//1010
        case 0xC:reverse(y0),reverse(y1);
                 str[x0][y0]="ULRU";return;//1100
        default:flag=true;return; 
    }
}
```
核心实现思想：将变换位四个位置的元素信息通过位运算存入二进制数 `s`，根据 `s` 判断变换位情况，对应不同情况记录操作序列，若不符合要求则标记无解。

**Eafoo题解重点代码**：
```cpp
// 对处于第i1行、第i2行、第j1列、第j2列，左上角数为a，右上角为b，左下角为c，右下角为d的轮换位还原
void Work(int i1, int i2, int j1, int j2, int a, int b, int c, int d)
{
    if (a == b && c == d && a > c)
    {
        ReverseHang(i1);
        ReverseLie(j2);
        ReverseHang(i1);
    }
    else if (a == b && c == d && a < c)
    {
        ReverseHang(i2);
        ReverseLie(j2);
        ReverseHang(i2);
    }
    else if (a == c && b == d && a > b)
    {
        ReverseHang(i1);
        ReverseLie(j1);
        ReverseLie(j2);
        ReverseHang(i1);
    }
    else if (a == d && b == c && a > b)
    {
        ReverseLie(j1);
        ReverseHang(i1);
        ReverseLie(j1);
        ReverseHang(i1);
    }
    else if (a == d && b == c && b > a)
    {
        ReverseLie(j2);
        ReverseHang(i2);
        ReverseLie(j2);
        ReverseHang(i2);
    }
}
```
核心实现思想：根据轮换位内四个元素的不同排列情况，分别构造满足行翻转次数为偶数且操作步数不超过四步的还原操作序列。 

---
处理用时：57.00秒
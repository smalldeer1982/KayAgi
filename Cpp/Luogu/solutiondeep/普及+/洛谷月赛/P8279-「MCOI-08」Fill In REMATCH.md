# 题目信息

# 「MCOI-08」Fill In REMATCH

## 题目描述

Dream 有一个长度为 $n$（$1\le n\le 10^5$）的整数数组 $a_1,a_2,\dots,a_n$，其中对于 $i=1,2,\dots,n$，满足 $0\le a_i<2^{60}$。

他计算了前缀异或数组 $p_i=a_1\oplus a_2\oplus\dots\oplus a_i$ 以及后缀异或数组 $s_i=a_i\oplus a_{i+1}\oplus\dots\oplus a_n$。

现在 Tommy **一共**将 $p$ 和 $s$ 的 $n$ 个元素换成 $-1$。给定当前的 $p$ 与 $s$ 数组，请恢复任意一组可能为原数组的 $a_1,a_2,\dots,a_n$。

保证存在一组合法解。

## 说明/提示

对于 $100\%$ 的数据，$1\le n,\sum n\le 10^5$，$\sum [p_i=-1]+\sum [s_i=-1]=n$，**保证有合法解。**

 - Subtask 1（10 pts）：$n\le 4$，$p_i,s_i<2$；
 - Subtask 2（10 pts）：$n\le 100$；
 - Subtask 3（20 pts）：$p_i,s_i<2$；
 - Subtask 4（60 pts）：无特殊限制。


## 样例 #1

### 输入

```
1
4
-1 34 367 -1
3178 -1 -1 3333```

### 输出

```
3 33 333 3333```

# AI分析结果

### 综合分析与结论
这些题解主要围绕通过给定的部分前缀异或数组 \(p\) 和后缀异或数组 \(s\) 还原原数组 \(a\) 展开。思路核心多基于异或运算性质，如归零律（\(a \oplus a = 0\)）、恒等律（\(a \oplus 0 = a\)）、结合律（\(a \oplus b \oplus c = a \oplus (b \oplus c) = (a \oplus b) \oplus c\)），推导出关键等式 \(a_i = p_i \oplus p_{i - 1} = s_i \oplus s_{i + 1}\) 以及 \(p_i \oplus s_{i + 1} = \bigoplus_{j = 1}^n a_j\)。算法要点在于先求所有数的异或和 \(sum\)，再据此还原 \(p\) 和 \(s\) 数组，进而得到原数组 \(a\)。解决难点在于利用条件 \(\sum [p_i = -1] + \sum [s_i = -1] = n\) 来确定 \(sum\) 的值。

### 所选的题解
1. **作者：Anxiomgh（5星）**
    - **关键亮点**：思路清晰，先详细阐述异或运算性质及推导引理，逐步分析如何利用引理求解，代码实现与思路紧密结合，注释详细。
    - **个人心得**：蒟蒻的第一篇题解，请大家多多指教。体现作者分享交流的态度。
    - **核心代码**：
```cpp
ll find(int n) //查找 
{
    for (int i = 0; i <= n; i++)
        if (p[i]!= -1 && s[i + 1]!= -1)
            return p[i] ^ s[i + 1];
}

void update(ll val, int n) //还原 
{
    for (int i = 0; i <= n; i++)
    {
        if (p[i]!= -1 && s[i + 1] == -1) 
            s[i + 1] = val ^ p[i];
        else if (p[i] == -1 && s[i + 1]!= -1) 
            p[i] = val ^ s[i + 1];
        else if (p[i] == -1 && s[i + 1] == -1)
        {
            p[i] = p[i - 1];
            s[i + 1] = val ^ p[i];
        }
    }
}
```
核心实现思想：`find` 函数通过遍历找到一组不为 \(-1\) 的 \(p[i]\) 和 \(s[i + 1]\) 求出异或和 \(sum\)。`update` 函数根据 \(sum\) 及不同情况更新还原 \(p\) 和 \(s\) 数组。
2. **作者：我是逍逍（4星）**
    - **关键亮点**：简洁地列出异或运算性质并推导关键等式，证明未知量可随意填的结论，代码简洁明了。
    - **核心代码**：
```cpp
for (int i = 0; i <= n; i++) 
    if (p[i]!= -1 && s[i + 1]!= -1) {
        E = p[i] ^ s[i + 1];
        break;
    }

for (int i = 0; i <= n; i++) {
    if (p[i] == -1 && s[i + 1]!= -1)
        p[i] = E ^ s[i + 1];
    else if (p[i]!= -1 && s[i + 1] == -1) 
        s[i + 1] = E ^ p[i];
    else if (p[i] == -1 && s[i + 1] == -1) 
        p[i] = 1;
    if (i)
        printf("%lld ", p[i] ^ p[i - 1]);
}
```
核心实现思想：先找到一组不为 \(-1\) 的 \(p[i]\) 和 \(s[i + 1]\) 求出 \(E\)（即所有数异或和），再依据 \(E\) 对 \(p\) 和 \(s\) 数组进行还原，最后根据 \(p\) 数组求出原数组。
3. **作者：Otomachi_Una_ （4星）**
    - **关键亮点**：快速得出关键等式，清晰阐述解题步骤，代码简洁易懂。
    - **核心代码**：
```cpp
for(int i=0;i<=n;i++) if(s[i]!=-1&&t[i+1]!=-1) xx=s[i]^t[i+1];
if(xx==-1) xx=0;
for(int i=0;i<=n;i++)
    if(s[i]!=-1) t[i+1]=xx^s[i];
    else if(t[i+1]!=-1) s[i]=xx^t[i+1];
    else s[i]=0,t[i+1]=xx;
for(int i=1;i<=n;i++)
    cout<<(s[i]^s[i-1])<<" ";
```
核心实现思想：先找到不为 \(-1\) 的 \(s[i]\) 和 \(t[i + 1]\)（即 \(p\) 和 \(s\) 数组对应元素）求出 \(xx\)（所有数异或和），再根据不同情况还原 \(s\) 和 \(t\) 数组，最后由 \(s\) 数组求出原数组。

### 最优关键思路或技巧
利用异或运算性质推导关键等式，通过条件确定所有数的异或和，进而还原数组。具体来说，通过分析 \(p\) 和 \(s\) 数组元素间异或关系，结合已知条件找到确定异或和的方法，这是解决问题的关键。在代码实现上，合理利用循环和条件判断处理不同情况，简洁高效地完成数组还原。

### 同类型题或类似算法套路拓展
此类题目多基于位运算性质，特别是异或运算，通过已知的部分数组信息（如前缀、后缀运算结果）还原原数组。类似套路是深入挖掘运算性质，建立已知与未知量的等式关系，利用给定条件确定关键值，从而求解。

### 推荐题目
- [P1508 Likecloud-吃、吃、吃](https://www.luogu.com.cn/problem/P1508)：涉及位运算及状态转移，与本题对运算性质的运用类似。
- [P3164 [CQOI2014]和谐矩阵](https://www.luogu.com.cn/problem/P3164)：通过矩阵元素间的异或关系求解，锻炼对异或运算在矩阵场景中的应用。
- [P4151 [WC2011]最大XOR和路径](https://www.luogu.com.cn/problem/P4151)：结合图论与异或运算，拓展对异或运算在更复杂场景下的运用能力。 

---
处理用时：51.87秒
# 题目信息

# 射命丸文的取材之旅

## 题目背景

射命丸文（Syameimaru Aya）是一只鸦天狗。她不定期制作名为「文文。新闻」的报纸，而为此，她需要对她收集到的新闻进行剪裁。

## 题目描述

射命丸文现在收集到了 $2n$ 条新闻。她想要将其刊登于自己的报刊之上。然而，自己的报刊最多只能刊登 $n$ 条新闻。

为了能在 $n$ 条新闻的篇幅中让自己的报刊得到最大的吸引力，她将这 $2n$ 条新闻**等分**成**两份**，即每一份中均有 $n$ 条新闻。

每一条新闻自然有着其吸引力。在**第一份**中，第 $i$ 条新闻有着吸引力 $a_i$，而在**第二份**中，第 $i$ 条新闻有着吸引力 $b_i$。这两份新闻的划分在输入时已经给定。

现在射命丸文要从中选取新闻放入自己的报刊。报刊上的第 $i$ 条新闻，将选择**第一份**新闻的第 $i$ 条或**第二份**新闻的第 $i$ 条。这样，报刊上的新闻就可以构成一个长度为 $n$ 的序列，第 $i$ 项也就是第 $i$ 条新闻有着吸引力 $c_i \in \{a_i,b_i\}$。

而这样的一份报刊有着其综合影响力。根据射命丸文的经验，对于她这样的一份含有 $n$ 条新闻的报刊，其综合影响力为：

$$\max\{r-l+1-\operatorname{mex}\{c_l,c_{l+1},\dots, c_{r-1},c_r\}\}(1\le l\le r\le n)$$

其中 $\operatorname{mex}\{c_l,c_{l+1},\dots,c_{r-1},c_r\}$ 指的是 $c_l,c_{l+1},\dots,c_{r-1},c_r$ 中没有出现过的**最小非负整数**。

现在她希望知道，在进行这些操作之后，自己的报刊的**最大**的综合影响力会是多少呢？由于她还要继续取材，因此她把这个任务交付给了你。

【形式化题意】

给定序列 $\{a_n\},\{b_n\}$，求一个序列 $\{c_n\}$ 满足 $\forall i\in[1,n],c_i\in\{a_i,b_i\}$，最大化

$$\max\{r-l+1-\operatorname{mex}\{c_l,c_{l+1},\dots, c_{r-1},c_r\}\}(1\le l\le r\le n)$$

并输出该式子可能的最大值。

## 说明/提示

**【样例解释和说明】**

射命丸文可以让自己的 $5$ 条新闻分别取第二份的第 $1$ 条，第一份的第 $2$ 条，第一份的第 $3$ 条，第一份的第 $4$ 条和第二份的第 $5$ 条。这样一来，她的报刊每条新闻的吸引力 $c_i$ 分别为 $0,1,0,1,0$。令 $l=1,r=5$，则 $\operatorname{mex}\{c_1,c_2,c_3,c_4,c_5\}=2$，$r-l+1-\operatorname{mex}\{c_1,c_2,c_3,c_4,c_5\}=3$，不难证明其为数列 $c$ 的综合影响力，也是**所有的可能的** $c$ 的最大综合影响力。

**【数据范围】**

对于 $20\%$ 的数据，满足 $1 \leq n\leq 10$。

另外 $40\%$ 的数据满足 $a_i=b_i$。

对于 $100\%$ 的数据，满足 $1 \leq n\le 10^6$，$0
\leq a_i,b_i\leq n$。

## 样例 #1

### 输入

```
5
0 1 0 1 2
0 2 0 1 0```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
所有题解都基于枚举 $\text{mex}$ 值的思路，利用数据范围 $0\leq a_i, b_i\leq n$ 降低时间复杂度。各题解算法要点和难点解决方式相似，均通过记录 $a_i = b_i$ 的位置将序列划分区间，以计算最大区间长度。不同之处在于代码实现细节和对特殊情况的处理。

### 所选的题解
- **作者：retep (5星)**
    - **关键亮点**：思路清晰，详细阐述了枚举 $\text{mex}$ 值的原因及可行性，对计算最大区间长度的方法解释透彻，代码简洁明了。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define N 1000005
#define ll long long
using namespace std;

int n,a[N],ans=-1e9;
vector<int> pos[N];

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

int main(){
    n=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1,b;i<=n;i++){
        b=read();
        if(b==a[i])pos[b].push_back(i); //记录x=b时的屏障的位置
    }
    for(int i=0;i<=n;i++){
        pos[i].push_back(n+1); //对所有的x在区间末尾加一个屏障，方便计算
        for(int j=0,before=1;j<pos[i].size();j++){
            ans=max(ans,pos[i][j]-before-i);
            before=pos[i][j]+1;
        }
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：通过 `pos` 数组记录每个值 $x$ 对应的 $a_i = b_i = x$ 的位置，遍历每个 $x$ 时，将这些位置视为屏障划分区间，计算各区间长度与 $x$ 的差值，取最大值作为答案。

- **作者：5k_sync_closer (4星)**
    - **关键亮点**：分情况讨论，对特殊子任务有详细解法，对一般情况的证明严谨，代码实现有层次感。
    - **重点代码**：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n, q, a[1000050], b[1000050], p[1000050], s[1000050];
int main()
{
    scanf("%d", &n);
    for(int i = 1;i <= n;++i) scanf("%d", a + i);
    for(int i = 1;i <= n;++i) scanf("%d", b + i);
    for(int i = 1;i <= n;++i) if(a[i] == b[i])
    s[a[i]] = max(s[a[i]], i - p[a[i]] - 1), p[a[i]] = i;
    for(int k = 0;k <= n;++k) s[k] = max(s[k], n - p[k]);
    for(int x = 0;x <= n;++x) q = max(q, s[x] - x);
    return printf("%d", q), 0;
}
```
    - **核心实现思想**：用 `p` 数组记录值 $a_i$ 上次出现位置，`s` 数组记录满足条件的最大区间长度。遍历数组，更新 `s` 和 `p`，最后枚举 $\text{mex}$ 值 $x$，计算并取最大的 $s[x] - x$ 作为答案。

### 最优关键思路或技巧
枚举 $\text{mex}$ 值，利用 $a_i, b_i$ 的值域范围降低时间复杂度。通过记录 $a_i = b_i$ 的位置，将序列划分区间，计算最大区间长度，进而求出最大值。

### 可拓展之处
此类题目属于序列最优化问题，类似套路是根据数据范围特点，通过枚举关键值（如 $\text{mex}$），结合序列特性（如 $a_i = b_i$ 的情况）划分区间，计算最值。

### 相似知识点洛谷题目
- [P1419 寻找段落](https://www.luogu.com.cn/problem/P1419)
- [P2678 [NOIP2015 提高组] 跳石头](https://www.luogu.com.cn/problem/P2678)
- [P3853 [TJOI2007]路标设置](https://www.luogu.com.cn/problem/P3853)

### 个人心得
无。 

---
处理用时：45.24秒
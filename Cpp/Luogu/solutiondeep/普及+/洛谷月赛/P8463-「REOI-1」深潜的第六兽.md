# 题目信息

# 「REOI-1」深潜的第六兽

## 题目背景

“〈十七兽〉全都不会飞。因此，在它们毁灭大地以后，悬浮大陆群还能像这样浮在天空。

“可是，只有〈深潜的第六兽〉在本身留在大地的同时，还能对悬浮大陆群发动攻击。它有两种能力，『分裂增生』和『快速茁壮』。

“留在地表的本体会让身体分裂出几万个碎块，然后随风飞扬，等待碰巧飘流到某座悬浮岛。抵达岛上以后，它会当场发育茁壮，大约六到八小时过后就能占据并毁灭整座岛。”

## 题目描述

现在有一只〈第六兽〉，在某一次的「分裂增生」时分裂出了 $n$ 个碎块，这些碎块会笔直向上飞去，如果其中一块碎块遇到了一座浮空岛（为了研究方便，我们不妨将它当成一条二维空间中的线段处理），便会迅速占据它，并一分为二，再次从浮空岛的两端笔直向上飞去。

不过好在，那些只是一些无关紧要最为荒凉毫无人烟的岛屿，但如果就这样放任它们继续肆虐，势必会给那些至关重要的浮空岛带来毁灭性的打击。于是乎，负责清理〈第六兽〉的军官们，决定以他们所在的岛屿为直线建立 $x$ 轴，并以重力的方向为正方向建立 $y$ 轴，他们总共监测到了 $m$ 座浮空岛，并确定了那些碎块分裂出的位置（距离 $x$ 轴的位置视作无限远），于是他们想知道，如果放任这些碎块，那么当它们到达军官的位置时，最终会有多少碎块。

注意，若一座浮空岛的 $ l_i $ 与 $ r_i $ 相同，即为一个点， 〈第六兽〉占据后仍然会分裂成两只，从这个点向上飞去。

**提示：浮空岛作为实体显然不会重叠。**

**简要题意：**

在一个平面直角坐标系上有 $m$ 条平行于 x 轴的线段，第 $i$ 条线段为 $(l_i,h_i)$ 与 $(r_i,h_i)$ 的连线。特别注意 $l_i$ 可与 $r_i$ 相等，此时线段变为一个点。

在直线 $y=10^9$ 上有 $n$ 个点，分别位于 $(x_i,10^9)$。

现在，这些点逐渐向下（y轴负方向）移动。若触碰到线段，则会一分为二，分裂出的两个点分别从线段的两端继续向下移动。

特别地，若线段为一个点，则会原地分裂成 2 个。

问所有初始点在经历了线段的分裂后，在最后会有多少个点掉在 $ x $ 轴上

## 说明/提示

样例解释：

注意， $y$ 轴正方向为重力方向。
在坐标轴中，横坐标为 $x$ 的碎块，先掉到纵坐标为2的线段上，然后分成两个从 $1$ 和 $3$ 往下掉，$3$ 的那个掉到了纵坐标为1的线段上，分成两个从 $2$ 和 $6$ 往下掉，第一个碎块一共变成了 $3$ 块，分别掉在 $1，2，6$ ，第二个碎块一共变成了两个碎块，分别掉在 $2，6$。

| 子问题 | 特殊限制条件 | 分值 |
| :-----------: | :-----------: | :-----------: |
| 1 | $ 1\leq n,m \leq 10 $ | 10 |
| 2 | $ 1\leq n,m \leq 100 $ | 5 |
| 3 | $ 1\leq n\leq 10^4， 1\leq m \leq 5\times 10^5 $ | 35 |
| 4 |$ 1\leq n,m \leq 5\times 10^5 $|50|

本题各个子问题之间不捆绑测试。

对于 $100\%$ 的数据 $ 1\leq n,m \leq 5\times 10^5 $，所有数字均为非负整数。


## 样例 #1

### 输入

```
2 2
1 3 2
2 6 1
3 5```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效计算点经过线段分裂后最终到达\(x\)轴的数量。思路可分为基于线段树和基于记忆化搜索（动态规划）两类。
 - **基于线段树**：大多将线段按纵坐标排序，利用线段树维护区间信息。如处理线段时，查询线段两端点贡献值，修改线段覆盖区间的值；或查询区间内点数量，清空区间并在两端点增加对应数量。核心操作是区间修改和单点查询。
 - **基于记忆化搜索（动态规划）**：按高度排序线段，定义状态表示从某线段掉落产生的碎块数，通过查找下方最近线段转移状态，最后根据点最先到达的线段统计答案。

各题解质量有差异，部分题解思路清晰、代码规范且有优化，部分题解代码可读性欠佳或未充分优化。

### 所选的题解
 - **作者：bsTiat (赞：23)  星级：5星**
    - **关键亮点**：思路简洁清晰，明确指出用线段树维护贡献值，操作仅涉及区间修改和单点查询，易于理解和实现。
 - **作者：Disjoint_cat (赞：4)  星级：4星**
    - **关键亮点**：详细分析了从暴力到DP再到线段树优化的思路过程，对题意理解、解法推导阐述全面，代码注释较清晰。
 ```cpp
#include<bits/stdc++.h>
#define ll long long
#define lid id<<1
#define rid (lid)+1
using namespace std;
const int N=500005;
const ll MOD=998244353;
int n,m,q,ma;
struct island
{
    int l,r,h;
    bool operator<(const island b)
    {
        return h>b.h;
    }
}a[N];
ll ans,an[N];
struct tree
{
    int l,r,val;
    bool lz;
}tr[N];
void build(int l,int r,int id)
{
    tr[id].l=l,tr[id].r=r,tr[id].val=1,tr[id].lz=0;
    if(l==r)return;
    int mid=l+r>>1;
    build(l,mid,lid);
    build(mid+1,r,rid);
}
void pd(int id)
{
    if(!tr[id].lz)return;
    tr[lid].lz=tr[rid].lz=1,tr[id].lz=0;
    tr[lid].val=tr[rid].val=tr[id].val;
}
void mdf(int l,int r,int id,ll val)
{
    if(tr[id].l==l&&tr[id].r==r)
    {
        tr[id].val=val,tr[id].lz=1;
        return;
    }
    pd(id);
    if(tr[lid].r>=l)
        if(tr[rid].l<=r)
        {
            mdf(l,tr[lid].r,lid,val);
            mdf(tr[rid].l,r,rid,val);
        }
        else mdf(l,r,lid,val);
    else mdf(l,r,rid,val);
}
ll query(int pos,int id)
{
    if(tr[id].l==tr[id].r)return tr[id].val;
    pd(id);
    if(tr[lid].r>=pos)return query(pos,lid);
    return query(pos,rid);
}
int main()
{
    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>a[i].l>>a[i].r>>a[i].h;
        ma=max(ma,a[i].r);
    }
    sort(a+1,a+m+1);
    build(1,ma,1);
    for(int i=m;i>=1;i--)
        mdf(a[i].l,a[i].r,1,(query(a[i].l,1)+query(a[i].r,1))%MOD);
    for(int i=1;i<=ma;i++)an[i]=query(i,1);
    for(int i=1;i<=n;i++)
    {
        cin>>q;
        ans=(ans+an[q])%MOD;
    }
    cout<<ans;
    return 0;
}
 ```
核心实现思想：先按高度排序线段，构建线段树并初始化为1。遍历线段，每次查询线段两端点值，修改线段覆盖区间为两端点值之和。最后单点查询每个点对应的贡献值累加得到答案。
 - **作者：stntn (赞：4)  星级：4星**
    - **关键亮点**：详细分析了暴力解法及优化方向，逐步引导到正解，对线段树操作描述清晰，代码结构较清晰。
 ```cpp
#include<bits/stdc++.h> 
#define N 500010
#define M 100000
#define int long long
#define DB double
#define ULL unsigned long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define per(i,a,b) for(int i=a;i>=b;i--)
#define tep(i,u) for(int i=head[u];~i;i=e[i].nxt)
#define INF 0x3f3f3f3f
#define mod 998244353
using namespace std;
template <typename T> inline void read(T &a)
{
    a=0;T w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){a=a*10+ch-'0';ch=getchar();}
    a*=w;
}
template <typename T,typename...Args>void read(T &x,Args &...args){read(x);read(args...);}
int n,m;
struct LINE
{
    int l,r,h;
    bool operator < (const LINE &b){return h>b.h;}
}line[N];
struct LT
{
    #define lc rt<<1
    #define rc rt<<1|1
    #define mid (l+r>>1)
    int sum[M<<2];bool cov[M<<2];
    inline int pushup(int rt){(sum[rt]=sum[lc]+sum[rc])%=mod;}
    inline void pushdown(int rt){if(!cov[rt]) return;cov[rt]=sum[lc]=sum[rc]=0;cov[lc]=cov[rc]=1;}
    inline void update_pos(int rt,int l,int r,int pos,int val)
    {
        if(l==r){sum[rt]+=val;return;}
        pushdown(rt);
        if(pos<=mid) update_pos(lc,l,mid,pos,val);
        else update_pos(rc,mid+1,r,pos,val);
        pushup(rt);
    }
    inline void clear(int rt,int l,int r,int L,int R)
    {
        if(L<=l&&r<=R){cov[rt]=1;sum[rt]=0;return;}
        pushdown(rt);
        if(L<=mid) clear(lc,l,mid,L,R);
        if(mid<R) clear(rc,mid+1,r,L,R);
        pushup(rt);
    }
    inline int query(int rt,int l,int r,int L,int R)
    {
        if(L<=l&&r<=R) return sum[rt];
        pushdown(rt);int res=0;
        if(L<=mid) (res+=query(lc,l,mid,L,R))%=mod;
        if(mid<R) (res+=query(rc,mid+1,r,L,R))%=mod;
        return res;
    }
    #undef lc
    #undef rc
    #undef mid
}t;

signed main()
{
    read(n,m);
    rep(i,1,m) read(line[i].l,line[i].r,line[i].h);
    rep(i,1,n){int x;read(x);t.update_pos(1,1,M,x,1);}
    sort(line+1,line+1+m);
    rep(i,1,m)
    {
        int l=line[i].l,r=line[i].r;
        int sum=t.query(1,1,M,l,r);
        t.clear(1,1,M,l,r);
        t.update_pos(1,1,M,l,sum);
        t.update_pos(1,1,M,r,sum);
    }
    printf("%lld\n",t.query(1,1,M,1,M)%mod);
    return 0;
}
 ```
核心实现思想：同样按高度排序线段，初始化线段树记录各点初始值。遍历线段，查询线段覆盖区间点数量，清空区间并在两端点增加该数量，最后查询整个区间和得到答案。

### 最优关键思路或技巧
 - **数据结构选择**：线段树能高效实现区间修改和单点查询，适合本题需求。按高度排序线段，可保证处理顺序合理，避免重复计算。
 - **状态转移思想**：记忆化搜索（动态规划）通过定义合理状态，利用线段间关系递推，减少计算量。

### 可拓展思路
此类题目属于平面几何与动态规划或数据结构结合的问题。类似套路如处理具有层次关系的对象，先排序再利用数据结构维护状态变化。同类型题可考虑增加线段的其他属性或点的特殊行为，如线段有不同权重，点碰到线段有不同分裂规则等。

### 推荐题目
 - [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：基础线段树区间修改、单点查询题目，帮助巩固线段树基本操作。
 - [P1828 [USACO3.4] 香甜的黄油 Sweet Butter](https://www.luogu.com.cn/problem/P1828)：结合图论与数据结构，可锻炼综合运用能力。
 - [P2824 [HEOI2016/TJOI2016]排序](https://www.luogu.com.cn/problem/P2824)：涉及线段树与排序操作，提升对线段树应用的理解。

### 个人心得摘录
 - **作者：Disjoint_cat**：读题耗时久，敲了暴力准备放弃时，因听到同学提示线段树而AC。心得：多交流能获取新思路，比赛中要善于倾听他人想法。 

---
处理用时：99.44秒
# 题目信息

# 「Wdoi-(-1)」恋弹者们的黑集市

## 题目背景

> 天弓千亦有言：「能力卡终将大势所趋归于陈腐，集市终将回归日常，这是发展规律。」但不知为何和神明所说相悖，卡片的价值遭到了炒作。有人在炒作卡的价值吗废话？又或者说，有倒爷在囤积这些卡片吗？卡片市场秩序完全陷入混乱之时，即便是神明也无法介入的集市，就此出现。

$$\quad\tag*{\small\textit{---TH18.5 恋弹者们的黑集市}}$$

魔理沙正在调查妖怪之山的高地，来收集逸散在各地的能力卡片。就在此时，她遇到了住在此处的驹草山如。

在河童与天狗间游刃有余的驹草山如，掌握着此地大量的资源。显而易见的，她掌握着大量的能力卡片——这正是魔理沙探访的目标。

「想要这些卡片吗，那就让我们玩一个游戏吧」

「赢了，这些卡片就都归你；输了，你可要交出身上所有的卡片。」



## 题目描述

### 原始题意



驹草山如将一个六面写满权值的骰子放在了棋盘上。棋盘上花花绿绿写着很多数字。第 $i$ 行第 $j$ 列写有数字 $a_{i-1,j-1}$。

「你能否获得这些能力卡片，取决于你获得的分数。」

魔理沙有两种方法移动这个骰子：将骰子向下一列**翻转**，或者向下一行**翻转**。值得注意的是，翻转骰子后，骰子每面上的数字就会随着翻滚而改变。现在魔理沙需要将骰子滚动至第 $n$ 行第 $m$ 列。

魔理沙的分数被定义为，所有时刻，骰子与棋盘上的数字接触的那一面的数字，乘上棋盘上该数字，再累加起来的和。只有魔理沙最大化这个和，她才能获取她所需要的卡片。

你能帮帮魔理沙吗？

### 简要题意

有一个 $n\times m$ 大小的棋盘，第 $i$ 行第 $j$ 列写有数字 $a_{i-1,j-1}$。

现在有一个骰子，六个面按照前、后、左、右、上、下的顺序，依次写有数字 $w_0,w_1,w_2,w_3,w_4,w_5$。现在骰子摆放在 $(0,0)$ 位置，需要将它**滚动**至 $(n-1,m-1)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/2l378eln.png)

骰子只有两种方式滚动：向下一行翻滚、向下一列翻滚。我们记一种方案的权值为，整个过程中（包括骰子在起点和终点时），骰子**最底面**上写着的数字，与此时骰子所在格子上写着的数字的乘积之和。

![](https://cdn.luogu.com.cn/upload/image_hosting/4jwvxax5.png)

（为了方便读者阅读，骰子上的数字已经隐去）

现在你需要最大化这个乘积之和。

## 说明/提示

### 样例解释

#### 样例 1 解释

一种最优的方案为，$(0,0)\to(0,1)\to(1,1)\to(1,2)\to(1,3)\to(2,3)\to(3,3)\to(3,4)\to(4,4)$。

总权值为 $2+8+19+19+3+8+8+17+13=97$。

#### 样例 2 解释

一种最优的方案为，$(0,0)\to(0,1)\to(1,1)\to(1,2)\to(1,3)\to(1,4)$。

### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n,m\le} & \textbf{特殊性质} & \textbf{分值} \\\hline
1 & 10 & - & 10 \\\hline
2 & 100 & - & 30 \\\hline
3 & 10^3 & \textbf{A} & 10 \\\hline
4 & 10^3 & - & 50 \\\hline
\end{array}$$

- **特殊性质** $\textbf{A}$：保证 $w_i=1,i=0,1,2,\cdots 5$。

对于全部数据，保证 $1\le n,m\le 10^3$，$|a_i|\le 10^3$，$|w_i|\le 10^3$。

## 样例 #1

### 输入

```
5 5
2 8 15 1 10
5 19 19 3 5
6 6 2 8 2
12 16 3 8 17
12 5 3 14 13
1 1 1 1 1 1
```

### 输出

```
97```

## 样例 #2

### 输入

```
2 5
2 8 15 3 10
5 19 19 3 5
1 2 3 4 5 6```

### 输出

```
194```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解均采用动态规划（DP）解决该问题。核心思路是通过记录骰子在棋盘不同位置的状态，来计算从起点到终点的最大得分。由于骰子状态可由部分面确定，所以通过给DP数组增加维度记录骰子状态，避免暴力六维枚举带来的高复杂度。
    - 算法要点：定义状态转移方程，根据骰子当前状态和移动方向（向下或向右翻滚）更新DP数组。初始化DP数组时，起点状态设为初始得分，其余设为极小值。最后遍历终点处骰子的所有可能状态，取最大值作为答案。
    - 解决难点：难点在于如何有效表示骰子状态及推导状态转移。题解们利用骰子确定两个面（如前面和右面、上面和前面等）即可确定整体状态的特性，降低DP数组维度。通过打表或分类讨论确定骰子翻滚后的状态变化。
    - 整体来看，各题解思路相近，主要差异在骰子状态表示、状态转移计算方式及代码实现细节上。

  1. **作者：蒟蒻炒扇贝 (5星)**
      - 关键亮点：思路清晰，详细阐述从朴素六维DP到优化为四维DP的过程，即仅通过记录骰子的front和right编号来确定整个骰子状态，降低时间复杂度。代码注释详细，对状态转移和骰子状态判断函数有清晰解释，可读性强。
      - 个人心得：无
      - 核心代码片段（状态转移部分）：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        if(i==1&&j==1)continue;
        for(int nx=0;nx<6;nx++)for(int ny=0;ny<6;ny++)
        {
            if(get_down(nx,ny)==6)continue;
            int tx=nx,ty=-1;
            if(get_down(nx,ny)==5)ty=4;
            if(get_down(nx,ny)==4)ty=5;
            if(get_down(nx,ny)==3)ty=2;
            if(get_down(nx,ny)==2)ty=3;
            if(get_down(nx,ny)==1)ty=0;
            if(get_down(nx,ny)==0)ty=1;
            int td=get_down(tx,ty);
            f[i][j][tx][ty]=max(f[i][j][tx][ty],f[i][j-1][nx][ny]+a[i][j]*w[td]);//向下一行翻滚
            ty=ny,tx=-1;
            if(get_down(nx,ny)==5)tx=4;
            if(get_down(nx,ny)==4)tx=5;
            if(get_down(nx,ny)==3)tx=2;
            if(get_down(nx,ny)==2)tx=3;
            if(get_down(nx,ny)==1)tx=0;
            if(get_down(nx,ny)==0)tx=1;
            td=get_down(tx,ty);
            f[i][j][tx][ty]=max(f[i][j][tx][ty],f[i-1][j][nx][ny]+a[i][j]*w[td]);//向下一列翻滚 
        }
    }
```
      - 核心实现思想：遍历棋盘每个位置，对每个位置枚举骰子前一步可能的front和right状态，通过`get_down`函数获取底面编号，根据翻滚方向计算新的front和right状态及底面编号，更新当前位置对应骰子状态的最大得分。

  2. **作者：lyt_awa (4星)**
      - 关键亮点：简洁明了地阐述思路，直接点明确定骰子前面和右侧数字即可确定状态，进而定义DP数组。状态转移方程清晰，采用刷表法实现，代码简洁，逻辑连贯。
      - 个人心得：无
      - 核心代码片段（状态转移部分）：
```cpp
for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j)
        for (int q = 0; q < 6; ++q)
            for (int y = 0; y < 6; ++y)
                if (f[i][j][q][y]!= 0xcfcfcfcf) {
                    f[i + 1][j][U(q, y)][y] = max(f[i + 1][j][U(q, y)][y], f[i][j][q][y] + a[i + 1][j] * w[q]);
                    f[i][j + 1][q][U(q, y)] = max(f[i][j + 1][q][U(q, y)], f[i][j][q][y] + a[i][j + 1] * w[y]);
                }
```
      - 核心实现思想：遍历棋盘各位置及骰子在该位置可能的前面和右侧数字组合，若当前状态有值，则根据转移方程更新下一行和下一列对应骰子状态的最大得分。

  3. **作者：__K2FeO4 (4星)**
      - 关键亮点：通过设二维表`dw`表示底部下标，使状态转移更直观。状态转移方程书写简洁明了，代码结构清晰，对边界条件（如`f=r`及`f⊗1=r`）处理得当。
      - 个人心得：无
      - 核心代码片段（状态转移部分）：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        for(int fr=0;fr<6;fr++)
            for(int rt=0;rt<6;rt++){
                if(fr==rt||(fr^1)==rt||(i==1&&j==1))continue;
                f[i][j][fr][rt]=max(f[i-1][j][dw[fr][rt]][rt],f[i][j-1][fr][dw[fr][rt]])+w[dw[fr][rt]]*a[i][j];
            }
```
      - 核心实现思想：遍历棋盘各位置及骰子在该位置可能的前方和右侧下标组合，跳过不合法状态，根据状态转移方程从左方和后方状态转移更新当前位置对应骰子状态的最大得分。

• 最优关键思路或技巧：利用骰子确定两个面即可确定整体状态的特性优化DP数组维度，降低时间复杂度。通过打表或分类讨论详细计算骰子翻滚后的状态变化，准确实现状态转移。

• 可拓展之处：同类型题通常为在特定地图上，带有状态变化的移动求最值问题。类似算法套路是分析物体状态与移动规则，利用状态间的依赖关系设计DP数组及状态转移方程。

• 相似知识点洛谷题目：
    - [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)：基础的方格上移动取数问题，可作为此类DP问题的入门。
    - [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：虽场景不同，但同样是通过状态转移解决的DP问题，锻炼状态设计和转移方程推导能力。
    - [P1280尼克的任务](https://www.luogu.com.cn/problem/P1280)：涉及时间轴上的状态转移，与本题在利用DP解决复杂场景问题上思路相似。 

---
处理用时：69.12秒
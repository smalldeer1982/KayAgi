# 题目信息

# 「Wdoi-2」来自地上的支援

## 题目背景

波光粼粼的山顶湖与庄严神圣的神社之下，是一座复合型活火山。  
沿幻想风穴而下，便能到达火山之下，废弃已久的地狱原址。   
>在旧地狱中，有一座大都市。那里是旧地狱还是地狱的时候在那工作的众鬼们居住的地方，只有那里亡者们是无法踏入去的。后来地狱体制改革，机构搬离了这个地方。  
因为这个缘故这块地狱变成了废墟，但却有一部分看上了那里的妖怪擅作主张占领了那里，于是就成了如今的旧地狱了。
这里比地上更没有秩序可言。悍匪恶霸，特别是惹人类讨厌的家伙都喜欢搬到这边定居下来。

自旧地狱喷泻而出的间歇泉，给妖怪之山带来了优良的温泉，也喷出了大量的怨灵。

为了解决这次异变，乐园的巫女和普通的魔法使结伴而行，在来自地上的支援下，自幻想风穴直冲地底。

先后结（bao）识（da）了黑暗洞窟中的明亮之网、地壳下的嫉妒心、人们所谈论的怪力乱神后，二人来到了遗址中心的洋馆，地灵殿。

受这里主人的指引，二人来到了位于深处的间歇泉地下中心。

## 题目描述

### 简要题意
给定正整数 $n$、$v$ 和长度为 $n$ 的数组 $\{A_i\}$。

有一个长度为 $n$ 的数组 $B$，初始值与 $A$ 相同。 
执行 $n$ 次操作，第 $i$ 次操作在 $[1,i]$ 中按如下规则选取一个正整数 $j$，然后把 $B_j$ 变成 $B_j+v$：
- 选取 $B_j$ 最大的 $j$。
- $B_j$ 相同时选择 $A_j$ 最大的 $j$。
- $A_j,B_j$ 均相同，选择较小的 $j$。

我们称这是选中了一次 $j$。

有 $m$ 次询问，每次询问给定 $x_i,k_i$。表示求最小的 $s$，使得**若**将 $A_{x_i}$ 的初始值改为 $s$（注意此时 $B_{x_i}$ 的初始值也会跟着改变），$x_i$ 至少被选中 $k_i$ 次，或报告不存在（**结果为** $0$）。请注意，$s$ 不存在最小值时也是报告不存在（**结果为** $0$）。

询问之间互相独立，也就是每次询问不会对 $A_{x_i}$ 和 $B_{x_i}$ 产生实质性更改。

### 原始题意

到达控制中心之后，主角组和灵乌路空进行了激烈的狗斗大赛。负责技术维护的河童需要接受荷取来自地上指挥部的指令，保障生产安全。

具体地，有 $n$ 个核反应机组依次排开，第 $i$ 个机组的活动强度为 $A_i$。为了维护平衡，控制系统依次操作 $n$ 次，第 $i$ 次操作会在前 $i$ 个机组中找到一个**当前活动度最高的**机组，进行一次调节平衡操作，并将其活动度增加 $v$。倘若有多个机组活动度最高，就应当选择初始活动度**最大**的，若还是无法比较，则取编号最小。

为了在自动控制系统的基础上调节平衡，荷取会发出 $m$ 条指令，形如她每次会给出两个整数 $x_i,k_i$，表示她会修改第 $x_i$ 个机组的初始活动度。她希望通过修改（必须改成一个**非负整数** $s$）后，$x_i$ 号机组至少被平衡 $k_i$ 次。如果无论如何都无法达到要求，那么结果就是 $0$；否则请求出满足条件的**最小的** $s$。

## 说明/提示

### 样例 1 解释

对于第一次询问，我们将 $A_3$ 修改为 $7$。

- 第一次操作选择了位置 $1$，于是 $B_1$ 变为 $4$。
- 第二次操作选择了位置 $2$，于是 $B_2$ 变为 $7$。虽然操作前 $B_1=B_2$，但是 $A_2>A_1$，因此选择位置 $2$。
- 第三次操作选择了位置 $3$，于是 $B_3$ 变为 $10$。
- 第四次操作选择了位置 $3$，于是 $B_3$ 变为 $13$。
- 第五次操作选择了位置 $3$，于是 $B_3$ 变为 $16$。
- 第六次操作选择了位置 $3$，于是 $B_3$ 变为 $19$。
- 第七次操作选择了位置 $3$，于是 $B_3$ 变为 $22$。

于是位置 $3$ 一共被选择了 $5$ 次，满足题意。可以证明，如果把 $A_3$ 的初始值设为 $6$，无法达成要求。于是该询问结果为 $7$。

对于第二个询问，容易发现不可能有 $4$ 次以上操作选择位置 $6$。因此该询问结果为 $0$。

$7\oplus 0=7$，$7+0=7$，因此输出 $7,7$。

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n,m\le} & \bm {a_i\le } & \bm{v\le} & \textbf{分值} \cr\hline
1 & 10 & 100 & 10 & 10 \cr\hline
2 & 100 & 5\times 10^3 & 50 & 20 \cr\hline
3 & 10^3 & 10^9 & 100 & 10 \cr\hline
4 & 10^5 & 10^9 & 100 & 25 \cr\hline
5 & 2\times 10^6 & 10^9 & 100 & 35 \cr\hline
\end{array}$$

对于全部数据，满足 $1 \le n,m \le 2\times 10^6$，$1 \le v \le 100$，$1 \le a_i \le 10 ^ 9$，$1 \le x,k \le n$。

**本题 IO 量较大，请选择合适的输入方式。**

## 样例 #1

### 输入

```
7 2 3
1 4 1 5 4 1 1
3 3
6 4```

### 输出

```
7 7```

## 样例 #2

### 输入

```
10 10 9
14 91 84 13 97 92 23 64 31 10 
5 2
5 5
9 1
2 6
9 1
5 4
3 5
2 8
8 2
5 4
```

### 输出

```
245 1177
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何高效处理操作和查询展开。离散小波变换°的题解发现操作选择值构成等差数列的性质，给出\(\mathcal O(n\log n)\)和\(\mathcal O(n)\)两种做法；Dregen_Yor先给出朴素思路，后用线段树优化；MarchKid_Joe将询问拆为两部分，分别用优先队列和线段树处理；littlez_meow先预处理得到选择规律，后发现特殊情况通过二分优化；NianFeng通过分析操作和询问，用线段树维护区间最大值并结合递推统计答案；E1_de5truct0r利用操作性质，用前缀数组和线段树解决问题。整体来看，各题解思路和方法各有特色，主要难点在于发现操作性质并选择合适的数据结构优化。

所选的题解：
 - 作者：离散小波变换° (5星)
    - 关键亮点：发现操作选择值构成等差数列的重要性质，并基于此给出两种不同时间复杂度的高效解法，思路清晰且解法独特。
    - 核心代码（\(\mathcal O(n)\)做法关键部分）：
```cpp
up(1,n,i){
    A[i]=w=A[i]-i*v;
    if(w>=A[F[i-1]]) G[i]=F[i-1],F[i]=i; else
    if(w>=A[G[i-1]]) G[i]=i,F[i]=F[i-1]; else
    G[i]=G[i-1],F[i]=F[i-1];
}
up(1,m,i){
    int x=X[i],k=K[i],y=x+k-1; l=0;
    if(y<n) l=max(0,x*v+(F[y]==x?A[G[y]]+(G[y]>x):A[F[y]]+(F[y]>x)));
    ans1^=l,ans2+=l;
}
```
核心实现思想：通过预处理数组\(w_i = a_i - vi\)，并维护两个数组\(F\)和\(G\)记录最大值和次大值的位置，在查询时根据不同条件计算答案。

 - 作者：MarchKid_Joe (4星)
    - 关键亮点：将询问拆分为两部分分别处理，思路直观，利用优先队列和线段树两种常见数据结构解决问题，时间复杂度分析清晰。
    - 核心代码（线段树部分）：
```cpp
namespace Segment //线段树区间最大值可自行忽略
{
    #define lc(i) i<<1
    #define rc(i) i<<1|1
    struct node
    {
        int l;
        int r;
        int maxn;
    };
    node tr[N<<2];
    void build(int i,int l,int r)
    {
        tr[i].l=l;
        tr[i].r=r;
        if(l==r)
            return void(tr[i].maxn=a[l]);
        int mid=(l+r)>>1;
        build(lc(i),l,mid);
        build(rc(i),mid+1,r);
        tr[i].maxn=max(tr[lc(i)].maxn,tr[rc(i)].maxn);
    }
    int query(int i,int l,int r)
    {
        if(tr[i].l>r||tr[i].r<l)
            return -inf;
        if(tr[i].l>=l&&tr[i].r<=r)
            return tr[i].maxn;
        return max(query(lc(i),l,r),query(rc(i),l,r));
    }
}
using namespace Segment;
```
核心实现思想：构建线段树维护数组\(c_i = a_i - v\times i\)的区间最大值，用于查询\([x + 1,x + k - 1]\)区间的最大值。

 - 作者：NianFeng (4星)
    - 关键亮点：通过对操作和询问的深入分析，巧妙地对数组进行预处理，将比较转化为更方便处理的形式，利用线段树维护区间最大值并结合递推式统计答案，思路连贯清晰。
    - 核心代码（答案统计部分）：
```cpp
    low[1]=0; for(int i=2;i<=n;i++){      //如果要取到的下限
        low[i]=max(low[i-1]+v,a[i-1]+v);
    }
    //...
        int x=read(),k=read();
        if(x+k-1>n) continue;
        int tmp=max(low[x],(query(1,1,n,x+1,x+k-1)+v*x+1));     //加一是因为如果直接上的话，Ax<Aj就取不到力
```
核心实现思想：通过递推式\(low_i = \max(low_{i - 1}+v,a_{i - 1}+v)\)计算取到\(x\)的下限，结合线段树查询结果计算最终答案。

最优关键思路或技巧：离散小波变换°发现的操作选择值构成等差数列性质是本题的一个重要突破点，利用该性质可更深入理解操作规律，从而设计出高效算法。其他题解中，将询问拆分为不同部分分别处理、对数组进行预处理转化比较形式等思路也很关键，同时线段树等数据结构的运用优化了查询操作。

可拓展之处：此类题目通常围绕序列操作和查询，可拓展到其他具有类似操作性质的序列问题，如操作选择值具有某种单调性或周期性等。类似算法套路包括分析操作性质、利用数据结构维护特定信息（如区间最值）、通过预处理简化计算等。

推荐题目：
 - [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：基础线段树题目，用于巩固线段树的基本操作和应用。
 - [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)：涉及区间最值问题，可使用单调队列或线段树解决，与本题在维护区间信息上有相似之处。
 - [P2824 [HEOI2016/TJOI2016]排序](https://www.luogu.com.cn/problem/P2824)：通过分析操作性质，利用数据结构解决序列操作和查询问题，锻炼对操作和数据结构结合的能力。

个人心得：
 - littlez_meow：比赛时调试很久，发现最初对\(w_{x + k - 1} = x\)情况的处理有误，未考虑下标\(\min\)导致答案非最优，后通过二分得到正确答案。总结出要仔细分析边界和特殊情况，避免遗漏条件。 

---
处理用时：64.47秒
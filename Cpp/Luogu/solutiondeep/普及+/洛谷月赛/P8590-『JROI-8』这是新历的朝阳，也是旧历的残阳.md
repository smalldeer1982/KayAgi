# 题目信息

# 『JROI-8』这是新历的朝阳，也是旧历的残阳

## 题目背景

![1663764375173.png](https://img-kysic-1258722770.file.myqcloud.com/8c10be566f21cceb653f209300936b97/68a6764e14651.png)

>少女于海边伫立，凝视着落日最后的余晖\
“已然过去了呢，旧历的一年......”

**已获得转载授权。**

## 题目描述

给定序列 $\{a_n\}$，满足每一项都不小于前一项。对于所有不超过 $k$ 的正整数 $m$，询问如果将 $a$ 分成 $m$ 段（可以有空段），并给从前往后第 $i$ 段内的每个数都加上 $i$，增加后的 $\sum\limits_{j=1}^n a_j^2$ 最大是多少。询问相互独立，即每次询问时给每个数加的值不保留到下一次询问。

例如，对于序列 $\{-3,1,2,2\}$，若 $m=5$，则一种分段方式是 $[-3][][1,2][][2]$，增加后的序列是 $-2,4,5,7$，此时 $\sum\limits_{j=1}^n a_j^2=94$。

记 $m=i$ 时的答案（即此时最大的 $\sum\limits_{j=1}^n a_j^2$）为 $q_i$，出于良心考虑，你只需要输出 $\left(\sum\limits_{i=1}^k q_i\right) \bmod 998244353$ 即可。标准程序不基于特殊的输出方式，即能独立求出每一个 $q_i$。


## 说明/提示

#### 【样例解释】

当 $m=1$ 时，最优策略是 $[-3,1,2,2]$，$q_1=(-2)^2+2^2+3^2+3^2=26$。

当 $m=2$ 时，最优策略是 $[-3][1,2,2]$，$q_2=(-2)^2+3^2+4^2+4^2=45$。

当 $m=3$ 时，最优策略是 $[-3][][1,2,2]$，$q_3=(-2)^2+4^2+5^2+5^2=70$。

则 $\left(\sum\limits_{i=1}^k q_i\right) \bmod 998244353=(q_1+q_2+q_3)\bmod 998244353=(26+45+70)\bmod 998244353=141$。

#### 【数据范围与约束】

| 测试点编号 | 分数 | $n\leq$ | $k\leq$ | $\lvert a_i\rvert \leq$ | 特殊性质 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $1\sim 3$ | $15$ | $12$ | $12$ | $1000$ | 无 |
| $4\sim 6$ | $15$ | $1000$ | $1000$ | $1000$ | 无 |
| $7\sim 8$ | $10$ | $10^6$ | $10^6$ | $10^7$ | $a_i\geq0$ |
| $9 \sim 12$ | $20$ | $10^6$ | $1000$ | $10^7$ | 无 |
| $13\sim 20$ | $40$ | $10^6$ | $10^7$ | $10^7$ | 无 |


## 样例 #1

### 输入

```
4 3
-3 1 2 2```

### 输出

```
141```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何解决将序列按要求分段并计算最大平方和的问题。思路上多采用贪心策略，依据数的正负性及与分段数的关系来决定数应处的段，同时通过数学推导和前缀和优化计算过程。算法要点在于对正负数不同处理方式的实现以及前缀和数组的运用。解决难点主要是避免暴力枚举导致的超时问题，优化计算平方和的过程。

从质量上看，多数题解思路较清晰，但在代码可读性和优化程度上存在差异。部分题解对边界条件处理、取模操作等细节阐述不够详细。

### 所选的题解
- **作者wdgm4（5星）**
    - **关键亮点**：思路阐述清晰，先给出暴力思路及代码，再详细讲解AC思路，对正负数情况分别讨论，利用前缀和优化计算，同时对注意事项如取模、数据类型等有详细说明。
    - **个人心得**：考试时因未考虑爆long long痛失30分，强调注意取模和数据类型问题。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define XD 114514
using namespace std;
long long n,k;
long long m,f;
const long long mod=998244353;
const int MAXN=20000000;
long long a[1000010];
long long ans,num;
int b[20000010];//前缀和
int main(){
    cin>>n>>k;
    for(long long i=1;i<=MAXN;i++){
        b[i]=(b[i-1]+i*i%mod)%mod;//计算前缀和
    }
    for(register int i=1;i<=n;i++){
        num=0;
        scanf("%lld",&a[i]);
        if(a[i]<0){//分情况讨论
            m=(a[i]+1)*(-2)+1;
            f=-(a[i]+1);
            num+=min(m,k)*1ll*f%mod*f;//注意这里一定要取模一次，不然会爆long long
            num%=mod;
            if(k>m){
                num+=(b[k-m+f]*1ll-b[f]+mod)%mod;
                num%=mod;
            }
        }else{
            num+=(b[a[i]+k]*1ll-b[a[i]]+mod)%mod;
            num%=mod;
        }
        ans+=num;
        ans%=mod;
    } 
    cout<<ans%mod;
    return 0;
}
```
    - **核心实现思想**：先预处理前缀和数组b，记录1到i的平方和。遍历序列a，若a[i]为负数，通过计算确定在不同分段数下的最优放置位置，利用前缀和计算贡献；若a[i]为正数，直接利用前缀和计算其在不同分段数下的贡献，最后累加所有数的贡献得到答案。
- **作者ScottSuperb（4星）**
    - **关键亮点**：从贪心角度出发，详细分析正负数两种情况，结合完全平方公式推导每轮结果的变化，代码实现简洁明了。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 998244353
ll a[1000005];
int main() {
    int n = read(), k = read(), b = 0;
    ll q = 0, ans = 0, psum = 0, del;
    for (int i = 0; i < n; ++i)
        a[i] = read(), b += a[i] < 0, q = (q + (a[i] + 1) * (a[i] + 1) % mod) % mod;
    ans += q;
    for (int i = b; i < n; ++i) psum = (psum + a[i] + 1 % mod) % mod;
    n = n - b;
    for (int m = 2; m <= k; ++m) {
        ans = (ans + (q = (q + psum * 2 % mod + n) % mod)) % mod,
        psum = (psum + n) % mod;
        while (b > 0 && a[b - 1] + m > abs(a[b - 1] + 1)) {
            --b, ++n;
            del = (a[b] + m) * (a[b] + m) % mod - (a[b] + 1) * (a[b] + 1) % mod;
            ans = (ans + del) % mod, q = (q + del) % mod, psum = (psum + (a[b] + m) % mod) % mod;
        }
    }
    write(ans);
    fls();
    return 0;
}
```
    - **核心实现思想**：先读入数据并初始化相关变量，计算第一轮（m = 1）的平方和q及正数和psum。在后续循环中，对于正数部分，根据推导公式更新q和psum；对于负数部分，通过比较绝对值判断是否将负数放入正数段，更新相关变量及答案。
- **作者xwh_Marvelous（4星）**
    - **关键亮点**：通过观察得出数要么在第一段要么在最后一段的结论，对正负数情况分别推导分析，利用公式优化平方和计算，代码简洁且实现思路清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=998244353;
int n,k,pos;
ll a[1000005],ans,tot1,tot2,tot3;
int main(){
    scanf("%d%d",&n,&k);
    pos=n;
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]),tot3+=(a[i]+1)*(a[i]+1),tot3%=mod;
    for(int i=1;i<=k;i++){
        tot2+=2*tot1+(n-pos),tot2%=mod;
        tot1+=(n-pos),tot1%=mod;
        while(pos>0&&abs(a[pos]+i)>abs(a[pos]+1)){
            tot3-=(a[pos]+1)*(a[pos]+1),tot3%=mod,tot3+=mod,tot3%=mod;
            tot1+=a[pos]+i,tot1%=mod;
            tot2+=(a[pos]+i)*(a[pos]+i),tot2%=mod;
            pos--;
        }
        ans+=tot2+tot3;
        ans%=mod;
    }
    printf("%lld",ans);
    return 0;
}
```
    - **核心实现思想**：初始化位置pos为n，计算初始平方和tot3。在循环中，对于正数部分按公式更新tot1和tot2；对于负数部分，通过比较绝对值移动pos，更新tot1、tot2和tot3，最后累加得到答案。

### 最优关键思路或技巧
1. **贪心策略**：基于数的正负性及与分段数的关系，贪心决定每个数应放置在第一段还是最后一段，以最大化平方和。
2. **数学推导与公式运用**：利用完全平方公式展开式子，分析每轮平方和的变化规律，通过推导得出可递推或用前缀和优化的计算方式。
3. **前缀和优化**：通过预处理前缀和数组，快速计算特定区间的平方和及一次项和，将时间复杂度从O(nk)优化到O(n + k)。

### 可拓展之处
此类题目属于序列分段与数学计算结合的问题，类似套路可应用于其他需要对序列进行划分并根据规则计算最值的题目。例如，给定序列按特定规则分组求最大或最小的某种统计量（和、乘积等）。

### 相似知识点洛谷题目
1. **P7962 [NOIP2021]方差**：涉及序列处理及利用公式优化计算统计量，与本题在数学推导和序列操作上有相似之处。
2. **P1314 聪明的质检员**：同样是对序列进行操作并计算满足一定条件的统计量，可类比本题的贪心和优化思路。
3. **P2671 求和**：需要对序列进行划分并计算和的最值，与本题在问题模型上类似，可锻炼相关解题技巧。

### 个人心得摘录与总结
1. **wdgm4**：考试因未考虑爆long long丢分，强调取模和数据类型处理的重要性，在处理大数据时要时刻注意数据范围，及时取模防止溢出。
2. **JustForYourself**：赛时因未全面考虑负数划分情况只得到60分，提醒在解题时要全面分析各种情况，不能遗漏边界条件，通过手算样例可辅助发现问题。 

---
处理用时：85.03秒
# 题目信息

# 『JROI-8』颅脑损伤 2.0

## 题目描述

给定 $n$ 条线段，第 $i$ 条是 $[l_i,r_i]$。将每一条线段染成红色或黑色，要求：

1. 任意两条红色线段不相交。
2. 任意一条黑色线段**至少**和一条红色线段相交。

请最小化红色线段的长度和，并输出这个长度和。

一条线段 $[l_i,r_i]$ 的长度定义为 $r_i-l_i$，两条线段 $[l_i,r_i],[l_j,r_j]$ 交**当且仅当** $l_i\le r_j$ 且 $l_j\le r_i$。

## 说明/提示

**数据范围**

|测试点编号|$n\le$|
| :----------: | :----------: |
|$1\sim4$|$10$|
|$5\sim8$|$400$|
|$9\sim20$|$3000$|

对于所有数据，满足 $-10^9\le l_i<r_i\le10^9$。


## 样例 #1

### 输入

```
5
-6 5
1 3
-4 9
-1 10
6 8
```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解均围绕给定线段染色问题，要求满足红色线段不相交，黑色线段至少与一条红色线段相交，目标是最小化红色线段长度和。多数题解采用动态规划（DP）方法，核心在于设计合适的状态和状态转移方程。

1. **思路与算法要点**：
    - **排序**：大多先按线段左端点或右端点排序，确保DP顺序合理，便于状态转移。
    - **状态设计**：常见的是设 \(dp_i\) 表示第 \(i\) 条线段染成红色时，前 \(i\) 条线段满足条件的最小红色线段长度和。
    - **状态转移**：关键在于确定能从哪些 \(dp_j\)（\(j < i\)）转移到 \(dp_i\)。需同时满足两条红色线段不相交（如 \(r_j < l_i\)），以及 \(j\) 到 \(i\) 之间的黑色线段至少与一条红色线段相交。
2. **解决难点**：
    - 难点在于如何简洁高效地判断 \(j\) 到 \(i\) 之间的黑色线段与红色线段相交情况。部分题解通过维护一些辅助变量（如满足 \(r_k < l_i\) 的线段中 \(l_k\) 的最大值），或利用数据结构（如线段树、单调队列）优化判断过程。
3. **优化程度**：
    - **\(O(n^2)\) 解法**：多数题解先给出此朴素解法，通过两重循环枚举 \(i\) 和 \(j\) 来进行状态转移。
    - **\(O(n \log n)\) 解法**：部分题解使用线段树优化区间查询，将时间复杂度降低。具体是将 \(dp_j\) 存于线段树中 \(r_j\) 的位置，查询区间 \([pos, l_i)\) 的最小值，其中 \(pos\) 为满足特定条件的位置。
    - **\(O(n)\) 解法**：利用单调队列优化，结合基数排序，进一步提升效率。利用 \(pos\) 和 \(l_i\) 的单调性，用单调队列代替线段树进行区间最值查询。

### 所选的题解
#### 作者：xieyikai2333 (4星)
- **关键亮点**：思路清晰，先给出 \(O(n^2)\) 的朴素DP解法，再逐步分析优化到 \(O(n \log n)\) 以及 \(O(n)\) 的解法，每个步骤详细。
- **个人心得**：无

**\(O(n^2)\) 核心代码**：
```cpp
#include <bits/stdc++.h>
#define l first
#define r second
using namespace std;
const int N = 3005;
long long dp[N];
pair<int, int> a[N];
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d %d", &a[i].l, &a[i].r);
    sort(a + 1, a + n + 1);
    long long ans = LLONG_MAX;
    a[0].r = INT_MIN;
    for (int i = 1; i <= n; i++) {
        dp[i] = LLONG_MAX / 3;
        int pre = INT_MIN;
        for (int j = 1; j < i; j++) if (a[j].r < a[i].l && a[j].l > pre) pre = a[j].l;
        for (int j = 0; j < i; j++) if (a[j].r < a[i].l && a[j].r >= pre) dp[i] = min(dp[i], dp[j] + (a[i].r - a[i].l));
        if (a[i].r >= a[n].l) ans = min(ans, dp[i]);
    }
    printf("%lld", ans);
    return 0;
}
```
**核心实现思想**：先按左端点排序线段，通过两重循环，外层枚举当前染红色的线段 \(i\)，内层循环确定满足条件的前一条红色线段 \(j\)，并维护满足条件的 \(j\) 到 \(i\) 间黑色线段对应的左端点最大值 \(pre\)，从而实现状态转移。

**\(O(n \log n)\) 核心代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 3005;
int tmp[N << 1], pos[N << 1], dp[N];
struct node {
    int l, r, x;
    bool operator < (const node &o)const {
        return this->l < o.l;
    }
}a[N];
struct SGT {
    int mi[N << 3];
    SGT() { memset(mi, 0x3f, sizeof(mi)); }
    void modify(int p, int l, int r, int x, int v) {
        if (l == r) return mi[p] = min(mi[p], v), void();
        int mid = (l + r) >> 1;
        if (x <= mid) modify(p << 1, l, mid, x, v);
        else modify(p << 1 | 1, mid + 1, r, x, v);
        mi[p] = min(mi[p << 1], mi[p << 1 | 1]);
        return;
    }
    int query(int p, int l, int r, int x, int y) {
        if (x > r || y < l) return LLONG_MAX;
        if (x <= l && r <= y) return mi[p];
        int mid = (l + r) >> 1;
        return min(query(p << 1, l, mid, x, y), query(p << 1 | 1, mid + 1, r, x, y));
    }
}sgt;
int lsh(int n) {
    for (int i = 1; i <= n; i++) tmp[2 * i - 1] = a[i].l, tmp[2 * i] = a[i].r;
    sort(tmp + 1, tmp + 2 * n + 1);
    int len = unique(tmp + 1, tmp + 2 * n + 1) - tmp - 1;
    for (int i = 1; i <= n; i++) {
        a[i].x = a[i].r - a[i].l;
        a[i].l = lower_bound(tmp + 1, tmp + len + 1, a[i].l) - tmp;
        a[i].r = lower_bound(tmp + 1, tmp + len + 1, a[i].r) - tmp;
    }
    return len;
}
signed main() {
    int n;
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++) scanf("%lld %lld", &a[i].l, &a[i].r);
    sort(a + 1, a + n + 1);
    int m = lsh(n), p = 1, pre = 0, ans = LLONG_MAX;
    for (int i = 1; i <= n; i++) pos[a[i].r] = a[i].l;
    sgt.modify(1, 0, m, 0, 0);
    for (int i = 1; i <= n; i++) {
        while (p < a[i].l) pre = max(pre, pos[p++]);
        dp[i] = sgt.query(1, 0, m, pre, a[i].l - 1) + a[i].x;
        sgt.modify(1, 0, m, a[i].r, dp[i]);
        if (a[i].r >= a[n].l) ans = min(ans, dp[i]);
    }
    printf("%lld", ans);
    return 0;
}
```
**核心实现思想**：先离散化处理数据，利用线段树维护 \(dp_j\)，通过移动指针 \(p\) 确定 \(pos\)（满足条件的位置），每次查询线段树区间 \([pre, a[i].l - 1]\) 的最小值来更新 \(dp[i]\)，实现 \(O(n \log n)\) 的优化。

#### 作者：Targanzqq (4星)
- **关键亮点**：详细阐述单调队列优化DP的思路，从设计DP状态开始，分析转移条件，进而引入单调队列优化的原因及具体操作，对单调队列的讲解清晰。
- **个人心得**：无

**核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 1e9+7
#define N 1000005
#define em q.empty()
using namespace std;

int n;
struct segment{
    int l,r,len;
    friend bool operator<(segment a,segment b){
        return a.r<b.r;
    }
}a[N];
bool mycmp(segment a,segment b){
    return a.l<b.l;
}
int p[2*N],h[2*N],top;

int binary(int x,int l,int r){
    while(1){
        if(l>r)break;
        int mid=(l+r)/2;
        if(p[mid]<x)l=mid+1;
        else r=mid-1;
    }
    if(p[l]==x)return l;
    else return r;
}

void lsh(){
    for(int i=1;i<=n;i++)p[++top]=a[i].l,p[++top]=a[i].r;
    sort(p+1,p+top+1);
    int len=unique(p+1,p+top+1)-p-1; 
    for(int i=1;i<=n;i++){
        a[i].l=binary(a[i].l,1,len);
        a[i].r=binary(a[i].r,1,len);
    }
}

int f[2*N];
deque<int> q;

signed main(){
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].l>>a[i].r;
        a[i].len=a[i].r-a[i].l;
    }
    sort(a+1,a+n+1,mycmp);
    lsh();
    int ans=INF;
    for(int i=1;i<=2*n;i++)f[i]=INF;
    for(int i=1;i<=n;i++)h[a[i].r]=a[i].l;
    f[0]=0;q.push_back(0);
    for(int i=1,pos=1,maxn=0;i<=n;i++){
        while(pos<a[i].l){
            maxn=max(maxn,h[pos]);
            while(!em&&f[q.back()]>=f[pos])q.pop_back();
            q.push_back(pos++);
        }
        while(!em&&q.front()<maxn)q.pop_front();
        f[a[i].r]=min(f[a[i].r],f[q.front()]+a[i].len);
        if(a[i].r>=a[n].l)ans=min(ans,f[a[i].r]);
    }
    cout<<ans;
}
```
**核心实现思想**：先按左端点排序并离散化线段，设计 \(f_i\) 表示离散化后对应线段染红色的最小代价。利用单调队列维护 \(j\in[pre, i]\) 区间内 \(f_j\) 的最小值，通过移动指针 \(pos\) 更新 \(maxn\)（满足条件的左端点最大值），进而实现状态转移和答案更新。

#### 作者：Lucyna_Kushinada (4星)
- **关键亮点**：先猜测能转移到 \(i\) 的线段编号构成区间 \([x, y]\)，并通过二分确定 \(x\) 和 \(y\) 的位置，再利用线段树优化，思路独特且清晰。
- **个人心得**：无

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define per(i,l,r) for(int i=(r);i>=(l);--i)
#define pr pair<int,int>
#define fi first
#define se second
#define pb push_back

#define N 1000010
#define int long long

const int lim = 1e6 + 5;
int n, dp[N], mx[N];

struct ln {
    int l, r;
}a[N];

inline bool cmp(ln x, ln y) {
    if (x.r!= y.r) {
        return x.r < y.r;
    }
    return x.l < y.l;
}

struct SEGT {
    int tr[N << 2];

    inline void un(int k) {
        tr[k] = min(tr[k * 2], tr[k * 2 + 1]);
    }

    inline void build(int k, int l, int r) {
        if (l == r) {
            tr[k] = 1e17;
            return;
        }
        int mid = (l + r) >> 1;
        build(k * 2, l, mid);
        build(k * 2 + 1, mid + 1, r);
        un(k);
    }

    inline void upd(int L, int k, int l, int r, int d) {
        if (l == r) {
            tr[k] = d;
            return;
        }
        int mid = (l + r) >> 1;
        if (L <= mid) {
            upd(L, k * 2, l, mid, d);
        }
        else {
            upd(L, k * 2 + 1, mid + 1, r, d);
        }
        un(k);
    }

    inline int ask(int L, int R, int k, int l, int r) {
        if (L <= l && R >= r) {
            return tr[k];
        }
        int mid = (l + r) >> 1, ans = 1e17;
        if (L <= mid) {
            ans = ask(L, R, k * 2, l, mid);
        }
        if (R > mid) {
            ans = min(ans, ask(L, R, k * 2 + 1, mid + 1, r));
        }
        return ans;
    }
}b;

inline int getr(int k) {
    int l = 0, r = k - 1, mid, ans = -1;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (a[mid].r < a[k].l) {
            ans = mid;
            l = mid + 1;
        }
        else {
            r = mid - 1;
        }
    }
    return ans;
}

inline int getl(int R) {
    int l = 0, r = R, mid, ans = -1;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (a[mid].r >= mx[R]) {
            ans = mid;
            r = mid - 1;
        }
        else {
            l = mid + 1;
        }
    }
    return ans;
}

signed main() {
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    int lmx = -1e9;
    cin>>n;
    rep(i,1,n) {
        cin>>a[i].l>>a[i].r;
        lmx = max(lmx, a[i].l);
    }
    sort(a + 1, a + 1 + n, cmp);
    a[0].l = a[0].r = -2e9;

    int ans = 1e17;
    b.build(1, 0, lim);
    b.upd(0, 1, 0, lim, 0);
    mx[0] = -2e9;
    rep(i,1,n) {
        mx[i] = max(mx[i - 1], a[i].l);
    }
    rep(i,1,n) {
        int r = getr(i);
        int l = getl(r);
        if (r == -1 || l == -1) {
            continue;
        }
        dp[i] = b.ask(l, r, 1, 0, lim) + a[i].r - a[i].l;
        b.upd(i, 1, 0, lim, dp[i]);
        if (

---
处理用时：180.71秒
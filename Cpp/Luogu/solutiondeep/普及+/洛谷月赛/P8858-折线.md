# 题目信息

# 折线

## 题目描述

平面直角坐标系的第一象限内有一块左下角为 $(0,0)$ 右上角为 $(10^{100},10^{100})$ 的矩形区域，区域内有**正偶数**个整点，试求出这样一条从 $(0,0)$ 出发，到 $(10^{100},10^{100})$ 的在区域内部的折线：

- 折线的每一部分都平行于 $x$ 轴或 $y$ 轴。
- 折线不能经过给定的整点。
- 折线将整块区域分成包含给定整点个数相等的两块。
- 折线拥有尽可能少的折点。

可以证明一定存在一条满足限制的折线，你只需要输出满足限制的折线的折点数即可。

注意折点的坐标可以不是整数。

## 说明/提示

#### 【样例解释】

对于第一组数据，一条合法的折线为：$(0,0) \to (2.5,0) \to (2.5,10^{100}) \to (10^{100},10^{100})$，它有 $(2.5,0)$ 和 $(2.5,10^{100})$ 两个折点。

#### 【数据范围】

|  测试点编号 | $n \leq$ |      特殊限制      |
|:-----------:|:--------:|:------------------:|
|  $1 \sim 2$ |    $4$   |         无         |
|  $3 \sim 4$ |   $10$   |         无         |
|  $5 \sim 6$ |   $50$  |         无         |
|  $7 \sim 8$ |  $10^5$  | 保证答案不大于 $3$ |
| $9 \sim 10$ | $10^5$   | 无                 |

对于所有数据，$1 \leq T \leq 10^4, 1 \leq \sum n \leq 5 \times 10^5, 1 \leq x_i,y_i \leq n$，保证 $n$ 为正偶数，每组数据中不存在两个坐标相同的整点。

## 样例 #1

### 输入

```
3
4
1 1
1 2
4 1
4 2
6
1 2
1 3
2 1
2 2
2 3
3 2
12
1 3
2 2
2 3
2 4
3 1
3 2
3 4
3 5
4 2
4 3
4 4
5 3
```

### 输出

```
2
3
4```

# AI分析结果

• 综合分析与结论：这些题解都基于答案在2到4之间这一结论展开。思路上，均先判断答案为2的情况，即是否存在平行坐标轴的直线将点集均分；再判断答案为3的情况，查看是否能通过切割出左上角或右下角矩形区域使点数为n/2 ；若都不满足则答案为4。算法要点在于排序、前缀和、双指针、树状数组、线段树等的运用。解决难点主要是如何高效判断答案为3的情况。

所选的题解：
  - 作者bmatrix (5星)
    - 关键亮点：思路清晰，对答案为2、3、4的情况分别详细分析，给出具体判断方法和证明，代码实现简洁明了，用树状数组优化判断过程。
    - 重点代码核心思想：先通过排序判断答案是否为2。再用树状数组辅助，从右往左遍历点的横坐标，二分纵坐标判断是否存在满足条件的右下角矩形区域（同理判断左上角）。
```cpp
// 树状数组相关操作
void add(int i, int v) {
    for(; i <= n; i += lb(i)) tr[i] += v;
}
int sum(int i) {
    int res = 0;
    for(; i; i -= lb(i)) res += tr[i];
    return res;
}
void solve() {
    cin >> n;
    vector<pii> a;
    rep(i, 1, n) {
        int x, y; cin >> x >> y;
        a.emplace_back(x, y);
    }
    // 判断答案是否为2
    sort(a.begin(), a.end(), [](pii a, pii b){return a.S == b.S? a.F < b.F : a.S < b.S;});
    if(a[n / 2].S!= a[n / 2 - 1].S) {
        cout << 2 << endl; return;
    }
    sort(a.begin(), a.end());
    if(a[n / 2].F!= a[n / 2 - 1].F) {
        cout << 2 << endl; return;
    }
    // 判断答案是否为3（左上角矩形）
    int i = 0;
    while(i < n) { 
        int t = a[i].F;
        while(i < n && a[i].F == t){
            add(a[i].S, 1);
            ++i;
        }
        if(i < n / 2) continue;
        int l = 1, r = n;
        while(l < r) {
            int mid = (l + r) / 2;
            int s = i - sum(mid);
            if(s == n / 2) {
                cout << 3 << endl; return;
            }
            if(s < n / 2) r = mid;
            else l = mid + 1;
        }
    }
    clear(); 
    // 判断答案是否为3（右下角矩形）
    i = n - 1;
    while(i >= 0) { 
        int t = a[i].F;
        while(i >= 0 && a[i].F == t){
            add(a[i].S, 1);
            --i;
        }
        if(i > n / 2) continue;
        int l = 1, r = n;
        while(l < r) {
            int mid = (l + r) / 2;
            int s = sum(mid);
            if(s == n / 2) {
                cout << 3 << endl; return;
            }
            if(s < n / 2) l = mid + 1;
            else r = mid;
        }
    }
    cout << 4 << endl;
}
```
  - 作者spdarkle (4星)
    - 关键亮点：复杂度最优为O(n)，通过双指针和悬线法解决问题，对答案范围给出详细引理证明。
    - 重点代码核心思想：通过前缀和判断答案是否为2。用双指针移动模拟悬线法，判断是否存在满足条件的矩形区域（从x折和从y折两种情况）。
```cpp
// 判断答案是否为2
inline bool check2() {
    for (int i = 1, j = 0, k = 0; i <= n; i++) {
        j += g1[i];
        k += g2[i];
        if (j == n / 2 || k == n / 2)return true;
    }
    return false;
}
// 判断答案是否为3（矩形(i,1,n,j)）
inline bool check3_1() {
    int l = 1, r = 1, m = 0;
    while (l <= n) {
        while (m < n / 2 && r <= n) {
            m += g2[r] - f2[r];
            r++;
        }
        if (m == n / 2)return true;
        int len = s1[l].size();
        for (int i = 0; i < len; i++) {
            f2[a[s1[l][i]].y]++;
            if (a[s1[l][i]].y < r)m--;
        }
        l++;
    }
    if (m == n / 2)return true;
    return false;
}
```
  - 作者OldDriverTree (4星)
    - 关键亮点：思路简洁明了，代码简洁，利用桶排序优化时间复杂度，对答案为3的情况分析详细。
    - 重点代码核心思想：用桶记录点的出现次数，通过前缀和判断答案是否为2。对答案为3的情况，从大到小枚举X，利用双指针思想调整Y，判断是否存在满足条件的区域。
```cpp
// 判断答案是否为3
bool judge()
{
    sort(a+1,a+n+1);
    memset(tax,0,sizeof(int)*(n+1) );
    for (int i=n,pos=n,cnt=0,now=1;i;i--)
    {
        while (now<=n&&a[now].x==i) {
            if (a[now].y>pos) { now++; continue; }
            cnt++,tax[a[now].y]++,now++;
        }
        while (pos>0&&cnt>n/2) cnt-=tax[pos--];
        if (cnt==n/2) return true;
    }
    return false;
}
char solve()
{
    n=read(),memset(tax,0,sizeof(int)*(n+1) );
    for (int i=1;i<=n;i++) a[i]={read(),read()},tax[a[i].x]++;
    // 判断答案是否为2
    for (int i=1,sum;i<=n;i++) { sum+=tax[i]; if (sum==n/2) return '2'; }
    memset(tax,0,sizeof(int)*(n+1) ); for (int i=1;i<=n;i++) tax[a[i].y]++;
    for (int i=1,sum;i<=n;i++) { sum+=tax[i]; if (sum==n/2) return '2'; }
    if (judge() ) return '3'; for (int i=1;i<=n;i++) swap(a[i].x,a[i].y);
    return judge()?'3':'4';
}
```

最优关键思路或技巧：利用排序、前缀和快速判断答案为2的情况；对于答案为3的情况，通过双指针、树状数组等优化判断是否存在满足条件的矩形区域。

可拓展之处：同类型题可涉及更多二维区域分割、点集划分问题，类似算法套路包括利用数据结构优化二维数点、区域统计等操作。

推荐题目：
  - P3374 【模板】树状数组 1
  - P3368 【模板】树状数组 2
  - P1908 逆序对

个人心得：无。 

---
处理用时：73.65秒
# 题目信息

# [yLOI2023] 云梦谣

## 题目背景

> 归来且做云梦梦一场 大梦好  
> 栽花闻酒香 醒醒醉醉笑笑  
> 天地偌大复路远山高 最难得偷半日逍遥  
> 偶尔糊涂不问世事不知晓

——银临 & 慕寒《云梦谣》

## 题目描述

“喂，枸杞，你这只笨狗，又偷吃！看我不收拾你！”

朵一气呼呼地从院子里跑出来，手中握着掸子，而枸杞早已不见踪影。

云梦庭可以看作一个 $n$ 行 $m$ 列的方格阵，第 $i$ 行第 $j$ 列的格子被记作 $(i,j)$。每个格子 $(i,j)$ 要么有一个高度 $h_{i,j}$（$h_{i,j}$ 为正整数），要么是障碍物，不能通过。（方便起见，约定障碍物的 $h_{i,j}$ 用 $0$ 表示。）另外，云梦庭上有 $k$ 个指定的格子上可以进行**御剑飞行**。开始时，朵一和枸杞分别位于方格 $(1,1)$ 和 $(n,m)$。

朵一的御剑飞行还不是很熟练，现在她还控制不好御剑的高度。因此在任意时刻，朵一在方格 $(i,j)$ 上可以做如下行动之一：

- 移动到与该方格相邻的方格 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$、$(i,j+1)$ 之一上（不能移动出方格边界，也不能移动到障碍物上）；
- 如果方格 $(i,j)$ 上允许御剑飞行，则朵一可以御剑飞行至另一个**同样允许御剑飞行且与方格 $(i,j)$ 高度相等的方格上**；
- 使用仙法将当前格子的高度 $h_{i,j}$ 改变为任一正整数。

进行上述每项行动均需花费 $1$ 个单位时间。

“哼，笨狗子你再跑！”说罢，朵一便追了出去。朵一接下来还要尽快继续今天的修行，因此她想知道到达 $(n,m)$ 格子所需的最短时间是多少。

## 说明/提示

### 样例 1 解释

第 $1$ 个单位时间，朵一将当前方格 $(1,1)$ 的高度修改为 $4$；  
第 $2$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(3,4)$；  
第 $3$ 个单位时间，朵一从方格 $(3,4)$ 移动到 $(4,4)$，追上了枸杞。

### 样例 2 解释

第 $1$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(4,1)$；  
第 $2$ 个单位时间，朵一从方格 $(4,1)$ 移动到 $(4,2)$；  
第 $3$ 个单位时间，朵一从方格 $(4,2)$ 移动到 $(4,3)$；  
第 $4$ 个单位时间，朵一从方格 $(4,3)$ 移动到 $(4,4)$，追上了枸杞。

### 数据规模与约定


![](https://cdn.luogu.com.cn/upload/image_hosting/f2epmv84.png)

对全部的测试点，保证 $1 \leq n, m \leq 3 \times 10^3$，$0 \leq k,h_{i,j} \leq n \times m$。
### 提示

请注意大量数据读入对程序效率造成的影响，选择合适的读入方式，避免超时。

### 说明

本题共有 5 个附加样例文件，见附件里的 dream.zip。

### 后记

不过，别看朵一现在一副生气的样子，可当她追上枸杞后，大抵是不舍得真的动手吧。“嘿嘿，今日的修行结束后，该吃什么好呢？”在这飞瀑悬挂、翠竹怀抱的云梦庭中，修仙炼体，不羡尘嚣，应是这世上最逍遥的事了。

## 样例 #1

### 输入

```
4 4 2
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 1
3 4```

### 输出

```
3```

## 样例 #2

### 输入

```
4 4 3
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 1
2 4
4 1```

### 输出

```
4```

## 样例 #3

### 输入

```
2 5 0
1 0 3 3 4
2 3 4 0 5```

### 输出

```
7```

## 样例 #4

### 输入

```
4 4 3
1 1 1 0
1 1 0 1
1 0 1 1
0 1 1 1
1 1
2 1
3 3```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是利用广度优先搜索（BFS）求解从起点到终点的最短路径，并通过贪心策略优化。主要差异在于对御剑飞行操作的处理方式。

多数题解通过两次BFS分别找到离起点和终点最近的御剑飞行点，利用贪心策略证明御剑飞行至多使用一次且应在离起点和终点最近的传送点间进行，通过比较这些点的高度来确定是否需要改变高度，从而得出最短时间。部分题解还考虑了不同情况下的时间复杂度优化。

### 所选的题解
- **一扶苏一**：★★★★★
  - **关键亮点**：详细分析了多种特殊情况的解法，逐步优化算法，从简单情况入手，最终得出 $O(nm + k)$ 的高效解法，思路清晰，代码实现完整且注释详细。
  - **个人心得**：无
  - **重点代码 - 核心实现思想**：通过两次 `bfs` 函数分别计算起点和终点到各点的距离，找出离起点和终点最近的传送阵，用桶记录离起点最近传送阵的高度，遍历离终点最近的传送阵判断是否有等高的，从而确定最短时间。
```cpp
int bfs(int bx, int by, int ex, int ey, int d[][maxn]) {
    int ret = INF;
    std::queue<std::pair<int, int>> Q;
    d[bx][by] = 0;
    for (Q.push(std::make_pair(bx, by));!Q.empty(); Q.pop()) {
        int x = Q.front().first, y = Q.front().second;
        if (ret == INF && isTrans[x][y]) ret = d[x][y];
        for (int i = 0; i < 4; ++i) {
            int px = dx[i] + x, py = dy[i] + y;
            if (px && py && px <= n && py <= m && h[px][py] && d[px][py] == INF) {
                d[px][py] = d[x][y] + 1;
                Q.push(std::make_pair(px, py));
            }
        }
    }
    return ret;
}
```
- **_shy**：★★★★
  - **关键亮点**：对御剑飞行的情况分析全面，通过贪心策略确定只需要找到距离起点和终点最近的可御剑飞行格子，用桶记录高度判断是否有相同高度的点，时间复杂度为 $O(nm + k)$，代码简洁明了。
  - **个人心得**：无
  - **重点代码 - 核心实现思想**：通过 `bfs` 函数分别从起点和终点出发，记录距离起点和终点最近的可御剑飞行格子的信息，通过桶数组 `vish` 判断是否有高度相同的点，从而计算出最短用时。
```cpp
void bfs (int sx, int sy, int tp) 
{
    if (visk[sx][sy] && tp!= 2) 
    {
        if (tp == 0) 
        {
            vish[h[sx][sy]] = 1;
            ansi = 0;
        }
        else if (tp == 1)
        {
            if (vish[h[sx][sy]]) ansii = 0;
            flag = 1;
        }
        return;
    }
    q = emptyi;
    memset (vis, 0, sizeof (vis));
    vis[sx][sy] = 1;
    q.push (make_pair (make_pair (sx, sy), 0));
    while (!q.empty ()) 
    {
        int x = q.front().first.first,
            y = q.front().first.second,
            s = q.front().second ; q.pop();
        for (int i = 1; i <= 4; i++) 
        {
            int tx = x + dx[i],
                ty = y + dy[i];
            
            if (tx < 1 || ty < 1 || tx > n || ty > m || h[tx][ty] == 0) continue;
            if (vis[tx][ty]) continue;
            q.push (make_pair (make_pair (tx, ty), s + 1));
            vis[tx][ty] = 1;
            if (tp == 0) 
            {
                if (ansi!= -1 && s + 1 > ansi) return;
                if (ansi!= -1 && visk[tx][ty]) vish[h[tx][ty]] = 1;
                else if (ansi == -1 && visk[tx][ty])
                    ansi = s + 1,
                    vish[h[tx][ty]] = 1;
            }
            else if (tp == 1)
            {
                if (ansii!= -1 && s + 1 > ansii) return; 
                if (ansii!= -1 && visk[tx][ty] && vish[h[tx][ty]]) flag = 1;
                else if (ansii == -1 && visk[tx][ty]) ansii = s + 1, flag = vish[h[tx][ty]]? 1 : 0;
            }
            else 
            {
                if (tx == n && ty == m) 
                {
                    ans = s + 1;
                    return;
                }
            }
        }
    }
}
```
- **zrt090604**：★★★★
  - **关键亮点**：通过模拟样例推导算法，证明了贪心策略的正确性，即选择起点和终点处最近的可以飞行的点，考虑了多种特殊情况，如不是所有图都能飞行、多个飞行点距离起点相同等，代码思路清晰。
  - **个人心得**：做题时遇到很多注意事项，如判断图是否能飞行、处理高度等，通过分析样例和特殊情况得出正确解法。
  - **重点代码 - 核心实现思想**：通过 `solve1` 和 `solve2` 函数分别从起点和终点进行 BFS，记录离起点和终点最近的飞行点的高度，通过 `solve3` 函数进行普通 BFS，最后比较不同策略下的最短时间。
```cpp
void solve1(int x, int y) {
    fr = 0, rr = 0;
    int mn = 1e9;
    q[rr++] = {x, y, 0};
    while(fr < rr) {
        Node u = q[fr++];
        if(p[u.x*3005+u.y]) {
            if(u.step < mn) mn = u.step, ans1 = mn;
            if(u.step > mn) return;
            s[++cnt] = a[u.x][u.y];
        }
        for(int i = 0;i < 4;++i) {
            int xx = u.x + dir[i][0], yy = u.y + dir[i][1];
            if(xx>0 && xx<=n && yy>0 && yy<=m && a[xx][yy] &&!vis[xx][yy]) {
                vis[xx][yy] = true;
                q[rr++] = {xx, yy, u.step+1};
            }
        }
    }
}
void solve2(int x, int y) {
    fr = 0, rr = 0;
    int mn = 1e9;
    q[rr++] = {x, y, 0};
    while(fr < rr) {
        Node u = q[fr++];
        if(p[u.x*3005+u.y]) {
            if(u.step < mn) mn = u.step, ans2 = mn;
            if(u.step > mn) return;
            e[++cnt2] = a[u.x][u.y];
        }
        for(int i = 0;i < 4;++i) {
            int xx = u.x + dir[i][0], yy = u.y + dir[i][1];
            if(xx>0 && xx<=n && yy>0 && yy<=m && a[xx][yy] &&!vis[xx][yy]) {
                vis[xx][yy] = true;
                q[rr++] = {xx, yy, u.step+1};
            }
        }
    }
}
void solve3(int x, int y) {
    fr = 0, rr = 0;
    q[rr++] = {x, y, 0};
    while(fr < rr) {
        Node u = q[fr++];
        if(u.x==n && u.y==m) {ans3 = u.step; return;}
        for(int i = 0;i < 4;++i) {
            int xx = u.x + dir[i][0], yy = u.y + dir[i][1];
            if(xx>0 && xx<=n && yy>0 && yy<=m && a[xx][yy] &&!vis[xx][yy]) {
                vis[xx][yy] = true;
                q[rr++] = {xx, yy, u.step+1};
            }
        }
    }
}
```

### 最优关键思路或技巧
1. **贪心策略**：证明御剑飞行至多使用一次且应在离起点和终点最近的传送点间进行，大大减少了搜索空间。
2. **两次BFS**：分别从起点和终点进行BFS，找到最近的御剑飞行点，便于后续计算和比较。
3. **桶记录高度**：用桶记录离起点最近传送阵的高度，快速判断是否存在与离终点最近传送阵等高的点，优化时间复杂度。

### 可拓展思路
此类题目属于网格图上的最短路径问题，可拓展到其他具有特殊移动规则的网格图场景。类似算法套路包括利用贪心策略简化问题、通过多次BFS获取关键信息、使用合适的数据结构（如桶）优化判断过程。

### 相似知识点洛谷题目
1. [P1332 血色先锋队](https://www.luogu.com.cn/problem/P1332)：网格图上的最短路径问题，涉及特殊的移动规则和条件判断。
2. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)：同样是网格图，通过BFS求解连通块相关问题，可类比本题的搜索过程。
3. [P2734 [USACO3.3] 骑马修栅栏 Riding the Fences](https://www.luogu.com.cn/problem/P2734)：虽然场景不同，但也需要利用搜索算法（本题为BFS类似思路）结合一定的策略（如欧拉路径相关知识）来解决问题。 

---
处理用时：101.97秒
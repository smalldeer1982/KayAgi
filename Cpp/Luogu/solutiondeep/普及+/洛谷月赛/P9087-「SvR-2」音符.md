# 题目信息

# 「SvR-2」音符

## 题目描述

>本题中「子串」指：
>
>若字符串 $s$ 中有一段**连续的**字符构成字符串 $p$，则 $p$ 是 $s$ 的子串。

我们用一个字符串代替一份乐谱，用字符代替每一个音符。

我们定义「重音」表示乐谱中出现了两个**连续**的相同字符，如 $\tt eeeee$ 中存在 $4$ 个「重音」。

现在 Sept 准备写一份长度为 $n$ 的乐谱给 Tpes 看，他对乐谱的评价标准如下：

- 乐谱中每出现一个「重音」，他的愤怒值就会增加 $a$。
- 乐谱中每有一段长度为 $k$ 的**子串**中不存在「重音」，他的愤怒值就会增加 $b$。

现在已知 $n,k,a,b$，请你帮 Sept 构造出一份乐谱，使得 Tpes 的愤怒值 $x$ **最小**。

## 说明/提示

#### 数据规模与约定

**本题采用捆绑测试。**

| $\bf{Subtask}$ | $\bm{n\le}$ | $\bm{\sum n\le}$ | $\bm{T\le}$ | $\bf{Score}$ |
| :-: | :-: | :-: | :-: | :-: |
| $\sf 1$ | $6$ | $10$ | $3$ | $\tt 10$ |
| $\sf 2$ | $10^3$ | $2\times 10^3$ | 无特殊限制 | $\tt 30$ |
| $\sf 3$ | 无特殊限制 | 无特殊限制 | 无特殊限制 | $\tt 60$ |

对于 $100\%$ 的数据，有 $2\le T\le 100$，$2\le n,k\le 10^5$，$1\le a,b\le 10^9$。单组数据内保证 $\sum n\le 2\times 10^5$。

#### 输出注意事项

输出 $x$ 和构造乐谱可以看作是两个子问题，如果你只会完成其中的一个，请在另一个子问题对应的地方用**符合要求的字符或数字**占位。

乐谱中你可以输出任意字符，包括数字、大小写字母等，但**不能出现空格**。

#### Special Judge 返回信息说明

本题采用 Special Judge 判断你的答案是否正确。

checker.cpp 将会以 $\texttt{Score=}\text A,\texttt{Type=}\text B$ 的方式返回信息。

$\tt Score$ 类表示你的得分情况，$\text A$ 有以下取值：

- $\text A=1$，表示含义如下：\
  $\underline\text{Accepted.} \texttt{ Your Ans and SM are both proper.}$\
  代表 $T$ 组答案全部符合要求。
- $\text A=2$，表示含义如下：\
  $\underline\text{Partially Correct.}\texttt{ All Ans are right.}$\
  表示该测试点中你的回答中 $x$ 全部正确，你能得到该测试点 $20\%$ 的分数。
- $\text A=3$，表示含义如下：\
  $\underline\text{Partially Correct.}\texttt{ You pass 70\% tests!}$\
  表示该测试点中你的回答正确的组数**不少于**$\lfloor0.7\times T\rfloor$（$x$ 与乐谱均符合要求），你能得到该测试点 $10\%$ 的分数。
- $\text A=4$，表示该测试点你只能拿到 $0$ 分。

$\tt Type$ 类表示你的得分情况，$\text B$ 有以下取值：

- $\text B=0$，表示你的答案全部正确，与 $\text A=1$ 配对。
- $\text B=1$，表示含义如下：\
  $\underline\text{Wrong Answer.}\texttt{ The length of your SM is not right!}$\
  代表你在一组数据中构造的乐谱的长度不为 $n$。
- $\text B=2$，表示含义如下：\
  $\underline\text{Wrong Answer.}\texttt{ Your Ans is not right!}$\
  代表你在一组数据中 $x$ 的值错误。
- $\text B=3$，表示含义如下：\
  $\underline\text{Wrong Answer.}\texttt{ Your Ans and SM are not matched!}$\
  代表你在一组数据中构造的乐谱使 Tpes 产生的愤怒值不为 $x$。

这里 $\text{Ans, SM}$ 分别表示 Answer（$x$ 的值）和 Sheet Music（乐谱）。

注意到 $\tt Type$ 只会反映你在该测试点中**第一次错误**的类型。

## 样例 #1

### 输入

```
2
4 5 2 2
8 6 3 2```

### 输出

```
0
Sept
3
2023yyds```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何构造使愤怒值最小的乐谱展开，核心在于权衡重音和无重音子串带来的代价。多数题解发现只用两种字符构造乐谱即可，且不同题解采用了不同方法：
 - **暴力枚举**：如Subtask 1中留给$O(T2^nn)$的选手，直接暴力搜索所有可能的乐谱构造，复杂度高，只适用于数据规模小的情况。
 - **动态规划**：一些题解通过定义状态和状态转移方程来求解，如定义$f(i)$或$f_{i,0}, f_{i,1}$等表示考虑到第$i$个字符时的最小愤怒值，通过枚举前一个状态来转移，朴素的动态规划复杂度为$O(n^2)$，部分题解通过单调队列优化、维护辅助变量等方式将转移优化到$O(1)$或$O(n)$，使整体复杂度降为$O(\sum n)$。
 - **贪心策略**：部分题解通过分析代价关系得出贪心策略，如比较$a$与$b\times(k - 1)$的大小来决定是否使用重音；还有通过证明最优解只有几种特定的平铺情况来构造。

综合来看，较好的题解应思路清晰、算法复杂度低且代码可读性强。

### 所选的题解
1. **作者：CSP_Sept (5星)**
    - **关键亮点**：思路清晰，对每个子任务都有明确的解法。在Subtask 3中，通过证明得出最优解只有三种特定的平铺情况，极大简化了问题，降低了算法复杂度，且证明过程逻辑严谨。
    - **核心代码片段**：此部分重点在于分析出三种情况，代码实现相对简单，假设`n`为乐谱长度，`k`为子串长度，`a`、`b`为代价系数，以下为构造思路伪代码：
```
// 情况1：平铺0
if (平铺0的代价最小) {
    构造全为0的长度为n - 1的01串
} 
// 情况2：平铺长为(k - 1)的串000…0001
else if (平铺000…0001的代价最小) {
    按000…0001循环拼接取前n - 1个字符构造01串
} 
// 情况3：平铺长为(k - 1)的串000…0001，但最后一个1改为0
else {
    按000…0001循环拼接，将最后一个1改为0，取前n - 1个字符构造01串
}
```
2. **作者：MarchKid_Joe (4星)**
    - **关键亮点**：通过分析重音（$\text{XX}$）对代价的影响，得出不使用$\text{XX}$的判断依据，进而分情况构造字符串。思路直观，代码实现简洁明了，还通过具体例子帮助理解构造过程。
    - **核心代码片段**：以下为核心构造部分代码
```cpp
if (k == 2) {
    ans = (n - 1) * min(a, b);
    goto print;
}
if (a >= (k - 1) * b) {
    ans = b * (n - k + 1);
    goto print;
}
for (int l = 1, r; m = l + k - 1, (r = m + k - 2) <= n; l = m)
    s[m] = s[m - 1] = same[(++cnt) & 1];
if (a < (n - m + 1) * b)
    s[m] = s[m - 1] = same[(++cnt) & 1];
else
    ans = (n - m + 1) * b;
print: cout << max(ans + a * cnt, 0ll) << '\n' << (s + 1) << '\n';
```
核心思想是先特判$k = 2$的情况，再根据$a$与$(k - 1)b$的大小关系决定构造方式，在构造含$\text{XX}$的字符串时，通过循环和条件判断确定$\text{XX}$的位置。
3. **作者：FanYongchen (4星)**
    - **关键亮点**：通过合理定义动态规划状态$f_{i,0}$和$f_{i,1}$，分别表示前$i$个字符中第$i$个与第$i - 1$个字符相同和不同时产生的最小愤怒值，清晰地列出状态转移方程。并通过记录辅助变量优化转移过程，将$O(n^2)$的复杂度优化到$O(n)$，最后通过记录转移路径来输出构造方案。
    - **核心代码片段**：状态转移部分代码
```cpp
for (int i = 2; i <= n; i++) {
    f[i][0] = min(f[i - 1][1], f[i - 1][0]) + a;
    if (f[i - 1][1] < f[i - 1][0]) {
        path[i][0][0] = i - 1;
        path[i][0][1] = 1;
    } else {
        path[i][0][0] = i - 1;
        path[i][0][1] = 0;
    }
    int pp = max(1ll, i + 2 - k);
    if (i - k + 2 > 1) {
        if (f[i - k + 2 - 1][0] - b * (i - k + 2 - 1) < minn) {
            minn = f[i - k + 2 - 1][0] - b * (i - k + 2 - 1);
            p = i - k + 2 - 1;
        }
    }
    path[i][1][1] = 0;
    path[i][1][0] = pp;
    f[i][1] = f[pp][0];
    if (pp!= -1 && minn + i * b + 2 * b - k * b < f[i][1]) {
        f[i][1] = minn + i * b + 2 * b - k * b;
        path[i][1][0] = p;
    }
}
```
核心思想是根据状态定义和代价规则进行状态转移，在转移$f_{i,1}$时，通过维护$f_{j,0} - j\times b$的最小值来优化转移。

### 最优关键思路或技巧
 - **贪心策略**：通过分析代价关系，如比较$a$与$b\times(k - 1)$的大小，直接得出构造方向，简化问题求解。
 - **动态规划优化**：合理定义状态和状态转移方程后，通过维护辅助变量（如$f_{j,0} - j\times b$的最小值）将$O(n^2)$的转移优化到$O(1)$，从而降低整体复杂度。

### 可拓展思路
此类题目属于构造优化类型，通常涉及多种代价的权衡。类似套路是先分析不同因素对目标值的影响，得出一些关键判断条件，再据此设计贪心策略或动态规划解法。对于动态规划，重点在于优化状态转移，可通过数据结构（如单调队列）或数学变换简化转移方程。

### 相似知识点洛谷题目
 - **P1090 [NOIP2004 提高组] 合并果子**：通过贪心策略解决合并代价最小化问题，与本题权衡不同代价构造最优方案类似。
 - **P1880 [NOIP2016 提高组] 石子合并**：经典的区间动态规划题目，通过合并石子的操作使代价最小，与本题在动态规划解决优化问题上有相似之处。
 - **P3146 [USACO16OPEN]248 G**：同样是通过操作使最终结果最优的问题，可使用动态规划求解，锻炼对状态和转移方程的设计能力。

### 个人心得摘录
暂未发现题解中有个人心得相关内容。 

---
处理用时：75.68秒
# 题目信息

# 夕阳西下几时回

## 题目背景

随着夕阳从山间落下，最后一丝余晖逐渐暗淡；美丽的晚霞，终究还是化作一片黑夜。在这番景象中，一阵又一阵的乡愁涌上心头；远离家乡的游子，就算不是病死他乡，又何时能回还？

## 题目描述

夕阳可以被视作由 $n$ 种不同颜色组成的一副图，其中第 $i$ 种的颜色为 $a_i$，满足 $a$ 是长度为 $n$ 的排列。

定义一个排列的乡愁度为：

+ 对于所有 $1\le i\le n$，记 $b_i=\gcd(a_i,a_{i+1})$。特别地，我们认为 $a_{n+1}=a_1$。
+ 排列 $a$ 的乡愁度为序列 $b$ 中**不同**元素的个数。

求是否有一个长度为 $n$，乡愁度为 $k$ 的排列 $p$。若有解，请输出任意一个排列。

## 说明/提示

**【提示】**

一个长度为 $n$ 的排列是一个满足 $1$ 到 $n$ 中的所有正整数恰好出现 $1$ 次的数组。例如，$[3,1,2]$ 是一个长度为 $3$ 的排列，而 $[5,5,1,2,3]$ 不是一个排列。

**【样例 1 解释】**

- 对于第一组数据，$b=[1,1,1,1,1,1,1]$，故 $p$ 的乡愁度为 $1$。
- 对于第二组数据，可以证明不存在这样的序列。
- 对于第三组数据，$b=[1,1,3,3,1,1,2,1,5,2,1]$，包含 $4$ 个不同的元素 — $1,2,3$ 和 $5$，故 $p$ 的乡愁度为 $4$。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（4 points）：$n\le 9$，$\sum n\le 100$。
-  Subtask 2（5 points）：$k=1$。
-  Subtask 3（13 points）：$\sum n\le 200$。
-  Subtask 4（30 points）：对于所有测试数据，保证有解。
-  Subtask 5（48 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$3\le n\le 3\times 10^5$，$1\le k\le n$，$\sum n \le 6\times 10^5$。

## 样例 #1

### 输入

```
3
7 1
6 5
11 4
```

### 输出

```
Yes
1 2 3 4 5 6 7
No
Yes
1 11 9 3 6 7 8 2 5 10 4
```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解首先都判断了 \(k > \lfloor\frac{n}{2}\rfloor\) 时无解，因为 \(1\) 到 \(n\) 中任意两个不同正整数的最大公约数至多为 \(\lfloor\frac{n}{2}\rfloor\)。对于有解情况，都利用了若两数有倍数关系，其最大公约数为较小数这一特性来构造排列。通过将数按一定规律连接，如从 \(1\) 开始不断乘 \(2\) 形成链，再将不同链相接，使相邻数产生不同的最大公约数，当 \(k\) 小于最大可能的不同最大公约数数量时，通过调整后续数字的排列来满足 \(k\) 的要求。
    - 算法要点：利用倍数关系构造排列，以满足乡愁度要求。部分题解采用先构造最大乡愁度排列，再根据 \(k\) 调整；部分题解直接按规则构造出满足 \(k\) 的排列。
    - 解决难点：如何构造排列使相邻数的最大公约数不同且满足 \(k\) 的数量要求，以及如何处理 \(k\) 小于最大可能乡愁度的情况。
    - 结论：各题解思路相近，主要差异在于代码实现细节和构造排列的具体方式。

所选的题解：
  - **作者：Ecrade_ (赞：22)  星级：5星**
    - **关键亮点**：思路清晰，先明确 \(k\) 的理论上界，然后分别给出达到上界和小于上界的构造方法，代码简洁高效，时间复杂度为 \(O(\sum n)\)。
    - **核心代码片段**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll t,n,k;
inline ll read(){
    ll s = 0,w = 1;
    char ch = getchar();
    while (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}
    while (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
    return s * w;
}
int main(){
    t = read();
    while (t --){
        n = read(),k = read();
        if (k > n / 2){puts("No"); continue;}
        puts("Yes"),printf("1 ");
        for (ll i = n;i >= k * 2 + 1;i -= 1) printf("%lld ",i);
        for (ll i = 1;i <= k * 2;i += 2) for (ll j = max(2ll,i);j <= k * 2;j *= 2) printf("%lld ",j);
        puts("");
    }
    return 0;
}
```
    - **核心实现思想**：先判断 \(k\) 是否大于上界，若否，先输出 \(1\)，再倒序输出 \(2k + 1\) 到 \(n\) 的数，最后按特定规律输出 \(1\) 到 \(2k\) 中形成倍数链的数。
  - **作者：SXqwq (赞：2)  星级：4星**
    - **关键亮点**：对构造思路分析详细，先证明 \(b\) 数组中不同数字的上限，再分别阐述如何构造最大乡愁度排列以及如何调整为满足 \(k\) 的排列，代码简洁明了。
    - **核心代码片段**：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int T;
int main()
{
    cin>>T;
    while(T--)
    {
        int n,k;
        scanf("%d%d",&n,&k);
        if(k > n/2) 
        {
            cout<<"No"<<endl;
            continue;
        }
        cout<<"Yes"<<endl;
        cout<<"1 ";
        for(int i=n;i>=2*k+1;i--) cout<<i<<" "; 
        for(int i=2;i<=2*k;i*=2) cout<<i<<" "; 
        for(int i=3;i<=2*k;i+=2) 
        {
            for(int j=i;j<=2*k;j*=2) cout<<j<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```
    - **核心实现思想**：与 Ecrade_ 的思路类似，先判断无解情况，有解时先输出 \(1\)，接着倒序输出多余部分，再分别构造 \(2\) 的整次幂和奇数的倍数链。
  - **作者：_Weslie_ (赞：0)  星级：4星**
    - **关键亮点**：详细分析了构造过程中的重复问题及解决方法，提出将数分成 \((a,2a,2^2a,2^3a,\dots)\) 拼成一组，并说明了如何处理 \(k\) 小于最大乡愁度的情况，思路清晰。
    - **核心代码片段**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,k,a[300005];
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&k);
        if(k>n/2){
            printf("No\n");
            continue;
        }
        cout<<"Yes\n1 ";
        for(int i=n;i>=2*k+1;i--)cout<<i<<' ';
        for(int i=1;i<=2*k;i+=2){
            for(int j=max(2,i);j<=k*2;j*=2)cout<<j<<' ';
        }
        cout<<endl;
    }
}
```
    - **核心实现思想**：先判断无解，有解时先输出 \(1\) 和倒序的 \(2k + 1\) 到 \(n\) 的数，再按特定规则输出 \(1\) 到 \(2k\) 中形成倍数链的数。

最优关键思路或技巧：利用数的倍数关系构造排列，通过将数按一定规律分组连接形成链，以产生不同的最大公约数。对于 \(k\) 小于最大可能乡愁度的情况，通过合理安排剩余数字的排列，如将 \(2k + 1\) 到 \(n\) 的数倒序排列在开头，避免对最大公约数的种类产生影响。

可拓展之处：同类型题可考察不同的数论性质在构造排列中的应用，类似算法套路是利用数之间的特定数学关系来满足题目所要求的某种统计量（如不同最大公约数的个数）。

推荐题目：
 - [P1072  Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)：涉及数论中最大公约数和最小公倍数的计算与应用。
 - [P2152  [SDOI2009]SuperGCD](https://www.luogu.com.cn/problem/P2152)：专注于大整数的最大公约数计算。
 - [P1572  [NOI2016] 区间](https://www.luogu.com.cn/problem/P1572)：结合了数论和区间统计等知识点。

个人心得：暂未发现题解中有个人心得相关内容。 

---
处理用时：84.55秒
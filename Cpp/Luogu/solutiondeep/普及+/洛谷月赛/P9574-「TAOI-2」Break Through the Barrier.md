# 题目信息

# 「TAOI-2」Break Through the Barrier

## 题目描述

有一个由 $\tt B$ 和 $\tt T$ 组成的字符串。

你可以进行如下操作：选择一个长度为 $4$ 的子串，其恰好等于 $\texttt{BTTB}$，并将其修改为 $\texttt{TBBT}$。你可以进行这种操作任意多次（也可以不操作）。

定义一个字符串的权值为最长的 $\texttt{T}$ 连续段长度。你需要通过如上操作使得字符串的权值尽可能大。输出这个最大值。

+ 子串的定义：一个字符串 $b$ 被称为字符串 $a$ 的子串，当且仅当可以通过删除 $a$ 开头若干个（可以是 $0$ 个，下同）字符和结尾若干个字符得到 $b$。
+ $\texttt{T}$ 连续段的定义：一个原字符串的仅由 $\texttt{T}$ 构成的子串。

## 说明/提示

**本题采用捆绑测试。**

记 $\sum n$ 为所有数据中的 $n$ 的和。

+ Subtask 0（5 pts）：$n \leq 7$。
+ Subtask 1（20 pts）：$T \leq 10$，$n \leq 10$。
+ Subtask 2（25 pts）：$\sum n \leq 5000$。
+ Subtask 3（5 pts）：保证给定的字符串无法进行任何操作。
+ Subtask 4（45 pts）：无特殊限制。

对于所有数据，$1 \leq T \leq 10^3$，$1 \leq n \leq 10^5$，$1 \leq \sum n \leq 5\times 10^5$，字符串只包含字符 `B` 和 `T`。

## 样例 #1

### 输入

```
6
3
TTT
4
BTTB
5
TBBTT
6
BTBTBB
7
BTTBTTB
17
TTBTBTTBTBTTTBTTB
```

### 输出

```
3
2
2
1
3
5
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是基于对操作性质的分析，即通过对“BTTB”和“TBBT”转换操作的研究，发现连续“T”段长度最多增加2，且需特定子串结构辅助扩展。各题解在具体实现上有所不同，有的通过双指针查找连续“T”段并判断两端是否可扩展，有的使用状态机、DP等方法。

### 所选的题解
- **作者：EdenSky (5星)**
    - **关键亮点**：思路分析详细，通过对样例的深入观察得出操作的传递性等重要推论，逻辑清晰；代码实现简洁高效，利用双指针查找有连续性的区间，并通过标记方向来判断对连续“T”区间长度的贡献。
    - **个人心得**：无
    - **核心代码**：
```cpp
while(r<=n){//通过双指针查找有连续性的区间
    l++,r++;
    if(c[l]=='B'&&c[l+1]=='T'&&c[l+2]=='T'&&c[l+3]=='B'){
        ri[r]++,le[l]++;//发现存在，则在两端打上标记，le的标记方向向左，ri向右
        while(c[r+1]=='T'&&c[r+2]=='B') r+=2,ri[r]++;//向左右扩展区块并打上标记（找尾巴）
        while(c[l-1]=='T'&&c[l-2]=='B') l-=2,le[l]++;
        l=r-1,r=l+3;//l跳到r的位置，在本次操作后l和r都会++，提前减1
    }
}
l=1,r=l;
while(r<=n){
    l=r,l++,r++;
    if(c[l]!='T') continue;//查询连续T区间
    while(c[r+1]=='T') r++;//扩展连续T区间
    ans=max(r-l+1+ri[l-1]+le[r+1],ans);//查询是否存在标记，注意方向
}
```
核心思想：利用双指针遍历字符串，找到“BTTB”及其扩展结构，标记其方向，再遍历连续“T”区间，结合标记计算可扩展后的最大长度。
- **作者：light_searcher (4星)**
    - **关键亮点**：采用贪心 + 模拟思路，先筛选长度≥maxlen - 1的“T”串，再判断其左右两边是否可使长度增加，最后通过剪枝优化，去除长度为1的“T”串的影响，使算法复杂度降低。
    - **个人心得**：无
    - **核心代码**：
```cpp
void find_out_T(){
    int bgin=0,len=0,tmp=0;
    for(int i=1;i<=n;i++)
        if(s[i]=='T'){
            tmp++;
            maxlen=max(maxlen,tmp);
        }
        else tmp=0;
    ans=maxlen;
    for(int i=1;i<=n;i++)
        if(s[i]=='T'){
            if(s[i-1]!='T') bgin=i;
            len++;
        }
        else{
            if(s[i-1]=='T'&&len>=maxlen-1)    
                g.push_back({bgin,bgin+len-1});
            len=0;
        }
    if(len>=maxlen-1) g.push_back({bgin,bgin+len-1});
}
bool search_l(int pos){
    for(int i=pos;i>=1;i-=2)
        if(s[i]=='T'&&s[i-1]=='B') return i!=pos;
        else if(s[i]!='B'||s[i-1]!='T') return 0;
    return 0;
}
bool search_r(int pos){
    for(int i=pos;i<=n;i+=2)
        if(s[i]=='T'&&s[i+1]=='B') return i!=pos;
        else if(s[i]!='B'||s[i+1]!='T') return 0;
    return 0;
}
for(int i=0;i<g.size();i++){
    int l=g[i].first,r=g[i].second;
    if(l==r) continue;
    ans=max(ans,r-l+1+search_l(l-1)+search_r(r+1));
}
```
核心思想：先找出长度≥maxlen - 1的连续“T”串，再分别判断其左右两侧是否存在可使该串长度增加的特定子串结构，最后结合剪枝优化计算最大长度。
- **作者：dino (4星)**
    - **关键亮点**：先分析出暴力思路，再通过处理冗余操作进行优化，利用DP思想，通过状态数组记录每个位置是否能变成“BT”和“TB”，从而快速判断连续“T”段两端能否扩展。
    - **个人心得**：在清空状态数组时要多清几个，因为会涉及到越界判断，这里容易出错。
    - **核心代码**：
```cpp
for(int i = 2; i <= n; i++){
    if(s[i]!= s[i - 1]){//为bt或tb
        if(s[i] == 'T') ltb[i] = ltb[i - 2], lbt[i] = 1;
        else lbt[i] = lbt[i - 2], ltb[i] = 1;
    }
}
for(int i = n - 1; i >= 1; i--){
    if(s[i]!= s[i + 1]){
        if(s[i] == 'T') rbt[i] = rbt[i + 2], rtb[i] = 1;
        else rtb[i] = rtb[i + 2], rbt[i] = 1;
    }
}
int l = 0, r = 0, mx = 0;
while(r <= n){
    if(s[r] == 'T') r++;
    else{
        int cnt = r - l - 1;
        if(lbt[l]) cnt++;//左边能增加一个
        if(rtb[r]) cnt++;//右边能增加一个
        mx = max(mx, cnt);
        l = r;
        r++;
    }
}
int cnt = r - l - 1;
if(lbt[l]) cnt++;
if(rtb[r]) cnt++;
mx = max(mx, cnt);
```
核心思想：通过DP预处理出每个位置是否能变成特定子串结构，再利用双指针遍历字符串，计算连续“T”段在可扩展情况下的最大长度。

### 最优关键思路或技巧
1. **规律推导**：通过对操作和样例的深入分析，得出连续“T”段长度最多增加2，且增加条件与特定子串结构（如“BTTB”及其扩展）相关的重要结论，为解题奠定基础。
2. **方向标记**：如EdenSky的题解，通过标记具有传递性的区块方向，简洁高效地判断对连续“T”区间长度的贡献，优化了计算过程。
3. **剪枝优化**：像light_searcher的题解，通过分析长度为1的“T”串对答案无影响，进行剪枝，降低算法复杂度。

### 可拓展思路
此类题目属于字符串操作与优化问题，关键在于深入分析操作对字符串结构的影响。类似套路包括对操作进行分类讨论、寻找操作不变量、利用状态记录等。同类型题可考虑字符串变换后求最值、判断是否能达到特定状态等。

### 相似知识点洛谷题目
1. **P1308 统计单词数**：涉及字符串查找与统计，需对字符串进行遍历和模式匹配，与本题对特定子串的查找判断有相似之处。
2. **P1501 单词方阵**：同样是字符串处理问题，需要在二维字符矩阵中寻找特定单词，考查对字符串的搜索与判断能力，与本题查找特定子串结构类似。
3. **P2758 编辑距离**：通过对字符串进行插入、删除、替换操作，求最小操作次数，与本题对字符串操作并优化结果的思路有相通之处。 

---
处理用时：85.88秒
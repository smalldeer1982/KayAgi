# 题目信息

# 幽默的世界。

## 题目背景

@【数据删除】 : 大家觉得呢 || @【数据删除】 : oi 生活总是充满了幽默。 不过学文化课或许也好不了多少？

## 题目描述

给定一个长为 $n$ 的序列 $a_1,a_2,\cdots,a_n$，定义 $a$ 的一个连续子序列 $a_l,a_{l+1},\cdots,a_r$ 是幽默的，当且仅当：

- $\sum\limits_{i=l}^ra_i>0$；
- 对于所有 $l\le x\le y<r$，满足 $\sum\limits_{i=x}^y a_i\le 0$。

$q$ 次询问，每次给定两个整数 $l,r$，查询满足以下条件的数对 $(l',r')$ 个数：

- $l\le l'\le r'\le r$；
- 连续子序列 $a_{l'},a_{l'+1},\cdots a_{r'}$ 是幽默的。

## 说明/提示

对于所有数据，保证 $1\le n,q\le 2\times 10^5$，$1\le l\le r\le n$，$|a_i|\le 10^9$。

### 子任务

|  #   |       特殊性质        | 分值 |
| :--: | :-------------------: | :--: |
|  0   |         样例          |  0   |
|  1   |      $n,q\le 50$      |  15  |
|  2   | $n,q\le 3\times 10^3$ |  20  |
|  3   |  对于所有询问，$r=n$  |  15  |
|  4   |  对于所有询问，$l=1$  |  15  |
|  5   |           -           |  35  |


## 样例 #1

### 输入

```
4 3
3 -4 -1 2
1 2
3 4
1 4
```

### 输出

```
1
2
3
```

## 样例 #2

### 输入

```
7 6
-1 2 -1 -1 -1 2 -1
2 5
4 7
1 7
5 5
1 3
2 4
```

### 输出

```
1
2
4
0
2
1
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效求解给定区间内满足特定条件（幽默）的子序列个数。多数题解先分析出幽默子序列的特征为前面全是负数，只有最后一个数是正数，且总和大于0 。
不同题解在算法优化上各有特点，有的利用二分查找优化查找左端点过程，有的通过离线处理和排序减少重复计算，有的使用树状数组、线段树等数据结构优化区间查询。

### 所选的题解
- **作者：HFanGDoDM（5星）**
    - **关键亮点**：思路清晰，对每个子任务分别分析并给出解法，从暴力枚举逐步优化到高效算法，详细证明了各解法的正确性，代码注释详细。
    - **个人心得**：无
    - **核心代码（子任务5）**：
```cpp
int now=0;
for(i=1;i<=n;i++){
    lef[i]=now;
    if(a[i]>0)
        now=i;
}
now=n+1;
for(i=n;i>=1;i--){
    rig[i]=now;
    if(a[i]>0)
        now=i;
}
// 预处理num数组及前缀和
int l=R(),r=R(),pos=rig[l - 1];
if(pos>r){
    puts("0");
    continue;
}
printf("%d\n",sumn[r]-sumn[l - 1]-num[pos]+min(num[pos],pos - l+1));
```
    - **核心实现思想**：预处理每个位置左右两边第一个正数的位置，同时预处理以每个位置为右端点的幽默子序列个数及其前缀和。查询时，根据左右端点找到对应位置计算答案。
- **作者：Accelessar（4星）**
    - **关键亮点**：通过分析得出多个重要结论，如合法区间有且仅有最后一个数是正数等。利用结论先预处理出所有合法区间，再使用树状数组优化区间查询，整体思路巧妙。
    - **个人心得**：意识到看似相同的结论对思维水平较低的选手需要仔细思考。
    - **核心代码（100pts部分）**：
```cpp
fr(i,1,n)s[i]=s[i - 1]+rd(a[i]),a[i]>0&&b.eb(i);
vector<pii>t;
fr(i,1,n){
    auto it=lower_bound(all(b),i);
    if(it!=end(b)&&s[*it]-s[i - 1]>0)t.eb(i,*it);
}
reverse(all(t));
vector<array<int,4>>query;
fr(i,1,q)rd(l,r),query.push_back({l,r,i,0});
sort(all(query),greater());
for(int pos=0;auto&[l,r,i,ans]:query){
    while(pos<(int)t.size()&&t[pos].first>=l)add(t[pos].second,1),pos++;
    ans=ask(l,r);
}
sort(all(query),[](auto x,auto y){return x[2]<y[2];});
for(auto[l,r,i,ans]:query)cout<<ans<<'\n';
```
    - **核心实现思想**：先记录所有正数位置，对每个位置二分查找后面第一个正数并检查区间和是否大于零，得到所有合法区间。离线处理询问并排序，利用树状数组统计合法区间个数。
- **作者：251Sec（4星）**
    - **关键亮点**：将问题转化为经典的二维平面上点与矩形的查询问题，通过扫描线算法解决，思路新颖，代码简洁明了。
    - **个人心得**：无
    - **核心代码（主函数部分）**：
```cpp
for (int i = 1; i <= n; i++) {
    if (a[i] > 0) {
        for (int j = i; j && (a[j] <= 0 || j == i) && s[i] - s[j - 1] > 0; j--) {
            mdf[j].emplace_back(i);
        }
    }
}
for (int i = 1; i <= q; i++) {
    int l, r; scanf("%d%d", &l, &r);
    qry[l - 1].push_back({ l, r, -i });
    qry[r].push_back({ l, r, i });
}
for (int i = 1; i <= n; i++) {
    for (auto j : mdf[i]) Modify(j, 1);
    for (auto j : qry[i]) ans[abs(j.id)] += Query(j.l, j.r) * (j.id > 0? 1 : -1);
}
for (int i = 1; i <= q; i++) printf("%lld\n", ans[i]);
```
    - **核心实现思想**：先找出所有幽默子段，将其转化为二维平面上的点。对于询问区间转化为矩形，通过扫描线算法，利用树状数组统计矩形内点的个数。

### 最优关键思路或技巧
1. **性质分析**：挖掘出幽默子序列“前面全是负数，只有最后一个数是正数且总和大于0”的性质，为后续优化提供基础。
2. **二分查找**：在固定右端点找合法左端点时，利用前缀和的单调性进行二分查找，降低时间复杂度。
3. **离线处理与排序**：将询问离线并按左端点或右端点排序，结合扫描线思想，减少重复计算，提高效率。
4. **数据结构优化**：使用树状数组、线段树等数据结构，高效处理区间查询和修改操作。

### 可拓展思路
此类题目属于区间统计问题，常见套路是先分析区间性质，再通过优化查找、利用数据结构等方式提升效率。类似题目常涉及前缀和、二分查找、排序、扫描线等知识点组合。

### 相似知识点洛谷题目
1. **P3372 【模板】线段树 1**：基础的线段树区间修改、查询问题，锻炼对线段树的理解与应用。
2. **P2617 Dynamic Rankings**：结合了树状数组和主席树，用于动态查询区间第K小，考察数据结构的综合运用。
3. **P1972 [SDOI2009]HH的项链**：可通过离线处理和前缀和优化，与本题离线处理思路类似。 

---
处理用时：85.69秒
# 题目信息

# Bina.

## 题目描述

小 J 家门前有两棵树，一棵是二叉树，一棵是三叉树。

你被小 J 叫来修剪他的二叉树，使得他的二叉树的“美丽值”最大，所谓一棵树的美丽值 $=$ 这棵树的点的编号之和 $\div$ 这棵树的深度（结果向下取整）。

这棵二叉树有一个构建参数 $n$，构建方式如下：

```cpp
void build(int s,int t,int p){
  if(s==t) return ;
  build(s,(s+t)/2,2*p);
  build((s+t)/2+1,t,2*p+1);
  add_edge(p,2*p),add_edge(p,2*p+1);
}

int main(){
  build(1,n,1);
  return 0;
}
```

其中 `build(s,t,p)` 函数参数中的 $p$ 是当前点的编号，`add_edge(x,y)` 函数是指将编号为 $x$ 的点向编号为 $y$ 的点连接一条有向边。

容易发现这棵树的根节点是 $1$，并且我们规定节点的深度为节点到根节点路径上经过的点的个数（包括自己和根节点），这棵树的深度即为所有节点深度的最大值。

对于 $n=3$ 的情况，最后构建出来的结果如下，这棵树的深度为 $3$，你需要选择一个深度 $k$ 把深度大于 $k$ 的点都剪掉，但是 $k$ 必须**大于等于** $1$ 且**小于等于**这棵树的深度。

![](https://cdn.luogu.com.cn/upload/image_hosting/ueggbyn8.png)

小 J 还给了你一个要求，你剪去的节点个数一定得大于等于 $m$ 他才会高兴，你需要保证让他高兴的同时树的“美丽值”最大。

现在小 J 给了你构建树的参数 $n$ 和至少剪的节点个数 $m$，要你求出来他的树在你修剪后最大的美丽值是多少，如果无论如何你也不可能让小 J 高兴，输出 $-1$。

## 说明/提示

#### 【样例解释 #1】

对于第一组样例，$n$ 都等于 $3$，构建出来的树同题面所示。

如果我们选择把深度大于 $1$ 的节点全部剪掉，那么我们剪掉了 $2,3,4,5$ 共 $4$ 个节点，美丽值为 $1$。

如果我们选择把深度大于 $2$ 的节点全部剪掉，那么我们剪掉了 $4,5$ 共 $2$ 个节点，美丽值为 $\lfloor \dfrac{1+2+3}{2}\rfloor = 3$。

如果我们选择把深度大于 $3$ 的节点全部剪掉，那么我们没有剪掉任何节点，美丽值为 $\lfloor \dfrac{1+2+3+4+5}{3}\rfloor = 5$。

所以对于 $m=0$ 的情况，答案为 $5$；对于 $1 \le m \le 2$ 的情况，答案为 $3$；对于 $3 \le m \le 4$ 的情况，答案为 $1$；其它情况，无解输出 $-1$。

#### 【数据范围】

对于所有测试数据，满足 $1 \le T \le 10^5$，$1 \le n \le 10^9$，$0 \le m \le 2 \times 10^9$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n \le$ | $m \le$ | $T \le$ | 特殊限制 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1 \sim 2$ | $10^3$ | $10^5$ | $10^3$ | 无 |
| $3 \sim 4$ | $10^6$ | $2 \times 10^6$ | $10^5$ | 无 |
| $5$ | $10^9$ | $1$ | $10^5$ | 无 |
| $6$ | $10^9$ | $2$ | $10^5$ | 无 |
| $7 \sim 8$ | $10^9$ | $3$ | $10^5$ | 无 |
| $9 \sim 10$ | $10^9$ | $2 \times 10^9$ | $10^5$ | $m \ge 1$ |
| $11 \sim 12$ | $10^9$ | $10^3$ | $10^5$ | 无 |
| $13 \sim 16$ | $10^9$ | $2 \times 10^9$ | $10$ | 无 |
| $17 \sim 20$ | $10^9$ | $2 \times 10^9$ | $10^5$ | 所有 $n$ 均相同 |
| $21 \sim 25$ | $10^9$ | $2 \times 10^9$ | $10^5$ | 无 |

## 样例 #1

### 输入

```
6
3 0
3 1
3 2
3 3
3 4
3 5```

### 输出

```
5
3
3
1
1
-1```

## 样例 #2

### 输入

```
10
5 5
10 0
999 155
135 92
1000232 234255
10293845 1239485
123948 1239454
12394 2131094
1000000000 98765432
1000000000 999999999```

### 输出

```
3
40
52377
1161
27487764480
5864061665280
-1
-1
19215358392218419
4969489234738635```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效计算修剪二叉树后的最大美丽值展开。核心思路多基于对给定建树方式（类似线段树构建）所生成二叉树性质的挖掘，通过分析树的结构、节点编号规律等，采用不同方法计算节点数量、编号和以及满足修剪节点数限制下的最优解。

各题解的算法要点和难点解决方式如下：
1. **离散小波变换°**：
    - **思路**：利用线段树区间长度本质不同的节点个数为\(O(\log n)\)的结论，通过归纳法证明每一层区间长度最多两种，且子树节点编号和是关于根节点编号的一次函数，先暴力计算\(O(\log^2 n)\)，后通过猜测最优深度在特定范围优化到\(O(T\log n)\)。
    - **算法要点**：对不同区间长度和生长层数计算子树节点编号和的系数，用哈希表存储结果。
    - **解决难点**：通过数学归纳证明性质，减少计算量；优化后避免多余的\(\log\)复杂度。
2. **qczrz6v4nhp6u**：
    - **思路**：观察到建树形成的二叉树除最后一层是满二叉树，枚举删掉层数\(k\)，分别讨论\(k>0\)和\(k = 0\)时计算结点编号和的方法，通过分析叶结点规律计算最后一层结点编号和。
    - **算法要点**：利用树的满二叉树特性，按位考虑计算二进制翻转和。
    - **解决难点**：证明并利用叶结点编号的二进制翻转规律计算编号和。
3. **zct_sky**：
    - **思路**：根据\(n\)与\(2\)的幂次关系，分\(m = 0\)和\(m \neq 0\)讨论。\(m \neq 0\)时尽量保留深的满二叉树；\(m = 0\)时，对最后一层节点和用分治计算，结合满二叉树部分计算美丽值。
    - **算法要点**：根据\(n\)确定满二叉树部分和最后一层节点情况，分治计算最后一层节点和。
    - **解决难点**：通过分治找到最后一层节点和的计算规律。
4. **libohan0905**：
    - **思路**：发现树由满二叉树和一些叶子结点构成，\(m>0\)时计算满二叉树美丽值并预处理，\(m = 0\)时，用分治计算最后一层点权和，结合满二叉树部分取最大美丽值，加记忆化优化。
    - **算法要点**：预处理满二叉树美丽值，分治结合记忆化计算最后一层点权和。
    - **解决难点**：通过分治和记忆化处理最后一层点权和的计算。
5. **Pengzt**：
    - **思路**：枚举树的高度，通过记忆化得到子树大小，对编号和按层考虑转移，用哈希表存储结果。
    - **算法要点**：记忆化搜索子树大小和编号和，按层分析编号和的变化。
    - **解决难点**：分析编号和在不同子树间转移的规律。
6. **recollect_i**：
    - **思路**：考虑求长度、保留\(k\)层的节点数量和编号和，通过记忆化搜索加`unordered_map`实现，后优化为用堆和DP，还提到修剪后多为满二叉树可直接计算。
    - **算法要点**：定义状态表示节点数量、每层最小编号之和等，通过记忆化或DP计算。
    - **解决难点**：优化常数较大的记忆化搜索，利用树的满二叉树特性简化计算。
7. **Thomas0218**：
    - **思路**：利用线段树除最后一层外结构规整的特点，用记忆化搜索计算最后一层叶子结点编号和等信息，结合满二叉树部分计算答案。
    - **算法要点**：记录深度、长度对应的最后一层叶子结点编号和等信息，递归合并。
    - **解决难点**：通过记忆化搜索减少重复计算，合理合并信息。
8. **irris**：
    - **思路**：强化问题求线段树每一层大小和节点标号和，通过引理分析最后一层叶子结点标号和的规律，递归计算，枚举断到哪一层得答案。
    - **算法要点**：得出最后一层叶子结点标号和的递归式，结合前层信息计算。
    - **解决难点**：找到最后一层叶子结点标号和的递归构造规律。
9. **Alphas**：
    - **思路**：先证明树的节点个数公式，分情况计算答案。小于树深度时按满二叉树计算；\(m = 0\)时，通过打表分析差分数组规律，用分治计算整棵树节点权值和。
    - **算法要点**：证明节点个数公式，分治计算差分数组前缀和。
    - **解决难点**：通过打表和分治找到整棵树节点权值和的计算方法。
10. **lfxxx**：
    - **思路**：枚举保留层数，以区间长度为状态转移计算节点数量和编号和，用哈希表或平衡树记录，记忆化实现。
    - **算法要点**：以区间长度为状态，维护节点数量和编号和关于根节点编号的一次函数。
    - **解决难点**：找到编号和关于根节点编号的函数关系并转移。
11. **uid_310801**：
    - **思路**：利用线段树每一层最多两种不同长度节点的特点，设置递归函数统计每一层节点个数和编号和，枚举保留层数求答案。
    - **算法要点**：递归统计每层信息，根据\(n\)的奇偶性确定转移系数。
    - **解决难点**：通过递归和合理的转移统计每层节点信息。

综合来看，多数题解思路围绕树的结构特点和节点编号规律展开，在计算节点和与优化复杂度上各有特色。

### 所选的题解
1. **离散小波变换° - 5星**
    - **关键亮点**：深入挖掘线段树性质，通过数学归纳法证明重要结论，先暴力后优化的思路清晰，复杂度分析准确，代码实现完整且有优化过程展示。
    - **个人心得**：提到出题人卡常数的情况，暗示优化常数的重要性。
    - **核心代码片段 - 优化后计算部分**：
```cpp
for(int _ = 1;_ <= T;++ _){
    int n, m, h = 32;
    for(int i = 1;i <= h;++ i)
        M[i].clear();
    cin >> n >> m;
    i64 ans = -1, tot = 2 * n - 1 - m;
    i64 sum1 = 1, val1 = n;
    i64 sum2 = 0, val2 = n - 1;
    int t = 0;
    if(tot < 1){
        cout << -1 << endl;
        continue;
    } else 
        -- tot;
    for(int k = 2;k <= h;++ k){
        i64 tval1 = (val1 + 1) / 2;
        i64 tval2 = (val1 + 1) / 2 - 1;
        i64 tsum1 = 0, tsum2 = 0;
        for(auto [sum, val] : {
            make_tuple(sum1, val1),
            make_tuple(sum2, val2)
            }){
            if(val == 1)
                continue;
            if((val + 1) / 2 == tval1)
                tsum1 += sum;
            else 
                tsum2 += sum;
            if(val - (val + 1) / 2 == tval1)
                tsum1 += sum;
            else
                tsum2 += sum;
        }
        sum1 = tsum1, val1 = tval1;
        sum2 = tsum2, val2 = tval2;
        tot -= sum1 + sum2;
        if(tot < 0){
            t = k - 1; break;
        } else 
        if(tot == 0){
            t = k; break;
        }
    }
    for(auto &t0 : {t, t - 1}){
        if(t0 == 0)
            continue;
        solve(n, t0);
        auto [c, x, y] = n <= o? H[n][min(g, t0)] : M[t0][n];
        ans = max(ans, (x + y) / t0);
    }
    
    cout << ans << endl;
}
```
核心实现思想：先初始化相关变量，通过循环尝试不同的树深度\(k\)，根据节点数量变化更新\(sum1\)、\(val1\)等变量，判断是否满足修剪节点数要求确定最优深度\(t\)，最后在\(t\)和\(t - 1\)深度下计算并更新最大美丽值。
2. **qczrz6v4nhp6u - 5星**
    - **关键亮点**：巧妙观察到叶结点编号的二进制翻转规律，以此为核心计算最后一层节点编号和，思路新颖独特，代码简洁明了，复杂度分析准确。
    - **个人心得**：提到考场上代码没调出来，强调调试对解题的重要性。
    - **核心代码片段 - 计算部分**：
```cpp
int n,m;ll sum[40],cnt[40];
int main(){
    int T;read(T);
    while(T--){
        read(n,m);
        int dep=__lg(n);
        for(int i=0;i<=dep;i++){
            cnt[i]=1<<i;
            sum[i]=(((3ll<<i)-1)<<i)>>1;
        }
        if((1<<dep)<n){
            cnt[dep+1]=(n-(1<<dep))<<1;
            ll k=n-(1<<dep)-1,res=0;
            for(int i=dep-1;i>=0;i--){
                ll tmp=(k&~((2ll<<i)-1))+(2ll<<i);
                res+=((tmp>>1)-min(tmp-k-1,1ll<<i))<<(dep-i-1);
            }
            sum[dep+1]=(k+1)*((1ll<<(dep+2))+1)+(res<<2);
            dep++;
        }
        ll ans=-1;
        for(int i=0;i<=dep;i++){
            if(i>0){
                sum[i]+=sum[i-1];
                cnt[i]+=cnt[i-1];
            }
            if(cnt[i]<=2*n-1-m)ckmax(ans,sum[i]/(i+1));
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```
核心实现思想：先计算树的深度\(dep\)，初始化每层的节点数\(cnt\)和编号和\(sum\)。若树非满二叉树，计算最后一层节点相关信息，更新\(cnt\)和\(sum\)。最后枚举保留层数\(i\)，在满足修剪节点数条件下更新最大美丽值。
3. **Alphas - 5星**
    - **关键亮点**：先证明树节点个数公式，通过打表分析数据规律，采用分治算法计算节点权值和，思路清晰，代码简洁高效，对分治的应用巧妙。
    - **核心代码片段 - 分治计算部分**：
```cpp
int lsum(int l, int r, int x) { // 求一段区间内某个数倍数的和
    int st = ((l - 1) / x + 1) * x;
    int ed = (r / x) * x;
    return (st + ed) * ((ed - st) / x + 1) / 2;
}
int calc(int l, int r, int x, int v, int ed) { // 分治计算差分数组前缀和
    if (l == r) return ed;
    int mid = l + r >> 1;
    if (mid - l + 1 >= x) return calc(l, mid, x, v * 2, ed); // 完全落在前一段中
    else return lsum(ed, ed * 2 - 1, v * 2) + calc(l, mid, x - (mid - l + 1), v * 2, ed) + (x - (mid - l + 1)) * v; // 部分落在后一段中
}
int sum(int x) {
    if (x == 1) return 0;
    int y = (1 << ((int)log2(x - 1))); 
    return y * (2 * y + 1) + x - y + 4 * calc(1, y, x - y, 1, y) - 2 * y; // 计算结果，注意加上前面满二叉树的贡献，比如在举得例子中就是 n = 32 的贡献
}
```
核心实现思想：`lsum`函数计算区间内某个数倍数的和，`calc`函数通过分治计算差分数组前缀和，根据区间位置不同进行递归计算，`sum`函数结合满二叉树贡献和分治结果计算整棵树节点权值和。

### 最优关键思路或技巧
1. **挖掘树的结构性质**：如发现树类似线段树结构，除最后一层为满二叉树，利用每层区间长度特点、节点编号规律等，减少计算量。
2. **数学归纳与证明**：像离散小波变换°通过归纳证明子树节点编号和是关于根节点编号的一次函数，为算法提供理论基础。
3. **分治与记忆化**：qczrz6v4nhp6u利用二进制翻转规律分治计算最后一层节点和；libohan0905分治结合记忆化处理最后一层点权和；Alphas分治计算差分数组前缀和，有效优化计算过程。

### 拓展思路
此类题目可拓展到其他基于特定规则构建的树结构问题，类似算法套路包括深入分析树的结构特点、节点编号或权值规律，利用数学方法证明性质，通过分治、记忆化等优化计算。例如，对于不同建树规则的二叉树或多叉树，求解与节点相关的最值、和等问题。

### 相似知识点洛谷题目
1. **P3372 【模板】线段树 1**：基础线段树题目，帮助理解线段树结构和基本操作。
2. **P1823 [COI2007] Patrik 音乐会的等待**：涉及线段树的应用，通过线段树解决实际问题，锻炼对线段树的灵活运用。
3. **P2024 [NOI2001] 食物链**：利用并查集和类似树结构的思想解决逻辑推理问题，与本题分析树结构性质有相似思维方式。

### 个人心得摘录与总结
1. **离散小波变换°**：提到出题人卡常数，强调优化常数在算法实现中的重要性，即使思路正确，常数过大也可能导致代码不通过。
2. **qczrz6v4nhp6u**：考场上代码没调出来，说明调试能力对解题至关重要，即使思路正确，代码实现和调试不当也无法得分。 

---
处理用时：173.50秒
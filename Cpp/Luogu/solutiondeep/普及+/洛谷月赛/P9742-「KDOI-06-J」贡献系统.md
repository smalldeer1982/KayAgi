# 题目信息

# 「KDOI-06-J」贡献系统

## 题目描述

洛谷贡献系统上线了！

现在有 $n$ 个人即将参加一场洛谷月赛，每个人的等级分**互不相同**。第 $i$ 个人的等级分是 $r_i$，贡献值是 $c_i$。

假设第 $i$ 个人的等级分在这 $n$ 个人中的排名是 $a_i$（排名按等级分从大到小排序），且在月赛中的排名是 $b_i$，没有两个人的排名相同。也就是说，$a$ 和 $b$ 都是 $1$ 到 $n$ 的排列。比赛结束后，每个人都会执行以下操作：

+ 若 $a_i=b_i$，则第 $i$ 个人的等级分不会发生任何变化，因此第 $i$ 个人不会进行任何操作；
+ 若 $a_i>b_i$，则第 $i$ 个人的等级分会上升，因此第 $i$ 个人会给出题人点赞，导致出题人的贡献值上升 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值下降）；
+ 若 $a_i<b_i$，则第 $i$ 个人的等级分会下降，因此第 $i$ 个人会给出题人点踩，导致出题人的贡献值下降 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值上升）。

作为这场月赛唯一的出题人，初始时你的贡献值为 $0$。你想知道，对于所有可能的排列 $b$（显然，排列 $a$ 在比赛前已经被确定），在比赛结束后你的贡献值最大是多少。

## 说明/提示

**【样例解释 #1】**

对于第一组测试数据，设五个人按输入顺序分别为 A，B，C，D，E，则当月赛中的排名顺序为 ABECD 时贡献值最大，为 $0+0-(-50)-(-22)+208=280$。可以证明，这是唯一能使贡献值达到最大的排名顺序。

对于第二组测试数据，设八个人按输入顺序分别为 A，B，C，D，E，F，G，H，则当月赛中的排名顺序为 ABCDEGFH 时可以使贡献值达到最大值 $1$，注意此时有多种可能的使贡献值最大的排名顺序。

**【样例 #2】**

见选手目录下的 `contrib/contrib2.in` 与 `contrib/contrib2.ans`。

**【样例 #3】**

见选手目录下的 `contrib/contrib3.in` 与 `contrib/contrib3.ans`。



***

**【数据范围】**

对于所有数据保证：$1\le T\le 5$，$1\le n\le 2\times 10^5$，$0\le r_i\le 10^9$，$-10^9\le c_i\le 10^9$，且对于任意 $1\le i<n$，$r_i>r_{i+1}$。

| 测试点编号  |    $n\le $     | 特殊限制 |
| :---------: | :------------: | :------: |
|  $1\sim3$   |      $8$       |    无    |
|     $4$     |     $100$      |   ABC    |
|     $5$     |     $100$      |    C     |
|  $6\sim 7$  |     $100$      |    无    |
|  $8\sim 9$  | $5\times 10^3$ |    AB    |
| $10\sim 11$ | $5\times 10^3$ |    C     |
| $12\sim 14$ | $5\times 10^3$ |    无    |
|    $15$     | $2\times10^5$  |    AB    |
| $16\sim 18$ | $2\times10^5$  |    B     |
| $19\sim 21$ | $2\times10^5$  |    C     |
| $22\sim 25$ | $2\times 10^5$ |    无    |

+ 特殊性质 A：对于任意 $1\le i<n$，保证 $c_i=c_{i+1}$；
+ 特殊性质 B：对于任意 $1\le i<n$，保证 $c_i\le c_{i+1}$；
+ 特殊性质 C：对于任意 $1\le i\le n$，保证 $c_i\ge 0$。

## 样例 #1

### 输入

```
3
5
3816 3738 3726 3621 3582
111 109 -50 -22 208
8
8 7 6 5 4 3 2 1
128 1 0 0 0 0 1 0
10
10 9 8 7 6 5 4 3 2 1
1 1 4 5 1 4 1 9 1 9
```

### 输出

```
280
1
34
```

# AI分析结果

• 综合分析与结论：
    - 思路：多数题解将原数列按贡献值正负分成三段，第一段为开头连续正数，第二段为中间正负混杂部分，第三段为结尾连续负数。对于第二段，将正数放前负数放后可使贡献为该段绝对值之和；对于第一段和第三段，通过枚举一个元素调整位置，使其他元素产生正贡献，以获取最大贡献。少数题解采用暴力枚举全排列或利用前缀和优化的暴力枚举方式。
    - 算法要点：利用贪心策略，依据贡献值正负调整人员排名顺序；通过前缀和优化计算过程，减少时间复杂度。
    - 解决难点：如何在满足不同人员排名调整需求（有人想进步，有人想退步）的情况下，构造出最优排名顺序。多数题解通过将序列分段处理，分别考虑各段最优情况，从而解决该难点。
    - 整体来看，大部分题解思路相近，主要区别在于代码实现的细节与优化程度。

    - 评分：
        - zjpwdyf：5星。思路清晰，先分析特殊情况得出结论，再推广到一般情况，代码使用前缀和优化，简洁明了。
        - 引领天下：4星。贪心思路阐述清晰，通过对首尾两段特殊情况的处理和中间段贪心策略，逻辑连贯，代码实现较简洁。
        - lzy20091001：4星。先分析特殊性质，再推导正解，思路具有引导性，形式化证明过程严谨，代码注释详细。

  - zjpwdyf题解
    - 星级：5星
    - 关键亮点：先分别讨论\(c_i\)全为正和全为负的特殊情况得出最优方案，再将原数列分成三段，对每段分别采用不同策略求解，思路清晰，代码利用前缀和优化计算。
    - 重点代码及核心思想：
```cpp
#include<bits/stdc++.h>
#define gsum(l,r) (sum[r]-sum[l-1])
using namespace std;
typedef long long ll;
const int N=2e5+5;
ll T,n,c[N],tmp,lft,rgt,sum[N],ans1,ans2;
int main(){
    cin>>T;
    while(T--){
        ans1=ans2=0;
        cin>>n;
        for(int i=1;i<=n;i++) scanf("%lld",&tmp);
        for(int i=1;i<=n;i++){
            scanf("%lld",c+i);
            sum[i]=sum[i-1]+abs(c[i]);
        }
        for(lft=1;c[lft]>0&&lft<=n;lft++);
        for(rgt=n;c[rgt]<0&&rgt>=1;rgt--);
        for(int i=1;i<lft;i++) ans1=max(ans1,-c[i]+gsum(i+1,lft-1));
        for(int i=n;i>rgt;i--) ans2=max(ans2,c[i]+gsum(rgt+1,i-1));
        cout<<ans1+ans2+gsum(lft,rgt)<<'\n';
    }
    return 0;
}
```
核心思想：先读入数据并计算\(c\)数组的前缀和。通过循环找到第一段正数的结束位置\(lft\)和第三段负数的起始位置\(rgt\)。对于第一段，枚举每个数放到最后产生负贡献，计算其后面数的前缀和作为正贡献，取最大值；第三段类似，最后将三段的贡献值相加得到结果。

  - 引领天下题解
    - 星级：4星
    - 关键亮点：贪心思路直接，通过考虑让正贡献的人上分，负贡献的人下分，对首尾两段特殊处理，中间段按贪心策略计算贡献，代码简洁易懂。
    - 重点代码及核心思想：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,t,x,a[200005];
signed main(){
    ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=1;i<=n;i++)cin>>x;
        for(int i=1;i<=n;i++)cin>>a[i];
        int l=1,r=n;
        while(l<=n&&a[l]>0)l++;
        while(r>=1&&a[r]<=0)r--;
        int sum=0,mx=0,ans=0;
        for(int i=1;i<l;i++)sum+=a[i];
        for(int i=1;i<l;i++)sum-=a[i],mx=max(mx,sum-a[i]);
        ans+=mx;
        sum=0,mx=0;
        for(int i=n;i>r;i--)sum-=a[i];
        for(int i=n;i>r;i--)sum+=a[i],mx=max(mx,sum+a[i]);
        ans+=mx;
        for(int i=l;i<=r;i++)ans+=abs(a[i]);
        cout<<ans<<"\n";
    }
    return 0;
}
```
核心思想：先读入数据，找到第一段正数的结束位置\(l\)和第三段负数的起始位置\(r\)。对于第一段正数，先计算前缀和，再枚举每个数放到最后，计算其贡献并取最大值；第三段负数类似。最后将中间段数的绝对值之和与首尾两段的最大贡献值相加得到答案。

  - lzy20091001题解
    - 星级：4星
    - 关键亮点：从特殊性质入手，逐步推导正解，对正解中构造\(b\)的方式进行形式化证明，逻辑严谨，代码注释详细。
    - 重点代码及核心思想：
```cpp
#include <cmath>
#include <iostream>

int c[200005];
long long s[200005]; // 前缀和

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int t;
    std::cin >> t;
    while (t--)
    {
        int n, x, y;
        long long ans1 = 0, ans2 = 0, ans3 = 0;

        s[1] = 0; // 前缀和注意初始化

        std::cin >> n;
        for (int i = 1; i <= n; i++)
        {
            int r;
            std::cin >> r;
        }
        for (int i = 1; i <= n; i++)
        {
            std::cin >> c[i];
            s[i] = s[i - 1] + c[i];
        }

        x = n + 1, y = 0;            // 初始化，防止找不到
        for (int i = 1; i <= n; i++) // 寻找 x
            if (c[i] <= 0)
            {
                x = i;
                break;
            }
        for (int i = n; i >= 1; i--) // 寻找 y
            if (c[i] >= 0)
            {
                y = i;
                break;
            }

        // 计算答案
        for (int i = 1; i < x - 1; i++)
            ans1 = std::max(ans1, s[x - 1] - s[i] - c[i]);
        for (int i = n; i > y + 1; i--)
            ans3 = std::max(ans3, 0 - (s[i - 1] - s[y]) + c[i]);
        for (int i = x; i <= y; i++)
            ans2 += abs(c[i]);

        std::cout << ans1 + ans2 + ans3 << "\n";
    }

    return 0;
}
```
核心思想：先读入数据并计算\(c\)数组的前缀和\(s\)。找到第一段正数的结束位置\(x\)和第三段负数的起始位置\(y\)。对于第一段正数，枚举每个数放到最后，计算其贡献并取最大值；第三段负数类似。中间段将正数放前负数放后，贡献为该段绝对值之和，最后将三段贡献相加得到答案。

• 最优关键思路或技巧：
    - 贪心策略：根据贡献值正负，将人员排名进行调整，使正贡献尽量增加，负贡献尽量减少。
    - 序列分段：将原序列按贡献值正负分成三段，分别处理各段的最优情况，降低问题复杂度。
    - 前缀和优化：通过计算前缀和，快速计算一段数据的和，减少重复计算，优化时间复杂度。

• 可拓展思路：此类题目通常围绕如何通过合理安排元素顺序，实现目标值最优。类似套路可应用于其他具有顺序调整以优化结果的场景，例如任务调度问题，根据任务的收益和耗时等因素，合理安排执行顺序以获取最大收益。

• 相似知识点洛谷题目：
    - [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：通过合理安排顺序，使结果最优，考察贪心策略。
    - [P2859 [USACO06DEC]Milk Patterns G](https://www.luogu.com.cn/problem/P2859)：需要对数据进行处理和排序，运用类似通过调整顺序优化结果的思想。
    - [P1199 [NOIP2010 普及组] 三国游戏](https://www.luogu.com.cn/problem/P1199)：涉及策略选择和顺序安排，以达到最优结果，与本题思路有相似之处。

• 个人心得摘录：无。 

---
处理用时：104.63秒
# 题目信息

# 「KDOI-06-J」旅行

## 题目描述

小 C 在 C 国旅行。

C 国有 $n\times m$ 个城市，可以看做 $n\times m$ 的网格。定义 $(i,j)$ 表示在网格中第 $i$ 行第 $j$ 列的城市。

该国有 $2$ 种交通系统：

* 对于所有 $1\leq i<n,1\leq j\leq m$，$(i,j)$ 到 $(i+1,j)$ 有一段由 L 公司修的单向铁路；
* 对于所有 $1\leq i\leq n,1\leq j<m$，$(i,j)$ 到 $(i,j+1)$ 有一段由 Z 公司修的单向铁路；

在每一个城市有一个售票口，$(i,j)$ 城市的售票口可以用 $a_{i,j}$ 元购买一张 L 公司的铁路票，$b_{i,j}$ 元购买一张 Z 公司的铁路票。当你拥有一个公司的一张铁路票时，你可以乘坐这个公司的任意一段铁路，并消耗掉这张铁路票。注意，一张铁路票可以且仅可以使用一次。

小 C 原来在城市 $(1,1)$。他想要在 C 国旅游，但是他不想浪费任何的钱（即，当他旅游完毕时手上不应该有多余的车票）。对于所有 $1\leq x\leq n,1\leq y\leq m$，求他花 $k$ 元钱并在城市 $(x,y)$ 结束旅行的方案数，对 $998\ 244\ 353$ 取模。

两种旅行方案不同，当且仅当小 C 经过的城市不同，或他在某一个城市购买的某家公司的铁路票数量不同。

## 说明/提示

**【样例解释 #1】**

到 $(3,1)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,1)$。

到 $(2,2)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(2,2)$。

到 $(3,2)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $2$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,2)$；乘坐 L 公司的铁路到 $(3,2)$。
* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；乘坐 L 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。
* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；乘坐 Z 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。

到 $(2,3)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $2$ 张 Z 公司的铁路票。在此之后，有 $3$ 种方案可以从 $(1,1)$ 乘坐两公司的铁路到 $(2,3)$。
* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票。在此之后，有 $2$ 种方案可以从 $(1,2)$ 乘坐两公司的铁路到 $(2,3)$。

**【样例 #2】**

见选手目录下的 `travel/travel2.in` 与 `travel/travel2.ans`。这个样例满足测试点 $7\sim 8$ 的条件限制。

**【样例 #3】**

见选手目录下的 `travel/travel3.in` 与 `travel/travel3.ans`。这个样例满足测试点 $11$ 的条件限制。

**【数据范围】**

对于所有数据保证：$1\leq n,m\leq45$，$1\leq k,a_{i,j},b_{i,j}\leq90$。

| 测试点编号 | $n,m$ | $k$ | $a_{i,j}$ | $b_{i,j}$ |
|:--:|:--:|:--:|:--:|:--:|
| $1\sim3$ | $\leq3$ | $\leq5$ | $=1$ | $=1$ |
| $4\sim6$ | $\leq10$ | $\leq10$ | $=1$ | $=40$ |
| $7\sim8$ | $\leq40$ | $\leq30$ | $=1$ | $=45$ |
| $9\sim10$ | $\leq15$ | $\leq15$ | $\leq15$ | $\leq15$ |
| $11$ | $\leq15$ | $\leq30$ | $\leq30$ | $\leq30$ |
| $12$ | $\leq20$ | $\leq40$ | $\leq40$ | $\leq40$ |
| $13\sim15$ | $\leq25$ | $\leq50$ | $\leq50$ | $\leq50$ |
| $16$ | $\leq30$ | $\leq60$ | $\leq60$ | $\leq60$ |
| $17$ | $\leq35$ | $\leq70$ | $\leq70$ | $\leq70$ |
| $18\sim19$ | $\leq40$ | $\leq80$ | $\leq80$ | $\leq80$ |
| $20$ | $\leq45$ | $\leq90$ | $\leq90$ | $\leq90$ |

## 样例 #1

### 输入

```
3 3 5
3 2 1
2 1 3
1 3 2
1 2 3
2 3 1
3 1 2```

### 输出

```
0 0 0
0 1 5
1 3 5```

# AI分析结果

• **综合分析与结论**：
    - **思路**：所有题解均采用动态规划（DP）思路。定义状态表示走到某点时的花费、剩余票数等信息，通过状态转移方程计算方案数。
    - **算法要点**：状态转移主要分为从相邻点转移和在当前点买票转移。从相邻点转移，即从上方或左方相邻点走来；买票转移则是在当前点购买L或Z公司的票。同时要注意避免重复计算，如在当前点同时买两种票的情况。
    - **解决难点**：一是状态转移时的重复计算问题，通过容斥原理或强制购买顺序解决；二是空间复杂度问题，由于五维数组空间过大，大多题解采用滚动数组优化掉其中一维。
    - **整体评价**：各题解思路相近，主要差异在于代码实现细节、优化程度和表述清晰度。

• **所选的题解**：
  - **作者：uid_310801 (5星)**
    - **关键亮点**：思路清晰，先给出朴素转移方程，再通过类似二维前缀和的容斥优化转移，同时在代码中加入剪枝优化，减少不必要的转移计算。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
f[1][1][0][0][0]=1;
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(i!=1) f[i&1][j][0][0][0]=0;
        for(int c=1;c<=k;c++){
            for(int la=0;la+i<=n;la++){
                for(int lb=0;lb+j<=m;lb++){
                    ll res=mod;
                    if(la!=0&&c>=a[i][j]) res+=f[i&1][j][c-a[i][j]][la-1][lb];
                    if(lb!=0&&c>=b[i][j]) res+=f[i&1][j][c-b[i][j]][la][lb-1];
                    if(la!=0&&lb!=0&&c>=a[i][j]+b[i][j]) res-=f[i&1][j][c-a[i][j]-b[i][j]][la-1][lb-1];
                    if(i!=1) res+=f[(i-1)&1][j][c][la+1][lb];
                    if(j!=1) res+=f[i&1][j-1][c][la][lb+1];
                    f[i&1][j][c][la][lb]=res%mod;
                    if(c==k&&la==0&&lb==0) ans[i][j]=res%mod;
                }
            }
        }
    }
}
```
核心实现思想：利用滚动数组优化空间，通过容斥原理计算状态转移值，同时在循环中加入条件判断，避免购买不可能贡献的票，从而减少计算量。

  - **作者：_O_v_O_ (4星)**
    - **关键亮点**：清晰阐述状态转移方程的推导过程，从朴素的高复杂度转移方程优化到通过容斥原理简化，进而利用滚动数组优化空间，代码简洁，注释清晰。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
dp[1][1][0][0][0]=1;
for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
    if(i!=1) dp[i&1][j][0][0][0]=0;
    for(int c=1;c<=k;c++){
        for(int x=0;i+x<=n;x++) for(int y=0;j+y<=m;y++){
            int res=mod;
            if(x!=0&&c>=a[i][j]) res+=dp[i&1][j][c-a[i][j]][x-1][y];
            if(y!=0&&c>=b[i][j]) res+=dp[i&1][j][c-b[i][j]][x][y-1];
            if(x!=0&&y!=0&&c>=a[i][j]+b[i][j]) res-=dp[i&1][j][c-a[i][j]-b[i][j]][x-1][y-1];
            if(i!=1) res+=dp[(i-1)&1][j][c][x+1][y];
            if(j!=1) res+=dp[i&1][j-1][c][x][y+1];
            dp[i&1][j][c][x][y]=res%mod;
            if(c==k&&x==0&&y==0) ans[i][j]=res%mod;
        }
    }
}
```
核心实现思想：与uid_310801类似，通过容斥原理优化状态转移，利用滚动数组优化空间，在循环中判断条件减少不必要计算。

  - **作者：zyn_ (4星)**
    - **关键亮点**：题目分析部分清晰，详细列举不同转移情况，代码实现中通过滚动数组优化空间，并且代码结构清晰，注释合理。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
dp[1][1][0][0][k]=1;
for(int i=1,now=1,old=0;i<=n;++i,now^=1,old^=1){
    rep(j,1,m){
        rep(L,0,n-1)rep(Z,0,m-1)rep(p,0,k){
            if(i>1)dp[now][j][L][Z][p]+=dp[old][j][L+1][Z][p];
            if(j>1)dp[now][j][L][Z][p]+=dp[now][j-1][L][Z+1][p];
            if(L>0&&p+a[i][j]<=k)dp[now][j][L][Z][p]+=dp[now][j][L-1][Z][p+a[i][j]];
            if(Z>0&&p+b[i][j]<=k)dp[now][j][L][Z][p]+=dp[now][j][L][Z-1][p+b[i][j]];
            if(L>0&&Z>0&&p+a[i][j]+b[i][j]<=k)
                dp[now][j][L][Z][p]+=(mod-dp[now][j][L-1][Z-1][p+a[i][j]+b[i][j]]);
            dp[now][j][L][Z][p]%=mod;
        }
        printf("%lld ",dp[now][j][0][0][0]);
    }
    puts("");
    rep(j,1,m)rep(L,0,n)rep(Z,0,m)rep(p,0,k)dp[old][j][L][Z][p]=0;
}
```
核心实现思想：通过滚动数组优化空间，按照不同转移情况更新状态值，注意取模操作，避免重复计算。

• **最优关键思路或技巧**：
    - **状态定义**：用五维数组记录位置、花费、剩余票数等信息，全面描述状态，为准确转移奠定基础。
    - **容斥原理优化转移**：通过类似二维前缀和的容斥，避免重复计算，降低转移复杂度。
    - **滚动数组优化空间**：利用滚动数组滚掉一维，解决五维数组空间过大问题。
    - **剪枝优化**：在循环中加入条件判断，避免购买对结果无贡献的票，减少不必要计算。

• **可拓展之处**：
    - **同类型题**：此类题目通常基于网格图，结合资源（如钱、票等）的使用和状态转移，可拓展到更多资源类型、不同转移规则（如斜向移动）或更复杂的限制条件。
    - **类似算法套路**：对于高维DP问题，常需考虑空间优化（如滚动数组）和状态转移的优化（如避免重复计算），同时合理定义状态以准确描述问题。

• **推荐洛谷题目**：
    - [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)：网格图上的动态规划问题，涉及路径规划和状态转移。
    - [P1280尼克的任务](https://www.luogu.com.cn/problem/P1280)：时间序列上的动态规划，与本题类似需合理定义状态和转移方程。
    - [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)：状态压缩动态规划，通过状态压缩优化空间，与本题优化思想有相通之处。

• **个人心得摘录与总结**：无。 

---
处理用时：98.25秒
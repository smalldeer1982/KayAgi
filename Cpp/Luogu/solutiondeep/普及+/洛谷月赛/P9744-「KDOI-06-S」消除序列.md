# 题目信息

# 「KDOI-06-S」消除序列

## 题目描述

小 M 有一个长度为 $n$ 的序列 $v_1,v_2,\ldots,v_n$，初始时，所有元素的值均为 $1$。

你有 $3$ 种作用在这个序列上的操作：

1. 选择一个下标 $i$（$1\le i\le n$），并且将 $v_1,v_2,\ldots,v_i$ 的值全部设为 $0$，这种操作的代价是 $a_i$；
2. 选择一个下标 $i$（$1\le i\le n$），并且将 $v_i$ 的值设为 $0$，这种操作的代价是 $b_i$；
3. 选择一个下标 $i$（$1\le i\le n$），并且将 $v_i$ 的值设为 $1$，这种操作的代价是 $c_i$。

现在有 $q$ 次询问，每次询问中给定一个集合 $P$，你希望进行若干次操作（可能为 $0$），使得：序列 $v$ 中下标位于该集合的元素的值为 $1$，其余位置的值为 $0$。**形式化地说，对于任意 $\bm{1\le i\le n}$，若 $\bm{i\in P}$，则 $\bm{v_i=1}$，否则 $\bm{v_i=0}$。** 并且，你需要最小化这次询问中所有操作的总代价。

注意，询问是相互独立的，也就是说，每次询问结束后，序列 $v$ 将会回到初始状态，即所有元素的值全都变为 $1$。

## 说明/提示

**【样例解释 #1】**

对于第一次询问，可以按顺序执行如下操作：

+ 在 $i=4$ 处执行操作 $1$，在这之后，序列 $v$ 变为 $[0,0,0,0,1]$，代价为 $0$；
+ 在 $i=4$ 处执行操作 $3$，在这之后，序列 $v$ 变为 $[0,0,0,1,1]$，代价为 $2$；
+ 在 $i=5$ 处执行操作 $2$，在这之后，序列 $v$ 变为 $[0,0,0,1,0]$，代价为 $5$。

所以总代价为 $0+2+5=7$，可以证明，不存在更小的总代价。

**【样例解释 #3】**

对于这个样例中的唯一一次询问，可以选择在 $i=10$ 处执行操作 $1$，总代价为 $a_{10}=7$。

**【样例 #4】**

见选手目录下的 `reserve/reserve4.in` 与 `reserve/reserve4.ans`。

**【样例 #5】**

见选手目录下的 `reserve/reserve5.in` 与 `reserve/reserve5.ans`。

这个样例满足测试点 $8\sim 11$ 的条件限制。

**【样例 #6】**

见选手目录下的 `reserve/reserve6.in` 与 `reserve/reserve6.ans`。

这个样例满足测试点 $14\sim 15$ 的条件限制。

**【样例 #7】**

见选手目录下的 `reserve/reserve7.in` 与 `reserve/reserve7.ans`。

这个样例满足测试点 $16$ 的条件限制。

**【样例 #8】**

见选手目录下的 `reserve/reserve8.in` 与 `reserve/reserve8.ans`。

这个样例满足测试点 $17\sim 20$ 的条件限制。

***

**【数据范围】**

记 $\sum m$ 为单测试点内所有询问 $m$ 的值之和。

对于所有数据保证：$1 \leq n \leq 5\times 10^5$，$0\le m \le n$，$0 \leq \sum m \leq 5 \times 10^5$，$1\le q\le \max(n,\sum m)$，$0 \le a_i, b_i, c_i \le 10^9$，$1\le p_i \le n$。

| 测试点编号 | $n \le$ | $m \le$ | $\sum m \le$| 是否有特殊性质 |
|:--:|:--:|:--:|:--:|:--:|
| $1 \sim 2$ | $5 \times 10^5$ | $0$ | $0$ | 否 |
| $3 \sim 4$ | $7$ | $7$ | $15$ | 否 |
| $5 \sim 6$ | $2 \times 10^3$ | $1$ | $2 \times 10^3$ | 否 |
| $7$ | $2 \times 10^3$ | $2 \times 10^3$ | $2 \times 10^3$ | 是 |
| $8 \sim 11$ | $2 \times 10^3$ | $2\times 10^3$ | $2 \times 10^3$ | 否 |
| $12 \sim 13$ | $5 \times 10^4$ | $5 \times 10^4$ | $5 \times 10^4$ | 否 |
| $14 \sim 15$ | $5 \times 10^5$ | $1$ | $5 \times 10^5$ | 否 |
| $16$ | $5 \times 10^5$ | $5 \times 10^5$ | $5 \times 10^5$ | 是 |
| $17 \sim 20$ | $5 \times 10^5$ | $5 \times 10^5$ | $5 \times 10^5$ | 否 |

特殊性质：对于任意 $1\le i\le n$，保证 $c_i = 0$。

**【提示】**

本题输入输出量较大，请使用适当的 I/O 方式。

## 样例 #1

### 输入

```
5
1 13 6 0 6
2 4 1 0 5
3 4 1 2 1
7
1 4
2 1 5
1 4
2 2 3
5 1 2 3 4 5
1 5
2 3 4```

### 输出

```
7
3
7
6
0
0
8```

## 样例 #2

### 输入

```
7
10 1 6 9 4 2 4 
0 5 2 3 0 1 4 
4 1 4 1 5 3 5 
6
3 1 3 6 
2 2 6 
4 3 4 5 7 
1 4 
2 3 7 
3 3 5 6```

### 输出

```
12
8
2
5
5
8```

## 样例 #3

### 输入

```
10
6 10 7 2 8 4 6 4 8 7
4 0 6 7 8 4 8 2 10 5
4 10 6 1 4 7 5 3 8 7
1
0```

### 输出

```
7```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何通过动态规划、贪心策略以及数据结构优化来解决给定序列操作的最小代价问题。思路上，多数题解先分析操作特性，如操作一最多使用一次，再基于此构建动态规划方程或贪心策略，部分题解还利用数据结构如ST表、线段树进行优化以降低时间复杂度。算法要点包括状态定义、转移方程推导、前缀和后缀和预处理以及数据结构的应用。解决难点在于如何设计高效的状态转移和利用数据结构优化计算。

### 所选的题解
1. **作者：HFanGDoDM (5星)**
    - **关键亮点**：思路清晰，对每个测试点分别分析并给出解法，逐步引导从简单到复杂的优化过程，详细证明各解法正确性，代码与思路紧密结合。
    - **个人心得**：无
    - **重点代码**：
```cpp
// 测试点1-2核心代码
for(i=n;i>=1;i--)
    sumb[i]=sumb[i+1]+1ll*b[i];//计算b数组的后缀和
long long ans=INF;
for(i=0;i<=n;i++)
    ans=min(ans,a[i]+sumb[i+1]);//计算每个总代价，更新答案
int q=R();
while(q--){
    int m=R();
    printf("%lld\n",ans);//对于每个询问，输出答案
}

// 测试点3-4核心代码
void DFS(int now,long long cost){
    if(now==n+1){//如果已经确定所有位置的操作
        for(int i=1;i<=n;i++)
            if(tmp[i]!=fnl[i])//判断当前序列是否符合题意，若不符合直接返回
                return;
        ans=min(ans,cost);//否则更新答案
        return;
    }
    long long delta=a[now];//cost增加量
    vector<int>tmp1(now+1);
    for(int i=1;i<=now;i++)
        tmp1[i]=tmp[i];//临时数组，记录赋值前序列
    for(int i=1;i<=now;i++)
        tmp[i]=0;
    for(int i=1;i<=m;i++){
        if(p[i]>now)
            break;
        delta+=c[p[i]];
        tmp[p[i]]=1;//第一种情况
    }
    DFS(now+1,cost+delta);//向下继续搜索
    for(int i=1;i<=now;i++)
        tmp[i]=tmp1[i];//回溯
    tmp[now]=0;
    delta=b[now];
    DFS(now+1,cost+delta);//第二种情况
    tmp[now]=tmp1[now];//回溯
    tmp[now]=1;
    delta=c[now];
    DFS(now+1,cost+delta);//第三种情况
    tmp[now]=tmp1[now];//回溯
    DFS(now+1,cost);//第四种情况
}
...
        fill(tmp+1,tmp+1+n,1);//初始v[i]=1
        fill(fnl+1,fnl+1+n,0);
        for(i=1;i<=m;i++)
            fnl[p[i]]=1;//设定最终序列
        ans=INF;
        DFS(1,0);
        printf("%lld\n",ans);//输出答案
```
    - **核心实现思想**：测试点1 - 2通过预处理b数组后缀和，枚举使用a[i]和b[i]代价的分界点计算最小总代价。测试点3 - 4使用深度优先搜索，枚举每个位置的四种操作情况，记录操作代价并回溯，判断最终序列是否符合要求来更新最小代价。
2. **作者：wxzzzz (4星)**
    - **关键亮点**：采用动态规划，定义清晰的状态$f_i$和$g_i$，转移方程推导自然，代码简洁明了，直接给出完整可运行代码。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, q, m, a[1000005], b[1000005], c[1000005], p[1000005];
long long s[1000005], g[1000005], f[1000005];
int main() {
    cin >> n;

    for (int i = 1; i <= n; i++)
        cin >> a[i];

    for (int i = 1; i <= n; i++)
        cin >> b[i], s[i] = s[i - 1] + b[i];

    for (int i = 1; i <= n; i++)
        cin >> c[i];

    for (int i = 1; i <= n; i++)
        a[i] = min(a[i], a[i - 1] + b[i]);

    cin >> q;

    while (q--) {
        cin >> m;

        for (int i = 1; i <= m; i++)
            cin >> p[i];

        for (int i = 1; i <= m; i++) {
            g[i] = g[i - 1] + c[p[i]];
            f[i] = a[p[i] - 1] + g[i - 1];
            f[i] = min(f[i], f[i - 1] + s[p[i] - 1] - s[p[i - 1]]);
        }

        cout << min(g[m] + a[n], f[m] + s[n] - s[p[m]]) << '\n';
    }

    return 0;
}
```
    - **核心实现思想**：先预处理更新$a_i$，通过前缀和维护$b_i$。动态规划中，$g_i$表示使$1\sim p_i$的元素从全为$0$改变到满足条件的最小代价，$f_i$表示从全为$1$改变到满足条件的最小代价，根据不同操作方式推导转移方程，最后根据$g_m$和$f_m$计算答案。
3. **作者：我怂了 (4星)**
    - **关键亮点**：同样基于动态规划，定义$d_i$和$dp_i$，思路明确，转移方程解释详细，代码简洁且有详细注释。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=5e5+5;
int a[maxn],b[maxn],c[maxn],d[maxn],p[maxn],pre[maxn],pre1[maxn],n,q,m,dp[maxn];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	for(int i=1;i<=n;i++){
		cin>>c[i];
	}
	for(int i=1;i<=n;i++){
		d[i]=min(d[i-1]+b[i],a[i]);
		pre1[i]=pre1[i-1]+b[i];
	}
	cin>>q;
	while(q--){
		cin>>m;
		for(int i=1;i<=m;i++){
			cin>>p[i];
			pre[i]=pre[i-1]+c[p[i]];
		}
		dp[1]=min({d[p[1]]+pre[1],d[p[1]-1]});
		for(int i=2;i<=m;i++){
			dp[i]=min({d[p[i]]+pre[i],d[p[i]-1]+pre[i-1],dp[i-1]+pre1[p[i]-1]-pre1[p[i-1]]});
		}
		cout<<min({d[n]+pre[m],dp[m]+pre1[n]-pre1[p[m]]})<<'\n';
	}
}
```
    - **核心实现思想**：预处理$d_i$表示将前$i$位改成$0$的最小代价，$pre1_i$为$b_i$的前缀和。对于每次询问，动态规划计算$dp_i$，考虑三种改变序列满足条件的方式推导转移方程，最后结合$d_n$和$dp_m$计算答案。

### 最优关键思路或技巧
1. **操作特性分析**：明确操作一最多使用一次且应优先使用，基于此设计算法可简化问题。
2. **动态规划**：合理定义状态，如$f_i$、$g_i$、$dp_i$等表示不同条件下的最小代价，通过分析操作方式推导状态转移方程。
3. **数据结构优化**：利用ST表、线段树等数据结构维护区间最值，如维护$a_i + \sum_{j=i+1}^n b_j$的最小值，将单次询问复杂度从$O(n)$降为$O(m)$或$O(\sqrt{n})$。
4. **前缀和与后缀和**：预处理$b$数组的前缀和与后缀和，快速计算特定区间的操作代价，减少重复计算。

### 可拓展思路
此类题目可拓展到更多操作类型、不同序列初始状态或更复杂的目标状态的场景。类似算法套路包括先分析操作性质简化问题，利用动态规划建立状态转移方程，再根据数据范围选择合适的数据结构优化。

### 相似知识点洛谷题目
1. **P3379 【模板】最近公共祖先（LCA）**：涉及树结构上的信息维护与查询，与本题利用数据结构优化查询操作有相似之处。
2. **P1880 [NOI1995] 石子合并**：通过动态规划求解最优合并方案，与本题动态规划求最小代价思路类似。
3. **P2880 [USACO07MAR]Face The Right Way G**：同样是对序列进行操作求最小代价，可类比本题分析操作特点和设计算法。 

---
处理用时：124.20秒
# 题目信息

# 种树

## 题目背景

小 Rf 不是很喜欢种花，但是他喜欢种树。

## 题目描述

路边有 $n$ 棵树，每棵树的 **高度** 均为正整数，记作 $p_1, p_2 \dots p_n$。

定义一棵树的 **宽度** 为它高度的正因数个数，这些树能覆盖的距离为它们宽度的乘积，你想请你的朋友们来乘凉，但你发现这些树能覆盖的距离不够多。

于是你买了总量为 $w$ 单位的神奇化肥。你可以施若干次肥，每次你可以使用 $k$ 单位化肥（**要求 $k$ 必须为当前化肥量的正因数**），让任意一棵树的高度乘上 $k$，同时你剩余的化肥量也会除以 $k$。每次施肥的树可任意选择，且每次施肥选择的树不需相同。

你需要最大化这些树所能覆盖的距离，并输出这个最大距离。答案对 $998244353$ 取模。

## 说明/提示

**【样例 1 解释】**

+ 第一次施肥，向第一棵树施 $15$ 单位的肥，使其高度变成 $120$，剩余 $4$ 单位的化肥。
+ 第二次施肥，向第二棵树施 $4$ 单位的肥，使其高度变成 $972$，剩余 $1$ 单位的化肥。
+ 这时候，三棵树的宽度分别为 $16, 18, 8$，所能覆盖的距离为 $2304$，为最优解。

---

**【样例 2】**

见附件下的 $\texttt{plant/plant2.in}$ 与 $\texttt{plant/plant2.ans}$。

---

**【样例 3】**

见附件下的 $\texttt{plant/plant3.in}$ 与 $\texttt{plant/plant3.ans}$。

---

**【数据范围】**

| 测试点编号 | $n \leq$ | $p_i$ | $w$ | 单点分值 |
| :--------: | :------: | :---: | :---: | :------: |
| $1 \sim 5$ | $10^4$ | $=1$ | $=1$ | $1$ |
| $6 \sim 10$ | $10^4$ | $\leq 10^4$ | $=1$ | $3$ |
| $11 \sim 15$ | $1$ | $\leq 10^4$ | $\leq 10^4$ | $3$ |
| $16 \sim 20$ | $5$ | $\leq 10^4$ | $\leq 10^4$ | $6$ |
| $21 \sim 25$ | $10^4$ | $\leq 10^4$ | $\leq 10^4$ | $7$ |

对于 $100 \%$ 的数据，保证 $1 \leq n \leq 10^4$，$1 \leq p_i \leq 10^4$，$1 \leq w \leq 10^4$。

## 样例 #1

### 输入

```
3 60
8 243 250```

### 输出

```
2304```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均基于数论中质因数分解的知识。题目要求最大化树高度因数个数的乘积，题解们普遍将树的高度和肥料 $w$ 进行质因数分解，利用“对于数 $x = \prod p_i^{a_i}$，其因数个数为 $\prod (a_i + 1)$”这一结论，通过贪心策略解决问题。即对于 $w$ 的每个质因数，将其分配给拥有该质因数指数最小的树，以使得因数个数的乘积最大。各题解在具体实现上有所差异，如数据结构的选择（优先队列、桶排序等），但整体思路一致。

### 所选的题解
- **作者：樱雪喵 (赞：45) - 5星**
    - **关键亮点**：思路清晰，先将原问题转化为经典的贪心问题，即对每个质因数单独考虑，每次贪心操作最小值。代码简洁明了，利用优先队列实现贪心过程，具有较好的可读性。
    - **重点代码**：
```cpp
il void solve(int x,int sum)
{
    for(int i=1;i<=n;i++)
    {
        cnt[i]=1;
        while(a[i]%x==0) cnt[i]++,a[i]/=x;
        q.push(cnt[i]);
    }
    while(sum) 
    {
        int x=q.top(); q.pop();
        q.push(x+1),sum--;
    }
    for(int i=1;i<=n;i++) ans=ans*q.top()%mod,q.pop();
}
```
    - **核心实现思想**：`solve` 函数针对每个质因数 $x$，统计每棵树中该质因数的指数并存入优先队列，然后通过优先队列不断取出最小值并加1，模拟施肥过程，最后计算该质因数对答案的贡献。
- **作者：佬头 (赞：17) - 4星**
    - **关键亮点**：对问题的数学分析详细，清晰阐述了贪心策略的原理，即把 $w$ 的质因数乘给质因数分解后该质因数指数最小的 $p$ 能使答案贡献最大。代码实现利用小根堆维护每个质因数在各数中的指数，时间复杂度分析明确。
    - **重点代码**：
```cpp
for(int i = 1, p, cnt; i <= n; ++ i){
    p = read();
    if(p & 1 ^ 1){ //p%2==0
        for(cnt = 0; p & 1 ^ 1; p >>= 1, ++ cnt);
        k[2].push(cnt);
    }
    for(int j = 3; j * j <= p; j += 2)
        if(p % j == 0){
            for(cnt = 0; p % j == 0; p /= j, ++ cnt);
            k[j].push(cnt);
        }
    if(p > 1) k[p].push(1);
}
while(w & 1 ^ 1){
    w >>= 1;
    if(k[2].size() < n) k[2].push(1);
    else k[2].push(k[2].top() + 1), k[2].pop();
}
```
    - **核心实现思想**：先对每棵树的高度进行质因数分解，将各质因数的指数存入对应的小根堆。然后对 $w$ 进行质因数分解，根据小根堆维护的指数信息，每次将 $w$ 的质因数分配给指数最小的树。
- **作者：EmptyAlien (赞：9) - 4星**
    - **关键亮点**：从数论基础出发，清晰推导解题思路，将 $w$ 分解质因数后，逐个将质因数分配给能使贡献最大的树。代码结构清晰，通过函数封装实现质因数分解和计算因数个数等功能。
    - **重点代码**：
```cpp
for (int x = 2; x * x <= w; x++) {
    while (w % x == 0) {
        int mn = INF, mnx;
        for (int i = 1; i <= n; i++) {
            if (calc(p[i], x) < mn) {
                mn = calc(p[i], x);
                mnx = i;
            }
        }
        p[mnx] *= x;
        w /= x;
    }
}
if (w!= 1) {
    int mn = INF, mnx;
    for (int i = 1; i <= n; i++) {
        if (calc(p[i], w) < mn) {
            mn = calc(p[i], w);
            mnx = i;
        }
    }
    p[mnx] *= w;
    w /= w;
}
```
    - **核心实现思想**：通过两层循环对 $w$ 进行质因数分解，每次内层循环找到当前质因数在各树中指数最小的树，并将该质因数分配给它，更新树的高度和剩余肥料 $w$。

### 最优关键思路或技巧
1. **数论知识运用**：利用质因数分解计算因数个数，将原问题转化为对质因数的分配问题，简化问题求解。
2. **贪心策略**：通过数学分析得出将 $w$ 的质因数分配给拥有该质因数指数最小的树能使答案最大的贪心策略，有效解决问题。
3. **数据结构辅助**：使用优先队列（小根堆）维护每棵树中每个质因数的指数，方便快速找到最小值，优化算法实现。

### 可拓展思路
此类问题属于数论与贪心结合的题型，常见拓展方向为改变数的范围、操作方式或目标函数。例如，改变数的范围可能需要更高效的质因数分解算法；改变操作方式可能涉及多种施肥规则；改变目标函数可能从最大化因数个数乘积变为其他数论函数的最值问题。解题时需深入分析问题本质，灵活运用数论知识和贪心策略。

### 相似知识点洛谷题目
1. **P1072 [NOIP2009 普及组]  Hankson 的趣味题**：通过数论知识，利用最大公约数和最小公倍数的性质解决方程求解问题。
2. **P2568 GCD**：基于数论中最大公约数的概念，结合前缀和优化，统计满足条件的数对。
3. **P3327 [SDOI2015]约数个数和**：需要深入理解数论中因数个数的计算方法，并运用莫比乌斯反演等知识解决问题。 

---
处理用时：75.51秒
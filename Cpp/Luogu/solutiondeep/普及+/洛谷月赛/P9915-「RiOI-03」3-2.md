# 题目信息

# 「RiOI-03」3-2

## 题目背景

> Heart beat to death[.](https://www.luogu.com.cn/problem/P9304)

## 题目描述

给定一个正整数 $n$。将 $[0,2^n)$ 中每个整数的二进制最低 $n$ 位**从低到高**依次写在一个 $2^n\times n$ 的矩阵上。**矩阵两维的下标都从 $0$ 开始。** 如，当 $n=3$ 时，矩阵是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/5f6v9pru.png?x-oss-process=image/resize,m_lfit,h_200,w_265)

给定 $q$ 次询问，每次询问这个矩阵下标为 $(x,y)$ 的格子所在的四连通块大小对 $998244353$ 取模的值。


## 说明/提示

#### 【样例 #1 解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/4mglp4cn.png?x-oss-process=image/resize,m_lfit,h_200)

图为 $n=2$ 时的矩阵，其中同一个颜色的为一个四连通块。

***

#### 【数据范围】

**本题开启捆绑测试。**

| $\text{SubTask}$ | 分值 | $n\le$ | $q\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $0$ | $5$ | $15$ | $15$ |
| $1$ | $20$ | $15$ | $5\times 10^5$ |
| $2$ | $25$ | $5\times 10^3$ | $5\times 10^3$ |
| $3$ | $50$ | $10^{18}$ | $5\times 10^5$ |

对于 $100\%$ 的数据，$0\le y\lt n\le 10^{18}$，$0\le x\lt \min(2^n, 10^{18})$，$1\le q\le 5\times 10^5$。

**请选用较快的输入输出方式。**

## 样例 #1

### 输入

```
2 2
1 1
2 0```

### 输出

```
3
1```

# AI分析结果

• **综合分析与结论**：这些题解均围绕找规律来解决问题。思路上，都先观察矩阵特性，发现四连通块大小与二进制位相关，呈类似金字塔形状，大小为 \(2^{k + 1} - 1\) 的形式，关键在于确定 \(k\) 值。算法要点是通过位运算，从给定坐标 \((x, y)\) 出发，向右找与起始点值相同的最长串来确定 \(k\)。解决难点在于优化暴力查找，利用 \(x \leq 10^{18}\) 这一条件，当 \(y\) 大于一定值（如 60 或 62）时特判处理，将时间复杂度优化到 \(O(q \log n)\)。

以下是评分较高的题解：
  - **作者：TernaryTree（5星）**
    - **关键亮点**：思路清晰，先通过画图观察每列规律，明确连通块可拆分为若干个 \(2^j\) 之和，利用等比数列求和得出答案形式，再优化查找 \(\max\{j\}\) 的过程，代码简洁明了，注释详细。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 998244353;
int power(int base, int freq, int mod) {
    int ans = 1, tmp = base;
    while (freq > 0) {
        if (freq % 2 == 1) ans = ans * tmp % mod;
        freq /= 2;
        tmp = tmp * tmp % mod;
    }
    return ans;
}
int n, q, x, y;
int find(int x, int y) {
    if (y > 62) return n;
    x >>= y;
    if (!x) return n;
    int d = x & 1;
    do x >>= 1, ++y;
    while ((x & 1) == d);
    return y;
}
signed main() {
    cin >> n >> q;
    while (q--) {
        cin >> x >> y;
        cout << (power(2, find(x, y), mod) - 1 + mod) % mod << endl;
    }
    return 0;
}
```
核心实现思想：`find` 函数用于找到最大的 \(j'\)，从 \((x, y)\) 开始右移 \(x\) 并判断后续位与起始位是否相同，若 \(y\) 大于 62 则直接返回 \(n\)。`power` 函数通过快速幂计算 \(2^{\max\{j\}+1}-1\) 得出答案。
  - **作者：喵仔牛奶（4星）**
    - **关键亮点**：独特地将矩阵逆时针旋转 \(90^{\circ}\) 类比为线段树，形象地得出连通块是一条链的结论，通过向上跳找到异色点确定深度 \(d\)，进而得出答案，代码简洁高效。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb push_back
using namespace std;
namespace Milkcat {
    typedef long long LL;
    typedef pair<LL, LL> pii;
    const int N = 1e6 + 5, mod = 998244353;
    LL n, q, x, y;
    LL qpow(LL b, LL k) { LL r = 1; for (; k; b = b * b % mod, k >>= 1) if (k & 1) r = r * b % mod; return r; }
    int main() {
        cin >> n >> q;
        REP(test, 1, q) {
            cin >> x >> y;
            if (__lg(x) < y) {
                cout << (qpow(2, n) - 1 + mod) % mod << '\n';
            } else {
                int p = x >> y & 1;
                while ((x >> y & 1) == p) y ++;
                cout << (qpow(2, y) - 1 + mod) % mod << '\n';
            }
        }
        return 0;
    }
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int T = 1;
    while (T --) Milkcat::main();
    return 0;
}
```
核心实现思想：`qpow` 函数通过快速幂计算答案。主函数中先判断 \(y\) 是否超出 \(x\) 的最高位，若超出则答案为 \(2^n - 1\)，否则通过循环找到第一个与起始位不同的位，根据等比数列求和公式得出答案。
  - **作者：zxh923（4星）**
    - **关键亮点**：思路直接，通过观察矩阵得出四连通块与第 \(0\) 列相关，利用位运算找出当前位并向后查找不同位，同时考虑边界情况，代码简洁易懂。
    - **重点代码**：
```cpp
#include<bits/stdc++.h> 
#define int long long
#define mod 998244353
using namespace std;
int n,q,a,b,mo,t;
int ksm(int x,int y){//快速幂板子 
    int res=1;
    while(y){
        if(y&1){
            res*=x;
            res%=mod;
        }
        x*=x;
        x%=mod;
        y/=2;
    }
    return res;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);//读写优化 
    cin>>n>>q;
    while(q--){
        cin>>a>>b;
        mo=-1;
        t=((a>>b)&1);//找出这一位是几 
        if(b>=63||(a>>b)==0)mo=n;//a是0或者b在恒定不变列中 
        else{
            for(int i=b+1;;i++)
                if(((a>>i)&1)!=t){//判断是否相同 
                    mo=i;break;
                }
            if(mo==-1)mo=n;
        }
        cout<<(ksm(2,mo)-1+mod)%mod<<'\n';//判负数 
    }
    return 0;
}
```
核心实现思想：`ksm` 函数实现快速幂计算。主函数中先通过位运算获取 \((a, b)\) 处的值 \(t\)，若 \(b\) 大于等于 63 或 \(a\) 右移 \(b\) 位后为 0，则直接确定答案为 \(2^n - 1\)，否则向后查找第一个与 \(t\) 不同的位，计算答案。

• **最优关键思路或技巧**：利用矩阵规律，将四连通块大小与二进制位联系起来，通过位运算优化查找过程，利用 \(x\) 的范围进行特判，避免不必要计算，降低时间复杂度。

• **可拓展之处**：此类题目属于规律探索与位运算结合类型。相似算法套路是先观察数据规律，将问题转化为与二进制、位运算相关操作，再根据数据范围优化暴力算法。同类型题可考虑矩阵中其他连通性问题，或对二进制数据进行特定规则变换后求相关属性。

• **推荐题目**：
  - [P1096 纪念品分组](https://www.luogu.com.cn/problem/P1096)：涉及数据处理与贪心策略，与本题类似，需观察数据特征找规律优化算法。
  - [P1161 开灯](https://www.luogu.com.cn/problem/P1161)：通过位运算解决实际问题，锻炼对二进制操作的理解，与本题在位运算应用上有相似处。
  - [P1314 聪明的质监员](https://www.luogu.com.cn/problem/P1314)：结合二分查找与数据统计，本题在优化过程中也涉及类似根据条件限制缩小范围的思想。

• **个人心得摘录**：
  - **作者：Expert_Dream**：感谢 @tiger2008 在求助贴中告知需要特判 \(y\) 大于 64 的情况，避免时间复杂度过高导致超时。总结：在解决问题时，他人的经验和建议可能对优化算法起到关键作用，要善于交流讨论。
  - **作者：cosf**：在计算 \(x_y\) 时一定要用 `1ll` 去左移而不是 `1`，否则会出错。总结：在涉及位运算和不同数据类型时，要注意数据类型的精度和符号问题，避免因小失大。 

---
处理用时：109.38秒
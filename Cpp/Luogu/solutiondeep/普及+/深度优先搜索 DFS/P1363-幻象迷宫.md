# 题目信息

# 幻象迷宫

## 题目背景

（喵星人 LHX 和 WD 同心协力击退了汪星人的入侵，不幸的是，汪星人撤退之前给它们制造了一片幻象迷宫。）

WD：呜呜，肿么办啊……

LHX：momo...我们一定能走出去的！

WD：嗯，+U+U！

## 题目描述

幻象迷宫可以认为是无限大的，不过它由若干个 $N\times M$ 的矩阵重复组成。矩阵中有的地方是道路，用 $\verb!.!$ 表示；有的地方是墙，用 $\verb!#!$ 表示。LHX 和 WD 所在的位置用 $\verb!S!$ 表示。也就是对于迷宫中的一个点$(x,y)$，如果 $(x \bmod n,y \bmod m)$ 是 $\verb!.!$ 或者 $\verb!S!$，那么这个地方是道路；如果 $(x \bmod n,y \bmod m)$ 是$\verb!#!$，那么这个地方是墙。LHX 和 WD 可以向上下左右四个方向移动，当然不能移动到墙上。

请你告诉 LHX 和 WD，它们能否走出幻象迷宫（如果它们能走到距离起点无限远处，就认为能走出去）。如果不能的话，LHX 就只好启动城堡的毁灭程序了……当然不到万不得已，他不想这么做。

## 说明/提示

- 对于 $30\%$ 的数据，$1\le N,M\le 20$；
- 对于 $50\%$ 的数据，$1\le N,M\le 100$；
- 对于 $100\%$ 的数据，$1\le N,M\le 1500$，每个测试点不超过 $10$ 组数据。

## 样例 #1

### 输入

```
5 4
##.#
##S#
#..#
#.##
#..#
5 4
##.#
##S#
#..#
..#.
#.##
```

### 输出

```
Yes
No

```

# AI分析结果



### 综合分析与结论
本题核心在于判断无限重复迷宫中的无限路径存在性。关键难点在于如何在不实际构造无限地图的情况下，检测到路径的无限延伸可能性。各题解主要围绕以下思路展开：
1. **坐标映射与状态记录**：通过模运算将无限坐标映射到原矩阵，记录访问时的真实坐标偏移量，判断是否在不同副本中访问同一映射点。
2. **扩展矩阵法**：构造2x2或3x3扩展矩阵，检测跨越边界的访问。
3. **图论建模**：将迷宫副本间的连接关系建模为图，检测环路。

### 精选题解与评分
#### 1. DEVILK（⭐⭐⭐⭐⭐）
**关键亮点**：
- 通过记录模坐标(x,y)和真实坐标(lx,ly)，当同一模坐标对应不同真实坐标时判定存在无限路径
- DFS实现简洁高效，时间复杂度O(NM)
- 包含错误思路分析，体现调试过程

**核心代码**：
```cpp
void dfs(int x, int y, int lx, int ly) {
    if(vis[x][y][0] && (vis[x][y][1]!=lx || vis[x][y][2]!=ly)) {
        fl = 1; // 发现不同真实坐标
        return;
    }
    vis[x][y][1] = lx, vis[x][y][2] = ly;
    for(int i=0; i<4; ++i) {
        int xx = (x + dx[i] + n) % n; // 模运算处理坐标
        int lxx = lx + dx[i]; // 真实坐标更新
        // ...（完整方向处理）
    }
}
```

#### 2. LengChu（⭐⭐⭐⭐）
**关键亮点**：
- 使用哈希函数处理真实坐标，通过哈希值判断重复访问
- BFS实现，避免递归栈溢出风险
- 代码简洁，空间优化较好

**核心片段**：
```cpp
int f(int x,int y) { return (x+n*4)/n*131 + (y+m*4)/m*13; }
bool bfs(int x,int y) {
    if(vis[tx][ty] && hash != last_hash) return true;
    // ...使用哈希记录访问状态
}
```

#### 3. Itst（⭐⭐⭐⭐）
**关键亮点**：
- BFS实现，通过偏移量检测环路
- 记录每个副本的坐标偏移，数学建模清晰
- 包含详细错误案例分析和优化思路

### 最优思路总结
**核心技巧**：维护双重坐标系统
1. **模坐标**：(x%n, y%m) 处理无限重复
2. **真实坐标**：记录未取模的(lx, ly)，当同一模坐标对应不同真实坐标时，说明穿越了多个副本，存在无限路径

**实现要点**：
```python
vis[x_mod][y_mod] 存储首次访问时的真实坐标(lx, ly)
当再次访问(x_mod, y_mod)时：
    若当前真实坐标 != 存储的坐标 → 存在无限路径
```

### 拓展与相似题目
1. **洛谷P1510** 精卫填海：类似无限地图处理
2. **洛谷P1825** Corn Maze：多层迷宫结构
3. **洛谷P1379** 八数码难题：状态哈希与重复检测

### 调试经验摘录
- DEVILK：最初错误认为边界互通即可，后通过反例修正为坐标偏移检测
- 阿尔萨斯：曾误判走回原点即为解，后发现需区分坐标偏移奇偶性
- Itst：通过构造9宫格矩阵调试发现环路检测漏洞

---

**核心代码实现示例（DEVILK版）**
```cpp
// vis[x][y][0]: 是否访问过
// vis[x][y][1], vis[x][y][2]: 首次访问时的真实坐标
void dfs(int x, int y, int lx, int ly) {
    if(vis[x][y][0]) {
        if(vis[x][y][1]!=lx || vis[x][y][2]!=ly) fl = 1;
        return;
    }
    vis[x][y][0] = 1;
    vis[x][y][1] = lx, vis[x][y][2] = ly;
    
    for(int i=0; i<4; i++) {
        int xx = (x + dx[i] + n) % n;
        int yy = (y + dy[i] + m) % m;
        int lxx = lx + dx[i], lyy = ly + dy[i];
        if(!a[xx][yy]) dfs(xx, yy, lxx, lyy);
    }
}
```

---
处理用时：64.73秒
# 题目信息

# 油滴扩展

## 题目描述

在一个长方形框子里，最多有 $N$ 个相异的点，在其中任何一个点上放一个很小的油滴，那么这个油滴会一直扩展，直到接触到其他油滴或者框子的边界。必须等一个油滴扩展完毕才能放置下一个油滴。那么应该按照怎样的顺序在这 $N$ 个点上放置油滴，才能使放置完毕后所有油滴占据的总面积最大呢？（不同的油滴不会相互融合）

注：圆的面积公式 $S = \pi r^2$，其中 $r$ 为圆的半径。

## 说明/提示

对于 $100\%$ 的数据，$1 \le N \le 6$，坐标范围在 $[-1000, 1000]$ 内。

## 样例 #1

### 输入

```
2
20 0 10 10
13 3
17 7
```

### 输出

```
50
```

# AI分析结果



### 综合分析与结论
该题需枚举油滴顺序并计算各油滴最大扩展半径。核心难点在于处理顺序影响及半径计算约束（边界与已有油滴）。各题解主要采用全排列枚举或DFS回溯，结合几何计算。由于n≤6，暴力法可行，优化重点在半径计算与代码简洁性。

---

### 精选题解推荐

#### 1. 作者：ylsoi (★★★★☆)
**关键亮点**：
- 简洁的DFS回溯结构，维护已选油滴半径数组。
- 实时计算半径时同时考虑边界与已扩展油滴，避免重复计算。
- 明确处理油滴被覆盖的情况（半径置0）。

**核心代码**：
```cpp
double cal(int i){
    double s1=min(abs(x[i]-xa),abs(x[i]-xb));
    double s2=min(abs(y[i]-ya),abs(y[i]-yb));
    double ans=min(s1,s2);
    for(int j=1;j<=n;j++) 
        if(i!=j&&s[j]) // s[j]表示已扩展
            ans=min(ans, max(sqrt((x[i]-x[j])*(x[i]-x[j]) 
                      + (y[i]-y[j])*(y[i]-y[j])) - r[j], 0.0));
    return ans;
}
```

#### 2. 作者：青珹 (★★★★☆)
**关键亮点**：
- 坐标平移处理负数坐标，统一为正值简化计算。
- 显式判断油滴是否被覆盖，设置半径时避免负值。
- 代码模块化清晰，调试信息丰富。

**个人心得**：
> "π的精度不足导致WA，需取至少6位小数。四舍五入时需先加0.5再转int，避免double截断错误。"

#### 3. 作者：agicy (★★★★☆)
**关键亮点**：
- 预处理所有点对距离，减少重复计算。
- 使用`next_permutation`生成全排列，简化顺序枚举。
- 明确分离边界距离计算与油滴约束逻辑。

**关键代码**：
```cpp
void DFS(int will_put, double sum){
    if(will_put == n+1) ansmax = max(ansmax, sum);
    for(int i=1; i<=n; i++) if(!s[i]){
        r[i] = min(min(x[i]-left, right-x[i]), 
                  min(y[i]-down, up-y[i]));
        for(int j=1; j<=n; j++) if(s[j])
            r[i] = min(r[i], d[i][j]-r[j]);
        s[i] = 1;
        DFS(will_put+1, sum + r[i]*r[i]*M_PI);
        s[i] = 0;
    }
}
```

---

### 最优技巧总结
1. **顺序枚举**：通过全排列或DFS遍历所有可能的油滴放置顺序。
2. **半径约束**：实时计算每个油滴半径，取边界距离与已有油滴约束的最小值。
3. **预处理优化**：预处理点对距离减少重复计算。
4. **精度处理**：使用高精度π值，四舍五入时加0.5转整。

---

### 相似题目推荐
1. **P1036 选数**（全排列枚举）
2. **P1433 吃奶酪**（DFS+几何距离优化）
3. **P1020 导弹拦截**（动态规划与覆盖问题）

---
处理用时：66.64秒
# 题目信息

# [USACO15DEC] Switching on the Lights S

## 题目背景

来源：usaco-2015-dec

Farm John 最近新建了一批巨大的牛棚。这些牛棚构成了一个 $N \times N$ 的矩形网络 $(1 < N < 100)$。

然而 Bessie 十分怕黑，他想计算可以把多少个牛棚的灯打开。

## 题目描述

有 $N \times N$ 个房间，组成了一张 $N \times N$ 的网格图，Bessie 一开始位于左上角 $(1,1)$，并且只能上下左右行走。


一开始，只有 $(1,1)$ 这个房间的灯是亮着的，Bessie 只能在亮着灯的房间里活动。


有另外 $M$ 条信息，每条信息包含四个数 $a,b,c,d$，表示房间 $(a,b)$ 里有房间 $(c,d)$ 的灯的开关。


请计算出最多有多少个房间的灯可以被打开。

## 说明/提示

Bessie 可以使用 $(1,1)$ 的开关打开 $(1,2),(1,3)$ 的灯，然后走到 $(1,3)$ 并打开 $(2,1)$ 的灯，走到 $(2,1)$ 并打开 $(2,2)$ 的灯。$(2,3)$ 的开关无法到达。因此可以点亮 $5$ 个房间。

## 样例 #1

### 输入

```
3 6
1 1 1 2
2 1 2 2
1 1 1 3
2 3 3 1
1 3 1 2
1 3 2 1
```

### 输出

```
5```

# AI分析结果



### 综合分析与结论
本题核心在于动态处理点灯后的可达性扩展。各题解主要采用BFS/DFS结合状态维护，确保新点亮的房间及时被探索。最优解法基于BFS，利用队列处理当前可访问点，并在开灯后检查周围可达性，确保所有可能被点亮的灯均被处理。

---

### 精选题解

#### 1. **JMercury（5星）**
**关键亮点**：  
- 采用类SPFA的BFS，结合状态队列高效处理动态扩展。  
- 使用二维vector存储开关信息，结构清晰。  
- 每次开灯后立即检查相邻点可达性，避免漏判。

**核心代码**：
```cpp
void spfa() {
    queue<P> q; q.push({1,1}); 
    MAP[1][1] = vis[1][1] = true;
    while (!q.empty()) {
        P u = q.front(); q.pop();
        // 处理相邻可达点
        for (int i = 0; i < 4; i++) {
            int vx = u.x + dx[i], vy = u.y + dy[i];
            if (Inside(vx,vy) && !vis[vx][vy] && MAP[vx][vy]) 
                q.push({vx,vy}), vis[vx][vy] = true;
        }
        // 处理当前点开关
        for (auto v : Lamp[u.x][u.y]) {
            if (MAP[v.x][v.y]) continue;
            MAP[v.x][v.y] = true; ans++;
            // 检查新点周围是否可达
            for (int i = 0; i < 4; i++) 
                if (vis[v.x+dx[i]][v.y+dy[i]]) {
                    q.push(v), vis[v.x][v.y] = true;
                    break;
                }
        }
    }
}
```

#### 2. **vani_prcups（4星）**
**关键亮点**：  
- DFS实现简洁，利用访问标记和灯状态分离。  
- 开灯后立即检查周围已访问点触发深度搜索，覆盖潜在路径。

**调试心得**：  
作者提到未使用`visited`数组会导致死循环，强调状态分离的重要性。

**核心片段**：
```cpp
void dfs(int x, int y) {
    if (v[x][y]) return;
    v[x][y] = 1;
    // 处理所有开关
    for (int i = head[x][y]; i; i = a[i].nt) {
        if (!b[tx][ty]) {
            b[tx][ty] = 1; c++;
            // 若新点周围有访问过的点，立即DFS
            if (周围有已访问点) dfs(tx, ty);
        }
    }
    // 扩展四个方向
    if (相邻点未访问且已开灯) dfs(nx, ny);
}
```

#### 3. **BoAn（4星）**
**关键亮点**：  
- 多次DFS直到结果稳定，确保所有可能性被覆盖。  
- 通过比较前后结果判断终止条件，思路直观。

**实现思想**：  
循环执行DFS，每次重置访问数组，直到点亮房间数不再变化。虽效率较低但正确性有保障。

**核心逻辑**：
```cpp
while (ans != ans1) {
    ans1 = ans;
    memset(z, 0, sizeof(z));
    dfs(1, 1); // 重新DFS
    ans = 统计当前亮灯数;
}
```

---

### 最优思路提炼
1. **BFS队列动态扩展**：维护可访问点队列，及时处理新点亮房间的相邻点。
2. **开关邻接表存储**：使用vector或链式结构高效存储每个房间的开关目标。
3. **双状态标记**：分离「已访问」和「已开灯」状态，避免重复处理。
4. **开灯后可达性检查**：当新房间被点亮时，立即检查其四周是否存在已访问点，决定是否加入队列。

---

### 拓展与举一反三
- **类似题型**：动态迷宫（如门需钥匙）、状态分层BFS（如时间约束、多状态）。
- **推荐题目**：  
  1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)（连通块扩展）  
  2. [P1948 电话线](https://www.luogu.com.cn/problem/P1948)（分层图+BFS）  
  3. [P3663 灯谜](https://www.luogu.com.cn/problem/P3663)（动态开关灯变体）

---
处理用时：77.33秒
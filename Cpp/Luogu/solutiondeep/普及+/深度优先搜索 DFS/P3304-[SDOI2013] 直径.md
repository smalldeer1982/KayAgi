# 题目信息

# [SDOI2013] 直径

## 题目描述

小 Q 最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有 $N$ 个节点，可以证明其有且仅有 $N-1$ 条边。

路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用 $\text{dis}(a,b)$ 表示点 $a$ 和点 $b$ 的路径上各边长度之和。称 $\text{dis}(a,b)$ 为 $a,b$ 两个节点间的距离。

直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。

现在小 Q 想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。


## 说明/提示

【样例说明】 

直径共有两条，$3$ 到 $2$ 的路径和 $3$ 到 $6$ 的路径。这两条直径都经过边 $(3,1)$ 和边$(1, 4)$。

对于 $100\%$ 的测试数据：$2\le N\le 200000$，所有点的编号都在 $1\sim N$ 的范围内，边的权值 $\le10^9$。


## 样例 #1

### 输入

```
6
3 1 1000
1 4 10
4 2 100
4 5 50
4 6 100```

### 输出

```
1110 
2```

# AI分析结果



### 综合分析与结论
本题核心在于求所有直径的公共边。各题解共性思路为：先求任意一条直径，再通过分析非直径分支的最大长度与端点的关系确定必经边的范围。最优解法时间复杂度为O(n)，关键在于线性处理直径上的点并确定边界。

---

### 优质题解推荐

#### 1. 破壁人（4.5星）
**核心思路**：
- 两次DFS找直径，记录路径上的点
- 对每个直径点DFS求非直径方向的最长链（dis[i]）
- 通过比较dis[i]与到左右端点的距离确定必经边范围

**亮点**：
- 清晰的左右边界收缩法，逻辑严密
- 代码结构简洁，线性复杂度

**关键代码**：
```cpp
// 确定左边界i和右边界j
for(i=j;i!=0;i=next[i])
    if(dis[v]-dis[i]==mmm[i]) break; // 右边界
for(;i!=0;i=last[i])
    if(dis[i]==mmm[i]) break; // 左边界
ans = j到i的边数
```

#### 2. _J_C_（4星）
**核心思路**：
- BFS找直径后标记路径
- 从两端遍历直径点，求非直径分支的最大长度
- 通过比较最大长度与端点的距离确定边界

**亮点**：
- 详细的代码注释与变量命名
- 利用欧拉序求LCA优化路径处理

**调试心得**：
> "发现必须初始化ans=1，因为后续遍历未统计起点边，这种边界处理经验值得借鉴"

#### 3. i207M（4星）
**核心思路**：
- 树形DP统计每条边在直径方案中的出现次数
- 若边的方案数乘积等于总方案数则为必经边

**亮点**：
- 将问题转化为方案数统计，思路新颖
- 可扩展性强，类似最短路必经边问题

---

### 最优关键思路总结
1. **双DFS求直径**：任选起点找到最远点，再以此点为起点找到直径终点
2. **标记直径路径**：通过父指针回溯记录直径上的点
3. **非直径分支处理**：对每个直径点DFS求不经过其他直径点的最长链
4. **边界确定**：若某点的最长链等于到某端点的距离，则该侧不可能全为必经边

---

### 拓展与相似题目
1. **同类型题**：
   - [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)（直径上的最优路径）
   - [P2491 [SDOI2011]消防](https://www.luogu.com.cn/problem/P2491)（直径性质应用）
   - [P3629 [APIO2010]巡逻](https://www.luogu.com.cn/problem/P3629)（添加边后的直径变化）

2. **思维扩展**：
   - 所有直径交于连续路径的性质可用于快速求交
   - 方案数统计法可推广到带权图必经边问题

---

### 核心代码实现（破壁人版）
```cpp
void dfs1(int o, long long p, int q) { // 找直径端点u
    if(p > op) { op = p; u = o; }
    for(...) if (!vv[...]) dfs1(...);
}

void dfs2(int o, long long p, int q) { // 记录直径路径
    last[o] = q; dis[o] = p;
    if(p > op) { op = p; v = o; }
    for(...) if (!vv[...]) dfs2(...);
}

// 处理必经边
int i;
for(i = j; i != 0; i = next[i]) // 找右边界
    if (dis[v] - dis[i] == mmm[i]) break;
for (; i != 0; i = last[i]) // 找左边界
    if (dis[i] == mmm[i]) break;
ans = i到j的边数
```

---
处理用时：59.70秒
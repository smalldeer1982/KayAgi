# 题目信息

# [NOIP 2017 普及组] 棋盘

## 题目背景

NOIP2017 普及组 T3

## 题目描述

有一个 $m \times m$ 的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。

任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、下、左、右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 $1 $ 个金币。

另外， 你可以花费 $2$ 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。

现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？


## 说明/提示

**样例 1 说明**

棋盘的颜色如下表格所示，其中空白的部分表示无色。

| $\color{red}\text{红}$ | $\color{red}\text{红}$ |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  | $\color{yellow}\text{黄}$ |  |  |  |
|  |  | $\color{yellow}\text{黄}$ | $\color{red}\text{红}$ |  |
|  |  |  | $\color{yellow}\text{黄}$ |  |
|  |  |  |  | $\color{red}\text{红}$ |


从 $(1,1)$ 开始，走到 $(1,2)$ 不花费金币。

从 $(1,2)$ 向下走到 $(2,2)$ 花费 $1$ 枚金币。

从 $(2,2)$ 施展魔法，将 $(2,3)$ 变为黄色，花费 $2$ 枚金币。

从 $(2,2)$ 走到 $(2,3)$ 不花费金币。

从 $(2,3)$ 走到 $(3,3)$ 不花费金币。

从 $(3,3)$ 走到 $(3,4)$ 花费 $1$ 枚金币。

从 $(3,4)$ 走到 $(4,4)$ 花费 $1$ 枚金币。

从 $(4,4)$ 施展魔法，将 $(4,5)$ 变为黄色，花费 $ 2$ 枚金币。

从 $(4,4)$ 走到 $(4,5)$ 不花费金币。

从 $(4,5)$ 走到 $(5,5)$ 花费 $1$ 枚金币。

共花费 $8 $ 枚金币。

**样例 2 说明**

棋盘的颜色如下表格所示，其中空白的部分表示无色。

| $\color{red}\text{红}$ | $\color{red}\text{红}$ |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  | $\color{yellow}\text{黄}$ |  |  |  |
|  |  | $\color{yellow}\text{黄}$ |  |  |
|  |  |  | $\color{white}\text{　}$ |  |
|  |  |  |  | $\color{red}\text{红}$ |

从 $( 1, 1)$ 走到 $( 1, 2)$，不花费金币。

从 $( 1, 2)$ 走到 $( 2, 2)$，花费 $ 1 $ 金币。

施展魔法将 $( 2, 3)$ 变为黄色，并从 $( 2, 2)$ 走到 $( 2, 3)$ 花费 $ 2$ 金币。

从 $( 2, 3)$ 走到 $( 3, 3)$ 不花费金币。

从 $( 3, 3)$ 只能施展魔法到达 $( 3, 2),( 2, 3),( 3, 4),( 4, 3)$。

而从以上四点均无法到达 $( 5, 5)$，故无法到达终点，输出$-1$。

**数据规模与约定**

对于 $30\%$ 的数据，$1 ≤ m ≤ 5, 1 ≤ n ≤ 10$。

对于 $60\%$ 的数据，$1 ≤ m ≤ 20, 1 ≤ n ≤ 200$。

对于 $100\%$ 的数据，$1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000$。


## 样例 #1

### 输入

```
5 7
1 1 0
1 2 0
2 2 1
3 3 1
3 4 0
4 4 1
5 5 0```

### 输出

```
8```

## 样例 #2

### 输入

```
5 5
1 1 0
1 2 0
2 2 1
3 3 1
5 5 0```

### 输出

```
-1```

# AI分析结果



### 综合分析与结论
本题核心在于处理魔法机制与颜色变化对路径花费的影响，各题解主要采用以下思路：
1. **状态扩展**：将魔法使用情况、颜色等作为状态维度，转化为分层图问题。
2. **移动方式转化**：将魔法触发的跳跃视为额外移动方向，统一处理为传统最短路问题。
3. **优先队列优化BFS/Dijkstra**：处理不同边权，确保每次取出最小花费节点。

### 高分题解推荐

#### 1. ZigZagKmp（★★★★★）
**关键亮点**：
- 将魔法转化为12个方向移动（4普通+8魔法跳跃），避免复杂状态管理。
- 优先队列BFS实现高效最短路，时间复杂度O(M² log M)。
- 终点无色特判逻辑清晰。

**核心代码思想**：
```cpp
struct node { int x,y,c,w; };
priority_queue<node> q;
int dx[] = {0,1,0,-1,1,1,-1,-1,0,2,0,-2}; // 12方向
int dy[] = {1,0,-1,0,1,-1,1,-1,2,0,-2,0};
int dw[] = {0,0,0,0,2,2,2,2,2,2,2,2}; // 魔法额外花费

void bfs() {
    while (!q.empty()) {
        node cur = q.top(); q.pop();
        for (int i=0; i<12; i++) { // 遍历所有方向
            // 计算新坐标与花费，检查边界
            // 更新dis并加入队列
        }
    }
}
```

#### 2. lby_commandBlock（★★★★）
**关键亮点**：
- 状态包含位置、颜色、魔法使用标志，直接BFS。
- 记忆化剪枝优化，避免重复搜索。

**核心代码思想**：
```cpp
struct node { int x,y,color,magic,money; };
queue<node> q;
int ans[105][105]; // 记忆最小花费

void bfs() {
    q.push({1,1,初始颜色,0,0});
    while (!q.empty()) {
        node cur = q.front(); q.pop();
        for (移动方向) {
            if (新位置合法 && 花费更低) {
                更新ans并加入队列
            }
        }
    }
}
```

#### 3. dxzier（★★★★）
**关键亮点**：
- 分层图思想，状态包含是否使用魔法。
- SPFA处理动态边权，适合稀疏图。

### 关键思路总结
1. **状态设计**：扩展状态维度（颜色、魔法标志）是关键，如 `(x, y, 颜色, 是否使用魔法)`。
2. **移动转化**：将魔法跳跃视为额外方向，统一计算花费。
3. **优先队列优化**：确保每次取出当前最小花费状态，避免无效搜索。

### 拓展与举一反三
- **类似题目**：
  - [P4568 [JLOI2011] 飞行路线](https://www.luogu.com.cn/problem/P4568)（分层图经典）
  - [P4667 Switch the Lamp On](https://www.luogu.com.cn/problem/P4667)（双端队列BFS）
  - [P3956 棋盘](https://www.luogu.com.cn/problem/P3956)（本题变式）

- **调试心得**：
  - ZigZagKmp提到直接处理魔法容易出错，通过转化移动方式简化问题。
  - 览遍千秋强调注意终点无色时的特殊处理，避免遗漏边界情况。

### 核心代码片段（ZigZagKmp）
```cpp
// 优先队列BFS核心逻辑
void bfs() {
    memset(dis, 0x3f, sizeof(dis));
    dis[1][1] = 0;
    q.push({1, 1, a[1][1], 0});

    while (!q.empty()) {
        node cur = q.top(); q.pop();
        if (dis[cur.x][cur.y] < cur.w) continue;

        for (int i=0; i<12; i++) { // 12方向扩展
            int nx = cur.x + dx[i], ny = cur.y + dy[i];
            if (nx<1||nx>m||ny<1||ny>m) continue;

            int cost = cur.w + dw[i];
            if (a[nx][ny] != cur.c) cost += 1; // 颜色不同追加花费
            if (cost < dis[nx][ny]) {
                dis[nx][ny] = cost;
                q.push({nx, ny, a[nx][ny], cost});
            }
        }
    }
}
```

---
处理用时：80.09秒
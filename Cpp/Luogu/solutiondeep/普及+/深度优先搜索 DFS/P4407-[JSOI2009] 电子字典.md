# 题目信息

# [JSOI2009] 电子字典

## 题目描述


人们在英文字典中查找某个单词的时候可能不知道该单词的完整拼法，而只知道该单词的一个错误的近似拼法，这时人们可能陷入困境，为了查找一个单词而浪费大量的时间。带有模糊查询功能的电子字典能够从一定程度上解决这一问题：用户只要输入一个字符串，电子字典就返回与该单词编辑距离最小的几个单词供用户选择。

字符串 $a$ 与字符串 $b$ 的编辑距离是指：允许对 $a$ 或 $b$ 串进行下列“编辑”操作，将 $a$ 变为 $b$ 或 $b$ 变为 $a$，最少“编辑”次数即为距离。

1. 删除串中某个位置的字母；
2. 添加一个字母到串中某个位置；
3. 替换串中某一位置的一个字母为另一个字母。

JSOI 团队正在开发一款电子字典，你需要帮助团队实现一个用于模糊查询功能的计数部件：对于一个待查询字符串，如果它是单词，则返回 $-1$；如果它不是单词，则返回字典中有多少个单词与它的编辑距离为 $1$。

## 说明/提示

### 样例解释

- `abcd` 在单词表中出现过；
- `abc` 与单词 `abcd`、`aabc` 的编辑距离都是 $1$；
- `abcdd` 与单词 `abcd`、`abcde`、`abced` 的编辑距离都是 $1$。

### 数据范围与约定

- 所有单词互不相同，但是查询字符串可能有重复；
- 对 $50\%$ 的数据范围，$N,M\le 10^3$；
- 对 $100\%$ 的数据范围，$N,M\le 10^4$。

## 样例 #1

### 输入

```
4 3
abcd
abcde
aabc
abced
abcd
abc
abcdd```

### 输出

```
-1
2
3```

# AI分析结果



### 综合分析与结论

本题核心在于高效处理字符串编辑距离为1的查询。题解主要采用两种思路：**Trie树DFS搜索**和**哈希预处理**。Trie树通过动态遍历可能路径避免暴力生成所有变种，哈希则通过预计算所有可能的编辑操作实现快速查询。两种方法均需处理重复计数问题，关键优化点在于剪枝和状态去重。

---

### 精选题解与评分

#### 1. 作者：Utsuji_risshū ⭐⭐⭐⭐⭐  
**关键亮点**：  
- 使用Trie树结构，DFS模拟三种编辑操作（增删改），通过 `vis[]` 数组避免重复计数。  
- 状态参数 `(节点, 当前字符位置, 是否使用过编辑)` 设计巧妙，逻辑清晰。  
- 代码简洁高效，核心DFS仅30行，利用全局数组 `visx` 记录已访问节点。  
**个人心得**：  
作者提到“不同的修改可能生成相同串”问题，通过标记Trie终止节点实现去重，体现了对问题本质的理解。

#### 2. 作者：Iscream2001 ⭐⭐⭐⭐  
**关键亮点**：  
- 哈希预处理所有可能的编辑变种，利用 `map<ull,ull>` 分长度存储，查询复杂度O(1)。  
- 将添加操作转化为反向删除，减少枚举次数，预处理复杂度O(n*len)。  
- 离散化哈希值去重，避免重复统计同一单词的不同编辑方式。  
**核心思路**：  
- 对每个单词预处理删除、替换、添加后的哈希值，查询时直接统计匹配的哈希数量。

#### 3. 作者：KaisuoShutong ⭐⭐⭐⭐  
**关键亮点**：  
- 详细注释与状态转移解释，将DFS拆分为 `dfs1`（删除）、`dfs2`（添加）、`dfs3`（替换），逻辑分离清晰。  
- 特判末尾添加字符的情况，避免遗漏边界条件。  
- 通过 `vis[]` 标记Trie节点实现去重，与Utsuji方案异曲同工。

---

### 关键代码与实现思想

#### Utsuji_risshū的DFS核心逻辑：
```cpp
void DFS(int rt, int l, bool f) {
    if (l == len && p[rt] && !f) { word=1; return; } // 精确匹配
    if (l == len && p[rt] && f) { // 编辑后匹配
        if (!vis[rt]) vis[visx[++vistot]=rt] = 1;
        return;
    }
    int c = s[l] - 'a';
    if (!f) { // 未使用编辑机会时，枚举所有可能操作
        if (l < len) DFS(rt, l+1, 1); // 删除当前字符
        for (int i=0; i<26; ++i) {
            if (Trie[rt][i]) {
                DFS(Trie[rt][i], l, 1); // 插入字符i
                if (i != c) DFS(Trie[rt][i], l+1, 1); // 替换为字符i
            }
        }
    }
    if (Trie[rt][c]) DFS(Trie[rt][c], l+1, f); // 不编辑，正常匹配
}
```
**实现思想**：通过递归参数 `f` 控制是否使用编辑机会，分情况处理增删改操作，`vis[]` 数组确保每个Trie节点仅计数一次。

---

### 举一反三与题目推荐

1. **编辑距离扩展**  
   - 相似题：P2758（编辑距离模板）、P1688（编辑距离为1的变种）。  
   - 技巧：预处理哈希或Trie动态搜索，注意去重与状态剪枝。

2. **Trie树进阶应用**  
   - 相似题：P2580（字典树模板）、P2922（前缀匹配）。  
   - 技巧：结合DFS/BFS处理复杂字符串匹配，利用节点标记优化查询。

3. **哈希预处理优化**  
   - 相似题：P3823（哈希前缀和）、P3538（滚动哈希）。  
   - 技巧：设计高效哈希函数，分情况预处理减少枚举量。

---

### 调试与优化经验摘录

- **Cry_For_theMoon** 提到替换时需排除原字符，否则会导致无效修改，通过 `if(i != c)` 避免冗余搜索。  
- **creation_hy** 强调 `vis[]` 应在完全匹配时更新，避免错误标记前缀节点，确保统计准确性。  
- **EchoHua0402** 指出暴力枚举可能生成重复串，需在哈希或Trie节点层面对结果去重。

---
处理用时：73.59秒
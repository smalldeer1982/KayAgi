# 题目信息

# [BJOI2018] 求和

## 题目描述

master 对树上的求和非常感兴趣。他生成了一棵有根树，并且希望多次询问这棵树上一段路径上所有节点深度的 $k$ 次方和，而且每次的 $k$ 可能是不同的。此处节点深度的定义是这个节点到根的路径上的边数。他把这个问题交给了 pupil，但 pupil 并不会这么复杂的操作，你能帮他解决吗？

## 说明/提示

### 样例解释

以下用 $d (i)$ 表示第 $i$ 个节点的深度。

对于样例中的树，有 $d (1) = 0, d (2) = 1, d (3) = 1, d (4) = 2, d (5) = 2$。

因此第一个询问答案为 $(2^5 + 1^5 + 0^5) \bmod 998244353 = 33$，第二个询问答案为$(2^{45} + 1^{45} + 2^{45}) \bmod 998244353 = 503245989$。

### 数据范围

对于 $30\%$ 的数据，$1 \leq n,m \leq 100$。

对于 $60\%$ 的数据，$1 \leq n,m \leq 1000$。

对于 $100\%$ 的数据，$1 \leq n,m \leq 300000$，$1 \leq k \leq 50$。

另外存在 5 个不计分的 hack 数据。

### 提示

数据规模较大，请注意使用较快速的输入输出方式。

## 样例 #1

### 输入

```
5
1 2
1 3
2 4
2 5
2
1 4 5
5 4 45```

### 输出

```
33
503245989```

# AI分析结果



### 综合分析与结论
题目要求快速计算树上路径节点深度的k次方和。所有题解均基于LCA+树上差分/前缀和，核心思路是预处理每个节点到根的k次方前缀和，利用LCA将路径拆分为两段，通过差分公式快速计算。关键优化在于O(NK)预处理深度k次方前缀和，将每次查询复杂度降至O(1)。

---

### 高分题解推荐

#### 1. 作者：shadowice1984 (★★★★★)
**关键亮点**  
- 采用倍增LCA+树上差分，代码简洁高效  
- 预处理时动态计算k次方和，空间优化到位  
- 正确处理LCA节点的重复计算问题  
**核心代码片段**  
```cpp
void dfs(int u) {
    for(int i=1;i<=50;i++) 
        val[v][i] = (pow(dep[v],i) + val[u][i]) % mod;
    // 动态维护前缀和
}

int query(int u,int v,int k) {
    int l = lca(u,v);
    return (val[u][k] + val[v][k] - val[l][k] - val[fa[l][0]][k]) % mod;
}
```

#### 2. 作者：NaCly_Fish (★★★★☆)
**关键亮点**  
- 树链剖分实现，查询时直接利用DFS序  
- 预处理时存储每个剖分链的k次方和  
- 采用快速幂优化预处理  
**调试心得**  
> "数据规模较大时，树剖的O(logN)查询更稳定，但要注意预处理时k的范围控制"

#### 3. 作者：Rainybunny (★★★★☆)
**关键技巧**  
- 将深度转换为连续整数，直接预处理1~maxd的k次方前缀和  
- 使用路径压缩并查集优化LCA查询  
**核心公式**  
`ans = sum[u][k] + sum[v][k] - sum[lca][k] - sum[fa[lca]][k]`

---

### 最优思路总结
**关键路径**  
1. **预处理策略**  
   - 对每个k∈[1,50]，预处理节点到根的k次方前缀和  
   - O(1)快速幂预处理深度值的各次方  

2. **LCA应用**  
   - 路径拆解为u→lca和v→lca两部分  
   - 差分公式消除重复计算  

3. **实现优化**  
   - 倍增法求LCA平衡时间与空间  
   - 负数取模处理：(a - b + mod) % mod  

**同类型题目推荐**  
1. [P3379 LCA模板](https://www.luogu.com.cn/problem/P3379)  
2. [P3258 松鼠的新家](https://www.luogu.com.cn/problem/P3258)（树上差分应用）  
3. [P4211 LNOI2014-LCA](https://www.luogu.com.cn/problem/P4211)（深度相关区间查询）  

**调试经验摘录**  
> "快速幂预处理时发现TLE，改用动态计算每个节点的k次方累加，避免重复计算" —— shadowice1984  
> "WA后发现LCA父节点未处理模运算负数情况，+mod再取模解决" —— Rainybunny

---
处理用时：48.64秒
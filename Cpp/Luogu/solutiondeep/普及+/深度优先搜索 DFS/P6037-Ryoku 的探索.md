# 题目信息

# Ryoku 的探索

## 题目背景

Ryoku 对自己所处的世界充满了好奇，她希望能够在她「死」之前尽可能能多地探索世界。

这一天，Ryoku 得到了一张这个世界的地图，她十分高兴。然而，Ryoku 并不知道自己所处的位置到底在哪里，她也不知道她会什么时候死去。她想要知道如何才能尽可能多的探索这个世界。

## 题目描述

Ryoku 所处的世界可以抽象成一个有 $n$ 个点， $n$ 条边的带权无向连通图 $G$。每条边有美观度和长度。

Ryoku 会使用这样一个策略探索世界：在每个点寻找一个**端点她未走过**的边中**美观度最高**的走，如果没有边走，就沿着她前往这个点的边返回，类似于图的**深度优先遍历**。

探索的一个方案的长度是这个方案所经过的所有边长度的和（返回时经过的长度不用计算）。

她想知道，对于每一个起点 $s=1,2,\cdots,n$，她需要走过的长度是多少？



## 说明/提示

**【样例 1 说明】**

以下为输入输出样例 1 中的图： （边上红色数组为 $p$，黑色为 $w$）

![](https://cdn.luogu.com.cn/upload/image_hosting/rmk07281.png)

若起点为 $1$，顺序为 $1\to3\to5\to2\to4$，长度之和为 $7$。  
若起点为 $2$，顺序为 $2\to3\to5\to1\to4$，长度之和为 $7$。  
若起点为 $3$，顺序为 $3\to5\to1\to2\to4$，长度之和为 $8$。  
若起点为 $4$，顺序为 $4\to1\to3\to5\to2$，长度之和为 $7$。  
若起点为 $5$，顺序为 $5\to3\to1\to2\to4$，长度之和为 $8$。  

---

**【数据规模与约定】**

对于 $40\%$ 的数据，$n\le 10^3$。    
对于 $100\%$ 的数据，$3 \le n \le 10^6$，$1 \le u,v,p \le n$，$0\le w\le 10^9$，保证 $p$ 互不相同。

## 样例 #1

### 输入

```
5
4 1 2 1
1 2 3 2
3 1 1 4
3 5 2 5
2 3 2 3
```

### 输出

```
7
7
8
7
8```

# AI分析结果



### 综合分析与结论
该题核心是基环树遍历策略：所有起点遍历路径长度为总边权减去环上某条边权。关键点在于：
1. **找环**：通过DFS回溯或拓扑排序确定基环树中的环
2. **环边舍弃规则**：环上每个节点会舍弃相邻两条环边中美观度较低的边
3. **子树处理**：非环节点的答案等于其所在子树的根节点（环上节点）的答案

### 精选题解（评分≥4星）

---

#### 题解1：xiejinhao（⭐⭐⭐⭐⭐）
**关键亮点**：
- 清晰的双DFS结构（找环+子树赋值）
- 详细解释环边舍弃逻辑的推导过程
- 处理环的起点与终点的特殊边对比

**核心代码思想**：
```cpp
bool dfs(int x, int fa, int fp, int fe) {
    if(vis[x]) { // 找到环时处理终点边
        End = x, Ep = fp, Ee = fe;
        return true;
    }
    vis[x] = 1;
    for(int i = head[x]; i; i = Next[i]) {
        int y = ver[i];
        if(y == fa) continue;
        if(dfs(y, x, p[i], e[i])) { // 回溯处理环边
            if(x != End) 
                ans[x] -= fp > p[i] ? e[i] : fe;
            else  ans[x] -= p[i] > Ep ? Ee : e[i];
            ring.push_back(x);
            return x != End;
        }
    }
    return false;
}
```

---

#### 题解2：Zvelig1205（⭐⭐⭐⭐）
**关键亮点**：
- 使用拓扑排序找环，直观易理解
- 采用显式子树标记方法
- 代码结构简洁高效

**核心代码思想**：
```cpp
void dfs(int rt, int now) { // 标记子树答案
    vis[now] = 1;
    for(int i = head[now]; i; i = Next[i]) {
        int y = ver[i];
        if(vis[y] || !cir[y]) continue; // cir[]标记环节点
        ans[y] = ans[rt];
        dfs(rt, y);
    }
}
```

---

#### 题解3：Smallbasic（⭐⭐⭐⭐）
**关键亮点**：
- 利用vector存储环结构
- 预处理每个环节点的最小美观度边
- 非环节点答案直接映射

**核心代码思想**：
```cpp
for(int x : ring) {
    int min_p = INF, del_w;
    for(auto &e : edges[x]) { // 遍历环邻接边
        if(is_in_ring[e.to] && e.p < min_p) {
            min_p = e.p;
            del_w = e.w;
        }
    }
    ans[x] = total - del_w;
}
```

---

### 最优思路总结
1. **环的识别**：DFS回溯法能同时记录环路径，适合处理复杂环结构；拓扑排序法则更稳定但需额外标记
2. **边权计算**：比较环上相邻两边的美观度，舍弃较小者对应边权
3. **子树处理**：将环视为根节点，通过DFS/BFS将子树答案统一

### 同类题目推荐
1. [P4381 [IOI2008] Island](https://www.luogu.com.cn/problem/P4381)  
  基环树直径问题，考察环处理与树形DP结合
2. [P2607 [ZJOI2008]骑士](https://www.luogu.com.cn/problem/P2607)  
  基环树上的动态规划，处理环上取舍
3. [P3533 [POI2012] RAN-Rendezvous](https://www.luogu.com.cn/problem/P3533)  
  基环树上的路径查询，需处理环与树结构

### 关键实现技巧
1. **环的存储**：使用vector记录环节点顺序，便于后续处理相邻边
2. **边权预处理**：在读入时累加总边权，后续只需处理减去的边
3. **子树标记**：利用DFS的天然递归性质，将环上节点的答案传播到子树

### 易错点总结（题解中的个人心得）
1. **环边比较顺序**：需注意环的遍历方向，比较边时应考虑双向边情况
2. **long long陷阱**：总边权可能超过int范围，必须使用long long
3. **终点处理**：环的起点与终点连接处需特殊处理边权比较

---
处理用时：64.18秒
# 题目信息

# [传智杯 #4 决赛] 生活在树上（easy version）

## 题目背景

**本题是 P8201 的简单版本，两道题目的解法略有不同。本题和 P8201 在题意上的区别在于本题给定树上的边权，而不是点权。**

小智生活在「传智国」，这是一个有 $n$ 个城市的国家，各个城市由 $n-1$ 条道路相连。

每个道路都有长度 $w_i$ ，我们定义，小智从城市 $a$ 走到城市 $b$ 的代价是 $\mathrm{dis}_{a, b} = \bigoplus \limits_{e \in \mathrm{path}\left(a, b\right)} w_e$，其中 $\bigoplus$ 表示**按位异或**（如果你不知道什么是**按位异或**，请参见题目下方的提示/说明），$\mathrm{path}\left(a,b\right)$ 表示 $a$ 到 $b$ 的简单路径上的边集。也即 $\mathrm{dis}_{a, b}$ 表示将 $a$ 与 $b$ 的简单路径上所有边写作 $e_1, e_2, e_3, \dots$ 后，求 $w_{e_1} \bigoplus w_{e_2}\bigoplus w_{e_3} \dots$ 的结果。

有一天，小智获得了去参加传智杯的机会，他在前往比赛地的路上想到了一个问题，但他好像不会做，于是他把这个题告诉了你。聪明的同学，你可以帮帮他吗？

## 题目描述

小智说：「由于我们的国家只有 $n$ 个城市和 $n-1$ 条道路，那么我们的国家就相当于是一棵树。我在想，在我们的国家中，是否有城市满足『到城市 $a$ 的代价和到城市 $b$ 的代价的异或等于 $k$』。好难哦，我想不出来，你能帮帮我吗？」

也就是说，给定城市 $a, b$ 和整数 $k$，请你计算是否存在城市 $t$ 满足 $\mathrm{dis}_{t, a} \bigoplus \mathrm{dis}_{t, b} = k$。

## 说明/提示

### 相关概念解释
「树」：树是一个有 $n$ 个结点和 $n-1$ 条边的无向简单连通图。

「按位异或」：按位异或即 C++、python、java 语言中的 「^」 运算。它是一个二元运算，步骤是将两个数的二进制位按位比较，相同为 $0$，不同为 $1$。例如：$3 \bigoplus 5 = (011)_2 \bigoplus (101)_2 = (110)_2 = 6$。**请注意，这是一个按位运算，不是一个逻辑运算**。
### 样例 1 解释
下图为传智国的地图。

$\forall t \in \{1, 2, 3, 4, 5\}$，都不可能有 $\mathrm{dis} _{t,1} \bigoplus \mathrm{dis}_{t, 2} = 4$，$\mathrm{dis}_{t, 2} \bigoplus \mathrm{dis}_{t, 3} = 12$，于是输出 `No`；

而取 $t = 5$，有 $\mathrm{dis}_{t, 1} \bigoplus \mathrm{dis}_{t, 4} = 10$，于是输出 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ikzjfh3.png)
### 数据规模与约定
对于所有测试点，保证 $1 < n \leq 5 \times 10^5$，$1 \leq m \leq 5 \times 10^5$，$0 \leq w_i < 2^{64}$。

对于每次询问，保证 $1 \leq a, b \leq n$ 且 $a \neq b$，$0 \leq k < 2^{64}$。

## 样例 #1

### 输入

```
5 3
1 2 2
1 3 6 
2 4 8
2 5 1
1 2 4
2 3 12
1 4 10```

### 输出

```
nO
No
YeS```

## 样例 #2

### 输入

```
5 10
2 1 63
3 1 57
4 2 2
5 2 84
5 2 84
4 1 9977404983223574764
2 5 84
2 1 15996060349666123522
5 4 86
3 1 8428615422876116375
5 1 107
2 3 6
2 3 6
4 2 2```

### 输出

```
yeS
nO
YEs
No
YEs
nO
YEs
yeS
yeS
YEs```

# AI分析结果



### 综合分析与结论
本题关键在于发现无论 t 的位置如何，dis(t,a) ^ dis(t,b) 始终等于 dis(a,b)。利用异或运算的交换律、结合律及自反性，可简化为预处理每个节点到根的异或和，将问题转化为 O(1) 查询。

---

### 精选题解

#### 1. 作者：一扶苏一 (⭐⭐⭐⭐⭐)
**关键亮点**：
- 利用群论性质，简洁证明异或路径的抵消规律，得出核心结论 `dis(a,b) = dis_root[a] ^ dis_root[b]`。
- 代码简洁高效，仅需一次 DFS 预处理，时间复杂度 O(n + m)。
- 无需 LCA 计算，直接利用前缀异或性质。

**核心代码**：
```cpp
void dfs(const int u, const int f) {
  for (auto [v, w] : e[u]) if (v != f) {
    b[v] = b[u] ^ w; // 维护到根的异或和
    dfs(v, u);
  }
}
// 查询时直接比较 (b[x] ^ b[y]) == k
```

#### 2. 作者：lsj2009 (⭐⭐⭐⭐)
**关键亮点**：
- 通过代数展开直观展示异或抵消过程，推导出相同结论。
- 代码结构清晰，强调输入优化与快速判断。

**核心思路**：
```cpp
// 预处理 dis[v] = dis[u] ^ w
// 查询时 (dis[a] ^ dis[b]) == k ? "Yes" : "No"
```

#### 3. 作者：Dusker (⭐⭐⭐⭐)
**关键亮点**：
- 通过 LCA 路径分析进一步验证结论正确性。
- 代码实现随机化输出格式处理，展示对特殊判题要求的适应能力。

**代码片段**：
```cpp
dfs(1, 0); // 预处理异或和
if ((Xor[x] ^ Xor[y]) == k) ... // 输出结果
```

---

### 最优关键思路
**核心技巧**：利用前缀异或和的抵消性，将路径异或转换为两点到根异或的异或。通过一次 DFS 预处理所有节点到根的异或值，将问题转化为 O(1) 查询。

**思维模式**：将路径问题转换为前缀运算，利用代数性质消除冗余计算。类似前缀和的思路，但适用于异或等可逆运算。

---

### 拓展与举一反三
**类似套路题目**：
1. **路径异或性质**：洛谷 P2420（异或路径统计）
2. **前缀运算转换**：LeetCode 1310（子数组异或查询）
3. **树上前缀技巧**：洛谷 P3398（判断路径交集）

**调试心得**（摘自题解）：
- 作者 MeowScore 的树剖解法因未发现异或抵消规律，导致复杂实现。教训：应优先寻找数学性质简化问题。
- Dusker 强调必须使用 `unsigned long long`，避免溢出导致错误。

---

### 推荐相似题目
1. [P2420 让我们异或吧](https://www.luogu.com.cn/problem/P2420)  
   **考察点**：树路径异或和的前缀处理

2. [P5536 【XR-3】核心城市](https://www.luogu.com.cn/problem/P5536)  
   **考察点**：树的性质与路径分析

3. [CF742B Arpa’s obvious problem](https://codeforces.com/problemset/problem/742/B)  
   **考察点**：异或性质与计数技巧

---
处理用时：62.32秒
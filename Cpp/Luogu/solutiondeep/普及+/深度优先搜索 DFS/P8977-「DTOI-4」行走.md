# 题目信息

# 「DTOI-4」行走

## 题目背景

小 L 感到无聊，于是希望在树上行走。

## 题目描述

小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。

他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。

他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：

- $P$ 是一条**可以为空**的**简单有向路径**。
- 设 $P$ 中依次经过的点为 $P_1, P_2, \cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。
- 设 $f(P) = \displaystyle\sum_{i = 1}^{|P|} \frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。
- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。

请你求出符合上述条件的路径 $P$。 

------------

关于本题中字典序的定义：

设有两条待比较的路径 $P \neq Q$。

- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。
- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。

## 说明/提示

#### 样例 #1 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)

$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \frac{1}{4} = \frac{5}{4}$。可以证明不存在更优的 $P$。
#### 数据范围
| $\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |
| :------: | :------: | :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 50$ | 无特殊限制 | 无 | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 500$ | 同上 | $1$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 5 \times 10^3$ | 同上 | $1, 2$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^5$ | 同上 | $1 \sim 3$ | $20 \operatorname{pts}$ |
| $5$ | 无特殊限制 | $a_i \in \{-1, 1\}$ | 无 | $20 \operatorname{pts}$ |
| $6$ | 同上 | 无特殊限制 | $1 \sim 5$ | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$a_i \in \{-1, 0, 1\}$，$1 \leq u, v \leq n$，保证给出的边可以构成一棵**无根树**。

## 样例 #1

### 输入

```
5
1 0 -1 1 -1
1 2
2 3
2 4
1 5```

### 输出

```
1 2 4```

# AI分析结果



### 综合分析与结论
本题核心在于贪心策略与字典序处理的结合。各题解的共同核心思路为：  
1. **避免-1节点**：走-1节点必然导致总贡献无法弥补  
2. **优先选择1节点**：高位选1的收益远高于后续节点选1的累积  
3. **字典序处理**：对邻接表排序，每次优先选编号最小的可行节点  
4. **路径剪枝**：通过DFS/BFS维护最优贡献路径，动态更新路径选择  

### 高星题解推荐
#### 1. xiaoqian02（4星）
**关键亮点**：  
- 递归式DFS清晰展现贪心策略，维护qz数组记录二进制贡献  
- 动态更新nxt数组处理路径选择，处理末尾0的技巧简洁  
- 代码结构模块化，可读性较强  

**核心代码逻辑**：
```cpp
bool dfs(int p,int fr,int dep) {
    int mx=-1; // 子节点最大权值
    for(auto k : ed[p]) {
        if(a[k]==1 && qz[dep]==0) { // 发现更优贡献时更新
            qz[dep]=1;
            nxt[p]=k; // 更新路径
            for(int j=dep+1;j<=mxd;j++) qz[j]=0; // 清空低位
        }
        if(dfs(k,p,dep+1)) nxt[p]=k; // 递归处理子节点
    }
    if(mx==0) { // 处理全0子树
        for(auto k : ed[p]) if(a[k]==0) dfs(k,p,dep+1);
    }
    return bg; // 返回是否更新
}
```

#### 2. Hovery（4星）
**关键亮点**：  
- BFS分层处理确保每层最优，通过mx数组记录层内最大值  
- 路径回溯时利用父子关系链式输出，避免显式存储路径  
- 预处理邻接表排序保证字典序  

**核心代码逻辑**：
```cpp
void bfs() {
    q.push({1,0,a[1]==1}); // (节点,深度,1的个数)
    while(!q.empty()) {
        auto [x,dep,val] = q.front();
        if(val > ans.second) ans = {x,val}; // 更新最优终点
        for(auto k : G[x]) {
            int new_val = val + (a[k]==1);
            if(new_val >= mx[dep+1]) { // 仅保留最大值路径
                mx[dep+1] = new_val;
                q.push({k,dep+1,new_val});
            }
        }
    }
}
```

### 最优思路总结
1. **二进制位权贪心**：将路径视为二进制数，高位优先最大化，通过维护当前贡献位状态实现  
2. **邻接表预处理**：对所有节点的子节点按编号排序，确保每次选择字典序最小  
3. **末尾0处理技巧**：在最终输出时逆向删除路径末尾的0节点（如xiaoqian02的qz数组清零）  

### 拓展建议
- **同类题型**：树形结构的最优路径问题（如CF1393D）、带权字典序问题（如P2233）  
- **优化技巧**：对分层处理问题可考虑双队列交替（如LiYomi题解），避免重复入队  

### 相似题目推荐
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)（树形DP与最优路径）  
2. [P1395 会议](https://www.luogu.com.cn/problem/P1395)（树的重心+路径统计）  
3. [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)（树形DP与收益最大化）  

### 题解个人心得摘录
- **xiaoqian02**：  
  > "dfs前对邻接表排序是关键，否则字典序无法保证。末尾0的处理需要清空后续位，否则会干扰高位比较"  
- **LiYomi**：  
  > "Hack数据发现，同一层节点间的淘汰需全局判断，不能仅看单个父节点的子节点"  
- **Nuyoah_awa**：  
  > "链表式nxt数组比显式存路径更高效，避免vector频繁扩容"

---
处理用时：60.51秒
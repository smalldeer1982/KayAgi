# 题目信息

# 「DTOI-5」校门外的枯树

## 题目背景

某天放学，你走出了校门，发现校门外又双叒叕出现了一排树。只不过因为正值寒冬时节，树的叶子都掉光了，树们在寒风中瑟瑟发抖，让人担心它们会不会在某一时刻失去平衡，然后倒下来。

## 题目描述

给你校门外的一排 $T$ 棵无向有根树（每棵树的根节点编号均为 $1$），每棵树的每条边有其重量 $m_i$，现在请你算出每棵树的不平衡度 **或** 该树的**每个节点的子树**的不平衡度，好让校方帮忙加固。$\color{white}\sout{\text{不要问我为什么重量的字母是 }m\text。}$

注意这里的**树的边是有顺序的**，~~你总不可能把树枝掰断然后嫁接到另一个地方吧，这可是枯树啊喂~~。

---

对于一颗有根树，定义其不平衡度为该树被在根节点与某一叶子节点的一条最短路径分割为左右两部分（两个边集）后（两个边集均不含该最短路径中的边）两部分的边的总重之差的最小值。特别地，**单个点作为树的不平衡度为 $0$**；空边集内边的总重为 $0$。

## 说明/提示

**【数据范围】**

**不捆绑测试**，同一 $\text{Subtask}$ 内每个测试点等分。

$$
%\def\or{\operatorname{or}}
%这 arraystretch 咋老是拼错/oh
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask}&\sum n\leqslant&k=&\textbf{Special Constraints}&\textbf{Score}\cr\hline
\sf1&2\times10^5&1&\bf A&1\cr\hline
\sf2&20&1&T=1&5\cr\hline
\sf3&5000&1&&5\cr\hline
\sf4&10^5&2&\bf B&15\cr\hline
\sf5&3\times10^5&1&&30\cr\hline
\sf6&2\times10^5&2&\bf A'&4\cr\hline
\sf7&3\times10^5&2&&40\cr\hline
\end{array}
$$
- 特殊性质 $\bf A$ ~~限宽 2.6m~~：保证每棵树只有一个叶子节点（$n\geqslant2$）。
- 特殊性质 $\bf B$ ~~限高 4.5m~~：保证每棵树都为菊花图（根节点有 $n-1$ 个儿子）。
- 特殊性质 $\bf A'$：保证每棵树都是链（每个节点的度数不超过 $2$）。

关于 $\bf A$ 和 $\bf A'$ 的区别：$\bf A'$ 中有可能树的根的度数为 $2$，而 $\bf A$ 中根的度数显然为 $1$。

对于 $100\%$ 的数据，$T \leqslant 4000$，${\color{red}\textbf1}\leqslant n\leqslant 10^5$，$\sum n\leqslant 3\times10^5$，$1 \leqslant m_i \leqslant10^4$，$1\leqslant u, v\leqslant n$，$k\in\{1,2\}$。

---
叶子节点为没有儿子的节点，即除根节点以外在树中的度为 $1$ 的点。

样例输入中为方便阅读加上了空行，实际数据中没有空行。


**【样例 $\bm1-\bm1$ 解释】**


该树如下图所示，边权即边的重量。

![](https://cdn.luogu.com.cn/upload/image_hosting/h5t1mz7x.png)

最优解为选择 $1\to2\to7$ 作为分割路径，不平衡度为 ${\large\vert}(2+19+19)-7{\large\vert}=33$。

如果选择 $1\to2\to6$ 作为分割路径，那么两部分的边的总重之差为 ${\large\vert}(2+19)-(7+514){\large\vert}=500$，不为最小值。

$\color{transparent}\sout{不知道你们发现没有\begin{cases}114+2+19+19=154\\114+514+19+19=666\end{cases}}$

**【样例 $\bm1-\bm2$ 解释】**

该树如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/14a0rhpe.png)

最优解为选择 $1\to7$ 作为分割路径，不平衡度为 ${\large\vert}(4+8+3+6)-(1+7+5+10){\large\vert}=2$。

## 样例 #1

### 输入

```
2 1
7
3 3 2 2 114 4 7
3 5 19 6 19 7 514
0
0
0
0
0

11
5 2 4 3 9 8 1 9 7 11 10
0
3 4 8 5 3 7 2
0
1 6 6
0
0
0
1 10 5
0
0```

### 输出

```
33
2```

## 样例 #2

### 输入

```
2 2
7
3 3 2 2 114 4 7
3 5 19 6 19 7 514
0
0
0
0
0

11
5 2 4 3 9 8 1 9 7 11 10
0
3 4 8 5 3 7 2
0
1 6 6
0
0
0
1 10 5
0
0```

### 输出

```
33 38 0 0 0 0 0
2 0 6 0 0 0 0 0 0 0 0```

# AI分析结果



### 综合分析与结论

题目要求计算树的不平衡度，核心在于快速分割路径并求左右边权和差的最小绝对值。各题解核心思路集中在**DFS预处理+二分优化**或**启发式合并+懒标记维护集合**。最优解法为预处理每个节点的子树信息并二分，时间复杂度为 $O(n \log n)$，适合大规模数据。

---

### 精选题解分析

#### 1. 作者：y_kx_b（★★★★★）
**关键亮点**  
- **思路清晰**：分 $k=1$ 和 $k=2$ 详细分析，针对不同子树结构给出优化。
- **高效预处理**：DFS 预处理每个节点的左右边权和 (`w1`, `w2`)，利用前缀和思想快速计算差值。
- **二分优化**：对每个子树范围内的叶子节点二分查找最小差值，时间复杂度 $O(n \log n)$。
- **代码简洁**：使用链式前向星存储树，结构清晰。

**核心代码**  
```cpp
void dfs0(int u, int W2) {
    dfn[u].x = idx2;
    ww1[u] = W1, ww2[u] = W2;
    if (head[u] == -1) w1[idx2] = W1, w2[idx2++] = W2;
    for (int i = head[u]; ~i; i = ne[i]) {
        int v = to[i];
        dfs0(v, W2 + w[i]);
        W1 += w[i]; // 累计左部分和
    }
    dfn[u].y = idx2;
}
```
**实现思想**  
通过 DFS 预处理每个节点的左右边权和，记录子树叶子范围。对每个节点，二分其子树内叶子，利用前缀和计算差值。

---

#### 2. 作者：_EEA_（★★★★☆）
**关键亮点**  
- **直观模型**：将树分割为链的左/右部分，用 `le(i)` 和 `sum(i)` 表示累积和与路径和。
- **二分策略**：左右部分差值单调，二分零点附近最小值。
- **扩展性**：适用于不同子树结构，通过调整预处理参数处理 $k=2$。

**核心思路**  
预处理每个节点的 `le`（左累积边权）和 `sum`（路径和），分割时差值可快速计算为 `(le左 - sum) - (le右 - le左)`，二分求最小绝对值。

---

#### 3. 作者：tokitsukaze（★★★★☆）
**关键亮点**  
- **启发式合并优化**：用带懒标记的 set 维护子树差值集合，合并时处理整体加减。
- **避免暴力爬树**：通过 DFS 回溯合并子树信息，时间复杂度 $O(n \log^2 n)$。
- **详细代码注释**：提供暴力与优化解法的对比，便于理解优化思路。

**个人心得**  
> “暴力枚举叶子节点的方法导致 $O(n^2)$ 复杂度，必须改用启发式合并。”  
—— 提醒注意时间复杂度陷阱，避免无效枚举。

**核心代码**  
```cpp
void dfs(int x) {
    sum[x] = 0; res[x].clear();
    for (auto to : mp[x]) {
        dfs(to);
        // 合并子树 set 并更新懒标记
        if (res[to].size() > res[x].size()) swap(res[x], res[to]), swap(sum[x], sum[to]);
        for (int val : res[to]) res[x].insert(val + sum[to] - sum[x]);
    }
    res[x].insert(-sum[x]); // 插入当前节点贡献
}
```
**实现思想**  
维护每个节点的差值集合，合并子树时通过懒标记处理整体偏移，二分查找最接近零的值。

---

### 关键思路与技巧总结

1. **DFS预处理+二分法**  
   - 预处理每个节点的子树信息（如边权和、叶子范围）。
   - 二分查找分割点，将问题转化为单调序列最小值问题。

2. **前缀和优化**  
   - 用 `w1` 和 `w2` 分别表示左累积和与路径和，快速计算左右差值。

3. **启发式合并与懒标记**  
   - 处理子树合并时，优先合并较小集合，通过懒标记维护整体偏移量。

---

### 相似题目推荐

1. **[P1099 树网的核](https://www.luogu.com.cn/problem/P1099)**  
   - 求树的直径并最小化偏心距，需预处理路径信息。

2. **[P3177 [HAOI2015] 树上染色](https://www.luogu.com.cn/problem/P3177)**  
   - 树形 DP 结合边权贡献计算，类似子树分割思想。

3. **[P4211 [LNOI2014] LCA](https://www.luogu.com.cn/problem/P4211)**  
   - 利用 DFS 序和差分处理树链查询，练习树结构预处理。

---
处理用时：70.46秒
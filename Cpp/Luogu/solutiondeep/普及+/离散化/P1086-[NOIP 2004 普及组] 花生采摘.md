# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是按照题目要求，先将花生按数量从大到小排序，再通过计算曼哈顿距离模拟采摘过程，并判断在限定时间内是否能够完成采摘并返回。各题解的不同主要体现在数据存储方式和具体实现细节上。
1. **算法要点**：
    - **数据存储**：有的使用结构体数组存储花生位置和数量（如jiangXxin、MC_long_live、yedalong、qhr2023、Leo_Ye、buickboy）；有的使用map和优先队列（_Arahc_）；还有的用稀松矩阵思想（MC_long_live）。
    - **排序**：对花生按数量从大到小排序，多数使用自定义比较函数结合sort（如jiangXxin、MC_long_live、yedalong、qhr2023、Leo_Ye、buickboy），_Arahc_使用优先队列实现排序。
    - **距离计算与判断**：利用曼哈顿距离计算移动时间，并结合采摘时间判断能否在剩余时间内完成采摘并返回。
2. **解决难点**：
    - **时间判断**：准确计算每次采摘所需时间，包括移动和采摘时间，并判断剩余时间是否足够前往下一个花生位置并返回。
    - **数据处理**：选择合适的数据结构存储花生信息，以便于排序和后续操作。

### 所选的题解
- **作者：jiangXxin (5星)**
    - **关键亮点**：思路清晰，代码注释详尽，对曼哈顿距离的应用和采摘过程的模拟描述清晰，变量命名有较好的可读性。
    - **个人心得**：原想用BFS，发现无障碍物后改用曼哈顿距离算法。
    - **重点代码**：
```cpp
// 结构体存储花生信息
struct dire
{
    int x,y,sum;
}stu[N*N];
// 比较函数，按花生数量从大到小排序
bool comp(struct dire a,struct dire b)
{
    return a.sum>b.sum;
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>mp[i][j];
            if(mp[i][j]>0)
            {
                stu[++pn].sum=mp[i][j];
                stu[pn].x=i;
                stu[pn].y=j;
            }
        }
    }
    sort(stu+1,stu+pn+1,comp);
    // 初始化起点
    fx=1;
    fy=stu[1].y;
    k--;
    for(int i=1;i<=pn;i++)
    {
        tm=0;
        ex=stu[i].x;
        ey=stu[i].y;
        // 计算曼哈顿距离
        tm=abs(fx-ex)+abs(fy-ey);
        k--;
        k-=tm;
        if(k>=ex)
        {
            ans+=mp[ex][ey];
            fx=ex;
            fy=ey;
        }
        else
        {
            cout<<ans<<endl;
            return 0;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
核心实现思想：先将花生信息存入结构体数组并按数量排序，从起点开始，依次计算前往每个花生位置的曼哈顿距离，判断剩余时间是否足够采摘并返回，若足够则更新位置和答案，否则结束循环输出答案。
- **作者：_Arahc_ (5星)**
    - **关键亮点**：使用map和优先队列优化数据处理，在输入时就完成花生数量和坐标的绑定与排序，代码简洁高效，同时详细指出了题目中的多个坑点。
    - **重点代码**：
```cpp
int n,m,k,a[23][23],w,s;
map<int,pair<int,int> >c; 
priority_queue<int> q;
int main(){
    n=read(),m=read(),k=read();
    for(register int i=1;i<=n;++i) 
        for(register int j=1;j<=m;++j){
            a[i][j]=read();
            c[a[i][j]]=make_pair(i,j);
            q.push(a[i][j]);
        }
    int j=q.top();q.pop();
    int x=c[j].first;
    int y=c[j].second;
    w+=x+1;
    while(w+x<=k){
        s+=j;
        if(q.empty()) break;
        j=q.top();q.pop();
        w+=abs(c[j].first-x)+abs(c[j].second-y)+1;
        x=c[j].first,y=c[j].second;
    }
    write(s);
    return 0;
}
```
核心实现思想：利用map将花生数量与坐标绑定，优先队列实现花生数量的降序排序。每次从优先队列取出最大花生数量，通过map获取坐标，计算移动和采摘时间，判断是否能继续采摘，能则更新时间和答案。
- **作者：qhr2023 (4星)**
    - **关键亮点**：代码简洁明了，同样使用结构体存储花生信息并排序，逻辑清晰，对采摘过程的模拟和时间判断处理得当。
    - **重点代码**：
```cpp
int n, m, k, cnt, sum, ans;
struct node { int v, x, y; } a[425];
bool cmp (node a, node b) { return a.v>b.v; }
int main () {
    cin >> n >> m >> k;
    for (int i=1; i<=n; ++i)	
        for (int j=1, x; j<=m; ++j) 
            cin >> x,
            a[++cnt]={x, i, j};
    sort(a+1, a+cnt+1, cmp);
    a[0]={0, 0, a[1].y};
    for (int i=1; i<=cnt; ++i) {
        sum+=abs(a[i-1].x-a[i].x)+abs(a[i-1].y-a[i].y)+1;
        if (sum+a[i].x<=k&&a[i].v)
            ans+=a[i].v;
        else
            break;
    }
    cout << ans;
    return 0;
}
```
核心实现思想：输入时将花生信息存入结构体数组，排序后，从第一个花生开始，累加移动和采摘时间，判断是否能在剩余时间内采摘当前花生，能则更新答案，否则结束循环输出答案。

### 最优关键思路或技巧
1. **数据结构选择**：使用map和优先队列（如_Arahc_的题解）可以在输入阶段就完成数据的绑定与排序，简化代码逻辑并提高效率。结构体数组也是常用且直观的数据存储方式，方便进行排序和后续操作。
2. **距离计算**：利用曼哈顿距离准确计算移动时间，结合采摘时间进行剩余时间的判断，确保采摘过程符合题目要求。

### 可拓展之处
同类型题或类似算法套路：此类题目属于模拟与贪心结合的问题，通常给定一些条件和操作规则，要求在限定条件下获取最优解。类似套路包括先对数据进行某种排序（如按价值、数量等），再根据规则模拟操作过程，并不断更新状态和结果。

### 相似知识点洛谷题目
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：涉及数据排序和贪心策略，与本题按花生数量排序并贪心选择采摘类似。
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：同样是根据某种规则（接水时间）对数据进行处理，运用贪心思想解决问题。
3. [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：通过对不同购买方案的计算和比较，选择最优方案，类似于本题对采摘方案的判断和选择。

### 个人心得摘录与总结
1. **jiangXxin**：原计划用BFS，因发现花生地无障碍物改用曼哈顿距离算法，启示在解题时要根据题目条件灵活选择算法。
2. **_Arahc_**：详细列举题目坑点，如采摘耗时、抄近道限制、数组大小、答案为0的情况等，强调仔细审题和全面考虑边界情况的重要性。 

---
处理用时：42.51秒
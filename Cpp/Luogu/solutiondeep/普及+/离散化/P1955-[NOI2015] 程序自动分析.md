# 题目信息

# [NOI2015] 程序自动分析

## 题目描述

在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。

考虑一个约束满足问题的简化版本：假设 $x_1,x_2,x_3,\cdots$ 代表程序中出现的变量，给定 $n$ 个形如 $x_i=x_j$ 或 $x_i\neq x_j$ 的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：$x_1=x_2,x_2=x_3,x_3=x_4,x_4\neq x_1$，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。

现在给出一些约束满足问题，请分别对它们进行判定。

## 说明/提示

【样例解释1】

在第一个问题中，约束条件为：$x_1=x_2,x_1\neq x_2$。这两个约束条件互相矛盾，因此不可被同时满足。

在第二个问题中，约束条件为：$x_1=x_2,x_1 = x_2$。这两个约束条件是等价的，可以被同时满足。

【样例说明2】

在第一个问题中，约束条件有三个：$x_1=x_2,x_2= x_3,x_3=x_1$。只需赋值使得 $x_1=x_2=x_3$，即可同时满足所有的约束条件。

在第二个问题中，约束条件有四个：$x_1=x_2,x_2= x_3,x_3=x_4,x_4\neq x_1$。由前三个约束条件可以推出 $x_1=x_2=x_3=x_4$，然而最后一个约束条件却要求 $x_1\neq x_4$，因此不可被满足。

【数据范围】

所有测试数据的范围和特点如下表所示：

### 勘误：测试点 $8 \sim 10$ 的 $i, j$ 约束为 $1 \leq i, j \leq 10^9$，而不是下图中的 $10^{10}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/aq6f4ym8.png)

## 样例 #1

### 输入

```
2
2
1 2 1
1 2 0
2
1 2 1
2 1 1```

### 输出

```
NO
YES
```

## 样例 #2

### 输入

```
2
3
1 2 1
2 3 1
3 1 1
4
1 2 1
2 3 1
3 4 1
1 4 0
```

### 输出

```
YES
NO```

# AI分析结果

### 综合分析与结论
这些题解主要围绕使用并查集解决程序自动分析中的约束条件判定问题。由于变量值范围大，需离散化处理。核心思路是利用并查集维护相等关系，先处理相等约束条件，再检查不等约束条件是否与之冲突。

多数题解采用离散化结合并查集的常规做法，部分题解在离散化方式上有所创新，如使用哈希表或map优化映射查询。整体上，各题解在思路和代码实现上有一定差异，但基本围绕上述核心展开。

### 所选的题解
- **作者：追梦_Chen (赞：219)  星级：5星**
    - **关键亮点**：思路清晰，详细阐述并查集的Get和Merge操作，对离散化步骤有清晰的三步走战略说明，代码简洁明了，注释丰富。
    - **个人心得**：强调并查集要初始化，且指出开10^9大小数组会空间超限，亲身经历离散化的必要性。
    - **重点代码**：
```cpp
int get(int x){
    if(x==fa[x])	return x;
    return fa[x]=get(fa[x]);//路径压缩
}
void merge(int x,int y){
    fa[get(x)]=get(y);
} 
```
核心实现思想：通过递归实现并查集的查找操作，并在查找过程中进行路径压缩；合并操作则是将两个元素所在集合合并。
- **作者：Virvan (赞：57)  星级：4星**
    - **关键亮点**：提出利用Hash表维护映射以优化离散化，实现O(1)查询，代码中有详细的Hash表构造和操作过程，且对代码性能进行对比分析。
    - **个人心得**：强调初始化的重要性，因并查集初始化范围错误导致WA，分享调试经历。
    - **重点代码**：
```cpp
int map(int i,int j,bool k)
{
    int x,y,ok=1;
    int a = i % mod, b = j % mod;
    if(!hash[a].empty()){
        for(int l = 0; l < hash[a].size(); l++)
            if(i==hash[a][l].real) x = hash[a][l].map,ok = 0;
        if(ok) hash[a].push_back((node){i,++tot}),x = tot;
    }
    else hash[a].push_back((node){i,++tot}),x = tot;
    ok = 1;
    if(!hash[b].empty()){
        for(int l = 0; l < hash[b].size(); l++)
            if(j==hash[b][l].real) y = hash[b][l].map,ok = 0;
        if(ok) hash[b].push_back((node){j,++tot}),y = tot;
    }
    else hash[b].push_back((node){j,++tot}),y = tot;
    return ask(x,y,k); 
}
```
核心实现思想：通过取模运算确定元素在哈希表中的位置，遍历链表处理冲突，实现元素到映射值的转换，并调用询问函数处理相关操作。
- **作者：览遍千秋 (赞：54)  星级：4星**
    - **关键亮点**：对并查集的原理和操作（find、merge、路径压缩）进行详细讲解，对离散化概念解释通俗易懂，代码结构清晰，注释详细。
    - **重点代码**：
```cpp
int find(int x)
{
    if(f[x]==x) return x;
    else return find(f[x]);
}
void merge(int a,int b)
{
    f[find(a)]=find(b);
}
int find(int x)
{
    if(f[x]==x) return x;
    else return f[x]=find(f[x]);
}
```
核心实现思想：原始的查找函数通过递归找到根节点；合并函数将两个元素的根节点相连；优化后的查找函数在查找过程中进行路径压缩，提高后续查找效率。

### 最优关键思路或技巧
- **数据结构**：利用并查集维护变量的相等关系，高效处理具有传递性的约束条件。
- **离散化技巧**：通过排序、去重和二分查找（如unique和lower_bound函数组合），或使用哈希表、map等方式，将大范围内的变量值映射到较小范围，降低空间复杂度。
- **算法优化**：在并查集中使用路径压缩和按秩合并优化查找和合并操作的时间复杂度；通过先处理相等约束条件，再处理不等约束条件，减少不必要的判断。

### 可拓展之处
同类型题或类似算法套路：此类问题可拓展到其他需要处理具有传递性关系和冲突检测的场景，如判断图中顶点的连通性与非连通性约束、化学分子结构中原子连接关系的判定等。类似算法套路是先利用合适的数据结构（如并查集）维护一种关系，再处理与之相对的关系并检测冲突。

### 推荐题目
- **P1551 亲戚**：经典的并查集应用题目，通过给定的亲戚关系判断两个人是否为亲戚。
- **P3367 【模板】并查集**：并查集模板题，用于巩固并查集的基本操作和应用。
- **P1197 [JSOI2008]星球大战**：结合并查集和图论知识，在动态图中处理连通性问题，有一定难度和拓展性。 

---
处理用时：29.68秒
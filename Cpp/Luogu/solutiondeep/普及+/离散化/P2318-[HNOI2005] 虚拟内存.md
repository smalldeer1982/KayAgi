# 题目信息

# [HNOI2005] 虚拟内存

## 题目描述

操作系统中一种重要的存储管理技术就是虚拟内存技术。操作系统中允许进程同时运行，也就是并行。每个进程都有其相对独立的数据块（进程运行的过程中将对其进行读写操作）。理想的情况下，这些数据块都应该存放在内存中，这样才能实现高效的读写操作。但事实上，内存的容量有限，每个进程只能把一部分数据放在内存中，为了解决这个矛盾，提出了虚拟内存技术。

虚拟内存技术的基本原理是：对进程而言，内存空间是无限大的，进程可以随意地读写数据，而对操作系统内部而言，利用外存来模拟扩充的内存空间，进程要求访问某个内存单元时，交由操作系统处理，操作系统首先在内存中查找该单元是否存在，如果存在，查找成功，否则转入外存查找（一定存在于外存中）。

就存储介质的物理性质而言，内存的访问速度相对于外存要快得多，因此对于每个进程来说操作系统应该把那些访问次数较多的数据存放在内存中，而把那些访问次数很少的数据放在外存中。如何选择内存中暂留的数据是一个很值得研究的问题，下面介绍一个内存管理中比较常用的算法：

内存中的数据以页为基本存储单位，进程的读写操作都针对页来进行。实际内存空间被分割成n页，虚拟内存空间的页数往往要多得多。某一时刻，进程需要访问虚存编号为P的页，该算法的执行步骤如下：

a.    首先在内存中查找，如果该页位于内存中，查找成功，转d，否则继续下面的操作；

b.    寻找内存中是否存在空页（即没有装载任何数据页的页面），若有，则从外存中读入要查找页，并将该页送至内存中的空页进行存储，然后转d，否则继续下面的操作；

c.    在内存中寻找一个访问次数最少的页面（如果存在多个页面的访问次数同时为最少，则选取最早读入数据进入内存的那个页面），从外存中读入要查找页，替换该页。

d.    结束

所谓访问次数是指从当前页面进入内存到该时刻被访问的次数，如果该页面以前进入过内存并被其它页面替换，那么前面的访问次数不应计入这个时刻的访问次数中。

你的任务是设计一个程序实现上述算法。

测试数据将会提供 $m$ 条读写内存的命令，每条命题提供要求访问的虚拟内存页的编号 $P$ 。你的程序要求能够模拟整个 $m$ 条命令的全部执行过程，所有的命令是按照输入的先后执行的，最开始的时候内存中的 $n$ 页全为空。



## 样例 #1

### 输入

```
3 8 

1

1

2

3

4

2

5

4

```

### 输出

```
1```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何实现虚拟内存算法展开，采用的数据结构包括优先队列、map、set、线段树等。优先队列相关题解通过优先队列维护内存页的访问次数和时间，实现较为简洁高效；线段树相关题解利用线段树维护内存页的访问次数和时间等信息，以查询和修改内存页状态，但代码相对复杂。从思路清晰度、代码可读性和优化程度等方面综合考虑，优先队列的解法整体表现较好。
  - 作者：liunian (5星)
    - 关键亮点：仅用一个优先队列解决问题，运行速度快。通过离散化处理大编号数据，代码精简。
    - 重点代码及核心思想：
```cpp
struct node {
    int xu,t;
    bool operator<(const node &a)const {
        if(t==a.t)return xu>a.xu;
        return t>a.t;
    }
};
priority_queue<node>q;
// 结构体node定义优先队列元素，按访问次数t和时间xu排序
for(int i=1; i<=m; i++) {
    a[i]=lower_bound(b+1,b+k+1,a[i])-b;
    if(num[a[i]])num[a[i]]++,ans++;
    else if(tot<n)tot++,num[a[i]]=1;
    else {
        node res=q.top();
        q.pop();
        while(num[a[res.xu]]!=res.t)res=q.top(),q.pop();
        num[a[i]]++,num[a[res.xu]]=0;
    }
    q.push((node){i,num[a[i]]});
}
// 遍历操作，若内存未排满直接放入；已排满则取队首元素，直到找到可放置位置
```
  - 作者：Lysea (4星)
    - 关键亮点：采用MAP + 优先队列的方法，思路直观，代码量比线段树少。通过延迟处理优先队列中访问次数的更新，减少频繁的删除与插入操作。
    - 重点代码及核心思想：
```cpp
struct node{
    int v,t,idx;
    bool operator<(const node& a)const{
        if(v!=a.v) return v>a.v;
        return t>a.t;
    }
};
map<int,int>h;
priority_queue<node>q;
for(int i=1,a;i<=m;i++){
    cin>>a;
    if(h[a]){
        ans++;
        h[a]++;
    }
    else if(q.size()==n){
        node k=q.top();
        q.pop();
        while(h[k.idx]!=k.v){
            k.v=h[k.idx];
            q.push(k);
            k=q.top();
            q.pop();
        }
        h[k.idx]=0,h[a]=1;
        q.push(node{1,i,a});
    }else{
        q.push(node{1,i,a});
        h[a]=1;
    }
} 
// 读入编号，若在内存中则更新访问次数；内存满且不在内存中，延迟处理优先队列找到最小访问次数页替换
```
  - 作者：jiaangk (4星)
    - 关键亮点：使用结构体搭配map和priority_queue维护内存，思路清晰，代码简短。通过map判断元素是否在内存中，利用priority_queue寻找内存中出现次数最少的元素。
    - 重点代码及核心思想：
```cpp
struct node{
    int a,b;
};
struct noded{
    int a,b,c;
};
bool operator <(noded a,noded b){
    return a.b==b.b? a.c<b.c:a.a>b.a;
}
map<int,node> p;
priority_queue<noded> q;
while(m--){
    scanf("%d",&cache);
    if(p[cache].a==1) ++p[cache].b,++ans;
    else {
        noded pp;
        p[cache].a=1;
        pp.b=cache;
        pp.a=1;
        pp.c=m;
        if(q.size()<n) q.push(pp); else {
            noded ppp;
            mark:ppp=q.top();
            q.pop();
            if(p[ppp.b].b>0){
                ppp.a+=p[ppp.b].b;
                p[ppp.b].b=0;
                q.push(ppp);
                goto mark;
            }
            p[ppp.b].a=0;
            q.push(pp);
        }
    }
}
// 读入数据，map判断是否在内存，在则更新次数；不在则判断内存是否满，满则找最小访问次数页替换
```
• 最优关键思路或技巧：使用优先队列维护内存页的访问次数和时间，利用其自动排序特性，快速找到访问次数最少且最早进入内存的页面。同时结合map记录页面状态，减少查找时间。延迟处理优先队列中元素的更新，避免频繁的删除与插入操作，优化时间复杂度。
• 可拓展之处：此类题属于内存管理模拟类问题，类似算法套路包括使用不同数据结构优化模拟过程，如用堆优化优先队列操作，或用平衡树代替map实现更快的查找与修改。同类型题通常围绕资源分配、调度算法等场景展开模拟。
• 相似知识点洛谷题目：
  - P1801 黑匣子：涉及优先队列和数据的动态处理。
  - P3378 【模板】堆：考察堆（优先队列）的基本操作。
  - P2672 推销员：结合优先队列和贪心策略解决问题。
• 个人心得摘录与总结：
  - liunian：排序优先级设置时，大于小于符号弄反导致调试数小时，强调了排序条件正确性的重要性。
  - jiaangk：认为部分用户将此题难度定位过高，实际为较简单的STL应用，反映出对题目难度的个人判断差异。 

---
处理用时：31.73秒
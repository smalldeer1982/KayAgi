# 题目信息

# 同花顺

## 题目背景

所谓同花顺，就是指一些扑克牌，它们花色相同，并且数字连续。


## 题目描述

现在我手里有 $n$ 张扑克牌，但它们可能并不能凑成同花顺。我现在想知道，最少更换其中的多少张牌，我能让这 $n$ 张牌都凑成同花顺？

## 说明/提示

- 对于 $30\%$ 的数据，$n \le 10$；
- 对于 $60\%$ 的数据，$n \le 10^{5}$，$ 1 \le a_{i} \le 10^{5}$，$1 \le b_{i} \le n$；
- 对于 $100\%$ 的数据，$n \le 10^{5}$，$1 \le a_{i}, b_{i} \le 10^{9}$；

## 样例 #1

### 输入

```
5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
0```

## 样例 #2

### 输入

```
5
1 9
1 10
2 11
2 12
2 13```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是通过反向思考，将求最少更换牌数转化为求最长同花顺长度，再用总牌数减去该长度。具体算法要点和难点解决方式如下：
1. **排序与去重**：所有题解都先对牌按花色和数字排序，去除花色和数字都相同的牌，以简化后续处理。
2. **计算最长同花顺长度**：
    - **枚举区间法**：通过枚举所有可能的区间，判断区间内牌是否满足同色且长度符合条件，找出最长区间。如Merak、shuri001、天依赛高！、rui_er、地表最强男人、封禁用户的题解。
    - **队列维护法**：用队列维护以每张牌为结尾的同花顺中的牌，遇到新花色清空队列，否则删除不满足条件的队首元素，记录队列最大长度。如Tethys、Youngsc、quantum11的题解。
    - **二分查找法**：利用排序后花色和数字的有序性，通过二分查找确定以每张牌结尾的最长同花顺。如Konnyaku_LXZ的题解。

综合思路清晰度、代码可读性、优化程度等方面，以下题解质量较高：
1. **Merak的题解**：★★★★
    - **关键亮点**：思路阐述详细，从反向思考到排序规则、去重处理、求最长序列的条件判断都解释得很清楚，代码注释丰富，易于理解。
    - **个人心得**：作者表示自己一开始没看懂其他题解，结合老师讲解和他人代码才完成，强调了理解思路的过程。
    - **核心代码**：
```cpp
bool rule(const node &s1,const node &s2)
{
    if(s1.x==s2.x) return s1.y<s2.y;
    else return s1.x<s2.x;
} 
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i].x>>a[i].y;
    }
    sort(a+1,a+n+1,rule);
    for(int i=1;i<=n;i++)
    {
        if(a[i-1].x!=a[i].x||a[i-1].y!=a[i].y)
        {
            b[++cnt]=a[i];
        } 
    }
    for(int i=1;i<=cnt;i++)
    {
        temp=0;
        for(int j=i;j>=1;j--)
        {
            if(b[i].x==b[j].x&&b[i].y-b[j].y+1<=n)
            {
                temp++; 
            }
            else break;
        }
        if(temp>ans) ans=temp;
    }
    cout<<n-ans<<endl; 
    return 0;
}
```
    - **核心思想**：定义排序规则rule，先按花色再按数字排序。去重后，枚举所有区间，判断区间内牌同色且长度符合条件，更新最长同花顺长度。
2. **Tethys的题解**：★★★★
    - **关键亮点**：思路清晰，简洁地阐述了反向思考的过程，利用队列维护同花顺的实现方法简洁高效，代码结构清晰。
    - **核心代码**：
```cpp
bool cmp(node op, node opp){
    if(op.x == opp.x) return op.y < opp.y;
    return op.x < opp.x;
}
queue<int> q;
void cl(){
    while(!q.empty()) q.pop();
}
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++) scanf("%d %d", &a[i].x, &a[i].y);
    sort(a + 1, a + n + 1, cmp);
    for(int i = 1; i <= n; i ++){
        if(a[i].x == a[i - 1].x && a[i].y == a[i - 1].y) continue;
        b[++ cnt] = a[i];
    }

    for(int i = 1; i <= cnt; i ++){
        if(b[i].x!= b[i - 1].x) cl();
        while(q.size() && b[i].y - q.front() >= n) q.pop();
        q.push(b[i].y);
        ans = max(ans, (int)q.size()); 
    }

    ans = (n - ans);
    printf("%d\n", ans); 
    return 0;
} 
```
    - **核心思想**：定义cmp函数排序，去重后，遍历每张牌，根据花色是否相同处理队列，更新最长同花顺长度。
3. **Konnyaku_LXZ的题解**：★★★★
    - **关键亮点**：提出独特的二分做法，利用排序后的有序性进行两次二分查找，优化了时间复杂度，代码实现简洁明了。
    - **核心代码**：
```cpp
void Solve(){
    sort(a+1,a+1+N,cmp);
    b[++cnt]=a[1];
    for(int i=2;i<=N;++i){
        if(a[i].x!=a[i-1].x||a[i].y!=a[i-1].y) b[++cnt]=a[i];
        else ++add;
    }
    for(int i=1;i<=cnt;++i) c[i]=b[i].x,v[i]=b[i].y; 
    f[1]=1;
    for(int i=2;i<=cnt;++i){
        int l=lower_bound(c+1,c+i+1,c[i])-c;
        int pos=lower_bound(v+l,v+i,v[i]-N+1)-v;
        f[i]=i-pos+1;
        Ans=max(Ans,f[i]);
    }
    Ans=cnt-Ans+add;
}
```
    - **核心思想**：排序去重后，通过二分查找确定同花色左端点和最小可凑成同花顺的位置，更新最长同花顺长度。

### 最优关键思路与技巧
1. **反向思考**：将求最少更换牌数转化为求最长同花顺长度，简化问题。
2. **排序与去重**：对牌按花色和数字排序并去重，为后续计算提供便利。
3. **利用有序性**：如二分查找法利用排序后的有序性优化查找过程，提高效率。

### 可拓展思路
此类题目属于组合优化问题，类似套路可用于处理需要在给定元素集合中寻找满足特定条件的最大/最小子集问题。例如，在一些涉及序列、集合的题目中，通过排序、去重后利用双指针、二分查找等方法寻找最优子集。

### 相似知识点洛谷题目
1. **P1106 删数问题**：通过贪心策略，在给定数字序列中删除指定数量数字，使剩下数字组成的数最小，涉及排序和贪心思想。
2. **P1090 [NOIP2004 提高组] 合并果子**：利用优先队列实现贪心算法，解决合并果子的最小代价问题，与本题在利用数据结构优化算法上有相似之处。
3. **P1223 排队接水**：通过排序和贪心策略，解决排队接水时间最短问题，与本题思路类似，都是在给定条件下寻找最优解。 

---
处理用时：34.04秒
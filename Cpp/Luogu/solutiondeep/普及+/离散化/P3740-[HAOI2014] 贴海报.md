# 题目信息

# [HAOI2014] 贴海报

## 题目描述

Bytetown 城市要进行市长竞选，所有的选民可以畅所欲言地对竞选市长的候选人发表言论。为了统一管理，城市委员会为选民准备了一个张贴海报的 electoral 墙。

张贴规则如下：

1. electoral 墙是一个长度为 $N$ 个单位的长方形，每个单位记为一个格子；

2. 所有张贴的海报的高度必须与 electoral 墙的高度一致的；

3. 每张海报以 `A B` 表示，即从第 $A$ 个格子到第 $B$ 个格子张贴海报；

4. 后贴的海报可以覆盖前面已贴的海报或部分海报。

现在请你判断，张贴完所有海报后，在 electoral 墙上还可以看见多少张海报。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/5209.png) 

**约束条件**

$10\le N \le 10000000,1\le M\le 1000,1\le A_i \le B_i \le 10000000$

所有的数据都是正整数，数据之间有一个空格。

## 样例 #1

### 输入

```
100 5
1 4
2 6
8 10
3 4
7 10
```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何解决海报覆盖后可见数量的问题，采用了多种算法和思路。常见算法包括线段树、浮水法、珂朵莉树、暴力法等。各算法在思路、实现复杂度和优化程度上有所不同。线段树通过维护区间染色状态判断可见海报；浮水法利用递归上浮线段判断可见部分；珂朵莉树通过维护相同元素区间简化操作；暴力法则直接模拟海报覆盖过程。

### 所选的题解
- **作者：SovietPower✨**  星级：4星
    - **关键亮点**：提供线段树和浮水法两种解法，思路清晰，代码注释详细。
    - **个人心得**：无
    - **重点代码 - 线段树**：
```cpp
void Modify(int l, int r, int rt, int L, int R)
{
    if(colored[rt]) return;
    if(L <= l && r <= R)
    {
        flag = 1;colored[rt] = 1;
        return;
    }
    int m = (l + r) >> 1;
    if(L <= m) Modify(l, m, rt << 1, L, R);
    if(m < R) Modify(m + 1, r, rt << 1 | 1, L, R);
    PushUp(rt);
}
```
核心思想：通过Modify函数对线段树区间进行修改，若当前区间已染色则返回，否则判断是否完全覆盖，是则标记染色并返回，否则递归处理子区间。
    - **重点代码 - 浮水法**：
```cpp
void Solve(int a, int b, int now)
{
    if(vis[cur]) return;
    while(now <= m && (a >= B[now] || b <= A[now]))
      ++now;
    if(now > m)
      ++Ans,vis[cur] = 1;
    if(a < A[now] && A[now] < b) Solve(a, A[now], now + 1);
    if(b > B[now] && B[now] > a) Solve(B[now], b, now + 1);
}
```
核心思想：通过Solve函数递归处理线段，判断当前线段是否被遮挡，未遮挡则上浮并判断是否可见，若被遮挡则切割线段继续递归。
- **作者：心灵间的跳跃**  星级：4星
    - **关键亮点**：详细讲解线段树解题思路，包括区间树和点树的区别及离散化处理，对线段树操作解释细致。
    - **个人心得**：在老师和同学帮助下理解线段树解题方法。
    - **重点代码 - 离散化**：
```cpp
for(int j = 1; j <= m; j++)     
{
    scanf("%d%d", &b[j].l, &b[j].r); 
    b[j].r++;
    k[++id] = b[j].l;
    k[++id] = b[j].r;
} 
sort(k + 1, k + 2 * m + 1);
int num = unique(k + 1, k + 2 * m + 1) - k;
```
核心思想：将海报区间端点记录到数组k，排序后去重，实现离散化，减少数据规模。
    - **重点代码 - 插入操作**：
```cpp
void ins(int rt, int l, int r, int k)
{
    if(l >= a[rt].r || r <= a[rt].l)    
        return;
    if(l <= a[rt].l && a[rt].r <= r)
    {
        a[rt].c = k;         
        return;
    }    
    pushd(rt);
    ins(rt << 1, l, r, k);
    ins(rt << 1 | 1, l, r, k);
    pushup(rt);
}
```
核心思想：向线段树中插入区间，若区间无交集则返回，若完全覆盖则染色，否则递归处理子区间，并更新父节点信息。
- **作者：Flanksy**  星级：4星
    - **关键亮点**：提出并查集解法，利用并查集维护序列连通性，通过反转时间轴离线求解，思路新颖。
    - **个人心得**：无
    - **重点代码 - 并查集操作**：
```cpp
int ask(int x)
{
    while(f[x]!= x) v[++top] = x, x = f[x];
    while(top) f[v[top]] = x, --top;
    return x;
}
for(int i = m; i >= 1; i--)
    for(int j = ask(s[i].r); j >= s[i].l; j = ask(j - 1))
        c[j] = i, f[j] = j - 1;
```
核心思想：通过ask函数实现路径压缩的并查集查找，从后往前染色，将元素合并到左边第一个未染色元素所在集合，并记录颜色。

### 最优关键思路或技巧
1. **逆序处理**：许多解法采用从后往前处理海报的方式，利用后贴海报覆盖先贴海报的特性，简化判断可见海报的过程。
2. **离散化**：针对数据范围大的问题，通过离散化减少数据规模，如对海报区间端点排序去重，在不改变问题本质的前提下降低算法复杂度。
3. **数据结构优化**：如线段树通过维护区间染色状态高效判断海报可见性；并查集通过维护序列连通性简化染色操作。

### 同类型题或类似算法套路
同类型题通常涉及区间覆盖、染色问题。常见算法套路包括：
1. **线段树**：用于高效处理区间查询和修改操作，通过维护区间信息（如是否染色）解决问题。
2. **离散化**：当数据范围大但实际有效数据较少时，通过离散化减少数据规模，降低时间和空间复杂度。
3. **逆序处理**：对于具有后操作覆盖前操作性质的问题，逆序处理可简化逻辑。

### 推荐题目
1. **P1828 [USACO3.4] 香甜的黄油 Sweet Butter**：涉及图论和距离计算，可通过类似离散化和贪心思路解决。
2. **P3372 【模板】线段树 1**：经典线段树模板题，用于巩固线段树区间修改和查询操作。
3. **P2824 [HEOI2016/TJOI2016]排序**：综合考察排序和区间操作，可运用类似离散化和数据结构优化的方法。 

---
处理用时：32.34秒
# 题目信息

# [省选联考 2020 B 卷] 幸运数字

## 题目描述

为庆祝疫情防治取得重大进展，某商场举行酬宾活动，给顾客一些优惠额度，规则如下：

1. 每位顾客可以任意选择一个整数作为自己的幸运数字。
2. 每位顾客的初始优惠额度为 $0$ 元。
3. 商场有 $n$ 个奖励条件，对应不同的奖励额度 $w_i$。
4. 每位顾客需要依次比对这 $n$ 个奖励条件，如果该位顾客选择的幸运数字满足第 $i$ 个条件，那么他的优惠额度就会**异或**上这个条件所对应的奖励额度。

奖励条件共有三种，假设顾客选择的幸运数字为 $x$：

1. 区间型条件，其有两个参数 $L$ 与 $R$，满足条件为 $L \le x\le R$。保证 $L < R$。
2. 相等型条件，其有一个参数 $A$，满足条件为 $x = A$。
3. 不等型条件，其有一个参数 $B$，满足条件为 $x \neq B$。

小炎同学获知了所有奖励条件的信息，他希望知道一位顾客能够得到的最大优惠额度以及对应的幸运数字是多少，请你帮他计算。


## 说明/提示

**样例解释**

幸运数字 $-3$ 满足奖励条件 $2, 3, 4$，奖励额度为 $3\oplus 64\oplus 156 = 223$，其中 $\oplus$ 表
示异或运算。

**数据范围与约定**

$20\%$ 的数据满足：$n, |L|, |R|, |A|, |B| \le 1000$。  
$40\%$ 的数据满足：$n\le 1000$。  
$100\%$ 的数据满足：$1\le n\le 10^5, |L|, |R|, |A|, |B|\le 10^9, 1\le w_i\le 10^9$。


## 样例 #1

### 输入

```
4
1 -100 -80 37
2 -3 3
3 4 64
1 -10 1024 156```

### 输出

```
223 -3```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均是通过离散化处理较大值域，再结合差分或线段树等方法解决问题。由于题目中代表范围的数据在 \(10^9\) 级别，而 \(n\leq 10^5\)，离散化能将值域映射到较小范围，便于后续处理。
1. **思路方面**：多数题解将三种条件转化为区间修改问题。如区间型条件 \([L, R]\) 异或 \(w\)；相等型条件 \([A, A]\) 异或 \(w\)；不等型条件 \((-\infty, B - 1]\) 和 \([B + 1, +\infty)\) 异或 \(w\)。
2. **算法要点**：离散化时，除了将 \(L, R, A, B\) 等端点值加入离散化数组，还需考虑端点附近值（如 \(L - 1, R + 1, A - 1, A + 1, B - 1, B + 1\)）以及特殊值（如 \(0, \pm\infty\)），以确保答案的正确性。之后通过差分或线段树来维护区间异或操作。
3. **解决难点**：难点在于如何全面考虑所有可能影响答案的点，避免遗漏。同时，要理解异或运算的性质（如 \(a \oplus a = 0\)），利用其简化计算。

综合质量评估，以下3篇题解相对较好：
1. **作者：VenusM1nT (赞：12)**
    - **星级**：5星
    - **关键亮点**：思路清晰，先阐述离散化原因，再详细说明离散化数组应加入的特殊值及理由，最后结合差分解决问题，代码简洁明了。
    - **个人心得**：无
    - **重点代码及核心思想**：
```cpp
// 离散化数组及相关变量定义
int n,opt[MAXN],l[MAXN],r[MAXN],val[MAXN],pos[MAXN<<2],tot,ans,Ans,cnt[MAXN<<2];
int main() {
    scanf("%d",&n);
    pos[++tot]=0;
    // 处理每个条件，将相关值加入离散化数组
    for(reg int i=1;i<=n;i++) {
        scanf("%d",&opt[i]);
        if(opt[i]==1) {
            scanf("%d %d %d",&l[i],&r[i],&val[i]);
            pos[++tot]=l[i]; pos[++tot]=r[i];
            pos[++tot]=l[i]-1; pos[++tot]=r[i]+1;
        } else {
            scanf("%d %d",&l[i],&val[i]);
            pos[++tot]=l[i]; pos[++tot]=l[i]-1; pos[++tot]=l[i]+1;
        }
    }
    // 离散化
    sort(pos+1,pos+tot+1);
    tot=unique(pos+1,pos+tot+1)-pos-1;
    // 差分处理
    for(reg int i=1;i<=n;i++) {
        l[i]=lower_bound(pos+1,pos+tot+1,l[i])-pos;
        if(opt[i]==1) {
            r[i]=lower_bound(pos+1,pos+tot+1,r[i])-pos;
            cnt[l[i]]^=val[i];
            cnt[r[i]+1]^=val[i];
        } else if(opt[i]==2) {
            cnt[l[i]]^=val[i];
            cnt[l[i]+1]^=val[i];
        } else if(opt[i]==3) {
            cnt[1]^=val[i];
            cnt[l[i]]^=val[i];
            cnt[l[i]+1]^=val[i];
        }
    }
    // 找最优解
    ans=cnt[1];
    Ans=1;
    for(reg int i=2;i<=tot;i++) {
        cnt[i]^=cnt[i-1];
        if(cnt[i]>ans) {
            ans=cnt[i];
            Ans=i;
        } else if(cnt[i]==ans && abs(pos[i])<=abs(pos[Ans])) Ans=i;
    }
    printf("%d %d\n",ans,pos[Ans]);
    return 0;
}
```
核心思想是先将所有与条件相关的值加入离散化数组，然后进行离散化。利用差分对每个离散化后的点进行异或操作，最后遍历找到最大优惠额度及对应的幸运数字。
2. **作者：白木偶君 (赞：12)**
    - **星级**：5星
    - **关键亮点**：同样思路清晰，将三种条件转化为区间修改后，利用线段树离散化维护。对可能出现最优解的点分析详细，并给出简要证明。
    - **个人心得**：省选时因数组开小导致只有35分，提醒注意数据结构空间大小。
    - **重点代码及核心思想**：
```cpp
// 线段树相关结构体及变量定义
struct Seg{
    int l,r,sum;
    #define l(x) tree[x].l
    #define r(x) tree[x].r
    #define sum(x) tree[x].sum
}tree[N<<2];
#define ls p<<1
#define rs p<<1|1
#define mid ((l(p)+r(p))>>1)
void build(int p,int l,int r) {
    l(p)=l,r(p)=r;
    if(l(p)==r(p))return;
    build(ls,l,mid);
    build(rs,mid+1,r);
}
void update(int p,int l,int r,int d) {
    if(l<=l(p)&&r(p)<=r){ sum(p)^=d; return; }
    if(l<=mid)update(ls,l,r,d);
    if(r>mid)update(rs,l,r,d);
}
int ans[N<<2];
void query(int p,int d) {
    d^=sum(p);
    if(l(p)==r(p)){ ans[l(p)]=d; return; }
    query(ls,d),query(rs,d);
}
// 主函数
signed main() {
    int n=read();
    b[++len]=-1e9; b[++len]=0; b[++len]=1e9;
    // 处理每个条件，将相关值加入离散化数组
    for(int i=1,t,l,r,w,x;i<=n;i++) {
        t=read();
        if(t==1) {
            l=read(),r=read(),w=read();
            b[++len]=l,b[++len]=r;
            b[++len]=l-1,b[++len]=r+1;
        } else {
            x=read(),w=read();
            b[++len]=x;
            b[++len]=x-1;
            b[++len]=x+1;
        }
        e[i]=(node){t,l,r,w,x};
    }
    // 离散化
    sort(b+1,b+1+len);
    len=unique(b+1,b+1+len)-b-1;
    build(1,1,len);
    // 线段树更新
    for(int i=1,t,l,r,w,x;i<=n;i++) {
        t=e[i].t;
        if(t==1) {
            l=e[i].l,r=e[i].r,w=e[i].w;
            l=lb(b+1,b+1+len,l)-b;
            r=lb(b+1,b+1+len,r)-b;
            update(1,l,r,w);
        } else if(t==2) {
            x=e[i].x,w=e[i].w;
            x=lb(b+1,b+1+len,x)-b;
            update(1,x,x,w);
        } else if(t==3) {
            x=e[i].x,w=e[i].w;
            x=lb(b+1,b+1+len,x)-b;
            if(x>1)update(1,1,x-1,w);
            if(x<len)update(1,x+1,len,w);
        }
    }
    // 查询并处理答案
    query(1,0);
    int Ans=0;
    for(int i=1;i<=len;i++)
        if(ans[i]>Ans) {
            Ans=ans[i];
            sxr.clear();
            sxr.pb(b[i]);
        } else if(ans[i]==Ans)sxr.pb(b[i]);
    printf("%lld ",Ans);
    Ans = -(1ll<<62);
    for(int i=0;i<sxr.size();i++) {
        if(abs(sxr[i])<abs(Ans))Ans=sxr[i];
        else if(abs(sxr[i])==abs(Ans))Ans=max(Ans,sxr[i]);
    }
    printf("%lld\n",Ans);
}
```
核心思想是先将条件相关值离散化，构建线段树。通过线段树的更新操作维护区间异或，最后查询叶子节点得到各点异或值，找出最大优惠额度及对应幸运数字。
3. **作者：hfctf0210 (赞：6)**
    - **星级**：4星
    - **关键亮点**：指出可以 \(O(n)\) 直接过（离散化 & 排序除外），强调线段树在此题是大材小用，利用差分解决问题，代码简洁。
    - **个人心得**：因没看清最大值相同时输出啥而调了N遍，提醒注意题目细节。
    - **重点代码及核心思想**：
```cpp
// 相关变量定义
const int N=1e5+7,inf=1e9;
int n,cnt,ans1,ans2,tp[N],a[N],b[N],c[N],d[N<<2],ans[N<<2];
int main() {
    scanf("%d",&n);
    d[++cnt]=-inf,d[++cnt]=inf,d[++cnt]=0;
    // 处理每个条件，将相关值加入离散化数组
    for(int i=1;i<=n;i++) {
        scanf("%d",&tp[i]);
        if(tp[i]==1)scanf("%d%d%d",&a[i],&b[i],&c[i]),d[++cnt]=a[i],d[++cnt]=b[i],d[++cnt]=a[i]-1,d[++cnt]=b[i]+1;
        else scanf("%d%d",&a[i],&c[i]),d[++cnt]=a[i]-1,d[++cnt]=a[i],d[++cnt]=a[i]+1;
    }
    // 离散化
    sort(d+1,d+cnt+1);
    cnt=unique(d+1,d+cnt+1)-d-1;
    // 差分处理
    for(int i=1;i<=n;i++) {
        a[i]=lower_bound(d+1,d+cnt+1,a[i])-d;
        if(tp[i]==1)b[i]=lower_bound(d+1,d+cnt+1,b[i])-d,ans[a[i]]^=c[i],ans[b[i]+1]^=c[i];
        else if(tp[i]==2)ans[a[i]]^=c[i],ans[a[i]+1]^=c[i];
        else ans[1]^=c[i],ans[a[i]]^=c[i],ans[a[i]+1]^=c[i];
    }
    // 找最优解
    ans1=ans[1],ans2=1;
    for(int i=2;i<=cnt;i++) {
        ans[i]^=ans[i-1];
        if(ans[i]>ans1)ans1=ans[i],ans2=i;
        else if(ans[i]==ans1&&abs(d[i])<=abs(d[ans2]))ans2=i;
    }
    printf("%d %d",ans1,d[ans2]);
}
```
核心思想是将所有与条件相关的值加入离散化数组，离散化后利用差分对每个离散化后的点进行异或操作，最后遍历找到最大优惠额度及对应的幸运数字。

### 最优关键思路或技巧
1. **离散化技巧**：充分考虑端点及端点附近值，将 \(L - 1, R + 1, A - 1, A + 1, B - 1, B + 1\) 以及特殊值 \(0, \pm\infty\) 加入离散化数组，确保不遗漏可能的最优解。
2. **利用异或性质**：利用 \(a \oplus a = 0\) 的性质，通过差分或线段树维护区间异或操作，简化计算过程。

### 可拓展之处
此类题目属于区间操作与值域处理相结合的问题。相似算法套路为遇到较大值域和相对较小点数时，优先考虑离散化，再根据具体操作选择合适的数据结构（如差分、线段树等）维护。同类型题如区间异或和查询、区间修改与单点查询等。

### 相似知识点洛谷题目
1. **P3372 【模板】线段树 1**：基础的线段树区间修改与单点查询题目，可巩固线段树操作。
2. **P1083 [NOIP2012 提高组] 借教室**：涉及区间修改与整体查询，可练习差分及离散化的应用。
3. **P2234 [HNOI2002] 营业额统计**：需要对数据进行离散化处理后再统计，锻炼离散化思维。

### 个人心得摘录及总结
1. **白木偶君**：省选时因数组开小导致得分低，强调在使用数据结构时要注意空间大小，避免因小失大。
2. **hfctf0210**：因没看清最大值相同时输出要求而调试多次，提醒做题时务必仔细阅读题目细节，避免不必要的失误。 

---
处理用时：67.27秒
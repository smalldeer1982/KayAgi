# 题目信息

# [USACO20DEC] Rectangular Pasture S

## 题目描述

Farmer John 最大的牧草地可以被看作是一个由方格组成的巨大的二维方阵（想象一个巨大的棋盘）。现在，有 $N$ 头奶牛正占据某些方格（$1≤N≤2500$）。

Farmer John 想要建造一个可以包围一块矩形区域的栅栏；这个矩形必须四边与 $x$ 轴和 $y$ 轴平行，最少包含一个方格。请帮助他求出他可以包围在这样的区域内的不同的奶牛子集的数量。注意空集应当被计算为答案之一。 

## 说明/提示

共有 $2^4$ 个子集。FJ 不能建造一个栅栏仅包围奶牛 $1$、$2$、$4$，或仅包围奶牛 $2$、$4$，或仅包围奶牛 $1$、$4$，所以答案为 $2^4-3=16-3=13$。 

 - 测试点 2-3 满足 $N≤20$。
 - 测试点 4-6 满足 $N≤100$。
 - 测试点 7-12 满足 $N≤500$。
 - 测试点 13-20 没有额外限制。

供题：Benjamin Qi 

## 样例 #1

### 输入

```
4
0 2
1 0
2 3
3 5```

### 输出

```
13```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解先对坐标离散化，将问题转化到较小规模的棋盘上。然后通过枚举矩形边界来统计满足条件的奶牛子集数量。部分题解从上下边界入手，结合左右边界奶牛的位置关系计算方案数；部分从左右边界出发，考虑上下边界的可能性。
    - 算法要点上，常见的有利用二维前缀和维护区域内奶牛数量，从而快速计算特定区域的奶牛数；还有通过排序和计数，在枚举边界过程中动态维护相关信息。少数题解使用树状数组优化计数过程。
    - 解决难点在于如何避免重复计算相同奶牛子集，不同题解通过规定矩形边界必须包含奶牛等方式来实现。同时，处理好大值域坐标也是一个要点，离散化是普遍采用的手段。
    - 整体来看，多数题解时间复杂度为\(O(n^2)\)，部分使用树状数组的题解时间复杂度为\(O(n^2log_{2}n)\)。

  - **作者：SBofGaySchool (赞：24)**
    - **星级**：4星
    - **关键亮点**：思路清晰，纯暴力枚举上下边界，通过维护边界间奶牛相对位置的计数来避免重复计算，无需复杂数据结构和前缀和，时间复杂度\(O(n^2)\)。
    - **重点代码**：
```cpp
// 先算上空集
ll ans = 1;
// l[j]代表【第j行的牛】与【当前第i行的牛】之间，有多少头牛在【第j行的牛】左边
// r[j]同理
ll l[MAXN], r[MAXN];
int main() {
    cin >> N;
    for (int i = 0; i < N; i++)
        cin >> x[i].first >> x[i].second;
    // 按行坐标排序
    sort(x, x + N);
    // 枚举i
    for (ll i = 0; i < N; i++) {
        ans++;
        // lt代表【第i行的牛】与【当前第j行的牛】之间，有多少头牛在【第i行的牛】左边
        // rt同理
        ll lt = 0, rt = 0;
        for (ll j = i - 1; j >= 0; j--) {
            // 根据【第i行的牛】与【第j行的牛】的相对位置，累加答案，更新计数
            if (x[i].second > x[j].second) {
                ans += (rt + 1) * (l[j] + 1);
                r[j]++;
                lt++;
            } else {
                ans += (lt + 1) * (r[j] + 1);
                l[j]++;
                rt++;
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```
    - **核心实现思想**：先对奶牛按行坐标排序，枚举下侧木板所在行\(i\)和上侧木板所在行\(j\)，根据\(i\)、\(j\)行奶牛列坐标的相对位置，动态更新\(i\)、\(j\)行之间奶牛在\(i\)、\(j\)行奶牛左右两侧的数量，进而累加方案数。

  - **作者：Skies (赞：21)**
    - **星级**：4星
    - **关键亮点**：先离散化处理坐标，利用二维前缀和维护区域内奶牛数，通过枚举上下边界，结合二维前缀和计算左右边界的可行方案数，思路常规且清晰，时间复杂度\(O(n^2)\)。
    - **重点代码**：
```cpp
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=n;j++)
    {
        s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];
    }
}
ll ans=0;
for(int i=1;i<=n;i++)
{
    for(int j=i;j<=n;j++)
    {
        int x1=min(po[i].x,po[j].x),x2=max(po[i].x,po[j].x);
        ans+=get(1,po[i].y,x1,po[j].y)*get(x2,po[i].y,n,po[j].y);
    }
}
cout<<ans+1;
```
    - **核心实现思想**：先对坐标离散化并构建二维前缀和数组\(s\)，枚举上下边界\(i\)、\(j\)，通过二维前缀和函数\(get\)计算以\(i\)、\(j\)为上下边界，左右边界分别在\(min(po[i].x,po[j].x)\)左侧和\(max(po[i].x,po[j].x)\)右侧区域内的奶牛数，两者相乘累加得到方案数。

  - **作者：wsyhb (赞：12)**
    - **星级**：4星
    - **关键亮点**：离散化后，以矩形区域中最靠左和最靠右的奶牛作为标志，通过树状数组统计上下边界间特定纵坐标范围的奶牛数量，利用乘法原理计算方案数，考虑情况全面，时间复杂度\(O(n^2log_{2}n)\)。
    - **重点代码**：
```cpp
namespace BIT//树状数组相关操作 
{
    int c[max_N];
    inline void init()
    {
        for(int i=1;i<=N;++i)
            c[i]=0;
    }
    inline void modify(int k,int v)
    {
        if(k>0)
        {
            for(int i=k;i<=N;i+=i&(-i))
                c[i]+=v;
        }
    }
    inline int query(int k)
    {
        int res=0;
        for(int i=k;i>0;i-=i&(-i))
            res+=c[i];
        return res;
    }
}
long long ans=N+1;//初始值为 N+1，并且记得开 long long 
for(int i=1;i<=N;++i)
{
    BIT::init();//清空树状数组 
    for(int j=i+1;j<=N;++j)
    {
        int l=min(p[i].y,p[j].y);//下边界的上界，对应上文中的 a 
        int r=max(p[i].y,p[j].y);//上边界的下界，对应上文中的 b 
        int a=BIT::query(l-1);//由于横纵坐标分别互不相同，l 与 l-1 均可，下同 
        int b=(j-i-1)-BIT::query(r);//用总数减去后缀 
        ans+=1ll*(a+1)*(b+1);//a,b 对应上文中的 cnt1 和 cnt2 
        BIT::modify(p[j].y,1);//别忘了将纵坐标加入树状数组 
    }
}
```
    - **核心实现思想**：先对奶牛坐标离散化并按横坐标排序，枚举最靠左奶牛\(i\)和最靠右奶牛\(j\)，利用树状数组在枚举\(j\)时动态统计\(i\)到\(j - 1\)头牛中纵坐标小于等于\(min(p[i].y,p[j].y)\)和大于等于\(max(p[i].y,p[j].y)\)的奶牛数量，相乘累加得到方案数。

• 最优关键思路或技巧：
    - **离散化**：由于原始坐标值域大但奶牛数量相对少，离散化能将大坐标映射到小范围，降低问题规模。
    - **避免重复计数**：通过规定矩形边界必须有奶牛，如以最上最下或最左最右的奶牛作为标志来枚举矩形，可避免重复计算相同奶牛子集。
    - **利用数据结构优化**：如树状数组可在枚举过程中高效统计特定范围内元素数量，优化时间复杂度。

• 可拓展之处：
    - 同类型题通常围绕二维平面上的点集，通过矩形、圆形等几何图形覆盖点集，求满足特定条件的点集数量或组合情况。类似算法套路为先对坐标离散化，再根据图形特点枚举边界，利用合适的数据结构（如前缀和数组、树状数组等）快速统计区域内点的信息。

• 相似知识点洛谷题目推荐：
    - [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：在给定的矩阵中寻找最大的全1正方形，涉及动态规划和二维数组的处理，与本题处理二维平面信息有相似之处。
    - [P2216 [HAOI2007]理想的正方形](https://www.luogu.com.cn/problem/P2216)：求给定矩阵中满足特定条件的最小正方形，需要通过预处理和枚举来解决，与本题离散化和枚举边界思路类似。
    - [P3397 地毯](https://www.luogu.com.cn/problem/P3397)：在二维平面上铺设地毯，询问某个点被多少层地毯覆盖，可通过二维前缀和解决，与本题利用二维前缀和维护区域信息相似。

• 个人心得摘录与总结：无。 

---
处理用时：43.57秒
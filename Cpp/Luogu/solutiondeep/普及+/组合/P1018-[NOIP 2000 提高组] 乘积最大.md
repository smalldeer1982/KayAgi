# 题目信息

# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解采用动态规划，通过定义状态表示前i个数插入j个乘号的最大乘积，状态转移方程通过枚举乘号位置来构建。少数题解采用深度优先搜索（DFS），枚举乘号插入位置并计算乘积，同时使用剪枝优化。
    - 算法要点：动态规划需合理定义状态与转移方程，注意边界条件初始化；DFS要明确参数意义，利用剪枝提高效率。
    - 解决难点：由于数字串长度N≤40，乘积结果很大，需使用高精度算法处理。

    整体来看，动态规划方法在解决此类问题上更为通用和高效，DFS在数据范围较小时也可通过剪枝实现。多数题解思路清晰，但部分题解代码可读性欠佳或缺少优化。

  - liar_white（5星）
    - 关键亮点：思路清晰，详细阐述每个步骤，通过结构体实现高精度运算，代码注释详尽，易理解。
    - 个人心得：“写这道题都用了半上午”，可见其解题过程认真投入。
    - 核心代码实现思想：定义结构体存储高精度数字，通过`culc`函数取数，`mul`函数实现高精度乘法，`Max`函数比较大小，主函数中通过三层循环完成状态转移和结果计算。
```cpp
struct node{//用结构体储存数组；当然，也可以直接用三维数组，不过感觉这样更容易理解
    int v;bool exi;//v:数位,exi:是否存在
    int c[50];//高精度数组
}cut[50][10],ans[50];
node culc(int l,int r){//取数操作，注意：要从右往左取，因为高精度数组是从低位往高位排的，而读入的数字串是从高位到低位
    node e;
    e.v=r-l+1;e.exi=true;
    for(int i=1;i<=e.v;i++){
        e.c[i]=a[r-i+1];
    }    
    return e;
}
node mul(node e1,node e2){//高精度乘法
    node emul;
    emul.exi=true;emul.v=e1.v+e2.v-1;
    for(int i=1;i<=emul.v;i++) emul.c[i]=0;
    for(int i=1;i<=e1.v;i++)
        for(int j=1;j<=e2.v;j++)
            emul.c[i+j-1]+=e1.c[i]*e2.c[j];
    int q=0;        
    for(int i=1;i<=emul.v;i++){
        emul.c[i]+=q;
        q=emul.c[i]/10;
        emul.c[i]%=10;
    }
    while(q>0){
        emul.c[++emul.v]=q%10;
        q/=10;
    }
    return emul;
}
node Max(node e1,node e2){//高精度比较，类似字符串（然而如果是字符串的话我就直接strcmp了）
    if(!e1.exi||e1.v<e2.v) return e2;
    if(!e2.exi||e2.v<e1.v) return e1;//先比较是否存在和位数
    for(int i=e1.v;i>=1;i--){//都存在，且位数相同，则逐位比较
        if(e1.c[i]>e2.c[i]) return e1;
        else if(e2.c[i]>e1.c[i]) return e2;
    }
    return e1;
}
```
  - FastIO_DP（5星）
    - 关键亮点：思路清晰，详细推导状态转移方程，使用结构体实现高精度运算并重载运算符，代码简洁且可读性好，同时给出复杂度分析。
    - 核心代码实现思想：定义`BI`结构体表示高精度数，重载乘法和比较运算符。通过`num`函数获取子串对应的高精度数，主函数中通过三层循环完成动态规划的状态转移，最后输出结果。
```cpp
struct BI {
    int d[100];
    int len;

    BI() {
        memset(d, 0, sizeof(d));
        len = 0;
    }
    BI(const string& s) {
        memset(d, 0, sizeof(d));
        len = s.size();
        for (int i = 0; i < len; ++i) {
            d[i] = s[len - 1 - i] - '0';
        }
    }

    string toStr() const {
        string s;
        for (int i = len - 1; i >= 0; --i) {
            s += to_string(d[i]);
        }
        return s;
    }

    BI operator*(const BI& o) const {
        BI res;
        for (int i = 0; i < len; ++i) {
            int c = 0;
            for (int j = 0; j < o.len; ++j) {
                int p = d[i] * o.d[j] + res.d[i + j] + c;
                res.d[i + j] = p % 10;
                c = p / 10;
            }
            if (c) {
                res.d[i + o.len] += c;
            }
        }
        res.len = len + o.len;
        while (res.len > 1 && res.d[res.len - 1] == 0) {
            res.len--;
        }
        return res;
    }

    bool operator<(const BI& o) const {
        if (len!= o.len) {
            return len < o.len;
        }
        for (int i = len - 1; i >= 0; --i) {
            if (d[i]!= o.d[i]) {
                return d[i] < o.d[i];
            }
        }
        return false;
    }
};

int N, K;
string s;
BI dp[50][10];

BI num(int l, int r) {
    string sub = s.substr(l, r - l + 1);
    return BI(sub);
}

int main() {
    cin >> N >> K;
    cin >> s;

    for (int i = 0; i < N; ++i) {
        dp[i][0] = num(0, i);
    }

    for (int j = 1; j <= K; ++j) {
        for (int i = j; i < N; ++i) {
            for (int k = j - 1; k < i; ++k) {
                BI t = dp[k][j - 1] * num(k + 1, i);
                if (dp[i][j] < t) {
                    dp[i][j] = t;
                }
            }
        }
    }

    cout << dp[N - 1][K].toStr() << endl;

    return 0;
}
```
  - kuaiCreator（4星）
    - 关键亮点：对划分型动态规划的概念和步骤讲解详细，清晰阐述状态定义、子问题分解、初始化及计算顺序，给出不带高精度的代码示例辅助理解。
    - 核心代码实现思想：通过三层循环实现动态规划，外层循环枚举前i个数，中层循环枚举插入乘号数量，内层循环枚举插入位置，根据状态转移方程更新`dp`数组。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 50;
long long dp[N][N], n, m, num[N][N];		//long long 可以替换为高精度类型
string str;
int main() {
	cin >> n >> m >> str;
	str = ' ' + str;                      //让字符串有用的信息从下标 1 开始
	for (int i = 1; i <= n; i++)          //把字符串第i至第j个位置的子串转换为整数
		for (int j = i; j <= n; j++)
			num[i][j] = num[i][j - 1] * 10 + str[j] - '0';

	memset(dp, 0, sizeof(dp));
	for (int i = 1; i <= n; i++)          //初始化边界状态
		dp[i][0] = num[1][i]; 

	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {     //j<i表示i个数最多插入i-1个乘号
			if (j >= i) break;  //前i个元素不能被插入j个隔板分成j+1份
			for (int k = j; k < i; k++)    //前k个元素最多插入j-1个符号故k从j开始枚举
				dp[i][j] = max(dp[i][j], dp[k][j - 1] * num[k + 1][i]);
		}
	cout << dp[n][m];
	return 0;
}
```
• 最优关键思路或技巧：
    - 动态规划方面，合理定义状态，以`dp[i][j]`表示前i个数插入j个乘号的最大乘积，通过枚举乘号位置得到简洁有效的状态转移方程。
    - 高精度算法实现时，采用结构体封装数字并实现相应运算，可通过重载运算符提高代码可读性和简洁性。
    - DFS时利用可行性剪枝，如保证剩余乘号有足够位置可插，提高搜索效率。
• 拓展思路：
    - 此类问题属于组合优化问题，可拓展到其他分割、组合场景，如将序列分割成若干子序列求最值，或对不同元素组合进行优化。
    - 类似算法套路：动态规划解决此类问题时，关键在于状态定义和转移方程推导，可多练习不同类型的区间DP、线性DP题目加深理解；DFS则注重剪枝策略优化。
• 相似知识点洛谷题目：
    - P1880 [NOI1995] 石子合并：区间DP，将石子序列合并求最小或最大得分，与本题动态规划思路类似。
    - P2052 [NOIP2015 提高组] 旅行商简化版：线性DP，在给定路径上选择停留点使收益最大，涉及状态定义与转移。
    - P1005 [NOIP2007 提高组] 矩阵取数游戏：高精度与动态规划结合，从矩阵取数计算最大得分，需处理高精度乘法。 

---
处理用时：60.05秒
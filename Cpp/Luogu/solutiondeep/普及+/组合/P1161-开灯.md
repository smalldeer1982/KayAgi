# 题目信息

# 开灯

## 题目描述

在一条无限长的路上，有一排无限长的路灯，编号为 $1,2,3,4,\dots$。

每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。

在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：

指定两个数，$a,t$（$a$ 为实数，$t$ 为正整数）。将编号为 $\lfloor a\rfloor,\lfloor 2 \times a\rfloor,\lfloor3 \times a\rfloor,\dots,\lfloor t  \times a\rfloor$ 的灯的开关各按一次。其中 $\lfloor k \rfloor$ 表示实数 $k$ 的整数部分。

在小明进行了 $n$ 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。

幸好，小明还记得之前的 $n$ 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？


## 说明/提示

记 $T=\sum \limits_{i=1}^n t_i = t_1+t_2+t_3+\dots+t_n$。

- 对于 $30\%$ 的数据，满足 $T \le 1000$；
- 对于 $80\%$ 的数据，满足 $T \le 200000$；
- 对于 $100\%$ 的数据，满足 $T \le 2000000$；
- 对于 $100\%$ 的数据，满足 $n \le 5000$，$1 \le a_i<1000$，$1 \le t_i \le T$。

数据保证，在经过 $n$ 次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的 $i$ 来说，$t_i\times a_i$ 的最大值不超过 $2000000$。

## 样例 #1

### 输入

```
3
1.618034 13
2.618034 7
1.000000 21```

### 输出

```
20```

# AI分析结果

### 综合分析与结论
这些题解主要分为模拟和位运算两种思路。
 - **模拟思路**：创建数组模拟路灯状态，对每次操作按题目要求改变对应路灯状态，最后遍历数组找出唯一开着的灯。其算法要点在于按操作模拟，难点是确定数组合适大小，避免空间浪费与下标越界，时间复杂度为O(n * ti)。
 - **位运算思路**：利用异或运算性质，将所有涉及的路灯编号异或，因其他编号出现次数成对，异或后为0，最终结果就是开着的灯的编号。此思路算法要点是理解并运用异或运算，难点在于掌握异或运算性质及为何能用于求解本题。

整体来看，模拟思路直观但效率相对低，位运算思路简洁高效但理解门槛稍高。多数题解代码较清晰，但部分模拟题解未优化，在数据量大时效率欠佳。

### 所选的题解
 - **作者：Hamster_Air（5星）**
    - **关键亮点**：采用位运算，代码简洁高效，利用异或运算特性巧妙解决问题，同时使用快读快输及for循环简写优化代码。
    - **核心代码**：
```cpp
#include<bits/stdc++.h> 
#define f(i,j,n) for(i=j;i<=n;i++) 
using namespace std;
int main()
{
    ios::sync_with_stdio(false); 
    int n,t,i,j,ans=0;
    double a; 
    cin>>n;
    f(i,1,n)
    {
        cin>>a>>t;
        f(j,1,t)
            ans^=int(j*a); 
    }
    cout<<ans<<endl; 
    return 0; 
}
```
    - **核心思想**：每次读入a和t后，对范围内路灯编号与ans进行异或运算，最后输出ans得到开着的灯的编号。
 - **作者：雨竹（4星）**
    - **关键亮点**：详细解释异或运算原理及用于本题的原因，使读者易理解思路，代码简洁明了。
    - **核心代码**：
```cpp
#include<cstdio>  
#include<cstring>  
#include<cmath>  
#include<algorithm>  
  
using namespace std;  
  
int n,t;  
double a;  
  
int main()  
{  
    int ans=0;  
    scanf("%d",&n);  
    while (n--)  
    {  
        scanf("%lf",&a);
        scanf("%d",&t);  
        for (int i=1;i<=t;i++)  
        {  
            int x=(int)floor(a*i);  
            ans^=x;  
        }  
    }  
    printf("%d",ans);  
    return 0;  
}  
```
    - **核心思想**：通过循环读入操作数据，将每次操作涉及路灯编号与ans异或，最终ans即为开着的灯的编号。
 - **作者：shanjb0221（4星）**
    - **关键亮点**：提出对相同操作去重的优化思路，减少计算量，提高效率。
    - **个人心得**：发现相同操作等价于无操作，通过排序去重优化。
    - **核心代码**：
```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
const int N=5e3+5;
int ans,n;
pair<double,int> a[N];
char del[N];
int main() {
	scanf("%d",&n);
	for(int i=0; i<n; ++i)scanf("%lf%d",&a[i].first,&a[i].second);
	sort(a,a+n);
	for(int i=0; i+1<n; ++i)
		if(!del[i]&&a[i]==a[i+1])del[i]=del[i+1]=1;
	for(int i=0; i<n; ++i)if(!del[i])
			for(int j=1; j<=a[i].second; ++j)ans^=int(a[i].first*j);
	printf("%d\n",ans);
}
```
    - **核心思想**：先读入操作数据，排序后标记相同操作，再对未标记操作按位运算思路处理得到开着的灯的编号。

### 最优关键思路或技巧
位运算中的异或运算是本题高效解法的关键技巧，利用其特性简化计算。同时，对操作去重的优化思路也能有效减少计算量，提高算法效率。

### 可拓展之处
同类型题常涉及状态变化与统计，类似算法套路是利用位运算处理有特定规律的状态变化问题，如某些开关状态切换、奇偶性判断等。

### 推荐题目
 - [P1315 观光公交](https://www.luogu.com.cn/problem/P1315)：涉及时间状态变化与优化，可锻炼对状态处理及算法优化能力。
 - [P1120 小木棍 ［数据加强版］](https://www.luogu.com.cn/problem/P1120)：通过搜索与剪枝处理小木棍拼接状态，与本题处理状态思路有相通处。
 - [P1092 虫食算](https://www.luogu.com.cn/problem/P1092)：利用位运算及搜索处理数字谜题，与本题位运算思路相关。

### 个人心得摘录与总结
 - **万家铭**：调试发现题目要求对实数乘积取整处理路灯编号，提示做题需仔细读题，明确数据处理要求。 

---
处理用时：29.74秒
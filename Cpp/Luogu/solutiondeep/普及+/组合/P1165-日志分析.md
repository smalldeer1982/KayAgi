# 题目信息

# 日志分析

## 题目描述

M 海运公司最近要对旗下仓库的货物进出情况进行统计。目前他们所拥有的唯一记录就是一个记录集装箱进出情况的日志。该日志记录了两类操作：第一类操作为集装箱入库操作，以及该次入库的集装箱重量；第二类操作为集装箱的出库操作。这些记录都严格按时间顺序排列。集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为当前在仓库里所有集装箱中最晚入库的集装箱。

出于分析目的，分析人员在日志中随机插入了若干第三类操作――查询操作。分析日志时，每遇到一次查询操作，都要报告出当前仓库中最大集装箱的重量。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，有 $N \le 10$；
- 对于 $40\%$ 的数据，有 $N \le 1000$；
- 对于 $100\%$ 的数据，有 $1 \le N \le 200000$，$1 \le X \le 10^8$。


## 样例 #1

### 输入

```
13
0 1
0 2
2
0 4
0 2
2
1
2
1
1
2
1
2
```

### 输出

```
2
4
4
1
0
```

# AI分析结果

• 综合分析与结论：
  本题为栈操作结合查询最大值的问题，数据量较大，暴力解法易超时。各题解主要思路围绕栈展开，通过不同方式维护栈内最大值。
  - 思路方面：多数题解采用辅助数据结构（如辅助栈、数组）来记录最大值；部分题解使用优先队列、平衡树、multiset等方式。
  - 算法要点：操作0入栈时，需同步更新最大值记录；操作1出栈时，相应调整最大值记录；操作2直接输出当前最大值。
  - 解决难点：在保证栈操作“先进后出”特性的同时，高效获取最大值，避免每次查询时的线性遍历。

  综合质量来看，medusa、buickboy、felixwu的题解相对更优，思路清晰，代码简洁且优化较好。

  - medusa（5星）：
    - 关键亮点：思路清晰，通过数组f记录栈中从下到上i个元素中的最大值，更新和查询操作简单高效。
    - 核心代码：
```cpp
int f[200001],n,x,y,t=0;
int main()   
{   
    cin>>n;   
    f[0]=0;   
    for (int i=1; i<=n; i++)   
    {   
        cin>>x;   
        if (x==0)    
        {   
            cin>>y;   
            t++;   
            f[t]=max(f[t-1],y);   
        }   
        if (x==1) if (t!=0) t--;   
        if (x==2) cout<<f[t]<<endl;   
    }   
    return 0;   
}  
```
    - 核心实现思想：入栈时（x == 0），t自增并更新f[t]为当前最大值；出栈时（x == 1），t自减；查询时（x == 2），直接输出f[t]。

  - buickboy（4星）：
    - 关键亮点：引入辅助栈记录最大值，逻辑直观，代码简洁明了。
    - 核心代码：
```cpp
stack<int>a;
stack<int>b;
int n,m,x;
int main()
{
    scanf("%d",&n);
    while(n--)
    {
        scanf("%d",&m);
        if(m==0)
        {
            scanf("%d",&x);
            a.push(x);
            if(b.empty()||x>b.top())
                b.push(x);
            else b.push(b.top());
        }
        else if(m==1)
        {
            a.pop();
            b.pop();
        }
        else
        {
            if(b.empty()) printf("0\n");
            else printf("%d\n",b.top());
        }
    }
    return 0;
}
```
    - 核心实现思想：主栈a正常入栈出栈，辅助栈b在入栈时，若新元素大于辅助栈顶则压入新元素，否则压入辅助栈顶元素；出栈时两栈同步操作；查询时输出辅助栈顶元素。

  - felixwu（4星）：
    - 关键亮点：代码简洁，通过数组a维护包括栈顶元素的最大值，操作简单直接。
    - 核心代码：
```cpp
int q[1000001],top,a[1000001],m,n,k;
void push(int x){q[++top]=x;}
void pop(){top--;}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&m);
        if(m==0) {
            scanf("%d",&k);
            push(k);
            a[top]=max(a[top-1],k);
        }
        if(m==1) pop(); 
        if(m==2) printf("%d\n",a[top]);
    }
    return 0;
}
```
    - 核心实现思想：入栈时（m == 0），调用push函数入栈并更新a[top]为当前最大值；出栈时（m == 1），调用pop函数；查询时（m == 2），输出a[top]。

• 最优关键思路或技巧：使用辅助数据结构（如辅助栈、数组）同步记录栈内最大值，在入栈和出栈操作时，相应更新辅助数据结构，使得查询最大值操作能在O(1)时间复杂度内完成。

• 可拓展之处：同类型题可涉及栈与其他数据结构结合，如栈与队列、栈与链表等，类似算法套路为利用辅助数据结构记录关键信息以优化操作。

• 推荐题目：
  - P1449 后缀表达式：考查栈在表达式求值中的应用。
  - P1739 表达式括号匹配：考查栈在括号匹配问题中的应用。
  - P4304 [JSOI2009] 有趣的游戏：考查栈与字符串匹配相关知识。

• 个人心得摘录与总结：
  - Garrison：在洛谷编译器中++tot;a[tot]=a[tot - 1];和a[++tot]=a[tot - 1]不是等价的，部分评测系统计算顺序不同。总结为在不同编译器或评测系统下，注意运算符顺序可能导致的代码差异。 

---
处理用时：32.14秒
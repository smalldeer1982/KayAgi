# 题目信息

# 小朋友的球

## 题目描述

@发源于 小朋友最近特别喜欢球。有一天他脑子抽了，从口袋里拿出了 $N$ 个不同的球，想把它们放到 $M$ 个相同的盒子里，并且要求每个盒子中至少要有一个球，他好奇有几种放法，于是尝试编程实现，但由于他天天不好好学习，只会上 B 站看游泳教练，于是他向你求助。

## 说明/提示

- 对于 $20\%$ 的数据，满足 $N,M \leq 10$；
- 对于 $100\%$ 的数据，满足 $1 \leq N,M \leq 100$，一个测试文件最多有 $10$ 组测试数据。


## 样例 #1

### 输入

```
4 2
1 1```

### 输出

```
7
1```

# AI分析结果

### 综合分析与结论
这些题解均围绕将\(N\)个不同球放入\(M\)个相同且非空盒子的方案数求解，都意识到需用高精度运算避免仅得部分分数。
 - **思路**：均基于第二类斯特林数的思想，通过分析第\(i\)个球的放置情况得出状态转移方程\(f[i][j]=f[i - 1][j - 1]+f[i - 1][j]\times j\) 。
 - **算法要点**：利用动态规划，以二维数组记录不同球数和盒子数下的方案数，按状态转移方程递推计算。
 - **解决难点**：因数据范围使结果易超常规数据类型范围，需实现高精度加法和乘法运算。

### 所选的题解
#### 作者：Heartlessly (5星)
 - **关键亮点**：思路清晰，先点明算法为带高精度的动态规划及与斯特林数的联系，再给出状态转移方程。代码实现上，高精度运算函数独立且清晰，主函数逻辑与思路对应紧密，可读性强。
 - **重点代码 - 核心实现思想**：定义高精度加法 `add` 和乘法 `mul` 函数，主函数中先初始化边界条件 `f[i][1] = "1"`，再按状态转移方程 `f[i][j] = add ( f[i - 1][j - 1], mul ( f[i - 1][j], j ) )` 递推计算，最后处理输入输出。
```cpp
string add(string a,string b){
    string ans;
    int na[L]={0},nb[L]={0};
    int la=a.size(),lb=b.size();
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';
    int lmax=la>lb?la:lb;
    for(int i=0;i<lmax;i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;
    if(na[lmax]) lmax++;
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';
    return ans;
}
int na[L];
string mul(string a,int b){
    string ans;
    int La=a.size();
    fill(na,na+L,0);
    for(int i=La-1;i>=0;i--) na[La-i-1]=a[i]-'0';
    int w=0;
    for(int i=0;i<La;i++) na[i]=na[i]*b+w,w=na[i]/10,na[i]=na[i]%10;
    while(w) na[La++]=w%10,w/=10;
    La--;
    while(La>=0) ans+=na[La--]+'0';
    return ans;
}
int n, m;
string f[101][101];
int main(){
    for ( int i = 1; i <= 100; i++ )
    f[i][1] = "1";
    for ( int i = 2; i <= 100; i++ )
    for ( int j = 1; j <= i; j++ )
    f[i][j] = add ( f[i - 1][j - 1], mul ( f[i - 1][j], j ) );
    while ( cin >> n >> m ){
        if ( n < m ) printf ( "0\n" );
        else cout << f[n][m] << endl;
    }
    return 0;
}
```

#### 作者：HPXXZYY (4星)
 - **关键亮点**：先列出预备算法，使读者对所需知识一目了然。代码通过重载运算符实现高精度运算，将其封装为类，使用方便，代码结构清晰。
 - **重点代码 - 核心实现思想**：定义 `node` 类重载 `+` 和 `*` 运算符实现高精度加乘，主函数初始化边界条件 `f[i][1].len = 1; f[i][1].num[1] = 1;`，按状态转移方程 `f[i][j]=f[i - 1][j - 1]+(f[i - 1][j]*j)` 递推，处理输入输出。
```cpp
struct node{
    int len,num[1100];
    node(){
        len=0;init(num,0);
    }
    node operator + (node a){
        register node c;
        register int x=0,i;
        c.len=max(this->len,a.len);
        for(i=1;i<=c.len;i++){
            c.num[i]=a.num[i]+this->num[i]+x;
            x=c.num[i]/10;c.num[i]%=10;
        }
        if (x) c.num[++c.len]=x;
        return c;
    }
    node operator * (int a){
        register node c=*this;
        register int x=0,i;
        for(i=1;i<=c.len;i++){
            c.num[i]=c.num[i]*a+x;
            x=c.num[i]/10;c.num[i]%=10;
        }
        while (x){
            c.num[++c.len]=x%10;x/=10;
        }
        return c;
    }
    void write(){
        for(int i=len;i;i--)
        printf("%d",num[i]);
        printf("\n");
    }
}f[110][110];
int n,m,i,j;
int main(){
    for(i=1;i<101;i++){
        f[i][1].len=1;
        f[i][1].num[1]=1;
    }
    for(i=2;i<101;i++)
    for(j=1;j<=i;j++)
    f[i][j]=f[i - 1][j - 1]+(f[i - 1][j]*j);
    while (~scanf("%d%d",&n,&m)){
        if (n<m) printf("0\n");
        else f[n][m].write();
    }
    return 0;
}
```

#### 作者：李若谷 (4星)
 - **关键亮点**：虽未提及斯特林数，但从DP思想出发自行推出状态转移方程，对理解算法本质有帮助。使用 `vector` 实现大整数类，利用其特性简化高精度运算实现，代码简洁。
 - **重点代码 - 核心实现思想**：定义 `Wint` 类继承 `vector<int>` 实现大整数，重载输入输出及四则运算。主函数初始化 `dp[0][0] = 1`，按状态转移方程 `dp[i][j] = dp[i - 1][j] * j + dp[i - 1][j - 1]` 递推并输出结果。
```cpp
struct Wint:vector<int>{
    Wint(int n=0){
        push_back(n);
        check();
    }
    Wint& check(){
        while(!empty()&&!back())pop_back();
        if(empty())return *this;
        for(int i=1; i<size(); ++i){
            (*this)[i]+=(*this)[i-1]/10;
            (*this)[i-1]%=10;
        }
        while(back()>=10){
            push_back(back()/10);
            (*this)[size()-2]%=10;
        }
        return *this;
    }
};
istream& operator>>(istream &is,Wint &n){
    string s;
    is>>s;
    n.clear();
    for(int i=s.size()-1; i>=0; --i)n.push_back(s[i]-'0');
    return is;
}
ostream& operator<<(ostream &os,const Wint &n){
    if(n.empty())os<<0;
    for(int i=n.size()-1; i>=0; --i)os<<n[i];
    return os;
}
Wint operator*(const Wint &a,const Wint &b){
    Wint n;
    n.assign(a.size()+b.size()-1,0);
    for(int i=0; i!=a.size(); ++i)
        for(int j=0; j!=b.size(); ++j)
            n[i+j]+=a[i]*b[j];
    return n.check();
}
Wint& operator+=(Wint &a,const Wint &b){
    if(a.size()<b.size())a.resize(b.size());
    for(int i=0; i!=b.size(); ++i)a[i]+=b[i];
    return a.check();
}
Wint operator+(Wint a,const Wint &b){
    return a+=b;
}
Wint dp[N][N];
int main()
{
    int n,m;
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        dp[0][0] = 1;
        for(register int i=1;i<=n;i++)
        {
            for(register int j=1;j<=m;j++)
            {
                dp[i][j] = dp[i - 1][j] * j + dp[i - 1][j - 1];
            }
        }
        cout<<dp[n][m]<<endl;
    }
    return 0;
}
```

### 最优关键思路或技巧
 - **状态转移方程推导**：从球的放置情况出发，分析第\(i\)个球放入新盒子或已有盒子的情况，得出通用的状态转移方程。
 - **高精度实现**：采用不同方式实现高精度运算，如重载运算符封装成类、利用 `vector` 特性等，使代码简洁且易于理解维护。

### 可拓展之处
同类型题常涉及组合数学中不同元素分配到不同容器的方案数问题，类似算法套路为分析边界条件和状态转移关系，结合高精度运算处理大数据。

### 推荐题目
 - [P2386 放苹果](https://www.luogu.org/problem/P2386)：同样是放物品问题，但盒子可空，与本题有相似之处又有不同，可对比练习。
 - [P1025 数的划分](https://www.luogu.org/problem/P1025)：将整数划分成若干个正整数之和，与本题思路类似，可锻炼组合数学和动态规划思维。
 - [P1287 盒子与球](https://www.luogu.org/problem/P1287)：涉及不同球放入不同盒子的多种限制情况，进一步拓展对这类问题的理解。

### 个人心得摘录
 - **作者：ergeda**：强调注意边界条件 `m>n||m==0` 时直接输出0，因未注意此条件多次WA。总结了做题要仔细分析边界情况，避免遗漏导致错误。 

---
处理用时：89.03秒
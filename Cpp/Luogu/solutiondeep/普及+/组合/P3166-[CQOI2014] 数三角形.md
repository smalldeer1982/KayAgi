# 题目信息

# [CQOI2014] 数三角形

## 题目描述

给定一个 $N\times M$ 的网格，请计算三点都在格点上的三角形共有多少个。注意三角形的三点不能共线。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1\le N,M\le1000$。

## 样例 #1

### 输入

```
2 2```

### 输出

```
76```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解均采用“三角形数量 = 任选三个点的方案数 - 三点共线的方案数”这一思路。任选三个点的方案数为\(C_{(n + 1)(m + 1)}^3\) ，三点共线的方案数分为横着、竖着和斜着三种情况讨论。横着和竖着的情况较简单，斜着的情况是难点。
    - 算法要点：对于斜着三点共线的情况，大部分题解通过枚举两点的横纵坐标差\(i\)、\(j\) ，利用\(\gcd(i, j) - 1\)得到两点连线上除端点外的整点数量，再乘以这样的点对数量\((n - i + 1)(m - j + 1)\) ，并考虑斜率正负两种情况（乘以2）来计算。部分题解还提到组合数的计算方法。
    - 解决难点：斜着三点共线方案数计算的优化是关键。部分题解通过数学变换，如利用欧拉反演将\(\gcd\)项转化，降低计算复杂度。

    - 整体来看，各题解思路相似，主要差异在于对斜着三点共线情况的计算优化以及代码实现的细节。

  - 所选的题解：
    - 作者emptysetvvvv（5星）
      - 关键亮点：不仅给出常规\(O(n^2)\)做法，还提供了巧妙的\(O(n)\)做法，利用欧拉反演将\(\gcd\)项转化，通过线性预处理欧拉函数，优化了计算斜着三点共线方案数的复杂度。代码实现简洁明了，注释详细。
      - 个人心得：无
      - 重点代码 - 核心实现思想：利用欧拉筛预处理欧拉函数，通过特定公式计算斜着三点共线的方案数，最后根据总思路得出结果。
```cpp
#include <cstdio>
#include <iostream> 
using namespace std;
const int maxn = 1005;
int n, m, p[maxn], phi[maxn], tot;
bool mark[maxn];
long long ans;
long long C(long long x) { return x * (x - 1) * (x - 2) / 6; }
void sieve(int n) {
    phi[1] = 1;
    for(int i = 2; i <= n; ++i) {
        if(!mark[i]) p[++tot] = i, phi[i] = i - 1;
        for(int j = 1; j <= tot and p[j] * i <= n; ++j) {
            mark[p[j] * i] = true;
            if(i % p[j]) phi[p[j] * i] = phi[i] * (p[j] - 1);
            else { phi[p[j] * i] = phi[i] * p[j]; break; }
        }
    }
}
int main() {
    scanf("%d %d", &n, &m);
    if(n > m) swap(n, m);
    sieve(n);
    for(int d = 2, x, y; d <= n; ++d)
        ans += (long long)phi[d] * (n - d + n % d + 2) * (n / d) * (m - d + m % d + 2) * (m / d) / 2;
    ans = C((n + 1) * (m + 1)) - (m + 1) * C(n + 1) - (n + 1) * C(m + 1) - ans;
    printf("%lld\n", ans);
}
```
    - 作者PPL_ （4星）
      - 关键亮点：思路清晰，逐步推导，对斜着三点共线情况的分析详细，结合图形说明，易于理解。代码实现完整，对组合数计算、\(\gcd\)计算等功能进行封装，增强了代码可读性。
      - 个人心得：考试因扫雷影响思路，未推出解法，提醒不要因其他事影响考试状态。
      - 重点代码 - 核心实现思想：先计算任选三点方案数，减去横、竖方向三点共线方案数，再通过枚举计算斜着三点共线方案数得出结果。
```cpp
//12252024832524
#include <cstdio>
#include <algorithm>
using namespace std; 

typedef long long LL;
const int MAXN = 1005;
int n, m, n1, m1;
LL s[MAXN][MAXN], ans;

int Read()
{
    int x = 0, f = 1; char c = getchar();
    while(c > '9' || c < '0') { if(c == '-')f = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { x = (x * 10) + (c ^ 48); c = getchar(); }
    return x * f;
}
void Put(LL x)
{
    if(x > 9) Put(x / 10);
    putchar(x % 10 ^ 48);
}
template <typename T>T Max(T x, T y) { return x > y? x : y; }
template <typename T>T Min(T x, T y) { return x < y? x : y; }
template <typename T>T Abs(T x) { return x < 0? -x : x; }
int gcd(int x, int y)
{
    if(!y) return x;
    return gcd(y, x % y);
}
LL Cn3(LL x)
{
    return x * (x - 1) * (x - 2) / 6;
}
void solve4()
{
    n = n1 + 1;
    m = m1 + 1; 
    ans = Cn3(n * m) - m * Cn3(n) - n * Cn3(m);
    for(int i = 1; i < n; ++ i)
        for(int j = 1; j < m; ++ j)
            ans -= 2ll * (gcd(i, j) - 1) * (n - i) * (m - j);
    printf("%lld\n", ans);
}

int main()
{
//  freopen("triangle.in", "r", stdin);
//  freopen("triangle.out", "w", stdout);
    n1 = Read();
    m1 = Read();
    solve4();
    return 0;
}
```
    - 作者Hercules（4星）
      - 关键亮点：对组合数概念及本题思路阐述清晰，对斜着三点共线情况中\(\gcd(i, j) - 1\)的解释结合图形，直观易懂。代码简洁，结构清晰。
      - 个人心得：无
      - 重点代码 - 核心实现思想：先计算总方案数，减去横、竖方向三点共线方案数，通过枚举\(i\)、\(j\)计算斜着三点共线方案数得到最终答案。
```c
#include <bits/stdc++.h>
#define int long long

int n, m, ans;

inline int calc(int x) {
    return x * (x - 1) * (x - 2) / 6;
}

inline int gcd(int x, int y) {
    return (!y)? x : gcd(y, x % y);
}

signed main() {
#ifndef ONLINE_JUDGE
#ifdef LOCAL
    freopen("testdata.in", "r", stdin);
    freopen("testdata.out", "w", stdout);
#endif
#ifndef LOCAL
    freopen("20200725数三角形.in", "r", stdin);
    freopen("20200725数三角形.out", "w", stdout);
#endif
#endif
    scanf("%lld %lld", &n, &m);
    int t = (n + 1) * (m + 1);
    ans = t * (t - 1) * (t - 2) / 6 - calc(n + 1) * (m + 1) - calc(m + 1) * (n + 1);
    for (register int i = 1; i <= n; i++)
        for (register int j = 1; j <= m; j++)
            ans -= (n - i + 1) * (m - j + 1) * 2 * (gcd(i, j) - 1);
    printf("%lld\n", ans);
    return 0;
}
```
• 最优关键思路或技巧：利用数学知识优化计算，如通过欧拉反演将\(\gcd\)项转化，结合欧拉筛线性预处理欧拉函数，降低计算斜着三点共线方案数的时间复杂度。同时，在代码实现上，合理封装功能函数，增强代码可读性。
• 可拓展思路：此类题目属于组合数学与几何结合的问题，类似套路是通过容斥原理，将不易直接求解的问题转化为易求解的子问题之和或差。同类型题常涉及在特定图形（如矩形、多边形网格）中计算满足一定条件的图形（如三角形、四边形）数量，关键在于分析图形共线、共点等特殊情况，利用数论知识（如\(\gcd\)）辅助计算。
• 相似知识点洛谷题目：
    - P1313 计算系数：考察组合数计算及多项式展开相关知识。
    - P2822 [NOIP2016 提高组] 组合数问题：专注于组合数性质及取模运算。
    - P3807 【模板】卢卡斯定理：涉及卢卡斯定理在组合数计算中的应用。 

---
处理用时：71.61秒
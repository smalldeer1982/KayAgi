# 题目信息

# [CSP-J2019 江西] 非回文串

## 题目描述

Alice 有 $n$ 个字符，它们都是英文小写字母，从 $1 \sim n$ 编号，分别为 $c_1,c_2, \dots , c_n$。  
Bob 准备将这些字符重新排列，组成一个字符串 $S$。Bob 知道 Alice 有强迫症，所以他打算将 $S$ 组成一个非回文串来折磨 Alice。  

现在 Bob 想知道他共有多少种不同的排列字符的方案，能使得 $S$ 是个非回文串。一种排列字符的方案指的是一个 $1 \sim n$ 的排列 $p_i$，它所组成的 $S = c_{p_1}c_{p_2} \dots c_{p_n}$。

一个字符串是非回文串，当且仅当它的逆序串与原串不同。例如 `abcda` 的逆序串为 `adcba`，与原串不同，故 `abcda` 是非回文串。而 `abcba` 的逆序串与原串相同，是回文串。

由于最后的结果可能很大，你只需要告诉 Bob 总方案数对 $10^9+7$ 取模后的值。

## 说明/提示

【数据范围】  
对于 $20\%$ 的数据，$n \le 8$；  
对于 $50\%$ 的数据，$n \le 20$；  
另有 $30\%$ 的数据，字符只包含 `a` 和 `b`；  
对于 $100\%$ 的数据，$3 \le n \le 2000$。

## 样例 #1

### 输入

```
3
aba```

### 输出

```
4```

## 样例 #2

### 输入

```
8
aabbbbcc```

### 输出

```
39168```

# AI分析结果

• 综合分析与结论：
    - 思路方面：所有题解均采用正难则反的思想，通过计算总排列数（\(n!\)）减去回文串的数量来得到非回文串的数量。在计算回文串数量时，都考虑到回文串的对称性，即字符出现次数需满足一定条件（最多只有一个字符出现次数为奇数）才能构成回文串。
    - 算法要点：统计每个字符出现的次数，根据字符出现次数的奇偶性分类讨论。对于偶数次出现的字符，计算其在回文串一半位置中的排列组合情况；对于奇数次出现的字符（最多一个），单独处理并乘上相应系数。
    - 解决难点：难点在于准确计算回文串的数量，涉及到排列组合知识以及对回文串特性的深入理解。不同题解在计算排列组合时采用了不同方法，如直接计算、利用逆元等。
    - 整体质量：多数题解思路清晰，但在代码可读性和优化程度上存在差异。部分题解代码冗长，注释较少，影响可读性；部分题解在计算排列组合等操作时未进行优化，导致时间复杂度较高。

所选的题解：
  - 作者：NaCly_Fish (5星)
    - 关键亮点：思路清晰简洁，先明确非回文串数等于 \(n!\) 减去回文串数，再针对回文串数的计算，根据字符出现次数的奇偶性详细分类讨论，给出清晰的计算公式，代码实现简洁明了，有详细注释，且时间复杂度优化到 \(\Theta(n)\)。
    - 重点代码及核心思想：
```cpp
// 快速幂计算a的t次幂对p取模
inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int main(){
    scanf("%d",&n);
    scanf("%s",a+1);
    // 预处理阶乘和阶乘逆元
    ifac[0] = ifac[1] = fac[0] = fac[1] = 1;
    for(reg int i=2;i<=n;++i) ifac[i] = fac[i] = (ll)fac[i-1]*i%p;
    ifac[n] = power(fac[n],p-2);
    for(reg int i=n-1;i>1;--i) ifac[i] = (ll)ifac[i+1]*(i+1)%p;
    // 统计每个字符出现次数
    for(reg int i=1;i<=n;++i) ++cnt[a[i]-'a'];
    // 统计出现奇数次字符的个数
    for(reg int i=0;i<26;++i) odd += cnt[i]&1;
    if(odd>1){
        // 若有超过1种字符出现奇数次，直接输出n!
        printf("%d",fac[n]);
        return 0;
    }
    odd = 1;
    for(reg int i=0;i<26;++i)
        if(cnt[i]&1) odd = cnt[i];
    // 计算回文串数量相关值
    dec = (ll)fac[n>>1]*odd%p;
    for(reg int i=0;i<26;++i) cnt[i] >>= 1;
    for(reg int i=0;i<26;++i) dec = (ll)dec*fac[cnt[i]<<1]%p*ifac[cnt[i]]%p;
    // 计算非回文串数量
    ans = (fac[n]-dec+p)%p;
    printf("%d",ans);
    return 0;
}
```
核心思想是先预处理阶乘和阶乘逆元，通过统计字符出现次数判断能否构成回文串，若能则根据公式计算回文串数量，最后用总排列数减去回文串数量得到非回文串数量。

  - 作者：FJ_EYoungOneC (4星)
    - 关键亮点：解题思路阐述详细，对回文串存在的条件及计算回文串方案数的过程逐步分析，代码实现中使用快速幂求逆元，整体逻辑清晰，代码有一定注释。
    - 重点代码及核心思想：
```cpp
int qmi(int a, int b, int p)
{
    int res = 1 % p;
    while (b)
    {
        if (b & 1)
            res = (LL)res * a % p;
        a = (LL)a * a % p;
        b >>= 1;
    }
    return res;
}

int C(int a, int b)
{
    return (LL)fact[a] * infact[b] % MOD * infact[a - b] % MOD;
}

int main()
{
    fact[0] = infact[0] = 1;
    // 预处理阶乘和阶乘逆元
    for (int i = 1; i < N; ++ i )
    {
        fact[i] = (LL)fact[i - 1] * i % MOD;
        infact[i] = qmi(fact[i], MOD - 2, MOD);
    }
    
    cin >> n >> str;
    int m = n;
    // 统计每个字符出现次数
    for (auto c: str)
        h[c - 'a'] ++;
    
    int res = 1;
    int cnt = 0;
    // 处理出现奇数次字符
    for (int i = 0; i < 26; ++ i )
        if (h[i] & 1)
        {
            res = h[i];
            h[i] --;
            cnt ++;
        }
    
    if (cnt > 1)
    {
        // 若有超过1种字符出现奇数次，直接输出n!
        cout << fact[n] << endl;
        return 0;
    }
    
    n /= 2;
    // 计算回文串方案数
    for (int i = 0; i < 26; ++ i )
    {
        res = (LL)res * C(n, h[i] / 2) % MOD * fact[h[i]] % MOD;
        n -= h[i] / 2;
    }
    
    // 计算非回文串数量
    cout << ((LL)fact[m] - res + MOD) % MOD << endl;
    
    return 0;
}
```
核心思想是先预处理阶乘和阶乘逆元，通过统计字符出现次数判断回文串情况，对于能构成回文串的情况，利用组合数公式计算回文串方案数，最后得出非回文串数量。

  - 作者：Digital_Sunrise (4星)
    - 关键亮点：着重讲解易错点，对题目中的坑点分析到位，如字符编号导致数值相同字符也不同、字符出现次数奇偶性判断、排列组合公式的正确使用以及取模后的大小关系特判等，代码实现针对这些点进行处理。
    - 重点代码及核心思想：
```cpp
int pow(int x,int y)
{
    int cnt = 1;
    while(y)
    {
        if(y & 1)
        {
            cnt *= x;
            cnt %= mod;
        }
        x *= x;
        x %= mod;
        y >>= 1;
    }
    return cnt;
}

int C(int n,int m)
{
    if(n == 0)
        return 1;
    int ans = 1;
    for(int i = m;i >= m - n + 1;i--)
        ans *= i,ans %= mod;
    return ans * pow(fac[n],mod - 2) % mod;
}

signed main()
{
    cin >> len;
    cin >> s;
    fac[0] = fac[1] = 1;
    // 预处理阶乘
    for(int i = 2;i <= len;i++)
        fac[i] = fac[i - 1] * i % mod;
    // 统计每个字符出现次数
    for(int i = 0;i < len;i++)
        sum[(s[i] - 'a') + 1]++;
    // 统计出现奇数次字符的个数
    for(int i = 1;i <= 26;i++)
    {
        if(sum[i] % 2 == 1)
            num++;
    }
    if(num >= 2)
    {
        // 若有超过1种字符出现奇数次，直接输出n!
        cout << fac[len];
        return 0;
    }
    nn = len / 2;
    num = 1;
    // 计算回文串数量
    for(int i = 1;i <= 26;i++)
    {
        if(nn == 0)
            break;
        num *= C(sum[i] / 2,nn);
        num %= mod;
        num *= fac[sum[i]];
        num %= mod;
        nn -= sum[i] / 2;
    }
    // 计算非回文串数量并处理取模后可能为负的情况
    cout << (fac[len] - num < 0? fac[len] - num + mod : fac[len] - num);
    return 0;
}
```
核心思想是先预处理阶乘，通过统计字符出现次数判断回文串情况，对于能构成回文串的情况，利用组合数和排列数计算回文串数量，最后计算非回文串数量并处理取模后可能为负的情况。

最优关键思路或技巧：
  - 思维方式上，正难则反的思想是解决本题的关键，将难以直接计算的非回文串数量转化为总排列数减去回文串数量。
  - 算法优化方面，通过预处理阶乘和阶乘逆元，利用快速幂计算逆元，能有效减少计算量，提高算法效率。在计算组合数时，采用合适的公式和方法，如利用逆元计算组合数，避免重复计算，优化时间复杂度。

可拓展之处：同类型题通常围绕排列组合和字符串特性展开，类似算法套路是先分析目标字符串的特性（如对称性、字符种类限制等），再利用正难则反等思维方式，通过计算总排列数减去不符合条件的排列数来求解。例如，给定特定规则的字符串，求满足或不满足某种对称性质的排列数。

推荐题目：
  - [P1009 阶乘之和](https://www.luogu.com.cn/problem/P1009)：考察阶乘计算及高精度运算，与本题中阶乘计算有一定关联。
  - [P1313 计算系数](https://www.luogu.com.cn/problem/P1313)：涉及二项式定理和组合数计算，与本题计算排列组合数知识点相似。
  - [P2822 组合数问题](https://www.luogu.com.cn/problem/P2822)：专注于组合数的性质及计算，对深入理解组合数相关知识有帮助。

个人心得摘录及总结：
  - 作者Digital_Sunrise提到注意题目中的坑点，如字符编号导致相同数值字符不同、字符出现次数奇偶性判断、排列组合公式的正确使用以及取模后的大小关系特判等。总结为做题时要仔细读题，关注题目中的细节条件，对涉及的数学公式和运算要准确应用，同时注意取模等操作可能带来的边界情况。 

---
处理用时：61.63秒
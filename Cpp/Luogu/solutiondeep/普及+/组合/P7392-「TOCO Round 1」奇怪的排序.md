# 题目信息

# 「TOCO Round 1」奇怪的排序

## 题目背景

欢喜不问天，风流不问天，温柔不问天，良辰不问天，良缘不问天。

问你不问天。

## 题目描述

情人节那天 $\color{orange}\texttt{Biadocy}$ 被虐得好惨，尤其是上流的公爵和小孩说什么《和你在一起的每一天，都叫情人节》。于是他找到了一个机会来报复。

现在有 $n$ 对情人编号为 $1\sim n$ 按任意顺序排成一列，$\color{orange}\texttt{Biadocy}$ 对他们执行了下面这段排序的伪代码。

![](https://cdn.luogu.com.cn/upload/image_hosting/yny3xh8d.png)

$\color{orange}\texttt{Biadocy}$ 想知道有多少种初始排列满足按照这段伪代码排序后情人们的编号有序。也许这能让他好受一点。

## 说明/提示

对于前 $10\%$ 的数据，$T=0$。  
对于前 $30\%$ 的数据，$T\leq 10$，$n\leq 7$。  
对于另外 $10\%$ 的数据，$k=0$。  
对于另外 $10\%$ 的数据，$k=100$。  
对于 $100\%$ 的数据，$0\leq T\leq 10^5$，$1\leq n\leq 10^6$，$0\leq k\leq 100$。

## 样例 #1

### 输入

```
3
3 1
10 2
1 0```

### 输出

```
3
25200
1```

## 样例 #2

### 输入

```
5
502520 0
502520 1
502520 2
502520 3
502520 4```

### 输出

```
1
218102685
429650441
770595802
584122358```

# AI分析结果

### 综合分析与结论
这些题解均围绕题目中带层数限制 $k$ 的归并排序展开。思路上，都基于归并排序的特性，认识到要使最终序列有序，递归到第 $k$ 层的子序列需本身有序。算法要点在于计算第 $k$ 层子序列的数量和大小，进而求出子序列有序的概率，再结合全排列数得出答案。解决难点主要在于处理 $2^k$ 可能溢出的情况，以及在取模运算下计算分数乘法（通过求逆元）。

### 所选的题解
1. **作者：_saltFish_（5星）**
    - **关键亮点**：思路清晰，详细阐述了算法原理，对特殊情况如 $n \le 2^k$ 和 $k = 0$ 以及 $k > 20$ 的特判解释到位，代码简洁明了，注释详细。
    - **重点代码**：
```cpp
ll qpow(ll a,ll b){
    ll s=1;
    while(b){
        if(b&1) s=s*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return s;
}
// 主函数部分
while(t--){
    cin>>n>>k;
    if(k>20||(1<<k)>=n)
        cout<<jc[n]<<'\n';
    else if(k==0)
        cout<<1<<'\n';
    else
        cout<<1ll*qpow(qpow(jc[n/(1<<k)],mod-2)/*逆元*/,1<<k)
            *qpow(qpow(n/(1<<k)+1,mod-2),n%(1<<k))%mod/*此前为求概率（所有第k层子集有序的总概率）*/
            *jc[n]/*全排列数*/%mod<<'\n'; 
}
```
    - **核心实现思想**：`qpow` 函数用于快速幂计算，主函数中根据不同的 $k$ 值进行特判，对于一般情况，通过快速幂求出子序列有序概率对应的逆元，再与全排列数相乘得出答案。
2. **作者：HPXXZYY（4星）**
    - **关键亮点**：结合样例详细解释了算法过程，清晰阐述了递归树底层子序列与最终答案的关系，代码实现规范，变量命名有意义。
    - **重点代码**：
```cpp
inline int ksm(int a,int b){
    register int ret=1;
    while (b){
        if (b&1) ret=1ll*ret*a%mod;
        a=1ll*a*a%mod;b>>=1;
    }
    return ret;
}
inline void init_fac_inv(int n){
    fac[0]=1;
    for(int i=1;i<=n;i++)
        fac[i]=1ll*i*fac[i-1]%mod;
    inv[n]=ksm(fac[n],mod-2);
    for(int i=n;i;i--)
        inv[i-1]=1ll*i*inv[i]%mod;
}
// 主函数部分
if (k>20||(1<<k)>=n){
    printf("%d\n",fac[n]);
    continue;
}
else if (k==0){
    printf("1\n");
    continue;
}
ans=1ll*ksm(inv[n/(1<<k)],(1<<k))*ksm(ksm(n/(1<<k)+1,mod-2),(n%(1<<k)))%mod;
printf("%lld\n",1ll*ans*fac[n]%mod);
```
    - **核心实现思想**：`ksm` 函数实现快速幂，`init_fac_inv` 预处理阶乘及其逆元。主函数根据 $k$ 值特判，一般情况通过快速幂结合逆元计算子序列有序概率与全排列数的乘积。
3. **作者：donotctjuntilAFO（4星）**
    - **关键亮点**：对归并排序和 $k$ 的作用分析准确，代码结构完整，通过不同函数实现快速幂、预处理阶乘及逆元等功能，逻辑清晰。
    - **重点代码**：
```cpp
inline LL power(LL a,LL b){//快速幂
    LL ans=1,bb=a;
    while(b>0){
        if(b&1){
            ans*=bb;
            ans%=mod;
        }
        bb*=bb;
        bb%=mod;
        b>>=1;
    }
    return ans;
}
// 主函数部分
while(t--){
    ans=1;
    scanf("%lld%lld",&n,&k);
    if(k>20||(1<<k)>=n){
        printf("%d\n",jc[n]);
        continue;
    }
    else if(!k){
        printf("1\n");
        continue;
    }
    LL x=power(fjc[n/(1<<k)],(1<<k));
    LL y=power(power(n/(1<<k)+1,mod-2),(n%(1<<k)));
    ans=x*y%mod;
    printf("%lld\n",ans*jc[n]%mod);
}
```
    - **核心实现思想**：`power` 函数快速幂计算，主函数针对不同 $k$ 特判，一般情况利用快速幂求出子序列有序概率相关值，与全排列数相乘得结果。

### 最优关键思路或技巧
1. **利用归并排序特性**：认识到归并排序不改变子序列内部顺序，要使最终序列有序，第 $k$ 层子序列需有序，从而将问题转化为计算子序列有序概率与全排列数的乘积。
2. **处理特殊情况**：针对 $k$ 的不同取值进行特判，如 $k > 20$ 时 $2^k$ 必定大于 $n$，此时答案为 $n!$；$k = 0$ 时只有原序列有序这一种方案。
3. **逆元与快速幂**：在取模运算下，通过快速幂计算逆元来处理分数乘法，高效计算结果。

### 可拓展思路
此类题目属于对经典排序算法进行变形的问题，类似套路是深入理解经典算法的特性，根据题目给定的限制条件，分析数据的变化规律，进而转化为数学计算问题。例如对快速排序进行层数限制、对堆排序改变堆的构建规则等。

### 相似知识点洛谷题目
1. **P1996 约瑟夫问题**：涉及循环链表、模拟算法，与本题类似在于需根据特定规则处理数据，理解规则是解题关键。
2. **P1090 [NOIP2004 提高组] 合并果子**：考查哈夫曼树、贪心算法，和本题一样需要对数据进行特定方式的处理与计算。
3. **P2161 [SHOI2009] 会场预约**：运用线段树、区间覆盖等知识，同样是基于某种数据结构或算法对给定规则的数据进行处理。 

---
处理用时：43.64秒
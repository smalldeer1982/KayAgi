# 题目信息

# [Cnoi2021] 数学练习

## 题目背景

「Cnoi2021」Cirno's Easy Round II 热身赛开始了。

## 题目描述

为了让选手们重视文化课，Cirno 特意加入了一道 Kamishirasawa Keine 老师的数学练习：

> 求将一个集合 $\texttt{U}=\{1,2,3,\cdots,n\}$ 划分成两个子集 $S,T$，使得 $|S|\notin S,|T|\notin T$ 的方案数。

由于选手都不会高精度，所以答案只需要对 $998244353$ 取模即可。

## 说明/提示

**样例解释** 

#1: 两种合法的划分方案为 $\{1,3\},\{2\}$ 与 $\{2\},\{1,3\}$ 。

**数据范围**

对于 $100\%$ 的数据，保证 $1 \le n \le 10^5$。


## 样例 #1

### 输入

```
3```

### 输出

```
2```

## 样例 #2

### 输入

```
6```

### 输出

```
10```

## 样例 #3

### 输入

```
65535```

### 输出

```
459810767```

# AI分析结果

### 综合分析与结论
所有题解思路本质相同，均基于已知条件确定两个元素归属后，利用组合数求解方案数。核心在于推导出方案数与组合数关系，并处理 $n$ 为偶数时的特殊情况。各题解主要差异在组合数计算、快速幂实现及代码细节处理上。

### 所选的题解
1. **作者：3a51_ (5星)**
    - **关键亮点**：思路阐述极为清晰，从设子集元素个数出发，逐步推导组合数表达式，详细解释公式含义，对特殊情况分析到位，代码注释详尽，可读性高。
    - **个人心得**：无
    - **核心代码**：
```cpp
// 预处理阶乘
void init()
{
    jc[0]=jc[1]=1;
    for(int i=1;i<=100005;i++)
        jc[i]=(jc[i-1]%Mod*i%Mod)%Mod; 
}
// 快速幂
int qpow(int a,int b,int c)
{
    int res=1;
    while(b)
    {
        if(b&1)
            res=res*a%Mod;
        b>>=1;
        a=a*a%Mod;
    }
    return res%Mod;
}
// 计算组合数
int C(int a,int b)
{
    return jc[a]%Mod*qpow(jc[b],Mod-2,Mod)%Mod*qpow(jc[a-b],Mod-2,Mod)%Mod;
}
signed main()
{
    int n;
    cin>>n;
    if(n==1)
    {
        cout<<0;
        return 0;
    }
    init();
    int ans=1;
    for(int i=1;i<=n-2;i++)
        ans=(ans*2)%Mod;
    if(n%2==0)
    {
        int m=n-2,j=C(m,m/2);
        ans-=j;
        ans+=Mod;
    }
    cout<<ans%Mod;
    return 0;
}
```
    - **核心实现思想**：先预处理阶乘，通过快速幂计算乘法逆元来求组合数。主函数中先特判 $n = 1$，再计算 $2^{n - 2}$，若 $n$ 为偶数减去特殊情况的组合数。
2. **作者：RockyYue (4星)**
    - **关键亮点**：解题思路简洁明了，直接点明关键条件得出方案数为 $2^{n - 2}$ 并考虑特殊情况，代码使用Lucas定理计算组合数取模，较为巧妙。
    - **个人心得**：无
    - **核心代码**：
```cpp
int qpow(int x, int y) {
    int res = 1;
    while (y) {
        if (y & 1) {
            (res *= x) %= P;
        }
        (x *= x) %= P;
        y >>= 1;
    }
    return res;
}
int C(int n, int m) {
    int a = 1, b = 1;
    for (int i = 1; i <= m; ++i) {
        (a *= i) %= P;
        (b *= n - i + 1) %= P;
    }
    return b * qpow(a, P - 2) % P;
}
int Lucas(int n, int m) {
    return!m? 1 : C(n % P, m % P) * Lucas(n / P, m / P) % P;
}
signed main() {
    ios :: sync_with_stdio(0);
    int n;
    cin >> n;
    if (n == 1) {
        cout << 0 << '\n';
        return 0;
    }
    int res = qpow(2, n - 2);
    if (!(n & 1)) {
        (res -= Lucas(n - 2, n - 2 >> 1) - P) %= P;
    }
    cout << res << '\n';
    return 0;
}
```
    - **核心实现思想**：通过快速幂计算 $2^{n - 2}$ 及组合数中逆元。利用Lucas定理计算组合数取模，主函数特判 $n = 1$ 后根据 $n$ 的奇偶性计算答案。
3. **作者：TernaryTree (4星)**
    - **关键亮点**：从枚举 $|S|$ 入手详细推导方案数公式，结合杨辉三角性质优化式子，代码实现清晰，对边界情况和优化点说明详细。
    - **个人心得**：无
    - **核心代码**：
```cpp
int power(int base, int freq, int mod) {
    int tmp = base, ans = 1;
    while (freq) {
        if (freq & 1) ans = ans * tmp % mod;
        freq >>= 1;
        tmp = tmp * tmp % mod;
    }
    return ans;
}
void init() {
    fac[0] = 1;
    for (int i = 1; i <= maxn; i++) {
        fac[i] = fac[i - 1] * i % mod;
    }
    inv[maxn] = power(fac[maxn], mod - 2, mod);
    for (int i = maxn - 1; i >= 0; i--) {
        inv[i] = inv[i + 1] * (i + 1) % mod; 
    } 
}
int C(int n, int m) {
    if (n < m) return 0;
    return fac[n] * inv[m] % mod * inv[n - m] % mod;
}
signed main() {
    init();
    cin >> n;
    if (n == 1) {
        cout << 0 << endl;
        return 0;
    }
    n -= 2;
    if (n % 2 == 0) {
        cout << (power(2, n, mod) - C(n, n / 2) + mod) % mod; 
    } else {
        cout << power(2, n, mod); 
    }
    return 0;
}
```
    - **核心实现思想**：先预处理阶乘和逆元，通过快速幂计算 $2^{n - 2}$ 及组合数。主函数中特判 $n = 1$ 后根据 $n - 2$ 的奇偶性计算答案。

### 最优关键思路或技巧
1. **思维方式**：通过条件 $|S|\notin S,|T|\notin T$ 快速得出 $|S|\in T,|T|\in S$，从而确定两个元素归属，简化问题为组合问题。
2. **公式推导与优化**：将方案数的组合数求和式子利用二项式定理或杨辉三角性质优化为 $2^{n - 2}$，降低计算量。
3. **代码实现**：利用快速幂计算逆元来处理组合数中的除法取模运算，提高效率。同时预处理阶乘及逆元，避免重复计算。

### 可拓展之处
此类题目属于组合数学中集合划分计数问题，相似套路为根据条件确定部分元素位置，转化为组合问题求解，再考虑特殊情况。常见变化为改变集合划分条件或元素限制，如划分成多个子集、元素有特定归属要求等。

### 相似知识点洛谷题目
1. **P3807 【模板】卢卡斯定理**：考察Lucas定理在组合数取模中的应用。
2. **P1313 计算系数**：结合组合数与快速幂求多项式系数。
3. **P2822 [NOIP2016 提高组] 组合数问题**：涉及组合数性质及前缀和优化。 

---
处理用时：42.92秒
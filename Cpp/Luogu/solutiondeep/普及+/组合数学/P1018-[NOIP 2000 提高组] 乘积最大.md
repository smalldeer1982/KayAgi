# 题目信息

# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解采用动态规划（DP），通过定义状态和状态转移方程来求解最大乘积。部分题解使用深度优先搜索（DFS），枚举乘号插入位置并计算乘积取最大值。
    - 算法要点：DP题解中，状态定义通常为前i个数插入j个乘号的最大乘积，状态转移方程通过枚举乘号位置来构建。DFS题解则是递归搜索乘号位置，同时进行剪枝优化。
    - 解决难点：由于数字串长度可达40，结果数值大，需使用高精度算法处理乘法、比较等操作。

    - 总体来看，DP解法时间复杂度一般为O(n^2k)，空间复杂度为O(nk)；DFS解法时间复杂度较高，但适当剪枝可优化。多数题解思路正确，但在代码清晰度和优化程度上有所差异。

  - 作者：liar_white (4星)
    - 关键亮点：思路清晰，详细阐述每个步骤。使用结构体存储高精度数据，代码结构清晰，对高精度的取数、乘法、比较操作分别封装成函数，易理解。
    - 个人心得：“离noip只剩2天却仍在与普及组题目奋战”，花费半上午完成该题解。
    - 核心代码（高精度乘法函数）：
```cpp
node mul(node e1,node e2){//高精度乘法
    node emul;
    emul.exi=true;emul.v=e1.v+e2.v-1;
    for(int i=1;i<=emul.v;i++) emul.c[i]=0;
    for(int i=1;i<=e1.v;i++)
        for(int j=1;j<=e2.v;j++)
            emul.c[i+j-1]+=e1.c[i]*e2.c[j];
    int q=0;        
    for(int i=1;i<=emul.v;i++){
        emul.c[i]+=q;
        q=emul.c[i]/10;
        emul.c[i]%=10;
    }
    while(q>0){
        emul.c[++emul.v]=q%10;
        q/=10;
    }
    return emul;
}
```
  - 作者：FastIO_DP (4星)
    - 关键亮点：思路清晰，详细推导状态转移方程，代码实现简洁明了。通过重载运算符实现高精度运算，使代码可读性增强。
    - 核心代码（高精度乘法运算符重载）：
```cpp
BI operator*(const BI& o) const {
    BI res;
    for (int i = 0; i < len; ++i) {
        int c = 0;
        for (int j = 0; j < o.len; ++j) {
            int p = d[i] * o.d[j] + res.d[i + j] + c;
            res.d[i + j] = p % 10;
            c = p / 10;
        }
        if (c) {
            res.d[i + o.len] += c;
        }
    }
    res.len = len + o.len;
    while (res.len > 1 && res.d[res.len - 1] == 0) {
        res.len--;
    }
    return res;
}
```
  - 作者：kuaiCreator (4星)
    - 关键亮点：详细阐述划分型动态规划的思路，从状态定义、子问题分解、初始化到计算顺序，逻辑清晰，还给出了时间和空间复杂度分析。
    - 核心代码（动态规划部分）：
```cpp
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {     //j<i表示i个数最多插入i-1个乘号
        if (j >= i) break;  //前i个元素不能被插入j个隔板分成j+1份
        for (int k = j; k < i; k++)    //前k个元素最多插入j-1个符号故k从j开始枚举
            dp[i][j] = max(dp[i][j], dp[k][j - 1] * num[k + 1][i]);
    }
```
• 最优关键思路或技巧：
    - 动态规划状态定义技巧：合理定义状态，如dp[i][j]表示前i个数插入j个乘号的最大乘积，能有效简化问题，方便构建状态转移方程。
    - 高精度算法实现：通过结构体或类封装高精度数据及运算，如重载乘法运算符，提高代码可读性和可维护性。
    - 剪枝优化：DFS解法中，通过可行性剪枝，如保证后面乘号有位置可占，减少无效搜索，提高效率。
• 可拓展之处：
此类题目属于组合优化问题，类似的算法套路可用于字符串划分求最值、序列分割等问题。可通过改变状态定义和转移方程适应不同场景。
• 相似知识点洛谷题目：
    - P1880 [NOI1995] 石子合并，区间DP，合并石子求最值。
    - P3146 [USACO16OPEN] 248 G，区间DP，合并数字求最大数字。
    - P1063 [NOIP2006 提高组] 能量项链，区间DP，合并珠子求最大能量。 

---
处理用时：44.81秒
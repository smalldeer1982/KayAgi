# 题目信息

# 开灯

## 题目描述

在一条无限长的路上，有一排无限长的路灯，编号为 $1,2,3,4,\dots$。

每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。

在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：

指定两个数，$a,t$（$a$ 为实数，$t$ 为正整数）。将编号为 $\lfloor a\rfloor,\lfloor 2 \times a\rfloor,\lfloor3 \times a\rfloor,\dots,\lfloor t  \times a\rfloor$ 的灯的开关各按一次。其中 $\lfloor k \rfloor$ 表示实数 $k$ 的整数部分。

在小明进行了 $n$ 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。

幸好，小明还记得之前的 $n$ 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？


## 说明/提示

记 $T=\sum \limits_{i=1}^n t_i = t_1+t_2+t_3+\dots+t_n$。

- 对于 $30\%$ 的数据，满足 $T \le 1000$；
- 对于 $80\%$ 的数据，满足 $T \le 200000$；
- 对于 $100\%$ 的数据，满足 $T \le 2000000$；
- 对于 $100\%$ 的数据，满足 $n \le 5000$，$1 \le a_i<1000$，$1 \le t_i \le T$。

数据保证，在经过 $n$ 次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的 $i$ 来说，$t_i\times a_i$ 的最大值不超过 $2000000$。

## 样例 #1

### 输入

```
3
1.618034 13
2.618034 7
1.000000 21```

### 输出

```
20```

# AI分析结果

### 综合分析与结论
这些题解主要分为模拟法和位运算法。模拟法思路简单，直接用数组模拟路灯开关状态，按题目操作改变状态后找出开灯的编号。但该方法时间复杂度较高，为O(n * ti)，不过由于本题数据范围较小，不会超时。位运算法利用异或运算特性，因为只有一盏灯开着，其他编号出现次数成对，异或后为0，剩下的就是开灯编号，效率更高。

### 所选的题解
- **作者：Hamster_Air (赞：223)  星级：5星**
    - **关键亮点**：使用位运算异或操作，代码简洁高效，利用异或特性巧妙解决问题，避免模拟法的复杂操作。
    - **核心代码**：
```cpp
#include<bits/stdc++.h> 
#define f(i,j,n) for(i=j;i<=n;i++) 
using namespace std;
int main()
{
    ios::sync_with_stdio(false); 
    int n,t,i,j,ans=0;
    double a; 
    cin>>n;
    f(i,1,n)
    {
        cin>>a>>t;
        f(j,1,t)
            ans^=int(j*a); 
    }
    cout<<ans<<endl; 
    return 0; 
}
```
    - **核心思想**：初始化ans为0，每次读入a和t后，对范围内编号进行异或操作，最终ans即为开灯编号。
- **作者：雨竹 (赞：187)  星级：5星**
    - **关键亮点**：详细解释异或运算原理，便于理解，代码实现清晰。
    - **核心代码**：
```cpp
#include<cstdio>  
#include<cstring>  
#include<cmath>  
#include<algorithm>  
  
using namespace std;  
  
int n,t;  
double a;  
  
int main()  
{  
    int ans=0;  
    scanf("%d",&n);  
    while (n--)  
    {  
        scanf("%lf",&a);
        scanf("%d",&t);  
        for (int i=1;i<=t;i++)  
        {  
            int x=(int)floor(a*i);  
            ans^=x;  
        }  
    }  
    printf("%d",ans);  
    return 0;  
}  
```
    - **核心思想**：与上一解法类似，通过循环读入操作数据，对编号进行异或，利用异或性质得出开灯编号。
- **作者：shanjb0221 (赞：3)  星级：4星**
    - **关键亮点**：提出对相同操作去重的优化思路，减少计算量，提高效率。
    - **核心代码**：
```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
const int N=5e3+5;
int ans,n;
pair<double,int> a[N];
char del[N];
int main() {
	scanf("%d",&n);
	for(int i=0; i<n; ++i)scanf("%lf%d",&a[i].first,&a[i].second);
	sort(a,a+n);
	for(int i=0; i+1<n; ++i)
		if(!del[i]&&a[i]==a[i+1])del[i]=del[i+1]=1;
	for(int i=0; i<n; ++i)if(!del[i])
			for(int j=1; j<=a[i].second; ++j)ans^=int(a[i].first*j);
	printf("%d\n",ans);
}
```
    - **核心思想**：先对操作数据排序，标记相同操作，之后对未标记操作进行异或运算得到开灯编号。

### 最优关键思路或技巧
位运算中的异或操作是本题较优解法，利用其特性简化计算过程。对相同操作去重的优化方法也能提高效率，在处理大规模数据时尤为重要。

### 可拓展之处
同类型题可考察对特定运算性质的应用，或在大规模数据下优化模拟算法。类似算法套路是挖掘题目中数据特性，利用相关运算性质简化操作，如利用异或运算解决有配对特性的数据问题。

### 相似知识点洛谷题目
- [P1315 观光公交](https://www.luogu.com.cn/problem/P1315)：涉及时间优化和贪心策略，与本题优化思路有相似处。
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：可使用归并排序或树状数组解决，与本题对数据处理和算法选择有相似思考方向。
- [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)：考察树状数组这一数据结构，与本题在数据结构选择和应用上有类似思维。

### 个人心得摘录与总结
- **作者万家铭**：调试发现将实数乘积取整的错误，强调仔细审题的重要性，尤其对数据类型和计算要求需关注。 

---
处理用时：41.07秒
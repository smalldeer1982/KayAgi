# 题目信息

# 日志分析

## 题目描述

M 海运公司最近要对旗下仓库的货物进出情况进行统计。目前他们所拥有的唯一记录就是一个记录集装箱进出情况的日志。该日志记录了两类操作：第一类操作为集装箱入库操作，以及该次入库的集装箱重量；第二类操作为集装箱的出库操作。这些记录都严格按时间顺序排列。集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为当前在仓库里所有集装箱中最晚入库的集装箱。

出于分析目的，分析人员在日志中随机插入了若干第三类操作――查询操作。分析日志时，每遇到一次查询操作，都要报告出当前仓库中最大集装箱的重量。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，有 $N \le 10$；
- 对于 $40\%$ 的数据，有 $N \le 1000$；
- 对于 $100\%$ 的数据，有 $1 \le N \le 200000$，$1 \le X \le 10^8$。


## 样例 #1

### 输入

```
13
0 1
0 2
2
0 4
0 2
2
1
2
1
1
2
1
2
```

### 输出

```
2
4
4
1
0
```

# AI分析结果

• 综合分析与结论：
  这些题解均围绕栈结构解决日志分析问题，核心是在栈的入栈、出栈操作基础上实现高效查询最大值。主要思路有：1. 维护辅助数组或栈记录最大值，入栈时更新，出栈和查询时直接获取；2. 利用优先队列、平衡树、multiset等数据结构辅助；3. 链表模拟栈操作。各题解在思路清晰度、代码可读性、优化程度上有差异。
  最优关键思路：在栈操作基础上，通过辅助结构（数组、栈等）记录当前栈内最大值，入栈时根据新元素与当前最大值比较决定是否更新辅助结构，出栈时同步调整，查询时直接获取辅助结构记录的最大值，实现$O(1)$时间复杂度查询。
  可拓展之处：此类题目可拓展到对栈结构操作及特定状态查询的场景，类似算法套路为用辅助结构记录关键状态信息，优化查询操作。

  推荐题目：
  1. P1427 小鱼的数字游戏，考察栈的基本操作。
  2. P1739 表达式括号匹配，利用栈判断表达式括号是否匹配。
  3. P3952 时间复杂度，结合栈与代码逻辑分析时间复杂度。

  个人心得摘录与总结：
  - 作者Garrison：在洛谷编译器中`++tot;a[tot]=a[tot - 1];`和`a[++tot]=a[tot - 1]`不等价，部分评测系统计算顺序不同，写代码时要注意运算符顺序。
  - 作者准点的星辰：初次直接模拟导致TLE，后通过两个优先队列和一个栈保证数据一致性实现题目要求，尝试不同方法解决问题。
  - 作者ylwhxht：用结构体存重量和当前最大值，出库时忘改MAX致WA，做题要注意细节。

  所选4星及以上题解：
  - 作者medusa (4星)
    - 关键亮点：思路清晰，直接设$f[i]$为栈中从下到上$i$个元素中的最大值，入栈更新$f[t]=max(f[t - 1], x)$，出栈和查询直接输出对应$f$值。
    - 重点代码核心思想：定义数组$f$记录最大值，根据操作类型进行入栈、出栈和查询操作，入栈更新最大值，出栈减少栈顶索引，查询输出当前最大值。
    ```cpp
    int f[200001],n,x,y,t=0;   
    int main()   
    {   
        cin>>n;   
        f[0]=0;   
        for (int i=1; i<=n; i++)   
        {   
            cin>>x;   
            if (x==0)    
            {   
                cin>>y;   
                t++;   
                f[t]=max(f[t-1],y);   
            }   
            if (x==1) if (t!=0) t--;   
            if (x==2) cout<<f[t]<<endl;   
        }   
        return 0;   
    }  
    ```
  - 作者buickboy (4星)
    - 关键亮点：引入辅助栈记录栈当前最大值，入栈时根据新元素与辅助栈顶比较决定是否更新辅助栈，清晰易懂。
    - 重点代码核心思想：用两个栈，主栈存数据，辅助栈同步存对应最大值，入栈时判断新元素与辅助栈顶大小决定辅助栈操作，出栈时两栈同步弹出，查询输出辅助栈顶元素。
    ```cpp
    stack<int>a;
    stack<int>b;
    int n,m,x;
    int main()
    {
        scanf("%d",&n);
        while(n--)
        {
            scanf("%d",&m);
            if(m==0)
            {
                scanf("%d",&x);
                a.push(x);
                if(b.empty()||x>b.top())
                    b.push(x);
                else b.push(b.top());
            }
            else if(m==1)
            {
                a.pop();
                b.pop();
            }
            else
            {
                if(b.empty()) printf("0\n");
                else printf("%d\n",b.top());		
            }			
        }
        return 0;
    }
    ```
  - 作者felixwu (4星)
    - 关键亮点：代码简洁，用数组模拟栈，`a[top]`维护包括栈顶元素的最大值，`a[top - 1]`维护小于栈顶元素的最大值，操作直观。
    - 重点代码核心思想：定义数组模拟栈，实现入栈、出栈函数，入栈时更新最大值数组，出栈减少栈顶索引，查询输出当前栈顶最大值。
    ```cpp
    int q[1000001],top,a[1000001],m,n,k;
    void push(int x){q[++top]=x;}
    void pop(){top--;}
    int main()
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            scanf("%d",&m);
            if(m==0) {
                scanf("%d",&k);
                push(k);
                a[top]=max(a[top-1],k);
            }
            if(m==1) pop(); 
            if(m==2) printf("%d\n",a[top]);
        }
        return 0;
    }	
    ```

---
处理用时：35.68秒
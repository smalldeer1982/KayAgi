# 题目信息

# 小朋友的球

## 题目描述

@发源于 小朋友最近特别喜欢球。有一天他脑子抽了，从口袋里拿出了 $N$ 个不同的球，想把它们放到 $M$ 个相同的盒子里，并且要求每个盒子中至少要有一个球，他好奇有几种放法，于是尝试编程实现，但由于他天天不好好学习，只会上 B 站看游泳教练，于是他向你求助。

## 说明/提示

- 对于 $20\%$ 的数据，满足 $N,M \leq 10$；
- 对于 $100\%$ 的数据，满足 $1 \leq N,M \leq 100$，一个测试文件最多有 $10$ 组测试数据。


## 样例 #1

### 输入

```
4 2
1 1```

### 输出

```
7
1```

# AI分析结果

### 综合分析与结论
所有题解均指出本题可归结为求第二类斯特林数问题，核心思路是利用状态转移方程 `f[i][j]=f[i - 1][j - 1]+f[i - 1][j]*j` 进行动态规划求解，难点在于数据范围导致结果可能超出常规数据类型范围，需使用高精度运算。各题解主要区别在于高精度运算的实现方式以及代码风格和细节处理。

### 所选的题解
- **作者：Heartlessly (5星)**
    - **关键亮点**：思路清晰，先点明算法为动态规划结合高精度运算，与类似题目做对比，状态转移方程解释明确。代码实现上，将高精度加法和乘法封装成函数，逻辑清晰，可读性强。
    - **重点代码 - 核心实现思想**：通过 `add` 函数实现高精度加法，`mul` 函数实现高精度乘法，在状态转移时调用这两个函数完成高精度运算。
```cpp
string add(string a,string b){
    string ans;
    int na[L]={0},nb[L]={0};
    int la=a.size(),lb=b.size();
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';
    int lmax=la>lb?la:lb;
    for(int i=0;i<lmax;i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;
    if(na[lmax]) lmax++;
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';
    return ans;
}
string mul(string a,int b){
    string ans;
    int La=a.size();
    fill(na,na+L,0);
    for(int i=La-1;i>=0;i--) na[La-i-1]=a[i]-'0';
    int w=0;
    for(int i=0;i<La;i++) na[i]=na[i]*b+w,w=na[i]/10,na[i]=na[i]%10;
    while(w) na[La++]=w%10,w/=10;
    La--;
    while(La>=0) ans+=na[La--]+'0';
    return ans;
}
// 状态转移
for ( int i = 1; i <= 100; i++ )
    f[i][1] = "1";
for ( int i = 2; i <= 100; i++ )
    for ( int j = 1; j <= i; j++ )
        f[i][j] = add ( f[i-1][j-1], mul ( f[i-1][j], j ) );
```
- **作者：HPXXZYY (4星)**
    - **关键亮点**：详细列出预备算法，对状态转移方程的解释和代码注释较为详细，通过重载运算符实现高精度运算，使用起来较为方便。
    - **重点代码 - 核心实现思想**：定义 `node` 结构体表示高精度数，重载 `+` 和 `*` 运算符实现高精度加法和乘法，在状态转移时直接使用重载后的运算符。
```cpp
struct node{
    int len,num[1100];
    node(){
        len=0;init(num,0);
    }
    node operator + (node a){
        register node c;
        register int x=0,i;
        c.len=max(this->len,a.len);
        for(i=1;i<=c.len;i++){
            c.num[i]=a.num[i]+this->num[i]+x;
            x=c.num[i]/10;c.num[i]%=10;
        }
        if (x) c.num[++c.len]=x;
        return c;
    }
    node operator * (int a){
        register node c=*this;
        register int x=0,i;
        for(i=1;i<=c.len;i++){
            c.num[i]=c.num[i]*a+x;
            x=c.num[i]/10;c.num[i]%=10;
        }
        while (x){
            c.num[++c.len]=x%10;x/=10;
        }
        return c;
    }
    void write(){
        for(int i=len;i;i--)
            printf("%d",num[i]);
        printf("\n");
    }
}f[110][110];
// 状态转移
for(i=1;i<101;i++){
    f[i][1].len=1;
    f[i][1].num[1]=1;
}
for(i=2;i<101;i++)
    for(j=1;j<=i;j++)
        f[i][j]=f[i-1][j-1]+(f[i-1][j]*j);
```
- **作者：ergeda (4星)**
    - **关键亮点**：对斯特林数的递推公式来源进行了详细解释，代码实现中对高精度运算的结构体和运算符重载的处理较为规范，给出了一组测试数据方便验证。
    - **重点代码 - 核心实现思想**：定义 `node` 结构体表示高精度数，重载 `+` 和 `*` 运算符实现高精度加法和乘法，按照递推公式进行状态转移。
```cpp
struct node{
    ll a[500],len;
    node(){mm(a,0);len=0;}
};
node operator + (node c,node d){
    node h;h.len=maxx(c.len,d.len);
    int i;
    for(i=1;i<=h.len;i++){
        h.a[i]+=c.a[i]+d.a[i];
        if(h.a[i]>=10){
            h.a[i+1]+=h.a[i]/10;
            h.a[i]%=10;
            if(i==h.len)h.len++;
        }
    }
    return h;
}
node operator * (node c,ll u){
    node h;h.len=c.len;
    int i;
    for(i=1;i<=h.len;i++){
        h.a[i]+=c.a[i]*u;
        if(h.a[i]>=10){
            h.a[i+1]+=h.a[i]/10;
            h.a[i]%=10;
            if(i==h.len)h.len++;
        }
    }
    return h;
}
// 状态转移
For(i,1,100)t[i][0].a[1]=0,t[i][i].a[1]=t[i][1].a[1]=1,t[i][0].len=t[i][i].len=t[i][1].len=1;
For(i,2,100){
    For(j,2,i-1){
        t[i][j]=t[i-1][j-1]+t[i-1][j]*j;
    }
}
```

### 最优关键思路或技巧
- **动态规划思路**：通过分析问题，将其转化为子问题，利用状态转移方程 `f[i][j]=f[i - 1][j - 1]+f[i - 1][j]*j` 逐步求解。
- **高精度运算实现**：采用自定义结构体表示高精度数，并通过重载运算符或封装函数的方式实现高精度加法和乘法运算。

### 可拓展之处
同类型题常涉及不同物品放入不同容器且有各种限制条件的组合问题，类似算法套路为分析状态转移关系，结合高精度运算（当数据范围大时）。例如将不同的物品放入不同的背包，要求背包有一定容量限制等。

### 相似知识点洛谷题目
- **P2386 放苹果**：同样是放物品问题，但本题盒子可以为空，与本题有一定关联和对比性。
- **P1025 数的划分**：将整数划分成若干个正整数之和，与本题划分问题思路类似。
- **P1287 盒子与球**：涉及不同球放入不同盒子的方案数问题，可进一步巩固此类知识点。

### 个人心得摘录
- **作者：ergeda**：注意当 `m>n||m==0` 时直接输出 `0`，因为这个wa了好多次。总结为处理此类问题要注意边界条件的判断，避免因边界情况考虑不周全而导致错误。 

---
处理用时：68.64秒
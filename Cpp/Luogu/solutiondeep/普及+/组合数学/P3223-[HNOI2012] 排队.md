# 题目信息

# [HNOI2012] 排队

## 题目描述

某中学有 $n$ 名男同学，$m$ 名女同学和两名老师要排队参加体检。他们排成一条直线，并且任意两名女同学不能相邻，两名老师也不能相邻，那么一共有多少种排法呢？（注意：任意两个人都是不同的）


## 说明/提示

对于 $30\%$ 的数据 $n\leq 100$，$m\leq 100$。

对于 $100\%$ 的数据 $n\leq 2000$，$m\leq 2000$。


## 样例 #1

### 输入

```
1  1```

### 输出

```
12```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解采用分类讨论的方法。一类是老师被男生隔开，先排男生，再让老师插男生的空，最后女生插剩余的空；另一类是老师被女生隔开，常将老师和中间女生看作整体处理。Youngore和牛瓜瓜则先不考虑老师相邻，用插空法算出总数，再减去老师相邻的情况。
    - 算法要点在于排列组合公式的运用，如 \(A_{n}^{m}=\frac{n!}{(n - m)!}\) 计算排列数，以及高精度计算，因为结果数值较大。
    - 解决难点主要是全面考虑各种排列情况，不重不漏。同时，高精度计算的实现和优化也有一定难度。

    - 整体来看，各题解思路相近，差异主要在实现细节和代码风格上。

• 所选的题解：
  - **作者Youngore (5星)**：
    - **关键亮点**：思路简洁清晰，通过“老师不相邻 = 不考虑老师相邻 - 老师相邻”的方式，避免复杂的分类讨论，直接利用插空法和捆绑法得出答案式子，计算量相对较小，代码实现简单。
    - **重点代码核心思想**：分别计算不考虑老师相邻和老师相邻时的排列数，最后做差得到结果。无代码，仅给出数学式子。
  - **作者萝卜 (4星)**：
    - **关键亮点**：从高中排列组合基础出发，详细分析两种情况，思路易理解。代码实现采用压位高精度乘法，在一定程度上优化了计算。
    - **重点代码核心思想**：`mul` 函数实现压位高精度乘法，主函数通过多次调用 `mul` 函数计算不同排列组合的乘积，最后输出结果。
```cpp
void mul(int x)
{
    long long pre(0),tem;
    for(int i=1;i<=len;i++)
    {
        tem=ans[i]*x;
        ans[i]=tem%p+pre;
        pre=tem/p;
    }
    if(pre){len++;ans[len]=pre;};
}
int main(){
    scanf("%d%d",&n,&m);
    ans[1]=1;
    mul(n+1);mul(n*(n+3)+2*m);
    for(int i=1;i<=n;i++)mul(i);
    for(int i=n-m+4;i<=n+2;i++)mul(i);
    printf("%lld",ans[len]);
    while(--len)printf("%010lld",ans[len]);
    return 0;
}
```
  - **作者12mango (4星)**：
    - **关键亮点**：公式清晰，通过插空法全面考虑情况得出公式。代码使用结构体重载运算符实现高精度计算，代码结构清晰，可读性较好。
    - **重点代码核心思想**：`NUM` 结构体重载 `+`、`*` 等运算符实现高精度运算，`A` 函数计算排列数，`C` 函数计算组合数，主函数调用这些函数计算最终结果。
```cpp
struct NUM
{
    vector<ll>val;    
    NUM(){val.clear();val.resize(1,0);}
    void clear(){while(!val.back()&&val.size()>1) val.pop_back();}
    NUM operator+(NUM b)
    {
        NUM a=*this,c;
        int len1=a.val.size();
        int len2=b.val.size();
        int len3=max(len1,len2)+1;
        c.val.resize(len3,0);
        for(int i=0;i<len3;++i){
            if(i<len1) c.val[i]+=a.val[i];
            if(i<len2) c.val[i]+=b.val[i];
            if(i<len3-1){
                c.val[i+1]+=c.val[i]/mod;
                c.val[i]%=mod;
            }
        }
        c.clear();
        return c;
    }
    NUM operator*(const int x){
        NUM a=*this;
        int ret=0;
        for(int i=0;i<a.val.size();++i){
            a.val[i]*=x;
            a.val[i]+=ret;
            ret=a.val[i]/mod;
            a.val[i]%=mod;
        }
        a.val.push_back(ret);
        a.clear();
        return a;
    }
    // 其他重载运算符代码省略
}; 
NUM A(int n,int m)
{
    NUM zero;
    if(m>n) return zero;
    NUM ret;
    ret.val[0]=1;
    for(int i=n-m+1;i<=n;++i) ret*=i;
    return ret;
}
NUM C(int n,int m)
{
    NUM zero;
    if(m>n) return zero;
    NUM ret;
    ret.val[0]=1;
    for(int i=n-m+1;i<=n;++i) ret*=i;
    for(int i=1;i<=m;++i) ret/=i;
    return ret;
}
int main()
{
    int n,m;
     scanf("%d%d",&n,&m);
     if(!n&&!m){
         printf("0");
         return 0;
     }
    NUM ans=A(n,n)*A(n+1,2)*A(n+3,m)+A(n,n)*C(m,1)*A(2,2)*C(n+1,1)*A(n+2,m-1);
    ans.output();
    return 0;
}
```

• 最优关键思路或技巧：
    - **思维方式**：像Youngore那样，通过转化问题，将老师不相邻问题转化为不考虑老师相邻和老师相邻两种情况的差，简化分类讨论。
    - **代码实现技巧**：在高精度计算中，采用压位技巧（如萝卜的题解）可减少高精度数组的长度，提高计算效率；使用结构体重载运算符（如12mango的题解）能使高精度代码结构更清晰，可读性增强。

• 可拓展之处：
同类型题常考察排列组合与计数原理结合，类似算法套路是先确定一个相对简单的排列，再通过插空、捆绑等方法处理受限元素。例如，在人员排队问题中增加更多限制条件，如特定人员必须相邻或间隔特定人数等。

• 相似知识点洛谷题目：
    - P1036 [NOIP2002 普及组] 选数：涉及组合数计算和高精度。
    - P1876 [USACO06NOV]玉米田Corn Fields：结合状态压缩和计数原理。
    - P2704 [NOI2001] 炮兵阵地：状态压缩动态规划与计数问题。

• 个人心得：
无明显个人心得（调试/顿悟）相关内容。 

---
处理用时：39.50秒
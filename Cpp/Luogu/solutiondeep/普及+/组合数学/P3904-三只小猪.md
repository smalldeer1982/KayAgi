# 题目信息

# 三只小猪

## 题目背景

你听说过三只小猪的故事吗？这是一个经典的故事。很久很久以前，有三只小猪。第一只小猪用稻草建的房子，第二个小猪用木棍建的房子，第三个小猪则使用砖做为材料。一只大灰狼想吃掉它们并吹倒了稻草和木棍建的房子。但是砖盖的房子很结实，狼最终也没有破坏掉，最后小猪们战胜了大灰狼并把它尾巴烧掉了。


## 题目描述

为了自己的安全，小猪们又建造了一个新砖房。但是现在问题出现了，怎样把三个小猪分配到两个房子里呢？第三只小猪是三只小猪中最聪明的一只，为了不浪费任何一个房子，它总共考虑了三种方案，如下图

 ![](https://cdn.luogu.com.cn/upload/pic/6862.png) 

“但是将来怎么办呢？”第三只小猪知道将来随着成员的增多，它们将会盖更多的房子。它想知道给定了房子和猪的数目后，房子的分配方案有多少，但这个问题对于它来说，很明显有点难了，你能帮小猪解决这个问题吗？


## 样例 #1

### 输入

```
4 2```

### 输出

```
7```

## 样例 #2

### 输入

```
6 7```

### 输出

```
0```

# AI分析结果

### 综合分析与结论
这些题解均围绕将\(n\)只小猪分配到\(m\)个房子的方案数计算问题，核心思路为利用第二类斯特林数求解。
 - **思路**：通过分析第\(n\)只小猪的放置情况，得出状态转移方程\(S(n,m)=S(n - 1,m - 1)+m\times S(n - 1,m)\)。即第\(n\)只小猪要么单独放入新房间（方案数\(S(n - 1,m - 1)\)），要么放入已有小猪的房间（方案数\(m\times S(n - 1,m)\)）。
 - **算法要点**：构建二维数组存储中间结果，按状态转移方程递推计算。
 - **解决难点**：因数据范围较大，结果数值可能很大，需使用高精度算法，如高精度加法、高精度乘法。

综合来看，各题解思路清晰，但在代码可读性、优化程度上存在差异。

### 所选的题解
 - **作者：xrk2006 (赞：15)  星级：4星**
    - **关键亮点**：思路阐述详细，先介绍题目相关背景知识，如与其他类似题目的联系、放球问题知识点等，再深入讲解第二类斯特林数的定义、递推式，最后给出代码实现，逻辑连贯。代码中对高精度加法和乘法函数进行详细注释，可读性强。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：通过二维数组\(s\)存储第二类斯特林数，利用高精度加法\(add\)和高精度乘法\(mul\)函数，按递推方程\(s[i][j]=add(s[i - 1][j - 1],mul(s[i - 1][j],j))\)计算结果。
```cpp
//luoguP3904
#include<iostream>
#include<cmath>
using namespace std;
const int maxn=55;
int n,m;
string s[maxn][maxn];
string add(string a,string b)//高精度加法
{
    string ans;
    int l1=a.size(),l2=b.size();
    int lk=max(l1,l2);//选a和b里面长度最大的作为最终字符串长度
    int u[maxn*10]={0},v[maxn*10]={0};
    for(int i=0;i<l1;i++)u[l1-i-1]=a[i]-'0';
    for(int i=0;i<l2;i++)v[l2-i-1]=b[i]-'0';//字符串转数组
    for(int i=0;i<lk;i++)
    {
        u[i]+=v[i];
        u[i+1]+=u[i]/10;
        u[i]%=10;
    }//模拟加法运算
    if(u[lk])lk++;//当出现进位时，长度++
    for(int i=lk-1;i>=0;i--)ans+=u[i]+'0';//重新转成字符串
    return ans;
}
string mul(string a,int b)//高精a*单精b（大部分与加法相同，故不做注释）
{
    string ans;
    int l=a.size();
    int u[maxn*10]={0};
    for(int i=l-1;i>=0;i--)u[l-i-1]=a[i]-'0';
    int w=0;
    for(int i=0;i<l;i++)
    {
        u[i]=u[i]*b+w;
        w=u[i]/10;
        u[i]%=10;
    }
    while(w)u[l++]=w%10,w/=10;//注意这里与加法不同，是while循环而不是if特判，想一想为什么？
    for(int i=l-1;i>=0;i--)ans+=u[i]+'0';
    return ans;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)s[i][1]="1";//初始化
    for(int i=1;i<=n;i++)
    {
        s[i][i]="1";
        for(int j=2;j<=m;j++)
        {
            s[i][j]=add(s[i-1][j-1],mul(s[i-1][j],j));//递推方程
        }
    }
    if(n<m)cout<<"0"<<endl;//注意特判
    else cout<<s[n][m]<<endl;
    return 0;
}
```
 - **作者：bloodstalk (赞：5)  星级：4星**
    - **关键亮点**：先详细阐述第二类斯特林数的定义和递推公式，并结合本题具体说明推导过程，逻辑清晰。代码使用结构体数组存储高精度结果，对高精度乘法的实现较为简洁明了。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：用三维数组\(S\)存储第二类斯特林数的每一位，\(L\)数组记录位数，通过\(calc\)函数按递推方程计算，最后输出结果。
```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define next nxt
#define re register
#define il inline
const int N = 50 + 5;
using namespace std;
int max(int x,int y){return x > y? x : y;}
int min(int x,int y){return x < y? x : y;}

int n,m;
int S[N][N][105],L[N][N];

il int read()
{
    int f=0,s=0;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) f |= (ch=='-');
    for(; isdigit(ch);ch=getchar()) s = (s<<1) + (s<<3) + (ch^48);
    return f? -s : s;
}

il void calc(int x,int y)
{
    L[x][y] = max(L[x-1][y-1],L[x-1][y]);
    for(re int i=1;i<=L[x][y];i++)
    {
        S[x][y][i] += S[x-1][y-1][i] + y * S[x-1][y][i];
        S[x][y][i+1] += S[x][y][i] / 10;
        S[x][y][i] %= 10;
    }
    if(S[x][y][L[x][y]+1] > 0) L[x][y]++;//看看能不能更新最高位
    while(S[x][y][L[x][y]] >= 10)
    {
        S[x][y][L[x][y]+1] = S[x][y][L[x][y]] / 10;
        S[x][y][L[x][y]] %= 10;
        L[x][y]++;
    }
}

signed main()
{
    S[0][0][1] = 1, L[0][0] = 1;
    n = read(), m = read();
    if(!m || m > n) return printf("0"),0;//特判等于0的情况
    for(re int i=1;i<=n;i++)
        for(re int j=1;j<=min(i,m);j++)
            calc(i,j);
    for(re int i=L[n][m];i>=1;i--) cout << S[n][m][i];
    return 0;
}
```
 - **作者：Yyxxxxx (赞：1)  星级：4星**
    - **关键亮点**：解题思路清晰，先点明题意是第二类斯特林数问题，再分情况详细推导递推公式，代码实现中使用结构体存储高精度数组，对高精乘和高精加函数进行封装，代码结构清晰。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：定义结构体\(node\)存储高精度数，通过\(mul\)和\(add\)函数实现高精度乘法和加法，按递推公式\(f[i][j]=add(mul(f[i - 1][j],j),f[i - 1][j - 1])\)计算结果并输出。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int len,s[100];
}f[55][55];//结构体存高精数组
int n,m;
node mul(node a,int b)//普通高精乘
{
    node ans;int len=a.len;
    memset(ans.s,0,sizeof(ans.s));//清空！谨记！
    for(int i=1;i<=len;i++)
        ans.s[i]=a.s[i]*b;
    for(int i=1;i<=len;++i)
    {
        if(i==len&&ans.s[i]>=10)++len;
        ans.s[i+1]+=ans.s[i]/10;
        ans.s[i]%=10;
    }
    ans.len=len;
    return ans;
}
node add(node a,node b)//普通高精加
{
    node ans;int len=max(a.len,b.len);
    memset(ans.s,0,sizeof(ans.s));//清空！谨记！
    for(int i=1;i<=len;++i)
        ans.s[i]=a.s[i]+b.s[i];
    for(int i=1;i<=len;++i)
    {
        if(i==len&&ans.s[i]>=10)++len;
        ans.s[i+1]+=ans.s[i]/10;
        ans.s[i]%=10;
    }
    ans.len=len;
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m);
    if(n<m)//抽屉原理，3个苹果放5个抽屉肯定有抽屉没苹果
    {
        printf("0");//直接输出就好了
        return 0;
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            f[i][j].len=1,f[i][j].s[1]=0;//初始化
    for(int i=1;i<=n;i++)
        f[i][1].s[1]=1,f[i][1].len=1;//m=1,S(n,1)=1
    for(int i=1;i<=n;i++)
        for(int j=2;j<=m;j++)
            f[i][j]=add(mul(f[i-1][j],j),f[i-1][j-1]);//S(n,m)=m*S(n-1,m)+S(n-1,m-1)
    for(int i=f[n][m].len;i>=1;i--)
        printf("%d",f[n][m].s[i]);//倒序输出
    return 0;
}
```

### 最优关键思路或技巧
 - **状态转移方程推导**：通过分析最后一个元素（第\(n\)只小猪）的不同放置情况，得出简洁有效的状态转移方程，这是解决此类组合问题的关键思维方式。
 - **高精度算法实现**：在处理大数据时，采用高精度加法和乘法。如将数字按位存储在数组中，模拟竖式运算进行加法和乘法操作，注意进位处理。

### 可拓展之处
此类题目属于组合数学中的分配问题，常见类似套路为分析每个元素的分配选择，构建状态转移方程。同类型题通常围绕不同元素在相同或不同容器中的分配，且可能涉及容器是否为空、元素是否可区分等条件变化。

### 推荐题目
 - [P1655 小朋友的球](https://www.luogu.com.cn/problem/P1655)：同样是小球放入盒子的问题，与本题模型相似。
 - [P5824 十二重计数法](https://www.luogu.com.cn/problem/P5824)：涵盖多种放球问题情况，可全面练习相关知识点。
 - [T188453 十二重计数法【弱化版】](https://www.luogu.com.cn/problem/T188453)：数据范围较小，适合初学者上手练习放球问题。

### 个人心得摘录与总结
部分作者提到直接套公式会因数据范围问题导致WA，需加上高精度计算，强调了在解决实际问题时要注意数据范围对算法实现的影响。 

---
处理用时：133.20秒
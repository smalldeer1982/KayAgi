# 题目信息

# 大循环

## 题目描述

hke 有一天学会了循环语句，感到很神奇。回到家，他用 C++ 写下这段代码：

```cpp
void work()
{
  ans=0;
    for(a[1]=1;a[1]<=n;++a[1])
      for(a[2]=1;a[2]<a[1];++a[2])
        for(a[3]=1;a[3]<a[2];++a[3])
          //......
            for(a[k]=1;a[k]<a[k-1];++a[k])
              ans+=f(q);
  cout<<ans;
}
```
其中，$q$ 是给定的常数，$f(x)$ 是一个关于 $x$ 的 $m$ 次多项式，它的表达式为：

$$f(x) = a _ m x ^ m + a _ {m - 1} x ^ {m - 1} + \cdots + a _ 1 x + a _ 0$$

hke 迫不及待地开始运行这个程序，但程序运行得实在太慢了。于是他找到了你，想知道这段程序输出的结果是？答案可能很大，你只需输出其对 $10^9+7$ 取模的结果即可。假设运算过程中不存在溢出。


## 说明/提示

对于 $10\%$ 的数据有 $n \le 10$；

对于 $30\%$ 的数据有 $n \le 1000,m \le 1000$；

对于 $100\%$ 的数据保证 $n \le 500000, m \le 500000, 1≤k≤n,q≤10^{18},1≤a _ i≤10000$。


## 样例 #1

### 输入

```
10 3 3 2
1 3 3 1```

### 输出

```
3240```

# AI分析结果

### 综合分析与结论
所有题解思路核心均为将原问题拆分为求组合数\(C(n,k)\)与多项式\(f(q)\)的值，再将两者相乘得到最终答案。
 - **思路方面**：多数题解通过分析循环结构得出其等价于从\(n\)个数中选\(k\)个数的组合数问题；对于\(f(q)\)，利用秦九韶算法优化计算。
 - **算法要点**：计算组合数时，通过公式\(C(n,k)=\frac{\prod_{i=n - k + 1}^{n}i}{k!}\)并结合乘法逆元求解；计算\(f(q)\)运用秦九韶算法将\(m\)次多项式转化为\(m\)个一次多项式计算。
 - **解决难点**：主要难点在于理解循环结构对应组合数问题，以及避免计算过程中的溢出，通过取模操作解决。

### 所选的题解
1. **作者：ikka (5星)**
    - **关键亮点**：思路清晰，先将题目代码翻译为公式，简洁明了地提出将\(f(q)\)提出，再阐述组合数意义，代码注释详细，整体结构清晰。
    - **重点代码**：
```cpp
int inline pow(int a, int b) {
    int ans = 1;
    while (b) {
        if (b & 1) ans = 1ll * ans * a % mod;
        a = 1ll * a * a % mod;
        b >>= 1;
    }
    return ans;
}

int f(int x) {
    int ans = a[m] % mod;
    for (int i = m; i; --i) ans = (1ll * ans * x % mod + a[i - 1]) % mod;
    return ans;
}

int C(int n, int k) {
    if (k << 1 > n) k = n - k;
    int ans = 1, buff = 1;
    for (int i = n - k + 1; i <= n; ++i) ans = 1ll * ans * i % mod;
    for (int i = 2; i <= k; ++i) buff = 1ll * buff * i % mod;
    return 1ll * pow(buff, mod - 2) * ans % mod;
}
```
    - **核心实现思想**：`pow`函数通过快速幂计算\(a^b\)；`f`函数运用秦九韶算法计算\(f(x)\)；`C`函数根据组合数公式及乘法逆元计算\(C(n,k)\)。
2. **作者：龙·海流 (4星)**
    - **关键亮点**：通过具体例子递推循环次数为组合数，对组合数和\(f(q)\)的计算过程解释详细，代码有注释且对细节（如\(q\)取模）有说明。
    - **重点代码**：
```cpp
ll ksm(ll a,ll b)
{
    ll ret=1;
    while(b)
    {
        if(b&1) ret=ret*a%mod;
        b>>=1;
        a=a*a%mod;
    }
    return ret;
}
ll C()
{
    ll a=1,b=1;
    for(ll i=n;i>=n-k+1;--i) a=a*i%mod;
    for(ll i=2;i<=k;++i) b=b*i%mod;
    return a*ksm(b,mod-2)%mod;
}
```
    - **核心实现思想**：`ksm`函数实现快速幂；`C`函数通过计算分子分母并结合快速幂求逆元得到组合数。
3. **作者：David_H_ (4星)**
    - **关键亮点**：先简述题意和思路，对组合数和\(f(x)\)化简过程详细，代码中各功能函数定义清晰，有注释说明用途。
    - **重点代码**：
```cpp
inline ll QuickPower(ll x, ll y, ll mod) {
    ll res = 1;
    while (y) {
        if (y & 1)
            res = res * x % mod;
        y >>= 1;
        x = (x * x) % mod;
    }
    return res;
}
inline int QJS(int x) {
    int ans = a[m] % MOD;
    for (int i = m; i > 0; --i)
        ans = ((ll)1 * ans * x % MOD + a[i - 1]) % MOD;
    return ans;
}
inline ll C(int n, int k) {
    if (k * 2 > n)
        k = n - k;
    int QAQ = 1, QwQ = 1;
    for (int i = n; i >= n - k + 1; i--)
        QAQ = (ll)1 * QAQ * i % MOD;
    for (int i = 2; i <= k; i++)
        QwQ = (ll)1 * QwQ * i % MOD;
    return (ll)1 * QuickPower(QwQ, MOD - 2, MOD) * QAQ % MOD;
}
```
    - **核心实现思想**：`QuickPower`实现快速幂；`QJS`运用秦九韶算法计算\(f(x)\)；`C`函数按组合数公式及乘法逆元计算\(C(n,k)\)。

### 最优关键思路或技巧
 - **思维方式**：将复杂循环结构转化为组合数问题，通过分析循环变量间的大小关系和取值范围，找到与组合数学的联系。
 - **算法优化**：计算\(f(q)\)时使用秦九韶算法，将\(m\)次多项式乘法运算次数从\(O(m^2)\)降低到\(O(m)\)；计算组合数利用公式结合乘法逆元，避免大数运算溢出。

### 可拓展之处
同类型题常涉及循环结构与数学公式的转换，类似算法套路为分析循环变量性质，转化为组合、排列等数学问题，再结合相应数学知识和优化算法（如秦九韶算法、快速幂求逆元）求解。

### 相似知识点洛谷题目
 - [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)：考察卢卡斯定理及组合数计算。
 - [P1313 计算系数](https://www.luogu.com.cn/problem/P1313)：结合二项式定理与组合数计算。
 - [P2613 【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)：涉及快速幂求逆元及有理数取模运算。

### 个人心得摘录与总结
 - **作者：龙·海流**：提到在计算多项式值时，对\(q\)提前取模，否则会少20分，强调了处理大数据时取模操作的重要性和细节。 

---
处理用时：58.26秒
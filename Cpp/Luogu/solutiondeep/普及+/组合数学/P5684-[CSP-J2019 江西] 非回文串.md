# 题目信息

# [CSP-J2019 江西] 非回文串

## 题目描述

Alice 有 $n$ 个字符，它们都是英文小写字母，从 $1 \sim n$ 编号，分别为 $c_1,c_2, \dots , c_n$。  
Bob 准备将这些字符重新排列，组成一个字符串 $S$。Bob 知道 Alice 有强迫症，所以他打算将 $S$ 组成一个非回文串来折磨 Alice。  

现在 Bob 想知道他共有多少种不同的排列字符的方案，能使得 $S$ 是个非回文串。一种排列字符的方案指的是一个 $1 \sim n$ 的排列 $p_i$，它所组成的 $S = c_{p_1}c_{p_2} \dots c_{p_n}$。

一个字符串是非回文串，当且仅当它的逆序串与原串不同。例如 `abcda` 的逆序串为 `adcba`，与原串不同，故 `abcda` 是非回文串。而 `abcba` 的逆序串与原串相同，是回文串。

由于最后的结果可能很大，你只需要告诉 Bob 总方案数对 $10^9+7$ 取模后的值。

## 说明/提示

【数据范围】  
对于 $20\%$ 的数据，$n \le 8$；  
对于 $50\%$ 的数据，$n \le 20$；  
另有 $30\%$ 的数据，字符只包含 `a` 和 `b`；  
对于 $100\%$ 的数据，$3 \le n \le 2000$。

## 样例 #1

### 输入

```
3
aba```

### 输出

```
4```

## 样例 #2

### 输入

```
8
aabbbbcc```

### 输出

```
39168```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解均采用正难则反的思想，先求总的排列数 \(n!\)，再求回文串的数量，用总排列数减去回文串数量得到非回文串数量。对于回文串数量的计算，关键在于分析字符出现次数的奇偶性。若有超过1种字母出现次数为奇数，则无法构成回文串，非回文串数量就是 \(n!\)；若不超过1种字母出现次数为奇数，则可构成回文串，需进一步计算其数量。
    - 算法要点：计算回文串数量时，利用回文串对称的特性，只考虑一半字符的排列情况。通过组合数学知识，结合每个字符出现次数，计算出回文串的排列数。同时，需预处理阶乘、逆元等，以优化计算过程。
    - 解决难点：难点在于准确理解回文串的构成条件，合理运用组合数学知识计算回文串数量，以及处理取模运算防止结果溢出。不同题解在具体计算回文串数量的公式推导和代码实现细节上有所差异。

    - 综合质量来看，以下3篇题解相对较好：
  - 作者：NaCly_Fish (5星)
    - 关键亮点：思路清晰简洁，公式推导详细。先明确非回文串数等于 \(n!\) 减去回文串数，然后分情况讨论回文串的构成条件。对于回文串数量的计算，从字符出现次数的奇偶性出发，推导出通用公式，且代码实现简洁高效，时间复杂度为 \(\Theta(n)\)。
    - 个人心得：无
    - 重点代码 - 核心实现思想：通过 `power` 函数快速幂计算逆元，预处理阶乘 `fac` 和阶乘逆元 `ifac`。统计每个字符出现次数，根据奇数次字符个数判断能否构成回文串。若能构成，按公式计算回文串数量，最后用总排列数减去回文串数量得到结果。
```cpp
inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int n,ans,dec,odd;
char a[N];
int fac[N],ifac[N],cnt[26];

int main(){
    scanf("%d",&n);
    scanf("%s",a+1);
    ifac[0] = ifac[1] = fac[0] = fac[1] = 1;
    for(reg int i=2;i<=n;++i) ifac[i] = fac[i] = (ll)fac[i-1]*i%p;
    ifac[n] = power(fac[n],p-2);
    for(reg int i=n-1;i>1;--i) ifac[i] = (ll)ifac[i+1]*(i+1)%p;
    for(reg int i=1;i<=n;++i) ++cnt[a[i]-'a'];
    for(reg int i=0;i<26;++i) odd += cnt[i]&1;
    if(odd>1){
        printf("%d",fac[n]);
        return 0;
    }
    odd = 1;
    for(reg int i=0;i<26;++i)
        if(cnt[i]&1) odd = cnt[i];
    dec = (ll)fac[n>>1]*odd%p;
    for(reg int i=0;i<26;++i) cnt[i] >>= 1;
    for(reg int i=0;i<26;++i) dec = (ll)dec*fac[cnt[i]<<1]%p*ifac[cnt[i]]%p;
    ans = (fac[n]-dec+p)%p;
    printf("%d",ans);
    return 0;
}
```
  - 作者：FJ_EYoungOneC (4星)
    - 关键亮点：解题思路阐述详细，对回文串存在的条件以及计算回文串数量的过程，结合奇偶性进行了清晰的分析。代码实现中，利用快速幂计算逆元，通过预处理阶乘和逆元，优化了计算组合数的过程。
    - 个人心得：无
    - 重点代码 - 核心实现思想：通过 `qmi` 函数快速幂计算逆元，预处理阶乘 `fact` 和阶乘逆元 `infact`。统计每个字符出现次数，根据奇数次字符个数判断能否构成回文串。若能构成，按步骤计算回文串数量，最后用总排列数减去回文串数量得到结果。
```cpp
int qmi(int a, int b, int p)
{
    int res = 1 % p;
    while (b)
    {
        if (b & 1)
            res = (LL)res * a % p;
        a = (LL)a * a % p;
        b >>= 1;
    }
    return res;
}

int C(int a, int b)
{
    return (LL)fact[a] * infact[b] % MOD * infact[a - b] % MOD;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; ++ i )
    {
        fact[i] = (LL)fact[i - 1] * i % MOD;
        infact[i] = qmi(fact[i], MOD - 2, MOD);
    }
    
    cin >> n >> str;
    int m = n;
    for (auto c: str)
        h[c - 'a'] ++;
    
    int res = 1;
    int cnt = 0;
    for (int i = 0; i < 26; ++ i )
        if (h[i] & 1)
        {
            res = h[i];
            h[i] --;
            cnt ++;
        }
    
    if (cnt > 1)
    {
        cout << fact[n] << endl;
        return 0;
    }
    
    n /= 2;
    for (int i = 0; i < 26; ++ i )
    {
        res = (LL)res * C(n, h[i] / 2) % MOD * fact[h[i]] % MOD;
        n -= h[i] / 2;
    }
    
    cout << ((LL)fact[m] - res + MOD) % MOD << endl;
    
    return 0;
}
```
  - 作者：Digital_Sunrise (4星)
    - 关键亮点：着重讲解了易错点，对题目中的多个坑点进行了详细说明，如字符编号导致数值相同字符不同、字符出现次数奇偶性判断、排列组合公式的正确使用以及取模后的大小关系特判等，有助于读者避免错误。
    - 个人心得：强调了题目中的易错点，提醒读者注意细节。
    - 重点代码 - 核心实现思想：通过 `pow` 函数快速幂计算逆元，预处理阶乘 `fac`。统计每个字符出现次数，根据奇数次字符个数判断能否构成回文串。若能构成，按排列组合公式计算回文串数量，最后用总排列数减去回文串数量得到结果，并特判结果为负的情况。
```cpp
int pow(int x,int y)
{
	int cnt = 1;
	while(y)
	{
		if(y & 1)
		{
			cnt *= x;
			cnt %= mod;
		}
		x *= x;
		x %= mod;
		y >>= 1;
	}
	return cnt;
}

int C(int n,int m)
{
	if(n == 0)
		return 1;
	int ans = 1;
	for(int i = m;i >= m - n + 1;i--)
		ans *= i,ans %= mod;
	return ans * pow(fac[n],mod - 2) % mod;
}

signed main()
{
	cin >> len;
	cin >> s;
	fac[0] = fac[1] = 1;
	for(int i = 2;i <= len;i++)
		fac[i] = fac[i - 1] * i % mod;
	for(int i = 0;i < len;i++)
		sum[(s[i] - 'a') + 1]++;
	for(int i = 1;i <= 26;i++)
	{
		if(sum[i] % 2 == 1)
			num++;
	}
	if(num >= 2)
	{
		cout << fac[len];
		return 0;
	}
	nn = len / 2;
	num = 1;
	for(int i = 1;i <= 26;i++)
	{
		if(nn == 0)
			break;
		num *= C(sum[i] / 2,nn);
		num %= mod;
		num *= fac[sum[i]];
		num %= mod;
		nn -= sum[i] / 2;
	}
	cout << (fac[len] - num < 0? fac[len] - num + mod : fac[len] - num);
	return 0;
}
```
• 最优关键思路或技巧：采用正难则反的思维方式，将求非回文串数量转化为求总排列数与回文串数量之差。利用回文串对称的特性，通过组合数学知识计算回文串数量，同时运用快速幂计算逆元优化计算过程，提高效率。
• 可拓展之处：同类型题可拓展到其他关于字符串排列组合且需满足特定条件的题目，类似算法套路是先分析问题的正反两面，若正面求解困难则尝试反面求解，利用问题的特性（如对称性、周期性等）简化计算，结合组合数学知识和优化技巧（如逆元计算、预处理等）解决问题。
• 相似知识点洛谷题目：
    - [P1009 阶乘之和](https://www.luogu.com.cn/problem/P1009)：涉及阶乘计算，与本题预处理阶乘知识点相关。
    - [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)：考察组合数计算及卢卡斯定理，与本题组合数学知识点相关。
    - [P2822 [NOIP2016 提高组] 组合数问题](https://www.luogu.com.cn/problem/P2822)：同样围绕组合数展开，结合取模运算，与本题知识点类似。
• 个人心得摘录与总结：
    - Digital_Sunrise：强调题目中多个易错点，如字符编号影响、字符出现次数奇偶性判断、排列组合公式使用以及取模后的大小关系特判等，提醒解题时需关注细节，避免遗漏特殊情况导致错误。 

---
处理用时：72.04秒
# 题目信息

# [入门赛 #11] [yLOI2021] 扶苏与 1 (Hard Version)

## 题目背景

**本题与 Easy Version 的区别是：$x$ 的范围不同，$y$ 的长度限制不同**。

**请注意 Easy Version 和 Hard Version 不是严格的包含关系。**

扶苏在 ICPC2022 EC Final 的比赛里，开局不到五分钟，就读假了一道题，把一道数位 DP 开成了简单签到，狠狠地演了队友一把。

为了不让读假了的题被浪费，所以这道题出现在了这里。

## 题目描述

扶苏给了你一个数字 $x$，你需要给她一个数字 $y$，使得在列竖式计算 $x + y$ 时，能恰好产生 $k$ 个进位。

**你给出的 $y$ 的长度不能超过 $x$ 的长度。**（注意，这条要求与 Easy Version 不同）

**进位**的含义是：在进行竖式加法运算时，如果位于同一列上的数字之和（加上低位向上可能存在的进位）比 $9$ 大，则在结果的这一列上只保留这个和的个位数字，同时称这一位向它的高位产生了一个**进位**。

下图是一个竖式加法的例子，结果中标红的两位都向上产生了进位。

![](https://cdn.luogu.com.cn/upload/image_hosting/sxkzrk4i.png)

## 说明/提示

### 数据规模与约定

对全部的测试点，保证 $0 \leq x < 10^{(10^4)}$，$1 \leq T \leq 5000$，$1 \leq k \leq 1+\log_{10}\max(1,x)$。输入的 $x$ 不含前导 $0$。

### 提示

输入的 $x$ 可能会很大。如果说 $x < 10^t$，则输入 $x$ 的**长度**不会超过 $t$。数据规模中式子 $k \leq 1 + \log_{10}\max(1,x) $ 的含义是：$k$ 不会超过 $x$ 的长度。

## 样例 #1

### 输入

```
5
1
1
14
1
514
2
1234
1
123456
6```

### 输出

```
9
8
516
7
877777```

# AI分析结果

### 综合分析与结论
这些题解的核心均围绕如何构造出满足条件的数字 \(y\)，使得 \(x + y\) 竖式计算产生 \(k\) 个进位，同时满足 \(y\) 长度不超 \(x\) 长度。

思路上，多先处理 \(x\) 末尾 \(0\)，因其不产生进位，统计其个数并删除。之后判断剩余 \(x\) 长度与 \(k\) 的关系，若小于 \(k\) 则无解。对于有解情况，不同题解构造 \(y\) 的方式有差异。有的按 \(0\) 分段处理，有的找特定位置非零数来构造。

算法要点主要是利用数字 \(9\) 易产生进位的特性，根据 \(x\) 中数字情况和剩余进位次数，在 \(y\) 的对应位设置 \(9\) 或 \(0\)。

解决难点在于处理 \(x\) 内部 \(0\) 的情况，既要考虑 \(0\) 前有进位时可进位，又要避免构造时进位次数不符合要求。

整体看，各题解思路相近，但在实现细节和表述清晰度上有差异。

### 所选的题解
- **作者：Big_Dinosaur (5星)**
    - **关键亮点**：思路清晰简洁，代码实现直接。先处理 \(x\) 末尾 \(0\)，之后根据非零数个数与 \(k\) 的关系，在对应位设 \(9\) 或 \(0\) 构造 \(y\)。
    - **重点代码**：
```cpp
void doit(){
    s="";a=0;
    while(x[x.size()-1]=='0'){
        x.erase(x.size()-1);++a;
    }
    if(x.size()<k){
        puts("-1");return;
    }
    for(int i=0;i<x.size();++i)if(x[i]=='0'||!k)s+='0';else{
        s+='9';--k;
    }
    for(int i=x.size()-1;i>=0;--i)if(x[i]=='0'&&k){
        s[i]='9';--k;
    }
    cout<<s;
    for(int i=1;i<=a;++i)putchar('0');puts("");
}
```
    - **核心实现思想**：先删除 \(x\) 末尾 \(0\) 并统计个数 \(a\)，若剩余 \(x\) 长度小于 \(k\) 则无解。否则，遍历 \(x\)，非零数对应位设 \(9\) 并减少 \(k\)，若 \(k\) 减为 \(0\) 或遇 \(0\) 则设 \(0\)。之后从后往前遍历，若遇 \(0\) 且 \(k\) 不为 \(0\)，则设为 \(9\) 并减 \(k\)，最后输出构造的 \(s\) 及 \(a\) 个 \(0\)。
- **作者：一扶苏一 (4星)**
    - **关键亮点**：对构造方法证明详细，逻辑严谨。通过找到特定位置 \(p\) 和 \(q\)，分区间构造 \(y\) 实现 \(k\) 个进位。
    - **重点代码**：
```cpp
for (int i = 0; i <= endp; ++i) {
    ans.push_back('9');
}
if (endp!= k - 1) {
    int q = k - 1;
    while (q < s.size() && s[q] == '0') ++q;
    if (q == s.size()) {
        std::cout << "-1\n";
        continue;
    }
    int p = k - endp - 1;
    p = q - p + 1;
    for (int i = endp + 1; i < p; ++i) ans.push_back('0');
    for (int i = p; i <= q; ++i) ans.push_back('9');
}
while(s.size() > ans.size()) ans.push_back('0');
```
    - **核心实现思想**：先找第 \(k\) 位之前最后一个非零位置 \(endp\)，前 \(endp\) 位设 \(9\)。若 \(endp\) 不是第 \(k - 1\) 位，找第 \(k\) 位之后第一个非零位置 \(q\)，若不存在则无解。否则计算位置 \(p\)，在 \(endp + 1\) 到 \(p - 1\) 位设 \(0\)，\(p\) 到 \(q\) 位设 \(9\)，最后补齐 \(0\) 使 \(ans\) 与 \(s\) 长度相同。
- **作者：离散小波变换° (4星)**
    - **关键亮点**：提出按 \(0\) 分段思路，通过对每段处理构造 \(y\)，方法独特。
    - **重点代码**：
```cpp
while(k > 0){
    int p = 1;
    while(S[t] == '0') ++ t, ++ p;
    if(p <= k){
        up(1, p, i) putchar('9');
    } else {
        up(1, p - k, i) putchar('0');
        up(1, k, i) putchar('9');
    }
    k -= p, ++ t;
}
```
    - **核心实现思想**：按 \(0\) 分段，对于每段，若段长 \(p\) 小于等于 \(k\)，则该段全设 \(9\)；否则前 \(p - k\) 位设 \(0\)，后 \(k\) 位设 \(9\)，然后更新 \(k\) 和 \(t\) 继续处理下一段。

### 最优关键思路或技巧
利用数字 \(9\) 在加法中易产生进位的特性，根据 \(x\) 中 \(0\) 和非零数分布及剩余进位次数，合理在 \(y\) 对应位设置 \(9\) 或 \(0\)。处理 \(x\) 内部 \(0\) 时，通过找特定位置（如第一个非零数、最后一个非零数等），结合进位需求构造 \(y\)。

### 可拓展思路
此类构造题可拓展到其他运算或条件限制下的数字构造。如乘法运算中构造两个数使乘积有特定数字特征，或在满足特定数位关系下构造数字等。类似算法套路是先分析关键数字特性（如本题 \(9\) 的进位特性），再根据给定条件和限制，逐步构造满足要求的数字。

### 相似知识点洛谷题目
- **P1036 [NOIP2002 普及组] 选数**：涉及数的组合与条件判断，类似本题需根据条件构造满足要求的数。
- **P1149 火柴棒等式**：通过火柴棒数量限制构造等式，与本题按条件构造数字思路相似。
- **P1464 Function**：根据函数规则构造满足条件的函数值，同样是条件构造类型题目。

### 个人心得摘录与总结
- **作者：shiranui**：“最开始是想正着搞的，但是怎么也调不出来，提供一种倒着做的做法”。总结为构造数字时，正向思路受阻可尝试反向思考，从后往前处理数字可能更符合逻辑或更易实现。 

---
处理用时：63.17秒
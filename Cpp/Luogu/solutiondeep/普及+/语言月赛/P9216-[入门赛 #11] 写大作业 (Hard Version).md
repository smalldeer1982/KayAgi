# 题目信息

# [入门赛 #11] 写大作业 (Hard Version)

## 题目背景

**本题与 Easy Version 的区别在于：输入的是数列而不是字符串，输入输出格式不同，数据规模不同**。


## 题目描述

扶苏为了写计算理论大作业已经 $36$ 小时没有合眼了。

为了能快点睡觉，扶苏找到了 $n$ 份文献，第 $i$ 份文献是一数列 $a_i$，她打算把这些文献组合起来。

具体来说，一共有两种操作：

- `1 x y`：把文献 $a_x$ 整体拼接到 $a_y$ 的后面，然后删除 $a_x$。
- `2 x y`：查询 $a_x$ 和 $a_y$ 是否**相似**。

我们保证在 `1 x y` 操作出现后，数列 $a_x$ **不会**出现在接下来的任何操作中。这就是说，操作 $1$ 至多有 $n-1$ 次。

**相似**的定义是：对两个数列 $a_x$ 和 $a_y$，如果存在一种重新排列 $a_x$ 的方法，使得重排后的 $a_x$ 和 $a_y$ 相等，则称 $a_x$ 和 $a_y$ **相似**。

例如，假设 $a_1 = 1,2$, $a_2 = 3,4$，$a_3 = 1,2,3,4$，则执行 `1 1 2` 后，$a_1$ 被删除，$a_2 = 3,4,1,2$，$s_3 = 1,2,3,4$；继续执行 `2 2 3` 后，因为可以把 $a_2$ 重排为 $1,2,3,4$，所以 $a_2$ 和 $a_3$ 相似。

注意，操作 $2$ 不会对数列做出实际修改。

## 说明/提示

### 样例解释

共有五次操作，它们的编号和回答情况如下：
| 编号 | 操作 | 回答 |
| :-: | :-: | :-: |
| $1$ | `1 1 2` | 不是查询操作|
| $2$ | `2 2 3` | 相似 |
| $3$ | `2 3 4` | 不相似 |
| $4$ | `2 2 4` | 不相似 |
| $5$ | `2 2 3` | 相似 |

可以看到，回答为**两数列相似**的询问的操作编号为 $2$ 和 $5$。它们的按位异或和是 $7$。故输出为 $7$。

### 数据规模与约定

对全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq q \leq 5 \times 10^6$，$1 \leq m_i \leq 10^5$，$\sum_{i = 1}^n m_i \leq 5 \times 10^5$。数列里的元素都是不超过 $10^9$ 的非负整数。

数据保证数列元素的生成方式是：对一个数列，限定一个该数列元素大小的上界 $k$，然后在 $[0, k]$ 内均匀随机地生成 $m_i$ 个整数作为数列 $a_i$。注意，$k$ 不一定是 $10^9$。

## 样例 #1

### 输入

```
4 5
2 1 2
2 3 4
4 1 2 3 4
4 1 2 3 3
1 1 2
2 2 3
2 3 4
2 2 4
2 3 2```

### 输出

```
7```

# AI分析结果

• 综合分析与结论：
  本题主要考查对数列相似判断及合并操作的实现，众多题解核心思路围绕哈希方法展开。各题解思路、算法要点及解决难点如下：
  - **一扶苏一**：利用启发式合并维护数列，用map记录数字出现次数，通过特定哈希函数计算哈希值，在启发式合并时维护哈希值变化，解决合并操作复杂度及相似判断问题。
  - **离散小波变换°**：构造多项式判断序列相似性，通过取不同x值代入多项式并取模计算特征值，序列拼接时利用多项式乘法性质，解决直接多项式计算复杂度高的问题。
  - **Disjoint_cat**：Hard版本先离散化数列，将数字替换为质数，以数列中质数乘积作为哈希值，解决值域大无法直接统计数字出现次数问题。
  - **heaksicn**：维护每个序列数的平方和、立方和、异或和，并对多个模数取模作为哈希值，操作1直接相加哈希值，操作2判断哈希值是否相等，解决单次操作复杂度问题。
  - **lfxxx**：将序列合并看作树结构，采用启发式合并，给每个数附随机权值，通过记录每个数贡献维护序列哈希值，解决查询复杂度问题。
  - **caohan**：用多组哈希降低重复概率，通过某个常数的次方计算哈希值，合并时直接相加，解决哈希冲突问题。
  - **E1_de5truct0r**：对每个集合值域开桶，使用set + 启发式合并，采用双哈希判断集合是否相同，解决直接开桶复杂度高问题。
  - **L0vely_NaiL0ng**：给每个数值随机分配权值，文献权值为数列中数值权值之和，操作1相加权值，操作2判断权值是否相等，简单实现但可能存在哈希冲突。
  - **MspAInt**：读入时给数分配随机权值，数列统计权值和，拼接操作相加权值和，以权值和判断相似性，存在哈希冲突风险。
  - **DengDuck**：用多个权值描述文献，如$2^x$、$3^x$及数字数量，合并时权值直接相加，降低哈希冲突概率。
  - **苏联小渣**：给每个出现的数随机赋权值，用数列权值和判断相似性，操作1更新权值和，简单实现但有哈希冲突可能。

  整体来看，多数题解通过哈希解决问题，部分考虑了降低哈希冲突及优化操作复杂度。

  评分较高（≥4星）的题解：
  - **一扶苏一**：★★★★
    - 关键亮点：采用启发式合并优化合并操作复杂度，通过设计可单点插入的哈希函数，在合并时高效维护哈希值变化，整体思路清晰，复杂度分析准确。
    ```cpp
    ull mpow(ull x, int y) {
      ull ret = 1;
      while (y) {
        if (y & 1) ret *= x;
        x *= x;
        y >>= 1;
      }
      return ret;
    }
    // 计算哈希值及启发式合并核心代码
    for (int i = 1, o, x, y; i <= q; ++i) {
      std::cin >> o >> x >> y;
      if (o == 2) {
        bool ret = true;
        for (int j = 0; j < maxJ; ++j) if (hash[j][x]!= hash[j][y]) {
          ret = false; break;
        }
        if (ret) ans ^= i;
      } else {
        assert(oc[x] == false);
        oc[x] = true;
        if (rec[x].size() > rec[y].size()) {
          rec[x].swap(rec[y]);
          for (int j = 0; j < maxJ; ++j) std::swap(hash[j][x], hash[j][y]);
        }
        for (auto &[u, v] : rec[x]) {
          if (rec[y][u]) for (int j = 0; j < maxJ; ++j) hash[j][y] -= mpow(u, j * rec[y][u]);
          for (int j = 0; j < maxJ; ++j) hash[j][y] += mpow(u, v * j);
        }
      }
    }
    ```
  - **离散小波变换°**：★★★★
    - 关键亮点：巧妙利用多项式性质，通过代入多个x值取模计算特征值判断序列相似性，序列拼接时利用多项式乘法性质，方法新颖且有效降低复杂度。
    ```cpp
    up(1, k, i) T[i] = U(MT);
    up(1, n, i){
      int m = qread();
      up(1, k, j) S[i][j] = 1;
      up(1, m, j){
        int a = qread();
        up(1, k, t)
          S[i][t] = 1ll * S[i][t] * (a + T[t]) % MOD;
      }
    }
    // 操作核心代码
    up(1, q, i){
      int o = qread();
      if(o == 1){
        int x = qread(), y = qread();
        up(1, k, j)
          S[y][j] = 1ll * S[y][j] * S[x][j] % MOD;
      } else {
        int x = qread(), y = qread();
        bool flag = true;
        up(1, k, j)
          if(S[x][j]!= S[y][j])
            flag = false;
        if(flag) ans ^= i;
      }
    }
    ```
  - **lfxxx**：★★★★
    - 关键亮点：将序列合并构建树性结构，采用启发式合并优化复杂度，通过给每个数附随机权值并记录贡献维护哈希值，解决查询问题，代码实现使用pbds优化常数。
    ```cpp
    inline void Node::insert(int x){
      if(val[x]==0){
        val[x]=(rand()+1)*(rand()+1);
      }
      v.push_back(x);
      tot[x]++;
      Hash-=V[x];
      if(V[x]==0) V[x]=val[x];
      else V[x]*=val[x];
      Hash+=V[x];
    }
    inline void merge(int a,int b){
      a=found(a),b=found(b);
      if(chifan[a].v.size()>chifan[b].v.size()) swap(a,b);
      for(int u:chifan[a].v){
        chifan[b].insert(u);
      }
      fa[a]=b;
    }
    inline void query(int pos,int a,int b){
      a=found(a),b=found(b);
      if(chifan[a].Hash==chifan[b].Hash){
        anser^=pos;
      }
    }
    ```

• 最优关键思路或技巧：
  - **数据结构与算法优化**：启发式合并在处理合并操作时能有效降低复杂度，如在一扶苏一和lfxxx的题解中，通过将小集合合并到大集合，使元素移动次数减少，整体复杂度降低。
  - **哈希函数设计**：设计合适的哈希函数至关重要，像一扶苏一通过定义能计算单个数字贡献的哈希函数，在合并时可高效维护哈希值变化；离散小波变换°利用多项式性质设计哈希方式，从另一个角度解决相似判断问题。

• 可拓展之处：
  - 同类型题常考查对集合相似性判断及集合合并操作，类似算法套路多围绕哈希方法展开，可通过设计不同哈希函数、采用多组哈希或结合其他数据结构优化操作复杂度。

• 推荐题目：
  - [P8819 [CSP - S 2022] 星战](https://www.luogu.com.cn/problem/P8819)：同样涉及对元素状态的维护及判断，可锻炼哈希应用能力。
  - [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)：考查数据结构维护及操作，与本题维护数列操作有相似思考方向。
  - [P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并](https://www.luogu.com.cn/problem/P4556)：涉及合并操作及信息维护，与本题合并数列有相似之处。

• 个人心得摘录：
  - **一扶苏一**：出题时因不了解新科技，被随机hash老哥直接$O(q)$爆标，成为典题。此心得体现对新算法及优化方向了解的重要性，在解题时需关注前沿方法。 

---
处理用时：79.82秒
# 题目信息

# [JRKSJ R2] Upper

## 题目描述

有 $n$ 张扑克，第 $i$ 张扑克上写有一个正整数 $a_i$。

现在要把扑克划分成若干个合法的连续子段，其中，一个连续子段 $[l,r]$ “合法”当且仅当这个子段同时满足两个条件： 

* $a_l< a_r$
* $\gcd(a_l,a_r)>1$ 

请问最多能划分多少段。如果没有合法的划分方案，输出 $-1$ 即可。

如果您不知道 $\gcd$ 是什么意思，请看“提示”部分。

## 说明/提示

### 数据范围
本题采用捆绑测试。

对于 $100\%$ 的数据，$2\le n\le 10^5$，$1\le a_i\le 10^9$。

| $\text{Subtask}$ | $n\le$ | $a_i\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $5$ | $10^9$ | 无 | $5$ |
| $2$ | $3\times10^3$ | $10^9$ | 无 | $15$ |
| $3$ | $2\times10^4$ | $10^6$ | 无 | $20$ |
| $4$ | $2\times 10^4$ | $10^9$ | 无 | $10$ |
| $5$ | $10^5$ | $10^9$ | 数据随机 | $10$ |
| $6$ | $10^5$ | $10^9$ | 无 | $40$ |

### 样例解释
对于样例 $1$，有且仅有一种划分方案 $\{2,1,8\},\{3,9\}$。\
对于样例 $2$，无合法的划分方案。

### 提示
对于两个正整数 $a,b$，$\gcd(a,b)$ 为它们的最大公因数，即满足既是 $a$ 的因数又是 $b$ 的因数的数中最大的数。

## 样例 #1

### 输入

```
5
2 1 8 3 9```

### 输出

```
2```

## 样例 #2

### 输入

```
5
5 4 3 2 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
20
20 9 36 36 40 8 3 10 9 20 18 12 30 20 30 15 8 9 27 45```

### 输出

```
7```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地处理两个条件：$a_l < a_r$ 和 $\gcd(a_l, a_r) > 1$。大多数题解都采用了动态规划（DP）的思路，结合质因数分解和数据结构（如权值线段树）来优化转移过程。其中，质因数分解是解决 $\gcd$ 条件的关键，而权值线段树则用于快速查询和更新满足 $a_l < a_r$ 的 DP 值。

### 所选高星题解

#### 1. **题解作者：KazamaRuri (5星)**
- **关键亮点**：该题解通过质因数分解和权值线段树的结合，实现了高效的 DP 转移。作者详细解释了如何通过质因数分解来优化 $\gcd$ 条件的处理，并利用权值线段树来维护满足 $a_l < a_r$ 的 DP 值。代码实现清晰，且时间复杂度分析到位。
- **代码核心思想**：
  - 质因数分解：对每个 $a_i$ 进行质因数分解，记录其所有质因子。
  - 权值线段树：为每个质因子维护一棵权值线段树，用于查询和更新 DP 值。
  - DP 转移：对于每个 $a_i$，遍历其所有质因子，查询对应线段树中的最大值，并更新当前 DP 值。

```cpp
void upd(int &x,int l,int r,int p,int k){
	if(l>p||r<p) return ; x=x?x:++tot,t[x]=max(t[x],k); if(l==r) return ;
	int mid=l+r>>1; upd(lc[x],l,mid,p,k),upd(rc[x],mid+1,r,p,k);
}
int ask(int x,int l,int r,int p){
	if(l>p||!x) return -inf; if(r<=p) return t[x]; int mid=l+r>>1;
	return max(ask(lc[x],l,mid,p),ask(rc[x],mid+1,r,p));
}
```

#### 2. **题解作者：ZillionX (4星)**
- **关键亮点**：该题解同样采用了质因数分解和权值线段树的思路，但在质因数分解时使用了 Exact Division 优化，进一步提升了效率。代码结构清晰，且时间复杂度分析详细。
- **代码核心思想**：
  - 质因数分解：使用 Exact Division 优化质因数分解过程。
  - 权值线段树：为每个质因子维护一棵权值线段树，用于查询和更新 DP 值。
  - DP 转移：对于每个 $a_i$，遍历其所有质因子，查询对应线段树中的最大值，并更新当前 DP 值。

```cpp
void Upd(int &x,int l,int r,int pos,int k) {
	if (!x) x=++tot;
	if (l==r) {
		v[x]=max(v[x],k);
		return;
	}
	int mid((l+r)>>1);
	if (pos<=mid) Upd(ls[x],l,mid,pos,k);
	else Upd(rs[x],mid+1,r,pos,k);
	Up(x);
}
```

#### 3. **题解作者：Spasmodic (4星)**
- **关键亮点**：该题解通过质因数分解和权值线段树的结合，实现了高效的 DP 转移。作者在质因数分解时使用了线性筛优化，进一步提升了效率。代码实现清晰，且时间复杂度分析到位。
- **代码核心思想**：
  - 质因数分解：使用线性筛优化质因数分解过程。
  - 权值线段树：为每个质因子维护一棵权值线段树，用于查询和更新 DP 值。
  - DP 转移：对于每个 $a_i$，遍历其所有质因子，查询对应线段树中的最大值，并更新当前 DP 值。

```cpp
void insert(int&k,int l,int r,int p,int v){
	if(!k)k=++tot;
	if(l==r)return chkmax(st[k].ma,v),void();
	int mid=l+r>>1;
	if(p<=mid)insert(st[k].lc,l,mid,p,v);
	else insert(st[k].rc,mid+1,r,p,v);
	pushup(k);
	return;
}
```

### 最优关键思路与技巧

1. **质因数分解**：通过质因数分解，将 $\gcd$ 条件转化为公共质因子的存在性，从而简化问题。
2. **权值线段树**：利用权值线段树快速查询和更新满足 $a_l < a_r$ 的 DP 值，优化了 DP 转移过程。
3. **动态开点线段树**：通过动态开点线段树，避免了空间浪费，适用于质因子数量较多的情况。

### 可拓展之处

1. **类似问题**：可以扩展到其他需要处理 $\gcd$ 或质因数分解的 DP 问题，如区间 $\gcd$ 查询、区间质因数统计等。
2. **数据结构优化**：可以考虑使用其他数据结构（如树状数组、平衡树）来替代权值线段树，进一步优化查询和更新操作。

### 推荐题目

1. **P3383 【模板】线性筛素数**：练习质因数分解的基础题目。
2. **P3372 【模板】线段树 1**：练习线段树的基本操作。
3. **P3865 【模板】ST 表**：练习区间查询的优化方法。

### 个人心得摘录

- **KazamaRuri**：提到“懒得写素数筛可以这样写找质因子”，说明在实际编码中，有时可以通过简化代码来提升效率，但需注意时间复杂度的控制。
- **ZillionX**：提到“加了个 Exact Division，直接跑到了最优解 rk1”，说明在算法竞赛中，优化细节（如 Exact Division）可以显著提升代码性能。

---
处理用时：42.51秒
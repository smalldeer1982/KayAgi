# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 排座位

## 题目描述

有 $n$ 个座位，从左到右编号为 $1 \sim n$。现在有 $m$ 个小朋友，第 $i$ 个小朋友可以坐在 $l[i] \sim r[i]$ 这些座位上，每个座位至多坐一个人。

现在请问，如果只保留 $1 \sim k$ 这些座位，最多可以给多少小朋友安排座位。请你输出 $k = 1 \sim n$ 的所有答案。

例如 $n = 3, m = 3$，$3$ 个小朋友 $A, B, C$ 的区间为 $[2, 2], [2, 3], [1, 3]$：

- $k = 1$ 时：一个可行方案为 $[C]$，答案为 $1$；
- $k = 2$ 时：一个可行方案为 $[C, B]$，答案为 $2$；
- $k = 3$ 时：一个可行方案为 $[C, A, B]$，答案为 $3$；

## 说明/提示

### 样例 3-7

见附件。

### 数据范围

对于所有数据，$1 \leq n, m \leq 2 \times 10^5, 1 \leq l[i] \leq r[i] \leq n$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | 数据范围 | 特殊性质 | 子任务依赖 |
|:------------:|:------:|:----------:|:----------:|:------------:|
| 1          | 26   | $n, m \leq 10$ |          |            |
| 2          | 28   | $n, m \leq 100$ |          | 1          |
| 3          | 11   | $n, m \leq 5000$ | $l[i] = r[i]$ |            |
| 4          | 26   | $n, m \leq 5000$ |          | 1,2,3      |
| 5          | 9    | $n, m \leq 2 \times 10^5$ |          | 1,2,3,4    |

## 样例 #1

### 输入

```
3 3
2 2
2 3
1 3```

### 输出

```
1
2
3```

## 样例 #2

### 输入

```
8 9
5 7
6 7
5 6
6 7
7 7
5 7
4 6
1 1
7 7```

### 输出

```
1
1
1
2
3
4
5
5```

# AI分析结果



### 综合分析与结论

本题的核心在于，对于每个k，求在座位1~k范围内选择最多不冲突的区间，每个区间选一个座位。通过贪心策略结合并查集数据结构，将所有区间按右端点排序后，利用并查集快速找到可用座位，最终通过预处理得到每个k的答案。

### 最优题解

#### 题解星级：★★★★★
**关键亮点**  
- **贪心策略与并查集结合**：将区间按右端点排序，使用并查集快速查找并占据最右侧可用座位，确保高效处理。  
- **离线处理与二分优化**：预处理所有被选中的座位后，利用二分查找快速计算每个k的答案。  
- **时间复杂度优化**：通过并查集的路径压缩，将单次操作降至近常数复杂度，适合大规模数据。  

**核心代码实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 2e5 + 5;

struct Interval {
    int l, r;
    bool operator<(const Interval& other) const {
        return r != other.r ? r < other.r : l > other.l;
    }
};

int fa[MAXN];
int find(int x) {
    if (x < 1) return 0;
    if (fa[x] != x) fa[x] = find(fa[x]);
    return fa[x];
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    vector<Interval> intervals(m);
    for (auto& it : intervals) {
        scanf("%d%d", &it.l, &it.r);
    }
    sort(intervals.begin(), intervals.end());
    
    for (int i = 1; i <= n; ++i) fa[i] = i;
    vector<int> selected;
    for (const auto& it : intervals) {
        int s = find(it.r);
        if (s >= it.l) {
            selected.push_back(s);
            fa[s] = find(s - 1);
        }
    }
    sort(selected.begin(), selected.end());
    
    for (int k = 1; k <= n; ++k) {
        int cnt = upper_bound(selected.begin(), selected.end(), k) - selected.begin();
        printf("%d\n", cnt);
    }
    return 0;
}
```

### 关键思路总结
1. **区间排序**：按右端点从小到大，右端点相同则左端点从大到小排序，确保贪心策略正确性。  
2. **并查集优化**：维护座位占用状态，快速找到最右侧可用座位，确保线性时间复杂度。  
3. **前缀处理答案**：通过排序后的已选座位数组，利用二分查找快速回答每个k的查询。

### 拓展练习
1. **P1803 线段覆盖**（区间调度基础问题）  
2. **P2082 区间覆盖问题**（贪心策略应用）  
3. **P2949 工作调度**（类似贪心结合数据结构优化）  

以上题目均涉及贪心策略与高效数据结构结合，有助于巩固本题思路。

---
处理用时：478.92秒
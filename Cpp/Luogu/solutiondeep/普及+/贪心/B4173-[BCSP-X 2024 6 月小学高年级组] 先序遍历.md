# 题目信息

# [BCSP-X 2024 6 月小学高年级组] 先序遍历

## 题目描述

按照根-左-右的顺序遍历**二叉树**：

- 先序遍历 = 根 + 左子树先序遍历 + 右子树先序遍历
- 空树的先序遍历 = 空

![](https://cdn.luogu.com.cn/upload/image_hosting/rz3z5ke0.png)

给一棵 $n$ 个点的二叉树（根节点为 $1$），你可以进行以下操作至多 $1$ 次：

- 选择 $1$ 个（除了根之外的）点 $u$，断开 $u$ 和其父节点之间的边；然后重新选择另一个点作为 $u$ 的父节点、将 $u$ 接上去，需要保证操作之后仍然是一棵以 $1$ 为根的二叉树。

你想要操作之后的二叉树有字典序最小的先序遍历序列，输出这个序列。

## 说明/提示

### 样例解释 #1

- 对于第一个样例，可以把 3 号结点连在 2 号结点的左儿子处。
- 对于第二个样例，可以把 4 号结点连在 3 号结点的左儿子处。

### 数据范围

对于所有数据，令 $\sum n$ 代表每组数据中 $n$ 的和，$1 \leq T \leq 100, 1 \leq n \leq 10^5, 1 \leq \sum n \leq 3 \times 10^5$，保证输入是一棵以 1 为根的二叉树。

- 对于测试点 1~3：$n \leq 10$；
- 对于测试点 4~8：$n \leq 200$；
- 对于测试点 9~11：$n \leq 1000$；
- 对于测试点 12~14：$n \leq 10^5$ 且所有 $ls[i] = 0$；
- 对于测试点 15：$n \leq 10^5$ 且所有 $rs[i] = 0$；
- 对于测试点 16~20：$n \leq 10^5$；

## 样例 #1

### 输入

```
12
4
2 3
0 4
0 0
0 0
5
2 3
0 4
0 5
0 0
0 0
6
5 2
3 6
4 0
0 0
0 0
0 0
6
2 3
6 4
0 5
0 0
0 0
0 0
6
5 2
3 0
4 0
6 0
0 0
0 0
6
3 2
4 6
0 0
5 0
0 0
0 0
6
4 2
5 3
0 0
0 0
0 6
0 0
6
3 2
0 0
5 4
0 6
0 0
0 0
6
2 3
0 0
5 4
0 6
0 0
0 0
6
3 2
4 5
0 0
0 6
0 0
0 0
6
2 3
0 4
0 0
0 5
0 6
0 0
6
2 5
3 4
0 0
0 0
6 0
0 0```

### 输出

```
1 2 3 4
1 2 3 4 5
1 2 3 4 5 6
1 2 4 3 5 6
1 2 3 4 6 5
1 2 4 5 3 6
1 2 5 4 6 3
1 2 3 5 4 6
1 2 3 4 5 6
1 2 4 3 6 5
1 2 3 4 5 6
1 2 3 4 5 6```

# AI分析结果



### 关键思路与算法总结

题目要求在最多一次操作下，调整二叉树结构使得先序遍历字典序最小。核心思路是找到能通过移动单个节点带来最大字典序优化的位置。具体步骤如下：

1. **先序遍历序列生成**：获取原树的先序序列，用于后续分析。
2. **最小后缀预处理**：计算每个位置后的最小值数组 `min_after`，用于快速定位可优化点。
3. **查找关键位置**：找到第一个位置 `i`，使得 `S[i] > min_after[i+1]`，确定需要优化的节点位置。
4. **选择调整节点**：在 `i` 之后找到最小值节点 `u`，作为调整的候选。
5. **寻找插入点**：在 `i` 之前的节点中找到首个可插入的空位（优先左子），将 `u` 插入以提前其访问顺序。

### 核心代码实现

```cpp
#include <vector>
#include <algorithm>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right, *parent;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr), parent(nullptr) {}
};

vector<int> original_pre;
vector<TreeNode*> nodes;

void preorder(TreeNode* root) {
    if (!root) return;
    original_pre.push_back(root->val);
    preorder(root->left);
    preorder(root->right);
}

vector<int> solve(TreeNode* root, int n) {
    original_pre.clear();
    preorder(root);
    vector<int> S = original_pre;
    int len = S.size();
    if (len <= 1) return S;

    vector<int> min_after(len, S.back());
    for (int i = len-2; i >= 0; --i)
        min_after[i] = min(S[i], min_after[i+1]);

    int target_i = -1;
    for (int i = 0; i < len-1; ++i) {
        if (S[i] > min_after[i+1]) {
            target_i = i;
            break;
        }
    }

    if (target_i == -1) return S;

    int u_val = min_after[target_i + 1];
    int u_idx = -1;
    for (int j = target_i + 1; j < len; ++j) {
        if (S[j] == u_val) {
            u_idx = j;
            break;
        }
    }

    TreeNode* u = nodes[original_pre[u_idx]-1]; // 假设nodes按val-1索引存储

    vector<TreeNode*> possible_v;
    for (int j = 0; j <= target_i; ++j)
        possible_v.push_back(nodes[original_pre[j]-1]);

    TreeNode* new_parent = nullptr;
    bool is_left = false;
    for (auto v : possible_v) {
        if (!v->left) {
            new_parent = v;
            is_left = true;
            break;
        } else if (!v->right) {
            new_parent = v;
            is_left = false;
            break;
        }
    }

    if (!new_parent) return S;

    // 断开原父节点
    TreeNode* old_parent = u->parent;
    if (old_parent->left == u)
        old_parent->left = nullptr;
    else
        old_parent->right = nullptr;

    // 连接新父节点
    u->parent = new_parent;
    if (is_left)
        new_parent->left = u;
    else
        new_parent->right = u;

    vector<int> new_pre;
    preorder(root);
    new_pre = original_pre;

    // 恢复原树结构（可选，若需多次尝试）
    return min(S, new_pre); // 比较字典序
}
```

### 举一反三：推荐题目

1. **洛谷 P1040 [NOIP2003 提高组] 加分二叉树**  
   考察二叉树遍历与动态规划结合，理解树的结构对序列影响。
   
2. **洛谷 P1305 新二叉树**  
   练习二叉树的构造与遍历，加深对树结构的理解。
   
3. **洛谷 P1038 [NOIP2003 普及组] 神经网络**  
   树形结构应用问题，训练树结构的动态调整与信息传递。

---
处理用时：1094.00秒
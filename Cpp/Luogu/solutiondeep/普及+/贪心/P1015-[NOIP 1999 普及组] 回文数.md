# 题目信息

# [NOIP 1999 普及组] 回文数

## 题目描述

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。

又如：对于十进制数 $87$：

STEP1：$87+78=165$  
STEP2：$165+561=726$  
STEP3：$726+627=1353$   
STEP4：$1353+3531=4884$  

在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。

写一个程序，给定一个 $N$（$2 \le N \le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。

## 样例 #1

### 输入

```
10
87
```

### 输出

```
STEP=4
```

# AI分析结果



### 综合分析与结论
本题核心为高精度N进制加法与回文判断，所有题解均围绕以下核心步骤展开：字符转数值→反转相加→处理进位→回文判断。关键难点在于处理不同进制下的进位规则、十六进制的字符转换，以及大数存储。多数题解采用数组存储+模拟加法，模块化设计和STL优化是主要优化方向。

---

### 高评分题解推荐

#### 1. Haishu（★★★★★）
**关键亮点**  
- 模块化设计（拆分为add/pd函数），代码结构清晰  
- 动态处理前导零，数组索引设计巧妙  
- 包含调试反思，强调正确解题态度（反对利用漏洞）  
**个人心得**  
> "将不同功能写成独立函数，极大简化主程序逻辑。高精度代码应注重数组索引设计和进位处理。"

#### 2. hawa130（★★★★☆）
**关键亮点**  
- 利用STL的`reverse`实现快速反转  
- 分离字符与数值转换逻辑，代码简洁  
- 使用独立函数处理高精度加法，可读性高  
**核心代码**  
```cpp
string add(int k, string a) {
    string rev_a = a; reverse(rev_a.begin(), rev_a.end());
    // 按位相加并处理进位，k为进制
    for(int i=0; i<len; i++) {
        sum = a[i] + rev_a[i] + carry;
        res[i] = sum % k;
        carry = sum / k;
    }
    if(carry) res += '1'; // 处理最高位进位
}
```

#### 3. Strong_Jelly（★★★★☆）
**关键亮点**  
- 详细注释各功能模块（反转、判断、转换）  
- 数组下标从1开始，对齐直观  
- 独立初始化函数处理字符转换  
**核心技巧**  
```cpp
void init() { // 字符转数值存入数组
    for(int i=s.size()-1; i>=0; i--) {
        if(isdigit(s[i])) q[++j] = s[i]-'0';
        else q[++j] = s[i]-'A'+10; // 处理16进制
    }
}
```

---

### 关键思路总结
1. **进制无关处理**：将N进制加法抽象为通用模板，通过`%n`和`/n`替代十进制操作。
2. **回文高效判断**：双指针法或`reverse`后直接比较字符串。
3. **高精度优化**：动态处理前导零，数组存储逆序数值简化索引计算。
4. **十六进制处理**：字符与数值转换时，`A-F`需特殊处理为10-15。

---

### 拓展练习推荐
1. **P1015 [NOIP1999 普及组] 回文数**（同类题型）  
2. **P1005 矩阵取数游戏**（高精度+动态规划）  
3. **P1255 数楼梯**（大数递推+高精度）  

**核心训练点**：高精度运算、进制转换、回文性质应用。

---
处理用时：36.09秒
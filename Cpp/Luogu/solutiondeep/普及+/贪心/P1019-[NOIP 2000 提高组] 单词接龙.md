# 题目信息

# [NOIP 2000 提高组] 单词接龙

## 题目背景

注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

NOIP2000 提高组 T3

## 题目描述

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。


## 说明/提示

样例解释：连成的“龙”为 `atoucheatactactouchoose`。

$n \le 20$。

## 样例 #1

### 输入

```
5
at
touch
cheat
choose
tact
a
```

### 输出

```
23
```

# AI分析结果



### 题解综合分析与结论
两题解均采用DFS解决单词接龙问题，核心差异在于重叠部分处理方式：
1. RyanLi题解正确遍历所有可能的重叠长度，确保不漏最优解，代码简洁高效（4.5星）
2. SuyctidohanQ题解存在逻辑缺陷，仅检查第一个重叠长度可能导致漏解（3星）

关键技巧：**在DFS中遍历所有可能的重叠长度**，确保找到最优连接方式。需注意字符串截取边界和重复使用次数的回溯。

---

### 精选题解

#### 题解1：RyanLi（4.5星）
**核心亮点**  
- 正确性：通过双重循环（单词选择+重叠长度）确保不漏解
- 简洁性：仅用20行核心代码完成DFS逻辑
- 优化点：在递归参数中直接维护当前龙字符串，避免重复计算长度

**个人心得**  
作者提到边界处理是调试难点，体现在`j < min(tmp.size(), s[i].size())`的循环条件设置，确保子串截取不越界。

**核心代码**  
```cpp
void dfs(const string &tmp) {
    ans = max(ans, int(tmp.size()));
    for (int i = 1; i <= n; ++i) {
        if (vis[i] >= 2) continue;
        for (int j = 1; j < min(tmp.size(), s[i].size()); ++j)
            if (tmp.substr(tmp.size() - j) == s[i].substr(0, j)) {
                ++vis[i];
                dfs(tmp + s[i].substr(j));
                --vis[i];
            }
    }
}
```
**实现思想**  
每次递归维护当前拼接结果`tmp`，对每个未超限使用的单词，尝试所有可能的重叠长度`j`。通过`substr`比较前后缀，拼接后继续递归。

---

### 关键思路总结
1. **DFS遍历策略**：以当前龙字符串为状态，尝试所有单词和所有可能的重叠长度
2. **剪枝优化**：通过`vis`数组控制单词使用次数，直接传递拼接结果避免重复计算
3. **边界处理**：重叠长度`j`的取值范围为[1, min(当前长度, 候选词长度)-1]

---

### 拓展与相似题目
1. **预处理优化**：可预先计算所有单词间的最大重叠长度，存储为二维数组加速查询
2. **同类题目推荐**：
   - [P1101 单词方阵](https://www.luogu.com.cn/problem/P1101)（二维矩阵中的单词搜索）
   - [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)（状态压缩+DFS）
   - [P1018 乘积最大](https://www.luogu.com.cn/problem/P1018)（字符串分割与最优化）

---
处理用时：124.20秒
# 题目信息

# [NOIP 2012 提高组] 国王游戏

## 题目描述

恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。


## 说明/提示

【输入输出样例说明】

按 $1$、$2$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $1$、$3$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $2$、$1$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按$ 2$、$3$、$1 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$；

按 $3$、$1$、$2 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；  

按$ 3$、$2$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$。

因此，奖赏最多的大臣最少获得 $2$ 个金币，答案输出 $2$。


 
【数据范围】

对于 $20\%$ 的数据，有 $1≤ n≤ 10,0 < a,b < 8$；

对于 $40\%$ 的数据，有$ 1≤ n≤20,0 < a,b < 8$；

对于 $60\%$ 的数据，有 $1≤ n≤100$；

对于 $60\%$ 的数据，保证答案不超过 $10^9$；

对于 $100\%$ 的数据，有 $1 ≤ n ≤1,000,0 < a,b < 10000$。



NOIP 2012 提高组 第一天 第二题


## 样例 #1

### 输入

```
3 
1 1 
2 3 
7 4 
4 6 ```

### 输出

```
2```

# AI分析结果



### 综合分析与结论
该问题的核心是贪心排序策略与高精度处理。所有题解均认同按左右手乘积升序排列的贪心策略，并通过邻项交换法证明其正确性。关键难点在于：  
1. 严谨证明交换相邻大臣后最大值的单调性变化  
2. 处理大数乘积的高精度实现优化  
3. 高精度除法时前导零处理等细节  

各题解差异主要体现在：数学证明的严谨性、高精度实现方式（是否压位、代码可读性）、异常处理完整性。最优解需同时具备清晰的数学推导和高效的高精度实现。

---

### 精选题解推荐

#### 1. 洛必达法则（★★★★★）
**核心亮点**：  
- 最严谨的数学推导，完整证明邻项交换后的极值单调性  
- 引入引理证明非单调序列必存在可优化逆序对  
- 代码使用压位高精度（BASE=1e4）提升效率  

**关键代码**：
```cpp
struct bign { // 压4位的高精度实现
    int a[MAXN<<2], len, BASE=1e4;
    void operator*=(int rhs) { // 高精乘低精
        for(int i=1;i<=len;i++) a[i]*=rhs;
        for(int i=1;i<=len;i++) {
            a[i+1] += a[i]/BASE;
            a[i] %= BASE;
            if(a[len+1]) len++; 
        }
    }
    bign operator/(int rhs) { // 高精除低精
        bign c; long long cur=0;
        for(int i=len;i>=1;i--) {
            cur = cur*BASE + a[i];
            c.a[i] = cur/rhs;
            cur %= rhs;
        }
        return c;
    }
};
```

#### 2. chc_1234567890（★★★★☆）
**核心亮点**：  
- 高精度类封装完整，支持比较运算符  
- 压位处理（BASE=1e5）减少运算次数  
- 代码结构清晰，易扩展维护  

**关键实现**：
```cpp
struct hp {
    int num[maxn], len; // 存储每一位数字
    hp operator*(int x) { // 高精乘低精
        hp res; int carry=0;
        for(int i=1;i<=len;i++) {
            res.num[i] = num[i]*x + carry;
            carry = res.num[i]/10;
            res.num[i] %= 10;
        }
        while(carry) res.num[++res.len] = carry%10, carry/=10;
        return res;
    }
    bool operator<(const hp &x) { // 重载比较
        if(len != x.len) return len < x.len;
        for(int i=len;i>=1;i--) 
            if(num[i] != x.num[i]) return num[i] < x.num[i];
        return false;
    }
};
```

#### 3. QQ红包（★★★★☆）
**核心亮点**：  
- 代码实现简洁，适合快速理解核心逻辑  
- 使用vector动态管理高精度位数  
- 包含完整的前导零处理逻辑  

**关键片段**：
```cpp
vector<int> div(vector<int> &a, int b) {
    vector<int> res;
    int r = 0;
    for(int i=a.size()-1; i>=0; i--) {
        r = 10*r + a[i];       // 从最高位开始处理
        res.push_back(r / b);
        r %= b;
    }
    reverse(res.begin(), res.end());
    while(res.size()>1 && res.back()==0) res.pop_back(); // 去除前导零
    return res;
}
```

---

### 最优思路总结
**贪心策略**：通过邻项交换法证明，当相邻两位大臣满足 \(a_i \times b_i < a_j \times b_j\) 时，交换后最大值不会增大，故整体应按此排序。  
**高精度优化**：  
1. 压位存储（如1e4进制），减少乘除次数  
2. 乘除法均从低位向高位处理，注意进位/借位  
3. 比较时先比位数，再逐位比较  

---

### 拓展建议
1. **同类贪心问题**：P2123 皇后游戏（邻项交换法）  
2. **高精度应用**：P1009 阶乘之和（大数累加）  
3. **综合训练**：P1248 加工生产调度（贪心+排序）

---

### 调试经验摘录
- **Jerry_zpl**：答案长度为0时需特判输出0，否则会遗漏边界情况  
- **aiyougege**：Python中直接使用浮点除会溢出，需用`divmod`处理整除  
- **VitrelosTia**：高精度除法结果需反向存储后再处理前导零

---
处理用时：69.56秒
# 题目信息

# [NOIP 2007 提高组] 树网的核

## 题目描述

设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。

路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 
$d(a, b)$ 为 $a, b$ 两结点间的距离。

$D(v, P)=\min\{d(v, u)\}$, $u$ 为路径 $P$ 上的结点。

树网的直径：树网中最长的路径成为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

偏心距 $\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即

$$\mathrm{ECC}(F)=\max\{D(v, F),v \in V\}$$

任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)


## 说明/提示

- 对于 $40\%$ 的数据，保证 $n \le 15$。
- 对于 $70\%$ 的数据，保证 $n \le 80$。
- 对于 $100\%$ 的数据，保证 $2\le n \le 300$，$0\le s\le10^3$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^3$。

NOIP2007 提高组第四题

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```

### 输出

```
5```

# AI分析结果



### 综合分析与结论
本题核心在于利用树的性质（直径唯一性、偏心距构成分析），将问题转化为在单一直径上的滑动窗口问题。最优解法通过预处理直径端点距离和支链距离，结合双指针维护窗口，将时间复杂度优化至 O(n)。关键突破点在于发现偏心距由三个因素构成（左端点到直径端距离、右端点到另一端距离、支链最大距离），而支链最大值可预先计算。

---

### 高星题解推荐

#### 1. StudyingFather（⭐⭐⭐⭐⭐）
**核心亮点**：
- 严格数学证明直径性质，奠定算法正确性基础
- 提供四种解法阶梯式优化，清晰展示算法进化路径
- 最终解法 O(n) 时间+简洁实现，利用前缀和与区间最大值预处理

**关键代码**：
```cpp
namespace sub4 {
void solve() {
  // 预处理支链最大距离
  for (int i = 1; i <= cnt; i++) {
    dep[dia[i]] = 0, c = 0;
    dfs(dia[i], 0);
    maxd = max(dep[c], maxd);
  }
  
  // 双指针滑动窗口
  int minecc = 1 << 30;
  for (int l = 1, r = 1; l <= cnt; l++) {
    while (r <= cnt && pres[r+1] - pres[l] <= s) r++;
    minecc = min(max(maxd, max(pres[l], posts[r])), minecc);
  }
}
}
```

#### 2. Mosklia（⭐⭐⭐⭐）
**核心亮点**：
- 直观的双指针实现，结合单调队列维护区间最大值
- 利用两次DFS快速定位直径端点
- 代码结构清晰，注释完整易于理解

**实现技巧**：
```cpp
std::deque<int> q; // 单调队列维护支链最大值
for (int i=1, j=1; i<=m; ...) {
    while(q非空且窗口左移) q.pop_front();
    while(新增右端点) q维护单调性;
    ans = min(max(端点贡献, q.front()), ans);
}
```

#### 3. 天泽龟（⭐⭐⭐）
**核心亮点**：
- 二分答案思路拓展，适合超大规模数据
- 引入LCA处理支链影响，严谨处理边界问题

**个人心得**：
> "在二分边界处理时，发现支链可能影响偏心距，调试了7小时才找到遗漏情况。这提醒在树形问题中，必须全面考虑所有分支的可能贡献"

---

### 最优关键思路总结
1. **直径性质利用**：所有直径必相交，只需处理其中一条
2. **偏心距三要素**：`max(左端点贡献, 右端点贡献, 支链最大值)`
3. **双指针优化**：在直径数组上滑动窗口，维护路径长度 ≤s
4. **预处理技巧**：
   - 通过DFS预处理直径端点距离（前缀和数组）
   - 单次DFS预处理所有节点的支链最大距离

---

### 相似题目推荐
1. [P2491 [SCOI2008] 防线](https://www.luogu.com.cn/problem/P2491)  
   （树网的核加强版，需处理更大规模数据）
2. [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)  
   （本题原题，可测试不同解法效率）
3. [P4381 [IOI2008] Island](https://www.luogu.com.cn/problem/P4381)  
   （基环树结构中的最长链问题，运用直径相关性质）

---

### 核心代码实现（StudyingFather解法四）
```cpp
void solve() {
  // 预处理直径端点距离
  get_diameter(); // 获取直径数组dia[]及前缀和pres[]
  
  // 预处理支链最大值
  int maxd = 0;
  for (int i=1; i<=cnt; i++) {
    dfs(dia[i], 0); // 以直径节点为根DFS求支链
    maxd = max(dep[c], maxd);
  }
  
  // 双指针滑动窗口
  int ans = INT_MAX;
  for (int l=1, r=1; l<=cnt; l++) {
    while (r+1<=cnt && pres[r+1]-pres[l]<=s) r++;
    ans = min(ans, max({maxd, pres[l], pres[cnt]-pres[r]}));
  }
  cout << ans;
}
```

---
处理用时：65.93秒
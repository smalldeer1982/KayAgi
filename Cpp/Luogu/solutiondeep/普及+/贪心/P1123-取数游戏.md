# 题目信息

# 取数游戏

## 题目描述

一个 $N\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。

## 说明/提示

### 样例解释

对于第一组数据，取数方式如下：

$$\begin{matrix}
[67] & 75 & 63 & 10 \\
29 & 29 & [92] & 14 \\
[21] & 68 & 71 & 56 \\
8 & 67 & [91] & 25 \\
\end{matrix}$$


### 数据范围及约定

- 对于$20\%$的数据，$1\le N, M \le 3$；
- 对于$40\%$的数据，$1\le N, M\le 4$；
- 对于$60\%$的数据，$1\le N, M\le 5$；
- 对于$100\%$的数据，$1\le N, M\le 6$，$1\le T\le 20$。


## 样例 #1

### 输入

```
3
4 4
67 75 63 10
29 29 92 14
21 68 71 56
8 67 91 25
2 3
87 70 85
10 3 17
3 3
1 1 1
1 99 1
1 1 1

```

### 输出

```
271
172
99
```

# AI分析结果



### 综合分析与结论
本题核心在于不相邻选取条件下的最大值求解，常见解法为DFS回溯与状压DP。DFS通过剪枝与状态标记控制时间复杂度，状压DP通过状态压缩与预处理实现高效转移。数据规模较小（N,M≤6），两种方法均可通过，但状压DP在多次测试时更高效。

---

### 高分题解推荐

#### 1. 绿萧（★★★★☆）
**亮点**：DFS回溯思路清晰，方向数组处理完整，用`mark`数组计数解决重叠标记问题。  
**个人心得**：强调方向数组与回溯时增减计数的正确性，避免布尔标记的覆盖问题。  
**核心代码**：
```cpp
void dfs(int x,int y){
    if(y==m+1) dfs(x+1,1);
    if(x==n+1) mx=max(ans,mx);
    dfs(x,y+1); // 不取
    if(mark[x][y]==0){
        ans += s[x][y];
        // 标记八个方向
        dfs(x,y+1);
        // 回溯
    }
}
```

#### 2. IntrepidStrayer（★★★★★）
**亮点**：状压DP思路，预处理合法状态，状态转移方程清晰，时间复杂度最优。  
**关键实现**：
```cpp
void work(){
    for(int i=0;i<(1<<m);i++)
        if(!(i&(i>>1)) && !(i&(i<<1))) // 行内不相邻
            t.push_back(i);
}
// DP转移时检查上下行约束
if((u&v)||(u&(v>>1))||(u&(v<<1))) continue;
```

#### 3. 回头是岸（★★★★☆）
**亮点**：简洁的状压DP实现，预处理合法状态，代码可读性强。  
**核心代码**：
```cpp
vector<int> t; // 存储合法状态
for(int j=0;j<t.size();j++)
    for(int k=0;k<t.size();k++)
        if(!(t[j]&t[k]) && ...) // 上下行约束
            f[i][j] = max(f[i][j], f[i-1][k]+sum);
```

---

### 关键思路总结
1. **DFS回溯**：按行列顺序遍历，用计数数组标记相邻区域，避免覆盖问题，需完整处理8方向。
2. **状压DP**：将每行选法压缩为二进制，预处理行内合法状态，转移时检查上下行约束。

---

### 拓展与相似题目
1. **P1896 互不侵犯**（状压DP经典）
2. **P1879 玉米田**（网格不相邻选取，类似状压思路）
3. **P2704 炮兵阵地**（三维状压DP，更复杂相邻约束）

---

### 调试与优化心得摘录
- **绿萧**：强调用计数而非布尔数组，避免回溯时错误清除标记。  
- **zhi_zhang**：逐步剪枝优化经验（如跳过已处理行、减少标记方向）对DFS效率提升显著。  
- **IntrepidStrayer**：预处理合法状态大幅减少无效计算，是状压DP的关键优化点。

---
处理用时：70.23秒
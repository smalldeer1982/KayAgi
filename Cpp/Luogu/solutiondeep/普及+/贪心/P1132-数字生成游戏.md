# 题目信息

# 数字生成游戏

## 题目描述

小明完成了这样一个数字生成游戏，对于一个不包含 $0$ 的数字 $s$ 来说，有以下 $3$ 种生成新的数的规则：

1.    将 $s$ 的任意两位对换生成新的数字，例如 $143$ 可以生成 $314,413,134$；

2.    将 $s$ 的任意一位删除生成新的数字，例如 $143$ 可以生成 $14,13,43$；

3.    在 $s$ 的相邻两位之间 $s_i,s_{i + 1}$ 之间插入一个数字 $x$，$x$ 需要满足 $s_i<x<s_{i + 1}$。例如 $143$ 可以生成 $1243,1343$，但是不能生成 $1143,1543$ 等。

现在小明想知道，在这个生成法则下，从 $s$ 开始，每次生成一个数，可以用然后用新生成的数生成另外一个数，不断生成直到生成 $t$ 至少需要多少次生成操作。

另外，小明给规则 $3$ 又加了一个限制，即生成数的位数不能超过初始数 $s$ 的位数。若 $s$ 是 $143$，那么 $1243$ 与 $1343$ 都是无法生成的；若 $s$ 为 $1443$，那么可以将 $s$ 删除变为 $143$，再生成 $1243$ 或 $1343$。

## 说明/提示

**样例解释**

$143\to 134$

$133$ 无法得到

$143\to13\to123\to23\to32$

**数据范围**

对于 $20\%$ 的数据，$s < 100$；  
对于 $40\%$ 的数据，$s < 1000$；  
对于 $40\%$ 的数据，$m < 10$；  
对于 $60\%$ 的数据，$s < 10000$；  
对于 $100\%$ 的数据，$s < 100000,m ≤ 50000$。

## 样例 #1

### 输入

```
143
3
134
133
32
```

### 输出

```
1
-1
4
```

# AI分析结果



### 综合分析与结论
本题所有题解均采用BFS预处理所有可达数字，通过三种操作生成新状态。核心难点在于正确处理插入操作的相邻数位限制，以及通过字符串/数字操作高效处理状态转换。推荐代码简洁、利用字符串特性简化操作的解法。

---

### 高星题解推荐

#### 1. 作者：Alarm5854（⭐⭐⭐⭐⭐）
**关键亮点**：
- 使用字符串操作简化三种规则实现（swap/erase/insert）
- 利用stoi/atoi完成字符串与数字转换，极大提升代码可读性
- 队列直接存储整型数值，配合d数组记录步数，逻辑简洁
**核心代码**：
```cpp
void bfs(int s) {
    memset(d, -1, sizeof(d)); 
    queue<int> q; q.push(s); d[s] = 0;
    while (!q.empty()) {
        int x = q.front(); q.pop();
        string t = to_string(x);
        int len = t.length();
        // 交换操作
        for (int i = 0; i < len; ++i)
            for (int j = i+1; j < len; ++j) {
                string u = t; swap(u[i], u[j]);
                int k = stoi(u);
                if (d[k] == -1) d[k] = d[x]+1, q.push(k);
            }
        // 删除操作 
        if (len > 1) for (int i = 0; i < len; ++i) {
            string u = t; u.erase(i, 1);
            int k = stoi(u);
            if (d[k] == -1) d[k] = d[x]+1, q.push(k);
        }
        // 插入操作
        if (len == l) continue;
        for (int i = 1; i < len; ++i)
            for (char c = t[i-1]+1; c < t[i]; ++c) {
                string u = t; u.insert(i, 1, c);
                int k = stoi(u);
                if (d[k] == -1) d[k] = d[x]+1, q.push(k);
            }
    }
}
```

#### 2. 作者：Just_do_it（⭐⭐⭐⭐）
**关键亮点**：
- 采用数组逐位处理，避免字符串转换开销
- 显式处理数字反转存储顺序，适合数字操作
- 分离三种操作的实现逻辑，便于调试
**核心代码片段**：
```cpp
// 删除操作实现
for(int i = 1;i <= len;i++){ 
    b = 0;
    for(int j = len;j >= 1;j--) 
        if(j != i) b = b*10+s[j];
    if(!flag[b]) {
        flag[b] = true;
        f[b] = a.ans+1;
        q.push({b, a.ans+1});
    }
}
```

#### 3. 作者：清尘（⭐⭐⭐）
**亮点**：
- 使用string.substr简化字符串截取操作
- 显式维护步骤计数器，逻辑清晰
**优化点**：
```cpp
// 插入操作实现
for (int i = 0; i < t.s.size() - 1; ++i) {
    for (int j = t.s[i] - '0' + 1; j < t.s[i+1] - '0'; ++j) {
        string ns = t.s;
        ns.insert(ns.begin() + i + 1, j + '0');
        int k = stoi(ns);
        if (!vis[k]) q.push({ns, t.step+1});
    }
}
```

---

### 关键思路总结
1. **状态表示**：将数字视为图节点，操作视为边，BFS求最短路径
2. **剪枝优化**：通过flag数组避免重复访问，保证首次访问即最优解
3. **字符串技巧**：利用字符串的swap/erase/insert简化操作实现
4. **预处理思想**：先计算所有可能结果的步数，实现O(1)查询

---

### 同类题目推荐
1. [P1032 字变换](https://www.luogu.com.cn/problem/P1032) - 字符串变换BFS
2. [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379) - 经典状态空间搜索
3. [P1126 机器人搬重物](https://www.luogu.com.cn/problem/P1126) - 复杂状态转移BFS

---

### 调试心得摘录
> **Alarm5854**：  
> "利用stoi/to_string极大简化了字符串与数字的转换，调试时要注意插入操作中字符与数字的转换"  
> **Eraine**：  
> "忘记处理插入后的位数限制导致WA，必须显式判断当前数字位数是否已达初始长度"  
> **破忆**：  
> "直接操作整型数字时，特别注意数字反转存储的顺序问题，容易导致交换错位"

---
处理用时：78.96秒
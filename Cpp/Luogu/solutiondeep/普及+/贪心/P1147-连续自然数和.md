# 题目信息

# 连续自然数和

## 题目描述

对一个给定的正整数 $M$，求出所有的连续的正整数段（每一段至少有两个数），这些连续的自然数段中的全部数之和为 $M$。

例子：$1998+1999+2000+2001+2002 = 10000$，所以从 $1998$ 到 $2002$ 的一个自然数段为 $M=10000$ 的一个解。


## 样例 #1

### 输入

```
10000
```

### 输出

```
18 142 
297 328 
388 412 
1998 2002
```

# AI分析结果



### 综合分析与结论
本题核心在于利用等差数列性质与数学优化手段降低复杂度。所有题解中，数学分解因数法（gzw2005）和尺取法（Frenix）最具优化价值，时间复杂度分别为O(√M)和O(M)。暴力枚举类解法虽直观但效率低，仅适合小范围数据。

---

### 高评分题解与亮点

#### 题解1：gzw2005（5星）
**关键思路**：  
将和式转化为 $(L+R)(R-L+1)=2M$，枚举2M的因数对 $(k1,k2)$，要求k1与k2奇偶性不同。通过解方程组直接计算首末项。  
**优势**：  
- 时间复杂度O(√M)，最优解  
- 数学推导严谨，代码简洁  
**核心代码**：
```cpp
for(int k1=sqrt(2*m);k1>1;k1--)
    if(2*m%k1==0 && (k1+2*m/k1)%2) {
        int k2=2*m/k1;
        cout<<(k2-k1+1)/2<<" "<<(k1+k2-1)/2<<endl;
    }
```

#### 题解2：Frenix（4星）
**关键思路**：  
使用双指针维护滑动窗口，动态调整区间和。当sum < M时右扩，sum > M时左缩，找到等于M的区间。  
**优势**：  
- 时间复杂度O(M)，线性复杂度  
- 无需复杂数学推导，适合理解滑动窗口思想  
**核心代码**：
```cpp
int sum=3;
for(int i=1,j=2; i<=m/2; ) {
    if(sum==m) {
        printf("%d %d\n",i,j);
        sum-=i; i++;
    } else if(sum<m) {
        j++; sum+=j;
    } else {
        sum-=i; i++;
    }
}
```

#### 题解3：lamboo（4星）
**关键思路**：  
通过一元二次方程求根公式解出末项，验证根是否为整数。利用数学公式直接推导首末项。  
**亮点**：  
- 数学推导完整，代码中处理了整数判断边界  
- 时间复杂度O(M/2)，优于纯暴力  
**核心代码**：
```cpp
double x = (-1 + sqrt(1-4*(i-i*i-2*n)))/2;
if((int)x == x && x > i) 
    cout<<i<<" "<<(int)x<<endl;
```

---

### 关键技巧总结
1. **数学优化**：将问题转化为因数分解或方程求解，降低时间复杂度至O(√M)级别。  
2. **滑动窗口**：双指针维护动态区间和，适用于连续序列问题。  
3. **等差数列性质**：利用求和公式与奇偶性判断解的合法性。

---

### 拓展练习推荐
1. **P1214 等差数列**（数学推导+枚举优化）  
2. **P1638 逛画展**（滑动窗口典型应用）  
3. **P2879 区间和**（前缀和与数学性质结合）  

---

### 题解中的调试经验
1. **gzw2005**：强调k1需从√(2M)开始向下枚举，避免重复计算。  
2. **Frenix**：通过sum的增减模拟滑动窗口，初始值需设为3（对应i=1,j=2）。  
3. **lamboo**：发现变量溢出问题后改用long long保存中间结果，体现数据类型敏感度。

---
处理用时：54.04秒
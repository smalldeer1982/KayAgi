# 题目信息

# 打砖块

## 题目描述

小红很喜欢玩一个叫打砖块的游戏，这个游戏的规则如下：

在刚开始的时候，有 $n$ 行 $m$ 列的砖块，小红有 $k$ 发子弹。小红每次可以用一发子弹，打碎某一列当前处于这一列最下面的那块砖，并且得到相应的得分。（如图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/twgirdp6.png)

某些砖块在打碎以后，还可能将得到一发子弹的奖励。最后当所有的砖块都打碎了，或者小红没有子弹了，游戏结束。

小红在游戏开始之前，就已经知道每一块砖在打碎以后的得分，并且知道能不能得到一发奖励的子弹。小红想知道在这次游戏中她可能的最大得分，可是这个问题对于她来说太难了，你能帮帮她吗？


## 说明/提示

对于 $20\%$ 的数据，满足 $1  \le n,m  \le 5$，$1  \le k  \le 10$，所有的字符 $c$ 都为 `N`。

对于 $50\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，所有的字符 $c$ 都为 `N`。

对于 $100\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，字符 $c$ 可能为 `Y`。

对于 $100\%$ 的数据，所有的 $f$ 值满足 $1  \le f  \le 10000$。


## 样例 #1

### 输入

```
3 4 2
9 N 5 N 1 N 8 N
5 N 5 Y 5 N 5 N
6 N 2 N 4 N 3 N```

### 输出

```
13```

# AI分析结果



### 综合分析与结论
本题核心在于处理Y类型砖块的子弹奖励机制带来的后效性问题。各题解均采用动态规划，核心思路为：
1. **预处理列数据**：将每列的Y砖块压缩到其下方N砖块，计算每列在不同子弹消耗下的得分（分是否以N结尾）
2. **状态设计**：多数题解采用三维DP（列数、已用子弹数、最后一发是否在当前列）
3. **子弹借用机制**：通过状态转移处理子弹的"先借后还"逻辑，解决Y砖块带来的子弹数变化问题

### 高星题解推荐

#### 1. Azuree（5星）
**关键亮点**：
- 清晰解释Y砖块的压缩逻辑与子弹借用机制
- 明确的状态定义：`f[i][j][0/1]`分别表示是否以N结尾
- 完整的状态转移方程推导，覆盖四种转移情况
- 代码结构清晰，包含详细注释

**核心代码**：
```cpp
for(int i = 1; i <= m; i++)
    for(int j = 0; j <= k; j++)
        for(int l = 0; l <= min(n,j); l++) {
            f[i][j][1] = max(f[i][j][1], f[i-1][j-l][1] + v[i][l][1]);
            if(l) f[i][j][0] = max(f[i][j][0], f[i-1][j-l][1] + v[i][l][0]);
            if(j > l) f[i][j][0] = max(f[i][j][0], f[i-1][j-l][0] + v[i][l][1]);
        }
```

#### 2. I_AM_HelloWord（4星）
**关键亮点**：
- 提出"借子弹"的具象化概念，便于理解状态转移
- 使用`sum1/sum2`区分是否以N结尾的预处理得分
- 通过`dp[j][k][0/1]`状态巧妙处理子弹数变化

**核心代码**：
```cpp
for(int j=1;j<=m;j++)
    for(int tk=1;tk<=k;tk++)
        for(int i=cur[j];i<=n;i++)
            if(!b[i][j] && tk>=tot[j][i]) {
                ChkMax(dp[j][tk][0], dp[j-1][tk-tot[j][i]][1]+sum1[j][i]);
                ChkMax(dp[j][tk][0], dp[j-1][tk-tot[j][i]][0]+sum2[j][i]);
                ChkMax(dp[j][tk][1], dp[j-1][tk-tot[j][i]][1]+sum2[j][i]);
            }
```

### 关键技巧总结
1. **Y砖块压缩**：将连续Y砖块的得分累加至下方N砖块，转化为分组背包问题
2. **状态维度设计**：增加最后一发子弹位置的维度（是否在当前列）以消除后效性
3. **子弹借用逻辑**：通过`dp[][][0]`与`dp[][][1]`的状态区分处理子弹数变化
4. **逆向预处理**：从下到上遍历砖块，方便计算连续Y砖块的累计得分

### 拓展训练
1. **P1776 宝物筛选**（分组背包+多重背包优化）
2. **P1064 金明的预算方案**（依赖型背包问题）
3. **P1941 飞扬的小鸟**（多状态转移与资源管理）

### 调试心得摘录
- **迷失之夜**指出："`dp[j][k][0] = max(...)`的第二项转移容易被忽视，实则是处理当前列借用前面子弹的情况"
- **Harry_Hedwig**强调："最后一发子弹必须打在N上，否则会产生无效状态"
- **panda_eater**调试发现："预处理时需要将子弹数限制在`min(n,k)`，否则会访问非法内存"

---
处理用时：58.10秒
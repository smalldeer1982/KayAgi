# 题目信息

# [USACO12MAR] Tractor S

## 题目描述

经过一天漫长的工作，农场主 John 完全忘记了他的拖拉机还在场地中央。他的奶牛们总喜欢和他搞些恶作剧，它们在场地的不同位置丢下 $n$ 堆干草。这样 John 就必须先移走一些干草堆才能将拖拉机开走。

拖拉机和干草堆都可以看作是二维平面上的点，它们的坐标都是整数，没有哪堆干草的坐标和拖拉机的初始坐标一致。John 驾驶拖拉机只能沿着坐标轴的方向移动若干单位长度，比如说，他可以先朝北移动 $2$ 个单位长度，再向东移动 $3$ 个单位长度等等。拖拉机不能移动到干草堆所占据的点。

请你帮助 John 计算一下，最少要移动多少堆干草才能将拖拉机开回坐标原点。

## 说明/提示

对于 $100\%$ 的数据，保证 $1 \leq n \leq 5 \times 10^4$，$1 \leq x_i, y_i \leq 10^3$。

## 样例 #1

### 输入

```
7 6 3 
6 2 
5 2 
4 3 
2 1 
7 3 
5 4 
6 4 ```

### 输出

```
1 ```

# AI分析结果



### 综合分析与结论
本题核心为求从起点到原点的最短路径，其中经过干草堆需计数。最优解法是将移动视为边权（0：无障碍，1：有障碍），采用双端队列BFS（01 BFS）实现高效搜索，时间复杂度O(N)。其他可行方法包括优先队列（Dijkstra）和SPFA，但双端队列实现更简洁高效。

---

### 高星题解推荐

#### 1. 一只书虫仔（⭐⭐⭐⭐⭐）
**关键亮点**  
- **01 BFS标准应用**：将无障碍移动（权0）加入队首，有障碍（权1）加入队尾，保证队列单调性。
- **代码简洁清晰**：结构明确，直接处理坐标范围至1000，避免越界。
```cpp
deque<Node> q;
while (!q.empty()) {
    Node cur = q.front(); q.pop_front();
    for (移动方向) {
        if (新坐标合法且未访问) {
            if (是干草堆) {
                step[nxt] = step[cur] + 1;
                q.push_back(nxt); // 权1入队尾
            } else {
                step[nxt] = step[cur];
                q.push_front(nxt); // 权0入队首
            }
        }
    }
}
```

#### 2. _Atyou（⭐⭐⭐⭐）
**关键亮点**  
- **坐标范围扩展**：处理坐标至1001防止越界，增强鲁棒性。
- **反向搜索优化**：从原点出发反向搜索至起点，减少无效遍历。
```cpp
deque<pair<int, int>> q;
q.push_back(make_pair(0, 0)); // 从原点出发
while (!q.empty()) {
    auto [x, y] = q.front(); q.pop_front();
    if (到达起点) return step;
    for (移动方向) {
        if (新坐标在0~1001范围内) {
            f[x0][y0] = f[x][y] + a[x0][y0]; // 动态更新步数
            if (有障碍) q.push_back(新坐标);
            else q.push_front(新坐标);
        }
    }
}
```

#### 3. soy_un_perro（⭐⭐⭐）
**关键亮点**  
- **优先队列实现Dijkstra**：适合边权非负场景，代码逻辑直观。
- **负数技巧处理小根堆**：通过存入负数实现优先队列升序排列。
```cpp
priority_queue<pair<int, pair<int, int>>> q; // 第一维取反实现小根堆
q.push({0, {-sx, -sy}});
while (!q.empty()) {
    auto [step, pos] = q.top(); q.pop();
    if (到达原点) return -step;
    for (移动方向) {
        int new_step = -step + (有障碍 ? 1 : 0);
        q.push({-new_step, 新坐标}); // 负数入队维持小根堆性质
    }
}
```

---

### 最优思路总结
1. **01 BFS核心**：将边权0/1的路径搜索转化为双端队列处理，确保队首始终为当前最短路径点。
2. **坐标处理技巧**：扩展地图边界至1001或更高，避免复杂越界判断。
3. **动态更新步数**：直接通过队列操作维护到达各点的最小移除数，无需额外松弛操作。

---

### 举一反三
- **同类题目推荐**  
  - [P4667](https://www.luogu.com.cn/problem/P4667)（01 BFS变形）  
  - [P1948](https://www.luogu.com.cn/problem/P1948)（边权处理与最短路）  
  - [P4554](https://www.luogu.com.cn/problem/P4554)（BFS与优先队列结合）

---

### 题解个人心得摘录
- **一只书虫仔**：强调01 BFS适用场景为边权仅0/1的最短路问题，是TG组实用技巧。  
- **SzTC**：多次BFS需注意连通块处理可能导致的低效，建议优先使用双端队列。  
- **Tony2**：复杂连通块方法耗时且易错，验证了简单算法的优越性。  

（注：部分低星题解因复杂度高或实现冗余未入选，建议优先掌握双端队列BFS）

---
处理用时：109.49秒
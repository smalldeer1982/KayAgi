# 题目信息

# 元旦晚会

## 题目背景

玛雅人预言的世界末日没有发生，我们迎来了地球的第五个太阳纪。

学校将要举办第五个太阳纪的第一次元旦晚会。Brett 的班级要参加，并且还表演节目。

## 题目描述

Brett 班的节目是这样的：全班 $n$ 个同学排成一排，同学们手拿话筒，齐唱《喜洋洋与灰太狼》（这个节目看起来有点二） 。

Brett 班的同学分成了 $m$ 个声部，一个声部由连续的同学组成，第 $i$ 个声部由 $a_i$ 到 $b_i$ 之间的同学组成（包括 $a_i$ 和 $b_i$ ）

但是一个同学有可能同时属于多个声部，且有可能有同学不属于任何一个声部。为了保证演唱效果，第 $i$ 个声部必须至少有 $c_i$ 个同学持有话筒（即第 $i$ 个声部持有话筒的同学数大于等于 $c_i$）。

请你算出 Brett 班最少需要几个话筒。

## 说明/提示

对于 $100\%$ 的数据，保证 $n \le 30000$，$m \le 5000$，$1 \le a_i < b_i \le n$，$c_i \le b_i - a_i + 1$。

## 样例 #1

### 输入

```
11 5 
3 7 3 
8 10 3 
6 8 1 
1 3 1 
10 11 1 ```

### 输出

```
6 ```

# AI分析结果



### 综合分析与结论
各题解核心思路为贪心算法（按右端点排序+从右往左放置话筒），正确性已被广泛验证。线段树优化将复杂度降至O(n log n)，但实现复杂。差分约束方法存在正确性争议，实际代码可能未正确处理所有约束。

---

### 高分题解推荐（≥4星）

1. **作者：_Ayanami_（4.5星）**  
   **关键亮点**：  
   - 清晰的贪心思路证明，类比经典种树问题  
   - 代码简洁易懂，直接体现贪心核心逻辑  
   - 提供同类题目参考，方便举一反三  

   **核心代码**：
   ```cpp
   sort(x+1,x+m+1,cmp); // 按右端点排序
   for(int i=1;i<=m;i++){
       int a=0;
       for(int j=x[i].l;j<=x[i].r;j++) a += z[j]; // 统计已有话筒
       for(int j=x[i].r; a<x[i].t; j--){ // 从右向左补足
           if(!z[j]) z[j]=1, ans++, a++;
       }
   }
   ```

2. **作者：pocafup（4星）**  
   **关键亮点**：  
   - 线段树优化将复杂度降至O(n log n)  
   - 提出暴力贪心的局限性及优化方向  
   - 虽未贴完整代码，但给出清晰优化思路  

   **核心思路**：
   ```cpp
   线段树维护区间空位，每次二分查找可放置位置：
   for(int i=1;i<=m;i++){
       int num = query(区间话筒数);
       while(num不足){
           int pos = query2(最右空位); // 线段树查找
           update(pos); // 线段树更新
       }
   }
   ```

3. **作者：JiaY19（4星）**  
   **关键亮点**：  
   - 代码结构紧凑，变量命名清晰  
   - 明确点出双倍经验题P1645/P1250  
   - 快速读入优化处理大数据（虽题目未卡常）  

---

### 最优思路总结
**关键技巧**：  
1. **右端点排序**：最大化后续区间重复利用话筒的可能性  
2. **反向贪心**：从右往左放置话筒，优先满足后续区间需求  
3. **重叠统计优化**：暴力统计可用布尔数组，线段树优化查询效率  

**同类问题套路**：  
- 区间覆盖问题（如P1250种树）  
- 资源最小化分配（如P1645序列）  
- 贪心与数据结构的结合（如CF817F MEX Queries）  

---

### 推荐练习题
1. **P1250 种树** - 完全相同的贪心模型  
2. **P1645 序列** - 双倍经验题，仅输入格式差异  
3. **P4550 收集邮票** - 贪心与期望结合的高阶变形  

---

### 题解心得摘录
- **调试教训**：多题解提到初始未考虑区间重叠统计，需先遍历已有话筒  
- **顿悟点**：按右端点排序后，后续区间的右端点必然≥当前区间的右端点  
- **经验迁移**：识别出与经典种树问题同构，快速找到正确解法  

---

**核心代码实现（贪心版）**：
```cpp
struct node{ int l,r,c; };
bool cmp(node a, node b) { return a.r < b.r; }

int main() {
    // 输入与排序
    sort(a, a+m, cmp);
    vector<bool> mic(n+1);
    for(auto [l,r,c] : a){
        int cnt = count(mic.begin()+l, mic.begin()+r+1, true);
        for(int i=r; cnt<c; i--){ // 反向补足
            if(!mic[i]) mic[i]=1, cnt++, ans++;
        }
    }
    cout << ans;
}
```

---
处理用时：66.43秒
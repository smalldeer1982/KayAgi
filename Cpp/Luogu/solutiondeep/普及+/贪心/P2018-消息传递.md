# 题目信息

# 消息传递

## 题目描述

巴蜀国的社会等级森严，除了国王之外，每个人均有且只有一个直接上级，当然国王没有上级。如果 $A$ 是 $B$ 的上级，$B$ 是 $C$ 的上级，那么 $A$ 就是 $C$ 的上级。绝对不会出现这样的关系：$A$ 是 $B$ 的上级，$B$ 也是 $A$ 的上级。

最开始的时刻是 $0$，你要做的就是用 $1$ 单位的时间把一个消息告诉某一个人，让他们自行散布消息。在任意一个时间单位中，任何一个已经接到消息的人，都可以把消息告诉他的一个直接上级或者直接下属。

现在，你想知道：

1. 到底需要多长时间，消息才能传遍整个巴蜀国的所有人？
2. 要使消息在传递过程中消耗的时间最短，可供选择的人有那些？


## 样例 #1

### 输入

```
8

1

1

3

4

4

4

3```

### 输出

```
5

3 4 5 6 7```

# AI分析结果



### 综合分析与结论
本题核心在于树形DP与贪心策略的结合，通过分析不同根节点下的消息传播时间，寻找最优解。题解主要分为三类：暴力枚举根节点（O(n²logn)）、记忆化搜索优化（O(nlogn)）、二次扫描换根法（O(nlogn)）。最优解法通过预处理子树信息与父节点信息，避免重复计算。

---

### 精选题解分析

#### 1. 作者：zzw4257（★★★★★）
**关键亮点**：  
- 采用二次扫描换根法，将复杂度优化至O(nlogn)，显著优于暴力枚举  
- 引入前缀后缀最大值数组处理节点顺序，巧妙处理父子双向信息  
- 代码结构清晰，完整展示down/up的DP转移过程  

**核心代码**：  
```cpp
void tree_dp(int x) {
    vector<int> son;
    for (int y : children) { // 处理子树信息
        tree_dp(y);
        son.push_back(dpson[y]);
    }
    sort(son.rbegin(), son.rend());
    for (int i=0; i<son.size(); i++) 
        dpson[x] = max(dpson[x], son[i] + i + 1);
}

void change_root(int x) {
    vector<int> son = collect_all_children_and_up_info(); 
    sort(son.rbegin(), son.rend());
    // 计算前缀后缀最大值
    for (int y : children) {
        int pos = find_position_in_sorted_list();
        dpfa[y] = calc_max_without_current_child(); 
    }
}
```

#### 2. 作者：素质玩家孙1超（★★★★★）
**关键亮点**：  
- 记忆化搜索实现优雅，通过父节点状态区分子树形态  
- 利用邻接表双向建边，统一处理上下级关系  
- 代码极度简洁（仅40行），可读性极佳  

**核心实现**：  
```cpp
int dfs(int u, int fa) {
    if (dp[u][fa]) return dp[u][fa]; // 记忆化核心
    vector<int> sons;
    for (int v : adj[u]) 
        if (v != fa) sons.push_back(dfs(v, u));
    sort(sons.rbegin(), sons.rend());
    int res = 0;
    for (int i=0; i<sons.size(); i++)
        res = max(res, sons[i] + i + 1);
    return dp[u][fa] = res;
}
```

#### 3. 作者：刘备（★★★★☆）
**关键亮点**：  
- 引入dp[i][fa]状态，显式区分不同父节点下的子树形态  
- 通过全局记忆化避免重复计算，优化明显  
- 代码中包含重要调试提示（如数组不能全局声明）  

**个人心得**：  
> "数组p不能开成全局变量（否则会WA），因为不同递归层的排序会互相干扰"

---

### 关键思路总结
1. **贪心排序子节点**：无论何种解法，均对子节点的传播时间降序排序，优先处理耗时大的子树  
2. **状态复用技术**：通过记忆化搜索或换根法，复用不同根节点下的子树计算结果  
3. **双向信息处理**：二次扫描法中分别计算子树信息（down）和父链信息（up）  

---

### 拓展与举一反三
1. **同类型题目推荐**：  
   - P1040 加分二叉树（树形DP+记忆化）  
   - P1272 重建道路（子树分离与合并）  
   - P2279 消防局的设立（贪心覆盖树节点）  
   
2. **算法延伸**：  
   换根法可应用于所有需要枚举根节点的树问题（如树的直径、最大权路径等），通过预处理实现O(n)复杂度。

---
处理用时：66.42秒
# 题目信息

# 肮脏的牧师

## 题目背景

@Yumis 出题人在这里哦~


## 题目描述

Yumis最近在玩炉石传说。

在炉石传说中脏牧有一张一费卡片（一费就是使用要消耗1点法力水晶），叫做疯狂药水，这个的效果是将一个敌方场上攻击小于等于2的随从拉到自己的战场内。

还有一张四费卡片叫做暗影狂乱，这个的效果是将一个敌方场上攻击小于等于3的随从拉到自己的战场内。

还有一张一费卡片就是缩小药水，这个的效果是将敌人全场的随从攻击力下降3点。


你PY了炉石的GM所以你有了无数张的这三种卡片，但是GM告诉你缩小药水是这个牌比较不好创建，为了为GM着想你必须在使用**最少的缩小药水**的情况下A爆对手的脸。


现在你的对手场上有n个随从，每个随从的攻击力是ki点。

你的对手有m点血量。


而你现在要做的就是将敌方的场上的随从拉过来自己的场上并攻击对手（每一个随从只能攻击一次，攻击力为你拉过来的时候随从剩余的攻击力），A爆对面的脸（将对面的血打到0点及以下）。


## 说明/提示

样例说明1：

敌方场上有3只随从，敌方有5点血量

我们把3攻随从和2攻随从拉过来花费0个缩小药水和5点耗费（一张疯狂药水一个暗影狂乱（1+4 = 5））伤害足够击杀对方。


样例说明2：

使用16个缩小药水（下面数据后面第一个括号指拉过来的时候伤害为多高 ，第二个括号表示拉过来的时候使用多少的缩小药水）

拿10（1）（3）、20（2）（6）、30（3）（9）、50（2）（16）攻的怪物总共造成8点伤害 刚好A爆！



Easy : 保证 0 < n <= 10  并且不存在用到暗影狂乱和缩小药水的情况    20%


Normal ：保证 0 < n <= 10  并且不存在用到缩小药水的情况           20%


Hard ：保证 0 < n <= 10                                                 30%


Extra：保证0 <= n <= 5000000(6个0)，最大攻击力小于30000                  30%


保证 0 < n <= 5000000     0 < ki <=30000    0<=m<=5000000 (6个0)


## 样例 #1

### 输入

```
3 5
1 2 3 
```

### 输出

```
0 5```

## 样例 #2

### 输入

```
8 8
10 20 30 40 50 60 70 80
```

### 输出

```
16 23```

## 样例 #3

### 输入

```
8 80
10 20 30 40 50 60 70 80
```

### 输出

```
Human Cannot Win Dog```

# AI分析结果



### 题解综合分析结论
各题解核心思路均为贪心策略，通过分层处理缩小药水次数，优先使用性价比高的随从（2攻→1攻→3攻），并结合桶排序处理大规模数据。核心差异在于溢出伤害的优化方式和排序实现方式。Yumis、AirCnt 的题解因高效桶排序和精细费用优化获得更高评分。

---

### 高星题解推荐

#### 1. 作者：Yumis（★★★★★）
**关键亮点**  
- 桶排序处理大规模数据，时间复杂度 O(30000)  
- 分层统计每层缩小后的攻击力分布，避免重复计算  
- 优先返还3攻随从优化费用，数学推导清晰  
**个人心得**  
> "桶排序在这个题里几乎是唯一解，五百万数据下 sort 根本扛不住" —— 强调桶排序的必要性

**核心代码**  
```cpp
for (int i = 1; i+2 <= 30001; i +=3) { // 分层处理缩小药水
    ans += to[i]; at1 += to[i];    // 统计1攻随从
    ans += to[i+1]*2; at2 += to[i+1]; // 统计2攻随从
    ans += to[i+2]*3; at3 += to[i+2]; // 统计3攻随从
    snum++;
    if(ans >= m) break;
}
// 溢出调整优先返还3攻
while(ans >= m+3 && at3) {at3--; ans -=3;}
```

---

#### 2. 作者：AirCnt（★★★★★）
**关键亮点**  
- 模3分组统计攻击力，避免重复计算缩小次数  
- 动态调整缩小药水使用与费用计算  
- 代码简洁，优先处理高费用随从  

**核心代码**  
```cpp
for(int i=1; i<=maxn && sum<m; i+=3) { // 按模3分组处理
    if(a[i]) sum += clac(i, a[i]); // 动态计算缩小次数
    // ... 类似处理i+1, i+2
}
// 溢出调整：优先返还3攻
while(sum-3>=m && used[3]) used[3]--, ans-=4;
```

---

#### 3. 作者：MTF_Lambda_04（★★★★）
**关键亮点**  
- 贪心+排序后动态调整溢出  
- 分阶段返还随从（先3攻再1攻）  
**不足**  
- 使用 sort 处理大规模数据可能超时  
**核心代码**  
```cpp
sort(a+1, a+n+1);
for(int i=1; i<=n; i++) {
    a[i] -= 3*need; // 动态调整缩小次数
    if(a[i] <=2) number++; // 优先使用1费随从
    else if(a[i]==3) number+=4; // 四费随从
}
// 溢出调整循环
while(m<0) {
    for(返还3攻);
    for(返还1攻);
}
```

---

### 最优关键思路总结
1. **桶排序优化**：处理大规模数据时，桶排序（O(max_k)）远优于常规排序（O(n logn)）。  
2. **分层贪心策略**：按缩小药水分层（每层3点攻击衰减），统计每层可用随从的攻击分布。  
3. **费用优先级**：优先使用2攻（1费）→1攻（1费）→3攻（4费），溢出时优先返还高费用随从。  

---

### 拓展与举一反三
1. **类似题目**  
   - [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：贪心+双指针  
   - [P1209 [USACO1.3]修理牛棚 Barn Repair](https://www.luogu.com.cn/problem/P1209)：贪心+区间处理  
   - [P5019 [NOIP2018 提高组] 铺设道路](https://www.luogu.com.cn/problem/P5019)：分层贪心  

2. **调试心得**  
   > "在样例1中发现直接按顺序贪心会导致费用过高，必须反向剔除溢出伤害" —— 强调反向调整的必要性  
   > "桶排序是五百万数据的救星，sort吸氧也过不去" —— 大数据量下算法选择的重要性

---
处理用时：75.96秒
# 题目信息

# [JSOI2007] 建筑抢修

## 题目描述

小刚在玩 JSOI 提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T 部落消灭了所有 Z 部落的入侵者。但是 T 部落的基地里已经有 $N$ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T 部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N < 150000$，$1 \le T_1 < T_2 < 2^{31}$。

## 样例 #1

### 输入

```
4
100 200
200 1300
1000 1250
2000 3200```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题本质是带截止时间的贪心调度问题，所有高效解法均采用**按截止时间排序+大根堆替换策略**。关键点在于排序后遍历时，用堆维护已选建筑的最长耗时，在超时时替换最大耗时的建筑以保证总时间最小化。时间复杂度为 $O(n\log n)$，适用于大规模数据。

---

### 高星题解推荐

#### 1. 作者：_Album_（⭐⭐⭐⭐⭐）
**核心思路**  
- 按 $t_2$ 升序排序，确保优先处理快报废的建筑  
- 用大根堆维护已选建筑的耗时  
- 当前建筑超时则替换堆顶最大耗时建筑  
**代码亮点**  
```cpp
sort(build + 1, build + 1 + n, cmp);
priority_queue<ll> Q; // 大根堆维护耗时
for (...) {
    sum += build[i].t1;
    Q.push(build[i].t1);
    if (sum > build[i].t2) {
        sum -= Q.top(); // 替换策略
        Q.pop();
    }
}
```

#### 2. 作者：灵乌路空（⭐⭐⭐⭐⭐）
**核心思想**  
- 排序后动态维护已选建筑集合  
- 当新建筑无法直接加入时，替换耗时更长的旧建筑  
**代码亮点**  
```cpp
std::sort(z+1, z+1+k, cmp); // 按t2排序
priority_queue<long int> q;
for (...) {
    if (可插入) { 直接插入堆 }
    else if (新建筑耗时 < 堆顶) {
        替换堆顶; // 保证总时间减少
    }
}
```

#### 3. 作者：Refun（⭐⭐⭐⭐⭐）
**关键洞见**  
- 正确性证明：替换策略保证总数不减少且总时间更优  
- 按 $t_2$ 排序防止"非紧急建筑被提前处理"  
**个人心得**  
> "如果不按T2排序的话可能是防止一些不需要很提前修改的建筑被提前修改"  
> "xjb贪就对了（滑稽）"（背后隐含正确性分析）

---

### 最优解法核心总结
1. **排序策略**：按 $t_2$ 升序排序，优先处理紧急建筑。  
2. **堆维护**：用大根堆动态维护已选建筑的最大耗时。  
3. **替换策略**：当总时间超限时，用当前建筑替换堆顶（若耗时更短），保证后续可容纳更多建筑。  

---

### 同类题目推荐
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心+小根堆  
2. [P1484 种树](https://www.luogu.com.cn/problem/P1484) - 带限制的贪心选择  
3. [P3620 [APIO/CTSC 2007] 数据备份](https://www.luogu.com.cn/problem/P3620) - 反悔贪心+堆  

---

### 调试经验摘录
- **wwldx的踩坑**：  
  初始按最迟开始时间排序导致错误，后引入间隙变量 `maxx` 修正替换逻辑。  
  > "maxx在每次数据处理更新一次就可"  
- **约瑟夫用脑玩的倒序思路**：  
  时间倒序处理需复杂替换逻辑，最终仍回归经典解法更优。

---
处理用时：73.43秒
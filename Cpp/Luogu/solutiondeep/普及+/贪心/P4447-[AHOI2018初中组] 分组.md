# 题目信息

# [AHOI2018初中组] 分组

## 题目描述

小可可的学校信息组总共有 $n$ 个队员，每个人都有一个实力值 $a_i$。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的 $n$ 个队员分成若干个小组去参加这场比赛。

但是每个队员都不会愿意与实力跟自己过于悬殊的队员组队，于是要求分成的每个小组的队员实力值连续，同时，一个队不需要两个实力相同的选手。举个例子：$[1, 2, 3, 4, 5]$ 是合法的分组方案，因为实力值连续；$[1, 2, 3, 5]$ 不是合法的分组方案，因为实力值不连续；$[0, 1, 1, 2]$ 同样不是合法的分组方案，因为出现了两个实力值为 $1$ 的选手。

如果有小组内人数太少，就会因为时间不够而无法获得高分，于是小可可想让你给出一个合法的分组方案，满足所有人都恰好分到一个小组，使得人数最少的组人数最多，输出人数最少的组人数的最大值。

注意：实力值可能是负数，分组的数量没有限制。

## 说明/提示

【样例解释】
分为 $2$ 组，一组的队员实力值是 $\{4, 5, 2, 3\}$，一组是 $\{-4, -3, -5\}$，其中最小的组人数为 $3$，可以发现没有比 $3$ 更优的分法了。

【数据范围】

对于 $100\%$ 的数据满足：$1\leq n\leq 100000$，$|a_i|\leq10^9$。

本题共 $10$ 个测试点，编号为 $1\sim10$，每个测试点额外保证如下：
| 测试点编号 | 数据限制 |
| :-----------: | :-----------: |
| $1\sim2$ | $n\leq 6, 1\leq a_i \leq 100$ |
| $3\sim4$ | $n\leq 1000, 1\leq a_i\leq 10^5$ 且 $a_i$ 互不相同 |
| $5\sim6$ | $n\leq 100000, a_i$ 互不相同 |
| $7\sim8$ | $n\leq 100000, 1\leq a_i \leq10^5$ |
| $9\sim 10$ | $n\leq 100000, -10^9 \leq a_i \leq 10^9$ |

## 样例 #1

### 输入

```
7
4 5 2 3 -4 -3 -5```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论
本题核心在于排序后的贪心策略，通过动态维护可接续的组信息，确保每次将当前元素插入最短合法组，从而最大化最小组人数。各题解主要围绕以下思路展开：
- **俄罗斯方块模拟**：将实力值映射为柱状图，按特定规则连线分组。
- **二分查找维护期望值**：通过维护每个组的下一期望值，利用二分查找快速定位可插入组。
- **优先队列优化**：用小根堆动态维护组长度，确保每次选择最短合法组。
- **队列区间处理**：利用排序后的连续性，通过单调队列维护合法区间。

最优思路为：排序后贪心维护组的末尾值，动态选择最短可行组接续。该思路可通过二分、优先队列或队列高效实现。

---

### 高星题解推荐

#### 1. CherryPockyOvO（⭐⭐⭐⭐⭐）
**亮点**：利用二分查找维护q数组（存储每组下一期望值），确保O(n log n)时间复杂度。通过维护单调性避免重复分组，代码简洁高效。
**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    int pos=lower_bound(q+1,q+top+1,f[i])-q; 
    while(q[pos+1]==f[i]&&pos<top) pos++; 
    if(pos>top||q[pos]!=f[i]) siz[++top]=1,q[top]=f[i]+1; 
    else siz[pos]++,q[pos]++; 
}
```
**实现思想**：排序后，每个元素通过二分查找定位到可接续组，优先选择最右侧合法组以保证组长度最小化。

#### 2. xiaoniu142857（⭐⭐⭐⭐⭐）
**亮点**：结合排序与队列处理，用O(n)时间维护合法区间。通过懒标记和区间更新避免重复操作，时空效率极优。
**核心代码**：
```cpp
for(int i=0;i<n;++i) {
    while(q.size()&&q.top().big<a[i]-1) { // 清理无法接续的组
        ans=min(ans,q.top().sum);
        q.pop();
    }
    if(q.empty()||q.top().big==a[i]) q.push(node{a[i],1});
    else { // 接续到最短合法组
        node x=q.top(); q.pop();
        x.big=a[i]; x.sum++;
        q.push(x);
    }
}
```
**实现思想**：优先队列维护组末尾值和长度，每次清理过期组后，直接将元素插入最短合法组。

#### 3. K0stlin（⭐⭐⭐⭐）
**亮点**：使用map套优先队列维护不同末尾值的组集合，确保每次选择最小长度组接续，逻辑清晰。
**核心代码**：
```cpp
for(int i=1;i<=n;++i){
    if(p[a[i]]==0) p[a[i]]=++k;
    if(p[a[i]-1]==0||q[p[a[i]-1]].size()==0) 
        q[p[a[i]]].push(1);
    else {
        s=q[p[a[i]-1]].top()+1;
        q[p[a[i]-1]].pop();
        q[p[a[i]]].push(s);
    }
}
```
**实现思想**：map记录每个末尾值对应的优先队列，优先接续到前一值的组中长度最小的。

---

### 最优技巧总结
1. **排序预处理**：所有高效解法均先排序，确保连续性处理。
2. **动态维护接续点**：通过数据结构（队列、优先队列、map）快速定位可插入组。
3. **贪心选择最短组**：确保每次插入后最小长度最大化，避免"短板效应"。

---

### 拓展与同类题推荐
**类似题目**：
1. **P1090 [NOIP2004 提高组] 合并果子**（贪心+优先队列）
2. **P1842 [USACO05NOV] 奶牛玩杂技**（排序+贪心决策）
3. **P2949 [USACO09OPEN] Work Scheduling G**（贪心+反悔机制）

**举一反三**：处理分组或接续问题时，优先考虑排序后动态维护合法区间，常用数据结构包括优先队列、二分查找或单调队列。

---
处理用时：78.22秒
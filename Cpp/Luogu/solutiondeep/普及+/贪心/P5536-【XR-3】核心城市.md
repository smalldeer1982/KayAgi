# 题目信息

# 【XR-3】核心城市

## 题目描述

X 国有 $n$ 座城市，$n - 1$ 条长度为 $1$ 的道路，每条道路连接两座城市，且任意两座城市都能通过若干条道路相互到达，显然，城市和道路形成了一棵树。

X 国国王决定将 $k$ 座城市钦定为 X 国的核心城市，这 $k$ 座城市需满足以下两个条件：

1. 这 $k$ 座城市可以通过道路，在不经过其他城市的情况下两两相互到达。
2. 定义某个非核心城市与这 $k$ 座核心城市的距离为，这座城市与 $k$ 座核心城市的距离的最小值。那么所有非核心城市中，与核心城市的距离最大的城市，其与核心城市的距离最小。你需要求出这个最小值。

## 说明/提示

【样例说明】

钦定 $1,2,5$ 这 $3$ 座城市为核心城市，这样 $3,4,6$ 另外 $3$ 座非核心城市与核心城市的距离均为 $1$，因此答案为 $1$。

## 样例 #1

### 输入

```
6 3
1 2
2 3
2 4
1 5
5 6
```

### 输出

```
1
```

# AI分析结果



### 综合分析与结论
本题核心在于选择树中k个连通节点，使得非核心节点的最大最小距离最小化。主流解法分为两类：
1. **基于树的直径**：通过两次DFS找直径中点作为核心，按子树最大深度差排序选择前k个节点。
2. **拓扑排序**：逆向思维，逐层剥离叶子节点直到剩余k个核心，剥离层数即为答案。

其中拓扑排序法更简洁高效，时间复杂度O(n)，无需复杂预处理，成为最优解法。

---

### 高星题解推荐

#### 1. wheneveright（5星）
**关键亮点**：
- 逆向思维从非核心城市切入，逐层剥离叶子节点。
- 利用类似拓扑排序的BFS实现，代码简洁高效。
- 正确性证明直观，答案即为剥离层数。

**核心代码**：
```cpp
queue<int> q;
for (int i = 1; i <= n; i++) 
    if (du[i] == 1) q.push(i), vis[i] = true;
while (cnt <= n - k) {
    ans++;
    queue<int> tmp;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        cnt++;
        for (int v : edge[u]) {
            if (--du[v] == 1) 
                tmp.push(v), vis[v] = true;
        }
    }
    q = tmp;
}
```
**实现思路**：每次处理当前叶子节点并更新相邻节点度数，剩余节点自然形成核心区域。

#### 2. 神之蒟蒻xyk（5星）
**关键亮点**：
- 与拓扑排序思路一致，代码极简。
- 直接统计剥离次数作为答案，逻辑清晰。

**核心代码**：
```cpp
queue<int> q1, q2;
for (int i = 1; i <= n; i++) 
    if (du[i] == 1) q1.push(i);
while (sum > k) {
    ans++;
    while (!q1.empty()) {
        int x = q1.front(); q1.pop();
        sum--;
        for (遍历相邻节点 y) 
            if (--du[y] == 1) q2.push(y);
    }
    swap(q1, q2);
}
```

#### 3. Hexarhy（5星）
**关键亮点**：
- 使用C++11特性简化代码。
- 双队列交替处理层级，逻辑与代码高度统一。

**核心代码**：
```cpp
queue<int> q, tmp;
for (叶子节点初始化 q);
while (cnt <= n - k) {
    ans++;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        cnt++;
        for (v : 相邻节点) 
            if (--deg[v] == 1) tmp.push(v);
    }
    q = tmp; // 交替处理下一层
}
```

---

### 最优思路总结
**拓扑排序法**的核心步骤：
1. 初始化：将所有度为1的叶子节点加入队列。
2. 逐层剥离：每次处理当前层所有叶子节点，更新相邻节点度数。
3. 统计层数：当剩余节点数≤k时停止，剥离次数即为答案。

**关键证明**：最远非核心节点必为最后被剥离的叶子，其距离等于剥离次数。

---

### 相似题目推荐
1. [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)  
   - 考察树的直径与最小偏心距。
2. [P3629 [APIO2010]巡逻](https://www.luogu.com.cn/problem/P3629)  
   - 结合直径性质优化路径覆盖。
3. [P2491 [SDOI2011]消防](https://www.luogu.com.cn/problem/P2491)  
   - 类似树网的核，强化直径性质应用。

---

### 个人心得摘录
- **SCAU_Lnn**："遇到复杂题先简化，如k=1时选中点，逐步扩展思路。"  
- **Cylete**："画图验证是关键，直径中点性质需结合反证法理解。"  
- **Hexarhy**："边权为1时拓扑法优势明显，避免复杂预处理。"  

调试经验：处理边界时需注意剩余节点数恰好等于k时的层数统计，避免off-by-one错误。

---
处理用时：84.21秒
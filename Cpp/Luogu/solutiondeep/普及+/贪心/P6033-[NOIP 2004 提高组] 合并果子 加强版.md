# 题目信息

# [NOIP 2004 提高组] 合并果子 加强版

## 题目背景

本题除【数据范围与约定】外与 [P1090](https://www.luogu.com.cn/problem/P1090) **完  全  一  致**。

## 题目描述

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $(n - 1)$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 $3$ 堆果子，数目依次为 $1,~2,~9$。可以先将 $1$、$2$ 堆合并，新堆数目为 $3$，耗费体力为 $3$。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$，耗费体力为 $12$。所以多多总共耗费体力为 $3+12=15$。可以证明 $15$ 为最小的体力耗费值。


## 说明/提示

**【数据规模与约定】**

**本题采用多测试点捆绑测试，共有四个子任务**。

- Subtask 1（10 points）：$1 \leq n \leq 8$。
- Subtask 2（20 points）：$1 \leq n \leq 10^3$。
- Subtask 3（30 points）：$1 \leq n \leq 10^5$。
- Subtask 4（40 points）：$1 \leq n \leq 10^7$。

对于全部的测试点，保证 $1 \leq a_i \leq 10^5$。

**【提示】**

- 请注意常数因子对程序效率造成的影响。
- 请使用类型合适的变量来存储本题的结果。
- 本题输入规模较大，请注意数据读入对程序效率造成的影响。



## 样例 #1

### 输入

```
3 
1 2 9 
```

### 输出

```
15
```

# AI分析结果



### 综合分析与结论  
本题核心在于通过双队列优化贪心合并过程，结合桶排序实现O(n)时间复杂度。各题解均围绕该核心展开，差异主要体现在排序实现（桶排/基排）、队列操作细节及代码优化程度。最优解法为：桶排序预处理 + 双队列合并策略。

---

### 精选题解与评分  
#### 1. Reanap（⭐⭐⭐⭐⭐）  
**关键亮点**：  
- 桶排序处理初始数据，O(n)预处理  
- 双队列维护有序合并序列，严格保证单调性  
- 代码简洁高效，包含快速读入优化  
**代码核心**：
```cpp
// 桶排序初始化q1
for (int i = 1; i <= 100000; ++i) 
    while(to[i]--) q1.push(i);

// 合并过程
int x = min(q1.front(), q2.front()); 
q2.push(x + y);
```

#### 2. HPXXZYY（⭐⭐⭐⭐）  
**关键亮点**：  
- 详细数学证明队列单调性  
- 独立设计get_first()函数提升可读性  
- 完整处理边界条件（空队列判断）  
**个人心得**：  
> "新合并的果子一定比之前的大，这保证了队列的单调性——这是双队列策略成立的关键"

#### 3. WsW_（⭐⭐⭐⭐）  
**关键亮点**：  
- 手写快速读入模板优化IO  
- 使用ull类型防止溢出  
- 队列操作逻辑高度对称  

---

### 关键代码实现  
**双队列合并核心逻辑**（Reanap版）：
```cpp
for (int i = 1; i < n; ++i) {
    int x, y;
    // 从q1/q2取最小值
    if((q1.front() < q2.front() && !q1.empty()) || q2.empty()) 
        x = q1.front(), q1.pop();
    else 
        x = q2.front(), q2.pop();
    
    // 重复取第二个最小值
    if((q1.front() < q2.front() && !q1.empty()) || q2.empty()) 
        y = q1.front(), q1.pop();
    else 
        y = q2.front(), q2.pop();
    
    q2.push(x + y);
    ans += x + y;
}
```

---

### 拓展与举一反三  
1. **同类问题套路**：  
   - 哈夫曼编码问题（如洛谷P2168）  
   - 需要动态取极值的贪心问题（如P4053 建筑抢修）  
   - 大值域下的线性排序（基排应用场景）  

2. **推荐题目**：  
   - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（原题弱化版）  
   - [P2168 荷马史诗](https://www.luogu.com.cn/problem/P2168)（k叉哈夫曼树）  
   - [P6035 纸牌游戏](https://www.luogu.com.cn/problem/P6035)（类似贪心策略）  

3. **优化技巧**：  
   - 桶排序适用于值域有限场景（a_i ≤ 1e5）  
   - 双队列策略可推广到需要维护动态有序序列的贪心问题  
   - 快读模板对1e7级数据量至关重要  

---

### 关键调试经验  
来自Alarm5854的基排实现：  
> "当a_i超过1e5时桶排失效，此时基排成为更好的选择。取基数256通过位运算优化模运算，比传统基排快3倍"  

来自china·xyc的溢出提醒：  
> "合并次数达1e7时，累加器必须用long long。测试用例23322278400000验证了这一点"

---
处理用时：54.00秒
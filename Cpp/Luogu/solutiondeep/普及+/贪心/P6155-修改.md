# 题目信息

# 修改

## 题目描述

给定一个长度为 $n$ 的整数序列 $a_i$，再给定一个长度为 $n$ 的整数序列 $b_i$。

你可以进行一些修改，每次你可以将一个 $a_i$ 增加 $1$，花费为 $b_i$，你需要使所有的 $a_i$ 不相等，且同时满足花费最少。

但 zbw 认为太过简单，于是他规定，你可以在修改前进行**无限**次如下操作：交换 $b_i,b_j(1 \leq i,j \leq n)$。

求最小的花费。

**由于答案可能很大，请输出答案对  $2^{64}$ 取模后的值。**




## 说明/提示

样例 $1$：不改变 $b$，让 $a_1$ 增加 $2$，$a_2$ 增加 $1$，总花费为 $4$。

样例 $2$：交换 $b_1,b_3$，让 $a_1$ 增加 $2$，总花费为 $2$。

样例 $3$：不做任何改变。

**本题输入量较大，请使用读入优化。**



| 测试点 |$n$  |$a_i$  |特殊性质|
| :----------: | :----------: | :----------: |  :----------: |
| $1,2$ |$\leq10$  |$\leq10^9$  |无 |
| $3\sim6$ |$\leq10^3$  |$\leq10^9$  |无| 
| $7\sim10$ |$\leq10^6$  |$\leq10^6$  | 无|
| $11\sim14$ |$\leq10^6$  |$\leq10^9$  |所有 $b_i$ 相等 |
| $15\sim20$ |$\leq10^6$  |$\leq10^9$  |无|

对于所有数据 $1 \leq n \leq 10^6$，$1\leq a_i,b_i\leq10^9$。

## 样例 #1

### 输入

```
3
3 3 3
1 2 3```

### 输出

```
4```

## 样例 #2

### 输入

```
3
3 3 4
3 2 1```

### 输出

```
2```

## 样例 #3

### 输入

```
3
3 4 5
2 1 3```

### 输出

```
0```

# AI分析结果



### 综合分析与结论
该问题的核心是贪心策略与冲突处理的结合。所有题解均围绕以下要点展开：
1. **排序预处理**：将a数组从小到大排序，b数组从小到大排序（通过交换b可自由分配代价权重）
2. **冲突处理**：通过栈/并查集/跳跃优化等方法处理重复元素，计算每个元素的最小必要修改量
3. **权重分配**：将最大的修改量分配给最小的b值以最小化总代价

### 高星题解推荐
---

#### 1. gyh20（★★★★★）
**核心亮点**：
- 栈结构的巧妙应用，清晰模拟元素填充过程
- 时间复杂度严格O(n log n)，适合1e6数据量
- 代码简洁，可读性强

**关键代码解析**：
```cpp
stack<node> q;
for(int i=1; i<=n; ){
    if(q.empty()) x = a[i]; // 跳跃空区间
    while(a[i] == x) q.push({a[i],i++}); // 相同元素入栈
    auto tmp = q.top(); q.pop();
    p[tmp.id].ans = x++ - tmp.x; // 记录增量
}
sort(p+1, p+n+1, cmp); // 按增量降序排列
for(int i=1; i<=n; i++) ans += p[i].ans * b[i]; // 最小权重分配
```
通过栈动态维护待处理元素，跳跃优化减少无效遍历。

---

#### 2. Leap_Frog（★★★★☆）
**核心亮点**：
- 与gyh20思路相似但代码更简洁
- 显式处理空区间跳跃，减少栈操作
- 自然溢出处理大数取模

**优化技巧**：
```cpp
while(pla <= a[n] || !s.empty()) {
    if(s.empty()) pla = a[top]; // 跳跃优化
    while(a[top] == pla) s.push(top++);
    if(!s.empty()){
        int tmp = s.top(); s.pop();
        if(pla != a[tmp]) r[++cnt] = pla - a[tmp]; // 仅记录非零修改
        pla++;
    }
}
```
通过显式跳跃空区间减少约50%的栈操作。

---

#### 3. Daniel_yao（★★★★）
**创新点**：
- 逆向思维从大到小处理元素
- 动态维护"数轴"空位概念
- 代码中融合栈与位置指针

**核心片段**：
```cpp
for(int i=2; i<=n+1; ) { // a[n+1]设为无穷大作为哨兵
    if(a[i] == a[i-1]) stk[++top] = i;
    else {
        int l = a[i-1];
        while(top && l < a[i]-1) { // 填充中间空隙
            l++;
            res[++tot] = l - a[stk[top--]]; 
        }
    }
}
```
通过哨兵技巧简化边界条件处理。

---

### 最优思路总结
1. **双排序策略**：a升序排列确定修改顺序，b升序排列实现最小权重分配
2. **栈式冲突处理**：动态维护待处理元素，确保每次修改量最小
3. **跳跃优化**：当无冲突时直接跳至下一个元素，将时间复杂度稳定在O(n)
4. **权值匹配**：修改量降序排列后与b升序逐项相乘，数学上保证Σ(xy)最小

### 拓展与技巧
1. **同类问题**：元素分配问题（如会议室安排、区间覆盖）可借鉴此贪心策略
2. **调试经验**：
   - 大数组排序前需确认比较函数正确性（如边界相等情况）
   - 自然溢出取模时注意中间结果是否可能超出64位范围
3. **卡常技巧**：
   - 使用fread快读处理1e6级输入
   - 避免STL容器，改用数组模拟栈
   - 用哨兵值简化边界判断

### 推荐练习题
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心+优先队列
2. [P4053 建筑抢修](https://www.luogu.com.cn/problem/P4053) - 贪心+堆维护
3. [P1842 奶牛玩杂技](https://www.luogu.com.cn/problem/P1842) - 权重排序策略

---
处理用时：69.85秒
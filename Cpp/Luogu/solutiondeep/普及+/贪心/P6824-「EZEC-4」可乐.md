# 题目信息

# 「EZEC-4」可乐

## 题目背景

很久以前，有一个 pigstd，非常迷恋美味的可乐。为了得到美味的可乐，他几乎用尽了所有的钱，他甚至对自己的 npy 也漠不关心~~其实是因为他没有npy~~，更不爱好看戏。除非买了新可乐，才会坐上马车出门炫耀一番。每一天，每个钟头他都要喝上一瓶新可乐。

pigstd 最近又买了许多箱新可乐——当然，这些可乐只有聪明的人才能喝到。

## 题目描述

pigstd 现在有 $n$ 箱可乐，第 $i$ 箱可乐上标着一个正整数 $a_{i}$。

若 pigstd 的聪明值为一个非负整数 $x$，对于第 $i$ 箱可乐，如果 $(a_{i} \oplus x )\le k$，那么 pigstd 就能喝到这箱可乐。

现在 pigstd 告诉了你 $k$ 与序列 $a$，你可以决定 pigstd 的聪明值 $x$，使得他能喝到的可乐的箱数最大。求出这个最大值。

## 说明/提示

### 提示

**pigstd 的聪明值 $x$ 可以为 $0$。**

### 样例解释

样例 1 解释：容易构造当 $x = 0$ 时，可以喝到所有可乐。

样例 2 解释：容易构造 $x = 913$，可以喝到所有可乐。

**样例解释未必是唯一的方法。**

### 数据范围

**本题采用捆绑测试。**

- Subtask 1（29 points）：$1 \le n,k,a_{i} \le 1000$。

- Subtask 2（1 points）：$a_{i} \le k$。

- Subtask 3（70 points）：无特殊限制。

对于所有数据，保证 $1 \le n,k,a_{i} \le 10^6$。

$\oplus$ 代表异或，如果您不知道什么是异或，请单击[这里](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fr=aladdin)。

## 样例 #1

### 输入

```
3 5
2
3
4```

### 输出

```
3```

## 样例 #2

### 输入

```
4 625
879
480
671
853
```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
各题解核心思路均为按位处理异或特性，主要分为两类：差分统计区间覆盖法（O(n logk)）与 Trie 树优化法（O(n logV)）。前者通过二进制位分解构造合法区间，后者利用前缀树结构优化查询。动态规划解法在 Trie 结构上实现高效状态转移，也颇具启发性。

---

### 高星题解推荐

#### 1. 作者：pigstd（★★★★★）
**关键亮点**：
- 差分数组统计合法区间，时空复杂度优秀
- 按位分解思路清晰，代码简洁易实现
- 通过二进制位分类讨论，构造区间差分

**核心代码**：
```cpp
void f(int b) {
    // 按位分解 a[i] 与 k 的二进制
    while(b) s1[++len1] = b%2, b/=2;
    while(kk) s2[++len2] = kk%2, kk/=2;
    
    for(int i=1; i<=len; i++) {
        if(s2[i] == 0) { // 必须严格匹配当前位
            sum = sum*2 + s1[i];
        } else {          // 允许产生分支
            int k1 = (sum*2+s1[i]) << (len-i);
            int k2 = (sum*2+s1[i]+1) << (len-i);
            c[k1]++; c[k2]--; // 差分记录区间
            sum = sum*2 + (s1[i]^1); // 继续匹配后续位
        }
    }
    c[sum]++; c[sum+1]--; // 最终完全匹配的情况
}
```
**实现思想**：对每个 a[i] 构造所有可能的合法 x 区间，通过差分数组统计重叠区间的最大值。

---

#### 2. 作者：Spasmodic（★★★★☆）
**关键亮点**：
- Trie 树预处理加速查询
- 利用子树大小快速统计合法数量
- 位运算与树遍历结合，复杂度稳定

**调试心得**：
> "注意在 query 末尾要特判完全匹配的情况，否则会被特定数据卡掉" —— 强调边界条件的处理重要性

**核心代码**：
```cpp
int query(int x) {
    int ret = 0, p = 0;
    for(int i=21; i>=0; i--) {
        int c = (x>>i)&1;
        int t = (k>>i)&1;
        if(t == 1) ret += sz[trie[p][1-(c^t)]]; // 累加子树大小
        if(!trie[p][c^t]) break;
        p = trie[p][c^t];
    }
    if(p) ret += sz[p]; // 完全匹配的叶子节点
    return ret;
}
```
**实现思想**：建立二进制 Trie 树，对每个 x 的查询路径统计所有可能满足条件的子树大小。

---

#### 3. 作者：pocafup（★★★★★）
**关键亮点**：
- 极简差分实现，代码仅需 30 行
- 按位分类讨论思路与 pigstd 类似，但实现更紧凑
- 直接操作二进制位，无需显式存储分解结果

**核心代码**：
```cpp
void solve(int num) {
    int re = 0;
    FOR(i,20,0) { // 从高位到低位枚举
        if((k>>i & 1) && (num>>i & 1)) { 
            // 构造可自由选择低位的区间
            dp[re + (1<<i)]++;
            dp[re + (1<<(i+1))]--;
        } else if((k>>i) & 1) {
            dp[re]++;         // 当前位确定后自由选择
            dp[re + (1<<i)]--;
            re += (1<<i);     // 继续匹配后续位
        } else if((num>>i) & 1) {
            re += (1<<i);     // 必须严格匹配当前位
        }
    }
}
```
**实现思想**：直接在循环中处理二进制位，通过位操作构造差分区间，代码高度优化。

---

### 最优关键思路
**位分解+区间统计**：从高位到低位逐位处理，当 k 的当前位为 1 时产生分支（x 可取两种值），为 0 时只能严格匹配。通过差分数组记录所有可能区间，最终前缀和求最大值。

**思维技巧**：将异或比较转化为二进制位上的区间覆盖问题，利用差分数组将 O(2^20) 的枚举问题优化为 O(n logk) 的统计问题。

---

### 拓展训练推荐
1. **P4735 最大异或对** - 经典 Trie 树应用
2. **P2114 [NOI2014] 起床困难综合症** - 位运算贪心策略
3. **P4592 [TJOI2018] 异或** - 树链剖分与可持久化 Trie 结合

---

### 个人心得摘录
> "在 query 的末尾要特判完全匹配的情况，否则会被叉掉" —— Spasmodic  
**总结**：处理边界条件是位运算题的关键，需特别注意二进制位完全匹配的特殊情况。

> "发现操作修改的是一段区间，因此差分即可" —— 多题解  
**启示**：将复杂条件转化为区间操作是优化复杂度的常见手段，遇到统计类问题应优先考虑差分技巧。

---
处理用时：80.03秒
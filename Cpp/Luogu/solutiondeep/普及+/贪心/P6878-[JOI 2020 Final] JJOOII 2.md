# 题目信息

# [JOI 2020 Final] JJOOII 2

## 题目描述

定义有连续 $K$ 个 $\tt J$ 和连续 $K$ 个 $\tt O$ 和连续 $K$ 个 $\tt I$ 组成的字符串为 $K$ 阶 JOI 串。

比如，$\tt JJOOII$ 为 $2$ 阶 JOI 串，**但是，注意要有顺序**，比如 $\tt OOJJII$ 就不是 $2$ 阶 JOI 串。

现在，给定一个长度为 $N$ 的字符串 $S$，可以对他进行 $3$ 种操作：

- 操作 $1$：删除 $S$ 开头的字符
- 操作 $2$：删除 $S$ 结尾的字符
- 操作 $3$：删除 $S$ 除了开头和结尾之外的一个字符

我们要通过这些操作让 $S$ 变为 $K$ 阶 JOI 串。

但是，我们想让操作 $3$ 尽量的少。

所以我们想知道，变为 $K$ 阶 JOI 串操作 $3$ 最少需要进行多少次？

如果不能变为 $K$ 阶 JOI 串，那么输出 $-1$。

## 说明/提示

#### 样例 1 解释

1. 进行一次操作 $1$，变为 $\tt JIJOIOIIJ$。
2. 进行一次操作 $2$，变为 $\tt JIJOIOII$。
3. 进行一次操作 $3$，删掉字符 $2$，变为 $\tt JJOIOII$。
4. 进行一次操作 $3$，删掉字符 $4$，变为 $\tt JJOOII$。

#### 样例 2 解释

$\tt JJJOOOIII$ 已经是 $3$ 阶 JOI 串了，所以不需要进行操作。

#### 样例 3 解释

$\tt IIIOOOJJJ$ 无法变为 $1$ 阶 JOI 串，无解。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（1 pts）：$N \le 21$。
- Subtask 2（12 pts）：$N \le 3000$。
- Subtask 3（87 pts）：无特殊限制。

对于 $100\%$ 的数据：

- $3 \le N \le 2 \times 10^5$。
- $1 \le K \le \dfrac{N}{3}$。
- $S$ 只包含 $\tt J$，$\tt O$，$\tt I$ 且长度为 $N$。

#### 说明

翻译自 [第19回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [B JJOOII 2](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t2.pdf)。

## 样例 #1

### 输入

```
10 2
OJIJOIOIIJ```

### 输出

```
2```

## 样例 #2

### 输入

```
9 3
JJJOOOIII
```

### 输出

```
0```

## 样例 #3

### 输入

```
9 1
IIIOOOJJJ
```

### 输出

```
-1```

# AI分析结果



### 综合分析与结论
题目核心是寻找最短子串，使其能通过删除操作转换为 K 阶 JOI 串。最优解法的关键点在于预处理字符位置，利用双指针或二分快速定位目标字符，计算最小操作次数。以下题解通过不同方式实现这一思路，其中部分解法在时间复杂度和代码简洁性上表现突出。

---

### 高分题解推荐

#### 1. 作者：NewJeanss (⭐⭐⭐⭐⭐)
**关键亮点**  
- **O(n) 线性复杂度**：通过预处理字符位置数组，维护单调递增指针快速定位后续字符。
- **代码简洁高效**：利用指针跳转避免重复遍历，显著降低时间复杂度。
- **核心思路**：遍历每个 J 的起点，快速找到对应 K 个 O 和 I 的区间，计算最小长度。

**核心代码**  
```cpp
for(int i=1;i<=cj;i++){
    if(i+k-1>cj) break;
    end=cntj[i+k-1];
    while(cnto[lo]<=end && lo<=co) lo++;
    if(lo+k-1>co) break;
    end=cnto[lo+k-1];
    while(cnti[li]<=end && li<=ci) li++;
    if(li+k-1>ci) break;
    ans=min(ans,cnti[li+k-1]-cntj[i]+1-3*k);
}
```

---

#### 2. 作者：Daniel_7216 (⭐⭐⭐⭐)
**关键亮点**  
- **前缀和与二分结合**：通过前缀和数组快速统计区间字符数，二分查找目标位置。
- **对称式处理**：代码结构对称，逻辑清晰，易于扩展。

**核心代码**  
```cpp
int a = lower_bound(sumn + i, sumn + 1 + n, k + sumn[i-1]) - sumn;
int b = lower_bound(sumo + a, sumo + 1 + n, k + sumo[a-1]) - sumo;
int c = lower_bound(sumi + b, sumi + 1 + n, k + sumi[b-1]) - sumi;
ans = min(ans, c - i + 1 - 3 * k);
```

---

#### 3. 作者：makerlife (⭐⭐⭐⭐)
**关键亮点**  
- **预处理字符位置数组**：直接记录每个字符的位置，避免重复计算。
- **贪心思想**：从每个 J 的起点出发，寻找最短匹配区间，保证最优性。

**核心代码**  
```cpp
for(int i=1;i<=totj;i++) {
    if(i+k-1>totj) break;
    int ed=cj[i+k-1];
    int pos=lower_bound(co+1, co+toto+1, ed) - co;
    if(pos+k-1>toto) break;
    ed=co[pos+k-1];
    pos=lower_bound(ci+1, ci+toti+1, ed) - ci;
    if(pos+k-1>toti) break;
    ans=min(ans,ci[pos+k-1]-cj[i]+1-3*k);
}
```

---

### 关键思路总结
1. **预处理字符位置**：将 J、O、I 的位置分别存入数组，便于快速访问。
2. **双指针跳转**：遍历 J 的起点时，O 和 I 的指针只需单调递增，避免重复扫描。
3. **区间长度计算**：最小操作次数 = 目标区间长度 - 3K，直接数学推导简化问题。

---

### 拓展与相似题目
1. **P1638 逛画展**（双指针求最小区间覆盖所有类型）
2. **P1147 连续自然数段**（前缀和与区间性质结合）
3. **P2925 [USACO08DEC] Hay For Sale**（贪心与区间覆盖优化）

---

### 调试心得摘录
- **NewJeanss**：提到“lo 和 li 不用每次从 1 开始，位置单调递增”，强调指针跳转的优化关键。
- **Daniel_7216**：在二分边界处理时需注意越界判断，避免无效区间影响结果。
- **makerlife**：强调预处理字符位置数组的重要性，直接减少后续计算复杂度。

---
处理用时：59.92秒
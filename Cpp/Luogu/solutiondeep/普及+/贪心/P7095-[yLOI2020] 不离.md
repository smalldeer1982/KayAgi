# 题目信息

# [yLOI2020] 不离

## 题目背景

> 乱玄黄时序，探风林实虚。  
> 我要你共我奇谈怪趣。  
> 任日月斑斓，待春秋兴残。  
> 我要我们有聚无散。  

——银临《不离》

## 题目描述

这道题目来自 zxy 哔哔，咕咕让哔哔选一首歌作为题目名，但是哔哔说没有想好，于是咕咕就帮他选了这首歌。

哔哔在玩一款叫做《暗黑破坏神》的游戏，某天哔哔灵光乍现，以游戏为背景出了一道神仙题并告诉了咕咕。咕咕并不会做，于是对题目进行了一定的简化。因此，经过简化后，这道题已经和《暗黑破坏神》没什么关系了。

游戏中人物有两个属性，我们分别称之为「力量」和「精神」，同时哔哔有 $n$ 件装备，穿戴第 $i$ 件装备需要人物在穿戴前的力量值不低于 $a_i$，精神值不低于 $b_i$。在穿戴第 $i$ 件装备后，人物的力量值会增加 $c_i$，精神值会增加 $d_i$。

哔哔可以自由选择穿装备的顺序，只要满足力量和精神不低于对应值，就可以穿戴该装备。

现在，咕咕想知道，如果想让哔哔穿戴上所有的装备，那么人物的初始力量值（即没有穿任何装备之前的力量值）最小应该是多少？在初始力量值最小的前提下，初始精神值（即没有穿任何装备之前的精神值）最小应该是多少？

显然，初始力量和初始精神都应该是非负整数。

## 说明/提示

### 样例 1 解释

当初始力量值为 $1$，精神值为 $2$ 时，可以穿戴第 $2$ 件装备。在穿戴该装备后，增加 $3$ 点力量和 $4$ 点精神，人物的属性变为 $4$ 点力量和 $6$ 点精神，此时可以穿戴第 $1$ 件装备。

### 数据规模与约定

**本题采用多测试点捆绑测试**。

- 子任务 $1$（$5$ 分）：保证 $n=0$。
- 子任务 $2$（$5$ 分）：保证 $n=1$。
- 子任务 $3$（$20$ 分）：保证 $a_i,b_i \le 100$，$n \le 6$。
- 子任务 $4$（$10$ 分）：保证 $a_i,b_i \le 10^5$，$n \le 6$。
- 子任务 $5$（$10$ 分）：保证 $a_i,b_i \le 10$。
- 子任务 $6$（$10$ 分）：保证 $a_i,b_i \le 100$。
- 子任务 $7$（$10$ 分）：保证 $b_i=0$，$n \le 6$。
- 子任务 $8$（$10$ 分）：保证 $b_i=0$。
- 子任务 $9$（$10$ 分）：保证 $n \le 6$。
- 子任务 $10$（$10$ 分）：无特殊约定。

对于全部的测试点，保证 $0 \le n \le 10^5$，$0 \le a_i,b_i,c_i,d_i \le 10^9$。

### 提示
有 $4$ 个样例文件，请见附加文件中的 forever.zip。

对于第三个样例，满足 $b_i = 0$。

## 样例 #1

### 输入

```
0
2
1 5 0 2
1 2 3 4```

### 输出

```
1 2```

# AI分析结果



### 综合分析与结论
本题核心是通过贪心策略与优先队列优化处理双属性约束下的最小化问题。最优思路为分两阶段处理：先按力量需求排序贪心求最小初始力量，再用优先队列动态维护可选装备求最小初始精神。时间复杂度为 O(n log n)，可高效处理 1e5 规模数据。

### 高星题解推荐

#### 1. 火车司机（5星）
**关键亮点**：  
- 两阶段贪心+优先队列，时间复杂度 O(n log n)
- 代码简洁高效，核心逻辑仅30行  
- 按力量排序后直接模拟，精神处理用堆动态维护最小需求  

**核心代码思想**：
```cpp
// 处理力量部分
sort(p + 1, p + 1 + n, cmp);
for (ri i = 1, a = 0; i <= n; ++i) {
    if (a < p[i].a) ans1 += p[i].a - a, a = p[i].a;
    a += p[i].c;
}
// 处理精神部分
priority_queue<buff> q;
for (ri i = 1, b = 0; i <= n; ++i) {
    while (p[i].a > ans1) { // 力量不足时从堆中取装备
        if (b < q.top().b) ans2 += q.top().b - b, b = q.top().b;
        b += q.top().d, ans1 += q.top().c, q.pop();
    }
    q.push(p[i]);
}
```

#### 2. LAB_Maple（5星）
**关键亮点**：  
- 代码实现极简，仅50行  
- 使用排序+堆的清晰两段式结构  
- 变量命名与逻辑对应直观  

**调试心得**：  
- 通过构造特殊数据（如a递增b递减）验证贪心正确性  
- 发现错误思路（直接双排序）后引入堆优化  

**核心代码片段**：
```cpp
// 处理精神部分
priority_queue<int,vector<int>,sqakioi> qq; 
for(;j<=n&&x[j].a<=add;++j) qq.push(j);
while(!qq.empty()) {
    int t=qq.top();
    if(spi<x[t].b) ad+=x[t].b-spi,spi=x[t].b;
    spi+=x[t].d,add+=x[t].c;
    for(;j<=n&&x[j].a<=add;++j) qq.push(j);
}
```

#### 3. doctorZ_（4星）
**关键亮点**：  
- 结构体排序与堆的结合使用  
- 完整处理了装备增益后的动态更新  
- 变量命名清晰（resa/resb表示当前属性值）

**核心思路**：  
- 维护堆存储当前可穿戴装备，每次取最小精神需求  
- 动态更新力量值并扩展可选装备集合  

---

### 最优关键思路总结
1. **双阶段贪心**：先完全独立处理力量最小化，再基于此结果处理精神。  
2. **排序策略**：力量阶段按 a_i 升序排序，确保每次处理当前最小需求。  
3. **堆优化精神阶段**：用优先队列（小根堆）维护当前可选的装备，按 b_i 排序，确保每次选择精神需求最小的装备。  
4. **动态更新**：每次穿戴装备后，将新增的符合力量条件的装备加入堆中。

---

### 相似题目推荐
1. **P1080 国王游戏** - 双关键字排序与贪心  
2. **P5020 货币系统** - 动态维护可用元素集合  
3. **P1090 合并果子** - 优先队列优化贪心策略  

---

### 代码实现技巧
**核心结构**：  
1. 预处理排序：
```cpp
sort(p+1, p+n+1, [](auto& x, auto& y){ 
    return x.a < y.a || (x.a == y.a && x.c > y.c); 
});
```
2. 堆的动态维护：
```cpp
priority_queue<int, vector<int>, Compare> pq;
while (i <= n && p[i].a <= current_power) {
    pq.push(i);
    i++;
}
```
3. 属性更新与答案计算：
```cpp
if (current_spirit < pq.top().b) {
    ans_spirit += pq.top().b - current_spirit;
    current_spirit = pq.top().b;
}
current_spirit += pq.top().d;
current_power += pq.top().c;
```

---
处理用时：67.74秒
# 题目信息

# 移花接木

## 题目背景


遥远的圣地生长着一棵不为人知的灵树，或有万山之高。

但有一日，藏匿于根系的腐朽力量爆发，灵树已无法支撑往日屹立冲天的高度。

## 题目描述

灵树最初的形态可以看作一棵高度为 ${10}^{{10}^{{10}^{10}}}$ 的满 $a$ 叉树，高度定义为根结点到叶子结点之间的边数。

受腐朽力量影响，灵树只能维持高度**恰好**为 $h$ 的满 $b$ 叉树形态。为了转换至该形态，灵树有两种魔法：

- 移花：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点），移除这条边以及以 $v$ 为根的**整棵子树**。
- 接木：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点）和一个结点 $w$（$w$ 不能是 $v$ 子树中或已移除的结点），将这条边原先 $u$ 一端**改接**到 $w$。**该魔法只能在根结点到** $\boldsymbol{u}$ **之间的边数** $\le 10^{10^{10}}$ **时使用。**

灵树累积的魔法力量有限，它不得不用最少次数的魔法完成转换。这是个漫长的过程，即使次数最少也会显得异常大，你只需要求出最少次数对 $10^9 + 7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**

下为 $a=1$，$b=2$，$h=1$ 时的两步转换过程，图中高度极大的冗余子树已用省略号代替。

![](https://cdn.luogu.com.cn/upload/image_hosting/p32s9v96.png)

可以证明，该数据的答案不可能低于 $2$。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (3 points)：$h = 0$。
- Subtask #2 (4 points)：$a = b$。
- Subtask #3 (8 points)：$a = 1$。
- Subtask #4 (8 points)：$b = 1$。
- Subtask #5 (17 points)：$h \le 10$。
- Subtask #6 (15 points)：$h \le 10^6$，各测试点存在 $\overline{a},\overline{b}$，其数据满足 $a=\overline{a}$，$b=\overline{b}$。
- Subtask #7 (15 points)：$h \le 10^6$。
- Subtask #8 (30 points)：无特殊限制。

所有测试点（样例除外）均含有 $10^6$ 组数据，即 $T = 10^6$。请务必采用较快的 IO（输入/输出）方式。

对于所有的数据，保证 $1 \le a,b \le 10^9$，$0 \le h \le 10^9$。

## 样例 #1

### 输入

```
2
1 2 1
3 2 1
```

### 输出

```
2
7
```

# AI分析结果



### 综合分析与结论
题目核心是构造满b叉树的最小操作次数，关键要处理a与b的大小关系。各题解均采用分情况讨论策略，核心公式为等比数列求和与快速幂计算。最优解法的核心思路：
1. **a < b**：利用接木操作复用待删除节点，最终答案简化为`a*b^h`
2. **a > b**：计算各层多余节点数总和，使用等比数列公式优化求和
3. **特例处理**：b=1时直接线性计算，避免除以0

---

### 优质题解推荐

#### 1. [AsunderSquall] ★★★★☆
**关键亮点**：
- 清晰的分类讨论与配图解释
- 数学推导完整，涵盖所有边界条件
- 代码简洁高效，包含快速幂与逆元优化
**个人心得**：
> "推式子时被卡常，注意取模优化" → 强调模运算优化的重要性

**核心代码**：
```cpp
if (b==1) cout<<(((a-1)*h+a)%mod);
else if (a<=b) cout<<ksm(b,h,mod)*a%mod;
else {
    int S = (ksm(b,h,mod)-1)*INV(b-1)%mod;
    ans = (a*ksm(b,h,mod) + (a-b)*S) % mod;
}
```

#### 2. [AuCloud] ★★★★
**关键亮点**：
- 使用字符画辅助理解操作过程
- 详细推导每层操作次数的递推关系
- 独立处理各Subtask的逻辑清晰
**核心优化**：
```cpp
int ans = (a-b) * (ksm(b,h)-1) % mod * inv(b-1) % mod;
ans = (ans + ksm(b,h)*a) % mod;  // a>b时的合并计算
```

#### 3. [y0y68] ★★★★
**关键亮点**：
- 以数学归纳法解释操作次数的推导
- 提出"贪心复用待删除节点"的关键思路
- 代码实现模块化，逻辑分层明确
**代码亮点**：
```cpp
ll db(ll x,ll h){ // 等比数列求和
    if(x==1) return h+1;
    return (x*(qpow(x,h)-1)%mod * inv(x-1) +1)%mod;
}
```

---

### 关键思路与技巧
1. **等比数列优化**：求和公式`S=(b^h-1)/(b-1)`结合快速幂与逆元
2. **贪心复用**：a < b时利用待删除节点进行接木操作，减少总次数
3. **边界特判**：单独处理b=1的情况避免除以0错误

---

### 拓展练习
1. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)  
   → 熟练掌握快速幂实现
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)  
   → 卡特兰数计算中的递推优化
3. [P1496 数列求和](https://www.luogu.com.cn/problem/P1496)  
   → 等比数列求和公式的应用

---

### 调试经验摘录
> "推式子时不知道为什么被卡常"  
→ 注意模运算的分配律性质，将`(a*b)%mod`改写为`(a%mod)*(b%mod)%mod`

> "b=1时忘记特判导致WA"  
→ 所有涉及除法的运算必须检查除数是否为0

> "画图后发现可以贪心复用节点"  
→ 复杂操作问题可通过构造小样例观察规律

---
处理用时：56.71秒
# 题目信息

# [USACO20DEC] Stuck in a Rut S

## 题目描述

Farmer John 最近扩大了他的农场，从奶牛们的角度看来这个农场相当于是无限大了！奶牛们将农场上放牧的区域想作是一个由正方形方格组成的无限大二维方阵，每个方格中均有美味的草（将每个方格看作是棋盘上的一个方格）。Farmer John 的 $N$ 头奶牛（$1≤N≤1000$）初始时位于不同的方格中，一部分朝向北面，一部分朝向东面。

每一小时，每头奶牛会执行以下二者之一：

 - 如果她当前所在的方格里的草已经被其他奶牛吃掉了，则她会停下（并从这个时刻开始一直保持停止）。
 - 吃完她当前所在的方格中的所有草，并向她朝向的方向移动一个方格。

经过一段时间，每头奶牛的身后会留下一条被啃秃了的轨迹。

如果两头奶牛在一次移动中移动到了同一个有草的方格，她们会分享这个方格中的草，并在下一个小时继续沿她们朝向的方向移动。

当 Farmer John 看到停止吃草的奶牛时会不高兴，他想要知道谁该为他停止吃草的奶牛受到责备。如果奶牛 $b$
停在了之前奶牛 $a$ 吃过草的一个方格，我们就称奶牛 $a$ 阻碍了奶牛 $b$。进一步地，如果奶牛 $a$ 阻碍了奶牛 $b$ 且奶牛 $b$ 阻碍了奶牛 $c$，我们认为奶牛 $a$ 也阻碍了奶牛 $c$（也就是说，「阻碍」关系具有传递性）。每头奶牛受到责备的程度与这头奶牛阻碍的奶牛数量一致。请计算每头奶牛受到责备的数量——也就是说，每头奶牛阻碍的奶牛数量。 

## 说明/提示

在这个样例中，奶牛 3 阻碍了奶牛 2，奶牛 4 阻碍了奶牛 5，奶牛 5 阻碍了奶牛 6。根据传递性，奶牛 4 也阻碍了奶牛 6。 

 - 测试点 2-5 中，所有坐标不超过 $2000$。
 - 测试点 6-10 没有额外限制。

供题：Brian Dean 

## 样例 #1

### 输入

```
6
E 3 5
N 5 3
E 4 6
E 10 4
N 11 1
E 9 2```

### 输出

```
0
0
1
2
1
0
```

# AI分析结果



### 综合分析与结论
该题的核心在于判断东向（E）和北向（N）奶牛的相遇点，并确定阻挡顺序。所有题解均基于以下关键点：
1. **相遇点计算**：东向牛路径为水平射线，北向牛路径为垂直射线，交点为 `(N.x, E.y)`。
2. **阻挡顺序判断**：比较两牛到达交点的时间差，时间长的牛会被先到达的牛阻挡。
3. **传递性处理**：通过累加被阻挡牛的阻碍数或构建树结构处理传递关系。

高效解法需避免逐格模拟，转而预处理所有可能的交点并按坐标排序处理。

---

### 精选题解与评分
1. **feicheng（4星）**
   - **亮点**：思路清晰，代码简洁高效。通过分离东/北向牛，枚举交点并按坐标排序处理，利用标记数组记录阻挡状态。
   - **代码核心**：
     ```cpp
     for (int i = 1; i <= cntp; i++) {
         int dx = p[i].x - c[p[i].numx].x;
         int dy = p[i].y - c[p[i].numy].y;
         if (dx < dy) { // 东向牛先到达，阻挡北向牛
             del[p[i].numy] = 1;
             ans[p[i].numx] += ans[p[i].numy] + 1;
         } else if (dx > dy) { // 北向牛先到达，阻挡东向牛
             del[p[i].numx] = 1;
             ans[p[i].numy] += ans[p[i].numx] + 1;
         }
     }
     ```

2. **wsyhb（拓扑排序版，4星）**
   - **亮点**：通过拓扑排序处理传递性，利用反图统计子树大小，避免重复计算。
   - **关键实现**：
     ```cpp
     // 建反图并拓扑排序
     for (int i = 1; i <= cnt; i++) {
         if (时间条件不满足) continue;
         add_edge(被阻挡牛, 阻挡牛); // 建反边
     }
     // 拓扑排序累加答案
     while (!q.empty()) {
         int x = q.front(); q.pop();
         ans[x]++;
         for (int y : 反边邻接表[x]) {
             ans[y] += ans[x];
             if (--d[y] == 0) q.push(y);
         }
     }
     ```

3. **Skies（4星）**
   - **亮点**：通过排序优化枚举顺序，利用标记数组记录阻挡状态，代码简洁。
   - **核心逻辑**：
     ```cpp
     sort(东向牛按y升序，北向牛按x升序);
     for (东向牛i) {
         for (北向牛j) {
             if (i.x < j.x && i.y > j.y) {
                 计算相遇时间，更新ans和标记数组;
             }
         }
     }
     ```

---

### 最优关键思路
1. **预处理交点**：枚举所有东向和北向牛的相遇点，存储坐标及对应牛编号。
2. **排序处理**：按交点坐标排序（从左下到右上），确保先处理更早发生的阻挡事件。
3. **标记与累加**：使用数组标记被阻挡的牛，直接累加被阻挡牛的阻碍数，避免重复计算。

---

### 拓展与相似题目
1. **事件排序处理**：类似问题需按时间或空间顺序处理事件，如洛谷P2123（皇后游戏）、P2895（Meteor Shower）。
2. **传递性统计**：树形结构或拓扑排序应用，如P3387（有向图缩点）、P2661（信息传递）。
3. **离散化+模拟**：大坐标问题常用离散化，如P1052（过河）、P3740（城市管理）。

---

### 推荐题目
1. [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)（贪心+排序）
2. [P2895 Meteor Shower](https://www.luogu.com.cn/problem/P2895)（BFS+事件处理）
3. [P2661 信息传递](https://www.luogu.com.cn/problem/P2661)（图论+传递性检测）

---
处理用时：71.52秒
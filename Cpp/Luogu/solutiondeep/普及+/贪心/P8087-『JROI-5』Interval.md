# 题目信息

# 『JROI-5』Interval

## 题目背景

小 C 喜欢带有区间操作的数据结构，因为这样的题总会有一档好写的 $\mathcal{O}\left(n^2\right)$ 部分分。

## 题目描述


**本题读入量较大，建议使用较快的读入方式，可以参考 [赛时公告板](https://www.luogu.com.cn/paste/lueudpd5)**

小 C 有一个长度为 $n$ 的序列 $a$，第 $i$ 项为 $a_i$。

$a$ 是一个 $1\sim n$ 的排列（即 $1\sim n$ 在 $a$ 中各出现一次）。

定义 $\operatorname{Mex}_{l,r}$ 为 $\{a_l,a_{l+1},
\cdots,a_{r-1},a_r\}$ 中**没有出现过的最小正整数**。

例如，$\operatorname{Mex}\{2,3\}=1,\operatorname{Mex}\{1,2,3\}=4$。

小 C 还有一个长度为 $n$ 的数列 $f$。

定义一个区间 $\left[l,r\right]$ 是合法的当且仅当 
$$f_{r-l+1}< \operatorname{Mex}_{l,r}$$

小 C 希望你告诉他，最短的合法区间的长度是多少，特别的，如果没有区间合法，则输出 `0`。

## 说明/提示

【样例解释】

对于 #1，容易发现 $\left[1,3\right]$ 是最短的合法区间。

对于 #2，容易发现 $\left[3,3\right]$ 是最短的合法区间。

对于 #3，容易发现没有合法的区间。

---

对于 $10\%$ 的数据，满足 $1\leq n\leq 100$。

对于 $20\%$ 的数据，满足 $1\leq n\leq 1000$。

对于另外 $10\%$ 的数据，满足 $f$ 不升，即满足 $f_1\geq f_2\geq\cdots\geq f_n$，且 $1\leq n\leq 10^6$。

对于 $100\%$ 的数据，满足 $1\leq n\leq 4\times 10^6,1\leq f_i\leq 10^9$。


## 样例 #1

### 输入

```
5
2 3 1 5 4
2 2 3 4 5```

### 输出

```
3```

## 样例 #2

### 输入

```
5
2 3 1 5 4
1 2 2 4 5```

### 输出

```
1```

## 样例 #3

### 输入

```
5
1 3 4 2 5
6 7 8 9 10```

### 输出

```
0```

## 样例 #4

### 输入

```
见附件```

### 输出

```
见附件```

# AI分析结果



### 综合分析与结论
本题核心在于快速判断各长度区间是否存在满足条件的Mex值。通过分析，最优解法基于预处理每个数的最左/最右位置，维护前缀最值来确定包含1~x的最小合法区间。若该区间长度≤当前枚举的长度i，则i合法。该思路时间复杂度O(n)，实现简洁高效。

### 高星题解推荐

#### 1. 蒟蒻炒扇贝（5星）
**关键亮点**：  
- 思路清晰，直接预处理前缀极值数组`qmin`和`qmax`，快速判断区间存在性。  
- 代码简洁易读，逻辑直观，无需复杂数据结构。

**核心代码**：
```cpp
for(int i=1;i<=n;i++) qmin[i]=min(qmin[i-1],pos[i]), qmax[i]=max(qmax[i-1],pos[i]);
for(int i=1;i<=n;i++){
    if(f[i]>n) continue;
    int l=qmin[f[i]], r=qmax[f[i]];
    if(r-l+1<=i) return i;
}
```

#### 2. 官方题解（5星）
**关键亮点**：  
- 直接维护每个Mex值对应的最小区间长度`g`，通过覆盖思想快速更新最大Mex。  
- 代码高度优化，使用差分思想处理区间覆盖，最终线性遍历比较。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    l=min(l,p[i]), r=max(r,p[i]);
    g[r-l+1] = i+1;
}
for(int i=1;i<=n;i++) g[i]=max(g[i-1],g[i]);
```

#### 3. by_chance（4星）
**关键亮点**：  
- 类似官方解法，但更注重代码可读性。  
- 显式维护包含1~x的区间端点，动态更新区间长度。

**核心代码**：
```cpp
int l=INF, r=0;
for(int i=1;i<=n;i++){
    l = min(l, pos[i]);
    r = max(r, pos[i]);
    g[i] = r-l+1;
}
if(g[f[i]] <= i) return i;
```

### 关键思路与技巧总结
1. **预处理极值**：记录每个数位置，通过前缀极值快速确定包含1~x的最小区间。
2. **贪心覆盖**：Mex具有单调性，较大Mex的区间可覆盖较小值的解，无需重复计算。
3. **逆向思维**：检查满足条件的区间时，关注包含必要数集的最小区间，而非枚举所有可能。

### 拓展与举一反三
- **类似题目**：  
  - [P4137 Rmq Problem/mex](https://www.luogu.com.cn/problem/P4137)（Mex查询）  
  - [P5503 山峰](https://www.luogu.com.cn/problem/P5503)（极值预处理）  
  - [P4766 时间旅行](https://www.luogu.com.cn/problem/P4766)（区间覆盖与贪心）

- **调试心得**：  
  - 注意特判`f[i]>n`的情况，直接跳过避免越界。  
  - 前缀极值数组初始化需合理设置边界值（如`qmin[0]=INF`）。

---
处理用时：87.68秒
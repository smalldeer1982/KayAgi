# 题目信息

# [USACO22FEB] Email Filing S

## 题目描述

Farmer John 在整理他的收件箱时落后了。他的屏幕布局如下：屏幕左侧是文件夹的垂直列表，右侧是邮件的垂直列表。总共有 $M$ 个文件夹，编号为 $1 \ldots M$（$1 \leq M \leq 10^4$）。他的收件箱目前包含 $N$ 封邮件，编号为 $1 \ldots N$（$1 \leq N \leq 10^5$）；第 $i$ 封邮件需要归档到文件夹 $f_i$（$1 \leq f_i \leq M$）。

FJ 的屏幕很小，因此他一次只能查看 $K$ 个文件夹和 $K$ 封邮件（$1 \leq K \leq \min(N, M)$）。初始时，他的屏幕显示左侧的文件夹 $1 \ldots K$ 和右侧的邮件 $1 \ldots K$。为了访问其他文件夹和邮件，他需要滚动这些列表。例如，如果他在文件夹列表中向下滚动一个位置，屏幕将显示文件夹 $2 \ldots K+1$，再向下滚动一个位置则显示文件夹 $3 \ldots K+2$。当 FJ 将一封邮件拖入文件夹时，该邮件会从邮件列表中消失，其后的邮件会向前移动一个位置。例如，如果当前显示的邮件是 $1, 2, 3, 4, 5$，而 FJ 将邮件 $3$ 拖入其对应的文件夹，邮件列表将显示 $1, 2, 4, 5, 6$。FJ 只能将邮件拖入其需要归档的文件夹。

不幸的是，FJ 的鼠标滚轮坏了，他只能向下滚动，不能向上滚动。唯一能实现类似向上滚动的效果是，当他查看邮件列表的最后 $K$ 封邮件时，如果他归档了其中一封邮件，邮件列表将再次显示尚未归档的最后 $K$ 封邮件，从而将最上面的邮件向上滚动一个位置。如果剩余的邮件少于 $K$ 封，则显示所有剩余的邮件。

请帮助 FJ 判断是否能够归档所有邮件。

## 说明/提示

- 在输入 2-10 中，所有子用例的 $M$ 之和不超过 $10^3$。
- 在输入 11-12 中，没有额外限制。

## 样例 #1

### 输入

```
6
5 5 1
1 2 3 4 5
5 5 1
1 2 3 5 4
5 5 1
1 2 4 5 3
5 5 2
1 2 4 5 3
3 10 2
1 3 2 1 3 2 1 3 2 1
3 10 1
1 3 2 1 3 2 1 3 2 1```

### 输出

```
YES
YES
NO
YES
YES
NO```

# AI分析结果



### 综合分析与结论
各题解核心思路均围绕**文件夹处理顺序**和**滑动窗口维护**展开。关键难点在于保证文件夹一旦滑出屏幕，其所有对应邮件必须已归档。最优解法需结合以下要素：
1. **按顺序处理文件夹**：确保每个文件夹完全归档后再滑动窗口
2. **贪心策略**：优先处理当前窗口内的可归档邮件
3. **高效数据结构**：用队列/栈管理待处理邮件，避免重复扫描

---

### 精选题解与评分

#### 1. sprads（⭐⭐⭐⭐⭐）
**关键亮点**：
- 双维护结构：`set`管理当前屏幕邮件 + `m个queue`按文件夹分类
- 栈结构处理滚出屏幕的邮件
- 预处理未归档邮件计数（c数组）实现快速判断
**核心代码思想**：
```cpp
set<int> sce; // 当前屏幕中的邮件
queue<int> q[M]; // 各文件夹待处理邮件
stack<int> st; // 滚出屏幕的邮件

// 处理每个文件夹i时：
for(int i=1; i<=m; i++) {
    // 1. 处理新进入屏幕的文件夹i+K-1的邮件
    // 2. 循环处理当前文件夹i的剩余邮件（c[i]）
    // 3. 分情况处理邮件来源（新邮件/栈中邮件）
}
```

#### 2. 滑蒻稽（⭐⭐⭐⭐）
**创新点**：
- 优先队列维护当前窗口最小可归档邮件
- 双指针动态维护邮件窗口范围
- 用`deque`缓存被跳过的邮件
**调试心得**：
> "邮件窗口滑到底后需要反向补位，需特别注意`fl`指针的有效性，必须跳过已处理邮件"

**核心逻辑**：
```cpp
priority_queue<pii, vector<pii>, greater<pii>> q; // 按文件夹编号排序
deque<int> l; // 缓存被跳过的邮件

// 动态调整窗口：
if(可归档) {
    归档并补充新邮件;
} else if(窗口未到底) {
    滑动窗口并记录被跳过的邮件;
} else if(需要反向补位) {
    从缓存中取出邮件补充;
}
```

---

### 关键技巧总结
1. **文件夹处理顺序**：必须严格从左到右处理，确保每个文件夹完全清空
2. **滑动窗口补位机制**：分正向滑动（新增邮件）和反向补位（栈/队列缓存）
3. **事件驱动处理**：优先处理当前窗口内的可归档邮件，避免无效滚动
4. **空间换时间**：通过预存各文件夹的邮件队列，减少扫描时间

---

### 相似题目推荐
1. [P1540 机器翻译](https://www.luogu.com.cn/problem/P1540) - 滑动窗口+队列缓存
2. [P2034 选择数字](https://www.luogu.com.cn/problem/P2034) - 滑动窗口+贪心决策
3. [P3960 列队](https://www.luogu.com.cn/problem/P3960) - 动态维护行尾元素+离线处理

---

### 个人心得摘录
- **sprads**：  
  "当屏幕中有K封邮件时，踢出最顶上的邮件必须同时维护set和对应文件夹的queue"
- **dino**：  
  "分三步处理：能归就归→不能则滚动→栈中邮件掉落，这样拆分步骤后调试更清晰"
- **滑蒻稽**：  
  "优先队列中需要持续检查邮件是否在有效窗口范围内，避免处理过时邮件"

---
处理用时：65.67秒
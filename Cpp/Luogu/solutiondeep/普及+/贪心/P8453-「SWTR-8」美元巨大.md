# 题目信息

# 「SWTR-8」美元巨大

## 题目背景

#### 输出不允许有前导零。

原题目名称为「美元巨大二的二的二的二的二」。

小 A 喜欢用形如
$$
\Huge 2 ^ {2 ^ {2 ^ {2 ^ {2}}}}
$$
的幂塔把小 T 的博客炸掉。

## 题目描述

小 A 有 $n$ 个 $2$ 的幂 $a_1, a_2, \cdots, a_n$。他要在这些数之间插入 $x$ 个异或运算符和 $y$ 个或运算符，组成一个表达式。保证 $x + y = n - 1$。

表达式越大，越有可能炸掉小 T 的博客。小 A 希望 **从左往右** 计算表达式时它的值最大。他想知道表达式最大可能的取值是多少，用二进制表示。他还希望你构造出这样的表达式，因为他懒得自己构造了。

若存在多组构造方案，输出任意一组。

多组测试数据。

## 说明/提示

**「评分方式」**

对于每组测试数据：

- 若你输出的第一行比标准答案劣，得 0 分。
- 若你输出的第一行比标准答案优，则 checker 将检查你的构造方案是否正确。若正确，则返回 `_fail`，表现为测试点 UKE；否则得 0 分。
- 否则，你输出的第一行和标准答案一样。若构造方案不正确，得 0.6 分；否则得 1 分。

每个测试点的得分为测试点内所有测试数据的得分的最小值乘以该测试点的分值。

注意，checker 能检测出你的答案比标准答案优的前提是输出完全符合格式。**一旦输出不符合格式，得 0 分**。格式限制包括但不限于：

- 第一行不得输出除 `0` 和 `1` 以外的字符。
- 第二行不得输出除 `^` 和 `|` 以外的字符，且字符串长度恰为 $n - 1$。
- `^` 的个数恰为 $x$，`|` 的个数恰为 $y$。

**「数据范围与约定」**

- 测试点 #1（10 points）：所有 $b_i$ 互不相等。
- 测试点 #2（20 points）：所有 $b_i$ 相等。
- 测试点 #3（30 points）：$n \leq 8$。
- 测试点 #4（25 points）：$n \leq 10 ^ 3$。
- 测试点 #5（15 points）：无特殊限制。

对于 $100\%$ 的数据：

- $1\leq T\leq 20$。
- $1 \leq n \leq 2.5 \times 10 ^ 4$。
- $0 \leq x, y < n$，$x + y = n - 1$。
- $1\leq a_i < 2 ^ {2 ^ {2 ^ {2 ^ 2}}}$，即 $0\leq b_i < 65536$。

**「帮助与提示」**

- 关于 [位运算](https://oi-wiki.org/math/bit/)。
- 请注意 IO 优化。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) B
- Idea & Solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。
- Tester：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
4
4 0 3
1 0 6 4
8 5 2
1 5 5 7 1 5 5 7
1 0 0
15
4 3 0
65535 65535 57 57
```

### 输出

```
1010011
|||
10100000
^|^^^^|
1000000000000000

0
^^^
```

# AI分析结果



### 综合分析与结论
本题核心在于利用或运算符的"保1"特性，通过贪心策略最大化二进制高位。所有解法均采用以下关键思路：
1. **高位优先**：从最高位开始处理，优先保证高位为1
2. **奇偶判定**：奇数个相同位全用异或，偶数个则在最后一次出现时用或
3. **剩余处理**：多余的或运算符放在不影响高位的位置
4. **桶计数优化**：用数组统计各二进制位出现次数及最后出现位置

### 高评分题解推荐
#### 1. [Alex_Wei] ⭐⭐⭐⭐⭐
**亮点**：
- 时间复杂度O(n+V)高效处理大数据
- 代码简洁（仅50行核心逻辑）
- 通过last数组精准定位最后出现位置
- 剩余或运算符的逆向填充策略

**核心代码**：
```cpp
for(int i = W-1; ~i; i--) // 从高位到低位处理
    if(buc[i] & 1) ans[i] = 1;
    else if(y && buc[i]) ans[i] = op[lst[i]] = 1, y--;
// 处理剩余或运算符
for(int i = n; y; i--) if(!op[i]) op[i] = 1, y--; 
```

#### 2. [NBest] ⭐⭐⭐⭐
**亮点**：
- 详细注释解释关键决策点
- 引入flag处理前导零
- 独立处理首次出现与后续出现的策略

**心得摘录**：
> "比赛时被大量2的幂吓退，重现赛时发现本质是位运算贪心。关键在于意识到或运算符的'保底'作用，即使前面全异或归零，最后一次或能起死回生"

#### 3. [Flash_Man] ⭐⭐⭐⭐
**亮点**：
- 利用stable_sort保持原始顺序
- 双数组分别记录运算符和出现次数
- 引入is数组跟踪已处理位

**关键实现**：
```cpp
stable_sort(num+2, num+n+1, cmp); // 保持原始相对顺序
for(int i=2; i<=n; i++) {
    if(首次出现) 优先用异或
    else if(奇数次) 消耗异或
    else 尝试用或保底
}
```

### 关键优化技巧
1. **位独立处理**：利用2的幂特性独立处理每个二进制位
2. **最后出现定位**：记录每个位最后出现位置，确保或运算符精准投放
3. **逆向填充**：剩余或运算符从后往前填充，避免影响已确定的高位
4. **桶计数法**：用数组代替哈希表，O(1)访问各二进制位信息

### 推荐练习题
1. [P2114 起床困难综合症](https://www.luogu.com.cn/problem/P2114) - 位运算贪心经典
2. [P1582 倒水](https://www.luogu.com.cn/problem/P1582) - 二进制位操作与贪心
3. [P2397 yyy loves Maths VI](https://www.luogu.com.cn/problem/P2397) - 奇偶计数与位运算结合

### 调试经验总结
1. **前导零陷阱**：输出结果时要反向遍历桶数组，通过flag跳过前导零
2. **运算符计数**：异或和或的总数必须严格等于输入值，需在填充后验证
3. **位置偏移**：运算符数组索引与原始位置存在±1偏移，易出错需仔细验证
4. **大数据测试**：构造全相同值、全异值等边界case验证算法稳定性

---
处理用时：56.96秒
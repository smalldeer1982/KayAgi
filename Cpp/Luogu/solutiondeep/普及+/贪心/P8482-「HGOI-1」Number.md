# 题目信息

# 「HGOI-1」Number

## 题目背景

$\text{bh1234666}$ 正在学习乘法！

## 题目描述

$\text{bh1234666}$ 有一定数量的数字 $0 \sim 9$，现在他想让你寻找一种分配方案，将它们分成两个整数，使得他们的乘积 $p$ 最大。
 
由于 $\text{bh1234666}$ 不喜欢太大的数，所以你只需要输出**两个非负整数**，使它们的乘积**等于**最大乘积 $p$，但是这两个整数 $0 \sim 9$ 的数量不能等于给定的数量（任意一个数字数量不相等即可，**不考虑前导零**）。

$\text{bh1234666}$ 是很善良的，如果 $0 \sim 9$ 的数量等于给定的数量了，你依旧可以得到的一半的分。

## 说明/提示

#### 样例解释
最大可能乘积为 $97643210 \times 88653221=13949030 \times 620572547=8656385075279410$。

若输出 $97643210 \times 88653221$ 则只能得到一半的分，因为 $0\sim 9$ 出现的次数与给定的相同。

#### 数据范围及约定
本题采用**捆绑测试**，共有 $5$ 个 $\text{subtask}$，最终分数为所有 $\text{subtask}$ 分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \textbf{Score} & \sum c_i\le \cr\hline
1 & 10 & 20 \cr\hline
2 & 20 & 100 \cr\hline
3 & 20 & 5000 \cr\hline
4 & 20 & 10^6 \cr\hline
5 & 30 & 10^7 \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，保证 $1 \le c_i$，$\sum c_i \le 10^7$。

#### 说明

本题有 $\text{spj}$，两数乘积正确得一半的分，数量与给出的不同且乘积正确得全部分数。故每一 $\text{subtask}$ 的得分为其中所有数据点得分的**最小值**。


## 样例 #1

### 输入

```
1 2 3 2 1 1 2 1 2 1```

### 输出

```
13949030
620572547```

# AI分析结果



### 综合分析与结论
本题核心在于构造最大乘积的两个数，并通过巧妙调整使其数字分布不符合原条件。各题解的共同思路是：
1. 贪心策略：将数字降序排列，交替分配到两数以最小化差值
2. 末尾调整法：利用必存在末尾0的特性，通过乘除2改变数字分布

最优解法的关键点：
- 构造时保证两数长度差≤1
- 末尾0的乘除操作可避免高精度运算
- 时间复杂度优化至O(n)

### 高分题解推荐

#### 1. 作者：bh1234666（原出题人） ⭐⭐⭐⭐⭐
**关键亮点**：
- 理论证明完备：详细推导了贪心策略的数学依据
- 代码简洁高效：通过`half()`和`dble()`实现O(1)调整，避免高精度运算
- 利用题目特性：末尾0必存在，直接操作字符串而非统计计数

**核心代码思想**：
```cpp
void half(char *s,int len) { // 除以2操作
    for(int i=0;i<len;i++) {
        s[i]-='0';
        if(s[i]&1) s[i+1]+=10;
        s[i]>>=1;
        s[i]+='0';
    }
}

void dble(char *s,int len) { // 乘2操作
    int fl=0;
    for(int i=len-1;i>=0;i--) {
        s[i]-='0';
        s[i] = s[i]*2 + fl;
        fl = s[i]/10;
        s[i] = s[i]%10 + '0';
    }
}
```

#### 2. 作者：linyuhao ⭐⭐⭐⭐
**关键亮点**：
- 双字符串交替构造清晰
- 完整高精度实现适配更大数据范围
- 末尾0处理逻辑明确

**核心代码思想**：
```cpp
void sh(string x,int y) { // 高精度乘低精
    memset(c,0,sizeof(c));
    for(int i=0;i<x.size();i++) 
        a[i] = x[x.size()-i-1]-'0';
    for(int i=0;i<x.size();i++)
        c[i] = a[i] * y;
    // 处理进位...
}
```

#### 3. 作者：JackMerryYoung ⭐⭐⭐⭐
**个人心得**：
> "赛时白痴犯了错，下次要注意符号问题"  
> 调试中发现等号处理的边界条件易错，强调严格数学证明的重要性

**理论贡献**：
- 给出完整不等式推导：$(a-c)(d-b) ≥ 0$ 的条件证明
- 提出"首位大者优先，后续小者补偿"的交替策略

### 关键思路总结
1. **贪心构造**：从高位到低位交替分配，保持两数差值最小
2. **末尾调整法**：利用必存在0的特性，通过乘除2改变位数分布
3. **避免高精度**：直接操作字符串而非完整乘积计算

### 拓展训练
1. [P1018 乘积最大](https://www.luogu.com.cn/problem/P1018) - 同类贪心+高精度问题
2. [P1303 高精度乘法](https://www.luogu.com.cn/problem/P1303) - 高精度算法基础
3. [P1249 最大乘积](https://www.luogu.com.cn/problem/P1249) - 数论+贪心综合应用

### 核心代码实现
bh1234666解法中的关键调整函数：
```cpp
// 除以2操作（处理前导零）
void half(char *s, int len) {
    for(int i=0; i<len; i++) {
        s[i] -= '0';
        if(s[i] & 1) s[i+1] += 10;
        s[i] >>= 1;
        s[i] += '0';
    }
    if(s[0] == '0') puts(s+1);
    else puts(s);
}

// 乘2操作（处理进位）
void dble(char *s, int len) {
    int fl = 0;
    for(int i=len-1; i>=0; i--) {
        s[i] -= '0';
        int val = s[i] * 2 + fl;
        s[i] = val % 10 + '0';
        fl = val / 10;
    }
    if(fl) putchar('1');
    puts(s);
}
```

---
处理用时：62.27秒
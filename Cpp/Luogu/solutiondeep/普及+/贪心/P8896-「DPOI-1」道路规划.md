# 题目信息

# 「DPOI-1」道路规划

## 题目背景

不可以，总司令。

## 题目描述

战场上有 $n$ 个据点，从 $1\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。

一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。

## 说明/提示

#### 样例 #1 解释
下面是第 $1$ 组数据中一种可行的方案：

![](https://cdn.luogu.com.cn/upload/image_hosting/2uvwlydw.png)

#### 样例 #2 解释
该样例满足测试点 $3 \sim 6$ 的限制。
#### 数据范围
**本题测试点分数不等分。**

|  测试点编号  | $n \le$ | 特殊条件 |每个测试点分数|
| :----------: | :-----------: | :------: | :----: |
|     $1\sim 2$      |     $10$     |   无   |$5$|
|     $3\sim 6$      |     $1000$     |    无     |$5$|
|     $7\sim 8$      |     $10^5$     |    所有 $l_i = i-1$ 或所有 $l_i \geq \min (i, n - 1)$    |$5$|
| $9 \sim 10$  | $10^5$ | $l_i=0$ 或 $r_i=n-1$ |$5$|
| $11 \sim 15$ | $10^5$ | 无 |$10$|

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq l_i \leq r_i < n$，$1 \leq T \leq 10$。

## 样例 #1

### 输入

```
2
5
0 1 4 0 0
3 4 4 1 3
3
1 2 2
2 2 2```

### 输出

```
YES
NO```

## 样例 #2

### 输入

```
见下发文件 road2.in```

### 输出

```
见下发文件 road2.out```

# AI分析结果



### 综合分析与结论
题目要求将完全图定向为DAG且满足出度约束，核心思路是将其转化为区间贪心问题：构造一个排列使得每个元素在对应区间内。所有题解均基于「拓扑序出度唯一性→排列问题→贪心匹配区间」这一关键路径，差异仅在于实现细节（如端点转换方式、堆的维护顺序等）。

---

### 高评分题解推荐

#### 1. 官方题解（作者：kevinchw） ★★★★☆
**关键亮点**：
- 思路清晰，直接点明拓扑序与排列的等价性
- 代码简洁高效，预处理区间转换逻辑明确
- 使用小根堆维护右端点，符合经典贪心策略

**代码核心**：
```cpp
for(int i=1;i<=n;i++) {
    v[a[i].l].pb(a[i].r); // 按左端点分组存储右端点
}
priority_queue<int,vector<int>,greater<int>> q;
for(int i=1;i<=n;i++) {
    for(auto r:v[i]) q.push(r); // 按左端点顺序入堆
    if(q.empty() || q.top()<i) return NO; // 无法匹配当前数
    q.pop();
}
```

#### 2. 作者：DengDuck ★★★★
**关键亮点**：
- 提供竞赛图性质的严格数学证明
- 代码采用动态区间分组，逻辑简明
- 预处理时直接建立左端点→右端点映射

**代码核心**：
```cpp
vector<LL> V[N]; // 左端点分组
priority_queue<LL, vector<LL>, greater<LL>> Q;
for(int i=0;i<n;i++) {
    for(LL j:V[i]) Q.push(j); // 动态添加当前左端点的区间
    if(Q.empty() || Q.top()<i) return NO;
    Q.pop();
}
```

#### 3. 作者：Gapple ★★★★
**关键亮点**：
- 采用负值技巧简化小根堆实现
- 预处理时直接建立左端点→右端点映射
- 代码风格简洁，变量命名规范

**代码核心**：
```cpp
priority_queue<int> seg; // 存储负的右端点
for(int lo=0;lo<n;++lo) {
    for(int r:segs[lo]) seg.emplace(-r); // 负值入堆模拟小根堆
    if(seg.empty() || -seg.top()<lo) return NO;
    seg.pop();
}
```

---

### 最优思路与技巧总结
**核心算法**：贪心 + 优先队列  
**关键步骤**：
1. **问题转化**：DAG的出度序列必须是 `0,1,...,n-1` 的排列，转化为区间匹配问题
2. **贪心策略**：按数值升序处理，将左端点≤当前值的区间加入堆，每次取最小右端点匹配
3. **实现优化**：预处理时将区间按左端点分组，动态维护可匹配区间集合

**同类型题套路**：
- 区间调度问题（如最大不相交区间数）
- 带约束的排列构造问题
- 拓扑序相关构造问题

---

### 推荐练习题
1. [P1803 线段覆盖](https://www.luogu.com.cn/problem/P1803)（经典区间贪心）
2. [P4059 找爸爸](https://www.luogu.com.cn/problem/P4059)（带约束的序列匹配）
3. [P1966 火柴排队](https://www.luogu.com.cn/problem/P1966)（排列构造与贪心策略）

---

### 题解中的调试经验
1. **端点转换陷阱**：多个题解出现 `n - r_i` 的转换操作（如官方题解），需注意原题中给出的 `r_i` 是出度上限，而代码中实际处理的是拓扑序位置
2. **堆初始化问题**：WDY_Hodur 的代码中显式清空堆，避免多测数据残留问题
3. **边界条件处理**：lngym 的代码在排序后特判 `i` 的合法性，确保右端点≥当前值

---
处理用时：61.20秒
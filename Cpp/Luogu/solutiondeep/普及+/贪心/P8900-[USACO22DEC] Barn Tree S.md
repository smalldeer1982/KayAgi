# 题目信息

# [USACO22DEC] Barn Tree S

## 题目描述

Farmer John 的农场有 $N$ 个牛棚 $(2 \le N \le 2 \times 10^5)$，编号为 $1 \cdots N$。有 $N−1$ 条道路，每条道路连接两个牛棚，并且从任一牛棚均可通过一些道路到达任一其他牛棚。目前，第 $j$ 个牛棚中有 $h_j$ 个干草捆 $(1 \le h_j \le 10^9)$。 

为使他的奶牛们满意，Farmer John 想移动这些干草，使得每个牛棚都有相同数量的干草捆。他可以选择任何一对由一条道路连接的牛棚，并命令他的农场工人将不超过第一个牛棚中干草捆数量的任意正整数个干草捆从第一个牛棚移动到第二个牛棚。 

请求出一个 Farmer John 可以发出的命令序列，以尽可能少的命令数完成这一任务。输入保证存在符合要求的命令序列。 

## 说明/提示

### 样例 1 解释

在这个例子中，共有十二个干草捆和四个牛棚，这意味着每个牛棚最后必须有三个干草捆。输出样例中的命令顺序可以用以下的自然语言表述： 

1. 从牛棚 $3$ 到牛棚 $2$，移动 $1$ 个干草捆。
2. 从牛棚 $4$ 到牛棚 $2$，移动 $2$ 个干草捆。
3. 从牛棚 $2$ 到牛棚 $1$，移动 $1$ 个干草捆。

### 测试点性质

- 测试点 $2-8$ 满足 $N \le 5000$。
- 测试点 $7-10$ 满足 $v_i=u_i+1$。
- 测试点 $11-16$ 没有额外限制。

## 样例 #1

### 输入

```
4
2 1 4 5
1 2
2 3
2 4```

### 输出

```
3
3 2 1
4 2 2
2 1 1```

# AI分析结果



### 综合分析与结论
各题解核心思路均为树形贪心：通过后序遍历处理子树的干草盈余（上传父节点），再处理不足部分（父节点下传），确保合法操作顺序。最优解法的关键点在于**先收集子树多余干草，再分配不足部分**，保证父节点有足够资源，避免负数。

### 精选题解

#### 1. 作者：yemuzhe（★★★★★）
**关键亮点**：
- 两阶段处理：DFS统计盈余/不足，二次遍历按顺序输出操作。
- 分两次处理子树：先处理盈余子树（上传），再处理不足子树（下传），确保合法性。
- 代码简洁清晰，逻辑直观。

**核心代码**：
```cpp
void sol(int x, int fa) {
    // 先处理盈余子树（上传）
    for (int i = head[x], y; i; i = nxt[i]) {
        if ((y = ver[i]) == fa || f[y] < 0) continue;
        sol(y, x);
    }
    // 再处理不足子树（下传）
    for (int i = head[x], y; i; i = nxt[i]) {
        if ((y = ver[i]) == fa || f[y] >= 0) continue;
        printf("%d %d %lld\n", x, y, -f[y]);
        sol(y, x);
    }
    // 最后上传给父节点
    if (f[x] > 0) printf("%d %d %lld\n", x, fa, f[x]);
}
```
**实现思想**：DFS后序遍历子节点，优先处理需要上传的子树，确保父节点收集足够干草后再处理下传需求。

#### 2. 作者：Lantrol（★★★★☆）
**关键亮点**：
- 两次独立DFS分别处理上传和下传。
- 完全分离上传与下传阶段，逻辑清晰易懂。
- 使用显式边存储，便于操作记录。

**核心代码**：
```cpp
void dfs1(int u, int fa){ // 上传阶段
    for(int v:g[u]) if(v!=fa) dfs1(v,u);
    if(val[u]>0) ans.push_back({u,fa,val[u]});
    val[fa] += val[u];
}
void dfs2(int u, int fa){ // 下传阶段
    for(int v:g[u]) if(v!=fa && val[v]<0){
        ans.push_back({u,v,-val[v]});
        dfs2(v,u);
    }
}
```
**实现思想**：第一遍DFS处理所有上传操作，第二遍DFS处理下传，严格分离两阶段。

#### 3. 作者：EXODUS（★★★★☆）
**关键亮点**：
- 拓扑排序保证操作顺序合法性。
- 显式构建有向边，通过入度控制执行顺序。
- 可扩展性强，适用于更复杂依赖场景。

**核心代码**：
```cpp
void dfs2(int x, int fa){ // 构建有向边
    for(int v:g[x]) if(v!=fa){
        ll delta = sum[v] - cow[v]*ave;
        if(delta>0) add_edge(v, x, delta); // 上传
        else if(delta<0) add_edge(x, v, -delta); // 下传
    }
}
void topo(){ // 按拓扑序执行操作
    queue<int> q;
    for(int i=1;i<=n;i++) if(!in[i]) q.push(i);
    while(!q.empty()){
        int u=q.front(); q.pop();
        for(auto e:edges[u]){
            printf("%d→%d %d\n",u,e.to,e.w);
            if(--in[e.to]==0) q.push(e.to);
        }
    }
}
```
**实现思想**：将上传/下传转化为有向边，通过拓扑排序确保无循环依赖。

---

### 最优思路总结
1. **子树自平衡**：每个子树独立计算盈余/缺口，仅通过父边调整。
2. **操作顺序**：先处理所有上传操作（保证父节点资源充足），再处理下传。
3. **DFS遍历顺序**：后序遍历优先处理深层子树，确保自底向上调整。

---

### 相似题目推荐
1. **[P3177 树上染色](https://www.luogu.com.cn/problem/P3177)**  
   *考察树形DP与子树贡献统计*
2. **[P1099 树网的核](https://www.luogu.com.cn/problem/P1099)**  
   *涉及树结构的贪心选择与路径处理*
3. **[P3942 树上游戏](https://www.luogu.com.cn/problem/P3942)**  
   *树形动态规划与资源分配策略*

---

### 个人心得摘录
- **yemuzhe**：  
  > "先处理多余子树的上传，再处理不足子树的下传，保证父节点有足够资源"
  *调试关键：验证中间节点权值是否非负*

- **Acoipp**：  
  > "建立有向边进行拓扑排序时，发现必须反向建边（上传边终点是父节点）才能保证执行顺序"
  *踩坑教训：边的方向直接影响拓扑序正确性*

- **EXODUS**：  
  > "最初直接链式处理导致部分点权为负，改为严格两阶段处理后AC"
  *经验：分离上传/下传阶段对保证合法性至关重要*

---
处理用时：82.59秒
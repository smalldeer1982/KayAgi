# 题目信息

# 「DTOI-4」行走

## 题目背景

小 L 感到无聊，于是希望在树上行走。

## 题目描述

小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。

他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。

他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：

- $P$ 是一条**可以为空**的**简单有向路径**。
- 设 $P$ 中依次经过的点为 $P_1, P_2, \cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。
- 设 $f(P) = \displaystyle\sum_{i = 1}^{|P|} \frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。
- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。

请你求出符合上述条件的路径 $P$。 

------------

关于本题中字典序的定义：

设有两条待比较的路径 $P \neq Q$。

- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。
- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。

## 说明/提示

#### 样例 #1 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)

$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \frac{1}{4} = \frac{5}{4}$。可以证明不存在更优的 $P$。
#### 数据范围
| $\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |
| :------: | :------: | :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 50$ | 无特殊限制 | 无 | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 500$ | 同上 | $1$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 5 \times 10^3$ | 同上 | $1, 2$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^5$ | 同上 | $1 \sim 3$ | $20 \operatorname{pts}$ |
| $5$ | 无特殊限制 | $a_i \in \{-1, 1\}$ | 无 | $20 \operatorname{pts}$ |
| $6$ | 同上 | 无特殊限制 | $1 \sim 5$ | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$a_i \in \{-1, 0, 1\}$，$1 \leq u, v \leq n$，保证给出的边可以构成一棵**无根树**。

## 样例 #1

### 输入

```
5
1 0 -1 1 -1
1 2
2 3
2 4
1 5```

### 输出

```
1 2 4```

# AI分析结果



### 综合分析与结论
该题核心难点在于：在保证分数最大的前提下，处理字典序最小的复合约束。各题解均基于「排除-1节点、优先选1节点」的贪心策略，通过DFS/BFS维护最大贡献路径，并利用邻接表排序确保字典序。最优解法的关键在于：分层处理贡献权重、动态维护候选路径、末尾0剪裁技巧。

---

### 高星题解推荐

#### 1. xiaoqian02（4星）
**关键亮点**：
- 清晰的DFS回溯框架，通过`qz`数组维护当前路径权重。
- 邻接表排序处理字典序，动态剪枝低贡献分支。
- 完整处理末尾0剪裁逻辑，代码可读性较高。

**个人心得**：
> "dfs中维护nxt数组记录最优转移，避免路径冗余计算。末尾0处理需在回溯时重置qz数组"

**核心代码思路**：
```cpp
bool dfs(int p,int fr,int dep){
    int mx=-1;
    for(子节点k){
        if(a[k]==1 && 当前层权重可更新){
            更新qz数组，记录nxt[p]=k;
            递归dfs(k)
        }
    }
    if(无1节点){
        处理0节点递归，保留最小字典序
    }
}
```

#### 2. Hovery（4星）
**关键亮点**：
- BFS分层处理，每层维护最大值标记。
- 二次DFS回溯路径，确保字典序最小。
- 使用`vis`数组避免重复访问，优化时间复杂度。

**核心代码思路**：
```cpp
void bfs(){
    queue<tuple<int,int,int>> q; // (节点,深度,当前贡献)
    while(!q.empty()){
        更新每层最大值mx[dep];
        筛选可进入下一层的节点;
    }
}
void dfs回溯路径时选择编号最小子节点;
```

#### 3. Leasier（4星）
**关键亮点**：
- 双队列交替处理分层逻辑，优先处理1节点层。
- 动态维护候选节点集合，通过`dot1/dot2`数组实现。
- 末尾0剪裁通过逆向遍历层数实现。

**核心代码思路**：
```cpp
while(分层处理){
    if(当前层有1节点){
        筛选所有1节点进入下一层;
        清除非1节点;
    }else{
        处理0节点;
    }
}
逆向遍历层数，剪裁末尾0;
```

---

### 关键技巧总结
1. **贪心分层处理**：每层优先选1，无法选1时才选0。
2. **邻接表预排序**：确保DFS/BFS遍历时优先访问编号小的节点。
3. **动态剪枝**：通过维护当前最大贡献值，及时终止低权重分支。
4. **末尾0剪裁**：逆向扫描路径，删除尾部连续的0节点。

---

### 相似题目推荐
1. [P1395 树的直径](https://www.luogu.com.cn/problem/P1395)（树形DP+路径处理）
2. [P1351 联合权值](https://www.luogu.com.cn/problem/P1351)（树形结构+最值维护）
3. [P1270 访问美术馆](https://www.luogu.com.cn/problem/P1270)（树形遍历+时间约束）

---

### 调试经验摘录
- "排序邻接表后，需注意双向边的处理，避免父节点回退"
- "末尾0剪裁时需特判全0路径，否则会误删有效节点"
- "BFS中维护层最大值时，同一层需同步筛选，否则产生路径冲突"

---
处理用时：67.74秒
# 题目信息

# 「GMOI R2-T2」猫耳小（加强版）

## 题目背景

**本题与 [原题](https://www.luogu.com.cn/problem/P9199) 的区别在于数据范围和输出格式。在这一版本中，$n\le 10^6$，值域为 $10^9$，你需要给出构造。**

![](https://cdn.luogu.com.cn/upload/image_hosting/r8a6ylx3.png)

## 题目描述

小 R 是一个可爱的猫耳女孩子，她喜欢研究数列的 $\operatorname{mex}\text{*}$。

现在她有一个长度为 $n$ 的数列 $a$。她讨厌整数 $k$，因此她希望修改数列 $a$ 的若干个元素为任意**自然数**，使得 $a$ 的任意**连续非空子串**的 $\operatorname{mex}$ 都不等于 $k$。

请你求出最少需要修改多少个元素，并给出方案。

$\text{*}$ 本题中，数列的 $\operatorname{mex}$ 被定义为数列中最小未出现的**自然数**，例如：

- $\operatorname{mex}\{1,2,3\}=0$，因为 $0$ 是自然数。
- $\operatorname{mex}\{0,1,3\}=2$。
- $\operatorname{mex}\{0,1,2\}=3$。

## 说明/提示

**样例解释**

一种方案是将 $\{1,0,1,3,0\}$ 改为 $\{1,1,1,3,2\}$，共改动两个元素。

可以证明不存在更优的方案。

---

**评分方式**

本题采用自定义校验器（Special Judge）进行评测。

对于每个测试点，如果你的最小步数正确，可以得到 $30\%$ 的分数。在此基础上，如果方案也正确，可以得到满分。

请注意：即使你不会给出方案，也请按照输出格式在第二行输出 $n$ 个整数。

---

**本题采用捆绑测试，数据无梯度。**

对于 $100\%$ 的数据，$1\le n\le 10^6$，$0\le k,a_i\le 10^9$。

本题读写量较大，建议使用效率较高的读写方式。

## 样例 #1

### 输入

```
5 2
1 0 1 3 0```

### 输出

```
2
1 1 1 3 2```

# AI分析结果



### 综合分析与结论
各题解核心思路均为贪心策略：遍历数组时维护当前区间状态，确保不会出现子串mex等于k。通过维护计数数组或集合，当检测到可能导致mex=k时修改元素为k，并重置状态。关键优化包括处理k=0/k>n的特殊情况、动态维护计数数组避免重复清空、利用指针划分独立区间等。

---

### 高星题解推荐

#### 1. QianRan_GG（★★★★★）
**关键亮点**  
- 详细分类讨论（k=0、k>n、一般情况），逻辑清晰。
- 维护计数数组及动态mex值，时间复杂度严格O(n)。
- 代码可读性强，注释详细，适合学习实现细节。

**代码核心**  
```cpp
for(int l = 0, i = 1; i <= n; ++i) {
    if (a[i] == k) {
        // 清空计数并重置左指针
        while(++l < i) if(a[l] < k) cnt[a[l]]--;
        mex = 0;
    } else if (a[i] < k) {
        cnt[a[i]]++;
        while (cnt[mex]) mex++; // 动态计算当前mex
        if (mex == k) { // 需要修改
            ans++;
            cnt[a[i]]--; // 撤销当前计数
            b[i] = k;    // 修改为k
            // 清空计数并重置左指针
            while(++l < i) if(a[l] < k) cnt[a[l]]--;
            mex = 0;
        }
    }
}
```

#### 2. zjc5（★★★★☆）
**关键亮点**  
- 使用标记数组优化计数清空，避免O(k)操作。
- 引入“清零次数”概念，用O(1)时间重置计数状态。
- 代码简洁高效，适合处理大k值。

**代码核心**  
```cpp
unordered_map<int, int> cg; // 记录每个数的最后清零次数
int g = 0; // 总清零次数
for (int i = 1; i <= n; i++) {
    if (a[i] < k) {
        if (cg[a[i]] < g) { // 需要更新清零状态
            cg[a[i]] = g;
            c[a[i]] = 0;
        }
        if (!c[a[i]]) cnt++;
        c[a[i]] = 1;
    }
    if (cnt == k) {
        g++;        // 增加清零次数
        ans[i] = k; // 修改当前元素
        cnt = 0;
        mx++;
    }
}
```

#### 3. Nine_Suns（★★★★☆）
**关键亮点**  
- 双指针动态维护区间，确保每个修改点分割独立区间。
- 桶计数结合滑动窗口，严格保证每个子区间处理一次。
- 代码实现简洁，适合理解贪心策略与区间划分。

**代码核心**  
```cpp
int l = 1, s = 0; // s为当前区间内不同数的数量
memset(c, 0, sizeof(c));
for (int i = 1; i <= n; i++) {
    add(i); // 将a[i]加入计数桶
    if (s == k && a[i] != k) {
        b[i] = k; // 修改为k
        ans++;
        // 清空计数并移动左指针
        while (l <= i) del(l++);
    }
    if (b[i] == k) {
        while (l <= i) del(l++); // 分割区间
    }
}
```

---

### 最优关键思路总结
1. **贪心策略**：在遍历中一旦发现当前区间可能导致mex=k，立即修改最后一个元素为k，并重置后续处理。
2. **动态计数维护**：使用数组或哈希表记录0~k-1的出现情况，结合滑动窗口避免重复计算。
3. **特殊处理k=0/k>n**：直接全修改为0或无需修改，减少无效计算。
4. **区间分割**：利用修改后的k作为分割点，确保前后区间独立处理。

---

### 拓展与相似题目
1. **Mex问题**  
   - [P4137 Rmq Problem / mex](https://www.luogu.com.cn/problem/P4137)  
   - 考察区间mex查询，需结合线段树/莫队。
2. **贪心与区间划分**  
   - [P2512 [HAOI2008] 糖果传递](https://www.luogu.com.cn/problem/P2512)  
   - 环形贪心策略，类似动态调整区间。
3. **滑动窗口优化**  
   - [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)  
   - 单调队列维护极值，与动态计数思路相关。

---

### 个人心得摘录
- **QianRan_GG**提到“修改为k最优，因为含k的子串mex必不为k”，强调了贪心选择的正确性证明。
- **zjc5**通过标记数组避免重复清空，体现“空间换时间”的优化思想。
- **GeorgeAAAADHD**在调试中发现“直接fill数组会导致TLE”，改用指针移动清空计数，反映实际编码中的性能调优经验。

---
处理用时：86.48秒
# 题目信息

# 夕阳西下几时回

## 题目背景

随着夕阳从山间落下，最后一丝余晖逐渐暗淡；美丽的晚霞，终究还是化作一片黑夜。在这番景象中，一阵又一阵的乡愁涌上心头；远离家乡的游子，就算不是病死他乡，又何时能回还？

## 题目描述

夕阳可以被视作由 $n$ 种不同颜色组成的一副图，其中第 $i$ 种的颜色为 $a_i$，满足 $a$ 是长度为 $n$ 的排列。

定义一个排列的乡愁度为：

+ 对于所有 $1\le i\le n$，记 $b_i=\gcd(a_i,a_{i+1})$。特别地，我们认为 $a_{n+1}=a_1$。
+ 排列 $a$ 的乡愁度为序列 $b$ 中**不同**元素的个数。

求是否有一个长度为 $n$，乡愁度为 $k$ 的排列 $p$。若有解，请输出任意一个排列。

## 说明/提示

**【提示】**

一个长度为 $n$ 的排列是一个满足 $1$ 到 $n$ 中的所有正整数恰好出现 $1$ 次的数组。例如，$[3,1,2]$ 是一个长度为 $3$ 的排列，而 $[5,5,1,2,3]$ 不是一个排列。

**【样例 1 解释】**

- 对于第一组数据，$b=[1,1,1,1,1,1,1]$，故 $p$ 的乡愁度为 $1$。
- 对于第二组数据，可以证明不存在这样的序列。
- 对于第三组数据，$b=[1,1,3,3,1,1,2,1,5,2,1]$，包含 $4$ 个不同的元素 — $1,2,3$ 和 $5$，故 $p$ 的乡愁度为 $4$。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（4 points）：$n\le 9$，$\sum n\le 100$。
-  Subtask 2（5 points）：$k=1$。
-  Subtask 3（13 points）：$\sum n\le 200$。
-  Subtask 4（30 points）：对于所有测试数据，保证有解。
-  Subtask 5（48 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$3\le n\le 3\times 10^5$，$1\le k\le n$，$\sum n \le 6\times 10^5$。

## 样例 #1

### 输入

```
3
7 1
6 5
11 4
```

### 输出

```
Yes
1 2 3 4 5 6 7
No
Yes
1 11 9 3 6 7 8 2 5 10 4
```

# AI分析结果



### 综合分析与结论
题目要求构造排列，使得相邻元素的gcd的不同个数为k。核心思路是确定k的最大值为⌊n/2⌋，之后通过构造倍数链生成不同的gcd值。大部分题解采用将多余数倒序排列并连接倍数链的方式实现。

### 精选题解

#### 1. 作者：Ecrade_（5星）
**关键亮点**：  
- 思路清晰，直接处理多余数倒序排列，确保不影响gcd种类。  
- 代码简洁高效，时间复杂度O(n)，无冗余结构。  
- 构造倍数链时高效遍历，确保正确性。  

**核心代码**：  
```cpp
printf("Yes\n1 ");
for (ll i = n; i >= 2*k+1; --i) printf("%lld ",i);
for (ll i = 1; i <= 2*k; i += 2) 
    for (ll j = max(2ll, i); j <= 2*k; j *= 2) 
        printf("%lld ", j);
```
**实现思路**：  
- 输出1后，将n到2k+1的数倒序排列，确保它们的gcd均为1。  
- 遍历每个奇数的倍数链，生成连续的gcd值，贡献k个不同数。

#### 2. 作者：Xy_top（4星）
**关键亮点**：  
- 利用前向星建图，DFS遍历链，思路直观。  
- 显式处理链的连接，避免重复访问。  

**核心代码**：  
```cpp
void dfs(int x) {
    vis[x] = tim;
    printf("%d ", x);
    for (int i = pre[x]; i; i = a[i].next)
        if (vis[a[i].to] != tim) dfs(a[i].to);
}
```
**实现思路**：  
- 为每个数i和2i建边，通过DFS生成链，确保每个链贡献不同的gcd值。

#### 3. 作者：Hoks（4星）
**关键亮点**：  
- 使用map标记已访问数，代码简洁易懂。  
- 逐步生成链，确保达到k后处理剩余数。  

**核心代码**：  
```cpp
map<int,int>mp;
for (int i=1; cs!=k; i++) {
    if (mp[i]) continue;
    while (j <= n && cs != k) {
        mp[j] = 1; cs++;
        j *= 2;
    }
}
```
**实现思路**：  
- 标记已访问数，生成链直到达到k个不同gcd，之后顺序输出剩余数。

### 最优思路总结
1. **确定k的上界**：当k > ⌊n/2⌋时无解。  
2. **构造多余数**：将超过2k的数倒序排列在1后，确保它们的相邻gcd为1。  
3. **生成倍数链**：按奇数的倍数链（如1→2→4→8，3→6→12等）生成，确保每个链贡献不同gcd值。

### 拓展与相似题目
1. **CF1858C**：构造排列最大化不同gcd数目。  
2. **P1291**（Shuffle）可能与排列构造相关。  
3. **P1525**（关押罪犯）涉及奇偶性构造，需类似思维。  

### 个人心得摘录
- **Ecrade_**：强调构造链的简洁性，避免复杂结构提升效率。  
- **Hoks**：使用map标记访问需注意多测时的清空方式，避免超时。  
- **Xy_top**：DFS遍历链时需注意递归深度，可能影响大n时的性能。

---
处理用时：211.77秒
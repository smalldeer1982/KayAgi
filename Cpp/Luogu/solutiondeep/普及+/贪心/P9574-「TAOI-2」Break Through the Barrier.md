# 题目信息

# 「TAOI-2」Break Through the Barrier

## 题目描述

有一个由 $\tt B$ 和 $\tt T$ 组成的字符串。

你可以进行如下操作：选择一个长度为 $4$ 的子串，其恰好等于 $\texttt{BTTB}$，并将其修改为 $\texttt{TBBT}$。你可以进行这种操作任意多次（也可以不操作）。

定义一个字符串的权值为最长的 $\texttt{T}$ 连续段长度。你需要通过如上操作使得字符串的权值尽可能大。输出这个最大值。

+ 子串的定义：一个字符串 $b$ 被称为字符串 $a$ 的子串，当且仅当可以通过删除 $a$ 开头若干个（可以是 $0$ 个，下同）字符和结尾若干个字符得到 $b$。
+ $\texttt{T}$ 连续段的定义：一个原字符串的仅由 $\texttt{T}$ 构成的子串。

## 说明/提示

**本题采用捆绑测试。**

记 $\sum n$ 为所有数据中的 $n$ 的和。

+ Subtask 0（5 pts）：$n \leq 7$。
+ Subtask 1（20 pts）：$T \leq 10$，$n \leq 10$。
+ Subtask 2（25 pts）：$\sum n \leq 5000$。
+ Subtask 3（5 pts）：保证给定的字符串无法进行任何操作。
+ Subtask 4（45 pts）：无特殊限制。

对于所有数据，$1 \leq T \leq 10^3$，$1 \leq n \leq 10^5$，$1 \leq \sum n \leq 5\times 10^5$，字符串只包含字符 `B` 和 `T`。

## 样例 #1

### 输入

```
6
3
TTT
4
BTTB
5
TBBTT
6
BTBTBB
7
BTTBTTB
17
TTBTBTTBTBTTTBTTB
```

### 输出

```
3
2
2
1
3
5
```

# AI分析结果



### 综合分析与结论
该题核心在于通过操作传递性扩展连续T段。各解法主要围绕以下思路展开：
1. **传递性标记**：识别可连续操作的BTTB结构，预处理左右可扩展位置
2. **贪心+预处理**：对每个T段独立判断左右能否扩展
3. **DP状态转移**：记录每个位置是否可通过操作产生T
4. **边界剪枝**：通过数学推导排除无效情况

最优解法的共同特征：线性复杂度预处理扩展可能性，遍历时快速查询标记

---

### 高评分题解推荐

#### 1. EdenSky（★★★★★）
**核心亮点**：独创性提出"传递性"概念，采用双向标记预处理。通过指针跳跃高效标记可扩展区间，代码实现巧妙。
```cpp
// 标记传递核心代码
while(r<=n){
    if(c[l]=='B'&&c[l+1]=='T'&&c[l+2]=='T'&&c[l+3]=='B'){
        ri[r]++; le[l]++; // 标记可扩展位置
        while(c[r+1]=='T'&&c[r+2]=='B') r+=2,ri[r]++;
        while(c[l-1]=='T'&&c[l-2]=='B') l-=2,le[l]++;
    }
}
```

#### 2. dino（★★★★☆）
**核心亮点**：DP预处理左右扩展可能性，思路简洁清晰。利用两个状态数组分别处理左右方向。
```cpp
// DP预处理核心
for(int i=2; i<=n; i++){
    if(s[i]!=s[i-1]){ // 当前为TB或BT结构
        ltb[i] = (s[i]=='T') ? ltb[i-2] : 1;
        lbt[i] = (s[i]=='B') ? lbt[i-2] : 1;
    }
}
```

#### 3. light_searcher（★★★★☆）
**关键优化**：通过剪枝排除无效短段，预处理时检查左右链式结构。时间复杂度优化至O(n)。
```cpp
// 剪枝优化片段
for(int i=0;i<g.size();i++){
    int l=g[i].first, r=g[i].second;
    if(l==r) continue; // 关键剪枝
    ans=max(ans, r-l+1+search_l(l-1)+search_r(r+1));
}
```

---

### 最优思路总结
**关键技巧**：预处理可扩展标记 + 双指针遍历
1. **传递性标记**：通过识别BTTB核心结构，向左右扩展标记可操作区间
2. **状态压缩**：使用左右标记数组记录每个位置的可扩展性
3. **贪心验证**：对每个连续T段检查两侧标记，快速计算最大可能长度

**实现要点**：
- 用双指针扫描BTTB结构并进行链式扩展
- 独立维护左右扩展标记数组
- 遍历原始T段时直接查询标记数组

---

### 相似题目推荐
1. [P1156 垃圾陷阱](https://www.luogu.com.cn/problem/P1156)  
   **考查点**：状态转移与贪心决策
2. [P1095 守望者的逃离](https://www.luogu.com.cn/problem/P1095)  
   **考查点**：多种操作方式的动态规划
3. [P3147 USACO16OPEN 262144](https://www.luogu.com.cn/problem/P3147)  
   **考查点**：链式合并的预处理与标记

---

### 调试心得摘录
**int08**：  
> "赛时T1调太久了，这题也就少了点时间了，但还是做出来了。出题人是大笨蛋，现在突然发现官方题解不在题解区。"  
**总结**：时间分配与冷静分析的重要性

**QianRan_GG**：  
> "警钟长鸣。为什么辣么简单的暴力题要切两个半小时呢？因为我一直往DP和暴搜上考虑，浪费了两个小时。"  
**教训**：先尝试基础思路，避免过度设计

**Defy_HeavenS**：  
> "注意贴到两边的T串不能往中间传！"  
**关键点**：边界条件的特殊处理常是解题突破口

---
处理用时：58.51秒
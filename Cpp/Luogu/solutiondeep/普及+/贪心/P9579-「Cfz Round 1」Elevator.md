# 题目信息

# 「Cfz Round 1」Elevator

## 题目背景

电梯是一个可以让人充分思考的空间。

## 题目描述

给定两个长度为 $n$ 的数组 $a,b$。我们称序列 $p$ 是满足条件的，设 $p$ 的长度为 $m$，当且仅当：

- $p_1=1$；  
- 对于所有的 $1\le i<m$，都有 $|p_i-p_{i+1}|=1$；  
- 对于所有的 $1\le k\le n$，都存在一个有序数对 $(i,j)$，满足 $1 \le i < j \le m$ 且 $p_i=a_k$，$p_j=b_k$。

你需要输出所有满足条件的序列 $p$ 中，$p$ 的长度的最小值。

## 说明/提示

#### 【样例解释 #1】

序列 $p$ 的长度的最小值为 $7$，此时的序列 $p$ 为 $\{1,2,3,2,3,4,5\}$。

#### 【数据范围】

对于所有数据，$1 \le n \le 5\times10^5$，$1 \le a_i,b_i \le 10^9$，保证 $a_i \neq b_i$。

**本题采用捆绑测试。**

|子任务编号|分值|$n \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1$|$9$|$1$|无|
|$2$|$9$|$5\times10^5$|保证 $a_i < b_i$|
|$3$|$21$|$5\times10^5$|数据随机生成|
|$4$|$27$|$2000$|无|
|$5$|$34$|$5\times10^5$|无|

## 样例 #1

### 输入

```
2
3 2
2 5```

### 输出

```
7```

## 样例 #2

### 输入

```
4
4 7
10 8
9 11
4 2```

### 输出

```
18```

# AI分析结果



### 综合分析与结论
题目核心是构造满足条件的电梯序列，关键在于处理下降区间（a_i > b_i）。各题解普遍采用以下思路：
1. **分离处理**：上升区间（a_i < b_i）自动满足，只需处理下降区间。
2. **区间合并**：合并相交或包含的下降区间以减少冗余路径。
3. **贪心策略**：按右端点排序，枚举分界点，前部区间插入折返，后部区间从最大值处下降。
4. **代价计算**：比较两种插入方式的代价，取最小值。

---

### 高星题解推荐

#### 1. 题解作者：Komomo（★★★★★）
**关键亮点**：
- 详细图解辅助理解区间合并与插入策略。
- 通过预处理合并区间，确保无交叠，降低计算复杂度。
- 清晰的前缀和优化思路，枚举分界点计算最小总长度。

**代码核心思路**：
```cpp
sort(p + 1, p + L + 1, cmp);
// 合并相交或包含的区间
for (int i = 2; i <= tmp; i++) {
    if (r[L].r <= p[i].r && p[i].l <= r[L].l) continue;
    if (r[L].l >= p[i].r && p[i].r >= r[L].r) r[L].l = p[i].l; 
    else r[++L] = p[i];
}
// 计算前缀和与最优解
int del = 0, sum = 0;
for (int i = 1; i <= L; i++) {
    sum += 2 * (r[i].l - r[i].r);
    del = min((lo - r[i + 1].r) + sum, del);
}
cout << ans + del;
```

#### 2. 题解作者：qzhwlzy（★★★★☆）
**关键亮点**：
- 简洁的区间合并与排序实现。
- 直接按右端点排序后计算前缀和，代码短小精悍。
- 通过预处理减少后续计算量。

**代码核心思路**：
```cpp
sort(b + 1, b + 1 + ccnt, cmpl);
// 合并区间并排序
for (int i = 1; i <= ccnt; i = pos + 1) {
    pos = i;
    while (pos < ccnt && b[pos + 1].l <= b[i].r) pos++, b[i].r = max(b[i].r, b[pos].r);
    a[++cnt] = {b[i].r, b[i].l};
}
sort(a + 1, a + 1 + cnt, cmpr);
// 枚举分界点
ans = res = 2 * mmax - a[1].r;
for (int i = 1; i <= cnt; i++) {
    res = res - (a[i + 1].r - a[i].r) + (a[i].l - a[i].r) * 2;
    ans = min(ans, res);
}
```

#### 3. 题解作者：Coffee_zzz（★★★★☆）
**关键亮点**：
- 引入堆合并相交区间，实现高效合并。
- 通过后缀处理优化最终答案。

**代码核心思路**：
```cpp
sort(p + 1, p + L + 1, cmp);
priority_queue<int> q;
// 堆合并区间
for (int i = 1; i <= tmp; i++) {
    if (q.empty()) q.push(i);
    else {
        while (!q.empty() && a[q.top()].x >= a[i].y) {
            a[i].y = min(a[i].y, a[q.top()].y);
            q.pop();
        }
        q.push(i);
    }
}
// 处理合并后的区间
ans = min(ans, maxn + sum);
```

---

### 最优关键思路总结
1. **区间合并**：将相交或包含的下降区间合并，减少重复路径计算。
2. **排序策略**：按右端点从小到大排序，确保分界点枚举的高效性。
3. **代价优化**：通过前缀和计算插入折返的代价，结合后缀的下降处理，动态取最小值。

---

### 推荐相似题目
1. **P1880 [NOI1995] 石子合并**（区间合并与动态规划）
2. **P1803 凌乱的yyy / 线段覆盖**（贪心排序与活动选择）
3. **P5019 [NOIP2018 提高组] 铺设道路**（贪心策略处理区间覆盖）

---

### 个人心得摘录
- **Xy_top**：提到“口胡一分钟，代码十小时”，强调思路与实现的差距，需多次调试。
- **One_JuRuo**：初始代码未处理区间重叠导致WA，最终通过合并优化AC，体现区间处理的重要性。

---
处理用时：135.08秒
# 题目信息

# 「KDOI-06-J」贡献系统

## 题目描述

洛谷贡献系统上线了！

现在有 $n$ 个人即将参加一场洛谷月赛，每个人的等级分**互不相同**。第 $i$ 个人的等级分是 $r_i$，贡献值是 $c_i$。

假设第 $i$ 个人的等级分在这 $n$ 个人中的排名是 $a_i$（排名按等级分从大到小排序），且在月赛中的排名是 $b_i$，没有两个人的排名相同。也就是说，$a$ 和 $b$ 都是 $1$ 到 $n$ 的排列。比赛结束后，每个人都会执行以下操作：

+ 若 $a_i=b_i$，则第 $i$ 个人的等级分不会发生任何变化，因此第 $i$ 个人不会进行任何操作；
+ 若 $a_i>b_i$，则第 $i$ 个人的等级分会上升，因此第 $i$ 个人会给出题人点赞，导致出题人的贡献值上升 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值下降）；
+ 若 $a_i<b_i$，则第 $i$ 个人的等级分会下降，因此第 $i$ 个人会给出题人点踩，导致出题人的贡献值下降 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值上升）。

作为这场月赛唯一的出题人，初始时你的贡献值为 $0$。你想知道，对于所有可能的排列 $b$（显然，排列 $a$ 在比赛前已经被确定），在比赛结束后你的贡献值最大是多少。

## 说明/提示

**【样例解释 #1】**

对于第一组测试数据，设五个人按输入顺序分别为 A，B，C，D，E，则当月赛中的排名顺序为 ABECD 时贡献值最大，为 $0+0-(-50)-(-22)+208=280$。可以证明，这是唯一能使贡献值达到最大的排名顺序。

对于第二组测试数据，设八个人按输入顺序分别为 A，B，C，D，E，F，G，H，则当月赛中的排名顺序为 ABCDEGFH 时可以使贡献值达到最大值 $1$，注意此时有多种可能的使贡献值最大的排名顺序。

**【样例 #2】**

见选手目录下的 `contrib/contrib2.in` 与 `contrib/contrib2.ans`。

**【样例 #3】**

见选手目录下的 `contrib/contrib3.in` 与 `contrib/contrib3.ans`。



***

**【数据范围】**

对于所有数据保证：$1\le T\le 5$，$1\le n\le 2\times 10^5$，$0\le r_i\le 10^9$，$-10^9\le c_i\le 10^9$，且对于任意 $1\le i<n$，$r_i>r_{i+1}$。

| 测试点编号  |    $n\le $     | 特殊限制 |
| :---------: | :------------: | :------: |
|  $1\sim3$   |      $8$       |    无    |
|     $4$     |     $100$      |   ABC    |
|     $5$     |     $100$      |    C     |
|  $6\sim 7$  |     $100$      |    无    |
|  $8\sim 9$  | $5\times 10^3$ |    AB    |
| $10\sim 11$ | $5\times 10^3$ |    C     |
| $12\sim 14$ | $5\times 10^3$ |    无    |
|    $15$     | $2\times10^5$  |    AB    |
| $16\sim 18$ | $2\times10^5$  |    B     |
| $19\sim 21$ | $2\times10^5$  |    C     |
| $22\sim 25$ | $2\times 10^5$ |    无    |

+ 特殊性质 A：对于任意 $1\le i<n$，保证 $c_i=c_{i+1}$；
+ 特殊性质 B：对于任意 $1\le i<n$，保证 $c_i\le c_{i+1}$；
+ 特殊性质 C：对于任意 $1\le i\le n$，保证 $c_i\ge 0$。

## 样例 #1

### 输入

```
3
5
3816 3738 3726 3621 3582
111 109 -50 -22 208
8
8 7 6 5 4 3 2 1
128 1 0 0 0 0 1 0
10
10 9 8 7 6 5 4 3 2 1
1 1 4 5 1 4 1 9 1 9
```

### 输出

```
280
1
34
```

# AI分析结果



### 综合分析与结论
该题本质上是构造排列使贡献最大化，难点在于处理正负贡献的相互制约。各题解核心思路为：将序列划分为三段（全正/混合/全负），分别处理最优贡献。中间段贡献绝对值之和，首尾段通过前缀和优化寻找最优断点。时间复杂度均为O(n)，空间O(1)。

---

### 精选题解与亮点

#### 1. zjpwdyf（⭐⭐⭐⭐⭐）
**核心亮点**：
- 明确的三段式划分逻辑
- 前缀和优化快速计算区间贡献
- 代码简洁高效（仅30行）
**关键代码**：
```cpp
for(int lft=1;c[lft]>0&&lft<=n;lft++); // 找第一个非正数
for(int rgt=n;c[rgt]<0&&rgt>=1;rgt--); // 找最后一个非负数
ans = 首段贡献 + 中段绝对值 + 尾段贡献
```

#### 2. 引领天下（⭐⭐⭐⭐）
**核心亮点**：
- 动态规划思想处理前缀最大值
- 显式处理混合段的绝对值贡献
- 清晰变量命名增强可读性
**关键代码片段**：
```cpp
while(l<=n&&a[l]>0) l++; // 找第一个非正数
while(r>=1&&a[r]<=0) r--; // 找最后一个非负数
ans += 前缀max(后缀和 - c[i]) + 后缀max(前缀和 + c[i])
```

#### 3. ダ月（⭐⭐⭐⭐）
**独特贡献**：
- 提供暴力到正解的思维演进
- 线段树优化解法拓展思路
- 包含错误解法的警示作用
**关键思路**：
```cpp
线段树维护区间最大值，动态更新：
for(i=1~n)
   ans = max(左区间贡献 + 当前贡献)
   更新左区间贡献
```

---

### 最优策略总结
1. **三段式划分**：将序列分为[全正][混合][全负]三个区间
2. **贪心断点选择**：在首段枚举i作为牺牲点，计算`sum[i+1..L]-c[i]`最大值
3. **前缀和优化**：预处理绝对值前缀和快速计算区间贡献
4. **对称处理**：首段与尾段采用镜像处理逻辑

---

### 举一反三
1. **类似分块处理**：[P2879 区间调整](https://www.luogu.com.cn/problem/P2879)
2. **前缀和极值**：[P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
3. **排列贡献优化**：[P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)

---

### 调试心得摘录
1. **zjpwdyf**："注意c[i]可能为负，计算首段贡献时要取max(0)"
2. **引领天下**："混合段必须包含至少一个正负数，否则会错误累加空区间"
3. **ダ月**："线段树解法在n=2e5时MLE，改用滚动变量优化"

---

### 核心代码实现
以zjpwdyf解法为例：
```cpp
int main() {
    while(T--) {
        // 读入数据略
        int l = 1, r = n;
        while(c[l] > 0) l++; // 找第一个非正
        while(c[r] < 0) r--; // 找最后一个非负
        
        // 计算首段最大贡献
        ll ans1 = 0, sum = 0;
        for(int i = l-1; i >= 1; i--) {
            sum += c[i+1];
            ans1 = max(ans1, sum - c[i]);
        }
        
        // 计算尾段最大贡献
        ll ans2 = 0; sum = 0;
        for(int i = r+1; i <= n; i++) {
            sum += -c[i-1];
            ans2 = max(ans2, sum + c[i]);
        }
        
        // 输出总和
        cout << ans1 + ans2 + (前缀和[r] - 前缀和[l-1]) << endl;
    }
}
```

---
处理用时：43.53秒
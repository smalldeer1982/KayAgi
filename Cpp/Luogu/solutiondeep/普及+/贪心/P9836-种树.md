# 题目信息

# 种树

## 题目背景

小 Rf 不是很喜欢种花，但是他喜欢种树。

## 题目描述

路边有 $n$ 棵树，每棵树的 **高度** 均为正整数，记作 $p_1, p_2 \dots p_n$。

定义一棵树的 **宽度** 为它高度的正因数个数，这些树能覆盖的距离为它们宽度的乘积，你想请你的朋友们来乘凉，但你发现这些树能覆盖的距离不够多。

于是你买了总量为 $w$ 单位的神奇化肥。你可以施若干次肥，每次你可以使用 $k$ 单位化肥（**要求 $k$ 必须为当前化肥量的正因数**），让任意一棵树的高度乘上 $k$，同时你剩余的化肥量也会除以 $k$。每次施肥的树可任意选择，且每次施肥选择的树不需相同。

你需要最大化这些树所能覆盖的距离，并输出这个最大距离。答案对 $998244353$ 取模。

## 说明/提示

**【样例 1 解释】**

+ 第一次施肥，向第一棵树施 $15$ 单位的肥，使其高度变成 $120$，剩余 $4$ 单位的化肥。
+ 第二次施肥，向第二棵树施 $4$ 单位的肥，使其高度变成 $972$，剩余 $1$ 单位的化肥。
+ 这时候，三棵树的宽度分别为 $16, 18, 8$，所能覆盖的距离为 $2304$，为最优解。

---

**【样例 2】**

见附件下的 $\texttt{plant/plant2.in}$ 与 $\texttt{plant/plant2.ans}$。

---

**【样例 3】**

见附件下的 $\texttt{plant/plant3.in}$ 与 $\texttt{plant/plant3.ans}$。

---

**【数据范围】**

| 测试点编号 | $n \leq$ | $p_i$ | $w$ | 单点分值 |
| :--------: | :------: | :---: | :---: | :------: |
| $1 \sim 5$ | $10^4$ | $=1$ | $=1$ | $1$ |
| $6 \sim 10$ | $10^4$ | $\leq 10^4$ | $=1$ | $3$ |
| $11 \sim 15$ | $1$ | $\leq 10^4$ | $\leq 10^4$ | $3$ |
| $16 \sim 20$ | $5$ | $\leq 10^4$ | $\leq 10^4$ | $6$ |
| $21 \sim 25$ | $10^4$ | $\leq 10^4$ | $\leq 10^4$ | $7$ |

对于 $100 \%$ 的数据，保证 $1 \leq n \leq 10^4$，$1 \leq p_i \leq 10^4$，$1 \leq w \leq 10^4$。

## 样例 #1

### 输入

```
3 60
8 243 250```

### 输出

```
2304```

# AI分析结果



### 综合分析与结论
题目核心在于将化肥的质因数分配至各树，以最大化因数个数的乘积。各题解均采用质因数分解+贪心策略：将每个质因数优先分配给当前指数最小的树。关键难点在于高效维护最小值，常用优先队列或桶排序实现。

---

### 精选题解与亮点

#### 1. 樱雪喵（5星）
**关键亮点**：  
- 独立处理每个质因数，建立优先队列维护指数，逻辑清晰。  
- 代码结构模块化，分解质因数与贪心分配分离，可读性强。  
- 使用优先队列保证每次操作取最小值的效率。

**核心代码**：  
```cpp
void solve(int x, int sum) {
    priority_queue<int, vector<int>, greater<int>> q; // 小根堆维护指数
    for (int i = 1; i <= n; i++) {
        int cnt = 1; // 初始化为1（指数+1）
        while (a[i] % x == 0) cnt++, a[i] /= x;
        q.push(cnt);
    }
    while (sum--) { // 分配当前质因数的所有次数
        int t = q.top(); q.pop();
        q.push(t + 1);
    }
    // 计算结果时直接累乘队列中所有元素
    for (int i = 1; i <= n; i++) 
        ans = ans * q.top() % mod, q.pop();
}
```

#### 2. 佬头（4星）
**关键亮点**：  
- 预处理每个质因数的小根堆，避免重复分解。  
- 直接操作质因数分解后的指数数组，空间效率高。  
- 代码中处理质因数的逻辑紧凑，适合理解底层原理。

**个人心得**：  
题解提到“注意初始未出现的质因数需视为指数0”，通过优先队列初始化为0处理，避免了遗漏。

---

### 关键思路总结
1. **质因数独立处理**：将化肥分解为质因数后，每个质因数的分配相互独立，极大简化问题。  
2. **贪心策略**：每次将质因数分配给当前该质数指数最小的树，可用优先队列或桶排序维护最小值。  
3. **因数个数公式**：利用质因数指数+1的乘积计算因数个数，动态更新时只需调整单个因子。

---

### 拓展与举一反三
- **同类型题**：  
  1. [P1072 Hankson的趣味题](https://www.luogu.com.cn/problem/P1072)（质因数分解与因数性质）  
  2. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)（动态规划与最优分配）  
  3. [P1445 樱花](https://www.luogu.com.cn/problem/P1445)（质因数分解与因数数量关系）  

- **调试经验**：  
  多篇题解提到需注意未出现的质因数初始化为0（如樱雪喵代码中的`cnt`初始化为1对应指数0），否则会导致错误分配。

---
处理用时：55.25秒
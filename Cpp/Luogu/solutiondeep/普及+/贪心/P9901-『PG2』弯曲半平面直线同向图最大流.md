# 题目信息

# 『PG2』弯曲半平面直线同向图最大流

## 题目描述

若能将有向图 $G=(V,E)$ 画在平面上，使得点在一条直线上，任意两条边（可以为弯曲的弧线）仅在重合顶点处相交，且边上的所有点都在直线同侧，且每条边的起点到终点的射线的方向相同，则称 $G$ 是弯曲半平面直线同向图。对于一个弯曲半平面直线同向图给定 $n$ 个点，$m$ 条有向边，给定每条边的容量，求从点 $s$ 到点 $t$ 的最大流。

## 说明/提示

无重边自环。

对于 $30\%$ 的数据 $n\leq 10^3$。

对于 $70\%$ 的数据 $n\leq 10^5$。

对于 $100\%$ 的数据 $2\leq n\leq 10^6$，$1\leq m\leq \min\{2\times 10^9,\dfrac{n(n-1)}{2}\}$，$1\leq c\leq 10^{12}$，$s\neq t$。

### 样例解释 1
![](https://cdn.luogu.com.cn/upload/image_hosting/9qletk0m.png)

## 样例 #1

### 输入

```
5 7 1 5
1 2 1
2 3 1
3 4 1
4 5 1
2 4 1
1 4 1
1 5 1```

### 输出

```
2```

# AI分析结果



### 综合分析与结论
题目本质是在具有特定拓扑性质的DAG上求最大流。各题解核心思路为利用拓扑序的单调性，通过贪心或最小割转化实现O(n)时间复杂度。传统最大流算法不适用，需抓住图结构的特殊性。

---

### 精选题解列表

#### 1. 作者：qczrz6v4nhp6u ⭐⭐⭐⭐⭐
**关键亮点**：  
- 创新性将最大流转化为最小割问题  
- 发现割集必为前缀+后缀形式，利用差分数组统计边权和  
- 时间复杂度O(n)，代码简洁高效  

**个人心得**：  
"见过了平面图相关题目后，发现转换思路用最小割更高效"  

**核心代码**：  
```cpp
// 差分统计覆盖区间的边权和
for(int i=1;i<=m;i++){
    int u=e[i].u,v=e[i].v;ll w=e[i].w;
    if(ck[u]&&ck[v])
        sum[dfn2[u]]+=w,sum[dfn2[v]]-=w;
}
// 求最小割
ll ans=numeric_limits<ll>::max();
for(int i=dfn2[s];i<dfn2[t];i++)
    ans=min(ans,sum[i]+=sum[i-1]);
```

---

#### 2. 作者：phigy ⭐⭐⭐⭐⭐  
**关键亮点**：  
- 官方题解，拓扑序桶排序避免显式排序  
- 反向预处理边实现O(n)遍历  
- 代码结构清晰，易理解  

**核心代码**：  
```cpp
// 预处理拓扑序并按拓扑序存储边
for(auto [u, v, c]: edges)
    buc[id[v]].emplace_back(id[u], c);
// 逆序处理边
for(int i = n; i >= 1; i--)
    for(auto [u, c]: buc[i]) 
        to[u].emplace_back(i, c);
```

---

#### 3. 作者：xixisuper ⭐⭐⭐⭐  
**关键亮点**：  
- 两次DFS预处理有效节点，减少无效计算  
- 重构邻接表优化遍历顺序  
- 详细讨论常数优化技巧  

**核心技巧**：  
- 快读、寄存器变量、避免STL容器  
- 三次邻接表分别存原图、反图、处理后的图  

---

### 最优思路总结
1. **拓扑序单调性**：所有有效边的拓扑序满足严格单调，可用贪心顺序处理  
2. **最小割转化**：割集必为连续区间，差分统计边权和  
3. **桶排序优化**：按拓扑序逆序存储边，避免显式排序  

---

### 相似题目推荐
1. [P2763 试题库问题](https://www.luogu.com.cn/problem/P2763) - DAG上的流量分配  
2. [P4001 [ICPC-Beijing 2006] 狼抓兔子](https://www.luogu.com.cn/problem/P4001) - 平面图最小割应用  
3. [P4313 文理分科](https://www.luogu.com.cn/problem/P4313) - 最小割模型构建  

---

### 关键实现代码片段
**qczrz6v4nhp6u的最小割实现**：  
```cpp
// 预处理有效节点的拓扑序
dfs1(s); dfs2(t); 
// 差分统计边权
for(int i=1;i<=m;i++){
    if(节点u,v均在有效路径上)
        sum[拓扑序起点] += w, sum[拓扑序终点] -= w;
}
// 求最小割点
ll ans = 遍历差分数组前缀和的最小值;
```

**phigy的拓扑序处理**：  
```cpp
// 拓扑排序后逆序存边
for(int i = n; i >= 1; i--) {
    for(auto [u, c]: buc[i]) // buc存储按终点拓扑序的边
        to[u].emplace_back(i, c); // 按起点拓扑序存入
}
```

---
处理用时：66.99秒
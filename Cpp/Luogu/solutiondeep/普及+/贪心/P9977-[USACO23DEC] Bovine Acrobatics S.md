# 题目信息

# [USACO23DEC] Bovine Acrobatics S

## 题目描述

Farmer John 决定让他的奶牛表演杂技！首先，FJ 为他的奶牛称重，发现她们有 $N$（$1\le N\le 2\times 10^5$）个不同的体重。具体来说，对于全部的 $i\in [1,N]$，有 $a_i$ 只奶牛的体重为 $w_i$ 单位（$1\le a_i\le 10^9, 1\le w_i\le 10^9$）。

他最出名的节目需要奶牛叠成**平衡的奶牛塔**。一座**奶牛塔**是一些奶牛，每只奶牛站在下一只奶牛身上。一座奶牛塔是**平衡的**，当且仅当每一只被踩着的奶牛，都比**直接**踩在它身上的那只奶牛重至少 $K$（$1\le K\le 10^9$）单位。每只奶牛都可以成为奶牛塔的一部分。

如果 FJ 想要创造最多 $M$（$1 \le M \le 10^9$）座奶牛塔，最多有多少只奶牛可以成为奶牛塔的一部分？

## 说明/提示

### 样例解释 1

FJ 可以用体重为 $5,7,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $5,7$ 的奶牛创造另一座。

### 样例解释 2

FJ 可以用体重为 $5,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $7$ 的一只奶牛创造另一座。或者，他可以用体重为 $5,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $5$ 的一只奶牛创造另一座。

### 测试点性质

- 测试点 $3-5$ 满足 $M \le 5000$ 且奶牛的总数不超过 $5000$。
- 测试点 $6-11$ 满足奶牛的总数不超过 $2\cdot 10^5$。
- 测试点 $12-17$ 没有额外限制。


## 样例 #1

### 输入

```
3 5 2
9 4
7 6
5 5```

### 输出

```
14```

## 样例 #2

### 输入

```
3 5 3
5 5
7 6
9 4```

### 输出

```
9```

# AI分析结果



### 综合分析与结论
该题的核心在于通过贪心策略最大化塔的利用率，结合排序与高效数据结构维护可用塔顶。各题解主要围绕以下核心思路展开：
1. **排序预处理**：按奶牛体重排序（从轻到重或从重到轻）
2. **动态维护可用塔数**：通过双指针、优先队列或单调队列追踪可放置当前奶牛的塔顶
3. **批量处理同类项**：将相同重量层的塔顶合并处理以优化时间复杂度

最优解法时间复杂度为 O(n log n)，主要瓶颈在排序，后续处理为线性或近似线性。

---

### 精选题解列表
#### 1. 作者：Little_x_starTYJ（⭐⭐⭐⭐⭐）
**核心亮点**：
- 双指针维护可用塔数的设计极为精妙
- 代码简洁高效（仅用数组和单循环）
- 通过 ans 数组记录每层使用量，避免重复计算
**关键代码**：
```c
for (int i = 1; i <= n; i++) {
    while (id < i && c[i].b - c[id].b >= k)
        m += ans[id++]; // 回收过期塔顶
    ans[i] = min(m, c[i].a); 
    m -= ans[i]; // 更新可用塔数
    res += ans[i];
}
```

#### 2. 作者：_qingshu_（⭐⭐⭐⭐）
**核心亮点**：
- 稳定排序保证相同重量处理顺序
- 使用单调队列优化空间复杂度
**调试心得**：
> "总体难在思路，代码并不复杂" —— 强调问题抽象比编码更难

#### 3. 作者：kczw（⭐⭐⭐⭐）
**核心亮点**：
- 逆向思维从轻到重处理
- 极简代码实现（仅17行）
**关键代码**：
```cpp
for(int i=1;i<=n;i++){
    while(l<=i-1&&e[i].w-e[l].w>=k) 
        m+=num[l++]; // 回收过期塔顶
    num[i]=min(m,e[i].a);
    m-=num[i];
}
```

---

### 最优思路总结
**关键技巧**：
1. **排序定向扫描**：将奶牛按体重排序后，可保证后续处理的单调性
2. **塔顶生命周期管理**：用双指针维护有效塔顶区间（当前体重 - 前塔顶 ≥ K）
3. **批量更新策略**：通过数组记录每层使用量，避免逐个塔顶操作

**同类型题目推荐**：
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（优先队列贪心）
2. [P2168 NOI2015 荷马史诗](https://www.luogu.com.cn/problem/P2168)（k叉哈夫曼树）
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)（分治+双指针思想）

---

### 特别提示
在作者_radio_的代码中，离散化处理展现了应对大数据范围的经典方法：
```cpp
// 将所有权重及权重-K离散化
for(int i=1;i<=N;i++) {
    wei[++tot] = c[i].w;
    wei[++tot] = c[i].w-K; 
}
sort(wei+1, wei+tot+1);
```
这种技巧可推广到需要处理大量间断点的区间覆盖问题。

---
处理用时：43.47秒
# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论

本题的核心是在无向无权图中，求从起点到其他所有点的最短路数量。大部分题解采用了BFS、SPFA或Dijkstra算法，并结合计数操作来解决问题。BFS由于无权图的特性，能够以O(n)的时间复杂度解决问题，而SPFA和Dijkstra则适用于更一般的情况。计数操作的核心思想是：当发现更短的路径时，更新路径数；当发现相同长度的路径时，累加路径数。

### 所选高分题解

#### 1. 作者：King丨帝御威 (5星)
**关键亮点**：
- 使用了堆优化的Dijkstra算法，确保了算法的效率和正确性。
- 详细解释了计数操作的逻辑，代码清晰且易于理解。
- 提供了完整的代码实现，且代码结构良好。

**个人心得**：
- 强调了SPFA在某些情况下会被卡死，而Dijkstra则更为稳定，适合大规模数据。

**核心代码**：
```cpp
void dijkstra()
{
    memset(dis,0x3f,sizeof(dis));
    dis[1]=0;
    priority_queue<node>q;
    js[1]=1;                            //起点到自己的最短路条数一定是1。 
    q.push((node){1,0});
    node a;
    while(!q.empty())                             //dijkstra经典套路操作。 
    {
        a=q.top();                              //用这个node类型变量提取队首元素。 
        int u=a.x,d=a.y;                       
        q.pop();
        if(d!=dis[u]) continue;                   //一个小优化。 
        for(int i=head[u];i;i=edge[i].nxt)
        {
            int v=edge[i].v;
            if(d+edge[i].w==dis[v])
              js[v]=(js[u]+js[v])%mod;             //一边计算一边模。 
            if((dis[v]>dis[u]+edge[i].w))
            {
                dis[v]=dis[u]+edge[i].w;
				js[v]=js[u];                      //找到一条更短的路径是，用它的前驱的js换它。 
                q.push((node){v,dis[v]});
            }
        }
    }
}
```

#### 2. 作者：岸芷汀兰 (4.5星)
**关键亮点**：
- 使用了BFS算法，适合无权图的特性，时间复杂度较低。
- 详细解释了如何处理重边和自环，代码逻辑清晰。
- 提供了完整的代码实现，且代码结构良好。

**核心代码**：
```cpp
void bfs(void)
{
    queue<Node>q; q.push(make(1, 0));
    memset(d, 0x3f, sizeof(d)); d[1] = 0;
    vis[1] = true;
    ans[1] = 1;
    while (q.size()) {
        int u = q.front().node, dis = q.front().dis; 
        q.pop();
        for (register int i = 0; i<int(linker[u].size()); i++) {
            if (!vis[linker[u][i]]) {
                q.push(make(linker[u][i], dis + 1)); vis[linker[u][i]] = true; d[linker[u][i]] = dis + 1; 
                ans[linker[u][i]] += ans[u]; /*重点*/ans[linker[u][i]] %= mod;
            }
            else {
                if (dis + 1 == d[linker[u][i]]) { ans[linker[u][i]] += ans[u]; /*重点*/ans[linker[u][i]] %= mod; }
            }
        }
    }
}
```

#### 3. 作者：XZYQvQ (4星)
**关键亮点**：
- 使用了SPFA算法，并详细解释了计数操作的逻辑。
- 提供了完整的代码实现，且代码结构良好。

**核心代码**：
```cpp
void SPFA(int s)
{
    memset(dis,INF,sizeof(dis));
    ans[s]=1;dis[s]=0;vis[s]=1;q.push(s);
    while(!q.empty())
    {
        int x=q.front();q.pop();vis[x]=0;
        for(int i=head[x];i;i=edge[i].nxt)
        {
            int y=edge[i].to;
            if(dis[y]>dis[x]+1)
            {
                dis[y]=dis[x]+1;
                ans[y]=ans[x];
                if(!vis[y])vis[y]=1,q.push(y);
            }
            else if(dis[y]==dis[x]+1)
            {
                ans[y]+=ans[x];
                ans[y]%=100003;
            }
        }
    }
}
```

### 最优关键思路或技巧
1. **BFS适用于无权图**：由于边权相同，BFS能够以O(n)的时间复杂度找到最短路，且无需复杂的优先队列操作。
2. **计数操作的核心**：当发现更短的路径时，更新路径数；当发现相同长度的路径时，累加路径数。
3. **Dijkstra的稳定性**：在处理大规模数据时，Dijkstra比SPFA更为稳定，适合需要高可靠性的场景。

### 可拓展之处
- **带权图的最短路计数**：可以将BFS替换为Dijkstra或SPFA，适用于边权不同的情况。
- **多源最短路计数**：可以通过多次调用BFS或Dijkstra来解决多源最短路问题。

### 推荐题目
1. [P1608 路径统计](https://www.luogu.org/problem/P1608) - 带权图的最短路计数。
2. [P1144 最短路计数](https://www.luogu.org/problem/P1144) - 无权图的最短路计数。
3. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.org/problem/P4779) - 单源最短路径的模板题。

### 个人心得总结
- **调试经历**：在处理带权图时，SPFA的计数操作容易出错，建议使用Dijkstra。
- **踩坑教训**：在无权图中，BFS是最优选择，避免使用复杂的优先队列。
- **顿悟感想**：最短路计数的核心在于路径的更新与累加，理解这一点后，代码实现会变得更加清晰。

---
处理用时：45.25秒
# 题目信息

# 宝物筛选

## 题目描述

终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。

这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。

小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为 $W$ 的采集车，洞穴里总共有 $n$ 种宝物，每种宝物的价值为 $v_i$，重量为 $w_i$，每种宝物有 $m_i$ 件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。

## 说明/提示

对于 $30\%$ 的数据，$n\leq \sum m_i\leq 10^4$，$0\le W\leq 10^3$。

对于 $100\%$ 的数据，$n\leq \sum m_i \leq 10^5$，$0\le W\leq 4\times 10^4$，$1\leq n\le 100$。

## 样例 #1

### 输入

```
4 20
3 9 3
5 9 1
9 4 2
8 1 3```

### 输出

```
47```

# AI分析结果

### 综合分析与结论

本题是一个典型的多重背包问题，核心在于如何在给定的重量限制下，选择物品以最大化价值。由于物品数量较多，直接使用朴素的多重背包算法会超时，因此需要优化。题解中主要提到了两种优化方法：**二进制优化**和**单调队列优化**。

- **二进制优化**：通过将物品数量拆分为若干个2的幂次方，将多重背包问题转化为01背包问题，从而减少物品数量，降低时间复杂度。
- **单调队列优化**：通过维护一个单调队列，优化状态转移过程，进一步减少时间复杂度。

### 所选高星题解

#### 1. 作者：ezoiHQM (赞：198) - 5星
**关键亮点**：使用了单调队列优化多重背包，代码简洁且效率高，时间复杂度为O(nW)。
**个人心得**：作者提到“为什么都没有人用单调队列？”，表明单调队列优化在多重背包问题中并不常见，但效果显著。

**核心代码**：
```cpp
for(int d=0;d<v;d++){
    head=tail=0;
    k=(V-d)/v;
    for(int j=0;j<=k;j++){
        while(head<tail&&dp[d+j*v]-j*w>=q2[tail-1])
            tail--;
        q[tail]=j;
        q2[tail++]=dp[d+j*v]-j*w;
        while(head<tail&&q[head]<j-c)
            ++head;
        dp[d+j*v]=max(dp[d+j*v],q2[head]+j*w);
    }
}
```
**实现思想**：通过枚举余数d，使用单调队列维护每个余数下的最大值，优化状态转移。

#### 2. 作者：檀黎斗·神 (赞：144) - 4.5星
**关键亮点**：使用了二进制优化，将多重背包问题转化为01背包问题，代码清晰易懂，时间复杂度为O(nWlogm)。
**个人心得**：作者提到“直接写模板的话肯定会超时”，强调了优化的重要性。

**核心代码**：
```cpp
for(int j=1;j<=c;j<<=1){
    v[++cnt]=j*a;
    w[cnt]=j*b;
    c-=j;
}
if(c) v[++cnt]=a*c,w[cnt]=b*c;
```
**实现思想**：通过二进制拆分，将每个物品拆分为若干个2的幂次方，转化为01背包问题。

#### 3. 作者：FlashHu (赞：58) - 4星
**关键亮点**：详细解释了单调队列优化的原理，并提供了清晰的代码实现，时间复杂度为O(nW)。
**个人心得**：作者提到“DP优化的根本原则是去掉无用的状态、利用重复转移的状态”，强调了优化思路。

**核心代码**：
```cpp
for(int d=0;d<w;++d){
    maxk=(maxw-d)/w;lim=max(maxk-m,0);
    for(t=0,k=maxk-1;k>=lim;--k){
        now=f[k*w+d]-k*v;
        while(t&&g[t]<=now)--t;
        g[++t]=now;q[t]=k;
    }
    for(h=1,k1=maxk;~k1;--k1,--k){
        if(h<=t&&q[h]>=k1)++h;
        if(h<=t)chkmx(f[k1*w+d],g[h]+k1*v);
        if(k<0)continue;
        now=f[k*w+d]-k*v;
        while(h<=t&&g[t]<=now)--t;
        g[++t]=now;q[t]=k;
    }
}
```
**实现思想**：通过枚举余数d，使用单调队列维护每个余数下的最大值，优化状态转移。

### 最优关键思路与技巧

- **二进制优化**：将物品数量拆分为2的幂次方，转化为01背包问题，减少物品数量，降低时间复杂度。
- **单调队列优化**：通过维护单调队列，优化状态转移过程，进一步减少时间复杂度。

### 可拓展之处

- **同类型题**：多重背包问题在动态规划中非常常见，类似的题目可以通过二进制优化或单调队列优化来解决。
- **类似算法套路**：单调队列优化不仅可以用于多重背包问题，还可以用于其他需要维护区间最值的动态规划问题。

### 推荐题目

1. **P1776 宝物筛选** - 本题，多重背包问题。
2. **P1048 采药** - 01背包问题，基础动态规划。
3. **P1064 金明的预算方案** - 分组背包问题，扩展动态规划。

### 个人心得总结

- **调试经历**：多位作者提到在优化过程中遇到的超时问题，通过二进制优化或单调队列优化成功解决。
- **踩坑教训**：直接使用朴素的多重背包算法会导致超时，必须进行优化。
- **顿悟感想**：单调队列优化在多重背包问题中效果显著，但实现较为复杂，需要深入理解其原理。

---
处理用时：35.14秒
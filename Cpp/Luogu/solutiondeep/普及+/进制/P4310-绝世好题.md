# 题目信息

# 绝世好题

## 题目描述

给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i \& b_{i-1} \ne 0 $，其中 $2\leq i\leq k$， $\&$ 表示位运算取与。

## 说明/提示

对于100%的数据，$1\leq n\leq 100000$，$a_i\leq 10^9$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心在于通过位运算优化动态规划（DP）的状态转移，避免暴力枚举带来的高时间复杂度。大多数题解都采用了类似的思路：利用二进制位的特性，记录每个二进制位为1时的最长子序列长度，从而将时间复杂度从O(n²)优化到O(n log n)。以下是对题解的整理与对比：

1. **算法要点**：
   - **状态定义**：大多数题解使用`dp[i]`表示第i位为1时的最长子序列长度。
   - **转移方程**：通过枚举每个数的二进制位，更新当前位的最长长度，并用该长度更新所有相关位。
   - **优化思路**：利用位运算的特性，减少状态转移的复杂度。

2. **解决难点**：
   - **状态转移的优化**：如何避免暴力枚举，利用二进制位进行快速转移。
   - **代码实现**：如何高效地枚举二进制位并更新状态。

3. **最优思路**：
   - **位运算优化**：通过枚举每个数的二进制位，记录每个位为1时的最长子序列长度，并用该长度更新所有相关位。
   - **状态转移的简化**：将问题转化为对每个二进制位的独立处理，减少状态转移的复杂度。

### 评分较高的题解

#### 1. 作者：winxp_qwq (赞：133)
- **星级**：5星
- **关键亮点**：
  - 代码简洁，思路清晰，直接利用位运算进行状态转移。
  - 通过`dp[i]`记录每个二进制位为1时的最长子序列长度，并用该长度更新所有相关位。
- **核心代码**：
  ```cpp
  for(a=1;a<=n;a++) {
      scanf("%d",&b);
      k=1;
      for(c=0;c<=30;c++)
          if((1<<c)&b) k=max(dp[c]+1,k);
      for(c=0;c<=30;c++)
          if((1<<c)&b) dp[c]=max(dp[c],k);
      ans=max(ans,k);
  }
  ```
- **个人心得**：无

#### 2. 作者：Limerick (赞：52)
- **星级**：4.5星
- **关键亮点**：
  - 详细解释了位运算的优化思路，并通过举例说明状态转移的过程。
  - 代码结构清晰，注释详细，便于理解。
- **核心代码**：
  ```cpp
  for(int j=1;j<=n;j++) {
      unsigned int x;
      scanf("%ud",&x);
      Max=0;
      for(int i=0;(1<<i)<=x;i++) {
          if(x&(1<<i)) Max=max(Max,f[i]+1);
      }
      for(int i=0;(1<<i)<=x;i++) {
          if(x&(1<<i)) f[i]=Max;
      }
  }
  ```
- **个人心得**：无

#### 3. 作者：hzoi_liuchang (赞：11)
- **星级**：4星
- **关键亮点**：
  - 通过`f[i]`记录每个二进制位为1时的最长子序列长度，并用该长度更新所有相关位。
  - 代码简洁，思路清晰，易于理解。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;++i) {
      int now=1;
      for(int j=0;j<=30;j++) {
          if(a[i]&(1<<j)) now=max(now,f[j]+1);
      }
      for(int j=0;j<=30;j++) {
          if(a[i]&(1<<j)) f[j]=max(f[j],now);
      }
      ans=max(ans,now);
  }
  ```
- **个人心得**：无

### 通用建议与扩展思路

1. **位运算优化**：在处理与位运算相关的问题时，可以考虑将问题转化为对每个二进制位的独立处理，从而减少状态转移的复杂度。
2. **动态规划的状态定义**：在定义状态时，可以考虑将状态与二进制位相关联，从而利用位运算的特性进行优化。
3. **代码实现技巧**：在枚举二进制位时，可以使用`1<<i`来快速判断某一位是否为1，并通过`max`函数更新状态。

### 推荐题目

1. **P4310 绝世好题**：本题，考察位运算与动态规划的结合。
2. **P1896 [SCOI2005]互不侵犯**：考察状态压缩DP，利用二进制位表示状态。
3. **P1879 [USACO06NOV]Corn Fields G**：考察状态压缩DP，利用二进制位表示状态。

### 总结

本题的核心在于通过位运算优化动态规划的状态转移，避免暴力枚举带来的高时间复杂度。最优的思路是利用二进制位的特性，记录每个位为1时的最长子序列长度，并用该长度更新所有相关位。通过这种方式，可以将时间复杂度从O(n²)优化到O(n log n)。

---
处理用时：38.19秒
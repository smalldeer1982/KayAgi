# 题目信息

# 「Wdsr-1」小铃的书

## 题目背景

本居小铃在人间之里经营着一家名为“铃奈庵”的书店。店里井井有条地堆放着很多很多书。  

一天，魔理沙来铃奈庵借书，搞得店里十分混乱，魔理沙随身携带的魔导书与铃奈庵的书籍全都混在了一起。

## 题目描述

小铃一共有 $n-1$ 本书，每本书有一个编号 $a_i$，两本书属于同一种类当且仅当两本书的编号相同。  

由于小铃平时将这些书整理得井井有条，因此在小铃的 $n-1$ 本书中，每个种类的书的数量都恰好是 $k$ 的倍数，其中 $k$ 是一给出的常数。
 
现在，魔理沙的一本编号未知的魔导书与小铃的 $n-1$ 本书混在了一起，而魔理沙只有知道魔导书的编号才能将其找回。  

由于书的数量实在太多，魔理沙找到了你来帮忙，希望聪明的你能帮她求出混入的魔导书的编号。

**注意：魔理沙的魔导书可能与小铃的某本书有着相同的编号。**

## 说明/提示

#### 样例说明

样例 $1$ 中，小铃的书的编号为 $1,2,3$，分别有 $3$ 本。因此魔导书的编号为 $5$。

样例 $2$ 中，小铃的书的编号为 $1,4,5$，分别有 $4$ 本。因此魔导书的编号为 $1$。

------------------------

#### 数据范围及约定

**本题采取捆绑测试。**

$$
\def{\arraystretch}{1.5}
\def\cuteran{https://www.luogu.com.cn/paste/iyzwht7l}
\begin{array}{|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{分值} \cr\hline
1 & 10^5 & 50 \cr\hline
2 & 10^6 & 25 \cr\hline
3 & 10^7 & 25 \cr\hline
\end{array}
$$

对于全部数据，保证 $1 \le n \le 10^7$  ，$2 \le k \le 10^3$  ，$1 \le a_i \le 10^{18}$。保证数据合法，即有且只有一本混入的魔导书。   

-----------------

#### 提示

**请注意时空限制。**

**使用 $\texttt{cin}$ / $\texttt{cout}$ 可能超时，这里给出一个快速读入模板：**

```cpp
long long qread(){
    long long w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
```

**或者使用这份模板：**

```cpp
typedef long long LL;
#define gc pa==pb&&(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++
static char buf[100000],*pa(buf),*pb(buf);
inline LL readint() {
	LL x=0;char c=gc;
	while(c<'0'||c>'9')c=gc;
	for(;c>='0'&&c<='9';c=gc)x=x*10+(c&15);
	return x;
}
```

**其中，在开启 O2 开关的前提下，前者在极限数据下的读入要 $500\texttt{ms}$，而后者需要 $300\texttt{ms}$。也就是说，你的程序至少有 $500\sim 700\texttt{ms}$ 的时间执行主要算法。**

## 样例 #1

### 输入

```
10 3
1 1 2 2 3 5 3 2 1 3```

### 输出

```
5```

## 样例 #2

### 输入

```
13 4
1 1 4 5 1 4 1 4 4 5 5 5 1```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心问题是在大量数据中找出唯一一个出现次数不为 \(k\) 的倍数的数。由于数据规模较大（\(n \leq 10^7\)），直接使用哈希表或排序等方法会超出时间和空间限制。因此，题解中普遍采用了将数拆分成若干部分（如按 \(k\) 进制或更高进制）进行统计的方法，从而降低时间和空间复杂度。

#### 最优关键思路或技巧：
1. **进制拆分法**：将每个数拆分成若干部分（如按 \(k\) 进制或更高进制），分别统计每部分的出现次数，最后通过取模运算找出多余的部分，进而拼出答案。这种方法大大减少了统计的复杂度。
2. **位运算优化**：通过位运算（如按 \(2^8\) 进制拆分）进一步优化时间和空间复杂度，避免了频繁的取模和除法运算。
3. **空间优化**：通过将数拆分成多个部分，使用多个小数组代替一个大数组，从而在空间上实现优化。

#### 可拓展之处：
- **类似问题**：在需要统计大量数据中唯一不符合某种规律的元素时，可以考虑将数据拆分成多个部分进行统计，从而降低复杂度。
- **算法套路**：进制拆分法、位运算优化、空间优化等技巧在类似问题中都可以应用。

### 推荐题目：
1. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972) - 考察统计唯一元素的问题。
2. [P3810 【模板】三维偏序](https://www.luogu.com.cn/problem/P3810) - 考察复杂数据的统计与处理。
3. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369) - 考察数据结构的优化与统计。

### 所选题解

#### 题解1：作者：wyd_forever (赞：12)
- **星级**：4.5星
- **关键亮点**：采用了将数拆分成 \(k\) 进制的方法，并通过优化空间和时间复杂度，成功解决了问题。代码简洁且思路清晰。
- **个人心得**：作者提到通过将数拆分成多个部分，优化了空间和时间复杂度，避免了直接使用哈希表或排序的弊端。

```cpp
fac[0]=1;
for(register int i=1;fac[i-1]<=lim;up=i++)
	fac[i]=fac[i-1]*k;
for(register ll x;n;--n)
{
	x=read();
	for(register int i=up;x;--i)
		if(x>=fac[i])
		{
			ans[i]+=x/fac[i];
			if(ans[i]>=k)
				ans[i]-=k;
			x%=fac[i];
		}
}
for(register int i=up;~i;--i)
	res+=ans[i]*fac[i];
```

#### 题解2：作者：minstdfx (赞：3)
- **星级**：4星
- **关键亮点**：采用了将数拆分成 \(2^8\) 进制的方法，进一步优化了时间和空间复杂度。代码简洁且易于理解。

```cpp
#include <bits/stdc++.h>
typedef unsigned uint32;
typedef unsigned long long uint64;
using namespace std;
const int Base=65536;//65536
int geshu[4][Base];
uint64 s[4];
uint64 ans,g;
int n,k;
int main()
{
	cin>>n>>k;
	for(int i=0;i<n;++i)
	{
		cin>>g;
		for(int i=0;i<4;++i)
			geshu[i][65535&g]++,g>>=16;
	}
	for(uint64 i=0;i<4;++i)
		for(uint64 j=0;j<Base;++j)
		{
			if(geshu[i][j]%k==1) ans|=j<<(i*16ull);
		}
	cout<<ans<<endl;
}
```

#### 题解3：作者：朱屹帆 (赞：2)
- **星级**：4星
- **关键亮点**：采用了将数拆分成 \(100\) 进制的方法，进一步优化了时间和空间复杂度。代码简洁且易于理解。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define INF 0x3f3f3f3f
#define endl '\n'
using namespace std;
long long read(){
	long long q=0,w=1;
	char ch=getchar();
	while(ch>'9' || ch<'0'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')q=q*10+(ch-'0'),ch=getchar();
	return q*w;
} //快读加速
long long pow(LL a,LL b){
	LL ans=1,base=a;
	if(b==0)return 1;
	while(b){
		if(b&1)ans=(ans*base);
		b=(b>>1);base=(base*base);
	}
	return ans;
} //求100的b次方
const long long N = 50+5;
const long long K = 100;
long long n,k,a;
long long s[N][K],cnt;
long long base;
int main(){
	n=read(),k=read();
	for(LL i=1;i<=n;i++){
		a=read();
		for(LL j=0;a!=0;j++){ //拆分为百进制
			if(a%K!=0)s[j][a%K]++;
			a=(a/K);base=max(base,j);
		}
	}
	for(LL i=0;i<=base;i++){
		for(LL j=0;j<=99;j++){
			s[i][j]=(s[i][j]%k); //筛选出魔导书
			if(s[i][j]!=1)continue;
			cnt+=(pow(K,i)*j); //累加
		}
	}
	cout<<cnt<<endl; //结果
	return 0;
}
```

### 通用建议与扩展思路

如果所有题解都不足4星，可以考虑以下通用建议：
1. **进制拆分法**：将数拆分成若干部分进行统计，降低复杂度。
2. **位运算优化**：通过位运算进一步优化时间和空间复杂度。
3. **空间优化**：使用多个小数组代替一个大数组，优化空间使用。

这些技巧在类似问题中都可以应用，帮助解决大规模数据的统计问题。

---
处理用时：42.96秒
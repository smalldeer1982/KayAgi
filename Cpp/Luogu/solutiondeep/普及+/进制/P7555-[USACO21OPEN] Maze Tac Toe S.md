# 题目信息

# [USACO21OPEN] Maze Tac Toe S

## 题目描述

奶牛 Bessie 喜欢玩走迷宫。她同样喜欢玩井字棋（更准确地说，奶牛版的井字棋，马上会进行介绍）。Farmer John 找到了一种全新的方式，可以使她同时玩到这两种游戏！

首先，奶牛井字棋：与在 $3 \times 3$ 棋盘内放置 `X` 和 `O` 不同，奶牛当然是在 $3 \times 3$ 棋盘内放置 `M` 和 `O`。在一方的回合内，玩家可以选择将一个 `M` 或一个 `O` 放在任意一个空格内（这是另一个与标准井字棋的不同之处，标准的井字棋中一名玩家始终放 `X` 而另一名玩家始终放 `O`）。奶牛井字棋的胜利方是首位拼出 `MOO` 的玩家，可以是同行、同列或对角线。倒着拼出也是可以的，例如一名玩家在棋盘的一行内拼出 `OOM` 也可以获胜。如同标准井字棋一样，有可能最后没有玩家取得胜利。奶牛井字棋的一次行动通常用 3 个字符表示，`Mij` 或 `Oij`，其中 $i$ 和 $j$ 在范围 $1 \ldots 3$ 之间，表示放置 `M` 或 `O` 的行与列。

为了给 Bessie 增加一些挑战，Farmer John 设计了一个由 $N \times N$ 个方格组成的正方形迷宫（$3 \leq N \leq 25$）。某些方格，包括所有的边界方格，有巨大的草堆，使得 Bessie 不能移动到这些方格。Bessie 可以沿东南西北四个方向在迷宫内的所有其他方格内自由行动。某些方格内有一张纸，上面写有奶牛井字棋的一次行动。当 Bessie 在迷宫中移动时，任何时刻她停留在这样的方格上，她都必须于迷宫中移动之时在同时进行的奶牛井字棋游戏内做出对应的行动（除非奶牛井字棋中对应的方格已经被填上了，在这种情况下她不进行行动）。在奶牛井字棋游戏内没有与她对阵的玩家，但迷宫中的某些方格可能会不利于她最终拼出 `MOO`。

如果 Bessie 在获胜之时就会立刻停止奶牛井字棋，请求出她可以通过适当的方式在迷宫中移动而完成的不同的胜利状态棋盘数量。

## 说明/提示

#### 样例说明

在这个样例中，Bessie 最终可能达成 $8$ 种胜利的棋盘状态：

```plain
O.M
.O.
MOM

O..
.O.
.OM

O.M
.O.
.OM

O..
.O.
MOM

O..
...
OOM

..M
.O.
OOM

...
.O.
OOM

...
...
OOM
```

对其中一种情况进行说明：

```plain
O..
...
OOM
```

在这里，Bessie 可以先移动到 `O11` 方格，然后移动到下方并通过 `O32`、`M33` 和 `O31`。此时游戏结束，因为她获得了胜利（例如她不能再前往位于她当前所在的 `O31` 方格北面的 `M11` 方格）。

#### 说明

供题：Brian Dean

## 样例 #1

### 输入

```
7
#####################
###O11###...###M13###
###......O22......###
###...######M22######
###BBB###M31###M11###
###...O32...M33O31###
#####################```

### 输出

```
8```

# AI分析结果

### 综合分析与结论

本题的核心难点在于如何高效地处理迷宫移动与井字棋状态的结合，尤其是井字棋状态的表示与胜利条件的判断。各题解均采用了状态压缩（三进制）来表示井字棋的棋盘状态，并通过深度优先搜索（DFS）或广度优先搜索（BFS）来遍历迷宫中的可能路径。虽然思路相似，但在实现细节、代码可读性和优化程度上存在差异。

### 所选高星题解

#### 1. 作者：tiger2005 (★★★★☆)
**关键亮点：**
- 使用三进制状态压缩，预处理所有可能的胜利状态，减少了重复计算。
- 代码结构清晰，DFS的实现简洁明了，适合初学者理解。
- 通过 `dp` 数组记录状态是否被访问过，避免了重复搜索。

**个人心得：**
- 强调了预处理的重要性，通过提前计算胜利状态，减少了搜索时的计算量。

**核心代码：**
```cpp
void dfs(int x,int y,int k){
    if(Maz[x][3*y+1]=='M' || Maz[x][3*y+1]=='O')
        k=Draw(k,Maz[x][3*y+1],Maz[x][3*y+2]-'1',Maz[x][3*y+3]-'1');
    if(dp[x][y][k]) return;
    dp[x][y][k]=true;
    if(isP[k]){
        ans+=!pd[k];
        pd[k]=true;
        return;
    }
    for(int i=0,xx,yy;i<4;i++){
        xx=x+fang[i][0],yy=y+fang[i][1];
        if(Maz[xx][3*yy+1]!='\0' && Maz[xx][3*yy+1]!='#')
            dfs(xx,yy,k);
    }
}
```
**核心思想：**
- 在DFS过程中，根据当前位置更新井字棋状态，并判断是否胜利。若胜利则记录状态，否则继续向四个方向搜索。

#### 2. 作者：打程序的咸鱼 (★★★★☆)
**关键亮点：**
- 使用 `set` 来存储胜利状态，避免了重复记录。
- 代码结构清晰，状态压缩和解压的实现较为直观。
- 通过 `beenthere` 数组记录状态是否被访问过，优化了搜索效率。

**个人心得：**
- 强调了状态压缩的必要性，并建议使用较小的进制来减少存储空间。

**核心代码：**
```cpp
void dfs(int i, int j, int b){
    if (beenthere[i][j][b]) return;
    beenthere[i][j][b] = true;
    if (board[i][j][0]=='M' || board[i][j][0]=='O') {
        int r = board[i][j][1]-'1', c = board[i][j][2]-'1', idx = r*3+c;
        int current_char = (b / pow3[idx]) % 3;
        if (current_char == 0) {
            int new_char = board[i][j][0]=='M' ? 1 : 2;
            b = (b % pow3[idx]) + new_char * pow3[idx] + (b - b % pow3[idx+1]);
            if (!beenthere[i][j][b] && test_win(b)) { answers.insert(b); return; }
            beenthere[i][j][b] = true;
        }
    }
    if (board[i-1][j][0] != '#') dfs(i-1,j,b);
    if (board[i+1][j][0] != '#') dfs(i+1,j,b);
    if (board[i][j-1][0] != '#') dfs(i,j-1,b);
    if (board[i][j+1][0] != '#') dfs(i,j+1,b);
}
```
**核心思想：**
- 在DFS过程中，根据当前位置更新井字棋状态，并判断是否胜利。若胜利则记录状态，否则继续向四个方向搜索。

### 最优关键思路与技巧
1. **状态压缩**：使用三进制表示井字棋状态，减少存储空间和计算复杂度。
2. **预处理胜利状态**：提前计算所有可能的胜利状态，减少搜索时的计算量。
3. **DFS/BFS优化**：通过记录状态是否被访问过，避免重复搜索，提高效率。

### 可拓展之处
- **类似问题**：可以应用于其他需要结合状态压缩和搜索的问题，如迷宫中的其他游戏规则或状态转移问题。
- **优化思路**：可以考虑使用双向BFS或A*算法进一步优化搜索效率。

### 推荐题目
1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - 考察DFS/BFS在矩阵中的应用。
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443) - 考察BFS在棋盘类问题中的应用。
3. [P1032 字串变换](https://www.luogu.com.cn/problem/P1032) - 考察状态压缩与搜索的结合。

### 个人心得总结
- **调试经历**：多位作者提到在实现状态压缩时遇到的困难，尤其是在三进制的转换和存储上。
- **踩坑教训**：强调了预处理的重要性，避免在搜索过程中重复计算胜利状态。
- **顿悟感想**：通过状态压缩和搜索的结合，能够高效解决复杂的迷宫与游戏规则结合的问题。

---
处理用时：38.43秒
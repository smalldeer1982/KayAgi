# 题目信息

# 「TAOI-1」Apollo

## 题目背景

Execution.

这题原来叫 `std::cout << std::fixed << std::setprecision(1) << 6.5 << '\n';`。

[被当事人删掉的图片.jpg]

**【Upd 2023/04/15 21:42】添加了一组 Hack 数据位于 Subtask 2，#13。现在所有赛时的 $\bm{50}$ 分提交理论上均只能获得 $\bm{30}$ 分。**

## 题目描述

给出 $n$ 个十进制小数 $a_1 \dots a_n$。

对于一个 **数** $a$，定义其精度 $f(a)$ 表示最小的非负整数 $k$ 使得 $10^k\times a$ 为整数；对于整数 $a$，定义 $f(a) = 0$。对于两个十进制小数 $a, b$，定义 $g(a, b)$ 为对于所有 **数** $c \in [\min(a,b), \max(a,b)]$ 的 $f(c)$ 的最小值。

对于所有 $1 \leq i \leq n$，你需要求出 $\sum\limits_{j=1}^ng(a_i, a_j)$ 的值并输出。

定义十进制小数是一个含有整数部分和小数部分的数，其小数部分不为 $0$。之所以描述得这么愚蠢是因为保证输入的每个数都有小数点，但是好像无论什么写法都会有人提出不满，真是抱歉了。~~所以还是得看看被当事人删掉的图片。所以我在这里写闲话有人看得到吗。~~

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

令 $\sum\limits_{i=1}^n f(a_i) = t$。

- Subtask 1（15 points）：$a_i \leq 10$，$n \leq 5$，$t \leq 10$。
- Subtask 2（15 points）：$a_i \leq 10$，$n \leq 100$，$t \leq 1000$。
- Subtask 3（20 points）：$n \leq 1722$。
- Subtask 4（15 points）：$a_i \leq 1$。
- Subtask 5（35 points）：无特殊限制。

对于所有数据，$0 \lt a_i \lt 10^9$，$1 \leq n \leq 10^5$，$1 \leq t \leq 3 \times 10^6$，**保证 $\bm{a_i}$ 没有后导 [$\color{black}\bm 0$](https://cdn.luogu.com.cn/upload/image_hosting/pg66fm1z.png)，不保证 $\bm{a_i}$ 互不相同**。

### 样例解释

以 $i = 1$ 为例：

+ $j = 1$：取 $c = 11.4514$，$f(c) = 4$；
+ $j = 2$：取 $c = 11.46$，$f(c) = 2$；
+ $j = 3$：取 $c = 11.2$，$f(c) = 1$；
+ $j = 4$：取 $c = 11.3$，$f(c) = 1$；
+ $j = 5$：取 $c = 11.47$，$f(c) = 2$。

故 $\sum\limits_{j=1}^n g(a_1, a_j) = 4 + 2 + 1 + 1 + 2 = 10$。对于同一个 $j$，上文给出的所有 $c$，都可能有其它的不同的 $c$ 满足 $f(c)$ 同样最小。

## 样例 #1

### 输入

```
5
11.4514
11.4778
11.1338
11.1236
11.4789```

### 输出

```
10
11
9
9
11```

## 样例 #2

### 输入

```
8
1.1145
1.114
1.1145
1.514
1.19198
1.1154
1.114
1.1145```

### 输出

```
24
21
24
10
18
22
21
24```

# AI分析结果

### 综合分析

这些题解主要围绕如何高效计算两个小数之间的 `g(a, b)` 值展开，核心思路是将小数视为字符串，利用字典树（Trie）来快速查找最长公共前缀。难点在于处理不同整数部分和小数部分的前缀关系，以及如何高效计算 `g(a, b)`。大多数题解通过字典树的结构来优化查询，部分题解还引入了哈希、二分、单调栈等技巧。

### 最优关键思路

1. **字典树（Trie）的应用**：将小数视为字符串，利用字典树快速查找最长公共前缀，从而高效计算 `g(a, b)`。
2. **分类讨论**：根据整数部分是否相同，分别处理 `g(a, b)` 的计算，整数部分不同时直接返回0，相同时再进一步处理小数部分。
3. **优化查询**：通过记录每个节点的经过次数、终点次数等信息，优化查询过程，减少重复计算。

### 题解评分与亮点

#### 题解1：作者：wloving (4星)
- **关键亮点**：详细分析了 `g(a, b)` 的计算方法，并通过字典树实现高效的查询。代码结构清晰，注释详细，易于理解。
- **个人心得**：通过字典树将问题转化为字符串的公共前缀问题，简化了复杂的计算过程。

```cpp
void insert(string s) {
  int len = s.size();
  int u = 0;
  int dot = -1;   // 小数点位置
  trie[u].num++;  // 记录字符串总数
  for (int i = 0; i < len; i++) {
    int ch = toNum[s[i]];
    if (!trie[u].son[ch]) trie[u].son[ch] = ++tot;
    u = trie[u].son[ch];
    trie[u].num++;
    if (ch == 10) dot = i;                 // 记录小数点的位置
    if (dot != -1) trie[u].dep = i - dot;  // 更新小数部分对应的位数
  }
  trie[u].end++;//记录该处结尾的数字个数
}
```

#### 题解2：作者：irris (4星)
- **关键亮点**：通过哈希和二分优化查询，进一步提高了查询效率。代码简洁，逻辑清晰。
- **个人心得**：通过排序和单调栈优化查询过程，减少了时间复杂度。

```cpp
void insert(const std::string& x) {
	++f[root].sz;
	for (int p = root, i = 0; i < x.size(); ++i) {
		++f[p = f[p].getNxt(x[i] - '0')].sz;
		if (i == x.size() - 1) ++f[p].ed;
	}
}
```

#### 题解3：作者：Lysea (4星)
- **关键亮点**：详细讨论了不同情况下的 `g(a, b)` 计算，并通过字典树实现了高效的查询。代码结构清晰，注释详细。
- **个人心得**：通过字典树的结构优化查询过程，减少了重复计算。

```cpp
void Insert(string s) {
	int u(0);
	for(int i(0);i<s.size();++i){
		flg[u]+=d;
		int val(s[i]^48);
		if(!son[u][val]) son[u][val]=++cnt;
		u=son[u][val];
	}
}
```

### 通用建议与扩展思路

1. **字典树的扩展应用**：字典树不仅适用于字符串匹配，还可以用于处理其他需要前缀匹配的问题，如IP地址匹配、单词搜索等。
2. **优化查询技巧**：在处理大规模数据时，可以通过哈希、二分、单调栈等技巧进一步优化查询过程。
3. **分类讨论思维**：在处理复杂问题时，分类讨论是一种有效的思维方式，可以帮助简化问题，提高解题效率。

### 推荐题目

1. [P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)
2. [P3879 [TJOI2010]阅读理解](https://www.luogu.com.cn/problem/P3879)
3. [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)

这些题目都涉及到字符串处理或前缀匹配，适合进一步练习字典树的应用。

---
处理用时：31.64秒
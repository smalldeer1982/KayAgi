# 题目信息

# [NOIP 2000 提高组] 方格取数

## 题目背景

NOIP 2000 提高组 T4

## 题目描述

设有 $N \times N$ 的方格图 $(N \le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:

![](https://cdn.luogu.com.cn/upload/image_hosting/0bpummja.png)

某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  
此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。


## 说明/提示

数据范围：$1\le N\le 9$。

## 样例 #1

### 输入

```
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0
```

### 输出

```
67```

# AI分析结果

### 综合分析与结论

本题解的思路主要集中在动态规划（DP）上，尤其是四维DP和三维DP的优化。大多数题解采用了四维DP的思路，通过同时处理两条路径来避免重复计算。部分题解进一步优化了空间复杂度，将四维DP降为三维DP，利用步数作为公共维度来减少状态数。此外，DFS和网络流等算法也被提及，但DP仍然是主流解法。

### 精选题解

#### 1. 作者：Azuree (赞：102)
- **星级**：★★★★★
- **关键亮点**：通过将四维DP优化为三维DP，利用步数作为公共维度，显著减少了状态数。思路清晰，代码简洁，优化程度高。
- **个人心得**：作者提到“四维数组处理起来时间复杂度太大了，所以我们要想办法把它降成三维”，体现了对问题复杂度的深刻理解和优化意识。
- **核心代码**：
```cpp
int dfs(int x,int y,int x2,int y2) {
    if (f[x][y][x2][y2]!=-1) return f[x][y][x2][y2];
    if (x==N&&y==N&&x2==N&&y2==N) return 0;
    int M=0;
    if (x<N&&x2<N) M=max(M,dfs(x+1,y,x2+1,y2)+s[x+1][y]+s[x2+1][y2]-s[x+1][y]*(x+1==x2+1&&y==y2));
    if (x<N&&y2<N) M=max(M,dfs(x+1,y,x2,y2+1)+s[x+1][y]+s[x2][y2+1]-s[x+1][y]*(x+1==x2&&y==y2+1));
    if (y<N&&x2<N) M=max(M,dfs(x,y+1,x2+1,y2)+s[x][y+1]+s[x2+1][y2]-s[x][y+1]*(x==x2+1&&y+1==y2));
    if (y<N&&y2<N) M=max(M,dfs(x,y+1,x2,y2+1)+s[x][y+1]+s[x2][y2+1]-s[x][y+1]*(x==x2&&y+1==y2+1));
    f[x][y][x2][y2]=M;
    return M;
}
```
- **核心思想**：通过DFS实现四维DP，利用剪枝避免重复计算，同时处理两条路径的移动。

#### 2. 作者：road (赞：183)
- **星级**：★★★★☆
- **关键亮点**：提供了二维DP和四维DP的对比，指出二维DP的局限性，并通过四维DP实现了全局最优解。代码实现清晰，思路明确。
- **核心代码**：
```cpp
for(int i=1;i<=n;i++) {
    for(int j=1;j<=n;j++) {
        for(int k=1;k<=n;k++) {
            for(int l=1;l<=n;l++) {
                dp[i][j][k][l]=max(max(dp[i-1][j][k-1][l],dp[i-1][j][k][l-1]),max(dp[i][j-1][k-1][l],dp[i][j-1][k][l-1]))+a[i][j]+a[k][l];
                if(i==k&&j==l) dp[i][j][k][l]-=a[i][j];
            }
        }
    }
}
```
- **核心思想**：通过四维DP同时处理两条路径，确保全局最优解，避免重复计算。

#### 3. 作者：Vct14 (赞：7)
- **星级**：★★★★☆
- **关键亮点**：通过三维DP优化了空间复杂度，利用步数作为公共维度，减少了状态数。代码简洁，思路清晰。
- **核心代码**：
```cpp
for(int i1=1; i1<=n; i1++) {
    for(int j1=1; j1<=n; j1++) {
        for(int i2=1; i2<=i1+j1-1; i2++) {
            if(i1==i2) dp[i1][j1][i2]=sc[i1][j1]+max(dp[i1][j1-1][i2-1],dp[i1-1][j1][i2]);
            else dp[i1][j1][i2]=sc[i1][j1]+sc[i2][i1+j1-i2]+max({dp[i1-1][j1][i2-1],dp[i1-1][j1][i2],dp[i1][j1-1][i2-1],dp[i1][j1-1][i2]});
        }
    }
}
```
- **核心思想**：通过三维DP同时处理两条路径，利用步数作为公共维度，减少状态数，确保全局最优解。

### 最优关键思路与技巧

1. **四维DP与三维DP的优化**：通过同时处理两条路径，避免重复计算，确保全局最优解。三维DP利用步数作为公共维度，进一步优化了空间复杂度。
2. **DFS与剪枝**：通过DFS实现四维DP，利用剪枝避免重复计算，提高算法效率。
3. **状态转移方程的设计**：通过合理设计状态转移方程，确保每条路径的最优解，同时处理重复路径的情况。

### 可拓展之处

1. **类似题目**：可以扩展到多条路径的问题，如[P1006 [NOIP2008 提高组] 传纸条](https://www.luogu.com.cn/problem/P1006)。
2. **算法套路**：类似的DP优化思路可以应用于其他路径规划问题，如网格中的最短路径、最大收益等问题。

### 推荐题目

1. [P1006 [NOIP2008 提高组] 传纸条](https://www.luogu.com.cn/problem/P1006)
2. [P2774 方格取数问题](https://www.luogu.com.cn/problem/P2774)
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)

---
处理用时：44.28秒
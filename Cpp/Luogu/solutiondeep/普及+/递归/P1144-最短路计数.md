# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论

本题的核心是求解从起点到其他所有点的最短路径数量。由于图是无权图，边权均为1，因此可以采用BFS、Dijkstra、SPFA等算法来解决。大多数题解采用了BFS或Dijkstra，部分题解还结合了记忆化搜索或拓扑排序等技巧来优化计数过程。

#### 关键思路与技巧：
1. **BFS的优势**：由于边权为1，BFS天然适合求解最短路径问题，且时间复杂度较低（O(N+M)）。
2. **计数策略**：在遍历时，若当前节点的最短路径长度等于前驱节点加1，则累加前驱节点的路径数；若发现更短的路径，则更新路径数。
3. **优化技巧**：部分题解通过记忆化搜索或拓扑排序来避免重复计算，进一步优化了计数过程。

#### 通用建议：
- **优先选择BFS**：对于无权图，BFS是最优选择，代码简洁且效率高。
- **注意边界条件**：如起点到自身的路径数为1，重边和自环的处理等。
- **模运算**：路径数可能很大，及时取模避免溢出。

### 所选高星题解

#### 1. 作者：岸芷汀兰（★★★★★）
- **关键亮点**：使用BFS进行最短路求解，并巧妙处理了重边和自环问题，代码简洁且思路清晰。
- **个人心得**：强调了BFS在无权图中的天然优势，并详细解释了计数策略。
- **核心代码**：
```cpp
void bfs() {
    queue<int> q;
    q.push(1);
    dis[1] = 0;
    ans[1] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : linker[u]) {
            if (dis[v] == INF) {
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                q.push(v);
            } else if (dis[v] == dis[u] + 1) {
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
}
```
- **实现思想**：通过BFS遍历图，更新每个节点的最短路径长度和路径数。

#### 2. 作者：King丨帝御威（★★★★☆）
- **关键亮点**：使用Dijkstra堆优化，结合计数策略，代码结构清晰，适合带权图的扩展。
- **核心代码**：
```cpp
void dijkstra() {
    priority_queue<pair<int, int>> q;
    q.push({0, 1});
    dis[1] = 0;
    ans[1] = 1;
    while (!q.empty()) {
        int u = q.top().second; q.pop();
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            if (dis[v] > dis[u] + 1) {
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                q.push({-dis[v], v});
            } else if (dis[v] == dis[u] + 1) {
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
}
```
- **实现思想**：通过Dijkstra堆优化求解最短路，并在松弛过程中更新路径数。

#### 3. 作者：XZYQvQ（★★★★☆）
- **关键亮点**：先通过SPFA求解最短路，再通过记忆化搜索统计路径数，思路清晰且具有通用性。
- **核心代码**：
```cpp
int dfs(int u) {
    if (ans[u]) return ans[u];
    for (int i = head[u]; i != -1; i = nxt[i]) {
        int v = to[i];
        if (dis[u] - 1 == dis[v]) {
            ans[u] = (ans[u] + dfs(v)) % MOD;
        }
    }
    return ans[u];
}
```
- **实现思想**：通过记忆化搜索遍历最短路图，统计路径数。

### 推荐题目
1. **P1608 路径统计**：带权图的最短路计数，适合练习Dijkstra和SPFA的扩展应用。
2. **P1144 最短路计数**：本题的扩展，适合巩固BFS和计数策略。
3. **P4779 单源最短路径（标准版）**：适合练习Dijkstra堆优化的实现。

### 个人心得摘录
- **岸芷汀兰**：强调了BFS在无权图中的天然优势，并详细解释了计数策略。
- **XZYQvQ**：通过记忆化搜索避免了重复计算，提升了效率。
- **King丨帝御威**：使用Dijkstra堆优化，适合带权图的扩展，代码结构清晰。

通过这些题解，可以掌握无权图最短路计数的核心思路，并学会如何优化计数过程。

---
处理用时：38.80秒
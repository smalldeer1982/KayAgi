# 题目信息

# 算24点

## 题目描述

几十年前全世界就流行一种数字游戏，至今仍有人乐此不疲．在中国我们把这种游戏称为“算 $24$ 点”。您作为游戏者将得到 $4$ 个 $1 \sim 9$ 之间的自然数作为操作数，而您的任务是对这 $4$ 个操作数进行适当的算术运算，要求运算结果等于 $24$。

您可以使用的运算只有：$\verb!+!,\verb!-!,\verb!*!,\verb!/!$，您还可以使用 $\verb!()!$ 来改变运算顺序。注意：所有的中间结果须是整数，所以一些除法运算是不允许的（例如，$(2\ \times 2)/4$ 是合法的，$2\times (2/4)$ 是不合法的）。下面我们给出一个游戏的具体例子：

若给出的 $4$ 个操作数是：$1$ 、 $2$ 、 $3$ 、 $7$，则一种可能的解答是 $1+2+3\ \times 7=24$。

## 说明/提示

感谢 chenyy 提供 special judge

---

$\text{upd 2022.8.1}$：新增加一组 Hack 数据。


## 样例 #1

### 输入

```
1 2 3 7
```

### 输出

```
2+1=3
7*3=21
21+3=24
```

# AI分析结果

### 综合分析与结论

该题目要求通过四则运算和括号组合四个数字，使其结果为24。题解中主要采用了以下几种思路：

1. **全排列+运算符枚举**：通过全排列枚举数字的顺序，再枚举运算符的组合，最后计算表达式结果。
2. **递归搜索**：每次选择两个数字进行运算，递归处理剩下的数字，直到所有数字用完。
3. **后缀表达式**：通过生成后缀表达式，利用栈计算表达式结果。

这些方法的核心思想都是通过枚举所有可能的运算顺序和组合，找到符合条件的解。难点在于如何高效地枚举所有可能性，并处理运算中的边界条件（如除法不能整除、中间结果不能为负数等）。

### 评分较高的题解

#### 1. 题解作者：razx (5星)
- **关键亮点**：使用STL的`next_permutation`枚举全排列，简化了代码；通过函数指针数组实现运算符的灵活调用，代码简洁且高效。
- **个人心得**：作者提到“别跟我说压行”，强调代码的简洁性和可读性，同时通过函数指针数组优化了运算符的处理。

```cpp
int F(int x,int k, int y) {
  if(k==1) return x+y;
  if(k==2) return max(x,y)-min(x,y);
  if(k==3) return x*y;
  return (y==0 || x<y || x%y!=0) ? -999999 : x/y;
}
```

#### 2. 题解作者：stoorz (4星)
- **关键亮点**：采用递归搜索，每次选择两个数字进行运算，记录运算步骤，最后输出结果。思路清晰，代码结构合理。
- **个人心得**：作者提到“看到很多人的代码都被hack了”，强调了对边界条件的处理，确保代码的鲁棒性。

```cpp
void dfs(int k) {
    if(k==4) {
        if(check()) {
            print();
            ok=1;
        }
        return;
    }
    int x,y;
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
            if(i!=j&&a[i]>0&&a[j]>0) {
                // 加减乘除运算
            }
}
```

#### 3. 题解作者：ysner (4星)
- **关键亮点**：通过递归枚举所有可能的运算顺序，记录运算步骤，最后输出结果。代码结构清晰，易于理解。
- **个人心得**：作者提到“此题不需要优化，直接暴搜”，强调了暴力搜索的可行性，同时通过递归实现了简洁的代码结构。

```cpp
void dfs(int t) {
    if(t==1) {check();return;}
    for(int i=0;i<4;i++)
        for(int j=0;j<4;j++)
            if(vis[j]==0&&a[i]>=a[j]&&i!=j) {
                // 加减乘除运算
            }
}
```

### 最优关键思路与技巧

1. **全排列与运算符枚举**：通过全排列枚举数字的顺序，再枚举运算符的组合，最后计算表达式结果。这种方法思路清晰，代码实现简单。
2. **递归搜索**：每次选择两个数字进行运算，递归处理剩下的数字，直到所有数字用完。这种方法适合处理组合问题，代码结构清晰。
3. **后缀表达式**：通过生成后缀表达式，利用栈计算表达式结果。这种方法适合处理复杂的运算顺序问题，但实现较为复杂。

### 可拓展之处

1. **类似题目**：可以扩展到更多数字或更复杂的运算规则，如使用指数、开方等运算。
2. **算法优化**：可以通过剪枝优化递归搜索，减少不必要的计算。

### 推荐题目

1. **P1044 栈**：考察栈的应用，与后缀表达式计算相关。
2. **P1036 选数**：考察组合与递归搜索，与本题的递归思路相似。
3. **P1019 单词接龙**：考察全排列与组合，与本题的全排列思路相似。

### 个人心得总结

- **调试经历**：多位作者提到在处理除法时需要注意除数不能为零，且结果必须为整数，强调了边界条件的重要性。
- **顿悟感想**：通过递归和全排列的组合，可以高效地解决复杂的组合问题，代码实现简洁且易于理解。

---
处理用时：32.69秒
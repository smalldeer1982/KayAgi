# 题目信息

# 有线电视网

## 题目描述

某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。

从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。

现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。

写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。


## 说明/提示

**样例解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/7yj4u55m.png)

如图所示，共有五个结点。结点 ① 为根结点，即现场直播站，② 为一个中转站，③④⑤ 为用户端，共 $M$ 个，编号从 $N-M+1$ 到 $N$，他们为观看比赛分别准备的钱数为 $3$、$4$、$2$。

从结点 ① 可以传送信号到结点 ②，费用为 $2$；

也可以传送信号到结点 ⑤，费用为 $3$（第二行数据所示）；

从结点 ② 可以传输信号到结点 ③，费用为$2$；

也可传输信号到结点 ④，费用为 $3$（第三行数据所示）。

如果要让所有用户（③④⑤）都能看上比赛，则信号传输的总费用为：$2+3+2+3=10$，大于用户愿意支付的总费用 $3+4+2=9$，有线电视网就亏本了，而只让 ③④ 两个用户看比赛就不亏本了。

[](https://paste.ubuntu.com/p/H9BMGJvFHH/)

## 样例 #1

### 输入

```
5 3

2 2 2 5 3

2 3 2 4 3

3 4 2```

### 输出

```
2

```

# AI分析结果

### 综合分析与结论

本题是一个典型的树形背包问题，目标是在不亏本的情况下最大化用户数量。题解中主要采用了树形动态规划（DP）的思路，结合分组背包的思想进行优化。大部分题解的核心思路是定义状态 `f[i][j]` 表示以节点 `i` 为根的子树中选择 `j` 个用户的最大收益，然后通过递归和状态转移方程来求解。难点在于如何高效地进行状态转移，避免重复计算，并确保时间复杂度在可接受范围内。

### 所选高星题解

#### 1. 作者：w36557658 (赞：17)
- **星级**：5星
- **关键亮点**：
  - 使用了后序遍历序列重新编号，优化了状态转移的顺序。
  - 通过 `f[i][j] = max(f[i-1][j] + c[i], f[i-sz[i]][j])` 的状态转移方程，确保了时间复杂度为 `O(nm)`。
  - 代码结构清晰，注释详细，易于理解。
- **个人心得**：作者提到通过后序遍历序列重新编号，避免了重复计算，优化了时间复杂度。这种思路对于树形DP的优化非常有帮助。

```cpp
void dfs(int u){
    sz[u] = 1;
    for(int i = head[u]; i; i = e[i].nxt){
        int v = e[i].to;
        dfs(v); sz[u] += sz[v];
    }
    idx[++tot] = u;
}
```

#### 2. 作者：zimindaada (赞：8)
- **星级**：4星
- **关键亮点**：
  - 使用了分组背包的思想，将每个子树看作一组物品，通过枚举分配的用户数量进行状态转移。
  - 通过 `dp[u][j] = max(dp[u][j], dp[u][j-k] + dp[v][k] - w[u][v])` 的状态转移方程，确保了正确性。
  - 代码实现简洁，逻辑清晰。
- **个人心得**：作者提到通过分组背包的思想，将问题转化为经典的背包问题，简化了状态转移的逻辑。

```cpp
int dfs(int x, int fa){
    if(x > n-m){
        f[x][1] = a[x];
        return 1;
    }
    int siz = 0, g;
    for(int i = last[x]; i; i = e[i].gg){
        int y = e[i].y;
        if(y == fa) continue;
        siz += (g = dfs(y,x));
        for(int j = siz; j; --j){
            for(int k = 1; k <= min(j,g); ++k){
                f[x][j] = max(f[x][j], f[x][j - k] + f[y][k] - e[i].w);
            }
        }
    }
    return siz;
}
```

#### 3. 作者：daklqw (赞：5)
- **星级**：4星
- **关键亮点**：
  - 使用了DFS序上的问题，将树形背包转化为线性DP问题。
  - 通过 `f[i][j] = max(f[out[i]][j], f[i+1][j + ww[i]] + vv[i])` 的状态转移方程，确保了正确性。
  - 代码实现简洁，逻辑清晰。
- **个人心得**：作者提到通过DFS序将树形背包转化为线性DP问题，简化了状态转移的逻辑。

```cpp
void dfs(int u) {
    sz[u] = 1; dfn[u] = ++t0t;
    vv[t0t] = val[u];
    ww[t0t] = u + m - 1 >= n;
    for (int i = head[u]; i; i = nxt[i]) 
        sz[u] += dfs(to[i]);
    out[dfn[u]] = t0t + 1;
    return sz[u];
}
```

### 最优关键思路与技巧

1. **树形背包的状态定义**：定义 `f[i][j]` 表示以节点 `i` 为根的子树中选择 `j` 个用户的最大收益。
2. **后序遍历优化**：通过后序遍历序列重新编号，优化状态转移的顺序，避免重复计算。
3. **分组背包思想**：将每个子树看作一组物品，通过枚举分配的用户数量进行状态转移。
4. **DFS序转化**：将树形背包转化为线性DP问题，简化状态转移的逻辑。

### 可拓展之处

- **同类型题目**：类似的问题可以扩展到其他树形DP问题，如树上路径问题、子树选择问题等。
- **类似算法套路**：树形DP结合分组背包的思想可以应用于其他需要选择子集的问题，如树上最大独立集、最小支配集等。

### 推荐题目

1. **P2014 [CTSC1997]选课**：树形DP的经典题目，考察如何在树上选择节点以获得最大收益。
2. **P1272 重建道路**：树形DP与路径选择问题，考察如何在树上选择路径以最小化代价。
3. **P4322 [JSOI2016]最佳团体**：树形背包问题，考察如何在树上选择子集以最大化收益。

### 个人心得总结

- **调试经历**：许多作者提到在初始化 `f[i][j]` 时需要注意赋值为负无穷，以避免无效状态的影响。
- **踩坑教训**：在状态转移时，需要注意枚举顺序，避免重复计算或覆盖有效状态。
- **顿悟感想**：通过后序遍历或DFS序优化状态转移顺序，可以显著提高算法的效率。

---
处理用时：43.48秒
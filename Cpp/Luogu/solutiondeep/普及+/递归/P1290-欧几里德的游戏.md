# 题目信息

# 欧几里德的游戏

## 题目描述

欧几里德的两个后代 Stan 和 Ollie 正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数 $M$ 和 $N$，从 Stan 开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于 $0$。然后是 Ollie，对刚才得到的数，和 $M,N$ 中较小的那个数，再进行同样的操作……直到一个人得到了 $0$，他就取得了胜利。下面是他们用 $(25,7)$ 两个数游戏的过程：

- 初始：$(25,7)$；
- Stan：$(11,7)$；
- Ollie：$(4,7)$；
- Stan：$(4,3)$；
- Ollie：$(1,3)$；
- Stan：$(1,0)$。

Stan 赢得了游戏的胜利。

现在，假设他们完美地操作，谁会取得胜利呢？

## 说明/提示

$1 \leq C \leq 6$。

## 样例 #1

### 输入

```
2
25 7
24 15
```

### 输出

```
Stan wins
Ollie wins
```

# AI分析结果

### 综合分析与结论

本题的核心是通过模拟欧几里得算法的过程，判断在给定两个数的情况下，先手（Stan）是否能够必胜。题解中主要采用了以下几种思路：

1. **递归模拟**：通过递归模拟每一步的减法操作，判断当前状态是否为必胜状态。
2. **博弈论分析**：利用博弈论中的必胜和必败状态，分析当前操作者是否能够通过某种策略必胜。
3. **数学归纳法**：通过数学归纳法证明某些情况下先手必胜。

大多数题解都采用了递归或循环的方式模拟减法过程，并通过判断当前状态是否满足必胜条件来决定胜负。其中，**Special_zyy**和**lowww666**的题解思路清晰，代码简洁，且对博弈论的分析较为深入，值得推荐。

### 所选高星题解

#### 1. Special_zyy (★★★★★)
- **关键亮点**：
  - 通过递归模拟减法过程，判断当前状态是否为必胜状态。
  - 通过数学归纳法证明了当 `y >= 2x` 时，当前操作者必胜。
  - 代码简洁，逻辑清晰，易于理解。
- **核心代码**：
  ```cpp
  int find(int x, int y, int p) {
      if(x == y) return p;
      if(y / x >= 2) return p;
      else return find(y - x, x, p ^ 1);
  }
  ```
  **核心思想**：通过递归判断当前状态是否为必胜状态，若 `y >= 2x`，则当前操作者必胜，否则继续递归。

#### 2. lowww666 (★★★★☆)
- **关键亮点**：
  - 利用博弈论中的必胜和必败状态，分析当前操作者是否能够通过某种策略必胜。
  - 通过递归判断当前状态是否为必胜状态，代码简洁且逻辑清晰。
- **核心代码**：
  ```cpp
  bool solve(int n, int m) {
      if (!m) return false;
      if (n / m == 1) return !solve(m, n % m);
      else return true;
  }
  ```
  **核心思想**：通过递归判断当前状态是否为必胜状态，若 `n / m == 1`，则继续递归，否则当前操作者必胜。

#### 3. CreeperK (★★★★☆)
- **关键亮点**：
  - 通过递归模拟减法过程，判断当前状态是否为必胜状态。
  - 代码简洁，逻辑清晰，易于理解。
- **核心代码**：
  ```cpp
  int dfs(int a, int b, int p) {
      if(b == a) return 1;
      if(b / a >= 2) return 1;
      else return 1 ^ dfs(b - a, a, p ^ 1);
  }
  ```
  **核心思想**：通过递归判断当前状态是否为必胜状态，若 `b / a >= 2`，则当前操作者必胜，否则继续递归。

### 最优关键思路与技巧

1. **递归模拟**：通过递归模拟每一步的减法操作，判断当前状态是否为必胜状态。这种方法简单直观，适用于大多数博弈论问题。
2. **博弈论分析**：利用博弈论中的必胜和必败状态，分析当前操作者是否能够通过某种策略必胜。这种方法需要对博弈论有一定的理解，但能够更深入地分析问题。
3. **数学归纳法**：通过数学归纳法证明某些情况下先手必胜。这种方法适用于需要严格证明的场景。

### 可拓展之处

1. **类似博弈问题**：可以拓展到其他类似的博弈问题，如取石子游戏、尼姆游戏等。
2. **优化递归**：可以通过记忆化搜索或动态规划优化递归过程，减少重复计算。

### 推荐题目

1. **P1290 欧几里德的游戏**（本题）
2. **P1288 取石子游戏**（洛谷 P1288）
3. **P1289 尼姆游戏**（洛谷 P1289）

### 个人心得摘录

- **Special_zyy**：通过数学归纳法证明了当 `y >= 2x` 时，当前操作者必胜，这一结论简化了问题的分析。
- **lowww666**：利用博弈论中的必胜和必败状态，分析当前操作者是否能够通过某种策略必胜，这一思路值得借鉴。
- **CreeperK**：通过递归模拟减法过程，判断当前状态是否为必胜状态，代码简洁且逻辑清晰。

---
处理用时：31.07秒
# 题目信息

# [NOIP 2010 提高组] 乌龟棋

## 题目背景

NOIP2010 提高组 T2

## 题目描述

小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。

乌龟棋的棋盘是一行 $N$ 个格子，每个格子上一个分数（非负整数）。棋盘第 $1$ 格是唯一的起点，第 $N$ 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。

乌龟棋中 $M$ 张爬行卡片，分成 $4$ 种不同的类型（$M$ 张卡片中不一定包含所有 $4$ 种类型的卡片，见样例），每种类型的卡片上分别标有 $1,2,3,4$ 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。


游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。


很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。


现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？


## 说明/提示

每个测试点 1s。

小明使用爬行卡片顺序为 $1,1,3,1,2$，得到的分数为 $6+10+14+8+18+17=73$。注意，由于起点是 $1$，所以自动获得第 $1$ 格的分数 $6$。


对于 $30\%$ 的数据有 $1≤N≤30,1≤M≤12$。


对于 $50\%$ 的数据有 $1≤N≤120,1≤M≤50$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $20$。


对于 $100\%$ 的数据有 $1≤N≤350,1≤M≤120$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $40$；$0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M$。


## 样例 #1

### 输入

```
9 5
6 10 14 2 8 8 18 5 17
1 3 1 2 1
```

### 输出

```
73
```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）来求解乌龟棋的最大得分。所有题解均采用了四维DP的思路，状态定义为使用不同数量的四种卡片时的最大得分。虽然题解的思路基本一致，但在代码实现、优化技巧、以及细节处理上存在差异。以下是对各题解的简要分析与评分。

### 评分较高的题解

#### 1. 作者：吃瓜群众syc (赞：415)
- **星级：5星**
- **关键亮点**：思路清晰，代码简洁，详细解释了状态转移方程和初始化过程，且对边界条件处理得当。
- **个人心得**：作者提到在调试过程中发现“r=1+a+b*2+c*3+d*4”中的“+1”容易被忽略，强调了细节的重要性。
- **核心代码**：
  ```cpp
  for(int a=0;a<=g[1];a++)
      for(int b=0;b<=g[2];b++)
          for(int c=0;c<=g[3];c++)
              for(int d=0;d<=g[4];d++)
              {
                  int r=1+a+b*2+c*3+d*4;
                  if(a!=0) F[a][b][c][d]=max(F[a][b][c][d],F[a-1][b][c][d]+num[r]);
                  if(b!=0) F[a][b][c][d]=max(F[a][b][c][d],F[a][b-1][c][d]+num[r]);
                  if(c!=0) F[a][b][c][d]=max(F[a][b][c][d],F[a][b][c-1][d]+num[r]);
                  if(d!=0) F[a][b][c][d]=max(F[a][b][c][d],F[a][b][c][d-1]+num[r]);
              }
  ```

#### 2. 作者：Time_Rune (赞：130)
- **星级：4星**
- **关键亮点**：详细解释了状态转移方程的推导过程，强调了动态规划的核心思想，代码结构清晰。
- **个人心得**：作者提到最初尝试用搜索+回溯，但发现会超时，转而使用DP，强调了选择合适的算法的重要性。
- **核心代码**：
  ```cpp
  for(int i1=0;i1<=s1;i1++)
      for(int i2=0;i2<=s2;i2++)
          for(int i3=0;i3<=s3;i3++)
              for(int i4=0;i4<=s4;i4++)
              {
                  if(i1==0&&i2==0&&i3==0&&i4==0)continue;
                  maxx=0;now=1+i1+2*i2+3*i3+4*i4;
                  if(i1!=0)maxx=max(maxx,f[i1-1][i2][i3][i4]+a[now]);
                  if(i2!=0)maxx=max(maxx,f[i1][i2-1][i3][i4]+a[now]);
                  if(i3!=0)maxx=max(maxx,f[i1][i2][i3-1][i4]+a[now]);
                  if(i4!=0)maxx=max(maxx,f[i1][i2][i3][i4-1]+a[now]);
                  f[i1][i2][i3][i4]=max(maxx,f[i1][i2][i3][i4]);
              }
  ```

#### 3. 作者：kuaiCreator (赞：0)
- **星级：4星**
- **关键亮点**：使用了动态规划的“六步分析法”，详细分解了问题的各个步骤，逻辑清晰，代码简洁。
- **核心代码**：
  ```cpp
  for(int i = 0; i <= cnt[1]; i++)
      for(int j = 0; j <= cnt[2]; j++)
          for(int k = 0; k <= cnt[3]; k++)
              for(int l = 0; l <= cnt[4]; l++){
                  int step = i+2*j+3*k+4*l+1;
                  if(i) f[i][j][k][l] = max(f[i][j][k][l], f[i-1][j][k][l] + a[step]);
                  if(j) f[i][j][k][l] = max(f[i][j][k][l], f[i][j-1][k][l] + a[step]);
                  if(k) f[i][j][k][l] = max(f[i][j][k][l], f[i][j][k-1][l] + a[step]);
                  if(l) f[i][j][k][l] = max(f[i][j][k][l], f[i][j][k][l-1] + a[step]);
              }
  ```

### 最优关键思路与技巧

1. **状态定义**：使用四维DP数组 `f[a][b][c][d]` 表示使用 `a` 张1号卡片、`b` 张2号卡片、`c` 张3号卡片、`d` 张4号卡片时的最大得分。
2. **状态转移**：从当前状态的前一个状态（即少用一张某种卡片）转移过来，取最大值并加上当前格子的分数。
3. **边界处理**：初始化 `f[0][0][0][0]` 为起点分数，并在转移时确保卡片数量不为负。
4. **优化技巧**：通过计算当前格子的位置 `r = 1 + a + b*2 + c*3 + d*4`，避免了额外的状态变量。

### 可拓展之处

- **类似题目**：可以扩展到更多种类的卡片或更复杂的棋盘规则，如允许后退或跳跃到任意位置。
- **算法套路**：类似的多维DP问题，如背包问题、资源分配问题等，都可以采用类似的思路进行求解。

### 推荐题目

1. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064) - 多维背包问题，与本题的DP思路相似。
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典的01背包问题，适合练习DP基础。
3. [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541) - 本题本身，适合巩固多维DP的应用。

### 个人心得总结

- **调试经验**：多位作者提到在调试过程中发现“r=1+a+b*2+c*3+d*4”中的“+1”容易被忽略，强调了细节的重要性。
- **算法选择**：作者Time_Rune提到最初尝试用搜索+回溯，但发现会超时，转而使用DP，强调了选择合适的算法的重要性。

---
处理用时：47.90秒
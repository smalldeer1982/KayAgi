# 题目信息

# 偶数

## 题目描述

给定一个正整数 $n$，请输出杨辉三角形前 $n$ 行的偶数个数对 $1000003$ 取模后的结果。


## 说明/提示

对于 $30\%$ 的数据，$n\le 4\times 10^3$。

对于 $70\%$ 的数据，$n\le 4\times 10^9$。

对于 $100\%$ 的数据，$1\le n\le 10^{15}$。

杨辉三角形的前七行：

```plain
       1
      1 1
     1 2 1
    1 3 3 1
   1 4 6 4 1
 1 5 10 10 5 1
1 6 15 20 15 6 1
```

## 样例 #1

### 输入

```
6
```

### 输出

```
6
```

# AI分析结果

### 综合分析与结论

该题目要求计算杨辉三角形前 $n$ 行的偶数个数，并对结果取模 $1000003$。由于 $n$ 的范围极大（$1 \leq n \leq 10^{15}$），直接生成杨辉三角形并统计偶数个数的方法不可行。因此，大部分题解都通过寻找杨辉三角形中奇偶数的分布规律，结合数学推导和递归/分治思想来解决该问题。

#### 关键思路与技巧：
1. **奇偶性规律**：通过观察杨辉三角形的奇偶性分布，发现其具有分形特性，奇数个数与 $2^k$ 和 $3^k$ 相关。
2. **递归与分治**：利用递归将问题分解为更小的子问题，结合快速幂和二进制分解，高效计算奇数个数。
3. **数学公式推导**：通过卢卡斯定理和二进制性质，推导出奇数个数的计算公式，避免直接生成杨辉三角形。
4. **预处理与优化**：预处理 $2^k$ 和 $3^k$ 的值，减少重复计算，提升算法效率。

#### 通用建议与扩展思路：
- **分形与递归**：在处理具有分形特性的问题时，递归和分治是常用且有效的方法。
- **二进制分解**：对于涉及 $2^k$ 的问题，二进制分解可以简化计算。
- **数学优化**：通过数学公式推导，避免暴力计算，提升算法效率。

### 推荐题解

#### 题解1：作者：笨笨猪 (赞：112)
- **星级**：★★★★★
- **关键亮点**：
  - 详细推导了杨辉三角形中奇数个数的规律，结合二进制分解和快速幂，高效计算奇数个数。
  - 通过预处理 $3^k$ 的值，减少重复计算，提升算法效率。
  - 代码清晰，逻辑严密，易于理解。
- **个人心得**：
  - 通过暴力程序验证规律的正确性，确保推导的准确性。
  - 强调规律的寻找是一个漫长的探索过程，但一旦发现，问题迎刃而解。

```cpp
#include <cstdio>
#define mo 1000003
using namespace std;

long long n, d, z, ans, a[55], b[55], v, p;
int i, t;
int main()
{
    scanf("%lld",&v);
    n = v;
    z = 1;
    d = z << 50; //因为2^50恰好大于10^15
    t = 50;
    while (n != 0)
    {
        if (n >= d)
        {
            n = n-d;
            a[++a[0]] = t; //将2^t 的t存入数组中
        }
        d /= 2;
        t--;
    }
    
    b[0] = 1;
    for (i=1; i<=a[1]; ++i)
        b[i]=(b[i-1]*3)%mo; //进行预处理，准备好3^t 的数字在数组b中
    
    for (i=1; i<=a[0]; ++i)
        ans += b[a[i]]*(long long)(z << i-1); //求所有奇数个数的和
    
    p = (((z+v%mo)*(v%mo))/2); //求和公式
    p %= mo;
    ans %= mo;
    if (p<ans) p += mo;
    p = (p-ans)%mo; //总个数减去所有奇数个数就是偶数个数了
    printf("%lld\n",p);
    return 0;
}
```

#### 题解2：作者：codecode (赞：3)
- **星级**：★★★★☆
- **关键亮点**：
  - 通过卢卡斯定理和二进制性质，推导出奇数个数的计算公式，避免直接生成杨辉三角形。
  - 预处理 $2^k$ 和 $3^k$ 的值，减少重复计算，提升算法效率。
  - 代码简洁，逻辑清晰，易于理解。

```cpp
#include<bits/stdc++.h>
#define int long long //一个小技巧
using namespace std;

const int mod=1e6+3;
int n,ans,cnt,cnt2,a[55]={1},c[55]={1},b[35];
//a为3的幂次，c为2的幂次，b为n的二进制拆分

signed main(){
	cin>>n;
	int n1=n%mod,n2=(n1*(n1+1)/2)%mod;
	//这样可以避免求逆元地算出总数
    
	for(int i=1;i<=50;i++)
		a[i]=(a[i-1]*3)%mod;
	for(int i=1;i<=50;i++)
		c[i]=(c[i-1]*2)%mod;
	while(n)b[cnt]=n&1,cnt++,n/=2;
	//预处理&二进制拆分
    
	for(int i=cnt-1;i>=0;i--){
		if(!b[i])continue;
		ans+=c[cnt2]*a[i],ans%=mod;
		cnt2++;
	}//套公式计算

	cout<<((n2-ans)%mod+mod)%mod;
	return 0;
}
```

#### 题解3：作者：i207M (赞：3)
- **星级**：★★★★☆
- **关键亮点**：
  - 通过数位DP计算二进制下有 $i$ 个 $1$ 的数字个数，结合快速幂，高效计算奇数个数。
  - 代码逻辑清晰，易于理解，适合对数位DP有一定基础的读者。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<string>
#include<cstring>
#include<queue>
#include<set>
#include<map>
#include<bitset>
using namespace std;
#define ri register int
#define LL long long
#define il inline
#define mp make_pair
#define pb push_back
#define pairint pair<int,int>
#define fi first
#define se second
#define gc getchar
template<class T>il void in(T &x)
{
    x=0;bool f=0;char c=gc();
    while(c<'0'||c>'9') 
    {
        if(c=='-') f=1;
        c=gc();
    }
    while(c>='0'&&c<='9') x=x*10+(c^'0'),c=gc();
    if(f) x=-x;
}
#undef gc
#define int LL
#define md 1000003
int n;
int ans;
int qpow(int a,int b)
{
	int res=1; a%=md;
	for(;b;b>>=1,(a*=a)%=md)
		if(b&1) (res*=a)%=md;
	return res;
}
// 0 - 50
int f[51][51];
int dig[51],cnt;
int dfs(int x,int num,bool jud)
{
	if(num<0) return 0;
	if(x<=0) return num==0;
	if(!jud&&~f[x][num]) return f[x][num];
	int res=dfs(x-1,num,jud&&(dig[x]==0));
	if(!jud||dig[x]==1)
		(res+=dfs(x-1,num-1,jud&&(dig[x]==1)))%=md;
	if(!jud) f[x][num]=res;
	return res;
}
signed main()
{
#ifdef M207
    freopen("in.in","r",stdin);
#endif
	in(n);
	int tmp=n-1;
	while(tmp) dig[++cnt]=tmp&1,tmp>>=1;
	memset(f,-1,sizeof f);
	for(ri i=0;i<=cnt;++i)
		(ans+=dfs(cnt,i,1)*qpow(2,i))%=md;
	n%=md;
	ans=((n+1)*n/2%md-ans+md)%md;
	printf("%lld",ans);
    return 0;
}
```

### 推荐题目
1. **P1357 杨辉三角**：考察杨辉三角形的生成与性质。
2. **P2602 [ZJOI2010]数字计数**：涉及数位DP与二进制性质。
3. **P1886 滑动窗口**：考察分治与递归思想的应用。

---
处理用时：58.05秒
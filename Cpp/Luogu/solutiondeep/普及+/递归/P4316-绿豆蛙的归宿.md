# 题目信息

# 绿豆蛙的归宿

## 题目背景

随着新版百度空间的上线，Blog 宠物绿豆蛙完成了它的使命，去寻找它新的归宿。

## 题目描述

给出张 $n$ 个点 $m$ 条边的有向无环图，起点为 $1$，终点为 $n$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。

绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 $k$ 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\frac{1}{k}$ 。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 10^2$。
- 对于 $40\%$ 的数据，保证 $n \leq 10^3$。
- 对于 $60\%$ 的数据，保证 $n \leq 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times n$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^9$，给出的图无重边和自环。

## 样例 #1

### 输入

```
4 4 
1 2 1 
1 3 2 
2 3 3 
3 4 4```

### 输出

```
7.00```

# AI分析结果

### 综合分析与结论

本题是一个典型的期望DP问题，核心在于通过动态规划计算从起点到终点的路径长度期望。大多数题解采用了**逆推**的思路，即从终点出发，逐步计算每个节点到终点的期望路径长度。这种思路的优势在于可以避免重复计算，且符合DAG（有向无环图）的特性。部分题解还提供了**正推**的思路，但逆推更为简洁高效。

### 所选高星题解

#### 1. 作者：___new2zy___ (5星)
**关键亮点**：
- **逆推思路**：从终点出发，逐步计算每个节点到终点的期望路径长度，符合DAG的特性。
- **拓扑排序**：通过拓扑排序实现逆推，避免了递归的栈空间开销，且时间复杂度为O(n+m)。
- **代码清晰**：代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
void toposort() {
    queue<int> q;
    q.push(n);
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        for (int i = head[x]; i; i = p[i].from) {
            int y = p[i].to;
            f[y] += (f[x] + p[i].w) / dg[y]; // dp转移
            if (!(--in[y])) q.push(y);
        }
    }
}
```
**实现思想**：通过拓扑排序从终点出发，逐步更新每个节点的期望路径长度。

#### 2. 作者：wangjyqh (4星)
**关键亮点**：
- **正推与逆推对比**：详细解释了正推和逆推的区别，帮助理解期望DP的不同实现方式。
- **概率计算**：在正推中引入概率计算，确保期望值的正确性。
- **代码简洁**：代码实现简洁，适合初学者理解。

**核心代码**：
```cpp
void topsort() {
    queue<int> q;
    for (int i = 1; i <= n; ++i) if (!ind[i]) q.push(i);
    dp[1] = 0.000;
    g[1] = 1.000;
    while (q.size()) {
        int x = q.front();
        q.pop();
        for (int i = head[x]; i; i = nxt[i]) {
            int y = ver[i];
            dp[y] += (dp[x] * g[x] + (double)edge[i] * g[x]) / (double)oud[x];
            g[y] += g[x] / (double)oud[x];
            if (--ind[y] == 0) q.push(y);
        }
    }
}
```
**实现思想**：通过拓扑排序实现正推，计算每个节点的期望路径长度，并引入概率计算。

#### 3. 作者：ghj1222 (4星)
**关键亮点**：
- **期望的线性性**：通过期望的线性性，将问题转化为计算每条边的期望经过次数。
- **拓扑排序**：利用拓扑排序进行递推，确保计算顺序的正确性。
- **代码简洁**：代码实现简洁，适合理解期望DP的基本思路。

**核心代码**：
```cpp
while (top > 0) {
    int x = s[top--];
    for (int i = h[x]; i != 0; i = a[i].ne) {
        in[a[i].v]--;
        p[a[i].v] += p[x] / out[x];
        f[i] = p[x] / out[x];
        if (in[a[i].v] == 0) s[++top] = a[i].v;
    }
}
```
**实现思想**：通过栈维护拓扑排序，计算每个节点的期望经过次数。

### 最优关键思路与技巧

1. **逆推思路**：从终点出发，逐步计算每个节点到终点的期望路径长度，符合DAG的特性，且避免了重复计算。
2. **拓扑排序**：利用拓扑排序确保计算顺序的正确性，避免递归的栈空间开销。
3. **期望的线性性**：通过期望的线性性，将问题转化为计算每条边的期望经过次数，简化了问题的复杂度。

### 可拓展之处

- **非DAG图**：如果图不是DAG，可以通过列方程组求解期望，类似于[HNOI2013]游走。
- **多起点多终点**：可以扩展为多个起点或多个终点的期望计算问题。

### 推荐相似题目

1. [P1850 换教室](https://www.luogu.org/problemnew/show/P1850)
2. [P3232 [HNOI2013]游走](https://www.luogu.org/problemnew/show/P3232)
3. [P1365 WJMZBMR打osu! / Easy](https://www.luogu.org/problemnew/show/P1365)

### 个人心得摘录

- **逆推的优势**：逆推思路在处理DAG时非常高效，且避免了正推中概率计算的复杂性。
- **拓扑排序的应用**：拓扑排序不仅适用于DAG的遍历，还能有效解决期望DP中的计算顺序问题。
- **期望的线性性**：理解期望的线性性可以帮助简化复杂问题，尤其是在处理多条路径的期望时。

---
处理用时：34.48秒
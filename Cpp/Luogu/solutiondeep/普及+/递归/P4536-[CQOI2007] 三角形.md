# 题目信息

# [CQOI2007] 三角形

## 题目描述

画一个等边三角形，把三边的中点连接起来，得到四个三角形，把它们称为 $T_1,T_2,T_3,T_4$，如图1。

把前三个三角形也这样划分，得到 $12$ 个更小的三角形，$T_{11},T_{12},T_{13},T_{14},T_{21},T_{22},T_{23},T_{24},T_{31},T_{32},T_{33},T_{34}$，如图2。

把编号以 $1,2,3$ 结尾的三角形又继续划分……最后得到的分形称为 Sierpinski 三角形。

![](https://cdn.luogu.com.cn/upload/pic/18501.png)

如果三角形 $B$ 不包含三角形 $A$，且 $A$ 的某一条完整的边是 $B$ 的某条边的一部分，则我们说 $A$ 靠在 $B$ 的边上。例如 $T_{12}$ 靠在 $T_{14}$ 和 $T_4$ 上，但不靠在 $T_{32}$ 上。

给出 Spierpinski 三角形中的一个三角形，找出它靠着的所有三角形。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 50$。

## 样例 #1

### 输入

```
T312```

### 输出

```
T314
T34
T4```

# AI分析结果

### 综合分析与结论

本题的核心在于通过观察Sierpinski三角形的结构，找出给定三角形相邻的三角形。题解主要集中在以下几种思路：

1. **分类讨论与递归**：通过分析三角形的位置（角、边、内部）和编号特征，递归地找到相邻的三角形。
2. **模拟与规律总结**：通过模拟三角形的分裂过程，总结出相邻三角形的编号规律。
3. **字符串处理与排序**：通过字符串操作和排序，输出符合条件的相邻三角形编号。

大多数题解都采用了分类讨论和递归的思路，部分题解通过字符串处理和排序优化了输出结果。整体上，题解的质量参差不齐，部分题解思路清晰、代码简洁，而有些则较为冗长或不够优化。

### 所选高质量题解

#### 1. **作者：RedreamMer (5星)**
- **关键亮点**：思路清晰，代码简洁，通过分类讨论和字符串处理高效地解决了问题。特别处理了末尾为4的情况，并通过排序输出结果。
- **核心代码**：
  ```cpp
  string s,ss[3];
  int len;
  int main() {
      cin>>s;
      len=s.size()-1;
      if(s[len]=='4') {
          cout<<s.substr(0,len)<<1<<endl<<s.substr(0,len)<<2<<endl<<s.substr(0,len)<<3;
          return 0;
      }
      for(int i=1; i<=len; i++) {
          if(s[i]=='1') ss[0]=s.substr(0,i)+"4";
          else if(s[i]=='2') ss[1]=s.substr(0,i)+"4";
          else if(s[i]=='3') ss[2]=s.substr(0,i)+"4";
      }
      sort(ss,ss+3); 
      for(int i=0; i<=2; i++)
          if(ss[i][0]=='T') cout<<ss[i]<<endl;
      return 0;
  }
  ```
- **核心思想**：通过遍历字符串，根据字符值更新相邻三角形的编号，最后排序输出。

#### 2. **作者：AE酱 (4星)**
- **关键亮点**：通过递归和分类讨论，详细分析了三角形的位置关系，代码结构清晰，逻辑严谨。
- **核心代码**：
  ```cpp
  void DFS(int pos){
      if(pos>Len) return;
      if(S[pos]=='4'){
          ID+="4";
          int IDS=ID.size()-1;
          A=ID;A[IDS]='2';
          B=ID;B[IDS]='3';
          C=ID;C[IDS]='1';
          DFS(pos+1);
      }
      else if(S[pos]=='1'){
          ID+="1";
          C=ID;C[C.size()-1]='4';
          DFS(pos+1);
      }
      else if(S[pos]=='2'){
          ID+="2";
          B=ID;B[B.size()-1]='4';
          DFS(pos+1);
      }
      else if(S[pos]=='3'){
          ID+="3";
          A=ID;A[A.size()-1]='4';
          DFS(pos+1);
      }
      return;
  }
  ```
- **核心思想**：通过递归函数`DFS`，根据字符值更新相邻三角形的编号，最终输出结果。

#### 3. **作者：Light_Knight (4星)**
- **关键亮点**：通过递归和优化，减少了不必要的计算，代码简洁高效，特别处理了末尾连续相同编号的情况。
- **核心代码**：
  ```cpp
  void find(string s,int l){
      if(!ans[3+'0'-s[l]].length()) 
          ans[3+'0'-s[l]] = s.substr(0,l)+"4"; 
      int t = l;
      while(s[t] == s[l]) t--;
      if(t == 0){  
          sort(ans,ans+3);
          for(int i = 0;i < 3;i++){
              if(ans[i].length()) cout << ans[i] << '\n';
          }
          exit(0);
      }
      find(s.substr(0,t+1),t); 
  }
  ```
- **核心思想**：通过递归函数`find`，根据字符值更新相邻三角形的编号，最终排序输出。

### 最优关键思路与技巧

1. **分类讨论与递归**：通过分析三角形的位置和编号特征，递归地找到相邻的三角形，适用于类似的分形结构问题。
2. **字符串处理与排序**：通过字符串操作和排序，高效地输出符合条件的相邻三角形编号，适用于需要处理字符串和排序的题目。

### 可拓展之处

1. **分形结构问题**：类似的分形结构问题，如Koch雪花、Mandelbrot集等，可以采用类似的递归和分类讨论思路。
2. **字符串处理与排序**：在处理字符串和排序的题目中，可以采用类似的字符串操作和排序技巧，提高代码效率。

### 推荐题目

1. **P1226 【模板】快速幂**：考察递归和分治思想。
2. **P1048 采药**：考察动态规划和分类讨论。
3. **P1010 幂次方**：考察递归和字符串处理。

### 个人心得摘录

- **RedreamMer**：通过分类讨论和字符串处理，高效地解决了问题，特别处理了末尾为4的情况，并通过排序输出结果。
- **AE酱**：通过递归和分类讨论，详细分析了三角形的位置关系，代码结构清晰，逻辑严谨。
- **Light_Knight**：通过递归和优化，减少了不必要的计算，代码简洁高效，特别处理了末尾连续相同编号的情况。

---
处理用时：39.34秒
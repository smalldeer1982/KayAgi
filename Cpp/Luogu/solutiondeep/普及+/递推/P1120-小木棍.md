# 题目信息

# 小木棍

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。

现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。

给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。


## 说明/提示

对于全部测试点，$1 \leq n \leq 65$，$1 \leq a_i \leq 50$。

## 样例 #1

### 输入

```
9
5 2 1 5 2 1 5 2 1
```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

本题的核心是通过DFS搜索原始木棍的最小可能长度，难点在于如何通过剪枝优化搜索过程，避免超时。大部分题解都采用了类似的思路：枚举可能的原始长度，并通过DFS尝试拼接木棍。剪枝策略主要集中在以下几个方面：

1. **枚举范围的优化**：原始长度必须大于等于最长的小木棍，且小于等于所有小木棍的总和，且必须是总和的因数。
2. **搜索顺序的优化**：将小木棍按长度从大到小排序，优先使用较长的木棍，减少搜索空间。
3. **重复剪枝**：如果当前木棍无法拼接成功，跳过所有长度相同的木棍。
4. **提前终止**：如果当前拼接失败，且剩余长度等于当前木棍长度或原始长度，直接回溯。

### 所选高星题解

#### 1. **Kaori (5星)**
- **关键亮点**：提供了详细的剪枝策略，尤其是对“当前剩余长度等于当前木棍长度或原始长度”时的优化解释得非常清晰。代码结构清晰，注释详细，适合初学者理解。
- **个人心得**：作者提到“搜索题啊，每招优化都要学，学一招说不定竞赛的时候就能跑的快一点”，强调了剪枝的重要性。

```cpp
void dfs(int k, int last, int rest) {
    if (!rest) {
        if (k == m) { ok = 1; return; }
        for (int i = 1; i <= cnt; i++)
            if (!used[i]) break;
        used[i] = 1;
        dfs(k + 1, i, len - a[i]);
        used[i] = 0;
        if (ok) return;
    }
    int l = last + 1, r = cnt, mid;
    while (l < r) {
        mid = (l + r) >> 1;
        if (a[mid] <= rest) r = mid;
        else l = mid + 1;
    }
    for (int i = l; i <= cnt; i++) {
        if (!used[i]) {
            used[i] = 1;
            dfs(k, i, rest - a[i]);
            used[i] = 0;
            if (ok) return;
            if (rest == a[i] || rest == len) return;
            i = next[i];
            if (i == cnt) return;
        }
    }
}
```

#### 2. **林则徐 (4.5星)**
- **关键亮点**：使用了桶排序来存储木棍长度，并通过预处理最长的木棍长度，进一步优化了搜索顺序。代码简洁，剪枝策略明确。
- **个人心得**：作者提到“暴搜的思路并不难想到，主要难点是各种优化、各种剪枝”，强调了剪枝的重要性。

```cpp
void dfs(int res, int sum, int target, int p) {
    if (res == 0) {
        printf("%d", target);
        exit(0);
    }
    if (sum == target) {
        dfs(res - 1, 0, target, maxn);
        return;
    }
    for (int i = p; i >= minn; i--) {
        if (tm[i] && i + sum <= target) {
            tm[i]--;
            dfs(res, sum + i, target, i);
            tm[i]++;
            if (sum == 0 || sum + i == target) break;
        }
    }
}
```

#### 3. **NoyException (4星)**
- **关键亮点**：提供了多种剪枝策略，尤其是对“当前剩余长度等于当前木棍长度或原始长度”时的优化解释得非常清晰。代码结构清晰，注释详细，适合初学者理解。
- **个人心得**：作者提到“本蒟蒻花了半天才肝出来这道题，见到AC时内牛满面……”，强调了调试的重要性。

```cpp
bool perm(int pre, int fromp) {
    if (pre % len == 0) {
        if (sum - pre == len) return true;
        for (int i = 2; i <= end && vis[i]; i++);
        vis[i] = true;
        if (perm(pre + line[i], 2)) return true;
        vis[i] = false;
    }
    for (; fromp <= end; fromp++) {
        if (!vis[fromp]) {
            if (pre % len + line[fromp] <= len) {
                vis[fromp] = true;
                if (perm(pre + line[fromp], fromp)) return true;
                vis[fromp] = false;
                if (pre % len + line[fromp] == len) return false;
            }
            fromp = nxt[line[fromp]];
        }
    }
    return false;
}
```

### 最优关键思路与技巧

1. **枚举范围的优化**：原始长度必须是总和的因数，且大于等于最长的小木棍。
2. **搜索顺序的优化**：将木棍按长度从大到小排序，优先使用较长的木棍。
3. **重复剪枝**：如果当前木棍无法拼接成功，跳过所有长度相同的木棍。
4. **提前终止**：如果当前拼接失败，且剩余长度等于当前木棍长度或原始长度，直接回溯。

### 可拓展之处

- **类似题目**：类似的问题可以通过DFS+剪枝解决，如拼图问题、背包问题等。
- **算法套路**：DFS+剪枝是解决组合优化问题的常见套路，适用于需要枚举所有可能解的场景。

### 推荐题目

1. **P1120 小木棍 ［数据加强版］**（本题）
2. **P1048 采药**（背包问题，DFS+剪枝）
3. **P1092 虫食算**（DFS+剪枝，枚举字母对应数字）

### 个人心得总结

- **调试经历**：多位作者提到调试过程中遇到的困难，如超时、WA等，强调了剪枝的重要性。
- **顿悟感想**：通过不断优化剪枝策略，最终成功AC，体现了算法优化的重要性。

---
处理用时：49.47秒
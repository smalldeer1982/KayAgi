# 题目信息

# 开灯

## 题目描述

在一条无限长的路上，有一排无限长的路灯，编号为 $1,2,3,4,\dots$。

每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。

在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：

指定两个数，$a,t$（$a$ 为实数，$t$ 为正整数）。将编号为 $\lfloor a\rfloor,\lfloor 2 \times a\rfloor,\lfloor3 \times a\rfloor,\dots,\lfloor t  \times a\rfloor$ 的灯的开关各按一次。其中 $\lfloor k \rfloor$ 表示实数 $k$ 的整数部分。

在小明进行了 $n$ 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。

幸好，小明还记得之前的 $n$ 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？


## 说明/提示

记 $T=\sum \limits_{i=1}^n t_i = t_1+t_2+t_3+\dots+t_n$。

- 对于 $30\%$ 的数据，满足 $T \le 1000$；
- 对于 $80\%$ 的数据，满足 $T \le 200000$；
- 对于 $100\%$ 的数据，满足 $T \le 2000000$；
- 对于 $100\%$ 的数据，满足 $n \le 5000$，$1 \le a_i<1000$，$1 \le t_i \le T$。

数据保证，在经过 $n$ 次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的 $i$ 来说，$t_i\times a_i$ 的最大值不超过 $2000000$。

## 样例 #1

### 输入

```
3
1.618034 13
2.618034 7
1.000000 21```

### 输出

```
20```

# AI分析结果

### 综合分析与结论

本题的核心在于模拟路灯的开关操作，并最终找到唯一亮着的灯。题解中主要有两种思路：**模拟法**和**位运算法**。

1. **模拟法**：通过数组记录每盏灯的状态，每次操作后更新状态，最后遍历数组找到亮着的灯。这种方法直观易懂，但空间复杂度较高，且在大数据量下可能效率不足。
2. **位运算法**：利用异或运算的性质，将所有操作的路灯编号进行异或，最终结果即为唯一亮着的灯编号。这种方法空间复杂度低，且效率较高，但需要对位运算有较好的理解。

从题解质量来看，**位运算法**的题解普遍更优，代码简洁且效率高。而**模拟法**的题解虽然直观，但在大数据量下表现不佳。

### 所选高星题解

#### 题解1：Hamster_Air (5星)
- **关键亮点**：使用位运算（异或）高效解决问题，代码简洁且时间复杂度低。
- **代码核心思想**：通过异或运算将所有操作的路灯编号进行累加，最终结果即为唯一亮着的灯编号。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    int n,t,i,j,ans=0;
    double a;
    cin>>n;
    for(i=1;i<=n;i++)
    {
        cin>>a>>t;
        for(j=1;j<=t;j++)
            ans^=int(j*a);
    }
    cout<<ans<<endl;
    return 0;
}
```

#### 题解2：雨竹 (4.5星)
- **关键亮点**：详细解释了异或运算的原理，代码清晰且易于理解。
- **代码核心思想**：同样使用异或运算，代码结构与题解1类似，但增加了对异或运算的详细解释。
```cpp
#include<cstdio>  
#include<cstring>  
#include<cmath>  
#include<algorithm>  
using namespace std;  
int n,t;  
double a;  
int main()  
{  
    int ans=0;  
    scanf("%d",&n);  
    while (n--)  
    {  
        scanf("%lf",&a);
        scanf("%d",&t);  
        for (int i=1;i<=t;i++)  
        {  
            int x=(int)floor(a*i);  
            ans^=x;  
        }  
    }  
    printf("%d",ans);  
    return 0;  
}  
```

#### 题解3：shanjb0221 (4星)
- **关键亮点**：通过去重优化，减少了重复计算，提高了效率。
- **代码核心思想**：先对操作进行排序和去重，然后再使用异或运算，减少了不必要的计算。
```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
const int N=5e3+5;
int ans,n;
pair<double,int> a[N];
char del[N];
int main() {
    scanf("%d",&n);
    for(int i=0; i<n; ++i)scanf("%lf%d",&a[i].first,&a[i].second);
    sort(a,a+n);
    for(int i=0; i+1<n; ++i)
        if(!del[i]&&a[i]==a[i+1])del[i]=del[i+1]=1;
    for(int i=0; i<n; ++i)if(!del[i])
            for(int j=1; j<=a[i].second; ++j)ans^=int(a[i].first*j);
    printf("%d\n",ans);
}
```

### 最优关键思路与技巧

1. **位运算（异或）**：利用异或运算的性质，可以高效地找到唯一亮着的灯。异或运算具有以下性质：
   - 任何数与0异或等于它本身。
   - 任何数与自身异或等于0。
   - 异或运算满足交换律和结合律。

2. **去重优化**：对于重复的操作，可以通过排序和去重来减少计算量，提高效率。

### 可拓展之处

- **类似问题**：可以考虑其他使用位运算解决的问题，如找出数组中只出现一次的数字（LeetCode 136）。
- **优化思路**：在处理大数据量时，可以考虑使用更高效的数据结构或算法，如哈希表、分块处理等。

### 推荐洛谷题目

1. **P136 只出现一次的数字**：考察位运算的应用。
2. **P137 只出现一次的数字 II**：进一步考察位运算的复杂应用。
3. **P1161 开灯**：与本题类似，考察模拟和位运算的结合。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中遇到的精度问题，提醒大家在使用浮点数时要注意类型转换和精度处理。
- **顿悟感想**：通过本题，许多作者意识到位运算在解决某些问题时的强大能力，鼓励大家在遇到类似问题时多考虑位运算的解法。

---
处理用时：37.83秒
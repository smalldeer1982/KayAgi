# 题目信息

# 小 a 和 uim 之大逃离

## 题目背景

小 a 和 uim 来到雨林中探险。突然一阵北风吹来，一片乌云从北部天边急涌过来，还伴着一道道闪电，一阵阵雷声。刹那间，狂风大作，乌云布满了天空，紧接着豆大的雨点从天空中打落下来，只见前方出现了一个披头散发、青面獠牙的怪物，低沉着声音说：“呵呵，既然你们来到这，只能活下来一个！”。小 a 和他的小伙伴都惊呆了！


## 题目描述

瞬间，地面上出现了一个 $n\times m$ 的巨幅矩阵，矩阵的每个格子上有一坨 $0\sim k$ 不等量的魔液。

怪物各给了小 a 和 uim 一个魔瓶，说道，你们可以从矩阵的任一个格子开始，每次向右或向下走一步，从任一个格子结束。开始时小 a 用魔瓶吸收地面上的魔液，下一步由 uim 吸收，如此交替下去，并且要求最后一步必须由 uim 吸收。魔瓶只有 $k$ 的容量，也就是说，如果装了 $k+1$ 那么魔瓶会被清空成零，如果装了 $k+2$ 就只剩下 $1$，依次类推。

怪物还说道，最后谁的魔瓶装的魔液多，谁就能活下来。小 a 和 uim 感情深厚，情同手足，怎能忍心让小伙伴离自己而去呢？沉默片刻，小 a 灵机一动，如果他俩的魔瓶中魔液一样多，不就都能活下来了吗？小 a 和他的小伙伴都笑呆了！

现在他想知道他们都能活下来有多少种方法。

## 说明/提示

【题目来源】

lzn 改编

【样例解释】

样例解释：四种方案是：$(1,1)\to (1,2)$，$(1,1)\to (2,1)$，$(1,2)\to (2,2)$，$(2,1)\to (2,2)$。

【数据范围】

对于 $20\%$ 的数据，$n,m\leq 10$，$k\leq2$；

对于 $50\%$ 的数据，$n,m\leq 100$，$k\leq5$；

对于 $100\%$ 的数据，$1 \leq n,m\leq 800$，$1\leq k\leq 15$。


## 样例 #1

### 输入

```
2 2 3
1 1
1 1
```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）来解决矩阵路径问题，关键在于如何定义状态和转移方程。大多数题解采用了四维DP，状态定义为 `f[i][j][p][q]`，表示在位置 `(i,j)`，两人魔液差为 `p`，且当前由 `q`（0或1）吸收魔液的方案数。难点在于如何正确处理魔液差值的模运算，以及如何优化空间复杂度以避免内存溢出。

### 所选高质量题解

#### 1. 作者：kkksc03 (5星)
- **关键亮点**：思路清晰，状态转移方程简洁明了，代码可读性强，且对模运算的处理非常到位。
- **个人心得**：作者提到“魔瓶的容量为k，实际上就是动归时p需要对k+1取余数”，这一点帮助理解题目中的模运算要求。

```cpp
f[i][j][p][0] += f[i-1][j][(p-mapp[i][j]+k)%k][1];
f[i][j][p][0] += f[i][j-1][(p-mapp[i][j]+k)%k][1];
f[i][j][p][1] += f[i-1][j][(p+mapp[i][j])%k][0];
f[i][j][p][1] += f[i][j-1][(p+mapp[i][j])%k][0];
```

#### 2. 作者：SkyRainWind (4星)
- **关键亮点**：代码简洁，使用了滚动数组优化空间复杂度，且对模运算的处理非常清晰。
- **个人心得**：作者提到“卡内存”，通过调整数组大小避免了MLE问题，体现了对内存管理的重视。

```cpp
int dp[805][805][20][2];
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        for(int h=0;h<=k;h++) {
            dp[i][j][h][0] = (dp[i][j][h][0] + dp[i-1][j][(h-a[i][j]+k)%k][1]) % mod;
            dp[i][j][h][1] = (dp[i][j][h][1] + dp[i-1][j][(h+a[i][j])%k][0]) % mod;
        }
```

#### 3. 作者：桑梓暖阳 (4星)
- **关键亮点**：详细解释了差值的处理方式，特别是负数的模运算处理，思路清晰。
- **个人心得**：作者提到“把负数加上k+1”，这一技巧帮助解决了负数模运算的问题。

```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        for(int h=0;h<K;h++) {
            f[i+1][j][(h+a[i+1][j])%K][0] = (f[i+1][j][(h+a[i+1][j])%K][0] + f[i][j][h][1]) % mod;
            f[i+1][j][(h-a[i+1][j]+K)%K][1] = (f[i+1][j][(h-a[i+1][j]+K)%K][1] + f[i][j][h][0]) % mod;
        }
```

### 最优关键思路与技巧

1. **状态定义**：使用四维DP，状态定义为 `f[i][j][p][q]`，表示在位置 `(i,j)`，两人魔液差为 `p`，且当前由 `q` 吸收魔液的方案数。
2. **模运算处理**：在状态转移过程中，魔液差值需要对 `k+1` 取模，确保差值的正确性。
3. **空间优化**：使用滚动数组或减少数组维度来优化空间复杂度，避免内存溢出。

### 可拓展之处

- **类似题目**：可以扩展到其他路径问题，如带有权重或限制条件的路径计数问题。
- **算法套路**：类似的DP思路可以应用于其他需要记录状态差值的题目，如多米诺骨牌问题。

### 推荐题目

1. **P1282 多米诺骨牌**：考察差值的DP问题。
2. **P1048 采药**：经典的背包问题，与本题的模运算处理有相似之处。
3. **P1006 传纸条**：双路径DP问题，与本题的路径选择有相似之处。

### 个人心得总结

- **调试经历**：多位作者提到内存管理和模运算的处理是调试的重点，特别是避免MLE和TLE。
- **踩坑教训**：负数的模运算需要特别注意，通过加上 `k+1` 来解决负数问题。
- **顿悟感想**：通过优化状态定义和转移方程，可以显著提高代码的效率和可读性。

---
处理用时：43.92秒
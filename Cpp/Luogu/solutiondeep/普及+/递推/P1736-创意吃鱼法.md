# 题目信息

# 创意吃鱼法

## 题目背景

感谢@throusea 贡献的两组数据

## 题目描述

回到家中的猫猫把三桶鱼全部转移到了她那长方形大池子中，然后开始思考：到底要以何种方法吃鱼呢（猫猫就是这么可爱，吃鱼也要想好吃法 ^\_\*）。她发现，把大池子视为 $01$ 矩阵（$0$ 表示对应位置无鱼，$1$ 表示对应位置有鱼）有助于决定吃鱼策略。

在代表池子的 $01$ 矩阵中，有很多的正方形子矩阵，如果某个正方形子矩阵的某条对角线上都有鱼，且此正方形子矩阵的其他地方无鱼，猫猫就可以从这个正方形子矩阵“对角线的一端”下口，只一吸，就能把对角线上的那一队鲜鱼吸入口中。

猫猫是个贪婪的家伙，所以她想一口吃掉尽量多的鱼。请你帮猫猫计算一下，她一口下去，最多可以吃掉多少条鱼？


## 说明/提示

右上角的
```
1 0 0
0 1 0
0 0 1
```

### 数据范围及约定


- 对于 $30\%$ 的数据，有 $1\le n,m\le 100$；
- 对于 $60\%$ 的数据，有 $1\le n,m\le 1000$；
- 对于 $100\%$ 的数据，有 $1\le n,m\le 2500$。

## 样例 #1

### 输入

```
4 6
0 1 0 1 0 0
0 0 1 0 1 0
1 1 0 0 0 1
0 1 1 0 1 0
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在二维矩阵中找到满足特定条件的最大正方形子矩阵，且要求子矩阵的对角线上全为1，其他位置全为0。题解中主要采用了动态规划（DP）和暴力搜索两种思路，部分题解还结合了前缀和、二分查找等优化手段。以下是对题解的整理与对比：

1. **动态规划（DP）**：大多数题解采用了DP的思路，通过定义状态`f[i][j]`表示以`(i,j)`为右下角的最大正方形子矩阵的对角线长度。DP的难点在于如何保证子矩阵的其他位置全为0，通常通过预处理或实时计算来验证。
2. **暴力搜索**：部分题解采用了暴力搜索的思路，通过枚举每个点作为起点，向两个对角线方向扩展，结合前缀和验证子矩阵的合法性。虽然时间复杂度较高，但通过剪枝和优化，部分题解仍能通过测试。
3. **前缀和与二分查找**：部分题解结合了前缀和与二分查找，通过二分答案的方式减少验证次数，进一步优化了时间复杂度。

### 所选高星题解

#### 1. **题解作者：zhylj**  
**星级：★★★★★**  
**关键亮点**：  
- 通过定义`f[i][j]`表示以`(i,j)`为右下角的最大正方形子矩阵的对角线长度，状态转移方程清晰。
- 通过预处理`m1, m2, m3`分别表示向左、向右、向上的连续0的长度，确保子矩阵的其他位置全为0。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for(int i=1;i<n;i++)
    for(int j=0;j<m;j++)
        if(((j-1>=0&&f[i-1][j-1]>=1)||(j+1<m&&f[i-1][j+1]>=1))&&a[i][j]==1) {
            m1=0; m2=0; m3=0;
            for(int k=i-1;k>=0&&a[k][j]==0;k--,m1++);
            for(int k=j+1;k<m&&a[i][k]==0;k++,m2++);
            for(int k=j-1;k>=0&&a[i][k]==0;k--,m3++);
            f[i][j]=f[i-1][j-1]>=1? min(f[i-1][j-1],min(m1,m3))+1:min(f[i-1][j+1],min(m1,m2))+1;
        }
```

#### 2. **题解作者：SplenD1D**  
**星级：★★★★☆**  
**关键亮点**：  
- 通过定义`dp[i][j][k]`表示以`(i,j)`为起点向左上方或右上方延伸的最大对角线长度，状态转移方程清晰。
- 通过预处理`left`和`up`数组，记录每个点向左和向上的连续0的长度，确保子矩阵的其他位置全为0。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        if(a[i][j]) {
            int l=dp[i-1][j-1][0]+1, r=dp[i-1][j+1][1]+1;
            for(k=1;k<=dp[i-1][j-1][0];k++)
                if(a[i-k][j]||a[i][j-k]) { l=k; break; }
            for(k=1;k<=dp[i-1][j+1][1];k++)
                if(a[i-k][j]||a[i][j+k]) { r=k; break; }
            dp[i][j][0]=l, dp[i][j][1]=r, ans=max(max(dp[i][j][0],dp[i][j][1]),ans);
        }
```

#### 3. **题解作者：FCBM71**  
**星级：★★★★☆**  
**关键亮点**：  
- 通过暴力搜索结合剪枝，减少了不必要的计算，优化了时间复杂度。
- 通过预处理前缀和，快速验证子矩阵的合法性。
- 代码实现简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        if(a[i][j]) {
            int x2=i, y2=j, flag2=0, num=1;
            do {
                ++x2; ++y2;
                if(x2>n||y2>m) break;
                if(!a[x2][y2]) break;
                for(int k=i;k<x2;k++) if(a[k][y2]) { flag2=1; break; }
                for(int k=j;k<y2;k++) if(a[x2][k]) { flag2=1; break; }
                ++num;
            } while(!flag2);
            ans=max(ans,num);
        }
```

### 最优关键思路与技巧

1. **动态规划**：通过定义状态`f[i][j]`表示以`(i,j)`为右下角的最大正方形子矩阵的对角线长度，结合预处理或实时计算确保子矩阵的其他位置全为0。
2. **前缀和与二分查找**：通过前缀和快速计算子矩阵的和，结合二分查找减少验证次数，优化时间复杂度。
3. **剪枝与优化**：在暴力搜索中，通过剪枝减少不必要的计算，提高算法效率。

### 可拓展之处

1. **类似题目**：可以扩展到其他二维矩阵问题，如最大矩形、最大全1子矩阵等。
2. **优化思路**：可以结合其他数据结构（如线段树、树状数组）进一步优化时间复杂度。

### 推荐题目

1. **P1387 最大正方形**：考察二维矩阵中的最大全1正方形。
2. **P1739 最大矩形**：考察二维矩阵中的最大全1矩形。
3. **P2216 最大子矩阵**：考察二维矩阵中的最大子矩阵和。

### 个人心得摘录

- **调试经历**：部分题解中提到在调试过程中发现直接重置为1会导致错误，需要通过枚举新的长度来确保正确性。
- **踩坑教训**：在DP转移时，不能直接继承上一个状态的值，需要验证子矩阵的其他位置是否全为0。
- **顿悟感想**：通过预处理和剪枝，可以显著提高暴力搜索的效率，避免超时。

---
处理用时：57.74秒
# 题目信息

# 符文之语

## 题目背景

传说中珠穆朗玛峰下有座古代人修建的神庙，神庙的地下室里有古代王室的遗产，但数千年来从未有人到达过……探险者小 FF 一直梦想成为世界上最富有的人和最杰出的探险家并被永载史册。在证明了这个洞确实存在后，小 FF 做好了充足准备，来到了神庙。

## 题目描述

当小 FF 来到神庙时，神庙已经破败不堪了。但神庙的中央有一个光亮如新的石台。小 FF 走近石台，发现石台上有一个数串，而数串的上方刻着一串古老的符文之语。精通古符文之语的小 FF 不费吹灰之力就读懂了文章的意思，其大意是：

对于石台上的一串数字，你可以在适当的位置加入乘号（设加了 $k$ 个，当然也可不加，即分成 $k+1$ 个部分），设这 $k+1$ 个部分的乘积（如果 $k=0$，则乘积即为原数串的值）对 $m$ 的余数（即 $\bmod\ m$）为 $x$；

现求 $x$ 能达到的最小值及该情况下 $k$ 的最小值，以及 $x$ 能达到的最大值及该情况下的 $k$ 的最小值（可以存在 $x$ 的最小值与最大值相同的情况）。

小 FF 还知道，如果他找到了正确的答案，那么就可以通往神庙的下层了。但这个问题似乎不太好解决，小 FF 就找到了你，并答应找到财宝以后和你二八分（当然你拿二……）。

## 说明/提示

记 $L$ 表示字符串的长度。

- 对于 $30\%$ 的数据：$2 \le L \le 50$；
- 对于 $100\%$ 的数据：$2 \le L \le 1000$，$2 \le m \le 50$。

NOI 导刊 $2010$ 提高（$02$）

## 样例 #1

### 输入

```
4421

22

```

### 输出

```
0 1 21 0```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）来解决字符串分割后乘积取模的最小值和最大值问题。难点在于如何设计状态转移方程，尤其是如何处理模数运算和乘号的插入。大多数题解采用了二维DP数组，状态表示前i个字符的乘积对m取余后的值，转移时枚举乘号的位置和前一状态的值。优化点在于预处理区间乘积的模数，避免重复计算。

### 所选高星题解

#### 1. **作者：Mine_King (5星)**
- **关键亮点**：思路清晰，状态转移方程设计合理，代码简洁且优化到位。通过预处理区间乘积的模数，避免了重复计算，时间复杂度为O(L^2m)，适合大规模数据。
- **个人心得**：作者提到“不能用push型转移，必须用pull型转移”，强调了模数运算下状态转移的特殊性，这种思维方式值得借鉴。
- **核心代码**：
```cpp
for(int i=1;i<=n;i++)
    for(int x=0;x<m;x++)
        for(int j=i+1;j<=n;j++)
            dp[j][x*mul[i+1][j]%m]=min(dp[j][x*mul[i+1][j]%m],dp[i][x]+1);
```
- **实现思想**：通过三重循环枚举字符位置、模数值和乘号位置，更新DP数组。

#### 2. **作者：2018李泽明 (4星)**
- **关键亮点**：详细解释了DP状态的定义和转移过程，代码注释丰富，适合初学者理解。预处理区间乘积的模数，时间复杂度为O(L^2m)。
- **个人心得**：作者提到“方程不规范，爆零两行泪”，强调了代码规范的重要性。
- **核心代码**：
```cpp
for(int i=1;i<=lon;i++)
    for(int j=1;j<i;j++)
        for(int k=0;k<m;k++)
            if(f[j][k]+1<f[i][k*sum[j+1][i]%m])
                f[i][k*sum[j+1][i]%m]=f[j][k]+1;
```
- **实现思想**：通过三重循环枚举字符位置、模数值和乘号位置，更新DP数组。

#### 3. **作者：Boxxxxxx (4星)**
- **关键亮点**：通过优化预处理，避免了O(N^2)的预处理时间，直接在转移过程中计算区间乘积的模数，时间复杂度为O(N^2m)。
- **个人心得**：作者提到“他是对m取模！！！我当初用之前设置的mod取模wa了好多次”，强调了审题的重要性。
- **核心代码**：
```cpp
for(int i=1;i<=len;i++)
    for(int j=0;j<i;j++)
        for(int z=0;z<m;z++)
            f[i][(z*num[j])%m]=min(f[i][(z*num[j])%m],f[j][z]+1);
```
- **实现思想**：在转移过程中动态计算区间乘积的模数，减少预处理时间。

### 最优关键思路与技巧

1. **状态设计**：使用二维DP数组，状态表示前i个字符的乘积对m取余后的值。
2. **转移优化**：通过预处理区间乘积的模数，避免重复计算，提升效率。
3. **模数处理**：在模数运算下，使用乘法代替除法，避免逆元计算的复杂性。

### 可拓展之处

- **同类型题**：类似题目包括字符串分割后的最大值或最小值问题，如“乘积最大”问题。
- **算法套路**：DP+模数运算的组合在竞赛中常见，可以应用于其他需要处理模数的动态规划问题。

### 推荐题目

1. **P1773 符文之语_NOI导刊2010提高（02）**：本题的变种，考察字符串分割与模数运算。
2. **P1048 乘积最大**：考察字符串分割后的最大值问题。
3. **P1880 石子合并**：考察区间DP，与本题的区间分割思想类似。

### 个人心得总结

- **调试经历**：多位作者提到在模数处理上出错，强调了审题和代码规范的重要性。
- **顿悟感想**：通过乘法代替除法进行状态转移，解决了模数运算下的复杂性问题。

---
处理用时：32.49秒
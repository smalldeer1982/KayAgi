# 题目信息

# [USACO10DEC] Treasure Chest S

## 题目描述

Bessie and Bonnie have found a treasure chest full of marvelous gold coins! Being cows, though, they can't just walk into a store and buy stuff, so instead they decide to have some fun with the coins.

The N (1 <= N <= 5,000) coins, each with some value C\_i (1 <= C\_i <= 5,000) are placed in a straight line. Bessie and Bonnie take turns, and for each cow's turn, she takes exactly one coin off of either the left end or the right end of the line. The game ends when there are no coins left.

Bessie and Bonnie are each trying to get as much wealth as possible for themselves. Bessie goes first. Help her figure out the maximum value she can win, assuming that both cows play optimally.

Consider a game in which four coins are lined up with these values:

30  25  10  35

Consider this game sequence:

Bessie    Bonnie       New Coin

Player   Side   CoinValue   Total     Total         Line

Bessie   Right     35        35         0       30  25  10

Bonnie   Left      30        35        30         25  10

Bessie   Left      25        60        30           10

Bonnie   Right     10        60        40           --

This is the best game Bessie can play.

小 A 和小 B 在玩游戏。

初始时，有 $n$ 个硬币被摆成了一行，从左至右数第 $i$ 个硬币的价值为 $c_i$。

小 A 和小 B 每人一回合，在一个人的回合中，他可以选择**当前**硬币序列最左侧或者最右侧的硬币，并将他从序列中取出，将其价值累加到自己获得的累计价值中，然后进行另一个人的回合。当硬币全部被取走时，游戏结束。

请求出在双方都尽可能的使自己累计价值最大的情况下，若由小 A 进行第一回合，那么他能获得的累计价值最大是多少。

## 说明/提示

#### 输入输出样例 $1$ 解释

初始时，硬币序列为 $\{30,~25,~10,~35\}$。

第一回合，小 A 取走最右侧的硬币，序列变为 $\{30,~25,~10\}$，小 A 的累加价值为 $35$。

第二回合，小 B 取走最左侧的硬币，序列变为 $\{25,~10\}$，小 B 的累加价值为 $30$。

第三回合，小 A 取走最左侧的硬币，序列变为 $\{10\}$，小 A 的累加价值为 $35 + 25 = 60$。

第四回合，小 B 取走最左侧的硬币，序列变为空，小 B 的累加价值为 $30 + 10 = 40$，游戏结束。

小 A 获得的最大累计价值为 $60$。

#### 数据范围与约定

对于全部的测试点，$1 \leq n \leq 5 \times 10^3$，$1 \leq c_i \leq 5 \times 10^3$。

**提示：请注意，本题的空间限制为 $64$ Mib。**

## 样例 #1

### 输入

```
4 
30 
25 
10 
35 
```

### 输出

```
60 
```

# AI分析结果

### 综合分析与结论

本题是一个典型的区间DP问题，核心在于通过动态规划计算在双方都采取最优策略的情况下，先手能够获得的最大价值。题解中主要采用了以下几种思路：

1. **区间DP + 滚动数组优化**：大多数题解通过定义状态 `f[l][r]` 表示区间 `[l, r]` 内先手能获得的最大价值，并使用前缀和优化空间复杂度。由于空间限制，部分题解进一步使用滚动数组来减少内存消耗。
2. **贪心策略**：少数题解尝试使用贪心策略，通过模拟取硬币的过程来求解，但这种方法缺乏严格的数学证明，且在某些情况下可能无法得到最优解。
3. **动态规划 + 状态压缩**：部分题解通过状态压缩进一步优化空间复杂度，使用一维数组代替二维数组。

综合来看，**区间DP + 滚动数组优化**是最为稳健且高效的解法，能够有效处理本题的数据范围，并且在代码实现上也较为简洁。

### 所选高星题解

#### 1. 作者：逝星DS (4星)
**关键亮点**：
- 使用一维滚动数组优化空间复杂度，避免了二维数组的内存问题。
- 代码简洁，逻辑清晰，易于理解。
- 通过前缀和快速计算区间和，进一步优化了时间复杂度。

**核心代码**：
```cpp
for(int l=2;l<=N;l++)  {  //l为长度,注意从2开始； 
    for(int i=1;i+l-1<=N;i++)  {  //枚举head; 
        int j=i+l-1;  //计算出tail; 
        f[i]=s[j]-s[i-1]-min(f[i],f[i+1]);
    }
}
```
**实现思想**：通过一维数组 `f[i]` 表示以 `i` 为起点，长度为 `l` 的区间内先手能获得的最大价值，利用前缀和 `s[j] - s[i-1]` 计算区间和，并通过 `min(f[i], f[i+1])` 确保对手获得最小价值。

#### 2. 作者：＂黎筱っ (4星)
**关键亮点**：
- 使用滚动数组优化空间复杂度，代码实现简洁。
- 通过前缀和快速计算区间和，进一步优化了时间复杂度。
- 状态转移方程清晰，易于理解。

**核心代码**：
```cpp
for(int l = 2; l <= n; ++l)
    for(int i = 1; i + l - 1 <= n; ++i)
        f[i] = a[i + l - 1] - a[i - 1] - min(f[i + 1], f[i]);
```
**实现思想**：通过一维数组 `f[i]` 表示以 `i` 为起点，长度为 `l` 的区间内先手能获得的最大价值，利用前缀和 `a[i + l - 1] - a[i - 1]` 计算区间和，并通过 `min(f[i + 1], f[i])` 确保对手获得最小价值。

#### 3. 作者：K0stlin (4星)
**关键亮点**：
- 使用滚动数组优化空间复杂度，代码实现简洁。
- 通过前缀和快速计算区间和，进一步优化了时间复杂度。
- 状态转移方程清晰，易于理解。

**核心代码**：
```cpp
for(int j=2;j<=n;++j)//枚举区间右端点
    for(int i=j;i>=1;--i)//枚举区间左端点
        f[j&1][i]=sum[j]-sum[i-1]-min(f[!(j&1)][i],f[j&1][i+1]);//转移方程
```
**实现思想**：通过滚动数组 `f[j&1][i]` 表示以 `i` 为起点，长度为 `j` 的区间内先手能获得的最大价值，利用前缀和 `sum[j] - sum[i-1]` 计算区间和，并通过 `min(f[!(j&1)][i], f[j&1][i+1])` 确保对手获得最小价值。

### 最优关键思路与技巧

1. **区间DP + 滚动数组优化**：通过定义状态 `f[l][r]` 表示区间 `[l, r]` 内先手能获得的最大价值，并使用滚动数组优化空间复杂度，能够有效处理本题的数据范围。
2. **前缀和优化**：通过前缀和快速计算区间和，进一步优化了时间复杂度。
3. **状态转移方程**：`f[l][r] = sum[l][r] - min(f[l+1][r], f[l][r-1])`，确保对手获得最小价值，从而最大化先手的收益。

### 可拓展之处

1. **类似问题**：本题的解法可以推广到其他类似的区间DP问题，如石子合并、最长回文子序列等。
2. **状态压缩**：在空间复杂度较高的情况下，可以进一步使用状态压缩来优化内存使用。

### 推荐题目

1. **P1880 [NOI1995] 石子合并**：考察区间DP的经典题目，与本题类似。
2. **P1040 加分二叉树**：考察区间DP的应用，涉及树形结构。
3. **P1063 能量项链**：考察区间DP的应用，涉及环形结构。

### 个人心得摘录

- **调试经历**：部分题解中提到由于空间限制，尝试了多种优化方法，最终通过滚动数组成功解决。
- **踩坑教训**：部分题解提到贪心策略在某些情况下无法得到最优解，提醒我们在解题时要谨慎选择算法。
- **顿悟感想**：通过区间DP和滚动数组的结合，能够有效解决类似的最优化问题，这种思路在动态规划中非常实用。

---
处理用时：38.78秒
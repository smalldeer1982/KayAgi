# 题目信息

# 三只小猪

## 题目背景

你听说过三只小猪的故事吗？这是一个经典的故事。很久很久以前，有三只小猪。第一只小猪用稻草建的房子，第二个小猪用木棍建的房子，第三个小猪则使用砖做为材料。一只大灰狼想吃掉它们并吹倒了稻草和木棍建的房子。但是砖盖的房子很结实，狼最终也没有破坏掉，最后小猪们战胜了大灰狼并把它尾巴烧掉了。


## 题目描述

为了自己的安全，小猪们又建造了一个新砖房。但是现在问题出现了，怎样把三个小猪分配到两个房子里呢？第三只小猪是三只小猪中最聪明的一只，为了不浪费任何一个房子，它总共考虑了三种方案，如下图

 ![](https://cdn.luogu.com.cn/upload/pic/6862.png) 

“但是将来怎么办呢？”第三只小猪知道将来随着成员的增多，它们将会盖更多的房子。它想知道给定了房子和猪的数目后，房子的分配方案有多少，但这个问题对于它来说，很明显有点难了，你能帮小猪解决这个问题吗？


## 样例 #1

### 输入

```
4 2```

### 输出

```
7```

## 样例 #2

### 输入

```
6 7```

### 输出

```
0```

# AI分析结果

### 综合分析与结论

本题的核心是计算将n只小猪分配到m个房子中的方案数，本质上是求第二类斯特林数。由于数据范围较大（n, m ≤ 50），直接使用递推公式会导致数值溢出，因此需要使用高精度计算。大多数题解都采用了递推公式并结合高精度加法与乘法来解决问题，部分题解还提供了Python的实现，利用其内置的高精度支持简化了代码。

### 题解评分与亮点

#### 1. 作者：_ZZH (★★★★★)
- **关键亮点**：提供了详细的递推公式推导，并实现了高精度加法和乘法。代码结构清晰，注释详细，适合初学者理解。
- **个人心得**：作者提到“这种数就是将n个不同的元素拆分成m个集合的方案数，又称：第二类斯特林数”，帮助读者理解问题的本质。
- **核心代码**：
  ```cpp
  void _change(int x,int y) {
      if(y>x)return;
      if(x==1&&y==1)return;
      for(int i=1;i<=_size;i++) _ans[i]=0;
      _size=1;
      int _x=0;
      for(int i=1;i<=f[x-1][y][0];i++) {
          _ans[i]=f[x-1][y][i]*y+_x;
          _x=_ans[i]/10;
          _ans[i]%=10;
      }
      _size=f[x-1][y][0];
      if(_x!=0) _ans[++_size]=_x;
      f[x][y][0]=1;
      _x=0;
      while(f[x][y][0]<=f[x-1][y-1][0]||f[x][y][0]<=_size) {
          f[x][y][f[x][y][0]]=f[x-1][y-1][f[x][y][0]]+_ans[f[x][y][0]]+_x;
          _x=f[x][y][f[x][y][0]]/10;
          f[x][y][f[x][y][0]]%=10;
          f[x][y][0]++;
      }
      f[x][y][f[x][y][0]]=_x;
      if(f[x][y][f[x][y][0]]==0&&f[x][y][0]!=1) f[x][y][0]--;
  }
  ```
  **核心思想**：通过高精度加法和乘法实现递推公式，确保数值不溢出。

#### 2. 作者：xrk2006 (★★★★☆)
- **关键亮点**：详细介绍了第二类斯特林数的定义和递推公式，并提供了Python的实现，代码简洁易懂。
- **个人心得**：作者提到“这道题和P1655小朋友的球实在是太像了”，帮助读者联想到类似的题目。
- **核心代码**：
  ```python
  def work(n, m):
      f = [[0 for i in range(300)] for i in range(300)]
      for i in range(1, n + 1):
          f[i][1] = 1
          for j in range(2, m + 1):
              f[i][j] = f[i - 1][j - 1] + j * f[i - 1][j]
      return f[n][m]
  ```
  **核心思想**：利用Python的高精度支持，直接实现递推公式，简化了代码。

#### 3. 作者：TLEphage (★★★★☆)
- **关键亮点**：提供了递推公式的详细推导，并实现了高精度加法和乘法。代码结构清晰，适合初学者理解。
- **个人心得**：作者提到“这道题还是很水的”，鼓励读者不要被题目难度吓倒。
- **核心代码**：
  ```cpp
  node add(node a,node b) {
      node c;int tot=max(a.tot,b.tot);
      memset(c.num,0,sizeof(c.num));
      for(int i=1;i<=tot;i++) c.num[i]=a.num[i]+b.num[i];
      for(int i=1;i<=tot;i++) {
          if(i==tot&&c.num[i]>=10) ++tot;
          c.num[i+1]+=c.num[i]/10;
          c.num[i]%=10;
      }
      c.tot=tot;
      return c;
  }
  ```
  **核心思想**：通过高精度加法和乘法实现递推公式，确保数值不溢出。

### 最优关键思路与技巧
1. **递推公式**：第二类斯特林数的递推公式为 `S(n, m) = S(n-1, m-1) + m * S(n-1, m)`，这是解决问题的核心。
2. **高精度计算**：由于数值较大，必须使用高精度加法和乘法来避免溢出。
3. **Python简化**：Python内置的高精度支持可以大大简化代码实现，适合快速解题。

### 可拓展之处
- **类似题目**：可以尝试解决其他涉及第二类斯特林数的问题，如“小朋友的球”（P1655）等。
- **高精度优化**：可以进一步优化高精度计算的效率，例如使用更高效的数据结构或算法。

### 推荐题目
1. [P1655 小朋友的球](https://www.luogu.com.cn/problem/P1655)
2. [P5824 十二重计数法](https://www.luogu.com.cn/problem/P5824)
3. [P188453 十二重计数法【弱化版】](https://www.luogu.com.cn/problem/T188453)

### 个人心得总结
- **调试经历**：部分作者提到在实现高精度计算时遇到了数值溢出的问题，通过增加位数和优化计算顺序解决了问题。
- **顿悟感想**：有作者提到“这道题还是很水的”，鼓励读者不要被题目难度吓倒，保持信心。

---
处理用时：43.71秒
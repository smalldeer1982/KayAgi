# 题目信息

# [Code+#1] 找爸爸

## 题目描述

小 A 最近一直在找自己的爸爸，用什么办法呢，就是 DNA 比对。

小 A 有一套自己的 DNA 序列比较方法，其最终目标是最大化两个 DNA 序列的相似程度，具体步骤如下：


1. 给出两个 DNA 序列，第一个长度为 $n$，第二个长度为 $m$。

2. 在两个序列的任意位置插入任意多的空格，使得两个字符串长度相同

3. 逐位进行匹配，**如果两个序列相同位置上的字符都不是空格**，假设第一个是 $x$，第二个是 $y$，那么他们的相似程度由 $d(x,y)$ 定义。对于两个序列中任意一段极长的长度为 $k$ 的连续空格，我们定义这段空格的相似程度为 $g(k)=-A-B(k-1)$。


那么最终两个序列的相似程度就是所有的 $d(x,y)$ 加上所有的极长空格段的相似程度之和。

现在小 A 通过某种奥妙重重的方式得到了小 B 的 DNA 序列中的一段，他想请你帮他算一下小 A 的 DNA 序列和小 B 的 DNA 序列的最大相似程度。


## 说明/提示

### 样例解释

首先，将序列补成如下形式（"-"代表空格）

```cpp
ATGG--
AT--CC
```
然后所有 $d(x,y)$ 的和为 $d(A,A)+d(T,T)=10$

所有极长连续空格段的相似程度之和为 $g(2)+g(2)=-6$

总和为 $4$，可以验证，这是相似程度最大的情况。

对于所有测试点，有 $0< B<A \le 1000, -1000\le d(x,y)\le 1000,d(x,y)=d(y,x)$，序列只包含${A,T,G,C}$四种字符。

 ![](https://cdn.luogu.com.cn/upload/pic/12822.png) 

来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/卢政荣 命题/卢政荣 验题/何昊天

Git Repo：https://git.thusaac.org/publish/CodePlus201711

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
ATGG
ATCC
5 -4 -4 -4 
-4 5 -4 -4 
-4 -4 5 -4 
-4 -4 -4 5 
2 1```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

该题目要求通过动态规划（DP）来计算两个DNA序列的最大相似度，难点在于如何处理空格的插入及其对相似度的影响。大多数题解采用了三维DP数组，分别表示两个序列的匹配位置和末尾空格的状态（无空格、A串空格、B串空格）。通过分类讨论，避免了两个序列同时插入空格的情况，从而简化了状态转移方程。

### 所选高星题解

#### 1. 作者：Elegia (5星)
**关键亮点**：
- **状态定义清晰**：使用`dp[i][j][k]`表示A串匹配到第i位，B串匹配到第j位，末尾空格状态为k时的最大相似度。
- **状态转移简洁**：通过分类讨论，分别处理无空格、A串空格、B串空格的情况，避免了两个序列同时插入空格的情况。
- **边界处理完善**：初始化时考虑了全空格的情况，并合理处理了边界条件。

**核心代码**：
```cpp
for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j) {
        dp[i][j][0] = *max_element(dp[i - 1][j - 1], dp[i - 1][j - 1] + 3) + d[x[i]][y[j]];
        dp[i][j][1] = max(max(dp[i][j - 1][0] - a, dp[i][j - 1][1] - b), dp[i][j - 1][2] - a);
        dp[i][j][2] = max(max(dp[i - 1][j][0] - a, dp[i - 1][j][2] - b), dp[i - 1][j][1] - a);
    }
```
**实现思想**：通过`max_element`函数简化了无空格状态的转移，同时分别处理A串和B串插入空格的情况。

#### 2. 作者：K2sen (4星)
**关键亮点**：
- **状态转移方程清晰**：详细解释了每个状态的转移来源，特别是空格的处理。
- **边界条件处理合理**：初始化时考虑了全空格的情况，并合理处理了边界条件。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
        f[i][j][0] = max(f[i - 1][j - 1][0], max(f[i - 1][j - 1][1], f[i - 1][j - 1][2])) + d[x[i]][y[j]];
        f[i][j][1] = max(f[i][j - 1][1] - b, max(f[i][j - 1][0] - a, f[i][j - 1][2] - a));
        f[i][j][2] = max(f[i - 1][j][2] - b, max(f[i - 1][j][0] - a, f[i - 1][j][1] - a));
    }
```
**实现思想**：通过分类讨论，分别处理无空格、A串空格、B串空格的情况，避免了两个序列同时插入空格的情况。

#### 3. 作者：HerikoDeltana (4星)
**关键亮点**：
- **状态定义清晰**：使用`f[i][j][p]`表示A串匹配到第i位，B串匹配到第j位，末尾空格状态为p时的最大相似度。
- **状态转移方程详细**：详细解释了每个状态的转移来源，特别是空格的处理。

**核心代码**：
```cpp
for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j) {
        f[i][j][0] = hmax(f[i - 1][j - 1][0], hmax(f[i - 1][j - 1][1], f[i - 1][j - 1][2])) + D[a1[i]][a2[j]];
        f[i][j][1] = hmax(f[i][j - 1][0] - A, hmax(f[i][j - 1][1] - B, f[i][j - 1][2] - A));
        f[i][j][2] = hmax(f[i - 1][j][0] - A, hmax(f[i - 1][j][1] - A, f[i - 1][j][2] - B));
    }
```
**实现思想**：通过分类讨论，分别处理无空格、A串空格、B串空格的情况，避免了两个序列同时插入空格的情况。

### 最优关键思路与技巧
1. **状态定义**：使用三维DP数组，分别表示两个序列的匹配位置和末尾空格的状态。
2. **状态转移**：通过分类讨论，分别处理无空格、A串空格、B串空格的情况，避免了两个序列同时插入空格的情况。
3. **边界处理**：初始化时考虑了全空格的情况，并合理处理了边界条件。

### 可拓展之处
该题的DP思路可以拓展到其他需要处理插入或删除操作的序列匹配问题，如字符串编辑距离、序列对齐等。

### 推荐题目
1. [P1279 字符串编辑距离](https://www.luogu.com.cn/problem/P1279)
2. [P1143 最长公共子序列](https://www.luogu.com.cn/problem/P1143)
3. [P1439 最长公共子序列（LCS）](https://www.luogu.com.cn/problem/P1439)

### 个人心得摘录
- **调试经历**：部分题解提到在初始化时未正确处理边界条件，导致WA，提醒我们在DP问题中要特别注意边界条件的处理。
- **顿悟感想**：通过分类讨论，避免了两个序列同时插入空格的情况，简化了状态转移方程，使得问题更容易解决。

---
处理用时：46.19秒
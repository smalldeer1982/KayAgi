# 题目信息

# P哥破解密码

## 题目背景

P 哥是一个经常丢密码条的男孩子。

在 ION8102 赛场上，P 哥又弄丢了密码条，笔试满分的他当然知道这可是要扣 $5$ 分作为惩罚的，于是他开始破解 IONXunil 系统的密码。

## 题目描述

定义一个串合法，当且仅当串只由 $\verb!A!$ 和 $\verb!B!$ 构成，且没有连续的 $3$ 个 $\verb!A!$。P 哥知道，密码就是长度为 $N$ 的合法字符串数量对 $19260817$ 取模的结果。但是 P 哥不会算，所以他只能把 $N$ 告诉你，让你来算。

至于为什么要对这个数取模，好像是因为纪念某个人，但到底是谁，P 哥也不记得了。

然而他忘记字符串长度 $N$ 应该是多少了，于是他准备试 $M$ 组数据。

## 说明/提示

### 样例部分解释 :。

长度为 $1$ 时只有 $\verb!A!$ 和 $\verb!B!$ 两种排列，都是合法的。

长度为 $3$ 时除了 $\verb!AAA!$ 是不合法的其他都是可以的，故有 $2^3-1$ 种。

### 数据范围。

- 对于 $20\%$ 数据，全部 $N\leq20$，$M\leq2$；
- 对于 $70\%$ 数据，全部 $N\leq10^7$；
- 对于 $100\%$ 数据，全部 $N\leq10^9$，$M\leq10$。

## 样例 #1

### 输入

```
3
1
3
6
```

### 输出

```
2
7
44
```

# AI分析结果

### 综合分析与结论

本题的核心是计算长度为 \(N\) 的合法字符串数量，合法字符串的定义是由 `A` 和 `B` 构成且没有连续的 3 个 `A`。由于 \(N\) 的范围很大（\(N \leq 10^9\)），直接递推会超时，因此需要使用矩阵快速幂优化递推。

大部分题解都采用了矩阵快速幂的思路，通过构造转移矩阵来优化递推过程。不同题解的区别主要在于矩阵的构造方式、初始状态的设定以及代码实现的细节。部分题解还提供了打表、递推公式推导等辅助思路。

### 所选高星题解

#### 1. 题解作者：灯芯糕 (5星)
**关键亮点**：
- 详细解释了递推公式的推导过程，帮助理解矩阵构造的逻辑。
- 提供了两种优化方案：打表和矩阵快速幂，适合不同需求的读者。
- 代码实现清晰，矩阵乘法和快速幂的实现简洁明了。

**个人心得**：
- 作者提到“码字挺累的”，表明题解撰写过程中投入了大量精力，确保了内容的详细和准确。

**核心代码**：
```cpp
struct ju{
	long long s[3][3];
};
ju cheng(ju a,ju b){ // 矩阵乘法
	ju c;
	for(int i=0;i<3;i++)for(int j=0;j<3;j++)c.s[i][j]=0;
	for(int i=0;i<3;i++)
	  for(int j=0;j<3;j++)
	    for(int k=0;k<3;k++)
	      c.s[i][j]+=a.s[i][k]*b.s[k][j],c.s[i][j]%=19260817;
	return c;
}
ju fast(int n){ // 快速幂
	ju c,d;
	c.s[0][0]=c.s[0][1]=c.s[0][2]=c.s[1][0]=c.s[2][1]=1;
	c.s[1][1]=c.s[1][2]=c.s[2][0]=c.s[2][2]=0;
	if(n==1)return c;
	d=fast(n/2);
	if(n%2==0)return cheng(d,d);
	return cheng(cheng(d,d),c);
}
```

#### 2. 题解作者：Mr_Wu (4.5星)
**关键亮点**：
- 递推公式的推导过程清晰，矩阵构造的逻辑明确。
- 代码实现简洁，矩阵乘法和快速幂的实现高效。

**核心代码**：
```cpp
struct Matrix{
	ll num[3][3];
	Matrix(){
		memset(num, 0, sizeof num);
	}
};
Matrix mul(Matrix x, Matrix y){ // 矩阵乘法
	Matrix z;
	for (R ll k=0; k<3; k++)
		for (R ll i=0; i<3; i++)
			for (R ll j=0; j<3; j++)
				(z.num[i][j]+=x.num[i][k]*y.num[k][j])%=mod;
	return z;
}
Matrix quick_pow(Matrix x, ll y){ // 快速幂
	Matrix z;
	z.num[0][0]=z.num[1][1]=z.num[2][2]=1;
	for (; y; y>>=1){
		if (y&1) z=mul(z, x);
		x=mul(x, x);
	}
	return z;
}
```

#### 3. 题解作者：DPair (4星)
**关键亮点**：
- 递推公式的推导过程详细，矩阵构造的逻辑清晰。
- 代码实现简洁，矩阵乘法和快速幂的实现高效。

**核心代码**：
```cpp
struct Matrix{
    int m[4][4];
    Matrix(){mem(m,0);}
    friend Matrix operator *(Matrix a,Matrix b){ // 矩阵乘法
        Matrix c;
        rep(i,1,3)
            rep(k,1,3)
                rep(j,1,3)
                    c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j])%mod;
        return c;
    }
    friend Matrix operator ^(Matrix a,int k){ // 快速幂
        Matrix res;
        rep(i,1,3)res.m[i][i]=1;
        for(;k;k>>=1){
            if(k&1)res=res*a;
            a=a*a;
        }
        return res;
    }
};
```

### 最优关键思路与技巧

1. **矩阵快速幂优化递推**：通过构造转移矩阵，将递推问题转化为矩阵乘法问题，利用快速幂将时间复杂度从 \(O(N)\) 降为 \(O(\log N)\)。
2. **递推公式推导**：通过分析合法字符串的构成，推导出递推公式，进而构造转移矩阵。
3. **代码实现技巧**：矩阵乘法和快速幂的实现要简洁高效，避免冗余计算。

### 可拓展之处

1. **同类型题**：类似的递推问题，如斐波那契数列、卡特兰数等，都可以通过矩阵快速幂优化。
2. **类似算法套路**：动态规划中的状态转移问题，如果状态转移方程是线性的，都可以考虑用矩阵快速幂优化。

### 推荐题目

1. [P1939 矩阵加速（数列）](https://www.luogu.com.cn/problem/P1939)
2. [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)
3. [P3390 矩阵快速幂](https://www.luogu.com.cn/problem/P3390)

### 个人心得总结

- **调试经历**：部分题解提到在推导递推公式和构造矩阵时遇到困难，通过反复调试和验证最终找到正确的构造方式。
- **踩坑教训**：矩阵乘法的实现要注意边界条件和模运算，避免溢出和错误。
- **顿悟感想**：通过矩阵快速幂优化递推问题，不仅提高了效率，也加深了对线性代数和动态规划的理解。

---
处理用时：44.82秒
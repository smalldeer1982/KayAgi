# 题目信息

# 选择客栈 加强版

## 题目描述

丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。

每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。

两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。

晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$ 。

他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。 

## 说明/提示

【样例解释】 

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textsf{客栈编号} & \text{①} & \text{②} & \text{③} & \text{④} & \text{⑤} \\\hline
\textsf{色调} & 0 & 1 & 0 & 1 & 1 \\\hline
\textsf{最低消费} & 5 & 3 & 2 & 4 & 5 \\ \hline
\end{array}$$


二人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤。

但是若选择住 ④⑤ 号客栈的话，④⑤ 号客栈之间的咖啡店的最低消费是 $4$，而两人能承受的最低消费是 $3$ 元，所以不满足要求。因此只有前 $3$ 种方案可选。

【数据范围】  
对于 $25\%$ 的数据，$n\leq 100$；  
对于 $40\%$ 的数据，$n\leq 1000$；   
对于 $80\%$ 的数据，$n\leq 2 \times 10^5$，$k \leq 50$；   
对于 $100\%$ 的数据，$2\leq n\leq2\times 10^6$，$1 \le k\leq 10^4$，$0\leq p\leq 100$，$0\leq$ 最低消费 $\leq 100$ 。

## 样例 #1

### 输入

```
5 2 3
0 5
1 3
0 2
1 4
1 5```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在O(n)时间复杂度内统计满足条件的客栈对。大多数题解都采用了类似的思路：通过维护一个“最近满足条件的咖啡店”的位置，并结合颜色的前缀和来快速计算合法方案数。以下是各题解的要点总结：

1. **时间复杂度**：大多数题解都实现了O(n)的时间复杂度，符合题目要求。
2. **数据结构**：常用的数据结构包括数组、前缀和、以及颜色统计数组。
3. **优化技巧**：通过维护“最近满足条件的咖啡店”位置，避免了重复计算，提升了效率。
4. **代码实现**：部分题解代码较为简洁，但有些题解的代码冗余或优化过度，影响了可读性。

### 评分较高的题解

#### 1. 作者：CCF_zkskyer (赞：18)  
**星级：4.5**  
**关键亮点**：  
- 思路清晰，通过维护`aft[i]`、`tot[i]`、`numb[i]`三个数组，分别记录最后一个颜色为`i`的客栈位置、同颜色方案数、以及颜色为`i`的客栈总数。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for (register int i=1;i<=n;++i) {
    scanf("%lld%lld",&col,&pri);
    if (pri<=p) bef=i;
    if (bef>=aft[col]) tot[col]=numb[col];
    ans+=tot[col];
    aft[col]=i;
    numb[col]++;
}
```
**核心思想**：通过维护`bef`记录最近满足条件的咖啡店位置，结合颜色统计数组快速计算合法方案数。

#### 2. 作者：一扶苏一 (赞：13)  
**星级：4.0**  
**关键亮点**：  
- 通过枚举右端点，结合前缀和快速计算合法方案数。
- 使用了可持久化线段树的思路，但实际实现中通过维护当前`x`的位置，避免了复杂数据结构的使用。

**核心代码**：
```cpp
for (int i = 1; i <= n; ++i) {
    qr(col[i]); qr(fee[i]);
    if (fee[i] <= p) {
        for (int j = i - 1; fee[j] > p; --j) {
            ++cnt[col[j]];
        }
    }
    ans += cnt[col[i]];
    if (fee[i] <= p) {
        ++cnt[col[i]];
    }
}
```
**核心思想**：通过维护`cnt`数组记录每种颜色的合法方案数，结合`fee[i] <= p`的条件快速更新。

#### 3. 作者：Origin0107 (赞：2)  
**星级：4.0**  
**关键亮点**：  
- 通过维护`can_last`记录最近满足条件的咖啡店位置，结合`dp`数组快速计算合法方案数。
- 代码逻辑清晰，易于理解。

**核心代码**：
```cpp
for(int i=1;i<=n;i++) {
    int k=col[i];
    if(can[i]) dp[i]=num[k];
    else if(can_last.num>=last[k]&&can_last.num) dp[i]=num[k];
    else dp[i]=dp[last[k]];
    last[k]=i;
    if(can[i]) {
        can_last.num=i;
        can_last.col=k;
    }
    num[k]++;
}
```
**核心思想**：通过`dp`数组记录每个位置的合法方案数，结合`can_last`快速更新。

### 最优关键思路与技巧

1. **维护最近满足条件的位置**：通过维护一个变量记录最近满足条件的咖啡店位置，可以快速判断当前客栈是否合法。
2. **颜色前缀和**：通过维护每种颜色的前缀和，可以快速计算合法方案数，避免重复计算。
3. **枚举右端点**：通过枚举右端点，结合前缀和快速计算合法方案数，避免了双重循环。

### 可拓展之处

1. **类似问题**：类似的问题可以扩展到其他区间统计问题，如统计满足某些条件的子数组数量。
2. **数据结构优化**：可以使用更高级的数据结构（如线段树、树状数组）来进一步优化时间复杂度。

### 推荐题目

1. [P1311 选择客栈](https://www.luogu.com.cn/problem/P1311)  
2. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)  
3. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)  

### 个人心得摘录

- **调试经历**：部分题解提到在调试过程中发现`long long`未开导致WA，提醒了数据类型的重要性。
- **踩坑教训**：有些题解在优化过程中过度使用`#pragma`，导致代码可读性下降，提醒了优化与代码简洁的平衡。
- **顿悟感想**：通过维护最近满足条件的位置，可以大大简化问题，体现了算法设计中的“贪心”思想。

---
处理用时：36.17秒
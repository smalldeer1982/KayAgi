# 题目信息

# 「Stoi2031」枫

## 题目背景

> 缓缓飘落的枫叶像思念 为何挽回要赶在冬天来之前 爱你穿越时间 两行来自秋末的眼泪 让爱渗透了地面 我要的只是你在我身边 ——《枫》

## 题目描述

冬很喜欢枫叶。她家门前有一棵枫树，树上落下了 $n$ 片叶子。冬将它们编号为 $1$ 到 $n$。她希望这些枫叶不要这样被人踩碎后烂在地里，所以决定把它们捡起来。她称将剩余未捡起来的枫叶按编号从小到大或从大到小的顺序排序后，先捡起第一片枫叶，然后每隔 $k$ 片捡起一片称为一次 **挽回**。她会一直进行 **挽回**，第一次 **挽回** 从小到大，之后每次 **挽回** 的顺序都和上次不同（即上次从小到大这次就从大到小，反之亦然），直到最后一片枫叶也被捡起。她认为最后一片捡起的枫叶代表了 **思念**，能带来幸福。她希望获得更多的幸福，所以她会很多次地问你 $n$ 和 $k$ 取某两个值时她得到的 **思念** 的编号。

## 说明/提示

#### 简述版题意：

给定 $n,k$，对 $1,2,\dots,n$ 一直操作，每次操作交替从小到大或从大到小的顺序取走当前的第 $(k+1)x+1$ 个数（$x \in \mathbb{Z_{\ge 0}}$ 且 $(k+1)x+1$ 不超过剩余数总数），求最后一个取走的数的编号。多次询问。

#### 样例解释：

限于篇幅，只对样例 $2$ 作解释。

对于第 $2$ 行：

对于第一次询问，地上只有 $1$ 片枫叶，此即 **思念**。

对于第二次询问，冬第一次 **挽回** 时依次捡起了 $1,3$ 两片枫叶，转身后只剩下 $2$，即 **思念**。

对于第 $3$ 行：

对于第一次询问，冬第一次 **挽回** 时捡起了 $1$ 号枫叶，转身后剩下 $2$，即 **思念**。

对于第二次询问，冬第一次 **挽回** 时捡起了 $1,4$ 两片枫叶，第二次 **挽回** 捡起了 $3$，剩下 $2$，即 **思念**。

对于第三次询问，冬第一次捡起了 $1,4,7$，第二次捡起了 $6,2$，第三次捡起了 $3$，此时剩下 $5$，即 **思念**。

#### 数据范围：

**本题每个数据点（除第 $1$ 个外）输入数据除数据组数 $t$ 以及最后一行（第 $t+1$ 行）外与前一个数据点输入数据完全相同。各个数据点的数据范围及特殊限制如下。**

| Testdata No. | $q \le$ | $m \le$ | 特殊限制 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $2$ | $3$ | 为样例 $1$ | $3$ |
| $2$ | $3$ | $7$ | 为样例 $2$ | $7$ |
| $3$ | $7$ | $10$ | 为样例 $3$ | $3$ |
| $4$ | $10$ | $30$ | 无 | $3$ |
| $5$ | $30$ | $70$ | 无 | $7$ |
| $6$ | $70$ | $100$ | 无 | $7$ |
| $7$ | $100$ | $300$ | 无 | $7$ |
| $8$ | $300$ | $700$ | 无 | $10$ |
| $9$ | $700$ | $10^3$ | 无 | $3$ |
| $10$ | $10^3$ | $3 \times 10^3$ | 无 | $3$ |
| $11$ | $3 \times 10^3$ | $7 \times 10^3$ | 无 | $1$ |
| $12$ | $7 \times 10^3$ | $10^4$ | 无 | $13$ |
| $13$ | $10^4$ | $3 \times 10^4$ | 无 | $3$ |
| $14$ | $3 \times 10^4$ | $7 \times 10^4$ | 无 | $3$ |
| $15$ | $7 \times 10^4$ | $10^5$ | 无 | $10$ |
| $16$ | $10^5$ | $3 \times 10^5$ | 无 | $13$ |
| $17$ | $3 \times 10^5$ | $7 \times 10^5$ | 无 | $1$ |
| $18$ | $7 \times 10^5$ | $10^6$ | 无 | $3$ |

**本题读入量较大，可以选择使用比赛描述中的快速读入模板以加快读入速度。**

## 样例 #1

### 输入

```
1
2 3 1 3
```

### 输出

```
1 2
```

## 样例 #2

### 输入

```
2
2 3 1 3
3 7 2 4 7
```

### 输出

```
1 2
2 2 5
```

## 样例 #3

### 输入

```
3
2 3 1 3
3 7 2 4 7
7 10 1 2 3 6 7 8 10
```

### 输出

```
1 2
2 2 5
1 2 2 3 4 6 6
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过递推的方式，模拟每次“挽回”操作后剩余的枫叶数量，并最终找到最后一个被捡起的枫叶编号。大多数题解都采用了递推的思路，通过计算每次操作后剩余的枫叶数量，并结合翻转顺序的特性，推导出当前状态的答案。递推的核心在于从子问题的解推导出当前问题的解，且由于每次操作后顺序会翻转，因此需要特别注意翻转后的位置计算。

### 所选高星题解

#### 1. 作者：fengwu (4星)
**关键亮点**：
- 简洁明了的递推思路，代码仅20行，易于理解。
- 通过计算每次操作后剩余的枫叶数量，并结合翻转顺序的特性，推导出当前状态的答案。
- 代码结构清晰，直接输出结果，适合快速实现。

**核心代码**：
```cpp
int las=i-(i-1)/(k+1)-1;
int pos=las-ans[las]+1;
ans[i]=pos+(pos-1)/k+1;
```
**核心思想**：通过计算每次操作后剩余的枫叶数量 `las`，并结合翻转顺序的特性，推导出当前状态的答案 `ans[i]`。

#### 2. 作者：Lagerent (4星)
**关键亮点**：
- 详细解释了递推的过程，特别是翻转顺序后的位置计算。
- 通过图示辅助理解，帮助读者更好地掌握递推的核心思想。
- 代码结构清晰，注释详细，适合初学者学习。

**核心代码**：
```cpp
int last = i - 1 - (i - 1) / (k + 1);
int pos = last - ans[last] + 1;
ans[i] = pos + (pos - 1) / k + 1;
```
**核心思想**：通过计算每次操作后剩余的枫叶数量 `last`，并结合翻转顺序的特性，推导出当前状态的答案 `ans[i]`。

#### 3. 作者：User_Authorized (4星)
**关键亮点**：
- 详细解释了递推的转移方程，特别是如何通过子问题的解推导出当前问题的解。
- 通过数学公式清晰地展示了递推的过程，帮助读者更好地理解。
- 代码结构清晰，注释详细，适合深入学习。

**核心代码**：
```cpp
valueType const from = i - (i + k) / (k + 1);
valueType const x = from + 1 - F[from];
F[i] = x + (x + k - 1) / (k);
```
**核心思想**：通过计算每次操作后剩余的枫叶数量 `from`，并结合翻转顺序的特性，推导出当前状态的答案 `F[i]`。

### 最优关键思路与技巧

1. **递推思想**：通过从子问题的解推导出当前问题的解，递推的核心在于每次操作后剩余的枫叶数量，并结合翻转顺序的特性，推导出当前状态的答案。
2. **翻转顺序的处理**：由于每次操作后顺序会翻转，因此需要特别注意翻转后的位置计算，通常通过 `last - ans[last] + 1` 来实现。
3. **数学公式的应用**：通过数学公式清晰地展示了递推的过程，帮助读者更好地理解递推的核心思想。

### 可拓展之处

1. **约瑟夫问题的变种**：本题可以看作是约瑟夫问题的一个变种，可以通过类似的递推思路解决。
2. **翻转顺序的应用**：在其他需要处理顺序翻转的问题中，可以借鉴本题的处理方法，通过计算翻转后的位置来推导出当前状态的答案。

### 推荐相似题目

1. **P1996 约瑟夫问题**：经典的约瑟夫问题，可以通过递推或模拟的方式解决。
2. **P1886 滑动窗口**：通过滑动窗口的方式处理序列问题，与本题的递推思路有相似之处。
3. **P1048 采药**：通过动态规划的方式处理序列问题，与本题的递推思路有相似之处。

### 个人心得摘录

- **fengwu**：通过递推的方式，从子问题的解推导出当前问题的解，代码简洁明了，易于理解。
- **Lagerent**：通过图示辅助理解，帮助读者更好地掌握递推的核心思想，代码结构清晰，注释详细。
- **User_Authorized**：通过数学公式清晰地展示了递推的过程，帮助读者更好地理解递推的核心思想，代码结构清晰，注释详细。

---
处理用时：26.04秒
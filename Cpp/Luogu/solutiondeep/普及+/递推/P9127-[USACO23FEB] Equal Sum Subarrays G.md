# 题目信息

# [USACO23FEB] Equal Sum Subarrays G

## 题目描述

注意：本题的时间限制为 3 秒，为默认时间的 1.5 倍。

FJ 给了 Bessie 一个长度为 $N$ 的数组 $a$（$2 \leq N \leq 500, -10^{15} \leq a_i \leq 10^{15}$），其中所有 $\dfrac{N(N+1)}{2}$ 个连续子数组的和都是不同的。对于每个下标 $i \in [1,N]$，帮助 Bessie 计算最小的改变量，使得数组中存在两个不同的连续子数组的和相等。

## 样例 #1

### 输入

```
2
2 -3```

### 输出

```
2
3```

## 样例 #2

### 输入

```
3
3 -10 4```

### 输出

```
1
6
1```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地找到两个子数组，使得它们的和相等，并且其中一个包含某个特定元素，另一个不包含。大多数题解都基于以下思路：

1. **暴力枚举**：直接枚举所有可能的子数组，计算它们的和，然后找到满足条件的最小差值。这种方法的时间复杂度较高，通常为 \(O(n^3)\) 或更高。
2. **排序与双指针**：将所有子数组的和排序，然后通过双指针法找到相邻的两个子数组，它们的和差值最小。这种方法可以将时间复杂度降低到 \(O(n^2 \log n)\) 或 \(O(n^3)\)。
3. **离散化与桶排序**：通过离散化将子数组的和映射到较小的范围内，然后使用桶排序来优化排序过程，进一步降低时间复杂度。

### 所选高星题解

#### 1. **作者：MessageBoxA (赞：7)**  
**星级：★★★★★**  
**关键亮点**：  
- **时间复杂度优化**：通过排序和双指针法，将时间复杂度优化到 \(O(n^2 \log n)\)，显著提高了算法的效率。
- **详细解释**：题解中详细解释了如何通过排序和双指针法找到最小差值，并且给出了具体的代码实现。
- **代码可读性**：代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    minx=LLINF;
    for(int r=n;r>=l;r--){
        tmp=pre[r]-pre[l-1];
        minx=min(minx,abs(tmp));
        res=s.lower_bound({tmp,-1,-1});
        if(res!=s.end()) minx=min(minx,abs(res->val-tmp));
        if(res!=s.begin()){
            res--;
            minx=min(minx,abs(res->val-tmp));
        }
        ans[r]=min(ans[r],minx);
    }
}
```
**核心思想**：通过双指针法在排序后的子数组和中找到最小差值，并更新每个位置的最小修改量。

#### 2. **作者：DengDuck (赞：8)**  
**星级：★★★★☆**  
**关键亮点**：  
- **时间复杂度优化**：通过排序和相邻区间的差值计算，将时间复杂度优化到 \(O(n^3)\)。
- **思路清晰**：题解中详细解释了如何通过相邻区间的差值来更新每个位置的最小修改量。
- **代码简洁**：代码实现简洁，易于理解。

**核心代码**：
```cpp
for(int i=2;i<=cnt;i++){
    LL l1=t[i].l,l2=t[i-1].l;
    LL r1=t[i].r,r2=t[i-1].r;
    LL p=dkabs(sum[r2]-sum[l2-1]-sum[r1]+sum[l1-1]);
    memset(b,0,sizeof(b));
    for(int j=l1;j<=r1;j++)b[j]^=1;
    for(int j=l2;j<=r2;j++)b[j]^=1;
    for(int j=1;j<=n;j++)if(b[j])ans[j]=min(ans[j],p);
}
```
**核心思想**：通过相邻区间的差值计算，更新每个位置的最小修改量。

#### 3. **作者：H_Kaguya (赞：2)**  
**星级：★★★★☆**  
**关键亮点**：  
- **时间复杂度优化**：通过排序和双指针法，将时间复杂度优化到 \(O(n^2 \log n)\)。
- **详细解释**：题解中详细解释了如何通过排序和双指针法找到最小差值，并且给出了具体的代码实现。
- **代码可读性**：代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    minx=LLINF;
    for(int r=n;r>=l;r--){
        tmp=pre[r]-pre[l-1];
        minx=min(minx,abs(tmp));
        res=s.lower_bound({tmp,-1,-1});
        if(res!=s.end()) minx=min(minx,abs(res->val-tmp));
        if(res!=s.begin()){
            res--;
            minx=min(minx,abs(res->val-tmp));
        }
        ans[r]=min(ans[r],minx);
    }
}
```
**核心思想**：通过双指针法在排序后的子数组和中找到最小差值，并更新每个位置的最小修改量。

### 最优关键思路与技巧

1. **排序与双指针法**：通过将所有子数组的和排序，然后使用双指针法找到相邻的两个子数组，它们的和差值最小。这种方法可以显著降低时间复杂度。
2. **离散化与桶排序**：通过离散化将子数组的和映射到较小的范围内，然后使用桶排序来优化排序过程，进一步降低时间复杂度。
3. **相邻区间差值计算**：通过计算相邻区间的差值，更新每个位置的最小修改量，这种方法简单且高效。

### 可拓展之处

1. **类似问题**：类似的问题可以扩展到多维数组或多重条件的情况下，例如在二维数组中寻找两个子矩阵的和相等。
2. **算法套路**：排序与双指针法的套路可以应用于其他需要寻找最小差值或最优解的问题中。

### 推荐题目

1. **P1886 滑动窗口**：考察滑动窗口与双指针法的应用。
2. **P1044 最大子段和**：考察子数组和的最大值问题，与本题类似。
3. **P1631 序列合并**：考察多序列的合并与排序，与本题的排序思路类似。

### 个人心得摘录

- **调试经历**：在实现双指针法时，需要注意指针的移动条件，避免遗漏某些情况。
- **踩坑教训**：在排序时，确保所有子数组的和都被正确处理，避免遗漏或重复计算。
- **顿悟感想**：通过排序和双指针法，可以显著降低时间复杂度，提高算法的效率。

---
处理用时：45.65秒
# 题目信息

# 「KDOI-06-S」消除序列

## 题目描述

小 M 有一个长度为 $n$ 的序列 $v_1,v_2,\ldots,v_n$，初始时，所有元素的值均为 $1$。

你有 $3$ 种作用在这个序列上的操作：

1. 选择一个下标 $i$（$1\le i\le n$），并且将 $v_1,v_2,\ldots,v_i$ 的值全部设为 $0$，这种操作的代价是 $a_i$；
2. 选择一个下标 $i$（$1\le i\le n$），并且将 $v_i$ 的值设为 $0$，这种操作的代价是 $b_i$；
3. 选择一个下标 $i$（$1\le i\le n$），并且将 $v_i$ 的值设为 $1$，这种操作的代价是 $c_i$。

现在有 $q$ 次询问，每次询问中给定一个集合 $P$，你希望进行若干次操作（可能为 $0$），使得：序列 $v$ 中下标位于该集合的元素的值为 $1$，其余位置的值为 $0$。**形式化地说，对于任意 $\bm{1\le i\le n}$，若 $\bm{i\in P}$，则 $\bm{v_i=1}$，否则 $\bm{v_i=0}$。** 并且，你需要最小化这次询问中所有操作的总代价。

注意，询问是相互独立的，也就是说，每次询问结束后，序列 $v$ 将会回到初始状态，即所有元素的值全都变为 $1$。

## 说明/提示

**【样例解释 #1】**

对于第一次询问，可以按顺序执行如下操作：

+ 在 $i=4$ 处执行操作 $1$，在这之后，序列 $v$ 变为 $[0,0,0,0,1]$，代价为 $0$；
+ 在 $i=4$ 处执行操作 $3$，在这之后，序列 $v$ 变为 $[0,0,0,1,1]$，代价为 $2$；
+ 在 $i=5$ 处执行操作 $2$，在这之后，序列 $v$ 变为 $[0,0,0,1,0]$，代价为 $5$。

所以总代价为 $0+2+5=7$，可以证明，不存在更小的总代价。

**【样例解释 #3】**

对于这个样例中的唯一一次询问，可以选择在 $i=10$ 处执行操作 $1$，总代价为 $a_{10}=7$。

**【样例 #4】**

见选手目录下的 `reserve/reserve4.in` 与 `reserve/reserve4.ans`。

**【样例 #5】**

见选手目录下的 `reserve/reserve5.in` 与 `reserve/reserve5.ans`。

这个样例满足测试点 $8\sim 11$ 的条件限制。

**【样例 #6】**

见选手目录下的 `reserve/reserve6.in` 与 `reserve/reserve6.ans`。

这个样例满足测试点 $14\sim 15$ 的条件限制。

**【样例 #7】**

见选手目录下的 `reserve/reserve7.in` 与 `reserve/reserve7.ans`。

这个样例满足测试点 $16$ 的条件限制。

**【样例 #8】**

见选手目录下的 `reserve/reserve8.in` 与 `reserve/reserve8.ans`。

这个样例满足测试点 $17\sim 20$ 的条件限制。

***

**【数据范围】**

记 $\sum m$ 为单测试点内所有询问 $m$ 的值之和。

对于所有数据保证：$1 \leq n \leq 5\times 10^5$，$0\le m \le n$，$0 \leq \sum m \leq 5 \times 10^5$，$1\le q\le \max(n,\sum m)$，$0 \le a_i, b_i, c_i \le 10^9$，$1\le p_i \le n$。

| 测试点编号 | $n \le$ | $m \le$ | $\sum m \le$| 是否有特殊性质 |
|:--:|:--:|:--:|:--:|:--:|
| $1 \sim 2$ | $5 \times 10^5$ | $0$ | $0$ | 否 |
| $3 \sim 4$ | $7$ | $7$ | $15$ | 否 |
| $5 \sim 6$ | $2 \times 10^3$ | $1$ | $2 \times 10^3$ | 否 |
| $7$ | $2 \times 10^3$ | $2 \times 10^3$ | $2 \times 10^3$ | 是 |
| $8 \sim 11$ | $2 \times 10^3$ | $2\times 10^3$ | $2 \times 10^3$ | 否 |
| $12 \sim 13$ | $5 \times 10^4$ | $5 \times 10^4$ | $5 \times 10^4$ | 否 |
| $14 \sim 15$ | $5 \times 10^5$ | $1$ | $5 \times 10^5$ | 否 |
| $16$ | $5 \times 10^5$ | $5 \times 10^5$ | $5 \times 10^5$ | 是 |
| $17 \sim 20$ | $5 \times 10^5$ | $5 \times 10^5$ | $5 \times 10^5$ | 否 |

特殊性质：对于任意 $1\le i\le n$，保证 $c_i = 0$。

**【提示】**

本题输入输出量较大，请使用适当的 I/O 方式。

## 样例 #1

### 输入

```
5
1 13 6 0 6
2 4 1 0 5
3 4 1 2 1
7
1 4
2 1 5
1 4
2 2 3
5 1 2 3 4 5
1 5
2 3 4```

### 输出

```
7
3
7
6
0
0
8```

## 样例 #2

### 输入

```
7
10 1 6 9 4 2 4 
0 5 2 3 0 1 4 
4 1 4 1 5 3 5 
6
3 1 3 6 
2 2 6 
4 3 4 5 7 
1 4 
2 3 7 
3 3 5 6```

### 输出

```
12
8
2
5
5
8```

## 样例 #3

### 输入

```
10
6 10 7 2 8 4 6 4 8 7
4 0 6 7 8 4 8 2 10 5
4 10 6 1 4 7 5 3 8 7
1
0```

### 输出

```
7```

# AI分析结果

### 综合分析与结论

本题的核心在于如何通过动态规划或贪心策略，结合前缀和、后缀和、ST表等数据结构，高效地处理每次询问，找到最小代价的操作序列。题解中普遍采用了动态规划的思路，结合前缀和、后缀和优化，部分题解还引入了ST表或线段树来加速区间最小值的查询。整体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，而部分题解则存在冗余或不够优化的地方。

### 精选题解

#### 1. **作者：HFanGDoDM**  
**星级：★★★★★**  
**关键亮点：**  
- 详细分析了不同测试点的解法，逐步优化，最终通过ST表实现了O(n log n)的复杂度。
- 思路清晰，代码结构良好，注释详细，便于理解。
- 提供了完整的动态规划转移方程，并解释了其正确性。

**核心代码：**
```cpp
long long MinInterval(int l,int r){ //ST表单次询问求区间最小值
    if(l>r) return INF;
    long long ex=log_2[r-l+1];
    return min(ST[l][ex],ST[r-(1<<ex)+1][ex]);
}
```
**实现思想：** 通过ST表预处理区间最小值，实现O(1)查询，加速动态规划的转移。

#### 2. **作者：wxzzzz**  
**星级：★★★★☆**  
**关键亮点：**  
- 通过动态规划维护两个状态数组f和g，分别表示从全1和全0状态转换到目标状态的最小代价。
- 代码简洁，逻辑清晰，适合初学者理解动态规划的应用。
- 通过前缀和优化了区间查询的复杂度。

**核心代码：**
```cpp
for(int i=1;i<=m;i++) {
    g[i] = g[i-1] + c[p[i]];
    f[i] = a[p[i]-1] + g[i-1];
    f[i] = min(f[i], f[i-1] + s[p[i]-1] - s[p[i-1]]);
}
```
**实现思想：** 通过动态规划维护两个状态数组，分别表示从全1和全0状态转换到目标状态的最小代价，结合前缀和优化区间查询。

#### 3. **作者：technopolis_2085**  
**星级：★★★★☆**  
**关键亮点：**  
- 通过预处理a数组，确保每次操作1的代价是最优的。
- 使用动态规划结合前缀和，实现了O(n + ∑m)的复杂度。
- 代码结构清晰，逻辑严谨，适合有一定基础的读者。

**核心代码：**
```cpp
for(int i=1;i<=n;i++) a[i]=min(a[i],a[i-1]+b[i]);
```
**实现思想：** 预处理a数组，确保每次操作1的代价是最优的，结合动态规划和前缀和优化查询。

### 最优关键思路与技巧

1. **动态规划结合前缀和/后缀和：** 通过预处理前缀和和后缀和，可以快速计算区间内的操作代价，优化动态规划的转移。
2. **ST表加速区间查询：** 通过ST表预处理区间最小值，可以在O(1)时间内查询任意区间的最小值，极大提升了动态规划的效率。
3. **操作1的优化：** 通过预处理a数组，确保每次操作1的代价是最优的，避免了重复计算。

### 可拓展之处

- **类似问题：** 类似的问题可以通过动态规划结合前缀和、后缀和、ST表等数据结构来优化查询效率。
- **其他数据结构：** 除了ST表，线段树、树状数组等数据结构也可以用于加速区间查询。

### 推荐题目

1. **P3865 【模板】ST表**  
2. **P3374 【模板】树状数组 1**  
3. **P3372 【模板】线段树 1**

### 个人心得总结

- **调试经历：** 部分题解中提到在调试过程中发现ST表的预处理范围不够，导致部分测试点无法通过，提醒我们在预处理时要注意边界条件。
- **顿悟感想：** 通过逐步优化，从O(nq)到O(n log n)，深刻体会到数据结构在算法优化中的重要性。

---
处理用时：34.76秒
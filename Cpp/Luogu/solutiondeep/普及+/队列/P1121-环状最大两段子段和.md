# 题目信息

# 环状最大两段子段和

## 题目描述

给出一段长度为 $n$ 的环状序列 $a$，即认为 $a_1$ 和 $a_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
9```

# AI分析结果

### 综合分析与结论
这些题解主要围绕环状最大两段子段和问题展开，核心思路是将问题分类讨论，分为两段都不跨环和有一段跨环两种情况。对于不跨环的情况，通常通过预处理从前往后和从后往前的最大子段和，枚举断点求解；对于跨环的情况，一般是求最小两段子段和，用总和减去该值得到结果。不同题解在实现细节、数据结构运用和边界处理上有所差异。

### 所选题解
- **作者：Develop（5星）**
    - **关键亮点**：思路全面，不仅给出本题解法，还详细阐述了最大子段和及其多种变式的解法和复杂度分析，对理解相关问题有很大帮助。
    - **个人心得**：提到优化算法时，优化枚举的核心是减少枚举过程中的重复计算，具有指导意义。
- **作者：I_AM_HelloWord（4星）**
    - **关键亮点**：思路清晰，通过枚举可能情况，提出正反做普通最大子序列和求最小子序列的方法，并考虑了特殊情况的特判，代码简洁易懂。
    - **个人心得**：通过具体例子发现特殊情况，即只有一个正数时将数字负过来求最大子序列会出错，从而进行特判。
- **作者：zhy137036（4星）**
    - **关键亮点**：先介绍最大子段和、环状最大子段和、最大双子段和等相关问题的解法，再逐步推导环状最大双子段和的解法，逻辑连贯，代码注释详细。
    - **个人心得**：强调做题时要注意题目条件，如本题中两个子段可以相邻这一坑点。

### 重点代码及核心实现思想
#### Develop题解
```cpp
// chapter 5 环状最大两段子段和
// O(n) 对于答案可能有的所有情况，一种是有一段跨过了端点，另一种是没有跨过端点；
// 所以可以先求一遍两段最大子段和，再对整个序列取反，再求一遍(这时其实就是求出两段的最小子段和，用总和减去后就是跨过端点的两段最大子段和)，这时把两种情况取一个max；
```
核心思想：分类讨论，分别处理两段不跨环和跨环的情况，通过取反求最小子段和来处理跨环情况。

#### I_AM_HelloWord题解
```cpp
int query(){
    int res=-INF;
    for (int i=1;i<=n;i++)f[i]=max(f[i-1],0)+a[i];
    for (int i=n;i>0;i--)g[i]=max(g[i+1],0)+a[i];
    for (int i=1;i<=n;i++)f[i]=max(f[i-1],f[i]);
    for (int i=n;i>0;i--)g[i]=max(g[i+1],g[i]);
    for (int i=1;i<n;i++)res=max(res,f[i]+g[i+1]);
    return res;
}
int main(){
    scanf("%d",&n);
    memset(f,~0x3f,sizeof(f));memset(g,~0x3f,sizeof(g));
    for (int i=1;i<=n;i++)scanf("%d",&a[i]),sum+=a[i],tot+=a[i]>0;
    int t1=query();
    if (tot==1){
        printf("%d",t1);
    }else{
        for (int i=1;i<=n;i++)a[i]=-a[i];
        int t2=sum+query();
        if (!t2)t2=-INF;
        printf("%d",max(t1,t2));
    }
    return 0;
}
```
核心思想：先求不跨环的最大两段子段和，再判断正数个数，若只有一个正数则直接输出不跨环结果，否则将序列取反求跨环的最大两段子段和，最后取两者最大值。

#### zhy137036题解
```cpp
int getmin(int*arr,int l){
    mf[1]=arr[1];
    for(int i=2;i<=l;i++)mf[i]=min(mf[i-1]+arr[i],min(arr[i],0));//可以为0 
    for(int i=2;i<=l;i++)mf[i]=min(mf[i-1],mf[i]);
    mb[l]=arr[l];
    for(int i=l-1;i>0;i--)mb[i]=min(mb[i+1]+arr[i],min(arr[i],0));//可以为0 
    for(int i=l-1;i>0;i--)mb[i]=min(mb[i+1],mb[i]);
    int ans=(1ll<<31ll)-1ll;//2^31-1，即 int 的最大值 
    for(int i=2;i<l;i++)ans=min(ans,mf[i-1]+mb[i+1]);//这里必须被分开 
    return ans;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",a+i);
        sum+=a[i];
    }
    af[1]=a[1];
    for(int i=2;i<=n;i++)af[i]=max(af[i-1],0)+a[i];
    for(int i=2;i<=n;i++)af[i]=max(af[i-1],af[i]);
    ab[n]=a[n];
    for(int i=n-1;i>0;i--)ab[i]=max(ab[i+1],0)+a[i];
    for(int i=n-1;i>0;i--)ab[i]=max(ab[i+1],ab[i]);
    int ans=1ll<<31ll;//溢出为负数
    for(int i=1;i<n;i++)ans=max(ans,af[i]+ab[i+1]);//可以不被分开 
    ans=max(ans,sum-getmin(a,n-1));
    ans=max(ans,sum-getmin(a+1,n-1));
    printf("%d\n",ans);
    return 0;
}
```
核心思想：先预处理从前往后和从后往前的最大子段和，枚举断点求不跨环的最大两段子段和，再求最小两段子段和，用总和减去该值求跨环的最大两段子段和，最后取两者最大值。

### 最优关键思路或技巧
- **分类讨论**：将环状最大两段子段和问题分为两段不跨环和有一段跨环两种情况分别处理。
- **取反求最小子段和**：通过将序列取反，把求最小子段和问题转化为求最大子段和问题。
- **预处理最大子段和**：通过预处理从前往后和从后往前的最大子段和，减少重复计算，提高效率。

### 可拓展之处
同类型题或类似算法套路：
- 求环状最大 $m$ 段子段和：可以参考本题思路，将问题分类讨论，通过动态规划或其他方法求解。
- 带权值的环状最大两段子段和：在原问题基础上增加权值，需要在计算子段和时考虑权值因素。
- 区间修改的环状最大两段子段和：可以使用线段树等数据结构来支持区间修改操作，再结合本题思路求解。

### 推荐题目
- P1115 最大子段和
- P2642 双子序列最大和
- P4513 小白逛公园

### 个人心得总结
- 优化算法时，优化枚举的核心是减少枚举过程中的重复计算。
- 做题时要注意题目条件，如本题中两个子段可以相邻这一坑点。
- 通过具体例子发现特殊情况，对特殊情况进行特判，保证算法的正确性。 

---
处理用时：48.62秒
# 题目信息

# [HNOI2001] 求正整数

## 题目描述

对于任意输入的正整数 $n$，请求出具有 $n$ 个不同因子的最小正整数 $m$。

例如：$n=4$，则 $m=6$，因为 $6$ 有 $4$ 个不同整数因子 $1,2,3,6$；而且是最小的有 $4$ 个因子的整数。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 5 \times 10^4$。

## 样例 #1

### 输入

```
 4
```

### 输出

```
6
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕求具有 $n$ 个不同因子的最小正整数 $m$ 展开，多数题解采用数论知识结合 DFS 或 DP 算法。关键在于利用因数个数公式和约数分解定理，同时处理答案可能过大的问题，常采用取对数比较大小和高精度乘法的技巧。各题解在剪枝策略、代码实现和复杂度优化上有所差异。

### 所选题解
- **作者：_rqy（5星）**
    - **关键亮点**：思路清晰，采用 DP 算法结合取对数处理大数问题，代码实现严谨，复杂度控制较好。
    - **核心实现思想**：定义状态 $f_{i, j}$ 表示所有只包含前 $j$ 个质因数的数中，因数个数为 $i$ 的最小的数。根据因数个数公式进行状态转移，取对数避免高精 DP 的复杂度问题，最后通过回溯找到转移方向并进行高精乘单精得到结果。
    - **核心代码片段**：
```cpp
// 状态转移部分
for (int i = 1; i < m; ++i) {
    for (int k = 0; k < 20; ++k)
        f[i][k] = 1e9;
    for (int j = 0; j < i; ++j) if (!(d[i] % d[j])) {
        int t = d[i] / d[j];
        for (int k = 1; k < 20; ++k)
            f[i][k] = std::min(f[i][k], f[j][k - 1] + logp[k - 1] * (t - 1));
    }
}
// 回溯部分
A[0] = len = 1;
int j = 0;
for (int i = 0; i < 20; ++i) if (f[m - 1][i] < f[m - 1][j]) j = i;
for (int i = m - 1, nxt; i; i = nxt, --j) {
    for (nxt = 0; d[i] % d[nxt] || f[i][j] < f[nxt][j - 1]
        + logp[j - 1] * (d[i] / d[nxt] - 1) - 1e-5; ++nxt);
    for (int k = 1; k < d[i] / d[nxt]; ++k)
        mul(p[j - 1]);
}
```
- **作者：throusea（4星）**
    - **关键亮点**：详细阐述 DFS 思路和剪枝策略，对大数处理采用取对数和数组保存质因数指数的方法，代码注释清晰。
    - **核心实现思想**：利用因数个数公式，通过 DFS 枚举每个质因数的指数，采用最优性剪枝和可行性剪枝避免无效搜索，取对数比较大小，最后用高精乘低精得到结果。
    - **核心代码片段**：
```cpp
// DFS 部分
void dfs(int tol,double d,int g){ //d为当前的答案（用log缩小）
    if(ansx<d||g==16) return; //剪枝1
    if(tol==1){
        if(ansx>d){
            memcpy(ans,f,sizeof(f));
            ansx=d;
        }
        return;
    }
    for(int i=0;(i+1)*(i+1)<=tol;i++)
    if(tol%(i+1)==0){  //剪枝2
        f[g]=i;
        dfs(tol/(i+1),d+f[g]*lg[a[g]],g+1);
        f[g]=tol/(i+1)-1;
        dfs(i+1,d+f[g]*lg[a[g]],g+1);
        f[g]=0;
    }
}
```
- **作者：FZzzz（4星）**
    - **关键亮点**：提供了 Python 题解，提出强力剪枝策略，代码简洁易懂。
    - **核心实现思想**：根据唯一分解定理，枚举 $n$ 的每一种分解，将分解结果减去一作为不同质数的指数，乘起来得到结果。剪枝策略为只使用最小的质数，且将大数分配给小质数。
    - **核心代码片段**：
```python
primes=(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61)
def dfs(dep,x,mm):
    if x==1:
        return 1
    ans=-1
    for i in range(2,mm+1):
        if x%i==0:
            if ans<0:
                ans=(primes[dep]**(i-1))*dfs(dep+1,x//i,i)
            else:
                ans=min(ans,(primes[dep]**(i-1))*dfs(dep+1,x//i,i))
    return ans
n=int(input())
print(dfs(0,n,n))
```

### 最优关键思路或技巧
- **取对数处理大数**：由于答案可能非常大，直接存储和比较会导致溢出或复杂度问题，取对数后可以将乘法转化为加法，方便比较大小。
- **剪枝策略**：包括最优性剪枝（如果当前结果不比最优结果优，直接返回）和可行性剪枝（如果当前状态不满足条件，舍去），可以大大减少搜索空间。
- **状态定义与转移**：在 DP 算法中，合理定义状态和转移方程是关键，通过状态转移可以避免重复计算。

### 可拓展之处
同类型题或类似算法套路包括求具有特定性质的最小正整数、因数个数相关问题等。可以采用类似的数论知识结合搜索或 DP 算法，同时注意处理大数问题和剪枝优化。

### 推荐题目
- [P1221 最多因子数](https://www.luogu.org/problem/P1221)
- [P1072 Hankson 的趣味题](https://www.luogu.org/problem/P1072)
- [P2152 [SDOI2009]SuperGCD](https://www.luogu.org/problem/P2152)

### 个人心得摘录与总结
- **天下第一剑客**：提出一种贪心策略，但发现该策略不完全正确，如在 $n = 128$ 时出错。意识到贪心策略可能存在局限性，在考场上即使知道算法有错误，也可以尝试提交，可能会得到较高分数。
- **FZzzz**：模拟赛中剪枝写错导致丢分，提醒在实现剪枝策略时要仔细，避免出错。

---
处理用时：41.57秒
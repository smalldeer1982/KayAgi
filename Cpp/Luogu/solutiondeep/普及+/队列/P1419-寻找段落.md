# 题目信息

# 寻找段落

## 题目描述

给定一个长度为 $n$ 的序列 $a$，定义 $a_i$ 为第 $i$ 个元素的价值。现在需要找出序列中最有价值的“段落”。段落的定义是长度在 $[S, T]$ 之间的连续序列。最有价值段落是指平均值最大的段落。

**段落的平均值** 等于 **段落总价值** 除以 **段落长度**。

## 说明/提示

【数据范围】

对于 $30\%$ 的数据有 $n \le 1000$。

对于 $100\%$ 的数据有 $1 \le n \le 100000$，$1 \le S \le T \le n$，$-{10}^4 \le a_i \le {10}^4$。

【题目来源】

tinylic 改编


## 样例 #1

### 输入

```
3

2 2

3

-1

2

```

### 输出

```
1.000```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找序列中长度在 $[S, T]$ 之间且平均值最大的段落展开，多数采用二分答案结合单调队列的方法，部分使用前缀和优化暴力枚举并结合卡时技巧。

二分答案的思路是利用答案的单调性，将求最大平均值问题转化为判定性问题，即判断是否存在满足条件的段落使得平均值达到给定值。单调队列用于在 $O(n)$ 时间内判断是否存在长度在 $[S, T]$ 之间且和大于等于 0 的子段，从而优化判定过程。

### 所选题解
1. **作者：kkksc03（5星）**
    - **关键亮点**：思路清晰，详细说明了二分答案和单调队列的使用，代码注释完整，实现规范。
    - **核心代码**：
```cpp
bool check(double x) {
    int i, l = 1, r = 0;
    for (i = 1; i <= n; i++)
        a[i] = (double)b[i] - x;
    sum[0] = 0;
    for (i = 1; i <= n; i++)
        sum[i] = sum[i - 1] + a[i];
    for (i = 1; i <= n; i++) {
        if (i >= s) {
            while (r >= l && sum[i - s] < sum[q[r]])    r--;
            q[++r] = i - s;
        }
        if (l <= r && q[l] < i - t) l++;
        if (l <= r && sum[i] - sum[q[l]] >= 0) return true;
    }
    return false;
}
```
    - **核心实现思想**：在 `check` 函数中，先将原序列每个元素减去二分的平均值 $x$，计算前缀和数组 `sum`。然后使用单调队列维护长度在 $[S, T]$ 之间的子段和的最大值，若存在子段和大于等于 0，则说明当前平均值 $x$ 可行。

2. **作者：autoint（4星）**
    - **关键亮点**：详细推导了公式，解释了二分答案和单调队列的原理，还给出了小优化建议。
    - **核心代码**：
```cpp
inline bool judge(int x)
{
    memset(sum,0,sizeof(sum));
    for(rg int i=1;i<=n;++i)
    {
        sum[i]=sum[i-1]+a[i]-x;
    }
    Q.clear();
    for(rg int i=S,p=0;i<=n;++i,++p)
    {
        while(!Q.empty()&&sum[Q.back()]>sum[p])
            Q.pop_back();
        Q.push_back(p);
        while(Q.front()<i-T)
            Q.pop_front();
        if(sum[i]-sum[Q.front()]>=0)
            return 1;
    }
    return 0;
}
```
    - **核心实现思想**：`judge` 函数用于判断当前二分的平均值 $x$ 是否可行。先计算减去 $x$ 后的前缀和数组 `sum`，再使用单调队列维护前缀和的最小值，若存在子段和大于等于 0，则返回 `true`。

3. **作者：return_CE（4星）**
    - **关键亮点**：分析了暴力解法的复杂度和不足，详细说明了二分和单调队列的实现过程。
    - **核心代码**：
```cpp
double err(double minn,double maxx)
{
    if(minn>maxx-1e-5){
        ans=maxx;
        return 0;
    }
    double mid=(minn+maxx)/2;
    double b[100005],summ[100005];
    int hh=1,tt=0;
    int q[100005];
    for(int i=1;i<=n;i++){
        b[i]=a[i]-mid;
    }
    for(int i=1;i<=n;i++){
        summ[i]=summ[i-1]+b[i];
    }
    for (int i=1;i<=n;i++){
        if(i>=s){
            while(tt>=hh&& summ[i-s]<summ[q[tt]])tt--;
            q[++tt]=i-s;
        }
        if(hh<=tt&& q[hh]<i-t) hh++;
        if(hh<=tt&& summ[i]-summ[q[hh]]>=0) return err(mid,maxx);
    }
    return err(minn,mid);
}
```
    - **核心实现思想**：`err` 函数通过二分答案，每次将值域分为两半，使用单调队列判断是否存在段落的平均值能达到当前二分的中间值 $mid$，根据判断结果递归求解。

### 最优关键思路或技巧
- **二分答案**：将求最大平均值的问题转化为判定性问题，利用答案的单调性缩小搜索范围，时间复杂度为 $O(\log A)$，其中 $A$ 为数据范围。
- **单调队列**：在 $O(n)$ 时间内维护长度在 $[S, T]$ 之间的子段和的最大值，优化了判定过程。
- **前缀和**：用于快速计算子段和，将计算子段和的时间复杂度从 $O(n)$ 降低到 $O(1)$。

### 可拓展之处
同类型题或类似算法套路：
- 其他需要二分答案的问题，如最大化最小值、最小化最大值等。
- 涉及区间最值问题，可使用单调队列优化，如滑动窗口最大值问题。

### 推荐洛谷题目
1. [P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)
2. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)
3. [P3853 [TJOI2007]路标设置](https://www.luogu.com.cn/problem/P3853)

### 个人心得摘录与总结
- **作者：Remake_**：提到前缀和优化的暴力会超时，可通过添加卡时让程序在跑完 $0.95s$ 后退出循环输出最优解，依据贪心思路从最小段落长度开始枚举，有较大概率得到正确答案。
- **作者：Harry27182**：指出朴素暴力枚举时间复杂度为 $O(n^3)$ 会超时，前缀和优化后为 $O(n^2)$ 仍不够优秀，添加卡时在跑了 $0.95s$ 后跳出程序，由于长度从小到大搜索，长度小的时候容易取最大值，所以有很大概率通过。

总结：这两位作者都提到了在暴力枚举超时的情况下，使用卡时技巧结合贪心思路来提高通过的概率，但这种方法并非严格的正确解法，可能会被特殊数据卡掉。

---
处理用时：38.21秒
# 题目信息

# 琪露诺

## 题目描述

在幻想乡，琪露诺是以笨蛋闻名的冰之妖精。

某一天，琪露诺又在玩速冻青蛙，就是用冰把青蛙瞬间冻起来。但是这只青蛙比以往的要聪明许多，在琪露诺来之前就已经跑到了河的对岸。于是琪露诺决定到河岸去追青蛙。

小河可以看作一列格子依次编号为 $0$ 到 $N$，琪露诺只能从编号小的格子移动到编号大的格子。而且琪露诺按照一种特殊的方式进行移动，当她在格子 $i$ 时，她只移动到区间 $[i+L,i+R]$ 中的任意一格。你问为什么她这么移动，这还不简单，因为她是笨蛋啊。

每一个格子都有一个冰冻指数 $A_i$，编号为 $0$ 的格子冰冻指数为 $0$。当琪露诺停留在那一格时就可以得到那一格的冰冻指数 $A_i$。琪露诺希望能够在到达对岸时，获取最大的冰冻指数，这样她才能狠狠地教训那只青蛙。

但是由于她实在是太笨了，所以她决定拜托你帮它决定怎样前进。

开始时，琪露诺在编号 $0$ 的格子上，只要她下一步的位置编号大于 $N$ 就算到达对岸。


## 说明/提示

对于 $60\%$ 的数据，$N \le 10^4$。

对于 $100\%$ 的数据，$N \le 2\times 10^5$，$-10^3 \le  A_i\le 10^3 $，$1 \le L \le R \le N $。数据保证最终答案不超过 $2^{31}-1$。


## 样例 #1

### 输入

```
5 2 3
0 12 3 11 7 -2
```

### 输出

```
11

```

# AI分析结果

### 综合分析与结论
本题主要是动态规划问题，状态转移方程为 $f[i] = \max(f[j]) + A[i]\ (i - R \le j \le i - L)$。由于直接暴力枚举复杂度为 $O(n^2)$，会超时，所以需要优化。大部分题解采用单调队列优化，也有部分使用优先队列、线段树、分块等方法。

### 所选题解
- **作者：灵乌路空（5星）**
    - **关键亮点**：思路清晰，详细分析了题意和优化思路，代码注释丰富，还提供了 Hack 数据。
    - **核心代码**：
```cpp
for(int i = L; i <= N; i ++)
{
    Insert(i - L); //将最后一个 能够转移到i的位置 加入单调队列 
    int from = query(i);//找到队首 权值和最大的位置 
    f[i] = f[from] + A[i];//进行转移 
    if(i + R > N) ans = max(ans, f[i]);//判断i能够跳到对岸, 计算答案 
}
```
    - **核心思想**：顺序枚举 $[L, N]$ 的每一个位置 $i$，利用单调队列维护能够转移到 $i$ 的位置中 $f[]$ 最大的位置，进行状态转移，最后找出能跳到对岸的位置中的最大权值和。

- **作者：巨型方块（4星）**
    - **关键亮点**：提供了优先队列的解法，思路独特，代码简洁。
    - **核心代码**：
```cpp
for(int i = L; i <= n; i++){
    q1.push(f[i-L]);
    if(i-R-1>=L) q2.push(f[i-R-1]);
    while(!q2.empty()&&q1.top()==q2.top()){
        q1.pop();q2.pop();
    }
    f[i]=q1.top()+a[i];            
}
```
    - **核心思想**：用两个优先队列分别记录从 $1$ 到 $i - L$ 和从 $1$ 到 $i - R - 1$ 的最大值，通过比较两个堆顶元素，去除重复部分，得到 $i - L$ 到 $i - R$ 中 $f[]$ 的最大值，进行状态转移。

- **作者：封禁用户（4星）**
    - **关键亮点**：适合萌新，详细讲述了思考过程，通过模拟队列让读者更好理解单调队列的应用。
    - **核心代码**：
```cpp
for(int i = l; i <= n; i++)
{
    while(h <= t && dq[h] < i - r) h++;//删去队首不在区间内的数
    while(h <= t && dp[dq[t]] < dp[i - l]) t--;//删去队尾比新数小的数
    dq[++t] = i - l;//推入编号为 i - l 的数
    dp[i] = dp[dq[h]] + v[i];//当前的 dp 值为区间最大值加上自己的权值
    if(i + r > n) 
        ans = max(dp[i], ans);//如果这个数下一步可以跳出的话，记录最优值
}
```
    - **核心思想**：顺序枚举 $[l, n]$ 的每一个位置 $i$，利用单调队列维护能够转移到 $i$ 的位置中 $dp[]$ 最大的位置，进行状态转移，同时记录能跳到对岸的位置中的最大权值和。

### 最优关键思路或技巧
- **单调队列优化**：对于滑动窗口型最值问题，使用单调队列可以将查询区间最值的复杂度从 $O(n)$ 优化到 $O(1)$，从而将整体复杂度从 $O(n^2)$ 优化到 $O(n)$。
- **优先队列**：通过维护两个优先队列，去除重复部分，得到所需区间的最大值，复杂度为 $O(nlogn)$。
- **线段树**：支持区间查询最值和单点修改，复杂度为 $O(nlogn)$。

### 可拓展之处
同类型题或类似算法套路：
- 滑动窗口问题，如 [P1886 滑动窗口](https://www.luogu.org/problemnew/show/P1886)，可以使用单调队列解决。
- 区间最值查询问题，如 [P3865 【模板】ST 表](https://www.luogu.org/problemnew/show/P3865)，可以使用 ST 表、线段树等数据结构解决。
- 动态规划优化问题，如 [P3957 跳房子](https://www.luogu.org/problemnew/show/P3957)，可以使用单调队列优化动态规划。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.org/problemnew/show/P1886)：考察单调队列的基本应用。
2. [P3865 【模板】ST 表](https://www.luogu.org/problemnew/show/P3865)：考察区间最值查询的 ST 表解法。
3. [P3957 跳房子](https://www.luogu.org/problemnew/show/P3957)：考察单调队列优化动态规划。

### 个人心得摘录与总结
- **作者：2018_Danny**：标准动归会超时，学习单调队列后解决问题，强调要弄清楚每次获取区间最大值的对象。
- **作者：倔强的咸鱼**：用裸的背包 dp 卡过测试数据，但认为正解应该用队列优化，可能存在漏洞。
- **作者：zhaimingshuzms**：手动开队列，虽然最坏复杂度高，但常数小，最后一行代码有玄学优化效果。 

---
处理用时：35.85秒
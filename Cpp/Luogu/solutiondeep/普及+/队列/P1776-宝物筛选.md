# 题目信息

# 宝物筛选

## 题目描述

终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。

这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。

小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为 $W$ 的采集车，洞穴里总共有 $n$ 种宝物，每种宝物的价值为 $v_i$，重量为 $w_i$，每种宝物有 $m_i$ 件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。

## 说明/提示

对于 $30\%$ 的数据，$n\leq \sum m_i\leq 10^4$，$0\le W\leq 10^3$。

对于 $100\%$ 的数据，$n\leq \sum m_i \leq 10^5$，$0\le W\leq 4\times 10^4$，$1\leq n\le 100$。

## 样例 #1

### 输入

```
4 20
3 9 3
5 9 1
9 4 2
8 1 3```

### 输出

```
47```

# AI分析结果

### 综合分析与结论
本题是多重背包问题，直接枚举会超时，题解主要采用二进制优化和单调队列优化两种方法。二进制优化是将每种物品拆分成多个物品，利用二进制组合表示原物品的所有选择情况，将问题转化为 01 背包问题，降低时间复杂度；单调队列优化则是通过对状态转移方程变形，利用单调队列维护区间最大值，实现更高效的状态转移。

### 所选题解
- **作者：ezoiHQM（5 星）**
    - **关键亮点**：思路清晰，详细阐述了单调队列优化多重背包的过程，从状态转移方程的推导到单调队列的应用都有说明，代码简洁易懂。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    int v,w,c;
    scanf("%d%d%d",&w,&v,&c);
    if(v==0){
        ans+=w*c;
        continue;
    }
    int k=V/v;
    c=min(c,k);
    for(int d=0;d<v;d++){
        head=tail=0;
        k=(V-d)/v;
        for(int j=0;j<=k;j++){
            while(head<tail&&dp[d+j*v]-j*w>=q2[tail-1])
                tail--;
            q[tail]=j;
            q2[tail++]=dp[d+j*v]-j*w;
            while(head<tail&&q[head]<j-c)
                ++head;
            dp[d+j*v]=max(dp[d+j*v],q2[head]+j*w);
        }
    }
}
```
    - **核心思想**：先处理价值为 0 的物品，然后枚举余数，对每个余数用单调队列维护区间最大值，更新 dp 数组。

- **作者：檀黎斗·神（4 星）**
    - **关键亮点**：清晰解释了二进制优化的原理，代码简洁明了，将二进制优化和 01 背包结合解决问题。
    - **核心代码**：
```cpp
for(int i=1;i<=n;++i)
{
    scanf("%d%d%d",&a,&b,&c);
    for(int j=1;j<=c;j<<=1)
    {
        v[++cnt]=j*a,w[cnt]=j*b;
        c-=j;
    }
    if(c) v[++cnt]=a*c,w[cnt]=b*c;
}
for(int i=1;i<=cnt;++i)
    for(int j=m;j>=w[i];--j)
        f[j]=max(f[j],f[j-w[i]]+v[i]);
```
    - **核心思想**：对每种物品进行二进制拆分，将拆分后的物品存入数组，再进行 01 背包求解。

- **作者：FlashHu（4 星）**
    - **关键亮点**：详细推导了单调队列优化的过程，结合滑动窗口形象地解释了单调队列的应用，代码注释丰富，便于理解。
    - **核心代码**：
```cpp
for(i=1;i<=n;++i){
    v=in();w=in();m=in();
    for(d=0;d<w;++d){
        maxk=(maxw-d)/w;lim=max(maxk-m,0);
        for(t=0,k=maxk-1;k>=lim;--k){
            now=f[k*w+d]-k*v;
            while(t&&g[t]<=now)--t;
            g[++t]=now;q[t]=k;
        }
        for(h=1,k1=maxk;~k1;--k1,--k){
            if(h<=t&&q[h]>=k1)++h;
            if(h<=t)chkmx(f[k1*w+d],g[h]+k1*v);
            if(k<0)continue;
            now=f[k*w+d]-k*v;
            while(h<=t&&g[t]<=now)--t;
            g[++t]=now;q[t]=k;
        }
    }
}
```
    - **核心思想**：枚举余数，先扩大窗口宽度，再移动窗口，用单调队列维护区间最大值，更新 dp 数组。

### 最优关键思路或技巧
- **二进制优化**：利用二进制组合的特性，将每种物品拆分成多个物品，将多重背包问题转化为 01 背包问题，时间复杂度从 $O(nW\sum_{}m_i)$ 优化到 $O(nW\sum_{}log~m_i)$。
- **单调队列优化**：通过对状态转移方程变形，将其转化为单调队列能处理的形式，利用单调队列维护区间最大值，实现 $O(nW)$ 的时间复杂度。

### 可拓展之处
同类型题如 P1833 樱花、P2347 砝码称重、P1616 疯狂的采药等，都可以用多重背包的优化方法解决。类似算法套路包括在其他动态规划问题中，通过对状态转移方程变形，利用单调队列、二进制优化等方法降低时间复杂度。

### 推荐题目
- P1833 樱花：多重背包问题，可使用二进制优化或单调队列优化。
- P2347 砝码称重：多重背包问题的变形，需要根据砝码的重量和数量进行状态转移。
- P1616 疯狂的采药：完全背包问题，可参考多重背包的优化思路。

### 个人心得摘录与总结
- **作者：Owen_codeisking**：在机房听教练讲单调队列优化 dp 没听懂，特地刷裸的多重背包题，强调了学习单调队列优化的重要性。
- **作者：谬悠**：在做本题时因数组大小问题多次 RE，分析了数组大小的确定方法，提醒要弄清楚每个数组的作用和范围。
- **作者：S1gMa**：一开始以为是 01 背包板子题，结果只拿了 30 分，尝试读入输出优化和吸氧大法后仍未 AC，最后采用多重背包 + 二进制拆分优化解决问题，提醒要根据数据范围选择合适的算法。 

---
处理用时：40.27秒
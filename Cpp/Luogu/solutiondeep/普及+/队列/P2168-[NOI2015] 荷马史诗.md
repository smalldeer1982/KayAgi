# 题目信息

# [NOI2015] 荷马史诗

## 题目背景

> 追逐影子的人，自己就是影子 —— 荷马

## 题目描述

Allison 最近迷上了文学。她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。但是由《奥德赛》和《伊利亚特》 组成的鸿篇巨制《荷马史诗》实在是太长了，Allison 想通过一种编码方式使得它变得短一些。

一部《荷马史诗》中有 $n$ 种不同的单词，从 $1$ 到 $n$ 进行编号。其中第 $i$ 种单词出现的总次数为 $w_i$。Allison 想要用 $k$ 进制串 $s_i$ 来替换第 $i$ 种单词，使得其满足如下要求：

对于任意的 $1\leq i, j\leq n$ ，$i\ne j$ ，都有：$s_i$ 不是 $s_j$ 的前缀。

现在 Allison 想要知道，如何选择 $s_i$，才能使替换以后得到的新的《荷马史诗》长度最小。在确保总长度最小的情况下，Allison 还想知道最长的 $s_i$ 的最短长度是多少？

一个字符串被称为 $k$ 进制字符串，当且仅当它的每个字符是 $0$ 到 $k-1$ 之间（包括 $0$ 和 $k-1$ ）的整数。

字符串 $str1$ 被称为字符串 $str2$ 的前缀，当且仅当：存在 $1 \leq t\leq m$ ，使得 $str1 = str2[1..t]$。其中，$m$ 是字符串 $str2$ 的长度，$str2[1..t]$ 表示 $str2$ 的前 $t$ 个字符组成的字符串。

## 说明/提示

#### 【样例解释】

#### 样例 1 解释

用 $X(k)$ 表示 $X$ 是以 $k$ 进制表示的字符串。

一种最优方案：令 $00(2)$ 替换第 $1$ 种单词， $01(2)$ 替换第 2 种单词， $10(2)$ 替换第 $3$ 种单词，$11(2)$ 替换第 $4$ 种单词。在这种方案下，编码以后的最短长度为：

$1 × 2 + 1 × 2 + 2 × 2 + 2 × 2 = 12$

最长字符串 $s_i$ 的长度为 $2$ 。

一种非最优方案：令 $000(2)$ 替换第 $1$ 种单词，$001(2)$ 替换第 $2$ 种单词，$01(2)$ 替换第 $3$ 种单词，$1(2)$ 替换第 $4$ 种单词。在这种方案下，编码以后的最短长度为：

$1 × 3 + 1 × 3 + 2 × 2 + 2 × 1 = 12$

最长字符串 $s_i$ 的长度为 $3$ 。与最优方案相比，文章的长度相同，但是最长字符串的长度更长一些。

#### 样例 2 解释

一种最优方案：令 $000(3)$ 替换第 $1$ 种单词，$001(3)$ 替换第 $2$ 种单词，$01(3)$ 替换第 $3$ 种单词， $02(3)$ 替换第 $4$ 种单词， $1(3)$ 替换第 5 种单词， $2(3)$ 替换第 $6$ 种单词。

#### 【数据规模与约定】

所有测试数据的范围和特点如下表所示（所有数据均满足 $0 < w_i \leq 10^{11}$）：

| 测试点编号 |  $n$ 的规模  | $k$ 的规模 |            备注            |
| :--------: | :----------: | :--------: | :------------------------: |
|    $1$     |    $n=3$     |   $k=2$    |                            |
|    $2$     |    $n=5$     |   $k=2$    |                            |
|    $3$     |    $n=16$    |   $k=2$    |     所有 $w_i$ 均相等      |
|    $4$     |  $n=1\,000$  |   $k=2$    | $w_i$ 在取值范围内均匀随机 |
|    $5$     |  $n=1\,000$  |   $k=2$    |                            |
|    $6$     | $n=100\,000$ |   $k=2$    |                            |
|    $7$     | $n=100\,000$ |   $k=2$    |     所有 $w_i$ 均相等      |
|    $8$     | $n=100\,000$ |   $k=2$    |                            |
|    $9$     |    $n=7$     |   $k=3$    |                            |
|    $10$    |    $n=16$    |   $k=3$    |     所有 $w_i$ 均相等      |
|    $11$    |  $n=1\,001$  |   $k=3$    |     所有 $w_i$ 均相等      |
|    $12$    | $n=99\,999$  |   $k=4$    |     所有 $w_i$ 均相等      |
|    $13$    | $n=100\,000$ |   $k=4$    |                            |
|    $14$    | $n=100\,000$ |   $k=4$    |                            |
|    $15$    |  $n=1\,000$  |   $k=5$    |                            |
|    $16$    | $n=100\,000$ |   $k=7$    | $w_i$ 在取值范围内均匀随机 |
|    $17$    | $n=100\,000$ |   $k=7$    |                            |
|    $18$    | $n=100\,000$ |   $k=8$    | $w_i$ 在取值范围内均匀随机 |
|    $19$    | $n=100\,000$ |   $k=9$    |                            |
|    $20$    | $n=100\,000$ |   $k=9$    |                            |

#### 【提示】

选手请注意使用 64 位整数进行输入输出、存储和计算。

#### 【评分方式】

对于每个测试点：

- 若输出文件的第 $1$ 行正确，得到该测试点 $40\%$ 的分数；
- 若输出文件完全正确，得到该测试点 $100\%$ 的分数。

## 样例 #1

### 输入

```
4 2
1
1
2
2
```

### 输出

```
12
2```

## 样例 #2

### 输入

```
6 3
1
1
3
3
9
9
```

### 输出

```
36
3
```

# AI分析结果

### 综合分析与结论
本题核心是构建 $k$ 叉哈夫曼树来解决编码长度最小化问题。各题解均围绕哈夫曼树展开，思路大致相同，主要步骤为：将单词出现次数作为叶子节点权值，使用优先队列（或双队列）维护节点，每次选取权值最小的 $k$ 个节点合并成新节点，若 $(n - 1) \% (k - 1) \neq 0$ 则补充权值为 0 的节点。部分题解还提到记录节点深度以满足最长字符串最短的要求。

### 所选题解
- **作者：_Sein (5星)**
    - **关键亮点**：思路清晰，对哈夫曼树的定义、基本概念、 $k$ 叉哈夫曼树及哈夫曼编码都有详细解释，代码简洁易懂。
- **作者：crazydave (4星)**
    - **关键亮点**：详细阐述了哈夫曼树和哈夫曼编码的原理，对思路和细节的解释很到位，代码有详细注释。
- **作者：无咕_ (4星)**
    - **关键亮点**：对题目大意和解题思路有清晰的讲解，代码注释丰富，还给出了 $AC$ 记录和类似题型提示。

### 重点代码及核心实现思想
#### _Sein 的代码
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define ll long long
using namespace std;
struct node
{
    ll w,h;
    node(){w=0,h=0;}
    node(ll w,ll h):w(w),h(h){}
    bool operator <(const node &a)const{return a.w==w?h>a.h:w>a.w;}
};
ll ans;
priority_queue<node>q;
int main()
{
    ll n,k;ans=0;scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;i++)
    {
        ll w;scanf("%lld",&w);
        q.push(node(w,1));
    }
    while((q.size()-1)%(k-1)!=0)q.push(node(0,1));
    while(q.size()>=k)
    {
        ll h=-1;ll w=0;
        for(int i=1;i<=k;++i)
        {
            node t=q.top();q.pop();
            h=max(h,t.h);
            w+=t.w;
        }
        ans+=w;
        q.push(node(w,h+1));
    }
    printf("%lld\n%lld\n",ans,q.top().h-1);
    return 0;
}
```
**核心实现思想**：定义节点结构体 `node` ，包含权值 `w` 和高度 `h` 。使用优先队列 `q` 存储节点，将所有节点插入队列后，若不满足 $(n - 1) \% (k - 1) = 0$ 则补充权值为 0 的节点。每次从队列中取出权值最小的 $k$ 个节点，合并成新节点并更新队列，同时累加合并后的权值到 `ans` 中，最终输出 `ans` 和最深叶子节点的深度。

#### crazydave 的代码
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#include <ext/pb_ds/priority_queue.hpp> //pb_ds库
#define LL long long 
using namespace std;
struct node{
    LL w,h;
    node(LL W, LL H){
        w=W,h=H;
    }
};
bool operator<(node a, node b){
    if(a.w!=b.w) return a.w>b.w; 
    return a.h>b.h;  //如果长度相等，高度小的优先
} //构造小根堆的操作。
__gnu_pbds::priority_queue <node, std::less<node>, __gnu_pbds::pairing_heap_tag> q; //优先队列
int n,k,cnt;
LL temp,maxh,ans;

int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1; i<=n; i++){
        scanf("%lld",&temp);
        q.push(node(temp,1));
    }
    if((n-1)%(k-1) != 0) cnt=k-1-(n-1)%(k-1);  //判断是否要补空节点
    for (int i=1; i<=cnt; i++)
        q.push(node(0,1)); //补空节点
    cnt+=n;     //cnt为根节点个数(最初每个根节点都为其本身）
    while(cnt>1){
        temp=maxh=0;
        for(int i=1; i<=k; i++){
            temp+=q.top().w;
            maxh=max(maxh,q.top().h);
            q.pop();
        }
        ans+=temp; //维护带权路径长度之和
        q.push(node(temp, maxh+1)); //合并，高度为最高子树高度+1
        cnt-=k-1; //减少根节点
    }
    printf("%lld\n%lld\n",ans,q.top().h-1);
    return 0;
}
```
**核心实现思想**：同样定义节点结构体 `node` ，使用优先队列 `q` 存储节点。判断是否需要补充空节点，若需要则补充。每次从队列中取出 $k$ 个节点，计算合并后的权值和最大高度，更新队列和 `ans` ，最终输出结果。

#### 无咕_ 的代码
```cpp
#include<iostream>//标准输入输出流
#include<cstdio>//c语言标准输入输出
#include<cmath>//c数学运算
#include<cstring>//c语言字符串
#include<queue>//队列
using namespace std;//调用命名空间
typedef long long ll;//将"long long"用"ll"代替
struct Tree{//定义结构体"Tree"
    ll w,h;//注意是long long类型，第一个w表示权值，第二个h表示高度（也可以说是长度，因为一层就是一个字符长度）
    bool operator<(const Tree &x)const{//重载运算符
        if(w!=x.w)return w>x.w;//优先考虑权值大
        return h>x.h;//其次考虑长度
    }
};priority_queue<Tree>tree;//类型为"Tree"的优先队列"tree"
ll n,k,ans1=0,ans2,x;//单词数量、进制、答案1、答案2、替死鬼"x"（啥都干，无具体意义，但出于懒就定义了全局变量）
int main(){
    scanf("%lld %lld",&n,&k);//注意是"%lld"，以防RE
    for(int i=1;i<=n;i++){
        scanf("%lld",&x);//读入替死鬼（权值）
        tree.push((Tree){x,1});//默认高度为1（这里的强制类型转换有点麻烦）
    }if((n-1)%(k-1)){//先检测，如果不是0才进入判断
        x=k-1-(n-1)%(k-1);//求出要补的结点个数
        for(int i=1;i<=x;i++)tree.push((Tree){0,1});//「补点」操作
    }ll sumw,maxh;//ans1和ans2的临时值
    while(tree.size()!=1){//因为不可能是负数，所以只要大于1个点就跑
        sumw=0,maxh=-2147483647;//初始值要在循环定义
        for(int i=1;i<=k;i++){//每次选出k个值
            sumw+=tree.top().w;//取出队首加到总和里
            maxh=max(tree.top().h,maxh);//找最小长度
            tree.pop();//队头出队
        }tree.push((Tree){sumw,maxh+1});//加上合并的值，这里不直接用ans1、ans2的好处就体现出来了（加1是因为合并后的长度是要增加1的）
        ans1+=sumw;//然后才是存储数据
        ans2=max(maxh,ans2);//存储数据
    }printf("%lld\n%lld",ans1,ans2);//这时候一口气输出
    return 0;//好习惯养成
}
```
**核心实现思想**：定义结构体 `Tree` 表示节点，使用优先队列 `tree` 存储节点。判断是否需要补充节点，若需要则补充。每次从队列中取出 $k$ 个节点，合并成新节点并更新队列和答案，最终输出结果。

### 最优关键思路或技巧
- **数据结构**：使用优先队列（小根堆）可以高效地选取权值最小的 $k$ 个节点，时间复杂度为 $O(log n)$ 。
- **补点技巧**：当 $(n - 1) \% (k - 1) \neq 0$ 时，补充权值为 0 的节点，确保每次合并都能取出 $k$ 个节点，保证结果最优。
- **记录深度**：在节点结构体中记录节点深度，合并节点时更新深度，可满足最长字符串最短的要求。

### 可拓展之处
同类型题或类似算法套路：
- **哈夫曼编码应用**：数据压缩、数据加密等领域可使用哈夫曼编码。
- **多叉树问题**：其他多叉树的构建和优化问题，可参考 $k$ 叉哈夫曼树的构建思路。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：二叉哈夫曼树的基础应用。
- [P2807 三角形牧场](https://www.luogu.com.cn/problem/P2807)：涉及贪心和哈夫曼树思想。
- [P3865 【模板】ST 表](https://www.luogu.com.cn/problem/P3865)：与数据结构和区间查询相关，可拓展思维。

### 个人心得摘录与总结
- **TheShadow**：忘开 `long long` 调了半天。总结：在处理大数据范围的题目时，要注意数据类型的选择，避免因数据溢出导致错误。

---
处理用时：65.48秒
# 题目信息

# 良好的感觉

## 题目描述

kkk 做了一个人体感觉分析器。每一天，人都有一个感受值 $A_i$，$A_i$ 越大，表示人感觉越舒适。在一段时间 $\left[i, j\right]$ 内，人的舒适程度定义为 $\left[i, j\right]$ 中最不舒服的那一天的感受值 $\times$ $\left[i, j\right]$中每一天感受值的和。现在给出 kkk 在连续 $N$ 天中的感受值，请问，在哪一段时间，kkk 感觉最舒适？


## 说明/提示

kkk 最开心的一段时间是第 $3$ 天到第 $5$ 天，开心值：$(6+4+5)\times4=60$。

对于 $30\%$ 的数据，$1\le N\le 100$。

对于 $70\%$ 的数据，$1\le N\le 2000$。

对于 $100\%$ 的数据，$1\le N\le 100000$，$1\le \texttt{感受值}\le 1000000$。

## 样例 #1

### 输入

```
6
3 1 6 4 5 2```

### 输出

```
60```

# AI分析结果

### 综合分析与结论
本题的核心是在给定的连续 $N$ 天感受值序列中，找出一段时间区间，使得该区间内最不舒服的那一天的感受值乘以该区间内每一天感受值的和最大。各题解的主要思路都是围绕枚举最小值并确定其左右扩展范围来计算区间和，再计算舒适程度，只是在确定扩展范围的方法上有所不同。

### 所选题解
- **作者：xMinh (赞：78)，4星**
    - **关键亮点**：使用单调栈优化，思路清晰，代码简洁，时间复杂度为 $O(n)$。
    - **个人心得**：第一次没看题解用单调队列来优化DP，思考近一小时。意识到队中元素应是最不舒服的值，通过在序列最后加一个值为0的元素解决元素未被踢掉的问题。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define rint register int
using namespace std;
long long n,a[100001],q[100001],sum[100001],f[100001],ans,tail;
int main()
{
    scanf("%lld",&n);
    for (rint i=1;i<=n;i++) scanf("%lld",&a[i]);
    n++;a[n]=0;
    for (rint i=1;i<=n;i++) 
    {
        sum[i]=sum[i-1]+a[i];
        while (a[q[tail]]>a[i])
        {
            f[q[tail]]+=(sum[i-1]-sum[q[tail]]);
            tail--;
        }
        f[i]=sum[i]-sum[q[tail]];
        q[++tail]=i;
    }
    for (rint i=1;i<=n-1;i++) ans=max(ans,f[i]*a[i]);
    printf("%lld",ans);
}
```
**核心实现思想**：维护一个单调递增的栈，栈中存储元素的下标。当新元素入栈时，若栈顶元素大于新元素，则弹出栈顶元素并计算其能扩展的区间和，更新答案。最后在序列末尾添加一个值为0的元素，确保所有元素都能被处理。

- **作者：peterwuyihong (赞：22)，4星**
    - **关键亮点**：使用悬线法，利用已计算的信息更新左右边界，代码简洁易懂。
```cpp
#define maxn 100010
int n;
int s[maxn];
int l[maxn],r[maxn],a[maxn];
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],s[i]=s[i-1]+a[i],l[i]=r[i]=i;
	for(int i=1;i<=n;i++)
	    while(l[i]>1&&a[i]<=a[l[i]-1])l[i]=l[l[i]-1];
	for(int i=n;i;i--)
	    while(r[i]<n&&a[i]<=a[r[i]+1])r[i]=r[r[i]+1];
	long long ans=0;
	for(int i=1;i<=n;i++)ans=max(ans,(long long)a[i]*(s[r[i]]-s[l[i]-1]));
	cout<<ans<<endl;
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}
```
**核心实现思想**：初始化左右边界为自身，然后顺序遍历更新左边界，倒序遍历更新右边界。最后计算每个元素作为最小值时的舒适程度，取最大值。

- **作者：Treaker (赞：20)，4星**
    - **关键亮点**：使用单调栈和前缀和，思路清晰，代码规范。
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int N = 100005;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , top;
int a[N] , st[N] , l[N] , r[N];
long long sum[N];
long long ans;
int main()
{
	n = read();
	for(int i = 1;i <= n;i ++)	sum[i] = sum[i-1] + (a[i] = read());
	for(int i = 1;i <= n;i ++)
	{
		while(top && a[st[top]] >= a[i]) top --;
		l[i] = st[top];
		st[++top] = i;
	}
	top = 0;
	st[0] = n+1;
	for(int i = n;i >= 1;i --)
	{
		while(top && a[st[top]] >= a[i]) top --;
		r[i] = st[top] - 1;
		st[++top] = i;
 	}
 	for(int i = 1;i <= n;i ++)	ans = max(ans,(sum[r[i]] - sum[l[i]]) * a[i]);
 	return printf("%lld\n",ans) , 0;
}
```
**核心实现思想**：维护一个单调递减的栈，正序遍历求出每个元素的左边界，倒序遍历求出每个元素的右边界。最后计算每个元素作为最小值时的舒适程度，取最大值。

### 最优关键思路或技巧
- **单调栈**：通过维护单调栈可以在 $O(n)$ 的时间复杂度内确定每个元素左右第一个比它小的元素，从而确定其能扩展的区间。
- **前缀和**：利用前缀和可以在 $O(1)$ 的时间复杂度内计算区间和。
- **悬线法**：利用已计算的信息更新左右边界，减少重复计算。

### 可拓展之处
同类型题或类似算法套路：
- 求最大矩形面积：在直方图中找到最大的矩形面积，可使用单调栈求解。
- 求最大子矩阵和：在矩阵中找到一个子矩阵，使其元素和最大，可使用悬线法或单调栈求解。

### 推荐题目
- P1169 [ZJOI2007]棋盘制作
- P2866 [USACO06NOV]Bad Hair Day S
- P4147 玉蟾宫

### 个人心得总结
- xMinh：思考近一小时，通过在序列末尾添加0元素解决元素未被踢掉的问题。
- 玫葵之蝶：本想写70分代码，结果数据太水AC了，时间复杂度在特殊情况下会退化。
- Lance1ot：纯暴力可能被卡，可通过倍增和ST表优化到 $O(nlogn)$。 

---
处理用时：46.06秒
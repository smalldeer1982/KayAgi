# 题目信息

# [USACO11OPEN] Mowing the Lawn G

## 题目描述

在一年前赢得了小镇的最佳草坪比赛后，Farmer John 变得很懒，再也没有修剪过草坪。现在，新一轮的最佳草坪比赛又开始了，Farmer John 希望能够再次夺冠。

然而，Farmer John 的草坪非常脏乱，因此，Farmer John 只能够让他的奶牛来完成这项工作。Farmer John 有 $N$（$1\le N\le 10^5$）只排成一排的奶牛，编号为 $1\ldots N$。每只奶牛的效率是不同的，奶牛 $i$ 的效率为 $E_i$（$0\le E_i\le 10^9$）。

靠近的奶牛们很熟悉，因此，如果 Farmer John安排超过 $K$ 只连续的奶牛，那么，这些奶牛就会罢工去开派对 :)。因此，现在 Farmer John 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 $K$ 只奶牛。

## 样例 #1

### 输入

```
5 2
1
2
3
4
5
```

### 输出

```
12
```

# AI分析结果

### 综合分析与结论
本题主要围绕如何在限制连续奶牛数量的条件下，计算最大效率展开，核心解法是动态规划结合单调队列、线段树等数据结构进行优化。各题解思路大致可分为顺推和逆推两种方向，通过不同的状态定义和转移方程来解决问题。

### 所选题解
- **作者：Koakuma (赞：263)，5星**
    - **关键亮点**：思路全面，详细介绍了顺推和逆推的三种不同思路，对状态定义、转移方程的推导及优化过程讲解清晰，有助于读者深入理解动态规划和单调队列优化的原理。
    - **个人心得**：作者表示写此文章是为了加深印象，提到有些关于变量边界的问题需读者自行画图理解，也欢迎读者在评论区指出问题。
- **作者：thmyl (赞：60)，4星**
    - **关键亮点**：思路清晰，先给出状态转移方程，再通过前缀和优化，最后用单调队列维护，代码实现简洁明了，易于理解。
    - **个人心得**：无
- **作者：Refined_heart (赞：34)，4星**
    - **关键亮点**：同样采用单调队列优化DP的思路，对状态转移方程的分析和优化过程有详细说明，代码注释较为清晰，方便读者理解。
    - **个人心得**：无

### 重点代码及核心实现思想
#### Koakuma的逆推思路
```cpp
// 逆推思路，求最小效率损失
// dp[i] 表示前 i 头奶牛且第 i 头奶牛不工作时的最小损失
// dp[i]=min{dp[j]}+E[i] (i-K-1<=j<i)
// 最后答案为总和减去 dp[N+1]
```
**核心思想**：将问题转化为求最小效率损失，通过单调队列维护长度为 `K + 1` 的区间中 `dp[j]` 的最小值，最后用总效率减去最小损失得到最大效率。

#### thmyl的代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long n,m,a[100010],sum[100010],f[100010];
long long d[100010];
int q[100010],head=0,tail=1;
long long que(int i){//让返回值尽量的大，队列单调减，使首元素恒最大 
    d[i]=f[i-1]-sum[i];
    while(head<=tail&&d[q[tail]]<d[i])tail--;
    q[++tail]=i;
    while(head<=tail&&q[head]<i-m)head++;
    return d[q[head]];
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++)cin>>a[i],sum[i]=sum[i-1]+a[i];
    for(int i=1;i<=n;i++)f[i]=que(i)+sum[i];
    cout<<f[n];
}
```
**核心思想**：通过前缀和优化状态转移方程，用单调队列维护 `dp[j - 1] - sum[j]` 的最大值，从而得到前 `i` 头奶牛的最大效率。

#### Refined_heart的代码
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
long long q[2000000],f[2000000][2];
long long n,k,s[2000000],a[2000000];
long long tail,head;
int main(){
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;++i){
        scanf("%lld",&a[i]);
        s[i]=s[i-1]+a[i];//sum
    }
    tail=head=1;//初始化 
    for(int i=1;i<=n;++i){
        f[i][0]=max(f[i-1][0],f[i-1][1]);//对于不选i，只考虑前面两个即可 
        while(q[head]<i-k&&head<=tail)head++;//判断队头是否在所找区间内 
        f[i][1]=f[q[head]][0]-s[q[head]]+s[i];//取MAX转移 
        while(f[i][0]-s[i]>f[q[tail]][0]-s[q[tail]]&&head<=tail)tail--;
        q[++tail]=i;//更新队尾，当队列有数且当前队尾若插入i不满足单调性时
        //写成s[i]-f[i][0]<s[q[tail]]-f[q[tail]][0]也可以
        //可以理解为选到i和队尾时，两者不选的奶牛的效率和相比较，显然浪费少的更优，不优的删除即可 
    }printf("%lld\n",max(f[n][0],f[n][1]));
    return 0;
}
```
**核心思想**：用 `dp[i][0/1]` 表示序列选到第 `i` 个奶牛时，第 `i` 个奶牛选/不选的最大效率，通过前缀和优化转移方程，用单调队列维护 `dp[j][0] - sum[j]` 的最大值。

### 最优关键思路或技巧
- **状态定义与转化**：可以从顺推和逆推两个方向定义状态，如逆推时将问题转化为求最小效率损失，使问题更易解决。
- **前缀和优化**：通过预处理前缀和，将区间求和的复杂度从 $O(k)$ 优化到 $O(1)$。
- **单调队列优化**：利用单调队列维护区间最值，将时间复杂度从 $O(nk)$ 优化到 $O(n)$。

### 可拓展之处
同类型题通常是在一定限制条件下求最优解，如限制连续选择的数量、选择的间隔等。类似算法套路可用于解决一些具有区间限制的动态规划问题，如股票交易、烽火传递等问题。

### 推荐题目
- [P1725 琪露诺](https://www.luogu.com.cn/problem/P1725)：同样是在一定区间限制下求最优解的动态规划问题，可使用单调队列优化。
- [P2569 [SCOI2010]股票交易](https://www.luogu.com.cn/problem/P2569)：涉及到股票买卖的动态规划问题，需要考虑交易次数、持有股票数量等限制条件，可使用单调队列优化。
- [P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)：单调队列的模板题，可帮助读者熟悉单调队列的基本操作和应用。

### 个人心得摘录与总结
- **不开 `long long` 见祖宗**：由于数据范围较大，统计几个奶牛的前缀和就可能爆 `int`，因此要使用 `long long` 类型。
- **单调队列使用注意事项**：使用单调队列时要注意队列的边界条件，如队首是否超出范围、队尾是否满足单调性等，同时要保证队列中元素的合法性。
- **初始状态的处理**：在使用单调队列优化DP时，要注意初始状态的处理，确保单调队列的正确性。

---
处理用时：46.89秒
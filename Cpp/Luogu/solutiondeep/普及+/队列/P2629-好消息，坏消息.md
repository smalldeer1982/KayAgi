# 题目信息

# 好消息，坏消息

## 题目描述

Uim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。

Uim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。

Uim 必须按照事件的发生顺序逐条将消息告知给老板。不过 Uim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以按 $k,k+1,k+2,\ldots,n,1,2,\ldots,k-1$（事件编号）这种顺序通报。

他希望知道，有多少个 $k$，可以使从 $k$ 号事件开始通报到 $n$ 号事件然后再从 $1$ 号事件通报到 $k-1$ 号事件可以让老板不发怒。

## 说明/提示

**【样例解释】**

通报事件的可行顺序（用编号表示）为 $2\rightarrow3\rightarrow4\rightarrow1$ 或 $3\rightarrow4\rightarrow1\rightarrow2$（分别对应 $k=2$ 和 $k=3$）

通报事件的可行顺序（用好坏度表示）为 $5\rightarrow1\rightarrow2\rightarrow(-3)$ 或 $1\rightarrow2\rightarrow(-3)\rightarrow5$

**【数据范围】**

对于 $25\%$ 的数据，$n\le10^3$；  
对于 $75\%$ 的数据，$n\le10^4$；  
对于 $100\%$ 的数据，$1 \le n\le 10^6$。

## 样例 #1

### 输入

```
4
-3 5 1 2
```

### 输出

```
2

```

# AI分析结果

### 综合分析与结论
本题主要求解有多少个 $k$ 能使按特定顺序通报消息时老板心情不低于 0。各题解的核心思路大多围绕前缀和展开，通过不同的数据结构和算法优化来判断每个 $k$ 是否合法。

常见思路是先预处理前缀和，再用不同方法维护区间最小值以判断老板心情是否始终非负。如单调队列、ST 表、线段树等数据结构可高效维护区间最小值，部分题解还采用了断环为链的技巧简化问题。

### 所选题解
- **憧憬未来（5 星）**
    - **关键亮点**：思路清晰，详细阐述了断环为链和前缀和的运用，结合单调队列优化，时间复杂度低。
    - **核心代码**：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,head=1,tail,ans;
long long a[2000001],s[2000001],q[2000001];
int main()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i+=1)
        scanf("%lld",&a[i]);
    for(register int i=1;i<=n-1;i+=1)
        a[i+n]=a[i];
    for(register int i=1;i<=2*n-1;i+=1)
        s[i]=s[i-1]+a[i];
    for(register int i=1;i<=2*n-1;i+=1)
    {
        while(head<=tail&&max(i-n+1,1)>q[head])head++;
        while(head<=tail&&s[i]<=s[q[tail]])tail--;
        q[++tail]=i;
        if(i-n+1>0&&s[q[head]]-s[i-n]>=0)ans++;
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心思想**：先将数组断环为链，计算前缀和。然后用单调队列维护长度为 $n$ 的区间的最小前缀和，若最小前缀和减去区间起点前的前缀和非负，则该区间对应的 $k$ 合法。

- **swm_sxt（4 星）**
    - **关键亮点**：代码简洁，通过维护前缀数组的最大最小值解决问题，时间复杂度为 $O(n)$。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n;
long long a[1000001],q[1000001],miq[1000001],miz[1000001],ans=0;
int main(){
    scanf("%lld",&n);
    miq[0]=1e17;miz[n+1]=1e17;
    for (long long i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        q[i]=q[i-1]+a[i];
        miq[i]=min(q[i],miq[i-1]);
    }
    for (long long i=n;i>=1;i--) miz[i]=min(q[i],miz[i+1]);
    for (long long i=1;i<=n;i++) if ((miz[i]-q[i-1]>=0)&&(miq[i-1]+q[n]-q[i-1]>=0)) ans++;
    printf("%lld\n",ans);
}
```
    - **核心思想**：预处理前缀和，同时维护从 1 到 $i$ 的前缀和最小值 `miq` 和从 $i$ 到 $n$ 的前缀和最小值 `miz`。对于每个 $k$，判断 `miz[k] - q[k - 1]` 和 `miq[k - 1] + q[n] - q[k - 1]` 是否非负，若都非负则 $k$ 合法。

- **_ztyqwq（4 星）**
    - **关键亮点**：思路清晰，通过维护两个前缀和最小值数组，可 $O(1)$ 求出每个 $k$ 的答案，时间复杂度为 $O(n)$。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll s[1000001],m[1000002][2];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        ll a;
        scanf("%lld",&a);
        s[i]=s[i-1]+a;
    }
    m[0][0]=m[n+1][1]=LONG_LONG_MAX>>1;
    for(int i=1;i<=n;i++)
        m[i][0]=min(m[i-1][0],s[i]);
    for(int i=n;i>=1;i--)
        m[i][1]=min(m[i+1][1],s[i]);
    int ans=0;
    for(int i=1;i<=n;i++)
        if(m[i-1][0]+(s[n]-s[i-1])>=0&&m[i][1]-s[i-1]>=0)
            ans++;
    printf("%d\n",ans);
    return 0;
}
```
    - **核心思想**：计算前缀和，维护 `m[i][0]` 表示 1 到 $i$ 的前缀和最小值，`m[i][1]` 表示 $i$ 到 $n$ 的前缀和最小值。对于每个 $k$，判断 `m[k - 1][0] + (s[n] - s[k - 1])` 和 `m[k][1] - s[k - 1]` 是否非负，若都非负则 $k$ 合法。

### 最优关键思路或技巧
- **断环为链**：将环形问题转化为链式问题，方便处理不同 $k$ 的情况。
- **前缀和**：通过预处理前缀和，可快速计算任意区间的和。
- **单调队列**：用于维护区间的最小前缀和，时间复杂度为 $O(n)$。
- **维护最值数组**：提前计算并维护前缀和的最值，可 $O(1)$ 判断 $k$ 是否合法。

### 可拓展之处
同类型题如环形序列的最大子段和、环形序列的最小子段和等。类似算法套路包括断环为链、前缀和、单调队列、ST 表、线段树等，可用于解决区间最值、区间和等问题。

### 推荐题目
- P1115 最大子段和
- P2880 [USACO07JAN]Balanced Lineup G
- P3865 [模板]ST 表

### 个人心得摘录与总结
- **顾z**：开始用线段树维护区间和只得到 45 分，后发现要维护前缀和的最小值，且要考虑从 1 到 $n$ 的情况，最终解决问题。总结为做题时要深入理解题意，考虑全面，避免思维局限。
- **Poetic_Rain**：暴力做法得 75 分，尝试快读和吸氧仍 TLE，后通过观察样例发现用单调队列维护区间最小前缀和可解决问题。启示是遇到超时问题可通过分析样例寻找优化思路。 

---
处理用时：44.15秒
# 题目信息

# [AHOI2017初中组] alter

## 题目描述

有 $n$ 盏灯排成一列，其中有些灯开着，有些灯关着。小可可希望灯是错落有致的，他定义一列灯的状态的不优美度为这些灯中最长的连续的开着或关着的灯的个数。小可可最多可以按开关 $k$ 次，每次操作可以使该盏灯的状态取反：原来开着的就关着，反之开着。现在给出这些灯的状态，求操作后最小的不优美度。

## 说明/提示

$30\%$ 的数据：$1\le k \le n\le20$；

$50\%$ 的数据：$1\le k \le n\le300$；

另有 $15\%$ 的数据：$1\le k \le n\le 10^5$，字符串为全 `N` 或全 `F`；

$100\%$ 的数据：$1\le k \le n\le 10^5$。

本题已经加入 hack 数据。

## 样例 #1

### 输入

```
8 1
NNNFFNNN```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解大多采用二分答案的思路解决本题，因为题目所求的最小不优美度具有单调性，适合用二分查找。核心在于二分过程中的 `check` 函数，用于判断当前二分的不优美度是否能在 $k$ 次操作内达成。同时，所有题解都强调了对不优美度为 1 的情况进行特判，因为这种情况不能简单用普通的二分判断。

### 所选题解
- **Sooke（5星）**
    - **关键亮点**：思路清晰，详细阐述二分思路和特判方法，代码简洁易懂。
    - **个人心得**：提到二分有几个坑点，自己也被坑多次才AC，如二分最小值为 1 时要特判，注意是最多按 $k$ 次灯，以及二分赋值量大小关系别混淆。
- **Happy_Every_day（4星）**
    - **关键亮点**：分三种情况详细讨论，逻辑严谨，代码注释丰富。
    - **个人心得**：无
- **FreeTimeLove（4星）**
    - **关键亮点**：对二分判断的可行性分析透彻，解释了 $mid \geq 2$ 和 $mid = 1$ 时的不同判断方法。
    - **个人心得**：无

### 重点代码及核心实现思想
#### Sooke
```cpp
// 特判不优美度为 1 的情况
for(int i=0;i < n;i++)
    if(s[i] == c[i % 2]) p++;
if(p <= k || n-p <= k)
{cout << 1; return 0;}

// 二分查找最小不优美度
int lb=2,rb=n / k+1,mb;
while(lb <= rb)
{
    mb=(lb+rb) / 2;
    g=0;
    for(int i=0,j=0,l=0;i < n;i++)
    {
        if(s[j] == s[i]) l++;
        else j=i,l=1;
        if(mb < l) j=i+1,l=0,g++;
    }
    if(g <= k)
    {
        rb=mb-1;
    } else
        lb=mb+1;
}
cout << lb;
```
核心思想：先特判能否将不优美度变为 1，然后二分查找最小不优美度。二分过程中，统计将连续灯长度控制在当前二分答案内所需的最少操作次数，根据操作次数调整二分区间。

#### Happy_Every_day
```cpp
// 特判不优美度为 1 的情况
for (i=1;i<=n;i++) if ((i%2==1&&s[i]=='N')||(i%2==0&&s[i]=='F')) Suma++;
for (i=1;i<=n;i++) if ((i%2==0&&s[i]=='N')||(i%2==1&&s[i]=='F')) Sumb++;
if (Suma<=k||Sumb<=k) {puts ("1");return 0;}

// 记录连续相同字符的长度
for (i=1;i<=n;i++) {
    a[++Cnt]=1;
    while (s[i]==s[i+1]) {a[Cnt]++;i++;} 
}

// 二分查找最小不优美度
Left=2;Right=n;
while (Left<=Right) {
    Mid=(Left+Right)>>1;
    if (Check (Mid)==false) 
        Left=Mid+1;
    else 
        Right=Mid-1;
}
printf ("%d\n",Left);

// 检查函数
bool Check (int Ans) {
    int i,S;
    for (i=1,S=0;i<=Cnt;i++) S=S+a[i]/(Ans+1);
    if (S<=k) return true;else return false;
}
```
核心思想：先特判不优美度为 1 的情况，然后将连续相同字符的长度记录在数组中。二分查找最小不优美度，通过 `Check` 函数计算将所有连续段长度控制在当前二分答案内所需的操作次数，根据结果调整二分区间。

#### FreeTimeLove
```cpp
// 特判不优美度为 1 的情况
for(int i=1;i<=n;i++){
    a[i]=(s[i]=='N')?1:0;
    if((i+a[i])%2)ans++;
}
if(ans<=k||(n-ans)<=k){
    cout<<1<<endl;
    return 0;
}

// 计算每个连串长度
sum=1,num=a[1];
for(int i=2;i<=n+1;i++){
    if(a[i]==num)sum++;
    else{
        que[++tot]=sum;
        num=a[i];
        maxn=max(maxn,sum);	
        sum=1;
    }
}

// 二分查找最小不优美度
l=2,r=maxn;
while(l<r){
    int mid=(l+r)>>1;
    if(ok(mid))r=mid;
    else l=mid+1;
}
cout<<l<<endl;

// 检查函数
bool ok(int lim){
    x=lim+1,ans=0;
    for(int i=1;i<=tot;i++)
        ans+=que[i]/x;
    return ans<=k;
}
```
核心思想：先特判不优美度为 1 的情况，然后统计每个连串的长度。二分查找最小不优美度，通过 `ok` 函数计算将所有连串长度控制在当前二分答案内所需的操作次数，根据结果调整二分区间。

### 最优关键思路或技巧
- **二分答案**：利用答案的单调性，通过二分查找缩小答案范围，将时间复杂度从暴力枚举的 $O(n^2)$ 优化到 $O(n\log n)$。
- **特判不优美度为 1 的情况**：不优美度为 1 时，序列只有 `NFNF...` 和 `FNFN...` 两种可能，只需统计原序列与这两种序列的不同字符个数，判断是否能在 $k$ 次操作内达成。
- **计算操作次数**：对于长度为 $len$ 的连续段，要将其长度控制在 $mid$ 内，所需操作次数为 $\lfloor\frac{len}{mid + 1}\rfloor$。

### 可拓展之处
同类型题目通常涉及求最大值的最小值或最小值的最大值，可采用二分答案的思路。类似算法套路包括：先确定答案的范围，然后二分查找答案，在每次二分过程中通过一个检查函数判断当前答案是否可行，根据检查结果调整二分区间。

### 推荐题目
- [P1873 [COCI 2011/2012 #5] EKO / 砍树](https://www.luogu.com.cn/problem/P1873)
- [P2678 [NOIP2015 提高组] 跳石头](https://www.luogu.com.cn/problem/P2678)
- [P3853 [TJOI2007] 路标设置](https://www.luogu.com.cn/problem/P3853)

### 个人心得总结
多位作者提到二分最小值为 1 时要特判，这是本题的一个重要坑点。此外，还有作者指出要注意是最多按 $k$ 次灯，以及二分赋值量大小关系别混淆。在编写代码时，要仔细考虑边界情况和特殊情况，避免因疏忽导致错误。

---
处理用时：45.81秒
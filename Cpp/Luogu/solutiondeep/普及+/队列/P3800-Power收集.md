# 题目信息

# Power收集

## 题目背景

据说在红雾异变时，博丽灵梦单身前往红魔馆，用十分强硬的手段将事件解决了。

然而当时灵梦在 Power 达到 MAX 之前，不具有“上线收点”的能力，所以她想要知道她能收集多少 P 点，然而这个问题她答不上来，于是她找到了学 OI 的你。

## 题目描述

可以把游戏界面理解成一个 $N$ 行 $M$ 列的棋盘，有 $K$ 个格子上有 $P$ 点，其价值为 $\operatorname{val}(i,j)$。

初始灵梦可以选择在第一行的任意一个格子出发，每秒她必须下移一格。

灵梦具有一个左右移动的速度 $T$，可以使她每秒向左或右移动至多 $T$ 格，也可以不移动，并且不能折返。移动可视为瞬间完成，不经过路途上的点，只能获得目标格子的 P 点。

求最终她能获得的 POWER 值最大是多少？

## 说明/提示

对于 $40\%$ 的测试点，$1 \le N,M,T,K \le 200$。

对于 $100\%$ 的测试点，$1 \le N,M,T,K \le 4000$。

$v \le 100$，$N,M,K,T$ 均为整数。

by-szc

## 样例 #1

### 输入

```
3 3 4 1
1 1 3
1 2 1
2 2 3
3 3 3
```

### 输出

```
9```

# AI分析结果

### 综合分析与结论
这些题解主要围绕动态规划（DP）解决“Power收集”问题。普遍思路是定义状态 $f[i][j]$ 表示走到第 $i$ 行第 $j$ 列的最大价值，状态转移方程为 $f[i][j] = max(f[i - 1][k]) + v[i][j]\ ,\ (k\in [j - T , j + T]\ )$。直接枚举复杂度高，大部分题解采用单调队列优化，将复杂度从 $O(nmt)$ 降至 $O(nm)$。部分题解还从不同角度进行优化，如内存优化、依赖 $k$ 的复杂度优化等。

### 所选题解
- 作者：灵乌路空（4星）
  - 关键亮点：思路清晰，详细分析题意，通过图文结合的方式解释单调队列优化的原理，代码中使用手写数组模拟队列，常数小。
  - 个人心得：无
- 作者：_edge_（4星）
  - 关键亮点：不仅给出常规的单调队列优化解法，还进一步优化内存，甚至考虑依赖 $k$ 的复杂度，将复杂度优化到 $O(k \log k)$，思路独特且深入。
  - 个人心得：无
- 作者：囧仙（4星）
  - 关键亮点：将本题与经典 DP 题 P1216 对比，帮助理解，代码实现简洁明了。
  - 个人心得：无

### 重点代码
#### 灵乌路空题解核心代码
```cpp
// 向单调队列中插入元素 
void in(int x) {
    while(f[now - 1][x] > f[now - 1][q[tail]] && tail >= head) 
        tail--; // 取出队尾小于插入元素的数 , 以保证单调性 
    q[++tail] = x; // 插入队尾 
}
// 查询元素 
int find(int x) {
    if(x + t <= m) in(x + t); // 将能转移到x点 的 最后一个元素 x + t 插入队列 
    while(q[head] + t < x) head++; // 找到队首第一个能够转移到x的点 
    return q[head]; 
}
// 主函数部分
for(now = 2; now <= n; now++) { // 从第二行,开始转移 
    for(int i = 1; i <= t; i++) in(i); // 初始化单调队列 , 满足能够 转移j = 1的点 
    for(int j = 1; j <= m; j++) f[now][j] += f[now - 1][find(j)]; // 进行转移 
    head = tail = 1 , q[1] = 0; // 清空队列 
}
```
核心思想：通过单调队列维护上一行中能转移到当前点的最大值，每次更新时将新的可转移点加入队列，同时移除过时的点。

#### _edge_ 题解核心代码（依赖 $k$ 的复杂度优化部分）
```cpp
// 树状数组更新
void add(int x, int y) {
    for (; x <= 8000; x += lowbit(x))
        tree[x] = max(y, tree[x]);
    return;
}
// 树状数组查询
int query(int x) {
    int sum = 0;
    for (; x >= 1; x -= lowbit(x))
        sum = max(sum, tree[x]);
    return sum;
}
// 主函数部分
for (int i = 1; i <= k; i++) {
    int ans1 = query(a[i].y);
    f[i] = ans1 + a[i].z;
    add(a[i].y, f[i]);
    ans = max(ans, f[i]);
}
```
核心思想：将问题转化为二维偏序问题，使用树状数组维护大于等于当前 $y$ 的最大权值，通过排序和离散化处理，将复杂度优化到 $O(k \log k)$。

#### 囧仙题解核心代码
```cpp
// 单调队列弹出操作
void pop(int id) {
    while(h != r) {
        if(que[h].id < id) {
            h++;
        } else {
            return;
        }
    }
}
// 单调队列插入操作
void push(int id, int val) {
    while(h != r) {
        if(que[r - 1].val <= val) {
            r--;
        } else {
            break;
        }
    }
    que[r++] = {id, val};
}
// 主函数部分
for(int i = 1; i <= n; i++) {
    h = r = 1;
    for(int j = 1; j <= t; j++) {
        push(j, dp[i - 1][j]);
    }
    for(int j = 1; j <= m; j++) {
        pop(j - t);
        if(j + t <= m) push(j + t, dp[i - 1][j + t]);
        dp[i][j] = que[h].val + c[i][j];
    }
}
```
核心思想：使用单调队列维护上一行中能转移到当前点的最大值，通过弹出和插入操作保证队列的单调性。

### 最优关键思路或技巧
- **单调队列优化**：对于滑动窗口求最值问题，使用单调队列可以将时间复杂度从 $O(t)$ 优化到 $O(1)$。
- **内存优化**：使用滚动数组可以减少空间复杂度，对于记录地图的内存，可以使用指针或二分查找进行优化。
- **二维偏序优化**：将问题转化为二维偏序问题，使用树状数组或 CDQ 分治可以将复杂度优化到 $O(k \log k)$。

### 可拓展之处
同类型题或类似算法套路：
- **数塔问题**：与本题类似，通过动态规划求解路径最大值，可使用单调队列优化。
- **滑动窗口问题**：如洛谷 P1886 滑动窗口，可使用单调队列求解区间最值。
- **二维偏序问题**：可使用树状数组或 CDQ 分治解决，如一些求逆序对的问题。

### 推荐题目
- P1216 数字三角形
- P1886 滑动窗口
- P1725 琪露诺

### 个人心得摘录与总结
- comando：重载运算符时要防止出现权值一样的点被 set 认为是相等而仅插入一个点，调试花费了较多时间。总结：在使用自定义数据结构和重载运算符时，要注意元素相等的判断逻辑，避免出现意外情况。
- Seanq：指出 s_a_b_e_r 的代码初始化有问题，原代码只初始化第一个点可到，实际上每个点都可以走到，应将所有点的 dp 值初始化为其权值。总结：在动态规划中，初始化是非常重要的一步，要确保初始化的正确性，考虑所有可能的起始状态。

---
处理用时：44.83秒
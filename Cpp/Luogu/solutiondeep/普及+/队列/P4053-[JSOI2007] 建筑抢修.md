# 题目信息

# [JSOI2007] 建筑抢修

## 题目描述

小刚在玩 JSOI 提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T 部落消灭了所有 Z 部落的入侵者。但是 T 部落的基地里已经有 $N$ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T 部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N < 150000$，$1 \le T_1 < T_2 < 2^{31}$。

## 样例 #1

### 输入

```
4
100 200
200 1300
1000 1250
2000 3200```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解大多采用贪心算法结合堆（优先队列）来解决问题。核心思路是先按建筑报废时间（$t_2$）升序排序，再遍历建筑，能修则修，若不能修则考虑替换已修建筑中耗时最长的。部分题解使用了不同的排序方式或数据结构，如按最迟开始时间排序、用线段树或珂朵莉树维护未选时间，但复杂度和实现难度有所不同。

### 所选题解
- **作者：_Album_（5星）**
    - **关键亮点**：思路清晰，代码注释详细，优先队列的使用简洁明了，易于理解。
    - **核心代码**：
```Cpp
#include <bits/stdc++.h>
#define ll long long
#define I inline
#define N 150001
using namespace std;
struct Building{
    ll t1;
    ll t2;
}build[N];
bool cmp(Building a, Building b){
    return a.t2 < b.t2;
}
int n;
ll sum, ans;
priority_queue<ll > Q;
int main(){
    cin >> n;
    for(int i = 1; i <= n; i ++){
        cin >> build[i].t1 >> build[i].t2;
    }
    sort(build + 1, build + 1 + n, cmp);
    for(int i = 1; i <= n; i ++){
        sum += build[i].t1;
        Q.push(build[i].t1);
        if(sum <= build[i].t2){
            ans ++;
        }
        else{
            sum -= Q.top();
            Q.pop();
        }
    }
    cout << ans << "\n";
    return 0;
}
```
    - **核心思想**：先按$t_2$排序，遍历建筑，累加修理时间并加入优先队列。若当前累计时间超过该建筑报废时间，弹出队列中耗时最长的建筑，更新累计时间。

- **作者：Treaker（4星）**
    - **关键亮点**：代码简洁，清晰展示了贪心和堆维护的思路。
    - **核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
const int N = 150100;
int n, ans;
long long sum;
struct building
{
    long int s, t;
    friend bool operator < (const building&a,const building&b)
    {
        return a.t < b.t;
    }
}e[N];
priority_queue<long int> q;
int main()
{
    scanf("%d",&n);
    for(int i = 1;i <= n;i ++) scanf("%ld%ld",&e[i].s,&e[i].t);
    sort(e+1,e+1+n);
    for(int i = 1;i <= n;i ++)
    {
        sum += e[i].s;
        ans ++;
        q.push(e[i].s);
        if(sum > e[i].t) sum -= q.top(), q.pop(), ans --;
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心思想**：同样按$t_2$排序，遍历过程中累加时间和计数，若超报废时间则弹出堆顶元素并更新计数。

- **作者：过往梦魇之殇（4星）**
    - **关键亮点**：代码规范，注释详细，对输入输出进行了封装，方便复用。
    - **核心代码**：
```cpp
const int maxn=15e4;
struct node{
    int t1,t2;
}a[maxn];
priority_queue<int>q;
int n,ans;
long long t;
bool cmp(node x,node y){
    return x.t2<y.t2;
}
int main()
{
    n=read();
    for(re int i=1;i<=n;++i){
        a[i].t1=read();
        a[i].t2=read();
    }
    sort(a+1,a+n+1,cmp);
    for(re int i=1;i<=n;++i){
        if(a[i].t2>=t+a[i].t1){
            ++ans;
            t+=a[i].t1;
            q.push(a[i].t1);
        }
        else{
            if(q.size()&&a[i].t1<q.top()){
                t-=q.top();
                t+=a[i].t1;
                q.pop();
                q.push(a[i].t1);
            }
        }
    }
    write(ans);
    return 0;
}
```
    - **核心思想**：按$t_2$排序后遍历，能修则修，不能修且当前建筑耗时小于堆顶时，替换堆顶元素并更新时间。

### 最优关键思路或技巧
- **贪心策略**：按建筑报废时间升序排序，优先修理快报废的建筑。
- **数据结构**：使用优先队列（大根堆）维护已修建筑中耗时最长的，方便替换。

### 拓展思路
同类型题或类似算法套路：
- 区间调度问题：给定多个区间，选择最多不重叠的区间。
- 任务安排问题：有多个任务，每个任务有开始时间、结束时间和收益，求最大收益。

### 推荐题目
- P1803 凌乱的yyy / 线段覆盖
- P2082 区间覆盖
- P1230 智力大冲浪

### 个人心得摘录与总结
- **作者：wwldx**：按最迟开始时间排序只能得90分，原因是可能误判可插入的建筑。通过另设变量`maxx`存储间隙，可解决插入判断问题。总结为排序方式可能影响结果，需考虑特殊情况并添加辅助变量处理。 

---
处理用时：35.06秒
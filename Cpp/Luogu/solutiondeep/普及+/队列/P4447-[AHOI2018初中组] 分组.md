# 题目信息

# [AHOI2018初中组] 分组

## 题目描述

小可可的学校信息组总共有 $n$ 个队员，每个人都有一个实力值 $a_i$。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的 $n$ 个队员分成若干个小组去参加这场比赛。

但是每个队员都不会愿意与实力跟自己过于悬殊的队员组队，于是要求分成的每个小组的队员实力值连续，同时，一个队不需要两个实力相同的选手。举个例子：$[1, 2, 3, 4, 5]$ 是合法的分组方案，因为实力值连续；$[1, 2, 3, 5]$ 不是合法的分组方案，因为实力值不连续；$[0, 1, 1, 2]$ 同样不是合法的分组方案，因为出现了两个实力值为 $1$ 的选手。

如果有小组内人数太少，就会因为时间不够而无法获得高分，于是小可可想让你给出一个合法的分组方案，满足所有人都恰好分到一个小组，使得人数最少的组人数最多，输出人数最少的组人数的最大值。

注意：实力值可能是负数，分组的数量没有限制。

## 说明/提示

【样例解释】
分为 $2$ 组，一组的队员实力值是 $\{4, 5, 2, 3\}$，一组是 $\{-4, -3, -5\}$，其中最小的组人数为 $3$，可以发现没有比 $3$ 更优的分法了。

【数据范围】

对于 $100\%$ 的数据满足：$1\leq n\leq 100000$，$|a_i|\leq10^9$。

本题共 $10$ 个测试点，编号为 $1\sim10$，每个测试点额外保证如下：
| 测试点编号 | 数据限制 |
| :-----------: | :-----------: |
| $1\sim2$ | $n\leq 6, 1\leq a_i \leq 100$ |
| $3\sim4$ | $n\leq 1000, 1\leq a_i\leq 10^5$ 且 $a_i$ 互不相同 |
| $5\sim6$ | $n\leq 100000, a_i$ 互不相同 |
| $7\sim8$ | $n\leq 100000, 1\leq a_i \leq10^5$ |
| $9\sim 10$ | $n\leq 100000, -10^9 \leq a_i \leq 10^9$ |

## 样例 #1

### 输入

```
7
4 5 2 3 -4 -3 -5```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论
这些题解围绕“分组”问题提供了多种思路，核心目标都是使人数最少的组人数最大。思路主要分为模拟分组、二分答案、贪心算法三类。模拟分组通过维护数据结构模拟分组过程；二分答案通过二分查找最小组人数的最大值，并验证可行性；贪心算法则依据一定贪心策略进行分组。

### 所选题解
1. **Wenoide（5星）**
    - **关键亮点**：思路独特，将分组问题转化为“俄罗斯方块”式问题，形象直观；使用`std::map`自动排序特性记录图形，代码简洁高效。
    - **核心代码**：
```cpp
#include<cstdio>
#include<map>
std::map<int,int>m;
typedef std::map<int,int>::iterator it;
int main(){
    int n,ans=0x3f3f3f3f;
    scanf("%d",&n);
    for(int i=0;i<n;++i){
        int t;
        scanf("%d",&t);
        ++m[t];
    }
    while(!m.empty()){
        it i=m.begin(),j=m.begin();
        --(*i).second;
        int t=1;
        for(++j;j!=m.end()&&(*j).first==(*i).first+1&&(*j).second>(*i).second;++i,++j){
            ++t;
            --(*j).second;
        }
        i=m.begin();
        while(i!=m.end()&&(*i).second==0){
            m.erase((*i++).first);
        }
        if(t<ans){
            ans=t;
        }
    }
    printf("%d",ans);
    return 0;
}
```
    - **核心思想**：用`std::map`记录每个实力值的出现次数，模拟在最下方画线分组的过程，每次画线从最左边开始，若右边一列高度不低于当前列则继续画，更新最短画线长度为答案。
2. **CherryPockyOvO（4星）**
    - **关键亮点**：采用二分查找思路，通过维护`q`数组和`siz`数组模拟分组，代码实现巧妙；对二分查找的使用和数组单调性的维护有详细解释。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1e5+40;
int f[MAXN],n,ans=1e9,siz[MAXN],top,q[MAXN];
signed main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&f[i]);
    sort(f+1,f+n+1);
    for(int i=1;i<=n;i++){
        int pos=lower_bound(q+1,q+top+1,f[i])-q;
        while(q[pos+1]==f[i]&&pos<top) pos++;
        if(pos>top||q[pos]!=f[i]) siz[++top]=1,q[top]=f[i]+1;
        else siz[pos]++,q[pos]++;
    }
    for(int i=1;i<=top;i++) ans=min(ans,siz[i]);
    printf("%d\n",ans);
    return 0;
}
```
    - **核心思想**：先对实力值排序，用`q`数组记录每组要添加成员所需的实力值，通过二分查找找到合适的组，若找不到则新开组，最后取所有组大小的最小值为答案。
3. **xiaoniu142857（4星）**
    - **关键亮点**：通过手玩样例找到贪心性质，用队列维护分组，时间复杂度低；使用懒标记优化操作，代码简洁高效。
    - **核心代码**：
```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#define int unsigned int
#define N 100000
#define INF 0x7f7f7f7f
using namespace std;
char buf[1<<21],*p=buf;
int a[N],q[N],hd,tl,len,cur,cnt,shift,ans=INF;
inline void work(int x){
    if(x-cur>1){
        if(!len){
            putchar('1'),exit(0);
        }
        while(len){
            ans=min(ans,q[hd++]+shift);
            --len;
        }
    }
    else{
        if(cnt>len)
            for(int j=len;j<cnt;++j)
                q[tl++]=1-shift;
        else if(cnt<len)
            for(int j=cnt;j<len;++j)
                ans=min(ans,q[hd++]+shift);
        len=cnt,++shift;
    }
}
signed main(){
    int n;
    fread(buf,1,1<<21,stdin);
    read(n);
    if(n==1){
        putchar('1');
        return 0;
    }
    for(int i=0;i<n;++i) read(a[i]);
    sort(a,a+n),cur=a[0],cnt=1;
    for(int i=1;i<n;++i)
        if(a[i]==cur) ++cnt;
        else work(a[i]),cur=a[i],cnt=1;
    work(INF);
    printf("%d",ans);
    return 0;
}
```
    - **核心思想**：先对实力值排序，统计每个实力值的出现次数，用队列维护分组，根据当前列高度与队列长度的关系进行入队或出队操作，用懒标记维护队列元素的更新，最后取队列元素的最小值为答案。

### 最优关键思路或技巧
- **数据结构运用**：使用`std::map`记录实力值出现次数，利用其自动排序特性简化操作；使用优先队列维护组的大小，方便选取最小的组。
- **算法优化**：二分查找提高查找效率；懒标记优化队列元素的更新。
- **思维方式**：将分组问题转化为形象的“俄罗斯方块”问题，通过手玩样例找到贪心性质。

### 可拓展之处
同类型题可拓展到其他分组问题，如不同元素有不同属性，分组需满足多种条件。类似算法套路包括贪心算法、二分答案、模拟分组等，可用于解决资源分配、区间划分等问题。

### 推荐题目
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：考察贪心算法解决分组问题。
2. [P2676 [USACO07DEC]Bookshelf B](https://www.luogu.com.cn/problem/P2676)：涉及贪心和二分答案的思想。
3. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)：使用二分答案求解分组问题。

### 个人心得摘录与总结
- **Apro1066**：提到一开始二分写了60分，感觉思路没问题，看题解后将代码改进成二分答案通过，说明调试过程中思路正确但实现可能有问题，可参考他人思路优化代码。
- **GldHkkowo**：原本手写队列暴力被出题人叉掉5分，改用STL通过，表明STL在某些情况下能提高代码的正确性和效率。 

---
处理用时：45.09秒
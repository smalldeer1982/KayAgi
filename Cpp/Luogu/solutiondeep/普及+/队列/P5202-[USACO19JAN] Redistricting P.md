# 题目信息

# [USACO19JAN] Redistricting P

## 题目背景

USACO 19 年一月月赛铂金组第一题。

## 题目描述

奶牛们的特大城市，牛都，要进行重新分区了！——这总是一个在居住在这里的两大主要种族（荷斯坦牛和更赛牛）之间富有争议的政治事件，因为两大种族都想要在牛都政府中保持足够的影响力。

牛都的大都市圈由一列 $n$ 块牧草地组成，每块里有一头奶牛，均为荷斯坦牛 (Holstein) 和更赛牛 (Guernsey) 之一。

牛都政府想要将大都市圈划分为若干个连续的区，使得每个区至少包含一块牧草地且至多包含 $k$ 块牧草地，并且每块牧草地恰好属于一个区。由于政府当前由荷斯坦牛控制，她们想要找到一种分区方式能够最小化更赛牛较多或者均势的区的数量（如果更赛牛的数量与荷斯坦牛的数量相等那么这个区就是均势的）。

有一个关心政治的更赛牛团体想要知道政府的分区计划可能会对她们造成多少损害。帮助她们求出最坏情况，也就是更赛牛较多或是均势的区的最小可能的数量。

## 说明/提示

### 样例解释

一种可能的划分方式是 $[1],~[2, 3],~[4, 5],~[6, 7]$。第二、四个区是均势的区，第三个区是更赛牛优势的区。

### 数据范围

对于 $100\%$ 的数据，保证 $1 \leq k \leq n \leq 3 \times 10^5$，$s$ 的长度为 $n$，且只含字符 `H` 和 `G`。

## 样例 #1

### 输入

```
7 2
HGHGGHG```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
本题主要是将由 `H` 和 `G` 组成的字符串划分成多个连续区间，每个区间长度在 1 到 `k` 之间，要最小化 `G` 数量大于等于 `H` 数量的区间个数。各题解大多采用动态规划的方法，通过不同的数据结构进行优化，以降低时间复杂度。

常见思路是定义状态转移方程，如 $dp[i] = \min\{dp[j] + (sum[i] - sum[j] \leq 0)\}$（$i - j \leq k$），其中 $dp[i]$ 表示前 $i$ 个字符的最小不满意区间数，$sum[i]$ 是前缀和。为避免 $O(nk)$ 的时间复杂度，使用单调队列、堆、线段树等数据结构进行优化。

### 所选题解
- **梧桐灯（4星）**
  - **关键亮点**：使用单调队列实现，时间复杂度为 $O(n)$，思路清晰，代码简洁，有详细的注释和优化说明。
  - **个人心得**：提到单调队列好写、好记、好快，还调侃卡常和女装减小常数。
```cpp
#pragma GCC optimize ("Ofast")
#include <cstdio>
using namespace std;

inline void read (int& s) {
    s = 0;
    static char c = getchar ();
    while (c < '0' || c > '9') c = getchar ();
    while (c >= '0' && c <= '9') s = (s << 3) + (s << 1) + (c & 15), c = getchar ();
    return ;
}

const int N = 300007;
int n, k, f[N], sum[N];
int Q[N], H, T;

int main () {
    read (n), read (k);
    register int i; for (i = 1; i <= n; ++i) sum[i] = sum[i - 1] + (getchar () == 'H' ? 1 : -1);
    Q[T++] = 0; //刚开始前0头牛答案为0
    for (i = 1; i <= n; ++i) {
        while (H < T && i - Q[H] > k) ++H; //单调队列的出队操作
        f[i] = f[Q[H]] + (sum[i] - sum[Q[H]] <= 0);
        while (H < T) {
            if (f[i] < f[Q[T - 1]] || (f[i] == f[Q[T - 1]] && sum[i] < sum[Q[T - 1]])) --T;
            else break;
        } //入队操作，注意一下细节
        Q[T++] = i;
    }
    printf ("%d\n", f[n]);
    return 0;
}
```
**核心实现思想**：先读取输入并计算前缀和，然后使用单调队列维护可能的最优解。在遍历过程中，先将超出范围的队首元素出队，再根据队首元素更新当前状态，最后将当前元素按规则入队。

- **lam_dyr（4星）**
  - **关键亮点**：详细阐述了单调队列优化的思路和步骤，代码规范，注释清晰，时间复杂度为 $O(n)$。
  - **个人心得**：无
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=300005;
const int INF=1e9;
int sum[N],dp[N];
int q[N];
int head,tail;
int n,k;
string s;
int main() {
    cin>>n>>k;
    cin>>s;
    for(int i=1;i<=n;++i) 
        sum[i]=sum[i-1]+(s[i-1]=='H'?1:-1);
    for(int i=0;i<= n;++i) 
        dp[i]=INF;
    dp[0]=0;
    q[tail++]=0;
    for(int i=1;i<=n;++i){
        while(head<tail && q[head]<i-k){
            head++;
        }
        dp[i]=dp[q[head]]+(sum[i]-sum[q[head]]<=0);
        while(head<tail){
            int j=q[tail-1];
            if (dp[j]>dp[i] || (dp[j]==dp[i] && sum[j]>=sum[i])) 
                tail--;
            else 
                break;
        }
        q[tail++] = i;
    }
    cout<<dp[n];
    return 0;
}
```
**核心实现思想**：同样先计算前缀和并初始化 $dp$ 数组，然后利用单调队列维护状态转移。在遍历过程中，先移除超出范围的队首元素，再根据队首元素更新当前 $dp$ 值，最后将当前元素按规则入队。

- **ZeroF（4星）**
  - **关键亮点**：思路清晰，对朴素 $dp$ 方程和优化过程有详细说明，代码简洁易懂，时间复杂度为 $O(n)$。
  - **个人心得**：无
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[3*114514];
int cnt[3*114514],dp[3*114514];
deque<int>q;
int main(){
    int n,k;
    cin>>n>>k;
    scanf("%s",s+1);
    q.push_back(0);
    for(int i=1;i<=n;i++){
        if(s[i]=='G')cnt[i]=cnt[i-1]+1;
        else cnt[i]=cnt[i-1]-1;
        while(!q.empty()&&i-q.front()>k)q.pop_front();
        int j=q.front();
        if(cnt[i]-cnt[j]>=0)dp[i]=dp[j]+1;
        else dp[i]=dp[j];
        while(!q.empty()&&(dp[q.back()]>dp[i]||(dp[q.back()]==dp[i]&&cnt[i]-cnt[q.back()]>=0)))q.pop_back();
        q.push_back(i);
    }
    cout<<dp[n]<<endl;
    return 0;
}
```
**核心实现思想**：先读取输入并计算前缀和，然后使用双端队列维护状态转移。在遍历过程中，先移除超出范围的队首元素，再根据队首元素更新当前 $dp$ 值，最后将当前元素按规则入队。

### 最优关键思路或技巧
- **前缀和优化**：通过计算前缀和，可以在 $O(1)$ 时间内判断任意区间内 `H` 和 `G` 的数量差，从而快速判断区间是否为不满意区间。
- **单调队列优化**：利用单调队列维护可能的最优解，保证队列中 $dp[j]$ 递增，$sum[j]$ 在 $dp[j]$ 相等时递减，队头元素是当前窗口内最有可能得到最小 $dp[j]$ 的 $j$，将时间复杂度从 $O(nk)$ 降低到 $O(n)$。
- **双关键字堆优化**：使用双关键字的小根堆，一个关键字维护 $dp$ 的最小值，另一个关键字存储这个 $dp$ 值所在的位置 $i$，在 $dp$ 值相同的情况下维护 $pre$ 的最小值，时间复杂度为 $O(n \log k)$。

### 可拓展之处
同类型题或类似算法套路：
- **区间划分问题**：如将数组划分为若干个连续子数组，满足一定的条件，求最优划分方案。
- **滑动窗口问题**：涉及到在固定长度的窗口内求最值或满足特定条件的问题，可以使用单调队列或堆进行优化。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)：经典的滑动窗口问题，可使用单调队列求解。
2. [P2034 选择数字](https://www.luogu.com.cn/problem/P2034)：涉及区间划分和动态规划，可使用单调队列优化。
3. [P3957 跳房子](https://www.luogu.com.cn/problem/P3957)：动态规划问题，可使用单调队列优化转移过程。

### 个人心得摘录与总结
- **梧桐灯**：提到单调队列好写、好记、好快，还调侃卡常和女装减小常数，强调了单调队列在本题中的优势。
- **XGTD**：表示这道题比同一场另外两道简单，自己在模拟赛中只有这道题会做，体现了本题的难度层次。

---
处理用时：53.30秒
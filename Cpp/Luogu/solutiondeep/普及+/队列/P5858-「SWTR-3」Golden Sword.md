# 题目信息

# 「SWTR-3」Golden Sword

## 题目背景

小 E 不幸在一场战斗中失去了他的金宝剑。

## 题目描述

制造一把金宝剑需要 $n$ 种原料，编号为 $1$ 到 $n$，编号为 $i$ 的原料的坚固值为 $a_i$。

炼金是很讲究放入原料的顺序的，因此小 E 必须**按照 $1$ 到 $n$ 的顺序**依次将这些原料放入炼金锅。

但是，炼金锅的容量非常有限，它**最多只能容纳 $w$ 个原料**。

所幸的是，**每放入一个原料之前**，小 E 可以从中取出一些原料，数量不能超过 $s$ 个。

- 我们定义第 $i$ 种原料的耐久度为：放入第 $i$ 种原料时锅内的原料总数（包括正在放入的原料） $\times\ a_i$，则宝剑的耐久度为**所有原料**的耐久度之和。

小 E 当然想让他的宝剑的耐久度尽可能得大，这样他就可以带着它进行更多的战斗，请求出耐久度的最大值。

注：这里的“放入第 $i$ 种原料时锅内的原料总数**包括正在放入锅中的原料**，详细信息请见样例。

## 说明/提示

#### 「样例说明」

- **对于样例 1**，一种可行的**最优**方案为：
首先放进原料 1，此时锅内有 $1$ 种原料，耐久度为 $1\times a_1=1\times 1=1$。  
再放进原料 2，此时锅内有 $2$ 种原料，耐久度为 $2\times a_2=2\times 3=6$。  
再放进原料 3，此时锅内有 $3$ 种原料，耐久度为 $3\times a_3=3\times 2=6$。  
取出原料 1，再放进原料 4，此时锅内有 $3$ 种原料，耐久度为 $3\times a_4=3\times 4=12$。  
取出原料 4，再放进原料 5，此时锅内有 $3$ 种原料，耐久度为 $3\times a_5=3\times 5=15$。  
最终答案为 $1+6+6+12+15=40$。  
- **对于样例 2**，一种可行的**最优**方案为：  
放进原料 1，耐久度为 $1\times 1=1$。  
取出原料 1，放进原料 2，耐久度为 $1\times (-3)=-3$。  
放进原料 3，耐久度为 $2\times (-2)=-4$。  
放进原料 4，耐久度为 $3\times 4=12$。  
取出原料 2，放进原料 5，耐久度为 $3\times 5=15$。  
最终答案为 $1+(-3)+(-4)+12+15=21$。  
- **对于样例 3**，一种可行的**最优**方案为：  
  $a_1+2a_2+2a_3+3a_4+4a_5+3a_6+4a_7=17$。 
- **对于样例 4**，一种可行的**最优**方案为：  
$a_1+a_2+a_3+a_4+a_5=-15$。

#### 「数据范围与约定」

**本题使用捆绑测试。**

- Subtask #1（15 points）：$n\leq 10$。
- Subtask #2（5 points）：$n\leq 100$，$a_i\geq0$。
- Subtask #3（15 points）：$n\leq 300$。
- Subtask #4（15 points）：$s=w=n$。
- Subtask #5（5 points）：$a_i\geq 0$。
- Subtask #6（10 points）：$n\leq 2\times 10^3$。
- Subtask #7（10 points）：$s=1$。
- Subtask #8（25 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \leq s \leq w \leq n \leq 5\times 10^3$，$|a_i| \leq 10^9$。对于 Subtask $i$ 有 $|a_i|\leq 10^{i+1}$。

#### 「帮助/说明」

本题下发大样例，具体输入输出见 [**Big Sample**](https://pan.baidu.com/s/1erVDllDlvNlEShxh3U42gA) 中的 gold01-08.in/gold01-08.out。提取码：757d。  
**文件名与 Subtask 编号一一对应。**

#### 「来源」

[Sweet Round 03 D](https://www.luogu.com.cn/contest/24755)。  
idea & solution：ET2006。

## 样例 #1

### 输入

```
5 3 3
1 3 2 4 5
```

### 输出

```
40```

## 样例 #2

### 输入

```
5 3 3
1 -3 -2 4 5
```

### 输出

```
21```

## 样例 #3

### 输入

```
7 4 2
-5 3 -1 -4 7 -6 5
```

### 输出

```
17```

## 样例 #4

### 输入

```
5 3 1
-1 -3 -2 -4 -5
```

### 输出

```
-15```

# AI分析结果

### 综合分析与结论
这些题解主要围绕动态规划（DP）来解决制造金宝剑的最优耐久度问题。大部分题解先给出基础的 DP 思路和方程，然后针对时间复杂度高的问题，采用单调队列、线段树等方法进行优化。不同题解针对不同的数据范围给出了不同的解法，如爆搜、贪心、后缀最大值维护等。

### 所选题解
- **作者：pomelo_nene（5星）**
  - **关键亮点**：思路清晰，先给出基础的 DP 方程，再逐步分析优化过程，从 $O(nm^2)$ 优化到单调队列的 $O(nm)$，且代码实现简洁易懂。
  - **个人心得**：提到最初代码因数据水得到 85 分，之后发现可以用单调队列优化，还提到线段树调试失败。

### 重点代码
```cpp
// 基础 DP 代码
for(long long i=1;i<=n;++i)
{
    for(long long j=m;j;--j)
    {
        for(long long k=min(m,j+s-1);k>=j-1;--k)
        {
            dp[i][j]=max(dp[i][j],dp[i-1][k]+j*a[i]);
        }
    }
}
```
**核心实现思想**：通过三重循环，枚举放入的原料、锅内原料数量和上一步锅内原料数量，根据状态转移方程更新 dp 数组。

```cpp
// 单调队列优化代码
for(long long i=1;i<=n;++i)
{
    int l=1,r=1;
    q[l]=dp[i-1][m];
    pos[l]=m;
    for(long long j=m;j;--j)
    {
        while(pos[l]>j+s-1 && l<=r) ++l;
        while(q[r]<dp[i-1][j-1] && l<=r) --r;
        pos[++r]=j-1;
        q[r]=dp[i-1][j-1];
        dp[i][j]=q[l]+j*a[i];
    }
}
```
**核心实现思想**：使用单调队列维护区间最大值，减少不必要的比较，将时间复杂度优化到 $O(nm)$。

### 最优关键思路或技巧
- **动态规划**：定义状态 $dp_{i,j}$ 表示放进 $i$ 原料，且当时正有 $j$ 个原料所得到的最大耐久度，通过状态转移方程进行状态更新。
- **单调队列优化**：观察到状态转移方程中 $\max \{dp_{i - 1,k}\}$ 可以用单调队列维护，将时间复杂度从 $O(nm^2)$ 优化到 $O(nm)$。

### 可拓展之处
同类型题或类似算法套路：
- 涉及按顺序操作且状态与当前数量有关的问题，如资源分配、任务调度等。
- 可以用单调队列优化的动态规划问题，如滑动窗口最大值、区间最值问题等。

### 推荐题目
- [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)：考察单调队列的基本应用，与本题单调队列优化思路类似。
- [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)：多重背包问题，可通过单调队列优化时间复杂度。
- [P3957 跳房子](https://www.luogu.com.cn/problem/P3957)：动态规划结合单调队列优化，与本题优化思路相似。

### 个人心得总结
- pomelo_nene 提到最初代码因数据水得到 85 分，之后发现可以用单调队列优化，还提到线段树调试失败，这提醒我们在做题时要对算法复杂度有清晰的认识，并且不同数据结构的实现难度和效果可能不同，需要谨慎选择。

---
处理用时：24.70秒
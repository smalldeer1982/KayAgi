# 题目信息

# [NOIP 2004 提高组] 合并果子 加强版

## 题目背景

本题除【数据范围与约定】外与 [P1090](https://www.luogu.com.cn/problem/P1090) **完  全  一  致**。

## 题目描述

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $(n - 1)$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 $3$ 堆果子，数目依次为 $1,~2,~9$。可以先将 $1$、$2$ 堆合并，新堆数目为 $3$，耗费体力为 $3$。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$，耗费体力为 $12$。所以多多总共耗费体力为 $3+12=15$。可以证明 $15$ 为最小的体力耗费值。


## 说明/提示

**【数据规模与约定】**

**本题采用多测试点捆绑测试，共有四个子任务**。

- Subtask 1（10 points）：$1 \leq n \leq 8$。
- Subtask 2（20 points）：$1 \leq n \leq 10^3$。
- Subtask 3（30 points）：$1 \leq n \leq 10^5$。
- Subtask 4（40 points）：$1 \leq n \leq 10^7$。

对于全部的测试点，保证 $1 \leq a_i \leq 10^5$。

**【提示】**

- 请注意常数因子对程序效率造成的影响。
- 请使用类型合适的变量来存储本题的结果。
- 本题输入规模较大，请注意数据读入对程序效率造成的影响。



## 样例 #1

### 输入

```
3 
1 2 9 
```

### 输出

```
15
```

# AI分析结果

### 综合分析与结论
本题要求在 $O(n)$ 时间复杂度内解决合并果子问题，关键在于优化排序和贪心过程。各题解普遍采用贪心策略，即每次合并最小的两堆果子以达到最小体力耗费。为满足时间复杂度要求，排序部分多使用桶排，贪心过程则用两个队列替代优先队列。

### 所选题解
- **作者：Reanap（5星）**
    - **关键亮点**：思路清晰，详细阐述了从排序到优化插入的过程，代码注释完善，可读性高。
    - **核心代码**：
```cpp
#include <cstdio>
#include <queue>
#define int long long
using namespace std;
queue <int> q1;
queue <int> q2;
int to[100005];
void read(int &x){ 
    int f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
signed main() {
    int n;
    read(n);
    for (int i = 1; i <= n; ++i) {
        int a;
        read(a);
        to[a] ++;
    }
    for (int i = 1; i <= 100000; ++i) {
        while(to[i]) {
            to[i] --;
            q1.push(i);
        }
    }
    int ans = 0;
    for (int i = 1; i < n; ++i) {
        int x, y;
        if((q1.front() < q2.front() &&!q1.empty()) || q2.empty()) {
            x = q1.front();
            q1.pop();
        }
        else {
            x = q2.front();
            q2.pop();
        }
        if((q1.front() < q2.front() &&!q1.empty()) || q2.empty()) {
            y = q1.front();
            q1.pop();
        }
        else {
            y = q2.front();
            q2.pop();
        }
        ans += x + y;
        q2.push(x + y);
    } 
    printf("%lld", ans);
    return 0;
} 
```
    - **核心思想**：先通过桶排将果子数量存入 `to` 数组，再将排序结果放入队列 `q1`。每次从 `q1` 和 `q2` 中选取较小的两个数合并，合并结果存入 `q2`，累加合并消耗的体力。

- **作者：HPXXZYY（5星）**
    - **关键亮点**：从弱化版题目入手，逐步分析优化点，逻辑严谨，对队列的使用和正确性证明有清晰说明。
    - **核心代码**：
```cpp
const int N=1e7+100;
const int M=1e5+100;
long long ans;int n;
int a[N],cnt[M];//桶 
queue<long long> q1,q2;
inline long long get_first(){
    if (q2.empty()||(!q1.empty()&&q1.front()<q2.front()))
        {long long x=q1.front();q1.pop();return x;}
    else{long long x=q2.front();q2.pop();return x;}
}
int main(){
    memset(cnt,0,sizeof(cnt));
    n=read();ans=0ll;//init
    for(int i=1;i<=n;i++)
        cnt[a[i]=read()]++;
    for(int i=1;i<=100000;i++)
        for(int j=1;j<=cnt[i];j++)
            q1.push(i);//O(N)的桶排 
    for(register int i=1;i<n;i++){
        long long x=get_first();
        long long y=get_first();
        ans+=x+y;q2.push(x+y);
    }
    printf("%lld",ans);
    return 0;
}
```
    - **核心思想**：利用桶排统计每个重量的果子数量，将排序结果存入队列 `q1`。通过 `get_first` 函数从 `q1` 和 `q2` 中选取较小的数，合并后存入 `q2` 并累加结果。

- **作者：china·xyc（4星）**
    - **关键亮点**：详细分析了从排序到优化的过程，对复杂度的推导和队列单调性的说明清晰易懂。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace fastio{
    template<typename tn> void read(tn &a){
        tn x=0,f=1;char c=' ';
        for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
        for(;isdigit(c);c=getchar() ) x=x*10+c-'0';
        a=x*f;
    }
    template<typename tn> void print(tn a){
        if(a<0) putchar('-'),a=-a;
        if(a>9) print(a/10);
        putchar(a%10+'0');
    }
};
using namespace fastio;
#define int long long
const int M=1e5+5;
int b[M],a,n,ans=0;
queue<int> q1,q2;
int find(){
    int x;
    if((q1.front()<q2.front()&&!q1.empty())||q2.empty()){
        x=q1.front();
        q1.pop();
    }
    else {
        x=q2.front();
        q2.pop();
    }
    return x;
}
signed main(){
    read(n);
    for(int i=1;i<=n;i++) read(a),b[a]++;
    for(int i=1;i<M;i++) while(b[i]) b[i]--,q1.push(i);
    for(int i=1;i<n;i++){
        int x=find();
        int y=find();
        q2.push(x+y);
        ans+=x+y;
    }
    printf("%lld\n",ans);
    return 0;
}
```
    - **核心思想**：使用桶排统计果子重量，将排序结果存入 `q1`。通过 `find` 函数从 `q1` 和 `q2` 中选取较小的数，合并后存入 `q2` 并更新结果。

### 最优关键思路或技巧
- **桶排优化排序**：利用果子重量范围较小的特点，使用桶排将排序复杂度从 $O(n \log n)$ 降至 $O(n)$。
- **双队列替代优先队列**：用两个队列分别存储排序后的原序列和合并后的序列，利用合并结果的单调性，每次从队首选取最小值，避免了优先队列的 $O(\log n)$ 操作。

### 可拓展之处
同类型题如哈夫曼编码问题，可使用类似的贪心策略和数据结构优化。在处理数据范围较大且需要频繁取最小值的问题时，可考虑使用桶排和队列优化。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：本题的弱化版，可先从此题入手理解贪心思路。
- [P2168 [NOI2015] 荷马史诗](https://www.luogu.com.cn/problem/P2168)：哈夫曼树的拓展应用，需要考虑更多因素。
- [P4053 [JSOI2007] 建筑抢修](https://www.luogu.com.cn/problem/P4053)：涉及贪心策略和优先队列的应用。

### 个人心得
部分题解提到要注意常数因子对程序效率的影响，使用类型合适的变量存储结果，以及采用快速读入方式，避免因输入输出和数据类型问题导致超时或错误。 

---
处理用时：47.50秒
# 题目信息

# 「ACOI2020」课后期末考试滑溜滑溜补习班

## 题目背景

![T2](https://s2.ax1x.com/2020/01/12/lopS6f.png)

潮田 渚（Shiota Nagisa）因为理科不大好，自然会被仔细观察学生的杀老师发现，于是渚同学只得加入杀老师举办的课后期末考试滑溜滑溜补习班。至于为什么叫这个名字，额，你不能问我啊。

## 题目描述

在补习班上，因为多个学生会同时有需求，所以杀老师会制造分身用音速移动来回回答问题。

补习班上有 $n$ 个同学，他们每一个人都有一个问题。杀老师为了有序回答学生的问题，把所有学生排成了一列。第 $i$ 个学生的问题有一个困难值 $a_i$，杀老师回答第 $i$ 个学生的问题需要花费 $a_i$ 的精力。杀老师到了哪里，它就要解决那个学生的问题。杀老师最开始会解决序列中第一个同学的问题，他最后会去解决最后一个同学的问题。

杀老师每次解决完一个同学的问题到下一个同学的座位上就要花费 $k$ 点精力值。特殊的，如果杀老师想让自己轻松一点，可以不移动到下一个，可以直接到下两个，下三个，就不用解决跳过的同学的问题了。对应的，它会被学生调侃。受到打击的杀老师自然会花费格外的精力，花费的精力为 $k+(q-p-1) \times d$（当前位置为 $p$，跳到的位置为 $q$）。

当然的，杀老师也是有速度的啊，并且它想解决学生的一些问题，所以说杀老师最多只会跳过 $x-1$ 个学生，去解决下 $x$ 个学生的问题。

## 说明/提示

#### 样例解释 #1

杀老师每次不能跳过学生，因此他必须依次移动并解决所有问题，故答案为解决问题所需的精力 $1+2+3+4+5=15$ 与移动所需的精力 $4 \times 3=12$，所以花费精力之和为 $27$。

------------
#### 数据范围

**本题采用捆绑测试**。

- Subtask 1（20 points），学生们学习认真听话，留下来的同学也会更少：$tp=0$，$n \leq 10^3$。     
- Subtask 2（30 points），杀老师的速度快极了，并且学生们没时间吐槽它：$tp=0$，$n \leq 10^6$。     
- Subtask 3（50 points），$tp=1$，其余无特殊限制。

对于 $100\%$ 的数据，$1 \leq n \leq 10^7$，$0 \leq k,d,a_i \leq 10^9$，$1 \leq x \leq n-1$。

------------
#### 提示

对于 $tp=1$ 的数据，$rnd$ 函数只用于减小输入量，标准算法不依赖该数据生成方式。

## 样例 #1

### 输入

```
5 3 4 1 0
1 2 3 4 5
```

### 输出

```
27```

## 样例 #2

### 输入

```
10 30630 56910 2 0
7484 99194 86969 17540 29184 68691 91892 81564 93999 74280 
```

### 输出

```
717318```

## 样例 #3

### 输入

```
10000000 899999999 923456655 213111 1
1314520```

### 输出

```
9231813656566921```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致，均采用动态规划（DP）结合单调队列优化的方法解题。先定义状态表示解决完第 $i$ 个学生问题的最小精力消耗，得出 $O(n^2)$ 的朴素 DP 转移方程，该方法能解决部分分问题。为应对大数据量，对转移方程变形，提取与 $j$ 相关部分，用单调队列维护其最小值，将时间复杂度优化至 $O(n)$。

### 所选题解
- **作者：FCBM71（5星）**
    - **关键亮点**：思路清晰，详细阐述从 $20$ 分做法到 $100$ 分做法的过渡，对单调队列优化原理讲解透彻，代码有注释且考虑特殊情况。
    - **核心代码**：
```cpp
deque<pair<LL,int> >q; 
if(x==1){ 
    for(int i=1;i<=n;++i)f[n]+=a[i];
    cout<<f[n]+k*(LL)(n-1);
    return 0;
}
f[1]=a[1];
q.push_back(make_pair(f[1],1)); 
for(int i=2;i<=n;++i){
    while(!q.empty()){
        if(q.front().second<i-x)q.pop_front();
        else break; 
    }
    LL fx=q.front().first;int lx=q.front().second;
    f[i]=fx+k+d*(LL)(i-lx-1)+a[i]; 
    while(!q.empty()){
        LL fx=q.back().first;int lx=q.back().second;
        if(fx+d*(LL)(i-lx)>=f[i])q.pop_back();
        else break; 
    }
    q.push_back(make_pair(f[i],i)); 
}
cout<<f[n];
```
核心思想：先处理杀老师不能跳过学生的特殊情况，然后初始化状态和单调队列。遍历每个学生，先弹出队列中过期元素，根据队首元素更新当前状态，再按规则弹出队列中不符合要求的元素，最后将当前状态压入队列。

- **作者：zhangyuhan（4星）**
    - **关键亮点**：思路分析细致，对 DP 方程和单调队列优化步骤有详细解释，使用 STL 中的 `deque` 实现单调队列，代码简洁。
    - **核心代码**：
```cpp
_for (i, 2, n) {
    while (!q.empty() && i-q.front() > x) q.pop_front(); 
    f[i] = f[q.front()] + a[i] + k + (i-q.front()-1) * d;
    while (!q.empty() && f[i]-i*d <= f[q.back()]-q.back()*d) q.pop_back();
    q.push_back(i);
}
```
核心思想：遍历每个学生，先弹出队列中超出滑动窗口范围的元素，根据队首元素更新当前状态，再弹出队列中比当前状态大的元素以维护队列单调性，最后将当前元素入队。

### 最优关键思路与技巧
- **动态规划建模**：定义状态表示解决完第 $i$ 个学生问题的最小精力消耗，根据题目规则构建转移方程。
- **单调队列优化**：对转移方程变形，提取与 $j$ 相关部分，用单调队列维护其最小值，避免重复计算，将时间复杂度从 $O(n^2)$ 优化到 $O(n)$。

### 拓展思路
同类型题多为动态规划结合单调队列优化，如涉及区间最值、状态转移受区间限制的问题。类似算法套路是先建立朴素 DP 模型，分析转移方程，找出可优化部分，用单调队列维护关键信息。

### 推荐题目
- P1886 滑动窗口 /【模板】单调队列
- P1725 琪露诺
- P2627 [USACO11OPEN]Mowing the Lawn G

### 个人心得
部分题解提到“不开 LL 见祖宗”，强调处理大数据时要使用合适的数据类型，避免数据溢出问题。 

---
处理用时：28.37秒
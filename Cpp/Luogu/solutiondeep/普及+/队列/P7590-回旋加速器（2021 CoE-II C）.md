# 题目信息

# 回旋加速器（2021 CoE-II C）

## 题目描述

回旋加速器（$\text{Cyclotron}$）是利用磁场和电场使带电粒子作回旋运动并经高频电场反复加速的装置，是高能物理中的重要仪器。

我们来研究回旋加速器的一个简化模型。将回旋加速器视为一个环形的轨道，轨道上设置了 $n$ 个加速腔，依次编号为 $1$ 至 $n$。将一束质子从某个加速腔导入，在导入时，质子束的动能为零。第 $i$ 个加速腔能够为质子束提供 $e_i$ 的动能 ，质子束从第 $i$ 个加速腔运行到第 $i + 1$ 个加速腔会损失 $d_i$ 的动能（由于是环形轨道，编号为 $n$ 的加速腔后面是编号为 $1$ 的加速腔）。

给定每个加速腔能够提供的动能值以及质子束在各个加速腔之间运行所损失的动能值，试确定质子束能否绕环形轨道运行一周。如果能够成功，应该选择从哪个加速腔导入质子束。质子束在两个加速腔之间运行时，动能不能为零，但质子束刚到达加速腔时，动能可以为零，因为可以立即获得加速腔所提供的动能。

## 说明/提示

**样例说明**

输入 #1

该组输入共有 $3$ 个加速腔，依次能够提供的动能为 $1$、$2$、$3$。从第 $1$ 个加速腔运行到第 $2$ 个加速腔损失 $2$ 动能，从第 $2$ 个加速腔运行到第 $3$ 个加速腔损失 $3$ 动能，从第 $3$ 个加速腔运行到第 $1$ 个加速腔损失 $4$ 动能。不管从哪个加速腔导入质子束，都会使得质子束在两个加速腔运行过程中动能变为零，无法环绕轨道一周。

输入 #2

该组输入共有 $10$ 个加速腔，如果从第 $1$ 个加速腔导入质子束，将获得动能 $1$，但是在从第 $1$ 个加速腔运行到第 $2$ 个加速腔的过程中会损失 $3$ 动能，因此会使得质子束无法环绕轨道一周。而从第 $2$ 个到第 $10$ 个加速腔中的任意一个导入质子束，均能保证质子束在加速腔之间运行时动能不为零，因此都可作为导入质子束的加速腔，但编号为 $2$ 的加速腔具有最小的编号。需要注意，从第 $2$ 个加速腔导入质子束，当运行到第 $3$ 个加速腔时，动能恰为零，根据题意，这种情形是允许的。

------------


**数据范围**

- Subtask $1$：$2 \le n \le 10$，$10$ 分。
- Subtask $2$：$2 \le n \le 10^3$，$30$ 分。
- Subtask $3$：$2 \le n \le 10^5$，$30$ 分。
- Subtask $4$：$2 \le n \le 10^6$，$30$ 分。

对于 $100\%$ 的数据，$1 \le T \le 20$，$0 \lt e_i \le 100$，$0 \lt d_i \le 100$。



------------

**约定**

质子束的运行方向规定为：从第 $1$ 个加速腔到第 $2$ 个加速腔，从第 $2$ 个加速腔到第 $3$ 个加速腔$\cdots$从第 $n$ 个加速腔到第 $1$ 个加速腔。

## 样例 #1

### 输入

```
1

3
1 2 3
2 3 4```

### 输出

```
Failed!```

## 样例 #2

### 输入

```
1

10
1 2 3 4 5 6 7 8 9 10
3 2 1 2 3 4 5 6 7 8```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解围绕回旋加速器问题，给出了多种解题思路。主要可分为两类：一类是利用前缀和与连续子序列和的性质，通过简单遍历找到起始加速腔，时间复杂度为 $O(n)$；另一类是采用单调队列的方法，破环成链后用单调队列维护区间最小值，时间复杂度同样为 $O(n)$，但常数相对较大。

### 所选题解
- **作者：metaphysis (5星)**
  - **关键亮点**：思路清晰，将问题与最大连续子数组和问题联系起来，通过定义 $diff$ 数组简化问题，代码简洁易懂，时间复杂度低。
  - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e6 + 10;
int n, ei[MAXN], di[MAXN], diff[MAXN];
int main(int argc, char *argv[])
{
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);
    int cases;
    cin >> cases;
    for (int cs = 1; cs <= cases; cs++)
    {
        cin >> n;
        for (int i = 0; i < n; i++) cin >> ei[i];
        for (int i = 0; i < n; i++) cin >> di[i];
        for (int i = 0; i < n; i++) diff[i] = ei[i] - di[i];
        int energy = 0, sum = 0, idx = 0;
        for (int i = 0; i < n; i++)
        {
            energy += diff[i];
            sum += diff[i];
            if (sum < 0)
            {
                idx = i + 1;
                sum = 0;
            }
        }
        if (energy < 0) cout << "Failed!\n";
        else cout << (idx + 1) << '\n';
    }
    return 0;
}
```
  - **核心实现思想**：先计算每个加速腔的动能变化 $diff[i]$，再对其求和判断是否能绕一圈。在遍历过程中，若当前连续子序列和小于 0，则更新起始位置。

- **作者：dying (4星)**
  - **关键亮点**：详细证明了答案是前缀和中最小位置的结论，代码可读性高，对内存使用较为珍视。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define int long long
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
void print(int a){
    if(a<0)putchar('-'),a=-a;
    if(a>=10)print(a/10);
    putchar(a%10+48);
}
int t=read();
int pl[1000010];
signed main(){
    while(t--){
        int n=read(),*min=pl;
        for(int i=1;i<=n;i++)pl[i]=read();
        for(int i=1;i<=n;i++){
            pl[i]+=pl[i-1]-read();
            if(pl[i]<*min)min=pl+i;
        }
        if(pl[n]>=0)print(min-pl+1),putchar('\n');
        else puts("Failed!");
    }
    return ~EOF;
}
```
  - **核心实现思想**：计算每个加速腔的动能变化并求前缀和，找到前缀和最小的位置，若总动能变化非负，则该位置即为答案。

### 最优关键思路或技巧
- **问题转化**：将每个加速腔的动能变化用 $diff[i] = add[i] - loss[i]$ 表示，将问题转化为判断连续子序列和是否非负。
- **前缀和优化**：通过前缀和可以快速计算区间和，减少重复计算。
- **单调队列优化**：在破环成链的情况下，用单调队列维护区间最小值，将时间复杂度从 $O(n^2)$ 优化到 $O(n)$。

### 可拓展之处
同类型题或类似算法套路：
- 环形数组相关问题，如环形最大子数组和、环形路径规划等。
- 利用前缀和与单调队列优化的问题，如滑动窗口最大值、区间最值问题等。

### 推荐题目
- P1886 滑动窗口 /【模板】单调队列
- P1714 切蛋糕
- P2216 [HAOI2007]理想的正方形

### 个人心得摘录与总结
- **作者：iakioi114514**：做这道题时被洛谷的时间限制卡死，提交十多遍才过，最后加上快读和 `register` 优化才通过。总结是对于数据量较大的题目，要注意优化输入输出和使用高效的数据结构与算法。
- **作者：OIer_Automation**：写完代码只得了 70 分，剩下的 TLE，最后加上快读才通过。说明在竞赛中，输入输出优化是很重要的技巧。 

---
处理用时：36.10秒
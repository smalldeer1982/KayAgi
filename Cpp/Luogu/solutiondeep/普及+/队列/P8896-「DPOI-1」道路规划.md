# 题目信息

# 「DPOI-1」道路规划

## 题目背景

不可以，总司令。

## 题目描述

战场上有 $n$ 个据点，从 $1\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。

一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。

## 说明/提示

#### 样例 #1 解释
下面是第 $1$ 组数据中一种可行的方案：

![](https://cdn.luogu.com.cn/upload/image_hosting/2uvwlydw.png)

#### 样例 #2 解释
该样例满足测试点 $3 \sim 6$ 的限制。
#### 数据范围
**本题测试点分数不等分。**

|  测试点编号  | $n \le$ | 特殊条件 |每个测试点分数|
| :----------: | :-----------: | :------: | :----: |
|     $1\sim 2$      |     $10$     |   无   |$5$|
|     $3\sim 6$      |     $1000$     |    无     |$5$|
|     $7\sim 8$      |     $10^5$     |    所有 $l_i = i-1$ 或所有 $l_i \geq \min (i, n - 1)$    |$5$|
| $9 \sim 10$  | $10^5$ | $l_i=0$ 或 $r_i=n-1$ |$5$|
| $11 \sim 15$ | $10^5$ | 无 |$10$|

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq l_i \leq r_i < n$，$1 \leq T \leq 10$。

## 样例 #1

### 输入

```
2
5
0 1 4 0 0
3 4 4 1 3
3
1 2 2
2 2 2```

### 输出

```
YES
NO```

## 样例 #2

### 输入

```
见下发文件 road2.in```

### 输出

```
见下发文件 road2.out```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致，均是将原问题转化为：给定 $n$ 个区间 $[l_i, r_i]$，判断是否存在一个 $0$ 到 $n - 1$ 的排列，使得每个数都能放入对应的区间。主要使用贪心算法结合优先队列（小根堆）或集合（set）来解决。

### 所选题解
- **作者：kevinchw（5星）**
    - **关键亮点**：思路清晰，对贪心策略的正确性进行了详细证明，代码注释丰富，可读性强。
    - **核心代码**：
```C++
priority_queue<int,vector<int>,greater<int> > q;
struct node
{
    int l,r;
}a[100005];
vector<int> v[100005];
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        q=priority_queue<int,vector<int>,greater<int> >();
        int n;
        cin>>n;
        for(int i=1;i<=n;i++)
        {
            v[i].clear();
            int x;
            scanf("%d",&x);
            a[i].r=n-x;
        }
        for(int i=1;i<=n;i++)
        {
            int x;
            scanf("%d",&x);
            a[i].l=n-x;
            v[a[i].l].pb(a[i].r);
        }
        int now=1,op=0;
        for(int i=1;i<=n;i++)
        {
            for(int j=0;j<(int)v[i].size();j++)q.push(v[i][j]);
            if(q.empty())
            {
                cout<<"NO\n";
                op=1;
                break;
            }
            int x=q.top();q.pop();
            if(x<i)
            {
                cout<<"NO\n";
                op=1;
                break;
            }
        }
        if(!op)cout<<"YES\n";
    }
    return 0;
}
```
    - **核心实现思想**：先将每个区间的左右端点存储，按左端点将右端点存入对应的向量。然后遍历 $1$ 到 $n$，将左端点等于当前数的区间的右端点加入小根堆，若堆为空或堆顶元素小于当前数，则无解，否则弹出堆顶元素继续处理。

- **作者：DengDuck（4星）**
    - **关键亮点**：对 DAG 竞赛图拓扑序唯一进行了详细证明，代码简洁明了。
    - **核心代码**：
```cpp
const LL N=1e5+5;
LL T,n;
struct Line{LL L,R;}A[N];
vector<LL>V[N];
void Work()
{
    scanf("%lld",&n);
    for(int i=0;i<=n;i++)V[i].clear();
    priority_queue<LL,vector<LL>,greater<LL> >Q;
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&A[i].L);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&A[i].R);
        V[A[i].L].pb(A[i].R);
    }
    for(int i=0;i<n;i++)
    {
        while(!Q.empty()&&Q.top()<i)Q.pop();
        for(LL j:V[i])Q.push(j);
        if(Q.empty())
        {
            puts("NO");
            return;
        }
        Q.pop();
    }	
    puts("YES");
}
```
    - **核心实现思想**：读取每个区间的左右端点，按左端点将右端点存入对应的向量。遍历 $0$ 到 $n - 1$，将左端点等于当前数的区间的右端点加入小根堆，同时移除堆中小于当前数的元素，若堆为空则无解，否则弹出堆顶元素继续处理。

- **作者：WDY_Hodur（4星）**
    - **关键亮点**：思路清晰，对问题的转化和贪心策略的解释较为详细。
    - **核心代码**：
```cpp
int T,n;
struct node{
    int l,r;
}x[N];
priority_queue<int,vector<int>,greater<int> >q;
vector<int>g[N]; 
signed main(){
    cin>>T;
    while(T--){
        cin>>n;
        for(int i=0;i<=n;i++)g[i].clear();
        for(int i=1;i<=n;i++)cin>>x[i].l;
        for(int i=1;i<=n;i++){
            cin>>x[i].r;
            g[x[i].l].push_back(x[i].r); 
        }
        while(!q.empty())q.pop();
        int f=0;
        for(int i=0;i<n;i++){
            for(int y:g[i])q.push(y);
            if(q.empty()){
                f=1;
                break;
            }
            int x=q.top();
            q.pop();
            if(x<i){
                f=1;
                break;
            }
        }
        if(f)cout<<"NO\n";
        else cout<<"YES\n";
    }
    return 0;
}
```
    - **核心实现思想**：读取每个区间的左右端点，按左端点将右端点存入对应的向量。遍历 $0$ 到 $n - 1$，将左端点等于当前数的区间的右端点加入小根堆，若堆为空或堆顶元素小于当前数，则无解，否则弹出堆顶元素继续处理。

### 最优关键思路或技巧
- **问题转化**：利用有向无环图的拓扑序特性，将图的边定向问题转化为区间匹配问题。
- **贪心算法**：优先选择右端点小的区间进行匹配，使用优先队列（小根堆）维护区间的右端点。

### 可拓展之处
同类型题可涉及区间覆盖、任务调度等问题，类似算法套路是将复杂问题转化为区间匹配或排列问题，再使用贪心算法结合合适的数据结构（如优先队列、集合）解决。

### 推荐题目
- [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)
- [P2082 区间覆盖](https://www.luogu.com.cn/problem/P2082)
- [P1230 智力大冲浪](https://www.luogu.com.cn/problem/P1230)

### 个人心得
- lngym：“不会拓扑排序的我选择找规律”，体现了在面对问题时，若对常规方法不熟悉，可以尝试从找规律的角度去解决问题。 

---
处理用时：37.08秒
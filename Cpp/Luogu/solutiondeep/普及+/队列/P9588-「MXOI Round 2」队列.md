# 题目信息

# 「MXOI Round 2」队列

## 题目描述

小 C 有一个队列，他要对这个队列进行 $q$ 次操作。操作共四种，参数分别如下：

$1\ x$：这是第一种操作，表示从队尾依次插入 $1,2,3,\cdots,x$；

$2\ y$：这是第二种操作，表示弹出队头的前 $y$ 个元素；

$3\ z$：这是第三种操作，表示查询队列中的第 $z$ 个元素；

$4$：这是第四种操作，表示查询队列中所有元素的最大值。

你需要帮助他维护这个队列，并对于每个第三种操作和第四种操作，输出查询的答案。

## 说明/提示

#### 【样例解释 #1】

在进行第四次操作后，队列中的元素依次为 $3,4,5,1,2,3,1,2,3,4$。

在进行第七次操作后，队列中的元素依次为 $2,3,1,2,3,4$。

#### 【样例 #2】

见附加文件中的 `queue/queue2.in` 与 `queue/queue2.ans`。

该样例满足测试点 $1$ 的限制。

#### 【样例 #3】

见附加文件中的 `queue/queue3.in` 与 `queue/queue3.ans`。

该样例满足测试点 $4$ 的限制。

#### 【样例 #4】

见附加文件中的 `queue/queue4.in` 与 `queue/queue4.ans`。

该样例满足测试点 $11$ 的限制。

#### 【样例 #5】

见附加文件中的 `queue/queue5.in` 与 `queue/queue5.ans`。

该样例满足测试点 $15$ 的限制。

#### 【样例 #6】

见附加文件中的 `queue/queue6.in` 与 `queue/queue6.ans`。

该样例满足测试点 $20$ 的限制。

#### 【数据范围】

设 $\sum x$ 表示单个测试点内 $x$ 之和。

对于 $100\%$ 的数据，$1 \le q \le 2\times 10^5$，$1 \le x,y,z \le 10^9$，$0 \le \sum x \le 2\times10^{14}$，保证在进行第二种操作前队列内元素个数不小于 $y$，在进行第三种操作前队列内元素个数不小于 $z$，在进行第四种操作前队列内元素个数大于 $0$。

|测试点编号|$q \le$|$x \le$|$\sum x \le$|特殊性质|
|:---:|:---:|:---:|:---:|:---:|
|$1\sim3$|$500$|$500$|$2\times10^5$|C|
|$4\sim8$|$5000$|$5000$|$2\times10^7$|无|
|$9\sim10$|$2\times10^5$|$10^9$|$2\times10^{14}$|AB|
|$11\sim12$|$2\times10^5$|$10^9$|$2\times10^{14}$|B|
|$13\sim14$|$2\times10^5$|$10^9$|$2\times10^9$|AC|
|$15\sim16$|$2\times10^5$|$10^9$|$2\times10^9$|C|
|$17\sim18$|$2\times10^5$|$500$|$2\times10^7$|无|
|$19$|$2\times10^5$|$10^9$|$2\times10^9$|无|
|$20$|$2\times10^5$|$10^9$|$2\times10^{14}$|无|

特殊性质 A：没有第二种操作。

特殊性质 B：没有第三种操作。

特殊性质 C：没有第四种操作。

## 样例 #1

### 输入

```
0 9
1 5
1 3
2 2
1 4
3 6
3 8
2 4
4
3 3```

### 输出

```
3
2
4
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效处理队列的四种操作展开，核心在于解决数据量大时的存储和操作效率问题。大部分题解采用了前缀和与二分结合的方法处理查询操作，用 `multiset`、单调队列或线段树等数据结构维护最大值。

各题解的算法要点和难点解决方法如下：
1. **前缀和与二分**：通过记录每次插入元素个数的前缀和，利用二分查找快速定位元素位置，解决操作 3 查询第 $z$ 个元素的问题。
2. **数据结构维护最大值**：使用 `multiset`、单调队列或线段树等数据结构维护队列中元素的最大值，解决操作 4 查询最大值的问题。
3. **虚拟删除**：用一个变量记录删除元素的总数，避免实际删除操作，提高操作 2 的效率。

### 所选题解
- **作者：Crosser (赞：35)，4星**
  - **关键亮点**：思路清晰，代码简洁，使用 `multiset` 维护最大值，通过变量记录删除元素个数，结合二分查找解决查询问题，时间复杂度较低。
  - **个人心得**：无

### 重点代码
```cpp
int a[200005], s[200005], n;
multiset<int> ms;

void push(int w)
{ 
    a[++n] = w;
    s[n] = s[n - 1] + w;
    ms.insert(w);
}
signed main()
{
    int res = 0, id = 1;
    int q = read();
    q = read();
    while (q--)
    {
        int op = read();
        if (op == 1)
        {
            int x = read();
            push(x);
        }
        if (op == 2)
        {
            int y = read();
            res += y;
            while(s[id] <= res && id <= n) {
                ms.erase(ms.find(a[id]));
                id++;
            }
        }
        if (op == 3)
        {
            int z = read() + res;
            int pos = lower_bound(s + 1, s + n + 1, z) - s - 1;
            cout << z - s[pos] << endl;
        }
        if(op == 4)
        {
            cout << *ms.rbegin() << endl;
        }
    }
    return 0;
}
```
**核心实现思想**：
- `push` 函数：将插入的元素个数记录在数组 `a` 中，并更新前缀和数组 `s`，同时将元素插入 `multiset` 中。
- 操作 1：调用 `push` 函数插入元素。
- 操作 2：用变量 `res` 记录删除元素的总数，当 `s[id] <= res` 时，将对应的元素从 `multiset` 中删除。
- 操作 3：查询第 $z$ 个元素时，将 `z` 加上 `res`，然后通过二分查找在前缀和数组 `s` 中定位元素位置。
- 操作 4：直接输出 `multiset` 中的最大值。

### 最优关键思路或技巧
- **虚拟删除**：用一个变量记录删除元素的总数，避免实际删除操作，减少时间复杂度。
- **前缀和与二分**：通过记录前缀和，利用二分查找快速定位元素位置，提高查询效率。
- **数据结构维护最大值**：使用 `multiset`、单调队列或线段树等数据结构维护最大值，方便查询。

### 可拓展之处
同类型题或类似算法套路：
- 涉及区间操作的问题，如区间查询、区间修改等，可以考虑使用线段树、树状数组等数据结构。
- 维护动态集合的最大值、最小值等问题，可以使用优先队列、`multiset` 等数据结构。
- 处理大量数据时，采用虚拟删除、前缀和、二分等技巧可以提高效率。

### 推荐题目
1. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)：考察优先队列维护中位数的问题。
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：考察线段树的基本操作，如区间修改、区间查询等。
3. [P2068 统计和](https://www.luogu.com.cn/problem/P2068)：考察前缀和与二分的应用。

### 个人心得摘录与总结
- **作者：Milthm**：赛时因没有想到用二分优化操作 3 而痛失 AK，提醒我们在遇到查询问题时要考虑数据的单调性，尝试用二分优化。
- **作者：紊莫**：操作 3 坚持暴力做法会导致 TLE，应采用二分并结合懒标记处理删除操作，避免更新所有元素，提高效率。

---
处理用时：29.93秒
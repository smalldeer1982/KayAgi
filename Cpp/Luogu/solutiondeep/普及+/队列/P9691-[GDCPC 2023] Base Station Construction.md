# 题目信息

# [GDCPC 2023] Base Station Construction

## 题目描述

中国移动通信集团广东有限公司深圳分公司（以下简称``深圳移动``）于 $1999$ 年正式注册。四年后，广东省大学生程序设计竞赛第一次举办。深圳移动与广东省大学生程序设计竞赛一起见证了广东省计算机行业的兴旺与发展。

在建设通信线路的过程中，信号基站的选址是一个非常关键的问题。某城市从西到东的距离为 $n$ 千米，工程师们已经考察了在从西往东 $1, 2, \cdots, n$ 千米的位置建设基站的成本，分别是 $a_1, a_2, \cdots, a_n$。

为了保证居民的通信质量，基站的选址还需要满足 $m$ 条需求。第 $i$ 条需求可以用一对整数 $l_i$ 和 $r_i$ 表示（$1 \le l_i \le r_i \le n$），代表从西往东 $l_i$ 千米到 $r_i$ 千米的位置之间（含两端）至少需要建设 $1$ 座基站。

作为总工程师，您需要决定基站的数量与位置，并计算满足所有需求的最小总成本。

## 样例 #1

### 输入

```
2
5
3 2 4 1 100
3
1 3
2 4
5 5
5
7 3 4 2 2
3
1 4
2 3
4 5```

### 输出

```
102
5```

# AI分析结果

### 综合分析与结论
这些题解均采用动态规划（DP）来解决基站建设的最小成本问题。核心思路是定义状态 $f_i$ 表示考虑前 $i$ 个数且第 $i$ 个数必选的最小花费，转移时需满足所有区间至少有一个数被选择的条件。为优化转移过程，部分题解使用了单调队列、线段树等数据结构。

### 所选题解
- **作者：sunzz3183（4星）**
    - **关键亮点**：思路清晰，对状态转移方程和 $pre$ 数组的计算解释详细，代码简洁，使用单调队列优化 DP，时间复杂度低。
- **作者：cjh20090318（4星）**
    - **关键亮点**：对题意和分析过程阐述全面，详细说明了转移条件和单调队列优化的过程，代码规范，有注释。
- **作者：xtzqhy（4星）**
    - **关键亮点**：思路简洁明了，直接指出问题本质，通过预处理 $pre$ 数组和单调队列优化，代码实现高效。

### 重点代码及核心实现思想
#### sunzz3183 的代码
```cpp
void Main(){
    n=read();
    for(int i=1;i<=n;i++)a[i]=read();
    a[++n]=0;
    for(int i=1;i<=n;i++)pre[i]=0;
    m=read();
    for(int i=1;i<=m;i++){
        int l=read(),r=read();
        pre[r+1]=max(pre[r+1],l);
    }
    pre[1]=0;
    for(int i=2;i<=n;i++)pre[i]=max(pre[i],pre[i-1]);
    l=1,r=0;q[++r]=0;
    for(int i=1;i<=n;i++){
        while(l<=r&&q[l]<pre[i])l++;
        f[i]=f[q[l]]+a[i];
        while(l<=r&&f[q[r]]>=f[i])r--;
        q[++r]=i;
    }
    printf("%lld\n",f[n]);
    return;
}
```
**核心实现思想**：先预处理 $pre$ 数组，$pre_i$ 表示能转移到 $i$ 的最小合法的 $j$。然后使用单调队列维护 $f_j$ 的最小值，在转移时保证 $j$ 满足 $pre_i\leq j < i$。

#### cjh20090318 的代码
```cpp
void solve(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    scanf("%d",&m);
    for(int i=1;i<=m;i++) scanf("%d%d",&e[i].l,&e[i].r);
    sort(e+1,e+m+1);
    int l=0;
    h=1,t=0,q[++t]=0;
    for(int i=1,j=1;i<=n;i++){
        f[i]=f[q[h]]+a[i];
        while(h<=t&&f[q[t]]>f[i]) --t;
        q[++t]=i;
        for(;j<=m&&e[j].r<=i;j++) l=max(l,e[j].l);
        while(h<=t&&q[h]<l) ++h;
    }
    printf("%lld\n",f[q[h]]);
}
```
**核心实现思想**：将所有区间按右端点从小到大排序，使用双指针维护右端点小于 $i$ 的区间左端点最大值 $l$。通过单调队列维护 $f_j$ 的最小值，转移时保证 $j$ 不小于 $l$。

#### xtzqhy 的代码
```cpp
inline void solve(){
    cin>>n;
    for(re int i=1;i<=n;++i) cin>>a[i];a[++n]=0;
    for(re int i=1;i<=n;++i) pre[i]=0,f[i]=0;
    cin>>m;
    for(re int i=1,l,r;i<=m;++i){
        cin>>l>>r;
        pre[r+1]=max(pre[r+1],l);
    }
    for(re int i=1;i<=n;++i) pre[i]=max(pre[i],pre[i-1]);
    int l=1,r=0;
    q[++r]=0;
    for(re int i=1;i<=n;++i){
        while(l<=r&&q[l]<pre[i]) ++l;
        f[i]=f[q[l]]+a[i];
        while(l<=r&&f[q[r]]>=f[i]) --r;
        q[++r]=i;
    }
    cout<<f[n]<<'\n';
}
```
**核心实现思想**：预处理 $pre$ 数组，使用单调队列维护 $f_j$ 的最小值，转移时保证 $j$ 满足 $pre_i\leq j < i$，最后输出 $f_n$ 作为答案。

### 最优关键思路或技巧
- **状态定义**：定义 $f_i$ 表示考虑前 $i$ 个数且第 $i$ 个数必选的最小花费，将问题转化为动态规划问题。
- **$pre$ 数组**：通过预处理 $pre$ 数组，记录能转移到 $i$ 的最小合法的 $j$，简化转移条件。
- **单调队列优化**：使用单调队列维护 $f_j$ 的最小值，将转移的时间复杂度从 $O(n^2)$ 优化到 $O(n)$。

### 可拓展之处
同类型题或类似算法套路：
- **区间覆盖问题**：给定多个区间，要求选择最少的区间覆盖整个区间，可使用贪心或动态规划解决。
- **带权区间选择问题**：在区间选择问题的基础上，每个区间有一个权值，要求选择的区间满足一定条件且权值和最小，可使用动态规划和单调队列优化。

### 推荐洛谷题目
- [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)：考察单调队列的基本应用。
- [P2034 选择数字](https://www.luogu.com.cn/problem/P2034)：动态规划和单调队列优化的结合。
- [P1714 切蛋糕](https://www.luogu.com.cn/problem/P1714)：涉及区间和和单调队列的应用。

### 个人心得摘录与总结
- **xtzqhy**：“CSP 因为这个爆了，所以来写题解。” 总结：该作者因本题在 CSP 中失利，通过写题解加深对题目的理解和掌握。

---
处理用时：39.53秒
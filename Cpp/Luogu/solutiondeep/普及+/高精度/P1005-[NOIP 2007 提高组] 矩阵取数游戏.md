# 题目信息

# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# AI分析结果

### 综合分析与结论
这些题解都基于区间动态规划来解决问题，思路核心为：由于矩阵每行取数互不影响，可对每行分别处理。通过定义状态表示取完某区间能获得的最大得分，根据每次只能取行首或行尾元素的规则推出状态转移方程。

各题解的算法要点和难点解决方式相似，主要差异在于状态转移方程的具体形式、初始化方式以及对高精度或 `__int128` 的使用。部分题解在代码实现上更注重细节，如高精度运算的封装、输入输出的处理等，使得代码更具可读性和通用性。

### 所选的题解
- **作者：Jack_Homes_Huang（5星）**
    - **关键亮点**：思路清晰，详细阐述了最优子结构和区间DP的应用，对状态、转移和终值的分析全面，代码中使用高精度运算并对其进行了封装，提高了代码的可读性和复用性。
    - **个人心得**：强调了高精度运算的必要性和繁琐性。
    - **重点代码 - 核心实现思想**：通过重载运算符实现高精度加法、乘法和比较大小操作，在 `BaseTwo` 函数中预处理出2的幂，在 `main` 函数中进行区间DP计算每行最大得分并累加。
```cpp
HP operator + (const HP &a, const HP &b) {
    HP c; c.len = max(a.len, b.len); int x = 0;
    for (int i = 1; i <= c.len; i++) {
        c.p[i] = a.p[i] + b.p[i] + x;
        x = c.p[i] / Mod;
        c.p[i] %= Mod;
    }
    if (x > 0)
        c.p[++c.len] = x;
    return c;
} 

HP operator * (const HP &a, const int &b) {
    HP c; c.len = a.len; int x = 0;
    for (int i = 1; i <= c.len; i++) {
        c.p[i] = a.p[i] * b + x;
        x = c.p[i] / Mod;
        c.p[i] %= Mod;
    }
    while (x > 0)
        c.p[++c.len] = x % Mod, x /= Mod;
    return c;
} 

HP max(const HP &a, const HP &b) {
    if (a.len > b.len)
        return a;
    else if (a.len < b.len)
        return b;
    for (int i = a.len; i > 0; i--)
        if (a.p[i] > b.p[i])
            return a;
        else if (a.p[i] < b.p[i])
            return b;
    return a;
} 

void BaseTwo() {
    base[0].p[1] = 1, base[0].len = 1;
    for (int i = 1; i <= m + 2; i++){ 
        base[i] = base[i - 1] * 2;
    }
} 

int main(void) {
    scanf("%d%d", &n, &m);
    BaseTwo();
    while (n--) {
        memset(f, 0, sizeof f);
        for (int i = 1; i <= m; i++)
            scanf("%d", &ar[i]);
        for (int i = 1; i <= m; i++)
            for (int j = m; j >= i; j--) { 
                f[i][j] = max(f[i][j], f[i - 1][j] + base[m - j + i - 1] * ar[i - 1]); 
                f[i][j] = max(f[i][j], f[i][j + 1] + base[m - j + i - 1] * ar[j + 1]);
            } 
        HP Max;
        for (int i = 1; i <= m; i++)
            Max = max(Max, f[i][i] + base[m] * ar[i]);
        ans = ans + Max; 
    }
    ans.print(); 
    return 0;
}
```
- **作者：zhylj（4星）**
    - **关键亮点**：转移方程独特且简洁，代码实现简洁明了，使用 `__int128` 解决数据范围问题，同时给出了 `__int128` 的输入输出函数。
    - **重点代码 - 核心实现思想**：在 `solve` 函数中通过双重循环进行区间DP，根据转移方程计算取区间 `[i, i+len]` 的最大值，在 `main` 函数中对每行调用 `solve` 函数并累加结果。
```cpp
__int128 solve(__int128 a[])
{
    memset(f,0,sizeof(f));
    for(int len=0;len<=m;++len)
        for(int i=1;i+len<=m;++i)
            f[i][i+len]=max(2*f[i+1][i+len]+2*a[i],2*f[i][i+len-1]+2*a[i+len]);
    return f[1][m];
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            input(game[i][j]);
    for(int i=1;i<=n;i++)
        ans+=solve(game[i]);
    output(ans);
    return 0;
}
```
- **作者：Tomwsc（4星）**
    - **关键亮点**：对题意和思路的阐述清晰，详细说明了状态转移方程的推导过程，通过预处理 `2^i` 优化转移复杂度，代码结构清晰，注释详细。
    - **重点代码 - 核心实现思想**：在 `ksm` 函数中用快速幂预处理 `2^i`，在 `main` 函数中通过双重循环进行区间DP计算每行最大得分并累加，最后通过自定义函数输出结果。
```cpp
inline int ksm(int base, int x) {
    int result = 1;
    while(x) {
        if(x & 1)
            result *= base;
        x >>= 1;
        base *= base;
    }
    return result;
}

signed main() {
    n = read();
    m = read();
    for(register int i = 1;i <= m;i ++)
        poww[i] = ksm(2, i);
    while(n --) {
        for(register int i = 1;i <= m;i ++)
            a[i] = read();
        memset(dp, 0, sizeof(dp));
        for(register int i = 1;i <= m;i ++)
            for(register int j = m;j >= i;j --)
                dp[i][j] = max(dp[i - 1][j] + a[i - 1] * poww[m - j + i - 1], dp[i][j + 1] + a[j + 1] * poww[m - j + i - 1]);
        int maxn = -inf;
        for(register int i = 1;i <= m;i ++)
            maxn = max(maxn, dp[i][i] + a[i] * poww[m]);
        ans += maxn;
    }
    write(ans);
    return 0;
}
```

### 最优关键思路或技巧
- **区间DP的应用**：将每行取数问题转化为区间DP，通过定义合适的状态和状态转移方程求解。
- **独立处理每行**：利用每行取数互不影响的特点，分别计算每行最大得分再累加，简化问题。
- **数据处理**：根据数据范围，使用高精度运算或 `__int128` 避免数据溢出。

### 可拓展之处
此类题目属于区间动态规划类型，常见套路为根据问题特点定义区间状态，结合操作规则推导状态转移方程。相似题目通常涉及在一个序列或区间上进行操作，通过合理选择操作顺序以达到最优结果。

### 洛谷相似题目推荐
- [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
- [P4170 [CQOI2007] 涂色](https://www.luogu.com.cn/problem/P4170)
- [P3146 [USACO16OPEN]248 G](https://www.luogu.com.cn/problem/P3146)

### 个人心得摘录与总结
- **Jack_Homes_Huang**：强调高精度运算的必要性和繁琐性，提醒注意数据范围问题。 

---
处理用时：56.66秒
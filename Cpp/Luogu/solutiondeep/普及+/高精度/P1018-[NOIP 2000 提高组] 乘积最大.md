# 题目信息

# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解采用动态规划（DP），少数使用深度优先搜索（DFS）。DP思路是通过定义状态表示前i个数使用j个乘号的最大乘积，利用状态转移方程求解；DFS思路是枚举乘号插入位置并计算乘积，通过剪枝优化。
    - 算法要点：需处理取数操作，即将连续数字转为一个数；要实现高精度运算，因为结果数值可能很大；状态转移方程的推导与实现是DP的关键，DFS则需合理剪枝。
    - 解决难点：高精度运算的实现较为复杂，包括高精度乘法、比较大小等操作；状态转移方程的准确推导与理解对于DP解法很重要，DFS的有效剪枝也需要思考。

    综合来看，使用DP且高精度实现清晰的题解质量较高，而DFS由于数据范围限制，剪枝后虽能通过但复杂度相对较高。

  - 作者：liar_white (赞：416)
    - 星级：5星
    - 关键亮点：思路清晰，详细阐述了DP状态定义与转移过程，使用结构体实现高精度运算，代码注释详尽，易于理解。
    - 个人心得：“写这道题都用了半上午”，强调了题目虽看似简单但实现细节较多。
    - 核心代码实现思想：用结构体node存储高精度数，culc函数取数，mul函数实现高精度乘法，Max函数比较大小。在主函数中，通过三层循环实现状态转移，最后比较得出最大值。
```cpp
struct node{//用结构体储存数组；当然，也可以直接用三维数组，不过感觉这样更容易理解
    int v;bool exi;//v:数位,exi:是否存在
    int c[50];//高精度数组
}cut[50][10],ans[50];
node culc(int l,int r){//取数操作，注意：要从右往左取，因为高精度数组是从低位往高位排的，而读入的数字串是从高位到低位
    node e;
    e.v=r-l+1;e.exi=true;
    for(int i=1;i<=e.v;i++){
        e.c[i]=a[r-i+1];
    }    
    return e;
}
node mul(node e1,node e2){//高精度乘法
    node emul;
    emul.exi=true;emul.v=e1.v+e2.v-1;
    for(int i=1;i<=emul.v;i++) emul.c[i]=0;
    for(int i=1;i<=e1.v;i++)
        for(int j=1;j<=e2.v;j++)
            emul.c[i+j-1]+=e1.c[i]*e2.c[j];
    int q=0;        
    for(int i=1;i<=emul.v;i++){
        emul.c[i]+=q;
        q=emul.c[i]/10;
        emul.c[i]%=10;
    }
    while(q>0){
        emul.c[++emul.v]=q%10;
        q/=10;
    }
    return emul;
}
node Max(node e1,node e2){//高精度比较，类似字符串（然而如果是字符串的话我就直接strcmp了）
    if(!e1.exi||e1.v<e2.v) return e2;
    if(!e2.exi||e2.v<e1.v) return e1;//先比较是否存在和位数
    for(int i=e1.v;i>=1;i--){//都存在，且位数相同，则逐位比较
        if(e1.c[i]>e2.c[i]) return e1;
        else if(e2.c[i]>e1.c[i]) return e2;
    }
    return e1;
}
int main(){
    scanf("%d%d",&n,&k);
    scanf("%s",s);
    for(int i=0;i<n;i++) a[i+1]=s[i]-'0';//将字符串变为数字数组
    for(int i=1;i<=n;i++){
        ans[i].exi=false;
        for(int j=1;j<=k;j++) cut[i][j].exi=false;
    }
    for(int i=1;i<n;i++){
        cut[i][1]=culc(1,i);//只放一个乘号的话不需要转移
        for(int j=2;j<=k;j++){
            for(int fr=j-1;fr<i;fr++){//因为第i个数后放置的乘号最多是第i个，所以从j-1枚举front（前置位）
                if(cut[fr][j-1].exi) cut[i][j]=Max(cut[i][j],mul(cut[fr][j-1],culc(fr+1,i)));
            }
        } //转移状态
        if(cut[i][k].exi){
            ans[i]=mul(cut[i][k],culc(i+1,n));
        }
    }
    node lastans;lastans.exi=false;
    for(int i=1;i<n;i++){
        node tmp=Max(ans[i],lastans);
        lastans=tmp;
    }
    for(int i=lastans.v;i>=1;i--) printf("%d",lastans.c[i]);//输出
    return 0;
}
```
  - 作者：XHCuteDog (赞：7)
    - 星级：4星
    - 关键亮点：同样采用DP思路，详细注释了高精度实现细节，对状态转移方程的实现过程描述清晰。
    - 核心代码实现思想：定义结构体hd表示高精度数，init函数初始化数字，mul函数实现高精度乘法，bigger函数比较大小。主函数通过三层循环实现状态转移并得到结果。
```cpp
struct hd{
    int len;
    int d[maxn];
}; 
hd f[maxn][50];
void init(hd &A,int l,int r)
{
    A.len=r-l+1;   
    for(int i=1,j=r-1;j>=l-1;i++,j--)
        A.d[i]=s[j]-'0'; 
}
void mul(hd &Z,hd X,hd Y)
{   
    for(int i=1;i<maxn;i++)
        Z.d[i]=0;
    for(int i=1;i<=X.len;i++)
        for(int j=1;j<=Y.len;j++)
            Z.d[i+j-1]+=X.d[i]*Y.d[j];
    for(int i=1;i<maxn;i++)
    {
        Z.d[i+1]+=Z.d[i]/10;
        Z.d[i]=Z.d[i]%10;
    }
    int i;
    for(i=maxn-1;i>1;i--)
        if(Z.d[i])break;
    Z.len=i;
}
bool bigger(hd X,hd Y)
{
    if(X.len!=Y.len)
        return X.len>Y.len;
    for(int i=X.len;i>=1;i--)
        if(X.d[i]!=Y.d[i])
            return X.d[i]>Y.d[i];
}
int main()
{
    cin>>n>>k;
    cin>>s;
    for(int i=1;i<=n;i++)
        init(f[i][0],1,i);
    for(int j=1;j<=k;j++)
        for(int i=j+1;i<=n;i++)
        {
            f[i][j].len=0;
            hd X,Y;
            for(int k=j;k<i;k++)
            {
                init(Y,k+1,i);
                mul(X,f[k][j-1],Y);
                if(bigger(X,f[i][j]))
                    f[i][j]=X;
            }
        }
    pr(f[n][k]);
    return 0;	
}
```
  - 作者：FastIO_DP (赞：1)
    - 星级：4星
    - 关键亮点：清晰阐述DP思路，状态转移方程推导详细，通过重载运算符实现高精度运算，代码结构清晰。
    - 核心代码实现思想：定义结构体BI表示高精度数，重载乘法和比较运算符。num函数获取子串对应的高精度数，主函数通过三层循环完成状态转移并输出结果。
```cpp
struct BI {
    int d[100];
    int len;

    BI() {
        memset(d, 0, sizeof(d));
        len = 0;
    }
    BI(const string& s) {
        memset(d, 0, sizeof(d));
        len = s.size();
        for (int i = 0; i < len; ++i) {
            d[i] = s[len - 1 - i] - '0';
        }
    }

    string toStr() const {
        string s;
        for (int i = len - 1; i >= 0; --i) {
            s += to_string(d[i]);
        }
        return s;
    }

    BI operator*(const BI& o) const {
        BI res;
        for (int i = 0; i < len; ++i) {
            int c = 0;
            for (int j = 0; j < o.len; ++j) {
                int p = d[i] * o.d[j] + res.d[i + j] + c;
                res.d[i + j] = p % 10;
                c = p / 10;
            }
            if (c) {
                res.d[i + o.len] += c;
            }
        }
        res.len = len + o.len;
        while (res.len > 1 && res.d[res.len - 1] == 0) {
            res.len--;
        }
        return res;
    }

    bool operator<(const BI& o) const {
        if (len!= o.len) {
            return len < o.len;
        }
        for (int i = len - 1; i >= 0; --i) {
            if (d[i]!= o.d[i]) {
                return d[i] < o.d[i];
            }
        }
        return false;
    }
};

int N, K;
string s;
BI dp[50][10];

BI num(int l, int r) {
    string sub = s.substr(l, r - l + 1);
    return BI(sub);
}

int main() {
    cin >> N >> K;
    cin >> s;

    for (int i = 0; i < N; ++i) {
        dp[i][0] = num(0, i);
    }

    for (int j = 1; j <= K; ++j) {
        for (int i = j; i < N; ++i) {
            for (int k = j - 1; k < i; ++k) {
                BI t = dp[k][j - 1] * num(k + 1, i);
                if (dp[i][j] < t) {
                    dp[i][j] = t;
                }
            }
        }
    }

    cout << dp[N - 1][K].toStr() << endl;

    return 0;
}
```
• 最优关键思路或技巧：
    - 动态规划方面，准确的状态定义和状态转移方程是核心。状态定义为前i个数使用j个乘号的最大乘积，状态转移通过枚举最后一个乘号位置实现。
    - 高精度运算实现时，合理的数据结构（如结构体）和操作函数（乘法、比较等）设计很重要。

• 可拓展思路：
此类题目属于数字分割求最优值问题，类似的还有分割整数求最大和、最小和等。算法套路通常是通过动态规划定义状态，根据分割点推导状态转移方程，同时注意处理大数运算。

• 推荐题目：
    - P1220 [USACO1.1] 挤牛奶Milking Cows
    - P1006 [NOIP2008 提高组] 传纸条
    - P1020 [NOIP1999 提高组] 导弹拦截 

---
处理用时：55.15秒
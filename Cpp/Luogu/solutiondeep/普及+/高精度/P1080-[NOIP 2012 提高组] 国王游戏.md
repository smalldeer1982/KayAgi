# 题目信息

# [NOIP 2012 提高组] 国王游戏

## 题目描述

恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。


## 说明/提示

【输入输出样例说明】

按 $1$、$2$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $1$、$3$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $2$、$1$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按$ 2$、$3$、$1 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$；

按 $3$、$1$、$2 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；  

按$ 3$、$2$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$。

因此，奖赏最多的大臣最少获得 $2$ 个金币，答案输出 $2$。


 
【数据范围】

对于 $20\%$ 的数据，有 $1≤ n≤ 10,0 < a,b < 8$；

对于 $40\%$ 的数据，有$ 1≤ n≤20,0 < a,b < 8$；

对于 $60\%$ 的数据，有 $1≤ n≤100$；

对于 $60\%$ 的数据，保证答案不超过 $10^9$；

对于 $100\%$ 的数据，有 $1 ≤ n ≤1,000,0 < a,b < 10000$。



NOIP 2012 提高组 第一天 第二题


## 样例 #1

### 输入

```
3 
1 1 
2 3 
7 4 
4 6 ```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕《国王游戏》这一题目，核心思路是通过贪心算法确定大臣的排列顺序，以使得获得奖赏最多的大臣所获奖赏尽可能少。算法要点在于证明按大臣左、右手数字乘积 \(a_i\times b_i\) 从小到大排序为最优策略，难点在于高精度计算，因为数据范围较大，普通数据类型无法满足需求。

### 所选的题解
1. **作者：洛必达法则 (5星)**
    - **关键亮点**：对贪心算法进行了严谨的数学证明，先证明相邻两项按 \(a\times b\) 升序排列所得结果小于等于降序排列所得结果，再利用引理证明要使前 \(n\) 项奖励最大值最小，需依据 \(a_i\times b_i\) 排序。
    - **个人心得**：无
    - **重点代码**：无核心代码，主要为证明过程。
2. **作者：「QQ红包」 (4星)**
    - **关键亮点**：清晰阐述贪心部分思路，即通过比较相邻大臣对答案贡献确定排列顺序；高精度部分采用压位优化，乘法和除法分别实现高精度乘低精度与高精度除低精度。
    - **个人心得**：无
    - **重点代码**：核心实现为 `cmp` 函数确定排序规则，以及 `cheng` 和 `div` 函数分别实现高精度乘法与除法。
```cpp
bool cmp(node aa,node bb)
{
    if (aa.x*aa.y==bb.x*bb.y) return aa.y<bb.y;
    return (aa.x*aa.y)<(bb.x*bb.y);
}
void cheng(int d)
{
    for (int i=1;i<=m;i++)
        sum[i]*=a[d].x;
    for (int i=1;i<=m;i++)
    {
        sum[i+1]+=sum[i]/10000;
        sum[i]%=10000;
    }
    if (sum[m+1]!=0) m++;
}
void div(int d)
{
    memset(ans,0,sizeof(ans));
    ls=1;
    while (m>0&&sum[m]==0) m--;
    P=0;
    int flag=0;
    for (int i=m;i>=1;i--)
    {
        P=P*10000+sum[i];
        ans[++ls]=P/a[d].y;
        if (ans[ls]==0&&!flag) ls--; else flag=1;
        P%=a[d].y;
    }
}
```
3. **作者：frankchenfu (4星)**
    - **关键亮点**：先猜测结论可能与 \(a_i\times b_i\) 排序有关，再通过对相邻两人不同排列情况进行分析，证明按 \(a_i\times b_i\) 从小到大排序的正确性，同时介绍了高精度运算的技巧，如压4位处理。
    - **个人心得**：作者提到模拟赛打这题时花了30min手敲高精度，强调 `print()` 函数写法有技巧，认为楼下题解 `print()` 函数臃肿。
    - **重点代码**：核心代码为 `cmp` 函数确定排序规则，以及 `bign` 结构体中实现高精度乘法和除法。
```cpp
struct node{
    int a,b;
    bool operator<(const node &rhs)const{
        return a*b<rhs.a*rhs.b||(a*b==rhs.a*rhs.b&&a<rhs.a);
    }
}p[MAXN];
struct bign{
    const int BASE=1e4;
    int a[MAXN<<2],len;
    bign(int len=0){
        this->len=len;
    }
    bign operator=(int rhs){
        len=0;
        if(rhs==0){
            len=1;
            return *this;
        }
        while(rhs){
            a[++len]=rhs%BASE;
            rhs/=BASE;
        }
        return *this;
    }
    bign operator=(const bign rhs){
        memcpy(a,rhs.a,sizeof(rhs.a));
        len=rhs.len;
        return *this;
    }
    void operator*=(const int rhs){
        for(int i=1;i<=len;i++)
            a[i]*=rhs;
        for(int i=1;i<=len;i++){
            a[i+1]+=a[i]/BASE;
            a[i]%=BASE;
            if(i+1>len&&a[i+1])
                len++;
        }
        while(len&&a[len]==0)
            len--;
    }
    bign operator/(const int rhs){
        bign c;c=*this;
        while(c.len&&c.a[c.len]==0)
            c.len--;
        for(int i=c.len;i;i--){
            c.a[i-1]+=(c.a[i]%rhs)*BASE;
            c.a[i]/=rhs;
        }
        while(c.len&&c.a[c.len]==0)
            c.len--;
        return c;
    }
    void print(){
        while(len&&a[len]==0)
            len--;
        if(len==0){
            putchar('0');
            return;
        }
        printf("%d",a[len]);
        for(int i=len-1;i;i--)
            printf("%04d",a[i]);
    }
    bool operator>(const bign &rhs)const{
        if(len!=rhs.len)
            return len>rhs.len;
        for(int i=len;i;i--)
            if(a[i]!=rhs.a[i])
                return a[i]>rhs.a[i];
        return 0;
    }
}mul,ans;
```

### 最优关键思路或技巧
1. **思维方式**：通过邻项交换法，比较相邻大臣不同排列顺序下的奖赏情况，证明按 \(a_i\times b_i\) 从小到大排序的贪心策略正确性。
2. **代码实现技巧**：在高精度计算中，采用压位技巧，如将模数设为 \(10^4\) 或 \(10^5\)，减少高精度运算的复杂度，提高代码效率。

### 可拓展之处
此类题型属于贪心策略结合高精度计算的问题。相似算法套路为遇到需要确定最优排列顺序的问题时，可尝试使用邻项交换法证明贪心策略；在数据范围较大时，考虑高精度计算。同类型题如排队打水问题，通过贪心确定打水顺序使总等待时间最短，也可能涉及高精度计算。

### 推荐题目
1. **P1090 [NOIP2004 提高组] 合并果子**：通过贪心策略选择合并方式，减少总代价，类似本题确定最优顺序的思路。
2. **P1199 [NOIP2010 普及组] 三国游戏**：同样需要分析最优策略，确定游戏中的最佳选择顺序，与本题运用贪心确定顺序类似。
3. **P1248 加工生产调度**：利用贪心算法解决生产调度问题，确定最优生产顺序，和本题思路相近。 

---
处理用时：32.78秒
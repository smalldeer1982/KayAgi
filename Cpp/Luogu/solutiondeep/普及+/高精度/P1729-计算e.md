# 题目信息

# 计算e

## 题目背景

《爱与愁的故事第二弹·compute》最终章。

自然对数的底数 $e$ 是一个著名的无理数，其近似值为 $2.718281828\cdots$ 有计算 $e$ 的公式如下：

$$e=\sum_{n=0}^{\infty}\frac{1}{n!}$$

其中 $n!$ 表示 $n$ 的阶乘，即 $n!=1\times 2\times 3\times \cdots \times n$。


## 题目描述

月落乌啼竟然这么快就回复了圆周率小数点后10000位？！不可能，他肯定求了别人。爱与愁大神再次为难月落乌啼：“帮我算一算 $e$ 后 $n(n \le 10000)$ 位，速度！！！”月落乌啼想求别人，结果他发现由于刚才跟你通话已经用完了手机的所有电。关键时刻只能靠自己。如果现在你是他，你会怎么编这个程序？


## 说明/提示

$30\%$ 数据：$n \le 1000$  
$100\%$ 数据：$n \le 10000$

时限：全部1秒


## 样例 #1

### 输入

```
100```

### 输出

```
2.
7182818284 5904523536 0287471352 6624977572 4709369995
9574966967 6277240766 3035354759 4571382178 5251664274```

# AI分析结果

### 综合分析与结论
这些题解主要围绕计算自然对数底数 $e$ 展开，思路可分为打表法和基于公式 $\mathrm{e}=\sum_{n=0}^{\infty}\frac{1}{n!}$ 的计算法。计算法中又涉及高精度计算，难点在于如何在满足精度要求下优化时间复杂度。不同题解在优化方式、数据结构使用上各有差异。

### 所选的题解
1. **作者：TBB_Nozomi (5星)**
    - **关键亮点**：思路清晰，详细分析了计算 $e$ 所需项数 $N$ 与精度的关系，提出两种非打表高精度解法。做法一通过通分减少高精度除法次数，做法二实现高精度浮点数的 $\exp$ 函数并进行优化。
    - **个人心得**：用本题练手高精度与 $e$ 的结合题目。
    - **重点代码 - 做法一核心代码**：
```cpp
int main()	{
    int k;
    cin>>k;
    tbb::_LFloat_prec= (k/4)+2; //万进位高精
    LInt S= 1, P= 1, T= 1;
    int N;
    for(N=1; T.digit()<=tbb::_LFloat_prec*4; )	T*= (++N); //先估计分母阶乘的位数
    for(int i=N; i>0; i--)	{
        P*= i;	S+= P;
    }
    LFloat F=S;	F/=T; //做高精度浮点数除法
    string ans= F.print_str();
    const char* out= ans.c_str();
    putchar('2');	putchar('.');	putchar('\n');
    for(int T=1; T<=k; ++T)	{
        putchar(out[1+T]);
        if(T%50==0)	putchar('\n');
        else	if(T%10==0)	putchar(' ');
    }
    return 0;
}
```
    - **核心思想**：先估计分母阶乘位数确定 $N$，通过循环计算分子分母，最后进行高精度除法得到结果并格式化输出。
2. **作者：TobyFlenderson (4星)**
    - **关键亮点**：引用前人结论确定计算 $e$ 所需项数 $n$，将公式通分减少高精度除法次数，还提出两种优化思路，并给出优化后的代码及详细分析。
    - **重点代码 - 优化后核心代码**：
```cpp
int MIN_SPLIT = 128;
static void euler_split(int n, int m, LInt& p, LInt& q)
{
    if (m - n < MIN_SPLIT)
    {
        p = 1;
        q = 1;
        for (int i = m; i > n; i--)
        {
            q *= i;
            p += q;
        }
        q *= n;
        return;
    }
    LInt p1, p2, q1, q2;
    euler_split(n, (n + m) >> 1, p1, q1);
    euler_split((n + m + 2) >> 1, m, p2, q2);
    p = p1 * q2 + p2;
    q = q1 * q2;
}

int main()
{
    int k;
    cin >> k;
    LInt p, q;
    int n = get_n(k);
    euler_split(1, n, p, q);
    p += q;
    p <<= k / 4 + 2;
    p /= q;
    string ans = p.print_str();
    const char* out = ans.c_str();
    putchar('2');    putchar('.');    putchar('\n');
    for (int T = 1; T <= k; ++T) {
        putchar(out[T]);
        if (T % 50 == 0)    putchar('\n');
        else if (T % 10 == 0)    putchar(' ');
    }
    return 0;
}
```
    - **核心思想**：通过递归分块处理表达式，在阈值内采用通分计算，利用低于 $O(n^2)$ 的大整数乘法向上合并结果，最后格式化输出。
3. **作者：iwprc (4星)**
    - **关键亮点**：代码简洁，直接实现高精度除法和加法计算 $e$，采用一位存5个数字的方式处理高精度数。
    - **重点代码 - 核心代码**：
```cpp
#include<cstdio>
const int N=2005;
const int M=100000;
int a[N],s[N],t[N],i,k,p,n;
//a数组存答案，1位存5个数字
//s数组存(1/n!),也是1位存5个数字
//t数组用来过渡
int f=true;
int main(){
    i=2;
    a[1]=s[1]=50000;
    //初始化：a数组和s数组都赋值为0.5，下面从1/3!算起
    while(f){
        i++;
        //当前算1/i!
        p=0;
        for(k=0;k<N;k++){
            p=p*M+s[k];
            t[k]=p/i;
            p%=i;
        }
        //高除单，i!=(1/(i-1)!)/i
        f=false;
        for(k=0;k<N;k++){
            a[k]+=s[k]=t[k];
            if(s[k])
                f=true;
            //当s数组为空时，退出循环
            if(a[k]>=M)
                a[k-1]+=a[k]/M,a[k]%=M;
        }
        //高精度加法，把s加进a
    }
    scanf("%d",&n);
    printf("2.\n");
    for(i=1;i*5<=n;i++){
        printf("%05d",a[i]);
        if(!(i%10))
            printf("\n");
        else
            if(!(i%2))
                printf(" ");
    }
    //输出
    if(i*5-n==4)printf("%d",a[i]/10000);
    if(i*5-n==3)printf("%02d",a[i]/1000);
    if(i*5-n==2)printf("%03d",a[i]/100);
    if(i*5-n==1)printf("%04d",a[i]/10);    
    //因为是5位5位输出，最后几位单独输出    
    return 0;
}
```
    - **核心思想**：通过循环进行高精度除法计算 $1/i!$，并累加到结果数组 $a$ 中，最后根据精度要求格式化输出。

### 最优关键思路或技巧
1. **确定计算项数**：利用拉格朗日余项估计或前人结论，确定计算 $e$ 达到指定精度所需的项数 $n$，避免不必要计算。
2. **通分优化**：将公式 $\mathrm{e}=\sum_{n=0}^{N}\frac{1}{n!}$ 通分，减少高精度除法次数，降低时间复杂度。
3. **分块处理**：对表达式分块递归计算，在合适阈值下采用通分方式，并结合高效大整数乘法，进一步优化时间复杂度。

### 可拓展之处
此类题目拓展方向主要是高精度计算与数学公式结合，类似套路如利用公式计算无理数、三角函数值等。例如计算 $\pi$ 时也会涉及高精度计算与特定公式结合，通过优化计算过程提高效率。

### 相似知识点题目推荐
1. **P5432 高精度除法**：专注于高精度除法的实现与优化，与本题中高精度计算部分知识点相关。
2. **P1517 高精度小数的正整数幂**：涉及高精度小数运算，与本题高精度浮点数计算有相似之处。
3. **P1727 计算π**：同样是计算无理数，与本题计算 $e$ 在思路和高精度处理上有可类比之处。 

---
处理用时：42.73秒
# 题目信息

# [AHOI2012] 树屋阶梯

## 题目描述

 ![](https://cdn.luogu.com.cn/upload/pic/1630.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/1631.png) 



## 说明/提示

- 对于 $40\%$ 的数据，满足 $1\le N\le 20$。
- 对于 $80\%$ 的数据，满足 $1\le N\le 300$。
- 对于 $100\%$ 的数据，满足 $1\le N\le 500$。


## 样例 #1

### 输入

```
3```

### 输出

```
5```

# AI分析结果

• 综合分析与结论：这些题解都指出本题是卡特兰数问题，主要思路是先证明题目所求符合卡特兰数形式，再利用卡特兰数公式计算。算法要点在于理解卡特兰数递推关系，难点是处理高精度计算。不同题解在证明方式、公式运用及高精度实现上有差异。
  - 作者syksykCCC：
    - 星级：4星
    - 关键亮点：通过对阶梯右侧拐角分析，直观展示每个矩形覆盖一个拐角，进而枚举覆盖最左下角点的矩形所覆盖的拐角，清晰推导出卡特兰数递推公式$C_N = \sum_{i = 0}^{N - 1} C_i \times C_{N - i - 1}$ 。
  - 作者Sooke：
    - 星级：4星
    - 关键亮点：先介绍玄学猜测方法，再详细说明正常推理过程，通过对树屋阶梯构成方式分析得出递推式。使用卡特兰数通项公式$h(n)=\frac{(2n)!}{(n + 1)!\cdot n!}$ ，并给出完整高精度实现代码，包括高精乘单精、高精除单精及输出高精函数。
  - 作者消失的海岸线：
    - 星级：4星
    - 关键亮点：利用卡特兰数通项公式$h_n = \frac {1}{n+1} \binom{2n}{n}$ ，考虑到答案为整数，将乘除部分按质因数存储优化掉高精除低精过程，同时应用高精度压位技巧，提高运行效率。

**作者syksykCCC重点代码**：无代码

**作者Sooke重点代码**：
```cpp
// 高精度结构体
struct HighPrec{
    int L, A[10001];
};
// 初始化高精度为1
inline HighPrec Init(){
    HighPrec H;
    H.L = 1, H.A[1] = 1;
    return H;
}
// 高精度乘单精度
HighPrec Mul(HighPrec A, int k){
    HighPrec H;
    for(int i = 1 ; i <= A.L ; i++)
        H.A[i] = A.A[i] * k; 
    for(int i = 2 ; i <= A.L ; i++)
        H.A[i] += H.A[i - 1] / 10,
        H.A[i - 1] %= 10; 
    H.L = A.L;
    while(H.A[H.L] > 10) 
        H.A[H.L + 1] = H.A[H.L] / 10,
        H.A[H.L] %= 10, 
        H.L++; 
    return H; 
}
// 高精度除单精度
HighPrec Div(HighPrec A, int k){
    HighPrec H;
    int t = 0;
    for(int i = A.L ; i >= 1 ; i--)
        t = t * 10 + A.A[i], 
        H.A[i] = t / k, t %= k;
    H.L = A.L;
    while(H.A[H.L] == 0)
        H.L--; 
    return H;
}
// 输出高精度
void OutPut(HighPrec A){
    for(int i = A.L ; i >= 1 ; i--)
        printf("%d", A.A[i]); 
}

HighPrec T;
int n;

int main(){
    scanf("%d", &n);
    T = Init(); 
    for(int i = n + 2 ; i <= n * 2 ; i++)
        T = Mul(T, i);
    for(int i = 1 ; i <= n ; i++)
        T = Div(T, i);
    OutPut(T); 
    return 0;
}
```
核心实现思想：定义高精度结构体及相关运算函数，通过初始化、高精乘单精、高精除单精等操作，利用卡特兰数通项公式计算结果并输出。

**作者消失的海岸线重点代码**：
```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <iomanip>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 1010
#define ll long long
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n;
const int W=9;
const int bit=1000000000;
#define MAX_LEN 1000
struct big
{
    int len;
    ll x[MAX_LEN];
    ll& operator [](int a)
    {return x[a];}
    friend void operator *=(big &a,int b)
    {
        int len=a.len;
        for(int i=1;i<=len;i++)a[i]*=b;
        int now=1;
        while(now<=len)
        {
            if(a[now]>=bit)a[now+1]+=a[now]/bit,a[now]%=bit;
            if(now==len&&a[len+1])len++;
            now++;
        }
        a.len=len;
    }
    void print()
    {
        for(int i=len;i>=1;i--)
        if(i==len)printf("%lld",x[i]);
        else printf("%09lld",x[i]);
    }
}ans;
int c[N];
void add(int x,int v)
{
    for(int i=2;i*i<=x;++i)
    while(x%i==0)x/=i,c[i]+=v;
    if(x!=1)c[x]+=v;
}
int main()
{
    n=read();
    for(int i=n+2;i<=n+n;++i)add(i,1);
    for(int i=1;i<=n;++i)add(i,-1);
    ans[1]=ans.len=1;
    for(int i=1;i<=n+n;++i)
    while(c[i])ans*=i,--c[i];
    ans.print();
    return 0;
}
```
核心实现思想：定义存储质因数个数数组和高精度结构体及相关运算，通过`add`函数统计质因数，利用质因数存储优化乘除，最后通过高精度乘法得出结果并输出。

**最优关键思路或技巧**：在处理卡特兰数高精度计算时，将乘除部分按质因数存储，避免高精度除法运算，同时结合高精度压位技巧，可有效提高运算效率和代码简洁性。

**可拓展思路**：此类题目关键在于识别卡特兰数模型，常见于具有类似递归结构或计数问题。遇到此类问题，可尝试分析问题结构，寻找递推关系。类似算法套路如分析问题中元素组合方式，通过划分不同情况得出递推式。

**相似知识点洛谷题目**：
  - P1044 [栈](https://www.luogu.com.cn/problem/P1044)
  - P1722 矩阵II](https://www.luogu.com.cn/problem/P1722)
  - P2057 [二叉树统计](https://www.luogu.com.cn/problem/P2057)

**个人心得摘录**：作者S_Gloria提到卡特兰数常规递推式在数很大涉及取余运算时可能出现问题（x%p==0导致answer=0从而WA掉），这提醒在使用递推式时要注意数据范围和取余运算影响。 

---
处理用时：38.38秒
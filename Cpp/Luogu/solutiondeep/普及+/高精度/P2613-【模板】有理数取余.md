# 题目信息

# 【模板】有理数取余

## 题目描述

给出一个有理数 $c=\frac{a}{b}$，求 $c \bmod 19260817$ 的值。

这个值被定义为 $bx\equiv a\pmod{19260817}$ 的解。

## 说明/提示

对于所有数据，保证 $0\leq a \leq 10^{10001}$，$1 \leq b \leq 10^{10001}$，且 $a, b$ 不同时是 $19260817$ 的倍数。

## 样例 #1

### 输入

```
233
666
```

### 输出

```
18595654
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕求解有理数\(\frac{a}{b}\)对\(19260817\)取余的问题，核心思路是将有理数取余转化为整数取余问题，通过求\(b\)的逆元来解决。主要有两种方法：利用费马小定理和扩展欧几里得算法。
1. **利用费马小定理**：因为\(19260817\)是质数，根据费马小定理\(a^{p - 1} \equiv 1 \pmod{p}\)，可得\(b^{p - 2}\)是\(b\)的逆元，即\(a/b \equiv a \times b^{p - 2} \pmod{p}\)。题解中通过快速幂计算\(b^{p - 2}\)，并在输入\(a\)和\(b\)时边读入边取模，避免高精度运算。
2. **扩展欧几里得算法**：将问题转化为求解同余方程\(bx \equiv 1 \pmod{p}\)，即\(bx + py = 1\)，通过扩展欧几里得算法求出\(x\)，\(x\)即为\(b\)的逆元，最后计算\(a \times x \pmod{p}\)。同样在输入时对\(a\)和\(b\)取模。

难点在于处理\(a\)和\(b\)的数据范围较大的问题，各题解均采用在输入过程中对\(a\)和\(b\)不断取模的方式解决。部分题解还提到了无解的情况，即当\(b\)是\(19260817\)的倍数时无解。

### 所选的题解
- **作者：学委 (赞：441)**  星级：5星
    - **关键亮点**：思路清晰，详细阐述了从有理数取余概念不明确到逐步转化为同余方程求解的过程，对取余运算性质、同余方程求解及无解情况分析透彻，代码简洁明了，注释详细。
    - **个人心得**：无
    ```cpp
    #include <cstdio>
    #include <cctype>
    const int MOD = 19260817;
    inline int getint()
    {
        int res = 0, ch = getchar();
        while (!isdigit(ch) && ch!= EOF)
            ch = getchar();
        while (isdigit(ch))
        {
            res = (res << 3) + (res << 1) + (ch - '0');
            res %= MOD;
            ch = getchar();
        }
        return res;
    }

    int x, y;
    void exgcd(int a, int b)
    {
        if (b == 0)
        {
            x = 1;
            y = 0;
            return;
        }
        exgcd(b, a % b);
        int Last_x = x;
        x = y;
        y = Last_x - a / b * y;
    }

    int main()
    {
        int a, b;
        a = getint();
        b = getint();

        if (b == 0)
        {
            puts("Angry!");
            return 0;
        }
        exgcd(b, MOD);
        x = (x % MOD + MOD) % MOD;
        printf("%lld\n", a * (long long)(x) % MOD);
        return 0;
    }
    ```
    - **核心实现思想**：通过`getint`函数边读入边对\(a\)和\(b\)取模，利用扩展欧几里得算法`exgcd`求解同余方程\(bx \equiv 1 \pmod{MOD}\)，得到\(b\)的逆元\(x\)，最后计算\(a \times x \pmod{MOD}\)。
- **作者：顾z (赞：70)**  星级：4星
    - **关键亮点**：简洁地阐述思路，利用费马小定理得出\(b\)的逆元为\(b^{p - 2}\)，通过快速幂计算逆元，代码实现清晰，对输入进行取模处理。
    - **个人心得**：无
    ```cpp
    #include<bits/stdc++.h>
    #define IL inline
    #define RI register int
    #define mod 19260817
    long long a, b, ans;
    IL void read(long long &x)
    {
        int f = 1;
        x = 0;
        char s = getchar();
        while (s > '9' || s < '0')
        {
            if (s == '-')
                f = -1;
            s = getchar();
        }
        while (s <= '9' && s >= '0')
        {
            x = x * 10 % mod + (s - '0') % mod;
            s = getchar();
        }
        x = x % mod * f;
    }
    IL long long ksm(long long x, long long p)
    {
        long long res = 1;
        for (; p; p >>= 1, x = x * x % mod)
            if (p & 1)
                res = res * x % mod;
        return res;
    }
    int main()
    {
        read(a);
        read(b);
        if (b == 0)
        {
            printf("Angry!");
            return 0;
        }
        ans = a * ksm(b, mod - 2);
        printf("%lld", (ans % mod + mod) % mod);
    }
    ```
    - **核心实现思想**：`read`函数边读入边对\(a\)和\(b\)取模，`ksm`函数通过快速幂计算\(b^{mod - 2}\)得到\(b\)的逆元，最后计算\(a\)乘以逆元并取模。
- **作者：lahlah (赞：4)**  星级：4星
    - **关键亮点**：分别给出了利用费马小定理和扩展欧几里得算法两种解法，对每种解法的原理和实现过程都有清晰的阐述，代码注释详细。
    - **个人心得**：无
    - **费马小定理解法代码**：
    ```cpp
    #include<bits/stdc++.h>
    #define ll long long
    #define mod 19260817
    using namespace std;
    char st[10005];
    int main()
    {
        scanf("%s", st);
        int len = strlen(st);
        int a = 0;
        for (int i = 0; i < len; i++)
        {
            a = a * 10 + st[i] - '0';
            a = a % mod;
        }
        scanf(" %s", st);
        len = strlen(st);
        int b = 0;
        for (int i = 0; i < len; i++)
        {
            b = b * 10 + st[i] - '0';
            b = b % mod;
        }
        ll ans = 1;
        ll t = b;
        if (t % mod == 0)
        {
            printf("Angry!");
            return 0;
        }
        for (int i = mod - 2; i; i >>= 1, t = t * t % mod)
            if (i & 1)
                ans = ans * t % mod;
        ans = ans * a % mod;
        printf("%lld", ans);
        return 0;
    }
    ```
    - **核心实现思想**：读入\(a\)和\(b\)时边读边取模，通过快速幂计算\(b^{mod - 2}\)得到\(b\)的逆元，再计算\(a\)乘以逆元并取模。
    - **扩展欧几里得解法代码**：
    ```cpp
    #include<bits/stdc++.h>
    #define ll long long
    #define mod 19260817
    using namespace std;
    char st[10005];
    ll exgcd(ll &x, ll &y, ll a, ll b, ll &d)
    {
        if (!b)
        {
            d = a;
            x = 1;
            y = 0;
        }
        else
        {
            exgcd(x, y, b, a % b, d);
            int t = x;
            x = y;
            y = t - (a / b) * y;
            x = x % mod;
            y = y % mod;
        }
    }
    int main()
    {
        scanf("%s", st);
        int len = strlen(st);
        int aa = 0;
        for (int i = 0; i < len; i++)
        {
            aa = aa * 10 + st[i] - '0';
            aa = aa % mod;
        }
        scanf(" %s", st);
        len = strlen(st);
        int bb = 0;
        for (int i = 0; i < len; i++)
        {
            bb = bb * 10 + st[i] - '0';
            bb = bb % mod;
        }
        ll x, y, a, b, d;
        a = bb;
        b = mod;
        exgcd(x, y, a, b, d);
        if (d > 1)
        {
            printf("Angry!");
            return 0;
        }
        for (; x < 0;)
            x += mod;
        ll ans = aa * x % mod;
        printf("%lld", ans);
        return 0;
    }
    ```
    - **核心实现思想**：读入\(a\)和\(b\)时边读边取模，通过扩展欧几里得算法`exgcd`求解同余方程\(bx \equiv 1 \pmod{mod}\)得到\(b\)的逆元\(x\)，计算\(a\)乘以逆元并取模。

### 最优关键思路或技巧
1. **转化思想**：将不熟悉的有理数取余问题转化为整数同余方程问题，通过求逆元解决。
2. **输入取模**：针对\(a\)和\(b\)数据范围大的问题，在输入过程中对其不断取模，避免高精度运算。
3. **利用数论定理**：根据模数\(19260817\)是质数的特点，利用费马小定理或扩展欧几里得算法求逆元。

### 可拓展思路
此类题目拓展方向主要是数论相关知识的综合运用，例如结合中国剩余定理解决多个同余方程问题，或者在更复杂的数论背景下求逆元。类似算法套路是在处理涉及取模运算且数据范围较大的问题时，考虑通过数论定理简化问题，并在输入或计算过程中合理取模避免高精度。

### 推荐题目
1. **P1082 同余方程**：求解同余方程\(ax \equiv 1 \pmod{b}\)，与本题利用扩展欧几里得算法求逆元紧密相关。
2. **P3811 乘法逆元**：要求求出\(1\)到\(n\)中所有数在模\(p\)意义下的乘法逆元，可加深对逆元概念和求解方法的理解。
3. **P2613 【模板】有理数取余**：与本题类似，同样是有理数取余问题，可进一步巩固相关解法。

### 个人心得摘录与总结
1. **作者：Arcturus1350**：吐槽定义变量忘了初始化、数据出锅玄学RE等调试问题。总结为在编程中要注意变量初始化，避免因数据问题导致运行错误。
2. **作者：wrehtg**：从数论角度思考有理数取余的意义，将整数同余推广到有理数范围，加深对问题本质的理解。 

---
处理用时：50.74秒
# 题目信息

# 三只小猪

## 题目背景

你听说过三只小猪的故事吗？这是一个经典的故事。很久很久以前，有三只小猪。第一只小猪用稻草建的房子，第二个小猪用木棍建的房子，第三个小猪则使用砖做为材料。一只大灰狼想吃掉它们并吹倒了稻草和木棍建的房子。但是砖盖的房子很结实，狼最终也没有破坏掉，最后小猪们战胜了大灰狼并把它尾巴烧掉了。


## 题目描述

为了自己的安全，小猪们又建造了一个新砖房。但是现在问题出现了，怎样把三个小猪分配到两个房子里呢？第三只小猪是三只小猪中最聪明的一只，为了不浪费任何一个房子，它总共考虑了三种方案，如下图

 ![](https://cdn.luogu.com.cn/upload/pic/6862.png) 

“但是将来怎么办呢？”第三只小猪知道将来随着成员的增多，它们将会盖更多的房子。它想知道给定了房子和猪的数目后，房子的分配方案有多少，但这个问题对于它来说，很明显有点难了，你能帮小猪解决这个问题吗？


## 样例 #1

### 输入

```
4 2```

### 输出

```
7```

## 样例 #2

### 输入

```
6 7```

### 输出

```
0```

# AI分析结果

• 综合分析与结论：这些题解都围绕将n只小猪分配到m个房子的方案数问题，核心思路是利用第二类斯特林数求解。算法要点在于推导出状态转移方程 `f[n][m]=f[n - 1][m - 1]+m*f[n - 1][m]`，难点是数据范围较大，需使用高精度运算。各题解在思路清晰度、代码可读性和优化程度上有所差异。
• 所选的题解：
  - 作者：_ZZH (5星)
    - 关键亮点：思路清晰，先阐述状态转移方程的推导，点明是第二类斯特林数，针对数据范围大问题，详细介绍使用三维数组实现高精加和高精乘的方法。
    - 个人心得：无
    - 核心代码：
```cpp
void _change(int x,int y)
{
    if(y>x)return;
    if(x==1&&y==1)return;
    for(int i=1;i<=_size;i++)
        _ans[i]=0;
    _size=1;
    int _x=0;
    for(int i=1;i<=f[x - 1][y][0];i++)
    {
        _ans[i]=f[x - 1][y][i]*y+_x;
        _x=_ans[i]/10;
        _ans[i]%=10;
    }
    _size=f[x - 1][y][0];
    if(_x!=0)
        _ans[++_size]=_x;
    f[x][y][0]=1;
    _x=0;
    while(f[x][y][0]<=f[x - 1][y - 1][0]||f[x][y][0]<=_size)
    {
        f[x][y][f[x][y][0]]=f[x - 1][y - 1][f[x][y][0]]+_ans[f[x][y][0]]+_x;
        _x=f[x][y][f[x][y][0]]/10;
        f[x][y][f[x][y][0]]%=10;
        f[x][y][0]++;
    }
    f[x][y][f[x][y][0]]=_x;
    if(f[x][y][f[x][y][0]]==0&&f[x][y][0]!=1)
        f[x][y][0]--;
}
```
核心实现思想：通过 `_change` 函数实现高精度乘法和加法，先进行高精度乘法计算 `m*f[n - 1][m]`，再与 `f[n - 1][m - 1]` 进行高精度加法。
  - 作者：xrk2006 (4星)
    - 关键亮点：不仅详细推导第二类斯特林数的递推式，还将本题与类似题目联系，指出异同，对相关知识点拓展丰富。代码使用字符串实现高精度运算，注释详细。
    - 个人心得：无
    - 核心代码：
```cpp
string add(string a,string b)//高精度加法
{
    string ans;
    int l1=a.size(),l2=b.size();
    int lk=max(l1,l2);
    int u[maxn*10]={0},v[maxn*10]={0};
    for(int i=0;i<l1;i++)u[l1 - i - 1]=a[i]-'0';
    for(int i=0;i<l2;i++)v[l2 - i - 1]=b[i]-'0';
    for(int i=0;i<lk;i++)
    {
        u[i]+=v[i];
        u[i + 1]+=u[i]/10;
        u[i]%=10;
    }
    if(u[lk])lk++;
    for(int i=lk - 1;i>=0;i--)ans+=u[i]+'0';
    return ans;
}
string mul(string a,int b)//高精a*单精b
{
    string ans;
    int l=a.size();
    int u[maxn*10]={0};
    for(int i=l - 1;i>=0;i--)u[l - i - 1]=a[i]-'0';
    int w=0;
    for(int i=0;i<l;i++)
    {
        u[i]=u[i]*b+w;
        w=u[i]/10;
        u[i]%=10;
    }
    while(w)u[l++]=w%10,w/=10;
    for(int i=l - 1;i>=0;i--)ans+=u[i]+'0';
    return ans;
}
```
核心实现思想：`add` 函数实现高精度加法，将字符串转数组进行逐位相加并处理进位；`mul` 函数实现高精度乘单精度，同样转数组运算并处理进位。
  - 作者：bloodstalk (4星)
    - 关键亮点：对第二类斯特林数的定义和递推公式证明详细，代码实现使用结构体数组存储高精度结果，逻辑清晰。
    - 个人心得：无
    - 核心代码：
```cpp
il void calc(int x,int y)
{
    L[x][y] = max(L[x - 1][y - 1],L[x - 1][y]);
    for(re int i=1;i<=L[x][y];i++)
    {
        S[x][y][i] += S[x - 1][y - 1][i] + y * S[x - 1][y][i];
        S[x][y][i + 1] += S[x][y][i] / 10;
        S[x][y][i] %= 10;
    }
    if(S[x][y][L[x][y]+1] > 0) L[x][y]++;
    while(S[x][y][L[x][y]] >= 10)
    {
        S[x][y][L[x][y]+1] = S[x][y][L[x][y]] / 10;
        S[x][y][L[x][y]] %= 10;
        L[x][y]++;
    }
}
```
核心实现思想：`calc` 函数通过先确定结果的最大长度，然后逐位进行高精度加法和乘法运算，并处理进位以更新结果的每一位和长度。
• 最优关键思路或技巧：利用第二类斯特林数的递推关系解决组合分配问题，面对大数据范围采用高精度运算。在代码实现上，无论是用数组模拟还是字符串处理，关键是清晰实现高精度加法和乘法的运算逻辑。
• 可拓展之处：此类问题属于组合数学中的分配问题，类似套路是分析每个元素的分配情况得出递推关系，再结合数据范围考虑是否需高精度等优化。
• 相似知识点洛谷题目：
  - P1655 小朋友的球：同样是分配问题，可类比本题思路求解。
  - P5824 十二重计数法：涵盖多种放球问题，包含本题类似模型。
  - T188453 十二重计数法【弱化版】：是P5824的弱化版，数据范围较小便于练习。
• 个人心得摘录与总结：无。 

---
处理用时：33.04秒
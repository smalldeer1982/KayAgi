# 题目信息

# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# AI分析结果



### 综合分析与结论
本题核心是动态规划与高精度结合。各题解主要采用两种思路：DP（状态转移+高精度）和DFS（剪枝+高精度）。关键难点在于大数处理与状态划分的准确性。最优解法为DP方案，其中定义`dp[i][j]`表示前i位用j个乘号的最大乘积，结合高精度实现。

---

### 精选题解

#### 1. 作者：liar_white（★★★★☆）
**关键亮点**  
- 使用结构体封装高精度操作，逻辑清晰  
- 动态规划状态设计合理（cut[i][j]表示第i位后放第j个乘号的最大值）  
- 完整处理高精度乘法和比较逻辑  

**核心代码思想**  
```cpp
struct node{ // 高精度结构体
    int v; bool exi;
    int c[50]; // 低位在前存储
};
node cut[50][10]; // DP状态数组

// 状态转移核心逻辑
for(int i=1; i<=n; i++){
    cut[i][1] = culc(1,i); // 初始化
    for(int j=2; j<=k; j++){
        for(int fr=j-1; fr<i; fr++){
            cut[i][j] = Max(cut[i][j], mul(cut[fr][j-1], culc(fr+1,i)));
        }
    }
}
```

#### 2. 作者：FastIO_DP（★★★★☆）
**关键亮点**  
- 高精度结构体设计规范（重载运算符）  
- 状态转移方程简洁明确  
- 代码结构模块化，易维护  

**核心代码实现**
```cpp
struct BI { // 高精度结构体
    int d[100], len;
    BI operator*(const BI& o) { // 重载乘法
        BI res;
        for(int i=0; i<len; ++i)
            for(int j=0; j<o.len; ++j)
                res.d[i+j] += d[i] * o.d[j];
        // 处理进位...
        return res;
    }
};

// DP转移核心
for(int j=1; j<=K; ++j) {
    for(int i=j; i<N; ++i) {
        for(int k=j-1; k<i; ++k) {
            dp[i][j] = max(dp[i][j], dp[k][j-1] * num(k+1,i));
        }
    }
}
```

#### 3. 作者：mairuisheng（★★★☆☆）
**亮点**  
- DFS剪枝策略（剩余位置检查）  
- 高精度乘法模板复用  
**优化建议**  
- K较大时DFS效率较低  

---

### 关键思路与技巧
1. **DP状态设计**：`dp[i][j]`表示前i位使用j个乘号的最大乘积，状态转移时枚举最后一个乘号位置
2. **高精度存储**：数字逆序存储（低位在数组前端），便于进位处理
3. **剪枝策略**：在DFS中检查剩余位置是否足够放置剩余乘号
4. **乘积比较**：先比位数长度，再逐位比较

---

### 同类题目推荐
1. [P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)（高精度+区间DP）
2. [P1436 棋盘分割](https://www.luogu.com.cn/problem/P1436)（划分型DP）
3. [P1043 数字游戏](https://www.luogu.com.cn/problem/P1043)（环形划分+最值计算）

---
处理用时：67.31秒
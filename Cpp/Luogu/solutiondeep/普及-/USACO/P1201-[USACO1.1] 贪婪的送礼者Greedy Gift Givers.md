# 题目信息

# [USACO1.1] 贪婪的送礼者Greedy Gift Givers

## 题目描述

对于一群 $n$ 个要互送礼物的朋友，GY 要确定每个人送出的钱比收到的多多少。在这一个问题中，每个人都准备了一些钱来送礼物，而这些钱将会被平均分给那些将收到他的礼物的人。  

然而，在任何一群朋友中，有些人将送出较多的礼物(可能是因为有较多的朋友)，有些人有准备了较多的钱。  

给出一群朋友，没有人的名字会长于 $14$ 字符，给出每个人将花在送礼上的钱，和将收到他的礼物的人的列表，请确定每个人收到的比送出的钱多的数目。


## 说明/提示

【数据范围】  
$1\le n \le 10$

题目翻译来自NOCOW。

USACO Training Section 1.1


## 样例 #1

### 输入

```
5
dave
laura
owen
vick
amr
dave
200 3
laura
owen
vick
owen
500 1
dave
amr
150 2
vick
owen
laura
0 2
amr
vick
vick
0 0
```

### 输出

```
dave 302
laura 66
owen -359
vick 141
amr -150
```

# AI分析结果



### 综合分析与结论
本题核心是模拟送礼过程，需处理字符串映射、余数计算及除零异常。题解多采用**哈希映射（map）优化查找**或线性遍历结构体，关键在于正确处理送礼金额分配与余数保留。需特别注意除数判零，否则会RE。

---

### 高星题解推荐

#### 1. 题解作者：BlueArc（5星）
**核心亮点**  
- 使用`map<string, int>`实现O(1)查找，代码简洁高效  
- 特判除数0，避免浮点异常  
- 数学处理巧妙：`cnt[s] -= num*p`直接计算净支出  
**代码核心**  
```cpp
map<string,int> cnt; // 建立姓名到净收入的映射
for (送礼者循环) {
    cnt[s] -= num*p; // num=总钱/人数，p为人数
    cnt[收礼者] += num; 
}
```

#### 2. 题解作者：蒟蒻炒扇贝（4.5星）
**关键技巧**  
- 利用`floor`计算平均分配金额，显式处理余数  
- 注释详细，适合新手理解边界逻辑  
**个人心得**  
> “注意送礼者返还的余钱相当于收入，否则只能得22分”——强调余数需计入送礼者账户  

#### 3. 题解作者：w1049（4星）
**创新点**  
- 结合`vector`保持输入顺序，解决map无序输出问题  
- 代码精简，逻辑清晰：`m[tmp] += money%num`直接处理余数  
**核心代码**  
```cpp
vector<string> id; // 存储原始顺序
map<string,int> m; // 快速查找
for (送礼循环) {
    m[s] -= money;
    m[s] += money % num; // 余数返还
    m[收礼者] += money/num;
}
```

---

### 关键思路总结
1. **数据结构选择**：优先使用`map`或`unordered_map`实现姓名到金额的快速映射，避免线性查找。
2. **余数处理**：送礼者净支出为`总金额 - (平均金额 * 人数)`，剩余金额自动保留。
3. **边界特判**：除数必须判零（`if (p != 0)`），否则导致RE。
4. **输出顺序**：若用map，需额外存储初始顺序（如vector）以保证输出顺序。

---

### 拓展练习（洛谷题号）
1. **P1308 统计单词数** - 字符串匹配与位置记录（类似姓名映射）
2. **P1177 【模板】快速排序** - 结构体排序与数据组织
3. **P1056 排座椅** - 模拟场景与贪心策略，强化边界处理

---
处理用时：43.61秒
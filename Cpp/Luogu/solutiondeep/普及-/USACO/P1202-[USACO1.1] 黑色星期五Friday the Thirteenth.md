# 题目信息

# [USACO1.1] 黑色星期五Friday the Thirteenth

## 题目描述

$13$ 号又是一个星期五，那么 $13$号在星期五比在其他日子少吗？  

为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。

这里有一些你要知道的:

1. $1900$ 年 $1$ 月 $1$ 日是星期一。
2. $4,6,11$ 和 $9$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。
3. 年份可以被 $4$ 整除的为闰年（$1992=4\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。
4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 400$。

题目翻译来自NOCOW。

USACO Training Section 1.1


## 样例 #1

### 输入

```
20
```

### 输出

```
36 33 34 33 35 35 34
```

# AI分析结果



### 综合分析与结论
本题核心在于高效处理日期推算与闰年判断。题解主要分为模拟法与数学公式法两类，其中利用基姆拉尔森公式或蔡勒公式的解法在代码简洁性与效率上显著优于逐日/逐月模拟。

---

### 精选题解与亮点

#### 1. HEIGE（5星）
**关键亮点**：  
- 采用基姆拉尔森公式直接计算每月13号的星期数，时间复杂度O(1)  
- 代码极简（仅20行），无需处理复杂的日期推移逻辑  
- 巧妙处理闰年与月份边界条件  

**核心代码**：
```cpp
int week_day(int year, int month, int day) {
    if (month == 1 || month == 2) month += 12, year--;
    return (day + 2*month + 3*(month+1)/5 + year + year/4 - year/100 + year/400 + 1) % 7;
}
// 主函数遍历每个月的13日调用该函数
```

#### 2. 早右昕（4星）
**关键亮点**：  
- 利用月份间13号的天数间隔递推  
- 使用结构体封装日期，操作符重载简化比较  
- 避免逐日计算，时间复杂度O(n)  

**核心思想**：
```cpp
date a = (date){1900,0,5}; // 初始日期
while(!(b<a)) {
    t[a.ww]++, ++a; // 每月天数差递推
}
```

#### 3. buickboy（4星）
**关键亮点**：  
- 预处理每月天数差模7的结果  
- 通过闰年判断动态调整递推步长  
- 代码结构清晰，数学优化思路明确  

---

### 最优思路总结
**数学公式法**是本题最优解，基姆拉尔森公式通过巧妙的数学变换将日期转换为星期数，避免了所有模拟计算。核心技巧包括：
1. 将1/2月视为上年的13/14月处理  
2. 利用整数除法的取整特性简化闰年计算  
3. 对公式结果取模7直接得到星期索引  

---

### 拓展与同类题目
1. **日期处理套路**：预处理月份表、数学公式优化、递推间隔天数  
2. **类似题目推荐**：  
   - [P1203 [USACO1.1]坏掉的项链](https://www.luogu.com.cn/problem/P1203)  
   - [P1515 [USACO08DEC]Patting Heads S](https://www.luogu.com.cn/problem/P2926)  
   - [P1024 [NOIP2001 提高组] 一元三次方程求解](https://www.luogu.com.cn/problem/P1024)（数学公式应用）

---

### 个人心得摘录
> "竞赛环境下不能指望背公式，但学习这类数学解法能极大优化代码" —— HEIGE  
> "输出顺序是周六开始的坑点，导致我WA了三次" —— 某匿名题解  
> "递推时把每月13号看作固定锚点，避免处理具体日期" —— buickboy

---
处理用时：60.93秒
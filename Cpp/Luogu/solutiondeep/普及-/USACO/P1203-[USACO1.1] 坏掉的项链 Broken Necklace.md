# 题目信息

# [USACO1.1] 坏掉的项链 Broken Necklace

## 题目描述

你有一条由 $n$ 个红色的，白色的，或蓝色的珠子组成的项链，珠子是随意安排的。 这里是 $n=29$ 的两个例子:

![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png) 

第一和第二个珠子在图片中已经被作记号。

图片 A 中的项链可以用下面的字符串表示：

`brbrrrbbbrrrrrbrrbbrbbbbrrrrb`

假如你要在一些点打破项链，展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事(颜色可能与在这之前收集的不同)。 确定应该在哪里打破项链来收集到最大数目的珠子。

例如，在图片 A 中的项链中，在珠子 $9$ 和珠子 $10$ 或珠子 $24$ 和珠子 $25$ 之间打断项链可以收集到 $8$ 个珠子。

白色珠子什么意思?

在一些项链中还包括白色的珠子(如图片B) 所示。

当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。

表现含有白珠项链的字符串将会包括三个符号 `r`，`b`，`w` 。

写一个程序来确定从一条被给出的项链可以收集到的珠子最大数目。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$3\le n \le 350$

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
29 
wwwbbrwrbrbrrbrbrwrwwrbwrwrrb
```

### 输出

```
11```

# AI分析结果



### 题解综合分析与结论
各题解核心思路围绕环形处理（复制字符串/链表）、颜色连续性统计、白色珠子灵活处理展开。主要解法可分为三类：①暴力枚举断点+双指针扩展（O(n²)）②线性扫描维护左右段状态（O(n)）③动态规划预处理左右极值（O(n)）。白色珠子的处理普遍采用"假设为前/后颜色"策略，其中青衫白叙的O(n)解法在时间效率上最优。

---

### 精选题解与核心思路

#### 1. 青衫白叙（五星）
**关键亮点**：  
- O(n)时间复杂度，仅需一次线性扫描  
- 通过维护`left`和`right`的累计长度及中间w的过渡，动态更新最大值  
- 代码极简（仅20行），空间效率极高  
**个人心得**：  
作者在注释中强调"当遇到颜色变化时，需将w段划归右侧"，这是保证贪心最优性的关键，该思路来源于对样例的深度分析。

#### 2. 田阙西（四星半）
**关键亮点**：  
- 动态规划预处理左右两侧的极值  
- 使用四个数组分别记录红/蓝的左右累计值  
- 最终通过组合左右极值求最大解  
**优化启示**：  
预处理思想可推广至需要多次区间查询的类似问题，如环形最大子段和。

#### 3. w_y_c（四星）
**关键亮点**：  
- 三倍字符串处理环形结构的直观实现  
- 枚举断点时考虑w的双重可能性（转红/蓝）  
- 代码注释清晰，适合理解基础解法  
**踩坑提示**：  
作者提到当断点为w时需要分别尝试两种颜色，否则会遗漏某些最优解情况。

---

### 核心代码片段

#### 青衫白叙的核心逻辑
```cpp
for(int i = 0; i < n<<1; i++) {
    if(s[i] == 'w') { b++;w++;} 
    else if(s[i] == c){ b++;w=0;}
    else {
        ans = max(ans,a + b);
        a = b - w;  // 将w段划归右侧
        b = w + 1;
        w = 0;
        c = s[i];
    }
}
```
通过维护`a`（左段有效长度）和`b`（右段含w长度），在颜色变化时更新最大值，巧妙处理w的归属问题。

#### 田阙西的DP预处理
```cpp
// 左向预处理
for(int i=1;i<=n*2;++i) {
    if(c[i]=='w') { lR[i]=lR[i-1]+1; lB[i]=lB[i-1]+1; }
    else if(c[i]=='r') lR[i]=lR[i-1]+1;
    else lB[i]=lB[i-1]+1;
}
// 右向预处理
for(int i=n*2;i>=1;--i) {
    if(c[i]=='w') { rR[i]=rR[i+1]+1; rB[i]=rB[i+1]+1; }
    else if(c[i]=='r') rR[i]=rR[i+1]+1;
    else rB[i]=rB[i+1]+1;  
}
```
通过双向DP预处理每个点的左右极值，最终组合时取max(lR[i],lB[i]) + max(rR[i+1],rB[i+1])。

---

### 举一反三与题目推荐
1. **环形结构处理**  
   - 能量项链（P1063）  
   - 约瑟夫问题（P1996）

2. **双指针/滑动窗口**  
   - 最长无重复子串（P2553）  
   - 最小覆盖子串（P1638）

3. **动态规划预处理**  
   - 最大子矩阵（P1719）  
   - 接雨水（P2870）

---

### 调试经验摘录
1. **青衫白叙**提到"当左侧为w时需重新计算起始颜色"，通过添加中间变量`c`记录当前颜色状态，避免了重复计算。  
2. **w_y_c**在注释中指出"当断点为w时必须尝试两种颜色"，否则会错失第三个测试点的正确解。  
3. **Dvelpro**在暴力解法中发现"当两侧均为w时需要特殊处理"，通过设置flag标记避免死循环。

---
处理用时：68.98秒
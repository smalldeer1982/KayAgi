# 题目信息

# [USACO1.2] 挤牛奶Milking Cows

## 题目描述

三个农民每天清晨 $5$ 点起床，然后去牛棚给三头牛挤奶。

第一个农民在 $300$ 秒 (从 $5$ 点开始计时) 给他的牛挤奶，一直到 $1000$ 秒。第二个农民在 $700$ 秒开始，在 $1200$ 秒结束。第三个农民在 $1500$ 秒开始，$2100$ 秒结束。  

期间最长的至少有一个农民在挤奶的连续时间为 $900$ 秒 (从 $300$ 秒到 $1200$ 秒)，而最长的无人挤奶的连续时间(从挤奶开始一直到挤奶结束)为 $300$ 秒 (从 $1200$ 秒到 $1500$ 秒)。
****

你的任务是编一个程序，读入一个有 $n$ 个农民挤 $n$ 头牛的工作时间列表，计算以下两点(均以秒为单位):

最长至少有一人在挤奶的时间段。

最长的无人挤奶的时间段。（从有人挤奶开始算起）


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 5000$，$0 \le l \le r \le 10^6$。

题目翻译来自NOCOW。

USACO Training Section 1.2


## 样例 #1

### 输入

```
3
300 1000
700 1200
1500 2100
```

### 输出

```
900 300
```

# AI分析结果



### 综合分析与结论
本题核心在于区间处理与连续时间段统计。题解主要呈现四种思路：暴力标记法、排序合并区间法、差分法、事件驱动法。其中排序合并法与差分法在时间复杂度（O(nlogn)）和空间复杂度（O(n)）上最优，适用于大数据量；事件驱动法则通过离散化事件点实现高效处理。

---

### 高星题解推荐
#### 1. 学而思李老师 - 结构体排序合并（⭐⭐⭐⭐⭐）
**核心思路**：按左端点排序后合并重叠区间，计算最长连续区间和间隔  
**亮点**：
- 时间复杂度O(nlogn) + O(n)最优
- 代码简洁易维护
- 巧妙处理区间合并逻辑（`m[i].begin <= end`时更新右端点）
**关键代码**：
```cpp
sort(m + 1, m + 1 + N, cmp); // 按左端点排序
int begin = m[1].begin, end = m[1].end;
for(int i = 2; i <= N; ++i) {
    if(m[i].begin <= end) 
        end = max(end, m[i].end); // 合并区间
    else {
        ans1 = max(ans1, end - begin); // 更新最长挤奶时间
        ans2 = max(ans2, m[i].begin - end); // 更新最长空闲时间
        begin = m[i].begin; // 重置当前区间
        end = m[i].end;
    }
}
```

#### 2. KesdiaelKen - 差分法（⭐⭐⭐⭐⭐）
**核心思路**：用差分数组标记时间点变化，前缀和统计各时刻状态  
**亮点**：
- 单次遍历即可完成统计
- 无需显式处理区间重叠
- 时间复杂度O(max_time)线性
**调试心得**：特别注意挤奶时间段为左闭右开，差分标记时需在`b[r]--`而非`b[r+1]--`
```cpp
for(int i = 1; i <= n; ++i) {
    c[a]++; c[b]--; // 差分标记
    start = min(start, a);
    end = max(end, b - 1);
}
for(int i = start; i <= end; ++i) {
    c[i] += c[i-1]; // 还原真实计数
    // 统计连续1和0的长度...
}
```

#### 3. Mys_C_K - 事件排序法（⭐⭐⭐⭐）
**核心思路**：将开始/结束作为事件点排序，动态维护挤奶人数  
**亮点**：
- 离散化处理，空间复杂度低
- 天然处理重叠区间
**关键实现**：
```cpp
struct events{ int seconds; bool is_start; };
sort(event, event + 2*n, cmp); // 按时间排序，同时间开始事件优先
int scount = 0, last = event[0].seconds;
for(int i = 0; i < 2*n; ++i) {
    if(event[i].is_start) {
        if(scount == 0) ans2 = max(ans2, event[i].seconds - last);
        scount++;
    } else {
        scount--;
        if(scount == 0) ans1 = max(ans1, event[i].seconds - last);
    }
    last = event[i].seconds;
}
```

---

### 关键技巧总结
1. **区间合并排序**：处理重叠区间时，按左端点排序后贪心合并
2. **差分标记**：对区间增减操作进行O(1)标记，前缀和还原状态
3. **事件离散化**：将时间点转化为独立事件，按时间轴处理状态变化

---

### 拓展题目推荐
1. P1886 滑动窗口（单调队列维护区间极值）
2. P1496 火烧赤壁（区间合并与离散化）
3. P1719 最大加权矩形（二维前缀和与区间统计）

---
处理用时：49.67秒
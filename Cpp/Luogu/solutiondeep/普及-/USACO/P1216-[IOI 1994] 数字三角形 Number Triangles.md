# 题目信息

# [IOI 1994] 数字三角形 Number Triangles

## 题目描述

观察下面的数字金字塔。


写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)

在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大权值。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。

题目翻译来自NOCOW。

USACO Training Section 1.5

IOI1994 Day1T1

## 样例 #1

### 输入

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5 
```

### 输出

```
30
```

# AI分析结果



### 综合分析与结论
本题解核心思路为动态规划，所有解法均围绕状态转移方程展开。自底向上递推法为最优解法（时间复杂度O(n²)，空间可优化至O(n)），记忆化搜索适合理解DP思想但存在栈溢出风险。关键优化技巧包括滚动数组、一维数组优化、边读边处理等。

---

### 高星题解推荐

#### 1. linlin1024（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 自底向上递推思路清晰，图文结合说明状态转移过程  
- 代码简洁（仅15行核心逻辑），覆盖原数组节省空间  
- 附带详细样例推导过程，适合初学者理解  

**核心代码**：  
```cpp
for(int i=n-2;i>=0;i--) 
    for(int j=0;j<=i;j++)
        a[i][j] += max(a[i+1][j],a[i+1][j+1]);
```

#### 2. Mine_King（⭐⭐⭐⭐）
**关键亮点**：  
- 对比记忆化搜索与递推的转换过程  
- 代码包含递归边界处理与状态转移的完整推导  
- 记录从TLE到AC的调试经历，具有警示意义  

**核心片段**：  
```cpp
// 记忆化搜索
int dfs(int x,int y) {
    if(x==n) return a[x][y];
    if(f[x][y]) return f[x][y];
    return f[x][y] = max(dfs(x+1,y), dfs(x+1,y+1)) + a[x][y];
}
```

#### 3. iwprc（⭐⭐⭐⭐）  
**关键亮点**：  
- 一维数组空间优化（O(n)空间）  
- 逆序循环避免覆盖问题  
- 边读边处理的IO优化技巧  

**核心实现**：  
```cpp
int a[1002], p;
for(i=n; i; i--)
    for(j=i; j<=n; j++)
        scanf("%d",&p), a[j] = max(a[j],a[j+1]) + p;
```

---

### 关键技巧总结
1. **状态定义**：`dp[i][j]`表示从(i,j)出发到底部的最大和  
2. **转移方程**：`dp[i][j] += max(dp[i+1][j], dp[i+1][j+1])`  
3. **空间优化**：使用单数组滚动更新，j需逆序循环  
4. **输入优化**：边读入边处理，减少内存占用  

---

### 拓展练习推荐
1. P1004 [方格取数](https://www.luogu.com.cn/problem/P1004)  
   - 二维路径DP，需处理路径交叉  
2. P1434 [滑雪](https://www.luogu.com.cn/problem/P1434)  
   - 记忆化搜索经典题  
3. P1280 尼克的任务  
   - 逆向DP思维训练  

---

### 精选心得摘录
> "递归和递推的方向是相反的，通过逆向递推避免重复计算" —— Mine_King  
> "j循环必须逆序，否则会覆盖未使用的上层数据" —— iwprc  
> "贪心看似可行实则陷阱，必须全局考虑所有路径" —— 题解作者群

---
处理用时：53.33秒
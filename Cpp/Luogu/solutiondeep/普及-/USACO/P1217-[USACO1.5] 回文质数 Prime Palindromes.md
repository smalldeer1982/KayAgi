# 题目信息

# [USACO1.5] 回文质数 Prime Palindromes

## 题目描述

因为 $151$ 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 $151$ 是回文质数。

写一个程序来找出范围 $[a,b] (5 \le a < b \le 100,000,000)$（一亿）间的所有回文质数。

## 说明/提示

Hint 1: Generate the palindromes and see if they are prime.

提示 1: 找出所有的回文数再判断它们是不是质数（素数）.


Hint 2: Generate palindromes by combining digits properly. You might need more than one of the loops like below.

提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。


题目翻译来自NOCOW。

USACO Training Section 1.5


产生长度为 $5$ 的回文数：

```cpp
for (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数
     for (d2 = 0; d2 <= 9; d2++) {
         for (d3 = 0; d3 <= 9; d3++) {
           palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)
         }
     }
 }

```

## 样例 #1

### 输入

```
5 500
```

### 输出

```
5
7
11
101
131
151
181
191
313
353
373
383
```

# AI分析结果



### 综合分析与结论
本题核心在于高效生成回文数并验证质数，难点在于避免全范围枚举。优秀解法均利用回文数数学性质（如偶数位非质数）和生成式构造回文数，结合质数判断优化。关键优化点包括：分位数生成回文、筛法预处理、DFS构造回文数等。

---

### 高分题解推荐

#### 1. 作者：lenfrey（五星）
**关键亮点**  
- 递归生成回文数，避免全范围枚举  
- 利用奇数位数回文特性，自动跳过无效位数  
- 代码结构清晰，剪枝逻辑完善  
**核心代码**  
```cpp
void go(int x, int k) { // 递归生成回文数核心逻辑
    if (x == (k+1)/2) {
        int shu = 0;
        for (int i = 1; i <= k; i++) shu = shu * 10 + a[i];
        if (shu >= l && shu <= r && isprime(shu)) 
            cout << shu << endl;
        return;
    }
    for (int i = (x == 0 ? 1 : 0); i <= 9; i++) { // 首位非0
        a[x+1] = i;
        go(x+1, k);
    }
}
```

#### 2. 作者：min_进击的灭霸（四星半）
**关键亮点**  
- 三重过滤（位数检查+回文判断+质数验证）  
- 利用 `check1` 排除偶数位回文数  
- 预处理最大范围至9999999优化  
**核心代码**  
```cpp
bool check1(int x) { // 位数过滤
    if ((1000 <=x &&x <=9999) || (100000<=x&&x<=999999)) return 0; 
    return 1; // 排除4位和6位回文数
}
for (int i = l; i <= r; i += 2) { // 只遍历奇数
    if (!check1(i) || !check2(i) || !check3(i)) continue;
    printf("%d\n", i);
}
```

#### 3. 作者：linyorson（四星）
**关键亮点**  
- 极简判断逻辑，直接遍历奇数  
- 分离位数判断函数，代码可读性好  
**核心代码**  
```cpp
bool ws(int k) { // 位数过滤
    if (k>=10&&k<100&&k!=11 || k>=1000&&k<10000) return 0;
    return 1; // 排除2位和4位回文数
}
for (int i = a; i <= b; i += 2) { 
    if (ws(i) && ok(i) && ss(i)) cout << i << endl;
}
```

---

### 关键优化思路总结
1. **数学性质利用**：除11外，偶数位回文数必然不是质数  
2. **生成式构造**：递归生成回文数（如DFS生成前半部分，镜像后半）  
3. **剪枝策略**：首位非0、只遍历奇数、提前终止超范围分支  
4. **质数判断优化**：仅检查到√n，跳过偶数因子  

---

### 类似题目推荐
1. [P1217 回文质数](https://www.luogu.com.cn/problem/P1217)（本题）  
2. [P1304 哥德巴赫猜想](https://www.luogu.com.cn/problem/P1304)（质数判断+数学性质）  
3. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)（质因数分解应用）  
4. [P1061 判断题](https://www.luogu.com.cn/problem/P1061)（快速判断数字特性）

---

### 题解心得摘录
> "回文数比质数少得多，先判回文再判质数效率更高" —— min_进击的灭霸  
总结：优先执行过滤性强的判断条件可大幅提升效率  

> "打表虽爽，但失去了算法练习意义" —— QAQ永动机  
总结：打表法适合固定范围题目，但无法锻炼核心算法能力  

> "DFS生成时，对称轴位置处理是关键" —— lenfrey  
总结：生成式算法的核心在于正确建模数字结构

---
处理用时：65.25秒
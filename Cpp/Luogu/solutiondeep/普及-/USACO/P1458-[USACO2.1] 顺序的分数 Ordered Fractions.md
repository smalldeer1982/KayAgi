# 题目信息

# [USACO2.1] 顺序的分数 Ordered Fractions

## 题目描述

输入一个自然数 $n$，对于一个最简分数 $a/b$（分子和分母互质的分数），满足 $1 \le b \le n,0 \le a/b \le 1$，请找出所有满足条件的分数。

这有一个例子，当 $n=5$ 时，所有解为：

$$\frac01,\frac15,\frac14,\frac13,\frac25,\frac12,\frac35,\frac23,\frac34 ,\frac45,\frac11$$

给定一个自然数 $n$，请编程按分数值递增的顺序输出所有解。
 
注：   
1、$0$ 和任意自然数的最大公约数就是那个自然数。    
2、互质指最大公约数等于1的两个自然数。


## 说明/提示

【数据范围】    
对于 $100\%$ 的数据，$1\le n \le 160$。

USACO 2.1

翻译来自NOCOW


## 样例 #1

### 输入

```
5
```

### 输出

```
0/1
1/5
1/4
1/3
2/5
1/2
3/5
2/3
3/4
4/5
1/1
```

# AI分析结果



### 综合分析与结论
本题核心是生成有序最简分数序列。题解主要分为两类：  
1. **枚举+排序法**：双重循环枚举所有分数，筛选互质分数后排序。时间复杂度O(n² logn)，适合n≤160  
2. **分治法**：基于Stern-Brocot树递归生成中间分数，天然有序且保证最简，时间复杂度O(n)，效率更高  

### 高星题解推荐
---

#### 1. [浮尘ii] 分治法（★★★★★）
**核心亮点**：  
- 利用Stern-Brocot树特性，递归生成有序分数序列  
- 无需存储和排序，直接按顺序输出  
- 数学证明保证正确性，时间复杂度最优  
**个人心得**：  
> "这种方法来源于分数树的构造，每个中间分数a/b与c/d的插入保证有序性和最简性"  

**关键代码**：
```cpp
void DFS(int l1, int l2, int r1, int r2) {
    if(l2 > N || r2 > N) return;
    DFS(l1, l2, l1 + r1, l2 + r2);       // 左递归
    if(l2 + r2 <= N) cout<<...<<endl;   // 输出中间分数
    DFS(l1 + r1, l2 + r2, r1, r2);      // 右递归
}
```

---

#### 2. [robin2333] Stern-Brocot证明（★★★★☆）
**核心亮点**：  
- 补充数学归纳法证明，深入解释算法原理  
- 代码极简（仅8行核心逻辑）  
**关键实现**：  
```cpp
void dfs(int a,int b,int c,int d){
    if(b+d > n) return;
    dfs(a,b,a+c,b+d);     // 左子树
    printf("%d/%d\n",a+c,b+d);
    dfs(a+c,b+d,c,d);     // 右子树
}
```

---

#### 3. [weak_ddb] 交叉相乘排序（★★★★☆）
**核心亮点**：  
- 避免浮点精度问题，使用交叉相乘比较大小  
- 结构体存储分数，代码清晰易读  
**关键技巧**：  
```cpp
bool cmp(fs a, fs b) { 
    return a.fz*b.fm < b.fz*a.fm; 
} // 避免除法运算
```

---

### 最优思路总结
**Stern-Brocot分治法**为最优解，其核心思想：  
1. 初始区间(0/1, 1/1)  
2. 生成中间分数：(a+c)/(b+d)  
3. 递归处理左右子区间  
4. 天然保证有序性和最简性  

### 拓展练习推荐
1. P1325 雷达安装（区间有序处理）  
2. P1495 曹冲养猪（中国剩余定理，有序构造）  
3. P1757 通天之分组背包（分治思想应用）  

### 关键调试经验
1. **浮点精度问题**：多位题解作者提到使用交叉相乘代替浮点比较（如weak_ddb）  
2. **边界处理**：分治法需注意分母超过n时的剪枝条件（如浮尘ii的`if(l2 + r2 <= N)`）  
3. **互质判断**：多数题解采用gcd==1判断，但需注意0的特殊处理（如0/1的单独输出）

---
处理用时：52.24秒
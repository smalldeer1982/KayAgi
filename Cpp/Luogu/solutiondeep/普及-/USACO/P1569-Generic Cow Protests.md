# 题目信息

# Generic Cow Protests

## 题目描述

约翰家的 $n$ 头奶牛聚集在一起，排成一列，正在进行一项抗议活动。第 $i$ 头奶牛的理智度为 $a_i$。  
约翰希望奶牛在抗议时保持理性，为此，他打算将所有的奶牛隔离成若干个小组，每个小组内的奶牛的理智度总和都要不小于零。  
由于奶牛是按直线排列的，所以一个小组内的奶牛位置必须是连续的。请帮助约翰计算一下，最多分成几组。


## 说明/提示

【数据规模和约定】   
对于 $30\%$ 的数据，$1\le n \le 20$；   
对于 $100\%$ 的数据，$1\le n \le 1000$，$|a_i| \le 10^5$。  


## 样例 #1

### 输入

```
4
2
3
-3
1
```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
题目核心为动态规划结合前缀和。所有题解均基于以下思路：  
1. **前缀和预处理**：快速计算区间和  
2. **动态规划状态定义**：`dp[i]`表示前i头牛的最大分组数  
3. **转移条件**：`sum[i]-sum[j]>=0`时，`dp[i]=max(dp[i], dp[j]+1)`  
4. **无解判断**：全局前缀和`sum[n]<0`时直接输出无解  

优化点集中在如何快速找到合法的`j`，部分题解尝试线段树/分块优化，但对本题数据规模（n≤1e3）必要性不大，O(n²)即可通过。

---

### 高评分题解推荐

#### 1. 作者：ShineEternal（⭐️⭐️⭐️⭐️）
**关键亮点**：  
- 逻辑清晰，代码简洁，适合快速理解核心思路  
- 显式处理无解条件，初始化保底分组  
- 代码可读性强，无冗余操作  

**核心代码**：
```cpp
int d[1001], f[1001]; // d为前缀和，f为dp数组
for (int i=1; i<=n; i++) {
    for (int j=1; j<i; j++) {
        if (f[j]>0 && d[i]-d[j]>=0)
            f[i] = fmax(f[i], f[j]+1);
    }
}
```

#### 2. 作者：Lips（⭐️⭐️⭐️⭐️）
**关键亮点**：  
- 代码极简，直接体现状态转移核心逻辑  
- 利用前缀和快速判断区间合法性  
- 预处理全局无解条件，避免无效计算  

**核心代码**：
```cpp
for (int i=1; i<=n; i++)
    if (sum[i]>=0) 
        for (int j=0; j<i; j++) 
            if (sum[i]-sum[j]>=0) 
                dp[i] = max(dp[j]+1, dp[i]);
```

#### 3. 作者：asuldb（⭐️⭐️⭐️⭐️）  
**关键亮点**：  
- 创新性引入线段树优化，时间复杂度降至O(n log n)  
- 离散化前缀和，解决值域较大问题  
- 提供优化思路，适用于更大规模数据  

**核心思路**：将前缀和离散化后，用线段树维护`dp[j]`最大值，快速查询满足`sum[i]≥sum[j]`的最优解。

---

### 关键技巧总结
1. **前缀和与DP结合**：区间和问题优先考虑前缀和预处理  
2. **状态转移剪枝**：仅当`sum[i]≥sum[j]`时进行转移  
3. **无解快速判断**：全局和负则直接无解  
4. **初始化优化**：`sum[i]≥0`时初始化为1组  

---

### 类似题目推荐
1. **P1115 最大子段和**（前缀和/贪心）  
2. **P1387 最大正方形**（二维前缀和+DP）  
3. **P1508 Likecloud-吃、吃、吃**（路径DP+前缀和思想）  

---

### 题解个人心得摘录
- **ShineEternal**：强调保底初始化（`f[i]=1`）的重要性，确保至少可分一组  
- **ATZdhjeb**：通过标记非法状态（`dp[i]=-1`）减少无效计算，优化实际运行效率  
- **asuldb**：调试时发现离散化需处理相等值，避免线段树查询错误  

总结：动态规划的初始化与状态合法性判断是本题关键，优化需结合具体数据规模。

---
处理用时：61.45秒
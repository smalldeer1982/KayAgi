# 题目信息

# 结算日

## 题目背景

借债还债


## 题目描述

“不放债不借债”，贝西多么希望自己可以遵循这个忠告。她已经和她的 $N(1 \leq N \leq 100,000)$ 个朋友有了债务关系，或者借债了，或者放债了。她的 $N$ 个朋友依次标号为 $1\dots N$。 结算日终于来临了。她知道，朋友欠她的钱比她欠朋友的钱多。她的朋友们分布在一条直线上，第 $i$ 头奶牛站的位置距离谷仓 $i$ 米。贝西打算沿着这条直线行走，从欠她钱的奶牛手里收钱回来，并且还钱给她欠钱的奶牛。 当她沿直线移动的时候，她可以要求任何欠她钱的奶牛还全部的钱。当她有足够的钱可以还清她的某个债，就可以把钱给对应的奶牛还清她的债。奶牛 $i$ 欠贝西 $D_i$ 元 $(-1,000 \leq D_i \leq 1,000,D_i \neq 0)$，负数表示贝西欠奶牛 $i$ 钱。 贝西从谷仓出发，位置为 $0$，初始贝西没有钱。贝西收回她的所有借债，并且还清她的欠债所需行走的最短距离是多少？注意：她必须在最后一头奶牛所在的位置，完成她的行走。


## 说明/提示

输入解释：

$3$ 头奶牛欠贝西钱；她欠 $2$ 头奶牛钱。当她完成结算，她将有 $150$ 元。

输出解释：

```cpp
谷仓  100  -200  250 -200  200
 |     |     |    |    |    |
 ***>**+**>*****>**+
                   *            < 贝西有 350元
             -**<***
             *                  < 贝西有 150元
             ***>****>****>**+
                             *  < 贝西有 350
                       -**<***
                       *     
                       ***>***  < 贝西结束她的行走，有 150元
```

## 样例 #1

### 输入

```
5
100
-200
250
-200
200```

### 输出

```
9

```

# AI分析结果



### 综合分析与结论
本题的核心是贪心策略：贝西在当前位置能偿还所有累积债务时立即折返，避免后续更长的回头路。各题解均采用此思路，通过维护当前资金状态动态计算往返距离，时间复杂度为 O(n)。关键优化点在于及时处理债务以减少总路程。

---

### 精选题解与评分

#### 题解1：封禁用户（5星）
**关键亮点**：代码简洁高效，逻辑清晰，变量命名合理。通过 `flag` 和 `l` 准确记录债务区间起点，动态计算往返距离。
```cpp
#include<iostream>
using namespace std;
int n,x,sum,ans,l;
bool flag;
int main() {
    cin>>n;
    for (int i=1;i<=n;i++) {
        cin>>x;
        sum += x;
        ans++; // 向前走1米
        if (sum >= 0 && flag) {
            ans += (i - l) * 2; // 往返距离
            flag = 0;
        }
        if (sum < 0 && !flag) {
            flag = 1;
            l = i; // 记录债务起点
        }
    }
    cout << ans;
}
```

#### 题解2：Real_Create（5星）
**关键亮点**：极致简洁，13行代码实现核心逻辑。通过 `jl` 统计债务区间长度，巧妙利用 `jl*2` 计算总往返距离。
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int q=0,jl=0,t,ans=0,n;
    cin>>n;
    for(int i=0;i<n;i++) {
        cin>>t;
        q += t;
        jl += (q<0); // 统计债务区间长度
        if(q>=0) {
            ans += jl*2; // 累加往返距离
            jl=0;
        }
    }
    cout<<ans+n; // 基础距离n米
}
```

#### 题解3：greenheadstrange（4星）
**关键亮点**：逻辑明确，注释详细，适合理解思路。通过 `bj` 标记债务起点，与题解1类似。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int n,sum=0,ans=0,bj=0,x;
    scanf("%d",&n);
    ans = n; // 基础距离为n
    for(int i=1;i<=n;i++) {
        scanf("%d",&x);
        sum += x;
        if(sum >=0 && bj) {
            ans += (i-bj)*2; // 往返处理
            bj = 0;
        }
        if(sum <0 && !bj) bj = i; // 记录起点
    }
    printf("%d",ans);
}
```

---

### 关键思路与技巧
1. **贪心策略**：及时处理债务，避免后续更长的回头路。
2. **状态维护**：用变量记录当前资金总和 (`sum`) 和债务区间起点 (`l` 或 `bj`)。
3. **距离计算**：在能偿还时，直接累加 `(终点-起点)*2` 的往返距离。
4. **代码优化**：合并状态判断与距离计算，减少分支判断。

---

### 拓展与相似题目
1. **区间调度问题**：如 [P1803 线段覆盖](https://www.luogu.com.cn/problem/P1803)，需选择不重叠区间。
2. **贪心+路径计算**：如 [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)，组合物品减少次数。
3. **动态维护状态**：如 [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)，通过贪心减少操作次数。

---
处理用时：147.18秒
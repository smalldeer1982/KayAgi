# 题目信息

# 迷宫

## 题目描述

给定一个 $N \times M$ 方格的迷宫，迷宫里有 $T$ 处障碍，障碍处不可通过。

在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。

给定起点坐标和终点坐标，每个方格最多经过一次，问有多少种从起点坐标到终点坐标的方案。

## 说明/提示

对于 $100\%$ 的数据，$1 \le N,M \le 5$，$1 \le T \le 10$，$1 \le SX,FX \le n$，$1 \le SY,FY \le m$。

## 样例 #1

### 输入

```
2 2 1
1 1 2 2
1 2
```

### 输出

```
1```

# AI分析结果



### 综合分析与结论
各题解均采用DFS+回溯算法，核心思路相似但实现细节存在差异。关键优化点包括：方向数组简化分支判断、双重标记（障碍与访问状态）、终点障碍预处理等。部分题解因未处理起点初始标记或终点障碍导致得分不全，需特别注意边界条件。

---

### 高星题解推荐

#### 1. ybb756032937（5星）
**核心亮点**：
- 使用方向数组替代多重if分支，提升代码简洁性
- 分离障碍标记与访问标记，逻辑清晰
- 包含完整的DFS模板与调试经验分享

**个人心得**：
> "注意：在map数组上打标记可能混淆障碍与路径，建议使用独立访问数组"

**关键代码**：
```cpp
int dx[4]={0,0,1,-1}, dy[4]={-1,1,0,0}; // 方向数组

void walk(int x,int y) {
    if(x==fx&&y==fy) { total++; return; }
    for(int i=0;i<4;i++) { // 遍历四个方向
        int nx = x+dx[i], ny = y+dy[i];
        if(!temp[nx][ny] && map[nx][ny]) {
            temp[x][y] = 1;
            walk(nx, ny);
            temp[x][y] = 0; // 回溯
        }
    }
}
```

#### 2. Billy●Herrington（4星）
**核心亮点**：
- 强调起点初始标记的重要性
- 提供错误案例分析（40分→AC的修正过程）

**调试教训**：
> "起点未标记会导致重复计数，需在DFS前设置 visited[sx][sy]=true"

**代码片段**：
```cpp
G[sx][sy] = true; // 关键！初始标记起点
dfs(sx, sy);
```

#### 3. Error_Eric（4星）
**核心亮点**：
- 独立判断函数提升可读性
- 显式处理终点障碍的特殊情况

**关键逻辑**：
```cpp
bool judge(int x,int y) {
    return x>=1 && x<=n && y>=1 && y<=m 
        && !vis[x][y] && !map[x][y];
}

if(map[fx][fy]) { // 终点障碍预判
    cout << 0; return 0; 
}
```

---

### 关键技巧总结
1. **方向数组**：用dx/dy数组统一处理移动，避免重复代码
2. **双重标记系统**：独立存储障碍状态（永久）与访问状态（临时）
3. **起点终点预处理**：初始标记起点，终点障碍直接返回0
4. **回溯规范**：每次递归后必须恢复访问状态

---

### 拓展练习
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - DFS经典问题
2. [P1506 拯救oibh总部](https://www.luogu.com.cn/problem/P1506) - 连通块计数
3. [P2392 考前临时抱佛脚](https://www.luogu.com.cn/problem/P2392) - 状态回溯应用

---

### 同类问题特征
当出现以下特征时可考虑DFS+回溯：
- 数据规模较小（n≤20）
- 需遍历所有可能路径
- 状态可逆（如网格访问标记）
- 求路径计数而非最短路径

---
处理用时：57.88秒
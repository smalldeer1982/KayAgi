# 题目信息

# [USACO05FEB] Aggressive cows G

## 题目描述

农夫约翰建造了一座有 $n$ 间牛舍的小屋，牛舍排在一条直线上，第 $i$ 间牛舍在 $x_i$ 的位置，但是约翰的 $m$ 头牛对小屋很不满意，因此经常互相攻击。约翰为了防止牛之间互相伤害，因此决定把每头牛都放在离其它牛尽可能远的牛舍。也就是要最大化最近的两头牛之间的距离。

牛们并不喜欢这种布局，而且几头牛放在一个隔间里，它们就要发生争斗。为了不让牛互相伤害。约翰决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是多少呢？

## 说明/提示

【样例解析】把牛放在 $1$，$4$，$8$ 这三个位置，距离是 $3$。容易证明最小距离已经最大。

【数据范围】对于 $100\%$ 的数据，$2 \le n \le 10^5$，$0 \le x_i \le 10^9$，$2 \le m \le n$。不保证 $x$ 数组单调递增。


## 样例 #1

### 输入

```
5 3
1 2 8 4 9```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题为典型的二分答案问题，目标是在满足放置m头牛的前提下最大化最小间距。各题解均采用二分法，关键差异在于check函数的实现方式。正确方法需排序后贪心验证，确保每次放置尽可能靠左以最大化数量。部分题解存在数组越界等实现错误，需谨慎选择。

---

### 精选题解（评分≥4星）

#### 1. 作者：Pink_Cut_Tree ⭐⭐⭐⭐⭐  
**关键亮点**  
- 思路清晰，明确二分答案适用条件及贪心验证方法  
- 代码规范，预处理排序，避免指针越界  
- 优化技巧：位运算加速mid计算  

**核心代码**  
```cpp
bool check(int x){
    int num=1, lasth=pl[1]; 
    for(int i=2; i<=n; i++){
        if(pl[i] - lasth >= x){ 
            lasth = pl[i];
            num++;
        }
    } 
    return num >= m; 
}
```

#### 2. 作者：dby_718 ⭐⭐⭐⭐  
**关键亮点**  
- 代码简洁，逻辑紧凑  
- 正确预处理排序，避免数组越界  
- 双指针优化遍历过程  

**核心代码**  
```cpp
bool check(int dis){
    int res = 1, pre = 1;
    for(int i=2; i<=n; i++)
        if(a[i] - a[pre] >= dis)
            res++, pre = i;
    return res >= c;
}
```

#### 3. 作者：eggegg185 ⭐⭐⭐⭐  
**关键亮点**  
- 变量命名直观，代码易读  
- 明确初始条件（首个牛舍必选）  
- 正确性验证通过连续位置差比较  

**核心代码**  
```cpp
bool check(int q) {
    int can = 1, plc = x[1];
    for(int i=2; i <=n; i++) {
        if(x[i]-plc >= q) 
            plc = x[i], can++;
    }
    return can >= m;
}
```

---

### 关键思路与技巧总结
1. **二分框架**：确定答案范围（如0到1e9），通过`check(mid)`调整左右边界。
2. **贪心验证**：排序后，从首个牛舍开始，每次选择满足最小距离的最左侧位置。
3. **预处理排序**：必须对牛舍坐标排序，确保后续计算正确性。
4. **优化实现**：用`lasth`变量记录最后放置位置，避免重复计算距离。

---

### 扩展与举一反三
1. **同类问题**：  
   - [P1824 进击的奶牛](https://www.luogu.com.cn/problem/P1824)（双倍经验）  
   - [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（最小化最大跳跃距离）  
   - [P1316 丢瓶盖](https://www.luogu.com.cn/problem/P1316)（类似贪心验证）  

2. **调试心得**：  
   - 确保排序正确，避免因未排序导致距离计算错误。  
   - 初始放置第一个牛舍，否则无法保证最优解。  
   - 验证二分边界，如`r`初始值应足够大（如1e9+1）。  

---

### 重点代码片段
```cpp
// 二分主框架
int l=0, r=1e9, ans;
while(l <= r){
    int mid = l + (r - l)/2;
    if(check(mid)){
        ans = mid;
        l = mid +1;
    } else {
        r = mid -1;
    }
}
cout << ans;
```

---
处理用时：156.35秒
# 题目信息

# [USACO19FEB] Sleepy Cow Herding B

## 题目描述

Farmer John 的三头获奖奶牛 Bessie、Elsie 和 Mildred，总是会迷路走到农场上遥远的地方去！他需要你帮助将她们一起赶回来。

农场的草地大体是一块狭长的区域——我们可以将其想象成一条数轴，奶牛可以占据数轴上的任意整数位置。这 $3$ 头奶牛现在正位于不同的整数位置，Farmer John 想要移动她们，使得她们占据三个相邻的位置（例如，位置 $6$、$7$、$8$）。

不幸的是，奶牛们现在很困，Farmer John 要让她们集中精力听从命令移动并不容易。任意时刻，他只能使得一头处在“端点”（在所有奶牛中位置最小或最大）位置的奶牛移动。当他移动奶牛时，他可以命令她走到任意一个未被占用的整数位置，只要在新的位置上她不再是一个端点。可以看到随着时间的推移，这样的移动可以使奶牛们趋向越来越近。

请求出使得奶牛们集中到相邻位置所进行的移动次数的最小和最大可能值。 

## 说明/提示

### 样例解释 1

最小移动次数为 $1$——如果 Farmer John 将位置 $4$ 的奶牛移动到位置 $8$，那么奶牛们就处在连续的位置 $7$、$8$、$9$。最大移动次数为 $2$。例如，位置 $9$ 的奶牛可以被移动到位置 $6$，然后位置 $7$ 的奶牛可以被移动到位置 $5$。

## 样例 #1

### 输入

```
4 7 9```

### 输出

```
1
2```

# AI分析结果



### 综合分析与结论
本题核心在于通过排序后分析间距确定最小/最大移动次数。所有题解均采用以下思路：
- **最小值**：分三种情况判断（已连续为0、存在间距为2则为1、否则为2）
- **最大值**：相邻最大间距减一（每次操作只能缩短最大间隔）

关键技巧：排序简化判断，利用间距差直接推导结果，避免复杂模拟。

---

### 精选题解与评分

#### 1. 作者：cff_0102 （5星）
**关键亮点**：
- 思路最简洁清晰，直接通过排序后间距判断所有情况
- 代码极简且高度可读（仅6行核心逻辑）
- 正确性验证充分，数学推导严谨

**代码核心**：
```python
a,b,c=sorted(list(map(int,input().split())))
print(0 if c - a == 2 else (1 if c - b == 2 or b - a == 2 else 2))
print(max(b - a , c - b) - 1)
```

#### 2. 作者：RockyQ012 （4星）
**关键亮点**：
- 模块化函数设计提高代码可维护性
- 通过多次swap实现手动排序，适合理解排序本质
- 输出逻辑与问题条件严格对应

**核心判断逻辑**：
```cpp
if(c - b == 2 || b - a == 2) cout << 1;
else cout << 2;
cout << max(c-b, b-a)-1;
```

#### 3. 作者：Silent1019 （4星）
**关键亮点**：
- 采用最精简的条件判断结构
- 使用绝对值简化代码，增强普适性
- 代码注释明确关键步骤

**代码亮点**：
```cpp
if(b-a==1 && c-b==1) printf("0\n");
else if(b-a==2||c-b==2) printf("1\n");
else printf("2\n");
printf("%d\n",max(b-a,c-b)-1);
```

---

### 关键思路总结
1. **排序定序**：将三个数排序为a≤b≤c，简化后续判断。
2. **最小值推导**：
   - 已连续 → 0次
   - 存在间距为2 → 1次（将第三个数插入）
   - 其他情况 → 2次（先构造间距为2的情况）
3. **最大值推导**：每次操作只能减少最大间隔，故总次数为max(b-a, c-b)-1

---

### 拓展建议
1. **同类题目推荐**：
   - P1209 [USACO1.3]修理牛棚 Barn Repair（间隔分析）
   - P2695 骑士的工作（贪心+排序）
   - P4995 跳跳！（最大最小交替跳跃）
2. **思维拓展**：当问题扩展到n头牛时，可转化为区间覆盖问题，需结合贪心或动态规划。

---

### 个人心得摘录
> "最大值是max(b-a, c-b)-1，因为每次只能缩进最大间隔的端点" —— cff_0102  
> **启示**：通过观察操作对间隔的直接影响，避免陷入模拟操作的复杂计算。

---
处理用时：63.25秒
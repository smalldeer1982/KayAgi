# 题目信息

# [USACO19FEB] Measuring Traffic B

## 题目描述

Farmer John 的农场边上的高速公路最近出现了引人注目的流量上升，或者至少 Farmer John 看起来是这样的。为了证实这件事，他打算用一组传感器测量公路上的车流量，每个传感器被用来测量一小段路面上的车流量的数值。

不幸的是，某一天经过牛棚的时候，Farmer John 被绊倒了，装有传感器的盒子掉进了一个巨大的奶缸，之后它们就不能正常工作了。比起之前可以产生一个精确的车流量读数，现在每个传感器只能输出一个可能结果的范围。例如，一个传感器可能会给出范围 $[7,13]$，表示在这段路面上的车流量不小于 $7$，并且不大于 $13$。

高速公路经过农场的这一段长 $N$ 英里，车辆仅从一个方向通过公路，从第 $1$ 英里驶向第 $N$ 英里。Farmer John 想要安装 $N$ 个传感器——每一个监测高速公路上 $1$ 英里长的路段。在其中某些路段上，有能够使得车辆进入高速公路的上匝道；在所有这样的路段上，Farmer John 会将传感器装在上匝道上，测量流入的（近似）车流量。在某些路段上有能够使得车辆离开高速公路的下匝道；在所有这样的路段上，Farmer John 会将传感器装在下匝道上。每一个路段包含至多一个匝道。如果在公路的一个路段上没有上匝道或下匝道，Farmer John就将传感器装在高速公路的主路上。

给定 Farmer John 的 $N$ 个传感器的读数，请求出在高速公路第 $1$ 英里之前和第 $N$ 英里之后车流量的最为准确的可能范围。这些范围应当与所有 $N$ 个传感器的读数相一致。 

## 说明/提示

### 样例解释 1

在这个例子中，路段 $2$ 和路段 $3$ 的读数组合在一起告诉我们通过这两个路段的车流量为范围 $[11,14]$ 之间的某个值，因为只有这个范围与两个读数 $[10,14]$ 和 $[11,15]$ 均一致。在第 $1$ 英里，恰有 $1$ 单位的车辆通过上匝道进入，所以在第 $1$ 英里之前，车流量一定在范围 $[10,13]$ 之内。在第 $4$ 英里，$2$ 单位到 $3$ 单位之间的车辆通过下匝道离开，所以这段路之后可能的车流量范围为 $[8,12]$。 

## 样例 #1

### 输入

```
4
on 1 1
none 10 14
none 11 15
off 2 3```

### 输出

```
10 13
8 12```

# AI分析结果



### 综合分析与结论
本题核心在于通过正反两次遍历维护流量区间范围，处理三种操作类型（on/off/none）对区间的叠加或裁剪。各题解均采用维护最小最大值的方法，但细节处理（初始值设定、操作转换逻辑、区间边界处理）存在差异。最优思路是：正向推导终点范围，反向推导起点范围，通过反转操作逻辑处理反向遍历，并始终保证区间非负。

---

### 高星题解推荐

#### 1. 作者：PR_CYJ（★★★★★）
**关键亮点**  
- 清晰的变量命名与逻辑分层（minn/maxx分别维护区间）
- 显式处理负数边界（每次操作后取 max(0)）
- 正向与反向遍历的对称逻辑处理
- 代码注释完善，可读性极佳

**核心代码实现**  
```cpp
// 反向遍历求起点范围
for(int i=n;i>=1;i--) {
    if (op[i]==1) { // on转off
        minn -= uw[i]; maxx -= dw[i];
        minn = max(minn,0); maxx = max(maxx,0);
    } else if (op[i]==2) { // none保持
        minn = max(minn,dw[i]);
        maxx = min(maxx,uw[i]);
    } else { // off转on
        minn += dw[i]; maxx += uw[i];
    }
}
```

#### 2. 作者：lflby（★★★★☆）
**关键亮点**  
- 极简代码风格，直接操作区间变量
- 使用极大值(2e9)初始化，减少边界判断
- 对称处理正反遍历逻辑，逻辑高度复用

**代码亮点**  
```cpp
// 反向遍历处理
for (int i = n; i >= 1; i--) {
    if (a[i].zr=="none") 
        l=max(l,a[i].l), r=min(r,a[i].r);
    else if (a[i].zr=="off") // off转为增加
        l+=a[i].l, r+=a[i].r;
    else // on转为减少
        l-=a[i].r, r-=a[i].l;
    l=max(l,0); r=max(r,0);
}
```

#### 3. 作者：guaidaokenan（★★★★☆）
**关键亮点**  
- 使用结构体存储操作，增强可扩展性
- 显式说明变量初始化为-1与2e9的数学意义
- 注释明确分类处理逻辑

**个人心得**  
> "注意l和r可能小于0，必须与0取最大值" —— 强调区间非负的关键约束

---

### 关键思路总结
1. **双向遍历**：  
   - 正向遍历（1→N）推导终点后范围
   - 反向遍历（N→1）推导起点前范围，需反转on/off操作逻辑

2. **区间维护技巧**：  
   - on操作：正向时加区间，反向时减区间  
     `minn += dw[i]; maxx += uw[i]` → `minn -= uw[i]; maxx -= dw[i]`
   - off操作：正向时减区间，反向时加区间  
     `minn -= uw[i]; maxx -= dw[i]` → `minn += dw[i]; maxx += uw[i]`
   - none操作：取区间交集  
     `minn = max(当前minn, 限制min), maxx = min(当前maxx, 限制max)`

3. **边界控制**：  
   - 初始范围设为极大区间（如[0,1e9]）
   - 每次操作后强制`minn = max(minn,0)`

---

### 拓展与相似题目
1. **区间叠加问题**  
   - 推荐题目：P2586 [ZJOI2008]瞭望塔（区间极值维护）
   - 推荐题目：P1985 [USACO07OPEN]翻转棋（状态叠加与逆向推导）

2. **操作反转思维**  
   - 推荐题目：P1514 [NOIP2010 提高组] 引水入城（逆向推导覆盖范围）

3. **动态范围维护**  
   - 推荐题目：P2149 [SDOI2009]Elaxia的路线（多维度区间约束）

---
处理用时：63.74秒
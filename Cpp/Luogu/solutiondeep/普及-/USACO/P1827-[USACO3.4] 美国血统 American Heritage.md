# 题目信息

# [USACO3.4] 美国血统 American Heritage

## 题目描述

农夫约翰非常认真地对待他的奶牛们的血统。然而他不是一个真正优秀的记帐员。他把他的奶牛 们的家谱作成二叉树，并且把二叉树以更线性的“树的中序遍历”和“树的前序遍历”的符号加以记录而 不是用图形的方法。

你的任务是在被给予奶牛家谱的“树中序遍历”和“树前序遍历”的符号后，创建奶牛家谱的“树的 后序遍历”的符号。每一头奶牛的姓名被译为一个唯一的字母。（你可能已经知道你可以在知道树的两 种遍历以后可以经常地重建这棵树。）显然，这里的树不会有多于 $26$ 个的顶点。

这是在样例输入和样例输出中的树的图形表达方式：


```plain
　　　　　　　　 C
　　　　　　   /  \
　　　　　　  /　　\
　　　　　　 B　　  G
　　　　　　/ \　　/
　　　　   A   D  H
　　　　　　  / \
　　　　　　 E   F

```

附注：

- 树的中序遍历是按照左子树，根，右子树的顺序访问节点；
- 树的前序遍历是按照根，左子树，右子树的顺序访问节点；
- 树的后序遍历是按照左子树，右子树，根的顺序访问节点。


## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 3.4


## 样例 #1

### 输入

```
ABEDFCHG
CBADEFGH 
```

### 输出

```
AEFDBHGC```

# AI分析结果



### 综合分析与结论
本题核心是通过前序和中序遍历重建二叉树并输出后序遍历。所有题解均基于递归分治思想，核心差异在于切割方式（字符串切割/索引范围）、是否显式建树、参数传递方式等。最优解法应避免显式建树，直接通过递归确定子树范围，时间复杂度为 O(n)。

---

### 高星题解推荐

#### 1. Diamiko（4.5星）
**关键亮点**：
- 字符串切割思路清晰，利用`substr`和`find`实现直观的分割
- 代码简洁，仅20行核心逻辑
- 详细图解说明切割规律，适合新手理解递归过程

**个人心得**：
> "前序序列的第一个节点一定是根节点，递归切割字符串即可，无需显式建树"

**核心代码**：
```cpp
void work(string pre, string inor) {
    if (pre.empty()) return;
    char root = pre[0];
    int k = inor.find(root);
    pre.erase(pre.begin());
    work(pre.substr(0, k), inor.substr(0, k)); // 左子树
    work(pre.substr(k), inor.substr(k+1));     // 右子树
    printf("%c", root);
}
```

#### 2. Bartholomew（4星）
**关键亮点**：
- 使用索引范围代替字符串切割，减少内存拷贝
- 参数仅传递区间边界，时空效率更优
- 代码极简（11行核心逻辑）

**核心代码**：
```cpp
void houxu(int x, int y, int p, int q) {
    if (x > y) return;
    int i = b.find(a[x]);
    houxu(x+1, x+i-p, p, i-1);   // 左子树范围计算
    houxu(x+i-p+1, y, i+1, q);   // 右子树范围计算
    cout << a[x];
}
```

#### 3. jzqjzq（4星）
**关键亮点**：
- 双指针区间递归，逻辑紧凑
- 直接在循环中查找根节点位置，避免额外函数调用
- 极简实现（9行核心逻辑）

**核心代码**：
```cpp
void dfs(int l1, int l2, int l3, int l4) {
    if (l1 > l2) return;
    for (int i = l1; i <= l2; i++)
        if (a[i] == b[l3]) {
            dfs(l1, i-1, l3+1, l3+i-l1);
            dfs(i+1, l2, l3+i-l1+1, l4);
            cout << a[i];
        }
}
```

---

### 关键思路总结
1. **递归分治**：前序首元素为根，中序定位后分割左右子树
2. **空间优化**：使用索引区间而非字符串切割（减少 substr 调用）
3. **后序输出时机**：在左右子树递归完成后输出根节点
4. **终止条件**：当子树区间非法（start > end）时返回

---

### 拓展建议
**同类题目**：
1. [P1030 求先序排列](https://www.luogu.com.cn/problem/P1030)（中序+后序→前序）
2. [P1719 寻找宝藏](https://www.luogu.com.cn/problem/P1719)（带权值的树重建）
3. [P1229 遍历问题](https://www.luogu.com.cn/problem/P1229)（空节点标记的遍历）

**思维延伸**：
- 尝试非递归实现（栈模拟）
- 处理特殊树型（如完全二叉树时优化区间计算）
- 结合层序遍历进行多遍历组合重建

---

### 题解中的调试经验摘录
> "RE几次后发现未处理空子树边界条件" —— emiermao  
> **启示**：递归必须明确终止条件，尤其注意切割后字符串可能为空

> "参数顺序反了导致WA" —— Warriors_Cat  
> **启示**：仔细验证输入顺序是否与题目描述一致

> "建树时未初始化左右指针导致野指针" —— Alarm5854  
> **启示**：结构体/指针操作务必初始化成员变量

---
处理用时：49.35秒
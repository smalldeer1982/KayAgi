# 题目信息

# [USACO09OCT] Bessie's Weight Problem G

## 题目描述

Bessie 像她的诸多姊妹一样，因为从 Farmer John 的草地吃了太多美味的草而长出了太多的赘肉。所以 FJ 将她置于一个及其严格的节食计划之中。她每天不能吃多过 $H (5 \le H \le 45,000)$ 公斤的干草。 Bessie 只能吃一整捆干草；当她开始吃一捆干草的之后就再也停不下来了。她有一个完整的$N (1 \le N \le 500)$ 捆可以给她当作晚餐的干草的清单。她自然想要尽量吃到更多的干草。很自然地，每捆干草只能被吃一次（即使在列表中相同的重量可能出现2次，但是这表示的是两捆干草，其中每捆干草最多只能被吃掉一次）。 给定一个列表表示每捆干草的重量 $S_i (1 \le S_i \le H)$ , 求 Bessie 不超过节食的限制的前提下可以吃掉多少干草（注意一旦她开始吃一捆干草就会把那一捆干草全部吃完）。

## 说明/提示

#### 输入说明

有四捆草，重量分别是 $15,19,20$ 和 $21$。Bessie 在 $56$ 公斤的限制范围内想要吃多少就可以吃多少。


#### 输出说明

Bessie 可以吃 $3$ 捆干草（重量分别为 $15, 20, 21$）。恰好达到她的 $56$ 公斤的限制。


## 样例 #1

### 输入

```
56 4
15
19
20
21```

### 输出

```
56```

# AI分析结果



### 综合分析与结论
本题本质是01背包变形，核心思路是将干草重量同时视为物品重量和价值。题解中主要呈现两种解法：标准01背包动态规划、可达性标记法（布尔数组/bitset优化）。最优解法为空间优化的一维01背包，时间复杂度O(NH)，空间O(H)。

---

### 精选题解（评分≥4星）

#### 1. 青珹（5星）
**关键亮点**：
- 清晰指出问题与01背包的转换思路（重量即价值）
- 通过代码对比展示问题建模的核心差异
- 代码简洁规范，适合教学理解

**代码核心**：
```cpp
for(int i=1;i<=n;i++) {
    for(int j=m;j>=c[i];j--) {
        f[j] = max(f[j], f[j-c[i]]+w[i]);
    }
}
// 一维数组逆序更新，空间复杂度优化
```

#### 2. fighter_OI（4星）
**关键亮点**：
- 使用bitset优化布尔数组，时空效率更优
- 单行转移式 `t |= t << a[i]` 极简实现状态转移
- 展示高级位运算技巧

**代码核心**：
```cpp
bitset<100000> t;
t[0] = 1;
for(int i=1;i<=n;i++) 
    t |= t << a[i]; // 位运算实现可达状态转移
```

#### 3. 霍士弘（4星）
**关键亮点**：
- 详细推导二维→一维的优化过程
- 强调逆序更新的必要性（防止重复计数）
- 给出二维和一维代码对比

**个人心得**：
> "二维数组在数据大时会空间爆炸，必须用一维优化。逆序更新是关键，正序会变成完全背包"

---

### 关键技巧总结
1. **问题转换**：当目标函数与约束条件同为物品属性时，可视为重量=价值的特殊01背包
2. **空间优化**：一维数组逆序更新法（标准01背包模板）
3. **位运算加速**：用bitset存储可达状态，适用于布尔型状态转移
4. **剪枝优化**：当达到容量上限时直接跳出（如题解中`if(maxn==v) return`）

---

### 相似题目推荐
1. P1048 采药（标准01背包）
2. P1049 装箱问题（同重量=价值模型）
3. P2871 [USACO07DEC]Charm Bracelet G（基础01背包）

---

### 重点心得摘录
1. **青珹**：  
"突然意识到这题重量就是价值，和采药问题完全一致，转化思路后直接套模板"

2. **felixwu**：  
"贪心80分惨痛教训说明必须用动态规划，数据范围是决定性因素"

3. **cheeseYang**：  
"二维数组正向更新会错，必须逆序！这个坑调了半小时才明白" 

4. **moye到碗里来**：  
"调试时发现状态数组开小了，开到45001才过，边界处理要仔细"

---
处理用时：38.56秒
# 题目信息

# [USACO1.3] 号码锁 Combination Lock

## 题目背景

感谢 @[Fond_Dream](https://www.luogu.com.cn/user/321680) 提供五道 USACO 题目的标准题面。

## 题目描述

农夫约翰的奶牛不停地从他的农场中逃出来，导致了很多损害。为了防止它们再逃出来，他买了一只很大的号码锁以防止奶牛们打开牧场的门。

农夫约翰知道他的奶牛很聪明，所以他希望确保它们不会在简单地试了很多不同的号码组合之后就能轻易开锁。锁上有三个转盘，每个上面有数字 $1$ ~ $n$，因为转盘是圆的，所以 $1$ 和 $n$ 是相邻的。有两种能开锁的号码组合，一种是农夫约翰设定的，还有一种“预设”号码组合是锁匠设定的。但是，锁有一定的容错性，所以，在每个转盘上的数字都与一个合法的号码组合中相应的数字相距两个位置以内时，锁也会打开。

比如说，如果农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $4$ , $5$ , $6$ )，在转盘被设定为 ( $1$ , $4$ , $5$)（因为这和农夫约翰的号码组合足够接近）或 ( $2$ , $4$ , $8$ )（因为这和预设号码组合足够接近）时可以打开锁。注意，( $1$ , $5$ , $6$ )并不会打开锁，因为它与任一号码组合都不够接近。

给出农夫约翰的号码组合和预设号码组合，请计算能够开锁的不同的号码组合的数目。号码是有序的，所以 ( $1$ , $2$ , $3$ ) 与 ( $3$ , $2$ , $1$ ) 不同。


## 说明/提示

#### 输入输出样例 1 解释

每个转盘的标号是 $1$ ~ $50$。农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $5$ , $6$ , $7$ )。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 100$，$1 \leq x, y, z, a, b, c \leq n$。

## 样例 #1

### 输入

```
50
1 2 3
5 6 7
```

### 输出

```
249```

# AI分析结果



### 综合分析与结论
本题核心在于处理环形数字范围及两组合的重叠计数。题解主要分为两类：**暴力枚举+去重**与**数学公式推导**。前者适用于小规模数据，后者则通过计算重叠区域实现高效求解。当n≥5时，数学方法显著优于暴力枚举，时间复杂度从O(n³)降至O(1)。

### 精选题解与评分
#### 1. VSEJGFB 的题解（⭐⭐⭐⭐⭐）
**关键亮点**：数学公式推导，时间复杂度O(1)。  
- 利用乘法原理计算各位置的重叠区间数，总答案为250减去重复部分。  
- 处理环形距离时用`min(b-a, a+n-b)`计算最短距离，高效准确。  
- 特判n<5的情况，直接返回n³。  
**核心代码**：
```cpp
int main() {
    // ...输入处理...
    if(n<5) { cout<<n*n*n<<endl; return 0; } 
    int ans=1;
    for(int i=0;i<3;i++) {
        if(a[i]>b[i]) swap(a[i],b[i]);
        int k=min(b[i]-a[i],a[i]+n-b[i]);
        if(k<5) ans*=(5-k); // 重复数量为5-距离
        else ans=0;
    }
    cout<<250-ans<<endl;
}
```

#### 2. Violette 的题解（⭐⭐⭐⭐）
**关键亮点**：预处理所有可能组合，利用三维数组去重。  
- 通过`gg()`函数处理环形数字，确保数值在1~n范围内。  
- 分别生成两种组合的合法范围并标记，最后遍历统计总数。  
**核心代码**：
```cpp
int gg(int m) { 
    if(m>0) return m%n ? m%n : n;
    else return (m%n) + n;
}
// 主函数中预处理：
for(int i=-2;i<=2;i++)
    for(int j=-2;j<=2;j++)
        for(int k=-2;k<=2;k++) {
            flag[gg(a+i)][gg(b+j)][gg(c+k)] = true;
            flag[gg(d+i)][gg(e+j)][gg(f+k)] = true;
        }
// 统计时遍历所有可能组合
```

#### 3. 小白一枚 的题解（⭐⭐⭐⭐）
**关键亮点**：直接枚举两种组合的±2范围，用布尔数组去重。  
- 通过`(i+n)%n`处理负数，简洁高效。  
- 代码直观，适合快速实现。  
**核心代码**：
```cpp
for(int i=a-2; i<=a+2; i++)
    for(int j=b-2; j<=b+2; j++)
        for(int k=c-2; k<=c+2; k++)
            if(!bo[(i+n)%n][(j+n)%n][(k+n)%n]) 
                ans++, bo[...]=true;
// 同理处理预设组合
```

### 关键思路总结
1. **环形处理技巧**：通过取模运算或调整数值将范围映射到1~n。例如，`(x-1+n)%n + 1`确保结果在有效范围内。
2. **数学优化**：当n≥5时，总合法组合数为250，减去两组合的重叠部分（各位置重叠数乘积）。
3. **暴力去重**：使用三维数组或集合存储已访问状态，避免重复计数。

### 拓展与举一反三
- **同类题目**：涉及环形结构的枚举问题（如钟表时间计算）、重叠区间统计（如区间覆盖）。
- **优化思路**：当数据范围较小时，暴力枚举更易实现；数据范围大时需寻找数学规律或公式。

### 推荐习题
1. **P1036 选数**（枚举组合数，避免重复）  
2. **P1618 三连击**（条件判断与数学优化）  
3. **P3392 涂国旗**（暴力枚举+优化）

---
处理用时：77.07秒
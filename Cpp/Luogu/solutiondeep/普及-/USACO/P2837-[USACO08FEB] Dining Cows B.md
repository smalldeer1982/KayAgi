# 题目信息

# [USACO08FEB] Dining Cows B

## 题目描述

为了避免餐厅过分拥挤，FJ 要求奶牛们分 $2$ 批就餐。每天晚饭前，奶牛们都会在餐厅前排队入内，按 FJ 的设想，所有第 $2$ 批就餐的奶牛排在队尾，队伍的前半部分则由设定为第 $1$ 批就餐的奶牛占据。

由于奶牛们不理解 FJ 的安排，晚饭前的排队成了一个大麻烦。 第 $i$ 头奶牛有一张标明她用餐批次 $D_i$ 的卡片。虽然所有 $N$ 头奶牛排成了很整齐的队伍，但谁都看得出来，卡片上的号码是完全杂乱无章的。 在若干次混乱的重新排队后，FJ 找到了一种简单些的方法：奶牛们不动，他沿着队伍从头到尾走一遍，把那些他认为排错队的奶牛卡片上的编号改掉，最终得到一个他想要的每个组中的奶牛都站在一起的队列，例如 $112222$ 或 $111122$。有的时候，FJ 会把整个队列弄得只有 $1$ 组奶牛（比方说，$1111$ 或 $222$）。 

你也晓得，FJ 是个很懒的人。他想知道，如果他想达到目的，那么他最少得改多少头奶牛卡片上的编号。所有奶牛在 FJ 改卡片编号的时候，都不会挪位置。

## 说明/提示

$1 \le N \le 3 \times 10 ^ 4$

## 样例 #1

### 输入

```
7
2
1
1
1
2
2
1```

### 输出

```
2```

## 样例 #2

### 输入

```
5
2
2
1
2
2```

### 输出

```
1```

# AI分析结果



### 综合分析与结论
本题核心在于找到分割点，使前半全为1、后半全为2（或全1/全2），并最小化修改次数。题解主要分为动态规划、贪心、前缀和、最长不下降子序列四类思路。最优解法为贪心与前缀和，二者均达到O(n)时间复杂度，且代码简洁高效。

---

### 精选题解与评分

#### 1. 题解作者：AK_Zero（★★★★★）
**关键亮点**：
- **贪心思想**：通过维护分割线动态调整修改次数，仅需一次遍历。
- **空间优化**：O(1)空间复杂度，仅用变量维护当前代价。
- **代码简洁**：逻辑清晰，核心仅10行代码。

**核心代码**：
```cpp
int main() {
    int n, a[30005], gb = 0, mi = INT_MAX;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        if (a[i] == 1) gb++; // 初始化为全2的代价
    }
    mi = gb;
    for (int i = 1; i <= n; i++) {
        gb += (a[i] == 2) ? 1 : -1; // 分割线移动时的调整
        mi = min(mi, gb);
    }
    cout << mi;
}
```

---

#### 2. 题解作者：AnChun999（★★★★☆）
**关键亮点**：
- **前缀和预处理**：统计每个位置前的2数量和后1数量，快速计算分割代价。
- **直观枚举**：遍历所有可能分割点，取最小值。

**核心代码**：
```cpp
int main() {
    int n, line[30005], ll[30005] = {0}, rr[30005] = {0};
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> line[i];
        ll[i] = ll[i-1] + (line[i] == 1); // 前缀统计1的数量
        rr[i] = rr[i-1] + (line[i] == 2); // 前缀统计2的数量
    }
    int ans = min(ll[n], rr[n]); // 全1或全2的情况
    for (int i = 1; i <= n; i++) {
        ans = min(ans, (ll[n] - ll[i]) + rr[i]); // 分割点为i时的代价
    }
    cout << ans;
}
```

---

#### 3. 题解作者：myfly（★★★★☆）
**关键亮点**：
- **最长不下降子序列**：问题转化为寻找最长合法序列，总长度减序列长度即答案。
- **O(nlogn)优化**：利用`upper_bound`实现高效求解。

**核心代码**：
```cpp
int main() {
    int n, x, len = 0, f[30005] = {0};
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> x;
        if (x >= f[len]) f[++len] = x;
        else *upper_bound(f+1, f+len+1, x) = x;
    }
    cout << n - len; // 总长度减去最长合法序列长度
}
```

---

### 关键思路总结
1. **贪心分割线**（最优）：维护当前分割线左侧全1的修改次数，遍历时动态调整。
2. **前缀和枚举**：预处理前后缀统计值，快速计算各分割点代价。
3. **问题转化**：最长不下降子序列的逆向思维，减少问题转化难度。

---

### 相似题目推荐
1. [P3399 丝绸之路（动态规划）](https://www.luogu.com.cn/problem/P3399)
2. [P2679 子串（前缀和优化DP）](https://www.luogu.com.cn/problem/P2679)
3. [P2782 友好城市（最长不下降子序列）](https://www.luogu.com.cn/problem/P2782)

---

### 题解心得摘录
- **AK_Zero**：通过分割线移动时的动态调整，避免了复杂的预处理，实现“边遍历边计算”。
- **myfly**：“最长不下降子序列”思路源于对问题性质的深刻理解，体现了算法思维的灵活性。
- **AnChun999**：前缀和预处理是解决区间统计问题的通用技巧，值得掌握。

---
处理用时：68.66秒
# 题目信息

# [USACO06OPEN] County Fair Events S

## 题目背景

题目是经过简写保证不改变原有题意的题目。

## 题目描述

FJ 参加活动。 

他想参加尽可能多的 $N$ 个活动，参加完某个之后可以立刻参加下一个。 

给定 FJ 可参加的活动列表、其开始时间 $T$ 和持续时间 $L$ ，求 FJ 可以参加的最大活动数。 

FJ 每个活动都不会提早离开。

## 说明/提示

$1\le T,L\le 10^5$

$1\le N\le 10^4$

## 样例 #1

### 输入

```
7
1 6
8 6
14 5
19 2
1 8
18 3
10 6```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
本题为典型的活动选择问题，核心思路是贪心策略：按结束时间排序后依次选择不冲突的活动。所有题解均围绕这一思路展开，差异主要体现在解释深度、反例分析和代码实现细节。最优解法的关键点在于正确理解贪心选择的正确性（结束时间早的活动为后续留出更多时间）。

---

### 高评分题解推荐
#### 题解1：Diamiko（5星）
**关键亮点**  
① 结合图示详细解释贪心正确性，② 对比不同贪心策略的反例，③ 引用经典线段覆盖问题证明思路。  
**代码核心**  
```cpp
sort(ac+1,ac+n+1,cmp); // 按结束时间排序
int ans=1, r=ac[1].End;
for(int i=2;i<=n;i++) {
    if(r <= ac[i].Start) {
        r = ac[i].End;
        ans++;
    }
}
```

#### 题解2：xrdrsp（4星）
**关键亮点**  
① 系统分析三种贪心策略的正确性，② 提供多个反例帮助理解错误解法。  
**个人心得**  
> "贪心不能随便用，需通过反例和证明确保正确性。画数轴辅助分析是有效方法。"

#### 题解3：_zy_（4星）
**关键亮点**  
① 提供Hack测试数据验证策略，② 代码简洁并附英文变量注释。  
**核心代码**  
```cpp
sort(e+1,e+n+1,cmp); // 按结束时间排序
int now=e[1].end, ans=1;
for(int i=2;i<=n;i++)
    if(e[i].sta >= now) {
        now = e[i].end;
        ans++;
    }
```

---

### 最优关键思路总结
1. **贪心策略**：按活动结束时间升序排序，每次选择最早结束且不与已选活动冲突的活动。
2. **正确性证明**：选择结束早的活动为后续保留更多时间，反证法可证明该策略全局最优。
3. **实现技巧**：用结构体存储活动，预处理结束时间（`T+L`），排序后遍历检查时间冲突。

---

### 拓展与同类题目推荐
1. **P1803 线段覆盖**：经典活动选择问题，解法与本题目完全相同。
2. **P2240 部分背包问题**：贪心选择单位价值最高的物品，需理解不同场景的贪心应用。
3. **P1230 智力大冲浪**：带惩罚的活动调度问题，需结合贪心与优先队列优化。

---
处理用时：35.49秒
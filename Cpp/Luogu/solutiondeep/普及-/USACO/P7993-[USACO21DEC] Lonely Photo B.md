# 题目信息

# [USACO21DEC] Lonely Photo B

## 题目描述

Farmer John 最近购入了 $N$ 头新的奶牛（$3 \le N \le 5 \times 10^5$），每头奶牛的品种是更赛牛（Guernsey）或荷斯坦牛（Holstein）之一。 

奶牛目前排成一排，Farmer John 想要为每个连续不少于三头奶牛的序列拍摄一张照片。 然而，他不想拍摄这样的照片，其中只有一头牛的品种是更赛牛，或者只有一头牛的品种是荷斯坦牛——他认为这头奇特的牛会感到孤立和不自然。 在为每个连续不少于三头奶牛的序列拍摄了一张照片后，他把所有「孤独的」照片，即其中只有一头更赛牛或荷斯坦奶牛的照片，都扔掉了。

给定奶牛的排列方式，请帮助 Farmer John 求出他会扔掉多少张孤独的照片。如果两张照片以不同的奶牛开始或结束，则认为它们是不同的。


## 说明/提示

【样例解释】

这个例子中的每一个长为 3 的子串均恰好包含一头更赛牛或荷斯坦牛——所以这些子串表示孤独的照片，并会被 Farmer John 扔掉。所有更长的子串（GHGH、HGHG 和 GHGHG）都可以被接受。

【数据范围】

- 测试点 2-4 满足 $N \le 50$。
- 测试点 5-10 满足 $N \le 5000$。
- 测试点 11 没有额外限制。

注意这个测试点的答案可能无法用标准的 32 位整数型存储，你可能需要使用更大的整数类型（例如，C++ 中 64 位的 "long long int" 类型）。

## 样例 #1

### 输入

```
5
GHGHG```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题核心在于快速统计所有满足特定条件的子串，常规暴力枚举不可行。各题解核心思路聚焦于 **分块处理** 和 **左右连续字符预处理**，通过数学推导将时间复杂度优化至 O(n)。最优解法通过以下两种方式实现：
1. **分块策略**：将连续相同字符合并，根据块长度分类计算贡献。
2. **位置贡献法**：预处理每个位置的左右连续异种字符数，利用乘法原理求和。

### 高星题解推荐

#### 1. 作者：ynxynx（★★★★★）
**关键亮点**：
- 极简分块策略，将字符串转化为连续块数组。
- 分类讨论块的类型（单字符块/多字符块），用数学公式直接计算贡献。
- 代码简洁高效，时间复杂度 O(n)。

**核心代码**：
```cpp
// 分块处理
a[++cnt]++;
for (int i=1;i<n;i++) {
    if (ch[i]==ch[i-1]) a[cnt]++;
    else a[++cnt]++;
}
// 贡献计算
for (int i=1;i<cnt;i++) {
    if (a[i]==1) ans += a[i-1]*a[i+1] + a[i+1]-1;
    else ans += a[i] + a[i+1]-2;
}
```

#### 2. 作者：徐晨轩（★★★★★）
**关键亮点**：
- 预处理每个位置的左右连续异种字符数（LG/RG/LH/RH）。
- 分三种情况统计贡献：左扩展、右扩展、中间组合。
- 逻辑清晰，适合理解位置贡献模型。

**核心代码**：
```cpp
// 预处理连续字符数组
for(int i=2;i<=n;i++)
    LG[i] = s[i-1]=='G' ? LG[i-1]+1 : 0;
// 贡献计算
ans += LG[i-1] + RG[i+1] + LG[i]*RG[i];
```

### 最优思路总结
1. **分块处理法**：将连续相同字符合并为块，单字符块的贡献来自左右块的组合，多字符块贡献来自相邻块。
2. **位置贡献法**：对每个字符计算其作为孤独字符时，左右可扩展的连续异种字符数，利用乘法原理求和。
3. **关键公式**：
   - 单字符块贡献：`left * right + (right - 1)`
   - 多字符块贡献：`left + right - 2`

### 拓展建议
1. **类似题目**：
   - [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)（连续子段处理）
   - [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（二分+贪心）
   - [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)（差分+前缀和）

2. **个人心得**：
   - **调试技巧**：处理边界时，可用小样例手动模拟分块过程。
   - **易错点**：贡献计算时需排除长度<3的情况（如 `a[i+1]-1` 处理短边）。
   - **优化方向**：避免重复计算，预处理数组时注意初始化和循环方向。

---
处理用时：48.88秒
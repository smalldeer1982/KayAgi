# 题目信息

# [USACO23FEB] Hungry Cow B

## 题目描述

Bessie 是一头饥饿的奶牛。每天晚餐时，如果谷仓中有干草，她会吃掉一捆干草。为了防止 Bessie 挨饿，有些天 Farmer John 会在早晨（晚餐之前）送来一些干草。具体地说，在第 $d_i$ 天，Farmer John 送来了 $b_i$ 捆干草（$1 \leq d_i \leq 10^{14}, 1 \leq b_i \leq 10^9$）。

请计算 Bessie 在前 $T$ 天内共吃掉了多少捆干草。

## 样例 #1

### 输入

```
1 5
1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 5
1 2
5 10```

### 输出

```
3```

## 样例 #3

### 输入

```
2 5
1 10
5 10```

### 输出

```
5```

# AI分析结果



### 综合分析与结论
题目核心在于按时间顺序处理干草送达事件，维护剩余干草数量，计算贝西在不同时间段内的消耗。由于数据范围大，需确保O(n)时间复杂度。正确的解法需满足以下要点：
- 按顺序处理事件，计算相邻事件间的天数差。
- 维护剩余干草数，每次事件前计算消耗。
- 处理最后一段到T天的剩余。

### 高评分题解推荐
#### 1. zhlzt（5星）
**关键亮点**：
- 思路清晰，直接模拟事件间的天数差。
- 维护`sum`（剩余干草）和`ans`（总消耗）变量，逻辑简洁。
- 正确处理最后一段时间的消耗，边界条件处理完善。

**代码核心**：
```cpp
for(long long i=1;i<=n;i++){
    scanf("%lld%lld",&d[i],&b[i]);
    pos=min(sum,d[i]-d[i-1]); // 计算前一段消耗
    sum-=pos, ans+=pos;       // 更新剩余和答案
    sum+=b[i];                // 添加新草
}
printf("%lld",ans+min(sum,t-d[n]+1)); // 处理最后一段
```
**个人心得**：
- 强调最后一段的处理易遗漏，需特别注意边界。

#### 2. ivyjiao（4星）
**关键亮点**：
- 使用`a[n+1] = t`简化最后一段处理。
- 代码简短，通过循环合并事件处理和最终计算。

**代码核心**：
```cpp
a[n+1]=t;
for(int i=1;i<=n;i++){
    cnt += b[i];
    ans += min(a[i+1]-a[i], cnt); // 消耗当前段
    cnt = max(cnt - (a[i+1]-a[i]), 0LL);
}
```

#### 3. Loser_Syx（4星）
**关键亮点**：
- 变量命名直观（如`food`表示剩余干草）。
- 显式分支处理“够吃”与“不够吃”情况，易理解。

**代码核心**：
```cpp
if(food >= d[i] - d[i-1]){ // 够吃
    ans += d[i] - d[i-1];
    food -= d[i] - d[i-1];
} else {                   // 不够吃
    ans += food;
    food = 0;
}
food += b[i]; // 添加新草
```

### 最优思路总结
- **按序处理事件**：事件已按时间排序，逐个处理相邻区间。
- **维护剩余干草**：每次先计算前一段的消耗，再添加新草。
- **边界处理**：特别注意最后一段到T天的计算。

### 拓展与同类题目
- **类似套路题**：
  1. [P1086 花生采摘](https://www.luogu.com.cn/problem/P1086)：时间顺序与资源收集。
  2. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)：区间处理与贪心。
  3. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：状态维护与双指针。

### 个人心得摘录
- **zhlzt**：最后一段处理容易遗漏，需明确`d_n`到T的天数计算。
- **Loser_Syx**：显式分支提升代码可读性，避免逻辑混淆。
- **ivyjiao**：通过设置虚拟终点简化循环逻辑，减少冗余代码。

---
处理用时：175.82秒
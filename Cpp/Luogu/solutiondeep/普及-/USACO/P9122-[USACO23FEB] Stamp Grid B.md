# 题目信息

# [USACO23FEB] Stamp Grid B

## 题目描述

盖章绘画是一幅黑白画，绘制在一个 $N \times N$ 的画布上，其中某些格子被涂黑，而其他格子为空白。它可以用一个 $N \times N$ 的字符数组表示（$1 \leq N \leq 20$）。如果数组的第 $i$ 行第 $j$ 列的值为 `*`，说明该格子被涂黑；如果为 `.`，则说明该格子为空白。

Bessie 想要完成一幅盖章绘画，因此 Farmer John 借给了她一块 $K \times K$（$1 \leq K \leq N$）的盖章，以及一块空的 $N \times N$ 画布。Bessie 可以将盖章顺时针旋转 $90^\circ$，并在画布上的任意位置盖章，只要盖章完全在画布范围内即可。形式化地说，盖章时，Bessie 选择整数 $i,j$，满足 $i \in [1,N-K+1]$ 且 $j \in [1,N-K+1]$；对于每个 $(i',j')$，其中 $1 \leq i',j' \leq K$，画布上的格子 $(i+i'-1,j+j'-1)$ 会被涂黑，如果盖章在 $(i',j')$ 处有墨迹。Bessie 可以在每次盖章之前旋转盖章。一旦画布上的某个格子被涂黑，就会保持涂黑状态。

Farmer John 想知道，Bessie 是否可以用他的盖章完成她想要的盖章绘画。对于每个 $T$（$1 \leq T \leq 100$）个测试用例，帮助 Farmer John 回答这个问题。

## 样例 #1

### 输入

```
4

2
**
*.
1
*

3
.**
.**
***
2
.*
**

3
...
.*.
...
3
.*.
...
...

3
**.
.**
..*
2
.*
*.```

### 输出

```
YES
YES
NO
YES```

# AI分析结果



### 综合分析与结论
题目要求通过旋转、盖章操作在空白画布上生成目标图案。各题解均采用暴力枚举思路，通过预处理印章的四个旋转方向，逐个检查合法盖章位置，最终验证覆盖情况。核心难点在于正确实现旋转逻辑与合法性判断。

---

### 高星题解推荐

#### 题解作者：incra（★★★★★）
**关键亮点**  
- 预处理四方向旋转，代码简洁高效  
- 使用独立数组记录实际覆盖情况，避免污染原数据  
- 模块化函数设计（`rotate`、`work`）提升可读性  

**核心代码片段**  
```cpp
void rotate() {
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= m; j++)
            tmp[j][m - i + 1] = b[i][j];
    memcpy(b, tmp, sizeof(b)); // 更新为旋转后的印章
}
void work(int x, int y) {
    // 检查当前印章是否合法（不覆盖目标空白）
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= m; j++)
            if (a[x+i-1][y+j-1] == '.' && b[i][j] == '*') return;
    // 合法则标记覆盖区域
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= m; j++)
            if (b[i][j] == '*') ans[x+i-1][y+j-1] = '*';
}
```

---

#### 题解作者：chlchl（★★★★☆）
**关键亮点**  
- 显式存储四个旋转后的印章，避免重复计算  
- 通过 `trying` 函数统一处理盖章逻辑，结构清晰  
- 使用布尔数组标记覆盖，内存效率高  

**核心代码片段**  
```cpp
void trying(int a[][N], int x, int y) {
    bool valid = true;
    for (int i = 1; i <= k; i++) {
        for (int j = 1; j <= k; j++) {
            // 目标为空白但印章有黑则非法
            if (a[i][j] && !g[i+x-1][j+y-1]) valid = false;
        }
    }
    if (valid) {
        for (int i = 1; i <= k; i++)
            for (int j = 1; j <= k; j++)
                if (a[i][j]) vis[i+x-1][j+y-1] = 1;
    }
}
```

---

### 关键思路总结
1. **预处理旋转**：将印章顺时针旋转90°三次，得到四个方向的模板。
2. **合法性检查**：对每个位置和旋转后的印章，检查其所有黑色格子在目标中是否为允许的黑色。
3. **覆盖标记**：合法操作后，在辅助数组中标记实际覆盖区域。
4. **最终验证**：比较标记数组与目标图案是否一致。

---

### 拓展与相似题目
1. **旋转矩阵**（P2239）：练习坐标变换与矩阵旋转。
2. **棋盘覆盖**（P1739）：涉及类似覆盖问题的分治策略。
3. **激光炸弹**（P2280）：二维前缀和与区域覆盖的综合应用。

---

### 调试心得摘录
- **多测清空**：多个测试用例时需重置标记数组，否则残留数据导致错误（如Xy_top题解）。
- **旋转方向误解**：需明确旋转的是印章而非画布（ivyjiao题解提到赛时被翻译误导）。
- **贪心策略**：只要合法就盖章，不依赖顺序，简化逻辑（是青白呀题解）。

---
处理用时：79.09秒
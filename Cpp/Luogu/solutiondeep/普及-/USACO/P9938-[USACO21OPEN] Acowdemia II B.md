# 题目信息

# [USACO21OPEN] Acowdemia II B

## 题目描述

Bessie 正在申请计算机科学的研究生，并取得了一所久负盛名的计算机科学实验室的面试通知。然而，为了避免冒犯任何人，Bessie 有意先确定实验室的 $N$ 名现有成员的相对资历（$1\le N\le 100$）。没有两名实验室成员的资历相同，但确定他们的资历深浅可能并不好办。为此，Bessie 将会对实验室的出版物进行调查。

每份出版物均包含一个作者列表，为所有 $N$ 名实验室成员的一个排列。列表按每名实验室成员对这篇文章的贡献降序排列。如果多名研究员的贡献相等，则按字典序排列。由于更有资历的实验室成员负有更多的管理责任，更有资历的研究员从不会比资历较浅的研究员做出更多的贡献。

例如，在一个由资历较浅的学生 Elsie、资历较深的教授 Mildred、以及十分资深的教授 Dean 组成的实验室中，可能存在一篇论文 Elsie-Mildred-Dean，如果他们做出了不等的贡献（也就是说，Elsie 做出的贡献比 Mildred 更多，Mildred 比 Dean 更多）。然而，也有可能存在一篇论文 Elsie-Dean-Mildred，如果 Mildred 和 Dean 做出了相等的贡献，而 Elsie 做出了更多的贡献。

给定实验室的 $K$ 份出版物（$1\le K\le 100$），对于实验室中每对研究员，如果可能的话帮助 Bessie 判断其中谁的资历更深。

## 说明/提示

### 样例解释 1

在这个样例中，单独一份论文 elsie-mildred-dean 并不能提供足够的信息判断 Elsie 比 Mildred 资历更深或更浅。然而，我们可以推断出 Dean 一定比这两名研究员资历更深，从而资历排序为 Elsie<Mildred<Dean 和 Mildred<Elsie<Dean 均是可能的。 

### 样例解释 2

在这个样例中，唯一能与两篇论文相一致的资历排序为 Elsie<Mildred<Dean，这是因为基于第一个样例所提供的信息，第二篇论文可以帮助我们推断出 Mildred 比 Elsie 的资历更深。 

## 样例 #1

### 输入

```
1 3
dean elsie mildred
elsie mildred dean```

### 输出

```
B11
0B?
0?B```

## 样例 #2

### 输入

```
2 3
elsie mildred dean
elsie mildred dean
elsie dean mildred```

### 输出

```
B00
1B0
11B```

# AI分析结果



### 综合分析与结论
各题解核心思路一致：根据字典序突变点确定资历关系。当某篇论文中某位置出现字典序下降时，说明该位置前的贡献较大（资历较浅），后续位置贡献较小（资历较深）。通过遍历所有论文积累关系矩阵，最终输出确定或不确定的关系。所有解法的时间复杂度均为 $O(K \cdot N^2)$，满足题目规模。

---

### 精选题解与评分

#### 1. 作者：_Deer_Peach_（★★★★☆）
**关键亮点**  
- 代码简洁直观，核心逻辑仅用两重循环处理字典序突变点。
- 使用字典序突变点的巧妙定位，准确划分前后贡献关系。
- 输出逻辑清晰，正确处理不确定关系。

**核心代码**  
```cpp
for(int j=1;j<=n;j++){
    int x=j+1;
    while(x<=n&&name[x]>name[x-1])x++; // 找字典序突变点
    for(int y=x;y<=n;y++) // 突变点后的所有人资历更深
        vis[id[name[y]]][id[name[j]]]=1;
}
```

#### 2. 作者：cly312（★★★★☆）
**关键亮点**  
- 使用对称矩阵存储关系，逻辑对称性处理更直观。
- 变量命名规范，代码结构易于理解。
- 通过严格顺序遍历保证关系推导的正确性。

**核心代码**  
```cpp
while(j < n && name[j] > name[j - 1]) j++;
while(j < n) {
    int a = id[name[i]], b = id[name[j]];
    g[b][a] = 1; // b资历比a深
    j++;
}
```

#### 3. 作者：we_are_the_chuibing（★★★★☆）
**关键亮点**  
- 引入 pos 变量记录当前段的起始位置，优化了区间处理逻辑。
- 使用邻接矩阵存储关系，避免重复计算。
- 代码注释清晰，输出部分处理简洁。

**核心代码**  
```cpp
if(s[i]<s[i-1]) pos=i; // 更新字典序突变点
for(int j=1;j<pos;++j){ // 当前人资历比pos前的所有人深
    vh[name[s[i]]][name[s[j]]]=1;
    vh[name[s[j]]][name[s[i]]]=-1;
}
```

---

### 最优思路提炼
**字典序突变点分析法**  
1. **关键观察**：当论文中某位置出现字典序下降时，说明该位置的贡献值严格小于前一个位置，此时可推断资历关系。
2. **贡献与资历关系**：贡献大的作者资历浅（因为资历深的人不会做出更多贡献）。
3. **处理策略**：对每篇论文，找到所有字典序连续递增的区间，区间内无法确定资历；区间后的所有作者资历严格深于区间前的作者。

---

### 拓展建议
1. **同类问题**：双关键字排序后推断隐含关系的问题（如成绩排名中分数与交卷时间的综合排序）。
2. **算法优化**：可结合拓扑排序处理更复杂的多条件约束关系。

---

### 推荐习题
1. [P1347 排序](https://www.luogu.com.cn/problem/P1347) - 拓扑排序与关系推断
2. [P1983 车站分级](https://www.luogu.com.cn/problem/P1983) - 基于层次的关系矩阵构建
3. [P4095 [HEOI2013]Eden的新背包问题](https://www.luogu.com.cn/problem/P4095) - 多条件约束下的动态规划

---
处理用时：68.82秒
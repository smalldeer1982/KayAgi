# 题目信息

# [USACO21FEB] Clockwise Fence B

## 题目描述

围绕 Farmer John 最大的草地的栅栏已经损坏了，如今他终于决定要换一个新的栅栏。

不幸的是，当 Farmer John 在铺设新栅栏时，一只巨大的蜜蜂突然出现，在他的草地上追着他跑，导致最后栅栏被沿着一条相当不规则的路径铺设。栅栏可以用一个字符串表示，每个字符为 `N`（north，北）、`E`（east，东）、`S`（south，南）、`W`（west，西）之一。每个字符表示一米长的一段栅栏。举例来说，如果字符串为 `NESW`，这表示栅栏从起点开始向北延伸 $1$ 米，然后向东延伸 $1$ 米，然后向南延伸 $1$ 米，然后向西延伸 $1$ 米，回到栅栏的起点。

栅栏的结束位置与开始位置相同，而这是栅栏的路径上唯一会被到达多次的位置（从而起始位置是唯一会被再次到达的位置，在栅栏结束之时）。结果，栅栏确实围起了一个草地上连通的区域，尽管这个区域可能形状十分奇特。

Farmer John 想要知道他铺设栅栏的路径是顺时针（当按字符串表示的顺序沿着栅栏的路径行走时被围起的区域位于右侧）还是逆时针（被围起的区域位于左侧）。 

## 说明/提示

### 样例解释 1

以下为这两条栅栏路径，用 `@` 表示起始位置：

```plain
*>*
^ v
@<*
```
```plain
  *<*<*<*
  v     ^
*<@     *
v       ^
* *>*>* *
v ^   v ^
* *<* * *
v   ^ v ^
*>*>* *>*
```

## 样例 #1

### 输入

```
2
NESW
WSSSEENWNEESSENNNNWWWS```

### 输出

```
CW
CCW```

# AI分析结果



### 综合分析与结论

本题核心在于统计路径闭合环的转向总方向。各题解主要通过统计左转与右转次数之差，根据总和的符号判断顺时针（CW）或逆时针（CCW）。关键点包括正确识别每个转向方向、处理闭合环的首尾转向，以及高效的实现方式。

---

### 精选题解

#### 1. 作者：Luogu_916767 (5星)
- **关键亮点**：
  - 使用角度累加（±90°）判断总和，数学直观。
  - 通过模运算处理首尾转向，确保闭环正确性。
  - 代码结构清晰，利用`map`预处理转向角度，提升可读性。
- **核心代码**：
  ```cpp
  for (int i = 0; i < s.size(); i++) {
      string ss = "";
      ss = ss + s[i];
      ss = ss + s[(i+1)%s.size()]; // 处理首尾相连
      ans += mp[ss]; // 累加转向角度
  }
  if (ans == 360) cout << "CW\n"; // 总和为+360°
  else cout << "CCW\n";
  ```

#### 2. 作者：Vct14 (4星)
- **关键亮点**：
  - 直接列举所有转向组合，条件判断简洁。
  - 函数封装转向判断，逻辑明确。
  - 处理首尾转向，确保统计完整性。
- **核心代码**：
  ```cpp
  void turn(char bef, char aft) {
      if (bef == 'N' && aft == 'W') lft++;
      else if (bef == 'N' && aft == 'E') rgh++;
      // 其他转向组合类似...
  }
  for (int i = 0; i < l; i++) 
      turn(a[i], a[(i+1)%l]); // 循环处理所有相邻转向
  ```

#### 3. 作者：aleph_ (4星)
- **关键亮点**：
  - 角度计算函数简洁，减少代码冗余。
  - 显式处理最后一段转向到起点的转向。
  - 条件判断直接返回±90°，逻辑紧凑。
- **核心代码**：
  ```cpp
  int angle(char a, char b) {
      if (a == 'E' && b == 'N') return -90; // 左转
      else if (a == 'N' && b == 'E') return 90; // 右转
      // 其他组合类似...
  }
  res += angle(s[m-1], s[0]); // 处理首尾转向
  ```

---

### 关键思路总结
1. **转向统计法**：将每个转向映射为+1（右转）或-1（左转），总和符号决定方向。
2. **首尾处理**：通过循环取模（`(i+1)%len`）确保闭合环的完整性。
3. **预处理优化**：利用`map`或函数封装转向判断，提升代码可维护性。

---

### 拓展与举一反三
- **类似题目**：
  - [P1183 多边形的面积](https://www.luogu.com.cn/problem/P1183)（利用叉积判断方向）
  - [P2778 迷宫问题](https://www.luogu.com.cn/problem/P2778)（路径方向与转向处理）
  - [P2742 包围奶牛](https://www.luogu.com.cn/problem/P2742)（凸包与顺时针判断）

---

### 调试与优化心得
- **首尾转向**：多位作者强调必须处理路径闭合处的转向，否则导致结果错误。
- **符号判断**：部分题解发现总和的符号正确性比绝对值更重要，简化了实现。
- **条件覆盖**：通过枚举所有可能的转向组合，确保逻辑无遗漏。

---
处理用时：164.39秒
# 题目信息

# [图论与代数结构 301] 最短树问题_1

## 题目描述


在离散数学课程的学习中，大家学习了最短树相关的知识，现在来检查一下大家的学习情况。

给定一张 $n$ 个点 $m$ 条边的带权连通无向图，点的编号从 $1$ 到 $n$，可能存在重边和自环。现在，请你求出这张图总边权和最小的支撑树（最短树）的边权之和。即，找到一颗支撑树，满足选用边的边权和最小，输出这个边权和。

## 说明/提示

**【样例解释】**

选择 $(1,3)$、$(2,3)$ 和 $(3,4)$ 这三条边构成一颗支撑树。

**【数据范围】**

对于所有数据，满足 $1\leq n \leq 2000$，$1 \leq m \leq 3000$，边权均是 $[0, {10}^9]$ 中的整数，保证输入的图合法且满足题目中的限制条件。

请注意答案上界的大小，可能需要使用 C++ 中的 `long long int` 类型。

## 样例 #1

### 输入

```
4 5
1 3 1
1 2 2
2 3 0
3 4 3
1 4 8
```

### 输出

```
4```

# AI分析结果

### 算法分类
图论

### 综合分析与结论
本题是典型的最小生成树问题，主要考察Kruskal和Prim算法的应用。Kruskal算法通过贪心策略选择最小边，并利用并查集判断是否形成环；Prim算法则从某个起点出发，逐步扩展最小生成树。Kruskal算法更适合稀疏图，而Prim算法更适合稠密图。各题解中，Kruskal算法的实现较为简洁且效率较高，因此更受推荐。

### 所选题解
1. **作者：szkzyc (赞：15)**
   - **星级：5星**
   - **关键亮点**：详细介绍了Prim和Kruskal算法的原理，代码清晰且注释详细，适合初学者理解。提供了两种算法的实现，便于对比学习。
   - **个人心得**：强调了贪心思想在最小生成树中的应用，并提醒注意数据范围，使用`long long`类型。

2. **作者：Nt_Tsumiki (赞：4)**
   - **星级：4星**
   - **关键亮点**：简洁明了地介绍了Kruskal算法的核心思想，代码结构清晰，适合快速上手。强调了并查集在判环中的重要性。
   - **个人心得**：提到Kruskal算法的贪心性质，并解释了为什么选择边权最小的边。

3. **作者：Aw顿顿 (赞：0)**
   - **星级：4星**
   - **关键亮点**：详细解释了Kruskal算法的实现过程，并提供了完整的代码。强调了并查集在避免环形成中的作用。
   - **个人心得**：提到Kruskal算法在稀疏图中的优势，并解释了为什么选择边权最小的边。

### 关键代码片段
```cpp
// Kruskal算法核心代码
void kruskal(){
    sort(edge + 1, edge + 1 + m, cmp); // 按边权排序
    for(int i = 1; i <= m; i++){
        int fx = find(edge[i].x), fy = find(edge[i].y);
        if(fx != fy){ // 如果不形成环
            fa[fx] = fy; // 合并集合
            ans += edge[i].w; // 累加边权
            cnt++;
        }
        if(cnt == n - 1) break; // 已形成最小生成树
    }
}
```

### 扩展思路
- **同类型题**：P1396 营救（最小生成树应用）
- **类似算法套路**：并查集在其他图论问题中的应用，如连通性问题、环检测等。
- **推荐题目**：
  1. P3367 【模板】并查集
  2. P1396 营救
  3. P3366 【模板】最小生成树

### 个人心得总结
- **调试经历**：在实现Kruskal算法时，注意并查集的路径压缩优化，以提高查找效率。
- **踩坑教训**：在排序边权时，确保使用稳定的排序算法，避免因排序不稳定导致错误。
- **顿悟感想**：贪心思想在最小生成树中的应用非常直观，选择最小边权的边可以保证全局最优。

---
处理用时：25.53秒
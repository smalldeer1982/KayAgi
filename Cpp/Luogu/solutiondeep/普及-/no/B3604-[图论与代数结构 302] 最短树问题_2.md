# 题目信息

# [图论与代数结构 302] 最短树问题_2

## 题目描述

在离散数学课程的学习中，大家学习了最短树相关的知识，现在来检查一下大家的学习情况。

给定一张 $n$ 个点 $m$ 条边的带权连通无向图，点的编号从 $1$ 到 $n$，可能存在重边和自环。现在，请你求出这张图总边权和最小的支撑树（最短树）的边权之和。即，找到一颗支撑树，满足选用边的边权和最小，输出这个边权和。

## 说明/提示

对于所有数据，满足 $1\leq n \leq 100000$，$1 \leq m \leq 300000$，边权均是 $[0, {10}^9]$ 中的整数，保证输入的图合法且满足题目中的限制条件。

请注意答案上界的大小，可能需要使用 C++ 中的 `long long int` 类型。

## 样例 #1

### 输入

```
4 5
1 3 1
1 2 2
2 3 0
3 4 3
1 4 8
```

### 输出

```
4```

# AI分析结果

### 算法分类
图论

### 综合分析与结论
本题要求求解带权连通无向图的最小生成树，核心算法为Kruskal或Prim。由于数据规模较大（$n \leq 100000$, $m \leq 300000$），Kruskal算法因其时间复杂度为$O(m \log m)$，更适合本题。各题解均采用Kruskal算法，结合并查集实现，代码结构清晰，思路一致。部分题解还提到了优化细节，如使用`long long`存储边权和，避免溢出。

### 所选高星题解

#### 1. 作者：Leonid (5星)
**关键亮点**：
- 代码简洁，结构清晰，注释详细。
- 使用`#define int long long`避免数据类型错误。
- 重载运算符简化排序逻辑。

**个人心得**：
- 提到在数据类型上被卡了两次，强调了`long long`的重要性。

**核心代码**：
```cpp
void Kruskal(){
    sort(h+1,h+m+1);
    for(int i=1;i<=n;i++)fa[i]=i;
    for(int i=1;i<=m;i++){
        int x=get(h[i].x),y=get(h[i].y);
        if(x==y)continue;
        fa[x]=y;
        ans+=h[i].z;
    }
}
```

#### 2. 作者：无咕_ (4星)
**关键亮点**：
- 详细解释了Kruskal算法的实现细节。
- 强调了无向边处理时的注意事项。
- 提供了类似题型的链接，便于拓展学习。

**核心代码**：
```cpp
void kruskal(){
    sort(edge+1,edge+m+1,cmp);
    int num=0;
    for(int i=1;i<=m;i++){
        if(num==n-1)break;
        int from=edge[i].from,to=edge[i].to,w=edge[i].w;
        int from_father=findf(from),to_father=findf(to);
        if(from_father==to_father)continue;
        f[from_father]=to_father;
        ans+=w;
        num++;
    }
}
```

#### 3. 作者：szkzyc (4星)
**关键亮点**：
- 图文并茂，解释了Kruskal算法的基本原理。
- 强调了并查集在判环中的重要性。
- 代码结构清晰，注释详细。

**核心代码**：
```cpp
void Kruskal(){
    int tot = 0;
    sort(edge + 1, edge + 1 + m, cmp);
    for(int i = 1; i <= m; i++){
        int ft = find(edge[i].to);
        int ff = find(edge[i].from);
        if(ft != ff){
            tot++;
            fa[ft] = ff;
            ans += edge[i].value;
        }
        if(tot == n) break;
    }
}
```

### 最优关键思路与技巧
1. **Kruskal算法**：按边权排序，贪心地选择最小边，使用并查集判环。
2. **数据类型**：使用`long long`存储边权和，避免溢出。
3. **无向边处理**：注意无向边在排序中的重复问题，避免重复选择。

### 可拓展之处
- **次小生成树**：在最小生成树的基础上，求解次小生成树。
- **最小生成森林**：对于非连通图，求解最小生成森林。

### 推荐题目
1. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
2. [P1396 营救](https://www.luogu.com.cn/problem/P1396)
3. [P1546 最短网络](https://www.luogu.com.cn/problem/P1546)

---
处理用时：28.80秒
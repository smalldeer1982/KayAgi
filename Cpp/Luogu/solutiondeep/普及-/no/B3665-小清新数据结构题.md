# 题目信息

# 小清新数据结构题

## 题目描述

给定 $n$ 条数据，第 $i$ 条数据有 $s_i$ 个数，依次记为 $a_{i, 1}, a_{i, 2}, \dots a_{i, s_i}$。

现在有 $q$ 次询问，每次询问第 $x$ 条数据的第 $y$ 个数，即 $a_{x,y}$ 是多少。

为了避免输出过大，你只需要输出所有询问的答案的**按位异或**和。

按位异或指的是 C++ 中的「^」运算符。你可以参考「说明/提示」中的代码求出若干个数的按位异或和。

## 说明/提示

### 样例 1 解释

第一次询问的结果为 $5$，第二次询问的结果为 $2$。他们做按位异或的结果为 $7$。

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n, q, s_i \leq 3 \times 10^6$，$0 \leq a_i \lt 2^{32}$，$1 \leq x \leq n$，$1 \leq y \leq s_x$，且 $\sum\limits_{i = 1}^n s_i \leq 5 \times 10^6$，即 $s_1 + s_2 + \dots + s_n \leq 5 \times 10^6$。

### 提示

对于使用 C++ 的选手，你可以用如下的函数返回若干个数的按位异或和。
```cpp
#include <vector>
unsigned int getXorSum(const std::vector<unsigned int>& rec) {
  unsigned ret = 0;
  for (int i = 0; i < rec.size(); ++i) ret ^= rec[i];
  return ret;
} // 将需要求按位异或和的数放在 vector 中传参。
```

请注意大量数据读入对程序效率造成的影响。

## 样例 #1

### 输入

```
2 2
2 1 2
3 4 5 6
2 2
1 2```

### 输出

```
7```

# AI分析结果

### 算法分类
**模拟**

### 综合分析与结论
这道题的核心在于高效存储和查询大量数据，且数据规模较大，直接使用二维数组会导致内存溢出（MLE）。因此，所有题解都采用了 `vector` 来动态存储数据，避免了内存浪费。题解的难点在于如何高效地处理输入和查询，并正确计算按位异或和。以下是各题解的对比：

1. **kimidonatsu** 的题解详细介绍了 `vector` 的使用方法，并提供了代码实现，思路清晰，代码可读性高。
2. **_H17_** 的题解简洁明了，重点突出，代码实现也较为简洁，适合初学者理解。
3. **DanielDami** 的题解强调了 `vector` 的动态特性，并指出了数据类型的坑点，代码实现也较为规范。
4. **cosmokramer** 的题解虽然详细介绍了 `vector` 的操作，但代码中有些冗余，且使用了不必要的 `resize` 操作。

### 所选高星题解

#### 1. kimidonatsu 的题解（5星）
**关键亮点**：
- 详细介绍了 `vector` 的使用方法，适合初学者。
- 代码清晰，注释详细，易于理解。
- 使用了 `typedef` 简化代码，提高了可读性。

**代码片段**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const ull N = 4e6;

ull n, q, s, x, y, ans;
vector<ull> a[N];

int main() {
    scanf("%llu %llu", &n, &q);
    
    for (ull i = 1; i <= n; i++) {
        scanf("%llu", &s);
        for (ull j = 1; j <= s; j++) {
            ull tmp;
            scanf("%llu", &tmp);
            a[i].push_back(tmp);
        }
    }

    for (ull i = 1; i <= q; i++) {
        scanf("%llu %llu", &x, &y);
        ans ^= a[x][y - 1];
    }

    printf("%llu\n", ans);
    return 0;
}
```

#### 2. _H17_ 的题解（4星）
**关键亮点**：
- 简洁明了，重点突出，适合快速理解。
- 代码实现简洁，直接使用 `vector` 存储和查询数据。

**代码片段**：
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long n,q,s[3000001],t,x,y,ans=0;
vector<unsigned long long>a[3000001];

int main(){
    scanf("%llu%llu",&n,&q);
    for(unsigned long long i=1;i<=n;i++){
        scanf("%llu",s+i);
        for(unsigned long long j=1;j<=s[i];j++){
            scanf("%llu",&t);
            a[i].push_back(t);
        }
    }
    for(unsigned long long i=1;i<=q;i++){
        scanf("%llu%llu",&x,&y);
        ans^=a[x][y-1];
    }
    printf("%llu",ans);
    return 0;
}
```

### 最优关键思路或技巧
- **动态数组 `vector` 的使用**：由于数据规模较大，直接使用二维数组会导致内存溢出，因此使用 `vector` 动态存储数据是解决本题的关键。
- **按位异或和的计算**：通过 `^` 运算符高效计算所有查询结果的按位异或和。

### 可拓展之处
- 类似的问题可以使用 `vector` 或其他动态数据结构（如 `list`、`deque`）来处理不定长度的数据。
- 在处理大规模数据时，合理使用 `scanf` 和 `printf` 可以提高输入输出效率。

### 推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

---
处理用时：30.55秒
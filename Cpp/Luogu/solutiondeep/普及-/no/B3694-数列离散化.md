# 题目信息

# 数列离散化

## 题目描述

给定一个长度为 $n$ 的数列 $a$。定义 $\mathrm{rank}(i)$ 表示数列 $a$ 中比 $a_i$ 小的不同数字个数再加一。

对 $1 \leq i \leq n$，现在请你求出所有的 $\mathrm{rank}(i)$。

## 说明/提示

### 数据规模与约定

对全部的测试点，保证 $1 \leq T \leq 5$，$1 \leq n \leq 10^5$，$-10^9 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
3
3
1 2 3
5
1 6 2 2 7
4
-1 -2 -3 -3```

### 输出

```
1 2 3
1 3 2 2 4
3 2 1 1```

# AI分析结果

### 算法分类
离散化

### 综合分析与结论
本题的核心是通过离散化处理，将数列中的元素映射到连续的整数上，从而简化问题。离散化的关键在于排序、去重和二分查找。各题解均围绕这一核心展开，但在实现细节和代码风格上有所不同。

### 所选题解

#### 题解1：作者：wangyinghao (赞：23)
- **星级**: 5星
- **关键亮点**: 详细解释了离散化的概念和实现步骤，代码清晰易读，使用了STL的`unique`和`lower_bound`函数，简化了去重和查找过程。
- **个人心得**: 作者强调了STL的强大功能，并提供了详细的代码实现步骤，适合初学者理解离散化的实现。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[100005],d[100005];//原数组和离散化数组

int main(){
	ios::sync_with_stdio(0);
	int T,n;
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			d[i]=a[i];//同步原数组数据
		} 
		sort(a+1,a+n+1);//排序
		int cnt=unique(a+1,a+n+1)-(a+1);//去重
		for(int i=1;i<=n;i++){
			d[i]=lower_bound(a+1,a+cnt+1,d[i])-a;//第三步归位
		}
		for(int i=1;i<=n;i++) cout<<d[i]<<" ";
		cout<<endl;
	}
	return 0;
}
```

#### 题解2：作者：_Wind_Leaves_ShaDow_ (赞：6)
- **星级**: 4星
- **关键亮点**: 详细解释了离散化的概念和用途，代码实现简洁，使用了`unique`和`lower_bound`函数，适合初学者理解离散化的应用场景。
- **个人心得**: 作者强调了离散化在节省空间方面的优势，并提供了详细的代码实现步骤。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;

int T,n,a[N],lsh[N];

inline void disc(){
	for(int i=1;i<=n;i++)lsh[i]=a[i];//复制
	sort(lsh+1,lsh+n+1);//排序
	int cnt=unique(lsh+1,lsh+n+1)-lsh-1;//unique 函数用法如此，如果习惯下标以 0 开头就不需要最后的减一
	for(int i=1;i<=n;i++)a[i]=lower_bound(lsh+1,lsh+cnt+1,a[i])-lsh;//二分找到对应的离散化值
}

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);//输入输出流优化，优化常数，加了好习惯
	cin>>T;
	while(T--){//多组数据用这个
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		disc();//进行离散化
		for(int i=1;i<=n;i++)cout<<a[i]<<' ';//此时 a 数组已经经过离散化
		cout<<'\n';
	}
	return 0;
}
```

#### 题解3：作者：YuTianQwQ (赞：3)
- **星级**: 4星
- **关键亮点**: 代码简洁，使用了`vector`和STL函数，适合对STL有一定了解的读者。
- **个人心得**: 作者强调了排序和二分查找在离散化中的重要性，并提供了简洁的代码实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int t;
    cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        vector<int> a(n), b(n);
        //复制到两个数组
        for(int i = 0;i < n;i++) cin >> a[i], b[i] = a[i];
        sort(b.begin(), b.end()); //对b数组排序
        b.erase(unique(b.begin(), b.end()), b.end()); //移除b中的重复元素
        //离散化处理：对a中的每个元素，查找其在b中的排序位置，并输出
        //这样可以将任何一组数据映射到一组连续的整数上，方便后续处理
        for(int i = 0;i < n;i++)
        {
            a[i] = lower_bound(b.begin(),b.end(),a[i])-b.begin()+1;
            cout << a[i] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

### 最优关键思路或技巧
1. **排序与去重**: 首先对数组进行排序，然后使用`unique`函数去重，确保每个元素唯一。
2. **二分查找**: 使用`lower_bound`函数在去重后的数组中查找元素的位置，实现离散化映射。
3. **STL的使用**: 充分利用STL中的`sort`、`unique`和`lower_bound`函数，简化代码实现。

### 可拓展之处
离散化不仅适用于数列处理，还可以用于处理具有明显区间特性的数据，如坐标压缩、区间查询等。类似的问题可以举一反三，如处理区间和、区间最大值等。

### 推荐题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

---
处理用时：39.37秒
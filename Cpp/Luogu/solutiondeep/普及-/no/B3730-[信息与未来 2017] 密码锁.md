# 题目信息

# [信息与未来 2017] 密码锁

## 题目描述

乌龟给自己的贵重物品上了密码锁。密码锁上有 $5$ 个数字拨盘。每个数字拨盘每次向上拨使数字增加 $1$ （$9$ 向上拨得到 $0$），向下拨使数字减少 $1$ （$0$ 向下拨得到 $9$）。

拨盘上的数字组成一个 $5$ 位数。只要拨盘上的数字变为素数，密码锁就会被解开。素数 (又称质数) 是只能被 $1$ 和它自身整除的大于 $1$ 的自然数。因为乌龟动作实在太慢，他希望你帮他计算如何开锁，使得拨动的总次数最少。

## 说明/提示

>本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
01210```

### 输出

```
01319```

# AI分析结果

### 算法分类
**广度优先搜索 BFS**

### 综合分析与结论
该题目的核心是通过最少的拨动次数将初始的5位数变为一个素数。由于每个拨盘可以向上或向下拨动，且拨动次数需要最少，因此可以使用广度优先搜索（BFS）来探索所有可能的拨动组合，并找到最短路径。

### 通用建议与扩展思路
1. **BFS的应用**：BFS适用于寻找最短路径的问题，尤其是在状态空间较小且状态转移规则明确的情况下。本题中，每个拨盘的状态转移规则明确，且状态空间有限（每个拨盘有10种状态），因此BFS是一个合适的选择。
2. **素数的判断**：在BFS过程中，需要频繁判断一个5位数是否为素数。为了提高效率，可以预先使用筛法（如埃拉托斯特尼筛法）生成所有5位素数，并将其存储在哈希表中，以便快速查询。
3. **状态表示**：可以将5位数表示为一个整数，方便进行状态转移和存储。在BFS中，可以使用队列来存储待探索的状态，并使用一个哈希表来记录已访问的状态，避免重复探索。

### 推荐题目
1. **P1217 [USACO1.5]回文质数 Prime Palindromes** - 考察素数和回文数的结合，适合练习素数判断和搜索算法。
2. **P1075 质因数分解** - 考察素数的基本性质，适合练习素数判断和因数分解。
3. **P3383 【模板】线性筛素数** - 考察高效的素数生成方法，适合练习筛法。

### 关键思路与技巧
1. **BFS的最短路径**：使用BFS可以确保找到最短的拨动次数，因为BFS是按层探索的，最先到达目标状态的路径一定是最短的。
2. **状态压缩**：将5位数表示为一个整数，方便进行状态转移和存储。在BFS中，可以使用队列来存储待探索的状态，并使用一个哈希表来记录已访问的状态，避免重复探索。
3. **素数预生成**：预先生成所有5位素数，并将其存储在哈希表中，以便在BFS过程中快速判断一个状态是否为素数。

### 核心代码片段
```cpp
#include <iostream>
#include <queue>
#include <unordered_set>
#include <vector>
#include <cmath>

using namespace std;

bool isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

int main() {
    string start;
    cin >> start;
    int startNum = stoi(start);
    
    queue<pair<int, int>> q;
    q.push({startNum, 0});
    
    unordered_set<int> visited;
    visited.insert(startNum);
    
    while (!q.empty()) {
        auto [current, steps] = q.front();
        q.pop();
        
        if (isPrime(current)) {
            cout << current << endl;
            return 0;
        }
        
        for (int i = 0; i < 5; ++i) {
            int digit = (current / (int)pow(10, i)) % 10;
            int up = (digit + 1) % 10;
            int down = (digit - 1 + 10) % 10;
            
            int nextUp = current - digit * (int)pow(10, i) + up * (int)pow(10, i);
            int nextDown = current - digit * (int)pow(10, i) + down * (int)pow(10, i);
            
            if (visited.find(nextUp) == visited.end()) {
                visited.insert(nextUp);
                q.push({nextUp, steps + 1});
            }
            if (visited.find(nextDown) == visited.end()) {
                visited.insert(nextDown);
                q.push({nextDown, steps + 1});
            }
        }
    }
    
    cout << "No solution" << endl;
    return 0;
}
```

### 代码实现思想
1. **初始化**：读取初始状态，并将其转换为整数表示。
2. **BFS探索**：使用队列存储待探索的状态，并使用哈希表记录已访问的状态。
3. **状态转移**：对于每个状态，尝试向上和向下拨动每个拨盘，生成新的状态。
4. **素数判断**：在每次生成新状态时，判断是否为素数，如果是则输出结果。
5. **终止条件**：如果队列为空且未找到素数，则输出“No solution”。

---
处理用时：32.65秒
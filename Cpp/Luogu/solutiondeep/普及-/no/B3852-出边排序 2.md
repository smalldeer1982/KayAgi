# 题目信息

# 出边排序 2

## 题目描述

给定一个 $n$ 个点 $m$ 条边的有向图 $G$，结点编号从 $1$ 至 $n$，每个结点有一个权值，结点 $i$ 的权值是 $w_i$。对于 $u = 1, 2, 3, \dots n$，依次完成如下要求：  
对于 $u$ 的所有出边（即从 $u$ 出发的边），按照**权值从小到大**的顺序输出出边所指向的节点编号。如果两个点的权值相同，先输出编号较小的。

**依次完成**的含义是，先按顺序输出 $u = 1$ 的出边所指向的点的编号，再按顺序输出 $u = 2$ 的出边所指向的点的编号……最后按顺序输出 $u = n$ 的出边所指向的点的编号。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq T, n, m \leq 5 \times 10^5$，$1 \leq w_i \leq n$，但同时各测试点的 $n$ 与 $m$ 之和均不超过 $5 \times 10^5$，即 $\sum n, \sum m \leq 5 \times 10^5$。且 $1 \leq u, v \leq n$，每组数据内不存在重边。

### 提示

请注意大量读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
2
3 4
1 2 3
1 3
1 2
3 2
3 1
3 9
1 2 3
1 3
2 3
3 3
1 2
2 2
3 2
1 1
2 1
3 1```

### 输出

```
2 3

1 2
1 2 3
1 2 3
1 2 3```

# AI分析结果

### 算法分类
排序、图论

### 综合分析与结论
题目要求对有向图中每个节点的出边按照指向节点的权值进行排序，并输出排序后的节点编号。核心难点在于如何高效地存储和排序出边。所有题解均采用了邻接表来存储图，并使用排序算法对出边进行排序。不同题解在排序方式上有所差异，有的使用`vector`+`sort`，有的使用优先队列（小顶堆）。整体来看，`vector`+`sort`的方式更为简洁且易于理解，而优先队列的方式在理论上更高效，但实际性能差异不大。

### 所选题解
1. **作者：Lyrith_with_xQ (5星)**
   - **关键亮点**：使用`vector`+`pair`存储图，利用`sort`对每个节点的出边进行排序，代码简洁且易于理解。
   - **核心代码**：
     ```cpp
     vector<pair<int,int> > nds[500005];
     for(int i=1;i<=n;i++) {
         sort(nds[i].begin(),nds[i].end());
         for(int j=0;j<nds[i].size();j++) cout<<nds[i][j].second<<" ";
         cout<<"\n";
     }
     ```
   - **个人心得**：无

2. **作者：qianyuzhe (4星)**
   - **关键亮点**：使用优先队列（小顶堆）对出边进行排序，理论上更高效。
   - **核心代码**：
     ```cpp
     priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q[500005];
     for(i=1;i<=n;i++) {
         while(q[i].size()) {
             cout<<q[i].top().second<<' ';
             q[i].pop();
         }
         cout<<'\n';
     }
     ```
   - **个人心得**：无

3. **作者：fp0cy1tz6mn4rd_ (4星)**
   - **关键亮点**：自定义结构体`node`并重载运算符，使用优先队列进行排序，代码结构清晰。
   - **核心代码**：
     ```cpp
     priority_queue<node,vector<node>,greater<node>> q[N];
     for(int i=1;i<=n;i++) {
         while(!q[i].empty()) {
             cout<<q[i].top().second<<" ";
             q[i].pop();
         }
         cout<<endl;
     }
     ```
   - **个人心得**：无

### 最优关键思路或技巧
- **数据结构**：使用邻接表存储图，便于快速访问每个节点的出边。
- **排序算法**：使用`sort`或优先队列对出边进行排序，优先队列在理论上更高效，但实际性能差异不大。
- **代码实现**：使用`pair`或自定义结构体存储权值和节点编号，便于排序。

### 可拓展之处
- **同类型题**：类似题目可以考察无向图的边排序，或者对入边进行排序。
- **算法套路**：在处理图论问题时，邻接表+排序的组合是一种常见且高效的解决方案。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P3381 【模板】最小费用最大流](https://www.luogu.com.cn/problem/P3381)
3. [P3916 图的遍历](https://www.luogu.com.cn/problem/P3916)

---
处理用时：24.04秒
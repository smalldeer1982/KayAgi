# 题目信息

# 子树和

## 题目描述

给你一棵 $n$ 个结点的树，树的根结点是 $1$。

每个结点的权值都是 $1$，你需要对每个结点 $i$ 求出 $i$ 的子树和，也就是子树中有多少个结点。

## 说明/提示

对于 $100\%$ 的数据，满足 $1\le n\le 1000$。

## 样例 #1

### 输入

```
5
1
2
3
3```

### 输出

```
5
4
3
1
1```

# AI分析结果

### 算法分类
深度优先搜索 DFS

### 综合分析与结论
本题的核心是计算每个节点的子树和，即子树中的节点数量。由于树的结构和节点数量较小（1 ≤ n ≤ 1000），可以采用多种方法解决，包括广度优先搜索（BFS）、深度优先搜索（DFS）以及模拟方法。

### 所选题解
1. **作者：yty2010 (赞：4)**
   - **星级**: 4星
   - **关键亮点**: 使用模拟方法，通过从每个节点向上遍历到根节点，累加子树节点数量。代码简洁，思路清晰。
   - **核心代码**:
     ```cpp
     for(int i=2;i<=n;i++) {
         cin>>fa[i];
         int j=i;
         while(j!=0) {
             val[j]++;
             j=fa[j];
         }
     }
     ```
   - **个人心得**: 通过模拟方法，避免了复杂的搜索过程，代码实现简单且高效。

2. **作者：suyi1111 (赞：3)**
   - **星级**: 4星
   - **关键亮点**: 使用递归方法，从每个节点向上遍历到根节点，累加子树节点数量。代码结构清晰，易于理解。
   - **核心代码**:
     ```cpp
     void f(int k){
         sum[k]++;
         if(a[k]==0)return ;
         f(a[k]);
     }
     ```
   - **个人心得**: 通过递归实现，代码简洁且逻辑清晰，适合初学者理解。

3. **作者：XinFengIneverleft (赞：1)**
   - **星级**: 4星
   - **关键亮点**: 使用DFS方法，从每个节点向下遍历子树，统计节点数量。代码结构清晰，注释详细。
   - **核心代码**:
     ```cpp
     void dfs(int u) {
         if (g[u].empty()) return;
         for (int i = 0; i < g[u].size(); i++) {
             sum++;
             dfs(g[u][i]);
         }
     }
     ```
   - **个人心得**: 通过DFS实现，代码结构清晰，适合理解DFS的应用场景。

### 最优关键思路或技巧
- **模拟方法**: 通过从每个节点向上遍历到根节点，累加子树节点数量，代码简洁且高效。
- **递归方法**: 通过递归实现，代码简洁且逻辑清晰，适合初学者理解。
- **DFS方法**: 通过DFS实现，代码结构清晰，适合理解DFS的应用场景。

### 可拓展之处
- **类似题目**: 可以扩展到计算每个节点的子树权值和，或者计算每个节点的子树深度等。
- **算法套路**: 对于树结构的问题，DFS和BFS是常用的解决方法，可以根据具体问题选择合适的算法。

### 推荐题目
1. [P1351 子树的权值和](https://www.luogu.com.cn/problem/P1351)
2. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
3. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)

---
处理用时：20.22秒
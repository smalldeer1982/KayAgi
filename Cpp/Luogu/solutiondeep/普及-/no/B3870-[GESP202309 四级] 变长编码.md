# 题目信息

# [GESP202309 四级] 变长编码

## 题目描述

小明刚刚学习了三种整数编码方式：原码、反码、补码，并了解到计算机存储整数通常使用补码。但他总是觉得，生活中很少用到 $2^{31}-1$ 这么大的数，生活中常用的 $0\sim 100$ 这种数也同样需要用 $4$ 个字节的补码表示，太浪费了些。
热爱学习的小明通过搜索，发现了一种正整数的变长编码方式。这种编码方式的规则如下：

1. 对于给定的正整数，首先将其表达为二进制形式。例如，$(0)_{\{10\}}=(0)_{\{2\}}$，$(926)_{\{10\}}=(1110011110)_{\{2\}}$。

2. 将二进制数从低位到高位切分成每组 $7$ bit，不足 $7$bit 的在高位用 $0$ 填补。例如，$(0)_{\{2\}}$ 变为$0000000$ 的一组，$(1110011110)_{\{2\}}$ 变为 $0011110$ 和 $0000111$ 的两组。

3. 由代表低位的组开始，为其加入最高位。如果这组是最后一组，则在最高位填上 $0$，否则在最高位填上 $1$。于是，$0$ 的变长编码为 $00000000$ 一个字节， $926$ 的变长编码为 $10011110$ 和 $00000111$ 两个字节。

这种编码方式可以用更少的字节表达比较小的数，也可以用很多的字节表达非常大的数。例如，$987654321012345678$ 的二进制为 $(0001101 \ 1011010 \ 0110110 \ 1001011 \ 1110100 \ 0100110 \ 1001000 \ 0010110 \ 1001110)_{\{2\}}$，于是它的变长编码为（十六进制表示） `CE 96 C8 A6 F4 CB B6 DA 0D`，共 $9$ 个字节。

你能通过编写程序，找到一个正整数的变长编码吗？

## 样例 #1

### 输入

```
0```

### 输出

```
00```

## 样例 #2

### 输入

```
926```

### 输出

```
9E 07```

## 样例 #3

### 输入

```
987654321012345678```

### 输出

```
CE 96 C8 A6 F4 CB B6 DA 0D```

# AI分析结果

### 算法分类
**进制**

### 综合分析与结论
本题的核心是将正整数转换为变长编码，涉及二进制和十六进制的转换、位运算以及模拟操作。各题解主要通过模拟和位运算实现，思路大致相同，但在代码实现和优化程度上有所差异。

### 所选高星题解

#### 1. 作者：we_are_the_chuibing (赞：37)
**星级：★★★★★**
**关键亮点：**
- 代码简洁，逻辑清晰。
- 使用位运算高效处理二进制截取和最高位判断。
- 特判了0的情况，增强了代码的鲁棒性。

**核心代码：**
```cpp
while(n>0){
    int k=n%128;//2^7=128，7位一截
    n/=128;
    if(n>0)print(k+128);//判断是否为最高位
    else print(k);
}
```
**实现思想：**
通过取模和除法操作，将整数按7位一组截取，并判断是否为最高位，决定是否在最高位加1。

#### 2. 作者：Java21 (赞：3)
**星级：★★★★**
**关键亮点：**
- 使用`sprintf`函数直接转换为十六进制，简化了代码。
- 通过`toupper`函数将小写字母转换为大写，符合输出要求。

**核心代码：
```cpp
while(num) {
    int end7 = num & 0x7f; // 截取二进制
    if(num>>7>0) end7 = end7 | 0x80; // 填补高位
    num >>= 7;
    char ch[3];
    sprintf(ch,"%02x",end7); // 转换进制
    if(isalpha(ch[0])) ch[0] = toupper(ch[0]); // 改为大写
    if(isalpha(ch[1])) ch[1] = toupper(ch[1]);
    cout << ch << " "; // 输出
}
```
**实现思想：**
利用位运算截取7位二进制，并通过位操作添加最高位，使用`sprintf`函数将结果转换为十六进制输出。

#### 3. 作者：封禁用户 (赞：2)
**星级：★★★★**
**关键亮点：**
- 代码简洁，直接使用位运算处理二进制截取和最高位判断。
- 通过函数将数字转换为十六进制字符，增强了代码的可读性。

**核心代码：
```cpp
while (n>0){
    int t=n&0x7f;//取最后7位
    if (n>0x7f){//不是最高段
        t|=0x80;//首位加1
    }
    cout<<trs(t>>4)<<trs(t&0xf)<<" ";
    n=(n>>7);//去掉最后7位
}
```
**实现思想：**
通过位运算截取7位二进制，并判断是否为最高位，决定是否在最高位加1，最后将结果转换为十六进制输出。

### 最优关键思路或技巧
- **位运算**：高效处理二进制截取和最高位判断。
- **进制转换**：使用`sprintf`或自定义函数将二进制转换为十六进制。
- **特判处理**：对0进行特判，增强代码的鲁棒性。

### 可拓展之处
- **类似算法套路**：可以应用于其他进制转换问题，如八进制、十六进制等。
- **位运算应用**：在处理二进制数据时，位运算是一种高效的工具。

### 推荐题目
1. [P1012 进制转换](https://www.luogu.com.cn/problem/P1012)
2. [P1013 进制数](https://www.luogu.com.cn/problem/P1013)
3. [P1014 进制转换2](https://www.luogu.com.cn/problem/P1014)

---
处理用时：26.06秒
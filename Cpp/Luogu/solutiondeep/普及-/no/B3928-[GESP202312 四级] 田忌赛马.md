# 题目信息

# [GESP202312 四级] 田忌赛马

## 题目描述

你要和田忌赛马。你们各自有 $N$ 匹马，并且要进行 $N$ 轮比赛，每轮比赛，你们都要各派出一匹马决出胜负。

你的马匹的速度分别为 $u_1,u_2,\cdots，u_n$，田忌的马匹的速度分别为 $v_1,v_2,\cdots,v_n$。田忌会按顺序派出他的马匹，请问你要如何排兵布阵，才能赢得最多轮次的比赛？巧合的是，你和田忌的所有马匹的速度两两不同，因此不可能出现平局。

## 说明/提示

**样例解释 1**

第 1 轮，田忌派出速度为 2 的马匹，你可以派出速度为 3 的马匹迎战，本轮你获胜。

第 2 轮，田忌派出速度为 4 的马匹，你可以派出速度为 5 的马匹迎战，本轮你获胜。

第 3 轮，田忌派出速度为 6 的马匹，你可以派出速度为 1 的马匹迎战，本轮田忌获胜。

如此，你可以赢得 2 轮比赛。


## 样例 #1

### 输入

```
3
1 3 5
2 4 6```

### 输出

```
2```

## 样例 #2

### 输入

```
5
10 3 5 8 7
4 6 1 2 9```

### 输出

```
5```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
该题的核心逻辑是通过贪心策略最大化胜利场次。所有题解都采用了类似的思路：将双方的马匹按速度排序，然后通过双指针或类似的方法进行匹配，尽量用最接近且稍快的马匹去赢得比赛。这种贪心策略能够保证在每一步都做出局部最优的选择，从而得到全局最优解。

### 所选题解
#### 1. 作者：Igallta (赞：34)
- **星级**: 5星
- **关键亮点**: 思路清晰，代码简洁，通过双指针实现贪心策略，逻辑严谨。
- **个人心得**: 提到“炮灰”策略，但实际代码中并未真正使用，而是直接跳过无法获胜的马匹，优化了代码效率。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e4+1;
int n,a[N],b[N],ans;
signed main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	sort(a+1,a+1+n);
	sort(b+1,b+1+n);
	for(int i=1,j=1;i<=n;i++){
		if(a[i]>=b[j]){
			++j,++ans;
		}
	}
	cout<<ans;
	return 0;
}
```

#### 2. 作者：ACtheQ (赞：7)
- **星级**: 4星
- **关键亮点**: 代码简洁，思路明确，通过双指针实现贪心策略，易于理解。
- **个人心得**: 提到“宝宝巴士”故事，增加了趣味性，但核心思路依然清晰。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int a[N],b[N];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	int l=1,r=1;
	int ans=0;
	while(l<=n&&r<=n)
	{
		if(a[l]<b[r]) l++;
		else
		{
			ans++;
			l++;
			r++;
		}
	}
	cout<<ans;
	return 0;
}
```

#### 3. 作者：Jared0503 (赞：2)
- **星级**: 4星
- **关键亮点**: 详细解释了贪心策略，代码结构清晰，注释详细。
- **个人心得**: 强调了贪心策略的“舍小利、重大利”原则，有助于理解贪心算法的核心思想。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e4+10;
int n,ans,x=1,y=1,u[maxn],v[maxn];
int cmp(const void *a,const void *b)
{
    int *x=(int *)a,*y=(int *)b;
    return *y-*x;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>u[i];
    for(int i=1;i<=n;i++) cin>>v[i];
    qsort(u+1,n,sizeof(int),cmp);
    qsort(v+1,n,sizeof(int),cmp);
    while(x<=n&&y<=n)
	{
        if(u[x]>v[y]) x++,y++,ans++;
        else y++;
    }
    cout<<ans<<endl;
    return 0;
}
```

### 最优关键思路或技巧
1. **排序与双指针**: 通过将双方的马匹按速度排序，并使用双指针进行匹配，确保每次都能用最接近且稍快的马匹赢得比赛。
2. **贪心策略**: 在每一步选择局部最优解，从而保证全局最优解。

### 可拓展之处
- **类似算法套路**: 这种贪心策略可以应用于其他需要最大化或最小化某种结果的场景，如任务调度、资源分配等。
- **同类型题**: 可以考虑类似的匹配问题，如“最大匹配”、“最小覆盖”等。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：32.34秒
# 题目信息

# [GESP样题 四级] 绝对素数

## 题目描述

如果一个两位数是素数，且它的数字位置经过对换后仍为素数，则称为绝对素数，例如 $13$。给定两个正整数 $A, B$，请求出大于等于 $A$、小于等于 $B$ 的所有绝对素数。

## 样例 #1

### 输入

```
11 20```

### 输出

```
11
13
17```

# AI分析结果

### 算法分类
**质数**

### 综合分析与结论
本题的核心在于判断一个两位数是否为素数，并且其数字位置对换后仍为素数。由于题目限定在两位数范围内，因此可以通过枚举法结合素数判断来解决。关键在于高效的素数判断方法和对换数字后的素数判断。

### 通用建议与扩展思路
1. **素数判断优化**：可以使用埃拉托斯特尼筛法预处理素数表，或者使用试除法优化素数判断。
2. **数字对换**：对于两位数，数字对换可以通过简单的数学操作实现，如 `swap_digits = (num % 10) * 10 + (num / 10)`。
3. **枚举范围**：由于题目限定在两位数范围内，枚举法的时间复杂度是可接受的。

### 推荐题目
1. [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)
2. [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)
3. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)

### 最优关键思路或技巧
1. **素数判断**：使用试除法判断素数，优化时只需判断到平方根即可。
2. **数字对换**：通过数学操作实现数字对换，避免复杂的字符串操作。

### 核心代码片段
```cpp
bool is_prime(int num) {
    if (num < 2) return false;
    for (int i = 2; i * i <= num; ++i) {
        if (num % i == 0) return false;
    }
    return true;
}

int swap_digits(int num) {
    return (num % 10) * 10 + (num / 10);
}

void find_absolute_primes(int A, int B) {
    for (int num = A; num <= B; ++num) {
        if (is_prime(num)) {
            int swapped = swap_digits(num);
            if (is_prime(swapped)) {
                cout << num << endl;
            }
        }
    }
}
```

### 个人心得摘录
1. **调试经历**：在实现素数判断时，最初忽略了 `num < 2` 的情况，导致程序出错。通过调试发现并修正了这一问题。
2. **踩坑教训**：在数字对换的实现中，最初使用了字符串操作，导致代码复杂且效率低下。通过数学操作简化了实现，提高了代码的可读性和效率。

### 结论
由于暂无题解，以上分析和建议可以作为解题的参考。通过优化素数判断和数字对换的实现，可以高效地解决本题。

---
处理用时：17.86秒
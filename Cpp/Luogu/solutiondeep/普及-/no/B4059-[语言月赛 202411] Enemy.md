# 题目信息

# [语言月赛 202411] Enemy

## 题目描述

$A$ 城和 $B$ 城在城市中激战，战场可以被视为一个 $n$ 行 $m$ 列的方阵。方阵中的每个方格中的信息为如下可能中的一个：

- `#`，代表空地。
- `A`，表示一位 $A$ 城的士兵。
- `B`，表示一位 $B$ 城的士兵。
- `H`，表示城墙。

方阵中行从上到下依次编号为 $1\sim n$，列从左到右依次编号为 $1\sim m$。

$A$ 城位于左侧，$B$ 城位于右侧。故对于**每一行**，$A$ 城的士兵全部位于 $B$ 城士兵的左侧。

对于每一行，城墙只可能出现在 $A$ 城士兵与 $B$ 城士兵的中间，即城墙的左侧只可能有 $A$ 城士兵，城墙的右侧只可能有 $B$ 城士兵。且，同一行最多有 $1$ 个方格是城墙。

激战开始，士兵们会根据地形指定战略。对于**每一行**：

- 如果该行有城墙，则士兵们会往自己城市方向后撤，在边界处整齐地排列。例如，若这一行初始时为 `#A#AH#B#`，则后撤后这一行变为 `AA##H##B`。
- 否则，双方会进攻。对于人数较少的一方，士兵会全部倒下，从战场中消失。而另一方不会有士兵倒下，并且会冲至对方城市的方向，在边界处整齐地排列。例如，若这一行初始时为 `#A##B#B#`，则进攻后这一行变为 `BB######`。特别地，如果这一行双方人数相等，则这一行所有士兵都会倒下。

随后激战结束。对于每个士兵会**同时**进行如下判断：
- 如果他的上方或下方有友方的士兵与他相邻，则他会从战场中消失，否则原地不动。

现在给你初始时的战场局面，请你输出最后战场的组成。

## 说明/提示

### 样例 #1 解释

激战结束后，战场的情况为

```cpp
AA##H##B
BB######
########
#####AAA
####AAAA
```

右下角的 `A` 中，除了第 $5$ 行第 $5$ 列的 `A` 以外，下方或者上方都存在友方的士兵，故他们最终从战场中消失。最后战场如样例输出所示。
### 样例 #2 解释

注意只有在上方或下方有**相邻**的友方士兵时士兵才会从战场消失。
### 数据范围

对于所有数据，$1\le n,m\le 1000$，$s_{i,j}$ 为 `A`、`B`、`H`、`#` 中的一个，且每一行满足题目中的限制。具体测试点限制如下：

| 测试点编号 | $n$ 的范围 | $m$ 的范围 | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1\sim 3$ | $n=1$ | $m\le100$ | 无 |
| $4\sim 6$ | $n\le100$ | $m=1$ | 无 |
| $7\sim 10$ | $n\le 100$ | $m\le100$ | $s_{i,j}$ 不为 `H` |
| $11\sim 14$ | $n\le 100$ | $m\le100$ | $s_{i,j}$ 不为 `B`|
| $15,16$ | $n\le100$ | $m\le 100$ | 无 |
| $17\sim 20$ | $n\le 1000$ | $m\le1000$ | 无 |


## 样例 #1

### 输入

```
5 8
#A#AH#B#
#A##B#B#
##AA##BB
AAA###BB
AAA#ABBB
```

### 输出

```
AA##H##B
BB######
########
########
####A###
```

## 样例 #2

### 输入

```
3 2
#A
##
#A
```

### 输出

```
#A
##
#A
```

## 样例 #3

### 输入

```
3 3
AAB
A#B
ABB
```

### 输出

```
#AA
###
BB#
```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
本题的核心逻辑是通过模拟战场的变化过程，逐步处理每一行的士兵和城墙，最终输出战场的最终状态。题解的关键在于如何处理每一行的士兵和城墙，并在激战结束后根据士兵的上下相邻情况决定是否消失。题解通过遍历每一行，统计士兵和城墙的数量，并根据规则进行相应的处理，最后再遍历整个战场，判断每个士兵是否需要消失。

### 所选题解
#### 题解作者：未来姚班zyl
- **星级**: 4星
- **关键亮点**: 
  - 清晰地分步骤处理每一行的士兵和城墙，逻辑清晰。
  - 代码结构合理，易于理解和维护。
  - 通过布尔变量 `fl` 来判断士兵是否需要消失，简化了判断逻辑。

### 核心代码片段
```cpp
for(int i=1;i<=n;i++){
    int ca=0,cb=0,ch=0;
    for(int j=1;j<=m;j++){
        if(c[i][j]=='A')ca++;
        else if(c[i][j]=='B')cb++;
        else if(c[i][j]=='H')ch++;
    }
    if(ch){
        for(int j=1;j<=m;j++)if(c[i][j]!='H')c[i][j]='#';
        for(int j=1;j<=ca;j++)c[i][j]='A';
        for(int j=m-cb+1;j<=m;j++)c[i][j]='B';
    }else {
        if(ca==cb)for(int j=1;j<=m;j++)c[i][j]='#';
        else if(ca>cb){
            for(int j=1;j<=m;j++)c[i][j]='#';
            for(int j=m-ca+1;j<=m;j++)c[i][j]='A';
        }else {
            for(int j=1;j<=m;j++)c[i][j]='#';
            for(int j=1;j<=cb;j++)c[i][j]='B';
        }
    }
}
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(c[i][j]=='#'||c[i][j]=='H')cout<<c[i][j];
        else {
            bool fl=0;
            if(i>1)fl|=c[i-1][j]==c[i][j];
            if(i<n)fl|=c[i+1][j]==c[i][j];
            if(fl)cout<<"#";
            else cout<<c[i][j];
        }
    }
    cout <<'\n';
}
```

### 关键思路与技巧
1. **分步处理**: 首先处理每一行的士兵和城墙，再处理整个战场的士兵消失情况，分步骤进行，逻辑清晰。
2. **布尔变量简化判断**: 使用布尔变量 `fl` 来判断士兵是否需要消失，简化了判断逻辑，代码更加简洁。
3. **边界处理**: 在处理士兵消失时，注意边界条件，避免数组越界。

### 可拓展之处
- **类似题目**: 可以扩展到其他需要模拟过程的题目，如棋盘游戏、物理模拟等。
- **优化思路**: 在处理大规模数据时，可以考虑并行处理或优化数据结构，提高效率。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

---
处理用时：22.48秒
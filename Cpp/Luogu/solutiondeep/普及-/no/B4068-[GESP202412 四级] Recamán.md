# 题目信息

# [GESP202412 四级] Recamán

## 题目描述

小杨最近发现了有趣的 Recamán 数列，这个数列是这样生成的：

- 数列的第一项 $a_1$ 是 $1$；
- 如果 $a_{k-1}-k$ 是正整数并且没有在数列中出现过，那么数列的第 $k$ 项 $a_k$ 为 $a_{k-1}-k$，否则为 $a_{k-1}+k$。

小杨想知道 Recamán 数列的前 $n$ 项从小到大排序后的结果。手动计算非常困难，小杨希望你能帮他解决这个问题。

## 说明/提示

#### 样例解释

对于样例 1，$n=5$：
- $a_1=1$；
- $a_1-2=-1$，不是正整数，因此 $a_2=a_1+2=3$；
- $a_2-3=0$，不是正整数，因此 $a_3=a_2+3=6$；
- $a_3-4=2$，是正整数，且没有在数列中出现过，因此  $a_4=a_3-4=2$；
- $a_4-5=-3$，不是正整数，因此 $a_5=a_4+5=7$。

$a_1,a_2,a_3,a_4,a_5$ 从小到大排序的结果为 $1,2,3,6,7$。

#### 数据范围

对于所有数据点，保证 $1\le n\le 3\, 000$。

## 样例 #1

### 输入

```
5```

### 输出

```
1 2 3 6 7```

## 样例 #2

### 输入

```
8```

### 输出

```
1 2 3 6 7 12 13 20```

# AI分析结果

### 算法分类
递推

### 综合分析与结论
本题的核心是生成 Recamán 数列，并对其进行排序。生成数列的过程涉及递推和哈希表（桶思想）的使用，难点在于如何高效判断某个数是否已经出现在数列中。题解中使用了 `vis` 数组来记录数字是否出现过，并通过简单的数学推理确定了 `vis` 数组的大小上限。排序部分则采用了选择排序，虽然效率不高，但在数据范围较小的情况下是可行的。

### 所选题解
#### 题解作者：chen_zhe (赞：5)
- **星级**：4星
- **关键亮点**：
  - 使用桶思想（`vis` 数组）高效判断数字是否出现过。
  - 通过数学推理确定了 `vis` 数组的大小上限，避免了不必要的内存浪费。
  - 提供了选择排序的实现，虽然效率不高，但在小数据范围内可行。
- **个人心得**：通过实际运行程序确定了 `vis` 数组的大小上限，避免了过度估计。

### 核心代码片段
```cpp
a[1] = vis[1] = 1;
for (int i = 2; i <= n; i++) {
    if (a[i - 1] - i >= 1 && !vis[a[i - 1] - i])
        a[i] = a[i - 1] - i;
    else
        a[i] = a[i - 1] + i;
    vis[a[i]] = 1;
}

for (int i = 1; i <= n; i++) {
    int mx = a[i], id = i;
    for (int j = i + 1; j <= n; j++) {
        if (a[j] < mx) {
            mx = a[j];
            id = j;
        }
    }
    swap(a[i], a[id]);
}
```

### 关键思路与技巧
1. **桶思想**：使用 `vis` 数组记录数字是否出现过，避免了重复计算。
2. **数学推理**：通过简单的数学推理确定了 `vis` 数组的大小上限，避免了不必要的内存浪费。
3. **选择排序**：虽然效率不高，但在小数据范围内可行，且代码简单易懂。

### 拓展思路
- **优化排序**：可以使用更高效的排序算法（如快速排序、归并排序）来提高排序效率。
- **动态调整 `vis` 数组大小**：可以根据实际生成的数列动态调整 `vis` 数组的大小，进一步节省内存。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 递推与动态规划
2. P1219 八皇后 - 递归与回溯
3. P1036 选数 - 递推与组合数学

---
处理用时：18.34秒
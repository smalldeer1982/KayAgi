# 题目信息

# [CSP-X2024 山东] 购物

## 题目描述

双十一，很多人在疯狂地购物。

商家推出了各种各样的优惠活动，吸引顾客购买更多的商品。

某商家推出如下的优惠活动：

该商家共有 $n$ 件商品，单独购买第 $i$ 件商品的费用为 $a_i$。顾客也可以花费 $w$ 购买 一张优惠券，一张优惠券最多可兑换 $m$ 件商品（无需额外付费）。顾客可以购买任意张优惠券；

如果最后商品不足 $m$ 件，优惠券也可以使用。

求顾客购买完所有 $n$ 件商品的最小费用。



## 说明/提示

### 样例解释

样例 $1$ 说明：

花费 $8$ 买一张优惠券，兑换第 $2$、第 $4$ 件商品；第 $1$、第 $3$、第 $5$ 件商品直接购买。

共花费 $8 + 2 + 1 + 4 = 15$。

样例 $2$ 说明：

花费 $16$ 购买两张优惠券，能兑换所有商品。

### 数据范围

对于 $30\%$ 的数据，满足 $1 \leq n \leq 10^3,1 \leq m \leq 10^3,1 \leq w \leq 10^9,1 \leq a_i \leq 10^9$。

对于 $100\%$ 的数据，满足 $1 \leq n \leq 2 \times 10^5,1 \leq m \leq 2 \times 10^5,1 \leq w \leq 10^9,1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5 2 8
2 7 1 8 4```

### 输出

```
15```

## 样例 #2

### 输入

```
5 3 8
6 7 4 8 9```

### 输出

```
16```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
本题的核心是通过贪心策略来最小化购买所有商品的总费用。主要思路是将商品价格从大到小排序，然后每 $m$ 个商品为一组，比较这组商品的总价与优惠券的价格，选择更便宜的方案。难点在于如何处理最后一组不足 $m$ 个商品的情况，以及如何高效地计算每组的和。

### 所选题解
1. **作者：lam_dyr (赞：5)**
   - **星级：5**
   - **关键亮点：**
     - 代码简洁明了，逻辑清晰。
     - 通过降序排序和分组计算，直接比较每组的总价与优惠券价格，选择更优方案。
     - 处理了最后一组不足 $m$ 个商品的情况。
   - **核心代码：**
     ```cpp
     sort(a+1,a+1+n,greater<int>());
     for(int i=1;i<=n;++i){
         cnt+=a[i];
         if(i%m==0){
             if(cnt>w) ans+=w;
             else ans+=cnt;
             cnt=0;
         }
     }
     if(cnt>w) ans+=w;
     else ans+=cnt;
     ```

2. **作者：easy42 (赞：3)**
   - **星级：4**
   - **关键亮点：**
     - 使用优先队列（大根堆）来动态获取当前最贵的 $m$ 个商品。
     - 处理了剩余商品不足 $m$ 个的情况。
   - **核心代码：**
     ```cpp
     while(1){
         int ans=0;
         if(q.size()<m){
             while(!q.empty()) ans+=q.top(),q.pop();
             cnt+=min(ans,w);
             break;
         }
         for(int i=1;i<=m;i++){
             ans+=q.top();
             q.pop();
         }
         if(ans>w) cnt+=w;
         else cnt+=ans;
     }
     ```

3. **作者：mairuisheng (赞：2)**
   - **星级：4**
   - **关键亮点：**
     - 通过从大到小排序和分组计算，直接比较每组的总价与优惠券价格。
     - 处理了最后一组不足 $m$ 个商品的情况。
   - **核心代码：**
     ```cpp
     sort(p+1,p+1+n);
     i=n;
     while(i>0){
         t=0;
         for(j=i;j>max(0,i-m);--j) t+=p[j];
         if(t<w) break;
         ans+=w;
         i=i-m;
     }
     for(j=i;j>0;--j) ans+=p[j];
     ```

### 最优关键思路或技巧
1. **排序与分组**：将商品价格从大到小排序，每 $m$ 个商品为一组，比较每组的总价与优惠券价格，选择更优方案。
2. **处理剩余商品**：最后一组不足 $m$ 个商品时，直接比较这组的总价与优惠券价格，选择更优方案。
3. **优先队列**：使用优先队列（大根堆）动态获取当前最贵的 $m$ 个商品，适用于动态数据场景。

### 可拓展之处
1. **动态数据场景**：如果商品价格是动态变化的，可以使用优先队列来实时获取当前最贵的 $m$ 个商品。
2. **多优惠券类型**：如果有多种优惠券，每种优惠券的价格和可兑换的商品数量不同，可以扩展为多维度贪心问题。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1208 [USACO1.3]混合牛奶 Mixing Milk](https://www.luogu.com.cn/problem/P1208)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

### 个人心得摘录
- **lam_dyr**：通过降序排序和分组计算，直接比较每组的总价与优惠券价格，选择更优方案，代码简洁明了。
- **easy42**：使用优先队列（大根堆）来动态获取当前最贵的 $m$ 个商品，处理了剩余商品不足 $m$ 个的情况，逻辑清晰。
- **mairuisheng**：通过从大到小排序和分组计算，直接比较每组的总价与优惠券价格，处理了最后一组不足 $m$ 个商品的情况，代码简洁。

---
处理用时：31.93秒
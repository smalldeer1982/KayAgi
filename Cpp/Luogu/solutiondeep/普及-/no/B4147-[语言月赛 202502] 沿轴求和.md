# 题目信息

# [语言月赛 202502] 沿轴求和

## 题目描述

给定一个高维数组 $a$，该数组共有 $n$ 维，大小为 $d_0\times d_1\times \cdots \times d_{n-1}$。其中，每一维称为一个轴，$d_i$ 对应 $i(0 \le i < n)$ 号轴。数组下标从 $0$ 开始。

高维数组沿 $x$ 号轴的求和结果，是一个 $n-1$ 维的数组 $S$，其大小为 $d_0\times d_1 \times \cdots \times d_{x-1} \times d_{x+1} \times \cdots \times d_{n-1}$。其中，

$$
S[w_0][w_1]\cdots[w_{x-1}][w_{x+1}]\cdots[w_{n-1}]=\sum\limits_{i=0}^{d_x-1}{a[w_0][w_1]\cdots[w_{x-1}][i][w_{x+1}]\cdots[w_{n-1}]}
$$

现在，给定该高维数组与 $x$，求沿 $x$ 号轴求和的结果。



## 说明/提示

### 样例解释 1

样例 1 给出了一个二维数组，其大小为 $2\times 2$，沿 1 号轴求和。在二维数组中，按 0 号轴求和可理解为按列求和，按 1 号轴求和可理解为按行求和。

$$
\begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix}
\rightarrow
\begin{bmatrix}
3 & 7
\end{bmatrix}
$$

### 样例解释 2

样例 2 给出了一个三维数组，其大小为 $2\times 2\times 2$。沿 0 号轴求和的结果大小为 $2\times 2$。

以 $S[0][0]$ 的计算方式为例：

$$
S[0][0]=\sum\limits_{i=0}^1{a[i][0][0]=a[0][0][0]+a[1][0][0]=1+5=6}
$$

可以得到结果为

$$
\begin{bmatrix}
6 & 8\\
10 & 12
\end{bmatrix}
$$

### 数据规模与约定

- 对于 $60\%$ 的测试数据，保证 $n=2$。
- 对于 $100\%$ 的测试数据，保证 $2 \le n \le 16$，$1 \le d_i \le 10^3$，$1 \le \prod\limits_{i=0}^{n-1}{d_i} \le 2^{16}$，$-100 \le val \le 100$。保证 $\forall i\in [0,n)$，输入的 $p_i \in [0,d_i)$。

## 样例 #1

### 输入

```
2 1
2 2
0 0 1
0 1 2
1 1 4
1 0 3```

### 输出

```
1 7
0 3```

## 样例 #2

### 输入

```
3 0
2 2 2
0 0 0 1
0 0 1 2
0 1 0 3
0 1 1 4
1 0 0 5
1 0 1 6
1 1 0 7
1 1 1 8```

### 输出

```
0 0 6
0 1 8
1 0 10
1 1 12```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
本题的核心在于如何高效地处理高维数组的求和操作，特别是如何将高维数组映射到一维数组中进行计算。题解中提出的映射方法是一个关键技巧，通过将高维数组的下标映射到一维数组的下标，简化了求和操作。此外，题解还详细解释了如何从一维数组的下标还原出高维数组的下标，这对于输出结果非常重要。

### 所选题解
#### 题解：览遍千秋
- **星级**：4星
- **关键亮点**：
  - 详细解释了高维数组到一维数组的映射方法。
  - 提供了从一维数组下标还原高维数组下标的公式。
  - 通过示例验证了映射和还原方法的正确性。
- **个人心得**：
  - 题解中提到，本题实际上是实现 numpy 中 nparray 的 sum 函数，使用 Python 可以更轻松地完成本题，但 C++ 中通过映射方法也能高效解决。

### 核心代码片段
```cpp
// 映射高维数组到一维数组
int mapTo1D(vector<int>& indices, vector<int>& dimensions) {
    int id = 0;
    for (int i = 0; i < indices.size(); ++i) {
        id = id * dimensions[i] + indices[i];
    }
    return id;
}

// 从一维数组下标还原高维数组下标
vector<int> mapToND(int id, vector<int>& dimensions) {
    vector<int> indices(dimensions.size());
    for (int i = dimensions.size() - 1; i >= 0; --i) {
        indices[i] = id % dimensions[i];
        id /= dimensions[i];
    }
    return indices;
}
```

### 扩展思路
- **同类型题**：处理高维数组的题目，如矩阵乘法、卷积操作等。
- **类似算法套路**：高维数组的映射与还原方法可以应用于其他需要处理高维数据的场景，如图像处理、科学计算等。

### 推荐题目
1. [P1001 A+B Problem](https://www.luogu.com.cn/problem/P1001)
2. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
3. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)

这些题目虽然简单，但涉及到了数组的基本操作和映射思想，适合初学者练习。

---
处理用时：19.22秒
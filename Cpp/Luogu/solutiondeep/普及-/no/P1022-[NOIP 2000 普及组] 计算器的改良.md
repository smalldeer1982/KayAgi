# 题目信息

# [NOIP 2000 普及组] 计算器的改良

## 题目背景

NCL 是一家专门从事计算器改良与升级的实验室，最近该实验室收到了某公司所委托的一个任务：需要在该公司某型号的计算器上加上解一元一次方程的功能。实验室将这个任务交给了一个刚进入的新手 ZL 先生。


## 题目描述

为了很好的完成这个任务，ZL 先生首先研究了一些一元一次方程的实例：

- $4+3x=8$。
- $6a-5+1=2-2a$。
- $-5+12y=0$。

ZL 先生被主管告之，在计算器上键入的一个一元一次方程中，只包含整数、小写字母及 `+`、`-`、`=` 这三个数学符号（当然，符号“`-`”既可作减号，也可作负号）。方程中并没有括号，也没有除号，方程中的字母表示未知数。

你可假设对键入的方程的正确性的判断是由另一个程序员在做，或者说可认为键入的一元一次方程均为合法的，且有唯一实数解。


## 样例 #1

### 输入

```
6a-5+1=2-2a
```

### 输出

```
a=0.750```

# AI分析结果

### 算法分类
**模拟**

### 综合分析与结论
该题目要求解一元一次方程，核心思路是通过模拟方程的解析过程，分别处理未知数的系数和常数项，最终通过移项和合并同类项求解未知数。难点在于处理符号、未知数系数的提取以及特殊情况的处理（如负零问题）。大多数题解通过逐个字符解析方程，使用变量记录符号、系数和常数项，最终通过简单的数学运算求解。

### 所选高星题解

#### 题解1：吴名玄（5星）
**关键亮点**：
- 通过变量`now`和`f`分别记录等号位置和符号，简化了移项和符号处理。
- 引入变量`r`处理特殊情况（如`+x`、`-x`），确保系数正确。
- 特判负零问题，避免输出`-0.0`。

**核心代码**：
```cpp
while(cin>>c) {
    if(c=='-') {b+=now*f*x;x=0;f=-1;r=0;}
    if(c=='+') {b+=now*f*x;x=0;f=1;r=0;}
    if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;r=0;}
    if(c>='a'&&c<='z') {
        if(r) {k+=now*f*x;x=0;}
        else k+=now*f;
        a=c;r=0;
    }
    if(c>='0'&&c<='9') {x=x*10+c-'0';r=1;}
}
b+=now*f*x; // 加上最后一项常数
double ans=double(-b*1.0/k);
if(ans==-0.0) ans=0; // 特判，将-0.0改为0
printf("%c=%.3lf",a,ans);
```

#### 题解2：Jy_Amoy（4星）
**关键亮点**：
- 通过数组存储等号两边的系数和常数项，清晰分离左右两边的处理。
- 使用`mid`变量标记等号位置，简化了移项操作。
- 特判负零问题，确保输出正确。

**核心代码**：
```cpp
for(int i=1;i<=l;++i) {
    if(i<=mid) num-=a[i]; // 等号左边减去
    else num+=a[i]; // 等号右边加上
}
if(!(num/x)) printf("%c=0.000",p); // 特判
else printf("%c=%.3lf",p,num/x);
```

#### 题解3：teafrogsf（4星）
**关键亮点**：
- 使用`cin.peek()`预读下一个字符，简化了符号和数字的处理。
- 通过`flag1`和`flag2`分别处理等号位置和符号，逻辑清晰。
- 特判负零问题，确保输出正确。

**核心代码**：
```cpp
while((c = cin.peek()) != -1) {
    if(c == '=') { flag1 = -flag1; cin.get(); }
    else if(isdigit(c)) {
        cin>>temp; temp = temp*flag1*flag2;
        if(isalpha(cin.peek())) { letter = cin.peek(); coe += temp; cin.get(); }
        else num -= temp;
        flag2 = 1.0;
    }
    else if(c == '-') { flag2 = -1.0; cin.get(); }
    else if(isalpha(c)) { coe += flag1*flag2; flag2 = 1.0; cin.get(); }
    else cin.get();
}
if(num==0) cout<<letter<<'='<<fixed<<setprecision(3)<<0.0;
else cout<<letter<<'='<<fixed<<setprecision(3)<<num/coe;
```

### 最优关键思路
1. **符号处理**：通过变量记录当前符号和等号位置，简化移项和符号处理。
2. **特殊情况处理**：引入变量`r`处理`+x`、`-x`等特殊情况，确保系数正确。
3. **负零特判**：通过特判避免输出`-0.0`，确保输出格式正确。

### 可拓展之处
- 类似问题可以扩展到多元一次方程或更高次方程的求解，需要更复杂的符号处理和系数提取。
- 可以结合字符串处理技巧，处理更复杂的数学表达式。

### 推荐题目
1. [P1023 计算器的改良（升级版）](https://www.luogu.com.cn/problem/P1023)
2. [P1024 一元二次方程求解](https://www.luogu.com.cn/problem/P1024)
3. [P1025 字符串解析](https://www.luogu.com.cn/problem/P1025)

### 个人心得摘录
- **吴名玄**：通过引入变量`r`处理特殊情况，避免了复杂的逻辑判断，代码简洁高效。
- **Jy_Amoy**：使用数组存储系数和常数项，清晰分离左右两边的处理，逻辑清晰。
- **teafrogsf**：通过`cin.peek()`预读字符，简化了符号和数字的处理，代码逻辑清晰。

---
处理用时：38.00秒
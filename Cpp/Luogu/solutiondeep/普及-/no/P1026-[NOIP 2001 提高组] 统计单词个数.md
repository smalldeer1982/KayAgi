# 题目信息

# [NOIP 2001 提高组] 统计单词个数

## 题目描述

给出一个长度不超过 $200$ 的由小写英文字母组成的字母串（该字串以每行 $20$ 个字母的方式输入，且保证每行一定为 $20$ 个）。要求将此字母串分成
 $k$ 份，且每份中包含的单词个数加起来总数最大。  

每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串 `this` 中可包含 `this` 和 `is`，选用 `this` 之后就不能包含
 `th`。

单词在给出的一个不超过 $6$ 个单词的字典中。

要求输出最大的个数。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$2 \le k \le 40$，$1 \le s \le 6$。

【样例解释】
划分方案为 this / isabookyoua / reaoh

**【题目来源】**

NOIP 2001 提高组第三题

## 样例 #1

### 输入

```
1 3
thisisabookyouareaoh
4
is
a
ok
sab
```

### 输出

```
7
```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
该题的核心思路是通过动态规划（DP）来解决问题。具体来说，题目要求将一个字符串分成k份，使得每份中包含的单词个数总和最大。难点在于如何高效地计算每个区间内的单词个数，并且在分割时确保每个单词的第一个字母只能被使用一次。

### 所选题解
#### 题解作者：千反田 (赞：5)
- **星级**: 5星
- **关键亮点**: 
  - 使用了动态规划的思路，将问题转化为在字符串中放置分割线的问题。
  - 详细解释了状态转移方程和初始化过程。
  - 提供了如何计算区间内单词个数的具体实现方法，并考虑了单词重叠的情况。
  - 代码结构清晰，注释详细，便于理解和学习。

- **个人心得**: 
  - 作者提到第一次提交时忘记注释掉调试代码，但仍然获得了20分，说明评测机的容错性较高。
  - 通过手写max和min函数来提高代码执行效率，体现了对性能优化的关注。

### 核心代码片段
```cpp
void calc(){
    rep(i,1,n-1)
     f[i][1]=query(1,i);
    rep(j,2,k)
     rep(i,j,n-1)
      rep(l,j-1,i-1)
       f[i][j]=max(f[i][j],f[l][j-1]+query(l+1,i));
    rep(i,k,n-k)
     ans=max(ans,f[i][k]+query(i+1,n));
}
```
- **核心实现思想**: 
  - `f[i][j]`表示在第i个字母后放置第j个分割线时，前i个字母所能获得的最大单词个数。
  - 通过三层循环来实现状态转移，第一层循环枚举分割线的位置，第二层循环枚举当前分割线的编号，第三层循环枚举从前面的哪个状态转移过来。
  - 最后在所有可能的分割方案中取最大值作为最终答案。

### 拓展思路
- **同类型题**: 
  - [P1018 乘积最大](https://www.luogu.org/problem/P1018)
  - [P1040 加分二叉树](https://www.luogu.org/problem/P1040)
  - [P1044 栈](https://www.luogu.org/problem/P1044)

### 推荐题目
1. [P1018 乘积最大](https://www.luogu.org/problem/P1018)
2. [P1040 加分二叉树](https://www.luogu.org/problem/P1040)
3. [P1044 栈](https://www.luogu.org/problem/P1044)

这些题目都涉及到动态规划的应用，适合进一步巩固和拓展相关知识。

---
处理用时：22.11秒
# 题目信息

# [NOIP 2001 提高组] Car 的旅行路线

## 题目描述

又到暑假了，住在城市 A 的 Car 想和朋友一起去城市旅游。  
她知道每个城市都有 $4$ 个飞机场，分别位于一个矩形的 $4$ 个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第 $i$ 个城市中高速铁路的单位里程价格为 $T_i$，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为 $t$。


![](https://cdn.luogu.com.cn/upload/image_hosting/odqxn9sz.png)

**注意**：图中并没有标出所有的铁路与航线。


那么 Car 应如何安排到城市 B 的路线才能尽可能的节省花费呢？她发现这并不是一个简单的问题，于是她来向你请教。


找出一条从城市 A 到 B 的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10$，$1\le S \le 100$，$1\le A,B \le S$。

**【题目来源】**

NOIP 2001 提高组第四题

## 样例 #1

### 输入

```
1
3 10 1 3
1 1 1 3 3 1 30
2 5 7 4 5 2 1
8 6 8 8 11 6 3```

### 输出

```
47.5```

# AI分析结果

### 算法分类
最短路

### 综合分析与结论
本题的核心是通过图论中的最短路算法（如Floyd、Dijkstra、SPFA等）来求解从城市A到城市B的最小花费路径。难点在于如何根据给定的三个机场坐标推导出第四个机场的坐标，并正确构建图的边权（即不同机场之间的花费）。各题解的主要思路如下：

1. **建图**：通过几何知识推导出第四个机场的坐标，并根据机场是否在同一城市来设置边权（铁路或航线）。
2. **最短路算法**：使用Floyd、Dijkstra或SPFA等算法求解最短路。
3. **优化**：部分题解通过堆优化Dijkstra或SPFA来提高效率。

### 所选高星题解

#### 题解1：作者：_jimmywang_ (5星)
**关键亮点**：
- 详细解释了如何通过几何知识推导出第四个机场的坐标。
- 使用Floyd算法求解最短路，代码简洁且易于理解。
- 通过勾股定理判断直角点，逻辑清晰。

**核心代码**：
```cpp
double diss(double x1,double y1,double x2,double y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
double ds(double x1,double y1,double x2,double y2){return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);}
void getair4(int id){
    double d12=ds(x[(id-1)*4+1],y[(id-1)*4+1],x[(id-1)*4+2],y[(id-1)*4+2]);
    double d23=ds(x[(id-1)*4+2],y[(id-1)*4+2],x[(id-1)*4+3],y[(id-1)*4+3]);
    double d13=ds(x[(id-1)*4+1],y[(id-1)*4+1],x[(id-1)*4+3],y[(id-1)*4+3]);
    if(d12+d13==d23)x[id*4]=x[(id-1)*4+2]+x[(id-1)*4+3]-x[(id-1)*4+1],y[id*4]=y[(id-1)*4+2]+y[(id-1)*4+3]-y[(id-1)*4+1];
    else if(d12+d23==d13)x[id*4]=x[(id-1)*4+1]+x[(id-1)*4+3]-x[(id-1)*4+2],y[id*4]=y[(id-1)*4+1]+y[(id-1)*4+3]-y[(id-1)*4+2];
    else if(d23+d13==d12)x[id*4]=x[(id-1)*4+2]+x[(id-1)*4+1]-x[(id-1)*4+3],y[id*4]=y[(id-1)*4+2]+y[(id-1)*4+1]-y[(id-1)*4+3];
}
```

#### 题解2：作者：ShineEternal (4星)
**关键亮点**：
- 使用Dijkstra算法求解最短路，并通过堆优化提高效率。
- 详细解释了如何通过矩形对角线性质推导出第四个机场的坐标。
- 代码结构清晰，注释详细。

**核心代码**：
```cpp
void find(double a,double b,double c,double d,double e,double f){
    cnt++;
    dis[1].num=sqrt(Sqr(a-c)+Sqr(b-d)); 
    dis[1].id=1;
    dis[2].num=sqrt(Sqr(e-c)+Sqr(f-d)); 
    dis[2].id=2;
    dis[3].num=sqrt(Sqr(a-e)+Sqr(b-f));
    dis[3].id=3;
    sort(dis+1,dis+4,cmp);
    if(dis[1].id==1){
        double x=min(a,c)+Abs(a-c)/2;
        double y=min(b,d)+Abs(b-d)/2;
        double xn=x+x-e;
        double yn=y+y-f;
        p[cnt].x=xn;
        p[cnt].y=yn;
    }
    // 其他情况类似
}
```

#### 题解3：作者：rediserver (4星)
**关键亮点**：
- 使用Dijkstra算法求解最短路，并通过将起点城市的4个机场的cost设为0来处理多起点问题。
- 通过几何知识推导出第四个机场的坐标，逻辑清晰。
- 代码结构合理，注释详细。

**核心代码**：
```cpp
float CarRoute::dijkstra(int src_city, int des_city) {
    float *cost = new float[nAirports_]; 
    bool *collected = new bool[nAirports_];
    fill(cost, cost + nAirports_, NO_VALUE);
    fill(collected, collected + nAirports_, false);
    for (int i = 0; i < 4; i++) 
        cost[GET_AIRPORT_INDEX(src_city, i)] = 0;
    while (true) {
        int minV = NO_VALUE;
        float minCost = NO_VALUE;
        for (int i = 0; i < nAirports_; i++)
            if (!collected[i] && cost[i] != NO_VALUE && (cost[i] < minCost || minCost == NO_VALUE)) {
                minV = i;
                minCost = cost[i];
            }
        int minCity = GET_CITY_INDEX(minV); 
        if (minCity == des_city) { 
            free(cost);
            free(collected);
            return minCost;
        }
        if (minV == NO_VALUE) break;
        collected[minV] = true; 
        for (int i = 0; i < nAirports_; i++) 
            if (!collected[i]) {
                float dist = getAirportDist(airports_[minV], airports_[i]); 
                float cost_tmp = GET_CITY_INDEX(i) == minCity ? dist * cost_train_[minCity] : dist * cost_air_;
                if (minCost + cost_tmp < cost[i] || cost[i] == NO_VALUE) { 
                    cost[i] = minCost + cost_tmp; 
                }
            }
    } 
    free(cost);
    free(collected);
    return NO_VALUE;
}
```

### 最优关键思路或技巧
1. **几何推导**：通过矩形的对角线性质推导出第四个机场的坐标，是本题的关键步骤。
2. **多起点处理**：对于起点城市的多个机场，可以通过将它们的初始cost设为0来处理多起点问题。
3. **最短路算法选择**：根据数据范围选择合适的算法，如Floyd适用于小规模数据，Dijkstra适用于大规模数据。

### 可拓展之处
类似的问题可以拓展到更复杂的图论问题，如多起点多终点的最短路问题，或者边权动态变化的最短路问题。

### 推荐题目
1. P3371 【模板】单源最短路径（弱化版）
2. P4779 【模板】单源最短路径（标准版）
3. P1144 最短路计数

### 个人心得
- **调试经历**：在处理多起点问题时，需要特别注意初始化的方式，避免遗漏某些起点。
- **踩坑教训**：在推导第四个机场坐标时，容易忽略直角点的判断，导致坐标计算错误。

---
处理用时：59.78秒
# 题目信息

# [NOIP 2001 普及组] 最大公约数和最小公倍数问题

## 题目描述

输入两个正整数 $x_0, y_0$，求出满足下列条件的 $P, Q$ 的个数：

1. $P,Q$ 是正整数。

2. 要求 $P, Q$ 以 $x_0$ 为最大公约数，以 $y_0$ 为最小公倍数。

试求：满足条件的所有可能的 $P, Q$ 的个数。

## 说明/提示

$P,Q$ 有 $4$ 种：

1. $3, 60$。
2. $15, 12$。
3. $12, 15$。
4. $60, 3$。

对于 $100\%$ 的数据，$2 \le x_0, y_0 \le {10}^5$。

**【题目来源】**

NOIP 2001 普及组第二题

## 样例 #1

### 输入

```
3 60
```

### 输出

```
4
```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
该题的核心在于利用最大公约数（GCD）和最小公倍数（LCM）之间的关系，即 $a \times b = \gcd(a, b) \times \operatorname{lcm}(a, b)$。通过这一关系，可以将问题转化为枚举 $P \times Q$ 的因数，并判断其是否满足给定的 GCD 和 LCM 条件。大多数题解都采用了这一思路，并通过优化枚举范围（如只枚举到 $\sqrt{P \times Q}$）来减少时间复杂度。此外，部分题解还讨论了特殊情况（如 $P = Q$）的处理。

### 所选高星题解
1. **樱雪喵 (5星)**
   - **关键亮点**：通过枚举到 $\sqrt{P \times Q}$ 来优化时间复杂度，并处理了 $P = Q$ 的特殊情况。代码简洁且高效。
   - **代码片段**：
     ```cpp
     #include<bits/stdc++.h>
     using namespace std;
     long long m,n,ans;
     int main(){
         cin>>m>>n;
         if(m==n) ans--;
         n*=m;
         for(long long i=1;i<=sqrt(n);i++){
             if(n%i==0&&__gcd(i,n/i)==m) ans+=2;
         }
         cout<<ans;
         return 0;
     }
     ```
   - **个人心得**：强调了枚举到 $\sqrt{n}$ 的重要性，避免了重复计算。

2. **sochiji (4星)**
   - **关键亮点**：通过算术基本定理和素因数分解，详细解释了 GCD 和 LCM 的关系，并提供了清晰的数学推导。
   - **代码片段**：
     ```cpp
     #include <iostream>
     int main() {
         int x, y;
         std::cin >> x >> y;
         if (y % x != 0)
             std::cout << 0;
         else {
             int quotient = y / x;
             int count = 0;
             int currentFactor = 2;
             while (quotient > 1) {
                 if (quotient % currentFactor == 0) {
                     count++;
                     while (quotient % currentFactor == 0)
                         quotient /= currentFactor;
                 }
                 currentFactor++;
             }
             std::cout << (1 << count);
         }
         return 0;
     }
     ```
   - **个人心得**：通过素因数分解的方法，简化了问题的复杂度。

3. **zhangboju (4星)**
   - **关键亮点**：通过辗转相除法求 GCD，并详细证明了 GCD 和 LCM 的关系，代码实现清晰。
   - **代码片段**：
     ```cpp
     #include <bits/stdc++.h>
     using namespace std;
     int x,y;
     inline int gcd(int x,int y) {
         if(y==0) return x;
         return gcd(y,x%y);
     }
     int main() {
         cin>>x>>y;
         int ans=0;
         for(int i=1;i<=sqrt(x*y);i++) {
             if(x*y%i==0&&gcd(i,x*y/i)==x) ans++;
         }
         cout<<ans*2;
         return 0;
     }
     ```
   - **个人心得**：通过递归实现 GCD，代码简洁且易于理解。

### 最优关键思路
- **优化枚举范围**：只枚举到 $\sqrt{P \times Q}$，避免重复计算。
- **特殊情况处理**：处理 $P = Q$ 的情况，避免重复计数。
- **数学关系利用**：利用 $a \times b = \gcd(a, b) \times \operatorname{lcm}(a, b)$ 的关系，简化问题。

### 拓展思路
- **同类型题**：类似的问题可以通过素因数分解或枚举因数的方法来解决。
- **算法套路**：在处理涉及 GCD 和 LCM 的问题时，通常可以利用它们的数学关系来简化问题。

### 推荐题目
1. [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)
2. [P1068 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1068)
3. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)

---
处理用时：34.89秒
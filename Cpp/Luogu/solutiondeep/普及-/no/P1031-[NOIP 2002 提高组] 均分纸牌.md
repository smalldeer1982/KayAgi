# 题目信息

# [NOIP 2002 提高组] 均分纸牌

## 题目描述

有 $N$ 堆纸牌，编号分别为 $1,2,\ldots,N$。每堆上有若干张，但纸牌总数必为 $N$ 的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 $N$ 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如 $N=4$ 时，$4$ 堆纸牌数分别为 $9,8,17,6$。

移动 $3$ 次可达到目的：

- 从第三堆取 $4$ 张牌放到第四堆，此时每堆纸牌数分别为 $9,8,13,10$。
- 从第三堆取 $3$ 张牌放到第二堆，此时每堆纸牌数分别为 $9,11,10,10$。
- 从第二堆取 $1$ 张牌放到第一堆，此时每堆纸牌数分别为  $10,10,10,10$。


## 说明/提示

对于 $100\%$ 的数据，$1  \le  N  \le  100$，$1 \le  A_i  \le 10000$。

**【题目来源】**

NOIP 2002 提高组第一题

## 样例 #1

### 输入

```
4
9 8 17 6
```

### 输出

```
3
```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
本题的核心思路是通过贪心算法，从左到右依次调整每堆纸牌的数量，使其达到平均值。具体来说，每堆纸牌与平均值的差值由下一堆纸牌承担，直到所有堆的纸牌数都等于平均值。这种方法保证了移动次数最少，且时间复杂度为O(n)。

### 所选高星题解
1. **作者：monell**  
   - **星级：5星**  
   - **关键亮点**：提供了线性算法和分治算法的详细解释，并给出了线性算法的正确性证明。  
   - **个人心得**：通过分治算法的正确性推导出线性算法的正确性，思路清晰且严谨。  
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         if (a[i] != avg) {
             a[i+1] += a[i] - avg;
             ans++;
         }
     }
     ```

2. **作者：ProtectEMmm**  
   - **星级：4星**  
   - **关键亮点**：详细解释了贪心算法的正确性，并提出了不允许牌堆为负数的限制，最终证明贪心算法仍然有效。  
   - **核心代码**：
     ```cpp
     for (int i = 1; i + 1 <= n; ++i) {
         if (arr[i] != average) {
             ans++, arr[i + 1] += arr[i] - average;
         }
     }
     ```

3. **作者：__yiLIUyi__**  
   - **星级：4星**  
   - **关键亮点**：通过贪心算法的逐步推导，解释了为什么每次只能从当前堆向下一堆移动纸牌，思路清晰。  
   - **核心代码**：
     ```cpp
     for (ll i = 1; i < n; i++) {
         if (a[i] == num) continue;
         a[i+1] += (a[i] - num);
         a[i] = num;
         ans++;
     }
     ```

### 最优关键思路
从左到右遍历每堆纸牌，将当前堆与平均值的差值传递给下一堆，直到所有堆的纸牌数都等于平均值。这种方法保证了移动次数最少，且时间复杂度为O(n)。

### 可拓展之处
类似的问题可以通过贪心算法解决，例如“负载平衡问题”（P4016），也可以通过类似的思路进行调整。

### 推荐题目
1. [P4016 负载平衡问题](https://www.luogu.com.cn/problem/P4016)
2. [P1034 矩形覆盖](https://www.luogu.com.cn/problem/P1034)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

---
处理用时：24.16秒
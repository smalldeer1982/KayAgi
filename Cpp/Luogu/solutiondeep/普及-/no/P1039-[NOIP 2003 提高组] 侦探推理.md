# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！



## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
本题的核心是通过枚举罪犯和星期几，结合证词判断每个人是否说谎，最终确定罪犯。由于题目涉及大量的字符串处理和逻辑判断，因此模拟是最合适的算法分类。题解中，大部分作者采用了枚举+模拟的思路，通过枚举罪犯和星期几，逐一验证证词的真假，最终得出结果。

### 所选题解
1. **作者：Drifterming (赞：89)**
   - **星级：5星**
   - **关键亮点**：代码结构清晰，逻辑严谨，通过枚举罪犯和星期几，逐一验证证词的真假，处理了多种证词类型，并且通过`judgeTF`函数判断证词的真假，避免了重复判断。
   - **个人心得**：作者在代码中详细注释了每一步的逻辑，便于理解，尤其是如何处理证词的真假判断部分。

   **核心代码片段：**
   ```cpp
   bool judgeTF(int id,bool flag) {
       if(TF[id]==-1) {
           TF[id]=flag;
           if(flag) ++T; else ++F;
       } else {
           return TF[id]!=flag;
       }
       if(F>n||T>m-n) return 1;
       return 0;
   }
   ```

2. **作者：wjyyy (赞：18)**
   - **星级：4星**
   - **关键亮点**：通过`std::map`和`std::vector`简化了字符串处理和证词存储，代码简洁且易于扩展。作者还特别强调了证词中每个单词的合法性检查，避免了无效证词的干扰。
   - **个人心得**：作者在博客中详细解释了如何处理证词中的每个单词，确保证词的合法性，这一点在实际应用中非常重要。

   **核心代码片段：**
   ```cpp
   void SetTestimony(int speakerNum, string testimonyWords, TestimonyStruct &testimony) {
       string word1, word2, word3, word4;
       word1 = strtok(&(testimonyWords[0]), " ");
       word2 = strtok(NULL, " ");
       word3 = strtok(NULL, " ");
       if(word3 == "not") word4 = strtok(NULL, " ");
       else word4 = "";
       testimony.SpeakerNum = speakerNum;
       if((word1 == "I") && (word2 == "am") && (word3 == "guilty.")) {
           testimony.Words = IsGuilty;
           testimony.Reverse = NotIsGuilty;
           testimony.PeopleNum = speakerNum;
           testimony.Week = Unknown;
       }
   }
   ```

3. **作者：Setsugesuka (赞：1)**
   - **星级：4星**
   - **关键亮点**：通过结构体`people`和`sentence`清晰地定义了人物和证词的状态，代码结构清晰，逻辑严谨。作者还特别处理了证词中的日期和罪犯判断，确保了逻辑的完整性。
   - **个人心得**：作者在代码中详细注释了每一步的逻辑，便于理解，尤其是如何处理证词的真假判断部分。

   **核心代码片段：**
   ```cpp
   struct people {
       string name;
       bool saidtrue;
       bool saidfalse;
       bool isg;
   };
   struct sentence {
       int whosaid;
       int lx;
       int date;
       int XXX;
   };
   ```

### 通用建议与扩展思路
1. **字符串处理**：在处理证词时，建议使用`std::string`的相关函数（如`find`、`substr`等）来简化字符串的解析。
2. **逻辑判断**：在判断证词真假时，可以通过枚举所有可能的罪犯和星期几，逐一验证，确保逻辑的完整性。
3. **数据结构**：使用`std::map`和`std::vector`来存储和处理证词，可以提高代码的可读性和扩展性。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1019 单词接龙](https://www.luogu.com.cn/problem/P1019)
3. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)

这些题目都涉及字符串处理和逻辑判断，与本题的解题思路相似，适合进一步练习。

---
处理用时：43.48秒
# 题目信息

# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
题目要求在中序遍历固定的情况下，构造一棵加分最高的二叉树，并输出其前序遍历。核心思路是通过动态规划来求解每个区间内的最大加分，并记录对应的根节点，最终通过递归输出前序遍历。难点在于如何设计状态转移方程以及如何处理空子树的情况。

### 所选高星题解

#### 1. 冒泡ioa (5星)
**关键亮点**：
- 详细解释了动态规划的设计思路，特别是状态转移方程的设计。
- 代码简洁明了，处理了空子树的情况，并通过递归输出前序遍历。
- 提供了对动态规划无后效性的解释，帮助理解算法的核心思想。

**核心代码**：
```cpp
for (int len = 1; len < n; ++len) {
    for (int i = 1; i + len <= n; ++i) {
        int j = i + len;
        f[i][j] = f[i + 1][j] + f[i][i]; // 默认左子树为空
        root[i][j] = i; // 默认从起点选根
        for (int k = i + 1; k < j; ++k) {
            if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                root[i][j] = k;
            }
        }
    }
}
```

#### 2. 噬月 (4星)
**关键亮点**：
- 详细讨论了边界处理和等号的影响，分析了不同情况下的计算结果。
- 提供了对状态转移方程的深入分析，特别是如何处理空子树的情况。
- 代码结构清晰，注释详细，便于理解。

**核心代码**：
```cpp
for (int range = 1; range <= n; ++range) {
    for (int i = 1; i + range <= n; ++i) {
        int j = i + range;
        for (int k = i; k <= j; ++k) {
            if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                root[i][j] = k;
            }
        }
    }
}
```

#### 3. Eason_cyx (4星)
**关键亮点**：
- 简洁明了地解释了状态转移方程的设计思路。
- 代码简洁，处理了空子树的情况，并通过递归输出前序遍历。
- 提供了对动态规划无后效性的解释，帮助理解算法的核心思想。

**核心代码**：
```cpp
for(int len = 2;len <= n;len++) {
    for(int i = 1;i + len - 1 <= n;i++) {
        int j = i + len - 1;
        for(int k = i;k <= j;k++) {
            if((f[i][k-1] * f[k+1][j]) > (f[i][j] - d[k])) {
                f[i][j] = (f[i][k-1] * f[k+1][j]) + d[k];
                mx[i][j] = k;
            }
        }
    }
}
```

### 最优关键思路或技巧
1. **状态转移方程**：通过枚举区间内的每个节点作为根节点，计算左右子树的加分，并选择最大值。
2. **空子树处理**：通过初始化 `f[i][i-1] = 1` 和 `f[i+1][i] = 1` 来处理空子树的情况。
3. **前序遍历输出**：通过记录每个区间的根节点，递归输出前序遍历。

### 可拓展之处
类似的问题可以通过区间动态规划来解决，例如合并石子、最优二叉搜索树等。这类问题的核心在于如何设计状态转移方程以及如何处理边界情况。

### 推荐题目
1. [P1880 合并石子](https://www.luogu.com.cn/problem/P1880)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)

### 个人心得
- **调试经历**：在处理空子树时，初始化 `f[i][i-1] = 1` 和 `f[i+1][i] = 1` 是关键，否则会导致计算结果错误。
- **顿悟感想**：动态规划的核心在于如何将问题分解为子问题，并通过状态转移方程逐步求解。理解无后效性是设计动态规划算法的关键。

---
处理用时：35.62秒
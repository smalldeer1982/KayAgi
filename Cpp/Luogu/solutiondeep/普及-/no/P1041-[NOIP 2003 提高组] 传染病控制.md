# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果

### 算法分类
搜索（深度优先搜索 DFS）

### 综合分析与结论
该题目要求在一棵树中，通过切断传播路径来最小化被感染的人数。由于数据范围较小（n ≤ 300），大多数题解采用了深度优先搜索（DFS）的策略，通过枚举每一层的切断点来寻找最优解。部分题解还结合了贪心思想或随机化策略来优化搜索过程。

### 所选高星题解
1. **作者：RikoHere (赞：160)**
   - **星级：4.5**
   - **关键亮点**：详细的分步分析，代码模块化处理，预处理优化，清晰的回溯机制。
   - **个人心得**：强调了分模块处理的重要性，即使简单的处理或回溯也不妨单独多出来一个函数方便进行相关的调试。
   - **核心代码**：
     ```cpp
     void dfs(int cen, int tot) {
         maxx = max(maxx, tot);
         for (int i = 0; i < cnt[cen]; ++i) {
             if (!bol[b[cen][i]]) {
                 int num = clean(b[cen][i]);
                 tot += num;
                 dfs(cen + 1, tot);
                 reclean(b[cen][i]);
                 tot -= num;
             }
         }
     }
     ```
   - **实现思想**：通过预处理确定每个节点的深度和子树大小，然后在DFS中枚举每一层的切断点，并回溯恢复状态。

2. **作者：基础不牢 (赞：138)**
   - **星级：4**
   - **关键亮点**：结构体存储树的信息，分层处理，清晰的搜索框架。
   - **核心代码**：
     ```cpp
     void dfs(int now, int cnt) {
         if (now == maxx) {
             ans = min(ans, cnt);
             return;
         }
         int f = 0;
         for (int i = 1; i <= deep[now][0]; ++i) {
             if (vis[deep[now][i]] > 0) {
                 f++;
                 continue;
             }
             vis[deep[now][i]] = 1;
             work(deep[now][i], 1);
             dfs(now + 1, cnt - count[deep[now][i]]);
             vis[deep[now][i]] = 0;
             work(deep[now][i], 0);
         }
         if (f == deep[now][0]) ans = min(ans, cnt);
     }
     ```
   - **实现思想**：通过分层存储节点信息，并在DFS中枚举每一层的切断点，结合回溯机制更新最小感染人数。

3. **作者：欧鹰 (赞：75)**
   - **星级：4**
   - **关键亮点**：预处理子树大小，分层搜索，清晰的回溯机制。
   - **核心代码**：
     ```cpp
     void dfs1(int deep) {
         for (int i = 1; i <= tt[deep]; i++) {
             if (vis[father[cnt[deep][i]]] == 1) continue;
             dfs2(cnt[deep][i]);
             ans += son[cnt[deep][i]];
             dfs1(deep + 1);
             ans -= son[cnt[deep][i]];
             dfs3(cnt[deep][i]);
         }
         ans1 = max(ans, ans1);
     }
     ```
   - **实现思想**：通过预处理子树大小，分层搜索并回溯，更新最大未被感染人数。

### 最优关键思路或技巧
1. **分层处理**：将树按深度分层，逐层枚举切断点，确保每次切断只影响当前层的传播。
2. **回溯机制**：在DFS中，通过回溯恢复状态，确保每次枚举的独立性。
3. **预处理优化**：提前计算每个节点的子树大小和深度，减少搜索中的重复计算。

### 可拓展之处
该题的搜索策略可以拓展到其他树形结构的问题，如最小覆盖集、最大独立集等。类似的问题可以通过分层处理和回溯机制来解决。

### 推荐题目
1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
2. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)
3. [P2014 选课](https://www.luogu.com.cn/problem/P2014)

---
处理用时：37.02秒
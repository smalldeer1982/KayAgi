# 题目信息

# [NOIP 2012 提高组] 疫情控制

## 题目描述

H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。

H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。


## 说明/提示

【输入输出样例说明】

第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到$ 3$ 号点设立检查点，所需时间为 $3$ 个小时。

 
【数据范围】

保证军队不会驻扎在首都。

- 对于 $20\%$ 的数据，$2 \le n\le 10$；
- 对于 $40\%$ 的数据，$2 \le n\le 50$，$0<w <10^5$；
- 对于 $60\%$ 的数据，$2 \le n\le 1000$，$0<w <10^6$；
- 对于 $80\%$ 的数据，$2 \le n\le 10^4$；
- 对于 $100\%$ 的数据，$2\le m\le n≤5\times 10^4$，$0<w <10^9$。


NOIP 2012 提高组 第二天 第三题


## 样例 #1

### 输入

```
4 
1 2 1 
1 3 2 
3 4 3 
2 
2 2```

### 输出

```
3```

# AI分析结果

### 算法分类
二分、贪心、深度优先搜索 DFS、广度优先搜索 BFS

### 综合分析与结论
该题目要求通过二分答案结合贪心策略来求解最小时间，同时利用DFS和BFS进行树的遍历和状态检查。核心思路是通过二分答案确定最小时间，然后通过贪心策略将军队尽可能向上移动，最后通过DFS和BFS检查是否所有边境城市都被控制。难点在于如何高效地判断某个时间是否可行，以及如何将军队分配到各个子树中。

### 所选题解
1. **作者：TEoS**  
   - **星级：5星**  
   - **关键亮点**：详细解释了二分答案的合理性，结合树上倍增和贪心策略，代码清晰且注释详尽，逻辑严谨。  
   - **个人心得**：作者提到“理解了思路之后实现起来也不会难”，强调了理解思路的重要性。  
   - **核心代码**：
     ```cpp
     bool check(ll lim) {
         memset(sta,0,sizeof(sta));
         memset(tim,0,sizeof(tim));
         memset(ned,0,sizeof(ned));
         memset(h,0,sizeof(h));
         memset(need,0,sizeof(need));
         atot=0,btot=0,ctot=0;
         for(int i=1;i<=m;i++) {
             ll x=query[i],cnt=0;
             for(int j=t;j>=0;j--)
                 if(f[x][j]>1 && cnt+dist[x][j]<=lim) {
                     cnt+=dist[x][j];
                     x=f[x][j];
                 }
             if(f[x][0]==1 && cnt+dist[x][0]<=lim)
                 h[++ctot]=make_pair(lim-cnt-dist[x][0],x);
             else
                 sta[x]=1;
         }
         for(int i=head[1];i;i=Next[i])
             if(!dfs(ver[i]))
                 need[ver[i]]=1;
         sort(h+1,h+ctot+1);
         for(int i=1;i<=ctot;i++)
             if(need[h[i].second] && h[i].first<dist[h[i].second][0])
                 need[h[i].second]=0;
             else
                 tim[++atot]=h[i].first;
         for(int i=head[1];i;i=Next[i])
             if(need[ver[i]])
                 ned[++btot]=dist[ver[i]][0];
         if(atot<btot) return 0;
         sort(tim+1,tim+atot+1),sort(ned+1,ned+btot+1);
         int i=1,j=1;
         while(i<=btot && j<=atot)
             if(tim[j]>=ned[i]) i++,j++;
             else j++;
         if(i>btot) return 1;
         return 0;
     }
     ```

2. **作者：litble**  
   - **星级：4星**  
   - **关键亮点**：通过预处理和二分答案结合贪心策略，代码简洁，逻辑清晰，适合快速理解。  
   - **核心代码**：
     ```cpp
     bool check(LL lim) {
         memset(vis,0,sizeof(vis));
         memset(used,0,sizeof(used));
         memset(restbj,0,sizeof(restbj));
         memset(restmin,0,sizeof(restmin));
         na=nb=0;
         for(int i=1;i<=m;++i) {
             int x=army[i],num=0;
             for(int j=17;j>=0;--j)
                 if(f[x][j]>1&&num+dis[x][j]<=lim)
                     num+=dis[x][j],x=f[x][j];
             if(f[x][0]==1&&num+dis[x][0]<=lim) {
                 a[++na].rest=lim-num-dis[x][0],a[na].id=i;
                 if(!restbj[x]||a[na].rest<restmin[x])
                     restmin[x]=a[na].rest,restbj[x]=i;
             }
             else vis[x]=1;
         }
         if(checkok(1,0)) return 1;
         sort(a+1,a+1+na,cmp),sort(b+1,b+1+nb,cmp);
         int now=1;used[0]=1;
         for(int i=1;i<=nb;++i) {
             if(!used[restbj[b[i].id]]){used[restbj[b[i].id]]=1;continue;}
             while(now<=na&&(used[a[now].id]||a[now].rest<b[i].rest))++now;
             if(now>na) return 0;used[a[now].id]=1;
         }
         return 1;
     }
     ```

3. **作者：FlashHu**  
   - **星级：4星**  
   - **关键亮点**：通过DFS直接判断子树是否被控制，避免了复杂的倍增操作，代码简洁且高效。  
   - **核心代码**：
     ```cpp
     bool check(ll mid) {
         memset(cov,0,sizeof(cov));
         memset(use,0,sizeof(use));
         memset(mn,0,sizeof(mn));
         for(int i=1;i<=cnt;++i)mn[t[i]]=0;
         for(int i=1;d[at[i]]>mid;++i)
             cov[at[i]]=1;
         for(p=i;i<=m;++i)
             if(!mn[top[at[i]]])mn[top[at[i]]]=i;
         use[0]=1;u=m+1;
         for(int i=1;i<=cnt;++i){
             dfs(t[i]);
             if(cov[t[i]])continue;
             if(use[mn[t[i]]]){
                 for(--u;u>=p&&(d[at[u]]+d[t[i]]>mid||use[u]);--u);
                 if(u<p)break;
                 use[u]=1;
             }
             else use[mn[t[i]]]=1;
         }
         return u>=p;
     }
     ```

### 最优关键思路或技巧
1. **二分答案**：通过二分答案确定最小时间，结合贪心策略判断是否可行。
2. **树上倍增**：利用树上倍增快速计算军队向上移动的位置，减少时间复杂度。
3. **DFS/BFS**：通过DFS和BFS检查子树是否被控制，确保所有边境城市都被覆盖。

### 可拓展之处
该题可以拓展到更复杂的树形结构或动态变化的图中，结合动态规划或图论中的其他算法进行优化。

### 推荐题目
1. [P1082 疫情控制](https://www.luogu.com.cn/problem/P1082)
2. [P1083 借教室](https://www.luogu.com.cn/problem/P1083)
3. [P1084 疫情控制](https://www.luogu.com.cn/problem/P1084)

---
处理用时：55.60秒
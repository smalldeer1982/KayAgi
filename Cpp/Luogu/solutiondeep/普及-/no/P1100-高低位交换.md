# 题目信息

# 高低位交换

## 题目描述

给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。

例如，数 $1314520$ 用二进制表示为 $0000\,0000\,0001\,0100\,0000\,1110\,1101\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\,0000\,0001\,0100$；后 $16$ 位为低位，即 $0000\,1110\,1101\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\,1110\,1101\,1000\,0000\,0000\,0001\,0100$。它即是十进制的 $249036820$。


## 样例 #1

### 输入

```
1314520
```

### 输出

```
249036820
```

# AI分析结果

### 算法分类
位运算

### 综合分析与结论
该题目要求将一个32位无符号整数的高低16位进行交换，核心思路是通过位运算实现。大部分题解采用了位运算（如左移、右移、与运算等）来高效地完成高低位交换，部分题解则通过模拟二进制转换来实现。位运算的解法通常更为简洁高效，而模拟方法则较为繁琐且易出错。

### 所选高星题解
#### 1. 作者：HenryHuang (赞：358)
- **星级**：5星
- **关键亮点**：使用位运算（左移、右移、与运算）高效实现高低位交换，代码简洁且解释清晰。
- **核心代码**：
  ```cpp
  cout<<((x&0x0000ffff)<<16|(x&0xffff0000)>>16)<<endl;
  ```
- **个人心得**：作者提到最初用模拟方法写了30行代码，后来通过位运算优化到不到10行，体现了位运算的高效性。

#### 2. 作者：月影困 (赞：95)
- **星级**：4星
- **关键亮点**：使用无符号整型，通过左移和右移操作实现高低位交换，代码简洁。
- **核心代码**：
  ```cpp
  printf("%u\n", (n >> 16) + (n << 16));
  ```
- **个人心得**：作者强调了无符号整型的重要性，避免符号位带来的问题。

#### 3. 作者：离散小波变换° (赞：54)
- **星级**：4星
- **关键亮点**：提供了两种位运算解法，分别通过左移右移和与运算实现，代码清晰且解释详细。
- **核心代码**：
  ```cpp
  cout<<(n>>16)+(n<<16);
  ```
- **个人心得**：作者详细解释了位运算的原理，并对比了两种解法的优劣，帮助读者更好地理解。

### 最优关键思路或技巧
1. **位运算**：通过左移、右移、与运算等操作，可以高效地提取和组合高低位，避免繁琐的二进制转换。
2. **无符号整型**：使用无符号整型可以避免符号位带来的问题，确保高低位交换的正确性。

### 可拓展之处
- **类似题目**：可以拓展到其他位操作问题，如位反转、位掩码等。
- **算法套路**：位运算在处理二进制数据时非常高效，适用于各种需要快速提取、组合或操作二进制位的场景。

### 推荐题目
1. **P1100 高低位交换**（本题）
2. **P1017 进制转换**（考察进制转换与位运算）
3. **P1226 快速幂**（考察位运算与幂运算的结合）

### 个人心得总结
- **调试经历**：多位作者提到最初使用模拟方法时代码冗长且易出错，后来通过位运算优化代码，体现了位运算的高效性。
- **踩坑教训**：使用有符号整型可能导致符号位问题，应优先使用无符号整型。
- **顿悟感想**：位运算在处理二进制数据时具有天然的优势，掌握位运算可以大幅提升代码效率。

---
处理用时：23.48秒
# 题目信息

# 平台

## 题目描述

空间中有一些平台。给出每个平台的位置，请你计算从每一个平台的边缘落下之后会落到哪一个平台上。

注意，如果某两个平台的某个两边缘横坐标相同，物体从上面那个平台落下之后将不会落在下面那个平台上（即平台的范围是一个开区间，不包含端点）。平台**可能会重叠**。

从平台下落时视作从平台下方开始下落，也就是说不会落到高度相同的平台上。**如果有两个平台的高度相同且都可以被落到的话，那么会落到编号靠前的那个平台。**

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)

## 样例 #1

### 输入

```
5
2 0 2
4 1 3
3 1 3
5 3 4
1 1 5
```

### 输出

```
0 5
1 5
1 5
5 5
0 0
```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
该题目要求模拟物体从平台边缘下落的过程，核心思路是通过遍历所有平台，找到满足条件的下落目标平台。由于平台可能重叠，且高度相同的平台需要优先选择编号较小的平台，因此需要对平台进行排序或特殊处理。大多数题解采用了O(n^2)的暴力模拟方法，部分题解通过排序优化了查找过程。

### 所选高星题解

#### 1. 作者：kevin_y (赞：82)
- **星级**：★★★★★
- **关键亮点**：代码简洁，直接通过两层循环暴力模拟，思路清晰，易于理解。
- **核心实现思想**：对于每个平台，分别从左边缘和右边缘下落，遍历所有平台找到满足条件的最高平台。
```cpp
for(int i=1;i<=n;i++){
    int sum1=0,sum2=0;
    for(int j=1;j<=n;j++)if(a[j]<a[i]&&b[j]<b[i]&&c[j]>b[i])if(a[sum1]<a[j])sum1=j;//左边下落
    cout<<sum1<<" ";
    for(int j=1;j<=n;j++)if(a[j]<a[i]&&b[j]<c[i]&&c[j]>c[i])if(a[sum2]<a[j])sum2=j;//右边下落
    cout<<sum2<<endl;
}
```

#### 2. 作者：JamlainHamstone (赞：1)
- **星级**：★★★★
- **关键亮点**：通过结构体存储平台信息，并按照高度降序排序，优化了查找过程。处理了平台重叠的情况。
- **核心实现思想**：排序后从高平台向低平台查找，找到第一个满足条件的平台即可停止。
```cpp
struct node{//结构体储存平台信息
    int h,l,r,id;
}s[1010];
bool cmp(node a,node b){
    if(a.h!=b.h) return a.h>b.h;
    return a.id<b.id;//编号小的优先
}
for(int i=1;i<=n;i++){
    for(int j=i+1;j<=n;j++){//左边答案
        if(s[j].l<s[i].l&&s[j].r>s[i].l){
            ans[s[i].id].lans=s[j].id;
            break;//找到就停止查找
        }
    }
    for(int j=i+1;j<=n;j++){//右边答案
        if(s[j].l<s[i].r&&s[j].r>s[i].r){
            ans[s[i].id].rans=s[j].id;
            break;//找到就停止查找
        }
    }
}
```

#### 3. 作者：ysner (赞：1)
- **星级**：★★★★
- **关键亮点**：通过排序和剪枝优化了查找过程，减少了不必要的遍历。
- **核心实现思想**：排序后从高平台向低平台查找，找到第一个满足条件的平台即可停止。
```cpp
bool com(pt x,pt y){
    return (x.g>y.g)||(x.g==y.g&&x.z<y.z);//在高度相同时将平台左端点从小到大排序
}
for(int i=0;i<n;i++){
    f1=0;//判断左端点的球是否已落在平台上
    f2=0;//判断右端点的球是否已落在平台上
    for(int j=i+1;j<n;j++){
        if(a[i].z>a[j].z&&a[i].z<a[j].y&&f1==0) {l[a[i].w][0]=a[j].w;f1=1;}
        if(a[i].y>a[j].z&&a[i].y<a[j].y&&f2==0) {l[a[i].w][1]=a[j].w;f2=1;}
        if(f1==1&&f2==1) break;//一点小优化，找到就不找了
    }
}
```

### 最优关键思路或技巧
1. **排序优化**：通过按高度降序排序，可以减少查找次数，优化时间复杂度。
2. **剪枝**：在找到满足条件的平台后立即停止查找，避免不必要的遍历。
3. **结构体存储**：使用结构体存储平台信息，便于排序和查找。

### 可拓展之处
类似的问题可以扩展到三维空间中的物体下落，或者考虑物体下落时的其他物理因素（如速度、加速度等）。

### 推荐相似题目
1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得总结
- **调试经历**：部分题解在处理平台重叠时出现问题，导致得分较低，需特别注意边界条件。
- **踩坑教训**：高度相同的平台需要优先选择编号较小的平台，否则会导致错误。
- **顿悟感想**：通过排序和剪枝可以显著优化查找过程，减少时间复杂度。

---
处理用时：37.53秒
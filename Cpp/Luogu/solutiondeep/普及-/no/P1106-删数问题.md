# 题目信息

# 删数问题

## 题目描述

键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。

## 说明/提示

用 $\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \leq k < \operatorname{len}(n) \leq 250$。

## 样例 #1

### 输入

```
175438 
4
```

### 输出

```
13```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
该题的核心思路是通过贪心策略，每次删除一个数字，使得剩下的数字尽可能小。具体来说，每次从高位到低位寻找第一个比后一个数字大的数字，删除它，重复这个过程直到删除k个数字。难点在于处理前导零和特殊情况（如删除后只剩零）。大部分题解都采用了这一思路，但在实现细节上有所不同，如使用字符串操作、链表优化等。

### 所选高星题解

#### 1. 作者：expin (赞：260)
- **星级**: 5星
- **关键亮点**: 
  - 思路清晰，详细解释了贪心策略的合理性。
  - 代码简洁，直接输出结果，避免了额外的存储。
  - 处理了前导零和特殊情况（如结果为0）。
- **个人心得**: 
  - "这样做可以每找出一个数就**直接输出**，但还要考虑前导0的问题。以及，若循环结束什么都没输出（意味着答案是0）就在程序结束前输出0。"

**核心代码**:
```cpp
while(cnt<rest){
    minp=t;
    for(int i=t;i<=k+t;++i)if(a[minp]>a[i])minp=i;
    if(a[minp])flag=1;
    if(flag)cout<<a[minp];
    k-=minp-t;
    t=minp+1;
    cnt++;
}
if(!flag)cout<<0;
```

#### 2. 作者：修罗海神王 (赞：196)
- **星级**: 4星
- **关键亮点**: 
  - 通过删除“下坡数”来优化贪心策略，减少了不必要的比较。
  - 代码结构清晰，易于理解。
  - 处理了前导零和特殊情况。
- **个人心得**: 
  - "大家有木有发现规律？？很明显，就是删去下坡数，也就是这个例子中的7（比5大）、5（比4大）、4（比3大）、8（比最后一个大（假设有，并为0））。"

**核心代码**:
```cpp
for(int i=1;i<=n;i++)
    for(int j=0;j<l;j++)
        if(a[j]>a[j+1]) {
            for(int k=j;k<l;k++) a[k]=a[k+1];
            l--; break;
        }
```

#### 3. 作者：xh39 (赞：143)
- **星级**: 4星
- **关键亮点**: 
  - 使用字符串的`erase`函数简化了删除操作。
  - 代码简洁，直接处理了前导零和特殊情况。
  - 思路清晰，易于实现。
- **个人心得**: 
  - "这一题主要是找到高峰就删，代码不难。还要注意前导零。（如果最后一个点wa的，肯定是没注意答案是0的情况）"

**核心代码**:
```cpp
while(s){
    for(i=0;n[i]<=n[i+1];) i++;
    n.erase(i,1);
    s--;
}
while(n[0]=='0'&&n.size()>1) n.erase(0,1);
cout<<n;
```

### 最优关键思路或技巧
1. **贪心策略**: 每次删除第一个比后一个数字大的数字，确保剩下的数字尽可能小。
2. **前导零处理**: 在输出前删除前导零，避免输出无效的零。
3. **特殊情况处理**: 如果删除后结果为0，确保输出0。

### 可拓展之处
- 类似问题可以扩展到其他贪心策略的应用，如最小生成树、最短路径等。
- 可以结合其他数据结构（如链表）来优化删除操作。

### 推荐题目
1. [P1107 删数问题 II](https://www.luogu.org/problem/P1107)
2. [P1108 删数问题 III](https://www.luogu.org/problem/P1108)
3. [P1109 删数问题 IV](https://www.luogu.org/problem/P1109)

---
处理用时：33.38秒
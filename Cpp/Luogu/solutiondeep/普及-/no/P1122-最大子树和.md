# 题目信息

# 最大子树和

## 题目描述

小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：

一株奇怪的花卉，上面共连有 $N$ 朵花，共有 $N-1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。

老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。

## 说明/提示

### 数据范围及约定

- 对于 $60\%$ 的数据，有 $1\le N\le 1000$；
- 对于 $100\%$ 的数据，有 $1\le N\le 16000$。

## 样例 #1

### 输入

```
7
-1 -1 -1 1 1 1 0
1 4
2 5
3 6
4 7
5 7
6 7
```

### 输出

```
3```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
该题目要求在一棵树中找到点权和最大的连通子树，属于典型的树形动态规划问题。各题解主要采用树形DP的思路，通过DFS遍历树结构，计算每个节点的子树和，并根据子树和的正负决定是否保留该子树。核心思想是通过贪心策略，只保留对总和有正贡献的子树。

### 所选高星题解
1. **题解作者：Mutsumi_0114 (5星)**
   - **关键亮点**：思路清晰，代码简洁，使用了vector存储树结构，DFS遍历时直接计算每个节点的子树和，并通过贪心策略优化。
   - **核心代码**：
     ```cpp
     void dfs(int u,int fa) {
         f[u]=a[u];//f初始值
         for(int i=0;i<E[u].size();i++) {
             int t=E[u][i];
             if(t!=fa) {
                 dfs(t,u);
                 if(f[t]>0)
                     f[u]+=f[t];//如式
             }
         }
     }
     ```
   - **个人心得**：作者强调了选择任意节点为根对结果没有影响，因为连通分量总是可以看作以某个点为根的树。

2. **题解作者：FCBM71 (4星)**
   - **关键亮点**：引入了两个状态数组 `fy` 和 `fn`，分别表示包含当前节点和不包含当前节点的最大子树和，进一步优化了DP过程。
   - **核心代码**：
     ```cpp
     void dfs(int x,int fa){
         for(int i=head[x];i;i=nxt[i]){
             if(to[i]==fa)continue;
             dfs(to[i],x);
             if(fy[to[i]]>0)fy[x]+=fy[to[i]];
             tomax(fn[x],fn[to[i]]);
             tomax(fn[x],fy[to[i]]);
         }
     }
     ```
   - **个人心得**：作者提到 `fn` 数组的初始化要设置为极小值，以应对所有点权为负数的情况。

3. **题解作者：tribool4_in (4星)**
   - **关键亮点**：代码简洁，直接使用DFS计算每个节点的子树和，并通过贪心策略优化。
   - **核心代码**：
     ```cpp
     void dfs(int u, int fa) {
         f[u] = a[u]; // 注意要赋初始值
         for(int i = 0; i < G[u].size(); i++) {
             int v = G[u][i];
             if (v == fa) continue;
             dfs(v, u);
             if (f[v] >= 1) f[u] += f[v];
         }
     }
     ```
   - **个人心得**：作者强调了DFS过程中要避免重复访问父节点，防止死循环。

### 最优关键思路或技巧
1. **树形DP**：通过DFS遍历树结构，计算每个节点的子树和，并根据子树和的正负决定是否保留该子树。
2. **贪心策略**：只保留对总和有正贡献的子树，优化了最终结果。
3. **状态转移方程**：`f[u] = a[u] + (f[v] > 0 ? f[v] : 0)`，其中 `v` 是 `u` 的子节点。

### 可拓展之处
类似的问题可以扩展到其他树形结构，如二叉树、多叉树等。还可以考虑带权树的最短路径、最长路径等问题。

### 推荐题目
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
2. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)
3. [P2016 战略游戏](https://www.luogu.com.cn/problem/P2016)

---
处理用时：30.50秒
# 题目信息

# 取数游戏

## 题目描述

一个 $N\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。

## 说明/提示

### 样例解释

对于第一组数据，取数方式如下：

$$\begin{matrix}
[67] & 75 & 63 & 10 \\
29 & 29 & [92] & 14 \\
[21] & 68 & 71 & 56 \\
8 & 67 & [91] & 25 \\
\end{matrix}$$


### 数据范围及约定

- 对于$20\%$的数据，$1\le N, M \le 3$；
- 对于$40\%$的数据，$1\le N, M\le 4$；
- 对于$60\%$的数据，$1\le N, M\le 5$；
- 对于$100\%$的数据，$1\le N, M\le 6$，$1\le T\le 20$。


## 样例 #1

### 输入

```
3
4 4
67 75 63 10
29 29 92 14
21 68 71 56
8 67 91 25
2 3
87 70 85
10 3 17
3 3
1 1 1
1 99 1
1 1 1

```

### 输出

```
271
172
99
```

# AI分析结果

### 算法分类
深度优先搜索 DFS

### 综合分析与结论
本题的核心是通过深度优先搜索（DFS）来枚举所有可能的取数方案，确保取出的数字不相邻，并找到和最大的方案。由于数据范围较小（N, M ≤ 6），DFS 是一种可行的解法。大多数题解都采用了 DFS 的思路，但在实现细节和优化上有所不同。

### 所选高星题解

#### 1. 题解作者：绿萧
- **星级**：5星
- **关键亮点**：
  - 详细分析了贪心和动态规划的不适用性，明确选择了 DFS 作为解法。
  - 使用 `mark` 数组记录每个点周围是否被取数，确保取数时不相邻。
  - 代码结构清晰，注释详细，易于理解。
- **核心代码**：
  ```cpp
  void dfs(int x, int y) {
      if (y == m + 1) { dfs(x + 1, 1); return; }
      if (x == n + 1) { mx = max(ans, mx); return; }
      dfs(x, y + 1); // 不取此数的情况
      if (mark[x][y] == 0) { // 取此数的情况
          ans += s[x][y];
          for (int fx = 0; fx < 8; ++fx) ++mark[x + d[fx][0]][y + d[fx][1]];
          dfs(x, y + 1);
          for (int fx = 0; fx < 8; ++fx) --mark[x + d[fx][0]][y + d[fx][1]];
          ans -= s[x][y];
      }
  }
  ```

#### 2. 题解作者：CRH380B
- **星级**：4星
- **关键亮点**：
  - 使用 `can` 数组记录每个点是否可选，避免了重复判断。
  - 代码简洁，逻辑清晰，适合初学者理解。
- **核心代码**：
  ```cpp
  void DFS(int i, int j, int now) {
      if (j > m) { i++; j = 1; }
      if (i > n) { if (now > ans) ans = now; return; }
      if (can[i][j] == 0) {
          for (int k = 1; k < 9; k++) can[i + dx[k]][j + dy[k]]++;
          DFS(i, j + 2, now + a[i][j]);
          for (int k = 1; k < 9; k++) can[i + dx[k]][j + dy[k]]--;
      }
      DFS(i, j + 1, now); // 不选
  }
  ```

#### 3. 题解作者：LSG_waterf
- **星级**：4星
- **关键亮点**：
  - 通过 `vis` 数组记录每个点的访问状态，确保取数时不相邻。
  - 使用了方向数组 `dx` 和 `dy` 来简化代码。
  - 代码结构清晰，易于理解。
- **核心代码**：
  ```cpp
  void dfs(int x, int y, int w) {
      if (x > n && y == 1) { ans = max(ans, w); return; }
      if (y < m) {
          if (vis[x][y] == 0) {
              change(x, y, 1);
              dfs(x, y + 1, w + a[x][y]);
              change(x, y, -1);
          }
          dfs(x, y + 1, w);
      }
      if (y == m) {
          if (vis[x][y] == 0) {
              change(x, y, 1);
              dfs(x + 1, 1, w + a[x][y]);
              change(x, y, -1);
          }
          dfs(x + 1, 1, w);
      }
  }
  ```

### 最优关键思路或技巧
1. **DFS + 回溯**：通过 DFS 枚举所有可能的取数方案，并使用回溯来恢复状态，确保每次取数后不影响后续选择。
2. **标记数组**：使用 `mark` 或 `can` 数组记录每个点是否被取数，确保取数时不相邻。
3. **方向数组**：使用方向数组简化代码，避免重复写多个方向的判断。

### 可拓展之处
类似的问题可以扩展到更大的矩阵或更复杂的约束条件，如取数时需要考虑更多的相邻关系或不同的取数规则。此外，可以尝试使用动态规划或状态压缩来优化解法。

### 推荐题目
1. [P1896 互不侵犯](https://www.luogu.com.cn/problem/P1896)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得摘录
- **绿萧**：详细分析了贪心和动态规划的不适用性，明确选择了 DFS 作为解法。
- **CRH380B**：代码简洁，逻辑清晰，适合初学者理解。
- **LSG_waterf**：通过 `vis` 数组记录每个点的访问状态，确保取数时不相邻。

---
处理用时：42.30秒
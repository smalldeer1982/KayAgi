# 题目信息

# 词链

## 题目描述

如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。

另外还有一些例子：
- `dog.gopher`
- `gopher.rat`
- `rat.tiger`
- `aloha.aloha`
- `arachnid.dog`

连接成的词可以与其他单词相连，组成更长的词链，例如：

`aloha.arachnid.dog.gopher.rat.tiger`

注意到，`.` 两边的字母一定是相同的。

现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。

## 说明/提示

- 对于 $40\%$ 的数据，有 $n \leq 10$；
- 对于 $100\%$ 的数据，有 $n \leq 1000$。


## 样例 #1

### 输入

```
6
aloha
arachnid
dog
gopher
rat
tiger```

### 输出

```
aloha.arachnid.dog.gopher.rat.tiger```

# AI分析结果

### 算法分类
图论

### 综合分析与结论
本题的核心是通过构建有向图并寻找欧拉路径或欧拉回路来解决问题。大多数题解都采用了这一思路，但在具体实现上有所不同。部分题解通过并查集判断图的连通性，并通过统计入度和出度来确定欧拉路径的起点和终点。还有一些题解直接通过DFS搜索欧拉路径，并通过排序保证字典序最小。整体上，题解的质量较高，思路清晰，代码实现也较为规范。

### 所选题解
1. **作者：loc_equinox (赞：86)**
   - **星级：5星**
   - **关键亮点：**
     - 通过并查集判断图的连通性，确保欧拉路径的存在。
     - 通过统计入度和出度确定欧拉路径的起点和终点。
     - 使用DFS搜索欧拉路径，并通过排序保证字典序最小。
   - **个人心得：**
     - 通过欧拉路径的特征，将问题转化为图论问题，大大简化了搜索过程。
     - 通过并查集和入度出度统计，避免了无效的搜索，提高了效率。

   **核心代码片段：**
   ```cpp
   void dfs(int st, int now, int pre_edge) {
       if (st == n) {
           for (int i = 1; i <= n; i++) {
               cout << res[i];
               if (i < n) cout << ".";
           }
           exit(0);
       }
       for (int k = 0; k < E[now].size(); k++) {
           if (!vis[E[now][k].ord]) {
               vis[E[now][k].ord] = 1;
               res[st + 1] = E[now][k].word;
               dfs(st + 1, E[now][k].to, E[now][k].ord);
           }
       }
       vis[pre_edge] = 0;
       return;
   }
   ```

2. **作者：zzr8178541919 (赞：83)**
   - **星级：4星**
   - **关键亮点：**
     - 通过分析词链的性质，确定起点的选择策略。
     - 使用DFS搜索欧拉路径，并通过标记和回溯保证每个单词只使用一次。
     - 通过排序保证字典序最小。
   - **个人心得：**
     - 通过分析词链的性质，确定了起点的选择策略，避免了无效的搜索。
     - 使用DFS搜索欧拉路径，并通过标记和回溯保证每个单词只使用一次，提高了效率。

   **核心代码片段：**
   ```cpp
   void dfs(int last, int step) {
       if (flag == 1) return;
       if (step == n) {
           flag = 1;
           for (int i = 1; i <= sum; i++) {
               ans[i] = now[i];
           }
           return;
       }
       for (int i = 1; i <= n; i++) {
           if (book[i] == 1) continue;
           if (a[last][a[last].length() - 1] == a[i][0]) {
               now[++sum] = a[i];
               book[i] = 1;
               dfs(i, step + 1);
               sum--;
               book[i] = 0;
           }
       }
   }
   ```

3. **作者：CGDGAD (赞：61)**
   - **星级：4星**
   - **关键亮点：**
     - 通过统计入度和出度确定欧拉路径的起点和终点。
     - 使用DFS搜索欧拉路径，并通过排序保证字典序最小。
     - 通过标记和回溯保证每个单词只使用一次。
   - **个人心得：**
     - 通过统计入度和出度确定欧拉路径的起点和终点，避免了无效的搜索。
     - 使用DFS搜索欧拉路径，并通过标记和回溯保证每个单词只使用一次，提高了效率。

   **核心代码片段：**
   ```cpp
   void dfs(int s, std::string curr, int count) {
       if (count == n) {
           curr[curr.length() - 1] = ' ';
           std::cout << curr;
           exit(0);
       }
       for (auto i : e[s])
           if (!used[i]) {
               used[i] = true;
               dfs(i, curr + a[i] + '.', count + 1);
               used[i] = false;
           }
   }
   ```

### 最优关键思路或技巧
1. **构建有向图**：将单词的首字母和尾字母作为图的节点，单词作为边，构建有向图。
2. **欧拉路径判断**：通过统计入度和出度，判断是否存在欧拉路径或欧拉回路。
3. **DFS搜索**：使用DFS搜索欧拉路径，并通过排序保证字典序最小。
4. **并查集**：通过并查集判断图的连通性，确保欧拉路径的存在。

### 可拓展之处
1. **欧拉路径的应用**：可以拓展到其他需要寻找路径或回路的问题，如邮递员问题、旅行商问题等。
2. **图的连通性判断**：可以拓展到其他需要判断图连通性的问题，如网络连接、社交网络分析等。

### 推荐题目
1. **P1127 词链**（本题）
2. **P2731 [USACO3.3] 骑马修栅栏 Riding the Fences**（欧拉路径）
3. **P1341 无序字母对**（欧拉路径）
4. **P1333 [USACO08OCT] Bovine Bones G**（图的连通性）

---
处理用时：38.67秒
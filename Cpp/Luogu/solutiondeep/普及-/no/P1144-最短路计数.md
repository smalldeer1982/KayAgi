# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 算法分类
最短路、广度优先搜索 BFS

### 综合分析与结论
本题的核心在于求解从起点到其他所有点的最短路数量。由于图是无权图，边权均为1，因此可以使用BFS来求解最短路，并在BFS的过程中统计最短路的数量。题解中主要使用了BFS和SPFA两种算法，其中BFS更为简洁且高效，适合无权图的最短路问题。

### 所选题解

#### 1. 作者：岸芷汀兰
**星级：5星**
**关键亮点：**
- 使用BFS进行最短路求解，思路清晰且代码简洁。
- 详细解释了如何处理自环和重边的情况。
- 通过`ans`数组记录最短路数量，并在BFS过程中动态更新。

**核心代码：**
```cpp
void bfs() {
    queue<Node> q; q.push(make(1, 0));
    memset(d, 0x3f, sizeof(d)); d[1] = 0;
    vis[1] = true;
    ans[1] = 1;
    while (q.size()) {
        int u = q.front().node, dis = q.front().dis; 
        q.pop();
        for (register int i = 0; i < int(linker[u].size()); i++) {
            if (!vis[cur]) {
                q.push(make(cur, dis + 1)); vis[cur] = true; d[cur] = dis + 1; 
                ans[cur] += ans[u]; ans[cur] %= mod;
            } else if (dis + 1 == d[cur]) {
                ans[cur] += ans[u]; ans[cur] %= mod;
            }
        }
    }
}
```

#### 2. 作者：King丨帝御威
**星级：4星**
**关键亮点：**
- 使用堆优化的Dijkstra算法，虽然复杂度略高，但代码结构清晰。
- 通过`ans`数组记录最短路数量，并在松弛过程中动态更新。

**核心代码：**
```cpp
void dijkstra() {
    memset(dis, 0x3f, sizeof(dis)); ans[1] = 1;
    q.push(make_pair(0, 1));
    while (!q.empty()) {
        int u = q.top().second; q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            if (dis[v] > dis[u] + 1) {
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                q.push(make_pair(-dis[v], v));
            } else if (dis[v] == dis[u] + 1) {
                ans[v] = (ans[v] + ans[u]) % mod;
            }
        }
    }
}
```

#### 3. 作者：TsReaper
**星级：4星**
**关键亮点：**
- 使用BFS进行最短路求解，思路简洁明了。
- 通过`count`数组记录最短路数量，并在BFS过程中动态更新。

**核心代码：**
```cpp
void bfs() {
    queue<int> q; q.push(1);
    memset(d, 0x3f, sizeof(d)); d[1] = 0;
    vis[1] = true;
    count[1] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) {
            if (!vis[v]) {
                q.push(v); vis[v] = true; d[v] = d[u] + 1;
                count[v] = count[u];
            } else if (d[v] == d[u] + 1) {
                count[v] = (count[v] + count[u]) % mod;
            }
        }
    }
}
```

### 最优关键思路
- **BFS求解最短路**：由于图是无权图，BFS是最适合的算法，能够在O(N)时间内求解最短路。
- **动态更新最短路数量**：在BFS过程中，通过`ans`数组记录最短路数量，并在遍历时动态更新。

### 可拓展之处
- **带权图的最短路计数**：如果图是带权图，可以使用Dijkstra或SPFA算法，并在松弛过程中更新最短路数量。
- **多源最短路计数**：如果需要从多个起点出发，可以初始化多个起点的`ans`值，并在BFS过程中同时更新。

### 推荐题目
1. [P1608 路径统计](https://www.luogu.org/problem/P1608)
2. [P1144 最短路计数](https://www.luogu.org/problem/P1144)
3. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.org/problem/P4779)

### 个人心得
- **调试经历**：在处理重边和自环时，容易忽略这些情况，导致结果错误。通过仔细检查输入数据和处理逻辑，可以避免这类问题。
- **顿悟感想**：BFS在无权图中的应用非常广泛，理解其核心思想后，可以轻松解决类似的最短路问题。

---
处理用时：40.23秒
# 题目信息

# [NOIP 2008 提高组] 火柴棒等式

## 题目描述

给你 $n$ 根火柴棍，你可以拼出多少个形如 $A+B=C$ 的等式？等式中的 $A$、$B$、$C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$）。用火柴棍拼数字 $0\sim9$ 的拼法如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p5hsawt2.png)

注意：

1. 加号与等号各自需要两根火柴棍；
2. 如果 $A\neq B$，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式（$A,B,C\geq0$）；
3. $n$ 根火柴棍必须全部用上。


## 说明/提示

【输入输出样例 1 解释】

$2$ 个等式为 $0+1=1$ 和 $1+0=1$。

【输入输出样例 2 解释】

$9$ 个等式为

$0+4=4$、$0+11=11$、$1+10=11$、$2+2=4$、$2+7=9$、$4+0=4$、$7+2=9$、$10+1=11$、$11+0=11$。

noip2008 提高第二题

## 样例 #1

### 输入

```
14```

### 输出

```
2```

## 样例 #2

### 输入

```
18```

### 输出

```
9```

# AI分析结果

### 算法分类
**枚举**

### 综合分析与结论
本题的核心是通过枚举所有可能的 $A$ 和 $B$，计算 $C = A + B$，并检查 $A$、$B$、$C$ 所需的火柴棒总数是否等于 $n$。由于 $n$ 的最大值为 24，且每个数字所需的火柴棒数有限，因此可以通过暴力枚举的方式解决。

各题解的思路基本一致，主要区别在于枚举的范围、代码的实现细节以及优化程度。大多数题解都采用了预处理数字所需的火柴棒数，并通过双重循环枚举 $A$ 和 $B$，最后检查等式是否成立。部分题解在枚举范围上进行了优化，如限制 $A$ 和 $B$ 的最大值为 1000 或 1111，以减少不必要的计算。

### 所选高星题解

#### 1. 作者：King_and_Grey (4星)
**关键亮点**：
- 预处理了 0 到 2000 的数字所需的火柴棒数，减少了重复计算。
- 枚举范围合理，限制 $A$ 和 $B$ 的最大值为 1000，提高了效率。
- 代码结构清晰，注释详细，易于理解。

**个人心得**：
- 作者在第一次提交时只枚举了 1 到 10 的数字，导致只得了 20 分。通过分析问题，作者意识到需要扩大枚举范围，并最终通过预处理和优化枚举范围解决了问题。

**核心代码**：
```cpp
int a[maxn + 5];
for (int i = 1; i <= 2000; i++) {
    for (int j = i; j; j /= 10) {
        a[i] += num[j % 10];
    }
}
for (int i = 0; i <= 1000; i++) {
    for (int j = 0; j <= 1000; j++) {
        if (a[i] + a[j] + a[i + j] + 4 == n) {
            ans++;
        }
    }
}
```

#### 2. 作者：hilsinleri (4星)
**关键亮点**：
- 通过函数 `s(int x)` 计算任意数字所需的火柴棒数，代码简洁。
- 枚举范围合理，限制 $A$ 和 $B$ 的最大值为 1000，提高了效率。
- 代码简洁明了，易于理解。

**核心代码**：
```cpp
int s(int x) {
    if (x == 0) return num[0];
    int ans = 0;
    while (x != 0) {
        int t = x % 10;
        ans += num[t];
        x /= 10;
    }
    return ans;
}
for (int i = 0; i <= 1000; ++i) {
    for (int j = 0; j <= 1000; ++j) {
        if (s(i) + s(j) + s(i + j) + 4 == n) {
            ++total;
        }
    }
}
```

#### 3. 作者：mcturtle (4星)
**关键亮点**：
- 预处理了 0 到 2000 的数字所需的火柴棒数，减少了重复计算。
- 枚举范围合理，限制 $A$ 和 $B$ 的最大值为 1000，提高了效率。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
int a[2001];
for (int i = 1; i <= 2000; i++) {
    for (int j = i; j; j /= 10) {
        a[i] += nt[j % 10];
    }
}
for (int i = 0; i <= 1000; i++) {
    for (int j = 0; j <= 1000; j++) {
        if (a[i] + a[j] + a[i + j] + 4 == n) {
            s++;
        }
    }
}
```

### 最优关键思路与技巧
1. **预处理数字所需的火柴棒数**：通过预处理 0 到 2000 的数字所需的火柴棒数，减少了重复计算，提高了效率。
2. **合理限制枚举范围**：由于 $n$ 的最大值为 24，限制 $A$ 和 $B$ 的最大值为 1000 或 1111，减少了不必要的计算。
3. **代码简洁与清晰**：通过函数封装和清晰的代码结构，提高了代码的可读性和可维护性。

### 可拓展之处
- 类似的问题可以通过预处理和枚举的方式解决，如计算满足某种条件的等式或组合。
- 可以进一步优化枚举范围，通过数学分析减少不必要的计算。

### 推荐题目
1. [P1149 [NOIP 2008 提高组] 火柴棒等式](https://www.luogu.com.cn/problem/P1149)
2. [P1217 [USACO1.5] 回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)
3. [P1022 [NOIP 2000 普及组] 计算器的改良](https://www.luogu.com.cn/problem/P1022)

---
处理用时：35.37秒
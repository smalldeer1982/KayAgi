# 题目信息

# [NOIP 2008 提高组] 双栈排序

## 题目描述

Tom 最近在研究一个有趣的排序问题。如图所示，通过 $2$ 个栈 $S_1$ 和 $S_2$，Tom 希望借助以下 $4$ 种操作实现将输入序列升序排序。

![](https://cdn.luogu.com.cn/upload/image_hosting/gwxu91ud.png)

- 操作 $\verb!a!$：将第一个元素压入栈 $S_1$。
- 操作 $\verb!b!$：将 $S_1$ 栈顶元素弹出至输出序列。
- 操作 $\verb!c!$：将第一个元素压入栈 $S_2$。
- 操作 $\verb!d!$：将 $S_2$ 栈顶元素弹出至输出序列。


如果一个 $1\sim n$ 的排列 $P$ 可以通过一系列合法操作使得输出序列为 $(1,2,\cdots,n-1,n)$，Tom 就称 $P$ 是一个“可双栈排序排列”。例如 $(1,3,2,4)$ 就是一个“可双栈排序序列”，而 $(2,3,4,1)$ 不是。下图描述了一个将 $(1,3,2,4)$ 排序的操作序列：$\texttt {a,c,c,b,a,d,d,b}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/jwdjwfee.png)

当然，这样的操作序列有可能有几个，对于上例 $(1,3,2,4)$，$\texttt{a,b,a,a,b,b,a,b}$ 是另外一个可行的操作序列。Tom 希望知道其中字典序最小的操作序列是什么。

## 说明/提示

$30\%$ 的数据满足：$n\le10$。

$50\%$ 的数据满足：$n\le50$。

$100\%$ 的数据满足：$n\le1000$。

2021.06.17 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)。hack 数据单独分为一个 subtask 防止混淆。

noip2008 提高第四题

## 样例 #1

### 输入

```
4
1 3 2 4```

### 输出

```
a b a a b b a b```

## 样例 #2

### 输入

```
4
2 3 4 1```

### 输出

```
0```

## 样例 #3

### 输入

```
3
2 3 1```

### 输出

```
a c a b b d```

# AI分析结果

### 算法分类
图论

### 综合分析与结论
本题的核心是通过两个栈的操作将输入序列排序，难点在于判断哪些元素不能共存于同一个栈中，并通过二分图染色将元素分配到两个栈中。大多数题解都采用了二分图染色的思路，并结合贪心策略来保证字典序最小的操作序列。部分题解在模拟操作时存在误判或优化不足的问题，导致代码复杂或效率不高。

### 所选题解
1. **zjp_shadow (5星)**
   - **关键亮点**：通过二分图染色判断元素是否可共存，并结合贪心策略保证字典序最小。代码清晰，逻辑严谨，优化到位。
   - **个人心得**：作者指出直接模拟操作会导致误判，提出了在`push`后不立即`pop`的优化策略，确保栈的单调性。
   - **核心代码**：
     ```cpp
     inline void Push(int cur, int id) {
         if (id == 1) { while(Pop(0)); }
         while (!S[id].empty() && S[id].top() < cur)
             if (!Pop(id)) Pop(id ^ 1);
         if (id == 1) { while(Pop(0)); }
         S[id].push(cur); out(id ? 'c' : 'a');
     }
     ```

2. **Comentropy (4星)**
   - **关键亮点**：详细分析了栈的单调性，并通过`popall`操作确保栈的合法性，代码结构清晰，逻辑严密。
   - **核心代码**：
     ```cpp
     void popall(int lim) {
         while(true) {
             if(stk1.size() && stk1.top() == now) {
                 stk1.pop(); printf("b "); now++;
             } else if(stk2.size() && stk2.top() == now) {
                 if(now == lim - 1) break;
                 stk2.pop(); printf("d "); now++;
             } else break;
         }
     }
     ```

3. **Coros_Trusds (4星)**
   - **关键亮点**：通过二分图染色判断元素是否可共存，并在模拟操作时优先操作第一个栈，确保字典序最小。
   - **核心代码**：
     ```cpp
     void check() {
         while(top[0] && stk[top[0]][0] == pos) {
             top[0]--; pos++; printf("b ");
         }
     }
     ```

### 最优关键思路或技巧
1. **二分图染色**：通过判断元素是否可共存，将问题转化为二分图染色问题，确保元素分配到两个栈中。
2. **贪心策略**：在模拟操作时，优先操作第一个栈，确保字典序最小。
3. **栈的单调性维护**：在`push`操作后，不立即`pop`，而是等到需要`pop`时再操作，确保栈的单调性。

### 可拓展之处
类似的问题可以扩展到多个栈的操作，或者更复杂的栈操作规则。此外，二分图染色的思路可以应用于其他需要将元素分配到不同集合的问题。

### 推荐题目
1. [P1155 双栈排序](https://www.luogu.com.cn/problem/P1155)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1073 最优贸易](https://www.luogu.com.cn/problem/P1073)

---
处理用时：28.81秒
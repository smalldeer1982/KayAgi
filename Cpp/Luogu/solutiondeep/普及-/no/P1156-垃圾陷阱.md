# 题目信息

# 垃圾陷阱

## 题目描述

卡门――农夫约翰极其珍视的一条 `Holsteins` 奶牛――已经落了到 “垃圾井” 中。“垃圾井” 是农夫们扔垃圾的地方，它的深度为 $D$（$2 \le D \le 100$）英尺。

卡门想把垃圾堆起来，等到堆得与井深同样高或比井深更高（即，垃圾高度总和 $\geq D$）时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。

每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。

假设卡门预先知道了每个垃圾扔下的时间 $t$（$1 \le t \le 1000$），以及每个垃圾堆放的高度 $h$（$1 \le h \le 25$）和吃进该垃圾能增加维持生命的时间 $f$（$1 \le f \le 30$），要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续 $10$ 小时的能量，如果卡门 $10$ 小时内（不含 $10$ 小时，维持生命的时间同）没有进食，卡门就将饿死。特别地，若体力值为 $0$ 时吃下垃圾或逃出井外也不会饿死。

## 说明/提示

**【样例说明】**

卡门堆放她收到的第一个垃圾：$\mathrm{height}=9$；

卡门吃掉她收到的第 $2$ 个垃圾，使她的生命从 $10$ 小时延伸到 $13$ 小时；

卡门堆放第 $3$ 个垃圾，$\mathrm{height}=19$；

卡门堆放第 $4$ 个垃圾，$\mathrm{height}=20$。


## 样例 #1

### 输入

```
20 4
5 4 9
9 3 2
12 6 10
13 1 1```

### 输出

```
13```

# AI分析结果

### 算法分类
动态规划

### 综合分析
该题目是一个典型的动态规划问题，核心在于如何通过合理的状态转移来模拟卡门在不同时间点的选择（吃垃圾或堆放垃圾），并最终找到最早逃出井外的时间或最长存活时间。题解中主要采用了以下几种思路：
1. **一维DP**：通过 `f[i]` 表示高度为 `i` 时的最大生命值，逐步更新状态。
2. **二维DP**：通过 `f[i][j]` 表示处理到第 `i` 个垃圾时，高度为 `j` 的最大生命值，进行状态转移。
3. **记忆化搜索**：通过DFS结合剪枝和记忆化来优化搜索过程。

### 所选高星题解
#### 题解1：Dispwnl（5星）
**关键亮点**：
- 使用一维DP数组 `f[high] = life`，简洁高效。
- 通过倒序遍历高度，确保状态转移的正确性。
- 代码清晰，逻辑严密，易于理解。

**核心代码**：
```cpp
for(int i=1;i<=g;i++)
  for(int j=d;j>=0;j--)
    if(f[j]>=c[i].t)
    {
        if(j+c[i].h>=d)
        {
            cout<<c[i].t;
            return 0;
        }
        f[j+c[i].h]=max(f[j+c[i].h],f[j]);
        f[j]+=c[i].l;
    }
```
**实现思想**：通过倒序遍历高度，确保每个状态只被更新一次，避免重复计算。

#### 题解2：ButterflyDew（4星）
**关键亮点**：
- 详细分析了状态转移的多种可能性，提出了离线算法和在线算法的区别。
- 通过填表法和刷表法展示了不同的状态转移方式，思路清晰。

**核心代码**：
```cpp
for(int i=1;i<=g;i++)
    for(int j=0;j<=d;j++)
    {
        if(dp[i-1][j]>=trash[i].t)
            dp[i][j]=max(dp[i][j],dp[i-1][j]+trash[i].c);
        if(j>=trash[i].h&&dp[i-1][j-trash[i].h]>=trash[i].t)
            dp[i][j]=max(dp[i][j],dp[i-1][j-trash[i].h]);
    }
```
**实现思想**：通过填表法逐步更新状态，确保每个状态的最优解。

#### 题解3：wjyyy（4星）
**关键亮点**：
- 详细解释了状态转移的条件，特别是生命值为0时的处理。
- 通过初始化负值和状态转移条件的严格判断，避免了无效状态的干扰。

**核心代码**：
```cpp
for(int i=0;i<g;i++)
    for(int j=0;j<=d;j++)
    {
        if(dp[i][j]<0) continue;
        if(j+r[i+1].h>=d&&dp[i][j]>=r[i+1].t-r[i].t)
        {
            printf("%d\n",r[i+1].t);
            return 0;
        }
        if(dp[i][j]-r[i+1].t+r[i].t>=0)
            dp[i+1][j+r[i+1].h]=dp[i][j]-r[i+1].t+r[i].t;
        if(dp[i][j]-r[i+1].t+r[i].t>=0)
            dp[i+1][j]=max(dp[i+1][j],dp[i][j]-r[i+1].t+r[i].t+r[i+1].f);
    }
```
**实现思想**：通过严格的状态转移条件，确保每个状态的有效性。

### 最优关键思路
1. **状态定义**：通过 `f[i][j]` 表示处理到第 `i` 个垃圾时，高度为 `j` 的最大生命值。
2. **状态转移**：通过吃垃圾或堆放垃圾两种选择进行状态转移，确保每个状态的最优解。
3. **初始化与边界条件**：通过初始化负值和严格的状态转移条件，避免无效状态的干扰。

### 可拓展之处
- **类似问题**：背包问题、资源分配问题等都可以通过类似的状态转移思路解决。
- **优化技巧**：记忆化搜索、剪枝等技巧可以进一步提升算法的效率。

### 推荐题目
1. P1048 采药（背包问题）
2. P1060 开心的金明（资源分配问题）
3. P1514 金明的预算方案（多重背包问题）

---
处理用时：38.74秒
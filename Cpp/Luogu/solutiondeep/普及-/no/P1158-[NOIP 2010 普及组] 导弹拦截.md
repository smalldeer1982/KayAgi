# 题目信息

# [NOIP 2010 普及组] 导弹拦截

## 题目描述

经过 $11$ 年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 $0$ 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。

某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。

## 说明/提示

两个点 $(x_1,y_1),(x_2,y_2)$ 之间距离的平方是 $(x_1-x_2)^2+(y_1-y_2)^2$。

两套系统工作半径 $r_1,r_2$ 的平方和，是指 $r_1,r_2$ 分别取平方后再求和，即 $r_1^2+r_2^2$。

### 样例 1 说明

样例 $1$ 中要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $18$ 和 $0$。

### 样例 2 说明

样例 $2$ 中的导弹拦截系统和导弹所在的位置如下图所示。要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $20$ 和 $10$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cvgomt03.png)

【数据范围】。

- 对于 $10\%$ 的数据，$N=1$。
- 对于 $20\%$ 的数据，$1\le N\le 2$。
- 对于 $40\%$ 的数据，$1\le N\le 100$。
- 对于 $70\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 10^5$，且所有坐标分量的绝对值都不超过 $1000$。

NOIP2010 普及组 第三题

## 样例 #1

### 输入

```
0 0 10 0
2
-3 3
10 0```

### 输出

```
18```

## 样例 #2

### 输入

```
0 0 6 0
5
-4 -2
-2 3
4 0
6 -2
9 1```

### 输出

```
30```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
该题的核心逻辑是通过贪心策略，将导弹按照与第一个系统的距离排序，然后枚举第一个系统拦截的最远导弹，计算第二个系统拦截剩余导弹的代价，最终找到最小代价和。大多数题解都采用了这一思路，但实现细节和优化程度有所不同。

### 所选高星题解

#### 1. 作者：TEoS (5星)
**关键亮点**：
- 思路清晰，详细解释了排序和枚举的过程。
- 代码结构简洁，变量命名合理，易于理解。
- 预处理了第二个系统的最大距离，优化了时间复杂度。

**核心代码**：
```cpp
sort(di+1,di+n+1,cmp);
for(int i=n;i>0;i--) {
    int a = pow(x[di[i].i]-x22,2)+pow(y[di[i].i]-y22,2);
    di[i].d2 = max(a,di[i+1].d2);
}
for(int i=0;i<=n;i++) {
    int a = di[i].d1 + di[i+1].d2;
    minn = min(a,minn);
}
```

#### 2. 作者：暗ざ之殇 (4星)
**关键亮点**：
- 详细说明了排序和枚举的思路，并配以图示解释。
- 代码中使用了预处理数组 `nxt` 来存储第二个系统的最大距离，优化了计算。

**核心代码**：
```cpp
sort(a+1,a+1+n,cmp1);
minx = a[n].dis1;
nxt[n] = dis2[a[n].id];
for(int i=n-1;i>=1;i--) {
    if(dis2[a[i].id] > nxt[i+1]) nxt[i] = dis2[a[i].id];
    else nxt[i] = nxt[i+1];
}
for(int i=n-1;i>=1;i--) {
    minx = min(minx, a[i].dis1 + nxt[i+1]);
}
```

#### 3. 作者：Zh_terminal (4星)
**关键亮点**：
- 代码简洁，直接使用了距离的平方，避免了浮点数计算。
- 详细解释了枚举的过程，并给出了时间复杂度分析。

**核心代码**：
```cpp
sort(a+1,a+N+1,cmp);
int ans = a[N].d1;
int d = 0;
for(int i=N;i>=1;i--) {
    d = max(d, a[i].d2);
    int ans2 = a[i-1].d1 + d;
    ans = min(ans, ans2);
}
```

### 最优关键思路
1. **排序与枚举**：将导弹按照与第一个系统的距离排序，然后枚举第一个系统拦截的最远导弹，计算第二个系统拦截剩余导弹的代价。
2. **预处理优化**：通过预处理第二个系统的最大距离，减少重复计算，优化时间复杂度。
3. **避免浮点数**：直接使用距离的平方进行计算，避免浮点数带来的精度问题。

### 可拓展之处
- **类似问题**：可以扩展到多个拦截系统的情况，进一步优化贪心策略。
- **其他应用**：类似思路可以应用于资源分配、任务调度等问题。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：26.40秒
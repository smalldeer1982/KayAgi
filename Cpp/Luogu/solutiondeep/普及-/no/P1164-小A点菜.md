# 题目信息

# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
该题目要求计算在给定预算内恰好花完所有钱的点菜方案数，属于典型的动态规划问题。大多数题解采用了二维或一维的动态规划方法，核心思想是通过状态转移方程计算不同预算下的方案数。难点在于如何正确初始化状态转移方程，并确保在计算过程中不重复或遗漏方案。

### 所选高星题解

#### 1. 作者：衡屿睿 (5星)
**关键亮点**：
- 详细解释了状态转移方程的推导过程，清晰易懂。
- 代码简洁，直接使用二维数组进行状态转移，适合初学者理解。
- 通过三个条件分别处理不同情况，逻辑严密。

**核心代码**：
```cpp
for(int i=1;i<=n;++i)
  for(int j=1;j<=m;++j)
  {
      if(j==a[i])f[i][j]=f[i-1][j]+1;
      if(j>a[i]) f[i][j]=f[i-1][j]+f[i-1][j-a[i]];
      if(j<a[i]) f[i][j]=f[i-1][j];
  }
```

#### 2. 作者：Dream_zhc (4星)
**关键亮点**：
- 详细解释了如何从二维数组降维到一维数组，优化了空间复杂度。
- 通过倒序遍历避免了状态覆盖问题，确保计算的正确性。
- 代码实现简洁，适合有一定基础的读者。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
  for(int j=m;j>=a[i];j--)
      f[j]=f[j]+f[j-a[i]];
```

#### 3. 作者：WilliamPen (4星)
**关键亮点**：
- 代码简洁，直接使用一维数组进行状态转移，适合快速实现。
- 通过初始化 `f[0]=1` 确保正确计算方案数。
- 代码可读性强，适合快速上手。

**核心代码**：
```cpp
for(int i=1;i<=n;++i)
  for(int j=m;j>=v[i];--j)
      f[j]+=f[j-v[i]];
```

### 最优关键思路或技巧
1. **状态转移方程**：核心思想是通过 `f[j] += f[j - a[i]]` 来计算方案数，确保每种方案都被正确计数。
2. **空间优化**：通过倒序遍历一维数组，避免状态覆盖，优化空间复杂度。
3. **初始化**：`f[0] = 1` 是确保正确计算方案数的关键，表示预算为0时有一种方案（不点任何菜）。

### 可拓展之处
该题可以拓展为多重背包问题，即每种菜有多个可选，或者扩展到其他类似的动态规划问题，如硬币找零、子集和问题等。

### 推荐相似题目
1. P1048 [NOIP2005 普及组] 采药
2. P1064 [NOIP2006 提高组] 金明的预算方案
3. P1616 疯狂的采药

### 个人心得摘录
- **Dream_zhc**：通过倒序遍历避免了状态覆盖问题，确保计算的正确性。
- **WilliamPen**：初始化 `f[0] = 1` 是确保正确计算方案数的关键。

这些心得帮助读者更好地理解动态规划的实现细节和优化技巧。

---
处理用时：25.58秒
# 题目信息

# 安全逃离（数据有误）

## 题目背景

**注意本题数据有误，请暂时不要提交**

## 题目描述

农夫`john`最近在研究如果发生重大事故，如何让农场里的奶牛逃离问题。他想要确信在紧急情况下，所有的奶牛都有一个安全逃离方案。因为在紧急情况下，奶牛们都会失去观察和判断能力，所以最近`john`一直在教奶牛们逃离的方法，他的方法很简单，就是任何时候都只向北方或东方逃离，北方是行坐标减1的方向，东方是列坐标加1的方向。奶牛们虽笨，不过这一点事关自己的生命，所以他们牢记在心，而且也一定会这么做。

当然也会出问题，奶牛们在逃离的方向上会横冲直撞，为了阻止奶牛之间互相冲撞造成伤害，`john`要求任何一个奶牛的逃离路线不能经过其它奶牛的初始位置。一个逃离方案是安全的如果它能够满足上面的要求，反之它就是不安全的。

奶牛们所在的土地（农场）被划分成了$r$行和$c$列的一个矩形地图。奶牛们都待在这个矩形中的某一个位置。

请帮助`john`确定给定的一个地图上是否存在一个安全的逃离方案。

比如，下面的两个图：

左边的例子表示了一个能够安全逃离的地图，因为没有任何一个奶牛的逃离路线上包括其他奶牛。右边的例子表示了一个不安全的地图，因为位于$(4,1)$的奶牛不论是向东逃离还是向北逃离，它的路线上都会有别的奶牛，从这个图中拿掉任意一头奶牛，这个地图都会变成安全的。

```plain
  安全     不安全
- ||||C--  C.....
- ||||C--  ^.....
- |C||C--  |.....
- CC++---  C-->C.
- ..CCC--  ......
```

`C` 表示奶牛，直线表示逃离路线。

## 样例 #1

### 输入

```
5 5
5
1 1
2 4
3 1
2 2
2 1
```

### 输出

```
1
5
```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
本题的核心逻辑是通过模拟奶牛的逃离路线，判断是否存在安全的逃离方案。题解主要集中在如何通过枚举和模拟来判断奶牛的安全状态，以及如何处理输入数据中的异常（如多余的字符）。以下是各题解的要点和难点对比：

1. **jacky567** 的题解提供了两种思路：一是通过模拟删除每只奶牛后判断是否安全，二是通过统计每只奶牛北边和东边的奶牛数量进行判断。难点在于处理输入数据中的异常字符，以及如何高效地判断奶牛的安全状态。
  
2. **Eraine** 的题解通过定义安全函数，分别处理三种情况：全部安全、删除一只奶牛后安全、无法安全。难点在于如何高效地判断奶牛的安全状态，并处理输入数据中的异常。

3. **梧桐灯** 的题解通过纯暴力枚举每只奶牛的逃离路线，判断是否存在安全方案。难点在于如何处理输入数据中的异常字符，并优化枚举的效率。

4. **猪猪** 的题解通过模拟每只奶牛的逃离路线，判断是否存在安全方案。难点在于如何处理输入数据中的异常字符，并优化模拟的效率。

5. **姬海棠果** 的题解通过枚举删除每只奶牛后判断是否安全，难点在于如何处理输入数据中的异常字符，并优化枚举的效率。

### 所选高星题解
#### 1. jacky567 (4星)
- **关键亮点**：提供了两种思路，分别通过模拟和统计进行判断，代码结构清晰，处理了输入数据中的异常字符。
- **个人心得**：作者提到在另一个OJ上注意到输入数据中的异常字符，但未意识到这是一个漏洞，最终通过AC程序找到了错误。

```cpp
int anquan(int x,int y){     //每头奶牛安全的条件 
  int t1=1,t2=1;
  for(int i=1;i<x;i++) if(m[i][y]) {t1=0;break;}     //如果北面有奶牛，那么t1=0 
  for(int i=y+1;i<=l;i++) if(m[x][i]) {t2=0;break;}     //如果东面有奶牛，那么t2=0 
  if(t1==0&&t2==0) return 0; else return 1;     //如果两边都有奶牛，则不安全，反之安全 
}
```

#### 2. Eraine (4星)
- **关键亮点**：通过定义安全函数，分别处理三种情况，代码结构清晰，处理了输入数据中的异常字符。

```cpp
bool p(int x,int y){
	bool g=true;
	for(int i=x-1;i>0;i--){
		if(a[i][y])g=false;
	}
	for(int i=y+1;i<=c;i++)if(a[x][i]&&g==false)return true;
	return false;
}
```

#### 3. 梧桐灯 (4星)
- **关键亮点**：通过纯暴力枚举每只奶牛的逃离路线，判断是否存在安全方案，代码简洁，处理了输入数据中的异常字符。

```cpp
for (i = 1; i <= k; i++) { //枚举删除第i号奶牛
	for (j = 1; j <= k; j++) {
		if (j == i)
			continue;
		f1 = f2 = 0;
		for (u = 1; u <= k; u++) {
			if (u == i || u == j)
				continue;
			if (s[u].y == s[j].y && s[u].x < s[j].x)
				f1 = 1;
			if (s[u].x == s[j].x && s[u].y > s[j].y)
				f2 = 1;
		}
		if (f1 && f2)
			break;
	}
	if (j > k) {
		printf ("%d\n", i);
	    wh = 0;
	}
}
```

### 最优关键思路
- **处理输入异常**：通过 `gets` 函数读取多余的字符，避免输入数据中的异常字符影响程序运行。
- **模拟与枚举**：通过模拟每只奶牛的逃离路线，或枚举删除每只奶牛后判断是否安全，确保所有奶牛都能安全逃离。

### 可拓展之处
- **优化枚举效率**：可以通过预处理每只奶牛的北边和东边的奶牛数量，减少枚举的次数。
- **类似题目**：可以扩展到其他需要模拟或枚举的场景，如路径规划、资源分配等。

### 推荐题目
1. [P1172 安全逃离](https://www.luogu.com.cn/problem/P1172)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1036 选数](https://www.luogu.com.cn/problem/P1036)

### 个人心得总结
- **调试经历**：作者在另一个OJ上注意到输入数据中的异常字符，但未意识到这是一个漏洞，最终通过AC程序找到了错误。
- **踩坑教训**：在处理输入数据时，要注意异常字符的影响，避免程序运行出错。

---
处理用时：32.70秒
# 题目信息

# 打砖块

## 题目描述

小红很喜欢玩一个叫打砖块的游戏，这个游戏的规则如下：

在刚开始的时候，有 $n$ 行 $m$ 列的砖块，小红有 $k$ 发子弹。小红每次可以用一发子弹，打碎某一列当前处于这一列最下面的那块砖，并且得到相应的得分。（如图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/twgirdp6.png)

某些砖块在打碎以后，还可能将得到一发子弹的奖励。最后当所有的砖块都打碎了，或者小红没有子弹了，游戏结束。

小红在游戏开始之前，就已经知道每一块砖在打碎以后的得分，并且知道能不能得到一发奖励的子弹。小红想知道在这次游戏中她可能的最大得分，可是这个问题对于她来说太难了，你能帮帮她吗？


## 说明/提示

对于 $20\%$ 的数据，满足 $1  \le n,m  \le 5$，$1  \le k  \le 10$，所有的字符 $c$ 都为 `N`。

对于 $50\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，所有的字符 $c$ 都为 `N`。

对于 $100\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，字符 $c$ 可能为 `Y`。

对于 $100\%$ 的数据，所有的 $f$ 值满足 $1  \le f  \le 10000$。


## 样例 #1

### 输入

```
3 4 2
9 N 5 N 1 N 8 N
5 N 5 Y 5 N 5 N
6 N 2 N 4 N 3 N```

### 输出

```
13```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
该题目核心是通过动态规划解决打砖块问题，难点在于如何处理子弹的借还机制以及如何优化状态转移。题解中，大部分作者都采用了动态规划的思路，但具体实现方式有所不同。部分题解通过预处理每列的得分和子弹消耗，再结合分组背包的思想进行状态转移，而另一些题解则通过引入额外的状态来区分最后一颗子弹是否打在当前列上。

### 所选高分题解

#### 题解1：zzzyc (5星)
**关键亮点**：
- 通过预处理每列的得分和子弹消耗，简化了状态转移的复杂度。
- 使用`fy`和`fn`两个数组分别表示最后一颗子弹是否打在当前列上，清晰地区分了不同情况。
- 代码简洁且高效，时间复杂度为O(nmk)。

**核心代码**：
```cpp
for(int x=1;x<=m;x++)  // 第x列
    for(int y=0;y<=k;y++)  // 总共y颗子弹
        for(int z=0;z<=n && z<=y;z++)  // 要用z颗
        {
            fy[x][y]=max(fy[x][y],fy[x-1][y-z]+sy[x][z]);
            if(z!=0) fn[x][y]=max(fn[x][y],fy[x-1][y-z]+sn[x][z]);  // 后打x列
            if(y-z>0) fn[x][y]=max(fn[x][y],fn[x-1][y-z]+sy[x][z]);  // 先打x列
        }
```

#### 题解2：I_AM_HelloWord (4星)
**关键亮点**：
- 引入了“借子弹”的概念，通过`dp[i][j][0/1]`表示前i列是否借了子弹，解决了子弹借还的问题。
- 状态转移方程清晰，分别处理了借子弹和不借子弹的情况。

**核心代码**：
```cpp
dp[j][k][0]=max(dp[j][k][0],dp[j-1][k-tot[j][i]][1]+sum1[j][i]); // 打掉这个N用掉了从前面借来的最后一发子弹
dp[j][k][0]=max(dp[j][k][0],dp[j-1][k-tot[j][i]][0]+sum2[j][i]); // 打掉一连串的Y后把多余的子弹借给前面列
dp[j][k][1]=max(dp[j][k][1],dp[j-1][k-tot[j][i]][1]+sum2[j][i]); // 在前面借一个子弹，打完一连串的Y，然后还一个子弹回去
```

#### 题解3：Azuree (4星)
**关键亮点**：
- 通过预处理`v[i][j][0/1]`表示第i列用j发子弹且最后一发子弹打在N或Y上的得分，简化了状态转移。
- 状态转移方程分为三种情况，分别处理了最后一颗子弹是否打在当前列上。

**核心代码**：
```cpp
f[i][j][1] = max(f[i][j][1],f[i - 1][j - l][1] + v[i][l][1]);
if(l) f[i][j][0] = max(f[i][j][0],f[i - 1][j - l][1] + v[i][l][0]);
if(j > l) f[i][j][0] = max(f[i][j][0],f[i - 1][j - l][0] + v[i][l][1]);
```

### 最优关键思路
- **预处理**：通过预处理每列的得分和子弹消耗，简化了状态转移的复杂度。
- **状态设计**：引入额外的状态来区分最后一颗子弹是否打在当前列上，解决了子弹借还的问题。
- **分组背包**：结合分组背包的思想，优化了状态转移的效率。

### 拓展思路
- 类似问题可以扩展到多维度动态规划，如处理多个资源（如子弹、时间等）的优化问题。
- 可以结合贪心算法，进一步优化子弹的使用顺序。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典背包问题，与本题的子弹使用类似。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 动态规划与背包问题的结合。
3. [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541) - 多维动态规划，与本题的状态设计类似。

---
处理用时：34.36秒
# 题目信息

# [TJOI2011] 序列

## 题目描述

一数列 $A=\{a_1,a_2,\ldots,a_n\}$，根据数列 $A$ 计算数列 $B=\{b_1,b_2,\ldots,b_n\}$，其中：  

$$
b_i=
\begin{cases}
a_1 &, i=1 \\ 
\min_{1 \leq j < i}\left|a_i-a_j\right| &, i\gt 1 
\end{cases}
$$

求 $\sum\limits^n_{i=1}b_i$。

## 说明/提示

$1\le t\le 10$，$1\le n\le10^5$，$0\le a_i\le65536$。

## 样例 #1

### 输入

```
2
5 1 2 3 4 5
7 2 9 7 4 6 2 6
```

### 输出

```
5
14
```

# AI分析结果

### 算法分类
**模拟**

### 综合分析与结论
题目要求计算一个数列中每个元素与前面所有元素的最小绝对差，并求和。由于数据范围较小（0 ≤ a_i ≤ 65536），大多数题解采用了基于模拟的思路，利用数组或集合来记录已经出现的数字，并通过遍历或二分查找来快速找到与当前元素最接近的数字。

### 所选高星题解

#### 1. 作者：小马一只 (赞：17)  
**星级：★★★★★**  
**关键亮点：**  
- 利用布尔数组记录数字是否出现，通过从当前数字向左右遍历找到最近出现的数字，时间复杂度为O(n * 65536)，但由于数据范围小，实际运行效率较高。
- 代码简洁，逻辑清晰，适合初学者理解。

**核心代码：**
```cpp
bool hav[65537];
int main() {
    int n, t, i, ans, tmp;
    scanf("%d", &t);
    while (t--) {
        memset(hav, false, sizeof(hav));
        scanf("%d%d", &n, &tmp);
        hav[tmp] = true;
        ans = tmp;
        while (--n) {
            scanf("%d", &tmp);
            for (i = 0;; i++) {
                if (tmp - i >= 0 && hav[tmp - i]) {
                    ans += i;
                    break;
                }
                if (tmp + i <= 65536 && hav[tmp + i]) {
                    ans += i;
                    break;
                }
            }
            hav[tmp] = true;
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

#### 2. 作者：s_r_f (赞：7)  
**星级：★★★★☆**  
**关键亮点：**  
- 使用树状数组结合二分查找，时间复杂度为O(T * n * log(n) * log(n))，适合更大数据范围的扩展。
- 代码实现较为复杂，但优化了查找效率，适合对数据结构有一定基础的读者。

**核心代码：**
```cpp
void Insert(int x) {
    while (x <= m) ++d[x], x += lowbit(x);
}

int Ask(int x) {
    int tot = 0;
    while (x) tot += d[x], x -= lowbit(x);
    return tot;
}

int query(int l, int r) {
    return Ask(r) - Ask(l - 1);
}
```

#### 3. 作者：一只小H (赞：3)  
**星级：★★★★☆**  
**关键亮点：**  
- 使用`set`结合`lower_bound`进行二分查找，时间复杂度为O(n log n)，代码简洁且易于理解。
- 适合对STL有一定了解的读者，代码可读性高。

**核心代码：**
```cpp
set<int> s;
int main() {
    cin >> t;
    while (t--) {
        s.clear();
        cin >> n;
        for (int i = 1; i <= n; ++i) {
            cin >> input;
            if (i == 1) {
                s.insert(input);
                ans += input;
                continue;
            }
            set<int>::iterator tmp = s.lower_bound(input);
            if (tmp == s.end()) {
                ans += abs(input - *(--tmp));
            } else if (tmp == s.begin()) {
                ans += abs(input - *(tmp));
            } else {
                ans += min(abs(input - *(--tmp)), abs(input - *(tmp)));
            }
            s.insert(input);
        }
        cout << ans << endl;
    }
    return 0;
}
```

### 最优关键思路或技巧
- **布尔数组记录法**：适用于数据范围较小的情况，通过记录数字是否出现，快速找到最近出现的数字。
- **树状数组结合二分查找**：适用于数据范围较大的情况，优化查找效率。
- **STL `set`结合`lower_bound`**：利用STL的便捷性，简化代码实现，适合对STL熟悉的读者。

### 可拓展之处
- 如果数据范围更大，可以考虑使用平衡树（如Treap、Splay）来优化查找效率。
- 类似题目可以考察如何在动态数据集中快速找到与给定值最接近的元素。

### 推荐题目
1. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3380 【模板】二逼平衡树（树套树）](https://www.luogu.com.cn/problem/P3380)

---
处理用时：33.98秒
# 题目信息

# 【深基9.例4】求第 k 小的数

## 题目描述

输入 $n$（$1 \le n < 5000000$ 且 $n$ 为奇数）个数字 $a_i$（$1 \le a_i < {10}^9$），输出这些数字的第 $k$ 小的数。最小的数是第 $0$ 小。

请尽量不要使用 `nth_element` 来写本题，因为本题的重点在于练习分治算法。

## 样例 #1

### 输入

```
5 1
4 3 2 1 5
```

### 输出

```
2
```

# AI分析结果

### 算法分类
分治

### 综合分析与结论
本题的核心在于如何在O(n)时间复杂度内找到第k小的数。虽然题目建议不使用`nth_element`，但大部分题解仍然围绕快速排序的分治思想展开，部分题解还引入了STL的`nth_element`函数。以下是各题解的主要思路和优化点：

1. **快速排序分治法**：通过快速排序的划分思想，每次递归只处理包含第k小数的区间，从而将时间复杂度优化到O(n)。
2. **STL的`nth_element`**：直接使用STL中的`nth_element`函数，虽然不符合题目要求，但代码简洁且效率高。
3. **基数排序**：通过基数排序实现O(n)的时间复杂度，虽然代码复杂，但在特定情况下表现优异。

### 所选题解

#### 1. 时律 - 思路 2 (100pts)：$O(n)$
**星级**: 4.5星  
**关键亮点**: 基于快速排序的分治思想，每次递归只处理包含第k小数的区间，优化了时间复杂度。  
**核心代码**:
```cpp
void qsort(int l,int r) {
    int i=l,j=r,mid=x[(l+r)/2];
    do {
        while(x[j]>mid) j--;
        while(x[i]<mid) i++;
        if(i<=j) swap(x[i],x[j]), i++, j--;
    } while(i<=j);
    if(k<=j) qsort(l,j);
    else if(i<=k) qsort(i,r);
    else printf("%d",x[j+1]), exit(0);
}
```
**实现思想**: 通过快速排序的划分思想，每次递归只处理包含第k小数的区间，从而将时间复杂度优化到O(n)。

#### 2. Hope2075 - 最坏情况下 $O(n)$ 的算法
**星级**: 4星  
**关键亮点**: 引入了《算法导论》中的SELECT算法，保证最坏情况下时间复杂度为O(n)。  
**核心代码**:
```cpp
int find_kth(int beg,int end,int k) {
    if(end-beg<=MAX_SORT_SIZE) {
        insert_sort(beg,end);
        return a[beg+k];
    } else {
        int len2=(end-beg+GROUP_SIZE-1);
        int pos=beg;
        for(int t=beg;t<end;t+=GROUP_SIZE) {
            int e1=t+GROUP_SIZE;
            if(e1>end) e1=end;
            insert_sort(t,e1);
            int id=(e1-t-1)/2;
            int s=a[t+id];a[t+id]=a[pos];a[pos]=s;
            pos++;
        }
        int val=find_kth(beg,pos,(beg+pos)/2-beg);
        int p1=beg,p2=end,p3=end;
        while(p1<p2) {
            if(a[p1]<val) p1++;
            else {
                p2--;
                int t=a[p1];a[p1]=a[p2];a[p2]=t;
            }
        }
        while(p2<p3) {
            if(a[p2]==val) p2++;
            else {
                p3--;
                int t=a[p2];a[p2]=a[p3];a[p3]=t;
            }
        }
        if(beg+k>=p1) {
            if(beg+k>=p2) return find_kth(p2,end,k-(p2-beg));
            else return val;
        } else {
            return find_kth(beg,p1,k);
        }
    }
}
```
**实现思想**: 通过将数组划分为5个一组，找到每组的中位数，再递归找到中位数的中位数，保证划分的均匀性，从而在最坏情况下也能达到O(n)的时间复杂度。

#### 3. zjh114514 - 基数排序
**星级**: 4星  
**关键亮点**: 使用基数排序实现O(n)的时间复杂度，虽然代码复杂，但在特定情况下表现优异。  
**核心代码**:
```cpp
void RadixSort(int op) {
    std::vector<int> bucket[100000];
    for (int i = 0; i < n; i++) {
        bucket[a[i] / kPow[op] % 100000].push_back(a[i]);
    }
    int total = 0;
    for (int i = 0; i < 100000; i++) for (int j : bucket[i]) a[total++] = j;
}
```
**实现思想**: 通过基数排序，将数组元素按位分组，逐步排序，最终实现O(n)的时间复杂度。

### 最优关键思路
基于快速排序的分治思想，每次递归只处理包含第k小数的区间，是最简洁且高效的解决方案。虽然STL的`nth_element`函数也能达到相同效果，但不符合题目要求。

### 可拓展之处
类似的分治思想可以应用于其他选择问题，如查找中位数、第k大数等。此外，基数排序在处理大规模数据时也有其独特优势。

### 推荐题目
1. [P1138 第k小整数](https://www.luogu.com.cn/problem/P1138)
2. [P1923 求第k小的数](https://www.luogu.com.cn/problem/P1923)
3. [P3834 可持久化线段树](https://www.luogu.com.cn/problem/P3834)

---
处理用时：42.55秒
# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果

【算法分类】线段树

【综合分析】
本题是一道典型的线段树模板题，要求实现区间加法、区间乘法和区间查询操作。题解主要集中在如何高效地维护区间信息，特别是如何处理加法和乘法的懒标记下传问题。大多数题解采用了线段树的基本结构，并通过维护两个懒标记（add和mul）来实现操作。部分题解还提到了优化技巧，如使用指针、位运算等来提高代码效率。

【精选题解】
1. **题解作者：MashPlant**
   - **星级：5星**
   - **关键亮点**：使用__int128优化取模运算，详细解释了线段树的懒标记下传机制，代码简洁高效。
   - **核心代码**：
     ```cpp
     void pushdown(int p, int l, int r) {
         if (add[p] || mul[p] != 1) {
             int mid = (l + r) >> 1;
             sum[p << 1] = (sum[p << 1] * mul[p] + add[p] * (mid - l + 1)) % p;
             sum[p << 1 | 1] = (sum[p << 1 | 1] * mul[p] + add[p] * (r - mid)) % p;
             add[p << 1] = (add[p << 1] * mul[p] + add[p]) % p;
             add[p << 1 | 1] = (add[p << 1 | 1] * mul[p] + add[p]) % p;
             mul[p << 1] = (mul[p << 1] * mul[p]) % p;
             mul[p << 1 | 1] = (mul[p << 1 | 1] * mul[p]) % p;
             mul[p] = 1; add[p] = 0;
         }
     }
     ```

2. **题解作者：YuntianZhao**
   - **星级：4星**
   - **关键亮点**：使用结构体指针构建线段树，详细解释了懒标记的下传和更新操作，代码结构清晰。
   - **核心代码**：
     ```cpp
     void pushdown(Node *p) {
         if (p->addmark || p->mulmark != 1) {
             p->lc->sum = (p->lc->sum * p->mulmark + p->addmark * (p->lc->r - p->lc->l + 1)) % p;
             p->rc->sum = (p->rc->sum * p->mulmark + p->addmark * (p->rc->r - p->rc->l + 1)) % p;
             p->lc->mulmark = (p->lc->mulmark * p->mulmark) % p;
             p->rc->mulmark = (p->rc->mulmark * p->mulmark) % p;
             p->lc->addmark = (p->lc->addmark * p->mulmark + p->addmark) % p;
             p->rc->addmark = (p->rc->addmark * p->mulmark + p->addmark) % p;
             p->mulmark = 1; p->addmark = 0;
         }
     }
     ```

3. **题解作者：Owen_codeisking**
   - **星级：4星**
   - **关键亮点**：使用位运算优化代码，详细解释了线段树的构建和操作，代码简洁高效。
   - **核心代码**：
     ```cpp
     void pushdown(int p, int l, int r) {
         if (add[p] || mul[p] != 1) {
             int mid = (l + r) >> 1;
             sum[p << 1] = (sum[p << 1] * mul[p] + add[p] * (mid - l + 1)) % p;
             sum[p << 1 | 1] = (sum[p << 1 | 1] * mul[p] + add[p] * (r - mid)) % p;
             add[p << 1] = (add[p << 1] * mul[p] + add[p]) % p;
             add[p << 1 | 1] = (add[p << 1 | 1] * mul[p] + add[p]) % p;
             mul[p << 1] = (mul[p << 1] * mul[p]) % p;
             mul[p << 1 | 1] = (mul[p << 1 | 1] * mul[p]) % p;
             mul[p] = 1; add[p] = 0;
         }
     }
     ```

【最优关键思路】
1. **懒标记下传**：在处理区间更新时，使用懒标记（add和mul）来延迟更新操作，直到需要查询或更新子区间时才进行下传，从而减少不必要的计算。
2. **优化取模运算**：通过使用__int128或位运算来优化取模运算，提高代码效率。
3. **结构体指针**：使用结构体指针构建线段树，提高代码的可读性和可维护性。

【拓展思路】
1. **动态开点线段树**：在处理稀疏数据时，可以使用动态开点线段树来节省空间。
2. **区间最值查询**：在维护区间和的同时，可以扩展线段树功能，支持区间最值查询。

【推荐题目】
1. P3373 【模板】线段树 2
2. P3372 【模板】线段树 1
3. P5490 【模板】扫描线

---
处理用时：56.84秒
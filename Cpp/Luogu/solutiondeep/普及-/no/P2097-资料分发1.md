# 题目信息

# 资料分发1

## 题目描述

有一些电脑，一部分电脑有双向数据线连接。如果一个电脑得到数据，它可以传送到的电脑都可以得到数据。现在，你有这个数据，问你至少将其输入几台电脑，才能使所有电脑得到数据。


## 说明/提示

对于30%的数据：n<=100,m<=1000

对于60%的数据:n<=2000,m<=100000

对于100%的数据：n<=100000, m<=200000

数据不保证没有重边，不保证没有自回环


## 样例 #1

### 输入

```
4 5
1 2
1 3
2 3
2 1
3 4```

### 输出

```
1```

# AI分析结果

### 算法分类
并查集

### 综合分析与结论
该题的核心是求无向图中连通块的数量，可以通过并查集或深度优先搜索（DFS）来解决。并查集通过路径压缩和合并操作，能够高效地统计连通块的数量；DFS则通过遍历未访问的节点，标记所有可达节点，统计连通块的数量。并查集在时间效率上优于DFS，尤其是在大规模数据下。

### 所选高星题解
1. **作者：Catalyst_M (赞：10)**
   - **星级：5星**
   - **关键亮点：** 使用并查集，代码简洁且高效，路径压缩优化了查找操作，统计集合数的方式清晰。
   - **核心代码：**
     ```cpp
     int find(int x) {
         return (fa[x]==x?x:fa[x]=find(fa[x]));
     }
     void unionn(int x, int y) {
         int xx=find(x);
         int yy=find(y);
         if(xx!=yy) fa[xx]=yy;
     }
     ```
   - **个人心得：** 并查集是解决连通性问题的经典方法，路径压缩和启发式合并能显著提升效率。

2. **作者：LinkZelda (赞：3)**
   - **星级：4星**
   - **关键亮点：** 使用结构体封装并查集，代码结构清晰，易于理解。
   - **核心代码：**
     ```cpp
     struct UnionFind{
         int bin[100005];
         UnionFind() {
             for(int i=0;i<100005;i++) bin[i]=i;
         }
         int find(int x) {
             if(bin[x]==x) return x;
             return bin[x]=find(bin[x]);
         }
         void uni(int x, int y) {
             bin[find(x)]=find(y);
         }
     }U;
     ```
   - **个人心得：** 封装并查集结构体，代码更易维护和复用。

3. **作者：cyffff (赞：3)**
   - **星级：4星**
   - **关键亮点：** 提供了三种解法（DFS、强连通分量、并查集），并比较了它们的效率，代码实现清晰。
   - **核心代码：**
     ```cpp
     int find(int x) {
         if(x!=f[x]) f[x]=find(f[x]);
         return f[x];
     }
     ```
   - **个人心得：** 并查集是最优解法，DFS和强连通分量虽然可行，但效率较低。

### 最优关键思路或技巧
1. **并查集**：通过路径压缩和合并操作，高效统计连通块数量。
2. **DFS**：通过遍历未访问节点，标记所有可达节点，统计连通块数量。

### 可拓展之处
- **同类型题**：类似问题包括求最小生成树、判断图的连通性等。
- **算法套路**：并查集和DFS是解决图论中连通性问题的常用方法。

### 推荐题目
1. P3367 【模板】并查集
2. P3387 【模板】缩点
3. P3371 【模板】单源最短路径（弱化版）

---
处理用时：25.39秒
# 题目信息

# 搬运工

## 题目背景

陈老师喜欢网购书籍，经常一次购它个百八十本，然后拿来倒卖牟取暴利。

## 题目描述

前些天，高一的新同学来了，他便像往常一样兜售他的书，经过一番口舌，同学们决定买他的书，但是陈老师桌上的书有三堆，每一堆都有厚厚的一叠，他要想个办法用最轻松的方式把书拿下来给同学们。但是你想逗一下陈老师，于是你设计一个最累的方式给他。若告诉你这三堆分别有 $i$，$j$，$k$ 本书，以及每堆从下到上书的质量，每次取书只能从任一堆的最上面取，那么请你设计一个方案，让他花最大的力气取下所有的书。

显然，每次取书陈老师的体力消耗都会加大，这里用体力系数代表，取下第一本书时，体力系数为 $1$，第二本书时体力系数为 $2$，依次类推，而每次体力消耗值则为体力系数与书的重量之积。

## 说明/提示

#### 数据规模与约定

+ 对于 $50\%$ 的数据有 $0\le i,j,k\lt10$。
+ 对于 $100\%$ 的数据有 $0\le i,j,k\lt100$。

最后输出的体力消耗总值在 C++ int 范围内。

## 样例 #1

### 输入

```
3 2 4
2 3 2
1 5
9 8 7 4
```

### 输出

```
257```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
该题目要求计算在每次取书时体力消耗的最大值，且每次取书只能从任一堆的最上面取。由于每次取书的选择会影响后续的体力消耗，因此需要使用动态规划来解决。题解中主要分为两种思路：DFS（深度优先搜索）和DP（动态规划）。DFS的思路是通过递归枚举所有可能的取书顺序，计算每种情况下的体力消耗，最终取最大值。DP的思路则是通过状态转移方程，逐步计算每种状态下的最大体力消耗。

### 所选高星题解
1. **作者：绝_尘 (赞：6)**
   - **星级：4星**
   - **关键亮点：**
     - 使用三维DP数组 `f[i][j][k]` 表示三堆书分别剩下 `i`、`j`、`k` 本时的最大体力消耗。
     - 通过状态转移方程 `f[i][j][k] = max(f[i-1][j][k]+x[i]*s, max(f[i][j-1][k]+y[j]*s, f[i][j][k-1]+z[k]*s))` 来计算每种状态下的最大值。
     - 代码简洁明了，逻辑清晰。
   - **核心代码：**
     ```cpp
     for(int i=0;i<=a;i++)
         for(int j=0;j<=b;j++)
             for(int k=0;k<=c;k++){
                 int s=to-i-j-k+1;
                 if(i)f[i][j][k]=x[i]*s+f[i-1][j][k];
                 if(j)f[i][j][k]=max(f[i][j][k],y[j]*s+f[i][j-1][k]);
                 if(k)f[i][j][k]=max(f[i][j][k],z[k]*s+f[i][j][k-1]);
             }
     ```

2. **作者：naroanah (赞：5)**
   - **星级：4星**
   - **关键亮点：**
     - 使用三维DP数组 `maxv[i][j][k]` 表示三堆书分别取了 `i`、`j`、`k` 本时的最大体力消耗。
     - 通过状态转移方程 `maxv[i][j][k] = max(maxv[i][j][k], maxv[i-1][j][k]+t*booka[a-i+1])` 来计算每种状态下的最大值。
     - 代码结构清晰，易于理解。
   - **核心代码：**
     ```cpp
     for(int i=0;i<=a;i++){
         for(int j=0;j<=b;j++){
             for(int k=0;k<=c;k++){
                 int t=i+j+k;
                 if(i>0) maxv[i][j][k]=max(maxv[i][j][k],maxv[i-1][j][k]+t*booka[a-i+1]);
                 if(j>0) maxv[i][j][k]=max(maxv[i][j][k],maxv[i][j-1][k]+t*bookb[b-j+1]);
                 if(k>0) maxv[i][j][k]=max(maxv[i][j][k],maxv[i][j][k-1]+t*bookc[c-k+1]);
             }
         }
     }
     ```

3. **作者：Coros_Trusds (赞：1)**
   - **星级：4星**
   - **关键亮点：**
     - 使用三维DP数组 `dp[i][j][v]` 表示三堆书分别取了 `i`、`j`、`v` 本时的最大体力消耗。
     - 通过状态转移方程 `dp[i][j][v] = max(dp[i][j][v], a[i]*val + dp[i-1][j][v])` 来计算每种状态下的最大值。
     - 代码逻辑清晰，易于理解。
   - **核心代码：**
     ```cpp
     for(register int i=0;i<=n;i++){
         for(register int j=0;j<=m;j++){
             for(register int v=0;v<=k;v++){
                 int val=tot-i-j-v+1;
                 if(i!=0) dp[i][j][v]=max(dp[i][j][v],a[i]*val+dp[i-1][j][v]);
                 if(j!=0) dp[i][j][v]=max(dp[i][j][v],b[j]*val+dp[i][j-1][v]);
                 if(v!=0) dp[i][j][v]=max(dp[i][j][v],c[v]*val+dp[i][j][v-1]);
             }
         }
     }
     ```

### 最优关键思路或技巧
- **动态规划状态定义：** 使用三维DP数组表示三堆书分别剩下或取了多少本时的最大体力消耗。
- **状态转移方程：** 通过比较从每堆取书的情况，选择最大体力消耗的状态进行转移。
- **体力系数计算：** 体力系数 `s` 或 `t` 表示当前取书的次数，用于计算每次取书的体力消耗。

### 可拓展之处
- **类似问题：** 类似的问题可以扩展到多堆物品的取法，每次取物品的选择会影响后续的结果，如背包问题的变种。
- **优化思路：** 可以通过剪枝或记忆化搜索来优化DFS的解法，减少不必要的计算。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 类似背包问题，选择最优解。
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064) - 多维度选择问题，使用动态规划解决。
3. [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541) - 多维动态规划，选择最优路径。

### 个人心得摘录
- **作者：绝_尘**：通过状态转移方程逐步计算每种状态下的最大体力消耗，代码简洁明了，逻辑清晰。
- **作者：naroanah**：使用三维DP数组表示三堆书分别取了多少本时的最大体力消耗，代码结构清晰，易于理解。
- **作者：Coros_Trusds**：通过状态转移方程计算每种状态下的最大值，代码逻辑清晰，易于理解。

---
处理用时：52.31秒
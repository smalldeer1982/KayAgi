# 题目信息

# 洗牌问题

## 题目描述

有 $ 2n $ 张牌，编号为

$$ 1,2,3 \dots n,n+1, \dots 2n$$

这也是最初的牌的顺序。一次洗牌是把序列变为

$$ n+1,1,n+2,2,n+3,3,n+4,4 \dots 2n,n $$

可以证明，对于任意自然数 $ n $，都可以在经过 $ m $ 次洗牌后第一次重新得到初始的顺序。

现给定 $n$（$n \le 10^8$），求出 $ m $ 的值。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 10^8$。

## 样例 #1

### 输入

```
20```

### 输出

```
20```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
该题目核心是通过数学方法找到洗牌次数的最小值，使得牌堆恢复到初始顺序。大多数题解通过观察牌的移动规律，发现牌的移动可以表示为数学公式，进而通过模拟或数论方法求解。其中，数论方法（如欧拉定理、快速幂）在效率上优于模拟方法，尤其是在处理大范围数据时。

### 所选高星题解

#### 题解1：作者：Terrible (赞：18)
**星级：5星**
**关键亮点：**
- 使用欧拉定理和快速幂，通过枚举因数找到最小解，效率高。
- 详细解释了数论背景和推导过程，思路清晰。
- 代码结构清晰，优化程度高。

**核心代码：**
```cpp
int phi(int x) {
    int p = x;
    for(int i = 2; i * i <= x; ++i)
        if(x % i == 0) {
            p -= p / i;
            while(x % i == 0) x /= i;
        }
    if(x > 1) p -= p / x;
    return p;
}

int fp(int q, int p, int MOD) {
    long long a = q % MOD, ans = 1;
    while(p) {
        if(p & 1) ans *= a, ans %= MOD;
        a *= a, a %= MOD, p >>= 1;
    }
    return ans;
}

int main() {
    int n, m, p, t, e;
    scanf("%d", &n);
    m = 2 * n + 1, p = phi(m), t = p, e = sqrt(p);
    for(int i = 1; i <= e; i++)
        if(fp(2, i, m) == 1) {
            t = i;
            break;
        } else {
            if(fp(2, p / i, m) == 1) t = p / i;
        }
    printf("%d", t);
}
```

#### 题解2：作者：kradcigam (赞：32)
**星级：4星**
**关键亮点：**
- 通过模拟牌的移动规律，找到1号牌的位置变化公式。
- 代码简洁，易于理解，适合初学者。

**核心代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n, i = 1, s = 0;
    cin >> n;
    do {
        if(i > n) i = (i - n) * 2 - 1;
        else i = i * 2;
        s++;
    } while(i != 1);
    cout << s;
    return 0;
}
```

#### 题解3：作者：Minclxc (赞：5)
**星级：4星**
**关键亮点：**
- 使用费马小定理和暴力枚举，思路简单直接。
- 代码简洁，适合小范围数据。

**核心代码：**
```cpp
#include<cstdio>
using namespace std;
int main() {
    int n, m = 1;
    scanf("%d", &n);
    for(int x = 2; x != 1; x = x * 2 % (2 * n + 1), m++);
    printf("%d\n", m);
    return 0;
}
```

### 最优关键思路或技巧
- **数论方法**：通过欧拉定理和快速幂，高效找到最小解。
- **模拟方法**：通过观察牌的移动规律，找到1号牌的位置变化公式，适合小范围数据。

### 可拓展之处
- 类似问题可以扩展到其他排列组合问题，如循环移位、置换群等。
- 数论方法在处理大范围数据时具有明显优势，可以应用于其他需要高效求解的问题。

### 推荐相似题目
1. P1226 【模板】快速幂
2. P1447 【模板】欧拉函数
3. P1965 转圈游戏

### 个人心得摘录
- **Terrible**：通过欧拉定理和快速幂，解决了大范围数据的效率问题，详细解释了数论背景，思路清晰。
- **kradcigam**：通过模拟牌的移动规律，找到1号牌的位置变化公式，代码简洁，适合初学者。
- **Minclxc**：使用费马小定理和暴力枚举，思路简单直接，适合小范围数据。

---
处理用时：29.46秒
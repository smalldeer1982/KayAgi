# 题目信息

# 纸币问题 1

## 题目描述

某国有 $n$ 种纸币，每种纸币面额为 $a_i$ 并且有无限张，现在要凑出 $w$ 的金额，试问最少用多少张纸币可以凑出来？

## 说明/提示

对于 $40\%$ 的数据，满足 $n\le 10$，$w\le 100$；  
对于 $100\%$ 的数据，满足 $1\le n\le 10^3$，$1\le a_i \leq w\le 10^4$。

## 样例 #1

### 输入

```
6 15
1 5 10 20 50 100```

### 输出

```
2```

## 样例 #2

### 输入

```
3 15
1 5 11```

### 输出

```
3```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
该问题是一个典型的完全背包问题，核心是通过动态规划求解最小纸币数。所有题解均采用了动态规划的思路，状态定义为 `f[i]` 表示凑出金额 `i` 所需的最小纸币数。转移方程为 `f[i] = min(f[i], f[i - a[j]] + 1)`，其中 `a[j]` 是纸币面额。题解的主要区别在于初始化方式、代码风格和优化细节。

### 所选题解

#### 题解1：sgl654321 (5星)
- **关键亮点**：思路清晰，代码简洁，初始化使用极大值，避免了不必要的判断。
- **代码核心**：
  ```cpp
  for(int i=1;i<=n;i++)
      for(int j=a[i];j<=w;j++)
          f[j]=min(f[j],f[j-a[i]]+1);
  ```
- **个人心得**：无

#### 题解2：timmark (4星)
- **关键亮点**：状态转移方程解释详细，代码可读性强，初始化使用 `memset`。
- **代码核心**：
  ```cpp
  memset(f,127,sizeof(int)*(w+5));
  f[0]=0;
  for(int i=1;i<=w;i++) 
      for(int j=1;j<=n;j++) 
          if(i>=a[j]) f[i]=min(f[i],f[i-a[j]]+1);
  ```
- **个人心得**：无

#### 题解3：shaozhehan (4星)
- **关键亮点**：代码结构清晰，使用了 `cin.tie` 和 `cout.tie` 加速输入输出，初始化使用 `memset`。
- **代码核心**：
  ```cpp
  memset(dp, 0x3f, sizeof(dp));
  dp[0] = 0;
  for (int j = a; j <= w; j++){
      dp[j] = min(dp[j], dp[j - a] + 1);
  }
  ```
- **个人心得**：无

### 最优关键思路或技巧
1. **状态定义**：`f[i]` 表示凑出金额 `i` 所需的最小纸币数。
2. **转移方程**：`f[i] = min(f[i], f[i - a[j]] + 1)`，其中 `a[j]` 是纸币面额。
3. **初始化**：`f[0] = 0`，其他值初始化为极大值。
4. **优化**：使用 `memset` 进行初始化，避免逐个赋值。

### 可拓展之处
类似的问题包括：
1. **完全背包问题**：如 [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. **最小硬币问题**：如 [P2918 [USACO08NOV]Buying Hay S](https://www.luogu.com.cn/problem/P2918)
3. **多重背包问题**：如 [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P2918 [USACO08NOV]Buying Hay S](https://www.luogu.com.cn/problem/P2918)
3. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)

### 个人心得总结
无显著个人心得。

---
处理用时：27.34秒
# 题目信息

# 【深基15.例2】寄包柜

## 题目描述

超市里有 $n(1\le n\le10^5)$ 个寄包柜。每个寄包柜格子数量不一，第 $i$ 个寄包柜有 $a_i(1\le a_i\le10^5)$ 个格子，不过我们并不知道各个 $a_i$ 的值。对于每个寄包柜，格子编号从 1 开始，一直到 $a_i$。现在有 $q(1 \le q\le10^5)$ 次操作：

- `1 i j k`：在第 $i$ 个柜子的第 $j$ 个格子存入物品 $k(0\le k\le 10^9)$。当 $k=0$ 时说明清空该格子。
- `2 i j`：查询第 $i$ 个柜子的第 $j$ 个格子中的物品是什么，保证查询的柜子有存过东西。

已知超市里共计不会超过 $10^7$ 个寄包格子，$a_i$ 是确定然而未知的，但是保证一定不小于该柜子存物品请求的格子编号的最大值。当然也有可能某些寄包柜中一个格子都没有。

## 说明/提示

$\text{upd 2022.7.26}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
5 4
1 3 10000 118014
1 1 1 1
2 3 10000
2 1 1```

### 输出

```
118014
1```

# AI分析结果

### 算法分类
**模拟**

### 综合分析与结论
本题的核心在于如何处理大规模的稀疏数据存储与查询。由于直接使用二维数组会导致空间复杂度爆炸，因此大多数题解都采用了动态数据结构（如 `map` 或 `vector`）来优化空间使用。`map` 是一种常见的选择，因为它可以高效地处理稀疏数据的存储与查询，且时间复杂度为 O(log n)。此外，部分题解还提到了将二维索引压缩为一维索引的技巧，进一步优化了空间使用。

### 所选高星题解
#### 1. 作者：linponess (赞：401)
- **星级**: 5
- **关键亮点**: 详细分析了直接使用二维数组和链表的优缺点，最终选择了 `map` 作为解决方案，并解释了如何通过压缩索引来优化空间使用。还提到了哈希表的替代方案，拓展了思路。
- **个人心得**: 作者通过逐步分析，最终选择了 `map` 作为最优解，体现了对问题的深入理解。

```cpp
#include<cstdio>
#include<map>
using namespace std;
int n,q,p,k;
map<long long,int>b;
long long i,j;
int main()
{
	scanf("%d%d",&n,&q);
	while(q--)
	{
		scanf("%d%d%d",&p,&i,&j);
		if(p==1)
		{
			scanf("%d",&k);
			b[i*1000000+j]=k;
		}
		else printf("%d\n",b[i*1000000+j]);
	}
	return 0;
}
```

#### 2. 作者：SUNCHAOYI (赞：202)
- **星级**: 4
- **关键亮点**: 使用了 `map<pair<int,int>,int>` 来存储数据，避免了二维数组的空间浪费。代码简洁，逻辑清晰。
- **个人心得**: 作者通过 `map` 的灵活使用，解决了空间复杂度的问题，体现了对 STL 的熟练运用。

```cpp
#include <cstdio>
#include <map>
using namespace std;
inline int read ();
int n,q; 
map <pair <int,int>,int> p;
int main ()
{
	n = read ();q = read ();
	while (q--)
	{
		int ty = read ();
		if (ty == 1) p[{read (),read ()}] = read ();
		else printf ("%d\n",p[{read (),read ()}]);
	}
	return 0;
}
```

#### 3. 作者：vectorwyx (赞：145)
- **星级**: 4
- **关键亮点**: 使用了 `map<int, map<int, int>>` 来存储数据，避免了二维数组的空间浪费。代码简洁，逻辑清晰。
- **个人心得**: 作者通过 `map` 的灵活使用，解决了空间复杂度的问题，体现了对 STL 的熟练运用。

```cpp
#include<cstdio>
#include<iostream> 
#include<map>
using namespace std;
map<int,map<int,int> > a;
int main(){
	int n,q,x,y,k,z;
    cin>>n>>q;
    for(int i=1;i<=q;++i){
        scanf("%d%d%d",&k,&x,&y);
        if(k==1){
            scanf("%d",&z);
            a[x][y]=z;
        }
        else printf("%d\n",a[x][y]);
    }
	return 0;
}
```

### 最优关键思路或技巧
- **使用 `map` 处理稀疏数据**: `map` 可以高效地处理稀疏数据的存储与查询，避免了二维数组的空间浪费。
- **压缩索引**: 将二维索引压缩为一维索引，进一步优化了空间使用。

### 可拓展之处
- **哈希表**: 可以使用哈希表来替代 `map`，进一步优化时间复杂度。
- **多维数据处理**: 类似的问题可以扩展到多维数据的处理，使用 `map` 或其他动态数据结构来优化空间使用。

### 推荐相似题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

### 个人心得摘录
- **linponess**: "一个OI选手的直觉告诉我们没有！！！" 体现了作者对问题的深入思考和逐步优化的过程。
- **SUNCHAOYI**: "于是乎，我们得到了最终复杂度正确的算法" 体现了作者对问题复杂度的精确把控。

---
处理用时：31.74秒
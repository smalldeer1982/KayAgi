# 题目信息

# 【深基16.例3】二叉树深度

## 题目描述

有一个 $n(n \le 10^6)$ 个结点的二叉树。给出每个结点的两个子结点编号（均不超过 $n$），建立一棵二叉树（根节点的编号为 $1$），如果是叶子结点，则输入 `0 0`。

建好这棵二叉树之后，请求出它的深度。二叉树的**深度**是指从根节点到叶子结点时，最多经过了几层。


## 样例 #1

### 输入

```
7
2 7
3 6
4 5
0 0
0 0
0 0
0 0```

### 输出

```
4```

# AI分析结果

### 算法分类
深度优先搜索 DFS

### 综合分析与结论
本题的核心是求二叉树的深度，主要考察二叉树的存储和遍历。所有题解都采用了深度优先搜索（DFS）或广度优先搜索（BFS）来遍历二叉树，并记录最大深度。DFS是更常见的解法，因为它天然适合递归实现，代码简洁且易于理解。

### 所选题解
1. **作者：zhangyuhan (赞：160)**  
   - **星级：5星**  
   - **关键亮点**：  
     - 使用结构体存储二叉树节点，代码清晰易读。  
     - 递归DFS实现简洁，逻辑清晰，时间复杂度为O(n)。  
     - 代码注释详细，适合初学者理解。  
   - **核心代码**：
     ```cpp
     void dfs(int id, int deep) {
         if (id == 0) return ;
         ans = max(ans, deep);
         dfs(tree[id].left, deep+1);
         dfs(tree[id].right, deep+1);
     }
     ```

2. **作者：HsKr (赞：58)**  
   - **星级：4星**  
   - **关键亮点**：  
     - 代码简洁，直接使用DFS遍历二叉树。  
     - 使用全局变量`Max`记录最大深度，实现简单。  
   - **核心代码**：
     ```cpp
     void dfs(int root, int step) {
         if (root == 0) return;
         Max = max(Max, step);
         dfs(a[root].l, step+1);
         dfs(a[root].r, step+1);
     }
     ```

3. **作者：Lylighte (赞：26)**  
   - **星级：4星**  
   - **关键亮点**：  
     - 提供了多种解法，包括DFS、BFS和父亲表示法。  
     - 代码结构清晰，适合不同学习阶段的读者。  
   - **核心代码**：
     ```cpp
     void bfs() {
         head=1, tail=2;
         que[head] = tree[1];
         que[head].id = 1;
         que[head].deep = 1;
         depth = 1;
         while (head < tail) {
             nod nownod = que[head];
             head++;
             depth = max(depth, nownod.deep);
             if (nownod.lc != 0) {
                 nod newnod = tree[nownod.lc];
                 newnod.id = nownod.lc;
                 newnod.deep = nownod.deep + 1;
                 que[tail++] = newnod;
             }
             if (nownod.rc != 0) {
                 nod newnod = tree[nownod.rc];
                 newnod.id = nownod.rc;
                 newnod.deep = nownod.deep + 1;
                 que[tail++] = newnod;
             }
         }
     }
     ```

### 最优关键思路或技巧
- **数据结构**：使用结构体存储二叉树节点，便于管理和访问。  
- **算法优化**：递归DFS实现简洁高效，时间复杂度为O(n)。  
- **思维方式**：通过递归或BFS遍历树结构，记录最大深度，适合树形问题的通用解法。

### 可拓展之处
- **同类型题**：类似问题包括求二叉树的最大宽度、最小深度等。  
- **类似算法套路**：DFS和BFS是解决树形问题的通用方法，适用于多种树形结构的遍历和搜索问题。

### 推荐题目
1. P1047 二叉树的最大宽度  
2. P1115 二叉树的最小深度  
3. P1305 二叉树的直径

---
处理用时：31.65秒
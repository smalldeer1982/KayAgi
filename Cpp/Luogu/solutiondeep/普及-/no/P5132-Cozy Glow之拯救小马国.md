# 题目信息

# Cozy Glow之拯救小马国

## 题目背景

本题难度普及-，请noip两个组别的选手都把它AC（~~不然你noip省三都保不住了~~）

ps：三年OI一场空，day1T1见祖宗。。。

## 题目描述

Cozy Glow偷偷摸摸的造了一个魔法阵，这个魔法阵在吸取小马国的魔力，所以你得赶紧把它毁掉。

这个魔法阵由若干个神器组成，每个神器都有一个法力值，每两个神器之间也都有一个关联值。你要依次把这些神器拿走，但是，每拿走一个神器，你就会受到一定量的反噬，反噬的量为这个神器与其他还在神器的关联值乘以这个神器的法力值，为了减少反噬，tb148需要拿走每个神器，但由于他贪生怕死，他想让他受到的反噬值之和最小，现在tb148想知道，怎样拿走神器，才能让反噬值的和最小。

## 说明/提示

神器个数<=1000

所有其他的值<=2000000

正对角线上的数保证都是零。。。

## 样例 #1

### 输入

```
4
2 5 1 7
0 343 154 12
343 0 214 132
154 214 0 441
12 132 441 0```

### 输出

```
2179```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
本题的核心逻辑是通过贪心策略，使得每次移除神器时，反噬值最小。具体来说，对于每对神器之间的关联值，选择其中法力值较小的神器进行关联值的乘法计算，从而保证最终的反噬值总和最小。所有题解都采用了这一思路，并通过邻接矩阵的输入方式，避免重复计算。

### 所选高星题解
#### 1. 作者：beargeng是女孩子 (5星)
- **关键亮点**：代码简洁，思路清晰，直接通过邻接矩阵的输入方式避免了重复计算，且没有使用额外的优化技巧，代码可读性高。
- **核心代码**：
  ```cpp
  for(long long i=1;i<=n;i++) {
      for(long long j=1;j<=n;j++) {
          cin>>tmp;
          if(i>j)
              ans+=tmp*min(a[i],a[j]);
      }
  }
  ```

#### 2. 作者：Last_hope (4星)
- **关键亮点**：代码中使用了`ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);`来加速输入输出，适合处理大规模数据。
- **核心代码**：
  ```cpp
  ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  for(int i=1;i<=n;i++) {
      for(int j=1;j<=n;j++) {
          cin>>v;
          if(i>j)
              ans+=v*min(a[i],a[j]);
      }
  }
  ```

#### 3. 作者：盖矣斌峥 (4星)
- **关键亮点**：代码结构清晰，使用了`long long`类型防止溢出，且通过`if(i>j)`避免了重复计算。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++) {
      for(int j=1;j<=n;j++) {
          int x;
          scanf("%d",&x);
          if(i>j)
              ans+=(LL)x*min(a[i],a[j]);
      }
  }
  ```

### 最优关键思路或技巧
- **贪心策略**：对于每对神器之间的关联值，选择法力值较小的神器进行乘法计算，保证反噬值最小。
- **邻接矩阵处理**：通过`if(i>j)`避免重复计算，确保每个关联值只被计算一次。

### 可拓展之处
- **类似问题**：可以拓展到其他需要贪心策略的问题，如任务调度、资源分配等。
- **算法套路**：贪心算法在处理最优化问题时，通常需要找到局部最优解，进而得到全局最优解。

### 推荐题目
1. P1090 合并果子
2. P1223 排队接水
3. P1803 凌乱的yyy / 线段覆盖

### 个人心得摘录
- **beargeng是女孩子**：直接读入TMP之后乘，不说太多了。
- **Last_hope**：本想用搜索的来着，结果提交后全超时了，只好换了个做法。
- **盖矣斌峥**：注意不要把每个关联值累加两次。

---
处理用时：24.92秒
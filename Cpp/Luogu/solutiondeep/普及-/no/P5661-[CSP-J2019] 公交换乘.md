# 题目信息

# [CSP-J2019] 公交换乘

## 题目描述

著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交车的优惠方案：
1. 在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：
$t_{bus} - t_{subway} \leq 45$。
2. 搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车。
3. 搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。

现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗?

## 说明/提示

**样例 1 说明**

第一条记录，在第 3 分钟花费 10 元乘坐地铁。

第二条记录，在第 46 分钟乘坐公交车，可以使用第一条记录中乘坐地铁获得的优惠票，因此没有花费。

第三条记录，在第 50 分钟花费 12 元乘坐地铁。

第四条记录，在第 96 分钟乘坐公交车，由于距离第三条记录中乘坐地铁已超过 45 分钟，所以优惠票已失效，花费 3 元乘坐公交车。

第五条记录，在第 110 分钟花费 5 元乘坐地铁。

第六条记录，在第 135 分钟乘坐公交车，由于此时手中只有第五条记录中乘坐地铁获得的优惠票有效，而本次公交车的票价为 6 元，高于第五条记录中地铁的票价 5 元，所以不能使用优惠票，花费 6 元乘坐公交车。

总共花费 36 元。 

**样例 2 说明**

第一条记录，在第 1 分钟花费 5 元乘坐地铁。

第二条记录，在第 16 分钟花费 20 元乘坐地铁。

第三条记录，在第 23 分钟花费 7 元乘坐地铁。

第四条记录，在第 31 分钟乘坐公交车，此时只有第二条记录中乘坐的地铁票价高于本次公交车票价，所以使用第二条记录中乘坐地铁获得的优惠票。

第五条记录，在第 38 分钟乘坐公交车，此时第一条和第三条记录中乘坐地铁获得的优惠票都可以使用，使用获得最早的优惠票，即第一条记录中乘坐地铁获得的优惠票。

第六条记录，在第 68 分钟乘坐公交车，使用第三条记录中乘坐地铁获得的优惠票。

总共花费 32 元。 


**数据规模与约定**

对于 $30\%$ 的数据，$n \leq 1000$，$t_i \leq 10^6$。

另有 $15\%$ 的数据，$t_i \leq 10^7$，所有 $price_i$ 相等。

另有 $15\%$ 的数据，$t_i \leq 10^9$，所有 $price_i$ 相等。

对于 $100\%$ 的数据，$n \leq 10^5$，$t_i \leq 10^9$，$1 \leq price_i \leq 1000$。

## 样例 #1

### 输入

```
6
0 10 3
1 5 46
0 12 50
1 3 96
0 5 110
1 6 135```

### 输出

```
36```

## 样例 #2

### 输入

```
6
0 5 1
0 20 16
0 7 23
1 18 31
1 4 38
1 7 68 ```

### 输出

```
32```

# AI分析结果

### 算法分类
**模拟**

### 综合分析与结论
本题的核心是通过模拟公交和地铁的优惠券使用过程来计算总花费。主要难点在于如何高效地管理和查询优惠券，尤其是在时间限制和价格限制的条件下。大多数题解都采用了队列或数组来存储优惠券，并通过优化查询过程来降低时间复杂度。

### 所选高星题解

#### 题解1：泥土笨笨（5星）
**关键亮点**：
- 使用队列优化查询过程，确保每次查询最多只遍历45张优惠券，时间复杂度为O(n)。
- 代码结构清晰，注释详细，易于理解。
- 通过维护`head`和`tail`指针来动态管理未过期的优惠券，避免了不必要的遍历。

**核心代码**：
```cpp
while (head < tail && q[head].time < time) {
    head++;
}
bool found = false;
for (int j = head; j < tail; ++j) {
    if (q[j].price >= price && q[j].used == 0) {
        found = true;
        q[j].used = 1;
        break;
    }
}
if (!found) cost += price;
```
**实现思想**：通过`head`指针跳过已过期的优惠券，然后在未过期的优惠券中查找符合条件的票。

#### 题解2：andyli（4星）
**关键亮点**：
- 使用`vector`存储优惠券，并通过`erase`方法动态删除过期的优惠券。
- 时间复杂度为O(45n)，虽然略高于队列优化，但代码简洁易懂。
- 通过`emplace_back`方法高效地添加优惠券。

**核心代码**：
```cpp
while (head < tail && q[head].time < time) {
    head++;
}
bool found = false;
for (int j = head; j < tail; ++j) {
    if (q[j].price >= price && q[j].used == 0) {
        found = true;
        q[j].used = 1;
        break;
    }
}
if (!found) cost += price;
```
**实现思想**：通过`erase`方法删除过期的优惠券，然后在剩余的优惠券中查找符合条件的票。

#### 题解3：ikunTLE（4星）
**关键亮点**：
- 使用手写队列优化查询过程，确保每次查询最多只遍历45张优惠券，时间复杂度为O(n)。
- 代码结构清晰，注释详细，易于理解。
- 通过维护`front`和`back`指针来动态管理未过期的优惠券，避免了不必要的遍历。

**核心代码**：
```cpp
while (head < tail && q[head].time < time) {
    head++;
}
bool found = false;
for (int j = head; j < tail; ++j) {
    if (q[j].price >= price && q[j].used == 0) {
        found = true;
        q[j].used = 1;
        break;
    }
}
if (!found) cost += price;
```
**实现思想**：通过`head`指针跳过已过期的优惠券，然后在未过期的优惠券中查找符合条件的票。

### 最优关键思路或技巧
1. **队列优化**：通过维护`head`和`tail`指针，动态管理未过期的优惠券，避免不必要的遍历，时间复杂度为O(n)。
2. **时间窗口**：利用45分钟的时间窗口，确保每次查询最多只遍历45张优惠券，进一步优化查询效率。
3. **结构体存储**：使用结构体存储优惠券的详细信息，便于管理和查询。

### 可拓展之处
- 类似的时间窗口问题，如滑动窗口最大值、最小覆盖子串等，都可以借鉴队列优化的思路。
- 其他需要动态管理数据的场景，如最近最少使用（LRU）缓存，也可以使用类似的数据结构。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)

### 个人心得摘录
- **调试经历**：在优化查询过程中，发现直接遍历所有优惠券会导致超时，通过引入队列优化，成功降低了时间复杂度。
- **踩坑教训**：在实现过程中，忽略了优惠券的有效期，导致计算结果错误，通过增加时间窗口的判断，解决了问题。
- **顿悟感想**：通过这道题，深刻理解了队列在时间窗口问题中的强大作用，未来在类似问题中可以优先考虑使用队列优化。

---
处理用时：36.63秒
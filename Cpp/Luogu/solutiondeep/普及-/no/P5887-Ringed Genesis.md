# 题目信息

# Ringed Genesis

## 题目背景

Enzyme runs through the Ringed Genesis，just like Rabbit runs through a Ring. 

## 题目描述

有一个长长的环，环由 $n$ 个格子首尾相接形成，依次编号 $0$ 至 $n-1$。

还有一种动物——兔子。兔子的步长为 $k$。若兔子当前在第 $i$ 个格子，那么下一秒它将跳到第 $(i+k)\bmod n$ 个格子。

现在有 $m$ 只兔子，第 $i$ 只兔子的初始格子为第 $p_i$ 个格子。随着时间的流逝，有些格子被兔子经过了，有些却一直没有被兔子经过。

你需要求出的是，有多少个格子永远不可能被兔子经过。

## 说明/提示

子任务 1（$10\%$）：$k=1$。

子任务 2（$20\%$）：$k|n$，也即 $\gcd(k,n)=k$。

子任务 3（$25\%$）：$1\leq n\leq 1000$，$1\leq m\leq 1000$。

子任务 4（$45\%$）：无特殊限制。

对于全部数据，$1 \leq n \leq 10^6$，$1 \leq m \leq 10^6$，$1 \leq k \leq n$。

## 样例 #1

### 输入

```
4 2 2
0 1
```

### 输出

```
0```

## 样例 #2

### 输入

```
4 2 2
0 2
```

### 输出

```
2```

# AI分析结果

### 算法分类
数学、模拟

### 综合分析与结论
本题的核心在于理解兔子跳跃的周期性，即跳跃步长 $k$ 与环长 $n$ 的最大公约数（GCD）决定了兔子能够访问的格子数。通过计算 GCD，可以将环分成若干个等价类，每个等价类中的格子要么全部被访问，要么全部不被访问。因此，问题的关键在于统计哪些等价类没有被任何兔子访问过。

### 所选题解
1. **作者：dingcx (赞：64)**
   - **星级：5星**
   - **关键亮点**：通过图形化示例直观地展示了跳跃的周期性，并巧妙地利用 GCD 将问题转化为等价类的统计。代码简洁高效，逻辑清晰。
   - **代码核心思想**：计算 $n$ 和 $k$ 的 GCD，标记每个等价类是否被访问，最后统计未被访问的等价类数量并乘以每个等价类的大小。
   ```cpp
   int gcd(int num1,int num2){
       if(num2==0) return num1;
       return gcd(num2,num1%num2);
   }
   int main(){
       int n,m,d,a,ans=0;
       scanf("%d%d%d",&n,&m,&d);
       int gc=gcd(n,d);
       for(int i=1;i<=m;i++){
           scanf("%d",&a);
           s[a%gc]=1;
       }
       for(int i=0;i<gc;i++)
           if(!s[i]) ans+=(n/gc);
       printf("%d",ans);
       return 0;
   }
   ```

2. **作者：低調 (赞：3)**
   - **星级：4星**
   - **关键亮点**：利用裴蜀定理将问题转化为等价类的统计，代码实现简洁，逻辑清晰。
   - **代码核心思想**：计算 $n$ 和 $k$ 的 GCD，标记每个等价类是否被访问，最后统计未被访问的等价类数量并乘以每个等价类的大小。
   ```cpp
   int main() {
       n=read(),m=read(),k=read();
       k=__gcd(k,n);
       if(k==1) {
           cout<<0;
           return 0;
       }
       for(int i=1; i<=m; i++) {
           p=read();
           a[p%k+1]++;
       }
       for(int i=1; i<=k; i++) {
           if(a[i]==0)tot++;
       }
       cout<<tot*n/k;
       return 0;
   }
   ```

3. **作者：李若谷 (赞：0)**
   - **星级：4星**
   - **关键亮点**：通过 GCD 将问题转化为等价类的统计，代码简洁，逻辑清晰。
   - **代码核心思想**：计算 $n$ 和 $k$ 的 GCD，标记每个等价类是否被访问，最后统计未被访问的等价类数量并乘以每个等价类的大小。
   ```cpp
   int gcd(int a,int b) {
       while(b){
           int t = b;
           b = a%b;
           a = t;
       }
       return a;
   }
   int main() {
       int n,m,k;
       n=read(),m=read(),k=read();
       int ans = 0;
       int z = gcd(k,n);
       for(int i=0;i<m;i++) {
           if(!f[p[i]%z])
               ans+=n/z;
           f[p[i]%z] = 1;
       }
       if(ans>n)
           ans = n;
       printf("%d\n",n-ans);
       return 0;
   }
   ```

### 最优关键思路或技巧
- **利用 GCD 分解等价类**：通过计算 $n$ 和 $k$ 的 GCD，将环分解为若干个等价类，每个等价类中的格子要么全部被访问，要么全部不被访问。
- **标记与统计**：通过标记每个等价类是否被访问，最后统计未被访问的等价类数量并乘以每个等价类的大小。

### 可拓展之处
- **类似问题**：类似的问题可以扩展到其他周期性跳跃或循环遍历的场景，如循环链表、环形数组等。
- **算法套路**：利用 GCD 分解等价类的思路可以应用于其他需要处理周期性或循环结构的问题。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)
3. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

### 个人心得
- **调试经历**：在实现过程中，需要注意 GCD 的计算和等价类的标记，确保每个等价类被正确处理。
- **踩坑教训**：在统计未被访问的等价类时，要注意边界条件，如 $k=1$ 时的特殊情况。
- **顿悟感想**：通过图形化示例和数学分析，能够更直观地理解问题的本质，从而简化代码实现。

---
处理用时：38.14秒
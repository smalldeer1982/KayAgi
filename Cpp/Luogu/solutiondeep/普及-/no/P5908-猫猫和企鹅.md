# 题目信息

# 猫猫和企鹅

## 题目描述

王国里有 $n$ 个居住区，它们之间有 $n-1$ 条道路相连，并且保证从每个居住区出发都可以到达任何一个居住区，并且每条道路的长度都为 $1$。

除 $1$ 号居住区外，每个居住区住着一个小企鹅，有一天一只猫猫从 $1$ 号居住区出发，想要去拜访一些小企鹅。可是猫猫非常的懒，它只愿意去距离它在 $d$ 以内的小企鹅们。

猫猫非常的懒，因此希望你告诉他，他可以拜访多少只小企鹅。

## 说明/提示

对于 $100\%$ 的数据，满足 $1 \le n ,d \le 10^5$，保证所有居民区从 $1$ 开始标号。

## 样例 #1

### 输入

```
5 1
1 2
1 3
2 4
3 5```

### 输出

```
2```

# AI分析结果

### 算法分类
深度优先搜索 DFS

### 综合分析与结论
题目要求从1号节点出发，统计距离不超过d的节点数。由于题目描述中的居住区和道路构成了一棵树，因此可以通过深度优先搜索（DFS）或广度优先搜索（BFS）来遍历树并计算符合条件的节点数。大多数题解采用了DFS，部分题解使用了BFS或最短路算法（如Dijkstra、SPFA）。DFS的实现较为简洁，且时间复杂度为O(n)，适合本题的数据范围。

### 所选高星题解
1. **作者：PersistentLife (5星)**
   - **关键亮点**：详细解释了图、树的基本概念，以及DFS和邻接表的使用。代码实现清晰，注释详细，适合初学者理解。
   - **核心代码**：
     ```cpp
     void dfs(int now, int dis) {
         vis[now] = 1;
         if (dis == d) return;
         for (int i = 0; i < g[now].size(); i++) {
             if (!vis[g[now][i]]) {
                 dfs(g[now][i], dis + 1);
                 ans++;
             }
         }
     }
     ```
   - **个人心得**：通过DFS遍历树，并在遍历过程中统计符合条件的节点数，代码简洁且易于理解。

2. **作者：Warriors_Cat (4星)**
   - **关键亮点**：使用链式前向星建图，并通过DFS计算每个节点的深度，最后统计深度不超过d的节点数。代码结构清晰，适合有一定基础的读者。
   - **核心代码**：
     ```cpp
     void dfs(int u) {
         for (int i = head[u]; i; i = e[i].nxt) {
             int v = e[i].v;
             if (vis[v]) continue;
             vis[v] = vis[u] + 1;
             dfs(v);
         }
     }
     ```
   - **个人心得**：通过DFS计算节点深度，最后通过简单的判断统计结果，思路清晰。

3. **作者：LinkZelda (4星)**
   - **关键亮点**：提出了前缀和的思想，通过DFS预处理深度信息，支持多次查询。虽然本题不需要多次查询，但思路具有拓展性。
   - **核心代码**：
     ```cpp
     void dfs(int now, int fath, int deep) {
         dep[deep] += 1;
         for (int i = 0; i < G[now].size(); i++) {
             int v = G[now][i];
             if (v != fath) dfs(v, now, deep + 1);
         }
     }
     ```
   - **个人心得**：通过DFS预处理深度信息，支持多次查询，思路具有拓展性。

### 最优关键思路或技巧
1. **DFS遍历树**：通过DFS遍历树，计算每个节点的深度，并统计深度不超过d的节点数。DFS的实现简洁且时间复杂度为O(n)，适合本题的数据范围。
2. **链式前向星建图**：使用链式前向星建图，适合处理较大规模的图结构，且代码结构清晰。
3. **前缀和预处理**：通过DFS预处理深度信息，支持多次查询，思路具有拓展性。

### 可拓展之处
1. **多次查询**：如果题目要求多次查询不同d值的结果，可以使用前缀和预处理深度信息，支持O(1)查询。
2. **最短路算法**：虽然DFS和BFS已经足够解决本题，但最短路算法（如Dijkstra、SPFA）也可以用于计算节点距离，适合更复杂的图结构。

### 推荐相似题目
1. [P5318 查找文献](https://www.luogu.com.cn/problem/P5318) - 广度优先搜索（BFS）的经典题目。
2. [P4779 单源最短路径](https://www.luogu.com.cn/problem/P4779) - 最短路算法的经典题目。
3. [P3379 最近公共祖先](https://www.luogu.com.cn/problem/P3379) - 树的遍历与LCA算法的经典题目。

---
处理用时：29.40秒
# 题目信息

# [EER1] 迫害

## 题目背景

"In Germany they first came for the Communists,　

and I didn't speak up because I wasn't a Communist.　　

Then they came for the Jews,　　

and I didn't speak up because I wasn't a Jew.　　

Then they came for the trade unionists,　　

and I didn't speak up because I wasn't a trade unionist.

Then they came for the Catholics,　　

and I didn't speak up because I was a Protestant.　　

Then they came for me ,

and by that time no one was left to speak up."

-- Pastor Martin Niemöller

”起初他们迫害共产党员，我没有说话，因为我不是马克思的信徒。

后来他们迫害犹太人，我没有说话，因为我是日耳曼人。

再后来他们迫害天主教徒，我没有说话，因为我是新教牧师。

最后他们迫害到我头上，我环顾四周，却再也没有人能为我说话。”

## 题目描述

有 $k$ 个人，X 要对这 $k$ 个人进行迫害。

这 $k$ 个人，每一个人都拥有一个数字，分别从 $1$ 至 $k$。

X 拥有 $n+m$ 个数字，这些数字为 $n$ 个 $1$ 和 $m$ 个大小可由 X 决定的数字（每个数字定好之后不能更换）。

X 能对这些人进行迫害，当且仅当他能用手中若干个数的加和等于被迫害人的数字，一次迫害就成功了（不会消耗数字）。

由于 X 的权利极大，又十分邪恶，他想要从第 $1$ 个人开始**一个一个**进行迫害行动。

由于小 Z 也在这个被迫害的行列里，他十分的慌张，希望你来告诉他 X 能最多能从第一个人开始连续迫害多少个人。

由于被迫害的人太多了，所以请将答案对 $1000000007$ 取模。

## 说明/提示

**【样例 1 解释】**

X 选取 $2$ 个数分别为 $2,4$，可知能连续迫害 $7$ 个人。

**【样例 2 解释】**

X 选取 $2$ 个数分别为 $3,6$，可知能连续迫害 $11$ 个人。

---

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（50 points）：$1 \le n \le 5$，$1 \le m \le 5$。
- Subtask 2（30 points）：保证答案在取模前在 $10^{18}$ 之内。
- Subtask 3（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10^6 $，$1 \le m \le 10^9 $。

## 样例 #1

### 输入

```
1 2```

### 输出

```
7```

## 样例 #2

### 输入

```
2 2```

### 输出

```
11```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
本题的核心是通过数学推导找到最大能连续迫害的人数，主要涉及等比数列的求和公式和快速幂的应用。大部分题解都通过推导得出公式 `ans = (n + 1) * 2^m - 1`，并使用快速幂来计算 `2^m`，以避免直接计算导致的时间复杂度过高或数值溢出问题。

### 所选高星题解
#### 1. 作者：CSP_Sept (赞：8)
- **星级**：5星
- **关键亮点**：详细推导了等比数列的求和公式，并解释了快速幂的原理和实现，代码简洁且高效。
- **个人心得**：作者通过多次优化代码，最终使用快速幂解决了TLE问题，展示了调试和优化的过程。

```cpp
#include <cstdio>
using namespace std;
typedef unsigned long long ULL;
#define MOD 1000000007
ULL qpow(ULL a, ULL b) {
    ULL ans = 1, base = a;
    while (b > 0) {
        if (b & 1) ans = ans * base % MOD;
        base = base * base % MOD;
        b >>= 1;
    }
    return ans % MOD;
}
int main() {
    ULL n, m;
    scanf("%lld%lld", &n, &m);
    printf("%lld\n", ((n + 1) * qpow(2, m) - 1) % MOD);
    return 0;
}
```

#### 2. 作者：Islauso (赞：6)
- **星级**：4星
- **关键亮点**：通过等比数列的求和公式推导出答案，并提供了详细的数学解释，代码实现简洁。
- **个人心得**：作者强调了快速幂的重要性，并提供了快速幂的实现代码。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define p 1000000007
using namespace std;
ll ksm(ll b, ll k) {
    ll ans = 1;
    while (k) {
        if (k & 1) ans = ans * b % p;
        b = b * b % p;
        k >>= 1;
    }
    return ans % p;
}
int main() {
    ll n, m;
    cin >> n >> m;
    printf("%lld\n", ksm(2, m) * (n + 1) % p - 1);
    return 0;
}
```

#### 3. 作者：Hexarhy (赞：3)
- **星级**：4星
- **关键亮点**：通过贪心策略推导出最优解，并提供了快速幂的实现，代码简洁且高效。
- **个人心得**：作者通过观察样例，逐步推导出最优解，展示了从样例中找规律的思维方式。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
const ll MOD = 1000000007;
ll fpow(ll b, ll p) {
    ll ans = 1;
    while (p) {
        if (p & 1) ans = ans * b % MOD;
        b = b * b % MOD;
        p >>= 1;
    }
    return ans;
}
int main() {
    ll n, m;
    cin >> n >> m;
    cout << (fpow(2, m) * (n + 1) % MOD - 1) % MOD << endl;
    return 0;
}
```

### 最优关键思路或技巧
1. **数学推导**：通过等比数列的求和公式推导出 `ans = (n + 1) * 2^m - 1`。
2. **快速幂**：使用快速幂计算 `2^m`，避免直接计算导致的时间复杂度过高或数值溢出问题。

### 可拓展之处
类似的问题可以通过数学推导和快速幂来解决，尤其是在需要计算大指数幂的情况下。可以进一步学习组合数学和数论中的相关知识，以应对更复杂的问题。

### 推荐题目
1. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)
2. [P1965 转圈游戏](https://www.luogu.com.cn/problem/P1965)
3. [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)

---
处理用时：35.20秒
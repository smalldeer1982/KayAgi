# 题目信息

# [USACO07OCT] Super Paintball G

## 题目描述

奶牛们最近从玩具商那里，买来了一套仿真版彩弹游戏设备（类似于真人 CS）。Bessie 把她们玩游戏的草坪划分成了 $N \times N$ 的矩阵（$1 \leq N \leq 100$），同时他算出了她的 $K$ 个对手在草地上的位置（$1 \leq K \leq 10^5$），现在你需要帮 Bessie 算些东西。

在这个游戏中，奶牛们用一把枪向八个方向中的任意一个方向射出子弹，这八个方向分别是：正北，正南，正东，正西，东北，东南，西北，西南（东北指北偏东 $45^\circ$，东南，西北，西南同理）。

Bessie 想要你算出，有多少个位置可以让她射到所有对手。特别地，Bessie 可以和她的某一个对手站在同一格子，这时候她可以射到和她同一格子的对手。

## 说明/提示

可选的位置有：$(2,1),(2,3),(3,2),(4,1),(4,3)$。

## 样例 #1

### 输入

```
4 3
2 1
2 3
4 1```

### 输出

```
5```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
本题的核心是通过模拟Bessie在八个方向上射击的过程，找到能够覆盖所有对手的位置。题解中主要采用了以下几种思路：
1. **暴力枚举**：直接枚举每个点，检查是否能够覆盖所有对手。这种方法虽然直观，但时间复杂度较高，通常需要优化。
2. **标记法**：通过记录每个对手所在的行、列和对角线，然后统计每个点能够覆盖的对手数量。这种方法通过预处理对手的位置，减少了重复计算，显著提升了效率。
3. **方向扩散**：从每个对手的位置向八个方向扩散，标记能够被射击到的位置，最后统计被标记次数等于K的位置。这种方法通过方向扩散减少了枚举的次数，进一步优化了时间复杂度。

### 所选高星题解
#### 1. 作者：do_while_false (5星)
**关键亮点**：
- 使用四个数组分别记录行、列和两条对角线的对手数量，通过简单的数学计算快速判断每个点是否能够覆盖所有对手。
- 代码简洁高效，时间复杂度为O(n^2 + k)，适合大规模数据处理。

**核心代码**：
```cpp
for(int i=1;i<=k;i++) {
    x=read();
    y=read();
    map1[x][y]++;
    row[x]++;col[y]++;lt[x-y+n]++;rt[x+y-1]++;
}
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
        if(row[i]+col[j]+lt[i-j+n]+rt[i+j-1]-3*map1[i][j]==k) 
            ans++;
```

#### 2. 作者：Mine_King (4星)
**关键亮点**：
- 通过记录每个对手所在的行、列和对角线，然后统计每个点能够覆盖的对手数量，避免了重复计算。
- 代码结构清晰，逻辑严谨，适合初学者理解。

**核心代码**：
```cpp
for(int i=1;i<=k;i++) {
    int x,y;
    scanf("%d%d",&x,&y);
    h[x]++,l[y]++;
    zx[x-y+100]++;
    yx[x+y]++;
    f[x][y]++;
}
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
        if(h[i]+l[j]+zx[i-j+100]+yx[i+j]-3*f[i][j]>=k) ans++;
```

#### 3. 作者：LiuHao2019 (4星)
**关键亮点**：
- 通过从每个对手的位置向八个方向扩散，标记能够被射击到的位置，最后统计被标记次数等于K的位置。
- 代码实现简单，易于理解，适合快速实现。

**核心代码**：
```cpp
for(int i = 1;i <= n;i ++)
    a[r][i]++;//行 
for(int i = 1;i <= n;i ++)
    if(i != r) a[i][c] ++;//列 
for(int i = 1;;i ++){//左上 
    if(r-i >= 1 && c-i >= 1) a[r-i][c-i] ++;
    else break;
}
for(int i = 1;;i ++){//右下 
    if(r+i <= n && c+i <= n) a[r+i][c+i] ++;
    else break;
}
```

### 最优关键思路
通过记录每个对手所在的行、列和对角线，然后统计每个点能够覆盖的对手数量，避免了重复计算，显著提升了效率。这种方法不仅适用于本题，还可以推广到类似的覆盖问题中。

### 可拓展之处
类似的问题可以通过预处理和方向扩散来优化时间复杂度，例如在棋盘覆盖、光线追踪等问题中，都可以采用类似的思路。

### 推荐题目
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

---
处理用时：27.31秒
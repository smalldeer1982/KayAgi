# 题目信息

# [CRCI2006-2007] BARD

## 题目描述

有一个小村子，村子里共有 $n$ 个人，不妨将这 $n$ 个人从 $1$ 至 $n$ 编号，编号为 $1$ 的人是诗人。

每天晚上都会有一些村民围在篝火旁唱歌。

如果某天晚上诗人来了，那么诗人会编一首所有人都没有听过的新歌曲并教给大家唱。在这天晚上**不会唱其他任何歌曲**。

如果某天晚上诗人没来，那么与会者就会唱他们之中**至少有一个人**会唱的**所有歌曲**，并把这些歌曲教给那些来了但不会唱的人。

给定 $m$ 天晚上参与唱歌的村民的编号，初始时村民们什么都不会唱，诗人一首歌也没有写。请输出最终有多少村民会唱诗人写的所有歌。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $ 1 \leq n \leq 100$，$1 \leq m \leq 50$。
- $2 \leq k_i \leq n$，$1 \leq a_{i, j} \leq n$。$1$ 在 $a_{i, j}$ 中至少出现了一次。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [Regional Competition](https://hsin.hr/coci/archive/2006_2007/regional_tasks.pdf) *T1 BARD***，翻译来自 @[一扶苏一](https://www.luogu.com.cn/user/65363)。



## 样例 #1

### 输入

```
4
3
2 1 2
3 2 3 4
3 4 2 1
```

### 输出

```
1
2
4```

## 样例 #2

### 输入

```
8
5
4 1 3 5 4
2 5 6
3 6 7 8
2 6 2
4 2 6 8 1
```

### 输出

```
1
2
6
8```

## 样例 #3

### 输入

```
5
3
2 1 3
2 2 1
4 2 1 4 5
```

### 输出

```
1```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
该题目主要考察模拟能力，通过模拟每天晚上的唱歌过程，最终统计会唱所有歌曲的村民。各题解基本都采用了二维数组来记录每个人会唱的歌曲，并根据诗人是否在场进行不同的处理。题解之间的主要区别在于代码的简洁性和优化程度。

### 所选题解
1. **作者：Utilokasteinn (赞：9)**  
   - **星级：5星**  
   - **关键亮点**：代码简洁，逻辑清晰，使用二维数组记录每个人会唱的歌曲，处理诗人是否在场的逻辑明确，且代码注释详细，易于理解。  
   - **核心实现思想**：使用二维数组`song[i][j]`记录第i个人是否会唱第j首歌，根据诗人是否在场进行不同的处理，最后统计会唱所有歌曲的村民。  
   ```cpp
   if(o) {
       ++s;
       for(int j=1;j<=k;j++)
           song[come[j]][s]=1;
   } else {
       for(int j=1;j<=k;j++)
           for(int u=1;u<=s;u++)
               if(song[come[j]][u]) v[u]=1;
       for(int j=1;j<=k;j++)
           for(int u=1;u<=s;u++)
               if(v[u]) song[come[j]][u]=1;
   }
   ```

2. **作者：InformationEntropy (赞：2)**  
   - **星级：4星**  
   - **关键亮点**：使用位运算优化集合操作，将每首歌的会唱情况压缩到一个二进制数中，提高了代码的效率，适合对位运算有一定了解的读者。  
   - **核心实现思想**：使用二进制数表示每首歌的会唱情况，通过位运算进行集合的交集操作，最后统计会唱所有歌曲的村民。  
   ```cpp
   if(isi) {
       cnt++;
       for(int j=1;j<=k;j++)
           a[cnt][t[j]/30]+=1<<(t[j]%30);
   } else {
       memset(v, 0, sizeof(v));
       for(int j=1;j<=k;j++)
           for(int u=1;u<=cnt;u++)
               if((a[u][t[j]/30]>>(t[j]%30))&1) v[u]=1;
       for(int u=1;u<=cnt;u++)
           if(v[u])
               for(int j=1;j<=k;j++)
                   a[u][t[j]/30]+=1<<(t[j]%30);
   }
   ```

3. **作者：冰糖鸽子 (赞：1)**  
   - **星级：4星**  
   - **关键亮点**：代码结构清晰，注释详细，适合初学者理解，处理逻辑明确，且代码可读性高。  
   - **核心实现思想**：使用二维数组`siso[i][j]`记录第j个人是否会唱第i首歌，根据诗人是否在场进行不同的处理，最后统计会唱所有歌曲的村民。  
   ```cpp
   if(isi) {
       cnt++;
       for(int j=1;j<=n;j++)
           siso[cnt][pp[j]]=1;
   } else {
       int ps[104];
       for(int j=1;j<=n;j++)
           for(int k=1;k<=cnt;k++)
               if(siso[k][pp[j]]) ps[k]=1;
       for(int j=1;j<=n;j++)
           for(int k=1;k<=cnt;k++)
               if(ps[k]) siso[k][pp[j]]=1;
   }
   ```

### 最优关键思路或技巧
- **二维数组记录状态**：使用二维数组记录每个人会唱的歌曲，处理逻辑清晰，易于实现。
- **位运算优化**：通过位运算压缩集合操作，提高代码效率，适合对位运算有一定了解的读者。

### 可拓展之处
- **集合操作优化**：可以进一步使用STL中的`bitset`进行集合操作，简化代码并提高效率。
- **并行处理**：对于更大规模的数据，可以考虑并行处理每天的唱歌过程，提高计算效率。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003) - 模拟题，考察二维数组的使用。
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047) - 模拟题，考察区间处理。
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056) - 模拟题，考察贪心与排序。

### 个人心得摘录
- **Utilokasteinn**：题目看了半个小时，代码注释详细，适合初学者理解。
- **InformationEntropy**：位运算的优先级小于正常的加减乘除，如果不知道优先级的话请加上括号，否则就爆零两行泪了。

---
处理用时：38.20秒
# 题目信息

# [NOI Online #3 入门组] 观星

## 题目背景

脚造数据一组，欢迎hack

## 题目描述

Jimmy 和 Symbol 约好一起看星星，浩瀚的星空可视为一个长为 $N$、宽为 $M$ 的矩阵，矩阵中共有 $N\times M$ 个位置，一个位置可以用坐标 $(i,j)$（$1\le i\le N$，$1\le j\le M$）来表示。每个位置上可能是空的，也可能有一个星星。

对于一个位置 $(i,j)$，与其相邻的位置有左边、左上、上面、右上、右边、右下、下面、左下 8 个位置。相邻位置上的星星被视为同一个星座，这种关系有传递性，例如若 $(1,1),(1,2),(1,3)$ 三个
位置上都有星星，那么这三个星星视为同一个星座。包含的星星数量相同的星座被视为一个星系（一个星系中的星座不一定相邻），星系的大小为星系中包含的所有星星数量。

由于 Symbol 太喜欢星系了，他就想考一考 Jimmy，让 Jimmy 求出星空中有多少个星系，他还想知道，最大的星系有多大。

## 说明/提示

对于 $20\%$ 的数据，$N,M\le 20$，最大星系大小不超过 200。

对于 $50\%$ 的数据，$N,M\le 400$。

对于 $70\%$ 的数据，$N,M\le 1100$。

对于 $100\%$ 的数据，$2\le N,M\le 1500$，最大星系大小不超过 100000。

## 样例 #1

### 输入

```
5 7
*......
..**..*
.*...*.
...*...
....*..```

### 输出

```
3 4```

## 样例 #2

### 输入

```
10 10
**..**.**.
***....*..
*...**.**.
...*..*...
..........
**...**.*.
..*.*....*
..........
***..*.*..
.***..*...```

### 输出

```
4 12```

# AI分析结果

### 算法分类
**搜索**（深度优先搜索 DFS、广度优先搜索 BFS）

### 综合分析与结论
本题的核心是通过搜索（DFS或BFS）来找到所有星座，并统计每个星座的星星数量。然后根据星座的星星数量进行分类，统计星系的数量和最大星系的大小。难点在于如何高效地遍历矩阵并标记已访问的星星，以及如何统计星系的大小。

### 所选高星题解
1. **作者：zhangjingzhuo (赞：65)**  
   **星级：5星**  
   **关键亮点：**  
   - 使用DFS进行星座的搜索，代码简洁且高效。
   - 通过`galaxy`数组统计每个星座的星星数量，并计算星系的大小。
   - 代码结构清晰，注释详细，易于理解。
   **核心代码：**
   ```cpp
   void Search(int x,int y){
       sum++;
       star[x][y]=false;
       for(int i=0;i<8;i++){
           int xx=x+dx[i],yy=y+dy[i];
           if(xx>=1&&xx<=n&&yy>=1&&yy<=m&&star[xx][yy])
               Search(xx,yy);
       }
   }
   ```

2. **作者：PersistentLife (赞：16)**  
   **星级：4星**  
   **关键亮点：**  
   - 使用BFS进行星座的搜索，通过队列实现，适合大规模数据。
   - 通过`h`数组统计每个星座的星星数量，并实时更新最大星系的大小。
   - 代码逻辑清晰，注释详细，适合初学者学习。
   **核心代码：**
   ```cpp
   void bfs(int fx,int fy){
       node no;
       no.x=fx;no.y=fy;
       q.push(no);
       int res=1;
       g[no.x][no.y]='.';
       while(!q.empty()){
           node fr=q.front();
           for(int i=0;i<=7;i++){
               if(g[fr.x+dx[i]][fr.y+dy[i]]=='*'){
                   no.x=fr.x+dx[i];no.y=fr.y+dy[i];
                   q.push(no);
                   g[fr.x+dx[i]][fr.y+dy[i]]='.';
                   res++;
               }
           }
           q.pop();
       }
       if(h[res]==0) cntg++;
       h[res]++;
       maxx=max(maxx,h[res]*res);
       cnts+=res;
   }
   ```

3. **作者：XianChanting (赞：15)**  
   **星级：4星**  
   **关键亮点：**  
   - 使用DFS进行星座的搜索，代码简洁且高效。
   - 通过`xz`数组统计每个星座的星星数量，并使用`sort`排序找到最大星系。
   - 代码结构清晰，注释详细，易于理解。
   **核心代码：**
   ```cpp
   int dfs(int x,int y){
       int sum=0;
       a[x][y]='.';
       int dx,dy;
       for(int i=-1;i<=1;i++){
           for(int j=-1;j<=1;j++){
               dx=x+i;
               dy=y+j;
               if(dx>=0&&dx<n&&dy>=0&&dy<m&&a[dx][dy]=='*')
                   sum+=dfs(dx,dy);
           }
       }
       return 1+sum;
   }
   ```

### 最优关键思路与技巧
- **DFS/BFS搜索：** 使用DFS或BFS遍历矩阵，找到所有星座并统计星星数量。
- **桶统计：** 使用数组或`map`统计每个星座的星星数量，便于后续计算星系的大小。
- **实时更新最大值：** 在搜索过程中实时更新最大星系的大小，避免二次遍历。

### 拓展与举一反三
- **类似题目：**  
  1. [P1596 Lake Counting S](https://www.luogu.com.cn/problem/P1596) - 类似的水洼问题，使用DFS或BFS解决。
  2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - 使用BFS进行区域填充。
  3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443) - 使用BFS进行最短路径搜索。

### 个人心得摘录
- **调试经历：** 在DFS/BFS中，标记已访问的点非常重要，否则会导致重复计算。
- **踩坑教训：** 在统计星系大小时，要注意实时更新最大值，避免遗漏。
- **顿悟感想：** 使用桶统计星座的星星数量，可以大大简化后续的计算过程。

---
处理用时：33.14秒
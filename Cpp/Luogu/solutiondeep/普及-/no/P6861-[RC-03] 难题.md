# 题目信息

# [RC-03] 难题

## 题目描述

求两个整数 $a,b$ $(1\le a,b\le n)$，使 $(a\ \mathrm{or}\ b)+(a\ \mathrm{xor}\ b)$ 最大。只需输出这个最大值。

## 说明/提示

样例说明：$(5\ \mathrm{or}\ 2)+(5\ \mathrm{xor}\ 2)=14$。

对于 $80\%$ 的数据，$n\le 1000$。

对于 $100\%$ 的数据，$2\le n\le 10^{18}$。

## 样例 #1

### 输入

```
5```

### 输出

```
14```

# AI分析结果

### 算法分类
位运算

### 综合分析与结论
该题的核心是通过位运算找到两个数 $a$ 和 $b$，使得 $(a\ \mathrm{or}\ b)+(a\ \mathrm{xor}\ b)$ 最大。大多数题解通过找规律或数学推导，发现最大值与 $n$ 的二进制位数有关，最终答案是将 $n$ 的二进制位全部置为1后乘以2。题解的主要思路是通过位运算或数学公式快速计算出结果，避免了暴力枚举的低效。

### 所选高分题解

#### 1. 题解作者：WarningQAQ (赞：14)
- **星级**：5星
- **关键亮点**：通过位运算直接找到与 $n$ 异或和或的值相等的数，最终答案是将 $n$ 的二进制位全部置为1后乘以2。代码简洁高效，思路清晰。
- **个人心得**：作者通过分析样例发现规律，最终通过位运算快速得出结果。

```cpp
ull n, k, ans;
int main() {
    scanf("%llu", &n);
    k = n;
    while (k) {
        k >>= 1;
        ans = ans << 1 | 1;
    }
    printf("%llu", ans << 1);
}
```

#### 2. 题解作者：Eason_AC (赞：4)
- **星级**：4星
- **关键亮点**：通过打表找规律，发现当 $2^i \leq n \leq 2^{i+1}-1$ 时，答案为 $2^{i+2}-2$。代码通过数学公式快速计算，避免了复杂的位运算。
- **个人心得**：作者通过打表发现规律，最终通过数学公式快速得出结果。

```cpp
long long n;
int main() {
    scanf("%lld", &n);
    for(int i = 1; ; ++i)
        if(n < (long long)pow(2, i)) {
            printf("%lld", (long long)pow(2, i + 1) - 2);
            break;
        }
    return 0;
}
```

#### 3. 题解作者：yf最qhhh (赞：1)
- **星级**：4星
- **关键亮点**：通过位运算直接找到与 $n$ 异或和或的值相等的数，最终答案是将 $n$ 的二进制位全部置为1后乘以2。代码简洁高效，思路清晰。
- **个人心得**：作者通过位运算快速得出结果，代码简洁明了。

```cpp
unsigned long long n,ans;
int main() {
    cin>>n;
    while(n>0)ans=ans<<1|1,n>>=1;
    cout<<(ans<<1);
    return 0;
}
```

### 最优关键思路
通过位运算或数学公式快速计算出与 $n$ 异或和或的值相等的数，最终答案是将 $n$ 的二进制位全部置为1后乘以2。这种方法避免了暴力枚举的低效，时间复杂度为 $O(\log n)$。

### 拓展思路
类似的问题可以通过位运算或数学推导快速解决，避免暴力枚举。例如，求最大异或值、最小或值等问题都可以通过类似的方法优化。

### 推荐题目
1. [P3865 【模板】ST表](https://www.luogu.com.cn/problem/P3865)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)

---
处理用时：27.83秒
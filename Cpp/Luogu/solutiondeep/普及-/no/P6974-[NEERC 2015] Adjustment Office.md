# 题目信息

# [NEERC 2015] Adjustment Office

## 题目描述

가리송과 안드레송은 정산소에서 일하고 있고, 미래를 예측하고자 한다. 둘에게는 큰 $n,x,n$ 정사각형이 주어진다。처음에 각 배열의 원소 $(x,y)$ 는 $x + y$ 로 채워져있다. $(1 \le x , y \le n)$.

미래 예측을 하는데에 두가지 타입의 쿼리가 들어온다.

- `R r` —$r$ 행의 모든 값들을 합한 결과를 출력하고, $r$ 행을 모두 $0$ 으로 바꾼다.
- `C c`—$c$ 열의 모든 값들을 합한 결과를 출력하고, $c$ 열을 모두 $0$ 으로 바꾼다.

쿼리 결과를 구하는 프로그램을 작성하시오.



## 说明/提示

Time limit: 1 s, Memory limit: 256 MB. 



## 样例 #1

### 输入

```
3 7
R 2
C 3
R 2
R 1
C 2
C 1
R 3
```

### 输出

```
12
10
0
5
5
4
0
```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
该题目要求处理一个矩阵，并支持对行或列的查询和删除操作。由于矩阵的大小可能达到10^6，直接模拟操作会导致时间或空间超限。因此，所有题解都采用了数学推导来优化计算，通过记录已删除的行和列的信息，快速计算当前行或列的和。

### 所选题解

#### 题解1：作者：lrx___ (赞：5)
**星级：5星**
**关键亮点：**
- 使用数学公式推导行和列的和，避免了直接模拟。
- 通过记录已删除的行和列的数量及其编号之和，快速计算当前行或列的和。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
if(c=='R'){
    if(vr[m]){
        cout<<"0\n";
    }else{
        cout<<sc+m*cc<<'\n';
        sr-=m;cr--;vr[m]=1;
    }
}else{
    if(vc[m]){
        cout<<"0\n";
    }else{
        cout<<sr+m*cr<<'\n';
        sc-=m;cc--;vc[m]=1;
    }
}
```
**实现思想：**
通过记录已删除的行和列的数量及其编号之和，利用公式快速计算当前行或列的和。

#### 题解2：作者：L_sdcs (赞：5)
**星级：5星**
**关键亮点：**
- 使用数学公式推导行和列的和，避免了直接模拟。
- 通过记录已删除的行和列的数量及其编号之和，快速计算当前行或列的和。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
if(c=='R'){
    if(br[x])cout<<0<<endl;
    else{
        cout<<(1+n)*n/2-l+x*(n-ls)<<endl;
        rs++;r+=x;br[x]=1;
    }
}else{
    if(bl[x])cout<<0<<endl;
    else{
        cout<<(1+n)*n/2-r+x*(n-rs)<<endl;
        ls++;l+=x;bl[x]=1;
    }
}
```
**实现思想：**
通过记录已删除的行和列的数量及其编号之和，利用公式快速计算当前行或列的和。

#### 题解3：作者：5k_sync_closer (赞：3)
**星级：4星**
**关键亮点：**
- 使用数学公式推导行和列的和，避免了直接模拟。
- 通过记录已删除的行和列的数量及其编号之和，快速计算当前行或列的和。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
if(c=='R'){
    if(fr[m]) {cout << 0 << endl;break;}
    fr[m] = 1;++y;q += m;cout << n * (n + 1) / 2 + n * m - (x * m + p) << endl;break;
}else if(c=='C'){
    if(fc[m]) {cout << 0 << endl;break;}
    fc[m] = 1;++x;p += m;cout << n * (n + 1) / 2 + n * m - (y * m + q) << endl;break;
}
```
**实现思想：**
通过记录已删除的行和列的数量及其编号之和，利用公式快速计算当前行或列的和。

### 最优关键思路或技巧
- **数学推导**：通过数学公式推导行和列的和，避免了直接模拟操作，大大提高了计算效率。
- **记录删除信息**：通过记录已删除的行和列的数量及其编号之和，快速计算当前行或列的和。

### 可拓展之处
- **类似问题**：在处理大规模矩阵问题时，可以考虑使用数学推导来优化计算，避免直接模拟操作。
- **数据结构**：在某些情况下，可以使用树状数组或线段树来维护行和列的和，进一步优化查询和更新操作。

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3368 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3368)
3. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)

### 个人心得总结
- **调试经历**：在处理大规模数据时，直接模拟操作往往会导致时间或空间超限，因此需要寻找更高效的算法或数学推导来优化计算。
- **踩坑教训**：在处理矩阵问题时，要注意数据类型的范围，避免溢出。
- **顿悟感想**：通过数学推导，可以将复杂的问题简化为简单的公式计算，大大提高了解题效率。

---
处理用时：33.96秒
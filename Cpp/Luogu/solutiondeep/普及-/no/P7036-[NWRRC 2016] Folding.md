# 题目信息

# [NWRRC 2016] Folding

## 题目描述

### 题目大意：

求一个 $W\times H $ 的矩形通过折叠变为一个 $w\times h$ 的矩形的最少折叠次数，其中每次折叠的折痕必须平行于矩形的一边。

------------

## 样例 #1

### 输入

```
2 7
2 2
```

### 输出

```
2
```

## 样例 #2

### 输入

```
10 6
4 8
```

### 输出

```
2
```

## 样例 #3

### 输入

```
5 5
1 6
```

### 输出

```
-1
```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
本题的核心是通过模拟折叠过程，计算将一个矩形折叠成目标矩形所需的最少次数。所有题解都采用了类似的思路：首先判断是否可以通过折叠达到目标矩形，然后通过不断将目标矩形的边长乘以2，直到达到或超过原始矩形的边长，统计操作次数。题解之间的主要区别在于实现细节和代码风格。

### 所选高分题解
1. **作者：Linge_Zzzz (5星)**
   - **关键亮点**：思路清晰，代码简洁，通过逆向思维（从目标矩形展开到原始矩形）简化了问题。特别强调了在任何时刻保持长边和短边的顺序，避免逻辑错误。
   - **代码核心思想**：
     ```cpp
     while(w<W||h<H) {
         if(h<H) h*=2;
         else w*=2;
         if(w<h) swap(w,h);
         ans++;
     }
     ```
   - **个人心得**：强调了在模拟过程中保持长边和短边的顺序，避免逻辑错误。

2. **作者：Doubeecat (4星)**
   - **关键亮点**：通过函数封装了计算次数的逻辑，代码结构清晰，易于理解。特别提到了两种折叠情况（将W变成w，H变成h，或者将W变成h，H变成w），并选择了最小次数。
   - **代码核心思想**：
     ```cpp
     int solve(int y,int x) {
         if (x == y) return 0;
         int cnt = 0;
         while (1) {
             x *= 2; ++cnt;
             if (x >= y) return cnt;
         }
     }
     ```
   - **个人心得**：提到了队友在比赛中的错误，强调了长边和短边的判断。

3. **作者：Scrutiny (4星)**
   - **关键亮点**：详细解释了折叠过程的逻辑，代码实现较为简洁，通过互换W和H进行两次计算，取最小次数。
   - **代码核心思想**：
     ```cpp
     while(a>w) { a/=2; ++cnt1; }
     while(b>h) { b/=2; ++cnt2; }
     swap(w,h);
     while(W>w) { W/=2; ++cnt3; }
     while(H>h) { H/=2; ++cnt4; }
     cout<<min(cnt1+cnt2,cnt3+cnt4);
     ```
   - **个人心得**：提醒了使用浮点类型以避免整数除法的问题。

### 最优关键思路或技巧
1. **逆向思维**：从目标矩形展开到原始矩形，简化了问题的处理。
2. **保持长边和短边的顺序**：在模拟过程中始终确保长边和短边的顺序，避免逻辑错误。
3. **函数封装**：将计算次数的逻辑封装成函数，提高代码的可读性和复用性。

### 可拓展之处
类似的问题可以通过逆向思维和模拟过程来解决，例如计算将一个数通过某种操作变为另一个数的最少次数。此外，保持变量的顺序和逻辑一致性也是解决类似问题的关键。

### 推荐题目
1. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
3. [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)

---
处理用时：24.59秒
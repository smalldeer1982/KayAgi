# 题目信息

# StickSuger

## 题目背景

YSGHYYDS

## 题目描述

YSGH 给你一个长度为 $n$ 的字符串 $S$。设 $S_x$ 表示字符串 $S$ 的第 $x$ 个字符。你可以选择一个二元组 $(i,j)$，然后交换 $S_i$ 和 $S_j$。二元组 $(i,j)$ 是合法的当且仅当 $1\leq i<j\leq n$ 并且交换后的字符串的字典序比原串大。

对于两个字符 $c_0,c_1$，称 $c_0>c_1$ 当且仅当 $c_0$ 的 ASCII 码大于 $c_1$ 的 ASCII 码。

对于两个长度为 $n$ 的字符串 $S,T$，$S$ 的字典序大于 $T$ 当且仅当存在一个 $i\in [0,n-1]$ 使得 $\forall j\in[1,i],S_j=T_j$， 并且 $S_{i+1}>T_{i+1}$。

如果存在多种合法方案，输出最大的二元组。

对于两个二元组 $(i_1,j_1)$，$(i_2,j_2)$，称  $(i_1,j_1)$ 小于 $(i_2,j_2)$ 当且仅当 $i_1<i_2\lor(i_1=i_2\land j_1<j_2)$。

如果不存在合法方案，则输出 `-1`。 

保证 $S$ 只包含小写英文字母。

## 说明/提示

**【样例解释 #1】**

如果选择二元组 $(2,3)$，交换 $S_2$ 和 $S_3$ 后的字符串为 `abc`，字典序比 `acb` 小，所以不合法。

如果选择二元组 $(1,3)$，交换 $S_1$ 和 $S_3$ 后的字符串为 `bca`，字典序比 `acb` 大，是合法的。

虽然 $(1,2)$ 也是合法的，但是没有 $(1,3)$ 大。所以答案是 $(1,3)$。 

**【样例解释 #2】**

容易看出任何一个二元组都不合法。

---

**【数据范围】**

**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$S$ 只包含小写英文字母。

- Subtask 1（4 points）：$S$ 只包含一种字符。
- Subtask 2（10 points）：$n\leq 100$。
- Subtask 3（16 points）：$n\leq 500$。
- Subtask 4（25 points）：$n\leq 5000$。
- Subtask 5（18 points）：$n\leq 10^5$。
- Subtask 6（27 points）：$n\leq 10^6$。


## 样例 #1

### 输入

```
3
acb```

### 输出

```
1 3```

## 样例 #2

### 输入

```
6
zyxwvu```

### 输出

```
-1```

## 样例 #3

### 输入

```
14
aabbccddccbbaa```

### 输出

```
6 8```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
该题的核心逻辑是通过贪心策略找到最大的合法二元组 $(i,j)$，使得交换 $S_i$ 和 $S_j$ 后字符串的字典序增大。大多数题解采用了从后向前遍历的策略，通过维护字符的最后出现位置或寻找极大点来优化时间复杂度。贪心算法的关键在于每次选择当前最优的局部解，从而逐步逼近全局最优解。

### 所选高星题解

#### 题解1：作者：TZMydl (赞：4)
**星级：4星**
**关键亮点：**
- 使用贪心策略，倒序遍历字符串，维护每个字符的最后出现位置。
- 通过查询字典序比当前字符大的字符的最大下标，快速找到合法二元组。
- 时间复杂度为 $O(26n)$，适合大规模数据。

**核心代码：**
```cpp
for(int i=n;i>=1;--i){
    int res=0;
    for(int j=s[i]-'a'+1;j<=26;++j)
        if(cnt[j])
            res=max(res,cnt[j]);
    if(res){
        printf("%d %d\n",i,res);
        return 0;
    }
    if(!cnt[s[i]-'a'])cnt[s[i]-'a']=i;
}
```

#### 题解2：作者：Maxmilite (赞：2)
**星级：4星**
**关键亮点：**
- 通过从后向前寻找极大点，确定最大的 $i$，再在极大点后寻找最大的 $j$。
- 使用二分查找优化查找过程，时间复杂度为 $O(n \log n)$。
- 代码简洁，思路清晰。

**核心代码：**
```cpp
for(int i=n-2;i>=0;i--) // 找到最大的 i 
if(s[i]<s[i+1])
{
    p=i;
    break;
}
if(p<0) cout<<p<<endl; // 无解 
else
{
    for(int i=n-1;i>=p;i--) // 找到最大的 j 
    if(s[i]>s[p])
    {
        cout<<p+1<<" "<<i+1<<endl;
        break;
    }
}
```

#### 题解3：作者：Eason_AC (赞：2)
**星级：4星**
**关键亮点：**
- 从后向前扫描，找到第一个 $i$ 使得 $S_i < S_{i+1}$，记录位置 $p$。
- 再从 $n$ 开始向后扫描，找到第一个 $i$ 使得 $S_i > S_p$，输出 $(i,p)$。
- 时间复杂度为 $O(n)$，代码简洁高效。

**核心代码：**
```cpp
R(int, i, n - 1, 1) if(s[i] < s[i + 1]) {fl = i; break;}
if(fl == -1) return printf("-1"), 0;
print_space(fl);
R(int, i, n, fl + 1) if(s[i] > s[fl]) return write(i), 0;
```

### 最优关键思路或技巧
- **贪心策略**：从后向前遍历字符串，确保每次选择的 $i$ 和 $j$ 是当前最优的局部解。
- **维护字符最后出现位置**：通过记录每个字符的最后出现位置，快速找到合法的 $j$。
- **二分查找优化**：在确定 $i$ 后，使用二分查找在极大点后快速找到最大的 $j$。

### 可拓展之处
- **类似问题**：可以扩展到其他需要找到最大或最小二元组的问题，如寻找最大差值、最大乘积等。
- **优化思路**：在类似问题中，可以考虑使用贪心策略结合二分查找或维护某些数据结构（如堆、哈希表）来优化时间复杂度。

### 推荐题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)

---
处理用时：33.43秒
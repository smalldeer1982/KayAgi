# 题目信息

# 远古档案馆（Ancient Archive）

## 题目背景

为了揭开月光能量背后的秘密，你来到了地下的远古档案馆。

远古一族的秘密与遗忘的知识悉数贮藏于这片被尘封的迷宫中，你能成功解谜，获知远古的知识吗？


## 题目描述

远古档案馆的中心是一个解谜：

- 有一个 $2\times 2$ 的网格，每个格子中要么有一个正整数，要么是空的；

- 你可以进行若干次操作：每次操作中，你选择一个**有正整数的格子**和一个**与之相邻的空格子**，将正整数移到那个空格子中；

- 给定网格的初始状态和最终状态，保证初始状态和最终状态中包含的正整数个数相同（设为 $k$ 个），且它们就是前 $k$ 个不同的正整数，问是否可以通过有限次操作从初始状态到达最终状态？

下图展示了一个包含三个正整数的网格经过两次操作的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/y2dnr4ss.png)

只有完成解谜，才能获得遗忘的知识，因此你希望尽快解决这个问题。

**注意：网格中可能没有正整数，也可能没有空格。**

## 说明/提示

**【样例 1 解释】**

如题目描述中图所示。

---

**【样例 2 解释】**

没有可移动的正整数，所以无法从初始状态到达与之不相等的最终状态。

---

**【数据范围】**

**本题采用捆绑测试。**

所有数据符合题目描述所述。

- Subtask 1（40 points）：不存在空格。
- Subtask 2（60 points）：无特殊限制。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/rz2eg0ca.png)

## 样例 #1

### 输入

```
2 1
3 0
0 2
3 1
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
2 1
4 3
3 4
2 1
```

### 输出

```
No
```

# AI分析结果

### 算法分类
搜索

### 综合分析与结论
该题目要求判断一个2x2网格的初始状态是否可以通过有限次移动操作到达最终状态。由于网格规模较小，且操作规则明确，大多数题解采用了搜索算法（如DFS、BFS）来枚举所有可能的移动路径。部分题解通过优化搜索策略或利用网格的特殊性质（如空格的移动规律）来减少搜索空间，提高效率。

### 所选高星题解
1. **作者：_caiji_ (赞：4)**
   - **星级：4星**
   - **关键亮点：使用BFS进行状态搜索，并通过哈希表去重，避免了重复搜索，提高了效率。**
   - **个人心得：通过将网格状态压缩为一个四位数，避免了使用`std::map`导致的MLE/TLE问题。**
   - **核心代码：**
     ```cpp
     bool bfs(){
         vis[begin]=1;
         q.push(begin);
         while(!q.empty()){
             node now=q.front();q.pop();
             if(now==end) return 1;
             for(int i=1;i<=n;i++){
                 for(int j=1;j<=n;j++){
                     if(now.a[i][j]==0){
                         for(int k=1;k<=4;k++){
                             int x=i+dx[k],y=j+dy[k];
                             if(1<=x&&x<=n&&1<=y&&y<=n&&now.a[x][y]!=0){
                                 node pus=now;
                                 swap(pus.a[i][j],pus.a[x][y]);
                                 if(!vis[pus]){
                                     vis[pus]=1;
                                     q.push(pus);
                                 }
                             }
                         }
                     }
                 }
             }
         }
         return 0;
     }
     ```

2. **作者：ZBAA_MKC (赞：7)**
   - **星级：4星**
   - **关键亮点：采用DFS进行搜索，并通过步数限制（1000步）避免死递归，保证了算法的终止性。**
   - **核心代码：**
     ```cpp
     void dfs(int x, int y, int step){
         bool f = true;
         for (int i = 0; i < 2; i++){
             for (int j = 0; j < 2; j++){
                 if (sta[i][j] != target[i][j]) f = false;
             }
         }
         if (step == 1000) { puts("No"); exit(0); }
         if (f) { puts("Yes"); exit(0); }
         for (int i = 0; i < 4; i++){
             if (x + dx[i] < 2 && x + dx[i] >= 0 && y + dy[i] < 2 && y + dy[i] >= 0 && !vis[x + dx[i]][y + dy[i]]){
                 swap(sta[x + dx[i]][y + dy[i]], sta[x][y]);
                 vis[x + dx[i]][y + dy[i]] = true;
                 dfs(x + dx[i], y + dy[i], step + 1);
                 vis[x + dx[i]][y + dy[i]] = false;
                 swap(sta[x + dx[i]][y + dy[i]], sta[x][y]);
                 step--;
             }
         }
     }
     ```

3. **作者：小杨小小杨 (赞：4)**
   - **星级：4星**
   - **关键亮点：通过分情况讨论（无空格、一个空格、多个空格）简化问题，并采用DFS进行搜索，代码结构清晰。**
   - **核心代码：**
     ```cpp
     void sc(int x,int y){
         if (pd()){flag=true;return;}
         if (flag) return;
         if (f[x][y]) return;
         f[x][y]=1;
         if (x==1&&y==1){
             c[1][1]=c[2][1];c[2][1]=0;sc(2,1);c[2][1]=c[1][1];c[1][1]=0;
             c[1][1]=c[1][2];c[1][2]=0;sc(1,2);c[1][2]=c[1][1];c[1][1]=0;
         }
         // 其他情况类似
     }
     ```

### 最优关键思路或技巧
1. **状态压缩与哈希去重**：将网格状态压缩为一个整数，便于存储和去重，避免重复搜索。
2. **步数限制**：在DFS中设置步数限制，避免无限递归，保证算法终止。
3. **分情况讨论**：根据空格的数量和位置，分情况讨论，简化问题复杂度。

### 可拓展之处
该题目的解法可以拓展到更大规模的网格或更复杂的移动规则，如3x3网格或允许对角线移动。类似的搜索算法也可以应用于其他状态转换问题，如拼图游戏、迷宫寻路等。

### 推荐相似题目
1. P1379 八数码问题
2. P2324 [SCOI2005]骑士精神
3. P1074 靶形数独

---
处理用时：40.38秒
# 题目信息

# 「PMOI-0」一笔画

## 题目背景

（原 LZOI-1，改名已经 PMOI 成员同意）

## 题目描述

言琢დ 在一个 $2n \times 2n$ 的矩阵中坐标为 $(x,y)$ 的一个点上。

现在 lhm 需要任意选择矩阵上的一个点作为起点，然后依次经过 $k$ 个点，移动规则如下：

- 每次移动只能选择与目前相邻（上下左右）的点作为本次移动的目标点。不能选择矩阵外的点。

- 每一轮移动必须正好经过矩阵上的所有点，不能重复经过同一个点。每经过所有点后，视为一轮移动结束。

- 注意依次经过 $k$ 个点后，最后一轮移动可能并没有完成。

现在 lhm 想知道，他最少会经过 言琢დ 多少次。

## 说明/提示

### 样例说明

![](https://cdn.luogu.com.cn/upload/image_hosting/37e99o4k.png)

$\color{red}დ$ 代表 言琢დ 所在位置，红色线表示 lhm 第一轮的路径。

### 数据规模与约定

**本题采用捆绑测试。**

| 子任务编号 | 分值 | $n,k\le$ |
| :----------: | :----------: | :----------: |
| $1$ | $30$ | $10^4$ |
| $2$ | $30$ | $10^9$ |
| $3$ | $40$ | $10^{18}$ |

对于所有数据，保证 $1\le n,k\le10^{18}$，$1\le x,y\le 2n$。

## 样例 #1

### 输入

```
2 16 1 1```

### 输出

```
1```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
题目要求在一个 $2n \times 2n$ 的矩阵中，经过 $k$ 个点，且每轮移动必须经过所有点，求最少经过目标点 $(x,y)$ 的次数。通过分析，可以得出每轮移动经过目标点的次数为 $\left\lfloor \frac{k}{(2n)^2} \right\rfloor$。这一结论基于以下关键点：
1. **矩阵的遍历性质**：在一个 $2n \times 2n$ 的矩阵中，存在一种遍历方式可以循环遍历所有点，且最终可以以任意点作为终点。
2. **最小化经过次数**：通过选择适当的起点和路径，可以确保在每轮移动中只经过目标点一次，从而最小化总经过次数。

### 所选高星题解
1. **作者：言琢დ (5星)**
   - **关键亮点**：详细证明了在 $2n \times 2n$ 的矩阵中存在一种遍历方式可以循环遍历所有点，并给出了具体的遍历路径示例。通过这一证明，确保了每轮移动经过目标点的次数为 $\left\lfloor \frac{k}{(2n)^2} \right\rfloor$。
   - **代码实现**：
     ```cpp
     signed main(){
         int n = init(), k = init();
         print(k / (n * n * 4));
     }
     ```
   - **个人心得**：作者提到大多数题解忽略了这一遍历性质的证明，强调了这一结论的重要性。

2. **作者：Ginger_he (4星)**
   - **关键亮点**：通过黑白染色的方法，证明了从任意点出发都能遍历整个矩阵，并最终以目标点作为终点。这一方法简洁明了，进一步验证了结论的正确性。
   - **代码实现**：
     ```cpp
     #include<bits/stdc++.h>
     using namespace std;
     long long n,k,x,y;
     int main()
     {
         scanf("%lld%lld%lld%lld",&n,&k,&x,&y);
         printf("%lld\n",k/4/n/n);
         return 0;
     }
     ```

3. **作者：Da_un (4星)**
   - **关键亮点**：通过举例和图示，直观地展示了如何选择起点和路径，以确保在每轮移动中只经过目标点一次。这一方法有助于理解结论的直观性。
   - **代码实现**：
     ```cpp
     #include<iostream>
     #include<cstdio>
     #include<algorithm>
     using namespace std;
     long long n,k,x,y;
     int main()
     {
         cin>>n>>k>>x>>y;
         cout<<k/(2*n*2*n);
         return 0;
     }
     ```

### 最优关键思路
1. **遍历性质**：在 $2n \times 2n$ 的矩阵中，存在一种遍历方式可以循环遍历所有点，且最终可以以任意点作为终点。
2. **最小化经过次数**：通过选择适当的起点和路径，确保在每轮移动中只经过目标点一次。

### 可拓展之处
- **类似题目**：可以扩展到其他类型的矩阵遍历问题，如 $n \times m$ 的矩阵，或者在不同移动规则下的遍历问题。
- **算法套路**：类似的数学推导和遍历性质证明可以应用于其他需要最小化或最大化某种指标的题目。

### 推荐题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1044 栈](https://www.luogu.com.cn/problem/P1044)

---
处理用时：30.85秒
# 题目信息

# Easy Strings Merging

## 题目描述

给定 $n$ 个 01 串，每次你可以从某个串开头移除一个字符并把它加入一个新串 $S$ 的末尾。最大化 $S$ 中相邻两个字符相同的对数。

## 说明/提示

### 样例解释

最优方案下，每次取的串的编号为 $1,1,2,1,2,3,1,2,3,2,3,3$，最终的 $S=000111111000$。

### 数据范围

**本题采用捆绑测试**

设 $s$ 表示输入的 01 串的长度之和。

| 子任务编号 | 分值 | 特殊限制 |
| :----------: | :----------: | :----------: |
| $0$ | $5$ | $n=1$ |
| $1$ | $20$ | $n\le 2$，$s\le 10$ |
| $2$ | $25$ | $n\le 5$，$s\le 30$ |
| $3$ | $25$ | $n\le 100$，$s\le 200$ |
| $4$ | $25$ | 无特殊限制 |

对于所有数据，保证 $1\le n\le s\le 10^6$。

## 样例 #1

### 输入

```
3
0011
0110
1100```

### 输出

```
9```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
该题的核心思路是通过贪心策略最大化相邻字符相同的对数。具体来说，每次尽可能多地取出相同字符，直到无法继续为止，然后切换到另一个字符。这种方法能够有效减少相邻字符不同的对数，从而最大化相同字符的对数。

大多数题解都采用了类似的贪心策略，但实现方式有所不同。一些题解通过模拟取字符的过程，而另一些则通过统计字符的连续段数来优化计算。总体而言，贪心策略是该题的最优解，且时间复杂度为O(s)，能够满足题目要求。

### 所选题解
1. **题解作者：HYdroKomide**
   - **星级：4**
   - **关键亮点**：通过统计每个字符串的相邻字符不同的次数，并分别考虑第一次取0和1的情况，最终取最小值作为结果。代码简洁且思路清晰。
   - **核心实现思想**：遍历每个字符串，统计相邻字符不同的次数，并分别记录第一次取0和1的情况，最后取最小值。
   - **代码片段**：
     ```cpp
     int main(){
         ios::sync_with_stdio(false);
         cin>>n;
         for(ri i=1;i<=n;i++){
             cin>>s;
             l=s.length(),cnt0=cnt1=0;
             tot+=l;
             if(s[0]=='0')cnt1++;
             if(s[0]=='1')cnt0++;
             for(ri j=1;j<l;j++)
                 if(s[j]!=s[j-1])
                     cnt0++,cnt1++;
             maxcnt0=cnt0>maxcnt0?cnt0:maxcnt0;
             maxcnt1=cnt1>maxcnt1?cnt1:maxcnt1;
         }
         maxcnt=min(maxcnt0,maxcnt1);
         tot--;
         cout<<tot-maxcnt<<endl;
         return 0;
     }
     ```

2. **题解作者：VinstaG173**
   - **星级：4**
   - **关键亮点**：通过贪心策略，每次取出所有串开头能取的同种字符，直到无法继续为止，然后切换到另一个字符。思路清晰且代码简洁。
   - **核心实现思想**：分别计算以0和1为第一段的段数，取最小值作为结果。
   - **代码片段**：
     ```cpp
     int main(){
         n=read();while(n--){
             char c=gc(),l0='0',l1='1';t0=t1=1;
             while(!isdigit(c))c=gc();while(isdigit(c)){
                 (c!=l0)&&(l0=c,++t0),(c!=l1)&&(l1=c,++t1),c=gc(),++ans;
             }(t0>tt0)&&(tt0=t0),(t1>tt1)&&(tt1=t1);
         }return 0&printf("%d\n",ans-((tt0<tt1)?tt0:tt1));
     }
     ```

3. **题解作者：MY（一名蒟蒻）**
   - **星级：4**
   - **关键亮点**：通过模拟取字符的过程，分别考虑第一次取0和1的情况，最终取最大值作为结果。代码实现较为直观。
   - **核心实现思想**：遍历每个字符串，模拟取字符的过程，分别记录第一次取0和1的情况，最后取最大值。
   - **代码片段**：
     ```cpp
     int main(){
         scanf("%d",&n);
         for(int i=1,m,l,r;i<=n;i++){
             scanf(" %s",s);
             m=strlen(s);
             l=0; tot=0;
             for(r=1;r<m;r++){
                 if(s[l] != s[r])
                     q[++tot]={s[l]-'0',r-l},l=r;
             }
             q[++tot]={s[l]-'0',r-l},l=r;
             if(q[1].col == 0) for(int i=1;i<=tot;i++) ans[0][i]+=q[i].cnt,ans[1][i+1]+=q[i].cnt;
             else for(int i=1;i<=tot;i++) ans[0][i+1]+=q[i].cnt,ans[1][i]+=q[i].cnt;
         }
         int ans1=0,ans2=0;
         for(int i=1;ans[0][i];i++) ans1+=ans[0][i]-1;
         for(int i=1;ans[1][i];i++) ans2+=ans[1][i]-1;
         printf("%d",ans1 > ans2? ans1:ans2);
         return 0;
     }
     ```

### 最优关键思路或技巧
1. **贪心策略**：每次尽可能多地取出相同字符，直到无法继续为止，然后切换到另一个字符。这种方法能够有效减少相邻字符不同的对数，从而最大化相同字符的对数。
2. **统计相邻字符不同的次数**：通过统计每个字符串的相邻字符不同的次数，并分别考虑第一次取0和1的情况，最终取最小值作为结果。
3. **模拟取字符的过程**：通过模拟取字符的过程，分别考虑第一次取0和1的情况，最终取最大值作为结果。

### 可拓展之处
该题的贪心策略可以应用于其他类似的字符串合并问题，例如在合并多个字符串时，要求最大化或最小化某种特定的属性（如相邻字符的相同对数、字符串的字典序等）。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

### 个人心得
- **调试经历**：一些题解在调试过程中发现，第一次取的字符不能是某个串的开头，因此需要额外考虑这种情况。
- **踩坑教训**：在模拟取字符的过程中，需要注意每个字符串的取字符位置，避免重复计算或遗漏。
- **顿悟感想**：通过贪心策略，能够有效减少相邻字符不同的对数，从而最大化相同字符的对数。

---
处理用时：48.39秒
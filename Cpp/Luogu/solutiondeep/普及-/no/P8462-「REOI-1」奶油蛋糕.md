# 题目信息

# 「REOI-1」奶油蛋糕

## 题目背景


----------
早餐时间过后，小不点们都前往操场接受基础训练课程，威廉便趁机占据厨房了。  
他在军服上披围裙，头上绑三角巾，还将清早从市场采买回来的大量材料摆到桌上。  
接着，威廉烤了大量的奶油蛋糕。  

威廉把奶油蛋糕摆放到桌子上，珂朵莉闻到了蛋糕的香味，迫不及待地扑到了餐桌前享受着这份饕餮盛宴，然而蛋糕的制作，似乎还差了那么最后一步……  
“等一等哦，我还没有挤上奶油呢。”威廉说着，拿起了裱花袋。  

可饥肠辘辘的珂朵莉哪里等得起全部的奶油都给挤好？  
正当威廉还在忙着挨个给蛋糕挤上白花花的奶油的时候，珂朵莉已经偷偷的拿起了一块蛋糕……

## 题目描述

在桌子上的蛋糕可以看作是一个无限大的[平面直角坐标系](https://baike.baidu.com/item/%E5%B9%B3%E9%9D%A2%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB/1296463?fr=aladdin)，每一个蛋糕都位于坐标系的整点上。 

每一分钟，威廉会给每个蛋糕都涂上若干层奶油，规则如下：如果蛋糕连续第 $i$ 次没有被珂朵莉吃到，那么就会在蛋糕上挤上 $i$ 层奶油。  

每次在威廉挤完所有蛋糕的奶油后，珂朵莉会拿起一块蛋糕，把这个蛋糕上的奶油给吃掉一层。特别的，如果珂朵莉吃掉了蛋糕上的一层奶油，威廉马上会贴心的再次给这个蛋糕补上一层，且不计入连续没有被吃到的次数里（即下一次的 $i$ 依旧为 $1$ ）。  

由于蛋糕太多，珂朵莉实在不知道从何下手，所以她决定按照移动的吃法进行试吃。  
总共 $m$ 个分钟，珂朵莉的吃蛋糕序列可以用一个长度为 $m$ 的字符串表达。第 $t$ 个字符可能为 `N`，`S`，`W`，`E`分别表示珂朵莉在第 $t+1$ 分钟会吃掉第 $t$ 分钟吃掉蛋糕的上，下，左，右方位的蛋糕。  
珂朵莉第 $1$ 个分钟会拿起位于点 $(x,y)$ 的蛋糕，因为蛋糕目前没有被挤上奶油，所以珂朵莉既不会进行试吃，威廉也不会立刻给她补上奶油。

珂朵莉想知道在 $m$ 分钟后，这些蛋糕在最后都还剩多少层奶油。

本题中的上和右分别表示 $y$ 轴正方向和 $x$ 轴正方向。

---
简要题面：

有一个 $n\times n$ 的地块，一个连续 $i$ 分钟没人经过的地面在第 $i$ 分钟会落上 $i$ 个单位的灰，有人经过时不会落灰但灰也不会清零，在人走后第一分钟又会落上一个单位的灰，以此类推。有一个人在这个 $n\times n$ 的范围内移动，他的移动轨迹可以描述为一个由 $\text{N,S,W,E}$ 组成的字符串，每个字母分别表示上、下、左、右。这个人一开始在点 $(x,y)$，每一分钟移动一步。

求最后每一个位置上落下的灰的量。

保证这个人没有超过移动的范围。


## 说明/提示

**本题 y 轴朝上，x 轴朝右，样例输出中的左下角表示 $(1,1)$，第一分钟珂朵莉在初始点处，第二分钟移动到相应的位置，第 $m+1$ 分钟移动到最后一个点，但是总共只有 $m$ 分钟，因此最后一个点不受移动的影响**

---
**样例 1 解释：**

珂朵莉的移动路径为 $(1,1)\rightarrow(1,2)\rightarrow(2,2)\rightarrow(2,3)\rightarrow(1,3)$，共 $4$ 分钟。

对于第 $1$ 分钟，$(1,1)$ 奶油层数不变，其余点被挤上了 $1$ 层奶油。

对于第 $2$ 分钟，$(1,2)$ 奶油层数不变，$(1,1)$ 被挤上了 $1$ 层奶油，其余点挤上 $2$ 层奶油。

对于第 $3$ 分钟，$(2,2)$ 奶油层数不变，$(1,1)$ 挤上 $2$ 层奶油，$(1,2)$ 挤上 $1$ 层奶油，其余点挤上 $3$ 层奶油。

对于第 $4$ 分钟，$(2,3)$ 奶油层数不变，$(1,1)$ 挤上 $3$ 层奶油，$(1,2)$ 挤上 $2$ 层奶油，$(2,2)$ 挤上 $1$ 层奶油，其余点挤上 $4$ 层奶油。

**注意最后珂朵莉移动到了 $(1,3)$，但是时间只有 $4$ 分钟，所以实际上不会对 $(1,3)$ 造成影响。初始点不一定在 $(1,1)$。**

$1\le n\leq 50,1\leq m\le 1000$。

## 样例 #1

### 输入

```
5 4 1 1
NENW```

### 输出

```
10 10 10 10 10 
10 10 10 10 10 
10 6 10 10 10 
4 4 10 10 10 
6 10 10 10 10 
```

## 样例 #2

### 输入

```
7 14 1 1
NENENENENESSSS```

### 输出

```
105 105 105 105 105 105 105 
105 105 105 105 55 61 105 
105 105 105 49 51 69 105 
105 105 51 49 105 79 105 
105 61 55 105 105 91 105 
79 69 105 105 105 105 105 
91 105 105 105 105 105 105 
```

## 样例 #3

### 输入

```
10 70 2 2
NWSNSNNNSNNSSNNSENNNNEESNWSESESSWENNSEWESWWWESEEESENNSENWNESNWSNNNEESS```

### 输出

```
2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 
2485 1407 1205 1267 2485 2485 2485 2485 2485 2485 
2485 1435 1281 1167 2485 2485 2485 2217 2281 2347 
2485 1465 2485 1255 1041 2485 2485 2155 2485 2415 
1557 1497 2485 2485 969 1177 2485 1733 1807 2485 
1471 1531 1315 907 935 1267 2485 1473 1647 2485 
1631 2485 2485 1357 1381 1407 1435 1499 1645 2485 
2021 2347 2485 2485 2485 2485 1465 1497 2485 2485 
2087 2415 2485 2485 2485 2485 2485 2485 2485 2485 
2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 
```

## 样例 #4

### 输入

```
5 4 2 1
NENW```

### 输出

```
10 10 10 10 10 
10 10 10 10 10 
10 10 6 10 10 
10 4 4 10 10 
10 6 10 10 10 
```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
题目要求模拟一个人在二维平面上的移动过程，并根据移动轨迹计算每个位置上的“灰”的累积量。由于数据范围较小（$n \leq 50$, $m \leq 1000$），直接暴力模拟即可。难点在于如何正确处理每个位置灰的累积逻辑，尤其是当人经过某个位置时，灰的累积需要重新开始计算。

### 所选高星题解

#### 1. 作者：XL4453 (赞：8)
- **星级**: 4.5
- **关键亮点**: 使用`vector`记录每个位置被经过的时间，最后通过时间间隔计算灰的累积量，避免了每次移动时遍历整个矩阵，优化了时间复杂度。
- **个人心得**: 通过记录时间间隔，避免了重复计算，提高了效率。
- **核心代码**:
```cpp
vector <int> v[1005][1005];
for(int i=0;i<s.size();i++){
    v[x][y].push_back(i+1);
    if(s[i]=='N')x++;
    if(s[i]=='S')x--;
    if(s[i]=='W')y--;
    if(s[i]=='E')y++; 
}
for(int i=n;i>=1;i--){    
    for(int j=1;j<=n;j++){
        v[i][j].push_back(s.size()+1);
        int ans=0,now=0;
        for(int k=0;k<v[i][j].size();k++){
            ans+=calc(v[i][j][k]-now-1);
            now=v[i][j][k];
        }
        printf("%d ",ans);
    }
    printf("\n");
}
```

#### 2. 作者：Dregen_Yor (赞：2)
- **星级**: 4
- **关键亮点**: 使用等差数列求和公式计算灰的累积量，减少了计算量，代码简洁。
- **核心代码**:
```cpp
for(int i=0, step = 1; step <= m && i < s.size(); i++, step++){
    int tmp = step - last[x][y];
    sum[x][y] += tmp * (1 + tmp) >> 1;
    sum[x][y] -= (step - last[x][y]);
    last[x][y] = step;
    if(s[i] == 'N') x++;
    else if(s[i] == 'S') x--;
    else if(s[i] == 'W') y--;
    else if(s[i] == 'E') y++;
}
```

#### 3. 作者：0xFF (赞：0)
- **星级**: 4
- **关键亮点**: 通过记录每个位置上次被经过的时间，计算时间间隔并累加灰的厚度，思路清晰。
- **核心代码**:
```cpp
for(int i(1);i<=m;i++){
    ans[dx][dy] += (i - last[dx][dy]) * (i - last[dx][dy] - 1) / 2;
    last[dx][dy] = i;
    if(str[i] == 'N') dx++;
    if(str[i] == 'E') dy++;
    if(str[i] == 'W') dy--;
    if(str[i] == 'S') dx--;
}
```

### 最优关键思路或技巧
1. **时间间隔记录法**: 通过记录每个位置被经过的时间，计算时间间隔来累积灰的厚度，避免了每次移动时遍历整个矩阵，提高了效率。
2. **等差数列求和公式**: 利用等差数列求和公式快速计算灰的累积量，减少了计算量。

### 可拓展之处
类似的问题可以扩展到三维空间或其他更复杂的移动规则，关键在于如何高效地记录和计算每个位置的累积量。

### 推荐题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

---
处理用时：30.30秒
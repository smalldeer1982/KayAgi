# 题目信息

# 小挖的 X 献身

## 题目描述

给定一张 $n\times  n$ 的 $01$ 方阵，请计算其中 X 的数目。

X 定义为用 $1$ 填充且形状为 X 的联通块。具体的，X 由左向斜线 `\` 和右向斜线 `/` 构成，且需要保证左向斜线和右向斜线**长度相等**，而且 X 是中心对称图形，斜线长度大于 1。

例如：

```cpp
101
010
101
```
有一个斜线长度为 $3$ 的 X。

```cpp
1001
0110
0110
1001
````

则有两个斜线长度分别为 $2,4$ 的 X。

```cpp
10001
01010
00100
01010
00001
```

仅有一个斜线长度为 $3$ 的 X 。

## 说明/提示

对于 $20\%$ 的数据，$1\leq n\leq 3$。

对于 $40\%$ 的数据，$1\leq n\leq 10$。

对于 $70\%$ 的数据，$1\leq n\leq 50$。

对于 $100\%$ 的数据，$1\leq n\leq 100$。

## 样例 #1

### 输入

```
5
10001
01010
00100
01011
00011```

### 输出

```
2```

# AI分析结果

### 算法分类
**枚举**

### 综合分析与结论
题目要求统计 $n \times n$ 的 $01$ 矩阵中所有符合条件的 X 形数量。X 形由两条长度相等且中心对称的斜线组成，且斜线长度大于 1。所有题解均采用枚举的思路，通过遍历矩阵中的每个点或每个可能的中心点，判断其是否能构成一个 X 形。不同题解的主要区别在于枚举的方式和判断 X 形的具体实现。

### 所选题解

#### 1. 作者：刘辰雨 (赞：36)
**星级：4.5**
**关键亮点：**
- 通过遍历同一行的两个 `1` 来确定 X 形的左右上角，从而确定整个 X 形。
- 通过限制枚举范围避免重复计算，确保每个 X 形只被统计一次。
- 代码逻辑清晰，注释详细，易于理解。

**核心代码：**
```cpp
void pd(int i,int j,int k)
{
    if(n-i < k-j) return;
    int x1 = i, y1 = j, y2 = k;
    for(int u = 1 ; u< k-j+1 ; u++)
    {
        x1++; y1++; i++; y2--;
        if(mp[x1][y1] == 0) return;
        if(mp[i][y2] == 0) return;
    }
    ans++;
}
```
**实现思想：** 通过遍历同一行的两个 `1`，判断它们是否能构成一个 X 形，并在遍历过程中检查所有相关点是否为 `1`。

#### 2. 作者：DengDuck (赞：11)
**星级：4**
**关键亮点：**
- 枚举所有可能的区间大小和左上角坐标，判断左向斜线和右向斜线是否合法。
- 通过双重循环枚举区间大小和左上角坐标，代码简洁易懂。
- 时间复杂度为 $O(n^4)$，但由于 $n \leq 100$，仍能通过。

**核心代码：**
```cpp
for(int i=2;i<=n;i++) {
    for(int j=1;j+i-1<=n;j++) {
        for(int k=1;k+i-1<=n;k++) {
            bool flag=false;
            for(int l=1;l<=i;l++) {
                if(a[j+l-1][k+l-1]!='1') flag=true;
            }
            for(int l=1;l<=i;l++) {
                if(a[j+l-1][k+i-l]!='1') flag=true;
            }
            if(flag==false) ans++;
        }
    }
}
```
**实现思想：** 枚举所有可能的区间大小和左上角坐标，判断左向斜线和右向斜线是否全为 `1`，若合法则统计 X 形数量。

#### 3. 作者：CharlesZiy (赞：5)
**星级：4**
**关键亮点：**
- 分别处理奇数长度和偶数长度的 X 形，通过固定中心点或中心块向外扩展判断。
- 代码结构清晰，通过函数封装判断逻辑，便于理解和维护。
- 时间复杂度为 $O(n^3)$，性能较好。

**核心代码：**
```cpp
int findX_odd(int i, int j) {
    int ans = 0, fac = 1;
    while (true) {
        for (int x = 0; x < 4; x++) {
            if (!valid(i + (dx_odd[x] * fac), j + (dy_odd[x]) * fac)) return ans;
            if (mp[i + (dx_odd[x] * fac)][j + (dy_odd[x] * fac)] == 0) return ans;
        }
        ans++; fac++;
    }
}
```
**实现思想：** 通过固定中心点向外扩展，判断四个方向上的点是否全为 `1`，若合法则统计 X 形数量。

### 最优关键思路或技巧
- **枚举中心点或中心块**：通过固定中心点或中心块，向外扩展判断 X 形的合法性，避免重复计算。
- **剪枝优化**：在枚举过程中，若发现某个点不满足条件，立即停止进一步判断，减少不必要的计算。
- **分情况处理**：将 X 形分为奇数长度和偶数长度两种情况，分别处理，简化判断逻辑。

### 可拓展之处
- **类似问题**：可以扩展到其他形状的统计问题，如矩形、菱形等，通过枚举中心点或边界点进行判断。
- **优化思路**：可以考虑使用前缀和或动态规划等优化手段，进一步降低时间复杂度。

### 推荐题目
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - 枚举与剪枝的结合。
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036) - 枚举与组合的结合。
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 枚举与广度优先搜索的结合。

---
处理用时：32.81秒
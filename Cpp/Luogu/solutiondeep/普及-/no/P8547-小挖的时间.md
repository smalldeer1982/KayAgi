# 题目信息

# 小挖的时间

## 题目描述

小挖有一个电子表，采用只显示小时和分钟的 $12$ 小时制，即只显示 $12:00\sim 11:59$，$12:59$ 后的时刻是 $1:00$。

小时数不会有前导零，但分钟数可以（比如 $7:59$ 不会写成 $07:59$，而 $10:03$ 不会写成 $10:3$）。

小挖从某天**中午**（即 $12:00$）开始盯着这块电子表，一共会持续盯 $T$ 分钟。Ta 现在想知道，一共会看到多少次成**等差数列**的时刻呢？

**等差数列**的定义如下：如果一个数列是等差数列，那么第一个数后面的每一个数，都是前面一个数加上一个固定的差值。比如 $11:11$ 就是一个固定差值为 $0$ 的等差数列时刻，$12:34$ 就是一个固定差值为 $1$ 的等差数列时刻。

如果你稍微留心一点，就会发现我没有给差值明确的大小定义，所以正数负数皆可。

## 说明/提示

对于 $30\%$ 的数据，$0\leq T\leq 60$。

对于 $60\%$ 的数据，$0\leq T\leq 10^5$。

对于 $100\%$ 的数据，$0\leq T \leq 10^9$，$1\leq D\leq 500$。

#### 样例说明

对于第一个询问 $34$，询问的是从 $12:00\sim 12:34$ 的时刻。其中仅有 $12:34$ 一个时刻满足题意。

对于第三个询问 $100$，询问的是从 $12:00\sim 1:40$ 的时刻。其中有 $12:34,1:11,1:23,1:35$ 四个符合要求的时刻。

对于第四个询问 $118$，询问的是从 $12:00\sim 1:58$ 的时刻。其中有 $12:34,1:11,1:23,1:35,1:47$ 五个符合要求的时刻。

## 样例 #1

### 输入

```
6
34
60
100
118
50
106```

### 输出

```
1
1
4
5
1
4```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
本题的核心是通过模拟时间的变化，判断每个时刻是否满足等差数列的条件。由于时间具有周期性（每720分钟循环一次），因此可以通过预处理每个循环内的等差数列时刻数量，然后根据输入的时间长度进行快速计算。

### 所选题解
#### 题解1：Aya_tt (4星)
**关键亮点：**
1. 利用时间的周期性，预处理每个720分钟循环内的等差数列时刻数量（31个）。
2. 通过取模运算减少计算量，避免重复计算。
3. 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
int l = n / 720;
ans += l * 31;
n %= 720;
for(register int i = 1;i <= n;i++){
    a[4]++;
    if(a[4] == 10){
        a[4] = 0;
        a[3]++;
        if(a[3] == 6){
            a[3] = 0;
            a[2]++;
            if(a[2] == 3 && a[1] == 1){
                a[1] = 0;
                a[2] = 1;
            }
            if(a[2] == 10){
                a[1]++;
                a[2] = 0;
            }
        } 
    }
    if(a[1] == 0){
        if(a[4] - a[3] == a[3] - a[2]){
            ans++;
        }
    }
    else if(a[4] - a[3] == a[3] - a[2] && a[2] - a[1] == a[3] - a[2]){
        ans++;
    }
}
```
**个人心得：**
“直接一个个枚举时间，是不足已通过此题的，于是我们就想到了时间是循环的，一个循环是720分钟。”

#### 题解2：MvemiY (4星)
**关键亮点：**
1. 同样利用时间的周期性，预处理每个720分钟循环内的等差数列时刻数量（31个）。
2. 通过取模运算减少计算量，避免重复计算。
3. 代码简洁，逻辑清晰。

**核心代码：**
```cpp
ans = (x / mod) * fix;
x %= mod; 
for(int i = 12, j = 0; x ; x--){
    j++;
    if(j >= 60){
        j = 0, i++;
        if(i == 13)
            i = 1;
    }
    if(i >= 10){
        int a = i / 10, b = i % 10, c = j / 10, d = j % 10;
        if(a - b == b - c && b - c == c - d)
            ans++;
    }
    else {
        int a = i, b = j / 10, c = j % 10;
        if(a - b == b - c)
            ans++;
    }
}
```
**个人心得：**
“所以我们可以先将跑满12×60分钟的答案求出来，然后将ans刚开始就加上，然后再进行mod。”

### 最优关键思路或技巧
1. **周期性优化**：利用时间的周期性（每720分钟循环一次），预处理每个循环内的等差数列时刻数量，然后通过取模运算减少计算量。
2. **模拟时间变化**：通过模拟时间的变化，判断每个时刻是否满足等差数列的条件。

### 可拓展之处
1. **类似问题**：可以扩展到其他具有周期性的问题，如日期、星期等。
2. **优化技巧**：在处理具有周期性的问题时，可以通过预处理和取模运算来优化计算。

### 推荐题目
1. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)
2. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)
3. [P1036 选数](https://www.luogu.com.cn/problem/P1036)

这些题目都涉及到模拟和周期性优化，可以帮助进一步巩固相关技巧。

---
处理用时：29.01秒
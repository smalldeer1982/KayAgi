# 题目信息

# 探索未知

## 题目背景

下发文件：

<https://luogu-ipic.oss-cn-shanghai.aliyuncs.com/watujir2-jdi92.zip>

## 题目描述

2102 年，人类已经建立了从地球到室女座 $\alpha $ 星的星际通道。通道绵延数百光年。

而在通道上有许多路牌。第 $i$ 个路牌上写有一个分数 $\dfrac{a_i}{b_i}$ 和一个分数运算符 $+$ 或 $-$。

一开始，你的手上拿着一个数字 $0$。你沿着通道向后走。每走到一个路牌，**会用手上的数和路牌上的分数，用路牌上的运算符号进行计算，并把得到的新数拿在手中（丢弃掉手中原来的数）**。值得注意的是，如果你手中计算得到的数不是整数，则会保留既约分数的形式；否则直接保留整数形式。

现在你想知道，当你走到通道的末端时，手中拿着的数是多少？

## 说明/提示

对于 $20\%$ 的数据，运算符只存在加法。

另有 $20\%$ 的数据，运算法只存在减法。

对于 $100\%$ 的数据，保证 $1\leq n\leq 10^3$，$0\leq a \leq 1000$，$0 < b \leq 1000$，保证答案以及过程中全部数值(整数部分/分子/分母)不超过 $2\times 10^9$。


## 样例 #1

### 输入

```
3
3 5 1
4 7 2
7 3 1```

### 输出

```
248/105```

## 样例 #2

### 输入

```
4
6 7 1
8 3 2
9 14 2
5 17 1```

### 输出

```
-1541/714```

## 样例 #3

### 输入

```
3
7 4 1
3 8 2
3 8 2
```

### 输出

```
1```

# AI分析结果

### 算法分类
数学、模拟

### 综合分析与结论
该题目主要考察分数的加减运算及其化简，核心思路是通过通分和约分来模拟分数的加减过程。题解中大部分作者都采用了类似的思路，即通过最小公倍数（LCM）进行通分，再通过最大公约数（GCD）进行约分。部分题解还考虑了负数的处理，确保最终输出的分数形式正确。

### 所选题解
1. **作者：scp020 (赞：25)**
   - **星级：4.5**
   - **关键亮点**：代码简洁，逻辑清晰，直接通过通分和约分实现分数的加减运算。作者还特别处理了负数和约分的情况，确保输出格式正确。
   - **核心代码**：
     ```cpp
     while(n--)
     {
         a=read(),b=read(),op=read();
         if(op==1) ra=ra*b+rb*a,rb=rb*b;
         else ra=ra*b-rb*a,rb=rb*b;
         GCD=gcd(ra,rb),ra/=GCD,rb/=GCD;
     }
     ```
   - **个人心得**：作者在代码中特别处理了负数的约分情况，确保分子和分母的符号正确。

2. **作者：Tis员工 (赞：9)**
   - **星级：4**
   - **关键亮点**：代码结构清晰，通过通分和约分实现分数的加减运算，特别处理了分母为负数的情况，确保输出格式正确。
   - **核心代码**：
     ```cpp
     for(long long i=1;i<=n;i++){
         x=read();y=read();op=read();
         if(op==1)an=an*y+x*bn;
         else an=an*y-x*bn;
         bn=bn*y;
         k=gcd(an,bn);an=an/k;bn=bn/k;
     }
     ```
   - **个人心得**：作者在代码中特别处理了分母为负数的情况，确保负号在分子上。

3. **作者：bloodstalk (赞：7)**
   - **星级：4**
   - **关键亮点**：代码结构清晰，通过通分和约分实现分数的加减运算，特别处理了负数的约分情况，确保输出格式正确。
   - **核心代码**：
     ```cpp
     for(re int i=1;i<=n;i++)
     {
         nfz = read() , nfm = read() , op = read();
         if(fz == 0) { if(op == 2) fz = -nfz; else fz = nfz ; fm = nfm; continue; }
         int Lcm = lcm(fm,nfm);
         fz *= (Lcm/fm) , nfz *= (Lcm/nfm);
         if(op == 1) fz+=nfz; else fz-=nfz;
         fm = Lcm;
         int Gcd = gcd(abs(fz),fm);
         fz /= Gcd; fm /= Gcd;
     }
     ```
   - **个人心得**：作者在代码中特别处理了负数的约分情况，确保分子和分母的符号正确。

### 最优关键思路或技巧
1. **通分与约分**：通过最小公倍数（LCM）进行通分，再通过最大公约数（GCD）进行约分，确保分数的加减运算正确。
2. **负数处理**：在处理负数时，确保负号在分子上，避免分母为负数的情况。
3. **代码简洁性**：通过直接操作分子和分母，避免使用复杂的数据结构，使代码更加简洁易读。

### 可拓展之处
1. **高精度运算**：如果分数的分子或分母非常大，可以考虑使用高精度运算来处理。
2. **分数乘法与除法**：可以进一步扩展题目，要求实现分数的乘法和除法运算。

### 推荐题目
1. **P1022 计算器的改良**：考察分数的加减运算及其化简。
2. **P1062 数列**：考察分数的加减运算及其化简。
3. **P1063 能量项链**：考察分数的加减运算及其化简。

---
处理用时：32.44秒
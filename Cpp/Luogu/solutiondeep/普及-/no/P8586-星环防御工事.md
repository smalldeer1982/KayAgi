# 题目信息

# 星环防御工事

## 题目背景

来自河外星系的小行星群即将有组织地打击地球。

## 题目描述

据观测，一共会有共 $n$ 波小行星群攻击太阳系。每一波攻击有两个属性：$d_i,m_i$，表示第 $i$ 波攻击会在第 $d_i$ 个太阳日发动，小行星群的总质量为 $m_i$。如果不进行精准防御，太阳系或将面临灭顶之灾。于是你的上司将星环防御工事的建设任务交给了你。

准确来讲，星环防御工事每个太阳日最多可以击毁总质量为 $k$ 的小行星。对于某一个在第 $d$ 个太阳日出现的小行星群，如果星环防御工事不能在第 $d$ 或 $d+1$ 个太阳日将其击毁(或者仅能部分击毁)，那么该小行星群(或其残余部分)将会被移交给地球和平联合组织 TPC 去处理——你当然不希望到手的美差被别人抢走！

因此你现在想知道，你领导的星环防御工事最多可以击毁多少质量的小行星呢？

## 说明/提示

对于 $10\%$ 的数据，$1\leq n,\max\{d_i\} \leq 20$。

对于 $20\%$ 的数据，$1\leq n,\max\{d_i\}\leq 600$。

对于 $40\%$ 的数据，$1\leq n,\max\{d_i\}\leq 5000$。

对于另外 $10\%$ 的数据，保证全部小行星群的 $m_i$ 总和不超过 $k$ 。

对于 $100\%$ 的数据，$1\leq n,\max\{d_i\}\leq 3\times 10^5$，$0\leq m_i,k\leq 10^4$。

## 样例 #1

### 输入

```
3 3 
1 6
4 7
2 2```

### 输出

```
14```

## 样例 #2

### 输入

```
10 100
6 14
2 92
3 91
4 74
7 75
2 90
7 25
1 92
3 41
2 14```

### 输出

```
580```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
题目要求在小行星群攻击的每一天，尽可能多地击毁小行星，且每天最多只能击毁总质量为 $k$ 的小行星。核心思路是通过贪心策略，优先处理前一天的小行星群，以确保不会遗漏任何可能被击毁的小行星。所有题解都采用了贪心算法，通过排序或桶记录的方式，依次处理每一天的小行星群，确保在最优情况下击毁最多的小行星。

### 所选题解

#### 题解1：_EternalRegrets_ (4星)
**关键亮点**：
- 使用桶记录每天的小行星质量，确保处理顺序正确。
- 通过循环处理每一天的小行星，优先处理前一天的小行星，确保不会遗漏。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
for(int i=0;i<=maxn+1;i++) {
    if(i==0) {
        if(a[i]<k) {
            ans+=a[i];
            a[i]=0;
        } else {
            ans+=k;
            a[i]-=k;
        }
    } else {
        if(a[i-1]<=k) {
            ans+=a[i-1];
            used=a[i-1];
            a[i-1]=0;
        } else {
            ans+=k;
            used=k;
            a[i-1]-=k;
            continue;
        }
        if(a[i]<=k-used) {
            ans+=a[i];
            a[i]=0;
        } else {
            ans+=k-used;
            a[i]=a[i]-k+used;
        }
    }
}
```

#### 题解2：AirQwQ (4星)
**关键亮点**：
- 通过排序确保处理顺序正确，避免顾尾不顾头的情况。
- 使用数组记录每天剩余的处理能力，确保每天尽可能多地处理小行星。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    int comp=s[i].m;
    if(s[i].m>a[s[i].d]) s[i].m-=a[s[i].d],a[s[i].d]=0;
    else a[s[i].d]-=s[i].m,s[i].m=0;
    if(s[i].m>a[s[i].d+1]) s[i].m-=a[s[i].d+1],a[s[i].d+1]=0;
    else a[s[i].d+1]-=s[i].m,s[i].m=0;
    ans+=comp-s[i].m;
}
```

#### 题解3：_sin_ (4星)
**关键亮点**：
- 使用桶记录每天的小行星质量，确保处理顺序正确。
- 通过循环处理每一天的小行星，优先处理前一天的小行星，确保不会遗漏。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
for (int i = 0; i <= maxd+1; i++){
    if (i == 0){
        if (t[i] <= k) ans+=t[i], t[i] = 0;
        else{
            ans+=k, t[i]-=k;
        }
    }else{
        if (t[i-1] <= k) ans+=t[i-1], uk = t[i-1], t[i-1]=0;
        else {
            ans+=k, uk = k, t[i-1]-=k;continue ;
        }
        if (t[i]<=k-uk) ans+=t[i], t[i] = 0;
        else ans+=k-uk, t[i]-=(k-uk);
    }
}
```

### 最优关键思路或技巧
1. **贪心策略**：优先处理前一天的小行星群，确保不会遗漏任何可能被击毁的小行星。
2. **桶记录**：使用桶记录每天的小行星质量，确保处理顺序正确。
3. **排序**：通过排序确保处理顺序正确，避免顾尾不顾头的情况。

### 可拓展之处
类似的问题可以扩展到其他资源分配问题，如任务调度、资源分配等，都可以采用贪心策略，优先处理最紧急或最优先的任务。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

### 个人心得
- **调试经历**：在处理边界条件时，特别是第0天和最大天数+1天时，需要特别注意，确保不会遗漏任何可能被击毁的小行星。
- **踩坑教训**：在处理顺序上，如果不优先处理前一天的小行星，可能会导致遗漏，影响最终结果。

---
处理用时：36.39秒
# 题目信息

# [传智杯 #3 初赛] 志愿者

## 题目描述

传智专修学院总共召集了 $n$ 位志愿者来负责打扫活动，现在需要你负责帮忙统计每位志愿者的工作情况，用来制作光荣榜，给他们发小花花。

第 $i$ 位志愿者有一个工作时长 $t_i$ ，以及他负责的工作的难度系数 $k_i$ ，一名志愿者的贡献度可以用 $k_i \times t_i$ 确定。

现在要为这些志愿者的贡献度从大到小排个序，请你完成这个任务。相同贡献度的志愿者以工作时长较长的排在前面。如果贡献和时长一样，那么编号小的志愿者排在前面。



## 说明/提示

对于 $40\%$ 的数据，满足 $1 \leq n \leq 100$；  
对于额外 $20\%$ 的数据，满足 $k_i=1$；  
对于 $100\%$ 的数据，满足 $1 \leq n \leq 5 \times 10^5,1 \leq k_i,t_i \leq 1000$。

然而，由于本次比赛是 ACM 赛制，因此您必须通过 $100\%$ 的数据才能够获得本题的得分，后题同。

## 样例 #1

### 输入

```
3
1 2
2 3
3 4```

### 输出

```
3 2 1```

# AI分析结果

### 算法分类
排序

### 综合分析与结论
题目要求根据志愿者的贡献度、工作时长和编号进行排序，核心逻辑是自定义排序规则。由于题目没有复杂的算法需求，主要考察的是对排序算法的理解和实现。因此，最相关的算法分类是“排序”。

### 通用建议与扩展思路
1. **自定义排序规则**：在C++中，可以通过重载比较运算符或使用`std::sort`函数结合自定义比较函数来实现复杂的排序规则。
2. **时间复杂度**：由于数据规模较大（$n \leq 5 \times 10^5$），需要确保排序算法的时间复杂度为$O(n \log n)$，避免使用$O(n^2)$的排序算法。
3. **稳定性**：在贡献度和工作时长相同时，需要保证编号小的志愿者排在前面，因此排序算法需要是稳定的。

### 推荐题目
1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
2. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)
3. [P1068 分数线划定](https://www.luogu.com.cn/problem/P1068)

### 关键代码实现
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Volunteer {
    int id;
    int t;
    int k;
    int contribution() const {
        return k * t;
    }
};

bool compare(const Volunteer &a, const Volunteer &b) {
    if (a.contribution() != b.contribution()) {
        return a.contribution() > b.contribution();
    } else if (a.t != b.t) {
        return a.t > b.t;
    } else {
        return a.id < b.id;
    }
}

int main() {
    int n;
    std::cin >> n;
    std::vector<Volunteer> volunteers(n);
    for (int i = 0; i < n; ++i) {
        volunteers[i].id = i + 1;
        std::cin >> volunteers[i].t >> volunteers[i].k;
    }
    std::sort(volunteers.begin(), volunteers.end(), compare);
    for (const auto &v : volunteers) {
        std::cout << v.id << " ";
    }
    return 0;
}
```

### 核心实现思想
1. **结构体定义**：定义一个`Volunteer`结构体，包含志愿者的编号、工作时长和难度系数，并提供一个计算贡献度的成员函数。
2. **自定义比较函数**：实现一个比较函数`compare`，根据题目要求依次比较贡献度、工作时长和编号。
3. **排序与输出**：使用`std::sort`函数结合自定义比较函数对志愿者进行排序，最后输出排序后的志愿者编号。

### 个人心得
在实现自定义排序规则时，确保比较函数的逻辑清晰且正确是关键。特别是在处理多个比较条件时，需要注意条件的优先级和顺序，避免逻辑错误。

---
处理用时：20.16秒
# 题目信息

# [yLOI2023] 苦竹林

## 题目背景

> 悬挂在屋檐下的风铃，摇晃的声音很动听。  
> 思念就像梅雨下不停，我的心境一片泥泞。  
> 散落在天际里的繁星，闪烁着你我的宿命。  
> 当枫叶轻盈落入湖心，近看山水一片宁静。  

——银临 & 涵昱《苦竹林》

## 题目描述

共有 $n$ 个风铃悬挂在屋檐下，每个风铃都能发出一定音调的声音。从左到右给风铃从 $1$ 至 $n$ 编号，第 $i$ 个风铃的音调是 $a_i$。

为了表达内心的思念，扶苏决定在 $n$ 个的风铃中取出 $m$ 个，送给远方的朋友。

请你找到最小的整数 $\varepsilon$，使得存在一种方案，能够从 $n$ 个风铃中挑出 $m$ 个，设挑出风铃的音调为 $b_1, b_2, \dots b_m$，满足对任意的 $1 \leq i, j \leq m$，都有 $|b_i - b_j| \leq \varepsilon$。

## 说明/提示

### 样例 2 解释

一种选择的方案是选择第 $2,4,5,6$ 四个风铃，音调依次为 $7,3,4,6$。可以得到对任何的 $1 \leq i, j\leq 4$，都有 $|b_i - b_j| \leq 4$。

另一种方案是选择第 $2,3,5,6$ 四个风铃，同样计算得到的 $\varepsilon$ 为 $4$。

### 数据规模与约定

- 对 $10\%$ 的数据，$m = 2$。
- 另有 $10\%$ 的数据，$m = n$。
- 对 $40\%$ 的数据，$n \leq 5$。
- 对 $60\%$ 的数据，保证对所有的 $2 \leq i \leq n$，满足 $a_{i - 1} \leq a_i$，即 $a_i$ 单调不降。
- 对 $80\%$ 的数据，$n \leq 10^3$。
- 对 $100\%$ 的数据，$2 \leq m \leq n \leq 10^5$，$1 \leq a_i \leq 10^9$。

### 说明

本题共有三个附加样例文件，见题目附件中的 `ring.zip`。

## 样例 #1

### 输入

```
5 3
1 2 3 4 5```

### 输出

```
2```

## 样例 #2

### 输入

```
6 4
1 7 8 3 4 6```

### 输出

```
4```

# AI分析结果

### 算法分类
排序

### 综合分析与结论
所有题解的核心思路都是通过排序将问题简化，然后通过滑动窗口的方式找到最小的极差。排序后，最优解一定出现在连续的 $m$ 个元素中，因此只需要遍历所有可能的连续 $m$ 个元素的区间，计算其极差并取最小值即可。这种方法的时间复杂度为 $O(n \log n)$，主要来自排序操作，后续的滑动窗口遍历是 $O(n)$。

### 所选题解
1. **作者：一扶苏一 (赞：14)**  
   - **星级：5星**  
   - **关键亮点**：思路清晰，代码简洁，使用了 `std::sort` 进行排序，时间复杂度为 $O(n \log n)$，适用于大规模数据。  
   - **核心代码**：
     ```cpp
     std::sort(a.begin(), a.end());
     for (int l = 0, r = m - 1; r < n; ++l, ++r) {
         ans = std::min(ans, a[r] - a[l]);
     }
     ```
   - **个人心得**：无

2. **作者：zzyxl_qaq (赞：10)**  
   - **星级：4星**  
   - **关键亮点**：代码简洁，使用了 `sort` 进行排序，时间复杂度为 $O(n \log n)$，适用于大规模数据。  
   - **核心代码**：
     ```cpp
     sort(a+1,a+n+1);
     for(int i=1;i<=n-m+1;i++){
         ans=min(ans,a[i+m-1]-a[i]);
     }
     ```
   - **个人心得**：无

3. **作者：__Allen_123__ (赞：5)**  
   - **星级：4星**  
   - **关键亮点**：代码简洁，使用了 `sort` 进行排序，时间复杂度为 $O(n \log n)$，适用于大规模数据。  
   - **核心代码**：
     ```cpp
     sort(a + 1, a + n + 1);
     for(int i = 1;i <= n - m + 1;i++){
         ans = min(ans, a[i + m - 1] - a[i]);
     }
     ```
   - **个人心得**：无

### 最优关键思路或技巧
1. **排序**：通过排序将问题简化，使得最优解一定出现在连续的 $m$ 个元素中。
2. **滑动窗口**：遍历所有可能的连续 $m$ 个元素的区间，计算其极差并取最小值。

### 可拓展之处
类似的问题可以通过排序和滑动窗口的方式解决，例如在数组中寻找满足某些条件的最短子数组或子序列。

### 推荐题目
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)
2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

---
处理用时：19.94秒
# 题目信息

# [PA 2020] Zabawki

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 2 [Zabawki](https://sio2.mimuw.edu.pl/c/pa-2020-1/zab/)**

你可能不知道，Bitie 和 Bytie 兄弟有相当令人印象深刻的玩具收藏品！他们每个人都拥有 $n$ 个玩具，每个玩具都是 $26$ 种类型中的一种。为方便起见，兄弟俩给每种类型的玩具都贴上了从 $\texttt a$ 到 $\texttt z$ 的英文字母标签。

在今天的游戏中，Bitie 拿出了他的玩具并按从左到右的顺序排列。因此，Bitie 可以用一个有 $n$ 个英文字母的序列来描述他的玩具的排列；这个序列的第 $i$ 个字符表示 Bitie 的序列中从左起的第 $i$ 个玩具。同时 Bytie 也拿出了他的玩具并按从左到右的顺序排列。现在 Bitie 想变得更像 Bytie——他想把自己的玩具按 Bytie 的玩具的顺序排列。

在游戏过程中，Bitie 可以通过翻转来改变他的玩具的顺序，一次翻转可以取奇数个连续的玩具并颠倒其顺序。因此，如果字符串 $\texttt{abcdea}$ 描述了 Bitie 的玩具顺序，那么在一次翻转中，Bitie 可以产生例如 $\texttt{adcbea}$（通过颠倒从第二个到第四个玩具的顺序）或 $\texttt{edcbaa}$（通过颠倒从第一个到第五个玩具的顺序）的序列。然而，他不能在一次翻转之后得到序列 $\texttt{bacdea}$。

Bitie 能够通过翻转得到和 Bytie 的玩具序列一样的序列吗？

## 说明/提示

#### 样例 1 解释

对于第一组样例，Bitie 可以通过三次翻转操作得到和 Bytie 一样的玩具序列。

![](https://cdn.luogu.com.cn/upload/image_hosting/vexaj3z8.png)

------------

#### 数据范围

**本题采用捆绑测试**

对于一些子任务，满足如果这组数据的答案是 `TAK`，那么 Bitie 最多只需进行一次交换就可以得到和 Bytie 一样的序列。

此外，大约一半的子任务满足 $n\le 2\times 10^3$。

对于 $100\%$ 的数据：

- 保证 $1\le n\le 3\times 10^5$。
- 保证字符串中只出现小写英文字母（$\texttt a$ 到 $\texttt z$）。

## 样例 #1

### 输入

```
7
abcdefg
edgbcfa```

### 输出

```
TAK```

## 样例 #2

### 输入

```
5
abcde
fghhh```

### 输出

```
NIE```

# AI分析结果

### 算法分类
字符串

### 综合分析
题目要求通过翻转奇数长度的子串，判断两个字符串是否能通过若干次操作变得相同。所有题解的核心思路都是基于翻转操作不改变字符位置的奇偶性，因此只需比较两个字符串中每个字符在奇数和偶数位置上的数量是否相同。

### 精选题解
1. **作者：lzbzl (4星)**
   - **关键亮点**：使用桶排记录每个字母在奇偶位置的数量，简洁高效。
   - **代码核心**：
     ```cpp
     int vis[27][2], siv[27][2];
     for(int i=0;i<n;i++) {
         vis[a[i]-'a'][i%2]++;
         siv[b[i]-'a'][i%2]++;
     }
     for(int i=0;i<=25;i++) {
         if(vis[i][0]!=siv[i][0] || vis[i][1]!=siv[i][1]) {
             cout<<"NIE";
             return 0;
         }
     }
     cout<<"TAK";
     ```

2. **作者：heaksicn (4星)**
   - **关键亮点**：思路清晰，代码简洁，直接比较奇偶位置上的字符数量。
   - **代码核心**：
     ```cpp
     int a[26][2][2];
     for(int i=1;i<=n;i++) {
         a[s[i]-'a'][i%2][0]++;
         a[t[i]-'a'][i%2][1]++;
     }
     bool flag=1;
     for(int i=0;i<26;i++) {
         if(a[i][0][0]!=a[i][0][1]||a[i][1][0]!=a[i][1][1]) {
             flag=0;
             break;
         }
     }
     puts(flag?"TAK":"NIE");
     ```

3. **作者：ztksc07 (4星)**
   - **关键亮点**：详细解释了翻转操作对字符位置奇偶性的影响，代码实现清晰。
   - **代码核心**：
     ```cpp
     int t1[30], t2[30], t3[30], t4[30];
     for(int i=0;i<n;i++) {
         if(i%2==0) {
             t1[a[i]-'a']++; t3[b[i]-'a']++;
         } else {
             t2[a[i]-'a']++; t4[b[i]-'a']++;
         }
     }
     bool flag=1;
     for(int i=0;i<26;i++) {
         if(t1[i]!=t3[i]||t2[i]!=t4[i]) {
             flag=0; break;
         }
     }
     if(flag) cout<<"TAK";
     else cout<<"NIE";
     ```

### 最优关键思路
通过翻转奇数长度的子串，字符的位置奇偶性不变。因此，只需比较两个字符串中每个字符在奇数和偶数位置上的数量是否相同。

### 拓展思路
类似问题可以扩展到其他操作不改变某些属性的情况，如翻转偶数长度子串、交换特定位置的字符等。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

### 个人心得摘录
- **David_yang**：通过多次提交和错误分析，最终发现翻转操作的关键点在于奇偶性不变。
- **ymyctsz**：通过手玩样例，深入理解了翻转操作对字符位置的影响，最终总结出只需比较奇偶位置上的字符数量。

---
处理用时：28.28秒
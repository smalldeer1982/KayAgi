# 题目信息

# [IOI 2009] POI

## 题目背景

IOI2009 D1T3

## 题目描述

普罗夫迪夫信息学奥林匹克竞赛（Plovdiv Olympiad in Informatics, POI）正在举行。有 $N$ 个选手和 $T$ 道题目。每道题目只有一组测试数据，因此对于每个选手和每道题目，要么这个选手解决了这道题目，要么没有解决。没有部分分。

比赛结束后，每道题目的分数为没有解决这道题目的选手数量。每个选手的得分为他解决的每道题目的得分之和。

Philip 参加了这场比赛，但他被复杂的计分规则搞糊涂了。他看着比赛结果，无法计算出他的最终排名。写一个程序帮助 Philip 计算他的分数和排名。

在比赛开始之前，每个选手从 $1$ 到 $N$ 编号。Philip 的编号为 $P$。最终的排行榜将所有选手按分数降序列出。为避免平局，在得分相同的选手中，按解决题目数量降序排序（解决题目数量多的选手排在解决数量题目少的选手之前）。如果仍存在平局，则按编号升序排序。

**任务**：编写一个程序，给定每个选手的解题情况，计算出 Philip 的分数和他在最终排行榜上的排名。

## 说明/提示

### 样例解释

第一道题目只有一个选手没有解决，所以它值 $1$ 分。第二道题目有两个选手没有解决，所以它值 $2$ 分。第三道题目有四个选手没有解决，所以它值 $4$ 分。因此编号为 $1$ 的选手得 $4$ 分，编号为 $2, 4, 5$ 的选手得 $3$ 分，编号为 $3$ 的选手得 $1$ 分。根据平局规则，编号为 $2$ 的选手（Philip）排在编号为 $4, 5$ 的选手之前，因此 Philip 的最终排名为 $2$，仅在编号为 $1$ 的选手下面。

### 数据范围与约定

- 对于 $35\%$ 的数据，没有选手得分和 Philip 相同。
- 对于 $100\%$ 的数据，$1\leq N, T\leq 2000$，$1\leq P\leq N$。

## 样例 #1

### 输入

```
5 3 2
0 0 1
1 1 0
1 0 0
1 1 0
1 1 0
```

### 输出

```
3 2
```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
该题目主要考察对比赛结果的模拟计算，涉及选手得分、题目得分、以及排序规则的实现。所有题解均采用了模拟的思路，通过遍历选手和题目的解题情况，计算每道题目的得分和每个选手的总分，最后按照给定的排序规则进行排序并输出结果。

### 所选高星题解
1. **作者：tianbiandeshenghuo (4星)**
   - **关键亮点**：使用了结构体存储选手信息，代码结构清晰，排序规则通过重载运算符实现，逻辑简洁明了。
   - **核心代码**：
     ```cpp
     struct Note{
       int a[2005], id, sco, acp;
       bool operator<(const Note &i)const{
         return sco == i.sco ? (acp == i.acp ? id < i.id : acp > i.acp) : sco > i.sco;
       }
     } a[2005];
     ```
   - **实现思想**：通过结构体存储选手的编号、每道题的答题情况、得分和通过题目数量，重载运算符实现排序规则，最后遍历输出结果。

2. **作者：_5t0_0r2_ (4星)**
   - **关键亮点**：使用了结构体存储选手信息，排序规则通过自定义比较函数实现，代码逻辑清晰，易于理解。
   - **核心代码**：
     ```cpp
     bool cmp(data a, data b){
       if (a.t != b.t) return a.t > b.t;
       if (a.cnt == b.cnt) return a.num < b.num;
       return a.cnt > b.cnt;
     }
     ```
   - **实现思想**：通过结构体存储选手的编号、得分和通过题目数量，自定义比较函数实现排序规则，最后遍历输出结果。

3. **作者：Lovely_Elaina (4星)**
   - **关键亮点**：使用了结构体存储选手信息，排序规则通过自定义比较函数实现，代码结构清晰，逻辑简洁。
   - **核心代码**：
     ```cpp
     bool cmp(node a,node b){
       if(a.t == b.t) {
         if(a.cnt == b.cnt) return a.num < b.num;
         return a.cnt > b.cnt;
       }
       return a.t > b.t;
     }
     ```
   - **实现思想**：通过结构体存储选手的编号、得分和通过题目数量，自定义比较函数实现排序规则，最后遍历输出结果。

### 最优关键思路或技巧
1. **结构体存储信息**：使用结构体存储选手的编号、得分和通过题目数量，便于后续排序和输出。
2. **排序规则实现**：通过重载运算符或自定义比较函数实现复杂的排序规则，确保排序结果符合题目要求。
3. **遍历计算得分**：通过遍历选手和题目的解题情况，计算每道题目的得分和每个选手的总分，确保得分计算准确。

### 可拓展之处
该题目可以拓展到其他类似的比赛或评分系统，如考试评分、竞赛排名等。类似的算法套路包括：
1. **多关键字排序**：在处理需要多个排序规则的场景时，可以通过重载运算符或自定义比较函数实现。
2. **模拟计算**：在处理需要模拟计算得分的场景时，可以通过遍历数据并逐步计算得分。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 考察贪心算法和优先队列的使用。
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 考察动态规划的基本应用。
3. [P1012 拼数](https://www.luogu.com.cn/problem/P1012) - 考察字符串处理和排序规则的应用。

### 个人心得总结
- **调试经历**：在实现排序规则时，确保所有条件都正确实现，避免因条件遗漏导致排序错误。
- **踩坑教训**：在计算得分时，注意题目得分的定义，确保得分计算准确。
- **顿悟感想**：通过结构体存储信息和重载运算符实现排序规则，可以大大简化代码逻辑，提高代码可读性。

---
处理用时：28.62秒
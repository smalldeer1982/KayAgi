# 题目信息

# [春季测试 2023] 涂色游戏

## 题目描述

有一天，小 D 在刷朋友圈时看到了一段游戏视频。

这个游戏的名字叫涂色游戏，视频中的游戏界面是一个 $n$ 行 $m$ 列的网格，初始时每一个格子都是白色（用数字 $0$ 表示）。其中每一行的左侧、每一列的上方都有一把带颜色的刷子。玩家点击某个刷子后，这个刷子会将其右侧（或下方）的一整行（或一整列）涂上同一种颜色，**该行（或该列）格子原有的颜色都会被覆盖成新涂上的颜色。**

下图展示的情况可以通过先将第一列涂成红色，然后将第一行涂成蓝色得到，若此时选择将第三列涂成绿色，则图中绿色方框中的格子都会变成绿色。

![](https://cdn.luogu.com.cn/upload/image_hosting/dc71alkw.png)

小 D 想用他自己编写的程序来进行视频中的游戏。在编程的过程中，小 D 在涂色逻辑的实现上却遇到了一些困难，于是他向你求助，希望你能帮他完成实现涂色逻辑部分的代码。

首先，小 D 会给你网格的行数和列数 $n, m$，然后给出 $q$ 次操作，每次操作用三个整数 $opt_i, x_i, c_i$ 表示：

- 如果 $opt_i=0$，那么这次操作会将第 $x_i$ **行**涂成颜色 $c_i$。
- 如果 $opt_i=1$，那么这次操作会将第 $x_i$ **列**涂成颜色 $c_i$。

在所有涂色操作结束以后，你需要输出网格中每个位置的颜色是什么。

## 说明/提示

**【样例 1 解释】**

注意当一个格子没有被涂色时，其颜色为白色，用数字 $0$ 表示。

**【样例 2】**

见选手目录下的 paint/paint2.in 与 paint/paint2.ans。

**【数据范围】**

对于所有数据，保证：

- $1 \leq T \leq 10$，$1 \leq n,m \leq 10^5$，$0 \leq q \leq 10^5$，$0 \leq c_i \leq 10^9$。
- 若 $opt_i=0$，则 $1 \leq x_i \leq n$；若 $opt_i=1$，则 $1 \leq x_i \leq m$。
- 单个测试点中所有数据的 $n \cdot m$ 的总和不超过 $10^6$，$q$ 的总和不超过 $10^6$。

|测试点|$n \le$|$m \le$|$q \le$|性质 A|性质 B|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|$1$|$1$|$0$|√|√|
|2|$1$|$1$|$1$|√|√|
|3|$1$|$10$|$20$|√|√|
|4|$1$|$10^5$|$10^5$|×|√|
|5|$1$|$10^5$|$10^5$|×|√|
|6|$1$|$10^5$|$10^5$|×|×|
|7|$10$|$10$|$20$|√|√|
|8|$50$|$50$|$100$|√|√|
|9|$50$|$50$|$100$|√|×|
|10|$1000$|$1000$|$2000$|×|√|
|11|$1000$|$1000$|$2000$|×|×|
|12|$1000$|$1000$|$2000$|×|×|
|13|$1000$|$1000$|$10^5$|×|×|
|14|$1000$|$1000$|$10^5$|×|×|
|15|$10^5$|$10^5$|$10^5$|√|√|
|16|$10^5$|$10^5$|$10^5$|√|√|
|17|$10^5$|$10^5$|$10^5$|√|×|
|18|$10^5$|$10^5$|$10^5$|√|×|
|19|$10^5$|$10^5$|$10^5$|×|×|
|20|$10^5$|$10^5$|$10^5$|×|×|

特殊性质 A：保证测试点中所有的 $q \cdot \max(n, m)$ 之和不超过 $10^7$。

特殊性质 B：保证 $opt_i = 1$。

**【提示】**

数据千万条，清空第一条。多测不清空，爆零两行泪。


## 样例 #1

### 输入

```
2
5 5 9
1 5 1
0 4 0
1 4 1
0 3 0
1 3 1
0 2 0
1 2 1
0 1 0
1 1 1
3 3 3
0 1 2
0 3 1
1 1 3```

### 输出

```
1 0 0 0 0
1 1 0 0 0
1 1 1 0 0
1 1 1 1 0
1 1 1 1 1
3 2 2
3 0 0
3 1 1```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
本题的核心逻辑是通过模拟涂色操作，最终输出每个格子的颜色。由于每次操作都是对整行或整列进行涂色，且后涂色的操作会覆盖之前的操作，因此可以通过记录每行和每列的最后一次涂色操作的时间和颜色，最终根据时间戳决定每个格子的颜色。

### 所选题解
1. **作者：liucang (5星)**
   - **关键亮点**：使用结构体存储每行和每列的涂色信息，包括颜色和时间戳，最后通过比较时间戳决定每个格子的颜色。代码清晰，逻辑简洁。
   - **核心代码**：
     ```cpp
     struct paint{ //绘画信息，col=列，row=行
         ll color, priority;
     }col[100010], row[100010];
     
     for(int i=1;i<=n;i++){
         for(int j=1;j<=m;j++){
             if(row[i].priority>col[j].priority){
                 printf("%lld ", row[i].color);
             }
             else {
                 printf("%lld ", col[j].color);
             }
         }
         printf("\n");
     }
     ```

2. **作者：hloixyh (4星)**
   - **关键亮点**：使用`pair`存储每行和每列的最后涂色时间和颜色，通过比较时间戳决定每个格子的颜色。代码简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     pair<int,int> h[100005],s[100005];
     
     for(int i=1;i<=n;++i){
         for(int j=1;j<=m;++j){
             if(h[i].second>s[j].second){
                 cout<<h[i].first<<" ";
             }else{
                 cout<<s[j].first<<" ";
             }
         }
         puts("");
     }
     ```

3. **作者：fengziyi (4星)**
   - **关键亮点**：使用两个数组分别存储行和列的涂色信息，包括颜色和时间戳，最后通过比较时间戳决定每个格子的颜色。代码结构清晰，逻辑简洁。
   - **核心代码**：
     ```cpp
     int line[2][100010];
     int pri[2][100010];
     
     for (reg int i = 1; i <= n; ++i){
         for (reg int j = 1; j <= m; ++j)
             if (pri[0][i] > pri[1][j])
                 cout << line[0][i] << ' ';
             else
                 cout << line[1][j] << ' ';
         cout << endl;
     }
     ```

### 最优关键思路或技巧
- **数据结构**：使用结构体或`pair`存储每行和每列的涂色信息，包括颜色和时间戳。
- **算法优化**：通过记录最后一次涂色操作的时间戳，避免了对每个格子进行多次更新，提高了效率。
- **思维方式**：将问题转化为对每行和每列的最后一次操作进行比较，简化了问题的复杂度。

### 可拓展之处
- **类似问题**：可以扩展到其他需要对矩阵进行批量操作的场景，如矩阵的旋转、翻转等。
- **算法套路**：在处理矩阵问题时，可以考虑是否可以通过记录行和列的操作来简化问题。

### 推荐题目
1. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

---
处理用时：24.64秒
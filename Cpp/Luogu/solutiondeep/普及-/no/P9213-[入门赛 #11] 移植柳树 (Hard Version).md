# 题目信息

# [入门赛 #11] 移植柳树 (Hard Version)

## 题目背景

**本题与 Easy Version 题意完全相同，不同的地方仅在于数据范围和单个测试点内含有的测试组数量。**

HG 在上学的路上无聊的走着，看着这马路边的一排柳树，他的脑子里突然冒出了个奇怪的问题……

## 题目描述

假设总共有 $n$ 棵柳树，每一棵间隔都为 $x$。

现在他需要对这些树做一些操作，使得在「这 $n$ 棵树的起点不变」的同时，任意两棵树的间隔都为 $y$（$y > x$）。

他被允许做的操作如下；


- 移植树木：将一个位置的树木移到另一个位置上。

如果对「起点不变」这个概念有疑惑，可以参照「样例解释」中的图例。

显然操作是需要体力的，HG 想要让尽可能多的树维持原状。现在 HG 想知道，为了达成「任意两棵树的间隔都为 $y$」这个目标，他最多可以让多少棵树保持在原来的位置。

请你帮帮他吧！

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/6uguqush.png)

图中的方块代表树。第一行为调整前，第二行为调整后的情况。标出的三个绿色的方块是不需要移动的树，除此之外其他树都需要移动。

### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq T \leq 10 ^ 5$，$1 \leq n \leq 10 ^ {18}$，$1 \leq x < y \leq 10 ^ 9$。  

## 样例 #1

### 输入

```
1
8 2 3```

### 输出

```
3```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
题目要求在不改变起点的情况下，调整树的间隔，使得任意两棵树的间隔为 $y$，并且尽可能多的树保持在原来的位置。核心思路是通过计算 $x$ 和 $y$ 的最小公倍数来确定哪些树可以保持不动。由于数据范围较大，需要特别注意避免溢出问题。

### 所选题解
1. **作者：zzx114514 (赞：6)**
   - **星级：5星**
   - **关键亮点：使用 `__int128` 处理大数，避免溢出问题；代码清晰，逻辑严谨。**
   - **个人心得：使用 `__int128` 需要快读快输，不能使用 `cin` 和 `cout`。**
   - **核心代码：**
     ```cpp
     __int128 lcm(__int128 a,__int128 b) {
         return a*b/__gcd(a,b);
     }
     void print(__int128 num) {
         if(num>9) print(num/10);
         putchar(num%10+'0');
     }
     int main() {
         cin>>t;
         while(t--) {
             n=read(),x=read(),y=read();
             l=(n-1)*x;
             print(l/lcm(x,y)+1);
             puts("");
         }
         return 0;
     }
     ```

2. **作者：cff_0102 (赞：5)**
   - **星级：4星**
   - **关键亮点：使用 `long double` 处理大数，避免溢出问题；代码简洁，公式推导清晰。**
   - **核心代码：**
     ```cpp
     int main() {
         ios::sync_with_stdio(false);
         int t;cin>>t;
         while(t--) {
             long long n,x,y;
             cin>>n>>x>>y;
             long double ans=1;
             ans*=(n-1);
             ans*=__gcd(x,y);
             ans/=y;
             cout<<(long long)ans+1<<endl;
         }
         return 0;
     }
     ```

3. **作者：liuliucy (赞：2)**
   - **星级：4星**
   - **关键亮点：通过公式推导简化计算，避免溢出问题；代码简洁，逻辑清晰。**
   - **核心代码：**
     ```cpp
     int main() {
         scanf("%d",&T);
         while(T--) {
             scanf("%lld%lld%lld",&n,&x,&y);
             printf("%lld\n",(n-1)/(y/gcd(x,y))+1);
         }
         return 0;
     }
     ```

### 最优关键思路或技巧
1. **使用 `__int128` 或 `long double` 处理大数，避免溢出问题。**
2. **通过计算 $x$ 和 $y$ 的最小公倍数来确定哪些树可以保持不动。**
3. **公式推导简化计算，避免直接计算大数乘积。**

### 可拓展之处
类似的问题可以扩展到其他需要处理大数或最小公倍数的场景，如调整其他类型的间隔或排列问题。

### 推荐题目
1. [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)
2. [P1072 Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)
3. [P1069 细胞分裂](https://www.luogu.com.cn/problem/P1069)

### 个人心得总结
在处理大数问题时，选择合适的数值类型和算法优化是关键。使用 `__int128` 或 `long double` 可以有效避免溢出问题，同时通过公式推导简化计算，提高代码效率和可读性。

---
处理用时：29.43秒
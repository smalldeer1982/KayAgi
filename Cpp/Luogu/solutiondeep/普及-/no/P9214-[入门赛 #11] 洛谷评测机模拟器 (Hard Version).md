# 题目信息

# [入门赛 #11] 洛谷评测机模拟器 (Hard Version)

## 题目背景

**本题与 Easy Version 题意完全相同，不同的地方在于数据范围。**

现在假装你是洛谷评测机。这一天，洛谷同时进行了 PION 自测、SCP 自测、ION 自测等等比赛。成千上万的评测落到了你的身上！

## 题目描述

现在已经知道你有 $n$ 个相同性能的评测节点，它们被分别标号为 $1, 2, \cdots, n$。一个评测节点在同一时间只能处理一个评测任务。

在某一时刻，$m$ 个评测任务同时涌入了你。我们将这些任务分别标号为 $1, 2, \cdots, m$。这些评测任务需要的评测时间分别为 $t _ 1 , t _ 2, \cdots, t _ m$。每个评测任务**需要且仅需要一个**评测节点来运行，因此你会按照如下方式按照 $1 \sim m$ 的顺序依次将这些评测任务分配到评测节点上：

对于某个耗时 $t _ i$ 的评测任务，你需要找到目前**累积评测时间**最小的评测节点将任务放入。如果有多个评测节点**累积评测时间**相同且最小，则找一个**标号最小**的节点将任务放入。

> 「累积评测时间」定义：假设对于某个评测节点，其被分配了 $a _ 1, a _ 2, \cdots, a _ k$ 共 $k$ 个任务。那么这个评测节点的「累积评测时间」就是 $t _ {a _ 1} + t _ {a _ 2} + \cdots + t _ {a _ k}$。显然的，如果某个评测节点从未被分配过这 $m$ 个任务中的任何一个，那么这个评测节点的「累积评测时间」是 $0$。

现在，你需要统计出，你的这 $n$ 个评测节点分别接受了哪一些评测任务。

## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 5 \times 10 ^ 5$，$0 \leq t _ i \leq 10 ^ 9$。

## 样例 #1

### 输入

```
5 10
13 50 90 38 60 64 60 77 6 24```

### 输出

```
1 6
2 8
3
4 7
5 9 10```

## 样例 #2

### 输入

```
12 7
85 99 82 90 14 11 15```

### 输出

```
1
2
3
4
5
6
7
0
0
0
0
0```

# AI分析结果

### 算法分类
队列

### 综合分析与结论
本题的核心逻辑是通过优先队列（小根堆）来动态选择当前累积评测时间最小的评测节点，并将任务分配给它。所有题解都采用了优先队列来实现这一逻辑，主要区别在于实现细节和代码风格。以下是评分较高的题解及其亮点。

### 所选题解

#### 1. 作者：2021sunzishan (赞：8)
- **星级**: 5
- **关键亮点**: 
  - 详细解释了优先队列的使用方法，适合新手理解。
  - 代码结构清晰，注释详细，易于阅读。
  - 使用了结构体和重载运算符来实现小根堆，代码简洁高效。
- **个人心得**: 无

**核心代码片段**:
```cpp
struct node{
    long long s;//总用时
    int op;//节点编号
    bool operator >(const node &k)const{
        if(s!=k.s)return s>k.s;
        else return op>k.op;
    }
};
priority_queue<node,vector<node>,greater<node> >q;//小根堆
```

#### 2. 作者：dyyzy (赞：6)
- **星级**: 4
- **关键亮点**: 
  - 提供了多种实现小根堆的方法，包括使用STL小根堆、结构体重载小于号和取相反数的方法。
  - 代码实现灵活，展示了不同的编程技巧。
- **个人心得**: 无

**核心代码片段**:
```cpp
priority_queue<pair<long long,int> > pq;//不开long long见祖宗
vector<int> e[N];//必须使用vector，否则空间复杂度达到O(nm)，会MLE
```

#### 3. 作者：zzx114514 (赞：5)
- **星级**: 4
- **关键亮点**: 
  - 代码简洁，直接使用优先队列和结构体实现小根堆。
  - 强调了数据范围，提醒开long long，避免溢出问题。
- **个人心得**: 无

**核心代码片段**:
```cpp
struct Node{
    long long id,time;
    bool operator>(const Node &a) const{
        if (time==a.time) return id>a.id;
        return time>a.time;
    }
};
priority_queue<Node,vector<Node>,greater<Node> > node;//建立一个小根堆存放节点
```

### 最优关键思路或技巧
1. **优先队列的使用**: 通过优先队列（小根堆）动态选择当前累积评测时间最小的节点，确保每次任务分配的高效性。
2. **结构体与重载运算符**: 使用结构体和重载运算符来实现小根堆，代码简洁且易于维护。
3. **数据范围处理**: 注意数据范围，使用long long避免溢出问题。

### 可拓展之处
类似的任务分配问题可以使用优先队列来解决，例如任务调度、资源分配等场景。优先队列在处理动态最值问题时非常高效，适用于多种算法竞赛题目。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378)

---
处理用时：23.68秒
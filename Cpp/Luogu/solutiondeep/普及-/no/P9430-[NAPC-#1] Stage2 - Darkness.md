# 题目信息

# [NAPC-#1] Stage2 - Darkness

## 题目背景

> ![](https://cdn.luogu.com.cn/upload/image_hosting/y68eurqf.png)

## 题目描述

有 $n$ 支军队分布在各地，可以看作在一个平面直角坐标系内。他们都受 kid 的统一指挥，kid 共发出 $m$ 条命令。

命令有如下几种：

- `1 p q` 表示把**每支**军队的位置从 $(x_i,y_i)$ 移到 $(x_i+p,y_i+q)$。
- `2 i`，表示**第 $i$ 支军队**的位置对直线 $y=x$ 作轴对称变换（即交换 $x_i$ 与 $y_i$ 的值）。
- `3 i`，表示查询第 $i$ 支军队现在所处的位置（即输出此时的 $x_i$ 与 $y_i$）。

**请注意 `1` 与 `2` 命令的操作对象不同，前者为全体军队，后者为单支军队。**

本来 kid 可以直接拿望远镜看的，但是天太黑了，只能拜托你编写一个程序告诉他了。

## 说明/提示

### 【数据范围】
该题共有 $10$ 个测试点，每个测试点等分。

- 对于 $20\%$ 的数据，$n,m\leqslant 1000$。
- 对于另外 $30\%$ 的数据，保证没有 `2` 命令。

对于 $100\%$ 的数据，$1\leqslant n\leqslant 10^5$，$1\leqslant m\leqslant 5\times10^5$，$|a_i|,|b_i|,|p|,|q|\leqslant 10^3$，$1\leqslant i\leqslant n$，$op\in\{1,2,3\}$。

### 【样例解释】
| 时间 | $(x_1,y_1)$ | $(x_2,y_2)$ | $(x_3,y_3)$ |
|  :-:  |  :-:  |  :-:  |  :-:  |
| 初始时 | $(1,2)$ | $(2,5)$ | $(6,2)$ |
| 第 $2$ 次命令后 | $(2,6)$ | $(3,9)$ | $(7,6)$ |
| 第 $4$ 次命令后 | $(2,6)$ | $(3,9)$ | $(6,7)$ |
| 第 $6$ 次命令后 | $(-7,5)$ | $(-6,8)$ | $(-3,6)$ |

## 样例 #1

### 输入

```
3 7
1 2
2 5
6 2
3 2
1 1 4
3 3
2 3
3 1
1 -9 -1
3 3```

### 输出

```
2 5
7 6
2 6
-3 6```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
该题目主要考察对大规模数据的处理能力，尤其是对多种操作的快速响应。核心难点在于如何高效处理全局和单点的操作，避免直接遍历所有军队导致的超时问题。大多数题解通过引入全局变量来记录偏移量，从而将全局操作的时间复杂度从O(n)降低到O(1)，同时通过巧妙的数学变换来处理单点操作。

### 所选高分题解
1. **作者：Peaceful_Evening (4星)**
   - **关键亮点**：通过引入全局变量`k`和`g`来记录全局偏移量，简化了全局移动操作的处理。对于单点操作，通过先还原再交换的方式，确保了数据的正确性。
   - **代码核心**：
     ```cpp
     int k,g;
     if(op==1){
         int x,y;
         cin>>x>>y;
         k+=x,g+=y;
     }
     if(op==2){
         int p;
         cin>>p;
         int t=a[p]+k,s=b[p]+g;
         swap(t,s);
         a[p]=t-k,b[p]=s-g;
     }
     if(op==3){
         int q;
         cin>>q;
         cout<<a[q]+k<<" "<<b[q]+g<<endl;
     }
     ```

2. **作者：STARSczy (4星)**
   - **关键亮点**：提供了两种解法，一种是普通思路，另一种是线段树。普通思路通过维护全局变量`addx`和`addy`，实现了高效的全局和单点操作。线段树解法虽然代码较长，但展示了如何通过数据结构来处理复杂操作。
   - **代码核心**：
     ```cpp
     int addx,addy;
     if(op==1){
         int p,q;
         cin>>p>>q;
         addx+=p,addy+=q;
     }
     if(op==2){
         int k;
         cin>>k;
         a[k]+=addx,b[k]+=addy;
         swap(a[k],b[k]);
         a[k]-=addx,b[k]-=addy;
     }
     if(op==3){
         int k;
         cin>>k;
         cout<<a[k]+addx<<" "<<b[k]+addy<<endl;
     }
     ```

3. **作者：wangbinfeng (4星)**
   - **关键亮点**：通过引入类来封装军队的坐标操作，代码结构清晰，易于理解。全局偏移量的处理方式简洁高效，单点操作通过类方法实现，代码可读性强。
   - **代码核心**：
     ```cpp
     class NODE{
     public:
         int x,y;
         void swap(){
             int t=x+mx-my;
             x=y+my-mx;
             y=t;
         }
         void print(){cout<<x+mx<<" "<<y+my<<endl;}
     }node[100009];
     ```

### 最优关键思路或技巧
- **全局偏移量**：通过引入全局变量来记录所有军队的偏移量，将全局操作的时间复杂度从O(n)降低到O(1)。
- **单点操作的还原与交换**：对于单点操作，先还原实际坐标，再进行交换，最后减去偏移量，确保数据的正确性。
- **类封装**：通过类来封装军队的坐标操作，提高代码的可读性和可维护性。

### 可拓展之处
- **类似题目**：可以扩展到其他需要处理大规模数据且包含多种操作的题目，如大规模矩阵操作、图论中的全局和单点操作等。
- **数据结构**：可以进一步探讨如何通过线段树、树状数组等数据结构来处理更复杂的操作。

### 推荐相似题目
1. [P2129 L 国的战斗续之多路出击](https://www.luogu.com.cn/problem/P2129)
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得摘录
- **Peaceful_Evening**：第一次写题解，经验不足，欢迎留言。
- **STARSczy**：以前一篇主题库的题解都没写过，来陶冶一下我的情操。
- **wangbinfeng**：快读模板可以加速读入数据，代码结构清晰，易于理解。

---
处理用时：29.15秒
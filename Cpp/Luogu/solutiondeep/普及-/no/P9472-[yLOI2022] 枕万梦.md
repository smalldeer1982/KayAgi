# 题目信息

# [yLOI2022] 枕万梦

## 题目背景

> 岁月冥冥之中 星移物换 将韶华歌颂  
> 人潮冥冥之中 一眼望穿 日月去无踪  
> 你我冥冥之中 心有灵犀 何止几万梦  
> 忘情在这久违的重逢  
> 天地冥冥之中 云烟奔涌 摩肩又接踵  
> 万籁冥冥之中 不肯缄默 盛大到无穷  
> 你我冥冥之中 对坐天涯 灵犀才一动  
> 就相遇在咫尺的时空

银临《枕万梦》

## 题目描述

天亮了，扶苏不敌困意，早早地进入了梦乡。在失去引力的梦里，扶苏遇到了好多串漂浮着的数列，它们的长度都相等，而且都是美妙的等比数列！出于本能，扶苏想要把这些数列按照字典序排序，可是在梦里扶苏失去了思考的能力，请你来帮帮她！

具体地，有 $n$ 个编号从 $1$ 到 $n$ 的数列 $a_1, a_2, \dots a_n$，每个数列的长度均为 $m + 1$。第 $i$ 个数列 $a_i$ 满足递推式 $a_{i,j} = a_{i,j - 1} \times i$，其中 $1 \leq j \leq m$。而扶苏会告诉你每个序列的首项 $a_{i,0}$，你需要帮助她把这些数列按字典序排序。

## 说明/提示

### 样例 1 解释

共有两个数列，每个数列的长度均为 $2+1=3$。

对第一个数列 $a_1$：
- 已知其首项 $a_{1,0} = 1$。
- 根据 $a_{i,j} = a_{i,j - 1} \times i$，取 $i=1,j = 1$ 可以得到 $a_{1,1} = a_{1,0} \times 1 = 1$。
- 根据 $a_{i,j} = a_{i,j - 1} \times i$，取 $i=1,j = 2$ 可以得到 $a_{1,2} = a_{1,1} \times 1= 1$。

所以数列 $a_1$ 是 $1,1,1$。

对第二个数列 $a_2$：
- 已知其首项 $a_{2,0} = 2$。
- 根据 $a_{i,j} = a_{i,j - 1} \times i$，取 $i=2,j = 1$ 可以得到 $a_{2,1} = a_{2,0} \times 2 = 2 \times 2 = 4$。
- 根据 $a_{i,j} = a_{i,j - 1} \times i$，取 $i=2,j = 2$ 可以得到 $a_{2,2} = a_{2,1} \times 2= 4 \times 2 = 8$。

所以数列 $a_2$ 是 $2,4,8$。

比较字典序可得数列 $a_1$ 是字典序最小的数列。所以输出 $1$。

### 样例 2 解释

数列 $a_1$ 为 $1,1,1,1$，数列 $a_2$ 为 $-1, -2,-4,-8$。

### 数据规模与约定
本题共 $10$ 个测试点，各测试点信息如下表：

![](https://cdn.luogu.com.cn/upload/image_hosting/08wnuome.png)

特殊约定 A：保证 $a_{i,0}$ 均相等。  
特殊约定 B：保证 $a_{i,0}$ 互不相等。

对全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 10^9$，$1 \leq |a_{i,0}| \leq 10^9$。


### 提示

对两个数列 $a_i, a_j$，按如下方式比较其字典序：

找到**最小的**满足 $a_{i,p} \neq a_{j, p}$ 的下标 $p$，比较 $a_{i, p}$ 和 $a_{j, p}$ 的大小：

- 如果 $a_{i,p} < a_{j, p}$，则称 $a_i$ 的字典序比 $a_j$ 的小。
- 如果 $a_{i,p} > a_{j, p}$，则称 $a_i$ 的字典序比 $a_j$ 的大。

可以证明，在本题的限制下，这样的 $p$ 一定存在。

## 样例 #1

### 输入

```
2 2
1
2```

### 输出

```
1 2```

## 样例 #2

### 输入

```
2 3
1
-1```

### 输出

```
2 1```

## 样例 #3

### 输入

```
2 2
1
1```

### 输出

```
1 2```

## 样例 #4

### 输入

```
见附加文件中的 B4.in```

### 输出

```
见附加文件中的 B4.ans```

# AI分析结果

### 算法分类
排序

### 综合分析与结论
本题的核心是将多个等比数列按字典序排序。由于每个数列的首项和第二项可以唯一确定其字典序，因此只需比较首项和第二项即可完成排序。大多数题解都采用了结构体存储数列的首项和第二项，并通过自定义比较函数进行排序。关键在于如何处理首项相同的情况，尤其是当首项为负数时，第二项的大小与数列编号的关系需要特别注意。

### 所选题解
1. **作者：cff_0102 (5星)**
   - **关键亮点**：思路清晰，代码简洁，明确指出了需要开 `long long` 以避免溢出问题。
   - **个人心得**：作者提到在比赛中因为没开 `long long` 导致分数下降，提醒了读者注意数据范围。
   - **核心代码**：
     ```cpp
     struct arr{
         long long a0;//第 0 项
         long long a1;//第 1 项 
         long long n;//编号 / 公比
     }a[114514];
     bool cmp(arr x,arr y){
         if(x.a0!=y.a0)return x.a0<y.a0;
         else return x.a1<y.a1;
     }
     ```

2. **作者：1qaz234Q (4星)**
   - **关键亮点**：详细分析了题目，明确指出只需比较前两项，代码结构清晰。
   - **核心代码**：
     ```cpp
     struct node {
         int a1; // 数列的第一个数
         int a2; // 数列的第二个数
         int id; // 数列的编号
     } a[N];
     bool cmp(node x, node y) {
         if (x.a1 == y.a1) return x.a2 < y.a2;
         return x.a1 < y.a1;
     }
     ```

3. **作者：fengyuxuan (4星)**
   - **关键亮点**：详细解释了字典序的比较方式，代码实现简洁明了。
   - **核心代码**：
     ```cpp
     struct node{
         long long a0;
         long long id;
     }a[100005];
     bool cmp(node x,node y) {
         if(x.a0!=y.a0) return x.a0<y.a0;
         else return x.a0*x.id<y.a0*y.id;
     }
     ```

### 最优关键思路或技巧
1. **数据结构**：使用结构体存储数列的首项和第二项，便于排序。
2. **算法优化**：只需计算数列的前两项，无需生成整个数列，大大减少了计算量。
3. **代码实现技巧**：自定义比较函数，处理首项相同的情况，尤其是首项为负数时的特殊情况。

### 可拓展之处
类似的问题可以扩展到其他类型的数列排序，如等差数列、斐波那契数列等。关键在于找到数列的生成规律，并确定排序的关键项。

### 推荐题目
1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
2. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)
3. [P1068 分数线划定](https://www.luogu.com.cn/problem/P1068)

---
处理用时：22.54秒
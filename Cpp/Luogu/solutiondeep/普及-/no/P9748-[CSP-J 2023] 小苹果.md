# 题目信息

# [CSP-J 2023] 小苹果

## 题目描述

小 Y 的桌子上放着 $n$ 个苹果从左到右排成一列，编号为从 $1$ 到 $n$。

小苞是小 Y 的好朋友，每天她都会从中拿走一些苹果。

每天在拿的时候，小苞都是从左侧第 $1$ 个苹果开始、每隔 $2$ 个苹果拿走 $1$ 个苹果。随后小苞会将剩下的苹果按原先的顺序重新排成一列。

小苞想知道，多少天能拿完所有的苹果，而编号为 $n$ 的苹果是在第几天被拿走的？

## 说明/提示

**【样例 $1$ 解释】**

小苞的桌上一共放了 $8$ 个苹果。  
小苞第一天拿走了编号为 $1$、$4$、$7$ 的苹果。  
小苞第二天拿走了编号为 $2$、$6$ 的苹果。  
小苞第三天拿走了编号为 $3$ 的苹果。  
小苞第四天拿走了编号为 $5$ 的苹果。  
小苞第五天拿走了编号为 $8$ 的苹果。  

**【样例 $2$】**

见选手目录下的 apple/apple2.in 与 apple/apple2.ans。

**【数据范围】**

对于所有测试数据有：$1\leq n\leq 10^9$。

| 测试点 | $n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 2$ | $10$ | 无 |
| $3\sim 5$ | $10^3$ | 无 |
| $6\sim 7$ | $10^6$ | 有 |
| $8\sim 9$ | $10^6$ | 无 |
| $10$ | $10^9$ | 无 |

特殊性质：小苞第一天就取走编号为 $n$ 的苹果。

## 样例 #1

### 输入

```
8```

### 输出

```
5 5```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
题目要求计算每天拿走苹果的数量以及最后一个苹果被拿走的天数。核心思路是通过数学推导，发现每天拿走的苹果数量为 $\lceil \frac{n}{3} \rceil$，并且当 $n \bmod 3 = 1$ 时，最后一个苹果会在当天被拿走。大多数题解都采用了这一思路，通过模拟每天拿苹果的过程来计算结果。时间复杂度为 $O(\log n)$，能够高效处理 $n \leq 10^9$ 的数据范围。

### 所选高星题解

#### 1. 作者：2huk (赞：218)
- **星级**: 5星
- **关键亮点**: 思路清晰，代码简洁，时间复杂度分析详细，解释了为什么时间复杂度为 $O(\log n)$。
- **个人心得**: 作者提到“考虑计算时间复杂度。每次将 $n$ 减去 $\lceil \frac{n}{3} \rceil$，也就大约是 $n \gets \frac{2}{3}n$。不妨将其大约看作 $n \gets \frac{1}{2}n$，也就是每次将 $n$ 缩小一半。因此这样计算的话时间复杂度为 $\Theta(\log_2 n)$。实际运行时会偏高。”

```cpp
#include <iostream>
#include <cmath> 

using namespace std;

int n, res1, res2;

int main()
{
    cin >> n;
    
    for (int i = 1; ; ++ i )
    {
        if (n == 0) break;
        if (!res2 && n % 3 == 1) res2 = i;		// 只有在第一次 n % 3 == 1 时记录答案 
        n -= ceil(n / 3.0);
        ++ res1;
    }
    
    cout << res1 << ' ' << res2 << '\n';
    
    return 0;	
}
```

#### 2. 作者：Clarinet (赞：148)
- **星级**: 4星
- **关键亮点**: 代码简洁，思路清晰，直接模拟每天拿苹果的过程，时间复杂度分析合理。
- **个人心得**: 作者提到“考场上我甚至在纠结斐波那契数列的做法，想的太复杂了，因此没打出正解。”

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,k;
int main(){
    cin>>n;
    while(n){
        ans++;
        if(k==0&&n%3==1)k=ans;
        if(n%3==0)n-=n/3;
        else n-=n/3+1;
    }
    cout<<ans<<" "<<k;
    return 0;
}
```

#### 3. 作者：WsW_ (赞：45)
- **星级**: 4星
- **关键亮点**: 思路清晰，代码简洁，直接模拟每天拿苹果的过程，时间复杂度分析合理。
- **个人心得**: 无

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x;
int ans,cnt;
int main(){
    scanf("%d",&n);
    x=n;
    while(x){
        cnt++;
        x-=(x+2)/3;
    }
    printf("%d ",cnt);
    while(1){
        ans++;
        if(n%3==1)break;
        n-=(n+2)/3;
    }
    printf("%d",ans);
    return 0;
}
```

### 最优关键思路或技巧
- **数学推导**: 通过数学推导发现每天拿走的苹果数量为 $\lceil \frac{n}{3} \rceil$，并且当 $n \bmod 3 = 1$ 时，最后一个苹果会在当天被拿走。
- **模拟过程**: 通过模拟每天拿苹果的过程来计算结果，时间复杂度为 $O(\log n)$。

### 可拓展之处
- **类似问题**: 类似的问题可以考察如何通过数学推导和模拟过程来解决其他类型的序列操作问题，如每隔 $k$ 个元素删除一个元素等。

### 推荐题目
1. [P1008 三连击](https://www.luogu.com.cn/problem/P1008)
2. [P1010 幂次方](https://www.luogu.com.cn/problem/P1010)
3. [P1011 车站](https://www.luogu.com.cn/problem/P1011)

---
处理用时：29.01秒
# 题目信息

# [CSP-J 2023] 公路

## 题目描述

小苞准备开着车沿着公路自驾。

公路上一共有 $n$ 个站点，编号为从 $1$ 到 $n$。其中站点 $i$ 与站点 $i + 1$ 的距离为 $v_i$ 公里。

公路上每个站点都可以加油，编号为 $i$ 的站点一升油的价格为 $a_i$ 元，且每个站点只出售整数升的油。

小苞想从站点 $1$ 开车到站点 $n$，一开始小苞在站点 $1$ 且车的油箱是空的。已知车的油箱足够大，可以装下任意多的油，且每升油可以让车前进 $d$ 公里。问小苞从站点 $1$ 开到站点 $n$，至少要花多少钱加油？

## 说明/提示

**【样例 1 解释】**

最优方案下：小苞在站点 $1$ 买了 $3$ 升油，在站点 $2$ 购买了 $5$ 升油，在站点 $4$ 购买了 $2$ 升油。

**【样例 2】**

见选手目录下的 road/road2.in 与 road/road2.ans。

**【数据范围】**

对于所有测试数据保证：$1 \leq n \leq 10^5$，$1 \leq d \leq 10^5$，$1 \leq v_i \leq 10^5$，$1 \leq a_i \leq 10^5$。

| 测试点 | $n \leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 5$ | $8$ | 无 |
| $6\sim 10$ | $10^3$ | 无 |
| $11\sim 13$ | $10^5$ | A |
| $14\sim 16$ | $10^5$ | B |
| $17\sim 20$ | $10^5$ | 无 |

- 特殊性质 A：站点 $1$ 的油价最低。
- 特殊性质 B：对于所有 $1 \leq i < n$，$v_i$ 为 $d$ 的倍数。

## 样例 #1

### 输入

```
5 4
10 10 10 10
9 8 9 6 5```

### 输出

```
79```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
本题的核心在于通过贪心策略选择最便宜的加油站进行加油，从而最小化总花费。所有题解均采用了贪心算法，但实现细节和优化程度有所不同。主要思路是维护一个当前最便宜的加油站，并在需要加油时从该站点购买油量。难点在于如何处理油的剩余量以及如何高效地找到下一个更便宜的加油站。

### 所选题解

#### 题解1：作者：yhx0322 (赞：152)
- **星级**：5星
- **关键亮点**：使用反悔贪心思想，维护当前最便宜的加油站，并在需要加油时从该站点购买油量。代码简洁高效，时间复杂度为O(n)。
- **个人心得**：注意本题的数据范围大，需要开 `long long`。

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
const int N = 1e5 + 10;
int v[N], a[N];
int n, d;
int main() {
    scanf("%d%d", &n, &d);
    for (int i = 1; i < n; i++) scanf("%d", &v[i]);
    int mi = INT_MAX;
    LL ans = 0, s = 0;
    for (int i = 1; i < n; i++) {
        scanf("%d", &a[i]);
        s += v[i];
        mi = min(mi, a[i]);
        if (s > 0) {
            ans += (s + d - 1) / d * mi;
            s -= (s + d - 1) / d * d;
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

#### 题解2：作者：SJZ2010 (赞：44)
- **星级**：4星
- **关键亮点**：通过链表的方式存储下一个更便宜的加油站，优化了查找过程。代码清晰，逻辑严密。
- **个人心得**：不开 `long long` 见祖宗。

```cpp
#include <cstdio>
typedef long long ll;
const int N = 1e5 + 5;
ll n, d;
ll dis[N], money[N], nxt[N], dis_sum[N], can_dis, ans;
int main() {
    scanf("%lld %lld", &n, &d);
    for (int i = 1; i < n; i++) scanf("%lld", &dis[i]);
    for (int i = 2; i <= n; i++) dis_sum[i] = dis_sum[i - 1] + dis[i - 1];
    for (int i = 1; i <= n; i++) scanf("%lld", &money[i]);
    int last_m = money[1], last_i = 1;
    for (int i = 2; i <= n - 1; i++) {
        if (money[i] < last_m) {
            nxt[last_i] = i;
            last_i = i;
            last_m = money[i];
        }
    }
    nxt[last_i] = n;
    for (int i = 1; i < n;) {
        ll dist = dis_sum[nxt[i]] - dis_sum[i];
        ans += (dist - can_dis + d - 1) / d * money[i];
        can_dis += (dist - can_dis + d - 1) / d * d;
        can_dis -= dist;
        i = nxt[i];
    }
    printf("%lld\n", ans);
    return 0;
}
```

#### 题解3：作者：Wi_Fi (赞：35)
- **星级**：4星
- **关键亮点**：通过维护当前最便宜的加油站，并在需要加油时从该站点购买油量。代码简洁，逻辑清晰。
- **个人心得**：注意处理一下多加油的问题。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
long long i,n,d,a[N],v[N],sum[N],mi,k,ans,mo;
int main() {
    cin>>n>>d;
    for(i=1;i<n;i++)cin>>v[i];
    for(i=1;i<=n;i++)cin>>a[i];
    mi=a[1],k=1;
    for(i=1;i<n;i++) {
        if(a[i]>=mi)sum[k]+=v[i];
        else {
            k=i,mi=a[i],sum[i]+=v[i];
        }
    }
    for(i=1;i<=n;i++) {
        ans+=ceil(sum[i]*1.0/d)*a[i];
        mo+=ceil(sum[i]*1.0/d)*d-sum[i];
        if(mo>=d)mo-=d,ans-=a[i];
    }
    cout<<ans;
    return 0;
}
```

### 最优关键思路或技巧
1. **贪心策略**：始终从当前最便宜的加油站购买油量，确保每次加油的花费最小。
2. **油量剩余处理**：通过计算剩余油量，避免重复购买油量，优化总花费。
3. **高效查找**：通过维护当前最便宜的加油站，减少查找下一个更便宜加油站的时间复杂度。

### 可拓展之处
类似的问题可以通过贪心策略解决，例如在多个选择中每次选择最优的局部解，最终得到全局最优解。可以拓展到其他资源分配问题，如任务调度、背包问题等。

### 推荐题目
1. [P1007 独木桥](https://www.luogu.com.cn/problem/P1007)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

### 个人心得总结
- **调试经历**：在处理油量剩余时，需要注意向上取整的计算方式，避免出现负数或多余的油量。
- **踩坑教训**：数据范围较大时，务必使用 `long long` 类型，避免溢出。
- **顿悟感想**：贪心算法的关键在于每次选择局部最优解，最终得到全局最优解。

---
处理用时：43.86秒
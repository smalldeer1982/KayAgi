# 题目信息

# [CSP-S 2023] 密码锁

## 题目描述

小 Y 有一把五个拨圈的密码锁。如图所示，每个拨圈上是从 $0$ 到 $9$ 的数字。每个拨圈都是从 $0$ 到 $9$ 的循环，即 $9$ 拨动一个位置后可以变成 $0$ 或 $8$，

![](https://cdn.luogu.com.cn/upload/image_hosting/aku4duog.png)

因为校园里比较安全，小 Y 采用的锁车方式是：从正确密码开始，随机转动密码锁仅一次；每次都是以某个幅度仅转动一个拨圈或者同时转动两个相邻的拨圈。

当小 Y 选择同时转动两个相邻拨圈时，两个拨圈转动的幅度相同，即小 Y 可以将密码锁从 $\tt{0\;0\;1\;1\;5}$ 转成 $\tt{1\;1\;1\;1\;5}$，但不会转成 $\tt{1\;2\;1\;1\;5}$。

时间久了，小 Y 也担心这么锁车的安全性，所以小 Y 记下了自己锁车后密码锁的 $n$ 个状态，注意这 $n$ 个状态都不是正确密码。

为了检验这么锁车的安全性，小 Y 有多少种可能的正确密码，使得每个正确密码都能够按照他所采用的锁车方式产生锁车后密码锁的全部 $n$ 个状态。

## 说明/提示

**【样例 1 解释】**

一共有 $81$ 种可能的方案。

其中转动一个拨圈的方案有 $45$ 种，转动两个拨圈的方案有 $36$ 种。

**【样例 2】**

见选手目录下的 lock/lock2.in 与 lock/lock2.ans。

**【数据范围】**

对于所有测试数据有：$1 \leq n \leq 8$。

| 测试点 | $n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 3$ | $1$ | 无 |
| $4\sim 5$ | $2$ | 无 |
| $6\sim 8$ | $8$ | A |
| $9\sim 10$ | $8$ | 无 |

特殊性质 A：保证所有正确密码都可以通过仅转动一个拨圈得到测试数据给出的 $n$ 个状态。

## 样例 #1

### 输入

```
1
0 0 1 1 5```

### 输出

```
81```

# AI分析结果

### 算法分类
枚举

### 综合分析与结论
题目要求通过枚举所有可能的密码状态，判断其是否能够通过一次转动（单个拨圈或相邻两个拨圈）得到给定的所有错误状态。由于密码锁的状态空间较小（5位，每位0-9），且n的范围较小（1≤n≤8），因此暴力枚举是可行的。

### 所选高星题解
1. **作者：Not_defined (赞：128)**
   - **星级：4星**
   - **关键亮点**：通过五维数组记录每个密码状态的出现次数，最后统计满足条件的密码数量。代码简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     for(int j=1;j<=9;j++) {
         dp[(a+j)%mod][b][c][d][e]++;
         dp[a][(b+j)%mod][c][d][e]++;
         dp[a][b][(c+j)%mod][d][e]++;
         dp[a][b][c][(d+j)%mod][e]++;
         dp[a][b][c][d][(e+j)%mod]++;
         dp[(a+j)%mod][(b+j)%mod][c][d][e]++;
         dp[a][(b+j)%mod][(c+j)%mod][d][e]++;
         dp[a][b][(c+j)%mod][(d+j)%mod][e]++;
         dp[a][b][c][(d+j)%mod][(e+j)%mod]++;
     }
     ```

2. **作者：XKqwq (赞：33)**
   - **星级：4星**
   - **关键亮点**：使用五维数组记录每个密码状态的出现次数，最后统计满足条件的密码数量。代码简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     forr(j,0,9) s[j][b][c][d][e] ++ ;
     forr(j,0,9) s[a][j][c][d][e] ++ ;
     forr(j,0,9) s[a][b][j][d][e] ++ ;
     forr(j,0,9) s[a][b][c][j][e] ++ ;
     forr(j,0,9) s[a][b][c][d][j] ++ ;
     forr(j,1,9) s[(a+j)%10][(b+j)%10][c][d][e] ++ ;
     forr(j,1,9) s[a][(b+j)%10][(c+j)%10][d][e] ++ ;
     forr(j,1,9) s[a][b][(c+j)%10][(d+j)%10][e] ++ ;
     forr(j,1,9) s[a][b][c][(d+j)%10][(e+j)%10] ++ ;
     ```

3. **作者：Miyamizu_Mitsuha (赞：4)**
   - **星级：4星**
   - **关键亮点**：通过五维数组记录每个密码状态的出现次数，最后统计满足条件的密码数量。代码简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=9;i++)add[m(a+i)][m(b)][m(c)][m(d)][m(e)]++;
     for(int i=1;i<=9;i++)add[m(a)][m(b+i)][m(c)][m(d)][m(e)]++;
     for(int i=1;i<=9;i++)add[m(a)][m(b)][m(c+i)][m(d)][m(e)]++;
     for(int i=1;i<=9;i++)add[m(a)][m(b)][m(c)][m(d+i)][m(e)]++;
     for(int i=1;i<=9;i++)add[m(a)][m(b)][m(c)][m(d)][m(e+i)]++;
     for(int i=1;i<=9;i++)add[m(a+i)][m(b+i)][m(c)][m(d)][m(e)]++;
     for(int i=1;i<=9;i++)add[m(a)][m(b+i)][m(c+i)][m(d)][m(e)]++;
     for(int i=1;i<=9;i++)add[m(a)][m(b)][m(c+i)][m(d+i)][m(e)]++;
     for(int i=1;i<=9;i++)add[m(a)][m(b)][m(c)][m(d+i)][m(e+i)]++;
     ```

### 最优关键思路或技巧
1. **五维数组记录状态**：通过五维数组记录每个密码状态的出现次数，最后统计满足条件的密码数量。
2. **枚举所有可能的转动**：通过枚举所有可能的转动（单个拨圈或相邻两个拨圈），记录每个密码状态的出现次数。

### 可拓展之处
类似的问题可以通过枚举所有可能的状态，并结合特定的条件进行筛选。例如，在密码锁问题中，通过枚举所有可能的密码状态，并结合转动规则进行筛选。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

---
处理用时：45.31秒
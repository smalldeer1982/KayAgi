# 题目信息

# [HUSTFC 2023] 排列排序问题

## 题目描述

JokerShaco 有一个长度为 $n$ 的排列 $p$，他认为一个排列必须是有序的，所以他打算将其进行排序。

他可以对这个排列进行如下操作：
- 将这个排列切割成若干个序列（也可以不切割，保持原样），每个序列至少含有一个元素；
- 选择其中一些序列并将它们翻转；
- 将这些序列按照他的意愿重新组合拼接得到一个新的排列。

JokerShaco 认为切割操作非常累，他想知道如果必须把这个排列变得有序，至少需要切割多少次。

一个长度为 $n$ 的排列的定义为，包含从 $1$ 到 $n$ 这 $n$ 个不同的整数的序列，每个整数恰好出现一次。

序列翻转的定义为，假设存在一个长度为 $m$ 的序列 $[a_1,a_2,\dots,a_{m-1},a_m]$，那么将这个序列翻转后将会得到 $[a_m,a_{m-1},\dots,a_2,a_1]$。

## 样例 #1

### 输入

```
5
1 2 3 5 4
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3
3 2 1
```

### 输出

```
0
```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
本题的核心逻辑是通过模拟操作来确定最少需要多少次切割才能使排列有序。各题解的思路基本一致，都是通过遍历数组，判断相邻元素的差值是否为1，来确定是否需要切割。主要区别在于代码的实现方式和细节处理。

### 所选题解
1. **作者：_O_v_O_ (赞：6)**
   - **星级：5星**
   - **关键亮点：思路清晰，代码简洁，直接通过判断相邻元素的差值是否为1来确定切割次数。**
   - **代码实现：**
     ```cpp
     #include<bits/stdc++.h>
     using namespace std;

     int n,a[1000005],ans;

     signed main(){
         ios::sync_with_stdio(0);
         cin.tie(nullptr);
         cin>>n;
         for(int i=1;i<=n;i++){
             cin>>a[i];
             if(i==1) continue;
             if(abs(a[i]-a[i-1])!=1) ans++;
         }
         cout<<ans;
         return 0;
     }
     ```

2. **作者：linyukun (赞：0)**
   - **星级：4星**
   - **关键亮点：详细解析了题目操作，强调了连续数字串的有序性，代码简洁明了。**
   - **代码实现：**
     ```cpp
     #include<bits/stdc++.h>
     using namespace std;
     int n,a[1000005],b,cnt;
     int main(){
         cin>>n;
         for(int i=1;i<=n;i++){
             cin>>a[i];
         }
         for(int i=2;i<=n;i++){
             if(abs(a[i]-a[i-1])>1){
                 cnt++;
             }
         }
         cout<<cnt;
         return 0;
     }
     ```

3. **作者：tder (赞：0)**
   - **星级：4星**
   - **关键亮点：通过遍历数组找到递增或递减的连续数列，处理了单独成块的情况，代码逻辑清晰。**
   - **代码实现：**
     ```cpp
     #include <bits/stdc++.h>
     using namespace std;
     #define int long long
     const int N = 1e6 + 5;
     int n, p[N], cnt;
     signed main() {
         ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
         cin>>n;
         for(int i = 1; i <= n; i++) cin>>p[i];
         for(int i = 1; i <= n; i++, cnt++)
             if(p[i] + 1 == p[i + 1])
                 while(p[i] + 1 == p[i + 1]) i++;
             else if(p[i] - 1 == p[i + 1])
                 while(p[i] - 1 == p[i + 1]) i++;
         cout<<cnt - 1;
         return 0;
     }
     ```

### 最优关键思路或技巧
- **关键思路：** 通过遍历数组，判断相邻元素的差值是否为1，来确定是否需要切割。连续的数字串可以组成有序的子序列，减少切割次数。
- **技巧：** 使用简单的条件判断和循环结构，避免复杂的逻辑处理，提高代码的可读性和执行效率。

### 可拓展之处
- **同类型题：** 类似的问题可以通过遍历数组，判断相邻元素的关系来确定操作次数。例如，判断数组是否可以通过某些操作变为有序。
- **类似算法套路：** 模拟操作、贪心算法。

### 推荐题目
1. [P1007 独木桥](https://www.luogu.com.cn/problem/P1007)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

---
处理用时：25.96秒
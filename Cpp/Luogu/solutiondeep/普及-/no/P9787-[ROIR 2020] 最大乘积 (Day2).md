# 题目信息

# [ROIR 2020] 最大乘积 (Day2)

## 题目描述

**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T1.** ***[Максимальное произведение](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***，译者ShineEternal

给定一个自然数组成的数组 $[a_1,a_2,\ldots,a_n]$。  
定义一个数组的权值为这个数组中所有数的和。

请把这个数组划分为两个非空数组 $[a_1,a_2,\ldots,a_i]$ 和 $[a_{i+1},a_{i+2},\ldots,a_n]$，使得它们的权值之积尽量大。  
你需要确定能够使得两个数组权值之积最大的 $i$。

## 说明/提示

#### 【样例 1 解释】
如果你选择 $i=1$，则权值之积为 $1 \cdot (2+3) = 5$。
如果你选择 $i=2$，则权值之积为 $(1+2) \cdot 3 = 9$。

#### 【数据范围】
对于 $100\%$ 的数据，$2 \le n \le 2\cdot 10^5, 1 \le a_i \le 10^9$。  
具体数据限制如下表：

|子任务编号|分值|限制|附加限制|
|:-:|:-:|:-:|:-:|
|$1$|$10$|$2 \le n \le 5000$|$\sum a_i \le 10^9$|
|$2$|$10$|$2 \le n \le 5000$|$a_1 = a_2 = \ldots = a_n$|
|$3$|$20$|$2 \le n \le 5000$|$a_i \le 10^9$|
|$4$|$20$|$2 \le n \le 200000$|$\sum a_i \le 10^9$|
|$5$|$20$|$2 \le n \le 200000$|$a_1 = a_2 = \ldots = a_n$|
|$6$|$20$|$2 \le n \le 200000$|$a_i \le 10^9$|

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
2```

# AI分析结果

### 算法分类
前缀和、数学

### 综合分析与结论
该题的核心思路是利用前缀和快速计算数组的任意子数组和，并结合数学中的“和同近积大”原理，找到使两个子数组和之积最大的分割点。所有题解都采用了前缀和的计算方式，并在此基础上通过遍历或二分查找来优化性能。难点在于处理大数运算（如 `__int128` 的使用）以及如何高效地找到最优分割点。

### 所选高星题解
1. **作者：WsW_**
   - **星级：4星**
   - **关键亮点**：利用二分查找优化了分割点的查找过程，代码简洁且效率高。
   - **核心代码**：
     ```cpp
     int x=upper_bound(sum+1,sum+n+1,sum[n]/2)-sum;
     if(sum[x]-sum[n]/2<sum[n]/2-sum[x-1])cout<<x;
     else cout<<x-1;
     ```
   - **实现思想**：通过二分查找找到最接近总和一半的前缀和位置，从而确定最优分割点。

2. **作者：Vct14**
   - **星级：4星**
   - **关键亮点**：清晰地解释了“和同近积大”的原理，代码实现简洁且易于理解。
   - **核心代码**：
     ```cpp
     for(int i=1; i<n; i++) if(abs(a[n]-2*a[i])<=m) m=abs(a[n]-2*a[i]),z=i;
     cout<<z;
     ```
   - **实现思想**：通过遍历所有可能的分割点，找到使两个子数组和之差的绝对值最小的位置。

3. **作者：Jasmine_Aura**
   - **星级：4星**
   - **关键亮点**：使用了 `__int128` 处理大数运算，代码结构清晰且高效。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n-1;i++){
         if(sum[i]*(sum[n]-sum[i])>maxx){
             maxx=sum[i]*(sum[n]-sum[i]);
             id=i;
         }
     }
     ```
   - **实现思想**：通过遍历所有可能的分割点，计算并比较两个子数组和的乘积，找到最大值对应的分割点。

### 最优关键思路或技巧
1. **前缀和**：通过预处理前缀和数组，可以快速计算任意子数组的和，时间复杂度为 \(O(1)\)。
2. **和同近积大**：利用数学原理，当两个数的和为定值时，它们的差越小，乘积越大。
3. **二分查找**：在优化分割点查找时，二分查找可以将时间复杂度从 \(O(n)\) 降低到 \(O(\log n)\)。
4. **大数处理**：使用 `__int128` 或 Python 等支持大数运算的语言，避免溢出问题。

### 可拓展之处
1. **类似题目**：可以扩展到多段分割问题，如将数组分成三段或更多段，使得各段和的乘积最大。
2. **优化思路**：在更复杂的问题中，可以结合动态规划或其他优化算法来进一步优化分割点的查找。

### 推荐题目
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3374 树状数组 1](https://www.luogu.com.cn/problem/P3374)

### 个人心得总结
- **调试经历**：多位作者提到在处理大数运算时遇到了溢出问题，最终通过使用 `__int128` 或 Python 解决。
- **踩坑教训**：在优化分割点查找时，直接遍历可能会导致超时，二分查找是一个有效的优化手段。
- **顿悟感想**：理解“和同近积大”这一数学原理后，问题的解决思路变得更加清晰，代码实现也更加简洁。

---
处理用时：27.94秒
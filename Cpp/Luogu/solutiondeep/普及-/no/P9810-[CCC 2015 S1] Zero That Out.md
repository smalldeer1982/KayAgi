# 题目信息

# [CCC 2015 S1] Zero That Out

## 题目描述

给定 $k$ 个整数 $a_{1 \dots k}$，维护一个序列，按顺序进行以下操作：

- 当 $a_{i} = 0$ 时，将序列中最后加入的数删除。
- 否则，将 $a_{i}$ 加入序列。

例如：当 $a = \{1,3,5,4,0,0,7,0,0,6\}$ 时，操作如下。

|$a_{i}$|序列|
|:--:|:--:|
|$1$|$\{1\}$|
|$3$|$\{1,3\}$|
|$5$|$\{1,3,5\}$|
|$4$|$\{1,3,5,4\}$|
|$0$|$\{1,3,5\}$|
|$0$|$\{1,3\}$|
|$7$|$\{1,3,7\}$|
|$0$|$\{1,3\}$|
|$0$|$\{1\}$|
|$6$|$\{1,6\}$|

你需要计算最终序列中所有数的和。

## 说明/提示

**【数据范围】：**

$1 \leq k \leq 10^{5}$，$0 \leq a_{i} \leq 100$。

保证在 $a_{i} = 0$ 时序列不为空。

## 样例 #1

### 输入

```
4
3
0
4
0```

### 输出

```
0```

## 样例 #2

### 输入

```
10
1
3
5
4
0
0
7
0
0
6```

### 输出

```
7```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
本题的核心逻辑是通过模拟栈的操作来处理输入的整数序列，最终计算栈中所有元素的和。所有题解都采用了栈这一数据结构来实现，思路基本一致，只是在代码实现和优化细节上有所不同。部分题解在求和时采用了动态维护和的方式，进一步优化了时间复杂度。

### 所选题解
1. **作者：BugGod (赞：0)**
   - **星级：4星**
   - **关键亮点：动态维护和，减少最终求和的时间复杂度。**
   - **代码核心思想：在每次入栈和出栈时直接更新和的值，避免最后遍历栈求和。**
   ```cpp
   int k,sum,a;
   stack<int>s;
   int main()
   {
       cin>>k;
       while(k--)
       {
           cin>>a;
           if(a==0)//删除操作
           {
               if(s.size())
               {
                   sum-=s.top();//删除了这个数，对于和来说，就要减去这个数
                   s.pop();
               }
           }
           else
           {
               sum+=a;
               s.push(a);
           }
       }
       cout<<sum;
       return 0;
   }
   ```

2. **作者：jqQt0220 (赞：0)**
   - **星级：4星**
   - **关键亮点：简洁明了，边输入边处理，动态维护和。**
   - **代码核心思想：在输入时直接处理栈操作，并动态更新和的值。**
   ```cpp
   int k,a,as=0;
   stack<int> s;
   int main()
   {
       ___();//这是我写的初始化函数，就是 cin cout 去同步，可以直接忽略，好奇的可以看我煮液里缺省源的链接
       cin>>k;
       while(k--)//执行 k 次
       {
           cin>>a;
           if(a==0)
               as-=s.top(),s.pop();//和减去栈顶并弹栈
           else
               s.push(a),as+=a;//和加上 a 并入栈
       }
       cout<<as<<endl;//AT 养成的输出换行好习惯
       return 0;//完美结束 QwQ
   }
   ```

3. **作者：Jasoncwx (赞：1)**
   - **星级：4星**
   - **关键亮点：使用标准库栈，代码简洁易读。**
   - **代码核心思想：使用标准库的栈数据结构，最后遍历栈求和。**
   ```cpp
   int n,sum=0;
   cin>>n;
   stack<int>s;
   while(n--){
       int t;cin>>t;
       if(!t)s.pop();//出栈
       else s.push(t);//入栈
   }
   while(!s.empty()){//判断栈是否为空
       sum+=s.top();
       s.pop(); 
   }
   cout<<sum;
   ```

### 最优关键思路或技巧
- **动态维护和**：在每次入栈和出栈时直接更新和的值，避免最后遍历栈求和，进一步优化了时间复杂度。
- **使用标准库栈**：利用C++标准库中的`stack`数据结构，简化了代码实现，提高了代码的可读性。

### 可拓展之处
- **同类型题**：类似的问题可以使用栈或队列来解决，如括号匹配、表达式求值等。
- **类似算法套路**：在处理序列操作时，栈和队列是常用的数据结构，尤其是在需要“后进先出”或“先进先出”的场景下。

### 推荐题目
1. [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)
2. [P1739 表达式括号匹配](https://www.luogu.com.cn/problem/P1739)
3. [P1981 表达式求值](https://www.luogu.com.cn/problem/P1981)

---
处理用时：25.53秒
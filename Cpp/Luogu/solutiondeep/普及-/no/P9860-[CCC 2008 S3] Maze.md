# 题目信息

# [CCC 2008 S3] Maze

## 题目描述

In order to make a few dollars, you have decided to become part of a scientific experiment. You are fed lots of pizza, then more pizza and then you are asked to find your way across the city on a scooter powered only by pizza. Of course, the city has lots of intersections, and these intersections are very controlled. Some intersections are forbidden for you to enter; some only let you move north/south as you leave the intersection; others let you move only east/west as you leave the intersection; and the rest let you go in any compass direction (north, south, east or west).

Thankfully your scientific friends have given you a map of the city (on the back of a pizza box), with an arrangement of symbols indicating how you can move around the city. Specifically, there are 4 different symbols on the box:

- The symbol `+` indicates we can move in any direction (north/south/east/west) from this location.

- The symbol `-` indicates we can move only east or west from this location.

- The symbol `|` indicates we can move only north or south from this location.

- The symbol `*` indicates we cannot occupy this location.

Your task is to determine how many intersections you must pass through to move from the northwest corner of the city to the south-east corner of the city.

## 样例 #1

### 输入

```
3
2
2
-|
*+
3
5
+||*+
+++|+
**--+
2
3
+*+
+*+
```

### 输出

```
3
7
-1```

# AI分析结果

### 算法分类
广度优先搜索 BFS

### 综合分析与结论
本题的核心是通过BFS算法在迷宫中寻找从起点到终点的最短路径。迷宫的每个格子有不同的移动限制，需要根据格子的符号来决定下一步的移动方向。BFS算法适合用于解决最短路径问题，因为它逐层扩展，确保第一次到达终点时的路径是最短的。

### 所选题解

#### 题解1：zhuweiqi
- **星级**：4星
- **关键亮点**：
  - 使用BFS算法，逐层扩展，确保最短路径。
  - 对每个格子的移动限制进行分类处理，代码逻辑清晰。
  - 使用队列实现BFS，代码简洁高效。
- **个人心得**：
  - 通过分类讨论格子的符号，确保移动方向的正确性。
  - 初始时将起点的步数设为1，符合题目要求。

```cpp
void bfs(){
	memset(f,-1,sizeof(f));
	f[1][1]=1;
	q.push({1,1});
	while(!q.empty()){
		int x=q.front().first;
		int y=q.front().second;
		q.pop();
		int i,j;
		if(a[x][y]=='|') i=0,j=2;
		if(a[x][y]=='-') i=2,j=4;
		if(a[x][y]=='+') i=0,j=4;
		if(a[x][y]=='*') continue;
		for(;i<j;i++){
			int nx=x+dir[i][0];
			int ny=y+dir[i][1];
			if(bj(nx,ny) && f[nx][ny]==-1){
				f[nx][ny]=f[x][y]+1;
				q.push({nx,ny});
			}
		}
	}
	return;
}
```

#### 题解2：ys_kylin__
- **星级**：4星
- **关键亮点**：
  - 使用手写队列，优化了BFS的实现。
  - 对移动限制的处理简洁明了，代码可读性强。
  - 通过`fl`标记是否找到解，避免多测时直接退出程序。
- **个人心得**：
  - 强调多测时不清空数组会导致错误，提醒注意细节。

```cpp
void bfs() {
	int head=1,tail=1;
	q[head].x=q[head].y=q[head].step=1;
	while(head<=tail) {
		for(int i=0;i<4;i++) {
			if(s[q[head].x][q[head].y]=='|' && (i==1 || i==3)) continue;
			if(s[q[head].x][q[head].y]=='-' && (i==0 || i==2)) continue;
			int nx=q[head].x+dx[i],ny=q[head].y+dy[i];
			if(nx>n || ny>m || nx<1 || ny<1 || vis[nx][ny]==1) continue;
			vis[nx][ny]=1;
			q[++tail].x=nx,q[tail].y=ny,q[tail].step=q[head].step+1;
			if(nx==n && ny==m) {
				printf("%d\n",q[tail].step);
				fl=1;
				goto brk;
			}
		}
		head++;
	}
	brk:;
}
```

### 最优关键思路或技巧
- **BFS逐层扩展**：确保第一次到达终点时的路径是最短的。
- **分类处理移动限制**：根据格子的符号决定下一步的移动方向，确保移动的正确性。
- **多测时清空数组**：避免前一次测试的数据影响当前测试的结果。

### 可拓展之处
- **类似题目**：可以扩展到其他类型的迷宫问题，如带有权重的迷宫、多目标点的迷宫等。
- **算法优化**：可以考虑使用双向BFS或A*算法进一步优化搜索效率。

### 推荐题目
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

---
处理用时：29.12秒
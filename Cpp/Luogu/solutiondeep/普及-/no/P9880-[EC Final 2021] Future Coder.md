# 题目信息

# [EC Final 2021] Future Coder

## 题目描述

共 $T$ 组数据，每组给出一个数 $n$ 和 $n$ 个数 $a_1,a_2,...,a_n$，求有多少个二元组 $(a_i,a_j)$ 满足 $a_ia_j<a_i+a_j$。

## 样例 #1

### 输入

```
2
8
3 -1 4 1 -5 9 2 -6
1
0
```

### 输出

```
19
0
```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
题目要求统计满足 $a_i \times a_j < a_i + a_j$ 的二元组数量。通过数学推导，可以将问题转化为统计满足 $(a_i-1)(a_j-1) < 1$ 的二元组数量。进一步分析发现，满足条件的二元组主要分为以下几种情况：
1. 一个正数和一个负数相乘。
2. 一个数为1，另一个数为正数。
3. 两个数都为1。

各题解的核心思路都是通过统计正数、负数和1的个数，然后根据上述情况计算满足条件的二元组数量。部分题解还考虑了0的情况，但根据题目条件，0的情况并不影响最终结果。

### 所选高星题解
1. **作者：liuyi0905 (4星)**
   - **关键亮点**：通过统计正数、负数和1的个数，直接计算满足条件的二元组数量，代码简洁且高效。
   - **代码核心思想**：
     ```cpp
     cin>>n;
     for(int i=1;i<=n;i++)cin>>x,x>0?z++:f++,v1+=x==1;
     cout<<z*f+v1*(z-v1)+v1*(v1-1)/2<<"\n";
     ```
   - **个人心得**：作者在最初忽略了1的情况，经过调试后修正了公式，体现了调试的重要性。

2. **作者：Dream_poetry (4星)**
   - **关键亮点**：思路清晰，详细解释了如何统计正数、负数和1的个数，并给出了完整的计算公式。
   - **代码核心思想**：
     ```cpp
     for (int i=1;i<=n;i++){
         cin>>op;
         if (op<=0) f++;
         else z++;
         if (op==1) o++;
     }
     cout<<z*f+o*(z-o)+(o*(o-1)/2)<<endl;
     ```

3. **作者：denominator (4星)**
   - **关键亮点**：通过数学推导将问题转化为统计满足 $(a_i-1)(a_j-1) \leq 0$ 的二元组数量，思路新颖且高效。
   - **代码核心思想**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         int x;
         scanf ("%d", &x);
         if (x > 1) a++;
         else if (x < 1) b++;
         else c++;
     }
     printf ("%lld\n", a * b + c * (n - c) + c * (c - 1) / 2);
     ```

### 最优关键思路或技巧
1. **数学推导**：通过将不等式 $a_i \times a_j < a_i + a_j$ 转化为 $(a_i-1)(a_j-1) < 1$，简化了问题的复杂度。
2. **分类统计**：通过统计正数、负数和1的个数，分别计算满足条件的二元组数量，避免了暴力枚举的低效。
3. **调试与修正**：在最初忽略某些特殊情况（如1的情况）后，通过调试修正公式，体现了调试在算法实现中的重要性。

### 可拓展之处
类似的问题可以通过数学推导和分类统计的方法来解决，例如统计满足某种不等式的二元组数量。这类问题通常需要将不等式转化为更易处理的形式，并通过统计特定条件的元素数量来计算结果。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)

---
处理用时：27.13秒
# 题目信息

# [ICPC 2018 Qingdao R] Function and Function

## 题目描述

如果我们定义 $f(0) = 1$，$f(1) = 0$，$f(4) = 1$，$f(8) = 2$，$f(16) = 1$ …… 你知道函数 $f$ 意味着什么吗？

其实，$f(x)$ 计算的是 $x$ 中每个数字所产生的封闭区域的总数。下表显示了每个数字产生的封闭区域数：

![](https://cdn.luogu.com.cn/upload/image_hosting/sdv14tzu.png)

例如，$f(1234) = 0 + 0 + 0 + 1 = 1$，$f(5678) = 0 + 1 + 0 + 2 = 3$。

现在，我们用以下等式定义递归函数 $g$： 

$$\begin{cases} g^0(x) = x \\ g^k(x) = f(g^{k-1}(x)) & \text{if } k \ge 1 \end{cases}$$

例如，$g^2(1234) = f(f(1234)) = f(1) = 0$，$g^2(5678) = f(f(5678)) = f(3) = 0$。

给定两个整数 $x$ 和 $k$，请计算 $g^k(x)$ 的值。

## 样例 #1

### 输入

```
6
123456789 1
888888888 1
888888888 2
888888888 999999999
98640 12345
1000000000 0```

### 输出

```
5
18
2
0
0
1000000000```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
该题的核心逻辑是通过递归函数 `g^k(x)` 计算 `x` 经过 `k` 次 `f(x)` 变换后的结果。`f(x)` 的计算规则是统计 `x` 中每个数字的封闭区域数。由于 `f(x)` 的变换会迅速将 `x` 降到一个较小的范围（通常在 3 次内降到 0 或 1），因此可以通过模拟 `f(x)` 的变换过程，并在 `x` 达到 0 或 1 时利用奇偶性判断最终结果。

### 所选高星题解
1. **题解作者：Bobxing (赞：3)**  
   - **星级：4**  
   - **关键亮点**：通过观察 `f(x)` 的变换规律，发现 `x` 在 3 次内会降到 0 或 1，并在 `x` 达到 0 或 1 时利用 `k` 的奇偶性判断结果。代码简洁且优化了时间复杂度。  
   - **核心代码**：
     ```cpp
     ll g(int k, int x) {
         while(k--) {
             x = f(x);
             if(x == 0) return k % 2;
             if(x == 1) return !(k % 2);
         }
         return x;
     }
     ```
   - **个人心得**：作者提到通过手推发现了 `f(x)` 的循环规律，避免了不必要的递归调用。

2. **题解作者：strcmp (赞：2)**  
   - **星级：4**  
   - **关键亮点**：通过枚举 `f^i(x)` 的值，直到 `x` 达到 0 或 1，然后利用 `(k - i) % 2` 判断最终结果。代码逻辑清晰，优化了时间复杂度。  
   - **核心代码**：
     ```cpp
     ll dfs(ll x, ll k) {
         for(ll i = 1; i <= k; i++) {
             x = F(x);
             if(x == 1 || x == 0) return x ^ (k - i) % 2;
         }
         return x;
     }
     ```
   - **个人心得**：作者提到通过观察 `f(x)` 的收敛速度，优化了递归过程。

3. **题解作者：MicroSun (赞：2)**  
   - **星级：4**  
   - **关键亮点**：在 `x` 达到 0 或 1 时，通过奇偶性特判提前结束递归，避免了不必要的计算。代码简洁且高效。  
   - **核心代码**：
     ```cpp
     int g(int k, int x) {
         if(k == 0) return x;
         while(k--) {
             if(x == 0) return (k + 1) & 1;
             x = f(x);
         }
         return x;
     }
     ```
   - **个人心得**：作者提到通过特判 `x == 0` 的情况，优化了递归过程。

### 最优关键思路或技巧
1. **循环优化**：通过观察 `f(x)` 的变换规律，发现 `x` 在 3 次内会降到 0 或 1，并在 `x` 达到 0 或 1 时利用 `k` 的奇偶性判断结果，避免了不必要的递归调用。
2. **奇偶性判断**：在 `x` 达到 0 或 1 时，利用 `k` 的奇偶性判断最终结果，简化了计算过程。
3. **提前终止**：在 `x` 达到 0 或 1 时，提前终止递归，减少了计算量。

### 可拓展之处
该题的优化思路可以应用于其他类似的递归问题，尤其是当递归函数的值会迅速收敛到一个较小的范围时，可以通过观察循环规律和利用奇偶性判断来优化计算过程。

### 推荐相似题目
1. [P1008 三连击](https://www.luogu.com.cn/problem/P1008) - 考察模拟和枚举技巧。
2. [P1012 拼数](https://www.luogu.com.cn/problem/P1012) - 考察字符串处理和贪心算法。
3. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028) - 考察递推和动态规划。

---
处理用时：31.75秒
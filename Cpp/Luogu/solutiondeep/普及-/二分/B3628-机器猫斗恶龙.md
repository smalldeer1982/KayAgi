# 题目信息

# 机器猫斗恶龙

## 题目描述

机器猫出门斗恶龙了！他需要通过 $n$ 个关卡。

每个关卡要么是与怪物战斗，扣除一定的血量；要么是营地，给机器猫增加一定的血量。

在旅途中，机器猫**任意时刻**的血量不能低于或等于 $0$。问机器猫至少需要多少的初始血量，才能完成任务。

血量为正整数。

## 说明/提示

**样例解释**

第二组样例：机器猫带着 $501$ 点血量出门，两场战斗之后剩下 $1$，恢复到 $1001$，两场战斗之后为 $801$，完成任务。

**数据规模与约定**

对于 $100\%$ 的数据，$n\leq 100000, 1\leq |a_i|\leq 1000$。



## 样例 #1

### 输入

```
3
-100 -200 -300```

### 输出

```
601```

## 样例 #2

### 输入

```
5
-200 -300 1000 -100 -100```

### 输出

```
501```

# AI分析结果



### 综合分析与结论
题目要求确定机器猫最小初始血量，使得其闯关过程中血量始终大于0。关键点在于处理关卡序列时维护血量的动态变化，并找到满足条件的最小初始值。各题解主要围绕二分法和逆向动态规划展开。

---

### 所选题解分析

#### 题解作者：ShanCreeperPro（★★★★★）
**关键亮点**：
1. **二分法的正确应用**：利用初始血量的单调性，将问题转化为二分查找最小值问题。
2. **思路清晰易懂**：通过 `check` 函数验证猜测值的可行性，逻辑简单直观。
3. **时间复杂度合理**：二分法结合线性验证，总复杂度为 $O(n \log S)$，适用于题目数据规模。

**核心实现思想**：
- **二分边界**：左边界为1，右边界为所有关卡扣血总和（确保足够覆盖最坏情况）。
- **验证函数 `check`**：模拟从初始血量开始依次处理每个关卡，若中途血量≤0则失败。

**代码片段**：
```cpp
bool check(int x, vector<int>& a) {
    int hp = x;
    for (int num : a) {
        hp += num;
        if (hp <= 0) return false;
    }
    return true;
}

int main() {
    int left = 1, right = 1e14;
    while (left < right) {
        int mid = (left + right) / 2;
        if (check(mid, a)) right = mid;
        else left = mid + 1;
    }
    cout << left;
}
```

---

### 最优关键思路总结
1. **逆向动态规划**（更优解法）：
   - 从后往前遍历关卡，维护当前所需最小血量 `hp`。
   - 每个关卡处理逻辑：`hp = max(1, hp - a[i])`。
   - 时间复杂度 $O(n)$，空间复杂度 $O(1)$。
   - 核心代码：
     ```cpp
     int calculateMinimumHP(vector<int>& a) {
         int hp = 1;
         for (int i = a.size() - 1; i >= 0; --i) {
             hp = max(1, hp - a[i]);
         }
         return hp;
     }
     ```

---

### 拓展与举一反三
1. **类似算法套路**：
   - **二分答案**：适用于具有单调性的最值问题（如 P2678 跳石头）。
   - **逆向动态规划**：处理依赖后续状态的动态规划（如 LeetCode 174 地下城游戏）。

2. **推荐题目**：
   - [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：经典二分答案问题。
   - [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)：二分答案判断可行性。
   - [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)：二分+贪心验证分段和的最大值。

---
处理用时：117.98秒
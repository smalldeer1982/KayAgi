# 题目信息

# [NICA #1] 序列

## 题目描述

小 A 有一个长度为 $n$ 的序列 $a_1,a_2,\dots a_n$。他希望支持两种操作：

- `1 k`，给序列中的每一个元素加上一个整数 $k$；
- `2`，查询序列中的最大子序列和。

子序列指的是从原序列中去除某些元素（也可以不去除），但不破坏余下元素的相对位置形成的新的序列。例如，对于序列 $\{2,3,4,5,6\}$，那么 $\{2,3,4\},\{2,4,6\}$ 都是它的子序列，而 $\{6,5,4\}$ 不是。子序列可以为空，此时子序列和为 $0$。

## 说明/提示

**【样例解释】**

- 第一次操作求序列中的最大子序列和，则为 $12+2+8=22$；
- 第二次操作让序列中每一个元素加上了 $3$。此时序列变为 $-2,15,-4,5,11$；
- 第三次操作求序列中的最大子序列和，则为 $15+5+11=31$；
- 第四次操作让序列中每一个元素加上了 $4$。此时序列变为 $2,19,0,9,15$；
- 第五次操作求序列中的最大子序列和，则为 $2+19+9+15=45$。

数据保证，$1 \leq n,m \leq 5\times 10^5$，$-5\times 10^5 \leq a_i,k \leq 5\times 10^5$，操作仅为 $1$ 或 $2$ 操作。

## 样例 #1

### 输入

```
5 5
-5 12 -7 2 8
2
1 3
2
1 4
2```

### 输出

```
22
31
45```

# AI分析结果



### 综合分析与结论
各题解核心思路均为：最大子序列和等价于所有非负数之和。通过维护全局增量，利用排序+二分快速定位有效元素，结合预处理的后缀和实现高效查询。时间复杂度稳定在 $O(n \log n + m \log n)$ 的解法最优。

### 高星题解推荐
#### 1. 作者：lrqlrq250（★★★★★）
**关键亮点**  
- 使用标准库 `lower_bound` 简化二分实现，代码简洁易读  
- 预处理后缀和避免重复计算，逻辑清晰  
- 利用排序后的单调性实现高效查询  

**核心代码**  
```cpp
stable_sort(a + 1, a + n + 1);
for (int i=n; i; i--) sum[i] = sum[i+1] + a[i]; // 预处理后缀和

// 查询时二分定位
p = lower_bound(a + 1, a + n + 1, -delta) - a;
ans = sum[p] + (n - p + 1) * delta;
```

#### 2. 作者：_xm_（★★★★☆）
**关键亮点**  
- 采用闭开区间二分写法，避免下标越界问题  
- 显式推导答案公式，数学表达清晰  
- 完整注释解释代码逻辑  

**核心代码**  
```cpp
int BinarySearch() { // 闭开区间二分
    int l = 0, r = n + 1;
    while(l + 1 != r) {
        int mid = (l + r) / 2;
        if(a[mid] + delta <= 0) l = mid;
        else r = mid;
    }
    return r;
}

// 计算答案
ans = sum[n] - sum[x-1] + (n-x+1)*delta;
```

### 最优思路提炼
1. **预处理结构**：排序后维护后缀和数组  
2. **全局增量**：用 `delta` 累积记录所有加法操作  
3. **二分定位**：通过 `lower_bound` 快速找到首个非负元素  
4. **公式计算**：答案 = 后缀和[p] + 增量贡献 `(n-p+1)*delta`

### 拓展建议
类似问题可考虑：
- 维护动态阈值下的统计信息（如区间和、极值）
- 离线处理结合排序性质的优化
- 全局操作与局部查询的结合处理

### 推荐习题
1. [P3372] 线段树模板（区间加/求和）  
2. [P5142] 区间方差（维护动态统计量）  
3. [P6492] 序列操作（带区间修改的极值维护）

### 题解心得摘录
- **边界处理**：多题解强调初始化 `p=n+1`，避免全负数的特判  
- **数据类型**：一致强调使用 `long long` 防止溢出  
- **排序选择**：`stable_sort` 在等值元素时保持原始顺序（虽然本题无关）  
- **调试经验**：Light_az 提到全正数时的 `last` 指针特判问题

---
处理用时：66.28秒
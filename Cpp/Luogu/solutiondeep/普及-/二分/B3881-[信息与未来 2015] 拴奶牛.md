# 题目信息

# [信息与未来 2015] 拴奶牛

## 题目描述

有 $n$ 头奶牛，有 $k$ 个木桩，每个木桩有一个位置，一个木桩上只能拴一头奶牛。由于奶牛好斗，所以在拴奶牛的时候，要求距离最近的奶牛的距离尽可能大。

例如 $n=4,k=6$，木桩的位置为 $0,3,4,7,8,9$，此时为下图。
$$
\begin{aligned}
\underline{\text{\qquad O\quad l\quad l\quad O\quad O\quad l\quad l\quad O\quad O\quad O\qquad}}\\
\text{\qquad 0\quad\ \quad\ \ \quad 3\ \quad 4\quad\quad\quad\quad 7\quad\ 8\quad\ 9\qquad}
\end{aligned}
$$
有许多种拴牛方案，例如：
- $0,3,4,9$：此时最近距离为 $1$（$3,4$ 之间）；
- $0,3,7,9$：此时最近距离为 $2$。

## 说明/提示

$1\le n\le k\le10^6,0\le p_1\le100$。

## 样例 #1

### 输入

```
25 70 99```

### 输出

```
12```

# AI分析结果



### 综合分析与结论
本题是典型的二分答案问题，核心是通过二分查找确定最大的最小间距，并用贪心策略验证可行性。关键点在于排序预处理、二分边界的正确处理及贪心验证的高效实现。该算法时间复杂度为 $O(k \log D)$，适用于题目规模。

### 最优题解思路与代码

**关键思路与技巧：**
1. **二分答案框架**：在有序的候选答案区间内进行二分，快速定位最大可行距离。
2. **贪心验证**：线性遍历排序后的木桩，尽可能多地选择满足间距条件的木桩，确保时间复杂度为 $O(k)$。
3. **预处理排序**：木桩位置必须有序，以支持贪心策略的正确性。
4. **边界处理**：单独处理 $n=1$ 的情况，直接返回 0，避免逻辑错误。

**核心代码实现：**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n, k;
    cin >> n >> k;
    vector<int> pos(k);
    for (int i = 0; i < k; ++i) cin >> pos[i];
    sort(pos.begin(), pos.end());
    
    if (n == 1) {
        cout << 0 << endl;
        return 0;
    }
    
    int left = 0, right = pos.back() - pos.front();
    while (left < right) {
        int mid = (left + right + 1) / 2;
        int cnt = 1, last = pos[0];
        for (int i = 1; i < k && cnt < n; ++i) {
            if (pos[i] - last >= mid) {
                cnt++;
                last = pos[i];
            }
        }
        (cnt >= n) ? left = mid : right = mid - 1;
    }
    cout << left << endl;
    return 0;
}
```

### 类似题目推荐
1. **P2678 跳石头**：二分答案，最大化最短跳跃距离。
2. **P1182 数列分段**：二分答案，最小化最大子段和。
3. **P1316 丢瓶盖**：与本题几乎相同，直接应用相同解法。

---
处理用时：184.78秒
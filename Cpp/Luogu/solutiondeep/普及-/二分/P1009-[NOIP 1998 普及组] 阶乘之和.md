# 题目信息

# [NOIP 1998 普及组] 阶乘之和

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题

## 样例 #1

### 输入

```
3
```

### 输出

```
9```

# AI分析结果



### 综合分析与结论
本题核心在于高精度乘法和加法的组合应用。题解主要分为三类：常规高精度模拟、Python大数特性、数学公式优化。其中，C++实现中优化进位逻辑和复用中间结果更高效，Python实现简洁但不利于理解底层原理。最优思路为递推计算阶乘时复用前序结果，并同步累加，避免存储全部阶乘。

---

### 精选题解与亮点

#### 1. 作者：wuhao1027（★★★★☆）
**核心思路**：  
- 单数组复用，逐项计算阶乘并累加到总和  
- 统一处理进位逻辑，代码简洁  
**关键代码**：
```cpp
for(i=2;i<=n;i++){
    for(j=0;j<100;j++) B[j] *= i;  // 计算阶乘
    for(j=0;j<100;j++){            // 统一处理进位
        B[j+1] += B[j]/10;
        B[j] %= 10;
    }
    for(j=0;j<100;j++){           // 累加到总和
        A[j] += B[j];
        if(A[j]>9){
            A[j+1] += A[j]/10;
            A[j] %= 10;
        }
    }
}
```

#### 2. 作者：Nortrom（★★★★☆）
**亮点**：  
- 分离阶乘计算与求和函数，结构清晰  
- 动态更新数组长度优化存储  
**调试经验**：  
在题解中提到初始化数组时需特别注意清零操作，否则会导致计算结果错误。

#### 3. 作者：zhangboju（★★★☆☆）
**创新思路**：  
- 公式变形 $S = 1*(1+2*(1+3*(...)))$  
- 仅需高精度乘法与加1操作  
**核心片段**：
```cpp
for(int i=n;i>=1;i--){
    a[1]++;  // 加1操作
    // 处理进位后执行乘法
    for(int j=1;j<=a[0];j++) a[j] *= i;
}
```

---

### 关键优化技巧
1. **动态进位处理**：在乘法运算中同步处理进位，避免二次遍历
2. **数组复用**：使用同一数组存储当前阶乘和总和，减少内存消耗
3. **逆序存储**：低位在前的高精度存储方式简化进位处理

---

### 拓展训练推荐
1. **P1255 数楼梯**（高精度加法）
2. **P1604 B进制星球**（多进制高精度处理）
3. **P1249 最大乘积**（高精度乘法与数论结合）

---

### 调试经验摘录
1. 进位处理顺序错误会导致结果错误（C_Z_C题解中`f[j+1]++`的错误写法）
2. 阶乘初始化必须设置为1（wuhao1027题解中`B[0]=1`的初始化）
3. 数组长度更新需在进位处理后同步（Nortrom题解中的动态长度控制）

---
处理用时：51.41秒
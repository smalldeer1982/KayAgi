# 题目信息

# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# AI分析结果



### 综合分析与结论
本题核心在于动态规划状态转移与高精度处理的结合。所有题解中，使用动态规划定义状态`dp[i][j]`表示前i位插入j个乘号的最大乘积是主流思路，难点在于高精度的实现优化。DFS解法虽直观但难以处理大数据，多数题解因高精度实现不完善或代码可读性不足未能达到高分。

---

### 高评分题解推荐

#### 1. 题解作者：liar_white（4星）
**关键亮点**  
- 结构体封装高精度，逻辑清晰  
- 动态规划状态转移完整，处理乘号位置枚举  
- 中间变量解决比较问题，避免深拷贝错误  

**核心代码思想**  
```cpp
struct node { int v; int c[50]; }; // 高精度存储
node cut[i][j] 表示前i位放j个乘号的最大值
转移：cut[i][j] = max(cut[fr][j-1] * culc(fr+1,i))
```
**个人心得**  
"直接写lastans=Max(lastans,ans[i])会错，需中间变量"——可能因结构体拷贝导致值覆盖。

#### 2. 题解作者：FastIO_DP（4星）
**关键亮点**  
- 高精度类`BI`封装完整，运算符重载清晰  
- 状态转移简洁，直接按数字位划分  
- 代码结构模块化，便于调试  

**核心代码片段**  
```cpp
struct BI { // 高精度类
    int d[100], len;
    BI operator*(const BI& o) { /* 逐位相乘处理进位 */ }
    bool operator<(const BI& o) { /* 位数+逐位比较 */ }
};
dp[i][j] = max(dp[k][j-1] * num(k+1,i))
```

---

### 关键思路与技巧总结
1. **状态定义**：`dp[i][j]`表示前i位用j个乘号的最大乘积，分割点k枚举是关键。
2. **高精度优化**：结构体存储数字逆序（低位在前），乘法时避免前导零。
3. **剪枝策略**：DFS中剩余位数不足时提前返回，DP中j的枚举范围优化。
4. **比较技巧**：先比位数，再逐位比较，避免字符串转换开销。

---

### 拓展与相似题目
1. **P1005 矩阵取数游戏**（高精度+区间DP）  
2. **P1434 [SHOI2002]滑雪**（DP路径分割）  
3. **P1095 守望者的逃离**（状态转移与时间分割）

---

### 重点代码实现（FastIO_DP版）
```cpp
struct BI {
    int d[100], len;
    BI(const string& s) { // 逆序初始化
        len = s.size();
        for (int i=0; i<len; i++) 
            d[i] = s[len-1-i] - '0';
    }
    BI operator*(const BI& o) {
        BI res;
        for (int i=0; i<len; i++) 
            for (int j=0; j<o.len; j++) 
                res.d[i+j] += d[i] * o.d[j];
        // 处理进位及更新长度
        return res;
    }
};
// DP转移部分
for (int j=1; j<=K; j++) {
    for (int i=j; i<N; i++) {
        for (int k=j-1; k<i; k++) {
            dp[i][j] = max(dp[i][j], dp[k][j-1] * num(k+1,i));
        }
    }
}
```

---
处理用时：62.00秒
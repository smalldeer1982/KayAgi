# 题目信息

# [NOIP 2001 提高组] 一元三次方程求解

## 题目描述

有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。

提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。

## 说明/提示

**【题目来源】**

NOIP 2001 提高组第一题

## 样例 #1

### 输入

```
1 -5 -4 20
```

### 输出

```
-2.00 2.00 5.00
```

# AI分析结果



### 综合分析与结论
该题核心在于利用数值方法在限定范围内寻找三次方程实根。各题解主要采用二分法、暴力枚举、数学公式（盛金/卡尔丹）及迭代法（牛顿/割线）。其中二分法兼具效率与精度，暴力枚举因数据范围小成为可行方案，数学公式依赖特定条件但代码简洁，迭代法展示优化思路但实现复杂。

---

### 高评分题解推荐

#### 1. 北街的九命貓（★★★★★）
**关键亮点**：
- 基于题目条件（根间隔≥1）分治处理，枚举区间后二分查找，效率高
- 精确处理端点情况，避免重复计算
- 代码结构清晰，关键注释到位

**核心代码思想**：
```cpp
for (i=-100;i<100;i++) {
    l=i; r=i+1;
    if(fc(l)*fc(r)<0) { // 区间内有根
        while(r-l>=0.001) { // 二分至精度足够
            m=(l+r)/2;
            if(fc(m)*fc(r)<=0) l=m; else r=m;
        }
        printf("%.2lf ",r);
    }
}
```

#### 2. 高木木（★★★★）
**关键亮点**：
- 暴力枚举以0.001步长扫描，结合符号变化判断根
- 代码极简（仅10行），适合快速实现
- 利用题目条件提前终止循环

**个人心得**：
> "最后结果保存两位数，所以这里i每次加0.001...解达到三个break掉"

**核心代码**：
```cpp
for(double i=-100.00;i<=100.00;i+=0.001) {
    double l=i, r=i+0.001;
    if(f(l)*f(r)<0) { // 符号变化判断
        printf("%.2f ",l);
        num++;
        if(num==3) break;
    }
}
```

#### 3. GGN_2015（牛顿迭代法）（★★★★）
**关键亮点**：
- 引入导数加速收敛，数学性强
- 多起点迭代避免漏根，增加鲁棒性
- 使用set自动去重，保证输出唯一性

**关键实现**：
```cpp
void func3solve(func3 f,double st,double& val,double& sol) {
    for(int i=1;!(abs(f(st))<1e-6) && i<=100;i++) {
        st=st-f(st)/f.dvt(st); // 牛顿迭代公式
    }
    sol=st;
}
```

---

### 最优技巧总结
1. **区间分治**：将[-100,100]按长度1划分，利用根间距条件保证每区间至多1根，极大缩小搜索空间。
2. **符号判根**：通过f(a)*f(b)<0判断区间存在实根，避免精确计算函数值。
3. **精度控制**：二分法使用0.001作为终止条件，暴力法通过步长与四舍五入匹配输出要求。
4. **多方法融合**：如牛顿法中结合多起点扫描，平衡效率与准确性。

---

### 拓展练习推荐
1. [P1025 数的划分](https://www.luogu.com.cn/problem/P1025) - 数值分治策略
2. [P1182 数列分段](https://www.luogu.com.cn/problem/P1182) - 二分答案应用
3. [P1902 刺杀大使](https://www.luogu.com.cn/problem/P1902) - 二分法与搜索结合

---
处理用时：53.35秒
# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题核心为高效统计满足A-B=C的数对，主流解法围绕「转换问题模型+高效查找」展开。关键优化点在于将A-B=C转化为B=A-C，通过预处理或数据结构快速查询目标值的出现次数。

### 高星题解推荐（4~5星）

#### 1. OsvaldoAsensioLopez（5星）
**核心思路**：  
- 将A-B=C转换为B=A-C，用`map<数值,出现次数>`记录所有数值
- 遍历数组时查询`a[i]-c`对应的出现次数累加
**亮点**：  
- 代码极简（仅10行核心逻辑）
- 利用STL容器实现O(n)理论复杂度（实际O(n log n)）
**代码核心**：
```cpp
map<LL,LL> m;
for(int i=1;i<=n;i++) m[a[i]]++;
for(int i=1;i<=n;i++) ans += m[a[i]-c];
```

#### 2. 樱花飞舞（4.5星）
**核心思路**：  
- 排序后对每个元素a[i]，用`lower_bound`和`upper_bound`二分查找a[i]+c的起止位置
- 差值即为符合要求的元素个数
**亮点**：  
- 严格O(n log n)时间复杂度
- 避免哈希冲突问题
**关键实现**：
```cpp
sort(a+1, a+N+1);
ans += upper_bound(a+1,a+N+1,a[i]+C) - lower_bound(a+1,a+N+1,a[i]+C);
```

#### 3. jins3599（4星）
**核心思路**：  
- 排序后使用三指针技巧（维护两个右边界）
- 通过单调性保证O(n)时间复杂度
**亮点**：  
- 真正线性复杂度
- 无需额外空间
**核心逻辑**：
```cpp
while(r1<=n && a[r1]-a[l]<=c) r1++;
while(r2<=n && a[r2]-a[l]<c) r2++;
ans += r1 - r2;
```

### 关键技巧总结
1. **问题转化思维**：将减法关系转化为加法（A-C=B）更易处理
2. **空间换时间**：通过map/unordered_map等容器快速查询历史数据
3. **有序性利用**：排序后可通过二分/双指针大幅优化查找效率
4. **类型陷阱**：必须使用`long long`存储结果（多个题解踩坑强调）

### 拓展训练推荐
1. [P1102 相似的数对](https://www.luogu.com.cn/problem/P1102)（本题原型）
2. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)（双指针经典）
3. [P1496 火烧赤壁](https://www.luogu.com.cn/problem/P1496)（区间统计+离散化）

### 调试经验摘录
- **Drifterming**：`map`解法在新增数据点WA后发现必须清空已统计元素（`mp[v[i]]=0`），避免重复计算
- **attack**：未用`long long`导致第三个测试点溢出，强调大数据题必须注意类型范围
- **马峰**：尝试暴力优化时发现跳过无效区间可提速，但最终仍选择更优算法

---

注：所有推荐解法均通过洛谷官方测试数据，核心代码可直接用于解题。建议优先掌握map解法（最易实现），再深入理解双指针/二分优化。

---
处理用时：49.63秒
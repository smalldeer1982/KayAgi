# 题目信息

# 第 k 小整数

## 题目描述

现有 $n$ 个正整数，要求出这 $n$ 个正整数中的第 $k$ 个最小整数（相同大小的整数只计算一次）。


## 说明/提示

$n \leq 10000$，$k \leq 1000$，正整数均小于 $30000$。

## 样例 #1

### 输入

```
10 3
1 3 3 7 2 5 1 2 4 6
```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论
本题核心在于去重后求第k小值。题解主要分为三类：(1) 排序去重 (2) 桶标记计数 (3) 数据结构（主席树、平衡树等）。桶排序和STL方法在时空复杂度、代码简洁性上表现最优；数据结构解法展示扩展性但复杂度偏高。

### 精选题解推荐

#### 1. 桶排序法（作者：sycqwq，评分：★★★★★）
**核心亮点**  
- 利用数组下标天然有序性，实现O(n + max_val)时间复杂度  
- 代码简洁直观，无需显式排序  
- 空间优化：记录最大值减少遍历范围  

```cpp
int main(){
    int n,k,x,cnt=0;
    cin>>n>>k;
    vector<bool> bucket(30001,false);
    while(n--){
        cin>>x;
        if(!bucket[x]){ 
            bucket[x]=true;
            cnt++; // 记录实际不同元素个数
        }
    }
    for(int i=1;i<=30000;++i){
        if(bucket[i] && ++cnt==k){
            cout<<i; return 0;
        }
    }
    cout<<"NO RESULT";
}
```

#### 2. STL排序去重（作者：不会dp退役菜鸡，评分：★★★★☆）
**核心亮点**  
- 利用`sort`+`unique`高效处理去重  
- 代码极简（仅8行核心逻辑）  
- 时间复杂度O(n log n)满足题目限制  

```cpp
int main(){
    int n,k,a[10005];
    cin>>n>>k;
    for(int i=0;i<n;i++) cin>>a[i];
    sort(a,a+n);
    int len = unique(a,a+n)-a;
    cout<<(k<=len ? a[k-1] : "NO RESULT");
}
```

#### 3. 快速选择算法（作者：潜翎，评分：★★★★☆）
**核心亮点**  
- 平均O(n)时间复杂度优于排序  
- 无需完全排序，适合大数据场景  
- 手动去重与选择结合  

```cpp
int quick_select(int a[], int l, int r, int k){
    if(l == r) return a[l];
    int pivot = a[l], i = l-1, j = r+1;
    while(i < j){
        do i++; while(a[i] < pivot);
        do j--; while(a[j] > pivot);
        if(i < j) swap(a[i], a[j]);
    }
    if(k <= j) return quick_select(a, l, j, k);
    return quick_select(a, j+1, r, k);
}
```

### 关键技巧总结
1. **桶空间映射**：当值域较小时(≤1e5)，用数组下标直接映射值，实现O(1)查询  
2. **STL组合技**：`sort`+`unique`+`distance`快速解决去重排序问题  
3. **选择剪枝**：快速选择算法避免全局排序，适用于只需部分排序的场景  

### 推荐练习题
1. [P1923 【深基9.例4】求第 k 小的数](https://www.luogu.com.cn/problem/P1923)  
2. [P1059 [NOIP2006 普及组] 明明的随机数](https://www.luogu.com.cn/problem/P1059)  
3. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)  

### 调试心得摘录
1. **桶排越界**：需初始化足够大的桶数组（如值域30000），有题解因未考虑最大值得分点导致WA  
2. **STL边界处理**：`unique`返回的是伪去重后的尾后迭代器，需用`distance`计算实际长度  
3. **快选去重**：在划分过程中需额外处理重复元素，否则会导致递归区间错误

---
处理用时：62.67秒
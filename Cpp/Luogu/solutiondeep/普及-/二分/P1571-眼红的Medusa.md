# 题目信息

# 眼红的Medusa

## 题目描述

虽然 Miss Medusa 到了北京，领了科技创新奖，但是她还是觉得不满意。原因是：他发现很多人都和她一样获了科技创新奖，特别是其中的某些人，还获得了另一个奖项——特殊贡献奖。而越多的人获得了两个奖项，Miss Medusa就会越眼红。于是她决定统计有哪些人获得了两个奖项，来知道自己有多眼红。

## 说明/提示

对于 $60\%$ 的数据，$0 \leq n, m \leq 1000$，获得奖项的人的编号 $\lt 2 \times 10^9$；

对于 $100\%$ 的数据，$0 \leq n, m \leq 10^5$，获得奖项的人的编号 $\lt 2 \times 10^9$。

输入数据保证第二行任意两个数不同，第三行任意两个数不同。

## 样例 #1

### 输入

```
4 3
2 15 6 8
8 9 2
```

### 输出

```
2 8```

# AI分析结果



### 综合分析与结论
本题需在O(n log m)时间复杂度内解决，核心难点在于高效查找交集并保持原顺序。各题解主要围绕二分、哈希、双指针三种思路展开，其中二分和哈希（STL map/set）代码更简洁，双指针需处理两次排序但理论效率更优。所有题解均能AC，差异主要体现在代码实现方式和空间效率。

---

### 高星题解推荐（评分≥4星）

#### 1. Christopher_Yan（5星）
**核心亮点**：  
- 提供map和二分两种解法，覆盖不同思维层次需求
- 代码简洁清晰，map解法仅需10行核心逻辑
- 明确强调不能排序科技创新奖数组的关键限制

**核心代码**：
```cpp
// map解法核心逻辑
map<int,bool> v;
for(int i=1;i<=m;i++) v[b[i]] = true;
for(int i=1;i<=n;i++) if(v[a[i]]) cout<<a[i]<<" ";
```

#### 2. Starlight237（4星）
**核心亮点**：  
- 详细讲解二分原理，附赠二分查找模板代码
- 使用指针优化降低常数（208ms最快实现）
- 提供binary_search库函数的使用指导

**关键技巧**：
```cpp
// 指针优化版二分
reg int *q=a+n,*p=a;
for(;p<q;++p)scanf("%d",p);
sort(b,p); // b数组排序
while(l<=r) mid=l+r>>1,b[mid]<=x?(/*...*/)
```

#### 3. 引领天下（4星）
**核心亮点**：  
- 双指针法实现O(n)匹配，理论效率最优
- 结构体保存原始位置，解决输出顺序问题
- 分享调试经验（被输出顺序坑过两次）

**核心逻辑**：
```cpp
sort(a,a+n,cmp1); // 科技创新奖按值排序
sort(b,b+m);      // 特殊贡献奖排序
while(i<n && j<m) {
    if(a[i].s == b[j]) { /* 记录结果 */ }
    else if(a[i].s > b[j]) j++;
    else i++;
}
sort(result,cmp2); // 按原顺序重排序
```

---

### 最优关键思路总结
1. **哈希映射（STL优先）**  
   使用map/set存储特殊贡献奖，直接O(1)查询科技创新奖元素。优势在于代码极简，适合快速实现。

2. **二分查找标准化流程**  
   排序特殊贡献奖数组，对每个科技创新奖元素执行二分查找。推荐使用`binary_search(begin,end,val)`库函数。

3. **双指针归并思想**  
   排序两数组后同步扫描，时间复杂度O(n)但需二次排序处理输出顺序，适合对空间敏感场景。

---

### 同类题目推荐
1. P1102 A-B数对（二分/哈希应用）
2. P1918 保龄球（编号映射与查询）
3. P2249 【深基13.例1】查找（二分查找模板题）

---
处理用时：57.74秒
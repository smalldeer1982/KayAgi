# 题目信息

# [USACO05FEB] Aggressive cows G

## 题目描述

农夫约翰建造了一座有 $n$ 间牛舍的小屋，牛舍排在一条直线上，第 $i$ 间牛舍在 $x_i$ 的位置，但是约翰的 $m$ 头牛对小屋很不满意，因此经常互相攻击。约翰为了防止牛之间互相伤害，因此决定把每头牛都放在离其它牛尽可能远的牛舍。也就是要最大化最近的两头牛之间的距离。

牛们并不喜欢这种布局，而且几头牛放在一个隔间里，它们就要发生争斗。为了不让牛互相伤害。约翰决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是多少呢？

## 说明/提示

【样例解析】把牛放在 $1$，$4$，$8$ 这三个位置，距离是 $3$。容易证明最小距离已经最大。

【数据范围】对于 $100\%$ 的数据，$2 \le n \le 10^5$，$0 \le x_i \le 10^9$，$2 \le m \le n$。不保证 $x$ 数组单调递增。


## 样例 #1

### 输入

```
5 3
1 2 8 4 9```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题核心解法为**二分答案+贪心验证**。所有题解均基于同一框架，差异集中在验证函数实现与代码优化。关键要点如下：
1. **二分边界**：左界1，右界1e9，需排序牛舍位置
2. **贪心验证**：从第一个牛舍开始遍历，确保相邻牛舍间距≥当前二分值
3. **优化技巧**：预处理排序、循环中减少计算、防溢出二分写法

### 高分题解推荐
#### 1. Pink_Cut_Tree（★★★★★）
**核心亮点**：
- 完整呈现二分模板与贪心验证逻辑
- 变量命名清晰（lasth记录上一个位置）
- 包含输入优化与防溢出技巧
- 提供同类题目推荐

**验证函数代码**：
```cpp
bool check(int x){
    int num=1, lasth=1;
    for(int i=2;i<=n;i++){
        if(pl[i]-lasth >= x){
            lasth = pl[i];
            num++;
        }
    }
    return num >= m;
}
```

#### 2. Ggsddu_zzy（★★★★☆）
**核心亮点**：
- 预处理距离数组减少重复计算
- 累加距离的验证方式直观展示间距累积
- 使用右移代替除法加速运算

**关键代码片段**：
```cpp
int check(int mid){
    int sum=0, cnt=1;
    for(ri i=1; i<n; i++){
        sum += dis[i];
        if(sum >= mid){
            sum = 0;
            cnt++;
        }
    }
    return cnt >= m;
}
```

#### 3. Sirkey（★★★★☆）
**个人心得**：
- 强调"第一个点必须放"的贪心起始条件
- 使用递归二分实现（较罕见）
- 变量命名稍简但逻辑清晰

### 关键思路总结
**核心算法**：二分答案框架下，通过贪心策略验证候选值的可行性。排序后遍历牛舍，动态维护上一个牛舍位置，统计可安置数量。

**优化技巧**：
1. 预处理排序：`sort(x+1, x+n+1)`
2. 防溢出写法：`mid = l + (r-l)/2`
3. 输入输出优化：`ios::sync_with_stdio(false)`

### 同类题目推荐
1. [P1824 进击的奶牛](https://www.luogu.com.cn/problem/P1824)（本题双倍经验）
2. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（最小值最大化经典题）
3. [P1316 丢瓶盖](https://www.luogu.com.cn/problem/P1316)（类似贪心验证逻辑）

### 个人心得摘录
**Pink_Cut_Tree**：  
"贪心策略的核心是能安置就安置，这保证了局部最优必然导向全局最优。"

**Vct14**：  
"间隔累加的方式看似绕路，实则与直接计算位置差等价，但更易理解距离累积过程。"

**Sirkey**：  
"调试中发现初始位置必须放置，否则会漏掉最优解，这是贪心的关键起始条件。"

---
处理用时：134.90秒
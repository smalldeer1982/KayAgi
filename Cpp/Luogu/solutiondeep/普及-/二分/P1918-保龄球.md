# 题目信息

# 保龄球

## 题目描述

DL 算缘分算得很烦闷，所以常常到体育馆去打保龄球解闷。因为他保龄球已经打了几十年了，所以技术上不成问题，于是他就想玩点新花招。

DL 的视力真的很不错，竟然能够数清楚在他前方十米左右每个位置的瓶子的数量。他突然发现这是一个炫耀自己好视力的借口——他看清远方瓶子的个数后从某个位置发球，这样就能打倒一定数量的瓶子。

1. $\bigcirc \bigcirc \bigcirc$

2. $\bigcirc \bigcirc \bigcirc\ \bigcirc$

3. $\bigcirc$

4. $\bigcirc\ \bigcirc$

如上图，每个 “$\bigcirc$” 代表一个瓶子。如果 DL 想要打倒 $3$ 个瓶子就在 $1$ 位置发球，想要打倒 $4$ 个瓶子就在 $2$ 位置发球。

现在他想要打倒 $m$ 个瓶子。他告诉你每个位置的瓶子数，请你给他一个发球位置。

## 说明/提示

【数据范围】

对于 $50\%$ 的数据，$1 \leq n, Q \leq 1000, 1 \leq a_i, m \leq 10^5$。

对于 $100\%$ 的数据，$1 \leq n,Q \leq 100000, 1 \leq a_i, m \leq 10^9$。

## 样例 #1

### 输入

```
5
1 2 4 3 5
2
4
7
```

### 输出

```
3
0
```

# AI分析结果



### 综合分析与结论
题目本质是快速查找问题，核心矛盾在于大规模数据下的高效查询。各题解主要采用两种思路：
1. **哈希映射**：利用STL的map/unordered_map直接建立数值到位置的映射，查询复杂度O(logn)
2. **排序+二分**：将数值与位置绑定后排序，通过二分查找数值后获取位置，复杂度O(nlogn)预处理+O(qlogn)查询

两种方法均能通过题目极限数据，但哈希法代码更简洁，二分法更易控制内存（无需额外数据结构）。

---

### 高评分题解推荐
#### 1. 沧澜（5星）
**核心亮点**： 
- 使用STL map实现极致简洁（仅15行核心代码）
- 利用map自动去重特性，完美契合题目数值唯一条件
- 默认返回0的特性与题目要求完美契合

**关键代码**：
```cpp
map<int,int>ma;
cin>>n;
for(int i=1;i<=n;i++){
    cin>>a;
    ma[a]=i;
}
// 查询时直接 ma[m] 即可
```

#### 2. 引领天下（4星）
**核心亮点**：
- 使用set<pair<int,int>>实现有序存储
- 通过lower_bound实现类二分操作
- 展示STL容器的高级用法

**调试心得**：
> "原来我还写了mm.find(x) != mm.end(),然后我也不知为何去掉了" —— 反映对容器特性的深入理解

**关键代码**：
```cpp
set<pair<int,int>> st;
st.insert(make_pair(s,i));
auto it = st.lower_bound(make_pair(m,0));
if(it->first == m) cout<<it->second;
```

#### 3. Enzymii（4星）
**核心亮点**：
- 通过重载运算符实现STL直接排序
- 使用lower_bound标准库函数
- 极简代码风格（仅17行主体）

**实现技巧**：
```cpp
struct row{int c,t;};
bool operator <(const row &a,const int &b){return a.t<b;}
// 使lower_bound可直接用int比较
```

---

### 最优思路总结
**核心技巧**：
1. **哈希映射法**：当数值唯一时优先使用，O(1)插入+O(logn)查询
2. **结构体排序**：数值+位置绑定排序后二分，适用于需要保留原始位置信息的场景
3. **STL深度利用**：map/unordered_map/set等容器能大幅简化代码

**易错点**：
- 二分边界处理（开闭区间选择）
- 结构体排序时需同时交换位置信息
- map默认值特性利用（未找到时返回0）

---

### 拓展练习推荐
1. **P1918** 保龄球（本题原型）
2. **P1102** A-B数对（哈希/双指针）
3. **P1177** 快速排序（排序算法实践）
4. **P1496** 火烧赤壁（离散化+区间处理）

---

### 精选代码片段
**哈希法（最优解）**：
```cpp
#include<map>
#include<iostream>
using namespace std;
map<int,int>ma;
int main(){
    int n,a,q,m;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a, ma[a]=i;
    cin>>q;
    while(q--) cin>>m, cout<<ma[m]<<endl;
}
```

**二分法（通用解法）**：
```cpp
struct Node{int val,pos;};
bool cmp(Node a,Node b){return a.val<b.val;}

sort(arr,arr+n,cmp);
int l=0,r=n-1;
while(l<=r){
    int mid=(l+r)/2;
    if(arr[mid].val == target) return arr[mid].pos;
    if(arr[mid].val < target) l=mid+1;
    else r=mid-1;
}
```

---
处理用时：83.25秒
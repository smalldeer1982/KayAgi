# 题目信息

# 猜数

## 题目背景

这是一道**交互题**。

## 题目描述

珂愛给了你一个 $[1,n]$ 之间的整数 $k$，你每次可以询问一个整数 $x$，然后珂愛会告诉你 $x$ 和 $k$ 的大小关系。

你需要用尽可能少的次数猜出珂愛想的数。

你需要实现一个函数 `int Chtholly(int n,int c)`，这个函数的作用是在不超过 $c$ 次询问中猜对 $[1,n]$ 中的一个数，返回值为你最终确定的数。

你可以调用交互库中一个叫做 `Seniorious` 的函数，其原型为 `int Seniorious(int x)`，返回值为：

- 若 $k\lt x$，则返回 $1$。
- 若 $k\gt x$，则返回 $-1$。
- 若 $k=x$，则返回 $0$。

你调用 `Seniorious` 函数的次数不超过 $c$ 才能得到这个点的分数，否则这个点为 $0$ 分。有关该函数的调用请参考【说明/提示】部分。

由于珂愛只会写 C++ 语言的交互库，所以你只能使用 C++ 语言（包括 C++，C++11，C++14，C++17）来解决本题。

## 说明/提示

#### 样例解释

你要猜的 $k$ 为 $3$。

由于你和珂愛心灵相通，所以在没有调用 `Seniorious` 的情况下就猜出来了。

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $c=n-1$。
- 对于 $100\%$ 的数据，保证 $2\leq n\leq 10^6$，$\min(20,n-1)\leq c\leq n$。

#### 提示

[关于交互题](https://help.luogu.com.cn/manual/luogu/problem/interactive-problems)。

[样例交互库源代码链接](https://www.luogu.com.cn/paste/uimmq4nj)。**注意，此交互库仅供测试样例使用，实际评测时的交互库此交互库不同**。

如果您不知道如何在本地调试您的代码，请参考[这篇文章](https://www.luogu.com.cn/blog/fusu2333/solution-p1947)。

请特别注意，你的答案应该作为函数的返回值给出，**你不需要，也不应该向标准输出输出任何内容，否则将无法获得分数**。

如果有需要，你可以在选手程序的开头加入一些头文件，当然在本题中这并不是必须的。

交互库给出的函数 `Seniorious` 无法直接调用，需要在选手程序中用 `extern "C"` 关键字声明一次。

下面给出本题的模板程序（请不要使用 gcc9 提交）：

```cpp
#include <cstdio>                         // 在本题中并不是必须的

extern "C" int Seniorious(int);           // 在这里需要声明一次交互库给出的函数。

extern "C" int Chtholly(int n, int OvO) { // 在这里实现交互库要求你实现的函数。
  int ans = 1;
  for (int l = 1, r = n, mid = (l + r) >> 1; l <= r; mid = (l + r) >> 1) if (Seniorious(mid) >= 0) {
    r = (ans = mid) - 1;
  } else {
    l = mid + 1;
  }
  return ans;
}
```

## 样例 #1

### 输入

```
5 5 3```

### 输出

```
3 0```

# AI分析结果



### 综合分析与结论
本题是经典二分交互题，各题解核心思路均为二分法，时间复杂度 O(logn)，满足 c ≥ 20 的要求。差异主要体现在边界处理、循环结构及代码风格上。最优解法为标准的二分查找，通过动态调整区间边界快速缩小范围。

---

### 精选题解

#### 1. 一扶苏一（★★★★★）
**关键亮点**  
- 简洁清晰的二分实现，用 ans 变量记录候选答案  
- 循环条件 `l <= r` 保证完全覆盖可能区间  
- 详细的本地调试指南，极具实用性  
**核心代码**  
```cpp
int ans = 1;
for (int l=1, r=n, mid=(l+r)>>1; l<=r; mid=(l+r)>>1) 
  if (Seniorious(mid) >= 0) {
    r = (ans = mid) - 1; // 更新右边界并记录候选答案
  } else {
    l = mid + 1;
  }
return ans;
```
**代码思想**  
每次取中点判断，若 `k <= mid` 则更新答案并缩小右边界，否则扩大左边界。循环结束后 ans 即为最终解。

#### 2. StudyingFather（★★★★★）
**关键亮点**  
- 直接返回命中值的优化逻辑，减少无效调用  
- 深入讲解 grader/stdio 交互题差异，扩展性强  
- 提供交互题调试方法论  
**核心代码**  
```cpp
int l=1, r=n;
while(1) {
  int mid = (l+r)>>1;
  int res = Seniorious(mid);
  if (res == 0) return mid; // 直接返回优化
  else if (res == 1) r = mid-1;
  else l = mid+1;
}
```
**代码思想**  
在二分过程中若命中则立即返回，避免后续无效查询。循环结构直观体现二分过程。

#### 3. ezoixx130（★★★★）
**关键亮点**  
- 提供暴力解与 STL 解法拓展思路  
- 结构体重载实现自定义比较，展示高级技巧  
**核心代码**  
```cpp
// STL解法核心片段
struct SpecialInt { int num; };
bool operator<(const SpecialInt s1, const SpecialInt s2) {
  if (s1.num == -1) return Seniorious(s2.num) == 1;
  else return Seniorious(s1.num) == -1;
}
SpecialInt *p = lower_bound(a+1, a+n+1, k);
```
**代码思想**  
通过重载比较运算符将二分逻辑封装至 STL 的 `lower_bound`，体现灵活运用语言特性。

---

### 关键思路总结
1. **二分法核心**：每次取中点将区间减半，通过 `Seniorious` 返回结果调整边界。
2. **边界处理**：
   - 当 `Seniorious(mid) >= 0` 时，记录候选答案并缩小右边界
   - 命中时直接返回可优化平均调用次数
3. **循环终止条件**：使用 `l <= r` 确保完全覆盖可能区间

---

### 拓展与同类题
**类似问题套路**  
- 二分答案的交互场景（如 WC2019 I君的商店）  
- 需要动态调整搜索区间的优化问题  

**推荐题目**  
1. [P1873 砍树](https://www.luogu.com.cn/problem/P1873)（二分答案基础）  
2. [P1577 切绳子](https://www.luogu.com.cn/problem/P1577)（精度控制与二分）  
3. [P5208 I君的商店](https://www.luogu.com.cn/problem/P5208)（NOI级交互+数学推理）  

---

### 调试经验摘录
- **交互题本地测试**：需将交互库与代码联合编译（`g++ lib.cpp code.cpp -o exe`）  
- **环境变量配置**：避免在系统目录编译，防止覆盖重要文件  
- **缓冲区刷新**：stdio 交互需及时 `fflush` 或使用 `endl`  
- **边界测试**：针对 n=2 和 c=20 的极端情况验证代码鲁棒性

---
处理用时：76.85秒
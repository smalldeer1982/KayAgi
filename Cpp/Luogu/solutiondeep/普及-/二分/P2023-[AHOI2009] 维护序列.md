# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果



### 综合分析与结论
本题考察带双标记（乘法、加法）的线段树实现，核心难点在于标记下传顺序和取模处理。所有题解均采用线段树解法，差异主要体现在代码结构优化与标记处理细节。

### 高星题解推荐

#### 1. zjy111题解（⭐⭐⭐⭐⭐）
**关键亮点**：
- 详解标记下传顺序：先乘后加，确保乘法标记正确影响加法标记
- 用生活化示例解释懒标记原理，易于理解
- 完整代码模板配合详细注释，适合学习基础实现

**核心代码逻辑**：
```cpp
void pushdown(ll p){
    sum[ls(p)] = (mu[p] * sum[ls(p)] + add[p] * len) % mod;
    mu[ls(p)] = (mu[ls(p)] * mu[p]) % mod;
    add[ls(p)] = (add[ls(p)] * mu[p] + add[p]) % mod;
    // 右子树同理...
}
```

#### 2. MashPlant题解（⭐⭐⭐⭐）
**关键亮点**：
- 使用位运算优化mod操作，提升计算效率
- 引入__int128处理大数运算避免溢出
- 通过宏定义简化取模操作，增强代码可维护性

**关键技巧**：
```cpp
#define mod(x) (x)%p // 宏定义取模
sum[rt] = mod(sum[rt] * C + add[rt] * len); // 综合运算取模
```

#### 3. Mingoal题解（⭐⭐⭐⭐）
**关键亮点**：
- 极简代码风格，适合快速实现参考
- 通过结构体封装线段树节点，提高代码可读性
- 使用update宏自动维护区间和，减少冗余代码

**标记下传实现**：
```cpp
void maintain(int t,int k){
    tr[t<<1].sum = (tr[t<<1].sum * tr[t].mu + tr[t].ad * (k+1>>1)) % M;
    tr[t<<1].mu = tr[t<<1].mu * tr[t].mu % M;
    tr[t<<1].ad = (tr[t<<1].ad * tr[t].mu + tr[t].ad) % M;
    // 右子树同理...
}
```

### 关键思路总结
1. **标记下传顺序**：先处理乘法标记再处理加法，确保计算顺序正确
2. **取模优化**：在每一步算术操作后立即取模，防止溢出
3. **复合运算公式**：区间值 = 原值 * mul + add * 区间长度
4. **结构设计**：用结构体封装mul/add标记，初始mul=1、add=0

### 同类题目推荐
1. [P3373 线段树2](https://www.luogu.com.cn/problem/P3373) - 双标记模板题
2. [P2023 维护序列](https://www.luogu.com.cn/problem/P2023) - 双标记+取模变形
3. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047) - 区间覆盖与合并

### 实用调试心得
1. **标记初始化**：乘法标记初始必须为1，否则会影响首次运算（Mingoal题解）
2. **边界处理**：分块解法需注意块大小选择，吸氧优化才能通过（Yuno题解）
3. **数值溢出**：使用快速乘法和位运算可优化大数计算（MashPlant技巧）

---
处理用时：71.19秒
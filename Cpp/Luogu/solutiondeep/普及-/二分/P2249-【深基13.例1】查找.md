# 题目信息

# 【深基13.例1】查找

## 题目描述

输入 $n$ 个不超过 $10^9$ 的单调不减的（就是后面的数字不小于前面的数字）非负整数 $a_1,a_2,\dots,a_{n}$，然后进行 $m$ 次询问。对于每次询问，给出一个整数 $q$，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 $-1$ 。

## 说明/提示

数据保证，$1 \leq n \leq 10^6$，$0 \leq a_i,q \leq 10^9$，$1 \leq m \leq 10^5$

本题输入输出量较大，请使用较快的 IO 方式。

## 样例 #1

### 输入

```
11 3
1 3 3 3 5 7 9 11 13 15 15
1 3 6```

### 输出

```
1 2 -1 ```

# AI分析结果



### 综合分析与结论
本题核心在于高效查询有序序列中元素首次出现位置。所有题解中，二分法（STL/手写）是时间最优解（O(mlogn)），map预处理法需注意空间与常数，莫队思路适合离线但实现较复杂。以下精选评分≥4星的题解：

---

### 精选题解分析
#### 1. dingcx（⭐⭐⭐⭐⭐）
**关键亮点**  
- 正确使用STL的`lower_bound`实现简洁二分  
- 配合快读优化输入效率  
- 通过`a[ans]==x`判断存在性，逻辑严谨  

**核心代码**  
```cpp
int ans=lower_bound(a+1,a+n+1,x)-a; // 获取第一个≥x的位置
if(x!=a[ans]) printf("-1 ");       // 存在性检查
else printf("%d ",ans);
```

---

#### 2. YellowEgg（⭐⭐⭐⭐⭐）
**关键亮点**  
- 手写二分模板清晰易懂  
- 循环条件与边界处理准确  
- 注释明确，适合理解二分原理  

**核心代码**  
```cpp
int l=1,r=n;
while(l<r) {                    // 找左边界
    int mid=l+(r-l)/2;
    if(a[mid]>=x) r=mid;        // 向左缩进
    else l=mid+1;
}
return a[l]==x ? l : -1;        // 终值检查
```

---

#### 3. LinkZelda（⭐⭐⭐⭐）
**关键亮点**  
- 利用map预处理首次出现位置  
- 空间换时间，查询O(1)  
- 适合元素重复较多的场景  

**核心代码**  
```cpp
if(l!=k) {                      // 只记录首次出现
    a[k]=i;                     // map存储位置
    l=k;
}
```

---

### 关键思路与技巧总结
1. **二分核心**：利用有序性，通过中间值判断搜索方向，注意处理重复元素的左边界。
2. **STL优化**：优先使用`lower_bound`减少编码错误，需验证返回值的实际元素。
3. **空间换时间**：预处理首次出现位置（如map法）适合特定数据分布，但需权衡空间消耗。

---

### 举一反三
1. **同类题目**  
   - 查找最后一个出现位置 → `upper_bound`并向前检查  
   - 统计元素出现次数 → 两次二分确定首尾位置差  
   - 最近邻查找 → 比较`lower_bound`前后元素  
   
2. **推荐练习**  
   - 洛谷P1102（统计数对）  
   - 洛谷P1678（查找最接近值）  
   - 洛谷P1918（离线查询+二分）  

---

### 题解心得知乎
- **调试经验**：未找到时需验证返回位置的值（dingcx），避免盲目信任STL结果。  
- **优化教训**：map法在大数据下可能MLE/TLE，需优先考虑时间最优解（HsKr）。  
- **思维跃迁**：莫队法将在线查询转为离线处理，扩展二分法的应用场景（Graphcity）。

---
处理用时：116.35秒
# 题目信息

# 「EZEC-10」打分

## 题目背景

**为防止评测机被卡，本题时限为 100 ms。**

## 题目描述

小 A 去参加奥运会。

奥运会中共有 $n$ 名裁判，分别给小 A 打分 $a_1,a_2,\ldots,a_n$。

小 A 对自己的得分不满意，于是他将某名裁判打出的分数加 $1$，称为一次操作。

但是小 A 不能太贪心，他最多只能进行 $m$ 次操作。

小 A 的最终得分为：所有得分中，去掉一个最高分和一个最低分后的平均值。

小 A 想知道，他的最终得分最高为多少。

## 说明/提示

**【样例 1 解释】**

一种可行的方案为：$[1,2,3]\to [3,2,3]$。

**【样例 2 解释】**

一种可行的方案为：$[1,2,2,3]\to [2,3,3,3]$。

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（5 points）：$m=0$。
- Subtask 2（10 points）：$n=3$。
- Subtask 3（15 points）：$n,m\le 10^3$。
- Subtask 4（70 points）：无特殊限制。

对于 $100\%$ 的数据，$3\le n\le 10^5$，$0\le m,a_i\le 10^9$。

## 样例 #1

### 输入

```
3 2
1 2 3```

### 输出

```
3```

## 样例 #2

### 输入

```
4 3
1 2 2 3```

### 输出

```
6```

# AI分析结果



### 综合分析与结论
本题核心为贪心策略，需最大化中间分数总和。关键点包括：忽略最低分、优先填平中间分数至当前最高分、剩余操作均匀分配。各题解均围绕此核心展开，差异在于实现细节与数学推导的严谨性。

---

### 精选题解及评分

#### 1. 作者：Maxmilite（★★★★★）
**核心亮点**：
- 数学推导严谨，通过总和比较分类讨论
- 巧妙避免浮点运算，用整数除法处理均匀分配
- 代码简洁高效（O(n log n)）

**关键实现**：
```cpp
sort(a + 1, a + n + 1);
long long cur = 0;
for (int i(2); i <= n - 1; ++i) cur += a[i];
if (cur + m < (n - 2) * a[n]) // 无法填平到原最高分
    printf("%llu\n", (cur + m));
else // 可填平后继续提升
    printf("%llu\n", (cur + m + a[n]) * (n - 2) / (n - 1));
```

#### 2. 作者：BotDand（★★★★☆）
**核心亮点**：
- 分两阶段处理（填平+均匀分配）
- 明确计算剩余操作数的分配策略
- 代码包含详细注释，易理解

**关键公式**：
```cpp
ans = s1 + s2; // 填平阶段
m -= s1;
x = m/(n-1); // 均匀分配次数
ans += x*(n-2);
if(y > 0) ans += (y-1); // 余数处理
```

#### 3. 作者：StayAlone（★★★★☆）
**核心亮点**：
- 明确数学分情况讨论
- 处理余数时的特殊判断（需减1）
- 代码包含详细注释说明边界条件

**个人心得**：
> "最后要减一是因为会有一个增加的与最大值共同去掉"  
> 强调余数处理时需考虑最高分变化对结果的影响

---

### 最优思路提炼
1. **排序预处理**：忽略最低分，关注中间值
2. **两阶段策略**：
   - 阶段一：将中间分数提升至原最高分（计算所需操作数）
   - 阶段二：若有余力，均匀分配剩余操作（避免产生新最高分）
3. **数学优化**：通过整数运算避免浮点误差，公式推导 `(总和 + m) / (n-2)` 转化为乘法形式

---

### 拓展练习推荐
1. [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995) - 贪心策略与极值处理
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223) - 排序与最优调度
3. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094) - 双指针贪心策略

---

### 关键代码实现
以Maxmilite解法为例，核心逻辑：
```cpp
sort(a + 1, a + n + 1); // 排序后a[1]为最小，a[n]为最大
unsigned long long sum_mid = 0;
for(int i=2; i<=n-1; ++i) sum_mid += a[i];

// 判断能否填平中间分数到原最高分
if(sum_mid + m <= (n-2)*a[n]) {
    ans = sum_mid + m; // 直接相加
} else {
    // 数学推导公式：总提升量 = (sum_mid + m + a[n]) * (n-2)/(n-1)
    ans = (sum_mid + m + a[n]) * (n-2) / (n-1);
}
```
该实现仅用13行核心代码完成所有关键逻辑，时间复杂度O(n log n)完全满足1e5数据量。

---
处理用时：52.06秒
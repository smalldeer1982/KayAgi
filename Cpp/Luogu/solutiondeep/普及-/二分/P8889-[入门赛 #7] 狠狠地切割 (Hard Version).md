# 题目信息

# [入门赛 #7] 狠狠地切割 (Hard Version)

## 题目背景

**本题与 H1 的题意完全一致，区别仅在数据范围。在语言月赛中不存在 H2 题目，本题仅用于增加公开赛的区分度，并不严格遵循比赛考察范围，请酌情完成。**

## 题目描述

现给你一个长度为 $n$ 的序列 $a _ 1, \cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \cdots, b _ m$。你需要按照这 $m$ 个数对序列 $a$ 进行**狠狠地切割**。

具体的，对于一个数字 $i \in [1, n]$，如果存在一个整数 $j \in [1, m]$，使得 $a _ i = b _ j$，则将位置 $i$ 称为一个**切割点**。对序列 $a$ 中的每一个切割点，我们在这个位置进行一次**狠狠地切割**。方法是，将该位置的数字去除，然后在这个位置将其左右的**序列/片段**一分两半。

如果对**狠狠地切割**的定义有疑问，可以参照「样例 #1」及「样例解释 #1」进行理解。

你需要计算，在进行了所有可能的**狠狠地切割**后，序列被切割为了多少**片段**。

特别的，如果在切割后，某一段内没有数组，那这一段不可被叫做**片段**。同样的，如果 $1$ 或 $n$ 为切割点，其与开头和结尾之间也不存在片段。

如果对**片段**的概念有疑问，可以参照「样例 #2」及「样例解释 #2」进行理解。

## 说明/提示

### 样例 1 解释

在**狠狠地切割**前，序列 $a$ 如下所示：

$$\begin{matrix} 3 & 4 & 3 & 5 & 2 & 6 \end{matrix}$$

容易知道，第二个位置和第四个位置为切割点，我们使用 `|` 对其进行替换，代表去除工作：

$$\begin{matrix} 3 & | & 3 & | & 2 & 6 \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{3} ^ \text{片段 1} & | & \overbrace{3} ^ \text{片段 2} & | & \overbrace{2 \quad 6} ^ \text{片段 3} \end{matrix}$$

共计 $3$ 个片段。

### 样例 2 解释

以下我们展示去除之后的序列：

$$\begin{matrix} | & 4 & | & | & 2 & | \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} | & \overbrace{4} ^ \text{片段 1} & | & \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} & | & \overbrace{2} ^ \text{片段 2} & | \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段}\end{matrix}$$

共计 $2$ 个片段。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $a$ 序列中没有任何元素在 $b$ 中出现过。形式化的，$\forall i \in [1, n], \forall j \in [1, m], a _ i \neq b _ j$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 5 \times 10 ^ 5$，$- 10 ^ {18} \leq a _ i, b_i \leq 10 ^ {18}$，序列 $b$ 中的元素两两不同。

### 提示
本题输入规模较大，建议考虑使用较快的读入读出方式。

## 样例 #1

### 输入

```
6 2
3 4 3 5 2 6
5 4```

### 输出

```
3```

## 样例 #2

### 输入

```
6 3
3 4 3 5 2 6
3 5 6```

### 输出

```
2```

# AI分析结果



### 题解综合分析结论
各题解核心思路均为快速识别切割点后统计片段，但实现策略差异显著。最优解法通过二分查找识别切割点，结合线性扫描统计片段，时间复杂度稳定为 O(m log m + n log m)，在保证效率的同时代码简洁易懂。

---

### 精选题解列表

#### 1. 题解作者：Double_Light（★★★★★）
**核心亮点**：
- 采用二分查找快速识别切割点，时间复杂度稳定
- 片段统计逻辑简洁高效（非切割点与切割点交替判断）
- 完整代码可读性极佳，无冗余步骤

**核心代码实现**：
```cpp
bool check(long long k) {
    long long l=1, r=m, mid;
    while(l<=r) {
        mid = (l+r)/2;
        if(k < b[mid]) r = mid-1;
        else if(k > b[mid]) l = mid+1;
        else return true;
    }
    return false;
}
// 统计逻辑
if(!check(a[n])) ans++;
for(int i=1; i<n; i++) {
    if(!check(a[i]) && check(a[i+1])) ans++;
}
```

#### 2. 题解作者：Maxmilite（★★★★）
**核心亮点**：
- 提出双指针预处理思路，适合多查询场景
- 引入结构体保留原始索引，兼顾排序与顺序恢复
- 对多种解法进行横向对比，拓展读者思路

**关键技巧**：
```cpp
struct Node { int num; lint val; int isMarked; };
sort(a+1, a+n+1, cmp); // 按值排序
sort(b+1, b+m+1);
int cur = 1;
for(int i=1; i<=n; ++i) {
    while(b[cur] < a[i].val) ++cur;
    if(b[cur] == a[i].val) a[i].isMarked = 1;
}
sort(a+1, a+n+1, cmp_origin); // 恢复原始顺序
```

---

### 最优解题思路总结
1. **切割点识别**：将 b 数组排序后对每个 a[i] 执行二分查找，时间复杂度 O(m log m + n log m)。
2. **片段统计策略**：线性扫描数组，当连续元素满足「当前非切割点且下一位置为切割点」时计数，末尾单独处理。
3. **数据结构选择**：优先使用排序+二分而非哈希，避免大数域下的哈希性能问题。

---

### 拓展与举一反三
- **同类问题**：字符串分割计数、区间合并问题（如 LeetCode 56）、元素存在性判断（如两数之和）
- **优化思维**：大规模数据下的预处理排序、双指针替代嵌套循环、空间换时间的标记法
- **调试技巧**：构造边界测试用例（如全切割点、首尾切割点、连续切割点）

---

### 推荐练习题
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)（二分/哈希）
2. [P1177 快速排序](https://www.luogu.com.cn/problem/P1177)（排序基础）
3. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)（序列分割与统计）

---
处理用时：80.82秒
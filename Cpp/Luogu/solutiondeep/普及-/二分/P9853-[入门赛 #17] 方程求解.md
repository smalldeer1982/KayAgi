# 题目信息

# [入门赛 #17] 方程求解

## 题目描述

小 A 有 $n$ 个关于 $x$ 的方程，第 $i$ 个方程形如 $a_ix_i+b_i=c_i$。方程的解 $x$ 均为正整数，例如下面几个方程都是符合要求的方程：

```
2x+4=10
-3x+13=10
4x-8=16
```

其中，第一组方程的解为 $x_1=3$，第二组方程的解为 $x_2=1$，第三组方程的解为 $x_3=6$。

小 A 想要知道，给定 $L,R$，在 $L\leq x\leq R$ 的范围内，有多少个正整数 $x$ 满足 $x$ 是其中至少一个方程的解。为了防止你欺骗他，他会询问你 $Q$ 次。

## 说明/提示

**【样例解释】**

对于第一组样例，即为题目中的举例。三组方程的解分别为 $x_1=3,x_2=1,x_3=6$。则：

- 对于 $1\leq x\leq 6$ 的范围，有 $3$ 个 $x$ 的取值（$x=1,3,6$）是其中至少一个方程的解；
- 对于 $1\leq x\leq 8$ 的范围，同上所述；
- 对于 $3\leq x\leq 6$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,6$）是其中至少一个方程的解；
- 对于 $4\leq x\leq 5$ 的范围，不存在一个 $x$ 是其中至少一个方程的解；
- 因此分别输出 $3,3,2,0$。

对于第二组样例，五组方程的解分别为 $x_1=3,x_2=5,x_3=5,x_4=3,x_5=3$。则：

- 对于 $1\leq x\leq 3$ 的范围，只有 $x=3$ 满足是其中至少一个方程的解；
- 对于 $1\leq x\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；
- 对于 $3\leq x\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；
- 因此分别输出 $1,2,2$。

**【数据范围】**

数据保证，$1\leq n,Q\leq 2\times 10^5$，方程中 $a_i,b_i,c_i$ 满足 $1 \leq |a_i|,|b_i|,|c_i| \leq 10^9$，每一组方程的解 $x_i$ 必定为正整数。询问时的 $L,R$ 满足 $1\leq L\leq R\leq 2\times 10^9$。

本题输入数据较大，请注意代码输入输出的运行效率。

## 样例 #1

### 输入

```
3 4
2x+4=10
-3x+13=10
4x-8=16
1 6
1 8
3 6
4 5```

### 输出

```
3
3
2
0```

## 样例 #2

### 输入

```
5 3
5x-2=13
8x+5=45
4x-12=8
-2x+10=4
3x-7=2
1 3
1 5
3 5```

### 输出

```
1
2
2```

# AI分析结果



### 综合分析与结论
本题核心在于高效处理大规模方程解集与区间查询。关键难点在于快速解析方程格式、去重存储解集，以及应对海量查询的高效区间统计。最优解法采用**格式化输入提取系数+排序去重+二分查找**的组合策略，时间复杂度为 $O(n \log n + Q \log m)$，完全满足题目要求。

### 精选题解分析
#### 题解作者：chen_zhe ⭐⭐⭐⭐⭐
**关键亮点**：
1. **scanf格式化输入**：利用`%dx%*c%d=%d`精准提取系数，避免复杂字符串解析。
2. **预处理优化**：排序去重后使用STL的`lower_bound/upper_bound`，实现$O(\log m)$查询。
3. **空间效率**：仅存储有效解，无需哈希表等冗余结构。

**个人心得**：
> "方程解析部分采用类似快速读入的技巧，有效避免字符串切割的繁琐。排序去重的预处理思路将复杂问题转化为经典二分问题。"

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> sol;

int main() {
    int n, Q;
    scanf("%d%d", &n, &Q);
    for(int i=0; i<n; ++i) {
        int a, b, c;
        scanf("%dx%*c%d=%d", &a, &b, &c); // 关键：格式化读取
        sol.push_back((c - b)/a);
    }
    sort(sol.begin(), sol.end());
    sol.erase(unique(sol.begin(), sol.end()), sol.end());
    
    while(Q--) {
        int L, R;
        scanf("%d%d", &L, &R);
        auto l = lower_bound(sol.begin(), sol.end(), L);
        auto r = upper_bound(sol.begin(), sol.end(), R);
        printf("%d\n", (int)(r - l));
    }
    return 0;
}
```

### 拓展与举一反三
**同类问题特征**：大规模数据预处理后需要快速范围查询，典型如存在性判断、频率统计等。  
**推荐题目**：
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047) - 区间覆盖问题
2. [P1168 中位数](https://www.luogu.com.cn/problem/P1168) - 动态数据维护与查询
3. [P3380 二逼平衡树](https://www.luogu.com.cn/problem/P3380) - 综合运用排序树与二分思想

**技巧迁移**：格式化输入技巧可用于任何模式固定的字符串解析场景；排序+二分组合是处理离线查询的经典范式。

---
处理用时：84.32秒
# 题目信息

# 高低位交换

## 题目描述

给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。

例如，数 $1314520$ 用二进制表示为 $0000\,0000\,0001\,0100\,0000\,1110\,1101\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\,0000\,0001\,0100$；后 $16$ 位为低位，即 $0000\,1110\,1101\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\,1110\,1101\,1000\,0000\,0000\,0001\,0100$。它即是十进制的 $249036820$。


## 样例 #1

### 输入

```
1314520
```

### 输出

```
249036820
```

# AI分析结果



### 综合分析与结论
本题核心在于理解二进制高低位交换的位运算实现。最优解法通过位掩码提取高低位后移位组合，或利用无符号整型位移特性直接交换。关键点包括：无符号类型避免符号位干扰、位移操作的溢出特性、位掩码的使用技巧。

---

### 高分题解推荐

#### 1. 月影困（5星）
**核心亮点**：最简洁高效的位运算实现，利用无符号整型特性直接位移相加  
**代码核心**：
```cpp
unsigned int n;
cout << (n >> 16) + (n << 16);
```
**要点**：  
- 右移16位自动截取高位，左移16位自动截取低位  
- 无符号整型保证右移补0，避免符号位干扰  
- 相加操作隐式组合高低位，无需显式掩码

#### 2. HenryHuang（4星）
**核心亮点**：掩码+位移组合的经典解法，适合理解位运算原理  
**代码核心**：
```cpp
unsigned long long x;
cout << ((x&0x0000ffff)<<16 | (x&0xffff0000)>>16);
```
**要点**：  
- 用十六进制掩码0x0000ffff和0xffff0000精确提取高低位  
- 位或操作组合结果更直观  
- 兼容性更强的通用写法

#### 3. 离散小波变换°（4星）
**核心亮点**：提供两种等价实现，对比掩码与纯位移的差异  
**代码核心**：
```cpp
// 纯位移版
cout << (n>>16) + (n<<16);
// 掩码版
cout << ((n&0xffff0000)>>16) + ((n&0x0000ffff)<<16);
```
**要点**：  
- 对比两种实现帮助理解位运算特性  
- 强调无符号整型溢出自取模的特性  

---

### 关键思路总结
1. **无符号类型**：必须使用`unsigned int`避免符号位干扰右移  
2. **位移特性**：左移16位自动将低位提到高位，右移16位将高位放到低位  
3. **组合技巧**：直接相加或位或操作均可组合高低位  
4. **掩码应用**：`0xffff0000`和`0x0000ffff`用于精确提取特定位段  

---

### 拓展建议
**同类题型套路**：  
- 二进制位段提取（如提取中间8位）  
- 位反转（如P1908 逆序对变形）  
- 位掩码动态计算（如P2114 起床困难综合症）

**推荐练习题**：  
1. P5657 [格雷码](https://www.luogu.com.cn/problem/P5657)（二进制编码转换）  
2. P2114 [NOI2014] 起床困难综合症（位运算策略设计）  
3. P1461 海明码（二进制位操作应用）  

---

### 代码片段示例
**月影困解法核心**：
```cpp
#include<cstdio>
int main() {
    unsigned int a;
    scanf("%u", &a);
    printf("%u", (a>>16)+(a<<16));
}
```
**关键点**：仅3行代码完成核心逻辑，体现位运算的极致简洁。

---
处理用时：49.55秒
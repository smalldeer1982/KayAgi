# 题目信息

# 拱猪计分

## 题目描述

「拱猪」是一种很有趣的扑克牌游戏。即使你不知道它的玩法，你也可以由它的计分方式来了解它的趣味性。假设在此我们仅考虑四个人的拱猪牌局，本题要求你根据下面的计分规则，在牌局结束时计算四位玩家所得分数。

1. 我们分别以 $\texttt S, \texttt H, \texttt D, \texttt C$ 来代表黑桃、红心、方块及梅花，并以数字 $1$ 至 $13$ 来代表 $\texttt A, \texttt 2, \dots, \texttt Q, \texttt K$ 等牌点，例如：$H_1$ 为红心 $\texttt A$，$S_{13}$ 为黑桃 $\texttt K$；
2. 牌局结束时，由各玩家持有的有关计分的牌（计分牌）仅有「猪」$S_{12}$，所有红心牌，「羊」$D_{11}$ 及「加倍」$C_{10}$ 等 $16$ 张牌，其它牌均弃置不计，若一位玩家未持有这 $16$ 张牌中任意一张，则以得零分计算；
3. 若持有 $C_{10}$ 牌的玩家只有该张牌而没有任何其它牌则得 $+50$ 分，否则将其它计分牌所得分数加倍计算；
4. 若红心牌不在同一家，则 $H_1$ 至 $H_{13}$ 等 $13$ 张牌均以负分计，其数值依次为 $-50, -2, -3, -4, -5, -6, -7, -8, -9, -10, -20, -30, -40$，且 $S_{12}$ 与 $D_{11}$ 的分值分别以 $-100$ 及 $+100$ 分计算；
5. 若红心牌 $H_1$ 至 $H_{13}$ 均在同一家，则有下列情形：

+ 所有红心牌以 $+200$ 分计算。
+ 若 $S_{12}, D_{11}$ 皆在吃下所有红心牌之一家，则此玩家得 $+500$ 分。
+ $C_{10}$ 牌依旧以前文所述原则计算。

例一：若各玩家持有计分牌如下：

1. `S12 H3 H5 H13`
2. `D11 H8 H9`
3. `C10 H1 H2 H4 H6 H7`
4. `H10 H11 H12`

则各家之得分依序为：$-148, +83, -138$ 及 $-60$。

例二：若各玩家持有计分牌如下：

1. `H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13`
2. `S12 C10`
3. `D11`
4. 无

则各家之得分依序为：$+200, -200, +100$ 及 $0$。

例三：若有一玩家持有所有 $16$ 张计分牌，则得 $+1000$ 分，其余三家均得零分。

## 样例 #1

### 输入

```
4  S12  H3  H5  H13
3  D11  H8  H9
6  C10  H1  H2  H4  H6  H7
3  H10  H11 H12
13 H1  H2  H3  H4  H5  H6  H7  H8  H9  H10  H11  H12  H13  
2  S12  C10
1  D11
0
0
0
0
0
```

### 输出

```
-148 +83 -138 -60
+200 -200 +100 0
```

# AI分析结果



### 综合分析与结论
本题需要处理复杂的计分规则，核心难点在于多条件分支的处理（红心全收集、特殊牌组合、C10加倍规则）。各题解均采用模拟思路，差异主要体现在状态标记方式、条件判断顺序和代码结构优化。高质量题解应具备清晰的规则分层处理、高效的状态跟踪机制和简洁的条件表达式。

---

### 高星题解推荐（4星）

#### 1. 作者：Diaоsi（4星）
**关键亮点**：  
- 分层处理红心全收集/未全收集两种主逻辑流  
- 使用vector存储当前玩家的计分牌，便于遍历统计  
- 通过独立计数器判断红心、S12、D11的存在状态  
- 优先处理特殊全收集情况，再用掩码排除已处理项  

**核心代码思想**：
```cpp
int score() {
    // 统计各类牌的存在状态
    int cntH=0, cntC10=0, cntS12=0, cntD11=0;
    for(auto& card : s) {
        if(card[0]=='H') cntH++;
        // 其他牌统计...
    }
    
    // 分层处理红心全收集情况
    if(cntH==13) {
        if(cntS12 && cntD11) ans += 500;
        else ans += 200 + ...;
    } 
    // 普通情况处理
    else {
        for(auto& card : s) {
            // 按牌型累加基础分
        }
    }
    // C10加倍处理
    if(hasC10 && s.size()>1) ans <<= 1;
}
```

#### 2. 作者：juruo_zjc（4星）
**关键亮点**：  
- 使用二维数组`sum[i][j]`标记玩家i是否持有j类牌  
- 将计分规则编码到预定义数组中，简化分数计算  
- 优先处理全红心情况，再处理其他牌的组合逻辑  

**核心代码思想**：
```cpp
for(int i=1;i<=4;i++){
    if(sum[i][1~13全存在]){
        if(同时有S12和D11) 加500;
        else 加200 + 单独计分;
    } else {
        if(无任何计分牌) 检查C10;
        else 遍历各牌累加基础分;
    }
    // C10加倍处理
}
```

---

### 最优解题技巧总结
1. **状态分层处理**：先处理红心全收集的特殊情况，再处理普通情况，避免条件交叉  
2. **预计算分值表**：将红心牌的分值存入数组，通过索引直接获取分值  
3. **掩码式标记**：使用布尔数组或计数器标记特殊牌（S12/D11/C10）的存在状态  
4. **加倍分离计算**：最后统一处理C10的加倍逻辑，避免中间计算干扰  
5. **输入预处理**：将牌面字符串转换为统一编码格式（如H1→1，S12→特殊编码）

---

### 易错点与调试经验
1. **符号输出**：必须对正数添加`+`号（`printf("%+d")`或手动判断）  
2. **全红心边界**：即使收集全红心，仍需单独处理S12/D11的计分（如例2的-200分情况）  
3. **C10孤立判断**：`n==1`时必须与其他牌存在性判断分离  
4. **16张牌特判**：容易遗漏"持有全部16张计分牌得1000分"的规则

---

### 推荐相似题目
1. **P1056 排座椅** - 复杂条件的最优安排模拟  
2. **P1098 字符串的展开** - 多级条件判断与字符串处理  
3. **P1065 作业调度方案** - 状态跟踪与资源分配模拟

---
处理用时：51.30秒
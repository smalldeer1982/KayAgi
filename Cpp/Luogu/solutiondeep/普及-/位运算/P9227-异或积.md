# 题目信息

# 异或积

## 题目背景

$\texttt{id: 4d7e}$

小 H 在课堂上学习了异或运算。

对于两个非负整数 $x,y$，它们的**异或**是指，将它们作为二进制数，对二进制表示中的每一位进行如下运算得到的结果：

- $x$ 和 $y$ 的这一位上不同时，结果的这一位为 $1$；
- $x$ 和 $y$ 的这一位上相同时，结果的这一位为 $0$。

$x$ 和 $y$ 的异或被记为 $x \operatorname{xor} y$ 或 $x \oplus y$。

在 C++ 中，你可以用 `x ^ y` 得到 $x$ 与 $y$ 的异或值。

另外，若干个数的异或称之为**异或和**。

## 题目描述

小 H 还了解到，一个长度为 $n$ 的数列 $a$ 的**异或积**是一个等长的数列 $b$，其中 $b_i$ 等于数列 $a$ 中除了 $a_i$ 以外其他元素的异或和，即
	
$$b_i = \bigoplus \limits_{j = 1}^{n} [j\ne i] a_j$$
	
例如，数列 $\{1, 2, 3, 4\}$ 的异或积为 $\{5, 6, 7, 0\}$。
	
**异或积变换**是指将一个数列用它的异或积替换的过程，由于异或积变换之后数列长度不变，所以异或积变换可以连续进行多次。
	
现在，小 H 有一个长度为 $n$ 的数列 $a$，他想请你帮他计算出 $a$ 经过 $k$ 次异或积变换之后得到的序列。

## 说明/提示

### 样例 1 解释

此样例即为题目描述中的例子。

### 样例 2 解释

第 $1$ 次异或积变换：$\{0,0,0,1\}\to\{1,1,1,0\}$；

第 $2$ 次异或积变换：$\{1,1,1,0\}\to\{0,0,0,1\}$。

### 数据规模与约定

对于 $100\%$ 的测试数据，$1 \le T \le 10$，$2 \le n \le 10^5$，$1 \le k \le 10^{18}$，$0 \le a_i < 2^{32}$。

| 测试点编号 | $n\leq$  | $k \leq$  |特殊性质|
| :----------: | :----------: | :----------: | :-----------: |
| $1 \sim 3$ | $100$ | $100$ | |
| $4 \sim 5$ | $1000$ | $1000$ | |
| $6 \sim 7$ | $3$ | $10^{18}$ | |
| $8 \sim 10$ | $10^5$ | $3$ | |
| $11 \sim 13$ | $10^5$ | $10^{18}$ | $a$ 中所有数的异或和为 $0$ |
| $14 \sim 15$ | $10^5$ | $10^{18}$ | $n$ 为奇数 |
| $16 \sim 17$ | $10^5$ | $10^{18}$ | $n$ 为偶数 |
| $18 \sim 20$ | $10^5$ | $10^{18}$ | |

### 提示

在 C++ 中，对于数据范围 $0\le x<2^{32}$，你可以：

- 使用 `unsigned int x` 来定义；
- 使用 `cin >> x` 或 `scanf("%u", &x)` 来输入；
- 使用 `cout << x` 或 `printf("%u", x)` 来输出。 

## 样例 #1

### 输入

```
1
4 1
1 2 3 4```

### 输出

```
5 6 7 0```

## 样例 #2

### 输入

```
1
4 2
0 0 0 1```

### 输出

```
0 0 0 1```

## 样例 #3

### 输入

```
见附件中的 samples/xor3.in```

### 输出

```
见附件中的 samples/xor3.ans```

# AI分析结果



### 综合分析与结论  
各题解核心思路一致：利用异或性质推导出数列变换后的模式，根据n的奇偶性及k的奇偶性决定最终结果，避免暴力模拟。  
**关键规律**：  
1. 变换后元素为原异或和与原元素的异或（`b_i = sum ^ a_i`）。  
2. 当n为偶数时，两次变换抵消；当n为奇数时，一次变换后结果稳定。  

---

### 高星题解推荐  

#### 1. 作者：hhoppitree（5星）  
**亮点**：  
- 出题人官方题解，数学推导严谨，明确给出异或和的变化规律。  
- 代码简洁高效，直接分奇偶处理，无冗余计算。  
**关键代码**：  
```cpp  
unsigned int sum = 0;  
for (int i = 1; i <= n; i++) sum ^= a[i];  
if (n % 2 || k % 2) {  
    for (int i = 1; i <= n; i++) printf("%u ", sum ^ a[i]);  
} else {  
    // 输出原数组  
}  
```  

#### 2. 作者：卷王（5星）  
**亮点**：  
- 代码极简，直接通过奇偶性判断，逻辑清晰。  
- 突出找规律思维，适合快速解题。  
**核心逻辑**：  
```cpp  
if (n % 2 == 0 && k % 2 == 0) 输出原数组  
else 输出一次变换后的数组  
```  

#### 3. 作者：Link_Cut_Y（4星）  
**亮点**：  
- 通过手动模拟实例验证规律，直观易懂。  
- 附带数学证明，增强说服力。  
**代码片段**：  
```cpp  
long long sum = 0;  
for (int i = 1; i <= n; i++) sum ^= a[i];  
if ((n % 2 == 0 && k % 2 == 1) || (n % 2 != 0)) {  
    // 输出变换后的数组  
}  
```  

---

### 关键思路与技巧  
1. **异或和性质**：变换后的元素等于原异或和与原元素异或。  
2. **奇偶分治**：n的奇偶性决定变换模式是否稳定，k的奇偶性决定是否需要应用变换。  
3. **O(1)次计算**：只需计算一次异或和，避免迭代。  

---

### 类似题目推荐  
1. [P6102 [NOI2019] 异或粽子](https://www.luogu.com.cn/problem/P6102)（异或性质+堆）  
2. [P3917 异或序列](https://www.luogu.com.cn/problem/P3917)（前缀异或和）  
3. [P2114 [NOI2014] 起床困难综合征](https://www.luogu.com.cn/problem/P2114)（位运算贪心）  

---

### 个人心得摘录  
> **August_Light**：  
> “当n为奇数时，无论sum初始值如何，变换后异或和必为0，后续不再变化。”  
> **总结**：抓住n的奇偶性直接决定后续行为，避免复杂推导。  

> **Link_Cut_Y**：  
> “考场上被逼去写作业了，痛失水赛。”  
> **教训**：比赛时需优先验证关键猜想，避免时间分配失误。

---
处理用时：46.69秒
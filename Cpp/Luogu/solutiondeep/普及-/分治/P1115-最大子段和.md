# 题目信息

# 最大子段和

## 题目描述

给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。


## 说明/提示

#### 样例 1 解释

选取 $[3, 5]$ 子段 $\{3, -1, 2\}$，其和为 $4$。

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。


## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
本题核心考察动态规划与贪心思想，最优解法为O(n)时间复杂度的贪心策略。题解中主流思路为维护当前子段和，当和为负时重置，并处理全负数特例。其他方法（分治、线段树）虽正确但非最优，模拟退火等非常规方法适用性差。

---

### 精选题解与亮点

#### 1. 作者：_Arahc_（★★★★★）
**核心亮点**：
- 动态规划结合空间优化，用单变量代替数组，空间降至O(1)
- 通过前缀和推导贪心决策逻辑，解释直观
- 代码高度精简（仅8行核心逻辑）

**关键代码**：
```cpp
int n, a, b, i, ans = -2147483647;
int main() {
    cin >> n;
    for (i=1; i<=n; i++) {
        cin >> a;
        if (i == 1) b = a;
        else b = max(a, b + a);
        ans = max(ans, b);
    }
    cout << ans;
}
```
**实现思想**：用`b`维护以当前元素结尾的最大子段和，`ans`记录全局最大值。

---

#### 2. 作者：Robert（★★★★☆）
**核心亮点**：
- 极简贪心实现，在线处理无需存储数组
- 明确处理全负数特例，鲁棒性强
- 代码仅7行，可读性极佳

**关键代码**：
```cpp
int n, j, sum, maxx;
int main() {         
    scanf("%d%d", &n, &maxx); sum = maxx;
    while(--n) {
        scanf("%d", &j);
        sum = sum > 0 ? sum : 0;
        sum += j;
        maxx = maxx > sum ? maxx : sum;
    }
    printf("%d", maxx);
}
```
**调试心得**：通过`sum = sum > 0 ? sum : 0`避免负积累，隐含重置逻辑。

---

#### 3. 作者：Enigmatic（★★★★☆）
**核心亮点**：
- 完全避免数组存储，空间复杂度O(1)
- 直接在线处理，逻辑清晰无冗余
- 特判全负数情况，覆盖边界条件

**关键代码**：
```cpp
int n, ans = -1e9, tmp = 0, now;
int main() {
    scanf("%d", &n);
    for (int i=1; i<=n; i++) {
        scanf("%d", &now);
        tmp += now;
        if (tmp > ans) ans = tmp;
        if (tmp < 0) tmp = 0;
    }
    printf("%d", ans);
}
```
**优化技巧**：通过`tmp`动态维护当前有效子段和，实时更新最大值。

---

### 最优算法总结
**关键技巧**：
1. **贪心策略**：当当前子段和为负时立即重置，避免拖累后续和。
2. **空间优化**：用单变量代替数组，空间复杂度从O(n)降至O(1)。
3. **特判处理**：全负数时直接取最大元素，保证结果合法。

---

### 拓展训练推荐
1. **P1121 环形最大子段和**  
   - 允许环形数组，需分情况讨论线性最大和跨越首尾的情况。
2. **P1714 切蛋糕**  
   - 限定子段长度不超过m，结合单调队列维护滑动窗口。
3. **P2642 最大子序和（输出区间）**  
   - 要求输出最大子段的起止位置，需记录索引。

---

### 核心代码实现（以贪心为例）
```cpp
int maxSubArray(vector<int>& nums) {
    int cur_sum = 0, max_sum = INT_MIN;
    for (int num : nums) {
        cur_sum = max(cur_sum + num, num);
        max_sum = max(max_sum, cur_sum);
    }
    return max_sum;
}
```
**实现逻辑**：遍历数组，维护`cur_sum`为当前子段和，`max_sum`记录历史最大值。

---
处理用时：61.23秒
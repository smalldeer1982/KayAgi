# 题目信息

# 机器猫斗恶龙

## 题目描述

机器猫出门斗恶龙了！他需要通过 $n$ 个关卡。

每个关卡要么是与怪物战斗，扣除一定的血量；要么是营地，给机器猫增加一定的血量。

在旅途中，机器猫**任意时刻**的血量不能低于或等于 $0$。问机器猫至少需要多少的初始血量，才能完成任务。

血量为正整数。

## 说明/提示

**样例解释**

第二组样例：机器猫带着 $501$ 点血量出门，两场战斗之后剩下 $1$，恢复到 $1001$，两场战斗之后为 $801$，完成任务。

**数据规模与约定**

对于 $100\%$ 的数据，$n\leq 100000, 1\leq |a_i|\leq 1000$。



## 样例 #1

### 输入

```
3
-100 -200 -300```

### 输出

```
601```

## 样例 #2

### 输入

```
5
-200 -300 1000 -100 -100```

### 输出

```
501```

# AI分析结果



### 综合分析与结论
题目要求机器猫在任何时刻血量严格大于0的前提下，找到最小的初始血量。关键思路是找到满足条件的最小初始值，可通过两种方法实现：

1. **二分法**：利用初始血量的单调性，通过二分查找确定最小可行值。时间复杂度O(n log C)，适用于中等数据。
2. **反向动态规划**：从后往前遍历，维护当前关卡所需的最小初始血量，时间复杂度O(n)，为最优解法。

### 精选题解分析

#### 题解作者：ShanCreeperPro（4星）
**关键亮点**：
- 思路清晰，利用二分法的单调性快速定位答案。
- 代码实现简单，适合快速编写和调试。
- 正确性显然，通过模拟检查中间步骤的血量。

**核心思路**：
```cpp
bool check(int x) {
    int hp = x;
    for (int a : arr) {
        hp += a;
        if (hp <= 0) return false;
    }
    return true;
}
```
通过二分法确定最小初始血量，每次调用`check`函数模拟过程，时间复杂度O(n log C)。

### 最优关键思路：反向动态规划
**算法要点**：
- 从后往前遍历关卡，维护进入当前关卡的最小血量`min_health`。
- 递推公式：`min_health = max(min_health - a[i], 1)`。
- 时间复杂度O(n)，空间复杂度O(1)。

**核心代码**：
```cpp
int calculateMinHP(vector<int>& a) {
    int min_health = 1;
    for (int i = a.size() - 1; i >= 0; --i) {
        min_health = max(min_health - a[i], 1);
    }
    return min_health;
}
```

### 拓展与举一反三
**类似题目推荐**：
1. [LEETCODE 174. 地下城游戏](https://leetcode.com/problems/dungeon-game/)：反向动态规划经典题。
2. [洛谷 P1095 守望者的逃离](https://www.luogu.com.cn/problem/P1095)：状态机与动态规划结合。
3. [洛谷 P1280 尼克的任务](https://www.luogu.com.cn/problem/P1280)：逆向时间轴处理动态规划。

**个人心得**：
- **调试重点**：确保每一步血量严格大于0，边界条件需仔细处理。
- **优化经验**：反向动态规划避免中间状态的复杂计算，显著提升效率。

---
处理用时：231.75秒
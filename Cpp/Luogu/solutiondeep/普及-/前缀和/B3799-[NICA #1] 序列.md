# 题目信息

# [NICA #1] 序列

## 题目描述

小 A 有一个长度为 $n$ 的序列 $a_1,a_2,\dots a_n$。他希望支持两种操作：

- `1 k`，给序列中的每一个元素加上一个整数 $k$；
- `2`，查询序列中的最大子序列和。

子序列指的是从原序列中去除某些元素（也可以不去除），但不破坏余下元素的相对位置形成的新的序列。例如，对于序列 $\{2,3,4,5,6\}$，那么 $\{2,3,4\},\{2,4,6\}$ 都是它的子序列，而 $\{6,5,4\}$ 不是。子序列可以为空，此时子序列和为 $0$。

## 说明/提示

**【样例解释】**

- 第一次操作求序列中的最大子序列和，则为 $12+2+8=22$；
- 第二次操作让序列中每一个元素加上了 $3$。此时序列变为 $-2,15,-4,5,11$；
- 第三次操作求序列中的最大子序列和，则为 $15+5+11=31$；
- 第四次操作让序列中每一个元素加上了 $4$。此时序列变为 $2,19,0,9,15$；
- 第五次操作求序列中的最大子序列和，则为 $2+19+9+15=45$。

数据保证，$1 \leq n,m \leq 5\times 10^5$，$-5\times 10^5 \leq a_i,k \leq 5\times 10^5$，操作仅为 $1$ 或 $2$ 操作。

## 样例 #1

### 输入

```
5 5
-5 12 -7 2 8
2
1 3
2
1 4
2```

### 输出

```
22
31
45```

# AI分析结果



### 综合分析与结论

本题核心在于高效维护全局加法操作并快速计算最大子序列和（即所有非负数之和）。各题解主要采用两种思路：**排序+二分+后缀和预处理**与**桶计数前缀和优化**。前者通过排序后二分定位分界点，时间复杂度为 O(n logn + m logn)；后者通过数值离散化实现 O(n + m) 的极致效率，但需要较大空间。桶方法在数值范围可控时最优，排序二分法更通用。

### 高星题解推荐

#### 1. Light_az（桶方法）⭐️⭐️⭐️⭐️⭐️
**关键亮点**：  
- 将数值离散化到桶中，预处理前缀和数组。
- 根据全局增量直接计算有效区间，实现 O(1) 查询。
- 时间复杂度最优（O(n + m)），适合大数据量。

**核心代码**：
```cpp
// 预处理桶计数和前缀和
for (int i = 1; i <= n; i++) {
    cin >> x;
    cnt[500000 + x]++; // 偏移处理负值
    sum[500000 + x] += x;
}
for (int i = 0; i <= 1000000; i++) {
    cnt[i] += cnt[i - 1];
    sum[i] += sum[i - 1];
}

// 查询处理
if (ans > 500000) 
    cout << sum[1000000] + ans * cnt[1000000];
else if (ans < -500000) 
    cout << 0;
else 
    cout << sum[1000000] - sum[500000 - ans] + ans * (cnt[1000000] - cnt[500000 - ans]);
```

#### 2. lrqlrq250（排序+二分）⭐️⭐️⭐️⭐️⭐️
**关键亮点**：  
- 排序后使用 `lower_bound` 快速定位分界点。
- 预处理后缀和避免重复计算，代码简洁高效。

**核心代码**：
```cpp
sort(a + 1, a + n + 1);
for (int i = n; i >= 1; i--) 
    sum[i] = sum[i + 1] + a[i];

// 二分查询
p = lower_bound(a + 1, a + n + 1, -delta) - a;
ans = (p <= n) ? sum[p] + (n - p + 1) * delta : 0;
```

#### 3. 2011FYCCCTA（排序+手写二分）⭐️⭐️⭐️⭐️
**关键亮点**：  
- 手写二分逻辑清晰，预处理倒序后缀和。
- 明确初始化边界条件，鲁棒性强。

**核心代码**：
```cpp
sort(a + 1, a + n + 1);
for (int i = n; i >= 1; i--) 
    sum[i] = a[i] + sum[i + 1];

// 二分逻辑
int p = n + 1, l = 1, r = n;
while (l <= r) {
    int mid = (l + r) / 2;
    if (a[mid] + add > 0) {
        p = mid;
        r = mid - 1;
    } else l = mid + 1;
}
ans = sum[p] + (n - p + 1) * add;
```

### 关键思路总结
1. **数值离散化**：通过偏移将负数映射到正数区间，结合前缀和实现 O(1) 查询。
2. **排序+二分**：利用有序性快速定位有效元素，结合后缀和避免重复计算。
3. **全局增量分离**：维护累计增量而非修改原数组，保证操作高效性。

### 拓展与相似题目
1. **P3368 【模板】树状数组 2**（区间修改+单点查询）
2. **P1115 最大子段和**（经典动态规划变种）
3. **P4552 [Poetize6] IncDec Sequence**（差分数组与全局操作）

### 题解心得分野
- **Light_az**提到桶方法需注意全正数时的边界处理，通过特判避免逻辑错误。
- **lrqlrq250**强调使用 `lower_bound` 简化二分实现，减少编码错误。
- **2011FYCCCTA**在调试中发现倒序预处理更适配升序数组的二分逻辑。

---
处理用时：119.45秒
# 题目信息

# [GESP202409 三级] 平衡序列

## 题目描述

小杨有一个包含 $n$ 个正整数的序列 $a$。他认为一个序列是平衡的当且仅当存在一个正整数 $i$（$1 \leq i < n$）使得序列第 $1$ 到第 $i$ 个数字的总和等于第 $i + 1$ 到第 $n$ 个数字的总和。

小杨想请你判断序列 $a$ 是否是平衡的。

## 说明/提示

### 样例 1 解释

- 对第一组测试用例，令 $i = 2$，有 $i + 2 = 3$，因此序列是平衡的。
- 对第二组测试用例，令 $i = 2$，有 $2 + 3 = 1 + 4$，因此序列是平衡的。
- 对第三组测试用例，不存在满足要求的 $i$。

### 数据规模与约定

对全部的测试数据，保证 $1 \leq t \leq 100$，$1 \leq n, a_i \leq 10000$。

## 样例 #1

### 输入

```
3
3
1 2 3
4
2 3 1 4
5
1 2 3 4 5```

### 输出

```
Yes
Yes
No```

# AI分析结果



### 综合分析与结论

本题的核心是判断是否存在分割点使序列前后和相等。题解1的暴力法因时间复杂度高被淘汰，题解2通过前缀和与总和的关系将时间复杂度优化到O(n)，是本题最优解法。关键技巧在于用一次遍历维护前缀和，并利用总和与当前前缀和的数学关系快速判断。

---

### 所选高星题解分析

#### 题解：思路2（作者：chen_zhe） ★★★★★
**关键亮点**  
1. **时间复杂度优化**：将O(n²)优化为O(n)，通过一次遍历维护前缀和。
2. **数学关系转换**：通过判断前缀和的两倍是否等于总和，避免单独计算后半部分和。
3. **边界处理严谨**：正确处理了分割点必须小于n的隐含条件（通过总和的正整数特性自然规避无效情况）。
4. **多组数据初始化**：强调每组数据需重置变量，避免状态污染。

**个人心得引用**  
> "需要注意，本题有多组测试数据，因此在处理每一组测试数据之前，记录总和、标记答案的相关变量都需要初始化，以免造成意料之外的情况。"  
—— 强调了多测试用例场景的初始化重要性。

#### 核心代码片段
```cpp
int sum = 0, sum2 = 0;
bool flag = false;
for (int i = 1; i <= n; ++i) {
    cin >> a[i];
    sum += a[i];
}
for (int i = 1; i <= n; ++i) {
    sum2 += a[i];
    if (sum2 * 2 == sum) {
        flag = true;
        break;
    }
}
cout << (flag ? "Yes" : "No") << endl;
```
**实现思想**  
1. 第一次遍历计算总和。
2. 第二次遍历累加前缀和，若其两倍等于总和则标记为平衡。
3. 根据标记输出结果。

---

### 拓展与举一反三

**关键技巧总结**  
- **前缀和优化**：通过维护累加值避免重复计算。
- **数学关系转换**：将分割条件转化为总和与当前累积的关系，避免显式分割。

**同类题目推荐**  
1. **洛谷 P1115**：最大子段和（前缀和与动态规划结合）。
2. **洛谷 P1984**：寻找中心下标（类似平衡点问题）。
3. **LeetCode 724**：Find Pivot Index（与本题完全一致）。

**调试经验总结**  
- **多测试用例初始化**：务必在每组数据前重置变量。
- **边界条件验证**：通过数学特性（如总和奇偶性）提前剪枝可优化常数时间。

---
处理用时：89.72秒
# 题目信息

# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# AI分析结果



### 综合分析与结论
本题需构造加分最高的二叉树，核心思路为区间DP。各题解均围绕设计状态`f[i][j]`表示区间`[i,j]`的最大加分，通过枚举根节点并合并左右子树最优解。记录根节点用于前序遍历输出是关键难点。以下为精选的高质量题解：

---

### 精选题解列表

#### 1. **冒泡ioa（★★★★★）**
**关键亮点**  
- 清晰的区间DP递推思路，自底向上填充DP表，避免递归开销。  
- 预处理空子树分值`f[i][i-1]=1`，简化边界条件。  
- 代码简洁高效，时间复杂度`O(n³)`，完全符合题目要求。  

**核心代码**  
```cpp
for (int len = 1; len < n; ++len) { // 区间长度从小到大
    for (int i = 1; i + len <= n; ++i) {
        int j = i + len;
        f[i][j] = f[i + 1][j] + f[i][i]; // 默认左子树为空
        root[i][j] = i;
        for (int k = i + 1; k < j; ++k) { // 枚举根节点
            if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                root[i][j] = k;
            }
        }
    }
}
```

#### 2. **winmt（★★★★☆）**
**关键亮点**  
- 记忆化搜索实现，更直观体现树形结构的递归特性。  
- 显式处理空子树返回值，逻辑清晰易懂。  

**核心代码**  
```cpp
long long search(int L, int r) { // 记忆化搜索计算f[L][r]
    if (L > r) return 1;
    if (f[L][r] == -1) {
        for (int k = L; k <= r; ++k) { // 枚举根节点
            long long now = search(L, k-1) * search(k+1, r) + f[k][k];
            if (now > f[L][r]) {
                f[L][r] = now;
                root[L][r] = k;
            }
        }
    }
    return f[L][r];
}
```

#### 3. **噬月（★★★★☆）**
**关键亮点**  
- 深入讨论边界条件与初始化细节，验证默认处理不影响最终结果。  
- 通过反例分析等号对前序遍历的影响，强化理解。  

**个人心得**  
> "枚举过程中，即使某次计算未考虑子树完整结构，后续区间扩展仍会修正结果，确保全局最优。"

---

### 关键思路总结
1. **状态设计**：`f[i][j]`表示区间`[i,j]`的子树最大加分，`root[i][j]`记录对应根节点。
2. **转移方程**：`f[i][j] = max(f[i][k-1] * f[k+1][j] + a[k])`，枚举`k`为根节点。
3. **边界处理**：空子树分值为1，单节点分值为自身。
4. **前序遍历输出**：利用`root`数组递归输出根→左→右顺序。

---

### 拓展建议
1. **类似题目**  
   - [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)：区间DP经典问题。  
   - [P1273 凸多边形的划分](https://www.luogu.com.cn/problem/P1273)：枚举中间点分割子问题。  
   - [P4342 Polygon](https://www.luogu.com.cn/problem/P4342)：环形区间DP，处理断开环的情况。

2. **优化技巧**  
   - 若需输出所有可能的最大树结构，可记录多个根节点。  
   - 对于大数据，预处理乘积表或使用滚动数组优化空间。

---

### 重点代码片段（冒泡ioa版）
**DP填充与输出**  
```cpp
// 计算最高分
cout << f[1][n] << endl;

// 前序遍历递归输出
void print(int l, int r) {
    if (l > r) return;
    cout << root[l][r] << " ";
    print(l, root[l][r]-1);
    print(root[l][r]+1, r);
}
```

---
处理用时：62.82秒
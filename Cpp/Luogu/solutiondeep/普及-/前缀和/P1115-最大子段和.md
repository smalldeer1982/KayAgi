# 题目信息

# 最大子段和

## 题目描述

给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。


## 说明/提示

#### 样例 1 解释

选取 $[3, 5]$ 子段 $\{3, -1, 2\}$，其和为 $4$。

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。


## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
本题核心是求最大连续子段和，各题解呈现多种解法，其中动态规划（贪心）是主流最优解。关键思路是维护当前子段和，当和为负时重置，确保后续子段不受负收益影响。最优解法时间复杂度O(n)，空间O(1)。

### 精选题解及亮点

#### 1. _Arahc_ 题解（5星）
**关键亮点**：
- 动态规划思路清晰，空间优化至O(1)
- 完整推导过程+代码简化示例
- 包含优化前后代码对比，体现算法优化思维

**核心代码**：
```cpp
int main(){
    cin>>n;
    for(i=1;i<=n;i++){
        cin>>a;
        if(i==1) b=a;
        else b=max(a, b+a);
        ans=max(ans,b);
    }
    cout<<ans;
}
```

#### 2. Robert 题解（4星）
**关键亮点**：
- 贪心思路简洁，代码极简（仅7行）
- 隐式处理全负数情况（通过maxx初始化为首个元素）

**核心代码**：
```cpp
int main(){         
    scanf("%d%d",&n,&maxx); sum=maxx;
    while(--n){
        scanf("%d",&j);
        sum=sum>0?sum:0; sum+=j;
        maxx=maxx>sum?maxx:sum;
    }
    printf("%d",maxx);
}
```

### 关键思路总结
- **核心技巧**：维护当前子段和，若为负则重置（避免拖累后续计算）
- **优化要点**：用变量代替数组保存状态，空间复杂度从O(n)优化至O(1)
- **特判处理**：全负数情况需单独处理，可通过初始值或遍历时记录极值

### 拓展建议与相似题目
**相似算法套路**：
- 滑动窗口（如P1886 滑动窗口）
- 前缀和+单调队列（如P1714 切蛋糕）
- 环形子段和（如P1121 环状最大子段和）

**推荐练习**：
1. P1714 切蛋糕（区间限制下的最大子段和，需单调队列）
2. P1121 环状最大子段和（环形数组变种）
3. P2642 双子序列最大和（双区间分割问题）

---
处理用时：50.59秒
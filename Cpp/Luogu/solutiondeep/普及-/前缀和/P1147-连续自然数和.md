# 题目信息

# 连续自然数和

## 题目描述

对一个给定的正整数 $M$，求出所有的连续的正整数段（每一段至少有两个数），这些连续的自然数段中的全部数之和为 $M$。

例子：$1998+1999+2000+2001+2002 = 10000$，所以从 $1998$ 到 $2002$ 的一个自然数段为 $M=10000$ 的一个解。


## 样例 #1

### 输入

```
10000
```

### 输出

```
18 142 
297 328 
388 412 
1998 2002
```

# AI分析结果



### 综合分析与结论
本题核心是寻找连续自然数段的和等于给定值M。各题解围绕数学公式展开，主要解法包括数学推导、双指针、暴力枚举、前缀和+二分等。最优解法为数学分解因数法（O(√M)）和双指针法（O(M)），其余解法存在效率或实现复杂度问题。

---

### 高分题解精选（评分≥4星）

#### 1. 作者：gzw2005（★★★★★）
**关键亮点**：
- 数学公式推导巧妙，将问题转化为因数分解
- 时间复杂度O(√M)，最优解法
- 代码简洁（仅10行核心逻辑）
**核心思路**：
```cpp
for(int k1=sqrt(2*m);k1>1;k1--) // 枚举因数k1
    if(2*m%k1==0 && (k1+2*m/k1)%2) // 判断奇偶性
        cout << (k2-k1+1)/2 << " " << (k1+k2-1)/2 << endl;
```
**代码要点**：通过 `(L+R)(R-L+1)=2M` 公式分解因数，仅需判断奇偶性即可确定整数解。

#### 2. 作者：Frenix（★★★★☆）
**关键亮点**：
- 尺取法经典应用，滑动窗口思想
- 时间复杂度O(M)，适合中等规模数据
- 代码直观易理解
**核心逻辑**：
```cpp
for(int i=1,j=2; i<=m/2; ) {
    if(sum == m) { // 找到解
        printf("%d %d\n",i,j);
        sum -= i++; // 左指针右移
    } else if(sum < m) sum += ++j; // 右指针右移
    else sum -= i++; // 缩小窗口
}
```
**技巧**：维护动态窗口，通过增减元素调整区间和，类似滑动窗口模板。

#### 3. 作者：lamboo（★★★☆☆→★★★☆）
**关键亮点**：
- 一元二次方程求解，数学推导清晰
- 时间复杂度O(M)，但含浮点运算
**核心公式**：
```
x = [ -1 + sqrt(1 + 8M + 4i² -4i) ] / 2
需验证x为整数且x > i
```

---

### 最优关键思路总结
1. **数学分解法**：利用公式 `(L+R)(R-L+1)=2M`，枚举因数时只需验证奇偶性，避免冗余计算。
2. **双指针滑动窗口**：动态维护区间和，适用于连续子数组类问题。
3. **因数对称性**：当枚举k1时，k2=2M/k1，只需遍历到√(2M)即可覆盖所有因子。

---

### 拓展与同类题型
1. **滑动窗口扩展**：P1638（逛画展）、P1114（最大子段和）
2. **数学公式推导**：P1498（牛顿叠箱）、P2920（时间管理）
3. **因数分解应用**：P1072（Hankson的趣味题）

---

### 题解中的个人心得摘录
1. **gzw2005**：强调分解后的两个因数需一奇一偶，否则无法得到整数解。
2. **lamboo**：提到调试时因未处理浮点精度问题卡顿2小时，建议用`floor(x)`验证整数。
3. **Frenix**：指出左端点超过m/2即可终止循环的边界优化，避免无效计算。

---
处理用时：51.40秒
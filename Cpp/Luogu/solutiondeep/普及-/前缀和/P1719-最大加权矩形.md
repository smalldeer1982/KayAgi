# 题目信息

# 最大加权矩形

## 题目描述

为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。

校长先给他们一个 $n\times n$ 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 $[-127,127]$ ,例如

```plain
 0 –2 –7  0 
 9  2 –6  2
-4  1 –4  1 
-1  8  0 –2
```

在左下角：

```plain
9  2
-4  1
-1  8
```

和为 $15$。

几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？


## 说明/提示

$1 \leq n\le 120$

## 样例 #1

### 输入

```
4
0 -2 -7 0
 9 2 -6 2
-4 1 -4  1 
-1 8  0 -2
```

### 输出

```
15```

# AI分析结果



### 综合分析与结论

各题解核心思路均为二维转一维（矩阵压缩+最大子段和）或二维前缀和枚举。最优解法是**矩阵压缩+一维最大子段和优化**，时间复杂度为 $O(n^3)$，可高效处理 $n=120$ 的数据。二维前缀和直接枚举法（$O(n^4)$）理论会超时，但部分题解通过代码优化或数据较弱通过。

---

### 高星题解推荐

#### 1. Yaser（4.5星）
**关键亮点**：  
- 清晰阐释矩阵压缩思想，将多行合并为一维数组  
- 使用动态规划求解最大子段和，代码结构清晰  
- 通过纵向累加实现行压缩，逻辑简洁  

**核心代码**：
```cpp
void MatrixSum() {
    loop(i, 1, n) {
        mset(temp, 0);
        loop(j, i, n) { // 累加i~j行
            loop(k, 1, n) temp[k] += matrix[j][k];
            Arrsum(); // 调用一维最大子段和
        }
    }
}
```

#### 2. tommymio（5星）
**关键亮点**：  
- 优化最大子段和计算，用单变量代替DP数组  
- 纵向前缀和预处理，减少重复计算  
- 代码简洁高效，无冗余操作  

**核心代码**：
```cpp
for(int i=1;i<=n;++i){
    for(int k=1;k<=i;++k){
        int sum=0;
        for(int j=1;j<=n;++j){
            int tmp = a[i][j] - a[i-k][j]; // 压缩后的列值
            sum = (sum<0) ? tmp : sum+tmp; // 动态更新sum
            ans = max(ans, sum);
        }
    }
}
```

#### 3. X_WT（4星）
**关键亮点**：  
- 详细推导纵向前缀和压缩过程  
- 结合最大子段和DP公式，逻辑清晰  
- 变量命名规范，适合初学者理解  

---

### 最优关键思路总结

1. **矩阵压缩**：枚举子矩阵的上下边界 $i$ 和 $j$，将 $i$ 到 $j$ 行的每列求和，压缩为一维数组。
2. **一维最大子段和**：对压缩后的数组使用 $O(n)$ 贪心或DP求解，维护全局最大值。
3. **纵向前缀和优化**：预处理每列的纵向前缀和，快速计算任意行区间的列和。

---

### 拓展与相似题目推荐

1. **P1115 最大子段和**（一维基础）  
2. **P2642 棋盘游戏**（二维前缀和+最值查询）  
3. **P2004 领地选择**（二维前缀和+固定尺寸子矩阵）

---

### 调试心得摘录

- **tommymio**：  
  > "当sum为负时直接重置，避免拖累后续计算，这一优化将空间复杂度从O(n)降为O(1)。"  

- **星之海**：  
  > "矩阵压缩的b数组必须每次清空，否则会累积错误数据。"  

- **Stella_Yan**：  
  > "二维前缀和公式易漏交叉项，建议画图理解容斥原理。"  

---

### 核心代码实现示例（tommymio优化版）

```cpp
int main() {
    // 输入与纵向前缀和预处理
    for(int i=1; i<=n; ++i) 
        for(int j=1; j<=n; ++j)
            a[i][j] += a[i-1][j];

    int ans = -INF;
    for(int i=1; i<=n; ++i) { // 枚举下边界
        for(int k=1; k<=i; ++k) { // 子矩阵高度k
            int sum = 0;
            for(int j=1; j<=n; ++j) { // 处理每列
                int val = a[i][j] - a[i-k][j];
                sum = max(val, sum + val); // 贪心更新
                ans = max(ans, sum);
            }
        }
    }
    cout << ans;
}
```

---
处理用时：64.44秒
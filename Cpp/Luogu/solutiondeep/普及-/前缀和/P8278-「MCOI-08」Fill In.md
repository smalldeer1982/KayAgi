# 题目信息

# 「MCOI-08」Fill In

## 题目背景

$$\begin{aligned}\text{sdjvlajdiofjoiw{\color{1f1e33}n}eglaj}\\\text{pcji{\color{1f1e33}2}gweiruitowoeuri}\\\text{cnvak{\color{1f1e33}5}jflkjweirqoiru}\\\text{rrrwei{\color{1f1e33}f}dlskfjqfafdfaff}\\\text{nmslfjwiejfijlxkjfq{\color{1f1e33}b}el}\\\text{mmm{\color{1f1e33}b}fsfmkdfmksld}\\\text{erjf{\color{1f1e33}n}kerjkwerjkwjeri}\\\text{sdfafafaf{\color{1f1e33}r}fxvzxvzvzx}\end{aligned}$$

## 题目描述

Dream 有一个长度为 $n$（$1\le n\le 10^5$）的正整数数组 $a_1,a_2,\dots,a_n$，其中对于 $i=1,2,\dots,n$，满足 $1\le a_i\le 1000$。

他计算了前缀和数组 $p_i=a_1+a_2+\dots+a_i$，保证对于 **原前缀和数组** 有任意 $1 \le i <n$ 都有 $p_i<p_{i+1}$。

现在 Tommy 偷走了这个数组以及将 $p$ 的若干个元素替代为 $-1$。给定当前的 $p$ 数组，请恢复任意一组合法 $a_1,a_2,\dots,a_n$，可证明一定存在一个数组 $a_i$ 满足要求。

## 说明/提示

#### 样例 1 解释

输出的序列 $a_i$ 一定满足要求：

- $p_1=10=a_1$；
- $p_3=20=a_1+a_2+a_3$；
- $p_5=30=a_1+a_2+a_3+a_4+a_5$。

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n,\sum n\le 10^5$，并保证存在至少一个合法 $a$ 数组。

 - Subtask 1（50 pts）：对于 $i=1,2,\dots,n$，$p_i\neq -1$；
 - Subtask 2（30 pts）：保证不存在 $i$ 使得 $p_i=p_{i+1}=-1$；
 - Subtask 3（20 pts）：无特殊限制。

## 样例 #1

### 输入

```
2
5
10 -1 20 -1 30
6
-1 -1 -1 -1 -1 -1```

### 输出

```
10 5 5 5 5
1 1 4 5 1 4```

# AI分析结果



### 综合分析与结论

本题核心在于处理前缀和数组中连续的未知区域（-1），需保证构造的数组元素在 [1,1000] 范围内。各题解共性思路是分段处理已知点间区间，通过均分差值避免数值溢出。最优解法需满足以下要点：

1. **分段均分**：将两个已知前缀和点间的差值均分到对应区间，余数优先分配至前部元素。
2. **末尾处理**：连续未知结尾部分直接填1。
3. **数值调整**：对可能超出1000的数值进行回传调整（部分题解特有）。

以下精选题解均实现上述要点，评分4星及以上。

---

### 精选题解分析

#### 1. SSqwq_（★★★★☆）
**关键亮点**：
- **简洁高效**：单次遍历完成区间划分与数值分配，时间复杂度O(n)。
- **余数前移**：通过整除和余数分配策略保证数值均匀分布。
- **末尾处理**：最后未处理的-1直接输出1。

**核心代码**：
```cpp
for(int j=0;j<mult-1;j++) {
    printf("%d ",p[i]/mult); // 均分到区间
    tmp -= p[i]/mult;
}
printf("%d ",tmp); // 余数给最后一个位置
```
**实现思想**：记录当前区间长度，遇到已知点时均分差值，余数放在区间末尾。

---

#### 2. TheSky233（★★★★★）
**关键亮点**：
- **安全调整机制**：对超出1000的数值向前回传调整，确保所有元素合法。
- **向上取整策略**：优先填充前面元素，避免后续数值溢出。

**调试心得**：
> "余数处理时需向前传递多余值，若某位置已达1000则跳过，直到所有数值合法。"

**核心代码**：
```cpp
int shang=sum/(r-l+1), yu=sum-shang*(r-l+1);
for(int j=l;j<=r;j++) a[j]=shang;
for(int j=l;j<l+yu;j++) a[j]++; // 余数前移
```
**实现思想**：均分后若余数存在，优先给前部元素+1，保证后续元素不超过1000。

---

#### 3. Dream_weavers（★★★★☆）
**关键亮点**：
- **结构体记录区间**：清晰划分已知点间区域，便于后续处理。
- **数学分配**：通过整除和模运算实现均分，代码可读性强。

**核心代码**：
```cpp
shang = sum / (r-l+1);
yu = sum % (r-l+1);
for(int j=l; j<=r; j++) a[j] = shang;
for(int j=l; j<l+yu; j++) a[j]++; // 余数分配
```
**实现思想**：用结构体存储区间信息，计算平均后处理余数，前部元素优先增加。

---

### 最优思路总结
1. **分段处理**：遍历前缀和数组，将连续的-1区间视为待处理段，找到最近左右已知点计算差值。
2. **均分策略**：将差值均分到区间内元素，余数优先分配给前部位置，避免后续元素溢出。
3. **末尾补1**：对结尾未知部分直接填充1，确保递增性。
4. **调整机制**（可选）：对可能超出1000的元素向前回传调整，确保合法性。

---

### 拓展题目推荐
1. **P1115 最大子段和**（前缀和极值应用）
2. **P3406 海底高铁**（差分数组与前缀和结合）
3. **P3667 切木棍**（区间划分与数值分配）

---

### 关键实现代码示例
以TheSky233的调整机制为例：
```cpp
if (ans[tot] > 1000) {
    int loj = ans[tot] - 1000;
    ans[tot] = 1000;
    while (loj > 0) {
        for (int k = tot-1; k >= start; k--) {
            if (ans[k] < 1000) {
                int add = min(loj, 1000 - ans[k]);
                ans[k] += add;
                loj -= add;
                if (loj == 0) break;
            }
        }
    }
}
```
此代码确保超出部分被前向分配，直至所有数值≤1000。

---
处理用时：71.23秒
# 题目信息

# [CRCI 2008] PLATFORME 平板

## 题目描述

为了进行一种游戏，现决定搭造一些平板，而各个平板的地址已经选定。基于最普遍的认识，没有任何支持物的平板不可能漂浮在空中。说的更精确些，任意一平板的两端必需有支柱或者它在另一块平板上。

你会得到各个平板在坐标系中的坐标（如左下图）。每一块平板的坐标都是由它的高度（与地板间的垂直距离）和它的水平方位（开始和结束）决定的。每个支柱都距它支撑的平板的边缘半个单位（如图）。

算出支持所有平板的支柱的总长度。

 ![](https://cdn.luogu.com.cn/upload/pic/994.png) 



## 样例 #1

### 输入

```
3

1 5 10

3 1 5

5 3 7

```

### 输出

```
14```

# AI分析结果

### 综合分析与结论
本题主要是计算支撑所有平板的支柱总长度。各题解思路大致可分为暴力枚举和使用线段树两类。
- **暴力枚举**：因数据范围小（N 最大为 100），可通过双重循环枚举每个平板，为其左右端点寻找合适的支撑平板，计算支柱长度。部分题解还对平板按高度排序，以简化寻找支撑平板的过程。
- **线段树**：将平板按高度排序后，用线段树维护每个位置的最大高度，通过单点查询获取左右端点下的最大高度，区间修改更新平板覆盖区间的高度。

### 高评分题解
1. **作者：mzyy1001（5 星）**
    - **关键亮点**：思路清晰，代码简洁，直接用双重循环暴搜，无需排序，对判断条件的处理明确。
    - **核心代码**：
```cpp
for(int i = 1;i <= n;i++)
{
    int y = a[i].y,x1 = a[i].x1,x2 = a[i].x2;  
    int h1 = 0,h2 = 0;
    for(int j = 1;j <= n;j++)
    {
        if(i == j) 
            continue;
        if(a[j].y >= y) 
            continue;
        if(a[j].x2 > x1 && a[j].x1 <= x1)
            h1 = max(h1,a[j].y);
        if(a[j].x2 >= x2 && a[j].x1 < x2)
            h2 = max(h2,a[j].y);
    }
    ans += y * 2 - h1 - h2;
}
```
    - **核心思想**：外层循环遍历每个平板，内层循环为当前平板的左右端点寻找合适的支撑平板，记录左右端点下的最大高度，最后计算支柱长度并累加到结果中。
2. **作者：Makasukaka（4 星）**
    - **关键亮点**：提供了两种解法，n^2 解法思路清晰，nlogn+nlogh 解法使用线段树优化，对线段树的使用和问题处理有详细解释。
    - **nlogn+nlogh 核心代码**：
```cpp
sort(a+1,a+1+n,cmp);
build(1,1,N);
for(int i = 1;i <= n;++i)
{
    int l=a[i].x1,r=a[i].x2;
    int d=query(1,l,l+1);
    ans+=(a[i].y-d);
    d=query(1,r-1,r);
    ans+=(a[i].y-d);
    insert(1,l+1,r-1,a[i].y);
}
```
    - **核心思想**：先对平板按高度排序，构建线段树。遍历每个平板，通过线段树查询左右端点下的最大高度，计算支柱长度并累加到结果中，最后更新平板覆盖区间的高度。
3. **作者：hongzy（4 星）**
    - **关键亮点**：思路简洁，代码可读性高，通过排序和模拟，对判断条件进行封装，使代码逻辑清晰。
    - **核心代码**：
```cpp
sort(A+1, A+N+1);
for(int i=1; i<=N; i++) {
    int lcost = -1, rcost = -1;
    for(int j=i-1; j>=0; j--) {
        if(lcost!= -1 && rcost!= -1) break;
        if(A[j].h < A[i].h) {
            if(lcost == -1 && Check(A[j].l, A[j].r, A[i].l, 1)) lcost = A[i].h - A[j].h;
            if(rcost == -1 && Check(A[j].l, A[j].r, A[i].r, 0)) rcost = A[i].h - A[j].h;
        }
    }
    ans += lcost + rcost;
}
```
    - **核心思想**：对平板按高度排序，遍历每个平板，为其左右端点寻找合适的支撑平板，计算支柱长度并累加到结果中，找到解后立即退出内层循环。

### 最优关键思路或技巧
- **数据结构**：线段树可用于维护区间信息，在本题中可高效查询和更新每个位置的最大高度。
- **算法优化**：对平板按高度排序，可减少不必要的比较，提高暴力枚举的效率。
- **思维方式**：将问题转化为为每个平板的左右端点寻找合适的支撑平板，简化问题。
- **代码实现技巧**：封装判断条件，使代码逻辑更清晰；使用结构体存储平板信息，方便管理。

### 拓展思路
同类型题或类似算法套路：
- 区间覆盖问题：可使用线段树维护区间信息，解决区间覆盖、查询等问题。
- 平面几何问题：涉及平面上的线段、区域等，可通过排序、枚举等方法解决。

### 推荐题目
1. [P1816 忠诚](https://www.luogu.com.cn/problem/P1816)：线段树单点查询、区间修改问题。
2. [P2068 统计和](https://www.luogu.com.cn/problem/P2068)：区间查询、修改问题，可使用线段树解决。
3. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：线段树基础模板题，包含区间修改和查询操作。

### 个人心得摘录与总结
- **作者：重回巅峰！**：卡题多次，总结出将读入数据扩大两倍方便计算，数组不能开小的教训。
- **作者：谬悠**：因用不来线段树，选择模拟解法，通过给左右坐标乘 2 处理支柱位置问题。
- **作者：rfsfreffr**：实现过程中被 double 与 int 的使用困扰，意识到建造支柱时每下降一格都要判断是否落在其他板子上。 

---
处理用时：33.91秒
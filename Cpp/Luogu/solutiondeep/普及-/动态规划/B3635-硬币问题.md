# 题目信息

# 硬币问题

## 题目描述

今有面值为 1、5、11 元的硬币各无限枚。

想要凑出 $n$ 元，问需要的最少硬币数量。

## 说明/提示

#### 样例解释

对于样例数据 1，最佳方案是 $15=5+5+5$，使用到 3 枚硬币。

对于样例数据 2，最佳方案是 $12=11 + 1$，使用到 2 枚硬币。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $n\leq 10^6$。

## 样例 #1

### 输入

```
15```

### 输出

```
3```

## 样例 #2

### 输入

```
12```

### 输出

```
2```

# AI分析结果



### 综合分析与结论
该题属于典型动态规划问题，核心在于构建状态转移方程。贪心算法虽直观但存在反例，动态规划能确保全局最优解。各题解均指向同一解法思路，核心差异在于边界处理与实现细节。

---

### 精选题解分析

#### 题解作者：ShanCreeperPro（★★★★★）
**关键亮点**：
1. 通过反例直击贪心算法缺陷，强化动态规划的必要性
2. 表格法清晰展现状态转移过程，辅助理解递推关系
3. 明确指出越界处理思路（例如初始化前11项）

**个人心得引用**：
> "贪心方法是 $11+1+1+1$，而最优却是 $5+5+5$" —— 通过样例对比直观说明贪心的局部最优陷阱

---

### 核心代码实现
```cpp
vector<int> f(n+1);
f[0] = 0;
for(int i=1; i<=n; ++i) {
    f[i] = f[i-1] + 1;  // 初始化为1元硬币方案
    if(i >=5) f[i] = min(f[i], f[i-5]+1);  // 尝试用5元优化
    if(i >=11) f[i] = min(f[i], f[i-11]+1); // 尝试用11元优化
}
return f[n];
```

**实现要点**：
1. 初始化时直接处理`f[0]`作为递推起点
2. 通过条件判断逐步引入更大面额的优化可能
3. 每步仅需比较三种子状态的最小值

---

### 同类拓展与优化
1. **变种题型**：若硬币数量有限（如01背包问题），需调整状态转移方程
2. **空间优化**：可滚动数组将空间复杂度降至$O(1)$（仅保留最近需要的状态）
3. **时间复杂度**：当面额种类为$k$时，复杂度为$O(kn)$，适用于$n\leq10^7$规模

---

### 推荐练习题
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)（01背包模板题）
2. [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)（完全背包拓展）
3. [P5662 纪念品](https://www.luogu.com.cn/problem/P5662)（动态规划与贪心结合）

---
处理用时：47.01秒
# 题目信息

# 最长上升子序列

## 题目描述

这是一个简单的动规板子题。

给出一个由 $n(n\le 5000)$ 个不超过 $10^6$ 的正整数组成的序列。请输出这个序列的**最长上升子序列**的长度。

最长上升子序列是指，从原序列中**按顺序**取出一些数字排在一起，这些数字是**逐渐增大**的。

## 说明/提示

分别取出 $1$、$2$、$3$、$4$ 即可。

## 样例 #1

### 输入

```
6
1 2 4 1 3 4```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
本题要求最长严格递增子序列长度，动态规划是基础解法。ShanCreeperPro 的题解采用经典 O(n²) DP 思路，适用于题目数据规模且易于理解，但未提及更优的 O(n log n) 二分优化方法。

---

### 所选优质题解

#### 题解作者：ShanCreeperPro（★★★★☆）
**关键亮点**  
- 清晰的 DP 状态定义：`f[i]` 表示以第 i 个元素结尾的 LIS 长度  
- 直观的双层循环递推逻辑，配合样例表格辅助理解  
- 强调初始化每个位置的默认长度为 1  
- 覆盖了上升子序列的拼接思想（当前元素与前面更优子序列合并）

**个人心得提炼**  
- 在双层循环中，外层遍历每个元素，内层遍历其所有前驱元素，通过比较 `a[j] < a[i]` 确保严格递增  
- 初始化每个 `f[i]` 为 1 是必要步骤，因为单个元素本身构成长度为 1 的子序列  

---

### 核心代码实现
```cpp
int main() {
    int n, a[5005], f[5005], ans = 0;
    cin >> n;
    for (int i = 0; i < n; ++i) cin >> a[i];
    for (int i = 0; i < n; ++i) {
        f[i] = 1; // 初始化为1
        for (int j = 0; j < i; ++j) {
            if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1);
        }
        ans = max(ans, f[i]);
    }
    cout << ans;
}
```
**实现思想**  
- 外层循环遍历每个元素，计算其对应的 `f[i]`  
- 内层循环检查所有前驱元素，通过状态转移方程 `f[i] = max(f[i], f[j]+1)` 更新最优解  
- 最终取 `f` 数组的最大值即为答案  

---

### 关键优化与拓展思路
**更优解法（O(n log n)）**  
维护一个 `tail` 数组，记录长度为 `i+1` 的 LIS 的最小末尾元素。对每个元素用二分查找插入位置，更新 `tail` 数组：
```cpp
vector<int> tail;
for (int x : a) {
    auto it = lower_bound(tail.begin(), tail.end(), x);
    if (it == tail.end()) tail.push_back(x);
    else *it = x;
}
return tail.size();
```

**类似题型推荐**  
1. P1020 [导弹拦截](https://www.luogu.com.cn/problem/P1020)（LIS 变形）  
2. P1091 [合唱队形](https://www.luogu.com.cn/problem/P1091)（双向 LIS 应用）  
3. P1439 [最长公共子序列](https://www.luogu.com.cn/problem/P1439)（LCS 转 LIS 优化）  

---

### 调试与踩坑经验
- **初始值遗漏**：每个 `f[i]` 必须初始化为 1，否则无法正确处理单个元素的情况  
- **严格递增判断**：条件必须为 `a[j] < a[i]`，写成 `<=` 会导致求非严格递增序列  
- **更新最大值位置**：在每轮外层循环后立即更新全局最大值，减少最后遍历的开销

---
处理用时：54.76秒
# 题目信息

# [信息与未来 2014] 最大连续部分和

## 题目描述

有 $n$ 个整数排成一排，求其中的最大连续部分和。

**至少要选一个数。**

## 说明/提示

$1\le n\le 10^7,0\le |x_i|\le 10^8$。

## 样例 #1

### 输入

```
7
-2 13 12 9 14 -10 2```

### 输出

```
48```

# AI分析结果



### 综合分析与结论
本题是经典的最大子数组和问题，核心挑战在于 O(n) 时间复杂度的实现。由于数据规模达到 1e7，必须采用线性扫描算法。Kadane 算法是唯一可行的解法，其他思路（如暴力枚举、分治等）均无法通过时间限制。

---

### 最优题解推荐（假设生成）

#### 题解：Kadane 算法（★★★★★）
**关键亮点**  
- 线性时间复杂度 O(n)，空间复杂度 O(1)
- 动态维护当前连续和，遇负及时重置
- 正确处理全负数等边界情况

**核心代码实现**  
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, x;
    scanf("%d", &n);
    
    long long current, max_sum;
    scanf("%lld", &current);
    max_sum = current;
    
    for (int i = 1; i < n; ++i) {
        scanf("%d", &x);
        current = max((long long)x, current + x); // 核心决策：延续或重置
        max_sum = max(max_sum, current);
    }
    printf("%lld\n", max_sum);
    return 0;
}
```

**个人心得**  
- 初始值必须设为第一个元素而非 0，确保全负数场景正确
- 用 `long long` 避免求和溢出
- 逐元素读取减少内存占用，适合大输入规模

---

### 关键技巧总结
1. **动态维护状态**：Kadane 算法的核心在于维护当前连续和，遇到负数时及时重置，体现贪心思想。
2. **边界处理**：通过初始值直接设置为第一个元素，而非从 0 开始，可正确处理全负数场景。
3. **空间优化**：逐元素读取而非存储整个数组，节省内存空间。

---

### 拓展与同类题目
- **环状数组最大和**：破环成链或同时维护最小子段和（如洛谷 P1121）
- **乘积最大子数组**：需同时维护最大正值和最小负值（LeetCode 152）
- **双子序列最大和**：分割点两侧分别应用 Kadane 算法（洛谷 P2642）

---

### 推荐练习题目
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115) - 模板题
2. [P1121 环状最大子段和](https://www.luogu.com.cn/problem/P1121) - 环状变种
3. [P2642 双子序列最大和](https://www.luogu.com.cn/problem/P2642) - 双区间扩展

---
处理用时：50.12秒
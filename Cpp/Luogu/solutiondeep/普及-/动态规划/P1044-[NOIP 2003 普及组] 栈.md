# 题目信息

# [NOIP 2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# AI分析结果



### 综合分析与结论
本题考察栈操作序列的计数问题，本质是计算卡特兰数。题解主要围绕卡特兰数的四种公式展开，辅以动态规划、记忆化搜索等实现方式。最优解法为直接应用卡特兰数递推公式，时间复杂度O(n)，空间效率优异。

---

### 精选题解与评分

#### 1. 作者：xiejinhao（⭐⭐⭐⭐⭐）
**关键亮点**  
- 提供4种解法：记忆化搜索、递推DP、组合数公式、高精度打表  
- 数学推导清晰，包含卡特兰数不同公式的对比分析  
- 代码示例完整，覆盖所有主流解法

**核心代码（递推公式）**  
```cpp
// 公式2递推实现
long long f[MAX_N];
f[0] = f[1] = 1;
for(int i=2; i<=n; i++)
    f[i] = f[i-1]*(4*i-2)/(i+1);
```

#### 2. 作者：inexistent（⭐⭐⭐⭐）
**关键亮点**  
- 通过分治思想推导卡特兰数递推式，数学直观  
- 结合栈操作过程解释公式意义，便于理解  
- 代码简洁，直接应用递推公式

**推导要点**  
```text
当第一个元素k最后出栈时，方案数为f(k-1)*f(n-k)
总和即为h(n) = Σh(k-1)h(n-k) (k=1~n)
```

#### 3. 作者：Shmily_389704（⭐⭐⭐⭐）
**关键亮点**  
- 二维DP状态定义清晰模拟栈操作  
- 状态转移方程直观体现进出栈决策  
- 代码简洁，适合动态规划学习者

**核心代码**  
```cpp
int f[20][20];
for(int i=0; i<=n; i++) f[0][i] = 1;
for(int i=1; i<=n; i++)
    for(int j=i; j<=n; j++)
        f[i][j] = (i==j) ? f[i-1][j] : f[i][j-1] + f[i-1][j];
```

---

### 关键思路与技巧
1. **卡特兰数公式**：直接应用h(n) = C(2n,n)/(n+1) 或递推式 h(n) = h(n-1)*(4n-2)/(n+1)  
2. **动态规划建模**：定义状态f[i][j]表示栈内i个元素、未进栈j个元素时的方案数  
3. **记忆化搜索优化**：通过缓存中间结果避免重复计算，将指数级复杂度降至O(n²)

---

### 拓展练习
1. [P1976 鸡蛋饼](https://www.luogu.com.cn/problem/P1976) - 圆上弦不相交方案数  
2. [P1754 球迷购票问题](https://www.luogu.com.cn/problem/P1754) - 卡特兰数经典应用  
3. [P2532 树屋阶梯](https://www.luogu.com.cn/problem/P2532) - 卡特兰数+高精度处理  

---

### 调试心得摘录
- **xiejinhao**："注意组合数公式在取模时的风险，优先选择减法公式"  
- **荼白**："调试时发现二维数组初始化边界条件容易遗漏，特别是f[0][j]全为1"  
- **Wind_Shear**："Python递归会超时，改用递推后效率提升百倍，说明算法选择至关重要"  

---

### 核心代码实现
**最优解（卡特兰递推式）**  
```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    long long ans = 1;
    cin >> n;
    for(int i=2; i<=n; i++) 
        ans = ans * (4*i-2) / (i+1);
    cout << ans;
    return 0;
}
```

---
处理用时：51.55秒
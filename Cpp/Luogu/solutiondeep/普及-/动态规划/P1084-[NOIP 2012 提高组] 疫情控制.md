# 题目信息

# [NOIP 2012 提高组] 疫情控制

## 题目描述

H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。

H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。


## 说明/提示

【输入输出样例说明】

第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到$ 3$ 号点设立检查点，所需时间为 $3$ 个小时。

 
【数据范围】

保证军队不会驻扎在首都。

- 对于 $20\%$ 的数据，$2 \le n\le 10$；
- 对于 $40\%$ 的数据，$2 \le n\le 50$，$0<w <10^5$；
- 对于 $60\%$ 的数据，$2 \le n\le 1000$，$0<w <10^6$；
- 对于 $80\%$ 的数据，$2 \le n\le 10^4$；
- 对于 $100\%$ 的数据，$2\le m\le n≤5\times 10^4$，$0<w <10^9$。


NOIP 2012 提高组 第二天 第三题


## 样例 #1

### 输入

```
4 
1 2 1 
1 3 2 
3 4 3 
2 
2 2```

### 输出

```
3```

# AI分析结果



### 题解综合分析结论
本题核心解法为「二分答案 + 树上贪心」，所有题解均围绕该框架展开。核心优化点集中在预处理移动路径、处理闲置军队、子树覆盖验证三个环节。差异主要体现在预处理方式（倍增/DFS）、贪心策略细节、代码实现复杂度等方面。

---

### 高评分题解亮点分析

#### 1. TEoS题解（★★★★★）
**关键亮点**：  
- 清晰的树上倍增预处理实现，完整标注关键代码段  
- 双重贪心策略（优先处理闲置军队 + 排序匹配）  
- 详尽的调试案例和可视化解释  
**核心代码思想**：  
```cpp
// 树上倍增预处理
void bfs() {
    q.push(1); d[1] = 1;
    while(q.size()) {
        int x = q.front(); q.pop();
        for(int i=head[x];i;i=Next[i]) {
            int y = ver[i];
            if(d[y]) continue;
            d[y] = d[x]+1;
            f[y][0] = x; dist[y][0] = edge[i];
            // 递推倍增数组...
        }
    }
}
```
**个人心得**：  
作者强调在实现时需特别注意「根节点子树的独立处理」，通过分离`need[]`数组避免状态污染，调试时通过构造特定测试案例验证边界条件。

---

#### 2. FlashHu题解（★★★★☆）
**关键亮点**：  
- 用DFS代替倍增实现O(n log nw)复杂度  
- 创新性使用指针动态维护可用军队  
- 代码量精简但保留关键注释  
**核心优化点**：  
```cpp
// DFS替代倍增预处理
void dfs(int x, int fa) {
    for(auto [v,w] : g[x]) if(v != fa) {
        d[v] = d[x] + w;
        dfs(v, x);
        low[x] = min(low[x], low[v] + w);
    }
    if(low[x] <= T) cov[x] = 1; // 动态判定覆盖
}
```

---

#### 3. Morning_Glory题解（★★★★☆）
**关键亮点**：  
- 引入优先队列优化匹配过程  
- 显式处理无法返回原点的军队  
- 完整特判无解情况  
**贪心策略**：  
优先用剩余时间最大的军队覆盖距离最远的子树，通过双指针实现高效匹配。

---

### 最优思路总结
1. **二分框架**：在[0, 总边权]区间二分最大移动时间。
2. **树上倍增预处理**：快速计算军队可达的最高位置。
3. **分类处理军队**：
   - 无法到达根节点的军队：就地驻扎控制子树。
   - 可到达根节点的军队：记录剩余时间并排序。
4. **子树覆盖检查**：DFS标记未被覆盖的子树，收集需覆盖的根节点子节点。
5. **贪心匹配**：将剩余时间最大的军队优先分配给距离最远的子树。

---

### 拓展练习推荐
1. [P5021 赛道修建](https://www.luogu.com.cn/problem/P5021)  
   - 同样使用二分答案 + 树形贪心策略，重点考察路径选择。
2. [P2680 运输计划](https://www.luogu.com.cn/problem/P2680)  
   - 结合LCA和路径覆盖，需要类似的时间优化技巧。
3. [P4381 岛屿](https://www.luogu.com.cn/problem/P4381)  
   - 环形树结构上的贪心策略，训练复杂场景分析能力。

---

### 调试经验总结
- **边界条件**：特别注意军队数 < 根节点度数时直接无解。
- **倍增实现**：递推时需从高位向低位枚举，避免跳跃不足。
- **状态污染**：每次check需重置标记数组，避免残留数据干扰。
某题解作者提到：「在匹配时若剩余时间相同的军队，优先处理原属该子树的军队，可避免跨子树匹配导致的逻辑错误」。

---
处理用时：57.35秒
# 题目信息

# 最大子段和

## 题目描述

给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。


## 说明/提示

#### 样例 1 解释

选取 $[3, 5]$ 子段 $\{3, -1, 2\}$，其和为 $4$。

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。


## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
本题核心是求连续非空子段的最大和，数据规模达2e5，要求O(n)算法。主流解法为贪心或动态规划，通过维护当前子段和，当和为负时重置。此外分治、前缀和+单调队列也是可行解法，但线性方法更优。需特别注意全负数情况的处理。

---

### 高星题解亮点分析

#### 1. 作者：_Arahc_（5星）
**核心亮点**：  
- 清晰的贪心思路：维护当前有效子段和，若加入新元素后总和更优则保留，否则重置
- 空间优化至O(1)，仅用变量滚动计算
- 详细样例推导与状态转移解释
- 正确处理全负数情况（通过初始化ans为极小值）

**关键代码**：
```cpp
int n, a, b, i, ans = -2147483647;
cin >> n;
for(i=1; i<=n; i++){
    cin >> a;
    if(i==1) b = a;
    else b = max(a, b + a); // 核心决策
    ans = max(ans, b);
}
```

#### 2. 作者：Robert（4.5星）
**核心亮点**：  
- 极简贪心实现（仅7行代码）
- 实时维护sum与maxx，sum<0时重置
- 处理全负数情况通过初始读取第一个值为maxx

**关键代码**：
```cpp
int n, j, sum, maxx;
scanf("%d%d", &n, &maxx);
sum = maxx;
while(--n){
    scanf("%d", &j);
    sum = sum>0 ? sum : 0; // 负数则重置
    sum += j;
    maxx = maxx>sum ? maxx : sum;
}
```

#### 3. 作者：mohei0（4星）
**核心亮点**：  
- 前缀和+前缀最小值优化
- 数学推导：max_sub = sum[i] - min_prefix
- 清晰展示如何通过预处理降复杂度

**关键代码**：
```cpp
for(int i=1; i<=n; i++){
    sum[i] = sum[i-1] + a[i];
    min_prefix = min(min_prefix, sum[i-1]);
    max_sub = max(max_sub, sum[i] - min_prefix);
}
```

---

### 最优思路总结
**核心技巧**：  
1. **贪心决策**：若当前子段和为正则继续累加，否则重置（`sum = max(a[i], sum + a[i])`）
2. **空间优化**：用滚动变量替代数组，空间复杂度O(1)
3. **边界处理**：初始化ans为极小值，单独处理全负数情况
4. **前缀和极值**：维护前缀和最小值，用当前前缀和减最小值得到最大子段

---

### 拓展与相似题目
1. **环形最大子段和**（P1121）  
   破环成链后求最大子段，或总和减去最小子段
2. **最大子矩阵**（P1719）  
   二维扩展，枚举行区间后压为一维处理
3. **双子序列最大和**（P2642）  
   分割序列为两部分分别求最大子段

---

### 关键调试经验
1. **全负数陷阱**：若所有元素为负，需输出最大单个元素而非0（作者Enigmatic的踩坑记录）
2. **初始化值**：`ans`初始值要足够小（如`-1e9`），避免漏算极大负值（作者引领天下的WA教训）
3. **决策顺序**：先更新`ans`再重置`sum`，防止漏判最后一个元素（作者Enigmatic的代码注释强调）

---

### 核心代码模板
```cpp
int maxSubArray(vector<int>& nums) {
    int cur = nums[0], ans = nums[0];
    for(int i=1; i<nums.size(); i++){
        cur = max(nums[i], cur + nums[i]); // 决策是否重置
        ans = max(ans, cur);
    }
    return ans;
}
```

---
处理用时：61.74秒
# 题目信息

# 文件压缩

## 题目背景

提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。


## 题目描述

该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。

举例：$S$ 是 `example`

1. 构造 $n$ 个字符串。

```plain
example
xamplee
ampleex
mpleexa
pleexam
leexamp
eexampl
```

2. 将字符串排序。

```plain
ampleex
example
eexampl
leexamp
mpleexa
pleexam
xamplee
```
3. 压缩结果。

$S' = \texttt{xelpame}$，$p = 7$

由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。

请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。

保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。

## 样例 #1

### 输入

```
7
xelpame
7
```

### 输出

```
example
```

# AI分析结果



### 综合分析与结论

本题核心是通过逆向构造法还原原字符串，关键点在于处理排序后的首字母与尾字母的映射关系，并通过倒推避免重复字符导致的错位。最优解法通过预处理字母出现频率，快速定位字符范围，大幅提升效率。

---

### 精选题解

#### 1. Cat_cc（5星）
**关键亮点**：  
- 利用字母频率统计预处理左右边界，避免逐个查找  
- 时间复杂度优化至O(n)，处理重复字符效率极高  
**核心代码**：
```cpp
for(int i=0;i<26;i++) {
    l[i] = r[i-1]+1;  // 字母i的起始位置
    r[i] = l[i]+a[i]-1; // 字母i的结束位置
}
int now = l[s[p]-'a'];
while(tot < n) {
    ans[tot] = s[now];
    now = r[s[now]-'a']--; // 更新为当前字母的最右位置
}
```
**个人心得**：  
> "在相同字典序的情况下，位置更靠后的字符应先被选用，这保证了逆向构造的正确性"

#### 2. MC_Launcher（4星）
**关键亮点**：  
- 直观的标记法处理已选字符  
- 清晰的倒序输出逻辑  
**核心代码**：
```cpp
for(int j=n-1;j>=0;j--) { // 逆序查找首个可用位置
    if(b[j] == a[now]) {
        now = j;
        ans[i] = a[now];
        b[j] = ')'; // 标记已使用
        break;
    }
}
```
**调试经验**：  
> "正推遇到重复字符会错位，输出中间变量后发现必须逆序构造"

#### 3. liuzhaoxu（4星）
**关键亮点**：  
- 通过具体测试案例解释正推问题  
- 双数组标记实现清晰映射  
**关键实现**：
```cpp
for(int i=n;i>=1;--i) { // 逆序扫描排序数组
    if(ss[i] == s[p]) {
        p = i;
        ans[--cnt] = s[p];
        ss[p] = '#'; // 更新标记
        break;
    }
}
```

---

### 最优技巧总结

**字母范围预处理法**：  
1. 统计每个字母出现次数  
2. 计算每个字母在排序后的左右边界  
3. 逆向构造时优先选择当前字母的最右位置  
该技巧将时间复杂度从O(n²)优化至O(n)，尤其适合高频重复字符场景

---

### 推荐练习题

1. **P1098 字符串的展开**（字符串特殊处理）  
2. **P1368 工艺**（最小循环表示问题）  
3. **P1782 旋转游戏**（环状结构处理）  

---

### 关键代码实现（Cat_cc优化版）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10001;
char s[N],ans[N];
int a[26],l[26],r[26];

int main() {
    int n,p;
    scanf("%d%s%d",&n,s+1,&p);
    
    // 统计字母频率
    for(int i=1;i<=n;i++) a[s[i]-'a']++;
    
    // 预处理字母范围
    for(int i=0;i<26;i++) {
        l[i] = (i>0 ? r[i-1] : 0) + 1;
        r[i] = l[i] + a[i] - 1;
    }
    
    // 逆向构造
    int now = l[s[p]-'a'];
    for(int i=0;i<n;i++) {
        ans[i] = s[now];
        now = r[s[now]-'a']--; // 关键：更新为当前字母的最右边界
    }
    
    // 逆序输出结果
    for(int i=n-1;i>=0;i--) putchar(ans[i]);
}
```

---
处理用时：57.12秒
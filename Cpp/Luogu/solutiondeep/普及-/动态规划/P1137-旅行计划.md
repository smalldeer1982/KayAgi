# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果



### 综合分析与结论
该题为DAG上的最长路径问题，核心解法聚焦拓扑排序与动态规划的结合。所有题解均围绕DAG特性展开，主要分为以下两类思路：
1. **拓扑排序+顺向DP**：按拓扑序转移状态，保证无后效性（90%题解采用）
2. **反向建图+记忆化搜索**：递归计算每个节点的最大深度，利用缓存优化（10%题解采用）

时间复杂度均为O(N+M)，空间复杂度O(M)。拓扑排序实现更易处理大规模数据，记忆化搜索代码更简洁但需注意递归深度。

---

### 高评分题解精选（评分≥4星）

#### 题解1：星星之火（5星）
**关键亮点**：
- 深入解释拓扑序与DP的无后效性关系
- 代码结构清晰，变量命名规范
- 完整包含拓扑排序与DP两阶段处理

**核心代码**：
```cpp
void topsort() { // 标准拓扑排序实现
    queue<int> q;
    for(int i=1;i<=n;i++) 
        if(ru[i]==0) q.push(i);
    while(!q.empty()) {
        int u = q.front(); q.pop();
        ts[++tot] = u;
        for(Edge e : adj[u]) {
            if(--ru[e.to] == 0) 
                q.push(e.to);
        }
    }
}

// DP阶段
for(int i=1;i<=n;i++) {
    int u = ts[i];
    for(Edge e : adj[u]) {
        dp[e.to] = max(dp[e.to], dp[u]+1);
    }
}
```

#### 题解2：_ZZH（4.5星）
**关键亮点**：
- 拓扑排序与DP融合，单次遍历完成计算
- 代码极简，空间优化到位
- 适合竞赛快速实现

**核心代码**：
```cpp
queue<int> q;
for(int i=1;i<=n;i++)
    if(in[i]==0) q.push(i), dp[i]=1;
    
while(!q.empty()) {
    int u = q.front(); q.pop();
    for(int v : adj[u]) {
        dp[v] = max(dp[v], dp[u]+1);
        if(--in[v] == 0)
            q.push(v);
    }
}
```

#### 题解3：归山_（4星）
**关键亮点**：
- 反向建图+记忆化搜索的独特思路
- 更符合直觉的递归式解法
- 包含重要调试提示（dp数组初始化）

**核心代码**：
```cpp
int dfs(int x) {
    if(dp[x] != -1) return dp[x];
    dp[x] = 1;
    for(int y : reverse_adj[x]) 
        dp[x] = max(dp[x], dfs(y)+1);
    return dp[x];
}
// 调用前需memset(dp, -1, sizeof(dp))
```

---

### 关键思路总结
**拓扑排序+DP**为最优解法：
1. **拓扑序保证正确性**：确保处理节点时所有前驱节点已计算完成
2. **状态转移方程**：`dp[v] = max(dp[v], dp[u]+1)`，u为v的直接前驱
3. **空间优化**：使用链式前向星存储邻接表，避免vector扩容开销
4. **初始化技巧**：所有节点初始dp值为1（自身作为起点）

---

### 同类题目推荐
1. **P1113 杂务**（DAG最长路径模板）
2. **P4017 最大食物链计数**（拓扑排序+路径计数）
3. **P3387 【模板】缩点**（强连通分量处理后转为DAG）

---

### 实践心得摘录
1. **调试教训**：初始化dp数组时忘记设置初始值1，导致样例输出全少1（@归山_）
2. **优化发现**：显式拓扑排序后DP比融合写法慢5%，但更易调试（@wshz）
3. **思维突破**：意识到终点i的答案等价于反向图中i作为起点的最长路径（@zyx10）

---

### 核心代码实现
拓扑排序+DP融合写法（最优实现）：
```cpp
vector<int> adj[MAXN];
int in[MAXN], dp[MAXN];

void solve() {
    queue<int> q;
    for(int i=1; i<=n; ++i) {
        dp[i] = 1;
        if(in[i] == 0) q.push(i);
    }
    
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : adj[u]) {
            dp[v] = max(dp[v], dp[u]+1);
            if(--in[v] == 0)
                q.push(v);
        }
    }
}
```

---
处理用时：61.13秒
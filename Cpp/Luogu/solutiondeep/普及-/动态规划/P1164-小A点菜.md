# 题目信息

# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论
本题属于01背包变种（求方案数），核心思路是动态规划。各题解普遍采用二维/一维DP，核心转移方程为 $f[j] += f[j-a[i]]$。关键优化点包括：一维数组空间优化、倒序遍历避免覆盖、初始化 $f[0]=1$ 处理恰好购买的情况。最优解法为优化后的一维DP，时间复杂度 $O(NM)$，空间 $O(M)$。

---

### 精选题解与评分
#### 1. Dream_zhc（5星）
**关键亮点**：
- 清晰解释二维→一维优化原理，图解覆盖问题
- 强调初始化 $f[0]=1$ 的关键作用
- 代码简洁规范，适合不同层次学习者

**个人心得**：
> "倒序遍历j的原因是防止覆盖i-1层的状态值，这与01背包的空间优化原理一致"

**核心代码**：
```cpp
int f[10010] = {1}; // 初始化技巧
for(int i=1; i<=n; i++)
    for(int j=m; j>=a[i]; j--)
        f[j] += f[j - a[i]];
```

#### 2. 衡屿睿（4星）
**关键亮点**：
- 直观的二维DP实现，适合理解基础逻辑
- 完整展示三种转移情况，便于调试验证
- 代码注释清晰，适合DP入门学习

**核心片段**：
```cpp
for(int i=1; i<=n; i++)
    for(int j=1; j<=m; j++){
        if(j == a[i]) f[i][j] = f[i-1][j]+1;
        else if(j > a[i]) f[i][j] = f[i-1][j] + f[i-1][j-a[i]];
        else f[i][j] = f[i-1][j];
    }
```

#### 3. 康师傅（4星）
**关键亮点**：
- 边读边处理的优化技巧
- 独特初始化方式 $dp[a]++$
- 代码极简风格，适合竞赛快速实现

**核心代码**：
```cpp
for(int i=1; i<=n; i++){
    scanf("%d",&a);
    for(int j=m;j>a;--j) dp[j] += dp[j-a];
    dp[a]++; // 直接处理当前菜品
}
```

---

### 关键技巧总结
1. **空间优化**：通过倒序遍历将二维DP压缩至一维，空间复杂度从 $O(NM)$ 降为 $O(M)$
2. **初始化技巧**：设置 $f[0]=1$ 处理恰好花费菜品价格的情况
3. **状态转移**：$f[j] += f[j-a[i]]$ 本质是方案数的叠加（选与不选）
4. **边界处理**：当 $j < a[i]$ 时直接继承前状态，无需额外操作

---

### 同类题目推荐
1. P1048 [采药]（基础01背包）
2. P1064 [金明的预算方案]（依赖背包）
3. P2347 [砝码称重]（方案数变种）

---

### 实用调试经验摘录
1. "Python输入需循环读取直到填满n项"（Eric_cao）
2. "二维数组调试可打印中间状态表"（Diegozcx）
3. "WA时检查是否漏掉f[0]=1初始化"（多篇题解共同强调）
4. "RE可能是数组越界，注意数据分多行输入的情况"（Eric_cao）

---
处理用时：51.59秒
# 题目信息

# 最大约数和

## 题目描述

选取和不超过 $S$ 的若干个不同的正整数，使得所有数的约数（不含它本身）之和最大。

## 说明/提示

**【样例说明】**

取数字 $4$ 和 $6$，可以得到最大值 $(1+2)+(1+2+3)=9$。

**【数据规模】**

对于 $100 \%$ 的数据，$1 \le S \le 1000$。

## 样例 #1

### 输入

```
11```

### 输出

```
9```

# AI分析结果



### 综合分析与结论  
本题本质是 **带预处理的01背包问题**，核心是将每个数字视为物品（重量为数值，价值为约数和），背包容量为S。题解普遍采用以下关键思路：  
1. **约数和预处理**：通过筛法优化计算（O(n log n)），优于暴力计算（O(n²)）。  
2. **背包建模**：用一维数组逆序遍历实现空间优化，保证每个数只选一次。  
3. **数学证明**：通过约数和性质避免重复选择（如Mys_C_K的证明）。  

---

### 高评分题解推荐  

#### 1. 作者：引领天下（⭐️⭐️⭐️⭐️⭐️）  
**关键亮点**：  
- **筛法预处理**：用类似埃氏筛的方式高效计算所有数的约数和，时间复杂度低。  
- **清晰模型转化**：明确将S视为背包容量，i为物品重量，约数和为价值。  
**核心代码**：  
```cpp
void prime() {
    for (int i = 1; i <= n; i++)
        for (int j = i * 2; j <= n; j += i)
            a[j] += i; // i是j的因子，累加到a[j]
}
```  
**个人心得**：强调预处理的重要性，指出筛法变体的通用性，适合举一反三。  

#### 2. 作者：Mys_C_K（⭐️⭐️⭐️⭐️⭐️）  
**关键亮点**：  
- **数学严谨性**：通过因式分解证明选重复数不如选更大数，确保背包模型正确性。  
- **代码简洁性**：直接使用筛法预处理+一维背包，无冗余逻辑。  
**核心代码**：  
```cpp
for (int i = 1; i <= S; i++)
    for (int j = S; j >= i; j--)
        dp[j] = max(dp[j], dp[j - i] + a[i]);
```  
**个人心得**：通过数学分析避免重复选择，提升代码可信度。  

#### 3. 作者：cs18（⭐️⭐️⭐️⭐️）  
**关键亮点**：  
- **代码可读性**：完整展示暴力计算约数和与标准背包模板，适合新手学习。  
- **错误提示**：强调初始化`ans=0`的重要性，避免实际编码踩坑。  
**核心代码**：  
```cpp
int find(int x) {
    int ans = 0; // 必须初始化
    for (int i = 1; i < x; i++)
        if (x % i == 0) ans += i;
    return ans;
}
```  

---

### 最优关键思路总结  
1. **筛法预处理**：通过遍历每个数的倍数累加因子，时间复杂度优化至O(n log n)。  
2. **一维逆序背包**：用`dp[j] = max(dp[j], dp[j - i] + a[i])`实现空间与时间双重优化。  
3. **模型转化思维**：将抽象问题转化为经典背包模型，需快速识别「重量-价值」对应关系。  

---

### 拓展与举一反三  
1. **同类题目**：  
   - **P1060 开心的金明**（基础01背包）  
   - **P2925 [USACO08DEC]干草出售**（容量限制优化）  
   - **P1853 投资的最大效益**（多维预处理+动态规划）  
2. **调试技巧**：  
   - 初始化变量（如`ans=0`）是常见错误点，需优先检查。  
   - 打表法可用于快速验证预处理结果，但需注意代码规范性。  

（注：以上题解代码均为核心片段，完整实现需结合预处理和输入输出逻辑。）

---
处理用时：53.90秒
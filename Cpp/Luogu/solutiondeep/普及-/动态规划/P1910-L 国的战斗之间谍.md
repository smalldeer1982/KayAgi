# 题目信息

# L 国的战斗之间谍

## 题目背景

L 国即将与 I 国发动战争！！


## 题目描述

俗话说的好：“知己知彼，百战不殆”。L 国的指挥官想派出间谍前往I国，于是，选人工作就落到了你身上。

你现在有 $N$ 个人选，每个人都有这样一些数据：$A$（能得到多少资料）、$B$（伪装能力有多差）、$C$（要多少工资）。已知敌人的探查间谍能力为 $M$（即去的所有人 $B$ 的和要小于等于 $M$）和手头有 $X$ 元钱，请问能拿到多少资料？


## 说明/提示

数据范围：$1\le n\le 100$，$1\le m\le 1000$，$1\leq x\leq 1000$。

## 样例 #1

### 输入

```
3 10 12
10 1 11
1 9 1
7 10 12
```

### 输出

```
11```

# AI分析结果



### 综合分析与结论
本题为二维背包问题，需在双重约束（总伪装能力≤M，总费用≤X）下求最大资料量。所有题解均围绕动态规划展开，核心差异在于空间优化与代码简洁性。DFS解法虽存在但效率低，仅适合极小数据。

---

### 精选题解（评分≥4星）

#### 1. 题解作者：MuelsyseU（★★★★★）
**关键亮点**：
- 完整推导三维DP到二维的优化过程，清晰解释滚动数组原理
- 强调逆序遍历防止覆盖问题，点明二维背包核心实现细节
- 代码高度简洁（仅15行核心逻辑）

**核心代码**：
```cpp
int f[1005][1005];
for(int i=1;i<=n;i++){
    cin>>x>>y>>z;
    for(int j=m;j>=y;j--)
        for(int k=p;k>=z;k--)
            f[j][k]=max(f[j][k],f[j-y][k-z]+x);
}
```
**实现思想**：使用滚动数组将状态压缩至二维，倒序更新确保使用上一层数据。

#### 2. 题解作者：北海_Beihai（★★★★☆）
**关键亮点**：
- 直击问题本质，用最简代码展示二维背包模板
- 变量命名清晰（m/x对应题目约束）
- 适合快速理解标准解法

**核心代码**：
```cpp
int f[1010][1010];
for(int i=1;i<=n;i++){
    int a,b,c; cin>>a>>b>>c;
    for(int j=m;j>=b;j--)
        for(int k=x;k>=c;k--)
            f[j][k]=max(f[j][k],f[j-b][k-c]+a);
}
```

---

### 关键技巧总结
1. **状态设计**：`f[j][k]`表示伪装能力≤j且费用≤k时的最大价值
2. **逆序更新**：保证每个物品只选一次，避免完全背包问题
3. **空间压缩**：通过滚动数组将三维DP压缩为二维，空间复杂度从O(NMX)降为O(MX)

---

### 拓展建议
1. **同类题型**：
   - P1855 榨取kkksc03（二维背包模板题）
   - P1509 找GF（二维约束+输出方案）
   - P1757 通天之分组背包（分组背包+二维约束）
2. **高阶技巧**：
   - 状态合并：当约束维度较高时，可通过离散化减少状态数
   - 剪枝优化：在DFS解法中预处理前缀和进行可行性剪枝

---

### 题解中的调试经验摘录
MuelsyseU提到：
> "逆序遍历是空间压缩的关键，正序会导致同一物品被多次选取。若用三维数组会MLE，需注意题目内存限制"

该经验点明了01背包与完全背包在实现时的核心差异，对理解二维背包的底层逻辑至关重要。

---
处理用时：39.99秒
# 题目信息

# 小书童——刷题大军

## 题目背景

数学是火，点亮物理的灯；物理是灯，照亮化学的路；化学是路，通向生物的坑；生物是坑，埋葬学理的人。  
文言是火，点亮历史宫灯；历史是灯，照亮社会之路；社会是路，通向哲学大坑；哲学是坑，埋葬文科生。——小 A


## 题目描述

小 A “刷题”十分猖狂，明目张胆地“刷题”。他现在在小书童里发现了 $n$ 样他喜欢的“题目”，每“题”都有他的需要时间，而老师布置了 $m$ 项作业，每项作业都有它的需要时间及分值，老师规定 $k$ 分以上算及格。小 A 只剩 $r$ 个单位时间，他想在及格的基础上更多地“刷题”。

## 说明/提示

### 数据范围及约定


对于 $100\%$ 的数据，$n\le 10$，$m\le 10$，$k\le 50$，$r\le 150$。数据保证没有不能及格的情况。


## 样例 #1

### 输入

```
3 4 20 100
15 20 50
10 15 40 40
5 5 10 15```

### 输出

```
2```

# AI分析结果



### 综合分析与结论
本题核心为二维优化问题：在有限时间内优先满足作业及格线，再最大化刷题数量。绝大多数题解采用「01背包+贪心」双阶段策略：
1. **01背包求解最小及格时间**：将作业视为物品，时间作体积、分数作价值，计算各时间点能获得的最大分数，找到首个≥k的时间点。
2. **贪心选择刷题顺序**：将题目按时间排序，用剩余时间尽可能多刷短时题。

### 高星题解推荐
#### 题解1：slaak（★★★★★）
**核心亮点**  
- 标准01背包实现，代码简洁清晰  
- 正确使用`break`提前终止扫描，减少无效计算  
- 变量命名合理，可读性强  

**核心代码**  
```cpp
// 01背包处理作业
for(int i=1;i<=m;i++)
    for(int j=r;j>=w[i];j--)
        f[j] = max(f[j], f[j-w[i]] + c[i]);

// 计算剩余时间
for(int i=1;i<=r;i++)
    if(f[i] >= k) { stt = r - i; break; }
```

#### 题解2：vectorwyx（★★★★☆）
**核心亮点**  
- 详细注释解释每步逻辑  
- 函数式编程风格增强可维护性  
- 明确分离背包与贪心阶段  

**关键实现**  
```cpp
sort(s+1,s+n+1); // 刷题时间排序
for(int i=1;i<=n;i++){
    t-=s[i];     // 贪心选择最小时间
    if(t>=0) ans++; else break;
}
```

#### 题解3：kpl000（★★★★☆）
**独特优势**  
- 反向思考求最小时间：`f[j] = min(f[j], f[j-point[i]] + t[i])`  
- 更直观体现时间最小化目标  

**关键片段**  
```cpp
for(int i=1;i<=m;i++)
    for(int j=k;j>=point[i];j--)
        f[j] = min(f[j], f[j-point[i]] + t[i]);
```

### 最优关键思路总结
1. **背包维度转换**：将分数作为价值（正向背包）或时间作为价值（逆向背包），根据需求选择更优维度。
2. **贪心排序前置**：预处理题目时间排序，避免在动态计算中反复排序。
3. **剪枝优化**：在背包扫描时一旦满足条件立即终止，如`slaak`解法中的`break`。

### 拓展建议
- **同类题目推荐**  
  - [P1048 采药](https://www.luogu.com.cn/problem/P1048)（基础01背包）  
  - [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)（贪心+背包结合）  
  - [P1806 跑步计划](https://www.luogu.com.cn/problem/P1806)（多维约束优化）

- **调试经验摘录**  
  > "发现f数组初始化错误导致WA，背包的f[0]必须初始化为0" —— 来自调试日志，强调背包初始状态的重要性。  
  > "排序后忘记同步交换时间和分数数组" —— 提醒处理关联数据时需保持数据一致性。

### 关键代码模板
```cpp
// 01背包核心模板
int f[MAX_TIME] = {0};
for (int i = 1; i <= m; i++) {
    for (int j = r; j >= w[i]; j--) {
        f[j] = max(f[j], f[j - w[i]] + c[i]);
    }
}

// 贪心刷题模板
sort(a + 1, a + n + 1);
int cnt = 0;
for (int i = 1; i <= n && remTime > 0; i++) {
    if (remTime >= a[i]) {
        remTime -= a[i];
        cnt++;
    }
}
```

---
处理用时：50.07秒
# 题目信息

# 【mc生存】卖东西

## 题目背景

服务器好好玩。

## 题目描述

lcy0x1 去服务器的系统商店买东西。

一个人的背包有 $21$ 格。

一开始他的背包里有 $m$ 件不同的物品（**不能卖**）。

他要买 $n$ 种物品，第 $i$ 件物品的名字为 $st_i$，有 $a_i$ 件，价值为 $b_i$，一格可以放 $c_i$ 个。

相同的物品可以放同一格（只要没放满）。

问：他跑一次最多能卖多少钱。

## 说明/提示

数据保证：

- $0\leq m\leq 21$；
- $0\leq n\leq 100$；
- $0\leq a_i\leq 1344$；
- $0\leq b_i\leq 10^4$；
- $0<c_i\leq 64$；
- $0<|st_i|<100$；
- $0\leq s\leq 10^6$。

**注：数据强大，搜索 $0$ 分，请使用多重背包。**

## 样例 #1

### 输入

```
20 3

63 1 64 yinshifen

1 10 1 men

1 1 64 yinshifen```

### 输出

```
64```

# AI分析结果



### 综合分析与结论
本题核心为背包问题变种，需处理物品合并、分组及容量限制。最优解法是将物品拆分为满格和余数格，转化为01背包或多重背包。贪心法在特定数据下可行，但动态规划更具普适性。

### 精选题解
#### 1. 作者：二哥啃菜包（★★★★★）
**关键亮点**  
- 正确拆分物品为多个满格和余数格，确保最优解。  
- 代码简洁高效，利用map去重后直接转化为01背包。  
**核心代码**  
```cpp
for(int i=1;i<=cnt;++i) {
    while(a[i]>c[i]) { // 拆分超出容量的部分
        a[++cnt]=c[i];
        b[cnt]=b[i];
        a[i]-=c[i];
    }
}
for(int i=1;i<=cnt;++i) {
    for(int j=m;j>=1;--j) {
        f[j]=max(f[j], f[j-1]+a[i]*b[i]); // 01背包状态转移
    }
}
```

#### 2. 作者：moongazer（★★★★☆）
**关键亮点**  
- 使用STL map合并同类物品，提高代码可读性。  
- 正确转化为01背包，处理余数格逻辑清晰。  
**核心代码**  
```cpp
while(a[s[i]]>=c[s[i]]) { // 拆分满格
    w[++k]=c[s[i]]*b[s[i]];
    a[s[i]]-=c[s[i]];
}
if(a[s[i]]) w[++k]=a[s[i]]*b[s[i]]; // 处理余数
for(int i=1;i<=k;i++) { // 01背包
    for(int j=m;j>=1;j--) {
        dp[j]=max(dp[j], dp[j-1]+w[i]);
    }
}
```

#### 3. 作者：hongzy（★★★★☆）
**关键亮点**  
- 多重背包直接处理物品数量，避免拆分。  
- 状态转移考虑占格数，确保正确性。  
**核心代码**  
```cpp
for(int i=1; i<=cnt; i++) {
    for(int j=V; j>=0; j--) {
        for(int k=0; k<=s[i]; k++) {
            int w = ceil((double)k / v[i]); // 计算占格数
            if(j-w <0) break;
            f[j] = max(f[j], f[j-w] + c[i]*k);
        }
    }
}
```

### 关键思路与技巧总结
1. **物品合并**：使用map或结构体合并同类物品，简化后续处理。
2. **拆分策略**：将物品拆分为满格（容量上限）和余数格，确保每个格子价值最大化。
3. **动态规划选择**：01背包适用于拆分后物品，多重背包直接处理原物品数量，需注意占格计算。

### 举一反三
- **同类题目推荐**  
  - [P1757 通天之分组背包](https://www.luogu.com.cn/problem/P1757)  
  - [P1776 宝物筛选（多重背包优化）](https://www.luogu.com.cn/problem/P1776)  
  - [P1048 采药（01背包基础）](https://www.luogu.com.cn/problem/P1048)  

### 个人心得摘录
- **调试经历**：贪心法在合并物品时易出错（如灵光一闪的代码WA样例），需仔细验证边界条件。  
- **优化技巧**：使用STL map或结构体管理物品可大幅提升代码可维护性（如moongazer的解法）。  
- **算法选择**：数据量小时贪心可行，但动态规划更普适，尤其需注意题目提示的“搜索0分”。

---
处理用时：52.46秒
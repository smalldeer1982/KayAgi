# 题目信息

# 美元汇率

## 题目背景

此处省略 `MAX_INT+1` 个数。

## 题目描述

在以后的若干天里戴维将学习美元与德国马克的汇率。编写程序帮助戴维何时应买或卖马克或美元，使他从 $100$ 美元开始，最后能获得最高可能的价值。


## 说明/提示

**样例解释**

```cpp
Day 1 ... changing 100.0000 美元= 400.0000 马克
Day 2 ... changing 400.0000 马克= 133.3333 美元
Day 3 ... changing 133.3333 美元= 666.6666 马克
Day 5 ... changing 666.6666 马克= 266.6666 美元
```

update on 2017/08/18：

1. 样例正确答案为 $266.67$

2. 已经把测试点 $1$ 改成样例。

3. SPJ 原先误差是 $0.01$，按照题目要求，重新改为 $0.05$。

## 样例 #1

### 输入

```
5
400
300
500
300
250```

### 输出

```
266.67```

# AI分析结果



### 题解综合分析结论
本题核心在于通过状态转移维护两种货币的最优持有量。主流解法为动态规划，通过维护美元/马克两种状态的最优解，逐步递推得到最终结果。贪心解法通过相邻汇率比较进行决策，正确性需严格证明但代码更简洁。两种方法时间复杂度均为O(n)，空间复杂度动态规划可优化至O(1)。

---

### 高星题解推荐

#### 1. 题解作者：2er0n3（★★★★★）
**核心亮点**  
- 明确双状态定义（美元/马克）  
- 状态转移方程清晰直观  
- 代码结构规范，适合理解DP基础  

**关键代码**  
```cpp
for(int i=2;i<=n;i++) {
    f[i][0] = max(f[i-1][0], (f[i-1][1]/a[i])*100);
    f[i][1] = max(f[i-1][1], f[i-1][0]*a[i]/100);
}
```

#### 2. 题解作者：moongazer（★★★★★）
**核心亮点**  
- 滚动变量优化空间至O(1)  
- 采用临时变量避免状态覆盖  
- 代码简洁高效，适合进阶学习  

**关键代码**  
```cpp
for(int i=1;i<=n;i++) {
    tmp = dp1; // 保存前一天美元值
    dp1 = max(dp1, (dp2/a)*100); // 更新美元
    dp2 = max(dp2, (tmp/100)*a); // 更新马克
}
```

#### 3. 题解作者：pyqpyq（★★★★☆）
**核心亮点**  
- 贪心策略简洁，相邻汇率比较  
- 数学推导验证转换收益公式  
- 代码极简，时间复杂度最优  

**关键思路**  
当 `前日汇率 > 当日汇率` 时转换，收益公式为 `m *= l/s`，正确性通过样例验证。

---

### 最优思路总结
**动态规划**：  
- 定义 `dp[i][0]` 和 `dp[i][1]` 分别表示第i天美元/马克的最大持有量  
- 转移方程：  
  ```math
  dp[i][0] = max(继承前日美元, 前日马克兑换美元)  
  dp[i][1] = max(继承前日马克, 前日美元兑换马克)
  ```

**贪心策略**：  
- 若当日汇率 `a[i]` < 次日汇率 `a[i+1]`，则全仓兑换马克  
- 反之则兑换回美元，收益公式为累乘相邻汇率比  

---

### 拓展与同类题目
**相似题型套路**  
- 状态机DP：如股票买卖问题（每日持有/不持有状态）  
- 序列决策问题：需维护多个状态的最优值  

**推荐题目**  
1. [P1233 股票交易](https://www.luogu.com.cn/problem/P1233)  
2. [P5662 纪念品](https://www.luogu.com.cn/problem/P5662)（CSP-J 2019）  
3. [P1968 美元汇率](https://www.luogu.com.cn/problem/P1968)（本题加强版）  

---

### 题解者心得摘录
- **调试经验**：动态规划需注意最后一天马克转美元的边界处理（@2er0n3）  
- **贪心证明**：通过数学推导发现转换公式的累乘特性（@pyqpyq）  
- **空间优化**：使用滚动变量时需用临时变量防止覆盖（@moongazer）

---
处理用时：151.72秒
# 题目信息

# [NOIP 1996 提高组] 砝码称重

## 题目描述

设有 $1\mathrm{g}$、$2\mathrm{g}$、$3\mathrm{g}$、$5\mathrm{g}$、$10\mathrm{g}$、$20\mathrm{g}$ 的砝码各若干枚（其总重 $ \le 1000$），可以表示成多少种重量？

## 说明/提示

**【题目来源】**

NOIP 1996 提高组第四题

## 样例 #1

### 输入

```
1 1 0 0 0 0```

### 输出

```
Total=3```

# AI分析结果



### 综合分析与结论
本题核心在于通过组合不同数量的砝码计算可表示的重量种类数。题解主要采用以下思路：
1. **动态规划**（多重背包、01背包）  
2. **位运算优化**（bitset快速状态转移）  
3. **二进制拆分**（优化多重背包）  
4. **暴力枚举**（数据范围小时可行）

关键优化点：  
- **逆序更新状态**避免重复计算（背包问题的经典优化）  
- **bitset的位并行特性**大幅提升状态转移效率  
- **二进制拆分**将多重背包转化为01背包，降低时间复杂度

---

### 高星题解推荐（≥4星）

#### 1. [pantw] bitset解法（⭐⭐⭐⭐⭐）  
**核心亮点**：  
- 利用`bitset`实现状态压缩，通过`S |= S << w[i]`一次性完成所有可能状态的转移  
- 代码极简（仅10行），时间复杂度O(Σa_i * 1000/32)  
**关键代码**：
```cpp
std::bitset<1010> S;
for(int i=0; i<6; i++) 
    for(int j=0; j<a[i]; j++) 
        S |= S << w[i];
```
**个人心得**：  
作者指出循环顺序不影响结果，但必须逐个处理每个砝码的每个实例，体现对位运算特性的深刻理解。

---

#### 2. [zhongtaiyang] 二进制拆分（⭐⭐⭐⭐⭐）  
**核心亮点**：  
- 标准多重背包优化，将砝码数量拆分为二进制组合，减少物品数量至O(log a_i)  
- 可处理更大规模的砝码数量  
**关键步骤**：  
```cpp
for(int i=0; i<6; i++) {
    for(int j=1; j<=num[i]; j*=2) { // 二进制拆分
        value[k++] = j * w[i];
        num[i] -= j;
    }
    if(num[i]) value[k++] = num[i] * w[i];
}
```
**拓展性**：此方法适用于所有多重背包问题（如洛谷P1776）。

---

#### 3. [Kan_kiz] 多重背包（⭐⭐⭐⭐）  
**核心亮点**：  
- 直观展示DP状态转移过程，适合教学理解  
- 强调**逆序更新**避免状态污染  
**关键实现**：  
```cpp
for(int i=1; i<=6; i++) 
    for(int j=1; j<=a[i]; j++) 
        for(int k=1000; k>=0; k--) 
            if(f[k]) f[k+w[i]] = 1;
```
**调试经验**：作者通过错误样例说明正序更新的问题，强调逆序的重要性。

---

### 最优思路总结
1. **bitset位压缩**是最优解法，时间复杂度与空间效率俱佳  
2. **二进制拆分**是处理多重背包的通用高效方法  
3. **逆序更新状态**是动态规划避免重复计算的核心技巧  

---

### 推荐相似题目
1. [P2871 背包问题求方案数](https://www.luogu.com.cn/problem/P2871)  
2. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)（多重背包+二进制优化）  
3. [P2340 Cow Exhibition](https://www.luogu.com.cn/problem/P2340)（双维度背包+偏移量技巧）

---
处理用时：55.08秒
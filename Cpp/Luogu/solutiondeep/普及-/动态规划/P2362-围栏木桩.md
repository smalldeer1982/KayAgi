# 题目信息

# 围栏木桩

## 题目描述

某农场有一个由按编号排列的 $n$ 根木桩构成的首尾不相连的围栏。现要在这个围栏中选取一些木桩，按照原有的编号次序排列之后，这些木桩高度成一个升序序列。所谓的升序序列就是序列中的任何一个数都不小于它之前的任何一个数。试编写程序从这个围栏中选取合适的木桩使得选出的木桩个数 $t$ 最大，并求出选取出 $t$ 根木桩的方案总数 $c$。


## 说明/提示

$m \leq 5$，$n \leq 20$，$h_i \leq 150$。

## 样例 #1

### 输入

```
3
9 10 1 9 8 7 6 3 4 6
3 100 70 102
6 40 37 23 89 91 12```

### 输出

```
4 1
2 2
3 3```

# AI分析结果



### 综合分析与结论
本题核心为求最长不下降子序列（LNDS）的长度及方案数。题解主要采用动态规划（DP）和DFS两种思路，其中DP解法在时间效率（O(n²)）和代码简洁性上表现更优，而DFS解法在小数据范围（n≤20）下可行但效率较低。关键难点在于正确维护状态转移时的方案数。

---

### 高分题解推荐

#### 1. mulberror（5星）
**关键亮点**：
- 状态定义清晰：`f[i]`为以i结尾的LNDS长度，`g[i]`为对应方案数。
- 动态转移处理简洁：分情况更新长度与方案数，代码可读性强。
- 边界处理明确：初始化`f[i]=g[i]=1`符合单元素子序列特性。

**核心代码**：
```cpp
for(int j=1; j<i; j++) {
    if(a[j] <= a[i]) {
        int s = f[j] + 1;
        if(s > f[i]) f[i] = s, g[i] = g[j];
        else if(s == f[i]) g[i] += g[j];
    }
}
```

#### 2. 江屿（4星）
**关键亮点**：
- 逆向遍历优化：从后往前遍历j，减少重复判断。
- 答案统计技巧：单次遍历同时确定最大值及累加方案数，逻辑紧凑。

**调试心得**：
- 提到输出格式坑点（%-5d与%5d的区别），强调代码细节的重要性。

**核心代码**：
```cpp
for(int k=j-1; k>=1; k--) // 逆序遍历优化
    if(a[j] >= a[k]) {
        if(b[j] < b[k]+1) b[j] = b[k]+1, c[j] = c[k];
        else if(b[j] == b[k]+1) c[j] += c[k];
    }
```

#### 3. Acc_Robin（4星）
**关键亮点**：
- DAG模型抽象：将状态转移视为有向无环图的最长链问题，思路新颖。
- 代码极简：仅用双重循环实现状态转移，无冗余操作。

**核心代码**：
```cpp
if(a[j] <= a[i]) {
    if(dp[i] < dp[j]+1) dp[i]=dp[j]+1, f[i]=f[j];
    else if(dp[i]==dp[j]+1) f[i] += f[j];
}
```

---

### 最优思路总结
**核心算法**：动态规划  
**关键步骤**：
1. **状态定义**：`f[i]`表示以第i个元素结尾的LNDS长度，`c[i]`表示对应方案数。
2. **状态转移**：
   - 若找到更长的子序列（`f[j]+1 > f[i]`），则继承方案数（`c[i] = c[j]`）。
   - 若长度相同（`f[j]+1 == f[i]`），则累加方案数（`c[i] += c[j]`）。
3. **答案统计**：遍历所有位置，累加最大长度的`c[i]`总和。

**实现技巧**：
- 逆序遍历j可减少无效计算（如江屿代码）。
- 初始化`f[i] = c[i] = 1`处理单元素边界情况。

---

### 相似题目推荐
1. **P1020 导弹拦截**：求最长不上升子序列及其个数。
2. **P1091 合唱队形**：双向LIS问题，需结合正向与逆向LIS。
3. **P1439 最长公共子序列**：LIS的O(n log n)优化变种，适合进阶练习。

---

### 个人心得摘录
- **江屿**：强调输出格式的细节处理（`%-5d`与`%5d`），提醒注意题目描述的隐蔽要求。
- **Atmizz**：DFS解法在小数据下的可行性验证，展示暴力法的适用边界。
- **Priori_Incantatem**：分步计算长度与方案数的思路，体现模块化编程的优势。

---
处理用时：75.64秒
# 题目信息

# [USACO3.1] 总分 Score Inflation

## 题目背景

选手在我们 USACO 的竞赛中的得分越多我们越高兴。

我们试着设计我们的竞赛以便人们能尽可能的多得分,这需要你的帮助。


## 题目描述

我们可以从几个种类中选取竞赛的题目，这里的一个“种类”是指一个竞赛题目的集合，解决集合中的题目需要相同多的时间并且能得到相同的分数。

你的任务是写一个程序来告诉 USACO 的职员,应该从每一个种类中选取多少题目，使得解决题目的总耗时在竞赛规定的时间里并且总分最大。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 10^4$，$1 \leq p_i, t_i \leq 10^4$。

## 样例 #1

### 输入

```
300 4
100 60
250 120
120 100
35 20```

### 输出

```
605```

# AI分析结果



### 综合分析与结论
本题为完全背包模板题，核心在于正确处理物品无限次选取时的状态转移。所有题解均正确识别了完全背包模型，但在代码优化、解释深度及教学价值上存在差异。最优解法采用一维数组优化，时间复杂度O(nm)，空间O(m)，符合题目数据范围要求。

---

### 高分题解推荐（≥4星）

#### 1. 作者：llzzxx712（5星）
**关键亮点**：
- 通过01背包与完全背包对比教学，帮助理解核心差异
- 提供二维到一维优化的详细推导过程，辅以调试数据可视化
- 代码注释清晰，变量命名规范，具有极高可读性

**个人心得**：
> "当我把输入数据第四个物品价值改为7时，发现f[3][10]已达到最大值11，程序在i=4时没有更改结果"  
> → 通过修改测试数据验证状态转移正确性，体现调试思维

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    for(int t1=t[i];t1<=m;t1++){ // 完全背包正序循环
        f[t1] = max(f[t1], f[t1-t[i]] + p[i]);
    }
}
```

#### 2. 作者：vibrant72（4星）
**关键亮点**：
- 明确提示输入顺序易错点（分数在前，时间在后）
- 代码简洁高效，使用标准库函数优化可读性
- 变量命名与问题域高度契合（time/points）

**核心代码**：
```cpp
for(int i=1; i<=n; i++)
    for(int j=w[i]; j<=m; j++)
        f[j] = max(f[j], f[j-w[i]] + v[i]);
```

#### 3. 作者：MaverickT（4星）
**关键亮点**：
- 建立与《疯狂的采药》题目的关联，帮助知识迁移
- 提供二维状态转移方程的数学表达形式
- 包含空间复杂度分析（二维数组的潜在问题）

**关键洞见**：
```cpp
// 与01背包的核心差异：
for(int j = t[i]; j <= m; j++)  // 完全背包正序循环
    f[j] = max(f[j], f[j - t[i]] + p[i]);
```

---

### 关键思路总结
1. **状态定义**：`f[j]` 表示用j分钟能获得的最大分数
2. **转移方程**：`f[j] = max(f[j], f[j-t[i]] + p[i])`
3. **循环顺序**：外层遍历物品，内层正序遍历时间（区别于01背包的逆序）
4. **输入陷阱**：题目输入为（分数，时间），易与常规（重量，价值）顺序混淆

---

### 同类题目推荐
1. [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616) - 完全背包模板题
2. [P1853 投资的最大效益](https://www.luogu.com.cn/problem/P1853) - 完全背包+滚动数组优化
3. [P2918 [USACO08NOV] Buying Hay S](https://www.luogu.com.cn/problem/P2918) - 完全背包变式（最小化问题）

---

### 调试经验摘录
1. **SLYZ_0120**："因为两个看反了，本蒟蒻硬是卡了10分钟" → 输入顺序验证的重要性
2. **乒乓高手**："调试了好长时间，发现是一个完全背包" → 通过错误实践加深模型理解
3. **Ryang**："第一次讲，可能讲的不太好，谅解" → 多维状态转移的直观解释尝试

---

### 核心代码模板
```cpp
int m, n; // 总时间和题目种类数
int p[MAXN], t[MAXN]; // 分数和时间数组
int dp[MAXM]; // MAXM为最大时间限制

memset(dp, 0, sizeof(dp));
for(int i=1; i<=n; ++i) {
    for(int j=t[i]; j<=m; ++j) {
        dp[j] = max(dp[j], dp[j - t[i]] + p[i]);
    }
}
cout << dp[m];
```

---
处理用时：49.03秒
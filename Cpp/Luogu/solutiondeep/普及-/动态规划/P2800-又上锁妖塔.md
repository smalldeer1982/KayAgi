# 题目信息

# 又上锁妖塔

## 题目描述

小 A 在玩《剑仙》，他遇到了一个锁妖塔，想从外面爬上去。

锁妖塔共有 $n$ 层，第 $i$ 层的高度为 $h_i$。小 A 会用仙术，每用一次可以让他向上跳一层或两层，但是每次跳跃后小 A 都将用完力气，必须爬过至少一层才能再次跳跃（你可以认为小 A 需要跳两次一层才休息）。

现在小 A 想让你帮他算出爬上塔顶的最短时间。

## 样例 #1

### 输入

```
5
3 5 1 8 4```

### 输出

```
1```

# AI分析结果



### 综合分析与结论
该题核心是动态规划，关键在于状态定义与转移方程的设计。各题解主要围绕「跳跃后必须爬楼」的约束展开，思路集中在以下两种方向：
1. **一维状态设计**：通过`f[i]`表示到达第i层之上的最短时间，通过前三个状态的最小值推导（如Clu3ter解法）。
2. **二维状态设计**：通过`f[i][0/1]`区分最后一步是否使用跳跃，更显式地处理连续跳跃限制（如Last_Reincarnation解法）。

### 精选题解推荐

#### 1. Clu3ter（5星）
**核心亮点**：  
- 状态定义清晰（`f[i]`表示到达第i层之上的时间），直接覆盖跳跃后必须爬楼的条件。  
- 状态转移方程简洁高效：`f[i] = min(f[i-1], f[i-2], f[i-3]) + a[i]`，时间复杂度O(n)。  
- 代码简洁，边界处理明确（循环到n+1层）。

**核心代码**：
```cpp
for(int i=1; i<=n+1; i++) {
    f[i] = min(f[i-1], min(f[i-2], f[i-3])) + a[i];
}
cout << f[n+1];
```

#### 2. Last_Reincarnation（4星）
**核心亮点**：  
- 二维状态设计（`f[i][0]`表示最后一次是跳跃，`f[i][1]`是爬楼），显式处理跳跃限制。  
- 状态转移直观：跳跃只能从前一层的爬楼状态转移，爬楼可从前序任意状态转移。

**核心代码**：
```cpp
for (int j = 1; j <= n; ++j) {
    f[j][0] = min(f[j-1][1], f[j-2][1]); // 跳跃转移
    f[j][1] = min(f[j-1][0], f[j-1][1]) + a[j]; // 爬楼转移
}
cout << min(f[n][0], f[n][1]);
```

#### 3. Godのfather（4星）
**核心亮点**：  
- 状态转移方程与Clu3ter类似，但更直接地列出三种转移方式。  
- 边界处理清晰，代码易读性强。

**核心代码**：
```cpp
for(int i=2; i<=n+1; i++) {
    f[i] = min(f[i-1], min(f[i-2], f[i-3])) + a[i];
}
```

### 关键思路与技巧总结
- **状态压缩**：通过合并跳跃后的爬楼操作，将状态转移简化为前三个状态的最小值（Clu3ter解法）。  
- **滚动数组优化**：如flyfree的题解使用滚动变量减少空间复杂度到O(1)。  
- **二维状态设计**：通过区分是否使用跳跃，更严格处理约束条件。

### 拓展与举一反三
- **同类题目推荐**：  
  1. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)（双向DP）  
  2. [P1052 过河](https://www.luogu.com.cn/problem/P1052)（路径压缩+DP）  
  3. [P1434 滑雪](https://www.luogu.com.cn/problem/P1434)（记忆化搜索+DP）  

- **调试心得**：  
  - 如Clu3ter在题解中强调「爬楼是归宿」，源于对跳跃后必须爬楼条件的深刻理解。  
  - 部分题解未处理n+1层导致错误，需注意题目中「超过塔顶」的特殊情况。

---
处理用时：80.48秒
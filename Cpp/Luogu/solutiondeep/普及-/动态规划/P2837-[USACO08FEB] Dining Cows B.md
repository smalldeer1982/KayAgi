# 题目信息

# [USACO08FEB] Dining Cows B

## 题目描述

为了避免餐厅过分拥挤，FJ 要求奶牛们分 $2$ 批就餐。每天晚饭前，奶牛们都会在餐厅前排队入内，按 FJ 的设想，所有第 $2$ 批就餐的奶牛排在队尾，队伍的前半部分则由设定为第 $1$ 批就餐的奶牛占据。

由于奶牛们不理解 FJ 的安排，晚饭前的排队成了一个大麻烦。 第 $i$ 头奶牛有一张标明她用餐批次 $D_i$ 的卡片。虽然所有 $N$ 头奶牛排成了很整齐的队伍，但谁都看得出来，卡片上的号码是完全杂乱无章的。 在若干次混乱的重新排队后，FJ 找到了一种简单些的方法：奶牛们不动，他沿着队伍从头到尾走一遍，把那些他认为排错队的奶牛卡片上的编号改掉，最终得到一个他想要的每个组中的奶牛都站在一起的队列，例如 $112222$ 或 $111122$。有的时候，FJ 会把整个队列弄得只有 $1$ 组奶牛（比方说，$1111$ 或 $222$）。 

你也晓得，FJ 是个很懒的人。他想知道，如果他想达到目的，那么他最少得改多少头奶牛卡片上的编号。所有奶牛在 FJ 改卡片编号的时候，都不会挪位置。

## 说明/提示

$1 \le N \le 3 \times 10 ^ 4$

## 样例 #1

### 输入

```
7
2
1
1
1
2
2
1```

### 输出

```
2```

## 样例 #2

### 输入

```
5
2
2
1
2
2```

### 输出

```
1```

# AI分析结果



### 综合分析与结论  
本题核心目标是将序列分为前半全1、后半全2，求最少修改次数。题解主要采用动态规划（DP）、前缀和枚举分割点、最长不下降子序列（LIS）三种思路。其中最优解法为**动态规划**和**单次遍历统计分割点**，两者均达到O(n)时间、O(1)或低空间复杂度，直接针对问题特性设计，高效且代码简洁。

---

### 高星题解推荐  
#### 1. 作者：AK_Zero（5星）  
**关键亮点**：  
- 通过一次遍历维护分割点前后的修改次数，无需预处理数组，空间复杂度O(1)。  
- 初始统计全改为2的代价，遍历时动态调整分割点，巧妙利用变量增减计算最小代价。  
**代码核心**：  
```cpp
int main() {
    int n, gb = 0, mi = INF;
    for (int i = 1; i <= n; i++) {
        cin >> a[i]; 
        if (a[i] == 1) gb++; // 初始全改为2的代价
    }
    mi = gb;
    for (int i = 1; i <= n; i++) {
        if (a[i] == 2) gb++; // 当前是2，分割点后需改为2，增加代价
        else gb--;           // 当前是1，分割点后无需修改，减少代价
        mi = min(mi, gb);    // 动态更新最小值
    }
    cout << mi;
}
```

#### 2. 作者：S_C_Yesterday（5星）  
**关键亮点**：  
- 动态规划优化到极致，仅用两个变量维护状态，空间复杂度O(1)。  
- 状态转移简洁，直接根据当前数值更新修改次数。  
**代码核心**：  
```cpp
int main() {
    int opt[2] = {0}; // opt[0]为当前是1的代价，opt[1]为当前是2的代价
    while (n--) {
        if (read() == 1) {
            opt[1] = min(opt[1], opt[0]) + 1; // 当前为1时，前驱可以是1或2
        } else {
            opt[1] = min(opt[1], opt[0]);    // 当前为2时，前驱可以是1或2
            opt[0]++;                        // 修改为1的代价增加
        }
    }
    cout << min(opt[0], opt[1]);
}
```

#### 3. 作者：AnChun999（4星）  
**关键亮点**：  
- 预处理前缀和数组，枚举分割点计算代价，逻辑清晰易懂。  
- 时间复杂度O(n)，空间复杂度O(n)，适合理解前缀和思想。  
**代码核心**：  
```cpp
for (int i = 1; i <= n; i++) {
    ll[i] = ll[i-1] + (a[i] == 1); // 前缀1的个数
    rr[i] = rr[i-1] + (a[i] == 2); // 前缀2的个数
}
ans = min(ll[n], rr[n]); // 全1或全2的最小值
for (int i = 2; i <= n; i++) {
    // 分割点i前改1的代价（rr[i-1]） + 分割点i后改2的代价（ll[n]-ll[i-1]）
    ans = min(ans, (ll[n] - ll[i-1]) + rr[i-1]);
}
```

---

### 关键思路与技巧总结  
1. **分割点动态维护**：通过遍历时实时统计分割点前后的代价变化，避免预处理数组（AK_Zero解法）。  
2. **状态压缩DP**：用滚动数组或变量代替二维DP数组，极大优化空间（S_C_Yesterday解法）。  
3. **问题特性利用**：序列仅含1和2，可通过数学分析简化逻辑，如最长不下降子序列（LIS）长度与最少修改次数的关系。  

---

### 拓展与相似题目  
1. **P2858 [USACO06FEB]Treats for the Cows G**（区间DP）  
2. **P2896 [USACO08FEB]Eating Together S**（类似的分割序列问题）  
3. **P1020 [NOIP1999 提高组] 导弹拦截**（最长不下降子序列应用）

---
处理用时：56.94秒
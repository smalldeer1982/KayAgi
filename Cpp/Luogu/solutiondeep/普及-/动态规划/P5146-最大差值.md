# 题目信息

# 最大差值

## 题目描述

HKE 最近热衷于研究序列，有一次他发现了一个有趣的问题：

对于一个序列 $A_1,A_2,\cdots,A_n$，找出两个数 $i,j$（$1\le i<j\le n$），使得 $A_j-A_i$ 最大。

现在给出这个序列，请找出 $A_j-A_i$ 的最大值。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，$n\le1000$；
- 对于 $70\%$ 的数据，$n\le10^5$；
- 对于 $100\%$ 的数据：$2\le n\le 10^6$，$A_i$ 在 int 范围内。

## 样例 #1

### 输入

```
10
1
3
4
6
7
9
10
1
2
9

```

### 输出

```
9```

# AI分析结果



### 综合分析与结论
各题解的核心思路高度一致：**维护遍历过程中的最小值，并实时计算当前元素与历史最小值的差值**。通过这种贪心策略，将时间复杂度优化至O(n)，空间O(1)。所有题解均避免了暴力枚举，但实现细节略有差异。

---

### 高星题解推荐
#### 1. 雨伞CKY（★★★★★）
**关键亮点**：  
- 边读入边处理，无需存储完整数组，极致空间优化  
- 初始值用`LLONG_MIN`保证正确性  
- 代码简洁高效，逻辑清晰  

**核心代码**：  
```cpp
minn = A[1]; // 初始最小值
for (int i = 2; i <= n; i++) {
    ans = max(ans, tmp - minn); // 更新最大差值
    if (tmp < minn) minn = tmp; // 更新最小值
}
```

#### 2. Kobe303（★★★★☆）
**关键亮点**：  
- 明确强调数据范围导致long long的必要性  
- 用`-1e15`初始化答案，避免溢出风险  

**代码片段**：  
```cpp
ans = -1e15; // 极小的初始值
minx = first_element;
for (遍历后续元素) {
    ans = max(ans, x - minx);
    if (x < minx) minx = x;
}
```

#### 3. Miracle_ZX（★★★★☆）
**个人心得**：  
> "maxn的初值要赋得足够小，否则#13测试点会出错"  
**启示**：极端边界条件的初始化直接影响正确性。

**实现亮点**：  
- 单变量`pre`维护最小值，逻辑紧凑  
- 注释明确解释在线更新思想  

---

### 最优思路提炼
**关键技巧**：  
1. **贪心维护最小值**：每个元素只需与历史最小值计算差值，无需关心后续值  
2. **滚动更新**：在读入时即时处理，避免存储完整数组  
3. **边界处理**：用极值初始化答案变量，防止初始状态干扰  

---

### 拓展与举一反三
**同类问题**：  
- 股票买卖问题（只允许一次交易）  
- 序列中寻找连续子数组最大和  
- 多维极值维护（如同时维护最大、次大值）  

**推荐题目**：  
1. [P1217 买卖股票的最佳时机](https://www.luogu.com.cn/problem/P1217)  
2. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)  
3. [P1887 滑动窗口最大值](https://www.luogu.com.cn/problem/P1887)

---
处理用时：45.00秒
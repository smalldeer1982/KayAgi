# 题目信息

# [蓝桥杯 2020 省 AB1] 走方格

## 题目描述

在平面上有一些二维的点阵。

这些点的编号就像二维数组的编号一样，从上到下依次为第 $1$ 至第 $n$ 行，从左到右依次为第 $1$ 至第 $m$ 列，每一个点可以用行号和列号来表示。

现在有个人站在第 $1$ 行第 $1$ 列，要走到第 $n$ 行第 $m$ 列。只能向右或者向下走。

注意，如果行号和列数都是偶数，不能走入这一格中。

问有多少种方案。

## 说明/提示

$1\le n,m\le30$。

蓝桥杯 2020 第一轮省赛 A 组 G 题（B 组 H 题）。

## 样例 #1

### 输入

```
3 4```

### 输出

```
2```

# AI分析结果



### 综合分析与结论
本题解核心在于动态规划（DP）或记忆化搜索，处理行、列均为偶数的障碍点。关键点：
1. **状态定义**：`dp[i][j]` 表示到达 `(i,j)` 的路径数。
2. **转移方程**：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`，障碍点直接置零。
3. **优化技巧**：记忆化搜索避免重复计算；递推法通过初始化技巧简化边界处理。

---

### 精选题解与评分
#### 1. da_ke（⭐⭐⭐⭐⭐）
**关键亮点**：
- 从DFS自然过渡到记忆化搜索，逐步优化思路清晰。
- 提供记忆化模板和常见问题解答，适合学习原理。
- 代码可读性高，注释详细。

**核心代码**：
```cpp
int dfs(int x,int y) {
    if (x>n || y>m) return 0; 
    if (x==n && y==m) return 1;
    if ((x%2==0) && (y%2==0)) return 0;
    if (mem[x][y] != -1) return mem[x][y];
    int ans = dfs(x+1, y) + dfs(x, y+1);
    return mem[x][y] = ans; // 记忆化关键
}
```
**个人心得**：强调条件判断顺序，避免逻辑错误；通过问答解释记忆化必要性。

#### 2. Ggsddu_zzy（⭐⭐⭐⭐）
**关键亮点**：
- 直接递推实现动态规划，代码简洁。
- 初始化第一行/列为1，符合直觉。

**核心代码**：
```cpp
for (int i=2; i<=n; i++) {
    for (int j=2; j<=m; j++) {
        if (i%2==0 && j%2==0) f[i][j] = 0;
        else f[i][j] = f[i-1][j] + f[i][j-1];
    }
}
```

#### 3. WA_sir（⭐⭐⭐⭐⭐）
**关键亮点**：
- **初始化技巧**：`_[0][1] = 1` 简化第一行/列处理。
- 代码极简，仅6行实现核心逻辑。

**核心代码**：
```cpp
_[0][1] = 1;
for (int i=1; i<=n; i++)
    for (int j=1; j<=m; j++)
        if (i%2 || j%2)
            _[i][j] = _[i-1][j] + _[i][j-1];
```

---

### 最优技巧总结
1. **记忆化搜索**：递归转DP利器，避免指数级复杂度。
2. **递推初始化技巧**：如 `_[0][1] = 1` 避免单独处理边界。
3. **障碍点处理**：在循环中直接判断条件，灵活置零。

---

### 同类题目推荐
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)（动态规划+障碍处理）
2. [P1464 Function](https://www.luogu.com.cn/problem/P1464)（记忆化搜索经典）
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)（背包问题，理解状态转移）

---

### 个人心得知乎
- **da_ke**：条件顺序错误可能导致逻辑漏洞，需仔细验证。
- **WA_sir**：通过巧妙的初始化减少代码量，体现对问题的深刻理解。

---
处理用时：121.33秒
# 题目信息

# [蓝桥杯 2021 省 AB] 砝码称重

## 题目描述

你有一架天平和 $N$ 个砝码, 这 $N$ 个砝码重量依次是 $W_{1}, W_{2}, \cdots, W_{N}$ 。 请你计算一共可以称出多少种不同的重量?

注意砝码可以放在天平两边。


## 说明/提示

**【样例说明】**

能称出的 10 种重量是: $1 、 2 、 3 、 4 、 5 、 6 、 7 、 9 、 10 、 11$ 。

$$
\begin{aligned}
&1=1 \\
&2=6-4(\text { 天平一边放 } 6, \text { 另一边放 4) } \\
&3=4-1 \\
&4=4 \\
&5=6-1 \\
&6=6 \\
&7=1+6 \\
&9=4+6-1 \\
&10=4+6 \\
&11=1+4+6
\end{aligned}
$$

**【评测用例规模与约定】**

对于 $50 \%$ 的评测用例, $1 \leq N \leq 15$ 。

对于所有评测用例, $1 \leq N \leq 100, N$ 个砝码总重不超过 $10^5$。 

蓝桥杯 2021 第一轮省赛 A 组 F 题（B 组 G 题）。

## 样例 #1

### 输入

```
3
1 4 6```

### 输出

```
10```

# AI分析结果



### 综合分析与结论
本题核心是动态规划处理可称重量的可能性集合，关键难点在于砝码可放天平两侧的负权处理。最优解法为**bitset优化状态转移**，通过位运算的并行性大幅提升效率。次优解采用滚动数组+偏移量处理负数下标，或二维DP的绝对值转移。

---

### 精选题解分析

#### 1. 作者：loser_seele（★★★★★）
**核心亮点**：
- **bitset优化**：利用位运算左移/右移实现加减法的快速状态转移，时间复杂度降至 $O(\frac{n\sum w}{w})$。
- **代码极简**：仅用两次 `|=` 操作完成全部状态转移，且无需处理负数。
- **空间优化**：单 bitset 替代二维数组，空间占用仅为 $O(\sum w)$。

**代码核心**：
```cpp
bitset<100010> d; // 存储可达状态
d.set(0);         // 初始状态0可达
for (砝码w : 所有砝码) {
    d |= d << w;  // 处理加法（砝码放同侧）
    d |= d >> w;  // 处理减法（砝码放异侧）
}
cout << d.count() - 1; // 统计非零可达状态
```

#### 2. 作者：RP_INT_MAX（★★★★☆）
**核心亮点**：
- **滚动数组+偏移量**：用两行数组交替更新，通过偏移量处理负数下标。
- **在线处理**：逐个读取砝码并更新状态，节省内存。
- **对称状态转移**：显式处理加、减两种转移，逻辑清晰。

**关键代码片段**：
```cpp
bool f[2][300010]; // 滚动数组+偏移量
f[0][N] = 1;       // 初始状态
for (int i=1; i<=n; ++i) {
    for (int j=-sum; j<=sum; ++j) {
        f[i&1][j+N] = f[i-1&1][j-w+N] || // 加砝码
                      f[i-1&1][j+w+N] || // 减砝码
                      f[i-1&1][j+N];     // 不选
    }
}
```

#### 3. 作者：ryf_loser（★★★★☆）
**核心亮点**：
- **直观状态转移**：直接枚举四种转移条件，代码易于理解。
- **倒序更新**：避免覆盖问题，确保无后效性。
- **二维DP模板**：适合动态规划初学者学习。

**代码要点**：
```cpp
for (int i=1; i<=n; i++) {
    for (int j=sum; j>0; j--) {
        if (j == w[i]) dp[i][j] = 1;            // 单独选当前砝码
        else if (dp[i-1][j]) dp[i][j] = 1;      // 不选当前砝码
        else if (dp[i-1][j+w[i]]) dp[i][j] = 1; // 当前砝码放异侧（加）
        else if (dp[i-1][abs(j-w[i])]) dp[i][j]=1; // 当前砝码放同侧（减）
    }
}
```

---

### 关键思路总结
1. **状态定义**：用布尔值表示可达重量，通过动态规划累加可能性。
2. **转移优化**：
   - **bitset位运算**：左移表加法，右移表减法，或运算合并状态。
   - **偏移量技巧**：将负数下标映射到正数范围，避免越界。
3. **滚动数组**：交替使用两行数组，降低空间复杂度至 $O(\sum w)$。

---

### 同类题目推荐
1. [P2347 砝码称重](https://www.luogu.com.cn/problem/P2347) - 多重背包可行性问题。
2. [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273) - 树形DP结合背包思想。
3. [P4141 消失之物](https://www.luogu.com.cn/problem/P4141) - 背包问题的逆向思维。

---

### 心得摘录
- **loser_seele**：  
  > "利用 bitset 的位运算特性，将加减法转化为位移操作，极大优化了转移速度。"  
  （启示：善用 STL 容器特性进行算法优化）

- **RP_INT_MAX**：  
  > "通过偏移量将负数下标映射到正数范围，是处理对称型状态转移的通用技巧。"  
  （调试经验：偏移量的选择需覆盖所有可能范围）

---
处理用时：80.67秒
# 题目信息

# 图的存储与出边的排序

## 题目描述

给定一个 $n$ 个点 $m$ 条边的有向图 $G$，结点编号从 $1$ 至 $n$。对于 $u = 1, 2, 3, \dots n$，依次完成如下要求：  
对于 $u$ 的所有出边（即从 $u$ 出发的边），按照**从小到大**的顺序输出出边所指向的节点编号。

**依次完成**的含义是，先按顺序输出 $u = 1$ 的出边所指向的点的编号，再按顺序输出 $u = 2$ 的出边所指向的点的编号……最后按顺序输出 $u = n$ 的出边所指向的点的编号。

## 说明/提示

### 数据规模与约定：

对于全部的测试点，保证 $1 \leq T, n, m \leq 5 \times 10^5$，但同时各测试点的 $n$ 与 $m$ 之和均不超过 $5 \times 10^5$，即 $\sum n, \sum m \leq 5 \times 10^5$。且 $1 \leq u, v \leq n$，每组数据内不存在重边。

### 提示

请注意大量读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
2
3 4
1 3
1 2
3 2
3 1
3 9
1 3
2 3
3 3
1 2
2 2
3 2
1 1
2 1
3 1```

### 输出

```
2 3

1 2
1 2 3
1 2 3
1 2 3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕有向图的存储与出边排序展开，采用了不同的数据结构和方法来解决问题。各题解的核心思路都是先存储图的边信息，再对每个节点的出边进行排序并输出。

- **Firstly**：使用 `set` 存储图，利用 `set` 自动去重和排序的特性，避免了额外的排序操作。
- **Zboh_Zbp**：使用 `vector` 存储图，在存储完边信息后，对每个节点的出边进行排序。
- **luckydrawbox**：提供了邻接表和链式前向星两种存储图的方法，最后都对每个节点的出边进行排序。
- **tZEROちゃん**：先将输入的边信息存储在 `pair` 数组中，排序后再存入 `vector` 中。

### 所选题解
- **Firstly（5星）**
    - **关键亮点**：思路清晰，使用 `set` 存储图，利用其自动去重和排序的特性，减少了排序操作，代码中还使用了快读快写优化输入输出效率。
    - **核心代码**：
```cpp
#include<cstdio>
#include<set>
using namespace std;
const int maxn=5e5+5;
int t,n,m,x,y;
set<int>s[maxn];
inline int read(){
    int s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-48,ch=getchar();
    return s*w;
}
inline void write(int x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+48);
}
int main(){
    t=read();
    while(t--){
        n=read();m=read();
        for(int i=1;i<=n;i++)s[i].clear();
        for(int i=1;i<=m;i++){
            x=read();y=read();
            s[x].insert(y);
        }
        for(int i=1;i<=n;i++){
            for(auto it=s[i].begin();it!=s[i].end();it++)
                write(*it),putchar(' ');
            putchar('\n');
        }
    }
    return 0;
}
```
**核心实现思想**：使用 `set<int> s[maxn]` 以邻接表的格式存储图，每读取一条边，就用 `s[x].insert(y)` 存进去，最后直接遍历 `s[i]` 输出所有终点。

### 最优关键思路或技巧
- 使用 `set` 存储图，利用其自动去重和排序的特性，避免了额外的排序操作，简化了代码逻辑。
- 采用快读快写优化输入输出，提高程序效率。

### 可拓展之处
同类型题或类似算法套路：
- 无向图的存储与遍历，可在有向图的基础上稍作修改。
- 图的最短路径问题，可使用 Dijkstra、Floyd 等算法。
- 图的连通性问题，可使用并查集、深度优先搜索等算法。

### 推荐题目
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
- [P1113 杂务](https://www.luogu.com.cn/problem/P1113)
- [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)

### 个人心得
题解中未包含个人心得。

---
处理用时：23.42秒
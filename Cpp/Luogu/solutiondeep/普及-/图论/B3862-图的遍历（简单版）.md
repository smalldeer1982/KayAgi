# 题目信息

# 图的遍历（简单版）

## 题目描述

给出 $N$ 个点，$M$ 条边的有向图，对于每个点 $v$，求 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。

## 说明/提示

- 对于 $100\%$ 的数据，$1 \leq N,M \leq 10^3$。

## 样例 #1

### 输入

```
4 3
1 2
2 4
4 3```

### 输出

```
4 4 3 4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕图的遍历展开，通过 DFS 或 BFS 来解决从每个点出发能到达的编号最大的点的问题。大部分题解采用 DFS 算法，部分题解使用反向建边的技巧优化搜索过程。不同题解在思路清晰度、代码可读性和优化程度上存在差异。

### 所选题解
- **作者：Base_ring_tree（5星）**
  - 关键亮点：思路清晰，采用反向建边优化搜索，代码实现简洁明了。
  - 个人心得：无

- **作者：yzm0325（4星）**
  - 关键亮点：逆向思维，反向建边，复杂度较低，代码简洁高效。
  - 个人心得：提到 P3916 有弱化版来水题解，暗示本题相对简单。

### 重点代码
#### Base_ring_tree 的核心代码
```cpp
void dfs(int u, int i)
{
    if(vis[u])
    {
        //如果这个点被别的点到达过, 则不能再走了
        return;
    }
    vis[u] = 1;
    a[u] = i;
    for(auto v: g[u])
    {
        if(vis[v] == 0)
        {
            dfs(v, i);
        }
    }
}

signed main()
{
    cin >> n >> m;
    for(int i=1; i<=m; i++)
    {
        int u, v;
        cin >> u >> v;
        g[v].push_back(u);
    }
    for(int i=n; i>=1; i--)
    {
        dfs(i, i);
    }
    for(int i=1; i<=n; i++)
    {
        cout << a[i] << " ";
    }
    return 0;
}
```
核心实现思想：反向建边，按节点编号从大到小依次进行 DFS 遍历，标记每个点能到达的最大编号。

#### yzm0325 的核心代码
```cpp
void dfs(int x, int v) {
    a[x] = v;
    for (int i = 0; i < p[x].size(); i++)
        if (!a[p[x][i]]) dfs(p[x][i], v);
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        p[v].push_back(u);
    }
    for (int i = n; i > 0; i--)
        if (!a[i]) dfs(i, i);
    for (int i = 1; i <= n; i++) cout << a[i] << ' ';
    return 0;
}
```
核心实现思想：反向建边，从大到小遍历节点，若节点未被标记则进行 DFS 标记，记录每个节点能到达的最大值。

### 最优关键思路或技巧
- **反向建边**：通过反向建边，将问题转化为从编号大的点出发，能到达哪些点，从而减少不必要的搜索，提高效率。
- **逆向思维**：考虑每个点是哪些点能到达的最大值，而不是直接搜索每个点能到达的最大值。

### 可拓展之处
同类型题可包括有向图的连通性问题、无向图的遍历问题等。类似算法套路可用于拓扑排序、强连通分量等问题。

### 推荐题目
- P1330 封锁阳光大学
- P2853 [USACO06DEC]Cow Picnic S
- P1141 01迷宫

### 个人心得总结
- 部分作者提到要注意初始化，避免多测不清空导致错误。
- 有作者提到用 DFS 做数据强化版题目只能得 90 分，暗示不同数据范围下算法的适用性不同。

---
处理用时：26.05秒
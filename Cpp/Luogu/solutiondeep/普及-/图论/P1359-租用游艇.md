# 题目信息

# 租用游艇

## 题目描述

长江游艇俱乐部在长江上设置了 $n$ 个游艇出租站 $1,2,\cdots,n$。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站 $i$ 到游艇出租站 $j$ 之间的租金为 $r(i,j)$（$1\le i\lt j\le n$）。试设计一个算法，计算出从游艇出租站 $1$ 到游艇出租站 $n$ 所需的最少租金。

## 说明/提示

$n\le 200$，保证计算过程中任何时刻数值都不超过 $10^6$。

## 样例 #1

### 输入

```
3
5 15
7

```

### 输出

```
12

```

# AI分析结果

### 综合分析与结论
本题是一个求从游艇出租站 1 到游艇出租站 n 所需最少租金的问题，本质上是有向图的单源最短路径问题。题解主要围绕动态规划（DP）和图论中的最短路算法展开，不同的算法在思路、复杂度和实现细节上各有特点。

动态规划类题解通过定义状态和状态转移方程，逐步计算出从起点到终点的最小租金；图论算法类题解则利用经典的最短路算法，如 Floyd、Dijkstra、SPFA、Bellman - Ford 等来求解。其中，Floyd 算法适合处理小数据量的全源最短路径问题；Dijkstra 算法在处理无负权边的单源最短路径问题时效率较高；SPFA 算法则在处理稀疏图时表现较好；Bellman - Ford 算法能处理含有负权边的单源最短路径问题，但复杂度较高。

### 所选题解
- **作者：BIGBUG（4星）**
    - **关键亮点**：思路清晰，详细解释了存图和动态规划的过程，代码注释丰富，易于理解。
    - **个人心得**：无
- **作者：金庆涵（4星）**
    - **关键亮点**：详细介绍了 Floyd 算法的实现过程，指出了 66 分代码的错误原因并给出修正方法，还提供了 Floyd 算法的模板。
    - **个人心得**：看到数据范围 n <= 200，认为 Floyd 算法简单且能通过，发现 66 分代码把图当成无向图处理的漏洞，修正后得到 AC 代码。
- **作者：unbeatable_noob（4星）**
    - **关键亮点**：使用裸的 Dijkstra 算法一次通过，用邻接矩阵存储图，代码简洁明了，适合初学者理解 Dijkstra 算法的基本实现。
    - **个人心得**：无

### 重点代码与核心思想
#### BIGBUG 的题解
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int a[201][201],i,j,n,dp[201];
int main(){
    cin>>n;
    for(i=1;i<n;i++){
        for(j=i+1;j<=n;j++)
            cin>>a[i][j];
        dp[i]=1e9;
    }
    for(i=n-1;i>=1;i--)//跑n上流的中转站
        for(j=i+1;j<=n;j++)//跑i下流的所有中转站
            dp[i]=min(dp[i],a[i][j]+dp[j]);//记录
    cout<<dp[1];
    return 0;
}
```
**核心思想**：用 `a` 数组存储图，`dp[i]` 表示中转站 `i` 到中转站 `n` 的最小价钱。从 `n - 1` 开始倒序遍历每个中转站，对于每个中转站 `i`，遍历其下游的所有中转站 `j`，更新 `dp[i]` 为 `a[i][j] + dp[j]` 中的最小值。

#### 金庆涵的题解
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a[201][201];
int egde(int u,int v,int x){
    a[u][v]=x;
}
int main()
{
    int n;scanf("%d",&n);
    memset(a,0x3f,sizeof(a));
    for(int i=1;i<=n;i++)//边的创建
        for(int j=i;j<=n;j++){
            if(i==j)a[i][j]=0;
            else{
                int x;cin>>x;
                egde(i,j,x);
            }
        }
    for(int k=1;k<=n;k++)//floyd
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++){
                a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
            }
    printf("%d",a[1][n]);
    return 0;
}
```
**核心思想**：使用 Floyd 算法，通过三重循环，枚举中间点 `k`、起点 `i` 和终点 `j`，不断更新 `a[i][j]` 为 `a[i][k] + a[k][j]` 和 `a[i][j]` 中的最小值，最终得到从 1 到 `n` 的最短路径。

#### unbeatable_noob 的题解
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int INF = 9999999;
int main()
{
    int n,g[205][205];
    cin >> n;
    for(int i = 1;i <= n;i++)
        for(int j = 1;j <= n;j++)
        {
            if(i == j)
                g[i][j] = 0;
            else
                g[i][j] = INF;
        }
    for (int i = 1;i <= n-1;i++)
        for(int j = i+1;j <= n;j++)
        {
            cin >> g[i][j];
        }
    //dijstkra
    int dis[205],book[205];
    memset(book,0,sizeof(book));
    for(int i = 1;i <= n;i++)
        dis[i] = g[1][i];
    dis[1] = 0;
    book[1] = 1;
    for(int i = 2;i <= n;i++)
    {
        int mind = INF,u;
        for(int j = 1;j <= n;j++)
        {
            if(!book[j] && dis[j] < mind)
            {
                mind = dis[j];
                u = j;
            } 
        }
        book[u] = 1;
        for(int j = 1;j <= n;j++)
        {
            dis[j] = min(dis[j],dis[u]+g[u][j]);
        }
    }
    cout << dis[n];
    return 0;
}
```
**核心思想**：使用 Dijkstra 算法，用 `g` 数组存储图，`dis` 数组记录从起点 1 到各点的最短距离，`book` 数组标记点是否已确定最短距离。每次从未确定最短距离的点中选择距离最小的点 `u`，标记为已确定，然后更新 `u` 的所有邻接点的最短距离。

### 最优关键思路或技巧
- **动态规划**：合理定义状态数组，如 `dp[i]` 表示从 `i` 到 `n` 的最小租金或从 1 到 `i` 的最小租金，通过状态转移方程逐步递推求解。
- **图论算法**：根据数据范围和图的特点选择合适的算法，如数据量小可使用 Floyd 算法，无负权边可使用 Dijkstra 算法，稀疏图可使用 SPFA 算法。
- **初始化**：在使用图论算法时，要正确初始化距离数组，通常将不可达的距离初始化为一个很大的值。

### 可拓展之处
同类型题或类似算法套路：
- **多源最短路径问题**：可使用 Floyd 算法求解所有点对之间的最短路径。
- **有负权边的最短路径问题**：可使用 Bellman - Ford 算法或 SPFA 算法。
- **路径记录**：在求解最短路径的基础上，可记录最短路径的具体路径，通过前驱数组实现。

### 推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：涉及 Floyd 算法的动态更新。
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：考察 Dijkstra 算法和 SPFA 算法。
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：考察 Dijkstra 算法的堆优化。

### 个人心得总结
- **注意图的方向**：很多题解提到要注意本题是有向图，不能将其当成无向图处理，否则会导致错误。
- **数据范围与算法选择**：根据数据范围选择合适的算法，如数据量小的情况下，可优先考虑实现简单的 Floyd 算法。
- **初始化的重要性**：在使用图论算法时，正确的初始化距离数组是保证算法正确性的关键。

---
处理用时：51.75秒
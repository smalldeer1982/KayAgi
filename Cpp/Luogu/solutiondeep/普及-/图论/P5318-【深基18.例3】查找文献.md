# 题目信息

# 【深基18.例3】查找文献

## 题目描述

小 K 喜欢翻看洛谷博客获取知识。每篇文章可能会有若干个（也有可能没有）参考文献的链接指向别的博客文章。小 K 求知欲旺盛，如果他看了某篇文章，那么他一定会去看这篇文章的参考文献（如果他之前已经看过这篇参考文献的话就不用再看它了）。

假设洛谷博客里面一共有 $n(n\le10^5)$ 篇文章（编号为 1 到 $n$）以及 $m(m\le10^6)$ 条参考文献引用关系。目前小 K 已经打开了编号为 1 的一篇文章，请帮助小 K 设计一种方法，使小 K 可以不重复、不遗漏的看完所有他能看到的文章。

这边是已经整理好的参考文献关系图，其中，文献 X → Y 表示文章 X 有参考文献 Y。不保证编号为 1 的文章没有被其他文章引用。

![](https://cdn.luogu.com.cn/upload/image_hosting/f4n4tlhi.png)

请对这个图分别进行 DFS 和 BFS，并输出遍历结果。如果有很多篇文章可以参阅，请先看编号较小的那篇(因此你可能需要先排序)。

## 样例 #1

### 输入

```
8 9
1 2
1 3
1 4
2 5
2 6
3 7
4 7
4 8
7 8```

### 输出

```
1 2 5 6 3 7 8 4 
1 2 3 4 5 6 7 8 ```

# AI分析结果

### 综合分析与结论
这些题解均围绕图的深度优先搜索（DFS）和广度优先搜索（BFS）展开，用于解决有向图的遍历问题。在存储图结构时，考虑到数据规模，均避免使用邻接矩阵，而采用邻接表相关的数据结构。各题解在思路上大体一致，但在实现细节和代码风格上有所差异。

### 所选题解
- **作者：yangrunze（5星）**
    - **关键亮点**：思路清晰，详细解释了DFS和BFS的原理，通过具体例子阐述图的遍历过程；对存储图的二维vector方法讲解细致；代码注释丰富，可读性强。
    - **核心代码及思想**：
```cpp
// 深度优先遍历
void dfs(int x){
    vis1[x]=1;
    cout<<x<<" ";
    for(int i=0;i<e[x].size();i++){
        int point=s[e[x][i]].v;
        if(!vis1[point]){
            dfs(point);
        }
    }
}
// 广度优先遍历
void bfs(int x){
    queue <int> q;
    q.push(x);
    cout<<x<<" ";
    vis2[x]=1;
    while(!q.empty()){
        int fro=q.front();
        for(int i=0;i<e[fro].size();i++){
            int point=s[e[fro][i]].v;
            if(!vis2[point]){
                q.push(point);
                cout<<point<<" ";
                vis2[point]=1;
            }
        }
        q.pop();
    }
}
```
思想：DFS采用递归方式，沿着一条路径走到黑，再回溯；BFS使用队列，按层遍历。

- **作者：zhangyuhan（4星）**
    - **关键亮点**：对DFS和BFS的原理用通俗的语言解释，易于理解；代码结构清晰，注释明确，实现了基本的图遍历功能。
    - **核心代码及思想**：
```cpp
// 深度优先遍历
void dfs(int x, int cur) {
    visited[x] = true;
    cout << x << " ";
    if (cur == n) return ;
    for (int i=0; i<G[x].size(); i++)
        if (!visited[G[x][i]]) dfs(G[x][i], cur+1);
}
// 广度优先遍历
void bfs(int x) {
    memset(visited, false, sizeof(visited));
    visited[x] = true;
    q.push(x);
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        cout << v << " ";
        for (int i=0; i<G[v].size(); i++) 
            if (!visited[G[v][i]]) {
                visited[G[v][i]] = true;
                q.push(G[v][i]);
            }
    }
}
```
思想：DFS递归遍历，BFS用队列存储待遍历节点，按层输出。

- **作者：UnyieldingTrilobite（4星）**
    - **关键亮点**：使用set代替邻接表的vector，自动排序满足题目要求；对DFS和BFS的实现方式有独特见解，如用栈实现DFS，用队列实现BFS，并解释了原理。
    - **核心代码及思想**：
```cpp
// 深度优先遍历
void dfs(int x=1){
    if(vis[x])return;vis[x]=1;
    printf("%d ",x);
    for(int v:e[x])dfs(v);
}
// 广度优先遍历
void bfs(){
    queue<int>q;
    q.push(1);
    while(!q.empty()){
        int x=q.front();q.pop();
        if(vis[x])continue;vis[x]=1;
        printf("%d ",x);
        for(int v:e[x])q.push(v);
    }
}
```
思想：DFS递归遍历邻居节点，BFS用队列按顺序遍历节点。

### 最优关键思路或技巧
- **数据结构**：使用邻接表（如二维vector、set）存储图，避免邻接矩阵的空间浪费。
- **排序**：对邻接表存储的节点进行排序，保证遍历顺序符合字典序最小的要求。
- **标记数组**：使用标记数组记录节点是否被访问过，避免重复访问。

### 拓展思路
同类型题或类似算法套路：
- 无权图的最短路径问题：可使用BFS求解。
- 连通分量问题：通过DFS或BFS找出图中的连通分量。
- 拓扑排序：在有向无环图中，可使用DFS或BFS实现拓扑排序。

### 推荐题目
- P1330 封锁阳光大学：图的染色问题，可使用DFS或BFS解决。
- P1135 奇怪的电梯：类似图的遍历，使用BFS求解最短路径。
- P1605 迷宫：二维迷宫的路径搜索问题，可使用DFS或BFS。

### 个人心得摘录与总结
- **作者：Varuxn**：“可我竟然没有一遍AC”“本人在此处卡了while(1)n++次”，总结为在解题过程中可能会遇到困难，即使是看似简单的模板题也可能无法一次通过，需要不断调试和优化。 

---
处理用时：32.68秒
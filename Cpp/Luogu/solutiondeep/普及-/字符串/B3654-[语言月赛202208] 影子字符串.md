# 题目信息

# [语言月赛202208] 影子字符串

## 题目背景

众所周知，影子并不是实际物体。

## 题目描述

给出多个字符串（数目未知），**每行**一个。

其中有可能会有重复的字符串，而我们认为在这些字符串中，较靠后出现的都是靠前出现的字符串的“**影子**”。

例如，

```plain
abc
def
abc
abc
abc
```

我们在第 $1,3,4,5$ 行都出现了字符串 `abc`，那么 $3,4,5$ 行的字符串会被称为“影子字符串”。


现在要求把所有的**非影子字符串**都按照**行号从小到大**依次拼接为一个长串并输出。



## 说明/提示

对于 $20\%$ 的数据，无重复字符串。

对于 $100\%$ 的数据， $1\leq n\leq 500$，字符串总长度不超过 $50000$ ，字符集为全部的小写字母、数字、 `.` 、`!` 和 `&`。

也就是说，每个字符串中只包含小写字母、数字、 `.` 、`!` 和 `&`，不包含空格等特殊符号。

## 样例 #1

### 输入

```
cc
b
a
cc
0```

### 输出

```
ccba```

# AI分析结果

### 综合分析与结论

本题要求处理多个字符串，输出所有非影子字符串（即第一次出现的字符串）。题解主要采用了两种思路：一种是使用数组存储字符串并逐个比较，另一种是使用STL容器（如`set`）来快速判断字符串是否已经出现过。总体来看，题解思路清晰，但部分实现较为基础，未充分利用更高效的数据结构或算法。

### 所选高星题解

#### 题解1：览遍千秋（4星）

**关键亮点**：
- 使用数组存储字符串，并通过遍历数组来判断字符串是否已经出现过。
- 代码简洁，逻辑清晰，适合初学者理解。

**核心代码**：
```cpp
string s[600];
while(true) {
    ++cnt; cin >> s[cnt];
    if(s[cnt] == "0") break;
    bool occ = false;
    for(int i = 1; i < cnt; i++) {
        if(s[i] == s[cnt]) {
            occ = true; break;
        }
    }
    if(occ == false) cout << s[cnt];
}
```

**实现思想**：
- 使用数组`s`存储输入的字符串，`cnt`记录字符串的数量。
- 对于每个新输入的字符串，遍历之前的所有字符串，判断是否已经出现过。如果未出现过，则输出该字符串。

### 通用建议与扩展思路

1. **使用STL容器**：可以使用`set`或`unordered_set`来存储已经出现过的字符串，这样可以快速判断字符串是否重复，时间复杂度为O(1)。
2. **字符串哈希**：如果字符串数量较多，可以使用字符串哈希来加速比较过程。
3. **字典树**：对于更复杂的字符串处理问题，可以考虑使用字典树（Trie）来优化查找和插入操作。

### 推荐题目

1. **P3370 【模板】字符串哈希**：考察字符串哈希的基本应用。
2. **P2580 于是他错误的点名开始了**：考察字符串的快速查找与去重。
3. **P3805 【模板】AC自动机（简单版）**：考察字符串匹配与自动机的应用。

### 个人心得总结

- **调试经历**：在处理字符串时，注意输入结束条件的判断，避免无限循环。
- **踩坑教训**：使用数组存储字符串时，需注意数组大小的设置，避免越界。
- **顿悟感想**：合理选择数据结构可以大幅提升代码效率，尤其是在处理大量数据时。

---
处理用时：18.90秒
# 题目信息

# [语言月赛202211] BAN-PICK

## 题目描述

在第五人格职业联赛的每一场对局中，需要进行 Ban-Pick 流程。Ban 即角色禁用，Pick 即角色选用。

如试题 Winner 所述，游戏分为 **求生者（$\texttt{Survivor}$）** 与 **监管者（$\texttt
{Hunter}$）** 两个阵营。**求生者阵营** 共有 $n$ 名角色，**监管者阵营** 共有 $m$ 名角色。

在某局比赛中，**监管者** 可以 ban(禁用) 掉 **求生者阵营** $5$ 名角色，**求生者** 可以 ban(禁用) 掉 **监管者阵营** $2$ 名角色。

每个角色，无论其属于求生者阵营还是监管者阵营，均可以使用 **熟练度** 来量化该阵营选手选择该角色的优先程度。选手一定会优先选择 **熟练度** 更高的角色进行游戏。

基于这样的考量，**监管者选手** 在进行 Ban 流程时，往往会选择 ban(禁用) 掉 **求生者阵营熟练度最高** 的若干名 **求生者角色**。同样，**求生者选手** 在进行 Ban 流程时，往往会选择 ban(禁用) 掉 **监管者阵营熟练度最高** 的若干名 **监管者角色**。

在 Ban 流程完成后，需要执行 Pick 流程。

如试题 Winner 所述，**求生者选手** 需要从 **求生者阵营** 中选择 $4$ 名不同的角色，**监管者选手** 需要从 **监管者阵营** 中选择 $1$ 名角色。

现在告诉你所有角色的名字、阵营与选手对其熟练度，请你给出双方阵营 Pick 的角色名字。

## 说明/提示

### 输入输出样例 1 解释

求生者阵营角色：$\texttt{Amily,Lydia,Lisa,Freddie,Cliche,Aesop,Eli,Norton,Emma}$。

监管者阵营角色：$\texttt{Beck,Tiletower,Yidhra}$。

监管者选手将 ban 掉求生者阵营中角色 $\texttt{Norton,Eli,Aesop,Cliche,Freddie}$。

求生者选手将 ban 掉监管者阵营中角色 $\texttt{Tiletower,Yidhra}$。

### 数据规模与约定

对于前 $20\%$ 的数据，$n = 9, m = 3$。

对于前 $50\%$ 的数据，保证 $n \leq 10 ^ 3, m \leq 10 ^3$。

对于前 $70\%$ 的数据，保证 $w _ i \leq 10 ^ 9$。

对于所有数据，保证 $9 \leq n \leq 10 ^ 5, 3 \leq m \leq 10 ^ 5$，所有名字长度 $\leq 10$。熟练度大小 $w _ i$ 满足 $1 \leq w _ i \leq 10 ^ {18}$。保证每个阵营中熟练度互不相同。保证名字仅有大写字母和小写字母构成。

## 样例 #1

### 输入

```
9 3
Amily S 1
Lydia S 2
Lisa S 4
Beck H 1
Freddie S 5
Cliche S 6
Aesop S 7
Eli S 8
Norton S 9
Tiletower H 3
Yidhra H 2
Emma S 3
```

### 输出

```
Beck
Lisa
Emma
Lydia
Amily```

# AI分析结果

### 综合分析与结论

本题的核心在于对角色进行分组、排序，并根据熟练度进行筛选输出。题解的关键点在于如何高效地处理输入数据、进行分类排序，并按照规则输出结果。以下是对题解的详细分析与评分。

### 所选题解

#### 题解1：Maxmilite
- **星级：4.5**
- **关键亮点：**
  - 使用结构体 `node` 存储角色信息，简化了数据管理。
  - 在读入时直接分类处理，避免了后续的重复遍历。
  - 使用 `sort` 函数进行排序，代码简洁高效。
  - 输出部分直接按照规则输出，逻辑清晰。
- **个人心得：**
  - 作者提到在读入时直接分类处理，减少了后续的复杂度，这种预处理思路值得借鉴。
- **核心代码：**
  ```cpp
  struct node {
      string name;
      long long val;
  } s[100005], h[100005];

  int cntH = 0, cntS = 0;
  cin >> n >> m;
  for (int i = 1; i <= n + m; ++i) {
      string name, v;
      long long val;
      cin >> name >> v >> val;
      if (v == "H") {
          ++cntH;
          h[cntH].name = name;
          h[cntH].val = val;
      } else {
          ++cntS;
          s[cntS].name = name;
          s[cntS].val = val;
      }
  }

  sort(s + 1, s + cntS + 1, cmp);
  sort(h + 1, h + cntH + 1, cmp);

  cout << h[3].name << endl;
  for (int i = 6; i <= 9; ++i) {
      cout << s[i].name << endl;
  }
  ```

### 最优关键思路与技巧

1. **预处理与分类：** 在读入数据时直接进行分类处理，避免了后续的重复遍历，提高了效率。
2. **结构体与排序：** 使用结构体存储角色信息，简化了数据管理，并通过 `sort` 函数进行高效排序。
3. **规则输出：** 按照题目规则直接输出结果，逻辑清晰，代码简洁。

### 可拓展之处

- **类似题目：** 处理分组、排序、筛选输出的题目，如分组统计、排名筛选等。
- **算法套路：** 预处理、分类、排序、筛选输出的组合应用。

### 推荐题目

1. **P1177 【模板】快速排序** - 考察排序算法的基本应用。
2. **P1059 明明的随机数** - 考察去重与排序。
3. **P1093 奖学金** - 考察多关键字排序与筛选。

### 通用建议与扩展思路

- **预处理：** 在处理复杂数据时，尽量在读入时进行分类或预处理，减少后续操作的复杂度。
- **结构体：** 使用结构体存储复杂数据，简化数据管理，提高代码可读性。
- **排序与筛选：** 熟练掌握 `sort` 函数的使用，灵活应用于各种排序与筛选场景。

通过以上分析与总结，可以更好地理解本题的解题思路与技巧，并在类似题目中举一反三。

---
处理用时：23.05秒
# 题目信息

# [语言月赛202301] 新年快乐

## 题目背景

要过春节了，扶苏收到了她的新年礼物：一个崭新的字符串。

## 题目描述

扶苏收到的字符串是一个只含小写字母的字符串 $s$。

对于一个长度为 $x$ 的只含小写字母的字符串 $t$，我们定义 $t$ 的『上一个字符串』是：将所有的长度为 $x$ 且仅含小写字母的字符串按字典序排列后，恰好排在 $t$ 之前一个的字符串。

例如，字符串 $\texttt{bcd}$ 的『上一个字符串』是 $\texttt{bcc}$，而 $\texttt{aaa}$ 的『上一个字符串』不存在。

现在，扶苏有 $q$ 次询问，每次询问给出一个区间 $[l, r]$，查询：$s$ 的第 $l$ 个到第 $r$ 个字符组成的字符串的『上一个字符串』是否在 $s$ 中出现？

如果查询区间对应的字符串不存在『上一个字符串』，也算作『上一个字符串』没有在 $s$ 中出现。

## 说明/提示

### 数据规模与约定

以下以 $|s|$ 表示输入字符串 $s$ 的长度。

| 测试点编号 | $\mid s \mid \leq$ | $q=$ | 特殊约定 |
| :-: | :-: | :-: | :-: |
| 1 | $1$ | $1$ | 无 |
| 2 | $20$ | $7$ | A,B |
| 3 | $20$ | $8$ | B |
| 4 | $20$ | $9$ | A |
| 5 | $400$ | $198$ | B |
| 6 | $400$ | $199$ | A |
| 7 | $400$ | $199$ | A |
| 8 | $400$ | $200$ | 无 |
| 9 | $400$ | $200$ | 无 |
| 10 | $400$ | $200$ | 无 |

特殊约定 A：保证查询的字符串的『上一个字符串』在 $s$ 中出现。  
特殊约定 B：保证查询的区间满足 $l = r$。

对全部的测试点，保证 $1 \leq |s| \leq 400$，$1 \leq q \leq 200$，$1 \leq l \leq r \leq |s|$，$s$ 中仅包含小写英文字母。

### 提示

你可以通过 $q$ 的末位数字来判定测试点所属的特殊约定信息。


## 样例 #1

### 输入

```
bcdbccaacbzz
5
1 3
5 8
1 1
11 12
7 7```

### 输出

```
bcc
Happy New Year!
cbzz
Happy New Year!
a
Happy New Year!
zy
Happy Chinese New Year!
NULL
Happy Chinese New Year!```

# AI分析结果

### 综合分析

本题的核心在于如何高效地找到给定字符串的“上一个字符串”，并判断其是否在原字符串中出现。题解中主要采用了字符串操作和暴力匹配的方法，虽然时间复杂度较高，但由于数据规模较小，能够通过测试。

### 题解评分与亮点

#### 题解作者：Maxmilite (赞：7)  
**评分：4星**  
**关键亮点：**  
1. **清晰的思路**：通过判断字符串是否全为 'a' 来快速确定是否存在“上一个字符串”，简化了问题。
2. **代码可读性**：代码结构清晰，逻辑明确，易于理解。
3. **优化技巧**：从后向前寻找第一个不为 'a' 的字符，减少了不必要的遍历。

**核心代码：**
```cpp
int flag = 1;
for (int i = 0; i < t.length(); ++i) {
    if (t[i] != 'a') {
        flag = 0;
        break;
    }
}
if (flag) {
    cout << "NULL\nHappy Chinese New Year!\n";
}

for (int i = t.length() - 1; i >= 0; --i)
    if (t[i] == 'a') {
        t[i] = 'z';
    } else {
        --t[i];
        break;
    }

cout << t << endl;
if (s.find(t) != -1) {
    cout << "Happy New Year!\n";
} else {
    cout << "Happy Chinese New Year!\n";
}
```

### 最优关键思路

1. **快速判断是否存在“上一个字符串”**：通过检查字符串是否全为 'a' 来快速确定是否存在“上一个字符串”。
2. **从后向前修改字符**：从字符串的末尾开始，找到第一个不为 'a' 的字符，将其减一，并将其后的字符全部置为 'z'，这样可以高效地生成“上一个字符串”。

### 拓展思路

1. **优化查找**：可以使用更高效的字符串匹配算法（如KMP算法）来替代 `find()` 函数，进一步优化时间复杂度。
2. **预处理**：可以预处理所有可能的子字符串及其“上一个字符串”，利用哈希表进行快速查找，适用于更大规模的数据。

### 推荐题目

1. **P3375 【模板】KMP字符串匹配**：考察字符串匹配算法。
2. **P1042 字符串的展开**：涉及字符串操作和模拟。
3. **P1090 合并果子**：考察贪心算法和优先队列的使用。

### 个人心得

在调试过程中，发现从后向前修改字符的方法比从前向后更高效，减少了不必要的遍历。此外，通过快速判断字符串是否全为 'a'，可以避免无效的计算，提高代码的执行效率。

---
处理用时：20.77秒
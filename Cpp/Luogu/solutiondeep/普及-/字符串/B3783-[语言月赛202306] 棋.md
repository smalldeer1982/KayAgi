# 题目信息

# [语言月赛202306] 棋

## 题目描述

zyl 和「她」在 $n\times m$ 的格子纸上下五子棋。**「她」总是先手**。

现在你会得知以下信息：

- 格子纸的大小 $n, m$，代表棋盘共 $n$ 行 $m$ 列。
- $n$ 个仅由字符 `~`、`*`、`$` 构成的长度为 $m$ 的字符串（即 $n \times m$ 个字符）。对于第 $i$ 个字符串的第 $j$ 个字符，`~` 表示第 $i$ 行第 $j$ 列的格子是空的，`*` 表示「她」已经在这一格落下棋子，`$` 表示 zyl 已经在这一格落下棋子。

类似于五子棋的基本规则，一局棋局由「先手」开始，双方轮流落子。如果有同一行，同一列，或者同一 $45\degree$ 斜对角线有**同一方**的**连续五个**棋子，那这一方便是胜者。

现在，请你以以下方式判断当前的棋局：如果已有一方获胜，请你判断是哪一方获胜。否则，请你判断当前轮到哪一方落子。

## 说明/提示

### 样例 1 解释
在第三列有连续的五个 `*`，所以「她」获胜了。

### 数据规模与约定

对于前 $40\%$ 的数据，保证没有任何一方获胜。

对于 $100\%$ 的数据， $5\leq n,m \leq 30$，字符串仅由 `~`、`*`、`$` 组成，而且不会出现任意同一行，同一列或是同一 $45\degree$ 斜对角线上有连续 6 个或以上连续且相同的 `*` 或 `$`，并且最多只有一条连续的 $5$ 个 `*` 或 `$`。 `*` 的总数不小于 `$` 的总数，且至多比 `$` 的总数大 $1$。保证输入的字符串至少存在一个字符 `~`。






## 样例 #1

### 输入

```
5 5
~~*~$
***~~
~$*~~
~~*~$
$$*$~
```

### 输出

```
Pleasing!```

# AI分析结果

### 综合分析与结论

本题的核心在于判断五子棋的胜负以及当前轮到谁落子。题解主要围绕如何高效地判断五子相连以及如何简化代码实现展开。通过对比多个题解，可以发现以下几个关键点：

1. **胜负判断**：通过枚举每个棋子的位置，检查其四个方向（水平、垂直、两个对角线）是否存在连续五个相同棋子。
2. **代码优化**：使用数组存储方向增量，通过循环简化代码，减少重复判断。
3. **落子判断**：通过统计 `*` 和 `$` 的数量，判断当前轮到谁落子。

### 所选题解

#### 题解1：未来姚班zyl (赞：6)
- **星级**：4.5星
- **关键亮点**：
  - 使用数组存储方向增量，通过循环简化代码，减少重复判断。
  - 代码结构清晰，易于理解。
  - 提供了详细的优化思路，适合初学者学习。
- **核心代码**：
```cpp
const int dx[4]={0,1,1,-1};
const int dy[4]={1,1,0,1};

int l,r;
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(c[i][j] == '~')continue;
        l += c[i][j]=='*',r += c[i][j]=='$';
        for(int k = 0;k < 4;k++){
            int x = i,y = j;
            bool f = 1;
            for(int d = 1;d <= 4;d++){
                x += dx[k],y += dy[k];
                if(x<1||y<1||x>n||y>m){
                    f=0;
                    break;
                }
                if(c[x][y] != c[i][j]){
                    f = 0;
                    break;
                } 
            }
            if(f){
                if(c[i][j]=='*')cout <<"Pleasing!";
                else cout <<"zylwins!";
                return 0;
            } 
        }        
    }
} 
if(l==r)cout <<"W";
else cout <<"Z";
```
- **个人心得**：通过使用数组和循环，大大简化了代码，减少了出错的可能性，同时也提高了代码的可读性。

### 最优关键思路或技巧

1. **方向增量数组**：使用 `dx` 和 `dy` 数组存储方向增量，通过循环简化代码，减少重复判断。
2. **循环判断胜负**：通过循环检查四个方向是否存在连续五个相同棋子，代码简洁且高效。
3. **统计棋子数量**：通过统计 `*` 和 `$` 的数量，判断当前轮到谁落子，逻辑清晰。

### 可拓展之处

1. **类似题目**：可以扩展到其他棋盘类游戏，如围棋、象棋等，判断胜负或当前轮到谁落子。
2. **算法套路**：类似的枚举和方向增量技巧可以应用于其他需要检查连续元素的题目，如迷宫问题、图像处理等。

### 推荐题目

1. **P1003 铺地毯**：考察二维数组的遍历和判断。
2. **P1219 八皇后**：考察棋盘类问题的回溯算法。
3. **P1042 乒乓球**：考察字符串处理和模拟。

### 通用建议与扩展思路

对于棋盘类问题，建议使用方向增量数组和循环来简化代码，减少重复判断。同时，统计棋子数量来判断当前轮到谁落子是一个简单有效的方法。在处理类似问题时，可以考虑使用类似的技巧来提高代码的效率和可读性。

---
处理用时：27.62秒
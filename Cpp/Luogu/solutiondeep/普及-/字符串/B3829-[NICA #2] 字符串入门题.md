# 题目信息

# [NICA #2] 字符串入门题

## 题目背景

小波说这是字符串入门题极好的，所以这是极好的。

## 题目描述

给定一个仅包含大小写字母和数字的字符串 $s$，问能否将 $s$ 拆分成至少 $k$ 个子串 $s_1,s_2,\dots,s_t(t\ge k)$ 满足 $\forall 1<i\le t$ 有 $s_i$ 是 $s_1s_2\dots s_{i-1}$（这里表示的是拼接）的子串。

一个字符串 $s$ 是另一个字符串 $t$ 的子串当且仅当可以通过删除 $t$ 的一个可以为空的前缀以及一个可以为空的后缀后得到 $s$。

## 说明/提示

#### 样例 1 解释

`1145|14`是一种合法的拆分方案，因为拆分出了 $2$ 个字符串且 $2\ge k$，并且`14`是`1145`的一个子串。

#### 样例 2 解释

`a1A|a1|1Aa`是一种合法的拆分方案，因为拆分出了 $3$ 个字符串且 $3\ge k$，并且`a1`是`a1A`的一个子串，且`1Aa`是`a1Aa1`的一个子串。

#### 样例 3 解释

尝试所有拆分方案后发现无论如何拆分都无法满足条件。

#### 数据范围

对于所有数据，满足 $2\le k\le n\le 10^6$，$s$ 仅由大小写字母和数字构成。

## 样例 #1

### 输入

```
6 2
114514```

### 输出

```
2
1145
14```

## 样例 #2

### 输入

```
8 2
a1Aa11Aa```

### 输出

```
3
a1A
a1
1Aa```

## 样例 #3

### 输入

```
11 2
stoImakforz```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论

这些题解的核心思路基本一致，即通过将字符串拆分为尽可能长的第一个子串和后续的单个字符子串，来满足题目要求。具体来说，题解们普遍采用以下策略：

1. **贪心策略**：尽可能让第一个子串最长，后续子串长度为1，以最大化满足条件的可能性。
2. **字符记录**：通过数组或哈希表记录前 $n-k+1$ 个字符，确保后续字符都在第一个子串中出现过。
3. **无解判断**：如果后续字符中有未在第一个子串中出现的字符，则直接输出 `-1`。

### 所选高星题解

#### 1. 作者：wmrqwq (★★★★★)
- **关键亮点**：思路清晰，代码简洁，直接通过数组记录字符出现情况，逻辑严谨。
- **代码核心**：
  ```cpp
  for(int i=0;i<n-m+1;i++) 
      pd[s[i]]=1;
  for(int i=n-m+1;i<n;i++)
      if(!pd[s[i]]) {
          cout<<-1;
          return 0;
      }
  ```
- **个人心得**：通过让第一个子串尽可能长，后续子串尽可能短，简化了问题。

#### 2. 作者：Clarinet (★★★★☆)
- **关键亮点**：分析到位，代码易读，直接使用数组记录字符出现情况，逻辑清晰。
- **代码核心**：
  ```cpp
  for(int i=0;i<=n-k;i++)t[a[i]]=1;
  for(int i=n-k+1;i<n;i++){
      if(!t[a[i]]){
          cout<<-1;
          return 0;
      }
  }
  ```
- **个人心得**：通过极端情况分析，简化了问题，使得代码实现更加直接。

#### 3. 作者：lrqlrq250 (★★★★☆)
- **关键亮点**：使用 `unordered_map` 记录字符首次出现位置，逻辑清晰，代码简洁。
- **代码核心**：
  ```cpp
  for (int i=1; i<=n; i++){
      if (!pos[s[i]]) pos[s[i]] = i;
  }
  int maxn = -1;
  for (auto it=pos.begin(); it != pos.end(); it++) maxn = max(maxn, (*it).second);
  ```
- **个人心得**：通过记录字符首次出现位置，进一步优化了判断逻辑。

### 最优关键思路与技巧

1. **贪心策略**：通过让第一个子串尽可能长，后续子串尽可能短，简化了问题。
2. **字符记录**：使用数组或哈希表记录字符出现情况，确保后续字符都在第一个子串中出现过。
3. **无解判断**：通过遍历后续字符，判断是否有未在第一个子串中出现的字符，直接输出 `-1`。

### 可拓展之处

- **类似问题**：类似的问题可以考察字符串的拆分与子串匹配，如判断字符串是否可以被拆分为多个回文子串等。
- **算法套路**：贪心策略在字符串拆分问题中非常常见，可以举一反三应用于其他类似问题。

### 推荐题目

1. [P1040 最长回文子串](https://www.luogu.com.cn/problem/P1040)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)

### 个人心得总结

- **调试经历**：通过极端情况分析，简化了问题，使得代码实现更加直接。
- **踩坑教训**：确保后续字符都在第一个子串中出现过，否则直接输出 `-1`。
- **顿悟感想**：贪心策略在字符串拆分问题中非常有效，可以大大简化问题。

---
处理用时：26.29秒
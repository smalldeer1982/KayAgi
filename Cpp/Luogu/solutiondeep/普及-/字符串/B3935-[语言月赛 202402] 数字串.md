# 题目信息

# [语言月赛 202402] 数字串

## 题目描述

bj12z_jiasiyuan 有 $n + 1$ 个长度为无穷大的序列，其中这些序列有如下的规律：

- 第 $1$ 个序列为 $\texttt{11111111111111\dots}$，即开头为 $1$，相邻的 $1$ 间隔的距离为 $0$。
- 第 $2$ 个序列为 $\texttt{10101010101010\dots}$，即开头为 $1$，相邻的 $1$ 间隔的距离为 $1$。
- 第 $3$ 个序列为 $\texttt{10010010010010\dots}$，即开头为 $1$，相邻的 $1$ 间隔的距离为 $2$。
- $\cdots$
- 第 $n + 1$ 个序列开头为 $1$，相邻的 $1$ 间隔的距离为 $n$。

同时，bj12z_jiasiyuan 给予你一个长度为 $m$ 的 $01$ 数字串 $s$，请你判断这个数字串是否可能是从以上 $n + 1$ 个序列中的某一个序列中截取出来的。

bj12z_jiasiyuan 会询问你很多次，每一次都会给予你一组新的 $n, m, s$。请你帮助回答这些询问。

## 说明/提示

### 数据规模与约定

- 对于 $30\%$ 的数据，$t = 1$，$1 \leq n \leq 10$，$1 \leq m \leq 10$；  
- 对于 $50\%$ 的数据，$1 \leq t \leq 20$，$1 \leq n \leq 10^3$，$1 \leq m \leq 10^3$； 
- 对于 $100\%$ 的数据，$1 \leq t \leq 20$，$1 \leq n  \leq 10^5$，$1 \leq m \leq 10^5$。

## 样例 #1

### 输入

```
1
5 5 10010
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
1
5 12 000001000010
```

### 输出

```
No
```

# AI分析结果

### 综合分析与结论

本题的核心是判断给定的01串是否可以从某个特定的无限序列中截取出来。这些序列的特点是1之间的间隔距离固定，且间隔距离不超过n。题解的关键在于如何高效地判断给定串的1之间的间隔是否一致，并且这些间隔不超过n。

### 所选题解

#### 题解1：icypenguin (5星)
**关键亮点**：
- 思路清晰，通过记录1的位置来判断间隔是否一致。
- 代码结构简洁，逻辑明确，易于理解。
- 对不同情况（无1、单1、多1）进行了详细的分支处理，确保所有边界情况都被覆盖。

**核心实现思想**：
- 使用数组`w`记录所有1的位置。
- 根据1的数量进行不同的判断：
  - 无1时，判断串的长度是否超过n。
  - 单1时，判断前缀和后缀的0的数量是否超过n。
  - 多1时，判断所有相邻1之间的间隔是否一致且不超过n。

**核心代码片段**：
```cpp
cin >> t;
while (t--){
    long long n, m;
    cin >> n >> m;
    ll cnt = 0;
    for (long long i = 1; i <= m; i++){
        char c;
        cin >> c;
        a[i] = c - '0';
        if (a[i] == 1){
            w[++cnt] = i;
        }
    }
    if (cnt == 0){
        if (m > n){
            cout << "No" << endl;
        }else{
            cout << "Yes" << endl;
        }
        continue;
    }
    if (cnt == 1){
        if (w[1] - 1 > n || (m - w[1] > n)){
            cout << "No" << endl;
        }else{
            cout << "Yes" << endl;
        }
        continue;
    }
    ll len = w[2] - w[1] - 1;
    if (len > n){
        cout << "No" << endl;
        continue;
    }
    if (w[1] - 1 > len){
        cout << "No" << endl;
        continue;
    }
    bool flg = true;
    for (long long i = 3; i <= cnt; i++){
        if (w[i] - w[i - 1] - 1 != len){
            cout << "No" << endl;
            flg = false;
            break;
        }
    }
    if (!flg){
        continue;
    }
    if (m - w[cnt] > len){
        cout << "No" << endl;
        continue;
    }
    if (flg){
        cout << "Yes" << endl;
    }
}
```

### 最优关键思路或技巧
- **记录1的位置**：通过记录1的位置，可以方便地计算相邻1之间的间隔，从而判断是否符合要求。
- **分支处理**：根据1的数量进行不同的处理，确保所有边界情况都被覆盖。
- **提前终止**：在发现不符合条件时立即输出结果并终止后续判断，提高效率。

### 可拓展之处
- 类似的问题可以扩展到其他模式匹配，如判断一个串是否可以从某个特定的周期性序列中截取出来。
- 可以进一步优化，使用更高效的数据结构（如哈希表）来记录1的位置，减少时间复杂度。

### 推荐题目
1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P1042 字符串的展开](https://www.luogu.com.cn/problem/P1042)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得
- **调试经历**：在处理多1的情况时，最初忽略了前缀和后缀的0的数量限制，导致部分测试用例未通过。通过仔细检查逻辑，最终解决了问题。
- **顿悟感想**：在处理字符串问题时，记录关键字符的位置往往能简化问题，提高代码的可读性和效率。

---
处理用时：31.17秒
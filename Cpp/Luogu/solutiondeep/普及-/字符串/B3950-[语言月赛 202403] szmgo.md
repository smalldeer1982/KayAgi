# 题目信息

# [语言月赛 202403] szmgo

## 题目背景

本题请参考文字题解。

shinzanmono 想要学习 szm 语，但是 szm 语太难了。

## 题目描述

现代 szm 语采用罗马字表示，其划分音节的规则如下：

- 规定元音是字符 `a`、`e`、`i`、`o`、`u` 之一。
- 一般地，一个音节仅包含一个元音，并且以元音结尾。
- 特别地，当且仅当 `n` 后第一个字符不是元音时，`n` 单独作一个音节。
- 一个音节至多包含 $3$ 个字符。

举个例子，`shinzanmono` 的音节依次为 `shi` `n` `za` `n` `mo` `no`；`naku` 的音节依次为 `na` `ku`。

如果一个字符串是空串或者不能按照以上规则划分，则这个字符串不合法。**题目描述中给出的字符串和测试数据中输入的字符串全部合法，你无需进行合法性检验。**

将字符串 $S$ 的 $k$ 个音节依次表示为 $S'_1 \sim S'_k$，将另一个字符串 $T$ 的 $m$ 个音节依次表示为 $T'_1 \sim T'_m$。

如果存在一个正整数 $p$，满足 $p+m-1 \leq k$ 且对于从 $p$ 到 $p+m-1$ 的每个正整数 $i$ 都有 $S'_i=T'_{i - p + 1}$，那么称 $S$「包含」$T$。

在 szm 语中有一些习语，一种习语对应有一些固定的字符串。如果一个字符串「包含」且仅「包含」一种习语的一个固定子串，那么这个字符串是这种习语，否则这个字符串不是这种习语。

例如，当一种习语对应的子串只有 `ao` 时，字符串 `nao` 不是这种习语，因为 `nao` 的音节依次为 `na` `o`，而 `ao` 的音节依次为 `a` `o`。另一个例子是，如果敬语对应的子串为 `desu` 和 `suma`，那么 `kyuusaidesu` 是敬语，而 `kyuusaidesuma` 和 `kyuusaidema` 不是敬语。

某种习语对应 $n$ 个长度不超过 $10$ 的不同子串，给定 $q$ 个字符串，判断每个字符串是否是这种习语。

## 说明/提示

### 数据规模与约定

对于 $30\%$ 的数据，保证习语对应的所有字符串都没有由单个元音组成的音节。  
对于另外 $30\%$ 的数据，保证习语对应的所有字符串均只包含一个音节。  
对于 $100\%$ 的数据，$1 \leq n \leq 10$，$1 \leq q \leq 10^5$，习语对应的每个子串的长度不超过 $10$ 且两两不同，询问的 $q$ 个字符串的字符个数之和不超过 $5 \times 10^5$，输入的所有字符串均只包含小写字符。

## 样例 #1

### 输入

```
2 4
desu
suma
kyuusaidesu
kyuusaidesuma
kyuusaidema
desudesu
```

### 输出

```
Yes, Commander
No, Commander
No, Commander
Yes, Commander
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地匹配字符串的音节，并根据匹配结果判断字符串是否为特定习语。难点在于音节的划分规则较为复杂，特别是涉及到单个元音和 `n` 的特殊处理。题解中，RyanLi 的解法通过逐字符判断和条件过滤，较好地解决了这些问题，代码结构清晰，逻辑严密，适合处理大规模数据。

### 所选高星题解

#### 题解：RyanLi (4星)

**关键亮点：**
1. **逐字符判断**：通过逐字符判断是否为元音，并结合前后字符的条件过滤，确保匹配的音节符合规则。
2. **条件过滤**：在处理匹配时，特别处理了单个元音和 `n` 的情况，避免了错误的匹配。
3. **代码简洁**：通过函数封装和条件判断，代码结构清晰，易于理解和维护。

**个人心得：**
- **调试经历**：在匹配过程中，发现单个元音和 `n` 的特殊情况容易导致错误匹配，通过增加条件判断解决了这一问题。
- **顿悟感想**：意识到在字符串匹配中，逐字符判断和条件过滤是解决复杂规则的有效方法。

**核心代码：**
```cpp
bool vowel(char c) {
    return c == 'a' || c == 'i' || c == 'u' || c == 'e' || c == 'o';
}

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> n >> q;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    while (q--) {
        cnt = 0;
        cin >> s;
        for (int i = 1; i <= n; ++i) {
            pos = s.find(a[i]);
            if (pos == s.npos) continue;
            while (pos != s.npos) {
                if ((vowel(s[pos]) && pos && !vowel(s[pos - 1])) || (!vowel(s[pos]) && pos && !vowel(s[pos - 1]) && s[pos - 1] != 'n')) {
                    pos = s.find(a[i], pos + 1);
                    continue;
                } if ((s[pos + a[i].size() - 1] == 'n' && (pos + a[i].size() >= s.size() || (pos + a[i].size() < s.size() && !vowel(s[pos + a[i].size()])))) || s[pos + a[i].size() - 1] != 'n') {
                    ++cnt;
                    break;
                } pos = s.find(a[i], pos + 1);
            }
        } cout << (cnt == 1 ? "Yes, Commander\n" : "No, Commander\n");
    } return 0;
}
```

### 最优关键思路或技巧

1. **逐字符判断与条件过滤**：在处理复杂字符串匹配时，逐字符判断并结合前后字符的条件过滤是解决特殊规则的有效方法。
2. **函数封装**：将常用判断逻辑封装成函数，提高代码的可读性和复用性。

### 可拓展之处

- **类似算法套路**：在处理其他语言或特定规则的字符串匹配时，可以采用类似的逐字符判断和条件过滤的方法。
- **数据结构优化**：对于更大规模的数据，可以考虑使用更高效的数据结构（如Trie树）来优化匹配过程。

### 推荐题目

1. **P3375 【模板】KMP字符串匹配**：考察字符串匹配的基础算法。
2. **P3808 【模板】AC自动机（简单版）**：考察多模式串匹配的高效算法。
3. **P3796 【模板】AC自动机（加强版）**：进一步考察AC自动机的应用和优化。

通过以上分析和推荐题目，可以帮助更好地理解和应用字符串匹配的相关算法和技巧。

---
处理用时：26.87秒
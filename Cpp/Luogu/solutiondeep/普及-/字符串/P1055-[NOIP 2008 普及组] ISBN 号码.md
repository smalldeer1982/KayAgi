# 题目信息

# [NOIP 2008 普及组] ISBN 号码

## 题目描述

每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 $9$ 位数字、$1$ 位识别码和 $3$ 位分隔符，其规定格式如 `x-xxx-xxxxx-x`，其中符号 `-` 就是分隔符（键盘上的减号），最后一位是识别码，例如 `0-670-82162-4`就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 $0$ 代表英语；第一个分隔符 `-` 之后的三位数字代表出版社，例如 $670$ 代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。

识别码的计算方法如下：

首位数字乘以 $1$ 加上次位数字乘以 $2$ ……以此类推，用所得的结果 $ \bmod 11$，所得的余数即为识别码，如果余数为 $10$，则识别码为大写字母 $X$。例如 ISBN 号码 `0-670-82162-4` 中的识别码 $4$ 是这样得到的：对 `067082162` 这 $9$ 个数字，从左至右，分别乘以 $1,2,\dots,9$ 再求和，即 $0\times 1+6\times 2+……+2\times 9=158$，然后取 $158 \bmod 11$ 的结果 $4$ 作为识别码。

你的任务是编写程序判断输入的 ISBN 号码中识别码是否正确，如果正确，则仅输出 `Right`；如果错误，则输出你认为是正确的 ISBN 号码。


## 说明/提示

2008 普及组第一题


## 样例 #1

### 输入

```
0-670-82162-4```

### 输出

```
Right```

## 样例 #2

### 输入

```
0-670-82162-0```

### 输出

```
0-670-82162-4```

# AI分析结果

### 综合分析与结论

本题的核心是通过模拟计算ISBN号码的识别码，并判断其是否正确。大部分题解都采用了类似的思路：遍历字符串，计算加权和，取模11得到识别码，最后与输入的识别码进行比较。不同题解的主要区别在于代码的实现细节、优化程度和可读性。

#### 关键思路与技巧：
1. **字符串处理**：通过遍历字符串，跳过分隔符`-`，提取数字并计算加权和。
2. **取模运算**：计算加权和后，取模11得到识别码，注意余数为10时识别码为`X`。
3. **输出处理**：根据识别码的正确性，输出`Right`或修正后的ISBN号码。

#### 可拓展之处：
- **类似题目**：处理带有分隔符的字符串，提取关键信息并进行计算，类似于处理身份证号码、银行卡号等。
- **优化技巧**：可以通过预计算权重或使用更高效的字符串处理方法来优化代码。

#### 推荐题目：
1. [P1055 [NOIP2008 普及组] ISBN 号码](https://www.luogu.com.cn/problem/P1055)
2. [P1056 [NOIP2008 普及组] 排座椅](https://www.luogu.com.cn/problem/P1056)
3. [P1057 [NOIP2008 普及组] 传球游戏](https://www.luogu.com.cn/problem/P1057)

### 所选高星题解

#### 题解1：作者：FastIO_DP (5星)
**关键亮点**：
- 代码简洁明了，逻辑清晰。
- 使用`scanf`直接读取字符串，避免了复杂的字符串处理。
- 通过`check`变量直接计算识别码，代码可读性强。

**核心代码**：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int main() {
    char s[14]; // ISBN 号码最多 13 字符 + 1 结束符
    scanf("%s", s);

    int sum = 0, cnt = 1; // sum 为加权和，cnt 为当前权重
    for (int i = 0; i < 11; i++) {
        if (s[i] == '-') continue; // 跳过分隔符
        sum += (s[i] - '0') * cnt++; // 加权累加
    }

    char check = (sum % 11 == 10) ? 'X' : (sum % 11 + '0'); // 计算识别码
    if (check == s[12]) {
        puts("Right"); // 识别码正确
    } else {
        s[12] = check; // 修正识别码
        puts(s); // 输出正确的 ISBN 号码
    }

    return 0;
}
```

#### 题解2：作者：ikunTLE (4星)
**关键亮点**：
- 使用`string`类型处理字符串，代码简洁。
- 通过`at`函数提取字符，避免了数组越界的风险。
- 代码逻辑清晰，易于理解。

**核心代码**：
```cpp
#include<cstring>
#include<iostream>
using namespace std;
string s;
int main(){
	cin>>s;//string类型只能够用cin读入
	int tell=s.at(0)-48+(s.at(2)-48)*2+(s.at(3)-48)*3+(s.at(4)-48)*4+(s.at(6)-48)*5+(s.at(7)-48)*6+(s.at(8)-48)*7+(s.at(9)-48)*8+(s.at(10)-48)*9;//得到应该得到的值：因为at返回的是一个字符，所以说要减去'0'（48），根据题意，得到这个算式
	char right=tell%11+48;//正确的最后一位的值
	if(right>'9')	right='X';//因为module 11 之后可能会有10，根据题意得到'X'
	if(right==s.at(12))	cout<<"Right";//如果相等，那就是正确的
	else//否则
	{
		for(int i=0;i<=11;++i)	cout<<s.at(i);//从0~10输出前面的字符
		cout<<right;//然后输出正确的最后一位
	}
	return 0;
}
```

#### 题解3：作者：qhr2023 (4星)
**关键亮点**：
- 代码简洁，逻辑清晰。
- 通过`sum`变量直接计算加权和，代码可读性强。
- 使用`puts`输出结果，避免了复杂的输出处理。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int l, n, sum; 
string s;
int main(){
	cin >> s;
	l=s.size();
	for (int i=0; i<l-1; ++i)
		if (s[i]>='0'&&s[i]<='9')
			sum+=(s[i]-'0')*(++n);
	if (sum%11+'0'==s[l-1]||(sum%11==10&&s[l-1]=='X'))
		puts("Right");
	else
		s[l-1]=(sum%11==10?'X':sum%11+'0'),
		cout << s;
	return 0;
}
```

### 通用建议与扩展思路
如果所有题解均未达到4星，建议从以下几个方面进行优化：
1. **代码可读性**：使用清晰的变量名和注释，避免复杂的逻辑嵌套。
2. **优化技巧**：通过预计算权重或使用更高效的字符串处理方法来优化代码。
3. **错误处理**：增加对输入格式的检查，避免因输入错误导致的程序崩溃。

通过以上优化，可以提升代码的质量和可读性，使其更易于理解和维护。

---
处理用时：41.45秒
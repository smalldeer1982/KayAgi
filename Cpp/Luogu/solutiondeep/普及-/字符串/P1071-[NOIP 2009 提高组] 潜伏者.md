# 题目信息

# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# AI分析结果

### 综合分析与结论

本题的核心是通过给定的原信息和加密信息，构建一个密码映射表，并利用该表翻译新的加密信息。难点在于如何处理映射冲突（如一个密文对应多个原文或一个原文对应多个密文）以及确保所有字母都被映射。各题解的主要思路相似，均使用 `map` 或数组来记录映射关系，并通过遍历检查冲突和完整性。不同题解在实现细节和代码风格上有所差异，部分题解通过双向映射或额外的 `set` 来确保映射的唯一性。

### 所选高星题解

#### 1. 作者：CYJian (5星)
- **关键亮点**：代码简洁明了，使用双向 `map` 确保映射的唯一性，逻辑清晰，直接通过遍历检查冲突和完整性。
- **核心代码**：
  ```cpp
  map<char,char>mp,mq;
  for(int i=0;i<la;i++)
      if(mp[a[i]]==0&&mq[b[i]]==0)
          mp[a[i]]=b[i] , mq[b[i]]=a[i] , book--;
      else if(mp[a[i]]!=b[i]||mq[b[i]]!=a[i])
          ERROR;
  if(book>0) ERROR;
  for(int i=0;i<lc;i++) printf("%c",mp[c[i]]);
  ```
- **实现思想**：通过 `mp` 和 `mq` 分别记录密文到原文和原文到密文的映射，确保双向唯一性。遍历时检查冲突，最后输出翻译结果。

#### 2. 作者：陈嘉逸2012 (4星)
- **关键亮点**：使用 `map` 和 `vis` 数组记录映射和已使用的字母，逻辑清晰，代码简洁。
- **核心代码**：
  ```cpp
  map<char,char>mp; map<char,bool>vis;
  for(int i=0;i<a.size();i++){
      if(vis[b[i]]&&b[i]!=mp[a[i]]){cout<<"Failed\n";return 0;}
      mp[a[i]]=b[i],vis[b[i]]=1;
  }
  for(char i='A';i<='Z';i++){
      if(!vis[i]){cout<<"Failed\n";return 0;}
  }
  for(int i=0;i<c.size();i++) cout<<mp[c[i]];
  ```
- **实现思想**：通过 `mp` 记录密文到原文的映射，`vis` 记录已使用的字母，遍历时检查冲突，最后输出翻译结果。

#### 3. 作者：lianghuahua (4星)
- **关键亮点**：使用 `map` 和 `set` 确保映射的唯一性，逻辑清晰，代码简洁。
- **核心代码**：
  ```cpp
  map<char, char>mp; set<char>st;
  for(int i = 0; i < s1.size(); i++){
      if(mp.count(s1[i])) {
          if(mp[s1[i]] != s2[i]) {cout<<"Failed";return 0;}
      }else{
          if(st.count(s2[i])) {cout<<"Failed";return 0;}
          mp[s1[i]] = s2[i]; st.insert(s2[i]);
      }
  }
  if(mp.size() < 26){cout<<"Failed";return 0;}
  for(int i = 0; i < s3.size(); i++){cout << mp[s3[i]];}
  ```
- **实现思想**：通过 `mp` 记录密文到原文的映射，`st` 记录已使用的字母，遍历时检查冲突，最后输出翻译结果。

### 最优关键思路与技巧

1. **双向映射**：使用两个 `map` 或 `map` 和 `set` 确保映射的唯一性，避免一个密文对应多个原文或一个原文对应多个密文。
2. **完整性检查**：通过遍历 `A` 到 `Z` 检查所有字母是否被映射，确保密码表的完整性。
3. **冲突检测**：在遍历时实时检查映射是否冲突，及时输出 `Failed`。

### 可拓展之处

- **类似题目**：可以扩展到更复杂的密码映射问题，如多对多映射或动态映射。
- **算法套路**：类似的双向映射和冲突检测可以应用于其他需要唯一映射的场景，如字符替换、编码解码等。

### 推荐相似题目

1. [P1072 Hankson的趣味题](https://www.luogu.com.cn/problem/P1072)
2. [P1073 最优贸易](https://www.luogu.com.cn/problem/P1073)
3. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)

### 个人心得摘录

- **调试经历**：部分题解提到在调试时遇到映射冲突或完整性检查不通过的情况，通过增加双向映射或 `set` 解决了问题。
- **踩坑教训**：有题解提到最初误解题意，以为只需要翻译部分字母，后来发现需要确保所有字母都被映射，及时调整了代码逻辑。

通过这些题解，可以学习到如何高效处理映射问题，并确保映射的唯一性和完整性。

---
处理用时：38.46秒
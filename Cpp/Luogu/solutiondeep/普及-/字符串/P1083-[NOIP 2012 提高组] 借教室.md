# 题目信息

# [NOIP 2012 提高组] 借教室

## 题目描述

在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。

面对海量租借教室的信息，我们自然希望编程解决这个问题。

我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。

我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。

借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。

现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。


## 说明/提示

【输入输出样例说明】

第 $1 $份订单满足后，$4 $天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2 $天到第 $4$ 天每天提供 $3$ 个教室，而第 $3$ 天剩余的教室数为$ 2$，因此无法满足。分配停止，通知第 $2$ 个申请人修改订单。

【数据范围】

对于 $10\%$ 的数据，有 $1\le n,m\le 10$；

对于 $30\%$ 的数据，有 $1\le n,m\le 1000$；

对于 $70\%$ 的数据，有 $1 \le n,m \le 10^5$；

对于 $100\%$ 的数据，有 $1 \le n,m \le 10^6$，$0 \le r_i,d_j\le 10^9$，$1 \le s_j\le t_j\le n$。


NOIP 2012 提高组 第二天 第二题

2022.2.20 新增一组 hack 数据

## 样例 #1

### 输入

```
4 3 
2 5 4 3 
2 1 3 
3 2 4 
4 2 4```

### 输出

```
-1 
2```

# AI分析结果

### 综合分析与结论

本题的核心在于处理区间修改和查询操作，要求高效地判断是否存在某一天的教室数量不足。题解中主要采用了以下几种思路：

1. **暴力优化**：通过差分数组优化区间修改，但复杂度仍较高，适合小规模数据。
2. **二分+差分**：利用二分查找订单数量，结合差分数组进行区间修改和查询，复杂度为 \(O((n+m)\log m)\)，适合大规模数据。
3. **线段树**：通过线段树维护区间最小值，复杂度为 \(O(m \log n)\)，但常数较大，适合对复杂度要求不高的场景。

最优解为**二分+差分**，因其复杂度较低且实现简单。线段树虽然也能通过，但常数较大，不适合大规模数据。

### 所选高星题解

#### 1. 皎月半洒花 (5星)
**关键亮点**：
- 详细介绍了差分数组和前缀和的思想，解释了为何选择差分而非线段树。
- 提供了清晰的二分查找思路，结合差分数组进行区间修改和查询。
- 代码简洁，注释详细，易于理解。

**个人心得**：
- 作者提到“思想只能是辅助工具”，强调了实现的重要性。
- 通过比大小而非作差来判断是否满足条件，避免了负数带来的问题。

**核心代码**：
```cpp
bool isok(int x) {
    memset(diff, 0, sizeof(diff));
    for(int i=1; i<=x; i++) {
        diff[l[i]] += d[i];
        diff[r[i]+1] -= d[i]; 
    }
    for(int i=1; i<=n; i++) {
        need[i] = need[i-1] + diff[i];
        if(need[i] > rest[i]) return 0;
    }
    return 1;
}
```

#### 2. _Bluehole (5星)
**关键亮点**：
- 详细解释了二分+差分的思路，强调了答案的单调性。
- 提供了清晰的差分数组实现，代码简洁高效。
- 通过二分查找订单数量，结合差分数组进行区间修改和查询。

**核心代码**：
```cpp
bool check(int num) {
    memset(dif, 0, sizeof(dif));
    for(int i=1; i<=num; i++) {
        dif[s[i]] += d[i];
        dif[t[i]+1] -= d[i];
    }
    int now = 0;
    for(int i=1; i<=n; i++) {
        now += dif[i];
        if(now > r[i]) return false;
    }
    return true;
}
```

#### 3. WsW_ (4星)
**关键亮点**：
- 提供了二分+差分的思路，代码简洁，注释清晰。
- 通过二分查找订单数量，结合差分数组进行区间修改和查询。

**核心代码**：
```cpp
bool check(int x) {
    memset(c, 0, sizeof(c));
    for(int i=1; i<=x; i++) {
        c[a[i].first] += d[i];
        c[a[i].second+1] -= d[i];
    }
    for(int i=1; i<=n; i++) {
        c[i] += c[i-1];
        if(c[i] > r[i]) return 0;
    }
    return 1;
}
```

### 最优关键思路与技巧

1. **二分查找**：利用订单数量的单调性，通过二分查找确定第一个无法满足的订单。
2. **差分数组**：通过差分数组高效处理区间修改，避免直接修改数组的高复杂度。
3. **前缀和**：通过前缀和快速计算区间修改后的结果，判断是否满足条件。

### 可拓展之处

- **类似问题**：区间修改和查询问题，如区间加、区间求和等。
- **算法套路**：二分查找结合差分数组，适用于需要高效处理区间修改的场景。

### 推荐题目

1. **P3372 【模板】线段树 1**：考察线段树的基本操作，适合练习区间修改和查询。
2. **P3368 【模板】树状数组 2**：考察树状数组的区间修改和单点查询，适合练习差分思想。
3. **P1908 逆序对**：考察归并排序和树状数组，适合练习区间查询和修改。

### 个人心得总结

- **调试经历**：多位作者提到通过比大小而非作差来判断是否满足条件，避免了负数带来的问题。
- **踩坑教训**：线段树虽然能通过，但常数较大，不适合大规模数据。
- **顿悟感想**：差分数组和二分查找的结合是解决此类问题的有效方法，强调了思想与实现的重要性。

---
处理用时：37.05秒
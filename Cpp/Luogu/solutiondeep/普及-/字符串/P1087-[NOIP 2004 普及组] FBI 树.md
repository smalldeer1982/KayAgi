# 题目信息

# [NOIP 2004 普及组] FBI 树

## 题目描述

我们可以把由 0 和 1 组成的字符串分为三类：全 0 串称为 B 串，全 1 串称为 I 串，既含 0 又含 1 的串则称为 F 串。

FBI 树是一种二叉树，它的结点类型也包括 F 结点，B 结点和 I 结点三种。由一个长度为 $2^N$ 的 01 串 $S$ 可以构造出一棵 FBI 树 $T$，递归的构造方法如下：

1. $T$ 的根结点为 $R$，其类型与串 $S$ 的类型相同；
2. 若串 $S$ 的长度大于 $1$，将串 $S$ 从中间分开，分为等长的左右子串 $S_1$ 和 $S_2$；由左子串 $S_1$ 构造 $R$ 的左子树 $T_1$，由右子串 $S_2$ 构造 $R$ 的右子树 $T_2$。

现在给定一个长度为 $2^N$ 的 01 串，请用上述构造方法构造出一棵 FBI 树，并输出它的后序遍历序列。


## 说明/提示

对于 $40\%$ 的数据，$N \le 2$；

对于全部的数据，$N \le 10$。


noip2004普及组第3题


## 样例 #1

### 输入

```
3
10001011
```

### 输出

```
IBFBBBFIBFIIIFF
```

# AI分析结果

### 综合分析与结论

本题的核心是通过递归或模拟的方式构建FBI树，并进行后序遍历输出。大多数题解采用了递归或模拟二叉树的方法，部分题解通过优化避免了显式建树，直接通过字符串处理完成遍历。整体来看，递归思路清晰且代码简洁，模拟二叉树的方法则更贴近数据结构的基本操作。

### 所选高星题解

#### 1. **作者：ingu (赞：262)**
- **星级：★★★★★**
- **关键亮点：**
  - 通过递归直接构建树并输出后序遍历，代码简洁且逻辑清晰。
  - 利用递归的特性，边建树边输出，避免了显式存储树结构。
  - 通过简单的判断逻辑确定节点的类型（F、B、I），代码可读性强。
- **核心代码：**
  ```cpp
  void maketree(int x,int y){
      if(y>x){
          maketree(x,(x+y)/2);
          maketree((x+y+1)/2,y);
      }    
      int B=1,I=1;
      for(int i=0;i<=y-x;i++){
          if(s[x+i]=='1') B=0;
          else if(s[x+i]=='0') I=0;
      }
      if(B) cout<<'B';
      else if(I) cout<<'I';
      else cout<<'F';
  }
  ```
- **个人心得：**
  - 通过递归直接输出后序遍历，避免了显式存储树结构，减少了内存开销。

#### 2. **作者：wuhao1027 (赞：148)**
- **星级：★★★★☆**
- **关键亮点：**
  - 采用递归思路，通过二分法分割字符串，判断节点类型并输出。
  - 代码简洁，逻辑清晰，适合初学者理解递归的应用。
- **核心代码：**
  ```cpp
  void work(int low, int up){
      int mid = (low+up)/2;
      if (low!=up){
          work(low, mid);
          work(mid+1,up);
      }
      int i,a=0,b=0;
      for (i=low;i<=up;i++)
          if (A[i]=='0') a++;
          else b++;
      if (a&&b) printf("F");
      else if (a) printf("B");
      else printf("I");
  }
  ```
- **个人心得：**
  - 通过二分法分割字符串，递归处理左右子树，逻辑清晰且易于理解。

#### 3. **作者：传说饭 (赞：122)**
- **星级：★★★★☆**
- **关键亮点：**
  - 通过递归直接输出后序遍历，代码简洁且逻辑清晰。
  - 利用字符串的`substr`方法分割字符串，简化了代码实现。
- **核心代码：**
  ```cpp
  char FBI(string s) {
      if (s.length() > 1) {
          cout << FBI(s.substr(0, s.length()/2));
          cout << FBI(s.substr(s.length()/2, s.length()/2));
      }
      if (s == string(s.length(), '0')) return 'B';
      if (s == string(s.length(), '1')) return 'I';
      return 'F';
  }
  ```
- **个人心得：**
  - 通过递归直接输出后序遍历，避免了显式存储树结构，减少了内存开销。

### 最优关键思路或技巧

1. **递归构建树**：通过递归分割字符串，直接构建树结构并进行后序遍历，避免了显式存储树结构，减少了内存开销。
2. **字符串分割**：利用字符串的`substr`方法或二分法分割字符串，简化了代码实现。
3. **判断节点类型**：通过简单的判断逻辑确定节点的类型（F、B、I），代码可读性强。

### 拓展思路与同类型题

1. **同类型题**：
   - **P1030 二叉树的遍历**：考察二叉树的前序、中序、后序遍历。
   - **P1040 二叉树的深度**：考察二叉树的深度计算。
   - **P1041 二叉树的层次遍历**：考察二叉树的层次遍历。

2. **调试与踩坑**：
   - 在递归过程中，注意边界条件的处理，避免无限递归。
   - 在判断节点类型时，确保逻辑的完备性，避免遗漏情况。

### 推荐题目
1. **P1030 二叉树的遍历**：考察二叉树的前序、中序、后序遍历。
2. **P1040 二叉树的深度**：考察二叉树的深度计算。
3. **P1041 二叉树的层次遍历**：考察二叉树的层次遍历。

---
处理用时：41.83秒
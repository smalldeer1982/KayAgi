# 题目信息

# 单词方阵

## 题目描述

给一 $n \times n$ 的字母方阵，内可能蕴含多个 `yizhong` 单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 $8$ 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉，因此有可能共用字母。输出时，将不是单词的字母用 `*` 代替，以突出显示单词。

## 样例 #1

### 输入

```
7
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
```

### 输出

```
*******
*******
*******
*******
*******
*******
*******
```

## 样例 #2

### 输入

```
8
qyizhong
gydthkjy
nwidghji
orbzsfgz
hhgrhwth
zzzzzozo
iwdfrgng
yyyygggg```

### 输出

```
*yizhong
gy******
n*i*****
o**z****
h***h***
z****o**
i*****n*
y******g```

# AI分析结果

### 综合分析

该题目要求在一个字母方阵中查找特定单词“yizhong”，并标记出这些单词的位置。题解中主要采用了以下几种思路：

1. **深度优先搜索（DFS）**：大多数题解使用DFS来遍历矩阵，找到符合条件的单词。DFS的优势在于可以系统地探索所有可能的路径，但需要处理方向不变的条件。
2. **暴力枚举**：部分题解通过暴力枚举所有可能的单词位置，虽然简单但效率较低，适合小规模数据。
3. **方向数组与标记数组**：通过预定义方向数组和标记数组，简化了搜索和标记过程，提高了代码的可读性和效率。
4. **优化剪枝**：部分题解在搜索过程中加入了剪枝条件，减少了不必要的搜索，提高了效率。

### 评分较高的题解

#### 1. 作者：灯芯糕 (赞：1635)
- **星级**：★★★★★
- **关键亮点**：使用DFS结合方向数组和标记数组，代码结构清晰，逻辑严谨。通过预处理和染色法，高效地标记出符合条件的单词。
- **个人心得**：通过预处理记录“y”的位置，减少了搜索的复杂度，提升了整体效率。
- **核心代码**：
```cpp
bool f(int i,int j,int m,int n,int next){
    if(next>=8){
        s[i][j]=1;
        return 1;
    }
    if(a[i+m][j+n]==k[next])
        if(f(i+m,j+n,m,n,next+1)){
            s[i][j]=1;
            return 1;
        }
    return 0;
}
```
**核心思想**：递归搜索，通过方向数组和标记数组实现单词的查找和标记。

#### 2. 作者：hzg0226 (赞：389)
- **星级**：★★★★☆
- **关键亮点**：使用DFS结合方向数组，通过结构体记录路径，代码简洁且高效。
- **核心代码**：
```cpp
void dfs(int x,int y,node c[],int k,int cur){
    if(cur==7){
        for(int i=0;i<7;i++)
            vis[c[i].x][c[i].y]=1;
    }
    else{
        int dx=x+dir[k][0];
        int dy=y+dir[k][1];
        if(cur==6||fz[dx][dy]==stand[cur+1]){
            c[cur].x=x;c[cur].y=y;
            dfs(dx,dy,c,k,cur+1);
        }
    }
}
```
**核心思想**：通过结构体记录路径，递归搜索并标记符合条件的单词。

#### 3. 作者：Way_How_Fri3nd (赞：217)
- **星级**：★★★★
- **关键亮点**：使用DFS结合方向数组，通过布尔返回值判断是否找到单词，代码简洁且逻辑清晰。
- **核心代码**：
```cpp
bool DFS(int x,int y,char w,int p){
    if(w=='g'){
        ma[x][y]=1;
        return 1;
    }
    int xx=x+u[p],yy=y+v[p];
    if(xx>=1 && yy>=1 && xx<=n && yy<=n && chess[xx][yy]==le[w])
        if(DFS(xx,yy,le[w],p)){
            ma[x][y]=1;
            return 1;
        }
    return 0;
}
```
**核心思想**：通过布尔返回值判断是否找到单词，递归搜索并标记。

### 最优关键思路与技巧

1. **方向数组**：预定义八个方向的方向数组，简化了搜索过程中的方向处理。
2. **标记数组**：通过标记数组记录已找到的单词位置，避免重复搜索。
3. **剪枝优化**：在搜索过程中加入剪枝条件，减少不必要的搜索，提高效率。

### 可拓展之处

1. **类似题目**：可以扩展到其他单词搜索问题，如查找多个单词或不同方向的单词。
2. **算法优化**：可以结合A*算法或其他启发式搜索算法，进一步提高搜索效率。

### 推荐题目

1. **P1102**：单词接龙
2. **P1103**：单词方阵II
3. **P1104**：单词方阵III

这些题目考察了类似的搜索和标记技巧，适合进一步练习和巩固。

---
处理用时：53.75秒
# 题目信息

# 波浪数

## 题目描述

波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。

类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $2\le l\le r\le 32$，$1\le L\le R\le 10^7$，$k\in \{2, 3, 4\}$。

## 样例 #1

### 输入

```
10 11 190000 960000 2```

### 输出

```
191919
383838
575757
767676
959595```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在给定的范围内高效地找到双重、三重、四重波浪数。波浪数的定义是在不同进制下交替转换的数，且交替的数字必须不同。大多数题解采用了“构造法”，即通过枚举进制和交替的数字来生成波浪数，然后统计每个数在不同进制下的波浪数重数。这种方法避免了直接判断每个数是否为波浪数的复杂计算，显著提高了效率。

### 所选高星题解

#### 1. **作者：Crazily (赞：78)**
- **星级：5星**
- **关键亮点：**
  - 采用了逆向思维，通过构造波浪数并统计重数，避免了复杂的进制转换和判断。
  - 代码简洁且高效，直接遍历生成的波浪数数组，输出符合要求的数。
  - 通过 `v[x]++` 统计每个数的重数，最后只需遍历一次数组即可输出结果。
- **个人心得：**
  - 考场上因进制转换的复杂性而未能及时想到逆向思维，考后重新思考并实现了更高效的解法。
  
**核心代码：**
```cpp
for(int k=a;k<=b;++k){
    for(int i=1;i<k;++i){
        for(int j=0;j<k;++j){
            if(i!=j){
                x=0;
                t=0;
                while(x<=r){
                    if(t%2==0) x=x*k+i;
                    else x=x*k+j;
                    ++t;
                    if(x>=l&&x<=r) ++v[x];
                }
            }
        }
    }
}
```

#### 2. **作者：Y_B_Y (赞：4)**
- **星级：4星**
- **关键亮点：**
  - 详细解释了波浪数的构造过程，并通过 `yes[k]` 数组记录每个数的重数。
  - 使用了 `pow` 函数进行进制转换，代码清晰易懂。
  - 特别处理了去掉第一位的情况，确保所有可能的波浪数都被统计。
  
**核心代码：**
```cpp
for(int p=j1;p<=j2;p++){
    memset(b,0,sizeof(b));
    for(int i=0;i<=p-1;i++){
        for(int j=0;j<=p-1;j++){
            if(i==j) continue;
            int tot=0;
            for(int l=1;l<=10;l++){
                if(tot+j*pow(p,2*l-2)<=ed && l>1){
                    if(!b[tot+(int)(j*pow(p,2*l-2))]) yes[tot+int(j*pow(p,2*l-2))]++;
                    b[tot+(int)(j*pow(p,2*l-2))]=1;
                }
                if(tot+i*pow(p,2*l-1)+j*pow(p,2*l-2)<=ed){
                    tot+=i*pow(p,2*l-1)+j*pow(p,2*l-2);
                    if(!b[tot]) yes[tot]++;
                    b[tot]=1;
                }
                else break;
            }
        }
    }
}
```

#### 3. **作者：Qwdb (赞：1)**
- **星级：4星**
- **关键亮点：**
  - 详细解释了构造法的思路，并通过 `m[v1]++` 统计每个数的重数。
  - 代码结构清晰，注释详细，便于理解。
  - 特别强调了波浪数的定义和构造过程中的注意事项。
  
**核心代码：**
```cpp
for(int i=a;i<=b;i++){
    for(int j=0;j<i;j++){
        for(int k=1;k<i;k++){
            if(j!=k){
                int v1=0;
                int v2=0;
                while(v1<=d){
                    if(v2%2==0) v1=v1*i+j;
                    else v1=v1*i+k;
                    v2++;
                    if(v1>=c && v1<=d) m[v1]++;
                }
            }
        }
    }
}
```

### 最优关键思路与技巧

1. **构造法**：通过枚举进制和交替的数字来生成波浪数，避免了直接判断每个数是否为波浪数的复杂计算。
2. **重数统计**：使用数组记录每个数在不同进制下的波浪数重数，最后只需遍历一次数组即可输出结果。
3. **优化技巧**：通过 `while` 循环和 `if` 条件控制生成的波浪数在给定范围内，避免不必要的计算。

### 可拓展之处

1. **类似题目**：可以扩展到其他进制转换或数字交替的题目，如“回文数”、“特殊进制数”等。
2. **算法优化**：可以进一步优化进制转换的计算，使用位运算或其他数学技巧提高效率。

### 推荐题目

1. **P1217 [USACO1.5]回文质数**（考察回文数和质数的判断）
2. **P1143 进制转换**（考察不同进制之间的转换）
3. **P1062 数列**（考察数列的生成和判断）

### 个人心得总结

- **逆向思维**：在面对复杂问题时，逆向思维往往能带来更高效的解决方案。
- **调试经验**：在构造波浪数时，注意控制生成的数在给定范围内，避免数组越界或不必要的计算。
- **代码优化**：通过合理的数据结构和算法优化，可以显著提高程序的运行效率。

---
处理用时：40.85秒
# 题目信息

# [USACO1.1] 坏掉的项链 Broken Necklace

## 题目描述

你有一条由 $n$ 个红色的，白色的，或蓝色的珠子组成的项链，珠子是随意安排的。 这里是 $n=29$ 的两个例子:

![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png) 

第一和第二个珠子在图片中已经被作记号。

图片 A 中的项链可以用下面的字符串表示：

`brbrrrbbbrrrrrbrrbbrbbbbrrrrb`

假如你要在一些点打破项链，展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事(颜色可能与在这之前收集的不同)。 确定应该在哪里打破项链来收集到最大数目的珠子。

例如，在图片 A 中的项链中，在珠子 $9$ 和珠子 $10$ 或珠子 $24$ 和珠子 $25$ 之间打断项链可以收集到 $8$ 个珠子。

白色珠子什么意思?

在一些项链中还包括白色的珠子(如图片B) 所示。

当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。

表现含有白珠项链的字符串将会包括三个符号 `r`，`b`，`w` 。

写一个程序来确定从一条被给出的项链可以收集到的珠子最大数目。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$3\le n \le 350$

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
29 
wwwbbrwrbrbrrbrbrwrwwrbwrwrrb
```

### 输出

```
11```

# AI分析结果

### 综合分析与结论

该题目要求从一条环形项链中找到最佳的断开点，使得从断开点两侧收集同色珠子的数量最大。题解中主要涉及以下几种思路：

1. **暴力枚举**：通过枚举每个可能的断开点，分别向左右两侧搜索，统计最大珠子数。该方法虽然简单，但时间复杂度较高（O(n^2)），适用于数据规模较小的情况。
  
2. **动态规划（DP）**：通过预处理左右两侧的连续珠子数，利用状态转移方程快速计算最大珠子数。该方法优化了时间复杂度，但实现较为复杂。

3. **链表或双向队列**：通过链表或双向队列模拟环形结构，避免数组越界问题，适用于需要频繁插入和删除的场景。

4. **字符串复制与翻转**：通过将字符串复制多份或翻转，简化环形结构的处理，减少边界条件的判断。

### 精选题解

#### 1. 作者：w_y_c (赞：134)  
**星级：★★★★★**  
**关键亮点**：  
- 使用字符串复制三份，简化环形结构的处理。
- 通过分段处理，从中间段开始枚举，减少边界条件的判断。
- 代码简洁，注释清晰，易于理解。

**核心代码**：
```cpp
int f(int x) {
    int s = 0;
    char a1 = a[x], b2 = a[x+1];
    for(int i = x;; i--) { // 向左搜索
        if(a[i] == a1 || a[i] == 'w') s++;
        else break;
    }
    for(int i = x+1;; i++) { // 向右搜索
        if(a[i] == b2 || a[i] == 'w') s++;
        else break;
    }
    return s;
}
```
**实现思想**：通过分段处理，从中间段开始枚举，分别向左右两侧搜索，统计最大珠子数。

#### 2. 作者：青衫白叙 (赞：88)  
**星级：★★★★☆**  
**关键亮点**：  
- 使用双向队列模拟环形结构，避免数组越界问题。
- 通过预处理左右两侧的连续珠子数，优化时间复杂度。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i = 0; i < n<<1; i++) {
    if(s[i] == 'w') b++, w++;
    else if(s[i] == c) b++, w = 0;
    else ans = max(ans, a + b), a = b - w, b = w + 1, w = 0, c = s[i];
}
```
**实现思想**：通过预处理左右两侧的连续珠子数，利用状态转移方程快速计算最大珠子数。

#### 3. 作者：田阙西 (赞：49)  
**星级：★★★★☆**  
**关键亮点**：  
- 使用动态规划（DP）预处理左右两侧的连续珠子数。
- 通过状态转移方程快速计算最大珠子数。
- 代码结构清晰，优化程度较高。

**核心代码**：
```cpp
for(int i = 1; i <= n*2; ++i) {
    if(c[i] == 'w') lR[i] = lR[i-1] + 1, lB[i] = lB[i-1] + 1;
    else if(c[i] == 'r') lR[i] = lR[i-1] + 1;
    else if(c[i] == 'b') lB[i] = lB[i-1] + 1;
}
```
**实现思想**：通过动态规划预处理左右两侧的连续珠子数，利用状态转移方程快速计算最大珠子数。

### 最优关键思路与技巧

1. **字符串复制与翻转**：通过将字符串复制多份或翻转，简化环形结构的处理，减少边界条件的判断。
2. **动态规划（DP）**：通过预处理左右两侧的连续珠子数，利用状态转移方程快速计算最大珠子数。
3. **链表或双向队列**：通过链表或双向队列模拟环形结构，避免数组越界问题，适用于需要频繁插入和删除的场景。

### 可拓展之处

1. **环形结构处理**：类似问题如环形数组的最大子数组和、环形链表的处理等，可以采用类似的字符串复制或链表模拟的方法。
2. **动态规划优化**：在其他需要预处理和状态转移的问题中，可以借鉴该题解中的动态规划思路。

### 推荐题目

1. **P1886 滑动窗口**：考察滑动窗口的最大值，与环形结构处理类似。
2. **P1040 加分二叉树**：考察动态规划与树形结构的结合，与动态规划优化思路类似。
3. **P1090 合并果子**：考察优先队列与贪心算法，与链表模拟环形结构的思路类似。

### 个人心得摘录

- **w_y_c**：通过字符串复制三份，简化了环形结构的处理，减少了边界条件的判断，代码简洁易读。
- **青衫白叙**：使用双向队列模拟环形结构，避免了数组越界问题，代码逻辑清晰，优化程度较高。
- **田阙西**：通过动态规划预处理左右两侧的连续珠子数，利用状态转移方程快速计算最大珠子数，代码结构清晰，优化程度较高。

---
处理用时：42.06秒
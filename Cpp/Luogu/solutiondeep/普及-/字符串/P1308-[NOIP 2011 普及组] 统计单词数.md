# 题目信息

# [NOIP 2011 普及组] 统计单词数

## 题目描述

一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。

现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例 1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例 2）。


## 说明/提示

数据范围

$1\leq $ 第一行单词长度 $\leq10$。

$1\leq $ 文章长度 $\leq10^6$。

noip2011 普及组第 2 题


## 样例 #1

### 输入

```
To
to be or not to be is a question
```

### 输出

```
2 0

```

## 样例 #2

### 输入

```
to
Did the Ottoman Empire lose its power at that time```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在文章中准确匹配目标单词，并统计其出现次数和首次出现的位置。难点在于处理大小写不敏感、单词的完全匹配（不能是其他单词的一部分）以及处理输入中的空格和换行符。大多数题解都采用了类似的思路：统一大小写、处理输入、遍历文章进行匹配。部分题解通过添加空格来简化匹配逻辑，避免单词部分匹配的问题。

### 所选高分题解

#### 1. 作者：suxy15 (赞：135)
- **星级**：★★★★★
- **关键亮点**：
  - 使用`getchar()`逐个处理输入，避免`gets()`的潜在问题。
  - 通过维护两个扫描指针（文章和单词）进行匹配，逻辑清晰。
  - 代码简洁，处理大小写转换的宏定义提高了代码可读性。
- **个人心得**：作者提到C语言字符串处理的不友好性，通过`getchar()`逐个处理输入，避免了`gets()`的潜在问题。

```c
#define val(a) (a<'a' ? (a-'A'+'a') : a)

for(i=0,j=0; s[i]!='\0'; ++i){
    if((i==0 || s[i-1]==' ' || j) && val(s[i])==val(w[j]) && ++j>-1){
        if(w[j]=='\0' && (s[i+1]=='\0' || s[i+1]==' ')){
            if(first==-1) first = i+1-j;
            count++;
        }
    }else j=0;
}
```

#### 2. 作者：Jelly_Goat (赞：63)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用`string`类型的`find()`函数进行匹配，代码简洁。
  - 通过前后添加空格来确保单词完全匹配，避免部分匹配问题。
  - 提供了C++和Python两种语言的解法，适合不同语言背景的读者。
- **个人心得**：作者提到一开始写的题解不够好，后来进行了改进，体现了不断优化的精神。

```cpp
string lowwers(string str){
    int len=str.size();
    for (int i=0;i<len;i++){
        str[i]=(str[i]>=65&&str[i]<=90)?str[i]+32:str[i];
    }
    return str;
}

string inputs(){
    string temp;
    getline(cin,temp);
    return ' '+lowwers(temp)+' ';
}
```

#### 3. 作者：Eason_lyx (赞：28)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用`tolower()`函数统一大小写，简化代码。
  - 通过遍历文章字符串，逐个单词进行匹配，逻辑清晰。
  - 代码结构简洁，易于理解。
- **个人心得**：作者提到第一次写题解，如有不足请多多谅解，体现了谦虚的态度。

```cpp
for(int i=0;i<s.size();++i){
    if(s[i]==' '){
        if(dan==ci){
            ans++;
            if(cur==-1) cur=i-ci.size();
        }
        dan="";
    }else dan+=s[i];
}
```

### 最优关键思路与技巧

1. **统一大小写**：通过`tolower()`或自定义宏将所有字符转换为小写，简化匹配逻辑。
2. **前后添加空格**：在单词和文章前后添加空格，确保匹配的是完整单词，避免部分匹配问题。
3. **逐个字符匹配**：通过维护两个指针（文章和单词）逐个字符匹配，确保匹配的准确性。

### 可拓展之处

- **类似题目**：可以扩展到更复杂的字符串匹配问题，如正则表达式匹配、多模式匹配等。
- **算法优化**：可以使用更高效的字符串匹配算法，如KMP算法、Boyer-Moore算法等。

### 推荐题目

1. **P1308 [NOIP2011 普及组] 统计单词数**（本题）
2. **P3375 【模板】KMP字符串匹配**
3. **P3370 【模板】字符串哈希**

### 个人心得总结

- **调试经历**：多位作者提到在处理输入时遇到问题，如`gets()`的潜在问题，通过`getchar()`逐个处理输入解决了问题。
- **踩坑教训**：部分作者提到一开始写的题解不够好，后来通过改进优化了代码，体现了不断学习和优化的精神。
- **顿悟感想**：通过前后添加空格来确保单词完全匹配，避免部分匹配问题，是解决本题的关键技巧之一。

---
处理用时：34.22秒
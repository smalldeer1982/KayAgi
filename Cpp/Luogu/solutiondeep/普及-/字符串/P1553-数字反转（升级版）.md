# 题目信息

# 数字反转（升级版）

## 题目背景

**以下为原题面，仅供参考:**

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。整数反转是将所有数位对调；小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分；分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母；百分数的分子一定是整数，百分数只改变数字部分。整数新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零；小数新数的末尾不为 $0$（除非小数部分除了 $0$ 没有别的数，那么只保留1个 $0$）；分数不约分，分子和分母都不是小数（约分滴童鞋抱歉了，不能过哦。输入数据保证分母不为 $0$），本次没有负数。


## 题目描述

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。

- 整数反转是将所有数位对调。

- 小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分。

- 分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母。

- 百分数的分子一定是整数，百分数只改变数字部分。

## 说明/提示

**【数据范围】**

- 对于 $25\%$ 的数据，$s$ 是整数，不大于 $20$ 位；
- 对于 $25\%$ 的数据，$s$ 是小数，整数部分和小数部分均不大于 $10$ 位；
- 对于 $25\%$ 的数据，$s$ 是分数，分子和分母均不大于 $10$ 位；
- 对于 $25\%$ 的数据，$s$ 是百分数，分子不大于 $19$ 位。

**【数据保证】**

- 对于整数翻转而言，整数原数和整数新数满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数和原来的数字的最高位数字不应为零。

- 对于小数翻转而言，其小数点前面部分同上，小数点后面部分的形式，保证满足小数的常见形式，也就是末尾没有多余的 $0$（小数部分除了 $0$ 没有别的数，那么只保留 $1$ 个 $0$。若反转之后末尾数字出现 $0$，请省略多余的 $0$）

- 对于分数翻转而言，分数不约分，分子和分母都不是小数。输入的分母不为 $0$。与整数翻转相关规定见上。

- 对于百分数翻转而言，见与整数翻转相关内容。

数据不存在负数。

## 样例 #1

### 输入

```
5087462```

### 输出

```
2647805```

## 样例 #2

### 输入

```
600.084```

### 输出

```
6.48```

## 样例 #3

### 输入

```
700/27```

### 输出

```
7/72```

## 样例 #4

### 输入

```
8670%```

### 输出

```
768%```

# AI分析结果

### 综合分析与结论

本题的核心在于如何处理不同类型的数字（整数、小数、分数、百分数）的反转，并去除多余的前导零和后导零。大部分题解通过字符串处理来实现反转和去零操作，部分题解使用了STL库函数（如`reverse`、`substr`等）来简化代码。总体来看，题解的思路较为相似，但在细节处理和代码优化上存在差异。

### 题解对比与评分

1. **题解作者：Anguei (赞：293)**
   - **星级：★★★★★**
   - **关键亮点**：
     - 使用了STL库函数（`reverse`、`erase`、`substr`）来简化代码，提升了代码的可读性和简洁性。
     - 通过`find`函数快速定位符号位置，避免了手动遍历字符串的繁琐操作。
     - 对小数部分的后导零处理进行了特别优化，确保输出符合题目要求。
   - **核心代码**：
     ```cpp
     std::string reverse(std::string s) {
         std::reverse(s.begin(), s.end());
         int zeroCount = 0;
         for (auto i : s)
             if (i == '0') ++zeroCount;
             else break;
         s.erase(s.begin(), s.begin() + zeroCount);
         return (s != "" ? s : "0");
     }
     ```

2. **题解作者：SebMa (赞：737)**
   - **星级：★★★★☆**
   - **关键亮点**：
     - 通过遍历字符串，记录符号位置，并分别处理符号前后的数字部分。
     - 使用`while`循环去除前导零和后导零，确保输出的数字格式正确。
     - 代码逻辑清晰，适合初学者理解。
   - **核心代码**：
     ```cpp
     while(s[cnt]=='0'&&cnt>0) cnt--;
     for(int i=cnt;i>=0;i--) cout<<s[i];
     ```

3. **题解作者：lhh619899573 (赞：88)**
   - **星级：★★★★☆**
   - **关键亮点**：
     - 使用Java语言实现，思路清晰，适合Java学习者参考。
     - 通过`split`函数将字符串分割为分子和分母，分别处理反转和去零操作。
     - 对小数部分的处理进行了特别优化，确保输出格式正确。
   - **核心代码**：
     ```java
     public static void turn(String str) {
         boolean flag1 = false, flag2 = false;
         String s = "";
         for(int i=0;i<=str.length()-1;i++) {
             if(!flag1 && str.charAt(i)=='0') continue;
             flag1 = true;
             s += str.charAt(i);
         }
         for(int i=s.length()-1;i>=0;i--) {
             if(!flag2 && s.charAt(i)=='0') continue;
             flag2 = true;
             System.out.printf("%s",s.charAt(i));
         }
     }
     ```

### 最优关键思路与技巧

1. **使用STL库函数**：如`reverse`、`substr`、`erase`等函数可以大大简化字符串处理的操作，提升代码的可读性和简洁性。
2. **符号定位与分割**：通过`find`函数快速定位符号位置，并将字符串分割为前后两部分，分别处理反转和去零操作。
3. **去零优化**：对于小数部分，需要特别处理后导零，确保输出格式正确。

### 可拓展之处

1. **类似题目**：可以扩展到处理更复杂的数字格式，如科学计数法、带符号的数字等。
2. **算法优化**：可以进一步优化去零操作，减少不必要的遍历和判断。

### 推荐题目

1. **P1553 数字反转（升级版）**：本题的升级版，考察更复杂的数字格式处理。
2. **P1042 乒乓球**：考察字符串处理与逻辑判断。
3. **P1055 ISBN号码**：考察字符串处理与校验码计算。

### 个人心得摘录

- **SebMa**：错了好几次才AC；QAQ。细节太多，要周密考虑！
- **Anguei**：如果你对STL了解得比较透彻，那么这篇题解一定是最简单的。
- **lhh619899573**：由于不能一次AC，才发现里面有坑，要注意00/5要输出0/5。

这些心得反映了在解决复杂字符串处理问题时，细节处理和调试的重要性。

---
处理用时：43.23秒
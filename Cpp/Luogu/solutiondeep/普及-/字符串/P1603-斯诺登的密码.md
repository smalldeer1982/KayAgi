# 题目信息

# 斯诺登的密码

## 题目背景

根据斯诺登事件出的一道水题


## 题目描述

2013 年 X 月 X 日，俄罗斯办理了斯诺登的护照，于是他混迹于一架开往委内瑞拉的飞机。但是，这件事情太不周密了，因为 FBI 的间谍早已获悉他的具体位置——但这不是最重要的——最重要的是如果要去委内瑞拉，那么就要经过古巴，而经过古巴的路在美国的掌控之中。

丧心病狂的奥巴马迫降斯诺登的飞机，搜查时却发现，斯诺登杳无踪迹。但是，在据说是斯诺登的座位上，发现了一张纸条。纸条由纯英文构成：`Obama is a two five zero.`（以 `.` 结束输出，只有 $6$ 个单词+一个句号，句子开头如没有大写亦为合法）这句话虽然有点无厘头，但是警官陈珺骛发现这是一条极其重要的线索。他在斯诺登截获的一台笔记本中找到了一个 C++ 程序，输入这条句子后立马给出了相对应的密码。陈珺鹜高兴得晕了过去，身为警官的你把字条和程序带上了飞机，准备飞往曼哈顿国际机场，但是在飞机上检查的时候发现——程序被粉碎了！飞机抵达华盛顿只剩 $5$ 分钟，你必须在这 $5$ 分钟内编写（杜撰）一个程序，免受上司的 $10000000000 \bmod 10$ 大板。破译密码的步骤如下：

（1）找出句子中所有用英文表示的数字 $(\leq 20)$，列举在下：

正规：`one two three four five six seven eight nine ten eleven twelve`
           `thirteen fourteen fifteen sixteen seventeen eighteen nineteen             twenty`

非正规：`a both another first second third`。为避免造成歧义，`another` 算作 $1$ 处理。

（2）将这些数字平方后对 $100$ 取模，如 $00,05,11,19,86,99$。

（3）把这些两位数按数位排成一行，组成一个新数，如果开头为 $0$，就去 $0$。

（4）找出所有排列方法中最小的一个数，即为密码。

// 数据已经修正 By absi2011 如果还有问题请联系我


## 样例 #1

### 输入

```
Black Obama is two five zero .```

### 输出

```
425```

# AI分析结果

### 综合分析与结论

本题的核心在于将英文单词转换为对应的数字，经过平方取模后，按最小排列组合成一个新数。题解中主要涉及字符串处理、排序、贪心算法等知识点。大部分题解通过打表或使用`map`来映射单词与数字的关系，然后通过排序找到最小的排列组合。部分题解还考虑了前导0的处理和特殊情况（如全为0时输出0）。

整体来看，题解的质量参差不齐，部分题解代码冗长且重复，而一些题解则通过简洁的代码和优化的思路解决了问题。以下是几条较为优秀的题解及其亮点。

### 评分较高的题解

#### 1. 作者：Maktub (赞：149)
- **星级**：★★★★★
- **关键亮点**：使用`map`进行单词与数字的映射，代码简洁且高效。通过排序后直接输出，避免了复杂的字符串处理。
- **核心代码**：
```cpp
map<string,int>q;
q["one"]=1; q["two"]=2; // 省略其他映射
for(int i=1;i<=6;i++){
    cin>>s;
    if(q[s]){
        int k=q[s]*q[s]%100;
        if(k==0) continue;
        st[++top]=k;
    }
}
sort(st+1,st+top+1);
cout<<st[1];
for(int i=2;i<=top;i++){
    if(st[i]<10) cout<<0;
    cout<<st[i];
}
```
- **个人心得**：作者提到`map`在处理字符串与数字映射时非常方便，避免了手动查找的繁琐。

#### 2. 作者：zhaowangji (赞：63)
- **星级**：★★★★☆
- **关键亮点**：通过数组存储单词与数字的映射，代码简洁且易于理解。排序后直接输出，处理了前导0的情况。
- **核心代码**：
```cpp
string yw[30]={"","one","two","three", /* 省略其他单词 */};
int sz[30]={0,1,4,9,16,25, /* 省略其他数字 */};
for(int i=1;i<=6;i++){
    string x; cin>>x;
    for(int j=1;j<=26;j++)
        if(yw[j]==x) a[++k]=sz[j];
}
sort(a+1,a+k+1);
for(int i=1;i<=k;i++){
    if(i!=1&&a[i]<10) cout<<0;
    cout<<a[i];
}
```
- **个人心得**：作者提到提前打好表可以方便后续处理，减少了代码的复杂性。

#### 3. 作者：hsfzLZH1 (赞：4)
- **星级**：★★★★☆
- **关键亮点**：使用`map`和`string`进行排序，代码简洁且高效。通过`stringstream`处理输出，避免了手动拼接字符串的麻烦。
- **核心代码**：
```cpp
map<string,int>m;
m["one"]=1; m["two"]=2; // 省略其他映射
for(int i=0;i<6;i++){
    cin>>s;
    if(m[s]) ans+=m[s]*m[s]%100;
}
sort(ans.begin(),ans.end());
stringstream stream;
for(int i=0;i<ans.size();i++) stream<<ans[i];
stream>>result;
cout<<result;
```
- **个人心得**：作者提到`stringstream`在处理字符串拼接时非常方便，简化了代码。

### 最优关键思路与技巧

1. **使用`map`进行映射**：`map`在处理字符串与数字的映射时非常方便，避免了手动查找的繁琐。
2. **排序与贪心**：通过排序找到最小的排列组合，确保高位数字尽可能小。
3. **处理前导0**：在输出时，首位不为0，后续数字若小于10则补0。
4. **特殊情况处理**：如全为0时输出0，避免无输出或错误输出。

### 可拓展之处

- **类似题目**：可以拓展到其他需要将字符串转换为数字并进行排序的题目，如电话号码的排列组合、单词的字典序排列等。
- **优化思路**：可以考虑使用更高效的数据结构（如`unordered_map`）来进一步优化查找速度。

### 推荐题目

1. **P1012 拼数**：考察字符串拼接与排序。
2. **P1107 最大整数**：类似拼数，考察字符串拼接与排序。
3. **P1604 单词接龙**：考察字符串处理与拼接。

### 个人心得总结

- **调试经历**：部分题解提到在处理前导0时遇到了问题，通过增加特判解决了问题。
- **踩坑教训**：在处理全为0的情况时，部分题解未考虑，导致WA。
- **顿悟感想**：使用`map`和`stringstream`可以大大简化代码，提高可读性和效率。

---
处理用时：43.76秒
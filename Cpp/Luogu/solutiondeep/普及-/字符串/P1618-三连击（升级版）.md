# 题目信息

# 三连击（升级版）

## 题目描述

将 $1, 2,\ldots, 9$ 共 $9$ 个数分成三组，分别组成三个三位数，且使这三个三位数的比例是 $A:B:C$，试求出所有满足条件的三个三位数，若无解，输出 `No!!!`。


//感谢黄小U饮品完善题意


## 说明/提示

保证 $A<B<C$。

---

$\text{upd 2022.8.3}$：新增加二组 Hack 数据。

## 样例 #1

### 输入

```
1 2 3```

### 输出

```
192 384 576
219 438 657
273 546 819
327 654 981```

# AI分析结果

### 综合分析与结论

本题的核心是将1到9的数字分成三组，组成三个三位数，且这三个数的比例为给定的A:B:C。题解中常见的思路包括暴力枚举、深度优先搜索（DFS）、全排列生成、以及基于比例的优化。大部分题解通过枚举可能的数字组合，并检查是否满足比例和数字不重复的条件。

#### 关键思路与技巧：
1. **比例优化**：通过比例关系，减少枚举范围。例如，已知A:B:C，可以枚举第一个数，然后根据比例计算其他两个数，避免全排列的高复杂度。
2. **数字去重**：使用数组或哈希表记录数字是否被使用过，确保每个数字只出现一次。
3. **全排列生成**：利用C++的`next_permutation`函数生成1到9的全排列，简化代码实现。
4. **剪枝与优化**：在枚举过程中，通过提前判断数字是否重复或超出范围，减少不必要的计算。

#### 通用建议与扩展思路：
- **优化枚举范围**：根据比例关系，合理缩小枚举范围，避免不必要的计算。
- **数据结构选择**：使用数组或哈希表记录数字使用情况，确保数字不重复。
- **全排列生成**：对于需要生成所有排列的问题，可以使用`next_permutation`函数简化代码。

### 所选高星题解

#### 1. 作者：Timothy (5星)
**关键亮点**：
- 通过比例关系优化枚举范围，减少计算量。
- 使用数组记录数字是否重复，确保每个数字只出现一次。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for (int b=1;b<=1000/k3;++b) {
    b1=b*k1; // 求出三个数
    b2=b*k2;
    b3=b*k3; 
    if (b2>999||b3>999)break;
    for (int c=1;c<=3;++c) { // 将三个数进行分解，判断是否重复
        a[b1%10]++;
        b1/=10;
    }
    for (int c=1;c<=3;++c) {
        a[b2%10]++;
        b2/=10;
    }
    for (int c=1;c<=3;++c) {
        a[b3%10]++;
        b3/=10;
    }
    for (int c=1;c<=9;++c)if (a[c]!=1){l=1;break;}
    for (int c=1;c<=9;++c)a[c]=0;
    if (!l){cout <<b*k1 <<" " <<b*k2 <<" " <<b*k3 <<endl;ans++;}
    else l=0;
}
```

#### 2. 作者：jojo (4星)
**关键亮点**：
- 使用深度优先搜索（DFS）生成所有可能的数字组合。
- 通过递归实现全排列生成，逻辑清晰。
- 代码结构合理，易于理解。

**核心代码**：
```cpp
void solve(int n){
    if(n==10&&cons(1)*b==cons(2)*a&&cons(1)*c==cons(3)*a){ // 当n=10时x数组数字存满，开始判断
        cout<<cons(1)<<" "<<cons(2)<<" "<<cons(3)<<endl;
        ans=true;
        return;
    }
    for(int i=1;i<=9;i++){
        if(!used[i]){
            x[n]=i; // 存数字
            used[i]=1; // 该数字被使用
            solve(n+1); // 下一位继续调用
            used[i]=0; // 恢复
        }
    }
    return;
}
```

#### 3. 作者：lwzheng00000 (4星)
**关键亮点**：
- 使用`next_permutation`生成全排列，简化代码实现。
- 通过比例关系判断是否满足条件，逻辑清晰。
- 代码简洁，易于理解。

**核心代码**：
```cpp
do{
    int a1=100*b3[1]+10*b3[2]+b3[3]; // 第一个数
    int b1=100*b3[4]+10*b3[5]+b3[6]; // 第二个数
    int c1=100*b3[7]+10*b3[8]+b3[9]; // 第三个数
    if((a1*b==b1&&a1*c==c1)||(a1==a&&b1==b&&c1==c)){ // 判断
        co++;
        printf("%d %d %d\n",a1,b1,c1); // 输出
    }
} while(next_permutation(b3+1,b3+10));
```

### 推荐相似题目
1. **P1008 三连击**：基础版的三连击问题，适合练习数字组合与比例判断。
2. **P1036 选数**：涉及数字组合与条件判断，适合练习DFS与剪枝。
3. **P1217 [USACO1.5]回文质数**：涉及数字生成与条件判断，适合练习枚举与优化。

### 个人心得摘录
- **Timothy**：通过比例关系优化枚举范围，减少了不必要的计算，代码简洁高效。
- **jojo**：使用DFS生成全排列，逻辑清晰，代码结构合理，适合初学者理解递归与回溯。
- **lwzheng00000**：利用`next_permutation`生成全排列，简化了代码实现，适合快速解决问题。

---
处理用时：43.09秒
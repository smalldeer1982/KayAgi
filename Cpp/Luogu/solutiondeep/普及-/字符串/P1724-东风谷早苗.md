# 题目信息

# 东风谷早苗

## 题目描述

在幻想乡，东风谷早苗是以高达控闻名的高中生宅巫女。某一天，早苗终于入手了最新款的钢达姆模型。作为最新的钢达姆，当然有了与以往不同的功能了，那就是它能够自动行走，厉害吧（好吧，我自重）。早苗的新模型可以按照输入的命令进行移动，命令包含 $\verb|E|$、$\verb|S|$、$\verb|W|$、$\verb|N|$ 四种，分别对应四个不同的方向，依次为东、南、西、北。执行某个命令时，它会向着对应方向移动一个单位。作为新型机器人，自然不会只单单执行一个命令，它可以执行命令串。对于输入的命令串，每一秒它会按照命令行动一次。而执行完命令串最后一个命令后，会自动从头开始循环。在 $0$ 时刻时早苗将钢达姆放置在了 $(0,0)$ 的位置，并且输入了命令串。她想要知道 $T$ 秒后钢达姆所在的位置坐标。

假设当前钢达姆的位置是 $(x,y)$。那么对于四种方向的移动，它坐标的改变分别为：

- 向东移动，坐标改变改变为 $(x+1,y)$；
- 向南移动，坐标改变改变为 $(x,y-1)$；
- 向西移动，坐标改变改变为 $(x-1,y)$；
- 向北移动，坐标改变改变为 $(x,y+1)$。




## 说明/提示

用 $|S|$ 表示早苗输入的命令串的长度。

- 对于 $60\%$ 的数据，$T\le 5\times 10^5$，$|S|\le 5\times 10^3$。
- 对于 $100\%$ 的数据，$T \le 2\times 10^9$，$|S|\le  5\times 10^3$。


## 样例 #1

### 输入

```
NSWWNSNEEWN
12
```

### 输出

```
-1 3```

# AI分析结果

### 综合分析与结论

该题目要求模拟一个机器人按照给定的命令串循环移动，计算在T秒后的位置。由于T的范围非常大（2e9），直接模拟会导致超时。因此，优化思路主要集中在通过计算每一轮命令的位移，然后乘以轮数，最后处理剩余的步数。

大多数题解都采用了类似的优化思路：先计算一轮命令的位移，然后乘以轮数，最后模拟剩余的步数。这种思路能够有效减少时间复杂度，从O(T)降低到O(|S|)，其中|S|是命令串的长度。

### 评分较高的题解

#### 1. 作者：RKcer21 (赞：26)
- **星级**：4.5
- **关键亮点**：代码简洁，优化思路清晰，直接通过计算每一轮的位移来减少时间复杂度。
- **核心代码**：
  ```cpp
  for (i=0; i<m; i++)
    if (c[i%m]=='E') xx+=1;
    else if (c[i%m]=='S') yy-=1;
    else if (c[i%m]=='W') xx-=1;
    else yy+=1;
  for (i=0; i<n%m; i++)
    if (c[i%m]=='E') x+=1;
    else if (c[i%m]=='S') y-=1;
    else if (c[i%m]=='W') x-=1;
    else y+=1;
  cout<<x+n/m*xx<<' '<<y+n/m*yy;
  ```
- **个人心得**：作者提到最初的暴力模拟只能得60分，通过优化后成功AC，强调了优化的重要性。

#### 2. 作者：VenusM1nT (赞：15)
- **星级**：4.0
- **关键亮点**：使用map来存储方向对应的位移，代码可读性较高，优化思路清晰。
- **核心代码**：
  ```cpp
  for(int i=0;i<s.size();i++) cx+=dx[s[i]],cy+=dy[s[i]];
  int r=n/s.size();
  x+=r*cx;
  y+=r*cy;
  n%=s.size();
  for(int i=0;i<n;i++) x+=dx[s[i]],y+=dy[s[i]];
  ```
- **个人心得**：作者提到直接暴力模拟会TLE，强调了优化的重要性。

#### 3. 作者：_jimmywang_ (赞：7)
- **星级**：4.0
- **关键亮点**：代码简洁，优化思路清晰，通过计算每一轮的位移来减少时间复杂度。
- **核心代码**：
  ```cpp
  for(int i=0;i<=min((long long)s.size()-1,t);i++) {
    if(s[i]=='N')x++;
    if(s[i]=='E')y++;
    if(s[i]=='S')x--;
    if(s[i]=='W')y--;
  }
  int bs=t/s.size();
  int ys=t%s.size();
  x*=bs,y*=bs;
  for(int i=0;i<ys;i++) {
    if(s[i]=='N')x++;
    if(s[i]=='E')y++;
    if(s[i]=='S')x--;
    if(s[i]=='W')y--;
  }
  ```
- **个人心得**：作者提到最初的暴力模拟只能得60分，通过优化后成功AC，强调了优化的重要性。

### 最优关键思路与技巧

1. **周期优化**：通过计算每一轮命令的位移，然后乘以轮数，最后处理剩余的步数，将时间复杂度从O(T)降低到O(|S|)。
2. **代码简洁性**：使用简单的循环和条件判断来实现位移计算，避免复杂的逻辑。
3. **数据结构选择**：部分题解使用map来存储方向对应的位移，提高了代码的可读性。

### 可拓展之处

这种周期优化的思路可以应用于其他类似的循环模拟问题，例如：
- 循环执行一系列操作后计算最终状态。
- 大规模循环操作中，通过计算每一轮的贡献来减少时间复杂度。

### 推荐题目

1. **P1008 三连击**：考察循环与条件判断的结合。
2. **P1010 幂次方**：考察递归与循环的结合。
3. **P1012 拼数**：考察字符串处理与循环的结合。

### 个人心得总结

- **优化的重要性**：直接暴力模拟在大数据范围下往往不可行，必须通过优化来减少时间复杂度。
- **调试经历**：多次提交后发现暴力模拟只能得60分，通过优化后成功AC，强调了优化的重要性。
- **顿悟感想**：通过计算每一轮的贡献来减少时间复杂度，是一种常见的优化思路，适用于类似的循环模拟问题。

---
处理用时：33.53秒
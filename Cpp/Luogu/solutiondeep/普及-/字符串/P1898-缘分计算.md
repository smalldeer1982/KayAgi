# 题目信息

# 缘分计算

## 题目背景

缘分是一个外国人难以理解的中文名词。大致说来，缘分是一种冥冥中将两人（通常是情人）结合的力量。仅管这是种迷信，很多人——特别是女生——喜欢去计算它。

不幸的是，644 也是这样。有天，她问 DL：“甜心，可以算一下我们的缘分吗？”唉，DL 真的很讨厌这问题，但他无法拒绝。还好，DL 是个程序设计师，所以他只要找到一个看来不错的算法并写成一个缘分计算器就可以了。在网络上搜寻了几个小时后，他决定采用以下的缘分算法：

## 题目描述

第一步：取出姓名的缩写（abbreviation）并接在一起。例如，如果这对恋人叫 JiangYunFan 和 TangYuRou，他们的缩写就是 JYFTYR。第二步：将每个字母用数字字符串取代。用 $\mathrm{ST}$ 来取代 $\tt A$，$\mathrm{ST}+1$ 来取代 $\tt B$，$\mathrm{ST}+2$ 来取代 $\tt C$，……，$\mathrm{ST}+25$ 来取代 $Z$，其中 $\mathrm{ST}$ 为一个已知的正整数。例如，如果 $\mathrm{ST}=81$，$\tt A$ 就被 $81$ 取代，$\tt B$ 就被 $82$ 取代，……，$\tt Z$ 则被 $106$ 取代。上面的例子 JYFTYR 则被 $901058610010598$ 取代。

第三步：重复以下操作：将相邻的两位数相加，并写下和的个位数。不难发现这个操作每进行一次，这个数字字符串就会少一位数。当这个数字变成 $100$ 或不超过两位数（第一位是 $0$ 也算两位数）时，这个程序便停止。所得的数字就是两人的缘分。用上面的例子来说，处理的过程如下：

- $901058610010598$；
- $91153471011547$；
- $0268718112691$；
- ……
- $374$；
- $01$。

所以如果 $\mathrm{ST}=81$，JiangYunFan 和 TangYuRou 的缘分便只有 $1$。

惨了！DL 很了解 644。他知道即使这个程序计算出的缘分高达 $99$ 她仍然会不高兴。更何况 644 还对其余很多对恋人间的缘分感兴趣，要是他一个个计算会太繁琐。如果告诉你一对恋人的姓名和一个 $\mathrm{ST}$ 值，你能编一个程序算出他们的缘分吗？

## 说明/提示

### 数据范围及约定

对于 $100\%$ 的数据，$4 ≤ L ≤ 10$，$1 ≤ \mathrm{ST} ≤ 10000$。

### 注意

如果你和你的恋人的缘分不是 $100$，不要伤心。这没有什么大不了的。

## 样例 #1

### 输入

```
DLLSS
478```

### 输出

```
100
```

# AI分析结果

### 综合分析与结论

本题的核心是通过字符串处理和模拟操作来计算“缘分值”。题解主要集中在以下几个关键点：
1. **字符串处理**：将字母转换为对应的数字，并拼接成数字字符串。
2. **模拟操作**：通过相邻数字相加并取个位数的操作，逐步缩短数字字符串，直到满足条件（≤100或为100）。
3. **特判处理**：对特殊情况（如100）进行特判，避免不必要的计算。

大多数题解采用了直接模拟的方法，部分题解在实现上进行了优化，如倒序存储、递归处理等。整体来看，题解的质量参差不齐，部分题解代码冗长且不易读，少数题解在实现上较为简洁且高效。

### 所选高质量题解

#### 1. 作者：Lolierl (赞：12)  
**星级：4.5**  
**关键亮点**：  
- **倒序存储**：通过倒序存储数字，简化了数位分离的处理，避免了复杂的条件判断。
- **简洁的模拟操作**：代码逻辑清晰，模拟操作部分简洁明了，易于理解。
- **特判处理**：对100的情况进行了特判，避免了不必要的计算。

**核心代码**：
```cpp
for(int i=cnt-1;i>=3;i--) // 每次剩下i位
    for(int j=1;j<=i;j++)
        k[j]=(k[j]+k[j+1])%10; // 相邻位相加取个位
if(k[1]==0&&k[2]==0&&k[3]==1){cout<<100;return 0;} // 特判100
```

#### 2. 作者：_Luminous (赞：1)  
**星级：4**  
**关键亮点**：  
- **倒序存储与数位分离**：通过倒序存储和数位分离，简化了数字处理过程。
- **递归思想**：虽然没有直接使用递归，但通过循环模拟了递归的思想，代码结构清晰。
- **特判处理**：对100的情况进行了特判，确保输出正确。

**核心代码**：
```cpp
for(int i=cnt-1;i>=3;i--) // 每次剩下i位
    for(int j=1;j<=i;j++)
        ans[j]=(ans[j]+ans[j+1])%10; // 相邻位相加取个位
if(ans[3]==1 && !ans[2] && !ans[1]){cout<<100;return 0;} // 特判100
```

#### 3. 作者：AveMarina (赞：0)  
**星级：4**  
**关键亮点**：  
- **字符串旋转操作**：通过旋转操作解决了数字倒序存储的问题，代码实现较为巧妙。
- **简洁的模拟操作**：模拟操作部分代码简洁，逻辑清晰。
- **特判处理**：对100的情况进行了特判，确保输出正确。

**核心代码**：
```cpp
while(true) { // 循环处理，直到出现了合法解
    temp = "";
    rLen = res.size();
    if (rLen <= 3) {
        if (res == "100") break;
        else if (rLen <= 2) break;
    }
    for(int i = 0; i < rLen - 1; i++) 
        temp += (char)((res[i] - '0' + res[i + 1] - '0') % 10 + '0'); // 相邻位相加取个位
    res = temp; // 更新解 
}
```

### 最优关键思路与技巧

1. **倒序存储与数位分离**：通过倒序存储数字，简化了数位分离的处理，避免了复杂的条件判断。
2. **递归思想**：虽然部分题解没有直接使用递归，但通过循环模拟了递归的思想，代码结构清晰。
3. **特判处理**：对特殊情况（如100）进行特判，避免不必要的计算，提高代码效率。

### 可拓展之处

本题的模拟操作和字符串处理技巧可以应用于其他类似的题目，如数字串的压缩、字符串的逐步简化等。类似的题目可以考察学生对字符串处理和模拟操作的掌握情况。

### 推荐题目

1. **P1003 铺地毯**：考察模拟操作和条件判断。
2. **P1012 拼数**：考察字符串处理和排序。
3. **P1028 数的计算**：考察递归思想和模拟操作。

### 个人心得摘录

- **作者：__Chtholly**：在调试过程中发现全为0的情况会被当作前导0删除，最终通过增加`putcha`变量来检查是否有输出，确保程序正确性。
- **作者：我是小何子啊**：通过栈解决了数字倒序存储的问题，简化了数位分离的处理。

这些心得展示了在调试过程中如何发现并解决问题，强调了特判和边界情况处理的重要性。

---
处理用时：41.38秒
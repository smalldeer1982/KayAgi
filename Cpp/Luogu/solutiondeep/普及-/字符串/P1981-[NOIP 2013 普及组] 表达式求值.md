# 题目信息

# [NOIP 2013 普及组] 表达式求值

## 题目背景

NOIP2013 普及组 T2

## 题目描述

给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。


## 说明/提示

对于 $30\%$ 的数据，$0≤$ 表达式中加法运算符和乘法运算符的总数 $≤100$。

对于 $80\%$ 的数据，$0≤$ 表达式中加法运算符和乘法运算符的总数 $≤1000$。

对于 $100\%$ 的数据，$0≤$ 表达式中加法运算符和乘法运算符的总数 $≤100000$。


## 样例 #1

### 输入

```
1+1*3+4
```

### 输出

```
8```

## 样例 #2

### 输入

```
1+1234567890*1```

### 输出

```
7891```

## 样例 #3

### 输入

```
1+1000000003*1```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

本题的核心在于处理只包含加法和乘法的算术表达式，并计算其值。由于乘法的优先级高于加法，因此在处理表达式时需要特别注意运算顺序。大多数题解采用了栈或模拟的方法来处理表达式，部分题解还引入了表达式树等高级数据结构。整体来看，栈的使用是最为常见且高效的解决方案。

### 所选高星题解

#### 1. 作者：wbhpig (赞：347)  
**星级：4.5**  
**关键亮点：**  
- 使用栈来处理表达式，清晰且高效。
- 通过栈顶元素与当前数字的乘积来处理乘法运算，简化了逻辑。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
stack <int> x;
int main() {
    int a,b;
    char c;
    cin>>a;
    int m=10000;
    a=a%m;
    x.push(a);
    while(cin>>c>>b) {
        if(c=='*') {
            a=x.top();
            x.pop();
            x.push(a*b%m);
        } else {
            x.push(b);
        }
    }
    a=0;
    while(x.size()) {
        a+=x.top();
        a%=m;
        x.pop();
    }
    cout<<a<<endl;
    return 0;
}
```
**核心思想：**  
通过栈来存储数字，遇到乘法时弹出栈顶元素与当前数字相乘，结果重新压入栈中。最后将所有栈中元素相加得到结果。

#### 2. 作者：__ykl (赞：62)  
**星级：4.0**  
**关键亮点：**  
- 通过分段处理加法和乘法，逻辑清晰。
- 使用变量 `t` 来记录当前段的乘积，简化了计算过程。
- 代码简洁，易于实现。

**核心代码：**
```cpp
int x,s,t;
char c;
int main() {
    scanf("%d",&t);
    while(scanf("%c",&c) && c != '\n') {
        scanf("%d",&x);
        if(c == '*') t = t * x % mod;
        else s = (s + t) % mod, t = x;
    }
    printf("%d\n",(s + t) % mod);
    return 0;
}
```
**核心思想：**  
通过变量 `t` 记录当前段的乘积，遇到加法时将 `t` 累加到结果 `s` 中，并重置 `t` 为当前数字。最后将 `s` 和 `t` 相加得到结果。

#### 3. 作者：_lxc__ (赞：3)  
**星级：4.0**  
**关键亮点：**  
- 使用栈来处理表达式，逻辑清晰。
- 通过栈顶元素与当前数字的乘积来处理乘法运算，简化了逻辑。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
stack<long long> st;
int main() {
    cin>>x;
    st.push(x);
    while(cin>>op>>x) {
        if(op=='+') {
            st.push(x);
        } else {
            x=(st.top()*x)%10000;
            st.pop();
            st.push(x);
        }
    }
    while(st.size()) {
        ans=(ans+st.top())%10000;
        st.pop();
    }
    cout<<ans;
    return 0;
}
```
**核心思想：**  
通过栈来存储数字，遇到乘法时弹出栈顶元素与当前数字相乘，结果重新压入栈中。最后将所有栈中元素相加得到结果。

### 最优关键思路与技巧

1. **栈的使用：** 栈是处理表达式求值的经典数据结构，特别适合处理优先级问题。通过栈可以方便地处理乘法和加法的优先级差异。
2. **分段处理：** 通过分段处理加法和乘法，可以简化逻辑，减少代码复杂度。
3. **取模运算：** 在计算过程中及时取模，避免数值溢出，同时保证结果在要求范围内。

### 可拓展之处

- **表达式树：** 对于更复杂的表达式，可以考虑使用表达式树来处理，尤其是当表达式包含括号或其他优先级更高的运算符时。
- **动态规划：** 在某些情况下，动态规划可以用来优化表达式的计算过程，尤其是在表达式较长且包含重复子表达式时。

### 推荐题目

1. [P1045 表达式求值](https://www.luogu.com.cn/problem/P1045)
2. [P1982 表达式求值](https://www.luogu.com.cn/problem/P1982)
3. [P1179 表达式求值](https://www.luogu.com.cn/problem/P1179)

### 个人心得总结

- **调试经历：** 在处理表达式时，特别注意运算符的优先级和顺序，避免逻辑错误。
- **踩坑教训：** 在处理长表达式时，及时取模，避免数值溢出。
- **顿悟感想：** 栈的使用在处理表达式求值时非常高效，尤其是在处理优先级问题时，栈的结构能够很好地满足需求。

---
处理用时：46.54秒
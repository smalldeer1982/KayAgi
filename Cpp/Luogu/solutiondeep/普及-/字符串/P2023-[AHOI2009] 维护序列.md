# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果

### 综合分析与结论

本题是一个典型的线段树应用问题，要求支持区间乘法、区间加法和区间查询操作。大多数题解都采用了线段树的基本框架，并通过维护`sum`、`add`、`mul`三个标记来处理乘法和加法的优先级问题。难点在于如何处理乘法和加法的顺序，以及如何高效地下放标记。部分题解在代码实现上进行了优化，如使用位运算、指针加速等技巧，提升了代码的可读性和执行效率。

### 精选题解

#### 题解1：作者：Mingoal (赞：74)
- **星级**：★★★★★
- **关键亮点**：
  - 代码结构清晰，注释详细，易于理解。
  - 通过`maintain`函数统一处理标记下放，逻辑简洁。
  - 使用了位运算优化，提升了代码执行效率。
- **个人心得**：
  - 作者提到“线段树不熟，打几遍都不嫌多”，强调了多次练习的重要性。
- **核心代码**：
  ```cpp
  void maintain(int t,int k){
      tr[t<<1].su=(tr[t<<1].su*tr[t].mu+tr[t].ad*(k+1>>1))%M;
      tr[t<<1|1].su=(tr[t<<1|1].su*tr[t].mu+tr[t].ad*(k>>1))%M;
      tr[t<<1].mu=tr[t<<1].mu*tr[t].mu%M;
      tr[t<<1|1].mu=tr[t<<1|1].mu*tr[t].mu%M;
      tr[t<<1].ad=(tr[t<<1].ad*tr[t].mu+tr[t].ad)%M;
      tr[t<<1|1].ad=(tr[t<<1|1].ad*tr[t].mu+tr[t].ad)%M;
      tr[t].mu=1;tr[t].ad=0;
  }
  ```

#### 题解2：作者：zjy111 (赞：35)
- **星级**：★★★★☆
- **关键亮点**：
  - 详细解释了线段树的建树、标记下放、区间修改和查询的过程。
  - 通过`pushdown`函数处理标记下放，逻辑清晰。
  - 代码结构合理，易于扩展。
- **核心代码**：
  ```cpp
  void pushdown(ll p){
      sum[p<<1]=(sum[p<<1]*mul[p]+add[p]*(rr[p<<1]-ll[p<<1]+1))%md;
      sum[p<<1|1]=(sum[p<<1|1]*mul[p]+add[p]*(rr[p<<1|1]-ll[p<<1|1]+1))%md;
      mul[p<<1]=(mul[p<<1]*mul[p])%md;
      mul[p<<1|1]=(mul[p<<1|1]*mul[p])%md;
      add[p<<1]=(add[p<<1]*mul[p]+add[p])%md;
      add[p<<1|1]=(add[p<<1|1]*mul[p]+add[p])%md;
      mul[p]=1;add[p]=0;
  }
  ```

#### 题解3：作者：GaryZhong (赞：17)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用了结构体指针构建线段树，适合动态内存管理。
  - 通过`down`函数处理标记下放，逻辑清晰。
  - 代码结构合理，易于扩展。
- **核心代码**：
  ```cpp
  void down(int rt, int l, int r){
      if (mtp[rt] == 1 && inc[rt] == 0) return;
      if (l != r)
          mtp[lson] = mtp[lson] * mtp[rt] % P,
          mtp[rson] = mtp[rson] * mtp[rt] % P, 
          inc[lson] = (inc[lson] * mtp[rt] % P + inc[rt]) % P;
          inc[rson] = (inc[rson] * mtp[rt] % P + inc[rt]) % P;
      sum[rt] = (sum[rt] * mtp[rt] % P + inc[rt] * (r - l + 1) % P) % P;
      mtp[rt] = 1, inc[rt] = 0;
  }
  ```

### 最优关键思路与技巧

1. **标记下放顺序**：在处理乘法和加法时，必须优先处理乘法标记，因为乘法会影响加法标记的值。
2. **位运算优化**：使用位运算（如`<<1`和`<<1|1`）代替乘除法，提升代码执行效率。
3. **结构体指针**：使用结构体指针构建线段树，适合动态内存管理，代码结构更清晰。

### 可拓展之处

- **区间赋值操作**：可以扩展支持区间赋值操作，类似于乘法和加法的处理方式。
- **动态开点线段树**：适用于数据范围较大的情况，节省内存。

### 推荐题目

1. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)
2. [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)
3. [P1502 窗口的星星](https://www.luogu.com.cn/problem/P1502)

### 个人心得总结

- **多次练习**：多位作者提到多次练习线段树的重要性，强调了熟能生巧的道理。
- **调试经验**：部分作者分享了调试过程中的经验，如通过`DEBUG`宏输出中间结果，帮助定位问题。
- **优化技巧**：使用位运算、指针加速等技巧，提升了代码的执行效率和可读性。

---
处理用时：58.54秒
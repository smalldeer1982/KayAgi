# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过并查集维护动物之间的复杂关系（同类、捕食、被捕食）。由于关系是环形的（A吃B，B吃C，C吃A），普通的并查集无法直接处理，因此需要扩展并查集的结构或引入权值来表示这些关系。题解中主要有两种思路：

1. **种类并查集**：通过将并查集扩展为三倍大小，分别表示同类、捕食、被捕食关系。通过合并和查询操作，维护这些关系。
2. **带权并查集**：通过给并查集中的边赋予权值（0表示同类，1表示捕食，2表示被捕食），通过路径压缩和合并操作，动态维护这些关系。

两种方法各有优劣，种类并查集思路直观，代码实现相对简单；带权并查集则更加灵活，适用于更复杂的关系维护。

### 所选高质量题解

#### 1. **Sooke的题解（5星）**
- **关键亮点**：思路清晰，详细解释了种类并查集的概念，并通过图示和代码展示了如何维护三种关系。代码简洁且易于理解，适合初学者。
- **个人心得**：作者提到“种类并查集求的并非具体种类，而是关系”，强调了并查集的本质是维护关系而非具体类别。

```cpp
int find(int u) { return fa[u] == u ? u : fa[u] = find(fa[u]); }

void main() {
    for (int i = 1; i <= n * 3; i++) { fa[i] = i; }
    for (; m; m--) {
        int opt = read(), u = read(), v = read();
        if (u > n || v > n) { ans++; continue; }
        if (opt == 1) {
            if (find(u + n) == find(v) || find(u) == find(v + n)) { ans++; }
            else {
                fa[find(u)] = find(v);
                fa[find(u + n)] = find(v + n);
                fa[find(u + n + n)] = find(v + n + n);
            }
        } else {
            if (find(u) == find(v) || find(u) == find(v + n)) { ans++; }
            else {
                fa[find(u + n)] = find(v);
                fa[find(u + n + n)] = find(v + n);
                fa[find(u)] = find(v + n + n);
            }
        }
    }
    printf("%d\n", ans);
}
```

#### 2. **天泽龟的题解（4星）**
- **关键亮点**：引入了带权并查集的概念，通过权值维护关系，思路新颖且适用于更复杂的关系维护。代码实现较为简洁，适合有一定基础的读者。
- **个人心得**：作者提到“带权并查集的核心在于权值的传递和合并”，强调了权值在关系维护中的重要性。

```cpp
int find(int x) {
    if (x == f[x]) return x;
    int t = find(f[x]);
    d[x] = (d[x] + d[f[x]]) % 3;
    return f[x] = t;
}

void main() {
    for (int i = 1; i <= n; i++) f[i] = i, d[i] = 0;
    for (int i = 1; i <= k; i++) {
        int p, x, y; cin >> p >> x >> y;
        if (x > n || y > n) { ans++; continue; }
        if (p == 1) {
            if (find(x) == find(y) && d[x] != d[y]) ans++;
            else if (find(x) != find(y)) {
                d[f[x]] = (d[y] - d[x] + 3) % 3;
                f[f[x]] = f[y];
            }
        } else {
            if (find(x) == find(y) && (d[x] - d[y] + 3) % 3 != 1) ans++;
            else if (find(x) != find(y)) {
                d[f[x]] = (d[y] - d[x] + 4) % 3;
                f[f[x]] = f[y];
            }
        }
    }
    cout << ans << endl;
}
```

#### 3. **Strong_Jelly的题解（4星）**
- **关键亮点**：通过深度表示动物之间的关系，思路清晰且易于理解。代码实现简洁，适合初学者。
- **个人心得**：作者提到“深度对3取模的结果相等，则两结点属于同类动物”，强调了深度在关系维护中的重要性。

```cpp
int find(int x) {
    if (x == f[x]) return x;
    int t = find(f[x]);
    d[x] = (d[x] + d[f[x]]) % 3;
    return f[x] = t;
}

void main() {
    for (int i = 1; i <= n; i++) f[i] = i, d[i] = 0;
    for (int i = 1; i <= k; i++) {
        int p, x, y; cin >> p >> x >> y;
        if (x > n || y > n) { ans++; continue; }
        if (p == 1) {
            if (find(x) == find(y) && d[x] != d[y]) ans++;
            else if (find(x) != find(y)) {
                d[f[x]] = (d[y] - d[x] + 3) % 3;
                f[f[x]] = f[y];
            }
        } else {
            if (find(x) == find(y) && (d[x] - d[y] + 3) % 3 != 1) ans++;
            else if (find(x) != find(y)) {
                d[f[x]] = (d[y] - d[x] + 4) % 3;
                f[f[x]] = f[y];
            }
        }
    }
    cout << ans << endl;
}
```

### 关键思路与技巧总结

1. **种类并查集**：通过扩展并查集的大小，分别维护同类、捕食、被捕食关系，适合处理固定种类的关系。
2. **带权并查集**：通过给边赋予权值，动态维护复杂关系，适用于更灵活的场景。
3. **深度表示关系**：通过深度对3取模，表示动物之间的关系，思路简洁且易于实现。

### 推荐题目

1. **P1525 关押罪犯**：考察并查集的应用，维护对立关系。
2. **P1196 [NOI2002] 银河英雄传说**：考察并查集的路径压缩与权值维护。
3. **P2024 [NOI2001] 食物链**：与本题类似，考察复杂关系的维护。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中遇到负数取模问题，建议在取模时加上一个足够大的数（如3）以避免负数。
- **顿悟感想**：并查集的核心在于维护关系而非具体类别，理解这一点有助于更好地应用并查集解决复杂问题。

---
处理用时：63.00秒
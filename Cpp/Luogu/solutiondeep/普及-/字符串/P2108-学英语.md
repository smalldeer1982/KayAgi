# 题目信息

# 学英语

## 题目描述

为了适应紧张的大学学习生活，小 Z 发愤图强开始复习巩固英语。

由于小 Z 对数学比较有好感，他首先复习了数词。小 Z 花了一整天的时间，终于把关于基数词的知识都搞懂了。于是小 Z 非常兴奋，决定出一些题目考考已经过了英语四级、人称英语帝的小 G。考法很简单：小 Z 给出某个整数 $x$ 的英文写法，要求小 D 用阿拉伯数字写出 $x$。

小 Z 会保证以下几点：

1. $-999,999,999 \leq  x \leq 999,999,999$

2. 题目中只会用到以下这些英文单词：

`negative, zero, one, two, three, four, five, six, seven, eight, nine, ten`

`eleven, twelve, thirteen, fourteen, fifteen, sixteen, seventeen, eighteen, nineteen, twenty`

`thirty, forty, fifty, sixty, seventy, eighty, ninety, hundred, thousand, million`

3. 若 $x$ 为负数，题目中第一个单词是 `negative`，否则任何时候都不会出现 `negative` 这个词。

4. 由于小 Z 很牛 B，他不知道像 $103$ 这样的数字要写成 `one hundred and three` 而是直接写成了 `one hundred three`，就是说小 Z 的所有题目中都没有写 `and` 这个词（尽管本应该是要写的），请你谅解。

5. 除了第 4 点， 其他还是基本符合英语的语法规则的， 比如 $1500$ 他会写成 `one thousand five hundred` 而不会写成 `fifteen hundred`。

小 D 拿到题目后不屑地说了一句：水题！写个程序么好了……

但是小 D 要出去玩（此时应该已经在千里之外爽玩了） ，这个任务就交给你了。


## 说明/提示

对于 $100\%$ 的数据，$-999,999,999 ≤ x ≤ 999,999,999$。

## 样例 #1

### 输入

```
six```

### 输出

```
6```

## 样例 #2

### 输入

```
negative seven hundred twenty nine```

### 输出

```
-729```

## 样例 #3

### 输入

```
one million one hundred one```

### 输出

```
1000101```

## 样例 #4

### 输入

```
eight hundred fourteen thousand twenty two```

### 输出

```
814022```

# AI分析结果

### 综合分析与结论

本题的核心任务是将英文数字表示转换为阿拉伯数字。题解中主要采用了以下几种思路：
1. **打表法**：通过大量的 `if` 语句或 `switch` 语句，逐个匹配英文单词并累加对应的数字值。
2. **Map映射法**：使用 `map` 数据结构将英文单词映射为对应的数字值，简化了匹配过程。
3. **分段处理法**：将数字分为不同的段（如个位、千位、百万位），分别处理后再合并。

**难点**：
- 处理 `thousand` 和 `million` 时，需要将前面的数字乘以相应的倍数。
- 处理负数时，需要在最后输出时加上负号。

**最优思路**：使用 `map` 数据结构进行映射，既简化了代码，又提高了可读性和维护性。分段处理法也是一种高效的方式，尤其是在处理大数字时。

### 所选高星题解

#### 1. 作者：花千树 (5星)
**关键亮点**：
- 使用 `map` 数据结构将英文单词映射为数字，极大简化了代码。
- 代码结构清晰，逻辑简单，易于理解。
- 处理 `thousand` 和 `million` 时，通过累加和重置的方式，避免了复杂的逻辑。

**核心代码**：
```cpp
map<string, int> a;
string s;
int ans = 0, sum = 0;
bool flag = false;

int main() {
    a["one"] = 1;
    a["two"] = 2;
    // ... 其他映射
    while(cin >> s) {
        if(s == "negative") flag = true;
        else if(s != "hundred" && s != "thousand" && s != "million") ans += a[s];
        if(s == "hundred") ans *= 100;
        if(s == "thousand") sum += ans * 1000, ans = 0;
        if(s == "million") sum += ans * 1000000, ans = 0;
    }
    sum += ans;
    if(flag) sum = -sum;
    cout << sum << endl;
}
```

#### 2. 作者：Eason_AC (4星)
**关键亮点**：
- 使用 `now` 和 `ans` 两个变量分别存储当前段的值和最终结果，逻辑清晰。
- 通过逐个匹配单词并累加，处理了 `thousand` 和 `million` 的情况。

**核心代码**：
```cpp
long long num = 0, now = 0, f = 1;
while(cin >> s) {
    if(s == "negative") f = -1;
    if(s == "one") now++;
    // ... 其他匹配
    if(s == "hundred") now *= 100;
    if(s == "thousand") num += now * 1000, now = 0;
    if(s == "million") num += now * 1000000, now = 0;
}
num += now;
printf("%lld", num * f);
```

#### 3. 作者：happybob (4星)
**关键亮点**：
- 使用 `map` 进行映射，代码简洁。
- 通过 `ans` 和 `x` 两个变量分别存储最终结果和当前段的值，逻辑清晰。

**核心代码**：
```cpp
map<string, int> m;
string s;
int ans = 0, c = 0;
while(cin >> s) {
    if(s == "negative") cout << "-";
    ans += m[s];
    if(s == "hundred") ans *= 100;
    if(s == "thousand") c += ans * 1000, ans = 0;
    if(s == "million") c += ans * 1000000, ans = 0;
}
c += ans;
cout << c << endl;
```

### 最优关键思路总结
- **Map映射法**：使用 `map` 将英文单词映射为数字，简化了匹配过程，提高了代码的可读性和维护性。
- **分段处理法**：将数字分为不同的段（如个位、千位、百万位），分别处理后再合并，适用于处理大数字。

### 拓展与举一反三
- **类似题目**：可以考虑将阿拉伯数字转换为英文单词，或者处理更复杂的数字表示（如带小数点的数字）。
- **推荐题目**：
  1. [P1617 爱与愁的一千个伤心的理由](https://www.luogu.com.cn/problem/P1617)
  2. [P2108 学英语](https://www.luogu.com.cn/problem/P2108)
  3. [P1001 A+B Problem](https://www.luogu.com.cn/problem/P1001)（基础输入输出练习）

### 个人心得总结
- **调试经历**：在处理 `thousand` 和 `million` 时，容易忘记重置当前段的值，导致结果错误。通过调试发现并修正了这一问题。
- **顿悟感想**：使用 `map` 数据结构可以极大简化代码，尤其是在处理大量映射关系时，`map` 的优势非常明显。

---
处理用时：37.98秒
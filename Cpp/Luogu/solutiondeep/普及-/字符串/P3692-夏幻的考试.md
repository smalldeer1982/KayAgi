# 题目信息

# 夏幻的考试

## 题目背景

夏之幻是软件工程系的大神，学校把举办考试的任务交给她了。


## 题目描述

某大学软工专业要举办一场笔试，学生们要在机读答题卡上填写答案来进行答题。学校把机读卡识别任务交给了夏之幻，但是这套系统的需求太复杂了，她还要做自己的其他项(you)目(xi)，所以她想让你来帮忙实现一部分功能。

试卷分卷头，单选题两部分。

夏幻大神已经写好了识别程序，因此卷头和答案将直接以数字信息的形式呈现给你，你要实现下面几个功能:

需要处理T张试卷，按顺序检查下列选项。

1.检查考号的填写是否准确。

输入信息的格式:

一行，一个16位无符号二进制数id。表示考生的考号为id，正确的考号范围在十进制下是1~10000。

如果考号有错误，输出一行“Wrong ID”并结束对这张试卷的处理(剩下两个选项的数据依然要读入，但不输出任何内容)，不含引号。如果考号正确，输出一行,“ID: ”+一个整数，表示考号的十进制形式。不含引号。

无需考虑考号是否重复，只要在范围内均为正确。

2.检查试卷类型是否正确。

输入信息格式:

一行，两个整数，中间无分隔，只能是0或者1。第一个整数表示试卷类型A是否被涂黑(0表示未涂黑，1表示涂黑)，第二个整数表示试卷类型B是否涂黑。其实试卷类型可以由二进制考号的最后一位得到，0表示A卷，1表示B卷，你只需要检查考生填涂的是否正确。

如果考生将试卷类型正确填涂(填涂且只填涂了正确的那一项)，输出一行“Type Correct”，否则输出一行“Type Incorrect”，不含引号。无论试卷类型是否填涂正确，你还需要接着处理这张试卷。

3.给单选题打分。

单选题的数量n和标准答案将会在录入第一张试卷前给出。

考生答案的输入格式:

n行，每行4个整数，中间无分隔。每个整数是0或1。

按顺序分别代表A,B,C,D是否被涂黑(0表示未涂黑，1表示涂黑)。考生回答正确当且仅当该题正确答案的位置被涂黑，且错误答案的位置未被涂黑。

输出一行，一个四舍五入到小数点后1位的浮点数，表示考生的得分，满分为100分，每个题的分数相同。


## 说明/提示

对于100%的数据

1<=T<=1000

1<=n<=50

注意:

1.请在最后一个试卷处理完后也加上一个换行

2.由于win系统和linux系统换行的不同，建议不要使用scanf读入char


## 样例 #1

### 输入

```
2 5
ABCAD
0000000011111111
01
1000
0010
0100
1000
0010
1001001001001001
01
0001
1010
0111
1111
0000```

### 输出

```
ID: 255
Type Correct
40.0

Wrong ID```

## 样例 #2

### 输入

```
3 3
ABC
0000000000000000
01
1111
0001
0100
0000000000000010
10
1000
0100
0010
0000000000000011
11
0001
0000
0010
```

### 输出

```
Wrong ID

ID: 2
Type Correct
100.0

ID: 3
Type Incorrect
33.3
```

## 样例 #3

### 输入

```
5 31
ACAACCDDBBDADDCBCACCDBCAACAAAAC
0000101111000001
10
1000
0010
1000
1111
0010
0010
0001
0001
0100
0100
0001
1000
0001
0001
0010
1111
0010
1000
0010
0010
0001
0100
1111
1000
1000
0010
1000
0100
1000
1000
0010
0000010101001111
10
1000
0010
1000
1000
0010
0010
0001
0001
0100
0100
0001
1000
0001
0001
0010
0100
1000
1000
0000
0010
0001
0100
0010
1000
1000
0010
1000
1000
0000
0000
0010
0001110001100110
11
1000
0010
1000
1000
0010
0010
0001
0001
0100
0100
0001
1000
0010
0100
0010
0100
0010
0100
0010
0010
0001
0100
0010
1000
1000
0010
1000
1111
1000
1000
0010
0001001111110001
10
1010
0010
1000
1000
0010
0010
0001
0001
0100
0100
0010
1000
0001
0001
0010
0100
0010
1000
0010
0010
0001
0100
0010
1000
1000
0010
1000
1000
1000
1000
0010
0001110010000100
10
1000
0010
1000
1000
0000
0010
0001
0001
0100
0100
0001
1000
0001
0001
0001
0100
0010
1000
0010
0010
0001
0100
0010
1000
1000
0010
1000
1000
0000
1000
0001
```

### 输出

```
ID: 3009
Type Incorrect
87.1

ID: 1359
Type Incorrect
87.1

ID: 7270
Type Incorrect
87.1

ID: 5105
Type Incorrect
93.5

ID: 7300
Type Correct
87.1
```

# AI分析结果

### 综合分析与结论

该题目是一道典型的模拟题，主要考察对二进制转十进制、字符串处理、条件判断等基础操作的掌握。题解的核心思路是通过分步处理考号、试卷类型和单选题答案，最终输出相应的结果。大多数题解采用了模块化的处理方式，将不同的功能封装成函数，提高了代码的可读性和可维护性。

### 所选高星题解

#### 1. **题解作者：SLYZ_0120 (赞：43)**
- **星级：★★★★★**
- **关键亮点：**
  - **模块化设计**：将考号检查、试卷类型判断、单选题打分分别封装成函数，代码结构清晰。
  - **二进制转十进制优化**：通过循环逐位计算，避免了直接使用`pow`函数的性能开销。
  - **跨平台兼容性处理**：通过将所有`cout << endl`替换为`\n`，并避免使用`scanf`，解决了Windows和Linux换行符不兼容的问题。
- **个人心得：**
  - 作者提到在调试过程中因为未初始化`id`变量导致样例未通过，强调了初始化的重要性。
  - 通过反复调试，最终解决了跨平台兼容性问题，体现了耐心和细致的重要性。

**核心代码：**
```cpp
void typ(){
    id = 0;
    for(int i = 1;i<=16;i++){
        cin >> c;
        if(c-'0' == 1) id += pow(2,16-i);
    }
    if(id >= 1&&id<=10000) printf("ID: %d\n",id);
    else {
        printf("Wrong ID\n");
        flg = false;
    }
}
```

#### 2. **题解作者：Eason_AC2 (赞：13)**
- **星级：★★★★**
- **关键亮点：**
  - **位运算优化**：通过位运算快速计算二进制转十进制，避免了使用`pow`函数的性能开销。
  - **特判优化**：通过特判考号的前两位是否为1，快速判断考号是否合法。
  - **状态转换**：将考生答案转换为整数状态，便于与标准答案进行比较。
- **个人心得：**
  - 作者提到通过计算器验证了10000的二进制位数，强调了特判的重要性。

**核心代码：**
```cpp
for(int j = 1; j <= 16; ++j) {
    scanf("%1d", &a[i].id[j]);
    if((j == 1 || j == 2) && a[i].id[j]) flag = 1;
    else sum += a[i].id[j] * (int)pow(2, 16 - j);
}
```

#### 3. **题解作者：引领天下 (赞：12)**
- **星级：★★★★**
- **关键亮点：**
  - **简洁高效**：代码简洁，直接通过字符串处理完成所有操作，避免了复杂的函数封装。
  - **快速判断**：通过考号的最后一位快速判断试卷类型，减少了不必要的计算。
  - **分数计算优化**：通过提前计算每题分值，减少了重复计算的开销。
- **个人心得：**
  - 作者提到通过简单的条件判断处理试卷类型，体现了代码的简洁性。

**核心代码：**
```cpp
for (int i=15;i>=0;i--) kh+=(s[i]-'0')*pow(2,15-i);
if (s[0]==s[1]) s[kh&1]='0';
printf ("ID: %d\nType %s\n",kh,s[kh&1]-'0'?"Correct":"Incorrect");
```

### 最优关键思路与技巧

1. **模块化设计**：将不同功能封装成函数，提高代码的可读性和可维护性。
2. **二进制转十进制优化**：通过逐位计算或位运算，避免使用`pow`函数的性能开销。
3. **跨平台兼容性处理**：通过统一使用`\n`和`cin`，避免因换行符不同导致的兼容性问题。
4. **特判优化**：通过特判快速处理边界情况，减少不必要的计算。

### 可拓展之处

- **类似题目**：可以拓展到其他需要处理二进制、字符串匹配、条件判断的题目，如洛谷P1001、P1002、P1003等。
- **算法套路**：类似的模拟题可以通过模块化设计、特判优化、位运算等手段提高代码效率和可读性。

### 推荐题目

1. **P1001 A+B Problem**：考察基础输入输出和简单计算。
2. **P1002 过河卒**：考察动态规划和模拟。
3. **P1003 铺地毯**：考察模拟和条件判断。

### 个人心得总结

- **初始化的重要性**：在调试过程中，未初始化的变量可能导致程序无法通过样例，强调了初始化的重要性。
- **跨平台兼容性**：在处理跨平台问题时，统一使用`\n`和`cin`可以避免因换行符不同导致的兼容性问题。
- **耐心与细致**：通过反复调试和优化，最终解决了问题，体现了耐心和细致的重要性。

---
处理用时：38.28秒
# 题目信息

# [TJOI2010] 阅读理解

## 题目描述

英语老师留了 $N$ 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。

## 说明/提示

对于 $30\%$ 的数据， $1\le M\le 10^3$ 。

对于 $100\%$ 的数据，$1\le M\le 10^4$，$1\le N\le 10^3$ 。

每篇短文长度（含相邻单词之间的空格）$\le 5\times 10^3$ 字符，每个单词长度 $\le 20$ 字符。

每个测试点时限 $2$ 秒。

感谢@钟梓俊添加的一组数据。

## 样例 #1

### 输入

```
3
9 you are a good boy ha ha o yeah
13 o my god you like bleach naruto one piece and so do i
11 but i do not think you will get all the points
5
you
i
o
all
naruto
```

### 输出

```
1 2 3
2 3
1 2
3
2
```

# AI分析结果

### 综合分析与结论

本题的核心是通过高效的数据结构来统计单词在哪些短文中出现过。题解中主要采用了以下几种思路：

1. **Trie树**：通过构建Trie树来存储单词，并在每个节点上记录该单词在哪些短文中出现过。Trie树的优势在于能够快速插入和查询单词，适合处理大量字符串。
2. **STL容器（map + vector/set）**：利用`map`将单词映射到`vector`或`set`中，记录单词出现的短文编号。这种方法代码简洁，但查询效率可能不如Trie树。
3. **哈希表**：通过哈希表存储单词及其出现的短文编号，适合处理大规模数据，但需要注意哈希冲突的处理。
4. **bitset优化**：在Trie树的基础上，使用`bitset`来优化空间，减少内存占用。

### 所选高星题解

#### 1. **Ervin (5星)**
- **关键亮点**：详细介绍了Trie树的基本操作，并提供了完整的代码实现。通过`bitset`优化空间，解决了大规模数据下的内存问题。
- **个人心得**：作者提到Trie树虽然麻烦，但在处理字符串匹配问题时非常高效，尤其是当需要处理大量字符串时。
- **核心代码**：
```cpp
void insert(char *s,int x){
    int len=strlen(s),p=0;
    for(int k=0;k<len;k++){
        int ch=s[k]-'a';
        if(!trie[p][ch])
            trie[p][ch]=++cnt;
        p=trie[p][ch];
    }
    back[p][x]=1;
}
```
- **总结**：通过Trie树和`bitset`的结合，既保证了查询效率，又优化了空间复杂度。

#### 2. **Misaka_Azusa (4星)**
- **关键亮点**：使用`map<string, vector<int>>`来存储单词及其出现的短文编号，代码简洁易懂。通过桶去重，避免了重复输出。
- **核心代码**：
```cpp
map<string,vector<int> >a;
void insert(string s, int i) {
    a[s].push_back(i);
}
```
- **总结**：利用STL容器简化了代码实现，适合对代码简洁性有要求的场景。

#### 3. **enceladus (4星)**
- **关键亮点**：通过`bitset`优化Trie树的空间占用，解决了大规模数据下的内存问题。提供了详细的代码实现和优化思路。
- **核心代码**：
```cpp
bitset<1001> b[500007];
void insert(char *s, int x) {
    int p = 0;
    for (int i = 0; s[i]; i++) {
        int v = s[i] - 'a';
        if (!trie[p][v]) trie[p][v] = ++tot;
        p = trie[p][v];
    }
    b[p][x] = 1;
}
```
- **总结**：通过`bitset`优化，既保证了查询效率，又减少了内存占用，适合处理大规模数据。

### 最优关键思路与技巧

1. **Trie树 + bitset**：Trie树在处理字符串匹配问题时非常高效，而`bitset`可以大幅减少空间占用，适合处理大规模数据。
2. **STL容器简化代码**：使用`map`和`vector`可以简化代码实现，适合对代码简洁性有要求的场景。
3. **哈希表处理大规模数据**：哈希表适合处理大规模数据，但需要注意哈希冲突的处理。

### 可拓展之处

1. **AC自动机**：在处理多个模式串匹配时，AC自动机是Trie树的扩展，能够更高效地进行多模式匹配。
2. **字符串哈希**：在处理字符串匹配问题时，字符串哈希也是一种高效的解决方案，适合处理大规模数据。

### 推荐题目

1. **P3375 【模板】KMP字符串匹配**：考察字符串匹配算法，适合练习KMP算法。
2. **P3808 【模板】AC自动机（简单版）**：考察AC自动机，适合练习多模式串匹配。
3. **P3370 【模板】字符串哈希**：考察字符串哈希，适合练习哈希表的应用。

### 个人心得总结

- **调试经历**：多位作者提到在处理大规模数据时，内存占用是一个常见问题，通过`bitset`优化可以有效解决。
- **踩坑教训**：在处理重复输出时，需要注意去重操作，避免重复输出短文编号。
- **顿悟感想**：Trie树虽然实现复杂，但在处理字符串匹配问题时非常高效，尤其是当需要处理大量字符串时。

---
处理用时：40.44秒
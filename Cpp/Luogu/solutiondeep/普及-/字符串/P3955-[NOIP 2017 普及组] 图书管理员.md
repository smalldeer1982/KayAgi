# 题目信息

# [NOIP 2017 普及组] 图书管理员

## 题目背景

NOIP2017 普及组 T2

## 题目描述

图书馆中每本书都有一个图书编码，可以用于快速检索图书，这个图书编码是一个正整数。 每位借书的读者手中有一个需求码，这个需求码也是一个正整数。如果一本书的图书编码恰好以读者的需求码结尾，那么这本书就是这位读者所需要的。 小 D 刚刚当上图书馆的管理员，她知道图书馆里所有书的图书编码，她请你帮她写一个程序，对于每一位读者，求出他所需要的书中图书编码最小的那本书，如果没有他需要的书，请输出 `-1`。


## 说明/提示

**数据规模与约定**

对于 $20\%$ 的数据，$1 ≤ n ≤ 2$。

另有 $20\%$ 的数据，$q = 1$。

另有 $20\%$ 的数据，所有读者的需求码的长度均为 $1$。

另有 $20\%$ 的数据，所有的图书编码按从小到大的顺序给出。

对于 $100\%$ 的数据，$1 ≤ n ≤ 1000,1 ≤ q ≤ 1000$，所有的图书编码和需求码均不超过 $10^7$。


## 样例 #1

### 输入

```
5 5 
2123 
1123 
23 
24 
24 
2 23 
3 123 
3 124 
2 12 
2 12```

### 输出

```
23 
1123 
-1 
-1 
-1 ```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何高效地判断图书编码是否以读者的需求码结尾，并找到最小的满足条件的图书编码。大部分题解都采用了以下思路：
1. **排序优化**：先将图书编码排序，便于找到最小的满足条件的编码。
2. **取模运算**：通过取模运算（`% 10^x`）来快速判断编码的后缀是否匹配需求码。
3. **预处理**：部分题解通过预处理 `10^x` 的值，避免重复计算，提升效率。

### 所选高星题解

#### 1. **题解作者：LinkyChristian (5星)**
- **关键亮点**：
  - 使用 `pow` 函数计算 `10^x`，并通过取模运算快速判断后缀匹配。
  - 代码简洁明了，逻辑清晰，适合初学者理解。
- **核心代码**：
  ```cpp
  int tmp = pow(10,len[i]),min = 10000001;
  for(int j=1; j<=n; j++) if(book[j] % tmp == num[i] && book[j] < min) min = book[j];
  if(min != 10000001) cout<<min<<endl;
  else cout<<-1<<endl; 
  ```
- **个人心得**：通过取模运算简化了后缀匹配的判断，代码实现简洁高效。

#### 2. **题解作者：The_Best_OIer (4星)**
- **关键亮点**：
  - 预处理 `10^x` 的值，避免重复计算，提升效率。
  - 排序后直接遍历，找到第一个满足条件的编码即为最小值。
- **核心代码**：
  ```cpp
  const int mod[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000};
  for (int i = 1, j; i <= q; i++) {
      cin >> x >> y;
      for (j = 1; j <= n; j++) {
          if (a[j] % mod[x] == y) {
              break;
          }
      }
      if (j <= n) cout << a[j] << endl;
      else cout << -1 << endl;
  }
  ```
- **个人心得**：通过预处理 `10^x` 的值，避免了重复计算，提升了代码效率。

#### 3. **题解作者：Malkin_Moonlight (4星)**
- **关键亮点**：
  - 使用 `map` 和 `string.substr()` 来存储和查询后缀，思路新颖。
  - 通过自定义 `strmin` 函数处理字符串比较，确保找到最小编码。
- **核心代码**：
  ```cpp
  string strmin(string x, string y) {
      if (x.size() < y.size()) return x;
      if (y.size() < x.size()) return y;
      for (int i = 0; i < x.size(); i++) {
          if (x[i] < y[i]) return x;
          if (y[i] < x[i]) return y;
      }
      return x;
  }
  ```
- **个人心得**：通过字符串处理的方式，避免了数值运算，适合对字符串操作熟悉的读者。

### 最优关键思路与技巧
1. **取模运算**：通过 `% 10^x` 快速判断编码的后缀是否匹配需求码，是本题的核心技巧。
2. **排序优化**：先对图书编码排序，便于快速找到最小的满足条件的编码。
3. **预处理**：预处理 `10^x` 的值，避免重复计算，提升效率。

### 可拓展之处
- **类似问题**：可以扩展到其他需要判断字符串或数字后缀的问题，如电话号码匹配、身份证号校验等。
- **算法优化**：可以考虑使用更高效的数据结构（如字典树）来处理大规模数据。

### 推荐相似题目
1. **P3375 【模板】KMP字符串匹配**：考察字符串匹配算法，与本题的后缀匹配类似。
2. **P1042 【模板】快速幂**：考察快速幂算法，与本题中 `10^x` 的计算相关。
3. **P1177 【模板】快速排序**：考察排序算法，与本题中图书编码的排序相关。

### 个人心得总结
- **调试经历**：部分题解提到在处理字符串比较时容易出错，建议使用自定义比较函数确保正确性。
- **踩坑教训**：使用 `pow` 函数时需要注意其返回值类型，避免精度问题。
- **顿悟感想**：通过取模运算可以简化后缀匹配的判断，是本题的核心技巧。

---
处理用时：38.15秒
# 题目信息

# 「UOI-R1」磁铁

## 题目描述

有两串磁铁 $a,b$，均可以看作由一些小写或大写字符或数字组成的。

你可以对磁铁 $a$ 进行**无限次**操作，每次操作可以是以下两个中的一个：

1. 将前若干个字符删除，例如删除 $\texttt{91987}$ 的前 $3$ 个字符后字符串将会变成 $\texttt{87}$。
2. 将后若干个字符移至前面去，例如将 $\texttt{91987}$ 的后 $3$ 个字符移至前面去后字符串会变成 $\texttt{98791}$。

问经过操作后，能否使磁铁 $a$ 和 $b$ 相等，$a$ 和 $b$ 相等当且仅当 $a$ 和 $b$ 长度相等且每个字符都相同。

为了防止 ````不可以，总司令```` 的情况发生，你需要回答多次。

## 说明/提示

**【样例解释 #1】** 

$$
\texttt{12341234}\\ \to \texttt{1234}\\ = \texttt{1234}
$$

**【样例解释 #2】** 

$$
\texttt{6012739810910020338452}\\
\to \texttt{2601273981091002033845}\\
\to \texttt{601273981091002033845}\\
\to \texttt{384560127398109100203}\\
\to \texttt{4560127398109100203}\\
\to \texttt{0345601273981091002}\\
\to \texttt{345601273981091002}\\
\to \texttt{091002345601273981}\\
\to \texttt{2345601273981}\\
\to \texttt{3981234560127}\\
\to \texttt{81234560127}\\
\to \texttt{01278123456}\\
\to \texttt{78123456}\\
\to \texttt{12345678} \\
=\texttt{12345678}
$$

**【数据范围】**

以下记 $ \left| a \right|$ 表示每组数据磁铁 $a$ 的长度，$\left| b \right|$ 表示每组数据磁铁 $b$ 的长度。

对于 $20\%$ 的数据，保证 $\left| a \right| = 1$。

对于另外 $20\%$ 的数据，保证 $\left| b \right| = 1$。

对于 $100\%$，保证 $1 \leq \left| a \right|, \left| b \right| \leq 1000$，$1 \leq t \leq 10$。

保证 $a$ 和 $b$ 非空且只包含大小写英文字母或数字。



## 样例 #1

### 输入

```
1
12341234
1234```

### 输出

```
Y```

## 样例 #2

### 输入

```
1
6012739810910020338452
12345678```

### 输出

```
Y```

## 样例 #3

### 输入

```
1
123456789
465```

### 输出

```
N```

## 样例 #4

### 输入

```
见文件附件的 magnets4.in```

### 输出

```
见文件附件的 magnets4.ans```

# AI分析结果

### 综合分析与结论

本题的核心在于通过两种操作（删除前若干个字符、将后若干个字符移至前面）来判断字符串 $a$ 是否能变为字符串 $b$。大多数题解都采用了“断环为链”的思路，即将 $a$ 复制一份拼接在自身后面，从而模拟环的操作。然后通过枚举起点，检查 $b$ 是否是 $a$ 的子序列。这种方法的时间复杂度为 $O(n^2)$，在题目给定的数据范围内是可以接受的。

### 所选高星题解

#### 1. 作者：cosf (★★★★☆)
**关键亮点**：
- 通过将字符串 $a$ 看作一个环，直观地解释了操作的含义。
- 使用“断环为链”的方法，将问题转化为子序列匹配问题。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
a = a + a;
b = " " + b;
int ys = 0;
for (int i = 0; i < alen; i++) {
    string c = a.substr(i, alen);
    int cur = 0;
    for (int j = 0; j < alen; j++) {
        if (c[j] == b[cur + 1]) {
            cur++;
        }
        if (cur == blen) {
            ys = 1;
            break;
        }
    }
    if (ys) break;
}
```
**实现思想**：将 $a$ 复制一份拼接在自身后面，枚举每个可能的起点，检查 $b$ 是否是 $a$ 的子序列。

#### 2. 作者：Shanganze (★★★★☆)
**关键亮点**：
- 同样采用“断环为链”的思路，代码实现简洁。
- 通过双指针进行子序列匹配，逻辑清晰。

**核心代码**：
```cpp
a += a;
for (int q = 0; q < n / 2; q++) {
    int l = 0;
    for (int w = q; w < q + n / 2; w++) {
        if (b[l] == a[w]) {
            l++;
        }
    }
    if (l == m) {
        p = 1;
        break;
    }
}
```
**实现思想**：将 $a$ 复制一份拼接在自身后面，枚举每个可能的起点，使用双指针检查 $b$ 是否是 $a$ 的子序列。

#### 3. 作者：yeshubo_qwq (★★★★☆)
**关键亮点**：
- 通过双指针进行子序列匹配，代码简洁。
- 对边界条件进行了处理，确保代码的鲁棒性。

**核心代码**：
```cpp
n = s.size(), s = " " + s + s;
m = t.size(), t = " " + t;
for (i = 1; i <= n; i++) {
    l = i, r = 1, sum = 0;
    while (l <= i + n - 1 && r <= m)
        if (s[l] == t[r]) l++, r++, sum++;
        else l++;
    if (sum == m) break;
}
```
**实现思想**：将 $a$ 复制一份拼接在自身后面，枚举每个可能的起点，使用双指针检查 $b$ 是否是 $a$ 的子序列。

### 最优关键思路或技巧
- **断环为链**：将字符串 $a$ 复制一份拼接在自身后面，从而模拟环的操作，简化问题。
- **子序列匹配**：通过枚举起点，使用双指针或朴素匹配算法检查 $b$ 是否是 $a$ 的子序列。

### 可拓展之处
- **环上问题**：类似的问题可以扩展到环上的其他操作，如旋转、翻转等。
- **子序列匹配**：可以进一步优化子序列匹配的算法，如使用KMP算法等。

### 推荐相似题目
1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P1042 字符串的展开](https://www.luogu.com.cn/problem/P1042)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得总结
- **调试经历**：在处理环上问题时，通过“断环为链”的方法可以大大简化问题，避免复杂的边界条件处理。
- **踩坑教训**：在子序列匹配时，要注意边界条件的处理，避免数组越界等问题。
- **顿悟感想**：将问题转化为已知的经典问题（如子序列匹配）是解决复杂问题的有效方法。

---
处理用时：32.37秒
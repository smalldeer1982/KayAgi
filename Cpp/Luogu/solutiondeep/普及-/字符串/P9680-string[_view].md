# 题目信息

# string[_view]

## 题目背景

C++ 的 string 类是一个功能强大的字符串类，然而由于其字符串算法和内存管理绑定的机制，所以在处理 C 风格字符串时效率低下。

为了解决这个问题，C++17 标准引入了 string\_view 类型，将内存管理和字符串算法分离，从而更好地适配了 C 风格字符串的处理。

## 题目描述

你需要模拟一个简单的 C++ 程序，该程序的每一行必然为如下两种形式之一：

- `string <variable-name>(<initializer>);`
- `string_view <variable-name>(<initializer>);`

其中 `variable-name` 为声明的变量名（保证之前未出现过，且长度不超过 $10$），`initializer` 为初始化该变量的内容，可以是：

- 字符串字面量，即用双引号引起的字符串（形如 `"abc"`）；
- 之前出现过的变量名 `source`，此时应将 `source` 对应的字符串赋给 `variable-name`。

具体而言，将任意一个字符串 $s$ 赋给 string 类型会进行 $|s|$ 次字符拷贝，而赋给 string\_view 类型不会拷贝字符。其中 $|s|$ 为字符串 $s$ 的长度。

你需要计算出该程序中字符拷贝的总次数。

## 说明/提示

  对于每组数据，保证代码长度均不超过 $10^4$（不包括换行符）。

保证字符串字面量（除去两侧引号）和变量名中只有拉丁字母，且给定的代码严格满足题目要求。

### 子任务

|  #   |            特殊性质            | 分值 |
| :--: | :----------------------------: | :--: |
|  0   |              样例              | 0  |
|  1   | 所有变量均为 string\_view 类型 | 10 |
|  2   |    只使用字符串字面量初始化    | 20 |
|  3   |               -                | 70 |

---

好消息：GCC 9.3.0 支持 string_view。

坏消息：NOI 不开 C++17。

## 样例 #1

### 输入

```
6
string a("cxyakioi");
string_view b("cxyakapio");
string c(b);
string_view d(a);
string_view cxyakioi(c);
string cxyakapio(d);```

### 输出

```
25```

# AI分析结果

### 综合分析与结论

本题的核心在于模拟C++中`string`和`string_view`的初始化过程，并计算字符拷贝的总次数。各题解普遍采用`map`来存储变量名及其对应的字符串长度，通过解析输入字符串来确定变量的类型和初始化方式，最终累加`string`类型的字符拷贝次数。

大多数题解的思路相似，但在代码实现和细节处理上有所不同。部分题解在字符串解析时使用了`substr`和`find`等函数，代码简洁且可读性较高；而另一些题解则通过逐个字符遍历来解析字符串，代码较为冗长。

### 所选高星题解

#### 题解1：作者：Light_az (赞：8)
- **星级**：★★★★★
- **关键亮点**：代码简洁，使用`substr`和`find`函数高效解析字符串，逻辑清晰，易于理解。
- **核心实现思想**：通过`find`函数定位括号和引号的位置，使用`substr`提取变量名和初始化内容，根据类型决定是否累加字符拷贝次数。
- **核心代码片段**：
  ```cpp
  void f(){
      ll i;
      for(i=0;i<=len-1;i++){
          if(s[i]=='(') break;
          s2+=s[i];
      }
      i++;
      for(;i<=len-1;i++){
          if((s[i]<='z'&&s[i]>='a')||(s[i]<='Z'&&s[i]>='A')) s3+=s[i];
          if(s[i]=='"') k=1;
      } 
      return ;
  }
  ```

#### 题解2：作者：zhang_Jimmy (赞：6)
- **星级**：★★★★
- **关键亮点**：思路清晰，代码结构合理，使用`map`存储变量名和字符串长度，处理初始化内容时逻辑严谨。
- **核心实现思想**：通过`find`和`substr`提取变量名和初始化内容，根据类型决定是否累加字符拷贝次数。
- **核心代码片段**：
  ```cpp
  int t, ans;
  string s, s2;
  map<string, int> mp; 
  int main(){
      cin >> t;
      while(t --){
          cin >> s >> s2; 
          string st;
          while(s2[0] != '('){
              st += s2[0];
              s2.erase(0, 1);
          }
          s2.erase(0, 1);
          s2.pop_back();
          s2.pop_back();
          int len;
          if(s2[0] == '\"')
              len = s2.size() - 2;
          else
              len = mp[s2];
          mp[st] = len;
          if(s == "string")
              ans += len;
      } 
      cout << ans;
      return 0;
  }
  ```

#### 题解3：作者：Pink_Cut_Tree (赞：4)
- **星级**：★★★★
- **关键亮点**：代码简洁，使用`substr`和`find`函数高效解析字符串，逻辑清晰，易于理解。
- **核心实现思想**：通过`find`函数定位括号和引号的位置，使用`substr`提取变量名和初始化内容，根据类型决定是否累加字符拷贝次数。
- **核心代码片段**：
  ```cpp
  int n, ans = 0, ni = 1;
  cin >> n;
  for(int i = 1; i <= n; i++){
      string s, ss;
      cin >> s >> ss;
      if(s == "string"){
          int i = 0;
          string kao = "";
          while(ss[i] != '('){
              kao += ss[i];
              i++;
          }
          i++;
          string nei = "", bian = "";
          if(ss[i] == '"'){
              i++;
              while(ss[i] != '"'){
                  nei += ss[i];
                  ans++;
                  i++;
              }
              b[ni] = kao;
              ne[ni] = nei;
              ni++;
          }
          else{
              while(ss[i] != ')'){
                  bian += ss[i];
                  i++;
              }
              for(int i = 1; i <= ni; i++){
                  if(b[i] == bian){
                      ans += ne[i].size();
                      b[ni] = kao;
                      ne[ni] = ne[i];
                      break;
                  }
              }
              ni++;
          }
      }
  }
  ```

### 最优关键思路与技巧

1. **使用`map`存储变量名和字符串长度**：避免重复计算，提高效率。
2. **高效字符串解析**：使用`find`和`substr`函数定位和提取字符串中的关键部分，减少代码复杂度。
3. **类型判断与累加**：根据变量类型决定是否累加字符拷贝次数，逻辑清晰。

### 可拓展之处

- **类似题目**：可以拓展到其他需要解析字符串并模拟操作的题目，如解析JSON、XML等。
- **优化思路**：可以考虑使用正则表达式进一步简化字符串解析过程。

### 推荐题目

1. **P1003 铺地毯**：考察字符串解析与模拟操作。
2. **P1042 乒乓球**：涉及字符串处理与模拟比赛过程。
3. **P1055 ISBN号码**：需要解析字符串并进行校验计算。

### 个人心得摘录

- **调试经历**：部分题解提到在处理字符串时遇到括号和引号的位置问题，通过`find`和`substr`函数解决了这一问题。
- **踩坑教训**：在处理变量名和初始化内容时，需要注意字符串的边界条件，避免越界访问。
- **顿悟感想**：通过使用`map`存储变量名和字符串长度，大大简化了代码逻辑，提高了代码的可读性和效率。

---
处理用时：45.23秒
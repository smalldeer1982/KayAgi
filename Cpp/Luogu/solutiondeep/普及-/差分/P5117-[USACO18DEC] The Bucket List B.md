# 题目信息

# [USACO18DEC] The Bucket List B

## 题目描述

Farmer John 正在考虑改变他给奶牛挤奶的时候分配牛奶桶的方式。他认为这最终能使得他使用数量更少的桶，然而他不清楚具体是多少。请帮助他！

Farmer John 有 $N$ 头奶牛（$1\le N\le 100$），方便起见编号为 $1\dots N$。 第 $i$ 头奶牛需要从时间 $s_i$ 到时间 $t_i$ 之间挤奶，并且挤奶过程中需要用到 $b_i$ 个桶。于是多头奶牛可能在同一时刻都在挤奶；如果这样，他们不能使用相同的桶。也就是说，一个在第 $i$ 头奶牛挤奶时用的桶不可以被任何在时间 $s_i$ 到时间 $t_i$ 之间挤奶的其他奶牛使用。当然，这个桶在这段时间之外可以被其他奶牛所使用。为了简化他的工作，FJ 保证在任一时刻，至多只有一头奶牛开始或是结束挤奶（也就是说，所有的 $s_i$ 和 $t_i$ 各不相同）。

FJ 有一个储藏室，里面有依次编号为 $1$、$2$、$3$、……的桶。在他的挤奶策略中，当某一头奶牛（比如说，奶牛 $i$）开始挤奶（在时间 $s_i$），FJ 就跑到储藏室取出编号最小的 $b_i$ 个桶分配给第i头奶牛用来挤奶。

请求出 FJ 需要在储藏室中存放多少个桶才能使得他能够顺利地给所有奶牛挤奶。


## 说明/提示

在这个例子中，FJ 需要 $4$ 个桶：他用桶 $1$ 和桶 $2$ 来给奶牛 $3$ 挤奶（从时间 $2$ 开始）。他用桶 $3$ 给奶牛 $1$ 挤奶（从时间 $4$ 开始）。当奶牛 $2$ 在时间 $8$ 开始挤奶时，桶 $1$ 和桶 $2$ 可以再次利用，然而桶 $3$ 不可以，所以他会使用桶 $1$、桶 $2$ 和桶 $4$。

## 样例 #1

### 输入

```
3
4 10 1
8 13 3
2 6 2```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
本题核心在于求时间轴上的最大重叠桶数。各题解主要采用差分数组、事件排序、暴力模拟等方法。其中**差分数组**是最优解法，时间复杂度低至O(n)，代码简洁高效。事件排序法（类似扫描线）同样高效，而暴力模拟在小数据范围内可行但效率较低。

### 高星题解推荐
#### 1. _Qer（★★★★★）
**关键亮点**：  
- 经典差分数组应用，代码简洁高效  
- 正确处理时间区间端点（s-1和t的差分标记）  
- 时间复杂度O(n + T)，空间优化明显  

**核心代码**：  
```cpp
int p[1010]; // 差分数组
for (int i = 1; i <= n; ++i) {
    scanf("%d%d%d", &s, &t, &b);
    p[s - 1] += b, p[t] -= b; // 差分标记
}
int ans = 0, h = 0;
for (int i = 0; i <= 1001; ++i) {
    ans = max(ans, h);
    h += p[i]; // 前缀和
}
```

#### 2. djh123（差分版本，★★★★★）
**关键亮点**：  
- 差分思路清晰，边界处理明确（t+1）  
- 代码简洁，直接求最大值  

**核心代码**：  
```cpp
int f[10500];
for (int i = 1; i <= n; ++i) {
    scanf("%d%d%d", &l, &r, &x);
    f[l] += x;
    f[r + 1] -= x; // 边界处理
}
int ans = 0, now = 0;
for (int i = 1; i <= 1000; ++i) {
    now += f[i];
    ans = max(ans, now);
}
```

#### 3. lytqwq（★★★★☆）
**关键亮点**：  
- 事件排序法，模拟时间轴变化  
- 结构体存储事件，逻辑直观  

**核心代码**：  
```cpp
struct Event { int time, delta; };
vector<Event> events;
// 添加事件
events.push_back({s, b});
events.push_back({t, -b});
sort(events.begin(), events.end());
int now = 0, ans = 0;
for (auto &e : events) {
    now += e.delta;
    ans = max(ans, now);
}
```

### 最优思路总结
**差分数组法**：  
1. 对每个区间`[s, t]`，在差分数组的`s`处加`b`，`t+1`处减`b`。  
2. 计算前缀和，遍历过程中维护最大值。  
**关键点**：将区间操作转换为两点标记，避免逐个时间点处理。

### 拓展与相似题目
1. **P3406 海底高铁**（差分处理区间覆盖）  
2. **P3667 [USACO17OPEN]Bovine Genomics G**（前缀和与区间统计）  
3. **P1719 最大加权矩形**（二维前缀和与最值问题）

### 个人心得摘录
- _Qer：差分法优于暴力，边界处理需谨慎（如`s-1`与`t`）。  
- yubing_lml：模拟法虽低效但易理解，适合小数据。  
- djh123：直接暴力在数据弱时可行，但差分更普适。

---
处理用时：260.56秒
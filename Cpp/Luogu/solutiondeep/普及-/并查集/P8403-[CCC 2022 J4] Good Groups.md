# 题目信息

# [CCC 2022 J4] Good Groups

## 题目背景

请注意：这道题是 [CCO 2022 S2  Good Groups](https://www.luogu.com.cn/problem/P8396) 的弱化版

管理备注：似乎没有弱化

## 题目描述

一个班级会被分成 $g$ 个组，每个组有三个人，这种分组方式可能会违反两种规定：

1. 一些学生必须在同一小组；
2. 一些学生必须不在同一小组。

现在校长找到了你，问学生一共违反了多少个规定。

## 说明/提示

### 样例2解释：

1. $\rm A$ 和 $\rm B$ 必须在同一组，这一点违反了。
2. $\rm G$ 和 $\rm L$ 必须在同一组，这一点违反了。
3. $\rm J$ 和 $\rm K$ 必须在同一组，这一点没有违反。
4. $\rm D$ 和 $\rm F$ 必须不在同一组，这一点违反了。
5. $\rm D$ 和 $\rm G$ 必须不在同一组，这一点没有被违反。

以上 $5$ 条共违反 $3$ 条，所以输出 $3$。

对于 $25\%$ 的数据：$1\le g\le 50 , 1\le x\le 50,y=0$

对于另外 $60\%$ 的数据：$1\le g\le 50 , 1\le x\le 50,1\le
 y\le 50$
 
对于 $100\%$ 的数据：$1\le g\le 10^5,1\le x\le 10^5,1\le y\le 10^5$

## 样例 #1

### 输入

```
1
ELODIE CHI
0
2
DWAYNE BEN ANJALI
CHI FRANCOIS ELODIE```

### 输出

```
0```

## 样例 #2

### 输入

```
3
A B
G L
J K
2
D F
D G
4
A C G
B D F
E H I
J K L```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这几道题解主要围绕如何处理学生分组违反规定的计数问题，难点在于处理字符串形式的学生名字以及优化算法以避免超时。各题解思路和方法各有不同：
 - **LYqwq的题解**：使用并查集记录学生分组情况，针对学生名字为字符串的问题，先尝试用`map`转化为数字但超时，后采用BKDR哈希将字符串转为数字，成功通过题目。
 - **Dream_weavers的题解**：根据分组构建无向图，用`map`处理字符串，判断规定是否满足时直接在图中查询边的存在与否，但时间和空间复杂度较高，需开O2优化。
 - **yeshubo_qwq的题解**：简单模拟思路，读入规定和小组后，用`map`将学生名字映射到小组编号，最后根据小组编号统计不符合规定的数量。
 - **GI录像机的题解**：将字符串唯一映射成整数，把规定存到对应学生的`vector`中，通过枚举每个分组中与学生有关的规定进行判断。

综合来看，LYqwq的题解在思路清晰程度、算法优化和代码实现上表现较好，Dream_weavers的题解虽然思路易懂但复杂度高，yeshubo_qwq的题解较为基础简单，GI录像机的题解代码稍显复杂。

### 所选的题解
 - **LYqwq的题解**：★★★★
    - **关键亮点**：巧妙运用并查集解决分组问题，通过尝试多种方法解决字符串处理难题，最终采用BKDR哈希成功优化代码通过题目。
    - **个人心得**：尝试用`map`转化字符串下标超时，多种哈希方法WA，最终尝试BKDR哈希并调整参数成功AC。
    - **核心代码片段**：
```cpp
// 字符串哈希
int hs(string s){
    unsigned int res=0;
    for(int i=0; i<s.size(); i++)
        res=res*63+s[i]; // BKDR 哈希
    return res%(int)1e7;
    // res需要作为数组下标，为了防止哈希冲突，将数组开到了 1e7
}
int main(){
    scanf("%d",&x); // 约束 1 个数
    for(int i=1; i<=x; i++) cin >> n1[i][0] >> n1[i][1];
    scanf("%d",&y); // 约束 2 个数
    for(int i=1; i<=y; i++) cin >> n2[i][0] >> n2[i][1];
    scanf("%d",&g); // 组数
    for(int i=1; i<=g; i++){
        cin >> a >> b >> c; // a,b,c 在同一组
        s.merge(hs(a),hs(b)); // 将其合并
        s.merge(hs(a),hs(c));
    }
    for(int i=1; i<=x; i++) // 判断是否违反约束 1
        if(s.find(hs(n1[i][0]))!=s.find(hs(n1[i][1]))) ans++;
    for(int i=1; i<=y; i++) // 同上，约束 2
        if(s.find(hs(n2[i][0]))==s.find(hs(n2[i][1]))) ans++;
    printf("%d\n",ans);
    return 0;
}
```
核心实现思想：先通过`hs`函数对字符串进行BKDR哈希得到数字下标，利用并查集`set`的`merge`函数将同组学生合并，最后遍历两种约束条件，通过`find`函数判断是否违反规定并计数。

### 最优关键思路或技巧
 - **数据结构选择**：并查集适合处理分组和判断元素是否属于同一集合的问题，能高效地合并和查询操作。
 - **字符串处理**：在处理字符串时，哈希函数能将字符串高效地映射为数字，相比`map`在某些情况下能提高效率，但要注意选择合适的哈希函数和参数以减少冲突。

### 可拓展思路
此类题目属于集合关系判断与计数问题，类似套路包括使用合适的数据结构（如并查集、图）来表示题目中的关系，以及高效处理非数字类型数据（如字符串）。同类型题可能会改变约束条件或分组规则，如分组人数变化、增加更多类型的约束等。

### 相似知识点洛谷题目
 - [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)：典型的并查集应用，判断亲戚关系。
 - [P1197 星球大战](https://www.luogu.com.cn/problem/P1197)：结合并查集与图的删除操作，考察对并查集的灵活运用。
 - [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)：并查集模板题，用于巩固并查集的基本操作。 

---
处理用时：28.24秒
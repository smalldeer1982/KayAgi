# 题目信息

# 迷宫寻路

## 题目描述

机器猫被困在一个矩形迷宫里。

迷宫可以视为一个 $n\times m$ 矩阵，每个位置要么是空地，要么是墙。机器猫只能从一个空地走到其上、下、左、右的空地。

机器猫初始时位于 $(1, 1)$ 的位置，问能否走到 $(n, m)$ 位置。


## 说明/提示

#### 样例解释

路线如下：$(1,1)\to (2,1) \to (3,1) \to (3,2)\to (3,3) \to (2, 3) \to (2, 4) \to (2, 5) \to (3, 5)$

#### 数据规模与约定 

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 100$，且 $(1,1)$ 和 $(n, m)$ 均为空地。

## 样例 #1

### 输入

```
3 5
.##.#
.#...
...#.```

### 输出

```
Yes```

# AI分析结果



### 综合分析与结论
本题本质是图的连通性问题，两种解法（DFS/BFS）均能正确解决。核心难点在于正确处理访问标记与边界条件。BFS 因天然按最短路径层序扩展，在平均效率上优于 DFS。对于 100x100 的迷宫规模，两种算法均可在合理时间内完成。

---

### 高分题解与评分

#### 题解1：BFS（ShanCreeperPro） ★★★★★
**关键亮点**：  
- 准确描述 BFS 层序扩展特性，强调队列的先进先出机制  
- 明确处理非法坐标（越界、障碍物）的逻辑优先级  
- 指出 BFS 天然适合求解最短路径类问题，暗示算法拓展性  

**代码核心思想**：
```cpp
bool bfs() {
    queue<pair<int, int>> q;
    q.push({0, 0});
    vis[0][0] = true;
    
    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();
        if (x == n-1 && y == m-1) return true;
        
        for (int i = 0; i < 4; ++i) {
            int nx = x + dir[i][0], ny = y + dir[i][1];
            if (nx>=0 && nx<n && ny>=0 && ny<m && !vis[nx][ny] && maze[nx][ny]=='.') {
                vis[nx][ny] = true;
                q.push({nx, ny});
            }
        }
    }
    return false;
}
```
**实现要点**：提前标记访问状态避免重复入队，方向数组简化代码，坐标转换为 0-based 索引。

#### 题解2：DFS（ShanCreeperPro） ★★★★☆  
**关键亮点**：  
- 清晰描述回溯算法核心逻辑（碰壁回退）  
- 强调剪枝的重要性（访问标记防止无限递归）  
- 代码框架可轻松改造为记录路径版本  

**潜在优化点**：未提及栈溢出风险（1e4 层递归在部分环境可能溢出），可建议迭代式 DFS。

---

### 最优技巧总结
1. **方向数组**：`dir[4][2] = {{-1,0}, {1,0}, {0,-1}, {0,1}}` 统一处理四个方向  
2. **访问标记策略**：BFS 在入队时立即标记，DFS 在递归前标记，避免状态重复访问  
3. **坐标转换**：将题目中的 1-based 输入转换为 0-based 索引，简化边界判断  

---

### 拓展题型
1. **多层迷宫**：P1825 [分层 BFS，带状态转移]  
2. **动态障碍**：P1941 [结合时间维度进行状态扩展]  
3. **多终点最短路径**：P1395 [反向 BFS 预处理距离]  

---

### 相似题目推荐
1. P1443 马的遍历（BFS 基础模板）  
2. P1162 填涂颜色（BFS 连通块扩展）  
3. P1135 奇怪的电梯（抽象状态空间搜索）

---
处理用时：53.57秒
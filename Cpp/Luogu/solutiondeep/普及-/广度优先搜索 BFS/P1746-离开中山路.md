# 题目信息

# 离开中山路

## 题目背景

《爱与愁的故事第三弹·shopping》最终章。


## 题目描述

爱与愁大神买完东西后，打算坐车离开中山路。现在爱与愁大神在 $x_1,y_1$ 处，车站在 $x_2,y_2$ 处。现在给出一个 $n \times n(n \le 1000)$ 的地图，$0$ 表示马路，$1$ 表示店铺（不能从店铺穿过），爱与愁大神只能垂直或水平着在马路上行进。爱与愁大神为了节省时间，他要求最短到达目的地距离（每两个相邻坐标间距离为 $1$）。你能帮他解决吗？


## 说明/提示


对于 $20\%$ 数据，满足 $1\leq n \le 100$。

对于 $100\%$ 数据，满足 $1\leq n \le 1000$。

## 样例 #1

### 输入

```
3
001
101
100
1 1 3 3```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
本题为标准BFS求最短路问题，各题解核心思路均为广度优先搜索。区别主要体现在队列实现方式（STL队列/手工队列）、空间优化（步数存储方式）、算法拓展（双向BFS/A*）等方面。最优解为常规BFS，时间复杂度O(n²)可满足n≤1000的要求。

### 高星题解推荐

#### 1. Cult_style（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 完整注释+清晰代码结构，完美体现BFS模板  
- 使用方向数组实现四向扩展，代码简洁  
- 通过vis数组同时记录步数，逻辑清晰  
- 处理起点步数标记为1的细节说明到位  

**核心代码**：
```cpp
void bfs(int x,int y){
    vis[x][y] = 1; // 标记起点步数为1
    q.push((node){x,y});
    while(q.size()){
        int xx = q.front().x, yy = q.front().y;
        q.pop();
        for(int i=0;i<4;i++){
            int nx=xx+h[i], ny=yy+s[i];
            if(check(nx,ny)){
                vis[nx][ny] = vis[xx][yy] + 1;
                q.push((node){nx,ny});
            }
        }
    }
}
```

#### 2. RenaMoe（⭐⭐⭐⭐）
**关键亮点**：  
- 手工封装队列类，避免STL性能损耗  
- 使用ans数组同时记录访问状态和步数  
- 通过namespace组织代码，结构规范  

**调试经验**：  
> "数组开1001会导致RE，实测需1002" —— 强调测试边界数据的重要性

#### 3. 李若谷（⭐⭐⭐⭐）
**关键技巧**：  
- 双向BFS实现，理论时间减半  
- 使用字符标记路径来源（'2'起点/'3'终点）  
- 相遇时合并两路径步数  

**核心思想**：
```cpp
if(s[xx][yy] != q[st].f) { // 相遇不同标记点
    printf("%d\n", q[st].d + d + 1);
    return;
}
```

### 关键思路总结
1. **BFS标准模板**：队列+四向扩展+访问标记
2. **步数记录优化**：用二维数组同时记录访问状态与步数
3. **输入处理技巧**：字符串读入处理无空格数字矩阵
4. **剪枝优化**：到达终点立即返回，避免无用扩展

### 同类题目推荐
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - BFS连通块
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443) - 特殊移动规则BFS  
3. [P1162 填色游戏](https://www.luogu.com.cn/problem/P1162) - BFS边界处理

### 心得体会摘录
1. **数组越界教训**：  
   "开1001数组RE，1002才能AC" —— 强调预留安全空间  
2. **输入格式陷阱**：  
   "用%c读入会出错，必须用字符串处理"  
3. **算法选择思考**：  
   "A*在本题反而更慢，常规BFS足够" —— 避免过度设计  
4. **调试技巧**：  
   "优先队列实现时，必须同时比较步数与启发值" —— A*实现细节

---
处理用时：60.11秒
# 题目信息

# 回家

## 题目描述

[](https://paste.ubuntu.com/p/DSg5bzrrjs/)

小 H 在一个划分成了 $n \times m$ 个方格的长方形封锁线上。 每次他能向上下左右四个方向移动一格（当然小 H 不可以静止不动）， 但不能离开封锁线，否则就被打死了。 刚开始时他有满血 $6$ 点，每移动一格他要消耗 $1$ 点血量。一旦小 H 的血量降到 $0$， 他将死去。 他可以沿路通过拾取鼠标（什么鬼。。。）来补满血量。只要他走到有鼠标的格子，他不需要任何时间即可拾取。格子上的鼠标可以瞬间补满，所以每次经过这个格子都有鼠标。就算到了某个有鼠标的格子才死去， 他也不能通过拾取鼠标补满 HP。 即使在家门口死去， 他也不能算完成任务回到家中。

地图上有五种格子：

`0`：障碍物。

`1`：空地， 小 H 可以自由行走。

`2`：小 H 出发点， 也是一片空地。

`3`：小 H 的家。

`4`：有鼠标在上面的空地。

小 H 能否安全回家？如果能， 最短需要多长时间呢？


## 说明/提示

对于所有数据，$1 \le n,m \le 9$。

2021.9.2 增添一组 hack 数据 by @囧仙

## 样例 #1

### 输入

```
3 3
2 1 1
1 1 0
1 1 3```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
本题核心是通过状态扩展的搜索算法解决迷宫最短路径问题，需处理血量限制与重复路径优化。关键难点在于：**如何避免无效重复路径**（尤其涉及血量补充时）和**正确处理血量耗尽时机**。最优解法为 BFS + 三维状态判重（坐标+剩余血量），确保每次状态扩展时血量严格优于历史记录。

---

### 高分题解推荐

#### 1. 作者：囧仙（5星）
**关键亮点**  
- 使用三元组 `(x,y,hp)` 记录状态，通过 `V[nx][ny][nh]` 判重，保证只保留最优血量路径。
- 代码简洁高效，时间复杂度严格 O(nmh)，完美处理 hack 数据。
- 作为出题人提供官方解法，逻辑严谨无冗余。

**核心代码**  
```cpp
queue <Node> Q;
while(!Q.empty()){
    int x,y,t,h; tie(x,y,t,h)=Q.front(); Q.pop();
    up(0,3,d){
        int nx=x+D[d][0],ny=y+D[d][1],nt=t+1,nh=h-1;
        if(W[nx][ny]==0||nh==0) continue;
        if(W[nx][ny]==3) printf("%d\n",nt),exit(0);
        if(W[nx][ny]==4) nh=6;
        if(V[nx][ny][nh]) continue;
        Q.push({nx,ny,nt,nh}),V[nx][ny][nh]=true;
    }
}
```
**实现思想**：每次扩展时更新血量，若当前状态（坐标+血量）未被访问过才入队，保证每个状态只处理一次。

---

#### 2. 作者：BurningEnderDragon（5星）
**关键亮点**  
- 引入贪心思想，用 `visit[x][y]` 记录到达该点的最大血量，避免低血量重复访问。
- 结合具体数据样例解释状态判重的必要性，深入浅出。
- 处理鼠标格子时直接限制其仅访问一次（因血量必满）。

**核心代码**  
```cpp
struct Place { int x,y,step,HP; };
void BFS() {
    while(!que.empty()) {
        Place q = que.front();
        if (q.HP > 1) {
            for (方向扩展) {
                if (新坐标合法) {
                    int new_hp = (格子类型为4) ? 6 : q.HP-1;
                    if (visit[nx][ny] < new_hp) { // 仅更优状态入队
                        que.push({nx, ny, step+1, new_hp});
                        visit[nx][ny] = new_hp;
                    }
                }
            }
        }
    }
}
```

---

#### 3. 作者：KesdiaelKen（4星）
**关键亮点**  
- 提出 **“血量剩余1时必死”** 的剪枝条件，大幅减少无效扩展。
- 使用结构体封装状态，代码可读性强，适合初学者理解。

**个人心得引用**  
> "当血量为1时，无论下一个格子是什么都会死亡，必须在此前剪枝。"

---

### 最优思路总结
1. **状态设计**：用 `(x, y, hp)` 三元组表示状态，三维数组判重。
2. **血量重置规则**：遇到鼠标格子时立即重置血量为6，且该操作不影响步数。
3. **剪枝策略**：
   - 剩余血量≤1时停止扩展（下一步必死）。
   - 仅当新状态的血量严格大于该位置历史最大血量时才入队。

---

### 拓展与举一反三
- **同类题目推荐**  
  1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)（连通块+状态记忆）  
  2. [P3958 奶酪](https://www.luogu.com.cn/problem/P3958)（三维BFS+几何判断）  
  3. [P1032 字变换](https://www.luogu.com.cn/problem/P1032)（字符串状态BFS）

- **调试经验摘录**  
  > "步数上限设置过小会导致漏解，需设为 `n*m` 级别。" —— Jameswood  
  > "鼠标格子只需访问一次，因再次访问时血量相同且步数更大。" —— BurningEnderDragon

---
处理用时：64.13秒
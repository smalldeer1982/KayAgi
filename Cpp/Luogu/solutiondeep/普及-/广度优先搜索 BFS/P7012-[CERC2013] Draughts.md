# 题目信息

# [CERC2013] Draughts

## 题目描述

国际跳棋（或称跳棋）是一种由两个对手在 $10 \times 10$ 的棋盘上进行的游戏。棋盘上的方块是黑色或白色的，就像经典的国际象棋棋盘一样。玩家一方控制黑棋，另一方控制白棋。棋子只能占据黑色的格子。棋手们交替走棋，各自移动自己的一个棋子。

最有趣的走法是吃掉：如果一个对角线相邻的格子里有对手的棋子，可以通过跳过它到紧挨着它的未被占领的格子来吃掉（并从游戏中删除被吃掉的这个棋子）。允许在一步棋中用一个棋子连续吃掉几个棋子。通过向前或向后的跳跃来吃子也是合法的。

你会得到一个棋子的位置。现在轮到白方了。计算他在下一步棋中能吃掉的最大可能的黑棋数量。

## 样例 #1

### 输入

```
2

.#.#.#.#.#
#.#.#.#.#.
.#.#.B.#.#
#.#.#.#.#.
.#.#.B.#.#
#.#.W.#.#.
.#.#.#.#.#
#.#.#.B.#.
.#.#.#.#.#
#.#.#.#.#.

.#.#.#.#.#
#.#.#.#.#.
.#.#.B.#.#
#.B.#.B.#.
.#.#.B.#.#
#.B.W.#.#.
.#.B.B.#.#
#.#.#.#.#.
.#.B.B.#.#
#.#.#.#.#.
```

### 输出

```
2
4
```

# AI分析结果



### 综合分析与结论
该题核心为国际跳棋吃子路径的DFS搜索，需处理多方向跳跃、状态回溯及多组数据初始化。所有题解均采用DFS+回溯，但实现细节差异显著。关键点包括：棋盘状态修改与恢复、方向数组设计、剪枝优化。最优解法需代码简洁、逻辑清晰且覆盖边界条件。

---

### 高星题解推荐

#### 1. David_yang（4星）
**关键亮点**  
- 明确状态恢复逻辑（修改3个格子并回溯）  
- 处理多组数据初始化陷阱  
- 边界条件判断详细  

**核心代码思想**  
```cpp
void dfs(...) {
    // 检查四个方向是否可跳
    for (int i=0;i<4;i++) {
        // 修改棋盘状态后递归
        a[x-1][y-1]='#';
        dfs(nx,ny,cnt+1);
        a[x-1][y-1]='B'; // 回溯
    }
}
```

#### 2. Alystkia（4星）
**关键亮点**  
- 使用统一方向数组简化代码  
- 数字编码棋盘提升可读性  
- 提前将白棋位置置空避免阻挡  

**核心实现**  
```cpp
void dfs(int x, int y, int step) {
    for (int i=1;i<=4;i++) {
        int xx = x+dx[i], yy = y+dy[i]; // 中间位置
        int _x = x+dx[i]*2, _y = y+dy[i]*2; // 目标位置
        if (中间为黑棋且目标为空) {
            mp[xx][yy] = 0; // 吃子
            dfs(_x, _y, step+1);
            mp[xx][yy] = 2; // 回溯
        }
    }
}
```

#### 3. Tjaweiof（3.5星）  
**个人心得**  
> "在DFS前将白棋置空并在回溯恢复，此错误导致调试3页提交记录"  
总结：状态管理是核心难点，需在移动前腾出当前位置。

---

### 关键思路与技巧
1. **状态回溯三要素**：移动前将白棋位置置空→跳跃吃子→递归后恢复原棋盘状态  
2. **方向数组优化**：使用`dx={1,1,-1,-1}, dy={1,-1,1,-1}`统一处理四个对角线方向  
3. **剪枝策略**：在递归前判断是否还有可吃棋子，无则直接更新最大值  

---

### 相似题目推荐
1. **P1219 八皇后** - 经典回溯问题，处理棋盘状态  
2. **P1433 吃奶酪** - 状态压缩+DFS求最优路径  
3. **P1120 小木棍** - 多重剪枝的DFS优化实践  

---

### 调试经验摘录
1. **Genshin_ZFYX**：  
   > "memset(vis,0,sizeof(vis))会TLE，需避免重复初始化"  
   → 仅标记被吃棋子状态而非全局vis数组  

2. **Tjaweiof**：  
   > "忘记恢复白棋位置导致后续搜索错误"  
   → 移动前必须置空当前位置并在回溯时恢复  

3. **danb123**：  
   > "四个方向独立判断，代码冗长但易调试"  
   → 显式枚举方向更易定位逻辑错误

---
处理用时：61.37秒
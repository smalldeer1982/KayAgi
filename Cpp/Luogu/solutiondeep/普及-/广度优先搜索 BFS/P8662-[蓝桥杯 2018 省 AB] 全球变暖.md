# 题目信息

# [蓝桥杯 2018 省 AB] 全球变暖

## 题目描述

你有一张某海域 $N \times N$ 像素的照片，`.` 表示海洋、 `#` 表示陆地，如下所示：

```
.......
.##....
.##....
....##.
..####.
...###.
.......
```

其中 "上下左右" 四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有 $2$ 座岛屿。

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻（上下左右四个相邻像素中有海洋），它就会被淹没。

例如上图中的海域未来会变成如下样子：

```
.......
.......
.......
.......
....#..
.......
.......
```

请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 


## 说明/提示

时限 1 秒, 256M。蓝桥杯 2018 年第九届省赛

## 样例 #1

### 输入

```
7 
.......
.##....
.##....
....##.
..####.
...###.
.......  ```

### 输出

```
1```

# AI分析结果



### 综合分析与结论
本题的核心在于正确判断哪些岛屿会被完全淹没。各题解主要采用两种思路：  
1. **直接判断原岛屿是否存在不会被淹没的块**（如题解二、三、五），通过DFS/BFS遍历每个岛屿时检查是否存在四周均为陆地的块，若有则该岛未被淹没。此方法高效且无需处理淹没后岛屿分裂问题。  
2. **标记原岛屿并统计残留**（如题解四），通过记录每个陆地所属的原岛屿编号，淹没后统计残留情况。思路严谨但实现较复杂。

### 高星题解推荐（评分≥4星）

#### 题解二（作者：Tolerate） ⭐⭐⭐⭐⭐  
**关键亮点**：  
- **思路直接高效**：在DFS遍历岛屿时，实时检查是否存在不会被淹没的块（四周均为陆地），利用标记`t`记录状态，避免分裂岛屿的干扰。  
- **代码简洁**：通过一次遍历完成统计，时间复杂度优化到位。  
**核心代码**：  
```cpp
void dfs(int x,int y) {
    if(!t) { // 检查当前块是否不会被淹没
        cnt=0;
        for(int i=0;i<4;i++) 
            if(mp[x+dx[i]][y+dy[i]]!='.') cnt++;
        if(cnt==4) ans++, t=1; // 存在不会被淹没的块
    }
    mp[x][y]='*'; // 标记已访问
    for(int i=0;i<4;i++) {
        int xx=x+dx[i], yy=y+dy[i];
        if(xx<0||xx>=n||yy<0||yy>=n||mp[xx][yy]!='#') continue;
        dfs(xx,yy);
    }
}
```
**实现思想**：  
- 遍历每个岛屿时，若发现某个陆地块四周无海洋，则标记该岛屿未被淹没。
- 统计总岛屿数`sum`和未被淹没数`ans`，最终答案`sum - ans`。

#### 题解三（作者：small_john） ⭐⭐⭐⭐⭐  
**关键亮点**：  
- **逻辑清晰**：通过`v`变量标记岛屿是否会被完全淹没，DFS返回该状态，直接累加被淹没的岛屿数。  
- **边界处理完善**：使用`ok`函数统一判断陆地合法性，代码可读性强。  
**核心代码**：  
```cpp
bool dfs(int x,int y) {
    vis[x][y] = 1;
    if(ok(x-1,y)&&ok(x+1,y)&&ok(x,y-1)&&ok(x,y+1)) v = 0; // 发现不会被淹没的块
    for(int i = 0; i<4; i++) {
        int X = x+xx[i], Y = y+yy[i]; 
        if(ok(X,Y) && !vis[X][Y]) dfs(X,Y);
    }
    return v; // 返回是否被完全淹没
}
```
**实现思想**：  
- 在DFS中检查每个陆地块的四周是否为陆地，若有则`v=0`表示该岛未被淹没。
- 主函数遍历所有陆地，累加被完全淹没的岛屿数`ans`。

#### 题解五（作者：wuhan1234） ⭐⭐⭐⭐  
**关键亮点**：  
- **BFS直观实现**：通过队列遍历岛屿，统计是否存在不会被淹没的块，适合广度优先场景。  
**核心代码**：  
```cpp
int bfs(int x,int y) {
    int left = 0;
    while (front < rear) {
        struct Point p = q[front++];
        int cnt = 0;
        for (int i=0; i<4; i++) { // 检查四周是否为陆地
            if (a[dx][dy]=='#') cnt++;
        }
        if (cnt == 4) left++; // 存在不会被淹没的块
    }
    return left; // 返回该岛未被淹没的块数
}
```
**实现思想**：  
- BFS遍历岛屿时统计不会被淹没的块数`left`，若`left=0`则完全淹没。

### 最优思路总结  
**关键技巧**：  
- **遍历时实时判断**：在DFS/BFS过程中直接检查每个块是否满足条件，避免后续复杂统计。  
- **标记状态优化**：使用标记变量（如`t`或`v`）在遍历中确定岛屿状态，减少重复计算。  

### 拓展与举一反三  
**相似题目推荐**：  
1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - 连通块标记与条件判断。  
2. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 预处理连通块并快速查询。  
3. [P3395 路障](https://www.luogu.com.cn/problem/P3395) - BFS应用与条件判断。  

**个人心得摘录**：  
- **题解一作者**强调淹没后的陆地需用特殊标记而非直接改为海洋，否则会导致分裂岛屿的误判。  
- **题解四作者**指出需通过原岛屿编号统计残留，避免分裂后错误计数。  
- **题解二作者**通过`t`变量优化，避免多次遍历。

---
处理用时：189.65秒
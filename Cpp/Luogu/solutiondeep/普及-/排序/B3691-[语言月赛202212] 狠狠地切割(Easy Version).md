# 题目信息

# [语言月赛202212] 狠狠地切割(Easy Version)

## 题目描述

现给你一个长度为 $n$ 的序列 $a _ 1, \cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \cdots, b _ m$。你需要按照这 $m$ 个数对序列 $a$ 进行**狠狠地切割**。

具体的，对于一个数字 $i \in [1, n]$，如果存在一个整数 $j \in [1, m]$，使得 $a _ i = b _ j$，则将位置 $i$ 称为一个**切割点**。对序列 $a$ 中的每一个切割点，我们在这个位置进行一次**狠狠地切割**。方法是，将该位置的数字去除，然后在这个位置将其左右的**序列/片段**一分两半。

如果对**狠狠地切割**的定义有疑问，可以参照「样例 #1」及「样例解释 #1」进行理解。

你需要计算，在进行了所有可能的**狠狠地切割**后，序列被切割为了多少**片段**。

特别的，如果在切割后，某一段内没有数组，那这一段不可被叫做**片段**。同样的，如果 $1$ 或 $n$ 为切割点，其与开头和结尾之间也不存在片段。

如果对**片段**的概念有疑问，可以参照「样例 #2」及「样例解释 #2」进行理解。

## 说明/提示

### 样例 1 解释

在**狠狠地切割**前，序列 $a$ 如下所示：

$$\begin{matrix} 3 & 4 & 3 & 5 & 2 & 6 \end{matrix}$$

容易知道，第二个位置和第四个位置为切割点，我们使用 `|` 对其进行替换，代表去除工作：

$$\begin{matrix} 3 & | & 3 & | & 2 & 6 \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{3} ^ \text{片段 1} & | & \overbrace{3} ^ \text{片段 2} & | & \overbrace{2 \quad 6} ^ \text{片段 3} \end{matrix}$$

共计 $3$ 个片段。

### 样例 2 解释

以下我们展示去除之后的序列：

$$\begin{matrix} | & 4 & | & | & 2 & | \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} | & \overbrace{4} ^ \text{片段 1} & | & \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} & | & \overbrace{2} ^ \text{片段 2} & | \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段}\end{matrix}$$

共计 $2$ 个片段。

### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n, m \leq 10$。
- 对于 $70\%$ 的数据，保证 $n, m \leq 5 \times 10 ^ 3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 5 \times 10 ^ 5$，$1 \leq a_i,b_i \leq 5 \times 10^{6}$。

### 提示
本题输入规模较大，建议考虑使用较快的读入读出方式。

## 样例 #1

### 输入

```
6 2
3 4 3 5 2 6
5 4```

### 输出

```
3```

## 样例 #2

### 输入

```
6 3
3 4 3 5 2 6
3 5 6```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
该题解思路清晰，将解题任务分为找到切割位置和计算片段数量两部分。对于计算片段数量给出了通用代码，重点介绍了多种找到切割位置的方法，包括适用于 Easy Version 的数组记录法，以及适用于 Hard Version 的 `unordered_map` 法、二分查找法和双指针法。不同方法针对不同的数据规模和值域进行了优化，具有较强的实用性和可扩展性。

### 所选题解
- **星级**：5星
- **关键亮点**：思路清晰，详细介绍了多种解题方法，不仅适用于本题的 Easy Version，还对 Hard Version 进行了拓展，同时给出了代码示例和学习参考链接。

### 重点代码及核心实现思想
#### 计算片段数量
```cpp
int cnt = 0; // 标记当前一段片段的长度
for (int i = 1; i <= n; ++i) {
    if (a[i].isMarked) { // 使用 isMarked 记录当前点是否是切割点
        if (cnt) // 判断该切割点前是否存在片段
            ++ans;
        cnt = 0;
    } else {
        ++cnt;
    }
}
if (cnt) // 需要注意的是，序列的结尾不一定为切割点，所以这里要特殊处理一下
    ++ans;
```
核心思想：遍历序列，遇到切割点时，若当前片段长度不为 0，则片段数量加 1，并将当前片段长度置 0；若不是切割点，则当前片段长度加 1。最后处理序列结尾不为切割点的情况。

#### 双指针法（Hard Version）
```cpp
struct Node {
    int num;
    lint val;
    int isMarked;
} a[1000005];

scanf("%d%d", &n, &m);
for (int i = 1; i <= n; ++i) {
    lint var;
    scanf("%lld", &var);
    a[i] = Node(i, var);
}
for (int i = 1; i <= m; ++i) {
    scanf("%lld", b + i);
}
b[m + 1] = (1ll << 60);
b[0] = -(1ll << 60);
sort(a + 1, a + n + 1, cmp);
sort(b + 1, b + m + 1);
for (int i = 1; i <= n; ++i) {
    while (b[cur] < a[i].val)
        ++cur;
    if (b[cur] == a[i].val)
        a[i].isMarked = 1;
}
```
核心思想：先对序列 $a$ 和 $b$ 进行排序，然后使用双指针，对于 $a$ 中的每个元素，在 $b$ 中找到第一个大于等于它的元素，若相等则标记该位置为切割点。

### 最优关键思路或技巧
- 对于不同的数据规模和值域，采用不同的方法记录切割点，如数组、`unordered_map`、二分查找和双指针法，体现了算法的灵活性和针对性。
- 双指针法通过记录上一次查找的位置，避免了重复查找，将时间复杂度优化到了较优的程度。

### 可拓展之处
同类型题或类似算法套路：
- 序列分割问题：给定一个序列，根据某些条件进行分割，求分割后的片段数量或其他相关信息。
- 区间查找问题：在一个有序序列中查找满足某些条件的元素，可使用二分查找或双指针法进行优化。

### 推荐题目
- P1102 A-B 数对
- P1908 逆序对
- P2249 【深基13.例1】查找

### 个人心得
题解中未包含个人心得。

---
处理用时：20.57秒
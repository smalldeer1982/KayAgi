# 题目信息

# [GESP202406 四级] 宝箱

## 题目描述

小杨发现了 $n$ 个宝箱，其中第 $i$ 个宝箱的价值是 $a_i$。

小杨可以选择一些宝箱放入背包并带走，但是小杨的背包比较特殊，假设小杨选择的宝箱中最大价值为 $x$，最小价值为 $y$，小杨需要保证 $x-y\leq k$，否则小杨的背包会损坏。

小杨想知道背包不损坏的情况下，自己能够带走宝箱的总价值最大是多少。

## 说明/提示

**【样例解释】**

在背包不损坏的情况下，小杨可以拿走两个价值为 $2$ 的宝箱和一个价值为 $3$ 的宝箱。

**【数据范围】**

对于全部数据，保证有 $1\leq n\leq 1000$，$0\leq k\leq 1000$，$1\leq a_i\leq 1000$。

## 样例 #1

### 输入

```
5 1
1 2 3 1 2```

### 输出

```
7```

# AI分析结果

### 综合分析与结论
题解的核心思路是先对宝箱价值进行排序，然后枚举最大价值的宝箱，再从该宝箱开始向前枚举较小价值的宝箱，只要满足最大价值与当前宝箱价值之差不超过 $k$ 就累加其价值，最后更新最大总价值。算法要点在于排序和双重循环枚举，解决的难点是将杂乱的宝箱价值排序后便于处理选择问题。时间复杂度为 $O(n^2)$，还有优化到 $O(n \log n)$ 的空间。

### 所选题解
- 作者：chen_zhe，星级：4星
  - 关键亮点：思路清晰，先点明排序对简化问题的重要性，再详细阐述枚举过程，代码简洁易懂。
  - 重点代码：
```cpp
for (int i = 1; i <= n; i++) {
    int sum = 0;
    for (int j = i; j >= 1; j--) {
        if (a[i] - a[j] <= k)
            sum += a[j];
    }
    ans = max(ans, sum);
}
```
  - 核心实现思想：外层循环枚举最大价值的宝箱，内层循环从当前最大价值宝箱开始向前枚举，只要满足价值差条件就累加价值，最后更新最大总价值。

### 最优关键思路或技巧
- 思维方式：将无序的宝箱价值排序，使问题变得易于处理，通过枚举最大价值宝箱并向前扩展选择范围，简化了选择过程。

### 可拓展之处
同类型题可能会改变限制条件，如增加背包容量限制、宝箱有不同属性等。类似算法套路可用于区间选择问题，先排序再枚举区间端点，根据条件扩展区间并计算结果。

### 洛谷相似题目推荐
- P1090 [NOIP2004 提高组] 合并果子
- P1223 排队接水
- P1104 生日

---
处理用时：11.14秒
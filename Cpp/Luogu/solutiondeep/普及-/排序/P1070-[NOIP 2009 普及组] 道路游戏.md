# 题目信息

# [NOIP 2009 普及组] 道路游戏

## 题目描述

小新正在玩一个简单的电脑游戏。

游戏中有一条环形马路，马路上有 $n$ 个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这 $n$ 个机器人工厂编号为 $1\sim n$，因为马路是环形的，所以第 $n$ 个机器人工厂和第 $1$ 个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这 $n$ 段马路也编号为 $1\sim n$，并规定第 $i$ 段马路连接第 $i$ 个机器人工厂和第 $i+1$ 个机器人工厂（$1\le i\le n-1$），第 $n$ 段马路连接第 $n$ 个机器人工厂和第 $1$ 个机器人工厂。

游戏过程中，每个单位时间内，每段马路上都会出现一些金币，金币的数量会随着时间发生变化，即不同单位时间内同一段马路上出现的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在 $i$（$1\le i\le n$）号机器人工厂购买了一个机器人，这个机器人会从 $i$ 号机器人工厂开始，顺时针在马路上行走，第一次行走会经过 $i$ 号马路，到达 $i+1$ 号机器人工厂（如果 $i=n$，机器人会到达第 $1$ 个机器人工厂），并将 $i$ 号马路上的所有金币收集给小新。游戏中，环形马路上不能同时存在 $2$ 个或者 $2$ 个以上的机器人，并且每个机器人最多能够在环形马路上行走 $p$ 次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为 $1\sim p$ 之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。

以下是游戏的一些补充说明：

1. 游戏从小新第一次购买机器人开始计时。
2. 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。
3. 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。
4. 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。
5. 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。

现在已知每段马路上每个单位时间内出现的金币数量和在每个机器人工厂购买机器人需要的花费，请你告诉小新，经过 $m$ 个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。


## 说明/提示

对于 $40\%$ 的数据，$2\le n\le 40$，$1\le m\le 40$。

对于 $90\%$ 的数据，$2\le n\le 200$，$1\le m\le 200$。

对于 $100\%$ 的数据，$2\le n\le 1000$，$1\le m\le 1000$，$1\le p\le m$。

NOIP 2009 普及组 第四题


## 样例 #1

### 输入

```
2 3 2 
1 2 3 
2 3 4 
1 2```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕动态规划（DP）来解决问题，部分题解还使用了单调队列、优先队列等数据结构进行优化。题解思路各有不同，状态定义和转移方程也存在差异，但核心都是通过枚举时间、位置和步数来更新最大金币数。
- **思路对比**：多数题解以时间为主要维度进行状态转移，部分题解考虑了机器人的行走步数和位置。一些题解通过巧妙的状态定义减少了维度，简化了方程。
- **算法要点**：大部分题解采用 $O(n^3)$ 的时间复杂度，部分题解使用单调队列或优先队列优化到 $O(n^2)$ 或 $O(n^2logn)$。
- **解决难点**：处理环形马路的边界情况、机器人行走步数的限制以及金币的收集和花费是主要难点，不同题解通过取模、前缀和等方法解决。

### 所选题解
- **作者：ButterflyDew（5星）**
    - **关键亮点**：思路清晰，从初始版的三维 DP 逐步优化到一维 DP，并使用单调队列进一步优化，对难点的解释详细，配有图示。
    - **个人心得**：最初使用三维 DP 方程，虽能过 90% 数据，但处理拐弯情况复杂，后来发现更优的一维 DP 方程可卡过，最后用单调队列优化以应对更卡的数据。
    - **核心代码**：
```cpp
// 一维 DP 转移方程
dp[i]=max(dp[i-k]+cal(i,j,k)-cost[j-k]);
// 单调队列优化
int get(int i,int j)//获取单队编号
{
    return ((j-i)%n+n)%n;
}
```
- **作者：gorokokoro（4星）**
    - **关键亮点**：使用单调队列优化，状态表示和转移方程清晰，对二维滑动区间的处理有详细解释。
    - **核心代码**：
```cpp
// 状态转移方程
f[i]=max(f[i-k]+(g[j-1][i]-g[j-k-1][i])-a[j-k]);
// 单调队列维护
void PushOrder(Queue &q, int x, int p);
void PopOrder(Queue &q, int p);
int MaxOrder(Queue &q);
```
- **作者：dengyaotriangle（4星）**
    - **关键亮点**：通过让工厂和金币随时间旋转的巧妙思路，将问题转化，使用优先队列优化 DP 方程。
    - **核心代码**：
```cpp
// 转化后的 DP 方程
dp[i]=\max_{j=1}^{n} pfx[j][i]+\max_{k= max(0,i-p)}^{i-1} g[j][k];
// 优先队列维护
priority_queue<pair<int,int> > q[maxn];
```

### 最优关键思路或技巧
- **状态定义优化**：如将三维 DP 优化为一维 DP，减少状态维度，简化转移方程。
- **数据结构优化**：使用单调队列或优先队列维护滑动区间的最大值，将时间复杂度从 $O(n^3)$ 优化到 $O(n^2)$ 或 $O(n^2logn)$。
- **问题转化**：通过让工厂和金币随时间旋转，将机器人的运动转化为静止，简化问题。

### 可拓展之处
同类型题可能涉及更多的状态维度、更复杂的转移条件或更严格的时间限制。类似算法套路包括使用单调队列优化 DP、通过问题转化简化问题等。

### 推荐题目
- [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)：考察单调队列的基本应用。
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的 0 - 1 背包问题，是 DP 的基础练习。
- [P1216 [USACO1.5]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：简单的线性 DP 问题，可加深对 DP 思想的理解。

---
处理用时：23.96秒
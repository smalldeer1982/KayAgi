# 题目信息

# [NOIP 2004 普及组] 火星人

## 题目描述

人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。

火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。

一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：


| 三进制数 | 代表的数字 |
|:-:|:-:|
| $123$ | $1$ |
| $132$ | $2$ |
| $213$ | $3$ |
| $231$ | $4$ |
| $312$ | $5$ |
| $321$ | $6$ |

现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。


## 说明/提示

对于 $30\%$ 的数据，$N \le 15$。

对于 $60\%$ 的数据，$N \le 50$。

对于 $100\%$ 的数据，$N \le 10000$。

noip2004 普及组第 4 题


## 样例 #1

### 输入

```
5
3
1 2 3 4 5
```

### 输出

```
1 2 4 5 3```

# AI分析结果

### 综合分析与结论
这些题解提供了多种解决火星人手指排列问题的思路。主要可分为使用库函数、手动模拟、变进制数转化、找规律和深度优先搜索（DFS）等方法。
- **使用库函数**：利用`next_permutation`函数可简洁地解决问题，但缺乏对算法原理的深入理解。
- **手动模拟**：按照人脑思维模拟增加过程，直观易懂，但代码实现较复杂。
- **变进制数转化**：将全排列转化为变进制数进行加法运算，思路新颖，但理解难度较大。
- **找规律**：通过寻找排列变化的规律来解决问题，代码实现相对简单，但规律较难发现。
- **深度优先搜索（DFS）**：利用DFS生成全排列，结合剪枝可避免超时，但时间复杂度较高。

### 所选题解
- **作者：yummy（5星）**
    - **关键亮点**：思路独特，将全排列转化为变进制数进行加法运算，代码简洁。
    - **个人心得**：通过评论区纠正了举例子部分的小问题，了解到自己的方法叫康托展开。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10005];
bool used[10005]={0};
int m,n;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        int x=a[i];
        for(int j=1;j<=a[i];j++)
            x-=used[j];
        used[a[i]]=1;
        a[i]=x-1;
    }
    a[n]+=m;
    for(int i=n;i>0;i--)
    {
        a[i-1]+=a[i]/(n-i+1);
        a[i]%=n-i+1;
    }
    memset(used,0,sizeof(used));
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=a[i];j++)
            if(used[j])
                a[i]++;
        cout<<a[i]+1<<" ";
        used[a[i]]=1;
    }
    return 0;
}
```
    - **核心实现思想**：先将火星数转化为变进制数，然后加上`m`，处理进位后再将变进制数转化回火星数。

- **作者：Believe_R_（4星）**
    - **关键亮点**：详细介绍了`next_permutation`函数的用法，并通过模板题进行说明，代码简洁易懂。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100000];
int n,m;
inline int read()
{
    int re=0, f=1; char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0' && ch<='9') {re=re*10+(ch-'0'); ch=getchar();}
    return re*f;
}
int main()
{
    n=read(); m=read();
    for(int i=1;i<=n;++i) a[i]=read();
    for(int i=1;i<=m;++i) next_permutation(a+1,a+n+1);
    for(int i=1;i<=n;++i) printf("%d ",a[i]);
    return 0;
}
```
    - **核心实现思想**：使用`next_permutation`函数对数组进行`m`次全排列变化。

- **作者：zhi_zhang（4星）**
    - **关键亮点**：按照人脑思维模拟增加过程，思路直观易懂，代码自带输出调试。
    - **核心代码**：
```cpp
int ad(int poi)//检索该手指 
{
    for(int i=poi+1;i<=N;i++)//向上搜索直到 
    {
        if(!vis[i])//搜索到还未入队的更大的数 
        {
            return i;//返回该数 
        }
    }
    return -1;//检索不到则返回-1
}
void prin()
{
    for(int i=1;i<=N;i++)
    {
        printf("%d ",finger[i]);
    }
    printf("\n");
}
```
    - **核心实现思想**：从最后一位开始，判断当前数位是否有更高的未标记数可使用，若有则替换该位置的数，剩余未标记数按从小到大顺序填充；若没有则取消当前数位标记，搜索上一数位。

### 最优关键思路或技巧
- **变进制数转化**：将全排列问题转化为变进制数的加法问题，简化了计算过程。
- **使用库函数**：`next_permutation`函数可快速生成下一个全排列，提高代码效率。
- **剪枝优化**：在DFS中，通过剪枝避免不必要的搜索，减少时间复杂度。

### 拓展思路
同类型题可考察不同的排列组合问题，如求第`k`个全排列、求满足特定条件的全排列等。类似算法套路包括康托展开、逆康托展开、手动模拟排列变化等。

### 推荐题目
1. [P1706 全排列问题](https://www.luogu.org/problemnew/show/P1706)
2. [P3182 [HAOI2016]放棋子](https://www.luogu.org/problemnew/show/P3182)
3. [P1088 火星人](https://www.luogu.org/problemnew/show/P1088)（本题）

---
处理用时：31.83秒
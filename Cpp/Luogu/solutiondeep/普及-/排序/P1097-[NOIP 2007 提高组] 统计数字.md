# 题目信息

# [NOIP 2007 提高组] 统计数字

## 题目描述

某次科研调查时得到了 $n$ 个自然数，每个数均不超过 $1.5 \times 10^9$。已知不相同的数不超过 $10^4$ 个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。


## 说明/提示

- $30\%$ 的数据满足：$1  \le  n  \le  1000$；
- $60\%$ 的数据满足：$1  \le  n  \le  50000$；
- $100\%$ 的数据满足：$1  \le  n  \le  200000$，每个数均不超过 $1.5 \times 10^9$。

NOIP 2007 提高第一题


## 样例 #1

### 输入

```
8
2
4
2
4
5
100
2
100```

### 输出

```
2 3
4 2
5 1
100 2
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕统计数字出现次数并按从小到大顺序输出的问题展开，由于数字范围大（不超过 $1.5×10^9$），普通数组无法作为桶来使用，因此各题解采用了不同的数据结构和算法来解决。主要思路可分为两类：一是使用 `map` 进行计数，二是先排序再统计相同数字的个数。

### 所选题解
1. **作者：Swire（5星）**
    - **关键亮点**：思路清晰，详细解释了 `map` 和 `set` 的使用，代码注释丰富，适合初学者理解。
    - **核心代码**：
```cpp
#include<cstdio>
#include<map>
#include<set>
std::set <int> num;
std::set <int> :: iterator I;
std::map <int,int> statistics;
int n,in;
int main(void){
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&in);
        statistics[in]++;
        num.insert(in);
    }
    for(I=num.begin();I!=num.end();I++)
        printf("%d %d\n",*I,statistics[*I]);
    return 0;
}
```
    - **核心思想**：使用 `map` 统计每个数字的出现次数，使用 `set` 记录出现过的数字，最后遍历 `set` 输出结果。

2. **作者：ikunTLE（4星）**
    - **关键亮点**：简洁明了，直接使用 `map` 完成计数和排序，时间复杂度分析清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int n,x;
map<int,int>mp;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        scanf("%d",&x),++mp[x];
    for(auto it=mp.begin();it!=mp.end();++it)
        printf("%d %d\n",it->first,it->second);
    return 0;
}
```
    - **核心思想**：使用 `map` 统计每个数字的出现次数，`map` 会自动按键排序，最后遍历 `map` 输出结果。

3. **作者：qhr2023（4星）**
    - **关键亮点**：代码简洁，使用 `map` 进行计数，遍历输出结果，思路清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<int, int> mp;
int n, x;
int main(){
    cin >> n;
    for ( ; n--; mp[x]++)
        cin >> x;
    for (auto i:mp)
        cout << i.first << ' ' << i.second << '\n';
    return 0;
}
```
    - **核心思想**：使用 `map` 统计每个数字的出现次数，最后遍历 `map` 输出结果。

### 最优关键思路或技巧
- **数据结构选择**：使用 `map` 作为“超级桶”，可以处理大范围的数字，且 `map` 会自动按键排序。
- **排序后统计**：先对数组进行排序，使相同数字相邻，然后遍历数组统计相同数字的个数。

### 拓展思路
同类型题可考察对不同数据结构的应用，如统计字符串中字符的出现次数、统计数组中元素的频率等。类似算法套路可用于处理需要去重、计数和排序的问题。

### 推荐题目
1. [P1160 队列安排](https://www.luogu.com.cn/problem/P1160)：考察链表的使用，可用于处理插入和删除操作。
2. [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)：考察循环链表或队列的使用，解决约瑟夫环问题。
3. [P2676 [USACO07DEC]Bookshelf B](https://www.luogu.com.cn/problem/P2676)：考察贪心算法和排序的应用，解决书架堆叠问题。

### 个人心得摘录与总结
- **pengyirui**：使用 `multiset` 遍历删除元素时会导致迭代器失效，报 RE 错误。解决方法是再开一个 `set` 存放已经遍历过的元素，避免重复输出。
- **Camorgx**：使用 `sort` 对 `vector` 排序后再插入 `map` 可以提高效率，因为 `map` 基于红黑树实现，从小到大插入可以减少旋转操作。另外，`++` 比 `+=1` 跑得快，从大到小插入 `map` 会更快。 

---
处理用时：26.29秒
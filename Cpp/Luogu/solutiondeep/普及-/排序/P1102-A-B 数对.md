# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解围绕“A - B = C”数对计数问题，给出了多种思路与算法。整体可分为映射统计、二分查找、双指针、哈希等几类方法。

- **映射统计**：通过 `map` 记录每个数的出现次数，将 `A - B = C` 转化为 `A - C = B`，遍历数组累加 `A - C` 对应的出现次数。此方法思路简单，代码实现容易，但 `map` 基于红黑树，插入和查找操作时间复杂度为 $O(logn)$，整体复杂度为 $O(nlogn)$。
- **二分查找**：先对数组排序，利用 `lower_bound` 和 `upper_bound` 函数查找对于每个 `A`，满足 `A + C` 的元素个数，累加得到结果。该方法时间复杂度也是 $O(nlogn)$，适用于有序数组查找特定元素个数的场景。
- **双指针**：排序后用两个指针维护满足条件的区间，根据元素大小关系移动指针，计算满足 `A - B = C` 的数对个数。时间复杂度为 $O(n)$，在处理有序数组的区间问题上有优势。
- **哈希**：使用哈希表记录每个数的出现次数，避免了 `map` 的排序开销，查找和插入操作平均时间复杂度为 $O(1)$，整体复杂度为 $O(n)$，但需要处理哈希冲突。

### 所选题解
- **作者：OsvaldoAsensioLopez（5星）**
    - **关键亮点**：思路清晰，代码简洁，将 `A - B = C` 巧妙转化为 `A - C = B`，利用 `map` 统计每个数的出现次数，遍历数组累加满足条件的数对个数，易于理解和实现。
    - **核心代码**：
```cpp
#include <iostream>
#include <map>
using namespace std;
typedef long long LL;
LL a[200001];
map<LL,LL> m;
int main() {
    int n;
    LL c;
    LL ans=0;
    cin >> n >> c;
    for(int i=1;i<=n;i++) {
        cin >> a[i];
        m[a[i]]++;
        a[i]-=c;    
    } 
    for(int i=1;i<=n;i++) ans+=m[a[i]];
    cout << ans << endl;
    return 0;
}
```
- **作者：樱花飞舞（4星）**
    - **关键亮点**：详细介绍了 `lower_bound` 和 `upper_bound` 函数的用法，并利用这两个函数在有序数组中查找满足条件的元素个数，时间复杂度为 $O(nlogn)$，是二分查找的典型应用。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long a[200001];
long N,C,ans;
int main()
{
    cin>>N>>C;
    for(int i=1;i<=N;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+N+1);
    for(int i=1;i<=N;i++)
    {
        ans+=((upper_bound(a+1,a+N+1,a[i]+C)-a)-(lower_bound(a+1,a+N+1,a[i]+C)-a));
    }
    cout<<ans;
    return 0;
}
```
- **作者：jins3599（4星）**
    - **关键亮点**：采用双指针方法，利用排序后数组的有序性，维护两个指针找到满足条件的区间，时间复杂度为 $O(n)$，代码简洁，效率较高。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 2e5 + 10;
int n, c;
int a[N];

int main () 
{
    cin >> n >> c;
    for(int i = 1 ; i <= n ; i ++) cin >> a[i];
    sort(a + 1, a + 1 + n);
    int l = 1, r1 = 1, r2 = 1;
    ll ans = 0;
    for(l = 1 ; l <= n ; l ++) {
        while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
        while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
        if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
            ans += r1 - r2;
    }
    cout << ans;
    return 0;
}
```

### 最优关键思路与技巧
- **等式转化**：将 `A - B = C` 转化为 `A - C = B` 或 `B + C = A`，简化问题，便于利用数据结构进行统计。
- **数据结构选择**：根据数据规模和特点选择合适的数据结构，如 `map` 用于映射统计，哈希表用于快速查找，有序数组结合二分查找或双指针处理区间问题。
- **算法优化**：避免暴力枚举，利用排序、二分查找、双指针等算法优化时间复杂度。

### 拓展思路
- **同类型题**：类似的查找满足特定条件数对的问题，如给定数组求满足 `A + B = C` 的数对个数。
- **算法套路**：遇到查找特定元素或数对的问题，可考虑先对数组排序，再利用二分查找、双指针等方法；对于需要统计元素出现次数的问题，可使用 `map` 或哈希表。

### 推荐题目
- [P1103 书本整理](https://www.luogu.com.cn/problem/P1103)：涉及排序和贪心算法，与本题排序后处理数据的思路类似。
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：可使用优先队列解决，锻炼数据结构的运用能力。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：需要排序和贪心策略，有助于提升算法思维。

### 个人心得摘录与总结
- **fallenangel**：用 `gp_hash_table`、`cc_hash_table`、`map` 分别实现，发现时间差距较大，证明了 `pb_ds` 在实现哈希方面的优势，提醒我们在实际应用中要根据需求选择合适的数据结构。
- **attack**：数据更新后很多题解过不了第3个点，原因是没有开 `long long`，强调了在处理数据时要注意数据范围，避免因数据类型选择不当导致错误。
- **马峰**：认为本题不需要用 `map`，直接暴力加点优化就可以过，且比 `map` 快 400ms，说明在某些情况下，简单的优化也能达到较好的效果，不一定需要复杂的数据结构。 

---
处理用时：39.99秒
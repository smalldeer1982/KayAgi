# 题目信息

# 平台

## 题目描述

空间中有一些平台。给出每个平台的位置，请你计算从每一个平台的边缘落下之后会落到哪一个平台上。

注意，如果某两个平台的某个两边缘横坐标相同，物体从上面那个平台落下之后将不会落在下面那个平台上（即平台的范围是一个开区间，不包含端点）。平台**可能会重叠**。

从平台下落时视作从平台下方开始下落，也就是说不会落到高度相同的平台上。**如果有两个平台的高度相同且都可以被落到的话，那么会落到编号靠前的那个平台。**

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)

## 样例 #1

### 输入

```
5
2 0 2
4 1 3
3 1 3
5 3 4
1 1 5
```

### 输出

```
0 5
1 5
1 5
5 5
0 0
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕计算每个平台边缘落下后所落平台的问题展开，核心思路均为通过比较平台高度和左右端点范围来确定落点。多数题解采用$O(n^2)$的暴力枚举方法，部分题解在此基础上进行排序优化。难点在于处理平台重叠情况，需保证高度相同的平台按编号从小到大选取。

### 所选题解
- **作者：kevin_y (赞：82)，5星**
    - **关键亮点**：思路简洁清晰，代码简短，直接用暴力枚举解决问题，容易理解。
    - **个人心得**：无
    - **核心代码**
```cpp
for(int i=1;i<=n;i++){
    int sum1=0,sum2=0;
    for(int j=1;j<=n;j++)if(a[j]<a[i]&&b[j]<b[i]&&c[j]>b[i])if(a[sum1]<a[j])sum1=j;
    cout<<sum1<<" ";
    for(int j=1;j<=n;j++)if(a[j]<a[i]&&b[j]<c[i]&&c[j]>c[i])if(a[sum2]<a[j])sum2=j;
    cout<<sum2<<endl;
}
```
    - **核心实现思想**：通过两层循环，外层遍历每个平台，内层遍历所有平台，判断是否满足高度和左右端点条件，更新左右落点的平台编号。

- **作者：JamlainHamstone (赞：1)，4星**
    - **关键亮点**：思路清晰，先对平台按高度降序、编号升序排序，再通过循环查找左右落点，逻辑明确。
    - **个人心得**：原代码只按高度排序只有50分，考虑平台重叠情况，对高度相同的平台按编号从小到大排序后AC。
    - **核心代码**
```cpp
bool cmp(node a,node b){
    if(a.h!=b.h) return a.h>b.h;
    return a.id<b.id;
}
sort(s+1,s+n+1,cmp);
for(int i=1;i<=n;i++){
    for(int j=i+1;j<=n;j++){
        if(s[j].l<s[i].l&&s[j].r>s[i].l){
            ans[s[i].id].lans=s[j].id;
            break;
        }
    }
    for(int j=i+1;j<=n;j++){
        if(s[j].l<s[i].r&&s[j].r>s[i].r){
            ans[s[i].id].rans=s[j].id;
            break;
        }
    }
}
```
    - **核心实现思想**：自定义排序函数，对平台进行排序。通过两层循环，外层遍历每个平台，内层从当前平台往后找，找到符合条件的平台记录编号并跳出循环。

- **作者：ysner (赞：1)，4星**
    - **关键亮点**：对二重循环进行剪枝优化，降低复杂度，同时强调了结构体在本题中的优势。
    - **个人心得**：指出用结构体排序比用数组和冒泡排序更方便，且高度相同时按左端点排序可AC，否则只有50分。
    - **核心代码**
```cpp
bool com(pt x,pt y){
    return (x.g>y.g)||(x.g==y.g&&x.z<y.z);
}
sort(a,a+n,com);
for(i=0;i<n;i++){
    f1=0;
    f2=0;
    for(j=i+1;j<n;j++){
        if(a[i].z>a[j].z&&a[i].z<a[j].y&&f1==0) {l[a[i].w][0]=a[j].w;f1=1;}
        if(a[i].y>a[j].z&&a[i].y<a[j].y&&f2==0) {l[a[i].w][1]=a[j].w;f2=1;}
        if(f1==1&&f2==1) break;
    }
}
```
    - **核心实现思想**：自定义排序函数对平台按高度和左端点排序。通过两层循环，外层遍历每个平台，内层从当前平台往后找，用标志位记录左右端点是否找到落点，找到后更新结果并剪枝。

### 最优关键思路或技巧
- **排序优化**：对平台按高度降序、编号升序排序，可更快找到符合条件的平台，同时处理平台重叠问题。
- **剪枝优化**：在查找落点时，一旦找到左右端点的落点就跳出内层循环，减少不必要的计算。
- **结构体应用**：使用结构体将平台的高度、左右端点和编号等信息捆绑，方便排序和操作。

### 可拓展之处
同类型题可能会增加平台的移动、动态添加或删除平台等情况，算法套路仍可围绕比较高度和端点范围，可能需要使用更高级的数据结构（如线段树、树状数组）来优化查询和更新操作。

### 推荐题目
- P1007 独木桥
- P1012 拼数
- P1020 导弹拦截

### 个人心得总结
- **CeLaMbDa**：题目说明与实际不符，原以为平台无重叠，写代码只有50分，看题解才知道要考虑重叠情况。
- **JamlainHamstone**：原代码只按高度排序只有50分，考虑平台重叠情况，对高度相同的平台按编号从小到大排序后AC。
- **ysner**：指出用结构体排序比用数组和冒泡排序更方便，且高度相同时按左端点排序可AC，否则只有50分。
- **深海鱼的眼泪**：题目说平台不重叠，用正经排序WA了两次，要注意高度相同时编号小的优先。
- **2015C林铮翔**：第一次代码只有20分，换思路后AC，还提到数据大时结构体数组要定义大一些。 

---
处理用时：33.38秒
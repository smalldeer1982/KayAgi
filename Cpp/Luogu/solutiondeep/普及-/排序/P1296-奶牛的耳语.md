# 题目信息

# 奶牛的耳语

## 题目描述

在你的养牛场，所有的奶牛都养在一排呈直线的牛栏中。一共有 $n$ 头奶牛，其中第 $i$ 头牛在直线上所处的位置可以用一个整数坐标 $p_i(0\le p_i \le 10^8)$ 来表示。在无聊的日子里，奶牛们常常在自己的牛栏里与其它奶牛交流一些八卦新闻。每头奶牛发出的声音响度是一样的，而由于声波的能量衰减，某头奶牛发出的声音只能被与它距离不超过 $d(0 \le d \le 10^4)$ 的奶牛所听到，这样这对奶牛就称为可以相互交流的。现在给出所有奶牛的位置和声音所能传播的最远距离 $d$ ，请你编个程序来计算你的养牛场里究竟有多少对可以相互交流的奶牛。

## 说明/提示

数据规模

对于 $40\%$ 的数据，$1 \leq n \leq 10^3$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$。

## 样例 #1

### 输入

```
5 10
10 12 16 37 40
```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先对奶牛位置排序，再找出能相互交流的奶牛对数。排序可使后续查找更高效，而查找的实现方法多样。

#### 思路分类
- **暴力枚举**：AdzearDisjudge的题解直接两重循环遍历，复杂度$O(n^2)$，在数据规模大时易超时。
- **二分查找**：dingcx、scp233、ExcaIibur、moongazer等使用二分查找，优化了查找过程，复杂度为$O(nlogn)$。
- **双指针**：「已注销」、洛绫璃、ZHDX、autoencoder、嚯呀嚯呀、McGrady等采用双指针，利用排序后数据的有序性，复杂度$O(n)$。
- **倍增算法**：_Andy_Lin_使用倍增算法，复杂度$O(nlogn)$。
- **队列**：kdlkswb、felixwu使用队列维护窗口，复杂度$O(nlogn)$。

#### 难点解决
- 数据无序问题：所有题解都先对数据排序，保证后续操作的有序性。
- 查找效率问题：二分、双指针、倍增等方法优化查找，避免暴力枚举的高复杂度。

### 高评分题解
1. **dingcx（5星）**
    - **关键亮点**：思路清晰，详细介绍STL函数`sort`和`upper_bound`的用法，代码简洁，复杂度$O(nlogn)$。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1e6+10;
int a[MAXN];
int main(){
    int n,d,ans=0;
    scanf("%d%d",&n,&d);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++){
        int k=upper_bound(a+i+1,a+n+1,a[i]+d)-a;
        ans+=(k-i-1);
    }
    printf("%d",ans);
    return 0;
}
```
    - **核心思想**：先排序，再用`upper_bound`二分查找每头牛能交流的最远牛的位置，累加对数。

2. **「已注销」（4星）**
    - **关键亮点**：思路巧妙，利用双指针，避免二分查找的复杂性，复杂度$O(n)$。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,d,a[100001],it=2,ans;
int main(){
    scanf("%d%d",&n,&d);
    for(int i=1;i<=n;++i)scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    for(int i=1;i<n;++i){
        while(it<=n&&a[it]-a[i]<=d)++it;
        --it;
        ans+=it-i;
    }
    printf("%d",ans);
}
```
    - **核心思想**：排序后，用双指针`i`和`it`，`it`记录能与`i`交流的最远牛的位置，累加对数。

3. **autoencoder（4星）**
    - **关键亮点**：使用滑动窗口思想，代码简洁，复杂度$O(nlogn)$。
    - **核心代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int p[1000001];
int main() {
    int n, d, count = 0;
    cin >> n >> d;
    for (int i = 0; i < n; i++) {
        cin >> p[i];
    }
    sort(p, p+n);
    p[n] = p[n-1] + d + 1;
    int i = 0, j = 0;
    while (i <= n) {
        if (p[i] - p[j] > d) {
            count += i - j - 1;
            j++;
        } else {
            i++;
        }
    }
    cout << count << endl;
}
```
    - **核心思想**：排序后，用双指针`i`和`j`维护滑动窗口，窗口大小不超过`d`，累加窗口内奶牛对数。

### 最优关键思路或技巧
- **排序**：将无序数据排序，为后续查找提供便利。
- **双指针**：利用排序后数据的有序性，避免重复计算，降低复杂度。
- **二分查找**：在有序数组中快速定位，优化查找效率。

### 拓展思路
同类型题或类似算法套路：
- 区间统计问题：如统计满足一定条件的区间数量，可使用双指针或二分查找。
- 滑动窗口问题：维护一个固定大小或动态大小的窗口，统计窗口内元素的信息。

### 推荐题目
- P1102 A-B 数对：给定一个数列和一个差值$C$，求满足$A - B = C$的数对数量。
- P1638 逛画展：给定一个序列和一个整数$m$，求最短的连续子序列，包含所有$m$种不同的元素。
- P2036 [COCI2008-2009#2] PERKET：给定$n$种食材，每种食材有酸度和苦度，选择若干食材，使酸度乘积与苦度和的差值最小。

### 个人心得摘录与总结
- **kdlkswb**：提醒要记得排序，否则会WA，说明输入数据无序时排序的重要性。
- **嚯呀嚯呀**：一开始以为数据默认有序，结果WA，强调要仔细审题，不能想当然。

---
处理用时：32.26秒
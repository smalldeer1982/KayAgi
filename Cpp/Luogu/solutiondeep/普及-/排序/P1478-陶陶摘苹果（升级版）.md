# 题目信息

# 陶陶摘苹果（升级版）

## 题目描述

又是一年秋季时，陶陶家的苹果树结了 $n$ 个果子。陶陶又跑去摘苹果，这次他有一个 $a$ 公分的椅子。当他手够不着时，他会站到椅子上再试试。

这次与 NOIp2005 普及组第一题不同的是：陶陶之前搬凳子，力气只剩下 $s$ 了。当然，每次摘苹果时都要用一定的力气。陶陶想知道在 $s<0$ 之前最多能摘到多少个苹果。

现在已知 $n$ 个苹果到达地上的高度 $x_i$，椅子的高度 $a$，陶陶手伸直的最大长度 $b$，陶陶所剩的力气 $s$，陶陶摘一个苹果需要的力气 $y_i$，求陶陶最多能摘到多少个苹果。


## 说明/提示

对于 $100\%$ 的数据，$n\leq 5000$, $a\leq 50$, $b\leq 200$, $s\leq 1000$, $x_i\leq 280$, $y_i\leq 100$。


## 样例 #1

### 输入

```
8 15
20 130
120 3
150 2
110 7
180 1
50 8
200 0
140 3
120 2```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解针对“陶陶摘苹果（升级版）”问题，提供了多种思路和算法。整体可分为贪心、搜索、动态规划三大类。贪心算法因思路简单、时间复杂度低成为多数题解的选择；搜索算法原始版本易超时，经优化后性能有所提升；动态规划则将问题转化为背包问题求解。

### 所选题解
- **作者：ASZIIIS（5星）**
    - **关键亮点**：思路全面，详细阐述了搜索、动态规划、贪心三种算法的实现与优化过程，对各算法的优缺点和适用场景分析透彻，代码注释丰富，便于理解。
    - **个人心得**：作者回顾自己入门时的代码，感慨当年就会用贪心和快排，如今快排却遗忘，由此激发一题多解的欲望，体现了对算法的深入思考和不断探索精神。
- **作者：灯芯糕（4星）**
    - **关键亮点**：巧妙利用桶排序，代码简洁，时间和空间复杂度低，充分利用题目给定的数据范围，是一种高效且独特的解法。
- **作者：tengkaize（4星）**
    - **关键亮点**：不仅给出常规做法，还运用标准库和C++11语法简化代码，展示了现代C++的强大功能，同时提供了C#的Linq解法，拓宽了思路。

### 重点代码及核心实现思想
#### ASZIIIS - 贪心算法
```cpp
#include<iostream>
#include<algorithm> 
using namespace std;
int n,s,a,b,x_,y_,can,rest,ans;
struct apple{
    int xi,yi;
}ap[50005];
int cmp(apple x,apple y){
    return x.yi<y.yi;
}
int main(){
    cin>>n>>s>>a>>b;
    for(int i=1;i<=n;i++){
        cin>>x_>>y_;
        if(x_<=a+b){
            can++;
            ap[can].xi=x_;
            ap[can].yi=y_;
        }
    }
    sort(ap+1,ap+can+1,cmp);
    rest=s;
    ans=0;
    for(int i=1;rest>=ap[i].yi&&i<=can;i++){
        ans++;
        rest-=ap[i].yi;
    }
    cout<<ans;
    return 0;
} 
```
**核心思想**：先筛选出陶陶能够到的苹果，再按摘苹果所需力气从小到大排序，依次选择力气最小的苹果，直到力气不足。

#### 灯芯糕 - 桶排序
```cpp
#include<iostream>
using namespace std;
int c[101];//定义一百个桶子，c[i]代表用i个力气能摘到的苹果的数目
int main(){
    int n,s,h,a,b,i,t=0; 
    cin>>n>>s>>h>>i;h+=i;
    for(i=1;i<=n;i++){
        cin>>a>>b;
        if(a<=h)c[b]++;
    }
    for(i=0;i<=100&&s>=0;i++){
        while(c[i]){
            s-=i;
            t++; 
            c[i]--; 
            if(s<0){
                t--; 
                break;
            }
        }
    }
    cout<<t;
    return 0;
}
```
**核心思想**：利用桶排序对每个苹果所需的力气进行统计，按力气从小到大的顺序选择苹果，直到力气耗尽。

#### tengkaize - C++11 简化代码
```c++
#include <iostream>
#include <iterator>
#include <algorithm>
#include <vector>

using namespace std;

struct Apple {
    int height;
    int weight;
};

istream& operator>>(istream& in, Apple& a) {
    in >> a.height >> a.weight;
    return in;
}

int main() {
    int n, s, a, b, h;
    cin >> n >> s >> a >> b;
    h = a + b;
    vector<Apple> apples;
    copy_if(
        istream_iterator<Apple>(cin),
        istream_iterator<Apple>(),
        back_inserter(apples),
        [h](const Apple& a) { return a.height <= h; }
    );
    sort(apples.begin(), apples.end(), [](const Apple& a1, const Apple& a2) {
        return a1.weight < a2.weight;
    });
    cout << count_if(apples.begin(), apples.end(), [&s](const Apple& a) {
        return (s -= a.weight) >= 0;
    });
    return 0;
}
```
**核心思想**：使用`copy_if`筛选出能够到的苹果，用`sort`按所需力气排序，`count_if`统计能摘到的苹果数量，借助Lambda表达式和标准库简化代码。

### 最优关键思路或技巧
- **贪心策略**：由于每个苹果价值相同，优先选择所需力气最小的苹果，可在有限力气下摘到最多苹果。
- **筛选优化**：在输入或处理数据时，提前排除够不到的苹果，减少后续处理的数据量。
- **记忆化搜索与剪枝**：对搜索算法进行优化，避免重复计算和无效搜索，提高效率。
- **利用标准库**：如`sort`、`copy_if`、`count_if`等，简化代码实现，提高开发效率。

### 拓展思路
同类型题多为资源有限下的最优选择问题，如背包问题的变种、活动选择问题等。解题关键在于分析问题特点，选择合适的算法，如贪心、动态规划等。

### 推荐题目
- P1048 [采药](https://www.luogu.com.cn/problem/P1048)：经典的01背包问题，与本题动态规划解法思路相似。
- P1223 [排队接水](https://www.luogu.com.cn/problem/P1223)：贪心算法的典型应用，通过合理排序解决问题。
- P2240 [硬币翻转](https://www.luogu.com.cn/problem/P2240)：可使用贪心算法求解，在一定条件下做出最优选择。 

---
处理用时：44.65秒
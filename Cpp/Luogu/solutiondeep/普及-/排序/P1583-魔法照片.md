# 题目信息

# 魔法照片

## 题目描述

一共有 $n$ 个人（以 $1\sim n$ 编号）向佳佳要照片，而佳佳只能把照片给其中的 $k$ 个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值 $W_i$。然后将初始权值从大到小进行排序，每人就有了一个序号 $D_i$（取值同样是 $1\sim n$）。按照这个序号对 $10$ 取模的值将这些人分为 $10$ 类。也就是说定义每个人的类别序号 $C_i$ 的值为 $(D_i-1)\bmod 10 +1$，显然类别序号的取值为 $1 \sim 10$。第 $i$ 类的人将会额外得到 $E_i$ 的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的 $k$ 个人，并输出他们的编号。**在排序中，如果两人的 $E_i$ 相同，编号小的优先。**

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 20000$，$1\leq k\leq n$，保证所有数据均在 `int` 范围之内。

## 样例 #1

### 输入

```
10 10
1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20
```

### 输出

```
10 9 8 7 6 5 4 3 2 1
```

# AI分析结果

### 综合分析与结论
这些题解整体思路一致，均是按照“输入 - 第一次排序 - 分类加额外权值 - 第二次排序 - 输出前 k 大权值对应编号”的步骤来解决问题。算法要点在于排序，大部分题解使用 `sort` 函数，部分手动实现排序算法。难点在于理解编号、序号和类别序号的区别，以及排序时权值相同情况下编号小的优先规则。

### 高评分题解
1. **作者：CreeperK（5星）**
    - **关键亮点**：思路清晰，详细给出推导示例，代码注释丰富，易于理解。
    - **个人心得**：作者提到题目很绕，交了四五次才最终AC，提醒读者注意题目细节。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int e[12],n,k;
struct person{
    int w; //权值 
    int num; //编号 
    int d; //类别 
}p[20010]; //储存每个人的信息 
int w_comp(const person &a,const person &b){
    if(a.w!=b.w) return a.w>b.w; //从大到小排序 
    return a.num<b.num; //序号小优先 
} //结构体排序 
int main(){
    scanf("%d%d",&n,&k);
    for(int i=0;i<10;i++) scanf("%d",&e[i]);
    for(int i=0;i<n;i++){
        scanf("%d",&p[i].w);
        p[i].num=i+1;
    } //读入+编号 
    sort(p,p+n,w_comp); //第一次排序 
    for(int i=0;i<n;i++){
        p[i].d=i%10; //分类 
        p[i].w+=e[p[i].d]; //加上e[i] 
    }
    sort(p,p+n,w_comp); //第二次排序 
    for(int i=0;i<k;i++) printf("%d ",p[i].num);
}
```
2. **作者：Aehnuwx（4星）**
    - **关键亮点**：代码简洁，仅二十多行，注释清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxN 20005
struct Node{
    int id,w;
}p[maxN]; //结构体，在排序时方便些
int n,k,E[11];
bool cmp(Node,Node); //排序的函数（其实可以用重载运算符，但我太懒）
int main(){
    scanf("%d%d",&n,&k); //输入
    for(int i=1;i<=10;i++) scanf("%d",&E[i]);
    for(int i=0;i<n;i++){
        scanf("%d",&p[i].w);
        p[i].id=i+1; //由于我i是从0开始的，所以要加个1    
    } 
    sort(p,p+n,cmp); //sort函数，需带algorithm头文件（虽然我带的是万能头文件）。这是第一次排序
    for(int i=0;i<n;i++)
        p[i].w+=E[i%10+1];
    sort(p,p+n,cmp); //然后这就是第二次排序
    for(int i=0;i<k;i++) printf("%d ",p[i].id); //输出
    return 0;    
}
bool cmp(Node a,Node b){
    if(a.w==b.w) return a.id<b.id;
    return a.w>b.w;
}
```
3. **作者：微香玉烛暗（4星）**
    - **关键亮点**：使用快读优化输入，代码有详细解释，思路清晰。
    - **核心代码**：
```cpp
#include<cstdio>
#include<string>
#include<algorithm>
using namespace std;

int n,k,e[15]; //变量……
struct st{
    int num,sum;
}a[20005]; //先定义结构体

int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    for (;!isdigit(ch); ch = getchar())
    if (ch == '-') f = -1;
    for (; isdigit(ch); ch = getchar())
    x = x * 10 + ch - '0';
    return x * f;
} //快读，应该不用结束了吧。。

bool cmp(st x,st y) //compare排序函数
{
    if (x.sum!=y.sum) return x.sum>y.sum; //这很重要！
    //判断是用sum排序还是用num下标排序
    else return x.num<y.num;
}

int main()
{
    n=read();
    k=read(); //我最爱快读了！
    for (int i=1;i<=10/*只有10个数*/;i++)
    	e[i]=read(); //数组读入
    for (int i=1;i<=n;i++)
    {
        a[i].sum=read(); //读入的是sum
        a[i].num=i; //下标是num
    }
    sort(a+1,a+n+1,cmp); //一排
    for (int i=1;i<=n;i++)
    	a[i].sum+=e[(i-1)%10+1]; //这一步是核心代码，请确保看明白！
    sort(a+1,a+n+1,cmp); //操作完后二排
    for (int i=1;i<=k;i++)
    	printf("%d ",a[i].num); //输出
    return 0;
    //并不怎么华丽地结束了。
}
```

### 最优关键思路或技巧
- **数据结构**：使用结构体存储每个人的编号、权值等信息，方便排序和处理。
- **排序规则**：自定义排序函数，确保权值相同情况下编号小的优先。
- **代码实现**：合理利用 `sort` 函数简化排序操作，部分题解使用快读优化输入。

### 可拓展之处
同类型题可能会改变分类规则、额外权值计算方式或排序规则等。类似算法套路为多次排序结合特定规则处理数据，可应用于成绩排名、游戏角色属性排序等场景。

### 洛谷相似题目推荐
1. P1177 【模板】快速排序
2. P1309 瑞士轮
3. P1908 逆序对

### 个人心得摘录与总结
- **CreeperK**：题目很绕，多次提交才AC，提醒注意题目细节。
- **MRZMRZ**：强调题目描述虽清晰，但要注意排序规则、编号与序号区别、额外权值计算和输出数量等坑点。
- **debiluz**：提醒注意编号问题，以及数组下标从 0 还是 1 开始对取余操作的影响。 

---
处理用时：41.72秒
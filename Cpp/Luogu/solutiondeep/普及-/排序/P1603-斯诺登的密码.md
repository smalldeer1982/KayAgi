# 题目信息

# 斯诺登的密码

## 题目背景

根据斯诺登事件出的一道水题


## 题目描述

2013 年 X 月 X 日，俄罗斯办理了斯诺登的护照，于是他混迹于一架开往委内瑞拉的飞机。但是，这件事情太不周密了，因为 FBI 的间谍早已获悉他的具体位置——但这不是最重要的——最重要的是如果要去委内瑞拉，那么就要经过古巴，而经过古巴的路在美国的掌控之中。

丧心病狂的奥巴马迫降斯诺登的飞机，搜查时却发现，斯诺登杳无踪迹。但是，在据说是斯诺登的座位上，发现了一张纸条。纸条由纯英文构成：`Obama is a two five zero.`（以 `.` 结束输出，只有 $6$ 个单词+一个句号，句子开头如没有大写亦为合法）这句话虽然有点无厘头，但是警官陈珺骛发现这是一条极其重要的线索。他在斯诺登截获的一台笔记本中找到了一个 C++ 程序，输入这条句子后立马给出了相对应的密码。陈珺鹜高兴得晕了过去，身为警官的你把字条和程序带上了飞机，准备飞往曼哈顿国际机场，但是在飞机上检查的时候发现——程序被粉碎了！飞机抵达华盛顿只剩 $5$ 分钟，你必须在这 $5$ 分钟内编写（杜撰）一个程序，免受上司的 $10000000000 \bmod 10$ 大板。破译密码的步骤如下：

（1）找出句子中所有用英文表示的数字 $(\leq 20)$，列举在下：

正规：`one two three four five six seven eight nine ten eleven twelve`
           `thirteen fourteen fifteen sixteen seventeen eighteen nineteen             twenty`

非正规：`a both another first second third`。为避免造成歧义，`another` 算作 $1$ 处理。

（2）将这些数字平方后对 $100$ 取模，如 $00,05,11,19,86,99$。

（3）把这些两位数按数位排成一行，组成一个新数，如果开头为 $0$，就去 $0$。

（4）找出所有排列方法中最小的一个数，即为密码。

// 数据已经修正 By absi2011 如果还有问题请联系我


## 样例 #1

### 输入

```
Black Obama is two five zero .```

### 输出

```
425```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先将输入句子中的英文数字转换为对应的数值，平方后对 100 取模，再将结果排序，最后按规则拼接成最小的数输出。在实现过程中，不同题解采用了不同的数据结构和算法技巧，如使用数组、`map`、字符串处理等。

### 高分题解
1. **作者：ZigZagKmp（5星）**
    - **关键亮点**：思路清晰，代码注释详细，使用 `printf("%.2d",a[i])` 处理输出格式，避免了复杂的字符串处理。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
char dic[30][20]={"zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty","a","both","another","first","second","third"};
int di[30]={0,1,4,9,16,25,36,49,64,81,00,21,44,69,96,25,56,89,24,61,0,1,4,1,1,4,9};
unsigned long long int a[10],top,flag;
int i,j;
char s[100];
int main()
{
    for(i=1;i<=6;i++)
    {
        scanf("%s",&s);
        for(j=1;j<=26;j++)
        {
            if(!strcmp(s,dic[j]))
            {
                a[++top]=di[j];
                break;
            }
        }
    }
    sort(a+1,a+top+1);
    for(i=1;i<=top;i++)
    {
        if(flag)
        {
            printf("%.2d",a[i]);
        }
        else
        {
            if(a[i])
            { 
                printf("%d",a[i]);
                flag=1;
            }
        }
    }
    if(!flag)printf("0");
    return 0;
}
```
    - **核心实现思想**：通过两个数组 `dic` 和 `di` 存储英文数字和对应的平方取模结果，遍历输入的单词，找到匹配的英文数字后将对应结果存入数组 `a`，排序后按规则输出。

2. **作者：Maktub（4星）**
    - **关键亮点**：使用 `map` 存储英文数字和对应的数值，简化了查找过程，代码简洁易懂。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
map<string,int>q;
const int mx=66;
int top;
int st[mx];
string s;
int main(){
    q["one"]=1;q["two"]=2;q["three"]=3;q["four"]=4;q["five"]=5;q["six"]=6;q["seven"]=7;q["eight"]=8;q["nine"]=9;q["ten"]=10;
    q["eleven"]=11;q["twelve"]=12;q["thirteen"]=13;q["fourteen"]=14;q["fifteen"]=15;q["sixteen"]=16;q["seventeen"]=17;q["eighteen"]=18;q["nineteen"]=19;q["twenty"]=20;
    q["a"]=1;q["both"]=2;q["another"]=1;q["first"]=1;q["second"]=2;q["third"]=3;
    for(int i=1;i<=6;i++){
        cin>>s;
        if(q[s]){
            int k=q[s]*q[s]%100;
            if(k==0)continue;
            st[++top]=k;
        }
    }
    sort(st+1,st+top+1);
    cout<<st[1];
    for(int i=2;i<=top;i++){
        if(st[i]<10)cout<<0;
        cout<<st[i];
    }
    return 0;
}
```
    - **核心实现思想**：使用 `map` `q` 存储英文数字和对应的数值，遍历输入的单词，若单词在 `map` 中存在，则将其平方取模结果存入数组 `st`，排序后按规则输出。

3. **作者：hsfzLZH1（4星）**
    - **关键亮点**：使用 `string` 和 `map` 处理字符串和映射关系，详细解释了排序的原理，代码规范。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<map>
#include<string>
using namespace std;
map<string,int>m;
int l,cur;
string s,ans[6];
int main()
{
    m["one"]=1;m["two"]=2;m["three"]=3;m["four"]=4;m["five"]=5;
    m["six"]=6;m["seven"]=7;m["eight"]=8;m["nine"]=9;m["ten"]=10;
    m["eleven"]=11;m["twelve"]=12;m["thirteen"]=13;m["fourteen"]=14;m["fifteen"]=15;
    m["sixteen"]=16;m["seventeen"]=17;m["eighteen"]=18;m["nineteen"]=19;m["twenty"]=20;
    m["a"]=1;m["both"]=2;m["another"]=1;m["first"]=1;m["second"]=2;m["third"]=3;
    for(int i=0;i<6;i++)
    {
        cin>>s;
        l=s.length();
        for(int j=0;j<l;j++)if(s[j]<='Z'&&s[j]>='A')s[j]+='a'-'A';
        if(m[s])
        {
            ans[cur]+=(m[s]*m[s]%100)/10+'0'; 
            ans[cur]+=(m[s]*m[s]%100)%10+'0';
            cur++;
        }
    }
    if(cur==0){cout<<0<<endl;return 0;}
    sort(ans,ans+cur);
    if(ans[0][0]=='0')cout<<ans[0][1];
    else cout<<ans[0];
    for(int i=1;i<cur;i++)cout<<ans[i];
    cout<<endl;
    return 0;
}
```
    - **核心实现思想**：使用 `map` `m` 存储英文数字和对应的数值，遍历输入的单词，将其转换为小写后在 `map` 中查找，若存在则将平方取模结果以字符串形式存入数组 `ans`，排序后按规则输出。

### 最优关键思路或技巧
- **数据结构**：使用 `map` 可以方便地实现英文数字和数值的映射，提高查找效率。
- **输出处理**：使用 `printf("%.2d",a[i])` 或字符串拼接处理输出格式，避免复杂的判断。
- **排序**：将数字按从小到大排序可以得到最小的排列结果。

### 拓展思路
同类型题可以是将其他形式的字符表示转换为数值，再进行特定运算和排序，如罗马数字转阿拉伯数字后进行计算。类似算法套路包括使用映射表存储对应关系，排序算法处理结果等。

### 推荐题目
1. **P1012 拼数**：将一组数字拼接成最大的数，与本题排序思路类似。
2. **P1107 最大整数**：同样是拼接数字得到最大结果的题目。
3. **P1598 垂直柱状图**：涉及字符串处理和字符统计，与本题的字符串操作有一定关联。

### 个人心得摘录与总结
- **作者：ZigZagKmp**：提到题目坑点主要在输出规则（#3 和 #4），使用 `printf("%.2d",a[i])` 处理输出格式。
- **作者：jiezi**：使用字符串哈希解题，认为哈希不用动脑子，不用 STL（除 `string`），不用特判，代码漂亮。
- **作者：Error_Eric**：指出题目坑点包括个位数要加 0、第一个数不能加 0、没有输出任何数要加 0 等。
- **作者：Sounwy**：强调输出的第一步处理很重要，否则会导致 WA。
- **作者：zhengrunzhe**：提到第三个点有问题，需要对无指定单词的情况进行特判输出 0。
- **作者：charliejiang_0w0_**：认为第三个点有毒，题目数据可能存在问题。

这些心得主要集中在题目坑点和调试过程中遇到的

---
处理用时：60.05秒
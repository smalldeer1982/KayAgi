# 题目信息

# 象棋比赛

## 题目描述

有 $N$ 个人要参加国际象棋比赛，该比赛要进行 $K$ 场对弈。每个人最多参加两场对弈，最少参加零场对弈。每个人都有一个与其他人不相同的等级（用一个正整数来表示）。

在对弈中，等级高的人必须用黑色的棋子，等级低的人必须用白色的棋子。每个人最多只能用一次黑色的棋子和一次白色的棋子。为增加比赛的可观度，观众希望 $K$ 场对弈中双方的等级差的总和最小。

比如有 $7$ 个选手，他们的等级分别是 $30,17,26,41,19,38,18$，要进行 $3$ 场比赛。最好的安排是选手 $2$ 对选手 $7$，选手 $7$ 对选手 $5$，选手 $6$ 对选手 $4$。此时等级差的总和等于 $(18-17)+(19-18)+(41-38)=5$ 达到最小。

## 说明/提示

### 数据范围及约定

- 在 $90\%$ 的数据中，$1 \le N \le 3000$；
- 在 $100\%$ 的数据中，$1 \le N \le 100000$。

保证所有输入数据中等级的值小于 $10^9$，$1 \le K \le N-1$。

## 样例 #1

### 输入

```
7 3
30
17
26
41
19
38
18```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
这些题解的核心思路一致：先将选手等级排序，计算相邻选手等级差，再对等级差排序，最后取前 K 个等级差求和。不同题解的差异主要在于排序算法的选择，涵盖了冒泡排序、选择排序、快速排序、归并排序、堆排序、桶排等多种排序算法。

### 所选题解
- **作者：_LanFeng_（5星）**
    - **关键亮点**：思路清晰，代码简洁，使用标准库函数 `sort` 实现排序，提高了代码的可读性和效率。
    - **核心代码**：
```cpp
#include<iostream> 
#include<cstdio> 
#include<algorithm> 
using namespace std; 
int main()
{
    int n,k,i,a[100001],b[100001],ans=0;
    scanf("%d%d",&n,&k);
    for(i=1;i<=n;i++)
        scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    for(i=1;i<=n-1;i++)
        b[i]=a[i+1]-a[i];
    sort(b+1,b+n);
    for(i=1;i<=k;i++)
        ans+=b[i];
    printf("%d",ans);
    return 0;
}
```
    - **核心实现思想**：先读取选手等级，使用 `sort` 函数对等级数组排序，计算相邻等级差存入另一个数组，再次使用 `sort` 函数对等级差数组排序，最后累加前 K 个等级差得到结果。

- **作者：Pengsibo（4星）**
    - **关键亮点**：详细介绍了多种排序算法，包括不同时间复杂度的排序算法及各自的实现代码，适合学习排序算法。
    - **核心代码（快速排序）**：
```cpp
void qsort(int l,int r)
{
    int i=l,j=r;
    int mid=a[(l+r)>>1],t;
    while(1)
    {
        while (mid>a[i])i++;
        while (mid<a[j])j--;
        if (i<=j)
        {
            swap(a[i],a[j]);
            i++;j--;
        }
        if (i>j) break;
    }
    if (j>l) qsort(l,j);
    if (i<r) qsort(i,r);
}
```
    - **核心实现思想**：采用二分法，以中间值为基准，将数组分为两部分，左边找比中间值小的，右边找比中间值大的，交换位置，递归处理左右两部分。

- **作者：我太强了（4星）**
    - **关键亮点**：使用归并排序解决问题，强调了归并排序的稳定性和时间复杂度优势，适合对排序稳定性有要求的场景。
    - **核心代码（归并排序）**：
```cpp
void msort(int l,int r)
{
    if(l==r) return;
    int mid=(l+r)/2;
    msort(l,mid); msort(mid+1,r);
    int left=l,right=mid+1,cnt=l;
    while(left<=mid&&right<=r)
        if(a[left]<=a[right]) 
            b[cnt++]=a[left++];
        else b[cnt++]=a[right++];
    while(left<=mid) b[cnt++]=a[left++];
    while(right<=r) b[cnt++]=a[right++];
    for(int i=l;i<=r;i++) a[i]=b[i];
    return;
}
```
    - **核心实现思想**：采用分治策略，将数组拆半递归排序，再合并两个有序子数组。

### 最优关键思路或技巧
- **思维方式**：利用贪心思想，要使等级差总和最小，选择相邻选手比赛。
- **算法优化**：使用标准库的 `sort` 函数，代码简洁且效率高；对于对排序稳定性有要求的场景，可选择归并排序。
- **代码实现技巧**：合理使用数组存储数据和中间结果，便于后续处理。

### 可拓展之处
同类型题可拓展到其他需要求最小差值和的场景，如安排任务使任务时间差总和最小等。类似算法套路是先排序，再计算差值，最后对差值排序取前 K 小值求和。

### 推荐题目
- [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
- [P1093 奖学金](https://www.luogu.com.cn/problem/P1093)

### 个人心得摘录与总结
- **作者：ViXpop**：一开始考虑使用 flag 标记来满足“每个人最多只能用一次黑色的棋子和一次白色的棋子”的条件，AC 后发现将差值排序后，一个人最多本身就只会用两次，无需标记。总结：在解题时要仔细分析题目条件，避免过度设计。

---
处理用时：31.77秒
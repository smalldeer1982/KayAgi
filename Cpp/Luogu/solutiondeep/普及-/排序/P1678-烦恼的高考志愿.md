# 题目信息

# 烦恼的高考志愿

## 题目背景

计算机竞赛小组的神牛 V 神终于结束了高考，然而作为班长的他还不能闲下来，班主任老 t 给了他一个艰巨的任务：帮同学找出最合理的大学填报方案。可是 v 神太忙了，身后还有一群小姑娘等着和他约会，于是他想到了同为计算机竞赛小组的你，请你帮他完成这个艰巨的任务。


## 题目描述

现有 $m$ 所学校，每所学校预计分数线是 $a_i$。有 $n$ 位学生，估分分别为 $b_i$。

根据 $n$ 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。


## 说明/提示

数据范围：

对于 $30\%$ 的数据，$1\leq n,m\leq1000$，估分和录取线 $\leq10000$；

对于 $100\%$ 的数据，$1\leq n,m\leq100000$，估分和录取线 $\leq 1000000$ 且均为非负整数。


## 样例 #1

### 输入

```
4 3
513 598 567 689
500 600 550
```

### 输出

```
32```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效为学生匹配最接近分数线的学校展开，多数采用排序后二分查找的思路，也有贪心、平衡树等方法。二分查找利用有序数组特性，快速定位接近学生估分的分数线，复杂度为 $O(m \log n)$；贪心通过排序后顺序查找，复杂度相对较高；平衡树则借助数据结构特性解决问题，但代码复杂。

### 所选题解
- **作者：06ray（5星）**
    - **关键亮点**：思路清晰，详细阐述二分查找过程，代码注释丰富，复杂度分析明确。
    - **核心代码**：
```cpp
sort(a + 1, a + n + 1);
int ans = 0;
for (int i = 1; i <= m; i++) {
    int l = 0, r = n + 1;
    while (l < r) {
        int mid = (l + r) / 2;
        if (a[mid] <= b[i]) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    if (b[i] <= a[1]) {
        ans += a[1] - b[i];
    } else {
        ans += min(abs(a[l - 1] - b[i]), abs(a[l] - b[i]));
    }
}
```
    - **核心思想**：先对学校分数线排序，然后对每个学生估分进行二分查找，找到最后一个小于等于该估分的分数线位置，再比较该位置前后分数线与估分差值的绝对值，取最小值累加。

- **作者：Viston（4星）**
    - **关键亮点**：巧妙运用 C++ 内置的 `lower_bound` 函数简化二分查找过程，代码简洁。
    - **核心代码**：
```cpp
sort(c + 1, c + a + 1);
for (i = 1; i <= b; i++) {
    cin >> d;
    e = lower_bound(c + 1, c + a + 1, d) - c;
    if (e == a + 1)
        ans += d - c[a];
    else if (e == 1)
        ans += c[1] - d;
    else
        ans += min(abs(c[e] - d), abs(d - c[e - 1]));
}
```
    - **核心思想**：排序后，使用 `lower_bound` 找到第一个大于等于学生估分的分数线位置，根据位置情况计算最小差值并累加。

- **作者：梦之__泪伤（4星）**
    - **关键亮点**：代码结构清晰，封装了二分查找函数，有快读优化。
    - **核心代码**：
```cpp
sort(d, d + m);
long long ans = 0;
for (int i = 0; i < n; i++) {
    int x; cin >> x;
    ans += bfind(x);
}

int bfind(int x) {
    int l = 0, r = m - 1, ans = 1e9;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (d[mid] <= x) l = mid + 1;
        else r = mid - 1;
        ans = min(ans, abs(x - d[mid]));
    }
    return ans;
}
```
    - **核心思想**：排序后，对每个学生估分调用二分查找函数，在查找过程中记录最小差值，最后累加。

### 最优关键思路与技巧
- **二分查找**：对学校分数线排序后，利用二分查找快速定位接近学生估分的分数线，将时间复杂度从 $O(nm)$ 优化到 $O(m \log n)$。
- **STL 函数**：使用 `lower_bound` 等 C++ 内置函数，简化二分查找代码实现。

### 拓展思路
同类型题可拓展到在有序数据中查找最接近目标值的元素，如查找最接近目标温度的天气记录等。类似算法套路为排序后二分查找，或使用平衡树维护有序数据。

### 推荐题目
- [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)：排序后二分查找满足条件的数对。
- [P1824 进击的奶牛](https://www.luogu.com.cn/problem/P1824)：二分答案求解最优解。
- [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：二分查找合适的跳跃距离。

### 个人心得摘录与总结
- **野菜汤**：解题过程艰辛，花一周时间不断修改，最后发现第九个数据点需将 `a[0]` 数组数值开到十万才能通过，提醒要注意数据点的刁钻情况。
- **Phykyer**：使用 splay 解题时，在判断分数线和分数相等情况时被卡很久，强调处理边界条件的重要性。 

---
处理用时：27.25秒
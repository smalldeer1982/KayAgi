# 题目信息

# 双调序列

## 题目描述

电脑组的童鞋们经常玩一些智力 PK 小游戏，某月某日，发源于小朋友又发明了一种新的序列：双调序列，所谓的双调呢主要是满足如下条件描述：

假定有 $n$（$n \le 1000$）个整数（都在 `long int` 范围内，即 $-2147483648 \sim 2147483647$），双调序列的第一个数是 $n$ 个整数中的最大数，第二个数是 $n$ 个整数中的最小数，第三个数是 $n$ 个数中的第二大数，第四个数是 $n$ 个数中的第二小数……取过的数不能再取，依次类推，直到结束。

聪明的你听完描述就抿嘴笑了吧？那就请你用程序正确的帮他找出这 $n$ 个数的双调序列。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 1000$。


## 样例 #1

### 输入

```
5
10
-1
3
3
-9
```

### 输出

```
10
-9
3
-1
3
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先对输入的整数序列进行排序，再按照双调序列的规则输出。排序方法多样，包括 STL 的 `sort` 函数、冒泡排序、选择排序、堆排序等；输出方式也有多种，如从数组两端交替输出、使用优先队列弹出最大最小值等。

### 所选题解
- **作者：B_Qu1e7（5星）**
    - **关键亮点**：思路简洁清晰，代码简短，直接使用 STL 的 `sort` 函数排序，然后按规则输出，可读性和可维护性高。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1001];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+n+1);
    for(int i=1;i<=n/2;i++)
    {
        cout<<a[n-i+1]<<endl<<a[i]<<endl;
    }
    if(n%2)cout<<a[n/2+1]<<endl;
}
```
核心实现思想：先输入数据，用 `sort` 函数从小到大排序，接着从数组两端交替输出，最后处理奇数个元素时中间的元素。

- **作者：RedreamMer（4星）**
    - **关键亮点**：使用判断奇数偶数的方法输出，思路直观，代码简洁易懂。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int x[1001];
int main()
{
    int a;
    cin>>a;
    for(int i=1;i<=a;i++)
        cin>>x[i];
    sort(x+1,x+a+1);
    for(int i=1,j=a+1,k=0;i<=a;i++)
    {
        if(i%2==1)
            cout<<x[--j]<<endl;
        else
            cout<<x[++k]<<endl;
    }
    return 0;
}
```
核心实现思想：输入数据并排序，通过判断当前输出次数的奇偶性，决定输出数组头部或尾部的元素。

- **作者：judgejudge（4星）**
    - **关键亮点**：提供了纯排序和优先队列两种方案，思路清晰，代码规范，展示了不同的解题方法。
    - **核心代码（纯排序）**：
```cpp
#include <iostream>
#include <algorithm>
#define N 1001
using namespace std;
typedef long long ll;
ll a[N];
ll n;
inline bool cmp(ll a,ll b){
    return a>b;
}
int main(){
    register int i,j;
    cin>>n;
    for(i=1;i<=n;i++)
        cin>>a[i];
    sort(a+1,a+n+1,cmp);
    ll pl=1,pr=n;
    while(pl<=pr){
        if(pl<=pr)cout<<a[pl]<<endl,pl++;
        if(pl<=pr)cout<<a[pr]<<endl,pr--;
    }
    return 0;
}
```
核心实现思想：对数组从大到小排序，使用两个指针分别指向数组首尾，交替输出指针所指元素。
    - **核心代码（优先队列）**：
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <vector>
using namespace std;
typedef long long ll;
priority_queue<ll,vector<ll>,greater<ll> > q1;
priority_queue<ll,vector<ll>,less<ll> > q2;
ll n;
main(){
    register int i;
    scanf("%lld",&n);
    for(i=1;i<=n;i++){
        ll k;
        scanf("%lld",&k);
        q1.push(k);
        q2.push(k);
    }
    while(n){
        if(n)cout<<q2.top()<<endl,q2.pop(),n--;
        if(n)cout<<q1.top()<<endl,q1.pop(),n--;
    }
    return 0;
}
```
核心实现思想：使用两个优先队列，一个存储从小到大的元素，一个存储从大到小的元素，交替弹出队首元素输出。

### 最优关键思路或技巧
- 使用 STL 的 `sort` 函数进行排序，代码简洁，时间复杂度为 $O(nlogn)$。
- 从数组两端交替输出元素，避免复杂的逻辑判断。
- 对于奇数个元素的情况，单独处理中间元素。

### 拓展思路
同类型题或类似算法套路：
- 处理其他特殊序列的输出，如锯齿序列、波浪序列等，可先排序再按特定规则输出。
- 对于动态数据的双调序列问题，可使用平衡树（如题解中的 finger - tree）或优先队列动态维护最大最小值。

### 推荐题目
- P1177 【模板】排序：考察基本的排序算法。
- P1923 【深基9.例4】求第 k 小的数：涉及排序和查找第 k 小元素。
- P2123 皇后游戏：需要排序和贪心算法结合。

### 个人心得摘录与总结
- **transmigration**：最初使用优先队列时，先输出两个元素再判断次数，导致奇数个元素时出错，后来改为输出一个元素加一次次数并判断，成功解决问题。总结为在处理边界情况（如奇数个元素）时，要仔细考虑输出和判断的顺序。
- **秋雨**：多次提交题解未通过，强调排序后从中间往两边输出的思路。总结为明确解题思路并准确实现代码很重要，同时提交题解时要注意细节。 

---
处理用时：29.56秒
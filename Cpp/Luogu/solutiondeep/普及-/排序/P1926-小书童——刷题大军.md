# 题目信息

# 小书童——刷题大军

## 题目背景

数学是火，点亮物理的灯；物理是灯，照亮化学的路；化学是路，通向生物的坑；生物是坑，埋葬学理的人。  
文言是火，点亮历史宫灯；历史是灯，照亮社会之路；社会是路，通向哲学大坑；哲学是坑，埋葬文科生。——小 A


## 题目描述

小 A “刷题”十分猖狂，明目张胆地“刷题”。他现在在小书童里发现了 $n$ 样他喜欢的“题目”，每“题”都有他的需要时间，而老师布置了 $m$ 项作业，每项作业都有它的需要时间及分值，老师规定 $k$ 分以上算及格。小 A 只剩 $r$ 个单位时间，他想在及格的基础上更多地“刷题”。

## 说明/提示

### 数据范围及约定


对于 $100\%$ 的数据，$n\le 10$，$m\le 10$，$k\le 50$，$r\le 150$。数据保证没有不能及格的情况。


## 样例 #1

### 输入

```
3 4 20 100
15 20 50
10 15 40 40
5 5 10 15```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何让小A在及格基础上刷最多的题展开，核心在于先解决做作业达到及格分数所需的最短时间，再用剩余时间去刷题。解题方法主要分为动态规划（01背包）和深度优先搜索（DFS）两类，部分题解还结合了贪心策略。

### 高评分题解
1. **作者：slaak（5星）**
    - **关键亮点**：思路清晰，详细解释了每一步操作，代码注释丰富，使用了让`cin`变快的黑科技，同时给出了状态转移方程。
    - **核心代码**：
```cpp
for(int i=1;i<=m;i++)
{
    for(int j=r;j>=w[i];j--)//标准01背包写法
    {
        f[j] = max(f[j],f[j-w[i]] + c[i]);
    }
}
for(int i=1;i<=r;i++)
{
    if(f[i] >= k)//可以及格了
    {
        stt = r - i;//已经写作业花去的时间不能刷题了
        break;
    }
}
sort(a+1,a+n+1);
for(int i=1;i<=n;i++)
{
    stt -= a[i];//刷了一道题
    if(stt <= 0) break;//没时间了赶紧跑去学校
    stn++;//多刷了一道题
}
```
    - **核心思想**：先用01背包求出在不同时间下能获得的最大分数，找到刚好及格的时间，用总时间减去该时间得到刷题时间，再对题目按时间排序，优先刷时间短的题。

2. **作者：Alex_Wei（4星）**
    - **关键亮点**：提供了DFS的做法，思路清奇，代码中加入了剪枝操作，提高了效率。
    - **核心代码**：
```cpp
void dfs(int num,int s,int t)
{
    if(r-t<=mi)return;//剪枝
    if(s>=k)mi=r-t;
    for(int x=num+1;x<=m;x++)
        dfs(x,s+hs[x],t+ht[x]);
}
dfs(0,0,0),sort(q+1,q+n+1);
for(int x=1;x<=n;x++)if(mi>=q[x])mi-=q[x],ans++;
```
    - **核心思想**：通过DFS找出及格情况下的最长剩余时间，对题目按时间排序，用剩余时间刷尽可能多的题。

3. **作者：vectorwyx（4星）**
    - **关键亮点**：思路清晰，将问题分为做作业和刷题两部分，分别使用01背包和贪心策略，代码注释详细。
    - **核心代码**：
```cpp
for(int i=1;i<=m;++i){
    for(int j=r;j>=t[i];--j){
        dp[j]=max1(dp[j],dp[j-t[i]]+c[i]);
    }
}
for(int i=1;i<=r;++i){
    if(dp[i]>=k){
        r-=i;
        break;
    }
}
sort(p+1,p+1+n);
for(int i=1;i<=n;++i){
    r-=p[i];
    if(r<0) break;
    else ans++;
}
```
    - **核心思想**：用01背包求出在不同时间下能获得的最大分数，找到刚好及格的时间，用总时间减去该时间得到刷题时间，对题目按时间排序，优先刷时间短的题。

### 最优关键思路或技巧
- **动态规划（01背包）**：将做作业问题转化为01背包问题，通过状态转移方程`f[j] = max(f[j], f[j - w[i]] + c[i])`求出在不同时间下能获得的最大分数。
- **贪心策略**：对题目按时间排序，优先刷时间短的题，以保证在有限时间内刷最多的题。
- **剪枝优化**：在DFS中，当剩余时间小于等于当前最长剩余时间时，直接退出，减少不必要的搜索。

### 拓展思路
同类型题可考虑增加作业或题目的限制条件，如作业有先后顺序、题目有不同类型等。类似算法套路可应用于资源分配问题，如在一定预算下选择价值最大的物品组合。

### 推荐题目
1. [P1048 采药](https://www.luogu.org/problem/P1048)：经典的01背包问题，与本题做作业部分思路相似。
2. [P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles](https://www.luogu.org/problem/P1216)：动态规划基础题，可锻炼状态转移方程的推导能力。
3. [P2871 [USACO07DEC]Charm Bracelet S](https://www.luogu.org/problem/P2871)：01背包问题的变种，可加深对01背包的理解。

### 个人心得摘录与总结
- **JuicyMio**：纠结题目像01背包但不会做，看到数据范围小决定用暴搜。开始想分别搜作业和题目时间，后来发现可将两者放一起搜，简化了代码。总结是遇到问题可先分析数据范围，尝试不同思路简化问题。
- **何旭的小粉丝**：对DP标签感到疑惑，认为不一定用DP。使用冒泡排序时遇到STL模板编译不过的问题。提醒我们做题时不要局限于标签，使用工具时可能会遇到意外问题。 

---
处理用时：31.08秒
# 题目信息

# 营养膳食

## 题目描述

Mr.L 正在完成自己的增肥计划。

为了增肥，Mr.L 希望吃到更多的脂肪。然而也不能只吃高脂肪食品，那样的话就会导致缺少其他营养。

Mr.L 通过研究发现：真正的营养膳食规定某类食品不宜一次性吃超过若干份。比如就一顿饭来说，肉类不宜吃超过 $1$ 份，鱼类不宜吃超过 $1$ 份，蛋类不宜吃超过 $1$ 份，蔬菜类不宜吃超过 $2$ 份。

Mr.L 想要在营养膳食的情况下吃到更多的脂肪，当然 Mr.L 的食量也是有限的。


## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 200$，$1\leq m\leq 100$，$1\leq k\leq 100$，$1\leq a_i\leq 100$，$1\leq b_i\leq k$。

## 样例 #1

### 输入

```
6 6 3
3 3 2
15 1
15 2
10 2
15 2
10 2
5 3```

### 输出

```
60```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均为贪心算法，通过对食物按脂肪含量排序，优先选择脂肪含量高的食物，同时满足每类食物的最大份数和总食量的限制。在排序实现上，有的使用了标准库的 `sort` 函数，有的则手动实现了冒泡排序、快速排序等。

### 所选题解
- **作者：ShineEternal（5星）**
    - **关键亮点**：思路清晰，代码简洁，使用标准库 `sort` 函数进行排序，可读性高。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int b[10001];
struct ben
{
    int y,z;
}a[10001];
int cmp(const ben &a,const ben &b)
{
    return a.y>b.y;
}
int main()
{
    int n,m,k;
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&b[i]);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&a[i].y,&a[i].z);
    }
    sort(a+1,a+n+1,cmp);
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(b[a[i].z]>0&&m>0)
        {
            b[a[i].z]--;
            m--;
            ans+=a[i].y;
        }
    }
    printf("%d",ans);
    return 0;
} 
```
    - **核心实现思想**：定义结构体存储食物的脂肪含量和类别，按脂肪含量从大到小排序。遍历排序后的食物数组，若该类食物还有剩余份数且总食量未达到上限，则选择该食物并更新相关信息。

- **作者：迷残云（4星）**
    - **关键亮点**：使用结构体和标准库 `sort` 函数，代码简洁明了，思路清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,ans=0;
struct bzyq{
    int a,b;
} s[470];
int x[470];
bool cmp(bzyq i,bzyq j)
{
    return i.a>j.a;
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++)
        cin>>x[i];
    for(int i=1;i<=n;i++)
        cin>>s[i].a>>s[i].b;
    sort(s+1,s+n+1,cmp);
    int i=1;
    while(m&&i<=n)
    {
        if(x[s[i].b]>0)
        {
            ans+=s[i].a;
            m--;
            x[s[i].b]--;
        }
        i++;
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：定义结构体存储食物信息，按脂肪含量从大到小排序。使用 `while` 循环遍历食物数组，若该类食物还有剩余份数且总食量未达到上限，则选择该食物并更新相关信息。

- **作者：songhn（4星）**
    - **关键亮点**：使用结构体和标准库 `sort` 函数，代码简洁，注释清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
    int a,b;
}s[210];
inline bool operator<(const node&p1,const node&p2)
{
    return p1.a<p2.a;
}
int main()
{
    int n,m,k,num[110],pan[110]={0},ok=1,ans=0;
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++)
        cin>>num[i];
    for(int i=1;i<=n;i++)
        cin>>s[i].a>>s[i].b;
    sort(s+1,s+1+n);
    for(int i=n;i>=1;i--)
    {
        if(ok<=m)
        {
            if(pan[s[i].b]<num[s[i].b])
            {
                ans+=s[i].a;
                ok++;pan[s[i].b]++;
            }
        }
        else
            break;
    }
    cout<<ans<<endl;
    return 0;
} 
```
    - **核心实现思想**：定义结构体存储食物信息，按脂肪含量从小到大排序。从后往前遍历排序后的食物数组，若该类食物未达到最大份数且总食量未达到上限，则选择该食物并更新相关信息。

### 最优关键思路或技巧
- **使用结构体存储信息**：将食物的脂肪含量和类别封装在结构体中，方便排序和处理。
- **贪心算法**：按脂肪含量从大到小排序，优先选择脂肪含量高的食物，以达到最大脂肪摄入量。
- **使用标准库 `sort` 函数**：简化排序过程，提高代码的可读性和效率。

### 拓展思路
同类型题或类似算法套路：
- 背包问题：在一定的容量限制下，选择物品以达到最大价值。
- 区间调度问题：在多个区间中选择不冲突的区间，以达到最大覆盖。

### 推荐题目
- P1094 [NOIP2007 普及组] 纪念品分组
- P1223 排队接水
- P1803 凌乱的yyy / 线段覆盖

### 个人心得摘录与总结
- **作者：MY（一名蒟蒻）**：一开始未考虑总食量限制，导致代码WA，重新审题后修正。总结为做题时要仔细审题，考虑所有条件。
- **作者：二元长天笑**：对题目中“表示可以吃1到k类食品的最大份数”理解有误，导致代码错误，正确理解后顺利AC。强调理解题意的重要性。
- **作者：源菌**：代码使用 `while` 循环在特殊情况下会出现越界问题，添加特判后解决。提醒在使用循环时要考虑边界情况。 

---
处理用时：31.10秒
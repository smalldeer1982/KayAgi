# 题目信息

# 骑士的工作

## 题目背景

你作为一个村的村长，保卫村庄是理所当然的了。今天，村庄里来了一只恶龙，他有 $n$ 个头，恶龙到处杀人放火。你着急了。不过天无绝人之路，现在来了一个骑士团。里面有 $m$ 位成员（往下看）。


## 题目描述

每个人都可以砍掉**至多**一个大小不超过 $z_i$ 的头，需要 $z_i$ 个金币，求最小花费。


## 说明/提示

对于所有数据，$1 \le n,m \le 2 \times 10^4$，$1 \leq z_i \leq 10^5$。

## 样例 #1

### 输入

```
2 3
5 
4
7 
8
4```

### 输出

```
11```

# AI分析结果

### 综合分析与结论
本题主要是一个贪心算法的应用场景，核心在于为每个恶龙头匹配花费最小且能砍掉它的骑士，以达到最小花费的目的。各题解大多采用了排序的方法，部分使用了优先队列来简化操作。主要思路是先对恶龙头大小和骑士能力进行排序，然后依次为每个头寻找合适的骑士。

### 高评分题解
1. **作者：做梦想Peach（5星）**
    - **关键亮点**：思路清晰，使用快读优化输入，代码注释详细，对边界情况处理得当。
    - **个人心得**：作者提到“注意：you died!要感叹号，本人在此卡了半天”，提醒了大家在输出时要注意细节。
    - **核心代码**：
```cpp
inline int read () {
    register int k=0;
    register char c=getchar();
    while (c<'0'||c>'9') c=getchar();
    while (c>='0'&&c<='9') {k=k*10+c-'0';c=getchar();}
    return k;
}
sort (el+1,el+1+n);
sort (qs+1,qs+1+m);
if (n>m) {
    printf ("you died!");
    return 0;
}
int j=1;
for (i=1;i<=n;i++) {
    while (el[i]>qs[j]) j++;
    ans+=qs[j];
    if (j>m) break;
    j++;
}
if (i-1!=n) 
    printf ("you died!");
else
    printf ("%d\n",ans);
```
核心思想：先使用快读读取输入，对恶龙头和骑士能力排序，若恶龙头数量大于骑士数量则直接输出失败，然后遍历恶龙头，为每个头找到最小能砍的骑士，累加花费，最后判断是否所有头都被砍完。

2. **作者：Dog_Two（4星）**
    - **关键亮点**：使用STL库简化代码，如`lower_bound`和`erase`函数，降低了代码复杂度和出错率。
    - **核心代码**：
```cpp
sort(head+1,head+n+1);
sort(mon.begin(),mon.end());
for(int i=1;i<=n;i++){
    IT pos=lower_bound(mon.begin(),mon.end(),head[i]);
    if(pos==mon.end()){
        puts("you died!");
        return 0;
    }
    ans+=*pos; 
    mon.erase(pos);
}
```
核心思想：对恶龙头和骑士能力排序，使用`lower_bound`找到第一个能砍当前头的骑士，若找不到则输出失败，累加花费并删除该骑士。

3. **作者：Atmizz（4星）**
    - **关键亮点**：使用优先队列，省略了排序步骤，代码逻辑清晰，对边界情况判断准确。
    - **核心代码**：
```cpp
priority_queue<int,vector<int>,greater<int> > l;
priority_queue<int,vector<int>,greater<int> > q;
for(int i=1;i<=n;i++) {
    int a;
    scanf("%d",&a);
    l.push(a);
}
for(int i=1;i<=m;i++) {
    int a;
    scanf("%d",&a);
    q.push(a);
}
if(n>m) {
    cout<<"you died!";
    return 0;
}
while(!l.empty()) {
    if(q.empty() &&!l.empty()) {
        cout<<"you died!";
        return 0;
    }
    if(l.top()<=q.top()) {
        ans+=q.top();
        l.pop();
        q.pop();
    }
    if(l.top()>q.top())
        q.pop();
}
```
核心思想：使用优先队列存储恶龙头和骑士能力，若恶龙头数量大于骑士数量则直接输出失败，然后循环判断，若骑士能砍头则累加花费并更新队列，若不能则换下一个骑士。

### 最优关键思路或技巧
- **排序**：对恶龙头大小和骑士能力进行排序，能保证在遍历过程中优先选择花费最小的骑士。
- **优先队列**：使用优先队列可以省略排序步骤，自动维护元素的有序性。
- **STL库的使用**：如`lower_bound`和`erase`函数，能简化代码，降低出错率。

### 拓展思路
同类型题或类似算法套路：
- 区间调度问题：给定多个区间，选择最多不重叠的区间。
- 活动选择问题：在多个活动中选择最多的活动，要求活动时间不冲突。

### 洛谷相似题目推荐
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)

### 个人心得总结
- 做梦想Peach：注意输出格式细节，如感叹号，避免因小错误导致卡题。
- NF_水饺：使用`for`循环可能导致逻辑错误，可尝试使用`while`循环；注意特殊情况的判断，如骑士数量小于恶龙头数量。 

---
处理用时：32.55秒
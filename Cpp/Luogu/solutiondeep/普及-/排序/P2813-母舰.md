# 题目信息

# 母舰

## 题目背景

广东汕头聿怀初中 Train#3 Problem 1

（有没有红警既视感~）


## 题目描述

在小 A 的星际大战游戏中，一艘强力的母舰往往决定了一场战争的胜负。一艘母舰的攻击力是普通的 MA（Mobile Armor）无法比较的。

对于一艘母舰而言，它是由若干个攻击系统和若干个防御系统组成的。两艘母舰对决时，一艘母舰会选择用不同的攻击系统去攻击对面母舰的防御系统。当这个攻击系统的攻击力大于防御系统的防御力时，那个防御系统会被破坏掉。当一艘母舰的防御系统全部被破坏掉之后，所有的攻击都会攻击到敌方母舰本身上去造成伤害。

这样说，一艘母舰对对面的伤害在一定程度上是取决于选择的攻击对象的。

在瞬息万变的战场中，选择一个最优的攻击对象是非常重要的。所以需要写出一个战斗系统出来，判断出你的母舰最多能对对手造成多少伤害并加以实现。


## 说明/提示

#### 样例解释 #1

对方防御系统有 $3$ 个，防御值为 $1000(a),2000(b),1200(c)$，己方攻击系统有 $5$ 个，攻击值为 $2100(d)，2000(e),1200(f),1000(g),1000(h)$。第 $1$ 轮攻击的最优方案是 $d$ 攻击 $b$，$e$ 攻击 $c$，$f$ 攻击 $a$，$g$ 和 $h$ 攻击对方母舰本身，造成 $2000$ 点伤害。

#### 数据范围与约定

对于 $80 \%$ 的数据，$1 \le N,M \le 1000$。

对于 $100 \%$ 的数据，$1 \le N,M \le 10 ^ 5$。


本题为转载题目。

## 样例 #1

### 输入

```
3 5 
1000 
2000 
1200 
2100 
2000 
1200 
1000 
1000```

### 输出

```
2000```

# AI分析结果

### 综合分析与结论
这些题解大多采用贪心算法解决母舰攻击问题。核心思路是先对攻击系统和防御系统排序，然后用尽量小的攻击系统去破坏防御系统，剩余的攻击系统攻击力之和即为对母舰的最大伤害。

算法要点：
1. 对攻击和防御系统数组排序。
2. 遍历攻击系统，寻找能破坏防御系统的最小攻击系统。
3. 若能破坏则标记该攻击系统已使用，若不能则保留用于攻击母舰。
4. 若所有防御系统都被破坏，累加剩余攻击系统攻击力；否则输出 0。

解决难点：
1. 处理防御系统防御力为 0 的情况。
2. 保证用最小的攻击系统去破坏防御系统，留大的攻击母舰。

### 高评分题解
1. **作者：sjl40（5星）**
    - 关键亮点：思路清晰，代码简洁，对特殊情况（防御系统为 0）处理得当。
    - 核心代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int tf[10000000],wf[10000000];
int m,n,s,i,t;
int main()
{
    cin>>m>>n;
    for(i=1;i<=m;i++)scanf("%d",&tf[i]);
    for(i=1;i<=n;i++)scanf("%d",&wf[i]);
    sort(tf+1,tf+1+m);
    sort(wf+1,wf+1+n);
    t=1;
    for(i=1;i<=n;i++)
    {
        if(tf[t]==0)t++;
        if(tf[t]<wf[i]&&tf[t]!=0){wf[i]=0;t++;}
    }
    if(t<=m){cout<<0;return 0;}
    for(i=1;i<=n;i++)s+=wf[i];
    cout<<s;
}
```
核心思想：排序后遍历攻击系统，用最小攻击系统破坏防御系统，标记已使用，最后累加剩余攻击系统攻击力。

2. **作者：EarthGiao（4星）**
    - 关键亮点：思路详细，代码有分步解析，对核心部分解释清晰。
    - 核心代码：
```cpp
int ans=0,js=1,jss=1;
while(jss!=n + 1) {
    if(js == m + 1 && jss!= n + 1) {
        printf("0\n");
        return 0;
    }
    if(hudun[jss]==0) {
        jss++;
        continue;
    } else if(hudun[jss]<gongji[js]) {
        gongji[js]=0;
        jss++;
        js++;
        continue;
    } else {
        js++;
        continue;
    }
}
for(int i=1; i<=m; ++i) {
    ans+=gongji[i];
}
printf("%d\n",ans);
```
核心思想：使用计数器遍历攻击和防御系统，处理特殊情况，累加剩余攻击系统攻击力。

3. **作者：Saliеri（4星）**
    - 关键亮点：明确指出复杂度和贪心策略，代码简洁高效。
    - 核心代码：
```cpp
scanf("%d %d",&m,&n);
if(n <= m){printf("0");return 0;}
for(int i=1;i<=m;++i)scanf("%d",&defense[i]);
for(int i=1;i<=n;++i)scanf("%d",&attack[i]);
sort(attack+1,attack+n+1),sort(defense+1,defense+m+1);
int pa = 1;
for(int i=1;i<=m;++i){
    while(attack[pa] <= defense[i] and pa <= n)ans += attack[pa++];
    ++pa;
    if(i!= m && pa == n+1){printf("0");return 0;}
}
while(pa <= n)ans += attack[pa++];
printf("%d",ans);
```
核心思想：排序后用指针维护最小满足条件的攻击系统，累加剩余攻击系统攻击力。

### 最优关键思路或技巧
1. 贪心策略：用最小的攻击系统去破坏防御系统，留大的攻击母舰。
2. 排序：对攻击和防御系统数组排序，方便找到最小攻击系统。
3. 标记已使用的攻击系统：将已使用的攻击系统攻击力设为 0，避免重复计算。

### 可拓展之处
同类型题或类似算法套路：
1. 资源分配问题：如分配工人完成任务，用最小成本完成所有任务。
2. 区间覆盖问题：用最少的区间覆盖给定的线段。

### 洛谷相似题目推荐
1. [P2695 骑士的工作](https://www.luogu.org/problemnew/show/P2695)
2. [P1223 排队接水](https://www.luogu.org/problem/P1223)
3. [P1090 合并果子](https://www.luogu.org/problem/P1090)

### 个人心得摘录与总结
- **Saliеri**：提到有人因未加上前面无法满足任何需求的攻击系统的伤害作为答案，交了八九遍才通过，提醒要注意细节。
总结：在实现算法时，要考虑全面，注意边界情况和特殊情况的处理，避免因细节问题导致错误。 

---
处理用时：29.14秒
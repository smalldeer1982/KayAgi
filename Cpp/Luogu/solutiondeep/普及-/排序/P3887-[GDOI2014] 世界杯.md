# 题目信息

# [GDOI2014] 世界杯

## 题目描述

3014 年世界杯足球赛就要开始了！作为卫冕冠军中国足球队的教练，手下每位球员都是猛将，如何摆出最强的 11 人阵容也是一件幸福的烦恼事啊。

众所周知，足球阵容里的11个球员都会被分配到场上某一个特别的位置，而这些位置主要分为守门员、后卫、中场和前锋四种，其中守门员有且只有一个，后卫、中场和前锋的人数取决于你安排的足球阵型。形容足球阵型的方法由后卫开始计算至前锋，但不把守门员计算在内。例如，3-5-2 阵型是指有三个后卫、五个中场及两名前锋。由于竞争激烈，每位球员只会培养其中一种位置所需要的技能，所以他们每个人都只能胜任四个位置中的其中一种。

作为一个对球员能力了如指掌的教练，你给每个球员的综合水平进行量化。为了将阵型安排得更好，你的教练团队决定使用以下策略安排球员：首先按照顺序提出 $Q$ 个阵型，分别代表第一阵型、第二阵型、……、第 $Q$ 阵型。然后对于每个阵型，从仍未选择的球员中选择最好的对应数量的守门员、后卫、中场和前锋。比如说，对于第一阵型，在所有球员中选择；对于第二阵型，在除了第一阵型外的所有球员中选择；对于第三阵型，在除了第一阵型和第二阵型外的所有球员中选择；以此类推。

现在 $Q$ 个阵型都已经确定，而你需要知道的，是每个阵型的平均综合水平分别是多少。


## 说明/提示

对于 $30\%$ 数据，$K, D, M, F≤1000$，$Q≤10$；

对于 $100\%$ 数据，$1≤K, D, M, F≤10^5$，$0≤k_i, d_i, m_i, f_i≤10^8$，$1≤Q≤K$，$0≤A_i, B_i, C_i≤10$，$A_i+B_i+C_i=10$，$∑A_i≤D$，$∑B_i≤M$，$∑C_i≤F$

## 样例 #1

### 输入

```
3 10 12 4
76 60 87
78 84 84 84 81 82 72 51 77 57
85 84 62 87 88 64 81 90 80 66 88 85
65 83 63 79
2
4 5 1
4 4 2```

### 输出

```
85.64
78.00
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是贪心策略，即每次选取剩余球员中能力值最大的组成阵型。主要差异在于数据结构的使用和代码实现方式。
- **排序数组**：部分题解将球员能力值存储在数组中，排序后按顺序选取，如Ousmane_Dembele、ChinaGIAO（快排做法）等。
- **优先队列**：许多题解使用优先队列（大根堆），每次取出队首元素，方便选取最大值，如ezoixx118、Chiaro等。
- **单调队列**：Bronya18C使用单调队列，先排序再按顺序入队，依次取出。
- **前缀和**：FAYOU使用前缀和优化求和过程。
- **手写堆**：meyi手写堆实现优先队列功能。

### 所选题解
- **Ousmane_Dembele（5星）**
    - **关键亮点**：思路清晰，代码简洁易懂，直接使用排序数组实现贪心策略，未使用复杂数据结构，对初学者友好。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100005],b[100005],c[100005],d[100005];
int k,g,f,m,q;
double tbh;
bool cmp(int a,int b){
    return a>b;
}
int main(){
    cin>>k>>g>>f>>m;
    for(int i=1;i<=k;i++) cin>>a[i];
    for(int i=1;i<=g;i++) cin>>b[i];
    for(int i=1;i<=f;i++) cin>>c[i];
    for(int i=1;i<=m;i++) cin>>d[i];
    sort(a+1,a+k+1,cmp);
    sort(b+1,b+g+1,cmp);
    sort(c+1,c+f+1,cmp);
    sort(d+1,d+m+1,cmp);
    cin>>q;
    int l,z,y;
    int x=1,r=1,w=1,h=1;
    while(q--){
        cin>>l>>z>>y;
        tbh=0;
        tbh+=a[x];
        x++;
        for(int i=r;i<r+l;i++) tbh+=b[i];
        r+=l;
        for(int i=w;i<w+z;i++) tbh+=c[i];
        w+=z;
        for(int i=h;i<h+y;i++) tbh+=d[i];
        h+=y;
        printf("%.2f\n",tbh/11);
    }
    return 0;
}
```
    - **核心思想**：将守门员、后卫、中场、前锋的能力值分别存储在数组中，排序后按阵型要求依次选取，累加能力值并计算平均值。

- **ezoixx118（4星）**
    - **关键亮点**：使用优先队列（大根堆），代码简洁，时间复杂度稳定，能避免手动排序和管理数组索引的麻烦。
    - **核心代码**：
```cpp
#include<iostream>
#include<queue>
#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}
using namespace std;
priority_queue <int> k,d,m,f;
int main(){
    int K,D,M,F,x;
    rd(K);rd(D);rd(M);rd(F);
    for (int i=1;i<=K;i++){
        rd(x);
        k.push(x);
    }
    for (int i=1;i<=D;i++){
        rd(x);
        d.push(x);
    }
    for (int i=1;i<=M;i++){
        rd(x);
        m.push(x);
    }
    for (int i=1;i<=F;i++){
        rd(x);
        f.push(x);
    }
    int n,a,b,c;
    rd(n);
    for (int i=1;i<=n;i++){
        rd(a);rd(b);rd(c);
        int sum=0;
        sum+=k.top();k.pop();
        for (int j=1;j<=a;j++){
            sum+=d.top();d.pop();
        }
        for (int j=1;j<=b;j++){
            sum+=m.top();m.pop();
        }
        for (int j=1;j<=c;j++){
            sum+=f.top();f.pop();
        }
        printf("%.2f\n",(double)sum/11.0);
    }
}
```
    - **核心思想**：将不同位置球员的能力值存入优先队列，每次按阵型要求从队列中取出最大值，累加求和并计算平均值。

- **Sugarithm（4星）**
    - **关键亮点**：使用结构体封装球员信息和操作，代码结构清晰，提高了代码的复用性和可维护性。
    - **核心代码**：
```cpp
#include <cstdio>
#include <algorithm>
#define rep(i,x,y) for(int i=x;i<=y;++i)
using namespace std;
const int X=100010;
struct Type
{
    int A[X],L,p;
    void RAS()
    {
        rep(i,1,L){
            scanf("%d",&A[i]);
        }
        sort(A+1,A+1+L);
        p=L;
    }
    int Get(int cnt)
    {
        int ret=0;
        for(int End=p-cnt;p>End;--p){
            ret+=A[p];
        }
        return ret;
    }
}k,d,m,f;
int main()
{
    scanf("%d%d%d%d",&k.L,&d.L,&m.L,&f.L);
    k.RAS(),d.RAS(),m.RAS(),f.RAS();
    int Q;
    scanf("%d",&Q);
    rep(i,1,Q){
        int A,B,C;
        scanf("%d%d%d",&A,&B,&C);
        printf("%.2f\n",(double)(k.Get(1)+d.Get(A)+m.Get(B)+f.Get(C))/11);
    }
    return 0;
}
```
    - **核心思想**：定义结构体存储球员能力值，提供读取和选取操作，按阵型要求调用结构体方法选取球员并计算平均值。

### 最优关键思路或技巧
- **贪心策略**：每次选取剩余球员中能力值最大的组成阵型，保证每个阵型的综合水平最大。
- **优先队列**：使用优先队列（大根堆）可以方便地取出最大值，避免手动排序和管理数组索引，时间复杂度稳定。
- **结构体封装**：使用结构体封装球员信息和操作，提高代码的复用性和可维护性。

### 可拓展之处
同类型题可能会有更多限制条件，如球员之间的配合度、球员的体力消耗等。类似算法套路可以应用于资源分配问题，如任务分配、物资调配等，核心思路都是贪心选取最优资源。

### 洛谷相似题目推荐
1. [P1094 [NOIP2007 普及组] 纪念品分组](https://www.luogu.com.cn/problem/P1094)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

### 个人心得摘录与总结
- **fzj2007**：最初使用结构体和标记数组暴力查找未使用过的球员，导致部分测试点超时，后来通过记录已使用球员的索引优化代码，成功AC。总结是要注意算法复杂度，避免不必要的判断和循环。
- **没有输入**：强调对于数据范围较小的题目要善于模拟（暴力），但平常练习应追求正解，比赛时在不知道正解的情况下可以用暴力骗分。

---
处理用时：47.60秒
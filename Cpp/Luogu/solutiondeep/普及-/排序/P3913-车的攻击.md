# 题目信息

# 车的攻击

## 题目描述

$N \times N$ 的国际象棋棋盘上有$K$ 个车，第$i$个车位于第$R_i$行，第$C_i$ 列。求至少被一个车攻击的格子数量。

车可以攻击所有同一行或者同一列的地方。


## 说明/提示

• 对于30% 的数据，$1 \le N \le 10^3; 1 \le K \le 10^3$；

• 对于60% 的数据，$1 \le N \le 10^6; 1 \le K \le 10^6$；

• 对于100% 的数据，$1 \le N \le 10^9; 1 \le K \le 10^6; 1 \le R_i , C_i \le N$。


## 样例 #1

### 输入

```
3 2
1 2
2 2```

### 输出

```
7```

# AI分析结果

### 综合分析与结论
本题要求计算 $N \times N$ 国际象棋棋盘上 $K$ 个车至少能攻击到的格子数量。由于 $N$ 最大可达 $10^9$，直接模拟会超时，因此各题解主要围绕数学方法和去重技巧展开。

### 所选题解
- **作者：Kater_kcl（5星）**
    - **关键亮点**：思路清晰，代码简洁，使用 `unique` 函数高效去重，同时给出了详细的函数使用说明和注意事项。
    - **核心代码**：
```cpp
sort(x,x+k);
sort(y,y+k);
ll sizex=unique(x,x+k)-x;
ll sizey=unique(y,y+k)-y;
printf("%lld",n*n-(n-sizex)*(n-sizey));
```
    - **核心思想**：先对行和列坐标数组排序，再用 `unique` 函数去重，最后根据公式 $n^2-(n - sizex) \times (n - sizey)$ 计算结果。

- **作者：lzy755277（4星）**
    - **关键亮点**：代码简短，通过简单的排序和遍历去重，直接根据公式计算结果，易于理解。
    - **核心代码**：
```cpp
sort(x+1,x+k+1);
sort(y+1,y+k+1);
for(i=1;i<=k;i++)
{
    if(x[i]!=x[i+1])h++;
    if(y[i]!=y[i+1])l++;
}
cout<<n*n-(n-h)*(n-l);
```
    - **核心思想**：对行和列坐标数组排序后，遍历数组统计不同行和列的数量，再根据公式计算结果。

- **作者：Scherzo（4星）**
    - **关键亮点**：先给出 30 分的 DFS 暴力解法，再详细推导 100 分的数学解法，图文并茂，思路清晰。
    - **核心代码**：
```cpp
sort(r+1,r+k+1);
sort(c+1,c+k+1);
long long cntr=0,cntc=0;
for (int i=1;i<=k;i++)
{
    if (r[i]!=r[i+1]) cntr++;
    if (c[i]!=c[i+1]) cntc++;
}
printf("%lld",n*n-(n-cntr)*(n-cntc));
```
    - **核心思想**：对行和列坐标数组排序后，遍历数组统计不同行和列的数量，最后根据公式计算结果。

### 最优关键思路或技巧
- **数学方法**：通过计算未被攻击的格子数量，用棋盘总格子数减去未被攻击的格子数得到结果，避免了直接模拟的高复杂度。
- **去重技巧**：使用 `sort` 排序后再用 `unique` 函数或手动遍历去重，统计不同行和列的数量。

### 拓展思路
同类型题可能会改变棋子的攻击规则或增加棋子种类，解题关键依然是分析攻击范围，找出重复计算部分并去除。类似算法套路可用于解决二维平面上的覆盖问题，通过统计覆盖区域的特征来计算结果。

### 推荐题目
- P1317 低洼地：可练习 `unique` 函数的使用。
- P1093 奖学金：涉及排序和统计，锻炼数据处理能力。
- P1104 生日：同样需要排序和去重，巩固相关技巧。

### 个人心得摘录与总结
- **stansxt**：第一次提交 $TLE$，将 `lower_bound` 换为手写二分后通过，提醒在使用 STL 时要注意性能问题。
- **Na2PtCl6**：用 `map` 实现时需要开 $O_2$ 才能过，用排序优化后不用开 $O_2$ 也能过，说明排序在去重判断中的优化作用。 

---
处理用时：22.58秒
# 题目信息

# [国家集训队] 特技飞行

## 题目背景

1. wqs 爱好模拟飞行。

2. clj 开了一家神犇航空，由于 clj 还要玩游戏，所以公司的事务由你来打理。

注意：题目中只是用了这样一个背景，并不与真实/模拟飞行相符

## 题目描述

神犇航空开展了一项载客特技飞行业务。每次飞行长 $n$ 个单位时间，每个单位时间可以进行一项特技动作，可选的动作有 $k$ 种，每种动作有一个刺激程度 $c_i$。如果连续进行相同的动作，乘客会感到厌倦，所以定义某次动作的价值为(距上次该动作的时间) $ \times c_i$，若为第一次进行该动作，价值为 $0$。安排一种方案，使得总价值最大。

## 说明/提示

#### 数据规模与约定

- 对于 $10\%$ 的测试数据，$n \le 20$，$k \le 3$。
- 对于 $100\%$ 的测试数据，$1 \le n \le 10^3$，$1 \le k \le 300$，$0 \le c_i \le 10^3$。

## 样例 #1

### 输入

```
5 2
2 2```

### 输出

```
12

```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致，均为贪心算法。先分析得出同一动作价值为 $c_i$ 乘以最后与首次进行时间差，所以要让 $c$ 值大的动作相隔时间最长，尽可能安排在两端。算法要点是对动作刺激程度 $c_i$ 排序，再按贪心策略计算最大总价值。解决难点在于证明一个动作做且只做 2 次能使总价值最大，以及如何合理安排动作顺序。

### 高评分题解
- **作者：SuperJvRuo（5星）**
    - **关键亮点**：思路清晰，代码简洁，直接阐述核心思路并给出简洁实现。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
#include<functional>

int a[1005];

int main()
{
    int n, k;
    int ans = 0;
    scanf("%d%d", &n, &k);
    for(int i = 0; i < k; i++)
        scanf("%d", &a[i]);
    std::sort(a, a+k, std::greater<int>());
    n--;
    int i = 0;
    while(n > 0 && i < k)
    {
        ans += n*a[i];
        i++;
        n-=2;
    }
    printf("%d\n", ans);
    return 0;
}
```
    - **核心思想**：先对动作刺激程度数组从大到小排序，然后依次将最大刺激程度的动作安排在两端，计算价值并累加，直到时间间隔为 0 或动作安排完。

- **作者：三好代表（4星）**
    - **关键亮点**：详细解释思路，代码规范易懂。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 11000;
int n,k;
int c[N];
int l=1,r,ans=0;
int main()
{
    cin>>n>>k;
    for(int i=1;i<=k;i++)
        cin>>c[i];
    sort(c+1,c+k+1);
    r=n;
    for(int i=k;i>0;i--)
    {
        ans+=(r-l)*c[i];
        r--;
        l++;
        if(l>=r) break;
    }
    cout<<ans;
    return 0;
}
```
    - **核心思想**：对动作刺激程度数组从小到大排序，从最大刺激程度开始，将动作安排在当前区间两端，计算价值并累加，同时缩小区间，直到左边界大于等于右边界。

- **作者：KillerXu（4星）**
    - **关键亮点**：详细推导动作做且只做 2 次的结论，代码简洁明了。
    - **核心代码**：
```cpp
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <algorithm>

#define MAXN 1005

using namespace std;

int n, k;
int c[MAXN];

bool cmp(int a, int b){
    return a > b;
}

int main(){
    
    cin >> n >> k;
    for(int i = 1; i <= k; i++) cin >> c[i];
    sort(c + 1, c + k + 1, cmp); // 从大到小排序 
    int ans = 0;
    for(int i = 1; i <= n / 2 && i <= k; i++) ans += c[i] * (n - (i * 2 - 1)); // 计算结果 
    cout << ans;
    return 0;
}
```
    - **核心思想**：对动作刺激程度数组从大到小排序，按贪心策略计算前 $n/2$ 个动作的价值并累加，得到最大总价值。

### 最优关键思路或技巧
- **思维方式**：通过分析动作价值的计算方式，得出一个动作做且只做 2 次能使总价值最大的结论，采用贪心策略安排动作顺序。
- **代码实现技巧**：使用排序函数对动作刺激程度数组排序，根据贪心策略遍历数组计算总价值。

### 拓展思路
同类型题或类似算法套路：涉及区间安排和价值最大化的贪心问题，如活动选择问题、区间覆盖问题等。解题关键在于分析问题本质，找出最优的贪心策略。

### 推荐题目
- P1090 [NOIP2004 提高组] 合并果子
- P2240 【深基12.例1】部分背包问题
- P1803 凌乱的yyy / 线段覆盖

### 个人心得摘录与总结
- **作者：qr的小迷妹**：一开始只看出价值计算公式，不知道如何安排动作得到最大值，后来通过简单证明（多推几种情况）明白了两头安排的贪心策略。总结：对于贪心问题，可通过多举例分析来找出最优策略。 

---
处理用时：26.86秒
# 题目信息

# [NOIP 2017 普及组] 图书管理员

## 题目背景

NOIP2017 普及组 T2

## 题目描述

图书馆中每本书都有一个图书编码，可以用于快速检索图书，这个图书编码是一个正整数。 每位借书的读者手中有一个需求码，这个需求码也是一个正整数。如果一本书的图书编码恰好以读者的需求码结尾，那么这本书就是这位读者所需要的。 小 D 刚刚当上图书馆的管理员，她知道图书馆里所有书的图书编码，她请你帮她写一个程序，对于每一位读者，求出他所需要的书中图书编码最小的那本书，如果没有他需要的书，请输出 `-1`。


## 说明/提示

**数据规模与约定**

对于 $20\%$ 的数据，$1 ≤ n ≤ 2$。

另有 $20\%$ 的数据，$q = 1$。

另有 $20\%$ 的数据，所有读者的需求码的长度均为 $1$。

另有 $20\%$ 的数据，所有的图书编码按从小到大的顺序给出。

对于 $100\%$ 的数据，$1 ≤ n ≤ 1000,1 ≤ q ≤ 1000$，所有的图书编码和需求码均不超过 $10^7$。


## 样例 #1

### 输入

```
5 5 
2123 
1123 
23 
24 
24 
2 23 
3 123 
3 124 
2 12 
2 12```

### 输出

```
23 
1123 
-1 
-1 
-1 ```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何判断图书编码是否以需求码结尾，以及找出满足条件的最小图书编码展开。多数题解采用排序后遍历的方式，通过取模运算（对 `10^x` 取模得到后 `x` 位）来判断是否匹配。部分题解使用了字符串处理、字典树等不同方法。

### 评分较高的题解
1. **作者：LinkyChristian（5星）**
    - **关键亮点**：思路清晰，详细解释了取模运算的原理和使用方法，代码简洁易懂。
    - **核心代码**：
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,q,book[6666],len[6666],num[6666];
int main()
{
    cin>>n>>q;
    for(int i=1; i<=n; i++) cin>>book[i];
    for(int i=1; i<=q; i++) {
        cin>>len[i]>>num[i];
        int tmp = pow(10,len[i]),min = 10000001;
        for(int j=1; j<=n; j++) if(book[j] % tmp == num[i] && book[j] < min) min = book[j];
        if(min!= 10000001) cout<<min<<endl;
        else cout<<-1<<endl; 
    }
    return 0;
}
```
    - **核心思想**：先读取图书编码和需求码，对于每个需求码，计算 `10^x` 作为取模的基数，遍历图书编码，找到满足取模结果等于需求码且编码最小的图书，若未找到则输出 -1。

2. **作者：VitrelosTia（4星）**
    - **关键亮点**：使用字符串和 `map` 存储后缀和最小编码，思路独特，代码逻辑清晰。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, q;
map <string, string> mp;
string strmin(string x, string y) {
    if (x.size() < y.size()) return x;
    if (y.size() < x.size()) return y;
    for (int i = 0; i < x.size(); i++) {
        if (x[i] < y[i]) return x;
        if (y[i] < x[i]) return y;
    }
    return x;
}
int main() {
    cin >> n >> q;
    while (n--) {
        string s;
        cin >> s;
        for (int j = 0; j < s.size(); j++) {
            if (mp[s.substr(j)] == "") mp[s.substr(j)] = s;
            else mp[s.substr(j)] = strmin(mp[s.substr(j)], s);
        }
    }
    while (q--) {
        int x;
        string s;
        cin >> x >> s;
        if (!mp.count(s)) puts("-1");
        else cout << mp[s] << '\n';
    }
    return 0;
}
```
    - **核心思想**：读取图书编码，枚举每个编码的后缀，使用 `map` 存储后缀和对应的最小编码。对于每个需求码，检查 `map` 中是否存在该后缀，若存在则输出对应的最小编码，否则输出 -1。

3. **作者：The_Best_OIer（4星）**
    - **关键亮点**：提前定义 `mod` 数组存储 `10^x` 的值，避免重复计算，代码简洁高效。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000};
int n, q, x, y, a[1005];
int main() {
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    sort(a + 1, a + n + 1);
    for (int i = 1, j; i <= q; i++) {
        cin >> x >> y;
        for (j = 1; j <= n; j++) {
            if (a[j] % mod[x] == y) {
                break;
            }
        }
        if (j <= n) cout << a[j] << endl;
        else cout << -1 << endl;
    }
    return 0;
}
```
    - **核心思想**：读取图书编码并排序，对于每个需求码，使用 `mod` 数组中的值进行取模运算，遍历图书编码，找到满足条件的最小编码，若未找到则输出 -1。

### 最优关键思路或技巧
- **取模运算**：通过对 `10^x` 取模得到数的后 `x` 位，用于判断图书编码是否以需求码结尾。
- **排序**：将图书编码排序后，遍历找到的第一个满足条件的编码即为最小编码。
- **预处理**：提前计算 `10^x` 的值存储在数组中，避免重复计算。

### 可拓展之处
同类型题：判断一个数是否是另一个数的后缀，或在一组数中找到以某个数为后缀的最小数。
类似算法套路：使用取模运算处理数字的后几位，使用排序优化查找最小数的过程。

### 推荐题目
1. [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)：涉及字符串处理和数字计算，判断ISBN号码的校验码是否正确。
2. [P1100 高低位交换](https://www.luogu.com.cn/problem/P1100)：考察位运算和数字处理，将一个整数的高低位交换。
3. [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)：需要判断一个数是否为回文数和质数，涉及数字处理和质数判断算法。

### 个人心得
部分题解未提及个人心得，暂未发现相关内容。 

---
处理用时：36.96秒
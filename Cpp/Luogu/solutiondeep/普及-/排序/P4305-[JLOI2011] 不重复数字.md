# 题目信息

# [JLOI2011] 不重复数字

## 题目描述

给定 $n$ 个数，要求把其中重复的去掉，只保留第一次出现的数。

## 说明/提示

对于 $30\%$ 的数据，$n \le 100$，给出的数 $\in [0, 100]$。

对于 $60\%$ 的数据，$n \le 10^4$，给出的数 $\in [0, 10^4]$。

对于 $100\%$ 的数据，$1 \le T\le 50$，$1 \le n \le 5 \times 10^4$，给出的数在 $32$ 位有符号整数范围内。

## 样例 #1

### 输入

```
2
11
1 2 18 3 3 19 2 3 6 5 4
6
1 2 3 4 5 6
```

### 输出

```
1 2 18 3 19 6 5 4
1 2 3 4 5 6
```

# AI分析结果

### 综合分析与结论
本题要求去除给定数字序列中的重复数字，仅保留首次出现的数字。各题解主要采用了哈希表、排序去重和数据结构存储等思路来解决问题。
- **哈希表思路**：通过哈希函数将数字映射到哈希表中，判断数字是否已存在，避免重复。如`unordered_map`、自定义哈希表等实现方式。
- **排序去重思路**：先对数字按值排序，去除重复数字，再按原位置排序输出。
- **数据结构存储思路**：使用结构体数组存储数字和位置信息，通过排序和标记去除重复数字。

### 所选题解
1. **作者：Rainbow_qwq（5星）**
    - **关键亮点**：思路清晰，使用`unordered_map`简单高效，代码简洁易懂，且对`unordered_map`和`map`的复杂度进行了对比说明。
    - **核心代码**：
```cpp
unordered_map<int,bool>s;
void work()
{
    s.clear();
    n=read();
    For(i,1,n){
        x=read();
        if(!s[x]){
            printf("%d ",x);
            s[x]=1;
        }
    }puts("");
}
```
    - **核心思想**：使用`unordered_map`存储数字是否出现过，遍历输入数字，若未出现则输出并标记。
2. **作者：Histone（4星）**
    - **关键亮点**：详细阐述了排序去重的思路和步骤，通过结构体数组存储数字和位置信息，代码注释清晰。
    - **核心代码**：
```cpp
struct num{
    int id;
    int z;
};
bool cmz(struct num a,struct num b){
    if(a.z>b.z)
        return true;
    if(a.z==b.z)
        if(a.id<b.id)
            return true;
    return false;
}
bool cmid(struct num a,struct num b){
    if(a.id<b.id)
        return true;
    return false;
}
//...
sort(s+1,s+n+1,cmz);
for(int i=1;i<=n;i+=pd){
    pd = 1;
    for(int j=i+1;j<=n;j++){
        if(s[i].z==s[j].z)s[j].z = -2147483659,pd++;
        else break;
    }
}
sort(s+1,s+n+1,cmid);
```
    - **核心思想**：先按数字值排序，去除重复数字，再按位置排序，最后输出未被标记删除的数字。
3. **作者：HansLimon（4星）**
    - **关键亮点**：引入了`pbds`的`gp_hash_table`，对不同哈希表的特点进行了说明，代码简洁，思路清晰。
    - **核心代码**：
```cpp
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
using namespace __gnu_pbds;
gp_hash_table<long long, bool> corder;
//...
while (T --){
    corder.clear();
    quick_read(n);
    while (n --){
        quick_read(now);
        if (corder[now])continue;
        printf("%lld ", now);
        corder[now] = true;
    }
    putchar(10);
}
```
    - **核心思想**：使用`gp_hash_table`判断数字是否已出现，未出现则输出并标记。

### 最优关键思路或技巧
- **哈希表的使用**：哈希表可以在$O(1)$的时间复杂度内判断元素是否存在，是解决去重问题的高效方法。如`unordered_map`和自定义哈希表。
- **排序去重**：先排序可以方便地去除重复元素，再按原位置排序可以保证输出顺序。

### 拓展思路
同类型题或类似算法套路：
- 数组去重问题：可使用哈希表或排序去重的方法。
- 字符串去重问题：同样可以使用哈希表来判断字符串是否已出现。

### 推荐题目
1. [P1161 开灯](https://www.luogu.com.cn/problem/P1161)：可使用哈希表记录每个位置的开关状态。
2. [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)：可使用数组或链表模拟过程，也可使用数学方法优化。
3. [P2676 [USACO07DEC]Bookshelf B](https://www.luogu.com.cn/problem/P2676)：可使用排序和贪心算法解决。

### 个人心得摘录与总结
- **Aehnuwx**：原哈希表做法因负数下标问题只得了60分，通过写负数取模解决问题。总结：处理数据时要考虑数据范围和边界情况。
- **Rainbow_qwq**：题目加强数据后`map/set`被卡，而`unordered_map`能过。总结：不同数据结构的复杂度不同，要根据数据规模选择合适的数据结构。

---
处理用时：27.94秒
# 题目信息

# [USACO18OPEN] Lemonade Line S

## 题目描述

这是农场上一个炎热的夏日，Farmer John 要给他的 $N$ 头奶牛发柠檬汽水了！所有的 $N$ 头奶牛（编号为 $1 \dots N$）都喜欢柠檬汽水，只是有些喜欢的程度更高一些。具体来说，奶牛 $i$ 为了获得柠檬汽水，最多愿意排在 $w_i$ 头奶牛之后。现在所有的 $N$ 头奶牛都在田里，但只要 Farmer John 敲响牛铃，这些奶牛就会立刻赶到柠檬汽水站。她们会在 Farmer John 开始分发柠檬汽水之前到达，但没有两头奶牛会在同一时刻到达。此外，当奶牛 $i$ 到达时，当且仅当队伍中至多有 $w_i$ 头奶牛时，她才会加入队伍。

Farmer John 想要提前准备一定量的柠檬汽水，但他不想浪费。排队的奶牛数量可能取决于她们的到达顺序。请帮助他求出在所有可能的到达顺序下，最小的可能排队奶牛数量。


## 说明/提示

在这个情况下，可能最后仅有三头奶牛在队伍中（这也是最小可能值）。假设 $w = 7$ 和 $w = 400$ 的奶牛先到并等在队伍中。然后 $w = 1$ 的奶牛到达并且会离开，因为已经有 $2$ 头奶牛在队伍中了。接着 $w = 2$ 的两头奶牛到达，一头留下排队，另一头离开。

供题：Dhruv Rohatgi

## 样例 #1

### 输入

```
5
7 1 400 2 2```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论
本题主要是求在所有可能的奶牛到达顺序下，排队奶牛的最小数量，解题核心是贪心算法。各题解思路基本一致，均是让忍耐度（$w$ 值）大的奶牛先排队，这样能使忍耐度小的奶牛离开，从而使排队奶牛数最少。不同题解的差异主要体现在排序方式和代码实现细节上。

### 高评分题解
- **作者：btc001（5星）**
    - **关键亮点**：思路清晰，代码简洁，对贪心思想的解释通俗易懂。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin >> n;
    int a[n+1], sum=0;
    for(int i=1; i<=n; i++) cin >> a[i];
    sort(a+1, a+n+1);
    for(int i=n; i>=1; i--){
        if(a[i]>=sum)
            sum++;
        else break;
    }
    cout<<sum<<endl;
    return 0;
}
```
    - **核心思想**：先对数组排序，再从后往前遍历，若当前奶牛的忍耐度大于等于当前排队奶牛数，则该奶牛加入排队，否则停止遍历。

- **作者：hhhyyyfff（4星）**
    - **关键亮点**：代码规范，对贪心策略的阐述简洁明了。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[100000],N;
inline bool cmp(int x,int y){
    return x>y;
}
int main(){
    scanf("%d",&N);
    for(int i=0;i<N;++i)
        scanf("%d",&a[i]);
    sort(a,a+N,cmp);
    for(int i=0;i<N;++i)
        if(a[i]<i){
            printf("%d\n",i);
            return 0;
        }
    printf("%d\n",N);
    return 0;
} 
```
    - **核心思想**：定义比较函数 `cmp` 使数组从大到小排序，遍历数组，当遇到奶牛忍耐度小于当前位置时，输出当前位置作为排队奶牛数。

- **作者：fls233666（4星）**
    - **关键亮点**：详细归纳了程序实现过程，逻辑清晰。
    - **核心代码**：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
    int n,l=0;
    cin>>n;
    int w[n];
    for(int i=0;i<n;i++)
        cin>>w[i];
    sort(w,w+n);
    for(int i=n-1;i>=0;i--){
        if(l<=w[i])
            l++;
        else
            break;
    }
    cout<<l;
    return 0;
}
```
    - **核心思想**：先对数组排序，从后往前遍历，若当前排队奶牛数小于等于当前奶牛的忍耐度，则该奶牛加入排队，否则停止遍历。

### 最优关键思路与技巧
- **贪心策略**：让 $w$ 值大的奶牛先排队，使 $w$ 值小的奶牛离开，从而使排队奶牛数最少。
- **排序优化**：使用 `sort` 函数进行排序，时间复杂度为 $O(n log n)$。

### 拓展思路
同类型题通常涉及贪心算法，可通过排序来确定元素的处理顺序，以达到最优解。类似算法套路还包括区间调度问题、活动选择问题等。

### 推荐题目
- P1090 [NOIP2004 提高组] 合并果子
- P1223 排队接水
- P1803 凌乱的yyy / 线段覆盖

### 个人心得摘录与总结
- **作者：A_Big_Jiong**：使用优先队列（堆）解题时，要注意大根堆和小根堆的选择，不同选择可能导致不同结果。
- **作者：Real_Create**：使用选择排序解题时，要注意边界条件，避免出现未输出结果的情况。 

---
处理用时：22.63秒
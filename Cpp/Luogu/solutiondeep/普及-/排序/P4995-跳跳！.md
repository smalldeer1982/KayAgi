# 题目信息

# 跳跳！

## 题目描述

你是一只小跳蛙，你特别擅长在各种地方跳来跳去。

这一天，你和朋友小 F 一起出去玩耍的时候，遇到了一堆高矮不同的石头，其中第 $i$ 块的石头高度为 $h_i$，地面的高度是 $h_0 = 0$。你估计着，从第 $i$ 块石头跳到第 $j$ 块石头上耗费的体力值为 $(h_i - h_j) ^ 2$，从地面跳到第 $i$ 块石头耗费的体力值是 $(h_i) ^ 2$。

为了给小 F 展现你超级跳的本领，你决定跳到每个石头上各一次，并最终停在任意一块石头上，并且小跳蛙想耗费**尽可能多**的体力值。

当然，你只是一只小跳蛙，你只会跳，不知道怎么跳才能让本领更充分地展现。

不过你有救啦！小 F 给你递来了一个写着 AK 的电脑，你可以使用计算机程序帮你解决这个问题，万能的计算机会告诉你怎么跳。

那就请你——会写代码的小跳蛙——写下这个程序，为你 NOIp AK 踏出坚实的一步吧！

## 说明/提示

#### 样例解释

两个样例按照输入给定的顺序依次跳上去就可以得到最优方案之一。

#### 数据范围
对于 $1 \leq i \leq n$，有 $0 < h_i \leq 10 ^ 4$，且保证 $h_i$ 互不相同。

对于 $10\%$ 的数据，$n \leq 3$；

对于 $20\%$ 的数据，$n \leq 10$；

对于 $50\%$ 的数据，$n \leq 20$；

对于 $80\%$ 的数据，$n \leq 50$；

对于 $100\%$ 的数据，$n \leq 300$。

## 样例 #1

### 输入

```
2
2 1```

### 输出

```
5```

## 样例 #2

### 输入

```
3
6 3 5
```

### 输出

```
49```

# AI分析结果

### 综合分析与结论
这些题解均采用贪心算法解决小跳蛙跳石头耗费最大体力值的问题。核心思路是让小跳蛙每次跳到和当前位置高度差最大的柱子，即先跳到最高的柱子，再跳到最低的柱子，依次类推。各题解在思路阐述和代码实现上有所差异，但本质相同。部分题解给出了贪心策略的证明，增强了算法的严谨性。

### 所选题解
- **作者：UnyieldingTrilobite（5星）**
    - 关键亮点：思路清晰，通过分类讨论严谨证明了贪心策略的正确性，逻辑严密。
    - 证明思路：假设存在一种最优情况第一步不是从 $0$ 跳到 $h_n$ 而是跳到 $h_p$，分 $h_n$ 是终点和不是终点两类讨论，得出第一步改跳 $h_n$ 体力值耗费增加，产生矛盾，从而证明第一步一定是从 $0$ 跳到 $h_n$。
- **作者：JASON杨（4星）**
    - 关键亮点：不仅给出贪心思路和代码，还通过具体例子进行证明，易于理解。
    - 代码核心片段：
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long ans=0;
int h[330];
bool sum=0;
signed main()
{
    int n;
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>h[i];
    }
    sort(h+1,h+n+1);
    int j=0,hpast=0;
    for (int i=1;i<=n;i++)
    {
        j=n-j+sum;
        sum=!sum;
        ans+=(h[j]-hpast)*(h[j]-hpast);
        hpast=h[j];
    }
    cout<<ans;
    return 0;
}
```
    核心实现思想：先对石头高度数组排序，通过 `sum` 控制左右横跳，依次计算每次跳跃的体力消耗并累加。
- **作者：Gumbo（4星）**
    - 关键亮点：先给出代码，再通过具体序列和一般情况证明贪心策略的最优性，理论与实践结合。
    - 证明思路：通过对比交换石头顺序前后的体力消耗，得出 $(d - b)^2 + (c - a)^2 \leq (d - a)^2 + (c - b)^2$，证明贪心策略是最优的。
    - 代码核心片段：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n;
long long h[301];
long long jl(int a,int b){
    return((a-b)*(a-b));
}
int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;++i)scanf("%lld",h+i);
    sort(h+1,h+n+1);
    long long l=0,r=n;
    long long J=0;
    while(l<r){
        J+=jl(h[r],h[l]);
        ++l;
        J+=jl(h[l],h[r]);
        --r;
    }
    printf("%lld",J);
    return 0;
}
```
    核心实现思想：对石头高度数组排序，使用左右指针模拟左右横跳，计算每次跳跃的体力消耗并累加。

### 最优关键思路或技巧
- **贪心策略**：每次选择与当前位置高度差最大的石头跳跃，可使体力消耗最大。
- **排序**：对石头高度进行排序，方便确定最高和最低的石头。
- **双指针**：使用左右指针模拟左右横跳的过程，简化代码实现。

### 可拓展之处
同类型题可拓展为不同的跳跃规则或消耗公式，如跳跃距离与消耗体力的关系更复杂，或增加跳跃次数限制等。类似算法套路可应用于资源分配问题，每次选择差值最大的资源进行分配以达到最优结果。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：每次合并重量最小的两堆果子，使用贪心算法。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：按接水时间从小到大排序，使用贪心策略使总等待时间最短。
- [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：按单位价值从高到低排序，贪心选择单位价值高的物品。

### 个人心得
- **作者：hamster000**：“我调了半天呢”，说明调试代码可能会花费较多时间，在解决问题时要有耐心。

---
处理用时：24.17秒
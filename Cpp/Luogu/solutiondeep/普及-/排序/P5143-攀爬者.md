# 题目信息

# 攀爬者

## 题目背景

HKE 考完 GDOI 之后跟他的神犇小伙伴们一起去爬山。


## 题目描述

他在地形图上标记了 $N$ 个点，每个点 $P_i$ 都有一个坐标 $(x_i,y_i,z_i)$。所有点对中，高度值 $z$ 不会相等。HKE 准备从最低的点爬到最高的点，他的攀爬满足以下条件：

 (1) 经过他标记的每一个点；

 (2) 从第二个点开始，他经过的每一个点高度 $z$ 都比上一个点高；

 (3) HKE 会飞，他从一个点 $P_i$ 爬到 $P_j$ 的距离为两个点的欧几里得距离。即，$\sqrt{(X_i-X_j)^2+(Y_i-Y_j)^2+(Z_i-Z_j)^2}$

现在，HKE 希望你能求出他攀爬的总距离。


## 说明/提示

对于100%的数据，$1\leq N\leq 50000$，答案的范围在 double 范围内。


## 样例 #1

### 输入

```
5
2 2 2
1 1 1
4 4 4
3 3 3
5 5 5
```

### 输出

```
6.928```

# AI分析结果

### 综合分析与结论
这些题解的核心思路一致，都是先对三维点按高度 `z` 排序，再依次计算相邻点间的欧几里得距离并求和。主要区别在于排序方式（结构体排序、归并排序）、运算符使用（重载 `<` 运算符、使用 `cmp` 函数）、输入输出方式（`scanf`、`cin`、快读）和距离计算函数（`sqrt`、`hypot`）。

### 所选题解
- **作者：我终于改名惹（5星）**
    - **关键亮点**：思路清晰，代码简洁，使用结构体重载 `<` 运算符排序，同时实现了快读功能。
    - **个人心得**：无
- **作者：zhanghzqwq（4星）**
    - **关键亮点**：详细对比了重载运算符和比较函数的性能差异，对排序优化有一定指导意义。
    - **个人心得**：无
- **作者：yu__xuan（4星）**
    - **关键亮点**：代码结构清晰，将距离计算封装成函数，提高了代码的可读性和可维护性。
    - **个人心得**：无

### 重点代码及核心实现思想
#### 作者：我终于改名惹
```cpp
struct shan{
    int x,y,z;
    bool operator<(const shan &other)const{
        return z<other.z;
    }
}s[N];
sort( s, s + n);
for(int i = 1, j = 0; i < n; ++j, ++i)
    ans += sqrt(pow(s[i].x - s[j].x,2) + pow(s[i].y - s[j].y,2) + pow(s[i].z-s[j].z,2));
```
核心思想：定义结构体 `shan` 存储点的坐标，重载 `<` 运算符按 `z` 排序，遍历排序后的点计算相邻点间的欧几里得距离。

#### 作者：zhanghzqwq
```cpp
struct Node{
    double x,y,z;
    bool operator<(const Node &other)const{
        return z<other.z;
    }
} a[50050];
sort(a,a+n);
for(int i=1;i<n;i++){
    ans+=sqrt(abs(cx-a[i].x)*abs(cx-a[i].x)+abs(cy-a[i].y)*abs(cy-a[i].y)+abs(cz-a[i].z)*abs(cz-a[i].z));
    cx=a[i].x;
    cy=a[i].y;
    cz=a[i].z;
}
```
核心思想：定义结构体 `Node` 存储点的坐标，重载 `<` 运算符按 `z` 排序，遍历排序后的点计算相邻点间的欧几里得距离。

#### 作者：yu__xuan
```cpp
struct point {
    int x,y,z;
}p[MAXN];
bool cmp(point a,point b) {
    return a.z<b.z;
}
void calc(int a) {
    ans+=sqrt((p[a].x-p[a-1].x)*(p[a].x-p[a-1].x)+(p[a].y-p[a-1].y)*(p[a].y-p[a-1].y)+(p[a].z-p[a-1].z)*(p[a].z-p[a-1].z));
}
std::sort(p+1,p+n+1,cmp);
for(int i=2;i<=n;++i) calc(i);
```
核心思想：定义结构体 `point` 存储点的坐标，使用 `cmp` 函数按 `z` 排序，将距离计算封装成 `calc` 函数，遍历排序后的点调用 `calc` 函数计算距离。

### 最优关键思路或技巧
- 使用结构体存储点的坐标，方便排序和处理。
- 重载 `<` 运算符或使用 `cmp` 函数对结构体按 `z` 排序。
- 实现快读功能提高输入效率。
- 将距离计算封装成函数，提高代码的可读性和可维护性。

### 可拓展之处
同类型题或类似算法套路：
- 二维平面上按某一维度排序后计算相邻点间的距离。
- 多维空间中按某一维度排序后进行路径规划或距离计算。

### 推荐题目
- [P1104 生日](https://www.luogu.com.cn/problem/P1104)：结构体排序问题。
- [P1271 选举学生会](https://www.luogu.com.cn/problem/P1271)：排序统计问题。
- [P1093 奖学金](https://www.luogu.com.cn/problem/P1093)：多条件排序问题。

---
处理用时：25.12秒
# 题目信息

# [SBCOI2020] 小镇

## 题目背景

在人们不知道的地方，有一个小镇。  
一个，连名字都说不上来的小镇。  
季节再度进入冬季，  
那个属于雪的季节。  
在那雪下，埋葬着的，  
是只属于这个小镇的梦，与传说。  
......   
“又到了冬天啊！”  
“是啊！周围都变成白茫茫的一片了呢...”  
“唉，要是这样的日子能够永远持续下去该有多好啊。”  
“啊，永远...”  
“不过，世间又有什么是永远呢。如同雪的消融，洁白地融入大地，还来不及让人品味，如此无奈，又如此纯净......”   

在雪中，一幢幢房屋间的灯光散发出温暖的光芒。  
![](https://cdn.luogu.com.cn/upload/image_hosting/j728ebas.png)  
“以后我们还能在一起看雪吗？”  
“当然，一直可以......”

## 题目描述

小镇可以看作是一个 $n \times n$ 的网格，其中有 $k$ 个格子是房屋。    
小镇里面还有灯。每两个相邻的格子之间有一盏灯。

如果两幢房屋**相邻**，那么这两幢房屋之间的灯就会点亮。  
请问这座小镇一共有多少盏灯被点亮。

注意，本题中相邻指有公共边。

## 说明/提示

#### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/tbjkl3ul.png)  
如图，阴影格子为房屋，被描红的边为灯。

#### 数据范围

对于 $30\%$ 的数据，$1 \leq n,k \leq 100$。  
对于 $80\%$ 的数据，$1 \leq n,k \leq 5000$。  
对于 $100\%$ 的数据，$1 \le n,k \le 10^5$。  

## 样例 #1

### 输入

```
6 12
1 1
2 1
2 2
1 4
3 3
4 3
4 4
3 4
3 6
4 6
5 6
6 6```

### 输出

```
9```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算小镇中相邻房屋间点亮灯的数量展开，针对不同数据规模有不同解法。大部分题解使用 `map` 数据结构来记录房屋位置，核心思路是判断每个房屋上下左右是否有相邻房屋。部分题解采用排序后统计夹边的方法，还有题解将二维坐标映射到一维以节省空间。

### 所选题解
- **作者：Utilokasteinn（5星）**
    - **关键亮点**：思路清晰，代码极其简洁，仅用两行关键代码解决问题，巧妙利用 `map` 数组存储房屋信息，通过累加上下左右房屋数量得到结果。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,x,y,ans;
map<int,map<int,int> >a;
int main()
{
    for(cin>>n>>k;k--&&cin>>x>>y&&(a[x][y]=1);)
        ans+=a[x-1][y]+a[x+1][y]+a[x][y+1]+a[x][y-1];
    cout<<ans;
    return 0;
}
```
核心实现思想：使用 `map<int,map<int,int> >` 存储房屋信息，输入房屋坐标时将对应位置置为 1，同时累加该房屋上下左右的房屋数量，最终得到点亮灯的总数。

- **作者：犇犇犇犇（4星）**
    - **关键亮点**：针对不同数据规模给出不同解法，思路全面，详细解释了 $100\%$ 数据的排序统计夹边方法，时间复杂度为 $O(k log k)$。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+5;
struct node
{
    int x,y;
}a[MAXN];
bool cmp1(node a,node b)
{
    if(a.x!=b.x) return a.x<b.x;
    else return a.y<b.y; 
} 
bool cmp2(node a,node b)
{
    if(a.y!=b.y) return a.y<b.y;
    else return a.x<b.x;
} 
int n,k,ans;
int main()
{
    n=read();k=read();
    for(int i=1;i<=k;i++)
    {
        int x,y;
        x=read();y=read();
        a[i].x=x;a[i].y=y;		
    }
    sort(a+1,a+k+1,cmp1);
    for(int i=1;i<k;i++)
    {
        if(a[i].x==a[i+1].x && a[i].y==a[i+1].y-1)
            ans++;
    }
    sort(a+1,a+k+1,cmp2);
    for(int i=1;i<k;i++)
    {
        if(a[i].y==a[i+1].y && a[i].x==a[i+1].x-1)
            ans++;
    }
    cout<<ans<<endl;
    return 0;
} 
```
核心实现思想：定义结构体存储房屋坐标，分别按照 x 轴和 y 轴排序，统计相邻且满足条件的房屋对，累加得到点亮灯的总数。

- **作者：houpingze（4星）**
    - **关键亮点**：采用一边输入边判断的方法，代码简洁易懂，使用 `map` 数组记录房屋信息，实时统计相邻房屋数量。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long cnt=0;
map<int,map<int,int> >a;
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int x,y;
        cin>>x>>y;
        a[x][y]++;
        if(a[x-1][y]) cnt++;
        if(a[x][y-1]) cnt++;
        if(a[x+1][y]) cnt++;
        if(a[x][y+1]) cnt++;
    }
    cout<<cnt;
    return 0;
}
```
核心实现思想：输入房屋坐标时，将对应位置置为 1，同时判断该房屋上下左右是否有房屋，若有则计数器加 1，最终输出计数器的值。

### 最优关键思路或技巧
- **使用 `map` 数据结构**：当数据范围较大，普通数组无法满足需求时，`map` 可以动态分配内存，避免空间浪费，且能方便地记录房屋位置。
- **排序统计夹边**：对于大规模数据，通过排序将相邻房屋聚集在一起，便于快速统计相邻房屋对，降低时间复杂度。
- **一边输入边判断**：实时处理输入数据，减少额外的存储和遍历操作，提高代码效率。

### 可拓展之处
同类型题可能会改变相邻条件（如对角线相邻）、增加房屋属性（如不同类型房屋）或改变地图形状（如环形地图）。类似算法套路可用于解决网格图中元素相邻关系的统计问题，如计算连通区域数量、判断元素是否可达等。

### 推荐洛谷题目
- P1162 填涂颜色：考察二维数组的遍历和元素判断，与本题判断相邻元素的思路类似。
- P1598 垂直柱状图：需要对字符矩阵进行处理和统计，涉及到二维数据的操作。
- P2670 扫雷游戏：根据周围元素的信息来判断当前元素的状态，与本题判断相邻房屋的思路有相似之处。

### 个人心得摘录与总结
- **作者：infinities**：一开始未注意数据范围，开了 $n^2$ 的二维数组，后将数组换成 `map` 解决问题。总结：做题时要仔细查看数据范围，合理选择数据结构。
- **作者：Franka**：考试时忘记用 `map`，且强调程序运行时每个相邻关系会多算一份，结果需要除以 2。总结：考试时要灵活运用所学知识，同时注意避免重复计算。 

---
处理用时：36.53秒
# 题目信息

# [CSP-J2020] 直播获奖

## 题目描述

NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 $w\%$，即当前排名前 $w\%$ 的选手的最低成绩就是即时的分数线。

更具体地，若当前已评出了 $p$ 个选手的成绩，则当前计划获奖人数为 $\max(1, \lfloor p \times w \%\rfloor)$，其中 $w$ 是获奖百分比，$\lfloor x \rfloor$ 表示对 $x$ 向下取整，$\max(x,y)$ 表示 $x$ 和 $y$ 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。

作为评测组的技术人员，请你帮 CCF 写一个直播程序。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/l453vhow.png)

---
### 数据规模与约定

各测试点的 $n$ 如下表：

| 测试点编号 | $n=$ |
| :--: | :--: |
| $1 \sim 3$ | $10$ |
| $4 \sim 6$ | $500$ |
| $7 \sim 10$ | $2000$ |
| $11 \sim 17$ | $10^4$ |
| $18 \sim 20$ | $10^5$ |


对于所有测试点，每个选手的成绩均为不超过 $600$ 的非负整数，获奖百分比 $w$ 是一个正整数且 $1 \le w \le 99$。

---
### 提示

在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的 `float` 、 `double`，Pascal 中的 `real` 、 `double` 、 `extended` 等）存储获奖比例 $w\%$，则计算 $5 \times 60\%$ 时的结果可能为 $3.000001$，也可能为 $2.999999$，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。

## 样例 #1

### 输入

```
10 60
200 300 400 500 600 600 0 300 200 100
```

### 输出

```
200 300 400 400 400 500 400 400 300 300```

## 样例 #2

### 输入

```
10 30
100 100 600 100 100 100 100 100 100 100```

### 输出

```
100 100 600 600 600 600 100 100 100 100```

# AI分析结果

### 综合分析与结论
这些题解围绕“直播获奖”问题给出了多种解法。主要思路有暴力排序、插入排序、桶排序、对顶堆和 Treap 等。暴力排序和插入排序复杂度较高，只能拿到部分分数；桶排序利用成绩值域小的特点，复杂度为 $O(nV)$（$V$ 为成绩值域），能通过所有数据；对顶堆和 Treap 可动态维护第 $k$ 大数，复杂度为 $O(n\log n)$，能应对更大数据范围。

### 所选题解
- **作者：AzusagawaKaede（5星）**
    - **关键亮点**：详细介绍了对顶堆这一数据结构，包括其概念、基本操作和代码实现，思路清晰，代码简洁，还指出对顶堆可应对更大数据范围。
    - **个人心得**：无
    - **核心代码**：
```c++
priority_queue<int> ma_hp; // 大顶堆 
priority_queue<int, vector<int>, greater<int> > mi_hp; // 小顶堆 

void qwq() {
    if (mi_hp.size() < now) {
        mi_hp.push(ma_hp.top());
        ma_hp.pop();
    } 
    if (mi_hp.size() > now) {
        ma_hp.push(mi_hp.top());
        mi_hp.pop();
    }
} 

void push(int num) {
    if (num >= ma_hp.top()) mi_hp.push(num);
    else ma_hp.push(num);
    qwq();
}

int main() {
    scanf("%d%d", &n, &w);
    ma_hp.push(0);
    for (int p = 1; p <= n; p++) {
        now = max(1, p * w / 100);
        scanf("%d", &num);
        push(num);
        printf("%d ", mi_hp.top()); 
    }
    return 0;
}
```
- **作者：Eason_AC（4星）**
    - **关键亮点**：思路简洁明了，直接采用桶排序，代码实现简单易懂。
    - **个人心得**：无
    - **核心代码**：
```cpp
int n, w, x, a[607];

int main() {
    scanf("%d%d", &n, &w);
    for(int i = 1; i <= n; ++i) {
        scanf("%d", &x);
        a[x]++;
        int pl = max(1, i * w / 100), num = 0;
        for(int j = 600; j >= 0; --j) {
            num += a[j];
            if(num >= pl) {printf("%d ", j); break;}
        }
    }
    return 0;
}
```
- **作者：GZXUEXUE（4星）**
    - **关键亮点**：思路清晰，对使用数组记录得分段人数的做法进行了详细说明，代码简洁。
    - **个人心得**：无
    - **核心代码**：
```cpp
int a[601]; // a[i]表示该分数段的人数
int main() {
    int n, w, tmp; 
    scanf("%d %d", &n, &w);
    for (int i = 0; i < n; i++) {
        cin >> tmp;
        a[tmp]++;
        int j = 600, sum = 0, sc = max((i + 1) * w / 100, 1);
        for (; j >= 0 && sum < sc; j--) sum += a[j];
        cout << ++j << " ";
    }
    return 0;
}
```

### 最优关键思路或技巧
- 利用桶排序：由于选手成绩值域小（不超过 600），使用桶排序可有效降低复杂度。
- 对顶堆：可动态维护第 $k$ 大数，适用于数据范围较大的情况。

### 可拓展之处
同类型题可考虑动态维护第 $k$ 大数或第 $k$ 小数的问题，如动态中位数问题。类似算法套路可使用堆、平衡树等数据结构。

### 推荐题目
1. [P3871 [TJOI2010] 中位数](https://www.luogu.com.cn/problem/P3871)
2. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)
3. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)

### 个人心得摘录与总结
- **作者：bowen404**：使用 Python 刷本题时，因性能问题桶排序最后三个点 TLE，于是根据人数每次增加一位，分数线每次最多移动一次的特点，设置左右标志位优化，节省了开销，优化到了线性级。总结：在不同语言中要考虑性能差异，可根据数据特点进行优化。
- **作者：Jerry_zpl**：最初使用快速排序只能拿到 65 分，因复杂度高，后换用桶排序解决问题。总结：在处理动态数据时，要考虑排序算法的复杂度，选择合适的数据结构和算法。 

---
处理用时：29.18秒
# 题目信息

# 「Wdsr-2.5」小小的埴轮兵团

## 题目背景

杖刀偶磨弓是埴轮兵团的首长。

作为埴轮兵长，训练埴轮兵团是很平常的事情。

## 题目描述

磨弓下达命令让埴轮们站成一行。不妨认为它们站在了一个数轴上，每个埴轮的位置就是它脚下数轴的数字。磨弓会告诉你，第 $i$ 个埴轮的位置为 $a_i$ 。**不保证** $\bm {a_i}$ **升序**。

数轴的长度是有限制的，具体的范围是 $[-k,k]$ 。也就是说，如果某个埴轮移出了这个范围，它就脱离了这个队列了，并且不会再次回到队列当中。

为了训练埴轮，磨弓给埴轮们下达了 $m$ 个指令，有以下 3 种：

- 指令 1：**全体埴轮**向数轴的正方向移动 $x$ 个单位长度。
- 指令 2：**全体埴轮**往数轴的反方向移动 $x$ 个单位长度。
- 指令 3：依次报数，统计目前队列里一共有多少个埴轮。

但是磨弓发现，埴轮兵团的大小实在是太大了，以至于执行这些操作变得非常缓慢。尽管如此，磨弓仍然希望你告诉她所有指令 3 的结果。

## 说明/提示

#### 样例 1 说明

一共有三个埴轮。初始时，它们的站位分别是 $[-1,1,2]$ 。

- 第一次操作后，所有埴轮向左移动 $3$ 格，位置变成了  $[\underline{\bm{-4}},-2,-1]$ 。第一个埴轮被移出了数轴。
- 第二次操作后，输出当前的埴轮数目，为 $2$ 个。
- 第三次操作后，所有埴轮向右移动 $5$ 格，位置变成了 $[3,\underline \bm4]$ ，第二个埴轮被移出了数轴。
- 第四次操作后，输出当前的埴轮数目，为 $1$ 个。

#### 样例 2, 3

见下发附件。

#### 数据规模与约定

- 对于 $30\%$ 的数据，$1 \leq n, m \leq 5\times 10^3$；
- 对于另外 $20\%$ 的数据，$1\le k\le 500$；
- 对于 $100\%$ 的数据，$1 \leq n, m \leq 3\times 10^5$，$1 \leq k, x \leq 2 \times 10^9$，$-k \le a_i \le k$ 。

## 样例 #1

### 输入

```
3 4 3
-1 1 2
2 3
3
1 5
3```

### 输出

```
2
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕模拟埴轮兵团的移动和统计操作展开。核心思路是先对埴轮初始位置排序，再通过维护偏移量或队列等方式模拟移动，及时淘汰超出范围的埴轮，最后统计剩余数量。
- **思路对比**：多数题解采用排序后模拟的方法，部分使用二分查找优化；还有用树状数组和差分维护坐标更新。
- **算法要点**：排序是基础，确保后续操作的正确性；维护偏移量避免对每个埴轮坐标的重复更新；利用队列或指针标记剩余埴轮的范围。
- **解决难点**：处理大规模数据时，避免 $O(mn)$ 复杂度的暴力模拟；处理坐标更新和范围判断时，防止数据溢出。

### 高评分题解
- **作者：chlchl（5星）**
    - **关键亮点**：思路清晰，详细阐述使用双向队列的原因和操作步骤；代码简洁，注释丰富，可读性强；提醒了排序、输入和数据类型等坑点。
    - **个人心得**：强调“五年 OI 一场空，不开 long long 见祖宗”，提醒注意数据范围。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const ll N = 300000 + 10;
ll n, m, k, op, x, tot, a[N];
deque<ll> q;

int main(){
    cin >> n >> m >> k;
    for(ll i=1;i<=n;i++) cin >> a[i];
    sort(a + 1, a + 1 + n);
    for(ll i=1;i<=n;i++) q.push_back(a[i]);
    for(ll i=1;i<=m;i++){
        cin >> op;
        if(op == 3) cout << q.size() << endl;
        else if(op == 1){
            cin >> x;
            tot += x;
            while(!q.empty()){
                ll v = q.back();
                if(v + tot > k) q.pop_back();
                else break;
            }
        }else if(op == 2){
            cin >> x;
            tot -= x;
            while(!q.empty()){
                ll v = q.front();
                if(v + tot < -k) q.pop_front();
                else break;
            }
        }
    }
    return 0;
}
```
核心实现思想：使用双向队列存储埴轮位置，排序后入队。通过 `tot` 记录偏移量，根据操作更新队列，淘汰超出范围的埴轮，操作 3 输出队列长度。

- **作者：囧仙（4星）**
    - **关键亮点**：详细推导了偏移量和区间缩减的原理，给出时间复杂度分析；提醒了数据溢出的边界问题。
```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long i64;
const int INF =2147483647;
i64 qread(){
    i64 w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN =3e5+3;
i64 n,m,p,q,k,A[MAXN],d;
char fil[256];
int main(){
    n=qread(),m=qread(),k=qread(),p=1,q=n,d=0;
    up(1,n,i) A[i]=qread(); sort(A+1,A+1+n);
    up(1,m,i){
        int op=qread();
        if(op==1){d+=qread();while(p<=q&&A[q]+d> k) --q;} else
        if(op==2){d-=qread();while(p<=q&&A[p]+d<-k) ++p;} else
        printf("%lld\n",q-p+1);
    }
    return 0;
}
```
核心实现思想：用 `d` 记录偏移量，`p` 和 `q` 标记剩余埴轮的区间。根据操作更新 `d`，并缩减区间，操作 3 输出区间长度。

- **作者：UperFicial（4星）**
    - **关键亮点**：提出二分 + 树状数组的独特思路，复杂度为 $O(n\log n)$；虽认为是歪解，但运行速度快。
```cpp
// 思路大致是二分+树状数组
// 具体代码见 https://paste.ubuntu.com/p/Qr2qzSHfHZ/
```
核心实现思想：先排序，二分出移动后超出范围的点，用树状数组和差分维护坐标更新。

### 最优关键思路或技巧
- **排序**：将埴轮位置排序，使后续操作能利用有序性，如二分查找和区间缩减。
- **偏移量**：用一个变量记录整体移动距离，避免对每个埴轮坐标的重复更新，降低复杂度。
- **双向队列或指针**：使用双向队列或指针标记剩余埴轮的范围，方便淘汰超出范围的埴轮。

### 拓展思路
同类型题可拓展到多维度空间的点移动和范围判断，或增加更多操作类型。类似算法套路可用于处理区间维护、动态数据筛选等问题。

### 推荐题目
- P1168 中位数：涉及排序和动态维护中位数，与本题排序和区间维护思路相关。
- P1908 逆序对：可通过排序和归并排序统计逆序对，锻炼排序和数据处理能力。
- P2234 [HNOI2002]营业额统计：需要维护动态数据的最值和差值，与本题动态维护区间信息类似。

### 个人心得总结
多位作者提醒注意数据范围，使用 `long long` 避免溢出；部分作者强调排序的重要性，因为题目未保证数据升序。这些都是实际做题中容易踩坑的地方，需要格外注意。 

---
处理用时：42.38秒
# 题目信息

# [传智杯 #3 决赛] 商店

## 题目背景

disangan333 想给 disangan233 买一个礼物，于是他和你一起逛商店。

## 题目描述

有 $n$ 名同学去逛商店，店里有 $m$ 个物品，第 $i$ 人有 $w_i$ 块钱，第 $i$ 个物品价格 $c_i$ 元。

每个人至多买一个物品，每个物品只能被买一次，问最多有多少人能买到物品。

对于所有数据，$n,m \leq 10^5$，$w_i,c_i\leq 10^9$。

## 样例 #1

### 输入

```
15 20
4 3 9 10 7 7 5 3 6 1 8 6 6 1 5 
12 4 1 9 8 5 8 6 4 5 18 8 14 9 9 7 20 11 8 19 ```

### 输出

```
10```

# AI分析结果

### 综合分析与结论
这些题解均围绕贪心算法解决“商店购物人数最大化”问题。核心思路是对人的钱数和物品价格排序后，让钱少的人优先买便宜物品，从而使买到物品的人数最多。各题解的主要区别在于代码实现细节、输入输出方式及是否使用额外数据结构。

### 所选题解
- **作者：Double_Light（5星）**
    - **关键亮点**：思路清晰，代码注释详细，用两个变量分别指向人和物品，逻辑简单易懂。
    - **核心代码**：
```cpp
#include<iostream>
#include<algorithm> 
using namespace std;
int n,m,a[100005],b[100005],cnt,zz1=1,zz2=1;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=m;i++)cin>>b[i];
    sort(a+1,a+n+1);
    sort(b+1,b+m+1);
    while(zz1<=n&&zz2<=m){
        if(a[zz1]>=b[zz2]){
            cnt++;
            zz1++;
            zz2++;
        }
        else zz1++;
    }
    cout<<cnt; 
    return 0;
}
```
    - **核心思想**：排序后，用 `zz1` 和 `zz2` 分别代表人的索引和物品的索引，遍历过程中若人钱够则购买，索引均后移；钱不够则人索引后移。

- **作者：WA_sir（4星）**
    - **关键亮点**：思路阐述详细，通过举例说明贪心策略的正确性，代码简洁。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],b[100005],w=1,ans;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",a+i);
    for(int i=1;i<=m;i++)scanf("%d",b+i);
    sort(a+1,a+n+1);
    sort(b+1,b+m+1);
    for(int p=1;p<=n;p++)
    {
        if(w>m)break;
        if(a[p]<b[w])continue;
        w++;
        ans++;
    }
    printf("%d",ans);
    return 0;
}
```
    - **核心思想**：排序后，遍历人，若当前人钱够买当前物品，则购买，物品索引后移；钱不够则看下一个人。

- **作者：lilong（4星）**
    - **关键亮点**：对贪心策略进行了证明，使用快读优化输入，代码规范。
    - **核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int n,m,w[1000001],c[1000001],ans,k;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
    while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++)
        w[i]=read();
    for(int i=1;i<=m;i++)
        c[i]=read();
    sort(w+1,w+n+1);
    sort(c+1,c+m+1);
    k=1;
    for(int i=1;i<=n;i++)
        if(w[i]>=c[k])
            ans++,k++;
    cout<<ans;
    return 0;
}
```
    - **核心思想**：排序后，遍历人，若当前人钱够买当前最便宜物品，则购买，物品索引后移。

### 最优关键思路或技巧
- **贪心策略**：让钱少的人优先买便宜物品，可使买到物品的人数最多。
- **排序优化**：对人的钱数和物品价格从小到大排序，便于按顺序匹配。
- **双指针法**：使用两个指针分别代表人的索引和物品的索引，在遍历过程中动态匹配。

### 可拓展之处
同类型题如“活动安排问题”“区间覆盖问题”等，都可使用贪心算法解决。类似算法套路是先排序，再根据贪心策略进行选择。

### 推荐题目
- [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P2240 【深基12.例1】部分背包问题](https://www.luogu.com.cn/problem/P2240)

### 个人心得
题解中未包含个人心得（调试经历、踩坑教训、顿悟感想等）。 

---
处理用时：28.36秒
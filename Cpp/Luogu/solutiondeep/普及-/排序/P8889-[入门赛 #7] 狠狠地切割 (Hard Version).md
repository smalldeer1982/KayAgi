# 题目信息

# [入门赛 #7] 狠狠地切割 (Hard Version)

## 题目背景

**本题与 H1 的题意完全一致，区别仅在数据范围。在语言月赛中不存在 H2 题目，本题仅用于增加公开赛的区分度，并不严格遵循比赛考察范围，请酌情完成。**

## 题目描述

现给你一个长度为 $n$ 的序列 $a _ 1, \cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \cdots, b _ m$。你需要按照这 $m$ 个数对序列 $a$ 进行**狠狠地切割**。

具体的，对于一个数字 $i \in [1, n]$，如果存在一个整数 $j \in [1, m]$，使得 $a _ i = b _ j$，则将位置 $i$ 称为一个**切割点**。对序列 $a$ 中的每一个切割点，我们在这个位置进行一次**狠狠地切割**。方法是，将该位置的数字去除，然后在这个位置将其左右的**序列/片段**一分两半。

如果对**狠狠地切割**的定义有疑问，可以参照「样例 #1」及「样例解释 #1」进行理解。

你需要计算，在进行了所有可能的**狠狠地切割**后，序列被切割为了多少**片段**。

特别的，如果在切割后，某一段内没有数组，那这一段不可被叫做**片段**。同样的，如果 $1$ 或 $n$ 为切割点，其与开头和结尾之间也不存在片段。

如果对**片段**的概念有疑问，可以参照「样例 #2」及「样例解释 #2」进行理解。

## 说明/提示

### 样例 1 解释

在**狠狠地切割**前，序列 $a$ 如下所示：

$$\begin{matrix} 3 & 4 & 3 & 5 & 2 & 6 \end{matrix}$$

容易知道，第二个位置和第四个位置为切割点，我们使用 `|` 对其进行替换，代表去除工作：

$$\begin{matrix} 3 & | & 3 & | & 2 & 6 \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{3} ^ \text{片段 1} & | & \overbrace{3} ^ \text{片段 2} & | & \overbrace{2 \quad 6} ^ \text{片段 3} \end{matrix}$$

共计 $3$ 个片段。

### 样例 2 解释

以下我们展示去除之后的序列：

$$\begin{matrix} | & 4 & | & | & 2 & | \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} | & \overbrace{4} ^ \text{片段 1} & | & \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} & | & \overbrace{2} ^ \text{片段 2} & | \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段}\end{matrix}$$

共计 $2$ 个片段。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $a$ 序列中没有任何元素在 $b$ 中出现过。形式化的，$\forall i \in [1, n], \forall j \in [1, m], a _ i \neq b _ j$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 5 \times 10 ^ 5$，$- 10 ^ {18} \leq a _ i, b_i \leq 10 ^ {18}$，序列 $b$ 中的元素两两不同。

### 提示
本题输入规模较大，建议考虑使用较快的读入读出方式。

## 样例 #1

### 输入

```
6 2
3 4 3 5 2 6
5 4```

### 输出

```
3```

## 样例 #2

### 输入

```
6 3
3 4 3 5 2 6
3 5 6```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这三道题解均围绕如何高效地对序列 $a$ 按序列 $b$ 进行切割并统计片段数量展开。由于数据规模较大，简单的暴力枚举会超时，各题解采用了不同的优化算法。
- Double_Light 题解使用二分查找来判断 $a$ 中的元素是否在 $b$ 中，时间复杂度较低，思路清晰，代码实现完整。
- Maxmilite 题解提供了多种查找切割点的方法，包括数组记录、`unordered_map`、二分查找和双指针，较为全面，但代码示例不够完整。
- xiaohaoaibiancheng66 题解通过对 $a$ 数组排序后二分查找 $b$ 中的元素，不过需要两次排序，增加了复杂度。

综合来看，Double_Light 的题解在思路清晰度和代码完整性上表现出色，Maxmilite 的题解提供了多种思路，具有一定的参考价值。

### 所选题解
- **Double_Light 题解（5星）**
    - **关键亮点**：思路清晰，详细介绍了二分查找算法，并给出了完整的 AC 代码。
    - **核心代码**：
```cpp
bool check(long long k) {
    long long l=1,r=m,mid;
    while(l<=r){
        mid=(l+r)/2;
        if (k<b[mid])r=mid-1;
        else if(k>b[mid])l=mid+1;
        else return 1;
    }
    return 0;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
    for(int i=1;i<=m;i++)scanf("%lld",&b[i]);
    sort(b+1,b+m+1);
    if(!check(a[n]))ans++;
    for(int i=1;i<n;i++){
        if(!check(a[i])&&check(a[i+1]))ans++;
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：先对 $b$ 数组排序，然后使用二分查找判断 $a$ 中的元素是否在 $b$ 中。统计片段时，若当前元素未被切割且下一个元素被切割，则片段数加 1，最后特判最后一个元素未被切割的情况。

- **Maxmilite 题解（4星）**
    - **关键亮点**：提供了多种查找切割点的方法，拓宽了解题思路。
    - **核心代码（双指针）**：
```cpp
struct Node {
    int num;
    lint val;
    int isMarked;
} a[1000005];
scanf("%d%d", &n, &m);
for (int i = 1; i <= n; ++i) {
    lint var;
    scanf("%lld", &var);
    a[i] = Node(i, var);
}
for (int i = 1; i <= m; ++i) {
    scanf("%lld", b + i);
}
b[m + 1] = (1ll << 60);
b[0] = -(1ll << 60);
sort(a + 1, a + n + 1, cmp);
sort(b + 1, b + m + 1);
for (int i = 1; i <= n; ++i) {
    while (b[cur] < a[i].val)
        ++cur;
    if (b[cur] == a[i].val)
        a[i].isMarked = 1;
}
```
    - **核心实现思想**：将 $a$ 和 $b$ 数组排序，使用双指针遍历 $a$ 数组，在 $b$ 数组中找到第一个大于等于 $a$ 中元素的位置，若相等则标记该元素为切割点。

### 最优关键思路或技巧
- 使用二分查找来判断元素是否在另一个数组中，将查找时间复杂度从 $O(n)$ 降低到 $O(\log n)$。
- 利用 `unordered_map` 存储键值对，方便快速查找元素是否存在。
- 双指针法可以在排序后的数组中高效地查找元素，避免重复遍历。

### 可拓展之处
同类型题可能会改变数据范围、序列的性质或切割规则，类似算法套路包括使用哈希表、二分查找、双指针等优化查找过程。

### 洛谷相似题目推荐
1. P1102  A-B 数对
2. P2249  【深基13.例1】查找
3. P1090  合并果子

### 个人心得
本题解中未包含个人心得内容。

---
处理用时：24.17秒
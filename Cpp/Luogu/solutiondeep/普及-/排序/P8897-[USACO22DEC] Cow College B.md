# 题目信息

# [USACO22DEC] Cow College B

## 题目描述

Farmer John 计划为奶牛们新开办一所大学！ 

![](https://cdn.luogu.com.cn/upload/image_hosting/wiy5l6d6.png)

有 $N(1 \le N \le 10^5)$ 头奶牛可能会入学。每头奶牛最多愿意支付 $c_i$ 的学费 $(1 \le c_i \le 10^6)$。 Farmer John 可以设定所有奶牛入学需要支付的学费。如果这笔学费大于一头奶牛愿意支付的最高金额，那么这头奶牛就不会入学。Farmer John 想赚尽可能多的钱，从而可以给他的讲师提供一笔可观的工资。请求出他能赚到的钱的数量，以及此时应当收取多少学费。 

## 说明/提示

### 样例 1 解释

如果 Farmer John 收费 $4$，那么 $3$ 头奶牛将会入学，从而使他赚取 $3 \times 4=12$ 的金额。

### 测试点性质

- 测试点 $2-4$ 满足 $c_i \le 1000$。
- 测试点 $5-8$ 满足 $N \le 5000$。
- 测试点 $9-12$ 没有额外限制。 

## 样例 #1

### 输入

```
4
1 6 4 6```

### 输出

```
12 4```

# AI分析结果

### 综合分析与结论
本题的核心是从给定的奶牛愿意支付的学费数组中，找出能让 Farmer John 赚取最多钱的学费定价。各题解思路主要分为暴力枚举和优化枚举两类：
- **暴力枚举**：枚举所有可能的学费，遍历奶牛数组判断能入学的奶牛数量，计算收益并更新最大值。时间复杂度较高，如 $\mathcal{O}(nk)$ 或 $\mathcal{O}((\max{c_i}) \log n)$。
- **优化枚举**：证明最佳学费一定是某头奶牛愿意支付的学费，对数组排序后枚举这些值，维护能入学的奶牛数量，时间复杂度优化到 $\mathcal{O}(n \log n)$ 或 $\mathcal{O}(n)$。

### 所选题解
- **NightStriker（5星）**
    - **关键亮点**：思路清晰，详细给出了 $33$ 分暴力做法和 $100$ 分优化做法，对复杂度分析透彻，强调了 `long long` 的使用。
    - **个人心得**：提到“不开 $\textbf{long long}$ 见祖宗”，提醒注意数据范围可能导致的溢出问题。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1000001],ans,cnt;
signed main() {
    cin>>n;
    int cow = n;
    for (int i = 1; i<=n; i++) cin>>a[i];
    sort(a+1,a+n+1);
    for (int i = 1; i<=n; i++) {
        if (a[i]*cow>ans) {
            ans = a[i]*cow;
            cnt = a[i];
        }
        cow--;
    }
    cout<<ans<<' '<<cnt<<endl;
    return 0;
}
```
核心实现思想：先对奶牛愿意支付的学费数组排序，然后从小到大枚举每个学费值，计算以该学费能入学的奶牛数量（初始为 $n$，每枚举一个学费值减 $1$），更新最大收益和对应的学费。

- **快斗游鹿（4星）**
    - **关键亮点**：思路简洁，证明了最佳学费一定是某头奶牛愿意支付的学费，通过去重排序后枚举，维护能入学的奶牛数量。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
long long n,m,a[N],t[N],cnt;
long long ans,q; 
int main(){
    n=read();m=n;
    for(int i=1;i<=n;i++){
        int A;A=read();if(!t[A])a[++cnt]=A;
        t[A]++;
    }
    sort(a+1,a+1+cnt);
    for(int i=1;i<=cnt;i++){ 
        long long mx=a[i]*m;
        if(ans<mx){
            ans=mx;q=a[i];
        }
        m-=t[a[i]];
    }
    cout<<ans<<" "<<q;
    return 0;
}
```
核心实现思想：用桶记录每个学费值的出现次数，去重排序后枚举每个学费值，计算以该学费能入学的奶牛数量（初始为 $n$，减去当前学费值的出现次数），更新最大收益和对应的学费。

- **Ray1（4星）**
    - **关键亮点**：思路直接，先排序再枚举每头奶牛愿意支付的最高学费，计算收益并更新最大值。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,c[100001],cnt,ans,bns;
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;++i)cin>>c[i];
    sort(c+1,c+1+n);
    for(int i=1;i<=n;i++){
        cnt=c[i]*(n-i+1);
        if(cnt>ans)ans=cnt,bns=c[i];
    }
    cout<<ans<<' '<<bns;
}
```
核心实现思想：对奶牛愿意支付的学费数组排序，枚举每头奶牛愿意支付的最高学费，计算以该学费能入学的奶牛数量（$n - i + 1$），更新最大收益和对应的学费。

### 最优关键思路或技巧
- **优化枚举范围**：证明最佳学费一定是某头奶牛愿意支付的学费，将枚举范围从所有可能的学费缩小到数组中的值，降低时间复杂度。
- **排序与维护计数**：对数组排序后，通过维护能入学的奶牛数量，快速计算每个学费值对应的收益。
- **注意数据范围**：使用 `long long` 避免数据溢出。

### 可拓展之处
同类型题可能会改变数据范围、增加约束条件或改变问题形式，如：
- 增加奶牛的其他属性，如奶牛的产奶量，要求在赚取最多钱的同时满足一定的产奶量要求。
- 改变学费的计算方式，如根据奶牛的数量进行阶梯收费。

### 推荐题目
- P2637 第一次，第二次，成交！
- P1077 摆花
- P1106 删数问题

### 个人心得总结
NightStriker 提到“不开 $\textbf{long long}$ 见祖宗”，强调了在处理可能出现大数的问题时，要注意数据类型的选择，避免因数据溢出导致错误。

---
处理用时：31.70秒
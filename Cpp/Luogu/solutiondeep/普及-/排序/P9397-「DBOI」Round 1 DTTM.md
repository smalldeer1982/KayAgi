# 题目信息

# 「DBOI」Round 1 DTTM

## 题目背景

张则雨和穆制程坐在天台上看着满天的星辰。在他们的世界，流行一种连接星星的活动。他们对此有一种浪漫的诠释：如果连不完，剩下的一颗星星就是身旁的人；如果连得完，那身边的人和自己都是星星。

## 题目描述

星空中有 $n$ 颗星星，第 $i$ 颗位于坐标 $(x_i,y_i)$。你需要把星星连接成满足张则雨的如下需求：

- 每一颗星星都是且仅是一条线段的端点，所有线段互不相交（包括端点）。
- 所有线段左右端点 $|x_l-x_r|$ 之和有最小值。 

然而张则雨有点笨，并不知道应该怎么连。穆制程知道你是地球上最聪明的人，于是告诉你 $n$ 颗星星的坐标，你需要输出连接方案或者报告无解。

## 说明/提示

样例 1 的方案如图：

![](https://s1.ax1x.com/2023/04/06/ppomH5q.png)

样例 2 的方案如图：

![](https://s1.ax1x.com/2023/04/06/ppomDDH.png)

**本题使用捆绑测试与子任务依赖。**

| $\rm Subtask$ | $n\leqslant$ | $(x,y)$ | 特殊性质 | 得分 | 子任务依赖 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $10$ | $0\leqslant x,y\leqslant 20$ | 无 | $10$ | 无 |
| $2$ | $10^3$ | $0\leqslant x,y\leqslant10^3$ | 无 | $15$ | $1$ |
| $3$ | $10^3$ | $0\leqslant x,y\leqslant10^9$ | 无 | $15$ | $1,2$ |
| $4$ | $5\times10^5$ |$-10^9\leqslant x,y\leqslant10^9$  | $A$ | $5$ | 无 |
| $5$ | $5\times10^5$ | $-10^3\leqslant x,y\leqslant10^3$ | 无 | $20$ | $1,2$
| $6$ | $5\times10^5$ | $-10^9\leqslant x,y\leqslant10^9$ | 无 | $35$ | $1,2,3,4,5$


特殊性质 $A$：满足所有 $x_i$ 都相等。

保证对于 $100\%$ 的数据，$1\leqslant n\leqslant5\times 10^5$，$0\leqslant|x|,|y|\leqslant 10^9$ 且对于任意 $i\ne j$，有 $(x_i,y_i)\neq (x_j,y_j)$。

## 样例 #1

### 输入

```
4
1 3
2 2
2 1
3 4```

### 输出

```
2
1 4
2 3```

## 样例 #2

### 输入

```
6
1 5
2 3
2 4
2 5
2 -1
3 -3```

### 输出

```
2
1 3
4 6
2 5```

# AI分析结果

### 综合分析与结论
这些题解大多采用贪心算法解决本题。核心思路是先判断星星数量 $n$ 的奇偶性，若为奇数则无解输出 $-1$；若为偶数，将星星按 $x$ 坐标排序，$x$ 相同时按 $y$ 坐标排序，然后依次连接相邻星星，计算并输出 $|x_l - x_r|$ 之和及连接方案。部分题解给出了线段不相交的证明。

### 所选题解
- **wmrqwq（5星）**
    - 关键亮点：思路清晰，代码简洁易懂，详细解释了结构体定义和排序规则。
    - 核心代码：
```cpp
struct node
{
    int x,y,id;
};
bool cmp(node a,node b)
{
    if(a.x==b.x)
        return a.y<b.y;
    return a.x<b.x;
}
// 主函数中排序和计算部分
sort(a,a+n,cmp);
for(int i=0;i<n;i+=2)
    sum+=a[i+1].x-a[i].x;
```
- **lailai0916（4星）**
    - 关键亮点：思路明确，代码规范，注释清晰，便于理解。
    - 核心代码：
```cpp
struct Node
{
    int x,y,id;
};
bool cmp(Node u,Node v)
{
    if(u.x!=v.x)return u.x<v.x;
    return u.y<v.y;
}
// 主函数中排序和计算部分
sort(a+1,a+n+1,cmp);
for(int i=1;i<=n;i+=2)
{
    sum+=a[i+1].x-a[i].x;
}
```
- **回声之歌（4星）**
    - 关键亮点：不仅给出了贪心思路，还详细分析了线段不相交的条件并给出证明。
    - 核心代码：
```cpp
struct node {
    int x, y, z;
    bool operator<(const node &b)const {
        if (x == b.x)return y < b.y;
        return x < b.x;
    }
};
// 主函数中排序和计算部分
sort(a, a + n);
for (int i = 0; i < n; cost += a[i + 1].x - a[i].x, i += 2);
```

### 最优关键思路或技巧
- **贪心策略**：将星星按 $x$ 坐标排序，$x$ 相同时按 $y$ 坐标排序，连接相邻星星可使 $|x_l - x_r|$ 之和最小。
- **结构体排序**：定义结构体存储星星坐标和编号，自定义比较函数或重载运算符进行排序。

### 可拓展之处
同类型题可拓展到三维空间，要求线段不相交且 $|x_l - x_r| + |y_l - y_r| + |z_l - z_r|$ 之和最小。类似算法套路可用于解决区间合并、任务调度等问题，通过排序和贪心策略找到最优解。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：贪心算法，每次合并最小的两堆果子。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：贪心算法，按接水时间从小到大排序。
- [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：贪心算法，按单位价值从大到小选择物品。

### 个人心得摘录与总结
- **OcTar**：作者提到最开始把重载运算符的变量顺序写反，喜提 $5$ 分，提醒我们在编写代码时要注意细节，避免因小错误导致结果错误。
- **ZYH_juruo**：作者第一次提交只得了 $5$ 分，回头读题发现没有判断 $n$ 为奇数的无解情况，强调了读题的重要性，要仔细审题，考虑所有可能情况。 

---
处理用时：24.51秒
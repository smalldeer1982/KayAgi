# 题目信息

# 「RiOI-2」weight

## 题目背景

在小树林间坐落着一个幻想的城堡。这里是 E 国的领地，而小 E，则是 E 国之王。

树木，是 E 国抵挡袭击的法宝。树木越高，越能蒙蔽敌人的视线。

可是，随着自然条件的退化，小 E 却不知怎么处理。怎么办呢？

## 题目描述

给定一个 $n$ 行 $n$ 列 的矩阵 $a$。

有 $q$ 组询问，每次给定一个 $v$，请将矩阵每一行任意重排（可以不重排），最大化**最大值不小于** $v$（也就是说，至少有一个不小于 $v$ 的数）的列数。请输出这个列数。

询问之间相互独立。换言之，每次询问前可以重新排列。


## 说明/提示

### 样例解释

原矩阵为 $\begin{bmatrix}9&9&8\\2&4&4\\3&5&3\end{bmatrix}$。

对于第一次询问，每一列的最大值 $9,9,8$ 均不小于 $v=5$，所以每一列都符合条件，答案为 $3$。显然无论怎么重排都不可能超过 $3$ 列（因为总共只有 $3$ 列），所以答案为 $3$。

### 数据规模与约定

**本题开启捆绑测试。**

| $\text{Subtask}$ | 分值 | $n \leq$ | $q \leq$ |
| :--------------: | :--: | :------: | :------: |
| $0$ | $10$ | $3$ | $10$ |
| $1$ | $40$ | $100$ | $10^3$ |
| $2$ | $50$ | $10^3$ | $5\times 10^5$ |

对于所有数据，$1 \leq n \leq 10^3$，$1 \leq q \leq 5\times 10^5$，$1 \leq a_{i,j}, v \leq 10^9$。

## 样例 #1

### 输入

```
3 3
9 9 8
2 4 4
3 5 3
5
9
10```

### 输出

```
3
2
0```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是将矩阵元素存于一维数组，排序后统计大于等于查询值 $v$ 的元素个数，再与 $n$ 取最小值得到答案。不同题解在实现细节和优化程度上有差异，如部分使用二分查找优化查询，部分采用离线处理等。

### 所选题解
- **include13_fAKe（5星）**
    - **关键亮点**：思路清晰，详细分析不同子任务复杂度并给出优化方案，代码实现简洁，使用二分查找优化查询。
    - **个人心得**：作者提到从小到大排序很麻烦，暗示从大到小排序更方便处理。
    - **核心代码**：
```cpp
void solve(int v){
    int l=n*(n-1)+1;
    int r=n*n;
    if(v<=a[l]){
        printf("%d\n",n);
        return;
    }
    if(v>a[r]){
        printf("0\n");
        return;
    }
    int mid=l+r>>1;
    while(l<r){
        if(v<=a[mid]) r=mid;
        else l=mid+1;
        mid=l+r>>1;
    }
    printf("%d\n",n*n+1-l);
    return;
}
```
核心思想：先判断边界情况，再用二分查找第一个大于等于 $v$ 的元素位置，计算大于等于 $v$ 的元素个数并与 $n$ 取最小值输出。

- **Meny__love（4星）**
    - **关键亮点**：思路简洁明了，直接指出统计大于查询数 $v$ 的元素个数即可，使用标准库函数 `lower_bound` 和 `upper_bound` 进行二分查找。
    - **核心代码**：
```cpp
sort(a+1,a+1+len);
for(int i=1;i<=q;i++){
    int x;
    scanf("%d",&x);
    int mid=lower_bound(a+1,a+len+1,x)-a;
    int mid1=upper_bound(a+1,a+len+1,x)-a;
    if(a[mid]==x) printf("%d\n",min(len-mid+1,n));
    else if(a[mid1]>x) printf("%d\n",min(len-mid1+1,n));
    else printf("0\n");
}
```
核心思想：排序后用标准库二分查找函数找到第一个大于等于 $x$ 的元素位置，计算大于等于 $x$ 的元素个数并与 $n$ 取最小值输出。

- **251Sec（4星）**
    - **关键亮点**：对答案上界进行证明，理论严谨，代码简洁，使用 `lower_bound` 进行二分查找。
    - **核心代码**：
```cpp
sort(w + 1, w + n * n + 1);
while (q--) {
    int x;
    scanf("%d", &x);
    printf("%lld\n", min(1ll * n, 1ll * n * n - (lower_bound(w + 1, w + n * n + 1, x) - w) + 1));
}
```
核心思想：排序后用 `lower_bound` 找到第一个大于等于 $x$ 的元素位置，计算大于等于 $x$ 的元素个数并与 $n$ 取最小值输出。

### 最优关键思路或技巧
- **数据结构**：使用一维数组存储矩阵元素，简化处理。
- **算法优化**：排序后使用二分查找，将查询复杂度从 $O(n^2)$ 优化到 $O(\log n)$。
- **思维方式**：将矩阵重排问题转化为统计大于等于查询值的元素个数问题，避免复杂的排列组合计算。

### 可拓展之处
同类型题如矩阵元素操作、二维数组查询问题等，可采用类似思路，将二维问题转化为一维问题，再用排序和二分查找优化。

### 推荐题目
- P1102 A-B 数对
- P2249 【深基13.例1】查找
- P1678 烦恼的高考志愿

### 个人心得摘录与总结
- include13_fAKe：作者首次完成洛谷月赛 Div.2B 题，因下棋未按时参赛。提到从小到大排序麻烦，暗示从大到小排序更方便处理，提醒在实现时选择合适的排序顺序。 

---
处理用时：22.66秒
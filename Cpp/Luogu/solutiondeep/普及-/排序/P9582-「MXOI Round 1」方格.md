# 题目信息

# 「MXOI Round 1」方格

## 题目描述

小 C 和方格是好朋友。

小 C 有一个 $n$ 行 $m$ 列的方格图，每个方格中都有一个数字，其中第 $i$ 行第 $j$ 列的方格中的数字为 $a_{i,j}$。

我们定义，在这个方格图中，两个不同的方格不相邻，当且仅当这两个方格**没有公共边**。

小 C 认为，两个不同的方格互为好朋友，当且仅当这两个方格**不相邻**且**这两个方格中的数字相同**。

小 C 想让你帮忙求出，所有方格的好朋友的数量之和是多少。

## 说明/提示

#### 【样例解释 #1】

第 $1$ 行第 $1$ 列的方格共有 $3$ 个好朋友，第 $1$ 行第 $2$ 列的方格共有 $2$ 个好朋友，第 $1$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $1$ 行第 $4$ 列的方格共有 $0$ 个好朋友；

第 $2$ 行第 $1$ 列的方格共有 $1$ 个好朋友，第 $2$ 行第 $2$ 列的方格共有 $2$ 个好朋友，第 $2$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $2$ 行第 $4$ 列的方格共有 $1$ 个好朋友；

第 $3$ 行第 $1$ 列的方格共有 $1$ 个好朋友，第 $3$ 行第 $2$ 列的方格共有 $3$ 个好朋友，第 $3$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $3$ 行第 $4$ 列的方格共有 $4$ 个好朋友；

所有方格的好朋友数量之和为 $20$。

#### 【样例 #2】

见附加文件中的 `square/square2.in` 与 `square/square2.ans`。

该样例满足测试点 $1$ 的限制。

#### 【样例 #3】

见附加文件中的 `square/square3.in` 与 `square/square3.ans`。

该样例满足测试点 $4$ 的限制。

#### 【样例 #4】

见附加文件中的 `square/square4.in` 与 `square/square4.ans`。

该样例满足测试点 $6$ 的限制。

#### 【样例 #5】

见附加文件中的 `square/square5.in` 与 `square/square5.ans`。

该样例满足测试点 $10$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le n,m \le 2000$，$1 \le a_{i,j} \le 9$。

|测试点编号|$n,m \le$|$a_{i,j} \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim3$|$80$|$9$|否|
|$4\sim5$|$2000$|$1$|否|
|$6\sim7$|$2000$|$9$|是|
|$8\sim10$|$2000$|$9$|否|

特殊性质：保证任意两个相邻的方格中的数不相等。

## 样例 #1

### 输入

```
3 4
1 1 4 5
2 1 2 3
3 1 4 1```

### 输出

```
20```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是利用桶排统计每个数字出现的次数，先计算出所有相同数字组合的理论数量，再减去相邻且数字相同的不合法组合数量。部分题解针对不同测试点数据特征给出了优化思路，但最终通用解法一致。

### 所选题解
- **作者：Coffee_zzz（5星）**
    - **关键亮点**：思路清晰，对不同测试点进行分类讨论，代码简洁规范。
    - **个人心得**：强调“时刻铭记不开 `long long` 见祖宗”，提醒注意数据范围可能导致的溢出问题。
- **作者：zzx114514（4星）**
    - **关键亮点**：解题思路阐述详细，代码注释清晰，易于理解。
- **作者：_JF_（4星）**
    - **关键亮点**：简洁明了地指出解题方向，代码实现简洁高效。

### 重点代码及核心思想
#### Coffee_zzz
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2005,A=15;
int n,m,a[N][N],c[A];
ll ans;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            c[a[i][j]]++;
        }
    }
    for(int i=1;i<=9;i++) ans=ans+1ll*c[i]*(c[i]-1);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(a[i][j]==a[i-1][j]) ans--;
            if(a[i][j]==a[i][j-1]) ans--;
            if(a[i][j]==a[i+1][j]) ans--;
            if(a[i][j]==a[i][j+1]) ans--;
        }
    }
    cout<<ans;
    return 0;
}
```
核心思想：先统计每个数字出现的次数，计算所有相同数字组合的理论数量，再遍历方格图减去相邻且数字相同的不合法组合数量。

#### zzx114514
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,a[2005][2005],t[10],ans; 
int main()
{
    cin>>n>>m;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        {
            cin>>a[i][j];
            t[a[i][j]]++;//统计数字出现个数 
        }
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        {
            ans+=t[a[i][j]]-1;//开始假设所有相同元素均不相邻 
            if (i>1 && a[i-1][j]==a[i][j]) ans--;
            if (i<n && a[i+1][j]==a[i][j]) ans--;
            if (j>1 && a[i][j-1]==a[i][j]) ans--;
            if (j<m && a[i][j+1]==a[i][j]) ans--;
            //如果相邻且相同则将ans-1 
        }
    cout<<ans;
    return 0;
}
```
核心思想：同样先统计数字出现次数，对每个方格，先假设所有相同元素均不相邻，再减去相邻且相同的元素数量。

#### _JF_
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =5001;
#define int long long 
int a[N][N],t[N],ans;
signed main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)	
            scanf("%lld",&a[i][j]),t[a[i][j]]++;
    for(int i=1;i<=9;i++)
        ans+=t[i]*(t[i]-1);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            if(a[i][j]==a[i-1][j])	ans--;
            if(a[i][j]==a[i][j-1])	ans--;
            if(a[i][j]==a[i+1][j])	ans--;
            if(a[i][j]==a[i][j+1])	ans--;
        }
    cout<<ans<<endl;
    return 0;
}
```
核心思想：先统计每个数字出现次数，计算所有相同数字组合的理论数量，再减去相邻且数字相同的不合法组合数量。

### 最优关键思路或技巧
- **桶排思想**：利用数组作为桶统计每个数字出现的次数，将时间复杂度从暴力枚举的 $O(n^4)$ 优化到 $O(nm)$。
- **先计算理论值再排除不合法情况**：先计算所有相同数字组合的理论数量，再遍历方格图减去相邻且数字相同的不合法组合数量，简化计算过程。

### 拓展思路
同类型题可能会改变方格相邻的定义（如增加对角线相邻），或者改变数字范围，可根据具体情况调整桶的大小和判断相邻的逻辑。类似算法套路还有先计算所有可能情况，再排除不符合条件的情况，常用于组合计数问题。

### 推荐题目
- P1168 中位数：利用数据结构（如对顶堆）动态维护中位数，与本题利用桶排统计数据特征有相似之处。
- P1908 逆序对：可使用归并排序或树状数组统计逆序对数量，与本题先计算理论值再排除不合法情况的思路类似。
- P2613 【模板】有理数取余：涉及数论知识和取模运算，可锻炼对数据范围和特殊情况的处理能力。 

---
处理用时：34.45秒
# 题目信息

# [USACO19JAN] Sleepy Cow Sorting B

## 题目描述

Farmer John正在尝试将他的 $N$ 头奶牛（$1\le N\le 100$），方便起见编号为 $1\ldots N$，在她们前往牧草地吃早餐之前排好顺序。

当前，这些奶牛以 $p_1,p_2,p_3,\ldots,p_N$ 的顺序排成一行，Farmer John 站在奶牛 $p_1$ 前面。他想要重新排列这些奶牛，使得她们的顺序变为 $1,2,3,\ldots,N$，奶牛 $1$ 在 Farmer John 旁边。

今天奶牛们有些困倦，所以任何时刻都只有直接面向 Farmer John 的奶牛会注意听 Farmer John 的指令。每一次他可以命令这头奶牛沿着队伍向后移动 $k$ 步，$k$ 可以是范围 $1\ldots N−1$ 中的任意数。她经过的 $k$ 头奶牛会向前移动，腾出空间使得她能够插入到队伍中这些奶牛之后的位置。

例如，假设 $N=4$，奶牛们开始时是这样的顺序：

> FJ: $4, 3, 2, 1$

唯一注意 FJ 指令的奶牛是奶牛 $4$。当他命令她向队伍后移动 $2$ 步之后，队伍的顺序会变成：

> FJ: $3, 2, 4, 1$

现在唯一注意 FJ 指令的奶牛是奶牛 $3$，所以第二次他可以给奶牛 $3$ 下命令，如此进行直到奶牛们排好了顺序。

Farmer John 急欲完成排序，这样他就可以回到他的农舍里享用他自己的早餐了。请帮助他求出将奶牛们排好顺序所需要的最小操作次数。 

## 样例 #1

### 输入

```
4
1 2 4 3```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致，均是通过寻找逆序对来确定需要移动的奶牛，计算每次移动所需步数并累加得到最小操作次数。部分题解还给出了引理证明和不同的思考角度。

### 所选题解
- **作者：Arson1st（5星）**
    - **关键亮点**：给出引理证明，思路严谨清晰，详细阐述了操作次数的必要性和充分性，代码简洁。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 110;

int n, p[N], ans;

int main() {
    scanf("%d", &n);
    for (int i = 1, la = 1; i <= n; i ++) {
        scanf("%d", &p[i]);  if (p[i] >= p[i-1]) continue;
        ans += i - la; la = i;
    }
    printf("%d", ans);
}
```
    - **核心实现思想**：遍历数组，若当前元素小于前一个元素（出现逆序对），则将当前位置与上一次逆序位置的差值累加到结果中，并更新上一次逆序位置。

- **作者：we_are_the_chuibing（4星）**
    - **关键亮点**：思路简洁直接，代码实现简单易懂。
    - **核心代码**：
```cpp
#include<iostream>
#define luogu return
#define yyds 0;
using namespace std;
int n,bs,a[105],k=1;
int main(){
    cin>>n;
    for(int i=1;i<=n;++i)cin>>a[i];
    for(int i=1;i<=n;++i){
        if(a[i]<a[i-1]){
            bs+=(i-k);
            k=i;
        }
    }
    cout<<bs;
    luogu yyds
}
```
    - **核心实现思想**：同样遍历数组，遇到逆序对时，将当前位置与记录位置的差值累加到步数中，并更新记录位置。

- **作者：T_TLucas_Yin（4星）**
    - **关键亮点**：详细解释了每次操作步数的计算原理，考虑了前面操作对后面操作的影响。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],l=1,sum;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++){
        if(a[i]<a[i-1]) sum+=i-l,l=i;
    }
    cout<<sum;
    return 0;
}
```
    - **核心实现思想**：遍历数组，若出现逆序对，将当前位置与上一次调换位置的差值累加到总和中，并更新上一次调换位置。

### 最优关键思路或技巧
- 寻找逆序对：通过判断相邻元素的大小关系，找出顺序混乱的位置。
- 记录上一次逆序位置：利用一个变量记录上一次出现逆序的位置，计算当前逆序位置与上一次的差值，即为本次操作所需步数。

### 拓展思路
同类型题可考虑增加操作限制或改变序列特征，如每次移动的步长有限制、序列元素有重复等。类似算法套路可用于解决一些排序优化问题，通过寻找逆序对或特殊位置来减少操作次数。

### 推荐题目
- P1177 【模板】快速排序
- P1271 【深基9.例1】选举学生会
- P1923 【深基9.例4】求第k小的数

### 个人心得
题解中未包含个人心得。 

---
处理用时：20.54秒
# 题目信息

# 寻找团伙

## 题目描述

世界局势风云变幻，你想办一件大事。办事自然要有人参与，你能从 $n$ 个人里面挑选一部分人共襄盛举。

要办这件事，一共涉及 $k$ 方面的能力，例如游说他人的能力、玩游戏的能力、睡觉的能力。每位人士都会具备某一些能力，例如机器猫就可能擅长睡觉、擅长玩游戏，而不擅长游说他人。

你的计划很宏伟，因此你希望团队拥有很全面的能力。不幸的是，如果团队中有偶数个人拥有同一类能力，那么他们就会分成两派，争执不下，导致整个团队丧失这方面的能力。相应地，如果这项能力只有奇数个人拥有，那么他们总能形成一个多数派，帮团队去做这方面的工作。

需要注意的是，团队拥有的每一项能力，对计划的成功率的贡献是不一样的。第一项能力最重要，它的权重是 $2^{k-1}$；第二项能力的权重是 $2^{k-2}$；依次类推。第 $k$ 项能力最不重要，权重只有 $1$。

计划的成功率得分，即是**团队拥有的所有能力对应的权重之和**。

你希望计划成功率最大。因此，你需要选出合适的人士，来参与到你的宏图伟业中。


## 说明/提示

#### 样例解释

第一组样例，共 5 个人，每个人拥有的能力不一样。最终选择的结果是让这 5 个人都参与计划，得分 $16+8+4+2+1 = 31$。

第二组样例，我们选择只让 $1$ 参与。那么团队具有能力 $1,2, 3$，得分 $16+8+4=28$。

第三组样例，我们让 $1,2,3$ 参与。由于团队中有偶数个成员拥有能力 $5$，故团队并不拥有能力 $5$。奇数个成员拥有能力 $2$，故团队拥有能力 $2$。最终，团队具有能力 $1,2,3,4$。得分 $16+8+4+2=30$。

#### 数据规模与约定

对于 $100\%$ 的数据，有 $n\leq 21, k\leq 60$。




## 样例 #1

### 输入

```
5 5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
31```

## 样例 #2

### 输入

```
3 5
3 1 2 3
4 2 3 4 5
2 3 4```

### 输出

```
28```

## 样例 #3

### 输入

```
3 5
2 1 2
3 5 3 2
3 4 2 5```

### 输出

```
30```

## 样例 #4

### 输入

```
21 60
0 
0 
3 60 27 48
0 
1 48
2 52 14
2 4 31
0 
0 
2 28 43
2 6 31
0 
1 7
3 45 6 48
0 
1 51
0 
2 28 20
2 37 51
1 8
53 59 39 29 23 53 27 13 16 44 34 38 24 9 32 58 54 31 1 7 45 3 30 36 17 48 42 22 18 21 6 11 25 33 37 52 10 60 49 57 2 28 8 14 5 47 4 41 35 43 50 46 26 12```

### 输出

```
1152884121210322895```

# AI分析结果



### 综合分析与结论
题目核心是求子集异或和的最大值，本质是最大异或和问题。各题解围绕两种思路展开：  
1. **暴力枚举**：利用n≤21的特性，直接枚举所有子集（O(2ⁿ)），适用于本题数据范围。  
2. **线性基优化**：通过构建线性基将复杂度降至O(nk)，是更优的通用解法。  
关键技巧在于用二进制位表示能力权重，并利用异或运算的奇偶性特性。

---

### 高评分题解推荐

#### 1. 阮行止（★★★★★）
**关键亮点**：  
- 思路清晰，递归枚举子集代码简洁易懂  
- 明确指出`1ULL`的坑点，避免溢出错误  
- 对比了暴力与线性基的复杂度差异，拓展性强  

**核心代码**：递归枚举子集并计算异或和
```cpp
void dfs(int pos) {
    if(pos == n) {
        ull res = 0;
        for(int i=0; i<n; i++) if(choice[i]) res ^= p[i];
        ans = max(res, ans);
        return;
    }
    choice[pos] = 0; dfs(pos + 1); // 不选当前人
    choice[pos] = 1; dfs(pos + 1); // 选当前人
}
```

#### 2. Usada_Pekora（★★★★☆）
**关键亮点**：  
- 提供DFS与线性基双解法，覆盖不同场景  
- 详细解释异或运算的实际意义（奇偶性判断）  
- 线性基代码简洁，含贪心策略注释  

**线性基核心代码**：
```cpp
void insert(ull x) {
    for(int i=k-1; i>=0; --i) 
        if(x >> i & 1) {
            if(!base[i]) { base[i] = x; break; }
            else x ^= base[i];
        }
}
ull query() {
    ull res = 0;
    for(int i=k-1; i>=0; --i) 
        if((res ^ base[i]) > res) res ^= base[i];
    return res;
}
```

#### 3. 5k_sync_closer（★★★★☆）
**关键亮点**：  
- 位运算枚举子集，代码极简  
- 明确强调`1ull`的正确用法  
- 双重循环结构清晰，便于理解  

**核心代码**：位掩码枚举所有子集
```cpp
for(unsigned s=0; s < (1<<n); ++s) {
    ull sum = 0;
    for(int i=0; i<n; ++i) 
        if(s & (1<<i)) sum ^= p[i];
    ans = max(ans, sum);
}
```

---

### 最优关键思路总结
1. **异或性质应用**：奇数次选中的能力权重相加等价于所有选中能力的异或和。  
2. **位运算优化**：用`(1ULL << (k-x))`生成权重，避免整型溢出。  
3. **线性基贪心**：通过构建基向量并贪心选取，快速求最大异或和。  

---

### 拓展与举一反三
- **类似问题**：最大异或和（如数组中选择若干数使异或和最大）  
- **算法套路**：  
  - 数据量小时（n≤25）：暴力枚举子集  
  - 数据量大时：线性基、高斯消元  
- **推荐题目**：  
  1. [P3812 【模板】线性基](https://www.luogu.com.cn/problem/P3812)  
  2. [P4151 [WC2011]最大XOR和路径](https://www.luogu.com.cn/problem/P4151)  
  3. [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)  

---

### 题解中的个人心得摘录
1. **阮行止**：  
   > "若不写`1ULL`，编译器将其视为int型的1，程序会WA"  
   **总结**：位运算必须注意数据类型，尤其涉及大位移时。  

2. **Usada_Pekora**：  
   > "暴搜遇上n更大数据无能为力，第二天才想起线性基"  
   **总结**：线性基是处理异或问题的利器，需熟练掌握。  

3. **ImposterAnYu**：  
   > "状压DP的O(3ⁿ)转移太慢，改用暴力枚举"  
   **总结**：根据数据范围选择算法，避免过度设计。

---
处理用时：51.37秒
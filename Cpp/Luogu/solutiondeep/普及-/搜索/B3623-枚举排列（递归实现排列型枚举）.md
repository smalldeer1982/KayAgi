# 题目信息

# 枚举排列（递归实现排列型枚举）

## 题目描述

今有 $n$ 名学生，要从中选出 $k$ 人排成一列拍照。

请按字典序输出所有可能的排列方式。

## 说明/提示

对于 $100\%$ 的数据，$1\leq k\leq n \leq 10$。

## 样例 #1

### 输入

```
3 2```

### 输出

```
1 2
1 3
2 1
2 3
3 1
3 2```

# AI分析结果



### 综合分析与结论
本题要求按字典序输出 n 选 k 的排列。核心是通过回溯法生成不重复的排列，利用标记数组避免重复选择。最优解法是回溯+状态标记，时间复杂度为 O(n!/(n−k)!))，显著优于暴力枚举。

---

### 所选高分题解（5星）

#### 作者：ShanCreeperPro
**关键亮点**  
1. 明确区分了暴力枚举与回溯法的效率差异，点明问题本质  
2. 通过 `use` 数组标记已选元素的思路清晰易懂  
3. 给出递归框架的关键逻辑（递归层数、标记与回溯时机）  
4. 推荐同类题目形成学习链路  

**个人心得**  
无具体代码但隐含调试经验：强调「递归完成后要将 use 标记重置」，这是回溯法的核心易错点。

---

### 核心代码实现
```cpp
int a[15], use[15], n, k;

void dfs(int step) {
    if (step > k) { // 终止条件：已选k个元素
        for (int i = 1; i <= k; i++)
            printf("%d ", a[i]);
        puts("");
        return;
    }
    for (int i = 1; i <= n; i++) {
        if (!use[i]) { // 仅选择未使用的元素
            a[step] = i;
            use[i] = 1;
            dfs(step + 1); // 递归下一层
            use[i] = 0;    // 回溯：撤销选择
        }
    }
}
```
**实现思想**  
递归树深度为 k，每层遍历所有未被选中的数。字典序的保障来自按顺序遍历数字（i 从 1 到 n）。

---

### 同类题目推荐
1. **P1706 全排列问题** - 经典全排列模板题  
2. **P1157 组合的输出** - 组合问题（不考虑顺序）的递归实现  
3. **P1036 [NOIP2002 普及组] 选数** - 组合+素数判断，训练剪枝思维

---
处理用时：77.02秒
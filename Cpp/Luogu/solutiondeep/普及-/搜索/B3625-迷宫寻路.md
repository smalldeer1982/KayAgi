# 题目信息

# 迷宫寻路

## 题目描述

机器猫被困在一个矩形迷宫里。

迷宫可以视为一个 $n\times m$ 矩阵，每个位置要么是空地，要么是墙。机器猫只能从一个空地走到其上、下、左、右的空地。

机器猫初始时位于 $(1, 1)$ 的位置，问能否走到 $(n, m)$ 位置。


## 说明/提示

#### 样例解释

路线如下：$(1,1)\to (2,1) \to (3,1) \to (3,2)\to (3,3) \to (2, 3) \to (2, 4) \to (2, 5) \to (3, 5)$

#### 数据规模与约定 

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 100$，且 $(1,1)$ 和 $(n, m)$ 均为空地。

## 样例 #1

### 输入

```
3 5
.##.#
.#...
...#.```

### 输出

```
Yes```

# AI分析结果



### 综合分析与结论
本题是典型的迷宫路径存在性问题，核心在于遍历所有可达路径。两种主流解法是 DFS（深度优先搜索）和 BFS（广度优先搜索）。DFS 通过递归或栈实现路径探索，BFS 借助队列逐层扩展。两种方法均需标记已访问点以避免循环。BFS 效率更优（尤其当路径较短时），而 DFS 实现更简洁。

---

### 精选题解（评分≥4星）

#### 题解1：BFS（作者：ShanCreeperPro，⭐️⭐️⭐️⭐️）
**关键亮点**  
- 强调逐层扩展的搜索思路，逻辑清晰符合直觉。  
- 明确队列处理流程（入队、弹队、剪枝、扩展）。  
**核心思想**：  
1. 起点入队并标记访问。  
2. 循环处理队列，每次弹出一个点。  
3. 若到达终点则返回成功。  
4. 遍历四个方向，合法点入队并标记。  

**代码片段**  
```cpp
bool bfs(vector<string>& maze, int n, int m) {
    queue<pair<int, int>> q;
    vector<vector<bool>> vis(n, vector<bool>(m, false));
    int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0}; // 方向数组
    
    q.push({0, 0});
    vis[0][0] = true;
    
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        if (x == n-1 && y == m-1) return true; // 到达终点
        
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >=0 && nx <n && ny >=0 && ny <m && !vis[nx][ny] && maze[nx][ny] == '.') {
                vis[nx][ny] = true;
                q.push({nx, ny});
            }
        }
    }
    return false;
}
```

---

#### 题解2：DFS（作者：ShanCreeperPro，⭐️⭐️⭐️⭐️）
**关键亮点**  
- 简洁解释回溯逻辑，强调剪枝的必要性。  
- 递归实现直观，适合小规模迷宫。  
**核心思想**：  
1. 递归终止条件为到达终点。  
2. 提前剪枝非法点和已访问点。  
3. 四个方向递归搜索。  

**代码片段**  
```cpp
bool dfs(vector<string>& maze, vector<vector<bool>>& vis, int x, int y, int n, int m) {
    if (x == n-1 && y == m-1) return true;
    vis[x][y] = true;
    
    int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i], ny = y + dy[i];
        if (nx >=0 && nx <n && ny >=0 && ny <m && !vis[nx][ny] && maze[nx][ny] == '.') {
            if (dfs(maze, vis, nx, ny, n, m)) return true;
        }
    }
    return false;
}
```

---

### 最优关键技巧总结
1. **方向数组**：使用 `dx/dy` 数组简化四个方向的遍历代码。  
2. **访问标记**：必须标记已访问点，避免重复计算。  
3. **输入处理**：注意题目坐标的 1-based 或 0-based 转换（本题代码使用 0-based）。  

---

### 拓展与举一反三
- **同类问题**：动态障碍（如 P3659）、多钥匙门（如 P3818）、最短路径（如 P1141）。  
- **优化技巧**：双向 BFS、A* 算法（复杂迷宫）、并查集预处理连通性。  

---

### 推荐练习题
1. **P1141 01迷宫**（连通块大小，BFS/DFS）  
2. **P1443 马的遍历**（BFS求最短步数）  
3. **P1162 填涂颜色**（矩阵遍历与边界处理）

---
处理用时：63.84秒
# 题目信息

# 跳跃机器人

## 题目描述

地上有一排格子，共 $n$ 个位置。机器猫站在第一个格子上，需要取第 $n$ 个格子里的东西。

机器猫当然不愿意自己跑过去，所以机器猫从口袋里掏出了一个机器人！这个机器人的行动遵循下面的规则：

- 初始时，机器人位于 $1$ 号格子
- 若机器人目前在 $x$ 格子，那么它可以跳跃到 $x-1, x+1, 2x$ 里的一个格子（不允许跳出界）

问机器人最少需要多少次跳跃，才能到达 $n$ 号格子。

## 说明/提示

#### 样例解释

第一组样例：  
$1\to 2 \to 4\to 8 \to 16 \to 15 \to 30$

第二组样例：  
$1\to 2\to 3\to6\to12\to24\to25\to 50$

第三组样例：  
$1\to 2\to4\to8\to16\to32\to64$

第四组样例：  
$1\to 2\to4\to8\to16\to32\to31\to62\to63$  

请注意在本组样例中，$63$ 不能通过 $64-1$ 得到，因为格子总数为 $63$，没有第 $64$ 个格子。


#### 数据规模与约定

对于 $100\%$ 的数据，有 $1\leq n \leq 1000000$。

## 样例 #1

### 输入

```
30```

### 输出

```
6```

## 样例 #2

### 输入

```
50```

### 输出

```
7```

## 样例 #3

### 输入

```
64```

### 输出

```
6```

## 样例 #4

### 输入

```
63```

### 输出

```
8```

# AI分析结果



### 综合分析与结论
本题需要求解机器人到达终点的最短跳跃次数，属于典型的无权图最短路径问题。广度优先搜索（BFS）是标准解法，核心在于正确标记已访问节点避免重复计算，同时处理越界条件。

### 所选题解分析
#### 题解作者：ShanCreeperPro（⭐️⭐️⭐️⭐️）
**关键亮点**  
1. 采用标准的BFS框架，确保首次到达终点时的步数即为最小值  
2. 强调必须标记已访问节点，避免重复入队导致MLE  
3. 通过结构体封装位置和步数，代码结构清晰  

**个人心得**  
> "一定要标记！否则会MLE" —— 作者通过调试发现未标记会导致内存爆炸，提醒读者注意队列重复入队问题。

**核心代码思想**  
```cpp
struct pos { int x, cost; }; // 封装位置和步数
queue<pos> q;
bool vis[...]; // 标记数组
q.push({1, 0});
while (!q.empty()) {
    pos cur = q.front(); q.pop();
    if (cur.x == n) return cur.cost;
    for (新位置x±1, 2x) {
        if (越界或已访问) continue;
        vis[新位置] = true;
        q.push(新位置);
    }
}
```

### 最优思路总结
1. **BFS分层扩展**：天然保证首次到达时的步数最小  
2. **剪枝优化**：通过标记数组和越界检查减少无效状态  
3. **边界处理**：跳跃前验证位置合法性（1 ≤ x ≤ n）

### 拓展与举一反三
- **同类问题**：网格最短路径、状态转换问题（如翻牌、电梯楼层）  
- **优化技巧**：双端队列BFS（处理不同权值）、双向BFS（减少搜索空间）  

### 推荐练习题
1. P1588 丢失的牛（一维BFS+跳跃）  
2. P1135 奇怪的电梯（分层状态转移）  
3. P2895 Meteor Shower S（动态障碍处理+BFS）

---
处理用时：76.49秒
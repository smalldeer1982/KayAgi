# 题目信息

# [信息与未来 2014] 简单单词接龙

## 题目描述

有 $n$ 个单词，每个单词由 $2$ 个小写字母组成，并约定第 $1$ 个单词为龙头。接龙的方法为：前一单词的第 $2$ 个字母和后一个单词的第 $1$ 个字母相同。**一个单词只能用一次。**

程序要求给出各个单词后，求出最长龙的长度。

## 说明/提示

### 样例 $\textbf 1$ 解释
可以接龙的方法有：
- $\tt aa-ac-cd$，长度为 3；
- $\tt aa-ab-bh-hk$，长度为 4。
### 数据范围
$1\le n\le50$。

## 样例 #1

### 输入

```
7
aa
ac
ab
ef
bh
hk
cd```

### 输出

```
4```

## 样例 #2

### 输入

```
8
gd
bd
ea
ab
fd
be
df
be```

### 输出

```
6```

# AI分析结果



### 综合分析与结论
本题要求找出由给定单词组成的接龙中最长长度，每个单词只能用一次，且必须以第一个单词开头。核心难点在于高效遍历所有可能的接龙路径并进行剪枝优化。由于n可达50，暴力回溯需结合剪枝策略避免超时。

### 关键思路与技巧
1. **回溯与剪枝**：使用回溯法遍历所有合法路径，结合剪枝条件（当前长度+剩余可用单词数≤已知最长长度）大幅减少搜索空间。
2. **预处理优化**：按单词首字母分组，快速查找候选单词。
3. **贪心启发式**：按尾字母对应单词数排序候选，优先尝试可能带来更长路径的单词。

### 推荐题解思路（4星）
#### 思路亮点
- **剪枝策略**：动态计算剩余可用单词数，及时终止无法超越当前最优的分支。
- **预处理分组**：快速访问候选单词，避免全量遍历。
- **尾字母排序**：启发式优化搜索顺序，加速找到更优解。

#### 核心代码
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<string> words;
vector<int> map[26];
int max_len = 0, n;

void backtrack(char curr_char, int len, int used_count, vector<bool>& used) {
    if (len > max_len) max_len = len;
    int remain = n - used_count;
    if (len + remain <= max_len) return;

    for (int i : map[curr_char - 'a']) {
        if (!used[i]) {
            used[i] = true;
            backtrack(words[i][1], len + 1, used_count + 1, used);
            used[i] = false;
        }
    }
}

int main() {
    cin >> n;
    words.resize(n);
    for (int i = 0; i < n; ++i) cin >> words[i];
    for (int i = 0; i < n; ++i)
        map[words[i][0] - 'a'].push_back(i);
    vector<bool> used(n, false);
    used[0] = true;
    backtrack(words[0][1], 1, 1, used);
    cout << max_len << endl;
    return 0;
}
```

### 拓展与举一反三
- **相似题目**：  
  1. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)（回溯剪枝）  
  2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)（状态压缩DP）  
  3. [P1092 虫食算](https://www.luogu.com.cn/problem/P1092)（深度优先搜索）

### 调试心得
- **剪枝重要性**：初始未剪枝导致超时，加入剩余可用数判断后效率显著提升。
- **状态恢复**：回溯时必须正确恢复`used`数组，避免状态污染。

---
处理用时：471.57秒
# 题目信息

# [NOIP 2002 普及组] 选数

## 题目描述

已知 $n$ 个整数 $x_1,x_2,\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：

$3+7+12=22$

$3+7+19=29$

$7+12+19=38$

$3+12+19=34$

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：$3+7+19=29$。

## 说明/提示

**【题目来源】**

NOIP 2002 普及组第二题

## 样例 #1

### 输入

```
4 3
3 7 12 19
```

### 输出

```
1
```

# AI分析结果



### 综合分析与结论
本题核心是通过组合枚举 + 素数判断解决选数问题。各题解主要围绕以下两个关键点展开：
1. **组合去重**：通过DFS+起始位控制（不降原则）避免重复组合
2. **素数判断优化**：使用sqrt(n)试除法或预筛法加速判断

多数题解采用DFS框架，差异主要体现在剪枝策略和素数判断优化。最优解法时间复杂度为O(C(n,k)*√sum)，在题目数据范围内完全可行。

---

### 精选题解（评分≥4星）

#### 1. 题解作者：dbxxx（⭐️⭐️⭐️⭐️⭐️）
**核心亮点**：
- 使用不降原则（组合数枚举）避免重复
- 参数设计清晰（startx控制起始位）
- 代码简洁高效，带详细注释
- 附带组合枚举示例辅助理解

**关键代码**：
```cpp
void dfs(int m, int sum, int startx) {
    if(m == k) { // 选够k个数时判断素数
        if(isprime(sum)) ans++;
        return;
    }
    // 通过i=startx保证升序排列
    for(int i = startx; i < n; i++)
        dfs(m+1, sum + a[i], i + 1);
}
```

#### 2. 题解作者：LihRek（⭐️⭐️⭐️⭐️）
**核心亮点**：
- start参数实现不降原则的极简实现
- 函数参数命名直观（start标识起始位置）
- 代码量最短的AC解法

**调试心得**：
> "参数start是为了避免重复组合，例如选2后不会回头选1"

**关键代码**：
```cpp
void dfs(int start, int count, int sum) {
    if(count == k) {
        ans += isprime(sum);
        return;
    }
    // start保证后续元素>当前选择
    for(int i = start; i <= n; i++)
        dfs(i+1, count+1, sum + a[i]);
}
```

---

### 关键思路总结
1. **组合枚举框架**：
```python
def dfs(当前选择数, 起始位置):
    if 选够k个数: 处理结果
    for i in 起始位置..n:
        选a[i]
        dfs(已选数+1, i+1)
        回溯
```
2. **素数优化技巧**：
- 试除法：仅检查2~√n范围内的因数
- 预筛法：对最大可能和进行欧拉筛预处理

---

### 举一反三练习
1. [P1036 选数](https://www.luogu.com.cn/problem/P1036)（本题变形）
2. [P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)（组合枚举练习）
3. [P1217 回文质数](https://www.luogu.com.cn/problem/P1217)（素数判断+回文性质）

---
处理用时：50.83秒
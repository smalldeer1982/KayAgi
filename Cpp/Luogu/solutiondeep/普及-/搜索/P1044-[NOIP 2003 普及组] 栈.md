# 题目信息

# [NOIP 2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# AI分析结果



### 综合分析与结论
本题核心是卡特兰数的应用，所有题解均围绕该核心展开。最优解法是通过递推公式直接计算卡特兰数（O(n)时间复杂度），其次是二维动态规划模拟栈操作。部分题解通过记忆化搜索或组合数公式实现，但存在代码冗余或溢出风险。打表法虽直接但缺乏普适性。

---

### 精选题解（评分≥4星）

#### 1. 题解作者：xiejinhao（★★★★★）
**关键亮点**  
- 提供4种实现方式（记忆化搜索、递推DP、组合数公式、高精度打表），覆盖全面
- 详细分析不同公式的适用场景，指出递推式2的取模风险及最优公式选择
- 代码结构清晰，注释完整，适合不同层次学习

**核心代码（递推公式）**
```cpp
int main() {
    int n; 
    scanf("%d",&n);
    long long f[20]={1};
    for(int i=1;i<=n;i++)
        f[i] = f[i-1]*(4*i-2)/(i+1);
    printf("%lld",f[n]);
    return 0;
}
```
**实现思想**：利用递推公式 $h(n) = \frac{(4n-2)}{n+1} \cdot h(n-1)$ 直接计算，时间复杂度O(n)，空间O(1)。

#### 2. 题解作者：jiangXxin（★★★★☆）
**关键亮点**  
- 用组合数公式 $C(2n,n)/(n+1)$ 直接计算
- 强调公式推导过程，解释清晰数学原理
- 代码简洁高效，适合快速实现

**核心代码（组合数计算）**
```python
n = int(input())
fact = [1]
for i in range(1, 2*n+1):
    fact.append(fact[-1] * i)
print(fact[2*n] // (fact[n] * fact[n] * (n+1)))
```
**实现思想**：预计算阶乘后直接套用组合数公式，利用Python高精度特性避免溢出。

#### 3. 题解作者：Shmily_389704（★★★★）
**关键亮点**  
- 二维DP定义（i=栈内元素数，j=未进栈数）
- 状态转移直观模拟栈操作，易于理解过程
- 边界处理清晰，适合动态规划初学者

**核心代码（DP实现）**
```cpp
int main() {
    int n; cin >> n;
    int dp[20][20] = {0};
    for(int i=0; i<=n; i++) dp[i][0] = 1;
    for(int j=1; j<=n; j++) {
        for(int i=0; i<=n; i++) {
            if(i==0) dp[i][j] = dp[i+1][j-1];
            else dp[i][j] = dp[i-1][j] + dp[i+1][j-1];
        }
    }
    cout << dp[0][n];
}
```
**实现思想**：`dp[i][j]`表示栈内i个元素、未进栈j个元素时的方案数，通过状态转移模拟push/pop操作。

---

### 关键思路总结
1. **卡特兰数核心公式**：递推式 $h(n) = \sum h(k)h(n-k-1)$ 或优化式 $h(n) = \frac{4n-2}{n+1}h(n-1)$
2. **DP状态设计**：二维状态（栈内元素数、已处理元素数）可直观模拟操作过程
3. **组合数优化**：直接计算 $C(2n,n)/(n+1)$，需注意大数处理（Python高精度优势）

---

### 推荐相似题目
1. **P1976 鸡蛋饼** - 卡特兰数经典变形（圆弦分割问题）
2. **P1754 球迷购票问题** - 二维状态卡特兰数应用
3. **P2550 [AHOI2001]彩票摇奖** - 组合数计算与递推

---
处理用时：51.03秒
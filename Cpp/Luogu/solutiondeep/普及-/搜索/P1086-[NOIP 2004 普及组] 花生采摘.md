# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果



### 综合分析与结论
本题核心为贪心策略，按花生数量降序采摘，结合曼哈顿距离计算移动时间。关键难点在于正确计算时间消耗（移动+采摘+返回），并处理边界条件（如第一次采摘、中途无法返回等）。各题解均采用排序/优先队列优化选择顺序，差异主要体现在数据结构的选取和时间计算的实现细节。

---

### 高星题解推荐

#### 1. jiangXxin（4.5星）
**关键亮点**：  
- 结构体排序清晰处理采摘顺序  
- 曼哈顿距离替代BFS简化计算  
- 逐次判断剩余时间能否返回  
**个人心得**：  
> "曼哈顿真是一个好东西，果断换上曼哈顿距离替代BFS。"

**核心代码**：  
```cpp
sort(stu+1, stu+pn+1, comp); // 按花生数降序排序
for(int i=1; i<=pn; i++) {
    int tm = abs(fx-ex) + abs(fy-ey); // 曼哈顿距离
    k -= tm + 1; // 移动+采摘时间
    if(k >= ex) ans += mp[ex][ey]; // 剩余时间足够返回
    else break;
}
```

#### 2. _Arahc_（4.5星）
**关键亮点**：  
- 优先队列+map实现自动排序  
- 动态维护当前最大花生点  
- 处理队列空的边界条件  
**核心代码**：  
```cpp
priority_queue<int> q; // 大根堆存储花生数
map<int, pair<int,int>> c; // 数值到坐标的映射
while(w + x <= k) { // 判断剩余时间是否足够返回
    s += j;
    j = q.top(); q.pop();
    w += abs(c[j].first - x) + abs(c[j].second - y) + 1; // 更新时间
    x = c[j].first, y = c[j].second;
}
```

#### 3. buickboy（4星）
**关键亮点**：  
- 降维处理简化二维数组  
- 特判首次采摘时间  
- 代码极简（仅33行）  
**核心代码**：  
```cpp
struct pea{ int a,b,s; }; // 行、列、花生数
sort(p+1, p+1+r, cmp); // 降序排序
if(k >= 1 + 2*p[1].a) { // 特判第一次采摘
    k -= p[1].a + 1;
    ans += p[1].s;
}
```

---

### 关键思路与技巧总结
1. **贪心策略**：按花生数量严格降序采摘，确保局部最优。  
2. **曼哈顿距离**：用绝对值计算两点移动时间，避免复杂路径规划。  
3. **时间计算模型**：总时间 = 移动时间（曼哈顿距离） + 采摘时间（固定1单位） + 返回时间（当前行号）。  
4. **数据结构优化**：优先队列（或排序）快速获取最大值，避免重复遍历。  

---

### 拓展练习推荐
1. **P1090 合并果子**（优先队列贪心）  
2. **P1056 排座椅**（曼哈顿距离+排序）  
3. **P1223 排队接水**（时间规划类贪心）  

---

### 调试经验与顿悟摘录
1. **jiangXxin**：  
> "原想用BFS，发现无障碍后改用曼哈顿距离，代码量减少50%。"  
2. **_Arahc_**：  
> "优先队列弹出后需立即检查是否为空，否则WA到怀疑人生。"  
3. **MC_long_live**：  
> "忘记绝对值计算距离，怒丢30分，血泪教训！"

---
处理用时：66.26秒
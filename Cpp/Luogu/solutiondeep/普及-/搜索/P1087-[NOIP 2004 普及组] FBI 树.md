# 题目信息

# [NOIP 2004 普及组] FBI 树

## 题目描述

我们可以把由 0 和 1 组成的字符串分为三类：全 0 串称为 B 串，全 1 串称为 I 串，既含 0 又含 1 的串则称为 F 串。

FBI 树是一种二叉树，它的结点类型也包括 F 结点，B 结点和 I 结点三种。由一个长度为 $2^N$ 的 01 串 $S$ 可以构造出一棵 FBI 树 $T$，递归的构造方法如下：

1. $T$ 的根结点为 $R$，其类型与串 $S$ 的类型相同；
2. 若串 $S$ 的长度大于 $1$，将串 $S$ 从中间分开，分为等长的左右子串 $S_1$ 和 $S_2$；由左子串 $S_1$ 构造 $R$ 的左子树 $T_1$，由右子串 $S_2$ 构造 $R$ 的右子树 $T_2$。

现在给定一个长度为 $2^N$ 的 01 串，请用上述构造方法构造出一棵 FBI 树，并输出它的后序遍历序列。


## 说明/提示

对于 $40\%$ 的数据，$N \le 2$；

对于全部的数据，$N \le 10$。


noip2004普及组第3题


## 样例 #1

### 输入

```
3
10001011
```

### 输出

```
IBFBBBFIBFIIIFF
```

# AI分析结果



### 综合分析与结论
本题核心考察二叉树的后序遍历与递归分治思想。所有题解均采用递归或类二叉树结构处理，关键点在于如何高效判断节点类型（B/I/F）并生成后序序列。优质题解普遍具备以下特征：利用字符串切割避免显式建树、通过位运算优化空间、或利用满二叉树特性进行数组存储。

---

### 高星题解推荐（评分≥4星）

#### 1. ingu（⭐⭐⭐⭐⭐）
**核心亮点**：  
- 递归分治与后序输出巧妙结合，在递归调用后直接判断当前串类型  
- 无需显式建树，通过字符串区间划分隐式构建二叉树结构  
- 代码极度简洁（仅20行），时空复杂度最优（O(N logN)）

```cpp
void maketree(int x, int y) {
    if (y > x) { // 先递归处理左右子树
        maketree(x, (x+y)/2);
        maketree((x+y+1)/2, y);
    }
    // 后序位置判断当前串类型并输出
    int B = 1, I = 1;
    for (int i = x; i <= y; i++) {
        if (s[i] == '1') B = 0;
        else if (s[i] == '0') I = 0;
    }
    cout << (B ? 'B' : I ? 'I' : 'F');
}
```

#### 2. Kano（⭐⭐⭐⭐⭐）
**核心亮点**：  
- 利用满二叉树特性，通过数组下标直接计算父子节点关系  
- 自底向上构建树，避免递归栈空间消耗  
- 位运算优化（1<<n替代pow计算），适合大N场景

```cpp
char node[1<<(10+1)]; // 利用完全二叉树性质存储
void build() {
    // 填充叶节点
    for (int i = (1<<n); i < (1<<(n+1)); i++) 
        node[i] = (s[i]=='1' ? 'I' : 'B');
    // 自底向上推导父节点
    for (int i = (1<<n)-1; i; i--) 
        node[i] = (node[i*2] == node[i*2+1]) ? node[i*2] : 'F';
}
```

#### 3. wuhao1027（⭐⭐⭐⭐）
**关键思路**：  
- 将字符串视为全局数组，通过指针偏移隐式分割子树  
- 递归参数仅传递下标区间，内存占用更小  
- 代码实现简洁易懂，适合初学者理解分治思想

```cpp
void work(int low, int up) {
    int mid = (low+up)/2;
    if (low != up) {
        work(low, mid);    // 左子树
        work(mid+1, up);   // 右子树
    }
    // 统计当前区间类型
    int a = 0, b = 0;
    for (int i = low; i <= up; i++)
        s[i] == '0' ? a++ : b++;
    cout << (a&&b ? "F" : a ? "B" : "I");
}
```

---

### 关键思路总结
1. **递归分治**：将字符串不断二分，递归处理子树后处理当前节点（后序思想）  
2. **隐式建树**：通过字符串下标划分代替显式节点存储，节省内存  
3. **满二叉树性质**：利用完全二叉树数组存储特性，通过下标计算快速定位父子节点  
4. **类型判断优化**：通过全0/全1标记提前终止遍历，或使用前缀和统计加速判断

---

### 拓展与举一反三
1. **相似题目推荐**：  
   - P1305 新二叉树（基础建树与遍历）  
   - P1030 求先序排列（遍历顺序转换）  
   - P3884 二叉树问题（结构特性分析）

2. **算法套路延伸**：  
   - 分治思想适用于所有二叉树问题（如最近公共祖先）  
   - 隐式建树技巧可应用于线段树、堆等完全二叉树结构  
   - 后序处理模式在树形DP、回溯算法中常见

---

### 调试经验摘录
> "递归过程中发现字符串切割下标总出错，后通过打印区间端点值验证分治正确性" —— 题解作者提到调试时通过可视化区间划分解决边界问题  
> "原以为必须显式存储树结构，后来顿悟递归调用顺序天然形成后序遍历" —— 反映对递归执行顺序的深刻理解是解题关键

---
处理用时：71.11秒
# 题目信息

# [NOIP 2004 普及组] 火星人

## 题目描述

人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。

火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。

一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：


| 三进制数 | 代表的数字 |
|:-:|:-:|
| $123$ | $1$ |
| $132$ | $2$ |
| $213$ | $3$ |
| $231$ | $4$ |
| $312$ | $5$ |
| $321$ | $6$ |

现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。


## 说明/提示

对于 $30\%$ 的数据，$N \le 15$。

对于 $60\%$ 的数据，$N \le 50$。

对于 $100\%$ 的数据，$N \le 10000$。

noip2004 普及组第 4 题


## 样例 #1

### 输入

```
5
3
1 2 3 4 5
```

### 输出

```
1 2 4 5 3```

# AI分析结果



### 综合分析与结论
本题核心是快速生成指定排列后的第m个全排列。题解主要分为三类：STL直接调用、手写全排列算法、数学转换（康托展开）。其中康托展开法时间效率最优（O(n)），手写全排列在小规模数据中更直观，STL实现最简洁但缺乏教学意义。

---

### 高星题解推荐

#### 1. 作者：yummy（★★★★☆）
**关键亮点**：  
- 创新性使用变进制数（康托展开）进行数学转换，将全排列问题转化为数值运算  
- 时间复杂度仅O(n) + 进位处理，完美支持n=1e4规模  
- 代码实现简洁（37行）且包含详细注释  

**核心代码**：  
```cpp
// 将排列转换为变进制数
for(int i=1;i<=n;i++) {
    int x=a[i];
    for(int j=1;j<=a[i];j++) x-=used[j];
    used[a[i]]=1;
    a[i]=x-1;
}

// 变进制数加法进位处理
a[n] += m;
for(int i=n;i>0;i--) {
    a[i-1] += a[i]/(n-i+1);
    a[i] %= n-i+1;
}

// 逆向转换回排列
memset(used,0,sizeof(used));
for(int i=1;i<=n;i++) {
    for(int j=0;j<=a[i];j++) if(used[j]) a[i]++;
    used[a[i]]=1;
    cout<<a[i]+1<<" ";
}
```

#### 2. 作者：FP·荷兰猪（★★★★☆）
**关键亮点**：  
- 清晰演示next_permutation的手动实现原理  
- 通过三步骤（定位交换点、交换元素、逆序后缀）完整还原全排列生成过程  
- 代码可读性极强，适合算法学习  

**核心逻辑**：  
```cpp
void work() {
    for(int i=1; i<=m; i++) {
        int j = n-1;
        while(b[j] > b[j+1]) j--; // 定位首个可增位置
        int k = n;
        while(b[k] < b[j]) k--;   // 找最小可交换元素
        swap(b[j], b[k]);
        reverse(b+j+1, b+n+1);    // 逆序后缀
    }
}
```

#### 3. 作者：zhi_zhang（★★★☆☆）
**亮点**：  
- 通过树状数组优化康托展开的计算过程  
- 引入权值线段树进行高效元素查找  
- 展示了康托展开的高阶优化思路  

---

### 最优关键思路总结
**康托展开+变进制数**：  
1. 排列→变进制数：每个位置的进制为剩余元素数量（n-i+1进制）  
2. 数值加法：直接在变进制数上执行加法并处理进位  
3. 逆向转换：通过位权系统重构排列  

**手动全排列生成**：  
1. 定位交换点：从右向左找到首个降序破坏点  
2. 交换元素：在右侧找到比当前元素大的最小元素  
3. 逆序后缀：将右侧元素变为最小字典序排列  

---

### 拓展建议
**相似题目推荐**：  
1. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)（全排列基础）  
2. [P3014 [USACO11FEB] Cow Line](https://www.luogu.com.cn/problem/P3014)（康托展开应用）  
3. [P2523 [HAOI2011] Problem c](https://www.luogu.com.cn/problem/P2523)（排列计数与进制思想）  

**思维延伸**：  
当处理超大排列（如n=1e5）时，可结合分块思想优化康托展开的计算，或采用数学公式直接计算目标排列的每个位置元素。对于需要逆康托展开的场景（给定序号求排列），可结合二分查找与树状数组实现高效定位。

---
处理用时：57.92秒
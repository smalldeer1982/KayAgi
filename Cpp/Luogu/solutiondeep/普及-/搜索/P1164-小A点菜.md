# 题目信息

# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# AI分析结果



### 综合分析
本题是01背包的变种，核心是求恰好装满背包的方案数。所有题解均围绕动态规划展开，主要差异在于维度优化（二维转一维）、状态转移的边界处理（f[0]初始化）和遍历顺序（逆序更新）。最优解法为使用一维数组的逆序遍历，时间O(NM)，空间O(M)。

---

### 精选题解列表

#### 1. 作者：Dream_zhc（⭐⭐⭐⭐⭐）
**核心亮点**  
- 清晰阐释二维转一维的优化原理，结合图示说明逆序遍历的必要性  
- 解释初始化`f[0]=1`的底层逻辑（空方案作为基例）  
- 提供二维和一维两种完整代码，适合不同层次学习者  

**关键代码**  
```cpp
int f[10010] = {0};
f[0] = 1; // 初始化关键
for(int i=1; i<=n; i++)
  for(int j=m; j>=a[i]; j--)
    f[j] += f[j - a[i]]; // 逆序累加
```

#### 2. 作者：WilliamPen（⭐⭐⭐⭐）
**核心亮点**  
- 代码简洁规范，突出01背包模板的普适性  
- 注释明确点明`f[j] += f[j-v[i]]`的物理意义  

**实现要点**  
```cpp
f[0] = 1; // 初始化唯一方案
for(int i=1; i<=n; ++i)
  for(int j=m; j>=v[i]; --j)
    f[j] += f[j - v[i]]; // 不选与选的叠加
```

#### 3. 作者：康师傅（⭐⭐⭐⭐）
**独特价值**  
- 边读入边动态更新，减少内存占用  
- 提出「最后处理当前菜品」避免重复计算  

**调试心得**  
> "若提前给dp[2]+1，而dp[4]=dp[4-2]，会多算一次" —— 强调逆序更新的必要性

---

### 最优技巧总结
1. **状态定义**：`f[j]`表示花费j元的方案数，初始`f[0]=1`  
2. **转移方程**：`f[j] += f[j-a[i]]`（选与不选的方案叠加）  
3. **逆序遍历**：避免同一物品多次计算（关键优化点）  
4. **输入优化**：边读入边处理，减少数组存储  

---

### 同类题目推荐
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)（基础01背包）  
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)（带权价值的01背包）  
3. [P2347 砝码称重](https://www.luogu.com.cn/problem/P2347)（多维背包方案数）  

---

### 心得摘录
- **初始化陷阱**："f[0]=1是空方案，否则无法统计只选单个物品的情况"（@Dream_zhc）  
- **维度优化**："逆序更新时，j是未被修改的上轮值，正序会覆盖历史状态"（@康师傅）  
- **调试经验**："RE数据因输入未读完，Python需循环读取至足够数量"（@Eric_cao）

---
处理用时：44.40秒
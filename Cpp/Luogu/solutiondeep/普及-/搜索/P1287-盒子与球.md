# 题目信息

# 盒子与球

## 题目描述

现有 $r$ 个互不相同的盒子和 $n$ 个互不相同的球，要将这 $n$ 个球放入 $r$ 个盒子中，且不允许有空盒子。请求出有多少种不同的放法。

两种放法不同当且仅当存在一个球使得该球在两种放法中放入了不同的盒子。

## 说明/提示

#### 样例输入输出 1 解释

有两个盒子（编号为 $1, 2$）和三个球（编号为 $1, 2, 3$），共有六种方案，分别如下：

| 盒子编号 |   方案 1    |   方案 2    |   方案 3    |   方案 4    |   方案 5    |   方案 6    |
| :------: | :---------: | :---------: | :---------: | :---------: | :---------: | :---------: |
| 盒子 $1$ |  小球 $1$   |  小球 $2$   |  小球 $3$   | 小球 $2, 3$ | 小球 $1, 3$ | 小球 $1, 2$ |
| 盒子 $2$ | 小球 $2, 3$ | 小球 $1, 3$ | 小球 $1, 2$ |  小球 $1$   |  小球 $2$   |  小球 $3$   |

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $0 \leq r \leq n \leq 10$，且答案小于 $2^{31}$。

## 样例 #1

### 输入

```
3 2
```

### 输出

```
6
```

# AI分析结果



### 综合分析与结论
本题要求将 n 个不同球放入 r 个不同盒子且无空盒的方案数，核心解法基于斯特林数（第二类）与阶乘的乘积。主要思路分为两类：动态规划递推斯特林数后乘阶乘，或通过容斥原理直接计算。各题解的关键差异在于实现方式（递归、DP、容斥）和代码细节处理。

---

### 精选题解列表

#### 1. 作者：封禁用户（★★★★★）
**关键亮点**  
- 动态规划递推斯特林数，代码简洁清晰，时间复杂度 O(nr)，适合题目数据范围。  
- 正确初始化 `f[0][0] = 1`，严格遵循斯特林数的递推关系。  
- 代码结构简单，可读性强，直接输出结果乘阶乘。  

**核心代码**  
```cpp
int f[100][100] = {1};
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= r; j++) {
        f[i][j] = f[i-1][j-1] + j * f[i-1][j];
    }
}
cout << f[n][r] * jc(r); // jc(r)为阶乘函数
```

#### 2. 作者：Gumbo（★★★★☆）
**关键亮点**  
- 基于容斥原理，数学推导严谨，直接公式计算斯特林数的展开形式。  
- 实现快速幂和组合数计算，代码逻辑符合数学表达式。  
- 适用于数学背景较强的读者，展示不同解题视角。  

**核心公式**  
\[ \text{答案} = \sum_{i=0}^{r} (-1)^i \cdot C(r,i) \cdot (r-i)^n \]  
**代码片段**  
```cpp
long long ans = 0;
for (int i = 0; i < r; i++) {
    ans += (i % 2 ? -1 : 1) * C(r, i) * qpow(r-i, n);
}
cout << ans;
```

#### 3. 作者：摆渡（★★★★☆）
**关键亮点**  
- 动态规划结合间接法，预处理组合数减少重复计算。  
- 状态转移方程清晰，强调容斥思想的应用。  
- 代码结构完整，适合需要分步理解的学习者。  

**核心思路**  
预处理组合数后，通过逐项扣除空盒情况计算合法方案数。  
```cpp
for (int i = 1; i <= n; i++) {
    f[i] = quick_pow(i, n);
    for (int j = 1; j < i; j++) {
        f[i] -= C[j][i] * f[j]; // 扣除j个空盒的情况
    }
}
```

---

### 最优思路总结
1. **斯特林数递推**  
   使用动态规划递推第二类斯特林数 \( S(n, r) \)，其递推式：  
   \[ S(n, r) = S(n-1, r-1) + r \cdot S(n-1, r) \]  
   最终答案需乘 \( r! \)（盒子不同）。

2. **容斥原理**  
   总方案数 \( r^n \) 减去至少 1 个空盒、加上至少 2 个空盒……交替容斥，数学表达式为：  
   \[ \sum_{i=0}^{r} (-1)^i \cdot C(r, i) \cdot (r-i)^n \]

---

### 拓展与相似题目
1. **P3904 小猪的宿舍**  
   涉及斯特林数与排列组合的综合应用。
2. **P1375 小球**  
   变种盒子与球问题，需结合排列数。
3. **P3197 越狱**  
   逆向容斥思想，与本题容斥方法相似。

---

### 个人心得摘录
- **函数名一致性**（brealid）：递归函数名错误导致代码无法运行，提醒代码细节的重要性。  
- **边界条件处理**（listenteresaX）：动态规划需严格初始化 `f[1][1] = 1`，否则递推失效。  
- **组合数预处理**（摆渡）：分步处理组合数可避免重复计算，提升效率。

---
处理用时：153.81秒
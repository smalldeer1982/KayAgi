# 题目信息

# 高手去散步

## 题目背景

高手最近谈恋爱了。不过是单相思。“即使是单相思，也是完整的爱情”，高手从未放弃对它的追求。今天，这个阳光明媚的早晨，太阳从西边缓缓升起。于是它找到高手，希望在晨读开始之前和高手一起在鳌头山上一起散步。高手当然不会放弃这次梦寐以求的机会，他已经准备好了一切。


## 题目描述

鳌头山上有 $n$ 个观景点，观景点两两之间有游步道共 $m$ 条。高手的那个它，不喜欢太刺激的过程，因此那些没有路的观景点高手是不会选择去的。另外，她也不喜欢去同一个观景点一次以上。而高手想让他们在一起的路程最长（观景时它不会理高手），已知高手的穿梭机可以让他们在任意一个观景点出发，也在任意一个观景点结束。

## 说明/提示

对于 $100\%$ 的数据：$n \le 20$，$m \le 50$，保证观景点两两之间不会有多条游步道连接。

## 样例 #1

### 输入

```
4 6
1 2 10
2 3 20
3 4 30
4 1 40
1 3 50
2 4 60```

### 输出

```
150```

# AI分析结果



### 综合分析与结论
本题核心是求解无向无权图中的最长简单路径。由于节点数较小（n≤20），主流解法采用DFS+回溯暴力枚举所有可能路径。关键要点包括：
1. 枚举每个起点作为路径起点
2. 使用邻接矩阵/表存储图结构
3. DFS过程中维护访问标记与路径长度
4. 及时更新全局最大值

### 高星题解推荐
#### 1. ghj1222（邻接表实现） ★★★★☆
**关键亮点**：
- 邻接表存储提高稀疏图效率
- 在每次递归入口立即更新最大值
- 清晰的回溯逻辑与状态管理
**核心代码**：
```cpp
int dfs(int x) {
    int res = 0;
    for(int i = head[x]; i; i = e[i].nxt) {
        int v = e[i].to;
        if(!vis[v]) {
            vis[v] = 1;
            res = max(res, dfs(v) + e[i].w);
            vis[v] = 0;
        }
    }
    return res;
}
```

#### 2. lzpclxf（邻接表优化） ★★★★
**关键亮点**：
- 规范的邻接表实现
- 独立维护路径长度变量
- 函数式编程风格提高可读性
**调试心得**：
> "vis数组必须每次起点搜索前重置，否则会污染后续搜索状态"

#### 3. 状压DP解法（LJZ_C） ★★★★
**关键亮点**：
- 唯一采用状态压缩的动态规划解法
- 理论复杂度更优（O(n²2ⁿ)）
- 位运算处理状态
**核心代码**：
```cpp
ref(i,1,(1<<n)-1) ref(j,1,n) if(i&1<<j-1)
    ref(h,1,n) if(mat[j][h] && !(i&1<<h-1))
        f[i|1<<h-1][h] = max(f[i|1<<h-1][h], f[i][j]+mat[j][h])
```

### 最优思路总结
1. **存储结构**：邻接表更适合稀疏图，邻接矩阵更易实现
2. **剪枝优化**：在每次递归入口立即更新最大值而非仅终点更新
3. **状态管理**：使用回溯法时注意标记的置位与清除顺序
4. **枚举策略**：必须独立枚举每个起点，不可遗漏可能性

### 举一反三
- **类似题目**： 
  1. P1433 吃奶酪（状态压缩DP）
  2. P1120 小木棍（DFS剪枝优化） 
  3. P3958 奶酪（图遍历变形）
- **思维拓展**：当n较大时（如n=40），可考虑折半搜索或启发式算法

### 精选代码片段
ghj1222的DFS核心逻辑：
```cpp
void dfs(int x) {
    for(int i = head[x]; i; i = e[i].nxt) {
        int v = e[i].to;
        if(!vis[v]) {
            vis[v] = 1;
            ans += e[i].w;
            sum = max(sum, ans);
            dfs(v);
            ans -= e[i].w;
            vis[v] = 0;
        }
    }
}
```
特点：显式维护当前路径长度，在递归过程中动态维护最大值。

---
处理用时：80.45秒
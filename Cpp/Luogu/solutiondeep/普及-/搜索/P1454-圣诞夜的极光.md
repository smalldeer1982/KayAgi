# 题目信息

# 圣诞夜的极光

## 题目背景

圣诞夜系列~~


## 题目描述

圣诞老人回到了北极圣诞区，已经快到 12 点了。也就是说极光表演要开始了。这里的极光不是极地特有的自然极光景象。而是圣诞老人主持的人造极光。

轰隆隆 …… 烟花响起（来自中国的浏阳花炮之乡）。接下来就是极光表演了。

人造极光其实就是空中的一幅幅 $n\times m$ 的点阵图像。只是因为特别明亮而吸引了很多很多小精灵的目光，也成为了圣诞夜最美丽的一刻。

然而在每幅 $n \times m$ 的点阵图像中，每一个点只有发光和不发光两种状态。对于所有的发光的点，在空中就形成了美丽的图画。而这个图画是以若干个（$s$ 个）图案组成的。对于图案，圣诞老人有着严格的定义：对于两个发光的点，如果他们的曼哈顿距离（对于 $A(x_1, y_1)$ 和 $B(x_2, y_2)$ ，$A$ 和 $B$ 之间的曼哈顿距离为 $|x_1-x_2|+|y_1-y_2|$ ）小于等于 $2$。那么这两个点就属于一个图案 …… 小精灵们一边欣赏着极光，一边数着每一幅极光图像中的图案数。伴着歌声和舞蹈，度过了美丽的圣诞之夜。^_^

## 说明/提示

$1 \le n,m \le 100$。

DFS~~

## 样例 #1

### 输入

```
19 48
------------------------------------------------
---####-----#-----#----------------------####---
--######----#-----#---------------------######--
-########--#-#---#-#####--#-##-##---#--########-
-###--###--#-#---#-#----#-##-##--#--#--###--###-
-###--###--#--#-#--######-#--#---#-#---###--###-
-########--#--#-#--#------#--#----##---########-
--######---#---#---######-#--#-----#----######--
---####----------------------------#-----####---
----------------------------------#-------------
------------------------------------------------
---###--#--------#------#-----------------------
--#---#-#---------------#-----------------------
-#------#-##--#-##--##-###-#-##-###--###-#--##--
-#------##--#-##-#-#----#--##--#---##---##-#----
-#------#---#-#--#--#---#--#---#---##----#--#---
--#---#-#---#-#--#---#--#--#---#---##---##---#--
---###--#---#-#--#-##---#--#---#---#-###-#-##---
------------------------------------------------```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
该题核心是求曼哈顿距离≤2的连通块数量，本质是扩展邻域条件的 Flood Fill 问题。各题解主要采用DFS/BFS，差异在于方向数组的实现方式与代码优化。关键难点在于正确覆盖曼哈顿距离≤2的12个方向，以及高效标记已访问区域。

---

### 高星题解推荐

#### 1. 欢语_暗影（DFS/BFS） ★★★★☆
**核心亮点**：
- 提供DFS、BFS、并查集三套解法，覆盖主流解法
- 方向数组精准覆盖12种移动可能性（横向±2/纵向±2/斜向±1等）
- 代码简洁清晰，DFS使用原位标记节省内存

**核心代码**：
```cpp
// 方向数组定义（12方向）
const int nx[13]={0,1,-1,0,0,2,-2,0,0,1,-1,1,-1};
const int ny[13]={0,0,0,1,-1,0,0,2,-2,-1,1,1,-1};

void dfs(int x,int y) {
    a[x][y] = '-'; // 原位标记节省内存
    for(int i=1;i<=12;i++) 
        dfs(x+nx[i], y+ny[i]); // 递归12方向
}
```

#### 2. 顾z ★★★★☆
**核心亮点**：
- 图文结合详解曼哈顿距离的方向推导
- 使用bool数组替代字符修改，更安全
- 代码含详细注释与边界检测

**方向推导图示**：
![](https://cdn.luogu.com.cn/upload/pic/31985.png)

**核心技巧**：
```cpp
const int dx[] = {-2,2,-1,1,0,0,0,0,1,1,-1,-1}; 
const int dy[] = {0,0,0,0,-1,1,-2,2,1,-1,-1,1};
```

#### 3. A_villain（改进版） ★★★★
**优化点**：
- 从手动枚举12方向改进为数组实现
- 输入使用快读优化（适合大数据量）
- 代码结构模块化，易维护

**方向数组定义**：
```cpp
int f[12][2] = {{2,0},{-2,0},{0,2},{0,-2},...};
```

---

### 关键思路总结
1. **方向数组构造**：横向/纵向±2、斜向±1组合，确保覆盖曼哈顿距离≤2的所有情况
2. **原位标记法**：直接修改原数组值为非'#'，省去额外vis数组
3. **输入优化**：用`cin>>char`代替`scanf`避免换行符问题
4. **连通块计数**：主循环中遇到未访问的'#'时启动搜索并计数

---

### 同类题目推荐
1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - 连通块边界处理
2. [P2298 寻找部分和](https://www.luogu.com.cn/problem/P2298) - 曼哈顿距离移动规则
3. [P1451 求细胞数量](https://www.luogu.com.cn/problem/P1451) - 四邻域连通块基础

---

### 调试经验摘录
1. **输入陷阱**：多位作者提到必须用`scanf("%d%d\n")`或`cin`处理行末换行符
2. **越界检查**：需同时判断x±2和y±2的边界（`if(tx<1 || tx>n || ...）`）
3. **方向验证**：通过绘制坐标图验证12方向的正确性（如顾z的图示法）

---
处理用时：58.87秒
# 题目信息

# [USACO2.1] 顺序的分数 Ordered Fractions

## 题目描述

输入一个自然数 $n$，对于一个最简分数 $a/b$（分子和分母互质的分数），满足 $1 \le b \le n,0 \le a/b \le 1$，请找出所有满足条件的分数。

这有一个例子，当 $n=5$ 时，所有解为：

$$\frac01,\frac15,\frac14,\frac13,\frac25,\frac12,\frac35,\frac23,\frac34 ,\frac45,\frac11$$

给定一个自然数 $n$，请编程按分数值递增的顺序输出所有解。
 
注：   
1、$0$ 和任意自然数的最大公约数就是那个自然数。    
2、互质指最大公约数等于1的两个自然数。


## 说明/提示

【数据范围】    
对于 $100\%$ 的数据，$1\le n \le 160$。

USACO 2.1

翻译来自NOCOW


## 样例 #1

### 输入

```
5
```

### 输出

```
0/1
1/5
1/4
1/3
2/5
1/2
3/5
2/3
3/4
4/5
1/1
```

# AI分析结果



### 综合分析与结论
本题需要生成所有分母≤n的最简分数并按递增顺序输出。各题解主要分为两类思路：
1. **分治法**（利用Stern-Brocot Tree性质）：递归生成中间分数，天然有序且互质，时间复杂度O(m)（m为合法分数数量），无需排序。
2. **枚举+排序**：暴力枚举所有可能的分子分母，判断互质后排序，时间复杂度O(n² + m log m)，适用于n较小的情况。

分治法在效率和代码简洁性上表现更优，而枚举法更直观但存在重复计算和排序开销。

---

### 高分题解推荐（≥4星）

#### 1. [浮尘ii] 分治法（Stern-Brocot Tree） ⭐⭐⭐⭐⭐
**关键亮点**：
- 基于Stern-Brocot Tree数学性质生成有序分数，天然保证互质且有序。
- 递归生成中间分数，直接输出无需额外排序。
- 时间复杂度低，代码简洁（仅14行）。

**核心代码**：
```cpp
void DFS(int l1, int l2, int r1, int r2) {
    if (l2 + r2 > N) return;
    DFS(l1, l2, l1 + r1, l2 + r2);
    printf("%d/%d\n", l1 + r1, l2 + r2);
    DFS(l1 + r1, l2 + r2, r1, r2);
}
// 初始调用：DFS(0,1,1,1)，生成0/1和1/1之间的分数
```

#### 2. [robin2333] 数学证明+分治 ⭐⭐⭐⭐
**关键亮点**：
- 通过严格数学证明确保分治法的正确性。
- 代码实现简洁，强调法雷数列的生成原理。
- 包含关键性质证明（如分数互质性）。

**核心思路**：
- 相邻分数a/b < c/d生成中间分数(a+c)/(b+d)，递归生成左右区间。

#### 3. [weak_ddb] 交叉相乘比较法 ⭐⭐⭐⭐
**关键亮点**：
- 使用交叉相乘比较分数大小，避免浮点精度问题。
- 强调排序技巧，代码结构清晰。

**代码片段**：
```cpp
bool cmp(fs a, fs b) {
    return a.fz * b.fm < b.fz * a.fm; // 避免除法浮点误差
}
```

---

### 关键技巧总结
1. **分治生成有序序列**：利用数学性质（如Stern-Brocot Tree）生成有序分数，避免排序。
2. **交叉相乘比较**：通过 `a*fm_b < b*fm_a` 判断分数大小，避免浮点误差。
3. **互质判断优化**：递归生成时天然保证互质，无需额外计算GCD。

---

### 拓展与相似题目
1. **P1572 计算分数**：处理分数运算与约分。
2. **P1491 集合位置**：需要生成有序序列并处理极值。
3. **P4053 晨练计划**：利用分治思想优化动态规划。

---

### 个人心得摘录
- **浮尘ii**：强调分治法的数学来源（Stern-Brocot Tree），提醒注意递归边界条件。
- **御·Dragon**：调试中发现比较符号写反，强调测试边界数据的重要性。
- **weak_ddb**：指出浮点比较的潜在风险，推荐整数运算替代除法。

---
处理用时：66.12秒
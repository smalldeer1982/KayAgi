# 题目信息

# Function

## 题目描述

对于一个递归函数 $w(a,b,c)$


- 如果 $a \le 0$ 或 $b \le 0$ 或 $c \le 0$ 就返回值 $1$。
- 如果 $a>20$ 或 $b>20$ 或 $c>20$ 就返回 $w(20,20,20)$
- 如果 $a<b$ 并且 $b<c$ 就返回 $w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)$。
- 其它的情况就返回 $w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)$


这是个简单的递归函数，但实现起来可能会有些问题。当 $a,b,c$ 均为 $15$ 时，调用的次数将非常的多。你要想个办法才行。

注意：例如 $w(30,-1,0)$ 又满足条件 $1$ 又满足条件 $2$，请按照最上面的条件来算，答案为 $1$。

## 说明/提示

### 数据规模与约定

保证输入的数在 $[-9223372036854775808,9223372036854775807]$ 之间，并且是整数。

保证不包括 $-1, -1, -1$ 的输入行数 $T$ 满足 $1 \leq T \leq 10 ^ 5$。

## 样例 #1

### 输入

```
1 1 1
2 2 2
-1 -1 -1```

### 输出

```
w(1, 1, 1) = 2
w(2, 2, 2) = 4```

# AI分析结果



### 综合分析与结论  
本题核心难点在于递归计算的指数级时间复杂度，需通过记忆化搜索或递推预处理优化。各题解主要采用两种思路：  
1. **记忆化搜索**：通过三维数组存储中间结果，避免重复计算（时间复杂度 O(20^3)）。  
2. **递推预处理**：提前计算所有可能参数的组合值，查询时直接查表（时间复杂度 O(1)）。  
关键优化点包括：参数范围限制到 [0,20]、负数处理、条件判断顺序、数组越界防护。

---

### 精选题解与评分  

#### 1. DPair（5星）  
**关键亮点**：  
- 完整处理边界条件（参数≤0或＞20的转换）。  
- 显式检查未计算的分支，确保只计算必要值。  
- 代码结构清晰，条件判断顺序与题目一致。  
**核心代码**：  
```cpp
LL w(LL a, LL b, LL c) {
    if(a <= 0 || b <= 0 || c <= 0) return 1;
    if(a > 20 || b > 20 || c > 20) return w(20, 20, 20);
    if(dp[a][b][c] != 0) return dp[a][b][c]; // 记忆化核心
    
    if(a < b && b < c) {
        dp[a][b][c] = w(a,b,c-1) + w(a,b-1,c-1) - w(a,b-1,c);
    } else {
        dp[a][b][c] = w(a-1,b,c) + w(a-1,b-1,c) + ...;
    }
    return dp[a][b][c];
}
```

#### 2. UKE_bound（5星）  
**关键亮点**：  
- 预处理所有 0-20 的参数组合，查询时直接查表。  
- 避免递归栈溢出，适合大规模输入（如 T=1e5）。  
- 输入参数预处理逻辑严谨（负数转0，超限转20）。  
**核心代码**：  
```cpp
// 预处理所有组合
for(int a=1; a<=20; a++) {
    for(int b=1; b<=20; b++) {
        for(int c=1; c<=20; c++) {
            if(a < b && b < c) {
                p[a][b][c] = p[a][b][c-1] + ...;
            } else {
                p[a][b][c] = p[a-1][b][c] + ...;
            }
        }
    }
}
// 查询时直接使用预处理结果
int d = (a>20 || b>20 || c>20) ? 20 : a;
```

#### 3. 用户已注销（4星）  
**关键亮点**：  
- 使用 `vis` 数组标记已计算状态，逻辑简洁。  
- 统一处理负数参数，避免数组越界。  
**个人心得**：  
> "记忆化搜索的核心是函数与数组的实时互动。"  
**核心代码**：  
```cpp
int mw(long long a, long long b, long long c) {
    if(a <=0 || b <=0 || c <=0) return 1;
    if(a >20 || b >20 || c >20) return mw(20,20,20);
    if(vis[a][b][c]) return w[a][b][c]; // 状态检查
    
    if(a < b && b < c) {
        w[a][b][c] = mw(a,b,c-1) + ...;
    } else {
        w[a][b][c] = mw(a-1,b,c) + ...;
    }
    vis[a][b][c] = true; // 标记已计算
    return w[a][b][c];
}
```

---

### 关键优化技巧总结  
1. **记忆化剪枝**：通过三维数组存储中间结果，避免重复递归。  
2. **参数约束**：将超过20的参数约束到20，负数直接返回1。  
3. **预处理策略**：对于固定范围参数（如本题的20），可提前计算所有可能值。  
4. **条件判断顺序**：严格按照题目优先级处理边界条件（如先判断≤0再判断>20）。

---

### 相似题目推荐  
1. **P1434 [SHOI2002]滑雪**（记忆化搜索/动态规划）  
2. **P1048 采药**（背包问题+记忆化优化）  
3. **P1216 数字三角形**（递推预处理+路径优化）

---
处理用时：57.92秒
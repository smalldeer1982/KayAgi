# 题目信息

# 宿舍里的故事之五子棋

## 题目描述

宿舍里好多好多有趣的事！

7890653 今天看到不知何时流行的五子棋，在宿舍里拿个本子，画一些格子，一个棋盘就做好了。

当 7890653 把目光放到棋上，突发奇想……

在一个 $5 \times 5$ 的棋盘内，放上 $n$ 颗棋子，其中 $5 \le n \le 25$；

这 $n$ 颗棋子可以放到棋盘内任意一个地方，但是不能重叠在一起。于是，便会有五颗棋子排成一行，或一列，或处在同一条对角线上。不同的放法可能会出现不同个数的五子的排列。

本题你要做的是，给你一个 $n$，你要找出不同放法出现的五子连线的数量（设为 $k$），如 $n=11$，有：

![](https://cdn.luogu.com.cn/upload/image_hosting/rcwazq5o.png)

只有这两种非负的 $k$ 值，（注意 $k$ 不重复），你要输出的便是 $k$ 值的和。

也就是 $1+2=3$。

## 样例 #1

### 输入

```
11```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题核心在于枚举所有可能的棋子摆放方式，统计不同五子连线数量k的分布。由于棋盘规模较小（5x5），直接DFS暴力搜索是可行的。优化点在于剪枝策略（剩余格子数判断）和棋盘状态的高效判断。打表法虽高效但缺乏通用性，DFS+剪枝是更通用的解法。

---

### 高分题解推荐

#### 1. Youngsc的题解（★★★★★）
**关键亮点**：  
- 将二维棋盘转化为一维处理，简化递归逻辑  
- 加入**可行性剪枝**大幅优化搜索效率  
- 代码结构清晰，包含坐标转换模板  
**个人心得**：  
> "将5*5的棋盘转化为25个格子的线" —— 线性化处理简化DFS逻辑  
> "剩下的格子不够剩下的棋子就返回" —— 强调剪枝的重要性  

**核心代码**：  
```cpp
inline void dfs(R int pos,R int num){
    if(!num){ check(); return; }
    if(25-pos+1 < num) return; // 关键剪枝
    for(R int i=pos; i<=25; ++i){
        R int x = (i-1)/5+1, y = (i-1)%5+1;
        f[x][y] = 1;
        dfs(i+1,num-1);
        f[x][y] = 0;
    }
}
```

#### 2. 樱式分解的题解（★★★★☆）  
**关键亮点**：  
- 直观的二维DFS实现，易于理解棋盘结构  
- 完整展示五子连线的判断逻辑  
- 使用回溯法枚举所有组合  

**核心判断逻辑**：  
```cpp
void c(){
    int q=0;
    // 检查行、列
    for(int i=1;i<=5;i++){
        if(a[i][1]&&a[i][2]&&a[i][3]&&a[i][4]&&a[i][5])q++;
        if(a[1][i]&&a[2][i]&&a[3][i]&&a[4][i]&&a[5][i])q++; 
    }
    // 检查对角线
    if(a[1][1]&&a[2][2]&&a[3][3]&&a[4][4]&&a[5][5])q++;
    if(a[1][5]&&a[2][4]&&a[3][3]&&a[4][2]&&a[5][1])q++;
    f[q]=true;
}
```

---

### 关键思路总结
1. **状态压缩**：将棋盘位置线性化（i→(x,y)），简化搜索过程  
2. **剪枝策略**：剩余可用位置 < 待放置棋子数时提前终止分支  
3. **连线判断**：统一处理行、列、对角线，利用短路逻辑优化判断  
4. **结果去重**：使用bool数组记录出现的k值，保证唯一性  

---

### 拓展建议
同类问题可考虑：  
- 棋盘类组合问题（如八皇后变形）  
- 需要枚举组合状态的计数问题  
- 带剪枝的深度优先搜索应用场景  

推荐练习题：  
1. P1219 [八皇后](https://www.luogu.com.cn/problem/P1219)  
2. P1036 [选数](https://www.luogu.com.cn/problem/P1036)  
3. P1120 小木棍（DFS剪枝经典）

---
处理用时：60.65秒
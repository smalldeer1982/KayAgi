# 题目信息

# 拯救oibh总部

## 题目背景

oibh 总部突然被水淹没了！现在需要你的救援……


## 题目描述

oibh 被突来的洪水淹没了，还好 oibh 总部有在某些重要的地方起一些围墙。用 `*` 号表示，而一个四面被围墙围住的区域洪水是进不去的。

oibh 总部内部也有许多重要区域，每个重要区域在图中用一个 `0` 表示。

现在给出 oibh 的围墙建设图，问有多少个没被洪水淹到的重要区域。

## 说明/提示

对于 $100\%$ 的数据，$1 \le x,y \le 500$。

## 样例 #1

### 输入

```
4 5
00000
00*00
0*0*0
00*00```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 5
*****
*0*0*
**0**
*0*0*
*****```

### 输出

```
5```

# AI分析结果



### 综合分析与结论
本题核心是识别被围墙完全包围的"0"区域。各题解主要采用DFS/BFS洪水填充算法，从边界或外围开始标记可淹没区域，最终统计未被淹没的区域。关键优化点在于边界处理方式（如外围扩展一圈）和染色策略。

---

### 精选题解（评分≥4星）

#### 1. 是羊驼鸭（★★★★★）
**关键亮点**：
- 外围扩展技巧：将地图外围虚拟一圈空地，从(0,0)开始DFS，确保所有外部连通区域被标记。
- 代码简洁清晰，染色逻辑直观。
- 处理边界条件巧妙，避免复杂判断。

**核心代码**：
```cpp
void dfs(int m,int n) {
    if(m<0||n<0||m>x+1||n>y+1||map[m][n]) return;
    map[m][n]=2;   
    dfs(m+dx[i],n+dy[i]); // 向四个方向扩展
}
// 主函数中调用：dfs(0,0);
```

**个人心得**：
> "若某一行或列全为*时，dfs(0,0)可自动处理外围，避免漏判边界情况。"

#### 2. Blue_wonders（★★★★☆）
**关键亮点**：
- 分阶段处理：先标记边界可淹没区域，再统计内部未标记点。
- 详细注释配图解释，适合新手理解DFS流程。
- 显式遍历四周边界点，逻辑严谨。

**核心实现**：
```cpp
for(int i=1;i<=n;i++){ // 处理第一列和最后一列
    if(a[i][1]==0) search(i,1);
    if(a[i][m]==0) search(i,m);
}
for(int i=1;i<=m;i++){ // 处理第一行和最后一行
    if(a[1][i]==0) search(1,i);
    if(a[n][i]==0) search(n,i);
}
```

#### 3. xxxjz（★★★★☆）
**关键亮点**：
- 调试经验：通过外围加一圈0解决边界漏判问题。
- 提供错误样例分析，强调边界处理的必要性。
- 代码简洁，突出核心逻辑。

**关键代码改进**：
```cpp
void dfs(int x,int y) {
    if(x<0||y<0||x>n+1||y>m+1||ch[x][y]=='*') return;
    ch[x][y]='*';
    dfs(x+xx[i],y+yy[i]); // 扩展时自动处理虚拟外围
}
```

**调试教训**：
> "原代码未加外围导致错误，添加虚拟外围后解决边界问题。"

---

### 最优关键思路总结
1. **外围扩展法**：在地图外虚拟一圈空地（坐标0到n+1），从(0,0)开始DFS/BFS，确保所有外部连通区域被标记。
2. **逆向思维**：统计未被洪水淹没的区域（未被染色的点），而非直接寻找闭合区域。
3. **染色标记**：通过修改原地图或使用辅助数组记录访问状态，避免重复计算。

---

### 拓展建议
1. **同类题目推荐**：
   - P1162 填涂颜色（闭合区域染色）
   - P1596 [USACO]湖计数（连通块计数）
   - P1451 求细胞数量（字符矩阵连通块）

2. **算法套路延伸**：
   - 多源BFS：同时从多个起点扩展（如P2867窗口面积统计）
   - 双向BFS：优化大规模搜索问题
   - 并查集：处理动态连通性问题

---

### 核心代码片段（最优解）
```cpp
// 外围扩展DFS实现
int dx[] = {0,0,1,-1}, dy[] = {1,-1,0,0};
void dfs(int x, int y) {
    if(x<0 || x>n+1 || y<0 || y>m+1 || vis[x][y]) return;
    vis[x][y] = 1;
    for(int i=0; i<4; ++i) dfs(x+dx[i], y+dy[i]);
}
// 初始化调用：dfs(0,0);
// 最终统计：未被访问且原始为0的点
```

---
处理用时：69.73秒
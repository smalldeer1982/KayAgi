# 题目信息

# [USACO18FEB] Hoofball B

## 题目描述

为了准备即将到来的蹄球锦标赛，Farmer John 正在训练他的 $N$ 头奶牛（方便起见，编号为 $1\ldots N$，其中 $1\le N\le 100$）进行传球。这些奶牛在牛棚一侧沿直线排列，第 $i$ 号奶牛位于距离牛棚 $x_i$ 的地方（$1\le x_i\le 1000$）。每头奶牛都在不同的位置上。

在训练开始的时候，Farmer John 会将若干个球传给不同的奶牛。当第 $i$ 号奶牛接到球时，无论是从 Farmer John 或是从另一头奶牛传来的，她会将球传给最近的奶牛（如果有多头奶牛与她距离相同，她会传给其中距左边最远的那头奶牛）。为了使所有奶牛都有机会练习到传球，Farmer John 想要确保每头奶牛都持球至少一次。帮助他求出为了达到这一目的他开始时至少要传出的球的数量。假设他在开始的时候能将球传给最适当的一组奶牛。 

## 说明/提示

在上面的样例中，Farmer John 应该将球传给位于 $x=1$ 的奶牛和位于 $x=11$ 的奶牛。位于 $x=1$ 的奶牛会将她的球传给位于 $x=3$ 的奶牛，在此之后这个球会在位于 $x=3$ 的奶牛和位于 $x=4$ 的奶牛之间来回传递。位于 $x=11$ 的奶牛会将她的球传给位于 $x=7$ 的奶牛，然后球会被传给位于 $x=4$ 的奶牛，在此之后这个球也会在位于 $x=3$ 的奶牛和位于 $x=4$ 的奶牛之间来回传递。这样的话，所有的奶牛都会至少一次接到球（可能从 Farmer John，也可能从另一头奶牛）。

可以看出，不存在这样一头奶牛，Farmer John 可以将球传给她之后所有奶牛最终都能被传到球。 

## 样例 #1

### 输入

```
5
7 1 3 11 4```

### 输出

```
2```

# AI分析结果



### 综合分析与结论
题目核心是构建传球链并识别必须发球的起点。关键点在于：① 排序后构建传球指向关系 ② 统计入度为0的节点（必须发球点）③ 处理两两互传的孤立环（需额外+1）。所有题解均采用排序+入度统计框架，差异主要在环的处理方式上。

---

### 精选题解与评分

#### 1. 作者：jianglai0119（⭐⭐⭐⭐⭐）
**关键亮点**  
- 创新性使用DFS标记可达节点，剩余未访问节点必为两两环，直接计算剩余数/2  
- 引入nxt数组替代邻接表，简化实现  
- 详细反例分析，说明单纯入度统计的漏洞  

**核心代码**  
```cpp
// 构建传球关系与入度统计
for(int i=1;i<=n;i++){
    if(i==1) nxt[i]=i+1, Du[i+1]++;
    else if(i==n) nxt[i]=i-1, Du[i-1]++;
    else if(a[i]-a[i-1] <= a[i+1]-a[i]) nxt[i]=i-1, Du[i-1]++;
    else nxt[i]=i+1, Du[i+1]++;
}

// DFS遍历入度为0的点
for(int i=1;i<=n;i++) 
    if(!Du[i]) ans++, DFS(i);

// 处理剩余环
ans += (未访问节点数)/2;
```

---

#### 2. 作者：Silent1019（⭐⭐⭐⭐）
**关键亮点**  
- 简洁清晰的入度统计框架  
- 直接通过to数组判断互传环，逻辑简明  
- 边界处理（a[0]和a[n+1]设为极大值）避免越界  

**核心代码**  
```cpp
for(int i=1;i<=n;i++){
    if(a[i]-a[i-1] > a[i+1]-a[i]) to[i]=i+1, cnt[i+1]++;
    else to[i]=i-1, cnt[i-1]++;
}
ans = 入度为0的节点数;
// 检查互传环
for(int i=1;i<=n;i++)
    if(cnt[i]==1 && cnt[i+1]==1 && to[i]==i+1 && to[i+1]==i)
        ans++;
```

---

#### 3. 作者：Je_son（⭐⭐⭐⭐）
**关键亮点**  
- 使用独立数组存储传球目标(to)与入度(cnt)  
- 特判条件合并到主循环，代码紧凑  
- 明确注释说明环的判断逻辑  

**核心代码**  
```cpp
for(int i=1;i<=n;i++){
    if(a[i]-a[i-1] <= a[i+1]-a[i])
        cnt[i-1]++, to[i] = i-1;
    else
        cnt[i+1]++, to[i] = i+1;
}
// 处理互传环
for(int i=2;i<=n;i++)
    if(to[i-1]==i && to[i]==i-1 && cnt[i-1]==1 && cnt[i]==1)
        res++;
```

---

### 关键技巧总结
1. **排序预处理**：将奶牛按位置排序，使传球方向仅需考虑相邻节点  
2. **入度统计**：通过入度数组快速识别必须发球的起点  
3. **环检测**：两两互传的环需特殊处理（入度均为1且相互指向）  
4. **边界处理**：设置虚拟极大/极小值避免数组越界  

---

### 拓展题目推荐
1. [P2661 信息传递](https://www.luogu.com.cn/problem/P2661) - 有向图最小环检测  
2. [P2921 Trick or Treat on the Farm](https://www.luogu.com.cn/problem/P2921) - 基环树遍历  
3. [P5149 会议座位](https://www.luogu.com.cn/problem/P5149) - 排序后构建映射关系  

---

### 题解中的调试经验
- **jianglai0119**：初始仅统计入度为0的节点，遇到互传环会WA，通过构造反例 `7 1 3 11 4 100 101` 发现漏洞  
- **Silent1019**：强调INF需设为足够大值（如2e9），避免距离计算溢出  
- **__O_v_O__**：发现当两节点互传但其他节点无法到达时，需额外发球

---
处理用时：49.25秒
# 题目信息

# 入门

## 题目描述

不是任何人都可以进入桃花岛的，黄药师最讨厌像郭靖一样呆头呆脑的人。所以，他在桃花岛的唯一入口处修了一条小路，这条小路全部用正方形瓷砖铺设而成。有的瓷砖可以踩，我们认为是安全的，而有的瓷砖一踩上去就会有喷出要命的毒气，那你就死翘翘了，我们认为是不安全的。你只能从一块安全的瓷砖上走到与他相邻的四块瓷砖中的任何一个上，但它也必须是安全的才行。

由于你是黄蓉的朋友，她事先告诉你哪些砖是安全的、哪些砖是不安全的，并且她会指引你飞到第一块砖上（第一块砖可能在任意安全位置），现在她告诉你进入桃花岛的秘密就是：如果你能走过最多的瓷砖并且没有死，那么桃花岛的大门就会自动打开了，你就可以从当前位置直接飞进大门了。

注意：瓷砖可以重复走过，但不能重复计数。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq W,H\le 20$。

## 样例 #1

### 输入

```
11 9
.#.........
.#.#######.
.#.#.....#.
.#.#.###.#.
.#.#..@#.#.
.#.#####.#.
.#.......#.
.#########.
...........
```

### 输出

```
59```

# AI分析结果



### 综合分析结论
本题本质是连通块计数问题，所有题解均采用DFS/BFS实现。核心难点在于正确理解输入行列顺序、避免重复计数、处理起点初始值。最优解法为不回溯的DFS/BFS，通过标记已访问位置实现去重。

---

### 高星题解推荐

#### 1. 作者：cyr2003（4.5星）
**关键亮点**：  
- 清晰处理行列输入顺序  
- 独立标记数组提升可读性  
- 函数式DFS结构便于理解  
**核心代码**：
```cpp
void dfs(int x,int y) {
    if(越界/不可走) return;
    b[x][y]=false; // 标记已访问
    ans++;
    dfs(x+1,y); // 四方向递归
    ... 
}
```

#### 2. 作者：那一条变阻器（4星）
**关键亮点**：  
- 染色法直接修改原数组节省空间  
- 明确ans初始值设为1处理起点  
**代码亮点**：
```cpp
void g(int x,int y){
    a[xx][yy] = -1; // 染色标记已访问
    ans++; 
    dfs(xx,yy); 
}
```

#### 3. 作者：Cxs3（4星）
**关键亮点**：  
- 详细边界条件注释  
- 方向数组规范清晰  
**核心实现**：
```cpp
int dx[]={0,-1,1,0,0}, dy[]={0,0,0,-1,1};
for(int i=1;i<=4;i++){ // 规范四方向遍历
    if(未越界 && 可走 && 未访问){
        ans++; 
        dfs(...);
    }
}
```

---

### 关键技巧总结
1. **行列顺序处理**：输入宽高后，存储矩阵时行列要倒置（h行w列）
2. **染色标记法**：将已访问位置标记为障碍（如赋值为'#'）节省额外空间
3. **不回溯DFS**：只需标记访问无需恢复状态，保证时间复杂度O(nm)
4. **初始值设定**：起点计入答案，ans初始化为1

---

### 同类题目推荐
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 连通块预处理  
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - 逆向染色技巧  
3. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135) - BFS最短路径变形

---

### 调试心得摘录
1. **梦里调音**：  
> "审题不认真，代码两行泪"  
→ 错误使用回溯导致超时，修正后直接标记避免重复计数  

2. **二元长天笑**：  
> "队列数组开小导致RE，空间不要吝啬"  
→ BFS队列大小应足够容纳所有可能节点  

3. **张皓涵**：  
> "DFS中直接修改原数组代替标记数组"  
→ 通过染色法减少内存使用，同时避免维护额外状态  

---

（注：所有推荐题解代码均为核心逻辑片段，完整实现需结合输入处理与初始化）

---
处理用时：49.67秒
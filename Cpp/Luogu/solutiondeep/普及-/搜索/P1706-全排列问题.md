# 题目信息

# 全排列问题

## 题目描述

按照字典序输出自然数 $1$ 到 $n$ 所有不重复的排列，即 $n$ 的全排列，要求所产生的任一数字序列中不允许出现重复的数字。


## 说明/提示

$1 \leq n \leq 9$。

## 样例 #1

### 输入

```
3```

### 输出

```
    1    2    3
    1    3    2
    2    1    3
    2    3    1
    3    1    2
    3    2    1
```

# AI分析结果



### 综合分析与结论
全排列问题的核心解法可分为两类：1. 基于回溯的DFS实现（理解算法本质） 2. 利用STL的`next_permutation`（快速实现）。其他方法如状态压缩、模拟循环等展示了不同思维角度但适用性有限。DFS回溯法在时间和空间复杂度（O(n!)）上最优，且具有教学价值。

---

### 高星题解推荐

#### 1. 和泉正宗（DFS回溯）⭐⭐⭐⭐⭐
**核心亮点**：  
- 清晰图解搜索树结构，直观展示递归过程  
- 完整标注回溯逻辑与剪枝原理  
- 代码结构规范，变量命名明确（pd数组标记使用状态）  
- 输出格式处理规范（%5d保留场宽）

**关键代码**：  
```cpp
void dfs(int k){
    if(k==n){ print(); return; }
    for(int i=1;i<=n;i++){
        if(!pd[i]){
            pd[i]=1;
            used[k+1]=i;
            dfs(k+1);
            pd[i]=0;
        }
    }
}
```

#### 2. Xxzxx（状态压缩）⭐⭐⭐⭐  
**核心亮点**：  
- 创新性使用二进制位标记状态  
- 通过lg数组快速定位可用数字  
- 无需标记数组，空间优化（O(1)额外空间）

**关键代码**：  
```cpp
void dfs(int i,int s){
    if(i>n) { /* 输出 */ return; }
    for(int ss=s; ss>0; ss-=ss&(-ss)){
        int temp=ss&(-ss);
        ans[i]=lg[temp]; // 通过位运算快速取可用数
        dfs(i+1,s-temp);
    }
}
```

#### 3. NeosKnight（STL极简版）⭐⭐⭐  
**核心亮点**：  
- 10行极简实现（竞赛实用技巧）  
- 正确使用`next_permutation`生成排列  
- 首项特殊处理优化循环次数  

---

### 关键技巧总结
1. **回溯模板**：  
```cpp
void dfs(层数){
    if(边界) 处理结果;
    for(所有可能选项){
        if(未被使用){
            标记使用;
            存储结果;
            dfs(层数+1);
            撤销标记;
        }
    }
}
```

2. **STL妙用**：  
`do{...}while(next_permutation(arr, arr+n))` 可快速生成全排列，但初始数组需有序。

3. **状态压缩**：  
用整数的二进制位表示状态集合，通过位运算快速查询/更新，适用于n较小（≤20）的场景。

---

### 拓展练习推荐
1. [P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)（组合数+格式控制）  
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036)（DFS+素数判定）  
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)（经典回溯+对角线处理）  

---

### 个人心得摘录
> "回溯时务必要重置标记数组，否则后续排列会缺少数字" —— Harry_Potter  
（调试教训：忘记`book[i]=0`导致结果不全）

> "输出格式的`%5d`比手动加空格更可靠" —— 赤瞳之鸦  
（实践技巧：格式函数能避免肉眼难以发现的空格错误）

> "状态压缩中`a&(-a)`取末位1的技巧惊艳" —— Xxzxx  
（算法优化：位运算的巧妙应用大幅提升效率）

---
处理用时：60.05秒
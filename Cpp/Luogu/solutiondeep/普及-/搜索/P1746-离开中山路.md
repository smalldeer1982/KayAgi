# 题目信息

# 离开中山路

## 题目背景

《爱与愁的故事第三弹·shopping》最终章。


## 题目描述

爱与愁大神买完东西后，打算坐车离开中山路。现在爱与愁大神在 $x_1,y_1$ 处，车站在 $x_2,y_2$ 处。现在给出一个 $n \times n(n \le 1000)$ 的地图，$0$ 表示马路，$1$ 表示店铺（不能从店铺穿过），爱与愁大神只能垂直或水平着在马路上行进。爱与愁大神为了节省时间，他要求最短到达目的地距离（每两个相邻坐标间距离为 $1$）。你能帮他解决吗？


## 说明/提示


对于 $20\%$ 数据，满足 $1\leq n \le 100$。

对于 $100\%$ 数据，满足 $1\leq n \le 1000$。

## 样例 #1

### 输入

```
3
001
101
100
1 1 3 3```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
本题为典型的最短路径问题，所有题解均基于广度优先搜索（BFS）或其优化变种。核心思路是通过队列逐层扩展路径，保证首次到达终点时为最短距离。关键差异体现在算法优化、数据结构选择及代码实现细节上。

### 精选题解与评分

#### 1. 作者：李若谷（双向BFS） ★★★★★
**关键亮点**：
- 采用双向BFS优化，从起点和终点同时扩展，显著减少搜索空间
- 通过`steps`和`stepe`数组分别记录起点/终点到各点的距离，相遇时直接求和
- 处理边界条件严谨，代码逻辑清晰
**核心代码**：
```cpp
int bfs() {
    start.push((node){sx,sy});
    final.push((node){ex,ey});
    steps[sx][sy] = 0; stepe[ex][ey] = 0;
    while (!start.empty() || !final.empty()) {
        // 双向交替扩展，代码篇幅较长此处省略
        if (相遇) return steps[x][y] + stepe[x][y];
    }
}
```

#### 2. 作者：Cult_style（标准BFS） ★★★★☆
**关键亮点**：
- 标准BFS模板实现，适合新手学习
- 详细注释+分离方向数组，代码可读性极佳
- 通过`vis`数组记录步数，直接输出终点值
**调试心得**：
> "vis数组初始化为1是因为起点也算一步，若为0会导致无法区分未访问节点"

#### 3. 作者：_yjh（STL队列） ★★★★
**关键亮点**：
- 规范使用STL队列，结构清晰
- 通过结构体存储坐标与步数，代码扩展性强
- 方向数组与边界检查分离，逻辑简洁

### 关键思路与技巧总结
1. **算法选择**：
   - **基础场景**：标准BFS时间复杂度O(n²)，完全满足n=1e3
   - **优化场景**：双向BFS时间降为O(n²/2)，A*通过启发函数加速搜索
2. **实现细节**：
   - **方向数组**：`dx/dy`定义上下左右移动，避免大量if-else
   - **访问标记**：需在入队时立即标记，防止重复访问
   - **输入处理**：字符读取需注意换行符，建议用`scanf("%s")`逐行读入
3. **数据结构**：
   - 手工队列性能更优（如题解中的数组模拟队列）
   - STL queue方便但需注意对象拷贝开销

### 举一反三
1. **类似题型**：
   - [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443) - BFS基础应用
   - [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 连通块预处理
   - [P2483 【模板】k短路](https://www.luogu.com.cn/problem/P2483) - A*算法实践
2. **扩展技巧**：
   - **多源BFS**：如同时处理多个起点
   - **分层BFS**：处理不同状态（如携带钥匙）

### 关键代码片段（双向BFS核心逻辑）
```cpp
// 正向扩展
for (int i=0; i<lens; i++) {
    node cur = start.front();
    start.pop();
    for (int j=0; j<4; j++) {
        int xx = cur.x+dx[j], yy = cur.y+dy[j];
        if (越界或不可达) continue;
        if (stepe[xx][yy] != -1) // 相遇判断
            return cur.step + 1 + stepe[xx][yy];
        steps[xx][yy] = cur.step + 1;
        start.push({xx, yy, steps[xx][yy]});
    }
}
// 反向扩展同理
```

---
处理用时：60.00秒
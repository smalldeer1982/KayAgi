# 题目信息

# 家族

## 题目描述

在一个与世隔绝的岛屿上，有一个有趣的现象：同一个家族的人家总是相邻的（这里的相邻是指东南西北四个方向），不同的家族之间总会有河流或是山丘隔绝，但同一个家族的人不一定有相同姓氏。现在给你岛上的地图，求出岛上有多少个不同的家族。岛上的地图有 $n$ 行，每行有若干列，每个格子中要么是空格，表示大海，要么是 $\text{``{\tt *}''}$，表示河流或山丘，要么是小写字母，表示一户人家的姓氏。


## 说明/提示

### 数据范围及约定

- $10\%$ 的数据，$n≤1$。
- $30\%$ 的数据，$n≤10$。
- $100\%$ 的数据，$n≤100$，每一行最多不超过 $200$ 个字符。

NOI导刊 2010 普及（10）


## 样例 #1

### 输入

```
4
*zlw**pxh
l*zlwk*hx*
w*tyy**yyy
        zzl
```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题核心是求连通块数量，难点在于处理不规则的二维输入（每行长度不同）及正确判定相邻条件。所有题解均采用DFS/BFS搜索连通块，核心差异在于输入处理、边界判断及代码可读性。

---

### 高星题解推荐

#### 1. 作者：Ksilver (⭐⭐⭐⭐⭐)
**关键亮点**  
- 使用BFS实现，避免递归栈溢出风险。  
- 预处理时将有效字符转为1，简化后续判断逻辑。  
- 显式记录每行长度`l[]`，确保边界判断精确。  
- 代码简洁，注释清晰，处理输入时用`getline`正确读取含空格行。  

**核心代码片段**  
```cpp
void bfs(int x,int y) {
    queue< pair<int,int> > q;
    q.push(make_pair(x,y));
    a[x][y]=0;
    while(!q.empty()) {
        int cx=q.front().first, cy=q.front().second;
        q.pop();
        for(int i=0; i<4; i++) {
            int nx=cx+dx[i], ny=cy+dy[i];
            if(nx>=1 && nx<=n && ny>=1 && ny<=l[nx] && a[nx][ny]==1) {
                a[nx][ny]=0;
                q.push(make_pair(nx,ny));
            }
        }
    }
}
```

#### 2. 作者：白烛葵 (⭐⭐⭐⭐)
**关键亮点**  
- 使用DFS实现，直接修改原数组标记访问，节省内存。  
- 输入处理正确跳过非字母字符，边界判断严谨。  
- 代码风格简洁，适合快速实现。  

**调试心得**  
> 初始未考虑每行长度不同，直接使用固定列数导致越界。后通过`tu[i].size()`动态获取行长度解决。

**核心代码**  
```cpp
void dfs(int x,int y) {
    if(x<0 || y<0 || x>=n || y>=tu[x].size() || !lxy[x][y]) return;
    lxy[x][y]=0;
    dfs(x+1,y); dfs(x-1,y); dfs(x,y+1); dfs(x,y-1);
}
```

#### 3. 作者：Stephzzz (⭐⭐⭐⭐)
**关键亮点**  
- 结构体封装坐标，提升代码可读性。  
- 显式处理输入中的换行符，避免脏数据。  
- 详细注释解释BFS流程，适合新手学习。  

**核心代码**  
```cpp
typedef struct { int row, col; } QElement;
void bfs(int row, int col) {
    QElement e1 = {row, col};
    q.push(e1);
    visited[row][col] = 1;
    while (!q.empty()) {
        QElement e2 = q.front(); q.pop();
        for (int k=0; k<4; k++) {
            int i = e2.row + movex[k], j = e2.col + movey[k];
            if (i>=0 && j>=0 && i<n && j<s[i].length() && ...) {
                // 入队并标记
            }
        }
    }
}
```

---

### 最优关键思路总结
1. **输入处理**：使用`getline`逐行读取，记录每行实际长度，避免固定列数导致越界。  
2. **标记与判重**：直接修改原数组（如置0）或使用独立`vis`数组，确保不重复访问。  
3. **边界判定**：动态判断每行的列范围（如`j < s[i].size()`），而非固定最大值。  
4. **搜索方式**：DFS/BFS均可，BFS更安全，DFS代码更简洁。  

---

### 拓展与相似题目推荐
1. **P1451 求细胞数量** - 基础连通块计数，规则网格。  
2. **P1596 Lake Counting** - 八方向连通块，字符矩阵处理。  
3. **P1162 填涂颜色** - 复杂边界条件下的连通块搜索。

---
处理用时：54.22秒
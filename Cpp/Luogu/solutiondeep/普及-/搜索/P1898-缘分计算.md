# 题目信息

# 缘分计算

## 题目背景

缘分是一个外国人难以理解的中文名词。大致说来，缘分是一种冥冥中将两人（通常是情人）结合的力量。仅管这是种迷信，很多人——特别是女生——喜欢去计算它。

不幸的是，644 也是这样。有天，她问 DL：“甜心，可以算一下我们的缘分吗？”唉，DL 真的很讨厌这问题，但他无法拒绝。还好，DL 是个程序设计师，所以他只要找到一个看来不错的算法并写成一个缘分计算器就可以了。在网络上搜寻了几个小时后，他决定采用以下的缘分算法：

## 题目描述

第一步：取出姓名的缩写（abbreviation）并接在一起。例如，如果这对恋人叫 JiangYunFan 和 TangYuRou，他们的缩写就是 JYFTYR。第二步：将每个字母用数字字符串取代。用 $\mathrm{ST}$ 来取代 $\tt A$，$\mathrm{ST}+1$ 来取代 $\tt B$，$\mathrm{ST}+2$ 来取代 $\tt C$，……，$\mathrm{ST}+25$ 来取代 $Z$，其中 $\mathrm{ST}$ 为一个已知的正整数。例如，如果 $\mathrm{ST}=81$，$\tt A$ 就被 $81$ 取代，$\tt B$ 就被 $82$ 取代，……，$\tt Z$ 则被 $106$ 取代。上面的例子 JYFTYR 则被 $901058610010598$ 取代。

第三步：重复以下操作：将相邻的两位数相加，并写下和的个位数。不难发现这个操作每进行一次，这个数字字符串就会少一位数。当这个数字变成 $100$ 或不超过两位数（第一位是 $0$ 也算两位数）时，这个程序便停止。所得的数字就是两人的缘分。用上面的例子来说，处理的过程如下：

- $901058610010598$；
- $91153471011547$；
- $0268718112691$；
- ……
- $374$；
- $01$。

所以如果 $\mathrm{ST}=81$，JiangYunFan 和 TangYuRou 的缘分便只有 $1$。

惨了！DL 很了解 644。他知道即使这个程序计算出的缘分高达 $99$ 她仍然会不高兴。更何况 644 还对其余很多对恋人间的缘分感兴趣，要是他一个个计算会太繁琐。如果告诉你一对恋人的姓名和一个 $\mathrm{ST}$ 值，你能编一个程序算出他们的缘分吗？

## 说明/提示

### 数据范围及约定

对于 $100\%$ 的数据，$4 ≤ L ≤ 10$，$1 ≤ \mathrm{ST} ≤ 10000$。

### 注意

如果你和你的恋人的缘分不是 $100$，不要伤心。这没有什么大不了的。

## 样例 #1

### 输入

```
DLLSS
478```

### 输出

```
100
```

# AI分析结果



### 综合分析与结论
本题核心是模拟字符串转换与相邻数位相加过程。各题解均采用模拟思路，核心差异集中在数位分离方式（正序/倒序）、存储结构（数组/字符串）、特判逻辑实现等细节。最优解法需兼顾代码简洁性与边界处理完备性。

---

### 高分题解推荐

#### 1. 作者：Lolierl（⭐⭐⭐⭐⭐）
**关键亮点**：
- 倒序数位分离：用取模法分解数字，无需复杂条件判断
- 高效数组处理：倒序存储后直接操作数组，避免字符串拼接
- 精简循环逻辑：仅需2层循环完成所有合并操作
- 正确性保障：特判100逻辑清晰，前导0处理巧妙

**核心代码**：
```cpp
for(int i=0;i<len;i++)
    a[i+1]=s[i]-65+st; // 字母转数字
int k[100001],p=0;
for(int i=len;i>=1;i--)  // 倒序分解数位
    while(a[i]>0){
        p++;
        k[p]=a[i]%10;
        a[i]/=10;
    }
while(p>2){
    for(int j=1;j<=p-1;j++)
        k[j]=(k[j]+k[j+1])%10; // 相邻相加
    p--;
}
```

#### 2. 作者：hmh13951417981（⭐⭐⭐⭐）
**关键亮点**：
- 正序数位分离：通过权重计算逐位提取
- 实时长度控制：动态维护数组有效长度
- 特判优化：提前检测100情况终止循环

**调试心得**：
> "特判条件写反导致WA两次，最后发现应检测a[1]==1而非a[3]==1。调试时用中间输出验证每轮结果"

#### 3. 作者：_Luminous（⭐⭐⭐⭐）
**技巧亮点**：
- 双数组交替：避免修改当前处理中的数组
- 位运算优化：用字符直接计算减少类型转换
- 内存预分配：固定大数组提升执行效率

---

### 最优关键思路
1. **倒序数位分离**：分解字母对应数字时，从低位到高位存储，利用`num%10`和`num/=10`快速获取各位
2. **滚动数组优化**：每次合并后覆盖原数组前部，空间复杂度保持O(n)
3. **即时特判**：在每次合并循环开始时检查100情况，避免多余计算
4. **前导0处理**：输出时用`a*10+b`自动过滤无效前导0，同时保留合法0值

---

### 相似题目推荐
1. [P1014 Cantor表](https://www.luogu.com.cn/problem/P1014) - 模拟数字排列规律
2. [P1328 生活大爆炸版石头剪刀布](https://www.luogu.com.cn/problem/P1328) - 循环状态模拟
3. [P1065 作业调度方案](https://www.luogu.com.cn/problem/P1065) - 多步骤过程模拟

---

### 题解心得知乎
**作者帝千秋**：  
> "测试时发现ST=0会导致异常，添加`st=abs(st)`后解决。教训：永远不要相信输入范围说明！"  
**总结**：防御性编程至关重要，即使题目给出数据范围也要做基本校验

**作者__Chtholly**：  
> "原以为倒序存储会复杂，实际比正序少30%代码量。顿悟：选择数据结构时应优先考虑操作便利性而非存储顺序"  
**总结**：算法设计时需权衡存储方式与操作复杂度，有时反直觉的方案更高效

---
处理用时：56.46秒
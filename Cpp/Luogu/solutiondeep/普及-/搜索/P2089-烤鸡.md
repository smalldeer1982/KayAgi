# 题目信息

# 烤鸡

## 题目背景

猪猪 Hanke 得到了一只鸡。


## 题目描述

猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 $10$ 种配料（芥末、孜然等），每种配料可以放 $1$ 到 $3$ 克，任意烤鸡的美味程度为所有配料质量之和。

现在， Hanke 想要知道，如果给你一个美味程度 $n$ ，请输出这 $10$ 种配料的所有搭配方案。

## 说明/提示

对于 $100\%$ 的数据，$n \leq 5000$。

## 样例 #1

### 输入

```
11```

### 输出

```
10
1 1 1 1 1 1 1 1 1 2 
1 1 1 1 1 1 1 1 2 1 
1 1 1 1 1 1 1 2 1 1 
1 1 1 1 1 1 2 1 1 1 
1 1 1 1 1 2 1 1 1 1 
1 1 1 1 2 1 1 1 1 1 
1 1 1 2 1 1 1 1 1 1 
1 1 2 1 1 1 1 1 1 1 
1 2 1 1 1 1 1 1 1 1 
2 1 1 1 1 1 1 1 1 1 ```

# AI分析结果



### 综合分析与结论
该题核心是枚举所有满足条件的组合方案，难点在于高效遍历与存储管理。所有题解均围绕枚举展开，主要分为暴力循环、递归回溯、存储优化三类思路。最优解法需兼顾代码简洁性与执行效率。

---

### 高星题解推荐

#### 1. 氢氧化铯CsOH（★★★★★）
**关键亮点**：
- **DFS剪枝优化**：提前终止无效分支（剩余调料全取最大/最小值仍不满足时停止）
- **高效字符串处理**：使用 `sprintf` 和指针偏移直接构建输出字符串，避免多次IO操作
- **代码分层清晰**：分离DFS逻辑与字符串拼接，便于维护

**核心代码**：
```cpp
void dfs(int cur, int left) {
    if(cur == 10 && !left) {
        cnt++; 
        printans(); // 将结果追加到字符串
        return;
    }
    for(int i=1; i<=3; i++) {
        if((10-cur-1)*3 + i < left) continue; // 剪枝1：剩余全3克仍不足
        if((10-cur-1) + i > left) break;      // 剪枝2：剩余全1克仍超出
        dfs(cur+1, left-i);
    }
}
```

#### 2. 万枪先生（★★★★☆）
**关键亮点**：
- **递归回溯模板清晰**：通过参数传递当前状态，代码可读性强
- **二维数组预存结果**：避免重复计算，直接输出全部方案
- **提前终止无效路径**：当 `total >= n` 时停止递归

**核心代码**：
```cpp
void peiliao(int total, int a) {
    if(a == 10) {
        if(total == n) memcpy(m1[kind++], m2, sizeof(m2)); // 存储方案
        return;
    }
    for(int i=1; i<=3; i++) {
        m2[a] = i;
        peiliao(total+i, a+1); // 递归尝试下一种调料
    }
}
```

#### 3. 冰翼ACE（★★★★☆）
**关键亮点**：
- **剪枝策略明确**：在递归前判断当前总和的可行性
- **状态恢复干净**：回溯时重置调料值为0，避免脏数据
- **二维数组存储结构**：直接映射输出格式，便于快速输出

**核心代码**：
```cpp
void search(int dep, int fsum) {
    if(dep > 10) {
        if(累计值等于n) 存储方案;
        return;
    }
    for(int i=1; i<=3; i++) {
        if(fsum+i > n) break; // 提前终止
        a[dep] = i;
        search(dep+1, fsum+i);
    }
}
```

---

### 关键思路与技巧总结
1. **剪枝优化**：在递归中通过剩余调料的最小/最大可能值提前终止无效分支
2. **输出优化**：使用字符串拼接代替多次`cout`，减少IO时间消耗
3. **存储设计**：预分配二维数组或字符串缓冲区，避免动态扩容开销
4. **递归模板**：参数传递当前状态（已选调料数、当前总和），通过回溯遍历所有可能

---

### 拓展与相似题目推荐
1. **全排列问题**（P1706）：递归实现排列生成，练习回溯基础
2. **选数**（P1036）：DFS剪枝的经典应用，求组合数
3. **三连击**（P1618）：暴力枚举与数学优化结合，训练枚举策略

---

### 题解中的调试经验
- **字符串覆盖问题**：氢氧化铯CsOH提到多次使用`sprintf`时需注意指针偏移，避免覆盖已有数据
- **递归参数设计**：多个题解强调通过参数传递状态（如当前总质量、已选调料数）而非全局变量
- **边界条件验证**：所有解法均需处理n<10或n>30的特殊情况，体现完整性问题意识

---
处理用时：55.88秒
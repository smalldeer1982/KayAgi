# 题目信息

# 放苹果

## 题目描述

把 $m$ 个同样的苹果放在 $n$ 个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法。（$5,1,1$ 和 $1,1,5$ 是同一种方法）


## 说明/提示

对于所有数据，保证：$1\leq m,n\leq 10$，$0 \leq t \leq 20$。

## 样例 #1

### 输入

```
1
7 3```

### 输出

```
8```

## 样例 #2

### 输入

```
3
3 2
4 3
2 7
```

### 输出

```
2
4
2
```

# AI分析结果



### 综合分析与结论
本题核心是计算允许空盘的非降序分法数，常用递归、动态规划、DFS等方法。递归和动态规划通过分解问题为子问题实现高效计算，DFS通过枚举去重处理。最优解法为递归和动态规划，时间复杂度较低且思路清晰。

### 精选题解
1. **ybb756032937（5星）**  
   **关键亮点**：递归思路明确，详细举例说明，边界处理清晰，适合理解递归分解。  
   **核心代码**：  
   ```cpp
   int apple(int m, int n) {
       if (m == 0 || m == 1 || n == 1) return 1;
       if (m < n) return apple(m, m);
       return apple(m - n, n) + apple(m, n - 1);
   }
   ```
   **思路**：分两种情况：有空盘（`apple(m, n-1)`）和无空盘（`apple(m-n, n)`）。

2. **蒟蒻lxy（5星）**  
   **关键亮点**：动态规划预处理，高效查表，代码结构清晰。  
   **核心代码**：  
   ```cpp
   for (int i = 2; i <= m; i++)
       for (int j = 2; j <= n; j++)
           if (i < j) f[i][j] = f[i][i];
           else f[i][j] = f[i - j][j] + f[i][j - 1];
   ```
   **思路**：递推式`f[i][j]`表示i个苹果放j个盘子的方案数，分情况处理。

3. **Panthera_AFO（4星）**  
   **关键亮点**：DFS枚举不降序分法，避免重复计数。  
   **核心代码**：  
   ```cpp
   void dfs(int pos, int now, int lftV) {
       if (pos == k && !lftV) { ans++; return; }
       for (int i = now; i <= lftV; i++)
           dfs(pos + 1, i, lftV - i);
   }
   ```
   **思路**：按非降序枚举每个盘子苹果数，保证唯一性。

### 关键技巧总结
1. **递归分解**：将问题拆分为存在空盘和满盘两种情况，递归求解。
2. **动态规划状态转移**：预处理状态表，利用递推式避免重复计算。
3. **DFS去重**：通过限制枚举顺序（非降序）避免重复方案。

### 类似题目推荐
1. **P1025 数的划分**（整数划分，不允许空盘）
2. **P1192 台阶问题**（递推与动态规划）
3. **P1249 最大乘积**（分拆优化问题）

### 个人心得摘录
- **调试经验**：DFS需确保枚举顺序避免重复，如规定非降序排列。  
- **优化技巧**：动态规划预处理可大幅提升多次查询效率。  
- **思维突破**：将空盘问题转化为非空盘问题（每个盘减一苹果）。

---
处理用时：53.08秒
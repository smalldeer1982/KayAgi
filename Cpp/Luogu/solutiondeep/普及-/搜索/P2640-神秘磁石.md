# 题目信息

# 神秘磁石

## 题目背景

在遥远的阿拉德大陆，有一种神秘的磁石，是由魔皇制作出来的，


## 题目描述

1. 若给他一个一维坐标系，那么他的磁力一定要在素数坐标的位置上才能发挥的最大（不管位置坐标的大小，只要是素数那么磁力就一样大）。
2. 若两个磁石相距为 $k$，那么磁石间的破坏力将会达到当前磁力的峰值

显然，两磁石间最大破坏力取决于磁力大小和磁石间距，那么请问给出长度不超过 $n$ 的一维坐标系，有哪几对坐标间磁石破坏力最大。


## 说明/提示

对于 $100\%$ 的数据，$1\leq k\leq n\leq 10^4$。

## 样例 #1

### 输入

```
6924 809```

### 输出

```
2 811
```

# AI分析结果



### 综合分析与结论
本题核心是寻找相差k的素数对。题解主要围绕素数判断优化展开，包含暴力判断、筛法、打表、Miller-Rabin等思路。关键优化点在于素数预处理与快速查询，筛法（尤其是线性筛）是时间与代码复杂度最优解。

---

### 高星题解推荐

#### 1. 作者：引领天下（★★★★★）
**亮点**：
- 线性筛法预处理素数表，时间复杂度O(n)
- 使用质数数组优化遍历范围，仅遍历已知素数
- 代码简洁高效，逻辑清晰
**核心代码**：
```cpp
void $(){ // 线性筛预处理
    for(int i=2;i<10001;i++)
        if(!s[i]){
            a[ps++]=i;
            for(int j=i*2;j<10001;j+=i)s[j]=1;
        }
}
int main(){
    $(); // 调用筛法
    for(int i=0;a[i]<=n&&a[i]+k<=n;i++)
        if(!s[a[i]+k]) printf("%d %d\n",a[i],a[i]+k);
}
```

#### 2. 作者：YLWang（★★★★☆）
**亮点**：
- 打表法预处理素数标记，查询O(1)
- 分离生成器与主程序，适合固定范围场景
- 包含生成素数表的完整示例代码
**核心思路**：
```cpp
// 预处理生成素数标记数组
int p[N] = {0,0,1,1,0,1,0,1,0...}; 
// 主程序直接查询
if(p[i] && p[i+k]) printf(...);
```

#### 3. 作者：Qing_s（★★★★☆）
**亮点**：
- 暴力解法中引入6倍原理优化素数判断
- 代码简洁适合初学者理解
- 明确循环边界n-k避免越界检查
**优化点**：
```cpp
bool prime(int x) { // 6倍原理优化
    if(x%6!=1 && x%6!=5) return false;
    int g = sqrt(x);
    for(int i=5;i<=g;i+=6)
        if(x%i==0 || x%(i+2)==0) return 0;
    return 1;
}
```

---

### 关键技巧总结
1. **筛法预处理**：线性筛(O(n))或埃氏筛(O(nloglogn))预处理素数标记数组
2. **双指针遍历**：仅检查素数数组中的元素，避免无效遍历（如引领天下的解法）
3. **数学优化**：利用素数分布规律（6k±1）快速排除合数
4. **边界控制**：i只需遍历到n-k，避免i+k越界

---

### 拓展建议
1. **同类题目**：
   - P1217 [USACO1.5]回文质数（双重性质判断）
   - P3383 【模板】线性筛素数（筛法练习）
   - P1304 哥德巴赫猜想（素数对分解）
   
2. **优化思路**：
- 大范围数据可用分段筛法
- 需要频繁查询时可用前缀和预处理素数区间统计
- 随机数相关题目可结合Miller-Rabin算法

---

### 代码片段精选
**线性筛核心实现**：
```cpp
const int N=1e4+5;
bool f[N]={1,1}; // 合数标记
vector<int> primes;

void init() {
    for(int i=2;i<N;i++){
        if(!f[i]) primes.push_back(i);
        for(int p : primes){
            if(i*p >= N) break;
            f[i*p] = true;
            if(i%p == 0) break;
        }
    }
}
```

**双素数对检测**：
```cpp
for(int i=0; i<primes.size() && primes[i]+k<=n; i++)
    if(!f[primes[i]+k]) 
        cout<<primes[i]<<" "<<primes[i]+k<<endl;
```

---
处理用时：51.66秒
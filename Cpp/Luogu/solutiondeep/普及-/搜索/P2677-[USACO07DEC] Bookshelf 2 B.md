# 题目信息

# [USACO07DEC] Bookshelf 2 B

## 题目描述

Farmer John最近为奶牛们的图书馆添置了一个巨大的书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。 所有N(1 <= N <= 20)头奶牛都有一个确定的身高H\_i(1 <= H\_i <= 1,000,000 - 好高的奶牛>\_<)。设所有奶牛身高的和为S。书架的 高度为B，并且保证1 <= B <= S。 为了够到比最高的那头奶牛还要高的书架顶，奶牛们不得不象演杂技一般，一头站在另一头的背上，叠成一座“奶牛塔”。当然，这个塔的高度，就是塔中所有奶牛的身高之和。为了往书架顶上放东西，所有奶牛的身高和必须不小于书架的高度。 塔叠得越高便越不稳定，于是奶牛们希望找到一种方案，使得叠出的塔在高度不小于书架高度的情况下，高度尽可能小。你也可以猜到你的任务了：写一个程序，计算奶牛们叠成的塔在满足要求的情况下，最少要比书架高多少。


## 说明/提示

输出说明:

我们选用奶牛1、3、4、5叠成塔，她们的总高度为3 + 3 + 5 + 6 = 17。任何方案都无法叠出高度为16的塔，于是答案为1。


## 样例 #1

### 输入

```
5 16
3
1
3
5
6```

### 输出

```
1```

# AI分析结果



### 题解综合分析与结论
本题核心是求解满足条件的子集和最小值问题，各题解主要采用以下思路：
1. **背包DP**：转化为01背包求最接近总容量解，时间复杂度O(n·w)，高效且稳定
2. **DFS剪枝**：通过剪枝优化降低搜索空间，适合小数据量（n≤20）
3. **折半搜索**：将指数级复杂度折半，适用于中等规模数据（n≤40）
4. **贪心与随机化**：存在正确性缺陷或稳定性问题，不推荐使用

### 高星题解推荐（≥4星）

---

#### 题解1：道费而隐（背包DP） ⭐⭐⭐⭐⭐
**关键亮点**：  
- 创新性将问题转化为01背包，总高度差作为背包容量  
- 代码简洁高效（仅20行核心逻辑），空间复杂度优化到位  
- 正确性严格保证，时间复杂度O(n·w)稳定  

**核心代码**：
```cpp
int w = tot - b; // 背包容量
for(int i=1; i<=n; i++)
    for(int j=w; j>=h[i]; j--)
        f[j] = max(f[j], f[j-h[i]]+h[i]);
cout << tot - f[w] - b;
```

---

#### 题解2：郑yz（DFS剪枝） ⭐⭐⭐⭐
**关键亮点**：  
- 引入最优解提前终止机制，显著减少搜索分支  
- 代码可读性强，适合DFS初学者理解剪枝逻辑  
- 添加路径记忆（vis数组）避免重复计算  

**个人心得**：  
> "一开始的>=写成>导致WA，提醒边界条件需谨慎验证"  

**核心剪枝逻辑**：
```cpp
void dfs(int t, long long sum) {
    if(sum >= s) {
        total = min(sum, total); // 立即更新最优解
        return; // 关键剪枝：找到可行解后不再深入
    }
    if(t > n) return;
    dfs(t+1, sum);          // 不选当前牛
    dfs(t+1, sum + hi[t]);  // 选当前牛
}
```

---

#### 题解3：Soledad_S（折半搜索） ⭐⭐⭐⭐
**关键亮点**：  
- 采用分治思想，将2ⁿ复杂度降为2^(n/2)  
- 配合二分查找快速定位最优解  
- 可扩展性强，适用更大规模数据  

**核心实现**：
```cpp
void DFS1(int pos, int ed, int tot) { // 前半部分搜索
    if(pos == ed+1) {
        a[++a[0]] = tot;
        return;
    }
    DFS1(pos+1, ed, tot);
    DFS1(pos+1, ed, tot + s[pos]);
}

int Half(int limit) { // 二分查找最优组合
    int l=1, r=b[0], pos=-1;
    while(l <= r) {
        int mid = (l+r) >> 1;
        if(b[mid] >= limit) pos=mid, r=mid-1;
        else l = mid+1;
    }
    return pos;
}
```

---

### 关键思路总结
1. **背包转化技巧**：将差值问题转化为最大化填充问题
2. **状态压缩剪枝**：在DFS中通过sum >= B立即剪枝
3. **分治优化**：折半搜索+二分查找处理中等规模数据
4. **空间优化DP**：使用滚动数组降低空间复杂度

---

### 推荐相似题目
1. [P2392 背包问题九讲](https://www.luogu.com.cn/problem/P2392) - 各类背包变形的系统练习  
2. [P3067 [USACO12OPEN]Balanced Cow Subsets G](https://www.luogu.com.cn/problem/P3067) - 折半搜索经典应用  
3. [P1036 选数](https://www.luogu.com.cn/problem/P1036) - DFS剪枝基础训练

---
处理用时：59.07秒
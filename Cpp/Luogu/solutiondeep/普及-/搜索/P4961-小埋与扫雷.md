# 题目信息

# 小埋与扫雷

## 题目背景

小埋总是在家中打游戏，一天，她突然想玩Windows自带的扫雷，在一旁的哥哥看见了，想起了自己小时候信息课在机房玩扫雷的日子，便兴致勃勃地开始教小埋扫雷。然而，小埋还是不明白 $\mathrm{3bv}$（Bechtel's Board Benchmark Value，每局将所有非雷的方块点开所需最少左键点击数，参见[扫雷网的教程](http://saolei.net/BBS/Title.asp?Id=227) ）怎么算，于是她找到了你。

![](https://i.loli.net/2018/10/04/5bb5bd6aefb70.jpg)

## 题目描述

小埋会告诉你一盘扫雷，用一个 $n\times m$ 的矩阵表示，$1$ 是雷 ，$0$ 不是雷，请你告诉她这盘扫雷的 $\mathrm{3bv}$ 。 

周围八格没有“雷”且自身不是“雷”的方格称为“空格”，周围八格有“雷”且自身不是“雷”的方格称为“数字”，由“空格”组成的八连通块称为一个“空”。$\mathrm{3bv}=\ $周围八格没有“空格”的“数字”个数$+$“空"的个数。

如果看不懂上面的计算方式，可以看题目背景中给出的教程，或者看下面的样例解释。

注：[八连通](https://baike.baidu.com/item/%E5%85%AB%E8%BF%9E%E9%80%9A)

## 说明/提示

$1\le n,\ m\le 1000$

## 样例解释

![](https://i.loli.net/2018/10/04/5bb5bc4644183.jpg)

## 样例 #1

### 输入

```
8 8
0 0 0 1 1 0 0 0 
1 0 0 1 0 0 0 1 
1 0 0 1 0 0 0 0 
0 0 0 0 0 0 0 0 
0 0 0 0 0 1 0 0 
0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 
0 1 0 0 0 0 0 0 ```

### 输出

```
13```

# AI分析结果



### 综合分析与结论
该题核心在于理解3BV定义并分步处理：**预处理雷图统计数字、DFS/BFS找空格连通块、判断数字周围是否存在空格**。各题解思路趋同，差异在于实现细节与优化技巧。关键点包括八连通处理、边界判断、双重遍历避免冗余。

---

### 精选题解及评分
#### 1. 作者：ouuan（5星）
**亮点**：  
- 预处理时将雷周围数字统一标记，DFS时空格与数字联动处理（遇到数字时ans减一，避免二次遍历）。  
- 方向数组处理八连通，代码简洁高效。  
- 边界处理采用memset初始化，逻辑严谨。  

**关键代码**：
```cpp
void dfs(int x, int y) {
    if (vis[x][y] || g[x][y] == -1) return;
    vis[x][y] = true;
    if (g[x][y] == 0) {
        for (int i=0; i<8; ++i) dfs(x+dir[i][0], y+dir[i][1]);
    } else --ans; // 遇到数字则减一
}
```
**个人心得**：  
"dfs到数字将答案减一并不继续dfs，优化码量与时间"——通过一次DFS同时处理空格与数字，减少遍历次数。

#### 2. 作者：Arse、三千体（4星）
**亮点**：  
- 分步明确：初始化雷图→统计孤立数字→DFS找空块。  
- 独立函数`iff()`判断数字周围是否存在空格，逻辑清晰。  
- 注释详细，适合新手理解流程。  

**关键代码**：
```cpp
void b(int x, int y) { // 预处理雷周围数字
    for (int p=0; p<8; p++) {
        int i=x+xz[p], j=y+yz[p];
        if (i>=0 && i<n && j>=0 && j<m && a[i][j]!=-1) a[i][j]++;
    }
}
```
**不足**：未优化数字判断时的重复遍历。

#### 3. 作者：SunnCloud（4星）
**亮点**：  
- 双重DFS处理：先找空块，再处理剩余数字。  
- 方向数组与越界判断结合，代码鲁棒性强。  
- 标记数组`a[x][y]=2`区分状态，避免额外空间。  

**关键代码**：
```cpp
void dfs(int x, int y) {
    a[x][y] = 2; // 标记已访问
    for (int i=0; i<8; i++) {
        int xx = x+xz[i], yy = y+yz[i];
        if (xx>=0 && xx<n && yy>=0 && yy<m && a[xx][yy]==0) 
            dfs(xx, yy);
    }
}
```

---

### 最优思路与技巧总结
1. **预处理雷图**：将雷标记为特殊值（如-1），遍历雷周围非雷格自增数字计数。
2. **八连通方向数组**：统一处理八个方向，避免冗余代码。
3. **DFS/BFS找空块**：遍历所有0格，标记连通区域，统计空块数。
4. **数字判断优化**：在DFS中处理相邻数字，减少后续遍历次数（如ouuan解法）。
5. **边界处理**：使用`if(xx>=0 && xx<n)`或memset外围标记防止越界。

---

### 拓展与举一反三
- **同类题目**：  
  - [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：矩阵连通块染色。  
  - [P1506 拯救oibh总部](https://www.luogu.com.cn/problem/P1506)：边界连通块处理。  
  - [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)：连通块预处理与查询优化。  

- **思维模式**：  
  - 矩阵遍历时优先预处理辅助信息（如数字值）。  
  - 将复杂问题分解为独立子任务（如先处理空块再处理数字）。  

---

### 题解中的调试经验摘录
- **Arse、三千体**：初始化雷图时思考半小时，强调雷与数字的区分。  
- **SunnCloud**：发现远古题解有误后修正，提醒注意标记定义。  
- **hylong**：边界处理险些被坑，强调八连通与四连通的差异。  

**总结**：八连通易漏方向，初始化需明确状态含义，边界检查是常见错误点。

---
处理用时：65.45秒
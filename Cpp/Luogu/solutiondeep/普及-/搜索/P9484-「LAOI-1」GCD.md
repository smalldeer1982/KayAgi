# 题目信息

# 「LAOI-1」GCD

## 题目描述

一张图有 $n$ 个节点，编号为 $1,2,3,\dots,n$。其中 $i$ 号节点会向 $j$ 号节点连一条边权为 $|i-j|$ 的无向边，当且仅当 $\gcd(i,j)=i,\operatorname{lcm}(i,j)=j$ 时连边。现询问 $q$ 次，每次询问求 $x$ 到 $y$ 的最短路径。

## 说明/提示

注意时空限制，本题不捆绑。

对于 $40\%$ 的数据，$T,n,q\le100$;

对于 $100\%$ 的数据，$1\le T\le10^6$，$1\le n,q\le10^6$，$1\le x,y\le n$，$1\le \sum n,\sum q\le10^6$。

**请使用更快的 IO 方式**。

updata on 2024/8/8：

时限上调到 1000ms。/yun

## 样例 #1

### 输入

```
1
6 4
1 4
3 5
2 5
2 4```

### 输出

```
3
6
5
2```

# AI分析结果



### 综合分析与结论
题目要求快速计算两节点间的最短路径。通过分析边连接条件，发现边仅存在于倍数关系节点之间。核心思路是利用最大公约数（GCD）作为中间枢纽，路径为 `x → GCD(x,y) → y`，总权值为 `x + y - 2*GCD(x,y)`。所有题解均基于此数学性质直接计算，时间复杂度为 O(log(min(x,y))) 每次查询，完美适应数据规模。

---

### 精选题解及评分

#### 1. Coffins 的题解（4星）
**关键亮点**：
- 思路简洁，直接指出边存在的等价条件为倍数关系。
- 通过分类讨论（倍数/因数路径）证明最优性，逻辑清晰。
- 代码高效，使用快速 IO 优化。

**核心代码**：
```cpp
int gcd(int a,int b) {
    while(b^=a^=b^=a%=b);
    return a;
}
// 输出计算：x + y - 2*gcd(x,y)
```
**实现思想**：非递归 GCD 计算配合位运算优化，输入输出加速处理。

#### 2. 官方题解（4星）
**关键亮点**：
- 数学证明更严谨，补充了 LCM 路径的对比分析。
- 使用快读快写模板应对极端数据规模。
- 调用 STL 的 `__gcd` 简化实现。

**核心代码**：
```cpp
int g = __gcd(a, b);
writeln(a + b - 2 * g);
```
**实现思想**：利用 STL 函数与高效 IO 模板，确保算法常数最优。

---

### 最优关键思路与技巧
1. **数论转换**：将图论问题转化为 GCD 性质分析，避免实际建图。
2. **路径构造**：以 GCD 为枢纽点，路径权值公式 `x + y - 2*GCD(x,y)`。
3. **IO 优化**：大规模数据下必须使用快速输入输出（如 `ios::sync_with_stdio(0)` 或快读模板）。

---

### 拓展与举一反三
- **同类问题**：涉及因数/倍数关系的图论问题（如分层图、树形结构）。
- **推荐题目**：
  1. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)
  2. [P2651 添加括号](https://www.luogu.com.cn/problem/P2651)
  3. [P5535 简单数论题](https://www.luogu.com.cn/problem/P5535)

---

### 个人心得摘录
- **Coffins**：首次提交被卡输入，强调 IO 优化的重要性。
- **通用教训**：在 1e6 级数据量下，算法常数（如 GCD 实现、IO 速度）直接影响是否通过。

---
处理用时：50.29秒
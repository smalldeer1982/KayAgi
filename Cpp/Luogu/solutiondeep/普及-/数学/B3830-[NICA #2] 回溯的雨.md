# 题目信息

# [NICA #2] 回溯的雨

## 题目描述

小 Ran 有两个正整数 $x,y$，她还有两个长度为 $n$ 的正整数序列 $a$ 与 $c$ 满足 $a_ix+y=c_i$ （$1\le i\le n$）。

很可惜的是，她忘记了所有 $a_i$ 的值与 $y$ 的值。她给你了 $x$ 的值与序列 $c$，并希望你能还原出一组 $y$ 的值与序列 $a$ 使得原先的条件被满足。

当然，可能存在很多组这样的解，所以她希望你能最大化 $y$ 的值并输出它（注意到你并不需要输出 $a$ 序列）。如果不能还原出这样一组数，请输出 $-1$ 来报告无解。

## 说明/提示

数据保证，$1 \leq n \leq 10^5$，$1 \leq x \leq 10^{12}$，$1 \leq c_i \leq 10^{18}$。

## 样例 #1

### 输入

```
5 2
4 6 8 10 12```

### 输出

```
2```

## 样例 #2

### 输入

```
5 2
3 6 9 12 15```

### 输出

```
-1```

# AI分析结果



### 综合分析与结论
题目要求构造满足条件的正整数序列和最大可能的y。关键点在于：
1. **所有c_i必须严格大于x**（否则无法构造正整数a_i和y）。
2. **所有c_i必须模x同余**（保证存在统一的y）。
3. **最大y为c的最小值减x**（通过最小化a_i的值来最大化y）。

无解条件为上述任意一条不满足。高效解法无需排序，直接遍历数组维护最小值和检查条件。

---

### 高星题解推荐

#### 1. 题解作者：fish_shit（⭐️⭐️⭐️⭐️⭐️）
**关键亮点**：
- **无需排序**，遍历时直接检查相邻差是否整除x，时间复杂度O(n)。
- 及时处理无解条件，内存占用少。
- 代码简洁高效，适合大数据量。

**核心代码**：
```cpp
long long minn=1e18+100;
for(int i=1;i<=n;i++){
    cin>>c[i];
    if(c[i]<=x) { /* 处理无解条件 */ }
    // 检查相邻差是否整除x
    if(i>=2 && (c[i]-c[i-1])%x!=0) { /* 无解处理 */ }
    minn = min(minn, c[i]); // 维护最小值
}
cout<<minn - x;
```

---

#### 2. 题解作者：ljk8886（⭐️⭐️⭐️⭐️）
**关键亮点**：
- 排序后检查余数是否一致，思路直观。
- 明确处理最小值是否大于x的条件。

**核心代码**：
```cpp
sort(c+1,c+n+1);
for(int i=2;i<=n;i++) {
    if(c[i]%x!=c[i-1]%x) { /* 无解处理 */ }
}
cout<<c[1]-x;
```

---

#### 3. 题解作者：Undertale_chara（⭐️⭐️⭐️⭐️）
**关键亮点**：
- 排序后检查所有元素余数是否等于第一个元素。
- 代码结构清晰，变量命名规范。

**核心代码**：
```cpp
sort(c+1,c+1+n);
ll pd=c[1]%x;
for(int i=1;i<=n;i++) {
    if(c[i]%x != pd) { /* 无解处理 */ }
}
cout<<c[1]-x;
```

---

### 最优技巧总结
- **避免排序**：直接遍历数组维护最小值和检查相邻差，复杂度更优。
- **同余转换**：通过检查差是否整除x代替直接模运算，减少计算量。
- **边界处理**：最小值必须严格大于x，防止a_i非正。

---

### 拓展题目推荐
1. **P1082 [NOIP2012 提高组] 同余方程**：求解线性同余方程。
2. **P5656 【模板】二元一次不定方程**：扩展欧几里得算法的应用。
3. **P3951 [NOIP2017 提高组] 小凯的疑惑**：数论中最大值构造问题。

---

### 个人心得摘录
- **数据范围**：必须使用`long long`避免溢出（多篇题解强调）。
- **条件验证**：通过数学推导确保解法正确性（如相邻差整除与同余的等价性）。
- **效率优化**：避免不必要的排序操作，提升代码效率。

---
处理用时：228.26秒
# 题目信息

# [语言月赛 202407] accomplishment

## 题目背景

对于一个国家来说粮食安全至关重要。所以小 A 认为最好的检验方法就是统计有多少粮食。

## 题目描述

小 A 打开了王国的地图，他的地图可以认为是一个 $n$ 行，$m$ 列的表格，每一个格子可以看做一个城市。

理论上来说小 A 只需要把每个城市的粮食统计并加起来就好了，但是小 A 发现他统计时出现了重大失误：他统计的每个城市的粮食数并不只是这一个城市的粮食数，而是和它相邻的所有的城市的粮食数的和。

这里的相邻指八连通，即一个城市的粮食数是它本身粮食数和它上、下、左、右、上左、下左、上右，下右的城市的粮食数的和：

![](https://cdn.luogu.com.cn/upload/image_hosting/u1vfgakc.png)

现在给出小 A 统计的错误的结果，请你帮他计算出，他的国家实际到底共有多少粮食。

## 说明/提示

### 样例 1 解释

小 A 的王国的粮食数一组可以情况为：
| 1 | 2 | 3 |
| :----------: | :----------: | :----------: |
| 3 | 2 | 1 |
| 1 | 3 | 2 |

易得粮食的总和为 $18$。  

### 样例 2 解释

小 A 的王国的粮食数的一种可能情况是：
| 3 | 3 | 3 |
| :----------: | :----------: | :----------: |
| 3 | 3 | 3 |
| 3 | 3 | 3 |

易得粮食的总和是 $27$。  

### 样例 3 解释

小 A 的王国的粮食数的一种可能情况是：
| 1 | 2 | 3 | 4 | 5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 7 | 8 | 9 | 1 | 2 | 3 |
| 4 | 5 | 6 | 7 | 8 | 9 |

易得粮食的总和是 $90$。

### 数据范围

- 对于 $10\%$ 的数据，$n,m \le 3$，$a_{i,j} \le 18$。
- 对于另外 $30\%$ 的数据，$a_{i,j} \le 9$。
- 对于 $100\%$ 的数据，$1 \le n,m \le 1000$，$1 \le a_{i,j} \le 10^9$，$n,m$ 都是 $3$ 的倍数。保证输入数据均对应至少一组合法的实际粮食数据，且这组实际粮食数据中每个位置均有粮食。  

友情提示：别匆忙，放慢脚步。

## 样例 #1

### 输入

```
3 3
8 12 8 
12 18 13 
9 12 8```

### 输出

```
18```

## 样例 #2

### 输入

```
3 3
12 18 12
18 27 18
12 18 12```

### 输出

```
27```

## 样例 #3

### 输入

```
3 6
18 30 27 24 21 16
27 45 45 45 45 33
24 39 36 33 30 22```

### 输出

```
90```

# AI分析结果



### 综合分析与结论
本题核心在于将大矩阵拆分为多个不重叠的 3×3 子矩阵，每个子矩阵的中心点错误值即等于该子矩阵实际值的总和。因此只需遍历所有子矩阵中心点累加错误值即可得到答案。该思路巧妙利用题目中 n,m 均为 3 的倍数的条件，将时间复杂度优化至 O(nm/9)，实现极其简洁。

---

### 精选题解与评分

#### 题解 1 - BinaryPotatoTree（5星）
**关键亮点**  
- 直接点明核心规律：每个 3×3 子矩阵中心点的错误值即为该子矩阵实际总和  
- 代码简洁高效，循环步长直接取 3，避免冗余计算  
- 附示意图帮助理解分块逻辑  

**核心代码**  
```cpp
for(int i=2; i<=n; i+=3) // 从第二行开始（1-based索引）
    for(int j=2; j<=m; j+=3) // 从第二列开始
        sum += a[i][j];
```

#### 题解 2 - I_am_rubbish（4星）  
**关键亮点**  
- 明确数据类型问题（需用 long long 防止溢出）  
- 指出解题思维的关键转变点  
- 附视频题解链接提供多维度解析  

**代码片段**  
（核心思路与题解 1 一致，代码结构相似）

---

### 关键思路总结
**分块处理法**：  
1. 将矩阵分割为多个 3×3 子块  
2. 每个子块中心的错误值 = 该子块实际值的总和  
3. 所有子块中心的错误值之和即为答案  

**实现技巧**：  
- 利用 1-based 索引，从 (2,2) 开始每隔 3 行/列取中心点  
- 累加时直接读取错误矩阵对应值，无需额外计算  

---

### 拓展练习
1. **二维前缀和**：[P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)  
2. **矩阵分块处理**：[P3397 地毯](https://www.luogu.com.cn/problem/P3397)  
3. **规律发现与数学建模**：[P1004 方格取数](https://www.luogu.com.cn/problem/P1004)  

**共通技巧**：  
- 观察数据特征（如本题的 3 的倍数条件）  
- 通过小规模样例推导数学规律  
- 将复杂问题分解为可重复处理的子结构

---
处理用时：56.92秒
# 题目信息

# [NOIP 1998 普及组] 阶乘之和

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题

## 样例 #1

### 输入

```
3
```

### 输出

```
9```

# AI分析结果



### 综合分析与结论
本题考察高精度运算与阶乘累加的结合应用。题解核心难点在于高效处理大数乘法和累加，同时避免溢出。主流解法分为两类：逐项计算阶乘后累加（高精乘+高精加），或数学优化（递推公式转换）。代码实现的关键在于进位处理与数据结构设计。

---

### 高评分题解亮点

#### 1. 作者：zhangboju（★★★★★）
**关键亮点**：数学公式转换法  
- 将阶乘和公式转换为递推形式：`S = 1 + 2*(1 + 3*(1 + 4*(...)))`
- 仅需高精度乘法和简单加法，减少运算次数
- 个人心得：通过公式变形避免高精度加法，显著优化性能

```cpp
for(int i=n;i>=1;i--){
    a[1]++; // 加1操作
    // 处理进位后执行乘法
    a = a * i;
}
```

#### 2. 作者：Nortrom（★★★★☆）
**关键亮点**：模块化设计  
- 分离阶乘计算(`change`)与累加(`qh`)函数，结构清晰
- 使用固定长度数组简化边界处理
- 代码可读性强，适合教学

```cpp
void change(int x){ // 高精度乘法
    int g=0;
    for(int i=100;i>=0;i--){
        a[i]=a[i]*x+g;
        g=a[i]/10;
        a[i]%=10;
    }
}
```

#### 3. 作者：二元长天笑（★★★★☆）
**关键亮点**：运算符重载  
- 通过重载`+`、`*`运算符实现直观运算
- 封装大数结构体，提升代码可维护性
- 展示面向对象思想在高精度问题中的应用

```cpp
struct fantastic {
    int len,s[9999];
    fantastic operator*(const fantastic &x){
        fantastic c;
        c.len = len + x.len;
        for(int i=0;i<len;i++)
            for(int j=0;j<x.len;j++)
                c.s[i+j] += s[i] * x.s[j];
        // 进位处理...
    }
};
```

---

### 核心技巧总结
1. **递推公式优化**：将阶乘和转换为嵌套乘法形式，减少高精度加法次数
2. **压位存储**：使用万进制（4位存一单元）减少运算次数
3. **运算符重载**：通过自定义类型实现直观的大数运算
4. **模块化设计**：分离乘法和加法逻辑，提高代码可维护性

---

### 推荐相似题目
1. P1591（阶乘数码） - 高精度阶乘应用
2. P1255（数楼梯） - 高精度递推
3. P1601（A+B Problem） - 基础高精度加法

---

### 调试经验摘录
> "因为进位写成`f[j+1]++`导致WA一个点...必须用`+=`处理多位进位" —— C_Z_C  
> "突然意识到可以用数学公式转换，减少大量加法运算" —— zhangboju  
> "二维数组存储各阶乘值虽直观但浪费空间，改为复用数组优化" —— 吃葡萄吐糖

这些经验强调了边界检查的重要性，以及数学思维在优化中的关键作用。

---
处理用时：56.91秒
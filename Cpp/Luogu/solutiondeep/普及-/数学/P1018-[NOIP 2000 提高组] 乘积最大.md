# 题目信息

# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# AI分析结果



### 综合分析与结论
本题核心为动态规划结合高精度处理。关键难点在于状态转移时的乘积计算与大数处理。各题解中，高效解法均采用线性DP结构，定义状态为前i位使用j个乘号的最大值，通过枚举分割点转移。高精度实现方式多样，需注意数位存储顺序与运算优化。

---

### 高评分题解推荐
#### 1. liar_white（5星）
**关键亮点**  
- 结构体封装高精度数组，逻辑清晰  
- 预处理各区间数值避免重复计算  
- 状态转移方程明确，注释详尽  
**个人心得**  
- 中间变量传递问题：直接比较函数返回可能导致错误，需用临时变量过渡。

#### 2. FastIO_DP（4星）  
**关键亮点**  
- 高精度类重载运算符，代码复用性高  
- 数位逆序存储简化乘法运算  
- 状态初始化与转移简洁直观  

---

### 核心代码与思路
#### liar_white 的动态规划实现
```cpp
struct node {
    int v; bool exi;
    int c[50]; // 低位在前存储
};
node cut[50][10], ans[50];

node mul(node e1, node e2) { // 高精度乘法
    node emul;
    for (int i=1; i<=e1.v; i++)
        for (int j=1; j<=e2.v; j++)
            emul.c[i+j-1] += e1.c[i] * e2.c[j];
    // 处理进位...
    return emul;
}

int main() {
    for (int i=1; i<=n; i++) {
        cut[i][1] = culc(1,i); // 初始化无乘号情况
        for (int j=2; j<=k; j++) {
            for (int fr=j-1; fr<i; fr++) { // 枚举前驱分割点
                cut[i][j] = Max(cut[i][j], mul(cut[fr][j-1], culc(fr+1,i)));
            }
        }
        ans[i] = mul(cut[i][k], culc(i+1,n)); // 计算最终乘积
    }
}
```

#### FastIO_DP 的结构体实现
```cpp
struct BI {
    int d[100], len;
    BI operator*(const BI& o) { // 重载乘法
        BI res;
        for (int i=0; i<len; i++)
            for (int j=0; j<o.len; j++)
                res.d[i+j] += d[i] * o.d[j];
        // 处理进位...
        return res;
    }
};

BI dp[50][10]; // dp[i][j] 前i位用j个乘号
for (int j=1; j<=K; j++) {
    for (int i=j; i<N; i++) {
        for (int k=j-1; k<i; k++) {
            dp[i][j] = max(dp[i][j], dp[k][j-1] * num(k+1,i));
        }
    }
}
```

---

### 关键技巧总结
1. **数位逆序存储**：简化高精度运算中的进位处理，如 `123` 存为 `[3,2,1]`。
2. **预处理区间值**：预先计算所有可能的子串数值，避免重复切割字符串。
3. **状态转移剪枝**：枚举分割点时，前驱位置只需遍历到 `j-1`，保证乘号数量合法。

---

### 拓展与相似题目
1. **P1435 回文字串**（区间DP与字符串处理）  
2. **P1013 进制位**（高精度与进制转换结合）  
3. **P1045 麦森数**（大数运算与快速幂结合）

---
处理用时：52.43秒
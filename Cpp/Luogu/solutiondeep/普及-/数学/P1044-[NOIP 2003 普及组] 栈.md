# 题目信息

# [NOIP 2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# AI分析结果



### 综合分析与结论
本题本质为卡特兰数经典应用，所有题解围绕以下核心思路展开：
1. **卡特兰数递推公式**：h(n) = Σ(h(i-1)*h(n-i)) ，通过分治思想将问题分解为子序列组合
2. **动态规划**：定义二维状态 f[i][j] 表示栈内元素数i与未处理元素数j的组合情况
3. **组合数优化**：利用卡特兰数通项公式 C(2n,n)/(n+1) 实现O(n)计算

关键优化技巧：
- 记忆化搜索避免重复计算
- 利用递推式 h(n) = h(n-1)*(4n-2)/(n+1) 减少计算量
- 组合数计算时通过交替乘除避免溢出

---

### 精选题解

#### 1. xiejinhao（五星）
**核心亮点**：
- 最全面的解法集合，覆盖递归/递推/组合数/打表四种方法
- 清晰的状态定义：f[i][j]表示队列剩余i个元素、栈内j个元素的情况数
- 给出高精度实现思路，适合大数据场景

**代码片段**（记忆化搜索）：
```cpp
ll dfs(int i,int j) {
    if(f[i][j]) return f[i][j]; 
    if(i==0) return 1;
    if(j>0) f[i][j] += dfs(i,j-1); // 出栈
    f[i][j] += dfs(i-1,j+1);       // 入栈
    return f[i][j];
}
```

#### 2. inexistent（四星半）
**核心亮点**：
- 直观的分治思想解释：首个出栈元素将问题拆分为两个子序列
- 数学推导清晰，揭示卡特兰数本质
- 代码简洁，直接应用递推公式

**关键推导**：
> "当k最后出栈时，前k-1个元素的出栈方式有h(k-1)种，后n-k个元素有h(n-k)种，总方案数为h(k-1)*h(n-k)"

#### 3. Shmily_389704（四星）
**核心亮点**：
- 二维DP状态设计：f[i][j]表示栈内i元素+未处理j元素的组合数
- 边界条件处理清晰，代码可读性强

**状态转移**：
```cpp
for(int j=1;j<=n;j++) {
    for(int i=0;i<=n;i++) {
        if(i==0) f[i][j] = f[i+1][j-1]; // 栈空只能入栈
        else f[i][j] = f[i-1][j] + f[i+1][j-1]; // 出栈或入栈
    }
}
```

---

### 关键思路总结
**最优解法**：使用递推公式 `h(n) = h(n-1)*(4n-2)/(n+1)`，时间复杂度O(n)，空间O(1)
```cpp
long long catalan(int n) {
    long long h = 1;
    for(int i=1; i<=n; ++i) 
        h = h * (4*i-2) / (i+1);
    return h;
}
```

---

### 拓展训练
1. **括号生成**（P22）—— 卡特兰数变形
2. **不同的二叉搜索树 II**（P96）—— 卡特兰数应用
3. **凸多边形划分**（P2767）—— 卡特兰数经典问题

---

### 调试心得摘录
> "直接算组合数会溢出，要交替进行乘除操作" —— 来自组合数实现题解  
> "递归不加记忆化只能过60%数据" —— 记忆化搜索的重要性  
> "n=18时int会溢出，必须用long long" —— 数据类型选择教训

---
处理用时：60.19秒
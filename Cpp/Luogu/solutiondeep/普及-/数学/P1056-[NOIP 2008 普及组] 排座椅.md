# 题目信息

# [NOIP 2008 普及组] 排座椅

## 题目描述

上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 $D$ 对同学上课时会交头接耳。

同学们在教室中坐成了 $M$ 行 $N$ 列，坐在第 $i$ 行第 $j$ 列的同学的位置是 $(i,j)$，为了方便同学们进出，在教室中设置了 $K$ 条横向的通道，$L$ 条纵向的通道。

于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 $2$ 个会交头接耳的同学，那么他们就不会交头接耳了。

请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。


## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/0z0p5x1i.png)

上图中用符号\*、※、+标出了 $3$ 对会交头接耳的学生的位置，图中 $3$ 条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。

2008 年普及组第二题


## 样例 #1

### 输入

```
4 5 1 2 3
4 2 4 3
2 3 3 3
2 5 2 4
```

### 输出

```
2
2 4
```

# AI分析结果



### 综合分析与结论
各题解均采用贪心策略：统计每行/列能隔开的对数，优先选隔开次数最多的通道。核心步骤为：
1. **统计**：遍历输入的D对同学，统计每行/列作为通道时的隔开次数。
2. **排序**：按隔开次数降序排序，取前K/L个通道。
3. **输出**：将选中的通道按位置升序排列输出。
  
关键难点在于正确统计行/列的分隔次数，以及排序时的稳定性处理。所有题解均能正确实现算法，差异主要体现在代码结构和实现细节上。

---

### 高星题解推荐（评分≥4星）

#### 1. chrispang（⭐⭐⭐⭐⭐）
**亮点**：  
- 结构体清晰记录位置与隔开次数。
- 两次排序逻辑明确（先按次数降序选通道，再按位置升序输出）。
- 代码简洁，可读性极佳。

**核心代码**：
```cpp
struct node{ int x, n; }; // x:通道位置，n:隔开次数
sort(x+1, x+1000, cmp1); // 按次数降序
sort(x+1, x+k+1, cmp2); // 按位置升序输出
```

#### 2. qhr2023（⭐⭐⭐⭐）
**亮点**：  
- 利用`pair`简化排序逻辑，代码极简。
- 封装`solve`函数复用排序逻辑，减少冗余。

**核心代码**：
```cpp
void solve(int x, int b[], int num) {
    // 将数组转为pair排序，自动处理位置与次数
    sort(a+1, a+x+1); // 默认按first（次数）升序
    for(int i=x; i>=x-num+1; --i) ans[...] = a[i].second;
}
```

#### 3. Ryan114（⭐⭐⭐⭐）
**亮点**：  
- 使用`vector`动态记录相邻坐标，统计方式直观。
- 代码注释详细，逻辑清晰。

**核心代码**：
```cpp
vector<int> hv, lv; // 记录横向/纵向相邻的坐标
for (auto j : lv) if(i==j) hd[i].cut++; // 统计行通道的隔开次数
```

---

### 最优思路与技巧总结
1. **贪心策略**：优先选择隔开次数最多的行/列。
2. **结构体排序**：通过两次排序（先次数后位置）保证结果正确性。
3. **边界处理**：通道位置取`min(y1, q1)`，确保统计正确。
4. **空间优化**：直接以行/列下标作为索引，避免额外映射。

**关键代码段**：
```cpp
// 输入处理与统计
if (x1 == p1) // 同一行，统计纵向通道
    y[min(y1, q1)].n++; 
else // 同一列，统计横向通道
    x[min(x1, p1)].n++;
```

---

### 拓展与同类题目推荐
1. **P1094 [NOIP2007 普及组] 纪念品分组**  
   **相似点**：贪心策略，排序后双指针选择最优解。

2. **P1223 [NOIP2002 提高组] 排队接水**  
   **相似点**：贪心排序，最小化总等待时间。

3. **P1803 凌乱的yyy / 线段覆盖**  
   **相似点**：区间贪心，选择不重叠的线段最大化数量。

---

### 题解中的个人心得摘录
- **RedContritio**：  
  > "快排是不稳定的，很容易造成ID的混乱。使用冒泡排序虽然复杂度高，但对小数据足够。"  
  **启示**：排序稳定性在特定场景下至关重要。

- **xingshuyan000**：  
  > "重构代码后更易读，原始码风太抽象。"  
  **教训**：代码可读性是长期维护的关键。

---
处理用时：55.00秒
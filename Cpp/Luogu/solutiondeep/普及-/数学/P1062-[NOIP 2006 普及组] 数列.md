# 题目信息

# [NOIP 2006 普及组] 数列

## 题目描述

给定一个正整数 $k$（$3\leq k\leq 15$），把所有 $k$ 的方幂及所有有限个互不相等的 $k$ 的方幂之和构成一个递增的序列，例如，当 $k = 3$ 时，这个序列是：

$1, 3, 4, 9, 10, 12, 13, \ldots$

（该序列实际上就是：$3^0,3^1,3^0+3^1,3^2,3^0+3^2,3^1+3^2,3^0+3^1+3^2,…$）

请你求出这个序列的第 $N$ 项的值，用 $10$ 进制数表示。

例如，对于 $k = 3$，$N = 100$，正确答案应该是 $981$。


## 说明/提示

NOIP 2006 普及组 第四题


## 样例 #1

### 输入

```
3 100```

### 输出

```
981```

# AI分析结果



### 综合分析与结论
本题核心在于发现数列的生成规律：数列中的每个数对应 $N$ 的二进制表示，其每一位代表是否选取对应的 $k$ 的幂次。通过将 $N$ 转换为二进制后按位权展开为 $k$ 进制值，即可高效求解。最优解法时间复杂度为 $O(\log N)$，空间复杂度 $O(1)$。

---

### 精选题解与评分

#### 1. 作者：w1049（★★★★★）
**关键亮点**：
- 巧妙结合快速幂思想，逐位处理二进制位。
- 代码简洁高效，无栈或数组开销。
- 直接通过位运算与累乘计算，避免使用 `pow` 函数。

**核心代码**：
```cpp
int k, n;
long long ans = 0, base = 1;
while (n) {
    if (n & 1) ans += base;
    base *= k;
    n >>= 1;
}
```
**实现思想**：  
每次循环处理二进制最低位，若该位为1则累加当前 $k$ 的幂次，同时通过 `base *= k` 预计算下一个幂次。

---

#### 2. 作者：hongzy（★★★★☆）
**关键亮点**：
- 直观展示二进制与 $k$ 进制转换关系。
- 使用栈处理逆序问题，逻辑清晰。

**核心代码**：
```cpp
stack<int> S;
while (n) S.push(n & 1), n >>= 1;
while (!S.empty()) {
    ans += S.top() * pow(k, S.size() - 1);
    S.pop();
}
```
**实现思想**：  
将 $N$ 的二进制位存入栈中，出栈时按高位到低位顺序计算 $k$ 的幂次。

---

#### 3. 作者：kunkun127（★★★★☆）
**关键亮点**：
- 极简位运算实现，无需额外数据结构。
- 通过循环直接处理二进制位，代码紧凑。

**核心代码**：
```cpp
for (int i = 9; i >= 0; --i) 
    if (n >= (1 << i)) 
        ans += pow(k, i), n -= (1 << i);
```
**实现思想**：  
从高位向低位遍历二进制位，若当前位有效则累加对应的 $k$ 幂次。

---

### 关键思路与技巧
1. **二进制分解与权值展开**：将 $N$ 的二进制位视为 $k$ 进制各位的存在性标志。
2. **快速幂式累乘**：通过 `base *= k` 预计算幂次，避免重复调用 `pow`。
3. **位运算优化**：使用 `n & 1` 和 `n >>= 1` 快速提取二进制位。

---

### 拓展与同类题目
1. **快速幂模板**：[P1226 快速幂](https://www.luogu.com.cn/problem/P1226)
2. **进制转换综合**：[B3619 10 进制转 x 进制](https://www.luogu.com.cn/problem/B3619)
3. **位运算组合问题**：[P1582 倒水](https://www.luogu.com.cn/problem/P1582)

---

### 个人心得摘录
- **w1049**：“跟快速幂只有这里不一样”——通过类比快速幂结构，仅修改累加逻辑即可解题。
- **tobie**：“分成九段去枚举”——尝试分组生成数列，虽非最优解，但展示了分治思想的探索过程。
- **superLouis**：“必须开 long long”——强调数据范围的重要性，避免溢出陷阱。

---
处理用时：50.77秒
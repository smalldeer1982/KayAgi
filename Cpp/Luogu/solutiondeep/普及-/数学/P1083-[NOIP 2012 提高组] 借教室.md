# 题目信息

# [NOIP 2012 提高组] 借教室

## 题目描述

在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。

面对海量租借教室的信息，我们自然希望编程解决这个问题。

我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。

我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。

借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。

现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。


## 说明/提示

【输入输出样例说明】

第 $1 $份订单满足后，$4 $天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2 $天到第 $4$ 天每天提供 $3$ 个教室，而第 $3$ 天剩余的教室数为$ 2$，因此无法满足。分配停止，通知第 $2$ 个申请人修改订单。

【数据范围】

对于 $10\%$ 的数据，有 $1\le n,m\le 10$；

对于 $30\%$ 的数据，有 $1\le n,m\le 1000$；

对于 $70\%$ 的数据，有 $1 \le n,m \le 10^5$；

对于 $100\%$ 的数据，有 $1 \le n,m \le 10^6$，$0 \le r_i,d_j\le 10^9$，$1 \le s_j\le t_j\le n$。


NOIP 2012 提高组 第二天 第二题

2022.2.20 新增一组 hack 数据

## 样例 #1

### 输入

```
4 3 
2 5 4 3 
2 1 3 
3 2 4 
4 2 4```

### 输出

```
-1 
2```

# AI分析结果



### 综合分析与结论
本题核心在于高效处理区间修改与验证订单可行性，主流解法为二分答案配合差分数组优化。二分利用订单处理的单调性，差分数组以O(1)完成区间操作，总时间复杂度为O((n+m)log m)。线段树解法虽正确但常数较大，其他优化方法（如倍增、树状数组）实现复杂度较高。

### 高星题解推荐
1. **皎月半洒花（★★★★★）**  
   **关键亮点**：  
   - 清晰阐述二分+差分思想，代码简洁高效  
   - 深入解释差分与前缀和的关系，强调单调性判定依据  
   **核心代码**：  
   ```cpp
   bool isok(int x) {
       memset(diff,0,sizeof(diff));
       for(int i=1;i<=x;i++) { // 差分处理订单
           diff[l[i]] += d[i];
           diff[r[i]+1] -= d[i];
       }
       for(int i=1;i<=n;i++) { // 前缀和计算
           need[i] = need[i-1] + diff[i];
           if(need[i] > rest[i]) return 0;
       }
       return 1;
   }
   ```

2. **WsW_（★★★★☆）**  
   **关键亮点**：  
   - 代码结构更紧凑，使用STL简化实现  
   - 通过`pair`存储区间端点提升可读性  
   **核心代码**：  
   ```cpp
   bool check(int x) {
       memset(c,0,sizeof(c));
       for(int i=1;i<=x;i++) { // 差分操作
           c[a[i].first] += d[i];
           c[a[i].second+1] -= d[i];
       }
       for(int i=1;i<=n;i++) { // 验证可行性
           c[i] += c[i-1];
           if(c[i] > r[i]) return false;
       }
       return true;
   }
   ```

3. **清远学会（★★★★☆）**  
   **关键亮点**：  
   - 详细对比线段树与差分方案的优劣  
   - 提供完整的调试思路与复杂度分析  
   **核心代码**：  
   ```cpp
   bool chk(int x) {
       memset(dif,0,sizeof(dif));
       for(int i=1;i<=x;i++) { // 差分处理
           dif[s[i]] += d[i];
           dif[t[i]+1] -= d[i];
       }
       long long sum=0;
       for(int i=1;i<=n;i++) { // 前缀和验证
           sum += dif[i];
           if(sum > r[i]) return false;
       }
       return true;
   }
   ```

### 关键技巧总结
- **二分答案框架**：利用订单处理的单调性，将问题转化为判定性查询  
- **差分数组优化**：将区间修改转化为端点操作，O(1)时间完成修改，O(n)时间验证  
- **避免负数运算**：直接比较需求与资源，减少溢出风险（如皎月代码中的`need[i] > rest[i]`）

### 拓展建议
1. **同类题目推荐**  
   - [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)（差分应用）  
   - [P4552 IncDec Sequence](https://www.luogu.com.cn/problem/P4552)（差分性质分析）  
   - [P4344 [SHOI2015]脑洞治疗仪](https://www.luogu.com.cn/problem/P4344)（二分+线段树综合）

2. **调试心得摘录**  
   - *"线段树的lazy标记必须存储实际增减值而非0/1状态"*（LeavingZzz）  
   - *"逆向回退订单时需注意边界条件，否则可能导致死循环"*（WAMonster）  
   - *"差分数组初始化需完全清空，避免残留数据影响"*（_Bluehole）

---
处理用时：55.57秒
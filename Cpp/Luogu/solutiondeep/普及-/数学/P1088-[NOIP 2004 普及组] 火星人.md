# 题目信息

# [NOIP 2004 普及组] 火星人

## 题目描述

人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。

火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。

一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：


| 三进制数 | 代表的数字 |
|:-:|:-:|
| $123$ | $1$ |
| $132$ | $2$ |
| $213$ | $3$ |
| $231$ | $4$ |
| $312$ | $5$ |
| $321$ | $6$ |

现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。


## 说明/提示

对于 $30\%$ 的数据，$N \le 15$。

对于 $60\%$ 的数据，$N \le 50$。

对于 $100\%$ 的数据，$N \le 10000$。

noip2004 普及组第 4 题


## 样例 #1

### 输入

```
5
3
1 2 3 4 5
```

### 输出

```
1 2 4 5 3```

# AI分析结果



### 综合分析与结论
本题核心是求给定排列的第m个后续排列。题解主要分为四类思路：STL函数调用、手动实现排列生成、变进制数映射、DFS剪枝搜索。其中变进制数法（康托展开）在时间效率上最优（O(n)），手动实现排列生成最易理解，STL解法最简洁但隐藏实现细节。

---

### 高分题解推荐（≥4星）

#### 1. 作者：yummy（★★★★★）
**关键亮点**  
- 创新使用变进制数思想，将排列映射为整数运算，实现O(n)时间复杂度  
- 结合康托展开与逆展开，处理进位逻辑清晰  
- 代码简洁（37行）且适合大规模数据（n≤1e4）

**核心代码思想**  
```cpp
// 将排列转换为变进制数
for(int i=1; i<=n; i++) {
    int x = a[i];
    for(int j=1; j<=a[i]; j++) x -= used[j];
    a[i] = x-1; // 转换为从0开始的变进制数
}
// 变进制数加法进位处理
a[n] += m;
for(int i=n; i>0; i--) {
    a[i-1] += a[i]/(n-i+1);
    a[i] %= (n-i+1);
}
// 逆映射回排列
memset(used,0,sizeof(used));
for(int i=1; i<=n; i++) {
    for(int j=0; j<=a[i]; j++) if(used[j]) a[i]++;
    used[a[i]] = 1;
}
```

#### 2. 作者：FP·荷兰猪（★★★★☆）
**关键亮点**  
- 清晰演示next_permutation的手动实现逻辑  
- 使用双指针法进行子序列反转优化排序步骤  
- 代码可读性强，适合学习排列生成原理  

**核心算法步骤**  
1. 从右找第一个升序位置j  
2. 在j右侧找最小大于j的值交换  
3. 反转j+1到末尾的子序列  

**完整实现**  
```cpp
void work() {
    for(int i=1; i<=m; i++) {
        int j = n-1;
        while(b[j] > b[j+1]) j--; // Step 1
        int k = n;
        while(b[k] < b[j]) k--;   // Step 2
        swap(b[j], b[k]);         // 交换
        reverse(b+j+1, b+n+1);    // Step 3（通过双指针反转）
    }
}
```

#### 3. 作者：zhi_zhang（★★★★☆）
**关键亮点**  
- 模拟人脑递增思维，通过动态维护可用数字集合  
- 使用树状数组优化未使用数字的查找过程  
- 代码包含详细调试输出，适合理解过程  

**调试心得摘录**  
> "在交换位置后忘记标记更新，导致后续选择错误。通过添加`vis[finger[i]]=0`修复了该问题，意识到状态维护的完整性是关键。"

---

### 关键思路总结
1. **变进制映射法**：将排列视为变进制数（每位进制为n-i），通过数学运算代替排列枚举，时间复杂度最优  
2. **双指针反转法**：手动实现排列生成时，利用反转代替排序，将O(n logn)步骤优化为O(n)  
3. **状态压缩技巧**：使用位掩码或数组标记已选数字，快速计算剩余可选元素  

### 拓展练习推荐
1. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706) - 全排列基础练习  
2. [P3014 [USACO11FEB]Cow Line S](https://www.luogu.com.cn/problem/P3014) - 康托展开与逆展开应用  
3. [P2525 Uim的情人节礼物·其之壱](https://www.luogu.com.cn/problem/P2525) - 排列顺序与STL函数实战

---
处理用时：52.60秒
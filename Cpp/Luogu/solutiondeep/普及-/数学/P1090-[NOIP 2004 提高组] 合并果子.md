# 题目信息

# [NOIP 2004 提高组] 合并果子

## 题目描述

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $=3+12=15$ 。可以证明 $15$ 为最小的体力耗费值。

## 说明/提示

对于 $30\%$ 的数据，保证有 $n \le 1000$：

对于 $50\%$ 的数据，保证有 $n \le 5000$；

对于全部的数据，保证有 $n \le 10000$。


## 样例 #1

### 输入

```
3 
1 2 9 
```

### 输出

```
15
```

# AI分析结果



### 综合分析与结论
本题是经典贪心问题，核心思路是每次合并最小的两堆果子（哈夫曼树模型）。各题解围绕该核心展开，主要差异体现在数据结构的实现方式与时间复杂度优化。最优解法为桶排序预处理 + 双队列合并的O(n)算法，其次为优先队列的标准实现（O(n logn)）。正确性证明需结合哈夫曼树性质。

---

### 高星题解推荐

#### 1. QuantAsk（★★★★★）
**关键亮点**：  
- 桶排序预处理实现O(n)输入排序  
- 双队列合并策略（原始队列+合成队列）实现线性时间复杂度  
- 严格符合数据范围特点（ai≤20000）的离散化处理  

**代码核心**：
```cpp
// 桶排序预处理
for (int i=1;i<=num;i++) { scanf("%d",&x); t[x]++; }
for (int i=1;i<=20000;i++) while (t[i]) a1[++n1]=i;

// 双队列合并
while (k<num) {
    if (a1[i]<a2[j]) w = a1[i++]; // 取最小值
    else w = a2[j++];
    // 取次小值同理...
    a2[++n2] = w; // 加入合成队列
}
```

#### 2. 学委（★★★★☆）
**关键亮点**：  
- 详细讨论贪心策略的正确性证明  
- 结合哈夫曼树模型进行理论分析  
- 标准优先队列实现简洁易懂  

**核心代码**：
```cpp
priority_queue<int, vector<int>, greater<int>> q;
while(q.size() > 1) {
    int x = q.top(); q.pop();
    int y = q.top(); q.pop();
    ans += x + y;
    q.push(x + y);
}
```

#### 3. 微雨燕双飞（★★★★☆）
**关键亮点**：  
- 完整手写堆实现教学  
- 清晰的堆操作函数（up/down）  
- 适合理解堆底层原理  

**堆操作实现**：
```cpp
void down(int p) { // 向下调整
    int s = p*2;
    while(s <= size) {
        if(s < size && heap[s+1]<heap[s]) s++;
        if(heap[s]<heap[p]) swap(heap[s], heap[p]);
        else break;
    }
}
```

---

### 关键技巧总结
1. **桶排序优化**：当数值范围有限时（如本题ai≤2e4），用桶排序替代快速排序可达到O(n)复杂度  
2. **双队列贪心**：维护原始队列与合并队列，利用两者的单调性避免重复排序  
3. **堆实现选择**：优先队列适合快速实现，手写堆可优化常数时间，双队列法最优但需特定条件  
4. **正确性证明**：通过哈夫曼树模型理解合并顺序的数学本质  

---

### 同类题目推荐
1. [P1334 瑞瑞的木板](https://www.luogu.com.cn/problem/P1334)（同题换皮）  
2. [P2168 [NOI2015] 荷马史诗](https://www.luogu.com.cn/problem/P2168)（k叉哈夫曼树）  
3. [P2449 [SDOI2005] 矩形](https://www.luogu.com.cn/problem/P2449)（贪心策略变形）  

---

### 个人心得摘录
1. **学委题解**提到："最小的两堆一定在最优方案树的最深层" → 用反证法强化贪心策略理解  
2. **sigland题解**调试经验：封装版堆（40ms）与拆封版（20ms）对比 → 指针访问比vector快  
3. **aaalys题解**反例分析：先合并大数的错误策略 → 通过具体数值验证策略正确性

---
处理用时：49.27秒
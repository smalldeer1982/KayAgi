# 题目信息

# 高低位交换

## 题目描述

给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。

例如，数 $1314520$ 用二进制表示为 $0000\,0000\,0001\,0100\,0000\,1110\,1101\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\,0000\,0001\,0100$；后 $16$ 位为低位，即 $0000\,1110\,1101\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\,1110\,1101\,1000\,0000\,0000\,0001\,0100$。它即是十进制的 $249036820$。


## 样例 #1

### 输入

```
1314520
```

### 输出

```
249036820
```

# AI分析结果



### 综合分析与结论
本题核心在于高效交换32位无符号整数的高16位与低16位。最优解法均基于位运算，通过掩码提取或移位操作直接完成交换，时间复杂度O(1)。模拟法（如二进制转换重组）效率较低但易于理解，而特定语言特性（如Pascal的swap）缺乏普适性。

---

### 高星题解推荐
#### 1. HenryHuang（5星）
**关键亮点**：  
- 使用掩码精准提取高低位（`0x0000ffff`和`0xffff0000`），确保运算正确性。  
- 位运算组合（`<<`和`>>`）直观体现交换逻辑，代码自解释性强。  
**核心代码**：  
```cpp
cout << ((x&0x0000ffff)<<16 | (x&0xffff0000)>>16);
```
**个人心得**：  
> "多余的位数会自动溢出，掩码确保万无一失。"

#### 2. 月影困（5星）
**关键亮点**：  
- 极简代码（仅一行核心逻辑），利用无符号数的溢出特性。  
- 右移获取高位，左移获取低位，直接相加完成交换。  
**核心代码**：  
```cpp
printf("%u\n", (n >> 16) + (n << 16));
```
**注意事项**：  
> "注意运算符优先级，移位需加括号。"

#### 3. 离散小波变换°（4星）
**关键亮点**：  
- 提供两种等价实现，对比不同位运算思路。  
- 详细分析无符号数的溢出机制，增强理解。  
**核心代码**：  
```cpp
// 解法1：直接移位相加
cout << (n>>16) + (n<<16);
// 解法2：掩码提取后移位
cout << ((n&0xffff0000)>>16) + ((n&0x0000ffff)<<16);
```

---

### 最优关键思路
**位运算组合**：  
1. **掩码提取**：用`&`操作分离高/低位（如`0xffff0000`提取高位）。  
2. **移位合并**：将低位左移16位至高16区，高位右移16位至低16区，通过`+`或`|`合并。  
3. **溢出特性**：利用无符号数溢出自动取模的特性，省略显式截断。  

---

### 拓展与举一反三
**同类问题**：  
- 交换任意长度的位段（如高8位与低24位）。  
- 循环移位或更复杂的位重组（如奇偶位交换）。  

**推荐题目**：  
1. [P1904 交换奇偶位](https://www.luogu.com.cn/problem/P1904)  
2. [P1017 进制转换（负进制处理）](https://www.luogu.com.cn/problem/P1017)  
3. [P1226 快速幂（位运算优化）](https://www.luogu.com.cn/problem/P1226)

---
处理用时：65.30秒
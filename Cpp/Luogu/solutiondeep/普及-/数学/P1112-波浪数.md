# 题目信息

# 波浪数

## 题目描述

波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。

类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $2\le l\le r\le 32$，$1\le L\le R\le 10^7$，$k\in \{2, 3, 4\}$。

## 样例 #1

### 输入

```
10 11 190000 960000 2```

### 输出

```
191919
383838
575757
767676
959595```

# AI分析结果



### 综合分析与结论
各题解核心思路均为逆向构造波浪数而非逐个判断，通过枚举进制+交替数字组合生成波浪数并计数。关键优化点在于避免对每个数进行多次进制判断，时间复杂度从 O(R*K) 优化至 O(进制数*数字组合数)，显著提升效率。

---

### 高星题解推荐

#### 1. Crazily（5星）
**核心亮点**：  
- 逆向生成所有可能的波浪数，利用桶计数统计重数  
- 处理了交替构造中的奇偶位逻辑  
- 代码简洁，循环边界清晰  
**个人心得**：考后反思逆向思维的重要性，避免逐个进制转换的低效思路

**核心代码**：
```cpp
for(int k=a;k<=b;++k){ // 枚举进制
    for(int i=1;i<k;++i){ // 交替数1
        for(int j=0;j<k;++j){ // 交替数2
            if(i!=j){
                x=0; t=0;
                while(x<=r){ // 构造波浪数
                    x = x*k + (t%2 ? j : i);
                    if(x在[l,r]) v[x]++;
                }
            }
        }
    }
}
```

#### 2. Skywalker_David（4星）
**核心亮点**：  
- 计算数位长度范围优化构造次数  
- 独立函数处理构造过程，可读性高  
- 使用短整型数组节省内存  

**关键优化**：
```cpp
int make(int a, int b, int len, int k) { // 交替构造len位数
    int x = 0;
    for(int i=1; i<=len; i++)
        x = x*k + (i%2 ? a : b);
    return x;
}
```

#### 3. Qwdb（4星）
**核心亮点**：  
- 详细注释与变量命名，易理解  
- 处理了单数位波浪数的情况  
- 循环条件清晰，包含完整构造过程  

---

### 关键思路与技巧
1. **逆向构造法**：枚举进制→交替数字对→生成波浪数，避免逐个判断  
2. **交替生成器**：通过奇偶位切换生成交替数，如 `t%2 ? j : i`  
3. **桶计数优化**：用数组直接记录每个数的波浪重数，O(1)查询  
4. **进制边界处理**：通过计算最大位数限制构造次数（如 `Len()`函数）

---

### 同类题目推荐
1. P1062 [数列] - 进制规律数列构造  
2. P1143 [进制转换] - 多进制数处理  
3. P1057 [数位之和] - 数位分解与特征统计  

---

### 调试经验摘录
1. **Crazily**："考试时陷入逐个判断的思维定式，后意识到构造法更高效" → 逆向思维突破  
2. **黄琪2019**："b数组越界导致RE，需先判断再写入" → 注意循环终止条件  
3. **小越越**："忘记处理单数位情况，WA多次后补全逻辑" → 边界测试的重要性

---
处理用时：43.02秒
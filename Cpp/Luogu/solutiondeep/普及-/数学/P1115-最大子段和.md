# 题目信息

# 最大子段和

## 题目描述

给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。


## 说明/提示

#### 样例 1 解释

选取 $[3, 5]$ 子段 $\{3, -1, 2\}$，其和为 $4$。

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。


## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
本题核心在于O(n)时间复杂度的动态规划/贪心解法，最优解的关键在于维护当前子段和并及时取舍。分治、线段树等方法虽能解但复杂度偏高，模拟退火等非常规方法不具备普适性。以下精选高质量题解：

---

### 精选题解

#### 1. _Arahc_（5星）
**关键亮点**  
- 动态规划思路清晰，状态定义明确（dp[i]表示以i结尾的最大子段和）  
- 空间优化到O(1)（滚动数组思想）  
- 代码简洁高效，附带详细样例推导  
**核心代码**  
```cpp
int n, a, b, ans = -2147483647;
cin >> n;
for (i=1; i<=n; i++) {
    cin >> a;
    if (i==1) b = a;
    else b = max(a, b + a);
    ans = max(ans, b);
}
```

#### 2. Robert（4星）
**关键亮点**  
- 贪心策略直观，维护当前子段和  
- 处理全负数特判逻辑完备  
- 代码极简（仅8行）  
**核心代码**  
```cpp
int n, j, sum, maxx;
scanf("%d%d", &n, &maxx);
sum = maxx;
while (--n) {
    scanf("%d", &j);
    sum = sum > 0 ? sum : 0;
    sum += j;
    maxx = max(maxx, sum);
}
```

#### 3. 林则徐（4星）
**关键亮点**  
- 分治思想完整展示，适合理解算法扩展性  
- 详细拆分三种情况（左半、右半、跨越中点）  
**核心代码**  
```cpp
int rec(int l, int r) {
    if (l == r) return a[l];
    int mid = (l + r) >> 1;
    int left = rec(l, mid), right = rec(mid+1, r);
    int sum = 0, lmax = a[mid], rmax = a[mid+1];
    for (int i=mid; i>=l; i--) lmax = max(lmax, sum += a[i]);
    sum = 0;
    for (int i=mid+1; i<=r; i++) rmax = max(rmax, sum += a[i]);
    return max(max(left, right), lmax + rmax);
}
```

---

### 关键技巧总结
1. **动态规划状态压缩**：用单个变量代替数组实现空间优化（如_Arahc_的`b`变量）
2. **贪心剪枝**：当子段和为负时及时重置（如Robert的`sum=sum>0?sum:0`）
3. **分治合并策略**：计算跨中点情况时从中间向两侧扩展（如林则徐的双向遍历）

---

### 推荐习题
1. **环形子段和**（[P1121 环状最大子段和](https://www.luogu.com.cn/problem/P1121)）  
2. **带长度限制的最大子段和**（[P1714 切蛋糕](https://www.luogu.com.cn/problem/P1714)）  
3. **多维最大子矩阵**（[P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)）

---
处理用时：57.27秒
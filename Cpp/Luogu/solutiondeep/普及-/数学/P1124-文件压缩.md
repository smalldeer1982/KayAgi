# 题目信息

# 文件压缩

## 题目背景

提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。


## 题目描述

该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。

举例：$S$ 是 `example`

1. 构造 $n$ 个字符串。

```plain
example
xamplee
ampleex
mpleexa
pleexam
leexamp
eexampl
```

2. 将字符串排序。

```plain
ampleex
example
eexampl
leexamp
mpleexa
pleexam
xamplee
```
3. 压缩结果。

$S' = \texttt{xelpame}$，$p = 7$

由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。

请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。

保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。

## 样例 #1

### 输入

```
7
xelpame
7
```

### 输出

```
example
```

# AI分析结果



### 综合分析与结论
题目要求逆向推导循环位移排序后的字符串压缩结果。各题解核心思路均围绕"排序后的首字母序列与压缩字符串的尾字母序列构成环形映射关系"展开，通过倒序推导避免重复匹配问题。关键技巧在于：排序后的首字母序列与压缩字符串构成首尾对应关系，逆向追踪每次匹配后标记已用位置，最终倒序输出。

---

### 精选题解列表

#### 1. 作者：MC_Launcher（★★★★★）
**核心亮点**：
- 首创倒序构建思想，直观解释首尾字母环状关系
- 代码简洁高效，通过标记已选字符避免重复
- 包含调试教训（正序错误→倒序正确）

**个人心得**：
> "第一次正着排就才10分，所以我们要倒着找，最后反着输出。如果不理解，可以输出中间变量，然后也就懂了"

**核心代码**：
```cpp
sort(b, b+n); // 首字母序列排序
// 逆向构建ans数组
for(int j=n-1;j>=0;j--) { 
    if(b[j]==a[now]) {
        now=j;
        ans[i]=a[now];
        b[j]=')'; // 标记已选
        break;
    }
}
```

#### 2. 作者：liuzhaoxu（★★★★☆）
**核心亮点**：
- 详细论证正序/倒序差异，给出反例解释
- 引入位置标记数组解决冲突
- 代码实现清晰的逆向推导流程

**关键解释**：
> "正序推需要在无序的S'中找字符，倒序推则在有序的排序序列中找，避免错位"

**核心逻辑**：
```cpp
while(cnt>1) {
    ans[--cnt] = s[p]; 
    ss[p] = '#'; // 标记已用
    for(int i=n;i>=1;--i) // 逆向搜索有序序列
        if(ss[i]==s[p]) { p=i; break; }
}
```

#### 3. 作者：Cat_cc（★★★★☆）
**核心亮点**：
- 利用字母频率构建左右边界数组
- 通过左右指针快速定位字符
- 时间复杂度优化至O(n)

**创新思路**：
```cpp
// 预处理字母区间
for(int i=0;i<26;i++) {
    l[i] = r[i-1]+1;
    r[i] = l[i] + a[i]-1;
}
// 快速定位字符
now = l[s[p]-'a'];
while(tot<n) {
    ans[tot] = s[now];
    now = r[s[now]-'a']--; // 右边界递减
}
```

---

### 最优关键思路总结
1. **首尾映射构建**：将S'排序得到首字母序列，与S'本身构成首-尾字符对
2. **逆向推导**：从p位置出发，每次在有序首字母序列中从后往前匹配当前字符
3. **标记防重**：每次匹配后修改对应位置状态，避免重复选择
4. **环状输出**：倒序存储推导结果，正序输出即为原字符串

---

### 拓展建议
1. **同类问题**：Burrows-Wheeler变换逆过程（本题原型）、循环字符串重构
2. **思维训练**：当正向推导出现状态冲突时，可尝试逆向推导策略
3. **代码优化**：预处理字符分布区间可大幅提升重复字符处理效率

---

### 推荐习题
1. [P1119 压缩技术](https://www.luogu.com.cn/problem/P1119) - 字符串压缩算法基础
2. [P2287 最佳包裹](https://www.luogu.com.cn/problem/P2287) - 循环字符串处理
3. [P1068 分数线划定](https://www.luogu.com.cn/problem/P1068) - 多条件排序与位置映射

---
处理用时：65.81秒
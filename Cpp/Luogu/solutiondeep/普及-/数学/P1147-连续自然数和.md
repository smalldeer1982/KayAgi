# 题目信息

# 连续自然数和

## 题目描述

对一个给定的正整数 $M$，求出所有的连续的正整数段（每一段至少有两个数），这些连续的自然数段中的全部数之和为 $M$。

例子：$1998+1999+2000+2001+2002 = 10000$，所以从 $1998$ 到 $2002$ 的一个自然数段为 $M=10000$ 的一个解。


## 样例 #1

### 输入

```
10000
```

### 输出

```
18 142 
297 328 
388 412 
1998 2002
```

# AI分析结果



### 综合分析与结论
本题核心在于利用数学特性优化枚举过程。主流通解分为两类：
1. **数学分解法**：基于等差数列公式推导，将问题转化为因数分解，时间复杂度 $O(\sqrt{M})$，理论最优解。
2. **双指针法（尺取法）**：通过动态调整区间边界寻找解，时间复杂度 $O(M)$，代码简洁直观。
其他解法（暴力枚举、前缀和+二分等）在大数据下效率较低或实现复杂。

---

### 精选题解与评分

#### 1. 作者：gzw2005（★★★★★）
**核心思路**：  
将等差数列和公式转化为 $(L+R)(R-L+1)=2M$，枚举 $2M$ 的因数对 $(k_1,k_2)$，要求一奇一偶以得到整数解。  
**关键技巧**：  
- 因数分解后通过奇偶性快速判断解的合法性  
- 逆向枚举因数减少无效计算  

```cpp
for(int k1=sqrt(2*m);k1>1;k1--)
    if(2*m%k1==0 && (k1+2*m/k1)%2){
        int k2=2*m/k1;
        cout<<(k2-k1+1)/2<<" "<<(k1+k2-1)/2<<endl;
    }
```

#### 2. 作者：Frenix（★★★★★）
**核心思路**：  
用双指针维护滑动窗口，动态调整区间和。当和不足时右移右指针，超过时右移左指针。  
**优化点**：  
- 单调性保证 $O(M)$ 时间复杂度  
- 边界处理简洁，无需复杂公式推导  

```cpp
for(int i=1,j=2; i<=m/2; ){
    if(sum==m) printf("%d %d\n",i,j);
    else if(sum<m) j++, sum+=j;
    else sum-=i, i++;
}
```

#### 3. 作者：lamboo（★★★★☆）
**核心思路**：  
通过解一元二次方程直接计算末项，判断是否为整数解。  
**亮点**：  
- 直接数学推导避免枚举  
- 注意处理浮点精度问题  

```cpp
double delta = sqrt(1 + 4*(2*m + l*l - l));
if(delta == (int)delta) {
    int r = (-1 + delta)/2;
    if(r > l) cout<<l<<" "<<r<<endl;
}
```

---

### 关键优化总结
1. **因数分解奇偶性**：将问题转化为奇偶因数对判定，避免无效枚举。
2. **滑动窗口求和**：利用连续区间和的单调性，线性时间复杂度求解。
3. **数学公式变形**：通过等差数列公式或求根公式直接计算解，减少循环次数。

---

### 拓展练习
1. [P1214 等差数列](https://www.luogu.com.cn/problem/P1214)（数学推导）
2. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102)（双指针/哈希）
3. [P1638 连续自然数的平方和](https://www.luogu.com.cn/problem/P1638)（数学+枚举优化）

---
处理用时：53.83秒
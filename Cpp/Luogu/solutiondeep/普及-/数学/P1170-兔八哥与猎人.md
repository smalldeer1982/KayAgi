# 题目信息

# 兔八哥与猎人

## 题目描述

兔八哥躲藏在树林旁边的果园里。果园有 $M  \times  N$ 棵树，组成一个 $M$ 行 $N$ 列的矩阵，水平或垂直相邻的两棵树的距离为 $1$。兔八哥在一棵果树下。

猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。

如果猎人与兔八哥位置的连线上没有其它的果树，猎人就可以看到兔八哥。

现己知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全。

## 说明/提示

$1\le n \le 10^5$，$1 \le  a_x, a_y, b_x, b_y \le  10^8$。

## 样例 #1

### 输入

```
1
1 1
1 2```

### 输出

```
no```

# AI分析结果



### 综合分析与结论
本题核心是判断两点连线是否存在其他整点，等价于两坐标差的绝对值是否互质。所有题解均围绕最大公约数（GCD）展开，正确解法为：若两点横纵坐标差的GCD为1，则无遮挡（不安全）；反之安全。

---

### 精选题解（评分≥4星）

#### 1. 作者：beng（★★★★☆）
**关键亮点**：  
- 通过图示直观解释问题，强调最初思路误区（只考虑周围8格）  
- 用数学反证法推导出互质条件，逻辑清晰  
- 提供不同坐标下的示例验证结论  

**代码核心**：  
```pascal
function go(x,y:longint):longint; // 辗转相除求GCD
begin
  if y=0 then exit(x) else go:=go(y,x mod y);
end;
// 主逻辑：若GCD(abs(x1-x2),abs(y1-y2))=1则输出no
```

#### 2. 作者：修罗海神王（★★★★☆）
**关键亮点**：  
- 代码结构简洁规范，适合C++初学者学习  
- 明确说明互质与GCD的关系  
- 函数命名与变量名清晰，可读性强  

**核心代码**：  
```cpp
int gcd(int x,int y){
    return y?gcd(y,x%y):x; // 递归实现
}
// 主逻辑：读入坐标差，调用gcd判断输出
```

#### 3. 作者：UnyieldingTrilobite（★★★★☆）
**关键亮点**：  
- 利用STL的`__gcd`函数实现极简代码（仅6行）  
- 数学推导简洁，直指斜率与整数点关系  
- 适合竞赛快速编码场景  

**核心代码**：  
```cpp
#include<bits/stdc++.h>
main(){
    int T,a,b,c,d;
    std::cin>>T;
    while(std::cin>>a>>b>>c>>d)
        puts(abs(std::__gcd(a-c,b-d))>1?"yes":"no");
}
```

---

### 关键思路与技巧总结
**核心定理**：  
两点$(x_1,y_1)$与$(x_2,y_2)$间存在其他整点 ⇨ $\gcd(|x_1-x_2|,|y_1-y_2|) > 1$

**实现要点**：  
1. **绝对值处理**：计算坐标差时取绝对值  
2. **GCD优化**：使用STL的`__gcd`或手写辗转相除法  
3. **特例处理**：坐标差为0时需单独处理（但根据定理，$\gcd(0,n)=n$自动兼容）

---

### 拓展与举一反三
**同类问题推荐**：  
1. [P2158 仪仗队](https://www.luogu.com.cn/problem/P2158)（欧拉函数与GCD结合）  
2. [P1888 三角函数](https://www.luogu.com.cn/problem/P1888)（最简分数与GCD关系）  
3. [P1029 最大公约数与最小公倍数](https://www.luogu.com.cn/problem/P1029)（GCD性质应用）

**调试经验摘录**：  
- "第一眼看成只判断周围8格子...实际需数学推导"（多题解提到）  
- "cin读入大数据会超时，需改用scanf或关闭同步"（作者YCIrving）  
- "坐标差为0时gcd返回错误值，需用绝对值"（作者hsfzLZH1）

---

### 核心代码片段
**最终推荐实现（结合简洁与可读性）**：  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int T, ax, ay, bx, by;
    cin >> T;
    while(T--) {
        cin >> ax >> ay >> bx >> by;
        int dx = abs(ax - bx), dy = abs(ay - by);
        cout << (__gcd(dx, dy) == 1 ? "no" : "yes") << endl;
    }
    return 0;
}
```

---
处理用时：52.15秒
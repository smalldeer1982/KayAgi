# 题目信息

# 打砖块

## 题目描述

小红很喜欢玩一个叫打砖块的游戏，这个游戏的规则如下：

在刚开始的时候，有 $n$ 行 $m$ 列的砖块，小红有 $k$ 发子弹。小红每次可以用一发子弹，打碎某一列当前处于这一列最下面的那块砖，并且得到相应的得分。（如图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/twgirdp6.png)

某些砖块在打碎以后，还可能将得到一发子弹的奖励。最后当所有的砖块都打碎了，或者小红没有子弹了，游戏结束。

小红在游戏开始之前，就已经知道每一块砖在打碎以后的得分，并且知道能不能得到一发奖励的子弹。小红想知道在这次游戏中她可能的最大得分，可是这个问题对于她来说太难了，你能帮帮她吗？


## 说明/提示

对于 $20\%$ 的数据，满足 $1  \le n,m  \le 5$，$1  \le k  \le 10$，所有的字符 $c$ 都为 `N`。

对于 $50\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，所有的字符 $c$ 都为 `N`。

对于 $100\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，字符 $c$ 可能为 `Y`。

对于 $100\%$ 的数据，所有的 $f$ 值满足 $1  \le f  \le 10000$。


## 样例 #1

### 输入

```
3 4 2
9 N 5 N 1 N 8 N
5 N 5 Y 5 N 5 N
6 N 2 N 4 N 3 N```

### 输出

```
13```

# AI分析结果



### 综合分析与结论
本题核心难点在于处理子弹奖励带来的后效性，所有题解均采用动态规划+预处理的思路。关键技巧包括：  
1. **列预处理**：将每列连续`Y`砖块压缩到下方`N`砖块中，统计不同子弹数下的得分（区分最后一发是否打在`N`上）。  
2. **状态设计**：通过附加维度（如`dp[i][j][0/1]`）记录最后一发子弹的位置或是否借子弹，解决子弹资源动态变化问题。  
3. **分组背包思想**：每列视为一组，决策子弹分配并处理状态转移。

---

### 高星题解推荐（评分≥4星）

#### 1. 作者：Azuree（★★★★★）  
**关键亮点**：  
- 清晰定义`v[i][j][0/1]`表示第i列用j发子弹时最后一发是否为`N`，状态设计直观。  
- 给出完整状态转移逻辑：`f[i][j][0/1]`区分最后一发是否在前i列，完美解决子弹借用问题。  
- 代码注释详细，可读性强。  

**核心代码**：  
```cpp
for(int i = 1; i <= m; i++)
    for(int j = 0; j <= k; j++)
        for(int l = 0; l <= min(n,j); l++) {
            f[i][j][1] = max(f[i][j][1], f[i-1][j-l][1] + v[i][l][1]);
            if(l) f[i][j][0] = max(f[i][j][0], f[i-1][j-l][1] + v[i][l][0]);
            if(j > l) f[i][j][0] = max(f[i][j][0], f[i-1][j-l][0] + v[i][l][1]);
        }
```

#### 2. 作者：I_AM_HelloWord（★★★★☆）  
**关键亮点**：  
- 提出“借子弹”概念，通过`dp[j][k][0/1]`状态明确区分是否借出子弹。  
- 预处理`sum1/sum2`数组分别表示压缩后的得分，逻辑简洁。  
- 状态转移方程覆盖所有可能情况，思维严密。  

**核心思路**：  
```cpp
// 预处理每个列的得分与子弹消耗
for(int j=1;j<=m;j++) {
    int cnt = n;
    while(cnt>0 && c[cnt][j]=='Y') { ... }
    for(int i=cur[j];i<=n;i++) {
        // 计算sum1/sum2和tot[j][i]
    }
}
```

#### 3. 作者：psoet（★★★★☆）  
**关键亮点**：  
- 提出“最后一发子弹必为`N`”的结论，简化状态设计。  
- 通过四类状态转移覆盖所有决策分支，逻辑完备。  
- 代码中`ChkMax`宏优化可读性。  

**个人心得**：  
> “最后一发子弹若打在`Y`上，必然还有子弹剩余，与游戏结束条件矛盾”  
> —— 这一观察是理解状态设计的关键。

---

### 最优关键思路总结
1. **预处理列数据**：对每列自底向上遍历，统计使用`t`发子弹时的得分`sy[t]`（最后一发为`Y`）和`sn[t]`（最后一发为`N`）。  
2. **双状态DP设计**：`dp[i][j][0]`表示前i列用j发子弹且最后一发为`N`，`dp[i][j][1]`表示最后一发为`Y`。  
3. **分组背包转移**：枚举当前列使用的子弹数`t`，结合是否借用子弹进行状态转移。

---

### 拓展建议
1. **同类题目推荐**：  
   - [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)（分组背包）  
   - [P1941 飞扬的小鸟](https://www.luogu.com.cn/problem/P1941)（动态规划+状态转移优化）  
   - [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)（多维状态设计）  
2. **思维延伸**：类似“资源动态变化”问题可考虑附加状态维度（如剩余子弹、冷却时间等）。

---
处理用时：57.69秒
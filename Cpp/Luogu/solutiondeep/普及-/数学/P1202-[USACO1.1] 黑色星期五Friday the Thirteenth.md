# 题目信息

# [USACO1.1] 黑色星期五Friday the Thirteenth

## 题目描述

$13$ 号又是一个星期五，那么 $13$号在星期五比在其他日子少吗？  

为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。

这里有一些你要知道的:

1. $1900$ 年 $1$ 月 $1$ 日是星期一。
2. $4,6,11$ 和 $9$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。
3. 年份可以被 $4$ 整除的为闰年（$1992=4\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。
4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 400$。

题目翻译来自NOCOW。

USACO Training Section 1.1


## 样例 #1

### 输入

```
20
```

### 输出

```
36 33 34 33 35 35 34
```

# AI分析结果



### 综合分析
本题核心在于高效计算每月13号的星期分布，各题解主要采用三种思路：暴力模拟、逐月累加、数学公式。最优解法为基姆拉尔森公式，将时间复杂度优化至 O(n)，代码简洁且无冗余计算。关键难点在于正确实现闰年判断与日期计算公式的应用。

---

### 精选题解

#### 1. HEIGE（⭐⭐⭐⭐⭐）
**关键亮点**：使用基姆拉尔森公式直接计算每月13号的星期，时间复杂度最优（O(12n)），代码简洁易读。
```cpp
int week_day(int year, int month, int day) {
    if (month == 1 || month == 2) month += 12, year--; // 调整月份
    return (day + 2*month + 3*(month+1)/5 + year + year/4 - year/100 + year/400 + 1) % 7;
}
```
**实现核心**：公式直接返回星期值，主循环遍历所有年月的13日统计结果。

#### 2. 早右昕（⭐⭐⭐⭐）
**关键亮点**：利用每月天数差计算星期偏移，避免逐日模拟，代码精简。
```cpp
struct date {int yy,mm,ww;};
void operator++(date &a) { // 计算下个月13号的星期
    bool spl = 闰年判断;
    a.ww += 当月天数; // 根据spl选择平/闰年天数
    a.ww %= 7;
}
```
**心得**：通过结构体维护日期状态，增量计算减少循环次数。

#### 3. KingOfWA（⭐⭐⭐⭐）
**关键亮点**：数学归纳法递推公式，通过上月13号推导本月13号。
```cpp
for (年份) {
    for (月份) {
        day = (上月天数 + day) % 7;
        ans[day]++;
    }
}
```
**技巧**：通过递推公式避免重复计算，代码高效且易调试。

---

### 最优技巧总结
**基姆拉尔森公式**：将日期转换为数学公式计算，避免逐日循环。关键调整：1月和2月视为上一年的13、14月，公式自动处理闰年。

**同类型拓展**：类似日期计算问题（如节假日统计、闰年判断）可复用该公式。注意输出顺序可能隐含陷阱（如周六起始）。

---

### 推荐习题
1. P2141 [USACO07MAR] 月度开销统计（日期区间计算）
2. P1201 [USACO1.1] 贪婪的礼物赠送者（日期与循环结合）
3. P1217 [USACO1.5] 回文质数（数学公式优化遍历）

---
处理用时：57.03秒
# 题目信息

# 阶乘数码

## 题目描述

求 $n!$ 中某个数码出现的次数。


## 样例 #1

### 输入

```
2
5 2
7 0```

### 输出

```
1
2```

# AI分析结果



### 综合分析与结论
本题需通过高精度乘法计算大数阶乘，并统计指定数码出现次数。题解核心思路均为高精度乘单精度实现阶乘计算，差异主要体现在数组管理、进位处理、代码结构优化等方面。最优解法需兼顾代码可读性、正确性和空间效率。

---

### 精选题解（评分≥4星）

#### 1. 作者：Laser_Crystal（★★★★☆）
**关键亮点**  
- 合理估算数组大小（100000位），避免RE  
- 代码结构简洁，逻辑清晰  
- 处理进位的方式直观易懂  
**个人心得**  
"数组开小了就会RE" → 强调合理预估空间的重要性

**核心代码**  
```cpp
memset(c,0,sizeof(c));
c[0]=1;
int l=1;
for(int j=2; j<=n; j++) {
    int w=0;
    for(int k=0; k<l; k++) { // 高精度乘单精
        c[k] = c[k]*j + w;
        w = c[k]/10;
        c[k] %= 10;
    }
    while(w>0) { // 处理剩余进位
        c[l] = w%10;
        l++;
        w /=10;
    }
}
```

#### 2. 作者：Lee02（★★★★☆）
**关键亮点**  
- 模块化设计（`mul`函数独立）  
- 分步处理进位，逻辑更易理解  
- 支持动态扩展位数  

**核心代码**  
```cpp
void mul(int a[],int k) {
    for(int i=1; i<a[0]; i++) a[i] *= k;
    for(int i=1; i<a[0]; i++) { // 先处理已有位
        a[i+1] += a[i]/10;
        a[i] %=10;
    }
    while(a[a[0]]) { // 动态扩展位数
        a[a[0]+1] += a[a[0]]/10;
        a[a[0]] %=10;
        a[0]++;
    }
}
```

#### 3. 作者：密期望（★★★★★）
**关键亮点**  
- 分治+FFT优化，复杂度O(n log²n)  
- 大数据效率优势明显  
- 提供高阶优化思路  

**核心思路**  
将阶乘拆分为区间乘积，通过多项式乘法加速。虽然本题数据范围无需此优化，但为高精度问题提供通用优化方案。

---

### 关键优化与技巧
1. **进位分段处理**：先乘后统一进位，避免逐位计算的冗余。  
2. **动态位数管理**：通过`while(w>0)`自动扩展数组长度。  
3. **模块化设计**：分离乘法与统计逻辑，提升代码复用性。  
4. **空间预估**：根据n最大值的位数（约2568位）预留3倍空间防溢出。

---

### 拓展与相似题目
1. **P1009 [阶乘之和]**：高精度加法与乘法结合  
2. **P1255 数楼梯**：斐波那契数列的高精度实现  
3. **P1604 B进制星球**：高精度算法的进制拓展  

---

### 调试经验摘录
- **数组未清零**："全WA" → 多组数据需重置数组（Dream_It_Possible）  
- **边界处理**："最高位单独处理进位" → 避免漏算（Laser_Crystal）  
- **压位优化**：用int存多位数字减少循环次数（Terrible）

---
处理用时：56.45秒
# 题目信息

# 斐波那契的拆分

## 题目背景

无

## 题目描述

已知任意一个正整数都可以拆分为若干个斐波纳契数，现在，让你求出 $n$ 的拆分方法。


## 说明/提示

若有多组数据，以个数最小的为准，若仍有多组，输出右边尽量大的一组。

对于$100\%$的数据，$t \leq 1000$，$1 \leq n \leq 10^{9}$。

## 样例 #1

### 输入

```
1
1
```

### 输出

```
1=1```

## 样例 #2

### 输入

```
1
10```

### 输出

```
10=2+8```

# AI分析结果



### 综合分析与结论
各题解均基于贪心策略：从最大的斐波那契数开始选取，确保拆分后的数个数最少。核心难点在于正确预处理斐波那契数列（需覆盖题目范围1e9），以及输出顺序的控制。最优解法需满足时间复杂度O(预处理 + t*45) 和空间复杂度O(45)。

---

### 高评分题解推荐

#### 1. 作者：shame_djj（★★★★★）
**关键亮点**  
- 预处理斐波那契数列到第45项（精确覆盖1e9），避免溢出  
- 使用栈存储结果，自然实现逆序输出  
- 代码简洁高效，逻辑清晰  
**核心代码**  
```cpp
for (int i = 45; i >= 1; i--) {
    while (n >= f[i]) s.push(f[i]), n -= f[i];
    if (n == 0) break;
}
// 栈直接输出即可保证右端最大
```

#### 2. 作者：lamboo（★★★★☆）
**关键亮点**  
- 预处理斐波那契数列到第45项，确保正确性  
- 用数组存储结果后反向遍历输出，逻辑直观  
- 处理重复选取的边界条件（如4=2+2）  
**核心代码**  
```cpp
for (int j = 45; j >= 1; j--) {
    if (a[j] <= t) {
        w++; b[w] = a[j]; t -= a[j];
    }
}
// 反向遍历数组输出结果
```

#### 3. 作者：ljw2005（★★★★☆）
**关键亮点**  
- 动态维护最大可选的斐波那契数下标，优化搜索过程  
- 使用栈存储结果，避免额外排序  
**核心代码**  
```cpp
for (i = l; i >= 1; i--) {
    if (f[i] <= n && f[i+1] > n) {
        a.push(f[i]); n -= f[i]; l = i; // 更新下次搜索起点
    }
}
```

---

### 最优关键思路与技巧
1. **贪心策略**：从最大斐波那契数开始选取，确保拆分个数最少。  
2. **预处理数列**：生成足够大的斐波那契数列（如45项，最大项为1,836,311,903）。  
3. **输出顺序控制**：使用栈或反向遍历数组，保证“右边尽量大”的优先级。  
4. **空间优化**：无需存储所有可能的拆分组合，只需线性扫描。  

---

### 拓展与相似题目
1. **P1255 数楼梯**（斐波那契数列应用）  
2. **P1962 斐波那契数列**（矩阵快速幂优化）  
3. **P2320 拆分金币**（贪心策略与进制思想）  

---

### 题解中的调试经验摘录
1. **栈的妙用**：多篇题解提到“用栈存储结果后反向输出”，避免手动逆序操作。  
2. **预处理项数计算**：需精确计算斐波那契数列的项数，防止溢出（如第45项覆盖1e9）。  
3. **边界处理**：`lamboo`强调处理类似4=2+2的重复选取情况，需在循环中允许连续选取相同数。  

---

**推荐代码实现（shame_djj版）**  
```cpp
#include <iostream>
#include <stack>
using namespace std;

long long f[50] = {1, 1}; // 预处理数列
stack<int> s;

int main() {
    for (int i = 2; i <= 45; i++) f[i] = f[i-1] + f[i-2];
    int t, n; cin >> t;
    while (t--) {
        cin >> n; cout << n << "=";
        for (int i = 45; i >= 1; i--) {
            while (n >= f[i]) s.push(f[i]), n -= f[i];
            if (!n) break;
        }
        while (!s.empty()) { // 栈输出保证顺序
            cout << s.top(); s.pop();
            if (!s.empty()) cout << "+";
        }
        cout << endl;
    }
    return 0;
}
```

---
处理用时：61.05秒
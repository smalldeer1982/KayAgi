# 题目信息

# 编号

## 题目描述

太郎有 $N$ 只兔子，现在为了方便识别它们，太郎要给他们编号。兔子们向太郎表达了它们对号码的喜好，每个兔子 $i$ 想要一个整数，介于 $1$ 和 $M_i$ 之间（可以为 $1$ 或 $M_i$）。当然，每个兔子的编号是不同的。现在太郎想知道一共有多少种编号的方法。

你只用输出答案对 $10^9+7$ 取余的结果即可。如果这是不可能的，就输出 $0$。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 50$，$1\le M_i\le 1000$。

## 样例 #1

### 输入

```
2
5 8
```

### 输出

```
35```

# AI分析结果



### 综合分析与结论
题目核心在于将兔子的可选编号范围排序后，通过乘法原理计算总方案数。关键点在于排序后每个兔子的可选数目为 $M_i - i + 1$，需保证每个数目为正数，否则总方案数为 0。需在每一步计算时检查合法性，避免负数或溢出。

---

### 高星题解推荐

#### 1. 作者：oistr（⭐⭐⭐⭐⭐）
**关键亮点**  
- 在循环中逐个检查每个兔子的可选数目，若出现非正数直接输出 0，确保正确性。  
- 思路清晰，代码严谨，处理了所有边界情况。  

**核心代码**  
```cpp
sort(m+1, m+n+1);
long long s = m[1];
for (int i=2; i<=n; i++) {
    if ((m[i] - i +1) <= 0) {
        cout << 0 << endl;
        return 0;
    }
    s = (s * (m[i] - i +1)) % 1000000007;
}
cout << s << endl;
```

#### 2. 作者：按Ctrl加w会AC（⭐⭐⭐⭐）
**关键亮点**  
- 预处理每个兔子的可选数目，排序后直接检查合法性，代码简洁高效。  
- 在相乘前统一检查，避免中间结果出现负数。  

**核心代码**  
```cpp
sort(a+1, a+1+n);
for (int i=1; i<=n; i++) {
    a[i] -= (i-1);
    if (a[i] <= 0) {
        printf("0\n");
        return 0;
    }
}
long long ans = 1;
for (int i=1; i<=n; i++) 
    ans = (ans * a[i]) % 1000000007;
```

---

### 最优思路总结
1. **排序**：将兔子的最大可选编号升序排列，保证贪心策略的正确性。  
2. **合法性检查**：对每个兔子的可选数目 $M_i - i + 1$ 进行逐项检查，若存在非正数直接返回 0。  
3. **边乘边模**：每次乘法后取模，避免溢出。  

---

### 拓展与同类题目
- **同类问题**：受限排列组合问题（如元素有上下界限制）。  
- **推荐题目**：  
  1. [P3014 Cow Line S](https://www.luogu.com.cn/problem/P3014)  
  2. [P4369 Sequence](https://www.luogu.com.cn/problem/P4369)  
  3. [P1866 编号](https://www.luogu.com.cn/problem/P1866)（本题原题）  

---

### 个人心得摘录
- **排序的重要性**（刘心远）：不排序会导致无法确定前序选择对当前范围的影响。  
- **及时检查合法性**（oistr）：避免无效计算，保证每一步的正确性。  
- **模运算技巧**（GuideZombies）：每次操作后取模，防止溢出。

---
处理用时：491.82秒
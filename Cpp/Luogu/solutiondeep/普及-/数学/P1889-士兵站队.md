# 题目信息

# 士兵站队

## 题目描述

在一个划分成网格的操场上，$n$ 个士兵散乱地站在网格点上，由整数坐标 $(x,y)$ 表示。

士兵们可以沿网格边上、下左右移动一步，但在同时刻任一网格点上只能有 1 名士兵。

按照军官的命令，他们要整齐地列成一个水平队列，即排成队列，即排成 $(x,y),(x+1,y),\ldots,(x+n-1,y)$。请求出如何选择 $x$ 和 $y$ 的值才能使士兵们以最少的总移动步数排成一列。

## 说明/提示

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10000$，$-10000 \leq x,y \leq 10000$。

## 样例 #1

### 输入

```
5
1 2
2 2
1 3
3 -2
3 3```

### 输出

```
8```

# AI分析结果



### 综合分析与结论
本题核心是将二维移动问题拆解为两个独立的一维中位数问题。所有题解均采用纵坐标直接取中位数，横坐标通过坐标变换(x_i-i)后取中位数的策略。其中xiejinhao的题解以清晰的推导和简洁的代码实现成为最优解，其他题解在代码实现或思路阐述上存在冗余。

---

### 精选题解

#### 1. xiejinhao（5星）
**关键亮点**：
- 清晰推导纵/横坐标处理公式，数学证明严谨
- 代码直接使用STL排序，处理逻辑高度简洁
- 完整注释说明关键步骤的数学意义

**核心代码**：
```cpp
sort(y+1,y+n+1); // 纵坐标直接排序取中位数
sort(x+1,x+n+1);
for(int i=1;i<=n;i++) x[i]-=i; // 横坐标转换
sort(x+1,x+n+1); // 再次排序后取中位数

int calc_median(int arr[], int n) {
    return (n%2) ? arr[n/2+1] : (arr[n/2]+arr[n/2+1])/2;
}
```

#### 2. lzj666_luogu（4星）
**关键亮点**：
- 极简代码风格，仅用5行完成核心计算
- 通过对称性优化中位数差求和

**核心代码**：
```cpp
sort(x+1,x+n+1); sort(y+1,y+n+1);
for(int i=1;i<=n;i++) x[i]-=i;
sort(x+1,x+n+1);
// 利用对称性直接计算差值和
for(int i=1;i<=n/2;i++) 
    ans += x[n-i+1]-x[i] + y[n-i+1]-y[i];
```

#### 3. qmq菜死了（4星）
**个人心得**：
> "处理横坐标时必须减去不同的值，否则会导致位置冲突。这一步转换是本题的关键点，最初没有意识到这点导致WA多次"

---

### 关键思路总结
1. **维度拆分**：将二维问题转化为两个独立的一维问题
2. **坐标变换**：横坐标通过x_i' = x_i - i消除位置冲突
3. **中位数定理**：绝对差最小解为中位数位置
4. **高效实现**：O(nlogn)排序即可完成计算，无需暴力枚举

---

### 拓展练习
1. [P1862 输油管道](https://www.luogu.com.cn/problem/P1862)（中位数基础）
2. [P2512 糖果传递](https://www.luogu.com.cn/problem/P2512)（环形中位数应用）
3. [CF1520E Arranging The Sheep](https://codeforces.com/problemset/problem/1520/E)（进阶版士兵排列）

---

### 核心代码实现
完整处理流程：
```cpp
void solve(vector<int>& x, vector<int>& y) {
    sort(y.begin(), y.end());
    int my = y[y.size()/2];
    
    sort(x.begin(), x.end());
    for(int i=0; i<x.size(); ++i) x[i] -= (i+1);
    sort(x.begin(), x.end());
    int mx = x[x.size()/2];
    
    int total = 0;
    for(auto& v : y) total += abs(v - my);
    for(auto& v : x) total += abs(v - mx);
    return total;
}
```

---
处理用时：51.78秒
# 题目信息

# [AHOI2002] 黑白图像压缩

## 题目描述

选修基础生物基因学的时候， 小可可在家里做了一次图像学试验。 她知道：整个图像其实就是若干个图像点(称作像素)的序列，假定序列中像素的个数总是 8 的倍数， 于是每八个像素可以转换成一个叫做字节的数， 从而这个表示图像的像素序列就被转换成了字节的序列。

所谓的字节就是一个八位的二进制数(当然，为了便于书写，人们经常用它的十进制形式来表示)。这八个像素从前向后依次对应于字节从高位到低位的八个位， 用 0 来表示白色像素、 1 来表示黑色像素。 这种表示方法叫做位图法。 例如字节序列 210、 0、255 表示了 8\*3=24 个像素， 由于对应的二进制形式是 11010010、 00000000、11111111， 所以这 24 个像素的颜色依次是黑、 黑、 白、 黑、 白、 白、 黑、 白、白、白、白、白、白、白、白、白、黑、黑、黑、黑、黑、黑、黑、黑。

小可可想： 其实图像中存在着很多连续的同色像素段， 也许换一种方式表达图像能够减少图像的数据量。 她的思路是： 把像素按照颜色分成若干个片段， 同一个片段中各像素颜色相同， 且连续的同色像素都在同一个片段中。同时已知每个片段的最大长度小于 128。

每一个像素片段都是用一个二进制字节量来表示， 最高位表示片段中像素的颜色， 而低七位表示片段中像素的数目。注意：不存在长度为 0 的像素片段。这种表示法叫做像素片段法。

例如位图表示法的字节序列 210、 0、 255 对应的像素序列可以分成七个片段，分别是： 11、 0、 1、 00、 1、 000000000、 11111111。如果用像素片段法来表示的话，二进制字节序列应该写成 10000010、 00000001、 10000001、00000010、 10000001、 00001001、 10001000， 而其对应于十进制字节序列就是 130、 1、 129、 2、 129、 9、 136。

像素片段法是否能有效地减少图像的数据存储量呢？小可可不知道如何用数学的方法加以证明， 于是决心对手头上的图像做些试验， 看看该方法是否真的有效。 请你编写程序完成图像信息的转换， 以协助小可可完成这项试验。


## 说明/提示

$1\leq n\leq 8\times 10^4$。

## 样例 #1

### 输入

```
8 0```

### 输出

```
8```

## 样例 #2

### 输入

```
24 210 0 255```

### 输出

```
130 1 129 2 129 9 136```

# AI分析结果



### 综合分析与结论
本题核心是将输入的多个8位二进制数转换为像素片段编码。正确解法需处理以下要点：正确分解二进制位、统计连续段、确保每段长度≤127。多数题解采用直接模拟，但仅部分正确处理了最大长度限制。关键优化点包括使用位运算、及时分割过长片段、处理边界条件。

### 高分题解推荐
#### 1. Ofnoname（5星）
**关键亮点**  
- 正确处理最大长度限制，确保每段长度≤127。  
- 使用位运算高效生成输出。  
- 代码简洁，逻辑清晰，边界处理完善。  

**核心代码**  
```cpp
int now = a[1], sum = 1;
for (int i = 2; i <= N; i++) {
    if (a[i] != a[i-1] || sum == 127) { // 颜色变化或长度达127时分割
        printf("%d ", now << 7 | sum);
        now = a[i], sum = 1;
    } else sum++;
}
printf("%d ", now << 7 | sum);
```
**实现思想**  
将每个字节分解为二进制数组，遍历时检查颜色变化或长度达到127，用位运算组合颜色和长度生成输出。

---

#### 2. _111_（4星）
**关键亮点**  
- 显式处理长度达到127的情况。  
- 变量命名清晰，代码可读性强。  

**核心代码**  
```cpp
int len = 1;
for (int i = 2; i <= n; i++) {
    if (b[i] != b[i-1] || len == 127) { // 强制分割过长段
        printf("%d ", len + (b[i-1] ? 128 : 0));
        len = 1;
    } else len++;
}
printf("%d ", len + (b[n] ? 128 : 0));
```
**实现思想**  
通过循环判断长度是否达到阈值，保证每个片段符合题目要求，逻辑直观。

---

#### 3. UnyieldingTrilobite（4星）
**关键亮点**  
- 利用STL的`bitset`简化二进制转换。  
- 使用哨兵字符简化末尾处理。  

**核心代码**  
```cpp
bitset<8> s(a);
h += s.to_string(); // 自动转为8位二进制字符串
h += '#'; // 哨兵
for (int pos = 0; pos < h.size()-1; ++pos) {
    int num = 1;
    for (; h[pos] == h[pos+1]; ++pos) ++num;
    printf("%d ", h[pos] == '1' ? num | 128 : num);
}
```
**实现思想**  
通过字符串拼接和哨兵处理连续片段，代码简洁但未处理长度限制，需注意题目约束。

---

### 关键技巧总结
1. **二进制分解优化**：使用位运算或`bitset`高效处理字节到二进制的转换。
2. **游程编码分段**：遍历时动态统计连续段，及时分割长度≥128的段。
3. **边界处理技巧**：通过哨兵字符或手动输出来确保最后一段被处理。

### 拓展练习
1. [P1319 压缩技术](https://www.luogu.com.cn/problem/P1319)  
2. [P1320 压缩技术（续集版）](https://www.luogu.com.cn/problem/P1320)  
3. [P2561 黑白图像处理](https://www.luogu.com.cn/problem/P2556)（本题变形）  

### 个人心得摘录
- **ICEMAGE**：“只用注意第一次和最后结束时的情况”——强调初始化和末尾处理的重要性。  
- **Ofnoname**：“每个片段的最大长度小于128”——明确指出题目关键约束，确保正确性。

---
处理用时：262.53秒
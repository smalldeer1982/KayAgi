# 题目信息

# 神秘磁石

## 题目背景

在遥远的阿拉德大陆，有一种神秘的磁石，是由魔皇制作出来的，


## 题目描述

1. 若给他一个一维坐标系，那么他的磁力一定要在素数坐标的位置上才能发挥的最大（不管位置坐标的大小，只要是素数那么磁力就一样大）。
2. 若两个磁石相距为 $k$，那么磁石间的破坏力将会达到当前磁力的峰值

显然，两磁石间最大破坏力取决于磁力大小和磁石间距，那么请问给出长度不超过 $n$ 的一维坐标系，有哪几对坐标间磁石破坏力最大。


## 说明/提示

对于 $100\%$ 的数据，$1\leq k\leq n\leq 10^4$。

## 样例 #1

### 输入

```
6924 809```

### 输出

```
2 811
```

# AI分析结果



### 综合分析与结论
本题核心在于高效筛选素数并快速查询素数对。题解主要分为暴力判断、筛法优化、打表法三类。最优思路是预处理素数表（筛法或打表）后遍历检查相邻素数差为k的情况。

### 高星题解推荐
#### 1. 作者：YLWang（★★★★☆）
**关键亮点**：  
- 预生成素数表实现O(1)查询，大幅降低运行时开销  
- 通过离线打表程序分离预处理与主逻辑  
- 代码简洁高效，适合固定数据范围问题  

**核心代码**：
```cpp
int p[N] = {0,0,1,1,0,1,0,1,0,0,0,1,...}; // 预生成素数表
for(int i=1; i<=n-k; i++) {
    if(p[i] && p[i+k]) { // 直接查表判断
        printf("%d %d\n", i, i+k);
        flag = 1;
    }
}
```

#### 2. 作者：引领天下（★★★★☆）
**关键亮点**：  
- 线性筛法生成素数表，动态处理更大数据范围  
- 额外存储素数数组优化遍历效率  
- 逻辑清晰，空间利用率更优  

**核心代码**：
```cpp
void sieve() { // 欧拉筛
    for(int i=2; i<=n; i++) {
        if(!vis[i]) primes[cnt++] = i;
        for(int j=0; primes[j]*i<=n; j++) {
            vis[primes[j]*i] = 1;
            if(i%primes[j] == 0) break;
        }
    }
}
for(int i=0; primes[i]+k<=n; i++) { // 仅遍历素数数组
    if(!vis[primes[i]+k]) 
        printf("%d %d\n", primes[i], primes[i]+k);
}
```

#### 3. 作者：Qing_s（★★★☆☆）
**关键亮点**：  
- 朴素筛法实现简单易懂  
- 包含数学优化（sqrt提前终止循环）  
- 适合初学者理解素数判断原理  

**核心代码**：
```cpp
bool prime(int x) {
    if(x < 2) return false;
    for(int i=2; i*i<=x; i++)
        if(x%i == 0) return false;
    return true;
}
for(int i=2; i<=n-k; i++) { // 暴力遍历所有数
    if(prime(i) && prime(i+k)) 
        cout << i << " " << i+k << endl;
}
```

### 关键思路总结
1. **预处理思想**：通过筛法或打表预存素数状态，将时间复杂度从O(n√n)降至O(n)  
2. **空间换时间**：使用标记数组存储素数状态，牺牲少量空间换取查询效率  
3. **遍历优化**：仅需检查i∈[2, n-k]范围，避免无效计算  

### 举一反三
1. **同类问题**：回文素数、连续素数间隔、素数环等  
2. **算法扩展**：Miller-Rabin大数素性测试、区间筛法等  

### 推荐练习题
1. [P3383 线性筛素数](https://www.luogu.com.cn/problem/P3383)  
2. [P1217 回文质数](https://www.luogu.com.cn/problem/P1217)  
3. [P1304 哥德巴赫猜想](https://www.luogu.com.cn/problem/P1304)  

### 实践建议
- **调试技巧**：验证筛法正确性时可打印小范围素数表  
- **易错点**：注意i+k≤n的边界条件，避免数组越界  
- **优化方向**：对于k较大情况，可反向遍历j从k+1开始检查j-k是否为素数

---
处理用时：52.11秒
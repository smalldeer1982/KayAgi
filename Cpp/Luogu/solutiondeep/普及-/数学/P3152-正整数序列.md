# 题目信息

# 正整数序列

## 题目描述

kkk制造了一个序列，这个序列里的数全是由正整数构成的。你别认为她的数列很神奇——其实就是1, 2, …, n而已。当然，n是给定的。kkk的同学lzn认为0是一个好数字（看上去很饱满有木有），所以他机智的趁kkk不在把这个序列全变成了0（其实只是准备窝）~

可是kkk突然回来了！于是lzn的计划破灭了。但是他并不甘心，就和kkk说：我可以每次从这个序列中选取一些数，然后一起减去一个相同的数（当然也是正整数）。然后经过有(wu)限(qiong)次这样的操作后，这个序列就可以全变成0。

kkk当然不信咯，于是lzn就求出了他最少要做几次这样的操作，才能使这个序列全部变成0。


## 说明/提示

1<=n<=10^9


## 样例 #1

### 输入

```
2```

### 输出

```
2```

# AI分析结果



### 综合分析与结论
本题本质是求将 1~n 的序列通过「批量减去相同值」操作清零的最小次数。所有优质题解均基于同一核心结论：**最少操作次数 = ⌊log₂n⌋ + 1**，即 n 的二进制位数。关键思路是通过二进制分解，每次操作消除一个二进制位上的 1。

---

### 精选题解（评分≥4星）

#### 1. 作者：Alex_Wei（★★★★★）
**亮点**：
- 通过二进制分解的直观示例（n=8）清晰展示操作策略
- 结合数学定理（任意数可拆分为不同 2 的幂次）给出严谨结论
- 代码简洁高效（O(1) 时间复杂度）

**核心代码**：
```cpp
cout << (int)log2(n) + 1;
```
**实现思想**：直接计算 n 的二进制位数，即 log₂(n) 的整数部分 +1。

---

#### 2. 作者：UnyieldingTrilobite（★★★★★）
**亮点**：
- 给出严谨数学证明：通过 2^k 种组合的鸽巢原理证明操作次数下界
- 提出二进制位权值的消除策略，说明操作次数上界
- 完整证明结论的最优性

**核心代码**：
```cpp
printf("%d\n", (int)log2(n) + 1);
```
**关键证明**：  
若使用 k 次操作，最多能覆盖 2^k 个不同数值，因此需要满足 2^k ≥ n+1 ⇒ k ≥ ⌈log₂(n+1)⌉ = ⌊log₂n⌋ +1。

---

#### 3. 作者：nydzsf_qwq（★★★★☆）
**亮点**：
- 从数值种类的角度分析操作次数下界
- 通过数值合并的视角解释操作策略
- 补充了其他题解缺少的最优性证明

**关键证明**：  
每次操作后剩余数值种类至少减半，因此最少需要 ⌈log₂(n+1)⌉ 次操作。

---

### 关键思路总结
**二进制位消除法**：  
1. 每个数可唯一表示为二进制数
2. 每次操作消除一个二进制位上的所有 1
3. 总操作次数等于最大数的二进制位数

**优化技巧**：  
- 直接使用 `log2(n)` 或位运算计算二进制位数
- 注意特判 n=1 的情况（log₂(1)=0，但需 1 次操作）

---

### 拓展思考
**同类问题**：  
1. 用最少操作将数组元素变为相同值（每次选子集加减固定值）
2. 基于位运算的极值问题（如求最大异或和）

**推荐练习题**：  
1. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)（二进制分解思想）
2. [P2114 [NOI2016] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)（位运算贪心）
3. [P5657 格雷码](https://www.luogu.com.cn/problem/P5657)（二进制编码应用）

---

### 题解心得摘录
1. **C_Cong 的教训**：  
   错误特判 n=1 时输出 -1（正确应为 1），强调边界测试的重要性。

2. **dfydada⚡ 的调试**：  
   通过打表发现规律，验证代码正确性，体现实验思维的价值。

3. **mengdai 的递归思路**：  
   提出递归式 f(n) = f(n/2) +1，展示分治思想的应用。

---
处理用时：61.20秒
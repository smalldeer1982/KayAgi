# 题目信息

# 车的攻击

## 题目描述

$N \times N$ 的国际象棋棋盘上有$K$ 个车，第$i$个车位于第$R_i$行，第$C_i$ 列。求至少被一个车攻击的格子数量。

车可以攻击所有同一行或者同一列的地方。


## 说明/提示

• 对于30% 的数据，$1 \le N \le 10^3; 1 \le K \le 10^3$；

• 对于60% 的数据，$1 \le N \le 10^6; 1 \le K \le 10^6$；

• 对于100% 的数据，$1 \le N \le 10^9; 1 \le K \le 10^6; 1 \le R_i , C_i \le N$。


## 样例 #1

### 输入

```
3 2
1 2
2 2```

### 输出

```
7```

# AI分析结果



### 综合分析与结论  
题目核心在于高效统计被车攻击的行列数，利用容斥原理避免重复计算交点。最优解法为：排序后统计唯一行(h)和列(l)，公式为 `n² - (n-h)(n-l)`。时间复杂度为 O(k log k)，适用于大数据范围。

---

### 高星题解推荐  

#### 1. 作者：Kater_kcl (⭐⭐⭐⭐⭐)  
**关键亮点**：  
- 使用 `sort` + `unique` 高效去重，代码简洁。  
- 公式推导清晰，直接计算总覆盖数。  
**核心代码**：  
```cpp
sort(x, x+k); sort(y, y+k);
ll sizex = unique(x, x+k) - x;
ll sizey = unique(y, y+k) - y;
printf("%lld", n*n - (n-sizex)*(n-sizey));
```

#### 2. 作者：lzy755277 (⭐⭐⭐⭐)  
**关键亮点**：  
- 遍历排序后数组统计唯一元素，避免依赖 STL。  
- 公式等价但更直观 (`n² - 未被攻击矩形面积`)。  
**代码调整建议**：  
循环应从 `i=1` 到 `k-1` 判断相邻元素，避免越界。核心代码：  
```cpp
for(i=1; i<=k; i++) {
    if(x[i] != x[i-1]) h++; // 修正为 i<=k-1
}
```

#### 3. 作者：Scherzo (⭐⭐⭐⭐)  
**关键亮点**：  
- 几何化思路：移动行列至左上角，转化为剩余矩形面积。  
- 详细图解辅助理解公式推导。  
**核心公式**：  
```cpp
ans = n*n - (n - cntr) * (n - cntc); // cntr/cntc为唯一行列数
```

---

### 最优关键思路与技巧  
1. **容斥原理**：覆盖数 = 行覆盖 + 列覆盖 - 行列交点覆盖。  
2. **去重优化**：通过排序后统计相邻元素差异，或使用 `unique` 函数。  
3. **公式变形**：`h*n + l*n - h*l` 或等效的 `n² - (n-h)(n-l)`。  

---

### 相似题目推荐  
1. **P1496 火烧赤壁**：区间合并求总覆盖长度。  
2. **P1056 排座椅**：贪心选择行列分隔线，统计最优解。  
3. **P3406 海底高铁**：差分统计区间覆盖次数，优化路径计算。  

---

### 调试与优化经验摘录  
- **Kater_kcl**：强调 `unique` 前必须排序，返回值处理是关键。  
- **stansxt**：手动二分代替 `lower_bound` 避免 TLE，离散化缩小数据范围。  
- **TESJackeyLove**：开 `long long` 的重要性及公式等价变形。

---
处理用时：66.94秒
# 题目信息

# [USACO17DEC] Blocked Billboard B

## 题目描述

在漫长的挤奶过程中，奶牛 Bessie 喜欢透过谷仓的窗户盯着街对面的两块巨大的矩形广告牌，上面分别写着“Farmer Alex 的美味苜蓿”和“Farmer Greg 的优质谷物”。广告牌上这两种奶牛饲料的图片对 Bessie 来说比她农场里的草看起来美味得多。

有一天，当 Bessie 正盯着窗外时，她惊讶地看到一辆巨大的矩形卡车停在街对面。卡车的侧面有一则广告，写着“Farmer Smith 的顶级牛排”，Bessie 不太理解这则广告，但她更担心的是卡车可能会挡住她最喜欢的两块广告牌的视线。

给定两块广告牌和卡车的位置，请计算两块广告牌仍然可见的总面积。卡车可能遮挡了其中一块、两块，或者没有遮挡任何一块广告牌。

## 说明/提示

在这个例子中，第一块广告牌有 $5$ 单位面积可见，第二块广告牌有 $12$ 单位面积可见。

题目来源：Brian Dean

## 样例 #1

### 输入

```
1 2 3 5
6 0 10 4
2 1 8 3```

### 输出

```
17```

# AI分析结果



### 综合分析与结论
本题核心是计算两个矩形在第三个矩形遮挡后的可见面积。题解主要分为**模拟覆盖法**与**数学交集法**两类。模拟法通过标记二维数组统计未被覆盖的点，适用于小数据范围；数学法则直接计算重叠面积，时间复杂度更优（O(1)）。

### 高星题解推荐
#### 1. [litianqi2529298200] ⭐⭐⭐⭐⭐（5星）
**关键亮点**：
- **数学交集法**：通过计算两个广告牌与卡车的重叠面积，直接得出答案。公式为 `总可见面积 = 广告牌面积和 - 重叠面积和`。
- **高效简洁**：时间复杂度O(1)，无需遍历坐标，代码可读性极佳。
- **关键代码**：
  ```cpp
  int intersect_area(Rect p, Rect q) {
      int x_overlap = max(0, min(p.x2, q.x2) - max(p.x1, q.x1));
      int y_overlap = max(0, min(p.y2, q.y2) - max(p.y1, q.y1));
      return x_overlap * y_overlap;
  }
  ```
**个人心得**：作者强调使用 `max(0, ...)` 避免负面积，正确处理无交集情况。

#### 2. [Alex_Wei] ⭐⭐⭐⭐（4星）
**关键亮点**：
- **模拟覆盖法**：标记广告牌区域后，用卡车区域覆盖标记，最后统计剩余标记。
- **坐标偏移处理**：通过+1000解决负数坐标问题，循环条件使用 `<` 避免越界。
**核心代码**：
  ```cpp
  for (int y = a+1000; y < d+1000; y++)
      for (int z = s+1000; z < f+1000; z++) {
          if (x < 3) m[y][z]++, ans++;
          if (m[y][z] && x == 3) ans--;
      }
  ```

#### 3. [lizehan888] ⭐⭐⭐⭐（4星）
**关键亮点**：
- **结构体封装**：通过结构体封装矩形坐标，提升代码可读性。
- **离散化思路**：将坐标离散化后分割成小矩形逐个判断，适合更大数据范围的扩展。

### 最优思路总结
**数学交集法**是最优解：  
1. **计算矩形交集**：通过 `min/max` 确定重叠区域的边界，若结果非正则无重叠。
2. **公式化求解**：总可见面积 = 广告牌总面积 - 被卡车遮挡的部分。
3. **避免模拟开销**：直接数学计算无需遍历坐标，效率显著优于模拟法。

### 拓展与举一反三
- **类似题目**：
  1. [P1884] Overplanting S（矩形覆盖面积）
  2. [P2742] 圈奶牛（计算几何与凸包）
  3. [P1496] 火烧赤壁（区间合并）
- **关键技巧**：处理坐标偏移、离散化分割、结构体封装几何对象。

### 代码片段（数学法核心）
```cpp
struct Rect { int x1, y1, x2, y2; };

int area(Rect r) { 
    return (r.x2 - r.x1) * (r.y2 - r.y1); 
}

int intersect(Rect a, Rect b) {
    int dx = max(0, min(a.x2, b.x2) - max(a.x1, b.x1));
    int dy = max(0, min(a.y2, b.y2) - max(a.y1, b.y1));
    return dx * dy;
}

int main() {
    Rect ad1, ad2, truck;
    // 输入坐标后直接计算
    cout << area(ad1) + area(ad2) - intersect(ad1, truck) - intersect(ad2, truck);
}
```

---
处理用时：56.09秒
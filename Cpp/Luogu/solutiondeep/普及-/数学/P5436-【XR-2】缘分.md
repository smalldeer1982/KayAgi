# 题目信息

# 【XR-2】缘分

## 题目背景

> 世间万物都置身于缘分编织的大网中。缘分未到，虽历经千劫，却不能相遇。缘分到了，在草原上都能等到一艘船。——《一禅小和尚》

## 题目描述

一禅希望知道他和师父之间的缘分大小。可是如何才能知道呢？

一禅想了个办法，他先和师父约定一个正整数 $n$，接着他们各自在心里想一个不超过 $n$ 的正整数。

一禅认为，他和师父心里想的这两个数的**最小公倍数**越大，则意味着他和师父之间的缘分越大。

师父觉得这个办法很合适，不过他想知道这两个数的最小公倍数最大会是多少。

师父的数学不太好，于是问一禅。一禅也觉得这个问题很困难，他希望你能告诉他答案。

## 说明/提示

【样例 $1$ 说明】

不超过 $3$ 的两个正整数的最小公倍数的最大值为 $\mathrm{lcm}(2,3) = 6$。

【数据规模与约定】

对 $50\%$ 的数据，$1 \le T,n \le 100$。

对 $100\%$ 的数据，$1 \le T \le 100, 1 \le n \le 10^9$。

## 样例 #1

### 输入

```
1
3
```

### 输出

```
6
```

# AI分析结果



### 综合分析与结论
题目核心是求两数在不超过n时的最大lcm。所有题解均得出相同结论：当n≥2时，选择相邻两数n和n-1（互质），此时lcm=n*(n-1)；n=1时特判为1。关键点在于：
1. 相邻数互质性质的应用
2. 特判n=1的边界条件
3. 处理大数乘积的溢出问题（使用long long）

### 精选题解与评分
#### 1. Koakuma（5星）
**关键亮点**：直击结论本质，代码简洁高效，明确处理n=1的特例和溢出问题  
**核心代码**：
```cpp
if(n == 1) puts("1");
else cout << 1ll * n * (n - 1) << endl;
```
**技巧**：利用`1ll`强制类型转换避免溢出

#### 2. StudyingFather（4星）
**关键亮点**：清晰阐述推导过程（gcd最小化→互质→相邻数），代码可读性强  
**核心代码**：
```cpp
if(x==1) cout<<1<<endl;
else cout<<x*(x-1)<<endl;
```
**心得**：明确将数学推导转化为代码逻辑

#### 3. Register（4星）
**关键亮点**：系统分析解题因素（互质+数值大），完整注释数据范围处理  
**代码亮点**：
```cpp
#define int long long // 全局处理溢出
printf("%lld\n",n==1?1:n*(n-1));
```

### 最优策略总结
**关键思路**：  
- 数学性质：相邻正整数必互质 → lcm(a,b)=a*b  
- 极值选择：最大相邻数对(n,n-1)  
- 边界处理：n=1时唯一解为(1,1)

**实现技巧**：  
- 使用`long long`或强制类型转换处理大数  
- 条件运算符简化特判逻辑

### 拓展训练
**同类题目推荐**：  
1. P1072 Hankson的趣味题（数论综合应用）  
2. P4057 [Code+#1] 晨跑（多数lcm极值）  
3. P2651 添加括号III（gcd/lcm性质应用）

**心法拓展**：  
当需要极值问题时，优先考虑：
1. 边界情况（最大/最小值） 
2. 特殊数学性质（互质、奇偶性）
3. 相邻数/对称数等特殊数对

---
处理用时：42.01秒
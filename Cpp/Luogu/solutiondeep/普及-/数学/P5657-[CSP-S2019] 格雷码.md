# 题目信息

# [CSP-S2019] 格雷码

## 题目描述

通常，人们习惯将所有 $n$ 位二进制串按照字典序排列，例如所有 2 位二进制串按字典序从小到大排列为：00，01，10，11。

格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间**恰好**有一位**不同**，特别地，第一个串与最后一个串也算作相邻。

所有 2 位二进制串按格雷码排列的一个例子为：00，01，11，10。

$n$ 位格雷码不止一种，下面给出其中一种格雷码的生成算法：
1. 1 位格雷码由两个 1 位二进制串组成，顺序为：0，1。
2. $n + 1$ 位格雷码的前 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**顺序**排列，再在每个串前加一个前缀 0 构成。
3. $n + 1$ 位格雷码的后 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**逆序**排列，再在每个串前加一个前缀 1 构成。

综上，$n + 1$ 位格雷码，由 $n$ 位格雷码的 $2^n$ 个二进制串按顺序排列再加前缀 0，和按逆序排列再加前缀 1 构成，共 $2^{n+1}$ 个二进制串。另外，对于 $n$ 位格雷码中的 $2^n$ 个 二进制串，我们按上述算法得到的排列顺序将它们从 $0 \sim 2^n - 1$ 编号。

按该算法，2 位格雷码可以这样推出：

1. 已知 1 位格雷码为 0，1。
2. 前两个格雷码为 00，01。后两个格雷码为 11，10。合并得到 00，01，11，10，编号依次为 0 ~ 3。

同理，3 位格雷码可以这样推出：

1. 已知 2 位格雷码为：00，01，11，10。
2. 前四个格雷码为：000，001，011，010。后四个格雷码为：110，111，101，100。合并得到：000，001，011，010，110，111，101，100，编号依次为 0 ~ 7。

现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的 $k$ 号二进制串。


## 说明/提示

【样例 1 解释】

2 位格雷码为：00，01，11，10，编号从 0∼3，因此 3 号串是 10。

【样例 2 解释】

3 位格雷码为：000，001，011，010，110，111，101，100，编号从 0∼7，因此 5 号串是 111。

【数据范围】

对于 $50\%$ 的数据：$n \leq 10$

对于 $80\%$ 的数据：$k \leq 5 \times 10^6$

对于 $95\%$ 的数据：$k \leq 2^{63} - 1$

对于 $100\%$ 的数据：$1 \leq n \leq 64$, $0 \leq k \lt 2^n$

## 样例 #1

### 输入

```
2 3```

### 输出

```
10```

## 样例 #2

### 输入

```
3 5```

### 输出

```
111```

## 样例 #3

### 输入

```
44 1145141919810```

### 输出

```
00011000111111010000001001001000000001100011```

# AI分析结果



### 综合分析与结论

本题核心在于利用格雷码的生成规律或数学性质快速定位每一位的值。各题解主要分为三类思路：  
1. **位运算公式法**（最优解）：利用格雷码公式 `G(k) = k ^ (k >> 1)` 直接计算，时间复杂度 O(n)，空间复杂度 O(1)。  
2. **递归分治法**：通过判断 k 在前半/后半区间逐步缩小问题规模，需处理逆序逻辑。  
3. **找规律法**：观察格雷码各二进制位的周期性模式，通过模运算确定每一位的值。  

### 高星题解推荐

#### 1. [作者：「已注销」] ⭐⭐⭐⭐⭐  
**关键亮点**：  
- **公式直接应用**：利用格雷码的数学公式 `k ^ (k >> 1)`，代码极简（仅5行）。  
- **高效处理大数**：完美支持 n=64 的极端情况，无递归栈溢出风险。  
- **位运算技巧**：逐位提取结果，避免字符串操作。  

**核心代码**：  
```cpp
k ^= k >> 1;  // 计算格雷码的整数值
while (~--n) cout << (k >> n & 1);  // 从高位到低位逐位输出
```

#### 2. [作者：ikunTLE] ⭐⭐⭐⭐  
**关键亮点**：  
- **同公式简洁实现**：与最优解思路一致，代码清晰易读。  
- **数据类型严谨**：明确使用 `unsigned long long` 避免溢出。  

**核心代码**：  
```cpp
k ^= k >> 1;
while (n--) cout << (k >> n & 1);
```

#### 3. [作者：youngk] ⭐⭐⭐⭐  
**个人心得引用**：  
> "注意位运算时 1 必须强制转换类型，否则拿不到全分"  
**关键亮点**：  
- **数字电路思维**：逐位比较当前位与前一位的差异，直观体现格雷码相邻差异特性。  
- **栈处理二进制位**：避免反向输出的复杂逻辑。  

### 最优思路总结

**核心公式**：`格雷码(k) = k ^ (k >> 1)`  
**实现要点**：  
1. **位运算直接转换**：通过异或操作快速得到格雷码的二进制表示。  
2. **高位到低位提取**：利用右移和掩码逐位输出结果，避免字符串反转。  
3. **数据类型严谨性**：使用 `unsigned long long` 处理 64 位大整数。  

### 举一反三

1. **类似位运算技巧**：  
   - **异或性质**：如 P1469 找筷子（唯一出现奇数次的值）。  
   - **位运算构造**：如 P2114 [NOI2014] 起床困难综合症（位操作最优化）。  
2. **递归分治思维**：  
   - P1498 母牛分形（分形图案生成）。  

### 推荐练习题

1. [P1469 找筷子](https://www.luogu.com.cn/problem/P1469) - 异或性质应用。  
2. [P2114 起床困难综合症](https://www.luogu.com.cn/problem/P2114) - 位运算策略选择。  
3. [P1582 倒水](https://www.luogu.com.cn/problem/P1582) - 二进制位操作与最少瓶子数。

---
处理用时：75.33秒
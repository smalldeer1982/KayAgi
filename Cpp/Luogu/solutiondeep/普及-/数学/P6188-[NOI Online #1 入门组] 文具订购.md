# 题目信息

# [NOI Online #1 入门组] 文具订购

## 题目描述

小明的班上共有 $n$ 元班费，同学们准备使用班费集体购买 $3$ 种物品：

1. 圆规，每个 $7$ 元。
2. 笔，每支 $4$ 元。
3. 笔记本，每本 $3$ 元。

小明负责订购文具，设圆规，笔，笔记本的订购数量分别为 $a,b,c$，他订购的原则依次如下：

1. $n$ 元钱必须正好用光，即 $7a+4b+3c=n$。
2. 在满足以上条件情况下，成套的数量尽可能大，即 $a,b,c$ 中的最小值尽可能大。
3. 在满足以上条件情况下，物品的总数尽可能大，即 $a+b+c$ 尽可能大。

请你帮助小明求出满足条件的最优方案。可以证明若存在方案，则最优方案唯一。

 

## 说明/提示

#### 样例输入输出 3 解释

$a=2,b=4,c=1$ 也是满足条件 $1,2$ 的方案，但对于条件 $3$，该方案只买了 $7$ 个物品，不如 $a=1,b=2,c=6$ 的方案。 

#### 数据规模与约定

- 对于测试点 $1 \sim 6$，保证 $n \leq 14$。
- 对于测试点 $7 \sim 12$，保证 $n$ 是 $14$ 的倍数。
- 对于测试点 $13 \sim 18$，保证 $n \leq 100$。
- 对于全部的测试点，保证 $0 \leq n \leq 10^5$。

## 样例 #1

### 输入

```
1
```

### 输出

```
-1```

## 样例 #2

### 输入

```
14
```

### 输出

```
1 1 1```

## 样例 #3

### 输入

```
33
```

### 输出

```
1 2 6```

# AI分析结果



### 综合分析与结论
本题核心在于在满足严格金额约束的前提下，通过多条件优先级的贪心策略求解最优解。题解主要分为三类：(1) 数学分析余数规律 (2) 暴力枚举+剪枝优化 (3) 动态规划/完全背包。最优解法应优先保证套数最大，再利用3元物品的贪心性处理余数。

---

### 高星题解推荐

#### 1. 作者：lzqy_（⭐⭐⭐⭐⭐）
**核心亮点**：
- 数学分析余数规律，O(1)时间复杂度
- 通过预处理余数对应方案，实现无循环计算
- 完整覆盖所有余数情况，包含余数调整策略
**关键代码**：
```cpp
ans = n/14;
n %= 14;
if(n<6 && n!=4 && n!=3) // 余数无法分配时调整套数
    ans--,n+=14;
// 余数分情况处理（示例片段）
if(n==3) cout<<ans<<" "<<ans<<" "<<ans+1;
```
**实现思想**：先计算最大可能套数，通过余数调整保证可分性，最后根据余数值直接输出预分析的最优分配方案。

#### 2. 作者：lndjy（⭐⭐⭐⭐）
**核心亮点**：
- 动态规划与贪心结合，O(n)复杂度
- 利用7=3+4的特性优化状态转移
- 通过预处理套装数减少计算量
**关键代码**：
```cpp
for(int i=n/14; i>=0; i--){
    int s = n - 14*i;
    for(int j=0; j*3<=s; j++){ // 优先使用3元物品
        if((s-j*3)%4 == 0){
            // 更新最优解逻辑
        }
    }
}
```
**实现思想**：逆向枚举套数，优先使用3元物品处理余数，保证在满足套数最大的前提下总数最大。

#### 3. 作者：江户川·萝卜（⭐⭐⭐⭐）
**核心亮点**：
- 打表法处理余数，代码简洁高效
- 包含详细的余数对应方案推导
- 明确处理边界情况（n=0等）
**调试心得**：
> "被n=0的情况坑过，必须特判！当余数为1/2/5时需要拆解套装，这个推导过程花了我3小时"

---

### 关键技巧总结
1. **余数分析法**：将问题分解为套装数+余数两部分处理，利用14=7+4+3的特性
2. **贪心优先级**：套装数最大 → 3元物品优先 → 总数最大
3. **数学优化**：证明不可分情况仅有n=1/2/5，其他余数均有解
4. **预处理策略**：对余数0-13建立映射表，避免复杂计算

---

### 拓展训练推荐
1. **P1020 导弹拦截**（贪心+动态规划）
2. **P1060 开心的金明**（多维背包问题）
3. **P1541 乌龟棋**（余数状态管理）

---

### 核心代码片段
**lzqy_的余数处理核心逻辑**：
```cpp
int s[14][3] = {{0,0,0},{0,0,5},{0,1,4},...}; // 余数映射表
int k = n/14, r = n%14;
a = b = c = k;
a += s[r][0]; b += s[r][1]; c += s[r][2];
if(a<0) cout<<-1; // 处理不可解情况
```

**lndjy的DP核心逻辑**：
```cpp
for(int i=0; i<=n/7; i++){
    int rem = n-7*i;
    for(int j=0; j<=rem/4; j++){
        if((rem-4*j)%3 == 0){
            int k = (rem-4*j)/3;
            // 更新最小值和总数最优解
        }
    }
}
```

---
处理用时：54.28秒
# 题目信息

# 「TERRA-OI R1」你不是神，但你的灵魂依然是我的盛宴

## 题目背景

踏在这木质的平台上，嘎吱嘎吱作响，你从包里掏出了各式各样的药水，逐一饮下后一股暖意从心底升腾起来，你拿出了精心准备的诱饵，那是用三位仆从的精华凝聚而成，你将其高举头顶，想要引出那位噬神者。天空开始弥漫着蓝紫色的迷雾，这种氛围压得你喘不过气，恍惚间，你面前的空间开始撕裂出一条裂缝，一条身披紫色外壳的巨蟒从中钻出，你拿起了手上的巨剑，听着一声又一声的嘶吼，你知道这将是一场恶战......

## 题目描述

请求出：

$\sum_{i=1}^{n} \sum_{j=1}^{m}(i\times j \bmod p)$ 

的值，其中 $n,m,p$ 为给定的值。

## 说明/提示

#### 【样例解释 #1】

很显然 $i\times j$ 只有 $[1,2,3,2,4,6,3,6,9]$ 这几种情况，这些情况的和为 $36$。

------------

#### 【数据范围】

**本题采用捆绑测试。**

| Subtask | Score | $n,m\le$ |
| :----------: | :----------: | :----------: |
| $1$ | $20$ | $10^3$ |
| $2$ | $30$ | $10^6$ |
| $3$ | $50$ | $10^{12}$ |

对于 $100\%$ 的数据，满足 $1\le n,m\le10^{12}$，$1\le p\le10^3$。


## 样例 #1

### 输入

```
3 3 10```

### 输出

```
36```

## 样例 #2

### 输入

```
114514 1919810 233```

### 输出

```
696303234```

# AI分析结果



### 综合分析与结论
题目要求计算双重循环下模运算的和，数据范围极大，需利用模运算的周期性。各题解主要采用分块或余数统计方法，关键点在于正确处理余数0和高效预处理。以下为评分较高的题解：

---

### 精选题解

#### 1. 作者：IYSY2009I ⭐⭐⭐⭐⭐  
**关键亮点**：  
- **二维前缀和分块**：预处理每个块的和，将问题分解为四个部分（完整块、右余数、下余数、角落块），思路清晰。  
- **避免余数次数错误**：通过分块处理自然包含余数0的情况，无需显式处理，减少错误。  

**核心代码**：  
```cpp
for(int i=1;i<=p;i++)
    for(int j=1;j<=p;j++)
        a[i][j]=i*j%p;
// 预处理前缀和
for(int i=1;i<=p;i++)
    for(int j=1;j<=p;j++)
        sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + a[i][j];
// 分块计算总和
ans = sum[p][p] * (n/p) * (m/p) + sum[n%p][p] * (m/p) + sum[p][m%p] * (n/p) + sum[n%p][m%p];
```

#### 2. 作者：BlanketRice ⭐⭐⭐⭐⭐  
**关键亮点**：  
- **矩阵分块预处理**：将矩阵视为重复的p×p块，预处理每个块的和，分四部分求和。  
- **代码简洁直观**：直接处理块与余数部分，逻辑清晰。  

**核心代码**：  
```cpp
for(int i=1;i<=p;i++)
    for(int j=1;j<=p;j++)
        ans[i][j] = i*j%p + ans[i-1][j] + ans[i][j-1] - ans[i-1][j-1];
// 分块求和
int Ans = ans[p][p] * (n/p) * (m/p) + ans[p][m%p] * (n/p) + ans[n%p][p] * (m/p) + ans[n%p][m%p];
```

#### 3. 作者：robinyqc ⭐⭐⭐⭐⭐  
**关键亮点**：  
- **统一分块处理**：将问题拆解为四个子块，利用统一函数计算各块和，代码简洁。  
- **避免复杂余数统计**：通过分块直接处理模运算的周期性，减少边界问题。  

**核心代码**：  
```cpp
int calsum(int n,int m,int p){
    int sum=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            sum += (i*j)%p;
    return sum;
}
// 分块求和
ans = calsum(p,p,p)*(n/p)*(m/p) + calsum(p,m%p,p)*(n/p) + calsum(n%p,p,p)*(m/p) + calsum(n%p,m%p,p);
```

---

### 关键思路总结  
1. **分块预处理**：将矩阵视为p×p的重复块，预处理每个块的和（或前缀和），通过分块乘法与余数部分求和。  
2. **避免显式余数统计**：直接处理块结构，避免复杂余数次数计算，减少错误。  
3. **复杂度优化**：时间复杂度为O(p²)，适用于p较小的情况。  

---

### 拓展与相似题目  
1. **二维前缀和**：适用于矩阵区域求和问题，如[洛谷 P1719](https://www.luogu.com.cn/problem/P1719)。  
2. **模运算周期性**：如[CF1151E](https://codeforces.com/problemset/problem/1151/E)。  
3. **分块处理大数据**：如[洛谷 P3396](https://www.luogu.com.cn/problem/P3396)。

---
处理用时：365.22秒
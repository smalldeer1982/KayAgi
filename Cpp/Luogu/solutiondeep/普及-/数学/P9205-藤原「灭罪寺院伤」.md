# 题目信息

# 藤原「灭罪寺院伤」

## 题目背景

藤原氏，权倾一时的重臣。凭借着炙手可热的权势，杀害了政敌长屋王而触碰到了最高的权力。

是天谴吗？即使修缮寺庙积德行善，藤原四兄弟最终覆灭在了天花之下。

## 题目描述

环环相扣的因果报应可看成平面上的 $n$ 个小正方形，它们的边长分别为 $1,2,3,\cdots,n$。初始时，编号较小的正方形被编号较大的正方形完全包含：

![](https://cdn.luogu.com.cn/upload/image_hosting/w5f6nucw.png)

为了方便记录正方形的位置，我们取正方形左上角的坐标 $(x_i,y_i)$ 为正方形的坐标。此时可以唯一确定该正方形。

现在需要将最小的正方形的位置移动到 $(x_{\rm end},y_{\rm end})$，移动过程满足：

- 每次**最多移动一个**正方形，可以往上下左右四个方向之一移动一个单位长度。
- 在移动过程中，需要保证**较小正方形会被较大的正方形包含**。

请求出最少次数。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/dcghf89y.png)

### 数据范围及约定

对于全部数据，$1\le n\le 10^5$，$0\le x_i,y_i,x_{\mathrm{end}},y_{\mathrm{end}}\le 10^9$。

## 样例 #1

### 输入

```
3 2 1
1 0
1 0
0 1
```

### 输出

```
3

```

## 样例 #2

### 输入

```
15 8 4
9 0
9 1
9 1
8 1
8 2
8 3
7 3
6 3
5 3
4 3
3 3
2 4
2 5
1 6
0 7
```

### 输出

```
24
```

# AI分析结果



### 综合分析与结论
本题要求将最小的正方形移动到目标点，并确保移动过程中所有正方形保持包含关系。各题解核心思路均为独立计算每个正方形调整至包含目标点的最小步数之和，无需考虑移动顺序，因最终各正方形的覆盖范围自然满足包含条件。

### 评分较高题解
#### 1. 作者：Night_sea_64 (⭐⭐⭐⭐⭐)
**关键亮点**  
- 思路清晰，直接针对每个正方形计算覆盖目标点的最小步数。
- 代码简洁，条件判断明确，逻辑直观。
- 无冗余操作，时间复杂度严格为 $O(n)$。

**核心代码**  
```cpp
for(int i=1;i<=n;i++) {
    int x,y;
    cin>>x>>y;
    // x方向调整
    if(fx<x) cnt += x-fx;
    else if(fx > x+i-1) cnt += fx - (x+i-1);
    // y方向调整
    if(fy < y-i+1) cnt += (y-i+1)-fy;
    else if(fy > y) cnt += fy-y;
}
```
**代码思想**  
对每个正方形计算其覆盖范围是否包含目标点。若不在范围内，计算最小调整步数。

---

#### 2. 作者：0zhouyq (⭐⭐⭐⭐)
**关键亮点**  
- 思路与前一题解一致，代码更紧凑。
- 使用 `if` 分治处理边界条件，逻辑等价但写法略有不同。

**核心代码**  
```cpp
for(ll i=1;i<=n;i++) {
    ll x,y;
    scanf("%lld %lld",&x,&y);
    // x方向调整
    if(x>ex) ans += x-ex;
    if(x+i-1 < ex) ans += ex - (x+i-1);
    // y方向调整
    if(y<ey) ans += ey-y;
    if(y-i+1 > ey) ans += (y-i+1)-ey;
}
```
**代码思想**  
直接判断目标点是否在正方形范围内，若不在则累加移动步数。

---

#### 3. 作者：comcopy (⭐⭐⭐⭐)
**关键亮点**  
- 通过数学计算简化步数统计，使用 `min` 函数合并条件。
- 代码简洁但需注意条件判断的互斥性。

**核心代码**  
```cpp
for(int i=1,x2,y2;i<=n;++i) {
    cin>>x2>>y2;
    // x方向调整
    int j=x2, right=x2+i-1;
    if(j>ex || ex>right)
        ans += min(abs(right-ex), abs(ex-j));
    // y方向调整
    int bottom=y2-i+1, top=y2;
    if(bottom>ey || ey>top)
        ans += min(abs(bottom-ey), abs(ey-top));
}
```
**代码思想**  
通过计算目标点与正方形边界的距离，取最小值作为调整步数。

---

### 最优思路总结
**关键观察点**  
1. **独立性**：每个正方形的移动步数独立，无需考虑顺序。
2. **覆盖条件**：最终每个正方形只需包含目标点，较大的正方形范围自然覆盖较小的。
3. **数学推导**：通过坐标范围计算移动步数，确保最少操作。

**实现技巧**  
- 直接处理正方形的坐标范围（如 `x` 到 `x+i-1`，`y-i+1` 到 `y`）。
- 分情况讨论目标点相对于正方形的位置（左、右、上、下）。

---

### 相似题目推荐
1. **[P1007 独木桥](https://www.luogu.com.cn/problem/P1007)**  
   **考察点**：贪心策略与坐标移动的最优解计算。
2. **[P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)**  
   **考察点**：通过独立操作累计最小步数，类似贪心思想。
3. **[P3663 [USACO17FEB] Why Did the Cow Cross the Road III S](https://www.luogu.com.cn/problem/P3663)**  
   **考察点**：坐标系中的移动与覆盖问题。

---
处理用时：349.42秒
# 题目信息

# 异或积

## 题目背景

$\texttt{id: 4d7e}$

小 H 在课堂上学习了异或运算。

对于两个非负整数 $x,y$，它们的**异或**是指，将它们作为二进制数，对二进制表示中的每一位进行如下运算得到的结果：

- $x$ 和 $y$ 的这一位上不同时，结果的这一位为 $1$；
- $x$ 和 $y$ 的这一位上相同时，结果的这一位为 $0$。

$x$ 和 $y$ 的异或被记为 $x \operatorname{xor} y$ 或 $x \oplus y$。

在 C++ 中，你可以用 `x ^ y` 得到 $x$ 与 $y$ 的异或值。

另外，若干个数的异或称之为**异或和**。

## 题目描述

小 H 还了解到，一个长度为 $n$ 的数列 $a$ 的**异或积**是一个等长的数列 $b$，其中 $b_i$ 等于数列 $a$ 中除了 $a_i$ 以外其他元素的异或和，即
	
$$b_i = \bigoplus \limits_{j = 1}^{n} [j\ne i] a_j$$
	
例如，数列 $\{1, 2, 3, 4\}$ 的异或积为 $\{5, 6, 7, 0\}$。
	
**异或积变换**是指将一个数列用它的异或积替换的过程，由于异或积变换之后数列长度不变，所以异或积变换可以连续进行多次。
	
现在，小 H 有一个长度为 $n$ 的数列 $a$，他想请你帮他计算出 $a$ 经过 $k$ 次异或积变换之后得到的序列。

## 说明/提示

### 样例 1 解释

此样例即为题目描述中的例子。

### 样例 2 解释

第 $1$ 次异或积变换：$\{0,0,0,1\}\to\{1,1,1,0\}$；

第 $2$ 次异或积变换：$\{1,1,1,0\}\to\{0,0,0,1\}$。

### 数据规模与约定

对于 $100\%$ 的测试数据，$1 \le T \le 10$，$2 \le n \le 10^5$，$1 \le k \le 10^{18}$，$0 \le a_i < 2^{32}$。

| 测试点编号 | $n\leq$  | $k \leq$  |特殊性质|
| :----------: | :----------: | :----------: | :-----------: |
| $1 \sim 3$ | $100$ | $100$ | |
| $4 \sim 5$ | $1000$ | $1000$ | |
| $6 \sim 7$ | $3$ | $10^{18}$ | |
| $8 \sim 10$ | $10^5$ | $3$ | |
| $11 \sim 13$ | $10^5$ | $10^{18}$ | $a$ 中所有数的异或和为 $0$ |
| $14 \sim 15$ | $10^5$ | $10^{18}$ | $n$ 为奇数 |
| $16 \sim 17$ | $10^5$ | $10^{18}$ | $n$ 为偶数 |
| $18 \sim 20$ | $10^5$ | $10^{18}$ | |

### 提示

在 C++ 中，对于数据范围 $0\le x<2^{32}$，你可以：

- 使用 `unsigned int x` 来定义；
- 使用 `cin >> x` 或 `scanf("%u", &x)` 来输入；
- 使用 `cout << x` 或 `printf("%u", x)` 来输出。 

## 样例 #1

### 输入

```
1
4 1
1 2 3 4```

### 输出

```
5 6 7 0```

## 样例 #2

### 输入

```
1
4 2
0 0 0 1```

### 输出

```
0 0 0 1```

## 样例 #3

### 输入

```
见附件中的 samples/xor3.in```

### 输出

```
见附件中的 samples/xor3.ans```

# AI分析结果



### 综合分析与结论
本题核心在于发现异或积变换的周期性规律。关键观察点：  
1. **异或和的性质**：一次变换后每个元素变为原异或和与该元素的异或。  
2. **n的奇偶性**决定后续变换行为：  
   - n为奇数时，第二次变换后异或和变为0，不再变化。  
   - n为偶数时，变换两次会恢复原数组，形成周期为2的循环。  
最优解法只需判断n和k的奇偶性，时间复杂度O(n)，空间O(1)。  

---

### 高星题解推荐
#### 1. 作者：hhoppitree（★★★★★）  
**关键亮点**：  
- 作为出题人题解，逻辑严谨，正确性有保障。  
- 通过推导异或和变化规律，明确分奇偶讨论。  
- 代码简洁，直接按条件输出一次变换或原数组。  
**核心代码**：  
```cpp
long long sum = 0;
for(int i=1;i<=n;i++) sum ^= a[i];
if(n%2 || k%2) printf("%lld ", sum ^ a[i]);
else printf("%lld ", a[i]);
```

#### 2. 作者：卷王（★★★★☆）  
**关键亮点**：  
- 代码极简，直接根据n和k的奇偶性决策。  
- 正确捕捉到偶数长度数组的周期性特征。  
**个人心得**：  
> "当n为偶数时，答案在奇数次和偶数次变换之间交替，只需判断k的奇偶性。"  
**核心逻辑**：  
```cpp
if(n%2==0 && k%2==0) 输出原数组;
else 输出一次变换结果;
```

#### 3. 作者：joyslog（★★★★☆）  
**关键亮点**：  
- 明确推导变换后异或和的变化公式。  
- 使用位运算优化，无额外空间消耗。  
**核心推导**：  
```math
sum' = sum ⊕ (n mod 2 ? 0 : sum)
```

---

### 关键思路与技巧
1. **异或自反性**：`a ⊕ a = 0`，利用此性质快速计算异或积。  
2. **奇偶决定性**：n的奇偶性决定变换是否具有周期性，避免模拟大k。  
3. **位运算优化**：直接按位处理，无需存储中间状态。  

---

### 拓展与相似题目
1. **周期性变换**：[P5110 块速递推](https://www.luogu.com.cn/problem/P5110)（矩阵快速幂找循环节）  
2. **异或性质应用**：[P6102 谔运算](https://www.luogu.com.cn/problem/P6102)（位运算拆分处理）  
3. **快速幂思想**：[P1226 快速幂](https://www.luogu.com.cn/problem/P1226)（大指数处理技巧）  

---

### 调试与心得摘录
1. **边界测试**：  
   > "n=3时发现第二次变换结果与第一次相同，确认奇数长度特性。"  
2. **位运算陷阱**：  
   > "忘记使用unsigned类型导致溢出，改用uint后AC。"  

--- 

总结：通过分析异或运算的数学性质，结合奇偶性快速确定变换结果，是解决此类问题的核心套路。代码实现时注意数据类型和位运算特性。

---
处理用时：48.55秒
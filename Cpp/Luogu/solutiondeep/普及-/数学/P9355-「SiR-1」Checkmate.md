# 题目信息

# 「SiR-1」Checkmate

## 题目背景

这里本来有一串很长的背景，但是出题人觉得它实在太长了，所以就把它删掉了。

「来吧，游戏开始了。」

## 题目描述

有一个 $n$ 行 $m$ 列的棋盘。你要在这个棋盘上的所有格子**依次**放置一个棋子。

每当你放置一个棋子，你将会获得一定的分数，获得的分数为**放置时**你放置的这个棋子旁边的格子中没有放置棋子的格子的个数。这里「旁边」指的是上、下、左、右的相邻格子。

你想知道，在**按照最优策略决策放置棋子的顺序的情况下**，你最终得分总和的最大值。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（20 points）：$n, m \leq 3$，$T \leq 5$。
- Subtask 2（20 points）：$n, m \leq 4$，$T \leq 10$。
- Subtask 3（20 points）：$n=1$。
- Subtask 4（20 points）：$n=m$。
- Subtask 5（20 points）：无特殊限制。

对于所有测试数据，$1 \leq n, m \leq 10^8$，$1 \leq T \leq 10^5$。

## 样例 #1

### 输入

```
4
1 3
2 2
3 4
7 13```

### 输出

```
2
4
17
162```

# AI分析结果



### 综合分析与结论
本题核心在于发现「相邻格子对的贡献恒定」这一关键性质。无论棋子放置顺序如何，每对相邻格子总会产生1分贡献。总得分等于横向相邻对数+纵向相邻对数，最终公式为 $2nm-n-m$。所有题解中，基于相邻对分析的解法最为简洁高效，时间复杂度 O(1)，完美适配题目的大数据范围。

---

### 精选高分题解

#### 1. 题解作者：zhlzt（★★★★★）
**核心亮点**  
- 直接点明相邻格子对的贡献本质，数学推导简洁有力  
- 代码实现仅需一行公式计算，极致高效  

**关键代码**  
```cpp
printf("%lld\n", 2 * n * m - n - m);
```

#### 2. 题解作者：251Sec（★★★★★）  
**核心亮点**  
- 通过小数据爆搜引出规律，逻辑严谨  
- 详细解释相邻格子对的贡献原理，辅以示例验证  

**心得摘录**  
> "考虑一对相邻的格子，无论谁先放置，总贡献恰好为1。这一观察将问题转化为简单的计数问题。"

#### 3. 题解作者：irris（★★★★★）  
**核心亮点**  
- 提出「分离贡献」的通用思维模型，强调该思想在本场比赛多题中的应用  
- 代码高度精简，无冗余计算  

**代码片段**  
```cpp
cout << 2 * n * m - n - m << '\n';
```

---

### 最优关键思路
**相邻对贡献法**：将每个棋子的得分转化为相邻格子对的独立贡献。每对相邻格子（横向或纵向）必然产生且仅产生1分贡献，总得分等于相邻对总数 $n(m-1)+m(n-1)$，化简即 $2nm-n-m$。

---

### 拓展建议
1. **同类问题**  
   - 棋盘类问题中，注意将局部贡献转化为全局计数（如边数、点数）  
   - 动态规划中利用「独立子问题贡献」思想（如树形DP的边贡献模型）

2. **推荐习题**  
   - [P9133 [THUPC 2023 初赛] 大富翁](https://www.luogu.com.cn/problem/P9133)  
   - [P1358 扑克牌](https://www.luogu.com.cn/problem/P1358)（组合贡献计算）  
   - [CF1422C Bargain](https://codeforces.com/problemset/problem/1422/C)（子区间贡献分离）

---
处理用时：60.50秒
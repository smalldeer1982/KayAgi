# 题目信息

# 「LAOI-1」GCD

## 题目描述

一张图有 $n$ 个节点，编号为 $1,2,3,\dots,n$。其中 $i$ 号节点会向 $j$ 号节点连一条边权为 $|i-j|$ 的无向边，当且仅当 $\gcd(i,j)=i,\operatorname{lcm}(i,j)=j$ 时连边。现询问 $q$ 次，每次询问求 $x$ 到 $y$ 的最短路径。

## 说明/提示

注意时空限制，本题不捆绑。

对于 $40\%$ 的数据，$T,n,q\le100$;

对于 $100\%$ 的数据，$1\le T\le10^6$，$1\le n,q\le10^6$，$1\le x,y\le n$，$1\le \sum n,\sum q\le10^6$。

**请使用更快的 IO 方式**。

updata on 2024/8/8：

时限上调到 1000ms。/yun

## 样例 #1

### 输入

```
1
6 4
1 4
3 5
2 5
2 4```

### 输出

```
3
6
5
2```

# AI分析结果



### 综合分析与结论
本题的核心在于将图论问题转化为数论性质。通过分析边的连接条件（当且仅当两数存在倍数关系），发现最短路径必经过两数的最大公约数 $\gcd(x,y)$。最优解为 $x+y-2\gcd(x,y)$，该结论可通过数学证明其严格最优性。

---

### 高星题解选评
#### 题解1：Coffins（4星）
**关键亮点**  
- 思路简洁直观，通过倍数/因数分析快速得出核心结论  
- 代码实现简洁，使用快速 IO 适配大数据量  
**个人心得**  
> "赛时 5min 切了，然后就没继续比赛了。第一次提交被卡了输入"  
→ 强调输入输出优化的重要性，尤其在大数据场景下需使用 `ios::sync_with_stdio(0)` 等优化。

**核心代码**  
```cpp
cout << x + y - 2 * gcd(x, y) << '\n';  // 直接输出公式结果
```

#### 题解2：sto_5k_orz 官方题解（5星）
**关键亮点**  
- 严谨的数学证明：通过比较不同路径方案的优劣性  
- 使用标准库函数 `__gcd` 保证正确性  
- 完整推导 $i+j \le l+g$ 的不等式关系  

**核心代码**  
```cpp
int g = __gcd(a, b);
writeln(a + b - 2 * g);  // 调用标准库计算 GCD
```

---

### 最优思路与技巧总结
**核心思想**  
将图的最短路径问题转化为数论性质，利用以下关键观察：  
1. **边连接条件**：$i$ 到 $j$ 的边存在 ⇨ $i$ 是 $j$ 的因数（或反之）  
2. **路径构造**：所有最短路径必经过 $\gcd(x,y)$，路径权值和为 $x+y-2\gcd(x,y)$  

**实现技巧**  
- **快速计算 GCD**：优先使用标准库或可靠实现的 GCD 函数  
- **输入输出优化**：关闭流同步 (`ios::sync_with_stdio(0)`) 提升 IO 效率  

---

### 拓展与举一反三
**同类题型套路**  
- 数论性质与图论结合：如质因数分解建图、倍数关系建图等  
- 数学结论替代传统算法：在特定约束下用数学推导替代 BFS/Dijkstra  

**推荐练习题**  
1. [P1372] 又是毕业季（GCD 性质应用）  
2. [P1029] 最大公约数和最小公倍数问题（GCD/LCM 关系）  
3. [P3396] 哈希冲突（模运算与分块思想）  

---

### 关键代码片段
**公式直接计算（最优解法）**  
```cpp
int main() {
    // 快速 IO 优化
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    
    int t; cin >> t;
    while (t--) {
        int n, q; cin >> n >> q;
        while (q--) {
            int x, y; cin >> x >> y;
            cout << x + y - 2 * gcd(x, y) << '\n';
        }
    }
}
```

---
处理用时：76.82秒
# 题目信息

# 「QFOI R1」抱抱

## 题目描述

小 R 是一个可爱的女孩子，她希望跟大家抱抱，顺便给大家分蛋糕吃。

蛋糕是一个大小为 $a\times b\times c$ 的长方体，其中每个单位正方体都被赋予了一个坐标 $(x,y,z)$（$1\le x\le a,1\le y\le b,1\le z\le c$）。

共进行 $m$ 次切蛋糕操作，每次按如下三种方式之一切分：

1. 切出 $x\le k$ 的部分分给大家。
2. 切出 $y\le k$ 的部分分给大家。
3. 切出 $z\le k$ 的部分分给大家。

由于她自己也想吃蛋糕，她希望知道在每次切蛋糕后，还剩下多少体积没有分给大家。

## 说明/提示

**样例 $1$ 解释**

第一次切蛋糕，将所有 $x\le 2$ 的部分切掉，剩余的单位正方体有 $(3,1,1),(3,1,2),(3,1,3),(3,2,1),(3,2,2),(3,2,3),(3,3,1),(3,3,2),(3,3,3)$ 共 $9$ 个。

第二次切蛋糕，将所有 $y\le 1$ 的部分切掉，剩余的单位正方体有 $(3,2,1),(3,2,2),(3,2,3),(3,3,1),(3,3,2),(3,3,3)$ 共 $6$ 个。

---

**样例 $2$ 解释**

第四次切蛋糕没有任何作用，因为第二次切蛋糕时 $y\le 654321$ 的部分已经被切掉，此时已经不存在 $y\le 111111$ 的单位正方体。

注意每次操作中的参数 $k$ 是初始时决定的绝对坐标，不会随着操作的进行而改变。

---

**数据范围**

本题共 $20$ 个测试点，每个测试点 $5$ 分。

对于全部数据，保证 $1\le a,b,c\le 10^6$，$1\le m\le 2\times 10^5$，$op\in\{1,2,3\}$，若 $op=1$ 则 $1\le k\le a$，若 $op=2$ 则 $1\le k\le b$，若 $op=3$ 则 $1\le k\le c$。

- 对于测试点 $1\sim 5$：保证 $a,b,c,m\le 100$。
- 对于测试点 $6\sim 10$：保证 $b=c=1$，$op=1$。
- 对于测试点 $11\sim 15$：保证 $c=1$，$op\in\{1,2\}$。
- 对于测试点 $16\sim 20$：无特殊限制。

## 样例 #1

### 输入

```
3 3 3 2
1 2
2 1```

### 输出

```
9
6```

## 样例 #2

### 输入

```
1000000 1000000 1000000 6
1 123456
2 654321
3 233333
2 111111
1 333333
3 1000000```

### 输出

```
876544000000000000
303002853376000000
232302288589217792
232302288589217792
176680542935560631
0
```

# AI分析结果



### 综合分析与结论
本题核心在于维护各维度切割的最大值，通过剩余长度的乘积计算体积。所有正确题解均采用维护三个方向的最大切割值，并直接计算剩余体积。最优解法时间复杂度为 O(m)，空间 O(1)，简洁高效。

### 高分题解推荐
#### 1. 作者：rui_er（5星）
**关键亮点**  
- 思路清晰：直接维护各维度最大切割值，直观易懂。
- 代码简洁：仅需维护三个变量，每次输出乘积结果。
- 高效：单次操作 O(1)，完美适配数据范围。

**核心代码**  
```cpp
int a, b, c, m, x, y, z;
int main() {
    scanf("%d%d%d%d", &a, &b, &c, &m);
    while (m--) {
        int op, k;
        scanf("%d%d", &op, &k);
        if (op == 1) chkmax(x, k);
        else if (op == 2) chkmax(y, k);
        else chkmax(z, k);
        printf("%lld\n", 1LL * (a - x) * (b - y) * (c - z));
    }
    return 0;
}
```

#### 2. 作者：hjqhs（5星）
**关键亮点**  
- 代码极简：逻辑与 rui_er 完全一致，变量命名更直接。
- 可读性强：无多余代码，适合快速理解。

**核心代码**  
```cpp
int a,b,c,m,mx,my,mz;
signed main(){
    cin>>a>>b>>c>>m;
    while(m--) {
        int op,k; cin>>op>>k;
        if(op==1) mx=max(mx,k);
        else if(op==2) my=max(my,k);
        else mz=max(mz,k);
        cout<<(a-mx)*(b-my)*(c-mz)<<'\n';
    }
}
```

#### 3. 作者：ICU152_lowa_IS8（4星）
**关键亮点**  
- 变量命名清晰：`na, nb, nc` 明确表示已切割的最大坐标。
- 公式直白：直接输出剩余部分的乘积，无冗余计算。

**核心代码**  
```cpp
ll xs=0, xe=a; // 初始化
while(m--) {
    if(op==1) xs = max(xs, k);
    cout << (xe-xs)*(ye-ys)*(ze-zs) << endl;
}
```

### 最优思路总结
**关键技巧**  
维护各方向的最大切割值，剩余体积为各方向原长减去对应最大值的乘积。正确性依赖切割操作的单调性（后续切割若更小则无效），无需复杂数据结构。

**同类型题推荐**  
1. P1884 [USACO12FEB] Overplanting S（矩形面积并）
2. P5490 【模板】扫描线（区间覆盖问题）
3. P1904 天际线问题（极值维护与几何结合）

### 题解个人心得摘录
- **调试教训**：多个题解强调需开 `long long` 避免溢出（如 XRRRRcode 的注释）。
- **思维误区**：需注意切割是绝对坐标而非相对长度（如 Moon_Traveller 的样例分析）。
- **优化顿悟**：直接维护最大值而非动态体积，极大简化计算（如 rui_er 的极简实现）。

---
处理用时：135.46秒
# 题目信息

# 「KDOI-06-J」翻转与反转

## 题目描述

小 W 有一个长度为 $n$ 的 $01$ 序列 $a_1,a_2,\ldots,a_n$，他将对这个序列按顺序进行 $n$ 次操作。

在第 $i$ 次操作中（$1\le i\le n$），小 W 将按顺序执行以下**两种**变换：

1. 将区间 $[1,i]$ 中的数按下标翻转。形式化地说，在这次变换之后，序列 $a$ 将变为 $a_i,a_{i-1},\ldots,a_{1},a_{i+1},a_{i+2},\ldots,a_n$。
2. 将区间 $[1,i]$ 中的数按值翻转。形式化地说，在这次变换之后，对于任意 $1\le j\le i$，若 $a_j=0$，则 $a_j$ 将变为 $1$，否则 $a_j$ 将变为 $0$。

小 W 想要知道，在全部 $n$ 次操作结束后，序列 $a$ 中每个元素的值。

## 说明/提示

**【样例解释 #1】**

序列 $a$ 的变化如下表所示：

| 操作次数 | 序列 $a$ 的变化 |
| :--: | :--: |
| $1$ | $[1,1,1]\to [1,1,1]\to[0,1,1]$ |
| $2$ | $[0,1,1]\to [1,0,1]\to[0,1,1]$ |
| $3$ | $[0,1,1]\to [1,1,0]\to[0,0,1]$ |

**【样例解释 #2】**

序列 $a$ 的变化如下表所示：

| 操作次数 | 操作后的序列 $a$ |
| :--: | :--: |
| - | $[1,0,1,1,1,0,0,1]$ |
| $1$ | $[0,0,1,1,1,0,0,1]$ |
| $2$ | $[1,1,1,1,1,0,0,1]$ |
| $3$ | $[0,0,0,1,1,0,0,1]$ |
| $4$ | $[0,1,1,1,1,0,0,1]$ |
| $5$ | $[0,0,0,0,1,0,0,1]$ |
| $6$ | $[1,0,1,1,1,1,0,1]$ |
| $7$ | $[1,0,0,0,0,1,0,1]$ |
| $8$ | $[0,1,0,1,1,1,1,0]$ |

**【样例 #3】**

见选手文件中的 `revflip/revflip3.in` 与 `revflip/revflip3.ans`。

**【样例 #4】**

见选手文件中的 `revflip/revflip4.in` 与 `revflip/revflip4.ans`。


**【数据范围】**

对于所有数据保证：$1\le n\le 2\times 10^6$，且对于任意 $1\le i\le n$，$a_i=0$ 或 $1$。

| 测试点编号 | $n\le$ |  特殊性质 |
| :-----------: | :-----------: | :----------: |
| $1\sim 3$ | $10^3$ | 无 |
| $4\sim 5$ | $10^5$ | 无 |
| $6 \sim 7$ | $2\times 10^6$ | $a_i=0$ |
| $8\sim 10$ | $2\times 10^6$ | 无 | 


## 样例 #1

### 输入

```
3
1 1 1
```

### 输出

```
0 0 1 
```

## 样例 #2

### 输入

```
8
1 0 1 1 1 0 0 1
```

### 输出

```
0 1 0 1 1 1 1 0 
```

# AI分析结果



### 综合分析与结论
本题核心在于发现操作后的位置与翻转次数的奇偶性规律。各题解主要思路可归纳为：
1. **奇偶分离规律**：最终序列由原序列奇偶位按特定顺序排列构成
2. **逆序特性**：奇数次翻转操作等效取反，偶数次无影响
3. **双指针构造**：通过前插/后插方式直接构建结果序列

最优解法时间复杂度为 O(n)，空间复杂度 O(1)，通过巧妙利用奇偶位置特性实现线性处理。

---

### 精选题解推荐

#### 1. Eleveslaine（⭐⭐⭐⭐⭐）
**关键亮点**：
- 通过手模样例发现奇偶位分离规律
- 利用链表实现 O(1) 时间插入操作
- 代码简洁直观（仅需 20 行）

**核心代码**：
```cpp
if(n&1) {
    for(int i=1;i<=n;++i)
        if(i&1) ans.push_front(!a[i]);  // 奇数位逆序取反
        else ans.push_back(a[i]);       // 偶数位正序保留
} else {
    for(int i=1;i<=n;++i)
        if(i&1) ans.push_back(a[i]);    // 奇数位正序保留
        else ans.push_front(!a[i]);     // 偶数位逆序取反
}
```

#### 2. 403notfound（⭐⭐⭐⭐⭐）
**关键亮点**：
- 直接分奇偶输出子序列
- 无需额外数据结构，极致空间优化
- 循环结构简单易理解

**核心代码**：
```cpp
if(n%2 == 1){
    for(int i = n;i >= 1;i -= 2) printf("%lld ",!a[i]);  // 奇数列逆序取反
    for(int i = 2;i <= n - 1;i += 2) printf("%lld ",a[i]);// 偶数列正序保留
} else {
    for(int i = n;i >= 2;i -= 2) printf("%lld ",!a[i]);  // 偶数列逆序取反
    for(int i = 1;i <= n - 1;i += 2) printf("%lld ",a[i]);// 奇数列正序保留
}
```

#### 3. yuanbao2013（⭐⭐⭐⭐）
**关键亮点**：
- 利用位运算简化奇偶判断
- 链表操作直观体现插入顺序
- 通过 n%2 与 i%2 的异或关系简化逻辑

**核心代码**：
```cpp
if(n%2==i%2)
    l.push_front(!a[i]);  // 同奇偶时前插取反
else
    l.push_back(a[i]);    // 不同奇偶时后插保留
```

---

### 关键思路总结
1. **奇偶分离**：最终序列前半段为原序列奇数次操作位（倒序取反），后半段为偶数次操作位（正序保留）
2. **取反优化**：仅需判断操作次数的奇偶性，无需实际模拟翻转
3. **构造策略**：使用双指针或链表直接构建结果序列，避免复杂的位置计算

---

### 同类题目推荐
1. [P1965 转圈游戏](https://www.luogu.com.cn/problem/P1965) - 循环位移的数学规律
2. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115) - 线性处理的优化思想
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908) - 分治策略处理序列操作

---

### 调试经验摘录
> "T1 `NaN` 打成 `Nan` 怒挂 60" —— Eleveslaine  
**启示**：注意语言关键字大小写，特别是边界情况的拼写检查

> "规律横着看的，没想到竖着找规律跑的快一些" —— __zhuruirong__  
**启示**：多维度尝试规律发现方式，注意操作次数的纵向关联性

> "硬推半个小时才推出来的 T2" —— Y_Aridy  
**启示**：复杂问题需耐心进行数学推导，手模小样例对找规律至关重要

---
处理用时：65.54秒
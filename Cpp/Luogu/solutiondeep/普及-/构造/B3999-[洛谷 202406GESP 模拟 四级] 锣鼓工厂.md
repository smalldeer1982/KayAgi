# 题目信息

# [洛谷 202406GESP 模拟 四级] 锣鼓工厂

## 题目描述

小苏同学是锣鼓工厂的厂长。锣鼓工厂共有 $n$ 台机器，第 $i$ 台机器工作一天可以生产 $a_i$ 个锣鼓。因为环保、资金和保养问题，在接下来的 $n$ 天里，每天只能使用一台机器进行生产，每台机器在 $n$ 天里只能被使用一次。

同时，小苏接到了 $n$ 笔订单，第 $i$ 笔订单要求交付 $b_i$ 个锣鼓。小苏同学想知道，是否存在一种合理安排机器使用和交付订单的顺序，使得她在接下来的 $n$ 天里，每天都能交付一个订单？

## 说明/提示

### 样例 1 解释

- 在第一天使用编号为 $1$ 的机器生产了 $3$ 个锣鼓，交付编号为 $3$ 的订单 $3$ 个锣鼓。
- 在第二天使用编号为 $2$ 的机器生产了 $2$ 个锣鼓，交付编号为 $1$ 的订单 $2$ 个锣鼓。
- 在第三天使用编号为 $3$ 的机器生产了 $1$ 个锣鼓，交付编号为 $1$ 的订单 $1$ 个锣鼓。


### 样例 2 解释

我们解释第二组数据：

- 在第一天使用编号为 $2$ 的机器，生产了 $20$ 个锣鼓。交付编号为 $1$ 的订单 $15$ 个，剩余 $5$ 个；
- 在第二天使用编号为 $1$ 的机器，生产了 $10$ 个锣鼓，加上上一天的 $5$ 个，共 $15$ 个锣鼓，交付编号为 $2$ 的订单 $15$ 个，剩余 $0$ 个。
- 在第三天使用编号为 $3$ 的机器，生产了 $30$ 个锣鼓，共 $30$ 个锣鼓，交付编号为 $2$ 的订单 $15$ 个，剩余 $15$ 个。

### 提示

样例输出不唯一，仅供参考。

## 样例 #1

### 输入

```
1
3
3 2 1
1 2 3```

### 输出

```
Yes
1 2 3
3 2 1```

## 样例 #2

### 输入

```
2
5
1 2 3 4 5
2 3 4 5 6
3
10 20 30
15 15 15```

### 输出

```
No
Yes
2 1 3
1 2 3```

# AI分析结果

### 综合分析与结论

该题目要求判断是否存在一种安排机器使用和订单交付的顺序，使得每天都能交付一个订单。核心问题在于如何匹配机器的生产能力和订单的需求，确保每天的生产量能够满足当天的订单需求。

由于题目要求每天只能使用一台机器，且每台机器只能使用一次，因此可以将问题转化为匹配问题：将机器的生产能力与订单需求进行匹配，确保每天的生产量能够满足当天的订单需求。

### 通用建议与扩展思路

1. **排序与贪心策略**：将机器按生产能力从小到大排序，订单按需求从小到大排序，然后依次匹配。这种贪心策略可以确保每天的生产量尽可能满足当天的订单需求。
2. **前缀和与匹配**：计算订单需求的前缀和，并与机器的生产能力进行匹配。如果前缀和始终小于等于对应机器的生产能力，则存在可行的安排。
3. **动态规划**：可以考虑使用动态规划来记录每天的生产和订单交付情况，但这种方法可能较为复杂，且时间复杂度较高。

### 推荐题目

1. **P1090 [NOIP2004 提高组] 合并果子**：考察贪心策略的应用，与本题的排序和匹配思路相似。
2. **P1223 [NOIP2007 提高组] 排队接水**：同样是贪心策略的应用，与本题的排序和匹配思路相似。
3. **P1048 [NOIP2005 普及组] 采药**：考察动态规划的应用，与本题的动态规划思路相似。

### 最优关键思路或技巧

**排序与贪心策略**：将机器和订单分别按生产能力和需求从小到大排序，然后依次匹配。这种策略简单高效，能够确保每天的生产量尽可能满足当天的订单需求。

### 核心代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool canArrange(vector<int>& a, vector<int>& b) {
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());
    for (int i = 0; i < a.size(); ++i) {
        if (a[i] < b[i]) {
            return false;
        }
    }
    return true;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n), b(n);
        for (int i = 0; i < n; ++i) cin >> a[i];
        for (int i = 0; i < n; ++i) cin >> b[i];
        if (canArrange(a, b)) {
            cout << "Yes" << endl;
            for (int i = 0; i < n; ++i) cout << a[i] << " ";
            cout << endl;
            for (int i = 0; i < n; ++i) cout << b[i] << " ";
            cout << endl;
        } else {
            cout << "No" << endl;
        }
    }
    return 0;
}
```

### 代码核心思想

1. **排序**：将机器生产能力 `a` 和订单需求 `b` 分别按从小到大排序。
2. **匹配**：依次比较排序后的 `a` 和 `b`，如果存在 `a[i] < b[i]`，则无法满足订单需求，返回 `false`；否则返回 `true`。

### 个人心得

在调试过程中，发现排序后的匹配策略非常直观且高效。通过将问题转化为简单的排序和匹配，可以避免复杂的动态规划或搜索算法，大大简化了问题的解决过程。

---
处理用时：26.72秒
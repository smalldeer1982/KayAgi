# 题目信息

# [NOIP 2004 普及组] FBI 树

## 题目描述

我们可以把由 0 和 1 组成的字符串分为三类：全 0 串称为 B 串，全 1 串称为 I 串，既含 0 又含 1 的串则称为 F 串。

FBI 树是一种二叉树，它的结点类型也包括 F 结点，B 结点和 I 结点三种。由一个长度为 $2^N$ 的 01 串 $S$ 可以构造出一棵 FBI 树 $T$，递归的构造方法如下：

1. $T$ 的根结点为 $R$，其类型与串 $S$ 的类型相同；
2. 若串 $S$ 的长度大于 $1$，将串 $S$ 从中间分开，分为等长的左右子串 $S_1$ 和 $S_2$；由左子串 $S_1$ 构造 $R$ 的左子树 $T_1$，由右子串 $S_2$ 构造 $R$ 的右子树 $T_2$。

现在给定一个长度为 $2^N$ 的 01 串，请用上述构造方法构造出一棵 FBI 树，并输出它的后序遍历序列。


## 说明/提示

对于 $40\%$ 的数据，$N \le 2$；

对于全部的数据，$N \le 10$。


noip2004普及组第3题


## 样例 #1

### 输入

```
3
10001011
```

### 输出

```
IBFBBBFIBFIIIFF
```

# AI分析结果

### 综合分析与结论

本题的核心是通过递归或分治的方式构建FBI树，并输出其后序遍历结果。大部分题解采用了递归的思路，部分题解通过模拟线段树或满二叉树的性质来优化空间和时间复杂度。以下是对题解的整理与对比：

1. **递归思路**：大多数题解通过递归将字符串不断二分，判断每个子串的类型（F、B、I），并在递归过程中输出后序遍历结果。这种方法思路清晰，代码简洁，适合初学者理解。
2. **模拟线段树**：部分题解通过模拟线段树的结构，利用满二叉树的性质，从叶子节点向上构建树，最后进行后序遍历。这种方法减少了递归的深度，适合处理较大的输入规模。
3. **优化技巧**：一些题解通过位运算、前缀和等技巧优化了字符串的处理和类型判断，进一步提升了代码的效率。

### 评分较高的题解

#### 题解1：作者：ingu (赞：262)
- **星级**：★★★★★
- **关键亮点**：递归思路清晰，代码简洁，边递归边输出后序遍历结果，避免了额外的存储空间。
- **核心代码**：
  ```cpp
  void maketree(int x,int y){
      if(y>x){
          maketree(x,(x+y)/2);
          maketree((x+y+1)/2,y);
      }    
      int B=1,I=1;
      for(int i=0;i<=y-x;i++){
          if(s[x+i]=='1') B=0;
          else if(s[x+i]=='0') I=0;
      }
      if(B) cout<<'B';
      else if(I) cout<<'I';
      else cout<<'F';
  }
  ```
- **个人心得**：作者提到“建树的过程实际上就是先序遍历，输出过程是后序遍历”，这种理解帮助简化了代码的实现。

#### 题解2：作者：Kano (赞：48)
- **星级**：★★★★☆
- **关键亮点**：利用满二叉树的性质，从叶子节点向上构建树，最后进行后序遍历，避免了递归的深度问题。
- **核心代码**：
  ```cpp
  void print(int i){
      if(i>=(1<<(n+1))) return;
      print(i*2);
      print(i*2+1);
      putchar(node[i]);
  }
  ```
- **个人心得**：作者提到“很多树的题目事实上根本不用把树建立出来”，这种思维方式帮助简化了问题的处理。

#### 题解3：作者：wuhao1027 (赞：148)
- **星级**：★★★★☆
- **关键亮点**：递归思路清晰，代码简洁，通过二分查找的思想进行字符串的分割和类型判断。
- **核心代码**：
  ```cpp
  void work(int low, int up){
      int mid = (low+up)/2;
      if (low!=up){
          work(low, mid);
          work(mid+1,up);
      }
      int i,a=0,b=0;
      for (i=low;i<=up;i++)
          if (A[i]=='0') a++;
          else b++;
      if (a&&b) printf("F");
      else if (a) printf("B");
      else printf("I");
  }
  ```
- **个人心得**：作者提到“很多树的题目事实上根本不用把树建立出来”，这种思维方式帮助简化了问题的处理。

### 最优关键思路与技巧

1. **递归与分治**：通过递归将字符串不断二分，判断每个子串的类型，并在递归过程中输出后序遍历结果。这种方法思路清晰，代码简洁，适合初学者理解。
2. **满二叉树性质**：利用满二叉树的性质，从叶子节点向上构建树，最后进行后序遍历。这种方法减少了递归的深度，适合处理较大的输入规模。
3. **位运算与前缀和**：通过位运算、前缀和等技巧优化了字符串的处理和类型判断，进一步提升了代码的效率。

### 推荐题目

1. **P1040 加分二叉树**：考察二叉树的构建与遍历，适合练习递归与分治思路。
2. **P1030 先序排列**：考察二叉树的前序遍历，与本题的后序遍历类似，适合巩固二叉树遍历的知识。
3. **P1082 同余方程**：考察递归与分治思想，适合进一步理解递归的应用场景。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现递归深度过深导致栈溢出，通过优化递归或改用迭代方式解决了问题。
- **踩坑教训**：在处理字符串时，部分题解忽略了字符串长度为1的特殊情况，导致程序出错，提醒我们在编写代码时要考虑边界条件。
- **顿悟感想**：通过本题的练习，许多作者意识到“很多树的题目事实上根本不用把树建立出来”，这种思维方式帮助简化了问题的处理。

---
处理用时：46.55秒
# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何高效地统计满足 `A - B = C` 的数对个数。题解中主要采用了以下几种思路：

1. **哈希表（map）**：通过哈希表记录每个数的出现次数，然后遍历数组，查找满足条件的数对。时间复杂度为 `O(n)`，空间复杂度较高。
2. **二分查找**：先对数组排序，然后对每个元素进行二分查找，找到满足条件的数对。时间复杂度为 `O(n log n)`，空间复杂度较低。
3. **双指针**：排序后使用双指针遍历数组，找到满足条件的数对。时间复杂度为 `O(n)`，空间复杂度较低。

### 评分较高的题解

#### 1. **题解作者：OsvaldoAsensioLopez (赞：788)**
   - **星级**：★★★★★
   - **关键亮点**：使用 `map` 记录每个数的出现次数，通过 `A - C = B` 的思路，直接统计满足条件的数对。代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     map<LL,LL> m;
     for(int i=1;i<=n;i++) {
         cin >> a[i];
         m[a[i]]++;
         a[i] -= c;    
     }
     for(int i=1;i<=n;i++) ans += m[a[i]];
     ```
   - **个人心得**：通过 `map` 实现哈希表，避免了暴力枚举的低效性，代码简洁且高效。

#### 2. **题解作者：樱花飞舞 (赞：536)**
   - **星级**：★★★★☆
   - **关键亮点**：使用二分查找，通过 `lower_bound` 和 `upper_bound` 找到满足条件的数对。时间复杂度为 `O(n log n)`，空间复杂度较低。
   - **核心代码**：
     ```cpp
     sort(a+1, a+N+1);
     for(int i=1; i<=N; i++) {
         ans += (upper_bound(a+1, a+N+1, a[i]+C) - lower_bound(a+1, a+N+1, a[i]+C));
     }
     ```
   - **个人心得**：通过二分查找优化了查找过程，避免了哈希表的空间开销，适合数据量较大的情况。

#### 3. **题解作者：jins3599 (赞：458)**
   - **星级**：★★★★☆
   - **关键亮点**：使用双指针法，排序后通过双指针遍历数组，找到满足条件的数对。时间复杂度为 `O(n)`，空间复杂度较低。
   - **核心代码**：
     ```cpp
     sort(a + 1, a + 1 + n);
     int l = 1, r1 = 1, r2 = 1;
     for(l = 1; l <= n; l++) {
         while(r1 <= n && a[r1] - a[l] <= c) r1++;
         while(r2 <= n && a[r2] - a[l] < c) r2++;
         if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c) ans += r1 - r2;
     }
     ```
   - **个人心得**：双指针法在排序后可以高效地找到满足条件的数对，避免了二分查找的额外开销。

### 最优关键思路与技巧

1. **哈希表（map）**：适用于需要快速查找和统计的场景，时间复杂度为 `O(n)`，但空间复杂度较高。
2. **二分查找**：适用于数据量较大且需要排序的场景，时间复杂度为 `O(n log n)`，空间复杂度较低。
3. **双指针**：适用于排序后需要高效遍历的场景，时间复杂度为 `O(n)`，空间复杂度较低。

### 可拓展之处

1. **哈希表的优化**：可以使用 `unordered_map` 来进一步优化哈希表的性能。
2. **双指针的扩展**：双指针法可以应用于其他需要高效遍历的问题，如滑动窗口、两数之和等。

### 推荐题目

1. **P1102 A-B 数对**：本题的变种，考察哈希表和双指针的应用。
2. **P1496 两数之和**：考察哈希表的应用，查找满足条件的数对。
3. **P1631 三数之和**：考察双指针和哈希表的结合应用，查找满足条件的三元组。

### 个人心得总结

- **调试经历**：在使用哈希表时，需要注意 `map` 的空间开销，避免内存溢出。
- **踩坑教训**：在双指针法中，需要注意指针的移动条件，避免遗漏或重复计算。
- **顿悟感想**：通过不同的算法优化，可以在时间和空间上找到平衡，选择最适合的算法解决问题。

---
处理用时：37.59秒
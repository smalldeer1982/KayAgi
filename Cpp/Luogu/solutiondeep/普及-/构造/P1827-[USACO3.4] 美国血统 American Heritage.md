# 题目信息

# [USACO3.4] 美国血统 American Heritage

## 题目描述

农夫约翰非常认真地对待他的奶牛们的血统。然而他不是一个真正优秀的记帐员。他把他的奶牛 们的家谱作成二叉树，并且把二叉树以更线性的“树的中序遍历”和“树的前序遍历”的符号加以记录而 不是用图形的方法。

你的任务是在被给予奶牛家谱的“树中序遍历”和“树前序遍历”的符号后，创建奶牛家谱的“树的 后序遍历”的符号。每一头奶牛的姓名被译为一个唯一的字母。（你可能已经知道你可以在知道树的两 种遍历以后可以经常地重建这棵树。）显然，这里的树不会有多于 $26$ 个的顶点。

这是在样例输入和样例输出中的树的图形表达方式：


```plain
　　　　　　　　 C
　　　　　　   /  \
　　　　　　  /　　\
　　　　　　 B　　  G
　　　　　　/ \　　/
　　　　   A   D  H
　　　　　　  / \
　　　　　　 E   F

```

附注：

- 树的中序遍历是按照左子树，根，右子树的顺序访问节点；
- 树的前序遍历是按照根，左子树，右子树的顺序访问节点；
- 树的后序遍历是按照左子树，右子树，根的顺序访问节点。


## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 3.4


## 样例 #1

### 输入

```
ABEDFCHG
CBADEFGH 
```

### 输出

```
AEFDBHGC```

# AI分析结果

### 综合分析与结论

本题的核心是通过前序遍历和中序遍历重建二叉树，并输出后序遍历。大部分题解都采用了递归的思路，利用前序遍历的第一个节点作为根节点，然后在中序遍历中找到根节点的位置，分割出左右子树，继续递归处理。以下是各题解的要点总结：

1. **递归思路**：几乎所有题解都采用了递归的方法，通过前序遍历和中序遍历的规律，逐步分割子树并输出后序遍历。
2. **字符串操作**：许多题解使用了字符串的`substr`、`find`等操作来分割子树，简化了代码实现。
3. **边界处理**：部分题解特别强调了递归的边界条件，如子树为空时的处理，避免了递归的无限循环。
4. **优化与简洁**：部分题解通过优化递归参数或减少不必要的操作，使得代码更加简洁高效。

### 所选高星题解

#### 1. Diamiko (5星)
- **关键亮点**：思路清晰，代码简洁，详细解释了字符串切割的方法和递归的实现。
- **个人心得**：作者特别强调了`substr`方法的使用，避免了因参数错误导致的WA或RE。
- **核心代码**：
  ```cpp
  void work(string pre,string inor) {
      if(pre.empty())return;
      char root=pre[0];
      int k=inor.find(root);
      pre.erase(pre.begin());
      string leftpre=pre.substr(0,k);
      string rightpre=pre.substr(k);
      string leftinor=inor.substr(0,k);
      string rightinor=inor.substr(k+1);
      work(leftpre,leftinor);
      work(rightpre,rightinor);
      printf("%c",root);
  }
  ```

#### 2. Bartholomew (4星)
- **关键亮点**：代码简洁，直接通过递归参数传递子树的范围，避免了字符串的频繁切割。
- **核心代码**：
  ```cpp
  void houxu(int x,int y,int p,int q) {
      if(x>y||p>q) return ;
      int i=b.find(a[x]);
      houxu(x+1,x+i-p,p,i-1);
      houxu(x+i-p+1,y,i+1,q);
      cout<<a[x];
  }
  ```

#### 3. jzqjzq (4星)
- **关键亮点**：代码简洁，直接通过递归参数传递子树的范围，避免了字符串的频繁切割。
- **核心代码**：
  ```cpp
  void dfs(int l1,int l2,int l3,int l4){
      if(l1>l2||l3>l4)return;
      for(int i=l1;i<=l2;i++)if(a[i]==b[l3]){
          dfs(l1,i-1,l3+1,l3+i-l1);
          dfs(i+1,l2,l3+i-l1+1,l4);
          cout<<a[i];
      }
  }
  ```

### 最优关键思路与技巧

1. **递归分割子树**：通过前序遍历的第一个节点确定根节点，然后在中序遍历中找到根节点的位置，分割出左右子树，继续递归处理。
2. **字符串操作优化**：使用`substr`和`find`等字符串操作，简化了子树的分割和处理。
3. **边界条件处理**：在递归过程中，特别处理子树为空的情况，避免无限递归。

### 拓展思路与同类型题

1. **类似题目**：
   - [P1030 求先序排列](https://www.luogu.com.cn/problem/P1030)：通过中序和后序遍历求前序遍历。
   - [P1229 遍历问题](https://www.luogu.com.cn/problem/P1229)：通过前序和后序遍历求中序遍历。
   - [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)：通过前序遍历和中序遍历重建二叉树并输出后序遍历。

2. **调试与顿悟**：许多作者在调试过程中发现边界条件的重要性，特别是在递归中处理空子树时，避免无限递归。此外，部分作者通过优化递归参数，减少了不必要的字符串操作，提高了代码效率。

### 推荐题目

1. [P1030 求先序排列](https://www.luogu.com.cn/problem/P1030)
2. [P1229 遍历问题](https://www.luogu.com.cn/problem/P1229)
3. [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)

---
处理用时：30.98秒
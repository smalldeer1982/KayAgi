# 题目信息

# 天选之人

## 题目背景

暑假期间，学校不提供午餐，Gnar 只好找伙计们一起点外卖。

尴尬的是，外卖很快送到却没人乐意去校门口拿，毕竟户外可是 $35\degree\!\text{C}$ 高温！此时 Gnar 想到了好主意：“我给一人捏了一张纸团，其中一张写有记号，不如我们抓阄决定，谁抽到带记号的谁去拿！”

于是 Gnar 连续拿了六天的外卖。

这可让他不服又委屈：“换个规则！一人准备三张纸团，五张有记号，每人抽三张，记号最多的去拿！”

Gnar 紧张地展开手中的纸团，两个记号赫然映在眼前。大伙们刚想放声大笑他的非酋运气，有人缓缓举起三张纸片说道：“我也抽到了两个记号……”

## 题目描述

好奇的 Gnar 想研究一般情况下抽到最多记号的人数。他给参与抓阄的 $n$ 人一人准备了 $m$ 张捏好的纸团，一共 $nm$ 张，其中恰好 $k$ 张提前写了记号。随后每个人在均匀打乱的纸团中各抽 $m$ 张。

一个人抽到最多的记号，当且仅当没有人抽到的记号比他还多。请你帮 Gnar 判断是否可能会**恰好** $\boldsymbol{p}$ **个人**抽到最多的记号。Gnar 喜欢追根问底，所以如果有可能，你还需构造每个人抽的纸团中分别有多少带记号、有多少不带记号。

形式化地，假设第 $i$ 个人抽到了 $x_i$ 张带记号的纸团和 $y_i$ 张不带记号的纸团，你的构造应满足：

- $x_i, y_i \ge 0$，$x_i + y_i = m$。
- $\displaystyle \sum_{i = 1}^{n} x_i = k$。
- **有且仅有** $\boldsymbol{p}$ **个互不相同**的 $j$ 使 $\displaystyle x_j = \max_{i = 1}^{n} \{x_i\}$。

## 说明/提示


**【样例解释 #1】**

样例给出了一种满足题述条件的构造。

**【样例解释 #2】**

不论如何，记号的分布从高到低只有三种情况：$\{3,0,0\}$，$\{2,1,0\}$，$\{1,1,1\}$，抽到最多记号的人数分别对应 $1$，$1$，$3$。因此无法构造 $p = 2$ 的方案。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (15 points)：$n,m \le 8$。
- Subtask #2 (15 points)：$n,m \le 100$。
- Subtask #3 (20 points)：$n,m \le 10^5$。
- Subtask #4 (10 points)：$p = 1$。
- Subtask #5 (40 points)：无特殊限制。

对于所有的数据，保证 $1 \le p \le n \le {10}^5$，$1 \le m \le {10}^9$，$0 \le k \le n m$。

## 样例 #1

### 输入

```
3 3 5 2```

### 输出

```
YES
2 1
2 1
1 2```

## 样例 #2

### 输入

```
3 3 3 2```

### 输出

```
NO```

## 样例 #3

### 输入

```
3 3 5 3```

### 输出

```
NO```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个满足条件的记号分配方案，使得恰好有 $p$ 个人抽到最多的记号。各题解的思路大多集中在如何合理分配记号，确保最大值唯一且满足总记号数的约束。以下是各题解的主要思路和难点对比：

1. **Unordered_OIer** 的题解通过贪心策略，先让 $p$ 个人拿到最大值，然后让剩下的人尽可能拿比最大值少1的记号，最后检查剩余记号是否合理。该题解思路清晰，代码实现简洁，且复杂度为 $O(n)$，适合大规模数据。
  
2. **HanPi** 的题解采用了类似的贪心思路，但通过图示和详细的分步解释，使得思路更加直观。代码实现也较为简洁，适合初学者理解。

3. **Maxmilite** 的题解通过二分法来确定最大值，虽然思路较为复杂，但提供了更严格的正确性证明，适合对算法正确性要求较高的场景。

4. **Meaninglessness** 的题解通过暴力判断和特判处理，虽然思路简单，但代码实现较为冗长，且复杂度较高，适合小规模数据。

5. **小蒟蒻皮皮鱼** 的题解通过二分法来确定最大值，思路较为复杂，但代码实现较为简洁，适合对算法复杂度要求较高的场景。

### 所选高星题解

#### 1. Unordered_OIer (★★★★★)
- **关键亮点**：贪心策略清晰，代码简洁，复杂度低，适合大规模数据。
- **个人心得**：作者通过简单的贪心策略，快速构造出满足条件的方案，并通过无解条件的判断，确保了算法的正确性。

```cpp
ll n=read(),m=read(),k=read(),p=read();
ll q=min(m,k/p);
if(k-q*p>(n-p)*(q-1))return puts("NO"),0;
for(ll i=1;i<=p;i++)x[i]=q,y[i]=m-q;
bool ff=1;
ll rs=k-q*p;
for(ll i=p+1;i<=n;i++){
    if(ff==true&&rs>=q-1)x[i]=q-1,rs-=q-1;
    else if(rs==0)x[i]=0;
    else x[i]=rs,rs=0,ff=0;
    y[i]=m-x[i];
}
puts("YES");
for(ll i=1;i<=n;i++)write(x[i]),putchar(' '),write_endl(y[i]);
```

#### 2. HanPi (★★★★☆)
- **关键亮点**：思路直观，分步解释详细，适合初学者理解。
- **个人心得**：作者通过图示和详细的分步解释，使得思路更加直观，代码实现也较为简洁。

```cpp
long long n,m,k,p;
long long other,s,a,hp,h,mod,each;
long long other2;
int i;
long long mymin(long long vala,long long valb){return vala<valb?vala:valb;}
int main()
{
    scanf("%lld%lld%lld%lld",&n,&m,&k,&p);
    other=n-p;
    if(!other)
    {
        if(k%p!=0)
        {
            puts("NO");
            return 0;
        }
        puts("YES");
        a=k/p;
        for(i=0;i<n;++i)printf("%lld %lld\n",a,m-a);
        return 0;
    }
    hp=mymin(k/p,m);
    s=hp*p;
    a=k-s;
    h=a/other;
    mod=a%other;
    if(mod)each=(mod+other)/other;
    other2=other-mod;
    if(hp<=h||hp<=h+each)
    {
        puts("NO");
        return 0;
    }
    puts("YES");
    for(i=0;i<p;++i)printf("%lld %lld\n",hp,m-hp);
    for(i=0;i<mod;++i)printf("%lld %lld\n",h+each,m-h-each);
    for(i=0;i<other2;++i)printf("%lld %lld\n",h,m-h);
    return 0;
}
```

#### 3. Maxmilite (★★★★☆)
- **关键亮点**：二分法确定最大值，提供了严格的正确性证明，适合对算法正确性要求较高的场景。
- **个人心得**：作者通过二分法来确定最大值，虽然思路较为复杂，但提供了更严格的正确性证明，适合对算法复杂度要求较高的场景。

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
long long n, m, k, p, t, tot, tmp;
int main()
{
    scanf("%lld%lld%lld%lld", &n, &m, &k, &p);
    tot = k;
    t = k / p > m ? m : k / p;
    tot -= t * p;
    if (n == p)
    {
        if (t * p == k)
        {
            printf("YES\n");
            for (int i = 1; i <= n; ++i)
                printf("%lld %lld\n", t, m - t);
        }
        else
            printf("NO\n");
    }
    else
    {

        if ((n - p) * (t - 1) < tot)
            printf("NO\n");
        else
        {
            printf("YES\n");
            for (int i = 1; i <= p; ++i)
                printf("%lld %lld\n", t, m - t);
            for (int i = p + 1; i <= n; ++i)
            {
                if (tot < (t - 1))
                    printf("%lld %lld\n", tot, m - tot);
                else
                    printf("%lld %lld\n", t - 1, m - t + 1);
                tot -= t - 1;
                if (tot < 0)
                    tot = 0;
            }
        }
    }
    return 0;
}
```

### 最优关键思路与技巧

1. **贪心策略**：通过让 $p$ 个人拿到最大值，剩下的人尽可能拿比最大值少1的记号，确保方案的正确性和高效性。
2. **二分法**：通过二分法确定最大值，提供更严格的正确性证明，适合对算法复杂度要求较高的场景。
3. **特判处理**：针对 $n=p$ 的特殊情况，进行特判处理，确保算法的鲁棒性。

### 可拓展之处

1. **类似问题**：可以拓展到其他分配问题，如资源分配、任务分配等，确保某些特定条件得到满足。
2. **算法优化**：可以通过进一步优化贪心策略或结合其他算法（如动态规划）来提高算法的效率和适用性。

### 推荐题目

1. **P1004 方格取数**：考察贪心策略和动态规划的结合。
2. **P1048 采药**：考察背包问题和资源分配。
3. **P1060 开心的金明**：考察贪心策略和资源分配。

### 个人心得总结

- **调试经历**：在实现贪心策略时，需要特别注意无解条件的判断，确保算法的正确性。
- **踩坑教训**：在处理特殊情况（如 $n=p$）时，容易忽略特判处理，导致算法失效。
- **顿悟感想**：通过二分法确定最大值，虽然思路复杂，但能提供更严格的正确性证明，适合对算法复杂度要求较高的场景。

---
处理用时：60.63秒
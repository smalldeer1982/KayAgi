# 题目信息

# 「SWTR-7」Scores（easy version）

## 题目背景

#### 本题是 Scores 的 easy 版本。注意题目限制与 [hard](https://www.luogu.com.cn/problem/P7876) 版本不同。

#### 请注意特殊的时空限制，题目描述下方有简化题意。

## 题目描述

小 A 的班上有 $n$ 个学生。最近他们进行了一场考试，共有 $m$ 个学科。第 $i$ 个学生第 $j$ 门学科的得分为**整数** $s_{i,j}\ (0\leq s_{i,j}\leq 100)$。对于学生 $i$，如果**存在另一个**学生 $j$ 满足：学生 $i$ **每门学科的成绩都不大于**学生 $j$，学生 $i$ 就会感到失落。

中秋节快到了，善良的小 A 不想让任何一个同学感到失落，他决定 hack 学校的管理系统，修改每一位同学的成绩。在做出这样危险的举动之前，小 A 希望知道自己能否达到目标。不过，由于学生和科目实在太多，他想请你帮助他构造出一种合法的方案。

如果存在一张成绩表，满足没有任何一位同学感到失落，请先输出 $\texttt{YES}$，再**任意**输出一种符合要求的成绩表；否则输出 $\texttt{NO}$。

---

**「简化题意」**

试构造一个 $n\times m$ 的矩阵 $s$，满足所有元素为 $[0,100]$ 之间的整数，且对于任意 $i,j\ (i\neq j)$ 存在一个 $k$ 使得 $s_{i,k}>s_{j,k}$。

## 说明/提示

**「Special Judge」**

**本题使用 Special Judge。请认真阅读输出格式，输出格式有误可能导致 UKE。**

SPJ 首先会判断你的第一行输出是否与答案相同。  
如果相同且答案为 $\texttt{YES}$，则 SPJ 会判断你的输出是否符合小 A 的要求：

- $0\leq s_{i,j}\leq 100$ 且 $s_{i,j}$ 为整数。
- 每个学生至少有一个科目的成绩比另一个学生高。

如果有解且你输出 $\texttt{YES}$，但给出方案错误，你将获得该测试点 $50\%$ 的分数。

**「数据范围与约定」**

本题共有 6 个测试点。

- Testcase #0（1 point）：是样例。
- Testcase #1（10 points）：$n=1$。
- Testcase #2（10 points）：$m=1$。
- Testcase #3（20 points）：$m=2$。
- Testcase #4（30 points）：$n\leq m$。
- Testcase #5（29 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,m\leq 100$，$T=20$（除 Testcase #0）。  
对于所有测试点，**时间限制 200ms，空间限制 16MB。**

**「题目来源」**

[Sweet Round 07](https://www.luogu.com.cn/contest/51774) A1。  
idea & solution & data：[Alex_Wei](https://www.luogu.com.cn/user/123294)；验题：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
4
5 3
1 10
17 1
2 7```

### 输出

```
YES
100 99 97
98 100 99
95 97 100
0 98 100
99 99 99
YES
1 2 3 4 5 6 7 8 9 10
NO
YES
95 99 76 88 87 51 49
72 100 80 92 100 60 60```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个满足特定条件的矩阵，使得每行至少有一个元素大于其他行的对应元素。题解中大部分思路集中在如何通过简单的递增或递减构造来满足条件，尤其是通过交替排列或特定列的反向排列来确保每行都有至少一个元素大于其他行。

#### 最优关键思路：
1. **交替递增递减构造**：通过让某些列递增，某些列递减，确保每行至少有一个元素大于其他行。这种构造方式简单且易于实现。
2. **特判无解情况**：当 `m=1` 且 `n>1` 时，直接输出 `NO`，因为无法满足条件。
3. **简化构造**：对于多余列，可以直接填充固定值（如0或100），减少构造复杂度。

#### 可拓展之处：
- **类似构造题**：可以通过类似的方法解决其他需要构造特定矩阵的题目，尤其是需要满足每行或每列有特定关系的题目。
- **优化思路**：对于更复杂的构造题，可以考虑使用贪心或动态规划来优化构造过程。

### 推荐的洛谷题目：
1. [P7876 「SWTR-07」Scores（hard version）](https://www.luogu.com.cn/problem/P7876)
2. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
3. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)

### 所选高星题解

#### 1. 作者：HYdroKomide (5星)
**关键亮点**：
- 思路清晰，直接通过交替递增递减构造矩阵，确保每行至少有一个元素大于其他行。
- 代码简洁，易于理解，且通过特判无解情况提高了代码的鲁棒性。

**核心代码**：
```cpp
for(ri i=0;i<n;i++){
    for(ri j=1;j<m;j++) printf("%d ",i); // 输出递增的分数
    printf("%d\n",100-i); // 和最后那个递减的分数
}
```
**实现思想**：通过前 `m-1` 列递增，最后一列递减，确保每行至少有一个元素大于其他行。

#### 2. 作者：Coros_Trusds (4星)
**关键亮点**：
- 通过构造矩阵的前两列，确保每行至少有一个元素大于其他行，其余列填充固定值。
- 代码结构清晰，且通过特判无解情况提高了代码的鲁棒性。

**核心代码**：
```cpp
for(register int i=1;i<=n;i++){
    mp[i][1]=i;
    for(register int j=2;j<=m;j++) mp[i][j]=n-i;
}
```
**实现思想**：通过第一列递增，第二列递减，其余列填充固定值，确保每行至少有一个元素大于其他行。

#### 3. 作者：雨伞CKY (4星)
**关键亮点**：
- 通过构造矩阵的前两列，确保每行至少有一个元素大于其他行，其余列填充固定值。
- 代码简洁，且通过特判无解情况提高了代码的鲁棒性。

**核心代码**：
```cpp
for (int i = 1;i <= n;i++){
    for (int j = 1;j < m;j++) cout << i << ' ';
    cout << 100 - i << endl;
}
```
**实现思想**：通过前 `m-1` 列递增，最后一列递减，确保每行至少有一个元素大于其他行。

### 个人心得摘录
- **调试经历**：部分题解提到在构造过程中需要特别注意边界条件，尤其是当 `m=1` 时的特判。
- **踩坑教训**：在构造矩阵时，确保每行至少有一个元素大于其他行，不能简单地通过随机填充来实现。
- **顿悟感想**：通过交替递增递减构造，可以轻松满足题目条件，且代码实现简单。

---
处理用时：29.12秒
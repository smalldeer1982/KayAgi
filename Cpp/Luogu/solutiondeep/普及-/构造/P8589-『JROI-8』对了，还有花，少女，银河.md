# 题目信息

# 『JROI-8』对了，还有花，少女，银河

## 题目背景

![1663764189387.png](https://img-kysic-1258722770.file.myqcloud.com/9d24e2bd5b20f277e72914b1bc44543e/44b6413b44c70.png)

>「其一」\
即使化身白骨，也有不想忘记的东西

**已获得转载授权。**

## 题目描述

给定 $n$，请构造一个长度为 $n$ 的仅包含 $0,1$ 的数字串，满足 $01,00,10,11$ 出现的次数相等。或报告无解。

这里“出现”指与原字符串中连续的一部分完全相同。例如，在 $1011101$ 中，$01,00,10,11$ 分别出现了 $2,0,2,2$ 次。

**请注意，大样例不以文件附加形式给出，而直接放在题目的 输入输出样例 中的 样例 #3**

## 说明/提示

【数据范围与提示】

| 测试点编号 | 分数 | $n\leq$ | 特殊性质 |
| -----------: | -----------: | -----------: | -----------: |
| $1\sim 2$ | $20$ | $5$ | 无 |
| $3\sim 4$ | $20$ | $10^6$ | $n \bmod 4 = 0$ |
| $5\sim 6$ | $20$ | $20$ | 无 |
| $7 \sim 10$ | $40$ | $10^6$ | 无 |

## 样例 #1

### 输入

```
3```

### 输出

```
-1```

## 样例 #2

### 输入

```
5```

### 输出

```
00110```

## 样例 #3

### 输入

```
15400```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个长度为 \( n \) 的 \( 01 \) 串，使得 \( 00, 01, 10, 11 \) 四种子串的出现次数相等。通过分析，我们发现只有当 \( n \equiv 1 \pmod{4} \) 时才有解，且构造方法为在开头输出一个 \( 0 \)，然后循环输出 \( 0110 \) 直到达到长度 \( n \)。大多数题解都围绕这一核心思路展开，部分题解通过 DFS 或手动模拟验证了这一规律。

### 所选高星题解

#### 1. **作者：AThls123 (5星)**
   - **关键亮点**：通过 DFS 验证了 \( n \equiv 1 \pmod{4} \) 时有解，并给出了简洁的构造方法。代码清晰，思路明确。
   - **个人心得**：通过 DFS 验证了构造规律，避免了盲目猜测。
   - **核心代码**：
     ```cpp
     int main() {
         long long n; cin >> n;
         if ((n - 1) % 4 == 0 && n != 1) {
             for (int i = 1; i <= n / 4; i++) cout << "0011";
             cout << 0 << endl;
             return 0;
         } else cout << -1 << endl;
         return 0;
     }
     ```

#### 2. **作者：xwh_Marvelous (4星)**
   - **关键亮点**：通过观察样例和数学推导，得出了 \( n \equiv 1 \pmod{4} \) 时有解的结论，并给出了构造方法。
   - **核心代码**：
     ```cpp
     int main() {
         scanf("%d", &n);
         n--;
         if (n % 4 != 0) {
             printf("-1");
             return 0;
         }
         putchar('0');
         for (int i = 1; i <= n / 4; i++) printf("0110");
         return 0;
     }
     ```

#### 3. **作者：__Allen_123__ (4星)**
   - **关键亮点**：通过数学推导和样例分析，得出了 \( n \equiv 1 \pmod{4} \) 时有解的结论，并给出了构造方法。
   - **核心代码**：
     ```cpp
     int main() {
         scanf("%d", &n);
         if (n % 4 != 1 || n == 1) {
             printf("-1");
             return 0;
         }
         printf("0");
         for (int i = 1; i <= n / 4; i++) printf("0110");
         return 0;
     }
     ```

### 最优关键思路与技巧

1. **数学推导**：通过分析子串数量和 \( n \equiv 1 \pmod{4} \) 的条件，快速判断是否有解。
2. **构造方法**：在开头输出一个 \( 0 \)，然后循环输出 \( 0110 \)，确保四种子串出现次数相等。
3. **DFS验证**：通过 DFS 验证构造规律，避免盲目猜测。

### 可拓展之处

1. **类似问题**：类似构造题可以通过数学推导和样例分析找到规律，避免盲目尝试。
2. **优化思路**：对于构造题，可以通过数学推导减少不必要的计算，提高效率。

### 推荐题目

1. **P8437 伟大的神**：考察构造和数学推导能力。
2. **P8588 简单的构造题**：类似构造题，考察规律发现和构造能力。
3. **P8590 复杂的构造题**：更复杂的构造题，考察综合能力。

### 个人心得总结

通过 DFS 验证构造规律，避免了盲目猜测，提高了题解的可靠性。数学推导和样例分析是解决构造题的有效方法。

---
处理用时：31.81秒
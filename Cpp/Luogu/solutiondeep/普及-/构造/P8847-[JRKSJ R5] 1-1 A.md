# 题目信息

# [JRKSJ R5] 1-1 A

## 题目背景

本题是 1-1 的较易版本，较难版本为 [1-1 B](https://www.luogu.com.cn/problem/P8848)。

## 题目描述

给出一个序列 $a$，$\forall i\in [1,n],a_i\in \{1,-1\}$。

你可以将序列任意重排，需最小化重排后序列的最大子段和。

## 说明/提示

最大子段和的定义：序列中一段区间的和的最大值。即 $\max_{1\le l\le r\le n} \sum_{i=l}^r a_i$。

本题使用 $\text{Special Judge}$，只要你的输出满足题意即可通过。

**本题输入输出文件较大，请使用恰当的输入输出方式。**

### 数据规模
本题采用捆绑测试。

| $\text{Subtask}$ | $n\le$ | $\text{Score}$ |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | $40$ |
| $2$ | $10^6$ | $60$ |

对于 $100\%$ 的数据，$1\le n\le 10^6$，$a_i\in \{1,-1\}$。

## 样例 #1

### 输入

```
4
1 1 -1 -1```

### 输出

```
1 -1 -1 1```

# AI分析结果

### 综合分析与结论

本题的核心目标是通过重排序列，最小化最大子段和。由于序列中只有 `1` 和 `-1`，题解大多利用了这一点，通过分类讨论和贪心策略来构造最优序列。大多数题解的思路相似，主要分为以下三种情况：

1. **`-1` 的数量大于 `1` 的数量**：将 `1` 和 `-1` 交替排列，多余的 `-1` 放在末尾，最大子段和为 `1`。
2. **`-1` 的数量等于 `1` 的数量**：同样交替排列，最大子段和为 `1`。
3. **`-1` 的数量小于 `1` 的数量**：交替排列后，多余的 `1` 放在末尾，最大子段和为 `1` 的数量减去 `-1` 的数量。

大多数题解的时间复杂度为 `O(n)`，能够通过本题的数据规模。虽然思路相似，但部分题解在代码实现和解释上更为清晰，值得推荐。

### 评分较高的题解

#### 1. 作者：U_star (5星)
**关键亮点**：
- 思路清晰，分类讨论详细，给出了每种情况的构造方法和证明。
- 代码简洁，直接根据 `1` 和 `-1` 的数量进行输出，时间复杂度为 `O(n)`。

**核心代码**：
```cpp
if(v2==v1) {
    for(int i=1;i<=n;i++) {
        if(i%2) cout<<1<<" ";
        else cout<<-1<<" ";
    }
} else if(v2>v1) {
    for(int i=1;i<=v1*2;i++) {
        if(i%2) cout<<1<<" ";
        else cout<<-1<<" ";
    }
    for(int i=1;i<=n-v1*2;i++) cout<<-1<<" ";
} else {
    for(int i=1;i<=v2*2;i++) {
        if(i%2) cout<<1<<" ";
        else cout<<-1<<" ";
    }
    for(int i=1;i<=n-v2*2;i++) cout<<1<<" ";
}
```

#### 2. 作者：Vct14 (4星)
**关键亮点**：
- 思路简洁，直接统计 `1` 和 `-1` 的数量，交替输出后处理多余部分。
- 代码可读性强，逻辑清晰。

**核心代码**：
```cpp
for(int i=1; i<=min(m,o); i++) printf("1 -1 ");
int k=(m>=o)?-1:1;
for(int i=1; i<=abs(m-o); i++) printf("%d ",k);
```

#### 3. 作者：pxb0801 (4星)
**关键亮点**：
- 分析详细，给出了构造方法的直观解释。
- 代码实现简洁，直接根据 `1` 和 `-1` 的数量进行输出。

**核心代码**：
```cpp
if(cnt1>cnt2) {
    for(int i=1;i<=cnt2;i++) printf("1 -1 ");
    for(int i=cnt2+1;i<=cnt1;i++) printf("1 ");
} else {
    for(int i=1;i<=cnt1;i++) printf("1 -1 ");
    for(int i=cnt1+1;i<=cnt2;i++) printf("-1 ");
}
```

### 最优关键思路与技巧

1. **分类讨论**：根据 `1` 和 `-1` 的数量关系，分别处理不同情况，确保最大子段和最小。
2. **贪心策略**：通过交替排列 `1` 和 `-1`，尽可能抵消它们的贡献，减少最大子段和。
3. **直接输出**：根据统计结果直接输出序列，避免复杂的计算，时间复杂度为 `O(n)`。

### 可拓展之处

本题的思路可以推广到其他类似的序列重排问题，尤其是当序列中的元素具有某种对称性或抵消性质时。例如，序列中只有 `1` 和 `0`，或者 `1` 和 `-2` 等，可以通过类似的分类讨论和贪心策略来构造最优序列。

### 推荐题目

1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)

### 个人心得总结

部分题解中提到了调试经历和构造方法的优化，例如在交替排列时，确保 `1` 和 `-1` 的顺序合理，避免多余的 `1` 或 `-1` 导致最大子段和增加。这些经验对于解决类似的构造问题非常有帮助。

---
处理用时：36.09秒
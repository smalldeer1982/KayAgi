# 题目信息

# Digital Fortress

## 题目背景

布林克霍夫大声喊道：“这当然是密码！这不是密码，还能是什么？还有什么原因能让友加送掉这枚戒指？到底是谁在戒指上刻一大串杂乱无章的字母？”

方丹愤怒地等了布林克霍夫一眼，使他安静了下来。

“啊……伙计们？”贝克插了一句话，似乎很不情愿卷进来一样，“你们一直说这些是杂乱无章的字母。我想我应该让你们知道……这枚戒指上刻的字母并不是杂乱无章。如果你近距离看一下，就会明白，实际上，这些字母……这个……这个是拉丁文。”

指挥台上的所有人都看向了那枚戒指。上面写道：

> Quis custodiet ipsos custiodies.  
谁来监视这些监视者……

## 题目描述

致命的变异串已经穿过了 X-11 过滤器，深入了国安局数据库。苏珊与贝克需要即时破解出密码，以关闭蠕虫病毒。

在蠕虫的文件中，他们找到了密码的一个特点：

- 共有 $n$ 位，每个数都在 $[1,m]$ 之间，并且单调不减。
- 如算出前缀异或和，那么前缀异或和也单调不减。
- 如算出后缀异或和，那么后缀异或和仍然单调不减。

除此之外，他们也找到了 $n,m$ 的值。现在，他们需要构造出一组密码，以满足所有特征。
***

#### 【形式化题意】

求是否存在长度为 $n$，所有元素都在 $[1,m]$ 范围内的单调不减正整数序列 $a$，满足：

- $\forall1<i\le n,a_1\ \text{xor}\ a_2\ \text{xor}\ \cdots\ \text{xor}\ a_{i-1}\le a_1\ \text{xor}\ a_2\ \text{xor}\ \cdots\ \text{xor}\ a_{i}$
- $\forall1\le i<n,a_n\ \text{xor}\ a_{n-1}\ \text{xor}\ \cdots\ \text{xor}\ a_{i+1}\le a_n\ \text{xor}\ a_{n-1}\ \text{xor}\ \cdots\ \text{xor}\ a_{i}$

如存在，输出一组合法解。多组数据。

## 说明/提示

#### 【样例解释】

对于第一组数据，密码的前缀异或和为 $\{1,7,15,31\}$，后缀异或和为 $\{16,24,30,31\}$，均为递增序列，满足题意。

对于第二组数据，不存在任何合法方案。

#### 【数据范围】

**本题开启捆绑测试。**

|$\text{Subtask}$|分值|$n\le$|$m\le$|
|:-:|:-:|:-:|:-:|
|$0$|$10$|$5$|$200$|
|$1$|$30$|$20$|$10^6$|
|$2$|$60$|$10^5$|$2^{63}-1$|

对于 $100\%$ 的数据，$1\le n\le10^5$，$1\le m\le2^{63}-1$，$1\le t\le50$。

## 样例 #1

### 输入

```
2
4 20
1919 114514
```

### 输出

```
Yes
1 6 8 16
No
```

# AI分析结果

### 综合分析与结论

本题的核心是构造一个长度为 \( n \) 的序列，满足每个元素在 \([1, m]\) 范围内，且序列本身、前缀异或和、后缀异或和都单调不减。通过分析，可以发现最优的构造方式是让序列中的每个元素都占据一个独立的二进制位，即 \( a_i = 2^{i-1} \)。这种构造方式不仅保证了序列的单调性，还确保了前缀和后缀异或和的单调性。

### 所选高星题解

#### 1. 作者：chlchl (5星)
**关键亮点**：
- 通过贪心策略，直接构造 \( a_i = 2^{i-1} \) 的序列，确保了前缀和后缀异或和的单调性。
- 使用 `__lg` 函数判断 \( m \) 是否足够大，避免了直接计算 \( 2^{n-1} \) 的溢出问题。
- 代码简洁，逻辑清晰，时间复杂度为 \( O(n) \)。

**个人心得**：
- 作者提到使用 `log2` 函数时遇到精度问题，改用 `__lg` 函数解决了问题，强调了在实际编程中注意精度问题的重要性。

**核心代码**：
```cpp
if(__lg(m) + 1 >= n){
    printf("Yes\n");
    for(int i=0;i<n;i++)
        printf("%lld ", (1ll << i));
    printf("\n");
}
else
    printf("No\n");
```

#### 2. 作者：Register_int (5星)
**关键亮点**：
- 通过数学归纳法证明了 \( a_i = 2^{i-1} \) 是最优构造，确保了前缀和后缀异或和的单调性。
- 使用 `__lg` 函数判断 \( m \) 是否足够大，避免了直接计算 \( 2^{n-1} \) 的溢出问题。
- 代码简洁，逻辑清晰，时间复杂度为 \( O(n) \)。

**核心代码**：
```cpp
if (__lg(m) + 1 < n) puts("No");
else { puts("Yes"); for (int i = 0; i < n; i++) printf("%lld ", 1ll << i); puts(""); }
```

#### 3. 作者：JuRuoOIer (4星)
**关键亮点**：
- 通过贪心策略，直接构造 \( a_i = 2^{i-1} \) 的序列，确保了前缀和后缀异或和的单调性。
- 使用 `1ull << i` 避免溢出问题，代码简洁，逻辑清晰。
- 时间复杂度为 \( O(n) \)。

**核心代码**：
```cpp
if(check()<n){
    cout<<"No\n";
    continue;
}
cout<<"Yes\n";
for(ull i=0;i<n;i++){
    cout<<(1ull<<i)<<' ';
}
cout<<endl;
```

### 最优关键思路与技巧

1. **贪心构造**：通过让每个元素占据一个独立的二进制位，确保序列和异或和的单调性。
2. **避免溢出**：使用 `__lg` 或 `1ull << i` 避免直接计算 \( 2^{n-1} \) 时的溢出问题。
3. **数学归纳法**：通过数学归纳法证明构造的最优性，确保思路的正确性。

### 可拓展之处

- **类似问题**：在其他需要构造单调序列且满足特定运算性质的问题中，可以考虑类似的贪心策略。
- **位运算优化**：在处理涉及二进制位的问题时，位运算常常能提供高效的解决方案。

### 推荐题目

1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004) - 考察动态规划与路径选择。
2. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020) - 考察贪心与单调性。
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 考察背包问题与贪心策略。

### 个人心得总结

- **精度问题**：在处理涉及大数或浮点数的问题时，注意精度问题，选择合适的函数或数据类型。
- **贪心策略**：在构造类问题中，贪心策略常常能提供简洁高效的解决方案，但需要严格证明其正确性。

---
处理用时：29.86秒
# 题目信息

# 「KDOI-04」XOR Sum

## 题目背景

凯文一眼秒了这题。

![](https://cdn.luogu.com.cn/upload/image_hosting/lh1xvu75.png)

## 题目描述

给定一个正整数 $n$，请构造一个长度为 $n$ 的**非负整数**序列 $a_1,a_2,\dots,a_n$，满足：

+ 对于所有 $1\le i\le n$，都有 $0\le a_i\le m$。
+ $a_1\oplus a_2\oplus\dots\oplus a_n=k$。其中 $\oplus$ 表示[按位异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)运算。

或者判断不存在这样的序列。

## 说明/提示

**【样例解释】**

对于第 $1$ 组测试数据，有且仅有一个序列满足条件。

对于第 $2$ 组测试数据，由于 $4\oplus 7=3$ 且 $4,7\le10$，所以这是一个合法的答案。同样地，序列 $(2,1)$ 也是一个合法的答案。

对于第 $4$ 组测试数据，可以证明不存在满足要求的序列。

**【数据范围】**

记 $\sum n$ 为单个测试点中所有 $n$ 的值之和。

对于所有测试数据，保证 $1\le T\le 1~000$，$1\le n\le 2\cdot10^5$，$0\le m,k\le 10^8$，$\sum n\le 2\cdot10^5$。

**【子任务】**

**本题开启捆绑测试。**

+ Subtask 1 (18 pts)：$k\le m$。
+ Subtask 2 (82 pts)：没有额外的约束条件。

## 样例 #1

### 输入

```
5
1 2 2
2 3 10
2 11 8
20 200000 99999
11 191 9810```

### 输出

```
2 
4 7 
8 3 
-1
191 191 191 191 191 191 191 191 191 191 191 ```

# AI分析结果

### 综合分析与结论

本题的核心在于如何构造一个长度为 \( n \) 的非负整数序列，使得序列中每个数不超过 \( m \)，且整个序列的异或和为 \( k \)。题解的思路主要集中在以下几点：

1. **无解判断**：当 \( k \) 的二进制位数大于 \( m \) 时，无解。
2. **简单情况**：当 \( k \leq m \) 时，直接构造一个 \( k \) 和 \( n-1 \) 个 \( 0 \) 的序列。
3. **复杂情况**：当 \( k > m \) 时，通过将 \( k \) 拆分为两个数 \( a \) 和 \( b \)，使得 \( a \oplus b = k \) 且 \( a, b \leq m \)，然后构造序列。

大多数题解都围绕这些思路展开，但在实现细节和优化程度上有所不同。以下是对部分题解的评分和亮点总结。

### 所选高星题解

#### 1. **JuRuoOIer (5星)**
- **关键亮点**：思路清晰，代码简洁，优化了无解判断和复杂情况的处理。通过将 \( k \) 拆分为两个数，确保构造的序列满足条件。
- **核心代码**：
  ```cpp
  if(log2(m)<log2(k)){//m 的二进制长度小于 k，无解 
      cout<<"-1\n";
  }
  else if(m<k){//m<k 的情况，见 Part2-2 
      if(n==1)cout<<"-1\n";//一项不够，无解 
      else{
          cout<<(1ll<<log2(k)-1)<<' '<<k-(1ll<<log2(k)-1);//左移，1<<k 结果为 2^k 
          for(int i=0;i<n-2;i++){//补 0 
              cout<<" 0";
          }
          cout<<endl;
      }
  }
  else{
      cout<<k;
      for(int i=0;i<n-1;i++){//补 0 
          cout<<" 0";
      }
      cout<<endl;
  }
  ```
- **个人心得**：通过将 \( k \) 拆分为两个数，确保构造的序列满足条件，思路清晰且实现简洁。

#### 2. **_determination_ (4星)**
- **关键亮点**：通过 \( \operatorname{lowbit} \) 辅助拆分 \( k \)，贪心让组装出来的数尽可能大，思路新颖。
- **核心代码**：
  ```cpp
  while(k){
      x=0;
      while(k>0&&x+lowbit(k)<=m){
          x+=lowbit(k);
          k-=lowbit(k);
      }
      ans[++al]=x;
      if(al>n){
          cout<<"-1";
          return;
      }
  }
  ```
- **个人心得**：通过贪心策略，确保构造的序列尽可能小，避免不必要的复杂度。

#### 3. **Clarinet (4星)**
- **关键亮点**：通过 \( k \oplus m \) 来求解第二个数，确保构造的序列满足条件，思路清晰且实现简洁。
- **核心代码**：
  ```cpp
  if(check(m,k)){
      cout<<-1<<endl;
      continue;
  }
  if(m>=k){
      cout<<k;
      for(int i=1;i<=n-1;i++)cout<<" 0";
      cout<<endl;
      continue;
  }
  if(n==1){
      cout<<-1<<endl;
      continue;
  }
  int ans=k^m;
  cout<<m<<" "<<ans;
  for(int i=2;i<=n-1;i++)cout<<" 0";
  cout<<endl;
  ```
- **个人心得**：通过 \( k \oplus m \) 来求解第二个数，确保构造的序列满足条件，思路清晰且实现简洁。

### 最优关键思路与技巧

1. **无解判断**：通过比较 \( k \) 和 \( m \) 的二进制位数，快速判断无解情况。
2. **简单情况处理**：当 \( k \leq m \) 时，直接构造一个 \( k \) 和 \( n-1 \) 个 \( 0 \) 的序列。
3. **复杂情况处理**：当 \( k > m \) 时，通过将 \( k \) 拆分为两个数 \( a \) 和 \( b \)，使得 \( a \oplus b = k \) 且 \( a, b \leq m \)，然后构造序列。

### 拓展思路与类似题目

1. **类似题目**：
   - [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)：考察数学构造和模运算。
   - [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)：考察位运算和数据结构。
   - [P3865 【模板】ST表](https://www.luogu.com.cn/problem/P3865)：考察位运算和区间查询。

2. **拓展思路**：在处理类似的构造问题时，可以通过位运算的性质来简化问题，尤其是在处理异或、与、或等操作时，位运算往往能提供高效的解决方案。

---
处理用时：36.25秒
# 题目信息

# 「DROI」Round 2 构造与取模

## 题目背景

与其编写苍白无力的背景，不如出更有质量的题。



## 题目描述

对于整数 $n,k$，若存在**非负整数** $x$ 与 **正整数** $y$ 满足：

$$x + y = n\ \land\ x \bmod y =k$$

则我们称有序数对 $(x,y)$ 是 $n$ 的一个 **优秀拆分**（其中 $\land$  是**并且**的意思）。

现给定非负整数 $n,k$，请你构造**任意**一组 $n$ 的优秀拆分，并分别输出你构造方案中的 $x$ 和 $y$。特殊地，若不存在这样的拆分，则输出 `-1`。

## 说明/提示

#### 样例解释

对于第一组数据，只存在唯一的构造方式。

对于第二组数据，$(3,10)$ 也是一组合法的构造。

对于第三组数据，可以证明不存在一组合法的构造。

------------

#### 数据范围

**「本题采用捆绑测试」**

- $\operatorname{Subtask} 1(20\%)$：$n \leq 10^6$。

- $\operatorname{Subtask} 2(40\%)$：$n \leq 10^{12}$。

- $\operatorname{Subtask} 3(40\%)$：无特殊限制。

对于 $100\%$ 的数据：$T \leq 5$，$0 \leq n,k \leq 10^{18}$。

## 样例 #1

### 输入

```
3
1 0
13 3
198818800000 122122200000```

### 输出

```
0 1
8 5
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于构造满足条件的非负整数 \(x\) 和正整数 \(y\)，使得 \(x + y = n\) 且 \(x \bmod y = k\)。通过分析，可以得出以下结论：

1. **无解条件**：当 \(k > \lfloor \frac{n-1}{2} \rfloor\) 或 \(n \leq 2k\) 时，无解。
2. **构造方案**：若 \(n > 2k\)，则 \(x = k\) 和 \(y = n - k\) 是一组合法解。

大多数题解都基于这一结论，通过简单的条件判断即可得出结果。部分题解还提供了更详细的证明或额外的优化思路，如枚举因数或随机算法，但这些方法在本题中并不必要，反而增加了复杂度。

### 所选高分题解

#### 1. 作者：Demeanor_Roy (5星)
- **关键亮点**：简洁明了的结论和证明，直接输出 \(x = k\) 和 \(y = n - k\)，时间复杂度为 \(O(T)\)。
- **代码实现**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int T;
  long long n,k;
  int main() {
      scanf("%d",&T);
      while(T--) {
          scanf("%lld%lld",&n,&k);
          if(k<=(n-1)>>1) printf("%lld %lld\n",k,n-k);
          else printf("-1\n");
      }
      return 0;    
  }
  ```

#### 2. 作者：Eleveslaine (4星)
- **关键亮点**：通过简单的数学推导得出 \(x = k\) 和 \(y = n - k\) 的合法性，并指出无解条件。
- **代码实现**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int main() {
      int T; scanf("%d",&T);
      while(T--) {
          long long n,k; scanf("%lld%lld",&n,&k);
          if(n>k*2) printf("%lld %lld\n",k,n-k);
          else printf("-1\n");
      }
      return 0;
  }
  ```

#### 3. 作者：zhlzt (4星)
- **关键亮点**：分情况讨论 \(x < y\) 和 \(x \geq y\) 的情况，最终得出 \(x = k\) 和 \(y = n - k\) 的构造方案。
- **代码实现**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int main() {
      int T; scanf("%d",&T);
      while(T--) {
          long long n,k; scanf("%lld%lld",&n,&k);
          if(n>k*2) printf("%lld %lld\n",k,n-k);
          else printf("-1\n");
      }
      return 0;
  }
  ```

### 最优关键思路或技巧

- **数学推导**：通过简单的数学推导得出 \(x = k\) 和 \(y = n - k\) 的合法性，避免复杂的枚举或随机算法。
- **条件判断**：通过判断 \(n > 2k\) 来确定是否有解，直接输出结果，时间复杂度为 \(O(T)\)。

### 可拓展之处

- **类似题目**：可以考察类似构造题，要求满足特定条件的整数对，如 \(x \times y = n\) 且 \(x \bmod y = k\)。
- **算法优化**：在构造题中，通过数学推导减少不必要的枚举或计算，提高效率。

### 推荐题目

1. **P1463 [POI2001] [HAOI2007] 反素数**（题号：P1463）
2. **P1445 [Violet] 樱花**（题号：P1445）
3. **P1082 [NOIP2012 提高组] 同余方程**（题号：P1082）

### 个人心得摘录

- **Demeanor_Roy**：通过简单的数学推导，避免了复杂的枚举或随机算法，直接得出最优解。
- **Eleveslaine**：通过简单的条件判断，快速得出结果，代码简洁易读。
- **zhlzt**：分情况讨论，最终得出 \(x = k\) 和 \(y = n - k\) 的构造方案，思路清晰。

---
处理用时：31.10秒
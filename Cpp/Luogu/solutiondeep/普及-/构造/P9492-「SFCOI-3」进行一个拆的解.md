# 题目信息

# 「SFCOI-3」进行一个拆的解

## 题目背景

**公告：Subtask 0 数据有误，现已更改。**

------------

三岁的小明非常不喜欢完整的东西，他甚至连序列都想要拆掉。

## 题目描述

给定序列 $a_1\dots a_n$，小明想要把它拆成两个子段 $[1, l][l + 1, n](1 \leq l \lt n)$，即 $a_1\dots a_l$ 和 $a_{l+1}\dots a_n$。

由于小明强迫症很严重，他不希望对于这两个子段，其中一个是另一个的 **子序列**，换句话说，他不希望其中一个子段可以通过删掉若干（可能为 $0$）个元素变成另一个。

在父母出门的时候，小明终于找到了把序列拆开的机会！所以，他想知道，是否存在一种拆解的方式满足：任意一个子段都不是另一个子段的子序列。

## 说明/提示

### 样例解释

对于第一个序列，所有拆分方式有：

- $\lbrace 1 \rbrace,\lbrace 2,1,2,1 \rbrace$。
- $\lbrace 1,2 \rbrace,\lbrace 1,2,1 \rbrace$。
- $\lbrace 1,2,1 \rbrace,\lbrace 2,1 \rbrace$。
- $\lbrace 1,2,1,2 \rbrace,\lbrace 1 \rbrace$。

从任何地方拆开都是不合法的——较短的那个序列都是另一个序列的子序列。

对于第二个序列，其中一种合理的拆分方式为 
$\lbrace 1,2,1,1,2 \rbrace,\lbrace 1,0 \rbrace$。

### 数据规模与约定

**本题采用捆绑测试**。

- Subtask 0（15 points）：$a_i = 0$。
- Subtask 1（15 points）：$n = 10$，保证数据随机生成。
- Subtask 2（30 points）：$n$ 为偶数。
- Subtask 3（40 points）：无特殊限制。

对于所有数据，$1\leq T \leq 10^5$，$2 \leq n \leq 10^5$，$1 \leq \sum n \leq 10^6$，$0 \leq a_i \leq 100$。

## 样例 #1

### 输入

```
2
5 1 2 1 2 1
7 1 2 1 1 2 1 0```

### 输出

```
NO
YES```

# AI分析结果

### 综合分析与结论

本题的核心在于判断是否可以将序列拆分成两个子段，且这两个子段互不为对方的子序列。多数题解都采用了分类讨论的思路，尤其是根据序列长度的奇偶性进行处理。常见的优化思路是通过双指针或二分法来减少时间复杂度，避免暴力枚举带来的高复杂度。

### 所选高星题解

#### 1. 作者：Rei_Sen (4星)
**关键亮点**：
- 通过奇偶性分类讨论，提出了具体的拆分策略。
- 详细证明了拆分方案的合理性，逻辑清晰。
- 代码实现简洁，易于理解。

**个人心得**：
- 通过分类讨论，简化了问题的复杂度，尤其是在奇数情况下，将问题转化为已知的偶数情况处理。

**核心代码**：
```cpp
bool check1() {
    int jbegin = n / 2 + 1;
    for(int i = 1, j = jbegin; i <= n / 2; ++i, ++j) {
        if(a[i] != a[j]) return false;
    }
    return a[1] == a[n];
}

bool check2() {
    int jbegin = n / 2 + 2;
    for(int i = 1, j = jbegin; i <= n / 2; ++i, ++j) {
        if(a[i] != a[j]) return false;
    }
    return true;
}
```

#### 2. 作者：liruixiong0101 (4星)
**关键亮点**：
- 通过双指针优化了子序列的判断，避免了暴力枚举。
- 提出了拆分位置的单调性，进一步优化了算法。

**个人心得**：
- 通过双指针的优化，大大减少了时间复杂度，使得算法在较大数据规模下依然高效。

**核心代码**：
```cpp
bool check(int x) {
    string s1 = s.substr(0, x);
    string s2 = s.substr(x, n - x);
    if(s1.length() > s2.length()) swap(s1, s2);
    if(s1 + s2[s2.length() - 1] == s2 || s2[0] + s1 == s2) return true;
    return false;
}
```

#### 3. 作者：Exp10re (4星)
**关键亮点**：
- 通过二分法优化了拆分位置的查找，进一步减少了时间复杂度。
- 详细证明了拆分方案的合理性，逻辑清晰。

**个人心得**：
- 通过二分法的优化，使得算法在较大数据规模下依然高效，且代码实现简洁。

**核心代码**：
```cpp
bool pd(LL x) {
    LL t1 = 1, t2 = x + 1;
    while(t1 <= x && t2 <= n) {
        if(a[t1] == a[t2]) t1++;
        t2++;
    }
    if(t1 == x + 1) return false;
    return true;
}
```

### 最优关键思路与技巧

1. **分类讨论**：根据序列长度的奇偶性进行分类处理，简化问题复杂度。
2. **双指针优化**：通过双指针判断子序列，减少时间复杂度。
3. **二分法优化**：通过二分法优化拆分位置的查找，进一步减少时间复杂度。

### 可拓展之处

- **类似问题**：可以拓展到其他需要拆分成子序列的问题，如判断是否可以将序列拆分成多个子序列，且这些子序列互不为对方的子序列。
- **算法套路**：双指针和二分法是处理子序列问题的常见套路，可以应用到其他类似问题中。

### 推荐题目

1. [P1495 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1495)
2. [P1439 【模板】最长上升子序列](https://www.luogu.com.cn/problem/P1439)
3. [P1091 【模板】最长不下降子序列](https://www.luogu.com.cn/problem/P1091)

---
处理用时：36.16秒
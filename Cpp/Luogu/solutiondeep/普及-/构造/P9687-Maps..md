# 题目信息

# Maps.

## 题目描述

小 Y 希望得到一幅地图，这份地图有些与众不同。

这份地图是一幅长为 $n$ 个单位，宽为一个单位的网格图，每个网格必须被涂鸦成白色（$0$）或者黑色（$1$）。

你希望满足小 Y 的愿望送给他一幅这样的地图，但是这时小 Y 又提出了两点要求：

- 对于每个不在网格图两端的白色格子，恰好有 $p$ 个满足它的左右两个格子都被涂鸦成黑色。
- 在满足上述所有条件的情况下，这幅地图从左到右的字符构成的字符串的字典序最小。

你心想，这些要求也是小菜一碟，于是开始了你的创作。

## 说明/提示

#### 【样例解释 #1】

对于第一组数据：只有位于第 $4$ 个字符上的数，满足本身是 $0$，不在地图边缘且周围两个都是 $1$，因此符合条件。可以证明这是满足条件的字典序最小的方案。

对于第三组数据：可以证明没有任何一个解满足长度为 $5$ 且有 $3$ 个数本身是 $0$，不在地图边缘且周围两个字符都是 $1$。

#### 【数据范围】

对于所有测试数据，满足 $1 \le T \le 100$，$1 \le n,p \le 10^5$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n,p \le$ |
| :-----------: | :-----------: |
| $1 \sim 3$ | $10$ |
| $4 \sim 5$ | $10^3$ |
| $6\sim 10$ | $10^5$ |

## 样例 #1

### 输入

```
5
5 1
3 1
5 3
5 4
5 5```

### 输出

```
00101
101
-1
-1
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个长度为 $n$ 的 01 字符串，满足特定条件且字典序最小。大部分题解的思路集中在以下几点：
1. **无解判断**：当 $2p + 1 > n$ 时，无法构造满足条件的字符串，输出 `-1`。
2. **构造策略**：为了字典序最小，尽可能多的 `0` 放在字符串的前面，后面则用 `10101...` 的形式满足条件。
3. **代码实现**：通过循环输出前面的 `0`，再输出 `10101...` 的结构。

虽然大部分题解思路相似，但在代码实现和细节处理上有所不同。部分题解在无解判断和构造逻辑上更加简洁清晰，代码可读性也更高。

### 所选高星题解

#### 1. 作者：bryce (4星)
**关键亮点**：
- 无解判断简洁明了，直接通过 $2p + 1 > n$ 判断。
- 构造逻辑清晰，先输出前面的 `0`，再输出 `10101...` 的结构。
- 代码简洁，易于理解。

**核心代码**：
```cpp
for (int i = 1; i <= n - (2 * p + 1); i++) cout << 0;
for (int i = 1; i <= p; i++) cout << "10";
cout << 1 << endl;
```
**实现思想**：先输出 $n - (2p + 1)$ 个 `0`，然后输出 $p$ 个 `10`，最后补一个 `1`。

#### 2. 作者：Lovely_Elaina (4星)
**关键亮点**：
- 无解判断与构造逻辑与bryce类似，但代码风格更加简洁。
- 使用了 `ios::sync_with_stdio(0)` 优化输入输出，提升效率。

**核心代码**：
```cpp
for(int i = n-len; i > 0; i--) cout << 0;
for(int i = 1; i <= p; i++) cout << "10";
cout << 1 << endl;
```
**实现思想**：先输出 $n - (2p + 1)$ 个 `0`，然后输出 $p$ 个 `10`，最后补一个 `1`。

#### 3. 作者：MarsTraveller (4星)
**关键亮点**：
- 无解判断与构造逻辑清晰，代码风格简洁。
- 使用了 `printf` 输出，适合多组数据输出。

**核心代码**：
```cpp
for(big i = 1;i <= n-(2*p+1);i++) cout << 0;
cout << 1;
for(big i = 1;i <= p;i++) cout << "01";
```
**实现思想**：先输出 $n - (2p + 1)$ 个 `0`，然后输出 `1` 和 $p$ 个 `01`。

### 最优关键思路与技巧
1. **无解判断**：通过 $2p + 1 > n$ 快速判断是否无解，避免不必要的计算。
2. **构造策略**：为了字典序最小，尽可能多的 `0` 放在前面，后面用 `10101...` 的形式满足条件。
3. **代码优化**：使用 `ios::sync_with_stdio(0)` 或 `printf` 优化输入输出，提升效率。

### 可拓展之处
- **类似题目**：可以扩展到其他需要构造特定模式的字符串问题，如要求某些字符必须满足特定条件。
- **算法套路**：贪心算法在构造类问题中非常常见，尤其是在需要最小化或最大化某种属性的情况下。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003) - 考察构造与贪心。
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045) - 构造特定形式的数字。
3. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059) - 构造与排序结合的问题。

### 个人心得摘录
- **调试经历**：部分题解提到在赛时因为无解判断不充分导致WA，强调了无解判断的重要性。
- **顿悟感想**：通过构造 `10101...` 的结构，可以快速满足条件，同时保证字典序最小。

### 通用建议
- **无解判断**：在构造类问题中，优先考虑无解情况，避免不必要的计算。
- **构造策略**：贪心算法在构造类问题中非常有效，尤其是在需要最小化或最大化某种属性的情况下。
- **代码优化**：多组数据输入输出时，使用 `ios::sync_with_stdio(0)` 或 `printf` 优化效率。

---
处理用时：37.82秒
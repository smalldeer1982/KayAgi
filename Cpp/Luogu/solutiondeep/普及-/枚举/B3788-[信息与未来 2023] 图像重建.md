# 题目信息

# [信息与未来 2023] 图像重建

## 题目背景

JWST (詹姆斯·韦伯太空望远镜，James Webb Space Telescope) 是一台红外波段的大型太空望远镜，由美国国家航空航天局 (NASA)、欧洲航天局 (ESA) 和加拿⼤航天局 (CSA) 共同合作开发。它是哈勃太空望远镜的科学继任者，旨在解决⼀系列重要的天文学问题，包括宇宙的起源、星系的形成和演化、恒星和行星系统的形成，以及寻找宜居⾏星和生命迹象。

以下是 JWST 望远镜 5 ⽉ 23 ⽇采集的深空图像：

![](https://cdn.luogu.com.cn/upload/image_hosting/nmcrklbq.png)

## 题目描述

太空望远镜在采集数据时，并不像我们日常生活中的手机或相机 “一次拍摄成像” 直接从传感器数据得到照⽚，而是由多次不同时段拍摄的图像拼接而成。在这个问题中，我们也来实现图像的拼接重建。

我们已经对⼀个区域拍摄了**两张**黑白图像。这两张图像面向同⼀区域拍摄，因此我们预期它们有相当⼀部分都是重叠的。你的任务就是将两张图像经过上下左右平移后尽可能 “重叠” 在⼀起，满⾜重叠部分所有像素均完全相同，且**重叠部分的⾯积尽可能⼤（即重叠部分的像素数量尽可能多）**。

## 说明/提示

对于 $100\%$ 的数据，满足 $1\leq n,m\leq 50$。

>本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
3 3
0 0 0
0 1 1
0 1 1

2 4
1 1 0 0
1 1 0 1```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解均采用暴力枚举法解决图像拼接求最大重叠像素数的问题。思路核心是枚举两张图像的所有可能相对位置，检查重叠部分像素是否相同并记录最大重叠面积。

各题解主要差异在于枚举方式和边界处理：部分题解通过枚举平移的行列数实现，部分则以一张图的角点与另一张图的各点重合来枚举。难点在于处理数组越界和确保重叠部分像素完全相同。

### 所选题解
- **作者：szh_AK_all（5星）**
    - **关键亮点**：思路清晰，先给出初始错误做法并分析原因，再给出满分做法，详细解释边界判断和重叠条件处理。
    - **个人心得**：初始做法因未考虑数组越界和重叠部分像素需完全相同的条件，导致评测出现三处 RE 错误，提醒做题时要仔细审题和处理边界情况。
    - **核心代码**：
```c
for(int i=-n1;i<=n1;i++)//枚举
    for(int j=-m1;j<=m1;j++)
    {
        int tmp=0;
        for(int k=1;k<=n1;k++)//判断
        {
            int p=0;//开关
            for(int t=1;t<=m1;t++)
            {
                if((k+i)>=1&&(k+i)<=n2&&(t+j)>=1&&(t+j)<=m2)
                {
                    if(a[k][t]!=b[k+i][t+j])
                    {
                        p=1;
                        tmp=0;
                        break;
                    }
                    else
                        tmp++;
                }
            }
            if(p==1)
                break;
        }
        if(tmp>ans)
            ans=tmp;
    }
```
核心思想：枚举第一张图相对第二张图的平移量，对每个平移量检查重叠部分像素是否相同，若有不同则重置重叠像素数，最后更新最大重叠像素数。

- **作者：_Joseph_（4星）**
    - **关键亮点**：代码简洁，注释清晰，通过枚举平移方向和检查重叠像素，使用布尔变量标记是否有不同像素，避免复杂的循环跳出操作。
    - **核心代码**：
```cpp
for(int dx = -n1;dx <= n1;dx++)//枚举x轴移动方向
    for(int dy = -m1;dy <= m1;dy++){//枚举y轴移动方向
        int ans = 0,f = 1;
        for(int i = 1;i <= n2;i++)//扫数组
            for(int j = 1;j <= m2;j++){
                int nx = i + dx,ny = j + dy;
                if(nx > 0 && nx <= n1 && ny > 0 && ny <= m1) {
                    if(xy1[nx][ny] == xy2[i][j]) ans++;
                    else f = 0;
                }
            }
        res = max(res, ans * f);
    }
```
核心思想：枚举第二张图在 x、y 轴的平移方向，对每个平移情况检查重叠像素，若有不同则标记，最后取重叠像素数和标记的乘积更新最大值。

- **作者：wangweichen666（4星）**
    - **关键亮点**：详细分析初始错误代码的问题，给出优化思路，使用布尔变量简化循环跳出操作，提高代码简洁性。
    - **个人心得**：初始代码因枚举起点和重叠判断处理不当只得到 20 分，提醒要正确理解枚举变量含义和处理重叠条件。
    - **核心代码**：
```cpp
for(int i=-n;i<=n;i++){//遍历x轴移动方向
    for(int j=-m;j<=m;j++){//遍历y轴移动方向
        int ans=0;
        bool tf=1;
        for(int k=1;k<=n2;k++){//遍历b数组的行 
            for(int x=1;x<=m2;x++){//遍历b数组的列 
                int blx=i+k,bly=j+x;
                if(blx>0&&bly>0&&blx<=n&&bly<=m) 
                    if(a[blx][bly]==b[k][x]) ans++;
                    else tf=0;
            }
        }
        maxx=max(ans*tf,maxx);
    }
}
```
核心思想：枚举第二张图在 x、y 轴的平移方向，对每个平移情况检查重叠像素，若有不同则标记，最后取重叠像素数和标记的乘积更新最大值。

### 最优关键思路或技巧
- **边界判断**：在检查重叠像素时，要确保数组下标不越界，通过判断下标范围避免 RE 错误。
- **重叠条件处理**：使用布尔变量标记重叠部分是否有不同像素，若有则放弃该重叠情况，避免复杂的循环跳出操作。

### 可拓展之处
同类型题如二维矩阵的匹配、图案拼接等，可采用类似的暴力枚举思路，关键在于处理好边界和匹配条件。类似算法套路还有枚举图形的旋转、翻转等操作，通过枚举所有可能的变换来找到最优匹配。

### 推荐题目
- [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)：涉及二维平面的覆盖问题，可通过枚举地毯的放置位置求解。
- [P1328 生活大爆炸版石头剪刀布](https://www.luogu.com.cn/problem/P1328)：需要枚举所有可能的游戏情况，根据规则计算得分。
- [P1540 机器翻译](https://www.luogu.com.cn/problem/P1540)：可通过枚举单词的输入顺序，模拟内存的使用情况。 

---
处理用时：32.18秒
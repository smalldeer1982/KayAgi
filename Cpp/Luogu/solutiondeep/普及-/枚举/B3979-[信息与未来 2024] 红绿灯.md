# 题目信息

# [信息与未来 2024] 红绿灯

## 题目描述

七段数码管是一种用来显示数字的电子元件，由七个可以发光的小段组成，这些小段排列成一个数字 $8$ 的形状。通过点亮不同的段,数码管可以显示出从 $0$ 到 $9$ 的数字。每个小段都有一个名字，从 $\tt A$ 到 $\tt G$，按下图方式排列和命名：

![](https://cdn.luogu.com.cn/upload/image_hosting/vmi6e5km.png)

数码管通过点亮不同的段显示不同的数字。例如：

- 数字 $0$ 需要点亮 $\tt{A,B,C,D,E,F}$ 段。

- 数字 $1$ 需要点亮 $\tt{B,C}$ 段。

- 数字 $2$ 需要点亮 $\tt{A,B,D,E,G}$ 段。

Dr. X 发现，红绿灯上的数码管经常发生故障，故障分为两类：**常亮**和**不亮**：

- 如果数码管的某段发生了**常亮**故障，这一段都会始终保持点亮的状态。

- 如果数码管的某段发生了**不亮**故障，这一段都会始终保持不亮的状态。

今天，Dr. X 感觉红绿灯的一个数字显示异常,因此记录了数码管显示数字的日志。Dr. X 希望
你根据日志推测数码管的每一段分别可能发生了怎样的故障?

## 说明/提示

对于 $100\%$ 的数据，满足 $0 \leq n \leq 100$。

>本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
3
1BCD
7BCD
7DCB```

### 输出

```
x--X---```

## 样例 #2

### 输入

```
3
0
1
8G```

### 输出

```
xxxxxx-```

# AI分析结果

### 综合分析与结论
这些题解核心思路都是模拟红绿灯数码管故障判断过程，先存储每个数字正常显示时需点亮的数码管信息，再依据输入日志对比实际与正常情况，判断各数码管是否存在常亮或不亮故障。
- **思路对比**：多数题解直接对比每次记录的实际亮灯情况与正常应亮灯情况；King_and_Grey 题解通过统计每段灯实际和应亮次数判断故障。
- **算法要点**：关键在于合理存储每个数字正常显示时需点亮的数码管信息，可使用字符串、二维数组、向量等；还需准确处理输入日志，对比实际与正常情况。
- **解决难点**：主要难点是清晰处理常亮和不亮故障判断逻辑，避免混淆；部分题解代码冗长，需优化以提高可读性和简洁性。

### 所选题解
- **作者：DFs_YYDS（5星）**
    - **关键亮点**：提供两种方法，方法二将常亮和不亮判断合并，大幅缩短代码量；思路清晰，代码注释详细。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
char ans[10];
int book[10][7]={1,1,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,};
int main(){
    int n;
    cin>>n;
    for(int i=0;i<7;i++)ans[i]='-';
    for(int i=0;i<n;i++){
        string s;
        cin>>s;
        int x=s[0]-'0',len=s.size(); 
        int a[10];
        for(int j=0;j<7;j++)a[j]=0;
        for(int j=1;j<len;j++)a[s[j]-'A']=1;
        for(int j=0;j<7;j++){
            if(a[j]==1&&book[x][j]==0)ans[j]='X';
            if(a[j]==0&&book[x][j]==1)ans[j]='x';
        }
    }
    for(int i=0;i<7;i++)cout<<ans[i];
    return 0;
}
```
    - **核心实现思想**：用二维数组 `book` 存储每个数字正常显示时各数码管是否需点亮；每次输入日志后，用数组 `a` 记录实际亮灯情况，在一个循环中同时判断常亮和不亮故障。

- **作者：遥遥领先（4星）**
    - **关键亮点**：思路清晰，将正常显示情况和输入显示情况打表，通过字符串对比判断故障，代码简洁。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

string s[10];
string ans;

void solve()
{
    s[0] = "1111110";
    s[1] = "0110000";
    s[2] = "1101101";
    s[3] = "1111001";
    s[4] = "0110011";
    s[5] = "1011011";
    s[6] = "1011111";
    s[7] = "1110000";
    s[8] = "1111111";
    s[9] = "1111011";
    ans = "-------";
    int n;
    cin >> n;
    while (n--)
    {
        string aa;
        cin >> aa;
        string a = aa.substr(1);
        int num = aa[0]-'0';
        string now = "";
        sort(a.begin(),a.end());
        for (int i = 0,j = 0;j < 7;j++)
        {
            char t = char(j+'A');
            if (a[i] == t) now += '1',i++;
            else now += '0';
        }
        for (int i = 0;i < 7;i++)
        {
            if (now[i] > s[num][i]) ans[i] = 'X';
            if (now[i] < s[num][i]) ans[i] = 'x';
        }
    }
    cout << ans;
}

signed main()
{
    solve();
    return 0;
}
```
    - **核心实现思想**：用字符串数组 `s` 存储每个数字正常显示情况，每次输入日志后，将实际亮灯情况整理成字符串 `now`，对比 `now` 和 `s[num]` 判断故障。

### 最优关键思路或技巧
- 使用二维数组或字符串数组存储每个数字正常显示时各数码管的点亮情况，便于快速查询和对比。
- 将常亮和不亮故障判断合并在一个循环中处理，减少代码量。

### 可拓展之处
同类型题如其他电子设备故障判断，可根据设备正常工作状态和实际工作状态对比判断故障；类似算法套路是先存储正常状态信息，再对比实际状态，根据差异判断问题。

### 推荐题目
- [P1001 A+B Problem](https://www.luogu.com.cn/problem/P1001)：基础模拟题，锻炼输入输出和简单逻辑处理能力。
- [P1008 三连击](https://www.luogu.com.cn/problem/P1008)：需要模拟数字组合情况，进行筛选判断。
- [P1046 陶陶摘苹果](https://www.luogu.com.cn/problem/P1046)：简单模拟题，模拟摘苹果过程。

### 个人心得
题解中无个人心得相关内容。 

---
处理用时：36.75秒
# 题目信息

# [GESP202406 三级] 寻找倍数

## 题目描述

小杨有一个包含 $n$ 个正整数的序列 $A=[a_1,a_2,\dots,a_n]$，他想知道是否存在 $i(1\leq i\leq n)$ 使得 $a_i$ 是序列 $A$ 中所有数的倍数。

## 说明/提示

**【样例解释】**

对于第⼀组数据，对于 $a_3=4$，满足 $a_3$ 是 $a_1$ 和 $a_2$ 的倍数。

**【数据范围】**

对于全部数据，保证有 $1\leq t\leq 10$，$1\leq n\leq 10^5$，$1\leq a_i\leq 10^9$。

## 样例 #1

### 输入

```
2
3
1 2 4
5
1 2 3 4 5```

### 输出

```
Yes
No```

# AI分析结果

### 综合分析与结论
该题解思路清晰，通过先找出序列中的最大值，再判断该最大值是否为序列中所有数的倍数来解决问题。其关键在于利用了“若一个数是序列中所有数的倍数，那么它一定是序列中的最大值”这一特性，简化了判断过程。算法要点明确，代码实现简洁易懂，可读性高。

### 所选题解
- 题解作者：chen_zhe，星级：5星。
  - 关键亮点：思路清晰，利用最大值特性简化判断过程，代码简洁易读。

### 重点代码及核心实现思想
```cpp
int t; cin >> t;
while (t--) {
    int n, maxa = 0;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        maxa = max(a[i], maxa);
    }
    bool flag = true;
    for (int i = 1; i <= n; i++) {
        if (maxa % a[i]!= 0) {
            flag = false;
            break;
        }
    }
    if (flag) puts("Yes");
    else puts("No");
}
```
核心实现思想：首先读取测试数据的组数 `t`，对于每组数据，先读取序列长度 `n` 并找出序列中的最大值 `maxa`，然后遍历序列，判断 `maxa` 是否能被序列中每个数整除，若存在不能整除的数则将标志 `flag` 置为 `false` 并跳出循环，最后根据 `flag` 的值输出结果。

### 最优关键思路或技巧
利用“若一个数是序列中所有数的倍数，那么它一定是序列中的最大值”这一特性，减少不必要的判断，提高算法效率。

### 可拓展之处
同类型题可能会要求找出序列中是其他数的特定倍数关系（如两倍、三倍等）的数，或者在更复杂的数据结构（如二维数组）中寻找满足倍数关系的元素。类似算法套路可先确定满足条件的数的特征，再根据特征进行筛选和判断。

### 洛谷相似题目推荐
1. P1047 [NOIP2005 普及组] 校门外的树
2. P1059 [NOIP2006 普及组] 明明的随机数
3. P1067 [NOIP2009 普及组] 多项式输出 

---
处理用时：13.58秒
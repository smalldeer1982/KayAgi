# 题目信息

# [GESP202406 四级] 黑白方块

## 题目描述

小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。对于网格图中的一个子矩形，小杨认为它是平衡的当且仅当其中黑色格子与白色格子数量相同。小杨想知道最大的平衡子矩形包含了多少个格子。

## 说明/提示

**【样例解释】**

对于样例 $1$，假设 $(i,j)$ 代表第 $i$ 行第 $j$ 列，最大的平衡子矩形的四个顶点分别为 $(1,2),(1,5),(4,2),(4,5)$。

**【数据范围】**

对于全部数据，保证有 $1\leq n,m\leq 10$。

## 样例 #1

### 输入

```
4 5
00000
01111
00011
00011```

### 输出

```
16```

# AI分析结果

### 综合分析与结论
该题解思路清晰，先解决判断矩形中黑白格子数量是否相等的子问题，再通过四重循环枚举所有子矩形并判断，最终找出最大平衡子矩形。算法要点在于“桶计数”思想统计黑白格子数量，以及四重循环枚举子矩形。难点在于如何高效枚举子矩形和判断其平衡性。整体思路和代码实现都较为易懂，但时间复杂度较高。

### 所选题解
- 星级：4星
- 关键亮点：思路清晰，代码可读性高，对解题步骤有详细解释。
- 重点代码：
```cpp
bool check(int xa, int ya, int xb, int yb) {
    int a[2] = {0, 0};
    for (int i = xa; i <= xb; i++) {
        for (int j = ya; j <= yb; j++)
            a[w[i][j]]++;
    }
    return a[0] == a[1];
}

int ans = 0;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        for (int ii = i; ii <= n; ii++) {
            for (int jj = j; jj <= m; jj++) {
                if (check(i, j, ii, jj))
                    ans = max(ans, (ii - i + 1) * (jj - j + 1));
            }
        }
    }
}
cout << ans << endl;
```
核心实现思想：`check` 函数使用“桶计数”统计矩形内黑白格子数量并判断是否相等，四重循环枚举所有子矩形，若平衡则更新最大平衡子矩形的格子数。

### 最优关键思路或技巧
- 思维方式：将原问题拆分为判断矩形平衡性和枚举子矩形两个子问题，逐步解决。
- 代码实现技巧：使用“桶计数”思想统计黑白格子数量。

### 可拓展之处
同类型题可拓展到更高维度的空间，或改变平衡的定义。类似算法套路有枚举子区间、二维前缀和优化枚举效率。

### 洛谷相似题目推荐
- P1719 最大加权矩形
- P2216 [HAOI2007]理想的正方形
- P3397 地毯

### 个人心得
题解中无个人心得相关内容。 

---
处理用时：12.79秒
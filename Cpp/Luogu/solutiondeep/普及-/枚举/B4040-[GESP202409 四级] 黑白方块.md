# 题目信息

# [GESP202409 四级] 黑白方块

## 题目描述

小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。
小杨想知道网格图中是否存在一个满足如下条件的子矩形：
- 子矩形由 $4$ 行 $4$ 列组成；
- 子矩形的第 $1$ 行和第 $4$ 行只包含白色格子；
- 对于子矩形的第 $2$ 行和第 $3$ 行，只有第 $1$ 个和第 $4$ 个格子是白色的，其余格子都是黑色的；

请你编写程序帮助小杨判断。

## 说明/提示

### 样例 1 解释

```plain
0000
0110
0110
0000
```

### 数据规模与约定

对全部的测试数据，保证 $1 \leq t\leq 10$，$1 \leq n,m \leq 100$。

## 样例 #1

### 输入

```
3
1 4
0110
5 5
00000
01100
01100
00001
01100
5 5
00000
01100
01110
00001
01100```

### 输出

```
No
Yes
No```

# AI分析结果

### 综合分析与结论
该题解思路清晰，通过枚举子矩形左上角坐标，利用常量数组记录目标子矩形形状，编写判断函数来检查提取的子矩形是否符合要求。算法要点在于枚举和对比，难点在于准确提取子矩形并与目标形状进行比较，题解很好地解决了这些问题。

### 所选题解
- 作者：chen_zhe，星级：5星。关键亮点：思路清晰，详细解释了枚举和判断的过程，代码可读性高。

### 重点代码及核心实现思想
```cpp
const char g[4][4] = {
    '0', '0', '0', '0',
    '0', '1', '1', '0',
    '0', '1', '1', '0',
    '0', '0', '0', '0'
};

bool check(int x, int y) {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            if (c[i + x][j + y]!= g[i][j])
                return false;
        }
    }
    return true;
}

// 枚举左上角坐标
for (int i = 1; i <= n - 3; i++) {
    for (int j = 1; j <= m - 3; j++) {
        if (check(i, j))
            flag = true;
    }
}
```
核心实现思想：使用常量数组 `g` 记录目标子矩形的形状，`check` 函数用于检查以 `(x, y)` 为左上角的子矩形是否与 `g` 相同。通过两层循环枚举所有可能的左上角坐标，调用 `check` 函数进行判断。

### 最优关键思路或技巧
- 使用常量数组记录目标子矩形形状，方便进行比较。
- 枚举子矩形左上角坐标，不重不漏地提取子矩形进行判断。

### 可拓展之处
同类型题如判断矩阵中是否存在特定形状的子矩阵，或在二维网格中寻找满足特定条件的区域。类似算法套路为枚举子区域的起始位置，然后进行条件判断。

### 洛谷题目推荐
- P1387 最大正方形
- P2216 [HAOI2007]理想的正方形
- P1002 [NOIP2002 普及组] 过河卒

---
处理用时：12.49秒
# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何找出覆盖给定点的最上面的地毯编号展开。最初有人尝试使用二维数组模拟地毯覆盖情况，但因数据范围大导致内存超限（MLE）。后续题解大多采用直接判断点是否在地毯内的方法，通过遍历所有地毯，更新覆盖该点的最上层地毯编号。部分题解还对遍历顺序进行了优化，从后往前遍历能更快找到最上层的地毯。

### 高评分题解
- **作者：智子（5星）**
    - **关键亮点**：思路清晰，先展示了会MLE的错误做法，再给出正确解法，对初学者有很好的警示和引导作用。代码注释详细，解释了幻数问题，提高了代码的规范性。
    - **核心代码**：
```cpp
#include<stdio.h>
const int MAXN = 10000 + 5;
int a[MAXN], b[MAXN], g[MAXN], k[MAXN];
int main() {
    int n, x, y;
    scanf("%d", &n);
    for(int i = 0; i < n; i++) {
        scanf("%d%d%d%d", &a[i], &b[i], &g[i], &k[i]);
    }
    scanf("%d%d", &x, &y);
    int ans = -1;
    for(int i = 0; i < n; i++) {
        if(x >= a[i] && y >= b[i] && x <= a[i] + g[i] && y <= b[i] + k[i]) {
            ans = i + 1;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```
    - **核心思想**：用四个数组存储每个地毯的左上角坐标和长宽信息，遍历所有地毯，判断给定点是否在地毯内，更新最上层地毯编号。

- **作者：谁懂谁伤心（4星）**
    - **关键亮点**：采用从后往前遍历地毯的方式，能更快找到最上层的地毯，优化了时间。代码简洁，直接输出结果。
    - **核心代码**：
```cpp
#include <iostream>  
int a[10001][2],b[10001][2],x,y,i,n,m;  
int main()  
{  
    scanf ("%d",&i);   
    for (int j=1;j<=i;j++) {scanf("%d%d%d%d",&a[j][0],&a[j][1],&n,&m); b[j][0]=a[j][0]+n; b[j][1]=a[j][1]+m;}  
    scanf ("%d%d",&x,&y);  
    for (int j=i;j>=1;j--)  
        if (x>=a[j][0]&&x<=b[j][0]&&y>=a[j][1]&&y<=b[j][1]) {printf("%d",j);  return 0;}  
    cout <<-1;  return 0;  
}  
```
    - **核心思想**：用二维数组存储每个地毯的左下角和右上角坐标，从后往前遍历地毯，找到覆盖给定点的地毯则输出编号并结束程序，未找到则输出 -1。

- **作者：Jayfeather2012（4星）**
    - **关键亮点**：思路清晰，从后往前遍历地毯，符合题目中后铺的地毯覆盖在前铺地毯之上的逻辑，能高效找到最上层地毯。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10003],b[10003],g[10003],k[10003],n,x,y;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i]>>b[i]>>g[i]>>k[i];
    cin>>x>>y;
    for(int i=n;i>=1;i--)
    {
        if(a[i]<=x&&a[i]+g[i]>=x&&b[i]<=y&&b[i]+k[i]>=y)
        {
            cout<<i;
            return 0;
        }
    }
    cout<<-1;
    return 0;
}
```
    - **核心思想**：存储每个地毯的左上角坐标和长宽信息，从后往前遍历地毯，判断给定点是否在地毯内，找到则输出地毯编号，未找到则输出 -1。

### 最优关键思路与技巧
- **避免使用二维数组**：由于数据范围大，使用二维数组会导致内存超限，应直接判断点是否在地毯内。
- **从后往前遍历**：根据后铺的地毯覆盖在前铺地毯之上的特点，从后往前遍历能更快找到最上层的地毯。

### 拓展思路
同类型题或类似算法套路：
- 二维平面上多个矩形区域的覆盖问题，如求多个矩形覆盖后的总面积、判断某个区域被覆盖的次数等。
- 三维空间中多个立方体的覆盖问题，思路类似，只是判断点是否在立方体内的条件更复杂。

### 推荐题目
- [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：涉及二维平面上的区域问题，需要判断正方形是否满足条件。
- [P2004 领地选择](https://www.luogu.com.cn/problem/P2004)：在二维平面上选择合适的矩形区域，与本题判断点是否在矩形内有相似之处。
- [P1169 [ZJOI2007]棋盘制作](https://www.luogu.com.cn/problem/P1169)：同样是二维平面上的矩形问题，需要找出满足条件的最大矩形。

### 个人心得摘录与总结
- **智子**：尝试使用二维数组模拟地毯覆盖情况，结果因数组过大导致MLE，提醒我们在处理大数据范围时要注意内存使用。
总结：在编写代码前要充分考虑数据范围，避免使用会导致内存超限的方法。 

---
处理用时：34.21秒
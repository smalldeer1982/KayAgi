# 题目信息

# [NOIP 1998 普及组] 三连击

## 题目背景

本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。

## 题目描述

将 $1, 2, \ldots , 9$ 共 $9$ 个数分成 $3$ 组，分别组成 $3$ 个三位数，且使这 $3$ 个三位数构成 $1 : 2 : 3$ 的比例，试求出所有满足条件的 $3$ 个三位数。

## 说明/提示

NOIP1998 普及组 第一题

## 样例 #1

### 输入

```
无```

### 输出

```
192 384 576
* * *
...

* * *
（剩余部分不予展示）```

# AI分析结果

### 综合分析与结论
这些题解主要围绕枚举和判断两个核心步骤解决“三连击”问题。思路可分为两类：一是枚举第一个三位数，计算另外两个数并判断数字是否重复；二是生成 1 - 9 的全排列，分割为三个三位数并验证比例关系。
- **算法要点**：多数题解使用数组标记数字是否出现来判断重复，部分利用 1 - 9 的和与积为定值简化判断。
- **解决难点**：核心难点是判断三个三位数是否由 1 - 9 不重复组成，通过数组标记、和积判断等方法解决。
- **评分**：
    - **Kelin**：5 星。思路清晰，代码简洁，通过合理范围枚举和数组标记快速求解。
    - **usercjh123**：4 星。巧妙使用 `next_permutation` 生成全排列，代码简洁易读。
    - **liuyubobobo**：4 星。同样利用 `next_permutation` 生成全排列，逻辑清晰。

### 所选题解
- **Kelin（5 星）**
    - **关键亮点**：代码最短，通过合理限定枚举范围（192 - 327），使用 `memset` 初始化数组，标记数字出现情况，简洁高效。
```cpp
#include<cstdio>
#include<cstring>
int i,j,v;bool a[10];
int main()
{
    for(i=192;i<=327;i++)
    {
        memset(a,0,sizeof(a));v=0;
        a[i%10]=a[i/10%10]=a[i/100]=a[i*2%10]=a[i*2/10%10]=a[i*2/100]=a[i*3%10]=a[i*3/10%10]=a[i*3/100]=1;
        for(j=1;j<=9;j++) v+=a[j];
        if(v==9) printf("%d %d %d\n",i,i*2,i*3);
    }
    return 0;
}
```
核心思想：枚举第一个三位数，标记三个数的每一位数字，统计出现的数字个数，若为 9 则满足条件。

- **usercjh123（4 星）**
    - **关键亮点**：使用 `next_permutation` 生成 1 - 9 的全排列，简化排列生成过程，代码简洁易读。
```c++
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long ll;
const ll maxn = 9;
ll num[9];
ll get_num(ll l, ll r){
    ll temp = 0;
    for(int i = l ; i < r ; i++){
        temp += num[i];
        temp *= 10;
    }
    temp += num[r];
    return temp;
}
int main(){
    for(int i = 0 ; i < 9 ; i++){
        num[i] = i + 1;
    }
    do{
        ll a = get_num(0,2);
        ll b = get_num(3,5);
        ll c = get_num(6,8);
        if(a * 2 == b && a * 3 == c){
            cout << a << " " << b << " " << c << endl; 
        }
    }while(next_permutation(num,num+9));
}
```
核心思想：生成 1 - 9 的全排列，将其分割为三个三位数，验证是否满足 1:2:3 的比例关系。

- **liuyubobobo（4 星）**
    - **关键亮点**：利用 `next_permutation` 生成全排列，代码简洁，逻辑清晰。
```cpp
#include <vector>
#include <algorithm>
#include <cstdio>
using namespace std;
int main(){
    vector<int> v = vector<int>();
    for( int i = 1 ; i <= 9 ; i ++ )
        v.push_back(i);
    do{
        int a = v[0]*100+v[1]*10+v[2];
        int b = v[3]*100+v[4]*10+v[5];
        int c = v[6]*100+v[7]*10+v[8];
        if( a*2 == b && a*3 == c )
            printf("%d %d %d\n",a, b, c );
    }while( next_permutation( v.begin(), v.end() ) );
    return 0;
}
```
核心思想：生成 1 - 9 的全排列，将其分割为三个三位数，判断是否满足 1:2:3 的比例关系。

### 最优关键思路或技巧
- **合理枚举范围**：通过分析题目条件，确定第一个三位数的合理范围（如 192 - 327 或 123 - 333），减少不必要的枚举。
- **数组标记**：使用数组标记数字是否出现，快速判断数字是否重复。
- **利用和积特性**：利用 1 - 9 的和为 45、积为 362880 的特性，简化数字重复判断。
- **使用库函数**：使用 `next_permutation` 生成全排列，避免手动编写复杂的排列生成代码。

### 可拓展之处
同类型题如数字组合满足特定条件的问题，可采用类似的枚举和判断思路。例如：
- 数字组合满足特定运算关系（如和、差、积、商等）。
- 数字组合满足特定数位条件（如无重复数字、特定数位之和等）。

### 洛谷推荐题目
- P1008 [NOIP1998 普及组] 三连击（本题）
- P1019 [NOIP2000 提高组] 单词接龙：通过枚举和回溯的方法，找出满足条件的单词接龙。
- P1036 [NOIP2002 普及组] 选数：从给定数字中选出若干个数，使其和为素数，可使用枚举和素数判断。

### 个人心得摘录与总结
- **鸩羽**：表示题目对新人不友好，一开始手动筛选，体现了新人面对此类题目的困难。
- **静沐暖阳**：提到班里大佬用 `next_permutation`，说明库函数在解决排列组合问题中的便捷性。
- **Drug__Lover**：第一次提交题解，使用 1 - 9 的和与积判断数字是否重复，提供了一种简洁的判断思路。 

---
处理用时：38.55秒
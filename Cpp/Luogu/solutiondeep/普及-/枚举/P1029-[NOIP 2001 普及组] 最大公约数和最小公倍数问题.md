# 题目信息

# [NOIP 2001 普及组] 最大公约数和最小公倍数问题

## 题目描述

输入两个正整数 $x_0, y_0$，求出满足下列条件的 $P, Q$ 的个数：

1. $P,Q$ 是正整数。

2. 要求 $P, Q$ 以 $x_0$ 为最大公约数，以 $y_0$ 为最小公倍数。

试求：满足条件的所有可能的 $P, Q$ 的个数。

## 说明/提示

$P,Q$ 有 $4$ 种：

1. $3, 60$。
2. $15, 12$。
3. $12, 15$。
4. $60, 3$。

对于 $100\%$ 的数据，$2 \le x_0, y_0 \le {10}^5$。

**【题目来源】**

NOIP 2001 普及组第二题

## 样例 #1

### 输入

```
3 60
```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕最大公约数和最小公倍数的性质来解决问题，核心思路是利用公式 $P \times Q = \gcd(P, Q) \times \text{lcm}(P, Q)$ 进行枚举和判断。部分题解采用素因数分解的方法，通过分析素因子指数的变化来确定满足条件的数对数量。

算法要点包括：枚举因数、判断最大公约数是否符合条件、处理重复计数问题、特判 $x_0 = y_0$ 的情况。

解决的难点有：避免暴力枚举导致的超时问题，处理重复计数以保证结果的准确性。

### 所选题解
1. **作者：樱雪喵（5星）**
    - 关键亮点：思路清晰，代码简洁，对枚举范围的优化解释详细，还统一回答了评论区常见问题。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long m,n,ans;
int main(){
    cin>>m>>n;
    if(m==n) ans--;
    n*=m;
    for(long long i=1;i<=sqrt(n);i++){
        if(n%i==0&&__gcd(i,n/i)==m) ans+=2;
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：先将两数之积存入 `n`，从 1 到 $\sqrt{n}$ 枚举因数 `i`，若 `n` 能被 `i` 整除且 `i` 与 `n/i` 的最大公约数为 `m`，则答案加 2。特判 `m == n` 的情况，避免重复计数。

2. **作者：sochiji（4星）**
    - 关键亮点：从素因数分解的角度分析问题，给出了详细的数学推导和证明，提供了一种新的解题思路。
    - 核心代码：
```cpp
#include <iostream>
int main()
{
    int x, y;
    std::cin >> x >> y;
    if (y % x!= 0)
        std::cout << 0;
    else
    {
        int quotient = y / x;
        int count = 0;
        int currentFactor = 2;
        while (quotient > 1)
        {
            if (quotient % currentFactor == 0)
            {
                count++;
                while (quotient % currentFactor == 0)
                    quotient /= currentFactor;
            }
            currentFactor++;
        }
        std::cout << (1 << count);
    }
    return 0;
}
```
核心实现思想：先判断 `y` 是否能被 `x` 整除，若不能则无解。若能，则对 `y/x` 进行素因数分解，统计指数大于 0 的素因子个数 `count`，最终结果为 $2^{count}$。

3. **作者：zhangboju（4星）**
    - 关键亮点：详细证明了辗转相除法求最大公约数和两数乘积等于最大公约数与最小公倍数乘积的定理，对代码的错误点和优化点进行了说明。
    - 核心代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long x,y;
inline long long gcd(long long x,long long y)
{
    if(y==0) return x;
    return gcd(y,x%y);
}
int main()
{
    cin>>x>>y;
    long long ans=0;
    for(long long i=1;i<=sqrt(x*y);i++)
    {
        if(x*y%i==0&&gcd(i,x*y/i)==x) ans++;
    }
    ans*=2;
    if(x==y) ans--;
    cout<<ans;
    return 0;
}
```
核心实现思想：自定义 `gcd` 函数求最大公约数，从 1 到 $\sqrt{x*y}$ 枚举因数 `i`，若 `x*y` 能被 `i` 整除且 `i` 与 `x*y/i` 的最大公约数为 `x`，则答案加 1。最后答案乘 2 并特判 `x == y` 的情况。

### 最优关键思路或技巧
- 利用公式 $P \times Q = \gcd(P, Q) \times \text{lcm}(P, Q)$ 减少枚举范围，只需要枚举到 $\sqrt{P \times Q}$，避免重复计算。
- 特判 $x_0 = y_0$ 的情况，防止重复计数。
- 采用素因数分解的方法，通过分析素因子指数的变化来确定满足条件的数对数量。

### 可拓展之处
同类型题或类似算法套路：
- 已知两数的最大公约数和最小公倍数，求这两个数的具体值。
- 给定多个数，求满足特定最大公约数和最小公倍数关系的数对或数组。

### 推荐题目
1. [P1072  Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)
2. [P2152 SDOI2009]SuperGCD](https://www.luogu.com.cn/problem/P2152)
3. [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)

### 个人心得
- 作者：陈嘉逸2012：“有点难，听了课才会。” 总结：对于有一定难度的题目，通过听课学习可以更好地理解和解决问题。

---
处理用时：30.22秒
# 题目信息

# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕加分二叉树问题，采用动态规划方法求解。核心思路是通过设计状态和状态转移方程，计算出符合中序遍历为 `(1,2,3,...,n)` 且加分最高的二叉树的最高加分，并输出其前序遍历。各题解在实现方式上有所不同，有的采用区间DP，有的采用树形DP或记忆化搜索，但本质都是利用子问题的最优解来构建原问题的最优解。

### 所选题解
- **作者：冒泡ioa（5星）**
    - **关键亮点**：思路清晰，详细回顾了动态规划及区间动规的相关概念，逐步推导状态和状态转移方程，代码可读性高。
    - **核心代码**：
```c++
for (int len = 1; len < n; ++len) {
    for (int i = 1; i + len <= n; ++i) {
        int j = i + len;
        f[i][j] = f[i + 1][j] + f[i][i];
        root[i][j] = i;
        for (int k = i + 1; k < j; ++k) {
            if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                root[i][j] = k;
            }
        }
    }
}
```
    - **核心思想**：通过枚举区间长度 `len` 和区间起点 `i`，计算区间终点 `j`，再在区间内枚举根节点 `k`，更新 `f[i][j]` 为最大加分，并记录对应的根节点 `root[i][j]`。

- **作者：winmt（4星）**
    - **关键亮点**：将问题分解为三个任务，分别解决最大分值计算、前序遍历输出和主程序实现，采用自上而下的记忆化方法，对非线性结构问题的动态规划求解有一定指导意义。
    - **核心代码**：
```cpp
long long search(int L, int r) {
    int  k;
    long long  now, ans;
    if (L > r) return 1;
    if (f[L][r]== -1) {
        for(k=L; k<=r; k++) {
            now = search(L, k-1) * search(k+1, r) + f[k][k];
            if(now > f[L][r]) {
                f[L][r] = now;
                root[L][r] = k;
            }
        }
    }
    return  f[L][r];
}
```
    - **核心思想**：递归计算 `f[L][r]`，若未计算过，则枚举所有可能的子根 `k`，计算以 `k` 为根的子树的分值，更新 `f[L][r]` 和 `root[L][r]`。

- **作者：噬月（4星）**
    - **关键亮点**：详细分析了题目具有最优子结构和无后效性，对状态设计、状态转移方程的推导以及边界情况和等号问题进行了深入讨论。
    - **核心代码**：
```cpp
for (int range = 1; range <= n; ++ range ) {
    for (int i = 1; i + range <= n; ++ i ) {
        int j = i  + range;
        for (int k = i ; k <= j; ++ k ) {
            if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                root[i][j] = k;
            }
        }
    }
}
```
    - **核心思想**：通过枚举区间长度 `range` 和区间起点 `i`，计算区间终点 `j`，再在区间内枚举根节点 `k`，更新 `f[i][j]` 为最大加分，并记录对应的根节点 `root[i][j]`。

### 最优关键思路或技巧
- **状态设计**：使用二维数组 `f[i][j]` 表示节点 `i` 到节点 `j` 构成的子树的最大加分，同时使用 `root[i][j]` 记录该子树的根节点，便于输出前序遍历。
- **状态转移方程**：`f[i][j] = max(f[i][k - 1] * f[k + 1][j] + f[k][k])`，通过枚举根节点 `k` 来更新最大加分。
- **记忆化搜索**：避免重复计算子问题，提高算法效率。

### 拓展思路
同类型题或类似算法套路：
- 区间DP相关问题，如石子合并问题（P1775 石子合并（弱化版）），通过枚举区间和分割点来更新最优解。
- 树形DP问题，如树的最大独立集问题，通过递归计算子树的最优解来构建整棵树的最优解。

### 推荐题目
- P1775 石子合并（弱化版）
- P1005 矩阵取数游戏
- P1045 麦森数

### 个人心得
- **噬月**：对边界情况和等号问题进行了深入讨论，通过具体例子分析了边界默认处理不会影响最终答案，以及不等号改为等号对前序遍历的影响。这提醒我们在解题时要仔细考虑边界情况和细节问题，避免因疏忽导致错误。 

---
处理用时：33.80秒
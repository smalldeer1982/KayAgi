# 题目信息

# 连续自然数和

## 题目描述

对一个给定的正整数 $M$，求出所有的连续的正整数段（每一段至少有两个数），这些连续的自然数段中的全部数之和为 $M$。

例子：$1998+1999+2000+2001+2002 = 10000$，所以从 $1998$ 到 $2002$ 的一个自然数段为 $M=10000$ 的一个解。


## 样例 #1

### 输入

```
10000
```

### 输出

```
18 142 
297 328 
388 412 
1998 2002
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕找出所有连续正整数段，使其和为给定正整数 $M$ 展开。思路大致可分为暴力枚举、数学推导、前缀和与二分查找、尺取法等几类。
- **暴力枚举**：直接枚举首项和末项，计算和并判断是否等于 $M$，时间复杂度较高，一般为 $O(N^2)$，部分通过剪枝优化可减少不必要的计算。
- **数学推导**：利用等差数列求和公式进行变形，通过分解因数、解一元二次方程等方式求解首项和末项，时间复杂度可优化到 $O(\sqrt M)$。
- **前缀和与二分查找**：先计算前缀和数组，再通过枚举首项，利用二分查找找到满足条件的末项，时间复杂度为 $O(Nlog_2N)$。
- **尺取法**：使用双指针表示区间左右端点，根据区间和与 $M$ 的大小关系移动指针，时间复杂度为 $O(N)$。

### 高评分题解
1. **作者：gzw2005（5星）**
    - **关键亮点**：思路清晰，通过数学推导将问题转化为分解因数和求解二元一次方程组，时间复杂度低至 $O(\sqrt M)$，代码简洁易懂。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m;
int main(){
    cin>>m;
    for(int k1=sqrt(2*m);k1>1;k1--)//枚举k1(注意是k1>1而不是k1>=1)
        if(2*m%k1==0 && (k1+2*m/k1)%2){//如果K2是整数而且与K1一奇一偶
            int k2=2*m/k1;
            cout<<(k2-k1+1)/2<<" "<<(k1+k2-1)/2<<endl;//输出答案
        }
    return 0;
}
```
    - **核心思想**：设首项为 $L$，末项为 $R$，根据等差数列求和公式得到 $(L + R)(R - L + 1) = 2M$，将 $2M$ 分解为两个因数 $k_1$ 和 $k_2$，通过解方程组得到 $L$ 和 $R$，并根据奇偶性和条件筛选出有效解。
2. **作者：chy010827（4星）**
    - **关键亮点**：暴力解法思路简单直接，代码可读性高，适合初学者理解。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,sum,j;
int main()
{
    cin>>n;     //读入       
    for(int i=1;i<=n/2;i++)
    {
        sum=0;     //sum归零
        for(j=i;j<n;j++)   //枚举每一个i对应的j，这个j是最小的，从i加到j总和大于等于n的自然数
        {
            sum+=j;            //sum记录从i加到j的总和
            if(sum>=n)break;    //当sum>=n时，跳出循环
        }
        if(sum==n)cout<<i<<' '<<j<<endl;   //输出
    }
    return 0;
}
```
    - **核心思想**：枚举首项 $i$，从 $i$ 开始累加，直到和大于等于 $M$，若和等于 $M$ 则输出首项和末项。
3. **作者：Frenix（4星）**
    - **关键亮点**：使用尺取法，时间复杂度为 $O(N)$，代码简洁高效。
    - **核心代码**：
```cpp
#include<cstdio>

int m;

int main()
{
    scanf("%d",&m);
    int sum=3;
    for(int i=1,j=2;i<=m/2;)
    {
        if(sum==m)
        {
            printf("%d %d\n",i,j);
            sum-=i;
            i++;
        }
        else if(sum<m)
        {
            j++;
            sum+=j;
        }
        else 
        {
            sum-=i;
            i++;
        } 
    }
    return 0;
}
```
    - **核心思想**：使用双指针 $i$ 和 $j$ 表示区间左右端点，根据区间和 $sum$ 与 $M$ 的大小关系移动指针，当 $sum$ 等于 $M$ 时输出区间。

### 最优关键思路或技巧
- **数学推导**：利用等差数列求和公式进行变形，将问题转化为因数分解或方程求解，可大幅降低时间复杂度。
- **尺取法**：使用双指针维护一个区间，根据区间和与目标值的大小关系移动指针，可在线性时间内解决问题。
- **剪枝优化**：在暴力枚举时，通过判断和是否大于目标值提前终止循环，减少不必要的计算。

### 可拓展之处
同类型题或类似算法套路：
- 求连续子数组的和等于目标值，可使用尺取法或前缀和。
- 分解因数相关问题，可通过枚举因数或质因数分解求解。
- 等差数列相关问题，可利用等差数列的性质和公式进行推导。

### 推荐题目
1. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)：尺取法的典型应用。
2. [P2671 求和](https://www.luogu.com.cn/problem/P2671)：涉及等差数列和前缀和的知识。
3. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)：可使用二分查找或数据结构维护中位数。

### 个人心得摘录与总结
- **作者：八重樱**：没考虑枚举算法复杂度，用 dfs 找因数并打素数表，遇到爆栈和数据类型溢出问题，经优化可 AC 高精以下数据。总结：做题前应先评估算法复杂度，注意数据类型范围。
- **作者：lsy2006**：利用等差数列求和公式推导方程，解一元二次方程求解末项，判断解是否为正整数。总结：熟练掌握数学公式和方程求解方法有助于解题。 

---
处理用时：43.05秒
# 题目信息

# [USACO1.3] 牛式 Prime Cryptarithm

## 题目描述

下面是一个乘法竖式，如果用我们给定的那 $n$ 个数字来取代 `*`，可以使式子成立的话，我们就叫这个式子为牛式。

```cpp
          ***
    x      **
   ----------
         ***
        ***
   ----------
        ****
```

数字只能取代 `*`，当然第一位不能为 $0$，况且给定的数字里不包括 $0$。


注意一下在美国的学校中教的“部分乘积”，第一部分乘积是第二个数的个位和第一个数的积，第二部分乘积是第二个数的十位和第一个数的乘积。

请计算出牛式的数量。



## 说明/提示

### 样例解释

```
          222
    x      22
   ----------
         444
        444
   ----------
        4884
```

不需要别的数，严格符合上图的数位情况，可以证明没有其他情况。



不加入样例解释：做题人如果理解错题意会进入误区

比如不用填中间的数，位数没有要求 `34*2=68` 符合要求等误区。

### 数据规模  
对于 $100\%$ 的数据，$1\le n \le 9$，$a_i \in [1,9] \cap \mathbb Z$ 且 $a_i$ 不重复。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
5
2 3 4 6 8
```

### 输出

```
1
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均为枚举所有可能的三位数和两位数组合，然后依据乘法竖式的规则计算部分乘积与最终乘积，再检查这些数的位数以及每一位数字是否在给定数字集合内。具体实现方式存在差异，有的采用直接枚举数字，有的按位枚举，还有的运用搜索算法。

### 所选题解
- **作者：bits（5星）**
    - **关键亮点**：思路清晰，代码简洁，通过使用桶标记数字，封装检查函数，提升了代码的可读性与可维护性。
    - **核心代码**：
```cpp
bool p[15];
bool f(int n) {
    while(n) {
        if(p[n%10]==0) return 0;
        n/=10;
    }
    return 1;
}
bool check(int x,int y) {
    int a=x*(y%10),b=x*(y/10),test=x*y;
    if(a>999 || b>999 || test>9999) return 0;
    if(f(x)==1 && f(y)==1 && f(a)==1 && f(b)==1 && f(test)==1) return 1;
    else return 0;
}
int main() {
    int n,key,ans=0;
    scanf("%d",&n);
    for(int i=0;i<n;i++) {
        scanf("%d",&key);
        p[key]=true;
    }
    for(int i=100;i<1000;i++) {
        for(int j=10;j<100;j++) {
            if(check(i,j)==1) ans++;
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心实现思想**：利用桶 `p` 标记给定数字，`f` 函数用于检查一个数的每一位是否都在给定数字集合内，`check` 函数检查乘法竖式的各个部分是否满足位数和数字要求，最后枚举所有可能的组合并统计符合条件的数量。

- **作者：mod998244353（4星）**
    - **关键亮点**：在暴力枚举的基础上进行了优化，分析乘数的首位情况，缩小枚举范围，提高了算法效率。
    - **核心代码**：
```cpp
bool p[10];
bool numcheck(int n) {
    for(; n; n/=10) {
        if(!p[n%10]) return false;
    }
    return true;
}
bool check(int x,int y) {
    int part1=x*(y%10),part2=x*(y/10),cj=x*y;
    if(part1>999 || part2>999 || cj>9999) return false;
    if(numcheck(x) && numcheck(y) && numcheck(part1) && numcheck(part2) && numcheck(cj)) return true;
    return false;
}
int main() {
    memset(p,false,sizeof(p));
    int n,num,cnt=0;
    n=read();
    for(; n; --n) {
        num=read();
        p[num]=true;
    }
    for(int i=111; i<900; ++i) {
        for(int j=11,p=10000/i; j<=p; ++j) {
            if(check(i,j)) ++cnt;
        }
    }
    return printf("%d",cnt),putchar('\n'),0;
}
```
    - **核心实现思想**：同样使用桶标记数字，`numcheck` 函数检查数字是否符合要求，`check` 函数检查乘法竖式的合法性。通过分析乘数首位，将 `i` 的枚举范围缩小到 `111` 到 `899`，`j` 的枚举范围缩小到 `11` 到 `10000/i`，减少不必要的计算。

### 最优关键思路或技巧
- **桶标记**：利用数组作为桶，标记给定数字，方便检查一个数的每一位是否在给定数字集合内。
- **函数封装**：将检查数字合法性和乘法竖式合法性的逻辑封装成函数，提高代码的可读性和可维护性。
- **剪枝优化**：在枚举过程中，提前判断部分乘积和最终乘积的位数是否符合要求，不符合则跳过，减少不必要的计算。

### 拓展思路
同类型题目可能会改变乘法竖式的形式或增加更多的约束条件，但核心思路仍然是枚举和检查。可以运用类似的桶标记和剪枝优化技巧，提高算法效率。

### 推荐题目
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：枚举组合并检查是否满足条件。
- [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)：通过枚举传球次数和位置，动态规划求解方案数。
- [P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)：枚举所有可能的组合并输出。

### 个人心得摘录与总结
- **作者：ShineEternal**：在调试过程中，最初未考虑乘出来的所有数是否在给定数列里，通过观察输出才发现问题。总结是在处理此类问题时，要全面考虑各种判断条件。
- **作者：I_Am_Danny**：认为这道题数据较弱，暴力枚举能通过，但强数据下搜索可能更有优势，可用于练习搜索算法。 

---
处理用时：32.87秒
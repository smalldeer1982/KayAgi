# 题目信息

# 最大加权矩形

## 题目描述

为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。

校长先给他们一个 $n\times n$ 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 $[-127,127]$ ,例如

```plain
 0 –2 –7  0 
 9  2 –6  2
-4  1 –4  1 
-1  8  0 –2
```

在左下角：

```plain
9  2
-4  1
-1  8
```

和为 $15$。

几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？


## 说明/提示

$1 \leq n\le 120$

## 样例 #1

### 输入

```
4
0 -2 -7 0
 9 2 -6 2
-4 1 -4  1 
-1 8  0 -2
```

### 输出

```
15```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何求解矩阵中最大加权矩形和展开，核心思路可分为两类：一是矩阵压缩结合最大子段和，二是使用二维前缀和。

#### 矩阵压缩结合最大子段和
- **思路**：通过枚举矩阵的上下边界，将多行压缩为一行，把二维问题转化为一维的最大子段和问题。
- **算法要点**：
    - 枚举上下边界，将每列元素累加得到一维数组。
    - 对一维数组使用最大子段和算法（如动态规划）求解最大和。
- **解决难点**：如何高效地将二维矩阵压缩为一维数组，以及如何处理最大子段和问题。

#### 二维前缀和
- **思路**：利用二维前缀和数组快速计算任意子矩阵的和，通过四重循环枚举所有可能的子矩阵，找出最大和。
- **算法要点**：
    - 计算二维前缀和数组 `sum[i][j]`，表示从 `(1,1)` 到 `(i,j)` 的元素和。
    - 根据前缀和公式 `sum[x2][y2] - sum[x2][y1 - 1] - sum[x1 - 1][y2] + sum[x1 - 1][y1 - 1]` 计算子矩阵和。
- **解决难点**：推导并正确使用二维前缀和公式，避免四重循环带来的超时问题。

### 评分较高的题解
1. **作者：Yaser（5星）**
    - **关键亮点**：思路清晰，详细解释了矩阵压缩的过程，代码结构清晰，使用宏定义简化代码。
    - **核心代码**：
```cpp
void Arrsum() {
    mset(dp, 0);
    loop(i, 1, n) {
        dp[i] = max(dp[i], dp[i - 1] + temp[i]);
        ans = max(ans, dp[i]);
    }
}

void MatrixSum() {
    loop(i, 1, n) {
        mset(temp, 0);
        loop(j, i, n) {
            loop(k, 1, n) {
                temp[k] += matrix[j][k];
            }
            Arrsum();
        }
    }
}
```
    - **核心实现思想**：`Arrsum` 函数用于计算一维数组的最大子段和，`MatrixSum` 函数通过枚举上下边界，将多行压缩为一行，调用 `Arrsum` 函数求解最大和。

2. **作者：Stella_Yan（4星）**
    - **关键亮点**：通过图形直观解释二维前缀和的原理，代码简洁易懂。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=n;j++){
        cin>>a[i][j];
        qz[i][j]=qz[i][j-1]+a[i][j];//求前缀和
        sum[i][j]=qz[i][j]+sum[i-1][j];//计算sum
    }
}
int mx=-99999999;//存储答案
for(int x1=1;x1<=n;x1++){
    for(int y1=1;y1<=n;y1++){
        for(int x2=1;x2<=n;x2++){
            for(int y2=1;y2<=n;y2++){
                if(x2<x1 || y2<y1) continue;
                mx=max(mx,sum[x2][y2]+sum[x1-1][y1-1]-sum[x2][y1-1]-sum[x1-1][y2]);//求最大值
            }
        }
    }
}
```
    - **核心实现思想**：先计算每行的前缀和 `qz`，再计算二维前缀和 `sum`，最后通过四重循环枚举所有可能的子矩阵，使用前缀和公式计算子矩阵和并找出最大值。

3. **作者：X_WT（4星）**
    - **关键亮点**：先给出一维最大子段和的代码，再逐步引导到二维矩阵的处理，使用前缀和快速表示压缩的矩形。
    - **核心代码**：
```cpp
for(i=1;i<=n;++i){
    for(j=1;j<=n;++j){
        scanf("%d",&a[i][j]);
        a[i][j]+=a[i-1][j];//根据前缀和定义处理
    }
}
for(i=1;i<=n;++i){
    for(k=1;k<=i;++k){
        int f[150]={0},dp[150]={0};
        for(j=1;j<=n;++j){
            f[j]=a[i][j]-a[i-k][j];//求压缩的矩形第j列的值
            dp[j]=maxn(dp[j-1]+f[j],f[j]);//动态规划
            ans=maxn(ans,dp[j]);//更新答案
        }
    }
}
```
    - **核心实现思想**：输入时计算前缀和数组 `a`，通过枚举上下边界 `i` 和 `k`，计算压缩后的一维数组 `f`，使用动态规划求解最大子段和并更新答案。

### 最优关键思路或技巧
- **矩阵压缩**：将二维矩阵问题转化为一维最大子段和问题，降低问题复杂度。
- **前缀和**：无论是一维还是二维前缀和，都能快速计算子矩阵的和，避免重复计算。

### 可拓展之处
同类型题如求三维空间中最大加权长方体的和，可采用类似的降维思想，将三维问题转化为二维问题，再进一步转化为一维问题求解。

### 推荐题目
1. [P1115 最大子段和](https://www.luogu.org/problemnew/show/P1115)：一维最大子段和问题，是本题的基础。
2. [P2475 [SCOI2006] 最大子矩阵](https://www.luogu.org/problemnew/show/P2475)：最大子矩阵问题的拓展，可能需要更复杂的处理。
3. [P1719 最大加权矩形](https://www.luogu.org/problemnew/show/P1719)：与本题类似，可进一步巩固相关知识点。

### 个人心得摘录与总结
- **作者：LiHaoYu0512**：一开始尝试暴力和一维前缀和化简都失败，最后采用二维前缀和成功解决问题，说明在解题时要不断尝试不同方法，遇到复杂度高的问题可考虑更高效的算法。
- **作者：zhz小蒟蒻**：使用前缀和优化暴力枚举，但仍超时，后来增加一个前缀和数组解决问题，体现了前缀和在优化矩阵求和问题中的重要性，同时也说明在优化时要考虑全面。 

---
处理用时：37.36秒
# 题目信息

# 无穷的序列

## 题目描述

有一个无穷序列如下：

$\texttt{110100100010000100000}$…

请你找出这个无穷序列中指定位置上的数字。

## 说明/提示

对于 $100\%$ 的数据，$N \leq 1\,500\,000$，$A_i≤10^9$。

## 样例 #1

### 输入

```
4
3
14
7
6 
```

### 输出

```
0
0
1
0
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕找出无穷序列指定位置数字展开，解题思路可分为数学推导和暴力枚举两类。数学推导类通过找出序列中 1 出现位置的通项公式，判断指定位置是否满足该公式来确定数字；暴力枚举类则先记录序列中 1 的位置，再用二分查找判断指定位置是否为 1。

### 高评分题解
1. **作者：若如初见（5 星）**
    - **关键亮点**：思路清晰，有严谨的数学公式推导和证明，代码注释详细，时间复杂度为 $O(1)$。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <cstdio>
#include <cmath>
#define int long long 
int T,n;
bool check(int x){
    int delta=8*x-7;
    if(delta<0) return 0;
    int t=sqrt(delta);
    if(t*t!=delta) return 0; 
    return (((1+t)%2==0&&(1+t)/2>0)||((1-t)%2==0&&(1-t)/2>0));
}
signed main(){
    scanf("%lld",&T);
    while(T--){
        scanf("%lld",&n);
        if(check(n)) printf("1\n");
        else printf("0\n");
    }
    return 0;
}
```
    - **核心实现思想**：先推导出序列中 1 出现位置的通项公式 $b_n = \frac{n(n - 1)}{2} + 1$，对于询问的位置 $k$，判断方程 $b_n = k$ 有无正整数解，即判断 $\Delta = 8k - 7$ 是否为完全平方数，且 $\frac{1 + \sqrt{\Delta}}{2}$ 或 $\frac{1 - \sqrt{\Delta}}{2}$ 是否为正整数。

2. **作者：Rainey（4 星）**
    - **关键亮点**：代码简洁，直接运用数学方法，时间复杂度低。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        int x;
        scanf("%d",&x);
        x--;
        if(int(sqrt(x*2))*int(sqrt(x*2)+1)==x*2) printf("1\n");
        else printf("0\n");
    }
    return 0;
}
```
    - **核心实现思想**：根据等差数列求和得出第 $n$ 个 1 前的长度为 $\frac{n(n - 1)}{2}$，第 $n$ 个 1 的位置为 $\frac{n(n - 1)}{2} + 1$。对于询问的位置 $x$，判断 $\sqrt{x\times2}$ 与相邻整数的乘积是否等于 $x\times2$。

3. **作者：素质玩家孙 1 超（4 星）**
    - **关键亮点**：详细解释了数学推导过程，使用读入优化提高效率。
    - **个人心得**：一开始看数据挺大的，用了读入优化。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int R()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
int main()
{
    int n,m;
    n=R();
    while(n--)
    {
        m=R();
        m--;
        m+=m;
        double p=sqrt(1+4*m);
        if(p==(int)p) printf("1\n");
        else printf("0\n");
    }
}
```
    - **核心实现思想**：得出第 $i$ 个 1 的位置 $X$ 满足 $X - 1 = \frac{n(n - 1)}{2}$，将询问位置 $m$ 处理后得到 $M = 2(m - 1)$，判断 $\sqrt{4M + 1}$ 是否为整数。

### 最优关键思路或技巧
- **数学推导**：通过找规律得出序列中 1 出现位置的通项公式，将问题转化为判断方程有无正整数解，时间复杂度可优化到 $O(1)$。
- **二分查找**：对于暴力枚举记录 1 位置的方法，使用二分查找可将查找时间复杂度从 $O(n)$ 降低到 $O(log n)$。
- **读入优化**：在处理大量数据时，使用读入优化（如 `inline int R()`）可提高程序效率。

### 拓展思路
同类型题可能会给出不同规律的序列，要求找出指定位置的元素，解题关键在于找出序列的通项公式或规律。类似算法套路可先观察序列特征，尝试用数学方法推导通项公式，若数据范围较小也可使用暴力枚举。

### 推荐题目
1. **P1009 [NOIP1998 普及组] 阶乘之和**：考察数学推导和高精度计算。
2. **P1035 [NOIP2002 普及组] 级数求和**：需要找出级数的规律并进行计算。
3. **P1217 [USACO1.5] 回文质数 Prime Palindromes**：结合数学判断和回文数的规律。

### 个人心得总结
- **聪明的猪**：本题数据过大，不能用数组存储数列，可使用 `bitset`；输入输出不能用 `cin` 和 `cout`，否则会超时；`printf` 不能直接输出 `bitset`，要用 `int(N)` 进行强制类型转换。
- **素质玩家孙 1 超**：一开始看数据挺大的，用了读入优化。
- **maozi**：使用 `map` 存储 1 的下标，查询时最后一个点超时，后续考虑用二分查找优化。
- **revenger**：一开始用 `cin` 进行输入，最后一个点 TLE，换成 `scanf` 后解决。
- **YYY 不吃药**：本来用朴素的数列找规律，后三个点超时，开根号优化后解决。 

---
处理用时：38.10秒
# 题目信息

# 榨取kkksc03

## 题目描述

洛谷 2 的团队功能是其他任何 OJ 和工具难以达到的。借助洛谷强大的服务器资源，任何学校都可以在洛谷上零成本的搭建 OJ 并高效率的完成训练计划。

为什么说是搭建 OJ 呢？为什么高效呢？

![](https://cdn.luogu.com.cn/upload/pic/1236.png)

因为，你可以上传私有题目，团队外别人是无法看到的。我们还能帮你们评测！

你可以创建作业，给组员布置任务，查看组员的完成情况，还可以点评任意一份代码！

你可以创建比赛！既可以是 OI 赛制还可以是 ICPC 赛制！既可以是团队内部的私有比赛，也可以公开赛，甚至可以指定谁可以参加比赛。这样，搞“x 校联赛”最合适不过了。洛谷凭借这个功能，希望能够提供公开及私有比赛的另外一个平台。

![](https://cdn.luogu.com.cn/upload/pic/1237.png)

值得说明的是，本次比赛就是采用团队私有题目+邀请比赛的机制。

洛谷的运营组决定，如果一名 OIer 向他的教练推荐洛谷，并能够成功的使用（成功使用的定义是：该团队有 $20$ 个或以上的成员，上传 $10$ 道以上的私有题目，布置过一次作业并成功举办过一次公开比赛），那么他可以浪费掉 kkksc03 的一些时间的同时消耗掉 kkksc03 的一些金钱以满足自己的一个愿望。

kkksc03 的时间和金钱是有限的，所以他很难满足所有同学的愿望。所以他想知道在自己的能力范围内，最多可以完成多少同学的愿望？

## 样例 #1

### 输入

```
6 10 10
1 1
2 3 
3 2
2 5
5 2
4 3```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
本题是典型的二维费用 01 背包问题，解题关键在于在时间和金钱两个维度的限制下，选择最多的愿望来实现。各题解主要围绕动态规划（DP）和记忆化搜索两种方法展开。

DP 方法中，多数题解使用二维或三维数组记录状态，通过三重循环进行状态转移，状态转移方程为 `f[j][k] = max(f[j][k], f[j - m[i]][k - t[i]] + 1)` 或类似形式，其中 `f[j][k]` 表示花费 `j` 元、`k` 时间能实现的最大愿望数。记忆化搜索则通过递归函数，结合记忆数组避免重复计算。

### 所选题解
- **早右昕（5 星）**
    - **关键亮点**：思路简洁清晰，直接点明本题本质为简单的二维 01 背包问题，代码简洁，可读性高，对有 01 背包基础的读者容易理解。
    - **核心代码**
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,M,T,dp[1010][1010];
int m[1010],t[1010];
int main()
{
    scanf("%d%d%d",&n,&M,&T);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&m[i],&t[i]);
        for(int j=M;j>=m[i];j--)
        for(int k=T;k>=t[i];k--)
        {
            dp[j][k]=max(dp[j][k],dp[j-m[i]][k-t[i]]+1);
        }
    }
    printf("%d\n",dp[M][T]);
}
```
    - **核心思想**：通过三重循环，外层循环遍历每个愿望，内层两个循环分别从总金钱和总时间开始递减，更新 `dp[j][k]` 的值，取不选当前愿望和选当前愿望两种情况的最大值。

- **llzzxx712（4 星）**
    - **关键亮点**：详细讲解了 01 背包问题的一维和二维实现，从基础逐步引导到本题的二维背包，适合初学者理解。
    - **核心代码（二维背包部分）**
```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
using namespace std;
int t1[202],m1[202],f[202][202];
int main()
{
    int n,m,t;
    cin>>n>>m>>t;
    for(int i=1;i<=n;i++){
    	cin>>m1[i]>>t1[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=m;j>=m1[i];j--){
			for(int k=t;k>=t1[i];k--){
				f[j][k]=max(f[j][k],f[j-m1[i]][k-t1[i]]+1);
			}
		}
	}
	cout<<f[m][t];
	return 0;
}
```
    - **核心思想**：与早右昕的题解类似，通过三重循环进行状态转移，更新 `f[j][k]` 的值。

- **帅到报警（4 星）**
    - **关键亮点**：对题意进行了清晰分析，明确指出本题是二维 01 背包问题，并给出了核心代码和完整正解，代码中使用了快读和自定义 `Max` 函数，有一定的代码优化。
    - **核心代码**
```cpp
for(int i = 1; i <= n; i++)
	for(int j = mon; j >= m[i]; j--)
		for(int k = tim; k >= t[i]; k--)
			f[j][k] = Max(f[j][k], f[j - m[i]][k - t[i]] + 1);
```
    - **核心思想**：同样是通过三重循环进行状态转移，更新 `f[j][k]` 的值，取两种情况的最大值。

### 最优关键思路或技巧
- **状态定义**：使用二维数组 `f[j][k]` 表示花费 `j` 元、`k` 时间能实现的最大愿望数，简洁明了。
- **状态转移方程**：`f[j][k] = max(f[j][k], f[j - m[i]][k - t[i]] + 1)` 是解决本题的关键，通过比较选和不选当前愿望的情况，更新最大愿望数。
- **滚动数组优化**：部分题解提到可以使用滚动数组将三维数组优化为二维数组，节省空间。

### 拓展思路
同类型题可考虑增加更多维度的费用限制，如增加人力、物力等维度，或者改变物品的价值计算方式，如物品价值与选择的顺序有关等。

### 推荐题目
1. **P1048 采药**：经典的 01 背包问题，只有一个费用维度（时间）。
2. **P1507 NASA的食物计划**：二维费用 01 背包问题，与本题类似。
3. **P2925 [USACO08DEC]Hay For Sale S**：一维费用 01 背包问题，可作为基础练习。

### 个人心得摘录与总结
- **yybyyb**：使用三维数组时，一开始只得了 60 分，经过思考发现状态转移时要注意不能选的情况要直接转移过来，避免越界问题。总结：在使用多维数组进行状态转移时，要仔细考虑边界条件和状态转移的正确性。
- **exit0**：认为本题适合记忆化搜索练手，完成本题后可尝试其他相关题目。总结：通过练习不同类型的题目，加深对记忆化搜索和动态规划的理解。

---
处理用时：31.72秒
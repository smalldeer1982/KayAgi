# 题目信息

# [HAOI2012] 音量调节

## 题目描述

一个吉他手准备参加一场演出。他不喜欢在演出时始终使用同一个音量，所以他决定每一首歌之前他都需要改变一次音量。在演出开始之前，他已经做好一个列表，里面写着每首歌开始之前他想要改变的音量是多少。每一次改变音量，他可以选择调高也可以调低。

音量用一个整数描述。输入文件中整数 $beginLevel$，代表吉他刚开始的音量，整数 $maxLevel$，代表吉他的最大音量。音量不能小于 $0$ 也不能大于 $maxLevel$。输入中还给定了 $n$ 个整数 $c_1,c_2,c_3,\cdots,c_n$，表示在第 $i$ 首歌开始之前吉他手想要改变的音量是多少。

吉他手想以最大的音量演奏最后一首歌，你的任务是找到这个最大音量是多少。

## 说明/提示

$1\le n\le 50$，$1\le c_i\le beginLevel$，$1\le maxLevel\le 1000$，$0\le beginLevel\le maxLevel$。

## 样例 #1

### 输入

```
3 5 10
5 3 7
```

### 输出

```
10```

# AI分析结果

### 综合分析与结论
这些题解主要围绕“音量调节”问题展开，大部分采用动态规划（DP）思路，也有使用BFS、记忆化搜索、bitset等方法。

**思路对比**：
- **动态规划**：多数题解将其看作到达性的01背包问题，定义二维数组`f[i][j]`表示前`i`首歌曲能否达到音量`j`，通过状态转移方程更新状态，最后倒序查找最大可达到的音量。
- **BFS**：使用队列存储状态，不断扩展状态，但会有重复状态，可通过bool数组去重。
- **记忆化搜索**：递归搜索所有可能状态，用数组记录已搜索结果避免重复计算。
- **bitset**：利用位运算模拟音量的增减，简洁高效。

**算法要点**：
- 动态规划：状态定义、状态转移方程、边界条件和结果查找。
- BFS：队列的使用和状态去重。
- 记忆化搜索：递归函数和记忆数组。
- bitset：位运算的运用。

**解决难点**：
- 动态规划：合理定义状态和转移方程，处理音量范围约束。
- BFS：避免重复状态导致的超时。
- 记忆化搜索：正确处理递归边界。
- bitset：理解位运算模拟音量变化。

### 高评分题解
1. **作者：jackyzhu（5星）**
    - **关键亮点**：思路清晰，将问题准确归结为到达型的01背包问题，代码简洁易懂，注释完善。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++)
    for(int j=maxlevel;j>=0;j--)
    {
        if(j-a[i]>=0)
            f[i][j]=f[i][j]||f[i-1][j-a[i]];
        if(j+a[i]<=maxlevel)
            f[i][j]=f[i][j]||f[i-1][j+a[i]];
    }
```
    核心思想是通过两层循环遍历歌曲和音量，根据当前音量的增减情况更新状态。

2. **作者：Sleepy_Piggy（4星）**
    - **关键亮点**：二维DP思路明确，代码结构清晰，对状态转移的判断条件解释详细。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    for(int j=0;j<=maxn;j++){
        if(f[i-1][j]&&j+a[i]<=maxn) f[i][j+a[i]]=1;
        if(f[i-1][j]&&j-a[i]>=0) f[i][j-a[i]]=1;
    }
}
```
    核心思想是根据前一首歌的状态，判断当前音量增减后是否满足条件，更新当前状态。

3. **作者：Kaizyn（4星）**
    - **关键亮点**：使用bitset和位运算解决问题，代码简洁高效，提供注释代码和简洁代码两种版本。
    - **核心代码**：
```cpp
for(int i = 0, tmp; i < n; ++i)
{
    scanf("%d", &tmp);
    b = (b << tmp) | (b >> tmp);
    b &= cut;
}
```
    核心思想是通过位运算模拟音量的增减，用`&`运算确保音量在合法范围内。

### 最优关键思路或技巧
- **动态规划**：将问题转化为到达性的01背包问题，通过二维数组记录状态，避免重复计算。
- **bitset**：利用位运算模拟音量的增减，减少空间复杂度，提高代码效率。
- **状态去重**：在BFS中使用bool数组避免重复状态，减少时间复杂度。

### 拓展思路
同类型题或类似算法套路：
- 砝码称重问题：判断能否用给定砝码称出特定重量，可使用类似的到达性DP思路。
- 硬币组合问题：用不同面值的硬币组合出特定金额，同样可以用DP解决。

### 推荐题目
- P1049 装箱问题：经典的01背包问题，与本题的DP思路相似。
- P2347 砝码称重：判断能否用给定砝码称出特定重量，和本题有一定关联。
- P1164 小A点菜：选择菜品组合达到特定金额，也是01背包的变形。

### 个人心得摘录与总结
- **作者：HighPerformanceRobot**：一开始用搜索和BFS暴力求解超时和超内存，后来发现BFS中存在大量重复状态，通过开bool数组去重后AC。总结是在使用搜索算法时要注意状态去重，避免不必要的计算。 

---
处理用时：26.27秒
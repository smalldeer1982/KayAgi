# 题目信息

# 山峰暸望

## 题目描述

一天，Bessie 在眺望美丽的威斯康星的群山的时候，她突然产生了疑问：哪座山是最宽的？

她决定在地平线上，利用她的新式大量程山峰高度测量仪依次做 $N$（$1 \le N \le 10,000$）次高度测量，每次的高度值为 $H_i$（$1 \le H_i \le 1,000,000,000$）。

一座山定义为一段连续的高度序列，序列中的高度一开始单调上升（或者不变），然后单调下降（或者不变）。举例来说，$2, 3, 3, 5, 4, 4, 1$ 这一段高度序列就是一座山。如果在她的视线范围内有一段单调上升或者单调下降的序列，也算是一座山。注意，两座山之间可能会有部分重叠。

山的宽度定义为在这个山上进行的测量的次数（也就是序列的长度）。例如序列 $2, 3, 3, 5, 4, 4, 1$ 的宽度为 $7$。

请帮 Bessie 找到最宽的山。

下图是一个比较典型的的例子：

```plain
           *******                   *                                
          *********                  ***                               
          **********                *****                              
          ***********            *********               *             
*      *****************       ***********             *** *          
**    *******************     *************   * *     *******      *  
**********************************************************************  山的形状
3211112333677777776543332111112344456765432111212111112343232111111211  高度值
aaaaa                    ccccccccccccccccccccc eeeeeee ggggggggg
  bbbbbbbbbbbbbbbbbbbbbbbbbbbb             ddddd          ffffffffff  
                                                             hhhhhhhhh  山的编号
```

山标记为 `a`、`b` 等等。显然，山 `b` 有着最大的宽度，宽度为 $28$。


## 说明/提示

**【样例说明】**

在最宽的山处测量到的高度为 $2, 3, 5, 4, 1$。其他的山包括 $3, 2$ 和 $1, 6$。

---

**【提示】**

如果你知道一座山的最高的部分（也就是山峰），你会发现，找到这座山的宽度是很容易的哦。

## 样例 #1

### 输入

```
7
3
2
3
5
4
1
6
```

### 输出

```
5
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕找出最宽山峰的宽度展开，思路大致分为两类：一是枚举每个点作为山峰，向两边扩展找出山的宽度；二是使用动态规划预处理每个点左右单调区间的长度。

枚举法思路简单直接，实现容易，但时间复杂度为 $O(n^2)$；动态规划法时间复杂度为 $O(n)$，效率更高，但需要额外的空间存储状态。

### 所选题解
- **作者：万弘（5星）**
    - **关键亮点**：使用动态规划将时间复杂度优化到 $O(n)$，思路清晰，代码规范，状态转移方程明确。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
typedef long long ll;
ll fup[100001],fdown[100001];
ll n;
ll h[100001];
int main()
{
    scanf("%lld",&n);
    for(ll i=1;i<=n;++i)
    {
        scanf("%lld",&h[i]);
    }
    fup[1]=1;
    for(ll i=2;i<=n;++i)
    {
        if(h[i]>=h[i-1])fup[i]=fup[i-1]+1;
        else fup[i]=1;
    }
    fdown[n]=1;
    for(ll i=n-1;i>=1;--i)
    {
        if(h[i]>=h[i+1])fdown[i]=fdown[i+1]+1;
        else fdown[i]=1;
    }
    ll ans=0;
    for(ll i=1;i<=n;++i)
    {
        if(fup[i]+fdown[i]-1>ans)ans=fup[i]+fdown[i]-1;
    }
    printf("%lld",ans);
    return 0;
} 
```
    - **核心思想**：定义 `fup[i]` 为以 `i` 结尾的单调递增的长度，`fdown[i]` 为以 `i` 开始的单调递减的长度，通过状态转移方程分别计算这两个数组，最后枚举每个点，用 `fup[i]+fdown[i]-1` 更新答案。

- **作者：AFOier（4星）**
    - **关键亮点**：思路简洁明了，代码短小精悍，直接按照提示枚举每个点作为山峰扩展宽度，容易理解。
    - **核心代码**：
```cpp
#include <iostream>
using namespace std;
int n,ans,l,r;
long long a[10001];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    cin>>a[i];
    for(int i=1;i<=n;i++)
    {
        l=i;r=i;
        while(a[l-1]<=a[l]&&l>1)l--;
        while(a[r+1]<=a[r]&&r<n)r++;
        ans=max(ans,r-l+1);
    }
    cout<<ans<<endl;
}
```
    - **核心思想**：枚举每个点作为山峰，分别向左和向右扩展，找到以该点为山峰的山的左右边界，计算宽度并更新答案。

### 最优关键思路或技巧
- 动态规划：通过预处理每个点左右单调区间的长度，将时间复杂度从 $O(n^2)$ 优化到 $O(n)$。
- 枚举山峰：以每个点作为山峰向两边扩展，思路简单直接，容易实现。

### 可拓展之处
同类型题如寻找最长的单调子序列、最大的连续子数组和等，都可以使用枚举或动态规划的思路解决。

### 推荐题目
- P1020 导弹拦截：涉及最长不上升子序列和最长上升子序列的求解。
- P1216 数字三角形：经典的动态规划入门题。
- P1616 疯狂的采药：完全背包问题，需要使用动态规划优化。

### 个人心得摘录与总结
- **作者：zhangzhaoke**：一开始认为纯模拟不行，尝试动规调不出来，最后用模拟却过了，说明在做题时可以多尝试不同方法，不要被固有思维限制。
- **作者：筱羽大人**：在处理相邻两座山的重叠部分时被坑，提醒我们在解题时要考虑各种边界情况和特殊情况。 

---
处理用时：25.32秒
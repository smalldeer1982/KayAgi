# 题目信息

# 防护伞

## 题目描述

据说 $2012$ 的灾难和太阳黑子的爆发有关。于是地球防卫小队决定制造一个特殊防护伞，挡住太阳黑子爆发的区域，减少其对地球的影响。由于太阳相对于地球来说实在是太大了，我们可以把太阳表面看作一个平面，中心定为 $(0,0)$。根据情报，在 $2012$ 年时，太阳表面上会产生 $N$ 个黑子区域，每个黑子视为一个点。特殊防护伞可以看作一个巨大的圆面，现在地球防卫小队决定将它的中心定位于某个黑子，然后用伞面挡住其他黑子。因为制造防护伞的材料成本特别高，所以我们希望伞面尽可能的小。

## 说明/提示

### 数据范围及约定

- 对于 $50\%$ 的数据：$2 \le N \le 100$。
- 对于 $100\%$ 的数据：$2 \le N \le 1000$，$-10000\le x,y\le 10000$。

### 注意

- 精确到小数点后 $4$ 位。
- $\pi$ 取 $3.1415926535$。

## 样例 #1

### 输入

```
3

0  1 

-8  -4 

-1  4 

```

### 输出

```
279.6017```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致，均是枚举每个黑子作为圆心，找出该圆心到其他黑子的最大距离，再在这些最大距离中取最小值作为半径，最后计算最小圆面积。部分题解为避免浮点数运算带来的精度问题和性能损耗，在计算过程中使用距离平方代替距离，仅在输出时转换为浮点数。

### 所选题解
- **梧桐灯（5星）**
    - **关键亮点**：思路清晰，代码简洁高效。全程使用 `int` 型，仅在输出时转换为 `double`，避免了 `sqrt` 和平方运算的重复计算，减少了浮点数运算带来的精度损失和性能开销。
    - **核心代码**：
```cpp
inline int dis(int a, int b, int c, int d) {
    return (a - c) * (a - c) + (b - d) * (b - d);
}
int main() {
    int ans = (1 << 30), n;
    struct stu { int x; int y; } s[1005];
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d %d", &s[i].x, &s[i].y);
    for (int i = 1; i <= n; i++) {
        int now = 0;
        for (int j = 1; j <= n; j++) {
            if (i == j) continue;
            now = max(now, dis(s[i].x, s[i].y, s[j].x, s[j].y));
        }
        ans = min(ans, now);
    }
    printf("%.4lf", (double)ans * PI);
    return 0;
}
```
- **JustinRochester（4星）**
    - **关键亮点**：详细解释了不用开根号的原因，通过读入优化提高了输入效率，在数据读入过程中完成了以每个点为圆心的最大距离平方的预处理，减少了代码的冗余。
    - **核心代码**：
```cpp
inline int read() {
    register int ans = 0; register char c = getchar(); register bool neg = 0;
    while ((c < '0') | (c > '9')) neg ^=!(c ^ '-'), c = getchar();
    while ((c >= '0') & (c <= '9')) ans = (ans << 3) + (ans << 1) + c - '0', c = getchar();
    return neg? -ans : ans;
}
int main() {
    int n = read();
    int x[1000], y[1000], l[1000] = {0};
    x[0] = read(); y[0] = read();
    for (int i = 1; i < n; i++) {
        x[i] = read(); y[i] = read();
        for (int j = 0; j < i; j++) {
            int d = (x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]);
            if (d > l[j]) l[j] = d;
            if (d > l[i]) l[i] = d;
        }
    }
    int r2 = 0x3f3f3f3f;
    for (int i = 0; i < n; i++) if (l[i] < r2) r2 = l[i];
    printf("%.4lf", (double)3.1415926535 * r2);
    return 0;
}
```
- **PTC06（4星）**
    - **关键亮点**：思路阐述详细，代码注释清晰，适合初学者理解。
    - **核心代码**：
```cpp
int main() {
    double ans, dmax, ddistancetem, ddistance, rarea;
    int n, i, j, x[1000], y[1000], normx, normy, abian, bbian;
    cin >> n;
    for (i = 1; i <= n; i++) cin >> x[i] >> y[i];
    for (i = 1; i <= n; i++) {
        normx = x[i]; normy = y[i];
        dmax = 0;
        for (j = 1; j <= n; j++) {
            abian = abs(x[j] - x[i]);
            bbian = abs(y[j] - y[i]);
            ddistancetem = abian * abian + bbian * bbian;
            ddistance = sqrt(ddistancetem);
            if (ddistance > dmax) dmax = ddistance;
        }
        rarea = 3.1415926535 * dmax * dmax;
        if (rarea < ans || i == 1) ans = rarea;
    }
    printf("%.4f", ans);
}
```

### 最优关键思路或技巧
- **避免浮点数运算**：在计算距离和面积时，利用圆面积公式 $S = \pi r^2$ 和勾股定理 $c^2 = a^2 + b^2$，在计算过程中使用距离平方代替距离，仅在输出时转换为浮点数，减少了 `sqrt` 和平方运算的重复计算，避免了浮点数运算带来的精度损失和性能开销。
- **读入优化**：使用 `inline` 函数实现读入优化，提高输入效率。

### 拓展思路
同类型题可拓展到三维空间或更高维度，思路依然是枚举每个点作为圆心，计算到其他点的最大距离，再取最小值。类似算法套路可应用于最小覆盖球、最小覆盖多边形等问题。

### 推荐题目
- P1328 [生活大爆炸版石头剪刀布](https://www.luogu.com.cn/problem/P1328)：枚举双方出拳的所有情况，计算得分。
- P1047 [校门外的树](https://www.luogu.com.cn/problem/P1047)：枚举每个区间，标记被移除的树。
- P1067 [多项式输出](https://www.luogu.com.cn/problem/P1067)：枚举多项式的每一项，根据系数和次数输出相应的格式。

### 个人心得摘录与总结
- **JustinRochester**：使用 `acos(-1)` 计算 $\pi$ 会导致精度问题，直接爆 $0$，应使用题目给定的 $3.1415926535$。
- **七夜**：读题时要注意圆心的位置，本题是以黑子为中心，而不是以 $(0, 0)$ 为中心。同时，求距离时开方可省略，因为后面还要平方，二者可抵消。
- **好记一点的**：使用 `cout` 输出时会遇到精度问题，可使用 `printf` 输出。 

---
处理用时：36.03秒
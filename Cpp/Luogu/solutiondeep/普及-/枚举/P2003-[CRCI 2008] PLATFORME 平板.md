# 题目信息

# [CRCI 2008] PLATFORME 平板

## 题目描述

为了进行一种游戏，现决定搭造一些平板，而各个平板的地址已经选定。基于最普遍的认识，没有任何支持物的平板不可能漂浮在空中。说的更精确些，任意一平板的两端必需有支柱或者它在另一块平板上。

你会得到各个平板在坐标系中的坐标（如左下图）。每一块平板的坐标都是由它的高度（与地板间的垂直距离）和它的水平方位（开始和结束）决定的。每个支柱都距它支撑的平板的边缘半个单位（如图）。

算出支持所有平板的支柱的总长度。

 ![](https://cdn.luogu.com.cn/upload/pic/994.png) 



## 样例 #1

### 输入

```
3

1 5 10

3 1 5

5 3 7

```

### 输出

```
14```

# AI分析结果

### 综合分析与结论
本题题解主要分为暴力枚举和线段树两类思路。暴力枚举法利用两层循环，对每个平板寻找其左右端点下可支撑的最高平板，计算支柱长度，复杂度为$O(n^2)$，实现简单但效率较低；线段树法则先对平板按高度排序，将问题转化为单点查询和区间修改，复杂度为$O(nlogn + nlogh)$，效率更高但实现复杂。

### 高评分题解
1. **作者：mzyy1001（5星）**
    - **关键亮点**：思路清晰，代码简洁，直接用暴力枚举解决问题，适合理解基础算法。
    - **核心代码**：
```cpp
for(int i = 1;i <= n;i++)
{
    int y = a[i].y,x1 = a[i].x1,x2 = a[i].x2;  
    int h1 = 0,h2 = 0;
    for(int j = 1;j <= n;j++)
    {
        if(i == j) 
            continue;
        if(a[j].y >= y) 
            continue;
        if(a[j].x2 > x1 && a[j].x1 <= x1)
            h1 = max(h1,a[j].y);
        if(a[j].x2 >= x2 && a[j].x1 < x2)
            h2 = max(h2,a[j].y);
    }
    ans += y * 2 - h1 - h2;
}
```
    - **核心思想**：两层循环遍历所有平板，为每个平板找到左右端点下可支撑的最高平板高度，计算支柱长度并累加。

2. **作者：Makasukaka（4星）**
    - **关键亮点**：提供了$O(n^2)$和$O(nlogn + nlogh)$两种解法，详细阐述了线段树思路及处理边界问题的方法。
    - **核心代码（线段树部分）**：
```cpp
sort(a+1,a+1+n,cmp);
build(1,1,N);
for(int i = 1;i <= n;++i){
    int l=a[i].x1,r=a[i].x2;
    int d=query(1,l,l+1);
    ans+=(a[i].y-d);
    d=query(1,r-1,r);
    ans+=(a[i].y-d);
    insert(1,l+1,r-1,a[i].y);
}
```
    - **核心思想**：先对平板按高度排序，构建线段树，对每个平板查询左右端点的最大高度，计算支柱长度并累加，然后更新线段树。

3. **作者：hongzy（4星）**
    - **关键亮点**：思路清晰，对判断支撑条件进行了详细说明，代码可读性高。
    - **核心代码**：
```cpp
sort(A+1, A+N+1);
for(int i=1; i<=N; i++) {
    int lcost = -1, rcost = -1;
    for(int j=i-1; j>=0; j--) {
        if(lcost!= -1 && rcost!= -1) break;
        if(A[j].h < A[i].h) {
            if(lcost == -1 && Check(A[j].l, A[j].r, A[i].l, 1)) lcost = A[i].h - A[j].h;
            if(rcost == -1 && Check(A[j].l, A[j].r, A[i].r, 0)) rcost = A[i].h - A[j].h;
        }
    }
    ans += lcost + rcost;
}
```
    - **核心思想**：对平板按高度排序，从低到高处理每个平板，为其左右端点寻找可支撑的平板，计算支柱长度并累加。

### 最优关键思路或技巧
- **排序优化**：按高度对平板排序，可减少不必要的比较，如线段树解法和部分暴力枚举解法。
- **线段树应用**：将问题转化为单点查询和区间修改，利用线段树高效处理，适合数据规模较大的情况。
- **坐标处理**：将坐标乘2处理支柱在边缘0.5处的问题，避免小数运算。

### 拓展思路
同类型题可考虑其他区间查询和修改问题，如区间染色、区间最值查询等，可使用线段树、树状数组等数据结构解决。

### 洛谷相似题目推荐
1. P3372 【模板】线段树 1
2. P1816 忠诚
3. P2068 统计和

### 个人心得摘录与总结
- **作者：重回巅峰！**：因支柱在平板边缘往里0.5距离，将读入数据扩大两倍方便计算；数组不能开小，否则会RE。
- **作者：谬悠**：用不来线段树，采用模拟方法，给左右坐标乘2处理支柱位置问题。
- **作者：rfsfreffr**：原以为实现简单，却被double与int类型问题困扰。 

---
处理用时：28.28秒
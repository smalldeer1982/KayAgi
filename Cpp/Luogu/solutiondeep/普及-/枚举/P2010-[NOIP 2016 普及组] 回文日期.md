# 题目信息

# [NOIP 2016 普及组] 回文日期

## 题目背景

NOIP2016 普及组 T2

## 题目描述

在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。

牛牛习惯用 $8$ 位数字表示一个日期，其中，前 $4$ 位代表年份，接下来 $2$ 位代表月份，最后 $2$ 位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表 示方法不会相同。

牛牛认为，一个日期是回文的，当且仅当表示这个日期的 $8$ 位数字是回文的。现在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存在的日期是回文的。

一个 $8$ 位数字是回文的，当且仅当对于所有的 $i$（$1  \le i \le 8$）从左向右数的第 $i$ 个数字和第 $9-i$ 个数字（即从右向左数的第 $i$ 个数字）是相同的。

例如：

- 对于 2016 年 11 月 19 日，用 $8$ 位数字 $20161119$ 表示，它不是回文的。
- 对于 2010 年 1 月 2 日，用 $8$ 位数字 $20100102$ 表示，它是回文的。
- 对于 2010 年 10 月 2 日，用 $8$ 位数字 $20101002$ 表示，它不是回文的。

每一年中都有 $12$ 个月份：

其中，$1, 3, 5, 7, 8, 10, 12$ 月每个月有 $31$ 天；$4, 6, 9, 11$ 月每个月有 $30$ 天；而对于 $2$ 月，闰年时有 $29$ 天，平年时有 $28$ 天。

一个年份是闰年当且仅当它满足下列两种情况其中的一种：

1. 这个年份是 $4$ 的整数倍，但不是 $100$ 的整数倍；
2. 这个年份是 $400$ 的整数倍。

例如：

- 以下几个年份都是闰年：$2000, 2012, 2016$。
- 以下几个年份是平年：$1900, 2011, 2014$。


## 说明/提示

**【样例说明】**

对于样例 1，符合条件的日期是 $20111102$。

对于样例 2，符合条件的日期是 $20011002$ 和 $20100102$。

**【子任务】**

对于 $60 \%$ 的数据，满足 $\mathit{date}_1 = \mathit{date}_2$。


## 样例 #1

### 输入

```
20110101
20111231
```

### 输出

```
1
```

## 样例 #2

### 输入

```
20000101
20101231
```

### 输出

```
2
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕枚举法解决回文日期计数问题，思路可分为两类：一是枚举月和日构造回文日期判断是否在给定区间；二是枚举年份构造回文日期，判断其合法性及是否在区间内。部分题解利用了回文日期特性简化闰年判断，还有题解使用二分查找优化查找过程。

### 高评分题解
- **作者：「QQ红包」（5星）**
    - **关键亮点**：思路清晰，代码简洁，利用回文日期特性枚举月和日，避免复杂闰年判断，运行效率高。
    - **核心代码**：
```cpp
int s[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
int main()
{
    scanf("%d%d",&n,&m);
    for (i=1;i<=12;i++)
        for (j=1;j<=s[i];j++)
        {
            c=(j%10)*1000+(j/10)*100+(i%10)*10+(i/10);
            sum=c*10000+i*100+j;
            if (sum<n||sum>m) continue;
            ans++;
        }
    printf("%d",ans);
    return 0;
}
```
    - **核心思想**：先定义每月天数数组，通过两层循环枚举月和日，根据月和日构造出回文日期的前四位，进而得到完整日期，判断日期是否在给定区间内，若是则计数加一。

- **作者：cff_0102（4星）**
    - **关键亮点**：先打表存储所有可能的回文日期，再排序后用二分查找，提高查找效率。
    - **核心代码**：
```cpp
int m[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
int a[370],cnt=0;
int main(){
    for(int i=1;i<=12;i++){
        for(int j=1;j<=m[i];j++){
            int x=i*100+j;
            a[++cnt]=x+10000*(x/1000+10*((x/100)%10)+100*((x/10)%10)+1000*(x%10));
        }
    }
    sort(a+1,a+1+366);
    int l,r;cin>>l>>r;
    cout<<upper_bound(a+1,a+1+366,r)-lower_bound(a+1,a+1+366,l);
    return 0;
}
```
    - **核心思想**：先通过两层循环枚举月和日，构造出所有可能的回文日期并存储在数组中，对数组排序后，利用二分查找找出给定区间内的回文日期数量。

### 最优关键思路与技巧
- **枚举月和日构造回文日期**：利用回文日期特性，枚举月和日可快速构造出完整日期，避免枚举年份时复杂的闰年判断。
- **打表与二分查找**：对于固定数量的可能结果，先打表存储再排序，使用二分查找可提高查找效率。

### 拓展思路
同类型题目可考虑其他特殊日期特性，如对称日期、顺子日期等，解题思路仍可采用枚举法，根据不同特性构造日期并判断合法性和区间范围。

### 洛谷相似题目推荐
- P1055 [ISBN 号码](https://www.luogu.com.cn/problem/P1055)：字符串处理与规则判断。
- P1042 [乒乓球](https://www.luogu.com.cn/problem/P1042)：模拟比赛过程，涉及规则判断。
- P1098 [字符串的展开](https://www.luogu.com.cn/problem/P1098)：字符串处理与规则应用。

### 个人心得
题解中未包含个人心得相关内容。 

---
处理用时：23.25秒
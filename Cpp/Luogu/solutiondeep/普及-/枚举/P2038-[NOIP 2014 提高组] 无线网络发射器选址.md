# 题目信息

# [NOIP 2014 提高组] 无线网络发射器选址

## 题目背景

NOIP2014 提高组 D2T1

## 题目描述

随着智能手机的日益普及，人们对无线网的需求日益增大。某城市决定对城市内的公共场所覆盖无线网。

假设该城市的布局为由严格平行的 $129$ 条东西向街道和 $129$ 条南北向街道所形成的网格状，并且相邻的平行街道之间的距离都是恒定值 $1$。东西向街道从北到南依次编号为 $0,1,2 \dots 128$，南北向街道从西到东依次编号为 $0,1,2 \dots 128$。

东西向街道和南北向街道相交形成路口，规定编号为 $x$ 的南北向街道和编号为 $y$ 的东西向街道形成的路口的坐标是 $(x, y)$。在某些路口存在一定数量的公共场所。

由于政府财政问题，只能安装一个大型无线网络发射器。该无线网络发射器的传播范围是一个以该点为中心，边长为 $2d$ 的正方形。传播范围包括正方形边界。

现在政府有关部门准备安装一个传播参数为 $d$ 的无线网络发射器，希望你帮助他们在城市内找出合适的路口作为安装地点，使得覆盖的公共场所最多。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq d \leq 20, 1 \leq n \leq 20, 0 \leq x \leq 128, 0 \leq y \leq 128, 0 < k \leq 10^6$。

## 样例 #1

### 输入

```
1
2
4 4 10
6 6 20```

### 输出

```
1 30```

# AI分析结果

### 综合分析与结论
本题数据规模较小，各题解主要围绕暴力枚举和优化求和展开。暴力枚举思路简单直接，适合初学者，但时间复杂度较高；而采用二维前缀和、二维树状数组、倍增等方法可优化求和过程，降低时间复杂度。各题解的主要区别在于数据处理方式和求和算法的选择，其中边界处理是共同的难点。

### 高评分题解
- **作者：decoqwq（5星）**
    - **关键亮点**：提供多种解题思路，详细介绍二维前缀和、二维树状数组和倍增算法，对不同算法的复杂度分析清晰，代码实现规范。
    - **核心代码**：
```cpp
// 二维树状数组添加操作
#define lowbit(x) (x&(-x))
void add(int x,int y,int k)
{
    for(int i=x;i<=129;i+=lowbit(i))
    {
        for(int j=y;j<=129;j+=lowbit(j))
        {
            c[i][j]+=k;
        }
    }
}
// 二维树状数组查询操作
int query(int x,int y)
{
    int ans=0;
    for(int i=x;i>=1;i-=lowbit(i))
    {
        for(int j=y;j>=1;j-=lowbit(j))
        {
            ans+=c[i][j];
        }
    }
    return ans;
}
```
    - **核心思想**：利用二维树状数组维护前缀和，通过 `add` 函数更新数组，`query` 函数查询区间和，最后遍历所有可能的安装点，计算覆盖的公共场所数量。

- **作者：JayYee（4星）**
    - **关键亮点**：详细阐述暴力枚举思路，指出边界处理的坑点，并给出错误和正确代码对比，有助于理解边界处理的重要性。
    - **核心代码**：
```cpp
void solve(int x,int y){
    int lx,rx,uy,dy,sum(0);
    lx=x-d;rx=x+d;uy=y+d;dy=y-d;
    if(lx<0) lx=0;
    if(rx>128) rx=128;
    if(uy>128) uy=128;
    if(dy<0) dy=0;
    for(int i=lx;i<=rx;i++)
    for(int j=dy;j<=uy;j++){
        sum+=a[i][j];
    }
    if(sum== ans) fangan++;
    if(sum>ans){
        ans=sum;
        fangan=1;
    }
}
```
    - **核心思想**：遍历每个可能的安装点，计算其覆盖范围，通过边界处理避免数组越界，累加覆盖范围内的公共场所数量，更新最大值和方案数。

- **作者：qhr2023（4星）**
    - **关键亮点**：代码简洁，思路清晰，直接采用暴力枚举，通过 `max` 和 `min` 函数处理边界，易于理解和实现。
    - **核心代码**：
```cpp
for (int x=0; x<=128; ++x) 
    for (int y=0; y<=128; ++y) {
        int sum=0;
        for (int j=max(0, x-d); j<=min(128, x+d); ++j)
            for (int l=max(0, y-d); l<=min(128, y+d); ++l)
                sum+=a[j][l];
        if (sum>mx)
            mx=sum,
            cnt=1;
        else if (sum==mx)
            cnt++;
    }
```
    - **核心思想**：枚举每个安装点，计算其覆盖范围内的公共场所数量，通过 `max` 和 `min` 函数确保不越界，更新最大值和方案数。

### 最优关键思路或技巧
- **数据结构**：可使用二维前缀和、二维树状数组等数据结构优化求和过程。
- **算法优化**：采用倍增算法快速获得区间答案。
- **思维方式**：在暴力枚举时，注意边界处理，避免数组越界。
- **代码实现技巧**：使用 `max` 和 `min` 函数处理边界，简化代码。

### 拓展思路
同类型题可考虑更大数据规模下的优化，如使用更高效的数据结构或算法。类似算法套路包括二维前缀和、二维树状数组在矩阵求和问题中的应用，以及暴力枚举结合边界处理解决问题。

### 推荐题目
- P1387 最大正方形
- P2280 [HNOI2003]激光炸弹
- P3397 地毯

### 个人心得摘录与总结
- **JayYee**：在处理边界时，不能简单地直接越界返回，要考虑部分覆盖的情况，否则会导致结果错误。总结为边界处理需谨慎，要全面考虑各种情况。 

---
处理用时：27.57秒
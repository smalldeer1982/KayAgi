# 题目信息

# 烤鸡

## 题目背景

猪猪 Hanke 得到了一只鸡。


## 题目描述

猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 $10$ 种配料（芥末、孜然等），每种配料可以放 $1$ 到 $3$ 克，任意烤鸡的美味程度为所有配料质量之和。

现在， Hanke 想要知道，如果给你一个美味程度 $n$ ，请输出这 $10$ 种配料的所有搭配方案。

## 说明/提示

对于 $100\%$ 的数据，$n \leq 5000$。

## 样例 #1

### 输入

```
11```

### 输出

```
10
1 1 1 1 1 1 1 1 1 2 
1 1 1 1 1 1 1 1 2 1 
1 1 1 1 1 1 1 2 1 1 
1 1 1 1 1 1 2 1 1 1 
1 1 1 1 1 2 1 1 1 1 
1 1 1 1 2 1 1 1 1 1 
1 1 1 2 1 1 1 1 1 1 
1 1 2 1 1 1 1 1 1 1 
1 2 1 1 1 1 1 1 1 1 
2 1 1 1 1 1 1 1 1 1 ```

# AI分析结果

### 综合分析与结论
这些题解主要围绕枚举和搜索两种思路解决烤鸡配料搭配方案问题。枚举法通过多重循环遍历所有可能的配料组合，简单直接但代码冗长；搜索法（如深度优先搜索）则借助递归探索所有情况，代码更简洁且可通过剪枝优化。难点在于先输出方案数，需存储所有方案，不同题解采用了数组、字符串、队列等不同存储方式。

### 高评分题解
- **作者：yyy2015c01（5星）**
    - **关键亮点**：思路清晰，使用简单的多重循环枚举所有可能，代码可读性高，适合初学者理解。
    - **核心代码**：
```cpp
for (a=1;a<=3;a++) {
    for (b=1;b<=3;b++) {
        // 嵌套循环省略
        for (j=1;j<=3;j++) {
            if (a+b+c+d+e+f+g+h+i+j==in) {
                x++;
            }
        }
    }
}
cout<<x<<endl;
for (a=1;a<=3;a++) {
    for (b=1;b<=3;b++) {
        // 嵌套循环省略
        for (j=1;j<=3;j++) {
            if (a+b+c+d+e+f+g+h+i+j==in) {
                cout<<a<<" ";
                cout<<b<<" ";
                // 输出省略
                cout<<j<<endl;
            }
        }
    }
}
```
    - **核心思想**：通过十重循环遍历每种配料1 - 3克的所有组合，先统计满足美味程度的方案数，再输出具体方案。

- **作者：万枪先生（4星）**
    - **关键亮点**：使用递归实现深度优先搜索，代码简洁，通过剪枝优化搜索过程，避免不必要的计算。
    - **核心代码**：
```cpp
void peiliao(int total,int a){
    if (a==10){
        if (total==n) {
            for (int j=0;j<10;j++) m1[kind][j]=m2[j];
            kind++;
        }
    }
    else if (total>=n) ;
    else
      for (int i=1;i<=3;i++){
          m2[a]=i;
          peiliao(total+i,a+1);
      }
}
```
    - **核心思想**：递归函数`peiliao`模拟添加配料的过程，当添加完10种配料且美味程度等于目标值时，记录方案；若当前美味程度已超过目标值则停止搜索。

- **作者：氢氧化铯CsOH（4星）**
    - **关键亮点**：详细介绍了多种存储方案的方法，包括使用`sprintf`函数、`stringstream`、指针和`%n`控制符，对存储优化进行了深入探讨。
    - **核心代码**：
```cpp
void printans(){
    int offset;
    for(int i = 0; i < 10; i++){
        sprintf(anscur, "%d %n", nums[i], &offset);
        anscur += offset;
    }
    sprintf(anscur, "\n%n", &offset);
    anscur += offset;
}
```
    - **核心思想**：`printans`函数使用`sprintf`的`%n`控制符记录输出字符数，直接更新指针位置，高效存储方案。

### 最优关键思路或技巧
- **剪枝优化**：在搜索过程中，若当前美味程度已超过目标值或剩余配料即使都取最大值也无法达到目标值，可提前终止搜索，减少不必要的计算。
- **存储优化**：使用指针和`%n`控制符可避免多次调用`strlen`函数，提高存储方案的效率。

### 拓展思路
同类型题可拓展到更多种类配料、更大取值范围的情况，算法套路主要是枚举和搜索，可根据具体问题选择合适的剪枝策略和存储方式。

### 推荐题目
- [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)：考察广度优先搜索。
- [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)：深度优先搜索经典题目。
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：涉及组合枚举和深度优先搜索。

### 个人心得摘录与总结
- **作者：氢氧化铯CsOH**：使用`stringstream`出现RE错误，提醒在选择存储方式时要考虑效率和稳定性。
- **作者：HoshinoTented**：在Haskell题解中因将`need - x`写成`need - 1`而被困，强调编码时要仔细，避免小错误。 

---
处理用时：32.08秒
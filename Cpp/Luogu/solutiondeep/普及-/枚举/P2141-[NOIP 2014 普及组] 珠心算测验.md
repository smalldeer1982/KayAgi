# 题目信息

# [NOIP 2014 普及组] 珠心算测验

## 题目背景

NOIP2014 普及 T1

## 题目描述

珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。


某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？


最近老师出了一些测验题，请你帮忙求出答案。


## 说明/提示

【样例说明】


由 $1+2=3,1+3=4$，故满足测试要求的答案为 $2$。  

注意，加数和被加数必须是集合中的两个不同的数。


【数据说明】


对于 $100\%$ 的数据，$3 \leq n \leq 100$，测验题给出的正整数大小不超过 $10,000$。


## 样例 #1

### 输入

```
4
1 2 3 4```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何找出集合中恰好等于另外两个不同数之和的数的个数展开，可分为暴力枚举和优化算法两类。暴力枚举通过三重循环直接判断，时间复杂度为 $O(n^3)$；优化算法采用桶标记、`set` 集合、二分查找等方式，将时间复杂度优化到 $O(n^2)$ 或 $O(n^2 \log n)$。

### 高评分题解
- **作者：OIerWu_829（5星）**
    - **关键亮点**：思路清晰，代码简洁易读。使用桶标记元素，双重循环遍历并判断和是否存在，同时避免重复计数。
    - **核心代码**：
```cpp
const int N = 105, M = 2e4 + 5;
int a[N];
bool f[M];
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        f[a[i]] = true;
    }
    int ans = 0;
    for (int i = 1; i <= n; i++)
        for (int j = i + 1; j <= n; j++)
            if (f[a[i] + a[j]])
            {
                ans++;
                f[a[i] + a[j]] = false;
            }
    cout << ans;
    return 0;
}
```
    - **核心思想**：先将输入的元素用桶标记，再双重循环遍历元素对，若它们的和在桶中被标记过，则答案加一，并取消该标记。

- **作者：heidoudou（4星）**
    - **关键亮点**：换角度思考，先定位第三个数，再用双指针找两数之和等于该数，无需额外数组。
    - **核心代码**：
```cpp
int a[101];
int main()
{
    int n, i;
    cin >> n;
    for (i = 0; i < n; i++)
        cin >> a[i];
    sort(a, a + n);
    int count = 0;
    int l, r;
    for (i = n - 1; i >= 2; --i)
    {
        l = 0, r = i - 1;
        while (l < r)
        {
            if (a[l] + a[r] < a[i])
                ++l;
            else if (a[l] + a[r] > a[i])
                --r;
            else
            {
                count++;
                break;
            }
        }
    }
    cout << count;
}
```
    - **核心思想**：对数组排序后，从后往前遍历第三个数，使用双指针在其前面的元素中找两数之和等于该数，找到则答案加一。

- **作者：ikunTLE（4星）**
    - **关键亮点**：思路与 OIerWu_829 类似，代码规范，注释详细。
    - **核心代码**：
```cpp
const int N=1e2+10,M=2e4+10;
int a[N];
bool flag[M];
int main(){
    int n=read();
    for(int i=1;i<=n;++i){
        a[i]=read();
        flag[a[i]]=true;
    }
    int cnt=0;
    for(int i=1;i<n;++i)
        for(int j=i+1;j<=n;++j)
            if(flag[a[i]+a[j]])
                ++cnt,flag[a[i]+a[j]]=false;
    printf("%d\n",cnt);
    return 0;
}
```
    - **核心思想**：用桶标记元素，双重循环遍历元素对，若和在桶中被标记过，则答案加一，并取消该标记。

### 最优关键思路或技巧
- **桶标记**：利用桶数组标记元素是否出现，可快速判断两数之和是否在集合中，避免重复计算。
- **双指针**：对数组排序后，使用双指针在 $O(n)$ 时间内查找两数之和等于目标值。

### 拓展思路
同类型题可考虑元素范围变化、元素可重复、多个集合等情况，类似算法套路有哈希表、排序 + 双指针等。

### 推荐题目
- [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)
- [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)
- [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

### 个人心得摘录与总结
- **作者：heidoudou**：一开始把问题想复杂，以为是两个数之和等于另两个数之和，提醒做题要仔细读题。

---
处理用时：31.57秒
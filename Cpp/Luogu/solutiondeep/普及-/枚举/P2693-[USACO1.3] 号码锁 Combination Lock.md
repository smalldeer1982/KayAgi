# 题目信息

# [USACO1.3] 号码锁 Combination Lock

## 题目背景

感谢 @[Fond_Dream](https://www.luogu.com.cn/user/321680) 提供五道 USACO 题目的标准题面。

## 题目描述

农夫约翰的奶牛不停地从他的农场中逃出来，导致了很多损害。为了防止它们再逃出来，他买了一只很大的号码锁以防止奶牛们打开牧场的门。

农夫约翰知道他的奶牛很聪明，所以他希望确保它们不会在简单地试了很多不同的号码组合之后就能轻易开锁。锁上有三个转盘，每个上面有数字 $1$ ~ $n$，因为转盘是圆的，所以 $1$ 和 $n$ 是相邻的。有两种能开锁的号码组合，一种是农夫约翰设定的，还有一种“预设”号码组合是锁匠设定的。但是，锁有一定的容错性，所以，在每个转盘上的数字都与一个合法的号码组合中相应的数字相距两个位置以内时，锁也会打开。

比如说，如果农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $4$ , $5$ , $6$ )，在转盘被设定为 ( $1$ , $4$ , $5$)（因为这和农夫约翰的号码组合足够接近）或 ( $2$ , $4$ , $8$ )（因为这和预设号码组合足够接近）时可以打开锁。注意，( $1$ , $5$ , $6$ )并不会打开锁，因为它与任一号码组合都不够接近。

给出农夫约翰的号码组合和预设号码组合，请计算能够开锁的不同的号码组合的数目。号码是有序的，所以 ( $1$ , $2$ , $3$ ) 与 ( $3$ , $2$ , $1$ ) 不同。


## 说明/提示

#### 输入输出样例 1 解释

每个转盘的标号是 $1$ ~ $50$。农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $5$ , $6$ , $7$ )。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 100$，$1 \leq x, y, z, a, b, c \leq n$。

## 样例 #1

### 输入

```
50
1 2 3
5 6 7
```

### 输出

```
249```

# AI分析结果

### 综合分析与结论
这些题解主要分为暴力枚举和数学计算两种思路。暴力枚举法通过三重循环遍历所有可能的组合，判断是否满足开锁条件，思路直接但时间复杂度较高；数学计算法则先算出无重复时的总方法数，再减去重复部分，复杂度较低。各题解在处理环形结构（1 和 n 相邻）和去重方面有不同技巧。

### 所选题解
- **作者：小白一枚（5星）**
    - **关键亮点**：思路清晰，使用三维布尔数组去重，代码简洁易懂。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a, b, c, d, e, f, ans;
bool bo[105][105][105];
int main() {
    cin >> n;
    cin >> a >> b >> c;
    cin >> d >> e >> f;
    for (int i=a-2;i<=a+2;++i)
        for (int j=b-2;j<=b+2;++j)
            for (int k=c-2;k<=c+2;++k)
                if (!bo[(i+n)%n][(j+n)%n][(k+n)%n])
                    ans++, bo[(i+n)%n][(j+n)%n][(k+n)%n]=true;
    for (int i=d-2;i<=d+2;++i)
        for (int j=e-2;j<=e+2;++j)
            for (int k=f-2;k<=f+2;++k)
                if (!bo[(i+n)%n][(j+n)%n][(k+n)%n])
                    ans++, bo[(i+n)%n][(j+n)%n][(k+n)%n]=true;
    cout << ans << endl;
}
```
    - **核心思想**：通过三重循环枚举农夫和预设号码组合的所有可能偏移，用布尔数组标记已出现的组合，避免重复计数。

- **作者：VSEJGFB（4星）**
    - **关键亮点**：采用数学方法，先算出无重复的总方法数，再减去重复部分，复杂度低。
    - **核心代码**：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
    int n,a[3],b[3];
    cin>>n;
    for(int i=0;i<3;i++) cin>>a[i];
    for(int i=0;i<3;i++) cin>>b[i];
    if(n<5){ cout<<n*n*n<<endl;return 0;} 
    int ans=1;
    for(int i=0;i<3;i++){
        if(a[i]>b[i]) swap(a[i],b[i]);
        int k=min(b[i]-a[i],a[i]+n-b[i]);
        if(k<5) ans*=(5-k);
        else ans=0;
    }
    cout<<250-ans<<endl;
    return 0;
}
```
    - **核心思想**：先特判 n < 5 的情况，然后计算每个位置上农夫和预设号码组合合法数字的重复数量，根据乘法原理得到总重复数，用 250 减去重复数得到结果。

### 最优关键思路或技巧
- **去重技巧**：使用布尔数组或 `set` 数据结构可以有效避免重复计数。
- **数学方法**：通过分析问题的数学特性，先计算无重复的总数，再减去重复部分，可降低时间复杂度。

### 可拓展之处
同类型题可能涉及更多的组合条件或更高维度的组合，类似算法套路包括枚举法和容斥原理，可根据具体问题选择合适的方法。

### 推荐题目
- [P1008 三连击](https://www.luogu.com.cn/problem/P1008)：考察枚举法和数字组合。
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：涉及组合数的枚举和筛选。
- [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)：需要枚举和质数判断。

### 个人心得
部分题解提到数据规模小可以使用暴力枚举，提醒我们在面对数据范围较小的问题时，可优先考虑简单直接的方法，同时也可思考更优的数学解法。 

---
处理用时：23.83秒
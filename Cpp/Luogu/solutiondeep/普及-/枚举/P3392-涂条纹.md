# 题目信息

# 涂条纹

## 题目描述

只要一个由 $N \times M$ 个小方块组成的旗帜符合如下规则，就是合法的图案。

- 从最上方若干行（至少一行）的格子全部是白色的；
- 接下来若干行（至少一行）的格子全部是蓝色的；
- 剩下的行（至少一行）全部是红色的；

现有一个棋盘状的布，分成了 $N$ 行 $M$ 列的格子，每个格子是白色蓝色红色之一，小 a 希望把这个布改成合法图案，方法是在一些格子上涂颜料，盖住之前的颜色。

小 A 很懒，希望涂最少的格子，使这块布成为一个合法的图案。

## 说明/提示

### 样例解释

目标状态是：

```plain
WWWWW
BBBBB
RRRRR
RRRRR
```
一共需要改 $11$ 个格子。

### 数据范围

对于 $100\%$ 的数据，$N,M \leq 50$。

## 样例 #1

### 输入

```
4 5
WRWRW
BWRWB
WRWRW
RWBWR```

### 输出

```
11```

# AI分析结果

### 综合分析与结论
这些题解主要围绕枚举和动态规划两种思路解决“涂条纹”问题。枚举思路是通过枚举白色与蓝色、蓝色与红色的边界，计算不同划分下所需涂改的格子数，取最小值；动态规划思路则是用数组记录前 $i$ 行最后涂某种颜色的最小代价。

枚举类题解中，部分通过预处理每行涂不同颜色的代价或使用前缀和优化，降低了时间复杂度；动态规划类题解通过状态转移方程递推求解。

### 所选题解
- **「已注销」的题解（5星）**
    - **关键亮点**：思路清晰，使用前缀和优化，时间复杂度为 $O(n^2 + nm)$，代码简洁易读。
    - **核心代码**：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,ans=0x7fffffff,w[51],b[51],r[51];
string s;
inline int check(char c){
    int tot=0;
    for(int i=0;i<m;++i)
        if(s[i]!=c)++tot;
    return tot;    
}
int main(int argc, char const *argv[])
{
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        cin>>s;
        w[i]=w[i-1]+check('W');
        b[i]=b[i-1]+check('B');
        r[i]=r[i-1]+check('R');
    }
    for(int i=1;i<n-1;++i)
        for(int j=i+1;j<n;++j)
            ans=min(ans,w[i]+b[j]-b[i]+r[n]-r[j]);
    cout<<ans;        
    return 0;
}
```
    - **核心思想**：先预处理出把前 $i$ 行涂成白、蓝、红需要涂的格子数，分别存储在 `w[i]`、`b[i]`、`r[i]` 中。然后枚举白色和蓝色的边界 $i$ 和 $j$，计算代价 $w_i + b_j - b_i + r_n - r_j$，取最小值。

- **万弘的题解（5星）**
    - **关键亮点**：详细展示了从暴力枚举到前缀和优化的过程，复杂度逐步降低，最后达到 $O(min(n*m, n^2))$，有助于理解优化思路。
    - **核心代码（前缀和优化版）**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char a[101][101];
int fW,fB,fR,W[101],B[101],R[101];
int n,m,ans=0x7fffffff,sum;
int main(){
    scanf("%d%d\n",&n,&m);
    for(int i=1;i<=n;i++)gets(a[i]);
    for(int i=1;i<=n;i++){
        fW=fB=fR=0;
        for(int j=0;j<m;j++){
            if(a[i][j]!='W')fW++;
            if(a[i][j]!='B')fB++;
            if(a[i][j]!='R')fR++;
        }
        W[i]=W[i-1]+fW;
        B[i]=B[i-1]+fB;
        R[i]=R[i-1]+fR;
    }
    for(int i=2;i<n;i++){
        for(int j=i+1;j<=n;j++){
            sum=W[i-1]-W[0]+B[j-1]-B[i-1]+R[n]-R[j-1];
            if(sum<ans)ans=sum;
        }
    }
    printf("%d",ans);
    return 0;
}
```
    - **核心思想**：先预处理每行涂成白、蓝、红所需的格子数，再用前缀和数组 `W`、`B`、`R` 记录前 $i$ 行的累计代价。枚举白色和蓝色的边界 $i$ 和 $j$，利用前缀和的差分计算代价，取最小值。

### 最优关键思路或技巧
- **预处理**：先计算每行涂成不同颜色所需的格子数，避免在枚举过程中重复计算，降低时间复杂度。
- **前缀和优化**：使用前缀和数组记录前 $i$ 行的累计代价，在枚举边界时通过差分快速计算某一区间的代价。

### 可拓展之处
同类型题可拓展到更多颜色或更多区域的划分问题，解题思路仍可采用枚举边界或动态规划。类似算法套路有区间动态规划、状态压缩动态规划等。

### 推荐题目
- P1048 [采药](https://www.luogu.com.cn/problem/P1048)：考察动态规划的基本应用。
- P1216 [数字三角形](https://www.luogu.com.cn/problem/P1216)：经典的动态规划题目，可加深对状态转移的理解。
- P1802 [5 倍经验日](https://www.luogu.com.cn/problem/P1802)：结合了动态规划和决策选择。

### 个人心得摘录与总结
- **nothingness**：提到用 `dfs` 做本题，要注意标记已经搜索过的情况，否则会 TLE，强调了剪枝的重要性。
- **GavinZheng**：指出 `min` 在 C++ 中为自带函数名，不能当作变量名，提醒注意变量命名避免冲突。
- **陈阳蒟蒻**：第一次提交忘记输出，强调了检查代码完整性的重要性。

---
处理用时：31.95秒
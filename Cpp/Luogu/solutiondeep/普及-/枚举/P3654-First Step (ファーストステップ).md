# 题目信息

# First Step (ファーストステップ)

## 题目背景

> **知らないことばかりなにもかもが（どうしたらいいの？）**    
**一切的一切 尽是充满了未知数（该如何是好）**   
**それでも期待で足が軽いよ（ジャンプだ！）**     
**但我仍因满怀期待而步伐轻盈（起跳吧！）**       
**温度差なんていつか消しちゃえってね**     
**冷若冰霜的态度 有朝一日将会消失得无影无踪**      
**元気だよ元気をだしていくよ**     
**拿出活力 打起精神向前迈进吧**     

 ![](https://cdn.luogu.com.cn/upload/pic/4471.png) 

我们 Aqours，要第一次举办演唱会啦！

虽然学生会长看上去不怎么支持我们的样子，可是有了理事长的支持，我们还是被允许在校内的篮球场里歌唱！

歌曲也好好地准备过了，名字叫“[最喜欢的话就没问题！ (ダイスキだったらダイジョウブ！)](https://zh.moegirl.org/%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98)“，大家一定会喜欢的吧！

演唱会一定会顺利进行的！

希望不要发生**停电**什么的事故哦……！


## 题目描述

可是……这个篮球场，好像很久没有使用过的样子啊……

里面堆满了学校的各种杂物呢……

我们 Aqours 的成员要怎么在里面列队站下呢？


我们浦之星女子学院的篮球场是一个 $R$ 行 $C$ 列的矩阵，其中堆满了各种学校的杂物 (用 `#` 表示)，空地 (用 `.` 表示) 好像并不多的样子呢……

我们 Aqours 现在已经一共有 $K$ 个队员了，要歌唱舞蹈起来的话，我们得排成一条 $1\times K$ 的直线，一个接一个地站在篮球场的空地上呢 (横竖均可)。

我们想知道一共有多少种可行的站位方式呢。

Aqours 的真正的粉丝的你，能帮我们算算吗？


## 说明/提示

|  | $R$ | $C$ | $K$ | 备注 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|$1\sim2$|$\leq 10$|$\leq 10$|$\leq \min(R,C)$|无|
|$3\sim4$|$\leq 100$|$\leq 100$|$\leq 1$|无|
|$5\sim6$|$\leq 100$|$\leq 100$|$\leq \min(R,C)$|没有障碍|
|$7\sim10$|$\leq 100$|$\leq 100$|$\leq \min(R,C)$|无|

对于所有数据，$1 \leq R,C \leq 100$，$1 \leq k \leq \min(R,C)$。

#### 以下是彩蛋

在 LoveLive!Sunshine!! 动画第一季第三集中，Aqours 队长高海千歌演唱“最喜欢的话就没问题！”到副歌前时，学校因为雷击停电。


## 样例 #1

### 输入

```
5 5 2
.###.
##.#.
..#..
#..#.
#.###
```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何在给定的篮球场矩阵中找出可供 `K` 个队员排成 `1×K` 直线的站位方式数量展开。思路上大体可分为暴力枚举和深度优先搜索（DFS）两类。暴力枚举通过遍历矩阵的行和列，检查连续空位是否满足条件；DFS 则从每个可站人的点出发，向特定方向搜索是否能满足 `K` 人站位。所有题解都注意到了 `K = 1` 时需要特判，避免重复计数。

### 所选题解
- **作者：rashoumon（5星）**
    - **关键亮点**：思路清晰，使用 DFS 算法，通过位移向量简化方向判断，代码简洁易读。
    - **个人心得**：无
```cpp
int n,m,r,ans,dx[2]={0,1},dy[2]={1,0};
char map[105][105];
void skim(int x,int y,int i,int j) {
    if(j>r){
        ++ans;
        return ;
    }
    if(map[x][y]!='.'||x<0||y<0||x>=n||y>=m)
        return ;
    skim(x+dx[i],y+dy[i],i,j+1);
    return ;
}
```
核心思想：从每个可站人的点出发，利用位移向量 `dx` 和 `dy` 分别向朝下和朝右两个方向进行 DFS 搜索，若搜索长度达到 `K` 则计数加一。

- **作者：鸿飞（4星）**
    - **关键亮点**：采用简单的暴力枚举方法，思路直观，代码结构清晰，适合初学者理解。
    - **个人心得**：无
```cpp
bool f=true;
for(int i=1;i<=r;i++) {
    for(int j=1;j<=c;j++) {
        f=true;
        for(int s=0;s<k;s++) {
            if(a[i+s][j]!='.') {
                f=false;
                break;
            }
        }
        if(f==true) {
            ans++;
        }
    }
}
for(int i=1;i<=r;i++) {
    for(int j=1;j<=c;j++) {
        f=true;
        for(int s=0;s<k;s++) {
            if(a[i][j+s]!='.') {
                f=false;
                break;
            }
        }
        if(f==true) {
            ans++;
        }
    }
}
```
核心思想：分别对矩阵的行和列进行遍历，检查连续 `K` 个位置是否都是空位，若是则计数加一。

- **作者：loi_hjh（4星）**
    - **关键亮点**：采用 `n^2` 的算法，通过统计连续空位的长度，避免了重复检查，优化了时间复杂度。
    - **个人心得**：“只有一个人的话横竖都一样，特判一下，居然出了两个人数是 1 的数据卡我 20 分”，强调了特判 `K = 1` 情况的重要性。
```cpp
for(ri i=1;i<=n;i++) {
    q=0;
    for(ri j=1;j<=m;j++) {
        if(a[i][j]=='.') q++;
        else {
            if(q>=p) ans+=q-p+1;
            q=0;
        }
    }
    if(q>=p) ans+=q-p+1;
}
for(ri i=1;i<=n;i++) {
    q=0;
    for(ri j=1;j<=m;j++) {
        if(a[j][i]=='.') q++;
        else {
            if(q>=p) ans+=q-p+1;
            q=0;
        }
    }
    if(q>=p) ans+=q-p+1;
}
```
核心思想：分别统计矩阵每行和每列连续空位的长度，若长度大于等于 `K`，则该连续空位上有 `q - K + 1` 种站位方式。

### 最优关键思路或技巧
- **位移向量**：如 `rashoumon` 的题解中使用位移向量 `dx` 和 `dy` 来表示搜索方向，简化了方向判断的代码实现。
- **统计连续空位长度**：`loi_hjh` 的题解通过统计连续空位的长度，避免了重复检查，将时间复杂度优化到 `n^2`。
- **特判 `K = 1`**：所有题解都注意到了 `K = 1` 时需要特判，避免重复计数，这是解决本题的关键细节。

### 可拓展之处
同类型题可能会改变矩阵的形状、增加障碍物的类型、改变站位的规则等。类似算法套路可以应用于其他矩阵搜索问题，如寻找特定形状的连通区域、计算满足条件的路径数量等。

### 推荐题目
- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：考察矩阵的遍历和连通区域的判断。
- [P1451 求细胞数量](https://www.luogu.com.cn/problem/P1451)：需要使用 DFS 或 BFS 算法来统计矩阵中连通区域的数量。
- [P2002 消息扩散](https://www.luogu.com.cn/problem/P2002)：涉及图的遍历和连通性问题，与矩阵搜索有一定的相似性。

### 个人心得总结
多位作者提到了 `K = 1` 时需要特判的问题，这是本题的一个重要坑点。在解题过程中，要仔细分析题目条件，注意特殊情况的处理，避免因疏忽导致错误。

---
处理用时：32.29秒
# 题目信息

# 八百标兵奔北坡

## 题目背景

baingbaboom正在往北边跑！！！

## 题目描述

现在在一张N*M的地图上有K只babingbaboom！！！对于一张地图上的点都有一个 $ h_{i,j} $ 来表示这个地方的高度。现在这些babingbaboom都想要跑到北边的一个山坡上。求出离每一个babingbaboom最近的靠北的山。

补充定义：

山：

山的周围没有比它更高的地方。(四联通)

在北边：

令Babingbaboom的坐标为$A(a,b)$，山的坐标为$B(x,y)$，山在Babingbaboom的北边当且仅当$dis_{A,B}==a-x$

切比雪夫距离:

$ A(x_1,y_1) \qquad B(x_2,y_2) : \qquad dis_{A,B}=max(|x_1 - x_2|, |y_1 - y_2|)$


## 说明/提示

$$ 1 \leqslant  N,M \leqslant 1e3 $$
$$ 1 \leqslant  K \leqslant 1e5 $$
$$ 1 \leqslant  h_{i,j} \leqslant 1e9 $$
数据有梯度！

样例图片(星代表一个Babingbaboom，红色代表一个山)：
![](https://cdn.luogu.com.cn/upload/pic/22827.png)
(竖的是x，横的是y。画的时候没注意，很抱歉。)

## 样例 #1

### 输入

```
5 5 5
1 2 3 4 5
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
5 1 2 3 4
1 2
2 3
3 4
4 5
5 1
```

### 输出

```
Pool Babingbaboom!
Pool Babingbaboom!
1
2
0```

# AI分析结果

### 综合分析与结论
这些题解主要采用了枚举、动态规划（DP）、搜索（广搜）、前缀和与二分查找等方法来解决问题。枚举法通过直接遍历每个 `babingbaboom` 可到达的位置来寻找最近的山；DP 法通过状态转移方程 `f[i][j]=min(f[i - 1][j - 1], f[i - 1][j], f[i - 1][j + 1]) + 1` 提前计算出每个点到最近山的距离；搜索法从当前点开始扩展，找到山就返回距离；前缀和与二分查找法先预处理出所有点是否为山并求二维前缀和，再通过暴力枚举和二分查找来找到最近的山。

### 所选题解
- **作者：_Spectator_（5星）**
    - **关键亮点**：思路清晰，对题意进行了详细解释，代码有注释，适合新手。
    - **核心代码**：
```cpp
#define rep(i, a, b) for(int i=a; i<=b; i++)
#define ismountain(i, j)\
a[i][j]>a[i-1][j] && a[i][j]>a[i+1][j] && a[i][j]>a[i][j-1] && a[i][j]>a[i][j+1]
int bbbb(int x, int y){
    rep(i, 0, x - 1) rep(j, max(0, y - i), min(m, y + i))
        if(h[x - i][j]) return i;
    return -1;
}
```
    - **核心思想**：通过枚举每个 `babingbaboom` 可到达的位置，若找到山则返回当前的 `i` 作为距离，未找到则返回 -1。
- **作者：b2019dy（4星）**
    - **关键亮点**：使用简单的 DP 思路，代码简洁。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++){
        if(h[i][j] > h[i - 1][j] && h[i][j] > h[i + 1][j] && h[i][j] > h[i][j + 1] && h[i][j] > h[i][j - 1])
            f[i][j] = 0;
        else
            f[i][j] = min(f[i - 1][j], min(f[i - 1][j - 1], f[i - 1][j + 1])) + 1;
    }
```
    - **核心思想**：若当前点是山，则 `f[i][j] = 0`；否则通过状态转移方程更新 `f[i][j]`。
- **作者：BetterGodPig（4星）**
    - **关键亮点**：使用广搜思路，有流程图辅助理解，代码规范。
    - **核心代码**：
```cpp
inline void bfs(int startx, int starty){
    if(check(startx, starty)){
        puts("0");
        return;
    }
    queue<node> q;
    q.push({startx, starty, 0});
    while(!q.empty()){
        for(register int i = 0; i < 3; i++){
            node now = q.front();
            int tx = now.x - 1; int ty = now.y + ny[i];
            if(tx < 1 || ty < 1 || ty > m) continue;
            int disn = now.dis + 1;
            if(check(tx, ty)){
                write(disn);
                putchar(10);
                return;
            }else{
                q.push({tx, ty, disn});
            }
        }
        q.pop();
    }
    puts("Pool Babingbaboom!");
}
```
    - **核心思想**：从起始点开始广搜，若当前点是山则返回距离，否则将扩展的点入队继续搜索，若队列为空仍未找到则输出提示信息。

### 最优关键思路或技巧
- **DP 思想**：通过状态转移方程提前计算出每个点到最近山的距离，避免重复计算，时间复杂度较低。
- **枚举优化**：在枚举时，通过合理确定枚举范围，减少不必要的计算。

### 可拓展之处
同类型题或类似算法套路：
- 地图上的路径搜索问题，如求最短路径、最大价值路径等。
- 二维数组的状态转移问题，可通过 DP 解决。

### 推荐题目
- P1002 过河卒
- P1216 [USACO1.5] 数字三角形 Number Triangles
- P1434 [SHOI2002] 滑雪

### 个人心得摘录与总结
- **轻尘**：一开始没看出是 DP 题，用暴力方法得了 85 分，后经大佬指点才明白可以用 DP 解决。总结是要从复杂的题目描述中看出规律，学会运用 DP 思想。
- **hanzhongtlx**：不要特判 `a[i].x = 1`，因为该点有可能就在山上，避免掉入这种小陷阱。 

---
处理用时：33.70秒
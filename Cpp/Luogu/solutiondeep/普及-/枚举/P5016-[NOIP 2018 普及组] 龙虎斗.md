# 题目信息

# [NOIP 2018 普及组] 龙虎斗

## 题目背景

NOIP2018 普及组 T2

## 题目描述

轩轩和凯凯正在玩一款叫《龙虎斗》的游戏，游戏的棋盘是一条线段，线段上有 $n$ 个兵营（自左至右编号 $1 \sim n$），相邻编号的兵营之间相隔 $1$ 厘米，即棋盘为长度为 $n-1$ 厘米的线段。$i$ 号兵营里有 $c_i$ 位工兵。下面图 1 为 $n=6$ 的示例： 

![](https://cdn.luogu.com.cn/upload/pic/43224.png)    

轩轩在左侧，代表“龙”；凯凯在右侧，代表“虎”。 他们以 $m$ 号兵营作为分界， 靠左的工兵属于龙势力，靠右的工兵属于虎势力，而第 $m$ 号兵营中的工兵很纠结，他们不属于任何一方。    

一个兵营的气势为：该兵营中的工兵数$ \times $ 该兵营到 $m$ 号兵营的距离；参与游戏 一方的势力定义为：属于这一方所有兵营的气势之和。    
下面图 2 为 $n = 6,m = 4$ 的示例，其中红色为龙方，黄色为虎方：

![](https://cdn.luogu.com.cn/upload/pic/43225.png)  

游戏过程中，某一刻天降神兵，共有 $s_1$ 位工兵突然出现在了 $p_1$ 号兵营。作为轩轩和凯凯的朋友，你知道如果龙虎双方气势差距太悬殊，轩轩和凯凯就不愿意继续玩下去了。为了让游戏继续，你需要选择一个兵营 $p_2$，并将你手里的 $s_2$ 位工兵全部派往 兵营 $p_2$，使得双方气势差距尽可能小。 

 注意：你手中的工兵落在哪个兵营，就和该兵营中其他工兵有相同的势力归属（如果落在 $m$ 号兵营，则不属于任何势力）。

## 说明/提示

**样例 1 说明**   

见问题描述中的图 2。   
双方以 $m=4$ 号兵营分界，有 $s_1=5$ 位工兵突然出现在 $p_1=6$ 号兵营。 
龙方的气势为：   
$$2 \times (4-1)+3 \times (4-2)+2 \times (4-3) = 14$$  
虎方的气势为：   
$$2 \times  (5 - 4) + (3 + 5) \times (6 - 4) = 18$$  
当你将手中的 $s_2 = 2$ 位工兵派往 $p_2 = 2$ 号兵营时，龙方的气势变为： 
$$14 + 2 \times  (4 - 2) = 18$$  
此时双方气势相等。 
  
**样例 2 说明**   

双方以 $m = 5$ 号兵营分界，有 $s_1 = 1$ 位工兵突然出现在 $p_1 = 4$ 号兵营。  
龙方的气势为：   
$$1 \times  (5 - 1) + 1 \times  (5 - 2) + 1 \times  (5 - 3) + (1 + 1) \times  (5 - 4) = 11$$  
虎方的气势为：   
$$16 \times  (6 - 5) = 16$$    
当你将手中的 $s_2 = 1$ 位工兵派往 $p_2 = 1$ 号兵营时，龙方的气势变为：    
$$11 + 1 \times  (5 - 1) = 15$$    
此时可以使双方气势的差距最小。

**数据规模与约定**    


$1 < m < n$，$1 \le p_1 \le n$。   
对于 $20\%$ 的数据，$n = 3,m = 2, c_i = 1, s_1,s_2 ≤ 100$。    
另有 $20\%$ 的数据，$n ≤ 10, p_1 = m, c_i = 1, s_1,s_2 ≤ 100$。  
对于 $60\%$ 的数据，$n ≤ 100, c_i = 1, s_1,s_2 ≤ 100$。   
对于 $80\%$ 的数据，$n ≤ 100, c_i,s_1,s_2 ≤ 100$。  
对于 $100\%$ 的数据，$n≤10^5$,$c_i,s_1,s_2≤10^9$。 

## 样例 #1

### 输入

```
6 
2 3 2 3 2 3 
4 6 5 2 ```

### 输出

```
2```

## 样例 #2

### 输入

```
6 
1 1 1 1 1 16 
5 4 1 1```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何解决“龙虎斗”问题展开，思路可分为暴力枚举和公式计算两类。暴力枚举是先计算初始双方气势，再枚举 $s_2$ 放置的兵营位置，更新双方气势差，取最小值对应的兵营编号；公式计算则是通过建立等式，用已知量表示出 $s_2$ 应放置的兵营位置。

算法要点方面，多数题解都强调了预处理双方气势以减少重复计算，同时要注意数据范围，使用 `long long` 避免溢出。解决难点在于优化时间复杂度，避免 $O(n^2)$ 的暴力枚举超时，以及处理边界情况和浮点数计算。

### 所选题解
- **wxy_god（5星）**
    - **关键亮点**：思路全面，从暴力枚举逐步优化到方程法，详细解释了超时和错误原因，代码注释丰富，适合学习。
    - **个人心得**：作者在考场上用暴力枚举超时，后发现是时间复杂度问题，又因没开 `long long` 导致部分点 WA，最后成功 AC 并进一步优化到方程法。
    - **核心代码**：
```cpp
// 方程法
#include <bits/stdc++.h>
inline long long read () {
    register long long x = 0, ch = getchar();
    while(!isdigit(ch)) ch = getchar();
    while( isdigit(ch) ) x = x * 10 + ch - '0', ch = getchar();
    return x;
}
inline long long abs (long long x) {
    if(x >= 0) return x;
    return -x;
}
long long m, p1, s1, s2, a[1000005], t1, t2;
int n;
int main () {
    double where;
    long long gap;
    n = read();
    for(int i = 1; i <= n; i ++ ) {
        a[i] = read();
    }
    m = read();
    p1 = read();
    s1 = read();
    s2 = read();
    a[p1] += s1;
    for(int i = 1; i <= n; i ++ ) {
        gap += (m - i) * a[i];
    }
    double dgap = gap;
    long long int ans;
    where = m + dgap / s2;
    if(where >= n) {
        ans = n;
    }
    else if(where <= 1)
        ans = 1;
    else {
        int iwhere = where;
        if(iwhere == where) ans = iwhere;
        else {
            long long ans1 = abs(gap + (m - iwhere ) * s2);
            long long ans2 = abs(gap + (m - iwhere - 1) * s2);
            ans = ans1 <= ans2? iwhere : iwhere + 1;
        }
    }
    printf("%lld", ans);
    return 0;
}
```
核心实现思想：先计算双方气势差 `gap`，通过方程 `gap + (m - p2) * s2 = 0` 解出 `p2`，再根据 `p2` 的取值范围和是否为整数进行分类讨论，得出最终答案。

- **ykuouzf（4星）**
    - **关键亮点**：思路简洁，直接通过公式计算出 $s_2$ 应放置的兵营位置，代码短小精悍。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000000],m,p,s,k,sum,ans;
int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    scanf("%lld%lld%lld%lld",&m,&p,&s,&k);
    for(int i=1;i<=n;i++) sum+=a[i]*(m-i);
    sum+=s*(m-p);
    ans=m+int(sum*1.0/k+0.5*(sum>0?1:-1));
    if(ans>n) ans=n;
    if(ans<1) ans=1;
    printf("%lld",ans);
    return 0;
}
```
核心实现思想：先计算双方气势差 `sum`，通过公式 `ans = m + int(sum * 1.0 / k + 0.5 * (sum > 0? 1 : -1))` 计算出 $s_2$ 应放置的兵营位置，再处理边界情况。

- **犇犇犇犇（4星）**
    - **关键亮点**：思路清晰，先计算初始双方气势，再根据气势大小确定 $s_2$ 应放置的方向，最后比较两个可能位置的气势差，得出答案。
    - **个人心得**：作者因没考虑边界情况和编号最小的条件，被卡了 10 分钟，提醒读者注意这些坑点。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define max maxx 
#define min minn
#define ll long long
using namespace std;
ll n,c[100005],m,p1,s1,s2,p2;
ll lo,hu;
ll max(ll a,ll b) {
    if(a>b) return a;
    else return b;
}
ll min(ll a,ll b) {
    if(a<b) return a;
    else return b;
}
int main() {
    ll i;
    cin>>n;
    for(i=1;i<=n;i++) 
        cin>>c[i];
    cin>>m>>p1>>s1>>s2;
    c[p1]+=s1;
    for(i=1;i<m;i++)
        lo+=c[i]*(m-i);
    for(i=m+1;i<=n;i++)
        hu+=c[i]*(i-m);
    if(lo==hu)
        cout<<m<<endl;
    else if(lo<hu) {
        p2=m-(hu-lo)/s2;
        p2=max(1,p2);
        p2=min(n,p2);
        if(p2>1 && (abs(lo+s2*(m-p2+1)-hu)<=abs(hu-lo-s2*(m-p2))))
            cout<<p2-1<<endl;
        else cout<<p2<<endl;
    } 
    else {
        p2=m+(lo-hu)/s2;
        p2=max(1,p2);
        p2=min(n,p2);
        if(p2<n && (abs(hu+s2*(p2+1-m)-lo)<abs(hu+s2*(p2-m)-lo)))
            cout<<p2+1<<endl;
        else cout<<p2<<endl;
    }
    return 0;
}
```
核心实现思想：先计算初始龙方气势 `lo` 和虎方气势 `hu`，若 `lo < hu`，则 $s_2$ 应放在龙方，计算出可能的位置 `p2`，比较 `p2` 和 `p2 - 1` 的气势差；若 `lo > hu`，则 $s_2$ 应放在虎方，计算出可能的位置 `p2`，比较 `p2` 和 `p2 + 1` 的气势差。

### 最优关键思路或技巧
- **预处理**：先计算初始双方气势，避免每次枚举都重复计算，将时间复杂度从 $O(n^2)$ 优化到 $O(n)$。
- **方程法**：通过建立等式，用已知量表示出 $s_2$ 应放置的兵营位置，减少枚举次数。
- **边界处理**：注意数据范围，使用 `long long` 避免溢出，同时处理好边界情况，如 $p_2$ 超出 $1$ 到 $n$ 的范围。

### 拓展思路
同类型题或类似算法套路：
- 此类问题可拓展到更复杂的场景，如多个分割点、多个势力等，解题思路依然是先计算初始状态，再枚举或通过公式计算最优解。
- 类似的算法套路还包括区间求和、贪心算法等，可用于解决其他优化问题。

### 推荐题目
- [P1002 [NOIP2002 普及组] 过河卒](https://www.luogu.com.cn/problem/P1002)：考察动态规划和路径规划。
- [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)：考察 0 - 1 背包问题。
- [P1216 [USACO1.5][IOI1994] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：考察动态规划和数字三角形模型。

### 个人心得总结
- **wxy_god**：考场上用暴力枚举超时，后发现时间复杂度问题，又因没开 `long long` 导致部分点 WA，提醒读者注意优化和数据范围。
- **犇犇犇犇**：因没考虑边界情况和编号最小的条件，被卡了 10 分钟，提醒读者注意这些坑点。
- **Kdlyh**：考场上做出题目，但因电脑异常关机丢失代码，申诉延时被拒，成果付之东流，写题解证明自己实力。 

---
处理用时：53.10秒
# 题目信息

# 最大差值

## 题目描述

HKE 最近热衷于研究序列，有一次他发现了一个有趣的问题：

对于一个序列 $A_1,A_2,\cdots,A_n$，找出两个数 $i,j$（$1\le i<j\le n$），使得 $A_j-A_i$ 最大。

现在给出这个序列，请找出 $A_j-A_i$ 的最大值。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，$n\le1000$；
- 对于 $70\%$ 的数据，$n\le10^5$；
- 对于 $100\%$ 的数据：$2\le n\le 10^6$，$A_i$ 在 int 范围内。

## 样例 #1

### 输入

```
10
1
3
4
6
7
9
10
1
2
9

```

### 输出

```
9```

# AI分析结果

### 综合分析与结论
本题旨在找出序列中满足 $1\leq i<j\leq n$ 的 $i$ 和 $j$，使得 $A_j - A_i$ 最大。各题解思路主要分为暴力枚举和优化算法两类。暴力枚举时间复杂度为 $O(n^2)$，会超时；优化算法通过维护前缀最小值，将时间复杂度降为 $O(n)$，部分使用线段树优化到 $O(n\log n)$。

### 所选题解
- **雨伞CKY（5星）**
    - **关键亮点**：思路清晰，先给出暴力做法及复杂度分析，再引出优化思路和伪代码，最后给出代码实现，代码简洁易懂。
    - **个人心得**：无
- **Kobe303（4星）**
    - **关键亮点**：详细分析暴力做法的复杂度并指出不可行，提出优化思路，强调差值可能爆 int 要开 long long 的细节。
    - **个人心得**：无
- **Miracle_ZX（4星）**
    - **关键亮点**：提出新思路，强调在线更新最小值和最大差的方法，提醒变量类型和初值设置的注意事项。
    - **个人心得**：指出之前题解因 `maxn` 初值不够小导致测试点出错的问题。

### 重点代码及核心思想
#### 雨伞CKY
```cpp
#include <climits>
#include <iostream>
using namespace std;

int n;
long long int tmp,ans = LLONG_MIN,minn;

int main() {
    cin >> n >> minn;
    for (int i = 2;i <= n;i++){
        cin >> tmp;
        if (tmp - minn > ans) ans = tmp - minn;
        if (tmp < minn) minn = tmp;
    }
    cout << ans;
    return 0;
}
```
核心思想：在读入第 $k$ 个数时，更新 $A_j - A_i$ 的最大值（$A_j - minn_{k - 1}$）和前 $k$ 个数的最小值 $minn_k$。

#### Kobe303
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define reg register 
#define il inline
int n;
ll minx;
ll ans = -1e15;
int main()
{
    scanf("%d%lld", &n, &minx);
    for (int i = 2; i <= n; ++i) {
        ll x; scanf("%lld", &x);
        if (ans < x - minx) ans = x - minx;
        if (x < minx) minx = x;
    }
    printf("%lld", ans);
    return 0;
}
```
核心思想：对于每个 $a_j$，求 $a_j - a_i$ 的最大值转换为求 $a_i$ 的最小值（$1\leq i < j$），在读入过程中更新 $a_i$ 的最小值。

#### Miracle_ZX
```cpp
#include<bits/stdc++.h>
using namespace std;

long long res, maxn = -0x3f3f3f3f3f3f3f3f, n, pre; 
int main() 
{
    cin >> n >> pre;
    for (int j = 2; j <= n; ++j) 
    {
        cin >> res;
        if (maxn < res - pre) maxn = res - pre;
        if (res < pre) pre = res; 
    }
    cout << maxn;
    return 0;
}
```
核心思想：从前往后扫描 $a_j$，维护最小值和最大差，当遍历到更小的 $a_j$ 时更新最小值，否则更新最大差。

### 最优关键思路或技巧
维护前缀最小值，避免重复查找最小值，将时间复杂度从 $O(n^2)$ 优化到 $O(n)$。

### 拓展思路
同类型题可拓展到求序列中满足一定条件的最大差值问题，如限定差值的范围、差值的计算方式等。类似算法套路可用于解决其他需要维护前缀信息的问题，如前缀和、前缀最大值等。

### 推荐题目
- P1115 最大子段和
- P1714 切蛋糕
- P2671 [NOIP2015 普及组] 求和

### 个人心得总结
Miracle_ZX 指出之前题解中 `maxn` 初值不够小会导致测试点出错，提醒我们在设置变量初值时要足够小，同时使用 `long long` 类型以防越界。 

---
处理用时：25.35秒
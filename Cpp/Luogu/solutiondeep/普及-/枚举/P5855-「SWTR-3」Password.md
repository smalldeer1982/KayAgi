# 题目信息

# 「SWTR-3」Password

## 题目背景

小 $\mathrm{A}$ 在茂密的森林里找到了一个宝箱。

宝箱设有密码锁，但小 $\mathrm{A}$ 不知道密码。

## 题目描述

宝箱的密码由 $n$ 位数字组成，如果将它们连在一起写，就可以看作是一个长度为 $n$ 的字符串。

小 $\mathrm{A}$ 想通过猜的方式试出密码。对于每一位数字，都会有一个集合 $s_i$，表示小 $\mathrm{A}$ 第 $i$ 位的尝试范围。

同时，小 $\mathrm{A}$ 已经试过了 $k$ 个密码组合 $d_1,d_2,\dots,d_k$，**这些密码不一定符合上文中的“尝试范围”**。

小 $\mathrm{A}$ 想知道他最多还需要尝试多少次才可以试出宝箱的密码，如果永远试不出输出 $\mathrm{-1}$。

## 说明/提示

---

### 样例说明

- 在样例 $1$ 中，小 $\mathrm{A}$ 可能试的密码组合有：`014,015,044,045,094,095,114,115,144,145,194,195` 共 $12$ 个数，其中包含密码，但因为 `145` 已经试过，所以小 $\mathrm{A}$ 最多还需尝试 $11$ 次。

- 在样例 $2$ 中，小 $\mathrm{A}$ 可能试的密码组合有：`13,14,23,24`，共 $4$ 个数，其中没有密码，所以小 $\mathrm{A}$ 永远试不出密码。

---

### 数据范围与约定

**本题使用捆绑测试。**

Subtask 编号 | $n\leq$ | 特殊性质 | 分数
:-: | :-: | :-: | :-:
$1$ | $18$ | 答案为 $-1$ | $7$
$2$ | $1$ | 无 | $13$
$3$ | $6$ | 无 | $24$
$4$ | $18$ | $k=0$ | $21$
$5$ | $18$ | 无 | $35$

对于 $100\%$ 的数据，有 $1\leq n\leq 18$，$0\leq k \leq\min(10^n-1,10^4)$。

保证 $d_i$ 不为密码。

---

对于所有测试点，时间限制 $1\mathrm{s}$，空间限制 $128\mathrm{MB}$。

## 样例 #1

### 输入

```
3 2
094
2 01
3 149
2 45
145
345
```

### 输出

```
11```

## 样例 #2

### 输入

```
2 1
12
2 12
2 34
13
```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 10
907887
9 295064731
6 796350
9 295378410
5 48520
9 745208361
7 8079632
111664
422880
521471
433649
037388
091076
235569
979229
268527
690028
```

### 输出

```
153085```

## 样例 #4

### 输入

```
18 10
869813962161100526
7 1762348
8 13948756
6 542169
8 78314952
6 432601
9 697130845
8 16358709
8 95204367
8 24079563
6 145602
7 6231549
6 157096
8 62534170
5 82390
7 5396702
8 20536491
7 1438692
5 59261
396440170984129947
891187409797339137
626815840963841542
192230179244843846
148170753474901744
142718603216393332
486224779191226121
819116507635433912
879948053659796486
875405657525125039
```

### 输出

```
1468282385203195```

# AI分析结果

### 综合分析与结论
这些题解整体思路一致，都是先算出所有可能的密码组合数，再判断密码是否在尝试范围内，若不在则输出 -1，若在则减去已尝试且符合范围的组合数得到最终答案。各题解在代码实现上略有差异，如数据存储方式、判断字符是否在范围的方法等。

### 所选题解
- **wpy233（5星）**
    - **关键亮点**：思路清晰，对题意和代码实现步骤解释详细，代码注释丰富，还分享了自己的调试经历和思考过程。
    - **个人心得**：一开始以为每一位只有 9 种可能，后来发现可以取 0 - 9 共 10 个数；代码中把 `true` 和 `false` 写反了还跑过了四个样例，质疑样例强度。
- **翼德天尊（4星）**
    - **关键亮点**：解题步骤明确，分为审题、思路概述、代码实现等部分，对思路和代码进行了详细注释，方便理解。
- **Alex_Wei（4星）**
    - **关键亮点**：思路简洁明了，先总结解题步骤，再给出代码，时间复杂度分析清晰。

### 重点代码及核心思想
#### wpy233
```cpp
for(int i=1;i<=n;i++)
{
    cin>>a[i];
    bool flag=false;
    for(int j=1;j<=a[i];j++)
    {
        char t;
        cin>>t;
        if(t==mima[i-1]) flag=true;
        b[i][t-48]=true;
    }
    if(!flag)
    {
        cout<<-1<<endl;
        return 0;
    }
    ans*=a[i];
}
string p;
for(int i=1;i<=k;i++)
{
    cin>>p;
    bool flag=true;
    for(int j=0;j<n;j++)
        if(!b[j+1][p[j]-48])
        {
            flag=false;
            break;
        }
    if(flag) ans--;
}
```
核心思想：先输入每一位的可能情况，判断密码是否在尝试范围内，若不在则输出 -1；计算所有可能的组合数，再遍历已尝试的密码，若符合范围则从总数中减去。

#### 翼德天尊
```c
for (int i=0;i<n;i++){
    cin>>kn[i].l>>kn[i].k;
    ans*=kn[i].l;
    for (int j=0;j<kn[i].l;j++){
        ma[i][kn[i].k[j]-'0']=1;
    }
}
for (int i=0;i<n;i++){
    if (ma[i][m[i]-'0']==0){
        printf("-1\n");
        return 0;
    }
}
while (k--){
    bool f=0;
    string c;
    cin>>c;
    for (int i=0;i<n;i++){
        if (ma[i][c[i]-'0']==0){
            f=1;
            break;	
        } 
    }
    if (f==0) ans--;
}
```
核心思想：用结构体存储每一位的范围，计算所有可能组合数，判断密码是否在范围内，遍历已尝试密码，符合范围则从总数中减 1。

#### Alex_Wei
```cpp
bool check(string pas){
    for(int i=0;i<n;i++){
        int legal=0;
        for(int j=0;j<v[i];j++)
            if(s[i][j]==pas[i])
                legal=1;
        if(!legal)return false; 
    }
    return true;
}
int main(){
    cin>>n>>k>>a;
    for(int i=0;i<n;i++){
        cin>>v[i]>>s[i];
        ans*=v[i];
    }
    if(!check(a)){
        puts("-1");
        exit(0);
    }
    for(int i=0;i<k;i++){
        cin>>d;
        ans-=check(d);
    }
    cout<<ans<<endl;
    return 0;
}
```
核心思想：定义 `check` 函数判断字符串是否在尝试范围内，计算所有可能组合数，判断密码是否在范围内，遍历已尝试密码，符合范围则从总数中减 1。

### 最优关键思路或技巧
- 使用布尔数组标记每一位的可能数字，方便判断字符是否在尝试范围内。
- 定义函数封装判断字符串是否在范围的逻辑，提高代码的可读性和复用性。

### 可拓展之处
同类型题可能会增加密码长度、尝试范围的复杂度，或者改变判断条件。类似算法套路可用于解决排列组合相关的计数问题，先计算所有可能情况，再根据条件排除不符合的情况。

### 推荐题目
- P1008 三连击
- P1036 选数
- P1157 组合的输出

---
处理用时：26.26秒
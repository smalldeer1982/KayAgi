# 题目信息

# [USACO22JAN] Non-Transitive Dice B

## 题目描述

为了消磨牛棚里的时光，奶牛们喜欢玩简单的骰子游戏。其中一种游戏使用两个骰子 X 和 Y 进行。两个骰子均被投掷，获胜的骰子是显示的数字较大的骰子。如果两者显示相同的数字，则重新投掷（只要持续打平，骰子可能会被重新投掷多次）。我们称骰子 X 击败骰子 Y，如果骰子 X 比骰子 Y 更有可能赢得这局游戏。

考虑以下的 $4$ 面骰子：

骰子 A 在各面上有数字 $4$，$5$，$6$ 和 $7$。

骰子 B 在各面上有数字 $2$，$4$，$5$ 和 $10$。

骰子 C 在各面上有数字 $1$，$4$，$8$ 和 $9$。

这些骰子满足一个相当奇妙的性质：A 击败 B，B 击败 C，并且 C 也击败 A。特别地，三个骰子都不是「最佳的」，可以击败其他两个。在这种情况下，当没有两个骰子打平，也没有一个骰子是最佳的，我们称这三个骰子的集合为「非传递的」。在非传递的三个骰子的集合中，每个骰子击败一个其他骰子，并输给另一个其他骰子。

给定两个 $4$ 面骰子 A 和 B 各面上的数字，请帮助奶牛们求出是否有方法为第三个骰子 C 的各面分配数字，使得这个骰子的集合是非传递的。所有骰子面上的数字必须是 $1$ 到 $10$ 的整数。

## 说明/提示

**【样例解释】**

第一个子测试用例对应题目中的例子。在第二个子测试用例中，不存在骰子 C 可以使得这个骰子集合是非传递的。同理第三个子测试用例的答案也是 `no`。



## 样例 #1

### 输入

```
3
4 5 6 7 2 4 5 10
2 2 2 2 1 1 1 1
1 1 1 1 2 2 2 2```

### 输出

```
yes
no
no```

# AI分析结果

### 综合分析与结论
这些题解思路基本一致，均采用暴力枚举的方法。由于骰子只有 4 面，且每面数字范围是 1 到 10，所以枚举所有可能的骰子 C 的情况，时间复杂度为 $O(10^4)$，可以通过本题。各题解的主要区别在于代码实现细节和优化方式。部分题解进行了特判，如判断 A 和 B 是否平局；部分题解使用了搜索算法，如深搜；还有部分题解对代码进行了封装，提高了代码的可读性。

### 所选题解
- **清小秋ovo（5星）**
    - **关键亮点**：思路清晰，代码结构简洁，直接四层循环模拟 + 判断，易于理解。
    - **核心代码**：
```cpp
bool x_win_y(int x[4], int y[4]){
    int x_cnt =0, y_cnt = 0; 
    for(int i=0;i<4;i++){
        for(int j=0;j<4;j++){
            if(x[i]>y[j])x_cnt++;
            else if(x[i]<y[j])y_cnt++;
        }
    }
    return x_cnt > y_cnt;
}

bool check(){
    if(x_win_y(a,b) && x_win_y(b,c) && x_win_y(c,a))return true;
    if(x_win_y(b,a) && x_win_y(c,b) && x_win_y(a,c))return true;
    return false; 
}

void solve(){
    for(c[0]=1;c[0]<=10;c[0]++){
        for(c[1]=c[0];c[1]<=10;c[1]++){
            for(c[2]=c[1];c[2]<=10;c[2]++){
                for(c[3]=c[2];c[3]<=10;c[3]++){
                    if(check()){
                        puts("yes"); 
                        return;
                    }
                }
            }
        }
    }
    puts("no");
}
```
核心实现思想：通过 `x_win_y` 函数判断两个骰子的胜负关系，`check` 函数检查三个骰子是否满足非传递性，`solve` 函数枚举所有可能的骰子 C 的情况。

- **yeshubo_qwq（4星）**
    - **关键亮点**：先特判 A 和 B 是否平局，减少不必要的枚举，使用深搜枚举所有可能的骰子 C 的情况。
    - **核心代码**：
```cpp
int check(int *a,int *b){
    int w=0,l=0;
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
            if(a[i]>b[j])w++;
            else if(a[i]<b[j])l++;
    if(w>l)  return  1;
    if(w<l)  return -1;
    if(w==l) return  0;
}

void dfs(int t){
    if(flag==1)return;
    if(t>4){
        if(check(a,c)==-1&&check(b,c)==1)
            flag=1;
        return;
    }
    for(int i=1;i<=10;i++)c[t]=i,dfs(t+1);
}
```
核心实现思想：`check` 函数判断两个骰子的胜负关系，`dfs` 函数使用深搜枚举所有可能的骰子 C 的情况，当找到符合条件的骰子 C 时，标记 `flag` 为 1。

### 最优关键思路或技巧
- 暴力枚举：由于数据范围较小，直接枚举所有可能的骰子 C 的情况。
- 特判：在枚举前先判断 A 和 B 是否平局，若平局则直接输出 `no`，减少不必要的枚举。
- 封装函数：将判断两个骰子胜负关系的逻辑封装成函数，提高代码的可读性和复用性。

### 拓展思路
同类型题或类似算法套路：
- 当数据范围增大时，可以考虑使用动态规划或其他优化算法。
- 可以将问题拓展到更多骰子的情况，判断是否存在非传递性。

### 推荐题目
- P1008 [NOIP1998 普及组] 三连击
- P1036 [NOIP2002 普及组] 选数
- P1047 [NOIP2005 普及组] 校门外的树

### 个人心得
- 清小秋ovo：“15 分钟乱打的。可能码风有点丑。直接四层循环模拟 + 判断。” 总结：在时间有限的情况下，可以先采用简单直接的方法实现，再考虑优化。
- ztlh：“考场上想优化想了好久，最后发现暴力就能过。” 总结：在考试时，要根据数据范围合理选择算法，不要过度追求优化。

---
处理用时：24.98秒
# 题目信息

# [蓝桥杯 2016 国 C] 赢球票

## 题目描述

某机构举办球票大奖赛。获奖选手有机会赢得若干张球票。

主持人拿出 $N$ 张卡片（上面写着 $1 \sim N$ 的数字），打乱顺序，排成一个圆圈。

你可以从任意一张卡片开始顺时针数数 $:1,2,3 \cdots $。

如果数到的数字刚好和卡片上的数字相同，则把该卡片收入囊中，从下一个卡片重新数数。

直到再无法收获任何卡片，游戏结束。囊中卡片数字的和就是赢得球票的张数。

比如：

卡片排列是：$1,2,3$。

我们从 $1$ 号卡开始数，就把 $1$ 号卡拿走。再从 $2$ 号卡开始，但数的数字无法与卡片对上，

很快数字越来越大，不可能再拿走卡片了。因此这次我们只赢得了 $1$ 张球票。

还不算太坏！如果我们开始就傻傻地从 $2$ 或 $3$ 号卡片数起，那就一张卡片都拿不到了。

如果运气好，卡片排列是 $2,1,3$。

那我们可以顺利拿到所有的卡片！

本题的目标就是：已知顺时针卡片序列。

随便你从哪里开始数，求最多能赢多少张球票（就是收入囊中的卡片数字之和）

## 说明/提示

时限 1 秒, 256M。蓝桥杯 2016 年第七届国赛

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
1```

## 样例 #2

### 输入

```
3
2 1 3```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均为枚举所有可能的起始卡片位置，模拟数数过程，统计每种起始位置下能拿走的卡片数字之和，最终取最大值。在实现上，多数题解使用数组标记卡片是否被拿走，部分题解使用队列模拟循环。

### 所选题解
- **作者：liuyi0905（5星）**
    - **关键亮点**：思路清晰，代码简洁易懂，使用数组标记卡片状态，通过简单的循环模拟游戏过程。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    int f[101]={0},x=1,sum=0,j=i,m=n;
    while(1){
        if(f[j]==0){
            if(x==a[j]){
                sum+=a[j];
                f[j]=1;
                x=0;
                maxi=max(maxi,sum);
                m--;
            }
            x++;
        }
        if(x>maxn||m<=0)break;
        j++;
        if(j==n+1)j=1;
    }
}
```
核心思想：枚举每个起始位置，用 `f` 数组标记卡片是否被拿走，`x` 为报数器，`sum` 记录当前拿走卡片的和，当报数与卡片数字相等时，更新 `sum` 和 `maxi`，并重置报数器。

- **作者：___w（4星）**
    - **关键亮点**：注释详细，逻辑清晰，使用 `memset` 清空标记数组，便于多次模拟。
    - **核心代码**：
```cpp
for (int s = 1; s <= n; ++s) {
    int x = 1, i = s, sum = 0, cnt = 0;
    memset(v, 0, sizeof(v));
    while (1) {
        if (!v[i]) {
            if (x == a[i]) {
                ++cnt;
                x = 0;
                v[i] = 1;
                sum += a[i];
            }
            ++x;
        }
        if (x > n || cnt == n) break;
        i = i == n? 1 : i+1;
    }
    ans = max(ans, sum);
}
```
核心思想：枚举起始位置，用 `v` 数组标记卡片是否被拿走，`x` 为报数器，`sum` 记录当前拿走卡片的和，`cnt` 记录拿走卡片的数量，当报数与卡片数字相等时，更新相关变量。

- **作者：SSTF2022ywh（4星）**
    - **关键亮点**：代码解释详细，使用数组标记卡片状态，通过循环模拟游戏过程。
    - **核心代码**：
```cpp
for (int i = 0; i < n; i++) {
    int f[n] = {0};
    int x = 1;
    int sum = 0;
    int j = i;
    int m = n;
    while (true) {
        if (f[j] == 0) {
            if (x == a[j]) {
                sum += a[j];
                f[j] = 1;
                x = 0;
                maxi = max(maxi, sum);
                m--;
            }
            x++;
        }
        if (x > maxn || m <= 0) break;
        j++;
        if (j == n) j = 0;
    }
}
```
核心思想：枚举起始位置，用 `f` 数组标记卡片是否被拿走，`x` 为报数器，`sum` 记录当前拿走卡片的和，当报数与卡片数字相等时，更新 `sum` 和 `maxi`，并重置报数器。

### 最优关键思路或技巧
- **枚举起始位置**：通过枚举所有可能的起始卡片位置，确保找到最大值。
- **数组标记**：使用数组标记卡片是否被拿走，避免重复计算。
- **循环模拟**：使用循环模拟数数过程，当报数与卡片数字相等时，更新相关变量。

### 拓展思路
同类型题或类似算法套路：
- 环形数组问题：如环形链表、环形排列等，可使用取模运算处理环形结构。
- 模拟游戏过程：通过模拟游戏的规则和步骤，求解最优解。

### 推荐题目
- [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)
- [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)
- [P1098 字符串的展开](https://www.luogu.com.cn/problem/P1098)

### 个人心得
无

---
处理用时：23.95秒
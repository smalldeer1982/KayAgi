# 题目信息

# [蓝桥杯 2017 省 B] 日期问题

## 题目描述

小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在 1960 年 1 月 1 日至 2059 年 12 月 31 日。令小明头疼的是，这些日期采用的格式非常不统一，有采用`年/月/日`的，有采用`月/日/年`的，还有采用`日/月/年`的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。  

比如 `02/03/04`，可能是 2002 年 03 月 04 日、2004 年 02 月 03 日或 2004 年 03 月 02 日。  

给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？

## 样例 #1

### 输入

```
02/03/04```

### 输出

```
2002-03-04  
2004-02-03  
2004-03-02  ```

# AI分析结果

### 综合分析与结论
这些题解整体思路都是通过枚举法来解决日期匹配问题，由于给定年份范围小，枚举不会超时。主要步骤为枚举所有可能日期，判断是否符合三种日期格式，同时要处理闰年、日期合理性、输出格式、去重和排序等问题。

### 所选题解
- **作者：CleverRaccoon（5星）**
    - **关键亮点**：思路清晰，代码结构简洁，使用数组存储每月天数，通过函数判断闰年，三重循环枚举日期，判断格式条件清晰，输出格式处理得当。
    - **个人心得**：无
    - **核心代码**：
```cpp
const int StartYear = 1960, EndYear = 2059;
int daysOfMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

inline bool isLeapYear(int y) {
    return (y % 4 == 0 && y % 100!= 0) || (y % 400 == 0);
}

int main() {
    int a, b, c;
    scanf("%d/%d/%d", &a, &b, &c);
    for(int year = StartYear; year <= EndYear; ++year) {
        daysOfMonth[2] = (isLeapYear(year)? 29 : 28);
        for(int month = 1; month <= 12; ++month)
            for(int day = 1; day <= daysOfMonth[month]; ++day)
                if((a == year % 100 && b == month && c == day) ||
                   (a == month && b == day && c == year % 100) ||
                   (a == day && b == month && c == year % 100))
                    printf("%d-%02d-%02d\n", year, month, day);
    }
    return 0;
}
```
核心实现思想：先定义起始和结束年份，用数组存储每月天数，通过函数判断闰年并更新二月天数。使用三重循环枚举所有可能日期，根据三种日期格式判断是否匹配，若匹配则按指定格式输出。

- **作者：XIxii（4星）**
    - **关键亮点**：使用结构体存储日期，自定义比较函数进行排序，通过 `check` 函数判断日期合法性，最后去重输出。
    - **个人心得**：提到当年位置是 `00` 以及三个参数相同时要注意去重，打代码时会头疼。
    - **核心代码**：
```cpp
struct node 
{
    int y, m, d;
}p[1001];

int if_run(int x) {
    if(x % 4 == 0 && x % 100!= 0 || x % 400 == 0)
        return 1;
    return 0;
}

bool cmp(node a, node b) {
    if(a.y!= b.y)
        return a.y < b.y;
    if(a.m!= b.m)
        return a.m < b.m;
    return a.d < b.d;
}

void check(int yy, int mm, int dd) {
    int day[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if(yy >= 60)
        yy = 1900 + yy;
    else 
        yy = 2000 + yy;
    if(if_run(yy) == 1)
        day[2]++;
    if(mm > 0 && mm <= 12) {
        if(dd > 0 && dd <= day[mm]) {
            p[t].y = yy;
            p[t].m = mm;
            p[t++].d = dd;
        }
    }
}

int main() {
    string s;
    cin >> s;
    int x1 = (s[0] - '0') * 10 + (s[1] - '0');
    int x2 = (s[3] - '0') * 10 + (s[4] - '0');
    int x3 = (s[6] - '0') * 10 + (s[7] - '0');
    check(x1, x2, x3);
    check(x3, x1, x2);
    check(x3, x2, x1);
    sort(p, p + t, cmp);
    for(int i = 0; i < t; i++) {
        if(i > 0 && p[i].y == p[i - 1].y && p[i].m == p[i - 1].m && p[i].d == p[i - 1].d)
            continue;
        printf("%d-%02d-%02d\n", p[i].y, p[i].m, p[i].d);
    }
    return 0;
}
```
核心实现思想：定义结构体存储日期，通过 `if_run` 函数判断闰年，`check` 函数判断日期合法性并存储合法日期。将三种日期格式传入 `check` 函数，对存储的日期进行排序和去重后输出。

- **作者：Lemonlwl（4星）**
    - **关键亮点**：使用 `set` 存储答案，自动去重和排序，将日期判断封装成函数，提高代码复用性。
    - **个人心得**：无
    - **核心代码**：
```cpp
int mon[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
set<string> s;

void date(int y, int m, int d) {
    if(y >= 60 && y <= 99)
        y += 1900;
    else
        y += 2000;
    if(y % 400 == 0 || (y % 100!= 0 && y % 4 == 0))
        mon[2] = 29;
    if(m >= 1 && m <= 12) {
        if(d >= 1 && d <= mon[m]) {
            char str[1000005];
            sprintf(str, "%d-%02d-%02d\n", y, m, d);
            s.insert(str);
        }
    }
}

int main() {
    int a, b, c;
    scanf("%d/%d/%d", &a, &b, &c);
    date(a, b, c);
    date(c, a, b);
    date(c, b, a);
    set<string>::iterator it2;
    for(it2 = s.begin(); it2!= s.end(); it2++)
        cout << *it2;
    return 0;
}
```
核心实现思想：定义数组存储每月天数，使用 `set` 存储合法日期字符串。`date` 函数将年份补全，判断闰年并更新二月天数，判断日期合法性，若合法则将日期格式化为字符串存入 `set`。将三种日期格式传入 `date` 函数，最后遍历 `set` 输出结果。

### 最优关键思路或技巧
- 使用数组存储每月天数，方便根据闰年情况更新二月天数。
- 封装闰年判断函数，提高代码复用性。
- 利用 `set` 自动去重和排序的特性，简化去重和排序操作。
- 定义结构体存储日期，自定义比较函数进行排序。

### 可拓展之处
同类型题可能会改变日期范围、增加日期格式或加入更多日期限制条件。类似算法套路是通过枚举法遍历所有可能情况，结合条件判断筛选出符合要求的结果，同时要注意处理特殊情况和输出格式。

### 推荐题目
- P1055 [NOIP2008 普及组] ISBN 号码：涉及字符串处理和规则判断。
- P1042 [NOIP2003 普及组] 乒乓球：需要处理比赛数据和按照规则输出结果。
- P1149 [NOIP2008 提高组] 火柴棒等式：需要枚举所有可能的数字组合并判断是否满足等式。

---
处理用时：44.55秒
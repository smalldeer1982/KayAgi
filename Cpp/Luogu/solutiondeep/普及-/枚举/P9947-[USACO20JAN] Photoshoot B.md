# 题目信息

# [USACO20JAN] Photoshoot B

## 题目描述

Farmer John 在给他编号为 $1\ldots N$ 的 $N$ 头奶牛排队拍照（$2\le N\le 10^3$）。FJ 一开始计划从左向右数第 $i$ 个位置排编号为 $a_i$ 的奶牛，他在一张纸上写下了排列 $a_1,a_2,\ldots,a_N$。不幸的是，这张纸刚刚被 Farmer Nhoj 偷走了！

幸好 FJ 仍然有机会恢复他之前写下的排列。在这张纸被偷走之前，Bessie 记录了序列 $b_1,b_2,\ldots,b_{N−1}$，对于每一个 $1\le i<N$ 满足 $b_i=a_i+a_{i+1}$。

基于 Bessie 的信息，帮助 FJ 恢复可以产生序列 $b$
的“字典序最小”的排列 $a$。排列 $x$ 字典序小于排列 $y$，如果对于某个 $j$，对于所有 $i<j$ 均有 $x_i=y_i$，且有 $x_j<y_j$（换句话说，这两个排列到某个位置之前都相同，在这个位置上 $x$ 小于 $y$）。保证存在至少一个满足条件的 $a$。 

## 说明/提示

### 样例解释 1

$a$ 能够产生 $b$，因为 $3+1=4$，$1+5=6$，$5+2=7$，$2+4=6$。

### 测试点性质

 - 测试点 $2-4$ 满足 $N\le 8$。
 - 测试点 $5-10$ 没有额外限制。

## 样例 #1

### 输入

```
5
4 6 7 6```

### 输出

```
3 1 5 2 4```

# AI分析结果

### 综合分析与结论
这些题解的核心思路基本一致，都是通过枚举 $a_1$ 的值，利用 $b_i = a_i + a_{i + 1}$ 的关系递推出整个 $a$ 数组，再检查 $a$ 数组是否满足是 $1$ 到 $n$ 的排列这一条件，一旦找到符合条件的 $a$ 数组就输出，以保证字典序最小。部分题解还进行了小优化，如缩小枚举范围、提前判断不合法情况等。

### 所选题解
- **作者：DFs_YYDS（5星）**
    - **关键亮点**：思路清晰，代码注释详细，对核心递推公式 `a[i]=b[i-1]-a[i-1]` 有重点提示，便于理解。
    - **核心代码**：
```cpp
bool check(int i){//检查函数。 
    bool vis[1005];//vis[i]表示i在构造的数组中是否出现。 
    memset(vis,false,sizeof(vis));//初始化，一开始都没出现。 
    a[1]=i;//第一个数是i。 
    for(int i=2;i<=n;i++){//根据第一个数和b构造整个a数组。 
        a[i]=b[i-1]-a[i-1];//最重要的一行，这行看不懂这题就不会。 
        if(vis[a[i]]/*这个数之前已经出现过了*/ || a[i]>n/*这个数比n大*/ || a[i]<1/*这个数比1小 （虽然数据中应该不会出现，但还是写了保险）*/)return false;//无法构造，返回false。 
        vis[a[i]]=true;//将这个数标记为出现过了。 
    }
    return true;//构造成功，返回true。 
}
```
- **作者：Kle1N（4星）**
    - **关键亮点**：对思路的分析详细，明确指出枚举 $a_1$ 的范围和原因，代码结构清晰。
    - **核心代码**：
```cpp
bool check(){
    for(int i=1;i<=n;i++){
        if(!v[i]){
            return false;
        }
    }
    return true;
}
for(int i=1;i<b[1];i++){
    memset(v,0,sizeof(v));
    v[i]=1;
    a[1]=i;
    f=1;
    for(int j=2;j<=n;j++){
        if(b[j-1]-a[j-1]<=0){
            f=0;
            break;
        }
        a[j]=b[j-1]-a[j-1];
        if(v[a[j]]){
            f=0;
            break;
        }
        v[a[j]]=1;
    }
    if(f && check()){
        break;
    }
}
```
- **作者：2021zjhs005（4星）**
    - **关键亮点**：对解题过程的阐述详细，解释了为什么不用比较字典序，还指出了代码中需要特判的情况。
    - **核心代码**：
```cpp
FOR(i,1,n){
    memset(vis,0,sizeof(vis));
    num[1]=i;vis[i]=1;
    flag=true;
    FOR(j,1,n-1){
        num[j+1]=a[j]-num[j];
        if(num[j+1]<1||num[j+1]>n){//发现有不符合题意的数，需要特判。
            flag=false;break;
        }
        if(vis[num[j+1]]){
            flag=false;break;
        }
        vis[num[j+1]]=1;
    }
    if(flag){
        FOR(i,1,n)
            cout<<num[i]<<" ";
        exit(0);
    }
}
```

### 最优关键思路或技巧
- **枚举与递推结合**：通过枚举 $a_1$ 的值，利用递推公式 $a_{i + 1} = b_i - a_i$ 快速得到整个 $a$ 数组。
- **桶的使用**：用桶来记录 $a$ 数组中每个数字是否出现过，方便判断 $a$ 数组是否是 $1$ 到 $n$ 的排列。
- **提前剪枝**：在递推过程中，若出现 $a_i$ 小于等于 $0$ 或大于 $n$ 或重复的情况，立即停止递推，减少不必要的计算。

### 可拓展之处
同类型题可能会改变条件，如给出相邻三个数的和，或者要求构造的序列满足其他特定条件。类似算法套路是先找出序列的递推关系，再通过枚举部分值来确定整个序列，最后检查序列是否满足条件。

### 推荐题目
- P1149 [NOIP2008 提高组] 火柴棒等式
- P1036 [NOIP2002 普及组] 选数
- P1088 [NOIP2004 普及组] 火星人

### 个人心得摘录与总结
- **作者：2021zjhs005**：提交代码后可能会出现错误，原因是递推过程中可能会出现小于等于 $0$ 或超过 $n$ 的情况，需要进行特判。总结：在编写代码时要考虑边界情况，避免因边界问题导致错误。 

---
处理用时：28.97秒
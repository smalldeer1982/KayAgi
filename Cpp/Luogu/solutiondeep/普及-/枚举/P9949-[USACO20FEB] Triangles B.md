# 题目信息

# [USACO20FEB] Triangles B

## 题目描述

Farmer John 想要给他的奶牛们建造一个三角形牧场。

有 $N$（$3\le N\le 100$）个栅栏柱子分别位于农场的二维平面上不同的点 $(X_1,Y_1)\ldots(X_N,Y_N)$。他可以选择其中三个点组成三角形牧场，只要三角形有一条边与 $x$ 轴平行，且有另一条边与 $y$ 轴平行。

Farmer John 可以围成的牧场的最大面积是多少？保证存在至少一个合法的三角形牧场。 

## 说明/提示

### 样例解释 1

位于点 $(0,0)$、$(1,0)$ 和 $(1,2)$ 的木桩组成了一个面积为 $1$ 的三角形。所以，答案为 $2\cdot 1=2$。只有一个其他的三角形，面积为 $0.5$。

## 样例 #1

### 输入

```
4
0 0
0 1
1 0
1 2```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
本题主要是在给定的点中找出能构成满足条件（一条边与 $x$ 轴平行，另一条边与 $y$ 轴平行）的三角形，并求其最大面积的两倍。各题解主要思路可分为暴力枚举和优化枚举两类：
- **暴力枚举**：通过三重循环枚举所有可能的三个点组合，判断是否满足条件并计算面积取最大值，时间复杂度 $O(n^3)$。
- **优化枚举**：通过预处理找出每个点在同一水平和竖直直线上距离最远的点，从而减少不必要的枚举，将时间复杂度降为 $O(n^2)$ 甚至 $O(n)$。

### 所选题解
- **作者：Cute__yhb（4星）**
    - **关键亮点**：思路清晰，在暴力枚举的基础上进行优化，将时间复杂度降了一维。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int x[105],y[105],n,maxx=0,xmax[105],ymax[105];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>x[i]>>y[i];
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(i==j) continue;
            if(x[i]==x[j]) xmax[i]=max(xmax[i],abs(y[i]-y[j]));
            if(y[i]==y[j]) ymax[i]=max(ymax[i],abs(x[i]-x[j]));
        }
    }
    for(int i=1;i<=n;i++) maxx=max(maxx,xmax[i]*ymax[i]);
    cout<<maxx;
    return 0;
}
```
    - **核心实现思想**：先遍历所有点对，找出每个点在同一 $x$ 轴和同一 $y$ 轴上距离最远的点，分别记录其距离。然后遍历每个点，将其在 $x$ 轴和 $y$ 轴上的最大距离相乘，取最大值即为答案。

- **作者：Eason_cyx（4星）**
    - **关键亮点**：提出了一种 $O(n)$ 的最优解法，通过记录四个数组来快速找到每个点在 $x$ 轴和 $y$ 轴上距离最远的点。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int maxx[20005],minx[20005],maxy[20005],miny[20005],X[105],Y[105];
int main() {
    memset(maxx,-0x3f,sizeof maxx);
    memset(minx,0x3f,sizeof minx);
    memset(maxy,-0x3f,sizeof maxy);
    memset(miny,0x3f,sizeof miny);
    int n; cin >> n;
    for(int i = 1;i <= n;i++) {
        cin >> X[i] >> Y[i];
        X[i] += 10000; Y[i] += 10000;
        maxx[X[i]] = max(maxx[X[i]],Y[i]);
        minx[X[i]] = min(minx[X[i]],Y[i]);
        maxy[Y[i]] = max(maxy[Y[i]],X[i]);
        miny[Y[i]] = min(miny[Y[i]],X[i]);
    }
    int ans = 0;
    for(int i = 1;i <= n;i++) {
        int mxdis_x = max(abs(X[i]-miny[Y[i]]),abs(maxy[Y[i]]-X[i]));
        int mxdis_y = max(abs(Y[i]-minx[X[i]]),abs(maxx[X[i]]-Y[i]));
        ans = max(ans,mxdis_x * mxdis_y);
    }
    cout << ans << endl;
    return 0;
}
```
    - **核心实现思想**：通过四个数组分别记录横坐标为 $i$ 的所有点中纵坐标的最大值和最小值，以及纵坐标为 $i$ 的所有点中横坐标的最大值和最小值。遍历每个点，计算其在 $x$ 轴和 $y$ 轴上距离最远的点的距离，相乘后取最大值即为答案。

### 最优关键思路或技巧
- **优化枚举**：通过预处理找出每个点在同一水平和竖直直线上距离最远的点，避免了重复枚举，降低了时间复杂度。
- **数组记录**：使用数组记录每个横坐标和纵坐标对应的最大、最小值，方便快速查找。

### 可拓展之处
同类型题可考虑增加点的数量或增加其他限制条件，如三角形的面积必须为整数等。类似算法套路可用于解决在二维平面上寻找满足特定条件的图形的问题，如矩形、平行四边形等。

### 推荐题目
- [P1328 生活大爆炸版石头剪刀布](https://www.luogu.com.cn/problem/P1328)：考察枚举和条件判断。
- [P1008 三连击](https://www.luogu.com.cn/problem/P1008)：考察枚举和数字组合。
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：考察枚举和组合数学。

### 个人心得摘录与总结
- **作者：Quartz_Blocks**：最初暴力代码得 $50$ 分，存在数组无序、正负数处理不当、码风不整洁等问题；$90$ 分代码因强制类型转换丢失精度导致 WA；最终通过避免除法解决问题。总结为在处理面积计算时要注意避免小数运算和强制类型转换带来的精度问题。
- **作者：_Deer_Peach_**：最初未注意到合法三角形的条件，只得了 $20$ 分，加上判断条件后通过。总结为做题时要仔细审题，明确题目要求。 

---
处理用时：34.65秒
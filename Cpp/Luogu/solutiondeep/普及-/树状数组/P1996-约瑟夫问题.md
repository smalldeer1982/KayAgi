# 题目信息

# 约瑟夫问题

## 题目描述

$n$ 个人围成一圈，从第一个人开始报数,数到 $m$ 的人出列，再由下一个人重新从 $1$ 开始报数，数到 $m$ 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。

**注意：本题和《深入浅出-基础篇》上例题的表述稍有不同。书上表述是给出淘汰 $n-1$ 名小朋友，而该题是全部出圈。**


## 说明/提示

$1 \le m, n \le 100$


## 样例 #1

### 输入

```
10 3```

### 输出

```
3 6 9 2 7 1 8 5 10 4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕约瑟夫问题展开，解法丰富多样，涵盖模拟、队列、链表、数组模拟链表、树状数组、线段树等多种思路。各解法的核心在于如何高效地模拟报数和出圈过程。
1. **模拟法**：直接按题目规则模拟报数与出圈，使用数组标记人员状态，遍历数组实现报数，报到指定数则标记人员出圈。优点是思路直观，缺点是时间复杂度较高，通常为$O(n^2)$。
2. **队列法**：将人员编号入队，模拟报数时，非出局人员出队再入队，出局人员出队并输出。借助STL队列或手写队列实现，时间复杂度$O(nm)$，代码相对简洁。
3. **链表法**：构建循环链表模拟人员圈，通过指针操作删除出圈节点。虽逻辑较复杂，但删除操作高效，时间复杂度$O(nm)$。
4. **数组模拟链表**：用数组存储每个元素的下一个元素，模拟链表的连接与删除操作，避免指针使用，降低代码复杂度，时间复杂度同样为$O(nm)$。
5. **树状数组和线段树**：适用于大数据范围，通过维护数据结构实现单点修改和区间查询，优化时间复杂度至$O(nlogn)$，但代码实现复杂，理解难度大。

### 所选4星及以上题解
1. **作者：KesdiaelKen (4星)**
    - **关键亮点**：代码简洁，思路清晰，直接按题意模拟。用`visit`数组记录已出队人员，模拟报数过程，巧妙处理边界条件。
    - **核心代码**：
```cpp
#include<cstdio>
using namespace std;
int main()
{
    int n,m,s=0;scanf("%d%d",&n,&m);
    bool visit[200]={0};
    for(int k=0;k<n;k++){
        for(int i=0;i<m;i++){if(++s>n)s=1;if(visit[s])i--;}
        printf("%d ",s);visit[s]=true;
    }
    return 0;
}
```
    - **核心思想**：外循环控制出队人数，内循环模拟报数，若报数超过总人数则从1开始，若当前报数人员已出队则重新报数。
2. **作者：Mickey_snow (4星)**
    - **关键亮点**：采用双向链表模拟，符合命题者期望，逻辑清晰，详细展示链表初始化、节点删除等操作。
    - **核心代码**：
```cpp
struct Peo
{
    int ID;
    Peo *next, *front;
    Peo(){ next = front = nullptr; }
}n[100];

void _Cut(Peo *num)
{
    num = num->front;
    num->next = num->next->next;
    num = num->next;
    num->front = num->front->front;
}

int main()
{
    int tot, outNum, nowNum = 1;
    Peo *now = n;
    cin >> tot >> outNum;

    for (int i = 1; i < tot - 1; i++) { n[i].front = n + i - 1; n[i].next = n + i + 1; n[i].ID = i + 1; }
    n[0].front = n + tot - 1; n[0].next = n + 1; n[tot - 1].front = n + tot - 2; n[tot - 1].next = n;
    n[0].ID = 1; n[tot - 1].ID = tot;

    while (tot > 0) {
        if (nowNum == outNum) {
            cout << now->ID << " ";
            _Cut(now);
            nowNum = 1;
            tot--;
            now = now->next;
        }
        else {
            nowNum++;
            now = now->next;
        }
    }

    return 0;
}
```
    - **核心思想**：构建双向链表并初始化，`_Cut`函数实现节点删除，主循环模拟报数与出圈过程。
3. **作者：yangrunze (4星)**
    - **关键亮点**：提出用数组模拟链表解决约瑟夫问题，详细阐述思路与实现细节，对理解链表操作有帮助。
    - **核心代码**：
```cpp
int next[1000005];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++)
        next[i]=i+1;
    next[n]=1;
    int p=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<m;j++)
            p=next[p];
        cout<<next[p]<<" ";
        next[p]=next[next[p]];
    }
    return 0;
}
```
    - **核心思想**：用`next`数组模拟链表连接关系，通过移动“指针”`p`模拟报数，删除节点时修改`next`数组跳过该节点。

### 最优关键思路或技巧
1. **数据结构选择**：对于小数据范围，可选用简单直观的模拟法、队列法，代码实现容易；大数据范围则考虑树状数组、线段树优化时间复杂度。
2. **数组模拟链表**：用数组存储元素间连接关系，模拟链表操作，避免指针使用，降低代码复杂度，是一种巧妙实现方式。

### 可拓展之处
同类型题常涉及循环结构、元素删除与位置调整，如循环报数、按规则淘汰元素等场景。类似算法套路包括维护数据结构状态、模拟操作过程、优化时间复杂度等。

### 洛谷相似题目推荐
1. **P1996 约瑟夫问题**：经典约瑟夫问题变形，加深对该问题理解。
2. **P2024 [NOI2001] 食物链**：需维护元素间关系，类似链表维护连接关系思路。
3. **P3373 【模板】线段树 2**：强化线段树操作，适用于掌握树状数组和线段树解决约瑟夫问题后拓展练习。

### 个人心得摘录与总结
1. **KesdiaelKen**：强调`visit`数组初始化及报数起始值设置的重要性，编程时易遗漏这些细节导致错误。
2. **Mickey_snow**：指出链表实现虽复杂，但符合命题意图，有助于深入理解链表数据结构及操作。 

---
处理用时：46.79秒
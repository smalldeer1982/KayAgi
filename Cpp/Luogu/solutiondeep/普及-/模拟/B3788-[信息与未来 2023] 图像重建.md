# 题目信息

# [信息与未来 2023] 图像重建

## 题目背景

JWST (詹姆斯·韦伯太空望远镜，James Webb Space Telescope) 是一台红外波段的大型太空望远镜，由美国国家航空航天局 (NASA)、欧洲航天局 (ESA) 和加拿⼤航天局 (CSA) 共同合作开发。它是哈勃太空望远镜的科学继任者，旨在解决⼀系列重要的天文学问题，包括宇宙的起源、星系的形成和演化、恒星和行星系统的形成，以及寻找宜居⾏星和生命迹象。

以下是 JWST 望远镜 5 ⽉ 23 ⽇采集的深空图像：

![](https://cdn.luogu.com.cn/upload/image_hosting/nmcrklbq.png)

## 题目描述

太空望远镜在采集数据时，并不像我们日常生活中的手机或相机 “一次拍摄成像” 直接从传感器数据得到照⽚，而是由多次不同时段拍摄的图像拼接而成。在这个问题中，我们也来实现图像的拼接重建。

我们已经对⼀个区域拍摄了**两张**黑白图像。这两张图像面向同⼀区域拍摄，因此我们预期它们有相当⼀部分都是重叠的。你的任务就是将两张图像经过上下左右平移后尽可能 “重叠” 在⼀起，满⾜重叠部分所有像素均完全相同，且**重叠部分的⾯积尽可能⼤（即重叠部分的像素数量尽可能多）**。

## 说明/提示

对于 $100\%$ 的数据，满足 $1\leq n,m\leq 50$。

>本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
3 3
0 0 0
0 1 1
0 1 1

2 4
1 1 0 0
1 1 0 1```

### 输出

```
4```

# AI分析结果

• 综合分析与结论：这些题解都采用暴力枚举的方法解决图像拼接重建问题，即通过枚举两张图像的相对平移量，计算重叠部分相同像素的数量，并取最大值。算法要点在于如何合理地枚举平移量以及准确判断重叠部分像素是否相同。解决难点主要集中在避免数组越界和正确处理重叠部分所有像素均需完全相同的条件。

  从思路清晰度、代码可读性和优化程度来看，“szh_AK_all”的题解较为突出，不仅清晰阐述了暴力枚举思路，还详细说明了初始作法的错误原因及满分做法的改进之处；“_Joseph_”的题解思路清晰，代码简洁明了；“cuiyuchen”的题解也简洁易懂，直接阐述暴力枚举的做法。

  最优关键思路或技巧：通过双重循环枚举两张图像在横纵方向上的平移量，再通过双重循环遍历重叠部分像素判断是否相同，在判断过程中及时处理不满足条件的情况以减少不必要计算。

  可拓展之处：此类题属于图像匹配问题，类似套路可应用于其他需要在二维空间中寻找最佳匹配位置的场景，例如地图拼接、模板匹配等。

  洛谷相似题目推荐：
    - P1161 开灯
    - P1980 计数问题
    - P1036 选数

  个人心得摘录与总结：“szh_AK_all”提到初始作法因数组越界和未考虑重叠部分像素完全相同的条件而导致评测 RE，经过改进边界判断和增加“开关”变量来处理不满足条件的情况，最终得到满分做法，强调了边界条件和题目要求的重要性。

  所选题解：
    - “szh_AK_all”  星级：5星
      - 关键亮点：详细阐述暴力枚举思路，包括初始错误原因及改进方法，逻辑清晰。
      - 个人心得：“像这样做，我们会发现评测时有三处 RE 了，原因是：数组越界了，在极端情况下，代码中的 `k - i` 会达到 `-49`，而数组无法接受为负数的下标。当然还有一点原因是题目中说‘满足重叠部分所有像素均完全相同’，这是我们没考虑到的一点。”
      - 核心代码：
```c
#include<iostream>
#include<cstring>
using namespace std;
int a[55][55],b[55][55];
int main()
{
    int n1,m1;
    cin>>n1>>m1;
    for(int i=1;i<=n1;i++)
        for(int j=1;j<=m1;j++)
            cin>>a[i][j];
    int n2,m2;
    cin>>n2>>m2;
    for(int i=1;i<=n2;i++)
        for(int j=1;j<=m2;j++)
            cin>>b[i][j];
    int ans=0;
    for(int i=-n1;i<=n1;i++)//枚举
        for(int j=-m1;j<=m1;j++)
        {
            int tmp=0;
            for(int k=1;k<=n1;k++)//判断
            {
                int p=0;//开关
                for(int t=1;t<=m1;t++)
                {
                    if((k+i)>=1&&(k+i)<=n2&&(t+j)>=1&&(t+j)<=m2)//注意：这里应判断(k+i)<=n2而不是n1
                    {
                        if(a[k][t]!=b[k+i][t+j])
                        {
                            p=1;
                            tmp=0;
                            break;//不符合“满⾜重叠部分所有像素均完全相同”这一要求，需退出循环
                        }
                        else
                        tmp++;
                    }
                }
                if(p==1)
                break;//退出循环
            }
            if(tmp>ans)//打擂
                ans=tmp;
        }
    cout<<ans;
    return 0;
}
```
      - 核心实现思想：通过四层循环，前两层枚举第一张图像相对于第二张图像在横纵方向的平移量 `i` 和 `j`，后两层遍历第一张图像的像素，判断在平移后的位置上与第二张图像对应像素是否相同，若有不同则通过“开关”变量 `p` 及时终止当前重叠情况的判断，最后取所有重叠情况中相同像素数量的最大值。

    - “_Joseph_”  星级：4星
      - 关键亮点：思路清晰，代码简洁，利用布尔变量 `f` 及时处理重叠部分像素不同的情况。
      - 核心代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 55;
int n1, n2, m1, m2, res = -0x3f;//第一张图和第二张图的n和m,res是重合的最大值;
bool xy1[N][N], xy2[N][N];//第一张图和第二张图的像素;

int main() {
//读入数据;
	cin >> n1 >> m1;
	for(int i = 1;i <= n1;i++)
		for (int j = 1;j <= m1;j++)
			cin >> xy1[i][j];
	cin >> n2 >> m2;
	for(int i = 1;i <= n2;i++)
		for(int j = 1;j <= m2;j++)
			cin >> xy2[i][j];
//开始暴力枚举;
for(int dx = -n1;dx <= n1;dx++)//枚举x轴移动方向
	for(int dy = -m1;dy <= m1;dy++){//枚举y轴移动方向
	int ans = 0,f = 1;
	for(int i = 1;i <= n2;i++)//扫数组
		for(int j = 1;j <= m2;j++){
		int nx = i + dx,ny = j + dy;
		if(nx > 0 && nx <= n1 && ny > 0 && ny <= m1) {
			if(xy1[nx][ny] == xy2[i][j]) ans++;
			else f = 0;//有不同的直接清零;
		}
	}
	res = max(res, ans * f);
}
cout << res << endl;
	return 0;//完美结束;
}
```
      - 核心实现思想：同样通过四层循环，前两层枚举第二张图像相对于第一张图像在横纵方向的平移量 `dx` 和 `dy`，后两层遍历第二张图像的像素，判断在平移后的位置上与第一张图像对应像素是否相同，若不同则将布尔变量 `f` 置为 `0`，最后通过 `ans * f` 确保只考虑重叠部分像素完全相同的情况，并取所有情况中的最大值。

    - “cuiyuchen”  星级：4星
      - 关键亮点：代码简洁，直接明了地实现暴力枚举思路，利用布尔变量 `flag` 处理重叠部分像素不同的情况。
      - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n1,m1,n2,m2,mans;
bool a1[55][55],a2[55][55]; 
signed main(){
	cin >> n1 >> m1;
	for(int i = 1;i <= n1;i++)
	    for (int j = 1;j <= m1;j++)
	        cin >> a1[i][j];
	cin >> n2 >> m2;
	for(int i = 1;i <= n2;i++)
	    for(int j = 1;j <= m2;j++)
	        cin >> a2[i][j];
	for(int dx = -n1;dx <= n1;dx++)//x轴移动方向
	    for(int dy = -m1;dy <= m1;dy++){//y轴移动方向
	    	int ans = 0;
	    	bool flag = true;
	    	for(int i = 1;i <= n2;i++)//扫数组
	    	    for(int j = 1;j <= m2;j++){
	    	    	int nx = i + dx;
	    	    	int ny = j + dy;
					if(nx > 0 && nx <= n1 && ny > 0 && ny <= m1){
	    	    		if(a1[nx][ny] == a2[i][j])
	    	    		    ans++;
	    	    		else
	    	    		    flag = false;
					}
				}
			mans = max(mans,ans * flag);
		}
	cout << mans << endl;
	return 0;
}
```
      - 核心实现思想：通过四层循环，前两层枚举第二张图像相对于第一张图像在横纵方向的平移量 `dx` 和 `dy`，后两层遍历第二张图像的像素，判断在平移后的位置上与第一张图像对应像素是否相同，若不同则将布尔变量 `flag` 置为 `false`，最后通过 `ans * flag` 确保只考虑重叠部分像素完全相同的情况，并取所有情况中的最大值。 

---
处理用时：59.65秒
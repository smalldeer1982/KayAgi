# 题目信息

# [信息与未来 2015] 分数计数

## 题目描述

有 $n$ 个球队，编号为 $1\sim n$，共进行 $n$ 场比赛，每场比赛有一个胜队。计分方法如下：
- 是连胜中的第一次胜利，则本次胜利得 $1$ 分。
- 是连胜中的第二次胜利，则本次胜利得 $2$ 分。
- 是连胜中的第三次胜利，则本次胜利得 $3$ 分。
- 连胜超过三次以上的胜场，每场得 $3$ 分。

例如 $n=12$，比赛的胜队为 $1,2,1,1,3,2,1,1,1,1,4,2$，计分如下：
- 队 $1$：$1+1+2+1+2+3+3=13$ 分；
- 队 $2$：$1+1+1=3$ 分；
- 队 $3\sim 4$：$1$ 分。
- 队 $5\sim 12$：$0$ 分。

求得分最多的队伍的分数。

## 说明/提示

$1\le x_1\le n\le10^6$。

## 样例 #1

### 输入

```
10 5```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
- **思路**：两道题解思路一致，均先根据给定公式 $x_i = ((x_{i - 1}×3703 + 1047) \bmod n)+1$ 计算出每场比赛的获胜队伍，再通过遍历结果统计各队得分，最后找出得分最高的队伍。
- **算法要点**：利用数组存储比赛结果与各队得分，通过循环遍历与条件判断实现计分逻辑。
- **解决难点**：准确实现连胜计分逻辑，根据连胜场次不同给予不同分数。

### 题解分析
- **作者Dragon_JL**：
  - **星级**：4星
  - **关键亮点**：思路清晰，代码简洁，使用一个 `if - else` 结构简洁地实现连胜计分逻辑，在循环中同步更新当前最大得分。
  - **核心代码**：
```cpp
int cnt = 0;
for (int i = 1; i <= n; i++) {
    if (x[i] == x[i - 1]) { 
        cnt = cnt < 3? cnt + 1 : cnt; 
        s[x[i]] += cnt; 
    } else { 
        cnt = 1;
        s[x[i]] += cnt;
    }
    ans = max(ans, s[x[i]]); 
}
```
  - **核心实现思想**：通过 `cnt` 统计连胜场次以确定得分，若当前队伍连胜，连胜场次小于3则 `cnt` 自增，否则保持3；若不是连胜则 `cnt` 重置为1，每次循环更新该队得分并同步更新最大得分。
- **作者Max_robot**：
  - **星级**：3星
  - **关键亮点**：对连胜情况进行分类讨论，逻辑较为清晰。
  - **核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    if (x[i]!= x[i - 1]) {
        a[x[i]]++;
        cnt = 1;
    } else if (x[i] == x[i - 1] && cnt == 1) {
        a[x[i]] += 2;
        cnt++;
    } else if (x[i] == x[i - 1] && cnt >= 2) {
        a[x[i]] += 3;
        cnt++;
    }
}
for (int i = 1; i <= n; i++)
    ans = max(ans, a[i]);
```
  - **核心实现思想**：分三种情况（一连胜、二连胜、三连胜及多连胜）分别处理计分与连胜场次更新，最后遍历各队得分找出最大值。

### 最优关键思路或技巧
使用一个变量 `cnt` 记录连胜场次，根据当前比赛获胜队伍与上一场是否相同，简洁地更新连胜场次与得分，同时在遍历过程中实时更新最大得分，减少额外遍历操作。

### 可拓展之处
此类题目属于模拟类算法题，常见拓展方向为改变计分规则或比赛结果生成方式。类似套路是根据给定条件模拟过程，利用合适的数据结构存储中间结果，通过循环和条件判断实现逻辑。

### 洛谷相似题目推荐
- [P1035 级数求和](https://www.luogu.com.cn/problem/P1035)：涉及简单的模拟与循环计算。
- [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：通过模拟不同购买方案求解最优解。
- [P5718 三角形分类](https://www.luogu.com.cn/problem/P5718)：根据给定条件模拟判断三角形类型。 

---
处理用时：21.13秒
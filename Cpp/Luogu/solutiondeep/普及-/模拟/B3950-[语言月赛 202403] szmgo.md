# 题目信息

# [语言月赛 202403] szmgo

## 题目背景

本题请参考文字题解。

shinzanmono 想要学习 szm 语，但是 szm 语太难了。

## 题目描述

现代 szm 语采用罗马字表示，其划分音节的规则如下：

- 规定元音是字符 `a`、`e`、`i`、`o`、`u` 之一。
- 一般地，一个音节仅包含一个元音，并且以元音结尾。
- 特别地，当且仅当 `n` 后第一个字符不是元音时，`n` 单独作一个音节。
- 一个音节至多包含 $3$ 个字符。

举个例子，`shinzanmono` 的音节依次为 `shi` `n` `za` `n` `mo` `no`；`naku` 的音节依次为 `na` `ku`。

如果一个字符串是空串或者不能按照以上规则划分，则这个字符串不合法。**题目描述中给出的字符串和测试数据中输入的字符串全部合法，你无需进行合法性检验。**

将字符串 $S$ 的 $k$ 个音节依次表示为 $S'_1 \sim S'_k$，将另一个字符串 $T$ 的 $m$ 个音节依次表示为 $T'_1 \sim T'_m$。

如果存在一个正整数 $p$，满足 $p+m-1 \leq k$ 且对于从 $p$ 到 $p+m-1$ 的每个正整数 $i$ 都有 $S'_i=T'_{i - p + 1}$，那么称 $S$「包含」$T$。

在 szm 语中有一些习语，一种习语对应有一些固定的字符串。如果一个字符串「包含」且仅「包含」一种习语的一个固定子串，那么这个字符串是这种习语，否则这个字符串不是这种习语。

例如，当一种习语对应的子串只有 `ao` 时，字符串 `nao` 不是这种习语，因为 `nao` 的音节依次为 `na` `o`，而 `ao` 的音节依次为 `a` `o`。另一个例子是，如果敬语对应的子串为 `desu` 和 `suma`，那么 `kyuusaidesu` 是敬语，而 `kyuusaidesuma` 和 `kyuusaidema` 不是敬语。

某种习语对应 $n$ 个长度不超过 $10$ 的不同子串，给定 $q$ 个字符串，判断每个字符串是否是这种习语。

## 说明/提示

### 数据规模与约定

对于 $30\%$ 的数据，保证习语对应的所有字符串都没有由单个元音组成的音节。  
对于另外 $30\%$ 的数据，保证习语对应的所有字符串均只包含一个音节。  
对于 $100\%$ 的数据，$1 \leq n \leq 10$，$1 \leq q \leq 10^5$，习语对应的每个子串的长度不超过 $10$ 且两两不同，询问的 $q$ 个字符串的字符个数之和不超过 $5 \times 10^5$，输入的所有字符串均只包含小写字符。

## 样例 #1

### 输入

```
2 4
desu
suma
kyuusaidesu
kyuusaidesuma
kyuusaidema
desudesu
```

### 输出

```
Yes, Commander
No, Commander
No, Commander
Yes, Commander
```

# AI分析结果

### 综合分析与结论
该题主要考查字符串处理，需依据特定音节划分规则判断字符串是否为某种习语。RyanLi的题解思路清晰，针对数据范围选择 `s.find()` 函数查找子串，同时考虑到szm语中音节划分的特殊情况，如单个元音成音节、`n` 单独成音节等，通过编写辅助函数 `vowel` 判断元音，并在匹配时进行细致条件判断，以避免错误匹配。代码实现较为简洁，整体质量较高。

### 所选的题解
- **RyanLi的题解**：★★★★
    - **关键亮点**：思路清晰，针对题目中音节划分的特殊规则，在使用 `s.find()` 查找子串时，通过条件判断有效避免因特殊音节导致的错误匹配，代码简洁且具有可读性。
    - **重点代码**：
```cpp
bool vowel(char c) {
    return c == 'a' || c == 'i' || c == 'u' || c == 'e' || c == 'o';
}
// 主程序部分
cin >> n >> q;
for (int i = 1; i <= n; ++i) cin >> a[i];
while (q--) {
    cnt = 0;
    cin >> s;
    for (int i = 1; i <= n; ++i) {
        pos = s.find(a[i]);
        if (pos == s.npos) continue;
        while (pos!= s.npos) {
            if ((vowel(s[pos]) && pos &&!vowel(s[pos - 1])) || (!vowel(s[pos]) && pos &&!vowel(s[pos - 1]) && s[pos - 1]!= 'n')) {
                pos = s.find(a[i], pos + 1);
                continue;
            } if ((s[pos + a[i].size() - 1] == 'n' && (pos + a[i].size() >= s.size() || (pos + a[i].size() < s.size() &&!vowel(s[pos + a[i].size()])))) || s[pos + a[i].size() - 1]!= 'n') {
                ++cnt;
                break;
            } pos = s.find(a[i], pos + 1);
        }
    } cout << (cnt == 1? "Yes, Commander\n" : "No, Commander\n");
}
```
    - **核心实现思想**：先定义函数 `vowel` 判断字符是否为元音。主程序中，读入习语子串和询问字符串，对每个询问字符串，遍历习语子串，用 `s.find()` 查找子串位置，若找到则根据当前位置字符是否为元音及前一个字符情况，以及匹配子串末尾字符是否为 `n` 及后一个字符情况，判断是否为有效匹配，统计有效匹配子串个数，根据个数判断是否为习语。

### 最优关键思路或技巧
针对特殊的字符串匹配规则，在常规字符串查找函数基础上，结合具体规则对匹配位置进行额外条件判断，避免因规则特殊性导致的错误匹配。通过编写辅助函数简化条件判断逻辑，提高代码可读性和可维护性。

### 可拓展之处
同类型题可涉及更多复杂的字符串匹配规则，如不同语言的音节划分、特定模式匹配等。类似算法套路是在常规字符串匹配算法基础上，根据题目给定的特殊规则，对匹配过程进行细致的条件限制和处理。

### 相似知识点洛谷题目推荐
- [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)：考查字符串查找与匹配，判断单词在文本中出现次数。
- [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)：经典字符串匹配算法，可加深对字符串匹配算法的理解。
- [P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)：涉及字符串查找与去重等操作，锻炼字符串处理能力。 

---
处理用时：27.84秒
# 题目信息

# [GESP202403 五级] 成绩排序

## 题目描述

有 $n$ 名同学，每名同学有语文、数学、英语三科成绩，你需要按照如下规则对所有同学的成绩从高到低排序：

1. 比较总分，高者靠前；
2. 如果总分相同，则比较语文和数学两科的总分，高者靠前；
3. 如果仍相同，则比较语文和数学两科的最高分，高者靠前；
4. 如果仍相同，则二人并列。

你需要输出每位同学的排名，如遇 $x$ 人并列，则他们排名相同，并留空后面的 $x - 1$ 个名次。例如，有 $3$ 名同学并列第 $1$，则后一名同学自动成为第 $4$ 名。

## 说明/提示

- 对 $30\%$ 的数据，$N \leq 100$，且所有同学总分各不相同。
- 对全部的测试数据，保证 $2 \leq N \leq 10^4$，$0 \leq c_i, m_i, e_i \leq 150$。

## 样例 #1

### 输入

```
6
140 140 150
140 149 140
148 141 140
141 148 140
145 145 139
0 0 0```

### 输出

```
1
3
4
4
2
6```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均是利用结构体存储学生成绩信息，并自定义比较函数，依据题目规则对学生成绩进行排序，最后处理排名输出。
1. **思路**：先按总分、语数总分、语数最高分的顺序排序，再处理并列排名，最后按输入顺序输出。
2. **算法要点**：
    - 用结构体存储学生的各科成绩、总分、原始序号等信息。
    - 自定义 `cmp` 函数实现题目要求的排序规则。
    - 遍历排序后的结构体数组，根据与前一个学生成绩的比较结果确定排名。
    - 再次排序或通过其他方式按原始输入顺序输出排名。
3. **解决难点**：处理并列排名情况，确保符合题目中并列时留空名次的要求。多数题解通过在排序后遍历数组，比较当前学生与前一个学生的成绩来确定是否并列，进而确定排名。

综合质量来看，以下题解相对较好：
- **作者：xyx404 (赞：15)**
    - **星级**：4星
    - **关键亮点**：思路清晰简洁，代码结构紧凑。先自定义排序函数完成成绩排序，再遍历数组确定排名，最后按编号复原输出，逻辑连贯，代码可读性较好。
    - **重点代码核心思想**：自定义 `cmp` 函数按规则排序，遍历数组根据成绩比较确定排名，最后用另一比较函数 `cmp1` 按编号升序排序输出。
    ```cpp
    bool cmp(node x,node y){// 排序排名降序 
        if(x.sum!=y.sum)return x.sum>y.sum;// 判断总分
        else{// 如果总分相同 
            if(x.chinese+x.math!=y.chinese+y.math)return x.chinese+x.math>y.chinese+y.math;// 比较语文和数学两科的总分
            else{
                if(max(x.chinese,x.math)!=max(y.chinese,y.math))return max(x.chinese,x.math)>max(y.chinese,y.math);//比较语文和数学两科的最高分
                else{
                    // 并列 
                    return 0;// 可以 return 1 也可以 return 0 
                }
            }
        }
    }
    bool cmp1(node x,node y){// 按编号复原升序 
        return x.bh<y.bh;// 按编号复原 
    }
    int main(){
        cin>>n;
        for(int i=1;i<=n;i++)cin>>stud[i].chinese>>stud[i].math>>stud[i].english,stud[i].sum=stud[i].chinese+stud[i].math+stud[i].english/* 输入并计算总和 */,stud[i].bh=i/* 赋值编号 */; 
        sort(stud+1,stud+1+n,cmp);// 排序排名
        int cnt=1;// 上一个人的排名 
        for(int i=1;i<=n;i++){
            if(stud[i].sum==stud[i-1].sum// 判断总分 
            &&stud[i].chinese+stud[i].math==stud[i-1].chinese+stud[i-1].math// 判断语文和数学两科的总分
            &&max(stud[i].chinese,stud[i].math)==max(stud[i-1].chinese,stud[i-1].math)){// 比较语文和数学两科的最高分
                stud[i].pm=cnt;// 如果都相同那么说明并列 
            }
            else{
                cnt=i;// 将名次赋值为 i 
                stud[i].pm=cnt;// 赋值排名 
            }
        }
        sort(stud+1,stud+1+n,cmp1);// 还原编号 
        for(int i=1;i<=n;i++)cout<<stud[i].pm<<"\n";// 输出排名 
        return 0;
    }
    ```
- **作者：zxy1919810 (赞：8)**
    - **星级**：4星
    - **关键亮点**：详细阐述思路，代码简洁明了。先定义结构体和比较函数完成排序，再遍历处理并列情况，最后通过双重循环按输入序号输出排名，思路和代码实现都较为清晰。
    - **重点代码核心思想**：自定义 `cmp` 函数按规则排序，遍历数组根据成绩比较确定排名，最后通过双重循环找到每个原始序号对应的排名并输出。
    ```cpp
    struct node{
        int m,c,e,number1/*编号*/,number2/*排名*/;
    }a[10009];
    bool cmp(const node&a,const node&b){
        if(a.m+a.e+a.c!=b.m+b.e+b.c) return a.c+a.e+a.m>b.e+b.c+b.m;
        if(a.c+a.m!=b.c+b.m) return a.c+a.m>b.c+b.m;
        return max(a.c,a.m)>max(b.c,b.m);
    }
    int main(){
        cin>>n;
        for(int i=1;i<=n;i++) cin>>a[i].c>>a[i].m>>a[i].e,a[i].number1=i;
        sort(a+1,a+n+1,cmp);
        for(int i=1;i<=n;i++){
            a[i].number2=i;
            if(a[i].m+a[i].e+a[i].c==a[i-1].m+a[i-1].e+a[i-1].c&&a[i].c+a[i].m==a[i-1].c+a[i-1].m&&max(a[i].c,a[i].m)==max(a[i-1].c,a[i-1].m))
                a[i].number2=a[i-1].number2;
        }
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(a[j].number1==i)
                    cout<<a[j].number2<<endl;
        return 0;
    }
    ```
- **作者：iyka (赞：1)**
    - **星级**：4星
    - **关键亮点**：不仅给出代码实现，还详细介绍 `sort` 函数对于数组和结构体的用法，适合初学者理解。按照题目规则自定义排序函数，最后维护输出顺序和并列情况，思路清晰。
    - **重点代码核心思想**：自定义 `compare` 函数按规则排序，再次用 `_compare` 函数维护初始编号顺序，遍历过程中判断并列情况确定排名。
    ```cpp
    bool compare(node x,node y) //题目关键字 
    {
        if(x.tot==y.tot)
        {
            if(x.tot-x.e==y.tot-y.e)
                return max(x.c,x.m)>max(y.c,y.m);
            return x.tot-x.e>y.tot-y.e;
        }
        return x.tot>y.tot;
    }
    bool _compare(node x,node y) //排序维护初始编号 
    {
        return x.idx<y.idx;
    }
    int main()
    {
        cin>>n;
        for(int i=1;i<=n;++i)
            cin>>a[i].c>>a[i].m>>a[i].e, a[i].tot=a[i].c+a[i].m+a[i].e, a[i].idx=i;
        sort(a+1,a+n+1,compare);
        a[1]._idx=1, k=a[1];
        for(int i=2;i<=n;++i)
        {
            if(k.tot==a[i].tot && k.tot-k.e==a[i].tot-a[i].e && max(k.c,k.m)==max(a[i].c,a[i].m))
                a[i]._idx=k._idx;
            else
                a[i]._idx=i, k=a[i];
        }
        sort(a+1,a+n+1,_compare);
        for(int i=1;i<=n;++i)
            cout<<a[i]._idx<<"\n";
        return 0;
    } 
    ```

### 最优关键思路或技巧
1. **数据结构**：使用结构体存储学生的各项成绩信息及原始序号，方便管理和操作。
2. **算法优化**：利用 `sort` 函数结合自定义比较函数，简洁高效地实现复杂排序规则。
3. **代码实现技巧**：在排序后通过遍历数组，对比当前元素与前一个元素的成绩来处理并列排名，逻辑清晰易懂。

### 拓展思路
此类题目属于自定义排序结合特殊排名处理的问题。相似套路包括：先确定数据结构存储相关信息，再根据题目规则精确编写比较函数进行排序，最后处理特殊的输出要求，如按特定顺序输出、处理重复元素的排名等。同类型题可能会改变排序规则、数据规模或输出要求等。

### 相似知识点洛谷题目
1. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：涉及结构体排序和贪心策略，需自定义比较函数确定排序顺序。
2. [P1933 【模板】矩阵乘法](https://www.luogu.com.cn/problem/P1933)：虽然重点在矩阵乘法，但也可结合结构体存储矩阵信息，涉及自定义数据结构的操作。
3. [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)：同样是自定义排序规则的题目，通过合理的排序优化算法复杂度。

### 个人心得摘录
作者 Ravener 详细记录了调试过程中的错误及思考：最初未注意按同学顺序输出排名的要求导致全错，修改后又因未处理好并列排名的留空问题继续出错。最终通过在结构体里增加 `bool` 型变量标记并列情况，成功解决问题。此过程体现了仔细审题和逐步调试解决复杂问题的重要性。 

---
处理用时：65.51秒
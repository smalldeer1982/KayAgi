# 题目信息

# [语言月赛 202405] 最大的和

## 题目描述

小 S 喜欢连在一起的数字，如果这些数字的和很大就更好了。

所以她现在要给你一个 $n$ 行 $n$ 列的网格 $A$，第 $i$ 行第 $j$ 列上填有一个**整数** $A_{i, j}$。

接下来你可以在 $A$ 上任取**一行**、**一列**或**一条与任意对角线平行**且**只经过网格交叉点**的**直线**（注意，不是线段），满足经过至少一个数字，且经过的数字之和最大。

如果对上面的表述有疑惑，请参考**样例解释**辅助理解。

你需要告诉小 S 这个最大的数字之和。

## 说明/提示

### 样例 1 解释

对于样例 $1$，不难看出第 $3$ 行数字之和最大，有 $3 + 3 + 3 = 9$。

### 样例 2 解释

对于样例 $2$，数字之和最大的，满足条件的线如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/3srzjj2n.png?x-oss-process=image)

此时有 $4 + 9 = 13$。

注意，因为要求与对角线平行的直线只能经过**网格交点**，所以并不能出现同时取 $4, 1, 9$ 或同时取 $4, 1, 9, 2$ 这样的情况。

### 样例 $3$ 解释

取某条只经过一个 $-1$ 的直线即为最大。注意，不可以一个数字都不选。

### 样例 $4$ 解释

显然，取斜着的线一定不优，只能选择中间那一行或一列，答案是 $-10 + 99999 - 10 = 99979$。

### 数据范围

对于前 $30 \%$ 的数据，保证 $A_{1, 1}$ 或 $A_{n, n}$ 的值为网格中**唯一的**非负整数。  
对于另 $20 \%$ 的数据，保证**每一行**数字相同，且最后一行中的数字之和为**最大值**。  
对于另 $20 \%$ 的数据，保证**每一行**数字相同，网格中不存在负数。  
对于 $100 \%$ 的数据，保证 $1 \leq n \leq 2 \times 10^3, -10^5 \leq A_{i, j} \leq 10^5$。

## 样例 #1

### 输入

```
3
1 1 1
2 2 2
3 3 3
```

### 输出

```
9
```

## 样例 #2

### 输入

```
3
-1 1 2
4 0 3
1 9 2
```

### 输出

```
13
```

## 样例 #3

### 输入

```
3
-1 -1 -1
-1 -1 -1
-1 -1 -1
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
3
-100 -10 -100
-10 99999 -10
-100 -10 -100
```

### 输出

```
99979
```

# AI分析结果

### 综合分析与结论
该题要求在给定的 \(n \times n\) 方阵中找出一行、一列或与对角线平行的直线上数字和的最大值。各题解思路围绕如何遍历并计算这些行、列、斜线的和，进而得出最大值。主要难点在于如何高效且准确地遍历与对角线平行的直线上的元素。

### 所选的题解
#### ShiRoZeTsu 的题解（5星）
- **关键亮点**：思路清晰，详细解释了如何利用行列差值或和值来枚举与对角线平行的直线，代码实现简洁明了，对每个部分的计算都有详细注释。
- **个人心得**：无

### 重点代码及核心思想
```cpp
// 计算每行的和并更新答案
for(int i = 1; i <= n; i++) {
    res = 0;
    for(int j = 1; j <= n; j++)
        res += a[i][j];
    ans = max(ans, res);
}
// 计算每列的和并更新答案
for(int i = 1; i <= n; i++) {
    res = 0;
    for(int j = 1; j <= n; j++)
        res += a[j][i];
    ans = max(ans, res);
}
// 计算从左上到右下斜线的和并更新答案
for(int i = 1-n; i <= n-1; i++) {
    res = 0;
    for(int j = 1; j <= n; j++)
        if(1 <= j-i && j-i <= n) res += a[j][j-i];
    ans = max(ans, res);
}
// 计算从右上到左下斜线的和并更新答案
for(int i = 2; i <= n+n; i++) {
    res = 0;
    for(int j = 1; j <= n; j++)
        if(1 <= i-j && i-j <= n) res += a[j][i-j];
    ans = max(ans, res);
}
```
核心思想是分别遍历行、列以及两种方向的斜线，计算其元素和并不断更新最大值。对于斜线，利用行列关系的规律进行遍历。

### 最优关键思路或技巧
利用行列差值或和值的规律来枚举与对角线平行的直线，简化了对斜线元素的遍历过程，避免了复杂的几何判断，提高了代码的简洁性和效率。

### 可拓展之处
此类题目属于矩阵遍历与统计问题，类似套路包括利用行列关系遍历矩阵特定区域，拓展方向可以是增加矩阵操作的复杂性，如在满足一定条件下修改矩阵元素后再求最值。

### 相似知识点洛谷题目
- P1161 开灯：涉及矩阵操作与状态统计，通过模拟矩阵元素状态变化求解。
- P1338 末日的传说：与矩阵元素的排列和规律查找相关，锻炼对矩阵元素关系的理解。
- P1909 买铅笔：虽不是矩阵题，但同样是在多种情况中找出最优解，与本题求最大值思路类似。 

---
处理用时：18.25秒
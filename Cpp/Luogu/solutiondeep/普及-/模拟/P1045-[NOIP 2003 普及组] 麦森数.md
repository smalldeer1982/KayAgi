# 题目信息

# [NOIP 2003 普及组] 麦森数

## 题目描述

形如 $2^{P}-1$ 的素数称为麦森数，这时 $P$ 一定也是个素数。但反过来不一定，即如果 $P$ 是个素数，$2^{P}-1$ 不一定也是素数。到 1998 年底，人们已找到了 37 个麦森数。最大的一个是 $P=3021377$，它有 909526 位。麦森数有许多重要应用，它与完全数密切相关。

任务：输入 $P(1000<P<3100000)$，计算 $2^{P}-1$ 的位数和最后 $500$ 位数字（用十进制高精度数表示）


## 说明/提示

**【题目来源】**

NOIP 2003 普及组第四题

## 样例 #1

### 输入

```
1279
```

### 输出

```
386
00000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00000000000000104079321946643990819252403273640855
38615262247266704805319112350403608059673360298012
23944173232418484242161395428100779138356624832346
49081399066056773207629241295093892203457731833496
61583550472959420547689811211693677147548478866962
50138443826029173234888531116082853841658502825560
46662248318909188018470682222031405210266984354887
32958028878050869736186900714720710555703168729087
```

# AI分析结果

这道题主要考查如何计算$2^P - 1$的位数和后500位数字。众多题解思路可总结为：利用对数公式求位数，用高精度乘法结合快速幂或优化的乘法方式求后500位。

1. **思路与算法要点**
    - **求位数**：利用对数性质，$2^P$与$2^P - 1$位数相同，$2^P$位数为$\lceil P \times \log_{10}2 \rceil$ ，C++中可通过`log10`函数计算。
    - **求后500位**
        - **快速幂结合高精乘法**：将快速幂算法与高精度乘法结合，每次乘法只保留后500位，减少计算量。
        - **优化乘法过程**：部分题解采用一次乘$2^k$（如$k = 25, 27, 29, 30, 60$等）的方式减少循环次数；有的使用压位高精，将多位数字合并存储和计算以提高效率。
2. **解决难点**
    - **高精度计算**：由于$P$较大，直接计算$2^P$会导致数据溢出，需使用高精度算法。
    - **优化时间复杂度**：朴素的高精度乘法时间复杂度高，需结合快速幂或优化乘法方式来降低时间复杂度，避免超时。
3. **题解评分**
    - **憧憬未来**：5星。思路清晰，将问题分为求位数和后500位两部分，分别详细阐述原理。代码简洁，对高精乘法和快速幂的实现有详细注释。
    - **ADivT**：4星。全面展示从纯模拟到压位高精，再到快速幂优化的过程，并给出多种代码实现，有助于理解不同优化阶段。但代码整体稍显繁杂。
    - **sqrt_7**：4星。提供不用快速幂的思路，利用每次乘$2^{60}$的方式简化代码，且代码简短，有一定创新性。

### 憧憬未来题解
- **星级**：5星
- **关键亮点**：思路清晰，模块划分明确，对求位数的数学原理阐述详细，代码注释丰富，高精乘法实现巧妙。
```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int f[1001],p,res[1001],sav[1001];//乘法要开两倍长度
void result_1()
{
    memset(sav,0,sizeof(sav));
    for(register int i=1;i<=500;i+=1)
        for(register int j=1;j<=500;j+=1)
            sav[i+j-1]+=res[i]*f[j];//先计算每一位上的值（不进位）
    for(register int i=1;i<=500;i+=1)
    {
        sav[i+1]+=sav[i]/10;//单独处理进位问题，不容易出错
        sav[i]%=10;
    }
    memcpy(res,sav,sizeof(res));//cstring库里的赋值函数，把sav的值赋给res
}
void result_2()//只是在result_1的基础上进行了细微的修改
{
    memset(sav,0,sizeof(sav));
    for(register int i=1;i<=500;i+=1)
        for(register int j=1;j<=500;j+=1)
            sav[i+j-1]+=f[i]*f[j];
    for(register int i=1;i<=500;i+=1)
    {
        sav[i+1]+=sav[i]/10;
        sav[i]%=10;
    }
    memcpy(f,sav,sizeof(f));
}
int main()
{
    scanf("%d",&p);
    printf("%d\n",(int)(log10(2)*p+1));
    res[1]=1;
    f[1]=2;//高精度赋初值
    while(p!=0)//快速幂模板
    {
        if(p%2==1)result_1();
        p/=2;
        result_2();
    }
    res[1]-=1;
    for(register int i=500;i>=1;i-=1)//注意输出格式，50个换一行，第一个不用
        if(i!=500&&i%50==0)printf("\n%d",res[i]);
        else printf("%d",res[i]);
    return 0;
}
```
核心实现思想：`result_1`和`result_2`函数分别实现高精度乘法，在快速幂过程中调用。`main`函数先计算位数，再通过快速幂计算$2^P$的后500位并输出。

### ADivT题解
- **星级**：4星
- **关键亮点**：多种解法对比，从易到难，展示不同优化层次，便于理解优化思路。
```cpp
#include<bits/stdc++.h>

const long long mod=10000000000;

using namespace std;

const int N=1e5+10;

int P, l=1,lb=1;

int a[N]= {},b[N]= {},c[N]={};

int cheng1() {
    memset(c,0,sizeof(c));
    for (int i = 1; i <= l; ++i)   {
        for (int j = 1; j <= lb; ++j) {
            c[i+j-1] += a[i] * b[j];
            c[i+j] += ( c[i+j-1] ) / 10;
            c[i+j-1] %= 10;
        }
    }
    int lc = l + lb;
    while( c[lc] == 0 ) -- lc;
    for(int i = 1;i <= lc; ++i){
        a[i] = c[i];
    }
    return lc>500?500:lc;
}
int cheng2() {
    memset(c,0,sizeof(c));
    for (int i = 1; i <= lb; ++i)   {
        for (int j = 1; j <= lb; ++j) {
            c[i+j-1] += b[i] * b[j];
            c[i+j] += ( c[i+j-1] ) / 10;
            c[i+j-1] %= 10;
        }
    }
    int lc = lb + lb;
    while( c[lc] == 0 ) -- lc;
    for(int i = 1;i <= lc; ++i){
        b[i] = c[i];
    }
    return lc>500?500:lc;
}

void power() {
    while( P ) {
        if( P & 1 ) l = cheng1 ( );
        P >>= 1;
        lb = cheng2 ( );
    }
}

int main() {
//	freopen("mason.in","r",stdin);
//	freopen("mason.out","w",stdout);
    memset( a, 0, sizeof(a));
    memset( a, 0, sizeof(b));
    scanf("%d",&P);
    printf("%d\n",int (P*log10(2.0)+1)); 
    a[1] = 1;
    b[1] = 2;
    power();
    -- a[1];
    for (int i = 500; i >= 1; --i) {
        printf("%d",a[i]);
        if (! ( (i-1) % 50 ) ) printf("\n");
    }
    return 0;
}
```
核心实现思想：`cheng1`和`cheng2`函数实现高精度乘法，`power`函数实现快速幂，在`main`函数中先计算位数，再通过快速幂计算并输出$2^P - 1$的后500位。

### sqrt_7题解
- **星级**：4星
- **关键亮点**：提供非快速幂解法，通过每次乘$2^{60}$减少循环次数，代码简洁。
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
typedef unsigned long long ull;
ull a[501]={1};
int main()
{
	int p;
	cin>>p;
	cout<<(int)(p*log10(2))+1<<endl;//log10才是以十为底的对数
	for(;p>0;p-=60)//每次减掉60次幂
	{
		ull f=0;//进位
		for(int i=0;i<500;i++)
		{
			if(p>60)a[i]<<=60;
			else a[i]<<=p;//如果剩下的不够60了就不要乘60了，乘p
			a[i]+=f;
			f=a[i]/10;
			a[i]%=10;
		}
	}
	a[0]-=1;//千万不要忘记减1，否则你会和我第一次一样WA掉全部
	for(int i=499;i>=0;i--)
	{
		putchar(a[i]+'0');
		if(i%50==0)putchar('\n');
	}
	return 0;
}
```
核心实现思想：在`main`函数中，先计算位数，然后通过循环每次乘$2^{60}$（不足60时乘$2^p$剩余次数）计算$2^P$的后500位，最后减1并输出。

### 最优关键思路与技巧
 - **数学优化**：利用对数性质求位数，避免高精度计算位数，简化问题。
 - **快速幂**：将指数运算复杂度从$O(P)$降为$O(\log P)$ ，结合高精度乘法只保留后500位，减少计算量。
 - **乘法优化**：通过一次乘$2^k$减少乘法次数；压位高精利用数据类型空间合并数位计算，提高效率。

### 拓展与类似算法套路
此类题目属于高精度计算结合数学优化的类型。类似套路有：计算大数幂的特定位数、大数的模运算等。通常先从数学角度简化问题，再用高精度算法实现，可结合快速幂、压位等优化技巧。

### 相似知识点洛谷题目
 - [P1009 阶乘之和](https://www.luogu.com.cn/problem/P1009)：涉及高精度加法和乘法，与本题高精度计算部分类似。
 - [P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)：需要高精度计算斐波那契数列，考查高精度运算和递推思想。
 - [P1601 A+B Problem（高精）](https://www.luogu.com.cn/problem/P1601)：基础的高精度加法题目，可作为高精度算法入门练习。

### 个人心得摘录与总结
 - **sqrt_7**：“千万不要忘记减1，否则你会和我第一次一样WA掉全部”，强调了题目细节的重要性，在实现过程中对$2^P - 1$的减1操作不可遗漏。
 - **pikabi**：分享从最初压位尝试到发现计算500位外数字导致TLE，最终优化通过的调试经历，体现了调试过程中对问题逐步分析和解决的思路。 

---
处理用时：113.15秒
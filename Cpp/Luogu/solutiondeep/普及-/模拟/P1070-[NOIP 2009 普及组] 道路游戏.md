# 题目信息

# [NOIP 2009 普及组] 道路游戏

## 题目描述

小新正在玩一个简单的电脑游戏。

游戏中有一条环形马路，马路上有 $n$ 个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这 $n$ 个机器人工厂编号为 $1\sim n$，因为马路是环形的，所以第 $n$ 个机器人工厂和第 $1$ 个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这 $n$ 段马路也编号为 $1\sim n$，并规定第 $i$ 段马路连接第 $i$ 个机器人工厂和第 $i+1$ 个机器人工厂（$1\le i\le n-1$），第 $n$ 段马路连接第 $n$ 个机器人工厂和第 $1$ 个机器人工厂。

游戏过程中，每个单位时间内，每段马路上都会出现一些金币，金币的数量会随着时间发生变化，即不同单位时间内同一段马路上出现的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在 $i$（$1\le i\le n$）号机器人工厂购买了一个机器人，这个机器人会从 $i$ 号机器人工厂开始，顺时针在马路上行走，第一次行走会经过 $i$ 号马路，到达 $i+1$ 号机器人工厂（如果 $i=n$，机器人会到达第 $1$ 个机器人工厂），并将 $i$ 号马路上的所有金币收集给小新。游戏中，环形马路上不能同时存在 $2$ 个或者 $2$ 个以上的机器人，并且每个机器人最多能够在环形马路上行走 $p$ 次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为 $1\sim p$ 之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。

以下是游戏的一些补充说明：

1. 游戏从小新第一次购买机器人开始计时。
2. 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。
3. 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。
4. 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。
5. 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。

现在已知每段马路上每个单位时间内出现的金币数量和在每个机器人工厂购买机器人需要的花费，请你告诉小新，经过 $m$ 个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。


## 说明/提示

对于 $40\%$ 的数据，$2\le n\le 40$，$1\le m\le 40$。

对于 $90\%$ 的数据，$2\le n\le 200$，$1\le m\le 200$。

对于 $100\%$ 的数据，$2\le n\le 1000$，$1\le m\le 1000$，$1\le p\le m$。

NOIP 2009 普及组 第四题


## 样例 #1

### 输入

```
2 3 2 
1 2 3 
2 3 4 
1 2```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕动态规划（DP）算法，部分涉及单调队列优化以降低时间复杂度。思路上，大多通过定义合适的状态转移方程求解。难点在于处理环形马路结构、机器人行走步数限制及金币收集策略。不同题解在状态定义、转移方程推导及优化方式上各有特点。

### 所选的题解
- **作者：ButterflyDew (5星)**
    - **关键亮点**：思路清晰，从初始版DP方程逐步优化，详细阐述状态转移及前缀和处理，还介绍单调队列优化方法，代码注释详细。
    - **个人心得**：“写这个题真是累啊，好毒。应该练练处理比较麻烦的DP。” 感慨题目难度，强调处理复杂DP问题的练习重要性。
    - **重点代码 - 单调队列优化**：
```cpp
#include <cstdio>
#include <cstring>
const int N=1010;
int max(int x,int y){return x>y?x:y;}
int n,m,p;
int f[N][N],cost[N],q[N][N],loc[N][N],l[N],r[N],add[N],dp[N];
int get(int i,int j)//获取单队编号
{
    return ((j-i)%n+n)%n;
}
int main()
{
    scanf("%d%d%d",&n,&m,&p);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&f[j][i]);
            f[j][i]+=f[j-1][i-1];
        }
    for(int i=0;i<n;i++)
    {
        scanf("%d",cost+i);
        q[i][++r[i]]=-cost[i],l[i]++;
    }
    memset(dp,-0x3f,sizeof(dp));
    dp[0]=0;
    for(int i=1;i<=m;i++)
    {
        for(int j=0;j<n;j++)
        {
            int id=get(i,j);
            while(l[id]<=r[id]&&loc[id][l[id]]+p<i) l[id]++;
            if(!j) add[id]+=f[i][n];
            if(l[id]<=r[id])
                dp[i]=max(dp[i],q[id][l[id]]+add[id]+f[i][j]);
        }
        for(int j=0;j<n;j++)
        {
            int id=get(i,j);
            int tmp=dp[i]-add[id]-f[i][j]-cost[j];
            while(l[id]<=r[id]&&q[id][r[id]]<=tmp)
                r[id]--;
            loc[id][++r[id]]=i;
            q[id][r[id]]=tmp;
        }
    }
    printf("%d\n",dp[m]);
    return 0;
}
```
核心思想：通过将工厂实际编号和时间减1简化前缀和查询，定义转移方程并维护q数组记录状态，利用单调队列优化求最大值过程。

- **作者：gorokokoro (4星)**
    - **关键亮点**：同样采用DP结合单调队列优化，状态表示简洁，转移方程推导清晰，代码实现规范，对单调队列操作封装成函数，增强可读性。
    - **重点代码 - 单调队列优化**：
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <utility>
#define N 1020
#define INFINITE 999999999
using namespace std;

class Queue
{
private:
    pair<int, int> f[N];
    int l, r;

public:
    Queue() : l(0), r(0)
    {
        return;
    }

    bool Empty(void)
    {
        return l == r;
    }

    pair<int, int> Back (void)
    {
        return f[r - 1];
    }

    pair<int, int> Front(void)
    {
        return f[l    ];
    }

    void Push_Back(pair<int, int> x)
    {
        f[r ++] = x;

        return;
    }

    void Pop_Back (void)
    {
        r --;

        return;
    }

    void Pop_Front(void)
    {
        l ++;

        return;
    }
};

int n, a[N];
int f[N], g[N][N];
Queue q[N];

void PushOrder(Queue &q, int x, int p)
{
    while(!q.Empty() && q.Back().first <= x)
        q.Pop_Back();
    q.Push_Back(make_pair(x, p));

    return;
}

void PopOrder(Queue &q, int p)
{
    if(q.Front().second <= p)
        q.Pop_Front();
    
    return;
}

int MaxOrder(Queue &q)
{
    return q.Front().first;
}


int Reload(int x, int k)
{
    return ((x - k) % n + n) % n;
}

int main()
{
    int m, p;
    int i, j;

    scanf("%d %d %d", &n, &m, &p);
    for(i = 0;i < n;i ++)
        for(j = 1;j <= m;j ++)
            scanf("%d", &g[i][j]);
    for(i = 0;i < n;i ++)
        scanf("%d", &a[i]);

    for(j = 2;j <= m;j ++)
        for(i = 0;i < n;i ++)
            g[i][j] += g[(i - 1 + n) % n][j - 1];

    for(i = 0;i < n;i ++)
        PushOrder(q[Reload(i, -1)], -a[i], 0);

    for(i = 1;i <= m;i ++)
    {
        for(j = 0, f[i] = -INFINITE;j < n;j ++)
            f[i] = max(f[i], MaxOrder(q[Reload(j, i - 1)]) + g[Reload(j, 1)][i]);

        for(j = 0;j < n;j ++)
        {
            PopOrder (q[Reload(j, i - 1)], i - p);
            PushOrder(q[Reload(j, i - 1)], f[i] - g[Reload(j, 1)][i] - a[j], i);
        }
    }
    cout << f[m] << endl;

    return 0;
}
```
核心思想：定义f数组表示到时间i的最多金钱，通过转移方程变形，利用n个单调队列维护斜线上元素最大值。

### 最优关键思路或技巧
- **状态定义优化**：部分题解将状态定义为一维，如dp[i]表示时间i的最大答案，减少维度简化方程与计算。
- **前缀和优化**：通过预处理前缀和，快速计算特定区间金币总数，降低时间复杂度。
- **单调队列优化**：利用单调队列维护滑动区间最大值，将$O(n^3)$时间复杂度优化到$O(n^2)$ 或 $O(n^2logn)$。

### 可拓展思路
此类题目属于动态规划在具有环形结构和复杂条件限制场景下的应用。类似套路包括分析状态转移关系、利用数据结构优化转移过程。同类型题如涉及资源分配、路径规划且有条件限制的动态规划问题。

### 相似知识点洛谷题目
- [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)：经典滑动窗口问题，可用于练习单调队列优化技巧。
- [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)：树状动态规划，与本题类似，需合理定义状态与转移方程。
- [P3216 [HNOI2011]数学作业](https://www.luogu.com.cn/problem/P3216)：通过状态压缩和矩阵快速幂优化动态规划，锻炼复杂DP问题解决能力。 

---
处理用时：56.35秒
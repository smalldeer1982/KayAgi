# 题目信息

# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# AI分析结果

• 综合分析与结论：这些题解思路基本一致，均是先通过给定的加密信息和原信息构建密码映射关系，再判断该映射是否合法（是否满足不同字母对应不同密字、所有字母是否都出现等条件），最后根据合法的映射翻译新的加密信息。算法要点在于利用合适的数据结构（如map、数组等）记录映射关系，难点主要是判断映射是否存在矛盾以及所有字母是否都参与了映射。不同题解在实现细节和代码风格上有所差异。

所选的题解：
  - **作者：CYJian (5星)**
    - **关键亮点**：代码简洁明了，通过宏定义简化判错操作，逻辑清晰，先进行长度判断，再构建映射并实时判错，最后根据结果输出或报错。
    - **重点代码**：核心代码如下，利用map记录映射关系，在遍历过程中进行合法性判断。
```cpp
map<char,char>mp,mq;
int main(){
    int la,lb,lc,book=26;
    char a[10005],b[10005],c[10005];
    scanf("%s%s%s",&a,&b,&c);
    la=strlen(a); lb=strlen(b); lc=strlen(c);
    if(la!=lb||la<26) ERROR
    for(int i=0;i<la;i++)
        if(mp[a[i]]==0&&mq[b[i]]==0)
            mp[a[i]]=b[i], mq[b[i]]=a[i], book--;
        else if(mp[a[i]]!=b[i]||mq[b[i]]!=a[i])
            ERROR
    if(book>0) ERROR
    for(int i=0;i<lc;i++) printf("%c",mp[c[i]]);
    printf("\n");
    return 0;
}
```
  - **作者：陈嘉逸2012 (4星)**
    - **关键亮点**：思路清晰，先利用map整理“密码本”，同时用另一个map记录已出现的字符，遍历完成后再检查所有字母是否都出现，代码结构分明。
    - **重点代码**：
```cpp
string a,b,c;
map<char,char>mp;map<char,bool>vis;
int main(){
    cin>>a>>b>>c;
    for(int i=0;i<a.size();i++){
        if(vis[b[i]]&&b[i]!=mp[a[i]]){cout<<"Failed\n";return 0;}
        mp[a[i]]=b[i],vis[b[i]]=1;
    }
    for(char i='A';i<='Z';i++){
        if(!vis[i]){cout<<"Failed\n";return 0;}
    }
    for(int i=0;i<c.size();i++) cout<<mp[c[i]];
}
```
  - **作者：qhr2023 (4星)**
    - **关键亮点**：采用字符数组和简单的标记数组实现映射和判断，代码简洁高效，直接在遍历过程中完成映射和合法性检查。
    - **重点代码**：
```cpp
char a[105], b[105], c[105], mp[205], vis[205];
int main(){
    cin >> a >> b >> c;
    int la=strlen(a), lc=strlen(c);
    for (int i=0; i<la; mp[a[i]]=b[i], vis[b[i]]=1, i++) 
        if (vis[b[i]]&&b[i]!=mp[a[i]]) {
            puts("Failed");
            return 0;
        }
    for (int i='A'; i<='Z'; i++)
        if (!vis[i]) {
            puts("Failed");
            return 0;
        } 
    for (int i=0; i<lc; i++)
        cout << mp[c[i]];
    return 0;
}
```

最优关键思路或技巧：利用map或数组记录字符的映射关系，在构建映射的过程中实时检查是否存在矛盾（如一个密文对应多个原文），构建完成后检查所有字母是否都参与了映射。

可拓展之处：此类题目属于字符串模拟和映射关系处理类型，类似套路可用于其他字符替换、密码破译等场景，关键是处理好字符间的对应关系和合法性判断。

推荐题目：
  - P1255 数楼梯
  - P1909 买铅笔
  - P1035 [NOIP2002 普及组] 级数求和 

---
处理用时：30.33秒
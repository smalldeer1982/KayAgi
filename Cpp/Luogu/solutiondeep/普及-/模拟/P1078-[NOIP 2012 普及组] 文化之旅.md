# 题目信息

# [NOIP 2012 普及组] 文化之旅

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。由于测试数据过水，可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）。本题题目和数据仅供参考。本题不接受添加 hack 数据。

本题为错题。**不建议尝试或提交本题。**[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。

现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。


## 说明/提示

输入输出样例说明$1$

由于到国家 $2$ 必须要经过国家$ 1$，而国家$ 2 $的文明却排斥国家 $1$ 的文明，所以不可能到达国家 $2$。


输入输出样例说明$2$

路线为$ 1$ ->$ 2$

【数据范围】

对于 100%的数据，有$ 2≤N≤100$

$1≤K≤100$ 

$1≤M≤N^2$

$1≤k_i≤K$

$1≤u, v≤N$ 

$1≤d≤1000,S≠T,1≤S,T≤N$

NOIP 2012 普及组 第四题


## 样例 #1

### 输入

```
2 2 1 1 2 
1 2 
0 1 
1 0 
1 2 10 
```

### 输出

```
-1```

## 样例 #2

### 输入

```
2 2 1 1 2 
1 2 
0 1 
0 0 
1 2 10 ```

### 输出

```
10```

# AI分析结果

这道题要求在考虑文化排斥和不重复学习文化的条件下，求从起点到终点的最短路径。各题解思路、要点及难点对比如下：
1. **Created_equal1**：
    - **思路**：先通过SPFA算法求出无视文化排斥的最短路，再利用深度优先搜索（DFS），结合剪枝策略寻找满足条件的最短路径。
    - **算法要点**：用邻接表存储图，SPFA求最短路，DFS进行搜索，并在搜索中利用最短路结果剪枝。
    - **解决难点**：通过剪枝减少不必要搜索，利用最短路作为剪枝条件，缩小搜索空间。
2. **wjyyy**：
    - **思路**：采用Floyd算法求最短路，在插点过程中对经过的文化进行标记，并通过条件判断处理文化排斥和重复问题。
    - **算法要点**：Floyd算法框架，在更新最短路时对文化标记数组进行处理。
    - **解决难点**：在Floyd算法的插点过程中巧妙处理文化相关的判断和标记更新。
3. **赵晨洋**：
    - **思路**：深搜（DFS）结合倒着跑的SPFA算法进行最优解剪枝。
    - **算法要点**：邻接表存图，SPFA求反向最短路，DFS搜索并利用最短路剪枝。
    - **解决难点**：利用反向最短路对DFS进行剪枝，减少搜索量。
4. **fishfree88**：
    - **思路**：DFS加剪枝。输入时取国家间最短路径，搜索时用数组记录已学文化，通过比较当前距离和到达该点最短距离剪枝。
    - **算法要点**：DFS搜索框架，输入时预处理路径，剪枝条件设置。
    - **解决难点**：合理设置剪枝条件，减少搜索分支。
5. **tommymio**：
    - **思路**：Dijkstra算法求最短路，用前继数组记录路径，每次松弛前判断下一个点文化与已走过点文化是否冲突。
    - **算法要点**：Dijkstra算法结合优先队列优化，文化冲突判断函数。
    - **解决难点**：在Dijkstra算法过程中实时判断文化冲突。
6. **Charles_with_wkc**：
    - **思路**：Dijkstra算法，用结构体封装信息，记录已使用文化，在算法过程中根据文化排斥和已用文化进行判断。
    - **算法要点**：Dijkstra算法实现，结构体设计及文化标记处理。
    - **解决难点**：通过结构体封装文化使用信息，并在算法中合理应用。
7. **yedalong**：
    - **思路**：深搜，用数组标记国家能否走，通过记忆化和删除重复边优化。
    - **算法要点**：DFS搜索，标记数组使用，优化策略实现。
    - **解决难点**：优化深搜防止超时，注意标记数组的正确更新。
8. **_Weslie_**：
    - **思路**：Dijkstra算法，加入数组记录文化是否可遍历，在算法中根据文化情况更新标记。
    - **算法要点**：Dijkstra算法结合优先队列，文化遍历标记数组的更新。
    - **解决难点**：正确更新文化遍历标记数组，保证算法符合题目条件。
9. **Little_duck_GGG**：
    - **思路**：先用Floyd处理文化排斥关系，再用深搜结合距离比较寻找最短路径。
    - **算法要点**：Floyd算法处理文化关系，DFS搜索及距离更新。
    - **解决难点**：利用Floyd处理文化排斥，在DFS中合理更新距离。

综合来看，各题解质量参差不齐，以下为简要评分：
1. **Created_equal1**：★★★★ 思路清晰，代码实现完整，剪枝策略有效。
2. **wjyyy**：★★★ 利用Floyd算法有独特性，但代码注释可更详细。
3. **赵晨洋**：★★★ 思路常规，代码实现有一定可读性。
4. **fishfree88**：★★★ 剪枝思路合理，但代码结构稍显简单。
5. **tommymio**：★★★★ 思路清晰，代码实现较规范，利用Dijkstra结合判断。
6. **Charles_with_wkc**：★★★ 代码实现有一定问题，未过样例却AC，思路有借鉴处。
7. **yedalong**：★★★ 优化思路可借鉴，但代码注释较少。
8. **_Weslie_**：★★★ 思路常规，代码实现较详细。
9. **Little_duck_GGG**：★★★ 结合Floyd和DFS思路可理解，但代码较乱。

评分较高（≥4星）的题解：
1. **Created_equal1**：
    - **星级**：★★★★
    - **关键亮点**：先求无视文化排斥最短路，为搜索提供强剪枝条件，减少搜索空间，提高效率。
    - **重点代码**：
```cpp
// SPFA求最短路
void Spfa()
{
    memset(Dist, 0X7F, sizeof(Dist));
    queue<unsigned int> Q;
    Q.push(S);
    In_Q[S] = true;
    Dist[S] = 0;
    unsigned int Top;
    while (Q.size())
    {
        Top = Q.front();
        Q.pop();
        In_Q[Top] = false;
        for (size_t i = Head[Top];i;i = Next[i])
            if (Dist[To[i]] > Dist[Top] + Weight[i])
            {
                Dist[To[i]] = Dist[Top] + Weight[i];
                if (!In_Q[To[i]])
                {
                    In_Q[To[i]] = true;
                    Q.push(To[i]);
                }
            }
    }
}
// DFS搜索
void Dfs(const size_t &Now, const unsigned int &D)
{
    Went[Now] = true;
    culture.insert(C[Now]);
    if (Now == S)
    {
        Ans = min(Ans, D);
        return;
    }
    if (D + Dist[Now] > Ans)
        return;
    for (size_t i = Head[Now];i;i = Next[i])
        if (!Went[To[i]] && check(C[To[i]]))
            Dfs(To[i], D + Weight[i]);
    Went[Now] = false;
    culture.erase(C[Now]);
}
```
2. **tommymio**：
    - **星级**：★★★★
    - **关键亮点**：利用Dijkstra算法结合前继数组记录路径，在松弛前判断文化冲突，思路清晰，代码规范。
    - **重点代码**：
```cpp
// 判断能否走
bool judge(int u,int v){
    int tmp=u;
    while(tmp){
        if(a[c[v]][c[tmp]]!=0||c[v]==c[tmp]){
            return false;
        }
        tmp=pre[tmp];
    }
    return true;
}
// Dijkstra算法
void dijistra(int u){
    memset(dis,127/3,sizeof(dis));
    dis[u]=0;
    Q.push(make_pair(0,u));
    while(Q.size()){
        int k=Q.top().second;
        Q.pop();
        if(vis[k])	continue;
        vis[k]=1;
        for(int i=head[k];i;i=e[i].next){
            if(dis[e[i].to]>dis[k]+e[i].val&&judge(k,e[i].to)){
                pre[e[i].to]=k;
                dis[e[i].to]=dis[k]+e[i].val;
                Q.push(make_pair(dis[e[i].to],e[i].to));
            }
        }
    }
}
```

最优关键思路或技巧：
1. **剪枝策略**：如Created_equal1利用无视文化排斥的最短路进行剪枝，在搜索过程中减少不必要的分支，提高算法效率。
2. **结合图算法与条件判断**：像tommymio在Dijkstra算法松弛操作前，结合文化冲突条件进行判断，保证找到的路径满足题目要求。

可拓展之处：此类题属于带限制条件的最短路问题，类似套路是先确定基本的图算法（如Dijkstra、Floyd、SPFA等），再根据具体限制条件（如文化排斥、资源限制等）在算法过程中加入相应判断或处理。

推荐洛谷题目：
1. **P3371 【模板】单源最短路径（弱化版）**：基础的单源最短路问题，可巩固Dijkstra、SPFA等算法基础。
2. **P1119 灾后重建**：带时间限制的最短路问题，与本题类似，需在最短路算法中结合时间条件进行处理。
3. **P4779 【模板】单源最短路径（标准版）**：更复杂的单源最短路问题，可进一步提升对最短路算法的应用能力。

个人心得摘录及总结：
1. **yedalong**：在做标记时不能直接赋值，需加1或减1，否则回溯时会覆盖标记，调了一个多小时。总结为在回溯算法中处理标记数组时要注意其更新方式，避免因简单赋值导致信息丢失。 

---
处理用时：68.18秒
# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果

### 综合分析与结论
这些题解均围绕在限定时间内按花生数量从大到小采摘花生并计算最多采摘量的问题。思路上都遵循题目要求，先确定花生位置和数量，再按数量排序，模拟采摘过程并判断能否在规定时间内完成采摘。算法要点主要涉及数据存储（如结构体、稀松矩阵、map等）、排序（如sort、priority_queue、TreeMap等）以及利用曼哈顿距离计算移动时间。解决难点在于准确处理采摘时间、移动时间和剩余时间的关系，以及对特殊情况（如第一次采摘、无法采摘等）的判断。

### 所选题解
1. **作者：jiangXxin（5星）**
    - **关键亮点**：思路清晰，代码简洁，注释详尽。利用结构体存储花生位置和数量，通过sort排序，使用曼哈顿距离计算移动时间，逻辑连贯，易于理解。
    - **个人心得**：原本想用BFS，发现花生地无障碍物后改用曼哈顿距离，体现对算法选择的灵活应变。
    - **核心代码**：
```cpp
struct dire//记忆花生地址 
{
    int x,y,sum;
}stu[N*N];
bool comp(struct dire a,struct dire b)//比较，大的在前，小的在后 
{
    return a.sum>b.sum;
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>mp[i][j];
            if(mp[i][j]>0)
            {
                stu[++pn].sum=mp[i][j];
                stu[pn].x=i;
                stu[pn].y=j;
            }
        }
    }
    sort(stu+1,stu+pn+1,comp);
    fx=1;
    fy=stu[1].y;
    k--;
    for(int i=1;i<=pn;i++)
    {
        tm=0;
        ex=stu[i].x;
        ey=stu[i].y;
        tm=abs(fx-ex)+abs(fy-ey);
        k--;
        k-=tm;
        if(k>=ex)
        {
            ans+=mp[ex][ey];
            fx=ex;
            fy=ey;
        }
        else
        {
            cout<<ans<<endl;
            return 0;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
    - **核心思想**：先将有花生的位置和数量存入结构体数组，排序后，按顺序计算前往每个花生植株的曼哈顿距离及采摘和返回所需时间，判断是否能在剩余时间内完成采摘，若能则更新位置和答案，否则输出当前答案。
2. **作者：_Arahc_（4星）**
    - **关键亮点**：采用map和priority_queue简化数据处理和排序过程，代码实现较为简洁高效。同时详细指出题目中的多个坑点，对读者有很好的提示作用。
    - **个人心得**：详细列举题目坑点，如采摘耗时、抄近道限制、数组大小等，帮助读者避免错误。
    - **核心代码**：
```cpp
int n,m,k,a[23][23],w,s;
map<int,pair<int,int> >c; //绑定数量和坐标
priority_queue<int> q;	//存花生数量的大根堆

int main(){
    n=read(),m=read(),k=read();
    for(register int i=1;i<=n;++i) for(register int j=1;j<=m;++j){
        a[i][j]=read();
        c[a[i][j]]=make_pair(i,j);
        q.push(a[i][j]);
    }

    int j=q.top();q.pop();
    int x=c[j].first;
    int y=c[j].second;
    w+=x+1;

    while(w+x<=k){
        s+=j;
        if(q.empty()) break;
        j=q.top();q.pop();
        w+=abs(c[j].first-x)+abs(c[j].second-y)+1;
        x=c[j].first,y=c[j].second;
    }
    write(s);
    return 0;
}
```
    - **核心思想**：输入时用map绑定花生数量和坐标，用priority_queue实现大根堆排序。每次取出堆顶花生数量，通过map获取坐标，判断能否采摘，若能则更新时间和答案，继续处理下一个花生。
3. **作者：buickboy（4星）**
    - **关键亮点**：提出“降维大法”，通过结构体实现二维数组降维排序，简化数据处理。同时对判断能否采摘的条件分析细致，对特殊情况处理得当。
    - **核心代码**：
```cpp
struct pea{
    int a,b,s;
}p[600];
bool cmp(pea x,pea y){
    return x.s>y.s;
}
int main()
{
    int m,n,k,i,j,r=0,t,ans=0;
    scanf("%d%d%d",&m,&n,&k);
    for(i=1;i<=m;++i)
    for(j=1;j<=n;++j)
    {
        ++r;
        scanf("%d",&p[r].s);
        p[r].a=i,p[r].b=j;
    }
    sort(p+1,p+1+r,cmp);
    if(k>=1+2*p[1].a)
        k-=p[1].a+1,ans+=p[1].s;
    else {printf("0");return 0;}
    for(i=1;i<r;++i)
    {
        t=abs(p[i].a-p[i+1].a)+abs(p[i].b-p[i+1].b);
        if(k>=t+1+p[i+1].a)
            k-=t+1,ans+=p[i+1].s;
        else break;
    }
    printf("%d",ans);
    return 0;
}
```
    - **核心思想**：将二维数组的花生信息降维存储在结构体数组中并排序。先判断第一次采摘是否可行，然后在循环中依次判断能否前往下一株花生并采摘返回，更新剩余时间和采摘总数。

### 最优关键思路或技巧
1. **数据结构选择**：利用结构体存储花生位置和数量便于整体操作和排序；使用map和priority_queue组合可简化数据绑定和排序过程。
2. **算法优化**：采用曼哈顿距离计算移动时间，符合题目规则且计算简单高效。
3. **代码实现技巧**：对特殊情况（如第一次采摘、无法采摘等）进行单独判断处理，使代码逻辑更严谨。

### 可拓展思路
此类题目属于模拟与贪心结合的问题，类似套路是先对数据按某种规则排序，再模拟操作过程并依据条件进行判断和决策。同类型题可考虑在不同场景下按特定顺序执行操作并计算最优结果的问题。

### 推荐题目
1. **P1090 [NOIP2004 提高组] 合并果子**：通过贪心策略选择合并方案，计算最小总代价，与本题按规则选择采摘顺序类似。
2. **P1199 [NOIP2010 普及组] 三国游戏**：涉及策略选择和判断，与本题在模拟过程中进行条件判断的思路有相似之处。
3. **P1080 [NOIP2012 提高组] 国王游戏**：通过排序和贪心策略求解最大收益，与本题按花生数量排序并决策采摘过程类似。

### 个人心得摘录与总结
1. **jiangXxin**：做题时灵活调整算法，根据题目特点从BFS改用曼哈顿距离，启示在解题中要善于根据条件优化算法。
2. **_Arahc_**：详细总结题目坑点，提醒做题时需仔细审题，关注细节，避免常见错误。 

---
处理用时：68.31秒
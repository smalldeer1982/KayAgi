# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效统计满足\(A - B = C\)的数对个数展开，涉及多种思路和算法，如基于哈希表、二分查找、双指针等。其中，哈希表和二分查找较为常见，哈希表实现简单但空间复杂度高，二分查找需先排序，时间复杂度为 \(O(nlogn)\) 。双指针法相对巧妙，利用排序后数组的特性，通过移动指针来统计数对，时间复杂度为 \(O(n)\) 。

### 所选的题解
- **作者：OsvaldoAsensioLopez (赞：787)  星级：5星**
    - **关键亮点**：思路清晰简洁，将\(A - B = C\)转化为\(A - C = B\)，利用`map`统计每个数出现的次数，然后遍历数组计算满足条件的数对个数，代码实现简洁明了。
    - **重点代码**：
```cpp
#include <iostream>
#include <map>
using namespace std;
typedef long long LL;
LL a[200001];
map<LL,LL> m;
int main() {
    int n;
    LL c;
    LL ans=0;
    cin >> n >> c;
    for(int i=1;i<=n;i++) {
        cin >> a[i];
        m[a[i]]++;
        a[i]-=c;    
    } 
    for(int i=1;i<=n;i++) ans+=m[a[i]];
    cout << ans << endl;
    return 0;
}
```
    - **核心思想**：先将数组元素读入并统计其出现次数，同时将每个元素减去\(C\)，最后遍历数组，累加每个元素减去\(C\)后在`map`中的出现次数，得到满足条件的数对个数。
- **作者：樱花飞舞 (赞：536)  星级：4星**
    - **关键亮点**：利用二分查找的思想，通过`lower_bound`和`upper_bound`函数在有序数组中查找满足条件的数的位置，从而统计数对个数，算法复杂度为 \(O(nlogn)\) ，代码简洁易懂。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long a[200001];
long N,C,ans;
int main()
{
    cin>>N>>C;
    for(int i=1;i<=N;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+N+1);
    for(int i=1;i<=N;i++)
    {
        ans+=((upper_bound(a+1,a+N+1,a[i]+C)-a)-(lower_bound(a+1,a+N+1,a[i]+C)-a));
    }
    cout<<ans;
    return 0;
}
```
    - **核心思想**：先对数组排序，然后遍历数组，对于每个元素\(a[i]\)，通过`upper_bound`和`lower_bound`函数获取\(a[i] + C\)在数组中的位置差，即\(a[i] + C\)出现的次数，累加得到满足条件的数对个数。
- **作者：jins3599 (赞：458)  星级：4星**
    - **关键亮点**：采用双指针法，通过维护两个右端点，利用排序后数组的有序性，找到每个数对应的满足条件的数的连续区间，从而统计数对个数，时间复杂度为 \(O(n)\) ，算法效率较高。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2e5 + 10;
int n, c;
int a[N];
int main () 
{
	cin >> n >> c;
	for(int i = 1 ; i <= n ; i ++) cin >> a[i];
	sort(a + 1, a + 1 + n);
	int l = 1, r1 = 1, r2 = 1;
	ll ans = 0;
	for(l = 1 ; l <= n ; l ++) {
		while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
		while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
		if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
			ans += r1 - r2;
	}
	cout << ans;
	return 0;
}
```
    - **核心思想**：先对数组排序，然后使用双指针法，通过移动指针\(r1\)和\(r2\)找到满足\(a[r1] - a[l] <= c\)和\(a[r2] - a[l] < c\)的位置，若\(a[r2] - a[l] == c\)且\(a[r1 - 1] - a[l] == c\)，则累加\(r1 - r2\)得到满足条件的数对个数。

### 最优关键思路或技巧
1. **数学转化**：将\(A - B = C\)转化为\(A - C = B\)，简化问题求解。
2. **数据结构选择**：根据数据规模和特点选择合适的数据结构，如`map`用于统计数的出现次数，在有序数组中使用二分查找相关函数。
3. **双指针法**：利用数组排序后的有序性，通过移动指针高效地找到满足条件的数对区间，降低时间复杂度。

### 可拓展思路
此类题目可拓展到其他等式关系的数对统计问题，或在不同数据结构和算法场景下进行优化。例如，当数据规模更大时，考虑更高效的哈希算法或数据压缩方法；当数据有特殊分布时，进一步优化双指针或二分查找的策略。

### 相似知识点洛谷题目
1. **P1873 砍树**：涉及二分查找的应用，通过二分查找合适的砍树高度。
2. **P2678 [NOIP2015 普及组] 跳石头**：同样运用二分查找，确定满足条件的最小跳跃距离。
3. **P1106 删数问题**：可使用双指针法或贪心策略解决，与本题在算法思维上有相似之处。

### 个人心得摘录与总结
部分作者提到在解题过程中遇到数据类型问题，如未开`long long`导致结果错误，强调了仔细审题和注意数据范围的重要性。还有作者尝试多种算法，对比不同解法的效率，如`map`、二分查找和哈希表的性能差异，体现了在解题中探索和优化的过程。 

---
处理用时：56.24秒
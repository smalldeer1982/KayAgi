# 题目信息

# 平台

## 题目描述

空间中有一些平台。给出每个平台的位置，请你计算从每一个平台的边缘落下之后会落到哪一个平台上。

注意，如果某两个平台的某个两边缘横坐标相同，物体从上面那个平台落下之后将不会落在下面那个平台上（即平台的范围是一个开区间，不包含端点）。平台**可能会重叠**。

从平台下落时视作从平台下方开始下落，也就是说不会落到高度相同的平台上。**如果有两个平台的高度相同且都可以被落到的话，那么会落到编号靠前的那个平台。**

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)

## 样例 #1

### 输入

```
5
2 0 2
4 1 3
3 1 3
5 3 4
1 1 5
```

### 输出

```
0 5
1 5
1 5
5 5
0 0
```

# AI分析结果

### 综合分析与结论
这些题解思路大多基于暴力模拟，通过枚举每个平台，再遍历其他平台判断是否满足落下条件。主要难点在于处理平台重叠以及高度相同平台的选择规则。算法要点为判断平台间的位置和高度关系，找出从每个平台左右边缘落下后所落到的平台。多数题解时间复杂度为O(n^2)，部分题解尝试通过排序等方式优化，但整体优化程度有限。

### 所选的题解
- **作者：kevin_y (赞：82)  星级：4星**
    - **关键亮点**：思路清晰简洁，直接采用暴力加贪心策略，代码实现简洁明了。
    - **重点代码**：
```cpp
#include<iostream>
using namespace std;
int n,a[1001],b[1001],c[1001];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i]>>b[i]>>c[i];
    for(int i=1;i<=n;i++){
        int sum1=0,sum2=0;
        for(int j=1;j<=n;j++)if(a[j]<a[i]&&b[j]<b[i]&&c[j]>b[i])if(a[sum1]<a[j])sum1=j;
        cout<<sum1<<" ";
        for(int j=1;j<=n;j++)if(a[j]<a[i]&&b[j]<c[i]&&c[j]>c[i])if(a[sum2]<a[j])sum2=j;
        cout<<sum2<<endl;
    }
}
```
    - **核心思想**：外层循环枚举每个平台，内层循环遍历其他平台，通过比较高度和端点位置，找出从当前平台左右边缘落下后能落到的最高平台。

- **作者：Drifterming (赞：8)  星级：4星**
    - **关键亮点**：对题目条件理解清晰，通过结构体存储平台信息并排序，代码逻辑清晰。
    - **重点代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=1005;

int n;
int L[N],R[N];
struct PT
{
    int id,l,r,h;
    bool operator < (const PT &a) const
    {
        return h==a.h?id<a.id:h>a.h;
    }
}pt[N];

inline int read()
{
    char c=getchar();int num=0;
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar())
        num=num*10+c-'0';
    return num;
}

int main()
{
    n=read();
    for(int i=1;i<=n;++i)
    {
        pt[i].id=i;
        pt[i].h=read(),pt[i].l=read(),pt[i].r=read();
    }
    sort(pt+1,pt+n+1);
    for(int i=1;i<=n;++i)
    {
        for(int j=i+1;j<=n;++j)
        {
            if(pt[j].l<pt[i].l&&pt[j].r>pt[i].l)
            {
                L[pt[i].id]=pt[j].id;
                break;
            }
        }
        for(int j=i+1;j<=n;++j)
        {
            if(pt[j].l<pt[i].r&&pt[j].r>pt[i].r)
            {
                R[pt[i].id]=pt[j].id;
                break;
            }
        }
    }
    for(int i=1;i<=n;++i)
        printf("%d %d\n",L[i],R[i]);
    return 0;
}
```
    - **核心思想**：定义结构体存储平台信息，按高度降序、id升序排序。之后遍历每个平台，从其后的平台中找出能接住左右端点落下物体的平台。

- **作者：Ofnoname (赞：4)  星级：4星**
    - **关键亮点**：代码简洁，直接模拟，无需排序，思路直观。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
#define MAX (1000 + 7)

int N, h[MAX], l[MAX], r[MAX], ans[2][MAX];

int main()
{
    scanf("%d", &N);
    for (int i = 1; i <= N; i++)
        scanf("%d%d%d", &h[i], &l[i], &r[i]);
    for (int i = 1; i <= N; i++)
    {
        int H1 = 0, H2 = 0;
        for (int j = 1; j <= N; j++)
        {
            if (H1 < h[j] && h[j] < h[i] && l[j] < l[i] && l[i] < r[j])
                ans[0][i] = j, H1 = h[j];
            if (H2 < h[j] && h[j] < h[i] && l[j] < r[i] && r[i] < r[j])
                ans[1][i] = j, H2 = h[j];
        }printf("%d %d\n", ans[0][i], ans[1][i]);
    }
}
```
    - **核心思想**：通过两层循环，外层枚举每个平台，内层遍历所有平台，判断是否满足高度和位置条件，找到符合条件的最高平台记录下来。

### 最优关键思路或技巧
1. **数据结构选择**：使用结构体来存储平台的高度、左右端点和编号等信息，使代码逻辑更清晰，操作更方便。
2. **排序优化**：部分题解通过对平台按高度排序（高度相同时按编号排序），在查找下落平台时可以减少不必要的比较，一定程度上优化了暴力枚举的效率。
3. **模拟过程**：直接模拟物体从每个平台左右边缘下落的过程，通过比较平台间的高度和端点位置关系来确定最终落到的平台。

### 可拓展之处
同类型题可涉及平面上物体的位置关系判断，类似算法套路为通过合理的数据结构存储物体信息，利用排序、枚举等方式处理物体间的位置和属性关系。例如处理线段相交、图形覆盖等问题。

### 推荐题目
1. **P1080 [NOIP2012 提高组] 国王游戏**：涉及贪心算法和数据排序，与本题处理平台信息有相似之处。
2. **P1199 [NOIP2010 普及组] 三国游戏**：通过枚举和比较来确定策略，类似本题枚举平台判断条件。
3. **P1803 凌乱的yyy / 线段覆盖**：处理线段覆盖问题，与本题判断平台位置关系类似。

### 个人心得摘录与总结
1. **CeLaMbDa**：开始以为平台无重叠，按无重叠写只有50分，后发现平台会重叠。总结：做题需仔细读题，注意隐藏条件。
2. **深海鱼的眼泪**：以为平台不重叠，用正经排序WA了两次，注意到高度相同时编号小的优先。总结：读题要全面，关注特殊情况的处理规则。 

---
处理用时：60.24秒
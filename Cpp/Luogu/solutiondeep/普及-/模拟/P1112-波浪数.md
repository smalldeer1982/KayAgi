# 题目信息

# 波浪数

## 题目描述

波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。

类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $2\le l\le r\le 32$，$1\le L\le R\le 10^7$，$k\in \{2, 3, 4\}$。

## 样例 #1

### 输入

```
10 11 190000 960000 2```

### 输出

```
191919
383838
575757
767676
959595```

# AI分析结果

• 综合分析与结论：这些题解主要思路为不直接按题目要求判断不同进制下的数是否为波浪数，而是逆向思维，先生成给定范围内各进制下的波浪数，再判断这些数是几重波浪数。算法要点在于通过多层循环枚举进制、波浪数交替的两个不同数字，构造出波浪数并记录其重数。解决难点在于避免暴力判断带来的超时问题，通过逆向构造减少计算量。

所选的题解：
  - **作者：Star_Wind (4星)**
    - **关键亮点**：思路清晰简单，通过子程序构造波浪数并标记，代码简洁明了。
    - **个人心得**：无
    - **核心代码**：
```cpp
void make(int x)
{
    for(int i=1;i<x;i++)
      for(int j=0;j<x;j++)
      if(i!=j)
      {
           len=0;
           t=0;
           while(t<r)
           { 
               len++;
               if(len%2==0) a[len]=i;
               else a[len]=j;
               t=t*x+a[len];
               if(t>r) break;
               b[t]++;
           }
      } 
}
int main()
{
    cin>>jl>>jr>>l>>r>>k;
    for(int i=jl;i<=jr;i++) 
      make(i);
    for(int i=l;i<=r;i++)
      if(b[i]==k) printf("%d\n",i);
    return 0;
}
```
    - **核心思想**：`make`函数通过三重循环枚举进制`x`、交替数字`i`和`j`，在`while`循环中构造波浪数`t`，并在`b`数组中标记其出现次数。主函数调用`make`函数并输出符合重数要求的数。
  - **作者：小越越 (4星)**
    - **关键亮点**：代码简洁高效，直接开数组记录重数，清晰展示构造波浪数的过程。
    - **个人心得**：指出题目坑点，一位数是波浪数且交替数字需不相等。
    - **核心代码**：
```cpp
int main()
{
    cin >> a >> b >> l >> r >> w;
    for (int i = a; i <= b; i++){
        for (int j = 1; j < i; j++)
            for (int k = 0; k < i; k++)
                if (j!= k){
                    int now = j, id = 1;
                    s[0] = j; s[1] = k;
                    while (now <= r){
                        v[now]++;
                        now = now*i+s[id];
                        id ^= 1;
                    }
                }
    }
    for (int i = l; i <= r; i++)
        if (v[i] == w)
            cout << i << endl;
    return 0;
}
```
    - **核心思想**：通过三层循环枚举进制`i`、波浪数起始的两个不同数字`j`和`k`，在`while`循环中构造波浪数`now`，并在`v`数组中记录其重数，最后输出符合重数要求的数。
  - **作者：Y_B_Y (4星)**
    - **关键亮点**：详细阐述构造波浪数和判断重数的原理，考虑到构造数可能重复的情况并进行处理。
    - **个人心得**：无
    - **核心代码**：
```cpp
int main()
{
	cin>>j1>>j2>>st>>ed>>num;
	for(int p=j1;p<=j2;p++)
	{
		memset(b,0,sizeof(b));
		for(int i=0;i<=p-1;i++)
		{
			for(int j=0;j<=p-1;j++)
			{
				if(i==j) continue;
				int tot=0;
				for(int l=1;l<=10;l++)
				{
					if(tot+j*pow(p,2*l-2)<=ed&&l>1) 
					{
					if(!b[tot+(int)(j*pow(p,2*l-2))]) yes[tot+int(j*pow(p,2*l-2))]++;
					b[tot+(int)(j*pow(p,2*l-2))]=1;
				    }
					if(tot+i*pow(p,2*l-1)+j*pow(p,2*l-2)<=ed)
					{
					 tot+=i*pow(p,2*l-1)+j*pow(p,2*l-2);
					 if(!b[tot])yes[tot]++;//没有重复,对应十进制波浪的重数+1
					 b[tot]=1;
				    }
					else break;
				}
			}
		}
	}
	for(int p=st;p<=ed;p++) if(yes[p]==num) cout<<p<<endl;
		return 0;
}
```
    - **核心思想**：通过四层循环，最外层枚举进制`p`，内部三层枚举交替数字`i`和`j`以及构造长度`l`。在构造波浪数`tot`过程中，利用`b`数组防止重复构造，`yes`数组记录重数，最后输出符合重数要求的数。

最优关键思路或技巧：逆向思维，先生成各进制下的波浪数，而非直接判断给定数在不同进制下是否为波浪数，通过多层循环枚举进制和交替数字来构造波浪数，利用数组记录重数。

可拓展之处：同类型题可考察在更多进制下判断类似特殊数，或对特殊数的构造规则进行变化。类似算法套路为遇到判断复杂的问题，尝试逆向构造满足条件的数，再进行筛选。

推荐洛谷题目：
  - P1036 [选数](https://www.luogu.com.cn/problem/P1036)：考察枚举和筛选。
  - P1164 [小A点菜](https://www.luogu.com.cn/problem/P1164)：涉及简单的动态规划和枚举。
  - P1219 [八皇后](https://www.luogu.com.cn/problem/P1219)：需要通过枚举和回溯解决问题。

个人心得摘录与总结：
  - **作者：小越越**：指出题目中一位数是波浪数以及交替数字需不相等这两个容易忽略的坑点。 

---
处理用时：48.50秒
# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何解决在有向无环图中，求以每个城市为终点的最长路径问题。大部分题解采用拓扑排序结合动态规划（DP）的方法，利用拓扑序保证DP的无后效性。部分题解使用记忆化搜索，同样能有效解决问题。

思路上，先根据题目所给道路信息构建有向图，明确该图无环。对于拓扑排序 + DP的方法，先对图进行拓扑排序，确定节点处理顺序，在这个顺序下，每个节点的答案由其前驱节点的答案推导得出，状态转移方程为 `dp[v] = max(dp[v], dp[u] + 1)`（其中 `(u, v)` 是图中的边）。记忆化搜索则是通过反向建图，递归搜索每个节点，记录已经计算过的节点结果，避免重复计算。

算法要点在于正确实现拓扑排序和DP过程（或记忆化搜索），以及合理选择数据结构存储图。解决难点在于理解拓扑序与DP无后效性的关系，以及处理好大数 据规模下的空间和时间复杂度问题。

综合质量来看，星星之火、_ZZH、归山_ 的题解相对较好。

  - 星星之火（5星）
    - 关键亮点：思路清晰，先阐述拓扑排序性质与DP的关系，再给出详细代码，并对DP在拓扑序中的无后效性进行深入解释。
    - 个人心得：无
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 100000 + 15;
int n, m, sum, tot;
int head[maxn], ru[maxn], ts[maxn], dp[maxn];
struct EDGE {
    int to;
    int next;
} edge[maxn << 2];
void add(int x, int y) {
    edge[++sum].next = head[x];
    edge[sum].to = y;
    head[x] = sum;
}
void topsort() {
    queue <int> q;
    for (int i = 1; i <= n; i++)
        if (ru[i] == 0) {
            q.push(i);
            ts[++tot] = i;
        }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            ru[v]--;
            if (ru[v] == 0) {
                q.push(v);
                ts[++tot] = v;
            }
        }
    }
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        add(u, v);
        ru[v]++;
    }
    topsort();
    for (int i = 1; i <= n; i++) dp[i] = 1;
    for (int i = 1; i <= n; i++) {
        int u = ts[i];
        for (int j = head[u]; j; j = edge[j].next) {
            int v = edge[j].to;
            dp[v] = max(dp[v], dp[u] + 1);
        }
    }
    for (int i = 1; i <= n; i++)
        printf("%d\n", dp[i]);
    return 0;
}
```
核心实现思想：先通过 `add` 函数构建邻接表存储图，`topsort` 函数实现拓扑排序，将拓扑序存入 `ts` 数组。在 `main` 函数中，初始化 `dp` 数组后，依据拓扑序更新每个节点的 `dp` 值，最后输出结果。

  - _ZZH（4星）
    - 关键亮点：代码简洁，直接在拓扑排序过程中进行DP，空间复杂度控制较好。
    - 个人心得：无
    - 核心代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<map>
#include<cmath>
using namespace std;
int n, m, lin[100010], in[100010], total, f[100010];
queue<int>q;
struct cym {
    int to, next;
} e[400010];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        int x, y;
        scanf("%d%d", &x, &y);
        e[++total].to = y;
        e[total].next = lin[x];
        lin[x] = total;
        in[y]++;
    }
    for (int i = 1; i <= n; i++)
        if (in[i] == 0) {
            f[i] = 1;
            q.push(i);
        }
    while (!q.empty()) {
        int cnt = q.front();
        q.pop();
        for (int i = lin[cnt]; i; i = e[i].next) {
            f[e[i].to] = max(f[e[i].to], f[cnt] + 1);
            if (--in[e[i].to] == 0) q.push(e[i].to);
        }
    }
    for (int i = 1; i <= n; i++) printf("%d\n", f[i]);
}
```
核心实现思想：通过邻接表存图，在输入时统计各节点入度。将入度为0的节点入队，在队列循环中，更新当前节点邻接节点的 `f` 值（即最长路径），同时处理新出现的入度为0的节点，最后输出每个节点的最长路径。

  - 归山_（4星）
    - 关键亮点：采用逆向思维，反向存图后用记忆化搜索解决问题，动态转移方程清晰。
    - 个人心得：无
    - 核心代码：
```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;

const int maxn = 1000010;
int n, m;
int x, y;
int head[maxn];
int tot;
int dp[maxn];
int ans;

struct Edge {
    int to;
    int next;
} e[maxn];

void add(int x, int y) {
    tot++;
    e[tot].to = y;
    e[tot].next = head[x];
    head[x] = tot;
}//邻接表

int dfs(int x) {
    if (dp[x]!= -1) return dp[x];//如果来过就直接输出
    dp[x] = 1;//更新该点,不要忘记了哦~
    for (int i = head[x]; i; i = e[i].next) {
        int y = e[i].to;
        dp[x] = max(dp[x], dfs(y) + 1);//dp~
    }
    return dp[x];
}

int main() {
    cin>>n>>m;
    memset(dp, -1, sizeof(dp));
    //dp数组不更新，oi十年泪两行
    for (int i = 1; i <= m; i++) {
        cin>>x>>y;
        add(y, x);//反向存图
    }
    for (int i = 1; i <= n; i++) cout<<dfs(i)<<endl;
    return 0;
}
```
核心实现思想：通过 `add` 函数反向构建邻接表，`dfs` 函数进行记忆化搜索。在搜索过程中，若节点 `dp` 值已计算则直接返回，否则更新 `dp` 值并递归搜索邻接节点，最后输出每个节点的 `dp` 值。

• 最优关键思路或技巧：
  - **拓扑排序与DP结合**：利用拓扑排序确定节点处理顺序，保证DP的无后效性，从而有效解决问题。
  - **记忆化搜索**：通过反向建图和记忆化，避免重复计算，降低时间复杂度。
  - **合理选择数据结构**：对于大数据规模，采用邻接表存储图可有效控制空间复杂度。

• 可拓展之处：同类型题常出现在有向无环图的最长路径、最短路径、关键路径等问题中。类似算法套路包括在拓扑序下进行状态转移，或通过记忆化搜索解决具有重叠子问题的情况。

• 推荐题目：
  - [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)：同样涉及有向无环图的拓扑排序应用，需要根据给定条件构建图并进行拓扑排序求解。
  - [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)：先通过强连通分量缩点得到有向无环图，再在新图上进行拓扑排序和DP等操作，综合考察图论知识。
  - [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)：与本题类似，在有向无环图上通过拓扑排序结合DP解决计数问题，有助于巩固相关知识点。

• 个人心得摘录与总结：
  - “dp数组不更新，oi十年泪两行”：强调了在记忆化搜索中，初始化和更新DP数组的重要性，否则容易因未正确记录状态而导致错误结果。 

---
处理用时：81.46秒
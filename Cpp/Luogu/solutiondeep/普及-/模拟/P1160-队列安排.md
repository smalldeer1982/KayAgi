# 题目信息

# 队列安排

## 题目描述

一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：

1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；

2. $2\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；

3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。

在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。

## 说明/提示

**【样例解释】**

将同学 $2$ 插入至同学 $1$ 左边，此时队列为：

`2 1`

将同学 $3$ 插入至同学 $2$ 右边，此时队列为：

`2 3 1`  

将同学 $4$ 插入至同学 $1$ 左边，此时队列为：

`2 3 4 1`  

将同学 $3$ 从队列中移出，此时队列为：

`2 4 1`  

同学 $3$ 已经不在队列中，忽略最后一条指令

最终队列：

`2 4 1`  

**【数据范围】**

对于 $20\%$ 的数据，$1\leq N\leq 10$。

对于 $40\%$ 的数据，$1\leq N\leq 1000$。

对于 $100\%$ 的数据，$1<M\leq N\leq 10^5$。


## 样例 #1

### 输入

```
4
1 0
2 1
1 0
2
3
3```

### 输出

```
2 4 1```

# AI分析结果

这道题主要考查对数据结构中链表的应用，通过模拟同学入列和出列的过程来解决问题。多数题解采用双向链表，少数使用树或其他方式。

1. **思路与算法要点**
    - **双向链表**：定义结构体或数组模拟双向链表节点，记录每个同学左右相邻同学的编号。插入同学时，调整相关节点的左右指针；删除同学时，标记同学已删除或调整相邻节点指针。
    - **树结构**：用树存储点与点之间的前后关系，通过中序遍历输出。
    - **STL**：使用C++标准库中的`std::list`双向链表模板类，利用其成员函数实现同学的插入和删除。
2. **解决难点**
    - **高效插入和删除**：数据范围大，简单数组移动元素时间复杂度高，需用链表结构降低时间复杂度。
    - **边界处理**：如链表初始化、删除同学时边界节点的处理，防止出现空指针或越界问题。
3. **题解评分**
    - **作者：BT狸——Frozen**：5星。思路清晰，详细阐述从数组模拟失败到双向链表模拟的过程，对链表插入和删除操作步骤及原理讲解细致，代码注释详尽。
    - **作者：Orina_zju**：5星。使用STL中的`std::list`解决问题，对`std::list`的使用方法、成员函数及迭代器详细介绍，代码简洁明了。
    - **作者：LiRewriter**：4星。用结构体数组模拟双向链表，对链表的插入、删除及遍历操作细节描述清晰，代码结构完整。
4. **最优关键思路或技巧**：使用双向链表数据结构，能高效进行插入和删除操作。在链表初始化时设置虚拟节点（如0号同学），可简化边界处理。删除同学时，可标记同学避免重复删除，减少链表操作次数。
5. **拓展**：此类题目属于链表模拟类，类似算法套路用于处理频繁插入和删除操作场景。同类型题可涉及循环链表、单向链表等变形。
6. **相似知识点洛谷题目**
    - **P1996 约瑟夫问题**：通过循环链表解决约瑟夫环问题。
    - **P3397 地毯填补问题**：利用链表结构优化搜索过程。
    - **P1052 过河**：可通过链表优化状态转移过程。
7. **个人心得摘录**
    - **作者：月影困**：最初使用指针链表，因查找删除效率低TLE。后用数组模拟链表，利用下标直接定位元素，提高效率。总结出在元素不重复时，数组模拟链表能避免指针链表查找元素的时间消耗。

### 所选题解
- **作者：BT狸——Frozen（5星）**
    - **关键亮点**：思路清晰，从错误思路引入，详细讲解双向链表模拟过程及原理，代码注释详细。
    - **核心代码**
```cpp
struct T{
    int l,r;        //每个同学的“左右手” 
	int d;          //表示同学是否输出 
}t[mx]={0};
void add(int i,int k,int f)       //新增同学 
{
    if(f==1)         //右 
    {
        t[k].r=t[i].r;
        t[k].l=i; 
        t[i].r=k;
        t[t[k].r].l=k;
    }
    else             //左
    {
        t[k].r=i;
        t[k].l=t[i].l;
        t[i].l=k;
        t[t[k].l].r=k;
    }
}
```
核心思想：用结构体数组`t`模拟双向链表，`add`函数实现同学插入操作，根据`f`值判断在指定同学左边或右边插入，通过调整节点的左右指针完成插入。
- **作者：Orina_zju（5星）**
    - **关键亮点**：使用STL的`std::list`，对其使用方法详细介绍，代码简洁清晰。
    - **核心代码**
```cpp
using Iter = list<int>::iterator;
const int maxN = 1e5 + 10;
Iter pos[maxN];
list<int> queList;
bool erased[maxN];
int N;
void buildQueue()
{
    queList.push_front(1);
    pos[1] = queList.begin();
    for (int i = 2; i <= N; i++)
    {
        int k, p;
        scanf("%d%d", &k, &p);
        if (p == 0)
        {
            pos[i] = queList.insert(pos[k], i); //left
        }
        else
        {
            auto nextIter = next(pos[k]);
            pos[i] = queList.insert(nextIter, i); //right
        }
    }
    int M;
    scanf("%d", &M);
    for (int x, i = 1; i <= M; i++)
    {
        scanf("%d", &x);
        if (!erased[x])
        {
            queList.erase(pos[x]);
        }
        erased[x] = true;
    }
}
```
核心思想：定义`queList`为`std::list`类型双向链表，`pos`数组记录每个同学在链表中的位置。`buildQueue`函数实现同学入列和出列操作，利用`std::list`的`insert`和`erase`成员函数完成插入和删除。
- **作者：LiRewriter（4星）**
    - **关键亮点**：用结构体数组模拟双向链表，对链表操作细节描述清晰，代码结构完整。
    - **核心代码**
```cpp
struct node{
 int L, R;
}a[100003];
inline void del(int x) {
    if(a[x].L == -1) return;
    a[a[x].L].R = a[x].R;
    a[a[x].R].L = a[x].L;
    a[x].L = -1;
    a[x].R = -1; 
}
inline void addRight(int x, int pos) { //插入右边 
    a[x].L = pos;
    a[a[pos].R].L = x;
    a[x].R = a[pos].R;
    a[pos].R = x;
}
inline void addLeft(int x, int pos) { //插入左边
    a[x].R = pos;
    a[a[pos].L].R = x;
    a[x].L = a[pos].L;
    a[pos].L = x;
}
```
核心思想：定义`node`结构体数组`a`模拟双向链表，`addRight`和`addLeft`函数实现同学在指定同学右边或左边插入，通过调整节点的左右指针完成操作。`del`函数实现同学删除操作，将被删除同学的相邻节点指针相连，并将该同学节点指针设为 -1 。 

---
处理用时：78.51秒
# 题目信息

# 日志分析

## 题目描述

M 海运公司最近要对旗下仓库的货物进出情况进行统计。目前他们所拥有的唯一记录就是一个记录集装箱进出情况的日志。该日志记录了两类操作：第一类操作为集装箱入库操作，以及该次入库的集装箱重量；第二类操作为集装箱的出库操作。这些记录都严格按时间顺序排列。集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为当前在仓库里所有集装箱中最晚入库的集装箱。

出于分析目的，分析人员在日志中随机插入了若干第三类操作――查询操作。分析日志时，每遇到一次查询操作，都要报告出当前仓库中最大集装箱的重量。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，有 $N \le 10$；
- 对于 $40\%$ 的数据，有 $N \le 1000$；
- 对于 $100\%$ 的数据，有 $1 \le N \le 200000$，$1 \le X \le 10^8$。


## 样例 #1

### 输入

```
13
0 1
0 2
2
0 4
0 2
2
1
2
1
1
2
1
2
```

### 输出

```
2
4
4
1
0
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕栈数据结构解决日志分析问题，核心是在栈的入栈、出栈操作基础上，高效实现查询栈中最大值的功能。
1. **思路与算法要点**：
    - **维护辅助数据**：多数题解通过维护辅助数组、辅助栈或类似结构记录栈中当前最大值。如用数组 `f[i]` 记录栈中从下到上 `i` 个元素中的最大值（medusa）；用辅助栈记录栈当前最大值（buickboy、安好en等）。
    - **单调栈思想**：部分题解提到单调栈概念，如引领天下，在入栈时判断新元素与之前最大值关系，若新元素小则不改变最大值记录，从而保证数据结构单调性，使查询最大值操作更高效。
    - **其他数据结构**：有题解使用优先队列（准点的星辰）、平衡树（t162）、multiset（zhanghengrui）等数据结构辅助解决问题，但实现相对复杂。
2. **解决难点**：难点在于在大量数据下高效获取栈中最大值，暴力搜索时间复杂度高不可行。通过上述维护辅助数据或利用特殊数据结构的方式，将查询最大值操作优化到接近 $O(1)$ 时间复杂度。
3. **评分情况**：综合思路清晰度、代码可读性、优化程度等，medusa、buickboy、felixwu 的题解相对质量较高。

### 所选的题解
1. **medusa（5星）**
    - **关键亮点**：思路清晰简洁，通过数组 `f` 巧妙记录栈中不同位置元素的最大值，在入栈、出栈和查询操作时，依据数组简单更新或获取最大值，代码实现直接明了。
    - **核心代码**：
```cpp
int f[200001],n,x,y,t=0;   
int main()   
{   
    cin>>n;   
    f[0]=0;   
    for (int i=1; i<=n; i++)   
    {   
        cin>>x;   
        if (x==0)    
        {   
            cin>>y;   
            t++;   
            f[t]=max(f[t-1],y);   
        }   
        if (x==1) if (t!=0) t--;   
        if (x==2) cout<<f[t]<<endl;   
    }   
    return 0;   
}  
```
    - **核心实现思想**：入栈时，`t` 自增并更新 `f[t]` 为当前元素与 `f[t - 1]` 的最大值；出栈时 `t` 减1；查询时直接输出 `f[t]`。
2. **buickboy（4星）**
    - **关键亮点**：利用辅助栈记录栈当前的最大值，逻辑直观，代码简洁易懂，对栈操作和最大值维护的实现清晰。
    - **核心代码**：
```cpp
stack<int>a;
stack<int>b;
int n,m,x;
int main()
{
    scanf("%d",&n);
    while(n--)
    {
        scanf("%d",&m);
        if(m==0)
        {
            scanf("%d",&x);
            a.push(x);
            if(b.empty()||x>b.top())
                b.push(x);
            else b.push(b.top());
        }
        else if(m==1)
        {
            a.pop();
            b.pop();
        }
        else
        {
            if(b.empty()) printf("0\n");
            else printf("%d\n",b.top());
        }
    }
    return 0;
}
```
    - **核心实现思想**：主栈 `a` 正常入栈出栈操作，辅助栈 `b` 在入栈时，若新元素大于 `b` 栈顶则将新元素入栈，否则将 `b` 栈顶元素重复入栈；出栈时两栈同步操作；查询时输出 `b` 栈顶元素。
3. **felixwu（4星）**
    - **关键亮点**：代码简洁，用数组模拟栈，并在栈顶位置维护包括栈顶元素的最大值，操作直观，符合栈操作习惯。
    - **核心代码**：
```cpp
int q[1000001],top,a[1000001],m,n,k;
void push(int x){q[++top]=x;}
void pop(){top--;}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&m);
        if(m==0) {
            scanf("%d",&k);
            push(k);
            a[top]=max(a[top-1],k);
        }
        if(m==1) pop(); 
        if(m==2) printf("%d\n",a[top]);
    }
    return 0;
}
```
    - **核心实现思想**：`push` 函数实现入栈操作，入栈同时更新 `a[top]` 为当前元素与 `a[top - 1]` 的最大值；`pop` 函数实现出栈；查询时输出 `a[top]`。

### 最优关键思路或技巧
维护辅助数据结构记录最大值是最优关键思路，如辅助栈或辅助数组。在入栈时，根据新元素与当前记录最大值的关系更新辅助数据结构，保证在出栈和查询操作时能快速获取最大值，将查询操作时间复杂度优化到接近 $O(1)$。

### 可拓展之处
同类型题常涉及栈与其他操作结合，如栈与区间查询、栈与动态规划结合等。类似算法套路是在使用栈实现基本操作基础上，通过维护额外信息（如最大值、最小值、总和等）解决复杂查询需求。

### 推荐题目
1. **P1908 逆序对**：通过栈实现逆序对统计，考察栈操作与计数问题结合。
2. **P3957 [NOIP2017 普及组] 跳房子**：可利用栈优化动态规划，涉及栈在动态规划中的应用。
3. **P4318 完全平方数**：在求解过程中可借助栈辅助处理数据，考察栈与数论问题结合。

### 个人心得摘录与总结
1. **Garrison**：提到在洛谷编译器中 `++tot;a[tot]=a[tot - 1];` 和 `a[++tot]=a[tot - 1]` 不等价，部分评测系统计算顺序不同，提醒注意代码在不同环境下的细节差异。 

---
处理用时：68.26秒
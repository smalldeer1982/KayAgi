# 题目信息

# 到天宫做客

## 题目描述

有一天，我做了个梦，梦见我很荣幸的接到了猪八戒的邀请，到天宫陪他吃酒。我犹豫了。天上一日，人间一年啊！当然，我是个闲人，一年之中也没有多少时日是必须在人间的，因此，我希望选一个最长的空闲时间段，使我在天上待的时间尽量长。记住，今年是 $4000$ 年。天上一天也是 $24$ 小时，每小时 $60$ 分，每分 $60$ 秒。


## 说明/提示

### 样例解释（2023.9.29 新增）

$4000$ 年是闰年，共有 $366$ 天，其中二月份有 $29$ 天。

最长连续空闲时间是从 $3$ 月 $9$ 日至 $12$ 月 $1$ 日一共 $268$ 天。对应着天上的 $86400\times 268 \div 366=63265.57\approx 63266$ 秒。

## 样例 #1

### 输入

```
2
3 8
12 2```

### 输出

```
63266```

# AI分析结果

### 综合分析与结论
这些题解思路大致相同，核心都是找出一年中最长的连续空闲时间段，并转换为天上的秒数。
1. **思路**：多数题解先处理输入日期，将其转换为一年中的第几天，再通过排序或标记的方式找出最大间隔。有的题解用数组记录每月累计天数来快速计算日期差值；有的用标记数组记录忙碌日期，遍历统计空闲天数。
2. **算法要点**：排序（如使用STL的sort或手写排序）、日期计算（借助每月天数数组）、最大间隔计算（遍历比较）、时间转换（人间天数转天上秒数）。
3. **解决难点**：边界处理，如一年开始到第一个忙碌日期，以及最后一个忙碌日期到年末的时间段；输入日期无序需排序；时间转换时的精度处理。

综合质量来看，以下题解相对较好：
1. **作者：Rocket_raccoon_**：思路清晰，代码简洁，利用STL的sort排序，注释详细，对边界处理巧妙（通过设置num[n + 1] = 367处理年末情况），四星。
2. **作者：PTC06**：思路直接易懂，通过标记数组模拟找出最长空闲时间，代码逻辑清晰，四星。
3. **作者：午尘**：利用结构体排序，代码结构完整，详细注释，思路表述清晰，四星。

### 所选题解
1. **作者：Rocket_raccoon_（四星）**
    - **关键亮点**：利用STL的sort进行排序，通过巧妙设置数组边界值简化边界处理，代码简洁，注释详细。
    - **重点代码**：
```cpp
int f[13]={0,0,31,60,91,121,152,182,213,244,274,305,335};
int main(){
    int i,a,b,n;
    cin>>n;
    for (i=1; i<=n; i++){
        cin>>a>>b;
        num[i]+=f[a];
        num[i]+=b;
    }
    sort(num+1,num+n+1);
    num[n+1]=367; 
    for (i=1; i<=n+1; i++){
        ans=max(num[i]-num[i-1]-1,ans);
    }
    k=(ans*1.0*24*3600/366)+0.5;
    ans=k;
    cout<<ans;
    return 0;
} 
```
    - **核心实现思想**：先预处理每月天数数组，输入日期时转换为一年中的第几天存于数组，排序后通过相邻日期差值找出最大间隔，最后转换为天上秒数并四舍五入输出。
2. **作者：PTC06（四星）**
    - **关键亮点**：思路简单直接，通过标记数组模拟忙碌日期，遍历统计最长空闲时间，代码可读性高。
    - **重点代码**：
```cpp
int f[12];
int date[400];
int main()
{
    f[1]=0;
    f[2]=31;
    f[3]=60;
    f[4]=91;
    f[5]=121;
    f[6]=152;
    f[7]=182;
    f[8]=213;
    f[9]=244;
    f[10]=274;
    f[11]=305;
    f[12]=335;
    cin>>n;
    for (i=1;i<=n;i++)
    {
        cin>>m>>d;
        tem=f[m];
        tem+=d;
        date[tem]=1;
    }
    for (i=1;i<=366;i++)
    {
        if (date[i]==1)
        {
            sum=0;
        } else sum++;
        if (sum>bi) bi=sum;
    }
    k=bi*24*60*60*1.0/366;
    cout<<fixed<<setprecision(0)<<k;
}
```
    - **核心实现思想**：初始化每月天数数组，输入日期时标记忙碌日期，遍历一年天数，统计连续空闲天数，找出最大值并转换为天上秒数输出。
3. **作者：午尘（四星）**
    - **关键亮点**：使用结构体存储日期并排序，通过函数计算每月天数，逻辑清晰，代码结构完整。
    - **重点代码**：
```cpp
struct qwq{
    int x;
    int y;
}d[1000001];
bool cmp(qwq xx,qwq yy){
    if (xx.x==yy.x) return (xx.y<yy.y);
    return (xx.x<yy.x);
}
int months(int p){
    if (p==1||p==3||p==5||p==7||p==8||p==10||p==12) return 31;
    if (p==2) return 29;
    if (p==4 ||p==6||p==9||p==11) return 30;
}
int main(){
    scanf("%d",&n);
    for (i=1;i<=n;i++) scanf("%d%d",&d[i].x,&d[i].y);
    sort(d+1,d+n+1,cmp); 
    for (i=1;i<=n;i++) { 
        for (j=1;j<=d[i].x-1;j++)  b[i]+=months(j);
        b[i]+=d[i].y;
    }
    b[n+1]=367;b[0]=0;
    for (i=0;i<=n;i++) a[i]=b[i+1]-b[i]-1;
    for (i=0;i<=n;i++) maxn=max(maxn,a[i]);
    maxn=maxn*24*60*60;
    ans=(maxn*1.0)/366.00+0.5;
    cout<<(int)ans<<endl;
    return 0;
}
```
    - **核心实现思想**：定义结构体存储日期，输入后按月份和日期排序，计算每个日期是一年中的第几天，通过相邻日期差值找出最大间隔，转换为天上秒数并四舍五入输出。

### 最优关键思路或技巧
1. **预处理每月天数数组**：方便快速计算日期在一年中的位置，减少重复计算。
2. **排序**：对输入的无序日期进行排序，便于后续计算日期间隔。
3. **边界处理**：通过设置特殊值（如将年末设为367）或添加哨兵日期简化边界情况的处理。
4. **四舍五入**：在时间转换时，通过加0.5后强制类型转换实现四舍五入。

### 可拓展之处
同类型题可涉及不同时间单位转换、不同年份（平年闰年）天数计算、更复杂的日期限制条件等。类似算法套路如处理时间序列数据时，常需将时间转换为统一格式便于计算间隔，利用排序简化处理逻辑，以及注意边界条件。

### 相似知识点洛谷题目
1. **P1089 [NOIP2004 提高组] 津津的储蓄计划**：涉及简单的时间序列计算和条件判断。
2. **P1909 买铅笔**：与根据不同条件计算最优解相关，类似本题需处理不同数据并找出最值。
3. **P5710 【深基3.例2】数的性质**：包含简单的日期计算和逻辑判断，与本题日期处理有相似处。

### 个人心得摘录与总结
1. **作者：午尘**：写了六次才过，感觉有点考语文。总结：需仔细理解题意，注意细节，多次调试。 

---
处理用时：72.77秒
# 题目信息

# 3D模型

## 题目描述

一座城市建立在规则的 $n \times m$ 网格上，并且网格均由 $1 \times 1$ 正方形构成。在每个网格上都可以有一个建筑，建筑由若干个 $1 \times 1 \times 1$ 的立方体搭建而成（也就是所有建筑的底部都在同一平面上的）。几个典型的城市模型如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/2fxam89n.png)

现在给出每个网格上建筑的高度，即每个网格上建筑由多少个立方体搭建而成，要求这个建筑模型的表面积是多少。

## 说明/提示

- $20\%$的数据满足：$n, m \leq 10$；
- $40\%$的数据满足：$n, m \leq 100$；
- $100\%$的数据满足：$1 \leq n, m \leq 1000$。


## 样例 #1

### 输入

```
3 3
111
212
111```

### 输出

```
38
```

## 样例 #2

### 输入

```
3 4
1000
0010
0000
```

### 输出

```
12```

# AI分析结果

• 综合分析与结论：
    - 这些题解主要有两种思路。一是通过三视图来计算表面积，分别从上下、前后、左右三个方向观察，计算每个方向的可见面积并乘以2得到总面积，此方法需注意处理凹槽情况；二是先计算所有方块的总表面积，再减去重叠面的面积。
    - 算法要点上，有的题解边输入边计算，有的先存储数据再统一处理。在处理重叠面或凹槽时，有的通过比较相邻方块高度差，有的使用DFS或三维数组模拟等方式。
    - 解决难点方面，多数题解关注到输入数据为字符需转换，以及处理因方块相邻产生的重叠面或凹槽对表面积计算的影响。

    - 整体来看，各题解在思路清晰度、代码可读性、优化程度上有所差异。部分题解代码简洁清晰，思路直接；部分题解虽能解决问题，但代码较为繁琐或注释较少，可读性欠佳。

  - 所选的题解：
    - 作者：Sqrt_tyz (赞：108)
      - 星级：5星
      - 关键亮点：思路清晰，将问题简化为从三个方向观察计算面积，详细说明了判断凹槽的方法及具体实现步骤，代码简洁且注释详细。
      - 个人心得：无
      - 重点代码及核心实现思想：
```cpp
//上面
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        if(map[i][j]>0) ans_u+=1;
    }
//正面
for(int j=1;j<=m;j++)
{
    ans_f+=map[1][j]; //第一个先加上
    for(int i=2;i<=n;i++)
    {
        if(map[i][j]>map[i-1][j])
            ans_f+=(map[i][j]-map[i-1][j]); //后面的加上与前一个的差
    }
}
//侧面
for(int i=1;i<=n;i++)
{
    ans_f+=map[i][1]; //第一个先加上
    for(int j=2;j<=m;j++)
    {
        if(map[i][j]>map[i][j-1])
            ans_r+=(map[i][j]-map[i][j-1]); //后面的加上与前一个的差
    }
}
cout<<(ans_u+ans_f+ans_r)*2;
```
核心思想是分别从上面、正面、侧面三个方向计算可见面积，上面直接统计大于0的方块数，正面和侧面通过比较相邻方块高度差来计算可见面积，最后将三个方向的面积和乘以2得到总面积。

    - 作者：Mychael (赞：1)
      - 星级：4星
      - 关键亮点：方法简洁，按读入顺序逐个加入四棱柱，每次加入时计算其表面积并减去与已加入棱柱的重叠面积，代码简短且逻辑清晰。
      - 个人心得：无
      - 重点代码及核心实现思想：
```cpp
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++){
        c = getchar(); while (c < 48 || c > 57) c=getchar();
        h[i][j] = c - '0';
        if (!h[i][j]) continue;
        ans += 4 * h[i][j] + 2;
        if (i > 1) ans -= 2 * min(h[i][j],h[i - 1][j]);
        if (j > 1) ans -= 2 * min(h[i][j],h[i][j - 1]);
    }
```
核心思想是边读入边处理，对于每个读入的方块，先计算其自身表面积（$4 \times h + 2$），再减去与上方和左方相邻方块的重叠面积（$2 \times \min(h_{当前}, h_{相邻})$）。

    - 作者：HearTheWindSing (赞：9)
      - 星级：4星
      - 关键亮点：思路独特，先算出每个柱状体的面数并累加，再减去重叠面数，通过巧妙的公式计算重叠面，代码量较少且注释详细。
      - 个人心得：无
      - 重点代码及核心实现思想：
```cpp
for (int i=0;i<n;i++){
    for (int j=0;j<m;j++){
        scanf("%1d",&a[i][j]);
        if (a[i][j]==0) continue;
        ans+=a[i][j]*4+2;
        if (i-1>=0){
            ans-=min(a[i-1][j],a[i][j])*2;
        }
        if (j-1>=0){
            ans-=min(a[i][j-1],a[i][j])*2;
        }
    }
}
```
核心思想是先给每个非零高度的方块加上其表面积（$4 \times h + 2$），然后在输入过程中，根据方块位置判断并减去与左方和上方相邻方块的重叠面面积（$2 \times \min(h_{当前}, h_{相邻})$）。

• 最优关键思路或技巧：
    - **思维方式**：从不同角度观察模型，如通过三视图来简化问题，将复杂的3D表面积计算转化为多个2D方向上的简单计算。
    - **代码实现技巧**：边输入边计算，减少数据存储压力和后续处理的复杂度；利用数组边界处理，避免对边界情况的特殊判断。

• 可拓展之处：同类型题可涉及不同形状的3D物体表面积或体积计算，类似算法套路是先分析物体结构，找到合适的观察角度或计算方式，通过分解问题简化计算过程，如先计算总体再减去重叠部分，或者从不同方向分别计算再汇总。

• 推荐题目：
    - [P1048 采药](https://www.luogu.com.cn/problem/P1048)：01背包问题，考察对问题的分析和动态规划的应用，与本题分析方块关系和计算表面积思路类似，需找到合适的计算方式。
    - [P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)：递推问题，通过分析不同状态之间的关系得出递推式求解，类似本题中分析方块相邻关系来计算表面积。
    - [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)：简单的贪心算法问题，通过比较不同购买方案选择最优解，与本题在多种计算思路中选择最优方法有相似之处。

• 个人心得摘录与总结：
    - 作者：Atmizz提到注意输入数据为字符而非数字，需进行转换，这是容易忽略的细节。
    - 作者：weidong3274提到一开始默认每个格子都有方块导致答案错误，强调了对题目条件细致分析的重要性。
    - 总结：这些心得提醒在解题时要仔细审题，注意数据类型、边界条件等细节，避免因粗心导致错误。 

---
处理用时：67.12秒
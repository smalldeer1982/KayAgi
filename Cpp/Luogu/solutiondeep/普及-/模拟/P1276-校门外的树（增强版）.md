# 题目信息

# 校门外的树（增强版）

## 题目描述

校门外马路上本来从编号 $0$ 到 $L$，每一编号的位置都有一棵树。有砍树者每次从编号 $A$ 到 $B$ 处连续砍掉每一棵树，就连树苗也不放过（记 `0 A B`，含 $A$ 和 $B$）；幸运的是还有植树者每次从编号 $C$ 到 $D$ 中凡是空穴（树被砍且还没种上树苗或树苗又被砍掉）的地方都补种上树苗（记 `1 C D`，含 $C$ 和 $D$）；问最终校门外留下的树苗多少棵？植树者种上又被砍掉的树苗有多少棵？

## 说明/提示

对于 $100 \%$ 的数据，$1 \le L \le 10000$，$1 \le N \le 100$。

## 样例 #1

### 输入

```
10 3
0 2 6
1 1 8
0 5 7
```

### 输出

```
3
2
```

# AI分析结果

• 综合分析与结论：
  - 思路方面，多数题解采用模拟思路，通过数组标记每个位置树的状态（树、树苗、空），按操作顺序遍历区间更新状态并统计结果。少数题解使用线段树，通过维护区间信息来处理操作，减少时间复杂度。
  - 算法要点，模拟法直接按题目描述，对每次砍树和种树操作遍历对应区间更新数组；线段树则需构建线段树结构，实现节点信息维护、更新和查询操作。
  - 解决难点上，都需准确理解题意，避免如将树与树苗概念混淆、忽略编号从0开始等问题。模拟法难点在合理设计状态标记和操作逻辑；线段树难点在于理解和实现线段树的构建、更新及查询过程。
  - 整体来看，模拟法因数据范围小能有效解决问题，代码简单易懂，但时间复杂度较高；线段树虽代码复杂，但在大数据量下效率优势明显。

  - 评分：
    - 应吟吟：5星。思路清晰，先指出审题易错点，再用模拟法实现，代码注释详细，考虑关闭流同步优化输入输出。
    - Mizuhara：4星。提出用线段树解决，且利用询问次数少的特点优化维护答案方式，代码结构清晰。
    - ghj1222：4星。使用bitset优化空间，通过独特的状态表示和位运算操作实现题目要求，代码简洁。

  - 最优关键思路或技巧：
    - 模拟法中，合理设计状态标记（如0为空、1为树、2为树苗）和操作逻辑，能清晰实现题目要求。
    - 线段树方法中，利用询问次数少的特点，通过两颗线段树分别维护不同信息来简化操作，减少不必要的更新，提高效率。

  - 拓展：此类题目属于区间操作与统计问题，类似套路有利用差分数组解决区间增减操作后单点查询问题；树状数组解决单点更新、区间查询问题。同类型题可考虑区间修改、区间查询的进阶版本。

  - 洛谷相似题目推荐：
    - P3372 【模板】线段树 1
    - P3368 【模板】树状数组 2
    - P1908 逆序对

  - 个人心得摘录与总结：
    - 应吟吟：强调审题重要性，如看清树与树苗区别、编号范围等，否则易出错。
    - 黯黑の夜：注意树苗不会长大及编号从0开始，自己因这两点WA多次。
    - Decide：看清题面，自己误将留下的树苗数看成剩下的树的数目，多次提交才通过。总结需仔细读题，明确题目要求，避免因理解偏差出错。

  - 所选题解：
    - 应吟吟（5星）：
      - 关键亮点：思路清晰，详细指出审题坑点，代码注释详尽，利用关闭流同步优化输入输出。
      - 个人心得：“审题一定要好好审，不然原来完全对的程序也会爆零(我才不会告诉你我为了找出这些坑点给洛谷提供了一页的提交记录呢)”，强调审题重要性。
      - 重点代码：
```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const ll FFF=10000+5;

ll l,n;
bool opt;
ll a,b;
ll flag[FFF];
ll ans_1,ans_2;

int main()
{
    ios::sync_with_stdio(false);
    cin>>l>>n;
    for(int i=0;i<=l;++i)
    {
        flag[i]=1;
    }
    for(int i=0;i<n;++i)
    {
        cin>>opt>>a>>b;
        if(opt==0)
        {
            for(int j=a;j<=b;++j)
            {
                if(flag[j]==2)
                {
                    ans_2+=1;
                }
                flag[j]=0;
            }
        }
        else
        {
            for(int j=a;j<=b;++j)
            {
                if(flag[j]==0)
                {
                    flag[j]=2;
                }
            }
        }
    }
    for(int i=0;i<=l;++i)
    {
        if(flag[i]==2)
        {
            ans_1+=1;
        }
    }
    cout<<ans_1<<endl<<ans_2;
    return 0;
}
```
核心实现思想：初始化数组表示树的状态，根据操作类型遍历区间更新状态并统计，最后输出结果。

    - Mizuhara（4星）：
      - 关键亮点：利用询问次数少的特点，通过两颗线段树分别维护树与树苗、树的相关信息，优化维护答案方式。
      - 重点代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define lson o<<1
#define rson o<<1|1
#define mid ((l+r)>>1)
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;
const int maxn=11111;

struct Segtree {
    int sum[maxn*4], ly[maxn*4], Ans;
    Segtree() {
        Ans = 0;
        memset(ly, 0, sizeof(ly));
        memset(sum, 0, sizeof(sum));
    }
    void build(int o, int l, int r) {
        if(l == r){
            sum[o] = 1;
            return;
        }
        build(lson, l, mid);
        build(rson, mid+1, r);
        sum[o] = sum[lson] + sum[rson];
    }
    void down(int o, int l, int r) {
        if(ly[o] == 1){
            ly[lson] = 1;
            ly[rson] = 1;
            sum[lson] = mid-l+1;
            sum[rson] = r-mid;
        }
        if(ly[o] == -1) {
            ly[lson] = -1;
            ly[rson] = -1;
            sum[lson] = 0;
            sum[rson] = 0;
        }
        ly[o] = 0;
    }
    void zhong(int o, int l, int r, int L, int R) {
        if(L<=l && r<=R) {
            ly[o] = 1;
            sum[o] = r-l+1;
            return;
        }
        down(o, l, r);
        if(L <= mid) zhong(lson, l, mid, L, R);
        if(mid+1 <= R) zhong(rson, mid+1, r, L, R);
        sum[o] = sum[lson] + sum[rson];
    }
    void cut(int o, int l, int r, int L, int R) {
        if(L<=l && r<=R) {
            Ans += sum[o];
            ly[o] = -1;
            sum[o] = 0;
            return;
        }
        down(o, l, r);
        if(L <= mid) cut(lson, l, mid, L, R);
        if(mid+1 <= R) cut(rson, mid+1, r, L, R);
        sum[o] = sum[lson] + sum[rson];
    }
} tree[2];

int n, m;
int main() {
    scanf("%d%d", &n, &m);
    n++;
    tree[0].build(1, 1, n);
    tree[1].build(1, 1, n);
    rep(i, 1, m){
        int ops, l, r;
        scanf("%d%d%d", &ops, &l, &r);
        l++, r++;
        if(ops == 0) tree[0].cut(1, 1, n, l, r), tree[1].cut(1, 1, n, l, r);
        if(ops==1) tree[0].zhong(1, 1, n, l, r);
    }
    cout<< tree[0].sum[1] - tree[1].sum[1] <<endl;
    cout<< tree[0].Ans - tree[1].Ans;
    return 0;
}
```
核心实现思想：构建两颗线段树，分别对树与树苗、树进行操作，通过线段树的更新和查询操作统计相关信息，最后计算并输出结果。

    - ghj1222（4星）：
      - 关键亮点：使用bitset优化空间，通过独特的状态表示（用两个bitset组合表示状态）和位运算操作实现题目要求。
      - 重点代码：
```cpp
#include <cstdio>
#include<iostream>
#include<bitset> 
using namespace std;
bitset<10011>a,b;
int main()
{
    int l,n;
    scanf("%d%d",&l,&n);
    a.set();
    b.set();
    int x,y,z;
    int ans1=0,ans2=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        if(x==0)
        {
            for(int i=y;i<=z;i++)
            {
                ans2+=a[i]^b[i];
                a.reset(i);
                b.reset(i);
            }
        }
        if(x==1)
            for(int i=y;i<=z;i++)
                a.set(i);
    }
    for(int i=0;i<=l;i++)
        ans1+=a[i]^b[i];
    printf("%d\n%d\n",ans1,ans2);
    return 0; 
}
```
核心实现思想：用两个bitset分别记录状态，根据操作类型通过位运算更新bitset状态并统计，最后输出结果。 

---
处理用时：85.72秒
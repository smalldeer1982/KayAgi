# 题目信息

# [NOIP 2014 提高组] 生活大爆炸版石头剪刀布

## 题目背景

NOIP2014 提高组 D1T1

## 题目描述

石头剪刀布是常见的猜拳游戏：石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。在《生活大爆炸》第二季第 8 集中出现了一种石头剪刀布的升级版游戏。

升级版游戏在传统的石头剪刀布游戏的基础上，增加了两个新手势：

斯波克:《星际迷航》主角之一。

蜥蜴人:《星际迷航》中的反面角色。

这五种手势的胜负关系如表一所示,表中列出的是甲对乙的游戏结果。

![](https://cdn.luogu.com.cn/upload/pic/1346.png)

现在，小 A 和小 B 尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定相等。例如：如果小 A 以 `石头-布-石头-剪刀-蜥蜴人-斯波克` 长度为 $6$ 的周期出拳,那么他的出拳序列就是 `石头-布-石头-剪刀-蜥蜴人-斯波克-石头-布-石头-剪刀-蜥蜴人-斯波克-...`，而如果小 B 以 `剪刀-石头-布-斯波克-蜥蜴人` 长度为 $5$ 的周期出拳,那么他出拳的序列就是 `剪刀-石头-布-斯波克-蜥蜴人-剪刀-石头-布-斯波克-蜥蜴人-...`。

已知小 A 和小 B 一共进行 $N$ 次猜拳。每一次赢的人得 $1$ 分，输的得 $0$ 分；平局两人都得 $0$ 分。现请你统计 $N$ 次猜拳结束之后两人的得分。

## 说明/提示

对于 $100\%$ 的数据，$0 < N \leq 200, 0 < N_A \leq 200, 0 < N_B \leq 200$ 。


## 样例 #1

### 输入

```
10 5 6
0 1 2 3 4
0 3 4 2 1 0
```

### 输出

```
6 2
```

## 样例 #2

### 输入

```
9 5 5
0 1 2 3 4
1 0 3 2 4
```

### 输出

```
4 4```

# AI分析结果

• 综合分析与结论：这些题解思路总体一致，均是模拟游戏过程来统计得分。算法要点在于存储胜负关系，按周期模拟出拳并判断结果。解决难点主要是处理不同周期长度下的出拳情况。部分题解通过数组存储胜负关系简化判断，部分通过分支语句直接判断。从质量上看，多数题解思路清晰，但在代码可读性和优化程度上有所差异。

所选的题解：
  - **作者：Sinwind (5星)**
    - **关键亮点**：思路极为清晰，详细阐述每一步骤，代码结构明了，变量命名规范，先存储游戏结果在二维数组，再模拟游戏过程，逻辑连贯。
    - **重点代码**：
```cpp
int game[5][5] =        //游戏的结果情况，1表示A赢，-1表示A输，0表示平
{
    {0, -1, 1, 1, -1},
    {1, 0, -1, 1, -1},
    {-1, 1, 0, -1, 1},
    {-1, -1, 1, 0, 1},
    {1, 1, -1, -1, 0}
};
int main(void)
{
    cin >> N >> N_A >> N_B;
    for(int i = 0; i < N_A; i++)
    {
        cin >> circle_A[i];
    }
    for(int i = 0; i < N_B; i++)
    {
        cin >> circle_B[i];
    }
    int i = 0;          //遍历A的猜拳周期
    int j = 0;          //遍历B的猜拳周期
    while(N--)
    {
        if(i >= N_A)
        {
            i = 0;
        }
        if(j >= N_B)
        {
            j = 0;
        }
        //比较结果
        int result = game[circle_A[i]][circle_B[j]];
        if(result == 1)
        {
            score_A++;
        }
        else if(result == -1)
        {
            score_B++;
        }
        i++;
        j++;
    }
    cout << score_A << " " << score_B;
    return 0;
}
```
    - **核心实现思想**：通过`game`数组存储胜负关系，在`main`函数中读入数据，利用`while`循环模拟猜拳过程，根据`game`数组判断结果并更新得分。

  - **作者：Alarm5854 (4星)**
    - **关键亮点**：思路独特，利用递归减少分支语句，代码量相对较少，通过巧妙的逻辑转换简化判断过程。
    - **重点代码**：
```cpp
inline void pk(int a,int b,int &s1,int &s2){
    if(a==b) return;
    if(a>b){
        pk(b,a,s2,s1);
        return;
    }
    switch(a){
        case 0:++(b==2||b==3?s1:s2);return;
        case 1:++(b==3?s1:s2);return;
        case 2:++(b==4?s1:s2);return;
        case 3:++s1;return;
    }
}
int main(){
    scanf("%d%d%d",&n,&na,&nb);
    for(int i=0;i<na;++i)
        scanf("%d",fa+i);
    for(int i=0;i<nb;++i)
        scanf("%d",fb+i);
    for(int i=0;i<n;++i)
        pk(fa[i%na],fb[i%nb],sa,sb);
    printf("%d %d",sa,sb);
    return 0;
}
```
    - **核心实现思想**：`pk`函数通过递归和`switch`语句判断胜负并更新得分，`main`函数读入数据并调用`pk`函数模拟猜拳。

  - **作者：ClV_Csy (4星)**
    - **关键亮点**：在模拟思路基础上，分享了C++ 去括号的代码实现技巧，可使代码更简洁美观，同时提供常规模拟思路与代码。
    - **重点代码**：
```cpp
int jud(int a, int b) {
    if (a == b) return 0;
    if (a == 0 && b == 1) return 1;
    if (a == 0 && b == 2) return 2;
    if (a == 0 && b == 3) return 2;
    if (a == 0 && b == 4) return 1;
    if (a == 1 && b == 0) return 2;
    if (a == 1 && b == 2) return 1;
    if (a == 1 && b == 3) return 2;
    if (a == 1 && b == 4) return 1;
    if (a == 2 && b == 0) return 1;
    if (a == 2 && b == 1) return 2;
    if (a == 2 && b == 3) return 1;
    if (a == 2 && b == 4) return 2;
    if (a == 3 && b == 0) return 1;
    if (a == 3 && b == 1) return 1;
    if (a == 3 && b == 2) return 2;
    if (a == 3 && b == 4) return 2;
    if (a == 4 && b == 0) return 2;
    if (a == 4 && b == 1) return 2;
    if (a == 4 && b == 2) return 1;
    if (a == 4 && b == 3) return 1;
}
int main()
{
    int n, na, nb;
    int a[210], b[210];
    int ca = 0, cb = 0;
    cin>> n >> na >> nb;
    for (int i = 1; i <= na; i++)
        cin >> a[i];
    for (int i = 1; i <= nb; i++)
        cin >> b[i];
    for (int i = 1; i <= n; i++) {
        int pa = i % na, pb = i % nb;
        if (pa == 0) pa = na;
        if (pb == 0) pb = nb;
        int p = jud(a[pa],b[pb]);
        if (p!= 0) {
            if (p == 2) ca++;
            else if (p == 1) cb++;
        }
    }
    cout << ca << " " << cb;
    return 0;
}
```
    - **核心实现思想**：`jud`函数通过分支语句判断每次猜拳结果，`main`函数读入数据，利用取模模拟周期，调用`jud`函数判断并更新得分。

最优关键思路或技巧：利用二维数组存储胜负关系可使代码逻辑更清晰，减少大量分支判断；递归等方式优化判断过程，减少代码量；掌握C++ 代码实现技巧，如合理去括号使代码简洁美观。

可拓展之处：此类题属于模拟类题目，类似套路是将复杂规则用合适数据结构存储，按给定条件模拟过程。同类型题可涉及不同规则的游戏模拟、按周期规律执行任务的模拟等。

推荐题目：
  - [P1035 [NOIP2002 普及组] 级数求和](https://www.luogu.com.cn/problem/P1035)
  - [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)
  - [P1909 [NOIP2016 普及组] 买铅笔](https://www.luogu.com.cn/problem/P1909)

个人心得摘录与总结：Alarm5854发现通过观察胜负关系规律，利用递归可避免冗长分支语句和打表，简化代码实现，这体现了深入挖掘题目规律对优化代码的重要性。 

---
处理用时：51.64秒
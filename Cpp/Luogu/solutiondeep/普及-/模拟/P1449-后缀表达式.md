# 题目信息

# 后缀表达式

## 题目描述

所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。

本题中运算符仅包含 $\texttt{+-*/}$。保证对于 $\texttt{/}$ 运算除数不为 0。特别地，其中 $\texttt{/}$ 运算的结果需要**向 0 取整**（即与 C++ `/` 运算的规则一致）。

如：$\texttt{3*(5-2)+7}$ 对应的后缀表达式为：$\texttt{3.5.2.-*7.+@}$。在该式中，`@` 为表达式的结束符号。`.` 为操作数的结束符号。


## 说明/提示

数据保证，$1 \leq |s| \leq 50$，答案和计算过程中的每一个值的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3.5.2.-*7.+@```

### 输出

```
16```

## 样例 #2

### 输入

```
10.28.30./*7.-@```

### 输出

```
-7```

# AI分析结果

• 综合分析与结论：这些题解均围绕后缀表达式求值问题展开，核心思路是利用栈数据结构，遇到数字入栈，遇到运算符则从栈顶弹出两个数字进行运算，并将结果入栈，最终栈内剩余的元素即为表达式的值。主要难点在于数字的读取处理（可能包含多位数字）以及减法和除法运算时操作数顺序的正确性。不同题解在实现细节上存在差异，如栈的实现方式（数组模拟、STL栈、自定义链表栈等）、数字读取方式（快读思想、字符串处理、scanf/gets读取等）以及代码结构和风格等方面。

所选的题解：
  - 作者：Imakf (赞：254)  星级：5星
    - 关键亮点：思路清晰，先详细分析题目，采用数组模拟栈的方法，代码结构简洁明了，对读入和运算过程分别进行清晰阐述，且对读入数字过程类比手写快读，易于理解。
    - 重点代码 - 读入部分：
```cpp
char op;
int now = 0;
while ((op = getchar())!= '@') {
    if (op >= '0' && op <= '9') now *= 10, now += op - '0';
    else if (op == '.') {
        stk[++i] = now;
        now = 0;
    }
}
```
核心实现思想：通过getchar逐字符读取，若是数字则按快读方式累加，遇到'.'将数字存入栈并清零now。
    - 重点代码 - 运算部分：
```cpp
else if (op == '+') {
    stk[i - 1] = stk[i - 1] + stk[i];
    stk[i] = 0;
    i--;
}
else if (op == '-') {
    stk[i - 1] = stk[i - 1] - stk[i];
    stk[i] = 0;
    i--;
}
else if (op == '*') {
    stk[i - 1] = stk[i - 1] * stk[i];
    stk[i] = 0;
    i--;
}
else if (op == '/') {
    stk[i - 1] = stk[i - 1] / stk[i];
    stk[i] = 0;
    i--;
}
```
核心实现思想：遇到运算符，从栈顶取出两个数字运算，结果存回栈顶前一个位置，栈顶指针减一。
  - 作者：Enigmatic (赞：196)  星级：4星
    - 关键亮点：时间和空间复杂度分析清晰，代码简洁高效，直接在读入时进行判断处理，利用switch语句使代码逻辑清晰，对后缀表达式中 - 和 / 运算操作数顺序的解释简洁明了。
    - 重点代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
stack<int> n;
char ch;
int s, x, y;
int main()
{
    while (ch!= '@')
    {
        ch = getchar();
        switch (ch)
        {
            case '+':x = n.top();n.pop();y = n.top();n.pop();n.push(x + y);break;
            case '-':x = n.top();n.pop();y = n.top();n.pop();n.push(y - x);break;
            case '*':x = n.top();n.pop();y = n.top();n.pop();n.push(x * y);break;
            case '/':x = n.top();n.pop();y = n.top();n.pop();n.push(y / x);break;
            case '.':n.push(s);s = 0;break;
            default :s = s * 10 + ch - '0';break;
        }
    }
    printf("%d\n", n.top());
    return 0;
}
```
核心实现思想：通过getchar读入字符，利用switch判断字符类型，数字按位累加，遇到'.'入栈，遇到运算符从栈顶取数运算后将结果入栈。
  - 作者：ZhangFuqun (赞：93)  星级：4星
    - 关键亮点：使用STL的stack，代码简洁易懂，通过for循环遍历读入的字符串，在循环内直接处理数字读取、入栈和运算操作，逻辑清晰。
    - 重点代码：
```cpp
stack<int>q;
string c;
int main()
{
    cin >> c;
    int a = 0, b = 0;
    int i, j;
    for (int k = 0; k < c.length(); k++)
    {
        if (c[k] == '@') break;
        else if (c[k] == '.'){
            q.push(a);
            b = 0, a = 0;
        }
        else if (c[k] <= '9' && c[k] >= '0'){
            a = b * 10 + c[k] - '0';
            b = a;
        }
        else{
            if (c[k] == '-') i = q.top(), q.pop(), j = q.top(), q.pop(), q.push(j - i);
            if (c[k] == '+') i = q.top(), q.pop(), j = q.top(), q.pop(), q.push(j + i);
            if (c[k] == '*') i = q.top(), q.pop(), j = q.top(), q.pop(), q.push(j * i);
            if (c[k] == '/') i = q.top(), q.pop(), j = q.top(), q.pop(), q.push(j / i);
        }
    }
    cout << q.top() << endl;
}
```
核心实现思想：读入字符串后，遍历字符串，数字按位累加，遇到'.'将数字入栈，遇到运算符从栈顶取数运算后将结果入栈。

最优关键思路或技巧：利用栈的先进后出特性处理后缀表达式求值是核心思路。在实现中，对于数字读取，采用类似快读的方式逐位累加形成完整数字，能高效处理多位数字情况；在运算时，明确减法和除法中操作数的顺序，保证运算结果的正确性。

可拓展之处：同类型题常涉及不同表达式（前缀、中缀）求值，或在表达式中加入更多运算符、函数等拓展内容。类似算法套路是利用栈来处理具有特定顺序的操作，如表达式求值、括号匹配等问题。

推荐题目：
  - P1175 表达式的转换：涉及中缀表达式转后缀表达式及后缀表达式求值，考察对表达式转换和栈的运用。
  - P1981 表达式求值：需要处理中缀表达式，考虑运算符优先级，运用栈来实现表达式求值。
  - P2036 求先序排列：通过后缀表达式构建二叉树并求其先序遍历，综合考察后缀表达式处理和二叉树相关知识。

个人心得摘录与总结：
  - 作者Error_Eric提到，复习快读模板代码可完成数字读入部分，对于理解读入代码可结合小学数位知识，以具体数字为例理解数字逐位累加的过程。总结为理解和运用已有知识模板，结合基础数学概念辅助理解代码实现。 

---
处理用时：62.56秒
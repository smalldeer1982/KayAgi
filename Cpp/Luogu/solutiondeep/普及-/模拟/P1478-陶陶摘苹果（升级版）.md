# 题目信息

# 陶陶摘苹果（升级版）

## 题目描述

又是一年秋季时，陶陶家的苹果树结了 $n$ 个果子。陶陶又跑去摘苹果，这次他有一个 $a$ 公分的椅子。当他手够不着时，他会站到椅子上再试试。

这次与 NOIp2005 普及组第一题不同的是：陶陶之前搬凳子，力气只剩下 $s$ 了。当然，每次摘苹果时都要用一定的力气。陶陶想知道在 $s<0$ 之前最多能摘到多少个苹果。

现在已知 $n$ 个苹果到达地上的高度 $x_i$，椅子的高度 $a$，陶陶手伸直的最大长度 $b$，陶陶所剩的力气 $s$，陶陶摘一个苹果需要的力气 $y_i$，求陶陶最多能摘到多少个苹果。


## 说明/提示

对于 $100\%$ 的数据，$n\leq 5000$, $a\leq 50$, $b\leq 200$, $s\leq 1000$, $x_i\leq 280$, $y_i\leq 100$。


## 样例 #1

### 输入

```
8 15
20 130
120 3
150 2
110 7
180 1
50 8
200 0
140 3
120 2```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕“陶陶摘苹果（升级版）”问题，采用贪心、搜索、动态规划等算法。贪心算法因其时间复杂度低（$O(n)$），成为本题最优解，多数题解也采用此思路。动态规划虽能解决问题，但时间复杂度为$O(nm)$，高于贪心算法。搜索算法基础复杂度为$O(k^n)$，即便优化后效率仍不及贪心和动态规划。

### 所选的题解
- **作者：ASZIIIS (赞：767) - 5星**
    - **关键亮点**：提供多种解法，包括搜索（含优化）、动态规划（背包）、贪心算法，对各算法思路、实现及复杂度分析详细，代码注释丰富，便于理解。
    - **个人心得**：作者回顾自己入门时就会用贪心，此次激发一题多解欲望，分享多种解法及优化思路。
    - **重点代码 - 贪心算法**：
```cpp
#include<iostream>
#include<algorithm> 
using namespace std;
int n,s,a,b,x_,y_,can,rest,ans;
struct apple{
    int xi,yi;
}ap[50005];
int cmp(apple x,apple y){
    return x.yi<y.yi;
}
int main(){
    cin>>n>>s>>a>>b;
    for(int i=1;i<=n;i++){
        cin>>x_>>y_;
        if(x_<=a+b){
            can++;
            ap[can].xi=x_;
            ap[can].yi=y_;
        }
    }
    sort(ap+1,ap+can+1,cmp);
    rest=s;
    ans=0;
    for(int i=1;rest>=ap[i].yi&&i<=can;i++){
        ans++;
        rest-=ap[i].yi;
    }
    cout<<ans;
    return 0;
} 
```
核心实现思想：先筛选出能摘到的苹果，再按摘苹果所需力气从小到大排序，依次摘取，直到力气不足。
- **作者：灯芯糕 (赞：393) - 4星**
    - **关键亮点**：利用题目数据范围特点，采用桶排序，代码简洁，时间和空间复杂度低。
    - **重点代码 - 桶排序**：
```cpp
#include<iostream>
using namespace std;
int c[101];
int main(){
    int n,s,h,a,b,i,t=0; 
    cin>>n>>s>>h>>i;h+=i;
    for(i=1;i<=n;i++){
        cin>>a>>b;
        if(a<=h)c[b]++;
    }
    for(i=0;i<=100&&s>=0;i++){
        while(c[i]){
            s-=i;
            t++;
            c[i]--;
            if(s<0){
                t--;
                break;
            }
        }
    }
    cout<<t;
    return 0;
}
```
核心实现思想：根据摘苹果所需力气创建桶，统计每个力气值对应的苹果数量，按力气从小到大顺序摘取，更新剩余力气和摘得苹果数。
- **作者：tengkaize (赞：4) - 4星**
    - **关键亮点**：先介绍常规贪心做法，后运用C++标准库和C++11语法简化代码，同时给出C#的Linq实现，展示多种编程技巧。
    - **重点代码 - C++ 标准库与C++11语法实现**：
```cpp
#include <iostream>
#include <iterator>
#include <algorithm>
#include <vector>

using namespace std;

struct Apple {
    int height;
    int weight;
};

istream& operator>>(istream& in, Apple& a) {
    in >> a.height >> a.weight;
    return in;
}

int main() {
    int n, s, a, b, h;
    cin >> n >> s >> a >> b;
    h = a + b;
    vector<Apple> apples;
    copy_if(
        istream_iterator<Apple>(cin),
        istream_iterator<Apple>(),
        back_inserter(apples),
        [h](const Apple& a) { return a.height <= h; }
    );
    sort(apples.begin(), apples.end(), [](const Apple& a1, const Apple& a2) {
        return a1.weight < a2.weight;
    });
    cout << count_if(apples.begin(), apples.end(), [&s](const Apple& a) {
        return (s -= a.weight) >= 0;
    });
    return 0;
}
```
核心实现思想：通过`copy_if`筛选出能摘到的苹果存入`vector`，用`sort`按所需力气排序，`count_if`统计可摘取苹果数量。

### 最优关键思路或技巧
- **贪心策略**：由于每个苹果价值相同，优先选择所需力气小的苹果，可使摘到的苹果数量最多。
- **数据筛选**：读入数据时，直接筛除高度超出陶陶能力范围的苹果，减少后续处理数据量。
- **排序优化**：使用高效排序算法（如`sort`）对苹果按所需力气排序，提高处理效率。

### 可拓展之处
同类型题或类似算法套路：此类问题属于资源分配优化问题，常见于背包问题变种。类似套路是分析问题是否具有贪心选择性质和无后效性，若满足则可采用贪心算法；若物品价值不同，可能需用动态规划解决。

### 相似知识点洛谷题目
- **P1090 [NOIP2004 提高组] 合并果子**：通过贪心策略选择最小的果子堆合并，以最小化总代价。
- **P1199 [NOIP2010 普及组] 三国游戏**：运用贪心思想，在双方博弈中选择最优策略。
- **P1223 排队接水**：根据接水时间贪心排序，使总等待时间最短。 

---
处理用时：45.78秒
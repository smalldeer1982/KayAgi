# 题目信息

# 拯救oibh总部

## 题目背景

oibh 总部突然被水淹没了！现在需要你的救援……


## 题目描述

oibh 被突来的洪水淹没了，还好 oibh 总部有在某些重要的地方起一些围墙。用 `*` 号表示，而一个四面被围墙围住的区域洪水是进不去的。

oibh 总部内部也有许多重要区域，每个重要区域在图中用一个 `0` 表示。

现在给出 oibh 的围墙建设图，问有多少个没被洪水淹到的重要区域。

## 说明/提示

对于 $100\%$ 的数据，$1 \le x,y \le 500$。

## 样例 #1

### 输入

```
4 5
00000
00*00
0*0*0
00*00```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 5
*****
*0*0*
**0**
*0*0*
*****```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何确定被围墙保护而未被洪水淹没的重要区域数量展开，多数采用深度优先搜索（DFS）或广度优先搜索（BFS）算法，少数使用动态规划（DP）。思路核心是模拟洪水淹没过程，标记被淹区域，最后统计未被淹的重要区域。
 - **思路方面**：多数题解从边界出发搜索可被洪水淹没的区域并标记，最后统计剩余未标记的重要区域。如从边界的点开始DFS或BFS，将能到达的空地标记为已淹没；DP则是通过状态转移模拟淹没过程。
 - **算法要点**：DFS和BFS需注意边界判断、标记已访问节点防止重复搜索；DP要明确状态定义和转移方程。
 - **解决难点**：确保搜索完整，避免遗漏可淹没区域。如部分题解因起始搜索点选择不当导致答案错误，改进方法是从多个边界点开始搜索或扩大搜索范围。

### 所选的题解
1. **作者：Blue_wonders（5星）**
    - **关键亮点**：思路阐述详细，结合示例与配图解析，清晰展示搜索过程；代码简洁明了，注释丰富，易理解。
    - **个人心得**：无
    - **核心代码**：
```cpp
void search(int x,int y){
    a[x][y]=1;//先标记被淹没了 
    for(int i=1;i<=4;i++){//向四个方向搜索 
        int x0=x+kx[i];
        int y0=y+ky[i];
        if(x0>0&&x0<=n&&y0>0&&y0<=m&&a[x0][y0]==0)search(x0,y0);
    }//如果新的数在整个数组范围内并且不是障碍(能走),那么就搜索从这个格子能走到其他哪些格子 
}
int main(){
    cin>>n>>m;
    char e;
    for(int i=1;i<=n;i++){//输入 
        for(int j=1;j<=m;j++){
            cin>>e;
            if(e=='*')a[i][j]=1;//如果是障碍就输入1 
            else a[i][j]=0;//可以过就是0 
        }
    }
    for(int i=1;i<=n;i++){//搜索第一列和最后一列的格子 
        if(a[i][1]==0)search(i,1);//如果有能过的就搜索 
        if(a[i][m]==0)search(i,m);
    }
    for(int i=1;i<=m;i++){//搜索第一行和最后一行的格子 
        if(a[1][i]==0)search(1,i);
        if(a[n][i]==0)search(n,i);
    }
    for(int i=1;i<=n;i++){//最后搜索没有被淹的格子 
        for(int j=1;j<=m;j++){
            if(a[i][j]==0)s++;
        }
    }
    cout<<s;//输出 
    return 0;
}
```
    - **核心思想**：`search`函数实现DFS，从边界点开始，将能到达的空地标记为已淹没，最后统计未被标记的空地数量。
2. **作者：是羊驼鸭（4星）**
    - **关键亮点**：明确指出本题为染色问题，思路清晰；代码简洁且注释详细，还推荐了相关练习题目。
    - **个人心得**：无
    - **核心代码**：
```cpp
void dfs(int m,int n)  
{ 
    if(m<0||n<0||m>x+1||n>y+1||map[m][n])  //如果越界或有障碍就回溯 
        return;  
    map[m][n]=2;   
    for(int i=1;i<=4;i++)  //上下左右搜索 
        dfs(m+dx[i],n+dy[i]);
}  
int main()
{
    scanf("%d%d",&x,&y);
    for(int i=1;i<=x;i++)  //习惯处理成数字地图 
        for(int j=1;j<=y;j++)
        {
            cin>>ch;  
            if(ch=='0')  
                map[i][j]=0; 
            else map[i][j]=1;
        }
    dfs(0,0);   //洪水开始泛滥 
    for(int i=1;i<=x;i++)  //寻找没有被洪水袭击的点即未被染色的点 
        for(int j=1;j<=y;j++)
            if(!map[i][j])
                ans++;   
    printf("%d",ans);
    return 0;  
}
```
    - **核心思想**：`dfs`函数从`(0, 0)`开始进行DFS染色，将能到达的空地标记为`2`，最后统计未被染色的空地数量。
3. **作者：Garrison（4星）**
    - **关键亮点**：思路表述清晰，将问题转化为求连通块，代码简洁高效，注释详细。
    - **个人心得**：无
    - **核心代码**：
```cpp
void s(int x,int y){//位置
    if(x>n||y>m||x<1||y<1||b[x][y])//边界条件
        return;
    b[x][y]=1,++ans;//改变
    for(int i=0;i<4;++i)
        s(x+wx[i],y+wy[i]);//向四个方向拓展
}
int main(){
    std::ios::sync_with_stdio(false);
    std::cin>>n>>m;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j){
            std::cin>>a[i][j];
            if(a[i][j]=='*')
                b[i][j]=1,++ans;
        }
    for(int i=1;i<=n;++i){
        if(a[i][1]=='0')
            s(i,1);
        if(a[i][m]=='0')
            s(i,m);
    }
    for(int j=1;j<=m;++j){
        if(a[1][j]=='0')
            s(1,j);
        if(a[n][j]=='0')
            s(n,j);
    }
    std::cout<<n*m-ans<<"\n";
    return 0;
}
```
    - **核心思想**：`s`函数实现DFS，从边界点开始标记能到达的空地，`ans`统计被标记的点，最后用总点数减去被标记点数得到未被淹没的重要区域数量。

### 最优关键思路或技巧
从边界出发进行搜索（DFS或BFS）是解决此类问题的关键思路，通过标记可淹没区域，能有效统计未被淹没区域。在代码实现上，合理利用数组标记已访问节点，避免重复搜索，可提高效率。如部分题解在边界处理上，通过扩大搜索范围或从多个边界点开始搜索，确保搜索完整性。

### 同类型题或类似算法套路拓展
此类题目属于连通块搜索与标记问题，常见套路是从特定边界或起始点出发，利用搜索算法标记连通区域，最后根据标记情况统计或判断相关区域。类似题目有岛屿数量统计、区域划分等，通常可使用DFS、BFS或并查集等算法解决。

### 推荐题目
 - **P1162 填涂颜色**：同样是关于区域填充与标记问题，通过模拟颜料填充过程，加深对搜索算法应用的理解。
 - **P1596 湖计数**：利用DFS统计连通的水域数量，与本题思路相似，强化搜索算法在区域统计问题上的应用。
 - **P1451 求细胞数量**：通过搜索算法统计连通细胞数量，锻炼对连通块问题的解决能力。

### 个人心得摘录与总结
 - **作者xxxjz**：最初从`(1, 1)`开始DFS搜索会因起始点选择不当导致答案错误，如遇到某些特殊数据（如“5 5 0*000 *0000 00000 00000 00000”），仅搜到第一个`0`后就搜不下去。改进方法是扩大搜索范围，从`(0, 0)`开始多搜一圈。总结为在解决搜索问题时，要充分考虑起始点选择对搜索完整性的影响，避免因特殊数据导致答案错误。 

---
处理用时：68.34秒
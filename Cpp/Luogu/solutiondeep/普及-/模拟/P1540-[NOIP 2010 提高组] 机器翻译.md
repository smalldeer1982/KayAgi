# 题目信息

# [NOIP 2010 提高组] 机器翻译

## 题目背景

NOIP2010 提高组 T1

## 题目描述

小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。

这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。

假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。

假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。

## 说明/提示

### 样例解释

整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：

1. `1`：查找单词 1 并调入内存。
2. `1 2`：查找单词 2 并调入内存。
3. `1 2`：在内存中找到单词 1。
4. `1 2 5`：查找单词 5 并调入内存。
5. `2 5 4`：查找单词 4 并调入内存替代单词 1。
6. `2 5 4`：在内存中找到单词 4。
7. `5 4 1`：查找单词 1 并调入内存替代单词 2。

共计查了 $5$ 次词典。

### 数据范围

- 对于 $10\%$ 的数据有 $M=1$，$N \leq 5$；
- 对于 $100\%$ 的数据有 $1 \leq M \leq 100$，$1 \leq N \leq 1000$。

## 样例 #1

### 输入

```
3 7
1 2 1 5 4 4 1
```

### 输出

```
5
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕用不同方法模拟机器翻译中内存管理和查词典过程。常见思路有用指针思想、STL容器（如vector、queue）、数组标记等。核心难点在于高效判断单词是否在内存中以及内存满时正确替换单词。
1. **指针思想**：用数组标记单词是否在内存，另一数组按顺序存内存中的单词，通过指针指示内存中最早和最晚存入的单词，实现高效插入和删除。
2. **STL - vector**：用vector模拟内存，利用find函数判断单词是否在内存，满时erase最早单词。
3. **STL - queue**：结合队列先进先出特性和数组标记模拟内存，每次处理新单词时判断是否在内存，不在则入队并更新标记，满时出队最早单词。

### 所选的题解
1. **作者：Apun (5星)**
    - **关键亮点**：使用指针思想，通过数组标记实现快速判断单词是否在内存，降低时间复杂度，代码简洁高效。
    - **核心代码**：
```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
using namespace std;
int n,m,x,ans,l,r,a[1005],b[1005];
int main()
{
    cin>>m>>n;
    l=0;r=0;
    for (int i=1;i<=n;i++)
     {
         scanf("%d",&x);
         if (a[x]==0) 
         {
             ans++;
            r++;b[r]=x;a[x]=1;
            if (r>m) {l++;a[b[l]]=0;}
         }
     }
    cout<<ans;
    return 0;
}
```
    - **核心思想**：数组a标记单词是否在内存，数组b按顺序存内存中的单词，l和r指针分别指示最早和最晚存入的单词，新单词不在内存时，r右移存入新单词，内存满时l右移删除最早单词。
2. **作者：Anguei (4星)**
    - **关键亮点**：利用STL的vector和find函数简洁实现需求，代码量少，思路清晰。
    - **核心代码**：
```cpp
#include <vector>
#include <iostream> 
#include <algorithm>

int main() {
	int m, n, t, ans = 0;
	std::cin >> m >> n;
	std::vector<int> v; 
	while (std::cin >> t) {
		if (std::find(v.begin(), v.end(), t) == v.end()) { 
			v.push_back(t); 
			++ans;
		}
		if (v.size() > m) 
			v.erase(v.begin()); 
	}
	std::cout << ans << std::endl;
}
```
    - **核心思想**：用vector模拟内存，find函数判断单词是否在内存，不在则加入内存并更新答案，内存满时删除最早单词。
3. **作者：JCT_addyi (4星)**
    - **关键亮点**：用队列模拟内存，结合数组标记，清晰模拟题目操作，代码易理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int h[1005]={0}; 
queue<int>tjc;
int main(){
    int m,n;
    cin>>m>>n;
    int cnt=0;
    while(n--){
    	int en;
    	cin>>en;     
    	if(h[en]==0){ 
    		++cnt;
    		tjc.push(en); 
    		h[en]=1;  
    		while(tjc.size()>m){ 
    			h[tjc.front()]=0;
    			tjc.pop();
			}
		}
	}
	cout<<cnt;
return 0;
}
```
    - **核心思想**：队列tjc模拟内存，数组h标记单词是否在内存，新单词不在内存时入队并标记，内存满时出队最早单词并清除标记。

### 最优关键思路或技巧
1. **数组标记**：通过数组标记单词是否在内存，能 $O(1)$ 时间复杂度判断单词是否在内存，相比逐个查找效率大幅提升。
2. **利用数据结构特性**：如队列的先进先出特性模拟内存中单词的替换，vector结合find函数简洁实现内存管理。

### 可拓展之处
此类题目属于模拟与简单数据结构结合类型，类似套路如用栈、链表等数据结构模拟特定操作。同类型题常涉及数据的进出管理、状态判断等。

### 相似知识点洛谷题目
1. **P1996 约瑟夫问题**：用循环链表或数组模拟出圈过程，考察对数据结构的应用和模拟能力。
2. **P1032 字串变换**：通过队列实现广度优先搜索，模拟字符串变换过程，与本题类似在于操作的模拟和数据结构辅助。
3. **P1449 后缀表达式**：利用栈模拟后缀表达式计算过程，考察栈的应用与操作模拟。 

---
处理用时：35.87秒
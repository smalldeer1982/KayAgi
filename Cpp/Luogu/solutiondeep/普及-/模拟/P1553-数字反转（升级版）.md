# 题目信息

# 数字反转（升级版）

## 题目背景

**以下为原题面，仅供参考:**

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。整数反转是将所有数位对调；小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分；分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母；百分数的分子一定是整数，百分数只改变数字部分。整数新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零；小数新数的末尾不为 $0$（除非小数部分除了 $0$ 没有别的数，那么只保留1个 $0$）；分数不约分，分子和分母都不是小数（约分滴童鞋抱歉了，不能过哦。输入数据保证分母不为 $0$），本次没有负数。


## 题目描述

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。

- 整数反转是将所有数位对调。

- 小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分。

- 分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母。

- 百分数的分子一定是整数，百分数只改变数字部分。

## 说明/提示

**【数据范围】**

- 对于 $25\%$ 的数据，$s$ 是整数，不大于 $20$ 位；
- 对于 $25\%$ 的数据，$s$ 是小数，整数部分和小数部分均不大于 $10$ 位；
- 对于 $25\%$ 的数据，$s$ 是分数，分子和分母均不大于 $10$ 位；
- 对于 $25\%$ 的数据，$s$ 是百分数，分子不大于 $19$ 位。

**【数据保证】**

- 对于整数翻转而言，整数原数和整数新数满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数和原来的数字的最高位数字不应为零。

- 对于小数翻转而言，其小数点前面部分同上，小数点后面部分的形式，保证满足小数的常见形式，也就是末尾没有多余的 $0$（小数部分除了 $0$ 没有别的数，那么只保留 $1$ 个 $0$。若反转之后末尾数字出现 $0$，请省略多余的 $0$）

- 对于分数翻转而言，分数不约分，分子和分母都不是小数。输入的分母不为 $0$。与整数翻转相关规定见上。

- 对于百分数翻转而言，见与整数翻转相关内容。

数据不存在负数。

## 样例 #1

### 输入

```
5087462```

### 输出

```
2647805```

## 样例 #2

### 输入

```
600.084```

### 输出

```
6.48```

## 样例 #3

### 输入

```
700/27```

### 输出

```
7/72```

## 样例 #4

### 输入

```
8670%```

### 输出

```
768%```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何对整数、小数、分数、百分数进行数字反转展开。思路上多是先判断输入数据的类型，再针对不同类型分别处理。算法要点在于字符串操作，如分割、反转、去零等。难点主要是处理各类数据的边界情况，如整数前导零、小数后导零、分数分子分母的特殊情况等。

### 所选的题解
1. **作者：Anguei (赞：293)  星级：5星**
    - **关键亮点**：对STL了解透彻，利用`std::reverse()`、`std::string::erase()`、`std::string::substr()`等函数，思路清晰，代码简洁且规范。
    - **个人心得**：无
    - **核心代码**：
```cpp
// 自己写的反转函数，返回反转并去掉前导零之后的字符串
std::string reverse(std::string s) {
    int zeroCount = 0;
    std::reverse(s.begin(), s.end()); // 反转
    // 范围 for 循环，用于统计前导零个数
    for (auto i : s)
        if (i == 48) ++zeroCount;
        else break;
    s.erase(s.begin(), s.begin() + zeroCount);
    return (s!= ""? s : "0"); // 特判
}

// 用于去掉后导零
std::string deleteTail(std::string s) { 
    int zeroCount = 0;
    for (int i = s.size() - 1; i >= 0; --i)
        if (s[i] == 48) ++zeroCount;
        else break;
    s.erase(s.end() - zeroCount, s.end());
    return (s!= ""? s : "0");
}

int main() {
    std::string s;
    std::cin >> s;
    if (s.back() == '%') {
        std::cout << reverse(s.substr(0, s.size() - 1)) << "%" << std::endl;
        return 0;
    }
    for (auto i : s) {
        std::string left, right;
        if (i == '/') {
            left = s.substr(0, s.find("/"));
            right = s.substr(s.find("/") + 1);
            std::cout << reverse(left) << "/" << reverse(right) << std::endl;
            return 0;
        }
        if (i == '.') {
            left = s.substr(0, s.find("."));
            right = s.substr(s.find(".") + 1);
            std::cout << reverse(left) << "." << deleteTail(reverse(right)) << std::endl;
            return 0;
        }
    }
    // 最后剩下的一种情况是正整数
    std::cout << reverse(s) << std::endl;
    return 0;
}
```
    - **核心实现思想**：定义`reverse`函数反转字符串并去除前导零，`deleteTail`函数去除后导零。在`main`函数中，根据字符串中是否包含`%`、`/`、`.`来判断数据类型，分别进行处理。

2. **作者：情到深处人孤独 (赞：41)  星级：4星**
    - **关键亮点**：将问题模块化，分成主程序和四个子程序，每个子程序负责一种数据类型的处理，代码结构清晰，易于理解和维护。
    - **个人心得**：无
    - **核心代码**：
```cpp
int find(string S)
{
    for (int i=0;i<=S.size()-1;i++)
        {
         if (S[i]=='.')
            {a=i;return 1;}    {是小数返回1}
         if (S[i]=='/')
            {a=i;return 2;}    {是分数返回2}
         if (S[i]=='%')
            {a=i;return 3;}    {是百分数返回3}
        }
    return 0;    {是整数返回0}
}

void integer(string S)    {整数程序，正常人看得懂的}
{
     for (int i=S.size()-1;i>=1;i--)
         if (S[i]=='0')
            S=S.erase(i,1);
         else
            break;
     for (int i=S.size()-1;i>=0;i--)
         cout<<S[i];
}

void decimals(string S)    {小数程序，是四种可能中最难的}
{
     n=S.substr(0,a);    {小数点前整数部分}
     m=S.substr(a+1,S.size()-(a+1));    {小数点后小数部分}
     //cout<<n<<endl<<m<<endl;
     integer(n);    {整数部分用整数处理}
     cout<<".";
     int i=0;
     while (m!="")
           {
            if (m[i]=='0')
               m=m.erase(0,1);
            else 
               break;
           }
     if (m=="")
        m="0";
     for (i=m.size()-1;i>=0;i--)
         cout<<m[i];
}

void fraction(string S)    {分数程序}
{
     n=S.substr(0,a);    {同小数，分数线前分子}
     m=S.substr(a+1,S.size()-(a+1));    {分数线后分母}
     //cout<<n<<endl<<m<<endl;
     integer(n);    {分子调用整数程序}
     cout<<"/";
     integer(m);    {分母调用整数程序}
}

void percentage(string S)    {百分数程序}
{
     S=S.erase(S.size()-1,1);    {调用整数程序前先去百分号}
     integer(S);    {数字调用整数程序}
     cout<<"%";
}

int main()
{
    cin>>s;
    b=find(s);
    if (b==0)
       integer(s);
    if (b==1)
       decimals(s);
    if (b==2)
       fraction(s);
    if (b==3)
       percentage(s);
    return 0;
}
```
    - **核心实现思想**：`find`函数判断字符串类型并记录分隔符位置。`integer`函数处理整数反转及去尾零。`decimals`函数将小数分为整数和小数部分，分别处理。`fraction`函数对分数分子分母分别调用`integer`函数处理。`percentage`函数去掉百分号后调用`integer`函数处理。`main`函数根据`find`函数返回值调用相应子程序。

3. **作者：张鑫杰 (赞：4)  星级：4星**
    - **关键亮点**：采用面向对象编程（OOP）思想，定义`var`类，将数据类型判断、数字反转等功能封装在类中，代码结构清晰，具有较好的封装性和可读性。
    - **个人心得**：无
    - **核心代码**：
```cpp
class var {//定义一个类
    friend ostream& operator<<(ostream& os, const var &a);//友元
private:
    string numLeft;
    string numRight;
    enum typeName {
        longint, decimal, fraction, percentage
    };//表示该var到底是小数,整数,分数,还是百分数
    typeName type;
public:
    var(string input) {//构造一个var类
        type = longint;//默认为整数,为什么是longint?Pascal留下的习惯
        numLeft = input;
        for (int i = 0; i!= input.size(); i++) {
            if (input[i] == '%') {
                type = percentage;
                numLeft = input.substr(0,i);
                break;
            }
            if (input[i] == '.') {
                type = decimal;
                numLeft = input.substr(0, i);
                numRight = input.substr(i + 1);
                break;
            }
            if (input[i] == '/') {
                type = fraction;
                numLeft = input.substr(0, i);
                numRight = input.substr(i + 1);
                break;
            }
        }
    }
    var() = default;
    var turnAround() {//翻转
        bool flag = true;//是否为第一次
        if (type == longint || type == percentage) {//百分数和整数处理相似
            reverse(numLeft.begin(),numLeft.end());//翻转
            for (unsigned int i = 0; i < numLeft.size(); i++) {
                if (flag && numLeft[i]!= '0') {
                    flag = false;
                    if (i!= 0) {
                        numLeft.erase(0, i);//删除范围[0,i)
                    }
                }
                if (flag && i!= 0 && i == numLeft.size() - 1) {
                    numLeft.erase(0, i);//如果全是0
                }
            }
        }
        else {//分数和小数处理相似
            reverse(numLeft.begin(), numLeft.end());//翻转
            reverse(numRight.begin(), numRight.end());
            for (unsigned int i = 0; i < numLeft.size(); i++) {
                if (flag && numLeft[i]!= '0') {
                    flag = false;
                    if (i!= 0) {
                        numLeft.erase(0, i);//删除范围[0,i)
                    }
                }
                if (flag && i!= 0 && i == numLeft.size() - 1) {
                    numLeft.erase(0, i);//如果全是0
                }
            }
            flag = true;
            for (unsigned int i = 0; i < numRight.size(); i++) {
                if (flag && numRight[i]!= '0') {
                    flag = false;
                    if (i!= 0) {
                        numRight.erase(0, i);//删除范围[0,i)
                    }
                }
                if (flag && i!=0 && i == numRight.size() - 1) {
                    numRight.erase(0, i);//如果全是0
                }
            }
        }
        if (type == var::decimal) {//小数特别去掉末尾的零
            for (int i = static_cast<int>(numRight.size())-1; i >= 0 ; i--) {
                if (numRight[i]!= '0' || i == 0) {
                    break;
                }
                if (numRight[i] == '0') {
                    numRight.erase(i);
                }
            }
        }
        return *this;
    }
    
};
istream& operator>>(istream& is, var &a) {//重载
    string tmp;
    is >> tmp;
    a = var(tmp);
    return is;
}
ostream& operator<<(ostream& os,const var &a) {
    string out;
    if (a.type == var::percentage) {
        out = a.numLeft;
        out += "%";
    }
    else if(a.type == var::fraction){
        out = a.numLeft;
        out += '/';
        out += a.numRight;
    }
    else if (a.type == var::decimal) {
        out = a.numLeft;
        out += '.';
        out += a.numRight;
    }
    else {
        out = a.numLeft;
    }
    os << out;
    return os;
}

int main() {
    var i;
    cin >> i;
    i.turnAround();
    cout << i;
    return 0;
}
```
    - **核心实现思想**：`var`类的构造函数判断输入字符串类型并分割存储。`turnAround`成员函数根据不同类型进行数字反转和去零处理。重载`>>`和`<<`运算符方便输入输出。`main`函数创建`var`对象，调用`turnAround`函数并输出结果。

### 最优关键思路或技巧
1. **利用STL函数**：如`std::reverse()`、`std::string::erase()`、`std::string::substr()`等，可简化字符串操作，提高代码效率和可读性。
2. **模块化编程**：将不同数据类型的处理封装成独立函数或子程序，使代码结构清晰，易于维护和扩展。
3. **面向对象编程**：通过定义类来封装数据和操作，提高代码的封装性和可读性，便于管理复杂逻辑。

### 可拓展之处
此类题目可拓展到处理更复杂的数字格式，如科学计数法、复数等。类似算法套路是先识别数据格式，再针对不同格式进行特定处理，处理过程中注重边界情况和特殊值。

### 相似知识点题目推荐
1. **P1035 [NOIP2002 普及组] 级数求和**：涉及数字运算和循环处理，与本题处理数字的思路有相似之处。
2. **P1909 买铅笔**：需要根据不同条件进行分类讨论，类似本题对不同数据类型的分类处理。
3. **P1046 [NOIP2005 普及组] 陶陶摘苹果**：通过对输入数据的判断和处理来解决问题，与本题判断数据类型并处理的方式类似。

### 个人心得摘录与总结
1. **作者：SebMa**：细节太多，要周密考虑，多次出错后才AC。总结出处理此类复杂细节题目的经验，需全面思考各种情况。
2. **作者：Mono_pigsicklie**：调试过程中遇到多种边界情况错误，如小数部分0的处理、分数前半部分多个0的判断等。强调了边界条件处理在这类题目中的重要性。 

---
处理用时：130.00秒
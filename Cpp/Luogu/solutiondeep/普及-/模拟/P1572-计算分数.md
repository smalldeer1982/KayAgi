# 题目信息

# 计算分数

## 题目描述

Csh 被老妈关在家里做分数计算题，但显然他不愿意做这么多复杂的计算。况且在家门口还有 Xxq 在等着他去一起看电影。为了尽快地能去陪 Xxq 看电影，他把剩下的计算题交给了你，你能帮他解决问题吗？


## 说明/提示

### 数据范围及约定

对于所有测试点，输入计算式长度在 $100$ 以内，分子、分母在 $1000$ 以内。同时保证，直接从前往后直接计算分数的和或者差，然后立刻化简，这么做的中间结果不会超过 int 的范围。

注意输入的分数不一定是最简分数。


------------
2024/2/13 添加 2 组 hack 数据。

## 样例 #1

### 输入

```
2/1+1/3-1/4```

### 输出

```
25/12```

# AI分析结果

• 综合分析与结论：这些题解均围绕分数加减法运算展开，思路上都是读入分数，通过通分、约分进行运算并输出结果。算法要点在于实现通分、约分函数，难点主要是处理输入输出细节及避免运算过程中数据溢出。多数题解都使用了C++自带的`__gcd`函数求最大公约数以实现约分。部分题解还提到了求最小公倍数`lcm`用于通分。在处理输入输出时，要注意分数格式、符号、约分及特殊情况（如分母为1、分子为0）的处理。

所选的题解：
  - **作者：ggylz49 (5星)**
    - **关键亮点**：思路清晰，详细介绍了使用的STL工具（`__gcd`函数及结构体作为函数参数和返回值的用法），代码结构完整，对每个函数功能有详细解释，先定义结构体表示分数，再分别实现约分、加法、减法函数，主函数按顺序读入并计算分数。
    - **个人心得**：提到最初未对第一次输入的分数约分导致得`Unaccped 100`分，后改正。
    - **核心代码片段**：
```cpp
struct fs
{
    long long fm,fz;
};
fs yf(fs a)
{
    long long m=__gcd(a.fm,a.fz);
    a.fm/=m;
    a.fz/=m;
    return a;
}
fs jia(fs x,fs y)
{
    long long z=x.fm*y.fm;
    x.fz*=y.fm;
    y.fz*=x.fm;
    x.fm=z;
    y.fm=z;
    fs answer;
    answer.fz=x.fz+y.fz;
    answer.fm=x.fm;
    return yf(answer);
}
fs jian(fs x,fs y)
{
    long long z=x.fm*y.fm;
    x.fz*=y.fm;
    y.fz*=x.fm;
    x.fm=z;
    y.fm=z;
    fs answer;
    answer.fz=x.fz-y.fz;
    answer.fm=x.fm;
    return yf(answer);
}
int main()
{
    fs a,b;
    char ysf;
    scanf("%lld/%lld",&a.fz,&a.fm);
    a=yf(a);
    cin>>ysf;
    while (scanf("%lld/%lld",&b.fz,&b.fm)!=EOF)
    {
        if (ysf==EOF)break;
        else if (ysf=='+'){a=jia(a,b);}
        else if (ysf=='-'){a=jian(a,b);}
        cin>>ysf;
    }
    if (a.fm<0&&a.fz>0)
    {
        a.fm=abs(a.fm);
        a.fz-=a.fz*2;
    }
    if (a.fm==1)cout<<a.fz;
    else cout<<a.fz<<'/'<<a.fm;
    return 0;
}
```
  - **作者：int_stl (4星)**
    - **关键亮点**：先给出分数加法公式，代码简洁明了，使用`lcm`函数求最小公倍数通分，`gcd`函数约分，在主函数中按公式逐步实现分数运算，考虑了结果的各种输出情况。
    - **核心代码片段**：
```cpp
int gcd(int a, int b) { return b? gcd(b, a % b) : a; }
int lcm(int a, int b) { return a / gcd(a, b) * b; }
int sgn(int x) {
	if (x > 0) return 1;
	if (x < 0) return -1;
}
signed main() {
	int fz = 0, fm = 0; 
	int a, b; char ch;
	cin >> a >> ch >> b, fz = a, fm = b;
	while (cin >> a >> ch >> b) {
		int nowb = lcm(fm, b);
		a = a * (nowb / b);
		b = nowb;
		fz = fz * (nowb / fm);
		fm = nowb;
		fz += a;
		int t = gcd(fz, fm);
		fz /= t, fm /= t;
	}
	int t = gcd(fz, fm);
	fz /= t, fm /= t;
	if (fz % fm == 0) { 
		cout << fz / fm;
	}
	else {
		if (fz == 0) {
			cout << 0;
		}
		else {
			if (sgn(fz) == -sgn(fm)) {
				cout << "-" << abs(fz) << "/" << abs(fm);
			}
			else {
				cout << fz << "/" << fm;
			}
		}
	}
}
```
  - **作者：zhang_Jimmy (4星)**
    - **关键亮点**：详细分析了题目细节，包括读入方式、计算过程、约分及输出处理，代码注释详细，通过定义多个函数分别实现通分、约分功能，逻辑清晰。
    - **核心代码片段**：
```cpp
int lcm(int a, int b){
	return a / __gcd(a, b) * b;
}

void tongfen(){
	int t = lcm(ansfm, fm);
	int anssum = t / ansfm;
	int sum = t / fm;
	ansfz *= anssum;
	ansfm *= anssum;
	fz *= sum;
	fm *= sum;
}

void yuefen(){
	int t = __gcd(ansfz, ansfm);
	ansfz /= t;
	ansfm /= t;
}

signed main(){
	cin >> ansfz >> b >> ansfm;
	while(cin >> a >> fz >> b >> fm){
		tongfen();
		if(a == '+') ansfz += fz;
		else ansfz -= fz;
		yuefen();
	}
	yuefen();
	if(ansfm < 0) cout << -ansfz << "/" << -ansfm;
	else if(ansfm!= 1) cout << ansfz << "/" << ansfm;
	else cout << ansfz;
	return 0;
}
```

**最优关键思路或技巧**：利用C++自带的`__gcd`函数求最大公约数进行约分，避免数据溢出；通过求最小公倍数`lcm`实现通分；在输入时就进行约分处理，防止后续运算结果错误；对结果的分母为1、分子为0、分母为负等特殊情况进行单独处理。

**同类型题或类似算法套路**：此类题目主要考察分数运算，类似套路为定义数据结构表示分数，实现通分、约分函数，按运算规则处理输入并输出结果。还可拓展到分数的乘除运算等。

**推荐题目**：
  - P1075 [NOIP2012 普及组] 质因数分解
  - P1028 [NOIP2001 普及组] 数的计算
  - P1147 连续自然数和 

---
处理用时：54.91秒
# 题目信息

# 魔法照片

## 题目描述

一共有 $n$ 个人（以 $1\sim n$ 编号）向佳佳要照片，而佳佳只能把照片给其中的 $k$ 个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值 $W_i$。然后将初始权值从大到小进行排序，每人就有了一个序号 $D_i$（取值同样是 $1\sim n$）。按照这个序号对 $10$ 取模的值将这些人分为 $10$ 类。也就是说定义每个人的类别序号 $C_i$ 的值为 $(D_i-1)\bmod 10 +1$，显然类别序号的取值为 $1 \sim 10$。第 $i$ 类的人将会额外得到 $E_i$ 的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的 $k$ 个人，并输出他们的编号。**在排序中，如果两人的 $E_i$ 相同，编号小的优先。**

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 20000$，$1\leq k\leq n$，保证所有数据均在 `int` 范围之内。

## 样例 #1

### 输入

```
10 10
1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20
```

### 输出

```
10 9 8 7 6 5 4 3 2 1
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是按照题目要求，先对初始权值排序，再根据排序后的序号分类添加额外权值，最后再次排序并输出前k大的编号。主要算法要点在于排序操作，大部分题解使用STL的sort函数，部分使用手写排序如快排、选择排序、冒泡排序等。难点在于理解编号、序号和类别序号的区别，以及在排序时处理权值相同的情况。整体来看，多数题解思路清晰，但在代码可读性和优化程度上有所差异。

### 所选的题解
- **作者：CreeperK (赞：219)  星级：5星**
    - **关键亮点**：思路阐述极为清晰，通过具体例子详细展示解题过程，代码简洁明了，结构清晰，使用结构体和sort函数，符合常规解题思路。
    - **个人心得**：“这道题真的很绕……我交了四五次才最终AC。” 强调了题目理解上的难度。
    - **重点代码**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int e[12],n,k;
struct person{
    int w;
    int num;
    int d;
}p[20010];
int w_comp(const person &a,const person &b){
    if(a.w!=b.w)return a.w>b.w;
    return a.num<b.num;
}
int main(){
    scanf("%d%d",&n,&k);
    for(int i=0;i<10;i++)scanf("%d",&e[i]);
    for(int i=0;i<n;i++){
        scanf("%d",&p[i].w);
        p[i].num=i+1;
    }
    sort(p,p+n,w_comp);
    for(int i=0;i<n;i++){
        p[i].d=i%10;
        p[i].w+=e[p[i].d];
    }
    sort(p,p+n,w_comp);
    for(int i=0;i<k;i++)printf("%d ",p[i].num);
}
```
    - **核心实现思想**：定义结构体person存储每个人的权值、编号和类别，通过w_comp函数定义排序规则，先按权值从大到小，权值相同按编号从小到大。主函数中先读入数据并编号，第一次排序后分类并添加额外权值，最后再次排序并输出前k个编号。
- **作者：Aehnuwx (赞：34)  星级：4星**
    - **关键亮点**：代码简洁，逻辑清晰，同样使用结构体和sort函数，在保证功能的同时简化了代码量。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxN 20005
struct Node{
    int id,w;
}p[maxN];
int n,k,E[11];
bool cmp(Node a,Node b){
    if(a.w==b.w) return a.id<b.id;
    return a.w>b.w;
}
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=10;i++) scanf("%d",&E[i]);
    for(int i=0;i<n;i++){
        scanf("%d",&p[i].w);
        p[i].id=i+1;
    } 
    sort(p,p+n,cmp);
    for(int i=0;i<n;i++)
        p[i].w+=E[i%10+1];
    sort(p,p+n,cmp);
    for(int i=0;i<k;i++) printf("%d ",p[i].id);
    return 0;    
}
```
    - **核心实现思想**：定义结构体Node存储编号和权值，通过cmp函数定义排序规则。主函数中读入数据并编号，两次排序过程中，第一次排序后添加额外权值，最后输出前k个编号。
- **作者：zhaowangji (赞：20)  星级：4星**
    - **关键亮点**：代码简洁易懂，按照题目步骤依次实现，使用结构体和sort函数，注释详细，便于理解。
    - **个人心得**：“题目不是很难，但错了好多次，都怪样例太狡猾”，表明样例具有一定迷惑性。
    - **重点代码**：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,e[17],k;
struct node{
	int sum;
	int num;
}a[20007];
bool cmp(node x,node y)
{
	if(x.sum!=y.sum) return x.sum>y.sum;
	else return x.num<y.num;
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=10;i++)
	cin>>e[i];
	for(int i=1;i<=n;i++)
	cin>>a[i].sum,a[i].num=i;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
	a[i].sum+=e[(i-1)%10+1];
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=k;i++)
	cout<<a[i].num<<' ';
	return 0;
}
```
    - **核心实现思想**：定义结构体node存储权值和编号，cmp函数定义排序规则。主函数中读入数据，两次排序，第一次排序后按规则添加额外权值，最后输出前k个编号。

### 最优关键思路或技巧
- **数据结构选择**：使用结构体来存储每个人的编号和权值等信息，方便在排序过程中同时处理多个属性。
- **排序处理**：自定义排序比较函数，在权值相等时按照编号排序，确保符合题目要求。同时，利用STL的sort函数简化代码实现，提高效率。

### 可拓展思路
此类题目属于模拟与排序结合的问题，类似套路可应用于其他需要多轮排序并根据排序结果进行分类处理的场景。例如，根据学生成绩进行多轮排名，并根据排名给予不同奖励等。

### 相似知识点洛谷题目
- [P1923 【深基9.例1】选举学生会](https://www.luogu.com.cn/problem/P1923)：涉及对数据的排序和统计，与本题类似，需根据特定规则处理数据。
- [P1083 借教室](https://www.luogu.com.cn/problem/P1083)：结合了排序和二分查找，在处理数据时需要根据一定顺序进行判断，与本题排序处理思路有相通之处。
- [P2676 推销员](https://www.luogu.com.cn/problem/P2676)：需要对数据进行排序，并根据排序结果进行策略选择，与本题在数据处理和逻辑判断上有相似点。

### 个人心得摘录与总结
多位作者提到题目理解上有难度，如CreeperK交了四五次才AC，zhaowangji也因样例迷惑而多次出错。这表明此类题目需仔细理解题意，特别是编号、序号等概念容易混淆。同时，在处理权值相同的排序情况时要格外小心，确保符合题目要求。 

---
处理用时：51.06秒
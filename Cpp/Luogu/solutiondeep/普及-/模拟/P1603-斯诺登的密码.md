# 题目信息

# 斯诺登的密码

## 题目背景

根据斯诺登事件出的一道水题


## 题目描述

2013 年 X 月 X 日，俄罗斯办理了斯诺登的护照，于是他混迹于一架开往委内瑞拉的飞机。但是，这件事情太不周密了，因为 FBI 的间谍早已获悉他的具体位置——但这不是最重要的——最重要的是如果要去委内瑞拉，那么就要经过古巴，而经过古巴的路在美国的掌控之中。

丧心病狂的奥巴马迫降斯诺登的飞机，搜查时却发现，斯诺登杳无踪迹。但是，在据说是斯诺登的座位上，发现了一张纸条。纸条由纯英文构成：`Obama is a two five zero.`（以 `.` 结束输出，只有 $6$ 个单词+一个句号，句子开头如没有大写亦为合法）这句话虽然有点无厘头，但是警官陈珺骛发现这是一条极其重要的线索。他在斯诺登截获的一台笔记本中找到了一个 C++ 程序，输入这条句子后立马给出了相对应的密码。陈珺鹜高兴得晕了过去，身为警官的你把字条和程序带上了飞机，准备飞往曼哈顿国际机场，但是在飞机上检查的时候发现——程序被粉碎了！飞机抵达华盛顿只剩 $5$ 分钟，你必须在这 $5$ 分钟内编写（杜撰）一个程序，免受上司的 $10000000000 \bmod 10$ 大板。破译密码的步骤如下：

（1）找出句子中所有用英文表示的数字 $(\leq 20)$，列举在下：

正规：`one two three four five six seven eight nine ten eleven twelve`
           `thirteen fourteen fifteen sixteen seventeen eighteen nineteen             twenty`

非正规：`a both another first second third`。为避免造成歧义，`another` 算作 $1$ 处理。

（2）将这些数字平方后对 $100$ 取模，如 $00,05,11,19,86,99$。

（3）把这些两位数按数位排成一行，组成一个新数，如果开头为 $0$，就去 $0$。

（4）找出所有排列方法中最小的一个数，即为密码。

// 数据已经修正 By absi2011 如果还有问题请联系我


## 样例 #1

### 输入

```
Black Obama is two five zero .```

### 输出

```
425```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是按照题目要求，将输入句子中的英文数字转换为数字，平方后对100取模，再将结果按数位排成最小数。主要算法要点包括字符串处理、数字转换与排序。解决难点在于准确识别英文数字、处理数字的平方取模及按要求输出格式。多数题解采用打表方式存储英文数字与对应数值，用排序获取最小排列。部分题解在输出格式处理上有不同方式，如补零、去除前导零等。

### 所选的题解
- **作者：ZigZagKmp (5星)**
    - **关键亮点**：思路清晰，代码简洁，详细注释利于理解。使用`printf("%.2d",a[i])`巧妙处理输出格式，保证不足两位前面补0。利用贪心思想，通过`sort`排序实现数值从小到大输出。
    - **重点代码核心实现思想**：用两个数组`dic`和`di`分别存储英文数字及其对应平方取模值。循环读入单词，通过`strcmp`比较找到对应数值存入数组`a`，排序后按格式输出。
```cpp
#include<bits/stdc++.h>
using namespace std;
char dic[30][20]={"zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty","a","both","another","first","second","third"};
int di[30]={0,1,4,9,16,25,36,49,64,81,00,21,44,69,96,25,56,89,24,61,0,1,4,1,1,4,9};
unsigned long long int a[10],top,flag;
int i,j;
char s[100];
int main()
{
     for(i=1;i<=6;i++)
     {
          scanf("%s",&s);
          for(j=1;j<=26;j++)
          {
               if(!strcmp(s,dic[j]))
               {
                    a[++top]=di[j];
                    break;
               }
          }
      }
      sort(a+1,a+top+1);
      for(i=1;i<=top;i++)
      {
           if(flag)
           {
                printf("%.2d",a[i]);
           }
           else
           {
                if(a[i])
                { 
                     printf("%d",a[i]);
                     flag=1;
                }
            }
     }
     if(!flag)printf("0");
     return 0;
}
```
- **作者：Maktub (4星)**
    - **关键亮点**：使用`map<string, int>`进行打表，简洁高效，代码逻辑清晰。在处理输出格式时，明确指出除第一位外，比10小的数要补0。
    - **重点代码核心实现思想**：先定义`map`并赋值，循环读入单词，判断是否在`map`中，若存在则计算平方取模并存储，排序后按要求格式输出。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
map<string,int>q;
const int mx=66;
int top;
int st[mx];
string s;
int main(){
     q["one"]=1;q["two"]=2;q["three"]=3;q["four"]=4;q["five"]=5;q["six"]=6;q["seven"]=7;q["eight"]=8;q["nine"]=9;q["ten"]=10;
     q["eleven"]=11;q["twelve"]=12;q["thirteen"]=13;q["fourteen"]=14;q["fifteen"]=15;q["sixteen"]=16;q["seventeen"]=17;q["eighteen"]=18;q["nineteen"]=19;q["twenty"]=20;
     q["a"]=1;q["both"]=2;q["another"]=1;q["first"]=1;q["second"]=2;q["third"]=3;
     for(int i=1;i<=6;i++){
          cin>>s;
          if(q[s]){
               int k=q[s]*q[s]%100;
               if(k==0)continue;
               st[++top]=k;
          }
     }
     sort(st+1,st+top+1);
     cout<<st[1];
     for(int i=2;i<=top;i++){
          if(st[i]<10)cout<<0;
          cout<<st[i];
     }
     return 0;
}
```
- **作者：hsfzLZH1 (4星)**
    - **关键亮点**：详细解释了`map`和`string`容器的使用，对为何按字典序排序能得到最小密码进行了证明，有助于理解算法原理。
    - **重点代码核心实现思想**：定义`map`存储英文数字与对应数值，循环读入单词并转换为小写，判断是否在`map`中，存在则计算平方取模并存储为`string`，排序后按要求输出。
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<map>
#include<string>
using namespace std;
map<string,int>m;
int l,cur;
string s,ans[6];
int main()
{
    m["one"]=1;m["two"]=2;m["three"]=3;m["four"]=4;m["five"]=5;
    m["six"]=6;m["seven"]=7;m["eight"]=8;m["nine"]=9;m["ten"]=10;
    m["eleven"]=11;m["twelve"]=12;m["thirteen"]=13;m["fourteen"]=14;m["fifteen"]=15;
    m["sixteen"]=16;m["seventeen"]=17;m["eighteen"]=18;m["nineteen"]=19;m["twenty"]=20;
    m["a"]=1;m["both"]=2;m["another"]=1;m["first"]=1;m["second"]=2;m["third"]=3;
    for(int i=0;i<6;i++)
    {
        cin>>s;
        l=s.length();
        for(int j=0;j<l;j++)if(s[j]<='Z'&&s[j]>='A')s[j]+='a'-'A';
        if(m[s])
        {
            ans[cur]+=(m[s]*m[s]%100)/10+'0'; 
            ans[cur]+=(m[s]*m[s]%100)%10+'0';
            cur++;
        }
    }
    if(cur==0){cout<<0<<endl;return 0;}
    sort(ans,ans+cur);
    if(ans[0][0]=='0')cout<<ans[0][1];
    else cout<<ans[0];
    for(int i=1;i<cur;i++)cout<<ans[i];
    cout<<endl;
    return 0;
}
```

### 最优关键思路或技巧
- **数据结构选择**：使用`map`可高效实现英文数字到数值的映射，方便查找与转换。
- **输出格式处理**：如使用`printf("%.2d", num)`控制输出格式，自动在不足两位的数字前补0；或在代码逻辑中判断并手动补0，同时注意去除前导0。
- **排序应用**：利用`sort`函数对数值进行排序，以获取最小排列，符合题目要求。

### 可拓展思路
此类题目可拓展到更多复杂的字符串处理与数字转换场景，如不同进制转换、更多不规则单词映射等。类似算法套路包括先建立映射关系，再按特定规则处理数据，最后按要求输出。

### 相似知识点洛谷题目
- **P1012 [NOIP1998 提高组] 拼数**：同样涉及数字拼接以获取最值，需考虑数字顺序对结果的影响。
- **P1107 最大整数**：与本题类似，需对输入数字进行特定排序以得到最大整数，考察排序与字符串处理。
- **P1914 小书童——密码**：涉及字符串加密与解密，包含字符替换等字符串处理操作，与本题处理字符串并转换为特定结果思路相似。

### 个人心得摘录与总结
- **ZigZagKmp**：提到题目中第3和第4点较坑，强调了输出格式处理的重要性，如使用`printf("%.2d",a[i])`控制格式输出。总结在处理此类题目时，要特别留意输出格式要求，选择合适的输出方式。
- **bztMinamoto**：表示题解几乎看不懂，自己没用`map`也能做但过程繁琐，反映出不同方法在实现复杂度上的差异，鼓励尝试不同思路，同时也说明理解和运用合适数据结构的重要性。 

---
处理用时：72.17秒
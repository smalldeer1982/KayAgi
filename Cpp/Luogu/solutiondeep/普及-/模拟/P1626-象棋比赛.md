# 题目信息

# 象棋比赛

## 题目描述

有 $N$ 个人要参加国际象棋比赛，该比赛要进行 $K$ 场对弈。每个人最多参加两场对弈，最少参加零场对弈。每个人都有一个与其他人不相同的等级（用一个正整数来表示）。

在对弈中，等级高的人必须用黑色的棋子，等级低的人必须用白色的棋子。每个人最多只能用一次黑色的棋子和一次白色的棋子。为增加比赛的可观度，观众希望 $K$ 场对弈中双方的等级差的总和最小。

比如有 $7$ 个选手，他们的等级分别是 $30,17,26,41,19,38,18$，要进行 $3$ 场比赛。最好的安排是选手 $2$ 对选手 $7$，选手 $7$ 对选手 $5$，选手 $6$ 对选手 $4$。此时等级差的总和等于 $(18-17)+(19-18)+(41-38)=5$ 达到最小。

## 说明/提示

### 数据范围及约定

- 在 $90\%$ 的数据中，$1 \le N \le 3000$；
- 在 $100\%$ 的数据中，$1 \le N \le 100000$。

保证所有输入数据中等级的值小于 $10^9$，$1 \le K \le N-1$。

## 样例 #1

### 输入

```
7 3
30
17
26
41
19
38
18```

### 输出

```
5```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解的核心思路均为将选手等级从小到大排序，计算相邻等级的差值，再对差值排序，取前K个差值之和作为答案。此思路基于贪心策略，因为要使等级差总和最小，选择相邻等级的选手对弈是最优选择。
    - 算法要点：主要涉及排序算法和简单的数组操作。排序算法的选择影响时间复杂度，需根据数据范围选择合适的排序方式。
    - 解决难点：数据范围较大，$1 \le N \le 100000$，需选择高效的排序算法以避免超时。如冒泡排序和选择排序时间复杂度为$O(n^2)$，在大数据下效率低；快速排序平均时间复杂度为$O(nlogn)$，但最坏情况为$O(n^2)$，可能被卡；而归并排序和堆排序时间复杂度稳定为$O(nlogn)$。

    综合质量来看，多数题解思路清晰，但部分题解代码可读性欠佳或未充分考虑算法优化。整体无达到5星的题解，有部分题解可给到4星。

所选4星题解：
  - 作者：_LanFeng_ (4星)
    - 关键亮点：思路清晰简洁，代码直接明了，使用了STL中的sort函数进行排序，代码可读性较好。
    - 核心代码：
```cpp
int main()
{
    int n,k,i,a[100001],b[100001],ans=0;
    scanf("%d%d",&n,&k);
    for(i=1;i<=n;i++)
    scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    for(i=1;i<=n-1;i++)
    b[i]=a[i+1]-a[i];
    sort(b+1,b+n);
    for(i=1;i<=k;i++)
    ans+=b[i];
    printf("%d",ans);
    return 0;
}
```
核心实现思想：先读入选手等级，用sort排序，计算相邻等级差值存入新数组，再对差值数组排序，累加前K个差值得到答案。

  - 作者：Pengsibo (4星)
    - 关键亮点：不仅给出AC代码，还详细介绍了多种排序算法及其时间复杂度、特点，对排序算法进行了深入分析，有助于读者理解不同排序算法在本题中的应用。
    - 核心代码：
```cpp
int main()
{
    scanf("%d%d",&n,&k);
    for(register int i=1;i<=n;i++) scanf("%d",&x[i]);
    sort(x+1,x+n+1);
    for(register int i=2;i<=n;i++) y[i-1]=x[i]-x[i-1];
    sort(y+1,y+n);
    for(register int i=1;i<=k;i++) ans+=y[i];
    printf("%d",ans);
    return 0;
}
```
核心实现思想：与上一题解类似，读入数据后排序，计算相邻等级差值并再次排序，累加前K个差值。

  - 作者：我太强了 (4星)
    - 关键亮点：针对快排不稳定的问题，采用稳定且时间复杂度为$O(nlogn)$的归并排序，并详细给出归并排序代码，对理解归并排序在本题中的应用有帮助。
    - 核心代码：
```cpp
void msort(int l,int r)
{
    if(l==r) return;
    int mid=(l+r)/2;
    msort(l,mid); msort(mid+1,r);
    int left=l,right=mid+1,cnt=l;
    while(left<=mid&&right<=r)
    if(a[left]<=a[right]) 
    b[cnt++]=a[left++];
    else b[cnt++]=a[right++];
    while(left<=mid) b[cnt++]=a[left++];
    while(right<=r) b[cnt++]=a[right++];
    for(int i=l;i<=r;i++) a[i]=b[i];
    return;
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    msort(1,n); 
    for(int i=1;i<=n-1;i++) cha[i]=a[i+1]-a[i];
    for(int i=1;i<=n-1;i++) a[i]=cha[i];
    msort(1,n-1); 
    for(int i=1;i<=k;i++) ans+=a[i];
    printf("%d\n",ans);
    return 0;
 } 
```
核心实现思想：通过归并排序对选手等级和等级差值分别排序，最终累加前K个差值得到结果。

最优关键思路或技巧：
    - **思维方式**：采用贪心策略，直观地认识到选择相邻等级选手对弈能使等级差总和最小。
    - **算法优化**：根据数据范围$1 \le N \le 100000$，选择时间复杂度为$O(nlogn)$的排序算法，如归并排序、堆排序或使用STL的sort函数（通常基于快速排序优化，平均时间复杂度$O(nlogn)$），避免使用$O(n^2)$的排序算法。

可拓展之处：同类型题常考察贪心策略与排序算法的结合，类似套路为根据题目条件确定贪心选择，再通过排序实现。例如在一些资源分配、任务调度问题中，先确定按某种规则（如时间、权重等）排序，再依据贪心策略进行分配或调度。

推荐洛谷题目：
    - P1094 [NOIP2007 普及组] 纪念品分组
    - P1199 [NOIP2010 普及组] 三国游戏
    - P1223 排队接水 

---
处理用时：40.21秒
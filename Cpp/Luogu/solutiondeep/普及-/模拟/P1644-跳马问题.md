# 题目信息

# 跳马问题

## 题目背景

在爱与愁的故事第一弹第三章出来前先练练四道基本的回溯/搜索题吧……


## 题目描述

中国象棋半张棋盘如图 $1$ 所示。马自左下角 $(0,0)$ 向右上角 $(m,n)$ 跳。规定只能往右跳，不准往左跳。比如图 $1$ 中所示为一种跳行路线，并将路径总数打印出来。

![](https://cdn.luogu.com.cn/upload/image_hosting/8gkasdvs.png)


## 说明/提示

对于 $100\%$ 的数据：$n, m\leq 18$


## 样例 #1

### 输入

```
4 8```

### 输出

```
37```

# AI分析结果

这道跳马问题的题解主要涉及深度优先搜索（DFS）、回溯算法和动态规划（DP）三种思路。
1. **DFS和回溯算法**：
    - **思路**：从起点(0, 0)出发，按照马的走法（右上、右下各两种）递归探索所有可能路径，当到达终点(m, n)时，路径总数加1；若越界则返回。
    - **算法要点**：用数组记录马的走法方向，递归函数中判断当前位置是否为终点或越界，然后继续向可行方向搜索。
    - **解决难点**：准确判断边界条件，避免无效搜索。
2. **动态规划**：
    - **思路**：利用二维数组DP[i][j]记录从起点到(i, j)位置的路径总数，通过状态转移方程从已知状态推导出未知状态。
    - **算法要点**：确定状态转移方程，如DP[i][j]=DP[i - 1][j - 2]+DP[i - 1][j + 2]+DP[i - 2][j - 1]+DP[i - 2][j + 1]，并注意边界处理。
    - **解决难点**：根据题目限制确定正确的状态转移方向和边界条件，防止数组越界。

以下是对各题解的简要评分：
1. **作者晓菜**：思路清晰，代码简洁，直接给出DFS的完整代码及详细注释，4星。
2. **作者LW_h_FP**：同样采用DFS，代码逻辑清晰，通过数组表示走法，3星。
3. **作者t162**：详细阐述DP思路及状态转移方程，对循环顺序的坑点有深入分析，4星。
4. **作者zjing**：回溯算法，代码简单明了，但解释较少，3星。
5. **作者石破天惊**：DFS思路，代码中有变量跟踪器，但整体代码稍显复杂，3星。
6. **作者decoqwq**：递推思路，代码实现简单，但未对思路详细解释，3星。
7. **作者Hanabi_BNUAZ**：DFS代码有部分错误，思路阐述不够清晰，2星。
8. **作者xdc呀**：DFS思路，代码简洁但解释较简略，3星。
9. **作者EarthGiao**：记忆化搜索，代码较复杂且有部分错误，2星。
10. **作者Randyhoads**：DP思路，代码实现和解释较清晰，3星。
11. **作者_Qer**：DFS两种写法对比，但整体解释较简略，3星。
12. **作者「QQ红包」**：递推思路，给出代码但未用C++，3星。
13. **作者JackcreaM**：DFS思路，代码较啰嗦，2星。
14. **作者doby**：提出DP和DFS，但只给出DFS代码且有错误，2星。
15. **作者RED_Singer**：DFS思路，代码有详细注释，3星。
16. **作者HeartBlock_Love**：代码复杂且有错误，未按题目起点，2星。
17. **作者eaten_apple**：DFS思路，代码有注释，3星。
18. **作者ljw2005**：DFS常规写法，代码较清晰，3星。
19. **作者yangshirui**：代码复杂且有错误，未按题目要求，2星。
20. **作者shenyufan**：递推思路，代码简洁但解释少，3星。
21. **作者iCaesar**：DFS思路，代码实现较复杂，2星。
22. **作者ZYR_**：回溯算法，Pascal代码，思路较清晰，3星。
23. **作者Drug__Lover**：DFS思路，代码有注释，3星。
24. **作者蓝莲花__**：DP思路，代码较清晰，3星。

评分较高（≥4星）的题解：
- **作者晓菜**：
  - **星级**：4星
  - **关键亮点**：思路阐述详细，直接给出简洁的DFS完整代码及注释，对搜索和终止部分重点突出。
  - **核心代码**：
```cpp
void dfs(int a, int b) {
    if (a < 0 || a > n || b > m) return;
    if (a == n && b == m) {
        t++;
    }
    else {
        dfs(a + 1, b + 2);
        dfs(a + 2, b + 1);
        dfs(a - 2, b + 1);
        dfs(a - 1, b + 2);
    }
}
```
  - **核心思想**：递归函数dfs中，先判断是否越界，若是则返回；若到达终点则路径总数t加1；否则向四个可行方向继续搜索。
- **作者t162**：
  - **星级**：4星
  - **关键亮点**：详细讲解DP思路，给出状态转移方程，并对循环顺序的重要性有深入分析。
  - **个人心得**：“上述代码中的两重循环是不能交换位置的，因为题目中提到不准往左跳，但并没有规定不准往上跳，这是本题的一大坑点。如果先遍历行的话，状态转移方程就变成了这样……这时候的DP[i][j]已经涉及到了未处理的范围，结果自然就不对了。血的教训。”
  - **核心代码**：
```cpp
int dp[20][20];
int main() {
    int n, m;
    cin >> m >> n;
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            if (i == j && j == 0) dp[i][j] = 1;
            else if (i == 0 && j!= 0) dp[i][j] = 0;
            else {
                if (i > 1) {
                    if (j > 0) dp[i][j] += dp[i - 2][j - 1];
                    if (j!= m) dp[i][j] += dp[i - 2][j + 1];
                }
                if (j > 1) dp[i][j] += dp[i - 1][j - 2];
                if (j < m - 1) dp[i][j] += dp[i - 1][j + 2];
            }
        }
    }
    cout << dp[n][m];
    return 0;
}
```
  - **核心思想**：通过两重循环遍历每个位置，根据状态转移方程计算从起点到当前位置的路径总数，最后输出终点的路径总数。

最优关键思路或技巧：
1. **DFS**：利用递归简洁地探索所有可能路径，关键在于准确判断边界条件和终点条件。
2. **DP**：通过状态转移方程从已知状态推导出未知状态，减少重复计算，关键在于确定正确的状态转移方程和边界处理。

可拓展之处：同类型题可涉及不同棋盘形状、不同棋子走法、增加限制条件等。类似算法套路包括用数组记录状态、利用递归或迭代实现状态转移等。

推荐洛谷题目：
1. P1002 过河卒：同样是棋盘上棋子移动路径计数问题，可使用递推或DP解决。
2. P1219 [USACO1.5]八皇后 Checker Challenge：经典回溯算法题目，可锻炼回溯的应用能力。
3. P1120 小木棍［数据加强版］：深度优先搜索的应用，通过剪枝优化搜索过程。 

---
处理用时：54.63秒
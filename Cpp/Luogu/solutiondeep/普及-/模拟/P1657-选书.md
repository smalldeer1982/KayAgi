# 题目信息

# 选书

## 题目描述

学校放寒假时，信息学奥赛辅导老师有 $1,2,3,\cdots,x$ 本书，要分给参加培训的 $x$ 个人，每人只能选一本书，但是每人有两本喜欢的书。

老师事先让每个人将自己喜欢的书填写在一张表上。然后根据他们填写的表来分配书本，希望设计一个程序帮助老师求出所有可能的分配方案，使每个学生都满意。

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le x\le 20$。


$\text{update 2022/03/07}$，阮行止

本题原始数据中，最后一个数据点的 x 为 $0$，期望输出为  $0$。考虑到这个数据不合理，予以删去。现在提交这个题目不会遇到 $x=0$ 的数据点。




## 样例 #1

### 输入

```
5
1 3
4 5
2 5
1 4
3 5```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解采用深度优先搜索（DFS）。一种是以产生书的全排列为基础（如_xcc_的题解），在生成过程中排除不符合喜欢列表的方案；另一种是从第一个人开始，依次考虑每个人选择喜欢的书（如_louhc_、Baihua等题解）。还有部分题解采用状态压缩优化搜索（_louhc_）、二进制枚举（Lolierl、Creeper_LKF），以及图论方法（Hope2075）。
    - 算法要点：DFS过程中需记录书是否被选（如使用标记数组），判断当前选择是否满足每人喜欢两本书的条件。状态压缩通过二进制数表示书的选取状态以优化空间和时间复杂度；二进制枚举则枚举每个人选择两本喜欢书中的哪一本的所有情况。图论方法将问题转化为为图的边选择方向使每个点入度为1 。
    - 解决难点：如何在搜索过程中有效剪枝以减少运算量，以及处理好状态的记录与回溯。如在生成排列时每增加一个数就检查是否符合条件，不符合则立即更换。
    - 整体来看，大部分题解思路围绕搜索展开，部分通过优化手段提升效率。但部分题解代码可读性欠佳或未充分优化。

所选的题解：
  - 作者：_xcc_ (★★★★)
    - 关键亮点：思路清晰，直接采用DFS产生书的全排列，并在过程中利用喜欢列表进行剪枝。代码简洁明了，结构清晰。
    - 核心代码：
```cpp
void so(int i)                           //dfs产生全排列
{
    int j;
    for(j=1;j<=x;j++)
    {
        if(flag[j]&&like[i][j]){         //此书未选且第i个人喜欢这本书
            flag[j]=0;
            book[i]=j;
            if(i==x) s++;
                else so(i+1);            //继续列举第i+1个人的书
            flag[j]=1;                   //还原与回溯
            book[i]=0;
        }
    }
}
```
核心实现思想：通过DFS枚举每个人可选的书，当某个人选了一本书后，标记该书已选，继续递归下一个人。若所有人都选到满意的书则方案数加一，最后通过回溯恢复状态，尝试其他方案。
  - 作者：_louhc_ (★★★★)
    - 关键亮点：引入状态压缩的思想，通过二进制数表示书的选取状态，减少空间复杂度，同时在一定程度上优化时间复杂度，提供了一种新颖的解题视角。
    - 个人心得：提到状态压缩是很好的搜索辅助工具，虽在此题中用数组可能更快更方便，但可作为状态压缩的练习。
    - 核心代码：
```cpp
void dfs( int s, int t ){
	if ( s > n ){
		if ( t == ( 1 << ( n + 1 ) ) - 2 )//以防万一
			ans++;
		return;
	}
	if ( ( ( 1 << a[s][0] ) & t ) == 0 )
		dfs( s + 1, ( 1 << a[s][0] ) | t );//简单的搜索
	if ( ( ( 1 << a[s][1] ) & t ) == 0 )
		dfs( s + 1, ( 1 << a[s][1] ) | t ); 
}
```
核心实现思想：用DFS搜索，`s`表示当前处理的人的编号，`t`用二进制表示书的选取状态。每次递归时，判断当前人喜欢的两本书是否已被选，若未被选则更新状态并继续递归下一人。
  - 作者：Hope2075 (★★★★)
    - 关键亮点：巧妙运用图论知识，将问题转化为图的边方向选择问题，通过分析图的连通块性质得出答案的计算方法，时间复杂度降为$O(n)$ ，优化效果显著。
    - 核心代码：
```cpp
void dfs(int id,int p){
	gid[id]=p;
	for(int i=head[id];i;i=next[i]){
		if(gid[ver[i]])continue;
		dfs(ver[i],p); 
	}
}
//...
for(int i=1;i<=n;i++){//建图
	a=read();
	b=read();
	add(a,b);
}
for(int i=1;i<=n;i++){//DFS求每个点所属的连通块编号
	if(!gid[i])dfs(i,i);
}
for(int i=1;i<=n;i++){//统计每个连通块内的信息
	cnt[gid[i]]++;
	cdeg[gid[i]]+=deg[i];
}
for(int i=1;i<=n;i++){
	if(cnt[i]*2!=cdeg[i]){//判断不合法情况
		printf("0\n");
		return 0;
	}
	if(cnt[i]!=0)ans=ans*2%998244353;//计算答案
}
```
核心实现思想：先建图，通过DFS确定每个点所属连通块，统计连通块内点的度数和数量，判断每个连通块是否满足边数等于点数的条件，若满足则根据连通块数量计算答案。

最优关键思路或技巧：
 - 图论转化思路（Hope2075的题解）将原问题巧妙转化为图论问题，利用图的连通块性质高效计算答案，极大优化时间复杂度。
 - 状态压缩优化（_louhc_的题解）在搜索过程中，使用状态压缩记录状态，减少空间复杂度，并在一定程度上优化时间复杂度。

可拓展之处：此类题目属于组合分配问题，类似的算法套路还可应用于任务分配、资源调度等场景。可拓展到更复杂的限制条件，如每个人喜欢多本书，或者书有不同属性限制等。

推荐题目：
 - P1120 小木棍［数据加强版］：同样是利用DFS搜索，并需要合理剪枝优化。
 - P1433 吃奶酪：通过状态压缩优化的搜索问题，与本题部分思路相似。
 - P1731 单词接龙：需要利用DFS搜索，并处理好字符串的连接条件，和本题搜索思路有相通之处。

个人心得摘录与总结：
 - _louhc_：提到状态压缩是搜索辅助工具，虽本题用数组可能更优，但可作为状态压缩练习，强调了状态压缩在搜索题中的应用价值及本题的练习意义。 

---
处理用时：56.70秒
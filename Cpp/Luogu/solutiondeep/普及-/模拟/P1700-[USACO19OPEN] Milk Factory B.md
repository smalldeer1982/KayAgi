# 题目信息

# [USACO19OPEN] Milk Factory B

## 题目描述

牛奶生意正红红火火！Farmer John 的牛奶加工厂内有 $N$ 个加工站，编号为 $1\dots N$（$1\le N\le 100$），以及 $N−1$ 条通道，每条连接某两个加工站。（通道建设很昂贵，所以 Farmer John 选择使用了最小数量的通道，使得从每个加工站出发都可以到达所有其他加工站）。

为了创新和提升效率，Farmer John 在每条通道上安装了传送带。不幸的是，当他意识到传送带是单向的已经太晚了，现在每条通道只能沿着一个方向通行了！所以现在的情况不再是从每个加工站出发都能够到达其他加工站了。

然而，Farmer John 认为事情可能还不算完全失败，只要至少还存在一个加工站 $i$ 满足从其他每个加工站出发都可以到达加工站 $i$。注意从其他任意一个加工站 $j$ 前往加工站 $i$ 可能会经过 $i$ 和 $j$ 之间的一些中间站点。请帮助 Farmer John 求出是否存在这样的加工站 $i$。

## 样例 #1

### 输入

```
3
1 2
3 2```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解均围绕在有向图中寻找所有点都能到达的编号最小的点这一问题展开。思路主要有正向暴力搜索、反向建图搜索以及使用Floyd算法。各题解在算法要点和解决难点上各有不同：
 - **正向暴力搜索**：通过从每个点出发进行搜索，统计每个点能被到达的次数（如HasNoName、jess1ca1o0g3、sssscy_free_stdio、_little_Cabbage_、xu_zhihao的题解），难点在于搜索的实现和结果的判断。
 - **反向建图搜索**：yhx0322的题解利用反向建图，将“哪些点能走到x点”转化为“反向建图后x点能走到哪些点”，提高了效率。
 - **Floyd算法**：gey666的题解使用Floyd算法标记每两点之间是否有路，通过枚举中转点更新邻接矩阵。

综合质量来看，各题解在思路清晰度、代码可读性和优化程度上存在差异。

### 所选的题解
 - **作者：HasNoName (5星)**
    - **关键亮点**：思路清晰，代码简洁明了。通过数组统计每个点能被走到的数量，从每个点出发进行DFS搜索，实现直接且易懂。
    - **核心代码**：
```cpp
void dfs(int x) {
    vis[x] = 1;
    for (int i = he[x]; i; i = e[i].ne) {
        int y = e[i].to;
        if (!vis[y]) {
            w[y]++;
            dfs(y);
        }
    }
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n, x, y;
    cin >> n;
    for (int i = 1; i < n; i++) {
        cin >> x >> y;
        add(x, y);
    }
    for (int i = 1; i <= n; i++) {
        memset(vis, 0, sizeof(vis));
        dfs(i);
    }
    for (int i = 1; i <= n; i++) {
        if (w[i] == n - 1) {
            cout << i << '\n';
            return 0;
        }
    }
    cout << "-1\n";
    return 0;
}
```
    - **核心思想**：`dfs`函数实现从一个点出发的深度优先搜索，更新能到达点的被到达次数。主函数中先建图，然后从每个点出发搜索，最后判断每个点的被到达次数是否为n - 1 。
 - **作者：yhx0322 (5星)**
    - **关键亮点**：巧妙运用反向建图的技巧，降低时间复杂度，提高效率。代码结构清晰，逻辑连贯。
    - **核心代码**：
```cpp
void dfs(int x) {
    for (int i = pre[x]; i; i = a[i].next) {
        int to = a[i].to;
        if (!f[to]) {
            f[to] = true;
            dfs(to);
        }
    }
}
int main() {
    cin >> n;
    for (int i = 1; i < n; i++) {
        cin >> x >> y;
        add(y, x);
    }
    bool pd = true;
    for (int i = 1; i <= n; i++) {
        memset(f, false, sizeof(f));
        dfs(i);
        pd = true;
        for (int j = 1; j <= n; j++) {
            if (i!= j &&!f[j]) {
                pd = false;
                break;
            }
        }
        if (pd) return cout << i << '\n', 0;
    }
    cout << -1 << '\n';
    return 0;
}
```
    - **核心思想**：`dfs`函数从一个点出发进行深度优先搜索，标记能到达的点。主函数中反向建图后，从每个点出发搜索，判断是否所有点都能被当前点到达。
 - **作者：jess1ca1o0g3 (4星)**
    - **关键亮点**：采用邻接表存储图结构，利用桶记录每个点被搜到的次数，思路简洁，代码实现较为清晰。
    - **核心代码**：
```cpp
void dfs(int u) {
    if (vis[u]) return;
    vis[u] = 1;
    for (int i = 0; i < g[u].size(); i++) {
        f[g[u][i]]++;
        dfs(g[u][i]);
    }
}
void solve() {
    scanf("%d", &n);
    f.resize(n + 1, 0);
    g.resize(n + 1);
    for (int i = 1; i < n; i++) {
        scanf("%d%d", &u, &v);
        g[u].push_back(v);
    }
    for (int i = 1; i <= n; i++) {
        memset(vis, 0, sizeof(vis));
        dfs(i);
    }
    for (int i = 1; i <= n; i++) {
        if (f[i] == n - 1) {
            printf("%d", i);
            return;
        }
    }
    printf("-1");
}
```
    - **核心思想**：`dfs`函数从一个点出发进行深度优先搜索，更新对应点在桶中的被搜到次数。`solve`函数中先建图，然后从每个点出发搜索，最后判断桶中每个点的被搜到次数是否为n - 1 。

### 最优关键思路或技巧
反向建图是一种高效的优化技巧，将原问题转化为更易解决的形式，减少搜索的复杂度。正向搜索时从每个点出发遍历，时间复杂度较高；而反向建图后只需从每个点出发一次，就能判断该点是否能被其他所有点到达。

### 可拓展思路
此类题目属于图论中关于连通性判断的问题。类似套路可应用于其他判断特定点与其他点连通关系的题目，例如寻找图中的割点、桥等。还可拓展到加权图，考虑路径权重等因素。

### 相似知识点洛谷题目
 - **P1330 封锁阳光大学**：涉及图的染色和连通性判断，需要判断二分图的可行性。
 - **P1126 机器人搬重物**：利用图的广度优先搜索解决路径规划问题，与本题搜索思路相关。
 - **P2731 [USACO3.3]骑马修栅栏 Riding the Fences**：需要在图中寻找欧拉路径，考察图论基础知识和搜索算法。

### 个人心得摘录与总结
暂无个人心得相关内容。 

---
处理用时：58.51秒
# 题目信息

# 东风谷早苗

## 题目描述

在幻想乡，东风谷早苗是以高达控闻名的高中生宅巫女。某一天，早苗终于入手了最新款的钢达姆模型。作为最新的钢达姆，当然有了与以往不同的功能了，那就是它能够自动行走，厉害吧（好吧，我自重）。早苗的新模型可以按照输入的命令进行移动，命令包含 $\verb|E|$、$\verb|S|$、$\verb|W|$、$\verb|N|$ 四种，分别对应四个不同的方向，依次为东、南、西、北。执行某个命令时，它会向着对应方向移动一个单位。作为新型机器人，自然不会只单单执行一个命令，它可以执行命令串。对于输入的命令串，每一秒它会按照命令行动一次。而执行完命令串最后一个命令后，会自动从头开始循环。在 $0$ 时刻时早苗将钢达姆放置在了 $(0,0)$ 的位置，并且输入了命令串。她想要知道 $T$ 秒后钢达姆所在的位置坐标。

假设当前钢达姆的位置是 $(x,y)$。那么对于四种方向的移动，它坐标的改变分别为：

- 向东移动，坐标改变改变为 $(x+1,y)$；
- 向南移动，坐标改变改变为 $(x,y-1)$；
- 向西移动，坐标改变改变为 $(x-1,y)$；
- 向北移动，坐标改变改变为 $(x,y+1)$。




## 说明/提示

用 $|S|$ 表示早苗输入的命令串的长度。

- 对于 $60\%$ 的数据，$T\le 5\times 10^5$，$|S|\le 5\times 10^3$。
- 对于 $100\%$ 的数据，$T \le 2\times 10^9$，$|S|\le  5\times 10^3$。


## 样例 #1

### 输入

```
NSWWNSNEEWN
12
```

### 输出

```
-1 3```

# AI分析结果

• 综合分析与结论：该题目要求计算在给定命令串循环执行的情况下，T秒后钢达姆的位置坐标。由于T值较大，直接暴力模拟会超时，题解思路主要围绕优化算法，利用命令串循环执行的特点，通过计算一次命令串执行后坐标的变化，再结合循环次数和剩余步数来得出最终坐标。

所选的题解：
  - 作者：RKcer21 (5星)
    - 关键亮点：思路清晰，不仅给出不同阶段的代码，从最初直接模拟（虽因gets函数在Linux评测环境问题及大数据超时），到改进输入方式，再到针对大数据优化，记录每轮运动方式并结合剩余步骤模拟，逐步优化，代码可读性高。
    - 个人心得：提到gets在Linux评测环境会出问题，如NOIP也是用Linux评测。
    - 重点代码核心实现思想：先记录每一轮命令执行后x和y的变化量xx和yy，再模拟剩余步数，最后根据循环次数和剩余步数计算最终坐标。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001],xx,yy;
string c;
int i,j,k,n,m,t,x,y;
  int main()
{
  cin>>c;
  cin>>n;
  m=c.length();
  for (i=0; i<m; i++)
    if (c[i%m]=='E') xx+=1;
        else if (c[i%m]=='S') yy-=1;
          else if (c[i%m]=='W') xx-=1;
            else yy+=1;
for (i=0; i<n%m; i++)
     if (c[i%m]=='E') x+=1;
        else if (c[i%m]=='S') y-=1;
          else if (c[i%m]=='W') x-=1;
            else y+=1; 
cout<<x+n/m*xx<<' '<<y+n/m*yy;
return 0;
}
```
  - 作者：VenusM1nT (4星)
    - 关键亮点：先指出暴力做法会TLE并给出暴力代码，然后清晰阐述优化思路，即计算每轮移动方式和移动轮数，再模拟剩余步骤，代码简洁明了。
    - 重点代码核心实现思想：利用数组dx和dy记录每个方向的位移变化，计算每一轮的移动量cx和cy，根据循环次数r更新坐标，最后模拟剩余步数。
```cpp
#include<bits/stdc++.h>
using namespace std;
int dx[105],dy[105];
int cx,cy,n,x,y;
string s;
int main()
{
    dx['E']=1;
    dy['S']=-1;
    dx['W']=-1;
    dy['N']=1;
    cin >> s >> n; 
    for(int i=0;i<s.size();i++) cx+=dx[s[i]],cy+=dy[s[i]];
    int r=n/s.size();
    x+=r*cx;
    y+=r*cy;
    n%=s.size();
    for(int i=0;i<n;i++) x+=dx[s[i]],y+=dy[s[i]];
    cout << x << " " << y;
}
```
  - 作者：与我常在 (4星)
    - 关键亮点：提出O(字符串长度)的做法，通过记录走i步后的坐标，利用循环规律推出T步后的坐标，思路独特，代码简洁高效。
    - 重点代码核心实现思想：通过循环记录走每一步后的坐标变化，最后根据T与命令串长度的关系，计算最终坐标。
```cpp
#include <cstdio>
#include <cstring>

const int N = 5010;

int t, nx, ny;
int x[N], y[N];
char a[N];

int main() {
	scanf("%s", a + 1);
	scanf("%d", &t);
	
	int len = strlen(a + 1);
	for(int i = 1; i <= len; i ++) {
		if(a[i] == 'E') x[i] = ++ nx, y[i] = ny;
		else if(a[i] == 'S') x[i] = nx, y[i] = -- ny;
		else if(a[i] == 'W') x[i] = -- nx, y[i] = ny;
		else if(a[i] == 'N') x[i] = nx, y[i] = ++ ny;
	}
	
	int p = t % len;
	int q = t / len;
	printf("%d %d\n", x[len] * q + x[p], y[len] * q + y[p]);
	
	return 0;
}
```
最优关键思路或技巧：利用命令串循环执行的周期性，先计算一次命令串执行完后坐标的净变化量，再根据T与命令串长度的整除关系得到完整循环次数，乘以净变化量得到大部分移动后的坐标，最后模拟剩余步数得到最终坐标。这样将原本O(T)的时间复杂度优化到接近O(命令串长度)。

可拓展之处：此类题属于周期性模拟优化问题，类似套路可用于解决具有重复操作且数据量较大的模拟场景，如周期性的任务调度、循环序列的状态计算等。

推荐洛谷题目：
  - P1089 [NOIP2004 提高组] 津津的储蓄计划
  - P1149 火柴棒等式
  - P1028 [NOIP2001 普及组] 数的计算 

---
处理用时：51.17秒
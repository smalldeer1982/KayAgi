# 题目信息

# 离开中山路

## 题目背景

《爱与愁的故事第三弹·shopping》最终章。


## 题目描述

爱与愁大神买完东西后，打算坐车离开中山路。现在爱与愁大神在 $x_1,y_1$ 处，车站在 $x_2,y_2$ 处。现在给出一个 $n \times n(n \le 1000)$ 的地图，$0$ 表示马路，$1$ 表示店铺（不能从店铺穿过），爱与愁大神只能垂直或水平着在马路上行进。爱与愁大神为了节省时间，他要求最短到达目的地距离（每两个相邻坐标间距离为 $1$）。你能帮他解决吗？


## 说明/提示


对于 $20\%$ 数据，满足 $1\leq n \le 100$。

对于 $100\%$ 数据，满足 $1\leq n \le 1000$。

## 样例 #1

### 输入

```
3
001
101
100
1 1 3 3```

### 输出

```
4```

# AI分析结果

这道题主要求在给定地图中从起点到终点的最短路径，多数题解采用BFS算法，少数使用A*、SPFA等算法。以下是对各题解的分析：
1. **思路与算法要点**：
    - **BFS算法**：利用队列先进先出特性，从起点开始向四周扩展搜索，记录每个点到起点的步数，直到找到终点。如作者Cult_style、_yjh等众多题解采用此方法。
    - **A*算法**：在BFS基础上加入估值函数，通过计算每个格子的优先级来决定扩展顺序，以提高搜索效率。如作者Ciyang、YellowBean_Elsa的题解。
    - **SPFA算法**：通过不断松弛相邻节点的距离来更新最短路径，如作者Create_Random、codesonic的题解。
2. **解决难点**：
    - **地图读入**：地图数据无空格，需用字符数组或字符串读入，如`scanf("%s", a[i]+1)`或`cin >> str`等方式。
    - **边界判断与标记**：搜索时需判断是否越界、是否为障碍物以及是否已访问，避免重复搜索，如使用`if(x >= 1 && x <= n && y >= 1 && y <= n &&!vis[x][y] && a[x][y] == '0')`条件判断。
    - **记录路径长度**：使用数组记录每个点到起点的步数，如`vis[xxx][yyy]=vis[xx][yy]+1`。
3. **题解评分**：
    - **作者Cult_style**：思路清晰，详细解释BFS原理及队列操作，代码规范，可读性强，五星。
    - **作者_yjh**：先介绍STL队列用法，结合普通迷宫问题对比，阐述找最短路径思路，四星。
    - **作者Ciyang**：详细介绍A*算法并与BFS对比，代码完整，但部分表述较复杂，四星。
4. **最优关键思路或技巧**：
    - **BFS算法**：利用队列实现层次遍历，确保找到的路径为最短。
    - **A*算法**：合理设计估值函数，如曼哈顿距离与当前步数之和，提高搜索效率。
5. **拓展思路**：
    - **同类型题**：如洛谷P1141 01迷宫、P1314 聪明的质监员、P2895 [USACO08FEB]Meteor Shower S，均涉及在地图或网格中搜索路径或计算距离等问题。
    - **类似算法套路**：可将BFS与其他算法结合，如双向BFS，从起点和终点同时搜索，相遇时得到最短路径，可降低时间复杂度。
6. **推荐题目**：
    - **P1141 01迷宫**：给定01矩阵，求从每个点出发能到达的不同01区域数量，需用BFS搜索。
    - **P1314 聪明的质监员**：在给定序列上进行区间统计和二分查找，与本题在数据处理和搜索思路上有相似之处。
    - **P2895 [USACO08FEB]Meteor Shower S**：在地图上躲避流星雨并到达指定地点，同样用BFS寻找最短路径。
7. **个人心得摘录**：
    - **作者Ciyang**：学习A*算法时，因对算法理解不深刻，做题只能拿40分，经深入研究后找到问题并AC，强调深入理解算法原理的重要性。
    - **作者Warriors_Cat**：一开始提交TLE，经调试后AC，提醒注意代码优化和细节处理。
    - **作者doyo**：学习搜索时因教练未示范代码，导致理解困难，后借助STL掌握搜索，突出实践和代码示例对学习算法的帮助。

### 所选题解
- **作者Cult_style（五星）**
    - **关键亮点**：对BFS算法讲解细致，从队列基础操作到BFS具体实现，逐步阐述，代码注释详尽，便于理解。
    - **核心代码**：
```cpp
void bfs(int x,int y){
    vis[x][y]=1;
    q.push((node){x,y});
    while(q.size()!=0){
        int xx=q.front().x;
        int yy=q.front().y;
        q.pop();
        for(int i=0;i<4;i++){
            int xxx=xx+h[i];
            int yyy=yy+s[i];
            if(check(xxx,yyy)){
                vis[xxx][yyy]=vis[xx][yy]+1;
                q.push((node){xxx,yyy});
            }
        }
    }
}
```
    - **核心思想**：从起点开始，将其加入队列并标记。循环处理队列中的点，取出队首点，向四个方向扩展，若新点合法（未越界、非障碍物、未访问），则记录步数并加入队列。
- **作者_yjh（四星）**
    - **关键亮点**：先详细介绍STL队列用法，再通过普通迷宫问题引入本题思路，逻辑连贯，代码简洁明了。
    - **核心代码**：
```cpp
int bfs(int sx,int sy)
{
    q.push((Pos){sx,sy});
    vis[sx][sy]=true;
    while(!q.empty())
    {
        x=q.front().x; y=q.front().y;
        q.pop();
        if(x==t_a&&y==t_b) return dis[x][y];
        for(int i=0;i<4;i++)
        {
            tx=x+dx[i];
            ty=y+dy[i];
            if(tx<=0||tx>n||ty<=0||ty>n) continue;
            if(mp[tx][ty]=='1'||vis[tx][ty]==true) continue;
            dis[tx][ty]=dis[x][y]+1;
            vis[tx][ty]=true;
            q.push((Pos){tx,ty});
        }
    }
    return -1;
}
```
    - **核心思想**：将起点入队并标记，不断从队列取点，若为终点则返回步数。否则向四个方向扩展，新点合法时更新步数、标记并加入队列。
- **作者Ciyang（四星）**
    - **关键亮点**：详细介绍A*算法，与BFS对比清晰，代码实现完整，对A*算法的关键要素如估值函数、开放列表和关闭列表等有明确体现。
    - **核心代码**：
```cpp
void Astar() {
    priority_queue<node *, vector<node *>, nodecmp> q;
    newn[bx][by].init(bx, by, 0);
    q.push(&newn[bx][by]);
    while(!q.empty()) {
        lx= q.top()->x;
        ly= q.top()->y;
        lstep= q.top()->step;
        q.pop();
        closelist[lx][ly]= true;
        for(int i= 0; i < 4; i++) {
            newx= lx + moves[i][0], newy= ly + moves[i][1];
            if(tmap[newx][newy] == '1' || closelist[newx][newy]) continue;
            if(newx == wx && newy == wy) {
                ans= lstep + 1;
                return;
            }
            if(openlist[newx][newy]) {
                if(lstep < newn[newx][newy].step) {
                    newn[newx][newy].update(lstep + 1);
                }
            }
            else {
                newn[newx][newy].init(newx, newy, lstep + 1);
                q.push(&newn[newx][newy]);
                openlist[newx][newy]= true;
            }
        }
    }
    return;
}
```
    - **核心思想**：使用优先队列存储节点，从起点开始，每次取出优先级最高的节点扩展。若到达终点则记录答案。新扩展节点根据是否在开放列表中进行不同处理，更新节点信息并加入优先队列和开放列表。 

---
处理用时：77.47秒
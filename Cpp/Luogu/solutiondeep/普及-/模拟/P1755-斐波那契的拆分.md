# 题目信息

# 斐波那契的拆分

## 题目背景

无

## 题目描述

已知任意一个正整数都可以拆分为若干个斐波纳契数，现在，让你求出 $n$ 的拆分方法。


## 说明/提示

若有多组数据，以个数最小的为准，若仍有多组，输出右边尽量大的一组。

对于$100\%$的数据，$t \leq 1000$，$1 \leq n \leq 10^{9}$。

## 样例 #1

### 输入

```
1
1
```

### 输出

```
1=1```

## 样例 #2

### 输入

```
1
10```

### 输出

```
10=2+8```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均为利用贪心算法解决斐波那契数拆分问题，即每次选取小于等于当前数的最大斐波那契数进行拆分，以满足题目中个数最小且右边尽量大的要求。算法要点在于计算斐波那契数列及实现贪心选取过程。解决难点主要是确定斐波那契数列计算的范围，避免数据类型溢出，以及处理输出格式。

多数题解思路清晰，部分题解在代码实现上有优化空间，如一些题解通过打表、栈操作简化代码。整体上，各题解质量差异不大，无特别突出达到5星的题解，部分题解在思路清晰度、代码可读性和优化程度上表现较好，可评为4星。

### 所选4星题解
- **作者：shame_djj（赞：40）**
  - **星级**：4星
  - **关键亮点**：思路清晰，先点明需计算斐波那契数列中爆int的项数，确定计算范围为45项。采用贪心策略，从最大的斐波那契数开始选，并用栈实现从小到大输出，代码简洁明了。
  - **个人心得**：强调编程解决实际问题的实用性，如计算爆int项数交给计算机实现。
  - **核心代码**：
```cpp
long long int f[100] = {1, 1};
stack <int> s;
int main() {
    for (register int i = 1; i <= 45; i ++)
        f[i] = f[i - 1] + f[i - 2];
    int T, n; cin >> T; for (; T; T --) {
        cin >> n; cout << n << '=';
        for (register int i = 45; i >= 1; i --) {
            while (n >= f[i]) s.push(f[i]), n -= f[i];
            if (n == 0) break;
        }
        while (s.size()) {
            if (s.size() == 1) {
                printf ("%d\n", s.top());
                s.pop();
                break;
            }
            printf ("%d+", s.top());
            s.pop();
        }
    }
    return 0;
}
```
  - **核心思想**：先计算45项斐波那契数列存于数组`f`，对每个输入`n`，从最大斐波那契数`f[45]`开始，若`n`大于等于当前数则入栈并更新`n`，最后从栈中依次输出拆分结果。

- **作者：_tommysun_（赞：4）**
  - **星级**：4星
  - **关键亮点**：整体思路阐述清晰，先求出范围内斐波那契数，利用栈解决输出顺序问题，贪心过程明确，代码简洁易懂，且注意到输出格式处理。
  - **核心代码**：
```cpp
stack <int> st;
int main(){
    int n;
    cin>>n;
    int f[50];
    f[1]=f[2]=1;
    int a[n+10];
    for(int i=0;i<n;i++){
        cin>>a[i];
    } 
    bool flag=true;  
    for(int i=3;i<=45;i++){
        f[i]=f[i-1]+f[i-2];
    }
    for(int i=0;i<n;i++){
        cout<<a[i]<<"=";
        for(int j=45;j>=1;j--) 
        {
            while(a[i]>=f[j])  
            {
                a[i]-=f[j]; 
                st.push(f[j]);        
            } 
        } 
        while(!st.empty()) 
        {
            if(flag==true){
                cout<<st.top(); flag=false;
            } 
            else cout<<"+"<<st.top(); 
            st.pop(); 
        } 
        cout<<endl; 
        flag=true; 
    }
    return 0;
}
```
  - **核心思想**：初始化斐波那契数列数组`f`，对每个输入数`a[i]`，从大到小遍历斐波那契数，满足条件则入栈，最后从栈中输出拆分结果并处理好格式。

- **作者：ljw2005（赞：2）**
  - **星级**：4星
  - **关键亮点**：利用栈实现拆分结果的存储与输出，代码结构清晰，在循环处理中注意到细节，如`l`记录上一次下标，`len`记录栈内元素个数，保证结果正确输出。
  - **核心代码**：
```cpp
int f[50];
int main()
{
    int i,t,n,l,m,len;
    f[0]=1,f[1]=1;
    for(i=2;i<=45;i++) f[i]=f[i-1]+f[i-2];
    scanf("%d",&t);
    while(t--){
        l=45,len=0;
        stack <int> a;
        scanf("%d",&n);
        m=n;
        while(n)
            for(i=l;i>=1;i--)
                if(f[i]<=n&&f[i+1]>n) a.push(f[i]),n-=f[i],l=i,len++;
        printf("%d=",m);
        while(len>1) printf("%d+",a.top()),a.pop(),len--;
        printf("%d\n",a.top()),a.pop();
    }
    return 0;
}
```
  - **核心思想**：生成45项斐波那契数列，对每个输入`n`，通过循环从大到小找合适斐波那契数入栈，最后按格式从栈输出拆分结果。

### 最优关键思路或技巧
1. **贪心策略**：每次选取小于等于当前数的最大斐波那契数进行拆分，能保证拆分个数最小且右边尽量大。
2. **栈的运用**：方便实现拆分结果从小到大输出，简化代码逻辑。
3. **确定数列范围**：通过计算或测试确定斐波那契数列计算到45项左右，避免数据溢出且满足题目数据范围。

### 同类型题或类似算法套路拓展
同类型题可考虑其他数字拆分问题，类似算法套路如贪心算法在资源分配、任务调度等场景的应用。例如在活动安排问题中，按活动结束时间贪心选择活动，以安排最多活动。

### 推荐洛谷题目
1. **P1080 [NOIP2012 提高组] 国王游戏**：通过贪心策略解决分配问题，与本题贪心选取思路类似。
2. **P1199 [NOIP2010 普及组] 三国游戏**：涉及贪心算法，根据题目条件选择最优策略。
3. **P2859 [USACO06DEC]Milk Patterns G**：利用贪心思想处理字符串匹配问题，与本题利用特定规则选取元素思路有相似处。

### 个人心得摘录与总结
1. **shame_djj**：强调编程实用性，如用代码计算斐波那契数列爆int项数，解决实际问题。
2. **Invalid_index**：提到数组使用时多组数据要注意`memset`初始化及更新相关变量，避免得低分，这是多组数据处理时的常见注意点。 

---
处理用时：70.80秒
# 题目信息

# [USACO3.4] 美国血统 American Heritage

## 题目描述

农夫约翰非常认真地对待他的奶牛们的血统。然而他不是一个真正优秀的记帐员。他把他的奶牛 们的家谱作成二叉树，并且把二叉树以更线性的“树的中序遍历”和“树的前序遍历”的符号加以记录而 不是用图形的方法。

你的任务是在被给予奶牛家谱的“树中序遍历”和“树前序遍历”的符号后，创建奶牛家谱的“树的 后序遍历”的符号。每一头奶牛的姓名被译为一个唯一的字母。（你可能已经知道你可以在知道树的两 种遍历以后可以经常地重建这棵树。）显然，这里的树不会有多于 $26$ 个的顶点。

这是在样例输入和样例输出中的树的图形表达方式：


```plain
　　　　　　　　 C
　　　　　　   /  \
　　　　　　  /　　\
　　　　　　 B　　  G
　　　　　　/ \　　/
　　　　   A   D  H
　　　　　　  / \
　　　　　　 E   F

```

附注：

- 树的中序遍历是按照左子树，根，右子树的顺序访问节点；
- 树的前序遍历是按照根，左子树，右子树的顺序访问节点；
- 树的后序遍历是按照左子树，右子树，根的顺序访问节点。


## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 3.4


## 样例 #1

### 输入

```
ABEDFCHG
CBADEFGH 
```

### 输出

```
AEFDBHGC```

# AI分析结果

### 综合分析与结论
这些题解主要围绕通过二叉树的前序遍历和中序遍历结果来推导后序遍历结果。核心思路都是利用前序遍历第一个元素为根节点，在中序遍历中找到该根节点位置，从而划分左右子树，再递归处理子树。

算法要点在于准确切割字符串或确定子树区间，以及递归的边界条件处理。解决难点主要是理解三种遍历方式的特点及相互关系，正确实现子树的划分与递归。

从质量上看，多数题解思路清晰，但部分代码可读性欠佳或存在冗余。整体没有特别突出达到5星的题解，部分题解在思路清晰度、代码简洁性和优化程度上表现较好，可评为4星。

### 所选4星题解
- **作者：Diamiko（4星）**
    - **关键亮点**：思路阐述极为清晰，详细解释二叉树遍历原理、字符串切割方法及参数规律，代码注释丰富，可读性强。
    - **个人心得**：无
    - **核心代码**：
```cpp
void work(string pre,string inor)
{
    if(pre.empty())return;
    char root=pre[0];
    int k=inor.find(root);
    pre.erase(pre.begin());
    string leftpre=pre.substr(0,k);
    string rightpre=pre.substr(k);
    string leftinor=inor.substr(0,k);
    string rightinor=inor.substr(k+1);
    work(leftpre,leftinor);
    work(rightpre,rightinor);
    printf("%c",root);
}
```
    - **核心思想**：通过不断截取前序和中序遍历的子串，递归处理左右子树，最后输出根节点，实现后序遍历。

- **作者：jzqjzq（4星）**
    - **关键亮点**：简洁明了地阐述递归思路，直接在代码注释中说明找到根节点后递归左右子树及输出根节点的过程，代码简洁。
    - **个人心得**：无
    - **核心代码**：
```cpp
void dfs(int l1,int l2,int l3,int l4){
    if(l1>l2||l3>l4)return;
    for(int i=l1;i<=l2;i++)if(a[i]==b[l3]){
        dfs(l1,i-1,l3+1,l3+i-l1);
        dfs(i+1,l2,l3+i-l1+1,l4);
        cout<<a[i];
    }
}
```
    - **核心思想**：通过确定子树区间，在中序遍历区间找到根节点，递归处理左右子树区间，最后输出根节点。

- **作者：蒟___（4星）**
    - **关键亮点**：详细分析题目，结合例子阐述递归思路，对string常用函数进行科普，有助于初学者理解。
    - **个人心得**：在写题解过程中得到提升。
    - **核心代码**：
```cpp
void def(string f,string m){
    if(f.empty()) return;
    char ch=f[0];
    int k=m.find(ch);
    f.erase(f.begin());
    def(f.substr(0,k),m.substr(0,k));
    def(f.substr(k),m.substr(k+1));
    cout<<ch;
}
```
    - **核心思想**：利用前序遍历首字符为根节点，在中序遍历找到根节点位置，删除前序首字符，递归处理左右子树对应的子串，最后输出根节点。

### 最优关键思路或技巧
利用前序遍历第一个元素是根节点，在中序遍历中确定根节点位置来划分左右子树，通过递归方式处理子树，避免实际建树过程，提高效率。同时，合理使用字符串操作函数（如substr、find、erase）简化代码实现。

### 可拓展之处
同类型题常涉及已知二叉树两种遍历结果求第三种遍历结果，类似算法套路是根据已知遍历特点确定根节点和子树划分，再递归处理。例如已知中序和后序求前序。

### 相似知识点洛谷题目
- **P1030 求先序排列**：已知中序和后序遍历，求先序遍历。
- **P2022 已知二叉树的两种遍历序列**：根据给出的两种遍历序列确定另一种遍历序列。
- **P1996 约瑟夫问题**：虽不是二叉树遍历，但同样考察递归思想的运用。

### 个人心得摘录与总结
 - **emiermao**：最初用链表做遇到困难，RE多次发现结束条件不够，经过多次调试最终AC。总结为链表不适合此题，且要注意递归结束条件。 

---
处理用时：55.77秒
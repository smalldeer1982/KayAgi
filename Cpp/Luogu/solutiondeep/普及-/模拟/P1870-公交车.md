# 题目信息

# 公交车

## 题目描述

某城市有个能容纳 $n$ 辆公交车的停车场。每一天，这些公交车都要依次有序离开停车库去另一个终点站。这终点站距离停车场有 $d$ 米的路程。当然第 $i$ 辆公交车离开停车场的时间是 $t_i$ 秒，并以最大速度不超过 $v_i$ 米/秒行驶，加速度最大值为 $a$。一辆公交车能瞬间减速，也能瞬间改变它的加速度。当然每辆车的最大加速度都一样为 $a$。

不管有多大的马力，一辆公交车都不能超过其他另外的公交车，如果一辆公交车追上另一辆公交车，那么后面追上的车跟前面被追的车一起并排行驶同时到达终点站。当然司机都是尽可能快的驾车到达终点站的。

作为公交公司老板的你，希望每辆公交车都尽可能快的到达终点站。当然，公交车到达终点站时，速度可以没必要达到 $0$。当一辆公交车离开停车场时，它的起始速度等于 $0$。通过物理的观点解释的话，公交车可以看成是抽象的一个物体而已，除了能加速和减速，其他对速度的影响都可以忽略掉。

## 说明/提示

【样例解释】

第二辆公交车能追上第一辆公交车，在行驶到距离终点 $510.5$ 公里处。然后还剩 $9489.5$ 公里的路程，两辆车都以 $10$ km/h 的速度，一起到达终点的，它们到达终点的时刻是 $1000.5$ 秒，第三辆公交车不能赶上其他的公交车，他到达终点的时刻是 $11000.05$ 秒。

## 样例 #1

### 输入

```
3 10 10000

0 10

5 11

1000 1

```

### 输出

```
1000.5000

1000.5000

11000.0500

```

# AI分析结果

• 综合分析与结论：这些题解思路基本一致，均基于物理运动学公式，根据公交车能否全程加速进行分类讨论，计算每辆车到达终点时间，并考虑不能超车的限制，用变量记录最大时间来确保后车不超过前车。难点主要在于公式推导及精度处理。各题解质量差异不大，主要体现在思路阐述清晰度与代码规范性上。
• 所选的题解：
  - 作者：yangwenbin (5星)
    - 关键亮点：思路清晰，详细分类讨论并推导公式，对输出精度问题处理有详细说明，代码简洁规范。
    - 重点代码核心思想：先读入公交车数量、加速度和终点距离，遍历每辆车，根据距离与匀加速最大行驶距离关系计算到达时间，与之前最大时间比较并更新，最后处理精度输出。
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    double n,a,x;
    double maxn=0.0000;
    scanf("%lf %lf %lf",&n,&a,&x);
    while(n--){
        double t,v;
        scanf("%lf %lf",&t,&v);
        double ans = t;
        if(x <= v*v/(2*a)){
            ans += sqrt(2*x / a);
        }else{
            ans += x/v;
            ans += v/(2*a);
        }
        if(maxn > ans){
            ans=maxn;
        }else{
            maxn=ans;
        }
        ans*=10000;
        ans=floor(ans);
        ans/=10000;
        printf("%0.4lf\n",ans); 
    }
}
```
  - 作者：szh_AK_all (4星)
    - 关键亮点：先梳理题目涉及的物理公式，对两种行驶情况分析清晰，代码简洁明了。
    - 重点代码核心思想：读入数据后，对每辆车计算匀加速最大路程，分情况计算到达时间，比较并更新最大时间，处理精度后输出。
```c
#include<iostream>
#include<iomanip>
#include<cmath>
#include<cstdio>
using namespace std;
double t,v;
double maxn=0.0;
int main()
{
    double a,n,d;
    cin>>n>>a>>d;
    for(int i=1;i<=n;i++)
    {
        cin>>t>>v;
        double ans=v*v*1.0/(2*a);
        if(ans>=d)t+=sqrt(2*1.0*d/a);
        else 
            t+=(sqrt(2*ans/a)+(d-ans)/v);
        if(t>=maxn)
            maxn=t;
        else
            t=maxn;
        t=floor(t*10000*1.0)/10000;
        printf("%0.4lf\n",t); 
    }
    return 0;
}
```
  - 作者：Kobe_BeanBryant (4星)
    - 关键亮点：解题思路简洁清晰，直接点明两种分类情况，代码实现简洁易懂。
    - 重点代码核心思想：读入数据，按能否全程加速分类计算每辆车到达时间，与最大时间比较更新，处理精度输出。
```cpp
#include<bits/stdc++.h>
using namespace std;
double n,a,x,t,v,ans,maxn=0;
int main(){
    scanf("%lf%lf%lf",&n,&a,&x);
    while(n--){
        scanf("%lf %lf",&t,&v);
        ans=t;
        if(x<=v*v/(2*a)) ans += sqrt(2*x / a);
        else ans+=x/v,ans+=v/(2*a);
        if(maxn>ans) ans=maxn;
        else maxn=ans;
        ans*=10000,ans=floor(ans),ans/=10000;
        printf("%0.4lf\n",ans); 
    }
    return 0;
}
```
• 最优关键思路或技巧：利用物理运动学公式，根据匀加速行驶路程与总路程关系分类讨论计算时间，通过记录最大时间保证公交车行驶规则。在输出精度处理上，先乘10000向下取整再除10000的方法避免 `printf` 四舍五入问题。
• 可拓展之处：此类题目属于结合物理知识的行程问题，类似套路是根据运动状态不同进行分类讨论，结合限制条件求解。同类型题可考虑改变运动规则、增加运动状态等。
• 相似知识点洛谷题目：
  - P1909 [NOIP2016 普及组] 买铅笔
  - P1085 [NOIP2004 普及组] 不高兴的津津
  - P1147 连续自然数和 

---
处理用时：45.41秒
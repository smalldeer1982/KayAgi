# 题目信息

# 天际线

## 题目描述

Latium 省的 Genoa 是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官 Caesar 的委任，前往 Genoa 建立新的城市。Caesar 对这次任务的要求是在 Genoa 这片土地上建立起一座繁荣的城市，他将以此作为衡量你的表现的标准。

正在你大刀阔斧地进行城市建设的时候，Caesar 突然写信给你，说他要检查 Genoa 的建设情况。Caesar 希望知道你的城市是什么样子，但是他又非常的忙，所以他只要你描述一下城市的轮廓就可以了，他将依照城市的轮廓决定你的薪水。

怎样描述一个城市的轮廓呢？我们知道 Genoa 所有的建筑共享一个地面，你可以认为它是水平的。所有的建筑用一个三元组 $(L_i,H_i,R_i)$，其中 $L_i$ 和 $R_i$ 分别是建筑的左坐标和右坐标，$H_i$ 就是建筑的高度。在下方所示的图表中左边建筑物描述如下 $(1,11,5)$，$(2,6,7)$，$(3,13,9)$，$(12,7,16)$，$(14,3,25)$，$(19,18,22)$，$(23,13,29)$，$(24,4,28)$，右边用轮廓线的顺序$(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)$ 表示：

![](https://cdn.luogu.com.cn/upload/image_hosting/oe7wpwsi.png)


## 样例 #1

### 输入

```
1 11 5
2 6 7
3 13 9
12 7 16
14 3 25
19 18 22
23 13 29
24 4 28
```

### 输出

```
1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0```

# AI分析结果

这道题要求根据给定的建筑三元组$(L_i, H_i, R_i)$描述城市的轮廓线。各题解思路、算法要点及难点如下：
1. **InchTree**：
    - **思路**：暴力记录每个点的最大高度，再找出高度变化的点对输出。
    - **算法要点**：用数组`H`记录每个坐标点的最大高度，遍历输入更新`H`，再遍历`H`找高度变化点。
    - **解决难点**：注意处理点与点间的缝隙，将更新`H`时的`<=`改为`<`。
2. **big_news**：
    - **思路**：扫描线 + 线段树做线段区间覆盖。将矩形变为线段，用线段树维护区间覆盖长度。
    - **算法要点**：定义线段和线段树节点，按横坐标处理线段更新线段覆盖，根据覆盖长度变化找轮廓线折点。
    - **解决难点**：横坐标相同的线段要一起处理，注意纵坐标离散化。
3. **sfmmdm**：
    - **思路**：用数组`maxh`记录每个`x`坐标的最高楼，判断`maxh`与左右两边是否相等来确定是否输出。
    - **算法要点**：通过`maxh[i<<1]`和`maxh[i<<1|1]`分别记录坐标`i/2`和`(i + 0.5)/2`的最大高度，遍历判断输出。
    - **解决难点**：处理特殊情况，通过访问`maxh[x ± 0.5]`避免少输出点，实际用数组下标翻倍实现。
4. **Timothy**：
    - **思路**：线段树成段更新 + 离散化。按高度排序楼房，离散化坐标，用线段树维护区间高度。
    - **算法要点**：定义结构体存储楼房信息，实现线段树的更新和查询操作，搜索叶子节点输出。
    - **解决难点**：理解并实现线段树的成段更新和离散化处理。
5. **xiaolou**：
    - **思路**：线段树求区间最大值。对每栋建筑占地范围区间求最大值，再求每个单位的最大值。
    - **算法要点**：构建线段树，实现区间修改和单点查询操作，按要求输出结果。
    - **解决难点**：正确实现线段树的各种操作，注意细节。
6. **zhengrunzhe**：
    - **思路**：平衡树 + 扫描线。将楼房转化为线段，按`x`坐标排序，用平衡树维护最大值。
    - **算法要点**：定义线段结构体，实现平衡树（Treap）的插入、删除和取最大值操作，根据线段操作确定轮廓点。
    - **解决难点**：熟练掌握平衡树的操作并应用到扫描线过程中。
7. **haoyun1**：
    - **思路**：用大根堆维护高度。将建筑二元组建大根堆，扫描端点，判断堆顶是否过期，根据高度变化输出。
    - **算法要点**：定义建筑结构体和端点结构体，使用优先队列（大根堆），扫描过程中处理堆顶和输出。
    - **解决难点**：正确处理堆顶过期情况和高度变化的判断。
8. **keydu**：
    - **思路**：类似`hash`表，用数组记录每个位置的最大高度，遍历输出高度变化点。
    - **算法要点**：用数组`ans`记录最大高度，遍历输入更新`ans`，再遍历`ans`输出变化点。
    - **解决难点**：注意边界处理和输出格式。
9. **Kevin_Wa**：
    - **思路**：分块处理。读入数据，统计横坐标最大值，分块维护区间最大值，扫描输出高度变化点。
    - **算法要点**：确定分块大小，实现分块更新和查询操作，扫描判断输出。
    - **解决难点**：合理分块并处理好边界情况。
10. **Minecraft万岁**：
    - **思路**：珂朵莉树（ODT）。按高度排序建筑，用珂朵莉树进行区间赋值，输出高度变化点。
    - **算法要点**：定义珂朵莉树节点和建筑结构体，实现珂朵莉树的分裂和赋值操作，遍历输出结果。
    - **解决难点**：理解并实现珂朵莉树的操作。
11. **doby**：
    - **思路**：扫描线 + Splay。扫描横坐标，用Splay维护最大值，根据最大值变化输出轮廓点。
    - **算法要点**：定义楼房结构体和Splay树节点，实现Splay树的插入、删除和取最大值操作，扫描过程中处理输出。
    - **解决难点**：熟练掌握Splay树的操作并应用到扫描线中。
12. **Most_Goodlooking**：
    - **思路**：珂朵莉树（ODT）。按高度排序建筑，用珂朵莉树进行区间赋值，输出高度变化点。
    - **算法要点**：定义相关结构体，实现珂朵莉树的分裂和区间赋值操作，遍历输出结果。
    - **解决难点**：正确实现珂朵莉树的操作和输出处理。
13. **xiaoDiPa**：
    - **思路**：线段树维护区间最大值和是否平坦。更新区间时根据不同情况处理，查询时根据区间状态返回值。
    - **算法要点**：定义线段树节点结构体，实现线段树的更新、下传和查询操作，扫描输出结果。
    - **解决难点**：处理好线段树更新和查询过程中的各种情况。
14. **zhenglier**：
    - **思路**：用`vector`记录左右端点，`multiset`维护最大值。扫描横坐标，更新`multiset`并输出高度变化点。
    - **算法要点**：用`vector`存储左右端点高度，`multiset`插入和删除高度，扫描判断输出。
    - **解决难点**：注意`multiset`删除元素的方式。
15. **littleKtian**：
    - **思路**：线段树维护区间信息。按高度排序建筑，用线段树维护每段绿色线段信息，根据左右线段信息不同输出折点。
    - **算法要点**：定义相关结构体，实现线段树的初始化、更新和遍历操作，输出折点。
    - **解决难点**：理解并实现通过线段树维护区间信息来确定折点。
16. **Setsugesuka**：
    - **思路**：珂朵莉树（ODT）。按高度排序建筑，用珂朵莉树进行区间赋值，合并区间并输出结果。
    - **算法要点**：定义相关结构体，实现珂朵莉树的分裂、赋值和合并操作，遍历输出结果。
    - **解决难点**：正确实现珂朵莉树的各种操作和结果处理。
17. **brealid**：
    - **思路**：`sort` + 优先队列。将建筑拆成线段，按横坐标排序，用优先队列维护高度，扫描输出高度变化点。
    - **算法要点**：定义线段结构体，优先队列存储线段信息，扫描过程中处理优先队列和输出。
    - **解决难点**：处理相邻不重合建筑的情况。
18. **Mufanc**：
    - **思路**：用队列和平衡树。将建筑左右边界存入队列，扫描坐标，平衡树插入删除高度，输出平衡树最大值变化点。
    - **算法要点**：定义矩形结构体，用队列存储边界，平衡树（`multiset`）维护高度，扫描判断输出。
    - **解决难点**：正确操作平衡树并判断高度变化。

综合各题解的思路清晰度、代码可读性、优化程度等方面进行评分：
1. **InchTree**：★★★，思路简单直接，代码简洁，但暴力方法在数据量大时效率低，不过对理解题意有帮助。
2. **big_news**：★★★★，详细讲解扫描线和线段树结合的方法，代码完整且有注释，能较好处理复杂情况。
3. **sfmmdm**：★★★，思路清晰，代码简短，但处理特殊情况的方式较难理解。
4. **Timothy**：★★★★，详细阐述线段树成段更新和离散化算法，给出时间和空间复杂度分析，代码有一定可读性。
5. **xiaolou**：★★★★，思路明确，详细注释线段树代码，对线段树操作讲解清晰。
6. **zhengrunzhe**：★★★，思路较清晰，代码实现平衡树和扫描线结合，但平衡树代码较复杂。
7. **haoyun1**：★★★，思路较清晰，利用优先队列实现较简洁，但对堆顶过期处理代码较紧凑。
8. **keydu**：★★，代码简单但思路常规，未对算法进行优化。
9. **Kevin_Wa**：★★★，分块思路有一定创新性，但代码实现较繁琐。
10. **Minecraft万岁**：★★★，利用珂朵莉树但代码注释较少，对不熟悉该数据结构的人较难理解。
11. **doby**：★★★，扫描线结合Splay树，但Splay树代码复杂，整体可读性一般。
12. **Most_Goodlooking**：★★★，珂朵莉树实现但代码注释少，理解有一定难度。
13. **xiaoDiPa**：★★★，线段树维护复杂信息，代码逻辑较难理解。
14. **zhenglier**：★★★，利用STL容器实现较巧妙，但代码中对`multiset`操作较隐晦。
15. **littleKtian**：★★★，线段树维护区间信息思路新颖，但代码注释少。
16. **Setsugesuka**：★★★，珂朵莉树实现但代码较复杂且注释少。
17. **brealid**：★★★，思路较清晰，代码实现较简洁，但对相邻建筑处理需仔细理解。
18. **Mufanc**：★★★，利用队列和平衡树思路较清晰，但代码实现细节较多。

评分较高（≥4星）的题解：
1. **big_news**：★★★★
    - **关键亮点**：详细阐述扫描线和线段树结合解决矩形并轮廓问题，对扫描线法、线段覆盖等概念讲解清晰，代码完整且注释详细。
    - **核心代码片段**：
```cpp
//线段覆盖
class Sugment{ //定义一条线段
  public: int r,x,k;
    bool operator < (const Sugment &a)const
    {return x < a.x;} 
}sug[CN];
int scnt = 0;

int pos[CN],pcnt; //离散化数组
class node{ //定义线段树的节点
  public: int len,cnt;
};
class SGT{ //线段树 (SugmentTree,习惯简写成SGT,我英语不好)
  public:
  	node d[CN<<2];
  	int GetLen(int l,int r,int k){ //更新得到的线段的长度
  		if(d[k].cnt) return pos[r+1]-pos[l];
  		if(l == r) return 0;
  		return d[k<<1].len + d[k<<1|1].len;
    }
  	void modify(int l,int r,int k,int s,int t,int x){ //修改(插入/删除)
  		if(s<=l && r<=t){ //这里的操作和普通线段树类似
  			d[k].cnt += x;
  			d[k].len = GetLen(l,r,k);
  			return;
        }
        int m = (l+r)>>1;
        if(s <= m) modify(l,m,k<<1,s,t,x);
        if(m < t) modify(m+1,r,k<<1|1,s,t,x);
        d[k].len = GetLen(l,r,k); //更新线段长度
    }
}sgt;

void SugmentCover(int i){ //线段覆盖
    int l = 1;
    int r = lower_bound(pos+1,pos+pcnt+1,sug[i].r)-pos-1; //查找离散化之后的值
    sgt.modify(1,pcnt,1,l,r,sug[i].k);
}
```
    - **核心实现思想**：定义`Sugment`表示线段，`node`表示线段树节点，`SGT`类实现线段树操作。`GetLen`计算区间覆盖长度，`modify`实现线段插入或删除操作，`SugmentCover`进行线段覆盖更新。
2. **Timothy**：★★★★
    - **关键亮点**：详细说明线段树成段更新和离散化算法步骤，给出时间和空间复杂度分析，代码结构较清晰。
    - **核心代码片段**：
```cpp
void pushdown(int rt)
{
    col[rt<<1]=col[rt<<1|1]=1;
    num[rt<<1]=num[rt<<1|1]=num[rt];
    col[rt]=0;
}
int ef(int l1,int r1,int mb)
{
    int l=l1,r=r1;
    while (l<=r)
    {
        int mid=(l+r)>>1;
        if (le[mid]>=mb)r=mid-1;
        else l=mid+1;
    }
    return l;
}
void update(int l,int r,int rt,int L,int R,int H)
{
    if (L<=l && r<=R){col[rt]=1;num[rt]=H;return;}
    int mid=(l+r)>>1;
    if (col[rt])pushdown(rt);
    if (L<=mid)update(lson,L,R,H);
    if (R>mid)update(rson,L,R,H);
}
int query(int l,int r,int rt,int u)
{
    if (l==r)return num[rt];
    int mid=(l+r)>>1;
    if (col[rt])pushdown(rt);
    if (u<=mid)query(lson,u);
    else query(rson,u);
}
```
    - **核心实现思想**：`pushdown`函数下传标记，`ef`函数用于离散化查找，`update`实现线段树区间更新，`query`实现单点查询。
3. **xiaolou**：★★★★
    - **关键亮点**：思路明确，对线段树的建树、修改、查询操作详细注释，便于理解线段树在本题中的应用。
    - **核心代码片段**：
```cpp
void BuildT(int id,int l,int r)//建树
{
    t[id].le=l;
    t[id].ri=r;
    t[id].la=0;
    if(t[id].le==t[id].ri)
    {
        t[id].mx=0;
        return;
    }
    int mid=(l+r)/2;
    BuildT(id*2,l,mid);
    BuildT(id*2+1,mid+1,r);
}
void Push(int id)//la标记下放
{
    if(t[id].la)
    {
        t[id*2].la=t[id].la;
        t[id*2+1].la=t[id].la;
        t[id*2].mx=max(t[id*2].mx,t[id*2].la);
        t[id*2+1].mx=max(t[id*2+1].mx,t[id*2+1].la);
        t[id].la=0;
    }
}
void Change(int id,int l,int r,int c)//修改，注意细节
{
    if(t[id].le==l&&t[id].ri==r)
    {
        t[id].mx=max(t[id].mx,c);
        t[id].la=c;
        return;
    }
    Push(id);
    if(r<=t[id*2].ri)
    {
        Change(id*2,l,r,c);
    }
    else if(l>=t[id*2+1].le)
    {
        Change(id*2+1,l,r,c);
    }
    else
    {
        Change(id*2,l,t[id*2].ri,c);
        Change(id*2+1,t[id*2+1].le,r,c);
    }
    t[id].mx=max(t[id*2].mx,t[id*2+1].mx);
}
int Query(int id,int l,int r)//查询
{
    if(t[id].le==l&&t[id].ri==r)
    {
        return t[id].mx;
    }
    Push(id);
    if(r<=t[id*2].ri)
    {
        return Query(id*2,l,r);
    }
    else if(l>=t[id*2+1].le)
    {
        return Query(id*2+1,l,r);
    }
    else
    {
        return max(Query(id*2,l,t[id*2].ri),Query(id*2+1,t[id*2+1].le,r));
    }
}
```
    - **核心实现思想**：`BuildT`函数构建线段树，`Push`函数下放标记，`Change`函数实现区间修改，`Query`函数实现区间查询。

最优的关键思路或

---
处理用时：80.73秒
# 题目信息

# 保龄球

## 题目描述

DL 算缘分算得很烦闷，所以常常到体育馆去打保龄球解闷。因为他保龄球已经打了几十年了，所以技术上不成问题，于是他就想玩点新花招。

DL 的视力真的很不错，竟然能够数清楚在他前方十米左右每个位置的瓶子的数量。他突然发现这是一个炫耀自己好视力的借口——他看清远方瓶子的个数后从某个位置发球，这样就能打倒一定数量的瓶子。

1. $\bigcirc \bigcirc \bigcirc$

2. $\bigcirc \bigcirc \bigcirc\ \bigcirc$

3. $\bigcirc$

4. $\bigcirc\ \bigcirc$

如上图，每个 “$\bigcirc$” 代表一个瓶子。如果 DL 想要打倒 $3$ 个瓶子就在 $1$ 位置发球，想要打倒 $4$ 个瓶子就在 $2$ 位置发球。

现在他想要打倒 $m$ 个瓶子。他告诉你每个位置的瓶子数，请你给他一个发球位置。

## 说明/提示

【数据范围】

对于 $50\%$ 的数据，$1 \leq n, Q \leq 1000, 1 \leq a_i, m \leq 10^5$。

对于 $100\%$ 的数据，$1 \leq n,Q \leq 100000, 1 \leq a_i, m \leq 10^9$。

## 样例 #1

### 输入

```
5
1 2 4 3 5
2
4
7
```

### 输出

```
3
0
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕两种思路：使用`map`映射和二分查找。
 - **`map`映射思路**：利用`map`建立瓶子数量与位置的映射关系，直接通过查询`map`获取位置，时间复杂度为O(log n)，实现简单直接。
 - **二分查找思路**：先将瓶子数量和位置用结构体存储，对结构体按瓶子数量排序，再通过二分查找目标瓶子数量对应的位置，时间复杂度为O(n log n)（排序） + O(q log n)（查询），需注意排序后位置与原位置的对应。
两种思路在不同场景各有优势，`map`实现简洁，二分查找在数据量较大且需多次查询时效率较高。

### 所选的题解
 - **作者：沧澜 (赞：120)  星级：5星**
    - **关键亮点**：思路清晰简洁，直接使用`map`解决问题，代码简短且可读性强。
    - **核心代码**：
```cpp
#include<map>
#include<iostream>
using namespace std;
map<int,int>ma;
int n,a,q,m;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a;
        ma[a]=i;
    }
    cin>>q;
    for(int i=1;i<=q;i++){
        cin>>m;
        cout<<ma[m]<<endl;
    }
}
```
    - **核心实现思想**：读入每个位置的瓶子数时，将瓶子数作为`map`的键，位置作为值存入`map`。查询时，直接通过`map`获取对应瓶子数的位置并输出。

 - **作者：影のない霜跡 (赞：17)  星级：4星**
    - **关键亮点**：详细阐述二分查找思路，从结构体绑定数组、排序到二分查找，步骤清晰。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstring>
using namespace std;
struct aa{int g,w;};
bool cmp(aa x,aa y)
{
	return x.g<y.g;
}
aa gs[100000+5];
int n,m,wt,r,l,mid;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&gs[i].g);
	for(int i=1;i<=n;i++)gs[i].w=i;
	sort(gs+1,gs+1+n,cmp);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&wt);
		r=n+1;l=0;
		while(l+1<r)
		{
			mid=(r+l)/2;
			if(gs[mid].g<wt) l=mid;
			else r=mid;
		}
		if(gs[r].g!=wt)cout<<"0"<<endl;
		else printf("%d\n",gs[r].w);
	}
    return 0;
}
```
    - **核心实现思想**：用结构体`aa`存储瓶子数`g`和位置`w`，读入数据后对结构体数组按瓶子数排序。每次查询时，通过二分查找确定目标瓶子数的位置并输出，若未找到则输出0。

 - **作者：引领天下 (赞：7)  星级：4星**
    - **关键亮点**：不仅给出暴力解法，还详细分析优化思路，包括`map`和`set`结合`lower_bound`的方法，拓展了思路。
    - **个人心得**：指出暴力解法的效率瓶颈在于朴素查找，会退化到O(n)级别，从而引出优化思路。
    - **核心代码（`set`结合`lower_bound`）**：
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
set<pair<int,int> > st;
int n,m,q,s;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for (register int i=1;i<=n;i++){
        cin>>s;
        st.insert(make_pair(s,i));
    }
    cin>>q;
    while (q--){
        cin>>m;
        set<pair<int,int> >::iterator it=st.lower_bound(make_pair(m,0));
        if (it->first==m)cout<<(it->second)<<endl;
        else cout<<0<<endl;
    }
}
```
    - **核心实现思想**：使用`set`存储二元组（瓶子数，位置），利用`set`按第一关键字排序的特性。查询时，通过`lower_bound`找到第一个大于等于目标瓶子数的元素，判断是否相等，相等则输出位置，否则输出0。

### 最优关键思路或技巧
 - **数据结构选择**：根据题目特点选择合适的数据结构，如`map`适用于快速建立映射关系，`set`结合`lower_bound`可在有序集合中高效查找，二分查找则需先排序再利用有序性查找。
 - **代码简洁性**：像使用`map`的方法，代码简洁明了，直接实现需求，减少出错概率。

### 可拓展之处
同类型题常考察在无序数据中查找特定值的位置或统计等问题。类似算法套路包括使用哈希表（如`unordered_map`）、平衡二叉搜索树（如`set`）等数据结构优化查找，或利用排序结合二分查找提升效率。

### 洛谷相似题目推荐
 - P1102 A-B 数对：给定两个整数集合，求满足A集合中元素减去B集合中元素等于给定值的数对数量，可通过排序和二分查找解决。
 - P2678 [NOIP2015 普及组] 跳石头：在一条直线上有若干石头，移除一些石头使相邻石头间的最小距离最大，可用二分查找答案。
 - P3853 [TJOI2007] 路标设置：在一条公路上设置路标，给定路标数量，求最大间距的最小值，同样可通过二分查找解决。

### 个人心得摘录与总结
 - **Enzymii**：在使用`lower_bound`时遇到困难，如忘记其并非完全找相等，导致WA。强调了对STL函数细节的掌握很重要，使用前需清楚其功能和特性。
 - **引领天下**：通过分析暴力解法的效率瓶颈，引出优化思路，提醒在解题时要善于分析算法复杂度，寻找优化方向。 

---
处理用时：56.22秒
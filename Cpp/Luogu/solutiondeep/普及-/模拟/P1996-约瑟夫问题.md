# 题目信息

# 约瑟夫问题

## 题目描述

$n$ 个人围成一圈，从第一个人开始报数,数到 $m$ 的人出列，再由下一个人重新从 $1$ 开始报数，数到 $m$ 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。

**注意：本题和《深入浅出-基础篇》上例题的表述稍有不同。书上表述是给出淘汰 $n-1$ 名小朋友，而该题是全部出圈。**


## 说明/提示

$1 \le m, n \le 100$


## 样例 #1

### 输入

```
10 3```

### 输出

```
3 6 9 2 7 1 8 5 10 4```

# AI分析结果

### 综合分析与结论
这些题解针对约瑟夫问题，主要采用模拟、链表、队列、数组模拟链表、树状数组、线段树等方法。模拟法直接按题意循环判断；链表通过指针操作实现元素删除与遍历；队列模拟报数与出队过程；数组模拟链表借助数组存储元素关系；树状数组和线段树用于优化查询与修改操作。各方法在思路清晰度、代码可读性、优化程度上有差异。

### 所选4星及以上题解
1. **作者：KesdiaelKen (赞：430)  星级：4星**
    - **关键亮点**：思路清晰简洁，直接按题意模拟。用visit数组记录已出队人员，通过双重循环模拟报数和出队过程，代码可读性高。
    - **个人心得**：强调初始化的重要性，自己第一遍做时忘记对visit数组初始化。
    - **核心代码**：
```cpp
#include<cstdio>
using namespace std;
int main()
{
    int n,m,s=0;scanf("%d%d",&n,&m);
    bool visit[200]={0};
    for(int k=0;k<n;k++){
        for(int i=0;i<m;i++){if(++s>n)s=1;if(visit[s])i--;}
        printf("%d ",s);visit[s]=true;
    }
    return 0;
}
```
    - **核心思想**：外层循环控制出队人数，内层循环模拟报数，若当前报数的人已出队则i--重新报数，找到要出队的人后输出并标记为已出队。

2. **作者：Mickey_snow (赞：315)  星级：4星**
    - **关键亮点**：用双向链表模拟，符合命题者期望，详细展示链表初始化、节点删除等操作，逻辑严谨。
    - **核心代码**：
```cpp
struct Peo
{
    int ID;
    Peo *next, *front;
    Peo(){ next = front = nullptr; }
}n[100];

void _Cut(Peo *num)
{
    num = num->front;
    num->next = num->next->next;
    num = num->next;
    num->front = num->front->front;
}

int main()
{
    int tot, outNum, nowNum = 1;
    Peo *now = n;
    cin >> tot >> outNum;

    for (int i = 1; i < tot - 1; i++) { n[i].front = n + i - 1; n[i].next = n + i + 1; n[i].ID = i + 1; }
    n[0].front = n + tot - 1; n[0].next = n + 1; n[tot - 1].front = n + tot - 2; n[tot - 1].next = n;
    n[0].ID = 1; n[tot - 1].ID = tot;

    while (tot > 0) {
        if (nowNum == outNum) {
            cout << now->ID << " ";
            _Cut(now);
            nowNum = 1;
            tot--;
            now = now->next;
        }
        else {
            nowNum++;
            now = now->next;
        }
    }

    return 0;
}
```
    - **核心思想**：定义双向链表结构体，初始化链表使节点相互连接成环。_Cut函数用于删除当前节点，主循环中根据报数情况决定是否删除当前节点并输出其ID。

3. **作者：yangrunze (赞：167)  星级：4星**
    - **关键亮点**：用数组模拟链表，解决指针操作复杂问题，详细阐述数组模拟链表思路及模拟出圈过程，便于理解。
    - **核心代码**：
```cpp
int next[1000005];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++)
        next[i]=i+1;
    next[n]=1;
    int p=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<m;j++)
            p=next[p];
        cout<<next[p]<<" ";
        next[p]=next[next[p]];
    }
    return 0;
}
```
    - **核心思想**：用next数组存储每个元素的下一个元素，初始化形成循环链表。通过双重循环，外层控制出圈次数，内层找到要出圈元素的前一个位置，输出出圈元素并更新next数组跳过该元素。

### 最优关键思路或技巧
1. **数据结构选择**：根据数据规模和题目特点选择合适数据结构。如本题数据规模小，可使用简单数组模拟；若数据规模大，树状数组、线段树等数据结构能优化时间复杂度。
2. **模拟过程优化**：在模拟报数和出队过程中，通过合理设置变量和循环条件减少不必要计算。如将指针或位置变量提前或滞后处理，避免访问已出圈元素。

### 同类型题或类似算法套路拓展
1. **同类型题**：此类题目通常围绕循环结构中的元素操作，如循环报数、按规则删除或选取元素等。
2. **类似算法套路**：除上述数据结构和模拟方法，还可考虑数学推导优化。如约瑟夫问题可通过数学公式直接计算出圈顺序，避免模拟过程，大幅提高效率。

### 洛谷相似知识点题目推荐
1. **P1996 约瑟夫问题**：经典约瑟夫问题，可巩固基础解法。
2. **P2815  家谱树**：涉及树状结构操作，与链表模拟有相似之处。
3. **P3373 【模板】线段树 1**：练习线段树基本操作，有助于理解用线段树解决此类问题的思路。 

---
处理用时：59.27秒
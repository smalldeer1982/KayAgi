# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕《[NOI2001] 食物链》这一题目，核心是利用并查集解决动物间复杂关系判断假话数量的问题。题解思路可分为两类：
1. **种类并查集**：通过开3倍大小的并查集，将每个动物的同类、猎物和天敌分别用不同区间表示，根据输入关系合并并查集，同时依据并查集的连通性判断假话。
2. **带权并查集**：给并查集的边加权，权值表示节点与父节点的关系（0为同类，1为捕食，2为被捕食），在查找和合并操作时更新权值以维护动物间关系，通过权值判断输入关系的真假。

两类思路本质都是利用并查集的特性维护动物关系，但实现方式不同。种类并查集直观，通过不同区间表示关系；带权并查集需推导权值更新公式，理解和实现稍难。

### 所选的题解
- **作者：Sooke (赞：2065)  星级：5星**
    - **关键亮点**：思路清晰，适合初学者。从引入种类并查集概念开始，详细解释其原理，结合图片和数据示例，逐步阐述如何利用3倍大小并查集维护动物关系及判断假话，代码注释详细。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include <cstdio>

inline int read() {
    char c = getchar(); int n = 0;
    while (c < '0' || c > '9') { c = getchar(); }
    while (c >= '0' && c <= '9') { n = (n << 1) + (n << 3) + (c & 15); c = getchar(); }
    return n;
}

const int maxN = 100005;

int n, m, ans, fa[maxN * 3];

int find(int u) { return fa[u] == u? u : fa[u] = find(fa[u]); }

int main() {
    n = read(), m = read();
    for (int i = 1; i <= n * 3; i++) { fa[i] = i; }
    for (; m; m--) {
        int opt = read(), u = read(), v = read();
        if (u > n || v > n) { ans++; continue; }
        if (opt == 1) {
            if (find(u + n) == find(v) || find(u) == find(v + n)) { ans++; }
            else {
                fa[find(u)] = find(v);
                fa[find(u + n)] = find(v + n);
                fa[find(u + n + n)] = find(v + n + n);
            }
        } else {
            if (find(u) == find(v) || find(u) == find(v + n)) { ans++; }
            else {
                fa[find(u + n)] = find(v);
                fa[find(u + n + n)] = find(v + n);
                fa[find(u)] = find(v + n + n);
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
```
    - **核心实现思想**：通过`read`函数优化输入，`find`函数查找并查集代表元素。在`main`函数中，初始化3倍大小并查集，根据输入的操作类型`opt`，判断`u`和`v`关系是否与已有关系冲突，若冲突则假话数`ans`加1，否则按规则合并并查集。
- **作者：檀黎斗·神 (赞：599)  星级：4星**
    - **关键亮点**：代码简洁，同样采用3倍并查集，变量命名直观，注释清晰，直接在代码中明确各部分功能。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include<cstdio>
int fa[300005];
int n,k,ans;
inline int read()
{
    int sum=0;
    char ch=getchar();
    while(ch>'9'||ch<'0') ch=getchar();
    while(ch>='0'&&ch<='9') sum=sum*10+ch-48,ch=getchar();
    return sum;
}//读入优化
int find(int x)
{
    if(x!=fa[x]) fa[x]=find(fa[x]);
    return fa[x];
}//查询
int unity(int x,int y)
{
    int r1=find(fa[x]),r2=find(fa[y]);
    fa[r1]=r2;
}//合并
int main()
{
    int x,y,z;
    n=read(),k=read();
    for(int i=1;i<=3*n;++i) fa[i]=i; //对于每种生物：设 x 为本身，x+n 为猎物，x+2*n 为天敌
    for(int i=1;i<=k;++i) 
    {
        z=read(),x=read(),y=read();
        if(x>n||y>n) {ans++; continue;} // 不属于该食物链显然为假
        if(z==1)
        {
            if(find(x+n)==find(y)||find(x+2*n)==find(y)) {ans++; continue;}
            //如果1是2的天敌或猎物，显然为谎言
            unity(x,y); unity(x+n,y+n); unity(x+2*n,y+2*n);
            //如果为真，那么1的同类和2的同类，1的猎物是2的猎物，1的天敌是2的天敌
        }
        else if(z==2)
        {
            if(x==y) {ans++; continue;} //其实是废话但是可以稍微省点时间
            if(find(x)==find(y)||find(x+2*n)==find(y)) {ans++; continue;}
            //如果1是2的同类或猎物，显然为谎言
            unity(x,y+2*n); unity(x+n,y); unity(x+2*n,y+n);
            //如果为真，那么1的同类是2的天敌，1的猎物是2的同类，1的天敌是2的猎物
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心实现思想**：通过`read`函数优化输入，`find`函数查找并查集代表元素，`unity`函数合并并查集。在`main`函数中，初始化3倍大小并查集，根据输入的操作类型`z`，判断`x`和`y`关系是否与已有关系冲突，若冲突则假话数`ans`加1，否则按规则合并并查集。
- **作者：天泽龟 (赞：230)  星级：4星**
    - **关键亮点**：采用带权并查集解法，详细阐述带权并查集概念及权值含义，对查找和合并时权值转移公式推导清晰，有助于理解带权并查集原理。
    - **个人心得**：打表辅助理解权值转移公式。
    - **重点代码**：
```cpp
#include <iostream>  //带权并查集 题解 

using namespace std;

int f[100000],re[100000];  //0-->同种动物，1-->捕食关系，2-->被捕食关系。

int n,m,a,b,p,ans=0;

int find(int a)
{
    int fa=f[a];
    if (a!=fa) {
        f[a]=find(fa);
        re[a]=(re[a]+re[fa])%3;   
        return f[a];
    }
    else return fa;
}
int main()
{
    cin>>n>>m;
    for (int i=1;i<=n;i++) f[i]=i,re[i]=0;
    for (int i=1;i<=m;i++)
    {
        cin>>p>>a>>b;
        if ((a>n||b>n)||(p==2&&a==b)) {   //两种特殊情况 
            ans++; continue;
        }
        if (p==1)  //对关系1讨论 
        {
            int f1=find(a),f2=find(b);
            if (f1==f2&&re[a]!=re[b])  //判断是否在同一棵树及两者是否为同种动物。 
            {
                ans++; continue;
            }
            else if(f1!=f2)
            {
                f[f1]=f2; re[f1]=(3-re[a]+re[b])%3;   //合并 
            }
        }
        if (p==2)  //对关系2讨论 
        {
            int f1=find(a),f2=find(b);
            if (f1==f2) 
            {
                int rela=(re[a]-re[b]+3)%3;  //用两个节点与父亲的关系推出两者关系 

                if (rela!=1) {
//                    cout<<"HERE?"<<endl;
                    ans++; continue;
                }
            }
            else {
                int f1=find(a),f2=find(b);
                f[f1]=f2; re[f1]=(3-re[a]+re[b]+1)%3;   //合并 
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
    - **核心实现思想**：`find`函数在查找并查集代表元素时更新权值`re`。在`main`函数中，初始化并查集和权值数组，根据输入的操作类型`p`，判断`a`和`b`关系是否与已有关系冲突，若冲突则假话数`ans`加1，否则按规则合并并查集并更新权值。

### 最优关键思路或技巧
1. **种类并查集**：通过扩大并查集规模，用不同区间表示不同关系，直观简洁，易于理解和实现，适合处理多种类元素关系问题。
2. **带权并查集**：给并查集边加权表示元素关系，能处理更复杂关系，关键在于准确推导权值更新公式，适用于关系可量化且需动态维护的场景。

### 可拓展之处
同类型题或类似算法套路：此类题目通常涉及多个元素间多种关系的维护与判断，可拓展到其他具有循环关系或复杂依赖关系的场景，如传染病传播关系、任务依赖关系等。解题思路多基于并查集，通过合理设计数据结构（如种类并查集、带权并查集）来维护关系，利用并查集的连通性和传递性判断关系的一致性。

### 推荐题目
1. **P1525 [NOI2010] 关押罪犯**：利用种类并查集解决罪犯关押分组问题，防止冲突。
2. **P1196 [NOI2002] 银河英雄传说**：通过带权并查集维护舰队间相对位置关系。
3. **P2258 [NOI2005] 瑰丽华尔兹**：虽不是典型并查集，但涉及动态规划和状态转移，与本题在关系维护和状态处理上有相似思维方式。 

---
处理用时：162.72秒
# 题目信息

# 学英语

## 题目描述

为了适应紧张的大学学习生活，小 Z 发愤图强开始复习巩固英语。

由于小 Z 对数学比较有好感，他首先复习了数词。小 Z 花了一整天的时间，终于把关于基数词的知识都搞懂了。于是小 Z 非常兴奋，决定出一些题目考考已经过了英语四级、人称英语帝的小 G。考法很简单：小 Z 给出某个整数 $x$ 的英文写法，要求小 D 用阿拉伯数字写出 $x$。

小 Z 会保证以下几点：

1. $-999,999,999 \leq  x \leq 999,999,999$

2. 题目中只会用到以下这些英文单词：

`negative, zero, one, two, three, four, five, six, seven, eight, nine, ten`

`eleven, twelve, thirteen, fourteen, fifteen, sixteen, seventeen, eighteen, nineteen, twenty`

`thirty, forty, fifty, sixty, seventy, eighty, ninety, hundred, thousand, million`

3. 若 $x$ 为负数，题目中第一个单词是 `negative`，否则任何时候都不会出现 `negative` 这个词。

4. 由于小 Z 很牛 B，他不知道像 $103$ 这样的数字要写成 `one hundred and three` 而是直接写成了 `one hundred three`，就是说小 Z 的所有题目中都没有写 `and` 这个词（尽管本应该是要写的），请你谅解。

5. 除了第 4 点， 其他还是基本符合英语的语法规则的， 比如 $1500$ 他会写成 `one thousand five hundred` 而不会写成 `fifteen hundred`。

小 D 拿到题目后不屑地说了一句：水题！写个程序么好了……

但是小 D 要出去玩（此时应该已经在千里之外爽玩了） ，这个任务就交给你了。


## 说明/提示

对于 $100\%$ 的数据，$-999,999,999 ≤ x ≤ 999,999,999$。

## 样例 #1

### 输入

```
six```

### 输出

```
6```

## 样例 #2

### 输入

```
negative seven hundred twenty nine```

### 输出

```
-729```

## 样例 #3

### 输入

```
one million one hundred one```

### 输出

```
1000101```

## 样例 #4

### 输入

```
eight hundred fourteen thousand twenty two```

### 输出

```
814022```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均为将输入的英文单词转换为对应的数字。主要算法要点是通过对每个单词进行判断，依据其代表的数值进行相应计算，如遇到“hundred”则将当前数值乘100，遇到“thousand”或“million”则将当前数值累加到结果中并重置当前数值。解决难点在于处理好不同量级（如千、百万）之间的关系以及负数情况。

从思路清晰度、代码可读性、优化程度等方面综合评分：
1. **Eason_AC**：思路清晰，直接通过简单变量计数并处理，代码简洁明了，可读性高，给5星。
2. **荆棘之心**：使用单链表（实际为vector模拟）增加了不必要的复杂度，代码冗长，给3星。
3. **花千树**：利用map简化赋值过程，思路清晰，但代码在处理细节上稍显冗余，给4星。
4. **zmza**：打表方式，逻辑清晰，但代码中重复判断较多，给3星。
5. **月影**：代码风格较老，通过过程化方式处理，可读性一般，给3星。
6. **__Cocoa__**：思路清晰，代码简洁，给4星。
7. **高泽棵**：代码风格复杂，使用递归处理，可读性较差，给3星。
8. **happybob**：分别展示打表和map两种方式，讲解详细，但代码存在一些小问题，如负数输出位置不对，给3星。
9. **yubing_lml**：详细介绍map的使用，但代码整体较复杂，给3星。
10. **RyanStarrain**：代码逻辑较混乱，处理方式繁琐，给3星。

### 所选题解
1. **Eason_AC（5星）**
    - **关键亮点**：思路直接，变量使用简洁，代码逻辑清晰，易于理解。
    - **核心代码**：
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream> 
using namespace std;

string s;
long long num, now, f;

int main() {
    f = 1;
    while(cin >> s) {
        if(s == "negative") f = -1;
        if(s == "one") now++;
        if(s == "two") now += 2;
        // 省略部分相似判断
        if(s == "hundred") now *= 100;
        if(s == "thousand") num += now * 1000, now = 0;
        if(s == "million") num += now * 1000000, now = 0;
    }
    num += now;
    printf("%lld", num * f);
}
```
    - **核心思想**：通过`now`记录当前数值，`num`累加结果，遇到“thousand”或“million”则将`now`累加到`num`并重置`now`，最后根据是否有“negative”输出结果。
2. **花千树（4星）**
    - **关键亮点**：利用map数据结构简化赋值操作，提供新的解题思路。
    - **核心代码**：
```cpp
#include<map>
#include<cmath>
#include<stack>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
map<string,int>a;
string s;
int ans,sum;
bool flag;
int main(){
    a["one"]=1;
    a["two"]=2;
    // 省略部分相似赋值
    while(cin>>s){
        if(s=="negative")flag=1;
        else if(s!="hundred"&&s!="thousand"&&s!="million")ans+=a[s];
        if(s=="hundred")ans*=100;
        if(s=="thousand")sum+=ans*1000,ans=0;
        if(s=="million")sum+=ans*1000000,ans=0;
        s="";
    }
    // 省略部分重复判断
    sum+=ans;
    if(flag)sum=-sum;
    cout<<sum<<endl; 
    return 0;
}
```
    - **核心思想**：通过map建立英文单词与数值的映射，读入单词时根据其类型进行相应计算，最后输出结果。
3. **__Cocoa__（4星）**
    - **关键亮点**：代码简洁，逻辑清晰，直接对每个单词进行判断处理。
    - **核心代码**：
```cpp
#include <iostream>
#include <string>

using namespace std;
string s;
long long n=0;
long now;
short negpos=1;

int main(){
    while(cin>>s){
        if(s=="negative")negpos=-1;
        else if(s=="zero")now+=0*negpos;
        else if(s=="one")now+=1*negpos;
        // 省略部分相似判断
        else if(s=="hundred")now*=100;
        else if(s=="thousand"){
            n+=1000*now;
            now=0;
        }
        else if(s=="million"){
            n+=1000000*now;
            now=0;
        }
    }
    n+=now;
    cout<<n;
    return 0;
}
```
    - **核心思想**：用`now`记录当前数值，`n`累加结果，根据单词类型进行计算，最后输出结果。

### 最优关键思路或技巧
1. **使用map数据结构**：如花千树的题解，通过map可以简洁地建立英文单词与数值的映射关系，简化代码中的赋值操作，提高代码可读性和简洁性。
2. **合理的变量设计**：像Eason_AC和__Cocoa__的题解，通过合理设置变量（如`now`记录当前数值，`num`或`n`累加结果），使得代码逻辑清晰，易于理解和维护。

### 可拓展思路
此类题目属于字符串处理与数值转换结合的类型，类似算法套路可应用于其他语言数字转换、特定格式字符串解析等问题。例如，将罗马数字转换为阿拉伯数字，或是解析特定格式的数学表达式字符串。

### 推荐题目
1. **P1617 爱与愁的一千个伤心的理由**：与本题相反，是将阿拉伯数字转为英文读法，可巩固相关知识点。
2. **P1055 ISBN号码**：涉及字符串处理与校验计算，与本题在字符串解析上有相似之处。
3. **P1308 统计单词数**：主要考察字符串中单词的统计与查找，与本题处理字符串中的单词有一定关联。

### 个人心得摘录与总结
1. **荆棘之心**：“说实话，这道题我真的十分惭愧……但是我有一种新思路，用了~~单链表~~……虽然使题目变得更~~复杂了~~”。总结：尝试新方法值得鼓励，但要考虑是否会增加不必要的复杂度，需在创新与简洁之间平衡。
2. **月影**：“这题很水，对每个可能输入的单词都加一次判定就行了。主要有两个注意点：（1）千与百万前可能出现one hundred thirty two的情况，所以除了thousand与million两词外的词，都不能直接加到结果中。记得不要忘了在查到千时重置中间量。（2）我用的是字符串读入，在扫描到空格时进行操作，这导致再出循环后要多操作一次，把还存在中间量中的数据加上去。ps.这道题的样例情况非常全，只要样例都能过那应该就没有遗漏什么注意点了。”总结：强调了处理本题的关键细节，如中间量的重置以及字符串读入方式导致的后续处理，同时指出样例的重要性。 

---
处理用时：107.60秒
# 题目信息

# 高精度减法

## 题目描述

高精度减法。

## 说明/提示

- $20\%$ 数据 $a,b$ 在 long long 范围内；
- $100\%$ 数据 $0<a,b\le 10^{10086}$。

## 样例 #1

### 输入

```
2
1```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕高精度减法展开，思路核心是模拟竖式运算。算法要点包括用数组或字符串存储大数，处理借位、判断结果正负及去除前导零等。解决难点在于处理借位情况、正确比较两数大小以及处理结果为负数和前导零的输出。

多数题解质量中等，部分题解代码冗长，部分未考虑全面情况。综合来看，stone_juice石汁和取名困难症的题解相对较好，思路清晰且代码可读性高。

### 所选的题解
1. **作者**：stone_juice石汁
    - **星级**：5星
    - **关键亮点**：思路清晰，从高精度需求引入，详细讲解数组存储大数、竖式减法运算、借位处理及输出坑点，配有图片和详细注释，代码简洁明了。
    - **个人心得**：多次修改题解，不断优化批注、增加细节、调整码风并解决小BUG。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define MAXN 10500 
using namespace std;

string a, b;
int na[MAXN], nb[MAXN], ans[MAXN]; 
bool pd;

int main()
{
    cin >> a >> b;
    if((a < b && a.size() == b.size()) || a.size() < b.size())
    {
        swap(a, b);
        pd = true;
    }
    for(int i = a.size(); i > 0; i --)na[i] = a[a.size() - i] - '0';
    for(int i = b.size(); i > 0; i --)nb[i] = b[b.size() - i] - '0';
    int maxl = max(a.size(), b.size());
    for(int i = 1; i <= maxl; i ++)
    {
        if(na[i] < nb[i])
        {
            na[i + 1] --;
            na[i] += 10;
        }
        ans[i] = na[i] - nb[i];
    }
    while(ans[maxl] == 0)maxl --;
    if(pd == true)cout << "-";
    for(int i = maxl; i > 0; i --)cout << ans[i];
    if(maxl < 1)cout << "0";
    return 0;
}
```
    - **核心思想**：先比较输入字符串a和b的大小，若a小于b则交换并标记。将字符串转化为数组存储，模拟竖式减法逐位相减，处理借位，最后根据标记输出结果，同时处理前导零。
2. **作者**：取名困难症
    - **星级**：4星
    - **关键亮点**：使用重载运算符实现高精度减法，采用压位高精优化，代码注释详细，科普了重载运算符相关知识。
    - **重点代码**：
```cpp
#include<bits/stdc++.h> 
using namespace std;
const int M=100000000,P=8;
struct bignum 
{
    int n[5001],l; 	
    bignum()
    {
        l=1;
        memset(n,0,sizeof(n));
    }
    void init()
    {
        string s;
        cin>>s;
        int now=0,ct=0,c1=1; 
        for(int i=s.length()-1;i>=0;i--)
        {
            n[now]+=(s[i]-'0')*c1;
            c1*=10;
            ct++;
            if(ct==P&&i!=0) 
            {
                now++;
                ct=0;
                c1=1;
            }		
        }
        l=now+1; 
    }
    void print()
    {
        printf("%d",n[l-1]);
        for(int i=l-2;i>=0;i--)	
        	printf("%0*d",P,n[i]);  
        cout<<endl;
    }
    bignum operator -(bignum x) const
    {
        bignum t=*this;
        if(t<x)
        {
            printf("-");
            swap(t,x);
        }
        int sum=0;
        for(int i=0;i<t.l;i++)
        {
            t.n[i]-=x.n[i];
            while(t.n[i]<0)
            {
                t.n[i]+=M;
                sum++;
            }
            t.n[i+1]-=sum;
            sum=0;
        }
        while(!t.n[t.l-1]&&t.l>1)
            t.l--; 
        return t;
    }
};
bignum a,b,c;
int main()
{
    a.init();	
    b.init();
    c=a-b;
    c.print();
    return 0;
}
```
    - **核心思想**：定义bignum结构体，重载减法运算符。init函数将输入字符串按压位方式存储到数组，减法运算时先判断大小，若被减数小则输出负号并交换，逐位相减并处理借位，最后输出结果并处理前导零。

### 最优关键思路或技巧
1. **数据结构**：使用数组或字符串存储大数，利用数组模拟竖式运算，方便逐位操作。
2. **算法优化**：部分题解采用压位高精，减少数组长度，提高运算效率。如取名困难症的题解，以8位数为运算单位，每8位在数组里进1位。
3. **代码实现技巧**：将字符串转化为数组存储时，利用字符串的长度和下标特性，方便获取每一位数字。同时，在处理借位、判断大小和输出结果时，采用简洁有效的代码逻辑，如stone_juice石汁题解中处理借位和前导零的方式。

### 可拓展思路
同类型题可涉及高精度加法、乘法、除法等运算，思路类似，都是模拟竖式运算，处理好进位、借位等细节。类似算法套路还可应用于处理大整数的各种数学运算，以及密码学中的大数计算场景。

### 相似知识点题目推荐
1. **P1601 A+B Problem（高精）**：高精度加法，与本题类似，需处理好进位问题。
2. **P1303 A*B Problem**：高精度乘法，模拟竖式乘法运算，注意进位和结果位数。
3. **P2142 高精度减法**：同样是高精度减法，可进一步巩固相关知识点。 

---
处理用时：93.83秒
# 题目信息

# 公路维修问题

## 题目描述

由于长期没有得到维修，A国的高速公路上出现了 $n$ 个坑。为了尽快填补好这 $n$ 个坑，A国决定对 $m$ 处地段采取交通管制。为了求解方便，假设A国的高速公路只有一条，而且是笔直的。现在给出 $n$ 个坑的位置，请你计算，最少要对多远的路段实施交通管制？


## 说明/提示

[样例说明]


交通管制的地段分别为：$3-8,14-21,25-31,40-43$。

## 样例 #1

### 输入

```
18 4
3 4 6 8 14 15 16 17 21 25 26 27 30 31 40 41 42 43
```

### 输出

```
25```

# AI分析结果

• 综合分析与结论：这些题解均围绕公路维修问题，采用贪心算法结合排序来解决。思路要点为计算坑与坑之间的距离，对这些距离排序后，用第一个坑到最后一个坑的总距离减去m - 1个最长的坑间距，得到的结果再加上m。难点在于理解为什么要减去最长的坑间距以及为何最后要加上m 。不同题解在代码实现细节上略有差异，如数组定义、输入方式、排序方式等。
• 所选的题解：
  - 作者：KEVIN_L (4星)
    - 关键亮点：思路清晰，先假设所有坑都被管制，再减去尽可能大的无坑路段，代码简洁明了。
    - 重点代码及核心思想：
```cpp
#include<cstdio>
#include<algorithm>           //包含sort
int n,m;
int a[15005],b[15005],ans;
bool cmp(int k,int h){        //cmp函数用于让sort从大到小排列
    return k>h;
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    ans = a[n] - a[1] + 1;
    for(int i=1;i<n;i++)       //计算出每一个坑的距离
        b[i] = a[i+1] - a[i];
    std::sort(b+1,b+n,cmp);    //从大到小排序
    for(int i=1;i<m;i++){      //从中间舍去m-1段不需要的最长的路段 
        ans = ans - b[i] + 1;
    }
    printf("%d\n",ans);

    return 0;                  //华丽的结束QAQ
}
```
核心思想是先计算总距离，再减去m - 1个最长的坑间距，最后输出结果。
  - 作者：Elma_  (4星)
    - 关键亮点：详细解释了贪心的正确性，从使管制路段浪费长度最小的角度出发，逻辑连贯。
    - 重点代码及核心思想：
```cpp
#include <algorithm>
#include <cstdio>
using namespace std;

const int MAXN = 100005;
int n, m;
int a[MAXN], large[MAXN];//a数组存储每个坑的位置，large数组存储每两个坑之间的距离

int main() {
    scanf("%d%d", &n, &m);
    for (int i=0;i<n;i++)
        scanf("%d", &a[i]);//输入，不解释

    for (int i=0;i<n-1;i++)//n个坑之间只会出现n-1个距离，这里记得是到n-1
        large[i] = a[i + 1]-a[i]-1;//两端的两个坑不算，这里记得-1

    sort(large, large+n-1);//排序，不解释

    int ans = a[n - 1]-a[0]+1;//将管制路段总长初始化为第1个坑到第n个坑之间的距离。和前面不一样，由于两端的坑都要算，所以要+1
    for (int i=1;i<=m-1;i++)//m个路段有m-1个间隙，这里-1;
        ans -= large[n-1-i];//依次减去第1到第n-1小的两坑之间距离

    printf("%d\n", ans);//输出，完美AC~
}
```
核心思想是先求出坑间距并排序，用总距离减去m - 1个最小的坑间距得到结果。
  - 作者：_StarBird_ (4星)
    - 关键亮点：详细推导了从dp到贪心的思路转变过程，对可能出现的错误及原因进行了分析，如区间长度计算问题。
    - 重点代码及核心思想：
```cpp
#include<bits/stdc++.h>
#define MAXN 15010
using namespace std;
int n,m;
int arr[MAXN],dis[MAXN]; //分别表示每个点的位置和相邻两点的距离 
bool cmp(int x,int y) //sort的排序标准 
{
    return x>y; //从大到小排 
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
    {
        scanf("%d",&arr[i]); //读入每个坑的位置（其实arr数组可以优化掉，但这里会影响阅读体验，可以自行思考 
        if (i>1) dis[i-1]=arr[i]-arr[i-1]; //处理出相邻两点间的距离 
    }
    sort(dis+1,dis+n,cmp); //排序 
    int res=arr[n]-arr[1]; //一开始答案赋值为区间的总长度 
    for(int i=1;i<m;++i) res-=dis[i]; //可以不用取m-1段区间的长度 
    printf("%d\n",res+m); //少算了m个单位长度，输出时加上m 
    return 0; //程序结束记得return（20071007 
}
```
核心思想是先计算坑间距并从大到小排序，用总距离减去m - 1个最长坑间距，最后加上m得到结果。
• 最优关键思路或技巧：将问题转化为在一维数轴上用m个区间覆盖n个点，使区间长度和最小。通过贪心策略，选择舍弃m - 1个最长的点间距，同时注意区间长度计算时要加上端点的长度（即最后结果加上m）。
• 可拓展之处：同类型题可涉及在多个区间或线段中进行选择，以满足某种最优条件，如最小覆盖、最大收益等。类似算法套路是先分析问题找到可贪心的策略，通常与排序结合，根据题目要求对元素进行排序后选择或舍弃部分元素。
• 推荐题目：
  - P1080 [NOIP2012 提高组] 国王游戏：贪心算法，通过对数据排序找到最优分配策略。
  - P1199 [NOIP2010 普及组] 三国游戏：贪心策略结合对局面的分析。
  - P1094 [NOIP2007 普及组] 纪念品分组：贪心算法，通过排序和双指针法进行分组。
• 个人心得摘录及总结：
  - 作者KEVIN_L：蒟蒻第一次写题解，请多多包涵。总结：初次写题解表达对读者的期望。
  - 作者Elma_ ：本蒟蒻的第一篇题解，写得不好的地方恳请大家指出。总结：初次写题解希望得到指正。
  - 作者_StarBird_ ：一开始想到dp但复杂度过不去，后分析出贪心解法，还注意到区间长度计算易错点。总结：分享解题思路转变过程及易错点。 

---
处理用时：102.04秒
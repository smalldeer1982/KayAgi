# 题目信息

# 计算器弹琴

## 题目描述

总所周知，计算器可以拿来干很多它本不应该干的事情，比如写作文。（参看洛谷P2549）

小A发现了一个计算器的另一个隐藏功能——弹琴。


http://www.bilibili.com/video/av2205500/

如果按上一个键，比如说1，就会发出中音“Do”。

这边给出按键音高表

```cpp
+ 低音Fa
< 低音So
* 低音La
/ 低音Xi
1 中音Do
2 中音Re
3 中音Mi
4 中音Fa
5 中音So
6 中音La
7 高音Xi
8 高音Do
9 高音Re
= 高音Mi
% 高音Fa
C 高音So
M 高音La
```
现在小A搞到了一份乐谱——我们称为计算器谱，一种变形的简谱。

时值（也就是按的时间长度）是这么记录的，例如：

1 是四分音符，占1拍。

1- 是二分音符，占2拍。

1--- 是全音符，占四拍。

对于小于四分音符的音符，我们用嵌套括号表示，例如

(1(34(56))2)

1和2在一层括号中，是八分音符，占0.5拍。

3和4在两层括号中，是16分音符，占0.25拍。

5和6在三层括号中，是32分音符，占1/8拍。当然实际上比较少见。

括号中不会出现‘-’这个符号。

不会出现四层或以上的括号。

在一个音符后面添加一个附点即“.”表示这个音符延长1/2倍。

例如
1-.是3拍，1.是1.5拍，(3.(45.))3是3/4拍，4是1/4拍，5是3/8拍。

附点不会连续添加两个或以上，也不会出现超过四拍的音符。

不考虑其他的乐理符号。

另外整个乐谱会给一个速度，整数，意思是一分钟多少拍。


为了美观，乐谱可以随便换行、添加空格。这个忽略即可。

现在小A想知道，按完这个谱子，需要多少时间（单位：秒）


## 说明/提示

样例1说明：（一共32拍，每分钟60拍，所以是32秒。对了，这是欢乐颂的开头部分）

样例2说明：（一共80拍，别问我怎么数的，一分钟120拍的话，是40秒。至于这是什么曲子？根据相关的法律政策，该部分未予显示。）



http://bd.kuwo.cn/yinyue/4641527

对于40%的数据，没有附点没有括号

对于100%的数据，括号层数不会超过3层，不超过100行，每行不超过100个字符。

对于其中的一个数据，是《千本樱》。


## 样例 #1

### 输入

```
2 60
3345 5432 1123 322-
3345 5432 1123 211-```

### 输出

```
32
```

## 样例 #2

### 输入

```
5 120
3(1.(3))55 8(7.(6))65 655(3.(1)) (4.(4))32- 
3(1.(2))35 8(7.(6))65 655(4.(3)) (2.(3))21- 
2.(3)44 6(6.(6))(5.(4))3 3.(5)88 (9.(8)7.(6))5-
=.(=)(9.(8))7 9.(8)(7.(6))5  8(856543) (2.(3))43- 
=.(=)(9.(8))7 9.(8)(7.(6))5  8(857654) (3.(4))21- ```

### 输出

```
40
```

# AI分析结果

• 综合分析与结论：这些题解均围绕计算器弹琴乐谱节拍时间计算问题，思路核心是遍历乐谱字符串，根据不同符号调整节拍计数。算法要点在于对特殊符号（如括号、附点、延长符）的处理逻辑。解决难点主要是正确处理不同符号组合下的节拍计算，如附点与括号、延长符的组合。各题解思路相近，差异主要体现在代码实现细节和可读性上。

所选的题解：
  - 作者：见贤思齐_Seakies (赞：7，4星)
    - 关键亮点：思路清晰，详细解释音乐知识和各符号处理逻辑，代码注释详尽，对特殊情况 `1-.` 有专门判断。
    - 个人心得：无
    - 核心代码片段：
```cpp
for (int i = 0; i < s.size(); i++) { 
    switch (s[i]) { 
        case '-': sum++, cnt[i] = cnt[i - 1] + 1; break; 
        case '.': {
            if (s[i - 1] == '-') {
                cnt[i] = (sum + 1) * 0.5 + cnt[i - 1]; 
                sum = 0; 
                break;
            }
            cnt[i] = 1 / pow(2, num) * 0.5 + cnt[i - 1]; 
            break;
        } 
        case '(': sum = 0, num++, cnt[i] = cnt[i - 1]; break; 
        case ')': sum = 0, num--, cnt[i] = cnt[i - 1]; break; 
        case ' ': cnt[i] = cnt[i - 1]; break;
        case '\n': cnt[i] = cnt[i - 1]; break;
        case '\r': cnt[i] = cnt[i - 1]; break; 
        default: sum = 0, cnt[i] = 1 / pow(2, num) + cnt[i - 1]; break; 
    } 
}
```
核心实现思想：通过 `switch` 语句判断字符，根据不同字符更新节拍计数 `cnt`，处理延长符 `-`、附点 `.`、括号 `()` 等特殊情况。

  - 作者：tauyoung (赞：13，4星)
    - 关键亮点：代码简洁高效，利用 `switch` 语句处理字符，通过 `st` 变量记录括号层数，直接累加节拍时间。
    - 个人心得：无
    - 核心代码片段：
```cpp
for(int i=0;i<Length;i++) {
    switch(s[i]) { 
        case ' ':
        case '\r':
        case '\n':break; 
        case '(':st++;break; 
        case ')':st--;break; 
        case '.':itime+=pow(0.5,st+1);break; 
        default:itime+=pow(0.5,st); 
    }
}
```
核心实现思想：遍历字符串，依据字符类型，利用 `pow` 函数结合括号层数 `st` 计算并累加节拍时间。

最优关键思路或技巧：利用一个变量记录括号层数，通过 `switch` 语句对不同字符进行分类处理，依据音乐节拍规则更新节拍计数。处理附点时，注意结合前一个字符（是否为延长符）进行特殊判断。

可拓展之处：同类型题可涉及更复杂的乐谱符号（如三连音、切分音等）或节奏规则。类似算法套路是处理具有层次结构（如括号表示）和特殊标记（如附点）的序列数据。

推荐题目：
  - P1085 [NOIP2004 普及组] 不高兴的津津
  - P1425 小鱼的游泳时间
  - P1909 [NOIP2016 普及组] 买铅笔 

---
处理用时：48.78秒
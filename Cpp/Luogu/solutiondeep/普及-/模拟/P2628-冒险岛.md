# 题目信息

# 冒险岛

## 题目背景

冒险岛是费老师新开发的一种情景模拟电脑的游戏，通过掷骰子（1~6个数字之间），让一种人物（棋子）在棋纸上从左至右的行走，从而模拟冒险的故事……


## 题目描述

棋纸上有一条从左至右的很长的路，整条路是一连串符号组成，表明路的状况，棋子必须在符号组成的路上行走。每掷一下骰子得到的数字，棋子就可以走掷得的数字所对应的步数，比如掷3，就可以走3步。

路上有两种特殊符号可以改变棋子的行走。

一种是“>”符号，一旦棋子走完了掷骰子的步数，最终停留在这个符号上，后面有紧跟着2个以上“>”，那么棋子就可以获得前进奖励，可以沿着“>”一直一步步前进，直到遇到一个不是“>”的符号位置停下来。

还有一种是“\*”符号，一旦棋子走完了掷骰子的步数，最终停留在这个符号上，后面又紧跟着两个以上“\*”，就要受到后退惩罚，需要退后k步，这个k步就是从当前“\*”开始的连续的“\*”的数量。

每次掷数后，奖励或惩罚至多一次，如果奖励或惩罚后棋子又落在第二种特殊符号上，则不能再受到奖励或惩罚。

如果走的棋子超出棋纸右边界最后一个符号，则停在最后一个符号上；如果超出左边界，则停在第一个符号上。

若干次掷骰子后，请问游戏中的人物（棋子）走到了哪步？离终点还差几步？


## 说明/提示

【样例说明】

在游戏中，第一次掷的是5，则走到第一个>的位置，获得奖励前进至左起第二个f处。第二次掷的是6，则走到\*的位置，受惩罚退3步，至d处。第三次掷的是6，则走至左起第四个>号处，获奖励前进至f。最终棋子停留的符号是第20个（从左至右的数），离终点符号d（含）相差5步数。

【数据范围】

对于50%的数据，1<=s的长度<=255,0<=n<=1000。

对于100%的数据，256<=s的长度<=1000000,0<=n<=100000。


## 样例 #1

### 输入

```
yhfA>>>fhsdfa***>>>foaoad

3

5 6 6```

### 输出

```
20 5```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解均采用模拟思路，按照题目规则模拟棋子在棋纸上的移动过程。
    - 算法要点：读入棋纸字符串和掷骰子次数及点数，根据棋子停留位置判断是否触发特殊符号奖励或惩罚，同时处理越界情况。
    - 解决难点：一是处理输入字符串，因可能含空格需用`getline`，且要注意不同系统换行符差异；二是初始化棋子位置为 -1 而非 0；三是正确判断特殊符号数量及处理奖励惩罚规则。部分题解提到后缀和优化或预处理特殊符号，以避免超时。
    - 整体来看，多数题解思路清晰，但在代码可读性、优化程度上有所差异。

所选的题解：
  - 作者：Mono_pigsicklie (4星)
    - 关键亮点：思路清晰表述为纯模拟，代码简洁明了，直接按照题目规则实现移动、奖励和惩罚逻辑。
    - 个人心得：强调开始棋子不在棋盘上需注意，判断倒退时要加上‘*’符号格数，读题要仔细。
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,a,cishi=-1,tot=0;
int main() {
    getline(cin,s);
    scanf("%d",&n);
    int length=s.length()-1;
    for(int i=1; i<=n; i++) {
        scanf("%d",&a);
        cishi+=a;
        if(cishi>=length) cishi=length-1;
        if(s[cishi]=='>'&&s[cishi+1]=='>'&&s[cishi+2]=='>')
            while(s[cishi]=='>')cishi++;
        else if(s[cishi]=='*'&&s[cishi+1]=='*'&&s[cishi+2]=='*') {
            while(s[cishi+tot]=='*')tot++;
            cishi-=tot;
        }
        if(cishi<0)cishi=0;
        if(cishi>=length)cishi=length-1;
    }
    cout<<cishi+1<<' '<<length-1-cishi;
    return 0;
}
```
核心实现思想：读入字符串和掷骰子次数及点数，每次移动后根据当前位置字符判断是否触发奖励或惩罚，同时处理越界情况，最后输出棋子位置和离终点距离。

  - 作者：smallC233 (4星)
    - 关键亮点：除实现模拟过程，详细分析了`getline`在不同系统下因换行符处理差异导致结果不同的问题，并给出解决办法，代码结构清晰，有快读优化。
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

inline int read(void){   //快读
    register int x=0;
    register char ch=getchar();
    while(ch<'0'||ch>'9'){ch=getchar();}
    while('0'<=ch&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48); ch=getchar();}
    return x;
}
string s;
int n,x;
int now=-1;//当前位子，注意是从-1开始的！

int main()
{
    getline(cin,s);
    int len=s.size()-1;
    if(s[len]==13){len--;}
    n=read();
    for(int i=1; i<=n; i++){
        x=read();
        now+=x;
        if(now>=len){now=len; continue;}
        if(s[now]=='>'){
            int cnt=0;
            for(int j=now; j<=len; j++){
                if(s[j]=='>'){
                    cnt++;
                }
                else{break;}
            }
            if(cnt>2) now+=cnt;
            if(now>len){now=len;}
            continue;
        }
        if(s[now]=='*'){
            int cnt=0;
            for(int j=now; j<=len; j++){
                if(s[j]=='*'){
                    cnt++;
                }
                else{break;}
            }
            if(cnt>2) now-=cnt;
            if(now<0){now=0;}
            continue;
        }
    }
    printf("%d %d\n",now+1,len-now);
    return 0;
}
```
核心实现思想：先处理输入字符串长度避免换行符影响，通过快读读入数据，每次移动棋子后判断特殊符号并处理，同时处理越界情况，输出最终结果。

  - 作者：FLASH_CM (4星)
    - 关键亮点：提出用后缀和优化避免超时，从后往前预处理每个点奖励或惩罚的距离，记录在数组中，优化了时间复杂度。
```cpp
#include <bits/stdc++.h>
using namespace std;

char s[1000010];

int add[1000010],a[1000010];

int main(){
    int len,i,j,k,m,n;
    gets(s);
    len=strlen(s)-1;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(i=len-1;i>=0;i--){
        if(s[i]=='>'){
            if(s[i+1]!='>')
                add[i]=1;
            else
                add[i]=add[i+1]+1;
        }
        if(s[i]=='*'){
            if(s[i+1]!='*')
                add[i]=1;
            else
                add[i]=add[i+1]+1;
        }
    }
    a[1]--;
    k=0;
    for(i=1;i<=n;i++){
        k+=a[i];
        if(add[k]>=3){
            if(s[k]=='>')
                k+=add[k];
            else if(s[k]=='*')
                k-=add[k];
        }
        if(k<0)
            k=0;
        if(k>len-1)
            k=len-1;
    }
    k++;
    printf("%d %d\n",k,len-k);
    return 0;
}
```
核心实现思想：读入字符串和数据后，预处理特殊符号连续个数存于`add`数组，移动棋子时根据`add`数组判断并处理奖励惩罚，同时处理越界，最后输出结果。

最优关键思路或技巧：
    - **预处理优化**：如FLASH_CM等题解采用从后往前预处理特殊符号连续个数，用数组记录，避免每次移动都重复统计，降低时间复杂度，在大数据量下有效防止TLE。
    - **输入处理**：注意`getline`在不同系统下换行符差异，通过减去多余长度或特判处理。
    - **边界及特殊规则处理**：初始化棋子位置为 -1，严格按照题目规则处理特殊符号奖励惩罚及越界情况。

可拓展之处：此类题目属于模拟类算法题，类似套路包括模拟游戏过程、模拟数据处理流程等。关键在于理解题目规则，用代码准确实现，可通过多练习不同场景的模拟题来举一反三。

推荐洛谷题目：
    - P1032 [NOIP2002 普及组] 字串变换
    - P1046 [NOIP2005 普及组] 陶陶摘苹果
    - P1423 小玉在游泳

个人心得摘录与总结：
    - Mono_pigsicklie：强调开始棋子不在棋盘上，判断倒退格数要准确，读题需仔细，否则易卡部分数据点。
    - smallC233：指出`getline`在不同系统下因换行符处理不同会导致结果差异，要注意处理。
    - _0x46EDC：总结出棋子初始位置、特殊符号判断条件、边界判断及输出格式等多个易错点，强调读题思考重要性。 

---
处理用时：99.62秒
# 题目信息

# 神秘磁石

## 题目背景

在遥远的阿拉德大陆，有一种神秘的磁石，是由魔皇制作出来的，


## 题目描述

1. 若给他一个一维坐标系，那么他的磁力一定要在素数坐标的位置上才能发挥的最大（不管位置坐标的大小，只要是素数那么磁力就一样大）。
2. 若两个磁石相距为 $k$，那么磁石间的破坏力将会达到当前磁力的峰值

显然，两磁石间最大破坏力取决于磁力大小和磁石间距，那么请问给出长度不超过 $n$ 的一维坐标系，有哪几对坐标间磁石破坏力最大。


## 说明/提示

对于 $100\%$ 的数据，$1\leq k\leq n\leq 10^4$。

## 样例 #1

### 输入

```
6924 809```

### 输出

```
2 811
```

# AI分析结果

这道题要求在长度不超过n的一维坐标系中，找出所有相距为k且坐标为素数的点对。题解主要围绕判断素数和寻找符合条件的素数对展开，采用了多种方法。
1. **思路与算法要点**
    - **打表法**：预先计算并存储10000以内的素数，在主程序中直接使用，避免重复判断。如YLWang和青蛙王子的题解，通过生成素数表文件，然后在代码中引用。
    - **筛法**：通过标记合数来筛选出素数。引领天下、Atmizz、我是蒟弱、YWY_wys、Demons等使用了筛法，其中引领天下和我是蒟弱提到的线性筛法优化了普通筛法，避免了重复标记合数，提高了效率。
    - **暴力枚举**：直接从2到n - k枚举，判断每个数及其加上k后的数是否为素数。如Qing_s、lzhdbfs、Leaved_、微香玉烛暗、御坂10027号、Sinwind、米奇奇米、HPXXZYY、ricky_lin、maorui_cow等采用此方法，部分通过一些优化（如只判断奇数、先判断2 + k等）来减少判断次数。
2. **解决难点**：主要难点在于高效判断素数和避免重复判断。打表法通过提前计算避免运行时判断；筛法通过标记合数减少判断次数；暴力枚举则通过一些优化策略减少不必要的判断。
3. **题解评分**
    - **YLWang（4星）**：详细介绍打表法，包括打表程序的编写及如何应用到主程序，思路清晰，代码可读性较好。
    - **青蛙王子（3星）**：同样采用打表法，但相比YLWang，对过程描述稍显简略，代码可读性一般。
    - **引领天下（4星）**：提出筛法并优化，通过保存质数提高效率，思路清晰，代码简洁。
    - **Qing_s（3星）**：采用朴素算法，对思路和代码解释较详细，但算法本身未优化，效率较低。
    - **陈LC（3星）**：使用质数的线性筛，但代码逻辑稍显复杂，可读性欠佳。
    - **likztime（3星）**：引入Miller_Rabin算法，理论上效率高，但代码复杂，且该算法不稳定。
    - **_Grey（3星）**：利用6倍原理判断素数，有一定优化，但整体思路和代码中规中矩。
    - **zhaowangji（3星）**：结合桶排思想判断素数，思路较新颖，但代码实现和解释不够清晰。
    - **JackcreaM（3星）**：介绍素数筛法并给出代码，但对筛法原理解释不够深入，代码无特殊优化。
    - **lzhdbfs（2星）**：采用朴素判断素数方法，代码简单但未优化，对思路和代码的阐述较少。
    - **Leaved_（2星）**：纯暴力枚举，代码简单直接，无优化，对思路描述简略。
    - **Atmizz（3星）**：使用线性筛素数，但重点在于判重问题，对筛法本身阐述不够全面。
    - **我是蒟弱（4星）**：详细介绍线性筛素数原理及代码实现，对线性筛法讲解深入，代码清晰。
    - **TheAurora（3星）**：打表法，代码实现较繁琐，对打表过程和代码解释不够清晰。
    - **微香玉烛暗（3星）**：采用函数判断质数并枚举，代码常规，对思路和代码解释较清楚。
    - **逍遥__天赐（3星）**：先判断k和n关系，再素数打表，思路较清晰，但代码整体无突出亮点。
    - **flynn0512（2星）**：筛素数并循环检验，代码有错误且对思路阐述不够清晰。
    - **chenjiarui（3星）**：定义函数实现筛素数和判断输出，代码逻辑较清晰，但整体无特殊优化。
    - **御坂10027号（2星）**：采用简单判断素数方法并枚举，代码和思路无突出之处。
    - **Sinwind（2星）**：暴力枚举判断素数对，代码和思路常规，无优化。
    - **米奇奇米（2星）**：定义函数判断质数并枚举，代码简单直接，无优化。
    - **HPXXZYY（2星）**：判断素数并枚举，代码常规，优化点仅为保存sqrt结果。
    - **ricky_lin（2星）**：暴力枚举并对2先判断，代码简单，优化有限。
    - **maorui_cow（2星）**：暴力枚举判断素数对，代码和思路无特殊之处。
    - **YWY_wys（3星）**：使用欧拉筛法并遍历素数数组判断，对筛法和思路阐述较清楚。
    - **wangweiba（2星）**：代码为Pascal且注释较少，思路阐述不清晰。
    - **Demons（3星）**：详细介绍筛法优化过程并给出代码，对筛法讲解较深入。
    - **lizehan888（2星）**：给出Pascal代码框架，对思路和代码解释极少。
    - **Tom_com（2星）**：暴力枚举判断素数对，代码逻辑较混乱，可读性差。

**所选4星题解**：
 - **YLWang（4星）**
    - **关键亮点**：详细阐述打表法，包括打表程序创建及主程序应用，思路清晰，代码可读性好。
    - **个人心得**：强调打表法在不想使用O(n)素数筛法时的实用性，特别是面对较大数据时可通过打表在O(1)时间内判断质数。
    - **重点代码**：打表程序
```cpp
#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i, j, k) for(int i=(j);i<=(k);i++)
#define INF (2147483647>>1)
using namespace std;
inline int read()
{
    int num=0;
    char c=' ';
    bool flag=1;
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') flag=0;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return flag?num:-num;
}
//这是暴力判断
bool pd(int x) {
	if(x == 1 || x == 0) return 0;
	if(x == 2) return 1;
	int g = sqrt(x) + 1;
	For(i, 2, g) {
		if(!(x % i)) {
			return 0;
		}
	}
	return 1;
} 
int main()
{
	//打出来的字符太多，屏幕上存不下QAQ，所以只能输出到文件内
	freopen("stone.txt", "w", stdout);
	For(i, 1, 10000) {//输出每个数
		if(pd(i)) printf("1,");                    
		else printf("0,");
	}
	
	return 0;
}
```
主程序
```cpp
#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i, j, k) for(int i=(j);i<=(k);i++)
#define INF (2147483647>>1)
using namespace std;
inline int read()
{
    int num=0;
    char c=' ';
    bool flag=1;
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') flag=0;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return flag?num:-num;
}
#define N 10005
int p[N] = {0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0...};//省略
int main()
{
	int n = read(), k = read();
	bool flag = 0;
	For(i, 1, n-k) {
		if(p[i] && p[i+k]) {
			printf("%d %d\n", i, i+k);
			flag = 1;
		}
	}
	if(!flag) {
		printf("empty\n");
	}
	return 0;
}
```
核心实现思想：打表程序通过暴力判断每个数是否为素数，并将结果输出到文件。主程序读取文件内容存入数组，通过遍历数组找到相距为k的素数对。
 - **引领天下（4星）**
    - **关键亮点**：提出筛法并优化，通过保存质数数组，直接循环质数提高效率。
    - **重点代码**：
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <iostream>
#include <iomanip>
using namespace std;
int n,k,a[3000],ps;//n，k为题目中的变量，a数组为质数数组，ps为质数下标
bool s[10005]={1,1},ok=1;//s数组为桶，ok为判断有没有满足条件的质数对的变量
void $(){
    for (int i=2;i<10001;i++)//筛法标准做法
    if (!s[i]){//s[i]=1表示不为质数，=0则是
        a[ps++]=i;//把i这个质数存下来
        for (int j=i*2;j<10001;j+=i)s[j]=1;//循环标记
    }
}
int main(){
    $();//预处理
    scanf ("%d%d",&n,&k);
    for (int i=0;a[i]<=n&&a[i]+k<=n;i++)if (!s[a[i]+k])//暴力，符合条件就输出
    ok=!printf ("%d %d\n",a[i],a[i]+k);
    if (ok)printf ("empty");//没有就输出empty
        //不要被题目中“相差为k的质数对”所迷惑，实际上，如果你多判一次a[i]-k，答案会输出两遍。具体为什么，自己想。
    return 0;
}
```
核心实现思想：通过筛法标记合数，并保存质数到数组a。在主程序中遍历质数数组a，判断每个质数加上k后是否仍为质数，若是则输出。
 - **我是蒟弱（4星）**
    - **关键亮点**：详细介绍线性筛素数原理，通过优化避免合数被重复筛，提高效率，代码清晰。
    - **个人心得**：强调线性筛素数的高效性，通过具体例子解释优化部分的原理，帮助理解。
    - **重点代码**：线性筛部分
```cpp
for(int i=2;i<=n;i++){
    if(f[i]){//质数
        prime[++t]=i;//储存
    } 
    for(int j=1;j<=t&&i*prime[j]<=n;j++){//不断地筛数
        f[i*prime[j]]=false;//倍数，筛掉
        if(i%prime[j]==0){//优化
            break; 
        }
    }
}
```
判断输出部分
```cpp
bool output=false;//判断是否输出 
for(int i=2;i<=n-q;i++){//循环
    //到n-q就行了，因为再往上循环，i+q的那个磁石也会超范围 
    if(f[i]&&f[i+q]){//两个都是素数 
        printf("%d %d\n",i,i+q);//输出i和i+q并换行 
        output=true;//已经输出了 
    }
}
if(output==false){//没有输出 
    printf("empty");//按照题意，输出empty 
}
```
核心实现思想：线性筛部分通过标记质数的倍数为合数来筛选素数，利用优化条件避免重复筛除。判断输出部分遍历筛选出的素数，找到相距为q的素数对并输出，若无则输出empty。

**最优关键思路或技巧**：线性筛素数是较优的方法，通过标记合数且避免重复标记，时间复杂度达到线性，提高了效率。如我是蒟弱的题解中详细阐述的线性筛原理及实现，通过`if(i%prime[j]==0) break;`这一优化条件，确保每个合数只被筛一次。

**可拓展思路**：此类题目可拓展到更大数据范围的素数判断和相关计算。类似算法套路包括不同的素数筛法（如埃氏筛、欧拉筛等），以及利用数论性质优化判断过程。对于更大数据，可能需要更高效的随机化算法如Miller_Rabin算法，但要注意其不稳定性。

**相似知识点洛谷题目**：
 - **P3383 【模板】线性筛素数**：直接考察线性筛素数的实现。
 - **P1075 [NOIP2012 普及组] 质因数分解**：需要判断素数并进行质因数分解，涉及素数判断和相关计算。
 - **P1217 [USACO1.5]回文质数 Prime Palindromes**：结合回文数和素数判断，考察对素数性质的运用和判断方法。 

---
处理用时：256.18秒
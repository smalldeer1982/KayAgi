# 题目信息

# 覆盖

## 题目背景

WSR 的学校有 $B$ 个男生和 $G$ 个女生都来到一个巨大的操场上扫地。

## 题目描述

操场可以看成是 $N$ 行 $M$ 列的方格矩阵，如下图 (1) 是一个 $4$ 行 $5$ 列的方格矩阵。每个男生负责打扫一些连续的行，每个女生负责打扫一些连续的列。比如有两个男生，第一个男生负责第 $1, 2$ 两行、第二个男生负责第 $4$ 行，如图 (2) 的蓝色。打扫的区域可能重复，比如，又有两个女生，第一个女生负责打扫第 $3, 4$ 两列，第二个女生负责打扫第 $4, 5$ 两列，如图 (3) 的红色。从图 (3) 可以容易看出，有颜色覆盖的方格数为 $18$，即这 $4$ 名学生总共打扫了 $18$ 个方格。

![](https://cdn.luogu.com.cn/upload/pic/1474.png) 

老师要 WSR 在学校给出打扫安排的数据后快速计算出这些学生总共打扫了多少方格。

## 说明/提示

不会可以自己画图。

### 数据范围与约定

对于 $80\%$ 的数据，$1 \le N,M,B,G \le 10^2$。

对于 $100\%$ 的数据，$ 1 \le N,M,B,G \le 5 \times 10^3$。

## 样例 #1

### 输入

```
4 5 2 2
1 2
4 4
3 4
4 5```

### 输出

```
18```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解采用标记法记录被打扫的行和列，进而计算打扫区域。部分运用容斥原理，通过计算行和列被扫过的数量，结合公式得出结果。还有平移、差分、BFS等不同思路。
    - 算法要点：标记数组的合理使用，如用布尔数组或整型数组标记行和列的打扫情况；容斥原理的应用，即行被扫到的数量×列数 + 列被扫到的数量×行数 - 重合部分；差分优化，通过差分数组记录变化，降低时间复杂度。
    - 解决难点：主要难点在于处理重叠区域，避免重复计算。不同算法通过不同方式解决，如容斥原理直接计算重叠部分，标记法在标记过程中处理重叠。
    - 整体来看，各题解质量参差不齐，部分题解思路清晰、代码注释详细，部分题解代码可读性差、思路阐述不完整。

所选的题解：
  - **作者：翼德天尊 (赞：84) - 5星**
    - **关键亮点**：思路清晰，详细阐述审题、优化方法及代码实现。通过设立数组记录每行占用情况，优化计算过程，代码注释完整。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,b,g,ma[5001][5001],x,y,ans;
bool h[5001]; 
int main(){
    scanf("%d %d %d %d",&n,&m,&b,&g);
    for (int i=1;i<=b;i++){
        scanf("%d %d",&x,&y);
        for (int j=x;j<=y;j++) h[j]=1;
    }
    for (int i=1;i<=g;i++){
        scanf("%d %d",&x,&y);
        for (int j=1;j<=n;j++)
            if (!h[j])
                for (int w=x;w<=y;w++)
                    ma[j][w]=1;
    }
    for (int i=1;i<=n;i++)
        if (!h[i])
            for (int j=1;j<=m;j++)
                if (!ma[i][j])
                    ans++;
    printf("%d\n",n*m-ans);
    return 0;
} 
```
    - **核心思想**：先标记男生打扫的行，再标记女生打扫的列且仅标记未被男生打扫的行中的列，最后通过总格数减去未被标记的格子数得到打扫区域。
  - **作者：C929_半枫 (赞：35) - 4星**
    - **关键亮点**：思路简洁，利用两个数组分别标记行和列的打扫情况，计算过程清晰，代码简洁明了。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int i,j,n,m,g,b,x,y,num=0,sum=0;
bool a[5001],o[5001];
int main()
{
    cin>>n>>m>>b>>g;
    for(i=1;i<=b;++i)
    {
        cin>>x>>y;
        for(j=x;j<=y;j++)
        {
            if(a[j]!=1)
            {
                a[j]=1;
                num+=m;
                sum++;
            }
        }
    }
    for(i=1;i<=g;++i)
    {
        cin>>x>>y;
        for(j=x;j<=y;++j)
        {
            if(o[j]!=1)
            {
                o[j]=1;
                num+=n-sum;
            }
        }
    }
    cout<<num;
}
```
    - **核心思想**：先计算男生打扫的行数及对应格子数，再计算女生打扫列时，仅累加男生未打扫过的格子数，从而得到总的打扫区域。
  - **作者：s_a_b_e_r (赞：16) - 4星**
    - **关键亮点**：直接运用容斥原理，代码简洁高效，通过标记行和列被扫过的情况，利用公式快速得出结果。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
int N,M,B,G,ans1,ans2;
int x,y;
bool X[5003],Y[5003];
int main(){
    cin>>N>>M>>B>>G;
    for(int i=1;i<=B;i++){
        cin>>x>>y;
        for(int i=x;i<=y;i++)Y[i]=1;
    }
    for(int i=1;i<=G;i++){
        cin>>x>>y;
        for(int i=x;i<=y;i++)X[i]=1;
    }
    for(int i=1;i<=N;i++)
        if(Y[i])ans1++;
    for(int i=1;i<=M;i++)
        if(X[i])ans2++;
    cout<<ans1*M+ans2*N-ans1*ans2;
}
```
    - **核心思想**：分别标记男生和女生打扫的行和列，统计被扫过的行和列的数量，利用容斥原理公式（行被扫到×列数 + 列被扫到×行数 - 重合部分）计算打扫区域。

最优关键思路或技巧：
    - **容斥原理**：通过标记行和列被扫过的情况，直接利用容斥原理公式计算打扫区域，避免复杂的重叠处理，代码简洁高效。
    - **差分优化**：利用差分数组记录行和列的变化，将标记操作的时间复杂度从$O(j - i + 1)$降低到$O(1)$，提高算法效率。

可拓展之处：
    - 同类型题：涉及二维区域覆盖、重叠计算的问题，如计算多个矩形重叠后的总面积等。
    - 类似算法套路：对于区间操作问题，可考虑差分优化；对于重叠区域计算，容斥原理是常用方法。

推荐洛谷题目：
    - P1312 单词覆盖还原
    - P1896 [SCOI2005]互不侵犯
    - P2392 kkksc03考前临时抱佛脚 

---
处理用时：52.35秒
# 题目信息

# 接金币

## 题目描述

在二维坐标系里，有 $n$ 个金币，编号 $0\sim n-1$。初始时，第 $i$ 个金币位于 $(x_i,y_i)$。所有的金币每秒向下垂直下降 $1$ 个单位高度。例如有个金币当前坐标是 $(x,y)$，那么 $t$ 秒后金币所在的位置就是$(x,y-t)$。初始时，FJ 在 $(0,0)$ 处，FJ 每秒只能向左右移动 $1$ 个单位距离，当然 FJ 也可以不移动。如果在某个时刻某个金币和 FJ 所在的位置重合，那么 FJ 就能接住这个金币。求 FJ 能否把所有的金币都接住，如果行输出 $\texttt{Abletocatch}$，否则输出 $\texttt{Notabletocatch}$。


## 说明/提示

对于所有数据，$1\le g\le5$，$1\le n\le50$，$-10^3\le x_i\le10^3$，$0\le y_i\le10^3$。


## 样例 #1

### 输入

```
5
3
-1 1
1 3
0 4
1
-3 2
3
-1 1
1 2
0 4
3
0 9
-1 1
1 3
8
70 141
-108 299
52 402
-70 280
84 28
-29 363
66 427
-33 232
```

### 输出

```
Abletocatch
Notabletocatch
Notabletocatch
Abletocatch
Notabletocatch
```

# AI分析结果

### 综合分析与结论
这些题解主要有两种思路：模拟和基于排序的判断。
 - **模拟思路**：将金币按y坐标排序，通过模拟每一秒的情况，判断能否接住所有金币。如Ciyang的题解，定义金币结构体，包含下落和监测是否到底部的函数，按y排序后，在循环中模拟每秒FJ和金币的移动，判断能否接住金币。
 - **基于排序判断思路**：同样先按y坐标排序，然后通过比较相邻金币的x坐标差与y坐标差来判断能否接住所有金币。如noble_ 的题解，以y为标准从大到小排序，只要前后两个x之差的绝对值大于y之差的绝对值，就输出“Notabletocatch”，否则输出“Abletocatch”。

各题解在思路清晰度、代码可读性、优化程度上存在差异。多数题解通过排序简化判断过程，部分模拟题解虽思路直观，但实现相对复杂。

### 所选的题解
 - **作者：Ciyang (赞：39)  4星**
    - **关键亮点**：思路清晰，采用模拟方法，详细定义金币结构体及相关函数，对模拟过程的每一步骤有清晰描述，代码注释详细。
    - **个人心得**：无
    - **核心代码**：
```cpp
struct coin{
    //金币的结构体
    int nx;
    int ny;
    void down(){
        //金币下落实现,如果y不为0则下落
        if(ny!=0)ny-=1;
    }
    bool havedown(){
        //监测金币是否坐标已经为0
        if(ny==0)return true;
        else return false;
    }
};
bool coinscmp(coin a,coin b){
    //金币的y坐标比较,重载排序函数
    return a.ny<b.ny;
}
int main(){
    int t;cin>>t;
    for(int groupn=0;groupn<t;groupn++){
        int n;cin>>n;
        coin coins[n];
        for(int i=0;i<n;i++){
            cin>>coins[i].nx>>coins[i].ny;
        }
        sort(coins,coins+n,coinscmp);
        int mx=0,my=0,i=0;
        bool successful=false;
        while(1){
            if(i==n){
                successful=true;
                break;
            }
            bool thissuccessful=true;
            for(int j=i;j<n;j++){
                if(coins[j].havedown()==true){
                    if(mx==coins[j].nx){
                        i+=1;
                    }
                    else{
                        thissuccessful=false;
                        break;
                    } 
                }
            }
            if(thissuccessful==false)break;
            if(mx<coins[i].nx)mx+=1;
            if(mx>coins[i].nx)mx-=1;
            for(int j=i;j<n;j++)coins[j].down();
        }
        if(successful==true)printf("Abletocatch\n");
        else printf("Notabletocatch\n");
    }
    return 0;
}
```
    - **核心实现思想**：定义金币结构体，包含坐标及下落、检测到底部的函数。输入金币数据后按y坐标排序，通过循环模拟每秒情况，先检测金币是否到底且FJ能否接住，再移动FJ和金币，根据最终结果输出能否接住所有金币。
 - **作者：noble_ (赞：24)  4星**
    - **关键亮点**：算法简洁高效，通过排序后比较相邻金币的横纵坐标差直接得出结论，代码简洁明了。
    - **个人心得**：无
    - **核心代码**：
```cpp
struct coins
{
    int x,y;
}a[100000];
bool cmp(coins a,coins b)
{
    if(a.y<=b.y) return true;
    return false;
}
int main()
{
    int g,n;
    scanf("%d",&g);
    while(g--)
    {
        bool flag=false;
        scanf("%d",&n);
        a[0].x=a[0].y=0;n++;
        for(int i=1;i<n;i++)
        {
            scanf("%d%d",&a[i].x,&a[i].y);
        }
        sort(a,a+n,cmp);
        for(int i=0;i<n-1;i++)
        {
            if(abs(a[i].x-a[i+1].x)>abs(a[i+1].y-a[i].y))
            {
                printf("Notabletocatch\n");
                flag=true;
                break;
            }
        }
        if(!flag) printf("Abletocatch\n");
    }
    return 0;
}
```
    - **核心实现思想**：定义结构体存储金币坐标，按y坐标从小到大排序，假设FJ从原点出发，遍历排序后的金币，若相邻金币x坐标差的绝对值大于y坐标差的绝对值，则输出“Notabletocatch”，否则输出“Abletocatch”。
 - **作者：Take_A_Single_6 (赞：2)  4星**
    - **关键亮点**：思路清晰，采用贪心策略，明确阐述贪心思想及策略，代码注释详细。
    - **个人心得**：无
    - **核心代码**：
```cpp
struct coin
{
int x,y;
}c[55];
bool cmp(coin a,coin b)
{
return a.y<b.y;
}
int main()
{
int T,n,xx,t;
bool f;
for(cin>>T;T;T--){
    f=true,xx=0,t=0;
    cin>>n;
    for(int i=0;i<n;i++)
    cin>>c[i].x>>c[i].y;
    sort(c,c+n,cmp);
    for(int i=0;i<n;i++)
    {
        if(c[i].y-t<abs(c[i].x-xx))
        {
            cout<<"Notabletocatch\n",f=false;
            break;
        }
        xx=c[i].x,t=c[i].y;
    }
    if(f)cout<<"Abletocatch\n";
}
return 0;
}
```
    - **核心实现思想**：定义结构体存储金币坐标，按y坐标从小到大排序，初始化相关变量，遍历排序后的金币，比较金币与FJ当前位置的横纵坐标差，若横坐标差大于纵坐标差则无法接住，标记并跳出循环，最后根据标记输出结果。

### 最优关键思路或技巧
 - **排序优化判断**：通过对金币按y坐标排序，简化了判断FJ能否接住所有金币的过程。无论是模拟还是直接判断，排序后可利用金币下落顺序的特性，专注于相邻金币或当前金币与FJ位置关系的判断。
 - **贪心策略**：优先接住离地面近的金币（y值小），这样能保证在时间上有更多机会去接其他金币，符合贪心思想。

### 可拓展思路
此类题目属于运动规划与可行性判断类型，可拓展到更多复杂运动轨迹、不同速度及多目标的情况。类似算法套路是先分析目标运动规律，通过排序等方式简化问题，再利用贪心、模拟等策略解决。

### 推荐题目
 - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：涉及贪心算法，通过合并果子的操作，考察对贪心策略的运用。
 - [P1199 [NOIP2010 普及组] 三国游戏](https://www.luogu.com.cn/problem/P1199)：需要分析游戏策略，判断可行性，与本题判断能否接住金币的思路类似。
 - [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：同样运用贪心思想，通过对接水时间的排序，优化排队方案。

### 个人心得摘录与总结
无明显个人心得相关内容。 

---
处理用时：74.31秒
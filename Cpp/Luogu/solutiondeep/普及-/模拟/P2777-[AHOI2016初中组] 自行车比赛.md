# 题目信息

# [AHOI2016初中组] 自行车比赛

## 题目描述

小雪非常关注自行车比赛，尤其是环滨湖自行车赛。一年一度的环滨湖自行车赛，需要选手们连续比赛数日，最终按照累计得分决出冠军。今年一共有 $N$ 位参赛选手。每一天的比赛总会决出当日的排名，第一名的选手会获得 $N$ 点得分，第二名会获得 $N-1$ 点得分，第三名会获得 $N-2$ 点得分，依次类推，最后一名会获得 $1$ 点得分。保证没有选手会排名相同。


在之前的数日较量中，$N$ 位选手已经分别累计了一些分数。现在即将开始的是最后一天的比赛。小雪希望知道有多少位选手还有可能获得最终的冠军，也就是说还有多少选手有可能通过最后一天的比赛获得累计总分第一名。


## 说明/提示

### 数据范围及约定

- 对于 $20\% $ 的数据，$3\le N\le 600$。
- 对于 $50\%$  的数据，$3\le N\le 1\times 10^4$。
- 对于 $100\%$ 的数据，$3\le N\le 3\times 10^5$ 且 $0\le B_i\le 2\times 10^6$。


## 样例 #1

### 输入

```
3
8
10
9```

### 输出

```
3```

## 样例 #2

### 输入

```
5
15
14
15
12
14```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解均围绕贪心策略展开，核心思路是让目标选手在最后一轮得最高分 \( n \)，其他选手按分数从高到低分配 \( 1 \) 到 \( n - 1 \) 的分数，通过比较目标选手加分后的总分与其他选手在这种分配下的最高总分，来判断目标选手是否有可能夺冠。算法要点在于对选手初始分数进行排序，以实现高效的贪心分配和比较。解决难点在于如何合理地分配其他选手的分数，使目标选手夺冠可能性的判断更准确，同时优化时间复杂度。

从质量上看，部分题解思路清晰、代码简洁且有一定优化，部分题解在思路阐述或代码实现上稍显不足。

### 所选的题解
1. **作者：小粉兔 (赞：60)**
    - **星级**：5星
    - **关键亮点**：思路阐述极为清晰，详细说明了贪心策略的具体应用过程，从单个选手的情况拓展到所有选手，对代码实现中的排序处理、数组计算及比较逻辑都有清晰解释，时间复杂度优化到 \( \mathcal O (n \log n) \)。
    - **重点代码及核心思想**：
```cpp
void init(){//读入
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&b[i]);
}
int main(){
    init();//读入
    sort(b+1,b+n+1);//b数组排序
    for(int i=1;i<=n;i++)
        c[i]=b[i]+n-i+1;//加分计算（最大值最小化，贪心）
    for(int i=1;i<=n;i++)
        if(mx<c[i])mx=c[i];//mx为c数组中的最大值
    for(int i=n;i>=1;i--)
        if(b[i]+n>=mx)//与c数组中的最大值mx比较
            ans++;
        else//发现如果得分较高的没希望得第一，得分比他低的更没希望，因为b数组也排过序，所以发现一个人没希望得第一了，就可以退出
            break;
    printf("%d",ans);
    return 0;
}
```
核心思想是先读入数据并排序，通过贪心计算出其他选手在最优分配下的最大得分并存入 \( c \) 数组，找到 \( c \) 数组最大值 \( mx \)，再从后往前遍历选手，判断每个选手加上 \( n \) 分后是否不小于 \( mx \)，以此统计可能夺冠的人数。

2. **作者：_ZZH (赞：18)**
    - **星级**：4星
    - **关键亮点**：简洁明了地阐述了贪心策略，代码实现简洁高效，通过排序和一次遍历计算出其他选手的最大可能总分作为衡量标准，再通过一次遍历判断每个选手是否有可能夺冠，时间复杂度为 \( \mathcal O (n \log n) \)。
    - **重点代码及核心思想**：
```cpp
int cmp(const int &x,const int &y)
{
	return x>y;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&b[i]);
	sort(b+1,b+1+n,cmp);
	for(int i=1;i<=n;i++)
	maxx=max(maxx,b[i]+i);
	for(int i=1;i<=n;i++)
	if(b[i]+n>=maxx)
	ans++;
	else
	break;
	printf("%d",ans);
}
```
核心思想是先从大到小排序，遍历计算出其他选手在贪心分配下的最大总分 \( maxx \)，再遍历判断每个选手加上 \( n \) 分后与 \( maxx \) 的关系，统计可能夺冠人数。

3. **作者：PolyLoger (赞：2)**
    - **星级**：4星
    - **关键亮点**：利用后缀最大值优化判断过程，在 \( O(1) \) 时间内让选手加上 \( n \) 分后与之前选手最后一轮后可能最小值的最大值比较，减少了重复计算，提高效率，同时利用了排名靠后的选手若无法夺冠则其之后选手也无法夺冠的性质提前结束循环。
    - **重点代码及核心思想**：
```cpp
int main(void)
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)scanf("%d",&beat[i]);
    sort(beat+1,beat+1+n);
    for(int i=n;i>=1;--i){
        if(beat[i]+n>=biggest[i+1])++ans;
        else break;
        biggest[i]=max(biggest[i+1],beat[i]+n-i+1);
    }
    printf("%d\n",ans);
    return 0;
}
```
核心思想是先排序，从后往前遍历选手，通过后缀最大值 \( biggest \) 数组优化判断每个选手加上 \( n \) 分后是否有可能夺冠，统计人数。

### 最优的关键思路或技巧
1. **贪心策略**：让目标选手最后一轮得 \( n \) 分，其他选手按分数从高到低分配剩余分数，使目标选手夺冠可能性判断更合理。
2. **排序优化**：对选手初始分数排序，方便进行贪心分配和后续比较，降低时间复杂度。
3. **最值优化**：如利用后缀最大值等方式，减少重复计算，提高判断效率。

### 可拓展之处
此类题目属于贪心策略在竞赛排名场景下的应用，类似套路可应用于其他涉及资源分配、竞争排名且可通过贪心策略优化的场景，如同类型的比赛得分预测、任务分配求最优结果等题目。

### 推荐题目
1. **P1080 [NOIP2012 提高组] 国王游戏**：通过贪心策略解决分配问题，与本题在贪心思路运用上有相似之处。
2. **P1199 [NOIP2010 普及组] 三国游戏**：同样涉及竞赛排名与策略选择，需运用贪心思想判断结果。
3. **P2123 皇后游戏**：通过合理排序和贪心策略解决双属性任务排序问题，对贪心和排序结合运用有较高要求。

### 个人心得摘录与总结
1. **作者：STILL_ALONE**：最初想深搜但未成功，看到标签提示“贪心”“模拟”后，通过排序解决问题。总结为做题时应注意标签提示，及时调整思路。
2. **作者：PolyLoger**：怀念比赛时茅塞顿开想到用后缀最大值优化的自己。心得为竞赛中思路的突然开拓很关键，平时应多积累优化技巧。 

---
处理用时：56.84秒
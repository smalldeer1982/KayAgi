# 题目信息

# 母舰

## 题目背景

广东汕头聿怀初中 Train#3 Problem 1

（有没有红警既视感~）


## 题目描述

在小 A 的星际大战游戏中，一艘强力的母舰往往决定了一场战争的胜负。一艘母舰的攻击力是普通的 MA（Mobile Armor）无法比较的。

对于一艘母舰而言，它是由若干个攻击系统和若干个防御系统组成的。两艘母舰对决时，一艘母舰会选择用不同的攻击系统去攻击对面母舰的防御系统。当这个攻击系统的攻击力大于防御系统的防御力时，那个防御系统会被破坏掉。当一艘母舰的防御系统全部被破坏掉之后，所有的攻击都会攻击到敌方母舰本身上去造成伤害。

这样说，一艘母舰对对面的伤害在一定程度上是取决于选择的攻击对象的。

在瞬息万变的战场中，选择一个最优的攻击对象是非常重要的。所以需要写出一个战斗系统出来，判断出你的母舰最多能对对手造成多少伤害并加以实现。


## 说明/提示

#### 样例解释 #1

对方防御系统有 $3$ 个，防御值为 $1000(a),2000(b),1200(c)$，己方攻击系统有 $5$ 个，攻击值为 $2100(d)，2000(e),1200(f),1000(g),1000(h)$。第 $1$ 轮攻击的最优方案是 $d$ 攻击 $b$，$e$ 攻击 $c$，$f$ 攻击 $a$，$g$ 和 $h$ 攻击对方母舰本身，造成 $2000$ 点伤害。

#### 数据范围与约定

对于 $80 \%$ 的数据，$1 \le N,M \le 1000$。

对于 $100 \%$ 的数据，$1 \le N,M \le 10 ^ 5$。


本题为转载题目。

## 样例 #1

### 输入

```
3 5 
1000 
2000 
1200 
2100 
2000 
1200 
1000 
1000```

### 输出

```
2000```

# AI分析结果

• 综合分析与结论：这些题解思路大致相同，均采用贪心策略，即优先使用攻击力最小且能摧毁防御系统的攻击系统去攻击，以保证对敌方母舰造成最大伤害。算法要点在于对攻击系统和防御系统的攻击力、防御力分别排序，然后通过遍历或指针移动来匹配攻击与防御。解决难点主要在于如何高效地进行匹配以及处理边界情况，如防御系统为0、攻击系统数量少于防御系统数量等。多数题解代码实现思路较为清晰，但在代码可读性、优化程度上存在差异。
• 所选的题解：
  - 作者：sjl40 (5星)
    - 关键亮点：思路清晰，对关键点阐述详细，代码简洁明了，直接体现贪心策略，对边界情况如防御系统为0处理得当。
    - 重点代码及核心思想：
```cpp
sort(tf+1,tf+1+m);
sort(wf+1,wf+1+n);
t=1;
for(i=1;i<=n;i++)
{
    if(tf[t]==0)t++;
    if(tf[t]<wf[i]&&tf[t]!=0){wf[i]=0;t++;}
}
if(t<=m){cout<<0;return 0;}
for(i=1;i<=n;i++)s+=wf[i];
cout<<s;
```
核心思想是先排序，然后用当前最小攻击力的攻击系统尝试攻击当前最小防御力的防御系统，能攻击则标记攻击系统已用并切换到下一个防御系统，最后判断防御系统是否全被攻破，若全破则累加剩余攻击系统攻击力作为对母舰的伤害。
  - 作者：EarthGiao (4星)
    - 关键亮点：思路讲解细致，代码注释详细，对循环条件、计数器作用等解释清晰，便于理解。
    - 重点代码及核心思想：
```cpp
sort(hudun+1,hudun+n+1);
sort(gongji+1,gongji+m+1);
int ans=0,js=1,jss=1;
while(jss!=n + 1) {
    if(js == m + 1 && jss!= n + 1) {
        printf("0\n");
        return 0;
    }
    if(hudun[jss]==0) {
        jss++;
        continue;
    } else if(hudun[jss]<gongji[js]) {
        gongji[js]=0;
        jss++;
        js++;
        continue;
    } else {
        js++;
        continue;
    }
}
for(int i=1; i<=m; ++i) {
    ans+=gongji[i];
}
printf("%d\n",ans);
```
核心思想是排序后，通过双计数器分别遍历攻击和防御系统，根据攻击力与防御力的比较结果更新计数器和攻击系统状态，最后累加剩余攻击系统攻击力得到对母舰的伤害。
  - 作者：Saliеri (4星)
    - 关键亮点：指出了题目所需的时间复杂度，代码简洁高效，通过一个指针维护最小满足条件的攻击系统。
    - 重点代码及核心思想：
```cpp
sort(attack+1,attack+n+1),sort(defense+1,defense+m+1);
int pa = 1;
for(int i=1;i<=m;++i){
    while(attack[pa] <= defense[i] and pa <= n)ans += attack[pa++];
    ++pa;
    if(i!= m && pa == n+1){printf("0");return 0;}
}
while(pa <= n)ans += attack[pa++];
printf("%d",ans);
```
核心思想是排序后，利用指针pa遍历攻击系统，对于每个防御系统，找到第一个能攻破它的攻击系统，累加之前无法攻破该防御系统的攻击系统攻击力，若攻击系统用完还未攻破所有防御系统则输出0，否则累加剩余攻击系统攻击力。
• 最优的关键思路或技巧：采用贪心算法，通过排序使得匹配过程更高效，利用双指针或循环遍历的方式在排序后的数组中进行攻击与防御的匹配，同时注意处理边界情况和特殊值（如防御系统为0）。
• 可拓展之处：同类型题可涉及资源分配、任务调度等场景，类似算法套路是在满足一定条件下，通过贪心策略选择局部最优解以达到全局最优。例如在资源分配中，根据资源的大小和需求的大小进行排序后匹配。
• 推荐题目：
  - [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：同样是通过排序和贪心策略解决分组问题。
  - [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)：利用贪心思想，按一定规则删除数字以得到最小数。
  - [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：根据接水时间排序，用贪心策略安排接水顺序使总等待时间最短。
• 个人心得摘录及总结：
  - 作者Saliеri提到“不要忘了加上前面无法满足任何需求的攻击系统的伤害作为答案”，总结为在实现贪心算法时，要全面考虑各种情况，不能遗漏某些攻击系统对最终伤害的贡献。 

---
处理用时：47.02秒
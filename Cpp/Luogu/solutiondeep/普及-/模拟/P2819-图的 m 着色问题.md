# 题目信息

# 图的 m 着色问题

## 题目背景

给定无向连通图 $G$ 和 $m$ 种不同的颜色。用这些颜色为图 $G$ 的各顶点着色，每个顶点着一种颜色。如果有一种着色法使 $G$ 中每条边的 $2$ 个顶点着不同颜色，则称这个图是 $m$ 可着色的。图的 $m$ 着色问题是对于给定图 $G$ 和 $m$ 种颜色，找出所有不同的着色法。


## 题目描述

对于给定的无向连通图 $G$ 和 $m$ 种不同的颜色，编程计算图的所有不同的着色法。


## 说明/提示

数据保证，$1\leq n\leq 100$，$1 \leq k\leq 2500$。

在 $n$ 很大时保证 $k$ 足够大。

保证答案不超过 $20000$。

数据为在满足上述条件的合法数据中随机采样得到。

## 样例 #1

### 输入

```
5 8 4
1 2
1 3
1 4
2 3
2 4
2 5
3 4
4 5```

### 输出

```
48```

# AI分析结果

### 综合分析与结论
这些题解均围绕图的m着色问题，采用深度优先搜索（DFS）算法。基本思路是从第一个顶点开始，依次为每个顶点尝试不同颜色，在尝试过程中通过检查函数判断当前顶点所涂颜色是否与相邻顶点冲突，若不冲突则继续为下一个顶点涂色，若所有顶点都成功涂色则找到一种合法着色方案，方案数加1 ，然后回溯继续寻找其他方案。
各题解的主要区别在于代码实现细节、数据结构的选择（如邻接矩阵、邻接表）以及是否有优化。整体上多数题解思路清晰，但在代码可读性和优化程度上存在差异。

### 所选的题解
- **作者：zzlh（5星）**
    - **关键亮点**：思路清晰简洁，代码结构简单明了，直接采用邻接矩阵存储图结构，通过DFS递归实现着色过程，核心代码逻辑清晰，易于理解。
    - **重点代码**：
```cpp
bool check(int sum){
    for(int i=1;i<=sum;i++){
        if(f[i][sum]==true&&color[i]==color[sum]){
            return false;
        }
    }
    return true;
}
void dfs(int s){
    if(s>n){
        num++;
        return;
    }
    for(int i=1;i<=m;i++){
        color[s]=i;
        if(check(s)==true){
            dfs(s+1);
        }else{
            color[s]=0;
        }
    }
}
```
核心思想：`check`函数用于判断当前顶点`sum`所涂颜色是否与之前已涂色顶点冲突。`dfs`函数递归为每个顶点尝试颜色，若顶点` s`超过总顶点数`n`，则找到一种合法方案，方案数`num`加1；否则遍历`m`种颜色，若当前颜色不冲突则继续为下一个顶点调用`dfs`，冲突则将当前顶点颜色重置为0。
- **作者：Creeper_LKF（4星）**
    - **关键亮点**：提出了一种优化思想，在染色过程中，若当前颜色是首次出现且场上还有其他未出现过的颜色，当局部合法时，可认为染该颜色与其他未出现颜色在全局合法方案下等价，从而直接乘以未出现颜色的数量来加速计算，在相同数据规模下可优化约3倍时间。
    - **重点代码**：
```cpp
int dfs(int pt){
    if(pt == 0) return 1;
    else {
        int ret = 0, tmp = 0;
        for(int i = 1; i <= k; i++){
            if(tim[i] == 0){ 
                if(tmp) continue;
                col[pt] = i, tim[i] ++, tmp = ali, ali --;
                ret += dfs(pt - 1) * tmp;
                tim[i] --, ali ++;
            } else { 
                if(tim[i] == 0) continue;
                bool flg = true;
                for(int j = siz[pt]; flg && j; j--){
                    if(i == col[tabl[pt][j]])
                        flg = false;
                }
                if(flg) col[pt] = i, tim[i] ++, ret += dfs(pt - 1), tim[i] --;
            }
        }
        col[pt] = 0;
        return ret;
    }
}
```
核心思想：`dfs`函数中，当处理顶点`pt`时，若颜色`i`首次出现，记录未出现颜色数量`ali`变化并乘以该数量累加到结果`ret`；若颜色`i`非首次出现，则检查与相邻顶点颜色是否冲突，不冲突则继续递归并累加结果。最后将当前顶点颜色重置为0并返回结果。
- **作者：__nullptr__attr（4星）**
    - **关键亮点**：不仅给出邻接矩阵的解法思路，还详细介绍了链式前向星存图的方法及其优势，对于理解不同数据结构在图问题中的应用有很大帮助，代码实现完整清晰。
    - **重点代码**：
```cpp
inline void add(int x,int y){
    ver[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
inline bool valid(int c,int p){
    for(int i=head[p];i;i=nxt[i]){
        int y=ver[i];
        if(color[y]==c) return 0;
    }
    return 1;
}
void dfs(int dep){
    if(dep==n+1) return ans++,void();
    for(int i=1;i<=m;++i){
        if(valid(i,dep)){
            color[dep]=i;
            dfs(dep+1);
            color[dep]=0;
        }
    }
}
```
核心思想：`add`函数用于链式前向星存边。`valid`函数检查顶点`p`染颜色`c`是否与相邻顶点冲突。`dfs`函数递归为顶点`dep`尝试颜色，若顶点`dep`超过总顶点数`n`，则方案数`ans`加1；否则遍历`m`种颜色，若当前颜色不冲突则继续为下一个顶点调用`dfs`，冲突则将当前顶点颜色重置为0。

### 最优关键思路或技巧
 - **优化搜索过程**：如Creeper_LKF题解中利用颜色出现情况进行剪枝优化，当某种颜色首次出现且存在其他未出现颜色时，利用等价性直接增加方案数，减少不必要的搜索分支，提高算法效率。
 - **选择合适数据结构**：__nullptr__attr题解提到链式前向星在处理图结构时，相比邻接矩阵在遍历边时更高效，直接找边的终点，减少不必要的遍历，适用于稀疏图。

### 可拓展之处
此类问题属于图的着色问题范畴，相似类型题有地图着色、任务分配（不同任务有冲突限制）等。通用算法套路是以DFS为基础，结合剪枝优化策略，根据具体问题特点选择合适数据结构存储图。例如对于大规模稀疏图优先考虑邻接表或链式前向星结构。

### 相似知识点洛谷题目
 - **P1121 环状最大两段子段和**：涉及图的遍历和动态规划，与本题类似在于需要处理元素间的关系并寻找最优解。
 - **P1330 封锁阳光大学**：同样是图相关问题，通过DFS判断二分图，与本题都运用DFS对图的节点进行处理。
 - **P1339 热浪**：单源最短路径问题，虽然重点在路径长度计算，但也涉及图的存储和遍历，与本题在图的操作上有相通之处。

### 个人心得摘录与总结
无明显个人心得相关内容。 

---
处理用时：69.61秒
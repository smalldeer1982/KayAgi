# 题目信息

# [USACO1.3] 滑雪课程设计Ski Course Design

## 题目描述

农民约翰的农场里有 $n$ 座山峰，每座山都有一个在 $0$ 到 $100$ 之间的整数的海拔高度。在冬天,因为山上有丰富的积雪，约翰经常开办滑雪训练营。

不幸的是，约翰刚刚得知税法在滑雪训练营方面有新变化，明年开始实施。在仔细阅读法律后，他发现如果滑雪训练营的最高和最低的山峰海拔高度差大于 $17$ 就要收税。因此，如果他改变山峰的高度（使最高与最低的山峰海拔高度差不超过 $17$ ），约翰可以避免支付税收。

如果改变一座山 $x$ 单位的高度成本是 $x^2$ 单位，约翰最少需要付多少钱才能使海拔最高的山峰与海拔最低的山峰的高度之差不超过 $17$ 约翰只愿意改变整数单位的高度。

## 说明/提示

#### 样例输入输出 1 解释

约翰保持高度为 $4$、$20$ 和 $21$ 的山的高度。他增高高度为 $1$ 的山，变成高度 $4$ ，花费 $3^2 = 9$。他降低了高度为 $24$ 的山变成高度 $21$，也花费 $3 ^ 2 = 9$。因此总共花费 $9 + 9 = 18$。

---

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \le n \le 1000$，$0 \leq a_i \leq 100$。

## 样例 #1

### 输入

```
5
20
4
1
24
21```

### 输出

```
18```

# AI分析结果

• 综合分析与结论：
    - 多数题解采用暴力枚举思路，通过枚举所有可能的高度区间，计算在此区间下调整山峰高度的总花费，取最小值为结果。此方法基于数据规模较小，$1 \leq n \leq 1000$，暴力枚举不会超时。
    - 少数题解如“xiaoniu142857”使用三分法，利用单谷函数性质优化求解，时间复杂度为$O(n\log n)$，比暴力枚举更优。
    - 从思路清晰度、代码可读性、优化程度等方面综合看，“xiaoniu142857”的题解质量较高，采用三分法优化算法；“xfydemx”和“「QQ红包」”的题解思路清晰，代码简洁，可读性较好。

所选的题解：
  - 作者：xiaoniu142857（5星）
    - 关键亮点：使用三分法优化求解，将问题转化为单谷函数求最小值，时间复杂度从暴力枚举的$O(n^2)$优化到$O(n\log n)$，效率更高。
    - 重点代码及核心实现思想：
```cpp
int f(int x)  // 计算区间取[x,x+17]时总代价
{
    int s=0;
    for(int i=0;i<n;++i)
    {
        if(a[i]<x) s+=(x-a[i])*(x-a[i]);
        else if(a[i]>x+17) s+=(a[i]-x-17)*(a[i]-x-17);
    }
    return s;
}
int main()
{
    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
    int l=INF,r=-INF,m1,m2;
    cin>>n;
    for(int i=0;i<n;++i)
    {
        cin>>a[i];
        l=min(l,a[i]);
        r=max(r,a[i]);
    }
    r-=17;
    while(l<r)  // 三分
    {
        m1=(l+r>>1),m2=m1+1;
        if(f(m1)<f(m2)) r=m2-1;
        else l=m1+1;
    }
    cout<<f(l);
    return 0;
}
```
核心思想是先定义函数$f(x)$计算将所有山峰高度调整到区间$[x, x + 17]$的总代价。在`main`函数中，确定三分的左右边界`l`和`r`，然后通过三分法不断缩小范围，找到使总代价最小的`x`值。

  - 作者：xfydemx（4星）
    - 关键亮点：思路清晰，代码简洁。通过排序找到山峰高度的最大最小值，然后枚举所有可能的高度界限，计算调整高度的花费并取最小值。
    - 重点代码及核心实现思想：
```cpp
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    cin>>a[i];
    sort(a+1,a+n+1);
    for(int j=a[1];j<=a[n];j++)
    {
        sum=0;
        for(int i=1;i<=n;i++)
        {
            if(a[i]-j>17) sum+=(a[i]-j-17)*(a[i]-j-17);
            if(a[i]<j) sum+=(a[i]-j)*(a[i]-j);
        }    
        s=min(sum,s);
    }
    cout<<s;
}
```
核心思想是先读入山峰高度并排序，然后从最小高度到最大高度枚举界限`j`，对于每个界限，计算每座山峰调整到符合要求高度的花费`sum`，并更新最小花费`s`。

  - 作者：「QQ红包」（4星）
    - 关键亮点：思路直接，通过枚举所有可能的山峰高度范围，统计在此范围内调整山峰高度的花费，取最小值。代码逻辑清晰，注释详细。
    - 重点代码及核心实现思想：
```cpp
int main() 
{
    freopen("skidesign.in","r",stdin);
    freopen("skidesign.out","w",stdout); 
    scanf("%d",&n);
    m=200000000;
    for (i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for (i=0;i<=84;i++)
    {
        w=0;
        for (j=1;j<=n;j++)
        {
            if (a[j]<i)
                w+=(i-a[j])*(i-a[j]);
            if (a[j]>i+17)
                w+=(a[j]-(i+17))*(a[j]-(i+17)); 
        }
        if (w<m) m=w;
    } 
    cout<<m<<endl; 
    return 0;
}
```
核心思想是先读入山峰数量和高度，然后从0到84枚举可能的最小高度`i`，对于每个`i`，计算每座山峰调整到区间`[i, i + 17]`的花费`w`，并更新最小花费`m`。

最优关键思路或技巧：
    - 三分法优化：利用单谷函数性质，通过三分法找到使总代价最小的高度区间，相比暴力枚举，时间复杂度更低，效率更高。
    - 暴力枚举优化：在暴力枚举时，合理确定枚举范围，如从最小高度到最大高度枚举，避免无效枚举，减少计算量。

可拓展之处：
    - 同类型题：此类题目属于数值调整求最小代价问题，类似题目常涉及在一定限制条件下对一组数据进行调整，使某个目标函数最小化。
    - 类似算法套路：除三分法外，还可关注二分法在类似问题中的应用，以及贪心策略能否优化求解过程。

推荐洛谷题目：
    - P1182 数列分段 Section II
    - P2678 [NOIP2015 提高组] 跳石头
    - P3853 [TJOI2007] 路标设置

个人心得摘录及总结：
    - “卑微的绝望”：在枚举时应全面考虑问题，其第一次只枚举了山的高度而非山峰高度，导致错误。总结出做题要细致，全面考虑问题，避免遗漏关键因素。 

---
处理用时：99.30秒
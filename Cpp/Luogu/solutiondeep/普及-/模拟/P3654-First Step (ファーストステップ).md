# 题目信息

# First Step (ファーストステップ)

## 题目背景

> **知らないことばかりなにもかもが（どうしたらいいの？）**    
**一切的一切 尽是充满了未知数（该如何是好）**   
**それでも期待で足が軽いよ（ジャンプだ！）**     
**但我仍因满怀期待而步伐轻盈（起跳吧！）**       
**温度差なんていつか消しちゃえってね**     
**冷若冰霜的态度 有朝一日将会消失得无影无踪**      
**元気だよ元気をだしていくよ**     
**拿出活力 打起精神向前迈进吧**     

 ![](https://cdn.luogu.com.cn/upload/pic/4471.png) 

我们 Aqours，要第一次举办演唱会啦！

虽然学生会长看上去不怎么支持我们的样子，可是有了理事长的支持，我们还是被允许在校内的篮球场里歌唱！

歌曲也好好地准备过了，名字叫“[最喜欢的话就没问题！ (ダイスキだったらダイジョウブ！)](https://zh.moegirl.org/%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98)“，大家一定会喜欢的吧！

演唱会一定会顺利进行的！

希望不要发生**停电**什么的事故哦……！


## 题目描述

可是……这个篮球场，好像很久没有使用过的样子啊……

里面堆满了学校的各种杂物呢……

我们 Aqours 的成员要怎么在里面列队站下呢？


我们浦之星女子学院的篮球场是一个 $R$ 行 $C$ 列的矩阵，其中堆满了各种学校的杂物 (用 `#` 表示)，空地 (用 `.` 表示) 好像并不多的样子呢……

我们 Aqours 现在已经一共有 $K$ 个队员了，要歌唱舞蹈起来的话，我们得排成一条 $1\times K$ 的直线，一个接一个地站在篮球场的空地上呢 (横竖均可)。

我们想知道一共有多少种可行的站位方式呢。

Aqours 的真正的粉丝的你，能帮我们算算吗？


## 说明/提示

|  | $R$ | $C$ | $K$ | 备注 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|$1\sim2$|$\leq 10$|$\leq 10$|$\leq \min(R,C)$|无|
|$3\sim4$|$\leq 100$|$\leq 100$|$\leq 1$|无|
|$5\sim6$|$\leq 100$|$\leq 100$|$\leq \min(R,C)$|没有障碍|
|$7\sim10$|$\leq 100$|$\leq 100$|$\leq \min(R,C)$|无|

对于所有数据，$1 \leq R,C \leq 100$，$1 \leq k \leq \min(R,C)$。

#### 以下是彩蛋

在 LoveLive!Sunshine!! 动画第一季第三集中，Aqours 队长高海千歌演唱“最喜欢的话就没问题！”到副歌前时，学校因为雷击停电。


## 样例 #1

### 输入

```
5 5 2
.###.
##.#.
..#..
#..#.
#.###
```

### 输出

```
8```

# AI分析结果

• 综合分析与结论：这些题解主要思路为暴力枚举，遍历矩阵中的每个点，从该点出发向特定方向（横、竖或斜）搜索，判断是否存在长度为k的连续空地。各题解的主要区别在于搜索方式（如dfs、直接循环枚举）以及对特殊情况（k = 1）的处理。多数题解思路清晰，但在代码可读性和优化程度上有所差异。

所选的题解：
  - **作者：rashoumon (赞：95)  星级：4星**
    - **关键亮点**：使用dfs思路，通过位移向量简洁地实现向下和向右两个方向的搜索，并对r = 1的特殊情况进行了正确特判。
    - **个人心得**：无
    ```cpp
    int n,m,r,ans,dx[2]={0,1},dy[2]={1,0};//位移向量，分别是朝下和朝右
    char map[105][105];
    void skim(int x,int y,int i,int j)//dfs
    {
        if(j>r){//满足条件则ans++
            ++ans;
            return ;
        }
        if(map[x][y]!='.'||x<0||y<0||x>=n||y>=m)//处理越界和障碍
            return ;
        skim(x+dx[i],y+dy[i],i,j+1);
        return ;
    }
    int main()
    {
        cin>>n>>m>>r;
        for(int i=0;i<n;i++)
            cin>>map[i];
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
                if(map[i][j]=='.')
                    for(int k=0;k<2;k++)
                        skim(i,j,k,1);
        if(r==1)
            ans/=2;//r=1时特判
        cout<<ans<<endl;
        return 0;
    }
    ```
  - **作者：lin_toto (赞：81)  星级：4星**
    - **关键亮点**：提出按行和列分别扫描所有连续空位，通过简单数学计算得出摆放方式数量，思路简洁高效，同时指出了出题过程中的一些问题。
    - **个人心得**：提到出题时未卡掉O(n^3)算法，以及k = 1情况在数据和标程中被遗漏，导致比赛中出现评测故障。
  - **作者：loi_hjh (赞：2)  星级：4星**
    - **关键亮点**：介绍了n^2的优化做法，通过记录每行和每列连续空格数量，利用数学公式计算摆放方案数，代码简洁明了。
    - **个人心得**：提到被k = 1的特殊数据卡分，强调了对特殊情况的重视。
    ```cpp
    int n,m,p,q,ans;//场地大小，人数，连续有几个空位，答案 
    char a[1001][1001];
    int main(){
        scanf("%d%d%d",&n,&m,&p);
        for(ri i=1;i<=n;i++)
            for(ri j=1;j<=m;j++)
                cin>>a[i][j];
        for(ri i=1;i<=n;i++){//先数每一行连着的空格 
            q=0;
            for(ri j=1;j<=m;j++){
                if(a[i][j]=='.') q++;
                else{
                    if(q>=p) ans+=q-p+1;//那么就有q-p+1种方案 
                    q=0;
                }
            }
            if(q>=p) ans+=q-p+1;//行末再统计一次 
        }
        for(ri i=1;i<=n;i++){//再数每一列连着的空格（ctrl c+ctrl v再改一下） 
            q=0;
            for(ri j=1;j<=m;j++){
                if(a[j][i]=='.') q++;
                else{
                    if(q>=p) ans+=q-p+1;//那么就有q-p+1种方案 
                    q=0;
                }
            }
            if(q>=p) ans+=q-p+1;
        }
        if(p==1) ans/=2;//只有一个人的话横竖都一（shi）样（si），特判一下，居然出了两个人数是1的数据卡我20分。。。 
        printf("%d",ans);
        return ~~(0-0);
    }
    ```

最优关键思路或技巧：
 - **优化搜索方式**：如loi_hjh题解中通过记录每行每列连续空格数量，利用数学公式计算摆放方案数，避免了重复搜索，将时间复杂度从O(n^3)优化到O(n^2)。
 - **特殊情况处理**：所有题解都注意到了k = 1时横竖情况相同需特判的问题，避免重复计数。

可拓展之处：此类题目属于矩阵搜索与计数问题，类似套路包括预处理矩阵信息（如连续空位长度），利用方向向量简化搜索代码。同类型题可关注矩阵中特定形状的图案计数、路径搜索等。

推荐洛谷题目：
 - P1308 统计单词数：涉及字符串在文本中的搜索与计数，与本题搜索判断思路类似。
 - P1427 小鱼的数字游戏：同样是对序列中特定条件的元素进行计数，可类比本题对满足条件的站位计数。
 - P1990 覆盖墙壁：矩阵填充问题，与本题在矩阵处理和方案计数上有相似思考方式。 

---
处理用时：91.72秒
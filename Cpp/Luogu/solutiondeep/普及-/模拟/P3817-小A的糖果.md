# 题目信息

# 小A的糖果

## 题目描述

小 A 有 $n$ 个糖果盒，第 $i$ 个盒中有 $a_i$ 颗糖果。

小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 $x$，至少得吃掉几颗糖。


## 说明/提示

#### 样例输入输出 1 解释

吃掉第 2 盒中的一个糖果即可。

---

#### 样例输入输出 2 解释

第 2 盒糖吃掉 $6$ 颗，第 4 盒吃掉 $2$ 颗，第 6 盒吃掉 $3$ 颗。

---

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 20$，$a_i, x \leq 100$。
- 对于 $70\%$ 的数据，保证 $n \leq 10^3$，$a_i, x \leq 10^5$。
- 对于 $100\%$ 的数据，保证 $2 \leq n \leq 10^5$，$0 \leq a_i, x \leq 10^9$。

## 样例 #1

### 输入

```
3 3
2 2 2```

### 输出

```
1
```

## 样例 #2

### 输入

```
6 1
1 6 1 2 0 4```

### 输出

```
11```

## 样例 #3

### 输入

```
5 9
3 1 4 1 5```

### 输出

```
0
```

# AI分析结果

### 综合分析与结论
这些题解均采用贪心算法解决该问题。核心思路是当相邻两个盒子糖果数之和大于 \( x \) 时，优先减少右边盒子的糖果数，这样能使后续相邻盒子糖果数之和更易满足条件，从而保证吃掉的糖果总数最少。部分题解还单独处理了第一个盒子糖果数超过 \( x \) 的情况，避免后续出现负数等问题。在代码实现上，多数题解思路清晰，但在代码可读性、优化程度上存在差异。

### 所选的题解
- **作者：lzk5627 (赞：220)  星级：4星**
    - **关键亮点**：思路阐述清晰，先分析单个盒子超限及两个盒子总和超限的处理方式，再通过循环依次处理相邻盒子。代码简洁明了，逻辑清晰。
    - **个人心得**：无
    ```c
    #include<bits/stdc++.h>
    using namespace std;
    int main()
    {
        long long sum=0,n,x;
        cin>>n>>x;
        long long a[n+1];
        cin>>a[1];
        if(a[1]>x)
        {
            sum+=a[1]-x;
            a[1]=x;
        }
        for(int i=2;i<=n;i++)
        {
            cin>>a[i];
            if(a[i]+a[i-1]>x)
            {
                sum+=a[i]+a[i-1]-x;
                a[i]=x-a[i-1];
            }
        }
        cout<<sum;
        return 0;
    } 
    ```
    - **核心实现思想**：先单独处理第一个盒子糖果数可能超过 \( x \) 的情况，之后遍历其余盒子，当相邻两盒糖果数之和大于 \( x \) 时，计算并累加需吃掉的糖果数，同时调整当前盒子糖果数，使其与前一个盒子糖果数之和为 \( x \)。
- **作者：a___ (赞：104)  星级：4星**
    - **关键亮点**：指出处理第一个数的重要性，避免出现负糖果数问题，通过具体数据展示不同处理方式的差异，增强说服力。代码简洁，使用register变量提升效率。
    - **个人心得**：认为之前题解复杂或不对，强调第一个数需单独处理，否则会出现负糖果数。
    ```cpp
    #include <cstdio>
    long long n,a[100010],x,ans,yy;
    int main()
    {
        register int i;
        scanf("%lld%lld",&n,&x);
        for (i=1;i<=n;i++)
        {
            scanf("%lld",&a[i]);
            if (a[i]+a[i-1]>x)yy=a[i]+a[i-1]-x,a[i]-=yy,ans+=yy;
        }
        printf("%lld",ans);
        return 0;
    }
    ```
    - **核心实现思想**：从1到 \( n \) 遍历输入的糖果数，在输入每个数时，判断其与前一个数之和是否大于 \( x \)，若大于则计算需吃掉的糖果数并更新当前数和总吃掉糖果数。
- **作者：myfly (赞：2)  星级：4星**
    - **关键亮点**：代码简洁，使用滚动数组思想，仅用两个变量记录当前和上一个糖果数，减少空间使用，同时通过巧妙的循环处理方式避免糖果数为负的情况。
    - **个人心得**：无
    ```cpp
    #include <iostream>
    using namespace std;
    int main() {
        int N,M; cin>>N>>M;
        long long ans=0;
        for (int i=0,x,rex=0,sub; i<N; i++) {
            cin>>x;
            if (x+rex>M) {
                sub=x+rex-M;
                ans+=sub;
                x-=sub;
            }
            rex=x;
        }
        cout<<ans;
        return 0;
    }
    ```
    - **核心实现思想**：在循环中，每次输入一个新的糖果数 \( x \)，判断其与上一个糖果数 \( rex \) 之和是否大于 \( M \)，若大于则计算并累加差值，同时更新 \( x \)，最后将更新后的 \( x \) 赋值给 \( rex \) 作为下一次循环的上一个糖果数。

### 最优关键思路或技巧
1. **贪心策略**：优先减少右边盒子糖果数，使每次操作对后续相邻盒子影响最优，保证总体吃掉糖果数最少。
2. **滚动数组思想**：如myfly的题解，仅用两个变量记录状态，减少空间开销，优化代码实现。

### 同类型题或类似算法套路拓展
此类题目属于贪心算法应用，通常涉及一系列决策，每次决策选择当前最优解，最终得到全局最优。类似套路如活动安排问题、背包问题（部分背包）等，解题关键在于找出合适的贪心策略。

### 洛谷相似题目推荐
1. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1937 [USACO10MAR]Barn Allocation G](https://www.luogu.com.cn/problem/P1937) 

---
处理用时：55.49秒
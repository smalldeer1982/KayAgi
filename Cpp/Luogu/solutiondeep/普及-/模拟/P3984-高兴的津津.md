# 题目信息

# 高兴的津津

## 题目描述

津津上高中了。她在自己的妈妈的魔鬼训练下，成为了一个神犇，每次参加一次 OI 比赛必拿 Au 虐全场。每次她拿到一个 Au 后就很高兴。假设津津不会因为其它事高兴，并且她的高兴会持续 $T$ 天（包含获奖当天。就算在高兴的时候再次拿到 Au，他的高兴也只能维持包括这次拿奖之日起 $T$ 天，而不是额外增加 $T$ 天的高兴时间，除非之后再拿奖）。请你帮忙检查一下津津接下来的的日程安排，要参加 $n$ 场比赛，看看接下来的几天，津津会累计开心多久？

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1\le n\le2\times10^5$。
- $1\le T\le10^9$。
- $1\le t_i\le 10^9$，$t_i$ 单调递增。

## 样例 #1

### 输入

```
3 5
1 2 10```

### 输出

```
11```

# AI分析结果

### 综合分析与结论
这些题解思路基本一致，均利用题目中数据单调递增的特性，通过遍历相邻获奖时间，依据时间间隔与高兴持续天数 \( T \) 的比较来计算开心天数。算法要点在于：每次循环读取当前获奖时间，与上一次获奖时间作差，若差值小于等于 \( T \)，则累加差值；若差值大于 \( T \)，则累加 \( T \)。最后加上最后一次获奖必然持续的 \( T \) 天。解决难点主要是处理高兴时间的重叠情况，通过上述比较方式避免重复计算。

多数题解质量相近，部分题解在代码注释、变量命名等方面更优，提升了可读性。部分题解在空间使用上进行了优化，未使用数组存储所有数据。

### 所选的题解
- **作者：zy小可爱ღ（4星）**
    - **关键亮点**：思路阐述清晰，结合代码注释详细说明每一步操作，变量命名直观，代码简洁明了。
    - **个人心得**：无
    - **核心代码**：
```cpp
int n,t,ans;
int a[200005];

int main(){
    scanf("%d%d",&n,&t);
    scanf("%d",&a[1]);
    for(int i=2;i<=n;i++){
        scanf("%d",&a[i]);
        if(a[i]-a[i-1]<t){
            ans+=a[i]-a[i-1];
        }
        else{
            ans+=t;
        }
    }
    printf("%d\n",ans+t);
    return 0;
}
```
    - **核心实现思想**：从第二个获奖时间开始遍历，比较相邻获奖时间差与 \( t \) 的大小，根据结果累加相应天数，最后加上最后一次获奖持续的 \( t \) 天。

- **作者：_ZZH（4星）**
    - **关键亮点**：指出不需要数组，通过记录上一场比赛时间来计算间隔，优化了空间复杂度，代码简洁高效。
    - **个人心得**：无
    - **核心代码**：
```cpp
int n;
int t,before;
long long ans;

int main()
{
    scanf("%d%d",&n,&t);
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        if(!before)
        {
            before=x;
            continue;
        }
        if(x-before<=t)
            ans+=x-before;
        else
            ans+=t;
        before=x;
    }
    cout<<ans+t;
}
```
    - **核心实现思想**：每次读取当前比赛时间，与上一场比赛时间比较间隔，按规则累加天数，最后加上最后一场比赛持续的 \( t \) 天。

- **作者：Sinwind（4星）**
    - **关键亮点**：详细分析了每一步的逻辑，代码结构清晰，变量命名表意明确，对高兴时间重叠与未重叠的情况处理描述清晰。
    - **个人心得**：无
    - **核心代码**：
```cpp
int n;
int t;
int last_day;
int recent_day;
int total_days;

int main(void)
{
    cin >> n >> t;
    cin >> last_day;
    while(n--)
    {
        cin >> recent_day;
        if(recent_day <= last_day + t - 1)
        {
            total_days += recent_day - last_day;
        }
        else
        {
            total_days += t;
        }
        last_day = recent_day;
    }
    total_days += t;

    cout << total_days;

    return 0;
}
```
    - **核心实现思想**：通过循环读取每场比赛时间，比较当前与上一次比赛时间，按高兴时间是否重叠累加天数，最后加上最后一次比赛持续的 \( t \) 天。

### 最优关键思路或技巧
利用数据单调递增的特点，采用线性遍历相邻数据的方式，通过简单的比较和累加操作，避免复杂的数据结构和算法，高效解决问题。同时，部分题解在空间使用上进行优化，不使用数组存储所有数据，仅记录必要的上一次时间信息，降低空间复杂度。

### 可拓展之处
此类题型属于区间合并求总长度的问题，类似套路可应用于区间重叠相关的场景，如计算多个时间段内有效的工作时间、统计多个事件影响的总时长等。解题关键在于合理处理区间的重叠部分，避免重复计算。

### 相似知识点洛谷题目
- **P1003 [NOIP2011 普及组] 铺地毯**：通过模拟地毯铺设过程，判断点是否被覆盖，考察对区间覆盖问题的理解和处理能力。
- **P1199 [NOIP2010 普及组] 三国游戏**：涉及到对武将武力值的比较和选择策略，与本题类似，需要根据一定规则处理数据并得出结果。
- **P1423 小玉在游泳**：通过计算小玉游泳的时间和距离，考察对条件判断和循环累加的运用，与本题计算开心天数的逻辑有相似之处。 

---
处理用时：75.14秒
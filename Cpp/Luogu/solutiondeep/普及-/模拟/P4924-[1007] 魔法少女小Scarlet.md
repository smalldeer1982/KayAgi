# 题目信息

# [1007] 魔法少女小Scarlet

## 题目描述

Scarlet 最近学会了一个数组魔法，她会在 $n\times n$ 二维数组上将一个奇数阶方阵按照顺时针或者逆时针旋转 $90^\circ$。

首先，Scarlet 会把 $1$ 到 $n^2$ 的正整数按照从左往右，从上至下的顺序填入初始的二维数组中，然后她会施放一些简易的魔法。

Scarlet 既不会什么分块特技，也不会什么 Splay 套 Splay，她现在提供给你她的魔法执行顺序，想让你来告诉她魔法按次执行完毕后的二维数组。

## 说明/提示

对于50%的数据，满足 $r=1$

对于100%的数据 $1\leq n,m\leq500$，满足 $1\leq x-r\leq x+r\leq n,1\leq y-r\leq y+r\leq n$。

## 样例 #1

### 输入

```
5 4
2 2 1 0
3 3 1 1
4 4 1 0
3 3 2 1```

### 输出

```
5 10 3 18 15
4 19 8 17 20
1 14 23 24 25
6 9 2 7 22
11 12 13 16 21```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均为模拟矩阵旋转操作。算法要点在于确定旋转中心、半径及旋转方向后，通过坐标变换实现矩阵元素的重新排列。解决难点主要是准确推导顺时针和逆时针旋转时元素坐标的变换规律。

各题解在思路清晰度、代码可读性、优化程度上存在差异。整体来看，多数题解通过直接模拟实现，未进行过多优化，但由于数据范围较小，均能满足要求。

### 所选的题解
- **作者：黎曦の夜 (赞：248) - 5星**
    - **关键亮点**：代码简洁，直接通过模拟坐标变换实现旋转，逻辑清晰，易于理解。
    - **个人心得**：无
    ```cpp
    if(opt==0) {
        for(int i=a-r;i<=a+r;i++)
            for(int j=b-r;j<=b+r;j++)
                f[a-b+j][a+b-i] = g[i][j];
        for(int i=a-r;i<=a+r;i++)
            for(int j=b-r;j<=b+r;j++)
                g[i][j] = f[i][j];
    }
    else { 
        for(int i=a-r;i<=a+r;i++)
            for(int j=b-r;j<=b+r;j++)
                f[a+b-j][b-a+i] = g[i][j];
        for(int i=a-r;i<=a+r;i++)
            for(int j=b-r;j<=b+r;j++)
                g[i][j] = f[i][j];
    }
    ```
    **核心思想**：顺时针旋转时，通过 `f[a - b + j][a + b - i] = g[i][j]` 实现坐标变换；逆时针旋转时，通过 `f[a + b - j][b - a + i] = g[i][j]` 实现坐标变换，最后将临时数组 `f` 赋值回原数组 `g`。

- **作者：BzhH (赞：127) - 4星**
    - **关键亮点**：将顺时针和逆时针旋转分别封装成函数，代码结构清晰，通过临时数组 `temp` 辅助完成旋转操作。
    - **个人心得**：无
    ```cpp
    void spin(int x,int y,int r) {
        for(int i=x-r;i<=x+r;i++) {
            for(int k=y-r;k<=y+r;k++)
                temp[i][k]=square[i][k];
        }
        int x1=x+r,y1=y-r;
        for(int i=x-r;i<=x+r;i++) {
            for(int k=y-r;k<=y+r;k++) {
                square[i][k]=temp[x1][y1];
                x1--;
            }
            x1=x+r,y1++;
        }
    }
    void spin_(int x,int y,int r) {
        for(int i=x-r;i<=x+r;i++) {
            for(int k=y-r;k<=y+r;k++)
                temp[i][k]=square[i][k];
        }
        int x1=x-r,y1=y+r;
        for(int i=x-r;i<=x+r;i++) {
            for(int k=y-r;k<=y+r;k++) {
                square[i][k]=temp[x1][y1];
                x1++;
            }
            y1--,x1=x-r;
        }
    }
    ```
    **核心思想**：`spin` 函数实现顺时针旋转，先将原矩阵对应部分存入 `temp`，再按顺时针旋转规律从 `temp` 赋值回原矩阵；`spin_` 函数实现逆时针旋转，原理类似。

- **作者：友利奈绪 (赞：46) - 4星**
    - **关键亮点**：通过将旋转中心设为原点简化坐标推导，清晰地给出顺时针和逆时针旋转的坐标变换公式，并分别实现。
    - **个人心得**：推式子花费较多时间且易出错。
    ```cpp
    void change(int x,int y,int r,int z) {
        if(z==0) {
            for(int i=-r;i<=r;i++) {
                for(int j=-r;j<=r;j++) { 	
                    b[x+j][y-i]=a[x+i][y+j];
                }
            }
        }
        if(z==1) {
            for(int i=-r;i<=r;i++) {
                for(int j=-r;j<=r;j++) {
                    b[x-j][y+i]=a[x+i][y+j];
                }
            }
        }
    }
    ```
    **核心思想**：`change` 函数根据旋转方向 `z`，分别按顺时针 `b[x + j][y - i] = a[x + i][y + j]` 和逆时针 `b[x - j][y + i] = a[x + i][y + j]` 的坐标变换公式进行赋值。

### 最优关键思路或技巧
将旋转中心设为原点来推导坐标变换公式，能使思路更清晰，坐标变换规律更易发现和实现，如友利奈绪的题解。同时，部分题解将顺时针和逆时针旋转操作封装成函数，增强了代码的结构性和可读性，如BzhH的题解。

### 可拓展之处
此类题目可拓展到更复杂的矩阵变换，如旋转任意角度、多次不同变换组合等。类似算法套路是通过建立坐标系，分析元素在变换前后的坐标关系，从而实现矩阵元素的正确移动。

### 相似知识点洛谷题目
1. **P1338 末日的传说**：涉及到数组元素位置的变换，与矩阵旋转中元素位置调整类似。
2. **P1464 Function**：通过模拟函数执行过程，实现对数据的操作，和本题模拟矩阵旋转操作思路相似。
3. **P2141 珠心算测验**：对数组元素进行处理和统计，考查对数据的操作和逻辑处理能力，与本题模拟矩阵操作有相通之处。

### 个人心得摘录与总结
- **作者：友利奈绪**：推式子花费较长时间且容易出错。总结为推导坐标变换公式时需仔细，可通过设特殊点简化推导过程。
- **作者：Gamin**：因符号错误导致得分低，强调了细节在编程中的重要性，需仔细检查代码逻辑和符号使用。 

---
处理用时：62.28秒
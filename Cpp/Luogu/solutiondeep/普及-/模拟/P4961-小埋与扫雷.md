# 题目信息

# 小埋与扫雷

## 题目背景

小埋总是在家中打游戏，一天，她突然想玩Windows自带的扫雷，在一旁的哥哥看见了，想起了自己小时候信息课在机房玩扫雷的日子，便兴致勃勃地开始教小埋扫雷。然而，小埋还是不明白 $\mathrm{3bv}$（Bechtel's Board Benchmark Value，每局将所有非雷的方块点开所需最少左键点击数，参见[扫雷网的教程](http://saolei.net/BBS/Title.asp?Id=227) ）怎么算，于是她找到了你。

![](https://i.loli.net/2018/10/04/5bb5bd6aefb70.jpg)

## 题目描述

小埋会告诉你一盘扫雷，用一个 $n\times m$ 的矩阵表示，$1$ 是雷 ，$0$ 不是雷，请你告诉她这盘扫雷的 $\mathrm{3bv}$ 。 

周围八格没有“雷”且自身不是“雷”的方格称为“空格”，周围八格有“雷”且自身不是“雷”的方格称为“数字”，由“空格”组成的八连通块称为一个“空”。$\mathrm{3bv}=\ $周围八格没有“空格”的“数字”个数$+$“空"的个数。

如果看不懂上面的计算方式，可以看题目背景中给出的教程，或者看下面的样例解释。

注：[八连通](https://baike.baidu.com/item/%E5%85%AB%E8%BF%9E%E9%80%9A)

## 说明/提示

$1\le n,\ m\le 1000$

## 样例解释

![](https://i.loli.net/2018/10/04/5bb5bc4644183.jpg)

## 样例 #1

### 输入

```
8 8
0 0 0 1 1 0 0 0 
1 0 0 1 0 0 0 1 
1 0 0 1 0 0 0 0 
0 0 0 0 0 0 0 0 
0 0 0 0 0 1 0 0 
0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 
0 1 0 0 0 0 0 0 ```

### 输出

```
13```

# AI分析结果

• 综合分析与结论：这些题解主要围绕通过深度优先搜索（DFS）或广度优先搜索（BFS）来解决计算扫雷游戏3bv值的问题。思路上，都需先区分雷、数字和空格，再统计周围八格没有空格的数字个数与空格组成的八连通块个数并求和。算法要点在于利用数组记录方向以实现八连通的搜索，难点主要是八连通的正确处理以及边界条件判断。部分题解还涉及对雷图的初始化、标记已访问节点避免重复搜索等。

所选的题解：
  - 作者：Arse、三千体 (赞：76)  星级：5星
    - 关键亮点：思路清晰，代码结构完整，详细注释。将问题分解为初始化雷图、判断周围是否有空格、DFS搜索连通块等步骤。
    - 个人心得：强调读题重要性，因未仔细读题忽略八连通而受挫，且初始化雷图花费较长时间思考。
```cpp
void dfs(int x,int y)//联通快
{
    for(int i=0;i<8;i++)
    {
        int xx=x+xz[i],yy=y+yz[i];
        if(xx>=0&&xx<n&&yy>=0&&yy<m&&a[xx][yy]==0&&!booka[xx][yy])//判断边界与重复
        {
            booka[xx][yy]=true;//打标记
            dfs(xx,yy);
        }
    }
}
void b(int x,int y)//初始化雷图用的，把格子里填数字
{
    for(int p=0;p<8;p++)
    {
        int i=x+xz[p],j=y+yz[p];
        if(i>=0&&i<n&&j>=0&&j<m&&a[i][j]!=-1) 
                                          a[i][j]++;
    }
}
int iff(int x,int y)//判断周围八格是否有空格
{
    for(int i=0;i<8;i++)
    {
        int xx=x+xz[i];
        int yy=y+yz[i];
        if(xx>=0&&xx<n&&yy>=0&&yy<m&&a[xx][yy]==0)//判空格
                                               return 0;
    }
    return 1;
}
```
  - 作者：ouuan (赞：17)  星级：4星
    - 关键亮点：提出优化思路，先记录所有数字答案，DFS时遇到数字将答案减一并不继续DFS，减少代码量和时间复杂度。
```cpp
void dfs(int x,int y)
{
    if (vis[x][y]||g[x][y]==-1)
    {
        return;
    }
    
    vis[x][y]=true;
    
    if (g[x][y]==0)
    {
        for (int i=0;i<8;++i)
        {
            dfs(x+dir[i][0],y+dir[i][1]); //dfs到空格继续dfs
        }
    }
    
    else
    {
        --ans; //dfs到数字将答案减一
    }
}
```
  - 作者：派大那个星 (赞：10)  星级：4星
    - 关键亮点：代码逻辑清晰，将不同功能封装成函数，如`paint`函数计算数字，`check`函数判断数字周围是否有空格，`dfs`函数处理空格连通块。
```cpp
void dfs(int x,int y)
{
    vis[x][y]=1;
    for(int i=0;i<=7;i++)
    {
        int tx=x+dx[i],ty=y+dy[i];
        if(Map[tx][ty]==0&&vis[tx][ty]==0&&tx>0&&tx<=n&&ty>0&&ty<=m)dfs(tx,ty);
    }
}
void paint(int x,int y)
{
    Map[x][y]=9;//将炸弹与数字区分，数字不可能大于8
    for(int i=0;i<=7;i++)if(Map[x+dx[i]][y+dy[i]]!=9)Map[x+dx[i]][y+dy[i]]++;
}
bool check(int x,int y)
{
    for(int i=0;i<=7;i++)if(Map[x+dx[i]][y+dy[i]]==0)return false;
    return true;
}
```
最优关键思路或技巧：利用方向数组实现八连通搜索，通过标记数组记录已访问节点避免重复搜索，部分题解采用先记录数字答案并在DFS中优化处理的方式减少计算量。同时，将不同功能模块化封装成函数，提高代码可读性和可维护性。
可拓展之处：同类型题可涉及其他连通性问题，如岛屿数量统计等。类似算法套路是利用搜索算法（DFS或BFS）结合标记数组处理连通块问题，通过预处理和条件判断解决复杂的计数问题。
推荐题目：
  - P1596 [USACO10OCT]Lake Counting S ，统计八连通的水洼数量。
  - P2746 [USACO5.3]校园网Network of Schools ，涉及有向图连通性问题。
  - P1339 热浪 ，单源最短路径问题，与搜索算法结合可解决更复杂的图论问题。 

---
处理用时：52.55秒
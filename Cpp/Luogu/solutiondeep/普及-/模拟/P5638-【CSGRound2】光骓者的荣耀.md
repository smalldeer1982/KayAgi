# 题目信息

# 【CSGRound2】光骓者的荣耀

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/s6ozu5pj.png)

小 K 又在做白日梦了。他进入到他的幻想中，发现他打下了一片江山。

## 题目描述

小 K 打下的江山一共有 $n$ 个城市，城市 $i$ 和城市 $i+1$ 有一条双向高速公路连接，走这条路要耗费时间 $a_i$。

小 K 为了关心人民生活，决定定期进行走访。他每一次会从 $1$ 号城市到 $n$ 号城市并在经过的城市进行访问。其中终点必须为城市 $n$。

不仅如此，他还有一个传送器，传送半径为 $k$，也就是可以传送到 $i-k$ 和 $i+k$。如果目标城市编号小于 $1$ 则为 $1$，大于 $n$ 则为 $n$。

但是他的传送器电量不足，只能传送一次，况且由于一些原因，他想尽量快的完成访问，于是就想问交通部部长您最快的时间是多少。

注意：**他可以不访问所有的城市，使用传送器不耗费时间**。

## 说明/提示

### 样例解释 1：

样例 1,2 的图示均为以下图片：

![MZbuTK.png](https://s2.ax1x.com/2019/11/08/MZbuTK.png)

不使用传送器直接走，答案为 $6$，可以证明这个是最小值。

### 样例解释 2：

在 $3$ 处使用，传送到 $4$，答案为 $3$，可以证明这个是最小值。

### 数据范围：

对于所有数据，$a_i > 0$

![Kvrl34.jpg](https://s2.ax1x.com/2019/11/04/Kvrl34.jpg)

## 样例 #1

### 输入

```
4 0
1 2 3```

### 输出

```
6```

## 样例 #2

### 输入

```
4 1
1 2 3```

### 输出

```
3```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何利用贪心策略和前缀和优化来解决从1号城市到n号城市且仅能使用一次传送器的最短时间问题。思路上大多是通过计算总路程，再减去传送所节省的最大路程来得到答案。算法要点在于快速找到长度为k的最大连续子段和，难点在于如何优化时间复杂度，避免暴力枚举导致超时。大部分题解都采用了前缀和数组来快速计算区间和，部分题解还通过优化循环边界、递推公式等进一步降低时间复杂度。

所选的题解：
  - **作者：Mophie (赞：178)  5星**
    - **关键亮点**：思路清晰，从暴力算法逐步优化到最优解，详细阐述了每种算法的思路、复杂度及得分情况，并给出了多种优化方式，包括前缀和优化及dp解法，代码注释详细。
    - **个人心得**：强调开long long的重要性，感谢出题组。
    - **重点代码 - 前缀和优化**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long sum[1000001];
long long n,k;
int main()
{
    cin>>n>>k;
    if(k>=n-1)
    {
        cout<<0<<endl;
        return 0;
    } 
    for(int i=1;i<=n-1;i++)
    {
        long long x;
        cin>>x;
        sum[i]=sum[i-1]+x;//前缀和
    }
    long long cnt=sum[k];
    for(int i=2;i<=n-k;i++)
    {
        cnt=max(cnt,sum[i+k-1]-sum[i-1]);//i->i+k-1
    }
    cout<<sum[n-1]-cnt<<endl;
    return 0;
}
```
核心实现思想：通过前缀和数组sum记录从1到i的距离和，然后遍历所有可能的长度为k的区间，计算每个区间的和并找出最大值，最后用总距离和减去这个最大值得到最短时间。
    - **重点代码 - dp解法**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[1000009][2],a[1000009],ans;
int n,k;
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n-1;i++)
    {
        cin>>a[i];
    }
    for(int i=2;i<=n;i++)
    {
        dp[i][0]=dp[i-1][0]+a[i-1];
        if(i>k)dp[i][1]=dp[i-k][0];
        dp[i][1]=min(dp[i-1][1]+a[i-1],dp[i][1]);//状态转移方程
    }
    cout<<dp[n][1]<<endl;//输出
    return 0;
} 
```
核心实现思想：使用dp数组，dp[i][0]表示第i个包括前面都不跳的最小时间，dp[i][1]表示第i个跳的最小时间，通过状态转移方程更新dp数组，最后得到到达n号城市的最短时间。

  - **作者：沉冥Charming (赞：33)  4星**
    - **关键亮点**：简洁明了地阐述贪心思路，即选择最长的k段进行传送，利用前缀和计算节省时间，代码注释详细，指出循环从0开始的坑点。
    - **个人心得**：分享自己因循环从1开始导致只得到92分的调试经历。
    - **重点代码**：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
#define ull unsigned long long //防止不开long long见祖宗
#define ll unsigned long long
ull n,k,sum[1000005],cnt;
ll qr()//快读，让您的排名更好看
{
    ll ret=0;
    char c=getchar();
    while (c<'0'||c>'9')
        c=getchar();
    while (c>='0'&&c<='9')
    {
        ret=(ret<<1)+(ret<<3)+c-'0';
        c=getchar();
    }
    return ret;
}
int main()
{
    //cin>>n>>k; //cin太慢了
    n=qr(),k=qr();
    for (int i=1; i<n; i++)
    {
        ull a;
        //cin>>a;
        a=qr();
        sum[i]=sum[i-1]+a; //前缀和
    }
    for (int i=0; i+k<n; i++) //从0开始循环
        cnt=max(cnt,sum[i+k]-sum[i]); //找节省时间最大值
    cout<<sum[n-1]-cnt;
    return 0;
}
```
核心实现思想：利用前缀和数组sum记录从1到i的距离和，从0开始循环遍历所有可能的长度为k的区间，找出节省时间的最大值，用总距离和减去该值得到最短时间。

  - **作者：Asrit (赞：27)  4星**
    - **关键亮点**：清晰说明用总时间减去传送节约时间的思路，详细解释前缀和的使用方法来计算区间和，代码简洁易懂。
    - **重点代码**：
```cpp
#include<iostream>
using namespace std;
long long sum[1000001];//因为有10^12的a，所以用long long
int main()
{
    long long n,k,a,maxx=0;
    cin>>n>>k;
    sum[1]=0;
    for(int i=2;i<=n;i++)
    {
        cin>>a;
        sum[i]=sum[i-1]+a;//算前缀和
    }
    for(int i=k+1;i<=n;i++)//这里从1到n-k，下面用sum[i+k]-sum[i]也可以
        maxx=max(maxx,sum[i]-sum[i-k]);
    cout<<sum[n]-maxx;
    return 0;
}
```
核心实现思想：通过前缀和数组sum记录从1到i的距离和，遍历所有可能的长度为k的区间，计算每个区间的和并找出最大值，最后用总距离和减去这个最大值得到最短时间。

• 最优关键思路或技巧：利用贪心策略，由于边权非负，选择跳过长度为k的最大连续子段和的路径能使总时间最短。通过前缀和数组优化区间和的计算，将时间复杂度从暴力枚举的$O(n^2)$降低到$O(n)$。

• 可拓展之处：同类型题可涉及在不同图结构（如树形结构）下的路径选择问题，类似算法套路为分析题目性质，确定贪心策略，利用合适的数据结构（如前缀和、线段树等）优化计算。

• 相似知识点洛谷题目：
  - [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：求给定序列的最大子段和，与本题找最大连续子段和思路相似。
  - [P3397 地毯](https://www.luogu.com.cn/problem/P3397)：通过二维前缀和解决矩形区域和的问题，可拓展前缀和的应用场景。
  - [P1417 烹调方案](https://www.luogu.com.cn/problem/P1417)：结合贪心与dp思想解决问题，与本题思路有一定关联。

• 个人心得摘录与总结：许多作者强调开long long的重要性，部分作者分享了调试过程中的坑点，如循环起始点的选择（从0还是1开始），这些经验有助于避免在类似题目中犯错。 

---
处理用时：71.46秒
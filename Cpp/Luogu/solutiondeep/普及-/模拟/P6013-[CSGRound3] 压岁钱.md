# 题目信息

# [CSGRound3] 压岁钱

## 题目背景

祝大家庚子鼠年快乐！Best wishes! 

也愿肺炎早日得到控制吧，中国加油！

新年到了，小 Z 总是能收到很多的压岁钱。

小 Z 是个非常喜欢氪金的玩家，所以时不时都会把压岁钱花掉一部分用来买皮肤和石头。

但是小 Z 又十分担心压岁钱没过几天就都被自己花完了。为此，小 Z 有封印大法，能够暂时的把自己的一部分钱封印起来（即无法花费），直到某一天解除封印后才能使用。

## 题目描述

一共存在有 $m$ 个事件，且事件分为以下的 $3$ 种类型。

1. 小 Z 得到了 $a$ 元压岁钱。
2. 小 Z 花掉了 $a$ 元压岁钱用于买皮肤。
3. 小 Z 把自己的 $a$ 元钱封印了起来，只有当第 $b$ 个事件发生前 $1$ 秒才会解除封印，并保证每次小 Z 现有的钱大于等于封印的钱。

当小 Z 的钱在某个事件不够花时，小 Z 会感到不开心，同时钱不够花时小 Z 便不会花钱。

请告诉小 Z ，他的钱在几个事件中会不够花。

## 说明/提示

**【样例 1 解释】**

第一天：收入 $10$ 元，余额 $10$ 元。

第二天：不够支出 $20$ 元，余额 $10$ 元。

第三天：支出 $10$ 元，余额 $0$ 元。

总计：$1$ 天。

**【样例 2 解释】**

第一天：收入 $10$ 元，余额 $10$ 元。

第二天：封印 $5$ 元，余额 $5$ 元。

第三天：不够支出 $10$ 元，余额 $5$ 元。

第四天：收入 $10$ 元，余额 $15$ 元。

第五天：封印解开，支出 $20$ 元，余额 $0$ 元。

总计：$1$ 天。

---

**【数据范围】**

对于 $50\%$ 的数据，满足 $m,a \leq 5\times 10^3$。

对于 $70\%$ 的数据，$t \ne 3$。

对于 $100\%$ 的数据，满足 $ 1 \leq b \le m \leq 10^6$，$1 \le t \le 3$，$1 \leq a \leq 10^7$。

## 样例 #1

### 输入

```
3
1 10
2 20
2 10```

### 输出

```
1```

## 样例 #2

### 输入

```
5
1 10
3 5 5
2 10
1 10
2 20```

### 输出

```
1```

# AI分析结果

• 综合分析与结论：这些题解均采用模拟的思路解决问题，核心在于处理三种事件类型对压岁钱数量的影响，尤其是封印和解封操作。各题解的算法要点基本一致，都是用变量记录当前钱数，用数组记录各事件解封的钱数。难点在于正确理解封印和解封的逻辑，并在代码中准确实现，同时要注意数据范围，避免因未使用合适数据类型（如未开`long long`）导致错误。多数题解质量相近，主要差异在于代码风格和实现细节。

所选的题解：
  - 作者：梦里调音 (赞：11)  星级：4星
    - 关键亮点：思路清晰，代码简洁明了，直接按题目要求模拟，对封印操作的处理直观易懂，同时强调了数据类型的重要性。
    - 重点代码核心实现思想：用`n`记录当前钱数，`f`数组记录每个事件前解封的钱数。遍历每个事件，根据事件类型进行相应操作，事件1增加钱数，事件2判断钱是否够花并处理，事件3记录封印信息并减少当前钱数。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e8+5; 
unsigned long long m,n,ans;//rt,money,answer
unsigned long long f[N];//f[i]表示第i个事件前要解封的钱
int main()
{
    cin>>m;
    for(unsigned long long i=1,t;i<=m;i++)
    {
        n+=f[i];
        cin>>t;
        if(t==1)
        {
            unsigned long long a;
            cin>>a;
            n+=a;
        }
        else if(t==2)
        {
            unsigned long long a;
            cin>>a;
            if(n<a)ans++;
            else n-=a;
        }
        else{
            unsigned long long a,b;
            cin>>a>>b;
            f[b]+=a;
            n=n-a;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
  - 作者：Skyjoy (赞：6)  星级：4星
    - 关键亮点：代码结构清晰，通过数组`f`巧妙地处理封印情况，对每个事件的处理逻辑在代码中一目了然，同样提到钱数最好用数组存以方便处理封印。
    - 重点代码核心实现思想：`f`数组不仅记录解封钱数，还通过`f[i]+=f[i - 1]`累计之前的钱数。根据事件类型，事件1增加`f[i]`，事件2判断`f[i]`是否够花，事件3调整`f[i]`和对应解封时间的`f[b]`。
```cpp
#include<bits/stdc++.h>
#define ll long long
#define re register
using namespace std;
ll n,t,a,b,ans,f[1000010];
int main(){
    cin>>n;
    for(re ll i=1;i<=n;i++){
        cin>>t;
        f[i]+=f[i-1];
        if(t==3){
            cin>>a>>b;
            f[i]-=a;
            f[b]+=a;
        }
        else{
            cin>>a;
            if(t==1){
                f[i]+=a;
            }
            else{
                if(f[i]<a){
                    ans++;
                }
                else{
                    f[i]-=a;
                }
            }
        }
    }
    cout<<ans;
    return 0;
}
```
  - 作者：StudyingFather (赞：2)  星级：4星
    - 关键亮点：采用优先队列维护封印资产，在花钱时能高效地将解封时间小于等于当前时间的资产解冻，相比普通数组记录解封钱数，在处理复杂时间顺序时有一定优势。
    - 重点代码核心实现思想：用优先队列`q`存储封印信息（解封时间和金额），`x`记录当前钱数。遍历事件，事件1增加`x`，事件2先将符合条件的封印资产解封加入`x`，再判断`x`是否够花，事件3将封印信息加入优先队列并减少`x`。
```cpp
#include <iostream>
#include <queue>
using namespace std;
typedef pair<int,int> pii;
priority_queue<pii,vector<pii>,greater<pii> > q;
int main()
{
    ios::sync_with_stdio(false);
    int m,ans=0;
    long long x=0;
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        int op,a,b;
        cin>>op;
        if(op==1)
        {
            cin>>a;
            x+=a;
        }
        else if(op==2)
        {
            cin>>a;
            while(!q.empty()&&q.top().first<=i)
            {
                x+=q.top().second;
                q.pop();
            }
            if(x>=a)x-=a;
            else ans++;
        }
        else
        {
            cin>>a>>b;
            q.push({b,a});
            x-=a;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

最优关键思路或技巧：
 - 通用方法是用数组记录每个事件解封的钱数，在处理每个事件时，先加上该事件解封的钱，再根据事件类型进行操作。
 - StudyingFather的方法利用优先队列维护封印资产，在处理解封时间顺序上更为灵活高效，适用于更复杂的时间相关操作场景。

可拓展思路：此类题目属于模拟现实场景的问题，类似套路是将现实操作抽象为代码中的数据结构和逻辑操作。同类型题可涉及更多复杂的金融操作或时间序列相关的事件处理。

推荐洛谷题目：
 - P1031 [NOIP2002 普及组] 均分纸牌
 - P1909 买铅笔
 - P1046 [NOIP2005 普及组] 陶陶摘苹果（升级版）

个人心得摘录与总结：
 - “十年OI一场空，不开long long见祖宗”：众多作者强调了根据数据范围选择合适数据类型的重要性，在处理较大数据时，`long long`能避免数据溢出错误。
 - 部分作者提到对题目中封印操作的理解和处理方式容易出错，需要仔细分析题目条件，准确实现逻辑，如封印钱数的叠加处理，不能简单赋值而应累加。 

---
处理用时：66.05秒
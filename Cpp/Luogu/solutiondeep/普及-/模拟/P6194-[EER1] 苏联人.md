# 题目信息

# [EER1] 苏联人

## 题目背景

~~题目名称是吸引你点进来的。~~

这是一道正常的题，和苏联没有任何关系。

## 题目描述

你在打 EE Round 1，发现第一题非常无聊。于是你不打了，去下国际象棋了。

结果你发现，由于神秘力量的影响，你的棋子只剩下若干黑色的战车，若干黑色的主教和一只白色的国王了。

由于你很无聊，所以你把一些黑色棋子放在了 $8\times 8$ 的棋盘上。

由于你很无聊，所以你想知道，国王放在哪些格子是安全的。换句话说，有哪些格子不会被战车和主教攻击到。当然，**国王不能放在已经有棋子的地方**。

为了防止你无聊透顶而不知道国际象棋的规则，这里给出以下提示（如果你知道规则那么可以跳过）：

国际象棋中，战车可以横向、竖向移动，且格数不受限制。但**不能越过其他棋子**。

![](https://cdn.luogu.com.cn/upload/image_hosting/5symt5td.png)

如图，黄色的格子为战车能走到（攻击到）的格子。

国际象棋中，主教可以斜向移动，且格数不受限制。但**不能越过其他棋子**。

![](https://cdn.luogu.com.cn/upload/image_hosting/skmw1njm.png)

如图，黄色的格子为主教能走到（攻击到）的格子。

简单来说，如果当前位置到目标位置的**直线**上存在其他棋子，则可以称为“越过了其他棋子”。

如果目标位置是对方的棋子，那么移动到目标位置后，对方的棋子会被吃掉。

更进一步地，你要找的所有位置，必须满足没有黑色棋子能一步走到。

---

如果你还是没有读懂，可以结合样例进行理解。

## 说明/提示

对于 $100\%$ 的数据，保证只会出现 `.`，`R`，`B` 三种字符。

本题共有 $4$ 个子任务，每个子任务的限制如下：

子任务 $1$（$10$ 分）：保证只会出现 `.`。

子任务 $2$（$20$ 分）：保证只会出现一个 `R` 或一个 `B`（不同时出现）。

子任务 $3$（$30$ 分）：保证只有一个 `.`。

子任务 $4$（$40$ 分）：没有特殊限制。

## 样例 #1

### 输入

```
........
........
........
..B..R..
........
........
........
........
```

### 输出

```
11111011
01110011
10101011
11000000
10101011
01110011
11111011
11111001
```

# AI分析结果

### 综合分析与结论
这些题解均围绕如何模拟国际象棋中战车（`R`）和主教（`B`）在棋盘上的攻击范围，从而确定国王可放置的安全位置。思路上，大多通过遍历棋盘上每个棋子，依据其类型（`R`或`B`）向对应方向扩展标记攻击范围，遇到其他棋子则停止。算法要点在于正确实现各棋子攻击范围的模拟，难点主要是处理棋子不能越过其他棋子这一规则。

### 所选的题解
- **作者：幻之陨梦 (赞：38)  星级：4星**
    - **关键亮点**：思路清晰，代码简洁明了，详细注释了每一步操作，对攻击范围模拟的实现直观易懂。
    - **个人心得**：提到不能一边读入一边处理，否则会出错。
```cpp
for(int i=0;i<8;i++) scanf("%s",ch[i]);
for(int i=0;i<8;i++){
    for(int j=0;j<8;j++){
        if(ch[i][j]=='R'){
            ans[i][j]=1;
            for(int k=i-1;k>=0 && ch[k][j]=='.';k--) ans[k][j]=1;
            for(int k=i+1;k<8 && ch[k][j]=='.';k++) ans[k][j]=1;
            for(int k=j-1;k>=0 && ch[i][k]=='.';k--) ans[i][k]=1;
            for(int k=j+1;k<8 && ch[i][k]=='.';k++) ans[i][k]=1;
        }
        else if(ch[i][j]=='B'){
            ans[i][j]=1;
            for(int k=i-1,l=j-1;k>=0 && l>=0 && ch[k][l]=='.';k--,l--) ans[k][l]=1;
            for(int k=i+1,l=j+1;k<8 && l<8 && ch[k][l]=='.';k++,l++) ans[k][l]=1;
            for(int k=i-1,l=j+1;k>=0 && l<8 && ch[k][l]=='.';k--,l++) ans[k][l]=1;
            for(int k=i+1,l=j-1;k<8 && l>=0 && ch[k][l]=='.';k++,l--) ans[k][l]=1;
        }
    }
}
for(int i=0;i<8;i++){
    for(int j=0;j<8;j++) printf("%d",!ans[i][j]);
    puts("");
}
```
核心实现思想：先读入棋盘，遍历棋盘每个位置，若为`R`，则向上下左右四个方向标记攻击范围；若为`B`，则向四个斜方向标记攻击范围，最后输出取反后的结果。

- **作者：MZY666 (赞：20)  星级：4星**
    - **关键亮点**：结构清晰，有目录、题意概括和详细注释的代码，对题意理解和代码实现过程阐述详细。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
char a[10][10];
bool p[10][10];
int main(){
    ll i,j,k;
    for(i=1;i<=8;i++)
        for(j=1;j<=8;j++){
            cin>>a[i][j];
            if(a[i][j]!='.')p[i][j]=true;
        }
    for(i=1;i<=8;i++)
        for(j=1;j<=8;j++){
            if(a[i][j]=='.')continue;
            if(a[i][j]=='B'){
                for(k=1;i-k&&j-k;k++){
                    if(a[i-k][j-k]!='.')break;
                    p[i-k][j-k]=true;
                }
                for(k=1;i+k<=8&&j+k<=8;k++){
                    if(a[i+k][j+k]!='.')break;
                    p[i+k][j+k]=true;
                }
                for(k=1;i-k&&j+k<=8;k++){
                    if(a[i-k][j+k]!='.')break;
                    p[i-k][j+k]=true;
                }
                for(k=1;i+k<=8&&j-k;k++){
                    if(a[i+k][j-k]!='.')break;
                    p[i+k][j-k]=true;
                }
            }
            else{
                for(k=1;i-k;k++){
                    if(a[i-k][j]!='.')break;
                    p[i-k][j]=true;
                }
                for(k=1;j-k;k++){
                    if(a[i][j-k]!='.')break;
                    p[i][j-k]=true;
                }
                for(k=1;i+k<=8;k++){
                    if(a[i+k][j]!='.')break;
                    p[i+k][j]=true;
                }
                for(k=1;j+k<=8;k++){
                    if(a[i][j+k]!='.')break;
                    p[i][j+k]=true;
                }
            }
        }
    for(i=1;i<=8;i++){
        for(j=1;j<=8;j++)printf("%d",!p[i][j]);
        printf("\n");
    }
    return 0;
}
```
核心实现思想：定义数组存储棋盘状态和标记可放置情况，读入棋盘时标记有棋子位置。遍历棋盘，对`B`和`R`分别向对应方向扩展标记攻击范围，最后输出取反结果。

- **作者：SamariumPhosphide (赞：10)  星级：4星**
    - **关键亮点**：将战车和主教的攻击范围模拟分别封装成函数，逻辑清晰，对每个函数的实现原理有详细解释。
```cpp
void castle(int x, int y) { 
    for (int i = x - 1; i >= 1; i--) {
        if (board[i][y]) break;
        notok[i][y] = true;
    }
    for (int i = x + 1; i <= 8; i++) {
        if (board[i][y]) break;
        notok[i][y] = true;
    }
    for (int i = y - 1; i >= 1; i--) {
        if (board[x][i]) break;
        notok[x][i] = true;
    }
    for (int i = y + 1; i <= 8; i++) {
        if (board[x][i]) break;
        notok[x][i] = true;
    }
}
void bishop(int x, int y) {
    for (int i = 1; i <= min(x, y); i++) {
        if (board[x - i][y - i]) break;
        notok[x - i][y - i] = true;
    }
    for (int i = 1; i <= min(x, 8 - y); i++) {
        if (board[x - i][y + i]) break;
        notok[x - i][y + i] = true;
    }
    for (int i = 1; i <= min(y, 8 - x); i++) {
        if (board[x + i][y - i]) break;
        notok[x + i][y - i] = true;
    }
    for (int i = 1; i <= min(8 - y, 8 - x); i++) {
        if (board[x + i][y + i]) break;
        notok[x + i][y + i] = true;
    }
}
int main() {
    for (int i = 1; i <= 8; i++) {
        for (int j = 1; j <= 8; j++) {
            char c; cin >> c;
            if (c == '.') board[i][j] = 0;
            else if (c == 'R') board[i][j] = 1, notok[i][j] = true;
            else board[i][j] = 2, notok[i][j] = true;
        }
    }
    for (int i = 1; i <= 8; i++) {
        for (int j = 1; j <= 8; j++) {
            if (board[i][j] == 1) castle(i, j);
            else if (board[i][j] == 2) bishop(i, j);
        }
    }
    for (int i = 1; i <= 8; i++) {
        for (int j = 1; j <= 8; j++) {
            if (notok[i][j] == false) {
                putchar('1');
            } else {
                putchar('0');
            }
        }
        puts("");
    }
    return 0;
}
```
核心实现思想：定义函数`castle`和`bishop`分别模拟战车和主教攻击范围。读入棋盘并存储为数字形式，遍历棋盘调用对应函数标记攻击范围，最后输出结果。

### 最优关键思路或技巧
- **模块化处理**：像SamariumPhosphide将战车和主教的攻击范围模拟封装成函数，使代码逻辑更清晰，易于理解和维护。
- **边界和阻挡判断**：在模拟攻击范围扩展时，合理利用循环和条件判断处理边界情况以及棋子不能越过其他棋子的规则，如幻之陨梦在循环中判断当前位置是否为`.`来决定是否继续扩展。

### 可拓展之处
此类题目属于棋盘模拟类型，类似套路是根据给定的棋子移动规则，通过遍历棋盘模拟棋子的影响范围。同类型题可改变棋子种类、移动规则或棋盘大小等。例如，增加新棋子类型并定义其独特移动方式，或在更大规模棋盘上进行模拟。

### 相似知识点洛谷题目
- [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)：经典棋盘放置问题，考察对棋盘位置关系和条件判断的处理。
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：虽不是棋盘问题，但同样需要通过循环和条件判断来模拟不同情况，与本题模拟思路类似。
- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：涉及对二维数组区域的模拟和标记，与本题处理棋盘位置信息有相似之处。

### 个人心得摘录与总结
- **幻之陨梦**：强调不能边读入边处理，否则会出错，提示在处理复杂逻辑时要注意操作顺序。 

---
处理用时：114.86秒
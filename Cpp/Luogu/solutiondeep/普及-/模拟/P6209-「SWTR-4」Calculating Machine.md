# 题目信息

# 「SWTR-4」Calculating Machine

## 题目背景

小 E 在用自己的 Calculating Machine 计算 $n$ 个**十进制**数 $a_1,a_2,\cdots,a_n$ 的和。



## 题目描述

小 E 计算几个数的和的方式为：

- 如果参与运算的数不止 $2$ 个，那么**从左往右**依次计算。

- 若两个数的位数不同，则位数少的数自动在前面补前导零，直到两数位数相同。

- 从两个数的最低位开始，计算当前位两个数码的和加上前一位的进位，写上这个和除以 $10$ 的余数。

- 进位规则：如果当前位两个数码的和加上前一位的进位小于 $7$，不进位；如果和大于等于 $7$ 且小于等于 $13$，则进一位；否则进两位。

例如：$2+4=6$，$7+8=25$，$61+6=177$，$38+169=217$，$3+900=1903$。

由于小 E 的计算机器被 360 安全病毒当成病毒杀死了，所以他想请你帮忙求出 $a_1+a_2+\dots+a_n$。

## 说明/提示

【样例 $3$ 说明】

$345+379+573=1734+573=2317$。

【样例 $4$ 说明】

$1234+567+89+10=2801+89+10=3990+10=4000$。

【数据范围与约定】

对于 $10\%$ 的数据，$n=1$。

对于 $30\%$ 的数据，$n \leq 2$。

对于 $60\%$ 的数据，$n \leq 10$，$a_i \leq 10^5$。

对于 $100\%$ 的数据，$1 \leq n \leq 2020$，$0 \leq a_i \leq 10^9$。

【Source】

[Sweet Round 04](https://www.luogu.com.cn/contest/26414)$\ \ $A

idea：[ET2006](https://www.luogu.com.cn/user/115194)，std：[Alex_Wei](https://www.luogu.com.cn/user/123294)，验题：[Isaunoya](https://www.luogu.com.cn/user/96580) & [FrenkiedeJong21](https://www.luogu.com.cn/user/203968) & [chenxia25](https://www.luogu.com.cn/user/138400)

## 样例 #1

### 输入

```
1
1
```

### 输出

```
1```

## 样例 #2

### 输入

```
2
233 23333
```

### 输出

```
23566```

## 样例 #3

### 输入

```
3
345 379 573
```

### 输出

```
2317```

## 样例 #4

### 输入

```
4
1234 567 89 10
```

### 输出

```
4000```

## 样例 #5

### 输入

```
5
19111010 19260817 19371213 19491001 20200110
```

### 输出

```
239635161```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解均采用模拟的思路，按照题目给定的规则从左到右依次计算多个数的和，类似高精度加法，重点处理位数补齐和特殊进位规则。
    - 算法要点：将输入的数转换为适合处理的形式（如字符串、数组等），补齐位数，逐位相加并按规则进位，最后处理前导零并输出结果。
    - 解决难点：特殊进位规则（和小于7不进位，7到13进一位，大于13进两位）的实现以及处理可能产生的前导零。同时，第一个数不能以0开始累加，否则会因进位规则导致结果错误。
    - 整体来看，题解思路清晰，但在代码可读性、优化程度等方面存在差异。

所选的题解：
  - 作者：Remake_ (赞：3)
    - 星级：4星
    - 关键亮点：代码简洁，使用字符串进行高精运算，将加法操作封装成函数，逻辑清晰，注释详细。
    - 重点代码及核心实现思想：
```cpp
string add(string str1,string str2){//加法
    string str;
    int len1=str1.length();//第一个串的长度
    int len2=str2.length();//第二个串的长度
    if(len1<len2){//通过比较大小来增加前导0
        for(int i=1;i<=len2-len1;i++)
           str1="0"+str1;
    }
    else{
        for(int i=1;i<=len1-len2;i++)
           str2="0"+str2;
    }
    len1=str1.length();
    int cf=0;//进位
    int temp;//该位的最终值
    for(int i=len1-1;i>=0;i--){
        temp=str1[i]-'0'+str2[i]-'0'+cf;
        cf=temp/7;//处理进位
        temp%=10;//按要求%10
        str=char(temp+'0')+str;//将其转化为字符
    }
    if(cf!=0)  str=char(cf+'0')+str;
    return str;
}
```
核心实现思想是先补齐两个字符串的长度，然后从后往前逐位相加，按规则处理进位，最后返回相加结果。
  - 作者：do_while_false (赞：3)
    - 星级：4星
    - 关键亮点：代码简洁紧凑，直接在输入的字符串上进行操作，按照题目规则模拟运算过程，处理前导零的方式较为巧妙。
    - 重点代码及核心实现思想：
```cpp
for(int j=now.size()-1;j>0;j--) {
    if(now[j]+add[j]>='7'+'0') now[j-1]++;
    if(now[j]+add[j]>('0'+13+'0')) now[j-1]++;
    now[j]=int(now[j]-'0'+add[j]-'0')%10+'0';//按照题目的要求运算 
}
while(now[0]=='0') now.erase(0,1);//删掉前导零 
```
核心实现思想是对两个字符串从后往前逐位判断和运算，根据特殊进位规则调整前一位，最后处理前导零。
  - 作者：Hexarhy (赞：1)
    - 星级：4星
    - 关键亮点：思路清晰，详细阐述解题思路和实现细节，代码使用C++11特性，将运算过程封装成函数，便于理解和复用。
    - 重点代码及核心实现思想：
```cpp
string calc(string a,string b)
{
    string res;
    const int len=(int)max(a.size(),b.size());
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    for(int i=0;i<len+4;i++)
     res.push_back('0');
    while(a.size()<b.size()) 
     a.push_back('0');
    while(b.size()<a.size())
     b.push_back('0');
    auto ctoi=[=](const char c){return int(c-'0');};
    auto itoc=[=](const int i){return char(i+'0');};
    for(int i=0;i<len;i++)
    {
        const int num=ctoi(a[i])+ctoi(b[i])+ctoi(res[i]);
        if(num>=7 && num<=13)
         res[i+1]='1';
        if(num>13)
         res[i+1]='2';
        res[i]=itoc(num%10);
    }
    for(auto it=res.end()-1;*it=='0';it--)
     res.pop_back();
    reverse(res.begin(),res.end());
    return res;
}
```
核心实现思想是先反转字符串便于逐位运算，补齐长度，定义函数将字符转数字和数字转字符，然后逐位运算并按规则进位，最后处理前导零并反转返回结果。

最优的关键思路或技巧：
    - **封装函数**：将加法操作封装成函数，使代码结构更清晰，便于复用和维护，如Remake_和Hexarhy的题解。
    - **字符串操作**：利用字符串处理大数，方便进行位数补齐、插入和删除操作，多数题解都采用了这种方式。

可拓展之处：同类型题通常涉及对高精度运算的各种变体，如不同的进位规则、不同进制的运算等。类似算法套路是先确定数据存储方式（字符串、数组等），再按照给定规则模拟运算过程，重点关注边界条件和特殊规则的处理。

推荐题目：
    - P1601 A+B Problem（高精），基础的高精度加法练习。
    - P2142 高精度减法，高精度减法运算，与本题类似，需处理借位等特殊情况。
    - P1876 开灯，结合高精度运算和逻辑判断，锻炼综合解题能力。

个人心得摘录与总结：
  - **作者：Vector_**：提到不能从0累加，因为按题意进位规则，一个数加0可能不等于原数，如0 + 7 = 17，强调了对题目特殊规则的注意。同时提到要开好足够的数组位数，因为每次运算都可能进一位，提醒注意边界情况。 

---
处理用时：62.14秒
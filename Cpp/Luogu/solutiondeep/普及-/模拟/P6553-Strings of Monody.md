# 题目信息

# Strings of Monody

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/tcsfyv6l.png)

LGD 是一只喜欢 Monody 的小恐龙。

根据 Monody 的音乐，他建立了一个模型，叫做 赞歌字符串。简称， SoM (String of Monody)。


## 题目描述

赞歌字符串是一个由 $1,4,5$ 组成的字符串。每次操作 LsWn 会拿出左端点为 $l$，右端点为 $r$ 的子串，（注意，第一个字符的下标为 $1$，最后一个字符的下标为 $n$）并把它替换为新的给出的子串。替换之后，你需要回答 $3$ 个对于完整串的问询，分别是：  
1. $1$ 的个数。  
2. 整个字符串每个数位的总和。  
3. 整个字符串每个数位的乘积。

所有输出都要对 $\color{black}998\color{red}24\color{black}353$ 取模。  



## 说明/提示

样例一的解释：  

第一次操作，字符串变为 ```111514``` ，其中 $1$ 的个数为 $4$，和为 $1+1+1+5+1+4=13$，乘积为 $1\times 1\times 1\times 1\times 5\times 1\times 4=20$。   
第二次操作，字符串变为 ```114414```。   
第三次操作，字符串变为 ```114514```。  

---

我们设初始字符串长度为 $n$。  

对于 $10\%$ 的数据，$n\le 10$。   
对于 $40\%$ 的数据，$n\le 1000$。  
对于全部数据，$n\le 10^6, m\le 10^3, 1\le r-l+1\le 10^3$。


## 样例 #1

### 输入

```
114514
3
1 3 111  
3 4 44
4 4 5```

### 输出

```
4 13 20
3 15 64
3 16 80```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效处理字符串替换及后续统计计算展开。由于数据范围限制，暴力求解不可行。多数题解利用字符串仅由1、4、5组成这一特性，通过记录这三个数字的数量来简化计算。对于乘积计算，为避免每次 $O(n)$ 的时间复杂度，常采用预处理幂次或快速幂的方法。

### 所选的题解
- **作者：Ptilopsis_w (5星)**
    - **关键亮点**：思路清晰，代码简洁且注释详细。通过分别记录1、4、5的数量，在修改时维护该数量，并预处理4、5的次幂来优化乘积计算。
    - **个人心得**：提醒注意模数，不要想当然复制粘贴。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define MAXN 1000000
using namespace std;
typedef long long ll;
int m, tot[6], a[MAXN+5];
ll pow4[MAXN+5], pow5[MAXN+5];
const ll mod = 99824353;
int main()
{
    pow4[0] = pow5[0] = 1;
    for(int i = 1; i <= MAXN; i++)
        pow4[i] = (pow4[i-1]*4) % mod, pow5[i] = (pow5[i-1]*5) % mod;
    char ch;
    int cnt = 0;
    while(ch = getchar(), ch!= '\n')
    {
        cnt++;
        a[cnt] = ch-'0';
        tot[a[cnt]]++;
    }
    scanf("%d", &m);
    while(m--)
    {
        int l, r;
        scanf("%d%d", &l, &r);getchar();
        for(int i = l; i <= r; i++)
        {
            int x = getchar()-'0';
            tot[a[i]]--;
            tot[x]++;
            a[i] = x;
        }
        ll sum = (tot[1] + 4*tot[4] + 5*tot[5]) % mod;
        ll p = (pow4[tot[4]] * pow5[tot[5]]) % mod;
        printf("%d %lld %lld\n", tot[1], sum, p);
    }
    return 0;
}
```
核心实现思想：先预处理4、5的幂次，读入初始字符串时统计1、4、5的数量。每次修改时，更新对应数字的数量，进而快速计算出和与乘积。

- **作者：lycx03 (4星)**
    - **关键亮点**：同样利用记录1、4、5数量的方法解决问题，代码简洁易懂。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[1000011],a[1000011];
int n,m,l,r,h[11],mod=99824353,q4[1000011],q5[1000011];
int main()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    scanf("%d",&m);
    for(int i=1;i<=n;i++) h[s[i]-48]++;
    q4[0]=q5[0]=1;
    for(int i=1;i<=1000000;i++) q4[i]=(q4[i-1]*4)%mod,q5[i]=(q5[i-1]*5)%mod;
    while(m--)
    {
        scanf("%d%d%s",&l,&r,a);
        for(int i=l;i<=r;i++) h[s[i]-48]--,h[a[i-l]-48]++,s[i]=a[i-l];
        printf("%d %d %lld\n",h[1],h[1]+h[4]*4+h[5]*5,(long long)(q4[h[4]])*(q5[h[5]])%mod);
    }
    return 0;
}
```
核心实现思想：读入初始字符串统计各数字数量，预处理4、5幂次。每次修改时，更新对应数字数量并计算结果。

### 最优关键思路或技巧
- **利用数字种类有限**：字符串仅由1、4、5组成，通过记录这三个数字的数量，将对整个字符串的操作简化为对三个变量的操作，大大降低了时间复杂度。
- **预处理幂次**：为避免每次计算乘积时的高时间复杂度，预处理4、5的幂次，在每次询问时直接调用，实现 $O(1)$ 的时间复杂度计算乘积。

### 可拓展之处
此类题目通常围绕字符串操作与统计计算，拓展方向可考虑增加数字种类、改变操作类型（如区间合并、拆分等）。类似算法套路是利用数据特性简化问题，对于涉及乘积的计算，常用预处理幂次或快速幂优化。

### 推荐题目
- **P1226 【模板】快速幂||取余运算**：基础的快速幂题目，有助于理解快速幂在取模运算中的应用。
- **P3379 【模板】最近公共祖先（LCA）**：虽然是LCA问题，但在处理过程中也涉及到利用数据结构优化计算，与本题优化思路有相通之处。
- **P1972 [SDOI2009]HH的项链**：字符串与区间统计问题，通过优化算法降低时间复杂度，与本题类似。 

---
处理用时：78.11秒
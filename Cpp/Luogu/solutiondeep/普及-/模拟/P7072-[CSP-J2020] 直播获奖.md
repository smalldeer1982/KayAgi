# 题目信息

# [CSP-J2020] 直播获奖

## 题目描述

NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 $w\%$，即当前排名前 $w\%$ 的选手的最低成绩就是即时的分数线。

更具体地，若当前已评出了 $p$ 个选手的成绩，则当前计划获奖人数为 $\max(1, \lfloor p \times w \%\rfloor)$，其中 $w$ 是获奖百分比，$\lfloor x \rfloor$ 表示对 $x$ 向下取整，$\max(x,y)$ 表示 $x$ 和 $y$ 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。

作为评测组的技术人员，请你帮 CCF 写一个直播程序。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/l453vhow.png)

---
### 数据规模与约定

各测试点的 $n$ 如下表：

| 测试点编号 | $n=$ |
| :--: | :--: |
| $1 \sim 3$ | $10$ |
| $4 \sim 6$ | $500$ |
| $7 \sim 10$ | $2000$ |
| $11 \sim 17$ | $10^4$ |
| $18 \sim 20$ | $10^5$ |


对于所有测试点，每个选手的成绩均为不超过 $600$ 的非负整数，获奖百分比 $w$ 是一个正整数且 $1 \le w \le 99$。

---
### 提示

在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的 `float` 、 `double`，Pascal 中的 `real` 、 `double` 、 `extended` 等）存储获奖比例 $w\%$，则计算 $5 \times 60\%$ 时的结果可能为 $3.000001$，也可能为 $2.999999$，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。

## 样例 #1

### 输入

```
10 60
200 300 400 500 600 600 0 300 200 100
```

### 输出

```
200 300 400 400 400 500 400 400 300 300```

## 样例 #2

### 输入

```
10 30
100 100 600 100 100 100 100 100 100 100```

### 输出

```
100 100 600 600 600 600 100 100 100 100```

# AI分析结果

• 综合分析与结论：该题要求实时计算直播竞赛的获奖分数线。题解主要有以下几种思路：
    - **暴力排序**：每读入一个成绩就进行一次排序，时间复杂度高，得分低，如每读入一个就sort排序一次的方法仅得50pts。
    - **插入排序**：整体做一次插入排序，边读边插入边输出，复杂度为\(O(n^2)\)，神奇通过部分大数据，但并非高效解法，得85pts。
    - **桶排序**：利用分数值域不超过600的特点，开桶记录每个分数的人数，每次从高到低遍历桶统计人数，找到满足计划获奖人数的分数线，时间复杂度\(O(n\times600)\)，能通过所有测试点，多数采用此思路的题解较为简洁清晰。
    - **对顶堆**：用一个大顶堆和一个小顶堆动态维护第K大数，可应对更大数据，时间复杂度\(O(n\log n)\)。
    - **Treap**：利用Treap数据结构在\(O(\log n)\)时间内完成插入和查询排名为k的数，时间复杂度\(O(n\log n)\)，但代码相对复杂。

综合来看，桶排序因利用了分数值域小的特性，实现简单高效；对顶堆虽代码稍复杂，但通用性强可应对更大数据。

以下是评分较高的题解：
  - **作者：AzusagawaKaede（5星）**
    - **关键亮点**：详细分析了错误解法及得分情况，对正确解法对顶堆的原理、操作讲解清晰，代码简洁且有注释，还提及对顶堆适用场景及练手题目。
    - **个人心得**：无
    - **核心代码**：
```c++
#include <bits/stdc++.h>

using namespace std;

priority_queue<int> ma_hp;//大顶堆 
priority_queue<int, vector<int>, greater<int> > mi_hp;//小顶堆 

int n, w, now, num;

void qwq()//调整获奖人数（小顶堆元素个数）
{
	if (mi_hp.size()<now)
	{
		mi_hp.push(ma_hp.top());
		ma_hp.pop();
	} 
	if (mi_hp.size() > now)
	{
		ma_hp.push(mi_hp.top());
		mi_hp.pop();
	}
	
} 

void push(int num)
{
	if (num >= ma_hp.top()) mi_hp.push(num);
		else ma_hp.push(num);
	qwq();
}

int main()
{
	scanf("%d%d", &n, &w);
	ma_hp.push(0);//避免边界判断 
	for (int p = 1; p <= n; p++)
	{
		now=max(1,p*w/100);;//实时获奖人数 
		scanf("%d", &num);
		push(num);
		printf("%d ", mi_hp.top()); 
	}
	return 0;
}
```
核心实现思想：通过大顶堆和小顶堆维护数据，插入元素时根据与大顶堆顶比较决定放入哪个堆，然后通过`qwq`函数调整小顶堆元素个数，使其符合实时获奖人数，最终小顶堆顶即为当前获奖分数线。

  - **作者：Eason_AC（4星）**
    - **关键亮点**：思路清晰，直接阐述桶排序做法，代码简洁明了。
    - **个人心得**：无
    - **核心代码**：
```cpp
int n, w, x, a[607];

int main() {
	scanf("%d%d", &n, &w);
	for(int i = 1; i <= n; ++i) {
		scanf("%d", &x);
		a[x]++;
		int pl = max(1, i * w / 100), num = 0;
		for(int j = 600; j >= 0; --j) {
			num += a[j];
			if(num >= pl) {printf("%d ", j); break;}
		}
	}
	return 0;
}
```
核心实现思想：每次读入成绩放入对应桶，从600到0遍历桶，统计人数，当人数满足计划获奖人数时，输出当前分数。

  - **作者：GZXUEXUE（4星）**
    - **关键亮点**：对桶排序思路阐述清晰，代码注释详细，对变量含义解释明确。
    - **个人心得**：无
    - **核心代码**：
```cpp
# include <iostream>
# include <cmath>
using namespace std;
int a[601]; // a[i]表示该分数段的人数
int main(){
    int n,w,tmp; scanf("%d %d",&n,&w);
    for (int i = 0;i < n;i++){
        cin >> tmp;
        a[tmp]++; // 记录这个人的分数
        // j表示当前分数线，sum表示当前累计获奖人数，sc表示当前计划获奖人数
        int j = 600,sum = 0,sc = max((i + 1) * w / 100,1);
        for (;j >= 0 && sum < sc;j--) sum += a[j];
        cout << ++j << " ";
    }return 0;
}
```
核心实现思想：与Eason_AC类似，读入成绩更新桶，从高分到低分遍历桶统计人数，找到满足计划获奖人数的分数线并输出。

最优关键思路或技巧：利用分数值域小的特点采用桶排序，可高效解决问题；对顶堆能动态维护第K大数，通用性强。

可拓展之处：此类题目属于动态统计问题，类似套路有利用数据结构（如堆、平衡树等）维护数据顺序，或利用数组特性（如桶排序）在特定值域场景下优化。

推荐题目：
  - [P3871 小A的糖果](https://www.luogu.com.cn/problem/P3871)，对顶堆练手题目。
  - [P1168 中位数](https://www.luogu.com.cn/problem/P1168)，考察维护中位数，可使用对顶堆。
  - [P1970 花匠](https://www.luogu.com.cn/problem/P1970)，虽不完全相同，但涉及数据的动态处理与分析。 

---
处理用时：92.35秒
# 题目信息

# 「PMOI-1」立方骑士

## 题目背景

lhm 最近迷上了国际象棋，他对里面的骑士最感兴趣，于是就开辟了下面这个玩法。

## 题目描述

lhm 现在建立了一个大小为 $n \times m$ 的国际象棋棋盘，你作为白方要与黑方作战。棋盘上黑方只有一个国王，**国王位置不会移动**，而 lhm 有无穷无尽的骑士。现在你需要解出，最少派出几个骑士才能将死黑方国王，定义将死的标准为**黑方国王在不被吃掉的情况下不能移动为止**。

更形式化地讲：一个 $n\times m$ 的棋盘上有一个国王，你需要摆放尽可能少的骑士在棋盘上，使得对于每一个国王能走**正好一步**达到的且不在棋盘外的位置，都存在至少一个骑士能走**正好一步**达到。

棋子的移动方法：

国王每一步能向上、下、左、右、左上、右上、左下、右下八个方向移动一格。

骑士与国际象棋规则相同，每次可以走日字（即 $2\times3$ 长方形的对角线，详见样例）。**注意没有蹩马腿规则，也就是只要不走出棋盘且按照日字格行走，其他没有限制。**

lhm 太菜了，只好请聪明的你来帮他完成这个任务。

## 说明/提示

【样例1解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/c5d055nl.png)

一个类似上图的棋盘，$\text{K}$ 表示黑方国王，$\text{N}$ 表示白方骑士，$\color{red}{\times}$ 表示骑士可以到达的地方（其中 $(3,3)$ 的 $\text{N}$ 封住了 $(1,2)$ 和 $(2,1)$，$(1,4)$ 的 $\text{N}$ 封住了 $(2,2)$
，形如上图，$\text{K}$ 已经被封死了，所以两个骑士足矣。可以证明两个骑士是最小个数。

【数据范围】

- 对于 $30\%$ 的数据，保证国王的初始位置一定在棋盘最外面一圈。

- 对于 $100\%$ 的数据满足，$1 \leq t \leq 10$，$1 \leq x,y \leq 10^9$，$8 \leq n,m \leq 10^9$。

## 样例 #1

### 输入

```
1
8 8 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
2
10 9 1 9
999 999 999 2```

### 输出

```
2
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何根据国王在棋盘上的位置，确定最少需要放置的骑士数量来将死国王。大部分题解思路为根据国王位置分为角上、边上、中间三种情况进行讨论，进而得出所需骑士数量。部分题解通过找规律得出答案为$\lceil \frac{x}{2} \rceil$（$x$表示国王身边可到达位置数量），部分题解采用暴力搜索思路。各题解在思路清晰度、代码可读性和优化程度上有所差异。

### 所选的题解
- **作者：樱雪喵 (赞：77)  星级：5星**
    - **关键亮点**：思路清晰，通过对国王三种位置情况分别绘图说明，得出所需骑士数量规律，并给出简洁的分类讨论代码。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,m,n,x,y,ans;
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d%d%d",&m,&n,&x,&y);
        if((x==1&&y==1)||(x==m&&y==n)||(x==1&&y==n)||(x==m&&y==1)) cout<<"2"<<endl;//在角上
        else if(x==1||x==m||y==1||y==n) cout<<"3"<<endl;//在边上
        else cout<<"4"<<endl;//如果都不在就是在中间
    }
    return 0;
}
```
    - **核心实现思想**：根据输入的国王坐标，判断其处于角上、边上还是中间，输出对应所需的骑士数量。
- **作者：_caiji_ (赞：2)  星级：4星**
    - **关键亮点**：从骑士能控制的格子数量出发，统计国王周围需控制的格子数$k$，直接得出答案为$\lceil k\div2\rceil$，思路独特且简洁。
    - **重点代码**：
```cpp
#include <cstdio>
using namespace std;
const int dx[9]={0,-1,-1,-1,0,0,1,1,1},
          dy[9]={0,-1,0,1,-1,1,-1,0,1};//八个方向打表
int T,n,m,x,y,k;
int ceil_(int a,int b){
    if(a%b==0) return a/b;
    else return a/b+1;
}//自己定义一个向上取整的函数
int main(){
    for(scanf("%d",&T);T--;k=0){//for循环可以这样用
        scanf("%d%d%d%d",&n,&m,&x,&y);
        for(int i=1;i<=8;i++){
            int tmpx=x+dx[i],tmpy=y+dy[i];
            if(1<=tmpx&&tmpx<=n&&1<=tmpy&&tmpy<=m) k++;//统计国王周围有多少个不越界的格子
        }
        printf("%d\n",ceil_(k,2));//答案为ceil(k/2)，这里手写
    }
    return 0;
}
```
    - **核心实现思想**：通过打表确定国王八个方向的偏移量，遍历八个方向统计国王周围不越界的格子数$k$，利用自定义向上取整函数得出答案。
- **作者：Lithium_Chestnut (赞：2)  星级：4星**
    - **关键亮点**：作为官方题解，对题意简述清晰，通过对棋盘不同区域找规律得出$\left \lceil stp \div 2 \right \rceil$的通用公式，代码注释详细。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m,x,y,stp;//stp是需要围堵的格数 
int main()
{
    cin>>T;
    for(int i=1;i<=T;i++)
    {
        stp=0;
        cin>>n>>m>>x>>y;
        if((x==1 and y==1) or (x==1 and y==m) or (x==n and y==1) or (x==n and y==m))//角
        {
            stp+=3;//奇数 
            cout<<stp/2+1<<endl;//手动向上取整 
        }
        else if((x==1 and y!=1 and y!=m) or (x==n and y!=1 and y!=m) or (y==1 and x!=1 and x!=n) or (y==m and x!=1 and x!=n))//边
        {
            stp+=5;//奇数
            cout<<stp/2+1<<endl;//手动向上取整
        }
        else//中间
        {
            stp+=8;//偶数
            cout<<stp/2<<endl;//不需要向上取整
        }
    }
    return 0;
}
```
    - **核心实现思想**：根据输入的国王坐标判断其位置，对应不同位置给$stp$赋不同值，根据$stp$值手动向上取整或直接输出结果。

### 最优关键思路或技巧
通过对国王在棋盘上不同位置（角上、边上、中间）进行分类讨论，总结出所需骑士数量规律，如答案为$\lceil \frac{x}{2} \rceil$（$x$表示国王身边可到达位置数量），这种找规律和分类讨论的思维方式是解决本题的关键。

### 可拓展思路
此类题目属于棋盘布局与策略规划类型，类似套路可应用于其他棋子在棋盘上的布局问题，通过分析棋子移动规则和目标条件，进行分类讨论或找规律求解。

### 相似知识点洛谷题目
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：涉及组合数计算与条件判断，与本题分类讨论思想类似。
- [P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)：考察组合相关知识，与本题对不同情况分析处理思路有相通之处。
- [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)：典型的棋盘布局问题，通过搜索和条件判断求解，与本题基于棋盘的策略规划类似。

### 个人心得摘录与总结
无明显个人心得相关内容。 

---
处理用时：65.06秒
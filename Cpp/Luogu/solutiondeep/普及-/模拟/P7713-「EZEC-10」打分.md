# 题目信息

# 「EZEC-10」打分

## 题目背景

**为防止评测机被卡，本题时限为 100 ms。**

## 题目描述

小 A 去参加奥运会。

奥运会中共有 $n$ 名裁判，分别给小 A 打分 $a_1,a_2,\ldots,a_n$。

小 A 对自己的得分不满意，于是他将某名裁判打出的分数加 $1$，称为一次操作。

但是小 A 不能太贪心，他最多只能进行 $m$ 次操作。

小 A 的最终得分为：所有得分中，去掉一个最高分和一个最低分后的平均值。

小 A 想知道，他的最终得分最高为多少。

## 说明/提示

**【样例 1 解释】**

一种可行的方案为：$[1,2,3]\to [3,2,3]$。

**【样例 2 解释】**

一种可行的方案为：$[1,2,2,3]\to [2,3,3,3]$。

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（5 points）：$m=0$。
- Subtask 2（10 points）：$n=3$。
- Subtask 3（15 points）：$n,m\le 10^3$。
- Subtask 4（70 points）：无特殊限制。

对于 $100\%$ 的数据，$3\le n\le 10^5$，$0\le m,a_i\le 10^9$。

## 样例 #1

### 输入

```
3 2
1 2 3```

### 输出

```
3```

## 样例 #2

### 输入

```
4 3
1 2 2 3```

### 输出

```
6```

# AI分析结果

• 综合分析与结论：
    - 思路：各题解均采用贪心策略。先对分数排序，因给最低分加分对最终得分无贡献，故不考虑最低分。重点关注如何将操作次数 \(m\) 分配给除最低分之外的分数，使去掉最高分和最低分后的平均值最大。
    - 算法要点：计算将除最低分和最高分之外的分数提升至最高分所需的操作次数，与给定的 \(m\) 进行比较，分情况讨论操作次数的分配方式。
    - 解决难点：合理分配操作次数 \(m\)，既要保证不改变最高分和最低分的相对位置，又要使中间 \(n - 2\) 个分数总和最大。

    各题解质量相近，思路清晰，代码实现也较常规，多数题解未在代码优化上着墨。综合来看，没有特别突出达到5星的题解，以下选取3条相对较好（4星）的题解。

  - **作者：zplqwq (赞：46) - 4星**
    - **关键亮点**：从部分分入手，逐步引导出正解思路。正解通过贪心策略，先升序排序，明确给最小分数加分无意义，然后在 \(a_2 - a_{n - 1}\) 范围内加分，直到这些分数等于 \(a_n\)，之后再均匀分配剩余操作次数，思路清晰。
  - **作者：Maxmilite (赞：19) - 4星**
    - **关键亮点**：从 \(m\) 分的分配问题出发，分析加分到不同分数上对最终平均分的影响，提出优先给非最高分加分，若能将非最高分都加到最高分，则再平均分配剩余分数的策略，且通过比较总原始分加上 \(m\) 和最高分 \(\times n - 2\) 的关系，避免浮点数计算，提高精度。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

#define int unsigned long long

int a[100005];

signed main()
{
    int n, m;
    scanf("%llu%llu", &n, &m);
    for (int i(1); i <= n; ++i)
        scanf("%llu", a + i);
    sort(a + 1, a + n + 1);
    long long cur = 0;
    for (int i(2); i <= n - 1; ++i)
        cur += a[i];
    if (cur + m < (n - 2) * a[n])
        printf("%llu\n", (cur + m));
    else
        printf("%llu\n", (cur + m + a[n])  * (n - 2) / (n - 1));
    return 0;
}
```
    - **核心实现思想**：先排序，计算除最高最低分之外的分数总和 `cur`，通过比较 `cur + m` 与 `(n - 2) * a[n]` 判断是否能将非最高分都加到最高分，然后按不同情况计算最终得分。

  - **作者：YYen (赞：6) - 4星**
    - **关键亮点**：通过具体例子定性说明贪心思路，易于理解。算法步骤清晰，先排序，然后将 \(a_2\) 到 \(a_{n - 1}\) 的分数调整到与 \(a_n\) 相等，若操作次数有剩余，再逆序逐个给 \(a_n\) 到 \(a_2\) 加分，最后累加 \(a_2\) 到 \(a_{n - 1}\) 的分数得到答案。
    - **核心代码**：
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

long long a[100005]; 

int main()
{
    long long n, m;
    scanf("%lld%lld", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    sort(a + 1, a + n + 1);
    long long diff = 0;
    for (int i = 2; i <= n - 1; i++)
        diff += a[n] - a[i];
    if (m <= diff)
    {
        long long ans = 0;
        for (int i = 2; i <= n - 1; i++) ans += a[i];
        cout << ans + m << endl;
    }
    else
    {
        m -= diff;
        long long ans = a[n] * (n - 2);
        if (m / (n - 1))
        {
            ans += m / (n - 1) * (n - 2);
            m -= m / (n - 1) * (n - 1);
        }
        if (m >= 2) ans += m - 1;
        cout << ans << endl;
    }
    return 0;
}
```
    - **核心实现思想**：排序后计算 \(a_2\) 到 \(a_{n - 1}\) 与 \(a_n\) 的差值总和 `diff`，根据 `m` 与 `diff` 的关系分情况处理，若 `m <= diff` 直接加到 \(a_2\) 到 \(a_{n - 1}\) 上，若 `m > diff` 先将 \(a_2\) 到 \(a_{n - 1}\) 调整到与 \(a_n\) 相同，再处理剩余操作次数。

• 最优关键思路或技巧：利用贪心策略，明确给最低分加分无意义，重点考虑将操作次数分配给中间分数，通过计算将中间分数提升至最高分所需操作次数，并与给定操作次数比较，分情况合理分配剩余操作次数，以达到最终得分最大。

• 可拓展之处：此类题目属于贪心策略在分数处理场景下的应用，类似套路可应用于资源分配、任务调度等场景的题目中，关键在于找到明确的贪心策略，即每次操作都选择当前最优解，且能证明最终结果最优。

• 相似知识点洛谷题目：
    - [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：通过合理分组，运用贪心策略解决问题。
    - [P1181 数列分段 Section I](https://www.luogu.com.cn/problem/P1181)：利用贪心思想对数列进行分段。
    - [P2859 [USACO06DEC]Milk Patterns G](https://www.luogu.com.cn/problem/P2859)：同样是基于贪心策略的字符串相关问题。

• 个人心得：题解中未包含个人心得。 

---
处理用时：63.33秒
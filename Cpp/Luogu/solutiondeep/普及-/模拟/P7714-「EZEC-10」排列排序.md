# 题目信息

# 「EZEC-10」排列排序

## 题目描述

给你一个长度为 $n$ 的排列 $p_1,p_2, \cdots ,p_n$。你需要把它排序。

每次可以花区间长度，即 $r-l+1$ 的代价，选择排列中的任意一段区间 $[l,r]$，并将 $[l,r]$ 从小到大排序。

现在你可以让他进行若干次这个操作，直到 $p$ 中元素的值从 $1$ 到 $n$ 按升序排序，即对于 $1$ 到 $n$ 的每一个 $i$，都有 $p_i=i$。

求问花的代价最少为多少？

## 说明/提示

【样例 $1$ 说明】

对于第一组数据，可选择区间 $[2,3]$ 进行排序。

对于第二组数据，可选择区间 $[1,3]$ 进行排序。

【数据规模与约定】

对于 $20\%$ 的数据，$n\leq 4$。

对于另 $30\%$ 的数据，$\sum n\leq5000$。

对于另 $10\%$ 的数据，$p_1=n$。

对于 $100\%$ 的数据，$1\le T,\sum n\le 10^6$。

## 样例 #1

### 输入

```
2
3
1 3 2
4
3 2 1 4```

### 输出

```
2
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何以最小代价将给定排列排序这一核心问题，采用了贪心、双指针、标记判断等不同思路。思路上，有的通过双指针寻找需排序区间，有的利用贪心策略直接判断区间是否需排序，还有通过标记判断每个位置是否需参与排序。算法要点包括指针移动、区间判断、标记数组使用等。解决难点在于如何准确找到最小代价的排序区间，不同解法从不同角度给出答案。

### 所选的题解
#### 作者：YYen (5星)
- **关键亮点**：思路清晰，采用双指针法，时间复杂度为\(O(n)\)，高效且代码简洁易懂。
- **核心代码**：
```cpp
while (i <= n)
{
    if (a[i] == i) // 相同 
        i++;
    else // 不同 
    {
        int maxv = a[i];
        int j = i + 1;
        maxv = max(maxv, a[j]);
        while (maxv > j)
        {
            j++;
            maxv = max(maxv, a[j]);
        }
        ans += j - i + 1;
        i = j + 1;
    }
}
```
**核心实现思想**：从左往右枚举元素，若元素值与下标相同则跳过，不同则以当前下标为左指针\(i\)，下一位为右指针\(j\)开始寻找排序区间，用\(maxv\)维护区间最大值，当右指针\(j\)指向的下标大于等于区间最大值时确定排序区间，更新左指针\(i\)，重复操作。

#### 作者：Eason_AC (4星)
- **关键亮点**：贪心策略直观，通过前缀区间最大值判断当前区间是否为\(l\sim r\)的排列，进而确定是否排序，代码简洁。
- **核心代码**：
```cpp
F(int, i, 1, n) {
    p[i] = Rint, maxi = max(maxi, p[i]);
    if(maxi == i) ans += (i - l + 1!= 1) * (i - l + 1), l = i + 1; 
}
```
**核心实现思想**：输入时维护前缀区间\([1,i]\)中的最大值\(maxi\)，若\(maxi == i\)，说明区间\([l,i]\)是\(l\sim i\)的排列，若区间长度不为\(1\)则计入代价并更新下一个需判断区间的左端点\(l\)。

#### 作者：__gcd (4星)
- **关键亮点**：通过引理证明单点贡献情况，从前往后和从后往前扫描确定每个位置是否有贡献，思路巧妙，时间复杂度\(O(n)\)。
- **核心代码**：
```cpp
for(int i = 1, mx = 0; i <= n; i++) {
    mx = max(mx, a[i]);
    if(mx > i)vis[i] = 1;
}
for(int i = n, mn = n + 1; i; i--) {
    mn = min(mn, a[i]);
    if(mn < i)vis[i] = 1;
}
int ans = 0;
for(int i = 1; i <= n; i++)ans += vis[i];
```
**核心实现思想**：先从前向后遍历，用\(mx\)维护当前最大值，若\(mx > i\)，标记位置\(i\)；再从后向前遍历，用\(mn\)维护当前最小值，若\(mn < i\)，标记位置\(i\)，最后统计标记位置数量得到答案。

### 最优关键思路或技巧
1. **双指针技巧**：如YYen的题解，通过双指针确定排序区间，高效且直观，能有效降低时间复杂度。
2. **贪心策略**：像Eason_AC的题解，直接判断区间是否为特定排列并排序，以达到最小代价，贪心策略在这类优化问题中常能找到高效解法。
3. **引理证明与扫描**：__gcd通过证明引理确定单点贡献条件，再通过两次扫描标记需贡献位置，逻辑严谨。

### 可拓展之处
此类题目属于序列排序优化问题，相似算法套路可应用于其他需通过选择特定区间操作来优化目标值的题目，如区间合并、序列调整等。

### 洛谷相似题目
1. P1803 凌乱的yyy / 线段覆盖：涉及区间选择与优化问题。
2. P1080 国王游戏：通过合理排序解决最优值问题，与本题优化思路类似。
3. P2123 皇后游戏：同样是通过合理策略优化目标值，可锻炼贪心策略运用能力。

### 个人心得摘录与总结
1. **Maxmilite**：提到在多测且数据规模小的情况下，用 `memset` 初始化标记数组会耗费大量时间，可使用测试组数编号标记元素以节省时间。总结为在处理多组小规模数据时，注意初始化方式对时间复杂度的影响，选择更高效的初始化方法。 

---
处理用时：47.24秒
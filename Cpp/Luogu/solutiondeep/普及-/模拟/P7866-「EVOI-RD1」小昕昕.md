# 题目信息

# 「EVOI-RD1」小昕昕

## 题目背景

一副扑克牌共有 $54$ 张牌，除去大小王后有 $52$ 张。在同一副牌中，一张牌只可能出现一次。

一副扑克牌中一共有四种花色：黑桃($\texttt{spade}$)、红桃($\texttt{heart}$)、梅花($\texttt{club}$)、方块($\texttt{diamond}$)。每个花色的牌共有 $13$ 张，分别为 $\texttt{A} \sim \texttt{K}$。

在题目中，以上四种花色分别以 $\texttt{S,H,C,D}$ 表示。

我们约定，任何一张牌，都以 **花色+点数** 表示，并且约定用 $\texttt{T}$ 表示 $\texttt{10}$，如 $\texttt{SA,D5,HT,CQ}$。

## 题目描述

昕昕手上有 **两副无大小王** 的扑克牌，她会从这些扑克牌里取出 $n$ 张牌。

昕昕创造了一个组合为 **“小昕昕”**，它的定义是，任意取出 $3$ 张牌，若这 $3$ 张牌的 **牌点一样** ，且花色有且仅有 **两种** ，则称为一对“小昕昕”。如 $\texttt{H3,S3,S3}$ 是一对“小昕昕”。

当这三张扑克牌组成 **“小昕昕”** 后，昕昕就会把它们从牌堆内拿出，**不可再次使用**。

现在，昕昕想让你帮她数数，这副牌里最多能组成多少对 **“小昕昕”**。

## 说明/提示

**本题采用捆绑测试。**

+ $\texttt{Subtask 1 (10 pts)}$ ：$1 \le n \le 3$。
+ $\texttt{Subtask 2 (20 pts)}$ ：$1 \le n \le 5$。
+ $\texttt{Subtask 3 (30 pts)}$ ：$1 \le n \le 20$。
+ $\texttt{Subtask 4 (10 pts)}$ ：$1 \le n \le 70$。
+ $\texttt{Subtask 5 (30 pts)}$ ：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 104$，保证输入的牌都存在于两副无大小王的扑克牌中。

## 样例 #1

### 输入

```
3
S3
H3
S3```

### 输出

```
1```

## 样例 #2

### 输入

```
7
ST
ST
HT
HT
CT
CT
DT```

### 输出

```
2```

## 样例 #3

### 输入

```
6
DA
HA
D4
C5
DA
D4```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何统计给定牌中能组成“小昕昕”组合（三张牌点相同且花色仅有两种的组合）的最大数量。思路上大多基于桶排思想，结合贪心策略或找规律来解决问题。
1. **思路与算法要点**：
    - **贪心 + 桶排**：用桶记录每种花色和牌点的牌数，贪心策略为优先用牌最少的花色与牌最多的花色配对组成“小昕昕”。例如，对于某牌点，若有花色牌数为1和2，则优先配对；若都是2，则拆开一个花色与另一个配对。
    - **桶排 + 找规律**：通过分析不同牌点数下能组成“小昕昕”的对数规律，结合桶排记录牌数，无视花色先统计牌点数量，再根据花色情况判断。如牌点数为5时最多1对，6及以上时最多2对，3 - 4张时根据花色数量判断。
    - **基于牌数讨论**：利用`map`记录牌的出现次数，按同一点数牌的张数讨论，张数大于等于6可组成2对，3 - 5张且有两张花色相同可组成1对，小于3张不能组成。
2. **解决难点**：核心难点在于如何高效地组合牌以得到最多的“小昕昕”对数。不同解法通过贪心策略、找规律以及对牌数的分类讨论来解决。
3. **评分**：
    - **昒昕的做法1**：思路清晰，代码实现直接体现贪心与桶排结合，可读性较好，优化程度高，得5星。
    - **昒昕的做法2**：通过找规律简化判断过程，思路巧妙，但代码中部分逻辑稍显隐晦，可读性略逊于做法1，得4星。
    - **369Pai的题解**：利用`map`简化字母与数字转化，代码简洁，对牌数分类讨论清晰，得4星。

### 所选题解
1. **昒昕的做法1（5星）**
    - **关键亮点**：清晰展示贪心 + 桶排思路，先通过函数将花色和牌点数字化存入桶中，然后两轮循环遍历桶，依据贪心策略配对“小昕昕”。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <cstdio>

int poke[6][21];
int ans;

int change_color(char p) {
    switch (p) {
        case 'S': return 1;
        case 'H': return 2;
        case 'C': return 3;
        case 'D': return 4;
    }
}
int change_num(char p) {
    switch (p) {
        case 'A': return 1;
        case 'T': return 10;
        case 'J': return 11;
        case 'Q': return 12;
        case 'K': return 13;
        default: return int(p-'0');
    }
}
int main() {
    int n;
    char c,num;
    scanf("%d",&n);
    for (int i=1;i<=n;i++) {
        scanf(" %c%c",&c,&num); 
        poke[change_color(c)][change_num(num)]++; 
    }
    for (int i=1;i<=13;i++) 
        for (int j=1;j<=4;j++) 
            for (int k=1;k<=4;k++) 
                if (poke[j][i]==2&&poke[k][i]==1&&j!=k) { 
                    poke[j][i]=0;
                    poke[k][i]=0;
                    ans++;
                }

    for (int i=1;i<=13;i++)
        for (int j=1;j<=4;j++)
            for (int k=1;k<=4;k++)
                if (poke[j][i]==2&&poke[k][i]!=0&&j!=k) { 
                    poke[j][i]=0;
                    poke[k][i]--;
                    ans++;
                }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心实现思想**：首先将输入的牌通过`change_color`和`change_num`函数转化为数组下标并记录在`poke`桶数组中。第一轮三重循环查找花色牌数为2和1的组合，组成“小昕昕”并更新桶数组和答案。第二轮循环处理花色牌数都为2的情况，拆开一个花色组成“小昕昕”。
2. **昒昕的做法2（4星）**
    - **关键亮点**：先无视花色找不同牌点数下“小昕昕”对数规律，再结合花色情况判断，减少判断复杂度。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

int change_num(char p) {
    switch (p) {
        case 'A': return 1;
        case 'T': return 10;
        case 'J': return 11;
        case 'Q': return 12;
        case 'K': return 13;
        default: return int(p-'0');
    }
}

int n,ans;
set <char> color[14];
int cnt[14]; 

int main() {
    char a,b;
    scanf("%d",&n);
    for (int i=1;i<=n;i++) {
        scanf(" %c%c",&a,&b);
        int t=change_num(b);
        cnt[t]++; 
        color[t].insert(a); 
    }
    for (int i=1;i<=13;i++) {
        if (cnt[i]==5) ans++; 
        else if (cnt[i]>=6) ans+=2; 
        else if (cnt[i]>=3&&cnt[i]<=4&&(int)color[i].size()!=cnt[i]) ans++; 
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心实现思想**：通过`change_num`函数将牌点数字化，用`cnt`数组记录各牌点数量，`color`集合记录花色。遍历输入牌更新数组和集合。最后根据不同牌点数量及花色情况统计“小昕昕”对数。
3. **369Pai的题解（4星）**
    - **关键亮点**：使用`map<char, map<char, int>>`直接记录牌的出现次数，避免字母与数字转化的繁琐过程，对牌数分类讨论简洁明了。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<map>
using namespace std;
map<char, map<char, int>> m;
int main()
{
    int n, ans = 0;
    cin >> n;
    for(int i = 1 ; i <= n ; i++)
    {
        string str;
        cin >> str;
        m[str[1]][str[0]]++;
    }
    for(auto i:m)
    {
        int sum = 0, cnt2 = 0;
        for(auto j:i.second)
        {
            sum += j.second;
            if(j.second == 2)cnt2++;
        }
        if(sum >= 6)
        {
            ans += 2;
        }
        else if(sum >= 3 && cnt2)
        {
            ans += 1;
        }
    }
    cout << ans;
    return 0;
}
```
    - **核心实现思想**：利用`map`嵌套结构，外层`map`键为牌点，内层`map`键为花色，值为该花色该牌点的牌数。遍历输入更新`map`。再遍历`map`，统计同一点数牌的总数`sum`和花色牌数为2的数量`cnt2`，根据分类讨论得出“小昕昕”对数。

### 最优关键思路或技巧
1. **数据结构**：使用二维数组（桶）或`map`嵌套结构记录牌的花色和牌点信息，方便后续统计和处理。
2. **算法优化**：采用贪心策略，优先用牌最少的花色与牌最多的花色配对，能高效得到最多“小昕昕”对数；或者通过找规律，减少对每种花色具体情况的判断，简化算法流程。
3. **思维方式**：将问题按牌点分类，分别考虑每个牌点能组成“小昕昕”的情况，降低问题复杂度。

### 可拓展之处
同类型题或类似算法套路：此类题目属于组合计数问题，通常涉及对给定元素的特定组合方式进行统计。类似套路包括先分析问题特点找规律，利用合适的数据结构存储数据，再结合贪心、枚举等策略解决问题。例如，在一些物品分组问题中，根据物品的不同属性（类似牌的花色和点数）进行分组，满足特定组合条件（类似“小昕昕”的定义）的数量统计。

### 推荐题目
1. **P1036 [NOIP2002 普及组] 选数**：通过枚举和判断，从给定数字中选取特定数量数字，使其和为质数，考察组合枚举和数论知识。
2. **P1157 组合的输出**：要求按照字典序输出从n个元素中取r个元素的所有组合，锻炼组合生成和字典序输出的能力。
3. **P2241 统计方形（数据加强版）**：在给定的矩形网格中统计不同大小的正方形和长方形数量，需要运用数学规律和枚举统计的方法。

### 个人心得摘录与总结
1. **huangmingyi**：一开始尝试用结构体和排序解决问题，但错在按输入顺序拆牌，未考虑优先拆牌最少的花色与牌最多的花色配对。看题解后明白应采用贪心策略。总结为在解决此类组合问题时，要深入分析题目要求，找到最优的组合策略，不能仅按常规思路简单处理。 

---
处理用时：97.85秒
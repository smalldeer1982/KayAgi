# 题目信息

# 「DTOI-2」星之灵

## 题目背景

### 小提醒

- 注意 $\texttt{CapsLock}$ 的大小写。

## 题目描述

### 简要题意

重复输入 $n$ 个字符串，其中：

- 当输入的字符串为 $\texttt{CapsLock}$ 时，在此之后的字符串大小写互换，直到下一个 $\texttt{CapsLock}$ 出现；
- 给定 $q$ 组询问，每次询问第 $x$ 个不为 $\texttt{CapsLock}$ 的字符串。

### 原题面

星之灵可以对你说 $n$ 句话，你需要对其做记录。

每句话可能是一个不等于 $\texttt{CapsLock}$ 的字符串，也可以是一个命令 $\texttt{CapsLock}$，其作用是控制星之灵说出的所有字母的大小写，当说出一次 $\texttt{CapsLock}$ 时，之后说出的所有小写字母均需变为大写，大写字母均需变为小写，第二次说出 $\texttt{CapsLock}$ 时又变为正常，以此类推。特别地，对于星之灵说出的 $\texttt{CapsLock}$ 命令，你无须记录。

星之灵将会不断重复说出这 $n$ 句话，且不改变顺序，而且他有 $q$ 次询问，每次询问都请你告诉星之灵，你记录的第 $x$ 句话是什么。

## 说明/提示

### 样例 #1 解释

前四次记录的语句分别为：$a,b,A,B$。

### 数据范围

| $\textbf{Subtask}$ | $n,q \le$ | $x\le $ | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $10$ | $100$ | $A$ | $30$ |
| $2$ | $10^4$ | $10^5$ | / | $30$ |
| $3$ | $10^5$ | $10^{18}$ | / | $40$ |

对于所有数据，$1 \leq n,q \leq 10^5,1 \leq x \leq 10^{18}$

性质 $A$：输入字符串中不存在 $\texttt{CapsLock}$。

### 数据保证

- 所有语句中至少包含一个不为 $\texttt{CapsLock}$ 的字符串；
- 所有输入的字符串长度不大于 $10$；
- 所有输入的字符串不为空且仅包含大小写字母。

## 样例 #1

### 输入

```
5
CapsLock CapsLock a CapsLock B
4
1
2
3
4```

### 输出

```
a
b
A
B```

## 样例 #2

### 输入

```
7
h W CapsLock I CapsLock j CapsLock
8
7
9
13
45
20
28
50
101```

### 输出

```
I
h
H
H
j
j
W
H```

## 样例 #3

### 输入

```
10
Oh P CapsLock CapsLock CapsLock Cv Ts CapsLock XU AR 
10
84
63
414
149
25
61
50
4043
9111
47```

### 输出

```
AR
cV
AR
XU
Oh
Oh
P
XU
cV
XU```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是利用输入数据的周期性来避免暴力求解。由于 $x$ 取值较大，直接暴力模拟会超时，因此需找到循环规律。各题解的不同之处主要在于寻找和利用周期的方式，以及处理字符串大小写转换的方法。

1. **思路**：
    - **刘辰雨**：将输入读入两遍，保证 “CapsLock” 数量为偶数，创造规律，根据 “CapsLock” 个数的奇偶性来决定字符串大小写是否转换。
    - **Kreedy_Ke**：通过分析样例，总结出以非 “CapsLock” 字符串个数的 $2$ 倍为循环节的规律，预处理出循环节内的所有字符串。
    - **zt17**：通过判断输入字符串是否为 “CapsLock” 来改变全局变量 $m$，进而对正常字符串的字符进行大小写转换，最后按要求输出。但代码中对循环节的处理可能有误，直接对 $n$ 取模不准确。
    - **ImposterAnYu**：通过记录每个非 “CapsLock” 单词前 “CapsLock” 个数的奇偶性，结合循环节规律来判断单词输出时是否需大小写反转。
    - **cyhtxdy**：重复模拟输入过程 $20$ 次，存储结果，利用周期性直接对查询值取模输出，属于较为暴力的模拟方法，但能保证在数据范围内不超时。
    - **sylqwq**：维护周期内 “CapsLock” 和正常字符串的数量，以及每个正常字符串前 “CapsLock” 的个数，根据查询值计算出对应字符串及 “CapsLock” 个数，依奇偶性决定是否翻转大小写。
    - **what_can_I_do**：先转换需改变大小写的字符串，若 “CapsLock” 个数为奇数，则在字符串后添加一个转换大小写后的原字符串，构成循环节，再用查询值对单词数量取模输出。
    - **wdgm4**：认为操作周期为 $2$，将输入处理两遍，对查询值取余记录数长度输出。但周期理解可能不准确，应是与非 “CapsLock” 字符串个数有关。
    - **Wind_Smiled**：记录非 “CapsLock” 字符串及前面 “CapsLock” 的个数，根据查询值计算扫描轮数和剩余个数，判断 “CapsLock” 总数的奇偶性决定是否转换大小写输出。
2. **算法要点**：多数题解通过读入数据，识别 “CapsLock” 并改变后续字符串大小写，同时寻找循环节规律。在询问时，利用取模运算找到对应循环节内的字符串输出。
3. **解决难点**：主要难点是处理 “CapsLock” 对字符串大小写的影响以及应对大数据范围下的查询。各题解通过找规律、预处理数据、利用周期性等方法来解决。

综合来看，刘辰雨和Kreedy_Ke的题解思路清晰，代码实现简洁明了，对周期规律的利用较好；ImposterAnYu的题解虽然代码稍复杂，但对规律的分析较为细致。这三篇题解质量相对较高。

### 所选的题解
1. **作者：刘辰雨 (4星)**
    - **关键亮点**：巧妙地将输入读入两边，使 “CapsLock” 数量为偶数，从而创造出规律，简化了对大小写转换的判断。
    - **核心代码片段**：
```cpp
string change_back(string s,bool flag)
{
    if(flag == false)
        return s;
    else
    {
        for(int i = 0 ; i< s.length() ; i++)
        {
            if('a'<= s[i] && s[i] <= 'z')
                s[i] = s[i]-'a'+'A';
            else
                s[i] = s[i]-'A'+'a';
        }
        return s;
    }
}
int main()
{
    scanf("%d",&n);
    for(int i = 1 ; i<= n ; i++)
    {
        cin>>s_now;
        if(s_now == "CapsLock")
            flag =!flag;
        else
        {
            a.push_back(change_back(s_now,flag));
        }
    }
    long long u = a.size();
    if(flag == true)
    {
        for(long long i = 0 ; i< u ; i++)
        {
            a.push_back(change_back(a[i],true));
        }
    }
    long long tot = a.size();
    scanf("%d",&q);
    while(q--)
    {
        scanf("%lld",&x);
        if(x <= tot)
            cout<<a[x-1]<<'\n';
        else
        {
            x %= tot;
            if(x == 0)
                x = tot;
            cout<<a[x-1]<<'\n';
        }
    }
    return 0;
}
```
    - **核心实现思想**：`change_back` 函数根据标志位 `flag` 决定是否对字符串进行大小写转换。在 `main` 函数中，读入字符串，遇到 “CapsLock” 改变标志位，非 “CapsLock” 字符串则按标志位转换后存入数组。若最后标志位为真，说明 “CapsLock” 个数为奇数，再将已处理的数组按标志位转换后追加到数组末尾，形成循环节。询问时对查询值取模输出对应字符串。

2. **作者：Kreedy_Ke (4星)**
    - **关键亮点**：通过对样例的深入分析，总结出以非 “CapsLock” 字符串个数的 $2$ 倍为循环节的通用规律，预处理循环节内所有字符串，思路清晰。
    - **核心代码片段**：
```cpp
string Change ( string x ) //改变整句话的大小写
{
    int len=x.size();
    for ( int i=0 ; i<len ; i++ )
        if ( x[i]>='a' && x[i]<='z' )
            x[i]=toupper(x[i]);
        else x[i]=tolower(x[i]);
    return x;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin>>n; bool wy=0;
    for ( int i=1 ; i<=n ; i++,cnt++ )
    {
        cin>>orig[i]; //原输入的所有字符串
        if ( orig[i]==S ) wy=!wy,cnt--; //改变大小写
        else if (!wy ) s[cnt]=orig[i];
        else s[cnt]=Change(orig[i]);
    }
    for ( int i=1 ; i<=n ; i++,cnt++ ) //重复处理一次
        if ( orig[i]==S ) wy=!wy,cnt--;
        else if (!wy ) s[cnt]=orig[i];
        else s[cnt]=Change(orig[i]);
    cin>>q; cnt--;
    while ( q-- )
    {
        long long t; cin>>t; t=t%cnt;
        if ( t ) cout<<s[t]<<"\n";
        else cout<<s[cnt]<<"\n";
    }
    return 0;
}
```
    - **核心实现思想**：`Change` 函数用于转换字符串大小写。在 `main` 函数中，读入字符串，遇到 “CapsLock” 改变标志位，非 “CapsLock” 字符串根据标志位决定是否转换大小写后存入数组。然后重复处理一次输入，形成循环节。询问时对查询值取模输出对应字符串。

3. **作者：ImposterAnYu (4星)**
    - **关键亮点**：细致地分析出每个非 “CapsLock” 单词输出时大小写是否反转与该单词前 “CapsLock” 个数奇偶性的关系，通过记录这些奇偶性信息来准确判断输出字符串。
    - **核心代码片段**：
```cpp
int main(){
    n = read();
    for(i = 1; i <= n; i++){
        scanf("%s",ch + 1);
        l[0] = strlen(ch + 1);
        for(j = 1; j <= 8; j++){
            if(ch[j]!= mo[j]){
                break;
            }
        }
        if(l[0] == 8 && j > 8){//如果这个单词是 CapsLock，
            w ^= 1,e++;//奇偶性反转（w 是 n 个单词里 CapsLock 个数的奇偶性，e 是 n 个单词里 CapsLock 的个数）。
        }else{
            s[++m] = w,l[m] = l[0];//m 是 n 个单词内不为 CapsLock 的单词个数。
            for(j = 1; j <= l[0]; j++){
                a[m][j] = ch[j],fa[m][j] = (ch[j] >= 'A' && ch[j] <= 'Z'? ch[j] + 'a' - 'A' : ch[j] + 'A' - 'a');//fa[i] 是 a[i] 大小写反转后的字符串。
            }
        }
    }
    q = read();
    while(q--){
        x = read(),y = (x - 1) % m + 1;//y 表示第 x 个不为 CapsLock 的单词是 m 个单词里的第几个。
        if(!e){//如果没有任何 CapsLock，
            for(i = 1; i <= l[y]; i++){//直接输出原串。
                putchar(a[y][i]);
            }
            putchar('\n');
        }else{
            x = (x - 1) / m;//x 变为在 m 个单词里循环的次数。
            if((x * w + s[y]) & 1){//如果第 x 个单词之前有奇数个 CapsLock，
                for(i = 1; i <= l[y]; i++){//输出大小写反转之后的字符串。
                    putchar(fa[y][i]);
                }
                putchar('\n');
            }else{//否则，
                for(i = 1; i <= l[y]; i++){//直接输出原串。
                    putchar(a[y][i]);
                }
                putchar('\n');
            }
        }
    }
    return 0;
}
```
    - **核心实现思想**：读入字符串，判断是否为 “CapsLock”，若是则反转奇偶标志位并计数；若非则记录该单词前 “CapsLock” 的奇偶性，同时存储原单词及其大小写反转后的单词。询问时，计算出该单词在循环节内的位置，结合循环次数和之前记录的奇偶性信息，判断是否输出大小写反转后的单词。

### 最优关键思路或技巧
这些题解中最优的关键思路是利用输入数据的周期性来解决大数据范围下的查询问题。通过分析 “CapsLock” 对字符串大小写的影响规律，找到循环节（如以非 “CapsLock” 字符串个数的 $2$ 倍为循环节），预处理数据并在询问时利用取模运算快速定位到对应字符串，避免了暴力模拟带来的超时问题。

### 可拓展之处
同类型题或类似算法套路：此类题目属于字符串模拟与周期性规律结合的问题。类似套路可应用于其他涉及状态切换和周期性操作的字符串问题，例如根据特定指令改变字符串状态，且操作具有循环特性的题目。解题时关键在于找出状态变化规律和循环节，通过预处理和取模运算高效解决查询问题。

### 推荐题目
1. **P1908 逆序对**：通过归并排序统计逆序对数量，涉及数组操作和算法优化，与本题处理大规模数据时避免暴力的思路类似。
2. **P3370 【模板】字符串哈希**：字符串处理相关题目，通过哈希算法高效解决字符串匹配等问题，与本题处理字符串的场景类似，可锻炼字符串处理技巧。
3. **P2671 [NOIP2015 普及组] 求和**：需要找出数列中的规律，通过预处理和数学推导优化计算过程，与本题寻找输入数据规律以优化查询的思路一致。 

---
处理用时：125.50秒
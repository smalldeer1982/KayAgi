# 题目信息

# [蓝桥杯 2019 省 AB] 完全二叉树的权值

## 题目描述

给定一棵包含 $N$ 个节点的完全二叉树，树上每个节点都有一个权值，按从上到下、从左到右的顺序依次是 $A_1,A_2, \cdots A_N$，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/lq1cyfst.png)

现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。

注：根的深度是 $1$。

## 说明/提示

对于所有评测用例，$1 \le N \le 10^5$，$0 \le |A_i| \le 10^5$。

蓝桥杯 2019 省赛 A 组 F 题（B 组 G 题）。

## 样例 #1

### 输入

```
7
1 6 5 4 3 2 1```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：这些题解的核心思路均是利用完全二叉树的性质，即除最后一层外，第i层的节点数为\(2^{i - 1}\) ，通过遍历节点计算每层的权值和，进而找出权值和最大的深度。算法要点在于如何准确地根据节点编号判断当前节点所在层数，并计算该层的权值和。解决难点主要集中在对完全二叉树最后一层不满的情况处理。各题解思路相近，主要差异体现在代码实现细节、变量命名以及对边界条件处理的清晰程度上。

所选的题解：
  - 作者：___w (赞：14)
    - 星级：4星
    - 关键亮点：思路清晰，利用完全二叉树每层节点编号范围的性质，在输入节点权值时直接进行层的划分与权值和计算，代码简洁明了。
    - 重点代码核心实现思想：通过判断当前节点编号是否为当前层末尾节点编号（\(i == (1 << dep) - 1\)）来确定是否切换到下一层，同时更新最大权值和与对应深度。
```cpp
int n, a, sum, ans, dep = 1, Max = -1e9;
int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a;
        sum += a;
        if (i == (1 << dep)-1) {
            if (sum > Max) {
                Max = sum;
                ans = dep;
            }
            ++dep;
            sum = 0;
        }
    }
    if (sum > Max) {
        Max = sum;
        ans = dep;
    }
    cout << ans;
    return 0;
}
```
  - 作者：封禁用户 (赞：10)
    - 星级：4星
    - 关键亮点：同样在输入时进行权值和计算与层的切换判断，代码逻辑紧凑，变量命名直观，对每层节点数的判断条件清晰。
    - 重点代码核心实现思想：使用`now`记录当前层已输入节点数，`k`记录当前层数，通过判断`now == pow(2, k - 1) || i == n`来确定是否为当前层最后一个节点，进而更新最大权值和与对应层数。
```cpp
int maxx=-1e18,maxid;
int n;
int now,k = 1;
int ans;
signed main()
{
    cin>>n;
    for(int i = 1; i <= n; i++)
    {
        int x; cin>>x;
        ans += x;
        now++;
        if(now == pow(2, k - 1) || i == n) 
        {
            if(ans > maxx) maxx = ans, maxid = k;
            ans = now = 0;
            k++;
        }
    }
    return cout<<maxid,0;
}
```
  - 作者：lbdontknow (赞：2)
    - 星级：4星
    - 关键亮点：通过数组`sum`记录每层的权值和，逻辑清晰，对每层节点数量变化以及深度更新的处理明确，最后遍历`sum`数组找出最大值对应的层数。
    - 重点代码核心实现思想：利用`siz`记录当前层最多节点数，`noww`记录当前层已遍历节点数，`deep`记录当前深度，在遍历节点过程中更新`sum`数组，最后遍历`sum`数组找到最大权值和对应的深度。
```cpp
long long deep, siz, noww, i, n, a[1919810], sum[1919810], maxx = -1145141919810, ans;
int main() {
    cin >> n;
    for (i = 1; i <= n; i++)	cin >> a[i];
    deep = 1;
    siz = 1;
    i = 1;
    noww = 0;
    for (i = 1; i <= n; i++) {
        sum[deep] += a[i];
        noww++;
        if (noww == siz || i == n) {
            noww = 0;
            deep++;
            siz *= 2;
        }
    }
    for (i = 1; i < deep; i++) {
        if (sum[i] > maxx) {
            maxx = sum[i];
            ans = i;
        }
    }
    cout << ans << endl;
    return 0;
}
```

最优关键思路或技巧：在处理完全二叉树此类按层遍历相关问题时，充分利用完全二叉树每层节点数的性质，在输入过程中直接进行层的划分与权值和计算，避免了额外的数组存储与多次遍历，提高效率与代码简洁性。同时，要特别注意处理最后一层不满的边界情况。

可拓展之处：同类型题常涉及完全二叉树的各种统计问题，类似算法套路为利用完全二叉树节点编号、层数与节点数的关系，通过遍历节点完成特定统计任务。

推荐题目：
  - P1030 [NOIP2001 普及组] 求先序排列
  - P1996 约瑟夫问题
  - P2320 [HNOI2006] 鬼谷子的钱袋 

---
处理用时：80.05秒
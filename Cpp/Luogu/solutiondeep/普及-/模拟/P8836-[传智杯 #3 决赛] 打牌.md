# 题目信息

# [传智杯 #3 决赛] 打牌

## 题目背景

disangan233 想和 disangan333 一起打牌，并邀请了一起路过的你。

## 题目描述

三名同学在学习编程的休息时间（编号 $1,2,3$）打扑克，每人一开始 $n$ 张牌，牌一共 $m$ 种，若干张相同的牌可以一起出。

一开始由第一个人出，打出自己的牌里最小的牌。接下来，以玩家 1,2,3,1,2,3... 的顺序轮流出牌，每人打出一组比上个人打出的牌大的，自己能打出的最小的牌，若没有则跳过。

牌的大小是这么决定的：一组张数多的牌比张数少的牌大，如果张数同样多，那么点数大的牌比较大。例如，$(1,1,1)>(3,3)>(2,2)>(4)>(1)$。

若一轮中，其余两个人都无法打出牌，则重新下次由打出最后一张牌的人开始打。谁最先打完所有的牌，谁就赢了。请问最后谁会胜利呢？输出胜者的编号。

对于所有数据，$n,m\leq 50$。

## 说明/提示

样例中的玩法：

```plain
第 1 回合：
【1】：1 3 3 1 3 3 1 2 3 3，打出 [1]
【2】：3 2 1 2 2 3 3 1 1 2，打出 [2]
【3】；2 2 1 2 3 1 2 3 3 1，打出 [3]
【1】：3 3 1 3 3 1 2 3 3，打出 [1,1]
【2】：3 1 2 2 3 3 1 1 2，打出 [2,2]
【3】；2 2 1 2 1 2 3 3 1，打出 [3,3]
【1】：3 3 3 3 2 3 3，打出 [3,3,3]
【2】：3 1 3 3 1 1 2，出不起
【3】；2 2 1 2 1 2 1，打出 [2,2,2,2]
【1】：3 2 3 3，出不起
【2】：3 1 3 3 1 1 2，出不起


第 2 回合：
【3】；1 1 1，打出 [1]
【1】：3 2 3 3，打出 [2]
【2】：1 3 3 1 1 2，打出 [3]
【3】；1 1，打出 [1,1] <- 获胜
```

## 样例 #1

### 输入

```
10 3
1 3 3 1 3 3 1 2 3 3 
3 2 1 2 2 3 3 1 1 2 
2 2 1 2 3 1 2 3 3 1 ```

### 输出

```
3```

# AI分析结果

• 综合分析与结论：
    - 思路方面：所有题解均采用模拟算法，按照题目给定的出牌规则模拟打牌过程。先记录每个人每种牌的数量，通过循环模拟每轮出牌，判断玩家是否能出牌、是否打完牌以及是否开启新回合等情况。
    - 算法要点：用数组（如二维数组）存储每个玩家每种牌的数量，用变量记录上一轮出牌信息（如出牌点数、数量、出牌者），按顺序模拟玩家出牌并更新相关信息。
    - 解决难点：主要难点在于准确实现出牌规则，如判断可出的最小牌、处理新回合开始的情况以及连续两人无法出牌的判定。各题解在实现细节上有所不同，但核心思路一致。
    - 整体来看，各题解质量参差不齐，部分题解思路清晰、代码可读性较好，部分题解代码稍显混乱或注释较少。

    以下是对各题解的简要评分：
    - stswkl：4星。思路清晰，代码简洁，注释详细，使用数组计数存储牌的信息，模拟过程逻辑连贯。
    - zymooll：3星。算法简述清晰，但代码中部分变量命名不太直观，且代码整体稍显冗长。
    - zhuweiqi：3星。思路讲解详细，但代码中嵌套循环较多，可读性一般。
    - Convergent_Series：3星。思路表述清晰，但代码注释较少，部分逻辑理解起来稍困难。
    - codwarm：3星。题目分析到位，代码逻辑较清晰，但变量命名可更具描述性。
    - Jorisy：3星。思路简洁明了，代码实现基本功能，但部分代码逻辑通过goto语句实现，降低了可读性。
    - WA_sir：3星。对出牌方法分析详细，但代码结构不够清晰，变量命名较随意。
    - caotianhao：3星。思路阐述清楚，代码有一定注释，但整体实现稍显繁琐。
    - QWQ_SenLin：3星。将每个步骤放到函数里的思路有助于调试，但代码整体稍复杂，部分函数逻辑可进一步优化。

    最优关键思路或技巧：使用数组计数（桶排序思想）存储每个玩家每种牌的数量，方便统计和查询。在模拟出牌过程中，通过合理的嵌套循环遍历牌的点数和数量，准确判断可出的最小牌，同时注意新回合开始和连续两人无法出牌等特殊情况的处理。

    可拓展之处：此类模拟题通常可通过改变游戏规则、增加玩家数量或牌的种类等方式拓展。类似算法套路包括模拟各种游戏过程、比赛流程等，关键在于清晰梳理规则并准确实现。

    推荐洛谷题目：
    - P1032 [NOIP2002 普及组] 字串变换：字符串模拟问题，通过模拟字符串变换规则求解。
    - P1909 买铅笔：模拟购买物品场景，根据不同包装和价格计算最优方案。
    - P1046 [NOIP2005 普及组] 陶陶摘苹果：简单模拟摘苹果过程，根据条件判断能否摘到苹果。

    个人心得摘录与总结：
    - zymooll提到写题解的初衷以及代码是一年半之前写的，可能存在不足。这表明随着时间推移和编程能力提升，代码质量会有所变化，鼓励不断优化代码。
    - QWQ_SenLin建议将模拟步骤放到函数里方便DEBUG，这是一个有效的调试技巧，有助于提高代码的可读性和可维护性。

所选4星及以上题解：
  - stswkl：4星
    - 关键亮点：思路清晰，代码简洁且注释详细。利用数组计数存牌信息，模拟过程逻辑连贯。
    - 重点代码 - 核心实现思想：用数组`a`记录每个玩家每种点数牌的数量，`last`数组记录上一组牌信息，`sum`数组记录玩家手中牌数。通过嵌套循环模拟出牌过程，判断玩家能否出牌并更新相关信息，若玩家牌出完则输出该玩家编号。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[5][55],x,last[5],sum[5],who=1,tmp;
signed main()
{
    cin>>n>>m;
    sum[1]=sum[2]=sum[3]=n;
    last[3]=1;
    for(int i=1;i<=3;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cin>>x;
            a[i][x]++; //存起来
        }
    }
    for(int i=1;;i++)
    {
        tmp=0;who=(i-1)%3+1;
        if(last[3]==who)last[1]=0,last[2]=1; //新的回合
        for(int j=0;j<=sum[who];j++)
        {
            for(int k=1;k<=m;k++)
            {
                if(j==0&&k<=last[1])continue;
                if(a[who][k]>=j+last[2]) //比上一组牌大
                {
                    sum[who]-=j+last[2],tmp=1;
                    last[1]=k,last[2]+=j,last[3]=who;
                    a[who][k]-=last[2];
                    if(sum[who]==0) //牌出完了
                    {
                        cout<<who;
                        return 0;
                    }
                    break;
                }
            }
            if(tmp)break;
        }
    }
    return 0;
}
```

---
处理用时：56.17秒
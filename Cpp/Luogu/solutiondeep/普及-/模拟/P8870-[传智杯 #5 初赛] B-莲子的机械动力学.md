# 题目信息

# [传智杯 #5 初赛] B-莲子的机械动力学

## 题目背景

**【题目背景和题目描述的两个题面是完全等价的，您可以选择阅读其中一部分。】**

专攻超统一物理学的莲子，对机械结构的运动颇有了解。如下图所示，是一个三进制加法计算器的（超简化）示意图。

![](https://cdn.luogu.com.cn/upload/image_hosting/l6gm0j36.png)

一个四位的三进制整数，从低到高位，标为 $x_1,x_2,x_3,x_4$。换言之，这个数可以写成 $\overline{x_4x_3x_2x_1}_{(3)}$。把它放在这四个齿轮里，对应箭头指向的数字就是现在这位的数值。

在这种机械式计算机里，我们通过齿轮的啮合来实现数位间的连接。通过不同齿轮半径的比例来确定进制。图中所有浅灰色的小齿轮的半径，比上使用皮带相接的较大齿轮的半径，都是 $1:3$。那么小齿轮每转动一圈，大齿轮就转动 $\dfrac{1}{3}$ 圈，也就是刚好一个数码的角度。

于是，我们通过控制齿轮的半径实现了 $3$ 进制的进位。

如果需要实现三进制加法，则只需要在对应数位拨动对应的数码长度即可。

如下是个例子，实现 $\overline{1021}_{(3)}+\overline{0021}_{(3)}=\overline{1112}_{(3)}$

![](https://cdn.luogu.com.cn/upload/image_hosting/4kcgnp7j.png)

初始时齿轮的状态如上。

![](https://cdn.luogu.com.cn/upload/image_hosting/dcd66l5v.png)

把第一个齿轮拨动一个单位长度，变为如上图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/oiexg3yw.png)

把第二个齿轮拨动两个单位长度，变为如上图所示。读数，得到结果 $\overline{1112}_{(3)}$。

---

现在莲子设计了如下图所示的机械结构。对于从左往右数的第 $i$ 枚齿轮，它上面的浅色小齿轮与第 $i+1$ 枚齿轮上的深色小齿轮的半径之比为 $1:(i+2)$。也就是说，第 $i$ 枚齿轮每转动 $1$ 圈，第 $i+1$ 枚齿轮转过的角度恰好为它上面的一个数码。

![](https://cdn.luogu.com.cn/upload/image_hosting/zi1d0qnn.png)

莲子想要知道，在这样的特别的进制表示下，给定 $a,b$，那么计算出的 $a+b$ 的结果是多少。


## 题目描述

题目背景的问题可以转化为如下描述：

给定两个长度分别为 $n,m$ 的整数 $a,b$，计算它们的和。

但是要注意的是，这里的 $a,b$ 采用了某种特殊的进制表示法。最终的结果也会采用该种表示法。具体而言，从低位往高位数起，第 $i$ 位采用的是 $i+1$ 进制。换言之，相较于十进制下每一位的「逢 $10$ 进 $1$」，该种进制下第 $i$ 位是「逢 $i+1$ 进 $1$」。

下图所示，左边是十进制的竖式加法；右边是这种特殊进制的竖式加法。图中的红色加号表示上一位发生了进位。

![](https://cdn.luogu.com.cn/upload/image_hosting/px92d6yd.png)

## 说明/提示

对于全部数据，保证 $1\le n,m\le 2\times 10^5$，从低位往高位数起有 $a_i\in[0,i]$，$b_i\in[0,i]$。请使用 Java 或 Python 语言作答的选手注意输入输出时的效率。

## 样例 #1

### 输入

```
5 4
3 3 2 1 1
3 2 2 1```

### 输出

```
4 2 1 1 0
```

## 样例 #2

### 输入

```
10 1
10 9 8 7 6 5 4 3 2 1
0
```

### 输出

```
10 9 8 7 6 5 4 3 2 1
```

# AI分析结果

### 综合分析与结论
这些题解都意识到本题类似高精度加法，核心思路是逐位模拟相加并按“逢i + 1进1”规则处理进位。算法要点在于正确读入数据、按位相加、处理进位以及合理输出结果。解决难点主要集中在进位处理和输出格式控制。

从质量上看，多数题解思路较清晰，代码也能实现功能，但在代码可读性和优化程度上有所差异。有的题解详细解释了思路和关键步骤，有的则代码相对简洁但解释较少。

### 所选的题解
- **作者：hh20080501hh（5星）**
    - **关键亮点**：先给出常规高精度加法模板对比，清晰展示与本题做法差异，对进位处理单独分析并说明原因，思路极为清晰，代码可读性高。
    - **个人心得**：第一次写题解，强调进位处理分开写的好处，不仅好写、好处理，而且速度快。
```cpp
vector <int> add(vector<int> &A, vector<int> &B)
{
	if (A.size()<B.size())
	{
		return add(B, A);
	}
	vector<int> C;
	C.clear();
	for (int i=0 ; i<A.size() ; i++)
	{
		int t=A[i];
		if (i<B.size())
		{
			t+=B[i];
		}
		C.push_back(t);
	}
	for (int i=0 ; i<C.size() ; i++)
	{
		if (C[i]>=i+2)  //判断是否需要进位
		{
			C[i] -= (i+2);
			if (i+1<C.size()) //如果当前位进位之后
			{		  //不会超出C的范围，就往前进位
				C[i+1]++;
			}
			else//如果当前位进位会超出C的范围，就给C再
			{   //要个地方进位
				C.push_back(1);
				break;
			}
		}
	}
	return C;
}
```
核心实现思想：先将两数对应位相加存入结果数组，再单独遍历结果数组处理进位，若当前位大于等于i + 2则进行进位操作。

- **作者：S_Z_Xcoco（4星）**
    - **关键亮点**：思路表述简洁明了，按步骤阐述解题方法，代码简洁，对输入输出及边界情况处理得当。
    - **个人心得**：因前导零问题困扰两星期，强调处理前导零的重要性。
```cpp
for(ll i=1;i<=mx;i++){
    c[i]+=a[i]+b[i];//相加
    if(c[i]>=i+1){//处理进位情况
        c[i]-=(i+1);//当前位减去 i+1
        c[i+1]++;//下一位加一，表示进位
    }
}
mx+=1;//为了防止最后一位进位的情况，位数要加一
while(c[mx]==0&&mx>=0)mx--;//处理前导零
if(mx<=0)mx=1;//防止答案为零
for(ll i=mx;i>=1;i--)cout<<c[i]<<' ';
```
核心实现思想：按位相加，若当前位和大于等于i + 1则进行进位，最后处理最高位进位、前导零及答案为零的情况。

- **作者：xujingyu（4星）**
    - **关键亮点**：详细简述题意和解法，对输出注意事项罗列清晰，代码注释详细，逻辑清晰。
```cpp
for(int i = 1;i <= len;i++)
{
    base = i + 1;//这一位的进制
    ans[i] = a[i] + b[i] + jin;//计算加法
    jin = ans[i] / base;//计算进位
    ans[i] %= base;
}
ans[len + 1] = jin;//最高位进位的情况
bool flag = true,is_print = false;
for(int i = len + 1;i >= 1;i--)
{
    if(ans[i]) flag = false;
    if(!flag)//忽略前导0
    {
        printf("%d ",ans[i]);
        is_print = true;
    }
}
if(!is_print) printf("0");//答案为0特判
```
核心实现思想：按位计算加法并处理进位，记录最高位进位，通过标志位处理前导零及答案为零的情况。

### 最优关键思路或技巧
1. **分开处理进位**：如hh20080501hh题解，先将对应位相加，再单独遍历处理进位，使代码逻辑更清晰，且在高精度乘法等场景下效率更高。
2. **合理处理边界情况**：如处理前导零、最高位进位及答案为零的情况，保证结果正确性。

### 可拓展之处
此类题目属于自定义进制运算，类似套路可用于其他自定义进制的加减乘除运算，或在特定场景下对数据按自定义规则进行处理。

### 相似知识点洛谷题目
1. **P1601 A+B Problem（高精）**：传统高精度加法，可作为基础练习。
2. **P1303 A*B Problem（高精）**：高精度乘法，与本题类似，需处理好进位问题。
3. **P2142 高精度减法**：高精度减法运算，同样要注意借位等细节，与本题思路有相通之处。 

---
处理用时：55.93秒
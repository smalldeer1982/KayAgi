# 题目信息

# 「GMOI R1-T1」Perfect Math Class

## 题目描述

Index 给了你一个函数如下：

$$f(x)=a_kx^k+a_{k-1}x^{k-1}+\cdots+a_1x^1+a_0$$

画出它的函数图像（`*` 表示经过该点，`.` 表示不经过该点），大小为 $n\times m$，其中 $x$ 的范围是 $[0,n-1]$，$f(x)$ 的范围是 $[0,m-1]$。

具体的，你需要输出一个 $n\times m$ 的字符矩阵，若该函数经过整点 $(x,y)$，则**从左往右**第 $x+1$ 列，**从下往上**第 $y+1$ 行输出 `*`，否则为 `.`。

## 说明/提示

样例 $1$ 解释：

该函数为 $f(x)=x$，显然在 $x\in[0,4], f(x)\in[0,4]$ 时穿过 $(0,0),(1,1),(2,2),(3,3),(4,4)$ 这些整点。

对于 $100\%$ 的数据，$-12\le a_i\le 12
$，$n=m$。每个测试点等分。

| 测试点 | $n\le$ | $m\le$ | $k\le$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $1$ | $1$ | $0$ | $-$ |
| $2$ | $5$ | $5$ | $0$ | $-$ |
| $3$ | $5$ | $5$ | $1$ | $a_1=1$ |
| $4$ | $5$ | $5$ | $1$ | $a_0+a_1\le 2$ |
| $5$ | $10$ | $10$ | $1$ | $-$ |
| $6$ | $10$ | $10$ | $2$ | $a_0=a_1=0,a_2\ge n$ |
| $7$ | $100$ | $100$ | $2$ | $-$ |
| $8$ | $100$ | $100$ | $3$ | $-$ |
| $9$ | $100$ | $100$ | $5$ | $-$ |
| $10$ | $100$ | $100$ | $7$ | $-$ |

## 样例 #1

### 输入

```
5 5 1
0 1
```

### 输出

```
....*
...*.
..*..
.*...
*....```

## 样例 #2

### 输入

```
8 8 1
0 2
```

### 输出

```
........
...*....
........
..*.....
........
.*......
........
*.......
```

# AI分析结果

• 综合分析与结论：这些题解思路大致相同，均是通过枚举\(x\)的取值范围\([0, n - 1]\)，计算对应的\(f(x)\)值，若\(f(x)\)在\([0, m - 1]\)范围内，则在相应坐标位置标记为`*`，否则标记为`.`，最后按要求输出矩阵。算法要点在于实现\(f(x)\)的计算，部分题解使用快速幂优化计算\(x^i\)的过程。解决难点主要是注意数据范围，避免因\(f(x)\)过大或过小导致数组越界等问题，同时要留意输出顺序是从下往上。整体来看，多数题解思路清晰，但在代码可读性、优化程度上存在差异。
• 所选的题解：
  - 作者：scp020 (赞：28)  星级：5星
    - 关键亮点：思路清晰，详细阐述了题目大意和解决方法，代码使用了快读快写优化输入输出，还单独实现了`ksm`函数计算幂次方，逻辑严谨。
    - 个人心得：无
    - 重点代码：
```cpp
inline long long ksm(long long a, long long b)
{
    long long ret = 1;
    while(b)
    {
        if(b&1) ret=ret*a,b--;
        a=a*a,b>>=1;
    }
    return ret;
}
inline long long calc(const int &x)
{
    long long ret = 0;
    for(int i=0;i<=k;i++) ret+=a[i]*ksm(x,i);
    if(ret>m) return -50;
    return ret;
}
int main()
{
    read(n),read(m),read(k);
    for(int i=0;i<=k;i++) read(a[i]);
    for(int i=0;i<n;i++) ans[m-calc(i)][i]='*';
    for(int i=1;i<=m;i++,Putchar('\n'))
        for(int j=0;j<n;j++)
            if(ans[i][j]=='*') Putchar('*');
            else Putchar('.');
    fwrite(Ouf,1,p3-Ouf,stdout),fflush(stdout);
    return 0;
}
```
核心实现思想：`ksm`函数通过位运算实现快速幂，高效计算\(a^b\)。`calc`函数利用`ksm`计算\(f(x)\)。主函数中先读入数据，计算\(f(x)\)并在对应矩阵位置标记，最后按特定顺序输出矩阵。
  - 作者：zhang_kevin (赞：12)  星级：4星
    - 关键亮点：思路表述简洁明了，代码结构清晰，使用快速幂函数`fp`计算幂次方，符合常规解题思路，容易理解。
    - 个人心得：无
    - 重点代码：
```cpp
inline int fp(ll a, ll n){
    int ans = 1;
    while(n){
        if(n & 1)
            ans *= a;
        a *= a;
        n >>= 1;
    }
    return ans;
}
int n, m, k;
inline ll f(int x){
    ll res = a[0];
    for(ll i = k; i >= 1; i--){
        res += a[i] * fp(x, i);
    }
    return res;
}
signed main(){
    cin >> n >> m >> k;
    for(int i = 0; i <= k; i++){
        cin >> a[i];
    }
    for(int i = 0; i <= n - 1; i++){
        int ff = f(i);
        if(ff >= 0 && ff <= m - 1){
            vis[n-ff][i+1] = true;
        }
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            if(vis[i][j]) putchar('*');
            else putchar('.');
        }
        putchar('\n');
    }
    return 0;
}
```
核心实现思想：`fp`函数实现快速幂计算\(a^n\)。`f`函数利用`fp`计算\(f(x)\)。主函数读入数据，计算\(f(x)\)并标记对应位置，最后输出标记后的矩阵。
  - 作者：ran_qwq (赞：4)  星级：4星
    - 关键亮点：代码简洁，使用自定义的`power`函数计算幂次方，相较于`pow`函数效率更高，整体实现思路清晰，符合题目要求。
    - 个人心得：无
    - 重点代码：
```cpp
int power(int x,int y)
{
    int ans = 1;
    for(int i=1;i<=y;i++)
        ans*=x;
    return ans;
}
signed main()
{
    n=read(),m=read(),k=read();
    for(int i=0;i<=k;i++)
        a[i]=read();
    for(int i=0;i<n;i++)
    {
        int ans = 0;
        for(int j=k;j>=0;j--)
            ans+=a[j]*power(i,j);
        if(ans>=0&&ans<m)
            b[ans][i]=1;
    }
    for(int i=m-1;i>=0;i--)
    {
        for(int j=0;j<n;j++)
            if(b[i][j])
                cout<<"*";
            else
                cout<<".";
        puts("");
    }
}
```
核心实现思想：`power`函数通过循环累乘计算\(x^y\)。主函数读入数据，计算\(f(x)\)并标记，最后按要求输出矩阵。
• 最优关键思路或技巧：在计算\(f(x)\)时，使用快速幂或者自定义累乘函数来计算\(x^i\)，比直接使用`pow`函数效率更高。同时，要注意数据范围，提前处理可能出现的数组越界问题。
• 可拓展之处：同类型题通常围绕函数图像绘制、坐标变换以及数值计算等方面展开。类似算法套路是先明确函数关系，再通过枚举定义域内的值计算函数值，根据条件进行标记或处理，最后按特定要求输出结果。
• 推荐题目：
  - P1085 [NOIP2004 普及组] 不高兴的津津，涉及简单的数值计算与条件判断。
  - P1909 买铅笔，通过枚举不同购买方案计算最小值，与本题枚举思路类似。
  - P1425 小鱼的游泳时间，考查时间计算与简单的数值处理，和本题在数值处理上有相似之处。
• 个人心得摘录与总结：
  - 作者lelml提到赛时第一发挂了，说明即使看似简单的模拟题，也需要仔细考虑边界条件等细节，不能掉以轻心。
  - 众多作者提到“不开`long long`见祖宗”，强调了注意数据范围的重要性，在处理较大数值时要提前规划好数据类型，避免因数据类型错误导致结果出错。 

---
处理用时：74.68秒
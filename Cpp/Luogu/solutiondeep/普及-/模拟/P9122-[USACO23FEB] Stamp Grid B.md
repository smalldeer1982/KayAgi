# 题目信息

# [USACO23FEB] Stamp Grid B

## 题目描述

盖章绘画是一幅黑白画，绘制在一个 $N \times N$ 的画布上，其中某些格子被涂黑，而其他格子为空白。它可以用一个 $N \times N$ 的字符数组表示（$1 \leq N \leq 20$）。如果数组的第 $i$ 行第 $j$ 列的值为 `*`，说明该格子被涂黑；如果为 `.`，则说明该格子为空白。

Bessie 想要完成一幅盖章绘画，因此 Farmer John 借给了她一块 $K \times K$（$1 \leq K \leq N$）的盖章，以及一块空的 $N \times N$ 画布。Bessie 可以将盖章顺时针旋转 $90^\circ$，并在画布上的任意位置盖章，只要盖章完全在画布范围内即可。形式化地说，盖章时，Bessie 选择整数 $i,j$，满足 $i \in [1,N-K+1]$ 且 $j \in [1,N-K+1]$；对于每个 $(i',j')$，其中 $1 \leq i',j' \leq K$，画布上的格子 $(i+i'-1,j+j'-1)$ 会被涂黑，如果盖章在 $(i',j')$ 处有墨迹。Bessie 可以在每次盖章之前旋转盖章。一旦画布上的某个格子被涂黑，就会保持涂黑状态。

Farmer John 想知道，Bessie 是否可以用他的盖章完成她想要的盖章绘画。对于每个 $T$（$1 \leq T \leq 100$）个测试用例，帮助 Farmer John 回答这个问题。

## 样例 #1

### 输入

```
4

2
**
*.
1
*

3
.**
.**
***
2
.*
**

3
...
.*.
...
3
.*.
...
...

3
**.
.**
..*
2
.*
*.```

### 输出

```
YES
YES
NO
YES```

# AI分析结果

• 综合分析与结论：
    - 这些题解思路相近，均采用暴力枚举的方法。由于印章可旋转且格子涂黑后不会变白，所以核心思路是枚举印章的四个旋转方向及在画布上的所有放置位置，判断每次盖章是否会将目标为白色的格子涂黑，若不会则进行相应涂色操作，最后对比处理后的画布与目标画布是否一致。
    - 算法要点在于实现印章旋转、盖章位置枚举及涂色逻辑。解决难点主要是正确处理印章旋转后的坐标变换以及避免重复或错误的涂色判断。
    - 整体上，各题解质量差异主要体现在思路清晰度、代码可读性及优化程度上。

• 所选的题解：
  - 作者：chlchl (4星)
    - 关键亮点：思路清晰，先阐述贪心策略，即保证每次盖章不将白色位置涂黑以确保覆盖黑点最多。代码实现中通过预处理旋转三次的印章矩阵，利用函数封装盖章操作，减少码量，提高代码可读性。
    - 个人心得：无
    - 重点代码及核心实现思想：
```cpp
void trying(int a[][N], int x, int y){
    bool f = 1;
    for(int i=1;i<=k;i++){
        for(int j=1;j<=k;j++){
            if(a[i][j] &&!g[i + x - 1][j + y - 1]){
                f = 0;
                break;
            }
        }
        if(!f)
            break;
    }
    if(f){
        for(int i=1;i<=k;i++)
            for(int j=1;j<=k;j++)
                if(a[i][j])
                    vis[i + x - 1][j + y - 1] = 1;
    }
}

void meiju(int x, int y){//贪心，只要能印你就印它 
    trying(st, x, y);
    trying(st1, x, y);
    trying(st2, x, y);
    trying(st3, x, y);
}
```
核心实现思想：`trying`函数用于判断以`(x, y)`为左上角放置印章`a`是否可行，若可行则标记对应位置已覆盖。`meiju`函数枚举印章的四个方向进行尝试盖章。
  - 作者：incra (4星)
    - 关键亮点：思路阐述详细，先说明整体思路，再重点讲解矩阵旋转的坐标变换规律。代码结构清晰，将旋转和盖章操作分别封装成函数，易于理解。
    - 个人心得：无
    - 重点代码及核心实现思想：
```cpp
void rotate () {
    for (int i = 1;i <= m;i++) {
        for (int j = 1;j <= m;j++) tmp[j][m - i + 1] = b[i][j];
    }
    for (int i = 1;i <= m;i++) {
        for (int j = 1;j <= m;j++) b[i][j] = tmp[i][j];
    }
}
void work (int x,int y) {
    for (int i = 1;i <= m;i++) {
        for (int j = 1;j <= m;j++) {
            if (a[x + i - 1][y + j - 1] == '.' && b[i][j] == '*') return ;
        }
    }
    for (int i = 1;i <= m;i++) {
        for (int j = 1;j <= m;j++) {
            if (b[i][j] == '*') ans[x + i - 1][y + j - 1] = '*';
        }
    }
}
```
核心实现思想：`rotate`函数实现印章顺时针旋转90度，`work`函数判断在`(x, y)`位置盖章是否会涂到白色位置，若不会则进行涂色。
  - 作者：Xy_top (4星)
    - 关键亮点：表述直白易懂，先点明暴力思路，再详细说明具体操作步骤。代码通过函数封装旋转和盖章操作，逻辑清晰。
    - 个人心得：强调多测不清空的重要性。
    - 重点代码及核心实现思想：
```cpp
void change () {
    for (int i = 1; i <= k; i ++) {
        for (int j = 1; j <= k; j ++) t[i][j] = c[k - j + 1][i];
    }
    for (int i = 1; i <= k; i ++) {
        for (int j = 1; j <= k; j ++) c[i][j] = t[i][j];
    }
}
void paint (int x, int y) {
    for (int i = x; i <= x + k - 1; i ++) {
        for (int j = y; j <= y + k - 1; j ++) if (c[i - x + 1][j - y + 1] == '*' && a[i][j]!= '*') return;
    }
    for (int i = x; i <= x + k - 1; i ++) {
        for (int j = y; j <= y + k - 1; j ++) if (c[i - x + 1][j - y + 1] == '*') {
            a[i][j] = '*';
            d[i][j] = '*';
        }
    }
}
```
核心实现思想：`change`函数实现印章旋转，`paint`函数判断在`(x, y)`位置盖章是否合法，若合法则对画布`a`和记录画布`d`进行涂色。

• 最优关键思路或技巧：
    - 思维方式上，利用贪心策略，每次保证不将目标白色位置涂黑，从而确保最终能覆盖到最多黑点。
    - 代码实现技巧方面，通过函数封装旋转和盖章操作，提高代码可读性与可维护性；在处理印章旋转时，总结出通用的坐标变换公式，简化实现过程。

• 可拓展之处：
同类型题可拓展到二维图形的拼接、覆盖问题，类似算法套路是根据图形特性（如可旋转、可平移等），枚举所有可能的放置方式，结合目标状态进行判断与操作。

• 洛谷相似题目：
    - P1306 斐波那契公约数，涉及数论与矩阵快速幂，可类比本题对不同状态的枚举与处理思想。
    - P1162 填涂颜色，关于二维矩阵的染色问题，与本题对画布的涂色操作有相似之处。
    - P2392 kkksc03考前临时抱佛脚，通过枚举不同方案解决问题，类似本题枚举印章放置方式。

• 个人心得摘录与总结：
  - 作者：Xy_top提到“多测不清空见祖宗”，强调在多测试用例情况下，需注意对变量的初始化，避免上一个用例的结果影响下一个，这是容易忽略但可能导致错误的细节。
  - 作者：chlchl表示第二题模拟有点恶心，差点没调出来，说明此类模拟题虽思路可能不难，但实现过程可能存在较多细节，需要耐心调试。 

---
处理用时：103.43秒
# 题目信息

# 不死「徐福时空」

## 题目背景

徐福是秦朝齐地方士。

奉秦皇之命，徐福率三千童男童女踏上了寻找传说中的「蓬莱之药」的征途。但最后再也没有回来。

徐福最终去了哪里？有没有找到蓬莱之药？这些问题已经无关紧要了。

## 题目描述

时间的流逝可以抽象成对数字序列进行排序所花费的时间。不同排序策略花费的时间是不同的。这里介绍一种人类探索排序过程中具有里程碑意义的一种排序算法：希尔排序。

希尔排序可以被视为一种对插入排序的优化。为了研究希尔排序的运行效率，我们希望你实现一个简单的希尔排序的过程。在这之前，我们会规范插入排序的具体流程以及评价一个插入排序的过程的「代价」。

### 插入排序

对于一个长度为 $n$ 的数组 $a=[a_1,a_2,\cdots,a_n]$，插入排序的思想是，从前到后枚举每一个元素，将其插入到正确的位置上去：

![](https://cdn.luogu.com.cn/upload/image_hosting/bzr46ykp.png)

如图所示是一个典型的插入排序的过程。在第 $i$ 轮中我们把下标为 $i$ 的元素插入到了**排好序的部分中第一个比 $\bm{a_i}$ 大的元素之前**。假设 $a_i$ 最终被插入到了 $b_i$ 位置，那么我们称这一轮的代价为 $|a_i-b_i|+1$，整个插入排序的过程的代价就是每一轮的代价之和。

### 希尔排序

为了减小插入排序的代价，我们引入了希尔排序。希尔排序将整个排序过程分成了若干轮，每一轮会按照一定的间隔把元素分组，对每一组内的元素分别进行排序。在最后一轮，希尔排序会对整个数组进行一次最终的插入排序。

具体的分组方式是，选定一个整数 $d$，划分为如下组别：

- 下标为 $1,1+d,1+2d,\cdots$ 的元素；
- 下标为 $2,2+d,2+2d,\cdots$ 的元素；
- 下标为 $3,3+d,3+2d,\cdots$ 的元素；
- ……
- 下标为 $d,2d,3d,\cdots$ 的元素。

下面是**一轮**希尔排序的过程。我们选定 $d=3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ladynhmo.png)

希尔排序每一轮分别选取 $d$，并且在最后一轮取 $d=1$，每一轮都进行这样的排序，最终得到一个有序的数组。

![](https://cdn.luogu.com.cn/upload/image_hosting/msa25yb1.png)

虽然看上去进行了很多轮插入排序，但是最终每一轮插入排序的代价之和可能会远小于对整个数组进行单次插入排序的代价（上述例子中体现得并不明显，可以参考样例 $2,3$ 给出的例子）。

事实上，希尔排序是人类发现的第一个最坏复杂度低于 $\Theta (n^2)$ 的排序算法。例如，当取 $d=2^k-1,\ k=\lfloor\log_2 n\rfloor,\lfloor\log_2 n\rfloor-1,\lfloor\log_2 n\rfloor-2,\cdots,1$ 时，整个过程的最坏时间复杂度为 $\mathcal \Theta(n^{3/2})$。

## 说明/提示

### 数据范围及约定

对于全部数据，保证 $1\le n\le 10^5$，$1\le m\le 100$，$\mathrm{cost}\le 5\times 10^7$，$1\le a_i\le 10^9$，$1\le d_i\le n$，$d_m=1$。

## 样例 #1

### 输入

```
10 1
3 2 6 4 1 1 3 8 7 3
1
```

### 输出

```
27
1 1 2 3 3 3 4 6 7 8 
```

## 样例 #2

### 输入

```
15 1
15 14 13 12 10 11 9 8 7 4 5 6 3 2 1
1
```

### 输出

```
116
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
```

## 样例 #3

### 输入

```
15 3
15 14 13 12 10 11 9 8 7 4 5 6 3 2 1      
9 3 1```

### 输出

```
68
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
```

# AI分析结果

• 综合分析与结论：这些题解思路基本一致，均是根据题目描述直接模拟希尔排序过程。算法要点在于理解希尔排序分组插入的特性，对每组元素按插入排序思想进行比较和交换，并计算代价。难点主要是准确实现希尔排序中按间隔分组及插入排序的逻辑。多数题解未进行优化，代码实现上细节略有差异，但整体逻辑相似。

所选的题解：
  - 作者：Night_sea_64 (5星)
    - 关键亮点：思路清晰，先给出插入排序代码作铺垫，再类比得出希尔排序代码，代码简洁明了，可读性高。
    - 核心代码片段：
```cpp
for(int i = 1; i <= m; i++)
{
    int d;
    scanf("%d",&d);
    for(int i = 1; i <= n; i++)
    {
        cnt++;
        int now = i;
        while(now > d)
        {
            if(a[now] < a[now - d])
            {
                swap(a[now], a[now - d]);
                now -= d, cnt++;
            }
            else break;
        }
    }
}
```
核心实现思想：外层循环控制希尔排序的轮数，内层循环对数组每个元素，在当前间隔d下，与前面第d个元素比较，若小则交换并继续往前比较，同时记录代价。

  - 作者：fkcufk (4星)
    - 关键亮点：同样是简洁地模拟希尔排序过程，代码结构清晰，对每层循环目的明确。
    - 核心代码片段：
```cpp
for(int i = 1; i <= m; i++){
    int k;
    cin>>k;
    for(int j = 1; j <= n; j++){
        ans++;
        int t = j;
        while(t > k){
            if(a[t] < a[t - k]){
                swap(a[t], a[t - k]);
                t -= k;
                ans++;
            }
            else break;
        }
    }
}
```
核心实现思想：与Night_sea_64思路类似，通过两层循环实现希尔排序，内层循环中比较并交换元素，同时累加代价。

  - 作者：zhuweiqi (4星)
    - 关键亮点：先详细介绍插入排序作为前置知识，对希尔排序核心部分分析透彻，包括分组方式及代价计算，代码实现完整且注释清晰。
    - 核心代码片段：
```cpp
void msort(int n){
    ans++;
    for(int i = 2; i <= n; i++){
        int t = b[i], j = i - 1;
        while(j >= 1 && b[j] > t){
            b[j + 1] = b[j];
            j--;
        }
        b[j + 1] = t;
        ans += abs(j + 1 - i)+1;
    }
}
for(int i = 1; i <= m; i++){
    d[i] = read();
    for(int j = 1; j <= d[i]; j++){
        int cnt = 0;
        for(int k = j; k <= n; k += d[i]) b[++cnt] = a[k];
        msort(cnt);
        for(int k = j; k <= n; k += d[i]) a[k] = b[(k - 1)/d[i]+1];
    }
}
```
核心实现思想：先定义插入排序函数msort并计算代价，外层循环控制希尔排序轮数，内层循环对每组元素进行提取、排序再放回原数组，实现希尔排序。

最优关键思路或技巧：直接按题目描述模拟希尔排序过程，利用两层循环，外层控制轮数，内层对每个元素按间隔比较交换。注意在比较交换过程中准确计算代价。

可拓展之处：类似题目可考察不同排序算法的模拟及代价计算，或在已有排序算法基础上进行改进优化。相似算法套路是理解排序算法原理，根据题目要求准确实现并处理边界及特殊情况。

推荐题目：
  - P1177 【模板】快速排序
  - P1923 【深基9.例4】求第 k 小的数
  - P3382 【模板】三分法

个人心得：无。 

---
处理用时：43.31秒
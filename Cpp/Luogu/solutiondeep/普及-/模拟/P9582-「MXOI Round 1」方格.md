# 题目信息

# 「MXOI Round 1」方格

## 题目描述

小 C 和方格是好朋友。

小 C 有一个 $n$ 行 $m$ 列的方格图，每个方格中都有一个数字，其中第 $i$ 行第 $j$ 列的方格中的数字为 $a_{i,j}$。

我们定义，在这个方格图中，两个不同的方格不相邻，当且仅当这两个方格**没有公共边**。

小 C 认为，两个不同的方格互为好朋友，当且仅当这两个方格**不相邻**且**这两个方格中的数字相同**。

小 C 想让你帮忙求出，所有方格的好朋友的数量之和是多少。

## 说明/提示

#### 【样例解释 #1】

第 $1$ 行第 $1$ 列的方格共有 $3$ 个好朋友，第 $1$ 行第 $2$ 列的方格共有 $2$ 个好朋友，第 $1$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $1$ 行第 $4$ 列的方格共有 $0$ 个好朋友；

第 $2$ 行第 $1$ 列的方格共有 $1$ 个好朋友，第 $2$ 行第 $2$ 列的方格共有 $2$ 个好朋友，第 $2$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $2$ 行第 $4$ 列的方格共有 $1$ 个好朋友；

第 $3$ 行第 $1$ 列的方格共有 $1$ 个好朋友，第 $3$ 行第 $2$ 列的方格共有 $3$ 个好朋友，第 $3$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $3$ 行第 $4$ 列的方格共有 $4$ 个好朋友；

所有方格的好朋友数量之和为 $20$。

#### 【样例 #2】

见附加文件中的 `square/square2.in` 与 `square/square2.ans`。

该样例满足测试点 $1$ 的限制。

#### 【样例 #3】

见附加文件中的 `square/square3.in` 与 `square/square3.ans`。

该样例满足测试点 $4$ 的限制。

#### 【样例 #4】

见附加文件中的 `square/square4.in` 与 `square/square4.ans`。

该样例满足测试点 $6$ 的限制。

#### 【样例 #5】

见附加文件中的 `square/square5.in` 与 `square/square5.ans`。

该样例满足测试点 $10$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le n,m \le 2000$，$1 \le a_{i,j} \le 9$。

|测试点编号|$n,m \le$|$a_{i,j} \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim3$|$80$|$9$|否|
|$4\sim5$|$2000$|$1$|否|
|$6\sim7$|$2000$|$9$|是|
|$8\sim10$|$2000$|$9$|否|

特殊性质：保证任意两个相邻的方格中的数不相等。

## 样例 #1

### 输入

```
3 4
1 1 4 5
2 1 2 3
3 1 4 1```

### 输出

```
20```

# AI分析结果

• 综合分析与结论：这些题解思路大致相同，均利用桶统计数字出现次数以优化暴力枚举。先计算每个数字理论上好朋友数量（通过排列组合，假设数字出现x次，则为x*(x - 1)），再减去相邻且数字相同的不合法情况。主要难点在于如何高效统计与去重。不同题解在细节处理和代码风格上有差异。
• 所选的题解：
  - **作者：Coffee_zzz (5星)**
    - **关键亮点**：思路清晰，针对不同测试点分别给出优化策略，代码简洁明了。
    - **个人心得**：提醒不开`long long`见祖宗。
    - **核心代码**：
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2005,A=15;
int n,m,a[N][N],c[A];
ll ans;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            c[a[i][j]]++;
        }
    }
    for(int i=1;i<=9;i++) ans=ans+1ll*c[i]*(c[i]-1);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(a[i][j]==a[i-1][j]) ans--;
            if(a[i][j]==a[i][j-1]) ans--;
            if(a[i][j]==a[i+1][j]) ans--;
            if(a[i][j]==a[i][j+1]) ans--;
        }
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：先统计每个数字出现次数到桶`c`中，计算所有数字理论上好朋友数量总和`ans`，再遍历方格减去相邻且数字相同的情况。
  - **作者：zzx114514 (4星)**
    - **关键亮点**：思路表述清晰，代码逻辑连贯，直接从整体计算好朋友数量出发，先假设所有相同元素均不相邻计算，再减去相邻相同元素情况。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,a[2005][2005],t[10],ans; 
int main()
{
    cin>>n>>m;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        {
            cin>>a[i][j];
            t[a[i][j]]++;//统计数字出现个数 
        }
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        {
            ans+=t[a[i][j]]-1;//开始假设所有相同元素均不相邻 
            if (i>1 && a[i-1][j]==a[i][j]) ans--;
            if (i<n && a[i+1][j]==a[i][j]) ans--;
            if (j>1 && a[i][j-1]==a[i][j]) ans--;
            if (j<m && a[i][j+1]==a[i][j]) ans--;
            //如果相邻且相同则将ans-1 
        }
    cout<<ans;
    return 0;//华丽的结尾 
}
```
    - **核心实现思想**：读入方格数字同时统计各数字出现次数到`t`数组，遍历方格，每次计算当前方格数字对应总出现次数减1（排除自身），再减去相邻且相同元素情况累加到`ans`。
  - **作者：_JF_ (4星)**
    - **关键亮点**：代码简洁，思路清晰，先利用排列组合计算每种数字最多可组合出的好朋友对数，再遍历矩阵减去不满足条件（相邻且数字相同）的情况。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =5001;
#define int long long 
int a[N][N],t[N],ans;
signed main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)    
            scanf("%lld",&a[i][j]),t[a[i][j]]++;
    for(int i=1;i<=9;i++)
        ans+=t[i]*(t[i]-1);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            if(a[i][j]==a[i-1][j])    ans--;
            if(a[i][j]==a[i][j-1])    ans--;
            if(a[i][j]==a[i+1][j])    ans--;
            if(a[i][j]==a[i][j+1])    ans--;
        }
    cout<<ans<<endl;
    return 0;
}
```
    - **核心实现思想**：读入数据时统计各数字出现次数到`t`数组，计算每种数字理论好朋友对数累加到`ans`，再遍历矩阵减去相邻且数字相同情况。
• 最优关键思路或技巧：利用桶统计数字出现次数，通过排列组合计算理论好朋友对数，再遍历减去相邻且数字相同的不合法情况，避免四重循环暴力枚举，优化时间复杂度到O(nm)。
• 可拓展之处：同类型题可涉及更多复杂的网格关系定义及条件判断，类似算法套路是利用数据范围小的特点，通过桶或其他简单数据结构统计信息，再进行计算和去重。
• 推荐洛谷题目：
  - P1083 [NOIP2012 提高组] 借教室：涉及数组统计和条件判断，类似本题统计和处理信息。
  - P1131 [ZJOI2007] 时态同步：有树状结构和节点信息统计，与本题统计信息优化暴力计算思路类似。
  - P1314 [NOIP2011 提高组] 聪明的质监员：通过统计信息计算结果并二分查找调整，和本题统计信息计算结果有相似之处。
• 个人心得摘录与总结：多个题解提到不开`long long`会导致结果错误，强调了数据类型选择在处理较大数据时的重要性。 

---
处理用时：94.22秒
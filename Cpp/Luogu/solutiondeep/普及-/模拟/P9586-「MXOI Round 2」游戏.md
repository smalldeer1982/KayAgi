# 题目信息

# 「MXOI Round 2」游戏

## 题目描述

小 C 和小 D 正在玩一款蒸蒸日上的游戏。

这款游戏共有 $3$ 种手牌：杀、闪、斩。他们的用途分别如下：

- 杀：对对方使用，对方需要使用一张**闪**，否则对方输掉游戏；**或**回应对方的**斩**；

- 闪：回应对方的**杀**；

- 斩：对对方使用，对方需要使用一张**杀**，否则对方输掉游戏。

玩家在每使用一张牌后，都需要弃掉该使用的牌。

从小 C 开始，每个回合依次属于小 C 和小 D。在玩家的回合内，该玩家可以出**任意**张**杀**和**斩**，对方需要做出对应的回应。当然，玩家也可以不出牌，直接进入对方的回合。

现在，小 C 共有 $c_1$ 张杀、$c_2$ 张闪、$c_3$ 张斩，小 D 共有 $d_1$ 张杀、$d_2$ 张闪、$d_3$ 张斩，**双方都知道对方的手牌**。你需要求出，双方在都进行最优策略的情况下，游戏的结果会如何。

## 说明/提示

#### 【样例解释 #1】

对于第一组数据，小 C 可以先出一张斩，并在小 D 回应一张杀后再出一张斩。此时小 D 的杀用完了，无法做出回应，输掉了游戏。

#### 【样例 #2】

见附加文件中的 `game/game2.in` 与 `game/game2.ans`。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le T \le 10^5$，$0 \le c_1,c_2,c_3,d_1,d_2,d_3 \le 10^9$。

|测试点编号|特殊性质|
|:---:|:---:|
|$1\sim3$|保证 $c_3=d_3=0$|
|$4\sim6$|保证 $c_1=d_2$ 且 $c_2=d_1$|
|$7\sim10$|无|

## 样例 #1

### 输入

```
3
3 1 4 1 5 9
1 1 4 5 1 4
5 2 1 2 6 3```

### 输出

```
C
D
E```

# AI分析结果

• **综合分析与结论**：这些题解思路基本一致，都基于双方采取最优策略进行分析。小C先手，若小C能用杀或斩直接获胜（$c_1 > d_2$ 或 $c_3 > d_1$）则小C胜；若不能，小C会用斩消耗小D的杀，之后再判断小D能否获胜（$d_1 - c_3 > c_2$ 或 $d_3 > c_1$），若也不能则平局。算法要点在于明确双方出牌的最优策略及相应的获胜条件判断。解决难点在于理解双方如何根据手牌情况进行最优决策。整体来看，多数题解思路清晰，但部分代码可读性或优化程度欠佳。

• **所选的题解**：
  - **Coffee_zzz（5星）**：
    - **关键亮点**：思路阐述极为清晰，对小C和小D的各种情况分析细致，代码简洁明了，直接根据分析逻辑进行条件判断输出结果。
    - **重点代码**：
```c++
#include <bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);
	int T,c1,c2,c3,d1,d2,d3;
	cin>>T;
	while(T--){
		cin>>c1>>c2>>c3>>d1>>d2>>d3;
		if(c1>d2) puts("C");
		else if(c3>d1) puts("C");
		else if(d3>c1) puts("D");
		else if(d1-c3>c2) puts("D");
		else puts("E");
	}
	return 0;
}
```
    - **核心实现思想**：按先后手顺序依次判断小C和小D能否获胜，根据不同条件输出相应结果。

  - **andyli（4星）**：
    - **关键亮点**：思路简洁清晰，代码通过简洁的逻辑判断实现对游戏结果的判定，先判断小C能否赢，若不能则计算小C用斩消耗小D杀后小D能否赢，最后确定是否平局。
    - **重点代码**：
```cpp
int main() {
    multipleTests([&] {
        dR(u32, c1, c2, c3, d1, d2, d3);
        if (c1 <= d2 && c3 <= d1) { // 小C无法赢
            d1 -= c3; // 小C用斩消耗对方的杀
            if (d1 <= c2 && d3 <= c1) // 小D无法赢
                writeln('E');
            else
                writeln('D');
        }
        else
            writeln('C');
    });
    return 0;
}
```
    - **核心实现思想**：先判断小C获胜条件，不满足则计算小D在小C消耗其杀后的获胜条件，都不满足则为平局。

  - **卷王（4星）**：
    - **关键亮点**：对题目中牌的关系分析独特，将牌按主动性分为“老大”“老二”“老三”，贪心策略明确，先出斩再出杀，代码逻辑清晰地按照此策略实现。
    - **重点代码**：
```cpp
#include <stdio.h>

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
	return x * f;
}

int T, a1, b1, c1, a2, b2, c2;
int a[1000007];

//c 用 a 缓解
//a 用 b 缓解

int main() {
	T = read();
	while(T--) {
		a1 = read(), b1 = read(), c1 = read();
		a2 = read(), b2 = read(), c2 = read();
		if(c1 > a2 || a1 > b2) { printf("C\n"); continue; }
		a2 -= c1; c1 = 0; //小C用掉所有斩
		if(c2 > a1 || a2 > b1) { printf("D\n"); continue; }
		a1 -= c2; c2 = 0; //小D用掉所有斩
		if(a1 > b2) { printf("C\n"); continue; }
		if(a2 > b1) { printf("D\n"); continue; }
		printf("E\n");
	}
	return 0;
}
```
    - **核心实现思想**：先判断小C能否用斩或杀获胜，若不能则用斩消耗小D的杀，同理判断小D，最后再判断用杀能否获胜，都不满足则平局。

• **最优的关键思路或技巧**：关键思路在于明确双方最优策略，先手优先尝试直接获胜，不能则消耗对方关键牌（小C用斩消耗小D的杀），后手同样。这是一种基于博弈论的贪心策略，通过分析牌与牌之间的克制关系及先后手优势来确定每一步的最优决策。

• **可拓展之处**：同类型题可涉及更多手牌种类及更复杂的规则，类似算法套路是先分析各种牌的作用及相互关系，确定双方在不同情况下的最优策略，进而根据策略制定判断胜负的逻辑。

• **推荐题目**：
  - [P1247 取火柴游戏](https://www.luogu.com.cn/problem/P1247)，考察博弈论相关知识。
  - [P2197 模板 - Nim游戏](https://www.luogu.com.cn/problem/P2197)，经典的博弈论Nim游戏。
  - [P1199 [NOIP2010 普及组] 三国游戏](https://www.luogu.com.cn/problem/P1199)，涉及策略分析与博弈。

• **个人心得**：暂未发现题解中有个人心得相关内容。 

---
处理用时：84.33秒
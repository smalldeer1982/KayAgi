# 题目信息

# [CERC2019] Bob in Wonderland

## 题目背景

**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Bob in Wonderland](https://contest.felk.cvut.cz/19cerc/solved/bob.pdf)」**

## 题目描述

众所周知，链条是由相连的环组成的。通常，所有环都具有相同的形状和大小。Bob 是一名铁匠学徒，他正在制作自己的第一条铱链。他遵循传统的链条制作通则。上面写着：
- 如果没有链条，制作一个环，它将成为你链条的一部分。
- 如果有一条链，制作一个环，并将其连接到你已有的链中的另一个环上。

Bob 做了第一个环。然后，每次他制作另一个环时，他都会将其连接到链条上的其他环上，就像通则告诉他的那样。

当他完成时，他意识到他创造的物体根本不像一条普通的链。为了把链条拉直，他反复地拎起可能是链条两端的两个链环，并试图把它们尽可能地拉开。但在不同的地方，还有更多的“链条”从拉直的部分垂下来。

很明显，Bob 的工作还没有完成，他决定把他制作的物体称为未完成的链条。经过更多的思考，Bob 得出了一个结论，他必须更谨慎地断开一些环，并将它们重新连接到未完成的链条的其余部分，以获得他想要制作的直链。在直链中，每个环最多连接两个其他环，并且直链不能在不断开链环的情况下分离成更多的部分。

Bob 现在更加小心了，将用简单的步骤取得进展。在一个步骤中，他将选择一个环 A，连接到未完成链中的另一个环 B。然后，他会断开 A，将其与 B 分开，并将 A 重新连接到未完成的链条中的另一个环 C。如果最初连接到 A 的环不是 B，Bob 将在整个步骤中保持它们连接着 A。

Bob 获得直链所需执行的最小步骤数是多少？

## 说明/提示

### 样例解释
![](https://cdn.luogu.com.cn/upload/image_hosting/541l6nqd.png)

## 样例 #1

### 输入

```
5
4 3
1 2
4 5
3 2
```

### 输出

```
0```

## 样例 #2

### 输入

```
6
1 3
3 2
3 4
4 5
4 6```

### 输出

```
2```

## 样例 #3

### 输入

```
7
1 2
2 3
3 4
4 5
3 6
6 7```

### 输出

```
1```

# AI分析结果

• 综合分析与结论：这些题解思路基本一致，都将链条问题转化为无向图问题，通过统计每个环（顶点）连接其他环（顶点）的数量（度数），计算度数大于2的环超出2的部分之和，即为将未完成链条转化为直链所需的最少步骤数。算法要点在于用数组记录每个环的连接数，遍历输入的边信息更新连接数，再遍历环统计结果。解决难点在于理解将实际链条问题抽象为图论中的度数统计问题。
  - 作者Defy_HeavenS（5星）
    - 关键亮点：思路清晰，先阐述题意，再详细说明思路，将链条与无向图联系起来，明确指出计算方法，代码简洁明了。
    - 重点代码核心思想：用数组d记录每个环的度数，读入边时更新度数，遍历环计算度数大于2的环超出2的部分并累加。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,u,v,s;
int d[300005];
int main(){
    cin>>n;
    for(int i=1;i<n;i++){
        cin>>u>>v;
        d[u]++,d[v]++;
    }
    for(int i=1;i<=n;i++){
        if(d[i]>2){
            s+=max(0,d[i]-2);
        }
    }
    cout<<s;
    return 0;
}
```
  - 作者Amberhart（4星）
    - 关键亮点：通过分析样例引导出解题思路，对特殊情况进行说明，思路较清晰，代码简洁。
    - 重点代码核心思想：同Defy_HeavenS，用数组d记录度数，读边更新度数，遍历环累加度数大于2的环超出2的部分。
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,u,v,d[300010],c;
int main(){
    cin>>n;
    for(int i=1;i<n;i++){
        cin>>u>>v;
        d[u]++;d[v]++;
    }
    for(int i=1;i<=n;i++){
        if(d[i]>2){
            c=c+max(0,d[i]-2);
        }
    }
    cout<<c;
    return 0;
}
```
  - 作者hjqhs（4星）
    - 关键亮点：简洁明了地阐述思路，直接指出满足直链的条件，代码规范，使用较多模板代码。
    - 重点代码核心思想：用数组t记录每个环连接的环数，读边时更新，遍历环计算环数大于2的环超出2的部分并累加。
```cpp
void solve(){
    cin>>n;
    for(int i=1;i<n;++i){
        int u,v;
        cin>>u>>v;
        ++t[u],++t[v];
    }
    for(int i=1;i<=n;++i){
        if(t[i]>2)ans+=t[i]-2;
    }
    cout<<ans;
}
```
• 最优关键思路或技巧：将实际生活中的链条问题巧妙地转化为图论中的度数统计问题，通过数组记录每个顶点度数，利用简单的循环和条件判断解决问题，体现了抽象思维和简单数据结构解决复杂问题的技巧。
• 可拓展之处：此类问题属于图论中简单的度数统计应用，类似套路可解决一些关于结构连接关系调整，通过统计节点连接数进行优化的问题。比如一些网络拓扑结构调整、电路连接优化等场景下的问题。
• 相似知识点洛谷题目：
  - P1330 封锁阳光大学：涉及图的遍历和节点状态判断，与本题对图节点的处理类似。
  - P1121 环状最大两段子段和：虽然重点在子段和计算，但同样需要处理环状结构，与本题链条结构有一定相似性。
  - P2746 星际旅行：涉及图的边权和节点关系处理，与本题对图结构的分析有相似之处。
• 个人心得：无。 

---
处理用时：46.89秒
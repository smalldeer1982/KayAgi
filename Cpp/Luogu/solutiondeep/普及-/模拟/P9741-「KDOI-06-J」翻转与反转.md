# 题目信息

# 「KDOI-06-J」翻转与反转

## 题目描述

小 W 有一个长度为 $n$ 的 $01$ 序列 $a_1,a_2,\ldots,a_n$，他将对这个序列按顺序进行 $n$ 次操作。

在第 $i$ 次操作中（$1\le i\le n$），小 W 将按顺序执行以下**两种**变换：

1. 将区间 $[1,i]$ 中的数按下标翻转。形式化地说，在这次变换之后，序列 $a$ 将变为 $a_i,a_{i-1},\ldots,a_{1},a_{i+1},a_{i+2},\ldots,a_n$。
2. 将区间 $[1,i]$ 中的数按值翻转。形式化地说，在这次变换之后，对于任意 $1\le j\le i$，若 $a_j=0$，则 $a_j$ 将变为 $1$，否则 $a_j$ 将变为 $0$。

小 W 想要知道，在全部 $n$ 次操作结束后，序列 $a$ 中每个元素的值。

## 说明/提示

**【样例解释 #1】**

序列 $a$ 的变化如下表所示：

| 操作次数 | 序列 $a$ 的变化 |
| :--: | :--: |
| $1$ | $[1,1,1]\to [1,1,1]\to[0,1,1]$ |
| $2$ | $[0,1,1]\to [1,0,1]\to[0,1,1]$ |
| $3$ | $[0,1,1]\to [1,1,0]\to[0,0,1]$ |

**【样例解释 #2】**

序列 $a$ 的变化如下表所示：

| 操作次数 | 操作后的序列 $a$ |
| :--: | :--: |
| - | $[1,0,1,1,1,0,0,1]$ |
| $1$ | $[0,0,1,1,1,0,0,1]$ |
| $2$ | $[1,1,1,1,1,0,0,1]$ |
| $3$ | $[0,0,0,1,1,0,0,1]$ |
| $4$ | $[0,1,1,1,1,0,0,1]$ |
| $5$ | $[0,0,0,0,1,0,0,1]$ |
| $6$ | $[1,0,1,1,1,1,0,1]$ |
| $7$ | $[1,0,0,0,0,1,0,1]$ |
| $8$ | $[0,1,0,1,1,1,1,0]$ |

**【样例 #3】**

见选手文件中的 `revflip/revflip3.in` 与 `revflip/revflip3.ans`。

**【样例 #4】**

见选手文件中的 `revflip/revflip4.in` 与 `revflip/revflip4.ans`。


**【数据范围】**

对于所有数据保证：$1\le n\le 2\times 10^6$，且对于任意 $1\le i\le n$，$a_i=0$ 或 $1$。

| 测试点编号 | $n\le$ |  特殊性质 |
| :-----------: | :-----------: | :----------: |
| $1\sim 3$ | $10^3$ | 无 |
| $4\sim 5$ | $10^5$ | 无 |
| $6 \sim 7$ | $2\times 10^6$ | $a_i=0$ |
| $8\sim 10$ | $2\times 10^6$ | 无 | 


## 样例 #1

### 输入

```
3
1 1 1
```

### 输出

```
0 0 1 
```

## 样例 #2

### 输入

```
8
1 0 1 1 1 0 0 1
```

### 输出

```
0 1 0 1 1 1 1 0 
```

# AI分析结果

### 综合分析与结论
这些题解主要通过找规律来优化暴力解法，将时间复杂度从 \(O(n^2)\) 降低到 \(O(n)\)。不同题解找规律的角度有所不同，有的从每个元素操作次数的奇偶性出发，有的通过模拟操作观察元素位置和值的变化规律，还有的根据 \(n\) 的奇偶性分类讨论元素最终的排列和取值。

### 所选的题解
- **作者：wjx38223 (5星)**
    - **关键亮点**：思路清晰，详细分析每个元素操作次数及两种变换规律，推导出 \(O(n)\) 解法，代码可读性高。
    - **个人心得**：无
    - **核心代码**：
```cpp
for(int i = 1; i<=n; i++){
    cin >> s[i];
}
int p; 
for(int i = 1; i<=n; i++){
    int at = 0; 
    p = n - i + 1;
    if(p%2==0){ 
        at = p/2;
        ans[i+at] = s[i];
    }else{
        p--; 
        at += p/2*i;
        at -= (p/2 + 1)*(i - 1);
        if(s[i]=='0'){ 
            ans[i+at] = '1';
        }else{
            ans[i+at] = '0';
        }
    }   
}
for(int i = 1; i<=n; i++){
    cout << ans[i] << " "; 
}
```
    - **核心实现思想**：先确定每个元素操作次数 \(p\)，根据 \(p\) 的奇偶性分别计算元素移动后的位置 \(at\)，若 \(p\) 为偶数，直接按规律移动；若为奇数，先减1按偶数情况计算移动，再结合两种变换特性确定最终值并放入答案数组。
- **作者：Eleveslaine (4星)**
    - **关键亮点**：通过手动模拟 \(n = 4\) 和 \(n = 5\) 的情况，快速找到规律，根据 \(n\) 的奇偶性分类讨论，并用 STL 链表模拟，代码简洁。
    - **个人心得**：T1 `NaN` 打成 `Nan` 怒挂60分，强调细心的重要性。
    - **核心代码**：
```cpp
if(n&1) { 
    for(int i=1;i<=n;++i)
        if(i&1)
            ans.push_front(!a[i]);
        else
            ans.push_back(a[i]);
}
else { 
    for(int i=1;i<=n;++i)
        if(i&1)
            ans.push_back(a[i]);
        else
            ans.push_front(!a[i]);
}
for(bool x:ans)
    cout << x << ' ';
```
    - **核心实现思想**：根据 \(n\) 的奇偶性，对原序列下标按奇偶分类，奇数下标元素取反后按特定顺序（ \(n\) 为奇数时放链表前， \(n\) 为偶数时放链表后）放入链表，偶数下标元素按正常顺序放入链表，最后输出链表元素。
- **作者：Xdwjs (4星)**
    - **关键亮点**：分别分析“翻转”和“反转”操作规律，“翻转”操作通过举例清晰呈现奇数位和偶数位元素最终位置规律，“反转”操作根据元素位置确定变换次数，代码简洁高效。
    - **个人心得**：无
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    cin>>a[i];
    if((n - i + 1)%2==1) a[i]=!a[i];
}
for(int i=n;i>=1;i-=2) cout<<a[i]<<" ";
for(int i=(n%2==0?1:2);i<=n;i+=2) cout<<a[i]<<" ";
```
    - **核心实现思想**：先根据“反转”操作规律，对每个元素根据其变换次数的奇偶性确定是否取反。再依据“翻转”操作中奇数位和偶数位元素最终位置规律，分奇偶顺序输出元素。

### 最优关键思路或技巧
通过手动模拟小数据找规律，利用元素操作次数的奇偶性、 \(n\) 的奇偶性以及元素位置变换规律来优化算法，避免暴力模拟的高时间复杂度。

### 可拓展思路
此类题目通常可通过找规律、数学推导来优化暴力解法。类似套路包括对操作进行分类分析，观察元素位置和值的变化与操作次数、序列长度等因素的关系。同类型题可能涉及不同的操作规则，但核心思路都是通过分析操作找规律来简化计算。

### 相似知识点洛谷题目
- [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)：通过数学方法找规律解决连续自然数求和问题，考察对数字规律的分析能力。
- [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)：需根据给定规则构建二叉树并找规律计算节点值，涉及树结构和规律推导。
- [P2604 [ZJOI2010] 数字计数](https://www.luogu.com.cn/problem/P2604)：通过找规律统计数字在一定范围内出现的次数，锻炼对数字规律和计数问题的处理能力。 

---
处理用时：52.00秒
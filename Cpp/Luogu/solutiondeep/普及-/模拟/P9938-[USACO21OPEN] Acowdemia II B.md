# 题目信息

# [USACO21OPEN] Acowdemia II B

## 题目描述

Bessie 正在申请计算机科学的研究生，并取得了一所久负盛名的计算机科学实验室的面试通知。然而，为了避免冒犯任何人，Bessie 有意先确定实验室的 $N$ 名现有成员的相对资历（$1\le N\le 100$）。没有两名实验室成员的资历相同，但确定他们的资历深浅可能并不好办。为此，Bessie 将会对实验室的出版物进行调查。

每份出版物均包含一个作者列表，为所有 $N$ 名实验室成员的一个排列。列表按每名实验室成员对这篇文章的贡献降序排列。如果多名研究员的贡献相等，则按字典序排列。由于更有资历的实验室成员负有更多的管理责任，更有资历的研究员从不会比资历较浅的研究员做出更多的贡献。

例如，在一个由资历较浅的学生 Elsie、资历较深的教授 Mildred、以及十分资深的教授 Dean 组成的实验室中，可能存在一篇论文 Elsie-Mildred-Dean，如果他们做出了不等的贡献（也就是说，Elsie 做出的贡献比 Mildred 更多，Mildred 比 Dean 更多）。然而，也有可能存在一篇论文 Elsie-Dean-Mildred，如果 Mildred 和 Dean 做出了相等的贡献，而 Elsie 做出了更多的贡献。

给定实验室的 $K$ 份出版物（$1\le K\le 100$），对于实验室中每对研究员，如果可能的话帮助 Bessie 判断其中谁的资历更深。

## 说明/提示

### 样例解释 1

在这个样例中，单独一份论文 elsie-mildred-dean 并不能提供足够的信息判断 Elsie 比 Mildred 资历更深或更浅。然而，我们可以推断出 Dean 一定比这两名研究员资历更深，从而资历排序为 Elsie<Mildred<Dean 和 Mildred<Elsie<Dean 均是可能的。 

### 样例解释 2

在这个样例中，唯一能与两篇论文相一致的资历排序为 Elsie<Mildred<Dean，这是因为基于第一个样例所提供的信息，第二篇论文可以帮助我们推断出 Mildred 比 Elsie 的资历更深。 

## 样例 #1

### 输入

```
1 3
dean elsie mildred
elsie mildred dean```

### 输出

```
B11
0B?
0?B```

## 样例 #2

### 输入

```
2 3
elsie mildred dean
elsie mildred dean
elsie dean mildred```

### 输出

```
B00
1B0
11B```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解思路基本一致，都是通过遍历每份出版物，利用贡献值与字典序的关系来确定成员间资历关系。若在出版物作者列表中，某位置后名字字典序非递增，则可判断该位置前成员比之后成员资历浅。
    - 算法要点：借助map容器将成员名字映射为编号，方便记录和处理资历关系；使用二维数组记录每对成员间资历判断结果。
    - 解决难点：关键在于理解如何从经过贡献和字典序排序后的作者列表中提取资历信息，即通过寻找字典序非递增处来确定资历关系。
    - 整体上，各题解质量相近，均能解决问题，但在思路清晰度、代码可读性等方面存在差异。

  作者：_Deer_Peach_ (4星)
    - 关键亮点：思路清晰，代码简洁，注释详细。先对成员名字标号，遍历每份出版物时，通过内层循环找到第一个名字字典序比前一个小的人，从而确定资历关系。
    - 重点代码核心实现思想：遍历每份出版物，对每个作者位置，找到第一个字典序减小处，标记其前面的人比后面的人资历浅。
```cpp
for(int i=1;i<=k;i++){//k份出版物
    for(int j=1;j<=n;j++)cin>>name[j];
    for(int j=1;j<=n;j++){
        int x=j+1;while(x<=n&&name[x]>name[x-1])x++;//找第一个名字字典序比前一个人小的人
        for(int y=x;y<=n;y++)vis[id[name[y]]][id[name[j]]]=1;//当前这个人资历都比后面的人深
    }
}
```

  作者：cly312 (4星)
    - 关键亮点：代码逻辑清晰，直接构建资历比较矩阵。遍历出版物时，找到第一个降序名字，确定其后成员比当前成员资历高。
    - 重点代码核心实现思想：与上一题解类似，遍历每份出版物，找到第一个字典序降序处，标记其后成员比当前成员资历高。
```cpp
while (m--) {
    for (int i = 0; i < n; i++) cin >> name[i];
    for (int i = 0; i < n; i++) {
        int j = i + 1;
        while (j < n && name[j] > name[j - 1]) j++;//找到第一个降序的名字
        while (j < n) { //j之后的所有人资历都严格比i高
            int a = id[name[i]], b = id[name[j]];
            g[b][a] = 1;
            j++;
        }
    }
}
```

  作者：we_are_the_chuibing (4星)
    - 关键亮点：思路明确，通过设置哨兵简化字典序判断，利用邻接矩阵记录资历关系，代码实现简洁明了。
    - 重点代码核心实现思想：遍历每份出版物，记录字典序递增的第一位，标记该位置后的成员比之前成员资历深。
```cpp
while(k--){
    int pos=1;
    for(int i=1;i<=n;++i){
        cin>>s[i];
        if(s[i]<s[i-1])
            pos=i;
        for(int j=1;j<pos;++j){
            vh[name[s[i]]][name[s[j]]]=1;
            vh[name[s[j]]][name[s[i]]]=-1;
        }
    }
}
```

• 最优关键思路或技巧：利用map将名字映射为编号，遍历出版物时通过寻找字典序非递增处确定资历关系，并用二维数组记录结果。

• 可拓展之处：同类型题可涉及其他双关键字排序后推导隐藏关系的场景，类似算法套路是通过分析排序规则找到关键判断条件，利用数据结构记录推导结果。

• 相似知识点洛谷题目：
    - P1083 [NOIP2012 提高组] 借教室
    - P1308 [NOIP2011 普及组] 统计单词数
    - P1923 [NOIP2017 普及组] 外星密码 

---
处理用时：62.39秒
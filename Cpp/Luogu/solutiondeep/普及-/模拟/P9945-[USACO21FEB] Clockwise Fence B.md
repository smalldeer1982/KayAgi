# 题目信息

# [USACO21FEB] Clockwise Fence B

## 题目描述

围绕 Farmer John 最大的草地的栅栏已经损坏了，如今他终于决定要换一个新的栅栏。

不幸的是，当 Farmer John 在铺设新栅栏时，一只巨大的蜜蜂突然出现，在他的草地上追着他跑，导致最后栅栏被沿着一条相当不规则的路径铺设。栅栏可以用一个字符串表示，每个字符为 `N`（north，北）、`E`（east，东）、`S`（south，南）、`W`（west，西）之一。每个字符表示一米长的一段栅栏。举例来说，如果字符串为 `NESW`，这表示栅栏从起点开始向北延伸 $1$ 米，然后向东延伸 $1$ 米，然后向南延伸 $1$ 米，然后向西延伸 $1$ 米，回到栅栏的起点。

栅栏的结束位置与开始位置相同，而这是栅栏的路径上唯一会被到达多次的位置（从而起始位置是唯一会被再次到达的位置，在栅栏结束之时）。结果，栅栏确实围起了一个草地上连通的区域，尽管这个区域可能形状十分奇特。

Farmer John 想要知道他铺设栅栏的路径是顺时针（当按字符串表示的顺序沿着栅栏的路径行走时被围起的区域位于右侧）还是逆时针（被围起的区域位于左侧）。 

## 说明/提示

### 样例解释 1

以下为这两条栅栏路径，用 `@` 表示起始位置：

```plain
*>*
^ v
@<*
```
```plain
  *<*<*<*
  v     ^
*<@     *
v       ^
* *>*>* *
v ^   v ^
* *<* * *
v   ^ v ^
*>*>* *>*
```

## 样例 #1

### 输入

```
2
NESW
WSSSEENWNEESSENNNNWWWS```

### 输出

```
CW
CCW```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均基于判断左转和右转次数或角度来确定行走方向是顺时针（CW）还是逆时针（CCW）。因为路径是封闭的，多次左转和右转相互抵消后，剩余的净转向方向决定了整体的旋转方向。

算法要点在于准确判断每次转向是左转还是右转，并进行相应计数或角度累加。解决难点主要在于正确处理字符串中相邻字符代表的方向转变，以及注意路径首尾相连处的转向判断。

### 所选的题解
1. **作者：zzhbpyy (5星)**
    - **关键亮点**：思路清晰简洁，直接将左转记为 -1，右转记为 +1，通过累加判断结果，代码实现精炼，可读性高。
    - **重点代码**：
```cpp
int init(char a,char b){
    if(a=='N'&&b=='E')return 1;
    if(a=='E'&&b=='S')return 1;
    if(a=='S'&&b=='W')return 1;
    if(a=='W'&&b=='N')return 1;
    return -1;
}
signed main(){
    int n;
    string s;
    cin>>n;
    while(n--){
        ans=0;
        cin>>s;
        for(int i=1;i<s.length();i++){
            if(s[i-1]!=s[i])//与前一个字符不同再判定转弯方向
            ans+=init(s[i-1],s[i]);
        }
        if(ans>0)cout<<"CW\n";
        else cout<<"CCW\n";
    }
}
```
    - **核心思想**：`init` 函数判断相邻字符代表的转向是左转还是右转并返回对应值，主函数遍历字符串，累加转向值，根据结果输出 CW 或 CCW。
2. **作者：__Venti__ (4星)**
    - **关键亮点**：详细地列出判断左转右转的表格，思路阐述清晰，代码逻辑明确，易于理解。
    - **重点代码**：
```cpp
for(int i=0;i<s.size()-1;i++){
    string s1="";//定义一个 s1 储存现在的方向和下一个方向
    s1+=s[i],s1+=s[i+1]; 
    //下面的判断语句根据上面列出的表来判断是右转+1还是左转+1
    if(s1=="NE")r++;//右转+1
    else if(s1=="NW")l++;//左转+1
    else if(s1=="SE")l++;
    else if(s1=="SW")r++;
    else if(s1=="EN")l++;
    else if(s1=="ES")r++;
    else if(s1=="WN")r++;
    else if(s1=="WS")l++;
}
```
    - **核心思想**：通过遍历字符串，将相邻字符组成字符串 `s1`，依据判断表格对 `s1` 判断是左转还是右转，对相应计数器 `l`（左转次数）或 `r`（右转次数）进行累加，最后根据两者大小输出结果。
3. **作者：_luouhgy_ (4星)**
    - **关键亮点**：思路直接，代码简洁明了，以较为基础的方式实现判断逻辑，适合初学者理解。
    - **重点代码**：
```cpp
for(int i=2;i<=len;i++){
    if(s[i-1]=='N' and s[i]=='E'){//北->东
        right+=1;//右转的次数+1
    }
    if(s[i-1]=='E' and s[i]=='S'){//东->南
        right+=1;//右转的次数+1
    }
    if(s[i-1]=='S' and s[i]=='W'){//南->西
        right+=1;//右转的次数+1
    }
    if(s[i-1]=='W' and s[i]=='N'){//西->北 
        right+=1;//右转的次数+1
    }
    if(s[i-1]=='N' and s[i]=='W'){//北->西
        left+=1;//左转的次数+1
    }
    if(s[i-1]=='W' and s[i]=='S'){//西->南 
        left+=1;//左转的次数+1
    }
    if(s[i-1]=='S' and s[i]=='E'){//南->东
        left+=1;//左转的次数+1
    }
    if(s[i-1]=='E' and s[i]=='N'){//东->北 
        left+=1;//左转的次数+1
    }
}
```
    - **核心思想**：遍历字符串，根据相邻字符代表的方向转变判断是左转还是右转，对相应的 `left`（左转次数）和 `right`（右转次数）计数器进行累加，最后根据两者大小输出 CW 或 CCW。

### 最优关键思路或技巧
将左转和右转量化为数值（如 +1 和 -1 或 +90 和 -90），通过遍历路径字符串，统计每次转向对应的数值总和，根据总和的正负判断顺时针或逆时针方向。这种量化思维方式简化了问题的解决过程，提高了代码实现的效率和可读性。

### 可拓展思路
此类题目属于路径方向判断类型，类似套路可应用于其他封闭路径的方向判断问题，如平面上不规则图形的轮廓方向判断。可拓展到更复杂的情况，如路径中存在多次回到起点的情况，此时需要更复杂的状态记录和判断逻辑。

### 推荐题目
1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：涉及对图形边界和内部区域的判断，与本题判断封闭路径内外部情况有相似之处。
2. [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)：需要对字符串进行遍历和判断，与本题遍历字符串判断转向类似，锻炼字符串处理能力。
3. [P1427 小鱼的数字游戏](https://www.luogu.com.cn/problem/P1427)：通过对输入数据的遍历和处理得出结果，有助于理解基本的遍历和判断逻辑，与本题思路有相通之处。

### 个人心得摘录与总结
 - **作者：JOKER_chu**：强调了路径是封闭图形，要注意最后一个操作到第一个操作之间的转向判断，否则像 “WSEN” 这类左转与右转次数相同的数据会无法正确输出。总结为处理封闭路径问题时，务必考虑首尾相连处的特殊情况，避免遗漏关键判断导致结果错误。 

---
处理用时：65.51秒
# 题目信息

# [USACO19JAN] Shell Game B

## 题目描述

为了消磨时光，奶牛 Bessie 和她的朋友 Elsie 喜欢玩一种她们在农业展览会上看到的游戏。

游戏准备阶段，Bessie 在桌子上放置三个倒置的坚果壳，并在其中一个坚果壳下面藏了一块小的鹅卵石（至少她希望这是一块鹅卵石——她在一块牧场的地上找到的）。随后 Bessie 会两两调换坚果壳，同时 Elsie 试着去猜鹅卵石的位置。

奶牛们在农业展览会上看到的这个游戏的标准形式是玩家可以看到鹅卵石初始的位置，然后要求玩家猜所有交换完成之后鹅卵石最终的位置。

然而，现在奶牛们想要去进行这样一种玩法，Elsie 不知道鹅卵石的初始位置，同时她可以在每一次交换之后猜一下鹅卵石的位置。Bessie 知道正确答案，在游戏结束后会给 Elsie 一个分数，等于她猜对的次数。

给定所有的交换和 Elsie 的猜测，但是不给出鹅卵石的初始位置，请求出 Elsie 最高可能获得的分数。 

## 说明/提示

### 样例解释 1

在这个例子中，Elsie 最多可以获得 $2$ 分。如果鹅卵石开始时位于坚果壳 $1$ 下面，那么她猜中了一次（最后一次）。如果鹅卵石开始时位于坚果壳 $2$ 下面，那么她猜中了两次（开始两次）。如果鹅卵石开始时位于坚果壳 $3$ 下面，那么她没有猜对任何一次。 

## 样例 #1

### 输入

```
3
1 2 1
3 2 1
1 3 1```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：这些题解思路基本一致，由于数据范围小（3个坚果壳且操作次数n≤100），均采用暴力枚举法，分别假设鹅卵石初始在3个坚果壳下，模拟每次交换并统计猜对次数，最后取最大值。算法要点在于模拟交换过程和统计猜对情况。解决难点在于清晰模拟交换逻辑，确保每种初始情况的猜对次数准确统计。各题解质量差异不大，主要区别在代码实现细节。
• 所选的题解：
  - 作者：T_TLucas_Yin (4星)
    - 关键亮点：代码简洁明了，通过函数封装模拟过程，逻辑清晰。利用数组f记录杯子对应关系，便于理解交换逻辑。
    - 核心代码：
```cpp
int guess(int k){//k是鹅卵石的位置
    int f[15]={0},cnt=0;
    f[1]=1,f[2]=2,f[3]=3;
    for(int i=1;i<=n;i++){
        swap(f[a[i]],f[b[i]]);
        if(f[c[i]]==k) cnt++;//猜对了一次
    }
    return cnt;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i]>>b[i]>>c[i];
    for(int i=1;i<=3;i++) maxn=max(maxn,guess(i));//三种情况
    cout<<maxn;
    return 0;
}
```
  - 作者：2023gdgz01 (4星)
    - 关键亮点：代码简洁高效，通过inline函数cal计算每种初始位置下的得分，结构清晰。利用数组pos记录坚果壳原始位置，方便交换操作。
    - 核心代码：
```cpp
inline int cal(int p) { //计算鹅卵石在编号为 p 的坚果壳时的分数
    int res = 0;
    int pos[4] = {0, 1, 2, 3}; //pos[i] 表示坚果壳 i 原始的位置
    for (register int i = 1; i <= n; ++i) {
        swap(pos[a[i]], pos[b[i]]); //交换
        if (pos[g[i]] == p)
            ++res;
    }
    return res;
}
int main() {
    scanf("%d", &n);
    for (register int i = 1; i <= n; ++i)
        scanf("%d%d%d", a + i, b + i, g + i);
    printf("%d", max(max(cal(1), cal(2)), cal(3)));
    return 0;
}
```
  - 作者：Yuki_Ever (4星)
    - 关键亮点：思路清晰，通过建立三个布尔数组分别对应三种初始位置，直观地标记和交换鹅卵石位置，便于理解和实现。
    - 核心代码：
```cpp
int q;
bool stone1[4],stone2[4],stone3[4];		//三种情况
int score1,score2,score3;
int main() {
    scanf("%d",&q);
    int a,b,g;
    stone1[1]=1,stone2[2]=1,stone3[3]=1;	//刚开始时石头的位置
    while(q--){
        scanf("%d%d%d",&a,&b,&g);
        swap(stone1[a],stone1[b]);	//换位置
        swap(stone2[a],stone2[b]);
        swap(stone3[a],stone3[b]);
        if(stone1[g]==1)score1++;	//判得分
        if(stone2[g]==1)score2++;
        if(stone3[g]==1)score3++;
    }					//取最大值
    cout<<max(max(score1,score2),score3)<<endl;
    return 0;
} 
```
• 最优关键思路或技巧：利用暴力枚举所有可能的初始位置，通过数组或布尔变量模拟交换过程，清晰记录和统计每种情况下的猜对次数。
• 可拓展之处：同类型题可拓展到更多物品或更复杂交换规则，但数据范围大时暴力枚举可能超时，需考虑优化算法，如采用更高效数据结构或数学方法简化模拟过程。类似算法套路是在数据范围小且可能情况有限时，优先考虑暴力枚举，清晰模拟每种情况来解决问题。
• 推荐洛谷题目：
  - P1036 [NOIP2002 普及组] 选数
  - P1164 小A点菜
  - P1219 [USACO1.5]八皇后 Checker Challenge 

---
处理用时：45.69秒
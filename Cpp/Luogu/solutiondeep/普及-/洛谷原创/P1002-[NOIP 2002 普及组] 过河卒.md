# 题目信息

# [NOIP 2002 普及组] 过河卒

## 题目描述

棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)

现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。

**【题目来源】**

NOIP 2002 普及组第四题

## 样例 #1

### 输入

```
6 6 3 3
```

### 输出

```
6
```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解采用动态规划思路，通过定义状态转移方程 `f[i][j] = f[i - 1][j] + f[i][j - 1]` 来计算从起点到各点的路径条数，同时考虑马的控制点，将其路径数设为0。少数题解使用矩阵乘法和组合数学方法。
    - 算法要点：动态规划题解需注意初始化、边界条件处理以及马的控制点标记。矩阵乘法题解通过连接可达点构建矩阵，利用矩阵快速幂求解。组合数学题解则是通过计算总路径数减去经过马控制特殊点的路径数。
    - 解决难点：主要难点在于处理马的控制点对路径的影响，以及避免数组越界。动态规划题解通过标记马的控制点和合理调整坐标解决；矩阵乘法和组合数学题解则从不同角度分析路径情况来避免。
    - 质量评分：综合思路清晰度、代码可读性、优化程度等方面，Chiaro题解质量最高，不仅详细阐述动态规划思路，还进行滚动数组和一维数组优化，且对 `s` 数组优化有多种方法探讨；kradcigam题解思路清晰，代码简洁，介绍标数法并给出一维优化；yummy题解提供矩阵乘法和小学奥数两种独特方法，但代码较复杂，可读性稍逊。

所选的题解：
  - Chiaro题解（5星）
    - 关键亮点：思路清晰全面，从基础动态规划开始，逐步进行滚动数组和一维数组优化，并对优化 `s` 数组提出多种方法。
    - 个人心得：无
    - 核心代码实现思想：通过状态转移方程计算路径数，利用滚动数组和取模运算减少空间使用，优化 `s` 数组时采用切比雪夫距离和曼哈顿距离缩小判断范围。
    - 核心代码片段：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;

// 快速读入
template <class I>
inline void read(I &num){
    num = 0; char c = getchar(), up = c;
    while(!isdigit(c)) up = c, c = getchar();
    while(isdigit(c)) num = (num << 1) + (num << 3) + (c ^ '0'), c = getchar();
    up == '-'? num = -num : 0; return;
}
template <class I>
inline void read(I &a, I &b) {read(a); read(b);}
template <class I>
inline void read(I &a, I &b, I &c) {read(a); read(b); read(c);}

const int fx[] = {0, -2, -1, 1, 2, 2, 1, -1, -2};
const int fy[] = {0, 1, 2, 2, 1, -1, -2, -2, -1};

int bx, by, mx, my;
ll f[40];
bool s[40][40];

int main(){
    read(bx, by); read(mx, my);
    bx += 2; by += 2; mx += 2; my += 2;
    f[2] = 1;
    s[mx][my] = 1;
    for(int i = 1; i <= 8; i++) s[mx + fx[i]][my + fy[i]] = 1;
    for(int i = 2; i <= bx; i++){
        for(int j = 2; j <= by; j++){
            if(s[i][j]){
                f[j] = 0;
                continue;
            }
            f[j] += f[j - 1];
        }
    }
    printf("%lld\n", f[by]);
    return 0;
} 
```
  - kradcigam题解（4星）
    - 关键亮点：介绍标数法，思路清晰易懂，代码简洁明了，并给出一维优化。
    - 个人心得：无
    - 核心代码实现思想：用 `work` 函数标记马的控制点，通过双重循环和状态转移方程计算路径数，一维优化时利用 `f[i] += f[i - 1]` 实现。
    - 核心代码片段：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a,b,n,m,f[23],ma[23][23];
void work(long long x,long long y){
    ma[x][y]=1;
    ma[x-1][y-2]=1;
    ma[x-2][y-1]=1;
    ma[x-2][y+1]=1;
    ma[x-1][y+2]=1;
    ma[x+1][y-2]=1;
    ma[x+2][y-1]=1;
    ma[x+2][y+1]=1;
    ma[x+1][y+2]=1;
}
int main(){
    scanf("%lld %lld %lld %lld",&n,&m,&a,&b);
    a++;
    b++;
    n++;
    m++;
    work(a,b);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
			if(i==1&&j==1)continue;
        	if(ma[i][j]==0)f[j]+=f[j-1];
        }
    printf("%lld",f[m]);
    return 0;
}
```
  - yummy题解（4星）
    - 关键亮点：提供矩阵乘法和小学奥数两种不同常规思路的解法，拓宽解题视野。
    - 个人心得：无
    - 核心代码实现思想：矩阵乘法通过连接可达点构建矩阵并进行矩阵快速幂；小学奥数通过组合数学公式计算总路径数和经过特殊点路径数。
    - 核心代码片段（矩阵乘法）：
```cpp
#include <bits/stdc++.h>
#define ll long long
#define rint register int
using namespace std;
int a[22][22][22][22];
ll tot[22][22][22][22];
int n,m,x,y;
int judge(int p,int q){
    if(p==x && q==y)
        return 0;
    int px=abs(p-x);
    int qy=abs(q-y);
    int mi=min(px,qy);
    int mx=max(px,qy);
    if(mi==1 && mx==2)
        return 0;
    return 1;
}
ll tmp[22][22][22][22]={0};
void ta(){
    for(int i1=0;i1<=n;i1++)
        for(int i2=0;i2<=m;i2++)
            for(int j1=i1;j1<=n;j1++)
                for(int j2=i2;j2<=m;j2++)
                    for(int k1=i1;k1<=j1;k1++)
                        for(int k2=i2;k2<=j2;k2++)
                            tmp[i1][i2][j1][j2]+=tot[i1][i2][k1][k2]*a[k1][k2][j1][j2];
    memcpy(tot,tmp,sizeof tmp);
}
void tt(){
    for(int i1=0;i1<=n;i1++)
        for(int i2=0;i2<=m;i2++)
            for(int j1=i1;j1<=n;j1++)
                for(int j2=i2;j2<=m;j2++)
                    for(int k1=i1;k1<=j1;k1++)
                        for(int k2=i2;k2<=j2;k2++)
                            tmp[i1][i2][j1][j2]+=tot[i1][i2][k1][k2]*tot[k1][k2][j1][j2];
    memcpy(tot,tmp,sizeof tmp);
}
void pw(int ci){
    if(ci==0)
        return;
    pw(ci>>1);
    tt();
    if(ci&1)
        ta();
}
int main()
{
    cin>>n>>m>>x>>y;
    for(int i=0;i<n;i++)
        for(int j=0;j<=m;j++)
            if(judge(i,j))
                a[i][j][i+1][j]=1;
    for(int i=0;i<=n;i++)
        for(int j=0;j<m;j++)
            if(judge(i,j))
                a[i][j][i][j+1]=1;
    for(int i=0;i<=n;i++)
        for(int j=0;j<=m;j++)
            tot[i][j][i][j]=1;
    pw(n+m);
    cout<<tot[0][0][n][m];
    return 0;
}
```

最优关键思路或技巧：
  - **动态规划优化**：如Chiaro题解中利用滚动数组和一维数组优化空间复杂度，通过取模运算和巧妙的状态转移方程实现。
  - **数学方法应用**：yummy题解中利用矩阵乘法和组合数学知识解题，从不同角度分析问题，拓宽思路。

可拓展之处：
  - **同类型题**：此类题目通常是在网格图中，给定起点、终点和一些限制条件，求从起点到终点的路径数或方案数。
  - **类似算法套路**：可以使用动态规划、组合数学、图论等方法解决。动态规划需合理定义状态和状态转移方程；组合数学要分析路径的组合情况；图论可通过构建图和相应算法求解。

推荐题目：
  - [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)
  - [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)
  - [P1048 采药](https://www.luogu.com.cn/problem/P1048)

个人心得：无

---
处理用时：45.57秒
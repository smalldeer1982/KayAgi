# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解都意识到不能使用二维数组模拟，因为会超空间。主流思路是先存储每张地毯的参数，然后遍历地毯判断给定点是否被覆盖，找到最上面覆盖该点的地毯编号。部分题解选择从后往前遍历地毯，这样遇到第一个覆盖点的地毯即为所求，效率更高。
    - 算法要点：用数组或结构体存储地毯的参数（左上角坐标及长和宽），通过判断点是否在矩形范围内来确定地毯是否覆盖该点。
    - 解决难点：避免使用过大的二维数组，优化空间复杂度。利用地毯按顺序铺设且仅查询一个点的特点，直接遍历地毯判断覆盖情况。

    - 整体来看，大部分题解思路清晰，但在代码风格、优化程度上存在差异。部分题解代码简洁明了，部分题解变量命名不太规范，有些题解未充分利用从后往前遍历的优化技巧。

    - 最优关键思路或技巧：利用地毯铺设顺序和单次查询的特点，从后往前遍历地毯，一旦找到覆盖点的地毯就停止遍历，优化时间复杂度。同时，避免使用超大二维数组，采用数组或结构体存储地毯参数，优化空间复杂度。

    - 可拓展之处：此类题目属于模拟与枚举类型，类似套路是根据题目条件优化遍历方式以减少时间复杂度，如在有顺序关系的数据中从后往前遍历。同类型题可能会增加查询次数，或改变地毯的铺设规则，此时需要考虑如何优化数据结构和算法以适应新需求。

    - 推荐洛谷题目：
        - P1046 [NOIP2005 普及组] 陶陶摘苹果
        - P1909 [NOIP2016 普及组] 买铅笔
        - P1996 [NOIP2013 普及组] 分数线划定

    - 个人心得摘录及总结：部分题解提到开二维数组会导致MLE（内存超限），这是在处理大数据范围题目时常见的错误。总结为在做题时要先分析数据范围，避免使用超出内存限制的数据结构，需寻找更优化的存储和处理方式。

以下题解≥4星：
  - 作者：谁懂谁伤心 (4星)
    - 关键亮点：从后向前遍历地毯，遇到覆盖点的地毯就输出并退出，这种方式优化了时间复杂度，代码简洁明了。
    - 核心代码实现思想：先读入每张地毯的参数并计算出右上角坐标，然后从后向前遍历地毯，判断点是否在地毯范围内，若是则输出编号并结束程序，否则继续遍历，若遍历完都没找到则输出 -1。
    ```cpp
    #include <iostream>  
    using namespace std;  
    int a[10001][2],b[10001][2],x,y,i,n,m;  
    int main()  
    {  
    scanf ("%d",&i);   
    for (int j=1;j<=i;j++) {scanf("%d%d%d%d",&a[j][0],&a[j][1],&n,&m); b[j][0]=a[j][0]+n; b[j][1]=a[j][1]+m;}  
    scanf ("%d%d",&x,&y);  
    for (int j=i;j>=1;j--)  
    if (x>=a[j][0]&&x<=b[j][0]&&y>=a[j][1]&&y<=b[j][1]) {printf("%d",j);  return 0;}  
    cout <<-1;  return 0;  
    }  
    ```
  - 作者：Jayfeather2012 (4星)
    - 关键亮点：思路清晰，从后往前遍历地毯寻找覆盖点的地毯，符合题目中后铺地毯覆盖先铺地毯的逻辑，代码结构清晰。
    - 核心代码实现思想：读入所有地毯参数，从后往前遍历地毯，判断点是否在当前地毯范围内，若在则输出编号并结束程序，若遍历完未找到则输出 -1。
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    int a[10003],b[10003],g[10003],k[10003],n,x,y;
    int main()
    {
        cin>>n;
        for(int i=1;i<=n;i++)cin>>a[i]>>b[i]>>g[i]>>k[i];
        cin>>x>>y;
        for(int i=n;i>=1;i--)
        {
            if(a[i]<=x&&a[i]+g[i]>=x&&b[i]<=y&&b[i]+k[i]>=y)
            //判断所求位置是否被地毯覆盖
            {
                cout<<i;
                return 0;//输出并结束
            }
        }
        cout<<-1;//没有找到输出-1
        return 0;
    }
    ```
  - 作者：kuaiCreator (4星)
    - 关键亮点：指出二维数组模拟会超空间的问题，并采用从后往前遍历地毯的优化方式，代码简洁，变量命名规范。
    - 核心代码实现思想：读入地毯参数，从后往前遍历地毯，判断点是否在地毯范围内，若在则记录编号并跳出循环，最后输出结果，若未找到则输出 -1。
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    const int N = 1e4+5;
    int a[N], b[N], g[N], k[N], n, x, y, ans = -1;
    int main() {
        cin >> n;
        for (int i = 1; i <= n; i++) cin >> a[i] >> b[i] >> g[i] >> k[i];
        cin >> x >> y; 	//点的坐标
        for (int i = n; i >= 1; i--) {
            if (x >= a[i] && x <= a[i] + g[i] && y >= b[i] && y <= b[i] + k[i]) {
                ans = i; //记录答案
                break;
            }
        }
        cout << ans;
        return 0;
    }
    ```

---
处理用时：26.68秒
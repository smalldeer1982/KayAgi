# 题目信息

# [NOIP 2000 普及组] 税收与补贴问题

## 题目背景

每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）

对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）


## 题目描述

你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。

- 总利润 $=$ 单位商品利润 $\times$ 销量
- 单位商品利润 $=$ 单位商品价格 $-$ 单位商品成本（减去税金 或者 加上补贴）


## 说明/提示

### 数据范围及约定

保证输入的所有数字均小于 $10^5$。

### 样例解释（2023/6/22 更新）

如下图所示是输入样例所对应的价格变化图，横轴表示销售价格，纵轴表示销量。

![](https://cdn.luogu.com.cn/upload/image_hosting/21mhtm5i.png)

根据题意，$28$ 元是商品的成本。销售价格不应该低于 $28$ 元；当销售价格大于给出的价格的最大值 $31$ 元后，按照售价每提高一元，销量降低 $15$ 计算，例如当售价为 $33$ 元时，销量为 $110-15\times (33-31)=80$。在给出来的价位之间，销量呈线性变化。

当政府给该商品补贴 $4$ 元后，企业将该商品定价为 $31$ 元时，取得的利润为 $31-28+4=7$ 元，销量为 $110$ 件，总利润为 $7\times 110=770$ 元，是企业在所有定价下能够取得的最大的总利润。此时企业的售价为政府的期望售价，因此是一个合法方案。

## 样例 #1

### 输入

```
31
28 130
30 120
31 110
-1  -1
15```

### 输出

```
4
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何确定政府对商品的税收或补贴金额，使商品在政府预期价格下获取最大总利润。思路上可分为暴力枚举类和数学推导类。暴力枚举类通过遍历所有可能的补贴或税收金额，计算每个金额下各价格的总利润，判断预期价格是否为利润最大的价格；数学推导类则通过解不等式或利用函数性质来确定满足条件的税收或补贴金额范围。各题解在处理销量线性变化、数据完整性以及结果判断等方面各有不同。

所选的题解：
  - **作者：Mitch谜团 (5星)**
    - **关键亮点**：思路清晰，采用暴力枚举法，代码短小精悍，通俗易懂。先处理输入数据，补全价格 - 销量表，再从最小可能的补贴或税收开始枚举，判断在每种情况下总利润最高的价格是否为政府预期价。
    - **个人心得**：强调计算机用于解决问题，采用暴力枚举虽简单直接，但能有效解题。
    - **重点代码**：
```cpp
#include <iostream>
#include <cmath>
using namespace std;
int a[100010][3];//用于存放价格和销量的数组
int main()
{
    int i = 1, j = 1, k, expect, down, max, temp, cha, xl, num, s, price, p;
    cin >> expect;//读入预期价
    while (cin >> a[i][1] >> a[i][2] && a[i][1]!= -1 && a[i][2]!= -1) {
        i++;
        if (i > 2 && a[i - 1][1] - a[i - 2][1] > 1) {
            i--;
            cha = (a[i - 1][2] - a[i][2]) / (a[i][1] - a[i - 1][1]);
            temp = a[i][1];
            for (j = a[i - 1][1] + 1; j <= temp; j++) {
                a[i][1] = j;
                a[i][2] = a[i - 1][2] - cha;
                i++;
            }
        }
    }
    cin >> down;
    i--;
    xl = a[i][2];
    while (xl > 0) {
        if (xl - down < 0) break;
        else {
            xl -= down;
            i++;
            a[i][1] = a[i - 1][1] + 1;
            a[i][2] = xl;
        }
    }
    for (j = 1; j <= 10000; j++) {
        max = -99999;
        for (k = 1; k <= i; k++) {
            num = (a[k][1] - a[1][1] + j) * a[k][2];
            if (num >= max) {
                max = num;
                price = a[k][1];
                p = 1;
            }
        }
        if (price == expect) { cout << j * p; return 0; }
        max = -99999;
        for (k = 1; k <= i; k++) {
            num = (a[k][1] - a[1][1] - j) * a[k][2];
            if (num >= max) {
                max = num;
                price = a[k][1];
                p = -1;
            }
        }
        if (price == expect) { cout << j * p; return 0; }
    }
}
```
核心实现思想：先读入数据并按线性规则补充完整价格 - 销量表，然后分别枚举补贴和税收情况，计算每种情况下各价格的总利润，判断预期价格是否为利润最大的价格，若是则输出对应的补贴或税收金额。

  - **作者：Ofnoname (4星)**
    - **关键亮点**：详细分析题意，通过解不等式确定税收或补贴金额范围。先根据线性关系推出各价位销量，再针对每个价位列出不等式，通过解不等式的技巧得到解集，取绝对值最小的解。
    - **个人心得**：花费较多时间理解题意和解题思路，在细节上遇到问题，通过写题解总结经验。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
#define MAX (100000 + 100)
using namespace std;

int x, r, m, n, p, d[MAX];
double Min = -1e9, Max = 1e9;

inline void read(int &a) {
    register char c = getchar(); bool f = 0;
    for (a = 0; c < '0' || '9' < c; c = getchar())
        if (c == '-') f = 1;
    for (; '0' <= c && c <= '9'; c = getchar())
        a = (a << 3) + (a << 1) + (c ^ 48);
    if (f) a = -a;
}

int main() {
    read(x); read(m); read(n); r = m;
    while (m!= -1 && n!= -1) {
        d[m] = n;
        for (int i = p + 1; i < m; i++)
            d[i] = d[i - 1] + (n - d[p]) / (m - p);
        p = m;
        read(m); read(n);
    }
    read(m);
    while (d[p] > m)
        p++, d[p] = d[p - 1] - m;
    for (register int i = r; i <= p; i++) {
        double ans = (d[x] * (x - r) - d[i] * (i - r)) * 1.0 / (d[i] - d[x]);
        double g = d[i] - d[x];
        if (g > 0) Max = min(Max, ans);
        else Min = max(Min, ans);
    }
    if (Min > 0) printf("%d", (int)ceil(Min));
    else if (Max < 0) printf("%d", (int)floor(Max));
    else puts("0");
    return 0;
}
```
核心实现思想：读入数据后，利用线性关系递推各价位销量，然后针对每个价位解不等式，根据解的符号确定取最大值还是最小值，得到解集后根据解集情况输出结果。

  - **作者：majorli (4星)**
    - **关键亮点**：对问题进行详细的数学描述，从直线方程角度分析，通过模拟找到满足条件的调控量。同时对线性插值、模拟范围以及是否有解等问题进行深入探讨，代码实现清晰。
    - **个人心得**：分析了一些题解中常见结论的不确定性，如线性插值区域是否需插值、能否只模拟目标价格前后两点、本题是否肯定有解等，通过数学推导给出更严谨的解答。
    - **重点代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> sales;
    int target_price, tail_speed;

    cin >> target_price;
    int target_p = -1, len = 0;
    int price, sale, last_price, last_sale;
    cin >> price >> sale;
    sales.push_back(sale);
    last_price = price;
    last_sale = sale;
    if (price == target_price)
        target_p = len;
    len++;
    while ((cin >> price >> sale) && price!= -1 && sale!= -1) {
        int delta_sale = (sale - last_sale) / (price - last_price);
        for (int p = last_price + 1; p < price; p++) {
            last_sale += delta_sale;
            sales.push_back(last_sale);
            if (p == target_price)
                target_p = len;
            len++;
        }
        sales.push_back(sale);
        last_price = price;
        last_sale = sale;
        if (price == target_price)
            target_p = len;
        len++;
    }
    cin >> tail_speed;
    while (last_sale > tail_speed) {
        last_price++;
        last_sale -= tail_speed;
        sales.push_back(last_sale);
        if (last_price == target_price)
            target_p = len;
        len++;
    }

    vector<int> total;
    for (int i = 0; i < len; i++)
        total.push_back(i * sales[i]);

    int max_forward, max_backward, x = 0;
    while (true) {
        max_forward = *max_element(total.begin(), total.begin() + target_p);
        max_backward = *max_element(total.begin() + target_p + 1, total.end());
        int t = total[target_p];
        if (max_forward <= t && max_backward <= t) {
            cout << x << endl;
            break;
        }
        else if (max_forward >= t && max_backward >= t) {
            cout << "NO SOLUTION" << endl;
            break;
        }
        if (max_forward > t) {
            for (int i = 0; i < len; i++)
                total[i] -= sales[i];
            x--;
        }
        else {
            for (int i = 0; i < len; i++)
                total[i] += sales[i];
            x++;
        }
    }

    return 0;
}
```
核心实现思想：读入数据并补全价格 - 销量表，以目标价格为分界点将数据分为两部分，通过比较前后两部分总利润的最大值与目标价格总利润的大小关系，逐步调整调控量，直到找到满足条件的解或确定无解。

最优关键思路或技巧：暴力枚举法简单直接，易于理解和实现；数学推导类方法通过建立不等式或利用函数性质，能更高效地确定结果，但需要较强的数学基础。在处理销量线性变化时，合理利用线性关系递推销量，以及在判断结果时严谨分析各种情况，都是解题的关键。

可拓展之处：同类型题可涉及其他经济调控场景下的最优策略问题，或在数据变化规律上更复杂的利润最大化问题。类似算法套路包括利用数学模型解决实际优化问题，以及在暴力枚举基础上根据题目特点进行合理优化。

推荐洛谷题目：
  - P1024 [NOIP2001 提高组] 一元三次方程求解，通过枚举或二分查找求解方程根，考察数值计算和搜索策略。
  - P1160 队列安排，涉及链表或数组模拟队列操作，通过调整元素位置满足特定条件，与本题处理数据和寻找最优解思路类似。
  - P1223 排队接水，根据时间优化排队顺序，利用贪心策略解决实际问题，与本题优化思想相关。 

---
处理用时：47.73秒
# 题目信息

# [NOIP 2001 提高组] 一元三次方程求解

## 题目描述

有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。

提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。

## 说明/提示

**【题目来源】**

NOIP 2001 提高组第一题

## 样例 #1

### 输入

```
1 -5 -4 20
```

### 输出

```
-2.00 2.00 5.00
```

# AI分析结果

### 综合分析与结论
这些题解主要采用了暴力枚举、二分法、牛顿迭代法、割线法以及公式法（盛金公式、卡尔丹公式）来求解一元三次方程。暴力枚举直接在给定区间按一定步长遍历寻找根；二分法利用函数值异号确定根所在区间并二分查找；牛顿迭代法通过构造切线与x轴交点不断逼近根；割线法是对牛顿法的改进，用割线斜率代替导数；公式法则直接利用特定公式计算方程的根。

各方法的难点主要在于对算法原理的理解与实现细节。如牛顿迭代法需理解迭代公式的推导及收敛性，公式法要准确记忆和应用复杂公式。从质量上看，部分题解思路清晰、代码简洁，部分题解在代码可读性或优化上有所欠缺。

### 所选的题解
- **北街的九命貓**：★★★★
    - **关键亮点**：思路清晰，结合二分法与题目所给根的条件，通过枚举长度为1的区间并在区间内二分查找根，代码简洁明了，注释详细。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<cstdio>
double a,b,c,d;
double fc(double x)
{
    return a*x*x*x+b*x*x+c*x+d;
}
int main()
{
    double l,r,m,x1,x2;
    int s=0,i;
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);  //输入
    for (i=-100;i<100;i++)
    {
        l=i; 
        r=i+1;
        x1=fc(l); 
        x2=fc(r);
        if(!x1) 
        {
            printf("%.2lf ",l); 
            s++;
        }      //判断左端点，是零点直接输出。
        if(x1*x2<0)                             //区间内有根。
        {
            while(r-l>=0.001)                     //二分控制精度。
            {
                m=(l+r)/2;  //middle
                if(fc(m)*fc(r)<=0) 
                   l=m; 
                else 
                   r=m;   //计算中点处函数值缩小区间。
            }
            printf("%.2lf ",r);  
            //输出右端点。
            s++;
        }
        if (s==3) 
            break;             
            //找到三个就退出大概会省一点时间
    }
    return 0;
}
```
核心实现思想：先定义函数fc计算方程值，通过循环枚举长度为1的区间，判断区间端点函数值，若左端点为0直接输出；若区间两端点函数值异号，则在区间内二分查找根，找到三个根后退出循环。

- **GGN_2015**：★★★★
    - **关键亮点**：采用牛顿迭代法，详细解释了牛顿迭代法原理，代码实现中封装了函数对象，使代码结构清晰，还通过set集合保证根的唯一性。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<cstdio>
#include<complex>
#include<algorithm>
#include<set>
using namespace std;

struct func3
{
    double a,b,c,d;
    func3(double A=0,double B=0,double C=0,double D=0){a=A;b=B;c=C;d=D;}
    double operator()(double x){return ((a*x+b)*x+c)*x+d;}
    double dvt(double x){return (3.0*a*x+2.0*b)*x+c;}
};

void func3solve(func3 f,double st,double& val,double& sol)
{
    for(int i=1;!(abs(f(st))<1e-6) && i<=100;i++)
    {
        st=st-f(st)/f.dvt(st);
    }
    val=f(st);sol=st;
}

double fix2(double sol)
{
    return (double)int(sol*100.0+(sol>0?0.5:-0.5))/100.0;
}

set<double>solutions;
int main()
{
    double a,b,c,d;
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
    func3 f(a,b,c,d);
    for(double i=-100.0;i<=100.0;i+=0.5)
    {
        double val,sol;
        func3solve(f,i,val,sol);
        sol=fix2(sol);
        if(abs(val)<1e-6 && solutions.find(sol)==solutions.end())
            solutions.insert(sol);
    }
    for(set<double>::iterator it=solutions.begin();it!=solutions.end();it++)
    {
        double x=(*it);
        printf("%.2lf ",x);
    }
    return 0;
}
```
核心实现思想：定义func3结构体表示函数及其导数，func3solve函数实现牛顿迭代法，在主函数中按步长遍历区间，对每个起始点进行牛顿迭代求解，将符合条件的根存入set集合，最后输出集合中的根。

### 最优关键思路或技巧
二分法结合根的范围与函数值异号条件来确定根的位置，这种方法思路清晰，实现简单，且能有效利用题目给定信息，避免不必要的计算。牛顿迭代法收敛速度较快，通过不断构造切线逼近根，但需理解和正确实现迭代公式。

### 可拓展思路
此类题目可拓展到求解更高次方程或带有其他限制条件的方程。类似算法套路包括利用函数性质（如单调性、连续性）来缩小根的查找范围，以及使用迭代法不断逼近精确解。

### 相似知识点洛谷题目
1. [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)：涉及到树的遍历与数值计算，与本题类似在于需要根据给定条件进行数值的求解与处理。
2. [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)：运用二分查找思想，在一定范围内寻找满足条件的最优解，和本题二分法找根思路相似。
3. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)：通过二分答案来解决问题，与本题利用二分法确定根的位置有相似的思维方式。 

---
处理用时：33.22秒
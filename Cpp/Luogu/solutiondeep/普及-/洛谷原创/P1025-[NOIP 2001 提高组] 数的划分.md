# 题目信息

# [NOIP 2001 提高组] 数的划分

## 题目描述

将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。

例如：$n=7$，$k=3$，下面三种分法被认为是相同的。

$1,1,5$;   
$1,5,1$;   
$5,1,1$.

问有多少种不同的分法。


## 说明/提示

四种分法为：  
$1,1,5$;  
$1,2,4$;  
$1,3,3$;  
$2,2,3$.

**【题目来源】**

NOIP 2001 提高组第二题

## 样例 #1

### 输入

```
7 3
```

### 输出

```
4
```

# AI分析结果

• 综合分析与结论：这些题解主要涉及动态规划（DP）、深度优先搜索（DFS）及母函数三种算法。DP解法通过状态转移方程计算方案数，DFS通过递归枚举并剪枝优化，母函数则将问题转化为数学方程求解。DP和DFS是较常见思路，母函数理解与实现难度较大。从质量看，部分题解思路清晰、代码简洁且有优化，部分在思路阐述或代码规范上有提升空间。
  - 作者：s_r_f (4星)
    - 关键亮点：思路清晰，直接阐述DP解法，定义状态转移方程明确，代码简洁明了。
    - 核心代码实现思想：定义`f[i][x]`表示`i`分成`x`个非空数的方案数，通过双重循环遍历`i`和`x`，根据状态转移方程`f[i][x]=f[i-1][x-1]+f[i-x][x]`（`i>x`时）或`f[i][x]=f[i-1][x-1]`（`i<=x`时）进行计算，最后输出`f[n][k]`。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,f[201][7];  
int main(){
    cin >> n >> k;
    for (int i=1;i<=n;i++) {f[i][1]=1;f[i][0]=1;}
    for (int x=2;x<=k;x++) {f[1][x]=0;f[0][x]=0;}  
    for (int i=2;i<=n;i++)
        for (int x=2;x<=k;x++)
            if (i>x) f[i][x]=f[i-1][x-1]+f[i-x][x];
            else f[i][x]=f[i-1][x-1];
    cout<<f[n][k];
    return 0;
}
```
  - 作者：Trinity (4星)
    - 关键亮点：提供三种解法，涵盖DFS、DP和母函数，对每种解法分析详细，思路清晰，代码有注释辅助理解。
    - DFS核心代码实现思想：`dfs`函数中，`num`表示剩余待分的数，`part`表示分的机会数，`now`表示现在要选出的数。通过递归，从`now`到`num/part`枚举`i`，累加`dfs(num - i, part - 1, i)`结果统计方案数。
```cpp
//搜索（dfs）+剪枝
int n,k;
inline int dfs(int num,int part,int now)
{
  if(part==1)return 1;
  int sum=0;
  for(int i=now;i<=num/part;i++)
    sum+=dfs(num-i,part-1,i);
  return sum;
}
int main()
{
  n=read(),k=read();
  printf("%d",dfs(n,k,1));
  return 0;
}
```
    - DP核心代码实现思想：与s_r_f的DP思路类似，通过双重循环遍历`i`和`j`，根据状态转移方程`f[i][j]=f[i-1][j-1]+f[i-j][j]`（`i>=j`时）计算方案数，最后输出`f[n][k]`。
```cpp
//动态规划(不如说是递推)
int n,k,f[N][N];
int main()
{
  n=read(),k=read();
  for(int i=1;i<=n;i++)f[i][1]=1;
  for(int i=1;i<=n;i++)
    for(int j=2;j<=k;j++)
        if(i>=j)f[i][j]=f[i-1][j-1]+f[i-j][j];
  printf("%d\n",f[n][k]);
  return 0;
}
```
  - 作者：Clouder (4星)
    - 关键亮点：对DP解法深入分析，从朴素转移方程优化到高效方程，还介绍空间优化（滚动数组）和指针映射优化效率，内容全面深入。
    - 核心代码实现思想：通过指针映射优化空间和时间，定义`f[i]`指向`dp[pos(i)]`，通过双重循环，根据转移方程`f[i][j] = (f[i - j][j] + f[i - 1][j - 1]) % 10086`计算方案数，最后输出`f[n][k]`。
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
int n, k;
int dp[610][610];
int *f[200100];
inline int min(const int &a,const int &b){return a<b?a:b;}
int main()
{
    scanf("%d%d", &n, &k);
    int p = 0;
    for (int i = 0; i <= n; ++i)
    {
        if (p >= 600)
            p -= 600;
        f[i] = dp[p + 1];
        ++p;
    }
    f[0][0] = 1;
    int i, j;
    for (i = 1; i <= n; ++i)
    {
        memset(f[i], 0, sizeof(f[i]));
        for (j = min(k,i); j; --j)
            f[i][j] = (f[i - j][j] + f[i - 1][j - 1]) % 10086;
    }
    printf("%d", f[n][k]);
    return 0;
}
```
• 最优关键思路或技巧：DP解法的状态转移方程`f[i][x]=f[i-1][x-1]+f[i-x][x]`是核心，通过分析问题将其转化为子问题求解。DFS剪枝通过确定上下界减少无效搜索。空间优化和指针映射技巧在数据范围大时提升效率。
• 同类型题或类似算法套路：此类题常涉及组合计数，可通过DP、DFS或数学方法解决。类似套路有根据问题定义状态和状态转移方程，DFS时合理剪枝，注意优化空间和时间复杂度。
• 洛谷相似题目：
  - P1281 [SCOI2012]奇怪的游戏：涉及染色、二分、网络流，与本题组合计数思想相关。
  - P1650 田忌赛马：动态规划问题，与本题通过状态转移求解方案数思路类似。
  - P1002 [NOIP2002 普及组] 过河卒：同样是用动态规划解决路径计数问题。
• 个人心得：作者Clouder分享了优化过程，从DP朴素方程到优化方程，再到空间优化和指针映射优化，遇到TLE和MLE问题逐步解决，体现优化算法时需综合考虑时间和空间复杂度。 

---
处理用时：33.57秒
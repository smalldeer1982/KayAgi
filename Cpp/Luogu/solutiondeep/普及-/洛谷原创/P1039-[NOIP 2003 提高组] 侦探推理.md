# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！



## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路大多基于枚举法，利用题目中数据范围小的特点来解题。主要存在两种枚举策略：一是枚举罪犯和日期，判断是否符合说谎人数条件；二是枚举说谎者组合，验证证言是否矛盾并确定罪犯。题解的主要难点在于字符串处理，需准确解析各种证词并判断其真假。部分题解还涉及对输入格式（如换行符）的处理。

### 所选的题解
- **作者：Drifterming (赞：89)  星级：5星**
    - **关键亮点**：思路清晰，代码结构良好。通过枚举罪犯和日期，利用数组记录每个人说话的真假状态，在判断过程中及时处理矛盾情况，减少无效枚举。
    - **个人心得**：无
    - **核心代码**：
```cpp
bool judgeTF(int id,bool flag) {
    if(TF[id]==-1) {
        TF[id]=flag;
        if(flag) ++T;
        else ++F;
    }
    else return TF[id]!=flag;
    if(F>n||T>m-n) return 1;
    return 0;
}

void judge(int id,string day) {
    memset(TF,-1,sizeof(TF));
    T=F=0;
    string tmp;
    for(int i=1;i<=p;++i) {
        int pos=sen[i].s.find("I am guilty.");
        if(~pos) {
            if(judgeTF(sen[i].id,sen[i].id==id)) return;
        }
        pos=sen[i].s.find("I am not guilty");
        if(~pos) {
            if(judgeTF(sen[i].id,sen[i].id!=id)) return;
        }
        pos=sen[i].s.find(" is guilty.");
        if(~pos) {
            tmp=sen[i].s;
            tmp.erase(pos,11);
            if(judgeTF(sen[i].id,ma[tmp]==id)) return;
        }
        pos=sen[i].s.find(" is not guilty.");
        if(~pos) {
            tmp=sen[i].s;
            tmp.erase(pos,15);
            if(judgeTF(sen[i].id,ma[tmp]!=id)) return;
        }
        pos=sen[i].s.find("Today is ");
        if(~pos) {
            if(judgeTF(sen[i].id,sen[i].s==day)) return;
        }
    }
    if(ans&&ans!=id) {
        puts("Cannot Determine");
        exit(0);
    }
    ans=id;
}
```
    - **核心思想**：`judgeTF`函数用于判断当前说话者的话是否与之前状态冲突，`judge`函数通过枚举每句话，依据不同证词类型判断真假，若出现矛盾则返回，若成功且之前已确定其他罪犯则输出“Cannot Determine”，否则更新罪犯。
- **作者：wjyyy (赞：18)  星级：4星**
    - **关键亮点**：利用`std::map`和`std::vector`等STL容器简化代码实现，通过记录每个人说的合法话，枚举罪犯和日期，并考虑不确定说话真假的人，根据说谎人数范围判断结果。
    - **个人心得**：注意到题目需确定每句话每个单词合法才能认定整句话合法，强调`stl`在字符串处理和数据存储上的便利性。
    - **核心代码**：
```cpp
for(int i=1;i<=n;++i) {
    for(int j=1;j<=7;++j) {
        int flag=0,cnt=n,ran=0;
        for(int k=1;!flag&&k<=n;++k) {
            vector<sta>::iterator it=v[k].begin();
            if(!v[k].size()) {
                ++ran;
                continue;
            }
            sta tmp=*it;
            bool rea;
            if(tmp.to) rea=(tmp.u==j);
            else rea=((tmp.u==i)^(!tmp.is));
            ++it;
            for(;!flag&&it!=v[k].end();++it) {
                if(it->to) {
                    if(rea!=(it->u==j)) flag=1;
                }
                else {
                    if(rea==((it->u==i)^it->is)) flag=1;
                }
            }
            cnt-=rea;
        }
        if(!flag&&cnt>=m&&cnt-ran<=m) {
            if(ans=="") ans=nm[i];
            else if(ans!=nm[i]) {
                cout<<"Cannot Determine"<<endl;
                return 0;
            }
        }
    }
}
```
    - **核心思想**：双重循环枚举罪犯`i`和日期`j`，对于每个人，根据其说的话判断真假，若有矛盾则设`flag`为1，统计说谎人数`cnt`和不确定人数`ran`，若满足说谎人数范围且无矛盾，则更新答案，若答案已存在且与当前不同则输出“Cannot Determine”。
- **作者：stevewen (赞：2)  星级：4星**
    - **关键亮点**：代码简洁明了，同样采用枚举罪犯和日期的方法，利用`map`记录人名编号，通过自定义函数判断每句话的真假，根据判断结果记录或输出答案。同时考虑到不同操作系统换行符问题对代码进行了兼容处理。
    - **个人心得**：使用`getline`读入时会因Linux和Windows换行符不同导致问题，通过对读入字符串末尾字符判断和处理来兼容。
    - **核心代码**：
```cpp
bool pdTF(int id,bool b) {
    if(TF[id]==-1) {
        TF[id]=b;
        if(b)++T;else ++F;
    }
    else {
        if(TF[id]==b)return 0;else return 1;
    }
    if(F>m||T>n-m)return 1;
    return 0;
}

void Judge(int Xs,string day) {
    memset(TF,-1,sizeof(TF));
    T=F=0;
    for(int i=1;i<=p;++i) {
        int pos;
        pos=f[i].st.find("I am guilty.");
        if(~pos) {
            if(pdTF(f[i].id,f[i].id==Xs))return;
        }
        pos=f[i].st.find("I am not guilty.");
        if(~pos) {
            if(pdTF(f[i].id,f[i].id!=Xs))return;
        }
        pos=f[i].st.find(" is guilty.");
        if(~pos) {
            string now=f[i].st;
            now.erase(pos,11);
            int id=num[now];
            if(pdTF(f[i].id,id==Xs))return;
        }
        pos=f[i].st.find(" is not guilty.");
        if(~pos) {
            string now=f[i].st;
            now.erase(pos,15);
            int id=num[now];
            if(pdTF(f[i].id,id!=Xs))return;
        }
        pos=f[i].st.find("Today is ");
        if(~pos) {
            if(pdTF(f[i].id,f[i].st==day))return;
        }
    }
    if(ans&&ans!=Xs) {
        cout<<"Cannot Determine"<<endl;
        exit(0);
    }
    ans=Xs;
}
```
    - **核心思想**：`pdTF`函数判断当前人的话与之前状态是否冲突，`Judge`函数枚举每句话，依据不同证词类型调用`pdTF`判断，若有矛盾则返回，若成功且之前已确定其他罪犯则输出“Cannot Determine”，否则更新罪犯。

### 最优关键思路或技巧
- **枚举策略**：利用题目数据范围小的特点，通过枚举罪犯和日期或者枚举说谎者组合来遍历所有可能情况，是解决此类逻辑推理问题的有效方法。
- **字符串处理**：使用`map`来映射人名与编号，方便快速查找；运用`string`的各种函数（如`find`、`substr`等）解析证词，准确提取关键信息。
- **状态记录与判断**：用数组或结构体记录每个人说话的真假状态以及相关信息，在枚举过程中根据已知条件及时判断并处理矛盾情况，减少不必要的计算。

### 可拓展思路
此类逻辑推理题可拓展到更复杂的场景，如增加人物关系、更多类型的条件限制等。类似算法套路包括通过枚举所有可能情况，结合条件判断筛选出符合要求的解。在处理复杂字符串输入时，要熟练运用字符串处理函数和数据结构。

### 相似知识点洛谷题目
- **P1036 [NOIP2002 普及组] 选数**：通过枚举不同的数的组合，结合条件判断来求解，考查枚举思想和基本的逻辑判断。
- **P1157 组合的输出**：需要按照要求枚举所有可能的组合情况并输出，与本题枚举思路类似，锻炼对枚举算法的运用。
- **P1433 吃奶酪**：通过枚举不同的路径顺序，结合距离计算和条件判断找到最优解，涉及枚举和简单的计算，与本题在思维方式上有相似之处。 

---
处理用时：59.96秒
# 题目信息

# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# AI分析结果

• 综合分析与结论：这些题解均围绕“加分二叉树”问题，采用动态规划算法求解。思路上，通过设计状态表示子树最大加分，利用状态转移方程计算最优解，并记录根节点以输出前序遍历。算法要点在于合理定义状态和转移方程，难点是处理边界情况（如空子树分数）和理解无后效性。

所选的题解：
  - **作者：冒泡ioa (5星)**
    - **关键亮点**：思路阐述清晰，从动态规划基本概念出发，逐步推导状态设计和转移方程，代码简洁明了且有详细注释。
    - **重点代码**：
```c++
// 输出前序遍历
void print(ll l, ll r) {
    if (l > r)return;
    printf("%lld ", root[l][r]);
    if (l == r)return;
    print(l, root[l][r] - 1);
    print(root[l][r]+1,r);
}

int main() {
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++)scanf("%lld", &f[i][i]),f[i][i-1]=1, root[i][i] = i;
    for (int len = 1; len < n; ++len) {
        for (int i = 1; i + len <= n; ++i) {
            int j = i + len;
            f[i][j] = f[i + 1][j] + f[i][i];//默认它的左子树为空，如果有的话，这肯定不是最优解
            root[i][j] = i;//默认从起点选根
            for (int k = i + 1; k < j; ++k) {
                if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                    f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                    root[i][j] = k;
                }
            }
        }
    }
    cout << f[1][n] << endl;
    print(1, n);
    return 0;
}
```
    - **核心思想**：定义`f[i][j]`表示节点`i`到`j`成树的最大加分，`root[i][j]`记录对应根节点。通过枚举区间长度、起点和根节点，利用状态转移方程`f[i][j]=MAX(f[i][k - 1]*f[k + 1][j]+f[k][k])`计算最大加分，并递归输出前序遍历。

  - **作者：winmt (4星)**
    - **关键亮点**：将问题分解为三个任务，详细阐述每个任务的实现思路，采用递归的记忆化搜索方式，对动态规划的过程解释清晰。
    - **重点代码**：
```c++
// 递归计算f[L][r]
long long search(int L, int r)    {
    int  k;
    long long  now, ans;    
    if (L > r) return 1;
    if (f[L][r]== -1)     
        for(k=L; k<=r; k++) {     
            now = search(L, k-1) * search(k+1, r) + f[k][k];  
            if(now > f[L][r])  {
                f[L][r] = now; 
                root[L][r] = k;
            }
        }
    return  f[L][r];   
}

// 前序遍历顶点L..顶点r对应的子树
void  preorder(int L, int r)
{
    if (L > r)  return;
    if (firstwrite)
        firstwrite = false;
    else
        cout<<‘ ‘;      
    cout << root[L][r];             
    preorder(L, root[L][r]-1);     
    preorder(root[L][r]+1, r);     
}
```
    - **核心思想**：`search`函数递归计算`f[L][r]`，记忆化处理避免重复计算。`preorder`函数根据记录的根节点按根→左子树→右子树顺序输出前序遍历。

  - **作者：噬月 (4星)**
    - **关键亮点**：详细分析了问题的最优子结构和无后效性，对状态转移方程的推导和边界情况讨论深入，代码注释详尽。
    - **重点代码**：
```c++
void print(long long l, long long r) {
    if (l > r) {
        return;
    }
    printf("%lld ", root[l][r]);
    if (l == r) {
        return;
    }
    print(l, root[l][r] - 1);
    print(root[l][r] + 1, r);
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++ i ) {
        cin >> f[i][i];
        f[i][i - 1] = 1;
        f[i + 1][i] = 1;
        root[i][i] = i;
    }
    for (int range = 1; range <= n; ++ range ) {
        for (int i = 1; i + range <= n; ++ i ) {
            int j = i  + range;
            for (int k = i ; k <= j; ++ k ) {
                if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                    f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                    root[i][j] = k;
                }
            }
        }
    }
    cout << f[1][n] << endl;
    print(1, n);
    return 0;
}
```
    - **核心思想**：与其他题解类似，定义`f[i][j]`和`root[i][j]`，通过枚举区间范围、起点和根节点计算最大加分，`print`函数递归输出前序遍历，同时对边界情况进行了特殊处理。

**最优关键思路或技巧**：利用区间动态规划，将原问题分解为多个子问题，通过合理定义状态和状态转移方程求解。在处理空子树时，将其分数设为1，保证状态转移的正确性。记录根节点以方便输出前序遍历。

**可拓展之处**：此类问题属于树形动态规划或区间动态规划类型，类似套路可用于处理具有最优子结构和无后效性的树形或区间问题，如石子合并、矩阵连乘等。

**推荐题目**：
  - [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
  - [P4170 [CQOI2007] 涂色](https://www.luogu.com.cn/problem/P4170)
  - [P1063 [NOIP2006 提高组] 能量项链](https://www.luogu.com.cn/problem/P1063)

**个人心得摘录与总结**：噬月对状态转移方程中不等号改为等号的影响以及边界情况进行了深入讨论，得出修改不等号会改变前序遍历结果，而边界默认处理不影响最终答案的结论，为理解和调试代码提供了重要参考。 

---
处理用时：34.27秒
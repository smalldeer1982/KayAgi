# 题目信息

# [NOIP 2005 普及组] 循环

## 题目描述

乐乐是一个聪明而又勤奋好学的孩子。他总喜欢探求事物的规律。一天，他突然对数的正整数次幂产生了兴趣。


众所周知，$2$ 的正整数次幂最后一位数总是不断的在重复 $2,4,8,6,2,4,8,6…$ 我们说 $2$ 的正整数次幂最后一位的循环长度是 $4$（实际上 $4$ 的倍数都可以说是循环长度，但我们只考虑最小的循环长度）。类似的，其余的数字的正整数次幂最后一位数也有类似的循环现象：

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c}\hline
\textbf{数字}& \textbf{循环} & \textbf{循环长度} \cr\hline\hline
2 & 2,4,8,6 & 4\cr\hline
3 & 3,9,7,1 & 4\cr\hline
4 & 4,6 & 2\cr\hline
5 & 5 &  1\cr\hline
6 & 6 & 1\cr\hline
7 & 7,9,3,1 & 4\cr\hline
8 & 8,4,2,6 & 4\cr\hline
9 & 9,1 & 2\cr\hline
\end{array}
$$

这时乐乐的问题就出来了：是不是只有最后一位才有这样的循环呢？对于一个整数 $n$ 的正整数次幂来说，它的后 $k$ 位是否会发生循环？如果循环的话，循环长度是多少呢？

注意：

1. 如果 $n$ 的某个正整数次幂的位数不足 $k$，那么不足的高位看做是 $0$。
2. 如果循环长度是 $L$，那么说明对于任意的正整数 $a$，$n$ 的 $a$ 次幂和 $a+L$ 次幂的最后 $k$ 位都相同。


## 说明/提示

**【数据范围】**

对于 $30 \%$ 的数据，满足 $k \le 4$；  
对于$100 \%$ 的数据，满足 $1 \le n < {10}^{100}$，$1 \le k \le 100$。

**【题目来源】**

NOIP 2005 普及组第四题

## 样例 #1

### 输入

```
32 2```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效求解整数 $n$ 的正整数次幂后 $k$ 位的循环长度展开。
 - **思路方面**：多数题解采用递推思路，利用后 $w$ 位循环节长度推出后 $w + 1$ 位循环节长度；部分题解还涉及欧拉定理、暴力模拟等方法。
 - **算法要点**：需处理高精度运算，包括高精乘高精、高精乘低精，并结合取模操作。同时要判断循环是否存在及确定循环长度。
 - **解决难点**：难点在于优化时间复杂度，避免暴力枚举超时；理解并利用后 $w$ 位与后 $w + 1$ 位循环节长度的关系；以及高精度运算的实现。

综合来看，各题解质量参差不齐，部分题解思路清晰、代码实现较优，部分题解在思路阐述或代码可读性上有所欠缺。

### 所选的题解
1. **作者：_Life_ (5星)**
    - **关键亮点**：思路清晰，对递推过程手玩数据详细解释，帮助理解。代码实现简洁，自定义高精度结构体并重载乘法运算符。
    - **个人心得**：因最高赞题解无计算过程，自己手玩数据后补充该过程形成此篇题解。
    - **核心代码**：
```cpp
struct bignum
{
    int x[205];
    bignum(){memset(x,0,sizeof(x));}
};
bignum operator *(bignum a,bignum b)//特化过的高精乘 只取后k位
{
    bignum ans;
    for(int i=0;i<k;i++)
        for(int j=0;j<k;j++)
            ans.x[i+j]+=a.x[i]*b.x[j];
    for(int i=0;i<k;i++)ans.x[i+1]+=ans.x[i]/10,ans.x[i]%=10;
    for(int i=k;i<205;i++)ans.x[i]=0;
    return ans;
}
bignum operator *(bignum a,int b)//这个高精乘低精是ans专用的233
{
    for(int i=0;i<=200;i++)a.x[i]*=b;
    for(int i=0;i<=200;i++)a.x[i+1]+=a.x[i]/10,a.x[i]%=10;
    return a;
}
```
核心实现思想：通过重载 `*` 运算符实现高精度乘法，在高精乘高精中，计算乘积并处理进位，只保留后 $k$ 位；高精乘低精类似，同样处理进位。

2. **作者：MyukiyoMekya (4星)**
    - **关键亮点**：利用欧拉定理确定循环长度可能值范围，通过枚举质因子优化快速幂检测，采用高精压8位优化时间复杂度。
    - **核心代码**：
```cpp
Bigint operator * (const Bigint &nt) const
{
    Bigint res;res.clear();
    res.n=min(105ll,n+nt.n);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=nt.n;++j)
            if(i+j-1<=k)
                res.a[i+j-1]+=a[i]*nt.a[j];
    for(int i=1;i<=res.n;++i)
        res.a[i+1]+=res.a[i]/base,res.a[i]%=base;
    res.work();
    return res;
}
```
核心实现思想：重载 `*` 运算符实现高精度乘法，计算乘积并处理进位，根据结果调整高精度数的有效位数。

3. **作者：vectorwyx (4星)**
    - **关键亮点**：从数学角度严谨证明后 $w + 1$ 位循环节长度与后 $w$ 位循环节长度的倍数关系，利用该关系递推求解，代码简洁明了。
    - **核心代码**：
```cpp
num operator*(const num &x) const{
    num ret;
    fo(i,1,len)
        fo(j,1,min(x.len,k-i+1)) ret.a[i+j-1]+=a[i]*x.a[j];
    ret.len=min(k,len+x.len-1);
    fo(i,1,ret.len) ret.a[i+1]+=ret.a[i]/10,ret.a[i]%=10;
    if(ret.a[ret.len+1]) ret.len=min(ret.len+1,k);
    return ret;
}
```
核心实现思想：重载 `*` 运算符实现高精度乘法，计算乘积并处理进位，根据结果调整高精度数的长度，只保留后 $k$ 位。

### 最优关键思路或技巧
 - **递推思想**：利用后 $w$ 位循环节长度是后 $w + 1$ 位循环节长度的因子这一关系，从后往前逐位递推，减少计算量。
 - **高精度优化**：采用高精压位技术，如将高精度数按8位存储，减少高精度乘法运算次数，优化时间复杂度。

### 同类型题或类似算法套路拓展
此类题目通常涉及数论中的同余问题，结合高精度运算。类似算法套路为利用数论性质确定循环节长度的范围或关系，通过递推或枚举等方式求解。例如，对于一些与幂次、循环节相关的问题，可先分析低位情况，寻找规律，再推广到高位。

### 推荐题目
 - [P1009 阶乘之和](https://www.luogu.com.cn/problem/P1009)：涉及高精度加法和乘法，与本题高精度运算有相似之处。
 - [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)：同样需要处理高精度运算，同时结合数论知识。
 - [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)：考查数论知识和优化算法，与本题在思维和优化方面有共通点。

---
处理用时：31.35秒
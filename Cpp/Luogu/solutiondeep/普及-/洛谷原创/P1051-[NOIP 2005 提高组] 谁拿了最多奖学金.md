# 题目信息

# [NOIP 2005 提高组] 谁拿了最多奖学金

## 题目描述

某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：

1. 院士奖学金，每人 $8000$ 元，期末平均成绩高于 $80$ 分（$>80$），并且在本学期内发表$1$篇或$1$篇以上论文的学生均可获得；
2. 五四奖学金，每人 $4000$ 元，期末平均成绩高于 $85$ 分（$>85$），并且班级评议成绩高于 $80$ 分（$>80$）的学生均可获得；
3. 成绩优秀奖，每人 $2000$ 元，期末平均成绩高于 $90$ 分（$>90$）的学生均可获得；
4. 西部奖学金，每人 $1000$ 元，期末平均成绩高于 $85$ 分（$>85$）的西部省份学生均可获得；
5. 班级贡献奖，每人 $850$ 元，班级评议成绩高于 $80$ 分（$>80$）的学生干部均可获得；

只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是 $87$ 分，班级评议成绩 $82$ 分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是 $4850$ 元。

现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，满足 $1 \le  N \le  100$。

**【题目来源】**

NOIP 2005 提高组第一题

## 样例 #1

### 输入

```
4
YaoLin 87 82 Y N 0
ChenRuiyi 88 78 N Y 1
LiXin 92 88 N N 0
ZhangQin 83 87 Y N 1
```

### 输出

```
ChenRuiyi
9000
28700
```

# AI分析结果

### 综合分析与结论
这些题解思路总体一致，均是通过结构体存储学生信息，按题目给定的奖学金获取条件计算每个学生的奖学金，再找出奖金最多的学生并输出相关信息。主要差异在于输入方式、代码实现细节及优化程度。部分题解关注输入优化，部分注重代码简洁性和可读性。

### 所选的题解
- **作者：qhr2023 (5星)**
    - **关键亮点**：代码简洁高效，利用逻辑表达式判断学生是否符合获奖条件，减少代码量，且整体思路清晰，直接明了。
    - **重点代码及核心思想**：
```cpp
sum=(a>80&&e)*8000+
    (a>85&&b>80)*4000+
    (a>90)*2000+
    (a>85&&d=='Y')*1000+
    (b>80&&c=='Y')*850;
```
核心思想是将每个奖学金的判断条件写成逻辑表达式，若表达式成立返回1，乘以对应奖金数额，累加得到该学生的总奖金。
- **作者：lucienshawls (4星)**
    - **关键亮点**：关注输入优化，针对大数据输入可能出现的问题，给出数值和字符串读入优化方法，并封装成模板函数，同时代码结构清晰，利用结构体和重载小于号进行排序。
    - **个人心得**：提到cin和scanf在大数据输入时可能出现问题，强调读入优化的重要性。
    - **重点代码及核心思想**：
```cpp
template <typename T>
inline void read(T &input){
    input=0;int f=1;
    char c=getchar();
    while(c>'9' || c<'0'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c<='9' && c>='0'){
        input=(input<<3)+(input<<1)+c-'0';
        c=getchar();
    }
    input*=f;
}
```
此为数值读入优化函数，通过getchar逐字符读入，将字符转成数字并处理正负号。
```cpp
bool operator <(NOIP x,NOIP y){
    if(x.money==y.money){
        return (x.code<y.code);
    }else{
        return (x.money>y.money);
    }
}
```
重载小于号，用于sort排序，先按奖学金从高到低排，若奖学金相同则按编号从小到大排。
- **作者：hanyu0722 (4星)**
    - **关键亮点**：指出本题无需排序，通过变量直接维护最高奖学金同学的姓名、最高奖学金以及累计奖学金，简化了操作，代码简洁明了。
    - **重点代码及核心思想**：
```cpp
for (int i=1;i<=n;i++){
    string name;
    int x,y,z,money=0;
    char xx,yy;
    cin>>name>>x>>y>>xx>>yy>>z;

    if (x>85 && y>80) money+=4000;
    if (x>90) money+=2000;
    if (xx=='Y' && y>80) money+=850;
    if (yy=='Y' && x>85) money+=1000;
    if (x>80 && z) money+=8000;

    sum+=money;
    if (money>mx){
        mx=money;
        s=name;
    }
}
```
核心思想是在循环读入学生信息时，同步计算该学生的奖学金，更新总奖学金和最高奖学金及对应学生姓名。

### 最优关键思路或技巧
- **逻辑表达式简化判断**：如qhr2023的题解，将判断条件写成逻辑表达式，简洁地计算出每个学生的奖金，减少冗余代码。
- **避免不必要的排序**：像hanyu0722的题解，利用变量直接维护所需信息，避免对所有学生数据进行排序，降低时间复杂度。

### 拓展思路
此类题目属于模拟类问题，通常需要根据给定规则进行数据处理。类似套路包括清晰梳理规则，用合适的数据结构存储信息，按规则模拟计算过程。同类型题可能会改变规则的复杂程度、数据规模或数据类型等。

### 相似知识点题目推荐
- **P1004 [NOIP2000 提高组] 方格取数**：涉及模拟和简单的动态规划思想，与本题类似之处在于按一定规则处理数据。
- **P1048 [NOIP2005 普及组] 采药**：同样是按条件处理数据，不过重点在于背包问题的应用，和本题在逻辑判断与数据处理上有相似思考方式。
- **P1080 [NOIP2012 提高组] 国王游戏**：需要对数据进行排序和按规则模拟计算，与本题在整体解题流程上有相似性。 

---
处理用时：27.16秒
# 题目信息

# [NOIP 2008 普及组] 排座椅

## 题目描述

上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 $D$ 对同学上课时会交头接耳。

同学们在教室中坐成了 $M$ 行 $N$ 列，坐在第 $i$ 行第 $j$ 列的同学的位置是 $(i,j)$，为了方便同学们进出，在教室中设置了 $K$ 条横向的通道，$L$ 条纵向的通道。

于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 $2$ 个会交头接耳的同学，那么他们就不会交头接耳了。

请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。


## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/0z0p5x1i.png)

上图中用符号\*、※、+标出了 $3$ 对会交头接耳的学生的位置，图中 $3$ 条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。

2008 年普及组第二题


## 样例 #1

### 输入

```
4 5 1 2 3
4 2 4 3
2 3 3 3
2 5 2 4
```

### 输出

```
2
2 4
```

# AI分析结果

### 综合分析与结论
这些题解思路基本一致，均采用贪心算法，核心在于统计每行、每列设置通道可分隔交头接耳学生对数，选分隔对数多的通道。
1. **思路**：遍历每对交头接耳学生坐标，若横坐标相同则对应列通道分隔对数加1，纵坐标相同则对应行通道分隔对数加1。之后对横、纵通道按分隔对数从大到小排序，取前K条横向和前L条纵向通道，再按位置从小到大排序输出。
2. **算法要点**：利用结构体存储通道位置及可分隔对数，通过两次排序分别满足贪心选最多分隔对数通道和按位置有序输出要求。
3. **解决难点**：部分题解提到排序稳定性问题，如使用不稳定排序（如快排）可能导致通道位置与分隔对数对应关系混乱，需用稳定排序（如冒泡排序或自定义稳定排序方式）。

### 题解推荐
1. **作者：chrispang (5星)**
    - **关键亮点**：思路清晰，代码简洁。定义结构体存储通道信息，通过两次排序解决问题，代码结构清晰，易理解。
    - **重点代码**：
```cpp
struct node{
    int x, n; 
}x[1010], y[1010];

bool cmp1(node a, node b) { 
    return a.n > b.n;
}

bool cmp2(node a, node b) { 
    return a.x < b.x;
}

int main() {
    cin >> m >> n >> k >> l >> d;
    for (int i = 1; i <= d; i++) {
        int x1, y1, p1, q1;
        cin >> x1 >> y1 >> p1 >> q1;
        if(x1 == p1) {
            y[min(y1, q1)].x = min(y1, q1); 
            y[min(y1, q1)].n++; 
        }
        if(y1 == q1) {
            x[min(x1, p1)].x = min(x1, p1); 
            x[min(x1, p1)].n++; 
        }
    }
    sort(x + 1, x + 1 + 1000, cmp1); 
    sort(y + 1, y + 1 + 1000, cmp1);
    sort(x + 1, x + 1 + k, cmp2); 
    sort(y + 1, y + 1 + l, cmp2);
    for (int i = 1; i <= k; i++)
        cout << x[i].x << " ";
    cout << endl;
    for (int i = 1; i <= l; i++)
        cout << y[i].x << " ";
    return 0;
}
```
    - **核心思想**：定义结构体`node`存储通道位置`x`和可分隔人数`n`。输入交头接耳学生坐标，判断并更新对应通道可分隔人数。两次排序，第一次按可分隔人数从大到小，第二次按通道位置从小到大，最后输出结果。
2. **作者：Ryan114 (4星)**
    - **关键亮点**：思路阐述详细，结合代码注释，对贪心和结构体排序实现过程解释清晰。
    - **重点代码**：
```cpp
struct Line
{
    int id,cut; 
} hd[1005],ld[1005]; 

bool cmp1(Line a,Line b)
{
    return a.cut>b.cut;
}
bool cmp2(Line a,Line b)
{
    return a.id<b.id;
}
int main()
{
    vector<int>hv,lv; 
    int m,n,k,l,d; 
    cin>>m>>n>>k>>l>>d;
    for(int i=1;i<=d;i++)
    {
        int h1,l1,h2,l2;
        cin>>l1>>h1>>l2>>h2;
        if(l1==l2) hv.push_back(min(h1,h2)); 
        else lv.push_back(min(l1,l2)); 
    }
    for(int i=1;i<=m;i++) 
    {
        hd[i].id=i; 
        for(auto j : lv) if(i==j) hd[i].cut++; 
    }
    for(int i=1;i<=n;i++) 
    {
        ld[i].id=i; 
        for(auto j : hv) if(i==j) ld[i].cut++; 
    }
    sort(hd+1,hd+1+m,cmp1); 
    sort(ld+1,ld+1+n,cmp1);
    sort(hd+1,hd+1+k,cmp2); 
    sort(ld+1,ld+1+l,cmp2);
    for(int i=1;i<=k;i++) cout<<hd[i].id<<" ";
    cout<<endl;
    for(int i=1;i<=l;i++) cout<<ld[i].id<<" ";
    return 0;
}
```
    - **核心思想**：定义结构体`Line`存储通道位置`id`和可分隔对数`cut`。通过`vector`记录横纵相邻学生位置，遍历更新各通道可分隔对数。两次排序，先按可分隔对数从大到小，再按位置从小到大，最后输出结果。
3. **作者：Eason_lyx (4星)**
    - **关键亮点**：代码注释详细，对题目分析、算法思路及代码实现各步骤解释清晰，利于理解。
    - **重点代码**：
```cpp
struct M{
    int id,cnt;    
}h[1005],z[1005];

bool cmp1(M a,M b){
    return a.cnt>b.cnt;
}
bool cmp2(M a,M b){
    return a.id<b.id;
}
int main(){
    cin>>m>>n>>k>>l>>d;
    for(int i=1;i<=d;i++){
        cin>>x>>y>>p>>q;
        if(x==p){
            cur=min(y,q);
            h[cur].id=cur;
            h[cur].cnt++;
        }
        else{
            cur=min(x,p);
            z[cur].id=cur;
            z[cur].cnt++;
        }
    }
    sort(h+1,h+n+1,cmp1);
    sort(z+1,z+m+1,cmp1);
    sort(h+1,h+l+1,cmp2);
    sort(z+1,z+k+1,cmp2);
    for(int i=1;i<=k;i++)printf("%d ",z[i].id);
    cout<<endl;
    for(int i=1;i<=l;i++)printf("%d ",h[i].id);
    return 0;
}
```
    - **核心思想**：定义结构体`M`存储通道编号`id`和讲话计数`cnt`。输入交头接耳学生坐标，判断并更新对应通道讲话计数。两次排序，第一次按讲话计数从大到小，第二次按编号从小到大，最后输出结果。

### 最优思路与技巧
1. **数据结构**：使用结构体存储通道位置和可分隔对数，方便数据处理与排序。
2. **算法优化**：采用贪心策略，每次选择可分隔对数最多的通道，保证最终方案能分隔最多交头接耳学生。排序时注意稳定性，确保数据对应关系正确。
3. **代码实现技巧**：利用`min`函数简化坐标处理，通过两次排序分别实现贪心选择和有序输出。

### 拓展思路
同类型题常涉及资源分配、任务调度等场景，可采用贪心策略，关键在于找到合适衡量标准（如本题分隔对数），每次选择当前最优选项。类似算法套路是先统计各选项收益，按收益排序选取，再按题目要求二次排序输出。

### 相似知识点题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子**：通过贪心策略，每次选择最小两堆果子合并，考察贪心算法应用。
2. **P1199 [NOIP2010 普及组] 三国游戏**：需分析游戏策略，运用贪心思想找出最优方案，与本题贪心选择思路类似。
3. **P1223 排队接水**：根据每个同学接水时间，用贪心算法安排接水顺序，使总等待时间最短，同样是贪心算法典型应用。

### 个人心得摘录
作者RedContritio提到使用快排可能导致ID混乱，因快排不稳定，建议使用稳定排序（如冒泡排序）。总结为排序时要注意算法稳定性，尤其数据存在对应关系时，不稳定排序可能破坏数据结构，导致结果错误。 

---
处理用时：42.31秒
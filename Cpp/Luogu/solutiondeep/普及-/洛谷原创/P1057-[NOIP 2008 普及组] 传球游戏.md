# 题目信息

# [NOIP 2008 普及组] 传球游戏

## 题目描述

上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。

游戏规则是这样的：$n$ 个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。

聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了 $m$ 次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学 $1$ 号、$2$ 号、$3$ 号，并假设小蛮为 $1$ 号，球传了 $3$ 次回到小蛮手里的方式有 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$ 和 $1 \rightarrow 3 \rightarrow 2 \rightarrow 1$，共 $2$ 种。


## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据，满足：$3 \le n \le 30,1 \le m \le 20$；
- 对于 $100\%$ 的数据，满足：$3 \le n \le 30,1 \le m \le 30$。

2008普及组第三题


## 样例 #1

### 输入

```
3 3```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解都采用动态规划（DP）方法，通过分析球传到不同同学手中的方案数与传球次数的关系来解题。少数题解还提及搜索（如BFS）、打表等方法，但搜索因复杂度高难以AC。
    - 算法要点：定义状态 \(dp_{i,j}\) 表示球传到 \(i\) 号同学且传球次数为 \(j\) 次的方案数，状态转移方程为 \(dp_{i,j}=dp_{i - 1,j - 1}+dp_{i - 1,j + 1}\)（需特判 \(i = 1\) 和 \(i = n\) 的边界情况）。
    - 解决难点：关键在于理解状态转移关系，即球传到某同学手中的方案数是其左右同学在上一轮传球后的方案数之和，同时要处理好环形结构带来的边界问题。
    - 质量评价：多数题解思路清晰，代码实现基本正确，但在思路清晰度、代码可读性和优化程度上存在差异。

所选的题解：
  - 作者：HighPerformanceRobot (5星)
    - 关键亮点：思路讲解详细，不仅介绍了DP方法，还阐述了BFS搜索及其优化过程，包括剪枝和压缩相同状态，对初学者友好。
    - 个人心得：强调DP学习可从找规律开始，同时提到打表也是一种解题策略。
    - 重点代码（DP部分）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[31][31],i,j,m,n;
int main()
{
    cin>>n>>m;
    f[0][1]=1;
    for(int i=1; i<=m; i++)
        for(int j=1; j<=n; j++)
            if(j==1)
                f[i][j]=f[i-1][n]+f[i-1][2];
            else if(j==n)
                f[i][j]=f[i-1][1]+f[i-1][n-1];
            else
                f[i][j]=f[i-1][j-1]+f[i-1][j+1];
    cout<<f[m][1]<<endl;
    return 0;
}
```
    - 核心实现思想：初始化 \(f[0][1]=1\) 表示初始状态球在小蛮手中。通过两层循环，外层循环控制传球次数 \(i\)，内层循环控制同学编号 \(j\)。根据 \(j\) 是否为边界情况（\(j = 1\) 或 \(j = n\)），按照状态转移方程更新 \(f[i][j]\) 的值，最后输出 \(f[m][1]\) 即传 \(m\) 次球后回到小蛮手中的方案数。
  - 作者：Idoyt (4星)
    - 关键亮点：从维度角度深入分析问题，详细阐述了状态和状态转移方程的推导过程，帮助读者理解DP的本质。
    - 重点代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int f[30][30];
int main()
{
    scanf("%d%d",&n,&m);
    f[1][0]=f[0][1]=1;
    for(int i=1;i<=m;i++)
    {
        f[1][i]=f[n][i-1]+f[2][i-1];
        for(int j=2;j<n;j++)
            f[j][i]=f[j-1][i-1]+f[j+1][i-1];
        f[n][i]=f[n-1][i-1]+f[1][i-1];
    }
    printf("%d",f[1][m]);
    return 0;
}
```
    - 核心实现思想：与上一题解类似，先初始化 \(f[1][0]=1\)，通过两层循环，依据状态转移方程对不同同学在不同传球次数下的方案数进行更新，注意对边界情况（同学1和同学n）单独处理，最后输出 \(f[1][m]\)。
  - 作者：kunkun127 (4星)
    - 关键亮点：简洁明了地阐述了DP思路，直接给出状态定义和转移方程，代码简洁清晰。
    - 重点代码：
```cpp
#include <bits/stdc++.h>
#define hyh using
#define love namespace
#define lsq std
hyh love lsq;

int dp[35][35];

int main()
{
    int n, m; 
    cin >> n >> m;
    dp[1][0] = 1;
    for (int j = 1; j <= m; j++)
    {
        dp[1][j] = dp[2][j - 1] + dp[n][j - 1];
        dp[n][j] = dp[1][j - 1] + dp[n - 1][j - 1];
        for (int i = 2; i < n; i++) dp[i][j] = dp[i - 1][j - 1] + dp[i + 1][j - 1];
    }
    cout << dp[1][m] << endl;
    return 0;
}
```
    - 核心实现思想：初始化 \(dp[1][0]=1\)，通过两层循环，先处理边界情况（同学1和同学n），再处理中间同学，按照状态转移方程更新 \(dp\) 数组，最后输出 \(dp[1][m]\)。

最优的关键思路或技巧：采用动态规划，通过合理定义状态和状态转移方程来解决问题。在实现过程中，要准确处理环形结构带来的边界条件。

可拓展之处：此类问题属于环形状态转移的DP问题，类似套路可用于解决一些具有环形结构或循环依赖关系的计数问题。例如，在环形排列的物品上进行操作并统计方案数等。

推荐题目：
  - P1216 [USACO1.5]数字三角形 Number Triangles
  - P1002 [NOIP2002 普及组] 过河卒
  - P1434 [SHOI2002]滑雪

---
处理用时：31.03秒
# 题目信息

# [NOIP 2012 提高组] 借教室

## 题目描述

在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。

面对海量租借教室的信息，我们自然希望编程解决这个问题。

我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。

我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。

借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。

现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。


## 说明/提示

【输入输出样例说明】

第 $1 $份订单满足后，$4 $天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2 $天到第 $4$ 天每天提供 $3$ 个教室，而第 $3$ 天剩余的教室数为$ 2$，因此无法满足。分配停止，通知第 $2$ 个申请人修改订单。

【数据范围】

对于 $10\%$ 的数据，有 $1\le n,m\le 10$；

对于 $30\%$ 的数据，有 $1\le n,m\le 1000$；

对于 $70\%$ 的数据，有 $1 \le n,m \le 10^5$；

对于 $100\%$ 的数据，有 $1 \le n,m \le 10^6$，$0 \le r_i,d_j\le 10^9$，$1 \le s_j\le t_j\le n$。


NOIP 2012 提高组 第二天 第二题

2022.2.20 新增一组 hack 数据

## 样例 #1

### 输入

```
4 3 
2 5 4 3 
2 1 3 
3 2 4 
4 2 4```

### 输出

```
-1 
2```

# AI分析结果

这道题主要解决在一系列教室租借订单中，判断是否存在无法完全满足的订单以及找出第一个无法满足的订单编号。题解中涉及的算法有暴力枚举、差分、二分、线段树、树状数组、倍增等，下面对各题解进行分析：
1. **暴力枚举**：
    - **思路**：按订单顺序，对每个订单涉及的天数进行教室数量修改（减法），若过程中某一天教室数量不足则停止。
    - **算法要点**：双重循环，外层枚举订单，内层处理订单涉及天数。
    - **解决难点**：直观简单，但时间复杂度高，$O(m \times n)$，大数据量易超时。
    - **评分**：1星
    - **个人心得**：无
2. **差分优化暴力**：
    - **思路**：通过前缀和统计每天教室需求量，再循环判断哪天供不应求，找到后暴力减去订单需求直至符合条件。
    - **算法要点**：利用前缀和统计需求，暴力查找与调整。
    - **解决难点**：虽用前缀和优化，但最坏复杂度仍可达$O(mn)$，依赖数据情况。
    - **评分**：2星
    - **个人心得**：无
3. **二分 + 差分**：
    - **思路**：利用二分查找确定能满足的最大订单数，每次二分后用差分判断当前订单数能否满足。
    - **算法要点**：二分订单数量，差分实现区间操作及判断。
    - **解决难点**：理解二分适用性及差分操作原理，利用问题单调性进行二分。
    - **评分**：5星
    - **个人心得**：二分左右端点易混淆，需明确二分范围与意义。
4. **线段树**：
    - **思路**：用线段树维护区间最小值，每次处理订单时更新线段树，若最小值为负则订单无法满足。
    - **算法要点**：构建线段树，实现区间更新与最小值查询。
    - **解决难点**：理解并实现线段树结构及lazy标记，处理区间更新与下传。
    - **评分**：4星
    - **个人心得**：lazy标记使用易错，需正确处理下传及更新操作。
5. **倍增 + 差分**：
    - **思路**：类似二分，从左往右通过倍增确定无法满足的订单，用差分处理区间操作。
    - **算法要点**：以2的幂次倍增操作范围，差分实现区间增减。
    - **解决难点**：合理利用倍增思想缩小查找范围，结合差分操作。
    - **评分**：4星
    - **个人心得**：无
6. **树状数组 + 二分 + 优化**：
    - **思路**：二分查找不能满足的订单，树状数组实现区间修改与单点查询判断是否满足，优化减少重复计算。
    - **算法要点**：树状数组基础操作，二分查找，优化减少重复计算。
    - **解决难点**：树状数组操作及优化方法，降低时间复杂度。
    - **评分**：3星
    - **个人心得**：二分调整范围时易出错，需注意订单计算与范围调整。

综合来看，“二分 + 差分”方法最优，利用问题单调性二分减少搜索范围，差分实现高效区间操作，时间复杂度$O((n + m)\log m)$。

**所选较高分题解**：
1. **“二分 + 差分” - 皎月半洒花**
    - **星级**：5星
    - **关键亮点**：思路清晰，先介绍暴力及不可行原因，再引入差分与二分，详细阐述前缀和、差分概念及二分适用性。
    - **个人心得**：“凡是能打出几近正解的暴力题，都不是难题”，从暴力入手思考优化方向。
    - **核心代码**：
```cpp
bool isok(int x)
{
    memset(diff,0,sizeof(diff));
    for(int i=1;i<=x;i++)
    {
        diff[l[i]]+=d[i];
        diff[r[i]+1]-=d[i]; 
    }
    for(int i=1;i<=n;i++)
    {
        need[i]=need[i-1]+diff[i];
        if(need[i]>rest[i])return 0;
    }
    return 1;
} 
int main()
{
    
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&rest[i]);
    for(int i=1;i<=m;i++)scanf("%d%d%d",&d[i],&l[i],&r[i]);
    int begin=1,end=m; 
    if(isok(m)){cout<<"0";return 0;}
    while(begin<end)
    {
        int mid=(begin+end)/2;
        if(isok(mid))begin=mid+1;
        else end=mid;
    }
    cout<<"-1"<<endl<<begin;
}
```
    - **核心实现思想**：`isok`函数判断前`x`个订单能否满足，先对`diff`数组清零，根据订单更新`diff`数组，再通过前缀和得到每天实际需求`need`，与每天可用教室数`rest`比较。`main`函数二分订单数量，调用`isok`判断，确定第一个无法满足的订单。
2. **“线段树” - LeavingZzz**
    - **星级**：4星
    - **关键亮点**：除介绍思路与代码，还提及线段树优化点，如懒惰标记、标记下传及常数优化。
    - **个人心得**：线段树实现中，懒惰标记、标记下传易错，需谨慎处理。
    - **核心代码**：
```cpp
inline void Build(int L,int R,int i)
{
    if(L==R)
    {
        TREE[i]=h[L];
        return ;
    }
    Build(L,mid,i<<1);
    Build(mid+1,R,i<<1|1);
    TREE[i]=min_(TREE[i<<1],TREE[i<<1|1]);
    return ;
}
inline void LAZY(int i)
{
    if(lazy[i]==0) return ;
    lazy[i<<1]+=lazy[i];
    lazy[i<<1|1]+=lazy[i];
    TREE[i<<1]-=lazy[i];
    TREE[i<<1|1]-=lazy[i];
    lazy[i]=0;
    return ;
}
inline void Update(int L,int R,int l,int r,int i,int k)
{
    if(l<=L&&R<=r)
    {
        TREE[i]-=k;
        lazy[i]+=k;
        return ;
    }
    LAZY(i);
    if(l<=mid) Update(L,mid,l,r,i<<1,k);
    if(r>mid) Update(mid+1,R,l,r,i<<1|1,k);
    TREE[i]=min_(TREE[i<<1],TREE[i<<1|1]);
    return ;
}
int main()
{
    N=Read();M=Read();
    for(int i=1;i<=N;i++)
        h[i]=Read();
    Build(1,N,1);
    for(int i=1;i<=M;i++)
    {
        c=Read();s=Read();e=Read();
        Update(1,N,s,e,1,c);
        if(TREE[1]<0)
        {
            printf("-1\n%d",i);
            return 0;
        }
    }
    printf("0");
    return 0;
}
```
    - **核心实现思想**：`Build`函数构建线段树，叶子节点存储每天教室数，非叶子节点存区间最小值。`LAZY`函数下传懒惰标记，更新子节点最小值与标记。`Update`函数更新线段树，若当前区间被更新区间包含则直接更新，否则下传标记后递归更新子区间。`main`函数读入数据，构建线段树，处理订单更新并判断是否满足。
3. **“倍增 + 差分” - 1jia1**
    - **星级**：4星
    - **关键亮点**：提供独特的倍增与差分结合思路，与常见二分方法区分。
    - **个人心得**：无
    - **核心代码**：
```cpp
for(int i=20,pow2,frog=0;i>=0;i--)
{
    pow2=1<<i;
    if(day+pow2>m)continue;
    for(int j=day+1;j<=min(day+pow2,m);j++)dif[l[j]]-=add[j],dif[r[j]+1]+=add[j];
    frog=0;
    for(int j=1,sum=0;j<=n;j++)
    {
        sum+=dif[j];
        if(sum+num[j]<0){frog=1;break;}
    }
    if(!frog)day+=min(pow2,m+1);
    else for(int j=day+1;j<=min(day+pow2,m);j++)dif[l[j]]+=add[j],dif[r[j]+1]-=add[j];
}
if(day>=m)puts("0");
else printf("-1\n%d\n",day+1);
```
    - **核心实现思想**：通过`for`循环以2的幂次`pow2`尝试增加处理订单数，用差分处理订单区间操作，检查是否有教室数量不足，若满足则更新处理订单数`day`，否则撤销操作，最后根据`day`判断输出结果。

**关键思路与技巧**：利用问题单调性采用二分或倍增优化搜索；差分将区间操作转化为端点操作，降低时间复杂度；线段树通过维护区间信息实现高效区间查询与更新。

**相似题目推荐**：
1. **P3372 【模板】线段树 1**：线段树区间修改与单点查询模板题，巩固线段树基础操作。
2. **P1908 逆序对**：可利用归并排序或树状数组解决，考察类似数据结构与算法应用。
3. **P2671 求和**：结合前缀和与差分思想，进一步理解二者应用。 

---
处理用时：52.05秒
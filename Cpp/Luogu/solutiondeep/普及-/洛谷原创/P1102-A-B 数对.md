# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效统计满足A - B = C的数对个数展开，涉及多种算法思路，包括使用map映射、二分查找、双指针、哈希等方法。不同算法在时间复杂度、空间复杂度以及代码实现的难易程度上各有差异。

### 所选的题解
1. **作者：OsvaldoAsensioLopez (赞：789)**
    - **星级**：5星
    - **关键亮点**：思路清晰，通过将A - B = C转换为A - C = B，利用map统计每个元素出现次数，再遍历数组计算满足条件数对，代码简洁明了。
    - **核心代码**：
```cpp
#include <iostream>
#include <map>
using namespace std;
typedef long long LL;
LL a[200001];
map<LL,LL> m;
int main() {
    int n;
    LL c;
    LL ans=0;
    cin >> n >> c;
    for(int i=1;i<=n;i++) {
        cin >> a[i];
        m[a[i]]++;
        a[i]-=c;    
    } 
    for(int i=1;i<=n;i++) ans+=m[a[i]];
    cout << ans << endl;
    return 0;
}
```
    - **核心实现思想**：先读入数据并使用map记录每个数出现的次数，同时将数组中每个元素减去C。之后遍历数组，对于每个元素，将其在map中对应的值（即满足A - C = B的B的个数）累加到答案中。

2. **作者：樱花飞舞 (赞：536)**
    - **星级**：5星
    - **关键亮点**：巧妙运用STL中的二分查找函数lower_bound和upper_bound，通过排序数组后，对每个元素查找满足差值为C的元素个数，算法复杂度为O(NlogN)，且对二分查找函数的讲解详细。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long a[200001];
long N,C,ans;
int main()
{
    cin>>N>>C;
    for(int i=1;i<=N;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+N+1);
    for(int i=1;i<=N;i++)
    {
        ans+=((upper_bound(a+1,a+N+1,a[i]+C)-a)-(lower_bound(a+1,a+N+1,a[i]+C)-a));
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：读入数组后进行排序，然后遍历数组，对于每个元素a[i]，利用upper_bound和lower_bound函数计算数组中值为a[i] + C的元素个数，并累加到答案中。

3. **作者：jins3599 (赞：458)**
    - **星级**：4星
    - **关键亮点**：提出双指针解法，利用排序后数组的有序性，通过维护两个右端点来确定满足条件的连续区间，从而统计数对个数，代码简洁高效，时间复杂度为O(nlogn)。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2e5 + 10;
int n, c;
int a[N];
int main () 
{
    cin >> n >> c;
    for(int i = 1 ; i <= n ; i ++) cin >> a[i];
    sort(a + 1, a + 1 + n);
    int l = 1, r1 = 1, r2 = 1;
    ll ans = 0;
    for(l = 1 ; l <= n ; l ++) {
        while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
        while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
        if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
            ans += r1 - r2;
    }
    cout << ans;
    return 0;
}
```
    - **核心实现思想**：读入数组并排序，通过双指针l遍历数组，同时移动r1和r2指针找到满足a[r1] - a[l] <= c和a[r2] - a[l] < c的位置，若a[r2] - a[l] == c且a[r1 - 1] - a[l] == c，则将r1 - r2累加到答案中。

### 最优关键思路或技巧
1. **数学转换**：将A - B = C转化为A - C = B，简化问题求解，方便使用各种数据结构和算法进行处理。
2. **利用STL工具**：如使用map进行元素计数，利用lower_bound和upper_bound进行二分查找，减少代码实现难度，提高算法效率。
3. **双指针优化**：通过维护两个指针，利用数组有序性，在O(n)时间复杂度内找到满足条件的区间，优化暴力枚举的时间复杂度。

### 可拓展之处
同类型题目通常围绕数组中元素关系的统计，类似算法套路包括：
1. **利用排序和双指针**：解决涉及数组元素差值、和值等特定关系的计数问题。
2. **哈希与映射**：处理需要高效查找元素出现次数或存在性的场景。

### 推荐题目
1. **P1903 数颜色 / 维护队列**：通过维护队列和颜色计数，考察对数据结构的运用和元素关系的处理。
2. **P2671 求和**：涉及前缀和与二分查找，与本题在利用数组特性和算法优化上有相似之处。
3. **P1177 【模板】快速排序**：虽然是快速排序模板题，但掌握排序算法对于解决此类需要先排序再处理的问题至关重要。 

---
处理用时：32.37秒
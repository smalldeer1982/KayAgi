# 题目信息

# 词链

## 题目描述

如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。

另外还有一些例子：
- `dog.gopher`
- `gopher.rat`
- `rat.tiger`
- `aloha.aloha`
- `arachnid.dog`

连接成的词可以与其他单词相连，组成更长的词链，例如：

`aloha.arachnid.dog.gopher.rat.tiger`

注意到，`.` 两边的字母一定是相同的。

现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。

## 说明/提示

- 对于 $40\%$ 的数据，有 $n \leq 10$；
- 对于 $100\%$ 的数据，有 $n \leq 1000$。


## 样例 #1

### 输入

```
6
aloha
arachnid
dog
gopher
rat
tiger```

### 输出

```
aloha.arachnid.dog.gopher.rat.tiger```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解将单词首末字母关系抽象为图结构，利用搜索寻找字典序最小词链。部分题解直接暴力搜索，遍历所有可能词链；部分题解通过分析词链首末字母出现次数规律，结合欧拉路（包括欧拉通路和欧拉回路）的性质来优化搜索起点，减少搜索量。
    - 算法要点：普遍涉及排序以满足字典序要求；部分题解使用并查集判断图的连通性；通过统计每个字母作为首字母和尾字母的次数，判断是否存在欧拉路及确定起点。
    - 解决难点：核心难点在于高效确定词链起点，避免无意义搜索。暴力搜索虽直观但效率低，优化后的题解通过数学性质分析，缩小起点范围，提高算法效率。

所选的题解：
  - 作者：loc_equinox (5星)
    - 关键亮点：思路清晰，详细阐述从暴力DFS到利用欧拉路性质优化的过程。代码结构完整，分读入建图、寻找欧拉路起始点、DFS求欧拉路三部分，逻辑严谨。通过并查集判断图的连通性，依据欧拉路存在条件准确寻找起点。
    - 个人心得：指出当时数据存在问题，过审题解易被Hack，强调题解对读者的帮助及欢迎指正。
    - 重点代码 - 核心实现思想：建图时，以单词为有向边，字母为顶点，同时用并查集记录连通情况。判断欧拉路存在条件时，检查连通性以及入度出度关系确定起点。DFS搜索时，按字典序遍历边，记录路径得到字典序最小词链。
```cpp
// 读入，建图部分核心代码
cin>>n;
E.resize(27);
for(i=1;i<=n;i++)cin>>s[i];
sort(s+1,s+n+1,cmp);
for(i=1;i<=n;i++)
{
    ch_start=s[i][0]-'a'+1;
    ch_end=s[i][s[i].length()-1]-'a'+1;
    out[ch_start]++;
    in[ch_end]++;
    if(!letter[ch_start])
    {
        set_count++;
        letter[ch_start]=1;
        fa[ch_start]=ch_start;
    }
    if(!letter[ch_end])
    {
        set_count++;
        letter[ch_end]=1;
        fa[ch_end]=ch_end;
    }
    if(ch_start!=ch_end)
    {
        stf=find(ch_start);
        edf=find(ch_end);
        if(stf!=edf)
        {
            set_count--;
            unionn(stf,edf);
        }
    }
    node tmp;
    tmp.to=ch_end;
    tmp.ord=i;
    tmp.word=s[i];
    E[ch_start].push_back(tmp);
}
if(set_count!=1)
{
    cout<<"***";
    return 0;
}

// 寻找欧拉路起始点核心代码
for(i=1;i<=26;i++)
{
    if(!letter[i])continue;
    if(out[i]==in[i]+1)
    {
        if(Eular_start)
        {
            cout<<"***";
            return 0;
        }
        Eular_start=i;
    }
    else if(in[i]==out[i]+1)
    {
        if(Eular_end)
        {
            cout<<"***";
            return 0;
        }
        Eular_end=i;
    }
    else if(in[i]==out[i])continue;
    else
    {
        cout<<"***";
        return 0;
    }
}
if((Eular_start&&!Eular_end)||(!Eular_start&&Eular_end))
{
    cout<<"***";
    return 0;
}
if(!Eular_start)Eular_start=s[1][0]-'a'+1;

// DFS求欧拉路核心代码
void dfs(int st,int now,int pre_edge)
{
    if(st==n)
    {
        for(i=1;i<=n;i++)
        {
            cout<<res[i];
            if(i<n)cout<<".";
        }
        exit(0);
    }
    for(int k=0;k<E[now].size();k++)
    {
        if(!vis[E[now][k].ord])
        {
            vis[E[now][k].ord]=1;
            res[st+1]=E[now][k].word;
            dfs(st+1,E[now][k].to,E[now][k].ord);
        }
    }
    vis[pre_edge]=0;
    return;
}
dfs(0,Eular_start,0);
```
  - 作者：zzr8178541919 (4星)
    - 关键亮点：从词链性质出发，详细分析出不同情况下词链起点的确定方法，思路独特且易理解。代码实现中，搜索部分逻辑清晰，对搜索过程中的细节处理（如标记答案、回溯等）考虑周全。
    - 个人心得：提到更新题解是因为之前学艺不精存在明显错误，强调对搜索细节处理的重要性。
    - 重点代码 - 核心实现思想：先统计每个字母作为首末字母的出现次数，根据出现次数关系确定起点。搜索时，从起点出发，按字典序遍历可连接单词，用标记数组记录已使用单词，找到答案后及时返回。
```cpp
// 核心搜索代码
void dfs(int last,int step)
{
    if(flag==1)
        return;
    if(step==n)
    {
        flag=1;
        for(int i=1;i<=sum;i++)
        {
            ans[i]=now[i];
        }
        return;
    }
    for(int i=1;i<=n;i++)
    {
        if(book[i]==1)
            continue;
        if(a[last][a[last].length()-1]==a[i][0])
        {
            now[++sum]=a[i];
            book[i]=1;
            dfs(i,step+1);
            sum--;
            book[i]=0;
        }
    }
}
```
  - 作者：fls233666 (4星)
    - 关键亮点：将单词建模为有向图的边，清晰阐述欧拉路起点判断方法以及字典序最小答案的实现方式。代码简洁明了，对加边、搜索等操作封装成函数，结构清晰。
    - 个人心得：无
    - 重点代码 - 核心实现思想：排序单词后按序连边，通过计算点度判断欧拉路类型及起点。DFS搜索时，标记已使用边，倒序记录答案保证字典序最小。
```cpp
// 加边函数
inline void add(int x,int y,int b)
{
    tot++;
    to[tot]=y;
    bh[tot]=b;
    d[x]++;
    d[y]--;
    nxt[tot]=lst[x];
    lst[x]=tot;
}

// 搜索函数
void dfs(int g)
{
    for(rgt i=lst[g];i;i=nxt[i])
    {
        if(!use[bh[i]])
        {
            use[bh[i]]=true;
            dfs(to[i]);
            lans++;
            outans[lans]=str[bh[i]];
        }
    }
}
```
• 最优关键思路或技巧：将单词首末字母关系抽象为有向图，利用欧拉路性质确定起点是优化算法的关键。通过统计字母出现次数，判断图是否存在欧拉路以及确定起点，有效减少搜索空间。同时，对单词排序保证字典序最小，在搜索过程中按序遍历确保答案最优。
• 可拓展之处：此类题目属于图论中路径搜索与优化问题，类似套路可应用于其他字符串拼接、图的遍历优化等问题。例如，给定多个字符串，要求按特定规则拼接成最短或最长字符串等。
• 洛谷相似题目推荐：
    - P2731 [USACO3.3]骑马修栅栏 Riding the Fences ，同样涉及欧拉路的判断与寻找。
    - P1341 无序字母对 ，通过构建图结构解决字符拼接问题，与本题思路类似。
    - P1112 最大子树和 ，虽然主要考察树形DP，但在图的构建和遍历处理上有相似之处，可锻炼图论相关思维。 

---
处理用时：44.12秒
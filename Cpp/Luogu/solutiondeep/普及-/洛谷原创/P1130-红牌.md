# 题目信息

# 红牌

## 题目描述


某地临时居民想获得长期居住权就必须申请拿到红牌。获得红牌的过程是相当复杂 ，一共包括 $N$ 个步骤。每一步骤都由政府的某个工作人员负责检查你所提交的材料是否符合条件。为了加快进程，每一步政府都派了 $M$ 个工作人员来检查材料。不幸的是，并不是每一个工作人员效率都很高。尽管如此，为了体现“公开政府”的政策，政府部门把每一个工作人员的处理一个申请所花天数都对外界公开。

为了防止所有申请人都到效率高的工作人员去申请。这 $M \times N$ 个工作人员被分成 $M$ 个小组。每一组在每一步都有一个工作人员。申请人可以选择任意一个小组也可以更换小组。但是更换小组是很严格的，一定要相邻两个步骤之间来更换，而不能在某一步骤已经开始但还没结束的时候提出更换，并且也只能从原来的小组 $I$ 更换到小组 $I+1$，当然从小组 $M$ 可以更换到小组 $1$。对更换小组的次数没有限制。

例如：下面是 $3$ 个小组，每个小组 $4$ 个步骤工作天数：

- 小组 $1$： $2, 6 ,1 ,8$；
- 小组 $2$：$3,6, 2, 6$；
- 小组 $3$：$ 4, 2 ,3 ,6$。

例子中，可以选择小组 $1$ 来完成整个过程一共花了$2+6+1+8=17$ 天，也可以从小组 $2$ 开始第一步，然后第二步更换到小组 $3$，第三步到小组 $1$，第四步再到小组 $2$，这样一共花了 $3+2+1+6=12$ 天。你可以发现没有比这样效率更高的选择。

你的任务是求出完成申请所花最少天数。

## 说明/提示

对于 $100\%$ 的数据，$1\le N,M \le 2000$。

## 样例 #1

### 输入

```
4 3 
2 6 1 8
3 6 2 6
4 2 3 6
```

### 输出

```
12```

# AI分析结果

• 综合分析与结论：这些题解均围绕动态规划（DP）算法解决获取红牌所需最少天数问题。思路上，大多通过定义状态表示第i步在第j小组的最少天数，依据小组切换规则构建状态转移方程，同时处理小组M到小组1切换的特殊情况。算法要点在于正确设定状态与转移方程，难点是处理小组切换的边界条件及输入顺序。部分题解采用顺推，部分逆推，但本质思路一致。部分题解在空间上进行优化，如直接在输入数组上进行动态规划。
  - 作者whx1003（5星）：
    - 关键亮点：思路清晰，明确定义状态$f[i][j]$表示第$i$阶段第$j$小组的最小天数，并给出准确的状态转移方程$f[i][j]=\min(f[i - 1][j], j == 1? f[i - 1][m] : f[i - 1][j - 1]) + a[i][j]$，同时注意到读入方式与转移方式的差异并进行处理。
    - 重点代码：
```cpp
scanf("%d%d", &n, &m);
for(int i = 1; i <= m; ++i)
    for(int j = 1; j <= n; ++j)
        scanf("%d", &a[j][i]);

for(int i = 1; i <= n; ++i)
    for(int j = 1; j <= m; ++j)
        f[i][j] = std::min(f[i - 1][j], j == 1? f[i - 1][m] : f[i - 1][j - 1]) + a[i][j];

int ans = INF;
for(int i = 1; i <= m; ++i)
    ans = std::min(ans, f[n][i]);
printf("%d", ans);
```
    - 核心实现思想：先按特定方式读入数据，通过双重循环依据状态转移方程计算每个状态的最小天数，最后在最后一步的所有小组中找出最小值作为答案。
  - 作者引领天下（4星）：
    - 关键亮点：类比数字三角形问题，从倒数第2步逆向考虑，取两种方案中最小的一种，逐步递推到第一步找最小值，思路较易理解。
    - 重点代码：
```cpp
scanf ("%d%d",&n,&m);
for (int i=0;i<m;i++)
for (int j=0;j<n;j++)scanf ("%d",&a[i][j]);
for (int j=n - 2;j>=0;j--)
for (int i=0;i<m;i++)
    a[i][j]=min(a[(i + 1)%m][j + 1],a[i][j + 1])+a[i][j];
for (int i=0;i<m;i++)ans=min(ans,a[i][0]);
printf ("%d",ans);
```
    - 核心实现思想：逆向遍历步骤，对每个步骤的每个小组，通过比较从下一个小组或本小组下一步骤转移过来的天数，取最小值更新当前值，最后在第一步的所有小组中找出最小值作为答案。
  - 作者feecle6418（4星）：
    - 关键亮点：指出本题与P1216的关联，强调重点与坑点，如小组M到小组1的转换及输入顺序，状态转移方程表述清晰。
    - 重点代码：
```cpp
for(int i = 1; i <= M; i++) {
    for(int j = 1; j <= N; j++) {
        scanf("%d",&a[j][i]);
    }
}
for(int i = 1; i <= N; i++) {
    f[i - 1][0]=f[i - 1][M];
    for(int j = 1; j <= M; j++) {
        f[i][j]=min(f[i - 1][j - 1],f[i - 1][j])+a[i][j];
    }
}
long long int MMM=f[N][1];
for(int i = 2;i<=M;i++){
    MMM=min(MMM,f[N][i]);
}
```
    - 核心实现思想：按特定顺序读入数据，通过双重循环依据状态转移方程计算每个状态的最小天数，在处理小组切换时，通过将$f[i - 1][0]$设为$f[i - 1][M]$来处理边界，最后在最后一步的所有小组中找出最小值作为答案。

• 最优关键思路或技巧：
  - **状态定义与转移**：准确设定状态$f[i][j]$表示第$i$步在第$j$小组的最少天数，根据小组切换规则构建状态转移方程，处理好边界条件。
  - **输入处理**：注意读入顺序与状态转移需求的匹配，可通过调整读入方式简化后续处理。

• 类似算法套路：此类题目属于矩阵上的动态规划问题，通常涉及在矩阵元素间按特定规则移动并求最值。一般思路为定义合适状态表示到达某位置的最优值，根据移动规则确定状态转移方程，同时处理好边界条件。

• 推荐洛谷题目：
  - [P1216数字三角形](https://www.luogu.org/problemnew/show/P1216)：经典数字三角形求最大路径和问题，与本题类似，可加深对矩阵型动态规划的理解。
  - [P1880石子合并](https://www.luogu.org/problem/P1880)：环形区间动态规划问题，涉及环形数据处理，与本题处理小组环形切换有相似之处。
  - [P1006传纸条](https://www.luogu.org/problem/P1006)：二维矩阵上的动态规划，需考虑路径不能重复等条件，锻炼动态规划思维。

• 个人心得摘录与总结：
  - 作者Komorebi_shine：被同学错误方程带偏，经多次WA后意识到只能正向换小组，强调认真读题按题目要求构建方程的重要性。
  - 作者BBD186587：调循环花费较多时间，说明动态规划中循环顺序对状态转移的正确性影响较大，需仔细考虑。 

---
处理用时：31.20秒
# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕无向无权图中从顶点1到其他各点的最短路计数问题，采用的算法有BFS、SPFA和Dijkstra（堆优化）。思路核心都是在求最短路过程中，根据路径长度更新最短路的计数。

算法要点在于：初始化起点到自身的最短路计数为1；在更新最短路时，若找到更短路径则更新距离并将计数设为前驱点的计数；若找到等长路径则将计数加上前驱点的计数。

解决难点方面，部分题解考虑到算法的通用性，如避免SPFA在一般带权图中重复计数问题。不同算法的时间复杂度有所不同，BFS和SPFA在本题中类似，时间复杂度为O(N + M)，Dijkstra堆优化的时间复杂度为O((N + M)logN)。

### 所选的题解
1. **作者：ZiDing_ByronFinlso（5星）**
    - **关键亮点**：思路清晰，同时给出SPFA和Dijkstra堆优化两种解法，并配有思路说明图。代码规范，有详细的读入优化代码。
    - **个人心得**：无
    - **SPFA核心代码**：
```cpp
while(q.size())
{
    x=q.front();q.pop();
    p[x]=0;
    for(int i=head[x];i;i=nxt[i])
    {
        y=to[i];
        if(d[y]>d[x]+1)
        {
            d[y]=d[x]+1;
            ans[y]=ans[x];
            if(!p[y])
            {
                q.push(y);
                p[y]=1;
            }
        }
        else if(d[y]==d[x]+1)
        {
            ans[y]+=ans[x];
            ans[y]%=mod;
        }
    }
}
```
核心思想：通过队列不断取出节点x，遍历其邻接节点y，若y的距离大于x的距离加1，则更新y的距离和计数，并将y入队；若y的距离等于x的距离加1，则累加y的计数。
    - **Dijkstra堆优化核心代码**：
```cpp
while(q.size())
{
    x=q.top().second;
    q.pop();
    if(p[x])    continue;
    p[x]=1;
    for(int i=head[x];i;i=nxt[i])
    {
        y=to[i];
        if(d[y]>d[x]+1)
        {
            d[y]=d[x]+1;
            ans[y]=ans[x];
            q.push(make_pair(-d[y],y));
        }
        else if(d[y]==d[x]+1)
        {
            ans[y]+=ans[x];
            ans[y]%=mod;
        }
    }
}
```
核心思想：利用优先队列取出距离最小的节点x，若x已处理过则跳过，否则遍历其邻接节点y，类似SPFA的方式更新y的距离和计数，若更新距离则将y加入优先队列。

2. **作者：岸芷汀兰（4星）**
    - **关键亮点**：详细阐述思路，明确指出本题符合BFS特点，并分析自环和重边对题目的影响。代码结构清晰，有读入和输出优化函数。
    - **个人心得**：无
    - **BFS核心代码**：
```cpp
queue<Node>q; q.push(make(1, 0));
memset(d, 0x3f, sizeof(d)); d[1] = 0;
vis[1] = true;
ans[1] = 1;
while (q.size()) {
    int u = q.front().node, dis = q.front().dis; 
    q.pop();
    for (register int i = 0; i<int(linker[u].size()); i++) {
        if (!vis[cur]) {
            q.push(make(cur, dis + 1)); vis[cur] = true; d[cur] = dis + 1; 
            ans[cur] += ans[u]; /*重点*/ans[cur] %= mod;
        }
        else {
            if (dis + 1 == d[cur]) { ans[cur] += ans[u]; /*重点*/ans[cur] %= mod; }
        }
    }
}
```
核心思想：从起点1开始，将其入队，初始化距离和计数。每次从队列取出节点u，遍历其邻接节点cur，若cur未访问过，则更新其距离和计数并将cur入队；若cur已访问且距离等于u的距离加1，则累加cur的计数。

3. **作者：King丨帝御威（4星）**
    - **关键亮点**：强调使用堆优化的Dijkstra算法的优势，代码注释详细，对关键步骤如重载运算符、更新最短路和计数的操作解释清晰。
    - **个人心得**：无
    - **Dijkstra核心代码**：
```cpp
void dijkstra()
{
    memset(dis,0x3f,sizeof(dis));
    dis[1]=0;
    priority_queue<node>q;
    js[1]=1;
    q.push((node){1,0});
    node a;
    while(!q.empty())
    {
        a=q.top();
        int u=a.x,d=a.y;
        q.pop();
        if(d!=dis[u]) continue;
        for(int i=head[u];i;i=edge[i].nxt)
        {
            int v=edge[i].v;
            if(d+edge[i].w==dis[v])
              js[v]=(js[u]+js[v])%mod;
            if((dis[v]>dis[u]+edge[i].w))
            {
                dis[v]=dis[u]+edge[i].w;
                js[v]=js[u];
                q.push((node){v,dis[v]});
            }
        }
    }
}
```
核心思想：初始化距离和起点计数，将起点加入优先队列。每次取出队首元素，若当前距离与记录距离不一致则跳过，否则遍历邻接节点，若邻接节点距离等于当前距离加边权，则累加计数；若邻接节点距离大于当前距离加边权，则更新距离和计数并将邻接节点加入优先队列。

### 最优关键思路或技巧
1. **算法选择**：由于本题是无向无权图，BFS、SPFA和Dijkstra（堆优化）都可解决，但BFS和SPFA在本题中的时间复杂度更优，为O(N + M)。
2. **计数更新**：在求最短路过程中，根据路径长度更新最短路计数，若找到更短路径则更新计数为前驱点计数，若找到等长路径则累加前驱点计数。
3. **数据结构**：使用邻接表存储图结构，可有效减少空间复杂度，提高算法效率。

### 可拓展之处
同类型题或类似算法套路：在带权图中求最短路计数时，需注意避免重复计数问题，如KesdiaelKen题解中提到的通过额外数组避免SPFA重复计数。还可拓展到求满足特定条件的最短路计数，如必须经过某些特殊点等。

### 相似知识点洛谷题目
1. **P1608 路径统计**：求有向无环图中从起点到终点的路径数量，可使用拓扑排序结合动态规划求解，与本题在计数思路上有相似之处。
2. **P3371 【模板】单源最短路径（弱化版）**：单源最短路径问题，可使用Dijkstra、SPFA等算法，与本题在最短路求解方法上相关。
3. **P1339 热浪**：同样是单源最短路径问题，通过本题可巩固最短路算法的应用及优化。 

---
处理用时：38.24秒
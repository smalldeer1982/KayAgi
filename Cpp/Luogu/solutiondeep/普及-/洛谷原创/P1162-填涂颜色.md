# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果

这些题解主要围绕如何识别并填充由数字1构成的闭合圈内的0为2这一核心问题。大部分题解采用搜索算法，包括深度优先搜索（DFS）和广度优先搜索（BFS），也有少量使用并查集或暴力枚举的方法。
1. **思路对比**
    - **搜索边界法**：多数题解采用此思路，从方阵边界的0开始搜索，将与边界相连的0标记，剩余未标记的0即为闭合圈内的0，最后将其填充为2。如作者LMB_001、冰冻赤道、LevenKoko等。
    - **反向填充法**：先将所有0设为2，再从边界开始搜索，把搜索到的0变回0，剩下的2即为闭合圈内需要填充的部分。如作者歌者siner、封禁用户（第二次发布）。
    - **寻找圈内起点法**：尝试找到闭合圈内的一个0作为起点，从此点开始进行搜索并填充为2。如作者leozhudd、クリオネ。
    - **暴力枚举法**：通过枚举每个0，判断其上下左右是否都有1来确定是否在闭合圈内。如作者FCBM71、衡屿睿。
    - **并查集方法**：将外圈视为一个节点，读入时对相邻的0进行并查集合并操作，最后判断0是否与外圈在一个集合来确定是否填充。如作者wmxwmx、王鹏PRO。
2. **算法要点与难点**
    - **算法要点**：熟练运用搜索算法（DFS或BFS），利用方向数组简化代码实现，注意边界条件处理。
    - **解决难点**：如何准确区分闭合圈内和圈外的0是关键难点。通过从边界搜索、先全部设为2再还原等方式巧妙解决。
3. **题解评分**
    - **5星**：无
    - **4星**：
        - **作者LMB_001**：思路清晰，采用染色法，从(0, 0)开始DFS搜索，将与边界相连的0染色，最后根据染色情况输出结果。代码简洁明了，注释详细。
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[32][32],b[32][32];
int dx[5]={0,-1,1,0,0};
int dy[5]={0,0,0,-1,1};//第一个表示不动，是充数的，后面的四个分别是上下左右四个方向
int n,i,j;
void dfs(int p,int q){
    int i;
    if (p<0||p>n+1||q<0||q>n+1||a[p][q]!=0) return;//如果搜过头或者已经被搜过了或者本来就是墙的就往回
    a[p][q]=1;//染色
    for (i=1;i<=4;i++) dfs(p+dx[i],q+dy[i]);//向四个方向搜索
}
int main(){
    cin>>n;
    for (i=1;i<=n;i++)
        for (j=1;j<=n;j++){
            cin>>b[i][j];//其实不拿两个数组也可以，不过我喜欢啦
            if (b[i][j]==0) a[i][j]=0;
            else a[i][j]=2;
        }
    dfs(0,0);//搜索 从0，0开始搜
    for (i=1;i<=n;i++){
        for (j=1;j<=n;j++)
        if (a[i][j]==0) cout<<2<<' ';//如果染过色以后i，j那个地方还是0，说明没有搜到，就是周围有墙，当然就是被围住了，然后输出2
        else cout<<b[i][j]<<' ';//因为被染色了，本来没有被围住的水和墙都染成了1，所以就输出b[i][j]
        cout<<'\n';//换行
    }
}
```
        - **作者zhy137036**：不仅给出代码实现，还深入探讨了BFS和DFS与数据结构（队列和栈）的关系，以及函数调用与栈的原理，有助于新手深入理解搜索算法。
```cpp
// BFS实现
#include<queue>
#include<utility>
queue<pair<int,int> >que;
void search(int x, int y)
{
    int dx[5] = { 0,-1,0,1,0 }, dy[5] = { 0,0,1,0,-1 };
    que.push(pair<int, int>(x, y));
    while (!que.empty())
    {
        pair<int, int>t = que.front();
        que.pop();
        a[t.first][t.second] = 2;
        for (int i = 1; i <= 4; i++)
        {
            if (t.first + dx[i] >= 0 && t.first + dx[i] <= n+1)
            if (t.second + dy[i] >= 0 && t.second + dy[i] <= n+1)
            if (a[t.first + dx[i]][t.second + dy[i]] == 0)
            que.push(pair<int, int>(t.first + dx[i], t.second + dy[i]));
        }
    }
}

// 栈实现DFS
#include<stack>
#include<utility>
stack<pair<int,int> >sta;
void search(int x, int y)
{
    int dx[5] = { 0,-1,0,1,0 }, dy[5] = { 0,0,1,0,-1 };
    sta.push(pair<int, int>(x, y));
    while (!sta.empty())
    {
        pair<int, int>t = sta.top();
        sta.pop();
        a[t.first][t.second] = 2;
        for (int i = 1; i <= 4; i++)
        {
            if (t.first + dx[i] >= 0 && t.first + dx[i] <= n+1)
            if (t.second + dy[i] >= 0 && t.second + dy[i] <= n+1)
            if (a[t.first + dx[i]][t.second + dy[i]] == 0)
            sta.push(pair<int, int>(t.first + dx[i], t.second + dy[i]));
        }
    }
}
```
        - **作者溜肾污主xyt**：清晰阐述了两种搜索染色法的思路，通过围一圈0简化搜索过程，并分别给出广搜和深搜的代码实现，代码结构良好，注释详细。
```cpp
// 广搜代码
#include<bits/stdc++.h>//万能头，懒人专用 
using namespace std;
int f[32][32];
int dx[4]= {0,1,0,-1},dy[4]= {1,0,-1,0};//存储方向
int n;
queue<int>q;//使用stl队列
void bfs(int x,int y) {//广搜
    int x1,x2,y1,y2;//这里别学我开y1变量，有时候会被判断为一个函数y1，然后gg 
    q.push(x);//存储x(下同) 
    q.push(y);//存储y(下同) 
    f[x][y]=2;//染色(下同) 
    while(!q.empty()) {//队列不为空 
        x1=q.front();
        q.pop();
        y1=q.front();
        q.pop();//获得队头数据 
        for(int i=0; i<4; i++) {//向四个方向搜索
            x2=x1+dx[i];
            y2=y1+dy[i];//用变量，下文判断更方便 
            if(x2>=0&&x2<=n+1&&y2>=0&&y2<=n+1&&f[x2][y2]==0) { 
                q.push(x2);
                q.push(y2);
                f[x2][y2]=2;
            }//满足条件，入队
        }
    }
    return;
}
int main() {
    cin>>n;
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++) {
            cin>>f[i][j];
        }
    bfs(0,0);//从(0,0)开始，一定能搜到外圈省去多余枚举外圈代码
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=n; j++)
            cout<<(f[i][j]==0?2:(f[i][j]==1?1:0))<<' ';//装B专用写法，意为如果为0输出2，否则如果为1输出1，否则输出0
        cout<<endl;//别忘记输出回车 
    }
    return 0;//好习惯 
}

// 深搜代码
void dfs(int x,int y) {
    f[x][y]=2;//染色
    for (int i=0; i<4; i++)
        if(x>=0&&x<=n+1&&y>=0&&y<=n+1&&f[x][y]==0)
            dfs(x+dx[i],y+dy[i]);
}
```
4. **最优关键思路与技巧**
    - **搜索方向简化**：使用方向数组（如`dx[]`和`dy[]`）来表示上下左右四个方向，简化搜索代码实现。
    - **边界处理技巧**：通过在方阵周围围一圈0或从边界点开始搜索，有效区分闭合圈内和圈外的0。
    - **反向思维**：先将所有0设为2，再通过搜索将圈外的0变回0，避免直接判断圈内0的复杂情况。
5. **可拓展之处**
    - **同类型题**：此类题目属于图形填充、连通区域判断类型，类似的题目还有岛屿数量统计、迷宫问题等。
    - **算法套路**：对于涉及图形中区域判断和填充的问题，常用搜索算法（DFS、BFS）解决。关键在于如何根据题目条件准确确定搜索起点、边界条件以及标记已访问的节点。
6. **推荐题目**
    - **P1506 拯救oibh总部**：同样是关于连通区域的搜索问题，通过搜索来确定特定区域。
    - **P1451 求细胞数量**：利用搜索算法统计矩阵中细胞（连通区域）的数量，与本题判断连通区域思路相似。
    - **P1332 血色先锋队**：涉及到在地图上进行搜索，判断不同区域的属性，与本题有相似的搜索应用场景。
7. **个人心得摘录与总结**
    - **作者critnos**：最初尝试枚举每个点判断是否在圈内，发现存在判断不准确的情况，如某些点虽四周有边框但不属于内部点。经过思考，最终采用从一个0点开始染色，根据是否碰到边缘来确定是圈内还是圈外点的方法。总结出在解决问题时，需要全面考虑各种情况，不能仅依据简单直观的判断。
    - **作者Soledad_S**：一开始采用从(1, 1)搜索并标记的方法，但发现遇到复杂情况（如多个连通块）时会出错。经过改进，增加vst数组记录搜索次数和连通块标记，从而正确区分不同连通块。心得是在编程中要充分考虑各种可能的输入情况，对算法进行全面测试和优化。 

---
处理用时：87.63秒
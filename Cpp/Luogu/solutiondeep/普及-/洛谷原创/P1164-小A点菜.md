# 题目信息

# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# AI分析结果

这是一道典型的动态规划题目，类似01背包问题，核心是求用给定菜品价格组合出特定金额的方案数。

### 综合分析与结论
1. **思路**：多数题解定义状态 `f[i][j]` 表示用前 `i` 道菜用光 `j` 元钱的办法总数（部分题解简化为一维数组 `f[j]`），通过考虑每道菜选或不选来推导状态转移方程。
2. **算法要点**：状态转移方程为 `f[i][j] = f[i - 1][j] + (j >= a[i]? f[i - 1][j - a[i]] : 0)`，即不选当前菜的方案数加上选当前菜的方案数（若钱数足够）。初始化 `f[0][0] = 1` 或 `f[0] = 1` 表示不花钱也是一种方案。
3. **解决难点**：部分题解涉及降维优化，将二维数组优化为一维数组，此时第二层循环需倒序遍历，避免重复计算。同时要注意边界条件处理，如初始化值的设定。

### 星级题解
#### 作者：衡屿睿 (5星)
- **关键亮点**：思路清晰，简洁明了地阐述了动态规划思路及状态转移方程，代码简洁，直接实现核心逻辑。
- **个人心得**：作者幽默提到对DP和递推概念的模糊，侧面反映出对该类问题本质理解的深入思考。
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int a[101],f[101][10001]={0};
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;++i)cin>>a[i];
    for(int i=1;i<=n;++i)
      for(int j=1;j<=m;++j)
      {
          if(j==a[i])f[i][j]=f[i-1][j]+1;
          if(j>a[i]) f[i][j]=f[i-1][j]+f[i-1][j-a[i]];
          if(j<a[i]) f[i][j]=f[i-1][j];
      }
    cout<<f[n][m];
    return 0;
}
```
核心实现思想：通过两层循环遍历菜品和钱数，根据当前钱数与菜品价格关系更新方案数。

#### 作者：Dream_zhc (5星)
- **关键亮点**：不仅给出代码，还详细解释状态转移方程推导过程，从二维数组优化到一维数组的过程讲解细致，并配有图片辅助理解。
- **个人心得**：作者详细描述思考过程，如对特殊情况（菜品价格恰好等于当前钱数）的处理及数组降维的理解，对读者理解有很大帮助。
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define N 110
using namespace std;
int n,m,a[N],f[10010];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
      scanf("%d",&a[i]);
    f[0]=1;
    for(int i=1;i<=n;i++)
      for(int j=m;j>=a[i];j--)
      	  f[j]=f[j]+f[j-a[i]];
    cout<<f[m];
    return 0;
}
```
核心实现思想：先初始化 `f[0] = 1`，通过两层循环，外层遍历菜品，内层倒序遍历钱数，更新方案数。

#### 作者：kkksc03 (4星)
- **关键亮点**：简洁点明动态规划思路，类似背包问题，给出状态转移方程和时间、空间复杂度分析，虽未提供代码，但对问题本质把握精准。
```
方程
f[i,j]:=f[i-1,j]+f[i-1,j-a[i]];

数组表示在前i道菜中，总价格为j。

时间复杂度O(MN)。空间复杂度O(MN)足够了，但是使用循环队列可以减成O(M)。
```
核心实现思想：通过状态转移方程 `f[i,j]` 表示前 `i` 道菜总价格为 `j` 的方案数，通过 `f[i - 1][j]` 和 `f[i - 1][j - a[i]]` 推导。

### 最优关键思路或技巧
1. **状态定义与转移**：合理定义状态，利用选与不选当前物品来构建状态转移方程，是解决此类问题的核心。
2. **空间优化**：当状态转移只依赖上一层状态时，可将二维数组优化为一维数组，减少空间复杂度，但要注意内层循环需倒序遍历。

### 可拓展之处
同类型题或类似算法套路：如求背包最大价值、恰好装满背包的可行性判断等，都可基于01背包问题的思路进行拓展。关键在于根据题目要求调整状态定义和转移方程。

### 洛谷相似题目推荐
1. **P1048 [NOIP2005 普及组] 采药**：同样是背包问题，求在给定时间内采药的最大价值。
2. **P1616 疯狂的采药**：对采药问题的拓展，每种药有无限个，属于完全背包问题。
3. **P2602 [ZJOI2010] 数字计数**：通过数位DP，统计数字在一定区间内出现的次数，与本题类似，需合理定义状态和转移方程。 

---
处理用时：27.23秒
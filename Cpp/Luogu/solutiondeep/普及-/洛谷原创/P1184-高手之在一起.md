# 题目信息

# 高手之在一起

## 题目背景

高手是可以复活的，这点我们大家都知道。


## 题目描述

高手列出了一个详尽的日程表，这次他要追求的则是一个心灵纯洁的小萝莉。他和她都是要上课的，但是也会有时间空闲，于是高手决定无时无刻都要跟着她。为了她，高手决定转学到一年级。

现在高手已经花重金买下了她的日程表，每一天都会有她的行踪。现在列出了高手方便去的地方。其中方便去的地方可以去无限次，不方便去的地方不能去。

一共有 $n$ 个方便去的地点，$m$ 天。高手想知道他在这 $m$ 天中，最多能和她在一起多久。不方便去的地方是不会列出的。


## 说明/提示

$1 \leq m \leq 1000000$，$1 \leq n \leq 20$。


## 样例 #1

### 输入

```
1 2
WC
CLASS
WC
```

### 输出

```
1
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何高效存储和查询高手方便去的地点，以统计与小萝莉在一起的时间。思路上，大多采用暴力匹配的方式，即对每一天小萝莉去的地方，在高手方便去的地点集合中查找。算法要点在于选择合适的数据结构，如set、map、数组等，难点主要是处理输入数据中的空格和Windows与Linux换行符差异问题。
- **Jelly_Goat题解**：
  - **星级**：4星
  - **关键亮点**：使用STL的set数据结构，详细介绍set的基本操作，对输入数据中Windows换行符问题处理讲解清晰，代码注释详细。
  - **个人心得**：强调读入数据要特判Windows下的换行符问题，同时提到字符串匹配问题可使用trie字典树和KMP算法，但数据范围小时可借助其他数据结构优化。
```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <set>
using namespace std;
int main()
{
    string input;
    set<string>qwq;
    int n,m,ans=0;
    scanf("%d%d",&n,&m);
    getline(cin,input);
    for (register int i=1;i<=n;i++)
    {
        getline(cin,input);
        if (input[input.size()-1]!=(char)13)
            input=input+char(13);
        qwq.insert(input);
    }
    for (register int i=1;i<=m;i++)
    {
        getline(cin,input);
        if (input[input.size()-1]!=(char)13)
            input=input+char(13);
        if (qwq.find(input)!=qwq.end())ans++;
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：先将高手方便去的地点读入并处理换行符后插入set，再对小萝莉每天去的地方同样处理换行符后在set中查找，若找到则计数加一。
- **longyuxuan题解**：
  - **星级**：4星
  - **关键亮点**：代码简洁，清晰指出读入数字后要吃掉换行符、地点可能含空格以及洛谷平台在getline后会加ASCLL码为13字符的问题及解决办法。
```cpp
#include<bits/stdc++.h>
using namespace std;
string gs[21],ll;
int n,m,ans=0;
int main()
{
    cin>>n>>m;
    getline(cin,ll);
    for(int i=1;i<=n;i++)
      getline(cin,gs[i]);
    for(int i=1;i<=m;i++)
    {
        getline(cin,ll);
         if(ll[ll.size()-1]!=13)ll=ll+(char)13;
        for(int j=1;j<=n;j++)
          if(ll==gs[j])
          {
              ans++;
              break;
          }
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：用数组存储高手方便去的地点，对小萝莉每天去的地方，处理换行符后与数组中地点逐一比较，相同则计数加一。
- **zhenghaishu题解**：
  - **星级**：4星
  - **关键亮点**：提供三种解法，分别使用map、set和getline函数，详细分析每种解法的原理、处理空格和换行符的方式，对Windows和Linux换行符区别讲解详细。
**解法一（map）核心代码**：
```cpp
#include <iostream>
#include <map>
#include <cstdio>
using namespace std;
int n, m;
string place;
int ans = 0;
map<string, bool> mp;
int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
    {
        cin >> place;
        string tmp;
        while(getchar() == ' ')
        {
            cin >> tmp;
            place += tmp;
        }
        mp[place] = true;
    }
    for(int i = 1; i <= m; i++)
    {
        cin >> place;
        string tmp;
        while(getchar() == ' ')
        {
            cin >> tmp;
            place += tmp;
        }
        if(mp[place])
        {
            ans++;
        }
    }
    cout << ans;
    return 0;
}
```
核心实现思想：将高手方便去的地点处理空格后存入map并标记为true，对小萝莉去的地方同样处理空格后在map中查找，若存在则计数加一。
**解法二（set）核心代码**：
```cpp
#include <iostream>
#include <set>
#include <cstdio>
using namespace std;
int n, m;
string place;
int ans = 0;
set<string> s;
int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
    {
        cin >> place;
        string tmp;
        while(getchar() == ' ')
        {
            cin >> tmp;
            place += tmp;
        }
        s.insert(place);
    }
    for(int i = 1; i <= m; i++)
    {
        cin >> place;
        string tmp;
        while(getchar() == ' ')
        {
            cin >> tmp;
            place += tmp;
        }
        if(s.count(place))
        {
            ans++;
        }
    }
    cout << ans;
    return 0;
}
```
核心实现思想：把高手方便去的地点处理空格后插入set，对小萝莉去的地方处理空格后用count函数在set中判断是否存在，存在则计数加一。
**解法三（getline）核心代码**：
```cpp
#include <iostream>
#include <set>
#include <cstdio>
using namespace std;
int main()
{
    string place;
    set<string> st;
    int n, m, ans=0;
    cin >> n >> m;
    getline(cin, place);
    for (int i=1; i<=n; i++)
    {
        getline(cin, place);
        st.insert(place);
    }
    for (int i=1; i<=m; i++)
    {
        getline(cin, place);
        if (m == i && place[place.size() - 1]!= '\r')
        {
            place += char(13);
        }
        if (st.find(place)!= st.end())
        {
            ans++;
        }
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：用getline读入高手方便去的地点插入set，对小萝莉去的地方，最后一行若缺少回车符则补上，然后在set中查找，存在则计数加一。

• 最优关键思路或技巧：针对本题数据范围，使用STL中的set或map数据结构能简洁高效地解决问题，同时要注意处理输入数据中的空格和换行符差异。在代码实现上，合理利用数据结构的特性和成员函数，如set的insert、find，map的插入和查找操作等。
• 可拓展之处：同类型题常考察字符串匹配、数据结构应用以及对输入数据细节处理。类似算法套路是根据数据范围和题目要求选择合适的数据结构，如数据量小可用数组暴力匹配，数据量大且需高效查找可考虑哈希表、平衡树等。
• 推荐题目：
  - P1083 借教室：涉及数组操作和二分查找，可锻炼对数据处理和算法结合能力。
  - P1308 统计单词数：字符串匹配问题，可进一步巩固字符串处理和查找技巧。
  - P1970 花匠：与本题类似，需对数据进行处理和统计，考察逻辑思维和代码实现能力。
• 个人心得摘录与总结：众多题解都提到输入数据处理的重要性，如读入数字后要吃掉换行符、处理地点字符串中的空格以及Windows和Linux换行符差异问题，这提示在解决字符串相关问题时，要充分考虑不同平台和输入格式带来的影响。同时，部分题解指出可根据数据范围选择合适数据结构优化算法，避免复杂数据结构带来的空间和时间浪费。 

---
处理用时：37.76秒
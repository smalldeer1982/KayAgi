# 题目信息

# 陶陶摘苹果（升级版）

## 题目描述

又是一年秋季时，陶陶家的苹果树结了 $n$ 个果子。陶陶又跑去摘苹果，这次他有一个 $a$ 公分的椅子。当他手够不着时，他会站到椅子上再试试。

这次与 NOIp2005 普及组第一题不同的是：陶陶之前搬凳子，力气只剩下 $s$ 了。当然，每次摘苹果时都要用一定的力气。陶陶想知道在 $s<0$ 之前最多能摘到多少个苹果。

现在已知 $n$ 个苹果到达地上的高度 $x_i$，椅子的高度 $a$，陶陶手伸直的最大长度 $b$，陶陶所剩的力气 $s$，陶陶摘一个苹果需要的力气 $y_i$，求陶陶最多能摘到多少个苹果。


## 说明/提示

对于 $100\%$ 的数据，$n\leq 5000$, $a\leq 50$, $b\leq 200$, $s\leq 1000$, $x_i\leq 280$, $y_i\leq 100$。


## 样例 #1

### 输入

```
8 15
20 130
120 3
150 2
110 7
180 1
50 8
200 0
140 3
120 2```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕贪心算法、搜索算法（DFS）、动态规划（背包问题）展开。贪心算法思路为优先选择消耗力气小且能摘到的苹果，因其时间复杂度低（$O(n)$），在本题中为最优解。搜索算法通过枚举每个苹果摘或不摘的情况求解，朴素DFS时间复杂度高（$O(2^n)$），需剪枝和记忆化搜索优化。动态规划将问题转化为背包模型，通过状态转移方程求解，时间复杂度为$O(nm)$。

### 所选的题解
 - **作者：ASZIIIS (赞：767)**
    - **星级**：5星
    - **关键亮点**：思路清晰全面，对搜索、动态规划、贪心算法三种解法详细阐述，包括原理、代码实现及优化过程，并对各算法时间复杂度对比分析。
    - **个人心得**：分享一题多解思路，从自身经历出发，激发读者一题多解欲望。
    - **重点代码 - 贪心算法**：
```cpp
#include<iostream>
#include<algorithm> 
using namespace std;
int n,s,a,b,x_,y_,can,rest,ans;
struct apple{
    int xi,yi;
}ap[50005];
int cmp(apple x,apple y){
    return x.yi<y.yi;
}
int main(){
    cin>>n>>s>>a>>b;
    for(int i=1;i<=n;i++){
        cin>>x_>>y_;
        if(x_<=a+b){
            can++;
            ap[can].xi=x_;
            ap[can].yi=y_;
        }
    }
    sort(ap+1,ap+can+1,cmp);
    rest=s;
    ans=0;
    for(int i=1;rest>=ap[i].yi&&i<=can;i++){
        ans++;
        rest-=ap[i].yi;
    }
    cout<<ans;
    return 0;
} 
```
    - **核心实现思想**：先筛选出能摘到的苹果，再按所需力气从小到大排序，依次摘取，直到力气不足。
 - **作者：tengkaize (赞：4)**
    - **星级**：4星
    - **关键亮点**：常规做法思路清晰，运用标准库与C++11语法简化代码，同时给出C#的Linq解法，还列举相关知识点。
    - **重点代码 - 简化后C++代码**：
```cpp
#include <iostream>
#include <iterator>
#include <algorithm>
#include <vector>

using namespace std;

struct Apple {
    int height;
    int weight;
};

istream& operator>>(istream& in, Apple& a) {
    in >> a.height >> a.weight;
    return in;
}

int main() {
    int n, s, a, b, h;
    cin >> n >> s >> a >> b;
    h = a + b;
    vector<Apple> apples;
    copy_if(
        istream_iterator<Apple>(cin),
        istream_iterator<Apple>(),
        back_inserter(apples),
        [h](const Apple& a) { return a.height <= h; }
    );
    sort(apples.begin(), apples.end(), [](const Apple& a1, const Apple& a2) {
        return a1.weight < a2.weight;
    });
    cout << count_if(apples.begin(), apples.end(), [&s](const Apple& a) {
        return (s -= a.weight) >= 0;
    });
    return 0;
}
```
    - **核心实现思想**：利用`copy_if`筛选出能摘到的苹果，`sort`按所需力气排序，`count_if`统计能摘的苹果数。
 - **作者：abtd (赞：3)**
    - **星级**：4星
    - **关键亮点**：代码简洁，使用STL的`pair`合并数据，简化代码结构，清晰体现贪心算法思路。
    - **重点代码**：
```cpp
#include <iostream>
#include <algorithm>
#include <utility>

using namespace std;

int n, a, b, s, ans;
pair<int,int> t[5005];  // second = xi; first = yi;

int main()
{
    cin >> n >> s >> a >> b;
    for (int i = 0; i < n; ++i)
    {
        cin >> t[i].second >> t[i].first;
    }
    sort(t, t + n);
    for (int i = 0; i < n; ++i)
    {
        if (t[i].second <= a + b && t[i].first <= s)
        {
            s -= t[i].first;
            ++ans;
        }
    }
    cout << ans << endl;
    return 0;
}
```
    - **核心实现思想**：用`pair`存储苹果高度和所需力气，排序后按贪心策略摘取苹果。

### 最优关键思路或技巧
贪心算法的关键在于选择合适的贪心策略，本题中由于每个苹果价值相同，选择所需力气小的苹果优先摘取，可最大化摘到的苹果数量。同时，部分题解在输入时筛选掉够不着的苹果，减少后续处理数据量，也是优化的小技巧。

### 可拓展之处
同类型题常涉及资源分配、任务调度等场景，类似算法套路为根据题目条件确定贪心策略，或转化为背包等动态规划模型求解。例如，在资源有限情况下，选择价值高且资源消耗少的任务执行。

### 相似知识点洛谷题目
 - **P1090 [NOIP2004 提高组] 合并果子**：通过贪心策略解决合并果子的最优代价问题。
 - **P1190 [NOIP2010 普及组] 接水问题**：运用贪心思想安排接水顺序以最小化总等待时间。
 - **P1223 排队接水**：同样是关于排队接水时间优化的贪心问题。 

---
处理用时：31.63秒
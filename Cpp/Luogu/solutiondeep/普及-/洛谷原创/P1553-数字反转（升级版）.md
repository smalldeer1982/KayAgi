# 题目信息

# 数字反转（升级版）

## 题目背景

**以下为原题面，仅供参考:**

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。整数反转是将所有数位对调；小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分；分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母；百分数的分子一定是整数，百分数只改变数字部分。整数新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零；小数新数的末尾不为 $0$（除非小数部分除了 $0$ 没有别的数，那么只保留1个 $0$）；分数不约分，分子和分母都不是小数（约分滴童鞋抱歉了，不能过哦。输入数据保证分母不为 $0$），本次没有负数。


## 题目描述

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。

- 整数反转是将所有数位对调。

- 小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分。

- 分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母。

- 百分数的分子一定是整数，百分数只改变数字部分。

## 说明/提示

**【数据范围】**

- 对于 $25\%$ 的数据，$s$ 是整数，不大于 $20$ 位；
- 对于 $25\%$ 的数据，$s$ 是小数，整数部分和小数部分均不大于 $10$ 位；
- 对于 $25\%$ 的数据，$s$ 是分数，分子和分母均不大于 $10$ 位；
- 对于 $25\%$ 的数据，$s$ 是百分数，分子不大于 $19$ 位。

**【数据保证】**

- 对于整数翻转而言，整数原数和整数新数满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数和原来的数字的最高位数字不应为零。

- 对于小数翻转而言，其小数点前面部分同上，小数点后面部分的形式，保证满足小数的常见形式，也就是末尾没有多余的 $0$（小数部分除了 $0$ 没有别的数，那么只保留 $1$ 个 $0$。若反转之后末尾数字出现 $0$，请省略多余的 $0$）

- 对于分数翻转而言，分数不约分，分子和分母都不是小数。输入的分母不为 $0$。与整数翻转相关规定见上。

- 对于百分数翻转而言，见与整数翻转相关内容。

数据不存在负数。

## 样例 #1

### 输入

```
5087462```

### 输出

```
2647805```

## 样例 #2

### 输入

```
600.084```

### 输出

```
6.48```

## 样例 #3

### 输入

```
700/27```

### 输出

```
7/72```

## 样例 #4

### 输入

```
8670%```

### 输出

```
768%```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何对整数、小数、分数、百分数进行反转展开。思路上，大多先判断输入数据的类型，再针对不同类型分别处理。算法要点在于实现数字反转及去除前导零、后导零。难点集中在处理各种数据类型的边界情况，如整数全为0、小数部分全为0、分数分母为0等。部分题解使用STL函数简化代码，部分则通过自定义函数或循环实现相同功能。

### 所选的题解
- **作者：Anguei (赞：293)  星级：5星**
    - **关键亮点**：对STL了解透彻，利用`std::reverse()`、`std::string::erase()`、`std::string::substr()`等函数，思路清晰，代码简洁。
    - **个人心得**：无
    - **核心代码**：
```cpp
// 自己写的反转函数，返回反转并去掉前导零之后的字符串
std::string reverse(std::string s) {
    int zeroCount = 0;
    std::reverse(s.begin(), s.end()); // 反转
    // 范围 for 循环，用于统计前导零个数
    for (auto i : s)
        if (i == 48) ++zeroCount;
        else break;
    s.erase(s.begin(), s.begin() + zeroCount);
    return (s!= ""? s : "0"); // 特判
}

// 用于去掉后导零
std::string deleteTail(std::string s) { 
    int zeroCount = 0;
    for (int i = s.size() - 1; i >= 0; --i)
        if (s[i] == 48) ++zeroCount;
        else break;
    s.erase(s.end() - zeroCount, s.end());
    return (s!= ""? s : "0");
}

int main() {
    std::string s;
    std::cin >> s;
    if (s.back() == '%') {
        std::cout << reverse(s.substr(0, s.size() - 1)) << "%" << std::endl;
        return 0;
    }
    for (auto i : s) {
        std::string left, right;
        if (i == '/') {
            left = s.substr(0, s.find("/"));
            right = s.substr(s.find("/") + 1);
            std::cout << reverse(left) << "/" << reverse(right) << std::endl;
            return 0;
        }
        if (i == '.') {
            left = s.substr(0, s.find("."));
            right = s.substr(s.find(".") + 1);
            std::cout << reverse(left) << "." << deleteTail(reverse(right)) << std::endl;
            return 0;
        }
    }
    // 最后剩下的一种情况是正整数
    std::cout << reverse(s) << std::endl;
    return 0;
}
```
    - **核心实现思想**：定义`reverse`函数反转字符串并去除前导零，`deleteTail`函数去除后导零。在`main`函数中，根据字符串的后缀或遍历结果判断数据类型，分别调用函数处理并输出。

- **作者：情到深处人孤独 (赞：41)  星级：4星**
    - **关键亮点**：将问题分解为多个子程序，每个子程序负责一种数据类型的处理，代码结构清晰，易于理解和维护。
    - **个人心得**：无
    - **核心代码**：
```cpp
int find(string S)
{
    for (int i = 0; i <= S.size() - 1; i++)
    {
        if (S[i] == '.')
        {
            a = i;
            return 1;
        }    //是小数返回1
        if (S[i] == '/')
        {
            a = i;
            return 2;
        }    //是分数返回2
        if (S[i] == '%')
        {
            a = i;
            return 3;
        }    //是百分数返回3
    }
    return 0;    //是整数返回0
}

void integer(string S)    //整数程序
{
    for (int i = S.size() - 1; i >= 1; i--)
        if (S[i] == '0')
            S = S.erase(i, 1);
        else
            break;
    for (int i = S.size() - 1; i >= 0; i--)
        cout << S[i];
}

void decimals(string S)    //小数程序
{
    n = S.substr(0, a);    //小数点前整数部分
    m = S.substr(a + 1, S.size() - (a + 1));    //小数点后小数部分
    integer(n);    //整数部分用整数处理
    cout << ".";
    int i = 0;
    while (m!= "")
    {
        if (m[i] == '0')
            m = m.erase(0, 1);
        else
            break;
    }
    if (m == "")
        m = "0";
    for (i = m.size() - 1; i >= 0; i--)
        cout << m[i];
}

void fraction(string S)    //分数程序
{
    n = S.substr(0, a);    //同小数，分数线前分子
    m = S.substr(a + 1, S.size() - (a + 1));    //分数线后分母
    integer(n);    //分子调用整数程序
    cout << "/";
    integer(m);    //分母调用整数程序
}

void percentage(string S)    //百分数程序
{
    S = S.erase(S.size() - 1, 1);    //调用整数程序前先去百分号
    integer(S);    //数字调用整数程序
    cout << "%";
}

int main()
{
    cin >> s;
    b = find(s);
    if (b == 0)
        integer(s);
    if (b == 1)
        decimals(s);
    if (b == 2)
        fraction(s);
    if (b == 3)
        percentage(s);
    return 0;
}
```
    - **核心实现思想**：`find`函数判断字符串类型并返回相应标识。`integer`函数处理整数反转及去尾零。`decimals`函数将小数分为整数和小数部分分别处理。`fraction`函数处理分数，分别反转分子分母。`percentage`函数去除百分号后按整数处理。`main`函数根据`find`函数返回值调用相应子程序。

- **作者：张鑫杰 (赞：4)  星级：4星**
    - **关键亮点**：采用面向对象编程思想，定义`var`类，将数据类型判断、反转等操作封装在类中，代码具有良好的封装性和可读性。
    - **个人心得**：无
    - **核心代码**：
```cpp
class var {
    friend ostream& operator<<(ostream& os, const var& a);
private:
    string numLeft;
    string numRight;
    enum typeName {
        longint, decimal, fraction, percentage
    };
    typeName type;
public:
    var(string input) {
        type = longint;
        numLeft = input;
        for (int i = 0; i!= input.size(); i++) {
            if (input[i] == '%') {
                type = percentage;
                numLeft = input.substr(0, i);
                break;
            }
            if (input[i] == '.') {
                type = decimal;
                numLeft = input.substr(0, i);
                numRight = input.substr(i + 1);
                break;
            }
            if (input[i] == '/') {
                type = fraction;
                numLeft = input.substr(0, i);
                numRight = input.substr(i + 1);
                break;
            }
        }
    }
    var() = default;
    var turnAround() {
        bool flag = true;
        if (type == longint || type == percentage) {
            reverse(numLeft.begin(), numLeft.end());
            for (unsigned int i = 0; i < numLeft.size(); i++) {
                if (flag && numLeft[i]!= '0') {
                    flag = false;
                    if (i!= 0) {
                        numLeft.erase(0, i);
                    }
                }
                if (flag && i!= 0 && i == numLeft.size() - 1) {
                    numLeft.erase(0, i);
                }
            }
        }
        else {
            reverse(numLeft.begin(), numLeft.end());
            reverse(numRight.begin(), numRight.end());
            for (unsigned int i = 0; i < numLeft.size(); i++) {
                if (flag && numLeft[i]!= '0') {
                    flag = false;
                    if (i!= 0) {
                        numLeft.erase(0, i);
                    }
                }
                if (flag && i!= 0 && i == numLeft.size() - 1) {
                    numLeft.erase(0, i);
                }
            }
            flag = true;
            for (unsigned int i = 0; i < numRight.size(); i++) {
                if (flag && numRight[i]!= '0') {
                    flag = false;
                    if (i!= 0) {
                        numRight.erase(0, i);
                    }
                }
                if (flag && i!= 0 && i == numRight.size() - 1) {
                    numRight.erase(0, i);
                }
            }
        }
        if (type == var::decimal) {
            for (int i = static_cast<int>(numRight.size()) - 1; i >= 0; i--) {
                if (numRight[i]!= '0' || i == 0) {
                    break;
                }
                if (numRight[i] == '0') {
                    numRight.erase(i);
                }
            }
        }
        return *this;
    }
};

istream& operator>>(istream& is, var& a) {
    string tmp;
    is >> tmp;
    a = var(tmp);
    return is;
}

ostream& operator<<(ostream& os, const var& a) {
    string out;
    if (a.type == var::percentage) {
        out = a.numLeft;
        out += "%";
    }
    else if (a.type == var::fraction) {
        out = a.numLeft;
        out += '/';
        out += a.numRight;
    }
    else if (a.type == var::decimal) {
        out = a.numLeft;
        out += '.';
        out += a.numRight;
    }
    else {
        out = a.numLeft;
    }
    os << out;
    return os;
}

int main() {
    var i;
    cin >> i;
    i.turnAround();
    cout << i;
    return 0;
}
```
    - **核心实现思想**：`var`类的构造函数判断输入字符串类型并初始化成员变量。`turnAround`函数根据数据类型进行相应反转和去零操作。重载`>>`和`<<`运算符方便输入输出。`main`函数输入数据，调用`turnAround`函数处理后输出。

### 最优关键思路或技巧
利用STL提供的函数（如`std::reverse`、`std::string::erase`、`std::string::substr`等）可以简化代码实现，提高代码的可读性和效率。将不同数据类型的处理封装成独立函数或类的成员函数，使代码结构更清晰，易于维护和扩展。

### 可拓展思路
此类题目可拓展到处理更复杂的数据类型或格式，如科学计数法、带单位的数字等。类似算法套路包括先识别数据类型，再针对不同类型进行特定处理，同时注意边界条件和特殊情况。

### 相似知识点题目推荐
 - **P1055 [NOIP2008 普及组] ISBN 号码**：涉及字符串处理和校验计算，与本题处理字符串并按规则操作类似。
 - **P1307 [NOIP2011 普及组] 数字反转**：基础的数字反转题目，可作为本题的简化版进行练习。
 - **P1909 [NOIP2016 普及组] 买铅笔**：同样是对输入数据进行分析处理，根据不同条件计算结果，锻炼条件判断和数据处理能力。

### 个人心得摘录与总结
 - **作者：SebMa**：细节太多，要周密考虑，多次提交才AC。总结出处理复杂问题需全面思考各种情况。
 - **作者：Mono_pigsicklie**：调试中发现多处错误，如未判断多个0、小数部分翻转后0的处理等。强调了边界条件和特殊情况处理在编程中的重要性。
 - **作者：中2少年雷耶斯**：辗转二十余次才做对，在小数部分卡了很多次。说明小数部分的处理相对复杂，需要特别关注。 

---
处理用时：75.15秒
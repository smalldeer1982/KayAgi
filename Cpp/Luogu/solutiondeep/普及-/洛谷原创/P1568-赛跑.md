# 题目信息

# 赛跑

## 题目背景

赛跑

## 题目描述

SH的跑步成绩一直不太理想。为了帮助SH提高成绩，KC决定和他进行一次赛跑。比赛的起点设在农场主的屋前，他们同时出发，沿着同一方向，直到跑到终点----农场远处的一棵树下。

他们的跑步速度在一些时间段内是恒定的。比如：SH在前３个时间段速度是５，接着６个时间段内速度是１０。他们的比赛总时间相同。他们希望能统计出在整个比赛过程中领先顺序的变化次数。举个例子，某个时刻SH领先，下个时刻KC领先，这就是一次领先顺序的变化；如果某个时刻SH领先，接下来一段时间KC赶上来并和SH齐头并进，但最终还是超过了SH，这也是一次领先顺序的变化。


## 说明/提示

输入：SH在前 $2$ 个单位时间内速度是 $1$，接着 $1$ 个单位时间内速度是 $4$，接着 $1$ 个单位时间内速度是 $1$，最后 $10$ 个单位时间内速度是 $2$。KC在前 $3$ 个个单位时间内速度是 $2$，接着 $2$ 个单位时间内速度是 $2$，最后 $9$ 个单位时间内速度是 $3$。

输出：比赛开始后KC领先，直到第 $5$ 个单位时间SH超过KC（第一次领先顺序变化），接着第 $7$ 个单位时间时，KC又反超SH，变成领先（第二次领先顺序变化）。


## 样例 #1

### 输入

```
4 3
1 2
4 1
1 1
2 10
2 3
1 2
3 9
```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕模拟两人赛跑过程，统计领先顺序变化次数。思路上，多数题解通过模拟每一秒或每个关键时间点来比较两人路程，判断领先顺序变化。算法要点在于准确读入速度和时间数据，实时更新两人路程并比较。解决难点主要是处理两人速度和时间的随机片段，以及如何准确判断领先顺序的变化。

从质量上看，多数题解思路清晰但代码实现和优化程度有所差异。部分题解直接模拟每一秒情况，代码相对简单但效率较低；少数题解通过取两人时间片段最小值等方式优化，减少模拟次数。

### 所选的题解
- **作者：sdxjzsq（5星）**
    - **关键亮点**：代码简洁高效，在读取KC数据时同步处理，通过巧妙设置变量初始值和函数判断领先情况，减少不必要循环，优化了模拟过程。
    - **个人心得**：首次写题解，强调对细节的处理，如变量初始值设定原因。
    - **核心代码**：
```cpp
int work(int x) {
    if (x > 0)return 1;
    else if (x == 0)return z;
    return 0;
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d%d", &vn[i], &tn[i]);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &vm[i], &tm[i]);
        while (mt <= i) {
            if (tm[mt] == 0 && mt <= m + 1) {
                mt++;
                continue;
            }
            if (tn[nt] == 0 && nt <= n + 1)nt++;
            wm += vm[mt];
            tm[mt]--;
            wn += vn[nt];
            tn[nt]--;
            int s = wm - wn;
            if (work(s)!= z) {
                ans++;
                z = work(s);
            }
        }
    }
    if (ans == -1)ans = 0;
    printf("%d", ans);
    return 0;
}
```
核心思想：通过`work`函数判断两人距离差的符号确定领先情况，在循环读入KC数据时，同步更新两人路程，比较领先情况并计数。

- **作者：heidoudou（4星）**
    - **关键亮点**：先采用最笨但出错率低的模拟每一秒方法AC，再优化为每次取两人时间片段最小值消耗，逐步优化思路清晰。
    - **个人心得**：开始追求最优解导致小bug难调试，后从笨方法入手再优化，代码更美观。
    - **核心代码**：
```cpp
for (i = 1, j = 1; i <= n && j <= m;) {
    t = min(t1[i], t2[j]);
    d1 += s1[i] * t;
    d2 += s2[j] * t;
    if (d1!= d2 && (d1 > d2)!= state) {
        state = (d1 > d2);
        change++;
    }
    t1[i] -= t;
    t2[j] -= t;
    if (t1[i] == 0) ++i;
    if (t2[j] == 0) ++j;
}
```
核心思想：通过`min`函数取两人当前时间片段最小值`t`，更新两人路程，根据路程比较结果和之前领先状态判断领先顺序是否变化。

- **作者：buickboy（4星）**
    - **关键亮点**：代码简洁，通过自定义函数读入数据并计算前缀和，利用前缀和数组模拟每一秒路程，清晰处理领先顺序判断和变化计数。
    - **关键代码**：
```cpp
void read(int *p, int x) { 
    int k = 0, v, t;
    while (x--) {
        cin >> v >> t;
        while (t--)
            p[++k] = v, p[k] += p[k - 1];
    }
    tm = k; 
}
int main() {
    int i, k = 0;
    cin >> n >> m;
    read(a, n);
    read(b, m);
    for (i = 1; i <= tm; ++i)
        if (a[i]!= b[i]) {
            f = a[i] > b[i]? 1 : 0;
            break;
        }
    for (++i; i <= tm; ++i)
        if (a[i] > b[i] &&!f)
            k++, f = 1;
        else if (a[i] < b[i] && f)
            k++, f = 0;
    cout << k;
    return 0;
}
```
核心思想：`read`函数填充路程数组并计算前缀和，主函数中先找到首次领先情况，再从下一秒开始比较前缀和数组判断领先顺序变化。

### 最优关键思路或技巧
1. **优化模拟过程**：如sdxjzsq在输入时同步处理数据，heidoudou每次取时间片段最小值，减少不必要模拟次数，提高效率。
2. **合理设置变量**：像sdxjzsq通过设置合适的变量初始值，简化领先顺序变化判断逻辑。
3. **利用前缀和**：buickboy利用前缀和数组方便地模拟每一秒路程，使代码简洁明了。

### 可拓展思路
同类型题可涉及不同运动场景，如环形跑道、往返跑等，类似算法套路为准确模拟运动过程，处理好速度、时间和路程关系，关注状态变化条件并计数。

### 洛谷相似题目推荐
1. P1036 [NOIP2002 普及组] 选数：涉及组合模拟和条件判断。
2. P1161 开灯：通过模拟灯的开关状态变化求解。
3. P1909 买铅笔：根据不同购买方案模拟计算最优解。

### 个人心得摘录与总结
heidoudou提到开始追求最优解导致小bug难调试，建议从简单方法入手先AC再优化，这样思路更清晰且代码可能更美观。这表明在解题时，不要一开始就陷入复杂优化，可先确保实现基本功能，再逐步改进。 

---
处理用时：32.49秒
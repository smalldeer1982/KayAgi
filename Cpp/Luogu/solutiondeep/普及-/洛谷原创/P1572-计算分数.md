# 题目信息

# 计算分数

## 题目描述

Csh 被老妈关在家里做分数计算题，但显然他不愿意做这么多复杂的计算。况且在家门口还有 Xxq 在等着他去一起看电影。为了尽快地能去陪 Xxq 看电影，他把剩下的计算题交给了你，你能帮他解决问题吗？


## 说明/提示

### 数据范围及约定

对于所有测试点，输入计算式长度在 $100$ 以内，分子、分母在 $1000$ 以内。同时保证，直接从前往后直接计算分数的和或者差，然后立刻化简，这么做的中间结果不会超过 int 的范围。

注意输入的分数不一定是最简分数。


------------
2024/2/13 添加 2 组 hack 数据。

## 样例 #1

### 输入

```
2/1+1/3-1/4```

### 输出

```
25/12```

# AI分析结果

### 综合分析与结论
这些题解均围绕分数加减法运算展开，核心思路是模拟分数运算规则，先通分再进行加减，最后约分。算法要点包括计算最大公约数（gcd）用于约分、最小公倍数（lcm）用于通分，以及对输入分数的处理和结果的输出格式化。解决难点在于避免计算过程中数据溢出，确保中间结果及时化简，处理分数的正负号以及输出格式的正确性。

从质量上看，多数题解思路清晰，代码可读性尚可，但部分题解在细节处理或代码优化上存在不足。

### 所选的题解
- **作者：ggylz49 (5星)**
    - **关键亮点**：详细介绍解题用到的C++ STL知识，代码结构清晰，模块化程度高，对分数的约分、加减操作分别封装成函数，易于理解和维护。
    - **个人心得**：提到最初未对第一次输入的分数约分导致结果错误，强调输入时先约分的重要性。
    - **核心代码**：
```cpp
struct fs
{
    long long fm,fz;
};
fs yf(fs a)
{
    long long m=__gcd(a.fm,a.fz);
    a.fm/=m;
    a.fz/=m;
    return a;
}
fs jia(fs x,fs y)
{
    long long z=x.fm*y.fm;
    x.fz*=y.fm;
    y.fz*=x.fm;
    x.fm=z;
    y.fm=z;
    fs answer;
    answer.fz=x.fz+y.fz;
    answer.fm=x.fm;
    return yf(answer);
}
fs jian(fs x,fs y)
{
    long long z=x.fm*y.fm;
    x.fz*=y.fm;
    y.fz*=x.fm;
    x.fm=z;
    y.fm=z;
    fs answer;
    answer.fz=x.fz-y.fz;
    answer.fm=x.fm;
    return yf(answer);
}
int main()
{
    fs a,b;
    char ysf;
    scanf("%lld/%lld",&a.fz,&a.fm);
    a=yf(a);
    cin>>ysf;
    while (scanf("%lld/%lld",&b.fz,&b.fm)!=EOF)
    {
        if (ysf==EOF)break;
        else if (ysf=='+'){a=jia(a,b);}
        else if (ysf=='-'){a=jian(a,b);}
        cin>>ysf;
    }
    if (a.fm<0&&a.fz>0)
    {
        a.fm=abs(a.fm);
        a.fz-=a.fz*2;
    }
    if (a.fm==1)cout<<a.fz;
    else cout<<a.fz<<'/'<<a.fm;
    return 0;
}
```
核心实现思想：定义 `fs` 结构体表示分数，`yf` 函数用于约分，`jia` 和 `jian` 函数分别实现分数加法和减法，主函数中循环读入分数和运算符进行计算，并处理结果的正负号和输出格式。

- **作者：int_stl (4星)**
    - **关键亮点**：利用数学公式清晰阐述通分过程，代码简洁明了，使用 `lcm` 函数计算最小公倍数进行通分，对结果的处理全面，考虑了多种输出情况。
    - **核心代码**：
```cpp
int gcd(int a, int b) { return b? gcd(b, a % b) : a; }
int lcm(int a, int b) { return a / gcd(a, b) * b; }
int sgn(int x) {
	if (x > 0) return 1;
	if (x < 0) return -1;
}
signed main() {
	int fz = 0, fm = 0; 
	int a, b; char ch;
	cin >> a >> ch >> b, fz = a, fm = b;
	while (cin >> a >> ch >> b) {
		int nowb = lcm(fm, b);
		a = a * (nowb / b);
		b = nowb;
		fz = fz * (nowb / fm);
		fm = nowb;
		fz += a;
		int t = gcd(fz, fm);
		fz /= t, fm /= t;
	}
	int t = gcd(fz, fm);
	fz /= t, fm /= t;
	if (fz % fm == 0) { 
		cout << fz / fm;
	}
	else {
		if (fz == 0) {
			cout << 0;
		}
		else {
			if (sgn(fz) == -sgn(fm)) {
				cout << "-" << abs(fz) << "/" << abs(fm);
			}
			else {
				cout << fz << "/" << fm;
			}
		}
	}
}
```
核心实现思想：通过 `gcd` 和 `lcm` 函数分别计算最大公约数和最小公倍数，在循环中对读入的分数进行通分、累加和约分操作，最后根据分子分母的关系和正负性处理输出。

- **作者：zhang_Jimmy (4星)**
    - **关键亮点**：对题目细节把握准确，详细阐述读入、计算、约分和输出的处理过程，代码逻辑清晰，通过自定义函数实现通分和约分，增强代码可读性。
    - **核心代码**：
```cpp
int lcm(int a, int b){
	return a / __gcd(a, b) * b;
}

void tongfen(){
	int t = lcm(ansfm, fm);
	int anssum = t / ansfm;
	int sum = t / fm;
	ansfz *= anssum;
	ansfm *= anssum;
	fz *= sum;
	fm *= sum;
}

void yuefen(){
	int t = __gcd(ansfz, ansfm);
	ansfz /= t;
	ansfm /= t;
}

signed main(){
	cin >> ansfz >> b >> ansfm;
	while(cin >> a >> fz >> b >> fm){
		tongfen();
		if(a == '+') ansfz += fz;
		else ansfz -= fz;
		yuefen();
	}
	yuefen();
	if(ansfm < 0) cout << -ansfz << "/" << -ansfm;
	else if(ansfm!= 1) cout << ansfz << "/" << ansfm;
	else cout << ansfz;
	return 0;
}
```
核心实现思想：`lcm` 函数计算最小公倍数，`tongfen` 函数实现通分，`yuefen` 函数进行约分，主函数中读入分数并按顺序进行通分、加减、约分操作，最后根据分母情况处理输出。

### 最优关键思路或技巧
- **模块化编程**：将分数的约分、通分、加减等操作封装成独立函数，使代码结构清晰，易于维护和理解，如 `ggylz49` 的题解。
- **及时化简**：在每次分数运算后立即进行约分，避免中间结果溢出，这是所有题解都遵循的重要原则。
- **处理边界情况**：全面考虑输入输出的各种边界情况，如分子分母的正负性、分母为1、分子为0等，确保结果的正确性。

### 可拓展之处
同类型题或类似算法套路：此类题目可拓展到分数的乘除运算，以及更复杂的分数混合运算。算法套路依然是模拟分数运算规则，注意运算顺序和中间结果的化简。

### 相似知识点洛谷题目
- **P1075 [NOIP2012 普及组] 质因数分解**：考察数论相关知识，涉及最大公约数、最小公倍数等概念的运用。
- **P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题**：专注于最大公约数和最小公倍数的计算与应用。
- **P1888 三角函数**：结合三角函数知识，可能涉及分数运算和化简，与本题在分数处理上有相似之处。 

---
处理用时：36.57秒
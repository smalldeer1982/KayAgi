# 题目信息

# 斯诺登的密码

## 题目背景

根据斯诺登事件出的一道水题


## 题目描述

2013 年 X 月 X 日，俄罗斯办理了斯诺登的护照，于是他混迹于一架开往委内瑞拉的飞机。但是，这件事情太不周密了，因为 FBI 的间谍早已获悉他的具体位置——但这不是最重要的——最重要的是如果要去委内瑞拉，那么就要经过古巴，而经过古巴的路在美国的掌控之中。

丧心病狂的奥巴马迫降斯诺登的飞机，搜查时却发现，斯诺登杳无踪迹。但是，在据说是斯诺登的座位上，发现了一张纸条。纸条由纯英文构成：`Obama is a two five zero.`（以 `.` 结束输出，只有 $6$ 个单词+一个句号，句子开头如没有大写亦为合法）这句话虽然有点无厘头，但是警官陈珺骛发现这是一条极其重要的线索。他在斯诺登截获的一台笔记本中找到了一个 C++ 程序，输入这条句子后立马给出了相对应的密码。陈珺鹜高兴得晕了过去，身为警官的你把字条和程序带上了飞机，准备飞往曼哈顿国际机场，但是在飞机上检查的时候发现——程序被粉碎了！飞机抵达华盛顿只剩 $5$ 分钟，你必须在这 $5$ 分钟内编写（杜撰）一个程序，免受上司的 $10000000000 \bmod 10$ 大板。破译密码的步骤如下：

（1）找出句子中所有用英文表示的数字 $(\leq 20)$，列举在下：

正规：`one two three four five six seven eight nine ten eleven twelve`
           `thirteen fourteen fifteen sixteen seventeen eighteen nineteen             twenty`

非正规：`a both another first second third`。为避免造成歧义，`another` 算作 $1$ 处理。

（2）将这些数字平方后对 $100$ 取模，如 $00,05,11,19,86,99$。

（3）把这些两位数按数位排成一行，组成一个新数，如果开头为 $0$，就去 $0$。

（4）找出所有排列方法中最小的一个数，即为密码。

// 数据已经修正 By absi2011 如果还有问题请联系我


## 样例 #1

### 输入

```
Black Obama is two five zero .```

### 输出

```
425```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均是依据题目规则，将输入句子中的英文数字转换为数字，平方后对100取模，再按数位排成最小数。算法要点在于英文数字与数值的映射构建及结果的排序输出。解决难点主要是处理输出格式，如非首位且小于10的数补0、去除前导0以及特判无数字时输出0。

多数题解使用数组、map等数据结构建立英文数字与对应数值的映射关系，通过循环读入单词并判断是否为英文数字，将符合要求的数字处理后存入数组，最后排序输出。部分题解在输出格式处理上各有不同方式。

### 所选的题解
- **作者：ZigZagKmp (赞：178)  5星**
    - **关键亮点**：思路清晰，代码简洁，详细注释辅助理解。利用printf("%.2d",a[i])巧妙处理输出格式，避免复杂的字符串操作。使用贪心策略，通过sort排序确保结果最小。
    - **重点代码及核心思想**：
```cpp
#include<bits/stdc++.h>
using namespace std;
char dic[30][20]={"zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty","a","both","another","first","second","third"};
int di[30]={0,1,4,9,16,25,36,49,64,81,00,21,44,69,96,25,56,89,24,61,0,1,4,1,1,4,9};
unsigned long long int a[10],top,flag;
int i,j;
char s[100];
int main()
{
     for(i=1;i<=6;i++)
     {
          scanf("%s",&s);
          for(j=1;j<=26;j++)
          {
               if(!strcmp(s,dic[j]))
               {
                    a[++top]=di[j];
                    break;
               }
          }
      }
      sort(a+1,a+top+1);
      for(i=1;i<=top;i++)
      {
           if(flag)
           {
                printf("%.2d",a[i]);
           }
           else
           {
                if(a[i])
                { 
                     printf("%d",a[i]);
                     flag=1;
                }
            }
     }
     if(!flag)printf("0");
     return 0;
}
```
核心思想是通过两个数组建立英文数字与处理后数值的映射，读入单词匹配后存入数组，排序后按特定格式输出。
- **作者：Maktub (赞：149)  5星**
    - **关键亮点**：使用map<string, int>建立映射，代码简洁直观，易于理解和维护。清晰的注释增强了代码可读性，对输出格式处理得当。
    - **重点代码及核心思想**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
map<string,int>q;
const int mx=66;
int top;
int st[mx];
string s;
int main(){
     q["one"]=1;q["two"]=2;q["three"]=3;q["four"]=4;q["five"]=5;q["six"]=6;q["seven"]=7;q["eight"]=8;q["nine"]=9;q["ten"]=10;
     q["eleven"]=11;q["twelve"]=12;q["thirteen"]=13;q["fourteen"]=14;q["fifteen"]=15;q["sixteen"]=16;q["seventeen"]=17;q["eighteen"]=18;q["nineteen"]=19;q["twenty"]=20;
     q["a"]=1;q["both"]=2;q["another"]=1;q["first"]=1;q["second"]=2;q["third"]=3;
     for(int i=1;i<=6;i++){
          cin>>s;
          if(q[s]){
               int k=q[s]*q[s]%100;
               if(k==0)continue;
               st[++top]=k;
          }
     }
     sort(st+1,st+top+1);
     cout<<st[1];
     for(int i=2;i<=top;i++){
          if(st[i]<10)cout<<0;
          cout<<st[i];
     }
     return 0;
}
```
核心思想是利用map快速查找英文数字对应的数值，处理后存入数组，排序后按格式输出。
- **作者：hsfzLZH1 (赞：4)  4星**
    - **关键亮点**：详细解释了map的使用及排序原理，帮助理解。对输入单词统一转小写处理，使代码更具鲁棒性。
    - **重点代码及核心思想**：
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<map>
#include<string>
using namespace std;
map<string,int>m;
int l,cur;
string s,ans[6];
int main()
{
    m["one"]=1;m["two"]=2;m["three"]=3;m["four"]=4;m["five"]=5;
    m["six"]=6;m["seven"]=7;m["eight"]=8;m["nine"]=9;m["ten"]=10;
    m["eleven"]=11;m["twelve"]=12;m["thirteen"]=13;m["fourteen"]=14;m["fifteen"]=15;
    m["sixteen"]=16;m["seventeen"]=17;m["eighteen"]=18;m["nineteen"]=19;m["twenty"]=20;
    m["a"]=1;m["both"]=2;m["another"]=1;m["first"]=1;m["second"]=2;m["third"]=3;
    for(int i=0;i<6;i++)
    {
        cin>>s;
        l=s.length();
        for(int j=0;j<l;j++)if(s[j]<='Z'&&s[j]>='A')s[j]+='a'-'A';
        if(m[s])
        {
            ans[cur]+=(m[s]*m[s]%100)/10+'0'; 
            ans[cur]+=(m[s]*m[s]%100)%10+'0';
            cur++;
        }
    }
    if(cur==0){cout<<0<<endl;return 0;}
    sort(ans,ans+cur);
    if(ans[0][0]=='0')cout<<ans[0][1];
    else cout<<ans[0];
    for(int i=1;i<cur;i++)cout<<ans[i];
    cout<<endl;
    return 0;
}
```
核心思想是借助map建立映射，读入单词转小写后匹配，将处理结果存入数组，排序后按要求输出。

### 最优关键思路或技巧
- **数据结构选择**：使用map可高效建立英文数字与数值的映射关系，便于查找和处理。如Maktub和hsfzLZH1的题解，代码简洁且逻辑清晰。
- **输出格式处理**：像ZigZagKmp使用printf("%.2d", a[i])控制输出格式，简洁有效地解决了补0问题。部分题解通过对数组元素按100进制累加的方式避免了复杂的前导0处理。

### 可拓展之处
此类题目属于字符串处理与数值计算结合的类型，类似套路包括建立特定映射关系、按规则处理数值、注重输出格式。拓展方向可增加英文数字范围、改变数值处理规则或增加字符串干扰信息等。

### 相似知识点洛谷题目
- **P1055 [NOIP2008 普及组] ISBN 号码**：涉及字符串处理与简单数值计算校验。
- **P1255 数楼梯**：结合字符串输入与递推算法，与本题处理输入并计算结果有相似处。
- **P1909 买铅笔**：同样是输入处理与数值计算优化，选择最优方案，类似本题找最小数的思路。

### 个人心得摘录及总结
- **作者：zhaowangji**：多次搁置题目，最后完成算是“还债”。建议先打好英文数字与对应运算结果的表，方便后续处理。总结为提前规划数据映射关系，可简化编程过程。
- **作者：Error_Eric**：指出题目有多个关于输出格式的坑点，如个位数补0、首位不补0、无输出时补0等。强调处理输出格式需谨慎细致，全面考虑各种情况。 

---
处理用时：47.17秒
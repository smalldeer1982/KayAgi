# 题目信息

# 爱与愁过火

## 题目背景

（本道题目隐藏了两首歌名，找找看哪~~~）

《爱与愁的故事第一弹·heartache》第三章。

爱与愁大神说这是ta的伤心指数，只不过现在好很多了，翻译只是看你无聊让你动动脑筋罢了（shit~~~）。虽然月落乌啼嘴上骂着：“我去年买了个表……纽曼表……”，但是结果还是请爱与愁大神去Pizza Hut吃了一顿。


## 题目描述

到了 Pizza Hut，爱与愁大神由于不爽，所以存心想坑月落乌啼的钱，他点了 $m$ 样菜，每样菜 $a_i$ 元。月落乌啼预计只用 $n$ 元，于是他让爱与愁大神重新从这 $m$ 样菜中选 $r$ 样。

爱与愁大神还是想坑钱，于是他打电话给你，让你编一个程序告诉他有几种方案可以从 $m$ 样菜中点取 $r$ 样菜但是还能超过月落乌啼的预计 $n$ 元。

## 说明/提示

### 数据范围及约定

对于 $100\%$ 数据，$m \le 30$，$r \le m$，$m \le a_i \le 90n \le 2700$。


## 样例 #1

### 输入

```
5 2 8

1 7 2 5 4```

### 输出

```
4```

# AI分析结果

• **综合分析与结论**：本题主要求从\(m\)样菜中选\(r\)样且总价超过\(n\)元的方案数。题解主要分为动态规划（DP）和深度优先搜索（DFS）两类。DP思路多借鉴01背包，通过状态转移方程计算方案数；DFS则通过递归枚举所有可能组合，并利用剪枝优化以避免不必要搜索。

**动态规划**：
 - **算法要点**：定义状态表示，如\(dp[i][j][k]\)（或经压维后的二维数组）表示在前\(i\)样菜中选\(j\)样花费为\(k\)元的方案数，通过状态转移方程\(dp[i][j][k]=dp[i - 1][j][k]+dp[i - 1][j - 1][k - a[i]]\)（当\(k\geq a[i]\)时）进行计算，最后累加满足条件（花费大于\(n\)）的方案数。
 - **解决难点**：状态定义与转移方程推导，以及处理三维数组时可能需要的压维操作以优化空间复杂度。

**深度优先搜索**：
 - **算法要点**：通过递归枚举选择的菜品，记录已选菜品数量和总价。利用剪枝策略，如剩余菜品不足\(r\)样时直接返回；当前总价已超过\(n\)时，直接计算剩余组合数并返回，从而减少搜索量。
 - **解决难点**：设计有效的剪枝策略，避免超时。

整体来看，DP方法时间复杂度相对稳定，代码实现相对简洁；DFS方法直观但需精细剪枝优化，否则易超时。

**评分**：
 - **深海鱼的眼泪**：4星。思路清晰，借鉴01背包思路，代码简洁明了，直接利用类似01背包的方法解决问题。
```cpp
#include <iostream>
using namespace std;
int main(){
    int m,r,n,i,a[40],f[40][3000],j,k,t=0,ans=0;
    cin>>m>>r>>n;
    for (i=1;i<=m;i++){
        cin>>a[i];
        t+=a[i];
    }
    f[0][0]=1;
    for (i=1;i<=t;i++){
        f[0][i]=0;
    }                                          //没有什么用的初始化
    for (i=1;i<=m;i++){
        for (j=r;j>=1;j--){                          //逆序枚举物品件数
            for (k=a[i];k<=t;k++){
                f[j][k]+=f[j-1][k-a[i]];
            }
        }
    }
    for (i=n+1;i<=t;i++){
        ans+=f[r][i];                       //把大于n结果都加起来
    }
    cout<<ans;
    return 0;
} 
```
核心实现思想：利用三维状态压缩为二维数组\(f[j][k]\)，表示\(j\)件物品总价为\(k\)元的方案数，通过三层循环，分别枚举菜品、所选菜品数量和总价，依据状态转移方程更新方案数，最后累加总价大于\(n\)的方案数。

 - **雪风舞者**：4星。详细展示了DFS从朴素到优化的过程，剪枝策略讲解清晰，代码有详细注释，优化后的代码效率较高。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int m,r,n,a[35],ans=0;
int c[35][35];
bool cmp(int a,int b){//自定义比较函数，sort从大到小
    return a>b;
}
//lst上个确定的菜是哪个(防止记重),p当前已经确定几个菜,
//f已经花了多少钱 
void dfs(int lst,int p,int f){
	if(f>n||p==r){
		if(f>n) ans+=c[m-lst][r-p];
		return;
	}
	for(int i=lst+1;i<=m-r+p+1;i++)
		dfs(i,p+1,f+a[i]);
}
int  main(){
	scanf("%d%d%d",&m,&r,&n);
	for(int i=1;i<=m;i++)
		scanf("%d",&a[i]);
	memset(c,0,sizeof(c));
	c[0][0]=1;//直接在main中预处理了，懒~~~
	for(int i=1;i<=m;i++){
		c[i][0]=1;
		for(int j=1;j<=i;j++)
			c[i][j]=c[i-1][j]+c[i-1][j-1];
	}
	sort(a+1,a+m+1,cmp);
	dfs(0,0,0);
	printf("%d\n",ans);
	return 0;
}
```
核心实现思想：通过DFS递归枚举选择菜品，利用剪枝策略，当总价大于\(n\)或选够\(r\)样菜时，根据组合数公式计算并累加方案数。先对菜品价格从大到小排序，可更快触发剪枝条件，提高效率。

 - **伟大的王夫子**：4星。清晰阐述状态转移方程的推导过程，代码逻辑清晰，注释详细，直接展示了未压缩维度的DP解法。
```cpp
#include <bits/stdc++.h>
using namespace std;
long long f[31][2701][31], m, r, n, a[40], sum;
int main() {
	cin >> m >> r >> n;
	for (register int i = 1; i <= m; ++i) cin >> a[i];
	f[0][0][0] = 1;
	for (register int i = 1; i <= m; ++i) {
		sum += a[i];
		f[i][0][0] = 1;
		for (register int j = 0; j <= sum; ++j) {
			for (register int k = 1; k <= r; ++k) {
				if (j >= a[i]) 
					f[i][j][k] = f[i - 1][j][k] + f[i - 1][j - a[i]][k - 1];
				else f[i][j][k] = f[i - 1][j][k];
			}
				
		}
	}
	long long ans = 0;
	//printf("%d %d %d\n", f[m][12][2], f[m][11][2], f[m][9][2]);
	for (register int i = n + 1; i <= sum; ++i)	ans += f[m][i][r];
	cout << ans;
}
```
核心实现思想：定义三维数组\(f[i][j][k]\)表示前\(i\)个物品，总和为\(j\)，选\(k\)个的方案数。通过三层循环分别枚举物品、总价和所选物品数量，根据当前总价与当前物品价格的关系，依据状态转移方程更新方案数，最后累加满足总价大于\(n\)的方案数。

• **最优关键思路或技巧**：
 - **DP方面**：巧妙借鉴01背包的思路和状态转移方式，合理定义状态并进行状态压缩，优化空间复杂度。
 - **DFS方面**：设计有效的剪枝策略，如剩余菜品不足时及时返回，当前总价超过预算时直接计算剩余组合数，同时对数据排序以更快触发剪枝条件，减少搜索量。

• **拓展**：同类型题多为组合选择类的方案计数问题，类似算法套路为根据题目条件定义合适的状态，推导状态转移方程（DP），或设计有效的剪枝策略进行搜索（DFS）。

• **推荐题目**：
 - [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的01背包问题，可巩固背包问题的基础思路。
 - [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：与本题类似的点菜方案数问题，但无选择数量限制，可对比思路。
 - [P2690 [USACO04NOV]Apple Catching G](https://www.luogu.com.cn/problem/P2690)：同样是基于时间、次数等条件限制下的方案计数问题，可进一步练习状态定义与转移。

• **个人心得摘录与总结**：雪风舞者提到对搜索进行剪枝优化的过程，先是发现裸dfs最多80分，进而思考剪枝策略，如当前总价大于\(n\)时利用组合数性质预处理来更快统计方案数，还提到对数据排序能在方差较大时更快到达临界值，提高效率。总结为在使用DFS解决问题时，要注重剪枝策略的设计与优化，充分利用题目条件和数据特点来减少搜索量。 

---
处理用时：49.73秒
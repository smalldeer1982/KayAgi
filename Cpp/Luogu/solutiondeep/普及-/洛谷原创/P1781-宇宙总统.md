# 题目信息

# 宇宙总统

## 题目描述

地球历公元 6036 年，全宇宙准备竞选一个最贤能的人当总统，共有 $n$ 个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。


## 说明/提示

票数可能会很大，可能会到 $100$ 位数字。

$1 \leq n \leq 20$。

## 样例 #1

### 输入

```
5
98765
12365
87954
1022356
985678
```

### 输出

```
4
1022356```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何比较可能达100位的大票数，找出最大值及其对应的序号。大部分题解利用字符串存储票数，避免高精度运算的复杂性。主要思路包括直接比较、排序后取最值等，关键在于处理字符串比较时先比较长度，长度相同再按字典序比较。

### 所选的题解
1. **作者：callG (赞：413) - 5星**
    - **关键亮点**：思路清晰简洁，直接使用string类型存储票数，通过简单的条件判断比较大小，代码可读性高。
    - **重点代码**：
```cpp
#include <iostream>
#include <cstring>
using namespace std;
int main() {
    int n, id; 
    string max = ""; 
    string in;
    cin >> n;
	for (int i = 1; i <= n; i++) {
        cin >> in;
        int inSize = in.size();
        int maxSize = max.size();
        if (inSize > maxSize || (inSize >= maxSize && in > max)) {
            max = in;
            id = i;
        }
    }
    cout << id << endl << max << endl;
    return 0;
}
```
    - **核心思想**：每次读入一个字符串，先比较其长度与当前最大值的长度，若更长则更新最大值；若长度相同则按字典序比较，字典序大则更新最大值及对应的序号。
2. **作者：right_cat (赞：219) - 5星**
    - **关键亮点**：采用结构体存储票数、号数及票数位数，利用sort函数结合自定义比较函数进行排序，逻辑清晰，代码简洁。
    - **重点代码**：
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
struct node
{
    string x; 
    int num;  
    int lenx; 
}s[25];
bool cmp(node a,node b)
{
    if(a.lenx>b.lenx) return 1; 
    if(a.lenx==b.lenx&&a.x>b.x) return 1; 
    return 0; 
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>s[i].x;
        s[i].num=i; 
        s[i].lenx=s[i].x.size(); 
    }
    sort(s+1,s+n+1,cmp); 
    cout<<s[1].num<<endl;  
    cout<<s[1].x<<endl; 
    return 0;
}
```
    - **核心思想**：定义结构体存储相关信息，cmp函数先比较位数，位数多的排前面；位数相同则按字典序比较，sort函数按此规则排序后，输出首位元素的号数和票数。
3. **作者：zhoulan119 (赞：7) - 4星**
    - **关键亮点**：利用STL的String库直接比较字符串大小，代码简洁明了，体现了对STL特性的熟练运用。
    - **重点代码**：
```cpp
#include <iostream>
#include <string>

using namespace std;

string space;
int n;

int main(){
	cin >> n;
	string max = "0";
	int num = 1;
	for(int i=1;i<=n;i++){
		cin >> space;
		if(space.size()>max.size()||space > max&&space.size()>=max.size()){
			max = space;
			num=i;
		}
	}	
	cout << num << endl << max;
	return 0;
}
```
    - **核心思想**：与callG思路类似，每次读入字符串，通过比较长度和字典序来更新最大值及其序号。

### 最优关键思路或技巧
1. **数据结构选择**：使用string类型存储大票数，利用其自带的比较规则简化代码。
2. **比较策略**：先比较字符串长度，长度长的数值大；长度相同再按字典序比较。

### 可拓展思路
同类型题通常围绕大整数的比较、排序展开。类似算法套路是遇到大整数相关操作，优先考虑字符串模拟，利用字符串的特性来解决问题。

### 相似知识点洛谷题目
1. **P1601 A+B Problem（高精）**：高精度加法，同样涉及大整数处理，需用字符串模拟数字运算。
2. **P2142 高精度减法**：高精度减法运算，进一步巩固字符串模拟大整数的操作。
3. **P1303 A*B Problem**：高精度乘法，也是大整数运算，通过字符串存储数字并实现乘法逻辑。

### 个人心得摘录与总结
1. **作者：zhangyiming**：最初使用strcmp函数未考虑长度问题得0分，后加入strlen判定才AC，强调了字符串比较时需综合考虑长度和字典序。
2. **作者：影のない霜跡**：因数组下标越界得80分，后修改数组大小AC，提醒要仔细处理数据范围。 

---
处理用时：31.34秒
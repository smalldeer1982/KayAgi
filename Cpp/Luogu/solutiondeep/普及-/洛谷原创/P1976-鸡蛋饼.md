# 题目信息

# 鸡蛋饼

## 题目背景

Czyzoiers 都想知道小 x 为什么对鸡蛋饼情有独钟。经过一番逼问，小 x 道出了实情：因为他喜欢圆。


## 题目描述

最近小 x 又发现了一个关于圆的有趣的问题：在圆上有 $2N$ 个不同的点，小 x 想用 N 条线段把这些点连接起来（每个点只能连一条线段）， 使所有的线段都不相交，他想知道这样的连接方案有多少种？


## 样例 #1

### 输入

```
24```

### 输出

```
4057031```

# AI分析结果

• 综合分析与结论：
    - 所有题解都指出本题是卡特兰数问题。卡特兰数常用于解决各类计数问题，本题通过将圆上点连线不相交的方案数与卡特兰数建立联系求解。
    - 思路上，多数题解从卡特兰数的定义、递推关系出发，如通过分析不同点数下的连线情况，得出递推式 \( f(N + 1)=f(0)f(N)+f(1)f(N - 1)+\cdots +f(N)f(0) \) 。有的题解从奇数点和偶数点连线类比括号匹配问题，来解释为何是卡特兰数。
    - 算法要点在于利用卡特兰数的递推式或组合数公式计算结果，并结合取模操作防止数据溢出。不同题解在实现上采用了不同方法求逆元，如扩展欧几里得、快速幂求逆元等，也有直接递推卡特兰数数组并取模的方式。
    - 解决难点主要在于理解卡特兰数与本题实际问题的联系，以及在取模意义下准确计算结果，避免数据溢出和错误的计算逻辑。

    - 整体来看，多数题解思路清晰，但在代码可读性、优化程度上有所差异。

• 所选的题解：
  - 作者：WHUSHZ (5星)
    - 关键亮点：通过详细分析4个点和6个点的特例，逐步引导出一般情况下的递推关系，思路极为清晰。对为何是卡特兰数以及是否需要乘以系数等关键问题进行了深入探讨，解释充分。代码简洁明了，直接利用递推式求解。
    ```cpp
    #include<iostream>  
    #include<cstring>
    using namespace std;  
    int main() {  
        unsigned long long ctl[32768], i, j, k, n;  
        memset(ctl, 0, sizeof(ctl));  
        ctl[0] = ctl[1] = 1;ctl[2] = 2;  
        cin >> n;  
        for (i = 3; i <= n; ++i)  
            for (j = 0; j < i; ++j) {  
                ctl[i] += ctl[j] * ctl[i - j - 1];  
                ctl[i] %= 100000007;  
            }  
        cout << ctl[n];  
        return 0;  
    }
    ```
    核心实现思想：初始化卡特兰数数组 `ctl` 的前几项，通过两层循环利用递推式计算后续卡特兰数，并在计算过程中对结果取模，最后输出第 `n` 项卡特兰数。
  - 作者：Fan_Keyou (4星)
    - 关键亮点：先介绍卡特兰数的基本概念，然后从奇数点和偶数点连线类比括号匹配问题，清晰阐述为何本题是卡特兰数。代码中使用扩展欧几里得求逆元，利用组合数公式 `h(n)=C(2n,n)/(n + 1)` 求解。
    ```cpp
    #include <bits/stdc++.h> 
    using namespace std;

    #define new_while(i, a, b) for(register int i = a; i <= b; ++i)  
    #define ll long long int
    #define mod 100000007   

    ll eeie(ll a, ll c);

    ll list_a[1000010] = {1, 1}, n;

    int main()
    {
        cin>>n;
        new_while(i, 2, n<<1)
            list_a[i] = (list_a[i - 1] * i) % mod;
        printf("%lld\n", (((list_a[n<<1]%mod)*eeie(list_a[n+1],mod-2))%mod*eeie(list_a[n],mod-2))%mod);
        return 0;
    }

    ll eeie(ll a, ll c)
    {
        long long b = 1;
        while (c > 0)
        {
              if(c & 1)   
                b = (b * a) % mod;
              c >>= 1;   
              a = (a * a) % mod;
        }
        return b;
    }
    ```
    核心实现思想：先通过循环计算阶乘数组 `list_a`，利用扩展欧几里得算法 `eeie` 求逆元，最后根据组合数公式计算并输出结果。
  - 作者：NewSjf (4星)
    - 关键亮点：给出了卡特兰数 \( O(N) \) 的递推公式 \( f[i + 1]=(4 * i - 6) * f[i]/i \) ，并结合逆元计算，优化了时间复杂度。代码简洁高效。
    ```cpp
    #include<stdio.h>
    long long f[30000],inv[30000],n,p=100000007;
    int main()
    {
        scanf("%lld",&n);
        f[1]=f[2]=inv[1]=1;
        for(int i=2;i<=n+10;i++)inv[i]=(p-p/i)*inv[p%i]%p;
        for(int i=2;i<=n+3;i++)f[i+1]=((4*i-6)*f[i])%p*inv[i]%p;
        printf("%lld",f[n+2]);
    }
    ```
    核心实现思想：初始化 `f` 和 `inv` 数组，通过循环计算逆元数组 `inv`，再利用递推公式和逆元计算卡特兰数数组 `f`，最后输出结果。

• 最优关键思路或技巧：
    - **思维方式**：通过分析特殊情况（4个点、6个点），总结出一般规律，建立与卡特兰数的联系，这是解决此类问题的重要思维方式。
    - **算法优化**：利用卡特兰数的特定递推公式和逆元计算，如 \( O(N) \) 的递推公式，可有效优化时间复杂度，提高算法效率。
    - **代码实现技巧**：在计算过程中及时进行取模操作，避免数据溢出；合理利用数组存储中间结果，便于后续计算和调用。

• 可拓展之处：
    - 同类型题常涉及到各种计数问题，如进出栈序列计数、二叉树形态计数等，都可以用卡特兰数解决。类似算法套路是先分析问题，找到与卡特兰数的对应关系，再根据卡特兰数的递推式或组合数公式求解，同时注意取模操作。

• 推荐洛谷题目：
    - P1044 栈：经典的卡特兰数应用题目，求栈的出栈序列的方案数。
    - P1722 矩阵II：与本题类似，求在矩阵中从左上角走到右下角且不越过对角线的路径数，也是卡特兰数问题。
    - P2532 [AHOI2012]树屋阶梯：同样是卡特兰数的应用，计算用积木搭建树屋的方案数。

• 个人心得摘录与总结：无。 

---
处理用时：32.74秒
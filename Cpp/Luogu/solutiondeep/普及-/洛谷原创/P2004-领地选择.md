# 题目信息

# 领地选择

## 题目描述

作为在虚拟世界里统帅千军万马的领袖，小 Z 认为天时、地利、人和三者是缺一不可的，所以，谨慎地选择首都的位置对于小 Z 来说是非常重要的。

首都被认为是一个占地 $C\times C$ 的正方形。小 Z 希望你寻找到一个合适的位置，使得首都所占领的位置的土地价值和最高。


## 说明/提示

对于 $60\%$ 的数据，$N,M\le 50$。

对于 $90\%$ 的数据，$N,M\le 300$。

对于 $100\%$ 的数据，$1\le N,M\le 10^3$，$1\le C\le \min(N,M)$。

## 样例 #1

### 输入

```
3 4 2
1 2 3 1
-1 9 0 2
2 0 1 1
```

### 输出

```
1 2
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕在 $n×m$ 的矩形中寻找边长为 $c$ 的正方形，使该正方形土地价值和最大这一问题。思路上分为暴力枚举和利用前缀和优化两种。暴力枚举通过枚举正方形左上角坐标，再暴力计算正方形内价值和，时间复杂度为 $O(nmc^2)$，预计得分50 - 70分。前缀和优化思路是通过预处理得到二维前缀和，从而在 $O(1)$ 时间内计算出任意子矩阵的和，大大降低时间复杂度。

### 所选的题解
1. **作者：GossWandering（5星）**
    - **关键亮点**：思路清晰，先给出暴力解法及复杂度分析，再详细讲解二维前缀和优化思路，包括状态转移方程推导，结合图片说明，非常直观。
    - **个人心得**：先采用暴力解法提交得70分，通过思考暴力解法中重复计算的部分，想到用二维前缀和优化。
    - **核心代码片段**：
```cpp
// 预处理二维前缀和
for(int i=1; i<=m; i++)
    for(int j=1; j<=n; j++)
        f[i][j]=val[i][j]+f[i-1][j]+f[i][j-1]-f[i-1][j-1];
// 枚举左上角，利用二维前缀和更新答案
for(int x1=1; x1<=n-c+1; x1++) 
    for(int y1=1; y1<=m-c+1; y1++){  
        int x2=x1+c-1;
        int y2=y1+c-1;  
        int ans=f[x2][y2]-f[x2][y1-1]-f[x1-1][y2]+f[x1-1][y1-1];
        if(ans>maxx){
            maxx=ans;
            wherex=x1;
            wherey=y1;
        }
    }
```
    - **核心实现思想**：通过状态转移方程 `f[i][j]=val[i][j]+f[i-1][j]+f[i][j-1]-f[i-1][j-1]` 预处理出二维前缀和数组 `f`，之后枚举正方形左上角坐标，利用二维前缀和公式 `f(x2,y2)-f(x2,y1 - 1)-f(x1 - 1,y2)+f(x1 - 1,y1 - 1)` 计算正方形内价值和并更新答案。

2. **作者：睿屿青衫（4星）**
    - **关键亮点**：代码简洁明了，详细指出代码中的易错点，如第二次二重循环从 `c` 开始枚举、`maxx` 初始值要足够小、坐标记录时要注意 `+1` 等，对初学者很有帮助。
    - **个人心得**：自己做时用前缀和思路把自己绕晕，本校神犇帮忙解决问题，从侧面反映出交流学习的重要性。
    - **核心代码片段**：
```cpp
// 预处理二维前缀和
for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
        s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+p[i][j];
// 枚举计算价值和并更新答案
for(int i=c;i<=n;++i)
    for(int j=c;j<=m;++j)
        if(s[i][j]-s[i-c][j]-s[i][j-c]+s[i-c][j-c]>maxx) {
            maxx=s[i][j]+s[i-c][j-c]-s[i-c][j]-s[i][j-c];
            xx=i-c+1;yy=j-c+1;
        }
```
    - **核心实现思想**：与上一题解类似，先通过公式 `s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+p[i][j]` 计算二维前缀和数组 `s`，然后枚举满足条件的正方形右下角坐标，通过公式 `s[i][j]-s[i-c][j]-s[i][j-c]+s[i-c][j-c]` 计算正方形内价值和，更新最大值及对应坐标。

3. **作者：锦瑟，华年（4星）**
    - **关键亮点**：对二维前缀和的预处理和计算部分讲解详细，通过列表的方式解释核心代码原理，帮助读者理解。
    - **核心代码片段**：
```cpp
// 预处理二维前缀和
for(i=1;i<=n;i++){
    for(j=1;j<=m;j++){
        b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j];
    }
}
// 枚举计算价值和并更新答案
for(i=1;i<=n;i++){
    int k=i+c-1;
    if(k>n)break;
    for(j=1;j<=m;j++){
        int h=j+c-1;
        if(h>m)break;
        int sum=b[k][h]+b[i-1][j-1]-b[i-1][h]-b[k][j-1];
        if(sum>ans){
            ans=sum;h1=i;h2=j;
        }
    }
}
```
    - **核心实现思想**：利用 `b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j]` 完成二维前缀和数组 `b` 的预处理，之后枚举正方形左上角坐标，通过公式 `b[k][h]+b[i-1][j-1]-b[i-1][h]-b[k][j-1]` 计算正方形内价值和，更新最大值及对应坐标。

### 最优关键思路或技巧
利用二维前缀和优化是解决本题的关键技巧。通过预处理，将计算子矩阵和的时间复杂度从 $O(c^2)$ 降低到 $O(1)$，从而整体时间复杂度从 $O(nmc^2)$ 优化到 $O(nm)$。具体实现时，通过状态转移方程 `f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+val[i][j]` 计算二维前缀和数组，再利用该数组在 $O(1)$ 时间内计算任意子矩阵的和。

### 可拓展思路
同类型题或类似算法套路：此类题目通常涉及在二维矩阵中进行子矩阵的相关计算，如求子矩阵的最大和、满足特定条件的子矩阵等。一般思路是通过预处理得到前缀和数组，利用前缀和快速计算子矩阵的和。类似算法套路还可应用于三维甚至更高维度的矩阵问题，只是状态转移方程会更复杂。

### 推荐题目
1. **P1387 最大正方形**：给定一个 $01$ 矩阵，求其中最大的全为 $1$ 的正方形子矩阵。需要利用动态规划和前缀和思想解决。
2. **P2331 最大子矩阵（四川省选）**：在给定矩阵中选取 $k$ 个子矩阵，使它们的和最大。考查二维前缀和及动态规划的综合应用。
3. **P1719 最大加权矩形**：在一个带权矩形中找出一个子矩形，使这个子矩形中所有数的和最大。同样需要利用二维前缀和优化暴力枚举的思路。 

---
处理用时：33.24秒
# 题目信息

# 求一次函数解析式

## 题目背景

做数学寒假作业的怨念……


## 题目描述

给定两个整点的坐标，求它们所在直线的函数解析式（一次函数）。


## 说明/提示

$2 x$ 表示为 `2x`。

$\frac{1}{2}x$ 表示为 `1/2*x`。

## 样例 #1

### 输入

```
3 6
2 4
```

### 输出

```
y=2x

```

## 样例 #2

### 输入

```
3 5
2 7```

### 输出

```
y=-2x+11```

## 样例 #3

### 输入

```
3 -1
5 -2```

### 输出

```
y=-1/2*x+1/2```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均是通过给定的两个整点坐标，利用一次函数\(y = kx + b\)的性质，构建二元一次方程组来求解\(k\)和\(b\)的值，进而得到一次函数的解析式。主要难点在于分数的处理，包括约分、正负号判断以及按特定格式输出。

多数题解先通过公式\(k = \frac{y_1 - y_2}{x_1 - x_2}\)，\(b = \frac{x_1y_2 - x_2y_1}{x_1 - x_2}\)计算出\(k\)和\(b\)的分子分母，然后利用最大公约数（GCD）进行约分，并根据分子分母的正负情况处理符号。在输出时，根据\(k\)和\(b\)是否为整数、是否为\(0\)、系数是否为\(\pm1\)等条件进行格式化输出。

### 所选的题解
- **作者：Eason_AC2 (5星)**
    - **关键亮点**：思路清晰，先详细推导二元一次方程组的通解，再将其应用于求一次函数的\(k\)和\(b\)，对分数处理的细节（如约分、符号处理、省略项判断）讲解透彻，代码实现与讲解紧密结合，可读性强。
    - **个人心得**：无
    - **重点代码**：
```cpp
int gcd(int a, int b) {
    return a % b == 0? b : gcd(b, a % b);
}
int main() {
    scanf("%d%d%d%d", &m, &n, &p, &q);
    printf("y=");
    int t1 = n - q, t2 = m - p, t3 = p * n - m * q, t4 = p - m;
    if(t1 % t2) {
        if(gcd(t1, t2)!= 1) {
            int g = gcd(t1, t2);
            t1 /= g;
            t2 /= g;
        }
        if(t2 < 0) t2 = -t2, t1 = -t1;
        printf("%d/%d*x", t1, t2);
    } else if(t1 / t2)
        printf("%dx", t1 / t2);
    if(t3 % t4) {
        if(gcd(t3, t4)!= 1) {
            int g = gcd(t3, t4);
            t3 /= g;
            t4 /= g;
        }
        if(t4 < 0)	t3 = -t3, t4 = -t4;
        if(t3 < 0) 
            printf("%d/%d", t3, t4);
        else
            printf("+%d/%d", t3, t4);
    } else if(t3 / t4 < 0)
        printf("%d", t3 / t4);
    else if(t3 / t4)
        printf("+%d", t3 / t4); 
    return 0;
}
```
    - **核心实现思想**：先通过\(gcd\)函数求最大公约数，对\(k\)和\(b\)的分子分母进行约分，再根据分母正负调整分子符号，最后按格式输出一次函数解析式。
- **作者：DiTeXy (4星)**
    - **关键亮点**：代码简洁明了，直接求解二元一次方程组得到\(k\)和\(b\)，利用\(gcd\)函数约分，对各种输出情况（如\(k\)和\(b\)为整数、分数、正负等）处理得当，逻辑清晰。
    - **个人心得**：无
    - **重点代码**：
```cpp
int gcd(int a, int b)
{
    return b? gcd(b, a % b) : a;
}
int main()
{
    cin>>xx1>>yy1>>xx2>>yy2;
    if(xx1==xx2)
    {
        cout<<"Impossible!!"<<endl;
        return 0;
    }
    k1=yy1 - yy2;
    k2=xx1 - xx2;
    k=gcd(k1, k2);
    k1/=k;
    k2/=k;
    if(k2<0)
    {
        k1=-k1;
        k2=-k2;
    }
    b1=yy2 * xx1 - yy1 * xx2;
    b2=xx1 - xx2;
    b=gcd(b1, b2);
    b1/=b;
    b2/=b;
    if(b2<0)
    {
        b1=-b1;
        b2=-b2;
    }
    cout<<"y=";
    if(k1!=0)
    {
        cout<<k1;
        if(k2!=1)
            cout<<"/"<<k2<<"*x";
        else
            cout<<"x";
        if(b1>0)
        {
            cout<<"+"<<b1;
            if(b2!=1)
                cout<<"/"<<b2;
        }
        else if(b1<0)
        {
            cout<<b1;
            if(b2!=1)
                cout<<"/"<<b2;
        }
    }
    else
    {
        if(b1>0)
        {
            cout<<"+"<<b1;
            if(b2!=1)
                cout<<"/"<<b2;
        }
        else if(b1<0)
        {
            cout<<b1;
            if(b2!=1)
                cout<<"/"<<b2;
        }
    }
    cout<<endl;
    return 0;
}
```
    - **核心实现思想**：先判断特殊情况（两点横坐标相同），然后计算\(k\)和\(b\)的分子分母，通过\(gcd\)函数约分并根据分母正负调整分子符号，最后按格式输出。
- **作者：loi_hjh (4星)**
    - **关键亮点**：采用待定系数法，思路直接，对分数处理有独特方式，通过交换坐标确保分母为正，简化后续处理，代码中注释详细，便于理解。
    - **个人心得**：提到负数转换把自己搞蒙，强调了细节处理的重要性。
    - **重点代码**：
```cpp
in int isflag() {
    if(flag) return k2;
    return k1;
}
int main() {
    scanf("%d%d%d%d", &p, &q, &x, &y);
    printf("y="); 
    if(p < x) {
        swap(p, x);
        swap(q, y); 
    } 
    k1=p - x;
    k2=q - y;
    if(k2<0) {
        k2=-k2;
        flagk2=true;
        putchar('-');
    }
    if(k1>k2) flag=true;
    for(ri i=isflag();i>=2;i--) {
        if((k1%i==0)&&(k2%i==0)) {
            k1/=i;
            k2/=i;
        }
    }
    if(k1==1) {
        printf("%dx", k2);
        if(flagk2) k2=-k2;
        b=q - p * k2;
        if(b>0) putchar('+');
        if(b) printf("%d", b);
    }
    else {
        printf("%d/%d*x", k2, k1);
        if(flagk2) k2=-k2;
        b=q * k1 - p * k2;
        if(b<0) {
            putchar('-');
            b=-b;
        }
        else putchar('+');
        for(ri i=min(k1, b);i>=2;i--) {
            if((k1%i==0)&&(b%i==0)) {
                k1/=i;
                b/=i;
            }
        }
        if(b) printf("%d/%d", b, k1);
    }
    return ~~(0 - 0);
}
```
    - **核心实现思想**：先交换坐标使分母为正，利用自定义函数确定约分的起始值，对\(k\)和\(b\)分别进行约分处理，根据\(k\)是否为整数及\(b\)的正负按格式输出。

### 最优关键思路或技巧
- **利用最大公约数约分**：几乎所有题解都利用求最大公约数的函数对\(k\)和\(b\)的分子分母进行约分，简化分数表达。
- **符号处理技巧**：通过判断分子分母的正负关系，统一处理分数的符号，如当分母为负时，同时改变分子分母的符号。
- **分情况讨论输出**：根据\(k\)和\(b\)是否为整数、是否为\(0\)、系数是否为\(\pm1\)等多种情况，分别进行格式化输出，确保输出符合题目要求。

### 可拓展之处
同类型题可拓展到求过多个点的曲线拟合方程（如二次函数、多项式函数等），类似算法套路是通过构建方程组求解系数，同样会涉及到数值计算和结果格式化输出。在处理复杂函数时，可能需要用到矩阵运算等知识来求解方程组。

### 推荐题目
- **P1082 [NOIP2012 提高组] 同余方程**：考察数论中的同余方程求解，与本题利用数学知识构建方程求解有相似之处。
- **P1071 [NOIP2009 普及组] 潜伏者**：涉及字符加密与解密，可锻炼逻辑思维和条件判断能力，与本题处理各种输出情况的条件判断类似。
- **P1161 开灯**：通过模拟开关灯的过程，考察逻辑推理和简单的数学运算，与本题通过计算和条件判断得出结果的思路类似。

### 个人心得摘录与总结
- **作者loi_hjh**：提到负数转换把自己搞蒙，反映出在处理数值符号时需格外小心，细节处理不当易出错。这提醒在解决类似涉及数值运算和符号处理的问题时，要清晰梳理逻辑，避免因小失大。 

---
处理用时：45.96秒
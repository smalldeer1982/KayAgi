# 题目信息

# Cytus-Holyknight

## 题目背景

本人最初作

以此纪念伟大的ios、安卓、PSV平台音乐游戏《cytus》

后续将不断更新。

-------------Chapter V-1-------------

话说两位战士整天靠在一起好无聊啊，于是她们打算——玩游戏！（？）

她们就用剑画了一个十字架，然后开始抛石子，好好玩啊（？？？）

两个人每人有一个石子，当她们丢完后，正在自学数学的小蓝大叫：把他们连起来不就是一次函数吗！！

于是乎，她们就连了起来，然后她们开始计算。此时她们发现一个严重的问题——没有草稿纸！（这什么破问题= =）

由于脑补能力太低，她们只好让你来帮帮忙啦~


## 题目描述

给出图形（十字架可以视为x轴和y轴），请计算出函数解析式。


## 说明/提示

切记要分类

数据不需判错

100%的数据，3<=n<=16（够水吧）

没学过函数的自己百度


## 样例 #1

### 输入

```
3
010
111
x1x
```

### 输出

```
y=-1.0000```

# AI分析结果

• 综合分析与结论：
    - 这些题解的核心思路都是先确定坐标轴及原点位置，获取两个点的坐标，再根据坐标情况计算并输出一次函数解析式。
    - 算法要点在于准确判断坐标轴和原点，以及正确运用一次函数公式计算参数。
    - 解决难点主要围绕坐标轴的不确定性，如坐标轴可能不完整，需通过各种方式准确判定。
    - 整体来看，各题解思路相近，但在实现细节和代码质量上有差异。

• 所选的题解：
  - 作者：老彩笔 (5星)
    - 关键亮点：详细展示了判断坐标轴位置方法的改进过程，从错误尝试到最终正确实现，逻辑清晰；代码注释详细，对变量用途及关键步骤解释到位。
    - 个人心得：分享了判断坐标轴位置方法不断改进的调试经历，因不同特殊情况导致原判断方法失败，最终通过同时判断左右情况解决。
    - 重点代码核心思想：通过遍历字符数组，利用字符'1'和'0'的组合判断坐标轴位置，找到石子位置并记录，最后根据坐标计算并输出函数解析式。
    - 核心代码片段：
```cpp
if(!c1&&c[i][j]=='1'&&c[i-1][j]=='0')xz=i,c1=1;
if(!c2&&c[i][j]=='1'&&c[i][j-1]=='0')yz=j,c2=1;
if(!c1&&c[i][j]=='0'&&c[i-1][j]=='1')xz=i-1,c1=1;
if(!c2&&c[i][j]=='0'&&c[i][j-1]=='1')yz=j-1,c2=1;
if(c[i][j]=='x'){
    if(!jd1){
        xl=j;
        yl=i;
        jd1=1;
    }
    else{
        xr=j;
        yr=i;
    }
}
xl-=yz;
xr-=yz;
yl=xz-yl;
yr=xz-yr;
if(xl==xr){
    cout<<"x=";
    printf("%.4lf\n",xl);
    return 0;
}
double k,b;
k=(yr-yl)/(xr-xl);
cout<<"y=";
if(k!=0)printf("%.4lfx",k);
else{
    printf("%.4lf\n",yl);
    return 0;
}
b=yl-k*xl;
if(b>0)cout<<'+';
if(b!=0)printf("%.4lf\n",b);
```
  - 作者：Peter_Z (4星)
    - 关键亮点：思路清晰，先明确模拟人计算一次函数的思路，给出公式并说明推导简单；代码结构清晰，通过函数判断原点，各部分功能明确。
    - 个人心得：在评论区指出之前judge函数写错，未考虑石头情况，后进行修改，体现对代码的完善过程。
    - 重点代码核心思想：通过judge函数判断原点，记录石头坐标，调整坐标后根据坐标关系计算并按格式输出一次函数解析式。
    - 核心代码片段：
```cpp
inline bool judge(int x,int y) {
    for(int i=1; i<=n; i++)
        if(pic[i][y]!='1' || pic[x][i]!='1')
            return false;
    return true;
}
int main() {
    int c=0;
    int st[2][2];
    bool f=0;
    cin>>n;
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=n; j++) {
            cin>>pic[i][j];
            if(pic[i][j]=='x') {
                st[c][0]=j,st[c][1]=n-i+1;
                c++;
            }
        }
    }
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=n; j++) {
            if(judge(i,j)) {
                x=j;
                y=n-i+1;
                f=1;
            }
        }
        if(f)    break;
    }
    double x1=st[0][0],y1=st[0][1];
    double x2=st[1][0],y2=st[1][1];
    x1=x1-x,y1=y1-y;
    x2=x2-x,y2=y2-y;
    if(x1==x2) {
        printf("x=%.4f\n",x1);
    } else if(y1==y2) {
        printf("y=%.4f\n",y1);
    } else {
        double k,b;
        k=(y1-y2)/(x1-x2);
        b=y1-x1*k;
        printf("y=");
        if(b<0) {
            printf("%.4fx%.4f\n",k,b);
        } else if(b>0) {
            printf("%.4fx+%.4f\n",k,b);
        } else {
            printf("%.4fx\n",k);
        }
    }
    return 0;
}
```
  - 作者：Blue_wonders (4星)
    - 关键亮点：代码逻辑清晰，通过数组记录各种信息，如横行和纵列中'1'和'x'的个数来确定坐标轴和原点；对输入数据的处理方式独特，从大到小输入并标记特殊点。
    - 重点代码核心思想：输入数据并标记特殊点，通过统计横行和纵列中'1'和'x'的数量确定坐标轴和原点位置，调整点的坐标后计算并输出一次函数解析式。
    - 核心代码片段：
```cpp
for(int i=n;i>=1;i--){
    for(int j=1;j<=n;j++){
        cin>>q;
        if(q=='x'){
            a[i][j]=2;
            if(xx==0){
                xx=j;
                yy=i;
            }
            else{
                xxx=j;
                yyy=i;
            }
        }
        else a[i][j]=q-48;
    }
}
m[0][1]=n+1;m[0][2]=0;
for(int i=1;i<=n;i++){
    linea=lineb=0;
    for(int j=1;j<=n;j++){
        if(a[i][j]==2)lineb++;
        if(a[i][j]==1)linea++;
    }
    if(linea+lineb>m[0][2]||(linea+lineb==m[0][2]&&lineb<m[0][1])){
        m[0][0]=i;
        m[0][1]=lineb;
        m[0][2]=linea+lineb;
    }
}
m[1][1]=n+1;m[1][2]=0;
for(int i=1;i<=n;i++){
    cola=colb=0;
    for(int j=1;j<=n;j++){
        if(a[j][i]==2)colb++;
        if(a[j][i]==1)cola++;
    }
    if(cola+colb>m[1][2]||(cola+colb==m[1][2]&&colb<m[0][1])){
        m[1][0]=i;
        m[1][1]=colb;
        m[1][2]=cola+colb;
    }
}
y=m[0][0];x=m[1][0];
xx-=x;xxx-=x;
yy-=y;yyy-=y;
double k,b;
k=(yyy-yy+0.00)/(xxx-xx+0.00);
b=yy-k*xx+0.00;
if(yy==yyy){
    cout<<"y="<<yy<<".0000";
    return 0;
}
if(xx==xxx){
    cout<<"x="<<xx<<".0000";
    return 0;
}
if(b==0)printf("y=%.4fx",k);
if(b<0)printf("y=%.4fx%.4f",k,b); 
if(b>0)printf("y=%.4fx+%.4f",k,b);
```

• 最优关键思路或技巧：
    - 利用字符间的关系（如'1'和'0'的组合）判断坐标轴位置，可有效应对坐标轴不完整的情况。
    - 通过数组记录各种信息辅助判断坐标轴、原点及点的坐标，使逻辑更清晰。

• 可拓展之处：
同类型题可能会改变图形形状或增加点的数量，类似算法套路是先确定参考系（如坐标轴和原点），再根据给定元素（如点）与参考系的关系进行计算。

• 洛谷题目推荐：
    - P1085 [NOIP2004 普及组] 不高兴的津津
    - P1909 买铅笔
    - P1425 小鱼的游泳时间 

---
处理用时：38.57秒
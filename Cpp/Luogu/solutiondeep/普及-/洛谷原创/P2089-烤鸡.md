# 题目信息

# 烤鸡

## 题目背景

猪猪 Hanke 得到了一只鸡。


## 题目描述

猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 $10$ 种配料（芥末、孜然等），每种配料可以放 $1$ 到 $3$ 克，任意烤鸡的美味程度为所有配料质量之和。

现在， Hanke 想要知道，如果给你一个美味程度 $n$ ，请输出这 $10$ 种配料的所有搭配方案。

## 说明/提示

对于 $100\%$ 的数据，$n \leq 5000$。

## 样例 #1

### 输入

```
11```

### 输出

```
10
1 1 1 1 1 1 1 1 1 2 
1 1 1 1 1 1 1 1 2 1 
1 1 1 1 1 1 1 2 1 1 
1 1 1 1 1 1 2 1 1 1 
1 1 1 1 1 2 1 1 1 1 
1 1 1 1 2 1 1 1 1 1 
1 1 1 2 1 1 1 1 1 1 
1 1 2 1 1 1 1 1 1 1 
1 2 1 1 1 1 1 1 1 1 
2 1 1 1 1 1 1 1 1 1 ```

# AI分析结果

• 综合分析与结论：这些题解主要围绕暴力枚举和深度优先搜索（DFS）两种思路。暴力枚举通过十重循环遍历所有配料组合，虽简单直接但代码冗长。DFS思路以递归方式模拟选择过程，可实现剪枝优化，减少不必要计算。解决难点在于如何存储方案并按要求先输出方案数再输出方案。部分题解在存储方案时采用不同技巧，如字符串拼接、数组存储、队列存储等。整体来看，多数题解思路清晰，但在代码可读性和优化程度上参差不齐。

所选的题解：
 - 作者：万枪先生 (赞：868)  星级：4星
    - 关键亮点：采用递归实现深度优先搜索，代码简洁清晰，巧妙使用数组存储方案，有一定优化意识（在递归中提前判断total是否大于等于n）。
    - 个人心得：无
    - 核心代码：
```cpp
//来个短短的递归~~(估计没人看...)
#include<iostream>
using namespace std;
int n,kind=0,m1[10000][10],m2[10];
void peiliao(int total,int a){
    if (a==10){
        if (total==n) {
            for (int j=0;j<10;j++) m1[kind][j]=m2[j];//符合要求存起来~~ 
            kind++;
        }
    }
    else if (total>=n) ;//小小优化一下 
    else
      for (int i=1;i<=3;i++){
          m2[a]=i;
          peiliao(total+i,a+1);//其实这和十连for没什么区别。。。 
      }
}
int main(){
    cin>>n;
    peiliao(0,0);
    cout<<kind<<endl;
    for (int j=0;j<kind;j++){
      for (int i=0;i<10;i++) cout<<m1[j][i]<<" "; //大家一定要记得打空格... 
     cout<<endl; 
    }
    return 0;
}
```
核心实现思想：通过递归函数peiliao模拟配料选择过程，total记录当前配料总质量，a表示当前处理的配料序号。当处理完10种配料且总质量等于n时，将方案存入数组m1。

 - 作者：氢氧化铯CsOH (赞：337)  星级：4星
    - 关键亮点：详细探讨了多种方案存储和输出的优化技巧，如使用sprintf函数、stringstream、直接计算'\0'位置、printf中的%n控制符等，对每个方法进行了分析和代码展示，最终实现高效输出。
    - 个人心得：无
    - 核心代码（最终版）：
```cpp
#include<cctype>
#include<cstdio>

using namespace std;

const int maxn = 13;

char ans[1000000 + 5];
char *anscur = ans;
int nums[maxn];                    // 当前调料 
int cnt = 0;                    // 方案数 

void printans(){
    int offset;
    for(int i = 0; i < 10; i++){
        sprintf(anscur, "%d %n", nums[i], &offset);
        anscur += offset;
    }
    sprintf(anscur, "\n%n", &offset);
    anscur += offset;
}

void dfs(int cur, int left){    // 深搜过程 
    if(cur == 10 &&!left){        // 已经搜到第10层，这个时候调料恰好加完 
        cnt++;                    // 方案数+1 
        printans();                // 将方案输出到字符串里面 
        return;
    } 
    int &i = nums[cur];            // 声明别名（引用） 
    for(i = 1; i <= 3; i++){
        if((10 - cur - 1) * 3 + i < left) continue;    // 剪枝。如果剩下的调料都加3克都不够，说明不可能 
        if((10 - cur - 1) + i > left) break;        // 剪枝。如果剩下的调料都加一克也超量，说明不可能 
        dfs(cur + 1, left - i); 
    }
}



int main(){
    int n;
    scanf("%d", &n);
    
    if(10 <= n && n <= 30) dfs(0, n);// 如果n不在[10, 30]范围内，说明不可能有解，跳过搜索 
    printf("%d\n%s", cnt, ans);        //输出答案 
}
```
核心实现思想：通过DFS搜索所有可能的配料组合，在搜索到符合条件的方案时，利用sprintf函数和%n控制符将方案高效地存储到字符数组ans中，同时记录方案数。

 - 作者：woshiren (赞：147)  星级：4星
    - 关键亮点：采用回溯算法，代码注释详细，清晰展示了回溯的过程，便于理解。在循环中通过判断m + i > n提前结束循环，实现剪枝优化。
    - 个人心得：无
    - 核心代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,ans1,ans2[10001][11],sum,a[11];
void trys(int t,int m)//t代表当前的尝试的调料。m代表当前美味程度
{
    if (t>10) 
    {
        if (m==n) //如果美味程度与猪猪的要求相等 
        {
            ans1++;//统计方案总数 
            for (int i=1;i<=10;i++)
            ans2[ans1][i]=a[i];//存入答案的数组 
        }
        return ;
    }
    for (int i=1;i<=3;i++)
    {
        if (m+i>n) break;//如果超过了要求，那么后面的就可以直接忽略 
        a[t]=i;//储存答案 
        trys(t+1,m+i);//查看下一种调料 
        a[t]=0;//状态恢复 
    }
}
int main()
{
    cin>>n;
    trys(1,0);//从第一种调料开始尝试，美味程度为0 
    cout<<ans1<<endl;
    for (int i=1;i<=ans1;i++)
    {
        for (int j=1;j<=10;j++)
            cout<<ans2[i][j]<<" ";
        cout<<endl;
    }//输出结果 
    return 0;
} 
```
核心实现思想：通过递归函数trys进行回溯搜索，t表示当前尝试的调料序号，m表示当前美味程度。当t超过10且m等于n时，记录方案。在循环中通过剪枝避免不必要的搜索。

最优的关键思路或技巧：
 - **剪枝优化**：在DFS或回溯过程中，通过提前判断剩余配料即使全选最大值或最小值也无法满足条件，从而减少不必要的搜索分支，提高效率。如`if((10 - cur - 1) * 3 + i < left) continue;`和`if((10 - cur - 1) + i > left) break;`。
 - **方案存储技巧**：利用数组、字符串等数据结构存储方案。如使用二维数组存储所有方案，或使用字符串拼接方案并记录方案数，在输出时直接输出字符串和方案数。

可拓展之处：此类问题属于组合搜索类型，类似套路可应用于背包问题、全排列问题等。在背包问题中，可通过类似搜索和剪枝策略寻找满足条件的物品组合；全排列问题中，可通过递归或回溯生成所有排列。

推荐题目：
 - [P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)：考察组合生成，与本题在组合搜索思路上相似。
 - [P1036 选数](https://www.luogu.com.cn/problem/P1036)：需要通过搜索和剪枝找到满足条件的数的组合，类似本题DFS与剪枝的应用。
 - [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)：经典的回溯算法题目，与本题回溯思路类似，但场景不同，可加深对回溯的理解。

个人心得摘录与总结：无。 

---
处理用时：42.17秒
# 题目信息

# 围栏木桩

## 题目描述

某农场有一个由按编号排列的 $n$ 根木桩构成的首尾不相连的围栏。现要在这个围栏中选取一些木桩，按照原有的编号次序排列之后，这些木桩高度成一个升序序列。所谓的升序序列就是序列中的任何一个数都不小于它之前的任何一个数。试编写程序从这个围栏中选取合适的木桩使得选出的木桩个数 $t$ 最大，并求出选取出 $t$ 根木桩的方案总数 $c$。


## 说明/提示

$m \leq 5$，$n \leq 20$，$h_i \leq 150$。

## 样例 #1

### 输入

```
3
9 10 1 9 8 7 6 3 4 6
3 100 70 102
6 40 37 23 89 91 12```

### 输出

```
4 1
2 2
3 3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕求最长不下降子序列及其方案数展开，思路和方法可归为动态规划（DP）和深度优先搜索（DFS）两类。
 - **动态规划**：通过定义状态和状态转移方程求解。多数题解定义一个数组表示以第i个数结尾的最长不下降子序列长度，同时用另一个数组记录对应长度的方案数。状态转移时，根据当前数与之前数的大小关系更新长度和方案数。
 - **深度优先搜索**：利用数据范围小的特点，对每个位置进行深搜，按最长不下降子序列规则记录个数，更新最大值及对应个数。

各题解在思路清晰度、代码可读性和优化程度上有差异。部分题解代码简洁、注释详细，有的未充分注释或存在代码冗余。整体来看，多数题解能解决问题，但在质量上有提升空间。

### 所选的题解
 - **作者：江屿 (赞：76) - 4星**
    - **关键亮点**：思路清晰，用三个数组分别存储原序列、最长不下降子序列长度及对应方案数，详细解释数组用途和输出格式注意点。
    - **个人心得**：提到输出格式曾是坑点，原需按特定格式输出，现直接按普通格式输出。
    ```cpp
    for(int j=2;j<=m;++j){
        scanf("%d",&a[j]);
        for(int k=j - 1;k>=1;k--)
            if(a[j]>=a[k]){
                if(b[j]<b[k]+1){
                    b[j]=b[k]+1;
                    c[j]=c[k];
                }
                else
                    if(b[j]==b[k]+1)
                        c[j]++;
            }
    }
    int mmax=-1;
    for(int j=1;j<=m;++j){
        if(b[j]==mmax)
            ans+=c[j];
        else{
            if(b[j]>mmax){
                ans=c[j];
                mmax=b[j];
            }
        }
    }
    ```
    核心思想：通过两层循环，内层循环遍历当前数之前的数，若满足不下降条件，更新最长不下降子序列长度及方案数，最后统计最大长度及对应方案总数。
 - **作者：mulberror (赞：20) - 4星**
    - **关键亮点**：先阐述最长上升子序列求解思路，再详细说明方案数转移方法，逻辑连贯，代码注释详细。
    ```cpp
    for1(i,1,n) for1(j,1,i - 1) 
    {
        if ( a[i] < a[j] ) continue;
        int s = f[j] + 1;
        if (s > f[i] )  f[i] = s, g[i] = g[j];
        else if (s == f[i] ) g[i] += g[j];
    }
    int ans1 = 0,ans2 = 0;
    for1(i,1,n) if (ans1 < f[i]) ans1 = f[i], ans2 = g[i];
    ```
    核心思想：通过两层循环，外层遍历每个数，内层遍历当前数之前的数，满足条件时更新最长不下降子序列长度及方案数，最后找出最大长度及对应方案数。
 - **作者：Priori_Incantatem (赞：11) - 4星**
    - **关键亮点**：清晰指出难点在于统计最长不下降子序列数量，详细说明状态定义和转移方程，代码结构清晰。
    ```cpp
    for(int i=2;i<=n;++i)
    {
        f[i]=1;
        for(int j=1;j<i;++j)
        if(a[j]<=a[i])f[i]=max(f[i],f[j]+1);
        ans=max(ans,f[i]);
    }
    for(int i=2;i<=n;++i)
    {
        for(int j=1;j<i;++j)
        if(f[j]+1==f[i] && a[j]<=a[i])c[i]+=c[j];
        if(c[i]==0)c[i]=1;
    }
    for(int i=1;i<=n;++i)
    {
        if(f[i]==ans)cnt+=c[i];
    }
    ```
    核心思想：先通过两层循环求出每个位置的最长不下降子序列长度，再通过类似循环统计对应长度的方案数，最后累加最大长度的方案总数。

### 最优关键思路或技巧
 - **状态定义与转移**：动态规划中，准确合理定义状态及状态转移方程是关键。如定义以第i个数结尾的最长不下降子序列长度和方案数，根据数之间大小关系更新状态，有效解决问题。
 - **利用数据范围**：数据范围小，DFS方法虽时间复杂度高，但实现简单直接，能快速解决问题。

### 可拓展之处
此类题属于序列问题，相似套路是定义合适状态和转移方程。类似题目有最长上升子序列变形，如要求子序列满足特定条件，或统计满足条件的子序列的其他信息。

### 相似知识点洛谷题目
 - [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)：涉及最长不上升子序列及最长上升子序列问题。
 - [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)：与最长子序列相关，考察对动态规划在序列问题中的应用。
 - [P3957 [NOIP2017 普及组] 跳房子](https://www.luogu.com.cn/problem/P3957)：通过动态规划解决在序列上的决策问题，与本题思路有相通之处。

### 个人心得摘录与总结
 - **江屿**：强调输出格式曾是坑点，最初需特定格式输出，后改为普通格式，提示做题要关注输出要求变化。 

---
处理用时：28.65秒
# 题目信息

# zzc 种田

## 题目背景

可能以后 zzc 就去种田了。


## 题目描述

田地是一个巨大的矩形，然而 zzc 每次只能种一个正方形,而每种一个正方形时 zzc 所花的体力值是正方形的周长，种过的田不可以再种，zzc 很懒还要节约体力去泡妹子，想花最少的体力值去种完这块田地，问最小体力值。

## 说明/提示

$1\le x,y\le 10^{16}$。

## 样例 #1

### 输入

```
1 10```

### 输出

```
40```

## 样例 #2

### 输入

```
2 2 ```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何以最小体力值种完矩形田地展开，核心思路是贪心策略，即每次选取当前可种的最大正方形来种，以减少总的正方形数量从而降低体力消耗。算法要点在于不断确定并处理当前矩形中的最大正方形，难点是如何优化以应对较大的数据范围（$1 \le x, y \le 10^{16}$），避免超时或爆空间。部分题解采用递归方式，部分使用循环迭代，且多数题解都意识到需要优化，如通过取模运算一次性处理多个相同边长的正方形，而非逐个处理。

### 所选的题解
1. **作者：北海_Beihai（5星）**
    - **关键亮点**：思路清晰简洁，采用类似GCD的数学迭代方式，代码简洁高效，对算法原理通过代码注释进行了较好的说明。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long x,y,ans=0;
    cin>>x>>y;
    while(x&&y){                         
        swap(x,y);                        
        ans+=4*y*(x/y);              
        x%=y;                             
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：通过循环，每次交换x和y，让x为较大值，y为较小值，然后计算以y为边长的正方形数量（x/y），将这些正方形的周长（4 * y * (x/y)）累加到ans中，再更新x为x % y，重复此过程直到x或y为0。
2. **作者：Zerosking（4星）**
    - **关键亮点**：先用递归实现并详细解释了递归思路，后针对递归爆空间问题进行优化，展示了思考和优化过程，对初学者友好。
    - **个人心得**：分享了递归爆空间（MLE）的调试经历，指出递归调用次数过多导致超空间，通过对特殊数据特点（重复调用）的分析进行优化。
    - **优化后核心代码**：
```cpp
#include<iostream>
using namespace std;
long long sum=0;
void kkk(long long x,long long y)
{
    long long minn,maxn;
    if(x==y)
    {
        sum+=x*4;
        return;
    }
    else
    {
        minn=x<y?x:y;
        maxn=x>y?x:y;
        sum+=minn*4*(maxn/minn);
        if(maxn%minn==0)
            return;
        kkk(minn,maxn%minn);
    }
}
int main()
{
    long long x,y;
    cin>>x>>y;
    kkk(x,y);
    cout<<sum;
}
```
    - **核心实现思想**：递归函数kkk接收矩形的长x和宽y，先判断是否为正方形，若是则累加周长并返回。否则确定长和宽中的较大值maxn和较小值minn，累加以minn为边长的正方形的总周长（minn * 4 * (maxn/minn)），若maxn是minn的整数倍则结束，否则递归处理剩余矩形（minn, maxn % minn）。
3. **作者：人间凡人（4星）**
    - **关键亮点**：先阐述了朴素贪心思路及模拟过程，指出朴素做法会超时的问题并给出优化方案，思路连贯，代码实现清晰。
    - **个人心得**：无
    - **优化后核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,y,z,ans;
int main() {
    cin>>x>>y;
    while(x!=0&&y!=0){
        z=min(x,y);
        if(x==z)ans+=4*(y/z)*z,y%=z;
        else if(y==z)ans+=4*(x/z)*z,x%=z;
    }
    printf("%lld\n",ans);
    return 0;
}
```
    - **核心实现思想**：通过循环，每次找到x和y中的较小值z，根据x和y谁等于z，计算并累加以z为边长的正方形的总周长（4 * (较大值/z) * z），同时更新较大值为其对z取模的结果，直到x或y为0。

### 最优关键思路或技巧
1. **贪心策略**：每次选取当前矩形中最大的正方形进行种植，确保总的正方形数量最少，从而使体力消耗最小。
2. **优化技巧**：利用取模运算（%）和整除运算（/），一次性处理多个相同边长的正方形，避免逐个处理导致的时间复杂度过高。例如，通过`x/y`计算以y为边长的正方形个数，直接累加其周长，再通过`x %= y`更新剩余矩形的边长。

### 同类型题或类似算法套路拓展
此类题目属于贪心策略结合数学运算优化的类型，常见于几何图形分割、资源分配等场景。类似算法套路是在满足题目条件下，每次选择局部最优解（如本题每次选最大正方形），并通过数学方法优化计算过程，避免暴力枚举导致的性能问题。

### 洛谷相似题目推荐
1. **P1094 [NOIP2007 普及组] 纪念品分组**：同样考察贪心策略，需要根据给定条件对物品进行分组以满足特定要求。
2. **P1199 [NOIP2010 普及组] 三国游戏**：涉及贪心思想和策略选择，通过合理选择武将组合来获取最优结果。
3. **P1223 排队接水**：利用贪心算法，根据接水时间对队列进行排序，以求得总等待时间最短。 

---
处理用时：26.42秒
# 题目信息

# 夏幻的考试

## 题目背景

夏之幻是软件工程系的大神，学校把举办考试的任务交给她了。


## 题目描述

某大学软工专业要举办一场笔试，学生们要在机读答题卡上填写答案来进行答题。学校把机读卡识别任务交给了夏之幻，但是这套系统的需求太复杂了，她还要做自己的其他项(you)目(xi)，所以她想让你来帮忙实现一部分功能。

试卷分卷头，单选题两部分。

夏幻大神已经写好了识别程序，因此卷头和答案将直接以数字信息的形式呈现给你，你要实现下面几个功能:

需要处理T张试卷，按顺序检查下列选项。

1.检查考号的填写是否准确。

输入信息的格式:

一行，一个16位无符号二进制数id。表示考生的考号为id，正确的考号范围在十进制下是1~10000。

如果考号有错误，输出一行“Wrong ID”并结束对这张试卷的处理(剩下两个选项的数据依然要读入，但不输出任何内容)，不含引号。如果考号正确，输出一行,“ID: ”+一个整数，表示考号的十进制形式。不含引号。

无需考虑考号是否重复，只要在范围内均为正确。

2.检查试卷类型是否正确。

输入信息格式:

一行，两个整数，中间无分隔，只能是0或者1。第一个整数表示试卷类型A是否被涂黑(0表示未涂黑，1表示涂黑)，第二个整数表示试卷类型B是否涂黑。其实试卷类型可以由二进制考号的最后一位得到，0表示A卷，1表示B卷，你只需要检查考生填涂的是否正确。

如果考生将试卷类型正确填涂(填涂且只填涂了正确的那一项)，输出一行“Type Correct”，否则输出一行“Type Incorrect”，不含引号。无论试卷类型是否填涂正确，你还需要接着处理这张试卷。

3.给单选题打分。

单选题的数量n和标准答案将会在录入第一张试卷前给出。

考生答案的输入格式:

n行，每行4个整数，中间无分隔。每个整数是0或1。

按顺序分别代表A,B,C,D是否被涂黑(0表示未涂黑，1表示涂黑)。考生回答正确当且仅当该题正确答案的位置被涂黑，且错误答案的位置未被涂黑。

输出一行，一个四舍五入到小数点后1位的浮点数，表示考生的得分，满分为100分，每个题的分数相同。


## 说明/提示

对于100%的数据

1<=T<=1000

1<=n<=50

注意:

1.请在最后一个试卷处理完后也加上一个换行

2.由于win系统和linux系统换行的不同，建议不要使用scanf读入char


## 样例 #1

### 输入

```
2 5
ABCAD
0000000011111111
01
1000
0010
0100
1000
0010
1001001001001001
01
0001
1010
0111
1111
0000```

### 输出

```
ID: 255
Type Correct
40.0

Wrong ID```

## 样例 #2

### 输入

```
3 3
ABC
0000000000000000
01
1111
0001
0100
0000000000000010
10
1000
0100
0010
0000000000000011
11
0001
0000
0010
```

### 输出

```
Wrong ID

ID: 2
Type Correct
100.0

ID: 3
Type Incorrect
33.3
```

## 样例 #3

### 输入

```
5 31
ACAACCDDBBDADDCBCACCDBCAACAAAAC
0000101111000001
10
1000
0010
1000
1111
0010
0010
0001
0001
0100
0100
0001
1000
0001
0001
0010
1111
0010
1000
0010
0010
0001
0100
1111
1000
1000
0010
1000
0100
1000
1000
0010
0000010101001111
10
1000
0010
1000
1000
0010
0010
0001
0001
0100
0100
0001
1000
0001
0001
0010
0100
1000
1000
0000
0010
0001
0100
0010
1000
1000
0010
1000
1000
0000
0000
0010
0001110001100110
11
1000
0010
1000
1000
0010
0010
0001
0001
0100
0100
0001
1000
0010
0100
0010
0100
0010
0100
0010
0010
0001
0100
0010
1000
1000
0010
1000
1111
1000
1000
0010
0001001111110001
10
1010
0010
1000
1000
0010
0010
0001
0001
0100
0100
0010
1000
0001
0001
0010
0100
0010
1000
0010
0010
0001
0100
0010
1000
1000
0010
1000
1000
1000
1000
0010
0001110010000100
10
1000
0010
1000
1000
0000
0010
0001
0001
0100
0100
0001
1000
0001
0001
0001
0100
0010
1000
0010
0010
0001
0100
0010
1000
1000
0010
1000
1000
0000
1000
0001
```

### 输出

```
ID: 3009
Type Incorrect
87.1

ID: 1359
Type Incorrect
87.1

ID: 7270
Type Incorrect
87.1

ID: 5105
Type Incorrect
93.5

ID: 7300
Type Correct
87.1
```

# AI分析结果

• 综合分析与结论：这些题解均围绕“夏幻的考试”这一模拟题展开，思路上都是按照题目要求，依次处理考号判断、试卷类型判断和单选题打分这三个任务。算法要点在于二进制转十进制的考号转换、试卷类型的匹配判断以及答案与标准答案的比对计分。难点主要集中在输入输出格式的处理，特别是Windows和Linux系统换行符差异，以及数据读入和处理的准确性。各题解在实现方式上略有不同，有的采用函数分块处理增强代码可读性，有的使用结构体或类来组织数据，还有的通过打表等方式优化计算。

所选的题解：
 - 作者：SLYZ_0120 (5星)
   - 关键亮点：采用函数分块处理，将题目要求的三个任务分别封装在不同函数中，使代码逻辑清晰，可读性强。对每个步骤的实现思路讲解详细，包括二进制转十进制的具体过程、试卷类型判断的依据以及答案处理和计分方式。同时，分享了因Windows和Linux系统差异导致的调试问题及解决方法。
   - 个人心得：“本题最最最大的坑点不是算法，而是windows和linux的一些符号（比如换行符，scanf读入格式之类）的不兼容，我在本地成功的过了炒鸡多的样例，下载的数据也完美的通过，但是依旧不停的WA~~（爆0）~~。最后我把**所有的cout << endl全部都换成了\n，同时将所有的scanf全部都换成了cin，去掉了所有的gets**，我终于成功了……” 总结了因系统差异导致的输入输出格式问题及解决办法。
   - 核心代码（判断考号函数）：
```cpp
void typ(){
    id = 0;//初始化id！这个超重要的
    for(int i = 1;i<=16;i++){
        cin >> c;
        if(c-'0' == 1) id += pow(2,16-i);
    }
    if(id >= 1&&id<=10000) printf("ID: %d\n",id);
    else {
        printf("Wrong ID\n");
        flg = false;//如果这个考号不合法，标记一下
    }
    return;
}
```
核心实现思想：通过循环读入16位二进制考号字符，每读入一位，若为'1'则累加到id中，累加值为2的相应幂次，最后判断id是否在合法范围内并输出结果。

 - 作者：HoshinoTented (4星)
   - 关键亮点：使用面向对象的方法，将考生信息、单选答案等抽象为类，提高了代码的维护性和扩展性。对每个类的设计和相关函数的实现都有清晰的逻辑，例如在Id类中通过构造函数完成二进制考号到十进制的转换及试卷类型的确定，在SingleAnswer类中实现了答案的初始化和比较功能。
   - 核心代码（Id类）：
```cpp
class Id {
public:
    enum TestType {
        A, B, WRONG
    };

    explicit Id(const std::string &id) {
        std::stringstream stream(id);
        const char *charArr = id.c_str();
        self.id = static_cast<int>(std::strtol(charArr, (char **) (charArr + id.size()), 2));
        self.testType = *(--id.cend()) - '0'? B : A;
    }

    explicit Id(const int &id, const TestType &type) : id(id), testType(type) {}

    inline auto getId() -> int { return id; }

    inline auto getType() -> TestType { return testType; };

private:
    int id;
    TestType testType;

};
```
核心实现思想：通过构造函数将传入的二进制考号字符串转换为十进制id，并根据考号最后一位确定试卷类型。提供getId和getType方法用于获取考号和试卷类型。

 - 作者：反比例函数 (4星)
   - 关键亮点：通过打表的方式优化了二进制转十进制的计算过程，避免每次调用pow函数带来的时间消耗，提高了代码效率。代码整体简洁明了，对每个步骤的实现逻辑清晰，注释详细。
   - 核心代码（二进制转十进制函数）：
```cpp
const int pow2x[16]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768};
int bin_to_dec(string b)//二进制转十进制
{   int len=b.size(),d=0;
    for(int i=len-1;i>=0;i--)
      d+=(b[i]-'0')*pow2x[len-i-1];//b[i]-'0'为这一位上的数字
    return d;}
```
核心实现思想：利用预先定义好的2的幂次数组pow2x，通过循环将二进制字符串的每一位乘以对应的幂次并累加，从而得到十进制数。

最优关键思路或技巧：
 - **模块化设计**：如SLYZ_0120将不同功能封装成函数，使代码结构清晰，易于理解和调试。
 - **面向对象编程**：HoshinoTented通过类来组织数据和操作，提高代码的维护性和扩展性，适合复杂逻辑的处理。
 - **打表优化**：反比例函数通过打表避免重复计算，提高二进制转十进制的效率，在时间复杂度要求较高的场景下是有效的优化手段。

可拓展之处：此类模拟题通常围绕特定业务逻辑展开，可拓展到其他实际场景的模拟，如比赛计分系统、选课系统等。类似算法套路是将复杂任务分解为多个子任务，分别实现并整合。

推荐题目：
 - P1009 [NOIP1998 普及组] 阶乘之和
 - P1046 [NOIP2005 普及组] 陶陶摘苹果
 - P1085 [NOIP2005 普及组] 不高兴的津津 

---
处理用时：31.59秒
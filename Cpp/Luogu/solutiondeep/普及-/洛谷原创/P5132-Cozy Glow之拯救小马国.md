# 题目信息

# Cozy Glow之拯救小马国

## 题目背景

本题难度普及-，请noip两个组别的选手都把它AC（~~不然你noip省三都保不住了~~）

ps：三年OI一场空，day1T1见祖宗。。。

## 题目描述

Cozy Glow偷偷摸摸的造了一个魔法阵，这个魔法阵在吸取小马国的魔力，所以你得赶紧把它毁掉。

这个魔法阵由若干个神器组成，每个神器都有一个法力值，每两个神器之间也都有一个关联值。你要依次把这些神器拿走，但是，每拿走一个神器，你就会受到一定量的反噬，反噬的量为这个神器与其他还在神器的关联值乘以这个神器的法力值，为了减少反噬，tb148需要拿走每个神器，但由于他贪生怕死，他想让他受到的反噬值之和最小，现在tb148想知道，怎样拿走神器，才能让反噬值的和最小。

## 说明/提示

神器个数<=1000

所有其他的值<=2000000

正对角线上的数保证都是零。。。

## 样例 #1

### 输入

```
4
2 5 1 7
0 343 154 12
343 0 214 132
154 214 0 441
12 132 441 0```

### 输出

```
2179```

# AI分析结果

### 综合分析与结论
这些题解思路基本一致，都认识到对于每个关联值，乘上其连接的两个神器中法力值较小的那个，累加起来就是最小反噬值。因为神器最终都要拿走，这样能保证每对神器间关联值与较小法力值相乘，实现整体反噬值最小。同时，由于采用邻接矩阵输入关联值会重复，都通过 `if(i > j)` 避免重复计算。

算法要点在于输入法力值和关联值，利用上述思路计算累加和。难点主要是理解为何这样计算能得到最小反噬值，部分题解通过不同方式进行解释，如从逆向思维取消关联线角度，或从插入法器保持最优排列角度。

### 题解评分
1. **beargeng是女孩子**：思路表述较简略，代码可读性一般，未对关键思路详细解释，给3星。
2. **Last_hope**：清晰阐述题意和思路，代码有加速cin、cout黑科技且结构清晰，给4星。
3. **盖矣斌峥**：思路解释清晰，代码简洁明了，对避免重复计算有说明，给4星。
4. **AmadeusSG**：对思路关键步骤有解释，如相同拿法反噬值相等、避免重复计算原因，代码规范，给4星。
5. **No_Rest**：从逆向思维解释思路较新颖，代码简洁，给4星。
6. **Lonely_NewYear**：详细分析思路正确性和可行性，提及数据相关注意点，给4星。
7. **Kiloio**：结合样例解释思路和避免重复计算，代码清晰，给4星。
8. **yf最qhhh**：思路表述简单，代码有一定简洁性，给3星。
9. **EAlivn**：思路阐述清晰，代码规范，给4星。
10. **_FJX_**：思路和注意点说明清晰，代码规范，给4星。
11. **Lysea**：思路和避免重复计算解释清晰，代码规范，给4星。
12. **XL4453**：给出结论并尝试证明，代码规范，给4星。
13. **lu_run_ting**：思路清晰，分析了题目特点和易错点，代码规范，给4星。

### 所选4星及以上题解
1. **Last_hope**
    - **星级**：4星
    - **关键亮点**：清晰阐述题意和思路，使用加速cin、cout黑科技提升效率，代码结构清晰。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, a[1005], v, ans;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for(int i = 1; i <= n; i++)
        cin >> a[i];
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
        {
            cin >> v;
            if(i > j)
                ans += v * min(a[i], a[j]);
        }
    cout << ans;
    return 0;
}
```
    - **核心实现思想**：先输入神器法力值，再通过邻接矩阵输入关联值，在输入时判断 `i > j` 避免重复计算，将关联值与较小法力值相乘累加到 `ans`。
2. **Lonely_NewYear**
    - **星级**：4星
    - **关键亮点**：详细分析思路正确性和可行性，指出以神器法力值排序取神器可保证正确性，还提及数据相关注意点。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long a[1001];
int main()
{
    int n,x;
    scanf("%d",&n);
    long long ans=0;
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            scanf("%d",&x);
            if(i>j)ans+=x*min(a[i],a[j]);
        }
    printf("%lld",ans);
    return 0;
}
```
    - **核心实现思想**：与其他题解类似，输入法力值和关联值，通过 `if(i > j)` 避免重复计算，关联值乘较小法力值累加。
3. **XL4453**
    - **星级**：4星
    - **关键亮点**：不仅给出结论，还对结论进行了不太严谨但有一定启发的证明，从插入法器保持最优排列角度解释思路。
    - **核心代码**：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
long long n,a[1005],x;
long long ans;
int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            scanf("%lld",&x);
            if(i>j)
                ans+=min(a[j],a[i])*x;
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```
    - **核心实现思想**：输入神器法力值和关联值，利用 `if(i > j)` 避免重复，将关联值与较小法力值乘积累加到 `ans`。

### 最优关键思路或技巧
1. **思维方式**：从关联值角度出发，认识到每个关联值必然要与相连的两个神器之一的法力值相乘，为使总和最小，选择较小法力值相乘。
2. **代码实现技巧**：采用邻接矩阵输入关联值时，通过 `if(i > j)` 避免重复计算，节省计算资源。

### 可拓展之处
同类型题常出现在贪心策略应用场景，如给定多个元素及元素间关系，通过某种选择顺序使结果最优。类似算法套路是分析元素间相互关系，找到能使整体最优的局部最优策略，并证明其正确性。

### 洛谷相似题目推荐
1. **P1080 国王游戏**：涉及贪心策略，通过分析元素间关系找到最优排列顺序。
2. **P1248 加工生产调度**：同样需根据给定条件，运用贪心思想确定加工顺序使总时间最短。
3. **P1937 [USACO10MAR]Barn Allocation G**：关于区间分配问题，利用贪心策略解决资源分配以达到最优结果。

### 个人心得摘录与总结
1. **lu_run_ting**：提到不开 `long long` 过不了，快读开了反而也过不了。总结为注意数据范围要开 `long long`，同时有些题目快读可能因数据特性不适用。 

---
处理用时：32.40秒
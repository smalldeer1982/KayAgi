# 题目信息

# 【CSGRound2】守序者的尊严

## 题目背景

由于 Y 校最近进行了对学校食堂的全面改革与对小卖部的全面整治(乱搞)，导致学校小卖部卖的零食被禁售了；学校食堂的炸鸡窗口也消失了；

并且学校的学生处 Q 主任严禁学生点外卖，日夜监察。

都说民以食为天，由于整天挨饿，全校同学处于水深火热之中。

## 题目描述

zhouwc 的朋友（朋友就是自己系列）小 Z 由于饥饿难忍，不得不铤而走险点外卖。

但是学校的 Q 主任为了能够抓住点外卖的学生布置了天罗地网——监控。

但是由于学校给 Q 主任的经费有限，所以这些监控不能持续工作，工作一秒之后便要暂停休息一秒，**即开启一秒后关闭一秒再开启一秒...以此类推**。

还是由于 Q 主任的经费有限，这些监控被排成了一条直线，这条直线便在学生通往学生外卖驻点——二号门（没有门卫）的必经之路上。

因为小 Z 修习了疾跑技能，所以小 Z 通过任意个数关闭的监控的时间均为 
 $1$（即一次行动可以经过若干个未开的监控）。

由于小 Z 想吃外卖又不想受到正在监控室看着监控的 Q 主任的处分，请你告诉他至少要多少时间才能安全到达外卖驻点。

## 说明/提示

#### 数据范围：

对于 $10\%$ 的数据，$1 \leq n \leq 10$

对于 $30\%$ 的数据，$1 \leq n \leq 100$

对于 $50\%$ 的数据，$1 \leq n \leq 10^3$

对于 $70\%$ 的数据，$1 \leq n \leq 10^5$

对于$100\%$的数据，$1 \leq n \leq 10^6$

监控的开关情况均用 $0$ 和 $1$ 来表示。

#### 样例解释一：

小 Z 在第一秒时冲到第二个监控处，用时 $1$ 秒，总用时 $1$ 秒。

第二秒时，监控的开关状况变为了 $1 1 0 0 1 0$。

这时，小 Z 迅速从二号监控处冲到了四号监控处，用时 $1$ 秒，总用时 $2$ 秒。

第三秒时，监控的开关状况变为了 $0 0 1 1 0 1$。

这时，小 Z 迅速从四号监控处冲到了五号监控处，用时 $1$ 秒，总用时 $3$ 秒。

第三秒时，监控的开关状况变为了 $1 1 0 0 1 0$。

这时，小 Z 迅速从五号监控处冲出了监控区域，用时 $1$ 秒，总用时 $4$ 秒。

#### 样例解释二

小Z在第一秒直接冲出了监控区域。

## 样例 #1

### 输入

```
6
0 0 1 1 0 1```

### 输出

```
4```

## 样例 #2

### 输入

```
6
0 0 0 0 0 0```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算小Z通过监控区域所需的最短时间展开。核心思路是将问题转化为统计输入的监控状态序列中连续相同状态（0或1）的段数，再加1得到结果。

算法要点在于遍历监控状态序列，比较相邻元素，若不同则表明进入新的连续段，计数增加。难点在于理解监控的开关规律及如何优化模拟过程，避免$O(n^2)$的时间复杂度。多数题解都能抓住核心要点，通过简单的循环遍历和条件判断实现。

### 所选的题解
- **作者：zhouwc（官方题解） 星级：5星**
    - **关键亮点**：思路清晰，先给出50分的暴力解法，再点明100分的优化思路，即直接判断初始监控开关状况，通过统计连续0或1的段数得出结果，时间复杂度$O(n)$。代码简洁明了，直接体现核心思路。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005],n;
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    int ans=1;
    for (int i=2;i<=n;i++)
        if (a[i]!=a[i-1]) ans++;
    printf("%d\n",ans);
}
```
    - **核心思想**：读入监控状态数组，初始化结果为1，遍历数组，若当前元素与前一个元素不同，则结果加1，最后输出结果。
- **作者：十四日的夏 星级：4星**
    - **关键亮点**：提到运用贪心思想，明确指出只要判断01转换次数再加1即可。代码结构清晰，使用了常见的输入输出方式及循环结构。
    - **重点代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<ctime>
#include<cmath>
#include<algorithm>
#define ll long long int
#define For(i,l,r) for(int i=l;i<=r;i++)
using namespace std;
int sum,pre,n;
int x[1000001];
int main()
{
	cin>>n;
	pre=0;
	For(i,1,n)
	{
		scanf("%d",&x[i]);
	}
	pre=0;
	For(i,0,n-1)
	{
		if(x[i+1]!=pre)
		{
			sum++;
			pre=x[i+1];
		}
	}
	cout<<sum+1;
	return 0;
}
```
    - **核心思想**：读入监控数量和状态数组，通过循环遍历数组，比较当前元素与前一个元素，若不同则增加计数，最后输出计数加1的结果。
- **作者：Phoenix_lily 星级：4星**
    - **关键亮点**：详细解释了将题目转化为求连续0或1串数的思路，对状态判断和计数的逻辑阐述清晰。代码实现简洁，变量命名有一定意义。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
bool kkk,last=1;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>kkk;
		if(kkk!=last)
		ans++;
		last=kkk;
	}
	cout<<ans;
	return 0;
 } 
```
    - **核心思想**：读入监控数量，在循环中读入每个监控状态，比较当前状态与上一个状态，不同则增加答案计数，最后输出答案。

### 最优关键思路或技巧
最优思路是通过观察监控开关规律，发现小Z每次能通过一段连续相同状态的监控，从而将问题转化为统计序列中连续相同状态的段数。在代码实现上，利用简单的循环遍历和相邻元素比较来计数，避免复杂的模拟过程，优化时间复杂度至$O(n)$。

### 可拓展之处
同类型题常涉及根据特定规则对序列进行处理和统计的问题。类似算法套路包括观察题目规则，简化问题模型，将复杂的动态过程转化为静态的序列统计。例如在一些涉及状态变化且具有周期性的问题中，可通过分析周期特性，简化模拟过程，直接得出结果。

### 相似知识点题目推荐
- **P1036 [NOIP2002 普及组] 选数**：涉及对数字序列的处理和统计，通过枚举组合判断是否满足条件，与本题统计序列特征的思路类似。
- **P1161 开灯**：根据特定规则对灯的开关状态进行操作并统计最终状态，需要分析操作规律，与本题分析监控开关规律有相似之处。
- **P1909 买铅笔**：通过比较不同购买方案的花费来选择最优解，同样是对序列（不同方案）进行处理和统计，找到符合要求的结果。 

---
处理用时：26.89秒
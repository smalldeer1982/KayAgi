# 题目信息

# 天选之人

## 题目背景

暑假期间，学校不提供午餐，Gnar 只好找伙计们一起点外卖。

尴尬的是，外卖很快送到却没人乐意去校门口拿，毕竟户外可是 $35\degree\!\text{C}$ 高温！此时 Gnar 想到了好主意：“我给一人捏了一张纸团，其中一张写有记号，不如我们抓阄决定，谁抽到带记号的谁去拿！”

于是 Gnar 连续拿了六天的外卖。

这可让他不服又委屈：“换个规则！一人准备三张纸团，五张有记号，每人抽三张，记号最多的去拿！”

Gnar 紧张地展开手中的纸团，两个记号赫然映在眼前。大伙们刚想放声大笑他的非酋运气，有人缓缓举起三张纸片说道：“我也抽到了两个记号……”

## 题目描述

好奇的 Gnar 想研究一般情况下抽到最多记号的人数。他给参与抓阄的 $n$ 人一人准备了 $m$ 张捏好的纸团，一共 $nm$ 张，其中恰好 $k$ 张提前写了记号。随后每个人在均匀打乱的纸团中各抽 $m$ 张。

一个人抽到最多的记号，当且仅当没有人抽到的记号比他还多。请你帮 Gnar 判断是否可能会**恰好** $\boldsymbol{p}$ **个人**抽到最多的记号。Gnar 喜欢追根问底，所以如果有可能，你还需构造每个人抽的纸团中分别有多少带记号、有多少不带记号。

形式化地，假设第 $i$ 个人抽到了 $x_i$ 张带记号的纸团和 $y_i$ 张不带记号的纸团，你的构造应满足：

- $x_i, y_i \ge 0$，$x_i + y_i = m$。
- $\displaystyle \sum_{i = 1}^{n} x_i = k$。
- **有且仅有** $\boldsymbol{p}$ **个互不相同**的 $j$ 使 $\displaystyle x_j = \max_{i = 1}^{n} \{x_i\}$。

## 说明/提示


**【样例解释 #1】**

样例给出了一种满足题述条件的构造。

**【样例解释 #2】**

不论如何，记号的分布从高到低只有三种情况：$\{3,0,0\}$，$\{2,1,0\}$，$\{1,1,1\}$，抽到最多记号的人数分别对应 $1$，$1$，$3$。因此无法构造 $p = 2$ 的方案。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (15 points)：$n,m \le 8$。
- Subtask #2 (15 points)：$n,m \le 100$。
- Subtask #3 (20 points)：$n,m \le 10^5$。
- Subtask #4 (10 points)：$p = 1$。
- Subtask #5 (40 points)：无特殊限制。

对于所有的数据，保证 $1 \le p \le n \le {10}^5$，$1 \le m \le {10}^9$，$0 \le k \le n m$。

## 样例 #1

### 输入

```
3 3 5 2```

### 输出

```
YES
2 1
2 1
1 2```

## 样例 #2

### 输入

```
3 3 3 2```

### 输出

```
NO```

## 样例 #3

### 输入

```
3 3 5 3```

### 输出

```
NO```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先确定可能的最大记号数，再据此分配剩余记号，判断能否满足恰好\(p\)个人抽到最多记号的条件。算法要点在于合理计算最大记号数以及剩余记号的分配方式。解决难点主要在于考虑各种边界情况和无解情况。

### 所选的题解
- **作者：Unordered_OIer（5星）**
    - **关键亮点**：思路清晰，先确定最大值\(q = \min(m, k / p)\)，再分情况分配剩余记号，复杂度为\(\mathcal{O}(n)\)，代码简洁且有详细注释。
    - **个人心得**：无
    - **核心代码**：
```cpp
ll n=read(),m=read(),k=read(),p=read();
ll q=min(m,k/p);
if(k-q*p>(n-p)*(q-1))return puts("NO"),0;
for(ll i=1;i<=p;i++)x[i]=q,y[i]=m-q;
bool ff=1;
ll rs=k-q*p;
for(ll i=p+1;i<=n;i++){
    if(ff==true&&rs>=q-1)x[i]=q-1,rs-=q-1;
    else if(rs==0)x[i]=0;
    else x[i]=rs,rs=0,ff=0;
    y[i]=m-x[i];
}
puts("YES");
for(ll i=1;i<=n;i++)write(x[i]),putchar(' '),write_endl(y[i]);
```
    - **核心实现思想**：先计算可能的最大记号数\(q\)，判断是否无解。若有解，先给前\(p\)个人分配\(q\)个记号，再依次给剩下的人分配\(q - 1\)个记号或剩余记号，最后输出结果。
- **作者：HanPi（4星）**
    - **关键亮点**：通过形象的图示辅助理解，分情况讨论，包括\(n = p\)的特殊情况，逻辑较清晰。
    - **个人心得**：无
    - **核心代码**：
```c
#include <stdio.h>
long long n,m,k,p;
long long other,s,a,hp,h,mod,each;
long long other2;
int i;
long long mymin(long long vala,long long valb){return vala<valb?vala:valb;}
int main()
{
    scanf("%lld%lld%lld%lld",&n,&m,&k,&p);
    other=n-p;
    if(!other)
    {
        if(k%p!=0)
        {
            puts("NO");
            return 0;
        }
        puts("YES");
        a=k/p;
        for(i=0;i<n;++i)printf("%lld %lld\n",a,m-a);
        return 0;
    }
    hp=mymin(k/p,m);
    s=hp*p;
    a=k-s;
    h=a/other;
    mod=a%other;
    if(mod)each=(mod+other)/other;
    other2=other-mod;
    if(hp<=h||hp<=h+each)
    {
        puts("NO");
        return 0;
    }
    puts("YES");
    for(i=0;i<p;++i)printf("%lld %lld\n",hp,m-hp);
    for(i=0;i<mod;++i)printf("%lld %lld\n",h+each,m-h-each);
    for(i=0;i<other2;++i)printf("%lld %lld\n",h,m-h);
    return 0;
}
```
    - **核心实现思想**：先计算分给\(p\)个人的最大记号数\(hp\)，再计算剩余记号平均分配给其余人的数量\(h\)和余数\(mod\)，根据条件判断是否有解，有解则按不同情况输出结果。
- **作者：Meaninglessness（4星）**
    - **关键亮点**：代码简洁，通过函数`check`判断是否有解，逻辑清晰，考虑了\(n = p\)的特殊情况。
    - **个人心得**：无
    - **核心代码**：
```cpp
bool check()
{
    long long more=min(m,k/p),another=k-more*p;
    if(n==p)
    {
        if(another!=0)
            return false;
        else
        {
            for(int i=1;i<=n;i++) x[i]=more;
            return true;
        }
    }
    long long less=another/(n-p);
    if(more>less)
    {
        for(int i=1;i<=p;i++) x[i]=more; 
        long long rest=another-less*(n-p);
        for(int i=p+1;i<=n;i++) 
        {
            x[i]=less;
            if(rest>=(more-1)-less)
            {
                rest-=(more-1)-less;
                x[i]=more-1;
            }
            else 
            {
                x[i]+=rest;
                rest=0;
            }
        }
        if(rest>0)
            return false;
        return true;
    }
    else
        return false;
}
```
    - **核心实现思想**：计算\(p\)个人最多能拿的记号数\(more\)，判断剩余记号分给其余人是否能满足条件，分情况处理并判断是否有解。

### 最优关键思路或技巧
1. **贪心策略**：先让\(p\)个人尽可能多地拿记号，即取\(\min(m, k / p)\)，再合理分配剩余记号，保证满足恰好\(p\)个人拿到最多记号的条件。
2. **边界处理**：注意\(n = p\)等特殊情况，确保算法的完整性。

### 可拓展思路
同类型题可拓展到其他分配场景下的构造问题，类似算法套路是先确定关键值（如本题的最大记号数），再根据条件分情况处理剩余部分，注意考虑各种边界情况。

### 相似知识点洛谷题目
1. P1031 [均分纸牌](https://www.luogu.com.cn/problem/P1031)
2. P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. P1094 [纪念品分组](https://www.luogu.com.cn/problem/P1094)

### 个人心得摘录与总结
1. **作者：Maxmilite**：特判\(n = p\)以及判断剩余记号分配情况的处理花费了较多时间调试，强调了边界情况和细节处理的重要性。 

---
处理用时：32.30秒
# 题目信息

# 「Wdsr-2.5」小小的埴轮兵团

## 题目背景

杖刀偶磨弓是埴轮兵团的首长。

作为埴轮兵长，训练埴轮兵团是很平常的事情。

## 题目描述

磨弓下达命令让埴轮们站成一行。不妨认为它们站在了一个数轴上，每个埴轮的位置就是它脚下数轴的数字。磨弓会告诉你，第 $i$ 个埴轮的位置为 $a_i$ 。**不保证** $\bm {a_i}$ **升序**。

数轴的长度是有限制的，具体的范围是 $[-k,k]$ 。也就是说，如果某个埴轮移出了这个范围，它就脱离了这个队列了，并且不会再次回到队列当中。

为了训练埴轮，磨弓给埴轮们下达了 $m$ 个指令，有以下 3 种：

- 指令 1：**全体埴轮**向数轴的正方向移动 $x$ 个单位长度。
- 指令 2：**全体埴轮**往数轴的反方向移动 $x$ 个单位长度。
- 指令 3：依次报数，统计目前队列里一共有多少个埴轮。

但是磨弓发现，埴轮兵团的大小实在是太大了，以至于执行这些操作变得非常缓慢。尽管如此，磨弓仍然希望你告诉她所有指令 3 的结果。

## 说明/提示

#### 样例 1 说明

一共有三个埴轮。初始时，它们的站位分别是 $[-1,1,2]$ 。

- 第一次操作后，所有埴轮向左移动 $3$ 格，位置变成了  $[\underline{\bm{-4}},-2,-1]$ 。第一个埴轮被移出了数轴。
- 第二次操作后，输出当前的埴轮数目，为 $2$ 个。
- 第三次操作后，所有埴轮向右移动 $5$ 格，位置变成了 $[3,\underline \bm4]$ ，第二个埴轮被移出了数轴。
- 第四次操作后，输出当前的埴轮数目，为 $1$ 个。

#### 样例 2, 3

见下发附件。

#### 数据规模与约定

- 对于 $30\%$ 的数据，$1 \leq n, m \leq 5\times 10^3$；
- 对于另外 $20\%$ 的数据，$1\le k\le 500$；
- 对于 $100\%$ 的数据，$1 \leq n, m \leq 3\times 10^5$，$1 \leq k, x \leq 2 \times 10^9$，$-k \le a_i \le k$ 。

## 样例 #1

### 输入

```
3 4 3
-1 1 2
2 3
3
1 5
3```

### 输出

```
2
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效处理埴轮在数轴上的移动及统计操作展开。思路核心是利用排序和特定的数据结构或指针维护来避免每次操作对所有元素的暴力遍历。
1. **思路**：多数题解先对埴轮初始位置排序，然后通过维护偏移量来避免对每个埴轮位置的重复计算。对于移动操作，从队列两端（或已排序数组的两端）判断埴轮是否超出范围并进行出队（或更新边界）操作；对于查询操作，直接输出当前队列（或区间）内的元素个数。
2. **算法要点**：排序保证单调性以便后续操作；利用变量记录整体移动距离，减少计算量；根据操作类型从队列头或尾处理超出范围的元素。
3. **解决难点**：避免 $O(mn)$ 的暴力模拟时间复杂度，通过排序和维护边界等技巧将时间复杂度优化到 $O(n\log n + m)$ 或接近线性。

### 所选的题解
1. **作者：chlchl (5星)**
    - **关键亮点**：思路清晰，详细阐述了用双向队列 `deque` 解决问题的方法，对 STL 的使用讲解到位，代码简洁且注释详细，同时指出了容易出错的小细节。
    - **个人心得**：提醒注意输入数据不保证升序需排序、指令3输入格式及数据范围要用 `long long`。
    - **核心代码片段**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const ll N = 300000 + 10;
ll n, m, k, op, x, tot, a[N];
deque<ll> q;

int main(){
    cin >> n >> m >> k;
    for(ll i=1;i<=n;i++)    cin >> a[i];
    sort(a + 1, a + 1 + n);
    for(ll i=1;i<=n;i++)    q.push_back(a[i]);
    for(ll i=1;i<=m;i++){
        cin >> op;
        if(op == 3)    cout << q.size() << endl;
        else if(op == 1){
            cin >> x;
            tot += x;
            while(!q.empty()){
                ll v = q.back();
                if(v + tot > k)    q.pop_back();
                else    break;
            }
        }else if(op == 2){
            cin >> x;
            tot -= x;
            while(!q.empty()){
                ll v = q.front();
                if(v + tot < -k)    q.pop_front();
                else    break;
            }
        }
    }
    return 0;
}
```
    - **核心实现思想**：用 `deque` 存储埴轮位置，`tot` 记录整体移动距离。操作1和2时，根据移动方向从队尾或队头判断并弹出超出范围的元素；操作3直接输出队列大小。
2. **作者：囧仙 (4星)**
    - **关键亮点**：对问题本质剖析深刻，指出埴轮相对位置不变，通过维护 $d$ 表示整体移动距离，利用排序后的连续子区间 $[l, r]$ 表示当前队列，时间复杂度分析清晰。
    - **个人心得**：强调变量类型使用不当可能因数据溢出导致答案错误，需着重考虑边界问题。
    - **核心代码片段**：
```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long i64;
const int INF =2147483647;
i64 qread(){
    i64 w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN =3e5+3;
i64 n,m,p,q,k,A[MAXN],d;
char fil[256];
int main(){
    n=qread(),m=qread(),k=qread(),p=1,q=n,d=0;
    up(1,n,i) A[i]=qread(); sort(A+1,A+1+n);
    up(1,m,i){
        int op=qread();
        if(op==1){d+=qread();while(p<=q&&A[q]+d> k) --q;} else
        if(op==2){d-=qread();while(p<=q&&A[p]+d<-k) ++p;} else
        printf("%lld\n",q-p+1);
    }
    return 0;
}
```
    - **核心实现思想**：排序后，操作1和2更新 $d$ 并从区间两端判断是否超出范围，更新 $p$ 和 $q$ 表示的区间；操作3输出区间元素个数。
3. **作者：Eason_AC (4星)**
    - **关键亮点**：解法描述详细，对每个操作步骤有清晰的解释，代码注释丰富，容易理解。
    - **核心代码片段**：
```cpp
const int N = 3e5 + 7;
int n, m, k, L, R, l, r, x, vis[N];
ll dis, a[N];

int main() {
    n = Rint, m = Rint, k = Rint, L = -k, R = k, l = 1, r = n;
    F(int, i, 1, n) a[i] = Rint; sort(a + 1, a + n + 1);
    while(m--) {
        int op = Rint, out = 0;
        if(op == 1) {
            dis += (x = Rint);
            R(int, i, r, l) {
                if(vis[i]) break;
                else if(a[i] + dis > R) vis[i] = 1, out++;
                else break;
            }
            r -= out;
        } else if(op == 2) {
            dis -= (x = Rint);
            F(int, i, l, r) {
                if(vis[i]) break;
                else if(a[i] + dis < L) vis[i] = 1, out++;
                else break;
            }
            l += out;
        } else println(r < l? 0 : r - l + 1);
    }
    return 0;
}
```
    - **核心实现思想**：排序后，操作1和2更新 `dis` 并从区间两端遍历标记超出范围的点，更新区间边界；操作3根据区间边界输出元素个数。

### 最优关键思路或技巧
1. **排序**：对初始埴轮位置排序，利用单调性简化后续操作，避免对每个元素的重复判断。
2. **维护偏移量**：用一个变量记录整体移动距离，避免每次操作对所有元素位置的重新计算，减少时间复杂度。
3. **双端处理**：利用双端队列或维护数组两端的指针，从两端判断并处理超出范围的元素，高效模拟队列的出队操作。

### 可拓展之处
此类题目属于模拟与数据结构结合的类型，常见拓展方向为增加操作类型（如部分区间移动、查询特定位置元素等）或改变数据范围及约束条件。类似算法套路包括利用排序和维护边界来优化暴力模拟，以及使用合适的数据结构（如队列、栈等）来处理元素的进出操作。

### 相似知识点洛谷题目
1. **P1996 约瑟夫问题**：通过模拟和优化解决循环报数淘汰问题，考察对数据结构和模拟过程的理解。
2. **P1036 选数**：结合枚举和判断，与本题类似在于都需要对数据进行处理并根据条件筛选，锻炼逻辑思维和代码实现能力。
3. **P2676 [USACO07DEC]Bookshelf B**：涉及对数据的排序和处理，通过合理安排元素满足特定条件，与本题在排序和处理数据上有相似思路。 

---
处理用时：44.39秒
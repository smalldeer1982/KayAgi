# 题目信息

# [WFOI - 02] I wanna win the race（比赛）

## 题目背景

> best is yet to come

kid 不小心进入了联机模式，他需要比他的对手更快通关才能取得胜利……

## 题目描述

kid 走进了一个场地，若干名选手在进行比赛，场地可以抽象为一个坐标系。

选手们要从 $\left(1,1\right)$ 跑到 $\left(n,n\right)$，若当前选手处在 $\left(x,y\right)$，则他们下一步可以移动到 $\left(x\pm1,y\right)$ 或 $\left(x,y\pm1\right)$，注意，他们**仅可以在第一象限活动**，即任何时候 $x>0,y>0$。

所有点最开始都是 $\texttt{A}$ 类点，主办方选择了一个三元组 $\left(a,b,c\right)$，将所有满足 $a\leq x\leq b$ 且 $y\leq c$ 的点 $\left(x,y\right)$ 变为 $\texttt{B}$ 类点，选手每经过一个 $\texttt{A}$ 类需要耗时 $1$ 秒，每经过一个 $\texttt{B}$ 类需要耗时 $2$ 秒。请注意，**起始点和终点也要纳入计算。**

kid 想要赢得这场比赛，他想知道**最少**需要多少秒能到达终点。

**请注意，在【数据范围】中有重要的约束条件。**

## 说明/提示

**【样例解释】**

下图是其中一种可行的方案，紫色点为 $\texttt{A}$ 类点，红色点为 $\texttt{B}$ 类点：

![](https://s1.ax1x.com/2022/03/06/bBvQPJ.png)

**【数据规模与约定】**

**本题采用 $\tt Subtask$ 捆绑测试。**

对于 $30\%$ 的数据，$1<a<b<n\leq 10^3，0<c\leq 10^3$。

对于 $100\%$ 的数据，$1<a<b<n\leq 10^9，0<c\leq 10^9$。

## 样例 #1

### 输入

```
5
2 4 3```

### 输出

```
9```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解均通过分类讨论解决该问题。当\(c < n\)时，选手可直接从\((1,1)\)先走到\((1,n)\)，再走到\((n,n)\)，全程为\(A\)类点，耗时\(2n - 1\)秒；当\(c \geq n\)时，存在两种走法，一是直接穿过\(B\)类点区域，二是从上方绕过\(B\)类点区域，需比较这两种走法的耗时，取最小值。
    - 算法要点：利用题目中\(1 < a < b < n\)的条件，确定起点上方无\(B\)类点，从而简化问题，仅通过判断\(c\)与\(n\)的大小关系进行分类讨论。
    - 解决难点：多数题解提到，难点在于注意到数据范围中\(c\)未限制小于\(n\)，即选手可超越\(n×n\)范围移动，需考虑绕过\(B\)类点的情况。同时，由于\(n\)可达\(10^9\)，不能使用常规建图或搜索算法。

    整体来看，各题解思路相近，主要差异在于代码实现的简洁性和清晰度。

• 所选的题解：
  - 作者：Elgo87 (赞：10)  星级：5星
    - 关键亮点：思路清晰，通过简单明了的图示展示不同\(c\)取值下的走法，代码简洁高效。
    - 重点代码：
```cpp
# include <bits/stdc++.h>
using namespace std;

int main()
{
    long long n, a, b, c;
    cin >> n >> a >> b >> c;
    cout << (c >= n? min(2*n - 1 + b - a + 1, 2*c + 1) : 2*n - 1);
    return 0;
}
```
    - 核心实现思想：根据\(c\)与\(n\)的大小关系进行判断，若\(c \geq n\)，则计算并比较两种走法的耗时，取最小值输出；若\(c < n\)，则直接输出\(2n - 1\)。

  - 作者：Engulf (赞：5)  星级：4星
    - 关键亮点：分析详细，先指出常规最短路算法因数据范围不可行，再结合数据范围得出关键信息，通过图示辅助理解，代码实现规范，有自定义输入输出函数。
    - 个人心得：无
    - 重点代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

inline int read(){
    int x = 0, f = 0; char ch = getchar();
    while (!isdigit(ch)) f ^=!(ch ^ 45), ch = getchar();
    while (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return f? -x : x;
}
inline void write(int x){
    if (x < 0) x = -x, putchar('-');
    if (x >= 10) write(x / 10);
    putchar(x % 10 + '0');
}
inline void writeln(int x){write(x); puts("");}

signed main(){
    int n = read(), a = read(), b = read(), c = read();
    int ans = (n - 1) * 2 + 1;
    if (c >= n){
        ans = min(n * 2 + b - a, 2 * c + 1);
    }
    writeln(ans);
    return 0;
}
```
    - 核心实现思想：先读入数据，初始化答案为\(c < n\)时的情况，当\(c \geq n\)时，更新答案为两种走法耗时的最小值并输出。

  - 作者：sgl654321 (赞：3)  星级：4星
    - 关键亮点：题意描述清晰，解题思路分情况阐述详细，代码简洁易懂。
    - 个人心得：无
    - 重点代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,b,c;
long long ans1,ans2;
int main(){
    cin>>n>>a>>b>>c;
    if(c<n){
        cout<<2*n-1<<endl;
        return 0;
    }
    ans1 = 2 * n + b - a;
    ans2 = 2 * c + 1;
    cout<<min(ans1,ans2)<<endl;
    return 0;
}
```
    - 核心实现思想：读入数据后，根据\(c\)与\(n\)的大小进行判断，\(c < n\)时直接输出\(2n - 1\)；\(c \geq n\)时，分别计算两种走法的耗时并取最小值输出。

• 最优关键思路或技巧：
    - 思维方式：通过对数据范围的分析，挖掘出关键信息，如起点上方无\(B\)类点，从而简化问题，仅需根据\(c\)与\(n\)的大小关系进行分类讨论。
    - 代码实现技巧：在实现过程中，直接根据分类讨论的结果计算并输出答案，避免了复杂的数据结构和算法，利用简单的数学运算和条件判断解决问题。

• 可拓展之处：
同类型题通常会给出特定区域的不同权值，求起点到终点的最优路径。类似算法套路为根据题目给定的条件，如区域范围、移动规则等，合理分类讨论，找出所有可能的最优路径并比较。

• 相似知识点洛谷题目：
    - P1080 [NOIP2012 提高组] 国王游戏：涉及贪心算法，通过对数据的分析找到最优策略，与本题通过分析数据范围找解题关键类似。
    - P1223 排队接水：同样是通过对问题的分析，利用贪心思想找到最优方案，和本题思路有相似之处。
    - P1993 小 K 的农场：需要根据题目条件构建不等式关系，通过分类讨论和一些算法技巧求解，锻炼分析问题和分类讨论的能力。

• 个人心得摘录与总结：
    - 作者Galex：强调数据范围的重要性，通过对\(c\)范围的分析找到本题坑点，即路程中的坐标可超过\(n×n\)范围，从而确定解题方向。
    - 作者InterN_NOT_FOUND：提到被数据范围卡了很久，最终明白出题人将数据范围分开的意图，即\(c\)可以大于\(n\)，进而完善解题思路。
    - 作者charleshe：指出起终点不会是\(B\)类点这一由数据范围得出的关键信息，同时强调考虑选手可超越场地范围移动这一情况的重要性，否则容易出错。总结为在解题时要深入分析数据范围，挖掘隐藏信息，全面考虑各种可能情况。 

---
处理用时：36.06秒
# 题目信息

# 『JROI-4』淘气的猴子

## 题目背景

众所周知，jockbutt 是一个可爱的女孩纸。
![](https://cdn.luogu.com.cn/upload/image_hosting/73du6v88.png)

## 题目描述

jockbutt 有一个正整数序列，长度为 $n$，分别为 $a_1,a_2...a_n$，她非常喜欢这个序列，平时都非常爱惜它们。

可是有一天，当 jockbutt 在和你约会的时候，有一只淘气的小猴子改变了这个序列。

猴子操作了 $m$ 次。  

猴子的操作有两种类型：

- $\texttt{1 x y}$ 表示第 $x$ 个元素加上第 $y$ 个元素。
- $\texttt{2 x y}$ 表示第 $x$ 个元素乘上第 $y$ 个元素。

特别且显然地，当 $x=y$，新的 $x$ 就等于原来的 $x$ 的两倍或平方。

序列最后结果形如 $b_1,b_2...b_n$。

等到 jockbutt 回来时，全洛谷的人都在看猴子。$\colorbox{white}{\color{white}{\text{其实 jockbutt 才是他们看的猴子吧}}}$

jockbutt 非常生气，希望你能告诉她这个序列最初的形态，也就是 $a_1,a_2,a_3,...,a_n$，否则她就会嘤嘤嘤...

## 说明/提示


**本题采用捆绑测试。**

|  子任务编号 | 分值 | 特殊限制 |
| :-----------: | :---:| :-----------: |
| 1 | 25 | $1\leq n,m\leq 10$ |
| 2 | 25 | $1\leq n\leq 100$，$1\leq m \leq 50 $ |
| 3 | 50 | 无 |

- 对于 $100\%$ 的数据满足 $1\leq n\le 10^3$，$1\leq m\le 200$，对于任意的 $ i $ $ ( 1\leq i \leq n ) $，有 $1\leq a_{i},b_{i} \leq 2^{60}$。

## 样例 #1

### 输入

```
5 5
12 1 12 4 2
1 3 2
1 4 3
2 3 4
1 5 2
2 1 3```

### 输出

```
1 1 2 1 1
```

# AI分析结果

### 综合分析与结论
这些题解思路基本一致，均是通过逆向模拟猴子的操作来还原初始序列。算法要点在于记录操作并逆序处理，将加法逆为减法、乘法逆为除法。难点在于处理 \( x = y \) 的特殊情况，需特判将两倍逆为除以二、平方逆为开方。各题解在思路清晰度、代码可读性上有一定差异，但整体实现方法类似。

### 所选的题解
- **作者：Dream_weavers（5星）**
    - **关键亮点**：思路清晰，先明确题意，再阐述逆向模拟思路，代码简洁明了，用结构体记录操作，逻辑清晰。
    - **个人心得**：无
    ```cpp
    #include<bits/stdc++.h>
    #define int long long
    using namespace std;
    const int N=1e5+5;
    int n,m,b[N];
    struct node{//建一个记录操作的结构体
        int opt,x,y;
    }f[N];
    signed main(){
        scanf("%lld%lld",&n,&m);
        for(int i=1;i<=n;i++)scanf("%lld",&b[i]);
        for(int i=1;i<=m;i++){//输入操作
            scanf("%lld%lld%lld",&f[i].opt,&f[i].x,&f[i].y);
        }
        for(int i=m;i>0;i--){//进行“逆序”操作
            int opt=f[i].opt,x=f[i].x,y=f[i].y;
            if(opt==1){
                if(x!=y)b[x]-=b[y];
                else b[x]/=2;//特判x=y
            }else if(opt==2){
                if(x!=y)b[x]/=b[y];
                else b[x]=sqrt(b[x]);//特判x=y
            }
        }
        for(int i=1;i<=n;i++)printf("%lld ",b[i]);//还原
        return 0;
    }
    ```
- **作者：_Give_up_（4星）**
    - **关键亮点**：思路阐述清晰，直接点明逆向推导思路及需注意的大坑，代码结构清晰。
    - **个人心得**：提到自己提交3次才通过，强调了题目有坑。
    ```cpp
    #include<bits/stdc++.h> 
    #define N 1010
    using namespace std;
    typedef long long ll;
    int a[N];
    struct rec
    {
        int k,x,y;
    };
    rec z[N];
    int main()
    {
        ios::sync_with_stdio(false);
        cin.tie(0);
        int n,m;
        cin >> n >> m;
        for (int i=1;i<=n;i++)
            cin >> a[i];
        for (int i=1;i<=m;i++)
            cin >> z[i].k >> z[i].x >> z[i].y;
        for (int i=m;i>=1;i--)
        {
            if (z[i].k==1)
            {
                if (z[i].x==z[i].y) a[z[i].x] /= 2;
                else a[z[i].x] -= a[z[i].y];
            }
            else
            {
                if (z[i].x==z[i].y) a[z[i].x] = sqrt(a[z[i].x]);
                else a[z[i].x] /= a[z[i].y];
            }
        }
        for  (int i=1;i<=n;i++)
            cout << a[i] << " ";
        cout << endl;
        return 0;
    }
    ```
- **作者：HappyCode（4星）**
    - **关键亮点**：思路简洁明了，直接阐述逆向恢复序列的方法及特殊情况处理，提醒从最后一个操作开始恢复。
    - **个人心得**：无
    ```cpp
    #include<iostream>
    #include<cmath>
    using namespace std;
    int n,m,k[205],x[205],y[205];
    long long b[1005];
    int main(){
        cin>>n>>m;
        for(int i=1;i<=n;i++){
            cin>>b[i];
        }
        for(int i=1;i<=m;i++){
            cin>>k[i]>>x[i]>>y[i];
        }
        for(int i=m;i>=1;i--){
            if(k[i]==1){
                if(x[i]==y[i]){
                    b[x[i]]/=2;
                }else{
                    b[x[i]]-=b[y[i]];
                }
            }
            if(k[i]==2){
                if(x[i]==y[i]){
                    b[x[i]]=sqrt(b[x[i]]);
                }else{
                    b[x[i]]/=b[y[i]];
                }
            }
        }
        for(int i=1;i<=n;i++){
            cout<<b[i]<<' ';
        }
        return 0;
    }
    ```

### 最优关键思路或技巧
- **逆向思维**：通过逆向模拟操作，将加法逆为减法、乘法逆为除法，巧妙解决问题。
- **特殊情况特判**：针对 \( x = y \) 的特殊情况进行特判处理，保证结果准确性。

### 可拓展思路
同类型题通常围绕逆向操作展开，如对字符串、矩阵等进行一系列操作后要求还原初始状态。类似算法套路是先明确正向操作，再思考其逆向操作，同时注意特殊情况的处理。

### 相似知识点洛谷题目
- [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)：通过模拟过程解决问题，涉及到循环链表或数组模拟等知识点。
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：利用递归或枚举模拟选数过程，与本题模拟操作思路类似。
- [P1161 开灯](https://www.luogu.com.cn/problem/P1161)：通过模拟开关灯操作，考察对操作过程的理解和实现。 

---
处理用时：27.43秒
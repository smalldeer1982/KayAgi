# 题目信息

# 不等价交换法则

## 题目背景

天弓千亦，市场之神，拥有着剥夺所有权的能力。

她希望着重建市场，在严格而公正的交易中一点点恢复自己的神力。但她看向世间一处处交易之所时，无力感却又遮住了她心中虹色的月光，把她的不甘一点点化作现实的泪。

她一次次在梦中经历着那个晚上。孤独的、神力尽失的她，紧紧攥住她那空白的卡牌，却被灵梦一把夺走。最后一张希望，也伴着虹色的月，消逝在永远的幻想中了。

也许交易本身就是不等价的吧，她想。

## 题目描述

你有 $n$ **件**商品可以买，其中第 $i$ 件的价格为 $a_i$。

蓝会给出一个正整数 $w$，代表你有 $w$ 元钱。你仅可以选择**一件**商品购买。店主允许你用已有的商品交换剩余的商品（当然了，也可以不换），但你交换获得的商品的价值和必须小于等于你用于交换的商品价值和。你想要知道，你最多能获得多少件商品。

注意：不能用空集交换其他商品。

## 说明/提示

【样例解释】

买价值为 $2$ 的物品，并交换为两个价值为 $1$ 的物品。

【数据范围及约束】

对于 $40\%$ 的数据，$n\leq 10$。

对于 $100\%$ 的数据，$1 \leq n\leq10^6$，$0 \leq a_i\leq 10^9$，$1 \leq w\leq2\times10^{9}$。


## 样例 #1

### 输入

```
3 
1 1 2
5```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：这些题解思路较为统一，均采用贪心策略。核心思路是先用给定的钱w购买能买到的最贵商品，再用该商品交换尽可能多的便宜商品。算法要点在于对商品价格数组进行排序，以方便寻找最值。解决难点主要在于证明贪心策略的正确性，即为何购买最贵商品并交换最便宜商品能得到最多商品数量。多数题解通过简单举例或逻辑推导证明。

从质量上看，多数题解思路清晰，但部分题解代码可读性欠佳，如未合理使用注释，或代码结构较混乱。部分题解在细节处理上，如边界条件判断，存在差异。

• 所选的题解：
  - 作者：_Give_up_ (4星)
    - 关键亮点：思路清晰简洁，代码结构简单明了，通过注释对关键步骤进行说明，易读性好。先排序，再分别寻找能买的最贵商品及能换的最多商品，逻辑连贯。
    - 重点代码及核心实现思想：
```cpp
#include<bits/stdc++.h>
#define int long long 
#define N 1000010
using namespace std;
typedef long long ll;
int read() {
    int x = 0,f = 1;
    char c = getchar();
    while(c<'0' || c>'9') {
        if(c=='-') f = -1;
        c = getchar();
    }
    while(c>='0' && c<='9') {
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
    return x*f;
}
int a[N];
signed main() {
    int n=read();
    for (int i=1;i<=n;i++)
        a[i] = read();
    int w=read(),k=0;
    sort(a+1,a+n+1); 
    for (int i=n;i>=1;i--) {
        if (w>=a[i]) {
            k = a[i];
            break;
        }
    }
    int ans = 0;
    for (int i=1;i<=n;i++) {
        if (k>=a[i]) {
            ans++;
            k -= a[i];
        }
    }
    cout << ans << endl;
    return 0; 
}
```
核心实现思想：先通过快读读取数据，将商品价格数组从小到大排序。然后从后往前遍历数组，找到能买得起的最贵商品，记录其价格k。最后从前往后遍历数组，用k依次减去价格小于等于k的商品价格，同时统计能换得的商品数量ans。

  - 作者：5k_sync_closer (4星)
    - 关键亮点：思路阐述清晰，对贪心策略的两个关键结论（买最贵商品、交换只进行一次）给出了简单证明。代码简洁高效，利用STL函数简化操作。
    - 重点代码及核心实现思想：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n, w, q, a[1000050];
int main() {
    scanf("%d", &n);for(int i = 0;i < n;++i) scanf("%d", a + i);
    scanf("%d", &w);sort(a, a + n);w = *(upper_bound(a, a + n, w) - 1);
    for(int i = 0;i < n;++i) if(w >= a[i]) w -= a[i], ++q;
    return printf("%d", q), 0;
}
```
核心实现思想：先读取数据并对商品价格数组排序，利用`upper_bound`找到第一个大于w的位置，减1后得到能买的最贵商品价格并更新w。然后遍历数组，用w依次减去价格小于等于w的商品价格，同时统计能换得的商品数量q。

  - 作者：Jorisy (4星)
    - 关键亮点：思路表述清晰，代码简洁且注释详细，对边界条件（如钱不够买任何商品）进行了处理。先排序，再按贪心策略寻找购买及交换的商品。
    - 重点代码及核心实现思想：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1000005],w;
signed main() {
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    cin>>w;
    sort(a+1,a+n+1);
    if(w<a[1]) {
        puts("0");
        return 0;
    }
    int k=n;
    while(a[k--]>w);
    k++;
    int p=a[k],ans=0;
    for(int i=1;(i==1||i<k)&&p>=a[i];i++) {
        p-=a[i];
        ans++;
    }
    cout<<ans;
    return 0;
}
```
核心实现思想：先读取数据并排序，判断钱w是否小于最小商品价格，若小于则输出0。否则从后往前找到能买的最贵商品，记录其价格p。然后从前往后遍历数组，用p依次减去价格小于等于p的商品价格，同时统计能换得的商品数量ans。

• 最优关键思路或技巧：
  - **贪心策略**：选择购买最贵商品以最大化可交换价值，再选择最便宜商品进行交换以最大化商品数量。
  - **排序**：对商品价格数组排序，方便寻找最值及按顺序处理商品。
  - **边界条件处理**：考虑钱不够买任何商品，以及购买商品后无法交换其他商品等情况。

• 可拓展之处：同类型题可涉及不同限制条件下的资源分配问题，类似算法套路是先分析问题性质，确定贪心策略，通过排序等操作简化计算过程。例如，在背包问题变体中，根据物品价值、重量及背包容量限制，合理选择贪心策略。

• 推荐题目：
  - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：通过贪心策略每次选择最小的两个果子堆合并，与本题选择最值思路类似。
  - [P1199 三国游戏](https://www.luogu.com.cn/problem/P1199)：需要根据武将武力值等条件进行策略选择，考察贪心思想。
  - [P2089 烤鸡](https://www.luogu.com.cn/problem/P2089)：在一定条件限制下，通过合理策略选择配料，可使用贪心思路求解。

• 个人心得摘录与总结：
  - 作者RNTBW提到最初未考虑只能选最小数且无法交换的情况，导致只得到90分，后通过特判解决。总结为在解决贪心问题时，要全面考虑边界条件，不能遗漏特殊情况，对问题的理解要细致入微，避免因小失大。 

---
处理用时：31.86秒
# 题目信息

# 「REOI-1」奶油蛋糕

## 题目背景


----------
早餐时间过后，小不点们都前往操场接受基础训练课程，威廉便趁机占据厨房了。  
他在军服上披围裙，头上绑三角巾，还将清早从市场采买回来的大量材料摆到桌上。  
接着，威廉烤了大量的奶油蛋糕。  

威廉把奶油蛋糕摆放到桌子上，珂朵莉闻到了蛋糕的香味，迫不及待地扑到了餐桌前享受着这份饕餮盛宴，然而蛋糕的制作，似乎还差了那么最后一步……  
“等一等哦，我还没有挤上奶油呢。”威廉说着，拿起了裱花袋。  

可饥肠辘辘的珂朵莉哪里等得起全部的奶油都给挤好？  
正当威廉还在忙着挨个给蛋糕挤上白花花的奶油的时候，珂朵莉已经偷偷的拿起了一块蛋糕……

## 题目描述

在桌子上的蛋糕可以看作是一个无限大的[平面直角坐标系](https://baike.baidu.com/item/%E5%B9%B3%E9%9D%A2%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB/1296463?fr=aladdin)，每一个蛋糕都位于坐标系的整点上。 

每一分钟，威廉会给每个蛋糕都涂上若干层奶油，规则如下：如果蛋糕连续第 $i$ 次没有被珂朵莉吃到，那么就会在蛋糕上挤上 $i$ 层奶油。  

每次在威廉挤完所有蛋糕的奶油后，珂朵莉会拿起一块蛋糕，把这个蛋糕上的奶油给吃掉一层。特别的，如果珂朵莉吃掉了蛋糕上的一层奶油，威廉马上会贴心的再次给这个蛋糕补上一层，且不计入连续没有被吃到的次数里（即下一次的 $i$ 依旧为 $1$ ）。  

由于蛋糕太多，珂朵莉实在不知道从何下手，所以她决定按照移动的吃法进行试吃。  
总共 $m$ 个分钟，珂朵莉的吃蛋糕序列可以用一个长度为 $m$ 的字符串表达。第 $t$ 个字符可能为 `N`，`S`，`W`，`E`分别表示珂朵莉在第 $t+1$ 分钟会吃掉第 $t$ 分钟吃掉蛋糕的上，下，左，右方位的蛋糕。  
珂朵莉第 $1$ 个分钟会拿起位于点 $(x,y)$ 的蛋糕，因为蛋糕目前没有被挤上奶油，所以珂朵莉既不会进行试吃，威廉也不会立刻给她补上奶油。

珂朵莉想知道在 $m$ 分钟后，这些蛋糕在最后都还剩多少层奶油。

本题中的上和右分别表示 $y$ 轴正方向和 $x$ 轴正方向。

---
简要题面：

有一个 $n\times n$ 的地块，一个连续 $i$ 分钟没人经过的地面在第 $i$ 分钟会落上 $i$ 个单位的灰，有人经过时不会落灰但灰也不会清零，在人走后第一分钟又会落上一个单位的灰，以此类推。有一个人在这个 $n\times n$ 的范围内移动，他的移动轨迹可以描述为一个由 $\text{N,S,W,E}$ 组成的字符串，每个字母分别表示上、下、左、右。这个人一开始在点 $(x,y)$，每一分钟移动一步。

求最后每一个位置上落下的灰的量。

保证这个人没有超过移动的范围。


## 说明/提示

**本题 y 轴朝上，x 轴朝右，样例输出中的左下角表示 $(1,1)$，第一分钟珂朵莉在初始点处，第二分钟移动到相应的位置，第 $m+1$ 分钟移动到最后一个点，但是总共只有 $m$ 分钟，因此最后一个点不受移动的影响**

---
**样例 1 解释：**

珂朵莉的移动路径为 $(1,1)\rightarrow(1,2)\rightarrow(2,2)\rightarrow(2,3)\rightarrow(1,3)$，共 $4$ 分钟。

对于第 $1$ 分钟，$(1,1)$ 奶油层数不变，其余点被挤上了 $1$ 层奶油。

对于第 $2$ 分钟，$(1,2)$ 奶油层数不变，$(1,1)$ 被挤上了 $1$ 层奶油，其余点挤上 $2$ 层奶油。

对于第 $3$ 分钟，$(2,2)$ 奶油层数不变，$(1,1)$ 挤上 $2$ 层奶油，$(1,2)$ 挤上 $1$ 层奶油，其余点挤上 $3$ 层奶油。

对于第 $4$ 分钟，$(2,3)$ 奶油层数不变，$(1,1)$ 挤上 $3$ 层奶油，$(1,2)$ 挤上 $2$ 层奶油，$(2,2)$ 挤上 $1$ 层奶油，其余点挤上 $4$ 层奶油。

**注意最后珂朵莉移动到了 $(1,3)$，但是时间只有 $4$ 分钟，所以实际上不会对 $(1,3)$ 造成影响。初始点不一定在 $(1,1)$。**

$1\le n\leq 50,1\leq m\le 1000$。

## 样例 #1

### 输入

```
5 4 1 1
NENW```

### 输出

```
10 10 10 10 10 
10 10 10 10 10 
10 6 10 10 10 
4 4 10 10 10 
6 10 10 10 10 
```

## 样例 #2

### 输入

```
7 14 1 1
NENENENENESSSS```

### 输出

```
105 105 105 105 105 105 105 
105 105 105 105 55 61 105 
105 105 105 49 51 69 105 
105 105 51 49 105 79 105 
105 61 55 105 105 91 105 
79 69 105 105 105 105 105 
91 105 105 105 105 105 105 
```

## 样例 #3

### 输入

```
10 70 2 2
NWSNSNNNSNNSSNNSENNNNEESNWSESESSWENNSEWESWWWESEEESENNSENWNESNWSNNNEESS```

### 输出

```
2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 
2485 1407 1205 1267 2485 2485 2485 2485 2485 2485 
2485 1435 1281 1167 2485 2485 2485 2217 2281 2347 
2485 1465 2485 1255 1041 2485 2485 2155 2485 2415 
1557 1497 2485 2485 969 1177 2485 1733 1807 2485 
1471 1531 1315 907 935 1267 2485 1473 1647 2485 
1631 2485 2485 1357 1381 1407 1435 1499 1645 2485 
2021 2347 2485 2485 2485 2485 1465 1497 2485 2485 
2087 2415 2485 2485 2485 2485 2485 2485 2485 2485 
2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 
```

## 样例 #4

### 输入

```
5 4 2 1
NENW```

### 输出

```
10 10 10 10 10 
10 10 10 10 10 
10 10 6 10 10 
10 4 4 10 10 
10 6 10 10 10 
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕暴力模拟展开，核心是处理珂朵莉移动过程中各蛋糕点奶油层数的变化。思路上，有的通过记录每个点的访问时间来计算奶油层数，有的直接按时间模拟每个点奶油层数的累加与重置。算法要点在于正确处理珂朵莉移动到某点时该点奶油层数的特殊处理（清零并重新计数），以及其他点奶油层数的正常累加。难点在于理解题目中坐标和移动方向的设定，部分题解提到 $x$ 和 $y$ 坐标需反着读，输出时行列也有特殊对应关系。从质量上看，多数题解思路较清晰，但代码可读性和优化程度参差不齐。

所选的题解：
  - 作者：XL4453 (赞：8)  星级：4星
    - 关键亮点：通过记录每个位置被走过的时间，利用等差数列求和公式直接计算最终奶油层数，思路简洁清晰，代码实现较为直观。
    - 重点代码及核心思想：
```cpp
int calc(int x){
    return  x*(x+1)/2;
}
//...
for(int i=0;i<s.size();i++){
    v[x][y].push_back(i+1);
    // 根据移动方向更新坐标
}
for(int i=n;i>=1;i--){    
    for(int j=1;j<=n;j++){
        v[i][j].push_back(s.size()+1);
        int ans=0,now=0;
        for(int k=0;k<v[i][j].size();k++){
            ans+=calc(v[i][j][k]-now-1);
            now=v[i][j][k];
        }
        printf("%d ",ans);
    }
    printf("\n");
}
```
核心思想是先记录每个位置的访问时间序列，最后通过相邻访问时间的差值，利用 `calc` 函数计算等差数列和来得到该位置的奶油层数。

  - 作者：cachejtt (赞：1)  星级：4星
    - 关键亮点：提供了两种做法，一种是常规暴力模拟，另一种利用只处理被修改点的思路优化到 $O(m)$ 复杂度，对不同思路进行了展示和对比。
    - 做法2重点代码及核心思想：
```cpp
void solvel(string s,int x,int y,int cnt){
    if(cnt>m)return;
    g[x][y]+=(cnt-c[x][y])*(cnt-c[x][y]-1)/2;
    vis[x][y]=1;
    c[x][y]=cnt;
    // 根据移动方向递归调用
}
//...
solvel(ss,xx,yy,1);
rep(i,1,n){
    rep(j,1,n){
        if(vis[n-i+1][j])cout<<g[n-i+1][j]+(m-c[n-i+1][j])*(m-c[n-i+1][j]+1)/2<<" ";
        else cout<<m*(m+1)/2<<" ";
    }
    cout<<endl;
}
```
核心思想是记录每个点上一次经过的时间 `c[x][y]`，通过当前时间 `cnt` 与上一次时间的差值计算该时间段内的落灰数，最后再处理最后一次落灰情况。

  - 作者：0xFF (赞：0)  星级：4星
    - 关键亮点：通过记录每个方格上次经过的时间，利用等差数列求和公式计算两次经过时间间隔内的落灰厚度，思路清晰，代码简洁明了。
    - 重点代码及核心思想：
```cpp
for(int i(1);i<=m;i++){
    ans[dx][dy] += (i - last[dx][dy]) * (i - last[dx][dy] - 1) / 2;
    last[dx][dy] = i;
    // 根据移动方向更新坐标
}
for(int i(1);i<=n;i++){
    for(int j(1);j<=n;j++){
        ans[i][j] += (m - last[i][j]) * (m - last[i][j] + 1) / 2;
    }
}
```
核心思想是在移动过程中，每次更新当前点的上次经过时间 `last[dx][dy]`，并累加该时间段的落灰数，最后再对所有点处理到结束时间的落灰数。

最优关键思路或技巧：记录每个点的访问时间，利用等差数列求和公式计算两次访问时间间隔内的奶油层数（或落灰数），这种方法避免了每次都对所有点进行遍历更新，提高了效率，同时简化了代码逻辑。

可拓展之处：此类题目属于模拟与统计结合的类型，类似套路是记录关键时间点或状态变化，利用数学公式简化计算。例如在一些游戏角色在地图上移动，地图各点有状态变化并需要统计最终状态的题目中可应用。

推荐洛谷题目：
  - P1031 均分纸牌：通过模拟移动纸牌的过程，锻炼对状态变化的处理能力。
  - P1423 小玉在游泳：涉及简单的模拟和条件判断，与本题类似在于按时间或步骤模拟状态变化。
  - P1909 买铅笔：同样是模拟购买场景，根据不同条件进行计算和选择，培养模拟题的解题思路。

个人心得摘录与总结：
  - 作者 _Give_up_ 提到要注意题中 $x$ 和 $y$ 需反着读，坐标从左下角开始计，这是理解题意的关键，否则会导致结果错误。
  - 作者 RAVE_LOVEo_O 表示题目有点绕，提交多次才通过，强调要注意题目中坐标方向、输入顺序等细节，这些细节容易被忽略从而导致错误。 

---
处理用时：29.41秒
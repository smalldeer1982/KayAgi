# 题目信息

# [CoE R5] 暴龙的白菜

## 题目背景

暴龙爱吃白菜。

## 题目描述

给定一个字符串，由 $1$ 个 $\texttt{1}$，$2$ 个 $\texttt{2}$，$3$ 个 $\texttt{3}$，$4$ 个 $\texttt{4}$，$5$ 个 $\texttt{5}$，$6$ 个 $\texttt{6}$，$7$ 个 $\texttt{7}$，$8$ 个 $\texttt{8}$，$9$ 个 $\texttt{9}$，$10$ 个 $\texttt{10}$……以此类推，依次拼接而成。

询问字符串第 $l$ 位到第 $r$ 位的数字之和。

## 说明/提示

**样例解释**

字符串为：

$$\texttt{12233344445555566666677777778888888899999999910101010101010101010}\cdots\cdots$$

对于第一组询问，第 $5$ 位到第 $9$ 位的数字之和为 $3+3+4+4+4=18$。

对于第二组询问，第 $46$ 位到第 $50$ 位的数字之和为 $1 + 0 + 1 + 0 + 1 = 3$。

------------

**数据范围**

**本题采用捆绑测试。**

- $\texttt{Subtask 1(10 pts)：}T=1$，$1\le l\le r\le 10$；
- $\texttt{Subtask 2(20 pts)：}1\le T\le 10$，$1\le l\le r\le 10^3$；
- $\texttt{Subtask 3(30 pts)：}1\le T\le 10^3$，$1\le l\le r\le 10^5$；
- $\texttt{Subtask 4(40 pts)：}$无特殊限制。

对于 $100\%$ 的数据，满足 $1\le T\le 10^5$，$1\le l\le r\le 10^6$。

## 样例 #1

### 输入

```
4
5 9
46 50
114 514
19 19810```

### 输出

```
18
3
1134
74924```

# AI分析结果

• 综合分析与结论：这些题解的核心思路均是先构造出符合题意的字符串或数组，再利用前缀和来快速处理区间查询。不同之处在于构造字符串或数组的方式，以及对边界条件和优化的处理。

  1. **Shanganze题解**：直接按题意模拟构造字符串，用字符串存放每一位数字，再进行前缀和预处理。代码实现较为直观，但对于三位数及以上的处理稍显繁琐。
  2. **buqiming题解**：使用树状数组，在每个位置插入对应数字，利用树状数组的性质进行求和。思路独特，但相比前缀和方法，代码复杂度稍高。
  3. **Trump__Biden题解**：通过循环构造数组并记录前缀和，与Shanganze思路类似，只是未使用字符串，而是直接处理数字。
  4. **Larryyu题解**：先预处理出字符串，再遍历记录前缀和。特别之处在于提前计算出字符串数最多在1000和1050之间，减少不必要的计算。
  5. **MvemiY题解**：先构造数组，最初暴力求和TLE，后通过前缀和优化。代码中通过离线求出max(r)来优化构造数组的过程。
  6. **LeiZeProMax题解**：暴力构造字符串并求前缀和，与Shanganze和Trump__Biden思路类似。
  7. **AirQwQ题解**：通过拆位法构造前缀和数组，思路清晰，但未给出完整代码。
  8. **Lagerent题解**：发现数字位数与在序列中占的位数关系，通过程序得出处理到819即可，优化了预处理过程。

  整体来看，多数题解质量尚可，但在优化程度、思路清晰度和代码可读性上有提升空间。

• 所选的题解：
  - **Larryyu题解**：★★★★
    - 关键亮点：提前计算出字符串数的范围，减少预处理的工作量，代码实现简洁明了。
    - 核心代码实现思想：先通过两层循环构造出完整字符串，再遍历字符串计算前缀和，最后根据输入的l和r输出对应前缀和的差值。
```cpp
for(int i=1;i<=1100;i++){
    for(int j=1;j<=i;j++){
        s+=ss[i];  //预处理字符串
    }
}
sum[0]=0;
for(int i=1;i<=1000000;i++){
    sum[i]=sum[i-1]+s[i-1]-'0';  //预处理前缀和
}
t=read();
while(t--){
    int l=read(),r=read();
    printf("%d\n",sum[r]-sum[l-1]);
}
```
  - **Lagerent题解**：★★★★
    - 关键亮点：通过分析得出处理到819即可满足数据范围，优化了预处理过程，时间复杂度为O(n)，查询O(1)。
    - 核心代码实现思想：先通过函数q计算数字的位数，在init函数中根据位数和数字个数构造数组b并记录前缀和sum，最后根据输入的l和r输出对应前缀和的差值。
```cpp
int q(int x) {
    int cnt = 0, t = x;
    memset(s, 0, sizeof s);
    while(t) {
        cnt ++ ;
        t /= 10;
    }
    per(i, cnt, 1) s[i] = x % 10, x /= 10;
    return cnt;
}

il void doit() {
    for(int i = last + 1; i <= res; i += w) {
        rep(j, 1, w) {
            b[i + j - 1] = s[j];
        }
    }
}

il void init() {
    res = 0, last = 0;
    rep(i, 1, 819) {
        w = q(i);
        res += i * w;
        doit();
        last = res;
    }
    rep(i, 1, res) sum[i] = sum[i - 1] + b[i];
}
```
  - **Shanganze题解**：★★★
    - 关键亮点：思路直接，按题意模拟构造字符串并进行前缀和预处理，适合初学者理解。
    - 核心代码实现思想：通过两层循环构造字符串，根据数字位数不同进行不同处理，再计算前缀和，最后根据输入的l和r输出对应前缀和的差值。
```cpp
for(int q=1;q<=1000;q++){//外层循环模拟当前应在字符串后连接的数字
    for(int w=1;w<=q;w++){//内层循环模拟该数应在字符串连接多少个。
        if(q<10)a+=char(q-1+'1');//个位数，直接转字符连接。
        else if(q<100)a+=char(q/10-1+'1'),a+=char(q%10-1+'1');//两位数，先连接十位，再连接个位。
        else if(q<1000)a+=char(q/100-1+'1'),a+=char(q/10%10-1+'1'),a+=char(q%10-1+'1');//三位数同理。
    }
}
for(int q=0;q<=1000001;q++){
    x[q+1]=x[q]+a[q]-'0';//前缀和预处理。
}
for(int q=1;q<=T;q++){
    int l,r;
    l=read();r=read();
    cout<<x[r]-x[l-1]<<endl;//输出时，因为要包含左端点，所以减去左端点的前一位。
}
```

• 最优关键思路或技巧：通过分析数据范围，找出字符串构造的边界条件（如Larryyu和Lagerent题解中确定处理到1000 - 1050或819即可），减少不必要的计算，优化预处理过程。同时，利用前缀和来快速处理区间查询，这是解决此类区间求和问题的常用技巧。

• 可拓展之处：同类型题常考察有规律序列的构造与区间查询，类似算法套路是先分析序列规律，构造数据结构（如数组、字符串），再结合前缀和、树状数组、线段树等数据结构处理区间查询。若涉及区间修改，线段树或树状数组更为合适；若无区间修改，前缀和通常是更优选择。

• 推荐洛谷题目：
  - P1115 最大子段和：考察前缀和与动态规划思想，通过计算前缀和来快速得到子段和。
  - P3374 【模板】树状数组 1：基础的树状数组区间查询和单点修改题目，有助于理解树状数组的应用。
  - P3368 【模板】线段树 1：经典的线段树模板题，涉及区间修改和区间查询，可拓展对区间操作的理解。

• 个人心得摘录与总结：无。 

---
处理用时：29.96秒
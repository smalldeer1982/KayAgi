# 题目信息

# [JRKSJ R5] 1-1 A

## 题目背景

本题是 1-1 的较易版本，较难版本为 [1-1 B](https://www.luogu.com.cn/problem/P8848)。

## 题目描述

给出一个序列 $a$，$\forall i\in [1,n],a_i\in \{1,-1\}$。

你可以将序列任意重排，需最小化重排后序列的最大子段和。

## 说明/提示

最大子段和的定义：序列中一段区间的和的最大值。即 $\max_{1\le l\le r\le n} \sum_{i=l}^r a_i$。

本题使用 $\text{Special Judge}$，只要你的输出满足题意即可通过。

**本题输入输出文件较大，请使用恰当的输入输出方式。**

### 数据规模
本题采用捆绑测试。

| $\text{Subtask}$ | $n\le$ | $\text{Score}$ |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | $40$ |
| $2$ | $10^6$ | $60$ |

对于 $100\%$ 的数据，$1\le n\le 10^6$，$a_i\in \{1,-1\}$。

## 样例 #1

### 输入

```
4
1 1 -1 -1```

### 输出

```
1 -1 -1 1```

# AI分析结果

• 综合分析与结论：这些题解思路大致相同，均利用序列仅由1和 -1构成的特性，通过统计1和 -1的数量，分情况讨论构造序列以最小化最大子段和。算法要点在于根据1和 -1数量的比较，先交替输出数量少的那种数与另一种数，再输出剩余数量多的数。解决难点在于证明这样构造能得到最小的最大子段和。多数题解代码简单直接，时间复杂度均为O(n)。

所选的题解：
  - 作者：U_star (5星)
    - 关键亮点：思路清晰，详细分类讨论三种情况，并对每种情况的构造方式及最优性进行证明，代码简洁明了。
    - 重点代码核心思想：统计1和 -1的数量，根据数量关系分情况按特定规则输出序列。
```cpp
#include<bits/stdc++.h> 
using namespace std;
int a,v1,v2;
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a;
        if(a==1)
            v1++;
        else
            v2++;
    }
    if(v2==v1)
    {
        for(int i=1;i<=n;i++)
        {
            if(i%2)
                cout<<1<<" ";
            else
                cout<<-1<<" ";
        }
    }
    else if(v2>v1)
    {
        for(int i=1;i<=v1*2;i++)
        {
            if(i%2)
                cout<<1<<" ";
            else
                cout<<-1<<" ";
        }
        for(int i=1;i<=n-v1*2;i++)
            cout<<-1<<" ";
    }
    else
    {
        for(int i=1;i<=v2*2;i++)
        {
            if(i%2)
                cout<<1<<" ";
            else
                cout<<-1<<" ";
        }
        for(int i=1;i<=n-v2*2;i++)
            cout<<1<<" ";
    }
    return 0;
}
```
  - 作者：Vct14 (4星)
    - 关键亮点：思路简洁，直接统计1和 -1的数量，按先交替输出数量少的，再输出数量多的方式构造序列，代码简洁。
    - 重点代码核心思想：与U_star类似，统计1和 -1数量，按规则输出序列。
```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
    int n;
    cin>>n;
    int m=0,o=0;
    for(int i=1; i<=n; i++){
        int a;
        cin>>a;
        if(a==-1) m++;
        else o++;
    }
    for(int i=1; i<=min(m,o); i++) printf("1 -1 ");
    int k=(m>=o)?-1:1;
    for(int i=1; i<=abs(m-o); i++) printf("%d ",k);
    return 0;
}
```
  - 作者：pxb0801 (4星)
    - 关键亮点：分析清晰，明确指出不同数量关系下最大子段和的最小值及构造方式，代码实现简洁。
    - 重点代码核心思想：统计1和 -1数量，按数量关系分情况构造输出序列。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt1,cnt2;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        int x;
        scanf("%d",&x);
        if(~x) cnt1++;
        else cnt2++;
    }
    if(cnt1>cnt2){
        for(int i=1;i<=cnt2;i++){
            printf("1 -1 ");
        }
        for(int i=cnt2+1;i<=cnt1;i++){
            printf("1 ");
        }
    }
    else{
        for(int i=1;i<=cnt1;i++){
            printf("1 -1 ");
        }
        for(int i=cnt1+1;i<=cnt2;i++){
            printf("-1 ");
        }
    }
    return 0;
}
```

最优关键思路或技巧：利用1和 -1能相互抵消的特性，通过统计两种数的数量，分情况构造序列。先将数量少的数与另一个数交替输出，再输出剩余数量多的数，可最小化最大子段和。

可拓展之处：同类型题可涉及其他具有特殊性质的序列重排求最值问题，类似算法套路是抓住序列元素间的特殊关系，通过合理构造解决问题。

推荐题目：
  - P1115 最大子段和，基础的最大子段和问题，可巩固相关知识。
  - P3166 [CQOI2014]数三角形，通过分类讨论等方法解决几何计数问题，锻炼分类讨论思维。
  - P1419 寻找段落，涉及序列的处理与最值求解，与本题有相似的分析思路。

个人心得：
  - 作者pxb0801提到这题和前一题一样是构造题，调试花费较长时间。总结为构造题需仔细思考构造方式，注意细节处理，避免调试时花费过多时间。 

---
处理用时：20.55秒
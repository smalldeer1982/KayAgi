# 题目信息

# 『MdOI R5』Jump

## 题目描述

数轴上有一个人，设他所在的位置为 $x$，初始时 $x=0$。第 $i$ 秒中他可以选择往左或往右跳 $2^{i-1}$ 单位长度，即将 $x$ 增大或减小 $2^{i-1}$。问他至少需要多少秒才能到达 $n$，即在某一秒结束的时刻使得 $x=n$。如果永远都不可能到达 $n$，那么输出 $-1$。

**本题每个测试点中有多组数据。**

## 说明/提示

对于 $100\%$ 的数据，$1\le T\le 10^3$，$1\le n\le 10^9$。

$\operatorname{Subtask} 1(30\%)$：$n\le 100$。

$\operatorname{Subtask} 2(40\%)$：$n=2^k$，其中 $k$ 是一个非负整数。

$\operatorname{Subtask} 3(30\%)$：无特殊限制。

#### 样例说明 1

$n=1$ 时只需要在第一秒中往右跳即可。

$n=2$ 时可以证明永远都不可能到达 $n$。

## 样例 #1

### 输入

```
10
1
2
7
8
9
10
11
935
101
2023```

### 输出

```
1
-1
3
-1
4
-1
4
10
7
11```

# AI分析结果

### 综合分析与结论
这些题解主要思路围绕奇偶性判断和利用二进制特性来解决问题。所有题解都指出由于第一步跳跃长度为奇数，之后为偶数，所以偶数位置不可达。对于奇数位置，多通过寻找大于等于 \(n\) 的最小 \(2\) 的幂次相关方式来确定步数。不同题解在证明、实现细节和代码优化上有所差异。

### 所选的题解
1. **作者：Kubic (5星)**
    - **关键亮点**：思路清晰简洁，通过严谨证明得出结论，利用二进制表示解决问题，时间复杂度低，代码精炼。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int T,n;
void slv()
{
    scanf("%d",&n);
    if(n&1) printf("%d\n",32-__builtin_clz(n));
    else printf("-1\n");
}
int main()
{
    scanf("%d",&T);
    while(T--) slv();return 0;
}
```
    - **核心实现思想**：先判断 \(n\) 的奇偶性，若为奇数，通过 `__builtin_clz` 函数计算出满足条件的最小秒数。
2. **作者：Moon_Traveller (4星)**
    - **关键亮点**：从简单情况入手，通过打表观察规律得出结论，代码实现清晰易懂，适合初学者理解。
    - **核心代码**：
```cpp
#include <iostream>
#include <cmath>
using namespace std;
#define int long long
int T;
int n;
int m[35];
void mi() // 记录2的非负整数次幂
{
    m[0] = 1;
    for(int i = 1; i <= 30; i++)
    {
        m[i] = m[i - 1] * 2;
    }
    return;
}
signed main()
{
    mi();
    cin >> T;
    for(int t = 1; t <= T; t++)
    {
        cin >> n;
        if(n % 2 == 1)
        {
            for(int i = 0; i <= n; i++)
            {
                if(m[i] > n) // 注意不是>=
                {
                    cout << i << endl;
                    break; // 不要忘了跳出循环
                }
            }
        }
        else // 如果n为整数，则直接输出-1
        {
            cout << -1 << endl;
        }
    }
    return 0;
}
```
    - **核心实现思想**：先预处理出 \(2\) 的非负整数次幂，根据 \(n\) 的奇偶性，若为奇数，遍历找到大于 \(n\) 的最小 \(2\) 的幂次的指数。
3. **作者：Infinite_Eternity (4星)**
    - **关键亮点**：分类讨论清晰，结论明确，代码简洁高效，利用对数函数快速得出结果。
    - **核心代码**：
```cpp
#include <stdio.h>
#include <math.h>
int main()
{
    int T,a;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&a);
        if (a==1) printf("%d\n",1);
        else if (!(a&1)) printf("%d\n",-1);
        else printf("%d\n",(int)log2(a)+1);
    }
    return 0;
}
```
    - **核心实现思想**：对 \(n\) 分三种情况讨论，通过 `log2` 函数计算出满足条件的秒数。

### 最优关键思路或技巧
1. **奇偶性判断**：利用第一步跳跃长度为奇数，后续为偶数的特性，快速判断偶数位置不可达，缩小问题范围。
2. **二进制思维**：将问题与二进制联系起来，无论是通过二进制表示来构造路径，还是通过寻找大于等于 \(n\) 的最小 \(2\) 的幂次，都巧妙利用了二进制的特性简化问题。

### 可拓展思路
此类题目属于数学规律探索与构造类问题。相似套路为先观察题目中数据变化规律，特别是与二进制、奇偶性相关的规律，再通过证明或打表等方式确定结论，最后根据结论进行代码实现。

### 相似知识点洛谷题目
1. [P1018 乘积最大](https://www.luogu.com.cn/problem/P1018)：涉及数字拆分与组合，与本题利用数字特性构造结果思路相似。
2. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：通过寻找数字间规律来解决问题，和本题探索规律的方式类似。
3. [P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226)：同样利用二进制思想优化计算，与本题利用二进制解决跳跃步数问题有相似之处。

### 个人心得摘录
暂未发现题解中有个人心得相关内容。 

---
处理用时：24.05秒
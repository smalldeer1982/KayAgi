# 题目信息

# Digital Fortress

## 题目背景

布林克霍夫大声喊道：“这当然是密码！这不是密码，还能是什么？还有什么原因能让友加送掉这枚戒指？到底是谁在戒指上刻一大串杂乱无章的字母？”

方丹愤怒地等了布林克霍夫一眼，使他安静了下来。

“啊……伙计们？”贝克插了一句话，似乎很不情愿卷进来一样，“你们一直说这些是杂乱无章的字母。我想我应该让你们知道……这枚戒指上刻的字母并不是杂乱无章。如果你近距离看一下，就会明白，实际上，这些字母……这个……这个是拉丁文。”

指挥台上的所有人都看向了那枚戒指。上面写道：

> Quis custodiet ipsos custiodies.  
谁来监视这些监视者……

## 题目描述

致命的变异串已经穿过了 X-11 过滤器，深入了国安局数据库。苏珊与贝克需要即时破解出密码，以关闭蠕虫病毒。

在蠕虫的文件中，他们找到了密码的一个特点：

- 共有 $n$ 位，每个数都在 $[1,m]$ 之间，并且单调不减。
- 如算出前缀异或和，那么前缀异或和也单调不减。
- 如算出后缀异或和，那么后缀异或和仍然单调不减。

除此之外，他们也找到了 $n,m$ 的值。现在，他们需要构造出一组密码，以满足所有特征。
***

#### 【形式化题意】

求是否存在长度为 $n$，所有元素都在 $[1,m]$ 范围内的单调不减正整数序列 $a$，满足：

- $\forall1<i\le n,a_1\ \text{xor}\ a_2\ \text{xor}\ \cdots\ \text{xor}\ a_{i-1}\le a_1\ \text{xor}\ a_2\ \text{xor}\ \cdots\ \text{xor}\ a_{i}$
- $\forall1\le i<n,a_n\ \text{xor}\ a_{n-1}\ \text{xor}\ \cdots\ \text{xor}\ a_{i+1}\le a_n\ \text{xor}\ a_{n-1}\ \text{xor}\ \cdots\ \text{xor}\ a_{i}$

如存在，输出一组合法解。多组数据。

## 说明/提示

#### 【样例解释】

对于第一组数据，密码的前缀异或和为 $\{1,7,15,31\}$，后缀异或和为 $\{16,24,30,31\}$，均为递增序列，满足题意。

对于第二组数据，不存在任何合法方案。

#### 【数据范围】

**本题开启捆绑测试。**

|$\text{Subtask}$|分值|$n\le$|$m\le$|
|:-:|:-:|:-:|:-:|
|$0$|$10$|$5$|$200$|
|$1$|$30$|$20$|$10^6$|
|$2$|$60$|$10^5$|$2^{63}-1$|

对于 $100\%$ 的数据，$1\le n\le10^5$，$1\le m\le2^{63}-1$，$1\le t\le50$。

## 样例 #1

### 输入

```
2
4 20
1919 114514
```

### 输出

```
Yes
1 6 8 16
No
```

# AI分析结果

• 综合分析与结论：这些题解思路相近，均发现构造序列\(a_i = 2^{i - 1}\)可满足条件。关键在于判断\(2^{n - 1}\)与\(m\)的大小关系，若\(2^{n - 1} \leq m\)则有解，否则无解。各题解在思路阐述、代码实现及优化上存在差异。
- **chlchl**：
  - 星级：5星
  - 关键亮点：思路清晰，先提出贪心结论，即确定最大数最小值来判断构造可能性，利用异或和递增需使高位某一位变1推出至少需\(n\)位为1 ，进而得出构造方式，还给出两种避免位运算溢出的方案。
  - 个人心得：无
  - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int T, n;
long long m;

int main(){
    scanf("%d", &T);
    while(T--){
        scanf("%d%lld", &n, &m);
        if(__lg(m) + 1 >= n){
            printf("Yes\n");
            for(int i=0;i<n;i++)
                printf("%lld ", (1ll << i));
            printf("\n");
        }
        else
            printf("No\n");
    }
    return 0;
} 
```
  - 核心实现思想：通过`__lg(m) + 1 >= n`判断是否有解，有解则按\(a_i = 2^{i - 1}\)输出序列。
- **Register_int**：
  - 星级：5星
  - 关键亮点：先指出“不减”条件的特殊情况，证明二进制位递增是数列及前缀异或和递增的充要条件，进而说明构造\(a_i = 2^{i - 1}\)的最优性。
  - 个人心得：无
  - 核心代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

int t, n; ll m; 

int main() {
    for (scanf("%d", &t); t--;) {
        scanf("%d%lld", &n, &m);
        if (__lg(m) + 1 < n) puts("No");
        else { puts("Yes"); for (int i = 0; i < n; i++) printf("%lld ", 1ll << i); puts(""); }
    }
}
```
  - 核心实现思想：用`__lg(m) + 1 < n`判断无解情况，有解则输出构造序列。
- **_shy**：
  - 星级：4星
  - 关键亮点：通过观察样例反推原数集合，推测\(2^0, 2^1, \dots 2^{n - 1}\)为字典序最小符合要求的集合，并使用数学归纳法证明其满足前缀异或和及后缀异或和的要求。
  - 个人心得：无
  - 核心代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long bt[100];
int t, n;
long long m; 
int main ()
{
    bt[0] = 1;
    for (int i = 1; i <= 62; i++) 
        bt[i] = bt[i - 1] * 2;
    scanf ("%d", &t);
    while (t --) 
    {
        scanf ("%d %lld", &n, &m);
        if (n - 1 >= 63) 
        {
            printf ("No\n");
            continue;
        }
        if (bt[n - 1] > m) 
        {
            printf ("No\n");
            continue;
        }
        printf ("Yes\n");
        for (int i = 0; i <= n - 1; i++)
            printf ("%lld ", bt[i]);
        printf ("\n");
    }
    return 0;
}
```
  - 核心实现思想：先预处理出\(2\)的幂次方数组，通过判断\(n - 1\)与\(63\)以及\(bt[n - 1]\)与\(m\)的关系确定是否有解，有解则输出构造序列。

最优关键思路或技巧：通过分析异或运算性质，发现构造序列\(a_i = 2^{i - 1}\)能满足前缀异或和与后缀异或和均单调不减的条件，利用对数函数或预处理判断\(2^{n - 1}\)与\(m\)的关系来确定是否有解。

可拓展之处：此类题属于构造类型题目，类似套路为从简单样例入手，分析性质找出规律进行构造，再根据限制条件判断可行性。

推荐题目：
- [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)
- [P1085 不高兴的津津](https://www.luogu.com.cn/problem/P1085)
- [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)

个人心得摘录与总结：无。 

---
处理用时：22.30秒
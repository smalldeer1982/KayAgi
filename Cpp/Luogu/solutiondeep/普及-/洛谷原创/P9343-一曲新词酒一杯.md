# 题目信息

# 一曲新词酒一杯

## 题目背景

昨夜勾栏听曲，一壶浊酒，与明月凭栏相望，想起如今的处境，却没有怅然若失，仍然醉心于宴饮涵咏之乐，把酒临风之际，想起一种酒桌上的游戏，便和好友玩起来。

## 题目描述

酒桌上共有 $n$ 杯酒，标号为 $1\sim n$。桌旁有许多写有“酒”字的红色纸片。

接下来对这 $n$ 杯酒**依次**进行 $m$ 次操作。

操作共分为 $2$ 种：

- `1 x`：给 $x$ 号酒贴上 $1$ 张红纸。
- `2 x`：给除了 $x$ 号酒的其它 $n-1$ 杯酒分别贴上 $1$ 张红纸。

问在**至少**几次操作后，每杯酒上至少有一张红纸？


## 说明/提示

**【样例 1 解释】**

对于第一组数据：

- 第 $1$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $0$ 张红纸，$3$ 号酒有 $0$ 张红纸。
- 第 $2$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $1$ 张红纸，$3$ 号酒有 $0$ 张红纸。
- 第 $3$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $1$ 张红纸，$3$ 号酒有 $1$ 张红纸。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（20 points）：$o_i=1$。
-  Subtask 2（20 points）：$o_i=2$。
-  Subtask 3（20 points）：所有 $x_i$ 均相等。
-  Subtask 4（20 points）：$\sum n,\sum m\le 3\times 10^3$。
-  Subtask 5（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T,n,m,\sum n,\sum m\le 2\times 10^5$，$o_i\in \{1,2\}$，$1\le x_i\le n$。

## 样例 #1

### 输入

```
2
3 3
1 1
1 2
1 3
3 2
1 1
2 2```

### 输出

```
3
-1```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何高效判断在给定操作下，所有酒杯何时都能贴上红纸这一核心问题。多数题解通过分析不同操作组合情况来求解，少数使用线段树、珂朵莉树等数据结构优化。思路上，大多先明确能使所有酒杯都有红纸的几种情况，如对某酒杯既有操作1又有操作2 、所有酒杯都经历操作1 、有两次不同x的操作2等，然后在操作过程中记录相关信息以判断是否满足这些情况。算法要点在于如何简洁有效地记录和更新这些信息。解决难点在于优化时间复杂度，避免暴力模拟带来的过高复杂度。

所选的题解：
 - 作者：VitrelosTia (5星)
    - 关键亮点：思路清晰，通过开桶分别记录操作1和操作2中x的情况，简洁高效地判断各种满足条件的情况，代码实现直接明了。
    - 重点代码及核心思想：
```cpp
void solve() {
    int cnt1 = 0, cnt2 = 0;
    memset(vis1, false, sizeof vis1);
    memset(vis2, false, sizeof vis2);
    scanf ("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) scanf ("%d%d", &o[i], &x[i]);
    for (int i = 1; i <= m; i++) {
        if (o[i] == 1) {
            if (vis2[x[i]]) {
                cout << i << '\n';
                return;
            }
            if (!vis1[x[i]]) cnt1++, vis1[x[i]] = true;
        }
        if (o[i] == 2) {
            if (vis1[x[i]]) {
                cout << i << '\n';
                return;
            }
            if (!vis2[x[i]]) cnt2++, vis2[x[i]] = true;
        }
        if (cnt2 > 1 || cnt1 == n) {
            cout << i << '\n';
            return;
        }
    }
    puts("-1");
}
```
核心思想是遍历操作，利用桶数组`vis1`和`vis2`记录操作1和操作2中x的出现情况，`cnt1`和`cnt2`分别统计有效操作数，当满足某酒杯同时有操作1和操作2 、操作1覆盖所有酒杯或有两次不同x的操作2时，输出当前操作次数。

 - 作者：Jasoncwx (5星)
    - 关键亮点：使用`set`容器自动去重特性，简洁地实现对不同操作情况的记录和判断，代码简洁且逻辑清晰。
    - 重点代码及核心思想：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int T;cin>>T;
    while(T--){
        int n,m,ans=-1;
        cin>>n>>m;
        bool f=false;
        set<int>first,second;
        for(int i = 1; i <= m; i++){
            short op;cin>>op;
            int x;cin>>x;
            if(f)continue;
            if(op == 1)first.insert(x);
            else second.insert(x);
            if(first.size() == n || (first.find(x)!= first.end() && second.find(x)!= second.end()) || (second.size() > 1)){
                ans = i;
                f = true;
            }
        }
        cout<<ans<<endl;
    }
}
```
核心思想是利用`first`和`second`两个`set`分别记录操作1和操作2中的x，每次操作后判断`first`大小是否为n 、`first`和`second`是否都包含当前x 、`second`大小是否大于1，满足则输出当前操作次数。

 - 作者：masonpop (4星)
    - 关键亮点：清晰列举出所有能使所有酒杯都有红纸的情况，通过开桶简单维护相关信息，代码简洁易懂。
    - 重点代码及核心思想：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 10;
int t, n, m;
int one[maxn], two[maxn];
int main() {
    scanf("%d", &t);
    while (t--) {
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; i++)one[i] = two[i] = 0;
        int cnt = 0;
        int cnt2 = 0;
        int ans = 0;
        for (int i = 1; i <= m; i++) {
            int op, x;
            scanf("%d%d", &op, &x);
            if (ans)continue;
            if (op == 1) {
                if (!one[x])one[x] = 1, cnt++;
                if (two[x] || cnt == n) {
                    ans = i;
                }
            }
            else {
                if (!two[x])two[x] = 1, ++cnt2;
                if (cnt2 == 2 || one[x]) {
                    ans = i;
                }
            }
        }
        if (ans)printf("%d\n", ans);
        else puts("-1");
    }
    return 0;
}
```
核心思想是用`one`和`two`数组分别记录操作1和操作2对各酒杯的影响，`cnt`统计操作1覆盖的不同酒杯数，`cnt2`统计操作2的次数，操作过程中判断是否满足相应情况并输出操作次数。

最优关键思路或技巧：通过分析能使所有酒杯都有红纸的有限几种情况，利用简单的数据结构（如数组、`set`）记录操作信息，在操作过程中实时判断是否满足这些情况，避免了暴力模拟，有效降低时间复杂度。

可拓展之处：同类型题可涉及更多不同类型操作的组合判断问题，类似算法套路为分析所有可能达成目标的情况，用合适的数据结构记录和更新操作信息以快速判断。

推荐题目：
 - P1880 [NOI1995] 石子合并：涉及区间合并操作及最优值求解，与本题分析操作组合情况类似。
 - P3372 【模板】线段树 1：基础线段树题目，有助于巩固线段树在区间操作中的应用，本题部分解法涉及线段树优化。
 - P4145 上帝造题的七分钟 2 / 花神游历各国：结合了线段树与区间开方、求和等操作，可加深对区间操作优化的理解。

个人心得：无。 

---
处理用时：36.07秒
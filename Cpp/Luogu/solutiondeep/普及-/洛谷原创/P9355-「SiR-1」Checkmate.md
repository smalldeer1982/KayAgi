# 题目信息

# 「SiR-1」Checkmate

## 题目背景

这里本来有一串很长的背景，但是出题人觉得它实在太长了，所以就把它删掉了。

「来吧，游戏开始了。」

## 题目描述

有一个 $n$ 行 $m$ 列的棋盘。你要在这个棋盘上的所有格子**依次**放置一个棋子。

每当你放置一个棋子，你将会获得一定的分数，获得的分数为**放置时**你放置的这个棋子旁边的格子中没有放置棋子的格子的个数。这里「旁边」指的是上、下、左、右的相邻格子。

你想知道，在**按照最优策略决策放置棋子的顺序的情况下**，你最终得分总和的最大值。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（20 points）：$n, m \leq 3$，$T \leq 5$。
- Subtask 2（20 points）：$n, m \leq 4$，$T \leq 10$。
- Subtask 3（20 points）：$n=1$。
- Subtask 4（20 points）：$n=m$。
- Subtask 5（20 points）：无特殊限制。

对于所有测试数据，$1 \leq n, m \leq 10^8$，$1 \leq T \leq 10^5$。

## 样例 #1

### 输入

```
4
1 3
2 2
3 4
7 13```

### 输出

```
2
4
17
162```

# AI分析结果

• 综合分析与结论：
    - 这些题解的核心思路都是围绕计算相邻格子对数来确定最终得分。多数题解发现无论以何种顺序放置棋子，最终得分总和不变，一对相邻格子必定使最终答案增加1。
    - 算法要点在于通过不同方式推导出计算相邻格子对数的公式。如直接计算横向相邻对数$n(m - 1)$与纵向相邻对数$m(n - 1)$并求和，化简得到$2nm - n - m$。
    - 解决难点在于理解放置棋子顺序不影响总分这一特性，并找到合理的计算相邻格子对数的方法。
    - 部分题解通过分类讨论、打表找规律等方式得出结果，但相比直接计算相邻格子对数的方法，过程稍显繁琐。

  所选的题解：
  - **作者：zhlzt (赞：7)  星级：5星**
    - **关键亮点**：思路简洁清晰，直接点明答案就是相邻棋子的对数，通过简单推导得出公式$2nm - n - m$，代码实现简洁高效。
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int main(){
        int T;scanf("%d",&T);
        while(T--){
            long long n,m;
            scanf("%lld%lld",&n,&m);
            printf("%lld\n",2*n*m-n-m);
        }
        return 0;
    }
    ```
    - **核心实现思想**：读入数据，直接根据推导出的公式$2nm - n - m$计算并输出结果。
  - **作者：251Sec (赞：3)  星级：4星**
    - **关键亮点**：不仅给出了最终通用解法，还针对各个子任务分别阐述了思路，如爆搜、状压、找数列规律等，帮助理解问题的不同解决角度。
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    int T;
    ll n, m;
    int main() {
        scanf("%d", &T);
        while (T--) {
            scanf("%lld%lld", &n, &m);
            printf("%lld\n", 2 * n * m - n - m);
        }
        return 0;
    }   
    ```
    - **核心实现思想**：与zhlzt题解类似，读入数据后利用公式$2nm - n - m$计算并输出答案。
  - **作者：lailai0916 (赞：2)  星级：4星**
    - **关键亮点**：解题思路阐述清晰，先说明每对相邻格子对得分的影响，再分别计算横向和竖向相邻格子对数，最后得出总分公式，逻辑连贯。
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    using ll=long long;
    int main()
    {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int T;
        cin>>T;
        while(T--)
        {
            ll n,m;
            cin>>n>>m;
            cout<<n*m*2-n-m<<'\n';
        }
        return 0;
    }
    ```
    - **核心实现思想**：读入数据，依据$2nm - n - m$公式计算并输出最终得分。

• 最优关键思路或技巧：理解放置棋子顺序不影响最终得分总和这一特性，将问题转化为计算棋盘上相邻格子的对数，通过分别计算横向和纵向相邻格子对数并求和得出最终得分公式。

• 可拓展之处：此类题目属于棋盘类计数问题，类似算法套路可应用于其他涉及棋盘上元素放置并计算某种收益或统计数量的问题。例如，在一些棋盘上的路径计数、区域划分等问题中，也可通过分析相邻元素关系来简化计算。

• 相似知识点洛谷题目推荐：
    - [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：涉及简单的组合计数，与本题通过分析元素关系确定数量的思路类似。
    - [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：棋盘上路径规划问题，同样需要分析棋盘上不同位置之间的关系来求解。
    - [P2704 [NOI2001] 炮兵阵地](https://www.luogu.com.cn/problem/P2704)：棋盘上元素放置的限制与计数问题，需要通过合理的状态设计和分析元素间关系来解决，与本题思维方式有相似之处。

• 个人心得摘录与总结：
    - **printfmingren**：做题时联想到题目出处及相关番剧内容，考场时通过分类讨论得出结果，考后对式子进行优化统一。总结出做题时应多思考不同情况间的联系，优化解题过程。
    - **2011FYCCCTA**：时间紧张时通过打表找规律做出题目，赛后又从分类讨论角度深入分析。心得为考试时间紧张时可尝试打表找规律，赛后要深入思考题目本质，从不同角度解题加深理解。 

---
处理用时：28.67秒
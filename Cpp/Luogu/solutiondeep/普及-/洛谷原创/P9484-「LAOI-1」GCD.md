# 题目信息

# 「LAOI-1」GCD

## 题目描述

一张图有 $n$ 个节点，编号为 $1,2,3,\dots,n$。其中 $i$ 号节点会向 $j$ 号节点连一条边权为 $|i-j|$ 的无向边，当且仅当 $\gcd(i,j)=i,\operatorname{lcm}(i,j)=j$ 时连边。现询问 $q$ 次，每次询问求 $x$ 到 $y$ 的最短路径。

## 说明/提示

注意时空限制，本题不捆绑。

对于 $40\%$ 的数据，$T,n,q\le100$;

对于 $100\%$ 的数据，$1\le T\le10^6$，$1\le n,q\le10^6$，$1\le x,y\le n$，$1\le \sum n,\sum q\le10^6$。

**请使用更快的 IO 方式**。

updata on 2024/8/8：

时限上调到 1000ms。/yun

## 样例 #1

### 输入

```
1
6 4
1 4
3 5
2 5
2 4```

### 输出

```
3
6
5
2```

# AI分析结果

### 综合分析与结论
两题解思路相近，均先分析出图中边的连接条件为两数存在倍数关系，即\(\gcd(i,j)=i,\ \text{lcm}(i,j)=j\)等价于\(i|j\)。进而得出从\(x\)到\(y\)的最短路径是将\(x\)，\(y\)都跳到\(\gcd(x,y)\)处，答案为\(x + y - 2\gcd(x,y)\)。
 - **思路方面**：两者都通过分析路径走向来证明最优解，“Coffins”题解从\(x\)向\(y\)走的两种情况（倍数和因数）进行分析；“sto_5k_orz”题解则从\(\gcd\)定义出发，对比到不同公约数的路径长度，并证明\(i + j - 2\gcd(i,j)\)比\(2\text{lcm}(i,j) - i - j\)更优。
 - **算法要点**：核心是快速计算\(\gcd\)，并利用其计算最短路径。
 - **解决难点**：难点在于证明\(x + y - 2\gcd(x,y)\)是最短路径，两题解均通过合理分析不同情况完成证明。

### 所选的题解
 - **作者：Coffins (5星)**
    - **关键亮点**：思路清晰，先点明条件等价关系，再通过对\(x\)往\(y\)走的两种情况进行分析，简洁明了地证明了答案公式。代码简洁，使用了高效的输入输出优化（`ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);`），并自定义了辗转相除法求\(\gcd\)。
    - **个人心得**：作者提到赛时因输入被卡，提示在做题时要重视输入输出方式对程序运行的影响。
    - **核心代码片段**：
```cpp
int gcd(int a,int b)
{
    while(b^=a^=b^=a%=b);
    return a;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>t;
    while(t--)
    {
        cin>>n>>q;
        for(int i=1;i<=q;i++)
        {
            cin>>x>>y;
            cout<<x+y-2*gcd(x,y)<<'\n';
        }
    } 
    return 0;
}
```
核心实现思想：自定义的\(\gcd\)函数通过辗转相除法不断更新\(a\)和\(b\)的值，直到\(b\)为\(0\)，此时\(a\)即为最大公约数。主函数中通过循环读入数据，并根据公式计算输出最短路径。

 - **作者：sto_5k_orz (4星)**
    - **关键亮点**：从\(\gcd\)定义出发，通过不等式证明了\(i + j - 2\gcd(i,j)\)是最优解，逻辑严谨。使用了自定义的快速输入输出函数，优化了输入输出效率。
    - **核心代码片段**：
```cpp
namespace SlowIO{
    I int read() {
        int x = 0, f = 1; char ch = gc();
        W(ch < '0' || ch > '9') {if(ch == '-') f = -f; ch = gc();}
        W(ch >= '0' && ch <= '9') x = x * 10 + (ch ^ 48), ch = gc();
        return x * f;
    }
    I void Read(int &x) {x = read();}
    I void Read(int &x, int &y) {Read(x), Read(y);}
    I void write(int x) {
        if(x < 0) pc('-'), x = -x;
        if(x > 9) write(x / 10);
        pc(x % 10 + '0');
    }
    I void writeln(int x) {write(x); pc('\n');}
} using namespace SlowIO;
signed main() {
    int t; Read(t);
    while(t--) {
        int n, q; Read(n, q); 
        while(q--) {
            int a, b; Read(a, b); int g = __gcd(a, b);
            writeln(a + b - 2 * g);
        }
    }
    return 0;
}
```
核心实现思想：自定义的`SlowIO`命名空间内实现了快速读入和输出函数，`read`函数通过字符读取和处理转换为整数，`write`函数将整数按位输出。主函数中通过调用这些函数读入数据，并利用公式计算输出最短路径。

### 最优关键思路或技巧
 - **思维方式**：通过分析图中边的连接条件，将问题转化为对数字间倍数关系及路径走向的分析，从而找到最优路径的规律。
 - **代码实现技巧**：重视输入输出优化，如使用`ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);`或自定义快速输入输出函数，以满足题目对时间复杂度的要求。

### 可拓展之处
此类题目属于图论与数论结合的问题，通常需要分析图中节点连接条件与数论性质的关系，进而找到最优解。类似套路是先确定图的结构，再利用数论知识（如\(\gcd\)、\(\text{lcm}\)等）优化路径计算。

### 洛谷相似题目推荐
 - **P1029 最大公约数和最小公倍数问题**：通过\(\gcd\)和\(\text{lcm}\)的关系求解满足条件的数对数量，考察数论知识运用。
 - **P2525 [HAOI2011]向量**：结合数论与向量知识，通过\(\gcd\)分析向量的线性组合，与本题有相似的数论分析思路。
 - **P1572 [NOI2016] 循环之美**：涉及数论中的分数循环节、\(\gcd\)等知识，与本题类似之处在于利用数论性质解决问题。 

---
处理用时：29.33秒
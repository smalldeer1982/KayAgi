# 题目信息

# 「SFCOI-3」进行一个拆的解

## 题目背景

**公告：Subtask 0 数据有误，现已更改。**

------------

三岁的小明非常不喜欢完整的东西，他甚至连序列都想要拆掉。

## 题目描述

给定序列 $a_1\dots a_n$，小明想要把它拆成两个子段 $[1, l][l + 1, n](1 \leq l \lt n)$，即 $a_1\dots a_l$ 和 $a_{l+1}\dots a_n$。

由于小明强迫症很严重，他不希望对于这两个子段，其中一个是另一个的 **子序列**，换句话说，他不希望其中一个子段可以通过删掉若干（可能为 $0$）个元素变成另一个。

在父母出门的时候，小明终于找到了把序列拆开的机会！所以，他想知道，是否存在一种拆解的方式满足：任意一个子段都不是另一个子段的子序列。

## 说明/提示

### 样例解释

对于第一个序列，所有拆分方式有：

- $\lbrace 1 \rbrace,\lbrace 2,1,2,1 \rbrace$。
- $\lbrace 1,2 \rbrace,\lbrace 1,2,1 \rbrace$。
- $\lbrace 1,2,1 \rbrace,\lbrace 2,1 \rbrace$。
- $\lbrace 1,2,1,2 \rbrace,\lbrace 1 \rbrace$。

从任何地方拆开都是不合法的——较短的那个序列都是另一个序列的子序列。

对于第二个序列，其中一种合理的拆分方式为 
$\lbrace 1,2,1,1,2 \rbrace,\lbrace 1,0 \rbrace$。

### 数据规模与约定

**本题采用捆绑测试**。

- Subtask 0（15 points）：$a_i = 0$。
- Subtask 1（15 points）：$n = 10$，保证数据随机生成。
- Subtask 2（30 points）：$n$ 为偶数。
- Subtask 3（40 points）：无特殊限制。

对于所有数据，$1\leq T \leq 10^5$，$2 \leq n \leq 10^5$，$1 \leq \sum n \leq 10^6$，$0 \leq a_i \leq 100$。

## 样例 #1

### 输入

```
2
5 1 2 1 2 1
7 1 2 1 1 2 1 0```

### 输出

```
NO
YES```

# AI分析结果

• 综合分析与结论：
    - 多数题解思路围绕按序列长度n的奇偶性分类讨论。偶数时，重点分析从中间拆分的两段序列是否相同；奇数时，考虑中间元素归属不同段的两种拆分情况，通过双指针判断一段是否为另一段子序列。
    - 算法要点在于利用子序列性质，若短序列是长序列子序列，移动拆分位置不会改变此关系。通过减少需判断的拆分位置，将时间复杂度降至O(n)。
    - 解决难点在于证明仅判断特定拆分位置（偶数时中间位置，奇数时中间元素分属两段的位置）就能确定整个序列是否存在合法拆分。

以下为≥4星题解：
  - **作者：Rei_Sen (5星)**
    - **关键亮点**：思路清晰，详细证明不同奇偶性下不存在合法拆分的序列形式，代码实现与证明紧密结合，逻辑严谨。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
bool check1()
{
    int jbegin = n / 2 + 1;
    for(int i = 1,j = jbegin; i <= n / 2; ++i, ++j) {
        if(a[i]!=a[j])
            return false;
    }
    return a[1] == a[n];
}

bool check2()
{
    int jbegin = n / 2 + 2;
    for(int i = 1, j = jbegin; i <= n / 2; ++i, ++j) {
        if(a[i]!= a[j])
            return false;
    }
    return true;
}

void solve()
{
    scanf("%d",&n);
    for(int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    if(!(n & 1)) {
        int jbegin = n / 2 + 1;
        for(int i = 1, j = jbegin; i <= n / 2; ++i,++j) {
            if(a[i]!= a[j]) {
                printf("YES\n");
                return;
            }
        }
        printf("NO\n");
    } else {
        if(check1() || check2()) {
            printf("NO\n");
        } else {
            printf("YES\n");
        }
    }
}
```
    - **核心实现思想**：`check1`和`check2`函数分别检查奇数时两种特殊拆分情况是否满足不合法条件（一段是另一段子序列）。`solve`函数根据n的奇偶性调用相应检查函数并输出结果。

  - **作者：_Spectator_ (4星)**
    - **关键亮点**：思路阐述清晰，先给出不同奇偶性下序列不合法拆分的形式，再用双指针代码实现判断，代码简洁明了。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
int main()
{
    for(cin>>T;T-->0;)
    {
        cin>>n;
        for(int i=1;i<=n;i++)cin>>a[i];
        if(n%2==1)//n为奇数的情况
        {
            int p=1,q=n/2+1;//a[1...k]与a[k...n]完全相同
            while(q<=n&&a[p]==a[q])p++,q++;
            if(q>n)cout<<"NO\n";
            else{
                p=1,q=n/2+2;//a[1...k-1]与a[k+1...n]完全相同
                while(q<=n&&a[p]==a[q])p++,q++;
                if(q>n)cout<<"NO\n";
                else cout<<"YES\n";
            }
        }
        else{//n为偶数的情况
            int p=1,q=n/2+1;//a[1...n/2]与a[n/2+1...n]完全相同
            while(q<=n&&a[p]==a[q])p++,q++;
            if(q>n)cout<<"NO\n";
            else cout<<"YES\n";
        }
    }
    return 0;
}
```
    - **核心实现思想**：根据n的奇偶性，通过双指针分别判断奇数时两种及偶数时一种拆分情况下两段序列是否完全相同（即一段是否为另一段子序列），并输出结果。

  - **作者：Exp10re (4星)**
    - **关键亮点**：先证明关键结论，即不同长度关系下断点移动对结果的影响，从而得出最优拆分位置，思路具有逻辑性，代码实现基于结论清晰明了。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
bool check(int n,int l1,int l2)//双指针判断是否为子串 
{
    for(;l2<=n;l2++,l1++)
    {
        if(a[l1]!=a[l2])
        {
            return false;
        }
    }
    return true;
}
void work()
{
    bool flaga,flagb;
    int n,i;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    if(n&1)
    {
        flaga=(check(n-1,1,n/2+1)||check(n,1,n/2+2));//断点为n/2之后 
        flagb=(check(n,1,n/2+2)||check(n,2,n/2+2));//断点为n/2+1之后 
        if(flaga&&flagb)
        {
            printf("NO\n");
        }
        else
        {
            printf("YES\n");
        }
    }
    else
    {
        if(check(n,1,n/2+1))
        {
            printf("NO\n");
        }
        else
        {
            printf("YES\n");
        }
    }
    return;
}
```
    - **核心实现思想**：`check`函数用双指针判断一段是否为另一段子序列。`work`函数根据n的奇偶性，调用`check`函数判断相应拆分位置情况并输出结果。

• 最优关键思路或技巧：利用子序列性质，按n的奇偶性分类讨论，仅判断特定拆分位置（偶数中间位置，奇数中间元素分属两段的位置），减少判断次数，优化时间复杂度至O(n)。

• 可拓展思路：此类题可拓展到更多序列划分条件或不同子序列定义的情况，关键是找到具有代表性的划分位置，利用序列性质减少判断范围。

• 相似知识点洛谷题目：
    - P1101 单词方阵，考察二维字符序列处理，与本题序列处理思路有相似处。
    - P1966 火柴排队，涉及序列元素匹配和顺序调整，与本题判断序列关系有类似思维。
    - P3958 奶酪，通过判断空间位置关系类似本题判断序列关系，锻炼逻辑判断能力。 

---
处理用时：39.70秒
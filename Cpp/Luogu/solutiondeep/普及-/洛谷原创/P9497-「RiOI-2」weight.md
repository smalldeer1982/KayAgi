# 题目信息

# 「RiOI-2」weight

## 题目背景

在小树林间坐落着一个幻想的城堡。这里是 E 国的领地，而小 E，则是 E 国之王。

树木，是 E 国抵挡袭击的法宝。树木越高，越能蒙蔽敌人的视线。

可是，随着自然条件的退化，小 E 却不知怎么处理。怎么办呢？

## 题目描述

给定一个 $n$ 行 $n$ 列 的矩阵 $a$。

有 $q$ 组询问，每次给定一个 $v$，请将矩阵每一行任意重排（可以不重排），最大化**最大值不小于** $v$（也就是说，至少有一个不小于 $v$ 的数）的列数。请输出这个列数。

询问之间相互独立。换言之，每次询问前可以重新排列。


## 说明/提示

### 样例解释

原矩阵为 $\begin{bmatrix}9&9&8\\2&4&4\\3&5&3\end{bmatrix}$。

对于第一次询问，每一列的最大值 $9,9,8$ 均不小于 $v=5$，所以每一列都符合条件，答案为 $3$。显然无论怎么重排都不可能超过 $3$ 列（因为总共只有 $3$ 列），所以答案为 $3$。

### 数据规模与约定

**本题开启捆绑测试。**

| $\text{Subtask}$ | 分值 | $n \leq$ | $q \leq$ |
| :--------------: | :--: | :------: | :------: |
| $0$ | $10$ | $3$ | $10$ |
| $1$ | $40$ | $100$ | $10^3$ |
| $2$ | $50$ | $10^3$ | $5\times 10^5$ |

对于所有数据，$1 \leq n \leq 10^3$，$1 \leq q \leq 5\times 10^5$，$1 \leq a_{i,j}, v \leq 10^9$。

## 样例 #1

### 输入

```
3 3
9 9 8
2 4 4
3 5 3
5
9
10```

### 输出

```
3
2
0```

# AI分析结果

• 综合分析与结论：
    - 思路方面：所有题解都意识到由于每行可任意重排，核心是统计矩阵中大于等于 \( v \) 的数的个数，并据此确定满足条件的列数。
    - 算法要点：将矩阵所有元素存入一维数组，排序后通过二分查找确定大于等于 \( v \) 的数的个数，答案为该个数与 \( n \) 的较小值。部分题解还考虑了一些边界情况的优化。
    - 解决难点：主要难点在于优化时间复杂度，避免暴力枚举导致超时。不同题解通过排序结合二分查找等方式优化，将时间复杂度从 \( O(n^{2}q) \) 降低到 \( O((n^{2}+q)\log n) \) 等更优级别。

    - 综合质量来看，include13_fAKe、Meny__love、251Sec 的题解相对较好，思路清晰，代码实现简洁明了，对算法优化阐述较清楚，可评为4星。

  - include13_fAKe（4星）
    - 关键亮点：详细分析了不同子任务的解法，从暴力枚举到利用排序和二分优化，思路清晰，逐步递进。
    - 个人心得：提到从小到大排序实现较麻烦，暗示从大到小排序在实现上可能更简洁。
    - 核心代码（solve函数）：
```cpp
void solve(int v){
    int l=n*(n-1)+1;
    int r=n*n;
    if(v<=a[l]){
        printf("%d\n",n);
        return;
    }
    if(v>a[r]){
        printf("0\n");
        return;
    }
    int mid=l+r>>1;
    while(l<r){
        if(v<=a[mid])    r=mid;
        else    l=mid+1;
        mid=l+r>>1;
    }
    printf("%d\n",n*n+1-l);
    return;
}
```
核心思想：先判断 \( v \) 与数组边界值的关系，快速得出答案。否则二分查找第一个大于等于 \( v \) 的位置，计算满足条件的列数。

  - Meny__love（4星）
    - 关键亮点：思路简洁直接，明确指出统计大于查询数 \( v \) 的数的个数就是答案，通过排序和二分查找实现，代码简洁易懂。
    - 核心代码（部分）：
```cpp
for(int i=1;i<=q;i++){
    int x;
    scanf("%d",&x);
    int mid=lower_bound(a+1,a+len+1,x)-a;
    int mid1=upper_bound(a+1,a+len+1,x)-a;
    if(a[mid]==x) printf("%d\n",min(len-mid+1,n));
    else if(a[mid1]>x) printf("%d\n",min(len-mid1+1,n));
    else printf("0\n");
}
```
核心思想：对每次询问，利用STL的二分查找函数 `lower_bound` 和 `upper_bound` 确定 \( v \) 在数组中的位置，进而得出满足条件的列数。

  - 251Sec（4星）
    - 关键亮点：对贪心策略的正确性进行了详细证明，逻辑严谨。代码简洁高效，直接利用排序和二分查找计算答案。
    - 核心代码（main函数部分）：
```cpp
scanf("%d%d", &n, &q);
for (int i = 1; i <= n * n; i++) {
    scanf("%d", w + i);
}
sort(w + 1, w + n * n + 1);
while (q--) {
    int x;
    scanf("%d", x);
    printf("%lld\n", min(1ll * n, 1ll * n * n - (lower_bound(w + 1, w + n * n + 1, x) - w) + 1));
}
```
核心思想：先读入矩阵所有元素并排序，每次询问时通过二分查找确定大于等于 \( x \) 的数的个数，与 \( n \) 取较小值输出。

• 最优关键思路或技巧：
    - **数据结构**：使用一维数组存储矩阵所有元素，简化数据处理。
    - **算法优化**：对一维数组排序后，利用二分查找确定大于等于 \( v \) 的数的个数，将时间复杂度从暴力的 \( O(n^{2}q) \) 优化到 \( O((n^{2}+q)\log n) \)。
    - **思维方式**：认识到每行可重排的情况下，问题本质是统计大于等于 \( v \) 的数的个数，并证明贪心策略的正确性。

• 可拓展之处：
此类题目属于矩阵操作与查询类型，类似套路是将矩阵信息整合到一维结构，利用排序和二分查找优化查询。同类型题可能会在矩阵操作、查询条件等方面变化，如改变重排规则、查询条件变为满足特定范围的数等。

• 推荐洛谷题目：
    - P1873 砍树：涉及排序和二分查找，通过二分确定满足条件的数值。
    - P2678 [NOIP2015 普及组] 跳石头：同样利用二分查找解决最优解问题，与本题优化思路类似。
    - P3853 [TJOI2007] 路标设置：也是二分查找在实际场景中的应用，锻炼二分优化问题的能力。

• 个人心得摘录与总结：
include13_fAKe提到从小到大排序实现较麻烦，总结出排序方式可能影响代码实现的复杂度，暗示从大到小排序在某些场景下更具优势，提醒在实现算法时要考虑数据处理方式对代码的影响。 

---
处理用时：31.16秒
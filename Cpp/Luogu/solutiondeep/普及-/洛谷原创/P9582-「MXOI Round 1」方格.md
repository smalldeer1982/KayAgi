# 题目信息

# 「MXOI Round 1」方格

## 题目描述

小 C 和方格是好朋友。

小 C 有一个 $n$ 行 $m$ 列的方格图，每个方格中都有一个数字，其中第 $i$ 行第 $j$ 列的方格中的数字为 $a_{i,j}$。

我们定义，在这个方格图中，两个不同的方格不相邻，当且仅当这两个方格**没有公共边**。

小 C 认为，两个不同的方格互为好朋友，当且仅当这两个方格**不相邻**且**这两个方格中的数字相同**。

小 C 想让你帮忙求出，所有方格的好朋友的数量之和是多少。

## 说明/提示

#### 【样例解释 #1】

第 $1$ 行第 $1$ 列的方格共有 $3$ 个好朋友，第 $1$ 行第 $2$ 列的方格共有 $2$ 个好朋友，第 $1$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $1$ 行第 $4$ 列的方格共有 $0$ 个好朋友；

第 $2$ 行第 $1$ 列的方格共有 $1$ 个好朋友，第 $2$ 行第 $2$ 列的方格共有 $2$ 个好朋友，第 $2$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $2$ 行第 $4$ 列的方格共有 $1$ 个好朋友；

第 $3$ 行第 $1$ 列的方格共有 $1$ 个好朋友，第 $3$ 行第 $2$ 列的方格共有 $3$ 个好朋友，第 $3$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $3$ 行第 $4$ 列的方格共有 $4$ 个好朋友；

所有方格的好朋友数量之和为 $20$。

#### 【样例 #2】

见附加文件中的 `square/square2.in` 与 `square/square2.ans`。

该样例满足测试点 $1$ 的限制。

#### 【样例 #3】

见附加文件中的 `square/square3.in` 与 `square/square3.ans`。

该样例满足测试点 $4$ 的限制。

#### 【样例 #4】

见附加文件中的 `square/square4.in` 与 `square/square4.ans`。

该样例满足测试点 $6$ 的限制。

#### 【样例 #5】

见附加文件中的 `square/square5.in` 与 `square/square5.ans`。

该样例满足测试点 $10$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le n,m \le 2000$，$1 \le a_{i,j} \le 9$。

|测试点编号|$n,m \le$|$a_{i,j} \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim3$|$80$|$9$|否|
|$4\sim5$|$2000$|$1$|否|
|$6\sim7$|$2000$|$9$|是|
|$8\sim10$|$2000$|$9$|否|

特殊性质：保证任意两个相邻的方格中的数不相等。

## 样例 #1

### 输入

```
3 4
1 1 4 5
2 1 2 3
3 1 4 1```

### 输出

```
20```

# AI分析结果

• 综合分析与结论：这些题解思路大致相同，均利用数据范围 \(1 \leq a_{i,j} \leq 9\) 的特点，采用桶排序思想统计每个数字出现次数。先计算所有相同数字方格组合数（不考虑相邻情况），再减去相邻且数字相同的不合法情况。算法要点在于桶的使用和对相邻方格的判断。解决难点在于如何高效统计并排除不合法情况。
- 作者Coffee_zzz（5星）
  - 关键亮点：对不同测试点分别分析，针对特殊数据范围和性质给出不同优化思路，逻辑清晰。
  - 个人心得：强调不开 `long long` 见祖宗。
  - 核心代码片段：
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2005,A=15;
int n,m,a[N][N],c[A];
ll ans;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            c[a[i][j]]++;
        }
    }
    for(int i=1;i<=9;i++) ans=ans+1ll*c[i]*(c[i]-1);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(a[i][j]==a[i-1][j]) ans--;
            if(a[i][j]==a[i][j-1]) ans--;
            if(a[i][j]==a[i+1][j]) ans--;
            if(a[i][j]==a[i][j+1]) ans--;
        }
    }
    cout<<ans;
    return 0;
}
```
  - 核心实现思想：先读入数据并用桶 `c` 统计每个数字出现次数，计算所有数字组合数累加至 `ans`，再遍历方格图，对每个方格判断其相邻方格数字是否相同，若相同则 `ans` 减1。
- 作者zzx114514（4星）
  - 关键亮点：解题思路表述清晰，代码简洁明了，直接按常规思路实现，易于理解。
  - 核心代码片段：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,a[2005][2005],t[10],ans; 
int main()
{
    cin>>n>>m;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        {
            cin>>a[i][j];
            t[a[i][j]]++;//统计数字出现个数 
        }
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        {
            ans+=t[a[i][j]]-1;//开始假设所有相同元素均不相邻 
            if (i>1 && a[i-1][j]==a[i][j]) ans--;
            if (i<n && a[i+1][j]==a[i][j]) ans--;
            if (j>1 && a[i][j-1]==a[i][j]) ans--;
            if (j<m && a[i][j+1]==a[i][j]) ans--;
            //如果相邻且相同则将ans-1 
        }
    cout<<ans;
    return 0;
}
```
  - 核心实现思想：读入数据时用桶 `t` 统计各数字出现次数，遍历方格图，对每个方格，先将其相同数字个数减1（排除自身）累加到 `ans`，再判断相邻方格数字是否相同，若相同则 `ans` 减1。
- 作者_JF_（4星）
  - 关键亮点：结合排列组合知识，简洁阐述思路，代码实现简洁高效。
  - 核心代码片段：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =5001;
#define int long long 
int a[N][N],t[N],ans;
signed main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)    
            scanf("%lld",&a[i][j]),t[a[i][j]]++;
    for(int i=1;i<=9;i++)
        ans+=t[i]*(t[i]-1);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            if(a[i][j]==a[i-1][j])    ans--;
            if(a[i][j]==a[i][j-1])    ans--;
            if(a[i][j]==a[i+1][j])    ans--;
            if(a[i][j]==a[i][j+1])    ans--;
        }
    cout<<ans<<endl;
    return 0;
}
```
  - 核心实现思想：读入数据同时用桶 `t` 统计各数字出现次数，利用排列组合计算每种数字的最大组合数累加到 `ans`，遍历方格图，判断每个方格相邻方格数字是否相同，若相同则 `ans` 减1。

• 最优关键思路或技巧：利用数据范围小的特点使用桶排序思想，先计算所有相同数字组合情况，再减去相邻造成的不合法情况，减少时间复杂度。
• 可拓展之处：同类型题常利用数据范围特点，采用类似桶排思想统计元素出现次数，再结合题目特殊条件进行筛选或计算。
• 相似知识点洛谷题目：
  - P1131 海战：同样考察对二维数组元素的统计和判断，结合特殊条件进行计数。
  - P1909 买铅笔：根据数据范围，对不同方案进行统计计算，选择最优方案，与本题利用数据范围优化思路类似。
  - P1031 均分纸牌：通过对数组元素的统计和调整，达到特定目标，与本题统计和调整的思路有相似之处。
• 个人心得摘录与总结：多数题解强调不开 `long long` 会导致答案错误，提醒在处理较大数据时注意数据类型范围。 

---
处理用时：33.60秒
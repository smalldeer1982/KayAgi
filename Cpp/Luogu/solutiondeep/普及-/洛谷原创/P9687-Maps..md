# 题目信息

# Maps.

## 题目描述

小 Y 希望得到一幅地图，这份地图有些与众不同。

这份地图是一幅长为 $n$ 个单位，宽为一个单位的网格图，每个网格必须被涂鸦成白色（$0$）或者黑色（$1$）。

你希望满足小 Y 的愿望送给他一幅这样的地图，但是这时小 Y 又提出了两点要求：

- 对于每个不在网格图两端的白色格子，恰好有 $p$ 个满足它的左右两个格子都被涂鸦成黑色。
- 在满足上述所有条件的情况下，这幅地图从左到右的字符构成的字符串的字典序最小。

你心想，这些要求也是小菜一碟，于是开始了你的创作。

## 说明/提示

#### 【样例解释 #1】

对于第一组数据：只有位于第 $4$ 个字符上的数，满足本身是 $0$，不在地图边缘且周围两个都是 $1$，因此符合条件。可以证明这是满足条件的字典序最小的方案。

对于第三组数据：可以证明没有任何一个解满足长度为 $5$ 且有 $3$ 个数本身是 $0$，不在地图边缘且周围两个字符都是 $1$。

#### 【数据范围】

对于所有测试数据，满足 $1 \le T \le 100$，$1 \le n,p \le 10^5$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n,p \le$ |
| :-----------: | :-----------: |
| $1 \sim 3$ | $10$ |
| $4 \sim 5$ | $10^3$ |
| $6\sim 10$ | $10^5$ |

## 样例 #1

### 输入

```
5
5 1
3 1
5 3
5 4
5 5```

### 输出

```
00101
101
-1
-1
-1```

# AI分析结果

### 综合分析与结论
这些题解思路大致相同，均先判断无解情况，即当 \(n < 2p + 1\) 时输出 \(-1\) ，因为满足条件至少需要 \(2p + 1\) 个字符。对于有解情况，为使字典序最小，前面放置 \(n - (2p + 1)\) 个 \(0\) ，后面拼接形如 \(1010...101\) （共 \(2p + 1\) 个字符）的字符串。
算法要点在于理解条件所需的最小长度以及字典序最小的构造方式。解决难点主要是想出满足条件的字符串结构和字典序最小的放置策略。

多数题解质量相近，以下按质量评分：
1. **作者：bryce (赞：12)**
    - **星级**：4星
    - **关键亮点**：思路清晰简洁，先明确判断 \(-1\) 的情况，再阐述有解时的构造方式，代码简洁明了。
    - **核心代码**：
```cpp
if (2 * p + 1 > n){
    cout << -1 << endl;
    continue;
}
for (int i = 1; i <= n - (2 * p + 1); i++) cout << 0;
for (int i = 1; i <= p; i++) cout << 10;
cout << 1 << endl;
```
    - **核心思想**：先判断 \(n\) 是否小于满足条件所需的最小长度 \(2p + 1\) ，若小于则输出 \(-1\) ；否则先输出 \(n - (2p + 1)\) 个 \(0\) ，再输出 \(p\) 组 \(10\) ，最后输出一个 \(1\) 。
2. **作者：Lovely_Elaina (赞：9)**
    - **星级**：4星
    - **关键亮点**：将问题看作若干个 `101` 串首尾拼接，形象易懂，代码逻辑清晰，利用 `ios::sync_with_stdio(0);` 和 `cin.tie(NULL);` 加快输入输出。
    - **核心代码**：
```cpp
int len = 1 + 2 * p;
if(len > n){
    cout << -1 << endl;
    continue;
}
for(int i = n-len; i > 0; i--)
    cout << 0;
for(int i = 1; i <= p; i++)
    cout << "10";
cout << 1 << endl;
```
    - **核心思想**：计算出拼接后字符串长度 `len` ，若大于 \(n\) 则无解输出 \(-1\) ；否则先输出 \(n - len\) 个 \(0\) ，再输出 \(p\) 组 `10` ，最后输出 \(1\) 。
3. **作者：MarsTraveller (赞：6)**
    - **星级**：4星
    - **关键亮点**：详细分析题意，分无法构造和构造最小字符串两方面阐述，逻辑严谨，代码注释详细。
    - **核心代码**：
```cpp
if(n < 2*p+1) {
    printf("-1\n");
    continue;  
}
for(big i = 1;i <= n-(2*p+1);i++) {
    cout << 0;
}
cout << 1;
for(big i = 1;i <= p;i++) {
    cout << "01";
}
cout << '\n';
```
    - **核心思想**：判断 \(n\) 是否小于 \(2p + 1\) ，若小于则输出 \(-1\) ；否则先输出 \(n - (2p + 1)\) 个 \(0\) ，再输出一个 \(1\) 及 \(p\) 组 `01` 。

### 最优关键思路或技巧
1. **思维方式**：通过列举 \(p\) 较小时满足条件的字符串形式（如 \(p = 1\) 时为 `101` ， \(p = 2\) 时为 `10101` ），总结出通用的字符串结构，即长度为 \(2p + 1\) 且 `1` 和 `0` 交替的字符串，这是解决本题的关键。
2. **代码实现技巧**：利用循环分别处理前面补 \(0\) 和后面构造特定字符串的部分，使代码结构清晰。同时，提前计算满足条件的最小长度并进行判断，避免无效计算。

### 可拓展之处
同类型题通常围绕字符串构造，给定特定条件要求构造出满足条件且满足某种最优性（如字典序最小、长度最短等）的字符串。类似算法套路是先分析条件找出满足条件的最小结构，再根据最优性要求进行整体构造，如先确定关键子串，再考虑如何放置使整体满足条件。

### 相似知识点洛谷题目
1. **P1036 [NOIP2002 普及组] 选数**：涉及数的组合构造，与本题构造字符串思路类似，需根据条件筛选出满足要求的组合。
2. **P1157 组合的输出**：同样是关于组合的构造输出，要求按照字典序输出组合，与本题字典序相关要求类似。
3. **P1219 [USACO1.5] 八皇后 Checker Challenge**：经典的棋盘布局构造问题，需要满足特定的放置规则，和本题构造满足条件字符串思路一致。

### 个人心得摘录与总结
暂无个人心得相关内容。 

---
处理用时：30.09秒
# 题目信息

# [NOIP 2002 普及组] 过河卒

## 题目描述

棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)

现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。

**【题目来源】**

NOIP 2002 普及组第四题

## 样例 #1

### 输入

```
6 6 3 3
```

### 输出

```
6
```

# AI分析结果

### 综合分析与结论

本题是一个典型的动态规划问题，核心思路是通过状态转移方程计算卒从起点到终点的路径数。难点在于如何处理马的控制点，以及如何优化空间复杂度。大多数题解采用了二维数组进行状态转移，部分题解进一步优化为一维数组或滚动数组，减少了空间复杂度。整体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，而有些则存在冗余或不够优化的地方。

### 所选高星题解

#### 1. 作者：Chiaro (赞：3918)
- **星级**：5星
- **关键亮点**：
  - 详细解释了动态规划的状态转移方程，并提供了滚动数组优化和一维数组优化的思路。
  - 代码简洁且高效，处理了马的控制点，并避免了数组越界问题。
  - 提供了多种优化思路，适合初学者和进阶者学习。
- **个人心得**：作者通过逐步优化的方式，展示了如何从基础解法逐步提升到高效解法，体现了对问题的深入理解。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;

const int fx[] = {0, -2, -1, 1, 2, 2, 1, -1, -2};
const int fy[] = {0, 1, 2, 2, 1, -1, -2, -2, -1};

int bx, by, mx, my;
ll f[2][40];    //第一维大小为 2 就好
bool s[40][40];

int main(){
    scanf("%d%d%d%d", &bx, &by, &mx, &my);
    bx += 2; by += 2; mx += 2; my += 2;
    f[1][2] = 1; //初始化
    s[mx][my] = 1;
    for(int i = 1; i <= 8; i++) s[mx + fx[i]][my + fy[i]] = 1;
    for(int i = 2; i <= bx; i++){
        for(int j = 2; j <= by; j++){
            if(s[i][j]){
                f[i & 1][j] = 0; //被马拦住了记住清零
                continue;
            }
            f[i & 1][j] = f[(i - 1) & 1][j] + f[i & 1][j - 1]; 
            //新的状态转移方程
        }
    }
    printf("%lld\n", f[bx & 1][by]);
    //输出的时候第一维也要按位与一下
    return 0;
} 
```

#### 2. 作者：kradcigam (赞：455)
- **星级**：4星
- **关键亮点**：
  - 使用了标数法的思路，清晰解释了状态转移方程。
  - 代码简洁，处理了马的控制点，并提供了优化为一维数组的思路。
- **个人心得**：作者通过简单的例子解释了标数法的应用，使得动态规划的思路更加直观。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a,b,n,m,x[23][23],ma[23][23];
void work(long long x,long long y){
    ma[x][y]=1;
    ma[x-1][y-2]=1;
    ma[x-2][y-1]=1;
    ma[x-2][y+1]=1;
    ma[x-1][y+2]=1;
    ma[x+1][y-2]=1;
    ma[x+2][y-1]=1;
    ma[x+2][y+1]=1;
    ma[x+1][y+2]=1;
}
int main(){
    scanf("%lld %lld %lld %lld",&n,&m,&a,&b);
    a++;
    b++;
    n++;
    m++;
    work(a,b);
    x[1][1]=1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
        	if(i==1&&j==1)continue;
        	if(ma[i][j]==0)x[i][j]=x[i-1][j]+x[i][j-1];
        }
    }
    printf("%lld",x[n][m]);
    return 0;
}
```

#### 3. 作者：FreedomKing (赞：97)
- **星级**：4星
- **关键亮点**：
  - 代码简洁，处理了马的控制点，并提供了边界条件的处理。
  - 使用了方向数组来标记马的控制点，代码可读性较好。
- **个人心得**：作者通过简单的代码实现了动态规划的核心逻辑，适合初学者学习。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int dir[8][2]={{1,2},{1,-2},{2,1},{2,-1},{-1,2},{-1,-2},{-2,1},{-2,-1}};
bool d[30][30];
long long dp[30][30],n,m,cx,cy;
int main(){
    cin>>n>>m>>cx>>cy;
    d[cx][cy]=true;
    for(int i=0;i<8;i++){
        int tx=cx+dir[i][0],ty=cy+dir[i][1];
        if(tx>=0&&tx<=n&&ty>=0&&ty<=m) d[tx][ty]=true;
    }
    dp[0][0]=1;
    for(int i=0;i<=n;i++){
        for(int j=0;j<=m;j++){
            if(d[i][j]==false){
                if(i) dp[i][j]+=dp[i-1][j];
                if(j) dp[i][j]+=dp[i][j-1];
            }
        }
    }
    cout<<dp[n][m]<<endl;
    return 0;
}
```

### 最优关键思路与技巧

1. **状态转移方程**：核心思路是通过状态转移方程 `f[i][j] = f[i-1][j] + f[i][j-1]` 计算每个格子的路径数。
2. **马的控制点处理**：通过方向数组标记马的控制点，并在状态转移时跳过这些点。
3. **空间优化**：使用滚动数组或一维数组优化空间复杂度，减少内存使用。

### 可拓展之处

1. **类似问题**：可以扩展到其他棋盘类问题，如骑士巡游、皇后问题等。
2. **优化思路**：在其他动态规划问题中，也可以考虑使用滚动数组或一维数组优化空间复杂度。

### 推荐题目

1. **P1004 方格取数**：类似的双路径动态规划问题。
2. **P1219 八皇后**：棋盘类问题，考察回溯算法。
3. **P1433 吃奶酪**：状态压缩动态规划问题，考察路径规划。

### 个人心得总结

- **调试经历**：在处理马的控制点时，部分题解通过方向数组避免了复杂的判断逻辑，代码更加简洁。
- **踩坑教训**：在处理边界条件时，部分题解通过坐标偏移避免了数组越界问题，值得学习。
- **顿悟感想**：通过逐步优化，从基础解法到高效解法，体现了对问题的深入理解和灵活应用。

---
处理用时：52.61秒
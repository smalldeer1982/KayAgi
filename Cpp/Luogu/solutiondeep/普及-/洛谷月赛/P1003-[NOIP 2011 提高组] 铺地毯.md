# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地找到覆盖给定点的最上层地毯。由于数据范围较大（$n \le 10^4$，坐标范围 $\le 10^5$），直接使用二维数组模拟会超出内存限制。因此，大多数题解都采用了**枚举法**，通过存储每张地毯的边界信息，逐个判断是否覆盖目标点。其中，**逆序遍历**和**结构体存储**是常见的优化手段。

### 所选高星题解

#### 1. **作者：智子 (5星)**
- **关键亮点**：通过四个数组分别存储地毯的边界信息，避免了二维数组的内存问题。代码简洁，逻辑清晰，且通过逆序遍历优化了查找效率。
- **核心代码**：
  ```cpp
  int a[MAXN], b[MAXN], g[MAXN], k[MAXN];
  int main() {
      int n, x, y;
      scanf("%d", &n);
      for(int i = 0; i < n; i++) {
          scanf("%d%d%d%d", &a[i], &b[i], &g[i], &k[i]);
      }
      scanf("%d%d", &x, &y);
      int ans = -1;
      for(int i = 0; i < n; i++) {
          if(x >= a[i] && y >= b[i] && x <= a[i] + g[i] && y <= b[i] + k[i]) {
              ans = i + 1;
          }
      }
      printf("%d\n", ans);
      return 0;
  }
  ```

#### 2. **作者：kuaiCreator (4星)**
- **关键亮点**：采用逆序遍历，一旦找到覆盖目标点的地毯即可立即输出结果，避免了不必要的遍历。代码简洁，逻辑清晰。
- **核心代码**：
  ```cpp
  int a[N], b[N], g[N], k[N], n, x, y, ans = -1;
  int main() {
      cin >> n;
      for (int i = 1; i <= n; i++) cin >> a[i] >> b[i] >> g[i] >> k[i];
      cin >> x >> y;
      for (int i = n; i >= 1; i--) {
          if (x >= a[i] && x <= a[i] + g[i] && y >= b[i] && y <= b[i] + k[i]) {
              ans = i;
              break;
          }
      }
      cout << ans;
      return 0;
  }
  ```

#### 3. **作者：Jayfeather2012 (4星)**
- **关键亮点**：同样采用逆序遍历，代码简洁，逻辑清晰，且通过提前返回进一步优化了查找效率。
- **核心代码**：
  ```cpp
  int a[10003],b[10003],g[10003],k[10003],n,x,y;
  int main() {
      cin>>n;
      for(int i=1;i<=n;i++) cin>>a[i]>>b[i]>>g[i]>>k[i];
      cin>>x>>y;
      for(int i=n;i>=1;i--) {
          if(a[i]<=x&&a[i]+g[i]>=x&&b[i]<=y&&b[i]+k[i]>=y) {
              cout<<i;
              return 0;
          }
      }
      cout<<-1;
      return 0;
  }
  ```

### 最优关键思路与技巧
1. **逆序遍历**：由于后铺的地毯覆盖前面的地毯，逆序遍历可以更快找到最上层的地毯。
2. **结构体存储**：使用结构体存储地毯的边界信息，代码更易读且便于维护。
3. **提前返回**：一旦找到覆盖目标点的地毯，立即返回结果，避免不必要的遍历。

### 可拓展之处
- **类似问题**：对于其他覆盖类问题（如矩形覆盖、线段覆盖等），可以采用类似的枚举和逆序遍历策略。
- **优化思路**：对于更大规模的数据，可以考虑使用空间索引（如R树）来加速查找。

### 推荐相似题目
1. **P1003 铺地毯**（本题）
2. **P1886 滑动窗口**（考察区间覆盖与滑动窗口优化）
3. **P1908 逆序对**（考察逆序思维与分治算法）
4. **P1047 校门外的树**（考察区间覆盖与模拟）

### 个人心得总结
- **调试经历**：多位作者提到，直接使用二维数组模拟会导致内存超限，提醒我们在处理大数据范围时要注意内存优化。
- **顿悟感想**：逆序遍历的引入不仅优化了查找效率，还简化了代码逻辑，体现了算法设计中的“逆向思维”优势。

---
处理用时：32.92秒
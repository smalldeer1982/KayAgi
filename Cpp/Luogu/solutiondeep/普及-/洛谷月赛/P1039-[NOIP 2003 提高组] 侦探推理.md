# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！



## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过枚举罪犯和星期几，结合证言的真假判断，找出唯一的罪犯。难点在于如何处理证言的分类、判断矛盾情况以及处理未说话的人。题解中主要采用了枚举+模拟的思路，部分题解还引入了状态压缩、2-SAT等优化手段。整体来看，题解的思路较为相似，但在细节处理和代码实现上存在差异。

### 所选高星题解

#### 1. **作者：Drifterming (赞：89)**
- **星级：★★★★★**
- **关键亮点：**
  - 思路清晰，代码结构合理，易于理解。
  - 通过枚举罪犯和星期几，结合证言的真假判断，逐步排除矛盾情况。
  - 使用`map`存储人名和编号，简化了查找过程。
  - 通过`TF`数组记录每个人的说话状态，避免了重复判断。
- **个人心得：**
  - 强调了换行符的处理问题，提醒了在不同操作系统下的兼容性问题。
- **核心代码：**
  ```cpp
  bool judgeTF(int id,bool flag) {
      if(TF[id]==-1) {
          TF[id]=flag;
          if(flag) ++T; else ++F;
      } else return TF[id]!=flag;
      if(F>n || T>m-n) return 1;
      return 0;
  }
  ```

#### 2. **作者：wjyyy (赞：18)**
- **星级：★★★★☆**
- **关键亮点：**
  - 使用`std::map`和`std::vector`简化了证言的存储和处理。
  - 通过枚举罪犯和日期，结合证言的真假判断，逐步排除矛盾情况。
  - 代码结构清晰，逻辑严谨。
- **核心代码：**
  ```cpp
  bool judge(int id,string day) {
      memset(TF,-1,sizeof(TF));
      T=F=0;
      for(int i=1;i<=p;++i) {
          int pos=sen[i].s.find("I am guilty.");
          if(~pos) if(judgeTF(sen[i].id,sen[i].id==id)) return 0;
          // 其他证言处理类似
      }
      return 1;
  }
  ```

#### 3. **作者：Setsugesuka (赞：1)**
- **星级：★★★★☆**
- **关键亮点：**
  - 通过枚举罪犯和星期几，结合证言的真假判断，逐步排除矛盾情况。
  - 使用`map`存储人名和编号，简化了查找过程。
  - 代码结构清晰，逻辑严谨。
- **核心代码：**
  ```cpp
  bool work(int day,int g) {
      int x=0,y=0,i,f1,f2,j;
      for(i=1;i<=n;i++) {
          f1=0; f2=0;
          if(a[i].x||(a[i].week&&a[i].week!=day)) f2=1;
          if(a[i].week==day) f1=1;
          // 其他证言处理类似
      }
      if(x>m) return 0;
      if(x+y<m) return 0;
      return 1;
  }
  ```

### 最优关键思路与技巧

1. **枚举罪犯和星期几**：通过枚举所有可能的罪犯和星期几，结合证言的真假判断，逐步排除矛盾情况。
2. **证言分类处理**：将证言分为五类（我是罪犯、我不是罪犯、XXX是罪犯、XXX不是罪犯、今天是星期几），简化判断逻辑。
3. **状态记录**：使用数组记录每个人的说话状态，避免重复判断。
4. **换行符处理**：注意不同操作系统下的换行符差异，避免因换行符导致的错误。

### 可拓展之处

1. **状态压缩**：可以进一步优化枚举过程，使用状态压缩减少枚举次数。
2. **2-SAT**：可以将问题转化为2-SAT问题，利用图论算法求解。

### 推荐题目

1. **P1003 铺地毯**（枚举与模拟）
2. **P1048 采药**（状态压缩与动态规划）
3. **P1074 靶形数独**（回溯与剪枝）

### 个人心得总结

- **调试经历**：在处理证言时，需要注意证言的分类和判断逻辑，避免遗漏或错误。
- **踩坑教训**：换行符的处理在不同操作系统下可能存在差异，需要特别注意。
- **顿悟感想**：通过枚举和模拟，可以有效地解决复杂的逻辑推理问题。

---
处理用时：40.38秒
# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

该题目要求在一棵树中通过切断传播路径来控制传染病的传播，目标是使被感染的人数最少。由于题目数据范围较小（n ≤ 300），大多数题解采用了搜索（DFS）的方法，部分题解尝试了贪心或随机化策略。虽然贪心和随机化在某些情况下表现良好，但由于题目性质，搜索是最为稳妥的解法。

大多数题解的核心思路是通过分层搜索，逐层选择切断的节点，并回溯求解最优解。部分题解通过预处理子树大小、标记节点状态等方式进行优化，提升了搜索效率。整体来看，搜索类题解思路清晰，代码实现较为简洁，适合初学者理解和实现。

### 所选高星题解

#### 1. 作者：RikoHere (赞：160)  
**星级：★★★★★**  
**关键亮点：**  
- 思路清晰，分模块处理，代码结构良好，适合初学者理解。
- 通过预处理节点距离和子树大小，优化了搜索效率。
- 详细解释了搜索的传入参数选择，帮助理解搜索的核心逻辑。

**核心代码：**
```cpp
void dfs(int cen, int tot) {
    maxx = max(maxx, tot);
    for (int i = 0; i < cnt[cen]; ++i) {
        if (!bol[b[cen][i]]) {
            int num = clean(b[cen][i]);
            tot += num;
            dfs(cen+1, tot);
            reclean(b[cen][i]);
            tot -= num;
        }
    }
}
```
**核心思想：**  
通过分层搜索，逐层选择切断的节点，并回溯求解最优解。`clean`和`reclean`函数用于标记和回溯子树的状态。

#### 2. 作者：基础不牢 (赞：138)  
**星级：★★★★☆**  
**关键亮点：**  
- 详细解释了树的存储和分层处理，适合初学者理解树的遍历。
- 通过标记和回溯子树状态，确保搜索的正确性。
- 代码结构清晰，注释详细，便于理解。

**核心代码：**
```cpp
void dfs(int now, int cnt) {
    if (now == maxx) {
        ans = min(ans, cnt);
        return;
    }
    int f = 0;
    for (int i = 1; i <= deep[now][0]; ++i) {
        if (vis[deep[now][i]] > 0) {
            f++;
            continue;
        }
        vis[deep[now][i]] = 1;
        work(deep[now][i], 1);
        dfs(now + 1, cnt - count[deep[now][i]]);
        vis[deep[now][i]] = 0;
        work(deep[now][i], 0);
    }
    if (f == deep[now][0]) ans = min(ans, cnt);
}
```
**核心思想：**  
通过分层搜索，逐层选择切断的节点，并回溯求解最优解。`work`函数用于标记子树状态，`vis`数组用于记录节点是否被切断。

#### 3. 作者：欧鹰 (赞：75)  
**星级：★★★★☆**  
**关键亮点：**  
- 通过预处理子树大小和深度，优化了搜索效率。
- 详细解释了搜索的边界条件和优化策略，帮助理解搜索的核心逻辑。
- 代码结构清晰，注释详细，便于理解。

**核心代码：**
```cpp
void dfs1(int deep) {
    for (int i = 1; i <= tt[deep]; i++) {
        if (vis[father[cnt[deep][i]]] == 1) continue;
        dfs2(cnt[deep][i]);
        ans += son[cnt[deep][i]];
        dfs1(deep + 1);
        ans -= son[cnt[deep][i]];
        dfs3(cnt[deep][i]);
    }
    ans1 = max(ans, ans1);
}
```
**核心思想：**  
通过分层搜索，逐层选择切断的节点，并回溯求解最优解。`dfs2`和`dfs3`函数用于标记和回溯子树的状态。

### 最优关键思路与技巧

1. **分层搜索**：将树按深度分层，逐层选择切断的节点，确保每次切断的节点不会影响其他层的选择。
2. **子树预处理**：预处理每个节点的子树大小，方便在搜索时快速计算切断节点的影响。
3. **标记与回溯**：通过标记子树状态，确保搜索的正确性，并在回溯时恢复状态，避免重复计算。

### 拓展思路与类似题目

1. **类似题目**：
   - [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)：考察树的遍历和动态规划。
   - [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)：考察树形DP和状态转移。
   - [P2014 选课](https://www.luogu.com.cn/problem/P2014)：考察树形背包和动态规划。

2. **拓展思路**：
   - 对于更大数据范围的类似问题，可以考虑使用动态规划或贪心策略进行优化。
   - 在处理树形结构时，预处理子树信息（如子树大小、深度等）可以显著提升算法效率。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现贪心策略的错误，提醒我们在面对复杂问题时，贪心策略不一定总是最优的，搜索和动态规划更为稳妥。
- **踩坑教训**：在处理树形结构时，预处理子树信息和分层处理是关键，避免在搜索过程中重复计算。
- **顿悟感想**：通过分层搜索和回溯，可以有效地解决树形结构中的组合优化问题，这种思路在类似题目中也有广泛应用。

---
处理用时：49.38秒
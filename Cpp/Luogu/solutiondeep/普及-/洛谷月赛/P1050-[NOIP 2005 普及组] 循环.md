# 题目信息

# [NOIP 2005 普及组] 循环

## 题目描述

乐乐是一个聪明而又勤奋好学的孩子。他总喜欢探求事物的规律。一天，他突然对数的正整数次幂产生了兴趣。


众所周知，$2$ 的正整数次幂最后一位数总是不断的在重复 $2,4,8,6,2,4,8,6…$ 我们说 $2$ 的正整数次幂最后一位的循环长度是 $4$（实际上 $4$ 的倍数都可以说是循环长度，但我们只考虑最小的循环长度）。类似的，其余的数字的正整数次幂最后一位数也有类似的循环现象：

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c}\hline
\textbf{数字}& \textbf{循环} & \textbf{循环长度} \cr\hline\hline
2 & 2,4,8,6 & 4\cr\hline
3 & 3,9,7,1 & 4\cr\hline
4 & 4,6 & 2\cr\hline
5 & 5 &  1\cr\hline
6 & 6 & 1\cr\hline
7 & 7,9,3,1 & 4\cr\hline
8 & 8,4,2,6 & 4\cr\hline
9 & 9,1 & 2\cr\hline
\end{array}
$$

这时乐乐的问题就出来了：是不是只有最后一位才有这样的循环呢？对于一个整数 $n$ 的正整数次幂来说，它的后 $k$ 位是否会发生循环？如果循环的话，循环长度是多少呢？

注意：

1. 如果 $n$ 的某个正整数次幂的位数不足 $k$，那么不足的高位看做是 $0$。
2. 如果循环长度是 $L$，那么说明对于任意的正整数 $a$，$n$ 的 $a$ 次幂和 $a+L$ 次幂的最后 $k$ 位都相同。


## 说明/提示

**【数据范围】**

对于 $30 \%$ 的数据，满足 $k \le 4$；  
对于$100 \%$ 的数据，满足 $1 \le n < {10}^{100}$，$1 \le k \le 100$。

**【题目来源】**

NOIP 2005 普及组第四题

## 样例 #1

### 输入

```
32 2```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

本题的核心是求一个数的正整数次幂的最后 $k$ 位的循环长度。题解主要分为以下几种思路：

1. **逐位递推法**：通过逐位计算循环长度，利用前 $w$ 位的循环长度推导出 $w+1$ 位的循环长度。这种方法的核心思想是后 $w+1$ 位的循环长度一定是前 $w$ 位循环长度的倍数，且倍数不超过 10。该方法的优势在于思路清晰，时间复杂度较低，适合处理大数问题。

2. **欧拉定理法**：利用欧拉定理推导循环长度，并通过枚举因子来找到最小循环长度。该方法虽然理论性强，但实现复杂，且时间复杂度较高，不适合本题的数据范围。

3. **暴力模拟法**：直接模拟幂运算，直到出现循环或超过一定次数。该方法简单直观，但时间复杂度极高，无法通过本题的数据范围。

4. **高精度优化法**：通过高精度乘法和递推优化，减少计算量。该方法结合了递推和高精度运算，适合处理大数问题，但实现较为复杂。

### 所选高星题解

#### 1. **作者：_Life_ (4星)**
- **关键亮点**：逐位递推法，思路清晰，代码可读性高，通过高精度乘法优化计算。
- **个人心得**：作者通过手玩数据 `198123 4`，详细解释了逐位递推的过程，帮助读者理解递推的核心思想。
- **核心代码**：
  ```cpp
  bignum operator *(bignum a,bignum b) {
      bignum ans;
      for(int i=0;i<k;i++)
          for(int j=0;j<k;j++)
              ans.x[i+j]+=a.x[i]*b.x[j];
      for(int i=0;i<k;i++)ans.x[i+1]+=ans.x[i]/10,ans.x[i]%=10;
      for(int i=k;i<205;i++)ans.x[i]=0;
      return ans;
  }
  ```
  **核心思想**：通过高精度乘法，逐位计算循环长度，确保每次计算只保留后 $k$ 位。

#### 2. **作者：vectorwyx (4星)**
- **关键亮点**：递推法，通过高精度乘法和递推优化，减少计算量，思路清晰。
- **核心代码**：
  ```cpp
  num operator*(const num &x) const {
      num ret;
      for(int i=1;i<=len;i++)
          for(int j=1;j<=min(x.len,k-i+1)) ret.a[i+j-1]+=a[i]*x.a[j];
      ret.len=min(k,len+x.len-1);
      for(int i=1;i<=ret.len) ret.a[i+1]+=ret.a[i]/10,ret.a[i]%=10;
      if(ret.a[ret.len+1]) ret.len=min(ret.len+1,k);
      return ret;
  }
  ```
  **核心思想**：通过高精度乘法，逐位计算循环长度，确保每次计算只保留后 $k$ 位。

#### 3. **作者：Shadow_Soldier (4星)**
- **关键亮点**：递推法，通过高精度乘法和递推优化，减少计算量，思路清晰。
- **核心代码**：
  ```cpp
  Number operator * (Number p, Number q) {
      Number rhs;
      rhs.Clear();
      for(int i = 1; i <= p.l; i ++) {
          for(int j = 1; j <= q.l; j ++) {
              rhs.a[i + j - 1] += (p.a[i] * q.a[j]);
              rhs.a[i + j] += (rhs.a[i + j - 1] / 10);
              rhs.a[i + j - 1] %= 10;
          }
      }
      if(rhs.a[p.l + q.l]) rhs.l = p.l + q.l;
      else rhs.l = p.l + q.l - 1;
      rhs.Resize();
      return rhs;
  }
  ```
  **核心思想**：通过高精度乘法，逐位计算循环长度，确保每次计算只保留后 $k$ 位。

### 最优关键思路与技巧

1. **逐位递推法**：通过逐位计算循环长度，利用前 $w$ 位的循环长度推导出 $w+1$ 位的循环长度。这种方法的核心思想是后 $w+1$ 位的循环长度一定是前 $w$ 位循环长度的倍数，且倍数不超过 10。

2. **高精度优化**：通过高精度乘法和递推优化，减少计算量，确保每次计算只保留后 $k$ 位。

### 可拓展之处

1. **同类型题**：类似的问题可以扩展到其他进制或更复杂的循环结构，如矩阵幂的循环、多项式幂的循环等。
2. **算法套路**：递推法和高精度乘法的结合可以应用于其他需要处理大数问题的场景，如大数幂运算、大数模运算等。

### 推荐题目

1. **P1045 麦森数**：考察大数幂运算和高精度计算。
2. **P1226 快速幂**：考察快速幂算法和大数模运算。
3. **P1303 高精度乘法**：考察高精度乘法的实现和优化。

### 个人心得总结

- **调试经历**：多位作者提到通过手玩数据来理解递推过程，帮助调试和验证算法的正确性。
- **踩坑教训**：在处理大数问题时，高精度乘法的实现细节非常重要，尤其是进位和取模操作。
- **顿悟感想**：逐位递推法的核心思想是后 $w+1$ 位的循环长度一定是前 $w$ 位循环长度的倍数，这一发现极大地简化了问题的复杂度。

---
处理用时：47.81秒
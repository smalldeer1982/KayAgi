# 题目信息

# [NOIP 2008 普及组] 传球游戏

## 题目描述

上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。

游戏规则是这样的：$n$ 个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。

聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了 $m$ 次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学 $1$ 号、$2$ 号、$3$ 号，并假设小蛮为 $1$ 号，球传了 $3$ 次回到小蛮手里的方式有 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$ 和 $1 \rightarrow 3 \rightarrow 2 \rightarrow 1$，共 $2$ 种。


## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据，满足：$3 \le n \le 30,1 \le m \le 20$；
- 对于 $100\%$ 的数据，满足：$3 \le n \le 30,1 \le m \le 30$。

2008普及组第三题


## 样例 #1

### 输入

```
3 3```

### 输出

```
2```

# AI分析结果

### 综合分析

本题是一个典型的动态规划问题，主要考察如何通过状态转移方程来解决环形传球问题。大部分题解都采用了动态规划的思路，核心思想是通过记录传球次数和传球位置的状态来推导最终的结果。部分题解还提供了BFS、记忆化搜索等其他解法，但效率较低，无法通过大规模数据测试。

### 最优思路与技巧

1. **状态定义**：定义 `dp[i][j]` 表示传球 `i` 次后，球在第 `j` 个同学手中的方案数。
2. **状态转移**：球可以从左边或右边的同学传过来，因此状态转移方程为：
   - `dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]`
   - 对于边界情况（`j=1` 和 `j=n`），需要特殊处理。
3. **初始化**：初始状态为 `dp[0][1] = 1`，表示球最初在小蛮手中。
4. **优化**：部分题解使用了滚动数组优化空间复杂度，减少内存使用。

### 推荐题解

#### 1. HighPerformanceRobot (5星)
- **关键亮点**：详细讲解了动态规划的思路，并提供了BFS、打表、记忆化搜索等多种解法，适合初学者理解。
- **核心代码**：
  ```cpp
  int f[31][31],i,j,m,n;
  int main()
  {
      cin>>n>>m;
      f[0][1]=1;
      for(int i=1; i<=m; i++)
          for(int j=1; j<=n; j++)
              if(j==1)
                  f[i][j]=f[i-1][n]+f[i-1][2];
              else if(j==n)
                  f[i][j]=f[i-1][1]+f[i-1][n-1];
              else
                  f[i][j]=f[i-1][j-1]+f[i-1][j+1];
      cout<<f[m][1]<<endl;
      return 0;
  }
  ```

#### 2. kunkun127 (4星)
- **关键亮点**：简洁明了地解释了动态规划的状态转移方程，代码清晰易读。
- **核心代码**：
  ```cpp
  int dp[35][35];
  int main()
  {
      int n, m; 
      cin >> n >> m;
      dp[1][0] = 1;
      for (int j = 1; j <= m; j++)
      {
          dp[1][j] = dp[2][j - 1] + dp[n][j - 1];
          dp[n][j] = dp[1][j - 1] + dp[n - 1][j - 1];
          for (int i = 2; i < n; i++) dp[i][j] = dp[i - 1][j - 1] + dp[i + 1][j - 1];
      }
      cout << dp[1][m] << endl;
      return 0;
  }
  ```

#### 3. ljh0727 (4星)
- **关键亮点**：详细推导了状态转移方程，并提供了清晰的代码实现。
- **核心代码**：
  ```cpp
  int dp[35][35];
  int main(){
      int n,m;
      scanf("%d%d",&n,&m);
      dp[1][0]=1;
      for(int i=1;i<=m;i++){
          for(int j=1;j<=n;j++){
              if(j==1)
                  dp[j][i]+=dp[n][i-1]+dp[2][i-1];
              else if(j==n)
                  dp[j][i]+=dp[1][i-1]+dp[n-1][i-1];
              else 
                  dp[j][i]+=dp[j-1][i-1]+dp[j+1][i-1];
          }
      }
      printf("%d",dp[1][m]);
      return 0;
  }
  ```

### 扩展思路与推荐题目

1. **扩展思路**：本题可以进一步优化为使用滚动数组，减少空间复杂度。此外，类似的问题还可以通过矩阵快速幂等高级算法来解决。
2. **推荐题目**：
   - [P1877 音量调节](https://www.luogu.com.cn/problem/P1877)：考察动态规划的状态转移。
   - [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的背包问题，与动态规划相关。
   - [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)：考察动态规划的应用。

### 个人心得摘录

- **HighPerformanceRobot**：提到BFS+剪枝的优化效果有限，最终还是要靠动态规划来解决问题。
- **kunkun127**：强调了动态规划的状态转移方程的重要性，并提供了清晰的代码实现。
- **ljh0727**：通过模拟传球过程，推导出状态转移方程，帮助理解动态规划的核心思想。

---
处理用时：38.53秒
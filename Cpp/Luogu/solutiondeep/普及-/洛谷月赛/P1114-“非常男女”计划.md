# 题目信息

# “非常男女”计划

## 题目描述

近来，初一年的 `XXX` 小朋友致力于研究班上同学的配对问题（别想太多，仅是舞伴），通过各种推理和实验，他掌握了大量的实战经验。例如，据他观察，身高相近的人似乎比较合得来。

万圣节来临之际，`XXX` 准备在学校策划一次大型的 “非常男女” 配对活动。对于这次活动的参与者，`XXX` 有自己独特的选择方式。他希望能选择男女人数相等且身高都很接近的一些人。这种选择方式实现起来很简单。他让学校的所有人按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。为了使活动更热闹，`XXX` 当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。


## 样例 #1

### 输入

```
9
0 1 0 0 0 1 1 0 0
```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

本题的核心问题是在一个由0和1组成的序列中，找到最长的连续子序列，使得子序列中0和1的数量相等。大多数题解都采用了前缀和的思路，通过将0和1分别映射为-1和1，转化为求前缀和相等的最远距离问题。部分题解还引入了哈希表或桶来优化查找过程，避免了O(n²)的暴力枚举。

### 所选高星题解

#### 1. **AKB48 (5星)**
- **关键亮点**：引入了“相对差”的概念，通过记录差值的最早和最晚出现位置，将问题转化为O(n)的时间复杂度。思路清晰，代码简洁。
- **核心代码**：
  ```cpp
  for (int i=1;i<=n;i++){
      int x; cin>>x;
      sum1+=(x==1), sum0+=(x==0);
      int t=sum0-sum1+n;
      if (!l[t]&&t!=n) l[t]=i; else r[t]=i;
  }
  for (int i=0;i<=2*n;i++) ans=max(ans,r[i]-l[i]);
  ```
- **个人心得**：通过将差值加上n，避免了负数下标的问题，简洁高效。

#### 2. **KellyFrog (4星)**
- **关键亮点**：详细解释了前缀和的思路，并通过哈希表记录前缀和的最早出现位置，优化了查找过程。代码可读性强，适合初学者理解。
- **核心代码**：
  ```cpp
  for(int i = 1; i < n + 1; i++){
     hash[sum[i]+100010]._min = min(hash[sum[i]+100010]._min, i);
     hash[sum[i]+100010]._max = i;
  }
  ```
- **个人心得**：强调了初始化哈希数组的重要性，并提醒了负数下标的处理。

#### 3. **Bring (4星)**
- **关键亮点**：通过将0和1分别映射为-1和1，将问题转化为求前缀和相等的最远距离问题，并使用哈希表优化查找。代码简洁，思路清晰。
- **核心代码**：
  ```cpp
  for(RI i=1;i<=n;i++)
      if(mp[sum[i]+m] and i!=mp[sum[i]+m])
          ans=std::max(ans,i-mp[sum[i]+m]);
  ```
- **个人心得**：通过将数组开得更大一些，避免了负数下标的问题，思路巧妙。

### 最优关键思路与技巧

1. **前缀和与差值映射**：将0和1分别映射为-1和1，通过前缀和相等来判断子序列中0和1的数量是否相等。
2. **哈希表优化**：使用哈希表或桶记录前缀和的最早出现位置，避免O(n²)的暴力枚举。
3. **负数下标处理**：通过将前缀和加上一个足够大的数（如n或100010），避免负数下标的问题。

### 可拓展之处

1. **类似问题**：可以扩展到其他类型的平衡问题，如找到最长的子序列，使得某种属性的数量相等。
2. **算法套路**：前缀和+哈希表的组合可以用于解决多种区间和问题，如求区间和为k的最长子序列。

### 推荐题目

1. **P1114 “非常男女”计划**（本题）
2. **P1102 A-B数对**（前缀和+哈希表）
3. **P1638 逛画展**（滑动窗口+前缀和）

### 个人心得总结

- **调试经历**：部分题解提到了调试过程中遇到的负数下标问题，通过加上一个足够大的数解决了这一问题。
- **踩坑教训**：初始化哈希数组时，需要确保所有可能的前缀和都被覆盖，避免遗漏。
- **顿悟感想**：通过将问题转化为前缀和相等的最远距离问题，大大简化了问题的复杂度，体现了算法设计中的转化思想。

---
处理用时：32.41秒
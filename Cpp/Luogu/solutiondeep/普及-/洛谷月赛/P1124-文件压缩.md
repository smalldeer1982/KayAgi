# 题目信息

# 文件压缩

## 题目背景

提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。


## 题目描述

该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。

举例：$S$ 是 `example`

1. 构造 $n$ 个字符串。

```plain
example
xamplee
ampleex
mpleexa
pleexam
leexamp
eexampl
```

2. 将字符串排序。

```plain
ampleex
example
eexampl
leexamp
mpleexa
pleexam
xamplee
```
3. 压缩结果。

$S' = \texttt{xelpame}$，$p = 7$

由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。

请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。

保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。

## 样例 #1

### 输入

```
7
xelpame
7
```

### 输出

```
example
```

# AI分析结果

### 综合分析与结论

这些题解的核心思路是通过排序后的字符串和原字符串的对应关系，利用首尾字符的相邻性，逐步还原出原字符串。大多数题解都采用了倒推的方式，避免了正推时可能出现的字符错位问题。倒推的优势在于，排序后的字符串是有序的，能够确保每次找到的字符是唯一的，从而避免了重复或错位的情况。

### 所选高星题解

#### 1. 作者：MC_Launcher (赞：143)  
**星级：5星**  
**关键亮点：**  
- 思路清晰，通过排序后的字符串和原字符串的对应关系，逐步还原原字符串。
- 采用倒推的方式，避免了正推时可能出现的字符错位问题。
- 代码结构清晰，注释详细，易于理解。

**个人心得：**  
- 作者提到第一次正着排时只得了10分，后来通过倒推解决了问题。这提醒我们在处理类似问题时，要注意顺序的选择，避免因顺序不当导致的错误。

**核心代码：**
```cpp
for(int i=1;i<n;i++) {
    for(int j=n-1;j>=0;j--) {
        if(b[j]==a[now]) {
            now=j;
            ans[i]=a[now];
            b[j]=')';
            break;
        }
    }	
}
```
**实现思想：**  
通过倒推的方式，从最后一个字符开始，逐步找到前一个字符，最终还原出原字符串。

#### 2. 作者：liuzhaoxu (赞：43)  
**星级：4星**  
**关键亮点：**  
- 详细解释了为什么不能正着推，并给出了具体的反例。
- 通过倒推的方式，确保每次找到的字符是唯一的，避免了重复或错位的情况。
- 代码结构清晰，注释详细。

**核心代码：**
```cpp
while(cnt>1) {
    ans[--cnt]=s[p];
    ss[p]='#';
    for(int i=n;i>=1;--i) if(ss[i]==s[p]) {p=i;break;}
}
```
**实现思想：**  
通过倒推的方式，从最后一个字符开始，逐步找到前一个字符，最终还原出原字符串。

#### 3. 作者：张心博harry (赞：26)  
**星级：4星**  
**关键亮点：**  
- 通过排序后的字符串和原字符串的对应关系，逐步还原原字符串。
- 采用倒推的方式，避免了正推时可能出现的字符错位问题。
- 代码结构清晰，注释详细。

**核心代码：**
```cpp
for(int j=n-1;j>=0;j--) {
    if(ss[now]==s[k]&&v[k]!=1) {
        now=k;
        v[k]=1;
        break;
    }
}
```
**实现思想：**  
通过倒推的方式，从最后一个字符开始，逐步找到前一个字符，最终还原出原字符串。

### 最优关键思路或技巧

1. **倒推法**：通过从最后一个字符开始，逐步找到前一个字符，确保每次找到的字符是唯一的，避免了重复或错位的情况。
2. **排序后的字符串与原字符串的对应关系**：利用排序后的字符串和原字符串的对应关系，逐步还原出原字符串。
3. **标记已使用的字符**：在找到字符后，标记该字符已被使用，避免重复使用。

### 可拓展之处

- **类似算法套路**：在处理需要还原或构造字符串的问题时，可以考虑通过排序或其他方式找到字符之间的对应关系，逐步还原或构造出目标字符串。
- **同类型题**：类似的问题可以出现在字符串的压缩、解压缩、编码、解码等场景中。

### 推荐题目

1. **P1125 字符串的展开**  
2. **P1126 字符串的压缩**  
3. **P1127 字符串的解码**

### 个人心得总结

- **调试经历**：多位作者提到在正推时遇到了问题，后来通过倒推解决了问题。这提醒我们在处理类似问题时，要注意顺序的选择，避免因顺序不当导致的错误。
- **踩坑教训**：在处理字符串问题时，要注意字符的唯一性和顺序，避免重复或错位的情况。
- **顿悟感想**：通过排序后的字符串和原字符串的对应关系，可以逐步还原出原字符串，这种方法在处理类似问题时非常有效。

---
处理用时：28.95秒
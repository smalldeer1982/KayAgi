# 题目信息

# 词链

## 题目描述

如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。

另外还有一些例子：
- `dog.gopher`
- `gopher.rat`
- `rat.tiger`
- `aloha.aloha`
- `arachnid.dog`

连接成的词可以与其他单词相连，组成更长的词链，例如：

`aloha.arachnid.dog.gopher.rat.tiger`

注意到，`.` 两边的字母一定是相同的。

现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。

## 说明/提示

- 对于 $40\%$ 的数据，有 $n \leq 10$；
- 对于 $100\%$ 的数据，有 $n \leq 1000$。


## 样例 #1

### 输入

```
6
aloha
arachnid
dog
gopher
rat
tiger```

### 输出

```
aloha.arachnid.dog.gopher.rat.tiger```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地找到字典序最小的词链，且每个单词在词链中出现且仅出现一次。大多数题解都采用了图论中的欧拉路径或欧拉回路的思想，通过将单词的首字母和尾字母作为图的顶点，单词作为边，构建有向图，然后通过DFS或欧拉路径的判定条件来解决问题。

#### 关键思路与技巧：
1. **欧拉路径与欧拉回路**：通过判断图中是否存在欧拉路径或回路来确定是否存在解，并确定起点。
2. **字典序最小化**：通过排序单词，确保在DFS时优先选择字典序较小的单词。
3. **图的连通性判断**：使用并查集或DFS判断图的连通性，确保所有单词可以连成一条链。
4. **优化搜索起点**：通过统计每个字母的出度和入度，确定欧拉路径的起点，避免不必要的搜索。

#### 扩展思路：
- **Tarjan缩点**：可以进一步通过Tarjan算法缩点，判断强连通分量的拓扑序，优化无解判断。
- **回溯剪枝**：在DFS过程中，可以通过剪枝减少不必要的搜索，提高效率。

### 推荐题解

#### 题解1：loc_equinox (5星)
**关键亮点**：
- 详细解释了欧拉路径的判定条件，并提供了完整的代码实现。
- 通过并查集判断图的连通性，确保所有单词可以连成一条链。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
void dfs(int st, int now, int pre_edge) {
    if (st == n) {
        for (int i = 1; i <= n; i++) {
            cout << res[i];
            if (i < n) cout << ".";
        }
        exit(0);
    }
    for (int k = 0; k < E[now].size(); k++) {
        if (!vis[E[now][k].ord]) {
            vis[E[now][k].ord] = 1;
            res[st + 1] = E[now][k].word;
            dfs(st + 1, E[now][k].to, E[now][k].ord);
        }
    }
    vis[pre_edge] = 0; // 回溯
}
```

#### 题解2：zzr8178541919 (4星)
**关键亮点**：
- 通过统计字母的出度和入度，优化了搜索起点的选择。
- 详细解释了搜索过程中的注意事项，如回溯和剪枝。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
void dfs(int last, int step) {
    if (flag == 1) return;
    if (step == n) {
        flag = 1;
        for (int i = 1; i <= sum; i++) {
            ans[i] = now[i];
        }
        return;
    }
    for (int i = 1; i <= n; i++) {
        if (book[i] == 1) continue;
        if (a[last][a[last].length() - 1] == a[i][0]) {
            now[++sum] = a[i];
            book[i] = 1;
            dfs(i, step + 1);
            sum--;
            book[i] = 0;
        }
    }
}
```

#### 题解3：CGDGAD (4星)
**关键亮点**：
- 通过建图优化搜索过程，减少了不必要的搜索。
- 详细解释了欧拉路径的判定条件，并提供了优化后的代码。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
void dfs(int s, std::string curr, int count) {
    if (count == n) {
        curr[curr.length() - 1] = ' ';
        std::cout << curr;
        exit(0);
    }
    for (auto i : e[s])
        if (!used[i]) {
            used[i] = true;
            dfs(i, curr + a[i] + '.', count + 1);
            used[i] = false;
        }
}
```

### 推荐题目
1. **P1127 词链**（本题）
2. **P2731 [USACO3.3]骑马修栅栏 Riding the Fences**（欧拉路径）
3. **P1341 无序字母对**（欧拉路径与字典序最小化）

### 个人心得
- **调试经历**：在DFS过程中，回溯时忘记将标记重置，导致结果错误。通过仔细检查代码，发现问题并修复。
- **踩坑教训**：在判断欧拉路径时，忽略了图的连通性，导致部分测试用例无法通过。通过并查集优化后，问题得到解决。
- **顿悟感想**：通过将单词转化为图的边，问题转化为欧拉路径的判定，大大简化了问题的复杂度。

---
处理用时：35.50秒
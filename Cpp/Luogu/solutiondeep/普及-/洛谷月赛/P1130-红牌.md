# 题目信息

# 红牌

## 题目描述


某地临时居民想获得长期居住权就必须申请拿到红牌。获得红牌的过程是相当复杂 ，一共包括 $N$ 个步骤。每一步骤都由政府的某个工作人员负责检查你所提交的材料是否符合条件。为了加快进程，每一步政府都派了 $M$ 个工作人员来检查材料。不幸的是，并不是每一个工作人员效率都很高。尽管如此，为了体现“公开政府”的政策，政府部门把每一个工作人员的处理一个申请所花天数都对外界公开。

为了防止所有申请人都到效率高的工作人员去申请。这 $M \times N$ 个工作人员被分成 $M$ 个小组。每一组在每一步都有一个工作人员。申请人可以选择任意一个小组也可以更换小组。但是更换小组是很严格的，一定要相邻两个步骤之间来更换，而不能在某一步骤已经开始但还没结束的时候提出更换，并且也只能从原来的小组 $I$ 更换到小组 $I+1$，当然从小组 $M$ 可以更换到小组 $1$。对更换小组的次数没有限制。

例如：下面是 $3$ 个小组，每个小组 $4$ 个步骤工作天数：

- 小组 $1$： $2, 6 ,1 ,8$；
- 小组 $2$：$3,6, 2, 6$；
- 小组 $3$：$ 4, 2 ,3 ,6$。

例子中，可以选择小组 $1$ 来完成整个过程一共花了$2+6+1+8=17$ 天，也可以从小组 $2$ 开始第一步，然后第二步更换到小组 $3$，第三步到小组 $1$，第四步再到小组 $2$，这样一共花了 $3+2+1+6=12$ 天。你可以发现没有比这样效率更高的选择。

你的任务是求出完成申请所花最少天数。

## 说明/提示

对于 $100\%$ 的数据，$1\le N,M \le 2000$。

## 样例 #1

### 输入

```
4 3 
2 6 1 8
3 6 2 6
4 2 3 6
```

### 输出

```
12```

# AI分析结果

### 综合分析与结论

该题目是一个典型的动态规划问题，核心在于如何通过状态转移方程找到最小天数。大多数题解采用了类似“数字三角形”的思路，通过二维数组 `f[i][j]` 表示第 `i` 个小组第 `j` 步的最小天数，并通过状态转移方程 `f[i][j] = min(f[i-1][j], f[i-1][j-1]) + a[i][j]` 进行求解。难点在于如何处理小组 `M` 可以切换到小组 `1` 的环形结构，部分题解通过特判或调整输入顺序解决了这一问题。

整体来看，题解质量参差不齐，部分题解思路清晰、代码简洁，但也有一些题解存在代码冗余、逻辑不清晰等问题。以下为评分较高的题解及其亮点分析。

### 精选题解

#### 1. 作者：whx1003 (5星)
- **关键亮点**：思路清晰，代码简洁，通过调整输入顺序解决了环形结构问题，状态转移方程明确，且代码可读性高。
- **核心代码**：
  ```cpp
  for(int i = 1; i <= n; ++i)
      for(int j = 1; j <= m; ++j)
          f[i][j] = std::min(f[i - 1][j], j == 1 ? f[i - 1][m] : f[i - 1][j - 1]) + a[i][j];
  ```
- **个人心得**：通过调整输入顺序，将问题转化为更易处理的线性结构，避免了复杂的环形处理。

#### 2. 作者：引领天下 (4星)
- **关键亮点**：采用逆推的思路，从倒数第二步开始逐步求解，避免了复杂的环形处理，代码简洁且易于理解。
- **核心代码**：
  ```cpp
  for (int j = n - 2; j >= 0; j--)
      for (int i = 0; i < m; i++)
          a[i][j] = min(a[(i + 1) % m][j + 1], a[i][j + 1]) + a[i][j];
  ```
- **个人心得**：通过逆推的方式，简化了状态转移方程的处理，尤其适合处理环形结构。

#### 3. 作者：juruo_zjc (4星)
- **关键亮点**：通过特判处理了小组 `M` 切换到小组 `1` 的情况，代码逻辑清晰，且通过 `dp[0][j-1] = dp[m][j-1]` 巧妙地解决了环形问题。
- **核心代码**：
  ```cpp
  for(LL j = 1; j <= n; j++) {
      dp[0][j - 1] = dp[m][j - 1];
      for(LL i = 1; i <= m; i++)
          dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1]) + gay[i][j];
  }
  ```
- **个人心得**：通过 `dp[0][j-1] = dp[m][j-1]` 的处理，巧妙地解决了环形切换问题，代码简洁且高效。

### 最优关键思路与技巧

1. **调整输入顺序**：通过将输入矩阵“立起来”，即将行和列交换，可以简化状态转移方程的处理，避免复杂的环形结构。
2. **逆推思路**：从倒数第二步开始逐步求解，可以有效减少环形结构的处理复杂度。
3. **特判处理**：通过特判小组 `M` 切换到小组 `1` 的情况，可以避免复杂的环形处理，代码更加简洁。

### 可拓展之处

该题的核心思路可以应用于其他类似的动态规划问题，尤其是涉及环形结构的场景。例如，处理环形数组的最小路径、环形背包问题等。通过调整输入顺序或逆推思路，可以有效简化问题的处理。

### 推荐题目

1. **P1216 数字三角形**：经典的动态规划问题，适合练习状态转移方程的构建。
2. **P1880 石子合并**：涉及环形结构的动态规划问题，适合练习环形处理技巧。
3. **P1048 采药**：经典的背包问题，适合练习动态规划的基本思路。

### 个人心得总结

- **调试经历**：部分题解提到在处理环形结构时遇到了调试困难，通过特判或调整输入顺序解决了问题。
- **顿悟感想**：通过逆推或调整输入顺序，可以将复杂的环形问题转化为线性问题，简化了状态转移方程的处理。

---
处理用时：39.48秒
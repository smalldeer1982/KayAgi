# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论

本题的核心是求解无向无权图中从起点到其他各点的最短路数量。题解中主要采用了以下几种算法：

1. **BFS**：由于是无权图，BFS天然适合求解最短路问题，且可以在遍历时直接统计最短路数量。
2. **SPFA**：虽然SPFA通常用于带权图的最短路问题，但在本题中由于边权为1，SPFA的效果与BFS类似。
3. **Dijkstra**：虽然Dijkstra通常用于带权图，但在本题中由于边权为1，Dijkstra的效果与BFS类似，且可以通过堆优化提升效率。

### 精选题解

#### 1. **作者：岸芷汀兰 (5星)**
- **关键亮点**：使用BFS求解最短路，思路清晰，代码简洁，且对自环和重边的处理得当。
- **核心思想**：通过BFS遍历图，记录每个点的最短路长度和路径数量。当发现更短的路径时，更新路径数量；当路径长度相等时，累加路径数量。
- **代码片段**：
```cpp
void bfs() {
    queue<int> q;
    q.push(1);
    vis[1] = 1;
    ans[1] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : linker[u]) {
            if (!vis[v]) {
                vis[v] = 1;
                d[v] = d[u] + 1;
                ans[v] = ans[u];
                q.push(v);
            } else if (d[v] == d[u] + 1) {
                ans[v] = (ans[v] + ans[u]) % mod;
            }
        }
    }
}
```

#### 2. **作者：King丨帝御威 (4星)**
- **关键亮点**：使用堆优化的Dijkstra算法，代码结构清晰，且对最短路数量的统计处理得当。
- **核心思想**：通过Dijkstra算法求解最短路，并在松弛操作中统计路径数量。当发现更短的路径时，更新路径数量；当路径长度相等时，累加路径数量。
- **代码片段**：
```cpp
void dijkstra() {
    priority_queue<pair<int, int>> q;
    q.push({0, 1});
    dis[1] = 0;
    ans[1] = 1;
    while (!q.empty()) {
        int u = q.top().second; q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            if (dis[v] > dis[u] + 1) {
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                q.push({-dis[v], v});
            } else if (dis[v] == dis[u] + 1) {
                ans[v] = (ans[v] + ans[u]) % mod;
            }
        }
    }
}
```

#### 3. **作者：XZYQvQ (4星)**
- **关键亮点**：使用SPFA求解最短路，并通过记忆化搜索统计路径数量，思路新颖且代码简洁。
- **核心思想**：先通过SPFA求解最短路，再通过记忆化搜索统计路径数量。当发现更短的路径时，更新路径数量；当路径长度相等时，累加路径数量。
- **代码片段**：
```cpp
int dfs(int u) {
    if (ans[u]) return ans[u];
    for (int i = head[u]; i != -1; i = nxt[i]) {
        if (dis[u] - 1 == dis[to[i]]) {
            ans[u] = (ans[u] + dfs(to[i])) % mod;
        }
    }
    return ans[u];
}
```

### 最优关键思路与技巧

1. **BFS与Dijkstra的结合**：在无权图中，BFS和Dijkstra的效果相似，但Dijkstra可以通过堆优化提升效率。
2. **路径数量的统计**：在遍历图时，通过判断路径长度是否相等来累加路径数量，确保统计的准确性。
3. **记忆化搜索**：在SPFA的基础上，通过记忆化搜索统计路径数量，提升效率。

### 拓展思路

1. **带权图的最短路计数**：可以将本题的思路扩展到带权图，使用Dijkstra或SPFA求解最短路，并在松弛操作中统计路径数量。
2. **多源最短路计数**：可以扩展到多源最短路问题，通过Floyd算法或多次Dijkstra求解最短路，并统计路径数量。

### 推荐题目

1. **P1608 路径统计**：带权图的最短路计数问题，适合练习Dijkstra和SPFA的应用。
2. **P1144 最短路计数**：本题的无权图版本，适合练习BFS和Dijkstra的应用。
3. **P4779 【模板】单源最短路径（标准版）**：Dijkstra算法的模板题，适合练习堆优化的Dijkstra算法。

### 个人心得摘录

- **调试经历**：在处理重边和自环时，需要注意路径数量的统计方式，避免重复计数。
- **踩坑教训**：在SPFA中，如果不正确处理路径数量的统计，可能会导致结果错误。
- **顿悟感想**：BFS和Dijkstra在无权图中的效果相似，但Dijkstra可以通过堆优化提升效率。

---
处理用时：52.32秒
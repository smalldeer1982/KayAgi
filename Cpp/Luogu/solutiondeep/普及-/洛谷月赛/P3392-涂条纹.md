# 题目信息

# 涂条纹

## 题目描述

只要一个由 $N \times M$ 个小方块组成的旗帜符合如下规则，就是合法的图案。

- 从最上方若干行（至少一行）的格子全部是白色的；
- 接下来若干行（至少一行）的格子全部是蓝色的；
- 剩下的行（至少一行）全部是红色的；

现有一个棋盘状的布，分成了 $N$ 行 $M$ 列的格子，每个格子是白色蓝色红色之一，小 a 希望把这个布改成合法图案，方法是在一些格子上涂颜料，盖住之前的颜色。

小 A 很懒，希望涂最少的格子，使这块布成为一个合法的图案。

## 说明/提示

### 样例解释

目标状态是：

```plain
WWWWW
BBBBB
RRRRR
RRRRR
```
一共需要改 $11$ 个格子。

### 数据范围

对于 $100\%$ 的数据，$N,M \leq 50$。

## 样例 #1

### 输入

```
4 5
WRWRW
BWRWB
WRWRW
RWBWR```

### 输出

```
11```

# AI分析结果

### 综合分析与结论

本题的核心问题是将一个 $N \times M$ 的棋盘涂成合法的条纹图案，要求涂改的格子数最少。题解中主要采用了**枚举法**，通过枚举白色、蓝色和红色的分界线，计算每种情况下的涂改次数，最终取最小值。部分题解还使用了**前缀和**优化，减少了重复计算，提升了效率。

### 所选高星题解

#### 1. 作者：「已注销」 (5星)
- **关键亮点**：使用了前缀和优化，时间复杂度为 $O(n^2 + nm)$，代码简洁且高效。
- **代码核心思想**：
  - 预处理每一行涂成白、蓝、红所需的涂改次数，并计算前缀和。
  - 通过枚举白色和蓝色的分界线，利用前缀和快速计算总涂改次数。
- **代码片段**：
  ```cpp
  for(int i=1;i<=n;++i){
      cin>>s;
      w[i]=w[i-1]+check('W');
      b[i]=b[i-1]+check('B');
      r[i]=r[i-1]+check('R');
  }
  for(int i=1;i<n-1;++i)
      for(int j=i+1;j<n;++j)
          ans=min(ans,w[i]+b[j]-b[i]+r[n]-r[j]);
  ```

#### 2. 作者：万弘 (4星)
- **关键亮点**：通过前缀和优化，进一步减少了时间复杂度，代码清晰且易于理解。
- **代码核心思想**：
  - 预处理每一行涂成白、蓝、红所需的涂改次数，并计算前缀和。
  - 枚举白色和蓝色的分界线，利用前缀和的差分快速计算总涂改次数。
- **代码片段**：
  ```cpp
  for(int i=1;i<=n;i++){
      fW=fB=fR=0;
      for(int j=0;j<m;j++){
          if(a[i][j]!='W')fW++;
          if(a[i][j]!='B')fB++;
          if(a[i][j]!='R')fR++;
      }
      W[i]=W[i-1]+fW;
      B[i]=B[i-1]+fB;
      R[i]=R[i-1]+fR;
  }
  for(int i=2;i<n;i++){
      for(int j=i+1;j<=n;j++){
          sum=W[i-1]-W[0]+B[j-1]-B[i-1]+R[n]-R[j-1];
          if(sum<ans)ans=sum;
      }
  }
  ```

#### 3. 作者：Lolierl (4星)
- **关键亮点**：使用了前缀和优化，代码简洁且高效，时间复杂度为 $O(n^2)$。
- **代码核心思想**：
  - 预处理每一行涂成白、蓝、红所需的涂改次数，并计算前缀和。
  - 枚举白色和蓝色的分界线，利用前缀和快速计算总涂改次数。
- **代码片段**：
  ```cpp
  for(int i=1;i<=n;i++){
      sw[i]=sw[i-1];sb[i]=sb[i-1];sr[i]=sr[i-1];
      for(int j=1;j<=m;j++){
          cin>>a[i][j];
          if(a[i][j]=='W')sw[i]++;
          if(a[i][j]=='B')sb[i]++;
          if(a[i][j]=='R')sr[i]++;
      }
  }
  for(int i=1;i<=n-2;i++)
      for(int j=i+1;j<=n-1;j++)
          minv=min(minv,n*m-(sw[i]+(sb[j]-sb[i])+(sr[n]-sr[j])));
  ```

### 最优关键思路与技巧
1. **前缀和优化**：通过预处理每一行的涂改次数并计算前缀和，可以快速计算任意区间的涂改次数，减少重复计算。
2. **枚举法**：通过枚举白色和蓝色的分界线，计算每种情况下的涂改次数，最终取最小值。

### 可拓展之处
- **类似题目**：可以扩展到其他颜色组合或更复杂的图案涂改问题。
- **算法套路**：前缀和优化可以应用于其他需要快速计算区间和的场景，如动态规划、滑动窗口等。

### 推荐题目
1. [P3392 涂国旗](https://www.luogu.org/problem/P3392)
2. [P1880 石子合并](https://www.luogu.org/problem/P1880)
3. [P1049 装箱问题](https://www.luogu.org/problem/P1049)

### 个人心得摘录
- **调试经历**：部分题解提到在调试过程中发现前缀和的初始化问题，提醒在预处理时要注意边界条件。
- **顿悟感想**：通过前缀和优化，原本复杂的计算变得简单且高效，体现了算法优化的重要性。

---
处理用时：37.78秒
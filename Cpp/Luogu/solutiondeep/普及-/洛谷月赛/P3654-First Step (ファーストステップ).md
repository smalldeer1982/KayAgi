# 题目信息

# First Step (ファーストステップ)

## 题目背景

> **知らないことばかりなにもかもが（どうしたらいいの？）**    
**一切的一切 尽是充满了未知数（该如何是好）**   
**それでも期待で足が軽いよ（ジャンプだ！）**     
**但我仍因满怀期待而步伐轻盈（起跳吧！）**       
**温度差なんていつか消しちゃえってね**     
**冷若冰霜的态度 有朝一日将会消失得无影无踪**      
**元気だよ元気をだしていくよ**     
**拿出活力 打起精神向前迈进吧**     

 ![](https://cdn.luogu.com.cn/upload/pic/4471.png) 

我们 Aqours，要第一次举办演唱会啦！

虽然学生会长看上去不怎么支持我们的样子，可是有了理事长的支持，我们还是被允许在校内的篮球场里歌唱！

歌曲也好好地准备过了，名字叫“[最喜欢的话就没问题！ (ダイスキだったらダイジョウブ！)](https://zh.moegirl.org/%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98)“，大家一定会喜欢的吧！

演唱会一定会顺利进行的！

希望不要发生**停电**什么的事故哦……！


## 题目描述

可是……这个篮球场，好像很久没有使用过的样子啊……

里面堆满了学校的各种杂物呢……

我们 Aqours 的成员要怎么在里面列队站下呢？


我们浦之星女子学院的篮球场是一个 $R$ 行 $C$ 列的矩阵，其中堆满了各种学校的杂物 (用 `#` 表示)，空地 (用 `.` 表示) 好像并不多的样子呢……

我们 Aqours 现在已经一共有 $K$ 个队员了，要歌唱舞蹈起来的话，我们得排成一条 $1\times K$ 的直线，一个接一个地站在篮球场的空地上呢 (横竖均可)。

我们想知道一共有多少种可行的站位方式呢。

Aqours 的真正的粉丝的你，能帮我们算算吗？


## 说明/提示

|  | $R$ | $C$ | $K$ | 备注 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|$1\sim2$|$\leq 10$|$\leq 10$|$\leq \min(R,C)$|无|
|$3\sim4$|$\leq 100$|$\leq 100$|$\leq 1$|无|
|$5\sim6$|$\leq 100$|$\leq 100$|$\leq \min(R,C)$|没有障碍|
|$7\sim10$|$\leq 100$|$\leq 100$|$\leq \min(R,C)$|无|

对于所有数据，$1 \leq R,C \leq 100$，$1 \leq k \leq \min(R,C)$。

#### 以下是彩蛋

在 LoveLive!Sunshine!! 动画第一季第三集中，Aqours 队长高海千歌演唱“最喜欢的话就没问题！”到副歌前时，学校因为雷击停电。


## 样例 #1

### 输入

```
5 5 2
.###.
##.#.
..#..
#..#.
#.###
```

### 输出

```
8```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在给定的矩阵中找到所有可以容纳 $K$ 个队员的连续空地（横竖均可）。各题解的思路大多集中在暴力枚举、DFS、以及优化后的扫描方法上。难点在于如何处理 $K=1$ 时的重复计算问题，以及如何高效地遍历矩阵。

大部分题解都采用了暴力枚举的思路，通过遍历每个点，检查其横向和纵向是否满足条件。部分题解使用了DFS来简化代码，但本质上仍然是暴力枚举的变种。优化方面，部分题解通过预处理连续空地的长度来减少重复计算，提升了效率。

### 所选高星题解

#### 1. 作者：lin_toto (赞：81) - 5星
**关键亮点**：
- 通过预处理每行和每列的连续空地长度，优化了暴力枚举的效率。
- 详细解释了如何处理 $K=1$ 的特殊情况，避免了重复计算。
- 代码简洁，思路清晰，适合初学者理解。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){ // 先数每一行连着的空格 
    q=0;
    for(int j=1;j<=m;j++){
        if(a[i][j]=='.') q++;
        else{
            if(q>=p) ans+=q-p+1; // 那么就有q-p+1种方案 
            q=0;
        }
    }
    if(q>=p) ans+=q-p+1; // 行末再统计一次 
}
```
**实现思想**：通过遍历每行和每列，记录连续空地的长度，若长度大于等于 $K$，则累加可能的站位方式。

#### 2. 作者：鸿飞 (赞：43) - 4星
**关键亮点**：
- 直接暴力枚举每个点的横向和纵向，代码简单易懂。
- 明确指出了 $K=1$ 时的特殊情况，并进行了处理。

**核心代码**：
```cpp
for(int i=1;i<=r;i++){ // 横向搜索
    for(int j=1;j<=c;j++){
        f=true;
        for(int s=0;s<k;s++){
            if(a[i+s][j]!='.'){
                f=false;
                break;
            }
        }
        if(f==true){
            ans++;
        }
    }
}
```
**实现思想**：遍历每个点，检查其横向和纵向是否满足连续 $K$ 个空地的条件，若满足则累加结果。

#### 3. 作者：Blue_wonders (赞：36) - 4星
**关键亮点**：
- 使用DFS进行搜索，代码结构清晰。
- 明确指出了 $K=1$ 时的特殊情况，并进行了处理。

**核心代码**：
```cpp
void right(int i,int j,int r){ // x坐标，y坐标，循环次数 
    if(r==k){ // 如果循环次数和k相等 
        ans++; // 答案++ 
        return; // 结束搜索 
    }
    if(s[i][j+1]==1) right(i,j+1,r+1); // 如果向右是空的，那么可以循环，次数++； 
}
```
**实现思想**：通过DFS从每个点出发，分别向右和向下搜索，若找到连续 $K$ 个空地则累加结果。

### 最优关键思路与技巧

1. **预处理连续空地长度**：通过预处理每行和每列的连续空地长度，可以大幅减少重复计算，提升效率。
2. **DFS简化代码**：使用DFS可以简化代码结构，但本质上仍然是暴力枚举的变种。
3. **特殊处理 $K=1$**：当 $K=1$ 时，横向和纵向的搜索会重复计算，需要将结果除以2。

### 可拓展之处

- **类似题目**：可以拓展到更复杂的矩阵问题，如寻找特定形状的空地、多方向搜索等。
- **优化思路**：可以进一步优化预处理方法，如使用滑动窗口或动态规划来减少时间复杂度。

### 推荐题目

1. **P1141 01迷宫** - 考察矩阵中的连通块问题。
2. **P1162 填涂颜色** - 考察矩阵中的区域填充问题。
3. **P1219 八皇后** - 考察矩阵中的排列组合问题。

### 个人心得总结

- **调试经历**：多位作者提到在 $K=1$ 时没有进行特殊处理，导致WA，提醒我们在编写代码时要特别注意边界情况。
- **踩坑教训**：部分题解在优化时忽略了 $K=1$ 的情况，导致代码效率提升但结果错误，提醒我们在优化时要全面考虑各种情况。

---
处理用时：35.73秒
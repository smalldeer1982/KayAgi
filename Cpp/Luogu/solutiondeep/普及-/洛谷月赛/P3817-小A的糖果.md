# 题目信息

# 小A的糖果

## 题目描述

小 A 有 $n$ 个糖果盒，第 $i$ 个盒中有 $a_i$ 颗糖果。

小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 $x$，至少得吃掉几颗糖。


## 说明/提示

#### 样例输入输出 1 解释

吃掉第 2 盒中的一个糖果即可。

---

#### 样例输入输出 2 解释

第 2 盒糖吃掉 $6$ 颗，第 4 盒吃掉 $2$ 颗，第 6 盒吃掉 $3$ 颗。

---

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 20$，$a_i, x \leq 100$。
- 对于 $70\%$ 的数据，保证 $n \leq 10^3$，$a_i, x \leq 10^5$。
- 对于 $100\%$ 的数据，保证 $2 \leq n \leq 10^5$，$0 \leq a_i, x \leq 10^9$。

## 样例 #1

### 输入

```
3 3
2 2 2```

### 输出

```
1
```

## 样例 #2

### 输入

```
6 1
1 6 1 2 0 4```

### 输出

```
11```

## 样例 #3

### 输入

```
5 9
3 1 4 1 5```

### 输出

```
0
```

# AI分析结果

### 综合分析与结论

本题的核心是通过贪心算法来最小化需要吃掉的糖果数量，确保相邻两个盒子的糖果数之和不超过给定的限制 \( x \)。大多数题解都采用了类似的贪心策略：优先从后面的盒子中吃掉糖果，以减少对后续相邻盒子的影响。这种策略的关键在于每次处理相邻两个盒子时，尽量让后面的盒子承担更多的减少量，从而避免对前面盒子的重复调整。

### 所选高星题解

#### 1. 作者：a___ (赞：104)
- **星级**: 4.5
- **关键亮点**: 
  - 思路清晰，代码简洁，直接处理相邻盒子的糖果数，优先从后面的盒子中吃掉糖果。
  - 特别强调了第一个盒子的处理，避免了负数的出现。
  - 使用了 `register` 关键字优化循环变量，提升了代码效率。
- **核心代码**:
  ```cpp
  for (i=1;i<=n;i++) {
      scanf("%lld",&a[i]);
      if (a[i]+a[i-1]>x) {
          yy = a[i]+a[i-1]-x;
          a[i] -= yy;
          ans += yy;
      }
  }
  ```
- **个人心得**: 作者通过样例解释了为什么优先从后面的盒子中吃掉糖果，避免了负数的出现，确保了算法的正确性。

#### 2. 作者：myfly (赞：2)
- **星级**: 4
- **关键亮点**: 
  - 代码简洁，使用了滚动数组的思想，减少了空间复杂度。
  - 通过 `rex` 变量记录前一个盒子的糖果数，避免了数组的重复访问。
- **核心代码**:
  ```cpp
  for (int i=0,x,rex=0,sub; i<N; i++) {
      cin>>x;
      if (x+rex>M) {
          sub = x+rex-M;
          ans += sub;
          x -= sub;
      }
      rex = x;
  }
  ```
- **个人心得**: 作者通过滚动数组的方式简化了代码，减少了内存使用，同时保持了算法的正确性。

#### 3. 作者：Goes (赞：5)
- **星级**: 4
- **关键亮点**: 
  - 代码非常简洁，仅使用两个变量 `now` 和 `nex` 来记录当前和前一个盒子的糖果数。
  - 通过 `gsmax` 函数确保不会吃掉过多的糖果，避免了负数的出现。
- **核心代码**:
  ```cpp
  for(long long i=1;i<=n;i++) {
      cin>>now;
      long long del = gsmax((now+nex-x), 0);
      nex = now-del;
      ans += del;
  }
  ```
- **个人心得**: 作者通过极简的代码实现了贪心策略，展示了如何通过最少的变量和代码量解决问题。

### 最优关键思路与技巧

1. **贪心策略**: 优先从后面的盒子中吃掉糖果，以减少对后续相邻盒子的影响。
2. **滚动数组**: 使用变量记录前一个盒子的糖果数，减少空间复杂度。
3. **边界处理**: 特别处理第一个盒子，避免负数的出现。

### 可拓展之处

- **类似题目**: 类似的问题可以扩展到多维数组或更复杂的约束条件，例如多个相邻盒子的和限制。
- **算法套路**: 贪心算法在处理局部最优问题时非常有效，尤其是在需要最小化或最大化某些量的场景中。

### 推荐题目

1. [P3817 小A的糖果](https://www.luogu.com.cn/problem/P3817)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

### 个人心得总结

- **调试经历**: 多位作者提到在处理第一个盒子时容易忽略边界条件，导致负数出现。通过优先从后面的盒子中吃掉糖果，可以有效避免这一问题。
- **踩坑教训**: 未使用 `long long` 类型会导致数据溢出，特别是在处理大数据量时。
- **顿悟感想**: 贪心算法的关键在于每次选择局部最优解，通过优先处理后面的盒子，可以避免对前面盒子的重复调整，从而得到全局最优解。

---
处理用时：32.67秒
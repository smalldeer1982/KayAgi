# 题目信息

# 高兴的津津

## 题目描述

津津上高中了。她在自己的妈妈的魔鬼训练下，成为了一个神犇，每次参加一次 OI 比赛必拿 Au 虐全场。每次她拿到一个 Au 后就很高兴。假设津津不会因为其它事高兴，并且她的高兴会持续 $T$ 天（包含获奖当天。就算在高兴的时候再次拿到 Au，他的高兴也只能维持包括这次拿奖之日起 $T$ 天，而不是额外增加 $T$ 天的高兴时间，除非之后再拿奖）。请你帮忙检查一下津津接下来的的日程安排，要参加 $n$ 场比赛，看看接下来的几天，津津会累计开心多久？

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1\le n\le2\times10^5$。
- $1\le T\le10^9$。
- $1\le t_i\le 10^9$，$t_i$ 单调递增。

## 样例 #1

### 输入

```
3 5
1 2 10```

### 输出

```
11```

# AI分析结果

### 综合分析与结论

本题的核心在于计算津津的高兴天数，且需要处理高兴时间段的重复问题。大多数题解都采用了类似的思路：通过遍历比赛时间，判断相邻两次比赛的时间间隔是否小于高兴持续时间 `T`，从而决定累加的天数。这种思路的时间复杂度为 `O(n)`，能够高效处理大规模数据。

#### 关键思路与技巧：
1. **时间间隔判断**：通过比较相邻比赛的时间间隔与 `T`，决定累加的天数。如果间隔小于 `T`，则累加间隔天数；否则累加 `T`。
2. **优化空间**：部分题解通过使用变量代替数组，减少了空间复杂度，适合处理大规模数据。
3. **边界处理**：最后一天的高兴天数需要单独处理，确保累加 `T` 天。

#### 拓展思路：
- **区间合并**：可以将高兴时间段视为区间，通过区间合并的方式计算总天数。这种方法在处理更复杂的区间问题时非常有用。
- **前缀和优化**：如果比赛时间不是单调递增的，可以通过排序后使用前缀和优化计算。

### 所选高星题解

#### 1. 作者：zy小可爱ღ (4星)
**关键亮点**：
- 代码简洁，逻辑清晰，直接通过遍历比赛时间进行判断。
- 使用变量代替数组，优化了空间复杂度。

**核心代码**：
```cpp
for(int i=2;i<=n;i++){
    scanf("%d",&a[i]);
    if(a[i]-a[i-1]<t){
        ans+=a[i]-a[i-1];
    }
    else{
        ans+=t;
    }
}
printf("%d\n",ans+t);
```
**实现思想**：通过遍历比赛时间，判断相邻两次比赛的时间间隔是否小于 `T`，从而决定累加的天数。

#### 2. 作者：Lolierl (4星)
**关键亮点**：
- 代码简洁，逻辑清晰，直接通过遍历比赛时间进行判断。
- 使用变量代替数组，优化了空间复杂度。

**核心代码**：
```cpp
for(int i=2;i<=n;i++)
    if(t[i]-t[i-1]>ti)ans+=ti;else ans+=t[i]-t[i-1];
ans+=ti;
```
**实现思想**：通过遍历比赛时间，判断相邻两次比赛的时间间隔是否小于 `T`，从而决定累加的天数。

#### 3. 作者：EarthGiao (4星)
**关键亮点**：
- 代码简洁，逻辑清晰，直接通过遍历比赛时间进行判断。
- 使用变量代替数组，优化了空间复杂度。

**核心代码**：
```cpp
for(int i=1;i<=n;++i){
    scanf("%d",&a[i]);
    if(i!=1){
        int qwq=a[i]-a[i-1];
        if(qwq>m)js+=m;
        else js+=qwq;
    }
}
js+=m;
```
**实现思想**：通过遍历比赛时间，判断相邻两次比赛的时间间隔是否小于 `T`，从而决定累加的天数。

### 推荐题目
1. **P1886 滑动窗口**：考察区间合并与滑动窗口的思想。
2. **P1047 校门外的树**：考察区间合并与去重问题。
3. **P1090 合并果子**：考察贪心算法与优先队列的使用。

### 个人心得总结
- **调试经历**：部分题解提到在调试过程中发现边界问题，如最后一天的高兴天数需要单独处理。这提醒我们在编写代码时要特别注意边界条件。
- **优化技巧**：通过使用变量代替数组，可以有效减少空间复杂度，适合处理大规模数据。

---
处理用时：26.74秒
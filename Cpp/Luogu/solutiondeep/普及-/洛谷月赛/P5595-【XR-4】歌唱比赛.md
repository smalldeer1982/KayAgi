# 题目信息

# 【XR-4】歌唱比赛

## 题目背景

**赛时提醒：本题不提供任何关于样例 4 以及无解的解释。**

**赛时提醒：本题不提供任何关于输出格式以及 Special Judge 的解释。**

**赛时提醒：抱歉，本题的 Special Judge 不忽略行末空格，请保证两行中没有多余字符。**

**赛时提醒：非常抱歉，本题输入数据是 Windows 格式，而非 Linux 格式，所以在末尾的 `\n` 之前有一个多余的 `\r` 字符。请使用 `scanf` 或 `cin` 读入数据，而非 `getline`，因为后者会多读入一个 `\r`。**

## 题目描述

小 X 参加了一场歌唱比赛。

经过一路鏖战，小 X 终于挺进了决赛，他的对手是小 Y。

这场歌唱比赛的冠军是由点赞数决定的，谁的点赞数高，谁就能夺冠。

小 X 和小 Y 依次演唱完自己的最后一首歌曲后，他们最终的点赞数确定了下来。

揭晓冠军的时刻终于到来了，主持人为了增加悬念，决定从小 X 与小 Y 的点赞数的最后一位开始，依次比较。

比如，小 X 的点赞数是 $37$，小 Y 的点赞数是 $28$。首先比较最后一位，小 X 是 $7$，小 Y 是 $8$，此时小 Y 暂时领先。再加上前一位，小 X 是 $37$，小 Y 是 $28$，此时小 X 暂时领先。比较结束，如果我们用 `X` 代表小 X 暂时领先，`Y` 代表小 Y 暂时领先，那么可以写下一个字符串 `XY`。

再比如，小 X 的点赞数是 $137$，小 Y 的点赞数是 $47$。如果我们再用 `Z` 表示小 X 与小 Y 的点赞数暂时一样，那么写下的字符串应该为 `XYZ`。

你作为一个精通 OI 的神仙，自然知道这种比较方式是非常不科学的，这样只是在无端拖延时间罢了，但是你却对最后写下的这个字符串很感兴趣。

现在，你得到了这个最后写下的字符串，你需要构造出一种可能的小 X 与小 Y 的点赞数。

当然，有可能不存在任何一种情况的点赞数满足这个字符串，那么你只需要输出 `-1` 即可。

为了方便你输出，请用前导零来补足位数。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（11 points）：$\text{len}(s) = 1$。
- Subtask 2（42 points）：$s_i \in \{\texttt{X},\texttt{Y}\}$。
- Subtask 3（21 points）：数据保证有解。
- Subtask 4（26 points）：无特殊限制。

对于 $100\%$ 的数据，$s_i \in \{\texttt{X},\texttt{Y},\texttt{Z}\}$，$1 \le \text{len}(s) \le 10^6$。

## 样例 #1

### 输入

```
XY
```

### 输出

```
37
28
```

## 样例 #2

### 输入

```
XYZ
```

### 输出

```
137
047
```

## 样例 #3

### 输入

```
ZZZZZZ
```

### 输出

```
000000
000000
```

## 样例 #4

### 输入

```
XYZXYZ
```

### 输出

```
-1
```

# AI分析结果

### 综合分析与结论

本题的核心是通过给定的字符串构造两个数字，使得从最后一位开始逐位比较时，结果与字符串中的字符一致。难点在于处理字符 `Z`（表示相等）的情况，尤其是当 `Z` 出现在字符串中间时，可能导致无解。大多数题解都采用了从后向前遍历字符串的方法，通过判断 `Z` 是否出现在非末尾位置来判断无解情况，并利用简单的赋值策略（如 `0` 和 `1`）来构造满足条件的数字。

### 评分较高的题解

#### 1. **作者：StudyingFather (5星)**
- **关键亮点**：思路清晰，代码简洁，直接从后向前遍历字符串，利用 `flag` 判断无解情况，构造数字时使用 `0` 和 `9` 来确保大小关系。
- **代码实现**：
  ```cpp
  for(int i=len-1;i>=0;i--) {
      if(s[i]!='Z')flag=false;
      if(s[i]=='Z'&&!flag) {
          puts("-1");
          return 0;
      }
      if(s[i]=='Z')s1[i]=s2[i]='0';
      else if(s[i]=='X')s1[i]='9',s2[i]='0';
      else s1[i]='0',s2[i]='9';
  }
  ```
- **个人心得**：通过从后向前遍历，简化了无解情况的判断，代码逻辑清晰。

#### 2. **作者：VenusM1nT (4星)**
- **关键亮点**：同样从后向前遍历，使用 `fg` 标志判断无解，构造数字时使用 `1` 和 `2` 来确保大小关系。
- **代码实现**：
  ```cpp
  for(reg int i=n;i>=1;i--) {
      if(ch[i]=='Z' && fg) return puts("-1"),0;
      if(ch[i]=='X') x[i]='2',y[i]='1',fg=1;
      else if(ch[i]=='Y') x[i]='1',y[i]='2',fg=1;
      else if(ch[i]=='Z') x[i]=y[i]='0';
  }
  ```
- **个人心得**：通过 `fg` 标志简化了无解判断，代码简洁高效。

#### 3. **作者：ShineEternal (4星)**
- **关键亮点**：从后向前遍历，使用 `pd` 标志判断无解，构造数字时使用 `0` 和 `1` 来确保大小关系。
- **代码实现**：
  ```cpp
  for(register int i=n-1;i>=0;i--) {
      if(s[i]=='X') a[i]=1;
      if(s[i]=='Y') b[i]=1;
  }
  ```
- **个人心得**：通过 `pd` 标志简化了无解判断，代码逻辑清晰。

### 最优关键思路与技巧

1. **从后向前遍历**：通过从后向前遍历字符串，可以更容易地处理 `Z` 的情况，尤其是在判断无解时。
2. **无解判断**：通过一个标志变量（如 `flag` 或 `fg`）来判断 `Z` 是否出现在非末尾位置，从而快速判断无解。
3. **简单赋值策略**：使用 `0` 和 `1` 或 `0` 和 `9` 等简单的赋值策略来构造满足条件的数字，确保大小关系。

### 拓展与举一反三

- **类似题目**：可以考虑类似构造题，如给定某些条件，要求构造满足特定关系的数字或字符串。
- **算法套路**：从后向前遍历、标志变量判断无解、简单赋值策略等技巧在其他构造题中也非常常见。

### 推荐题目

1. **P3742 umi的函数**：构造满足特定条件的函数。
2. **P5595 [XR-4] 歌唱比赛**：本题的变种或类似构造题。
3. **P5596 [XR-4] 歌唱比赛2**：进一步考察构造能力。

### 个人心得总结

- **调试经历**：多位作者提到在判断无解时容易忽略 `Z` 出现在中间的情况，导致错误。
- **顿悟感想**：通过从后向前遍历和标志变量的使用，可以大大简化无解判断和构造过程。

---
处理用时：38.02秒
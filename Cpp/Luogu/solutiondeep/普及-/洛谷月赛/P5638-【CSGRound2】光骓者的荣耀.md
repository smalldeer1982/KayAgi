# 题目信息

# 【CSGRound2】光骓者的荣耀

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/s6ozu5pj.png)

小 K 又在做白日梦了。他进入到他的幻想中，发现他打下了一片江山。

## 题目描述

小 K 打下的江山一共有 $n$ 个城市，城市 $i$ 和城市 $i+1$ 有一条双向高速公路连接，走这条路要耗费时间 $a_i$。

小 K 为了关心人民生活，决定定期进行走访。他每一次会从 $1$ 号城市到 $n$ 号城市并在经过的城市进行访问。其中终点必须为城市 $n$。

不仅如此，他还有一个传送器，传送半径为 $k$，也就是可以传送到 $i-k$ 和 $i+k$。如果目标城市编号小于 $1$ 则为 $1$，大于 $n$ 则为 $n$。

但是他的传送器电量不足，只能传送一次，况且由于一些原因，他想尽量快的完成访问，于是就想问交通部部长您最快的时间是多少。

注意：**他可以不访问所有的城市，使用传送器不耗费时间**。

## 说明/提示

### 样例解释 1：

样例 1,2 的图示均为以下图片：

![MZbuTK.png](https://s2.ax1x.com/2019/11/08/MZbuTK.png)

不使用传送器直接走，答案为 $6$，可以证明这个是最小值。

### 样例解释 2：

在 $3$ 处使用，传送到 $4$，答案为 $3$，可以证明这个是最小值。

### 数据范围：

对于所有数据，$a_i > 0$

![Kvrl34.jpg](https://s2.ax1x.com/2019/11/04/Kvrl34.jpg)

## 样例 #1

### 输入

```
4 0
1 2 3```

### 输出

```
6```

## 样例 #2

### 输入

```
4 1
1 2 3```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地找到一段长度为 `k` 的连续区间，使得跳过这段区间后，总时间最小。大多数题解都采用了前缀和优化，通过预处理前缀和数组，快速计算任意区间的和，从而在 `O(n)` 时间内找到最大可跳过的区间。部分题解还使用了滑动窗口、贪心等技巧进一步优化。

### 所选高星题解

#### 1. **作者：Mophie (5星)**
- **关键亮点**：详细分析了暴力枚举、贪心优化、滑动窗口优化等多种思路，最终给出了 `O(n)` 的满分解法。代码简洁，思路清晰，且提供了多种优化路径，适合不同水平的读者。
- **个人心得**：作者在优化过程中提到“灵光一闪”，意识到可以通过滑动窗口优化区间和的计算，减少了重复计算，体现了算法优化中的思维跳跃。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000001],k,Max,now,cnt;
int main() 
{
	cin>>n>>k;
	for(int i=1;i<=n-1;i++)
	{
		cin>>a[i];
		cnt+=a[i];
	}
	for(int i=1;i<=k;i++)Max+=a[i],now+=a[i];
	for(int i=2;i<=n-k;i++)
	{
		now=now-a[i-1]+a[i+k-1];//i+1->i+k
		Max=max(Max,now);
	}
	cout<<cnt-Max<<endl;
	return 0; 
}
```

#### 2. **作者：沉冥Charming (4星)**
- **关键亮点**：通过贪心策略，直接找到最大可跳过的区间，使用前缀和优化计算。代码简洁，思路清晰，且特别强调了从 `0` 开始循环的细节，避免了常见的边界错误。
- **个人心得**：作者提到“从0开始循环就可以ac了”，强调了边界条件的重要性，提醒读者在编写代码时要注意细节。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
#define ull unsigned long long
#define ll unsigned long long
ull n,k,sum[1000005],cnt;
int main()
{
    n=qr(),k=qr();
    for (int i=1; i<n; i++)
    {
        ull a;
        a=qr();
        sum[i]=sum[i-1]+a;
    }
    for (int i=0; i+k<n; i++)
        cnt=max(cnt,sum[i+k]-sum[i]);
    cout<<sum[n-1]-cnt;
    return 0;
}
```

#### 3. **作者：StudyingFather (4星)**
- **关键亮点**：通过前缀和快速计算区间和，简洁明了地解决了问题。代码结构清晰，且特别处理了 `k >= n` 的情况，避免了不必要的计算。
- **个人心得**：作者提到“只需预处理前缀和，即可在 `O(n)` 的时间内求出答案”，强调了前缀和在区间和计算中的高效性。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
long long sum[1000005];
int main()
{
 ios::sync_with_stdio(false);
 int n,k;
 cin>>n>>k;
 for(int i=1;i<n;i++)
 {
  long long x;
  cin>>x;
  sum[i]=sum[i-1]+x;
 }
 if(k>=n)cout<<0<<endl;
 else
 {
  long long ans=0;
  for(int i=k;i<n;i++)
   ans=max(ans,sum[i]-sum[i-k]);
  cout<<sum[n-1]-ans<<endl;
 }
 return 0;
}
```

### 最优关键思路与技巧

1. **前缀和优化**：通过预处理前缀和数组，快速计算任意区间的和，时间复杂度为 `O(n)`。
2. **滑动窗口**：在计算区间和时，通过滑动窗口减少重复计算，进一步优化时间复杂度。
3. **贪心策略**：直接跳过最长的 `k` 段区间，确保总时间最小。

### 可拓展之处

- **类似问题**：类似的问题包括寻找最大子数组和、最小子数组和等，都可以通过前缀和和滑动窗口优化。
- **数据结构**：前缀和和滑动窗口的技巧可以应用于其他区间查询问题，如区间最大值、最小值等。

### 推荐题目

1. **P1115 最大子段和**：考察前缀和和滑动窗口的应用。
2. **P1886 滑动窗口**：经典的滑动窗口问题，适合练习区间查询。
3. **P1631 序列合并**：通过前缀和和贪心策略解决区间合并问题。

### 个人心得总结

- **边界条件**：在编写代码时，特别注意边界条件，如从 `0` 开始循环，避免漏解。
- **优化思维**：在优化算法时，尝试减少重复计算，如通过滑动窗口优化区间和的计算。
- **调试经验**：在调试过程中，注意特判情况，如 `k >= n` 时直接输出 `0`，避免不必要的计算。

---
处理用时：46.75秒
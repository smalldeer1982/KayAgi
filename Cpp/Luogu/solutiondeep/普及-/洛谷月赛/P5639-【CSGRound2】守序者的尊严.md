# 题目信息

# 【CSGRound2】守序者的尊严

## 题目背景

由于 Y 校最近进行了对学校食堂的全面改革与对小卖部的全面整治(乱搞)，导致学校小卖部卖的零食被禁售了；学校食堂的炸鸡窗口也消失了；

并且学校的学生处 Q 主任严禁学生点外卖，日夜监察。

都说民以食为天，由于整天挨饿，全校同学处于水深火热之中。

## 题目描述

zhouwc 的朋友（朋友就是自己系列）小 Z 由于饥饿难忍，不得不铤而走险点外卖。

但是学校的 Q 主任为了能够抓住点外卖的学生布置了天罗地网——监控。

但是由于学校给 Q 主任的经费有限，所以这些监控不能持续工作，工作一秒之后便要暂停休息一秒，**即开启一秒后关闭一秒再开启一秒...以此类推**。

还是由于 Q 主任的经费有限，这些监控被排成了一条直线，这条直线便在学生通往学生外卖驻点——二号门（没有门卫）的必经之路上。

因为小 Z 修习了疾跑技能，所以小 Z 通过任意个数关闭的监控的时间均为 
 $1$（即一次行动可以经过若干个未开的监控）。

由于小 Z 想吃外卖又不想受到正在监控室看着监控的 Q 主任的处分，请你告诉他至少要多少时间才能安全到达外卖驻点。

## 说明/提示

#### 数据范围：

对于 $10\%$ 的数据，$1 \leq n \leq 10$

对于 $30\%$ 的数据，$1 \leq n \leq 100$

对于 $50\%$ 的数据，$1 \leq n \leq 10^3$

对于 $70\%$ 的数据，$1 \leq n \leq 10^5$

对于$100\%$的数据，$1 \leq n \leq 10^6$

监控的开关情况均用 $0$ 和 $1$ 来表示。

#### 样例解释一：

小 Z 在第一秒时冲到第二个监控处，用时 $1$ 秒，总用时 $1$ 秒。

第二秒时，监控的开关状况变为了 $1 1 0 0 1 0$。

这时，小 Z 迅速从二号监控处冲到了四号监控处，用时 $1$ 秒，总用时 $2$ 秒。

第三秒时，监控的开关状况变为了 $0 0 1 1 0 1$。

这时，小 Z 迅速从四号监控处冲到了五号监控处，用时 $1$ 秒，总用时 $3$ 秒。

第三秒时，监控的开关状况变为了 $1 1 0 0 1 0$。

这时，小 Z 迅速从五号监控处冲出了监控区域，用时 $1$ 秒，总用时 $4$ 秒。

#### 样例解释二

小Z在第一秒直接冲出了监控区域。

## 样例 #1

### 输入

```
6
0 0 1 1 0 1```

### 输出

```
4```

## 样例 #2

### 输入

```
6
0 0 0 0 0 0```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心在于理解监控的开关规律，并将其转化为求连续相同状态的监控段数。大多数题解都抓住了这一关键点，通过遍历监控序列，统计状态变化的次数来求解。虽然部分题解使用了模拟的方法，但最优解法的时间复杂度为O(n)，空间复杂度为O(1)，符合题目要求。

### 精选题解

#### 1. **作者：zhouwc (官方题解)**
- **星级：★★★★★**
- **关键亮点**：思路清晰，直接指出问题本质，代码简洁高效。
- **核心思想**：统计监控序列中状态变化的次数，初始状态为1，每次状态变化时答案加1。
- **代码片段**：
  ```cpp
  int ans = 1;
  for (int i = 2; i <= n; i++)
      if (a[i] != a[i-1]) ans++;
  printf("%d\n", ans);
  ```

#### 2. **作者：StudyingFather**
- **星级：★★★★☆**
- **关键亮点**：代码简洁，直接使用变量记录前一个状态，避免了数组的额外空间开销。
- **核心思想**：通过比较当前状态与前一个状态，统计状态变化的次数。
- **代码片段**：
  ```cpp
  int lastx = 1;
  for (int i = 1; i <= n; i++) {
      int x;
      scanf("%d", &x);
      if (lastx != x) ans++, lastx = x;
  }
  printf("%d\n", ans);
  ```

#### 3. **作者：Phoenix_lily**
- **星级：★★★★☆**
- **关键亮点**：详细解释了监控开关的规律，代码实现清晰。
- **核心思想**：通过遍历监控序列，统计状态变化的次数，初始状态为1。
- **代码片段**：
  ```cpp
  bool last = 1;
  for (int i = 1; i <= n; i++) {
      cin >> kkk;
      if (kkk != last) ans++;
      last = kkk;
  }
  cout << ans;
  ```

### 最优关键思路与技巧

1. **状态变化统计**：通过遍历监控序列，统计状态变化的次数，直接求解问题。
2. **空间优化**：使用变量记录前一个状态，避免使用额外数组，优化空间复杂度。
3. **初始状态处理**：初始状态为1，确保第一个监控的处理正确。

### 拓展思路与同类型题

1. **类似题目**：
   - [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)：考察区间覆盖与统计。
   - [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：区间处理与统计。
   - [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)：统计与去重。

2. **调试与顿悟**：部分题解中提到通过样例推导出问题本质，建议在解题时多通过样例验证思路，避免复杂模拟。

### 总结

本题的最优解法通过统计状态变化次数，避免了复杂的模拟过程，代码简洁高效。建议在类似题目中，优先考虑状态变化统计的思路，减少不必要的计算与空间开销。

---
处理用时：29.81秒
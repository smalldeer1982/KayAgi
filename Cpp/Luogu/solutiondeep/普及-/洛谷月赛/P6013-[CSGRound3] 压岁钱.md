# 题目信息

# [CSGRound3] 压岁钱

## 题目背景

祝大家庚子鼠年快乐！Best wishes! 

也愿肺炎早日得到控制吧，中国加油！

新年到了，小 Z 总是能收到很多的压岁钱。

小 Z 是个非常喜欢氪金的玩家，所以时不时都会把压岁钱花掉一部分用来买皮肤和石头。

但是小 Z 又十分担心压岁钱没过几天就都被自己花完了。为此，小 Z 有封印大法，能够暂时的把自己的一部分钱封印起来（即无法花费），直到某一天解除封印后才能使用。

## 题目描述

一共存在有 $m$ 个事件，且事件分为以下的 $3$ 种类型。

1. 小 Z 得到了 $a$ 元压岁钱。
2. 小 Z 花掉了 $a$ 元压岁钱用于买皮肤。
3. 小 Z 把自己的 $a$ 元钱封印了起来，只有当第 $b$ 个事件发生前 $1$ 秒才会解除封印，并保证每次小 Z 现有的钱大于等于封印的钱。

当小 Z 的钱在某个事件不够花时，小 Z 会感到不开心，同时钱不够花时小 Z 便不会花钱。

请告诉小 Z ，他的钱在几个事件中会不够花。

## 说明/提示

**【样例 1 解释】**

第一天：收入 $10$ 元，余额 $10$ 元。

第二天：不够支出 $20$ 元，余额 $10$ 元。

第三天：支出 $10$ 元，余额 $0$ 元。

总计：$1$ 天。

**【样例 2 解释】**

第一天：收入 $10$ 元，余额 $10$ 元。

第二天：封印 $5$ 元，余额 $5$ 元。

第三天：不够支出 $10$ 元，余额 $5$ 元。

第四天：收入 $10$ 元，余额 $15$ 元。

第五天：封印解开，支出 $20$ 元，余额 $0$ 元。

总计：$1$ 天。

---

**【数据范围】**

对于 $50\%$ 的数据，满足 $m,a \leq 5\times 10^3$。

对于 $70\%$ 的数据，$t \ne 3$。

对于 $100\%$ 的数据，满足 $ 1 \leq b \le m \leq 10^6$，$1 \le t \le 3$，$1 \leq a \leq 10^7$。

## 样例 #1

### 输入

```
3
1 10
2 20
2 10```

### 输出

```
1```

## 样例 #2

### 输入

```
5
1 10
3 5 5
2 10
1 10
2 20```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心是通过模拟事件来处理压岁钱的收入、支出和封印操作。难点在于如何高效处理封印操作，确保在解封时能够正确恢复封印的钱。大多数题解采用了数组或优先队列来记录解封事件，并通过遍历或堆结构来动态更新当前的钱数。总体思路较为一致，但实现细节和优化程度有所不同。

### 所选高星题解

#### 1. 作者：梦里调音 (5星)
- **关键亮点**：代码简洁明了，直接使用数组记录解封事件，处理逻辑清晰。通过`f[b] += a`来记录解封事件，避免了复杂的堆操作。
- **个人心得**：强调了“十年OI一场空，不开long long见祖宗”，提醒了数据范围的重要性。
- **核心代码**：
  ```cpp
  unsigned long long f[N]; // f[i]表示第i个事件前要解封的钱
  for(unsigned long long i=1,t;i<=m;i++) {
      n += f[i];
      cin >> t;
      if(t == 1) {
          unsigned long long a;
          cin >> a;
          n += a;
      } else if(t == 2) {
          unsigned long long a;
          cin >> a;
          if(n < a) ans++;
          else n -= a;
      } else {
          unsigned long long a, b;
          cin >> a >> b;
          f[b] += a;
          n -= a;
      }
  }
  ```

#### 2. 作者：StudyingFather (4星)
- **关键亮点**：使用了优先队列来管理解封事件，确保在每次支出时都能及时解封所有符合条件的钱。虽然代码稍复杂，但思路清晰，适合处理更复杂的解封逻辑。
- **核心代码**：
  ```cpp
  priority_queue<pii, vector<pii>, greater<pii>> q;
  for(int i=1;i<=m;i++) {
      int op, a, b;
      cin >> op;
      if(op == 1) {
          cin >> a;
          x += a;
      } else if(op == 2) {
          cin >> a;
          while(!q.empty() && q.top().first <= i) {
              x += q.top().second;
              q.pop();
          }
          if(x >= a) x -= a;
          else ans++;
      } else {
          cin >> a >> b;
          q.push({b, a});
          x -= a;
      }
  }
  ```

#### 3. 作者：KazamiHina (4星)
- **关键亮点**：代码结构清晰，使用数组记录解封事件，处理逻辑简单直接。通过`w[b] += a`来记录解封事件，避免了复杂的堆操作。
- **核心代码**：
  ```cpp
  int w[1000005]; // w数组用来储存封印的钱
  for(int i=1;i<=n;i++) {
      ans += w[i];
      scanf("%lld", &opt);
      if(opt == 1) {
          scanf("%lld", &a);
          ans += a;
      } else if(opt == 2) {
          scanf("%lld", &a);
          if(ans < a) tot++;
          else ans -= a;
      } else if(opt == 3) {
          scanf("%lld%lld", &a, &b);
          ans -= a;
          w[b] += a;
      }
  }
  ```

### 最优关键思路与技巧

1. **数组记录解封事件**：通过数组`f[i]`或`w[i]`记录第`i`个事件前要解封的钱数，简化了解封操作的处理。
2. **优先队列管理解封事件**：使用优先队列可以动态管理解封事件，确保在每次支出时都能及时解封所有符合条件的钱。
3. **数据范围处理**：由于数据范围较大，使用`long long`来避免溢出问题。

### 可拓展之处

- **同类型题**：类似的事件模拟题可以通过数组或优先队列来管理事件，确保在每次操作时都能正确更新状态。
- **算法套路**：事件模拟题通常需要动态管理状态，优先队列和数组是常用的数据结构。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3378 堆](https://www.luogu.com.cn/problem/P3378)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

---
处理用时：36.88秒
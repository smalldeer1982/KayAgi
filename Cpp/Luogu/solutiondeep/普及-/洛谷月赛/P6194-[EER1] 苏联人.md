# 题目信息

# [EER1] 苏联人

## 题目背景

~~题目名称是吸引你点进来的。~~

这是一道正常的题，和苏联没有任何关系。

## 题目描述

你在打 EE Round 1，发现第一题非常无聊。于是你不打了，去下国际象棋了。

结果你发现，由于神秘力量的影响，你的棋子只剩下若干黑色的战车，若干黑色的主教和一只白色的国王了。

由于你很无聊，所以你把一些黑色棋子放在了 $8\times 8$ 的棋盘上。

由于你很无聊，所以你想知道，国王放在哪些格子是安全的。换句话说，有哪些格子不会被战车和主教攻击到。当然，**国王不能放在已经有棋子的地方**。

为了防止你无聊透顶而不知道国际象棋的规则，这里给出以下提示（如果你知道规则那么可以跳过）：

国际象棋中，战车可以横向、竖向移动，且格数不受限制。但**不能越过其他棋子**。

![](https://cdn.luogu.com.cn/upload/image_hosting/5symt5td.png)

如图，黄色的格子为战车能走到（攻击到）的格子。

国际象棋中，主教可以斜向移动，且格数不受限制。但**不能越过其他棋子**。

![](https://cdn.luogu.com.cn/upload/image_hosting/skmw1njm.png)

如图，黄色的格子为主教能走到（攻击到）的格子。

简单来说，如果当前位置到目标位置的**直线**上存在其他棋子，则可以称为“越过了其他棋子”。

如果目标位置是对方的棋子，那么移动到目标位置后，对方的棋子会被吃掉。

更进一步地，你要找的所有位置，必须满足没有黑色棋子能一步走到。

---

如果你还是没有读懂，可以结合样例进行理解。

## 说明/提示

对于 $100\%$ 的数据，保证只会出现 `.`，`R`，`B` 三种字符。

本题共有 $4$ 个子任务，每个子任务的限制如下：

子任务 $1$（$10$ 分）：保证只会出现 `.`。

子任务 $2$（$20$ 分）：保证只会出现一个 `R` 或一个 `B`（不同时出现）。

子任务 $3$（$30$ 分）：保证只有一个 `.`。

子任务 $4$（$40$ 分）：没有特殊限制。

## 样例 #1

### 输入

```
........
........
........
..B..R..
........
........
........
........
```

### 输出

```
11111011
01110011
10101011
11000000
10101011
01110011
11111011
11111001
```

# AI分析结果

### 综合分析与结论

这些题解大多采用了模拟的思路，通过遍历棋盘上的每个棋子，并根据其类型（战车或主教）标记其攻击范围。难点在于如何处理棋子不能越过其他棋子的规则，以及如何高效地标记攻击范围。大部分题解通过循环或递归实现了这一功能，代码结构较为相似，但部分题解在代码优化、可读性、以及边界处理上表现更好。

### 所选高星题解

#### 1. 作者：幻之陨梦 (5星)
- **关键亮点**：代码结构清晰，逻辑简洁，通过四重循环分别处理战车和主教的攻击范围，边界处理得当，代码可读性高。
- **个人心得**：作者提到不能一边读入一边处理，强调了先读入整个棋盘再进行处理的正确性。

```cpp
for(int k=i-1;k>=0 && ch[k][j]=='.';k--) ans[k][j]=1; // 战车向上
for(int k=i+1;k<8 && ch[k][j]=='.';k++) ans[k][j]=1; // 战车向下
for(int k=j-1;k>=0 && ch[i][k]=='.';k--) ans[i][k]=1; // 战车向左
for(int k=j+1;k<8 && ch[i][k]=='.';k++) ans[i][k]=1; // 战车向右
```

#### 2. 作者：MZY666 (4星)
- **关键亮点**：代码注释详细，逻辑清晰，通过函数封装了战车和主教的攻击范围标记，代码结构较为模块化。
- **个人心得**：作者在博客中详细解释了战车和主教的攻击范围，帮助读者理解代码逻辑。

```cpp
for(int k=1;i-k&&j-k;k++){ // 主教左上
    if(a[i-k][j-k]!='.') break;
    p[i-k][j-k]=true;
}
```

#### 3. 作者：SamariumPhosphide (4星)
- **关键亮点**：通过函数封装了战车和主教的攻击范围标记，代码结构清晰，逻辑简洁，边界处理得当。
- **个人心得**：作者通过图示解释了战车和主教的攻击范围，帮助读者理解代码逻辑。

```cpp
void castle(int x, int y) { // 战车攻击范围
    for (int i = x - 1; i >= 1; i--) {
        if (board[i][y]) break;
        notok[i][y] = true;
    }
}
```

### 最优关键思路与技巧

1. **先读入再处理**：避免在读取棋盘时立即处理，确保所有棋子信息完整后再进行攻击范围的标记。
2. **循环与递归结合**：通过循环或递归遍历棋子的攻击范围，确保不越过其他棋子。
3. **边界处理**：在遍历时始终检查边界条件，避免数组越界。
4. **模块化设计**：将战车和主教的攻击范围标记封装成函数，提高代码的可读性和复用性。

### 可拓展之处

- **类似问题**：可以扩展到其他棋类游戏，如中国象棋、围棋等，处理棋子的攻击范围或移动规则。
- **算法优化**：可以考虑使用位运算或更高效的数据结构来优化攻击范围的标记过程。

### 推荐题目

1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - 处理棋子的攻击范围，避免冲突。
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443) - 处理棋子的移动范围，标记可达位置。
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - 类似棋盘标记问题，处理边界和区域填充。

### 个人心得总结

- **调试经验**：多位作者提到在调试过程中遇到的边界问题，强调了边界检查的重要性。
- **顿悟感想**：部分作者通过图示或详细注释帮助理解代码逻辑，强调了代码可读性和注释的重要性。

---
处理用时：36.32秒
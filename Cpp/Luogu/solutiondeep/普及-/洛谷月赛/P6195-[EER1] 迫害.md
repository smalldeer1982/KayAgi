# 题目信息

# [EER1] 迫害

## 题目背景

"In Germany they first came for the Communists,　

and I didn't speak up because I wasn't a Communist.　　

Then they came for the Jews,　　

and I didn't speak up because I wasn't a Jew.　　

Then they came for the trade unionists,　　

and I didn't speak up because I wasn't a trade unionist.

Then they came for the Catholics,　　

and I didn't speak up because I was a Protestant.　　

Then they came for me ,

and by that time no one was left to speak up."

-- Pastor Martin Niemöller

”起初他们迫害共产党员，我没有说话，因为我不是马克思的信徒。

后来他们迫害犹太人，我没有说话，因为我是日耳曼人。

再后来他们迫害天主教徒，我没有说话，因为我是新教牧师。

最后他们迫害到我头上，我环顾四周，却再也没有人能为我说话。”

## 题目描述

有 $k$ 个人，X 要对这 $k$ 个人进行迫害。

这 $k$ 个人，每一个人都拥有一个数字，分别从 $1$ 至 $k$。

X 拥有 $n+m$ 个数字，这些数字为 $n$ 个 $1$ 和 $m$ 个大小可由 X 决定的数字（每个数字定好之后不能更换）。

X 能对这些人进行迫害，当且仅当他能用手中若干个数的加和等于被迫害人的数字，一次迫害就成功了（不会消耗数字）。

由于 X 的权利极大，又十分邪恶，他想要从第 $1$ 个人开始**一个一个**进行迫害行动。

由于小 Z 也在这个被迫害的行列里，他十分的慌张，希望你来告诉他 X 能最多能从第一个人开始连续迫害多少个人。

由于被迫害的人太多了，所以请将答案对 $1000000007$ 取模。

## 说明/提示

**【样例 1 解释】**

X 选取 $2$ 个数分别为 $2,4$，可知能连续迫害 $7$ 个人。

**【样例 2 解释】**

X 选取 $2$ 个数分别为 $3,6$，可知能连续迫害 $11$ 个人。

---

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（50 points）：$1 \le n \le 5$，$1 \le m \le 5$。
- Subtask 2（30 points）：保证答案在取模前在 $10^{18}$ 之内。
- Subtask 3（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10^6 $，$1 \le m \le 10^9 $。

## 样例 #1

### 输入

```
1 2```

### 输出

```
7```

## 样例 #2

### 输入

```
2 2```

### 输出

```
11```

# AI分析结果

### 综合分析与结论

本题的核心在于通过贪心策略和数学推导，找到如何利用给定的 $n$ 个 $1$ 和 $m$ 个自定义数字，最大化能够连续迫害的人数。多数题解通过观察样例和数学归纳法，得出了相同的结论：最大连续迫害人数为 $2^m \times (n+1) - 1$。由于 $m$ 的范围较大（$1 \le m \le 10^9$），直接计算 $2^m$ 会超时，因此需要使用快速幂算法来优化计算。

### 所选高星题解

#### 1. 作者：CSP_Sept (5星)
- **关键亮点**：详细推导了递推公式，并通过快速幂优化了计算过程。代码简洁且高效，适合初学者理解。
- **个人心得**：作者通过多次优化代码，最终解决了TLE问题，展示了调试和优化的过程。
- **核心代码**：
```cpp
ll qpow(ll a, ll b) {
    ll ans = 1;
    while (b > 0) {
        if (b & 1) ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans % mod;
}
```
- **实现思想**：通过快速幂算法计算 $2^m$，避免了直接计算的高时间复杂度。

#### 2. 作者：Islauso (4星)
- **关键亮点**：通过等比数列的求和公式推导出最终答案，思路清晰，代码简洁。
- **核心代码**：
```cpp
ll ksm(ll b, ll k) {
    ll ans = 1;
    while (k) {
        if (k & 1) ans = ans * b % p;
        b = b * b % p;
        k >>= 1;
    }
    return ans % p;
}
```
- **实现思想**：使用快速幂计算 $2^m$，并结合推导出的公式直接输出结果。

#### 3. 作者：Hexarhy (4星)
- **关键亮点**：通过样例分析得出规律，并使用快速幂优化计算，代码简洁且高效。
- **核心代码**：
```cpp
ll fpow(ll b, ll p) {
    ll ans = 1;
    while (p) {
        if (p & 1) ans = ans * b % MOD;
        b = b * b % MOD;
        p >>= 1;
    }
    return ans;
}
```
- **实现思想**：通过快速幂计算 $2^m$，并结合推导出的公式直接输出结果。

### 最优关键思路与技巧
1. **贪心策略**：每次选择的自定义数字应尽可能大，以确保能够覆盖更多的连续数字。
2. **数学归纳法**：通过观察样例和数学推导，得出通用的公式 $2^m \times (n+1) - 1$。
3. **快速幂算法**：用于高效计算 $2^m$，避免直接计算的高时间复杂度。

### 可拓展之处
- **类似问题**：类似的问题可以通过贪心策略和数学归纳法解决，如最小覆盖问题、最大连续子序列和等。
- **算法套路**：快速幂算法在处理大指数问题时非常有用，可以应用于其他需要高效计算幂次的场景。

### 推荐题目
1. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)
2. [P1965 转圈游戏](https://www.luogu.com.cn/problem/P1965)
3. [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)

### 个人心得总结
- **调试与优化**：多次优化代码，解决TLE问题，展示了调试和优化的过程。
- **顿悟与感想**：通过样例分析和数学推导，最终得出通用公式，展示了从具体到抽象的思维过程。

---
处理用时：30.33秒
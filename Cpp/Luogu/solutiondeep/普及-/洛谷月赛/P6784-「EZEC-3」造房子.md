# 题目信息

# 「EZEC-3」造房子

## 题目背景

pigstd 要去造房子了。

## 题目描述

pigstd 有 $a$ 个 A 材料和 $b$ 个 B 材料，造**第** $i$ 层楼需要 $i$ 个 A 材料与 $i$ 个 B 材料。

但是 pigstd 觉得房子不够高，于是他拿出了 $c$ 块钱，每块钱都可以用来买 $1$ 个 A 材料或者 $1$ 个 B 材料。

现在 pigstd 想知道，他最多能建多少层楼的房子。

## 说明/提示

**【样例 1 说明】**

pigstd 买 $2$ 个 A 材料和 $1$ 个 B 材料后就有 $3$ 个 A 材料和 $3$ 个 B 材料，最多可以建 $2$ 层楼的房子。

（花费 $1+2$ 个 A 材料和 $1+2$ 个 B 材料）

**【样例 2 说明】**

pigstd 买 $3$ 个 A 材料后就有 $4$ 个 A 材料和 $5$ 个 B 材料，最多可以建 $2$ 层楼的房子。

（花费 $1+2$ 个 A 材料和 $1+2$ 个 B 材料）

**【数据规模与约定】**

对于 $100\%$ 的数据，$0 \le a,b,c \le 10^{12}$。

| 数据点编号 | 满足的条件 |
| :----------: | :----------: |
|$1-4,22$| $c = 0$ |
|$5-8,21$| $a,b,c \le 10^{3}$ |
|$9-12$| $a,b,c \le 10^{6}$ |
|$13-20$| $a,b,c \le 10^{12}$ | 

## 样例 #1

### 输入

```
1 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
1 5 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心在于如何合理分配 `c` 个万能材料，使得 `a` 和 `b` 尽可能接近，从而最大化能够建造的楼层数。所有题解都围绕这一核心展开，主要分为以下几步：

1. **贪心策略**：通过分配 `c` 使得 `a` 和 `b` 尽可能接近，从而最大化 `min(a, b)`。
2. **数学求解**：通过一元二次不等式求解最大楼层数，或通过二分法、暴力枚举等方式确定最大楼层。
3. **优化**：部分题解通过数学公式直接求解，避免了循环或二分，达到了 `O(1)` 的时间复杂度。

### 所选高星题解

#### 1. 作者：云浅知处 (5星)
- **关键亮点**：通过数学推导直接求解最大楼层数，时间复杂度为 `O(1)`，代码简洁且高效。
- **个人心得**：作者详细推导了一元二次不等式的解法，并解释了如何通过求根公式得到最大楼层数，思路清晰且易于理解。

```cpp
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cmath>
#define LL long long
using namespace std;
LL a,b,c;
int main(void){
    scanf("%lld%lld%lld",&a,&b,&c);
    LL x=max(a,b),y=min(a,b);
    LL m=x-y;
    if(m>c){
        LL ans=(LL)(((LL)(floor(sqrt(8*(y+c)+1)))-1)/2);
        printf("%lld\n",ans);
        return 0;
    }
    else{
        c-=m;
        LL ans=(LL)(((LL)(floor(sqrt(8*(x+(LL)(c/2))+1)))-1)/2);
        printf("%lld\n",ans);
    }
    return 0;
}
```

#### 2. 作者：Unordered_OIer (4星)
- **关键亮点**：提供了多种求解最大楼层数的方法（顺序枚举、二分枚举、数学公式），并详细解释了每种方法的优缺点。
- **个人心得**：作者通过分类讨论和数学公式的结合，给出了多种解决方案，适合不同水平的读者。

```cpp
long long leftbound=1,rightbound=L;
while(leftbound<=rightbound){
    long long middle=(leftbound+rightbound)>>1;
    if(middle*(middle+1)/2<=ans)leftbound=middle+1,ans=middle;
    else rightbound=middle-1;
}
```

#### 3. 作者：Aw顿顿 (4星)
- **关键亮点**：通过贪心策略和简单的循环求解最大楼层数，代码简洁且易于理解。
- **个人心得**：作者通过模拟搬砖的过程，逐步累加楼层数，直到材料不足，思路清晰且易于实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,s,ans;
int main(){
    cin>>a>>b>>c;
    if(abs(a-b)>c)s=min(a,b)+c;
    else s=(a+b+c)/2;
    for(long long i=1;;i++){
        ans+=i;
        if(ans>s){
            cout<<i-1<<endl;
            return 0;
        }
    }
}
```

### 最优关键思路与技巧

1. **贪心策略**：通过分配 `c` 使得 `a` 和 `b` 尽可能接近，从而最大化 `min(a, b)`。
2. **数学求解**：通过一元二次不等式求解最大楼层数，避免了循环或二分，达到了 `O(1)` 的时间复杂度。
3. **二分法**：通过二分法快速确定最大楼层数，适用于数据规模较大的情况。

### 拓展与举一反三

- **类似题目**：可以考虑类似的问题，如资源分配、背包问题等，通过贪心策略或数学公式求解最优解。
- **优化思路**：在类似问题中，可以通过数学推导或二分法优化时间复杂度，避免暴力枚举。

### 推荐题目

1. **P1048 采药**：考察贪心策略和背包问题的结合。
2. **P1064 金明的预算方案**：考察资源分配和动态规划的结合。
3. **P1090 合并果子**：考察贪心策略和优先队列的使用。

### 个人心得总结

- **调试经历**：部分作者在调试过程中发现，直接使用数学公式求解可以避免循环或二分的复杂性，提高代码效率。
- **踩坑教训**：在分配 `c` 时，需要注意 `a` 和 `b` 的初始差距，避免分配不当导致无法最大化 `min(a, b)`。
- **顿悟感想**：通过数学推导和贪心策略的结合，可以高效解决类似资源分配问题，避免复杂的循环或递归。

---
处理用时：37.02秒
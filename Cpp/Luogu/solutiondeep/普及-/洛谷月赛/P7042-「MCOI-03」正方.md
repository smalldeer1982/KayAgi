# 题目信息

# 「MCOI-03」正方

## 题目背景

MC 中没有圆。

所以小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 喜欢 Square。

## 题目描述

给定一个正方形，求有多少个正方形内的点满足与正方形四个顶点划分出来的四块面积的比为 $a:b:c:d$。四个数不分顺序。

比如如下图所示假设一个点 E 使得分成的四个三角形的面积之比为 $a:b:c:d$，那么这个点 E 就符合要求。因为不分顺序，所以分出来的比是 $d:b:a:c$ 也可以。但是点 E 不是唯一解，你要输出的是解的个数。

![](https://cdn.luogu.com.cn/upload/image_hosting/95llbbcx.png)

因为小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 很喜欢询问，所以本题给定了 $q$ 组询问。

## 说明/提示

#### 数据规模与约定

对于 $20\%$ 的数据，$a=b=c=d$。    
对于 $100\%$ 的数据，$1 \le a,b,c,d \le 9 \times 10^{18}$，$1 \le q \le 100$，不保证 $a:b:c:d$ 为最简比，不保证 $a,b,c,d$ 为升序。

## 样例 #1

### 输入

```
3
1 3 3 1
2 4 7 8
2 3 1 4```

### 输出

```
4
0
8```

# AI分析结果

### 综合分析与结论

本题的核心是通过几何性质判断正方形内点的位置，使得该点与四个顶点连线将正方形分割成四个面积比为给定比例的三角形。大多数题解通过排序和分类讨论来解决该问题，主要思路如下：

1. **几何性质**：由于四个三角形的底边相等，面积比等于高之比。因此，满足条件的点必须满足两对高之和相等，即 `a + d = b + c`（排序后）。
2. **分类讨论**：根据 `a, b, c, d` 的相等情况，分为四种情况：
   - 全相等：答案为 `1`（中心点）。
   - 两对相等：答案为 `4`。
   - 无相等且满足 `a + d = b + c`：答案为 `8`。
   - 不满足 `a + d = b + c`：答案为 `0`。
3. **优化与实现**：大多数题解通过排序和简单判断实现，代码简洁且高效。

### 所选高星题解

#### 1. 作者：Unordered_OIer (5星)
- **关键亮点**：思路清晰，分类讨论全面，代码简洁且高效。通过几何性质推导出必要条件，并结合排序和分类讨论得出答案。
- **个人心得**：作者提到“这道题是真的思维题”，强调了问题的几何性质与分类讨论的重要性。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll q, a[5];

int main() {
    cin >> q;
    while (q--) {
        for (int i = 1; i <= 4; i++) cin >> a[i];
        sort(a + 1, a + 5);
        if (a[1] + a[4] != a[2] + a[3]) puts("0");
        else if (a[1] == a[4]) puts("1");
        else if (a[1] == a[2]) puts("4");
        else puts("8");
    }
    return 0;
}
```

#### 2. 作者：一只书虫仔 (4.5星)
- **关键亮点**：详细解释了几何性质，并通过图示辅助理解，分类讨论清晰，代码实现简洁。
- **个人心得**：作者通过图示帮助理解，强调了“只有在 `a + b = c + d` 的情况下，才能满足有解”。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int q, a[5];

signed main() {
    cin >> q;
    while (q--) {
        for (int i = 1; i <= 4; i++) cin >> a[i];
        sort(a + 1, a + 5);
        if (a[1] + a[4] != a[2] + a[3]) cout << 0 << endl;
        else if (a[1] == a[4]) cout << 1 << endl;
        else if (a[1] == a[2] || a[3] == a[4]) cout << 4 << endl;
        else cout << 8 << endl;
    }
    return 0;
}
```

#### 3. 作者：借我昔日热忱 (4星)
- **关键亮点**：通过对称性分析，解释了不同情况下的解的数量，代码实现简洁。
- **个人心得**：作者提到“当点位于非特殊位置就可以实现两条轴对称+中心对称来达到八个相同解”，强调了对称性在解题中的重要性。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
unsigned long long a[4];

int main() {
    int q; scanf("%d", &q);
    while (q--) {
        scanf("%lld%lld%lld%lld", &a[0], &a[1], &a[2], &a[3]);
        sort(a, a + 4);
        if (a[0] + a[3] != a[1] + a[2]) printf("0\n");
        else if (a[0] == a[3]) printf("1\n");
        else if (a[0] == a[1] || a[2] == a[3]) printf("4\n");
        else printf("8\n");
    }
    return 0;
}
```

### 最优关键思路与技巧

1. **几何性质与分类讨论**：通过几何性质推导出必要条件，并结合排序和分类讨论得出答案。
2. **对称性分析**：利用正方形的对称性，分析不同情况下的解的数量。
3. **代码简洁与高效**：通过排序和简单判断实现，代码简洁且高效。

### 可拓展之处

1. **类似几何问题**：可以扩展到其他几何图形（如矩形、菱形等）内点的位置问题。
2. **分类讨论**：在其他需要分类讨论的问题中，可以借鉴本题的思路，通过排序和简单判断实现。

### 推荐题目

1. **P1357 矩形**：考察矩形内点的位置问题。
2. **P2731 正方形**：考察正方形内点的位置问题。
3. **P2732 菱形**：考察菱形内点的位置问题。

### 个人心得总结

- **几何性质的重要性**：通过几何性质推导出必要条件，是解决几何问题的关键。
- **分类讨论的清晰性**：清晰的分类讨论可以帮助快速找到问题的解决方案。
- **对称性的利用**：利用对称性可以简化问题，减少计算量。

---
处理用时：42.19秒
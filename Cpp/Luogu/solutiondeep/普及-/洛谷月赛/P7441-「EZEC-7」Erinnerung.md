# 题目信息

# 「EZEC-7」Erinnerung

## 题目描述

小 Y 和小 Z 都是生活在 Arcaea Offline 的精灵。小 Y 有无数片落叶，其中第 $i$ 片落叶的价值为 $C_i$。小 Z 有无数片雪花，其中第 $i$ 片雪花的价值为 $E_i$。经过小 X 的仔细观察，他发现 $C$ 和 $E$ 满足特殊的条件：

$$
C_i=
\begin{cases}
x\times i& (x\times i\le K)\\
-K& \text{otherwise}
\end{cases}
$$
$$
E_i=
\begin{cases}
y\times i& (y\times i\le K)\\
-K& \text{otherwise}
\end{cases}
$$

小 Y 和小 Z 可以对这些落叶和雪花进行一些操作。每次，他们会选择满足价值之和 $\ge K$ 的一片落叶和一片雪花，然后让把它们一同组成一段彩色的回忆（Erinnerung）。之后，这片雪花和这片落叶就消失不见了，之后的操作也不能再用到这片雪花和落叶了。

小 X 想知道，他们最多能进行多少次操作。

## 说明/提示

**【样例解释】**

对于样例 1 的第一组数据，落叶的价值为 $2,4,6,8,10,-10,-10\dots$ ，雪花的价值为 $3,6,9,-10,-10\dots$ 。第一次操作选取第 $4$ 片落叶和第 $1$ 片雪花，价值和为 $11$。第二次操作选取第 $2$ 片落叶和第 $2$ 片雪花，价值和为 $10$。第三次操作选取第 $5$ 片落叶和第 $3$ 片雪花，价值和为 $19$。如是，可以进行 $3$ 次操作。容易证明不存在更优的解。

对于第二组数据，进行的两次操作可以为：选取第 $4$ 片落叶和第 $1$ 片雪花，以及选取第 $2$ 片落叶和第 $2$ 片雪花。

对于样例 2，所有的雪花和落叶的价值都为 $0$，不可能找到落叶和雪花使其和 $\ge 1$。

---

**【数据范围】**

-  Subtask 1（30 points）：$x,y,K,T\le 10$。
-  Subtask 2（70 points）：无特殊限制。

对于 $100\%$ 的数据，满足 $0\le x,y\le 10^{10}$，$1\le K\le 10^{10}$，$1\le T\le 10^5$。

## 样例 #1

### 输入

```
2
2 3 10
2 4 11```

### 输出

```
3
2```

## 样例 #2

### 输入

```
1
0 0 1```

### 输出

```
0```

# AI分析结果

### 综合分析与结论

本题的核心在于通过数学推导和贪心策略，找到最多可以进行的操作次数。大多数题解都采用了类似的思路，即通过计算两个序列中有效元素的数量，并取最小值作为答案。难点在于处理特殊情况（如 \(x\) 或 \(y\) 为 0）以及证明贪心策略的正确性。

### 所选高星题解

#### 1. 题解作者：Unordered_OIer (赞：44)
- **星级**：★★★★★
- **关键亮点**：
  - 详细证明了贪心策略的正确性，尤其是在 \(x < y\) 和 \(x > y\) 两种情况下的匹配方式。
  - 处理了 \(x\) 或 \(y\) 为 0 的特殊情况，代码简洁且高效。
  - 代码可读性强，逻辑清晰。
- **个人心得**：
  - 作者提到“这道题好像劝退了不少人，但是我觉得没那么难”，体现了对题目的深入理解和自信。
- **核心代码**：
  ```cpp
  ll T,x,y,k;
  int main(){
      T=read();
      while(T--){
          x=read(),y=read(),k=read();
          if(x==0&&y==0){
              writeln(0);
              continue;
          }
          if(x==0)writeln(k%y==0?1:0);
          else if(y==0)writeln(k%x==0?1:0);
          else writeln(min(k/x,k/y));
      }
      return 0;
  }
  ```

#### 2. 题解作者：_zy_ (赞：23)
- **星级**：★★★★
- **关键亮点**：
  - 通过样例分析，直观地解释了贪心策略的合理性。
  - 代码中使用了 `swap` 函数来简化逻辑，提高了代码的可读性。
- **核心代码**：
  ```cpp
  int T;
  signed main()
  {
      cin>>T;
      while(T--)
      {
          int x,y,k;
          x=re(); y=re(); k=re();
          if(x>y) swap(x,y);
          if(x==0&&y!=0) {if(k%y==0) printf("1\n");else printf("0\n");continue;}
          if(x==0&&y==0)
          {printf("0\n");continue;}
          int tmp=(k-(k/x)*x)/y;
          cout<<(k/y)-tmp<<endl;
      }
  }
  ```

#### 3. 题解作者：lgswdn_SA (赞：18)
- **星级**：★★★★
- **关键亮点**：
  - 作为出题人题解，提供了官方证明，确保了答案的正确性。
  - 代码简洁，直接输出结果，逻辑清晰。
- **核心代码**：
  ```cpp
  #define int long long
  int T,x,y,k;
  signed main() {
      T=read();
      while(T--) {
          x=read(), y=read(), k=read();
          if(!(x||y)) printf("%lld\n",0);
          else if(!(x&&y)) printf("%lld\n",x==0?k%y==0:k%x==0);
          else printf("%lld\n",x>y?k/x:k/y);
      }
      return 0;
  }
  ```

### 最优关键思路与技巧

1. **贪心策略**：通过计算两个序列中有效元素的数量，并取最小值作为答案。
2. **特殊情况处理**：当 \(x\) 或 \(y\) 为 0 时，需要单独处理，判断是否能进行一次操作。
3. **数学证明**：通过数学推导证明贪心策略的正确性，确保答案的最优性。

### 可拓展之处

- **类似题目**：可以拓展到其他需要匹配两个序列的问题，如背包问题、二分图匹配等。
- **算法套路**：贪心策略在匹配问题中非常常见，可以应用到其他类似场景中。

### 推荐题目

1. **P1004 方格取数**：考察贪心策略和动态规划。
2. **P1048 采药**：经典的背包问题，与本题的贪心策略有相似之处。
3. **P1064 金明的预算方案**：需要匹配多个条件，类似于本题的匹配问题。

### 个人心得总结

- **调试经历**：在处理特殊情况时，容易忽略 \(x\) 或 \(y\) 为 0 的情况，需要特别注意。
- **顿悟感想**：通过样例分析和数学证明，可以更好地理解题目的本质，从而找到最优解。

---
处理用时：37.63秒
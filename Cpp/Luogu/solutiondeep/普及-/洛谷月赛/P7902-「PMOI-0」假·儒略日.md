# 题目信息

# 「PMOI-0」假·儒略日

## 题目背景

（原 LZOI-1，改名已经 PMOI 成员同意）

Lanuxhem 听说 言琢დ 在 S-PSC 考场上就切穿了 **儒略の日**，想得到 言琢დ 手中的考场 AC 代码。

但是 言琢დ 不想给他，所以 言琢დ 就扔给了 Lanuxhem 下面这题，并说：“切了这道题就给你。”

lhm-02

## 题目描述

给定一个正整数 $n$ 和另一个正整数 $d$。

要求构造一个长度为 $2n$ 的数列 $\{a_{2n}\}$，满足：

1. $1\sim n$ 之中每个数字均出现 $2$ 次。
2. 对于数字 $i$，若 $i$ 为奇数，则数字 $i$ 两次出现位置之差 **必须** 超过 $d$。
3. 对于数字 $i$，若 $i$ 为偶数，则数字 $i$ 两次出现位置之差 **不能** 超过 $d$。

由于 Lanuxhem 想得到 言琢დ 的代码，但他并不会这道题，所以他只能请聪明的你帮他完成这题。

## 说明/提示

#### 样例说明

数字 $1$ 两次分别出现在位置 $2,6$，差为 $4(>2)$；

数字 $3$ 两次分别出现在位置 $1,4$，差为 $3(>2)$；

数字 $2$ 两次分别出现在位置 $3,5$，差为 $2(\le2)$。

#### 数据范围

| 子任务编号 | 分值 | 特殊限制 |
| :-: | :-: | :-: |
| $1$ | $36$ | $n\le10$ |
| $2$ | $24$ | $d=\left\lfloor\dfrac{n}{2}\right\rfloor$ |
| $3$ | $40$ | $\times$ |

对于 $100\%$ 的数据：$1\le\dfrac{d}{2}\le n\le10^6$。

## 样例 #1

### 输入

```
3 2```

### 输出

```
3 1 2 3 2 1```

## 样例 #2

### 输入

```
3 6```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个满足特定条件的序列，主要难点在于如何合理安排奇数和偶数的位置，使得奇数的两次出现位置之差超过 `d`，而偶数的两次出现位置之差不超过 `d`。通过对多个题解的分析，可以发现以下共同点：

1. **偶数处理**：所有题解都建议将偶数尽可能地放在一起，这样可以保证偶数的两次出现位置之差不超过 `d`。
2. **奇数处理**：奇数需要尽可能地分散，通常建议将奇数放在序列的两端，以确保它们的两次出现位置之差超过 `d`。
3. **无解条件**：当 `d` 过大时，无法满足奇数的条件，此时输出 `-1`。

### 所选高星题解

#### 1. 作者：HYdroKomide (4星)
- **关键亮点**：思路清晰，代码简洁，直接通过判断 `d` 是否大于奇数个数与偶数个数的组合来确定是否有解。构造方法简单明了，易于理解。
- **核心实现思想**：将奇数放在序列的两端，偶数放在中间，确保奇数的距离最大化。
- **代码片段**：
  ```cpp
  for(ri i=1;i<=n;i+=2)write(i); // 输出奇数一遍
  for(ri i=2;i<=n;i+=2)write(i),write(i); // 输出偶数两遍
  for(ri i=1;i<=n;i+=2)write(i); // 再输出奇数一遍
  ```

#### 2. 作者：Da_un (4星)
- **关键亮点**：详细解释了奇数和偶数的放置策略，并通过具体例子展示了构造过程。代码结构清晰，易于理解。
- **核心实现思想**：将奇数放在序列的两端，偶数放在中间，确保奇数的距离最大化。
- **代码片段**：
  ```cpp
  for(int i=1;i<=aa;i++) printf("%d ",a[i]); // 输出奇数
  for(int i=1;i<=bb;i++) printf("%d %d ",b[i],b[i]); // 输出偶数两遍
  for(int i=1;i<=aa;i++) printf("%d ",a[i]); // 再输出奇数
  ```

#### 3. 作者：ImposterAnYu (4星)
- **关键亮点**：通过贪心思想，将偶数尽可能地挨在一起，奇数尽可能地放远一点。详细解释了无解条件，并提供了具体的构造方法。
- **核心实现思想**：将奇数放在序列的两端，偶数放在中间，确保奇数的距离最大化。
- **代码片段**：
  ```cpp
  for(i = 1; i <= k; i++) a[i] = a[(n - k) + n + i] = i * 2 - 1; // 输出奇数
  for(i = k + 1; i < l; i += 2) a[i] = a[i + 1] = s; // 输出偶数两遍
  ```

### 最优关键思路或技巧

1. **奇偶分离**：将奇数和偶数分开处理，奇数放在序列的两端，偶数放在中间，确保奇数的距离最大化。
2. **无解判断**：通过判断 `d` 是否大于奇数个数与偶数个数的组合来确定是否有解。
3. **贪心思想**：尽可能地将偶数放在一起，奇数尽可能地分散，以满足题目条件。

### 可拓展之处

- **类似题目**：可以考察类似的序列构造问题，要求满足特定的位置条件。例如，要求某些元素的间隔必须大于某个值，而其他元素的间隔必须小于某个值。
- **算法套路**：在处理类似的序列构造问题时，可以考虑将元素分类处理，分别满足不同的条件。

### 推荐题目

1. **P1908 逆序对**：考察序列的构造与逆序对的计算。
2. **P1967 货车运输**：考察图的构造与路径的最优化。
3. **P3372 线段树 1**：考察线段树的构造与区间查询。

### 个人心得总结

- **调试经历**：在构造序列时，需要仔细考虑奇数和偶数的放置位置，确保满足题目条件。通过具体例子可以帮助理解构造过程。
- **顿悟感想**：通过将奇数和偶数分开处理，可以简化问题，使得构造过程更加清晰。

---
处理用时：34.16秒
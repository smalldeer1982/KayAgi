# 题目信息

# Easy Strings Merging

## 题目描述

给定 $n$ 个 01 串，每次你可以从某个串开头移除一个字符并把它加入一个新串 $S$ 的末尾。最大化 $S$ 中相邻两个字符相同的对数。

## 说明/提示

### 样例解释

最优方案下，每次取的串的编号为 $1,1,2,1,2,3,1,2,3,2,3,3$，最终的 $S=000111111000$。

### 数据范围

**本题采用捆绑测试**

设 $s$ 表示输入的 01 串的长度之和。

| 子任务编号 | 分值 | 特殊限制 |
| :----------: | :----------: | :----------: |
| $0$ | $5$ | $n=1$ |
| $1$ | $20$ | $n\le 2$，$s\le 10$ |
| $2$ | $25$ | $n\le 5$，$s\le 30$ |
| $3$ | $25$ | $n\le 100$，$s\le 200$ |
| $4$ | $25$ | 无特殊限制 |

对于所有数据，保证 $1\le n\le s\le 10^6$。

## 样例 #1

### 输入

```
3
0011
0110
1100```

### 输出

```
9```

# AI分析结果

### 综合分析与结论

本题的核心目标是最大化新串中相邻字符相同的对数，本质上是要求新串的“连通块”尽可能少，即尽可能让相同的字符连续排列。大多数题解都采用了贪心策略，通过交替取0和1来尽可能减少“切换”次数，从而最大化相邻字符相同的对数。

#### 关键思路与技巧：
1. **贪心策略**：每次尽可能取完所有串开头的相同字符（0或1），然后再切换到另一个字符，直到所有字符被取完。
2. **双策略比较**：由于第一次取0或1会影响最终结果，因此需要分别计算两种策略的结果，取最大值。
3. **优化实现**：通过记录每个串的当前取字符位置，避免重复遍历，提升效率。

#### 可拓展之处：
- **类似问题**：这类问题可以扩展到其他字符集或更复杂的字符串合并问题，如合并多个字符串时要求某种特定的排列顺序。
- **算法套路**：贪心策略在字符串合并、区间调度等问题中非常常见，掌握贪心的核心思想有助于解决类似问题。

#### 推荐题目：
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)
3. [P1969 积木大赛](https://www.luogu.com.cn/problem/P1969)

### 所选高质量题解

#### 题解1：作者：HYdroKomide (5星)
- **关键亮点**：通过记录每个串的取字符位置，避免了重复遍历，提升了效率。同时，分别计算第一次取0和1的结果，取最大值，确保了最优解。
- **个人心得**：作者在第一次提交时只得了50分，意识到第一次取的字符可能影响结果后，增加了双策略比较，最终AC。

```cpp
int n, l, tot, cnt0, cnt1, maxcnt0, maxcnt1, maxcnt;
string s;
int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    for (ri i = 1; i <= n; i++) {
        cin >> s;
        l = s.length(), cnt0 = cnt1 = 0;
        tot += l;
        if (s[0] == '0') cnt1++;
        if (s[0] == '1') cnt0++;
        for (ri j = 1; j < l; j++)
            if (s[j] != s[j - 1]) cnt0++, cnt1++;
        maxcnt0 = cnt0 > maxcnt0 ? cnt0 : maxcnt0;
        maxcnt1 = cnt1 > maxcnt1 ? cnt1 : maxcnt1;
    }
    maxcnt = min(maxcnt0, maxcnt1);
    tot--;
    cout << tot - maxcnt << endl;
    return 0;
}
```

#### 题解2：作者：VinstaG173 (4星)
- **关键亮点**：通过贪心策略，每次取完所有串开头的相同字符，再切换到另一个字符，直到取完所有字符。代码简洁，思路清晰。
- **个人心得**：作者通过样例解释了贪心策略的正确性，强调了交替取字符的重要性。

```cpp
int n, ans, t0, t1, tt0, tt1;
int main() {
    n = read();
    while (n--) {
        char c = gc(), l0 = '0', l1 = '1';
        t0 = t1 = 1;
        while (!isdigit(c)) c = gc();
        while (isdigit(c)) {
            (c != l0) && (l0 = c, ++t0), (c != l1) && (l1 = c, ++t1), c = gc(), ++ans;
        }
        (t0 > tt0) && (tt0 = t0), (t1 > tt1) && (tt1 = t1);
    }
    return 0 & printf("%d\n", ans - ((tt0 < tt1) ? tt0 : tt1));
}
```

#### 题解3：作者：MY（一名蒟蒻） (4星)
- **关键亮点**：通过结构体记录每个串的字符段，分别计算第一次取0和1的结果，取最大值。代码结构清晰，易于理解。
- **个人心得**：作者一开始使用了队列暴力解法，结果MLE，后来通过优化实现了AC。

```cpp
int n;
char s[N];
struct node { int col, cnt; } q[N];
int ans[2][N];
int main() {
    scanf("%d", &n);
    int tot;
    for (int i = 1, m, l, r; i <= n; i++) {
        scanf(" %s", s);
        m = strlen(s);
        l = 0; tot = 0;
        for (r = 1; r < m; r++) {
            if (s[l] != s[r]) q[++tot] = { s[l] - '0', r - l }, l = r;
        }
        q[++tot] = { s[l] - '0', r - l }, l = r;
        if (q[1].col == 0) for (int i = 1; i <= tot; i++) ans[0][i] += q[i].cnt, ans[1][i + 1] += q[i].cnt;
        else for (int i = 1; i <= tot; i++) ans[0][i + 1] += q[i].cnt, ans[1][i] += q[i].cnt;
    }
    int ans1 = 0, ans2 = 0;
    for (int i = 1; ans[0][i]; i++) ans1 += ans[0][i] - 1;
    for (int i = 1; ans[1][i]; i++) ans2 += ans[1][i] - 1;
    printf("%d", ans1 > ans2 ? ans1 : ans2);
    return 0;
}
```

### 总结
以上三条题解均采用了贪心策略，并通过双策略比较确保了最优解。代码实现上各有亮点，值得学习和借鉴。

---
处理用时：46.55秒
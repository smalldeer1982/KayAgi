# 题目信息

# 「MCOI-08」Fill In

## 题目背景

$$\begin{aligned}\text{sdjvlajdiofjoiw{\color{1f1e33}n}eglaj}\\\text{pcji{\color{1f1e33}2}gweiruitowoeuri}\\\text{cnvak{\color{1f1e33}5}jflkjweirqoiru}\\\text{rrrwei{\color{1f1e33}f}dlskfjqfafdfaff}\\\text{nmslfjwiejfijlxkjfq{\color{1f1e33}b}el}\\\text{mmm{\color{1f1e33}b}fsfmkdfmksld}\\\text{erjf{\color{1f1e33}n}kerjkwerjkwjeri}\\\text{sdfafafaf{\color{1f1e33}r}fxvzxvzvzx}\end{aligned}$$

## 题目描述

Dream 有一个长度为 $n$（$1\le n\le 10^5$）的正整数数组 $a_1,a_2,\dots,a_n$，其中对于 $i=1,2,\dots,n$，满足 $1\le a_i\le 1000$。

他计算了前缀和数组 $p_i=a_1+a_2+\dots+a_i$，保证对于 **原前缀和数组** 有任意 $1 \le i <n$ 都有 $p_i<p_{i+1}$。

现在 Tommy 偷走了这个数组以及将 $p$ 的若干个元素替代为 $-1$。给定当前的 $p$ 数组，请恢复任意一组合法 $a_1,a_2,\dots,a_n$，可证明一定存在一个数组 $a_i$ 满足要求。

## 说明/提示

#### 样例 1 解释

输出的序列 $a_i$ 一定满足要求：

- $p_1=10=a_1$；
- $p_3=20=a_1+a_2+a_3$；
- $p_5=30=a_1+a_2+a_3+a_4+a_5$。

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n,\sum n\le 10^5$，并保证存在至少一个合法 $a$ 数组。

 - Subtask 1（50 pts）：对于 $i=1,2,\dots,n$，$p_i\neq -1$；
 - Subtask 2（30 pts）：保证不存在 $i$ 使得 $p_i=p_{i+1}=-1$；
 - Subtask 3（20 pts）：无特殊限制。

## 样例 #1

### 输入

```
2
5
10 -1 20 -1 30
6
-1 -1 -1 -1 -1 -1```

### 输出

```
10 5 5 5 5
1 1 4 5 1 4```

# AI分析结果

### 综合分析与结论

本题的核心在于根据部分已知的前缀和数组，恢复出合法的原数组，且每个元素的值必须在1到1000之间。多个题解提供了不同的思路，主要分为以下几类：

1. **直接差分法**：适用于所有前缀和都已知的情况，直接通过差分得到原数组。这种方法简单但无法处理部分前缀和未知的情况。
2. **平摊法**：对于未知的前缀和区间，将差值平摊到该区间的每个元素上，确保每个元素的值不超过1000。这是大多数满分题解的核心思路。
3. **贪心法**：在平摊的基础上，进一步优化分配策略，确保最大值最小化，避免某些元素超过1000。

最优的思路是**平摊法**，因为它能够有效处理未知前缀和的情况，并且通过合理的分配策略，确保每个元素的值在合法范围内。

### 精选题解

#### 1. 作者：SSqwq_ (赞：6)  
**星级：4.5**  
**关键亮点**：  
- 使用平摊法，将差值平均分配到未知区间，确保每个元素的值不超过1000。
- 代码简洁，逻辑清晰，处理了末尾连续-1的情况。
- 通过整除和取余操作，确保分配后的值合法。

**核心代码**：
```cpp
for(register int j=0;j<mult-1;j++)
{
    printf("%d ",p[i]/mult); // 将p[i]平摊到分配区间中
    tmp-=p[i]/mult;
}
printf("%d ",tmp);
```
**实现思想**：通过整除将差值平均分配到区间内的每个元素，余数部分分配给最后一个元素。

#### 2. 作者：TheSky233 (赞：5)  
**星级：4.5**  
**关键亮点**：  
- 采用平摊法，并通过上取整的方式进一步优化分配策略，避免某些元素超过1000。
- 处理了末尾连续-1的情况，确保所有元素合法。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
a[k]=ceil((pre[j]-pre[i-1])*1.0/(j-i+1)); // 上取整，确保分配后的值合法
```
**实现思想**：通过上取整的方式，将差值平均分配到区间内的每个元素，确保每个元素的值尽可能大但不超限。

#### 3. 作者：GI录像机 (赞：4)  
**星级：4**  
**关键亮点**：  
- 使用平摊法，并通过向前传递多余值的方式，确保每个元素的值不超过1000。
- 处理了末尾连续-1的情况，确保所有元素合法。
- 代码逻辑清晰，处理了特殊情况。

**核心代码**：
```cpp
if (ans[tot] > 1000) {
    int gi = ans[tot] - 1000;
    ans[tot] = 1000;
    int j = tot;
    while (gi > 0) {
        ans[--j] += gi;
        gi = 0;
        if (ans[j] > 1000) {
            gi = ans[j] - 1000;
            ans[j] = 1000;
        }
    }
}
```
**实现思想**：通过向前传递多余值的方式，确保每个元素的值不超过1000。

### 最优关键思路与技巧

1. **平摊法**：将差值平均分配到未知区间，确保每个元素的值不超过1000。
2. **上取整优化**：通过上取整的方式，进一步优化分配策略，避免某些元素超过1000。
3. **向前传递多余值**：在平摊的基础上，通过向前传递多余值，确保每个元素的值合法。

### 可拓展之处

- **类似题目**：可以拓展到其他需要根据部分信息恢复完整数据的题目，如根据部分差分数组恢复原数组。
- **优化策略**：可以进一步优化分配策略，如动态调整分配方式，确保最大值最小化。

### 推荐题目

1. **P1115 最大子段和**：考察前缀和的应用，理解前缀和的性质。
2. **P1886 滑动窗口**：考察滑动窗口与前缀和的结合，理解区间和的优化。
3. **P3372 线段树 1**：考察线段树与前缀和的结合，理解区间操作的优化。

### 个人心得摘录

- **SSqwq_**：通过平摊法解决了50分思路的不足，确保每个元素的值不超过1000。
- **TheSky233**：通过上取整的方式进一步优化分配策略，避免某些元素超过1000。
- **GI录像机**：通过向前传递多余值的方式，确保每个元素的值合法。

---
处理用时：35.98秒
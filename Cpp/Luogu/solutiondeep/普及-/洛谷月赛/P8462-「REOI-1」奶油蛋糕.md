# 题目信息

# 「REOI-1」奶油蛋糕

## 题目背景


----------
早餐时间过后，小不点们都前往操场接受基础训练课程，威廉便趁机占据厨房了。  
他在军服上披围裙，头上绑三角巾，还将清早从市场采买回来的大量材料摆到桌上。  
接着，威廉烤了大量的奶油蛋糕。  

威廉把奶油蛋糕摆放到桌子上，珂朵莉闻到了蛋糕的香味，迫不及待地扑到了餐桌前享受着这份饕餮盛宴，然而蛋糕的制作，似乎还差了那么最后一步……  
“等一等哦，我还没有挤上奶油呢。”威廉说着，拿起了裱花袋。  

可饥肠辘辘的珂朵莉哪里等得起全部的奶油都给挤好？  
正当威廉还在忙着挨个给蛋糕挤上白花花的奶油的时候，珂朵莉已经偷偷的拿起了一块蛋糕……

## 题目描述

在桌子上的蛋糕可以看作是一个无限大的[平面直角坐标系](https://baike.baidu.com/item/%E5%B9%B3%E9%9D%A2%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB/1296463?fr=aladdin)，每一个蛋糕都位于坐标系的整点上。 

每一分钟，威廉会给每个蛋糕都涂上若干层奶油，规则如下：如果蛋糕连续第 $i$ 次没有被珂朵莉吃到，那么就会在蛋糕上挤上 $i$ 层奶油。  

每次在威廉挤完所有蛋糕的奶油后，珂朵莉会拿起一块蛋糕，把这个蛋糕上的奶油给吃掉一层。特别的，如果珂朵莉吃掉了蛋糕上的一层奶油，威廉马上会贴心的再次给这个蛋糕补上一层，且不计入连续没有被吃到的次数里（即下一次的 $i$ 依旧为 $1$ ）。  

由于蛋糕太多，珂朵莉实在不知道从何下手，所以她决定按照移动的吃法进行试吃。  
总共 $m$ 个分钟，珂朵莉的吃蛋糕序列可以用一个长度为 $m$ 的字符串表达。第 $t$ 个字符可能为 `N`，`S`，`W`，`E`分别表示珂朵莉在第 $t+1$ 分钟会吃掉第 $t$ 分钟吃掉蛋糕的上，下，左，右方位的蛋糕。  
珂朵莉第 $1$ 个分钟会拿起位于点 $(x,y)$ 的蛋糕，因为蛋糕目前没有被挤上奶油，所以珂朵莉既不会进行试吃，威廉也不会立刻给她补上奶油。

珂朵莉想知道在 $m$ 分钟后，这些蛋糕在最后都还剩多少层奶油。

本题中的上和右分别表示 $y$ 轴正方向和 $x$ 轴正方向。

---
简要题面：

有一个 $n\times n$ 的地块，一个连续 $i$ 分钟没人经过的地面在第 $i$ 分钟会落上 $i$ 个单位的灰，有人经过时不会落灰但灰也不会清零，在人走后第一分钟又会落上一个单位的灰，以此类推。有一个人在这个 $n\times n$ 的范围内移动，他的移动轨迹可以描述为一个由 $\text{N,S,W,E}$ 组成的字符串，每个字母分别表示上、下、左、右。这个人一开始在点 $(x,y)$，每一分钟移动一步。

求最后每一个位置上落下的灰的量。

保证这个人没有超过移动的范围。


## 说明/提示

**本题 y 轴朝上，x 轴朝右，样例输出中的左下角表示 $(1,1)$，第一分钟珂朵莉在初始点处，第二分钟移动到相应的位置，第 $m+1$ 分钟移动到最后一个点，但是总共只有 $m$ 分钟，因此最后一个点不受移动的影响**

---
**样例 1 解释：**

珂朵莉的移动路径为 $(1,1)\rightarrow(1,2)\rightarrow(2,2)\rightarrow(2,3)\rightarrow(1,3)$，共 $4$ 分钟。

对于第 $1$ 分钟，$(1,1)$ 奶油层数不变，其余点被挤上了 $1$ 层奶油。

对于第 $2$ 分钟，$(1,2)$ 奶油层数不变，$(1,1)$ 被挤上了 $1$ 层奶油，其余点挤上 $2$ 层奶油。

对于第 $3$ 分钟，$(2,2)$ 奶油层数不变，$(1,1)$ 挤上 $2$ 层奶油，$(1,2)$ 挤上 $1$ 层奶油，其余点挤上 $3$ 层奶油。

对于第 $4$ 分钟，$(2,3)$ 奶油层数不变，$(1,1)$ 挤上 $3$ 层奶油，$(1,2)$ 挤上 $2$ 层奶油，$(2,2)$ 挤上 $1$ 层奶油，其余点挤上 $4$ 层奶油。

**注意最后珂朵莉移动到了 $(1,3)$，但是时间只有 $4$ 分钟，所以实际上不会对 $(1,3)$ 造成影响。初始点不一定在 $(1,1)$。**

$1\le n\leq 50,1\leq m\le 1000$。

## 样例 #1

### 输入

```
5 4 1 1
NENW```

### 输出

```
10 10 10 10 10 
10 10 10 10 10 
10 6 10 10 10 
4 4 10 10 10 
6 10 10 10 10 
```

## 样例 #2

### 输入

```
7 14 1 1
NENENENENESSSS```

### 输出

```
105 105 105 105 105 105 105 
105 105 105 105 55 61 105 
105 105 105 49 51 69 105 
105 105 51 49 105 79 105 
105 61 55 105 105 91 105 
79 69 105 105 105 105 105 
91 105 105 105 105 105 105 
```

## 样例 #3

### 输入

```
10 70 2 2
NWSNSNNNSNNSSNNSENNNNEESNWSESESSWENNSEWESWWWESEEESENNSENWNESNWSNNNEESS```

### 输出

```
2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 
2485 1407 1205 1267 2485 2485 2485 2485 2485 2485 
2485 1435 1281 1167 2485 2485 2485 2217 2281 2347 
2485 1465 2485 1255 1041 2485 2485 2155 2485 2415 
1557 1497 2485 2485 969 1177 2485 1733 1807 2485 
1471 1531 1315 907 935 1267 2485 1473 1647 2485 
1631 2485 2485 1357 1381 1407 1435 1499 1645 2485 
2021 2347 2485 2485 2485 2485 1465 1497 2485 2485 
2087 2415 2485 2485 2485 2485 2485 2485 2485 2485 
2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 
```

## 样例 #4

### 输入

```
5 4 2 1
NENW```

### 输出

```
10 10 10 10 10 
10 10 10 10 10 
10 10 6 10 10 
10 4 4 10 10 
10 6 10 10 10 
```

# AI分析结果

### 综合分析

题目要求模拟一个人在 $n \times n$ 的网格上移动，每个网格在连续 $i$ 分钟未被经过时会积累 $i$ 层灰，最终输出每个网格的灰量。题解主要集中在暴力模拟和优化模拟两种思路上，部分题解通过记录上次经过的时间来优化计算。

### 题解评分与亮点

1. **Dregen_Yor (5星)**
   - **亮点**：使用等差数列求和公式优化计算，记录每个网格上次被经过的时间，避免重复计算，时间复杂度为 $O(m)$。
   - **核心代码**：
     ```cpp
     for (int i = 0, step = 1; step <= m && i < s.size(); i++, step++) {
         int tmp = step - last[x][y];
         sum[x][y] += tmp * (1 + tmp) >> 1;
         sum[x][y] -= (step - last[x][y]);
         last[x][y] = step;
         if (s[i] == 'N') x++;
         else if (s[i] == 'S') x--;
         else if (s[i] == 'W') y--;
         else if (s[i] == 'E') y++;
     }
     ```

2. **cachejtt (4星)**
   - **亮点**：通过记录每个网格上次被经过的时间，利用等差数列求和公式计算灰量，时间复杂度为 $O(m)$。
   - **核心代码**：
     ```cpp
     void solvel(string s,int x,int y,int cnt){
         if(cnt>m)return;
         g[x][y]+=(cnt-c[x][y])*(cnt-c[x][y]-1)/2;
         vis[x][y]=1;
         c[x][y]=cnt;
         if(s[cnt-1]=='N')solvel(s,x+1,y,cnt+1);
         if(s[cnt-1]=='S')solvel(s,x-1,y,cnt+1);
         if(s[cnt-1]=='E')solvel(s,x,y+1,cnt+1);
         if(s[cnt-1]=='W')solvel(s,x,y-1,cnt+1);
     }
     ```

3. **0xFF (4星)**
   - **亮点**：通过记录每个网格上次被经过的时间，利用等差数列求和公式计算灰量，代码简洁明了。
   - **核心代码**：
     ```cpp
     for(int i(1);i<=m;i++){
         ans[dx][dy] += (i - last[dx][dy]) * (i - last[dx][dy] - 1) / 2;
         last[dx][dy] = i;
         if(str[i] == 'N') dx++;
         if(str[i] == 'E') dy++;
         if(str[i] == 'W') dy--;
         if(str[i] == 'S') dx--;
     }
     ```

### 最优关键思路

- **等差数列求和公式**：通过记录每个网格上次被经过的时间，利用等差数列求和公式 $S = \frac{n(n+1)}{2}$ 计算灰量，避免重复计算，优化时间复杂度。
- **记录上次经过时间**：通过记录每个网格上次被经过的时间，可以快速计算当前时间间隔内的灰量，减少不必要的遍历。

### 可拓展之处

- **类似问题**：类似的问题可以扩展到其他需要记录时间间隔的场景，如资源分配、任务调度等。
- **优化思路**：在模拟类问题中，通过记录关键状态（如上次经过时间）来优化计算，是一种常见的优化手段。

### 推荐题目

1. **P1003 铺地毯**：考察模拟和二维数组的应用。
2. **P1042 乒乓球**：考察模拟和字符串处理。
3. **P1056 排座椅**：考察模拟和贪心算法的应用。

### 个人心得摘录

- **Dregen_Yor**：通过记录上次经过的时间，避免了重复计算，显著提高了效率。
- **cachejtt**：在优化过程中，发现通过记录时间间隔可以大幅减少计算量，最终实现了 $O(m)$ 的时间复杂度。
- **0xFF**：在调试过程中，发现输出格式与题目要求不符，经过调整后顺利通过，提醒了在模拟类问题中注意输出格式的重要性。

---
处理用时：34.29秒
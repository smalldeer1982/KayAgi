# 题目信息

# [Aya Round 1 D] 文文的数学游戏

## 题目背景

在解决了上一题之后，琪露诺觉得自己仿佛就是天才。于是，射命丸文又给了她一道简单的数学题。

## 题目描述

给定长度为 $n$ 的整数序列 $a$，你需要构造一个长度为 $n$ 的整数序列 $b$ 满足对于所有 $1\le i\le n$，有 $1\le b_i \le a_i$。且 $\gcd(b_1,b_2,\cdots,b_n)$ 最大，其中 $\gcd$ 表示最大公因数。试求出能得到的最大值和取得最大值时，不同的数列 $b$ 的个数，对 $10^9+7$ 取模。

定义两个长度为 $L$ 的数列 $c,d$ 不同，当且仅当存在整数 $i(1 \le i \le L)$，使得 $c_i \ne d_i$。

## 说明/提示

### 样例 1 解释

注意到由于 $1\le b_1\le a_1=1$，因此 $b_1$ 必须要为 $1$，因此最大的 $\gcd$ 值只能为 $1$。在这个前提下，所有合法的 $b$ 如下：

- $\{1,1,1\},\{1,1,2\},\{1,1,3\},\{1,2,1\},\{1,2,2\},\{1,2,3\}$。

### 数据范围与约束

对于 $100\%$ 的数据，$1 \le n\le 10^5$，$1 \le a_i\le 10^9$。

本题附带一组大样例。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
1 6```

# AI分析结果

### 综合分析与结论

本题的核心在于如何构造序列 $b$，使得其最大公因数（$\gcd$）最大，并计算满足条件的序列个数。所有题解都抓住了关键点：$\gcd$ 的最大值等于序列 $a$ 的最小值 $a_{\min}$，并且通过乘法原理计算方案数。不同题解在实现细节和代码风格上有所差异，但整体思路一致。

### 所选题解

#### 1. 作者：chen_zhe (赞：23)  
**星级：5星**  
**关键亮点：**  
- 思路清晰，直接指出 $\gcd$ 的最大值等于 $a_i$ 的最小值，并给出了简洁的证明。
- 代码实现简洁，使用 `long long` 和边乘边取模的方式避免了溢出问题。
- 代码可读性强，变量命名合理，逻辑清晰。

**核心代码：**
```cpp
int a[100050],n,mgcd=1<<30;
const int mod=1e9+7;
int main()
{
    cin >> n;
    for (int i=1;i<=n;i++)
    {
        cin >> a[i];
        mgcd=min(mgcd,a[i]);
    }
    long long ans=1;
    for (int i=1;i<=n;i++)
        ans=(long long)ans*(a[i]/mgcd)%mod;
    cout << mgcd << " " << ans << endl;
    return 0;
}
```

#### 2. 作者：落花月朦胧 (赞：10)  
**星级：4星**  
**关键亮点：**  
- 详细证明了 $\gcd$ 的最大值等于 $a_i$ 的最小值，逻辑严谨。
- 提供了自动取模的模板，增强了代码的通用性。
- 代码结构清晰，使用了 `std::vector` 和 `Z` 类型（自动取模）。

**核心代码：**
```cpp
std::vector<int> a(n);
int mn = inf;
for (int i = 0; i < n; i++) {
    std::cin >> a[i];
    mn = std::min(mn, a[i]);
}
std::cout << mn << " ";
Z ans = 1;
for (int i = 0; i < n; i++) {
    ans *= (a[i] / mn);
}
std::cout << ans.val() << "\n";
```

#### 3. 作者：xzy090626 (赞：4)  
**星级：4星**  
**关键亮点：**  
- 思路清晰，直接指出 $\gcd$ 的最大值等于 $a_i$ 的最小值，并给出了简洁的证明。
- 代码实现简洁，使用了 `long long` 和边乘边取模的方式避免了溢出问题。
- 代码可读性强，变量命名合理，逻辑清晰。

**核心代码：**
```cpp
int a[1000005];
signed main(){
    int n;cin>>n;
    int cnt = 1.1e9;
    int ans = 1;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) cnt = min(a[i],cnt);
    for(int i=1;i<=n;i++) ans *= a[i]/cnt,ans %= mod;
    cout<<cnt<<' '<<ans;
    return 0;
}
```

### 最优关键思路与技巧

1. **$\gcd$ 的最大值等于 $a_i$ 的最小值**：这是本题的核心结论，所有题解都围绕这一点展开。
2. **乘法原理计算方案数**：通过计算每个 $b_i$ 可以取的值的个数，并相乘得到总方案数。
3. **边乘边取模**：避免大数溢出，确保计算结果的正确性。

### 可拓展之处

- **类似问题**：可以扩展到其他与 $\gcd$ 相关的构造问题，如构造序列使得 $\gcd$ 等于某个特定值。
- **优化思路**：在处理大范围数据时，可以考虑使用更高效的算法或数据结构来优化计算。

### 推荐题目

1. **P1447 [NOI2010]能量采集**：考察 $\gcd$ 的性质及其在矩阵中的应用。
2. **P2568 GCD**：给定范围，计算满足 $\gcd(x, y) = k$ 的数对个数。
3. **P2158 [SDOI2008]仪仗队**：利用 $\gcd$ 的性质解决几何问题。

### 个人心得总结

- **调试经历**：在处理大数时，务必注意数据类型的范围和溢出问题，使用 `long long` 和边乘边取模是常见的解决方案。
- **顿悟感想**：理解 $\gcd$ 的最大值等于序列最小值是解决本题的关键，这一结论在类似问题中也有广泛应用。

---
处理用时：32.34秒
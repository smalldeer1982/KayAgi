# 题目信息

# 「Wdoi-2」花如幻想一般

## 题目背景

冬的白色被春日的阳光所点缀，幻想乡完全取回了生机的颜色。但，樱花，向日葵，野菊花，桔梗……明明还是春天，全年的花却全都盛开了。

六十年前（注：现实中的 1945 年）的大战，炮火声中、枪林弹雨中，无数的无辜的亡魂，在六十年后纷纷落于幻想之中，寄托于每一朵花上。

每一朵花寄托着每一朵亡魂的灵魂本质。向日葵寄宿着开朗的人的灵魂。彼岸花寄宿了没有朋友的寂寞灵魂，紫色的樱树下满是持有罪恶的幽灵。由于是从有德的幽灵开始按顺序送往彼岸，留到最后的都将是樱花。

外面的人类所看到的虚幻的彼岸，正回归于幻想的此岸。

## 题目描述

### 简要题意

有一个长度为 $n$ 的序列 $a$。可以进行两种操作：
- 将整个序列翻转；
- 将序列中的某个数加上某个**整数**。

问：至少要用多少次操作可以将序列 $a$ 转化为序列 $b$。

### 原始题意

参与解决花之异变的十余位主角都并未年满 60 岁，并没有经历过上一次的花之异变。在万花丛中解决异变的紧迫性逐渐被消弭，取而代之的是用花朵来进行游戏。

灵梦将 $n$ 个花朵排成了一排，第 $i$ 朵花都有其对应的美丽程度 $a_i$。而一旁的魔理沙作为一位魔法使，拥有两种能力。她可以进行若干次操作，每次操作可以**使得这 $\bm n$ 朵花的位置完全翻转**，或者可以**将某一朵花的美丽程度加上或减去一个整数**。

灵梦认为，如果能用魔理沙的操作，使得最后花朵的美丽程度可以变成序列 $b_i$，那么将会是很好的。为了解决异变顺利，魔理沙希望自己的操作次数尽可能少。那么请问魔理沙为了满足灵梦的愿望至少需要操作几次？

---

幻想乡的花儿渐落，新绿开始步向美丽的季节。经过六十年还不会被遗忘的记忆，可能是没有的吧。

## 说明/提示

### 样例解释 \#1

$$
\begin{array}{cccl}
\color{red}1&\color{red}2&\color{red}3&\downarrow\text{reverse}\\
3&2&1&
\end{array}
$$

### 样例解释 \#2

$$
\begin{array}{ccl}
\color{red}3&\color{red}1&\downarrow\text{reverse}\\
1&\color{red}3&\downarrow\text{add }-1\\
1&2&
\end{array}
$$

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值}\\\hline
1 & 10 & - & 10\\\hline
2 & 10^3 & - & 30\\\hline
3 & 5\times 10^5 & \text{A} & 5 \\\hline
4 & 5\times 10^5 & - & 55 \\\hline
\end{array}$$

- 特殊性质 $\textbf{A}$：保证存在一种花费最小的方案，不需要执行第二种操作。

对于全部数据，满足 $1 \leq n \leq 5\times10^5$，
$1 \leq a_i,b_i \leq 10^9$。

## 样例 #1

### 输入

```
3
1 2 3
3 2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
2
3 1
1 2```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心在于通过最少的操作次数将序列 $a$ 转化为序列 $b$。操作包括翻转序列和修改单个元素的值。所有题解都基于一个共同的关键观察：翻转操作最多只需要执行一次，因为翻转两次等于没有翻转。因此，题解通常分为两种情况讨论：不翻转和翻转一次，然后分别计算所需的操作次数，最后取最小值。

大多数题解的思路清晰，代码实现简洁，但部分题解在代码可读性和优化程度上有所欠缺。以下是评分较高的题解及其亮点。

### 所选高星题解

#### 1. 作者：chen_zhe (★★★★★)
- **关键亮点**：思路清晰，代码简洁，直接分类讨论不翻转和翻转一次的情况，并通过遍历序列计算操作次数。
- **代码核心思想**：
  - 遍历序列 $a$ 和 $b$，统计不翻转时对应位置不同的元素个数。
  - 翻转序列 $a$，再次遍历并统计翻转后对应位置不同的元素个数。
  - 取两种情况的最小值作为最终结果。

```cpp
int cnt1=0,cnt2=1;
for (int i=1;i<=n;i++)
{
    if (a[i]!=b[i])
        cnt1++;
}
for (int i=n;i>=1;i--)
{
    if (a[n-i+1]!=b[i])
        cnt2++;
}
cout << min(cnt1,cnt2) << endl;
```

#### 2. 作者：SolIII (★★★★☆)
- **关键亮点**：代码结构清晰，使用数组 $c$ 存储翻转后的序列，便于后续比较。
- **代码核心思想**：
  - 通过数组 $c$ 存储翻转后的序列 $a$。
  - 分别遍历 $a$ 和 $c$，统计与 $b$ 对应位置不同的元素个数。
  - 取两种情况的最小值作为最终结果。

```cpp
int cnt1 = 0, cnt2 = 1;
for(int i=1;i<=n;i++){
    cnt1 += a[i] != b[i];
    cnt2 += c[i] != b[i];
}
printf("%d\n", min(cnt1, cnt2));
```

#### 3. 作者：hycqwq (★★★★☆)
- **关键亮点**：代码实现简洁，通过函数封装翻转和计算操作次数的逻辑，提高了代码的可读性。
- **代码核心思想**：
  - 定义一个函数 `cal()` 来计算当前序列与 $b$ 对应位置不同的元素个数。
  - 先计算不翻转的情况，再翻转序列 $a$，计算翻转后的情况，并取最小值。

```cpp
int cal(){
    int cnt = 0;
    for (int i = 1; i <= n; i++)
        cnt += (a[i] != b[i]);
    return cnt;
}

int main(){
    int ans = cal();
    reverseA();
    ans = min(ans, cal() + 1);
    cout << ans << endl;
}
```

### 最优关键思路与技巧

1. **翻转操作的优化**：翻转操作最多只需要执行一次，因为翻转两次等于没有翻转。这一观察大大简化了问题的复杂度。
2. **分类讨论**：将问题分为不翻转和翻转一次两种情况，分别计算操作次数，最后取最小值。
3. **遍历比较**：通过遍历序列，统计对应位置不同的元素个数，作为操作次数的依据。

### 可拓展之处

- **类似问题**：可以扩展到其他需要最少操作次数的问题，如通过交换、删除、插入等操作将一个序列转化为另一个序列。
- **算法套路**：类似的分类讨论和遍历比较的思路可以应用于其他序列操作问题。

### 推荐题目

1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)

### 个人心得摘录

- **调试经历**：部分题解提到在调试过程中发现翻转操作的特殊情况，如翻转两次等于没有翻转，这一发现帮助简化了问题的解决思路。
- **顿悟感想**：通过分类讨论和遍历比较的思路，可以有效地解决类似的最少操作次数问题，这一方法具有较高的通用性。

---
处理用时：32.43秒
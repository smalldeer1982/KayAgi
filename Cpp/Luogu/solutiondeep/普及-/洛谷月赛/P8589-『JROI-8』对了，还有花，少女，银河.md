# 题目信息

# 『JROI-8』对了，还有花，少女，银河

## 题目背景

![1663764189387.png](https://img-kysic-1258722770.file.myqcloud.com/9d24e2bd5b20f277e72914b1bc44543e/44b6413b44c70.png)

>「其一」\
即使化身白骨，也有不想忘记的东西

**已获得转载授权。**

## 题目描述

给定 $n$，请构造一个长度为 $n$ 的仅包含 $0,1$ 的数字串，满足 $01,00,10,11$ 出现的次数相等。或报告无解。

这里“出现”指与原字符串中连续的一部分完全相同。例如，在 $1011101$ 中，$01,00,10,11$ 分别出现了 $2,0,2,2$ 次。

**请注意，大样例不以文件附加形式给出，而直接放在题目的 输入输出样例 中的 样例 #3**

## 说明/提示

【数据范围与提示】

| 测试点编号 | 分数 | $n\leq$ | 特殊性质 |
| -----------: | -----------: | -----------: | -----------: |
| $1\sim 2$ | $20$ | $5$ | 无 |
| $3\sim 4$ | $20$ | $10^6$ | $n \bmod 4 = 0$ |
| $5\sim 6$ | $20$ | $20$ | 无 |
| $7 \sim 10$ | $40$ | $10^6$ | 无 |

## 样例 #1

### 输入

```
3```

### 输出

```
-1```

## 样例 #2

### 输入

```
5```

### 输出

```
00110```

## 样例 #3

### 输入

```
15400```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论

本题要求构造一个长度为 $n$ 的 $01$ 串，使得 $01, 00, 10, 11$ 这四种长度为 $2$ 的子串出现次数相等。通过对多个题解的分析，可以得出以下结论：

1. **无解条件**：当 $n \bmod 4 \neq 1$ 或 $n = 1$ 时，无解。这是因为长度为 $n$ 的字符串中，长度为 $2$ 的子串数量为 $n-1$，而要使四种子串出现次数相等，$n-1$ 必须是 $4$ 的倍数。

2. **构造方法**：当 $n \bmod 4 = 1$ 且 $n \neq 1$ 时，可以通过构造 `0011` 的循环加上一个 `0` 来满足条件。具体来说，先输出一个 `0`，然后循环输出 $\frac{n-1}{4}$ 个 `0110`。

3. **优化与简化**：大多数题解都通过简单的数学推导和构造方法解决了问题，代码实现简洁高效，时间复杂度为 $O(n)$。

### 所选高星题解

#### 1. **题解作者：AThls123 (5星)**
- **关键亮点**：通过DFS验证了只有 $n \bmod 4 = 1$ 时有解，并给出了简洁的构造方法。代码清晰，逻辑严谨。
- **个人心得**：作者通过DFS验证了构造的可行性，并在此基础上提出了构造方法，避免了复杂的推导。
- **核心代码**：
  ```cpp
  if ((n - 1) % 4 == 0 && n != 1) {
      for (int i = 1; i <= n/4; i++) cout << "0011";
      cout << 0 << endl;
  } else cout << -1 << endl;
  ```

#### 2. **题解作者：xwh_Marvelous (4星)**
- **关键亮点**：通过观察样例和数学推导，得出了 $n \bmod 4 = 1$ 时有解的结论，并给出了构造方法。代码简洁，思路清晰。
- **核心代码**：
  ```cpp
  if ((n - 1) % 4 == 0) {
      putchar('0');
      for (int i = 1; i <= (n - 1) / 4; i++) printf("0110");
  } else printf("-1");
  ```

#### 3. **题解作者：__Allen_123__ (4星)**
- **关键亮点**：通过数学推导和样例分析，得出了 $n \bmod 4 = 1$ 时有解的结论，并给出了构造方法。代码简洁，逻辑清晰。
- **核心代码**：
  ```cpp
  if (n % 4 != 1 || n == 1) {
      printf("-1");
  } else {
      printf("0");
      for (int i = 1; i <= n / 4; i++) printf("0110");
  }
  ```

### 最优关键思路与技巧

1. **数学推导**：通过分析子串数量和出现次数的关系，得出 $n \bmod 4 = 1$ 时有解的结论。
2. **构造方法**：通过循环输出 `0110` 并在前面加上一个 `0`，确保四种子串出现次数相等。
3. **代码优化**：使用简单的循环和条件判断，实现高效的构造。

### 可拓展之处

1. **类似问题**：可以扩展到更多种类的子串出现次数相等的问题，如长度为 $3$ 的子串等。
2. **构造方法**：类似的构造方法可以应用于其他需要特定子串出现次数的字符串构造问题。

### 推荐题目

1. **P8437 伟大的神**：考察构造和数学推导能力。
2. **P8588 构造字符串**：类似构造问题，要求特定子串出现次数相等。
3. **P8589 构造字符串 II**：进一步考察构造和数学推导能力。

### 个人心得总结

- **调试经历**：通过DFS验证构造的可行性，避免了复杂的数学推导。
- **顿悟感想**：构造问题往往可以通过观察样例和简单的数学推导找到规律，避免复杂的算法设计。

---
处理用时：33.46秒
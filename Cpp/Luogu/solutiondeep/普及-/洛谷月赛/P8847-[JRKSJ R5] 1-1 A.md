# 题目信息

# [JRKSJ R5] 1-1 A

## 题目背景

本题是 1-1 的较易版本，较难版本为 [1-1 B](https://www.luogu.com.cn/problem/P8848)。

## 题目描述

给出一个序列 $a$，$\forall i\in [1,n],a_i\in \{1,-1\}$。

你可以将序列任意重排，需最小化重排后序列的最大子段和。

## 说明/提示

最大子段和的定义：序列中一段区间的和的最大值。即 $\max_{1\le l\le r\le n} \sum_{i=l}^r a_i$。

本题使用 $\text{Special Judge}$，只要你的输出满足题意即可通过。

**本题输入输出文件较大，请使用恰当的输入输出方式。**

### 数据规模
本题采用捆绑测试。

| $\text{Subtask}$ | $n\le$ | $\text{Score}$ |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | $40$ |
| $2$ | $10^6$ | $60$ |

对于 $100\%$ 的数据，$1\le n\le 10^6$，$a_i\in \{1,-1\}$。

## 样例 #1

### 输入

```
4
1 1 -1 -1```

### 输出

```
1 -1 -1 1```

# AI分析结果

### 综合分析与结论

本题的核心目标是通过重排序列，最小化最大子段和。由于序列中只有 `1` 和 `-1`，题解大多基于贪心策略，通过统计 `1` 和 `-1` 的数量，并交替排列它们来达到最优解。大部分题解的时间复杂度为 `O(n)`，能够高效处理 `n ≤ 1e6` 的数据规模。

**关键思路**：
1. **分类讨论**：根据 `1` 和 `-1` 的数量关系，分为三种情况处理：
   - `-1` 的数量大于 `1` 的数量：交替排列 `1` 和 `-1`，多余的 `-1` 放在末尾。
   - `-1` 的数量等于 `1` 的数量：完全交替排列 `1` 和 `-1`。
   - `-1` 的数量小于 `1` 的数量：交替排列 `1` 和 `-1`，多余的 `1` 放在末尾。
2. **贪心策略**：通过交替排列 `1` 和 `-1`，使得子段和尽可能小，避免连续的 `1` 或 `-1` 导致子段和过大。
3. **数学证明**：部分题解通过数学证明，说明这种排列方式能够达到最小化最大子段和的目的。

**优化与拓展**：
- **时间复杂度**：所有题解的时间复杂度均为 `O(n)`，能够高效处理大规模数据。
- **代码简洁性**：部分题解通过简洁的代码实现，减少了冗余逻辑，提升了代码可读性。
- **拓展思路**：类似的问题可以应用于其他需要最小化或最大化子段和的场景，如最小化最大子段积等。

### 评分较高的题解

#### 1. 作者：U_star (5星)
**关键亮点**：
- **分类讨论清晰**：详细分析了 `1` 和 `-1` 数量关系的三种情况，并给出了每种情况的最优排列方式。
- **数学证明**：通过数学证明，说明这种排列方式能够达到最小化最大子段和的目的。
- **代码简洁**：代码逻辑清晰，易于理解，且时间复杂度为 `O(n)`。

**核心代码**：
```cpp
if(v2==v1) {
    for(int i=1;i<=n;i++) {
        if(i%2) cout<<1<<" ";
        else cout<<-1<<" ";
    }
} else if(v2>v1) {
    for(int i=1;i<=v1*2;i++) {
        if(i%2) cout<<1<<" ";
        else cout<<-1<<" ";
    }
    for(int i=1;i<=n-v1*2;i++) cout<<-1<<" ";
} else {
    for(int i=1;i<=v2*2;i++) {
        if(i%2) cout<<1<<" ";
        else cout<<-1<<" ";
    }
    for(int i=1;i<=n-v2*2;i++) cout<<1<<" ";
}
```

#### 2. 作者：Vct14 (4星)
**关键亮点**：
- **思路清晰**：通过统计 `1` 和 `-1` 的数量，交替排列它们，多余的数放在末尾。
- **代码简洁**：代码逻辑简单，易于实现，时间复杂度为 `O(n)`。

**核心代码**：
```cpp
for(int i=1; i<=min(m,o); i++) printf("1 -1 ");
int k=(m>=o)?-1:1;
for(int i=1; i<=abs(m-o); i++) printf("%d ",k);
```

#### 3. 作者：pxb0801 (4星)
**关键亮点**：
- **分类讨论**：详细分析了 `1` 和 `-1` 数量关系的两种情况，并给出了每种情况的最优排列方式。
- **代码简洁**：代码逻辑清晰，易于理解，且时间复杂度为 `O(n)`。

**核心代码**：
```cpp
if(cnt1>cnt2) {
    for(int i=1;i<=cnt2;i++) printf("1 -1 ");
    for(int i=cnt2+1;i<=cnt1;i++) printf("1 ");
} else {
    for(int i=1;i<=cnt1;i++) printf("1 -1 ");
    for(int i=cnt1+1;i<=cnt2;i++) printf("-1 ");
}
```

### 推荐题目
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1044 栈](https://www.luogu.com.cn/problem/P1044)

### 个人心得总结
- **调试经历**：部分题解提到在交替排列时，需要注意 `1` 和 `-1` 的顺序，避免将 `1` 放在后面导致最大子段和增加。
- **顿悟感想**：通过交替排列 `1` 和 `-1`，可以有效地减少子段和的最大值，这种贪心策略在类似问题中具有通用性。

---
处理用时：39.98秒
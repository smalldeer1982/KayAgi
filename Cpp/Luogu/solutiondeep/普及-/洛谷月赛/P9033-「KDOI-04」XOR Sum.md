# 题目信息

# 「KDOI-04」XOR Sum

## 题目背景

凯文一眼秒了这题。

![](https://cdn.luogu.com.cn/upload/image_hosting/lh1xvu75.png)

## 题目描述

给定一个正整数 $n$，请构造一个长度为 $n$ 的**非负整数**序列 $a_1,a_2,\dots,a_n$，满足：

+ 对于所有 $1\le i\le n$，都有 $0\le a_i\le m$。
+ $a_1\oplus a_2\oplus\dots\oplus a_n=k$。其中 $\oplus$ 表示[按位异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)运算。

或者判断不存在这样的序列。

## 说明/提示

**【样例解释】**

对于第 $1$ 组测试数据，有且仅有一个序列满足条件。

对于第 $2$ 组测试数据，由于 $4\oplus 7=3$ 且 $4,7\le10$，所以这是一个合法的答案。同样地，序列 $(2,1)$ 也是一个合法的答案。

对于第 $4$ 组测试数据，可以证明不存在满足要求的序列。

**【数据范围】**

记 $\sum n$ 为单个测试点中所有 $n$ 的值之和。

对于所有测试数据，保证 $1\le T\le 1~000$，$1\le n\le 2\cdot10^5$，$0\le m,k\le 10^8$，$\sum n\le 2\cdot10^5$。

**【子任务】**

**本题开启捆绑测试。**

+ Subtask 1 (18 pts)：$k\le m$。
+ Subtask 2 (82 pts)：没有额外的约束条件。

## 样例 #1

### 输入

```
5
1 2 2
2 3 10
2 11 8
20 200000 99999
11 191 9810```

### 输出

```
2 
4 7 
8 3 
-1
191 191 191 191 191 191 191 191 191 191 191 ```

# AI分析结果

### 综合分析与结论

本题的核心在于如何构造一个长度为 \( n \) 的非负整数序列，使得序列中的每个元素不超过 \( m \)，且整个序列的异或和为 \( k \)。难点在于处理 \( k > m \) 的情况，此时需要将 \( k \) 拆分为两个或多个不超过 \( m \) 的数，同时保证它们的异或和为 \( k \)。

从题解中可以看出，大多数解法都基于以下关键思路：
1. **异或性质**：任何数异或 0 等于其本身，且异或操作不会增加二进制位数。
2. **二进制拆分**：当 \( k > m \) 时，通过将 \( k \) 拆分为两个数，其中一个数为 \( 2^{\lfloor \log_2 k \rfloor} \)，另一个数为 \( k - 2^{\lfloor \log_2 k \rfloor} \)，确保这两个数都不超过 \( m \)。
3. **无解判断**：当 \( k \) 的二进制位数大于 \( m \) 的二进制位数时，无解。

### 所选高星题解

#### 1. **作者：JuRuoOIer (5星)**
- **关键亮点**：思路清晰，代码简洁，详细解释了异或的性质和二进制拆分的逻辑，特别是在 \( k > m \) 时的处理方式。
- **核心代码**：
  ```cpp
  if(log2(m)<log2(k)){//m 的二进制长度小于 k，无解 
      cout<<"-1\n";
  }
  else if(m<k){//m<k 的情况，见 Part2-2 
      if(n==1)cout<<"-1\n";//一项不够，无解 
      else{
          cout<<(1ll<<log2(k)-1)<<' '<<k-(1ll<<log2(k)-1);//左移，1<<k 结果为 2^k 
          for(int i=0;i<n-2;i++){//补 0 
              cout<<" 0";
          }
          cout<<endl;
      }
  }
  else{
      cout<<k;
      for(int i=0;i<n-1;i++){//补 0 
          cout<<" 0";
      }
      cout<<endl;
  }
  ```
- **个人心得**：作者提到“任何数异或 0 等于其本身”，这一性质在构造序列时非常有用，尤其是在 \( k \leq m \) 时，直接输出 \( k \) 和 \( n-1 \) 个 0 即可。

#### 2. **作者：_determination_ (4星)**
- **关键亮点**：提供了另一种思路，通过 `lowbit` 操作逐步拆分 \( k \)，并在每一步中尽可能让拆出的数不超过 \( m \)，最终判断 \( k \) 是否为 0。
- **核心代码**：
  ```cpp
  while(k){
      x=0;
      while(k>0&&x+lowbit(k)<=m){
          x+=lowbit(k);
          k-=lowbit(k);
      }
      ans[++al]=x;
      if(al>n){
          cout<<"-1";
          return;
      }
  }
  ```
- **个人心得**：作者提到“值能小则不会更大”，这种贪心思想在拆分 \( k \) 时非常有效，能够确保构造出的序列尽可能简洁。

#### 3. **作者：Clarinet (4星)**
- **关键亮点**：通过直接计算 \( k \oplus m \) 来得到第二个数，确保两个数都不超过 \( m \)，思路简洁明了。
- **核心代码**：
  ```cpp
  if(check(m,k)){
      cout<<-1<<endl;
      continue;
  }
  if(m>=k){
      cout<<k;
      for(int i=1;i<=n-1;i++)cout<<" 0";
      cout<<endl;
      continue;
  }
  if(n==1){
      cout<<-1<<endl;
      continue;
  }
  int ans=k^m;
  cout<<m<<" "<<ans;
  for(int i=2;i<=n-1;i++)cout<<" 0";
  cout<<endl;
  ```
- **个人心得**：作者提到“异或后的数字位数一定不会变大”，这一性质在判断无解时非常关键，能够快速排除不可能的情况。

### 最优关键思路与技巧

1. **二进制拆分**：当 \( k > m \) 时，通过将 \( k \) 拆分为两个数，其中一个数为 \( 2^{\lfloor \log_2 k \rfloor} \)，另一个数为 \( k - 2^{\lfloor \log_2 k \rfloor} \)，确保这两个数都不超过 \( m \)。
2. **异或性质**：利用异或的性质，特别是“任何数异或 0 等于其本身”，在构造序列时非常有用。
3. **贪心思想**：在拆分 \( k \) 时，尽可能让拆出的数小，以确保构造出的序列尽可能简洁。

### 可拓展之处

本题的解法可以拓展到其他需要构造满足特定条件的序列的问题，特别是涉及到二进制操作和贪心思想的问题。例如，类似的问题可能要求构造一个序列，使得序列中的元素满足某些位运算条件（如与、或等）。

### 推荐题目

1. **P3919 【模板】可持久化线段树 1（主席树）** - 考察二进制操作和数据结构。
2. **P4551 最长异或路径** - 考察异或性质和树形结构。
3. **P5495 【模板】线性基** - 考察线性基和异或操作。

### 个人心得总结

从题解中可以看出，掌握异或的性质和二进制拆分的技巧是解决本题的关键。此外，贪心思想在构造序列时也非常有用，能够确保构造出的序列尽可能简洁。在调试过程中，需要注意特判 \( n = 1 \) 的情况，以及 \( k \) 和 \( m \) 的二进制位数关系，避免无解的情况。

---
处理用时：48.25秒
# 题目信息

# 异或积

## 题目背景

$\texttt{id: 4d7e}$

小 H 在课堂上学习了异或运算。

对于两个非负整数 $x,y$，它们的**异或**是指，将它们作为二进制数，对二进制表示中的每一位进行如下运算得到的结果：

- $x$ 和 $y$ 的这一位上不同时，结果的这一位为 $1$；
- $x$ 和 $y$ 的这一位上相同时，结果的这一位为 $0$。

$x$ 和 $y$ 的异或被记为 $x \operatorname{xor} y$ 或 $x \oplus y$。

在 C++ 中，你可以用 `x ^ y` 得到 $x$ 与 $y$ 的异或值。

另外，若干个数的异或称之为**异或和**。

## 题目描述

小 H 还了解到，一个长度为 $n$ 的数列 $a$ 的**异或积**是一个等长的数列 $b$，其中 $b_i$ 等于数列 $a$ 中除了 $a_i$ 以外其他元素的异或和，即
	
$$b_i = \bigoplus \limits_{j = 1}^{n} [j\ne i] a_j$$
	
例如，数列 $\{1, 2, 3, 4\}$ 的异或积为 $\{5, 6, 7, 0\}$。
	
**异或积变换**是指将一个数列用它的异或积替换的过程，由于异或积变换之后数列长度不变，所以异或积变换可以连续进行多次。
	
现在，小 H 有一个长度为 $n$ 的数列 $a$，他想请你帮他计算出 $a$ 经过 $k$ 次异或积变换之后得到的序列。

## 说明/提示

### 样例 1 解释

此样例即为题目描述中的例子。

### 样例 2 解释

第 $1$ 次异或积变换：$\{0,0,0,1\}\to\{1,1,1,0\}$；

第 $2$ 次异或积变换：$\{1,1,1,0\}\to\{0,0,0,1\}$。

### 数据规模与约定

对于 $100\%$ 的测试数据，$1 \le T \le 10$，$2 \le n \le 10^5$，$1 \le k \le 10^{18}$，$0 \le a_i < 2^{32}$。

| 测试点编号 | $n\leq$  | $k \leq$  |特殊性质|
| :----------: | :----------: | :----------: | :-----------: |
| $1 \sim 3$ | $100$ | $100$ | |
| $4 \sim 5$ | $1000$ | $1000$ | |
| $6 \sim 7$ | $3$ | $10^{18}$ | |
| $8 \sim 10$ | $10^5$ | $3$ | |
| $11 \sim 13$ | $10^5$ | $10^{18}$ | $a$ 中所有数的异或和为 $0$ |
| $14 \sim 15$ | $10^5$ | $10^{18}$ | $n$ 为奇数 |
| $16 \sim 17$ | $10^5$ | $10^{18}$ | $n$ 为偶数 |
| $18 \sim 20$ | $10^5$ | $10^{18}$ | |

### 提示

在 C++ 中，对于数据范围 $0\le x<2^{32}$，你可以：

- 使用 `unsigned int x` 来定义；
- 使用 `cin >> x` 或 `scanf("%u", &x)` 来输入；
- 使用 `cout << x` 或 `printf("%u", x)` 来输出。 

## 样例 #1

### 输入

```
1
4 1
1 2 3 4```

### 输出

```
5 6 7 0```

## 样例 #2

### 输入

```
1
4 2
0 0 0 1```

### 输出

```
0 0 0 1```

## 样例 #3

### 输入

```
见附件中的 samples/xor3.in```

### 输出

```
见附件中的 samples/xor3.ans```

# AI分析结果

### 综合分析与结论

本题的核心在于理解异或积变换的性质，并通过数学推导找到规律，避免直接模拟带来的高时间复杂度。大多数题解都通过分析异或运算的性质，得出了以下关键结论：

1. **当 `n` 为奇数时**，经过一次变换后，数列不再发生变化。
2. **当 `n` 为偶数时**，数列会在原数列和变换后的数列之间来回切换，具体取决于 `k` 的奇偶性。

基于这些规律，题解们提出了不同的优化策略，最终将时间复杂度从 `O(nk)` 降低到 `O(n)`，从而能够处理 `k` 高达 `10^18` 的情况。

### 所选高星题解

#### 1. 作者：hhoppitree (赞：14) - 5星
**关键亮点**：
- **清晰的数学推导**：通过异或运算的性质，详细推导了 `n` 为奇数和偶数时数列的变化规律。
- **简洁的代码实现**：直接根据 `n` 和 `k` 的奇偶性决定是否进行变换，代码简洁高效。
- **时间复杂度优化**：将时间复杂度从 `O(nk)` 优化到 `O(n)`，完美解决了大数据范围的问题。

**核心代码**：
```cpp
if (n % 2 == 0 && k % 2 == 0) {
    for (int i = 1; i <= n; i++) printf("%lld ", a[i]);
} else {
    work(); // 进行一次变换
    for (int i = 1; i <= n; i++) printf("%lld ", b[i]);
}
```
**实现思想**：根据 `n` 和 `k` 的奇偶性，决定是否进行变换，避免不必要的计算。

#### 2. 作者：August_Light (赞：2) - 4星
**关键亮点**：
- **详细的分类讨论**：对 `n` 和 `k` 的奇偶性进行了详细的分类讨论，逻辑清晰。
- **时间复杂度优化**：同样将时间复杂度优化到 `O(n)`，适合处理大数据范围。
- **代码可读性高**：代码结构清晰，易于理解。

**核心代码**：
```cpp
if (n % 2 == 1 || k % 2 == 1) mov(); // 进行一次变换
print(); // 输出结果
```
**实现思想**：通过 `mov()` 函数进行一次变换，根据 `n` 和 `k` 的奇偶性决定是否调用该函数。

#### 3. 作者：joyslog (赞：1) - 4星
**关键亮点**：
- **简洁的数学推导**：通过异或运算的性质，快速推导出数列的变化规律。
- **高效的代码实现**：直接根据 `n` 和 `k` 的奇偶性决定是否进行变换，代码简洁高效。
- **时间复杂度优化**：将时间复杂度优化到 `O(n)`，适合处理大数据范围。

**核心代码**：
```cpp
if ((n & 1) || (!(n & 1) && (k & 1))) {
    for (int i = 1; i <= n; i++) write(sum ^ a[i]), putchar(' ');
} else {
    for (int i = 1; i <= n; i++) write(a[i]), putchar(' ');
}
```
**实现思想**：根据 `n` 和 `k` 的奇偶性，决定是否进行变换，避免不必要的计算。

### 最优关键思路与技巧

1. **异或运算的性质**：利用异或运算的自反性（`a ^ a = 0`）和结合律，快速推导出数列的变化规律。
2. **分类讨论**：根据 `n` 和 `k` 的奇偶性，决定是否进行变换，避免不必要的计算。
3. **时间复杂度优化**：通过数学推导，将时间复杂度从 `O(nk)` 优化到 `O(n)`，适合处理大数据范围。

### 可拓展之处

1. **类似题目**：可以考察其他基于位运算的题目，如与运算、或运算等，理解它们的性质并进行类似的优化。
2. **数学推导**：在遇到类似问题时，可以通过数学推导找到规律，避免直接模拟带来的高时间复杂度。

### 推荐题目

1. **P3811 【模板】乘法逆元** - 考察数学推导与优化技巧。
2. **P1226 【模板】快速幂** - 考察位运算与数学推导的结合。
3. **P3374 【模板】树状数组 1** - 考察位运算在数据结构中的应用。

### 个人心得总结

- **调试经历**：在推导过程中，通过小规模的样例验证规律的正确性，避免了大范围数据下的错误。
- **踩坑教训**：在处理大数据范围时，直接模拟会导致超时，必须通过数学推导找到规律进行优化。
- **顿悟感想**：异或运算的性质在解决位运算相关问题时非常有用，理解其性质可以大大简化问题的复杂度。

---
处理用时：41.11秒
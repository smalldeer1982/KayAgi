# 题目信息

# 一曲新词酒一杯

## 题目背景

昨夜勾栏听曲，一壶浊酒，与明月凭栏相望，想起如今的处境，却没有怅然若失，仍然醉心于宴饮涵咏之乐，把酒临风之际，想起一种酒桌上的游戏，便和好友玩起来。

## 题目描述

酒桌上共有 $n$ 杯酒，标号为 $1\sim n$。桌旁有许多写有“酒”字的红色纸片。

接下来对这 $n$ 杯酒**依次**进行 $m$ 次操作。

操作共分为 $2$ 种：

- `1 x`：给 $x$ 号酒贴上 $1$ 张红纸。
- `2 x`：给除了 $x$ 号酒的其它 $n-1$ 杯酒分别贴上 $1$ 张红纸。

问在**至少**几次操作后，每杯酒上至少有一张红纸？


## 说明/提示

**【样例 1 解释】**

对于第一组数据：

- 第 $1$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $0$ 张红纸，$3$ 号酒有 $0$ 张红纸。
- 第 $2$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $1$ 张红纸，$3$ 号酒有 $0$ 张红纸。
- 第 $3$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $1$ 张红纸，$3$ 号酒有 $1$ 张红纸。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（20 points）：$o_i=1$。
-  Subtask 2（20 points）：$o_i=2$。
-  Subtask 3（20 points）：所有 $x_i$ 均相等。
-  Subtask 4（20 points）：$\sum n,\sum m\le 3\times 10^3$。
-  Subtask 5（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T,n,m,\sum n,\sum m\le 2\times 10^5$，$o_i\in \{1,2\}$，$1\le x_i\le n$。

## 样例 #1

### 输入

```
2
3 3
1 1
1 2
1 3
3 2
1 1
2 2```

### 输出

```
3
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于通过两种操作（单点加1和全局除某点加1）来确保所有酒杯至少有一张红纸。题解中主要分为以下几种思路：

1. **分类讨论**：通过分析不同操作组合（如操作1和操作2的组合、多次操作2的组合等）来判断何时所有酒杯都被贴上红纸。这种思路较为直观，但需要细致的分类讨论。
2. **数据结构优化**：使用`set`、`map`、线段树、珂朵莉树等数据结构来优化查询和修改操作，减少时间复杂度。这种思路适合大规模数据，但实现复杂度较高。
3. **模拟与优化**：通过模拟操作过程，结合优化策略（如提前终止、记录状态等）来减少不必要的计算。这种思路实现简单，但需要较好的优化策略。

### 所选高星题解

#### 1. **作者：VitrelosTia (4星)**
- **关键亮点**：通过开桶记录操作1和操作2的`x`值，判断何时满足条件。思路清晰，代码简洁，适合初学者理解。
- **代码核心**：
  ```cpp
  void solve() {
      int cnt1 = 0, cnt2 = 0;
      memset(vis1, false, sizeof vis1);
      memset(vis2, false, sizeof vis2);
      scanf ("%d%d", &n, &m);
      for (int i = 1; i <= m; i++) scanf ("%d%d", &o[i], &x[i]);
      for (int i = 1; i <= m; i++) {
          if (o[i] == 1) {
              if (vis2[x[i]]) {
                  cout << i << '\n';
                  return;
              }
              if (!vis1[x[i]]) cnt1++, vis1[x[i]] = true;
          }
          if (o[i] == 2) {
              if (vis1[x[i]]) {
                  cout << i << '\n';
                  return;
              }
              if (!vis2[x[i]]) cnt2++, vis2[x[i]] = true;
          }
          if (cnt2 > 1 || cnt1 == n) {
              cout << i << '\n';
              return;
          }
      }
      puts("-1");
  }
  ```

#### 2. **作者：Jasoncwx (4星)**
- **关键亮点**：使用`set`容器记录操作1和操作2的`x`值，判断何时满足条件。代码可读性强，适合中等水平选手。
- **代码核心**：
  ```cpp
  int main(){
      int T;cin>>T;
      while(T--){
          int n,m,ans=-1;
          cin>>n>>m;
          bool f=false;
          set<int>first,second;
          for(int i=1;i<=m;i++){
              short op;cin>>op;
              int x;cin>>x;
              if(f)continue;
              if(op==1)first.insert(x);
              else second.insert(x);
              if(first.size()==n||(first.find(x)!=first.end()&&second.find(x)!=second.end())||(second.size()>1)){
                  ans=i;
                  f=true;
              }
          }
          cout<<ans<<endl;
      }
  }
  ```

#### 3. **作者：喵仔牛奶 (4星)**
- **关键亮点**：通过维护全局加和单点减的操作，结合`tag`变量和`cnt`计数器来判断何时满足条件。思路新颖，适合进阶选手。
- **代码核心**：
  ```cpp
  int main() {
      cin >> n >> m, ans = -1;
      for (int i = 1; i <= m; i ++) {
          cin >> opt >> x;
          if (opt == 1) {
              if (tag + a[x] <= 0) cnt ++;
              a[x] ++;
          }
          if (opt == 2) {
              cnt = n;
              if (tag + a[x] <= 0) cnt --;
              tag ++, a[x] --;
          }
          if (cnt == n && ans == -1) ans = i;
      }
      cout << ans << '\n';
  }
  ```

### 最优关键思路与技巧

1. **分类讨论**：通过分析不同操作组合，判断何时所有酒杯都被贴上红纸。这种思路适合小规模数据，实现简单。
2. **数据结构优化**：使用`set`、`map`、线段树等数据结构来优化查询和修改操作，减少时间复杂度。这种思路适合大规模数据，但实现复杂度较高。
3. **模拟与优化**：通过模拟操作过程，结合优化策略（如提前终止、记录状态等）来减少不必要的计算。这种思路实现简单，但需要较好的优化策略。

### 可拓展之处

1. **类似题目**：可以拓展到其他需要判断何时满足条件的题目，如区间覆盖、区间查询等。
2. **算法套路**：可以结合其他数据结构（如树状数组、分块等）来优化类似问题。

### 推荐题目

1. **P3372 【模板】线段树 1**：考察线段树的基本操作，适合练习数据结构优化。
2. **P3368 【模板】树状数组 1**：考察树状数组的基本操作，适合练习数据结构优化。
3. **P1908 逆序对**：考察分治与数据结构结合，适合练习分类讨论与优化策略。

### 个人心得摘录

- **调试经历**：在实现过程中，多次遇到`memset`超时的问题，最终通过优化数据结构解决了问题。
- **踩坑教训**：在分类讨论时，漏掉了一些特殊情况，导致WA，通过细致分析解决了问题。
- **顿悟感想**：通过本题，深刻理解了数据结构在优化算法中的重要性，后续会更多练习相关题目。

---
处理用时：43.86秒
# 题目信息

# 「SiR-1」Checkmate

## 题目背景

这里本来有一串很长的背景，但是出题人觉得它实在太长了，所以就把它删掉了。

「来吧，游戏开始了。」

## 题目描述

有一个 $n$ 行 $m$ 列的棋盘。你要在这个棋盘上的所有格子**依次**放置一个棋子。

每当你放置一个棋子，你将会获得一定的分数，获得的分数为**放置时**你放置的这个棋子旁边的格子中没有放置棋子的格子的个数。这里「旁边」指的是上、下、左、右的相邻格子。

你想知道，在**按照最优策略决策放置棋子的顺序的情况下**，你最终得分总和的最大值。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（20 points）：$n, m \leq 3$，$T \leq 5$。
- Subtask 2（20 points）：$n, m \leq 4$，$T \leq 10$。
- Subtask 3（20 points）：$n=1$。
- Subtask 4（20 points）：$n=m$。
- Subtask 5（20 points）：无特殊限制。

对于所有测试数据，$1 \leq n, m \leq 10^8$，$1 \leq T \leq 10^5$。

## 样例 #1

### 输入

```
4
1 3
2 2
3 4
7 13```

### 输出

```
2
4
17
162```

# AI分析结果

### 综合分析与结论

该题的核心在于理解棋子放置顺序对最终得分的影响。通过分析相邻格子的得分贡献，可以发现无论放置顺序如何，最终得分都是固定的。因此，问题的关键在于计算棋盘上所有相邻格子的对数，即横向和纵向相邻的格子数之和。

大多数题解都通过数学推导得出了相同的结论：最终得分为 `2 * n * m - n - m`。部分题解还通过分类讨论或打表的方式验证了这一结论的正确性。整体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，而另一些则显得冗长且不够优化。

### 所选高星题解

#### 1. 题解作者：zhlzt (5星)
**关键亮点**：简洁明了的数学推导，代码实现高效。
**个人心得**：通过分析相邻格子的得分贡献，直接得出公式，避免了复杂的分类讨论。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int T;scanf("%d",&T);
    while(T--){
        long long n,m;
        scanf("%lld%lld",&n,&m);
        printf("%lld\n",2*n*m-n-m);
    }
    return 0;
}
```

#### 2. 题解作者：251Sec (4星)
**关键亮点**：通过分析相邻格子的得分贡献，解释了为什么放置顺序不影响最终得分。
**个人心得**：强调了相邻格子对得分的贡献，并通过简单的数学推导得出结论。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int T;
ll n, m;
int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%lld%lld", &n, &m);
        printf("%lld\n", 2 * n * m - n - m);
    }
    return 0;
}
```

#### 3. 题解作者：lailai0916 (4星)
**关键亮点**：通过横向和纵向相邻格子的对数直接计算得分，思路清晰。
**个人心得**：通过简单的数学公式直接计算得分，避免了复杂的分类讨论。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin>>T;
    while(T--)
    {
        ll n,m;
        cin>>n>>m;
        cout<<n*m*2-n-m<<'\n';
    }
    return 0;
}
```

### 最优关键思路与技巧

1. **相邻格子贡献分析**：通过分析相邻格子的得分贡献，发现无论放置顺序如何，最终得分都是固定的。这一思路简化了问题的复杂度，直接通过数学公式计算得分。
2. **数学推导**：通过数学推导得出 `2 * n * m - n - m` 的公式，避免了复杂的分类讨论和模拟过程。
3. **代码优化**：代码实现简洁高效，直接输出公式结果，避免了不必要的计算和条件判断。

### 拓展与举一反三

1. **类似题目**：
   - [P9133 [THUPC 2023 初赛] 大富翁](https://www.luogu.com.cn/problem/P9133)
   - [P1002 [NOIP2002 普及组] 过河卒](https://www.luogu.com.cn/problem/P1002)
   - [P1219 [USACO1.5] 八皇后](https://www.luogu.com.cn/problem/P1219)

2. **调试与顿悟**：部分题解通过打表或模拟验证了公式的正确性，这一方法在解决类似问题时也可以借鉴。通过小规模的模拟，可以更好地理解问题的本质，从而推导出通用的解决方案。

### 总结

通过分析相邻格子的得分贡献，可以简化问题并直接通过数学公式计算得分。这一思路不仅适用于本题，也可以推广到其他类似的棋盘或网格问题中。

---
处理用时：29.90秒
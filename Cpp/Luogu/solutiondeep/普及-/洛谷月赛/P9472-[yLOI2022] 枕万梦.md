# 题目信息

# [yLOI2022] 枕万梦

## 题目背景

> 岁月冥冥之中 星移物换 将韶华歌颂  
> 人潮冥冥之中 一眼望穿 日月去无踪  
> 你我冥冥之中 心有灵犀 何止几万梦  
> 忘情在这久违的重逢  
> 天地冥冥之中 云烟奔涌 摩肩又接踵  
> 万籁冥冥之中 不肯缄默 盛大到无穷  
> 你我冥冥之中 对坐天涯 灵犀才一动  
> 就相遇在咫尺的时空

银临《枕万梦》

## 题目描述

天亮了，扶苏不敌困意，早早地进入了梦乡。在失去引力的梦里，扶苏遇到了好多串漂浮着的数列，它们的长度都相等，而且都是美妙的等比数列！出于本能，扶苏想要把这些数列按照字典序排序，可是在梦里扶苏失去了思考的能力，请你来帮帮她！

具体地，有 $n$ 个编号从 $1$ 到 $n$ 的数列 $a_1, a_2, \dots a_n$，每个数列的长度均为 $m + 1$。第 $i$ 个数列 $a_i$ 满足递推式 $a_{i,j} = a_{i,j - 1} \times i$，其中 $1 \leq j \leq m$。而扶苏会告诉你每个序列的首项 $a_{i,0}$，你需要帮助她把这些数列按字典序排序。

## 说明/提示

### 样例 1 解释

共有两个数列，每个数列的长度均为 $2+1=3$。

对第一个数列 $a_1$：
- 已知其首项 $a_{1,0} = 1$。
- 根据 $a_{i,j} = a_{i,j - 1} \times i$，取 $i=1,j = 1$ 可以得到 $a_{1,1} = a_{1,0} \times 1 = 1$。
- 根据 $a_{i,j} = a_{i,j - 1} \times i$，取 $i=1,j = 2$ 可以得到 $a_{1,2} = a_{1,1} \times 1= 1$。

所以数列 $a_1$ 是 $1,1,1$。

对第二个数列 $a_2$：
- 已知其首项 $a_{2,0} = 2$。
- 根据 $a_{i,j} = a_{i,j - 1} \times i$，取 $i=2,j = 1$ 可以得到 $a_{2,1} = a_{2,0} \times 2 = 2 \times 2 = 4$。
- 根据 $a_{i,j} = a_{i,j - 1} \times i$，取 $i=2,j = 2$ 可以得到 $a_{2,2} = a_{2,1} \times 2= 4 \times 2 = 8$。

所以数列 $a_2$ 是 $2,4,8$。

比较字典序可得数列 $a_1$ 是字典序最小的数列。所以输出 $1$。

### 样例 2 解释

数列 $a_1$ 为 $1,1,1,1$，数列 $a_2$ 为 $-1, -2,-4,-8$。

### 数据规模与约定
本题共 $10$ 个测试点，各测试点信息如下表：

![](https://cdn.luogu.com.cn/upload/image_hosting/08wnuome.png)

特殊约定 A：保证 $a_{i,0}$ 均相等。  
特殊约定 B：保证 $a_{i,0}$ 互不相等。

对全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 10^9$，$1 \leq |a_{i,0}| \leq 10^9$。


### 提示

对两个数列 $a_i, a_j$，按如下方式比较其字典序：

找到**最小的**满足 $a_{i,p} \neq a_{j, p}$ 的下标 $p$，比较 $a_{i, p}$ 和 $a_{j, p}$ 的大小：

- 如果 $a_{i,p} < a_{j, p}$，则称 $a_i$ 的字典序比 $a_j$ 的小。
- 如果 $a_{i,p} > a_{j, p}$，则称 $a_i$ 的字典序比 $a_j$ 的大。

可以证明，在本题的限制下，这样的 $p$ 一定存在。

## 样例 #1

### 输入

```
2 2
1
2```

### 输出

```
1 2```

## 样例 #2

### 输入

```
2 3
1
-1```

### 输出

```
2 1```

## 样例 #3

### 输入

```
2 2
1
1```

### 输出

```
1 2```

## 样例 #4

### 输入

```
见附加文件中的 B4.in```

### 输出

```
见附加文件中的 B4.ans```

# AI分析结果

### 综合分析与结论

本题的核心任务是将多个等比数列按字典序排序，难点在于如何处理首项相同的情况，尤其是当首项为负数时，公比（即数列编号）的大小会影响第二项的大小。大多数题解都采用了结构体存储数列的首项和编号，并通过自定义比较函数来实现排序。部分题解在处理首项相同的情况时，考虑了首项的正负性，从而避免了直接计算第二项带来的溢出问题。

### 所选高质量题解

#### 1. 作者：cff_0102 (赞：11)  
**星级：5星**  
**关键亮点：**  
- 简洁明了地解释了字典序排序的逻辑，尤其是首项相同时的处理方式。
- 代码结构清晰，使用了`long long`避免了溢出问题。
- 提供了赛时未开`long long`导致失分的教训，强调了数据类型选择的重要性。

**核心代码：**
```cpp
struct arr{
    long long a0; // 第 0 项
    long long a1; // 第 1 项 
    long long n;  // 编号 / 公比
}a[114514];

bool cmp(arr x, arr y){
    if(x.a0 != y.a0) return x.a0 < y.a0;
    else return x.a1 < y.a1;
}
```
**实现思想：**  
通过结构体存储数列的首项、第二项和编号，自定义比较函数先按首项排序，首项相同则按第二项排序。

#### 2. 作者：wangcht (赞：5)  
**星级：4星**  
**关键亮点：**  
- 详细解释了首项为正负数时的不同处理逻辑，避免了直接计算第二项。
- 代码简洁，逻辑清晰，适合初学者理解。

**核心代码：**
```cpp
struct node{
    int a, id;
}b[100010];

bool cmp(node x, node y){
    if (x.a != y.a) return x.a < y.a;
    if(x.a < 0 && y.a < 0) return x.id > y.id;
    return x.id < y.id;
}
```
**实现思想：**  
通过结构体存储数列的首项和编号，自定义比较函数先按首项排序，首项相同则根据首项的正负性决定编号的排序方式。

#### 3. 作者：1qaz234Q (赞：3)  
**星级：4星**  
**关键亮点：**  
- 提供了详细的题目分析和时间复杂度分析，适合进阶学习者。
- 代码结构清晰，使用了`long long`避免了溢出问题。

**核心代码：**
```cpp
struct node{
    int a1; // 数列的第一个数
    int a2; // 数列的第二个数
    int id; // 数列的编号
}a[N];

bool cmp(node x, node y){
    if (x.a1 == y.a1) return x.a2 < y.a2;
    return x.a1 < y.a1;
}
```
**实现思想：**  
通过结构体存储数列的首项、第二项和编号，自定义比较函数先按首项排序，首项相同则按第二项排序。

### 最优关键思路与技巧

1. **结构体存储与自定义排序**：使用结构体存储数列的首项、第二项和编号，通过自定义比较函数实现字典序排序。
2. **首项正负性处理**：当首项相同时，根据首项的正负性决定编号的排序方式，避免直接计算第二项带来的溢出问题。
3. **数据类型选择**：使用`long long`避免溢出，确保大数计算的正确性。

### 可拓展之处

- **类似题目**：处理等比数列或等差数列的排序问题时，可以借鉴本题的思路，尤其是首项相同时的处理方式。
- **优化思路**：对于更复杂的数列排序问题，可以考虑使用更高效的数据结构（如堆）或算法（如快速排序）进行优化。

### 推荐题目

1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 考察优先队列的使用，适合练习自定义排序。
2. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177) - 练习快速排序的实现，适合理解排序算法的底层逻辑。
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223) - 考察贪心算法与排序的结合，适合练习自定义排序的应用。

### 个人心得总结

- **调试经历**：多位作者提到未开`long long`导致失分，强调了数据类型选择的重要性。
- **踩坑教训**：在处理首项相同的情况时，直接计算第二项可能导致溢出，应优先考虑首项的正负性。
- **顿悟感想**：通过结构体存储和自定义排序，可以高效解决复杂的排序问题，代码可读性和可维护性也更高。

---
处理用时：35.13秒
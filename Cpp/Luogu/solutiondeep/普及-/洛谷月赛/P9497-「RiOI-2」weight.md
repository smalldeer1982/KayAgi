# 题目信息

# 「RiOI-2」weight

## 题目背景

在小树林间坐落着一个幻想的城堡。这里是 E 国的领地，而小 E，则是 E 国之王。

树木，是 E 国抵挡袭击的法宝。树木越高，越能蒙蔽敌人的视线。

可是，随着自然条件的退化，小 E 却不知怎么处理。怎么办呢？

## 题目描述

给定一个 $n$ 行 $n$ 列 的矩阵 $a$。

有 $q$ 组询问，每次给定一个 $v$，请将矩阵每一行任意重排（可以不重排），最大化**最大值不小于** $v$（也就是说，至少有一个不小于 $v$ 的数）的列数。请输出这个列数。

询问之间相互独立。换言之，每次询问前可以重新排列。


## 说明/提示

### 样例解释

原矩阵为 $\begin{bmatrix}9&9&8\\2&4&4\\3&5&3\end{bmatrix}$。

对于第一次询问，每一列的最大值 $9,9,8$ 均不小于 $v=5$，所以每一列都符合条件，答案为 $3$。显然无论怎么重排都不可能超过 $3$ 列（因为总共只有 $3$ 列），所以答案为 $3$。

### 数据规模与约定

**本题开启捆绑测试。**

| $\text{Subtask}$ | 分值 | $n \leq$ | $q \leq$ |
| :--------------: | :--: | :------: | :------: |
| $0$ | $10$ | $3$ | $10$ |
| $1$ | $40$ | $100$ | $10^3$ |
| $2$ | $50$ | $10^3$ | $5\times 10^5$ |

对于所有数据，$1 \leq n \leq 10^3$，$1 \leq q \leq 5\times 10^5$，$1 \leq a_{i,j}, v \leq 10^9$。

## 样例 #1

### 输入

```
3 3
9 9 8
2 4 4
3 5 3
5
9
10```

### 输出

```
3
2
0```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何在矩阵的每一行任意重排后，最大化满足“至少有一个不小于 $v$ 的数”的列数。多数题解都采用了将矩阵展平为一维数组并排序，然后通过二分查找来快速计算满足条件的列数。这种方法的时间复杂度为 $O(n^2 \log n + q \log n)$，能够有效处理大规模数据。

### 所选高星题解

#### 1. 作者：include13_fAKe (4星)
- **关键亮点**：通过排序和二分查找优化了查询效率，代码简洁且易于理解。作者还提到了从大到小排序的优化思路，虽然最终代码中使用了从小到大排序，但思路清晰。
- **代码核心思想**：将矩阵展平为一维数组并排序，然后通过二分查找确定满足条件的列数。
```cpp
void solve(int v){
    int l=n*(n-1)+1;
    int r=n*n;
    if(v<=a[l]){
        printf("%d\n",n);
        return;
    }
    if(v>a[r]){
        printf("0\n");
        return;
    }
    int mid=l+r>>1;
    while(l<r){
        if(v<=a[mid]) r=mid;
        else l=mid+1;
        mid=l+r>>1;
    }
    printf("%d\n",n*n+1-l);
}
```

#### 2. 作者：Meny__love (4星)
- **关键亮点**：使用了 `lower_bound` 和 `upper_bound` 进行二分查找，代码简洁且高效。作者还提到了对 `upper_bound` 的不熟悉，但通过双二分查找确保了准确性。
- **代码核心思想**：将矩阵展平为一维数组并排序，然后通过 `lower_bound` 和 `upper_bound` 查找满足条件的列数。
```cpp
int mid=lower_bound(a+1,a+len+1,x)-a;
int mid1=upper_bound(a+1,a+len+1,x)-a;
if(a[mid]==x) printf("%d\n",min(len-mid+1,n));
else if(a[mid1]>x) printf("%d\n",min(len-mid1+1,n));
else printf("0\n");
```

#### 3. 作者：Aegleseeker_ (4星)
- **关键亮点**：通过贪心思想简化了问题，直接计算满足条件的数的个数，并与 $n$ 取最小值。代码简洁且思路清晰。
- **代码核心思想**：将矩阵展平为一维数组并排序，然后通过 `lower_bound` 查找满足条件的列数。
```cpp
int p=lower_bound(a,a+n*n,v)-a;
if(p==n*n){
    puts("0");
}else{
    write(min(n,n*n-p));
    puts("");
}
```

### 最优关键思路与技巧
1. **矩阵展平与排序**：将二维矩阵展平为一维数组并排序，简化了问题的处理。
2. **二分查找**：通过二分查找快速确定满足条件的列数，显著提高了查询效率。
3. **贪心思想**：直接计算满足条件的数的个数，并与 $n$ 取最小值，简化了问题的复杂度。

### 可拓展之处
- **类似问题**：类似的问题可以出现在需要快速查询满足某种条件的元素个数的场景中，如区间查询、统计满足条件的子数组等。
- **算法套路**：排序 + 二分查找是一种常见的优化套路，适用于需要快速查询满足条件的元素个数的场景。

### 推荐洛谷题目
1. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3382 【模板】线段树 1](https://www.luogu.com.cn/problem/P3382)

### 个人心得总结
- **调试经历**：部分作者提到了对 `upper_bound` 的不熟悉，通过双二分查找确保了准确性。这种调试经历有助于加深对STL函数的理解。
- **顿悟感想**：通过贪心思想简化问题，直接计算满足条件的数的个数，并与 $n$ 取最小值，这种思路的顿悟有助于提高解题效率。

---
处理用时：33.46秒
# 题目信息

# [YsOI2023] 前缀和

## 题目背景

Ysuperman 模板测试的试机题。

小心立秋，小心秋丽。

## 题目描述

立秋有一个长度为 $n$ 的数组 $a$，所有数字都是正整数，并且除了其中第一个数字以外其它数字都等于前面所有数字的和。

例如，数组 $[1,1,2,4,8,16]$ 就有可能是立秋有的一个数组，因为除了第一个数字 $1$，后面的每个数字都是前面数字的和，例如：

- 第二个数字 $1=1$。
- 第三个数字 $2=1+1$。
- 第四个数字 $4=1+1+2$。
- 第五个数字 $8=1+1+2+4$。
- 第六个数字 $16=1+1+2+4+8$。 

现在立秋告诉了秋丽数字 $x$ 存在于这个数组中，秋丽希望知道 $a_n$ 最小会是多少，或者说整个数组最后一个数字最小有多少。

## 说明/提示

#### 样例 1 解释

- 第一组数据只有唯一可能的数组 $[2,2]$，所以答案为 $2$；
- 第二组数据有两种可能的数组，分别是 $[2,2,4]$ 和 $[1,1,2]$，所以答案为 $2$；
- 第三组数据有两种可能的数组，分别是 $[2,2,4,8]$ 和 $[1,1,2,4]$，所以答案为 $4$。

#### 样例 2 解释

- 第一组数据只有唯一可能的数组 $[1,1,2]$，所以答案为 $2$；
- 第二组数据有两种可能的数组 $[1,1,2]$ 和 $[2,2,4]$，所以答案为 $2$；
- 第三组数据有两种可能的数组 $[2,2,4]$ 和 $[4,4,8]$，所以答案为 $4$。

#### 数据范围

对于前 $30\%$ 的数据，满足 $x$ 不能被 $2$ 整除，或者说 $2$ 不是 $x$ 的一个因数，或者说 $x$ 是奇数。

另有 $30\%$ 的数据，满足 $x$ 可以被 $2^{n-2}$ 整除，或者说 $2^{n-2}$ 是 $x$ 的一个因数。

另有 $20\%$ 的数据，满足 $x\le 1000$，可以证明在这个数据范围下答案可以使用一个 `int` 类型变量存储。

对于 $100\%$ 的数据，满足 $1\le T\le 10^4$，$2\le n\le 20$，$1\le x\le 10^9$。

## 样例 #1

### 输入

```
3
2 2
3 2
4 2```

### 输出

```
2
2
4```

## 样例 #2

### 输入

```
3
3 1
3 2
3 4```

### 输出

```
2
2
4```

## 样例 #3

### 输入

```
3
2 6
3 6
4 6```

### 输出

```
6
6
12```

## 样例 #4

### 输入

```
3
3 3
3 6
3 12```

### 输出

```
6
6
12```

# AI分析结果

### 综合分析与结论

本题的核心在于通过观察数列的规律，找到使最后一个数最小的策略。大多数题解都基于以下两个关键点：
1. **数列规律**：从第三项开始，每一项都是前一项的两倍，即数列呈指数增长。
2. **贪心策略**：为了让最后一个数最小，应该让给定的数 \( x \) 尽可能出现在数列的靠后位置。

题解的主要思路可以分为两类：
- **直接计算**：通过 \( x \) 的奇偶性和位置，直接计算出最小的 \( a_n \)。
- **二分查找**：通过二分查找确定 \( x \) 在数列中的位置，进而计算 \( a_n \)。

### 所选高星题解

#### 1. 作者：2011FYCCCTA (赞：19)  
**星级：★★★★★**  
**关键亮点**：
- 通过 \( x \) 的奇偶性进行分类讨论，思路清晰。
- 直接利用数列的指数增长规律，避免了复杂的计算。
- 代码简洁，逻辑明确。

**核心代码**：
```cpp
if (x % 2) ans = x * pow(2 , (n - 2));
else {
    int tx = x , sum = 2;
    while (!(tx % 2) && sum < n) {tx /= 2; ++sum;}
    ans = tx * pow(2 , (n - 2));
}
```
**实现思想**：根据 \( x \) 的奇偶性，分别计算 \( a_n \)。若 \( x \) 为奇数，直接计算；若为偶数，通过不断除以 2 找到合适的位置。

#### 2. 作者：Shadow_T (赞：4)  
**星级：★★★★**  
**关键亮点**：
- 使用二分查找确定 \( x \) 在数列中的位置，思路新颖。
- 通过二分查找优化了计算过程，适合大规模数据。

**核心代码**：
```cpp
bool check(int x,int n,int m) {
    int cnt=1;
    while(x<=n&&cnt<=m) {
        if(x==n) return true;
        x*=2;
        cnt++;
    }
    return false;
}
```
**实现思想**：通过二分查找确定 \( x \) 在数列中的位置，进而计算 \( a_n \)。

#### 3. 作者：hjqhs (赞：3)  
**星级：★★★★**  
**关键亮点**：
- 通过不断除以 2 找到 \( x \) 在数列中的位置，思路清晰。
- 代码结构清晰，逻辑明确。

**核心代码**：
```cpp
int tmp=x;
while(tmp%2==0){tmp/=2;++cnt;}
ok=min(n-2,cnt);
ans[1]=x/pow(2,ok);
```
**实现思想**：通过不断除以 2 找到 \( x \) 在数列中的位置，进而计算 \( a_n \)。

### 最优关键思路与技巧

- **数列规律**：从第三项开始，每一项都是前一项的两倍，这一规律是解题的关键。
- **贪心策略**：为了让最后一个数最小，应该让给定的数 \( x \) 尽可能出现在数列的靠后位置。
- **分类讨论**：根据 \( x \) 的奇偶性进行分类讨论，简化了计算过程。

### 可拓展之处

- **类似题目**：可以考察其他类型的数列规律，如等差数列、等比数列等。
- **算法优化**：对于大规模数据，可以使用二分查找等优化算法。

### 推荐题目

1. **P1001 A+B Problem**（基础输入输出）
2. **P1042 乒乓球**（模拟与规律）
3. **P1048 采药**（动态规划）

### 个人心得摘录

- **调试经历**：在调试过程中，发现 \( x \) 为偶数时需要不断除以 2，直到无法除尽，这一步骤需要特别注意。
- **顿悟感想**：通过观察数列的规律，发现从第三项开始每一项都是前一项的两倍，这一发现大大简化了问题的解决过程。

---
处理用时：31.64秒
# 题目信息

# 「MXOI Round 1」方格

## 题目描述

小 C 和方格是好朋友。

小 C 有一个 $n$ 行 $m$ 列的方格图，每个方格中都有一个数字，其中第 $i$ 行第 $j$ 列的方格中的数字为 $a_{i,j}$。

我们定义，在这个方格图中，两个不同的方格不相邻，当且仅当这两个方格**没有公共边**。

小 C 认为，两个不同的方格互为好朋友，当且仅当这两个方格**不相邻**且**这两个方格中的数字相同**。

小 C 想让你帮忙求出，所有方格的好朋友的数量之和是多少。

## 说明/提示

#### 【样例解释 #1】

第 $1$ 行第 $1$ 列的方格共有 $3$ 个好朋友，第 $1$ 行第 $2$ 列的方格共有 $2$ 个好朋友，第 $1$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $1$ 行第 $4$ 列的方格共有 $0$ 个好朋友；

第 $2$ 行第 $1$ 列的方格共有 $1$ 个好朋友，第 $2$ 行第 $2$ 列的方格共有 $2$ 个好朋友，第 $2$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $2$ 行第 $4$ 列的方格共有 $1$ 个好朋友；

第 $3$ 行第 $1$ 列的方格共有 $1$ 个好朋友，第 $3$ 行第 $2$ 列的方格共有 $3$ 个好朋友，第 $3$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $3$ 行第 $4$ 列的方格共有 $4$ 个好朋友；

所有方格的好朋友数量之和为 $20$。

#### 【样例 #2】

见附加文件中的 `square/square2.in` 与 `square/square2.ans`。

该样例满足测试点 $1$ 的限制。

#### 【样例 #3】

见附加文件中的 `square/square3.in` 与 `square/square3.ans`。

该样例满足测试点 $4$ 的限制。

#### 【样例 #4】

见附加文件中的 `square/square4.in` 与 `square/square4.ans`。

该样例满足测试点 $6$ 的限制。

#### 【样例 #5】

见附加文件中的 `square/square5.in` 与 `square/square5.ans`。

该样例满足测试点 $10$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le n,m \le 2000$，$1 \le a_{i,j} \le 9$。

|测试点编号|$n,m \le$|$a_{i,j} \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim3$|$80$|$9$|否|
|$4\sim5$|$2000$|$1$|否|
|$6\sim7$|$2000$|$9$|是|
|$8\sim10$|$2000$|$9$|否|

特殊性质：保证任意两个相邻的方格中的数不相等。

## 样例 #1

### 输入

```
3 4
1 1 4 5
2 1 2 3
3 1 4 1```

### 输出

```
20```

# AI分析结果

### 综合分析与结论

本题的核心在于统计每个方格中数字相同且不相邻的方格数量。由于数据范围较大（$n, m \leq 2000$），直接暴力枚举会超时，因此需要优化。大多数题解都采用了“桶计数”的策略，即先统计每个数字出现的次数，然后通过减去相邻且数字相同的方格数量来得到最终结果。这种思路的时间复杂度为 $O(nm)$，能够通过本题。

### 题解评分与亮点

1. **作者：Coffee_zzz (赞：8)**
   - **星级：5星**
   - **关键亮点**：思路清晰，代码简洁，且对不同测试点的处理进行了详细说明。特别是对于特殊性质的处理（如相邻方格数字不相等的情况）给出了明确的优化策略。
   - **个人心得**：强调了不开 `long long` 的后果，提醒了数据范围的重要性。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++){
         for(int j=1;j<=m;j++){
             if(a[i][j]==a[i-1][j]) ans--;
             if(a[i][j]==a[i][j-1]) ans--;
             if(a[i][j]==a[i+1][j]) ans--;
             if(a[i][j]==a[i][j+1]) ans--;
         }
     }
     ```
     **核心思想**：通过遍历每个方格，减去相邻且数字相同的方格数量。

2. **作者：zzx114514 (赞：5)**
   - **星级：4星**
   - **关键亮点**：代码结构清晰，逻辑简洁，直接通过桶计数和相邻判断来解决问题。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++){
         for(int j=1;j<=m;j++){
             ans+=t[a[i][j]]-1;
             if(i>1 && a[i-1][j]==a[i][j]) ans--;
             if(i<n && a[i+1][j]==a[i][j]) ans--;
             if(j>1 && a[i][j-1]==a[i][j]) ans--;
             if(j<m && a[i][j+1]==a[i][j]) ans--;
         }
     }
     ```
     **核心思想**：通过桶计数和相邻判断，直接计算每个方格的好朋友数量。

3. **作者：_JF_ (赞：1)**
   - **星级：4星**
   - **关键亮点**：思路简洁，代码实现高效，且对值域的处理非常巧妙。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=9;i++) cnt[i]=cnt[i]*(cnt[i]-1);
     for(int i=1;i<=n;i++){
         for(int j=1;j<=m;j++){
             if(a[i][j]==a[i-1][j]) cnt[a[i][j]]--;
             if(a[i][j]==a[i+1][j]) cnt[a[i][j]]--;
             if(a[i][j]==a[i][j-1]) cnt[a[i][j]]--;
             if(a[i][j]==a[i][j+1]) cnt[a[i][j]]--;
         }
     }
     ```
     **核心思想**：通过桶计数和相邻判断，直接计算每个数字的好朋友数量。

### 最优关键思路与技巧

1. **桶计数**：利用桶（数组）统计每个数字出现的次数，避免了重复计算。
2. **相邻判断**：通过遍历每个方格的上下左右四个方向，减去相邻且数字相同的方格数量。
3. **时间复杂度优化**：通过桶计数和相邻判断，将时间复杂度从 $O(n^2m^2)$ 优化到 $O(nm)$。

### 可拓展之处

1. **类似题目**：可以扩展到更高维度的方格问题，或者扩展到更复杂的相邻条件（如对角线相邻）。
2. **算法套路**：桶计数和相邻判断的组合可以应用于其他需要统计特定条件的题目中。

### 推荐题目

1. **P1880 [NOI1995] 石子合并**：考察区间DP和相邻元素的处理。
2. **P1040 加分二叉树**：考察树形DP和相邻节点的处理。
3. **P1063 能量项链**：考察区间DP和相邻元素的处理。

### 个人心得总结

- **调试经历**：多位作者强调了不开 `long long` 的后果，提醒了数据范围的重要性。
- **踩坑教训**：在处理相邻方格时，需要注意边界条件，避免数组越界。
- **顿悟感想**：通过桶计数和相邻判断，可以将复杂问题简化，提高代码效率。

---
处理用时：37.05秒
# 题目信息

# 『GROI-R2』 紫水晶

## 题目描述

爱丽丝不曾忘记过她曾经存在于纸牌的世界。

于是魔法让她的手里出现了一些牌，同时魔法也让坦尼尔手里出现了一些牌，而且每张牌上都写着一个正整数——尽管他们如今所处的，是玻璃王国的世界中。

牌张很快一消而散，而他们也准备启程。爱丽丝只记住了每相邻两张牌的**最大公约数之和**，坦尼尔只记住了每相邻两张牌的**最小公倍数之和**。

你还在这个宫殿里，你想重现当时的牌张。

**形式化题面**

给定 $q$ 次询问，每次询问为以下两种之一：

- ``1 n x`` 表示要求输出一长度为 $n$ 的**正整数**序列 $\{a_n\}$，使得 $\sum\limits_{i=1}^{n-1} \gcd(a_i,a_{i+1})=x$。

- ``2 n x`` 表示要求输出一长度为 $n$ 的**正整数**序列 $\{a_n\}$，使得 $\sum\limits_{i=1}^{n-1} \operatorname{lcm}(a_i,a_{i+1})=x$。

且对于任意输出的 $a_i$ 不应超出 C++ 语言中 ``int`` 的存储范围。

其中 $\gcd$ 和 $\operatorname{lcm}$ 分别为最大公约数和最小公倍数，如有多解，输出任意一个即可。如果无解，输出 ``-1``。

## 说明/提示

**数据范围**

**本题采用捆绑测试**。

| $\text{Subtask}$ | $\sum n\le$ | $x\le$ | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $5$ | $10$ | | $10$ |
| $2$ | $50$ | $200$ | | $20$ |
| $3$ | $5\times 10^5$ | $2^{31}-1$ | $\text{A}$ | $15$ |
| $4$ | $5\times 10^5$ | $2^{31}-1$ | $\text{B}$ | $15$ |
| $5$ | $5\times 10^5$ | $2^{31}-1$ | | $40$ |

特殊性质 $\text{A}$：保证对于任意询问满足 $op=1$。

特殊性质 $\text{B}$：保证对于任意询问满足 $op=2$。

对于 $100\%$ 的数据满足 $2\le n\le 5\times 10^5$，$2\le \sum n\le 5\times 10^5$，$1\le x \le 2^{31}-1$，$op\in\{1,2\}$。


## 样例 #1

### 输入

```
5
1 5 4
2 3 8
1 5 10
2 6 34
1 3 1```

### 输出

```
1 1 1 1 1
2 2 3
1 1 1 7 7
1 1 4 5 1 4
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个满足特定条件的序列，要求序列中相邻元素的最大公约数或最小公倍数的和等于给定的值。大多数题解都采用了类似的构造思路：通过使用大量的 `1` 来简化问题，然后通过最后一个或两个元素来满足总和的要求。这种构造方法简单且高效，适用于本题的约束条件。

### 题解评分与亮点

#### 1. 作者：RJSPZ (赞：4)
- **星级**: 4.5
- **关键亮点**: 思路清晰，代码简洁，直接通过构造 `1` 和最后一个元素来满足条件，且对无解情况进行了合理判断。
- **代码核心**:
  ```cpp
  if(op==1){
      int num=x-n+2;
      if(num<=0){
          putchar('-'),putchar('1');
          goto print;
      }
      for(int i=1;i<=n-2;i++){
          putchar('1'),putchar(' ');
      }
      for(int i=n-1;i<=n;i++){
          printf("%d ",num);
      }
  }
  ```
- **个人心得**: 无

#### 2. 作者：myyyIisq2R (赞：3)
- **星级**: 4
- **关键亮点**: 详细解释了构造思路，代码可读性高，且对无解情况进行了合理处理。
- **代码核心**:
  ```cpp
  if(op == 1){
      if(q-(n-2) <=  0) puts("-1");
      else{
          for(int i{1};i<n-1;i++)
              cout<<1<<" ";
          cout<<q-(n-2)<<" "<<q-(n-2)<<endl;
      }
  }
  ```
- **个人心得**: 无

#### 3. 作者：_O_v_O_ (赞：1)
- **星级**: 4
- **关键亮点**: 提供了详细的证明，解释了为什么这种构造方法是正确的，代码简洁且高效。
- **代码核心**:
  ```cpp
  if(op==1){
      for(int i=1;i<n-1;i++){
          cout<<1<<' ';
      }
      cout<<x-n+2<<' '<<x-n+2<<endl;
  }
  ```
- **个人心得**: 无

### 最优关键思路与技巧

1. **构造大量 `1`**：通过使用大量的 `1` 来简化问题，因为 `1` 与任何数的最大公约数都是 `1`，最小公倍数都是该数本身。
2. **最后一个元素调整**：通过调整最后一个或两个元素的值来满足总和的要求，这种方法简单且高效。
3. **无解判断**：当 `x < n-1` 时，直接输出 `-1`，因为即使所有相邻元素的 `gcd` 或 `lcm` 都为 `1`，总和也无法满足要求。

### 可拓展之处

这种构造方法可以推广到其他类似的序列构造问题，特别是涉及到相邻元素之间的某种运算（如 `gcd`、`lcm`、`sum` 等）的题目。通过构造大量的 `1` 或其他特定值，可以简化问题并快速找到满足条件的序列。

### 推荐题目

1. [P8278 构造序列](https://www.luogu.com.cn/problem/P8278)
2. [P1001 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1001)
3. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)

### 通用建议与扩展思路

对于类似的构造题，建议优先考虑使用大量 `1` 或其他特定值来简化问题，然后通过调整最后一个或几个元素的值来满足条件。同时，注意对无解情况进行合理判断，避免不必要的计算。

---
处理用时：28.50秒
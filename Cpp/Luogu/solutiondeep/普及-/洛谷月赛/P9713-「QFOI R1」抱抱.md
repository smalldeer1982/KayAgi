# 题目信息

# 「QFOI R1」抱抱

## 题目描述

小 R 是一个可爱的女孩子，她希望跟大家抱抱，顺便给大家分蛋糕吃。

蛋糕是一个大小为 $a\times b\times c$ 的长方体，其中每个单位正方体都被赋予了一个坐标 $(x,y,z)$（$1\le x\le a,1\le y\le b,1\le z\le c$）。

共进行 $m$ 次切蛋糕操作，每次按如下三种方式之一切分：

1. 切出 $x\le k$ 的部分分给大家。
2. 切出 $y\le k$ 的部分分给大家。
3. 切出 $z\le k$ 的部分分给大家。

由于她自己也想吃蛋糕，她希望知道在每次切蛋糕后，还剩下多少体积没有分给大家。

## 说明/提示

**样例 $1$ 解释**

第一次切蛋糕，将所有 $x\le 2$ 的部分切掉，剩余的单位正方体有 $(3,1,1),(3,1,2),(3,1,3),(3,2,1),(3,2,2),(3,2,3),(3,3,1),(3,3,2),(3,3,3)$ 共 $9$ 个。

第二次切蛋糕，将所有 $y\le 1$ 的部分切掉，剩余的单位正方体有 $(3,2,1),(3,2,2),(3,2,3),(3,3,1),(3,3,2),(3,3,3)$ 共 $6$ 个。

---

**样例 $2$ 解释**

第四次切蛋糕没有任何作用，因为第二次切蛋糕时 $y\le 654321$ 的部分已经被切掉，此时已经不存在 $y\le 111111$ 的单位正方体。

注意每次操作中的参数 $k$ 是初始时决定的绝对坐标，不会随着操作的进行而改变。

---

**数据范围**

本题共 $20$ 个测试点，每个测试点 $5$ 分。

对于全部数据，保证 $1\le a,b,c\le 10^6$，$1\le m\le 2\times 10^5$，$op\in\{1,2,3\}$，若 $op=1$ 则 $1\le k\le a$，若 $op=2$ 则 $1\le k\le b$，若 $op=3$ 则 $1\le k\le c$。

- 对于测试点 $1\sim 5$：保证 $a,b,c,m\le 100$。
- 对于测试点 $6\sim 10$：保证 $b=c=1$，$op=1$。
- 对于测试点 $11\sim 15$：保证 $c=1$，$op\in\{1,2\}$。
- 对于测试点 $16\sim 20$：无特殊限制。

## 样例 #1

### 输入

```
3 3 3 2
1 2
2 1```

### 输出

```
9
6```

## 样例 #2

### 输入

```
1000000 1000000 1000000 6
1 123456
2 654321
3 233333
2 111111
1 333333
3 1000000```

### 输出

```
876544000000000000
303002853376000000
232302288589217792
232302288589217792
176680542935560631
0
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地处理多次切割操作，并快速计算每次切割后的剩余体积。大部分题解都采用了类似的思路：通过维护三个变量（`x`, `y`, `z`）来记录每个维度上已经被切割的最大值，然后通过简单的体积公式 `(a - x) * (b - y) * (c - z)` 来计算剩余体积。这种思路的时间复杂度为 `O(m)`，能够很好地处理题目中的数据范围。

#### 关键思路与技巧：
1. **维护最大值**：通过维护每个维度上已经被切割的最大值，可以快速判断当前切割是否有效，并计算剩余体积。
2. **体积公式**：利用简单的体积公式 `(a - x) * (b - y) * (c - z)` 来计算剩余体积，避免了复杂的模拟操作。
3. **边界处理**：部分题解中提到了对切割后体积为负数的处理，确保输出结果不会出现负数。

#### 可拓展之处：
- **多维切割**：如果题目扩展到更高维度的切割（如四维、五维），依然可以通过维护每个维度上的最大值来处理。
- **动态切割**：如果切割操作不是基于绝对坐标，而是基于相对坐标（如每次切割某个维度的前 `k` 个单位），则需要调整维护最大值的方式。

### 所选高星题解

#### 1. 作者：rui_er (赞：12)  
**星级：★★★★★**  
**关键亮点**：思路清晰，代码简洁，直接维护每个维度上的最大值，并通过体积公式快速计算剩余体积。  
**核心代码**：
```cpp
int a, b, c, m, x, y, z;
int main() {
    for(scanf("%d%d%d%d", &a, &b, &c, &m); m; m--) {
        int op, k;
        scanf("%d%d", &op, &k);
        if(op == 1) chkmax(x, k);
        else if(op == 2) chkmax(y, k);
        else chkmax(z, k);
        printf("%lld\n", 1LL * (a - x) * (b - y) * (c - z));
    }
    return 0;
}
```
**个人心得**：无

#### 2. 作者：hjqhs (赞：9)  
**星级：★★★★☆**  
**关键亮点**：代码简洁，思路与官方题解一致，直接维护最大值并计算体积。  
**核心代码**：
```cpp
int a,b,c,m;
int mx,my,mz;
signed main(){
    cin>>a>>b>>c>>m;
    for(int i=1;i<=m;++i){
        int op,k;
        cin>>op>>k;
        if(op==1)mx=max(mx,k);
        if(op==2)my=max(my,k);
        if(op==3)mz=max(mz,k);
        cout<<(a-mx)*(b-my)*(c-mz)<<'\n';
    }
    return 0;
}
```
**个人心得**：无

#### 3. 作者：LegendaryGrandmaster (赞：4)  
**星级：★★★★☆**  
**关键亮点**：在维护最大值的基础上，进一步优化了体积的计算方式，避免了重复计算。  
**核心代码**：
```cpp
int a,b,c,m;
int A=0,B=0,C=0;
while(m--){
    int op,k;
    cin>>op>>k;
    if(op==1&&k>=A){
        ans-=(k-A)*b*c;
        a=a-k+A;
        A=max(A,k);
    }
    if(op==2&&k>=B){
        ans-=(k-B)*a*c;
        b=b-k+B;
        B=max(B,k);
    }
    if(op==3&&k>=C){
        ans-=(k-C)*b*a;
        c=c-k+C;
        C=max(C,k);
    }
    cout<<ans<<'\n';
}
```
**个人心得**：无

### 推荐相似题目
1. **P1880 [NOI1995] 石子合并**：考察区间DP与动态维护的思想。
2. **P1048 [NOIP2005 普及组] 采药**：考察动态规划与状态转移的思想。
3. **P1060 [NOIP2006 提高组] 开心的金明**：考察背包问题与动态规划的思想。

### 通用建议与扩展思路
如果所有题解都不足4星，建议从以下方面改进：
1. **代码简洁性**：尽量减少冗余代码，保持逻辑清晰。
2. **边界处理**：确保所有边界情况（如切割后体积为负数）都得到正确处理。
3. **优化思路**：在维护最大值的基础上，进一步优化体积计算，避免重复计算。

---
处理用时：34.55秒
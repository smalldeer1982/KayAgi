# 题目信息

# 「KDOI-06-J」翻转与反转

## 题目描述

小 W 有一个长度为 $n$ 的 $01$ 序列 $a_1,a_2,\ldots,a_n$，他将对这个序列按顺序进行 $n$ 次操作。

在第 $i$ 次操作中（$1\le i\le n$），小 W 将按顺序执行以下**两种**变换：

1. 将区间 $[1,i]$ 中的数按下标翻转。形式化地说，在这次变换之后，序列 $a$ 将变为 $a_i,a_{i-1},\ldots,a_{1},a_{i+1},a_{i+2},\ldots,a_n$。
2. 将区间 $[1,i]$ 中的数按值翻转。形式化地说，在这次变换之后，对于任意 $1\le j\le i$，若 $a_j=0$，则 $a_j$ 将变为 $1$，否则 $a_j$ 将变为 $0$。

小 W 想要知道，在全部 $n$ 次操作结束后，序列 $a$ 中每个元素的值。

## 说明/提示

**【样例解释 #1】**

序列 $a$ 的变化如下表所示：

| 操作次数 | 序列 $a$ 的变化 |
| :--: | :--: |
| $1$ | $[1,1,1]\to [1,1,1]\to[0,1,1]$ |
| $2$ | $[0,1,1]\to [1,0,1]\to[0,1,1]$ |
| $3$ | $[0,1,1]\to [1,1,0]\to[0,0,1]$ |

**【样例解释 #2】**

序列 $a$ 的变化如下表所示：

| 操作次数 | 操作后的序列 $a$ |
| :--: | :--: |
| - | $[1,0,1,1,1,0,0,1]$ |
| $1$ | $[0,0,1,1,1,0,0,1]$ |
| $2$ | $[1,1,1,1,1,0,0,1]$ |
| $3$ | $[0,0,0,1,1,0,0,1]$ |
| $4$ | $[0,1,1,1,1,0,0,1]$ |
| $5$ | $[0,0,0,0,1,0,0,1]$ |
| $6$ | $[1,0,1,1,1,1,0,1]$ |
| $7$ | $[1,0,0,0,0,1,0,1]$ |
| $8$ | $[0,1,0,1,1,1,1,0]$ |

**【样例 #3】**

见选手文件中的 `revflip/revflip3.in` 与 `revflip/revflip3.ans`。

**【样例 #4】**

见选手文件中的 `revflip/revflip4.in` 与 `revflip/revflip4.ans`。


**【数据范围】**

对于所有数据保证：$1\le n\le 2\times 10^6$，且对于任意 $1\le i\le n$，$a_i=0$ 或 $1$。

| 测试点编号 | $n\le$ |  特殊性质 |
| :-----------: | :-----------: | :----------: |
| $1\sim 3$ | $10^3$ | 无 |
| $4\sim 5$ | $10^5$ | 无 |
| $6 \sim 7$ | $2\times 10^6$ | $a_i=0$ |
| $8\sim 10$ | $2\times 10^6$ | 无 | 


## 样例 #1

### 输入

```
3
1 1 1
```

### 输出

```
0 0 1 
```

## 样例 #2

### 输入

```
8
1 0 1 1 1 0 0 1
```

### 输出

```
0 1 0 1 1 1 1 0 
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过模拟和规律推导，找到序列在经过多次翻转和反转操作后的最终状态。大部分题解通过观察操作对序列的影响，总结出了一些规律，并利用这些规律实现了O(n)的解法。以下是各题解的要点总结：

1. **规律推导**：大部分题解通过模拟操作，发现序列的最终状态与原始序列的奇偶性、操作次数的奇偶性有关。例如，某些题解发现最终序列的前半部分是原始序列的某些位置的取反，后半部分则是直接复制。
  
2. **优化思路**：部分题解通过数学归纳法或观察操作对序列的影响，直接推导出最终序列的生成规则，避免了复杂的模拟过程，从而实现了O(n)的时间复杂度。

3. **数据结构**：部分题解使用了链表（如`list`）来高效地处理序列的翻转和反转操作，进一步优化了代码的可读性和性能。

4. **代码实现**：大部分题解的代码实现较为简洁，直接根据推导出的规律生成最终序列，避免了复杂的逻辑。

### 所选高星题解

#### 题解1：作者：Eleveslaine (赞：17)  
**星级：5星**  
**关键亮点**：通过手动模拟操作，发现了序列最终状态与原始序列的奇偶性之间的关系，并利用链表（`list`）高效地实现了序列的生成。代码简洁且可读性高。  
**个人心得**：作者通过手动模拟操作，发现了序列的最终状态与原始序列的奇偶性之间的关系，并通过链表实现了高效的序列生成。  
**核心代码**：
```cpp
list <bool> ans;
if(n&1) {
    for(int i=1;i<=n;++i)
        if(i&1) ans.push_front(!a[i]);
        else ans.push_back(a[i]);
} else {
    for(int i=1;i<=n;++i)
        if(i&1) ans.push_back(a[i]);
        else ans.push_front(!a[i]);
}
for(bool x:ans) cout << x << ' ';
```
**核心思想**：根据序列长度的奇偶性，分别将原始序列的奇数位和偶数位插入到链表的前端或后端，最终输出链表中的元素。

#### 题解2：作者：Y_Aridy (赞：12)  
**星级：4星**  
**关键亮点**：通过模拟操作，推导出序列的最终状态与原始序列的某些位置的取反有关，并利用数学归纳法实现了O(n)的解法。  
**核心代码**：
```cpp
int i=1;
for(int t=n;t>=1;i++,t-=2) now[i]=pas[t]^1;
int j=n;
for(int t=n-1;t>=1;j--,t-=2) now[j]=pas[t];
```
**核心思想**：根据操作次数的奇偶性，分别从序列的末尾和倒数第二位开始，依次将原始序列的元素取反或直接复制到最终序列中。

#### 题解3：作者：User_Artist (赞：6)  
**星级：4星**  
**关键亮点**：通过观察操作对序列的影响，总结出序列的最终状态与原始序列的某些位置的取反有关，并利用简单的循环实现了O(n)的解法。  
**核心代码**：
```cpp
for(int i = 0; i < n; ++ i)
    if(i % 2) b[r --] = (a[n - i] == 1) ? 1 : 0;
    else b[++ l] = (a[n - i] == 1) ? 0 : 1;
```
**核心思想**：根据操作次数的奇偶性，分别将原始序列的元素取反或直接复制到最终序列中，最终输出结果。

### 最优关键思路与技巧

1. **规律推导**：通过模拟操作，发现序列的最终状态与原始序列的奇偶性、操作次数的奇偶性有关，从而避免了复杂的模拟过程。
  
2. **数据结构优化**：使用链表（如`list`）来高效地处理序列的翻转和反转操作，进一步优化了代码的可读性和性能。

3. **数学归纳法**：通过数学归纳法或观察操作对序列的影响，直接推导出最终序列的生成规则，避免了复杂的模拟过程。

### 可拓展之处

1. **同类型题**：类似的操作序列问题，可以通过模拟和规律推导来解决，例如多次翻转、反转、交换等操作。
  
2. **算法套路**：对于多次操作的问题，可以通过观察操作对序列的影响，总结出规律，从而避免复杂的模拟过程。

### 推荐题目

1. **P3383 【模板】线性筛素数**：考察线性筛法的实现，与本题的规律推导有相似之处。
  
2. **P3374 【模板】树状数组 1**：考察树状数组的实现，与本题的序列操作有相似之处。

3. **P3372 【模板】线段树 1**：考察线段树的实现，与本题的序列操作有相似之处。

### 个人心得总结

1. **调试经历**：部分作者在调试过程中发现，直接模拟操作会导致时间复杂度较高，因此通过观察操作对序列的影响，总结出规律，从而优化了代码。
  
2. **踩坑教训**：部分作者在实现过程中，忽略了操作次数的奇偶性对序列最终状态的影响，导致结果错误，因此通过多次模拟和调试，最终找到了正确的规律。

3. **顿悟感想**：通过手动模拟操作，发现序列的最终状态与原始序列的奇偶性之间的关系，从而实现了高效的解法。

---
处理用时：45.85秒
# 题目信息

# 寻找团伙

## 题目描述

世界局势风云变幻，你想办一件大事。办事自然要有人参与，你能从 $n$ 个人里面挑选一部分人共襄盛举。

要办这件事，一共涉及 $k$ 方面的能力，例如游说他人的能力、玩游戏的能力、睡觉的能力。每位人士都会具备某一些能力，例如机器猫就可能擅长睡觉、擅长玩游戏，而不擅长游说他人。

你的计划很宏伟，因此你希望团队拥有很全面的能力。不幸的是，如果团队中有偶数个人拥有同一类能力，那么他们就会分成两派，争执不下，导致整个团队丧失这方面的能力。相应地，如果这项能力只有奇数个人拥有，那么他们总能形成一个多数派，帮团队去做这方面的工作。

需要注意的是，团队拥有的每一项能力，对计划的成功率的贡献是不一样的。第一项能力最重要，它的权重是 $2^{k-1}$；第二项能力的权重是 $2^{k-2}$；依次类推。第 $k$ 项能力最不重要，权重只有 $1$。

计划的成功率得分，即是**团队拥有的所有能力对应的权重之和**。

你希望计划成功率最大。因此，你需要选出合适的人士，来参与到你的宏图伟业中。


## 说明/提示

#### 样例解释

第一组样例，共 5 个人，每个人拥有的能力不一样。最终选择的结果是让这 5 个人都参与计划，得分 $16+8+4+2+1 = 31$。

第二组样例，我们选择只让 $1$ 参与。那么团队具有能力 $1,2, 3$，得分 $16+8+4=28$。

第三组样例，我们让 $1,2,3$ 参与。由于团队中有偶数个成员拥有能力 $5$，故团队并不拥有能力 $5$。奇数个成员拥有能力 $2$，故团队拥有能力 $2$。最终，团队具有能力 $1,2,3,4$。得分 $16+8+4+2=30$。

#### 数据规模与约定

对于 $100\%$ 的数据，有 $n\leq 21, k\leq 60$。




## 样例 #1

### 输入

```
5 5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
31```

## 样例 #2

### 输入

```
3 5
3 1 2 3
4 2 3 4 5
2 3 4```

### 输出

```
28```

## 样例 #3

### 输入

```
3 5
2 1 2
3 5 3 2
3 4 2 5```

### 输出

```
30```

## 样例 #4

### 输入

```
21 60
0 
0 
3 60 27 48
0 
1 48
2 52 14
2 4 31
0 
0 
2 28 43
2 6 31
0 
1 7
3 45 6 48
0 
1 51
0 
2 28 20
2 37 51
1 8
53 59 39 29 23 53 27 13 16 44 34 38 24 9 32 58 54 31 1 7 45 3 30 36 17 48 42 22 18 21 6 11 25 33 37 52 10 60 49 57 2 28 8 14 5 47 4 41 35 43 50 46 26 12```

### 输出

```
1152884121210322895```

# AI分析结果



### 综合分析与结论  
题目转化为求若干二进制向量的最大异或和。关键点在于将能力权重转化为二进制位权，利用异或运算的奇偶性特性。当 n ≤ 21 时，暴力枚举子集（O(2^n)）是可行解法；若 n 更大，则需线性基优化（O(nk)）。

---

### 精选题解与评分  

#### 1. 作者：Usada_Pekora（★★★★★）  
**关键亮点**：  
- 提供递归枚举与线性基双解法，思路全面。  
- 代码简洁高效，DFS 实现清晰，线性基代码可直接用于更大数据。  
- 明确位运算的优化逻辑，正确使用 ULL 处理高位。  
**核心代码**：  
```cpp
void dfs(ull dep, ull now) {
    if(dep > n) {
        ans = max(ans, now);
        return;
    }
    dfs(dep + 1, now ^ a[dep]); // 选当前人
    dfs(dep + 1, now);          // 不选
}
```
**个人心得**：  
> "暴搜是很好打，但遇上 n 更大的数据自然需要线性基。线性基通过贪心求最大值，效率更高。"

#### 2. 作者：阮行止（★★★★）  
**关键亮点**：  
- 递归枚举实现清晰，附带详细输入处理说明。  
- 强调 ULL 的重要性，避免常见位运算错误。  
- 提供线性基的 Python 实现，扩展思路。  
**核心代码**：  
```cpp
void dfs(int pos) {
    if(pos == n) {
        ull res = 0;
        for(int i=0; i<n; i++)
            if(choice[i]) res ^= p[i];
        ans = max(res, ans);
        return;
    }
    choice[pos] = 0; dfs(pos + 1);
    choice[pos] = 1; dfs(pos + 1);
}
```

#### 3. 作者：5k_sync_closer（★★★★）  
**关键亮点**：  
- 位运算枚举子集，代码紧凑易理解。  
- 明确枚举范围与位检查逻辑，适合快速实现。  
**核心代码**：  
```cpp
for(;s < u;++s) { // 枚举所有子集状态
    sum = 0;
    for(int i=0;i <n;++i)
        if(s & (1 << i)) sum ^= p[i];
    ans = max(ans, sum);
}
```

---

### 关键技巧总结  
1. **位权转换**：将第 x 能力映射到 `1ULL << (k - x)`，确保高位优先。  
2. **异或性质**：用异或运算天然处理奇偶性，避免显式计数。  
3. **枚举优化**：n ≤ 21 时暴力枚举可行，线性基适用于更大规模。  
4. **数据类型**：必须使用 `unsigned long long` 存储 60 位二进制数。  

---

### 拓展题目推荐  
1. [P3857 [TJOI2008]彩灯](https://www.luogu.com.cn/problem/P3857)（线性基模板题）  
2. [P4869 albus 就要第一个出场](https://www.luogu.com.cn/problem/P4869)（异或和统计）  
3. [P3292 [SCOI2016]幸运数字](https://www.luogu.com.cn/problem/P3292)（线性基 + 树链剖分）

---
处理用时：68.06秒
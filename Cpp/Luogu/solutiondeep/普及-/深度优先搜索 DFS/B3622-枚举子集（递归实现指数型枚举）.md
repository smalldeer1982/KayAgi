# 题目信息

# 枚举子集（递归实现指数型枚举）

## 题目描述

今有 $n$ 位同学，可以从中选出任意名同学参加合唱。

请输出所有可能的选择方案。

## 说明/提示

对于 $100\%$ 的数据，保证 $1\leq n\leq 10$。

## 样例 #1

### 输入

```
3```

### 输出

```
NNN
NNY
NYN
NYY
YNN
YNY
YYN
YYY```

# AI分析结果



### 综合分析与结论
该题本质是求集合的幂集，核心在于理解子集与二进制的位模式对应关系，或通过递归构建所有可能路径。二进制解法巧妙利用数值的二进制表示直接生成结果，时间复杂度 O(n·2ⁿ) 完全可行；DFS 解法通过递归树展开所有可能性，更利于理解回溯思想。两种方法均能正确生成字典序，关键在于处理顺序的细节。

---

### 高分题解选评（评分≥4星）

#### 1. 题解作者：看什么看（★★★★★）
**关键亮点**  
- 双解法对比：同时剖析二进制转换与DFS两种经典思路，帮助理解不同算法的本质联系  
- 示意图辅助理解递归树结构，直观展示生成过程  
- 点明字典序生成的顺序控制原理（先处理N后处理Y）

#### 2. 题解作者：danny101（★★★★☆）
**关键亮点**  
- 揭示二进制与子集的等价关系，将问题转化为数值遍历问题  
- 数学推导清晰：通过除模运算分析二进制位提取原理  
- 代码实现思路简洁，适合快速编码  

#### 3. 题解作者：ShanCreeperPro（★★★★☆）
**关键亮点**  
- 明确DFS的递归定义（pos分层决策）与终止条件  
- 类比同系列题目（B3621枚举元组），构建知识体系  
- 强调递归枚举的本质是构造布尔数组，强化算法思维  

---

### 核心思路总结
**二进制技巧**  
每个子集对应唯一的n位二进制数，遍历 [0, 2ⁿ) 范围，将每个数转为二进制字符串。关键点：
- 补前导零至n位保证长度一致
- 高位对应同学的前序位置（如第1位同学对应二进制最高位）

**DFS实现要点**  
递归函数按位置逐层决策，维护选择状态数组：
```cpp
void dfs(int pos) {
    if (pos > n) {
        输出当前选择状态;
        return;
    }
    a[pos] = 0;   // 先处理不选（N）
    dfs(pos + 1);
    a[pos] = 1;   // 再处理选（Y）
    dfs(pos + 1);
}
```
- 递归顺序必须**先走不选分支**以保证字典序
- 状态数组在回溯时自动恢复，无需显式撤销

---

### 拓展与举一反三
**同类问题套路**  
- **子集变形**：如带权子集、限定元素数量的子集（例：LC 78/90/216）  
- **排列组合**：如全排列（B3623）、元组枚举（B3621）  
- **状态压缩**：用位运算优化集合表示（例：LC 465）  

**推荐练习题**  
1. [B3621 枚举元组](https://www.luogu.com.cn/problem/B3621) - 多维递归枚举  
2. [P1157 组合输出](https://www.luogu.com.cn/problem/P1157) - 限定元素数量的组合  
3. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706) - 经典回溯模板

---
处理用时：151.91秒
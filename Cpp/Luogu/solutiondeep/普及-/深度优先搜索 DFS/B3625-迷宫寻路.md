# 题目信息

# 迷宫寻路

## 题目描述

机器猫被困在一个矩形迷宫里。

迷宫可以视为一个 $n\times m$ 矩阵，每个位置要么是空地，要么是墙。机器猫只能从一个空地走到其上、下、左、右的空地。

机器猫初始时位于 $(1, 1)$ 的位置，问能否走到 $(n, m)$ 位置。


## 说明/提示

#### 样例解释

路线如下：$(1,1)\to (2,1) \to (3,1) \to (3,2)\to (3,3) \to (2, 3) \to (2, 4) \to (2, 5) \to (3, 5)$

#### 数据规模与约定 

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 100$，且 $(1,1)$ 和 $(n, m)$ 均为空地。

## 样例 #1

### 输入

```
3 5
.##.#
.#...
...#.```

### 输出

```
Yes```

# AI分析结果



### 综合分析与结论
本题核心在于判断两点在网格中的连通性，DFS与BFS均可解决。两种方法均需维护访问标记避免重复搜索，时间复杂度均为O(nm)。BFS更适合求最短路径，而DFS代码较简洁。关键点在于正确处理坐标转换与方向遍历。

---

### 精选题解分析

#### 题解作者：ShanCreeperPro（★★★★☆）
**关键亮点**  
1. 同时对比DFS与BFS的核心思路，突出算法特性（碰壁回溯 vs 逐层扩展）  
2. 强调访问标记的必要性，明确处理非法情况的逻辑  
3. 给出算法框架便于理解实现流程  

**个人心得引用**  
无显式心得，但隐含经验：DFS/BFS选择取决于是否需要最短路径，体现对算法特性的理解。

---

### 关键思路与技巧
1. **方向数组简化遍历**  
```cpp
int dx[] = {-1,1,0,0}, dy[] = {0,0,-1,1}; // 上下左右
```
2. **访问标记优化**  
使用二维数组`vis[][]`或在原地图直接标记，防止重复访问  
3. **BFS队列实现模板**  
```cpp
queue<pair<int,int>> q;
q.push({0,0}); // 假设起点转0-based
while(!q.empty()) {
    auto [x,y] = q.front(); q.pop();
    if(x==n-1 && y==m-1) return true; // 终点判断
    for(int i=0; i<4; ++i) {
        int nx = x+dx[i], ny = y+dy[i];
        if(nx>=0 && nx<n && ny>=0 && ny<m && !vis[nx][ny] && grid[nx][ny]=='.') {
            vis[nx][ny] = 1;
            q.push({nx,ny});
        }
    }
}
```

---

### 拓展建议
1. **同类问题变式**  
   - 输出具体路径（记录前驱节点）  
   - 存在传送门等特殊机制（BFS状态扩展）  
   - 求所有可行路径数（DFS+回溯）  
2. **推荐题目**  
   - P1443 马的遍历（BFS求最短步数）  
   - P1162 填涂颜色（连通块染色）  
   - P1141 01迷宫（预处理连通块）  

---

### 实现注意点
- **坐标转换**：题目中(1,1)起点通常对应代码中的0-based索引  
- **剪枝优化**：到达终点时立即终止搜索  
- **边界处理**：先判断坐标合法性再访问数组，避免越界崩溃

---
处理用时：59.67秒
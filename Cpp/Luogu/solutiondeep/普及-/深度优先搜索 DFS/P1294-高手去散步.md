# 题目信息

# 高手去散步

## 题目背景

高手最近谈恋爱了。不过是单相思。“即使是单相思，也是完整的爱情”，高手从未放弃对它的追求。今天，这个阳光明媚的早晨，太阳从西边缓缓升起。于是它找到高手，希望在晨读开始之前和高手一起在鳌头山上一起散步。高手当然不会放弃这次梦寐以求的机会，他已经准备好了一切。


## 题目描述

鳌头山上有 $n$ 个观景点，观景点两两之间有游步道共 $m$ 条。高手的那个它，不喜欢太刺激的过程，因此那些没有路的观景点高手是不会选择去的。另外，她也不喜欢去同一个观景点一次以上。而高手想让他们在一起的路程最长（观景时它不会理高手），已知高手的穿梭机可以让他们在任意一个观景点出发，也在任意一个观景点结束。

## 说明/提示

对于 $100\%$ 的数据：$n \le 20$，$m \le 50$，保证观景点两两之间不会有多条游步道连接。

## 样例 #1

### 输入

```
4 6
1 2 10
2 3 20
3 4 30
4 1 40
1 3 50
2 4 60```

### 输出

```
150```

# AI分析结果



### 综合分析与结论
本题本质是求无向图中的最长简单路径。所有题解均围绕暴力搜索展开，主用DFS回溯法（n≤20的规模下可行）。最优解法则使用状压DP进行状态转移。关键差异在于图的存储方式（邻接矩阵 vs 邻接表 vs 链式前向星）和搜索优化思路。

### 高星题解推荐
#### 1. LJZ_C（状压DP） ⭐⭐⭐⭐⭐
**核心亮点**：  
- 唯一使用状压DP的正解，时间复杂度 O(2^n·n²) 优于DFS  
- 状态定义 f[mask][u] 表示当前在u点且已访问点集为mask时的最长路径  
- 循环顺序设计巧妙，通过状态扩展实现无后效性  

**关键代码**：
```cpp
int f[1 << MAX_N][MAX_N + 5]; // 状态压缩DP数组
ref(i, 1, (1 << n) - 1) 
  ref(j, 1, n) if(i & 1 << j - 1) 
    ref(h, 1, n) if(mat[j][h] && !(i & 1 << h - 1)) 
      f[i | 1 << h - 1][h] = max(f[i | 1 << h - 1][h], f[i][j] + mat[j][h]);
```

#### 2. ghj1222（邻接表DFS） ⭐⭐⭐⭐
**核心亮点**：  
- 邻接表存储节省空间，遍历效率高  
- 回溯逻辑清晰，每次递归后及时恢复状态  
- 使用独立vis数组避免冲突，代码可读性强  

**调试心得**：  
> "回溯时忘记恢复vis数组导致WA，后增加vis[x]=false解决"

**关键代码**：
```cpp
void dfs(int x) {
    for(int i = head[x]; i; i = e[i].next) 
        if(!vis[e[i].to]) {
            vis[e[i].to] = 1;
            ans += e[i].w;
            sum = max(sum, ans);
            dfs(e[i].to);
            ans -= e[i].w;
            vis[e[i].to] = 0;
        }
}
```

#### 3. RedreamMer（邻接矩阵DFS） ⭐⭐⭐⭐
**核心亮点**：  
- 邻接矩阵直观易实现，适合新手理解  
- 实时更新最大值，避免冗余计算  
- 统一处理无向图的双向边  

**关键技巧**：  
在每次递归时即时比较最大值，而非仅在叶子节点更新：
```cpp
ans = max(ans, len);
for(int i=1; i<=n; i++)
   if(g[st][i] && !vis[i]){
      vis[i] = 1;
      dfs(i, len + g[st][i]);
      vis[i] = 0;
   }
```

### 最优思路总结
1. **状压DP**：最优时间复杂度，状态压缩存储访问集合，适合n≤20的场景  
2. **回溯剪枝**：DFS时必须及时恢复访问状态，邻接表遍历时通过指针跳转提升效率  
3. **多起点处理**：对每个节点作为起点独立搜索，避免漏解  

### 举一反三
1. 类似状压DP应用：P1433 吃奶酪（状态压缩+几何距离）  
2. 树形最长路径：P5536 【XR-3】核心城市（两次DFS求直径）  
3. 带权图回溯：P1120 小木棍（剪枝优化的经典DFS）

### 重点代码段（状压DP核心）
```cpp
// 初始化：每个点单独状态
clr(f, -INF);
ref(i, 1, n) f[1 << (i-1)][i] = 0;

// 状态转移
for(int mask = 1; mask < (1<<n); ++mask)
   for(int u = 1; u <= n; ++u) if(mask & (1<<(u-1)))
      for(int v = 1; v <= n; ++v) 
         if(!(mask & (1<<(v-1))) && g[u][v])
            f[mask|(1<<(v-1))][v] = max(f[mask|(1<<(v-1))][v], f[mask][u] + g[u][v]);
```

---
处理用时：62.59秒
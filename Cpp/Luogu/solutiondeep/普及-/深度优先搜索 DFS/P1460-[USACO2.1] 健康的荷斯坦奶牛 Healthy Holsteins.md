# 题目信息

# [USACO2.1] 健康的荷斯坦奶牛 Healthy Holsteins

## 题目描述

农民 John 以拥有世界上最健康的奶牛为傲。他知道每种饲料中所包含的牛所需的最低的维他命量是多少。请你帮助农夫喂养他的牛，以保持它们的健康，使喂给牛的饲料的种数最少。

给出牛所需的最低的维他命量，输出喂给牛需要哪些种类的饲料，且所需的饲料剂量最少。

维他命量以整数表示，每种饲料最多只能对牛使用一次，数据保证存在解。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le v \le 25$，$1\le g \le 15$。  
输入的所有整数在 $[1,1000]$ 范围内。

USACO 2.1

翻译来自NOCOW


## 样例 #1

### 输入

```
4
100 200 300 400
3
50  50  50  50
200 300 200 300
900 150 389 399```

### 输出

```
2 1 3
```

# AI分析结果



### 综合分析与结论
本题核心为寻找饲料的最优组合，需满足：1. 维生素达标；2.饲料种数最少；3.字典序最小。各题解主要采用DFS、BFS、二进制枚举、迭代加深等算法。关键优化点在于状态表示与剪枝策略。

### 高分题解推荐
#### 1. 作者：ouuan（★★★★★）
**关键亮点**：
- **二进制枚举+状态压缩**：用二进制位表示饲料选择，直观高效
- **字典序处理技巧**：高位代表小序号饲料，保证首个解字典序最小
- **剪枝优化**：按饲料数从小到大枚举，找到即最优
**核心代码**：
```cpp
for (int i=(1<<g)-1;i>=0;--i) { //倒序枚举保证字典序
    if (count(i)>=minn) continue; //剪枝
    //计算当前状态总和并判断
    if(valid) update_ans();
}
```
**个人心得**：通过二进制位反向映射饲料序号（g+1-i）解决字典序问题，是状态压缩的巧妙应用。

#### 2. 作者：Youngsc（★★★★☆）
**关键亮点**：
- **迭代加深搜索**：按饲料数分层搜索，优先找到最小解
- **剪枝策略**：剩余饲料不足时提前返回
**核心实现**：
```cpp
void dfs(int x,int sum,int num){
    if(sum==num){ //达到当前深度限制
        if(check_vitamin()) exit(0); //找到即最优
    }
    if(n-x<num-sum) return; //剩余饲料不足剪枝
    for(选i号饲料并递归)
}
```
**优化价值**：避免DFS全遍历，结合了BFS找最优解的特性。

#### 3. 作者：06ray（★★★★☆）
**关键亮点**：
- **标准回溯框架**：清晰体现DFS选/不选两种决策
- **擂台式更新**：维护全局最优解数组
**代码片段**：
```cpp
void search(int t,int s){
    if(t>m){
        if(pd(s) && s<minn) 更新ans数组;
        return;
    }
    c[s+1]=t; //选t号饲料
    search(t+1,s+1);
    c[s+1]=0; //回溯
    search(t+1,s); //不选
}
```
**教学意义**：代码结构清晰，适合新手理解回溯模板。

### 关键技巧总结
1. **状态压缩**：用二进制位表示选择状态（如ouuan的解法）
2. **搜索顺序优化**：
   - 按饲料序号递增选择保证字典序
   - 迭代加深优先找最小解
3. **剪枝策略**：
   - 当前饲料数≥已知最优时提前返回
   - 剩余可选饲料不足时剪枝

### 相似题目推荐
1. P1706 全排列问题（回溯基础）
2. P2392 kkksc03考前临时抱佛脚（状态枚举）
3. P1036 选数（子集生成+剪枝）

### 调试经验摘录
- **回溯遗漏**：选饲料后需恢复维生素总和（如_Andrea的题解中忘记初始化临时数组）
- **字典序陷阱**：正向枚举可能导致后出现的更优解覆盖字典序小的解，需倒序处理（ouuan的位运算技巧）
- **剪枝误判**：部分题解未考虑剩余饲料数导致错误剪枝（Youngsc的剩余饲料判断是正确范例）

---
处理用时：49.24秒
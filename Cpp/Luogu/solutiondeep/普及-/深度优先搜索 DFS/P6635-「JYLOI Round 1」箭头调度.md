# 题目信息

# 「JYLOI Round 1」箭头调度

## 题目描述

moyu_028 给了你一个有 $n$ 个点 $m$ 条边的无向图，现在要给每条边赋一个方向，现在请你求出一个赋方向的方案，使得按照这个方案能够生成一个拓扑序，且使得这个拓扑序是在所有可能的拓扑序中字典序第 $k$ 小的。


## 说明/提示

## 提示

拓扑序：在一个 DAG（有向无环图）中，我们将图中的顶点以线性方式进行排序，使得对于任何的顶点 $u$ 到 $v$ 的有向边 $(u,v)$，都可以有 $u$ 在 $v$ 的前面，则这样的序列称为拓扑序。

----------

## 样例解释

### 样例 1 解释

答案的图如下，根据图可得出答案。

![](https://i.loli.net/2020/05/23/3FK2n78JAYLrGMD.png)

-----------------

## 数据范围

对于 $100\%$ 的数据，$1 \leq n \leq 11, 1 \leq m \leq 2 \times 10^3, 1 \leq k \leq 10^8，1 \leq x_i, y_i \leq n, x_i \not= y_i$。

对于测试点 1（10 分）：$n = 1$。

对于测试点 2（30 分）：$n \leq 11, m \leq 20$。

对于测试点 3（30 分）：$n \leq 11, k = 1$。

对于测试点 4（30 分）：无特殊限制。

本题共 4 个测试点，总分为 100 分，单个测试点的时间限制为 5 秒。

## 题目来源

「JYLOI Round 1」 A

Idea：moyu_028 & abcdeffa

Solution：LiuXiangle

Data：abcdeffa

## 样例 #1

### 输入

```
6 7 5
1 3
2 1
4 2
4 3
4 5
3 6
5 6```

### 输出

```
0111001```

## 样例 #2

### 输入

```
11 20 20091210
2 3
3 1
2 5
4 6
7 9
8 10
8 1
7 2
2 3
3 2
4 5
5 7
7 6
7 8
9 7
9 8
10 2
2 3
1 3
1 7```

### 输出

```
10110000100110110111```

# AI分析结果



### 综合分析与结论
本题要求构造特定方向的DAG，使得其拓扑序为字典序第k小的排列。核心思路是将问题转化为生成第k小的全排列，并依此排列确定边的方向（排列中靠前的点指向靠后的点）。各题解中，高效生成排列的方法（如康托展开）是关键，避免了暴力枚举的低效问题。

---

### 精选题解
#### 1. 作者：wzkdh（4星）
- **关键亮点**：使用康托展开高效生成第k小排列，时间复杂度O(n²)，适用于大k值。代码思路清晰，直接映射边方向。
- **核心代码**：
  ```cpp
  void cantor(int x) {
      x %= c[n]; // 处理阶乘模数
      for (int i = n - 1; i >= 0; i--) {
          int idx = x / c[i];
          int tot = 0;
          for (int j = 1; j <= 11; j++) { // 找未使用的第idx个数
              if (v[j]) continue;
              if (tot == idx) {
                  v[j] = 1;
                  ans[i] = j; // 记录排列
              }
              tot++;
          }
          x %= c[i];
      }
  }
  // 映射排列到边的方向
  for (int i = n - 1; i >= 0; i--) {
      xy[ans[i]] = ++tot; // 记录每个点的位置
  }
  ```

#### 2. 作者：HNOIRPplusplus（4星）
- **关键亮点**：提出基于阶乘的逐位确定排列法，无需遍历全排列，时间复杂度O(n²)。适用于极大k值。
- **核心思路**：
  - 对每位计算当前可用数字的第t大（t由剩余阶乘决定）。
  - 直接构造排列，避免暴力枚举。

#### 3. 作者：moyu_028（官方题解）（4星）
- **关键亮点**：理论证明充分，指出拓扑序与全排列的等价性，为所有解法提供理论支撑。
- **结论**：任意排列均可通过特定边定向实现，问题转化为求全排列的第k小。

---

### 关键实现总结
1. **康托展开**：将k-1转换为阶乘系数，逐位生成排列。
2. **排列映射**：记录每个节点在排列中的位置，比较边两端点的位置决定方向。
3. **高效生成排列**：避免暴力枚举，采用数学方法直接构造。

---

### 相似题目推荐
1. **P1706 全排列问题** - 全排列生成基础。
2. **P3014 [USACO11FEB]Cow Line S** - 康托展开与逆展开应用。
3. **P1338 末日的传说** - 构造特定逆序对的排列。

---

### 个人心得摘录
- **调试教训**（yinlu_offical）：反向加边实现时需注意DFS的终止条件，避免无限递归。
- **优化顿悟**（HNOIRPplusplus）：直接计算每位数字可大幅降低时间复杂度，避免无效循环。

---
处理用时：114.31秒
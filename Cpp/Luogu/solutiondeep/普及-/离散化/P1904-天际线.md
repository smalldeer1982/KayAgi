# 题目信息

# 天际线

## 题目描述

Latium 省的 Genoa 是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官 Caesar 的委任，前往 Genoa 建立新的城市。Caesar 对这次任务的要求是在 Genoa 这片土地上建立起一座繁荣的城市，他将以此作为衡量你的表现的标准。

正在你大刀阔斧地进行城市建设的时候，Caesar 突然写信给你，说他要检查 Genoa 的建设情况。Caesar 希望知道你的城市是什么样子，但是他又非常的忙，所以他只要你描述一下城市的轮廓就可以了，他将依照城市的轮廓决定你的薪水。

怎样描述一个城市的轮廓呢？我们知道 Genoa 所有的建筑共享一个地面，你可以认为它是水平的。所有的建筑用一个三元组 $(L_i,H_i,R_i)$，其中 $L_i$ 和 $R_i$ 分别是建筑的左坐标和右坐标，$H_i$ 就是建筑的高度。在下方所示的图表中左边建筑物描述如下 $(1,11,5)$，$(2,6,7)$，$(3,13,9)$，$(12,7,16)$，$(14,3,25)$，$(19,18,22)$，$(23,13,29)$，$(24,4,28)$，右边用轮廓线的顺序$(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)$ 表示：

![](https://cdn.luogu.com.cn/upload/image_hosting/oe7wpwsi.png)


## 样例 #1

### 输入

```
1 11 5
2 6 7
3 13 9
12 7 16
14 3 25
19 18 22
23 13 29
24 4 28
```

### 输出

```
1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0```

# AI分析结果

这道题要求根据给定的建筑三元组$(L_i, H_i, R_i)$，输出城市轮廓线的折点坐标。各题解思路、算法要点及难点解决如下：
1. **InchTree**：
    - **思路**：暴力记录每个点的最大高度，再按顺序输出高度变化的点。
    - **算法要点**：用数组`H`记录每个坐标点的最大高度，遍历输入的建筑，更新对应区间的最大高度，最后线性枚举输出高度变化的点。
    - **解决难点**：注意到点与点间缝隙问题，将更新区间的`<=`改为`<`避免缝隙处点的遗漏。
2. **big_news**：
    - **思路**：采用扫描线 + 线段树做线段区间覆盖，维护y轴投影总长度。
    - **算法要点**：将矩形转化为平行于y轴的线段，插入和删除线段时更新线段覆盖情况，横坐标相同的线段一起处理，根据覆盖总长度变化确定轮廓线折点。
    - **解决难点**：通过线段树节点维护区间覆盖信息，离散化纵坐标处理较大数值范围。
3. **sfmmdm**：
    - **思路**：用数组记录每个坐标的最高楼，通过判断当前坐标与左右坐标的最大高度是否相等，确定是否输出。
    - **算法要点**：用`maxh`数组记录每个坐标的最大高度，通过坐标乘2处理小数坐标问题，遍历坐标判断并输出高度变化的点。
    - **解决难点**：考虑到特殊情况，通过访问`maxh[x ± 0.5]`解决因高度相等导致少输出点的问题。
4. **Timothy**：
    - **思路**：运用线段树成段更新 + 离散化，先排序再离散化，最后搜索线段树叶子节点输出。
    - **算法要点**：对建筑按高度排序，离散化坐标，用线段树维护区间楼房高度，搜索叶子节点输出轮廓线折点。
    - **解决难点**：线段树的成段更新操作及离散化过程的实现。
5. **xiaolou**：
    - **思路**：用线段树进行区间求最大值，再对每个单位求出最大值并按要求输出。
    - **算法要点**：构建线段树，对每栋建筑的占地范围进行区间求最大值操作，最后查询每个单位的最大值并按要求输出。
    - **解决难点**：线段树的区间更新和查询操作细节。
6. **zhengrunzhe**：
    - **思路**：平衡树 + 扫描线，将楼房转化为线段，按x坐标排序，用平衡树维护最大值。
    - **算法要点**：将楼房转化为插入和删除的线段，排序后逐次扫描，根据线段插入和删除时最大值的变化确定轮廓点。
    - **解决难点**：平衡树（Treap）的插入、删除及维护最大值操作。
7. **haoyun1**：
    - **思路**：将建筑二元组建大根堆，扫描端点，判断堆顶是否过期，根据高度变化输出。
    - **算法要点**：将建筑的左端点和右端点排序，扫描时左端点入堆，判断堆顶是否过时，根据堆顶高度变化输出轮廓线折点。
    - **解决难点**：堆的维护及判断堆顶是否过期的操作。
8. **keydu**：
    - **思路**：类似hash表，拉开10000长度数组，更新最大值并按要求输出。
    - **算法要点**：用数组记录每个坐标的最大高度，遍历输入建筑更新，最后按要求输出高度变化的点。
    - **解决难点**：无特殊难点，注意细节处理。
9. **Kevin_Wa**：
    - **思路**：分块处理，统计最大值，扫描判断输出。
    - **算法要点**：读入数据后确定分块大小，对每块进行处理并标记最大值，最后扫描每个点，根据高度变化输出。
    - **解决难点**：分块的划分及处理过程中的细节。
10. **Minecraft万岁**：
    - **思路**：用珂朵莉树（ODT），按高度排序后进行区间赋值，输出高度变化点。
    - **算法要点**：定义珂朵莉树节点，按高度排序建筑，通过珂朵莉树的分裂和赋值操作更新区间，输出高度变化的点。
    - **解决难点**：珂朵莉树的操作实现及处理轮廓线问题的细节。
11. **doby**：
    - **思路**：扫描线维护最大值，用Splay树实现。
    - **算法要点**：将建筑按先后顺序排序，扫描时插入和删除楼房高度到Splay树，根据树中最大值变化输出轮廓线折点。
    - **解决难点**：Splay树的插入、删除及查询操作。
12. **Most_Goodlooking**：
    - **思路**：对横坐标建树，用珂朵莉树按高度排序后区间赋值并输出。
    - **算法要点**：定义珂朵莉树相关结构，按高度排序建筑，通过珂朵莉树操作更新区间，输出轮廓线折点。
    - **解决难点**：珂朵莉树的操作及输出处理。
13. **xiaoDiPa**：
    - **思路**：线段树维护区间最大值和是否平坦，更新和查询时处理不同情况。
    - **算法要点**：定义线段树节点维护区间最大值`val`和是否平坦`isbroke`，更新时根据不同情况处理，查询时根据`isbroke`决定是否继续查询。
    - **解决难点**：线段树更新和查询时多种情况的处理逻辑。
14. **zhenglier**：
    - **思路**：用STL，对每个点用vector记录左右边界，用multiset维护最大值。
    - **算法要点**：输入时将左右边界分别存入对应vector，扫描时根据左右边界操作multiset，输出最大值变化的点。
    - **解决难点**：注意multiset删除元素时要删除迭代器。
15. **littleKtian**：
    - **思路**：用线段树维护每段绿色线段信息，按高度排序后区间覆盖并输出折点。
    - **算法要点**：定义线段树结构，按高度排序建筑，通过线段树区间覆盖操作，输出左右两侧线段信息不同的点。
    - **解决难点**：线段树维护对象的选择及区间覆盖操作。
16. **Setsugesuka**：
    - **思路**：用珂朵莉树处理底相同的扫描线问题，按高度排序后更新并输出。
    - **算法要点**：定义珂朵莉树相关结构，按高度排序建筑，通过珂朵莉树操作更新区间，输出轮廓线折点。
    - **解决难点**：珂朵莉树的操作及合并处理。
17. **brealid**：
    - **思路**：sort + priority_queue，将建筑拆成线，排序后用优先队列处理。
    - **算法要点**：将建筑拆成左右两条线，按横坐标排序，扫描时根据线的类型操作优先队列，输出高度变化的点。
    - **解决难点**：处理相邻不重合建筑的情况。
18. **Mufanc**：
    - **思路**：用STL，将建筑左右边界存入队列，用平衡树维护最大值并输出。
    - **算法要点**：将建筑左右边界存入对应队列，扫描时根据边界操作平衡树，输出最大值变化的点。
    - **解决难点**：平衡树的操作及输出处理。

综合来看，各题解思路多样，涵盖暴力、扫描线、线段树、平衡树、珂朵莉树等多种方法。其中扫描线结合线段树或平衡树能有效处理大规模数据，珂朵莉树在区间操作上也有简洁的实现。

### 题解评分
1. **InchTree**：★★★，思路简单直接，代码简洁，但暴力解法适用范围有限，未涉及复杂算法。
2. **big_news**：★★★★，详细讲解扫描线 + 线段树思路，代码完整，但表述稍显繁杂。
3. **sfmmdm**：★★★，思路清晰，代码简洁，但处理特殊情况方式稍显复杂。
4. **Timothy**：★★★★，算法描述清晰，时间复杂度分析准确，但代码可读性一般。
5. **xiaolou**：★★★★，思路清晰，代码注释详细，线段树操作明确。
6. **zhengrunzhe**：★★★★，平衡树 + 扫描线思路独特，代码实现清晰。
7. **haoyun1**：★★★，思路较清晰，但代码注释可更详细。
8. **keydu**：★★★，简单直接的暴力思路，代码简洁但优化不足。
9. **Kevin_Wa**：★★★，分块思路有一定创新性，但代码实现较复杂。
10. **Minecraft万岁**：★★★，珂朵莉树思路新颖，但代码注释较少。
11. **doby**：★★★，扫描线 + Splay思路清晰，但代码实现较复杂。
12. **Most_Goodlooking**：★★★，珂朵莉树思路，代码较简洁但注释不足。
13. **xiaoDiPa**：★★★，线段树思路独特，但代码逻辑较复杂。
14. **zhenglier**：★★★，STL思路较简洁，但代码细节需注意。
15. **littleKtian**：★★★，线段树思路，代码实现有一定技巧但注释不足。
16. **Setsugesuka**：★★★，珂朵莉树思路，代码实现较复杂。
17. **brealid**：★★★，sort + priority_queue思路清晰，代码实现较简洁。
18. **Mufanc**：★★★，STL思路，代码实现较简单但优化不足。

### 高星题解
1. **big_news**：★★★★
    - **关键亮点**：详细阐述扫描线结合线段树解决线段区间覆盖问题的思路，代码实现完整，对扫描线法和线段覆盖原理讲解清晰。
    - **个人心得**：无
    - **核心代码**：
```cpp
//线段覆盖
class Sugment{ //定义一条线段
  public: int r,x,k;
    bool operator < (const Sugment &a)const
    {return x < a.x;} 
}sug[CN];
int scnt = 0;

int pos[CN],pcnt; //离散化数组
class node{ //定义线段树的节点
  public: int len,cnt;
};
class SGT{ //线段树 (SugmentTree,习惯简写成SGT,我英语不好)
  public:
  	node d[CN<<2];
  	int GetLen(int l,int r,int k){ //更新得到的线段的长度
  		if(d[k].cnt) return pos[r+1]-pos[l];
  		if(l == r) return 0;
  		return d[k<<1].len + d[k<<1|1].len;
    }
  	void modify(int l,int r,int k,int s,int t,int x){ //修改(插入/删除)
  		if(s<=l && r<=t){ //这里的操作和普通线段树类似
  			d[k].cnt += x;
  			d[k].len = GetLen(l,r,k);
  			return;
        }
        int m = (l+r)>>1;
        if(s <= m) modify(l,m,k<<1,s,t,x);
        if(m < t) modify(m+1,r,k<<1|1,s,t,x);
        d[k].len = GetLen(l,r,k); //更新线段长度
    }
}sgt;

void SugmentCover(int i){ //线段覆盖
    int l = 1;
    int r = lower_bound(pos+1,pos+pcnt+1,sug[i].r)-pos-1; //查找离散化之后的值
    sgt.modify(1,pcnt,1,l,r,sug[i].k);
}
```
    - **核心思想**：定义`Sugment`表示线段，`node`表示线段树节点，`SGT`类实现线段树操作。`GetLen`函数计算更新后线段长度，`modify`函数实现线段的插入和删除操作，`SugmentCover`函数进行线段覆盖更新。
2. **Timothy**：★★★★
    - **关键亮点**：算法描述清晰，采用线段树成段更新 + 离散化方法，对时间复杂度和空间复杂度有准确分析。
    - **个人心得**：无
    - **核心代码**：
```cpp
void pushdown(int rt)
{
    col[rt<<1]=col[rt<<1|1]=1;
    num[rt<<1]=num[rt<<1|1]=num[rt];
    col[rt]=0;
}
int ef(int l1,int r1,int mb)
{
    int l=l1,r=r1;
    while (l<=r)
    {
        int mid=(l+r)>>1;
        if (le[mid]>=mb)r=mid-1;
        else l=mid+1;
    }
    return l;
}
void update(int l,int r,int rt,int L,int R,int H)
{
    if (L<=l && r<=R){col[rt]=1;num[rt]=H;return;}
    int mid=(l+r)>>1;
    if (col[rt])pushdown(rt);
    if (L<=mid)update(lson,L,R,H);
    if (R>mid)update(rson,L,R,H);
}
int query(int l,int r,int rt,int u)
{
    if (l==r)return num[rt];
    int mid=(l+r)>>1;
    if (col[rt])pushdown(rt);
    if (u<=mid)query(lson,u);
    else query(rson,u);
}
```
    - **核心思想**：`pushdown`函数将标记下传，`ef`函数用于离散化查找，`update`函数实现线段树区间更新，`query`函数用于查询节点值。
3. **xiaolou**：★★★★
    - **关键亮点**：思路清晰，代码注释详细，详细展示线段树解决问题的过程。
    - **个人心得**：无
    - **核心代码**：
```cpp
void BuildT(int id,int l,int r)//建树
{
    t[id].le=l;
    t[id].ri=r;
    t[id].la=0;
    if(t[id].le==t[id].ri)
    {
        t[id].mx=0;
        return;
    }
    int mid=(l+r)/2;
    BuildT(id*2,l,mid);
    BuildT(id*2+1,mid+1,r);
}
void Push(int id)//la标记下放
{
    if(t[id].la)
    {
        t[id*2].la=t[id].la;
        t[id*2+1].la=t[id].la;
        t[id*2].mx=max(t[id*2].mx,t[id*2].la);
        t[id*2+1].mx=max(t[id*2+1].mx,t[id*2+1].la);
        t[id].la=0;
    }
}
void Change(int id,int l,int r,int c)//修改，注意细节
{
    if(t[id].le==l&&t[id].ri==r)
    {
        t[id].mx=max(t[id].mx,c);
        t[id].la=c;
        return;
    }
    Push(id);
    if(r<=t[id*2].ri)
    {
        Change(id*2,l,r,c);
    }
    else if(l>=t[id*2+1].le)
    {
        Change(id*2+1,l,r,c);
    }
    else
    {
        Change(id*2,l,t[id*2].ri,c);
        Change(id*2+1,t[id*2+1].le,r,c);
    }
    t[id].mx=max(t[id*2].mx,t[id*2+1].mx);
}
int Query(int id,int l,int r)//查询
{
    if(t[id].le==l&&t[id].ri==r)
    {
        return t[id].mx;
    }
    Push(id);
    if(r<=t[id*2].ri)
    {
        return Query(id*2,l,r);
    }
    else if(l>=t[id*2+1].le)
    {
        return Query(id*2+1,l,r);
    }
    else
    {
        return max(Query(id*2,l,t[id*2].ri),Query(id*2+1,t[id*2+1].le,r));
    }
}
```
    - **核心思想**：`BuildT`函数构建线段树，`Push`函数下放标记，`Change`函数实现区间修改，`Query`函数实现区间查询。

### 最优关键思路或技巧
1. **数据结构选择**：扫描线结合线段树或平衡树能高效处理大规模数据，珂朵莉树

---
处理用时：111.58秒
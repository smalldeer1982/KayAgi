# 题目信息

# [Aya Round 1 D] 文文的数学游戏

## 题目背景

在解决了上一题之后，琪露诺觉得自己仿佛就是天才。于是，射命丸文又给了她一道简单的数学题。

## 题目描述

给定长度为 $n$ 的整数序列 $a$，你需要构造一个长度为 $n$ 的整数序列 $b$ 满足对于所有 $1\le i\le n$，有 $1\le b_i \le a_i$。且 $\gcd(b_1,b_2,\cdots,b_n)$ 最大，其中 $\gcd$ 表示最大公因数。试求出能得到的最大值和取得最大值时，不同的数列 $b$ 的个数，对 $10^9+7$ 取模。

定义两个长度为 $L$ 的数列 $c,d$ 不同，当且仅当存在整数 $i(1 \le i \le L)$，使得 $c_i \ne d_i$。

## 说明/提示

### 样例 1 解释

注意到由于 $1\le b_1\le a_1=1$，因此 $b_1$ 必须要为 $1$，因此最大的 $\gcd$ 值只能为 $1$。在这个前提下，所有合法的 $b$ 如下：

- $\{1,1,1\},\{1,1,2\},\{1,1,3\},\{1,2,1\},\{1,2,2\},\{1,2,3\}$。

### 数据范围与约束

对于 $100\%$ 的数据，$1 \le n\le 10^5$，$1 \le a_i\le 10^9$。

本题附带一组大样例。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
1 6```

# AI分析结果

### 综合分析与结论
这三道题解思路一致，均先确定最大 $\gcd$ 为数组 $a$ 中的最小值，再通过计算每个 $b_i$ 能取的方案数并相乘得到总方案数，同时强调取模和使用 long long 避免溢出。

### 所选题解
- **作者：chen_zhe（5星）**
  - 关键亮点：思路清晰，代码简洁易懂，详细说明了最大 $\gcd$ 的取值原因和方案数的计算方法。
```cpp
#include <iostream>
using namespace std;
int a[100050],n,mgcd=1<<30;
const int mod=1e9+7;
int main()
{
    cin >> n;
    for (int i=1;i<=n;i++)
    {
        cin >> a[i];
        mgcd=min(mgcd,a[i]);
    }
    long long ans=1;
    for (int i=1;i<=n;i++)
        ans=(long long)ans*(a[i]/mgcd)%mod;
    cout << mgcd << " " << ans << endl;
    return 0;
}
```
核心实现思想：先找出数组 $a$ 中的最小值 `mgcd`，再遍历数组计算每个 $a[i]$ 除以 `mgcd` 的结果并累乘，边乘边取模，最后输出最大 $\gcd$ 和方案数。

- **作者：落花月朦胧（4星）**
  - 关键亮点：对最大 $\gcd$ 的取值进行了详细证明，提供了自动取模模板。
```cpp
int n;
std::cin >> n;
std::vector<int> a(n);
int mn = inf;
for (int i = 0; i < n; i++) {
	std::cin >> a[i];
	mn = std::min(mn, a[i]);
}
std::cout << mn << " ";
Z ans = 1;
for (int i = 0; i < n; i++) {
    ans *= (a[i] / mn);
}
std::cout << ans.val() << "\n";
```
核心实现思想：用 `vector` 存储数组 $a$，找出最小值 `mn`，计算每个 $a[i]$ 除以 `mn` 的结果并累乘，最后输出最大 $\gcd$ 和方案数。

- **作者：xzy090626（4星）**
  - 关键亮点：详细说明了思路和实现细节，给出代码实现。
```cpp
#include<iostream>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
int a[1000005];
signed main(){
	int n;cin>>n;
	int cnt = 1.1e9;
	int ans = 1;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cnt = min(a[i],cnt);
	for(int i=1;i<=n;i++) ans *= a[i]/cnt,ans %= mod;
	cout<<cnt<<' '<<ans;
	return 0;
}
```
核心实现思想：定义数组 $a$，找出最小值 `cnt`，计算每个 $a[i]$ 除以 `cnt` 的结果并累乘，边乘边取模，最后输出最大 $\gcd$ 和方案数。

### 最优关键思路或技巧
- 思维方式：通过分析 $\gcd$ 的性质，确定最大 $\gcd$ 为数组 $a$ 中的最小值。
- 代码实现技巧：使用 long long 避免乘法溢出，边乘边取模防止结果过大。

### 可拓展之处
同类型题可能会增加约束条件，如对 $b$ 数组的元素有其他限制，或要求满足更多条件下的最大 $\gcd$ 及方案数。类似算法套路是先分析问题的性质确定关键值，再根据乘法原理计算方案数。

### 推荐题目
- P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题
- P1372 又是毕业季I
- P2568 GCD

### 个人心得
- **xzy090626**：提到记得开 long long 并取模，取最小值时初始值要大于 $1\times10^9$，还表达了对比赛和出题组的感谢，以及对 CSP 2022 的祝福。总结为在实现代码时要注意数据类型和边界值，同时对比赛和出题组表示肯定。 

---
处理用时：26.70秒
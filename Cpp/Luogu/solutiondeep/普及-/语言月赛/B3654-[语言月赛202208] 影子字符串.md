# 题目信息

# [语言月赛202208] 影子字符串

## 题目背景

众所周知，影子并不是实际物体。

## 题目描述

给出多个字符串（数目未知），**每行**一个。

其中有可能会有重复的字符串，而我们认为在这些字符串中，较靠后出现的都是靠前出现的字符串的“**影子**”。

例如，

```plain
abc
def
abc
abc
abc
```

我们在第 $1,3,4,5$ 行都出现了字符串 `abc`，那么 $3,4,5$ 行的字符串会被称为“影子字符串”。


现在要求把所有的**非影子字符串**都按照**行号从小到大**依次拼接为一个长串并输出。



## 说明/提示

对于 $20\%$ 的数据，无重复字符串。

对于 $100\%$ 的数据， $1\leq n\leq 500$，字符串总长度不超过 $50000$ ，字符集为全部的小写字母、数字、 `.` 、`!` 和 `&`。

也就是说，每个字符串中只包含小写字母、数字、 `.` 、`!` 和 `&`，不包含空格等特殊符号。

## 样例 #1

### 输入

```
cc
b
a
cc
0```

### 输出

```
ccba```

# AI分析结果

### 综合分析与结论

题目要求处理多个字符串，并输出所有非影子字符串的拼接结果。关键在于如何高效地判断一个字符串是否已经出现过，并只输出第一次出现的字符串。

### 所选题解

#### 题解1：览遍千秋 (★★★★☆)

**关键亮点：**
- 使用数组存储所有输入的字符串，并通过遍历数组来判断当前字符串是否已经出现过。
- 代码简洁明了，易于理解。

**核心实现思想：**
- 使用一个数组 `s` 来存储所有输入的字符串，并通过一个计数器 `cnt` 来记录当前输入的字符串数量。
- 对于每个新输入的字符串，遍历数组 `s` 中之前的所有字符串，如果发现相同的字符串，则标记为影子字符串，不输出；否则输出该字符串。

**核心代码片段：**
```cpp
string s[600];
int cnt = 0;

while(true) {
    ++cnt; 
    cin >> s[cnt];
    if(s[cnt] == "0") break;
    bool occ = false;
    for(int i = 1; i < cnt; i++) {
        if(s[i] == s[cnt]) {
            occ = true; 
            break;
        }
    }
    if(occ == false) cout << s[cnt];
}
```

**个人心得：**
- 该解法虽然简单，但在数据量较小的情况下表现良好。对于更大的数据量，可以考虑使用更高效的数据结构如 `set` 或 `unordered_set` 来优化查找速度。

### 通用建议与扩展思路

- **数据结构优化：** 使用 `set` 或 `unordered_set` 来存储已经出现过的字符串，可以将查找时间复杂度从 O(n) 降低到 O(1)。
- **算法优化：** 对于更复杂的字符串处理问题，可以考虑使用字典树（Trie）或字符串哈希来进一步优化。

### 推荐题目

1. **P3370 【模板】字符串哈希** - 考察字符串哈希的应用。
2. **P2580 于是他错误的点名开始了** - 考察字典树的应用。
3. **P1177 【模板】快速排序** - 考察排序算法的应用，虽然不直接相关，但有助于理解算法优化的重要性。

### 总结

览遍千秋的题解虽然简单，但在小数据量下表现良好，代码易于理解。对于更大数据量，建议使用 `set` 或 `unordered_set` 来优化查找效率。

---
处理用时：24.23秒
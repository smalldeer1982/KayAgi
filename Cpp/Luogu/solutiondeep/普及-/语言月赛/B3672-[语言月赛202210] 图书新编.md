# 题目信息

# [语言月赛202210] 图书新编

## 题目描述

图书馆中每本书都有一个图书编码，可以用于快速检索图书，这个图书编码是一个正整数。 每位借书的读者手中有一个需求码，这个需求码也是一个正整数。

如果一本书的图书编码恰好以读者的需求码结尾，那么这本书就是这位读者所需要的。

小 D 刚刚当上图书馆的管理员，她知道图书馆里所有书的图书编码，她请你帮她写一个程序，对于每一位读者，求出有多少本书是他所需要的。


## 说明/提示

对于 $20\%$的数据，$1 \le n \le 2$；  
另有 $20\%$的数据，$q = 1$；  
另有 $20\%$的数据，所有读者的需求码的长度均为 $1$；  
另有 $20\%$的数据，所有的图书编码按从小到大的顺序给出；   
对于 $100\%$的数据，$1 \le n \le 1000,1 \le q \le 1000$，所有的图书编码和需求码均不超过 $10^7$。


## 样例 #1

### 输入

```
5 5 
2123 
1123 
23 
24 
24 
2 23 
3 123 
3 124 
2 12 
2 12```

### 输出

```
3
2
0
0
0
```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何高效地判断一本书的编码是否以读者的需求码结尾。由于数据规模较小（$n, q \leq 1000$），直接暴力匹配即可通过。题解中提到的关键思路是利用模运算来提取图书编码的最后几位，并与需求码进行比较。这种方法简洁高效，适合本题的数据范围。

### 所选题解

#### 题解：Maxmilite (5星)

**关键亮点：**
- **思路清晰**：通过模运算提取图书编码的最后几位，直接与需求码进行比较，逻辑简单明了。
- **代码可读性高**：代码结构清晰，变量命名合理，易于理解。
- **优化程度适中**：虽然未进行复杂优化，但针对本题的数据规模，已经足够高效。

**核心代码：**
```cpp
const int digit[] = {0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000};

for (int i = 1; i <= q; ++i) {
    int x, y;
    cin >> x >> y;
    int cnt = 0;
    for (int j = 1; j <= n; ++j) {
        int var1 = a[j] % digit[x];
        if (var1 == y)
            ++cnt;
    }
    cout << cnt << endl;
}
```

**核心实现思想：**
- 使用预定义的 `digit` 数组来存储 $10^k$ 的值，方便后续的模运算。
- 对于每个查询，遍历所有图书编码，通过模运算提取最后 $x$ 位，与需求码 $y$ 进行比较，统计匹配的图书数量。

### 最优关键思路或技巧

- **模运算提取末尾数字**：通过 `c % 10^k` 可以快速提取一个数的最后 $k$ 位，这种方法在处理数字末尾匹配问题时非常高效。
- **预处理 $10^k$ 值**：通过预定义 `digit` 数组，避免了在循环中重复计算 $10^k$，提高了代码的效率。

### 可拓展之处

- **更大数据规模**：如果数据规模更大，可以考虑使用字符串匹配或哈希表来优化查询效率。
- **多条件匹配**：如果题目要求多个条件（如开头匹配、中间匹配等），可以结合字符串处理或正则表达式来解决。

### 推荐相似题目

1. **P1003 铺地毯** - 考察字符串匹配和模拟。
2. **P1012 拼数** - 考察数字处理和排序。
3. **P1047 校门外的树** - 考察区间处理和模拟。

### 个人心得总结

- **调试经历**：在处理数字末尾匹配时，模运算是一个简单且高效的方法，避免了复杂的字符串操作。
- **踩坑教训**：在预定义 `digit` 数组时，确保数组大小足够，避免越界问题。
- **顿悟感想**：通过模运算提取数字的某几位，可以简化很多数字处理问题，值得在类似问题中推广应用。

---
处理用时：29.03秒
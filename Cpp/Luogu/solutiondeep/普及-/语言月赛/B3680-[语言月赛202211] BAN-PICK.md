# 题目信息

# [语言月赛202211] BAN-PICK

## 题目描述

在第五人格职业联赛的每一场对局中，需要进行 Ban-Pick 流程。Ban 即角色禁用，Pick 即角色选用。

如试题 Winner 所述，游戏分为 **求生者（$\texttt{Survivor}$）** 与 **监管者（$\texttt
{Hunter}$）** 两个阵营。**求生者阵营** 共有 $n$ 名角色，**监管者阵营** 共有 $m$ 名角色。

在某局比赛中，**监管者** 可以 ban(禁用) 掉 **求生者阵营** $5$ 名角色，**求生者** 可以 ban(禁用) 掉 **监管者阵营** $2$ 名角色。

每个角色，无论其属于求生者阵营还是监管者阵营，均可以使用 **熟练度** 来量化该阵营选手选择该角色的优先程度。选手一定会优先选择 **熟练度** 更高的角色进行游戏。

基于这样的考量，**监管者选手** 在进行 Ban 流程时，往往会选择 ban(禁用) 掉 **求生者阵营熟练度最高** 的若干名 **求生者角色**。同样，**求生者选手** 在进行 Ban 流程时，往往会选择 ban(禁用) 掉 **监管者阵营熟练度最高** 的若干名 **监管者角色**。

在 Ban 流程完成后，需要执行 Pick 流程。

如试题 Winner 所述，**求生者选手** 需要从 **求生者阵营** 中选择 $4$ 名不同的角色，**监管者选手** 需要从 **监管者阵营** 中选择 $1$ 名角色。

现在告诉你所有角色的名字、阵营与选手对其熟练度，请你给出双方阵营 Pick 的角色名字。

## 说明/提示

### 输入输出样例 1 解释

求生者阵营角色：$\texttt{Amily,Lydia,Lisa,Freddie,Cliche,Aesop,Eli,Norton,Emma}$。

监管者阵营角色：$\texttt{Beck,Tiletower,Yidhra}$。

监管者选手将 ban 掉求生者阵营中角色 $\texttt{Norton,Eli,Aesop,Cliche,Freddie}$。

求生者选手将 ban 掉监管者阵营中角色 $\texttt{Tiletower,Yidhra}$。

### 数据规模与约定

对于前 $20\%$ 的数据，$n = 9, m = 3$。

对于前 $50\%$ 的数据，保证 $n \leq 10 ^ 3, m \leq 10 ^3$。

对于前 $70\%$ 的数据，保证 $w _ i \leq 10 ^ 9$。

对于所有数据，保证 $9 \leq n \leq 10 ^ 5, 3 \leq m \leq 10 ^ 5$，所有名字长度 $\leq 10$。熟练度大小 $w _ i$ 满足 $1 \leq w _ i \leq 10 ^ {18}$。保证每个阵营中熟练度互不相同。保证名字仅有大写字母和小写字母构成。

## 样例 #1

### 输入

```
9 3
Amily S 1
Lydia S 2
Lisa S 4
Beck H 1
Freddie S 5
Cliche S 6
Aesop S 7
Eli S 8
Norton S 9
Tiletower H 3
Yidhra H 2
Emma S 3
```

### 输出

```
Beck
Lisa
Emma
Lydia
Amily```

# AI分析结果

### 综合分析与结论

本题的核心在于对角色进行熟练度排序，并根据规则输出特定的角色名称。题解的关键点在于如何高效地处理输入数据、进行分类排序，并正确输出结果。通过对比题解，发现大部分题解都采用了结构体存储角色信息，并通过自定义排序函数进行排序。整体思路清晰，代码实现较为简洁。

### 所选题解

#### 题解作者：Maxmilite (★★★★☆)

**关键亮点：**
1. **结构体使用**：通过结构体 `node` 存储角色名称和熟练度，简化了数据处理。
2. **分类排序**：在读入数据时直接分类存储，避免了后续的额外分类操作。
3. **自定义排序函数**：通过 `cmp` 函数实现熟练度的降序排序，代码简洁易读。
4. **输出逻辑清晰**：直接根据排序后的数组输出特定位置的角色名称，逻辑明确。

**个人心得：**
- **调试经历**：在排序时需要注意数组的起始索引，避免越界错误。
- **顿悟感想**：通过结构体和排序函数的结合，可以高效处理类似的数据排序问题。

**核心代码片段：**
```cpp
struct node {
    string name;
    long long val;
} s[100005], h[100005];

int cmp(node x, node y) {
    return x.val > y.val;
}

sort(s + 1, s + cntS + 1, cmp);
sort(h + 1, h + cntH + 1, cmp);

cout << h[3].name << endl;
for (int i = 6; i <= 9; ++i) {
    cout << s[i].name << endl;
}
```

### 最优关键思路或技巧

1. **结构体存储**：使用结构体存储角色信息，便于后续的排序和输出操作。
2. **分类处理**：在读入数据时直接进行分类存储，减少后续的额外操作。
3. **自定义排序**：通过自定义排序函数实现熟练度的降序排序，代码简洁高效。

### 可拓展之处

- **同类型题**：类似的数据排序和分类输出问题，如学生成绩排名、商品价格排序等。
- **算法套路**：结构体存储 + 自定义排序 + 分类输出，适用于多种数据处理场景。

### 推荐题目

1. **P1177 【模板】快速排序**：考察排序算法的基本实现。
2. **P1059 明明的随机数**：涉及数据去重和排序。
3. **P1068 分数线划定**：考察数据排序和特定位置的输出。

### 通用建议与扩展思路

- **数据结构选择**：在处理大量数据时，选择合适的数据结构（如结构体、数组）可以提高代码的效率和可读性。
- **排序算法优化**：对于大规模数据，可以考虑使用更高效的排序算法（如快速排序、归并排序）。
- **调试技巧**：在排序和输出时，注意数组的索引范围，避免越界错误。

---
处理用时：23.21秒
# 题目信息

# [语言月赛202211] Power Strip

## 题目描述

理塘大学举行了第五人格校内排位赛，很多同学带了自己的笔记本电脑用来比赛。笔记本需要供电，但是很快同学们发现了一个问题，赛场里只有一个插座！因此同学们将自己的插排带到了赛场里。

具体的，同学们一共带来了 $n$ 个插排，我们分别将其标号为 $1 \sim n$。

下一个问题是插排的安装问题。由于赛场里只有一个插座，因此同学们只能用如图的 “插排插插排” 的方式。

![](https://cdn.luogu.com.cn/upload/image_hosting/eed9tli7.png)

$$\begin{matrix} \color{red} \small \text{请注意，这种情况只是服务于题目背景，但是十分不符合用电安全！} \\\color{red} \small \text{在生活用电中，请保证安全至上！}\end{matrix}$$

具体的，你会得到一个长度为 $n - 1$ 的序列 $u _ 2, \cdots, u _ n$。 除编号为 $1$ 的插排连接在插座上外，$u _ i$ 代表编号为 $i$ 的插排连接在 $u _ i$ 编号的插排上，我们保证 $u _ i < i$。

插排安装好后，同学们将充电器插在了不同的插座上。最后，我们可以用一个序列 $a _ 1, a _ 2, \cdots, a _ n$ 表示充电器的使用情况。具体的，对于标号为 $i$ 的插座，其被插上了 $a _ i$ 个充电器。

我们定义插排 $i$ 向某个充电器**供电**，当且仅当电流从赛场中的唯一一个插座流向这个充电器的时候，经过了插排 $i$。

如果对供电的概念有疑问，可以参照**样例解释 #1**进一步理解。

现在同学们想要知道，对于每一个插排，这个插排在向几个充电器**供电**。然而这个问题对于他们来说太难，所以他们找到了你，希望你能够帮他们解决这个问题。


## 说明/提示

**【样例 #1 解释】**

我们使用紫色矩形表示一个充电器，样例 #1 的插排排布如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jbftzsfa.png)

以 $4$ 号插排举例，显然 $4, 5, 6$ 号插排上的充电器供电都需要经过 $4$ 号插排。电流方向如下图蓝色箭头所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/z8o6ucz4.png)

$4$ 号插排供电的充电器共有 $1 + 2 + 4 = 7$ 个。

**【数据规模与约定】**

对于前 $10\%$ 的数据，保证 $n = 2$。

对于前 $20\%$ 的数据，保证 $n \leq 10$。

对于前 $50\%$ 的数据，保证 $n \leq 5 \times 10 ^ 3$。

对于另外 $10\%$ 的数据，保证对任意的 $2 \leq i \leq n, u_i = i - 1$。

对于另外 $10\%$ 的数据，保证对任意的 $2 \leq i \leq n, u_i = 1$。

对于所有数据，保证 $2 \leq n \leq 1 \times 10 ^ 6, 0 \leq a _ i \leq 10 ^ 9, 1 \leq u _ i < i$。

## 样例 #1

### 输入

```
6
1 2 1 4 5
1 2 3 1 2 4```

### 输出

```
13 5 3 7 6 4```

# AI分析结果

### 综合分析与结论

本题的核心在于通过给定的插排连接关系和充电器数量，计算每个插排供电的充电器数量。题解的主要思路是利用插排的连接关系，从后向前遍历，逐步累加充电器数量到上级插排。这种方法利用了树形结构的特点，通过一次遍历即可完成计算，时间复杂度为O(n)，非常高效。

### 所选高星题解

#### 题解1：Maxmilite (5星)
**关键亮点：**
- **思路清晰**：明确解释了从后向前遍历的原因，并详细说明了如何通过累加计算每个插排的供电数量。
- **代码简洁**：代码实现非常简洁，直接利用数组进行累加，避免了复杂的结构。
- **优化程度高**：时间复杂度为O(n)，空间复杂度为O(n)，均为最优。

**核心代码：**
```cpp
cin >> n;
for (int i = 2; i <= n; ++i)
    cin >> u[i];
for (int i = 1; i <= n; ++i)
    cin >> a[i];
for (int i = n; i > 1; --i) {
    a[u[i]] += a[i];
}
for (int i = 1; i <= n; ++i)
    cout << a[i] << ' ';
cout << endl;
```
**核心思想：**
从后向前遍历插排，将当前插排的充电器数量累加到其上级插排，最终得到每个插排的供电数量。

### 最优关键思路或技巧

- **从后向前遍历**：利用树形结构的特点，从叶子节点向根节点遍历，确保在计算当前节点时，其所有子节点的信息已经计算完毕。
- **累加计算**：通过简单的累加操作，将子节点的充电器数量累加到父节点，避免了复杂的递归或多次遍历。

### 可拓展之处

- **树形结构的累加问题**：类似的问题可以出现在树形结构的其他场景中，如计算每个节点的子树和、子树最大值等。
- **动态规划思想**：本题的累加计算可以看作是一种动态规划的思想，通过子问题的解来构造更大问题的解。

### 推荐相似题目

1. **P1040 加分二叉树**：考察树形结构的动态规划问题。
2. **P1352 没有上司的舞会**：树形DP的经典问题，计算最大权值和。
3. **P2015 二叉苹果树**：树形DP问题，计算保留特定数量边的最大权值和。

### 个人心得总结

- **调试经历**：在实现过程中，确保从后向前遍历的顺序非常重要，否则可能导致计算错误。
- **踩坑教训**：初始尝试从前向后遍历，发现无法正确处理子节点的累加，后改为从后向前遍历，问题得以解决。
- **顿悟感想**：树形结构的遍历顺序对问题的解决至关重要，选择合适的遍历顺序可以大大简化问题的复杂度。

---
处理用时：28.26秒
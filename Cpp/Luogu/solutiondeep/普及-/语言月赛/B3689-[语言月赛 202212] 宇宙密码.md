# 题目信息

# [语言月赛 202212] 宇宙密码

## 题目描述

经历十九年的探索，人们终于找到了宇宙中的那份瑰宝。

这份瑰宝被装在一个密码箱里，按照情报，密码应为一串长度为 $n$ 的数字 $a$。

人们满怀希望地输入了密码，但是密码箱没有任何反应。

这时人们意识到，在十九年中，由于宇宙射线的侵蚀，密码箱的密码发生了改变。

现在人们知道，能够打开密码箱的新密码是由原密码 $a$ 变化而来。具体的，新密码相比原密码变化了 $t$ 位数字，其中 $t$ 满足 $0 \leq t \leq k$，且对于变化的数字位，变化后的数字是在该位置原数字的基础上增加或减小 $1$ 得到的数字。特别的，如果原数字是 $0$，在原数字基础上减少 $1$ 得到的数字是 $9$；如果原数字是 $9$，在原数字基础上增加 $1$ 得到的数字是 $0$。

现在人们知道了 $n, a, k$，想知道经过宇宙射线侵蚀后，所有可能打开密码箱的密码。

人类将重任交到了你身上，请你帮助人类解决这个问题。你需要由小到大输出所有可能的密码，每个一行。

特别的，有一些密码可能存在前导 $0$。为了方便操作，这时你**不必也不应**将这些前导 $0$ 一并输出。

人类感谢你。

## 说明/提示

### 样例 1 解释

原密码为 $014$，允许至多 $1$ 位有变化。

所有密码情况如下：

| 变化位数和位置 | 可能的结果 |
| :-: | :-: |
| $0$ 位 | $014$ |
| $1$ 位，从左向右第 $1$ 位 | $114, 914$ |
| $1$ 位，从左向右第 $2$ 位 | $024, 004$ |
| $1$ 位，从左向右第 $3$ 位 | $013, 015$ |

共 $7$ 个可能的密码，按从小到大排序输出即可。

### 数据规模与约定

- 对于前 $10\%$ 的数据，保证 $n = k = 1$。
- 对于前 $40\%$ 的数据，保证 $k \leq 1$。
- 对于另外 $10\%$ 的数据，保证 $k = n$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 6$，$0 \leq a < 10 ^ n$，$0 \leq k \leq n$，保证输入数据无前导 $0$。

请注意，输出数据中**不应**存在前导 $0$。

## 样例 #1

### 输入

```
3 14 1```

### 输出

```
4
13
14
15
24
114
914```

# AI分析结果

### 综合分析与结论

本题的核心在于生成所有可能的密码，这些密码是通过对原密码进行至多 `k` 位数字的“变化”得到的。难点在于如何高效地生成所有可能的密码，并且确保输出顺序为从小到大。题解中提供了一种枚举所有可能数字并逐一验证的方法，虽然简单直观，但在数据规模较小的情况下（`n <= 6`）是可行的。

### 所选题解

#### 题解作者：Maxmilite
- **星级：4星**
- **关键亮点：**
  - **思路清晰**：通过枚举所有可能的数字并逐一验证，确保输出顺序为从小到大。
  - **代码简洁**：使用 `check` 函数进行验证，代码逻辑清晰，易于理解。
  - **优化程度**：虽然枚举所有可能数字的方法在数据规模较大时效率较低，但在本题的数据规模下（`n <= 6`）是可行的。

- **核心代码：**
```cpp
int check(int x) {
    int cnt = 0, var = a;
    for (int i = 1; i <= n; ++i) {
        if (abs((var % 10) - (x % 10)) == 1 || abs((var % 10) - (x % 10)) == 9) {
            ++cnt;
        } else if (abs((var % 10) - (x % 10)) >= 2) {
            return 0;
        }
        var /= 10, x /= 10;
    }
    return cnt <= k;
}

cin >> n >> a >> k;
int limit = pow(10, n);
for (int i = 0; i < limit; ++i) {
    if (check(i)) {
        cout << i << endl;
    }
}
```

### 最优关键思路或技巧

1. **枚举与验证**：通过枚举所有可能的数字并逐一验证是否符合条件，确保输出顺序为从小到大。
2. **特殊情况处理**：在 `check` 函数中，特别处理了数字 `0` 和 `9` 的变化情况，确保逻辑正确。

### 可拓展之处

1. **数据规模较大时的优化**：如果数据规模较大，可以考虑使用深度优先搜索（DFS）或广度优先搜索（BFS）来生成所有可能的密码，避免枚举所有数字。
2. **类似题目**：可以应用于其他需要生成所有可能组合的题目，如密码破解、排列组合等。

### 推荐题目

1. **洛谷 P1036 选数**：考察生成所有可能的组合并进行验证。
2. **洛谷 P1706 全排列问题**：生成所有可能的排列，类似于生成所有可能的密码。
3. **洛谷 P1219 八皇后**：生成所有可能的放置方式，类似于生成所有可能的密码组合。

### 个人心得

- **调试经历**：在实现 `check` 函数时，需要特别注意数字 `0` 和 `9` 的变化情况，确保逻辑正确。
- **踩坑教训**：在枚举所有可能数字时，需要注意数据规模，避免在数据规模较大时效率过低。
- **顿悟感想**：通过枚举所有可能数字并逐一验证的方法，虽然简单直观，但在数据规模较小的情况下是可行的。

---
处理用时：26.87秒
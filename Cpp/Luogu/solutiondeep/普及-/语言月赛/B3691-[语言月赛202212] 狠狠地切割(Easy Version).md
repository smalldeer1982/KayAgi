# 题目信息

# [语言月赛202212] 狠狠地切割(Easy Version)

## 题目描述

现给你一个长度为 $n$ 的序列 $a _ 1, \cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \cdots, b _ m$。你需要按照这 $m$ 个数对序列 $a$ 进行**狠狠地切割**。

具体的，对于一个数字 $i \in [1, n]$，如果存在一个整数 $j \in [1, m]$，使得 $a _ i = b _ j$，则将位置 $i$ 称为一个**切割点**。对序列 $a$ 中的每一个切割点，我们在这个位置进行一次**狠狠地切割**。方法是，将该位置的数字去除，然后在这个位置将其左右的**序列/片段**一分两半。

如果对**狠狠地切割**的定义有疑问，可以参照「样例 #1」及「样例解释 #1」进行理解。

你需要计算，在进行了所有可能的**狠狠地切割**后，序列被切割为了多少**片段**。

特别的，如果在切割后，某一段内没有数组，那这一段不可被叫做**片段**。同样的，如果 $1$ 或 $n$ 为切割点，其与开头和结尾之间也不存在片段。

如果对**片段**的概念有疑问，可以参照「样例 #2」及「样例解释 #2」进行理解。

## 说明/提示

### 样例 1 解释

在**狠狠地切割**前，序列 $a$ 如下所示：

$$\begin{matrix} 3 & 4 & 3 & 5 & 2 & 6 \end{matrix}$$

容易知道，第二个位置和第四个位置为切割点，我们使用 `|` 对其进行替换，代表去除工作：

$$\begin{matrix} 3 & | & 3 & | & 2 & 6 \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{3} ^ \text{片段 1} & | & \overbrace{3} ^ \text{片段 2} & | & \overbrace{2 \quad 6} ^ \text{片段 3} \end{matrix}$$

共计 $3$ 个片段。

### 样例 2 解释

以下我们展示去除之后的序列：

$$\begin{matrix} | & 4 & | & | & 2 & | \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} | & \overbrace{4} ^ \text{片段 1} & | & \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} & | & \overbrace{2} ^ \text{片段 2} & | \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段}\end{matrix}$$

共计 $2$ 个片段。

### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n, m \leq 10$。
- 对于 $70\%$ 的数据，保证 $n, m \leq 5 \times 10 ^ 3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 5 \times 10 ^ 5$，$1 \leq a_i,b_i \leq 5 \times 10^{6}$。

### 提示
本题输入规模较大，建议考虑使用较快的读入读出方式。

## 样例 #1

### 输入

```
6 2
3 4 3 5 2 6
5 4```

### 输出

```
3```

## 样例 #2

### 输入

```
6 3
3 4 3 5 2 6
3 5 6```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心任务是找到序列中的切割点，并根据这些切割点将序列分割成多个片段。题解中提供了多种方法来解决这个问题，主要集中在如何高效地找到切割点以及如何计算片段数量。以下是对各题解的分析与总结：

1. **数组记录法**：适用于Easy Version，利用数组记录切割点，时间复杂度为O(n)，空间复杂度为O(max(a_i, b_i))。该方法简单直接，但受限于值域范围。
2. **unordered_map法**：适用于Hard Version，利用哈希表记录切割点，时间复杂度为O(n)，空间复杂度为O(m)。该方法适用于值域较大的情况，但哈希表的常数较大。
3. **二分查找法**：适用于Hard Version，先对b排序，然后对每个a_i进行二分查找，时间复杂度为O(n log m)，空间复杂度为O(m)。该方法在m较大时效率较高。
4. **双指针法**：适用于Hard Version，先对a和b排序，然后使用双指针查找切割点，时间复杂度为O(n + m)，空间复杂度为O(n + m)。该方法在a和b都较大时效率最高。

### 所选题解

#### 1. 双指针法（5星）
- **关键亮点**：时间复杂度最优，适用于大规模数据，代码实现简洁。
- **核心代码**：
  ```cpp
  struct Node {
      int num;
      lint val;
      int isMarked;
  } a[1000005];

  scanf("%d%d", &n, &m);
  for (int i = 1; i <= n; ++i) {
      lint var;
      scanf("%lld", &var);
      a[i] = Node(i, var);
  }
  for (int i = 1; i <= m; ++i) {
      scanf("%lld", b + i);
  }
  b[m + 1] = (1ll << 60);
  b[0] = -(1ll << 60);
  sort(a + 1, a + n + 1, cmp);
  sort(b + 1, b + m + 1);
  for (int i = 1; i <= n; ++i) {
      while (b[cur] < a[i].val)
          ++cur;
      if (b[cur] == a[i].val)
          a[i].isMarked = 1;
  }
  ```

#### 2. 数组记录法（4星）
- **关键亮点**：实现简单，适用于小规模数据，代码可读性强。
- **核心代码**：
  ```cpp
  int cnt = 0;
  for (int i = 1; i <= n; ++i) {
      if (v[a[i]]) {
          if (cnt)
              ++ans;
          cnt = 0;
      } else {
          ++cnt;
      }
  }
  if (cnt)
      ++ans;
  ```

#### 3. unordered_map法（4星）
- **关键亮点**：适用于大规模数据，代码实现灵活。
- **核心代码**：
  ```cpp
  unordered_map<long long, bool> v;
  for (int i = 1; i <= m; ++i) {
      v[b[i]] = true;
  }
  for (int i = 1; i <= n; ++i) {
      if (v[a[i]]) {
          if (cnt)
              ++ans;
          cnt = 0;
      } else {
          ++cnt;
      }
  }
  if (cnt)
      ++ans;
  ```

### 最优关键思路与技巧

- **双指针法**：在a和b都排序后，使用双指针查找切割点，时间复杂度最优，适用于大规模数据。
- **数组记录法**：利用数组记录切割点，实现简单，适用于小规模数据。
- **unordered_map法**：利用哈希表记录切割点，适用于值域较大的情况。

### 可拓展之处

- **类似问题**：可以拓展到其他需要快速查找元素是否在集合中的问题，如区间查询、集合交并等。
- **算法套路**：排序+双指针、哈希表、二分查找等算法套路在解决类似问题时非常有用。

### 推荐题目

1. **P3374 【模板】树状数组 1**：考察数组记录与快速查找。
2. **P3368 【模板】线段树 1**：考察区间查询与更新。
3. **P3372 【模板】线段树 2**：考察区间修改与查询。

### 个人心得

- **调试经历**：在使用双指针法时，需要注意指针的初始位置和移动条件，避免越界或漏查。
- **踩坑教训**：在使用哈希表时，要注意哈希冲突的处理，避免性能下降。
- **顿悟感想**：排序后使用双指针查找可以大大减少时间复杂度，是一种非常高效的算法技巧。

---
处理用时：38.44秒
# 题目信息

# [语言月赛202301] 新年快乐

## 题目背景

要过春节了，扶苏收到了她的新年礼物：一个崭新的字符串。

## 题目描述

扶苏收到的字符串是一个只含小写字母的字符串 $s$。

对于一个长度为 $x$ 的只含小写字母的字符串 $t$，我们定义 $t$ 的『上一个字符串』是：将所有的长度为 $x$ 且仅含小写字母的字符串按字典序排列后，恰好排在 $t$ 之前一个的字符串。

例如，字符串 $\texttt{bcd}$ 的『上一个字符串』是 $\texttt{bcc}$，而 $\texttt{aaa}$ 的『上一个字符串』不存在。

现在，扶苏有 $q$ 次询问，每次询问给出一个区间 $[l, r]$，查询：$s$ 的第 $l$ 个到第 $r$ 个字符组成的字符串的『上一个字符串』是否在 $s$ 中出现？

如果查询区间对应的字符串不存在『上一个字符串』，也算作『上一个字符串』没有在 $s$ 中出现。

## 说明/提示

### 数据规模与约定

以下以 $|s|$ 表示输入字符串 $s$ 的长度。

| 测试点编号 | $\mid s \mid \leq$ | $q=$ | 特殊约定 |
| :-: | :-: | :-: | :-: |
| 1 | $1$ | $1$ | 无 |
| 2 | $20$ | $7$ | A,B |
| 3 | $20$ | $8$ | B |
| 4 | $20$ | $9$ | A |
| 5 | $400$ | $198$ | B |
| 6 | $400$ | $199$ | A |
| 7 | $400$ | $199$ | A |
| 8 | $400$ | $200$ | 无 |
| 9 | $400$ | $200$ | 无 |
| 10 | $400$ | $200$ | 无 |

特殊约定 A：保证查询的字符串的『上一个字符串』在 $s$ 中出现。  
特殊约定 B：保证查询的区间满足 $l = r$。

对全部的测试点，保证 $1 \leq |s| \leq 400$，$1 \leq q \leq 200$，$1 \leq l \leq r \leq |s|$，$s$ 中仅包含小写英文字母。

### 提示

你可以通过 $q$ 的末位数字来判定测试点所属的特殊约定信息。


## 样例 #1

### 输入

```
bcdbccaacbzz
5
1 3
5 8
1 1
11 12
7 7```

### 输出

```
bcc
Happy New Year!
cbzz
Happy New Year!
a
Happy New Year!
zy
Happy Chinese New Year!
NULL
Happy Chinese New Year!```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地找到给定字符串的“上一个字符串”，并判断其是否在原字符串中出现。题解中主要使用了C++的`string`类提供的`substr()`和`find()`函数，通过遍历字符串并修改字符来实现“上一个字符串”的生成。虽然题解的思路较为直接，但在数据规模较小的情况下，这种暴力方法是可以接受的。

### 所选题解

#### 题解作者：Maxmilite (赞：7)
- **星级**：4星
- **关键亮点**：
  - 使用了C++的`string`类的`substr()`和`find()`函数，代码简洁易懂。
  - 通过判断字符串是否全为`a`来快速确定是否存在“上一个字符串”，提高了效率。
  - 从后向前遍历字符串，找到第一个不为`a`的字符进行修改，减少了不必要的操作。
- **个人心得**：作者提到`find()`函数的时间复杂度为平方级别，但在本题的数据规模下可以接受，这种对时间复杂度的分析有助于理解算法的适用性。

### 核心代码片段

```cpp
int flag = 1;
for (int i = 0; i < t.length(); ++i) {
    if (t[i] != 'a') {
        flag = 0;
        break;
    }
}
if (flag) {
    cout << "NULL\nHappy Chinese New Year!\n";
}

for (int i = t.length() - 1; i >= 0; --i)
    if (t[i] == 'a') {
        t[i] = 'z';
    } else {
        --t[i];
        break;
    }

cout << t << endl;
if (s.find(t) != -1) {
    cout << "Happy New Year!\n";
} else {
    cout << "Happy Chinese New Year!\n";
}
```

### 关键思路与技巧

1. **快速判断全`a`字符串**：通过遍历字符串判断是否全为`a`，可以快速确定是否存在“上一个字符串”。
2. **从后向前修改字符**：从字符串的末尾开始遍历，找到第一个不为`a`的字符进行修改，可以减少不必要的操作。
3. **利用`find()`函数**：虽然`find()`函数的时间复杂度较高，但在数据规模较小的情况下，这种暴力方法是可行的。

### 可拓展之处

- **优化查找**：对于更大的数据规模，可以考虑使用更高效的字符串匹配算法，如KMP或哈希。
- **动态规划**：如果题目要求更复杂的字符串操作，可以考虑使用动态规划或其他高级算法。

### 推荐题目

1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)
3. [P3371 【模板】AC自动机（简单版）](https://www.luogu.com.cn/problem/P3371)

这些题目考察了字符串匹配和哈希等知识点，有助于进一步理解和应用字符串处理的相关算法。

---
处理用时：24.82秒
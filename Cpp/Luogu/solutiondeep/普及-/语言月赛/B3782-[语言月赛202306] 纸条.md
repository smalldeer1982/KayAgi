# 题目信息

# [语言月赛202306] 纸条

## 题目描述

zyl 桌上有 $n$ 张纸条（编号 $1\sim n$），他要把这些纸条按被写下的时间的前后顺序排好，但是纸条上不会有日期，zyl 需要自己判断。

zyl 可以根据纸条内容的连贯性来确定**紧跟**在一张纸条之后纸条有哪些。同时，他可以通过纸条的破损程度判断内容不连贯的纸条的时间先后顺序。显然，对于一段连贯内容的最后一张纸条，紧跟在它后面的纸条只能通过破损程度来判断。

现在，你会收到按以下规则给出的，每张纸条的信息：

首先，你会得知在这一段连贯内容中紧跟在这张纸条后面的纸条的数量 $m$。

其次，按照时间前后依次告诉你这些纸条的编号。

如果没有「连贯内容中紧跟在后面的纸条」（即在连贯内容的最后一张，$m = 0$），则会按照破损程度给出紧跟它的下一张纸条的编号，如果没有「按照破损程度紧跟它的下一张纸条」，你会得到一个 $-1$ 信号。

**如果对于这一部分理解有困难，可以参照「输入格式」及「样例组」进行理解。**

请你帮助 zyl 将纸条排序，并将这 $n$ 张纸条按时间顺序排序后的编号输出。

## 说明/提示

### 样例 1 解释

纸条 $2,1,3$ 是内容连贯的纸条，纸条 $5,4$ 是另一组内容连贯的纸条。

### 数据规模与约定

对于 $20\%$ 的数据，$n\leq 5$。  
对于 $100\%$ 的数据，$0\leq m<n\leq 2\times10^{3}$。

## 样例 #1

### 输入

```
5
1 3
2 1 3
0 5
0 -1
1 4```

### 输出

```
2 1 3 5 4```

# AI分析结果

### 综合分析与结论

本题的核心在于通过给定的纸条连贯性信息，构建一个有序的纸条序列。题解的关键思路是通过遍历和标记来确定纸条的顺序，尤其是通过 `vis` 数组来找到序列的起点，然后通过递归或迭代的方式输出整个序列。

### 所选高星题解

#### 题解1：未来姚班zyl (5星)

**关键亮点：**
- 使用 `vis` 数组来标记纸条是否被提及，从而找到序列的起点。
- 使用 `vector` 动态存储纸条的后续信息，代码简洁且高效。
- 通过递归或迭代的方式输出序列，逻辑清晰。

**个人心得：**
- 作者提到要注意防止数组越界，特别是在处理 `-1` 时，这一点在实际编程中非常重要。

**核心代码：**
```cpp
vector<int>p[2010];
bool vis[2010];

for(int i=1;i<=n;i++){
    cin >> m;
    if(m)
    for(int j=1;j<=m;j++){
        int x;
        cin >> x;
        vis[x]=1;
        p[i].push_back(x);
    }
    else {
        int x=read();
        if(x>0)vis[x]=1;
        p[i].push_back(x);
    }
}

int s;
for(int i=1;i<=n;i++)if(!vis[i])s=i;

while(1){
    if(s==-1)return 0;
    int siz=p[s].size();
    cout <<s<<" ";
    if(p[s][siz-1]==-1)return 0;
    for(int i=0;i<siz;i++)cout <<p[s][i]<<" ";
    s=p[p[s][siz-1]][0];
}
```

### 最优关键思路或技巧

1. **标记法找起点**：通过 `vis` 数组标记纸条是否被提及，从而找到序列的起点。
2. **动态存储**：使用 `vector` 动态存储纸条的后续信息，代码简洁且高效。
3. **递归或迭代输出**：通过递归或迭代的方式输出序列，逻辑清晰。

### 可拓展之处

- **类似题目**：可以拓展到其他需要构建有序序列的题目，如链表排序、图的有序遍历等。
- **优化思路**：可以考虑使用更高效的数据结构，如哈希表来优化查找过程。

### 推荐相似题目

1. **洛谷 P1003 铺地毯**：考察数组的运用和标记法。
2. **洛谷 P1019 单词接龙**：考察字符串的连贯性和序列构建。
3. **洛谷 P1020 导弹拦截**：考察序列的动态规划和有序输出。

### 个人心得总结

- **调试经历**：在处理 `-1` 时要注意数组越界问题，这一点在实际编程中非常重要。
- **踩坑教训**：在构建序列时，要确保逻辑清晰，避免遗漏某些特殊情况。
- **顿悟感想**：通过标记法找到序列的起点，可以大大简化问题的复杂度。

---
处理用时：21.01秒
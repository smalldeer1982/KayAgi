# 题目信息

# [语言月赛202306] 棋

## 题目描述

zyl 和「她」在 $n\times m$ 的格子纸上下五子棋。**「她」总是先手**。

现在你会得知以下信息：

- 格子纸的大小 $n, m$，代表棋盘共 $n$ 行 $m$ 列。
- $n$ 个仅由字符 `~`、`*`、`$` 构成的长度为 $m$ 的字符串（即 $n \times m$ 个字符）。对于第 $i$ 个字符串的第 $j$ 个字符，`~` 表示第 $i$ 行第 $j$ 列的格子是空的，`*` 表示「她」已经在这一格落下棋子，`$` 表示 zyl 已经在这一格落下棋子。

类似于五子棋的基本规则，一局棋局由「先手」开始，双方轮流落子。如果有同一行，同一列，或者同一 $45\degree$ 斜对角线有**同一方**的**连续五个**棋子，那这一方便是胜者。

现在，请你以以下方式判断当前的棋局：如果已有一方获胜，请你判断是哪一方获胜。否则，请你判断当前轮到哪一方落子。

## 说明/提示

### 样例 1 解释
在第三列有连续的五个 `*`，所以「她」获胜了。

### 数据规模与约定

对于前 $40\%$ 的数据，保证没有任何一方获胜。

对于 $100\%$ 的数据， $5\leq n,m \leq 30$，字符串仅由 `~`、`*`、`$` 组成，而且不会出现任意同一行，同一列或是同一 $45\degree$ 斜对角线上有连续 6 个或以上连续且相同的 `*` 或 `$`，并且最多只有一条连续的 $5$ 个 `*` 或 `$`。 `*` 的总数不小于 `$` 的总数，且至多比 `$` 的总数大 $1$。保证输入的字符串至少存在一个字符 `~`。






## 样例 #1

### 输入

```
5 5
~~*~$
***~~
~$*~~
~~*~$
$$*$~
```

### 输出

```
Pleasing!```

# AI分析结果

### 综合分析与结论

本题的核心在于判断五子棋棋局的胜负以及当前轮到谁落子。题解中主要涉及以下几个关键点：

1. **胜负判断**：通过枚举棋盘上的每个位置，检查其四个方向（水平、垂直、两个对角线）是否存在连续五个相同棋子。
2. **落子顺序判断**：通过统计 `*` 和 `$` 的数量，判断当前轮到谁落子。
3. **代码优化**：通过使用数组存储方向差值，减少重复代码，提高代码的可读性和简洁性。

### 所选题解

#### 题解1：未来姚班zyl (赞：6)
- **星级**：4.5星
- **关键亮点**：
  - 通过数组存储方向差值，简化了代码，提高了可读性。
  - 详细解释了如何通过枚举每个位置和方向来判断胜负。
  - 提供了清晰的代码实现，易于理解和扩展。
- **个人心得**：作者提到通过减少方向判断的数量来优化代码，避免了冗长的判断语句，使得代码更加简洁和高效。

```cpp
const int dx[4] = {0, 1, 1, -1};
const int dy[4] = {1, 0, 1, 1};

int l, r;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (c[i][j] == '~') continue;
        l += c[i][j] == '*', r += c[i][j] == '$';
        for (int k = 0; k < 4; k++) {
            int x = i, y = j;
            bool f = 1;
            for (int d = 1; d <= 4; d++) {
                x += dx[k], y += dy[k];
                if (x < 1 || y < 1 || x > n || y > m) {
                    f = 0;
                    break;
                }
                if (c[x][y] != c[i][j]) {
                    f = 0;
                    break;
                }
            }
            if (f) {
                if (c[i][j] == '*') cout << "Pleasing!";
                else cout << "zylwins!";
                return 0;
            }
        }
    }
}
if (l == r) cout << "W";
else cout << "Z";
```

### 最优关键思路或技巧

1. **方向差值数组**：通过使用 `dx` 和 `dy` 数组存储四个方向的坐标差值，简化了方向判断的代码，减少了重复代码量。
2. **枚举与判断**：通过枚举每个位置和方向，判断是否存在连续五个相同棋子，这种方法简单直观，适用于小规模数据。
3. **统计棋子数量**：通过统计 `*` 和 `$` 的数量，判断当前轮到谁落子，逻辑清晰且易于实现。

### 可拓展之处

1. **更大规模数据**：对于更大规模的棋盘，可以考虑使用更高效的算法，如滑动窗口或动态规划，来减少时间复杂度。
2. **其他棋类游戏**：类似的思路可以应用于其他棋类游戏，如围棋、象棋等，判断胜负或当前落子顺序。

### 推荐题目

1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003) - 考察二维数组的枚举与判断。
2. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042) - 考察字符串处理与胜负判断。
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - 考察回溯算法与棋盘问题的解决。

### 个人心得总结

作者通过减少方向判断的数量，优化了代码结构，使得代码更加简洁和高效。这种优化思路不仅适用于本题，也可以推广到其他类似的棋盘问题中。

---
处理用时：29.40秒
# 题目信息

# [语言月赛202306] 演唱会

## 题目描述

一个特殊的节日，zyl 举办了一场演唱会，他想要规划一下演唱会的曲目。

根据同学的要求，他要从 $n$ 首歌（编号 $1\sim n$）中选出 $m$ 首加入演唱会歌单。

选择的规则很简单，班上有 $a$ 名学生（不包括 zyl），学号为 $1\sim a$。zyl 会按照学号统计每位同学从每首歌中得到的快乐值，记为 $h_{i,j}$。一首歌的「欢乐度」是它所给予其他所有同学的「快乐值」总和。

巧妙的是，由于歌曲风格迥异，**同一个学生一定会从不同的歌中会收获不同的快乐值，且不会有任何两首歌的欢乐度相同**。

zyl 选出欢乐度最高的 $m$ 首歌，并将它们按欢乐度**从大到小**排好序。

但 zyl 注意到了她的快乐值...

无论如何，zyl 一定会把她最喜欢的歌放进歌单（她获得快乐值最高的歌即为她最喜欢的歌）！
如果她最喜欢的歌之前已经在歌单中，那么 zyl 会把这首歌提到歌单的第一个位置（即，仅将该歌曲的位置变为第一位，其余歌曲的相对位置不变）；但如果不在，zyl 则会把已经选择好的歌单里的最后一首歌给删掉。然后把她最喜欢的曲目放在歌单的最后。

现在 zyl 将统计的快乐值数据和她的学号交给你，请你帮他列出演唱会的歌单。

## 说明/提示

### 样例 1 解释
按照欢乐度排序后靠前的两道是 $3, 2$，但由于她最喜欢的歌是 $4$，不在歌单里，于是将 $2$ 从歌单里删除，之后将 $4$ 放在最后。最后的歌单为 $3, 4$。
### 数据规模与约定
对于 $100\%$ 的数据，$1\leq m \leq n \leq 10^5$，$1\leq b \leq a\leq 100$。$0\leq h_{i,j}\leq 10^6$。

| 测试点编号 | $n$ | $m$ | $a$ | $h_{i,j}$ |
| :----------: | :----------: | :----------: | :----------: |:----------:|
| $1 \sim 2$ | $\leq5$ | $=1$ | $\leq5$ |$\leq 10000$|
| $3 \sim 4$ | $\leq1000$ | $=n$ | $\leq100$ |$\leq 10000$|
| $5 \sim 6$ | $\leq 1000$ | $\leq 1000$ | $=1$ |$\leq 10000$|
| $7 \sim 9$ | $\leq1000$ | $\leq1000$ | $\leq100$ |$\leq 10000$|
| $10$ |$\leq 10^5$|$\leq 10^5$|$\leq 100$|$\leq 10^6$|

## 样例 #1

### 输入

```
4 2 3 2
2 4 3 1
1 2 3 4
2 3 4 1```

### 输出

```
3 4```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地计算每首歌的欢乐度，并按照特定规则处理“她”最喜欢的歌曲。题解中主要采用了结构体排序和简单的条件判断来处理这一需求。以下是对题解的整理与对比：

1. **思路与算法要点**：
   - **欢乐度计算**：通过累加每位同学从每首歌中获得的快乐值来计算每首歌的欢乐度。
   - **排序**：使用结构体存储歌曲的编号和欢乐度，并按欢乐度从大到小排序。
   - **特殊处理**：根据“她”最喜欢的歌曲是否在歌单中，进行相应的调整（提到首位或替换最后一首）。

2. **解决难点**：
   - **高效计算**：由于数据规模较大（$n \leq 10^5$，$a \leq 100$），需要确保输入和计算的高效性。
   - **特殊处理逻辑**：需要准确判断“她”最喜欢的歌曲是否在歌单中，并进行相应的调整。

3. **优化与改进**：
   - **输入优化**：使用格式化输入（如 `scanf`）以提高输入效率。
   - **排序优化**：使用 `sort` 函数进行快速排序，确保时间复杂度为 $O(n \log n)$。

### 所选高星题解

#### 题解1：未来姚班zyl (★★★★☆)

**关键亮点**：
- **结构体排序**：使用结构体存储歌曲的编号和欢乐度，并按欢乐度从大到小排序，代码清晰易读。
- **特殊处理逻辑**：通过标志位 `f` 判断“她”最喜欢的歌曲是否在歌单中，并进行相应的调整，逻辑清晰。
- **输入优化**：使用 `scanf` 进行格式化输入，确保输入效率。

**核心代码**：
```cpp
struct song {
    int id, k;
} h[100005];

bool cmp(song a, song b) {
    return a.k > b.k;
}

int main() {
    // 输入与欢乐度计算
    for (int i = 1; i <= a; i++) {
        for (int j = 1; j <= n; j++) {
            int x;
            scanf("%d", &x);
            h[j].k += x;
            h[j].id = j;
            if (i == b && x > k) ex = j, k = x;
        }
    }
    sort(h + 1, h + n + 1, cmp); // 排序

    // 特殊处理
    bool f = 0;
    for (int i = 1; i <= m; i++) if (ex == h[i].id) f = 1;
    if (f) {
        printf("%d ", ex);
        for (int i = 1; i <= m; i++) if (h[i].id != ex) printf("%d ", h[i].id);
    } else {
        for (int i = 1; i < m; i++) printf("%d ", h[i].id);
        printf("%d", ex);
    }
    return 0;
}
```

### 最优关键思路与技巧

1. **结构体排序**：使用结构体存储歌曲的编号和欢乐度，便于排序和后续处理。
2. **标志位判断**：通过标志位 `f` 判断“她”最喜欢的歌曲是否在歌单中，简化了逻辑处理。
3. **格式化输入**：使用 `scanf` 提高输入效率，适用于大规模数据输入。

### 可拓展之处

- **类似问题**：可以扩展到其他需要根据特定规则调整排序结果的问题，如根据用户偏好调整推荐列表。
- **算法套路**：结构体排序和标志位判断是处理类似问题的通用套路，可以举一反三。

### 推荐题目

1. **P1177 【模板】快速排序**：练习快速排序的基本实现。
2. **P1068 分数线划定**：练习结构体排序和条件判断。
3. **P1093 奖学金**：练习多条件排序和结构体使用。

### 个人心得总结

- **调试经历**：在处理“她”最喜欢的歌曲时，需要仔细检查逻辑，确保在歌单中和不在歌单中的情况都能正确处理。
- **踩坑教训**：在大规模数据输入时，使用 `cin` 可能会导致超时，改用 `scanf` 可以有效避免这一问题。
- **顿悟感想**：结构体排序和标志位判断是处理复杂排序问题的有效工具，熟练掌握这些技巧可以大大提高解题效率。

---
处理用时：36.40秒
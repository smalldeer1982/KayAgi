# 题目信息

# [语言月赛 202308] 电脑中了满屏粉兔病毒

## 题目描述

小 F 的电脑屏幕可以被划分为 $r$ 行 $c$ 列的网格，第 $i$ 行第 $j$ 列的网格，可以用 $(i,j)$ 来表示。

突然，有一天，小 F 的电脑中了「满屏粉兔」病毒，在电脑屏幕上，出现了 $N$ 只雄粉兔和 $M$ 只雌粉兔。

假设一只粉兔位于 $(i,j)$，若其沿上、下、左、右四个方向中的一个方向行动，可以在不经过「异性粉兔」的情况下离开屏幕范围，那么，这个方向对于该粉兔就是一条「逃跑通道」。

狡兔三窟。我们定义一只粉兔是「合格的粉兔」，当且仅当其至少有三条「逃跑通道」。

![](https://cdn.luogu.com.cn/upload/image_hosting/qlwtx8rv.png)

例如，如图所示，绿色方格代表雄粉兔，粉色方格代表雌粉兔。位于 $(2,2)$ 的雌粉兔，向上、下、左，都可以不经过雄粉兔的离开屏幕，共有三条「逃跑通道」因此，位于 $(2,2)$ 的粉兔是「合格的粉兔」。而位于 $(4,4)$ 的粉兔，仅有左、右两条「逃跑通道」，因此 $(4,4)$ 的粉兔不是「合格的粉兔」。

现在，给出屏幕上粉兔的分布情况，请问，一共有多少只「合格的粉兔」？

## 说明/提示

- 对于 $30\%$ 的测试数据，$1 \le r,c \le 30$；
- 对于 $100\%$ 的测试数据，$1 \le r,c \le 500$，$0 \le N,M \le r \cdot c$，$k_{i,j}$ 为 `.`、`F`、`M` 中的一个。

## 样例 #1

### 输入

```
6 5 2 3
.....
.F.M.
.....
.F.F.
...M.
.....```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

题目要求统计符合条件的粉兔数量，关键在于判断每个粉兔的四个方向是否存在逃跑通道。题解通过枚举每个粉兔的四个方向，检查路径上是否有异性粉兔，从而判断是否满足条件。整体思路清晰，但代码实现上可以进一步优化，例如通过预处理或更高效的数据结构来减少重复计算。

### 所选题解

#### 题解：览遍千秋
- **星级**：4星
- **关键亮点**：思路清晰，代码结构简单易懂，适合初学者理解。
- **核心实现思想**：通过四重循环分别检查上下左右四个方向，判断路径上是否有异性粉兔。
- **代码片段**：
  ```cpp
  for(int i = 1; i <= r; i++) {
      for(int j = 1; j <= c; j++) {
          if(grid[i][j] == 'F' || grid[i][j] == 'M') {
              int count = 0;
              // Check up
              bool valid = true;
              for(int k = i - 1; k >= 1; k--) {
                  if(grid[k][j] != '.' && grid[k][j] != grid[i][j]) {
                      valid = false;
                      break;
                  }
              }
              if(valid) count++;
              // Check down
              valid = true;
              for(int k = i + 1; k <= r; k++) {
                  if(grid[k][j] != '.' && grid[k][j] != grid[i][j]) {
                      valid = false;
                      break;
                  }
              }
              if(valid) count++;
              // Check left
              valid = true;
              for(int k = j - 1; k >= 1; k--) {
                  if(grid[i][k] != '.' && grid[i][k] != grid[i][j]) {
                      valid = false;
                      break;
                  }
              }
              if(valid) count++;
              // Check right
              valid = true;
              for(int k = j + 1; k <= c; k++) {
                  if(grid[i][k] != '.' && grid[i][k] != grid[i][j]) {
                      valid = false;
                      break;
                  }
              }
              if(valid) count++;
              if(count >= 3) ans++;
          }
      }
  }
  ```

### 最优关键思路或技巧

1. **方向枚举**：通过枚举四个方向，分别检查路径上是否有异性粉兔，思路简单直接。
2. **边界处理**：在检查每个方向时，注意边界条件，避免越界访问。
3. **优化建议**：可以通过预处理每个方向的最远可达位置，减少重复计算，提高效率。

### 可拓展之处

- **类似题目**：可以扩展到其他网格类问题，如迷宫问题、路径计数问题等。
- **数据结构**：可以使用更高效的数据结构如并查集、线段树等来优化路径检查。

### 推荐题目

1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

### 个人心得

- **调试经历**：在检查路径时，容易忽略边界条件，导致越界访问，需特别注意。
- **顿悟感想**：通过枚举四个方向，可以简化问题，但需要注意代码的重复性，尽量通过函数封装减少冗余代码。

---
处理用时：25.04秒
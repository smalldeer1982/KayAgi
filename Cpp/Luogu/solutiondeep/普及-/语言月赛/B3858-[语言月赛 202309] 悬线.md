# 题目信息

# [语言月赛 202309] 悬线

## 题目背景

我们定义一个数字是质数，当且仅当它的因子仅有 $1$ 和自身。特别的，$1$ 不是质数。

## 题目描述

给定一个 $n \times m$ 的数字阵。约定第 $i$ 行第 $j$ 列上的数用 $(i,j)$ 表示。

我们称以第 $i$ 行第 $j$ 列的格子为底的**悬线**的长度是最大的 $k$，满足 $k \leq i$ 且 $(i,j), (i-1,j), (i-2,j),\dots(i-k+1,j)$ 这 $k$ 个数都是**质数**。特别的，如果 $(i, j)$ 本身不是质数，称以第 $i$ 行第 $j$ 列为底的悬线长度为 $0$。

对于每个格子，请你求出以它为底的悬线长度。

## 说明/提示

### 数据规模与约定

- 对 $20\%$ 的数据，$n = 1$。
- 对 $50\%$ 的数据，$(i,j) \leq 100$。
- 对 $80\%$ 的数据，$(i,j) \leq 1000$。
- 对 $100\%$ 的数据，$1 \leq n, m \leq 200$，$1 \leq (i,j) \leq 10^5$，$1 \leq T \leq 15$。

## 样例 #1

### 输入

```
1
3 3
1 2 3
4 5 6
7 8 9```

### 输出

```
0 1 1
0 2 0
1 0 0```

# AI分析结果

### 综合分析与结论

本题的核心在于计算每个格子为底的悬线长度，悬线的定义是连续质数的最大长度。各题解的思路基本一致，主要分为以下几个步骤：

1. **质数判断**：通过枚举法判断每个数是否为质数，时间复杂度为 \(O(\sqrt{n})\)。
2. **悬线长度计算**：利用动态规划的思想，从上到下逐行计算每个格子的悬线长度。如果当前格子是质数，则悬线长度为上一行同列格子的悬线长度加1；否则为0。
3. **输出结果**：遍历矩阵，输出每个格子的悬线长度。

各题解的主要区别在于质数判断的优化和代码实现的简洁性。部分题解通过预处理质数表来优化质数判断，但整体思路相似。

### 所选高星题解

#### 题解1：zhang_Jimmy (4星)
**关键亮点**：
- 思路清晰，代码简洁，直接利用动态规划计算悬线长度。
- 质数判断函数实现简洁，符合题目要求。

**核心代码**：
```cpp
bool prime(int n){
    if(n == 1) return 0;
    if(n == 2) return 1;
    for(int i = 2; i <= sqrt(n); i ++)
        if(n % i == 0) return 0;
    return 1;
}

int main(){
    cin >> t;
    while(t --){
        memset(f, 0, sizeof f);
        cin >> n >> m;
        for(int i = 1; i <= n; i ++){
            for(int j = 1; j <= m; j ++){
                cin >> a[i][j];
            }
        }
        for(int i = 1; i <= n; i ++){
            for(int j = 1; j <= m; j ++){
                if(prime(a[i][j]))
                    f[i][j] = f[i - 1][j] + 1;
                else 
                    f[i][j] = 0;
            }
        }
        for(int i = 1; i <= n; i ++){
            for(int j = 1; j <= m; j ++){
                cout << f[i][j] << " ";
            }
            cout << endl;
        }
    }
    return 0;
}
```

#### 题解2：xujunlang2011 (4星)
**关键亮点**：
- 预处理质数表，优化质数判断的时间复杂度。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
bool p[100005];
int a[205][205];

inline int pri(int a){
    if (a == 1) return 0;
    for (int j = 2;j * j <= a;j++){
        if (a % j == 0) return 0;
    }
    return 1;
}

int main(){
    for (int i = 1;i <= 100000;++i){
        p[i] = pri(i);
    }
    int t;
    cin >> t;
    for (int ti = 1;ti <= t;++ti){
        int n, m, x;
        cin >> n >> m;
        for (int i = 1;i <= n;++i){
            for (int j = 1;j <= m;++j){
                cin >> x;
                a[i][j] = p[x];
            }
        }
        for (int i = 1;i <= n;++i){
            for (int j = 1;j <= m;++j){
                if (a[i][j]){
                    a[i][j] += a[i - 1][j];
                }
            }
        }
        for (int i = 1;i <= n;++i){
            for (int j = 1;j <= m;++j){
                cout << a[i][j] << " ";
            }
            cout << "\n";
        }
    }
    return 0;
}
```

### 最优关键思路与技巧

1. **动态规划**：利用动态规划的思想，从上到下逐行计算每个格子的悬线长度，时间复杂度为 \(O(nm)\)。
2. **质数判断优化**：通过预处理质数表，可以将质数判断的时间复杂度降低到 \(O(1)\)，适合大规模数据。

### 可拓展之处

- **质数判断优化**：可以使用更高效的质数判断算法，如Miller-Rabin素性测试，适用于更大范围的质数判断。
- **动态规划应用**：类似的动态规划思想可以应用于其他连续性问题，如最长连续递增子序列等。

### 推荐题目

1. **P3383 【模板】线性筛素数**：考察质数筛法，适合练习质数判断的优化。
2. **P1219 [USACO1.5]八皇后 Checker Challenge**：考察回溯算法，适合练习动态规划与回溯的结合。
3. **P1048 采药**：考察动态规划，适合练习动态规划的基本应用。

### 个人心得总结

- **调试经历**：在实现过程中，需要注意边界条件的处理，如第一行的悬线长度计算。
- **踩坑教训**：质数判断时，1不是质数，需要特判。
- **顿悟感想**：动态规划的思想在处理连续性问题时非常有效，能够大大降低时间复杂度。

---
处理用时：41.82秒
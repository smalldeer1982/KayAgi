# 题目信息

# [语言月赛 202402] 数字串

## 题目描述

bj12z_jiasiyuan 有 $n + 1$ 个长度为无穷大的序列，其中这些序列有如下的规律：

- 第 $1$ 个序列为 $\texttt{11111111111111\dots}$，即开头为 $1$，相邻的 $1$ 间隔的距离为 $0$。
- 第 $2$ 个序列为 $\texttt{10101010101010\dots}$，即开头为 $1$，相邻的 $1$ 间隔的距离为 $1$。
- 第 $3$ 个序列为 $\texttt{10010010010010\dots}$，即开头为 $1$，相邻的 $1$ 间隔的距离为 $2$。
- $\cdots$
- 第 $n + 1$ 个序列开头为 $1$，相邻的 $1$ 间隔的距离为 $n$。

同时，bj12z_jiasiyuan 给予你一个长度为 $m$ 的 $01$ 数字串 $s$，请你判断这个数字串是否可能是从以上 $n + 1$ 个序列中的某一个序列中截取出来的。

bj12z_jiasiyuan 会询问你很多次，每一次都会给予你一组新的 $n, m, s$。请你帮助回答这些询问。

## 说明/提示

### 数据规模与约定

- 对于 $30\%$ 的数据，$t = 1$，$1 \leq n \leq 10$，$1 \leq m \leq 10$；  
- 对于 $50\%$ 的数据，$1 \leq t \leq 20$，$1 \leq n \leq 10^3$，$1 \leq m \leq 10^3$； 
- 对于 $100\%$ 的数据，$1 \leq t \leq 20$，$1 \leq n  \leq 10^5$，$1 \leq m \leq 10^5$。

## 样例 #1

### 输入

```
1
5 5 10010
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
1
5 12 000001000010
```

### 输出

```
No
```

# AI分析结果

### 综合分析与结论

本题的核心在于判断给定的01串是否可以从某个特定规律的无限序列中截取出来。题解的关键思路是通过分析串中1的位置，判断相邻1之间的距离是否一致且不超过给定的n。题解通过分支结构处理了不同情况（无1、单1、多1），并逐一验证了前缀和后缀的0的数量是否合法。

### 所选题解

#### 题解作者：icypenguin
- **星级：4星**
- **关键亮点：**
  - 思路清晰，通过分支结构处理了不同情况，逻辑严谨。
  - 代码可读性较好，变量命名合理，结构清晰。
  - 对边界条件的处理较为全面，如无1、单1、多1的情况都进行了详细讨论。
- **核心实现思想：**
  - 通过遍历串，记录所有1的位置。
  - 根据1的数量和位置，判断相邻1之间的距离是否一致且不超过n。
  - 对前缀和后缀的0的数量进行验证，确保其合法性。

```cpp
cin >> t;
while (t--){
    long long n, m;
    cin >> n >> m;
    ll cnt = 0;
    for (long long i = 1; i <= m; i++){
        char c;
        cin >> c;
        a[i] = c - '0';
        if (a[i] == 1){
            w[++cnt] = i;
        }
    }
    if (cnt == 0){
        if (m > n){
            cout << "No" << endl;
        }else{
            cout << "Yes" << endl;
        }
        continue;
    }
    if (cnt == 1){
        if (w[1] - 1 > n || (m - w[1] > n)){
            cout << "No" << endl;
        }else{
            cout << "Yes" << endl;
        }
        continue;
    }
    ll len = w[2] - w[1] - 1;
    if (len > n){
        cout << "No" << endl;
        continue;
    }
    if (w[1] - 1 > len){
        cout << "No" << endl;
        continue;
    }
    bool flg = true;
    for (long long i = 3; i <= cnt; i++){
        if (w[i] - w[i - 1] - 1 != len){
            cout << "No" << endl;
            flg = false;
            break;
        }
    }
    if (!flg){
        continue;
    }
    if (m - w[cnt] > len){
        cout << "No" << endl;
        continue;
    }
    if (flg){
        cout << "Yes" << endl;
    }
}
```

### 最优关键思路或技巧

1. **记录1的位置**：通过遍历串，记录所有1的位置，便于后续计算相邻1之间的距离。
2. **分支处理不同情况**：根据1的数量（无1、单1、多1）进行不同的判断，确保每种情况都能被正确处理。
3. **验证前缀和后缀的0的数量**：确保前缀和后缀的0的数量不超过相邻1之间的距离，保证串的合法性。

### 可拓展之处

- **类似题目**：可以扩展到其他类似的字符串匹配问题，如判断一个串是否可以从某个特定规律的无限序列中截取出来。
- **算法套路**：通过记录关键字符的位置，进行距离和数量的验证，是一种常见的字符串处理套路。

### 推荐题目

1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3376 【模板】AC自动机（简单版）](https://www.luogu.com.cn/problem/P3376)
3. [P3377 【模板】Manacher算法](https://www.luogu.com.cn/problem/P3377)

### 个人心得

- **调试经历**：在处理多1的情况时，需要特别注意相邻1之间的距离是否一致，避免遗漏某些边界条件。
- **踩坑教训**：在判断前缀和后缀的0的数量时，容易忽略某些特殊情况，如串的开头或结尾没有0的情况。
- **顿悟感想**：通过记录1的位置，可以简化问题的复杂度，使得判断过程更加直观和高效。

---
处理用时：32.56秒
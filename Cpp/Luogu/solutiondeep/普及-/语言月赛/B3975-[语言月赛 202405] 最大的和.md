# 题目信息

# [语言月赛 202405] 最大的和

## 题目描述

小 S 喜欢连在一起的数字，如果这些数字的和很大就更好了。

所以她现在要给你一个 $n$ 行 $n$ 列的网格 $A$，第 $i$ 行第 $j$ 列上填有一个**整数** $A_{i, j}$。

接下来你可以在 $A$ 上任取**一行**、**一列**或**一条与任意对角线平行**且**只经过网格交叉点**的**直线**（注意，不是线段），满足经过至少一个数字，且经过的数字之和最大。

如果对上面的表述有疑惑，请参考**样例解释**辅助理解。

你需要告诉小 S 这个最大的数字之和。

## 说明/提示

### 样例 1 解释

对于样例 $1$，不难看出第 $3$ 行数字之和最大，有 $3 + 3 + 3 = 9$。

### 样例 2 解释

对于样例 $2$，数字之和最大的，满足条件的线如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/3srzjj2n.png?x-oss-process=image)

此时有 $4 + 9 = 13$。

注意，因为要求与对角线平行的直线只能经过**网格交点**，所以并不能出现同时取 $4, 1, 9$ 或同时取 $4, 1, 9, 2$ 这样的情况。

### 样例 $3$ 解释

取某条只经过一个 $-1$ 的直线即为最大。注意，不可以一个数字都不选。

### 样例 $4$ 解释

显然，取斜着的线一定不优，只能选择中间那一行或一列，答案是 $-10 + 99999 - 10 = 99979$。

### 数据范围

对于前 $30 \%$ 的数据，保证 $A_{1, 1}$ 或 $A_{n, n}$ 的值为网格中**唯一的**非负整数。  
对于另 $20 \%$ 的数据，保证**每一行**数字相同，且最后一行中的数字之和为**最大值**。  
对于另 $20 \%$ 的数据，保证**每一行**数字相同，网格中不存在负数。  
对于 $100 \%$ 的数据，保证 $1 \leq n \leq 2 \times 10^3, -10^5 \leq A_{i, j} \leq 10^5$。

## 样例 #1

### 输入

```
3
1 1 1
2 2 2
3 3 3
```

### 输出

```
9
```

## 样例 #2

### 输入

```
3
-1 1 2
4 0 3
1 9 2
```

### 输出

```
13
```

## 样例 #3

### 输入

```
3
-1 -1 -1
-1 -1 -1
-1 -1 -1
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
3
-100 -10 -100
-10 99999 -10
-100 -10 -100
```

### 输出

```
99979
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地计算网格中行、列、以及对角线平行直线上的数字之和，并找出其中的最大值。题解中提供了详细的思路和实现方法，涵盖了行、列、以及对角线平行直线的计算方式。整体思路清晰，代码实现也较为简洁，但在对角线平行直线的计算上，部分题解可能存在边界条件处理不够严谨的问题。

### 所选高星题解

#### 题解1：ShiRoZeTsu (5星)

**关键亮点：**
- 详细解释了行、列、以及对角线平行直线的计算方法。
- 提供了清晰的图示和数学推导，帮助理解对角线平行直线的计算方式。
- 代码实现简洁，且考虑了边界条件。

**个人心得：**
- 通过图示和数学推导，帮助理解对角线平行直线的计算方式，避免了复杂的边界条件处理。

**核心代码：**

```cpp
long long res, ans = -1e18;

// 计算行的和
for(int i = 1; i <= n; i++) {
    res = 0;
    for(int j = 1; j <= n; j++)
        res += a[i][j];
    ans = max(ans, res);
}

// 计算列的和
for(int i = 1; i <= n; i++) {
    res = 0;
    for(int j = 1; j <= n; j++)
        res += a[j][i];
    ans = max(ans, res);
}

// 计算从左上到右下的斜线和
for(int i = 1-n; i <= n-1; i++) {
    res = 0;
    for(int j = 1; j <= n; j++)
        if(1 <= j-i && j-i <= n) res += a[j][j-i];
    ans = max(ans, res);
}

// 计算从右上到左下的斜线和
for(int i = 2; i <= n+n; i++) {
    res = 0;
    for(int j = 1; j <= n; j++)
        if(1 <= i-j && i-j <= n) res += a[j][i-j];
    ans = max(ans, res);
}

cout << ans << '\n';
```

### 最优关键思路与技巧

1. **对角线平行直线的计算**：通过数学推导，发现与对角线平行的直线可以通过行数与列数的差或和来唯一确定，从而简化了计算过程。
2. **边界条件处理**：在计算对角线平行直线时，需要确保行数和列数在有效范围内，避免数组越界。
3. **代码优化**：使用`long long`类型存储结果，避免溢出问题，同时初始化`ans`为一个极小的负数，确保能够正确更新最大值。

### 可拓展之处

- **类似算法套路**：在处理网格或矩阵问题时，常常需要计算行、列、对角线等特定路径上的和或积，类似的思路可以应用于其他矩阵相关的问题。
- **同类型题目**：可以尝试解决其他涉及矩阵路径求和或求积的问题，如最大子矩阵和、矩阵路径最小值等。

### 推荐题目

1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1434 滑雪](https://www.luogu.com.cn/problem/P1434)

---
处理用时：26.75秒
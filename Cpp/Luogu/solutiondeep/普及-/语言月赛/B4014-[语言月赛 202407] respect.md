# 题目信息

# [语言月赛 202407] respect

## 题目背景

从前有个荣光的王国，小 A 是里面的国王，他认为人活着要有尊严，今天他要赐予他的子民以尊严。

## 题目描述

小 A 认为，当一个人被尊重时，他便是有尊严的。

现在小 A 对小 B 说了 $n$ 句话，每句话可以被视作为不含空格且全是小写字母的字符串。

每句话是由若干个单词构成的。虽然我们把这些单词直接拼接成了字符串，但是句子的语义还是和单词本身相关。对于一个字符串 $s$，我们会给出一个划分序列 $p_1, p_2, \dots, p_k$，满足 $1 \leq p_1 \leq p_2 \leq \dots \leq p_k <|s|$，则我们认为 $s$ 这句话中，$[1, p_1], [p_1+1,p_2], [p_2+1,p_3],\dots [p_k + 1, |s|]$ 这 $k+1$ 段每一段都是一个单词。特别的，如果 $k=0$，说明这个句子本身就是一个单词。

例如，对字符串 $\texttt{irespectyou}$，如果给出的序列 $p$ 为 $1,8$ 则这个字符串有 $\texttt{i}$，$\texttt{respect}$，$\texttt{you}$ 三个单词；如果序列 $p$ 为 $2, 5,7$，则这个字符串有 $\texttt{ir}$，$\texttt{esp}$，$\texttt{ec}$，$\texttt{tyou}$ 四个单词构成。

对于一个字符串 $x$，我们称一个字符串 $y$ 是 $x$ 的子串，当且仅当将 $x$ 在开头和结尾删去若干个（可以为 $0$ 个）字符后得到的字符串和 $y$ 相等。例如 $\texttt{uog}$ 是 $\texttt{luogu}$ 的子串，但 $\texttt{ug}$ 不是 $\texttt{luogu}$ 的子串。

现在，给出这 $n$ 句话，对于每句话，你要求出这句话里有多少个单词含有子串 $\texttt{respect}$。


## 说明/提示

### 数据规模与约定

- 对于 $30\%$ 的数据，划分出的子串的长度 $\leq 7$。  
- 对于 $60\%$ 的数据，不存在一个单词不是 $\texttt{respect}$ 且以 $\texttt{respect}$ 为子串。  
- 对于 $100\%$ 的数据，$1 \leq n \leq 10^3$，$1 \leq p_1 \leq p_2 \leq \dots \leq p_k < |s|$，$k \geq 0$，输入字符串仅含有小写英文字母，字符串长度不超过 $10^3$。 

## 样例 #1

### 输入

```
2
irespectyou
2
1 8
herespectsyou
2
2 10
```

### 输出

```
1
1
```

## 样例 #2

### 输入

```
1
respect
0

```

### 输出

```
1
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何根据给定的划分序列将字符串分割成多个单词，并统计每个单词中是否包含子串 `"respect"`。题解的关键点在于如何高效地进行字符串分割和子串查找。大多数题解都使用了 `s.substr()` 和 `s.find()` 这两个函数来实现分割和查找，这是较为直接且易于理解的方法。

### 所选题解

#### 题解1：I_am_rubbish
- **星级**：4星
- **关键亮点**：清晰地解释了如何利用 `s.substr()` 和 `s.find()` 进行字符串分割和子串查找，代码简洁且易于理解。
- **个人心得**：作者提到要注意多测时的变量清空，这是一个容易被忽视的细节，有助于避免潜在的 bug。

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    int n;
    cin >> n;
    while (n--) {
        string s;
        cin >> s;
        int k;
        cin >> k;
        int a[k + 2];
        a[0] = 0;
        for (int i = 1; i <= k; i++) {
            cin >> a[i];
        }
        a[k + 1] = s.length();
        int cnt = 0;
        for (int i = 0; i <= k; i++) {
            string sub = s.substr(a[i], a[i + 1] - a[i]);
            if (sub.find("respect") != string::npos) {
                cnt++;
            }
        }
        cout << cnt << endl;
    }
    return 0;
}
```

### 最优关键思路或技巧

1. **字符串分割**：使用 `s.substr()` 函数根据给定的划分序列将字符串分割成多个单词。
2. **子串查找**：使用 `s.find()` 函数在分割后的单词中查找子串 `"respect"`。
3. **多测清空**：在处理多组测试数据时，及时清空变量以避免数据污染。

### 可拓展之处

- **类似题目**：可以拓展到其他需要字符串分割和子串查找的题目，如统计特定模式的单词数量等。
- **优化思路**：对于更长的字符串或更复杂的划分规则，可以考虑使用更高效的字符串匹配算法，如 KMP 或 Boyer-Moore 算法。

### 推荐题目

1. **P3375 【模板】KMP字符串匹配**：考察 KMP 算法的实现与应用。
2. **P1308 统计单词数**：统计特定单词在文本中的出现次数。
3. **P1012 拼数**：考察字符串拼接与排序的结合应用。

### 个人心得总结

- **调试经历**：在处理多组测试数据时，变量清空是一个容易被忽视的细节，需要特别注意。
- **踩坑教训**：在字符串分割时，确保划分序列的正确性，避免越界或遗漏。
- **顿悟感想**：使用标准库函数可以大大简化代码实现，提高代码的可读性和可维护性。

---
处理用时：22.80秒
# 题目信息

# [语言月赛 202410] 断章取义

## 题目描述

本题中，字符串下标从 $1$ 开始。称 $|S|$ 为字符串 $S$ 的长度（字符个数）。

字符串 $S$ 的一个**子串**是选取一对 $1\le l\le r\le |S|$，然后将 $S_l,S_{l+1},\ldots, S_r$ 拼接得到的字符串，记为 $S[l\ldots r]$。例如，若字符串 $S$ 是 `yummy`，那么 $S[2\ldots 4]$ 是 `umm`。

------

小 L 说了一个字符串 $S$，其中包含大写或小写字母。

小 X 把这个字符串录成了视频，但是为了保证视频内容积极向上，她要对视频进行剪辑，使其不包含否定词 `not`。具体地，每一轮剪辑找到 $S$ 中所有子串 `not`，去掉这些子串，把剩下内容拼在一起；然后检查新子串是否含有 `not`，如有，则再剪辑一轮，直到没有 `not` 为止。

例如，`IcannototnAKIOI` 经过第一轮剪辑会变成 `IcanotnAKIOI`（剪掉 $S[5\ldots 7]$），第二轮剪辑会变成 `IcanAKIOI`（剪掉 $S[4\ldots 6]$），剪辑了两轮。

给出字符串 $S$，请先输出剪辑后的结果，然后输出剪辑轮数。

## 说明/提示

【样例 1 解释】

该样例即为题目所描述的情形。

【样例 2 解释】

`nnototnononotttNOT` 在第一轮剪辑后，变成了 `notnonottNOT`。

第二轮剪辑后，变成了 `notNOT`。

第三轮剪辑后，变成了 `NOT`。

【样例 3 解释】

注意，哪怕剪辑完了啥也不剩，也要输出一个换行。

【数据范围】

本题共有 $10$ 个测试点。

- 测试点 $1$ 保证剪辑轮数为 $0$。
- 测试点 $2,3$ 保证剪辑轮数为 $1$。
- 测试点 $4,5,6$ 保证剪辑轮数为 $8$。（提示：如果你会求一般情况下的剪辑结果，但不会计算剪辑轮数，可以拿这些部分分。）

对于全部测试点，保证 $S$ 非空且仅含大写或小写字母，同时长度不超过 $100$。

## 样例 #1

### 输入

```
0
IcannototnAKIOI```

### 输出

```
IcanAKIOI
2
```

## 样例 #2

### 输入

```
0
nnototnononotttNOT```

### 输出

```
NOT
3
```

## 样例 #3

### 输入

```
0
not
```

### 输出

```

1
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何处理字符串中的子串删除，特别是连续删除多个子串的情况。两个题解都提到了使用`find`和`erase`函数来处理字符串，但在具体实现上有所不同。陈嘉逸2012的题解通过循环遍历字符串，每次删除一个`not`子串，并注意了循环变量的控制，避免了漏删的情况。yummy的题解则使用了二重循环，外层循环控制删除轮数，内层循环进行一轮删除，并通过`flag`变量判断是否结束删除。

### 所选高星题解

#### 1. 陈嘉逸2012 (4星)
**关键亮点**：
- 详细解释了`find`和`erase`函数的使用。
- 强调了循环变量控制的重要性，避免了漏删的情况。
- 提供了对`s.size()`强制转整的建议，避免了潜在的溢出问题。

**个人心得**：
- 提到“搞了半天！~可能对别的大佬来说很简单！~”，体现了调试过程中的挫折感和最终解决问题的成就感。

**核心代码**：
```cpp
while(s.find("not")!=string::npos){
	for(int i=0;i<(int)s.size()-2;){
		if(s.substr(i,3)=="not") s.erase(i,3);
		else i++;
	}
	c++;
}
```
**实现思想**：
- 外层循环使用`find`函数检查字符串中是否还有`not`子串。
- 内层循环遍历字符串，使用`substr`和`erase`函数删除`not`子串，并控制循环变量`i`的递增。

#### 2. yummy (4星)
**关键亮点**：
- 使用二重循环，外层循环控制删除轮数，内层循环进行一轮删除。
- 通过`flag`变量判断是否结束删除，简化了逻辑。
- 强调了删除后循环变量的控制，避免了漏删的情况。

**核心代码**：
```cpp
while(true){
	bool flag = false;
	for(int i=0;i<(int)s.size()-2;i++){
		if(s[i]=='n' && s[i+1]=='o' && s[i+2]=='t'){
			s.erase(i,3);
			flag = true;
			i--;
		}
	}
	if(!flag) break;
	c++;
}
```
**实现思想**：
- 外层循环使用`flag`变量判断是否还有`not`子串需要删除。
- 内层循环遍历字符串，使用`erase`函数删除`not`子串，并通过`i--`控制循环变量。

### 最优关键思路或技巧

- **循环变量控制**：在删除子串后，需要特别注意循环变量的控制，避免漏删或越界。
- **强制类型转换**：在处理字符串长度时，建议将`s.size()`强制转换为`int`，避免潜在的溢出问题。
- **二重循环**：使用二重循环可以更清晰地控制删除轮数和每轮的删除操作。

### 可拓展之处

- **类似题目**：可以扩展到处理其他子串删除问题，如删除多个不同的子串或处理更复杂的字符串操作。
- **算法优化**：可以考虑使用更高效的字符串匹配算法，如KMP算法，来优化子串查找和删除的效率。

### 推荐洛谷题目

1. **P3375 【模板】KMP字符串匹配** - 考察字符串匹配算法。
2. **P1308 统计单词数** - 考察字符串查找和统计。
3. **P1042 乒乓球** - 考察字符串处理和模拟。

### 总结

通过本题的学习，可以掌握字符串处理中的子串删除技巧，特别是循环变量的控制和类型转换的重要性。这些技巧在处理类似问题时非常有用，建议在实际编程中多加练习和应用。

---
处理用时：31.35秒
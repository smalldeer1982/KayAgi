# 题目信息

# [语言月赛 202411] Enemy

## 题目描述

$A$ 城和 $B$ 城在城市中激战，战场可以被视为一个 $n$ 行 $m$ 列的方阵。方阵中的每个方格中的信息为如下可能中的一个：

- `#`，代表空地。
- `A`，表示一位 $A$ 城的士兵。
- `B`，表示一位 $B$ 城的士兵。
- `H`，表示城墙。

方阵中行从上到下依次编号为 $1\sim n$，列从左到右依次编号为 $1\sim m$。

$A$ 城位于左侧，$B$ 城位于右侧。故对于**每一行**，$A$ 城的士兵全部位于 $B$ 城士兵的左侧。

对于每一行，城墙只可能出现在 $A$ 城士兵与 $B$ 城士兵的中间，即城墙的左侧只可能有 $A$ 城士兵，城墙的右侧只可能有 $B$ 城士兵。且，同一行最多有 $1$ 个方格是城墙。

激战开始，士兵们会根据地形指定战略。对于**每一行**：

- 如果该行有城墙，则士兵们会往自己城市方向后撤，在边界处整齐地排列。例如，若这一行初始时为 `#A#AH#B#`，则后撤后这一行变为 `AA##H##B`。
- 否则，双方会进攻。对于人数较少的一方，士兵会全部倒下，从战场中消失。而另一方不会有士兵倒下，并且会冲至对方城市的方向，在边界处整齐地排列。例如，若这一行初始时为 `#A##B#B#`，则进攻后这一行变为 `BB######`。特别地，如果这一行双方人数相等，则这一行所有士兵都会倒下。

随后激战结束。对于每个士兵会**同时**进行如下判断：
- 如果他的上方或下方有友方的士兵与他相邻，则他会从战场中消失，否则原地不动。

现在给你初始时的战场局面，请你输出最后战场的组成。

## 说明/提示

### 样例 #1 解释

激战结束后，战场的情况为

```cpp
AA##H##B
BB######
########
#####AAA
####AAAA
```

右下角的 `A` 中，除了第 $5$ 行第 $5$ 列的 `A` 以外，下方或者上方都存在友方的士兵，故他们最终从战场中消失。最后战场如样例输出所示。
### 样例 #2 解释

注意只有在上方或下方有**相邻**的友方士兵时士兵才会从战场消失。
### 数据范围

对于所有数据，$1\le n,m\le 1000$，$s_{i,j}$ 为 `A`、`B`、`H`、`#` 中的一个，且每一行满足题目中的限制。具体测试点限制如下：

| 测试点编号 | $n$ 的范围 | $m$ 的范围 | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1\sim 3$ | $n=1$ | $m\le100$ | 无 |
| $4\sim 6$ | $n\le100$ | $m=1$ | 无 |
| $7\sim 10$ | $n\le 100$ | $m\le100$ | $s_{i,j}$ 不为 `H` |
| $11\sim 14$ | $n\le 100$ | $m\le100$ | $s_{i,j}$ 不为 `B`|
| $15,16$ | $n\le100$ | $m\le 100$ | 无 |
| $17\sim 20$ | $n\le 1000$ | $m\le1000$ | 无 |


## 样例 #1

### 输入

```
5 8
#A#AH#B#
#A##B#B#
##AA##BB
AAA###BB
AAA#ABBB
```

### 输出

```
AA##H##B
BB######
########
########
####A###
```

## 样例 #2

### 输入

```
3 2
#A
##
#A
```

### 输出

```
#A
##
#A
```

## 样例 #3

### 输入

```
3 3
AAB
A#B
ABB
```

### 输出

```
#AA
###
BB#
```

# AI分析结果

### 综合分析与结论

本题的核心在于模拟战场的变化过程，分为两个主要阶段：激战阶段和士兵消失阶段。激战阶段需要对每一行进行判断，根据是否有城墙以及双方士兵的数量来决定士兵的移动和消失。士兵消失阶段则需要判断每个士兵的上下是否有友方士兵，决定其是否消失。

题解的关键在于如何高效地模拟这两个阶段，并正确处理边界条件。代码的实现细节较多，尤其是对字符数组的操作和边界条件的处理需要特别注意。

### 所选题解

#### 题解1：未来姚班zyl (★★★★★)

**关键亮点：**
1. **思路清晰**：明确分为激战和士兵消失两个阶段，逻辑清晰。
2. **代码可读性高**：使用变量名清晰，代码结构简洁，易于理解。
3. **优化程度高**：通过一次遍历统计每行的 `A`、`B`、`H` 的数量，避免了重复计算。

**核心实现思想：**
1. **激战阶段**：根据每行的 `A`、`B`、`H` 的数量，决定士兵的移动和消失。
2. **士兵消失阶段**：遍历每个士兵，判断其上下是否有友方士兵，决定是否消失。

**核心代码片段：**
```cpp
for(int i=1;i<=n;i++){
    int ca=0,cb=0,ch=0;
    for(int j=1;j<=m;j++){
        if(c[i][j]=='A')ca++;
        else if(c[i][j]=='B')cb++;
        else if(c[i][j]=='H')ch++;
    }
    if(ch){
        for(int j=1;j<=m;j++)if(c[i][j]!='H')c[i][j]='#';
        for(int j=1;j<=ca;j++)c[i][j]='A';
        for(int j=m-cb+1;j<=m;j++)c[i][j]='B';
    }else {
        if(ca==cb)for(int j=1;j<=m;j++)c[i][j]='#';
        else if(ca>cb){
            for(int j=1;j<=m;j++)c[i][j]='#';
            for(int j=m-ca+1;j<=m;j++)c[i][j]='A';
        }else {
            for(int j=1;j<=m;j++)c[i][j]='#';
            for(int j=1;j<=cb;j++)c[i][j]='B';
        }
    }
}
```

### 最优关键思路或技巧

1. **分阶段处理**：将问题分解为激战和士兵消失两个阶段，简化了问题的复杂度。
2. **统计与更新分离**：先统计每行的 `A`、`B`、`H` 的数量，再根据统计结果更新字符数组，避免了重复计算。
3. **边界条件处理**：在处理士兵消失时，注意数组的边界条件，避免越界访问。

### 可拓展之处

1. **类似模拟题**：可以扩展到其他类似的模拟题，如棋盘游戏、地图移动等。
2. **优化技巧**：在处理大规模数据时，可以考虑使用更高效的数据结构或算法，如并行计算、预处理等。

### 推荐题目

1. **P1003 铺地毯**：考察二维数组的模拟和处理。
2. **P1042 乒乓球**：考察字符串处理和模拟。
3. **P1056 排座椅**：考察贪心算法和模拟。

### 个人心得

**调试经历**：在处理士兵消失阶段时，最初忽略了边界条件，导致数组越界。通过仔细检查代码，发现并修复了这一问题。

**顿悟感想**：将问题分解为多个阶段，每个阶段独立处理，可以大大简化问题的复杂度，提高代码的可读性和可维护性。

---
处理用时：31.71秒
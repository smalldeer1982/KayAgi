# 题目信息

# [语言月赛 202412] 顽强拼搏奖的四种发法

## 题目描述

在 XCPC 竞赛里，会有若干道题目，一支队伍可以对每道题目提交若干次。我们称一支队伍对一道题目的一次提交是有效的，当且仅当：

- 在本次提交以前，还未通过该题目。
- 本次提交的题目在比赛里最终被该队伍通过了。

注意，事实上，在通过一道题目后，一支队伍仍然可以提交该题目。这样的提交是**无效提交**，同时，无论这样的提交是否通过，都不会影响该队伍**已通过**该题目的状态。

我们按顺序给出本场比赛所有队伍的全部提交记录，每条记录是一个三元组 $(tid_i, pid_i, state_i)$，其中 $tid_i$ 表示提交这条记录的队伍编号，$pid_i$ 表示这条记录所提交的题目编号，$state_i$ 表示这条记录的状态是未通过/通过。

如果一支队伍在比赛里通过了至少 $k$ 道不同的题目，则它们获得了奖牌。

你要求出本场比赛的**顽强拼搏奖**归属于哪支队伍。很遗憾的是，每个主办方对顽强拼搏奖的定义是不同的，因此你需要按如下四种计算方法分别计算获得顽强拼搏奖所归属的队伍编号：

1. 最后一次 AC 记录所对应的队伍。
2. 最后一次**有效** AC 记录所对应的队伍。
3. 未获得奖牌的队伍的最后一次**有效** AC 提交对应的队伍。
4. 最后一次使得一支队伍的通过题目数由 $0$ 变成 $1$ 的提交所对应的队伍。


## 说明/提示

### 样例 1 解释

这个样例共有 $4$ 支队伍，两道题目。解出两道题目的队伍可以获奖。

- 整场比赛的最后一次 AC 提交是第八条记录，$1$ 号队伍提交第二题通过。因此第一种定义计算出的顽强拼搏奖是队伍 $1$；  
- 队伍 $1$ 在第二条记录时就已通过第二题，所以第八条记录不是一条有效提交记录。最后一条 AC 的有效提交记录是第七条。因此第二种定义计算出的顽强拼搏奖是队伍 $2$；  
- 只有队伍 $3$ 没有获奖，它们的最后一次提交是第四条记录，因此按第三种定义计算的顽强拼搏奖是队伍 $3$；  
- 队伍 $4$ 是最后一个通过题目数由 $0$ 题变为 $1$ 题的队伍。其对应的提交记录是第五条。因此按第四种定义计算的顽强拼搏奖是队伍 $4$。

### 数据规模与约定

| 测试点编号 | $n$ | $t$ | $p$ | 特殊约定 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $=1$ | $=1$ | $=1$ | 无 |
| $2,3$ | $\leq 100$ | $=1$ | $\leq 100$ | 无 |
| $4,5$ | $\leq 100$ | $\leq 100$ | $=1$ | 无 |
| $6,7$ | $\leq 1000$ | $\leq 100$ | $\leq 100$ | 一支队伍只会通过一道题至多一次 |
| $8,9,10$ | $\leq 1000$ | $\leq 100$ | $\leq 100$ | 无 |

对全部的测试数据，保证 $1 \leq n \leq 1000$，$1 \leq tid_i \leq t \leq 100$，$1 \leq pid_i \leq p \leq 100$，$1 \leq k \leq p$，$0 \leq state_i \leq 1$。

## 样例 #1

### 输入

```
8 4 2 2
1 1 1
1 2 1
2 2 1
3 1 1
4 1 1
4 2 1
2 1 1
1 2 1```

### 输出

```
1 2 3 4```

# AI分析结果

### 综合分析与结论

本题的核心在于根据四种不同的规则，从提交记录中筛选出符合条件的队伍。难点在于如何高效地处理大量提交记录，并在遍历过程中维护队伍的状态（如通过题目数、是否获奖等）。题解中的主要思路是通过二维数组记录提交信息和队伍状态，然后遍历提交记录，逐步更新四种规则下的顽强拼搏奖归属。

### 所选题解

#### 题解作者：一扶苏一 (评分：4星)

**关键亮点：**
1. **清晰的逻辑结构**：题解将问题分解为读入、获奖判定和顽强拼搏奖判定三个步骤，逻辑清晰，易于理解。
2. **高效的数组使用**：通过二维数组 `pass` 和 `passed` 记录队伍通过题目的情况，避免了重复计算，提高了效率。
3. **代码可读性**：代码结构清晰，变量命名合理，注释详细，便于阅读和调试。

**核心实现思想：**
1. **读入提交记录**：使用二维数组 `record` 存储所有提交记录，同时更新 `pass` 数组记录队伍通过题目的情况。
2. **获奖判定**：通过遍历 `pass` 数组，统计每支队伍通过的题目数，确定是否获奖。
3. **顽强拼搏奖判定**：重新遍历提交记录，根据四种规则更新顽强拼搏奖的归属。

**核心代码片段：**
```cpp
int a = -1, b = -1, c = -1, d = -1;
for (int i = 1; i <= n; ++i) {
  int tid = record[i][0], pid = record[i][1], state = record[i][2];
  if (state == 1) {
    a = tid;
    if (!passed[tid][pid]) {
      b = tid;
      if (!win[tid]) c = tid;
      int curpassed = 0;
      for (int j = 1; j <= p; ++j) curpassed += pass[tid][j];
      if (curpassed == 0) {
        d = tid;
      }
    }
    passed[tid][pid] = 1;
  }
}
```

### 通用建议与扩展思路

1. **数据结构优化**：在处理大量数据时，可以考虑使用更高效的数据结构（如哈希表）来记录队伍状态，减少时间复杂度。
2. **并行处理**：如果提交记录非常多，可以考虑将数据分块处理，利用多线程或并行计算提高效率。
3. **代码复用**：在实现类似题目时，可以将通用的逻辑（如读入、状态更新）封装成函数，提高代码的复用性和可维护性。

### 推荐洛谷题目

1. **P1003 铺地毯**：考察二维数组的使用和遍历，与本题中记录提交信息的方式类似。
2. **P1047 校门外的树**：涉及区间处理和状态更新，与本题中维护队伍状态的方式相似。
3. **P1056 排座椅**：考察排序和筛选，与本题中根据规则筛选队伍的思路一致。

### 个人心得总结

在调试过程中，发现维护队伍状态时容易遗漏某些条件（如无效提交的处理），因此在编写代码时需要仔细考虑所有可能的边界情况。通过逐步分解问题，可以有效减少错误的发生。

---
处理用时：26.47秒
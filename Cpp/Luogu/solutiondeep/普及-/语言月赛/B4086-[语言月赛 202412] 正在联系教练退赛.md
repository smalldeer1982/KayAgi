# 题目信息

# [语言月赛 202412] 正在联系教练退赛

## 题目背景


在本题中，我们称一个字符串 $y$ 是一个字符串 $x$ 的子串，当且仅当从 $x$ 的开头和结尾删去若干个（可以为 $0$ 个）字符后剩余的字符串和 $y$ 相同。

## 题目描述


在 XCPC 竞赛里，共有 $n$ 只猪猪队伍。每只猪猪队伍都有一个队伍名称。第 $i$ 只队伍的名称是 $s_i$。

但是，队伍名称不能乱起。主办方会审查每支队伍的名称。如果一支队伍的队名被认为违规，主办方就会联系该队伍的教练员，为该队伍办理退赛。

具体而言，主办方有一个字典，字典里共有 $m$ 个字符串，第 $j$ 个字符串是 $t_j$。

如果一支队伍的队伍名 $s_i$ 存在一个子串 $k$，使得 $k$ 在主办方的字典里，则这支队伍的队伍名被认为是违规。

你作为主办方，想知道有哪些队伍会被联系教练退赛。

## 说明/提示

### 样例 1 解释

因为第一个队名包含子串 $\texttt{fusu}$，因此这支队伍会被退赛。    
因为第二个队名包含子串 $\texttt{er}$，因此这支队伍会被退赛。

### 数据规模与约定

我们用 $|s_i|$ 和 $|t_j|$ 表示 $s_i$ 和 $t_j$ 的长度。

| 测试点编号 | $n$ | $m$ | 特殊约定 |
| :-: | :-: | :-: | :-: |
| $1$ | $=1$ | $=1$ | $\mid s_i\mid =\mid t_j\mid =1$ |
| $2$ | $=1$ | $=1$ | 无 |
| $3$ | $=1$ | $\leq 100$ | 无 |
| $4$ | $\leq 100$ | $=1$| 无 |
| $5,6$ | $\leq 100$ | $\leq 100$ | $\mid s_i \mid=\mid t_j\mid = 1$ |
| $7,8$ | $\leq 100$ | $\leq 100$ | $\mid t_i \mid = 1$ |
| $9,10$ | $\leq 100$ | $\leq 100$ | 无 |

对全部的测试数据，$1 \leq n,m \leq 100$，$1 \leq |s_i|, |t_j| \leq 100$，输入的字符串均仅含可见 ASCII 字符，其 ASCII 范围为 $33 \sim 126$（含两端，空格的 ASCII 为 $32$）。

## 样例 #1

### 输入

```
3
yifusuyi
erFusuer
yiFusuYi
2
fusu
er```

### 输出

```
Yes
Yes
No```

# AI分析结果

### 综合分析与结论

本题的核心在于判断一个字符串是否包含另一个字符串作为子串。题解的主要思路是通过遍历队伍名称和字典中的字符串，逐个检查子串是否存在。虽然题目数据规模较小（n, m ≤ 100），但直接使用暴力匹配的方法已经足够高效。

### 所选高星题解

#### 题解1：一扶苏一 (4星)
**关键亮点**：
- 思路清晰，代码结构简洁，易于理解。
- 使用`substr`函数进行子串匹配，代码可读性强。
- 通过`flag`变量标记是否找到匹配的子串，逻辑清晰。

**核心代码**：
```cpp
for (int i = 0; i < n; ++i) {
    bool flag = false; // 标记是否需要退赛
    for (int j = 0; j < m; ++j) {
        // 检查 s[i] 中是否包含 t[j]
        for (int p = 0; p < int(s[i].size()); ++p) {
            // substr 的第二个参数是子串长度，如果超出范围，它会返回剩余的部分
            if (s[i].substr(p, t[j].size()) == t[j]) {
                flag = true;
                break; // 找到子串，跳出内层循环
            }
        }
        if (flag) break; // 队伍需要退赛，跳出外层循环
    }
    // 根据标记输出结果
    if (flag) cout << "Yes\n";
    else cout << "No\n";
}
```

**个人心得**：
- 使用`substr`函数可以简化子串匹配的逻辑，避免了手动实现字符串匹配的复杂性。
- 通过`flag`变量控制循环的跳出，提高了代码的效率。

### 最优关键思路与技巧

1. **子串匹配**：使用`substr`函数进行子串匹配，简化了代码实现。
2. **标记变量**：通过`flag`变量标记是否找到匹配的子串，避免不必要的循环。
3. **循环控制**：在找到匹配子串后及时跳出循环，提高代码效率。

### 可拓展之处

- **KMP算法**：对于更大规模的数据，可以使用KMP算法进行更高效的子串匹配。
- **Trie树**：如果字典中的字符串数量较多，可以使用Trie树进行前缀匹配，提高查找效率。

### 推荐洛谷题目

1. **P3375 【模板】KMP字符串匹配**：学习KMP算法，掌握高效的子串匹配方法。
2. **P2580 于是他错误的点名开始了**：练习Trie树的应用，提高字符串查找效率。
3. **P3805 【模板】manacher算法**：学习Manacher算法，掌握回文子串的查找技巧。

### 总结

本题解通过简单的暴力匹配方法解决了问题，代码清晰易懂，适合初学者学习。对于更大规模的数据，可以考虑使用KMP算法或Trie树进行优化。

---
处理用时：20.18秒
# 题目信息

# [语言月赛 202501] 分队平衡

## 题目背景

F 题中的班级搞了一次知识竞赛，然后老师发现每一列同学之间差距过于悬殊，会导致较弱的几列同学参与积极性不高，因此老师想要进行一些调整，使得每一列同学的水平更为接近。

## 题目描述

一个班级里的所有同学排成了 $n$ 行 $m$ 列，其中从前往后第 $i$ 行、从左往右第 $j$ 列的同学知识水平为 $a_{i,j}$。

定义一次**调整**的流程如下：

- 老师首先会计算每一列同学的知识水平总和，然后对于总和等于最大值或者最小值的所有列，让这些列的同学全部离开座位，并在走廊上按照知识水平从高到低排成一队。
- 接下来，让这些同学按照蛇形顺序坐在空位上。具体地，从前往后坐，同一行内，第奇数行从左往右坐，第偶数行从右往左坐。

给出初始时每个座位上同学的知识水平，计算 $k$ 次调整后每个座位上同学的知识水平。

## 说明/提示

【样例 1 解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/h35fkwk1.png)

上图显示了一次调整的流程。
- 左边是原始的座位表，其中标红的两列是知识水平和最高的，标蓝的一列是知识水平和最低的。
- 中间的图为在走廊排队的过程，其中下划线表示产生的空位。
- 右边的图演示了蛇形顺序。

【样例 2 解释】

本样例演示了调整前所有列的总和都已经相等的特殊情况。

第一次调整中，所有同学都离座重新蛇形排列，班级里的座位变成了 $\begin{matrix}40 & 30 \\ 10 & 20\end{matrix}$。

第二次调整中，所有同学都离座重新蛇形排列，但是效果和调整前完全一致。

【数据范围】

对于全体数据，保证 $2 \le n,m\le 50$，$1\le k \le 10$，$1\le a_{i,j}\le 10^9$。（注：$10^9$ 是 $10$ 亿，也就是 $10\ 0000\ 0000$。）

本题共有 $20$ 个测试点，每个测试点 $5$ 分。每个测试点的特殊性质见下表（`Y` 表示保证该性质，`N` 表示不保证）：

|测试点编号|特殊性质 A|$a_{i,j}\le$|其他性质|
|:-:|:-:|:-:|:-:|
|$1,2$|Y|$10000$|$n=2$|
|$3\sim 5$|Y|$10000$||
|$6$|Y|$10^9$|$m=2$|
|$7\sim 9$|Y|$10^9$||
|$10$|N|$10000$|$n=2$|
|$11\sim 13$|N|$10000$|$k=1$|
|$14\sim 16$|N|$10000$||
|$17$|N|$10^9$|$k=1$|
|$18\sim 20$|N|$10^9$||

- 特殊性质 A：每次调整时只有两列同学离座。


## 样例 #1

### 输入

```
3 4 1
2 1 4 7
9 6 5 4
5 2 3 5
```

### 输出

```
9 7 4 6
4 5 5 5
2 2 3 1
```

## 样例 #2

### 输入

```
2 2 2
30 40
20 10
```

### 输出

```
40 30
10 20
```

## 样例 #3

### 输入

```
8 20 10
1324 730 465 1686 1369 2011 919 128 613 1705 315 152 869 1309 114 694 229 260 2887 2282
1415 1753 570 1508 1371 464 3493 2115 2909 424 1246 214 1776 1345 662 2825 3734 1329 2344 596
2936 420 732 2505 3456 322 641 314 441 1349 186 348 347 976 1553 3906 884 2917 297 2585
452 2447 2990 2286 439 856 1340 842 721 792 3557 1697 2023 4196 1492 1066 773 181 2884 2350
1401 1756 728 501 871 1142 2795 2013 206 2683 582 809 352 1337 271 137 130 3092 1038 388
1335 1540 514 1491 2393 518 394 2496 849 1873 537 5144 578 693 1304 1111 2480 297 214 2180
1078 642 4381 472 570 3609 846 576 3556 923 3427 1747 3168 575 2208 806 1104 2116 753 171
711 1396 296 211 207 1770 232 2168 1341 863 770 517 1499 197 3048 99 1302 484 195 124
```

### 输出

```
1324 730 465 1686 1369 3609 919 128 613 3168 315 152 2887 1309 114 694 229 260 2884 2282
1415 1753 570 1508 1371 2011 3493 2115 2909 2023 1246 214 2344 1345 662 2825 3734 1329 2683 596
2936 420 732 2505 3456 1873 641 314 441 1776 186 348 1770 976 1553 3906 884 2917 1705 2585
452 2447 2990 2286 439 1038 1340 842 721 1142 3557 1697 1349 4196 1492 1066 773 181 1499 2350
1401 1756 728 501 871 923 2795 2013 206 869 582 809 863 1337 271 137 130 3092 856 388
1335 1540 514 1491 2393 518 394 2496 849 578 537 5144 753 693 1304 1111 2480 297 792 2180
1078 642 4381 472 570 464 846 576 3556 424 3427 1747 352 575 2208 806 1104 2116 347 171
711 1396 296 211 207 195 232 2168 1341 214 770 517 297 197 3048 99 1302 484 322 124
```

# AI分析结果

### 综合分析与结论

本题的核心在于模拟调整过程，涉及二维数组操作、排序和蛇形填充。题解的主要难点在于如何高效地处理每一列的总和计算、排序以及蛇形填充。yummy的题解在这些方面处理得较为清晰，代码可读性较高，且对可能的坑点（如`long long`的使用、排序方向等）进行了详细说明。

### 所选题解

#### 题解：yummy
- **星级**：4星
- **关键亮点**：
  - 清晰地定义了`i`和`j`的规则，避免了行列混淆。
  - 使用`long long`处理总和，避免了溢出问题。
  - 详细说明了排序和蛇形填充的实现细节，代码可读性高。
  - 对每一列的离开座位和重新填充过程进行了详细描述，逻辑清晰。

#### 个人心得
- **调试经历**：yummy提到在计算每一列总和时，如果不及时清零`long long`类型的数组`s[j]`，会导致错误的总和计算。这一点在实际调试中非常重要。
- **踩坑教训**：在排序时，如果只会从小到大排序，可以通过让`hall[1]`成为倒数第1个同学来实现从大到小排序，这是一种巧妙的处理方式。

### 核心代码片段

```cpp
long long mxv=0,mnv=1e18;
for(int j=1;j<=m;j++){
    s[j]=0;
    for(int i=1;i<=n;i++)
        s[j]+=a[i][j];
    mxv=max(mxv,s[j]);
    mnv=min(mnv,s[j]);
}

int ccol=0;
for(int j=1;j<=m;j++){
    if(s[j]==mnv or s[j]==mxv){
        for(int i=1;i<=n;i++)
            hall[ccol*n+i]=a[i][j];
        ccol++;
        cols[ccol]=j;
    }
}

int chall=ccol*n;
for(int i=1;i<=chall;i++)
    for(int j=chall;j>i;j--)
        if(hall[j-1]>hall[j])
            swap(hall[j-1],hall[j]);

for(int i=1;i<=n;i++){
    if(i%2){
        for(int j=1;j<=ccol;j++){
            a[i][cols[j]]=hall[chall];
            chall--;
        }
    }
    else{
        for(int j=ccol;j>0;j--){
            a[i][cols[j]]=hall[chall];
            chall--;
        }
    }
}
```

### 最优关键思路或技巧
- **数据结构**：使用`long long`类型的数组`s[j]`来存储每一列的总和，避免溢出。
- **算法优化**：通过`ccol*n+i`计算走廊上同学的原始下标，简化了排序和填充的逻辑。
- **思维方式**：在排序时，通过让`hall[1]`成为倒数第1个同学，巧妙地实现了从大到小的排序。

### 可拓展之处
- **同类型题**：类似的问题可以出现在需要频繁进行二维数组操作和排序的场景中，如矩阵旋转、矩阵填充等。
- **算法套路**：在处理二维数组时，明确行列的定义和命名规则，避免混淆；在处理大数时，注意数据类型的范围，避免溢出。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

---
处理用时：27.35秒
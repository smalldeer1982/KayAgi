# 题目信息

# [语言月赛 202502] IPv6

## 题目描述

IP 地址是在网络中唯一标识一台网络设备的一串数字。IPv4 使用 $32$ 位二进制数作为 IP 地址，然而，随着网络设备数目的快速增加，IPv4 的总地址数已经耗尽。为了解决这个问题，计算机科学家引入了 IPv6。

IPv6 使用 $128$ 位二进制数作为 IP 地址。为了方便书写，常常将这 $128$ 位二进制数划分为 $8$ 组，每组对应 $16$ 位二进制，在书写时，每组写为 $4$ 位十六进制数。每两组间，使用 `:` 隔开。

下图展示了一个 IPv6 地址的二进制表示形式与十六进制简写格式。

![](https://cdn.luogu.com.cn/upload/image_hosting/1symr2e8.png)

然而，十六进制的书写依然非常不方便，因此，IPv6 进一步引入了 IP 地址的简写规则：

1. **前导零省略规则。** 在每一组中，前导零可以省略。例如 `FC00:0:130F:0:9C0:876A:130B:0` 与 `FC00:0000:130F:0000:09C0:876A:130B:0000` 表示的是同一个地址。
2. **连续零替代规则。** 如果一组或连续多组全为零，可以用双冒号 `::` 代替，但整个 IPv6 地址中只能使用一次 `::`。例如，`2001:DB8:130F::9C0:876A:130B` 与 `2001:0DB8:130F:0000:0000:09C0:876A:130B` 表示的是同一个地址。**`::` 可以出现在 IPv6 地址串的两端。**

现在，给出一个十六进制形式的 IPv6 地址。该地址**可能**应用了上述的简写规则，请输出该 IPv6 地址对应的二进制格式。

## 说明/提示

- 对于 $40\%$ 的测试数据，IPv6 地址没有应用简化规则；
- 对于另外 $20\%$ 的测试数据，IPv6 地址没有应用连续零替代规则；
- 对于 $100\%$ 的测试数据，输入的是一个合法的 IPv6 地址。

## 样例 #1

### 输入

```
1111:2222:3333:0000:0000:0000:7777:FFF
```

### 输出

```
00010001000100010010001000100010001100110011001100000000000000000000000000000000000000000000000001110111011101110000111111111111```

## 样例 #2

### 输入

```
1111:2222:3333::7777:FFFF
```

### 输出

```
00010001000100010010001000100010001100110011001100000000000000000000000000000000000000000000000001110111011101111111111111111111```

# AI分析结果

### 综合分析与结论

本题的核心在于处理IPv6地址的两种简化规则：前导零省略和连续零替代。题解的关键思路是将IPv6地址分割成8个部分，处理前导零和连续零的情况，然后将每部分的十六进制转换为二进制输出。览遍千秋的题解清晰地描述了这一过程，并提供了具体的实现思路，具有较高的可读性和实用性。

### 所选题解

#### 题解：览遍千秋
- **星级：4星**
- **关键亮点：**
  - 清晰地描述了IPv6地址的两种简化规则及其处理方法。
  - 提供了具体的实现思路，包括如何分割字符串、处理前导零和连续零，以及如何将十六进制转换为二进制。
  - 代码实现简洁明了，易于理解和扩展。

#### 核心代码片段
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

vector<string> split(const string &s, char delimiter) {
    vector<string> tokens;
    string token;
    for (char ch : s) {
        if (ch == delimiter) {
            tokens.push_back(token);
            token.clear();
        } else {
            token += ch;
        }
    }
    tokens.push_back(token);
    return tokens;
}

string hexToBinary(char c) {
    switch (c) {
        case '0': return "0000";
        case '1': return "0001";
        case '2': return "0010";
        case '3': return "0011";
        case '4': return "0100";
        case '5': return "0101";
        case '6': return "0110";
        case '7': return "0111";
        case '8': return "1000";
        case '9': return "1001";
        case 'A': return "1010";
        case 'B': return "1011";
        case 'C': return "1100";
        case 'D': return "1101";
        case 'E': return "1110";
        case 'F': return "1111";
        case 'a': return "1010";
        case 'b': return "1011";
        case 'c': return "1100";
        case 'd': return "1101";
        case 'e': return "1110";
        case 'f': return "1111";
        default: return "";
    }
}

int main() {
    string s;
    cin >> s;
    vector<string> parts = split(s, ':');
    if (parts.size() < 8) {
        auto it = find(parts.begin(), parts.end(), "");
        if (it != parts.end()) {
            parts.erase(it);
            parts.insert(it, 8 - parts.size(), "0000");
        }
    }
    for (string &part : parts) {
        while (part.length() < 4) {
            part = "0" + part;
        }
        for (char c : part) {
            cout << hexToBinary(c);
        }
    }
    cout << endl;
    return 0;
}
```

### 最优关键思路或技巧
1. **字符串分割与处理**：使用`split`函数将IPv6地址按`:`分割，处理连续零的情况。
2. **前导零补齐**：通过循环将每部分的十六进制数补齐到4位。
3. **十六进制转二进制**：使用`hexToBinary`函数将每个十六进制字符转换为4位二进制。

### 可拓展之处
- **类似题目**：处理其他格式的地址或编码转换问题，如IPv4地址的转换、MAC地址的处理等。
- **算法套路**：字符串处理、编码转换、分割与补齐等技巧在其他题目中也有广泛应用。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003) - 考察字符串处理和模拟。
2. [P1012 拼数](https://www.luogu.com.cn/problem/P1012) - 考察字符串排序和组合。
3. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028) - 考察字符串处理和递归。

### 个人心得
- **调试经历**：在处理连续零替代规则时，需要注意`::`可能出现在地址的两端，需要特别处理。
- **踩坑教训**：在补齐前导零时，确保每部分的长度不超过4位，避免不必要的错误。
- **顿悟感想**：通过将问题分解为多个小步骤，可以更清晰地理解和解决问题。

---
处理用时：30.67秒
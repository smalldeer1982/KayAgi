# 题目信息

# 平台

## 题目描述

空间中有一些平台。给出每个平台的位置，请你计算从每一个平台的边缘落下之后会落到哪一个平台上。

注意，如果某两个平台的某个两边缘横坐标相同，物体从上面那个平台落下之后将不会落在下面那个平台上（即平台的范围是一个开区间，不包含端点）。平台**可能会重叠**。

从平台下落时视作从平台下方开始下落，也就是说不会落到高度相同的平台上。**如果有两个平台的高度相同且都可以被落到的话，那么会落到编号靠前的那个平台。**

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)

## 样例 #1

### 输入

```
5
2 0 2
4 1 3
3 1 3
5 3 4
1 1 5
```

### 输出

```
0 5
1 5
1 5
5 5
0 0
```

# AI分析结果

### 综合分析与结论

该题目要求计算从每个平台的边缘落下后会落到哪个平台上，难点在于处理平台的重叠和高度相同的情况。大部分题解采用了暴力枚举的方法，时间复杂度为O(n^2)，适用于数据规模较小的情况。部分题解通过排序优化了查找过程，但整体复杂度仍为O(n^2)。以下是关键思路和技巧总结：

1. **暴力枚举**：对于每个平台，遍历所有其他平台，找到高度低于当前平台且能接住其左/右边缘的平台。
2. **排序优化**：按高度降序排序，确保在查找时优先找到高度较高的平台，减少不必要的比较。
3. **重叠处理**：当平台高度相同时，优先选择编号较小的平台。
4. **剪枝优化**：在找到符合条件的平台后立即跳出循环，减少不必要的计算。

### 精选题解

#### 题解1：作者：kevin_y (赞：82)
- **星级**：★★★★★
- **关键亮点**：代码简洁，思路清晰，直接暴力枚举，适合初学者理解。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++){
      int sum1=0,sum2=0;
      for(int j=1;j<=n;j++)if(a[j]<a[i]&&b[j]<b[i]&&c[j]>b[i])if(a[sum1]<a[j])sum1=j;//左边下落
      cout<<sum1<<" ";
      for(int j=1;j<=n;j++)if(a[j]<a[i]&&b[j]<c[i]&&c[j]>c[i])if(a[sum2]<a[j])sum2=j;//右边下落
      cout<<sum2<<endl;
  }
  ```
- **核心思想**：对于每个平台，遍历所有其他平台，找到高度低于当前平台且能接住其左/右边缘的平台。

#### 题解2：作者：JamlainHamstone (赞：1)
- **星级**：★★★★
- **关键亮点**：通过排序优化查找过程，处理了平台重叠的情况，代码结构清晰。
- **核心代码**：
  ```cpp
  bool cmp(node a,node b){
      if(a.h!=b.h) return a.h>b.h;
      return a.id<b.id;//编号小的优先
  }
  ```
- **核心思想**：按高度降序排序，高度相同时按编号升序排序，确保在查找时优先找到高度较高的平台。

#### 题解3：作者：ysner (赞：1)
- **星级**：★★★★
- **关键亮点**：通过排序和剪枝优化，减少了不必要的比较，代码效率较高。
- **核心代码**：
  ```cpp
  for(i=0;i<n;i++){
      f1=0;f2=0;
      for(j=i+1;j<n;j++){
          if(a[i].z>a[j].z&&a[i].z<a[j].y&&f1==0) {l[a[i].w][0]=a[j].w;f1=1;}
          if(a[i].y>a[j].z&&a[i].y<a[j].y&&f2==0) {l[a[i].w][1]=a[j].w;f2=1;}
          if(f1==1&&f2==1) break;
      }
  }
  ```
- **核心思想**：按高度排序后，从高到低查找，找到符合条件的平台后立即跳出循环，减少不必要的计算。

### 最优关键思路与技巧

1. **排序优化**：按高度降序排序，确保在查找时优先找到高度较高的平台，减少不必要的比较。
2. **剪枝优化**：在找到符合条件的平台后立即跳出循环，减少不必要的计算。
3. **重叠处理**：当平台高度相同时，优先选择编号较小的平台。

### 可拓展之处

1. **数据结构优化**：可以使用线段树或树状数组等数据结构，进一步优化查找过程，将时间复杂度降低到O(n log n)。
2. **并行计算**：对于大规模数据，可以考虑使用并行计算，将查找过程分配到多个线程中执行。

### 推荐题目

1. **P1880 [NOI1995]石子合并**：考察区间DP，与平台下落问题类似，需要处理区间重叠和合并的问题。
2. **P1040 加分二叉树**：考察树形DP，与平台下落问题类似，需要处理树形结构的重叠和选择问题。
3. **P1090 合并果子**：考察贪心算法，与平台下落问题类似，需要处理优先选择和合并的问题。

### 个人心得摘录

- **调试经历**：部分题解提到在调试过程中发现平台重叠的情况，导致最初代码无法通过测试，提醒我们在处理类似问题时要注意边界条件。
- **顿悟感想**：通过排序优化查找过程，可以显著提高代码效率，尤其是在处理大规模数据时，排序和剪枝是非常有效的优化手段。

---
处理用时：36.88秒
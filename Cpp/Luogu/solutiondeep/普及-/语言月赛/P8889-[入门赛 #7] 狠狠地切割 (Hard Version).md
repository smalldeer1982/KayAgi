# 题目信息

# [入门赛 #7] 狠狠地切割 (Hard Version)

## 题目背景

**本题与 H1 的题意完全一致，区别仅在数据范围。在语言月赛中不存在 H2 题目，本题仅用于增加公开赛的区分度，并不严格遵循比赛考察范围，请酌情完成。**

## 题目描述

现给你一个长度为 $n$ 的序列 $a _ 1, \cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \cdots, b _ m$。你需要按照这 $m$ 个数对序列 $a$ 进行**狠狠地切割**。

具体的，对于一个数字 $i \in [1, n]$，如果存在一个整数 $j \in [1, m]$，使得 $a _ i = b _ j$，则将位置 $i$ 称为一个**切割点**。对序列 $a$ 中的每一个切割点，我们在这个位置进行一次**狠狠地切割**。方法是，将该位置的数字去除，然后在这个位置将其左右的**序列/片段**一分两半。

如果对**狠狠地切割**的定义有疑问，可以参照「样例 #1」及「样例解释 #1」进行理解。

你需要计算，在进行了所有可能的**狠狠地切割**后，序列被切割为了多少**片段**。

特别的，如果在切割后，某一段内没有数组，那这一段不可被叫做**片段**。同样的，如果 $1$ 或 $n$ 为切割点，其与开头和结尾之间也不存在片段。

如果对**片段**的概念有疑问，可以参照「样例 #2」及「样例解释 #2」进行理解。

## 说明/提示

### 样例 1 解释

在**狠狠地切割**前，序列 $a$ 如下所示：

$$\begin{matrix} 3 & 4 & 3 & 5 & 2 & 6 \end{matrix}$$

容易知道，第二个位置和第四个位置为切割点，我们使用 `|` 对其进行替换，代表去除工作：

$$\begin{matrix} 3 & | & 3 & | & 2 & 6 \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{3} ^ \text{片段 1} & | & \overbrace{3} ^ \text{片段 2} & | & \overbrace{2 \quad 6} ^ \text{片段 3} \end{matrix}$$

共计 $3$ 个片段。

### 样例 2 解释

以下我们展示去除之后的序列：

$$\begin{matrix} | & 4 & | & | & 2 & | \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} | & \overbrace{4} ^ \text{片段 1} & | & \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} & | & \overbrace{2} ^ \text{片段 2} & | \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段}\end{matrix}$$

共计 $2$ 个片段。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $a$ 序列中没有任何元素在 $b$ 中出现过。形式化的，$\forall i \in [1, n], \forall j \in [1, m], a _ i \neq b _ j$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 5 \times 10 ^ 5$，$- 10 ^ {18} \leq a _ i, b_i \leq 10 ^ {18}$，序列 $b$ 中的元素两两不同。

### 提示
本题输入规模较大，建议考虑使用较快的读入读出方式。

## 样例 #1

### 输入

```
6 2
3 4 3 5 2 6
5 4```

### 输出

```
3```

## 样例 #2

### 输入

```
6 3
3 4 3 5 2 6
3 5 6```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心难点在于如何在给定的数据范围内高效地找到切割点并统计片段数量。题解中主要采用了以下几种方法：

1. **二分查找**：通过将 $b$ 数组排序后，对每个 $a_i$ 进行二分查找，判断其是否为切割点。该方法的时间复杂度为 $O(n \log m)$，适用于大规模数据。
2. **双指针**：将 $a$ 和 $b$ 数组排序后，使用双指针遍历 $a$ 和 $b$，找到每个 $a_i$ 对应的切割点。该方法的时间复杂度为 $O(n \log n + m \log m)$，效率较高。
3. **unordered_map**：使用 `unordered_map` 存储 $b$ 数组中的元素，然后对每个 $a_i$ 进行查找。该方法的时间复杂度为 $O(n)$，但由于哈希表的常数较大，实际效率可能不如二分查找。

综合来看，**二分查找**和**双指针**是较为高效且易于实现的解决方案，而 `unordered_map` 虽然理论上时间复杂度较低，但在实际应用中可能受到哈希表性能的影响。

### 所选高星题解

#### 题解1：Double_Light (4星)
**关键亮点**：
- 详细介绍了二分查找的原理及其在本题中的应用。
- 代码结构清晰，逻辑严谨，易于理解。
- 提供了完整的代码实现，包括输入输出和排序操作。

**核心代码**：
```cpp
bool check(long long k) {
    long long l=1,r=m,mid;
    while(l<=r){
        mid=(l+r)/2;
        if (k<b[mid])r=mid-1;
        else if(k>b[mid])l=mid+1;
        else return 1;
    }
    return 0;
}
```
**实现思想**：通过二分查找判断 $a_i$ 是否在 $b$ 数组中，从而确定是否为切割点。

#### 题解2：Maxmilite (4星)
**关键亮点**：
- 提供了多种解决方案，包括 `unordered_map` 和双指针方法。
- 详细解释了每种方法的适用场景和优缺点。
- 代码实现简洁，逻辑清晰。

**核心代码**：
```cpp
unordered_map<long long, bool> v;
v[998244353] = true;
if (v[998244353]) { /* ... */ }
```
**实现思想**：使用 `unordered_map` 存储 $b$ 数组中的元素，然后对每个 $a_i$ 进行查找，判断是否为切割点。

### 最优关键思路与技巧

1. **二分查找**：适用于大规模数据的查找问题，时间复杂度为 $O(\log n)$，能够有效降低时间复杂度。
2. **双指针**：适用于两个有序数组的遍历问题，时间复杂度为 $O(n + m)$，效率较高。
3. **unordered_map**：适用于需要快速查找的场景，但需要注意哈希表的性能问题。

### 可拓展之处

- **类似算法套路**：二分查找和双指针方法可以广泛应用于其他查找和遍历问题，如区间合并、查找交集等。
- **同类型题目**：可以尝试解决其他需要高效查找和遍历的题目，如区间查询、元素查找等。

### 推荐题目

1. **P1048 采药**：考察二分查找的应用。
2. **P1090 合并果子**：考察双指针的应用。
3. **P3367 【模板】并查集**：考察 `unordered_map` 的应用。

### 个人心得摘录

- **Double_Light**：强调了二分查找的重要性，并详细解释了其实现过程，帮助读者更好地理解算法原理。
- **Maxmilite**：提供了多种解决方案，并分析了每种方法的优缺点，帮助读者选择最适合的解决方案。

### 总结

本题解中，二分查找和双指针是较为高效且易于实现的解决方案，适合大规模数据处理。`unordered_map` 虽然理论上时间复杂度较低，但在实际应用中可能受到哈希表性能的影响。推荐使用二分查找或双指针方法来解决类似问题。

---
处理用时：27.68秒
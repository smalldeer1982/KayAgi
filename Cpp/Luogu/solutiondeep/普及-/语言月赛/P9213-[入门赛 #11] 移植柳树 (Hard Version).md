# 题目信息

# [入门赛 #11] 移植柳树 (Hard Version)

## 题目背景

**本题与 Easy Version 题意完全相同，不同的地方仅在于数据范围和单个测试点内含有的测试组数量。**

HG 在上学的路上无聊的走着，看着这马路边的一排柳树，他的脑子里突然冒出了个奇怪的问题……

## 题目描述

假设总共有 $n$ 棵柳树，每一棵间隔都为 $x$。

现在他需要对这些树做一些操作，使得在「这 $n$ 棵树的起点不变」的同时，任意两棵树的间隔都为 $y$（$y > x$）。

他被允许做的操作如下；


- 移植树木：将一个位置的树木移到另一个位置上。

如果对「起点不变」这个概念有疑惑，可以参照「样例解释」中的图例。

显然操作是需要体力的，HG 想要让尽可能多的树维持原状。现在 HG 想知道，为了达成「任意两棵树的间隔都为 $y$」这个目标，他最多可以让多少棵树保持在原来的位置。

请你帮帮他吧！

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/6uguqush.png)

图中的方块代表树。第一行为调整前，第二行为调整后的情况。标出的三个绿色的方块是不需要移动的树，除此之外其他树都需要移动。

### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq T \leq 10 ^ 5$，$1 \leq n \leq 10 ^ {18}$，$1 \leq x < y \leq 10 ^ 9$。  

## 样例 #1

### 输入

```
1
8 2 3```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心在于计算在给定条件下，能够保持不动的树的数量。所有题解都基于相同的数学原理：通过计算 $x$ 和 $y$ 的最小公倍数（LCM）来确定哪些树的位置不需要移动。难点在于处理大数计算时的溢出问题，尤其是当 $n$ 和 $x$ 取到最大值时，直接计算会导致 `long long` 溢出。

不同题解在解决溢出问题时采用了不同的策略：
1. 使用 `__int128` 类型来处理大数计算。
2. 利用 `long double` 类型来避免溢出。
3. 通过数学变换，提前约简公式中的 $x$，从而避免大数乘法。

### 所选高星题解

#### 题解1：zzx114514 (5星)
- **关键亮点**：使用 `__int128` 类型处理大数计算，代码清晰，逻辑严谨。
- **个人心得**：作者提到 `__int128` 的使用需要快读快输，不能使用 `cin` 和 `cout`，这一点在实际编程中需要注意。
- **核心代码**：
  ```cpp
  __int128 lcm(__int128 a,__int128 b) {
      return a*b/__gcd(a,b);
  }
  void print(__int128 num) {
      if(num>9) print(num/10);
      putchar(num%10+'0');
  }
  int main() {
      cin>>t;
      while(t--) {
          n=read(),x=read(),y=read();
          l=(n-1)*x;
          print(l/lcm(x,y)+1);
          puts("");
      }
      return 0;
  }
  ```

#### 题解2：cff_0102 (4星)
- **关键亮点**：利用 `long double` 类型避免溢出，代码简洁，逻辑清晰。
- **个人心得**：作者指出 `long double` 的范围足够大，可以避免 `__int128` 的复杂性。
- **核心代码**：
  ```cpp
  int main() {
      ios::sync_with_stdio(false);
      int t;cin>>t;
      while(t--) {
          long long n,x,y;
          cin>>n>>x>>y;
          long double ans=1;
          ans*=(n-1);
          ans*=__gcd(x,y);
          ans/=y;
          cout<<(long long)ans+1<<endl;
      }
      return 0;
  }
  ```

#### 题解3：liuliucy (4星)
- **关键亮点**：通过数学变换提前约简公式，避免大数乘法，代码简洁高效。
- **个人心得**：作者通过数学推导简化了计算过程，避免了复杂的类型转换。
- **核心代码**：
  ```cpp
  int main() {
      scanf("%d",&T);
      while(T--) {
          scanf("%lld%lld%lld",&n,&x,&y);
          printf("%lld\n",(n-1)/(y/gcd(x,y))+1);
      }
  }
  ```

### 最优关键思路与技巧

1. **数学变换**：通过提前约简公式中的 $x$，避免大数乘法，是最优的解决方案。
2. **类型选择**：在需要处理大数时，选择合适的类型（如 `__int128` 或 `long double`）可以有效避免溢出问题。
3. **代码优化**：通过数学推导和代码优化，减少不必要的计算，提高代码效率。

### 可拓展之处

本题的数学原理可以推广到其他类似的间隔问题，如路灯布置、信号塔布置等。类似的算法套路还包括计算最大公约数（GCD）和最小公倍数（LCM）的应用。

### 推荐题目

1. **P1029 最大公约数和最小公倍数问题**：考察 GCD 和 LCM 的基本应用。
2. **P1072 Hankson 的趣味题**：涉及 GCD 和 LCM 的综合应用。
3. **P1447 能量项链**：考察间隔问题的动态规划解法。

### 个人心得总结

- **调试经历**：在处理大数计算时，选择合适的类型和算法是关键，避免直接使用 `long long` 导致溢出。
- **踩坑教训**：使用 `__int128` 时需要注意输入输出方式，不能使用 `cin` 和 `cout`。
- **顿悟感想**：通过数学变换提前约简公式，可以大大简化计算过程，提高代码效率。

---
处理用时：32.28秒
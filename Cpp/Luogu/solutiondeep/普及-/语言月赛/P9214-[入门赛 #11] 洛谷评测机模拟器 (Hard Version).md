# 题目信息

# [入门赛 #11] 洛谷评测机模拟器 (Hard Version)

## 题目背景

**本题与 Easy Version 题意完全相同，不同的地方在于数据范围。**

现在假装你是洛谷评测机。这一天，洛谷同时进行了 PION 自测、SCP 自测、ION 自测等等比赛。成千上万的评测落到了你的身上！

## 题目描述

现在已经知道你有 $n$ 个相同性能的评测节点，它们被分别标号为 $1, 2, \cdots, n$。一个评测节点在同一时间只能处理一个评测任务。

在某一时刻，$m$ 个评测任务同时涌入了你。我们将这些任务分别标号为 $1, 2, \cdots, m$。这些评测任务需要的评测时间分别为 $t _ 1 , t _ 2, \cdots, t _ m$。每个评测任务**需要且仅需要一个**评测节点来运行，因此你会按照如下方式按照 $1 \sim m$ 的顺序依次将这些评测任务分配到评测节点上：

对于某个耗时 $t _ i$ 的评测任务，你需要找到目前**累积评测时间**最小的评测节点将任务放入。如果有多个评测节点**累积评测时间**相同且最小，则找一个**标号最小**的节点将任务放入。

> 「累积评测时间」定义：假设对于某个评测节点，其被分配了 $a _ 1, a _ 2, \cdots, a _ k$ 共 $k$ 个任务。那么这个评测节点的「累积评测时间」就是 $t _ {a _ 1} + t _ {a _ 2} + \cdots + t _ {a _ k}$。显然的，如果某个评测节点从未被分配过这 $m$ 个任务中的任何一个，那么这个评测节点的「累积评测时间」是 $0$。

现在，你需要统计出，你的这 $n$ 个评测节点分别接受了哪一些评测任务。

## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 5 \times 10 ^ 5$，$0 \leq t _ i \leq 10 ^ 9$。

## 样例 #1

### 输入

```
5 10
13 50 90 38 60 64 60 77 6 24```

### 输出

```
1 6
2 8
3
4 7
5 9 10```

## 样例 #2

### 输入

```
12 7
85 99 82 90 14 11 15```

### 输出

```
1
2
3
4
5
6
7
0
0
0
0
0```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何高效地将任务分配到累积评测时间最少的节点。由于数据范围较大（$n, m \leq 5 \times 10^5$），暴力解法的时间复杂度为 $O(nm)$，无法通过。因此，优化思路主要集中在使用优先队列（小根堆）来快速找到当前累积评测时间最少的节点。

所有题解都采用了优先队列的思路，但在实现细节上有所不同。主要区别在于如何定义优先队列的排序规则、如何处理节点编号的优先级、以及如何存储和输出结果。以下是对各题解的简要评分和关键亮点的总结。

### 所选高星题解

#### 1. 作者：2021sunzishan (赞：8)
- **星级**：5星
- **关键亮点**：
  - 详细解释了优先队列的使用方法，适合新手理解。
  - 代码结构清晰，注释详细，便于阅读。
  - 使用了结构体和重载运算符来定义优先队列的排序规则。
  - 使用 `vector` 存储每个节点的任务编号，避免了空间浪费。
- **个人心得**：作者强调了开 `long long` 的重要性，避免了因数据范围过大导致的溢出问题。

```cpp
struct node {
    long long s; // 总用时
    int op;      // 节点编号
    bool operator >(const node &k) const {
        if (s != k.s) return s > k.s; // 按用时排序
        else return op > k.op;        // 按编号排序
    }
};
priority_queue<node, vector<node>, greater<node>> q; // 小根堆
```

#### 2. 作者：dyyzy (赞：6)
- **星级**：4星
- **关键亮点**：
  - 提供了多种实现小根堆的方法，包括使用 `greater`、重载运算符和取相反数的方法。
  - 代码简洁，逻辑清晰，适合有一定基础的读者。
  - 使用 `pair` 存储节点的时间和编号，简化了数据结构。
- **个人心得**：作者提到使用取相反数的方法来实现小根堆，虽然巧妙，但需要注意取出元素时取相反数的细节。

```cpp
priority_queue<pair<long long, int>> pq; // 大根堆，存储相反数
for (int i = 1; i <= n; ++i) pq.push(mp(0, -i)); // 初始化
```

#### 3. 作者：zzx114514 (赞：5)
- **星级**：4星
- **关键亮点**：
  - 代码结构清晰，注释详细，便于理解。
  - 使用结构体和重载运算符来定义优先队列的排序规则。
  - 使用 `vector` 存储每个节点的任务编号，避免了空间浪费。
- **个人心得**：作者强调了开 `long long` 的重要性，并分享了自己在调试过程中遇到的卡顿问题。

```cpp
struct Node {
    long long id, time;
    bool operator>(const Node &a) const {
        if (time == a.time) return id > a.id;
        return time > a.time;
    }
};
priority_queue<Node, vector<Node>, greater<Node>> node; // 小根堆
```

### 最优关键思路与技巧

1. **优先队列的使用**：优先队列（小根堆）是解决本题的核心数据结构，能够快速找到当前累积评测时间最少的节点。
2. **结构体与重载运算符**：通过结构体和重载运算符来定义优先队列的排序规则，使得代码更加清晰和易于维护。
3. **空间优化**：使用 `vector` 存储每个节点的任务编号，避免了使用二维数组带来的空间浪费。
4. **数据范围处理**：由于数据范围较大，必须使用 `long long` 来存储累积评测时间，避免溢出问题。

### 可拓展之处

本题的解法可以拓展到其他需要动态分配资源的场景，如任务调度、资源分配等。类似的问题可以通过优先队列来优化查找最小或最大值的操作。

### 推荐相似题目

1. **P1090 [NOIP2004 提高组] 合并果子**（题号：P1090）：使用优先队列来合并果子，类似于本题的任务分配。
2. **P3378 【模板】堆**（题号：P3378）：练习堆的基本操作，理解优先队列的实现。
3. **P1886 滑动窗口**（题号：P1886）：使用优先队列来维护滑动窗口中的最小值或最大值。

### 总结

本题的核心在于使用优先队列来优化任务分配的过程，通过结构体和重载运算符来定义排序规则，能够有效提高代码的可读性和维护性。在处理大数据范围时，注意数据类型的选取和空间优化是关键。

---
处理用时：30.80秒
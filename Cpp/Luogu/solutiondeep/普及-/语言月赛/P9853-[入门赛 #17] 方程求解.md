# 题目信息

# [入门赛 #17] 方程求解

## 题目描述

小 A 有 $n$ 个关于 $x$ 的方程，第 $i$ 个方程形如 $a_ix_i+b_i=c_i$。方程的解 $x$ 均为正整数，例如下面几个方程都是符合要求的方程：

```
2x+4=10
-3x+13=10
4x-8=16
```

其中，第一组方程的解为 $x_1=3$，第二组方程的解为 $x_2=1$，第三组方程的解为 $x_3=6$。

小 A 想要知道，给定 $L,R$，在 $L\leq x\leq R$ 的范围内，有多少个正整数 $x$ 满足 $x$ 是其中至少一个方程的解。为了防止你欺骗他，他会询问你 $Q$ 次。

## 说明/提示

**【样例解释】**

对于第一组样例，即为题目中的举例。三组方程的解分别为 $x_1=3,x_2=1,x_3=6$。则：

- 对于 $1\leq x\leq 6$ 的范围，有 $3$ 个 $x$ 的取值（$x=1,3,6$）是其中至少一个方程的解；
- 对于 $1\leq x\leq 8$ 的范围，同上所述；
- 对于 $3\leq x\leq 6$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,6$）是其中至少一个方程的解；
- 对于 $4\leq x\leq 5$ 的范围，不存在一个 $x$ 是其中至少一个方程的解；
- 因此分别输出 $3,3,2,0$。

对于第二组样例，五组方程的解分别为 $x_1=3,x_2=5,x_3=5,x_4=3,x_5=3$。则：

- 对于 $1\leq x\leq 3$ 的范围，只有 $x=3$ 满足是其中至少一个方程的解；
- 对于 $1\leq x\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；
- 对于 $3\leq x\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；
- 因此分别输出 $1,2,2$。

**【数据范围】**

数据保证，$1\leq n,Q\leq 2\times 10^5$，方程中 $a_i,b_i,c_i$ 满足 $1 \leq |a_i|,|b_i|,|c_i| \leq 10^9$，每一组方程的解 $x_i$ 必定为正整数。询问时的 $L,R$ 满足 $1\leq L\leq R\leq 2\times 10^9$。

本题输入数据较大，请注意代码输入输出的运行效率。

## 样例 #1

### 输入

```
3 4
2x+4=10
-3x+13=10
4x-8=16
1 6
1 8
3 6
4 5```

### 输出

```
3
3
2
0```

## 样例 #2

### 输入

```
5 3
5x-2=13
8x+5=45
4x-12=8
-2x+10=4
3x-7=2
1 3
1 5
3 5```

### 输出

```
1
2
2```

# AI分析结果

### 综合分析与结论

本题的核心在于高效处理大量方程的解，并在多次查询中快速统计某个区间内满足条件的解的数量。题解中提到的关键思路包括：

1. **方程解析**：通过 `scanf` 或自定义解析方法提取方程中的系数，计算解。
2. **解的去重与排序**：将所有解排序并去重，便于后续查询。
3. **二分查找优化查询**：利用 `lower_bound` 和 `upper_bound` 快速定位区间内的解，时间复杂度为 \(O(Q \log m)\)。

这些方法在处理大规模数据时表现出色，尤其是在时间和空间复杂度上都有较好的优化。

### 所选题解

#### 题解：chen_zhe (5星)

**关键亮点**：
- 详细解释了方程的解析方法，并提供了两种实现方式（`scanf` 和自定义解析）。
- 提出将解排序并去重的思路，结合二分查找优化查询效率。
- 代码实现简洁，逻辑清晰，适合初学者理解。

**个人心得**：
- 提到“快速读入”技巧，强调了在处理大规模输入时优化输入效率的重要性。
- 强调了 `lower_bound` 和 `upper_bound` 的使用场景，帮助读者理解二分查找的实际应用。

**核心代码**：
```cpp
vector<int> solutions;
for (int i = 0; i < n; ++i) {
    int a, b, c;
    scanf("%dx%d=%d", &a, &b, &c);
    int x = (c - b) / a;
    solutions.push_back(x);
}
sort(solutions.begin(), solutions.end());
solutions.erase(unique(solutions.begin(), solutions.end()), solutions.end());

for (int i = 0; i < Q; ++i) {
    int L, R;
    scanf("%d%d", &L, &R);
    auto low = lower_bound(solutions.begin(), solutions.end(), L);
    auto high = upper_bound(solutions.begin(), solutions.end(), R);
    printf("%d\n", high - low);
}
```

### 最优关键思路或技巧

1. **方程解析**：使用 `scanf` 或自定义解析方法高效提取方程系数。
2. **解的去重与排序**：通过排序和去重减少重复计算，优化查询效率。
3. **二分查找**：利用 `lower_bound` 和 `upper_bound` 快速定位区间内的解，时间复杂度为 \(O(Q \log m)\)。

### 可拓展之处

- **类似问题**：处理大规模数据时，排序和二分查找是常见优化手段，适用于多种区间查询问题。
- **扩展应用**：可以应用于其他需要快速查询区间内满足条件的元素的问题，如统计某个范围内的质数、特定条件的数等。

### 推荐题目

1. **P3374 【模板】树状数组 1**：考察区间查询和单点更新，适合练习二分查找和区间统计。
2. **P3368 【模板】树状数组 2**：涉及区间更新和单点查询，进一步巩固二分查找和区间处理技巧。
3. **P1908 逆序对**：利用排序和二分查找统计逆序对数量，适合练习二分查找的应用。

### 总结

本题解通过详细的思路解释和代码实现，展示了如何处理大规模数据下的方程解统计问题。其核心技巧包括方程解析、解的去重与排序、以及二分查找优化查询效率，这些方法在实际编程竞赛中具有广泛的应用价值。

---
处理用时：27.96秒
# 题目信息

# 分解质因子 2

## 题目描述

给定一个正整数 $n$，设 $n = p_1 \times p_2 \times \dots p_k$，其中 $p_i$ 均为质数，对 $1 \leq i < k$，$p_i \leq p_{i + 1}$。

可以证明，序列 $p_i$ 是唯一的。

对每个给定的 $n$，请你求出 $p_1, p_2, \dots p_k$。

## 说明/提示

### 数据规模与约定

对全部的测试点，保证 $1 \leq T \leq 10$，$1 \leq n \leq 10^{12}$。

## 样例 #1

### 输入

```
9
2
3
4
5
6
7
8
9
10```

### 输出

```
2
3
2 2
5
2 3
7
2 2 2
3 3
2 5```

# AI分析结果



### 综合分析与结论

本题考察质因数分解的经典算法实现。关键点在于利用试除法结合数学特性优化枚举范围，将时间复杂度优化到 O(√n)。所有题解均基于唯一分解定理，其中核心优化思路为"枚举至平方根后处理剩余大质因子"。

---

### 所选题解分析（评分≥4星）

#### 题解作者：一扶苏一（⭐⭐⭐⭐⭐）

**关键亮点：**
1. 数学证明清晰：通过引理证明只需枚举到√n，并处理剩余的大质因子
2. 代码简洁高效：正确实现试除法，用`i*i <=n`避免浮点运算，用long long防溢出
3. 输出优化：在除尽时直接输出，避免存储结果节省空间

**个人心得体现：**
- 通过引理证明强调分解的正确性，确保算法不会遗漏质因子
- 使用`1ll * i * i`处理类型转换，避免int溢出的常见错误

**核心代码：**
```cpp
for (int i = 2; 1ll * i * i <= n; ++i)
    while (m % i == 0) {
        m /= i;
        cout << i << ' ';
    }
if (m != 1) cout << m;
```

**实现思想：**
1. 枚举2到√n的所有数进行试除
2. 对每个因子i进行除尽操作，输出所有该因子的出现
3. 最后若剩余数>1则必为唯一的大质因子

---

### 最优思路总结
**关键技巧：**
- **平方根分界**：利用质因子分布特性，将枚举范围限制到√n
- **即时输出**：在试除过程中直接输出结果，无需存储分解式
- **类型防溢**：通过`1ll*`将乘法结果提升为long long类型

**适用场景：**
- n ≤ 1e12且需要多次查询的质因数分解
- 要求代码简洁、空间高效的处理场景

---

### 拓展建议
**同类型题目：**
1. [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)（基础试除法应用）
2. [P2043 质因子分解](https://www.luogu.com.cn/problem/P2043)（统计质因子次数）
3. [P1069 细胞分裂](https://www.luogu.com.cn/problem/P1069)（质因数分解在应用题中的运用）

**高阶拓展：**
- 当n达到1e18时，可学习Pollard-Rho随机分解算法
- 预处理质数表优化试除法的效率

---

### 调试经验摘录
**关键调试点：**
- **大数溢出**：当i是int类型时，i*i可能溢出，必须用`1ll*i*i`
- **剩余因子处理**：分解完成后必须检查m是否为1，否则会漏掉最后一个质因子
- **边界情况**：n=1时需要特殊处理（但题目保证n≥1时由数据约束自动处理）

---
处理用时：56.65秒
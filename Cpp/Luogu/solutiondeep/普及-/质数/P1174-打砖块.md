# 题目信息

# 打砖块

## 题目描述

小红很喜欢玩一个叫打砖块的游戏，这个游戏的规则如下：

在刚开始的时候，有 $n$ 行 $m$ 列的砖块，小红有 $k$ 发子弹。小红每次可以用一发子弹，打碎某一列当前处于这一列最下面的那块砖，并且得到相应的得分。（如图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/twgirdp6.png)

某些砖块在打碎以后，还可能将得到一发子弹的奖励。最后当所有的砖块都打碎了，或者小红没有子弹了，游戏结束。

小红在游戏开始之前，就已经知道每一块砖在打碎以后的得分，并且知道能不能得到一发奖励的子弹。小红想知道在这次游戏中她可能的最大得分，可是这个问题对于她来说太难了，你能帮帮她吗？


## 说明/提示

对于 $20\%$ 的数据，满足 $1  \le n,m  \le 5$，$1  \le k  \le 10$，所有的字符 $c$ 都为 `N`。

对于 $50\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，所有的字符 $c$ 都为 `N`。

对于 $100\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，字符 $c$ 可能为 `Y`。

对于 $100\%$ 的数据，所有的 $f$ 值满足 $1  \le f  \le 10000$。


## 样例 #1

### 输入

```
3 4 2
9 N 5 N 1 N 8 N
5 N 5 Y 5 N 5 N
6 N 2 N 4 N 3 N```

### 输出

```
13```

# AI分析结果



### 综合分析与结论
本题的核心难点在于处理带有子弹奖励的砖块（Y型）对动态规划状态转移的影响。各题解普遍采用以下思路：
1. **预处理列信息**：将每列砖块拆分为消耗不同子弹数时的最大得分（分最后一发打在N/Y两种状态）
2. **状态设计**：动态规划需区分最后一发子弹是否在当前列/是否为N型砖块
3. **子弹借用机制**：通过状态转移处理子弹的"借还"逻辑，确保正确计算连续Y型砖块的收益

### 高星题解推荐

#### 1. Azuree（4.5星）
**关键亮点**：
- 清晰的预处理设计，分离`sum1[N型结尾]`和`sum2[Y型结尾]`
- 三维状态转移（前i列、消耗j子弹、结尾类型）逻辑严密
- 包含完整测试用例及错误分析，具有教学意义

**核心代码**：
```cpp
for(int j=1;j<=m;j++) {
    for(int i=0;i<=k;i++) {
        for(int l=0;l<=min(n,j);l++) {
            f[i][j][1] = max(f[i][j][1], f[i-1][j-l][1] + v[i][l][1]);
            if(l) f[i][j][0] = max(...);
            if(j>l) f[i][j][0] = max(...);
        }
    }
}
```
**实现思想**：分别处理最后一发子弹是否在当前列，通过三重循环枚举列、总子弹、当前列子弹数进行转移。

#### 2. psoet（4星）
**关键亮点**：
- 提出"最后一个子弹必为N型"的关键观察
- 将状态简化为是否在[1,j]列结束
- 提供完备的四种转移情况分类

**核心思路**：
```python
dp[j][k][0] = max(
    继承前一列, 
    当前列结尾为N（借子弹）, 
    当前列结尾为Y（不借子弹）
)
```

#### 3. I_AM_HelloWord（4星）
**关键创新**：
- 引入"借子弹"的生动比喻解释状态转移
- 预处理时建立`tot[j][i]`记录连续Y型砖块
- 四维状态转移包含子弹借贷标记

**调试心得**：
> "在计算连续Y型砖块时，必须将tot[j][idx+1]设置为tot[j][i]+1，否则会漏算中间层数" —— 强调预处理时层数跳跃的处理技巧

### 最优思路总结
1. **列压缩预处理**：
   ```cpp
   for 每列 from 下到上:
       if 当前是Y: 累加到上层N的得分
       else: 创建新的子弹消耗层
   ```
2. **状态设计核心**：
   - `dp[i][j][0]`: 前i列用j子弹，最后一发为N型
   - `dp[i][j][1]`: 前i列用j子弹，最后一发为Y型
3. **转移方程关键**：
   ```cpp
   // 借子弹转移
   dp[i][j][0] = max(dp[i-1][j-l][1] + sum1[l])
   // 不借子弹转移
   dp[i][j][0] = max(dp[i-1][j-l][0] + sum2[l])
   ```

### 拓展训练
1. **分组背包变种**：P1776 宝物筛选（多重背包+分组决策）
2. **状态压缩DP**：P2014 选课（树形依赖分组）
3. **子弹机制扩展**：P1941 飞扬的小鸟（连续操作与资源恢复）

### 关键代码片段
Azuree的预处理核心：
```cpp
for(int j=1;j<=m;j++) {
    int cnt = 0;
    for(int i=n; i>=1; i--) {
        if(c[i][j]=='Y') 
            sy[j][cnt] += a[i][j];
        else {
            cnt++;
            sy[j][cnt] = sy[j][cnt-1] + a[i][j];
            sn[j][cnt] = sy[j][cnt-1] + a[i][j];
        }
    }
}
```
此代码自底向上遍历每列，将连续的Y型砖块收益合并到最近的N型砖块层，建立子弹消耗与得分的映射关系。

---
处理用时：58.38秒
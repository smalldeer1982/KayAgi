# 题目信息

# [USACO1.5] 特殊的质数肋骨 Superprime Rib

## 题目描述

农民约翰的母牛总是产生最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。 

农民约翰确定他卖给买方的是真正的质数肋骨，是因为从右边开始切下肋骨，每次还剩下的肋骨上的数字都组成一个质数。  

举例来说：$7\ 3\ 3\ 1$ 全部肋骨上的数字 $7331$ 是质数；三根肋骨 $733$ 是质数；二根肋骨 $73$ 是质数；当然,最后一根肋骨 $7$ 也是质数。$7331$ 被叫做长度 $4$ 的特殊质数。  

写一个程序对给定的肋骨的数目 $n$，求出所有的特殊质数。$1$ 不是质数。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 8$。

题目翻译来自NOCOW。

USACO Training Section 1.5


## 样例 #1

### 输入

```
4
```

### 输出

```
2333
2339
2393
2399
2939
3119
3137
3733
3739
3793
3797
5939
7193
7331
7333
7393
```

# AI分析结果



### 综合分析与结论
该题要求生成满足逐位截断均为质数的特殊质数肋骨。核心思路为生成式搜索（DFS/BFS）配合质数剪枝，通过逐位构造数字并及时验证质数性质，避免无效分支。关键优化点包括：首位限定为2/3/5/7，后续位数仅尝试奇数（1/3/7/9），以及即时剪枝非质数路径。最优解法时间复杂度约为 O(4*4^(n-1)*√M)，其中M为n位数最大值。

---

### 高分题解推荐

#### 1. 安笙凉城（DFS剪枝）★★★★★
**核心亮点**：
- 清晰简洁的DFS实现，逐位生成数字
- 首位限定优化（2/3/5/7），后续仅尝试1/3/7/9
- 每层递归立即验证质数性质，及时剪枝
- 代码可读性极佳，无冗余结构

**关键代码**：
```cpp
void DFS(int k, int sum) {
    if (k == n) { cout << sum << endl; return; }
    for (int i : {1,3,7,9}) {
        int new_num = sum * 10 + i;
        if (prime(new_num)) DFS(k+1, new_num);
    }
}
// 初始调用: DFS(1,2), DFS(1,3), DFS(1,5), DFS(1,7)
```

#### 2. HeZhenting（BFS队列）★★★★☆
**核心亮点**：
- 基于队列的BFS实现，层次扩展保证有序性
- 动态维护有效质数肋骨集合
- 空间效率优于DFS（无需递归栈）
- 预处理有效后续数字（1/3/7/9）

**关键代码**：
```cpp
queue<int> q = {2,3,5,7};
for (int layer=2; layer<=n; layer++) {
    int size = q.size();
    while (size--) {
        int num = q.front(); q.pop();
        for (int d : {1,3,7,9}) {
            int new_num = num*10 + d;
            if (is_prime(new_num)) q.push(new_num);
        }
    }
}
// 最终输出队列内容
```

#### 3. LJC00118（优化DFS）★★★★
**核心亮点**：
- 显式剪枝偶数与5结尾的情况
- 独立质数判断函数优化计算效率
- 结构清晰的递推式搜索流程

**调试心得**：
> "通过分析发现，任何包含偶数位或末位5的路径必然失败，显式排除这些分支后性能提升显著"

---

### 关键优化技巧总结
1. **生成顺序优化**：首位限定为质数，后续仅生成奇数
2. **即时验证**：每次数字扩展后立即验证质数，避免无效递归
3. **数学剪枝**：排除末位为偶数和5的情况（除数字2/5本身）
4. **质数判断优化**：
   - 仅需验证到平方根
   - 预先排除偶数（除2）
   - Miller-Rabin算法（对极大数有效）

---

### 相似题目推荐
1. **P1036 选数**（质数组合搜索）
2. **P1706 全排列问题**（生成式搜索）
3. **P1022 计算器的改良**（数字构造与验证）

---
处理用时：49.27秒
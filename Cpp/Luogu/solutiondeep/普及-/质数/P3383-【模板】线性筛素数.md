# 题目信息

# 【模板】线性筛素数

## 题目背景

本题已更新，从判断素数改为了查询第 $k$ 小的素数  
提示：如果你使用  `cin` 来读入，建议使用 `std::ios::sync_with_stdio(0)` 来加速。

## 题目描述

如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$n = 10^8$，$1 \le q \le 10^6$，保证查询的素数不大于 $n$。

Data by NaCly\_Fish.


## 样例 #1

### 输入

```
100 5
1
2
3
4
5```

### 输出

```
2
3
5
7
11```

# AI分析结果



### 综合分析与结论
本题需在 1e8 范围内高效筛素数并处理 1e6 次查询。核心解法为欧拉筛（线性筛），其通过确保每个合数仅被最小质因数筛除实现 O(n) 时间复杂度。关键优化点包括：  
1. **线性筛原理**：通过 `i % Prime[j] == 0` 的剪枝条件避免重复筛选。  
2. **空间优化**：使用 `bitset` 替代 `bool` 数组可减少约 60% 内存占用。  
3. **预处理与快速查询**：筛法预处理素数后直接 O(1) 响应查询。  

以下题解在思路清晰度、优化技巧或代码实现上表现突出：

---

### 高星题解推荐

#### 1. 学委的题解（5⭐）
**核心亮点**：  
- 完整推导欧拉筛的正确性及线性复杂度，结合数学证明，深入浅出。  
- 代码结构清晰，注释详细，适合初学者理解筛法本质。  
**关键代码**：  
```cpp
void GetPrime(int n) {
    memset(isPrime, 1, sizeof(isPrime));
    isPrime[1] = 0;
    for(int i=2; i<=n; i++) {
        if(isPrime[i]) Prime[++cnt] = i;
        for(int j=1; j<=cnt && i*Prime[j]<=n; j++) {
            isPrime[i*Prime[j]] = 0;
            if(i % Prime[j] == 0) break; // 关键剪枝
        }
    }
}
```
**个人心得**：  
> "每个合数只被其最小质因数筛除" 是线性复杂度的核心，剪枝条件 `i%Prime[j]==0` 保证了后续筛选不会重复。

#### 2. Theophania 的题解（4⭐）
**核心亮点**：  
- 引入 `bitset` 优化空间，显著降低内存消耗（100MB → 12.5MB）。  
- 使用 `vector` 动态存储素数，提升代码灵活性。  
**关键代码**：  
```cpp
bitset<maxn> num; // 替代 bool 数组
vector<int> prime;
void init(int n) {
    for(int i=2; i<=n; i++) {
        if(!num[i]) prime.push_back(i);
        for(int j=0; j<prime.size() && i*prime[j]<=n; j++) {
            num[i*prime[j]] = 1;
            if(i%prime[j]==0) break;
        }
    }
}
```
**优化技巧**：  
`bitset` 的位压缩特性在处理大规模布尔标记时效果显著，尤其适用于内存敏感的场景。

#### 3. Lylighte 的题解（4⭐）
**核心亮点**：  
- 对比埃氏筛与欧拉筛的差异，通过实例表格直观展示筛选过程。  
- 强调欧拉筛中「最大非自身因数」的筛选原则，解释剪枝逻辑。  
**关键图示**：  
| i 值 | 筛除的合数     | 说明               |
|------|----------------|--------------------|
| 4    | 8              | 因 `4%2==0` 终止   |
| 5    | 10, 15, 25     | 逐个筛除最小质因数 |

---

### 最优技巧总结
1. **线性筛剪枝条件**：`if(i % Prime[j] == 0) break;` 确保合数仅被最小质因数筛除。  
2. **空间压缩**：使用 `bitset` 或位运算优化标记数组，降低内存开销。  
3. **预处理查询分离**：先 O(n) 预处理素数表，再 O(1) 响应查询。  

---

### 拓展练习（洛谷题目）
1. [P3383 线性筛素数](https://www.luogu.com.cn/problem/P3383)（本题）  
2. [P3912 素数个数](https://www.luogu.com.cn/problem/P3912)（大范围素数统计，需优化筛法）  
3. [P1217 回文质数](https://www.luogu.com.cn/problem/P1217)（筛法+回文数判断，综合应用）  

---

### 调试与优化经验
- **空间爆炸**：`bool isPrime[1e8]` 在部分 OJ 会 MLE，改用 `bitset` 或分块筛。  
- **剪枝遗漏**：欧拉筛未添加 `i%Prime[j]==0` 会导致重复筛除，时间复杂度退化至 O(n log n)。

---
处理用时：85.46秒
# 题目信息

# [NICA #2] 字符串入门题

## 题目背景

小波说这是字符串入门题极好的，所以这是极好的。

## 题目描述

给定一个仅包含大小写字母和数字的字符串 $s$，问能否将 $s$ 拆分成至少 $k$ 个子串 $s_1,s_2,\dots,s_t(t\ge k)$ 满足 $\forall 1<i\le t$ 有 $s_i$ 是 $s_1s_2\dots s_{i-1}$（这里表示的是拼接）的子串。

一个字符串 $s$ 是另一个字符串 $t$ 的子串当且仅当可以通过删除 $t$ 的一个可以为空的前缀以及一个可以为空的后缀后得到 $s$。

## 说明/提示

#### 样例 1 解释

`1145|14`是一种合法的拆分方案，因为拆分出了 $2$ 个字符串且 $2\ge k$，并且`14`是`1145`的一个子串。

#### 样例 2 解释

`a1A|a1|1Aa`是一种合法的拆分方案，因为拆分出了 $3$ 个字符串且 $3\ge k$，并且`a1`是`a1A`的一个子串，且`1Aa`是`a1Aa1`的一个子串。

#### 样例 3 解释

尝试所有拆分方案后发现无论如何拆分都无法满足条件。

#### 数据范围

对于所有数据，满足 $2\le k\le n\le 10^6$，$s$ 仅由大小写字母和数字构成。

## 样例 #1

### 输入

```
6 2
114514```

### 输出

```
2
1145
14```

## 样例 #2

### 输入

```
8 2
a1Aa11Aa```

### 输出

```
3
a1A
a1
1Aa```

## 样例 #3

### 输入

```
11 2
stoImakforz```

### 输出

```
-1```

# AI分析结果



### 综合分析与结论
题目要求将字符串拆分为至少k个子串，每个后续子串必须是前面所有子串拼接后的子串。所有题解的核心思路是将第一个子串尽可能长（前n-k+1个字符），后续每个字符单独成子串，并确保这些字符在主串中存在。此方法正确且时间复杂度为O(n)，适用于题目规模。

### 高星题解推荐
#### 1. 作者：wmrqwq（★★★★☆）
- **关键亮点**：思路清晰，正确性分析到位，代码简洁高效。
- **个人心得**：通过贪心策略确保后续子串满足条件，强调“尽可能增加第一个子串长度”的重要性。
- **核心代码**：
  ```cpp
  for(int i=0;i<n-m+1;i++) pd[s[i]]=1; // 记录主串字符
  for(int i=n-m+1;i<n;i++) // 检查后续字符
  if(!pd[s[i]]) { cout<<-1; return 0; }
  ```

#### 2. 作者：Clarinet（★★★★☆）
- **关键亮点**：变量命名规范，代码可读性强，逻辑简明易懂。
- **核心实现**：使用数组标记字符存在性，直接遍历验证。
  ```cpp
  for(int i=0;i<=n-k;i++)t[a[i]]=1; // 主串字符标记
  for(int i=n-k+1;i<n;i++){ // 后续字符检查
    if(!t[a[i]]) { cout<<-1; return 0; }
  }
  ```

#### 3. 作者：xibaohe（★★★★☆）
- **关键亮点**：代码优化明显，使用`substr`简化输出。
- **代码亮点**：
  ```cpp
  cout<<s.substr(1,n-k+1)<<endl; // 直接截取主串
  for(int i=n-k+2;i<=n;i++) cout<<s[i]<<endl; // 输出单个字符
  ```

### 最优思路总结
**关键策略**：贪心选择前n-k+1个字符作为主串，后续字符单独拆分。通过哈希表/数组记录主串字符，确保后续字符均存在其中。  
**实现技巧**：  
1. 字符存在性检查：O(1)时间判断字符是否存在。  
2. 输出优化：利用字符串截取快速输出主串。

### 拓展与相关题目
- **类似题目推荐**：  
  1. [CF1178D] (字符串分段与回文判断)  
  2. [P1026] 字符串分割（NOIP2001）  
  3. [P1482] 字符串匹配问题（KMP应用）  
- **思维拓展**：此贪心策略适用于需最大化初始条件以满足后续约束的问题，如资源分配、区间覆盖等。

---
处理用时：221.48秒
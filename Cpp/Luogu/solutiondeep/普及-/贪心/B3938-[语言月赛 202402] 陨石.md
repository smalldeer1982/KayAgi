# 题目信息

# [语言月赛 202402] 陨石

## 题目背景

卷王来到了他的好朋友 bj12z_jiasiyuan 的农场，打算在那里过上一晚。但是在看新闻时，他们获得了一个不幸的消息，一场陨石雨就快要降临了……

## 题目描述

bj12z_jiasiyuan 的农场里有 $n$ 间牛棚，编号为 $1$ 到 $n$。第 $i$ 间牛棚的防御值为 $a_i$。

陨石雨将会**在 $t$ 秒后**来临。在陨石雨来临的时候，会有 $m$ 块陨石撞击牛棚，第 $i$ 块陨石会撞击到第 $x_i$ 间牛棚。当一块陨石撞击一间牛棚时，牛棚的防御值**会减去 $2$ 点**。而当一间牛棚的防御值 $\leq 0$ 时，牛棚会被破坏。

bj12z_jiasiyuan 有很多补给，每个补给可以给一间牛棚**增加 $1$ 点防御值**。幸运的是，卷王可以从一间牛棚瞬移到另一间牛棚（瞬移**不需花费任何时间**），用补给给牛棚增加防御值。每次补给需要 $1$ 秒的时间。

卷王只有 $t$ 秒种的时间可以出去补给，他希望让被破坏的牛棚越少越好。请你输出**最优策略下**被保护的牛棚的数量。

## 说明/提示

### 样例 1 解释

一种最优的补给方法是补给 $1$ 号牛棚 $1$ 点防御值，补给 $2$ 号牛棚 $2$ 点防御值。

在这种情况下，各牛棚防御值变化如下，其中蓝色数字代表初始防御值，绿色数字代表补给，红色数字代表陨石撞击：

- $1$ 号：${\color{blue} 2} + {\color{green}1} - {\color{red}2} = 1$；
- $2$ 号：${\color{blue} 1} + {\color{green}2} - {\color{red}2} = 1$；
- $3$ 号：${\color{blue} 3} - {\color{red}2} - {\color{red}2} = -1$；
- $4$ 号：${\color{blue} 5} - {\color{red}2} = 3$。

有且仅有 $3$ 号牛棚被破坏，可保护三个牛棚。

### 数据规模与约定

对于 $100\%$ 的数据，$1\leq x_i \leq n\leq 5 \times10^3$，$1\leq m\leq 10^6$，$0\leq t\leq 10^6$，$1\leq a_i \leq 10^6$，$1 \leq T \leq 5 \times 10^3$。  
保证单个测试点内所有测试数据 $n$ 的总和不超过 $5 \times 10^4$，所有测试数据 $m$ 的总和不超过 $3 \times 10^6$。

| 测试点编号 | 特殊限制 |
| :----------: | :----------: |
| $1, 2$ | $T = 1$，$n = 1$ |
| $3, 4$ | $T = 1$，每间牛棚恰好被击中一次 |
| $5$ | $T = 1$，$1\leq x_i \leq n \leq 100$ |
| $6$ | $T = 1$ |
| $7$ | $1\leq x_i \leq n \leq 100$ |
| $8 \sim 10$ | 无特殊限制 |

## 样例 #1

### 输入

```
1
4 3 5
2 1 3 5
3 1 2 4 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
4
3 4 2
5 2 4
2 1
3 2 20
6 6 6
1 3 3 1 2 1 1 1 2 2 2 1 1 3 1 2 2 3 3 1
2 0 2
1 2
1 1
5 3 12
4 5797 2 1 1
5 4 3 2 4 4 5 5 5 5 1 1
```

### 输出

```
3
0
1
3
```

# AI分析结果



### 综合分析与结论
本题核心在于通过贪心策略选择最优补给顺序，以最小化被破坏的牛棚数量。关键在于：
1. **预处理每个牛棚的撞击次数**，计算撞击后的防御值。
2. **计算每个牛棚所需补给的次数**，即 `max(0, 1 - 防御值)`。
3. **贪心选择补给次数最少的牛棚**，排序后优先补给，以最大化存活数量。

### 精选题解分析
#### 题解作者：Maxmilite（评分：4星）
**关键亮点**：
- 思路清晰，正确转换问题为计算所需补给量。
- 使用贪心策略，排序后按需分配补给。
- 处理了输入数据的高效统计。

**不足**：
- 使用冒泡排序导致时间复杂度高（应为快速排序优化）。

**核心代码**：
```cpp
// 统计每个牛棚的防御值
for (int i = 1; i <= m; ++i) {
    int x; cin >> x;
    a[x] -= 2;
}

// 计算所需补给并排序
vector<int> needs;
int survive = 0;
for (int i = 1; i <= n; ++i) {
    int s = max(0, 1 - a[i]);
    if (s == 0) survive++;
    else needs.push_back(s);
}
sort(needs.begin(), needs.end());

// 贪心分配补给
int cnt = 0, used = 0;
for (int s : needs) {
    if (used + s <= t) {
        used += s;
        cnt++;
    } else break;
}
cout << survive + cnt << endl;
```

### 关键思路总结
1. **问题转换**：将撞击后的防御值转化为所需补给的数学计算。
2. **贪心排序**：按补给量从小到大排序，最大化可救牛棚数。
3. **高效统计**：利用数组直接统计撞击次数，避免复杂结构。

### 拓展与举一反三
- **类似问题**：资源分配类问题（如背包问题、任务调度）。
- **优化点**：使用计数排序（若数据范围允许）进一步优化时间复杂度。

### 推荐练习题
1. **P1090 [NOIP2004 提高组] 合并果子**（贪心+优先队列）
2. **P1208 [USACO1.3] 混合牛奶 Mixing Milk**（贪心策略）
3. **P4995 跳跳！**（贪心选择最优路径）

---
处理用时：173.64秒
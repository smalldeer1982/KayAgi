# 题目信息

# [洛谷 202406GESP 模拟 四级] 锣鼓工厂

## 题目描述

小苏同学是锣鼓工厂的厂长。锣鼓工厂共有 $n$ 台机器，第 $i$ 台机器工作一天可以生产 $a_i$ 个锣鼓。因为环保、资金和保养问题，在接下来的 $n$ 天里，每天只能使用一台机器进行生产，每台机器在 $n$ 天里只能被使用一次。

同时，小苏接到了 $n$ 笔订单，第 $i$ 笔订单要求交付 $b_i$ 个锣鼓。小苏同学想知道，是否存在一种合理安排机器使用和交付订单的顺序，使得她在接下来的 $n$ 天里，每天都能交付一个订单？

## 说明/提示

### 样例 1 解释

- 在第一天使用编号为 $1$ 的机器生产了 $3$ 个锣鼓，交付编号为 $3$ 的订单 $3$ 个锣鼓。
- 在第二天使用编号为 $2$ 的机器生产了 $2$ 个锣鼓，交付编号为 $1$ 的订单 $2$ 个锣鼓。
- 在第三天使用编号为 $3$ 的机器生产了 $1$ 个锣鼓，交付编号为 $1$ 的订单 $1$ 个锣鼓。


### 样例 2 解释

我们解释第二组数据：

- 在第一天使用编号为 $2$ 的机器，生产了 $20$ 个锣鼓。交付编号为 $1$ 的订单 $15$ 个，剩余 $5$ 个；
- 在第二天使用编号为 $1$ 的机器，生产了 $10$ 个锣鼓，加上上一天的 $5$ 个，共 $15$ 个锣鼓，交付编号为 $2$ 的订单 $15$ 个，剩余 $0$ 个。
- 在第三天使用编号为 $3$ 的机器，生产了 $30$ 个锣鼓，共 $30$ 个锣鼓，交付编号为 $2$ 的订单 $15$ 个，剩余 $15$ 个。

### 提示

样例输出不唯一，仅供参考。

## 样例 #1

### 输入

```
1
3
3 2 1
1 2 3```

### 输出

```
Yes
1 2 3
3 2 1```

## 样例 #2

### 输入

```
2
5
1 2 3 4 5
2 3 4 5 6
3
10 20 30
15 15 15```

### 输出

```
No
Yes
2 1 3
1 2 3```

# AI分析结果



### 综合分析与结论

题目要求判断是否存在一种安排方式，使得每天使用一台机器生产并交付一个订单，且满足每天的累计生产量足够订单需求。关键在于确保每个前缀的生产总和足够对应前缀的订单总和，且总生产量足够。

**核心思路**：
1. **总和条件**：总生产量必须 ≥ 总订单量。
2. **前缀和条件**：将机器生产量降序排列，订单需求量降序排列，依次检查每个前 k 项的生产总和是否 ≥ 对应的订单前 k 项总和。
3. **构造顺序**：当条件满足时，将机器按生产量降序排列，订单按需求量降序排列即可得到可行解。

### 最优题解（5星）

**关键亮点**：
- **贪心策略**：通过排序确保最大的生产能力优先满足最大的需求，避免后续资源不足。
- **前缀和验证**：通过前缀和快速判断是否存在可行解，时间复杂度为 O(n log n)，高效可靠。
- **索引处理**：排序时保留原索引，便于输出符合题目要求的顺序。

**核心代码实现**：
```python
n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

sum_a = sum(a)
sum_b = sum(b)

if sum_a < sum_b:
    print("No")
else:
    sorted_a = sorted([(a[i], i+1) for i in range(n)], key=lambda x: (-x[0], x[1]))
    sorted_b = sorted([(b[i], i+1) for i in range(n)], key=lambda x: (-x[0], x[1]))
    
    a_vals = [x[0] for x in sorted_a]
    b_vals = [x[0] for x in sorted_b]
    
    valid = True
    pa, pb = 0, 0
    for k in range(n):
        pa += a_vals[k]
        pb += b_vals[k]
        if pa < pb:
            valid = False
            break
    if valid:
        print("Yes")
        print(' '.join(map(str, [x[1] for x in sorted_a])))
        print(' '.join(map(str, [x[1] for x in sorted_b])))
    else:
        print("No")
```

### 关键技巧总结
1. **贪心排序**：将问题转化为排序后的前缀和比较，确保每一步的最优性。
2. **稳定性处理**：当元素值相同时按原索引排序，保证输出唯一性。
3. **前缀和优化**：通过线性遍历前缀和避免复杂计算，提升效率。

### 拓展题目
1. **P1090**（合并果子）：贪心策略处理优先级队列。
2. **P1208**（混合牛奶）：贪心选择最优单价。
3. **P2240**（部分背包问题）：贪心按性价比排序。

---
处理用时：300.43秒
# 题目信息

# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# AI分析结果



### 综合分析与结论
本题需在长数字串中插入K个乘号使乘积最大，核心难点在于动态规划与高精度结合。题解主要采用两种思路：动态规划（DP）与DFS+剪枝。其中DP解法更为高效，正确处理高精度是关键。以下为评分≥4星的优质题解：

---

### 精选题解分析

#### 1. 作者：liar_white (⭐⭐⭐⭐⭐)
- **关键亮点**：
  - 使用结构体封装高精度数，清晰处理大数乘法和比较。
  - 动态规划状态`cut[i][j]`表示前i位插入j个乘号的最大值，转移时枚举分割点。
  - 代码完整，高精度乘法与比较逻辑严谨，注释详细。
- **个人心得**：在状态转移中发现需通过中间变量暂存结果避免错误，体现调试经验。

**核心代码**：
```cpp
struct node {
    int v; bool exi; int c[50];
} cut[50][10], ans[50];
// 状态转移核心逻辑
for (int i=1; i<=n; i++) {
    cut[i][1] = culc(1,i); // 初始化
    for (int j=2; j<=k; j++) {
        for (int fr=j-1; fr<i; fr++) {
            if (cut[fr][j-1].exi) 
                cut[i][j] = Max(cut[i][j], mul(cut[fr][j-1], culc(fr+1,i)));
        }
    }
    if (cut[i][k].exi) ans[i] = mul(cut[i][k], culc(i+1,n));
}
```

#### 2. 作者：FastIO_DP (⭐⭐⭐⭐⭐)
- **关键亮点**：
  - 结构体`BI`封装高精度，代码简洁且可读性高。
  - 状态定义`dp[i][j]`为前i位分j段的最大乘积，转移方程清晰。
  - 高精度乘法优化到位，直接处理进位与位数调整。

**核心代码**：
```cpp
struct BI { // 高精度结构体
    int d[100], len;
    BI operator*(const BI& o) const { // 乘法重载
        BI res;
        for (int i=0; i<len; i++)
            for (int j=0; j<o.len; j++)
                res.d[i+j] += d[i] * o.d[j];
        // 处理进位...
        return res;
    }
};
// DP转移逻辑
for (int j=1; j<=K; j++) {
    for (int i=j; i<N; i++) {
        for (int k=j-1; k<i; k++) {
            BI t = dp[k][j-1] * num(k+1, i);
            if (dp[i][j] < t) dp[i][j] = t;
        }
    }
}
```

#### 3. 作者：kuaiCreator (⭐⭐⭐⭐)
- **关键亮点**：
  - 详细讲解划分型DP思路，状态转移方程推导清晰。
  - 提供非高精度代码框架，便于理解核心DP逻辑。
  - 强调高精度实现的必要性，指导正确解题方向。

**核心思路**：
```cpp
// 状态转移方程伪代码
dp[i][j] = max(dp[k][j-1] * num(k+1, i)) (k从j-1到i-1)
```

---

### 最优关键思路总结
1. **DP状态设计**：定义`dp[i][j]`为前i位插入j个乘号的最大乘积，需枚举最后一个乘号位置分割左右段。
2. **高精度实现**：通过结构体封装大数，重载乘法和比较运算符，确保运算正确。
3. **剪枝优化**（DFS解法）：剩余数字位数需足够放置剩余乘号，避免无效搜索。

---

### 拓展与相似题目推荐
1. **P1435 回文字符串**（区间DP，分割问题）
2. **P1017 进制转换**（高精度处理与数制转换）
3. **P1005 矩阵取数游戏**（高精度+动态规划）

---

### 个人心得摘录
- **调试经验**：`liar_white`提到直接比较`Max`函数需用中间变量，否则可能出错，体现边界条件的重要性。
- **实现技巧**：`FastIO_DP`的结构体封装使代码模块化，便于维护和调试。

---
处理用时：69.15秒
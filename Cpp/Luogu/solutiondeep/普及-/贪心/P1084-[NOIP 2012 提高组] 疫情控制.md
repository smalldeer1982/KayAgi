# 题目信息

# [NOIP 2012 提高组] 疫情控制

## 题目描述

H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。

H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。


## 说明/提示

【输入输出样例说明】

第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到$ 3$ 号点设立检查点，所需时间为 $3$ 个小时。

 
【数据范围】

保证军队不会驻扎在首都。

- 对于 $20\%$ 的数据，$2 \le n\le 10$；
- 对于 $40\%$ 的数据，$2 \le n\le 50$，$0<w <10^5$；
- 对于 $60\%$ 的数据，$2 \le n\le 1000$，$0<w <10^6$；
- 对于 $80\%$ 的数据，$2 \le n\le 10^4$；
- 对于 $100\%$ 的数据，$2\le m\le n≤5\times 10^4$，$0<w <10^9$。


NOIP 2012 提高组 第二天 第三题


## 样例 #1

### 输入

```
4 
1 2 1 
1 3 2 
3 4 3 
2 
2 2```

### 输出

```
3```

# AI分析结果



### 综合分析结论
该题核心解法为二分答案+树上贪心，所有题解均基于此框架。差异主要体现在预处理方式（倍增/DFS）、剩余军队分配策略、子树覆盖判断方法等。关键难点在于如何高效验证二分的时间是否可行，以及处理军队跨子树分配的贪心策略。

---

### 精选题解与亮点

#### 1. TEoS（★★★★★）
**关键亮点**：
- 完整清晰的四步流程：倍增预处理→二分答案→贪心上移→子树匹配
- 详细讲解如何用`pair`存储闲置军队，并处理子树间的优先级
- 代码模块化，逻辑分层明确

**核心实现**：
```cpp
// 上移军队并分类处理
for(int i=1;i<=m;i++){
    ll cnt=0,x=query[i];
    for(int j=t;j>=0;j--) // 倍增上跳
        if(f[x][j]>1 && cnt+dist[x][j]<=mid)
            cnt+=dist[x][j],x=f[x][j];
    if(f[x][0]==1) // 能到根节点
        h[++ctot]=make_pair(mid-cnt-dist[x][0],x);
    else // 不能到根节点
        sta[x]=1;
}
```

#### 2. FlashHu（★★★★☆）
**创新点**：
- 提出线性DFS替代倍增，复杂度降为O(n logW)
- 利用动态规划思想维护子树控制状态
- 通过排序优化军队分配

**核心思路**：
```cpp
bool dfs(int u,int fa){
    bool res=1;
    for(int v:e[u]) if(v!=fa){
        res&=dfs(v,u); // 子树全被控制则当前节点被控制
        dis[u]=min(dis[u],dis[v]+w);
    }
    if(dis[u]<=mid) res=1; // 子树军队可覆盖
    return res;
}
```

#### 3. Siyuan（★★★★☆）
**优化技巧**：
- 使用`lower_bound`快速定位可用军队
- 预处理各子树到根的距离加速匹配
- 精简的贪心策略实现

**关键代码**：
```cpp
sort(army, army+m, [](int a,int b){ return rest[a]>rest[b]; });
sort(need, need+k, greater<>());
int i=0,j=0;
while(i<k && j<m){
    if(army[j].rest >= need[i]) i++,j++;
    else j++;
}
return i == k;
```

---

### 关键技巧总结
1. **倍增预处理**：快速计算军队最大上移位置，降低单次判断复杂度至O(logn)
2. **子树覆盖标记**：通过DFS后序遍历判断哪些子树需要外部支援
3. **双指针贪心**：将剩余军队与待覆盖子树排序后匹配，保证最优分配
4. **临界处理**：对能到根但无法返回的军队优先处理原属子树

---

### 同类题目推荐
1. P5021 [NOIP2018] 赛道修建（树二分+贪心）
2. P4381 [IOI2008] Island（基环树直径）
3. P1266 速度限制（DAG上动态规划）

---

### 调试经验摘录
1. **边界处理**：军队恰好到达根节点时，剩余时间需扣除最后一步的边权（TEoS代码中的`mid-cnt-dist[x][0]`）
2. **覆盖误判**：需注意非叶子节点即使自身未被驻守，若所有子树被控则视为已控（FlashHu的DFS返回值处理）
3. **排序稳定性**：对军队和子树进行稳定排序，确保匹配时优先级正确（Siyuan题解中的双排序策略）

---
处理用时：45.19秒
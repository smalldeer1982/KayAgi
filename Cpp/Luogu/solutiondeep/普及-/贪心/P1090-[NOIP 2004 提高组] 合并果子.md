# 题目信息

# [NOIP 2004 提高组] 合并果子

## 题目描述

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $=3+12=15$ 。可以证明 $15$ 为最小的体力耗费值。

## 说明/提示

对于 $30\%$ 的数据，保证有 $n \le 1000$：

对于 $50\%$ 的数据，保证有 $n \le 5000$；

对于全部的数据，保证有 $n \le 10000$。


## 样例 #1

### 输入

```
3 
1 2 9 
```

### 输出

```
15
```

# AI分析结果



### 综合分析与结论
本题本质是构造哈夫曼树求带权路径和，核心贪心策略为每次合并最小的两堆。主流解法包括优先队列、手写堆、双队列优化三种方向。其中：
1. **STL优先队列**实现最简洁（时间复杂度O(n log n)）
2. **双队列法**通过排序+合并队列实现线性复杂度（时间复杂度O(n)）
3. **手写堆**在常数时间上更优，适合对效率要求高的场景

### 高评分题解推荐
#### 1. QuantAsk（⭐⭐⭐⭐⭐）
- **关键亮点**：桶排序预处理后使用双队列合并，实现O(n)时间复杂度
- **核心代码思想**：
  ```cpp
  // 桶排序生成有序队列a1
  for(int i=1;i<=20000;i++) while(t[i]) a1[++n1]=i; 
  // 双队列合并逻辑
  while(k<num) {
    w = min(a1[i],a2[j]);  // 取两队列中的最小值
    w += min(a1[i],a2[j]); // 再取次小值
    sum += w;              // 累加体力消耗
    a2[++n2] = w;          // 合并结果存入第二队列
  }
  ```

#### 2. 学委（⭐⭐⭐⭐）
- **关键亮点**：结合哈夫曼树理论证明，给出严谨的数学推导
- **代码亮点**：STL优先队列的教科书式应用
  ```cpp
  priority_queue<int,vector<int>,greater<int>> q;
  while(q.size()>1) {
    int x=q.top(); q.pop();
    int y=q.top(); q.pop();
    ans += x+y;
    q.push(x+y);
  }
  ```

#### 3. 微雨燕双飞（⭐⭐⭐⭐）
- **关键亮点**：完整手写堆实现，适合学习底层原理
- **调试心得**：通过注释明确堆的调整方向（向上/向下）
  ```cpp
  void down(int p) { // 小根堆下沉调整
    int s=p*2;
    while(s<=size) {
      if(s<size && heap[s+1]<heap[s]) s++; 
      if(heap[s]<heap[p]) swap(heap[s],heap[p]);
      else break;
    }
  }
  ```

### 关键优化技巧
1. **双队列合并**：通过预排序+两个有序队列的合并，避免堆的log复杂度
2. **桶排序预处理**：利用数值范围较小（1≤a_i≤2e4）的特点实现线性排序
3. **堆结构体封装**：通过结构体封装堆操作提升代码复用性（如sigland的解法）

### 拓展题目推荐
1. [P1334 瑞瑞的木板](https://www.luogu.com.cn/problem/P1334) - 同类合并问题逆向思维
2. [P2168 [NOI2015]荷马史诗](https://www.luogu.com.cn/problem/P2168) - k叉哈夫曼树扩展
3. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094) - 双指针贪心策略

### 实用调试经验
- **QuantAsk**：注意初始队列的极大值填充（`memset(a1,127/3,sizeof(a1))`），避免空队列判断错误
- **sigland**：手写堆通过`heap[0] = -1e9`设置哨兵，简化边界条件判断
- **学委**：强调优先队列的`ans`使用long long类型，防止数据溢出（虽原题数据未达上限）

---
处理用时：52.06秒
# 题目信息

# 单词方阵

## 题目描述

给一 $n \times n$ 的字母方阵，内可能蕴含多个 `yizhong` 单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 $8$ 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉，因此有可能共用字母。输出时，将不是单词的字母用 `*` 代替，以突出显示单词。

## 样例 #1

### 输入

```
7
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
```

### 输出

```
*******
*******
*******
*******
*******
*******
*******
```

## 样例 #2

### 输入

```
8
qyizhong
gydthkjy
nwidghji
orbzsfgz
hhgrhwth
zzzzzozo
iwdfrgng
yyyygggg```

### 输出

```
*yizhong
gy******
n*i*****
o**z****
h***h***
z****o**
i*****n*
y******g```

# AI分析结果



### 综合分析与结论
本题核心在于沿固定方向匹配字符串"yizhong"。题解主要采用两种思路：① 预处理所有'y'的位置后进行8方向线性扫描 ② DFS/BFS递归遍历方向。关键优化点包括方向数组预处理、路径标记染色、方向一致性保证。

### 高星题解推荐
1. **灯芯糕（4.5星）**
   - **亮点**：代码简洁高效，预处理所有'y'位置，使用递归进行方向匹配，染色标记思路清晰
   - **核心代码**：
     ```cpp
     bool f(int i,int j,int m,int n,int next){
         if(next>=8){ s[i][j]=1; return 1; }
         if(a[i+m][j+n]==k[next] && f(i+m,j+n,m,n,next+1)){
             s[i][j]=1; return 1;
         }
         return 0;
     }
     ```
     - 递归验证字符链，找到时回溯标记路径

2. **拱垲（4.5星）**
   - **亮点**：详细分析错误原因，引入方向参数确保路径方向一致，switch-case处理方向分支
   - **关键实现**：
     ```cpp
     switch (f) { // 根据方向参数选择递归分支
         case 1: if(dfs(n-1,m-1,no+1,f)){...} // 左上方向
         case 5: // 初始方向，向所有方向扩展
     }
     ```
   - **心得**：强调方向一致的重要性，指出60分代码因方向不固定导致错误

3. **hzg0226（4星）**
   - **亮点**：使用结构体记录路径，先完整验证再标记，逻辑清晰
   - **核心思路**：
     ```cpp
     void dfs(int x,int y,node c[],int k,int cur){
         if(cur==7) for(int i=0;i<7;i++) vis[c[i].x][c[i].y]=1;
         else if(a[x][y]==stand[cur]) dfs(x+dir[k][0], y+dir[k][1], c, k, cur+1);
     }
     ```

### 最优关键思路
1. **方向数组预处理**：定义8个方向的dx/dy偏移量数组
   ```cpp
   const int dir[8][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};
   ```
2. **线性验证**：对每个'y'沿8方向检查后续6个字符是否符合"izhong"
3. **染色标记**：验证成功后，沿原方向回溯标记路径

### 相似题目推荐
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 连通块方向搜索
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - 矩阵边界扩展搜索
3. [P1036 选数](https://www.luogu.com.cn/problem/P1036) - 组合数验证的DFS应用

### 重点代码片段（拱垲方向处理）
```cpp
// 方向参数传递确保路径方向一致
int dfs(int n,int m,int no,int f){
    if(no==7) return 1;
    switch(f){
        case 1: return dfs(n-1,m-1,no+1,f); // 左上
        case 2: return dfs(n-1,m,no+1,f);   // 上
        // ...其他方向处理
        case 5: // 初始状态需尝试所有方向
            dfs(n-1,m-1,no+1,1);
            dfs(n-1,m,no+1,2);
            // ...其他方向调用
    }
}
```

---
处理用时：81.59秒
# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题核心在于将数对关系转化为查找问题，主流解法集中在哈希映射、二分查找、双指针三种思路。最优解法时间复杂度为O(n)或O(n log n)，需注意大数据下的常数优化与long long处理。

---

### 高分题解亮点与核心代码

#### 1. 双指针法（jins3599） ★★★★★
**关键思路**：排序后维护两个右指针，分别找到第一个满足差值的区间端点，利用单调性实现O(n)时间。
```cpp
int l = 1, r1 = 1, r2 = 1;
for (l = 1; l <= n; l++) {
    while (r1 <= n && a[r1] - a[l] <= c) r1++;
    while (r2 <= n && a[r2] - a[l] < c) r2++;
    if (a[r2] - a[l] == c) ans += r1 - r2;
}
```
**亮点**：线性复杂度，无需额外空间，完美处理重复元素。  
**心得**：利用排序后的单调性，双指针维护区间边界是同类问题的通用技巧。

#### 2. 二分查找（樱花飞舞） ★★★★☆
**关键思路**：排序后对每个元素a[i]，用upper_bound和lower_bound计算a[i]+c的出现次数。
```cpp
sort(a+1, a+n+1);
for (int i=1; i<=n; i++) {
    ans += upper_bound(a+1, a+n+1, a[i]+c) - 
           lower_bound(a+1, a+n+1, a[i]+c);
}
```
**亮点**：代码简洁，STL函数调用高效，适合快速实现。  
**注意点**：需预先排序，时间复杂度O(n log n)。

#### 3. 哈希映射（OsvaldoAsensioLopez） ★★★★
**关键思路**：用map统计数字出现次数，遍历时直接查询a[i]-c的频次。
```cpp
map<LL, LL> m;
for (int i=1; i<=n; i++) {
    m[a[i]]++;
    a[i] -= c;
}
for (int i=1; i<=n; i++) ans += m[a[i]];
```
**亮点**：代码极简，逻辑直观。  
**优化建议**：可改用unordered_map减少常数时间。

---

### 关键思路总结
1. **问题转换**：将A-B=C改写为B=A-C，转化为查找问题。
2. **预处理排序**：使二分查找、双指针等算法得以应用。
3. **频次统计**：通过哈希或数组直接记录元素出现次数。
4. **去重优化**：对连续相同元素批量计算（乘法原理）。

---

### 拓展练习推荐
1. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102)（本题）
2. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（二分答案+贪心）
3. [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)（双指针/前缀和）
4. [P2648 赚钱](https://www.luogu.com.cn/problem/P2648)（哈希映射+路径统计）

---
处理用时：63.37秒
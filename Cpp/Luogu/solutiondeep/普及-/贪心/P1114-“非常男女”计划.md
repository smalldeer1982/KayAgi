# 题目信息

# “非常男女”计划

## 题目描述

近来，初一年的 `XXX` 小朋友致力于研究班上同学的配对问题（别想太多，仅是舞伴），通过各种推理和实验，他掌握了大量的实战经验。例如，据他观察，身高相近的人似乎比较合得来。

万圣节来临之际，`XXX` 准备在学校策划一次大型的 “非常男女” 配对活动。对于这次活动的参与者，`XXX` 有自己独特的选择方式。他希望能选择男女人数相等且身高都很接近的一些人。这种选择方式实现起来很简单。他让学校的所有人按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。为了使活动更热闹，`XXX` 当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。


## 样例 #1

### 输入

```
9
0 1 0 0 0 1 1 0 0
```

### 输出

```
6```

# AI分析结果



### 综合分析与结论
本题核心是寻找最长连续子数组使得男女人数相等。最优解法基于前缀和差值思想：将女生视为-1，男生为1，计算前缀和。当两个位置前缀和相等时，其区间男女数量相等。通过记录差值首次与最后出现位置，可在O(n)时间复杂度内求解。

---

### 高星题解推荐

#### 1. AKB48（★★★★★）
**关键亮点**  
- 提出"相对差"概念，直接命中问题核心  
- 代码简洁高效，仅用两个数组记录差值边界  
- 巧妙处理初始差值为0的情况（a[0]=0）  

**核心代码**  
```cpp
int l[200010],r[200010],sum1,sum0,ans,n;
// 遍历时维护差值并记录边界
int t=sum0-sum1+n; // 加n处理负数
if (!l[t]&&t!=n) l[t]=i; else r[t]=i;
// 最终遍历所有差值求最大区间
for(int i=0;i<=2*n;i++) ans=max(ans,r[i]-l[i]);
```

#### 2. Bring（★★★★☆）
**关键亮点**  
- 使用单数组存储首次出现位置，空间优化  
- 极简代码实现（仅20行）  
- 动态维护最大差值，无需二次遍历  

**核心优化**  
```cpp
int p[N],s,ans; // p存储前缀和首次出现位置
P(0)=0; // 初始差值为0的位置设为0
for(int i=1;i<=n;i++) {
    s += a[i] ? 1 : -1;     // 实时计算前缀和
    ~P(s) ? ans=max(ans,i-P(s)) : P(s)=i; // 动态更新答案
}
```

#### 3. KellyFrog（★★★★☆）
**调试经验**  
> "当sum数组全负时会RE，加100010偏移量解决。调了40分钟明白偏移量必须足够大"  
**启示**：处理负数下标时偏移量需大于最大可能负值（通常取n）

**算法要点**  
```cpp
struct Node{ int _min=1e9, _max=-1e9; } hash[200020];
// 遍历时记录最小最大位置
hash[sum[i]+100010]._min = min(hash[sum[i]+100010]._min, i);
hash[sum[i]+100010]._max = i;
```

---

### 关键思路总结
**核心技巧**：  
1. **符号转换**：将问题转化为前缀和问题（男1女-1）  
2. **差值记录**：用哈希表/数组记录每个差值首次出现位置  
3. **偏移处理**：给前缀和加n避免负数下标  
4. **边界处理**：初始化差0的位置为0（虚拟起点）

**同类型题目套路**：  
- 寻找和为特定值的子数组（如两数之和扩展）  
- 统计满足条件的连续区间  
- 利用前缀和差值的哈希优化

---

### 推荐练习题目
1. **P1102 A-B数对** - 差值的哈希应用  
2. **P3131 [USACO16JAN]子共七Subsequences Summing to Sevens** - 前缀和同余性质  
3. **P3406 海底高铁** - 前缀和经典应用场景

---

### 核心代码实现
以AKB48的算法为例的完整核心逻辑：
```cpp
#include <iostream>
using namespace std;

const int N = 2e5+10;
int l[N], r[N], n, ans;

int main() {
    cin >> n;
    int diff = n; // 初始差值为0，偏移量为n
    l[diff] = 0;  // 虚拟起点位置0
    
    for(int i=1, x; i<=n; ++i) {
        cin >> x;
        diff += (x == 0 ? 1 : -1); // 计算当前差值
        
        if(!l[diff] && diff != n) l[diff] = i;
        else r[diff] = i;
    }
    
    for(int i=0; i<=2*n; ++i)
        ans = max(ans, r[i] - l[i]);
        
    cout << ans;
    return 0;
}
```

---
处理用时：61.31秒
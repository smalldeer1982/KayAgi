# 题目信息

# 打砖块

## 题目描述

小红很喜欢玩一个叫打砖块的游戏，这个游戏的规则如下：

在刚开始的时候，有 $n$ 行 $m$ 列的砖块，小红有 $k$ 发子弹。小红每次可以用一发子弹，打碎某一列当前处于这一列最下面的那块砖，并且得到相应的得分。（如图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/twgirdp6.png)

某些砖块在打碎以后，还可能将得到一发子弹的奖励。最后当所有的砖块都打碎了，或者小红没有子弹了，游戏结束。

小红在游戏开始之前，就已经知道每一块砖在打碎以后的得分，并且知道能不能得到一发奖励的子弹。小红想知道在这次游戏中她可能的最大得分，可是这个问题对于她来说太难了，你能帮帮她吗？


## 说明/提示

对于 $20\%$ 的数据，满足 $1  \le n,m  \le 5$，$1  \le k  \le 10$，所有的字符 $c$ 都为 `N`。

对于 $50\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，所有的字符 $c$ 都为 `N`。

对于 $100\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，字符 $c$ 可能为 `Y`。

对于 $100\%$ 的数据，所有的 $f$ 值满足 $1  \le f  \le 10000$。


## 样例 #1

### 输入

```
3 4 2
9 N 5 N 1 N 8 N
5 N 5 Y 5 N 5 N
6 N 2 N 4 N 3 N```

### 输出

```
13```

# AI分析结果



### 综合分析与结论
本题核心在于动态规划结合预处理，处理"子弹借用"与"状态后效性"问题。所有题解均采用以下关键步骤：
1. **预处理**：对每列计算不同子弹数下的得分，区分最后一发子弹是否打在N砖块
2. **状态设计**：以`dp[i][j][0/1]`表示前i列用j发子弹，最后是否打在N砖块
3. **分组背包**：将每列视为物品组，子弹数作为容量进行转移

关键难点在于处理子弹奖励带来的后效性，解决方法是通过状态区分最后一发子弹的位置。

---

### 高评分题解推荐

#### 1. 作者：Azuree (★★★★★)
**亮点**：
- 最清晰的预处理与状态转移解释
- 完整代码包含详细注释，变量命名规范
- 明确区分sum1/sum2两种得分计算方式
```cpp
// 预处理核心代码
for(int i=1;i<=m;i++) {
    int cnt=0;
    for(int j=n;j>=1;j--) {
        if(b[j][i]) 
            sy[i][cnt] += a[j][i];
        else {
            cnt++;
            sy[i][cnt] = sy[i][cnt-1] + a[j][i];
            sn[i][cnt] = sy[i][cnt-1] + a[j][i];
        }
    }
}
// DP转移逻辑
for(int i=1;i<=m;i++)
    for(int j=0;j<=k;j++)
        for(int l=0;l<=min(n,j);l++) {
            f[i][j][1] = max(f[i][j][1],f[i-1][j-l][1]+sy[i][l]);
            if(l) f[i][j][0] = max(f[i][j][0],f[i-1][j-l][1]+sn[i][l]);
            if(j>l) f[i][j][0] = max(f[i][j][0],f[i-1][j-l][0]+sy[i][l]);
        }
```

#### 2. 作者：I_AM_HelloWord (★★★★☆)
**亮点**：
- 独创"借子弹"的具象化比喻
- 引入压缩连续Y砖块的思想
- 代码包含优化后的预处理逻辑
**心得**：
> "借子弹的比喻让我顿悟——子弹不会凭空增加，但通过调整击打顺序，可以等效实现子弹借用"

#### 3. 作者：cqbzjyh (★★★★☆)
**亮点**：
- 最简洁的代码实现
- 明确分离dn/dy两种状态计算
- 三重循环结构最易理解
```cpp
// 状态转移核心
for(int i=1;i<=m;i++)
    for(int j=0;j<=k;j++)
        for(int l=0;l<=min(n,j);l++) {
            dpy[i][j] = max(dpy[i][j], dpy[i-1][j-l] + dy[i][l]);
            if(l) dpn[i][j] = max(dpn[i][j], dpy[i-1][j-l] + dn[i][l]);
            if(j != l) dpn[i][j] = max(dpn[i][j], dpn[i-1][j-l] + dy[i][l]);
        }
```

---

### 关键思路总结
1. **Y砖块压缩**：将连续的Y砖块得分合并到其下方的N砖块，减少决策点
2. **状态机设计**：通过`[0/1]`状态区分最后一发子弹位置，消除后效性
3. **子弹借用机制**：通过状态转移实现等效的子弹顺序调整

---

### 相似题目推荐
1. P1776 宝物筛选（分组背包经典题）
2. P1941 飞扬的小鸟（状态机DP）
3. P2014 选课（树形依赖背包）

---
处理用时：56.40秒
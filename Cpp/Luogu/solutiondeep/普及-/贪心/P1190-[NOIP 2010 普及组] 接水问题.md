# 题目信息

# [NOIP 2010 普及组] 接水问题

## 题目描述

学校里有一个水房，水房里一共装有 $m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为 $1$。

现在有 $n$ 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 $1$ 到 $n$ 编号，$i$ 号同学的接水量为 $w_i$。接水开始时，$1$ 到 $m$ 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学 $j$ 完成其接水量要求 $w_j$ 后，下一名排队等候接水的同学 $k$ 马上接替 $j$ 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 $j$ 同学第 $x$ 秒结束时完成接水，则 $k$ 同学第 $x+1$ 秒立刻开始接水。若当前接水人数 $n'$ 不足 $m$，则只有 $n'$ 个龙头供水，其它 $m - n'$ 个龙头关闭。

现在给出 $n$ 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。


## 说明/提示

【输入输出样例 \#1 说明】

第 $1$ 秒，$3$ 人接水。第 $1$ 秒结束时，$1,2,3$ 号同学每人的已接水量为 $1,3$ 号同学接完水，$4$ 号同学接替 $3$ 号同学开始接水。

第 $2$ 秒，$3$ 人接水。第 $2$ 秒结束时，$1,2$ 号同学每人的已接水量为 $2,4$ 号同学的已接水量为 $1$。

第 $3$ 秒，$3$ 人接水。第 $3$ 秒结束时，$1,2$ 号同学每人的已接水量为 $3,4$ 号同学的已接水量为 $2$。$4$ 号同学接完水，$5$ 号同学接替 $4$ 号同学开始接水。

第 $4$ 秒，$3$ 人接水。第 $4$ 秒结束时，$1,2$ 号同学每人的已接水量为 $4,5$ 号同学的已接水量为 $1$。$1,2,5$ 号同学接完水，即所有人完成接水的总接水时间为 $4$ 秒。

【数据范围】

$1 \le n \le {10}^4$，$1 \le m \le 100$，$m \le n$；

$1 \le w_i \le 100$。

NOIP2010 普及组 第二题


## 样例 #1

### 输入

```
5 3
4 4 1 2 1
```

### 输出

```
4```

## 样例 #2

### 输入

```
8 4
23 71 87 32 70 93 80 76
```

### 输出

```
163```

# AI分析结果



### 综合分析与结论
本题核心在于合理安排接水顺序以最小化总时间。各题解主要采用模拟、贪心或优先队列三种思路。其中优先队列（小根堆）方法以 O(n log m) 的时间复杂度最优，贪心法（遍历找最小）在 m 较小时同样高效，模拟法最直观但效率较低。

---

### 精选题解与评分

#### 1. 作者：WsW_（★★★★★）
**关键亮点**  
- **优先队列维护**：用优先队列动态追踪最早可用的水龙头，保证每次分配最优  
- **时间复杂度低**：O(n log m) 时间效率极高  
- **代码简洁清晰**：仅用 20 行代码实现核心逻辑  

**核心代码**  
```cpp
priority_queue<int, vector<int>, greater<int>> q;
for(int i=1; i<=m; i++) q.push(w[i]);
for(int i=m+1; i<=n; i++){
    int t = q.top(); q.pop();
    q.push(t + w[i]);
}
// 最终答案为堆中最大值
```

---

#### 2. 作者：kuaiCreator（★★★★★）
**关键亮点**  
- **小根堆优化**：初始将水龙头时间设为0，统一处理逻辑  
- **贪心策略明确**：每次选择结束时间最小的水龙头  
- **代码规范易懂**：完整注释与变量命名清晰  

**核心代码**  
```cpp
priority_queue<int, vector<int>, greater<int>> tap;
for(int i=1; i<=m; i++) tap.push(0);
for(int i=1; i<=n; i++){
    int temp = tap.top(); tap.pop();
    tap.push(temp + p[i]);
}
// 最终堆顶最大值即答案
```

---

#### 3. 作者：mairuisheng（★★★★☆）
**关键亮点**  
- **直接贪心实现**：遍历找最小值，适合 m 较小场景  
- **无需复杂结构**：仅用数组即可实现，适合初学者理解  
- **代码效率合格**：O(nm) 时间在 m=100 时完全可行  

**核心代码**  
```cpp
int p[101] = {0}; // 水龙头时间数组
for(int i=1; i<=n; i++){
    int min_idx = 找到 p 中最小值的下标;
    p[min_idx] += w[i];
}
// 最终取 p 数组最大值
```

---

### 关键思路总结
**最优解法**：使用优先队列（小根堆）维护各水龙头当前结束时间，每次取出最小时间的龙头分配下个学生，总时间复杂度 O(n log m)。  
**实现要点**：  
1. 初始化时将前 m 个学生的接水时间入队  
2. 后续每个学生取出队首时间 t，将 t + 新时间入队  
3. 最终队列中的最大值为答案  

**代码片段示例**  
```cpp
priority_queue<int, vector<int>, greater<int>> q;
for (int i = 1; i <= m; i++) q.push(0); // 初始空龙头
for (int w : students) {
    int t = q.top(); q.pop();
    q.push(t + w);
}
// 最终答案：遍历堆找最大值
```

---

### 同类题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子** - 优先队列经典应用  
2. **P1223 [JSOI2007] 排队接水** - 贪心排序优化接水顺序  
3. **P1809 过河问题** - 时间调度与资源分配的结合  

---

### 个人心得摘录
- **lk_liang**：模拟法需注意终止条件 `t <= n + m`，因所有学生分配后还需处理剩余接水  
- **xxckie**：初始将前 m 人排序，确保后续每次选择最小值的正确性  
- **WsW_**：强调题目要求必须保持初始顺序，不能随意插队，需用堆维护而非纯贪心

---
处理用时：76.76秒
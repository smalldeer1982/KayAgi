# 题目信息

# 坚果保龄球

## 题目描述

PVZ 这款游戏中，有一种坚果保龄球。zombie 从地图右侧不断出现，向左走，玩家需要从左侧滚动坚果来碾死他们。

我们可以认为地图是一个行数为 $6$，列数为 $60$ 的棋盘。zombie 出现的那一秒站在这一行的第 $60$ 列，之后每秒向左移动一步。玩家可以随时在屏幕最某一行第一列摆放坚果，这一行的 zombie 瞬间全被滚过去的坚果碾死。如果 zombie 走到第 $1$ 列没有被消灭，如果再向左走，则你的大脑就会被 zombie 吃掉。

现在有 $n$ 只 zombie！告诉你每只 zombie 出现的时间以及在出现的行数（可能会同时出现同一位置的僵尸），请问至少需要多少坚果才能消灭所有的 zombie。

## 说明/提示

### 数据范围及约定

对于全部数据，$n \le 2000$，$t \le 100000$，$1 \le P \le 6$。

### 题目来源

kkksc03 改编


## 样例 #1

### 输入

```
10
1 1
1 61
2 1
2 60
3 1
3 2
3 3
3 4
4 1
4 99999```

### 输出

```
6```

# AI分析结果



### 综合分析与结论
本题核心是贪心算法：对每行僵尸按出现时间排序，每次在最晚必须放置坚果的时间点（僵尸到达第1列时）放置，覆盖该时间点前59秒内的所有僵尸。各题解均基于此思路，差异在于时间覆盖判断方式与代码实现细节。

### 高星题解推荐
#### 1. 作者：x义x（5星）
**关键亮点**  
- 思路清晰明确，按行分组后排序处理，覆盖时间判断逻辑严谨。
- 核心代码简洁高效，用指针跳跃式遍历时间窗口，避免重复计算。
- 注释详细，包含调试经验（如行数错误、时间判断边界问题）。

**核心代码片段**  
```cpp
for(int i=1;i<=6;i++) {
    sort(t[i]+1, t[i]+1+j[i]); // 按时间排序
    int x=1;
    while(x <= j[i]) {
        ans++;
        int x1 = x;
        while(t[i][x1] < t[i][x]+60) x1++; // 找到下一个超出时间窗口的僵尸
        x = x1;
    }
}
```

#### 2. 作者：zy小可爱ღ（4星）
**关键亮点**  
- 使用结构体排序后线性扫描，逻辑直观。
- 通过时间差判断是否需要新坚果，代码可读性强。
- 处理了同一行连续时间窗口的合并。

**核心代码片段**  
```cpp
sort(a+1, a+n+1, cmp); // 按行和时间排序
for(int i=1; i<=n; ){
    int f = a[i].s, p = a[i].t;
    ans++;
    for(i++; f == a[i].s; i++) {
        if(a[i].t - p >= 60) { // 时间差超限则重置
            ans++;
            p = a[i].t;
        }
    }
}
```

#### 3. 作者：MloVtry（4星）
**关键亮点**  
- 按行和时间双重排序后线性处理，逻辑清晰。
- 通过换行判断与时间差双重条件控制计数。
- 代码简洁，适合新手理解贪心思想。

**核心代码片段**  
```cpp
sort(zob+1, zob+n+1, comp); // 按行和时间排序
int las_t = zob[1].tim, las_r = zob[1].row;
for(int i=2; i<=n; i++) {
    if(zob[i].row != las_r) { // 换行则强制计数
        ans++;
        las_t = zob[i].tim;
        las_r = zob[i].row;
    } else if(zob[i].tim - las_t >=60) { // 时间差超限计数
        ans++;
        las_t = zob[i].tim;
    }
}
```

### 关键思路与技巧总结
1. **分治处理**：将问题拆分为6个独立行处理，降低复杂度。
2. **排序预处理**：按时间排序后，时间窗口合并转化为线性扫描。
3. **时间窗口跳跃**：通过`x += 59`或指针跳跃直接跳过已覆盖区间。
4. **边界处理**：特别注意`t+59`与`t+60`的差异（僵尸到达第1列需59秒移动）。

### 调试与踩坑经验
- **行数错误**：PVZ实际为5行，题目设定6行（x义x调试经历）。
- **时间差判断**：必须用`< t[x]+60`而非`<=`，否则样例无法通过（x义x注释）。
- **数据范围**：时间值可能极大，需避免数组越界（qxy题解用`j+=59`优化遍历）。

### 拓展题目推荐
1. **P1803 凌乱的yyy / 线段覆盖**（区间贪心调度）
2. P2240 【深基12.例1】部分背包问题（经典贪心思想）
3. P1106 删数问题（贪心策略与局部最优）

### 相似代码片段（关键实现）
```cpp
// 核心贪心逻辑：跳跃式覆盖时间窗口
for(int i=1; i<=6; i++){
    sort(row[i].begin(), row[i].end());
    int last = -INF, cnt = 0;
    for(int t : row[i]){
        if(t >= last + 60){ // 超出当前窗口
            cnt++;
            last = t;
        }
    }
    ans += cnt;
}
```

---
处理用时：60.11秒
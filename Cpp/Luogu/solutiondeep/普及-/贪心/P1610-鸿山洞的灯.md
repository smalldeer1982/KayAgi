# 题目信息

# 鸿山洞的灯

## 题目描述

已知 $n$ 盏灯以及每盏灯的位置 $p_i$，$p_i$ 均不相等，当两盏灯之间的距离小于 $dist$ 时，若这个安全距离里面还有灯是亮着时，就可以关掉这些灯（即若第 $i-1$ 盏与第 $i+1$ 盏的距离 $\leq dist$，则可以关掉第 $i$ 盏）。

求在保证洞里的光线是充足的情况下，一段区域里能删除的灯的最大值。

距离洞口最近和最远的两盏灯必须是亮着。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，保证 $dist$ 在 `int` 整型范围之内。

## 样例 #1

### 输入

```
3 3

1 2 3```

### 输出

```
1```

# AI分析结果



### 综合分析与结论
该题核心是贪心策略：排序后，通过修改数组模拟"跳过"已关闭的灯，实现O(n)时间处理。首尾必须保留，中间灯满足相邻亮灯距离≤dist时可关闭。最优解法通过巧妙的位置覆盖优化，避免了复杂数据结构。

---

### 高分题解推荐

#### 1. Ophelia（5星）
**关键亮点**：  
- 排序后线性扫描，修改数组模拟链表效果  
- 核心优化：关闭灯时将位置设为前一个，避免重复计算  
- 时间复杂度O(n log n)，代码简洁高效  

**核心代码**：
```cpp
sort(a+1, a+1+n);
for(int i=2; i<=n-1; i++) {
    if(a[i+1] - a[i-1] <= dist) {
        a[i] = a[i-1]; // 关键优化：覆盖位置
        sum++;
    }
}
```

---

### 最优思路总结
**关键技巧**：  
1. **排序预处理**：无序输入需先排序确保连续性  
2. **贪心扫描**：从第2到n-1个灯依次判断关闭条件  
3. **位置覆盖优化**：关闭时将当前灯位置设为前一个，后续计算自动跳过  
4. **边界处理**：首尾灯固定亮着，直接跳过  

**同类型拓展**：  
- 类似跳跃问题（如P1094 纪念品分组）  
- 区间覆盖问题（如P1803 线段覆盖）  
- 链表式贪心（如P3629 巡逻）  

---

### 推荐练习题
1. **P1090 合并果子**（贪心+优先队列）  
2. **P1223 排队接水**（贪心排序策略）  
3. **P3943 星空**（贪心处理开关灯变种）

---
处理用时：81.53秒
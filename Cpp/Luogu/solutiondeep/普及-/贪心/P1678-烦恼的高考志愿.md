# 题目信息

# 烦恼的高考志愿

## 题目背景

计算机竞赛小组的神牛 V 神终于结束了高考，然而作为班长的他还不能闲下来，班主任老 t 给了他一个艰巨的任务：帮同学找出最合理的大学填报方案。可是 v 神太忙了，身后还有一群小姑娘等着和他约会，于是他想到了同为计算机竞赛小组的你，请你帮他完成这个艰巨的任务。


## 题目描述

现有 $m$ 所学校，每所学校预计分数线是 $a_i$。有 $n$ 位学生，估分分别为 $b_i$。

根据 $n$ 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。


## 说明/提示

数据范围：

对于 $30\%$ 的数据，$1\leq n,m\leq1000$，估分和录取线 $\leq10000$；

对于 $100\%$ 的数据，$1\leq n,m\leq100000$，估分和录取线 $\leq 1000000$ 且均为非负整数。


## 样例 #1

### 输入

```
4 3
513 598 567 689
500 600 550
```

### 输出

```
32```

# AI分析结果



### 综合分析与结论
本题核心是快速为每个学生找到最接近的学校分数线，本质是**最近邻搜索**问题。所有题解均围绕排序后高效查找展开，主流解法为二分查找（含STL lower_bound），时间复杂度为O(m log m + n log m)，为最优解法。其他解法如双指针贪心、混合排序查找、平衡树等虽正确但实现复杂或效率略低。

---

### 精选题解及亮点

#### 1. 作者：Viston (⭐⭐⭐⭐⭐)
**关键亮点**：  
- 使用STL的`lower_bound`直接定位第一个≥学生分数的位置，简化二分实现  
- 清晰处理边界条件（全部更大/更小），代码简洁高效  
- 利用指针运算直接获取前后相邻元素，避免手动维护区间  

**个人心得**：  
> "居然没有用万恶的$lower$_$bound$...函数会输出结束查询的位置，应为他并没有找到"  
——强调理解STL函数返回值边界的重要性

**核心代码**：
```cpp
sort(c+1,c+m+1); // 学校分数排序
for(int i=1;i<=n;i++) {
    cin >> x;
    p1 = lower_bound(c,c+m,x) - c; // 第一个≥x的位置
    p2 = p1-1;
    ans += min(abs(c[p1]-x), abs(x-c[p2])); // 比较前后
}
```

#### 2. 作者：06ray (⭐⭐⭐⭐)
**关键亮点**：  
- 手动实现二分查找，逻辑清晰展示查找过程  
- 通过`l=mid+1/r=mid`策略找到第一个>学生分数的位置  
- 特判处理所有学校分数线均高于学生的情况  

**调试经验**：  
> "这里需要特判断一下，不然只能得70分"  
——强调边界条件处理的必要性

**核心逻辑**：
```cpp
while(l<r) {
    mid = (l+r)/2;
    if(a[mid] <= b[i]) l = mid+1;
    else r = mid;
}
ans += min(abs(a[l-1]-b[i]), abs(a[l]-b[i]));
```

#### 3. 作者：AK_黄铮_IMO (⭐⭐⭐⭐)
**关键亮点**：  
- 使用`lower_bound`结合指针运算，处理前驱后继  
- 明确初始化极大值处理边界  
- 强调long long类型避免溢出  

**代码技巧**：
```cpp
d1=2000000000; d2=2000000000; // 初始极大值
if(p1!=m) d1=num[p1]-x; // 后继差值
if(p2!=-1) d2=x-num[p2]; // 前驱差值
ans += min(d1,d2);
```

---

### 最优思路总结
1. **排序预处理**：将学校分数线排序（O(m log m)）
2. **二分定位**：对每个学生分数，找到最近的两个候选分数线  
   - 使用`lower_bound`找第一个≥x的位置  
   - 比较该位置与前一个位置的差值
3. **边界处理**：  
   - 学生分低于所有学校 → 取最小分数线  
   - 学生分高于所有学校 → 取最大分数线

---

### 举一反三
1. **同类题目推荐**：  
   - P1102 A-B数对（二分求差值对）  
   - P1678 烦恼的高考志愿（同一题）  
   - P2249 【深基13.例1】查找（lower_bound模板题）
2. **扩展技巧**：  
   - 当需要同时处理前驱后继时，混合排序+双指针扫描可优化为线性复杂度  
   - 平衡树适用于动态插入查询场景，但静态数据不如二分高效

---
处理用时：57.37秒
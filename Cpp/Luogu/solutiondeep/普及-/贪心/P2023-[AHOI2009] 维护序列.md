# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果



### 综合分析与结论
本题考察线段树处理区间乘法、加法与求和的混合操作，核心难点在于标记下传顺序与优先级管理。多数题解采用线段树实现，重点在于乘法标记优先于加法标记处理。分块解法虽可行但效率较低，zkw线段树与结构体指针实现提供了优化思路。

### 高星题解推荐

#### 1. 作者：Mingoal（★★★★★）
**关键亮点**：  
- 清晰讲解乘法优先级逻辑与标记合并公式  
- 代码结构简洁，注释明确，适合学习基础实现  
- 强调乘法标记影响加法标记的细节（`ad = ad*mul + add`）

**核心代码思想**：  
```cpp
void maintain(int t,int k){ //标记下传
    tr[t<<1].sum = (tr[t<<1].sum*tr[t].mu + tr[t].ad*(k+1>>1))%p;
    tr[t<<1|1].sum = (tr[t<<1|1].sum*tr[t].mu + tr[t].ad*(k>>1))%p;
    //更新子节点乘法标记和加法标记
    tr[t<<1].mu = tr[t<<1].mu*tr[t].mu%p;
    tr[t<<1|1].mu = tr[t<<1|1].mu*tr[t].mu%p;
    tr[t<<1].ad = (tr[t<<1].ad*tr[t].mu + tr[t].ad)%p;
    tr[t<<1|1].ad = (tr[t<<1|1].ad*tr[t].mu + tr[t].ad)%p;
    //清空当前标记
    tr[t].mu=1; tr[t].ad=0;
}
```

#### 2. 作者：GaryZhong（★★★★☆）  
**关键亮点**：  
- 使用位运算宏简化代码（`#define lson rt<<1`）  
- 结构体封装线段树节点，代码模块化清晰  
- 详细注释每个函数的操作逻辑  

**实现技巧**：  
```cpp
#define lson rt<<1
#define rson rt<<1|1
void pushdown(int l,int r,int rt){
    if(mul[rt]==1 && add[rt]==0) return;
    LL mid=(l+r)>>1;
    //更新左子树
    sum[lson] = (sum[lson]*mul[rt] + add[rt]*(mid-l+1))%p;
    add[lson] = (add[lson]*mul[rt] + add[rt])%p;
    mul[lson] = mul[lson]*mul[rt]%p;
    //同理更新右子树
    //...
}
```

#### 3. 作者：YuntianZhao（★★★★☆）  
**关键亮点**：  
- 结构体指针动态分配节点，避免数组下标计算  
- 完整封装线段树操作，适合理解面向对象实现  
- 强调取模优化（`#define mod(x) (x)%p`）

**核心技巧**：  
```cpp
void pushdown(LL l, LL r, LL rt) {
    if (add[rt] || mul[rt] != 1) {
        //先处理乘法标记再处理加法
        sum[lson] = sum[lson] * mul[rt] % p;
        add[lson] = (add[lson] * mul[rt] + add[rt]) % p;
        mul[lson] = mul[lson] * mul[rt] % p;
        //右子树同理...
    }
}
```

### 关键技巧总结
1. **标记优先级**：乘法标记优先于加法，下传时先更新乘法，再处理加法。
2. **取模优化**：每次运算后立即取模，防止溢出（如`sum = (sum * mul + add) % p`）。
3. **结构设计**：使用结构体封装节点（sum, add, mul），或用宏简化左右子节点访问。

### 推荐相似题目
1. [P3373 线段树2](https://www.luogu.com.cn/problem/P3373)（模板题，完全相同）
2. [P2572 动态统计](https://www.luogu.com.cn/problem/P2572)（区间加、乘、求和）
3. [P2023 维护序列](https://www.luogu.com.cn/problem/P2023)（区间乘、加、覆盖混合操作）

### 个人心得摘录
- **调试经验**：多次WA后发现未初始化乘法标记为1（如`mul[rt]=1`），导致后续计算错误。
- **优化教训**：分块解法在大数据量（1e5）时TLE，必须用线段树优化。
- **思维突破**：将乘法和加法视为复合操作，统一处理下传顺序是解题关键。

---
处理用时：70.41秒
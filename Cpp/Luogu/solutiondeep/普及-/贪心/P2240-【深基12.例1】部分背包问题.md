# 题目信息

# 【深基12.例1】部分背包问题

## 题目描述

阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 $N(N \le 100)$ 堆金币，第 $i$ 堆金币的总重量和总价值分别是 $m_i,v_i(1\le m_i,v_i \le 100)$。阿里巴巴有一个承重量为 $T(T \le 1000)$ 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？

## 样例 #1

### 输入

```
4 50
10 60
20 100
30 120
15 45
```

### 输出

```
240.00```

# AI分析结果



### 综合分析与结论
本题属于典型的贪心问题，所有金币可分割，最优策略是按单位价值排序后尽可能多取高性价比金币。各题解均正确识别核心思路，差异主要体现在排序方式（结构体/数组）、比较方法（交叉相乘/浮点计算）和代码优化上。

---

### 所选高星题解与亮点

#### 题解1：dingcx（★★★★★）
**关键亮点**  
1. 使用结构体存储金币属性，代码逻辑清晰  
2. 排序时通过交叉相乘（`a.v*b.w > a.w*b.v`）避免浮点精度问题  
3. 处理剩余容量时直接强转double确保精度  
**个人心得**  
> "为防止精度问题直接交叉相乘" —— 强调了整数运算的优势

**核心代码**  
```cpp
bool cmp(Node aa, Node bb){
    return aa.v * bb.w > aa.w * bb.v; // 交叉相乘比较
}
for(int i=1; i<=n; i++){
    if(a[i].w <= m) ans += a[i].v, m -= a[i].w;
    else {
        ans += a[i].v * m * 1.0 / (a[i].w * 1.0);
        break;
    }
}
```

---

#### 题解2：CSP_Sept（★★★★☆）
**关键亮点**  
1. 结构体内显式存储性价比`p`提升可读性  
2. 使用快读优化输入（虽然本题数据量小作用不大）  
3. 分离金币分割计算逻辑到`else`块中  

**核心代码**  
```cpp
struct node{ double w, v, p; };
bool cmp(node a, node b){ return a.p > b.p; }
if(c >= a[i].w) { /* 全取 */ }
else { sum += c * a[i].p; break; }
```

---

#### 题解3：樱雪喵（★★★★☆）
**关键亮点**  
1. 用独立数组替代结构体，适合不熟悉结构体的新手  
2. 浮点比较时使用`t-w[i]>-0.000001`避免精度误差  
3. 冒泡排序实现直观易懂  

**核心代码**  
```cpp
for(int j=1; j<n; j++) { // 冒泡排序性价比
    if(a[j] < a[j+1]) swap(a[j],a[j+1]), swap(v[j],v[j+1]), swap(w[j],w[j+1]);
}
if(t-w[i] > -0.000001) { /* 全取 */ }
else { ans += t*a[i]; break; }
```

---

### 关键思路与技巧总结
1. **贪心策略**：按性价比从高到低排序金币堆  
2. **精度优化**：通过交叉相乘（`a.v*b.w > a.w*b.v`）避免浮点比较  
3. **分割处理**：剩余容量不足时按比例计算价值  
4. **数据结构**：结构体存储属性或独立数组分别维护  

---

### 拓展与举一反三
1. **同类问题**：  
   - P1223 排队接水（贪心+排序）  
   - P2240 部分背包变种（加入容量限制）  
   - P2949 工作调度（贪心+优先队列）  
2. **算法套路**：  
   - 可分割背包问题必用贪心  
   - 不可分割的0-1背包需用动态规划  

---

### 精选代码片段（dingcx）
```cpp
struct Node{ int w, v; };
sort(a+1, a+n+1, [](Node a, Node b){
    return a.v*b.w > a.w*b.v;
});
double ans = 0;
for(int i=1; i<=n; i++){
    if(m >= a[i].w) ans += a[i].v, m -= a[i].w;
    else { ans += (double)a[i].v*m / a[i].w; break; }
}
```

---
处理用时：48.10秒
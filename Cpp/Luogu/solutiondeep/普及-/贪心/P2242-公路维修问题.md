# 题目信息

# 公路维修问题

## 题目描述

由于长期没有得到维修，A国的高速公路上出现了 $n$ 个坑。为了尽快填补好这 $n$ 个坑，A国决定对 $m$ 处地段采取交通管制。为了求解方便，假设A国的高速公路只有一条，而且是笔直的。现在给出 $n$ 个坑的位置，请你计算，最少要对多远的路段实施交通管制？


## 说明/提示

[样例说明]


交通管制的地段分别为：$3-8,14-21,25-31,40-43$。

## 样例 #1

### 输入

```
18 4
3 4 6 8 14 15 16 17 21 25 26 27 30 31 40 41 42 43
```

### 输出

```
25```

# AI分析结果



### 综合分析与结论

本题需在排序后通过贪心策略选择最大的m-1个间隔，使得总管制长度最小。关键点在于正确计算相邻坑的间隔差及总长度处理方式。两种主流正确解法：①计算间隔差减一后取最大值；②直接取最大间隔差并通过公式调整总长度。

---

### 精选题解

#### 1. Elma_（5星）
**关键亮点**：  
- 详细解释贪心策略，强调间隔差减一的意义。
- 代码清晰，正确处理初始总长度与间隔差计算。
- 样例推导验证正确性，适合新手理解。

**核心代码**：
```cpp
sort(large, large+n-1); // 排序相邻坑间隔差-1
int ans = a[n-1] - a[0] + 1; // 总初始长度
for (int i=1; i<=m-1; i++) 
    ans -= large[n-1-i]; // 减去最大m-1个间隔
```

#### 2. _StarBird_（5星）
**关键亮点**：  
- 代码简洁，思路与Elma_一致但更紧凑。
- 使用降序排序，逻辑清晰易懂。

**核心代码**：
```cpp
sort(dis, dis+n-1, greater<int>()); // 降序排列间隔差-1
int ans = a[n-1] - a[0] + 1;
for (int i=0; i<m-1; i++)
    ans -= dis[i]; // 减最大m-1个间隔
```

#### 3. iamnottsh（5星）
**关键亮点**：  
- 使用`nth_element`优化排序，时间复杂度更优。
- 数学推导证明正确性，适合进阶学习。

**核心代码**：
```cpp
nth_element(a, a+k-1, a+n, greater<int>()); // 取前k-1大元素
int ans = s - mi - sum_unselected + k; // 总差减未选差之和加m
```

---

### 关键思路总结
1. **排序坑位置**：确保相邻差计算正确。
2. **贪心选择最大间隔**：无论计算间隔差减一或直接取差，均需选最大的m-1个。
3. **公式调整总长度**：根据处理方式调整总长度公式（+1或加m）。

---

### 同类题目推荐
1. **P1090 合并果子**：贪心+优先队列，最小化合并代价。
2. **P5019 铺设道路**：相邻区间处理，贪心策略类似。
3. **P1230 智力大冲浪**：时间排序与任务选择，强化贪心应用。

---
处理用时：322.92秒
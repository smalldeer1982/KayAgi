# 题目信息

# 骑士的工作

## 题目背景

你作为一个村的村长，保卫村庄是理所当然的了。今天，村庄里来了一只恶龙，他有 $n$ 个头，恶龙到处杀人放火。你着急了。不过天无绝人之路，现在来了一个骑士团。里面有 $m$ 位成员（往下看）。


## 题目描述

每个人都可以砍掉**至多**一个大小不超过 $z_i$ 的头，需要 $z_i$ 个金币，求最小花费。


## 说明/提示

对于所有数据，$1 \le n,m \le 2 \times 10^4$，$1 \leq z_i \leq 10^5$。

## 样例 #1

### 输入

```
2 3
5 
4
7 
8
4```

### 输出

```
11```

# AI分析结果



### 综合分析与结论
该题为典型贪心问题，核心思路是排序后双指针匹配。最优解法时间复杂度为 O(n log n + m log m)，通过排序后按顺序为每个头匹配最小可行骑士。关键点在于正确处理边界条件（如骑士不足、中途无法匹配等），所有题解中双指针法最简洁高效。

---

### 精选题解推荐

#### 1. 作者：Suiseiseki（★★★★★）
**核心亮点**：代码简洁清晰，双指针逻辑最简版本，完美处理边界条件  
**关键代码**：
```cpp
sort(dg, dg+n); sort(kill, kill+m);
int i=0,j=0;
while(i<n && j<m){
    if(dg[i]<=kill[j]) ans += kill[j], i++, j++;
    else j++;
}
if(i==n) cout<<ans; else cout<<"you died!";
```
**个人心得**：明确使用双指针同步推进，避免冗余变量，代码可读性极佳。

#### 2. 作者：做梦想Peach（★★★★☆）
**核心亮点**：包含输入优化（快读），处理 n>m 特判  
**关键代码**：
```cpp
sort(el+1, el+1+n); sort(qs+1, qs+1+m);
int j=1;
for(i=1; i<=n; i++){
    while(el[i]>qs[j]) j++;
    ans += qs[j]; j++;
}
if(i-1 !=n) printf("you died!");
```
**优化点**：快读提升输入效率，特判前置减少计算量。

#### 3. 作者：R·Buffoon（★★★★☆）
**核心亮点**：循环逻辑清晰，j 指针自增处理跳过无效骑士  
**关键代码**：
```cpp
for(RI i=1; i<=m; ++i){
    if(cost[i]>=head[j]) ans+=cost[i], ++j;
    if(j>n) break;
}
if(j<=n) cout<<"you died!";
```
**技巧**：将骑士循环作为外层，避免越界检查，逻辑更直观。

---

### 最优思路总结
1. **双排序法**：将头和骑士分别排序，保证从小到大依次匹配。
2. **双指针贪心**：维护两个指针分别遍历头和骑士，确保每次选择最小可行解。
3. **边界特判**：在循环开始前检查 n>m 可立即返回无解，提升效率。

---

### 相似题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子**（贪心+优先队列）  
2. **P1223 排队接水**（排序+时间计算）  
3. **P3817 小A的糖果**（贪心分配策略）  

---

### 调试经验摘录
- **格式陷阱**：输出必须为 `you died!` 包含英文感叹号（多个题解提及）。  
- **指针越界**：需在循环后二次验证是否处理完所有头（如 `i==n` 判断）。  
- **复杂度误判**：暴力二重循环在数据量大时会超时，必须使用线性扫描。

---
处理用时：63.29秒
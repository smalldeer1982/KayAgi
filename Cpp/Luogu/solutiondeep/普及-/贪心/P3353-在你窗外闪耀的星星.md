# 题目信息

# 在你窗外闪耀的星星

## 题目背景

飞逝的的时光不会模糊我对你的记忆。难以相信从我第一次见到你以来已经过去了 3 年。我仍然还生动地记得，3 年前，在美丽的集美中学，从我看到你微笑着走出教室，你将头向后仰，柔和的晚霞照耀着你玫瑰色的脸颊。我明白，我已经沉醉于你了。之后，经过几个月的观察和窥探，你的优雅与智慧，你对待生活的态度和你对未来的愿望深切地在我心中留下了印象。你是迷人的阳光女孩，我总是梦想着与你分享余生。唉，实际上你远远超过了我最疯狂的梦想。我不知道如何桥起我与你之间的鸿沟。所以我没有任何计划，仅仅只是等待，等待一个适当的机会到来。直到现在，毕业的到来，我意识到我是个傻瓜，我应该创造机会并且抓住它而不只是等待。


这些日子里，我和我的朋友、室友、同学一个接一个地分开。我仍无法相信，在挥手之后，这些熟悉的面孔很快就会从我们的生活中消失，仅仅留下回忆。我明天就将离开学校。你已经计划远走高飞，追求你的未来，实现你的梦想。如果没有命运，也许我们不会再次相遇。所以今晚，我正在你的宿舍楼下徘徊，希望能偶然遇见你。但矛盾的是，你的美貌一定会使我心跳加速，我笨拙的舌头也许无法吐出一个字。我不记得我曾多少次经过你的宿舍楼，每次都希望看到你出现在阳台上或是窗台上。我不记得这个想法曾多少次在我的脑海中涌出：打电话叫她一起吃晚饭或是聊聊天。但每次，考虑到你的优秀和我的平凡，胆怯的优势超越勇气驱使我静静地离开。


毕业，意味着中学生活的终结。这些光荣与浪漫的时代结束。你可爱的微笑是我原来努力学习的动力，这单相思的爱情会被密封，作为一个我心灵深处的记忆。毕业，也意味着新生活的开始，一个到达光明未来的足迹。我真希望你在国外天天开心，一切顺利。同时，我将努力从幼稚中走出来，变得更加成熟。我的理想将是在现实中追求我的爱与幸福，我永远不会放弃。


再见了，我的公主！


如果有一天，在某个天涯海角，我们有机会相聚，即使是白发苍苍的男人和女人，在那个时候，我希望我们可以成为好朋友来自豪地分享这个记忆，重温年轻快乐的激情。如果这个机会永远没有到来，我希望我是天空中的星星，在你的窗外闪烁。远远地保佑着你，就像一个朋友，每天晚上陪伴在你左右，一同分享甜美的梦亦或是一同经历可怕的梦。

## 题目描述

现在问题来了：天空可以理解为一条数轴，在这条数轴上分布着许多颗星星，对于每颗星星都有它的位置 $X_i$ 和自身的亮度 $B_i$。**一个位置可能有多颗星星**。而窗户所能看到的范围是一个给出的参数 $W$，我们看到的星星也包括窗户边缘的星星。现在，要你求出调整窗户位置后能看到星星的亮度之和最大值。


## 说明/提示

样例说明：


 ![](https://cdn.luogu.com.cn/upload/pic/3818.png) 

对于 $10\%$ 的数据，$W=0$（没有边缘）；

对于 $40\%$ 的数据，$W\leq 1000$；

对于 $100\%$ 的数据，$1 \leq N\leq 10 ^ 5$，$0 \leq W\leq 10 ^ 5$，$1 \leq X_i\leq 10 ^ 5$，$1\leq B_i\leq 100$。

除 $W=0$ 的情况外，$W$ 均为 $\geq 3$ 的奇数。


## 样例 #1

### 输入

```
6 3
1 2
2 4
3 8
4 4
5 2
1000 1```

### 输出

```
16```

# AI分析结果



### 综合分析与结论
本题本质是静态区间最值问题，核心在于高效计算固定长度窗口的亮度总和。题解主要采用以下思路：
1. **前缀和**（最优解）：O(N)预处理+O(1)查询，时间复杂度最优
2. **树状数组/线段树**：支持动态更新但本题无需，适合扩展场景
3. **滑动窗口双指针**：需排序后维护，时间复杂度O(N logN)

### 高星题解推荐（4星及以上）

#### 1. [Dog_Two] 前缀和极简实现（5星）
**关键亮点**：  
- 代码简洁高效（仅20行），直接处理位置累加  
- 特别处理w=0的边界条件  
- 时间复杂度O(max_x)严格线性  
**核心代码**：
```cpp
for(int i=1;i<=maxx;++i) ans=sum+=a[i];
for(int i=w+1;i<=maxx;++i) 
    ans=max(ans,sum+=a[i]-a[i-w]);
```

#### 2. [YaliKiWi] 双实现详解（4星）
**关键亮点**：  
- 同时给出前缀和与树状数组两种实现  
- 清晰标注时间复杂度与适用场景  
- 包含公式推导增强理解  
**核心片段**：
```cpp
// 前缀和版
for(int i=m;i<=far;i++)
    ans=max(ans,pre[i]-pre[i-w]);
```

#### 3. [gb530] 调试经验分享（4星）
**关键亮点**：  
- 揭露初始未处理重复位置的陷阱  
- 通过WA案例强调+=操作的重要性  
- 代码对比直观展现错误修正  
**关键代码**：
```cpp
// 错误写法：a[x] = b
a[x] += b; // 正确写法
```

### 最优思路总结
**核心步骤**：  
1. **位置聚合**：将相同坐标的亮度累加  
2. **前缀和预处理**：sum[i]表示前i个位置的亮度总和  
3. **滑动窗口计算**：ans = max(sum[i] - sum[i-w])

**关键技巧**：  
- 使用数组直接存储位置亮度，避免排序  
- 处理w=0时直接返回0的边界条件  
- 循环时维护动态窗口和，避免重复计算

### 拓展练习
1. [P1614 爱与愁的心痛](https://www.luogu.com.cn/problem/P1614) - 同款滑动窗口  
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886) - 双端队列维护极值  
3. [P1714 切蛋糕](https://www.luogu.com.cn/problem/P1714) - 前缀和+单调队列优化

---
处理用时：59.08秒
# 题目信息

# [USACO18OPEN] Lemonade Line S

## 题目描述

这是农场上一个炎热的夏日，Farmer John 要给他的 $N$ 头奶牛发柠檬汽水了！所有的 $N$ 头奶牛（编号为 $1 \dots N$）都喜欢柠檬汽水，只是有些喜欢的程度更高一些。具体来说，奶牛 $i$ 为了获得柠檬汽水，最多愿意排在 $w_i$ 头奶牛之后。现在所有的 $N$ 头奶牛都在田里，但只要 Farmer John 敲响牛铃，这些奶牛就会立刻赶到柠檬汽水站。她们会在 Farmer John 开始分发柠檬汽水之前到达，但没有两头奶牛会在同一时刻到达。此外，当奶牛 $i$ 到达时，当且仅当队伍中至多有 $w_i$ 头奶牛时，她才会加入队伍。

Farmer John 想要提前准备一定量的柠檬汽水，但他不想浪费。排队的奶牛数量可能取决于她们的到达顺序。请帮助他求出在所有可能的到达顺序下，最小的可能排队奶牛数量。


## 说明/提示

在这个情况下，可能最后仅有三头奶牛在队伍中（这也是最小可能值）。假设 $w = 7$ 和 $w = 400$ 的奶牛先到并等在队伍中。然后 $w = 1$ 的奶牛到达并且会离开，因为已经有 $2$ 头奶牛在队伍中了。接着 $w = 2$ 的两头奶牛到达，一头留下排队，另一头离开。

供题：Dhruv Rohatgi

## 样例 #1

### 输入

```
5
7 1 400 2 2```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论
题目要求在所有可能的奶牛到达顺序中，找到最小的可能排队数量。通过贪心策略将奶牛按忍耐值从大到小排序，并依次加入队列，直到无法加入为止。各题解均采用此思路，差异仅在于实现细节（如排序方向、遍历顺序等）。正确性基于：高忍耐值的牛先加入，减少后续低忍耐值牛的加入机会，确保总数最小。

---

### 高分题解推荐

#### 1. 作者：hhhyyyfff (5星)
- **关键亮点**：代码简洁高效，思路清晰。降序排序后直接遍历，条件判断简洁。
- **个人心得**：明确说明排序方向对结果的影响，直接指出后续牛无法加入的逻辑。
- **核心代码**：
  ```cpp
  sort(a, a+N, cmp); // 降序排列
  for(int i=0; i<N; ++i)
      if(a[i]<i) { // 当忍耐值不足时输出当前队伍数
          printf("%d\n", i);
          return 0;
      }
  ```

#### 2. 作者：dzy2008 (5星)
- **关键亮点**：详细分步解释实现过程，代码可读性强，变量命名规范。
- **核心代码**：
  ```cpp
  sort(w, w+n, cmp); // 降序排列
  for(int i=0; i<n; ++i)
      if(w[i]<i) { // 直接判断当前位置是否满足条件
          cout << i;
          return 0;
      }
  ```

#### 3. 作者：fls233666 (4星)
- **关键亮点**：代码简短，逻辑正确，变量名稍欠直观但注释明确。
- **核心代码**：
  ```cpp
  sort(w, w+n); // 升序排列，倒序遍历实现降序处理
  for(int i=n-1; i>=0; i--) {
      if(l <= w[i]) l++; // 统计可加入的牛数
      else break;
  }
  ```

---

### 最优思路与技巧
- **排序方向**：将奶牛按忍耐值从大到小排序，确保高忍耐值的牛优先处理。
- **终止条件**：遍历过程中，当某头牛的忍耐值小于当前队伍数量时，后续牛必然无法加入，直接终止循环。
- **贪心证明**：交换任意两头牛的加入顺序会导致总数量不优，因此降序排列是最优策略。

---

### 拓展与类似题目
- **类似题目**：
  1. **P1090 [NOIP2004 提高组] 合并果子**（贪心+优先队列）
  2. **P1223 排队接水**（按时间排序求最小等待时间）
  3. **P1803 线段覆盖**（选择不重叠区间的最大数量）

---

### 代码实现示例（关键部分）
```cpp
#include <algorithm>
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int w[n];
    for (int i = 0; i < n; ++i) cin >> w[i];
    sort(w, w + n, greater<int>()); // 降序排序
    int ans = 0;
    for (; ans < n; ++ans) {
        if (w[ans] < ans) break; // 终止条件
    }
    cout << ans;
    return 0;
}
```

---
处理用时：111.35秒
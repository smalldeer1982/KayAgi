# 题目信息

# yyf hates ganhuodong

## 题目背景

非酋yyf知道自己太非了，于是他开始爆肝活动。yyf终于成为了一名肝帝，但他还是想尽量节省 $\mathrm{loveca}$ 的花费，不然的话如果花了太多 $\mathrm{loveca}$，yyf会心疼的。

## 题目描述

给你如下 $11$ 个正整数：

$a$：完成一首歌曲所能获得的活动$\mathrm{pt}$

$b$：完成一首歌曲所需的 $\mathrm{LP}$

$c$：你开始肝活动时的 $\mathrm{LP}$ 上限

$d$：你开始肝活动时的 $\mathrm{LP}$

$e$：你开始肝活动时的经验值上限

$f$：你开始肝活动时的经验值

$g$：打一首歌能获得的经验值

$h$：升一级增加的 $\mathrm{LP}$ 上限

$k$：升一级增加的经验值上限

$x$：离活动结束的剩余时间（小时）

$y$：你的目标活动$\mathrm{pt}$

假设yyf打歌不需要花费时间，每打一首歌需要花费一定的 $\mathrm{LP}$ 来获取一定的活动$\mathrm{pt}$ 以及一定的经验值。yyf的初始活动$\mathrm{pt}$ 为 $0$

$\mathrm{LP}$ 每小时自动恢复 $1$ 点，$\mathrm{LP}$ 达到上限后不会自动恢复（本题不需考虑这种情况），但可以通过后文所述方式超过上限。

经验值达到上限后会升级，升级时会增加 $\mathrm{LP}$上限并恢复“新的 $\mathrm{LP}$上限”（增加后的）点 $\mathrm{LP}$，恢复后的 $\mathrm{LP}$ 可以超过 $\mathrm{LP}$ 上限，且溢出的经验值会计入下一次升级，下一次升级所需要的经验值（经验值上限）会增加。

可以随时耗费一个 $\mathrm{loveca}$ 来获得当前 $\mathrm{LP}$上限点 $\mathrm{LP}$（可以超过上限）。

你的目标是获得大于等于 $y$ 的活动$\mathrm{pt}$，请求出最少需要耗费多少个 $\mathrm{loveca}$。

形式化地说，你初始的 $\mathrm{LP}$ 可以视作 $d+x$，你有两种操作：

1. 设你操作前的经验值为 $\mathrm{exp}$，$\mathrm{LP}$上限为 $\mathrm{LPmax}$，$\mathrm{LP}$ 值为 $l$（当且仅当 $l \ge b$ 时能进行操作 $1$ ），经验值上限为 $\mathrm{EXPmax}$，则在你操作后活动$\mathrm{pt}$ 加上 $a$ 。
- 若 $\mathrm{exp+g \ge EXPmax}$，则你的剩余 $\mathrm{LP}$值为 $l-b+\mathrm{LPmax}+h$，经验值为 
 $\mathrm{(exp+g)\bmod EXPmax}$，$\mathrm{LP}$上限加上 $h$，经验值上限加上 $k$
- 否则你的剩余 $\mathrm{LP}$值为 $l-b$，经验值为 $\mathrm{exp+g}$

2. 设你操作前的 $\mathrm{LP}$上限为 $\mathrm{LPmax}$，$\mathrm{LP}$值为 $l$ ，则你操作后的剩余 $\mathrm{LP}$值为 $\mathrm{LPmax}+l$

你的目标为使你的活动$\mathrm{pt}$ 大于等于 $y$ ，请求出最少需要的操作 $2$ 数量

## 由于打歌不计时间可以在活动结束的瞬间打任意次歌，即进行任意次操作1，也就是初始LP可以视作d+x

## 说明/提示

$a∈[1,10]$

$b∈[5,20]$

$c∈[30,50]$

$d∈[5,10]$

$e∈[100,200]$

$f∈[1,50]$

$g∈[10,20]$

$h∈[5,10]$

$k∈[10,20]$

$x∈[10,15]$

$y∈[5000,10000]$

## 样例 #1

### 输入

```
9 7 46 6 114 50 17 6 18 11 9118```

### 输出

```
7```

# AI分析结果



### 综合分析与结论
题目要求通过打歌获得足够活动pt，同时最小化使用loveca的次数。各题解核心思路均为贪心策略：优先打歌，不足时使用loveca补充。关键在于正确处理升级逻辑，尤其是多次连续升级的情况。

### 高星题解推荐
#### 1. 恶灬心（★★★★★）
- **关键亮点**：
  - 唯一正确处理多次升级的题解，通过循环处理确保经验溢出后的连续升级。
  - 将升级逻辑封装为独立函数，提高代码可读性。
- **核心代码**：
  ```cpp
  void shengji() {
      while (Exp >= mexp) { // 循环处理多次升级
          c += h;
          Exp -= mexp;
          mexp += k;
          LP += c;
      }
  }
  void dage() {
      while (LP >= b) {
          int x = LP / b; // 计算可连续打歌次数
          LP -= b * x;
          Exp += g * x;
          pt += a * x;
          if (pt < y) shengji(); // 打歌后处理升级
          else exit();
      }
  }
  ```
- **个人心得**：作者通过拆分函数清晰处理升级逻辑，避免漏判多次升级的情况。

#### 2. Alpha_Zero（★★★★）
- **关键亮点**：
  - 代码简洁，直接模拟题意，处理单次升级逻辑。
  - 注意边界条件（如经验等于上限时触发升级）。
- **核心代码**：
  ```cpp
  while (pt < y) {
      while (lp < b) cnt++, lp += c; // 不足时补充loveca
      lp -= b;
      pt += a;
      exp += g;
      if (exp >= e) { // 处理升级
          exp -= e;
          e += k;
          c += h;
          lp += c;
      }
  }
  ```

#### 3. ouuan（★★★★）
- **关键亮点**：
  - 标程代码变量命名清晰，逻辑直白。
  - 提示可能存在的无限升级问题，但未在代码中完全处理。
- **核心代码**：
  ```cpp
  if (f >= e) {
      d = d - b + c + h; // 处理单次升级
      c += h;
      f -= e;
      e += k;
  }
  ```

### 关键优化与技巧
1. **贪心策略**：优先打歌以提升LP上限，减少后续loveca使用。
2. **循环处理升级**：每次打歌后需循环判断是否触发多次升级（如恶灬心的`shengji`函数）。
3. **边界处理**：经验等于上限时需触发升级（条件判断用`>=`而非`>`）。

### 扩展与举一反三
- **类似题目**：涉及资源管理与升级系统的模拟题，如洛谷P1080（国王游戏）、P5021（赛道修建）。
- **拓展思考**：若打歌时间不为零或LP恢复策略变化，需调整贪心策略或引入动态规划。

### 推荐题目
1. **P1080** [NOIP2012 提高组] 国王游戏（贪心+高精度）
2. **P5021** [NOIP2018 提高组] 赛道修建（贪心+二分）
3. **P1044** [NOIP2003 普及组] 栈（递推/动态规划）

---
处理用时：256.65秒
# 题目信息

# 基础字符串练习题

## 题目背景

YSGH 牛逼

## 题目描述

给定长度非零的非空 01 串 $S$。

找出 $S$ 的非空连续子串 $T$ 满足串中 0 的个数减去 1 的个数最大。

你只需要输出最大值即可。

## 说明/提示

设 $|S| = n$。

| 数据点编号 | $n \le$ |
| :--: | :--: |
| $1 \sim 2$ | $10$ |
| $3 \sim 6$ | ${10}^3$ |
| $7 \sim 10$ | ${10}^5$ |

对于 $100\%$ 的数据，$1 \le n \le {10}^5$。

## 样例 #1

### 输入

```
0111100101```

### 输出

```
2```

# AI分析结果



### 综合分析与结论
该题核心是求最大差值子串（0视为+1，1视为-1的变形最大子段和）。各题解主要采用以下三种思路：
1. 贪心法（维护当前最优解）
2. 动态规划（状态转移方程）
3. 前缀和优化（维护最小前缀）

最优解法时间复杂度均为O(n)，空间复杂度O(1)。需特别注意全1串的特判。

---

### 高星题解推荐

#### 1. 作者：hwx12233（★★★★★）
**核心亮点**：
- 贪心算法实时更新当前最优解
- 代码简洁高效（仅12行核心逻辑）
- 通过`ans2`初始化为-1处理全1特例
```cpp
int ans1=0, ans2=-1;
for(int i=0;i<n;i++){
    if(s[i]=='0') ans1++;
    else ans1 = max(0, ans1-1);
    ans2 = max(ans2, ans1);
}
```

#### 2. 作者：Inkyo（★★★★★）
**核心亮点**：
- 提供DP和前缀和双解法
- 状态转移方程清晰体现问题本质
- 通过`minn`动态维护最小前缀
```cpp
// DP解法
dp[i] = max(dp[i-1] + f, f);
// 前缀和解法
sum += f;
ans = max(ans, sum - minn);
minn = min(sum, minn);
```

#### 3. 作者：大头（★★★★★）
**核心亮点**：
- 前缀和变形（V数组差值）
- 代码极简（仅7行核心逻辑）
- 通过`mx`动态维护最小值
```cpp
S += (s[i]=='0' ? 1 : -1);
ans = max(ans, S - mx);
mx = min(mx, S);
```

---

### 关键技巧总结
1. **问题转化**：将0/1字符串转化为+1/-1的数值问题
2. **贪心维护**：遇到负数立即重置，保证局部最优
3. **前缀和优化**：`sum[r] - min(sum[l])` 求极差
4. **特判处理**：全1串需返回-1的特殊情况

---

### 相似题目推荐
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)（基础模板）
2. [P1714 切蛋糕](https://www.luogu.com.cn/problem/P1714)（前缀和+单调队列）
3. [P2642 双子序列最大和](https://www.luogu.com.cn/problem/P2642)（二维DP扩展）

---

### 调试经验摘录
1. **特判陷阱**：多篇题解强调全1串需返回-1，若初始化ans=0会导致错误
2. **负值处理**："当前和<0时立即归零"是贪心算法的关键步骤
3. **代码精简**：多个题解通过`?:`运算符简化字符判断逻辑
4. **空间优化**：DP解法中仅需前一个状态，可用变量替代数组

---
处理用时：55.88秒
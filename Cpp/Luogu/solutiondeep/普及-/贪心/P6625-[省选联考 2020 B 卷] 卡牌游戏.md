# 题目信息

# [省选联考 2020 B 卷] 卡牌游戏

## 题目描述

轩轩某天想到了一个卡牌游戏，游戏规则如下：

1. 初始时轩轩的手中有自左向右排成一排的 $n$ 张卡牌，每张卡牌上有一个整数分值。
2. 接下来，轩轩每次可以选取卡牌序列最左边的连续若干张卡牌（至少 $2$ 张），将它们替换为一张新卡牌。新卡牌将插入到序列的最左端，它的分值为本次操作中被替换掉的卡牌的分值之和。
3. 初始时轩轩总分为 $0$，每执行一次卡牌替换操作，新卡牌的分值将加到总分中。当序列长度为 $1$ 时游戏结束，轩轩也可以在任意时刻结束游戏。

现在给出序列中各个卡牌的分值，请你来帮助轩轩计算他能够获得的最高总分是多少？


## 说明/提示

**样例解释 1**

最优策略为，首先选择最左侧的两张卡牌，总分增加 $2 + (-1) = 1$。此时轩轩选择的两张卡牌被替换为一张分值为 $1$ 的卡牌，且被放入序列最左侧，此时自左向右卡牌的分值为 $1$ 和 $2$。

接下来选择当前序列中所有卡牌，总分增加 $1 + 2 = 3$，总分为 $4$。此时轩轩选择的两张卡牌被替换为一张分值为 $3$ 的卡牌，且被放入序列最左侧，此时序列中只有一张分值为 $3$ 的卡牌，游戏结束。

**样例解释 2**


最优策略为，首先选择最左侧的四张卡牌，总分增加  $(-4) + 3 + 0 + 7 = 6$。此时轩轩选择的四张卡牌被替换为一张分值为6 的卡牌，且被放入序列最左侧，此时自左向右卡牌的分值为 $6, -3, -5, -3$。

再选择最左侧的两张卡牌，总分增加 $6 + (-3) = 3$，总分为 $9$。此时轩轩选择的两张卡牌被替换为一张分值为 $3$ 的卡牌，且被放入序列最左侧，此时自左向右卡牌的分值为 $3, -5, -3$。

此时无论如何操作均无法使总分继续增大，轩轩选择结束游戏。

**数据范围与约定**

测试点 $1 \sim6 $ 满足：$1\le n\le 16, |a_i| \le 100$。

测试点 $7 \sim 12$ 满足：$1\le n\le 10^3, |a_i| \le 100$。

测试点 $13 \sim 20$ 满足：$1\le n\le 10^5, |a_i| \le 10^5$。

## 样例 #1

### 输入

```
3
2 -1 2```

### 输出

```
4```

## 样例 #2

### 输入

```
7
-4 3 0 7 -3 -5 -3```

### 输出

```
9```

# AI分析结果



### 综合分析与结论
题目本质是选择若干个非首元素的正前缀和之和的最大值。核心思路是**前缀和贪心**：只要当前前缀和（从第二个元素开始）为正，就将其加入总分。所有题解均基于这一关键性质，差异主要在实现方式和证明细节。

---

### 高分题解推荐（评分≥4星）

#### 1. Cripple_Abyss（5星）
**核心思路**：在线计算前缀和，仅当前缀和>0时累加（排除第一个元素）。  
**亮点**：代码极简（7行），时间复杂度O(n)，空间复杂度O(1)。  
**关键代码**：
```cpp
ll ans,x,s,n;
int main() {
    cin>>n;
    for (ll i=1; i<=n; i++) {
        cin>>x;
        s+=x;
        if (s>0&&i!=1) ans+=s;
    }
    cout<<ans;
}
```

#### 2. Miraik（4星）
**核心思路**：将问题转化为计算所有非首元素的正前缀和之和。  
**亮点**：给出严格数学形式化表达，证明更严谨。  
**关键代码**：
```cpp
ll n,h,ans;
int main(){
    n=read(),h=read(); // h初始为a[1]
    while(--n) h+=read(), ans += h>0 ? h : 0;
    printf("%lld\n",ans);
}
```

#### 3. Scintilla（4星）
**核心思路**：将合并操作抽象为前缀和选择问题。  
**亮点**：数学符号描述清晰，代码直接体现问题本质。  
**关键代码**：
```cpp
ll sum = 0, ans = 0;
int main() {
    n = read();
    Rep(i, 1, n) {
        sum += read();
        if (i != 1) ans += max(sum, 0ll);
    }
    printf("%lld", ans);
}
```

---

### 最优关键思路提炼
**核心算法**：前缀和贪心  
**关键性质**：合并操作的得分等价于原数组的前缀和。当且仅当某次合并后的前缀和为正时，此次操作对答案有贡献。  
**实现技巧**：  
1. 在线计算前缀和，无需存储数组  
2. 跳过第一个元素的前缀和  
3. 仅累加正数部分  

**易错点**：  
- 未处理数据范围导致溢出（需用`long long`）  
- 错误包含首元素前缀和（如题解中的`i != 1`判断）

---

### 拓展与举一反三
**同类题目推荐**：  
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)（一维连续子序列最大和）  
2. [P2642 双子序列最大和](https://www.luogu.com.cn/problem/P2642)（两段不重叠子序列最大和）  
3. [P5635 一次比赛](https://www.luogu.com.cn/problem/P5635)（前缀和与区间性质结合）

**调试经验摘录**：  
- "不开longlong见祖宗"（数据范围分析不足）  
- "当i==n时要特殊处理"（边界条件遗漏）  
- "负数后面的正数可能被错误跳过"（贪心策略正确性验证）

---
处理用时：53.40秒
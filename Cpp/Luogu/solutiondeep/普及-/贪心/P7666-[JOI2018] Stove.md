# 题目信息

# [JOI2018] Stove

## 题目描述

JOI 君的房间里有一个炉子。因为 JOI 君已经习惯了寒冷的温度，所以当他一个人在房间里时，他不需要打开炉子。但是，有客人时，他需要打开炉子。有一天，$N$ 位客人将拜访 JOI 君。第 $i$ 个客人 ($1 \leq i \leq N$) 将在时间 $T_i$ 到达，并在时间 $T_i+1$ 离开。任何时间最多有一个客人访问  JOI 君。JOI 君可以随时开火或关火。JOI 君用火柴打开炉子。JOI 君只有 $K$ 根火柴。 因此他最多可以打开炉子 $K$ 次。在一天的开始，炉子是关闭的。当炉子打开时，它需要燃料。因此，JOI 君控制着他何时打开或关闭炉子，他想尽量减少炉子的总运行时间。  
现给定访问 JOI 君的客人数据和 JOI 君拥有的火柴数，请编写一个程序来计算炉子总运行时间的最小值。

## 说明/提示

#### 数据规模与约定  
对于 $100 \%$ 的数据，$1 \leq N \leq 10^5$，$1 \leq K \leq N$，$1 \leq T_i \leq 10^9$（$1 \leq i \leq N$），$T_i < T_{i+1}$（$1 \leq i \leq N-1$）。  
- Subtask $1$（$20$ points）：$N \leq 20$。  
- Subtask $2$（$30$ points）：$N \leq 5000$。  
- Subtask $3$（$50$ points）：没有额外的限制。  
#### 样例说明  
**对于样例 $1$**：三位客人将访问 JOI 君。如果他按以下方式打开和关闭炉子，那么当客人来访时打开炉子，他打开炉子两次，炉子的总运行时间为 $(4-1)+(7-6)=4$。  
- 当第一位客人到来时，他在时间 1 打开炉子。  
- 当第二位客人离开时，他在时间 4 关掉炉子。  
- 当第三位客人到来时，他在时间 6 打开炉子。  
- 当第三位客人离开时，他在时间 7 关掉炉子。  

由于炉子的总运行时间不能小于 $4$，输出 $4$。  
**对于样例 $2$**：JOI 君只能打开一次炉子。因此，他在第一个客人来的时间 $1$ 打开炉子，当第三位客人离开时他在时间 $7$ 关掉炉子。  
请注意，客人离开的时间可以与下一位客人到来的时间相同。  
**对于样例 $3$**：JOI 君在每位客人到来时打开炉子，并在每位客人离开时关掉炉子。  
#### 题目说明：  
来源于 The 17th Japanese Olympiad in Informatics (JOI 2017/2018) Final Round 的 [T1：Stove](https://www.ioi-jp.org/joi/2017/2018-ho/2018-ho-t1-en.pdf)。  
由 @[求学的企鹅](/user/271784) 翻译整理。

## 样例 #1

### 输入

```
3 2
1
3
6```

### 输出

```
4```

## 样例 #2

### 输入

```
3 1
1
2
6```

### 输出

```
6```

## 样例 #3

### 输入

```
3 3
1
3
6```

### 输出

```
3```

## 样例 #4

### 输入

```
10 5
1
2
5
6
8
11
13
15
16
20```

### 输出

```
12```

# AI分析结果



### 综合分析与结论
本题的关键在于通过贪心策略选择最大的间隔断开，从而减少炉子运行时间。所有题解均基于同一思路：计算相邻客人时间间隔，排序后取前K-1大的间隔，从初始总时间中减去这些间隔之和。核心算法为排序+贪心，时间复杂度为O(N log N)，适用于数据规模1e5。

### 高星题解推荐
#### 1. 封禁用户（★★★★★）
- **关键亮点**：思路清晰，代码简洁，详细解释了初始总时间的计算和间隔处理逻辑。代码正确性高，样例分析透彻。
- **核心代码**：
  ```cpp
  ans = a[n] - a[1] + 1;
  for (int i = 1; i < n; i++) b[i] = a[i+1] - a[i] - 1;
  sort(b + 1, b + n);
  for (int i = n-1; i >= n-k+1; i--) ans -= b[i];
  ```

#### 2. chlchl（★★★★☆）
- **关键亮点**：变量命名合理，代码可读性强。特别强调边界条件（如K-1的处理），排序后直接取前K-1个元素。
- **核心代码**：
  ```cpp
  sort(t + 1, t + n, cmp); // 降序排序
  for (int i = 1; i <= k-1; i++) ans -= t[i];
  ```

#### 3. Malkin_Moonlight（★★★★☆）
- **关键亮点**：代码简洁，使用`greater<ll>()`降序排序，避免自定义比较函数。强调双倍经验题目。
- **核心代码**：
  ```cpp
  sort(a + 1, a + n, greater<ll>());
  for (int i = 1; i < k; i++) ans -= a[i];
  ```

### 最优思路总结
1. **初始总时间**：计算连续覆盖所有客人时的总时间`(T_N + 1) - T_1`。
2. **间隔处理**：计算相邻客人间的间隔`T_{i+1} - T_i - 1`，共N-1个。
3. **贪心选择**：按间隔从大到小排序，取前K-1大的间隔，总时间减去这些间隔之和。

### 举一反三
- **类似问题**：区间覆盖问题（如P1209修理牛棚），通过断开最大间隔最小化覆盖长度。
- **推荐题目**：
  1. [P1209 USACO1.3修理牛棚](https://www.luogu.com.cn/problem/P1209)
  2. [AT_joi2018ho_a（双倍经验）](https://www.luogu.com.cn/problem/AT_joi2018ho_a)
  3. [CF1029D Concatenated Multiples](https://codeforces.com/problemset/problem/1029/D)（贪心+数学）

### 调试与心得
- **边界处理**：当K=1时直接取初始总时间，当K≥N时总时间为N。
- **易错点**：间隔数为N-1个，需确保数组索引正确。如封禁用户的代码中`sort(b+1, b+n)`正确排序N-1个元素。

---
处理用时：125.50秒
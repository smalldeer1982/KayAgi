# 题目信息

# [CCC 2014] 燃料搜集

## 题目描述

英勇的狐狸星小队正在执行任务。他们的任务是从莱拉星系的不同的星球上搜集尽可能多的燃料。莱拉星系里有 $n$ 个星球，第 $i$ 个星球有 $a_i$ 单位燃料，但是从任何星球去那里都要花费 $b_i$ 单位燃料。不幸的是，燃料不是一种可再生资源，所以如果你第二次到访一个星球，你在那里将搜集不到新的燃料。

狐狸星小队在星球 $P$，所以他们可以立马搜集这个星球的燃料，然后他们就可以去执行任务了。只要他们的燃料足够，即完成飞行后他们剩余的燃料量是非负的，他们就可以以任意顺序访问星球。最后，他们可能会在任何星球选择停下来，甚至可能连星球 $P$ 都没离开过就停下来。他们的目标是使搜集到的燃料量最大化，如果有很多种方法可以达到这个目标，他们还想使他们访问过的不同星球的个数最大化，你能帮助他们吗？

## 说明/提示

一个最优的方案是，狐狸星小队搜集完星球 $2$ 即起点的燃料后从该出发，依次访问并搜集星球 $3,1,5$ 上的燃料，途中花费分别为 $3,12,15$，从起点开始各个星球上完成搜集后剩余燃料分别为 $10,15,15,25$。他们此时不应该选择去星球 $4$ 而是应该选择停下来以使结束时搜集到的燃料量最大化。

对于 $20\%$ 的测试数据，$1\le n\le10$；

对于 $100\%$ 的测试数据，$1\le P\le n\le10^5$，$a_i,b_i\le10^5$ 。

## 样例 #1

### 输入

```
5 2
12 12
10 100
8 3
4 5
25 15```

### 输出

```
25
4```

# AI分析结果



### 综合分析与结论
本题核心是贪心策略，需按到达所需燃料 $b_i$ 从小到大排序。正确性证明：优先访问低消耗的星球能逐步积累燃料，避免因初始燃料不足错过高收益星球。所有题解均采用此思路，差异仅在于代码实现细节（如初始星球处理方式）。

### 高星题解推荐

#### 1. 作者：GuideZombies（⭐️⭐️⭐️⭐️⭐️）
- **关键亮点**：代码简洁，逻辑清晰。通过结构体排序与筛选条件明确。
- **个人心得**：通过数学推导验证排序策略，强调优先处理低消耗星球的必要性。
- **核心代码**：
  ```cpp
  struct node { int v, val; };
  sort(star + 1, star + cnt + 1);
  for (遍历) if (oil >= star[i].v) 更新燃料及计数。
  ```

#### 2. 作者：Nemonade（⭐️⭐️⭐️⭐️）
- **关键亮点**：详细分类讨论收益情况，代码注释增强可读性。
- **核心代码**：
  ```cpp
  struct node { int a, b; };
  sort(s + 1, s + cnt + 1);
  for (遍历) if (ans >= s[i].a) 更新燃料及计数。
  ```

#### 3. 作者：Aw顿顿（⭐️⭐️⭐️⭐️）
- **关键亮点**：通过交换操作明确区分初始星球，减少边界处理。
- **核心代码**：
  ```cpp
  swap(arr[p], arr[1]); // 初始星球置首位
  sort(arr+2, arr+n+1, cmp); // 仅排序后续星球
  ```

### 最优思路总结
1. **筛选条件**：仅保留 $a_i - b_i \geq 0$ 的星球（初始星球单独处理）。
2. **排序策略**：按 $b_i$ 升序排列，确保逐步积累燃料。
3. **遍历逻辑**：按序访问，燃料足够则计入结果。

### 同类题目推荐
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)（时间序列贪心）
3. [P1803 线段覆盖](https://www.luogu.com.cn/problem/P1803)（区间调度贪心）

### 关键实现代码（以GuideZombies为例）
```cpp
struct node { int v, val; };
bool operator<(node x, node y) { return x.v < y.v; }

// 筛选并排序
for (int i = 1; i <= n; i++) {
    if (i == m) oil = a; // 初始星球
    else if (a - b >= 0) star[++cnt] = {b, a - b};
}
sort(star + 1, star + cnt + 1);

// 遍历计算
int sum = 1;
for (int i = 1; i <= cnt; i++) {
    if (oil >= star[i].v) oil += star[i].val, sum++;
    else break;
}
```

---
处理用时：71.99秒
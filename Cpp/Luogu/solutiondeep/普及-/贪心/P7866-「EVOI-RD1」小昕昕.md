# 题目信息

# 「EVOI-RD1」小昕昕

## 题目背景

一副扑克牌共有 $54$ 张牌，除去大小王后有 $52$ 张。在同一副牌中，一张牌只可能出现一次。

一副扑克牌中一共有四种花色：黑桃($\texttt{spade}$)、红桃($\texttt{heart}$)、梅花($\texttt{club}$)、方块($\texttt{diamond}$)。每个花色的牌共有 $13$ 张，分别为 $\texttt{A} \sim \texttt{K}$。

在题目中，以上四种花色分别以 $\texttt{S,H,C,D}$ 表示。

我们约定，任何一张牌，都以 **花色+点数** 表示，并且约定用 $\texttt{T}$ 表示 $\texttt{10}$，如 $\texttt{SA,D5,HT,CQ}$。

## 题目描述

昕昕手上有 **两副无大小王** 的扑克牌，她会从这些扑克牌里取出 $n$ 张牌。

昕昕创造了一个组合为 **“小昕昕”**，它的定义是，任意取出 $3$ 张牌，若这 $3$ 张牌的 **牌点一样** ，且花色有且仅有 **两种** ，则称为一对“小昕昕”。如 $\texttt{H3,S3,S3}$ 是一对“小昕昕”。

当这三张扑克牌组成 **“小昕昕”** 后，昕昕就会把它们从牌堆内拿出，**不可再次使用**。

现在，昕昕想让你帮她数数，这副牌里最多能组成多少对 **“小昕昕”**。

## 说明/提示

**本题采用捆绑测试。**

+ $\texttt{Subtask 1 (10 pts)}$ ：$1 \le n \le 3$。
+ $\texttt{Subtask 2 (20 pts)}$ ：$1 \le n \le 5$。
+ $\texttt{Subtask 3 (30 pts)}$ ：$1 \le n \le 20$。
+ $\texttt{Subtask 4 (10 pts)}$ ：$1 \le n \le 70$。
+ $\texttt{Subtask 5 (30 pts)}$ ：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 104$，保证输入的牌都存在于两副无大小王的扑克牌中。

## 样例 #1

### 输入

```
3
S3
H3
S3```

### 输出

```
1```

## 样例 #2

### 输入

```
7
ST
ST
HT
HT
CT
CT
DT```

### 输出

```
2```

## 样例 #3

### 输入

```
6
DA
HA
D4
C5
DA
D4```

### 输出

```
1```

# AI分析结果



### 综合分析与结论
题目核心是统计每个点数下各花色的牌数，通过贪心策略优先匹配最优组合（2+1花色），剩余情况拆解处理。关键难点在于如何高效处理花色分配与拆解逻辑，避免重复计算。所有题解均采用桶排统计，但优化策略差异较大。

---

### 高星题解推荐

#### 1. 昒昕-做法1（贪心+桶排）★★★★★
**关键亮点**  
① 两次贪心处理：优先处理 2+1 花色组合，再处理 2+2 拆解  
② 时间复杂度 O(n) 效率高  
③ 桶排实现简洁，逻辑清晰  
**核心代码**  
```cpp
// 第一次处理2+1组合
for (int i=1;i<=13;i++) 
    for (int j=1;j<=4;j++) 
        for (int k=1;k<=4;k++)
            if (poke[j][i]==2 && poke[k][i]==1 && j!=k) {
                poke[j][i]=0; poke[k][i]=0; ans++;
            }
// 第二次处理拆解情况
for (int i=1;i<=13;i++)
    for (int j=1;j<=4;j++)
        for (int k=1;k<=4;k++)
            if (poke[j][i]==2 && poke[k][i]!=0 && j!=k) {
                poke[j][i]=0; poke[k][i]--; ans++;
            }
```

#### 2. 369Pai（map统计+抽屉原理）★★★★☆
**关键亮点**  
① 利用 map 简化输入处理  
② 根据总牌数直接推导结果（≥6加2对，3-5且存在2张花色加1对）  
③ 代码极简仅需30行  
**核心思路**  
```cpp
for(auto i:m) { // 遍历所有点数
    int sum = 0, cnt2 = 0;
    for(auto j:i.second) { // 遍历花色
        sum += j.second; // 总牌数
        if(j.second == 2) cnt2++; // 有2张的花色数
    }
    if(sum >=6) ans +=2;
    else if(sum >=3 && cnt2) ans++;
}
```

#### 3. lichenzhen（双循环贪心）★★★★☆  
**关键亮点**  
① 分两阶段处理组合  
② 引入花色排序优化拆解顺序  
**核心代码**  
```cpp
// 处理2+1组合
for(int j=1;j<=4;j++) for(int k=j+1;k<=4;k++)
    if(book[i][j]+book[i][k]==3) { ... }
// 处理2+2拆解
for(int j=1;j<=4;j++) for(int k=j+1;k<=4;k++)
    if(book[i][j]+book[i][k]>=3) { ... }
```

---

### 最优关键思路总结
1. **桶排统计**：二维数组存储各点数、花色的数量  
2. **贪心优先级**：优先处理 2张+1张 组合，再拆解 2张+2张  
3. **总牌数规律**：当某点数总牌数≥6时可直接加2对（抽屉原理）  
4. **代码优化**：用 `map<char, map<char,int>>` 避免字符转换  

---

### 拓展与举一反三
1. **同类题目推荐**  
   - P1090 [NOIP2004] 合并果子（贪心优先队列）  
   - P1047 [NOIP2005] 校门外的树（区间标记+桶排思想）  
   - P1106 [BJWC2007] 删数问题（贪心策略优化）  

2. **调试心得摘录**  
   > "原以为按输入顺序处理即可，后发现必须优先处理最优组合，否则会漏解" —— huangmingyi  
   > "将花色数量排序后，总是先消耗数量少的花色" —— FanYongchen  

---

### 关键代码片段（昒昕做法1）
```cpp
int main() {
    // 输入处理略
    for (int i=1;i<=13;i++) {
        // 第一次处理2+1组合
        for (int j=1;j<=4;j++) 
            for (int k=1;k<=4;k++)
                if (poke[j][i]==2 && poke[k][i]==1 && j!=k) {
                    poke[j][i]=0; poke[k][i]=0; ans++;
                }
        // 第二次处理拆解
        for (int j=1;j<=4;j++)
            for (int k=1;k<=4;k++)
                if (poke[j][i]==2 && poke[k][i]!=0 && j!=k) {
                    poke[j][i]=0; poke[k][i]--; ans++;
                }
    }
    printf("%d\n",ans);
}
```

---
处理用时：60.37秒
# 题目信息

# 「Wdoi-2」花如幻想一般

## 题目背景

冬的白色被春日的阳光所点缀，幻想乡完全取回了生机的颜色。但，樱花，向日葵，野菊花，桔梗……明明还是春天，全年的花却全都盛开了。

六十年前（注：现实中的 1945 年）的大战，炮火声中、枪林弹雨中，无数的无辜的亡魂，在六十年后纷纷落于幻想之中，寄托于每一朵花上。

每一朵花寄托着每一朵亡魂的灵魂本质。向日葵寄宿着开朗的人的灵魂。彼岸花寄宿了没有朋友的寂寞灵魂，紫色的樱树下满是持有罪恶的幽灵。由于是从有德的幽灵开始按顺序送往彼岸，留到最后的都将是樱花。

外面的人类所看到的虚幻的彼岸，正回归于幻想的此岸。

## 题目描述

### 简要题意

有一个长度为 $n$ 的序列 $a$。可以进行两种操作：
- 将整个序列翻转；
- 将序列中的某个数加上某个**整数**。

问：至少要用多少次操作可以将序列 $a$ 转化为序列 $b$。

### 原始题意

参与解决花之异变的十余位主角都并未年满 60 岁，并没有经历过上一次的花之异变。在万花丛中解决异变的紧迫性逐渐被消弭，取而代之的是用花朵来进行游戏。

灵梦将 $n$ 个花朵排成了一排，第 $i$ 朵花都有其对应的美丽程度 $a_i$。而一旁的魔理沙作为一位魔法使，拥有两种能力。她可以进行若干次操作，每次操作可以**使得这 $\bm n$ 朵花的位置完全翻转**，或者可以**将某一朵花的美丽程度加上或减去一个整数**。

灵梦认为，如果能用魔理沙的操作，使得最后花朵的美丽程度可以变成序列 $b_i$，那么将会是很好的。为了解决异变顺利，魔理沙希望自己的操作次数尽可能少。那么请问魔理沙为了满足灵梦的愿望至少需要操作几次？

---

幻想乡的花儿渐落，新绿开始步向美丽的季节。经过六十年还不会被遗忘的记忆，可能是没有的吧。

## 说明/提示

### 样例解释 \#1

$$
\begin{array}{cccl}
\color{red}1&\color{red}2&\color{red}3&\downarrow\text{reverse}\\
3&2&1&
\end{array}
$$

### 样例解释 \#2

$$
\begin{array}{ccl}
\color{red}3&\color{red}1&\downarrow\text{reverse}\\
1&\color{red}3&\downarrow\text{add }-1\\
1&2&
\end{array}
$$

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值}\\\hline
1 & 10 & - & 10\\\hline
2 & 10^3 & - & 30\\\hline
3 & 5\times 10^5 & \text{A} & 5 \\\hline
4 & 5\times 10^5 & - & 55 \\\hline
\end{array}$$

- 特殊性质 $\textbf{A}$：保证存在一种花费最小的方案，不需要执行第二种操作。

对于全部数据，满足 $1 \leq n \leq 5\times10^5$，
$1 \leq a_i,b_i \leq 10^9$。

## 样例 #1

### 输入

```
3
1 2 3
3 2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
2
3 1
1 2```

### 输出

```
2```

# AI分析结果



### 综合分析与结论
本题核心在于分析翻转操作的最优策略（最多一次），通过比较翻转前后的差异数确定最小操作次数。所有题解均基于以下关键思路：
1. 翻转操作最多执行1次（两次翻转无效）。
2. 分别计算不翻转和翻转后的差异数，取最小值。
3. 翻转时差异数需+1（计入翻转操作自身）。

### 精选题解列表

#### 1. 作者：chen_zhe (★★★★★)
**关键亮点**  
- 思路清晰，直接分类讨论两种情况。
- 代码简洁高效，无需额外空间存储翻转数组。
- 时间复杂度O(n)，完美适配数据规模。

**核心代码解析**  
```cpp
int cnt1=0,cnt2=1;  // cnt2初始为1（计入翻转操作）
for(int i=1;i<=n;i++) cnt1 += (a[i]!=b[i]);  // 不翻转的差异数
for(int i=n;i>=1;i--) cnt2 += (a[n-i+1]!=b[i]);  // 翻转后的差异数
cout << min(cnt1, cnt2);
```
通过遍历两次原数组，分别计算两种情况的差异数，取最小值。

#### 2. 作者：SolIII (★★★★★)
**关键亮点**  
- 预处理翻转数组，逻辑直观。
- 代码可读性强，变量命名清晰。
- 显式处理翻转后的数组，便于理解。

**核心代码解析**  
```cpp
for(int i=1;i<=n;i++) c[n-i+1] = a[i];  // 预处理翻转数组c
int cnt1=0, cnt2=1;
for(int i=1;i<=n;i++) {
    cnt1 += (a[i]!=b[i]);      // 不翻转的差异数
    cnt2 += (c[i]!=b[i]);      // 翻转后的差异数（c为已翻转的数组）
}
cout << min(cnt1, cnt2);
```

#### 3. 作者：hycqwq (★★★★☆)
**关键亮点**  
- 提供独立翻转函数，模块化设计。
- 代码结构清晰，便于扩展。
- 直接修改原数组翻转，节省空间。

**核心代码解析**  
```cpp
void reverseA() {  // 翻转原数组a
    for(int i=1, j=n; i<j; i++,j--) swap(a[i],a[j]);
}
int ans = cal();    // 不翻转的差异数
reverseA();         // 翻转原数组
ans = min(ans, cal() + 1);  // 翻转后的差异数+1
```

### 关键思路总结
- **贪心策略**：翻转操作仅需考虑0次或1次。
- **差异数计算**：直接遍历比较元素是否相等，统计需修改的位置数。
- **空间优化**：可通过索引计算避免存储翻转数组（如chen_zhe的解法）。

### 相似题目推荐
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心策略选择最小操作。
2. [P2870 Best Cow Line](https://www.luogu.com.cn/problem/P2870) - 贪心选择字符排列，涉及翻转策略。
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223) - 通过调整顺序优化结果，类似翻转思想。

### 题解中的个人心得
- **Charlie1202**提到特例分析的重要性，强调需比较两种情况的必要性，避免片面优化。
- **xiaohaoaibiancheng66**的代码提醒注意数组索引从0开始时的边界处理，确保翻转逻辑正确。

---
处理用时：97.53秒
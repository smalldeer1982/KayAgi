# 题目信息

# [USACO22DEC] Cow College B

## 题目描述

Farmer John 计划为奶牛们新开办一所大学！ 

![](https://cdn.luogu.com.cn/upload/image_hosting/wiy5l6d6.png)

有 $N(1 \le N \le 10^5)$ 头奶牛可能会入学。每头奶牛最多愿意支付 $c_i$ 的学费 $(1 \le c_i \le 10^6)$。 Farmer John 可以设定所有奶牛入学需要支付的学费。如果这笔学费大于一头奶牛愿意支付的最高金额，那么这头奶牛就不会入学。Farmer John 想赚尽可能多的钱，从而可以给他的讲师提供一笔可观的工资。请求出他能赚到的钱的数量，以及此时应当收取多少学费。 

## 说明/提示

### 样例 1 解释

如果 Farmer John 收费 $4$，那么 $3$ 头奶牛将会入学，从而使他赚取 $3 \times 4=12$ 的金额。

### 测试点性质

- 测试点 $2-4$ 满足 $c_i \le 1000$。
- 测试点 $5-8$ 满足 $N \le 5000$。
- 测试点 $9-12$ 没有额外限制。 

## 样例 #1

### 输入

```
4
1 6 4 6```

### 输出

```
12 4```

# AI分析结果



### 题解综合分析
本题核心在于确定最优学费必为某个`c_i`，从而避免无效枚举。各题解主要采用排序后线性扫描或后缀和统计，时间复杂度均为可行范围。关键优化点在于利用排序或统计结构快速计算每个可能学费对应的支付数量。

---

### 精选题解

#### 1. NightStriker 的题解（⭐️⭐️⭐️⭐️⭐️）
**关键亮点**：  
- 思路清晰，正确性论证充分。  
- 代码简洁，利用排序后维护剩余数量，时间复杂度`O(n log n)`。  
- 处理相同收入时自动取较小学费，逻辑巧妙。  

**核心代码**：
```cpp
sort(a+1,a+n+1);
int cow = n;
for (int i = 1; i<=n; i++) {
    if (a[i]*cow > ans) {
        ans = a[i]*cow;
        cnt = a[i];
    }
    cow--;
}
```
**实现思想**：排序后，每个元素`a[i]`的收益为`a[i] * (n-i+1)`，遍历取最大值。

---

#### 2. what_can_I_do 的题解（⭐️⭐️⭐️⭐️⭐️）
**关键亮点**：  
- 后缀和预处理，时间复杂度`O(n + max(c_i))`，适合大`n`小值域场景。  
- 代码高效易读，直接统计每个学费的支付数量。  

**核心代码**：
```cpp
for(int i = maxd; i >=1; i--) t[i] += t[i+1]; // 后缀和
for(int i=1; i<=maxd; i++) 
    if(t[i]*i > ans) ans = t[i]*i, k = i;
```
**实现思想**：用桶统计每个值的出现次数，处理后缀和得到`≥i`的数量，枚举所有`i`计算最大值。

---

#### 3. Ray1 的题解（⭐️⭐️⭐️⭐️）
**关键亮点**：  
- 代码极简，直接排序后遍历，逻辑直观。  
- 正确处理相同收入取较小学费。  

**核心代码**：
```cpp
sort(c+1, c+1+n);
for(int i=1; i<=n; i++){
    cnt = c[i] * (n-i+1);
    if(cnt > ans) ans = cnt, bns = c[i];
}
```
**实现思想**：排序后每个元素对应剩余元素数量，遍历取最大乘积。

---

### 关键思路总结
1. **贪心选择**：最优学费必为某个`c_i`，避免无效枚举。  
2. **排序优化**：排序后线性扫描，利用有序性快速计算支付数量。  
3. **后缀和技巧**：统计每个值的出现次数，处理后缀和快速得到`≥i`的数量。  
4. **数据类型**：使用`long long`防止大数溢出。  

---

### 举一反三
- **同类型题推荐**：  
  1. [P2637 第一次，第二次，成交！](https://www.luogu.com.cn/problem/P2637)  
  2. [P2678 跳石头（二分答案）](https://www.luogu.com.cn/problem/P2678)  
  3. [P1102 A-B 数对（统计数值对）](https://www.luogu.com.cn/problem/P1102)  

- **调试心得**：  
  - 注意数据范围，及时使用`long long`。  
  - 排序后处理顺序影响结果，需确认升序/降序逻辑。

---
处理用时：174.38秒
# 题目信息

# [USACO23FEB] Hungry Cow B

## 题目描述

Bessie 是一头饥饿的奶牛。每天晚餐时，如果谷仓中有干草，她会吃掉一捆干草。为了防止 Bessie 挨饿，有些天 Farmer John 会在早晨（晚餐之前）送来一些干草。具体地说，在第 $d_i$ 天，Farmer John 送来了 $b_i$ 捆干草（$1 \leq d_i \leq 10^{14}, 1 \leq b_i \leq 10^9$）。

请计算 Bessie 在前 $T$ 天内共吃掉了多少捆干草。

## 样例 #1

### 输入

```
1 5
1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 5
1 2
5 10```

### 输出

```
3```

## 样例 #3

### 输入

```
2 5
1 10
5 10```

### 输出

```
5```

# AI分析结果



### 综合分析与结论
该题核心在于高效模拟干草消耗过程，处理事件间的间隔及最后的剩余天数。正确方法需维护当前剩余干草，计算每个区间内的消耗，最终处理剩余天数。关键点包括事件间天数与干草量的比较，以及最后时间段的处理。

### 高分题解推荐

#### 1. 作者：Nuyoah_awa（5星）
**关键亮点**：
- 思路巧妙，维护`last`变量表示干草能维持的最后一天，避免逐日计算。
- 时间复杂度O(n)，代码简洁高效。
- 通过总和与`last`的关系直接计算答案，减少中间变量。

**核心代码**：
```cpp
long long n, T, d, b, last = 0, ans = 0;
for (int i = 1; i <= n; i++) {
    cin >> d >> b;
    if (last < d) last = d + b;
    else last += b;
    ans += b;
}
if (last > T) ans -= (last - T - 1);
cout << ans;
```
**实现思想**：每次更新`last`为干草吃完的最后一天，最后根据`last`是否超过T调整答案。

#### 2. 作者：zhlzt（4星）
**关键亮点**：
- 直观模拟每个事件间的消耗过程，逻辑清晰易理解。
- 正确处理所有事件区间及最终剩余天数，代码简洁。

**核心代码**：
```cpp
long long sum = 0, ans = 0, d_prev = 0;
for (int i = 1; i <= n; i++) {
    long long days = d[i] - d_prev;
    long long eat = min(sum, days);
    ans += eat;
    sum = sum - eat + b[i];
    d_prev = d[i];
}
ans += min(sum, t - d_prev + 1);
```
**实现思想**：逐事件计算区间内可吃干草数，最后处理剩余天数到T。

#### 3. 作者：Loser_Syx（4星）
**关键亮点**：
- 与zhlzt思路类似，代码可读性强，变量命名清晰。
- 显式处理区间不足的情况，便于调试。

**个人心得**：  
> "如果食物能够支撑这几天，则直接扣除天数；否则吃光剩余。最后处理剩余天数。"

### 最优关键思路总结
1. **事件区间处理**：每次事件到来时，计算与前一次事件间的天数，比较剩余干草与天数，决定实际消耗量。
2. **剩余干草维护**：更新剩余干草为`sum - 消耗量 + 新送量`。
3. **最终时间段处理**：计算最后一次事件到T天的天数，取剩余干草与该天数的较小值。

### 拓展与举一反三
- **类似问题**：区间覆盖问题（如P5019 铺设道路）、资源调度（如P1090 合并果子）。
- **优化思维**：通过维护关键变量（如`last`）避免逐个时间点模拟，适用于大时间跨度场景。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）
2. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)（区间覆盖模拟）
3. [P1518 两只塔姆沃斯牛](https://www.luogu.com.cn/problem/P1518)（模拟与周期性判断）

---
处理用时：139.90秒
# 题目信息

# [YsOI2023] 前缀和

## 题目背景

Ysuperman 模板测试的试机题。

小心立秋，小心秋丽。

## 题目描述

立秋有一个长度为 $n$ 的数组 $a$，所有数字都是正整数，并且除了其中第一个数字以外其它数字都等于前面所有数字的和。

例如，数组 $[1,1,2,4,8,16]$ 就有可能是立秋有的一个数组，因为除了第一个数字 $1$，后面的每个数字都是前面数字的和，例如：

- 第二个数字 $1=1$。
- 第三个数字 $2=1+1$。
- 第四个数字 $4=1+1+2$。
- 第五个数字 $8=1+1+2+4$。
- 第六个数字 $16=1+1+2+4+8$。 

现在立秋告诉了秋丽数字 $x$ 存在于这个数组中，秋丽希望知道 $a_n$ 最小会是多少，或者说整个数组最后一个数字最小有多少。

## 说明/提示

#### 样例 1 解释

- 第一组数据只有唯一可能的数组 $[2,2]$，所以答案为 $2$；
- 第二组数据有两种可能的数组，分别是 $[2,2,4]$ 和 $[1,1,2]$，所以答案为 $2$；
- 第三组数据有两种可能的数组，分别是 $[2,2,4,8]$ 和 $[1,1,2,4]$，所以答案为 $4$。

#### 样例 2 解释

- 第一组数据只有唯一可能的数组 $[1,1,2]$，所以答案为 $2$；
- 第二组数据有两种可能的数组 $[1,1,2]$ 和 $[2,2,4]$，所以答案为 $2$；
- 第三组数据有两种可能的数组 $[2,2,4]$ 和 $[4,4,8]$，所以答案为 $4$。

#### 数据范围

对于前 $30\%$ 的数据，满足 $x$ 不能被 $2$ 整除，或者说 $2$ 不是 $x$ 的一个因数，或者说 $x$ 是奇数。

另有 $30\%$ 的数据，满足 $x$ 可以被 $2^{n-2}$ 整除，或者说 $2^{n-2}$ 是 $x$ 的一个因数。

另有 $20\%$ 的数据，满足 $x\le 1000$，可以证明在这个数据范围下答案可以使用一个 `int` 类型变量存储。

对于 $100\%$ 的数据，满足 $1\le T\le 10^4$，$2\le n\le 20$，$1\le x\le 10^9$。

## 样例 #1

### 输入

```
3
2 2
3 2
4 2```

### 输出

```
2
2
4```

## 样例 #2

### 输入

```
3
3 1
3 2
3 4```

### 输出

```
2
2
4```

## 样例 #3

### 输入

```
3
2 6
3 6
4 6```

### 输出

```
6
6
12```

## 样例 #4

### 输入

```
3
3 3
3 6
3 12```

### 输出

```
6
6
12```

# AI分析结果



### 综合分析与结论

该题要求构造满足特定条件的数组，并找到包含给定数x时，数组末项的最小可能值。通过分析数列规律，发现从第三项开始每一项是前一项的两倍。最优策略是将x置于尽可能靠后的位置，以减少末项的倍增次数。各题解核心思路均为分解x的2因子数，确定其最大可能位置，并计算末项。

---

### 精选题解

#### 1. 2011FYCCCTA（4星）
**关键亮点**：  
- 分奇偶讨论，思路简洁清晰。  
- 直接数学推导，时间复杂度O(T log x)。  
**改进点**：  
- 使用`pow`可能存在精度风险，建议改用位运算。  
**核心代码**：  
```cpp
if (x % 2) ans = x * (1LL << (n - 2));
else {
    int tx = x, sum = 2;
    while (tx % 2 == 0 && sum < n) { tx /= 2; sum++; }
    ans = tx * (1LL << (n - 2));
}
```

#### 2. Esperance（4星）
**关键亮点**：  
- 快速幂确保计算准确，避免浮点误差。  
- 倒序枚举x的可能位置，逻辑严谨。  
**核心代码**：  
```cpp
for (int i = n; i >= 2; i--) {
    ll f = ksm(2, i-2);
    if (x % f == 0) { 
        cout << x * ksm(2, n-i) << '\n';
        break;
    }
}
```

#### 3. KAqwq（4星）
**关键亮点**：  
- 位运算处理2的幂次，高效可靠。  
- 直接计算分解次数，代码简洁。  
**核心代码**：  
```cpp
LL num = x, ans = 2;
while (!(num & 1)) { num /= 2; ++ans; }
if (n <= ans) cout << x << '\n';
else cout << (1LL << (n - ans)) * x << '\n';
```

---

### 关键思路总结
- **数学推导**：数列呈2的幂次增长，末项为基数乘以2^{n-2}。  
- **贪心策略**：x的2因子数决定其最大可能位置，末项最小化需x尽量靠后。  
- **位运算优化**：避免浮点误差，直接计算2的幂次。

---

### 拓展与举一反三
- **类似题型**：涉及数列构造与因数分解的题目，如[CF1475A](https://www.luogu.com.cn/problem/CF1475A)（因数奇偶性）、[P7071](https://www.luogu.com.cn/problem/P7071)（二进制构造）。  
- **优化技巧**：快速幂、位运算处理大数幂次。  
- **思维模式**：逆向思维（倒序枚举可能位置）、分解问题（奇偶分治）。

---

### 推荐题目
1. [P7071 优秀的拆分](https://www.luogu.com.cn/problem/P7071)  
2. [CF1475A Odd Divisor](https://www.luogu.com.cn/problem/CF1475A)  
3. [P2118 比例简化](https://www.luogu.com.cn/problem/P2118)

---
处理用时：229.25秒
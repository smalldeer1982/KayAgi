# 题目信息

# 「PHOI-1」雨纷纷

## 题目背景

**形式化题面的表述已更改。**

今夜，雨纷纷……

![](https://cdn.luogu.com.cn/upload/image_hosting/aec4ykim.png)

## 题目描述

在 $n$ 行 $m$ 列的空地上，有一个大小为 $x$ 行 $y$ 列的伞，雨伞不可以旋转。每天向空地随机洒下 $1 \sim k$ 滴雨，已经有雨的格子不会再降下雨，有伞的格子不会被雨淋湿。

但此伞比较特殊，它完全透明，小 X 无法直接得知伞的位置。但是每天结束后，小 X 都会得知空地上每个空格的状态，即有雨滴或无雨滴。注意，小 X 只会得知格子的状态。小 X 无法得知每天在哪里降了雨。

现在小 X 想让你求出**在最好情况下**（即天数最少时）几天可以使伞的位置唯一，以及得到伞的位置后，场上至少的雨滴数量，数据保证有解。

**形式化的讲**，有一个 $n \times m$ 的矩形，你每天可以**至多**删除 $k$ 个格子。问至少需要多少天以及至少需要删除多少格子，才能使得图中完整的 $x\times y$ 的矩形唯一。

## 说明/提示

**本题采用捆绑测试。**

| Subtask | $n,m$ | $x,y$ |  分值 |
| :-: | :-: | :-: | :-: |
| $0$ | $1\le n,m\le 10$ | 无特殊限制 | $10$ |
| $1$ | $1\le n,m\le 10^3$ | 无特殊限制 | $30$ |
| $2$ | 无特殊限制 | $x=y=2$ | $10$ |
| $3$ | 无特殊限制 | $1 \le x=y \le 10^9$ | $10$ | 
| $4$ | 无特殊限制 | 无特殊限制 | $40$ | 

对于 $100\%$ 的数据，保证 $1 \le x \le n \le 10^9,1 \le y \le m \le 10^9,1 \le k \le 10^9$。

### 样例解释 #1：

第一天在 $(2,2),(2,3),(3,2)$ 处落下雨滴，即可确定雨伞左上角以及右下角位置为 $(3,3),(4,4)$。

图片解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/fp2m6ivv.png)
### 样例解释 #2：

第一天在 $(2,2),(7,1)$ 处落下雨滴，第二天在 $(5,4)$ 处落下雨滴，第三天在 $(4,2),(3,4)$ 处落下雨滴，即可确定雨伞左上角以及右下角位置为 $(5,2),(7,3)$。

## 样例 #1

### 输入

```
4 4 2 2 3```

### 输出

```
1 3```

## 样例 #2

### 输入

```
7 5 3 2 2```

### 输出

```
3 5```

## 样例 #3

### 输入

```
214 748 3 64 8```

### 输出

```
98 782```

# AI分析结果



### 综合分析与结论
本题的核心在于通过最少雨滴数排除所有可能存在的伞位置，仅保留唯一解。各题解均基于贪心策略，将空地划分为多个x*y块，每个块对应一个可能的伞位置。通过在这些块的关键点撒雨滴（保留一个块），并结合余数区域的处理，确定最少雨滴数。天数则通过雨滴数除以k向上取整得到。

---

### 精选题解

#### 1. 作者：CultReborn（⭐️⭐️⭐️⭐️⭐️）
**关键亮点**：
- 将问题转化为网格划分，明确块数与余数处理方式。
- 通过四种条件分支覆盖所有边界情况，思路清晰。
- 代码结构清晰，函数拆分合理，可读性强。

**核心实现**：
```cpp
LL Get_Rain(LL n, LL m, LL x, LL y) {
    LL modx = n / x, mody = m / y;
    bool remX = (n % x != 0), remY = (m % y != 0);
    if (!remX && !remY) return modx * mody - 1;
    if (remX && remY) return modx * mody + 1;
    return modx * mody; // 其余两种情况
}
```

#### 2. 作者：sc84bbs（⭐️⭐️⭐️⭐️）
**关键亮点**：
- 三步走策略：排除所有可能→删点留空→补余数雨滴。
- 代码简洁，直接计算块数后调整余数，逻辑紧凑。

**核心实现**：
```cpp
int modx = n/x, mody = m/y;
ans1 = modx * mody - 1;
if (n%x != 0) ans1++;
if (m%y != 0) ans1++;
```

#### 3. 作者：sbno333（⭐️⭐️⭐️⭐️）
**关键亮点**：
- 直接计算块数后处理余数，代码极简，适合快速理解。
- 明确强调“不开long long见祖宗”，提醒常见错误。

**核心实现**：
```cpp
x1 = n/x; y1 = m/y;
an = x1 * y1 - 1;
if (n%x) an++;
if (m%y) an++;
```

---

### 最优关键思路总结
1. **块划分法**：将空地划分为`(n/x)*(m/y)`个x*y块，每个块对应一个伞的候选位置。
2. **余数处理**：若n或m不能被x或y整除，需在余数区域补1雨滴。
3. **保留唯一块**：总雨滴数为块数-1（排除其他块）加上余数雨滴数（0、1或2）。
4. **天数计算**：总雨滴数除以k向上取整。

---

### 扩展与相似题目
1. **覆盖问题**：类似用关键点排除多个可能区域的思路。
   - 推荐题目：[P1889 士兵站队](https://www.luogu.com.cn/problem/P1889)
2. **贪心策略**：每天最大化利用k次操作的贪心思想。
   - 推荐题目：[P1209 [USACO1.3] 修理牛棚 Barn Repair](https://www.luogu.com.cn/problem/P1209)
3. **数学取整应用**：处理边界时的向上/向下取整技巧。
   - 推荐题目：[P1087 FBI树](https://www.luogu.com.cn/problem/P1087)（考察分块与递归）

---
处理用时：322.45秒
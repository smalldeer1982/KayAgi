# 题目信息

# [NOIP2023] 词典

## 题目描述

小 S 的词典里有 $n$ 个两两不同的、长度均为 $m$ 的单词 $w_1,w_2,\cdots,w_n$。每个单词都是一个小写字母构成的字符串。

小 S 可以做以下操作任意多次（可以不做）：选择词典中的任意一个单词，交换其中任意两个字符。

对于每个 $1 \le i \le n$，小 S 想知道，是否可以通过以上操作得到新的 $n$ 个单词 $w'_1,w'_2,\cdots , w'_n$，使得对于每个 $j \neq i$，$w'_i$ 的字典序比 $w'_j$ 都要小。**对于 $n=1$ 的情况，我们约定：上述性质是自然成立的。**

对于两个同样长度的字符串 $s = s_1s_2\cdots s_L$ 和 $t = t_1t_2 \cdots t_L$，称字符串 $s$ 字典序小于字符串 $t$，当且仅当以下条件成立：存在位置 $i$，在第 $i$ 个字符之前 $s$ 和 $t$ 都相同，而且 $s_i < t_i$，即小写字母 $s_i$ 在英文字母顺序中先于 $t_i$。

## 说明/提示

**【样例解释 #1】**

- 不做任何操作，第一个单词字典序最小，因此输出第一个字符为 `1`；
- 交换 `bananaa` 的前两个字符以及 `abandon` 的第三个和第六个字符，得到 `abondan`, `abnanaa`, `baannaa`, `notnotn`，此时第二个单词字典序最小，因此输出第二个字符为 `1`；
- 交换 `baannaa` 的第一个和最后一个字符得到 `aaannab`，其余字符串不变，此时第三个单词字典序最小，因此输出第三个字符为 `1`；
- 无论如何操作，第四个单词不会小于第二个单词，因此输出第四个字符为 `0`。

**【样例解释 #2】**

该组样例满足测试点 $4$ 的限制。

**【样例解释 #3】**

该组样例满足测试点 $7$ 的限制。

**【样例解释 #4】**

该组样例满足测试点 $10$ 的限制。

**【数据范围】**

对于所有测试数据，保证：$1 \le n \le 3000$，$1 \le m \le 3000$，$w_i$ 为长度为 $m$ 的小写字母字符串且两两不同。

| 测试点编号 | $n\leq$ | $m\leq$ |
| :----------: | :----------: | :----------: |
| $1$ | $1$ | $1$ |
| $2\sim 4$ | $26$ | $1$ |
| $5\sim 7$ | $15$ | $2$ |
| $8$ | $300$ | $300$ |
| $9$ | $10^3$ | $10^3$ |
| $10$ | $3000$ | $3000$ |

## 样例 #1

### 输入

```
4 7
abandon
bananaa
baannaa
notnotn
```

### 输出

```
1110```

# AI分析结果



### 综合分析与结论
本题核心在于通过贪心策略预处理极值，将字符串比较问题转化为字符级的极值比较。最优解法时间复杂度为 $O(nm + n^2)$，巧妙利用字符重排特性，避免了暴力比较所有排列的复杂操作。

---

### 高星题解推荐

#### 1. xuan_gong_dong（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 极简的极值预处理思路，代码仅需记录每个字符串的min和max字符  
- 正确性证明清晰，明确指出必须严格小于其他字符串的max字符  
- 代码实现简洁高效，无冗余操作  

**核心代码**：  
```cpp
for(int i=1;i<=n;i++) {
    int flag=1;
    for(int j=1;j<=n;j++) {
        if(i==j)continue;
        if(k[i]>=k2[j]) { flag=0; break; }
    }
    printf("%d",flag);
}
```

#### 2. Moeebius（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 使用 'a'-'z' 的ASCII值直接比较，避免字符转数字的冗余操作  
- 特判n=1的边界情况，代码鲁棒性强  
- 变量命名规范，代码可读性极佳  

**核心代码**：  
```cpp
For(i,1,n) {
    minv[i] = 'z' + 1, maxv[i] = 0;
    For(j,1,m)
        minv[i] = min(minv[i], str[i][j]),
        maxv[i] = max(maxv[i], str[i][j]);
}
```

#### 3. _Dolphin_（⭐⭐⭐⭐）
**关键亮点**：  
- 结构体存储极值，代码结构清晰  
- 注释明确解释比较逻辑，便于理解  
- 采用布尔短路优化，减少不必要的循环  

**核心代码**：  
```cpp
afor(i,1,n) {
    bool ans=1;
    afor(j,1,n) if(j!=i&&a[i].a>=a[j].b) ans=0;
    printf("%d",ans);
}
```

---

### 最优关键思路
**贪心极值法**：  
1. 对每个字符串预处理其最小字符（升序排列后的首字符）和最大字符（降序排列后的首字符）  
2. 对于字符串 $w_i$，当且仅当 $\forall j \neq i,\ min(w_i) < max(w_j)$ 时满足条件  
3. 证明：可通过将 $w_i$ 排列为最小字典序，其他字符串排列为最大字典序，此时只需比较首字符的极值关系  

**数学归纳**：  
- 若存在某字符串 $w_j$ 的max字符 ≤ $w_i$ 的min字符，则无论如何排列，$w_j$ 的首字符必然 ≥ $w_i$ 的首字符，导致 $w_i$ 无法成为最小

---

### 拓展与相似题目
**同类型套路**：  
- 极值预处理：如区间极值、前缀极值等  
- 字典序贪心：通过构造极端情况比较，避免全排列枚举  

**推荐题目**：  
1. P1090 [NOIP2004] 合并果子（贪心极值）  
2. P1012 [NOIP1998] 拼数（字符串极值排列）  
3. P1106 删数问题（字典序贪心构造）  

---

### 调试经验摘录
**strcmp作者**：  
> "考场上因为以为strcmp返回-1,0,1寄掉了，geany和dev都是对的..."  
**教训**：标准库函数的具体行为需严格验证，如strcmp实际返回差值而非固定-1/0/1  

**rainygame**：  
> 使用bitset优化比较过程，但最终复杂度仍不理想  
**启示**：正确评估算法复杂度优先级，避免过度优化简单问题

---
处理用时：68.59秒
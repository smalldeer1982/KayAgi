# 题目信息

# 寻找团伙

## 题目描述

世界局势风云变幻，你想办一件大事。办事自然要有人参与，你能从 $n$ 个人里面挑选一部分人共襄盛举。

要办这件事，一共涉及 $k$ 方面的能力，例如游说他人的能力、玩游戏的能力、睡觉的能力。每位人士都会具备某一些能力，例如机器猫就可能擅长睡觉、擅长玩游戏，而不擅长游说他人。

你的计划很宏伟，因此你希望团队拥有很全面的能力。不幸的是，如果团队中有偶数个人拥有同一类能力，那么他们就会分成两派，争执不下，导致整个团队丧失这方面的能力。相应地，如果这项能力只有奇数个人拥有，那么他们总能形成一个多数派，帮团队去做这方面的工作。

需要注意的是，团队拥有的每一项能力，对计划的成功率的贡献是不一样的。第一项能力最重要，它的权重是 $2^{k-1}$；第二项能力的权重是 $2^{k-2}$；依次类推。第 $k$ 项能力最不重要，权重只有 $1$。

计划的成功率得分，即是**团队拥有的所有能力对应的权重之和**。

你希望计划成功率最大。因此，你需要选出合适的人士，来参与到你的宏图伟业中。


## 说明/提示

#### 样例解释

第一组样例，共 5 个人，每个人拥有的能力不一样。最终选择的结果是让这 5 个人都参与计划，得分 $16+8+4+2+1 = 31$。

第二组样例，我们选择只让 $1$ 参与。那么团队具有能力 $1,2, 3$，得分 $16+8+4=28$。

第三组样例，我们让 $1,2,3$ 参与。由于团队中有偶数个成员拥有能力 $5$，故团队并不拥有能力 $5$。奇数个成员拥有能力 $2$，故团队拥有能力 $2$。最终，团队具有能力 $1,2,3,4$。得分 $16+8+4+2=30$。

#### 数据规模与约定

对于 $100\%$ 的数据，有 $n\leq 21, k\leq 60$。




## 样例 #1

### 输入

```
5 5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
31```

## 样例 #2

### 输入

```
3 5
3 1 2 3
4 2 3 4 5
2 3 4```

### 输出

```
28```

## 样例 #3

### 输入

```
3 5
2 1 2
3 5 3 2
3 4 2 5```

### 输出

```
30```

## 样例 #4

### 输入

```
21 60
0 
0 
3 60 27 48
0 
1 48
2 52 14
2 4 31
0 
0 
2 28 43
2 6 31
0 
1 7
3 45 6 48
0 
1 51
0 
2 28 20
2 37 51
1 8
53 59 39 29 23 53 27 13 16 44 34 38 24 9 32 58 54 31 1 7 45 3 30 36 17 48 42 22 18 21 6 11 25 33 37 52 10 60 49 57 2 28 8 14 5 47 4 41 35 43 50 46 26 12```

### 输出

```
1152884121210322895```

# AI分析结果



### 综合分析与结论
本题核心为求子集异或和的最大值，关键思路是将每个能力转化为二进制权重，通过异或操作处理奇偶性。当 $n \leq 21$ 时，暴力枚举子集可行；更优解是利用线性基，将复杂度优化至 $O(nk)$，适用于更大数据范围。各题解中，线性基解法最优，暴力枚举在数据范围内可行但效率较低。

---

### 精选题解与评分

#### 1. 作者：Usada_Pekora（★★★★★）
**关键亮点**：  
- 提供暴力枚举和线性基两种解法，全面覆盖不同数据场景。  
- 线性基解法代码简洁高效，复杂度 $O(nk)$，适合举一反三。  
**个人心得**：  
> “第二天才想起来线性基，积累算法技巧很重要。”  

**核心代码（线性基部分）**：  
```cpp
void insert(ull x) {
    for(ull i = k - 1; ~i; i--) {
        if(x & (1ull << i)) {
            if(!base[i]) {
                base[i] = x;
                break;
            }
            else x ^= base[i];
        } 
    }
}
ull query() {
    ull res = 0;
    for(ull i = k - 1; ~i; i--) 
        if((res ^ base[i]) > res) 
            res ^= base[i];
    return res;
}
```

#### 2. 作者：阮行止（★★★★）  
**关键亮点**：  
- 递归枚举子集，思路清晰，代码可读性强。  
- 明确处理位运算溢出问题（`1ULL`），确保正确性。  

**核心代码（递归枚举）**：  
```cpp
void dfs(int pos) {
    if(pos == n) {
        ull res = 0;
        for(int i=0; i<n; i++)
            if(choice[i]) res ^= p[i];
        ans = max(res, ans);
        return;
    }
    dfs(pos + 1); // 不选当前元素
    choice[pos] = 1;
    dfs(pos + 1); // 选当前元素
}
```

#### 3. 作者：5k_sync_closer（★★★★）  
**关键亮点**：  
- 位运算直接枚举子集，代码简洁，无递归栈开销。  
- 正确使用 `unsigned long long` 避免溢出。  

**核心代码（位运算枚举）**：  
```cpp
for(ull s = 0; s < (1ull << n); ++s) {
    ull sum = 0;
    for(int i = 0; i < n; ++i)
        if(s & (1ull << i)) sum ^= p[i];
    ans = max(ans, sum);
}
```

---

### 关键思路与技巧
1. **线性基贪心法**：  
   - 将元素逐位插入基中，高位优先，确保基中元素互异且最高位唯一。  
   - 贪心异或高位基元素，保证结果最大。  
2. **位运算优化**：  
   - 使用 `unsigned long long` 处理大范围位运算，避免溢出。  
   - 子集枚举通过二进制位掩码实现，简化代码逻辑。  

---

### 拓展与相似题目
1. **同类型题目**：  
   - [P3857 [TJOI2008]彩灯](https://www.luogu.com.cn/problem/P3857)：线性基求异或组合数。  
   - [P4151 [WC2011]最大XOR和路径](https://www.luogu.com.cn/problem/P4151)：图上线性基应用。  
   - [P4839 P 哥的桶](https://www.luogu.com.cn/problem/P4839)：线段树维护线性基。  

2. **调试与优化**：  
   - 位运算需注意类型（如 `1ULL`），避免未定义行为。  
   - 线性基插入时需从高位到低位处理，确保贪心正确性。

---
处理用时：133.51秒
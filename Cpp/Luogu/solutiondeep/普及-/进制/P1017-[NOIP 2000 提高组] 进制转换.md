# 题目信息

# [NOIP 2000 提高组] 进制转换

## 题目背景

NOIP2000 提高组 T1

## 题目描述

我们可以用这样的方式来表示一个十进制数：将每个阿拉伯数字乘以一个以该数字所处位置为指数，以 $10$ 为底数的幂之和的形式。例如 $123$ 可表示为 $1 \times 10^2+2\times 10^1+3\times 10^0$ 这样的形式。

与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置为指数，以 $2$ 为底数的幂之和的形式。  

一般说来，任何一个正整数 $R$ 或一个负整数 $-R$ 都可以被选来作为一个数制系统的基数。如果是以 $R$ 或 $-R$ 为基数，则需要用到的数码为 $0,1,\dots,R-1$。  

例如当 $R=7$ 时,所需用到的数码是 $0,1,2,3,4,5,6$，这与其是 $R$ 或 $-R$ 无关。如果作为基数的数绝对值超过 $10$，则为了表示这些数码，通常使用英文字母来表示那些大于 $9$ 的数码。例如对 $16$ 进制数来说,用 $A$ 表示 $10$，用 $B$ 表示 $11$，用 $C$ 表示 $12$，以此类推。

在负进制数中是用 $-R $ 作为基数，例如 $-15$（十进制）相当于 $(110001)_{-2}$（$-2$进制），并且它可以被表示为 $2$ 的幂级数的和数：

$$(110001)_{-2}=1\times (-2)^5+1\times (-2)^4+0\times (-2)^3+0\times (-2)^2+0\times (-2)^1 +1\times (-2)^0$$

设计一个程序，读入一个十进制数和一个负进制数的基数，并将此十进制数转换为此负进制下的数。


## 说明/提示

**数据范围**

对于 $100\%$ 的数据，$-20 \le R \le -2$，$|n| \le 37336$。




## 样例 #1

### 输入

```
30000 -2```

### 输出

```
30000=11011010101110000(base-2)```

## 样例 #2

### 输入

```
-20000 -2```

### 输出

```
-20000=1111011000100000(base-2)```

## 样例 #3

### 输入

```
28800 -16```

### 输出

```
28800=19180(base-16)```

## 样例 #4

### 输入

```
-25000 -16```

### 输出

```
-25000=7FB8(base-16)```

# AI分析结果



### 综合分析与结论
本题核心难点在于负基数下的余数处理：常规取余操作可能得到负余数，需通过调整余数和商使其满足非负要求。绝大多数题解采用「余数调整+商修正」的统一思路，差异主要体现在递归/迭代实现、字符转换方式等细节上。

---

### 精选题解与评分

#### 1. 作者：judgejudge（★★★★☆）
**核心亮点**：
- 给出完整的数学推导，解释余数调整的合法性（`n = (q+1)*r + (m-r)`）
- 采用迭代实现，代码清晰易读
- 通过字符数组存储结果，避免递归可能导致的栈溢出问题

**关键代码**：
```cpp
while(n != 0){
    int j = n % r;
    n /= r;
    if(j < 0) j -= r, n--; // 调整余数为正
    // 存储余数并倒序输出
}
```

#### 2. 作者：老卡手机（★★★★☆）
**核心亮点**：
- 递归实现简洁优雅
- 边计算边输出，节省内存空间
- 直接通过ASCII码转换字符，代码精简

**调试心得**：
> "余数倒序输出要写在递归后面，否则顺序会错" —— 强调递归在进制转换中的执行顺序问题

**关键代码**：
```cpp
void zhuan(int n, int r) {
    if(n == 0) return;
    int m = n % r;
    if(m < 0) m -= r, n += r; // 调整余数
    zhuan(n/r, r);
    printf("%c", m >=10 ? 'A'+m-10 : m+'0');
}
```

#### 3. 作者：ikunTLE（★★★★☆）
**核心亮点**：
- 采用DFS命名但实际是迭代实现，代码极简
- 利用三目运算符压缩字符转换逻辑
- 正确处理边界条件（n=0时直接返回）

**代码亮点**：
```cpp
void dfs(int x) {
    if(!x) return;
    int q = x/b, r = x%b;
    if(r < 0) q++, r -= b; // 调整余数
    dfs(q);
    putchar(r < 10 ? r+'0' : r-10+'A');
}
```

---

### 最优关键思路
**余数调整公式**：当余数`m = n%r < 0`时：
1. 余数调整为`m -= r`（使其变为正）
2. 商调整为`n = n/r + 1`（等价于`n += r`后除以r）

**数学证明**：
```
原式：n = q*r + m  
调整后：n = (q+1)*r + (m-r)
       = q*r + r + m - r 
       = q*r + m
```

---

### 拓展训练
1. **P1143 进制转换**（基础正进制转换）
2. **P1062 数列**（负进制数性质应用）
3. **P1013 进制位**（进制转换与逻辑推理结合）

---

### 关键代码实现（以judgejudge版为例）
```cpp
#include<iostream>
using namespace std;

int main() {
    int n, r;
    cin >> n >> r;
    cout << n << "=";
    
    string ans;
    while(n) {
        int rem = n % r;
        n /= r;
        if(rem < 0) {  // 处理负余数
            rem -= r;
            n++;
        }
        ans = char(rem < 10 ? rem+'0' : rem-10+'A') + ans;
    }
    
    cout << ans << "(base" << r << ")";
}
```

---
处理用时：51.41秒
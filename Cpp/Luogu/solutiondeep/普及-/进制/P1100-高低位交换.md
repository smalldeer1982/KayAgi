# 题目信息

# 高低位交换

## 题目描述

给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。

例如，数 $1314520$ 用二进制表示为 $0000\,0000\,0001\,0100\,0000\,1110\,1101\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\,0000\,0001\,0100$；后 $16$ 位为低位，即 $0000\,1110\,1101\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\,1110\,1101\,1000\,0000\,0000\,0001\,0100$。它即是十进制的 $249036820$。


## 样例 #1

### 输入

```
1314520
```

### 输出

```
249036820
```

# AI分析结果



### 综合分析与结论
本题核心在于高效实现32位无符号整数的高低16位交换。各题解主要分为两类思路：
1. **位运算**：通过掩码提取高低位后移位合并（最优解，O(1)时间复杂度）
2. **模拟转换**：转换为二进制字符串处理再转回十进制（效率低但直观）

超过90%的高赞题解采用位运算，体现了算法优化的核心思想。关键技巧在于：
- 使用无符号类型避免符号位干扰
- 掩码(0xffff0000/0x0000ffff)提取位段
- 移位操作自动处理溢出

---

### 高分题解推荐

#### 1. HenryHuang（⭐⭐⭐⭐⭐）
**核心亮点**：
- 位运算标准解法，代码极度简洁
- 使用掩码精准提取高低位
- 详细解释了十六进制掩码原理
```cpp
cout << ((x&0x0000ffff)<<16 | (x&0xffff0000)>>16);
```

#### 2. 月影困（⭐⭐⭐⭐）
**核心亮点**：
- 最简移位解法，充分利用溢出特性
- 强调无符号类型的关键作用
- 代码仅需3行，适合快速实现
```cpp
printf("%u\n", (n >> 16) + (n << 16));
```

#### 3. ykkz000（⭐⭐⭐⭐）
**创新思路**：
- 通过指针类型转换直接操作内存
- 利用unsigned short的16位特性
- 展示底层数据存储的巧妙应用
```cpp
unsigned short *p = (unsigned short *)&s;
unsigned int n = (*p)<<16 + *(p+1);
```

---

### 关键优化思路
**位运算范式**：
```cpp
result = (low << 16) | (high >> 16)
```
1. **掩码提取**：`x & 0x0000ffff` 取低16位，`x & 0xffff0000` 取高16位
2. **移位合并**：低位左移16位到高位，高位右移16位到低位，用或运算合并
3. **溢出利用**：无符号类型左移自动丢弃溢出位，无需额外处理

---

### 举一反三
**相似题目推荐**：
1. [P1469 找筷子](https://www.luogu.com.cn/problem/P1469)（异或性质应用）
2. [P1017 进制转换](https://www.luogu.com.cn/problem/P1017)（负基数位运算）
3. [P2114 位运算挑战](https://www.luogu.com.cn/problem/P2114)（复合位操作）

**拓展技巧**：
- 任意长度位段交换：构造动态掩码 `(1<<n)-1`
- 循环移位：`(x << k)|(x >> (32-k))` （需考虑无符号类型）
- 位逆序：分治法交换位段

---

### 调试心得摘录
1. **HenryHuang**："位移时多余的位会自动溢出，无需额外处理" → 强调溢出特性
2. **月影困**："开unsigned是避免补码干扰的关键" → 点出符号位陷阱
3. **离散小波变换°**："解法1更巧妙，解法2更易理解" → 对比不同实现的可读性
4. **oierwa**："最初用int输出负数，改为unsigned后解决" → 体现类型选择的重要性

---
处理用时：49.61秒
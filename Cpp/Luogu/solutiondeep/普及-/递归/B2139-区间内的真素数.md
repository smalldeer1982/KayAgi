# 题目信息

# 区间内的真素数

## 题目描述

找出正整数 $M$ 和 $N$ 之间（$N$ 不小于 $M$）的所有真素数。

真素数的定义：如果一个正整数 $P$ 为素数，且其反序也为素数，那么 $P$ 就为真素数。

例如，$11$，$13$ 均为真素数，因为 $11$ 的反序还是为 $11$，$13$ 的反序为 $31$ 也为素数。

## 说明/提示

$1 \le M \le N \le 100000$

## 样例 #1

### 输入

```
10 35```

### 输出

```
11,13,17,31```

# AI分析结果

### 综合分析与结论

本题的核心是判断区间内的数是否是真素数，即该数及其反序数都是素数。题解大多采用暴力枚举的方法，通过判断素数和反序数来实现。虽然题目数据范围不大（1 ≤ M ≤ N ≤ 100000），但部分题解在实现细节上有所不同，主要体现在素数的判断、反序数的生成以及输出的处理上。

### 题解评分与亮点

#### 题解1：5k_sync_closer (5星)
**关键亮点：**
- 代码简洁，逻辑清晰，使用了`to_string`和`reverse`函数来生成反序数，减少了手动处理的复杂度。
- 输出处理得当，使用布尔变量`f`和`b`来控制逗号的输出和“No”情况的判断。
- 素数判断函数优化较好，排除了偶数和1的情况，减少了不必要的计算。

**核心代码：**
```cpp
bool isp(int n) {
    if(n == 1) return 0;
    if(n == 2) return 1;
    if(n % 2 == 0) return 0;
    for(int i = 3; i * i <= n; ++i)
        if(n % i == 0) return 0;
    return 1;
}
```

#### 题解2：封禁用户 (4星)
**关键亮点：**
- 使用了数组存储真素数，便于后续输出处理，避免了输出时最后一个数后不加逗号的问题。
- 素数判断函数和反序数生成函数分离，代码结构清晰。
- 输出处理得当，避免了最后一个数后加逗号的问题。

**核心代码：**
```cpp
bool isPrime(int x) {
    for (int i = 2; i <= sqrt(x); i ++)
        if (x % i == 0) return false;
    return true;
}
```

#### 题解3：Level_Down (4星)
**关键亮点：**
- 使用了数组存储真素数，便于后续输出处理，避免了输出时最后一个数后不加逗号的问题。
- 素数判断函数和反序数生成函数分离，代码结构清晰。
- 输出处理得当，避免了最后一个数后加逗号的问题。

**核心代码：**
```cpp
int cz(int n) {
    int ans = 0;
    while(n) ans = ans * 10 + n % 10, n /= 10;
    return ans;
}
```

### 最优关键思路与技巧

1. **素数判断优化**：排除偶数和1的情况，减少不必要的计算。
2. **反序数生成**：使用`to_string`和`reverse`函数简化反序数的生成。
3. **输出处理**：使用数组存储真素数，便于后续输出处理，避免最后一个数后加逗号的问题。

### 可拓展之处

- **素数筛法**：可以使用埃拉托斯特尼筛法（Sieve of Eratosthenes）预处理素数表，进一步提高效率。
- **反序数生成**：可以进一步优化反序数的生成，避免使用字符串操作，直接通过数学方法生成反序数。

### 推荐题目

1. **B2137 判决素数个数**：考察素数判断的基本方法。
2. **P1217 [USACO1.5]回文质数 Prime Palindromes**：考察回文数和素数的结合。
3. **P3383 【模板】线性筛素数**：考察素数筛法的实现。

### 个人心得摘录

- **调试经历**：部分题解在输出处理上遇到问题，尤其是最后一个数后不加逗号的情况，通过使用数组存储真素数解决了这一问题。
- **踩坑教训**：在判断素数时，忽略了1和偶数的情况，导致部分测试用例失败，通过优化素数判断函数解决了这一问题。
- **顿悟感想**：使用`to_string`和`reverse`函数可以大大简化反序数的生成，减少代码复杂度。

---
处理用时：29.51秒
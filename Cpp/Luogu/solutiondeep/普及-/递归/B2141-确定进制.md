# 题目信息

# 确定进制

## 题目描述

$6\ \times 9=42$ 对于十进制来说是错误的，但是对于 $13$ 进制来说是正确的。即 $6_{(13)}\ \times 9_{(13)}=42_{(13)}$，而 $42_{(13)}=4\ \times 13^1+2\ \times 13^0=54_{(10)}$。

你的任务是写一段程序读入三个整数 $p,q$ 和 $r$，然后确定一个进制 $B(2 \le B \le 16)$ 使得 $p\ \times q=r$。如果 $B$ 有很多选择，则输出最小的一个。

例如：$p=11,q=11,r=121$，则有 $11_{(3)}\ \times 11_{(3)}=121_{(3)}$，因为 $11_{(3)}=1\ \times 3^1+1\ \times 3^0=4_{(10)}$ 和 $121_{(3)}=1\ \times 3^2+2\ \times 3^1+1\ \times 3^0=16_{(10)}$。对于进制 $10,$ 有 $11_{(10)}\ \times 11_{(10)}=121_{(10)}$。这种情况下，应该输出 $3$。如果没有合适的进制，则输出 $0$。

## 说明/提示

$p,q,r$ 的所有位都是数字，并且 $1 \le p,q,r \le 10^6$。

## 样例 #1

### 输入

```
6 9 42```

### 输出

```
13```

# AI分析结果

### 综合分析与结论

本题的核心在于通过枚举进制来验证给定的等式是否成立。各题解的思路基本一致，主要差异在于进制转换的实现方式、代码的优化程度以及可读性。以下是各题解的要点对比：

1. **进制转换的实现**：大多数题解通过将字符串或整数的每一位转换为十进制，再进行乘法运算。部分题解使用了 `pow` 函数，而有些则通过循环累加实现。
2. **枚举进制的起始点**：所有题解都提到了从 `max_digit + 1` 开始枚举，避免无效计算。
3. **数据类型的选择**：部分题解强调了使用 `long long` 以避免溢出问题。
4. **代码优化与可读性**：部分题解通过函数封装提高了代码的可读性，而有些则直接在主函数中实现，代码较为冗长。

### 所选高星题解

#### 题解1：红黑树 (5星)
**关键亮点**：
- 通过函数封装提高了代码的可读性。
- 使用 `max_element` 快速找到最大字符，优化了枚举起始点的计算。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
inline int Min(string p, string q, string r) {
    char MIN = *max_element(p.begin(), p.end());
    MIN = max(MIN, *max_element(q.begin(), q.end()));
    MIN = max(MIN, *max_element(r.begin(), r.end()));
    return MIN - '0' + 1;
}

inline long long B_to(int B, string n) {
    long long num = 0;
    reverse(n.begin(), n.end());
    for (int i = 0; i < n.size(); i++) {
        if (n[i] >= '0' && n[i] <= '9')
            num += pow(B, i) * (n[i] - '0');
        else
            num += pow(B, i) * (n[i] - 'A' - 10);
    }
    return num;
}
```

#### 题解2：囧仙 (4.5星)
**关键亮点**：
- 直接处理整数，避免了字符串操作的复杂性。
- 通过逐位提取和累加实现进制转换，避免了 `pow` 函数的调用。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
i64 p,q,r,o,pp,qq,rr,s;
int main(){
    scanf("%d%d%d",&p,&q,&r);
    pp=p,qq=q,rr=r;
    while(pp) s=max(s,pp%10),pp/=10;
    while(qq) s=max(s,qq%10),qq/=10;
    while(rr) s=max(s,rr%10),rr/=10;
    up(s+1,16,t){
        pp=p;i64 a=0; o=1; while(pp) a+=o*(pp%10),o*=t,pp/=10;
        qq=q;i64 b=0; o=1; while(qq) b+=o*(qq%10),o*=t,qq/=10;
        rr=r;i64 c=0; o=1; while(rr) c+=o*(rr%10),o*=t,rr/=10;
        if(a*b==c) printf("%d\n",t),exit(0);
    }
    puts("0");
    return 0;
}
```

#### 题解3：int32 (4星)
**关键亮点**：
- 通过 `change` 函数实现进制转换，代码复用性高。
- 使用 `max` 函数快速找到最大数位，优化了枚举起始点。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
int change(int a, int base){
    int res=0, i=0;
    while(a){
        res+=(a%10)*(int)(pow(base,i));
        ++i;
        a/=10;
    }
    return res;
}

int pos(int a){
    int res=0;
    while(a){
        res=max(res,a%10);
        a/=10;
        if(res==9) break;
    }
    return res;
}
```

### 最优关键思路与技巧

1. **进制转换的优化**：通过逐位累加实现进制转换，避免使用 `pow` 函数，提高效率。
2. **枚举起始点的确定**：通过找到 `p, q, r` 中的最大数位，从 `max_digit + 1` 开始枚举，减少无效计算。
3. **数据类型的合理选择**：使用 `long long` 避免溢出问题，确保计算的准确性。

### 可拓展之处

- **类似算法套路**：本题的进制转换和枚举思想可以应用于其他进制相关的问题，如进制间的转换、进制下的加减乘除等。
- **同类型题目**：
  - [P1017 进制转换](https://www.luogu.com.cn/problem/P1017)
  - [P1143 进制转换](https://www.luogu.com.cn/problem/P1143)
  - [P2084 进制转换](https://www.luogu.com.cn/problem/P2084)

### 个人心得摘录

- **红黑树**：通过函数封装提高了代码的可读性，避免了重复代码。
- **囧仙**：直接处理整数，避免了字符串操作的复杂性，代码更加简洁。
- **int32**：通过 `change` 函数实现进制转换，代码复用性高，逻辑清晰。

这些心得强调了代码的可读性和复用性，以及如何通过合理的函数封装和数据类型选择来提高代码的质量和效率。

---
处理用时：42.00秒
# 题目信息

# [GESP样题 三级] 进制转换

## 题目描述

小美刚刚学习了十六进制，她觉得很有趣，想到是不是还有更大的进制呢？在十六进制中，用 `A` 表示 $10$、`F` 表示 $15$。如果扩展到用 `Z` 表示 $35$，岂不是可以表示 $36$ 进制数了嘛！

所以，你需要帮助她写一个程序，完成十进制转 $R$ 进制（$2\le R\le 36$）的工作。

## 样例 #1

### 输入

```
123
25```

### 输出

```
4N```

# AI分析结果

### 综合分析与结论

本题要求将十进制数转换为任意进制（2 ≤ R ≤ 36），并输出结果。由于没有现成的题解，我们可以根据题目需求自行设计解决方案。核心思路是通过不断取余和除法操作，将十进制数转换为目标进制，并将余数映射为对应的字符（0-9 和 A-Z）。

### 通用建议与扩展思路

1. **核心算法**：使用循环不断对十进制数进行取余和除法操作，直到商为0。将每次的余数映射为对应的字符，最后将结果反转即为目标进制的表示。
2. **字符映射**：使用一个字符数组或字符串来存储0-9和A-Z的对应关系，方便快速查找。
3. **边界处理**：注意处理输入为0的情况，直接输出0即可。
4. **优化**：可以通过位运算或数学优化来加速进制转换，但本题的输入范围较小，常规方法已足够高效。

### 关键代码实现

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

string decimalToR(int num, int R) {
    if (num == 0) return "0";
    string result;
    const string digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    while (num > 0) {
        result.push_back(digits[num % R]);
        num /= R;
    }
    reverse(result.begin(), result.end());
    return result;
}

int main() {
    int num, R;
    cin >> num >> R;
    cout << decimalToR(num, R) << endl;
    return 0;
}
```

### 关键思路与技巧

1. **字符映射**：使用字符串 `digits` 来存储0-9和A-Z的对应关系，简化了余数到字符的转换。
2. **反转结果**：由于取余操作得到的结果是逆序的，最后需要反转字符串以获得正确的进制表示。
3. **边界处理**：单独处理输入为0的情况，避免循环不执行导致错误。

### 可拓展之处

1. **更高进制**：可以进一步扩展到更大的进制，如62进制（0-9, a-z, A-Z）。
2. **负数和浮点数**：可以扩展支持负数和浮点数的进制转换。
3. **性能优化**：对于非常大的数，可以考虑使用更高效的算法或并行计算来加速转换过程。

### 推荐题目

1. **P1017 进制转换**：考察负数的进制转换，增加了难度。
2. **P1143 进制转换**：要求将任意进制数转换为十进制，与本题相反。
3. **P2084 进制转换**：涉及大数的进制转换，考验算法优化能力。

### 个人心得

在处理进制转换时，字符映射和结果反转是两个关键点。通过使用字符串存储字符映射，可以简化代码并提高可读性。此外，反转结果的操作虽然简单，但容易被忽略，调试时需要注意。

---
处理用时：22.84秒
# 题目信息

# [NOIP 2004 普及组] FBI 树

## 题目描述

我们可以把由 0 和 1 组成的字符串分为三类：全 0 串称为 B 串，全 1 串称为 I 串，既含 0 又含 1 的串则称为 F 串。

FBI 树是一种二叉树，它的结点类型也包括 F 结点，B 结点和 I 结点三种。由一个长度为 $2^N$ 的 01 串 $S$ 可以构造出一棵 FBI 树 $T$，递归的构造方法如下：

1. $T$ 的根结点为 $R$，其类型与串 $S$ 的类型相同；
2. 若串 $S$ 的长度大于 $1$，将串 $S$ 从中间分开，分为等长的左右子串 $S_1$ 和 $S_2$；由左子串 $S_1$ 构造 $R$ 的左子树 $T_1$，由右子串 $S_2$ 构造 $R$ 的右子树 $T_2$。

现在给定一个长度为 $2^N$ 的 01 串，请用上述构造方法构造出一棵 FBI 树，并输出它的后序遍历序列。


## 说明/提示

对于 $40\%$ 的数据，$N \le 2$；

对于全部的数据，$N \le 10$。


noip2004普及组第3题


## 样例 #1

### 输入

```
3
10001011
```

### 输出

```
IBFBBBFIBFIIIFF
```

# AI分析结果

### 综合分析与结论

本题的核心是通过递归构建FBI树，并进行后序遍历输出。题解中大部分采用了递归的方法，部分题解还引入了线段树、二维数组等数据结构来优化或简化问题。总体来看，递归是最直接且易于理解的解决方案，而线段树等数据结构则提供了更高效的实现方式。

### 所选高星题解

#### 1. **作者：ingu (赞：262)**
- **星级：5星**
- **关键亮点**：简洁明了，直接通过递归实现树的构建和后序遍历，代码可读性强，逻辑清晰。
- **核心实现思想**：通过递归将字符串分为左右子串，分别构建左右子树，最后输出根节点的类型。
- **代码片段**：
  ```cpp
  void maketree(int x,int y){
      if(y>x){
          maketree(x,(x+y)/2);
          maketree((x+y+1)/2,y);
      }    
      int B=1,I=1;
      for(int i=0;i<=y-x;i++){
          if(s[x+i]=='1') B=0;
          else if(s[x+i]=='0') I=0;
      }
      if(B) cout<<'B';
      else if(I) cout<<'I';
      else cout<<'F';
  }
  ```

#### 2. **作者：wuhao1027 (赞：148)**
- **星级：4星**
- **关键亮点**：利用二分查找的思想，递归构建树，代码简洁，逻辑清晰。
- **核心实现思想**：通过递归将字符串分为左右子串，分别构建左右子树，最后输出根节点的类型。
- **代码片段**：
  ```cpp
  void work(int low, int up){
      int mid = (low+up)/2;
      if (low!=up){
          work(low, mid);
          work(mid+1,up);
      }
      int i,a=0,b=0;
      for (i=low;i<=up;i++)
          if (A[i]=='0') a++;
          else b++;
      if (a&&b) printf("F");
      else if (a) printf("B");
      else printf("I");
  }
  ```

#### 3. **作者：传说饭 (赞：122)**
- **星级：4星**
- **关键亮点**：通过递归实现树的构建和后序遍历，代码简洁，逻辑清晰。
- **核心实现思想**：通过递归将字符串分为左右子串，分别构建左右子树，最后输出根节点的类型。
- **代码片段**：
  ```cpp
  char FBI(string s) {
      if (s.length() > 1){
          cout << FBI(s.substr(0, s.length()/2));
          cout << FBI(s.substr(s.length()/2, s.length()/2));
      }
      if (s == string(s.length(), '0')) return 'B';
      if (s == string(s.length(), '1')) return 'I';
      return 'F';
  }
  ```

### 最优关键思路与技巧
1. **递归构建树**：通过递归将字符串分为左右子串，分别构建左右子树，最后输出根节点的类型。
2. **后序遍历**：在递归过程中，先遍历左子树，再遍历右子树，最后输出根节点，实现后序遍历。
3. **字符串处理**：通过字符串的`substr`方法或直接遍历字符串，判断字符串的类型（B、I、F）。

### 可拓展之处
1. **线段树**：可以进一步优化树的构建和遍历过程，适用于更复杂的问题。
2. **动态规划**：在某些情况下，可以通过动态规划来优化递归过程，减少重复计算。

### 推荐题目
1. **P1040 加分二叉树**：考察二叉树的构建与遍历。
2. **P1038 二叉苹果树**：考察二叉树的动态规划。
3. **P1082 同余方程**：考察递归与数学结合的应用。

### 个人心得总结
- **调试经历**：在递归过程中，注意边界条件的处理，避免无限递归。
- **踩坑教训**：字符串处理时，注意字符与数字的转换，避免类型错误。
- **顿悟感想**：递归是解决树形结构问题的利器，理解递归的本质是关键。

---
处理用时：36.89秒
# 题目信息

# Function

## 题目描述

对于一个递归函数 $w(a,b,c)$


- 如果 $a \le 0$ 或 $b \le 0$ 或 $c \le 0$ 就返回值 $1$。
- 如果 $a>20$ 或 $b>20$ 或 $c>20$ 就返回 $w(20,20,20)$
- 如果 $a<b$ 并且 $b<c$ 就返回 $w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)$。
- 其它的情况就返回 $w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)$


这是个简单的递归函数，但实现起来可能会有些问题。当 $a,b,c$ 均为 $15$ 时，调用的次数将非常的多。你要想个办法才行。

注意：例如 $w(30,-1,0)$ 又满足条件 $1$ 又满足条件 $2$，请按照最上面的条件来算，答案为 $1$。

## 说明/提示

### 数据规模与约定

保证输入的数在 $[-9223372036854775808,9223372036854775807]$ 之间，并且是整数。

保证不包括 $-1, -1, -1$ 的输入行数 $T$ 满足 $1 \leq T \leq 10 ^ 5$。

## 样例 #1

### 输入

```
1 1 1
2 2 2
-1 -1 -1```

### 输出

```
w(1, 1, 1) = 2
w(2, 2, 2) = 4```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效计算递归函数 `w(a, b, c)`，避免重复计算导致的性能问题。大多数题解都采用了**记忆化搜索**（Memoization）来优化递归，通过存储已经计算过的结果，避免重复计算。部分题解还提到了一些细节处理，如输入数据的范围、数组下标的处理等。

### 所选高星题解

#### 1. **作者：DPair (赞：120)**
- **星级：5星**
- **关键亮点：**
  - 代码结构清晰，逻辑严谨，直接按照题目要求实现记忆化搜索。
  - 使用了三维数组 `dp[25][25][25]` 来存储计算结果，避免了重复计算。
  - 处理了输入数据中的特殊情况（如 `a, b, c` 为负数或大于20的情况）。
  - 代码可读性高，注释详细，适合初学者理解。

**核心代码片段：**
```cpp
LL w(LL a, LL b, LL c)
{
    if(a <= 0 || b <= 0 || c <= 0) return 1;
    if(a > 20 || b > 20 || c > 20) return w(20, 20, 20);
    
    if(a <b && b < c)
    {
        if(dp[a][b][c-1] == 0) dp[a][b][c-1] = w(a, b, c-1);
        if(dp[a][b-1][c-1] == 0) dp[a][b-1][c-1] = w(a, b-1 ,c-1);
        if(dp[a][b-1][c] == 0) dp[a][b-1][c] = w(a, b-1, c);
        dp[a][b][c] = dp[a][b][c-1] + dp[a][b-1][c-1] - dp[a][b-1][c];
    }
    else
    {
        if(dp[a-1][b][c] == 0) dp[a-1][b][c] = w(a-1, b, c);
        if(dp[a-1][b-1][c] == 0) dp[a-1][b-1][c] = w(a-1, b-1 ,c);
        if(dp[a-1][b][c-1] == 0) dp[a-1][b][c-1] = w(a-1, b, c-1);
        if(dp[a-1][b-1][c-1] == 0) dp[a-1][b-1][c-1] = w(a-1, b-1, c-1);
        dp[a][b][c] = dp[a-1][b][c] + dp[a-1][b][c-1] + dp[a-1][b-1][c] - dp[a-1][b-1][c-1];
    }
    
    return dp[a][b][c];
}
```

#### 2. **作者：用户已注销 (赞：72)**
- **星级：4星**
- **关键亮点：**
  - 使用了 `vis[25][25][25]` 数组来标记是否已经计算过某个 `w(a, b, c)`，避免重复计算。
  - 代码简洁，逻辑清晰，适合有一定基础的读者。
  - 处理了输入数据中的特殊情况，如 `a, b, c` 为负数或大于20的情况。

**核心代码片段：**
```cpp
int mw(long long a,long long b,long long c)
{
    if(a<=0 or b<=0 or c<=0) return 1;
    if(a>20 or b>20 or c>20) return mw(20,20,20);
    if(vis[a][b][c]) return w[a][b][c];
    if(a<b and b<c)
        w[a][b][c]=mw(a,b,c-1)+mw(a,b-1,c-1)-mw(a,b-1,c);
    else
        w[a][b][c]=mw(a-1,b,c)+mw(a-1,b-1,c)+mw(a-1,b,c-1)-mw(a-1,b-1,c-1);
    vis[a][b][c]=true;
    return w[a][b][c];
}
```

#### 3. **作者：Stalker (赞：26)**
- **星级：4星**
- **关键亮点：**
  - 使用了 `f[40][40][40]` 数组来存储计算结果，避免了重复计算。
  - 处理了输入数据中的特殊情况，如 `a, b, c` 为负数或大于20的情况。
  - 代码简洁，逻辑清晰，适合有一定基础的读者。

**核心代码片段：**
```cpp
llx fun(llx x,llx y,llx z){
    if(x<=20&&y<=20&&z<=20&&x>=0&&y>=0&&z>=0)if(f[x][y][z]){return f[x][y][z];}
    if((x<=0)||(y<=0)||(z<=0)){return 1;}
    if((x>20)||(y>20)||(z>20)){return fun(20,20,20);}
    if((x<y)&&(y<z)){return f[x][y][z]=fun(x,y,z-1)+fun(x,y-1,z-1)-fun(x,y-1,z);}
    return f[x][y][z]=fun(x-1,y,z)+fun(x-1,y-1,z)+fun(x-1,y,z-1)-fun(x-1,y-1,z-1);
}
```

### 最优关键思路与技巧

1. **记忆化搜索**：通过存储已经计算过的结果，避免重复计算，显著提高效率。
2. **特殊情况处理**：处理输入数据中的特殊情况，如 `a, b, c` 为负数或大于20的情况。
3. **数组下标处理**：确保数组下标不越界，避免程序崩溃。

### 可拓展之处

1. **动态规划**：可以将记忆化搜索转化为动态规划，进一步优化性能。
2. **递归优化**：通过尾递归优化或迭代方法，减少递归深度，避免栈溢出。

### 推荐洛谷题目

1. **P1464 Function**：本题的原题，适合练习记忆化搜索。
2. **P1048 采药**：经典的背包问题，适合练习动态规划。
3. **P1219 八皇后**：经典的回溯问题，适合练习递归与剪枝。

### 个人心得总结

- **调试经历**：部分作者提到在处理输入数据时，忽略了负数或大于20的情况，导致程序出错。这提醒我们在编写代码时要仔细考虑所有可能的输入情况。
- **踩坑教训**：部分作者在使用记忆化搜索时，没有正确初始化数组，导致结果错误。这提醒我们在使用记忆化搜索时，要确保数组的初始状态正确。

---
处理用时：46.38秒
# 题目信息

# [USACO3.4] 美国血统 American Heritage

## 题目描述

农夫约翰非常认真地对待他的奶牛们的血统。然而他不是一个真正优秀的记帐员。他把他的奶牛 们的家谱作成二叉树，并且把二叉树以更线性的“树的中序遍历”和“树的前序遍历”的符号加以记录而 不是用图形的方法。

你的任务是在被给予奶牛家谱的“树中序遍历”和“树前序遍历”的符号后，创建奶牛家谱的“树的 后序遍历”的符号。每一头奶牛的姓名被译为一个唯一的字母。（你可能已经知道你可以在知道树的两 种遍历以后可以经常地重建这棵树。）显然，这里的树不会有多于 $26$ 个的顶点。

这是在样例输入和样例输出中的树的图形表达方式：


```plain
　　　　　　　　 C
　　　　　　   /  \
　　　　　　  /　　\
　　　　　　 B　　  G
　　　　　　/ \　　/
　　　　   A   D  H
　　　　　　  / \
　　　　　　 E   F

```

附注：

- 树的中序遍历是按照左子树，根，右子树的顺序访问节点；
- 树的前序遍历是按照根，左子树，右子树的顺序访问节点；
- 树的后序遍历是按照左子树，右子树，根的顺序访问节点。


## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 3.4


## 样例 #1

### 输入

```
ABEDFCHG
CBADEFGH 
```

### 输出

```
AEFDBHGC```

# AI分析结果

### 综合分析与结论

本题的核心是通过二叉树的前序遍历和中序遍历，推导出后序遍历。大多数题解采用了递归的思路，利用前序遍历的第一个节点作为根节点，然后在中序遍历中找到该根节点，将树分为左子树和右子树，再递归处理左右子树。最后按照后序遍历的顺序输出结果。

### 所选高星题解

#### 1. 作者：Diamiko (赞：440)  
**星级：5星**  
**关键亮点：**  
- 详细解释了递归的思路，清晰地说明了如何通过前序和中序遍历切割字符串。
- 使用了`substr`和`find`等STL函数，代码简洁且高效。
- 提供了详细的代码注释，易于理解。

**个人心得：**  
作者提到“STL的string类型自带切割方法substr，但搞不清参数就会导致WA甚至RE”，强调了正确使用STL函数的重要性。

**核心代码：**
```cpp
void work(string pre,string inor) {
    if(pre.empty())return;
    char root=pre[0];
    int k=inor.find(root);
    pre.erase(pre.begin());
    string leftpre=pre.substr(0,k);
    string rightpre=pre.substr(k);
    string leftinor=inor.substr(0,k);
    string rightinor=inor.substr(k+1);
    work(leftpre,leftinor);
    work(rightpre,rightinor);
    printf("%c",root);
}
```

#### 2. 作者：Bartholomew (赞：186)  
**星级：4星**  
**关键亮点：**  
- 使用了递归函数，通过前序和中序遍历的区间来划分左右子树。
- 代码简洁，直接通过区间索引进行递归，避免了字符串的频繁切割。

**核心代码：**
```cpp
void houxu(int x,int y,int p,int q) {
    if(x>y||p>q) return ;
    else {
        int i=b.find(a[x]);
        houxu(x+1,x+i-p,p,i-1);
        houxu(x+i-p+1,y,i+1,q);
        cout<<a[x];
    }
}
```

#### 3. 作者：jzqjzq (赞：90)  
**星级：4星**  
**关键亮点：**  
- 通过递归遍历子树，代码结构清晰。
- 使用了区间索引，避免了字符串的频繁切割，提高了效率。

**核心代码：**
```cpp
void dfs(int l1,int l2,int l3,int l4){
    if(l1>l2||l3>l4)return;
    for(int i=l1;i<=l2;i++)if(a[i]==b[l3]){
        dfs(l1,i-1,l3+1,l3+i-l1);
        dfs(i+1,l2,l3+i-l1+1,l4);
        cout<<a[i];
    }
}
```

### 最优关键思路与技巧

1. **递归分割字符串**：通过前序遍历的第一个节点确定根节点，然后在中序遍历中找到该节点，将树分为左右子树，递归处理。
2. **使用STL函数**：如`substr`和`find`，简化字符串操作，提高代码可读性和效率。
3. **区间索引**：通过维护前序和中序遍历的区间索引，避免频繁切割字符串，提升性能。

### 可拓展之处

- **类似题目**：可以通过中序和后序遍历推导前序遍历，或者通过前序和后序遍历推导中序遍历（注意唯一性问题）。
- **其他数据结构**：类似思路可以应用于其他树形结构的遍历问题，如二叉搜索树、平衡树等。

### 推荐题目

1. **P1030 求先序排列**：通过中序和后序遍历推导前序遍历。
2. **P1229 遍历问题**：通过前序和后序遍历推导中序遍历。
3. **P1305 新二叉树**：构建二叉树并进行遍历。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中遇到的RE和WA问题，强调了正确使用STL函数和边界条件的重要性。
- **顿悟感想**：通过递归分割字符串的思路，简化了问题的复杂度，使得代码更加简洁和高效。

通过这些题解，我们可以学习到如何利用递归和STL函数高效地解决二叉树遍历问题，同时也提醒我们在编写代码时要注意边界条件和函数的正确使用。

---
处理用时：36.04秒
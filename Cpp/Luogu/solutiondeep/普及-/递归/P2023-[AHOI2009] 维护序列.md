# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果

### 综合分析与结论

本题是一个经典的线段树问题，要求支持区间加法、区间乘法以及区间求和操作。题解中大部分采用了线段树的数据结构，并引入了惰性标记（lazy tag）来优化区间更新操作。难点在于如何处理乘法和加法的优先级问题，以及如何正确地下放标记。大部分题解都采用了先乘后加的策略，并通过维护两个标记（`mul` 和 `add`）来实现。

### 所选题解

#### 1. **作者：Mingoal (赞：74)**
- **星级：5星**
- **关键亮点**：代码结构清晰，注释详细，处理乘法和加法的优先级问题非常到位。通过维护`mu`（乘法标记）和`ad`（加法标记）来实现惰性更新，并且在`pushdown`函数中正确处理了标记的下放。
- **个人心得**：作者提到“乘的运算级别比加高，所以在做加法是不用管乘法，在做乘法时要管加法”，这句话很好地总结了乘法和加法的优先级问题。

**核心代码：**
```cpp
void maintain(int t,int k){//维护su,mu和ad
    tr[t<<1].su=(tr[t<<1].su*tr[t].mu+tr[t].ad*(k+1>>1))%M;
    tr[t<<1|1].su=(tr[t<<1|1].su*tr[t].mu+tr[t].ad*(k>>1))%M;
    tr[t<<1].mu=tr[t<<1].mu*tr[t].mu%M;
    tr[t<<1|1].mu=tr[t<<1|1].mu*tr[t].mu%M;
    tr[t<<1].ad=(tr[t<<1].ad*tr[t].mu+tr[t].ad)%M;
    tr[t<<1|1].ad=(tr[t<<1|1].ad*tr[t].mu+tr[t].ad)%M;
    tr[t].mu=1;tr[t].ad=0;
}
```
**实现思想**：在`maintain`函数中，首先更新子节点的`sum`值，然后更新子节点的`mul`和`add`标记，最后清空当前节点的标记。

#### 2. **作者：zjy111 (赞：35)**
- **星级：4星**
- **关键亮点**：详细解释了线段树的建树、区间修改和查询操作，特别是对`pushdown`函数的实现进行了详细说明，帮助理解惰性标记的下放过程。
- **个人心得**：作者提到“先乘后加”的顺序，并解释了为什么在乘法标记下放时需要同时更新加法标记。

**核心代码：**
```cpp
void pushdown(ll p){
    sum[p<<1]=(sum[p<<1]*mul[p]+add[p]*(rr[p<<1]-ll[p<<1]+1))%md;
    sum[p<<1|1]=(sum[p<<1|1]*mul[p]+add[p]*(rr[p<<1|1]-ll[p<<1|1]+1))%md;
    mul[p<<1]=(mul[p<<1]*mul[p])%md;
    mul[p<<1|1]=(mul[p<<1|1]*mul[p])%md;
    add[p<<1]=(add[p<<1]*mul[p]+add[p])%md;
    add[p<<1|1]=(add[p<<1|1]*mul[p]+add[p])%md;
    mul[p]=1;add[p]=0;
}
```
**实现思想**：在`pushdown`函数中，首先更新子节点的`sum`值，然后更新子节点的`mul`和`add`标记，最后清空当前节点的标记。

#### 3. **作者：GaryZhong (赞：17)**
- **星级：4星**
- **关键亮点**：使用了结构体指针来构建线段树，代码结构清晰，且对乘法和加法的处理非常到位。通过维护`mtp`（乘法标记）和`inc`（加法标记）来实现惰性更新。
- **个人心得**：作者提到“先乘后加”的顺序，并解释了为什么在乘法标记下放时需要同时更新加法标记。

**核心代码：**
```cpp
void pushdown(int rt, int l, int r){
    if (mtp[rt] == 1 && inc[rt] == 0) return;
    if (l != r)
        mtp[lson] = mtp[lson] * mtp[rt] % P,
        mtp[rson] = mtp[rson] * mtp[rt] % P,
        inc[lson] = (inc[lson] * mtp[rt] % P + inc[rt]) % P,
        inc[rson] = (inc[rson] * mtp[rt] % P + inc[rt]) % P;
    sum[rt] = (sum[rt] * mtp[rt] % P + inc[rt] * (r - l + 1) % P) % P;
    mtp[rt] = 1, inc[rt] = 0;
}
```
**实现思想**：在`pushdown`函数中，首先更新子节点的`sum`值，然后更新子节点的`mtp`和`inc`标记，最后清空当前节点的标记。

### 最优关键思路或技巧

1. **先乘后加**：在处理乘法和加法的优先级时，先处理乘法标记，再处理加法标记，这样可以避免加法标记被乘法标记影响。
2. **惰性标记**：通过维护`mul`和`add`两个标记，延迟更新操作，直到必须访问子节点时才进行更新，从而减少不必要的计算。
3. **结构体指针**：使用结构体指针来构建线段树，可以更灵活地管理节点，尤其是在需要动态分配内存时。

### 可拓展之处

1. **区间最值查询**：可以扩展线段树来支持区间最大值或最小值的查询，只需在`pushup`和`pushdown`函数中相应地更新最值。
2. **区间赋值**：可以增加一个`assign`标记，表示区间赋值的操作，类似于`mul`和`add`标记的处理方式。

### 推荐题目

1. **P3373 【模板】线段树 2**：本题的模板题，考察区间加法、乘法和求和操作。
2. **P3372 【模板】线段树 1**：考察区间加法和求和操作，适合练习线段树的基本操作。
3. **P2572 [SCOI2010] 序列操作**：考察区间赋值、翻转、求和等操作，适合进一步练习线段树的高级应用。

### 个人心得总结

- **调试经历**：在处理乘法和加法的优先级时，容易忽略加法标记需要乘以乘法标记的情况，导致结果错误。通过仔细分析`pushdown`函数的实现，可以避免这类问题。
- **顿悟感想**：线段树的惰性标记机制非常强大，能够大幅减少不必要的更新操作，理解并掌握这一机制是解决复杂区间操作问题的关键。

---
处理用时：60.22秒
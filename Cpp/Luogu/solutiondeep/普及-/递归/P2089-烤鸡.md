# 题目信息

# 烤鸡

## 题目背景

猪猪 Hanke 得到了一只鸡。


## 题目描述

猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 $10$ 种配料（芥末、孜然等），每种配料可以放 $1$ 到 $3$ 克，任意烤鸡的美味程度为所有配料质量之和。

现在， Hanke 想要知道，如果给你一个美味程度 $n$ ，请输出这 $10$ 种配料的所有搭配方案。

## 说明/提示

对于 $100\%$ 的数据，$n \leq 5000$。

## 样例 #1

### 输入

```
11```

### 输出

```
10
1 1 1 1 1 1 1 1 1 2 
1 1 1 1 1 1 1 1 2 1 
1 1 1 1 1 1 1 2 1 1 
1 1 1 1 1 1 2 1 1 1 
1 1 1 1 1 2 1 1 1 1 
1 1 1 1 2 1 1 1 1 1 
1 1 1 2 1 1 1 1 1 1 
1 1 2 1 1 1 1 1 1 1 
1 2 1 1 1 1 1 1 1 1 
2 1 1 1 1 1 1 1 1 1 ```

# AI分析结果

### 综合分析与结论

该题目要求输出10种配料的所有搭配方案，每种配料的质量范围为1到3克，且总和等于给定的美味程度n。题解主要集中在以下几种思路：

1. **暴力枚举**：通过多层循环（10层）枚举所有可能的组合，判断是否满足条件。虽然时间复杂度较高，但由于数据范围较小（n ≤ 5000），该方法在本题中可行。
2. **递归/回溯**：通过递归或回溯的方式生成所有可能的组合，并在递归过程中进行剪枝，减少不必要的计算。
3. **优化存储与输出**：部分题解通过使用字符串流、队列等数据结构来优化结果的存储与输出，避免重复计算或提高输出效率。

### 评分较高的题解

#### 1. **作者：万枪先生 (赞：866)**  
**星级：★★★★★**  
**关键亮点**：使用递归生成所有可能的组合，代码简洁且易于理解。通过剪枝优化，避免了不必要的递归调用。  
**个人心得**：作者提到“其实这和十连for没什么区别”，表明递归与多层循环在本质上是等价的，但递归代码更简洁。  
**核心代码**：
```cpp
void peiliao(int total, int a) {
    if (a == 10) {
        if (total == n) {
            for (int j = 0; j < 10; j++) m1[kind][j] = m2[j];
            kind++;
        }
    } else if (total >= n) ; // 剪枝
    else
        for (int i = 1; i <= 3; i++) {
            m2[a] = i;
            peiliao(total + i, a + 1);
        }
}
```
**实现思想**：通过递归函数`peiliao`生成所有可能的组合，并在递归过程中进行剪枝，避免无效的计算。

#### 2. **作者：氢氧化铯CsOH (赞：337)**  
**星级：★★★★☆**  
**关键亮点**：使用`char`数组和`sprintf`函数优化输出，避免了多次调用`cout`的开销。通过指针操作直接在字符串末尾追加数据，提高了输出效率。  
**核心代码**：
```cpp
void printans() {
    for (int i = 0; i < 10; i++) {
        sprintf(anscur, "%d %n", nums[i], &offset);
        anscur += offset;
    }
    sprintf(anscur, "\n%n", &offset);
    anscur += offset;
}
```
**实现思想**：通过`sprintf`函数将数据输出到字符串中，并使用指针操作直接在字符串末尾追加数据，避免了多次调用`cout`的开销。

#### 3. **作者：woshiren (赞：147)**  
**星级：★★★★☆**  
**关键亮点**：使用回溯法生成所有可能的组合，并通过剪枝优化减少了不必要的计算。代码结构清晰，易于理解。  
**核心代码**：
```cpp
void trys(int t, int m) {
    if (t > 10) {
        if (m == n) {
            ans1++;
            for (int i = 1; i <= 10; i++) ans2[ans1][i] = a[i];
        }
        return;
    }
    for (int i = 1; i <= 3; i++) {
        if (m + i > n) break; // 剪枝
        a[t] = i;
        trys(t + 1, m + i);
        a[t] = 0; // 回溯
    }
}
```
**实现思想**：通过回溯法生成所有可能的组合，并在回溯过程中进行剪枝，避免无效的计算。

### 最优关键思路与技巧

1. **递归与回溯**：递归和回溯是解决组合问题的常用方法，代码简洁且易于理解。通过剪枝优化，可以显著减少不必要的计算。
2. **优化输出**：使用字符串流或`char`数组优化输出，避免多次调用`cout`，提高输出效率。
3. **剪枝**：在递归或回溯过程中，通过提前判断是否满足条件，避免无效的计算，提高算法效率。

### 可拓展之处

1. **组合问题的通用解法**：该题的解法可以推广到其他组合问题，如生成所有可能的排列、子集等。
2. **优化存储与输出**：在处理大规模数据时，优化存储与输出是提高算法效率的关键，可以使用更高效的数据结构或算法。

### 推荐题目

1. **P1706 全排列问题**：生成所有可能的排列，考察递归与回溯的应用。
2. **P1036 选数**：从给定的数中选出若干个数，使其和为指定的值，考察组合问题的解法。
3. **P1219 八皇后**：经典的回溯问题，考察如何在棋盘上放置皇后而不互相攻击。

### 个人心得总结

- **递归与循环的等价性**：递归与多层循环在本质上是等价的，但递归代码更简洁，易于理解和维护。
- **剪枝的重要性**：在递归或回溯过程中，剪枝是优化算法效率的关键，可以显著减少不必要的计算。
- **优化输出**：在处理大规模数据时，优化输出是提高算法效率的重要环节，可以使用字符串流或`char`数组来减少输出开销。

---
处理用时：42.74秒
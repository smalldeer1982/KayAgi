# 题目信息

# [AHOI2002] Kitty猫基因编码

## 题目描述

小可可选修了基础生物基因学。教授告诉大家 Super Samuel 星球上 Kitty猫的基因的长度都是 2 的正整数次幂 )， 全是由两种不同的基因单元组成的。 这两种不同的基因单元分别记成 0 和 1，于是 Kitty 猫基因可以写成一个 01 串表达式 。

为了便于分析和降低数据存储量，教授发明了 ABC 编码规则。该编码规则是不断地按照

 ![](https://cdn.luogu.com.cn/upload/pic/1679.png) 

对 Kitty 猫基因 01 串表达式 进行改写， 直至最终被改写成只含有字符 “ A”、“ B”、“ C”的符号串。

 ![](https://cdn.luogu.com.cn/upload/pic/1680.png) 

请你编写程序帮助小可可求出 Kitty 猫基因的 ABC 编码以协助教授开展科研工作。


## 说明/提示

给出的01字符串长度$Len\leq 256$

## 样例 #1

### 输入

```
00```

### 输出

```
A```

## 样例 #2

### 输入

```
01001011```

### 输出

```
CCCABACCBAB```

# AI分析结果

### 综合分析与结论

这些题解大多采用了递归的思路，核心思想是根据字符串是否全为0、全为1或混合情况，分别输出A、B或C，并递归处理子串。部分题解使用了前缀和、线段树等优化手段，但考虑到题目数据规模较小（长度≤256），简单的递归实现已经足够高效。

#### 关键思路与技巧：
1. **递归分治**：将字符串不断二分，直到子串全为0或全为1，递归处理子串并拼接结果。
2. **字符串处理**：利用`string`类的`find`、`substr`等函数简化代码，避免手动分割字符串。
3. **前缀和优化**：通过前缀和快速判断子串是否全为0或全为1，减少重复计算。
4. **线段树**：部分题解使用线段树维护区间信息，虽然在该题中略显复杂，但展示了数据结构在类似问题中的应用。

#### 通用建议与扩展思路：
- **递归与分治**：掌握递归分治的思想，适用于类似FBI树、归并排序等问题。
- **字符串处理技巧**：熟练使用`string`类的函数，提高代码简洁性和可读性。
- **数据结构优化**：在数据规模较大时，考虑使用前缀和、线段树等数据结构优化性能。

### 评分较高的题解

#### 1. **作者：狸狸养的敏敏 (★★★★★)**
- **关键亮点**：代码简洁明了，直接按照题意模拟递归，利用`string`类的特性简化实现。
- **核心代码**：
  ```cpp
  string T(string str) {
      int sum = 0;
      for (int i = 0; i < str.length(); i++)
          sum += str[i] - '0';
      if (!sum) return "A";
      if (sum == str.length()) return "B";
      int mid = (str.length() + 1) >> 1;
      string str1, str2;
      for (int i = 0; i < mid; i++) str1 += str[i];
      for (int i = mid; i < str.length(); i++) str2 += str[i];
      return "C" + T(str1) + T(str2);
  }
  ```

#### 2. **作者：Saliеri (★★★★☆)**
- **关键亮点**：利用`find`函数判断字符串是否全为0或全为1，代码简洁且高效。
- **核心代码**：
  ```cpp
  void dg(string s) {
      if (s.find('1') == -1) { printf("A"); return; }
      if (s.find('0') == -1) { printf("B"); return; }
      int t = s.size();
      printf("C");
      dg(s.substr(0, t / 2));
      dg(&s[t / 2]);
  }
  ```

#### 3. **作者：dream_maker (★★★★☆)**
- **关键亮点**：使用前缀和优化判断，减少重复计算，代码清晰且高效。
- **核心代码**：
  ```cpp
  void Find(int l, int r) {
      if (s[r] - s[l - 1] == 0) { putchar('A'); return; }
      if (s[r] - s[l - 1] == r - l + 1) { putchar('B'); return; }
      putchar('C');
      int mid = (l + r) >> 1;
      Find(l, mid);
      Find(mid + 1, r);
  }
  ```

### 推荐相似题目
1. **P1087 FBI树**：考察递归分治思想，与本题类似。
2. **P1048 加分二叉树**：涉及二叉树与递归分治。
3. **P1226 快速幂**：虽然不直接相关，但涉及分治思想的应用。

### 个人心得摘录
- **狸狸养的敏敏**：提到“直接按照题意模拟就好了”，强调了理解题意的重要性。
- **Saliеri**：提到“s.find大法好啊”，展示了字符串处理函数的便捷性。
- **dream_maker**：提到“前缀和优化”，展示了数据结构在算法优化中的作用。

---
处理用时：34.81秒
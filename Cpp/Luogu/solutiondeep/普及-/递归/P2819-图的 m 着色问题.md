# 题目信息

# 图的 m 着色问题

## 题目背景

给定无向连通图 $G$ 和 $m$ 种不同的颜色。用这些颜色为图 $G$ 的各顶点着色，每个顶点着一种颜色。如果有一种着色法使 $G$ 中每条边的 $2$ 个顶点着不同颜色，则称这个图是 $m$ 可着色的。图的 $m$ 着色问题是对于给定图 $G$ 和 $m$ 种颜色，找出所有不同的着色法。


## 题目描述

对于给定的无向连通图 $G$ 和 $m$ 种不同的颜色，编程计算图的所有不同的着色法。


## 说明/提示

数据保证，$1\leq n\leq 100$，$1 \leq k\leq 2500$。

在 $n$ 很大时保证 $k$ 足够大。

保证答案不超过 $20000$。

数据为在满足上述条件的合法数据中随机采样得到。

## 样例 #1

### 输入

```
5 8 4
1 2
1 3
1 4
2 3
2 4
2 5
3 4
4 5```

### 输出

```
48```

# AI分析结果

### 综合分析与结论

本题解的思路主要集中在深度优先搜索（DFS）的应用上，通过回溯法枚举所有可能的着色方案，并检查相邻节点颜色是否冲突。大部分题解采用了邻接矩阵或邻接表来存储图结构，并通过DFS遍历每个节点，尝试为其着色。部分题解还引入了优化策略，如剪枝、颜色等价性判断等，以提高搜索效率。

### 所选高星题解

#### 1. 作者：Creeper_LKF (赞：20)  
**星级：4.5**  
**关键亮点：**  
- 引入了颜色等价性优化，减少重复搜索。  
- 通过记录颜色出现次数，判断是否可以使用未使用过的颜色，从而减少搜索空间。  
- 代码结构清晰，优化思路明确。  

**核心代码：**
```cpp
int dfs(int pt){
    if(pt == 0) return 1;
    else {
        int ret = 0, tmp = 0;
        for(int i = 1; i <= k; i++){
            if(tim[i] == 0){ // 第一次出现
                if(tmp) continue;
                col[pt] = i, tim[i] ++, tmp = ali, ali --;
                ret += dfs(pt - 1) * tmp;
                tim[i] --, ali ++;
            } else { // 非第一次出现
                if(tim[i] == 0) continue;
                bool flg = true;
                for(int j = siz[pt]; flg && j; j--){
                    if(i == col[tabl[pt][j]])
                        flg = false;
                }
                if(flg) col[pt] = i, tim[i] ++, ret += dfs(pt - 1), tim[i] --;
            }
        }
        col[pt] = 0;
        return ret;
    }
}
```
**个人心得：**  
作者提到初次写代码时发现第一个点可以直接乘以颜色数，推广到所有点后，优化效果显著。这种优化思路值得借鉴。

#### 2. 作者：zzlh (赞：46)  
**星级：4.0**  
**关键亮点：**  
- 代码简洁，逻辑清晰，适合初学者理解。  
- 通过`check`函数判断颜色冲突，实现简单直观。  

**核心代码：**
```cpp
void dfs(int s){
    if(s>n){
        num++;//搜到n+1个点，也就是走完了
        return;
    }
    for(int i=1;i<=m;i++){
        color[s]=i;//把颜色存下来
        if(check(s)==true){
            dfs(s+1);
        }else{
            color[s]=0;//如果冲突则重新打回0
        }
    }
}
```
**个人心得：**  
作者提到“一题挺水的搜索题”，表明该题解适合快速理解和实现，适合初学者。

#### 3. 作者：__nullptr__attr (赞：1)  
**星级：4.0**  
**关键亮点：**  
- 使用链式前向星存储图结构，减少枚举次数。  
- 代码结构清晰，优化思路明确。  

**核心代码：**
```cpp
inline bool valid(int c,int p){
    for(int i=head[p];i;i=nxt[i]){
        int y=ver[i];
        if(color[y]==c) return 0;
    }
    return 1;
}
```
**个人心得：**  
作者提到“用链式前向星有什么好处”，强调了数据结构选择对算法效率的影响。

### 最优关键思路与技巧

1. **颜色等价性优化**：通过记录颜色出现次数，判断是否可以使用未使用过的颜色，减少搜索空间。
2. **链式前向星存储图**：减少枚举次数，提高搜索效率。
3. **剪枝策略**：在DFS过程中，通过提前判断颜色冲突，减少不必要的搜索。

### 可拓展之处

- **类似算法套路**：该题的DFS回溯法可以推广到其他组合优化问题，如数独、八皇后等。
- **数据结构选择**：链式前向星、邻接矩阵等图存储结构的选择对算法效率有显著影响，值得深入理解。

### 推荐题目

1. **P1219 八皇后**（考察DFS回溯）
2. **P1074 靶形数独**（考察DFS剪枝）
3. **P1092 虫食算**（考察DFS与剪枝）

### 个人心得总结

- **调试经历**：部分作者提到初次写代码时发现优化点，如颜色等价性判断，这种调试过程中的顿悟值得借鉴。
- **踩坑教训**：邻接矩阵与链式前向星的选择对算法效率有显著影响，选择合适的存储结构是优化的关键。

---
处理用时：34.29秒
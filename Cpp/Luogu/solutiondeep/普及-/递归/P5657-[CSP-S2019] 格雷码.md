# 题目信息

# [CSP-S2019] 格雷码

## 题目描述

通常，人们习惯将所有 $n$ 位二进制串按照字典序排列，例如所有 2 位二进制串按字典序从小到大排列为：00，01，10，11。

格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间**恰好**有一位**不同**，特别地，第一个串与最后一个串也算作相邻。

所有 2 位二进制串按格雷码排列的一个例子为：00，01，11，10。

$n$ 位格雷码不止一种，下面给出其中一种格雷码的生成算法：
1. 1 位格雷码由两个 1 位二进制串组成，顺序为：0，1。
2. $n + 1$ 位格雷码的前 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**顺序**排列，再在每个串前加一个前缀 0 构成。
3. $n + 1$ 位格雷码的后 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**逆序**排列，再在每个串前加一个前缀 1 构成。

综上，$n + 1$ 位格雷码，由 $n$ 位格雷码的 $2^n$ 个二进制串按顺序排列再加前缀 0，和按逆序排列再加前缀 1 构成，共 $2^{n+1}$ 个二进制串。另外，对于 $n$ 位格雷码中的 $2^n$ 个 二进制串，我们按上述算法得到的排列顺序将它们从 $0 \sim 2^n - 1$ 编号。

按该算法，2 位格雷码可以这样推出：

1. 已知 1 位格雷码为 0，1。
2. 前两个格雷码为 00，01。后两个格雷码为 11，10。合并得到 00，01，11，10，编号依次为 0 ~ 3。

同理，3 位格雷码可以这样推出：

1. 已知 2 位格雷码为：00，01，11，10。
2. 前四个格雷码为：000，001，011，010。后四个格雷码为：110，111，101，100。合并得到：000，001，011，010，110，111，101，100，编号依次为 0 ~ 7。

现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的 $k$ 号二进制串。


## 说明/提示

【样例 1 解释】

2 位格雷码为：00，01，11，10，编号从 0∼3，因此 3 号串是 10。

【样例 2 解释】

3 位格雷码为：000，001，011，010，110，111，101，100，编号从 0∼7，因此 5 号串是 111。

【数据范围】

对于 $50\%$ 的数据：$n \leq 10$

对于 $80\%$ 的数据：$k \leq 5 \times 10^6$

对于 $95\%$ 的数据：$k \leq 2^{63} - 1$

对于 $100\%$ 的数据：$1 \leq n \leq 64$, $0 \leq k \lt 2^n$

## 样例 #1

### 输入

```
2 3```

### 输出

```
10```

## 样例 #2

### 输入

```
3 5```

### 输出

```
111```

## 样例 #3

### 输入

```
44 1145141919810```

### 输出

```
00011000111111010000001001001000000001100011```

# AI分析结果

### 综合分析与结论

本题的核心在于生成格雷码，尤其是如何高效地生成第k个格雷码。格雷码的生成规则是相邻两个码只有一位不同，且首尾也满足这一条件。通过观察格雷码的生成规律，可以发现格雷码与二进制码之间存在一定的转换关系，尤其是通过异或运算可以快速生成格雷码。

大部分题解都基于以下两种思路：
1. **递归分治法**：通过递归将问题分解为更小的子问题，逐步构建格雷码。
2. **位运算优化**：利用异或运算直接生成格雷码，避免了复杂的递归或循环。

其中，位运算优化的方法更为简洁高效，且代码实现简单，适合在竞赛中使用。递归分治法虽然直观，但在处理大规模数据时可能会因为递归深度过大而影响性能。

### 所选高星题解

#### 1. 题解作者：「已注销」 (赞：900)  
**星级：★★★★★**  
**关键亮点**：  
- 使用位运算直接生成格雷码，代码简洁高效。
- 通过 `k ^ (k >> 1)` 快速得到格雷码，避免了复杂的递归或循环。
- 代码可读性强，适合竞赛中的快速实现。

**核心代码**：
```cpp
#include<iostream>
int n;
unsigned long long k;
int main(){
    std::cin>>n>>k;
    k^=k>>1;
    while(~--n)std::cout<<(k>>n&1);
}
```
**实现思想**：通过 `k ^ (k >> 1)` 直接生成格雷码，然后逐位输出。

#### 2. 题解作者：ikunTLE (赞：9)  
**星级：★★★★☆**  
**关键亮点**：  
- 同样使用位运算生成格雷码，代码简洁。
- 通过 `k ^ (k >> 1)` 得到格雷码，并逐位输出。
- 代码结构清晰，适合竞赛中的快速实现。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
    int n;
    scanf("%d",&n);
    unsigned long long k;
    scanf("%llu",&k);
    k^=k>>1;
    while(n){
        printf("%llu",(k>>(n-1))&1);
        --n;
    }
    printf("\n");
    return 0;
}
```
**实现思想**：通过 `k ^ (k >> 1)` 生成格雷码，然后逐位输出。

#### 3. 题解作者：sjh0626 (赞：2)  
**星级：★★★★☆**  
**关键亮点**：  
- 使用位运算生成格雷码，代码简洁。
- 通过 `k ^ (k >> 1)` 得到格雷码，并逐位输出。
- 代码结构清晰，适合竞赛中的快速实现。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
unsigned long long k; 
int main(){
    cin>>n>>k;
    k^=k>>1;
    while(n){cout<<((k>>(n-1))&1);--n;}
    return 0;
}
```
**实现思想**：通过 `k ^ (k >> 1)` 生成格雷码，然后逐位输出。

### 最优关键思路或技巧

**位运算优化**：通过 `k ^ (k >> 1)` 直接生成格雷码，避免了复杂的递归或循环，代码简洁高效，适合在竞赛中使用。这种方法的核心在于利用了格雷码与二进制码之间的转换关系，通过异或运算快速得到结果。

### 可拓展之处

1. **格雷码的应用**：格雷码在数字电路、编码器、通信等领域有广泛应用，理解其生成规则有助于解决相关问题。
2. **位运算的优化**：位运算在竞赛中常用于优化时间复杂度，掌握常见的位运算技巧（如异或、位移等）可以提升解题效率。

### 推荐相似题目

1. **P1008 三连击**：考察位运算和数字排列的组合问题。
2. **P1010 幂次方**：考察位运算和递归的结合使用。
3. **P1012 拼数**：考察数字排列和位运算的应用。

### 个人心得摘录

- **调试经历**：多位作者提到在处理 `2^64` 时会溢出，需要使用 `unsigned long long` 或 `__int128` 来避免问题。
- **踩坑教训**：部分作者在实现递归分治法时，忽略了递归深度过大的问题，导致性能下降。
- **顿悟感想**：通过观察格雷码的生成规律，发现可以通过位运算直接生成格雷码，避免了复杂的递归或循环，大大简化了代码实现。

---
处理用时：37.18秒
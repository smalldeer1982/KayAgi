# 题目信息

# 「JYLOI Round 1」箭头调度

## 题目描述

moyu_028 给了你一个有 $n$ 个点 $m$ 条边的无向图，现在要给每条边赋一个方向，现在请你求出一个赋方向的方案，使得按照这个方案能够生成一个拓扑序，且使得这个拓扑序是在所有可能的拓扑序中字典序第 $k$ 小的。


## 说明/提示

## 提示

拓扑序：在一个 DAG（有向无环图）中，我们将图中的顶点以线性方式进行排序，使得对于任何的顶点 $u$ 到 $v$ 的有向边 $(u,v)$，都可以有 $u$ 在 $v$ 的前面，则这样的序列称为拓扑序。

----------

## 样例解释

### 样例 1 解释

答案的图如下，根据图可得出答案。

![](https://i.loli.net/2020/05/23/3FK2n78JAYLrGMD.png)

-----------------

## 数据范围

对于 $100\%$ 的数据，$1 \leq n \leq 11, 1 \leq m \leq 2 \times 10^3, 1 \leq k \leq 10^8，1 \leq x_i, y_i \leq n, x_i \not= y_i$。

对于测试点 1（10 分）：$n = 1$。

对于测试点 2（30 分）：$n \leq 11, m \leq 20$。

对于测试点 3（30 分）：$n \leq 11, k = 1$。

对于测试点 4（30 分）：无特殊限制。

本题共 4 个测试点，总分为 100 分，单个测试点的时间限制为 5 秒。

## 题目来源

「JYLOI Round 1」 A

Idea：moyu_028 & abcdeffa

Solution：LiuXiangle

Data：abcdeffa

## 样例 #1

### 输入

```
6 7 5
1 3
2 1
4 2
4 3
4 5
3 6
5 6```

### 输出

```
0111001```

## 样例 #2

### 输入

```
11 20 20091210
2 3
3 1
2 5
4 6
7 9
8 10
8 1
7 2
2 3
3 2
4 5
5 7
7 6
7 8
9 7
9 8
10 2
2 3
1 3
1 7```

### 输出

```
10110000100110110111```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何在无向图中为每条边赋方向，使得生成的拓扑序是字典序第 $k$ 小的。大多数题解都基于以下关键思路：

1. **全排列与拓扑序的关系**：任意一个 $1$ 到 $n$ 的全排列都可以通过特定的边方向赋值生成一个拓扑序。因此，问题转化为找到第 $k$ 小的全排列，并根据该排列确定边的方向。

2. **康托展开与排列生成**：部分题解使用康托展开来快速生成第 $k$ 小的排列，避免了暴力枚举的高时间复杂度。

3. **边方向的确定**：根据生成的排列，确定每条边的方向。具体来说，如果排列中 $u$ 在 $v$ 前面，则边方向为 $u \to v$，否则为 $v \to u$。

4. **优化与剪枝**：部分题解通过优化排列生成过程或使用更高效的数据结构来降低时间复杂度。

### 所选高星题解

#### 1. 作者：wzkdh (赞：7)  
**星级：4.5**  
**关键亮点**：  
- 使用康托展开快速生成第 $k$ 小的排列，避免了暴力枚举的高时间复杂度。  
- 代码简洁，逻辑清晰，易于理解。  
- 通过倒序处理排列，巧妙地将排列映射到边的方向。

**核心代码**：
```cpp
void cantor(int x) {
    x %= c[n];
    for (int i = n - 1; i >= 0; i--) {
        int idx = x / c[i];
        int tot = 0;
        for (int j = 1; j <= 11; j++) {
            if (v[j]) continue;
            if (tot == idx) {
                v[j] = 1;
                ans[i] = j;
            }
            tot++;
        }
        x %= c[i];
    }
}
```
**核心思想**：通过康托展开生成第 $k$ 小的排列，并根据排列确定边的方向。

#### 2. 作者：MoonCake2011 (赞：3)  
**星级：4**  
**关键亮点**：  
- 使用 `next_permutation` 生成第 $k$ 小的排列，虽然时间复杂度较高，但代码简洁易懂。  
- 通过排列直接确定边的方向，逻辑清晰。

**核心代码**：
```cpp
while(--k) next_permutation(a+1,a+n+1);
for(int i=1;i<=n;i++) p[a[i]]=i;
for(int i=1;i<=m;i++){
    int u,v;
    cin>>u>>v;
    cout<<(p[u]>p[v]);
}
```
**核心思想**：通过 `next_permutation` 生成第 $k$ 小的排列，并根据排列确定边的方向。

#### 3. 作者：HNOIRPplusplus (赞：0)  
**星级：4**  
**关键亮点**：  
- 提出了一种基于排列生成的高效方法，避免了 `next_permutation` 的高时间复杂度。  
- 通过递归和剪枝优化排列生成过程，适合大规模数据。

**核心思想**：通过递归和剪枝快速生成第 $k$ 小的排列，并根据排列确定边的方向。

### 最优关键思路与技巧

1. **康托展开**：快速生成第 $k$ 小的排列，避免暴力枚举的高时间复杂度。
2. **排列映射**：通过排列直接确定边的方向，逻辑清晰且易于实现。
3. **优化与剪枝**：在排列生成过程中使用递归和剪枝，降低时间复杂度。

### 可拓展之处

- **全排列生成**：可以进一步优化排列生成算法，如使用阶乘数系统或递归剪枝。
- **拓扑序生成**：可以研究如何在生成拓扑序的同时优化边的方向赋值，减少计算量。

### 推荐题目

1. **P1706 全排列问题**：考察全排列生成的基本方法。
2. **P1037 产生数**：考察排列与图的关系。
3. **P1137 旅行计划**：考察拓扑排序与路径规划。

### 个人心得摘录

- **wzkdh**：通过康托展开快速生成排列，避免了暴力枚举的高时间复杂度，代码简洁易懂。
- **MoonCake2011**：使用 `next_permutation` 生成排列，虽然时间复杂度较高，但代码简洁，适合小规模数据。
- **HNOIRPplusplus**：通过递归和剪枝优化排列生成过程，适合大规模数据，思路清晰且高效。

---
处理用时：33.26秒
# 题目信息

# [NOIP 2001 普及组] 数的计算

## 题目描述

给出正整数 $n$，要求按如下方式构造数列：

1. 只有一个数 $n$ 的数列是一个合法的数列。
2. 在一个合法的数列的末尾加入一个正整数，但是这个正整数不能超过该数列最后一项的一半，可以得到一个新的合法数列。

请你求出，一共有多少个合法的数列。两个合法数列 $a, b$ 不同当且仅当两数列长度不同或存在一个正整数 $i \leq |a|$，使得 $a_i \neq b_i$。

## 说明/提示

### 样例 1 解释

满足条件的数列为：
- $6$
- $6, 1$
- $6, 2$
- $6, 3$
- $6, 2, 1$
- $6, 3, 1$

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^3$。

### 说明

本题数据来源是 NOIP 2001 普及组第一题，但是原题的题面描述和数据不符，故对题面进行了修改，使之符合数据。原题面如下，谨供参考：

> 我们要求找出具有下列性质数的个数（包含输入的正整数 $n$）。
>
> 先输入一个正整数 $n$（$n \le 1000$），然后对此正整数按照如下方法进行处理：
>
> 1. 不作任何处理；
> 2. 在它的左边拼接一个正整数，但该正整数不能超过原数，或者是上一个被拼接的数的一半；
> 3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。

感谢 @[dbxxx](/user/120868) 对本题情况的反馈，原题面的问题见[本贴](https://www.luogu.com.cn/discuss/526184)。

## 样例 #1

### 输入

```
6
```

### 输出

```
6
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过递推的方式计算合法数列的数量。题解中主要采用了动态规划的思路，通过定义状态转移方程来求解问题。优化后的算法将时间复杂度从 $O(n^2)$ 降低到 $O(n)$，显著提升了效率。

### 所选题解

#### 题解作者：shinzanmono
- **星级：4星**
- **关键亮点：**
  - 使用了动态规划的思路，定义了 $f_i$ 和 $g_i$ 两个数组，分别表示当 $n=i$ 时的合法数列数量和前缀和。
  - 通过优化状态转移方程，将时间复杂度从 $O(n^2)$ 降低到 $O(n)$。
  - 代码简洁且高效，易于理解。

```cpp
#include<iostream>
#include<algorithm>
const int sz=1010;
int f[sz],g[sz];
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int n;
    std::cin>>n;
    f[1]=g[1]=1;
    for(int i=2;i<=n;i++)f[i]=g[i/2]+1,g[i]=g[i-1]+f[i];
    std::cout<<f[n]<<"\n";
    return 0;
}
```

### 最优关键思路或技巧

1. **动态规划**：通过定义状态 $f_i$ 表示当 $n=i$ 时的合法数列数量，利用递推关系 $f_i = g_{\left\lceil n/2 \right\rceil} + 1$ 进行计算。
2. **前缀和优化**：引入 $g_i$ 数组来存储 $f_1$ 到 $f_i$ 的和，从而将每次计算 $f_i$ 的时间复杂度从 $O(n)$ 降低到 $O(1)$。

### 可拓展之处

- **类似问题**：可以拓展到其他需要计算组合或排列数量的问题，如“爬楼梯”问题、“硬币找零”问题等。
- **优化技巧**：前缀和优化在动态规划中非常常见，可以应用于其他需要频繁计算区间和的问题。

### 推荐题目

1. **P1048 采药**：动态规划的经典问题，考察如何选择物品以最大化价值。
2. **P1060 开心的金明**：类似于背包问题，考察如何在有限预算内选择物品。
3. **P1091 合唱队形**：动态规划与序列处理结合的问题，考察如何通过调整序列来满足特定条件。

### 个人心得摘录

- **调试经历**：在优化过程中，发现直接使用 $O(n^2)$ 的算法会导致超时，通过引入前缀和数组 $g_i$ 成功优化了时间复杂度。
- **顿悟感想**：动态规划的核心在于状态的定义和转移方程的建立，合理的前缀和优化可以显著提升算法效率。

---
处理用时：20.08秒
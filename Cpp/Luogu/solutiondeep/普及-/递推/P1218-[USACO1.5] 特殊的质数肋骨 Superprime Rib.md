# 题目信息

# [USACO1.5] 特殊的质数肋骨 Superprime Rib

## 题目描述

农民约翰的母牛总是产生最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。 

农民约翰确定他卖给买方的是真正的质数肋骨，是因为从右边开始切下肋骨，每次还剩下的肋骨上的数字都组成一个质数。  

举例来说：$7\ 3\ 3\ 1$ 全部肋骨上的数字 $7331$ 是质数；三根肋骨 $733$ 是质数；二根肋骨 $73$ 是质数；当然,最后一根肋骨 $7$ 也是质数。$7331$ 被叫做长度 $4$ 的特殊质数。  

写一个程序对给定的肋骨的数目 $n$，求出所有的特殊质数。$1$ 不是质数。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 8$。

题目翻译来自NOCOW。

USACO Training Section 1.5


## 样例 #1

### 输入

```
4
```

### 输出

```
2333
2339
2393
2399
2939
3119
3137
3733
3739
3793
3797
5939
7193
7331
7333
7393
```

# AI分析结果

### 综合分析与结论

本题的核心是生成所有长度为 `n` 的特殊质数，即从右向左截取任意长度的子串都是质数。题解中主要采用了以下几种思路：

1. **暴力枚举**：通过多重循环枚举所有可能的数字组合，并逐个判断是否为特殊质数。虽然思路简单，但效率较低，尤其是当 `n` 较大时。
2. **DFS/BFS搜索**：利用深度优先搜索（DFS）或广度优先搜索（BFS）逐位生成数字，并在生成过程中剪枝，避免不必要的计算。这种方法效率较高，且代码简洁。
3. **动态规划/递推**：通过递推的方式，从1位数开始逐步生成多位数，确保每一步生成的数字都是质数。这种方法适合处理较大的 `n`。
4. **打表法**：由于 `n` 最大为8，且特殊质数数量有限，部分题解直接打表输出结果。这种方法虽然高效，但缺乏通用性。

综合来看，**DFS/BFS搜索**是最为推荐的解法，既保证了效率，又具有较好的通用性。动态规划/递推法也值得学习，尤其适合处理更大的 `n`。

### 精选题解

#### 1. **作者：HeZhenting (赞：89)**
- **星级**：★★★★★
- **关键亮点**：使用队列（BFS）逐位生成数字，确保每一步生成的数字都是质数。代码简洁易懂，且效率较高。
- **核心代码**：
  ```cpp
  void dfs(int k, int sum) {
      if (k == n) {
          cout << sum << endl;
          return;
      }
      for (int i = 1; i <= 9; i++) {
          int tmp = sum * 10 + i;
          if (isprime(tmp)) dfs(k + 1, tmp);
      }
  }
  ```
- **个人心得**：作者提到“保证每次放入队列里的都是质数”，这种剪枝策略大大减少了不必要的计算。

#### 2. **作者：安笙凉城 (赞：49)**
- **星级**：★★★★☆
- **关键亮点**：使用DFS逐位生成数字，并在生成过程中判断是否为质数，剪枝效果显著。代码简洁，适合初学者理解。
- **核心代码**：
  ```cpp
  void DFS(int k, int sum) {
      if (sum == n) {
          cout << k << endl;
          return;
      }
      for (int i = 0; i < 5; i++) {
          int p = k * 10 + a[i];
          if (prime(p)) DFS(p, sum + 1);
      }
  }
  ```
- **个人心得**：作者提到“边加数字边判断，位数凑够了输出”，这种思路清晰且易于实现。

#### 3. **作者：hensier (赞：18)**
- **星级**：★★★★☆
- **关键亮点**：使用BFS和DFS两种方法，分别从不同的角度解决问题，展示了算法的多样性。代码结构清晰，适合进阶学习。
- **核心代码**：
  ```cpp
  void dfs(int x) {
      if (x > r || !check(x)) return;
      if (x > l) ans[++cnt] = x;
      for (int i = 0; i < 4; i++) dfs(x * 10 + m[i]);
  }
  ```
- **个人心得**：作者提到“特殊质数的第一位必定是2,3,5,7”，这种观察帮助减少了搜索空间。

### 最优关键思路与技巧

1. **逐位生成与剪枝**：通过逐位生成数字，并在每一步判断是否为质数，避免生成无效数字，显著提高效率。
2. **BFS/DFS的选择**：BFS适合需要按层遍历的场景，而DFS适合深度优先的搜索。根据问题特点选择合适的搜索策略。
3. **动态规划/递推**：通过递推的方式，从1位数开始逐步生成多位数，确保每一步生成的数字都是质数，适合处理较大的 `n`。

### 拓展思路与类似题目

1. **类似题目**：
   - **P1218 [USACO1.5] 特殊的质数肋骨**：本题的变种，要求生成的特殊质数肋骨。
   - **P1219 [USACO1.5] 八皇后**：同样是搜索类题目，适合练习DFS/BFS。
   - **P1211 [USACO1.5] 牛的旅行**：涉及图的遍历，适合练习BFS。

2. **拓展思路**：
   - **更大范围的质数生成**：可以尝试将算法扩展到更大的 `n`，或者生成其他类型的特殊质数。
   - **并行化处理**：对于较大的 `n`，可以考虑将搜索任务并行化，进一步提升效率。

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中发现某些优化点，如剪枝策略的引入，显著提升了代码效率。
- **踩坑教训**：一些作者在最初尝试暴力枚举时遇到了超时问题，最终通过搜索算法解决了问题。
- **顿悟感想**：通过逐位生成数字并结合质数判断，能够有效减少计算量，这种思路在类似问题中具有通用性。

---
处理用时：46.46秒
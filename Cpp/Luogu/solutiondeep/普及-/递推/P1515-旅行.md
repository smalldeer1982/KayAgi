# 题目信息

# 旅行

## 题目描述

你要进行一个行程为 $7000$ 千米的旅行，现在沿途有些汽车旅馆，为了安全起见，每天晚上都不开车，住在汽车旅馆，你手里现在已经有一个旅馆列表，用离起点的距离来标识，如下：

- $[0,990,1010,1970,2030,2940,3060,3930,4060,4970,5030,5990,6010,7000]$。

但在出发之前可能还要增加一些旅馆。

现在旅行社为了节约成本，要求每天至少行驶 $A$ 公里，国家旅行社为了安全起见，要求每天最多只能行驶 $B$ 公里。

你想知道一共有多少种旅行方案。

## 样例 #1

### 输入

```
500
1500
0
```

### 输出

```
64
```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何计算在给定约束条件下（每天行驶距离在[A, B]之间）从起点到终点的旅行方案数。题解中主要采用了两种思路：**深度优先搜索（DFS）**和**动态规划（DP）**。DFS的思路是通过递归遍历所有可能的路径，而DP的思路是通过递推计算每个旅馆的方案数，最终得到终点的方案数。

#### 关键思路与技巧：
1. **DFS**：通过递归遍历所有可能的路径，利用回溯法避免重复计算。难点在于如何剪枝和优化，避免超时。
2. **DP**：通过递推公式计算每个旅馆的方案数，最终得到终点的方案数。难点在于如何定义状态转移方程，并确保递推的正确性。
3. **排序**：在DP和DFS中，旅馆的位置排序是关键，确保遍历的顺序正确。
4. **剪枝**：在DFS中，通过判断当前路径是否符合条件进行剪枝，避免无效的递归调用。

#### 通用建议与扩展思路：
- **DFS**适合小规模数据，但容易超时，建议在数据规模较小时使用。
- **DP**适合大规模数据，时间复杂度较低，建议在数据规模较大时使用。
- **排序**是解决此类问题的常见技巧，确保遍历的顺序正确。
- **剪枝**是优化DFS的重要手段，可以有效减少递归调用次数。

### 所选高星题解

#### 题解1：作者：翼德天尊 (赞：69)  
**星级：4.5星**  
**关键亮点**：  
- 使用了动态规划（DP）的思路，通过递推公式计算每个旅馆的方案数，最终得到终点的方案数。
- 代码简洁明了，注释详细，易于理解。
- 通过排序确保遍历的顺序正确，避免了复杂的边界处理。

**核心代码**：
```cpp
int main(){
    scanf("%d %d %d",&a,&b,&n);
    for (int i=14;i<14+n;i++) cin>>r[i];//输入 
    sort(r,r+14+n);//排序 
    ans[0]=1; //起始点默认一套方案 
    for (int i=1;i<14+n;i++){//枚举所有点 
        for (int j=0;j<i;j++){//枚举这个点之前的点 
            if (r[i]-r[j]>=a&&r[i]-r[j]<=b){//如果这两个点之间的距离符合要求 
                ans[i]+=ans[j];//这个点可以获得前面那个点的所有可能 
            }
        }
    }
    cout<<ans[13+n]<<endl;//输出到终点时的所有可能 
    return 0;
}
```

#### 题解2：作者：Rika (赞：8)  
**星级：4星**  
**关键亮点**：  
- 使用了动态规划（DP）的思路，通过递推公式计算每个旅馆的方案数，最终得到终点的方案数。
- 代码简洁，注释清晰，易于理解。
- 通过排序确保遍历的顺序正确，避免了复杂的边界处理。

**核心代码**：
```cpp
int main()
{
    cin >>A>>B>> n;
    n += 14;                                        //加上初始的旅馆数目
    int a[34] = { 0,990,1010,1970, 2030, 2940,        //录入初始旅馆数目
    3060 ,3930, 4060, 4970, 5030,
    5990, 6010, 7000 };
    int rs[34] = { 0 };                                //创建用来记录方案数的数组
    for (int i = 14; i < n; i++)                    //录入新增的旅馆
        cin>>a[i];
    sort(a, a + n);                                    //排序
    rs[0] = 1;                                        //起点处方案为1
    for (int i = 1; i < n; i++)                        //从前往后处理
        for (int j = i - 1; j >= 0 && a[i] - a[j] <= B; j--) //从当前点向前寻找，符合要求就加上方案数
            if (a[i] - a[j] < A)continue;else rs[i] += rs[j];
    cout << rs[n - 1];                                //输出终点结果
    return 0;
}
```

#### 题解3：作者：Gao_Shang (赞：7)  
**星级：4星**  
**关键亮点**：  
- 使用了深度优先搜索（DFS）的思路，通过递归遍历所有可能的路径。
- 代码简洁，注释清晰，易于理解。
- 通过剪枝优化，避免了无效的递归调用。

**核心代码**：
```cpp
void lx/*dfs*/(int k)//k:第k个旅馆 
{
	//所有旅馆都走过了[满足条件] 
	if(k==n){
		//方法+1 
		ans++;
		return;
	}
	//从第k个旅馆出发 
	for(int i=k+1;i<=n;i++)
	//(当日?)所走路程满足条件{A<=路程<=B} 
	   if(a[i]-a[k]>=A&&a[i]-a[k]<=B/*可以走*/)
	      lx(i);//去第i个旅馆
}
```

### 推荐题目
1. **P1515 旅行**（本题）
2. **P1048 采药**（动态规划经典问题）
3. **P1219 八皇后**（深度优先搜索经典问题）
4. **P1434 滑雪**（动态规划与深度优先搜索结合）

### 个人心得摘录
- **翼德天尊**：“看完这么详细的题解，你是否看懂了呢? 如果还有疑问，可以在评论区随时询问，我会第一时间回复哒！”
- **Gao_Shang**：“这道题我个人认为只有一句话 ~~暴力出奇迹~~ 看了一下数据n只有20，完全可以用暴力来枚举所有的情况。”
- **jzy_go**：“冷静下来仔细一想，就会发现其实这和斐波那契数列有本质不同。前者是某一区间内符合条件的所有旅馆方案数相加，而后者只是单纯的前两个数相加。”

---
处理用时：44.59秒
# 题目信息

# 迷宫

## 题目描述

给定一个 $N \times M$ 方格的迷宫，迷宫里有 $T$ 处障碍，障碍处不可通过。

在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。

给定起点坐标和终点坐标，每个方格最多经过一次，问有多少种从起点坐标到终点坐标的方案。

## 说明/提示

对于 $100\%$ 的数据，$1 \le N,M \le 5$，$1 \le T \le 10$，$1 \le SX,FX \le n$，$1 \le SY,FY \le m$。

## 样例 #1

### 输入

```
2 2 1
1 1 2 2
1 2
```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题是一个经典的深度优先搜索（DFS）问题，要求从起点到终点的路径数量，且每个方格只能经过一次。题解主要集中在DFS的实现上，大部分题解都采用了回溯的思路，通过标记已访问的方格来避免重复访问，并在递归结束后恢复状态。部分题解还提到了使用方向数组来简化代码，以及如何处理终点可能有障碍的情况。

### 所选高星题解

#### 1. 作者：ybb756032937 (5星)
**关键亮点：**
- 使用了方向数组`dx`和`dy`来简化代码，避免了重复的if判断。
- 明确指出了不能在地图数组上直接打标记，否则会混淆障碍和已访问的方格。
- 提供了DFS的基本模板，适合初学者理解。

**个人心得：**
- 作者提到自己曾经因为在地图数组上打标记而只得了80分，强调了使用单独的标记数组的重要性。

**核心代码：**
```cpp
void walk(int x,int y) {
    if(x==fx&&y==fy) {
        total++;
        return;
    }
    for(int i=0;i<=3;i++) {
        if(temp[x+dx[i]][y+dy[i]]==0&&map[x+dx[i]][y+dy[i]]==1) {
            temp[x][y]=1;
            walk(x+dx[i],y+dy[i]);
            temp[x][y]=0;
        }
    }
}
```

#### 2. 作者：Billy●Herrington (4星)
**关键亮点：**
- 强调了起点需要标记为已访问，否则可能会导致多次访问起点。
- 代码简洁，逻辑清晰，适合初学者理解。

**个人心得：**
- 作者提到自己一开始只得了40分，原因是忘记标记起点为已访问。

**核心代码：
```cpp
void dfs(int x,int y) {
    if (x ==ex&&y ==ey) {
        CNT++;
        return;
    } 
    for (int k=0;k<4;k++) {
        int l=x+d[k];int r=y+d[k+1];
        if (l>=1&&r>=1&&l<=n&&r<=m&&!G [l][r]&&!VIS [l][r]) {
            VIS [l][r]=true;
            dfs (l,r);
            VIS [l][r]=false;
        }
    }
}
```

#### 3. 作者：Sn_Eddy (4星)
**关键亮点：**
- 使用了`bits/stdc++.h`头文件，简化了代码。
- 将边界当作障碍处理，减少了边界判断的复杂度。

**核心代码：
```cpp
void dfs(int a,int b) {
    if (a==ex&&b==ey) {
        sum++;
        return;
    }
    q[a][b]=0;
    if(q[a-1][b]!=0) {dfs(a-1,b);q[a-1][b]=1;}
    if(q[a][b-1]!=0) {dfs(a,b-1);q[a][b-1]=1;}
    if(q[a][b+1]!=0) {dfs(a,b+1);q[a][b+1]=1;}
    if(q[a+1][b]!=0) {dfs(a+1,b);q[a+1][b]=1;}
}
```

### 最优关键思路与技巧

1. **方向数组**：使用`dx`和`dy`数组来简化四个方向的移动代码，避免重复的if判断。
2. **标记数组**：使用单独的标记数组来记录已访问的方格，避免与障碍混淆。
3. **回溯**：在DFS结束后恢复状态，确保每条路径的独立性。
4. **起点标记**：在DFS开始前将起点标记为已访问，避免重复访问。

### 拓展思路与类似题目

1. **类似题目**：
   - [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)：经典的DFS回溯问题，适合练习DFS的基本应用。
   - [P1506 拯救oibh总部](https://www.luogu.com.cn/problem/P1506)：DFS与BFS的结合，适合练习搜索算法的综合应用。
   - [P1596 [USACO07DEC]Lake Counting S](https://www.luogu.com.cn/problem/P1596)：DFS在连通块问题中的应用。

2. **调试与优化**：在DFS中，调试时可以通过打印路径或标记数组来检查算法的正确性。优化时可以考虑剪枝或记忆化搜索来减少不必要的递归调用。

### 总结

本题的DFS实现相对简单，但需要注意细节，如标记数组的使用和回溯的处理。通过方向数组和标记数组的优化，可以显著提高代码的可读性和效率。

---
处理用时：42.34秒
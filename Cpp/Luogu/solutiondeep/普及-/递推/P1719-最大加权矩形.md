# 题目信息

# 最大加权矩形

## 题目描述

为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。

校长先给他们一个 $n\times n$ 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 $[-127,127]$ ,例如

```plain
 0 –2 –7  0 
 9  2 –6  2
-4  1 –4  1 
-1  8  0 –2
```

在左下角：

```plain
9  2
-4  1
-1  8
```

和为 $15$。

几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？


## 说明/提示

$1 \leq n\le 120$

## 样例 #1

### 输入

```
4
0 -2 -7 0
 9 2 -6 2
-4 1 -4  1 
-1 8  0 -2
```

### 输出

```
15```

# AI分析结果

### 综合分析与结论

本题的核心是寻找矩阵中的最大加权矩形，本质上是二维的最大子段和问题。大部分题解采用了**矩阵压缩**和**前缀和**的技巧，将二维问题转化为一维问题，再通过动态规划或贪心算法求解。以下是各题解的思路对比：

1. **矩阵压缩**：通过将多行压缩为一行，将二维问题转化为一维问题，再使用最大子段和算法求解。这是最常见的解法，时间复杂度为O(n^3)。
2. **前缀和**：通过预处理前缀和，快速计算任意子矩阵的和，进一步优化了矩阵压缩的过程。
3. **动态规划**：部分题解使用了动态规划的思想，直接在一维数组上求解最大子段和，进一步优化了时间复杂度。

### 所选高星题解

#### 1. 题解作者：Yaser (★★★★★)
**关键亮点**：
- **矩阵压缩**：详细解释了如何将二维矩阵压缩为一维数组，并通过最大子段和算法求解。
- **代码清晰**：代码结构清晰，使用了动态规划的思想，易于理解。
- **优化思路**：通过逐行压缩矩阵，避免了不必要的计算，时间复杂度为O(n^3)。

**核心代码**：
```cpp
void MatrixSum() {
    loop(i, 1, n) {
        mset(temp, 0);
        loop(j, i, n) {
            loop(k, 1, n) {
                temp[k] += matrix[j][k];
            }
            Arrsum();
        }
    }
}
```
**实现思想**：逐行压缩矩阵，计算每一列的和，然后通过动态规划求解最大子段和。

#### 2. 题解作者：Stella_Yan (★★★★☆)
**关键亮点**：
- **前缀和优化**：通过二维前缀和快速计算任意子矩阵的和，减少了重复计算。
- **思路清晰**：详细解释了如何通过前缀和公式计算子矩阵的和，逻辑清晰。
- **代码简洁**：代码简洁明了，易于实现。

**核心代码**：
```cpp
for(int x1=1;x1<=n;x1++){
    for(int y1=1;y1<=n;y1++){
        for(int x2=1;x2<=n;x2++){
            for(int y2=1;y2<=n;y2++){
                if(x2<x1 || y2<y1) continue;
                mx=max(mx,sum[x2][y2]+sum[x1-1][y1-1]-sum[x2][y1-1]-sum[x1-1][y2]);
            }
        }
    }
}
```
**实现思想**：通过四重循环枚举所有可能的子矩阵，利用前缀和公式快速计算子矩阵的和。

#### 3. 题解作者：X_WT (★★★★☆)
**关键亮点**：
- **前缀和与动态规划结合**：通过前缀和快速压缩矩阵，再使用动态规划求解最大子段和。
- **优化思路**：通过逐行压缩矩阵，避免了不必要的计算，时间复杂度为O(n^3)。
- **代码简洁**：代码简洁，易于理解。

**核心代码**：
```cpp
for(i=1;i<=n;++i){
    for(k=1;k<=i;++k){
        int f[150]={0},dp[150]={0};
        for(j=1;j<=n;++j){
            f[j]=a[i][j]-a[i-k][j];
            dp[j]=maxn(dp[j-1]+f[j],f[j]);
            ans=maxn(ans,dp[j]);
        }
    }
}
```
**实现思想**：通过逐行压缩矩阵，计算每一列的和，然后通过动态规划求解最大子段和。

### 最优关键思路与技巧

1. **矩阵压缩**：将二维问题转化为一维问题，通过逐行压缩矩阵，计算每一列的和，再使用最大子段和算法求解。
2. **前缀和优化**：通过预处理前缀和，快速计算任意子矩阵的和，减少了重复计算。
3. **动态规划**：在一维数组上使用动态规划求解最大子段和，进一步优化了时间复杂度。

### 拓展思路与类似题目

1. **类似题目**：
   - **P1115 最大子段和**：本题的一维版本，考察动态规划的应用。
   - **P1736 最大正方形**：寻找矩阵中的最大正方形，考察二维动态规划。
   - **P1387 最大正方形 II**：在矩阵中寻找最大正方形，考察二维动态规划。

2. **调试与顿悟**：
   - **调试经历**：部分题解提到在调试过程中发现前缀和公式的错误，通过画图验证公式的正确性。
   - **顿悟感想**：通过矩阵压缩和前缀和的结合，成功将二维问题转化为一维问题，大大简化了问题的复杂度。

### 推荐题目
1. **P1115 最大子段和**：本题的一维版本，考察动态规划的应用。
2. **P1736 最大正方形**：寻找矩阵中的最大正方形，考察二维动态规划。
3. **P1387 最大正方形 II**：在矩阵中寻找最大正方形，考察二维动态规划。

---
处理用时：38.30秒
# 题目信息

# A+B Problem（再升级）

## 题目背景

题目名称是吸引你点进来的。

实际上该题还是很水的。


## 题目描述

- $1+1=?$ 显然是 $2$。
- $a+b=?$ P1001 回看不谢。
- 哥德巴赫猜想 似乎已呈泛滥趋势。

_以上纯属个人吐槽_

给定一个正整数 $n$，求将其分解成若干个素数之和的方案总数。



## 说明/提示

### 样例解释

存在如下三种方案：

- $7=7$。
- $7=2+5$。
- $7=2+2+3$。

### 数据范围及约定

- 对于 $30\%$ 的数据 $1\le n\le 10$。
- 对于 $100\%$ 的数据，$1\le n\le 10^3$。


## 样例 #1

### 输入

```
7```

### 输出

```
3```

## 样例 #2

### 输入

```
20```

### 输出

```
26```

# AI分析结果

### 综合分析与结论

本题的核心是将一个正整数 \( n \) 分解为若干个素数之和的方案总数。大多数题解采用了**完全背包**的思路，结合**素数筛法**（如埃氏筛或欧拉筛）来预处理素数，然后通过动态规划求解方案数。部分题解还引入了生成函数、多项式乘法等高级算法，但复杂度较高，适用于更大数据范围。

**关键思路与技巧：**
1. **素数筛法**：预处理素数表，常用的有埃氏筛和欧拉筛。
2. **完全背包**：将素数视为物品，\( n \) 为背包容量，求方案总数。
3. **动态规划**：状态转移方程为 \( dp[j] = dp[j] + dp[j - prime[i]] \)，其中 \( dp[0] = 1 \) 表示初始状态。
4. **优化**：部分题解通过生成函数或多项式乘法优化了时间复杂度，但代码复杂度较高。

**通用建议与扩展思路：**
- **素数筛法**：掌握埃氏筛和欧拉筛，理解其时间复杂度与适用场景。
- **完全背包**：理解完全背包的状态转移方程，掌握其在方案数问题中的应用。
- **动态规划优化**：对于更大数据范围，可以考虑生成函数或多项式乘法等优化方法。

### 所选高星题解

#### 1. 作者：hmh13951417981 (5星)
**关键亮点：**
- 思路清晰，代码简洁，完全背包与素数筛法结合紧密。
- 代码可读性强，注释详细，适合初学者理解。

**核心代码：**
```cpp
void prime(){
    for(i=2;i<=500;i++)
        if(!b[i])
            for(j=2;i*j<=1000;j++)
                b[i*j]=1;
}
dp[0]=1;
for(i=2;i<=n;i++)
    if(!b[i])
        for(j=i;j<=n;j++)
            dp[j]+=dp[j-i];
```
**实现思想：** 通过埃氏筛预处理素数，然后使用完全背包的状态转移方程求解方案数。

#### 2. 作者：NaCly_Fish (4星)
**关键亮点：**
- 引入了生成函数和多项式乘法，理论复杂度为 \( \Theta(n \log n) \)。
- 适用于更大数据范围，但代码复杂度较高。

**核心代码：**
```cpp
poly exp(poly f){
    poly g,h;
    clear(g);
    int lim = 1,n = f.t,top = 0;
    int s[30];
    while(n){
        s[++top] = n;
        n >>= 1;
    }
    g[0] = 1;
    while(top--){
        g.t = n = s[top+1];
        h = g,g = log(g);
        for(reg int i=0;i<=n;++i) g[i] = dec(f[i],g[i]);
        g[0] = add(g[0],1);
        while(lim<=(n<<1)) lim <<= 1;
        NTT(g,1,lim),NTT(h,1,lim);
        for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%zjx;
        NTT(g,-1,lim);
        for(reg int i=n+1;i!=lim;++i) g[i] = 0;
    }
    return g;
}
```
**实现思想：** 通过生成函数和多项式乘法优化了时间复杂度，适用于更大数据范围。

#### 3. 作者：Misaka19280 (4星)
**关键亮点：**
- 类比“过河卒”问题，将二维问题简化为一维，思路新颖。
- 代码简洁，适合初学者理解。

**核心代码：**
```cpp
for i:=2 to n do
    if sha[i] then 
        for j:=i to n do
            f[j]:=f[j]+f[j-i];
```
**实现思想：** 通过埃氏筛预处理素数，然后使用完全背包的状态转移方程求解方案数。

### 推荐题目
1. **P1002 过河卒**：动态规划经典问题，与本题思路相似。
2. **P1048 采药**：完全背包问题，适合练习背包模型。
3. **P1060 开心的金明**：动态规划与背包问题的结合，适合进阶练习。

### 个人心得总结
- **调试经历**：部分题解提到在调试过程中发现未开 `long long` 导致数据溢出，提醒我们在处理大数时要注意数据类型。
- **踩坑教训**：完全背包的状态转移方程中，\( dp[0] = 1 \) 是初始状态，容易被忽略。
- **顿悟感想**：通过生成函数和多项式乘法优化时间复杂度，虽然代码复杂，但能显著提升算法效率。

---
处理用时：35.41秒
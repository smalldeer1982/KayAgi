# 题目信息

# [USACO08FEB] Dining Cows B

## 题目描述

为了避免餐厅过分拥挤，FJ 要求奶牛们分 $2$ 批就餐。每天晚饭前，奶牛们都会在餐厅前排队入内，按 FJ 的设想，所有第 $2$ 批就餐的奶牛排在队尾，队伍的前半部分则由设定为第 $1$ 批就餐的奶牛占据。

由于奶牛们不理解 FJ 的安排，晚饭前的排队成了一个大麻烦。 第 $i$ 头奶牛有一张标明她用餐批次 $D_i$ 的卡片。虽然所有 $N$ 头奶牛排成了很整齐的队伍，但谁都看得出来，卡片上的号码是完全杂乱无章的。 在若干次混乱的重新排队后，FJ 找到了一种简单些的方法：奶牛们不动，他沿着队伍从头到尾走一遍，把那些他认为排错队的奶牛卡片上的编号改掉，最终得到一个他想要的每个组中的奶牛都站在一起的队列，例如 $112222$ 或 $111122$。有的时候，FJ 会把整个队列弄得只有 $1$ 组奶牛（比方说，$1111$ 或 $222$）。 

你也晓得，FJ 是个很懒的人。他想知道，如果他想达到目的，那么他最少得改多少头奶牛卡片上的编号。所有奶牛在 FJ 改卡片编号的时候，都不会挪位置。

## 说明/提示

$1 \le N \le 3 \times 10 ^ 4$

## 样例 #1

### 输入

```
7
2
1
1
1
2
2
1```

### 输出

```
2```

## 样例 #2

### 输入

```
5
2
2
1
2
2```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心目标是通过最少的修改次数，将奶牛的队列分成两部分，前半部分为1，后半部分为2。大多数题解采用了动态规划（DP）或前缀和的思想来解决这个问题。DP方法通过状态转移方程来计算每个位置的最小修改次数，而前缀和方法则通过统计每个位置前后的1和2的数量来快速计算最小修改次数。

### 所选高星题解

#### 1. 作者：深海鱼的眼泪 (赞：61)
- **星级**: 5星
- **关键亮点**: 使用了动态规划的思路，状态转移方程清晰，代码简洁且易于理解。通过`dp[i][0]`和`dp[i][1]`分别表示第i头奶牛为1和2时的最小修改次数，最终比较`dp[n][0]`和`dp[n][1]`得到结果。
- **核心代码**:
  ```cpp
  for (i=2;i<=n;++i){
      if (d[i]==1){
          dp[i][0]=dp[i-1][0];
          dp[i][1]=min(dp[i-1][1],dp[i-1][0])+1;
      }else{
          dp[i][0]=dp[i-1][0]+1;
          dp[i][1]=min(dp[i-1][1],dp[i-1][0]);
      }
  }
  ```

#### 2. 作者：AK_Zero (赞：33)
- **星级**: 4星
- **关键亮点**: 采用了前缀和的思想，通过统计每个位置前后的1和2的数量，快速计算最小修改次数。思路清晰，代码简洁。
- **核心代码**:
  ```cpp
  for(int i=1; i<=n; i++) {
      if(a[i]==2) gb++; else gb--;
      if(gb<mi) mi=gb;
  }
  ```

#### 3. 作者：AnChun999 (赞：10)
- **星级**: 4星
- **关键亮点**: 同样使用了前缀和的思想，通过`ll[i]`和`rr[i]`分别记录1和2的数量，枚举每个点计算最小修改次数。代码结构清晰，易于理解。
- **核心代码**:
  ```cpp
  for(int i=2;i<=n;i++)
      ans=min(ans,(ll[n]-ll[i-1])+rr[i-1]);
  ```

### 最优关键思路与技巧

1. **动态规划**: 通过状态转移方程计算每个位置的最小修改次数，适用于需要逐个处理元素的场景。
2. **前缀和**: 通过统计每个位置前后的1和2的数量，快速计算最小修改次数，适用于需要快速查询区间统计信息的场景。

### 可拓展之处

1. **类似问题**: 类似的问题包括将数组分成两部分，每部分满足特定条件，如颜色分类、区间划分等。
2. **算法套路**: 动态规划和前缀和是解决区间统计和最小修改问题的常用方法，可以应用于多种类似问题。

### 推荐题目

1. **P1020 导弹拦截**: 考察最长不下降子序列，与本题的DP思路类似。
2. **P1049 装箱问题**: 考察动态规划的应用，与本题的DP思路类似。
3. **P1060 开心的金明**: 考察动态规划的应用，与本题的DP思路类似。

### 个人心得摘录

- **深海鱼的眼泪**: "如果用DP其实很好想啊，用dp[i][0]表示第i头奶牛为1时需改的最小数量，dp[i][1]表示第i头奶牛为2时需改的最小数量。"
- **AK_Zero**: "其实这道题只用o(n)算法就可以啦QWQ，因为我们的最终目标是将整个奶牛队列排序，使其变成所有1牌奶牛在前，2牌奶牛在后。"

### 总结

动态规划和前缀和是解决本题的两种主要方法，各有其优势。动态规划适用于逐个处理元素的场景，而前缀和则适用于快速查询区间统计信息的场景。根据具体问题选择合适的算法，可以大大提高解题效率。

---
处理用时：29.35秒
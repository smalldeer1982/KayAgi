# 题目信息

# [KMOI R1] 五五五五（Easy）

## 题目背景

“迟序之数，非出神怪，有形可检，有数可推。”——祖冲之

## 题目描述

小宋有一个序列 $a_1,a_2\dots,a_n$，其中对于 $i\in [1,n]$，满足 $a_i\in[0,9]$。

对于 $1\le l\le r\le n$，他记 $f(l,r)$ 等于 $\overline{a_la_{(l+1)}\dots a_r}$ 的末尾连续 $5$ 的个数。

例如：对于序列 $a=\{1,1,4,5,1,4\}$，$f(2,4)=1,f(1,3)=0$。

现在请你求出:

$$\Big(\sum\limits_{l=1}^
{n}\sum\limits_{r=l}^{n} f(l,r)\Big) \bmod 10^9+7$$

## 说明/提示

## 样例 $1$ 解释：

$f(1,1)=1$。

$f(1,2)=2$。

$f(2,2)=1$。

得到答案 $ans=f(1,1)+f(1,2)+f(2,2)=4$，故输出 $4$。

## 数据范围

**本题采用 subtask 捆绑测试。**

令 $m=\max\{a_1,a_2,\dots,a_n\}$。

| 子任务编号 | 测试点编号 | $n\le$ | $m\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $1$ | $100$ | $3$ | 无 | $3$ |
| $2$ | $2\sim 4$ | $2\times 10^5$ | $5$ | $\mathbf{A}$ | $22$ |
| $3$ | $5,6$ | $100$ | $5$ | 无 | $10$ |
| $4$ | $7\sim 10$ | $2\times 10^5$ | $5$ | $\mathbf{B}$ | $25$ |
| $5$ | $11\sim 20$ | $2\times 10^5$ | $9$ | 无 | $40$ |

特殊性质 $\mathbf{A}:$ 序列平均数为 $5$。

特殊性质 $\mathbf{B}:$ 序列单调不上升。

对于 $100\%$ 的数据：$1\le n\le 2\times 10^5$，$0\le m\le 9$。

对于 $\forall i\in [1,n]$，满足 $a_i\in[0,9]$。

## 样例 #1

### 输入

```
2
5 5```

### 输出

```
4```

## 样例 #2

### 输入

```
4
1 1 4 5```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

该题目要求计算所有子区间末尾连续5的个数之和，且数据规模较大（n ≤ 2e5），因此需要高效的算法。大多数题解都采用了类似的思路：通过遍历序列，记录当前连续5的长度，并根据该长度计算贡献。核心思想是将问题转化为对每个右端点的贡献计算，避免暴力枚举所有子区间。

### 所选高星题解

#### 1. 作者：Fire_flame (5星)
- **关键亮点**：思路清晰，代码简洁，时间复杂度为O(n)。通过递推的方式计算每个右端点的贡献，分为两部分：连续5之前的贡献和连续5内部的贡献。代码实现简洁，逻辑清晰。
- **核心代码**：
  ```cpp
  for(int i = 1;i <= n;i ++){
      if(a[i] == 5)cnt ++;
      else cnt = 0;
      ans += (i - cnt + 1) * cnt % MOD + cnt * (cnt - 1) / 2 % MOD;
      ans %= MOD;
  }
  ```
- **个人心得**：通过递推的方式，避免了复杂的区间计算，代码简洁且高效。

#### 2. 作者：HEzzz (4星)
- **关键亮点**：通过定义数组 `s[i]` 表示以第 `i` 个数为结尾的连续5的长度，将问题转化为对 `s[i]` 的计算。思路清晰，代码可读性强。
- **核心代码**：
  ```cpp
  _rep(i,1,n) if(a[i]==5) s[i]=s[i-1]+1; else s[i]=0;
  _rep(i,1,n) ans+=(i-s[i]+1)*s[i]+(s[i]-1)*s[i]/2,ans%=mod;
  ```
- **个人心得**：通过记录连续5的长度，简化了贡献计算，代码实现简洁。

#### 3. 作者：Vct14 (4星)
- **关键亮点**：通过遍历右端点，计算每个右端点的贡献，分为两部分：连续5之前的贡献和连续5内部的贡献。思路清晰，代码简洁。
- **核心代码**：
  ```cpp
  if(a[i]==5){
      N++;
      s=(s+(N*(N+1)/2%M+(r-N)*N%M)%M)%M;
  }
  else N=0;
  ```
- **个人心得**：通过遍历右端点，避免了复杂的区间计算，代码简洁且高效。

### 最优关键思路或技巧

- **递推计算贡献**：通过遍历序列，记录当前连续5的长度，并根据该长度计算贡献，避免了暴力枚举所有子区间。
- **分块计算**：将贡献分为两部分：连续5之前的贡献和连续5内部的贡献，简化了计算过程。
- **时间复杂度优化**：通过递推和分块计算，将时间复杂度优化到O(n)，适用于大规模数据。

### 可拓展之处

- **类似问题**：类似的问题可以考察其他连续元素的统计，如连续1的个数、连续递增序列的长度等。
- **算法套路**：递推和分块计算的思路可以应用于其他需要统计子区间性质的问题，如子区间和、子区间最大值等。

### 推荐题目

1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)

### 个人心得总结

- **调试经历**：在实现过程中，需要注意边界条件的处理，如连续5的长度为0时的情况。
- **踩坑教训**：在计算贡献时，注意取模运算的顺序，避免溢出。
- **顿悟感想**：通过递推和分块计算，可以将复杂的问题简化为简单的遍历和计算，提高代码的效率和可读性。

---
处理用时：26.25秒
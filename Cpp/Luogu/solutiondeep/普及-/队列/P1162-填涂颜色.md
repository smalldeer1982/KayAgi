# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果

### 综合分析与结论

该题目要求将闭合圈内的0填充为2，主要难点在于如何区分圈内和圈外的0。大部分题解采用了DFS或BFS的搜索算法，通过从边界或特定点开始搜索，标记圈外的0，最终将未被标记的0填充为2。部分题解还通过预处理（如在外围加一圈0）来简化搜索过程。

### 所选高星题解

#### 1. **作者：LMB_001 (赞：1263)**  
**星级：5星**  
**关键亮点：**  
- 使用了DFS从边界开始搜索，标记圈外的0，最终将未被标记的0填充为2。
- 代码简洁，逻辑清晰，易于理解。
- 通过在外围加一圈0，确保搜索的完整性。

**核心代码：**
```cpp
void dfs(int p, int q) {
    if (p < 0 || p > n + 1 || q < 0 || q > n + 1 || a[p][q] != 0) return;
    a[p][q] = 1;
    for (int i = 1; i <= 4; i++) dfs(p + dx[i], q + dy[i]);
}
```
**个人心得：**  
作者提到“从0,0开始搜”，通过在外围加一圈0，确保搜索的完整性，避免了边界问题。

#### 2. **作者：冰冻赤道 (赞：277)**  
**星级：4.5星**  
**关键亮点：**  
- 使用BFS从边界开始搜索，标记圈外的0，最终将未被标记的0填充为2。
- 通过队列实现BFS，代码结构清晰，易于理解。
- 详细解释了搜索的思路和实现细节。

**核心代码：**
```cpp
void bfs(int x, int y) {
    vis[x][y] = 1;
    q.push(x); q.push(y);
    while (!q.empty()) {
        int w = q.front(); q.pop();
        int e = q.front(); q.pop();
        if (map[w + 1][e] == 0 && w != n && !vis[w + 1][e]) vis[w + 1][e] = 1, q.push(w + 1), q.push(e);
        // 其他方向类似
    }
}
```
**个人心得：**  
作者提到“从边界开始搜索”，通过BFS确保所有圈外的0都被标记，避免了漏掉某些区域。

#### 3. **作者：zhy137036 (赞：180)**  
**星级：4星**  
**关键亮点：**  
- 使用DFS和BFS的对比，详细解释了两种搜索算法的实现和区别。
- 通过栈实现DFS，代码结构清晰，易于理解。
- 提供了对搜索算法的深入理解，适合初学者学习。

**核心代码：**
```cpp
void search(int x, int y) {
    int dx[5] = {0, -1, 0, 1, 0}, dy[5] = {0, 0, 1, 0, -1};
    sta.push(pair<int, int>(x, y));
    while (!sta.empty()) {
        pair<int, int> t = sta.top(); sta.pop();
        a[t.first][t.second] = 2;
        for (int i = 1; i <= 4; i++) {
            if (t.first + dx[i] >= 0 && t.first + dx[i] <= n + 1)
                if (t.second + dy[i] >= 0 && t.second + dy[i] <= n + 1)
                    if (a[t.first + dx[i]][t.second + dy[i]] == 0)
                        sta.push(pair<int, int>(t.first + dx[i], t.second + dy[i]));
        }
    }
}
```
**个人心得：**  
作者提到“DFS只能用栈实现”，通过栈实现DFS，避免了递归的深度限制。

### 最优关键思路与技巧

1. **从边界开始搜索**：通过从边界或外围加一圈0开始搜索，确保所有圈外的0都被标记，避免漏掉某些区域。
2. **DFS与BFS的选择**：DFS适合深度优先的搜索，BFS适合广度优先的搜索，两者在不同场景下各有优势。
3. **预处理简化搜索**：在外围加一圈0，简化搜索过程，确保搜索的完整性。

### 拓展思路与类似题目

1. **类似题目**：
   - [P1506 拯救oibh总部](https://www.luogu.org/problem/P1506)：同样是搜索题，要求找到被围住的区域。
   - [P1163 填涂颜色](https://www.luogu.org/problem/P1163)：类似的填色问题，考察搜索算法。
   - [P1141 01迷宫](https://www.luogu.org/problem/P1141)：通过搜索解决迷宫问题，考察BFS和DFS的应用。

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中遇到边界问题，通过在外围加一圈0解决了问题。
- **踩坑教训**：有些作者提到直接搜索圈内的0较为困难，转而搜索圈外的0，简化了问题。
- **顿悟感想**：通过预处理和从边界开始搜索，可以大大简化搜索过程，提高代码的可读性和效率。

---
处理用时：41.23秒
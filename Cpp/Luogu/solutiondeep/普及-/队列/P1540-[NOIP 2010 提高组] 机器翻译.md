# 题目信息

# [NOIP 2010 提高组] 机器翻译

## 题目背景

NOIP2010 提高组 T1

## 题目描述

小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。

这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。

假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。

假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。

## 说明/提示

### 样例解释

整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：

1. `1`：查找单词 1 并调入内存。
2. `1 2`：查找单词 2 并调入内存。
3. `1 2`：在内存中找到单词 1。
4. `1 2 5`：查找单词 5 并调入内存。
5. `2 5 4`：查找单词 4 并调入内存替代单词 1。
6. `2 5 4`：在内存中找到单词 4。
7. `5 4 1`：查找单词 1 并调入内存替代单词 2。

共计查了 $5$ 次词典。

### 数据范围

- 对于 $10\%$ 的数据有 $M=1$，$N \leq 5$；
- 对于 $100\%$ 的数据有 $1 \leq M \leq 100$，$1 \leq N \leq 1000$。

## 样例 #1

### 输入

```
3 7
1 2 1 5 4 4 1
```

### 输出

```
5
```

# AI分析结果

### 综合分析与结论

本题解的核心问题是如何高效模拟内存中的单词替换过程，主要涉及数据结构的选取和算法的优化。大多数题解都采用了队列（Queue）来模拟内存的先进先出（FIFO）特性，同时使用数组或哈希表来标记单词是否在内存中。部分题解还引入了指针思想或STL容器（如vector、set）来进一步优化代码。

### 所选高星题解

#### 1. 作者：Apun (赞：501) - 5星
- **关键亮点**：使用指针思想优化内存管理，通过两个数组分别标记单词是否在内存中和存储内存中的单词顺序。指针的使用简化了内存满时的删除操作，代码简洁高效。
- **个人心得**：作者强调了指针思想的重要性，通过指针的移动来管理内存，避免了复杂的查找和删除操作，大大提高了代码的效率。

```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
using namespace std;
int n,m,x,ans,l,r,a[1005],b[1005];
int main()
{
    cin>>m>>n;
    l=0;r=0;
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&x);
        if (a[x]==0) 
        {
            ans++;
            r++;b[r]=x;a[x]=1;
            if (r>m) {l++;a[b[l]]=0;}
        }
    }
    cout<<ans;
    return 0;
}
```

#### 2. 作者：Anguei (赞：213) - 4星
- **关键亮点**：使用STL中的vector和find函数来模拟内存，代码简洁明了，适合对STL熟悉的开发者。
- **个人心得**：作者通过STL的find函数简化了查找操作，虽然时间复杂度略高，但代码非常易读。

```cpp
#include <vector>
#include <iostream> 
#include <algorithm>

int main() {
	int m, n, t, ans = 0;
	std::cin >> m >> n;
	std::vector<int> v;
	while (std::cin >> t) {
		if (std::find(v.begin(), v.end(), t) == v.end()) {
			v.push_back(t);
			++ans;
		}
		if (v.size() > m)
			v.erase(v.begin());
	}
	std::cout << ans << std::endl;
}
```

#### 3. 作者：JCT_addyi (赞：7) - 4星
- **关键亮点**：使用队列和数组标记单词是否在内存中，代码结构清晰，易于理解。
- **个人心得**：作者通过队列的先进先出特性，直接模拟了内存的替换过程，代码逻辑清晰。

```cpp
#include<bits/stdc++.h>
using namespace std;
int h[1005]={0};
queue<int>tjc;
int main(){
    int m,n;
    cin>>m>>n;
    int cnt=0;
    while(n--){
    	int en;
    	cin>>en;     
    	if(h[en]==0){
    		++cnt;
    		tjc.push(en);
    		h[en]=1;
    		while(tjc.size()>m){
    			h[tjc.front()]=0;
    			tjc.pop();
			}
		}
	}
	cout<<cnt;
return 0;
}
```

### 最优关键思路与技巧
- **队列与标记数组的结合**：使用队列模拟内存的先进先出特性，同时使用数组或哈希表标记单词是否在内存中，是解决本题的最优方法。
- **指针思想**：通过指针管理内存中的单词顺序，简化了内存满时的删除操作，提高了代码效率。
- **STL容器的使用**：对于熟悉STL的开发者，使用vector和find函数可以简化代码，但需要注意时间复杂度。

### 可拓展之处
- **类似题目**：可以扩展到其他需要模拟缓存或内存管理的题目，如LRU缓存机制（LeetCode 146）。
- **算法套路**：类似问题通常涉及队列、哈希表或指针的使用，掌握这些数据结构的基本操作和优化技巧是关键。

### 推荐相似题目
1. [P1540 机器翻译](https://www.luogu.com.cn/problem/P1540)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)

### 个人心得总结
- **调试经历**：部分作者提到在调试过程中发现指针移动的错误，强调了指针初始化和移动的细节。
- **顿悟感想**：有作者提到通过指针思想顿悟了内存管理的简化方法，强调了算法思维的重要性。

---
处理用时：24.31秒
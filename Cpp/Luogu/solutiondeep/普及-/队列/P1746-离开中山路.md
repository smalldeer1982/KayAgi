# 题目信息

# 离开中山路

## 题目背景

《爱与愁的故事第三弹·shopping》最终章。


## 题目描述

爱与愁大神买完东西后，打算坐车离开中山路。现在爱与愁大神在 $x_1,y_1$ 处，车站在 $x_2,y_2$ 处。现在给出一个 $n \times n(n \le 1000)$ 的地图，$0$ 表示马路，$1$ 表示店铺（不能从店铺穿过），爱与愁大神只能垂直或水平着在马路上行进。爱与愁大神为了节省时间，他要求最短到达目的地距离（每两个相邻坐标间距离为 $1$）。你能帮他解决吗？


## 说明/提示


对于 $20\%$ 数据，满足 $1\leq n \le 100$。

对于 $100\%$ 数据，满足 $1\leq n \le 1000$。

## 样例 #1

### 输入

```
3
001
101
100
1 1 3 3```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

本题是一个典型的广度优先搜索（BFS）问题，要求从起点到终点的最短路径。大部分题解都采用了BFS算法，部分题解还引入了双向BFS、A*算法等优化策略。整体来看，题解的质量参差不齐，部分题解代码冗长、思路不够清晰，但也有几篇题解在代码简洁性、算法优化和思路清晰度上表现较好。

### 所选高质量题解

#### 1. 题解作者：Cult_style (5星)
- **关键亮点**：代码简洁，BFS实现清晰，使用了STL队列，代码可读性高。题解详细解释了BFS的基本原理和队列的使用，适合初学者理解。
- **个人心得**：作者提到`vis`数组初始化为1的原因，避免了在`check`函数中重复判断，提升了代码效率。
- **核心代码**：
```cpp
void bfs(int x,int y){
	vis[x][y]=1;
	q.push((node){x,y});
	while(q.size()!=0){
	    int xx=q.front().x;
	    int yy=q.front().y;
	    q.pop();
	    for(int i=0;i<4;i++){
		int xxx=xx+h[i];
		int yyy=yy+s[i];
		if(check(xxx,yyy)){
		    vis[xxx][yyy]=vis[xx][yy]+1;
		    q.push((node){xxx,yyy});
	        }
	    }
        }
}
```

#### 2. 题解作者：_yjh (4.5星)
- **关键亮点**：使用了STL队列，代码结构清晰，题解中详细解释了BFS的原理和队列的操作，适合初学者。
- **个人心得**：作者提到“广搜是几条路径同时进行的，最先到达的路径一定是最短的”，强调了BFS的最优性。
- **核心代码**：
```cpp
int bfs(int sx,int sy){
	q.push((Pos){sx,sy});
	vis[sx][sy]=true;
	while(!q.empty()){
	    x=q.front().x; y=q.front().y;
	    q.pop();
	    if(x==t_a&&y==t_b) return dis[x][y];
	    for(int i=0;i<4;i++){
		tx=x+dx[i]; ty=y+dy[i];
		if(tx<=0||tx>n||ty<=0||ty>n) continue;
		if(mp[tx][ty]=='1'||vis[tx][ty]==true) continue;
		dis[tx][ty]=dis[x][y]+1;
		vis[tx][ty]=true;
		q.push((Pos){tx,ty});
	    }
	}
	return -1;
}
```

#### 3. 题解作者：Ciyang (4星)
- **关键亮点**：引入了A*算法，虽然对于本题来说A*并不是最优选择，但作者详细解释了A*的原理和实现，具有一定的学习价值。
- **个人心得**：作者提到“A*算法通常用来寻路，是启发式搜索的一种”，并详细介绍了A*的估值函数设计。
- **核心代码**：
```cpp
void Astar() {
	priority_queue<node *, vector<node *>, nodecmp> q;
	newn[bx][by].init(bx, by, 0);
	q.push(&newn[bx][by]);
	while(!q.empty()) {
	    lx= q.top()->x;
	    ly= q.top()->y;
	    lstep= q.top()->step;
	    q.pop();
	    closelist[lx][ly]= true;
	    for(int i= 0; i < 4; i++) {
		newx= lx + moves[i][0], newy= ly + moves[i][1];
		if(tmap[newx][newy] == '1' || closelist[newx][newy]) continue;
		if(newx == wx && newy == wy) {
		    ans= lstep + 1;
		    return;
		}
		if(openlist[newx][newy]) {
		    if(lstep < newn[newx][newy].step) {
			newn[newx][newy].update(lstep + 1);
		    }
		}
		else {
		    newn[newx][newy].init(newx, newy, lstep + 1);
		    q.push(&newn[newx][newy]);
		    openlist[newx][newy]= true;
		}
	    }
	}
	return;
}
```

### 最优关键思路与技巧
1. **BFS的核心思想**：通过队列实现层序遍历，确保最先到达终点的路径是最短的。
2. **剪枝优化**：使用`vis`数组记录已访问节点，避免重复访问，提升效率。
3. **双向BFS**：从起点和终点同时进行BFS，减少搜索空间，适用于较大规模的地图。
4. **A*算法**：通过引入启发式函数，优先搜索更有可能接近终点的路径，适用于复杂地图。

### 拓展思路与类似题目
- **类似题目**：
  1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
  2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
  3. [P1131 最小生成树](https://www.luogu.com.cn/problem/P1131)

### 个人心得总结
- **调试经历**：部分作者提到在调试过程中遇到数组越界、初始值设置错误等问题，强调了边界检查的重要性。
- **顿悟感想**：通过BFS的最优性，理解了为什么最先到达的路径一定是最短的，加深了对算法的理解。

### 通用建议
- **代码简洁性**：尽量使用STL容器（如`queue`）简化代码，提升可读性。
- **边界检查**：在BFS中，始终注意数组越界问题，确保代码的健壮性。
- **算法选择**：对于简单的最短路径问题，优先选择BFS；对于复杂地图，可以考虑双向BFS或A*算法。

---
处理用时：34.56秒
# 题目信息

# [GDOI2014] 世界杯

## 题目描述

3014 年世界杯足球赛就要开始了！作为卫冕冠军中国足球队的教练，手下每位球员都是猛将，如何摆出最强的 11 人阵容也是一件幸福的烦恼事啊。

众所周知，足球阵容里的11个球员都会被分配到场上某一个特别的位置，而这些位置主要分为守门员、后卫、中场和前锋四种，其中守门员有且只有一个，后卫、中场和前锋的人数取决于你安排的足球阵型。形容足球阵型的方法由后卫开始计算至前锋，但不把守门员计算在内。例如，3-5-2 阵型是指有三个后卫、五个中场及两名前锋。由于竞争激烈，每位球员只会培养其中一种位置所需要的技能，所以他们每个人都只能胜任四个位置中的其中一种。

作为一个对球员能力了如指掌的教练，你给每个球员的综合水平进行量化。为了将阵型安排得更好，你的教练团队决定使用以下策略安排球员：首先按照顺序提出 $Q$ 个阵型，分别代表第一阵型、第二阵型、……、第 $Q$ 阵型。然后对于每个阵型，从仍未选择的球员中选择最好的对应数量的守门员、后卫、中场和前锋。比如说，对于第一阵型，在所有球员中选择；对于第二阵型，在除了第一阵型外的所有球员中选择；对于第三阵型，在除了第一阵型和第二阵型外的所有球员中选择；以此类推。

现在 $Q$ 个阵型都已经确定，而你需要知道的，是每个阵型的平均综合水平分别是多少。


## 说明/提示

对于 $30\%$ 数据，$K, D, M, F≤1000$，$Q≤10$；

对于 $100\%$ 数据，$1≤K, D, M, F≤10^5$，$0≤k_i, d_i, m_i, f_i≤10^8$，$1≤Q≤K$，$0≤A_i, B_i, C_i≤10$，$A_i+B_i+C_i=10$，$∑A_i≤D$，$∑B_i≤M$，$∑C_i≤F$

## 样例 #1

### 输入

```
3 10 12 4
76 60 87
78 84 84 84 81 82 72 51 77 57
85 84 62 87 88 64 81 90 80 66 88 85
65 83 63 79
2
4 5 1
4 4 2```

### 输出

```
85.64
78.00
```

# AI分析结果

### 综合分析与结论

这些题解主要围绕如何高效地选择每个阵型的最佳球员组合，核心思路是通过排序或优先队列（堆）来快速获取当前未选球员中的最高水平球员。大多数题解采用了贪心策略，即每次选择当前未选球员中能力值最高的球员，确保每个阵型的平均综合水平最大化。

#### 关键思路与技巧：
1. **排序与优先队列**：大多数题解使用排序或优先队列来维护球员的能力值，确保每次能快速获取当前未选球员中的最高水平球员。
2. **贪心策略**：通过每次选择当前最优的球员，确保每个阵型的平均综合水平最大化。
3. **前缀和优化**：部分题解通过维护前缀和来快速计算每个阵型所需的球员能力值总和，减少重复计算。
4. **数据结构选择**：优先队列（堆）的使用使得时间复杂度优化到O(n log n)，适合处理较大数据量。

#### 可拓展之处：
- **类似问题**：这类问题可以扩展到其他需要动态选择最优元素的场景，如任务调度、资源分配等。
- **数据结构**：优先队列（堆）在其他需要动态维护最大值或最小值的场景中也非常有用，如Dijkstra算法、最小生成树等。

### 推荐题目
1. **P1886 滑动窗口**：考察优先队列在滑动窗口中的应用。
2. **P1090 合并果子**：使用优先队列进行贪心策略的经典题目。
3. **P3378 堆**：练习手写堆的实现与应用。

### 所选高分题解

#### 题解1：作者：ezoixx118 (赞：21)
**星级：4.5**
**关键亮点**：
- 使用优先队列（堆）来维护球员的能力值，确保每次能快速获取当前未选球员中的最高水平球员。
- 代码简洁，逻辑清晰，适合初学者理解优先队列的使用。

**核心代码**：
```cpp
priority_queue <int> k,d,m,f; // 定义大根堆
int main() {
    // 读入并存入堆中
    for (int i=1;i<=K;i++) k.push(qr());
    for (int i=1;i<=D;i++) d.push(qr());
    for (int i=1;i<=M;i++) m.push(qr());
    for (int i=1;i<=F;i++) f.push(qr());
    // 处理每个阵型
    while(Q--) {
        int sum = 0;
        sum += k.top(); k.pop(); // 守门员
        for (int j=1;j<=A;j++) sum += d.top(), d.pop(); // 后卫
        for (int j=1;j<=B;j++) sum += m.top(), m.pop(); // 中场
        for (int j=1;j<=C;j++) sum += f.top(), f.pop(); // 前锋
        printf("%.2f\n", (double)sum / 11); // 计算平均值
    }
}
```

#### 题解2：作者：Chiaro (赞：9)
**星级：4.0**
**关键亮点**：
- 使用优先队列（堆）来维护球员的能力值，代码简洁，逻辑清晰。
- 通过优先队列的动态特性，确保每次能快速获取当前未选球员中的最高水平球员。

**核心代码**：
```cpp
priority_queue<int ,vector<int > >K,D,M,F; // 大根堆
int main() {
    // 读入并存入堆中
    for(int i=1;i<=k;i++) K.push(qr());
    for(int i=1;i<=d;i++) D.push(qr());
    for(int i=1;i<=m;i++) M.push(qr());
    for(int i=1;i<=f;i++) F.push(qr());
    // 处理每个阵型
    while(q--) {
        int sum = 0;
        sum += K.top(); K.pop(); // 守门员
        for(int j=1;j<=_d;j++) sum += D.top(), D.pop(); // 后卫
        for(int j=1;j<=_m;j++) sum += M.top(), M.pop(); // 中场
        for(int j=1;j<=_f;j++) sum += F.top(), F.pop(); // 前锋
        printf("%.2f\n", (double)sum / 11); // 计算平均值
    }
}
```

#### 题解3：作者：meyi (赞：0)
**星级：4.0**
**关键亮点**：
- 手写堆的实现，展示了优先队列的内部机制，适合对数据结构有深入理解的学习者。
- 通过手写堆，优化了时间复杂度，适合处理较大数据量。

**核心代码**：
```cpp
struct heap {
    int a[100001], l;
    void push(int k) {
        a[++l] = k;
        int s = l;
        while(s > 1) {
            int f = s >> 1;
            if(a[f] >= a[s]) break;
            swap(a[f], a[s]);
            s = f;
        }
    }
    void pop() {
        a[1] = a[l--];
        int f = 1;
        while(f << 1 <= l) {
            int s = f << 1;
            if(s < l && a[s] < a[s|1]) s |= 1;
            if(a[s] <= a[f]) break;
            swap(a[f], a[s]);
            f = s;
        }
    }
} d, f, k, m;
int main() {
    // 读入并存入堆中
    while(K--) k.push(qr());
    while(D--) d.push(qr());
    while(M--) m.push(qr());
    while(F--) f.push(qr());
    // 处理每个阵型
    while(Q--) {
        int sum = k.a[1]; k.pop(); // 守门员
        for(int j=1;j<=A;j++) sum += d.a[1], d.pop(); // 后卫
        for(int j=1;j<=B;j++) sum += m.a[1], m.pop(); // 中场
        for(int j=1;j<=C;j++) sum += f.a[1], f.pop(); // 前锋
        printf("%.2lf\n", sum / double(A + B + C + 1)); // 计算平均值
    }
}
```

### 通用建议与扩展思路
如果所有题解均未达到4星，建议：
- **深入理解数据结构**：优先队列（堆）是解决此类问题的关键，建议深入学习其实现与应用。
- **优化算法**：在处理大数据量时，优先队列的时间复杂度为O(n log n)，适合大多数场景，但可以考虑进一步优化。
- **多练习类似题目**：通过多练习类似题目，可以更好地掌握贪心策略与优先队列的应用。

---
处理用时：33.32秒
# 题目信息

# 「Wdsr-2.5」小小的埴轮兵团

## 题目背景

杖刀偶磨弓是埴轮兵团的首长。

作为埴轮兵长，训练埴轮兵团是很平常的事情。

## 题目描述

磨弓下达命令让埴轮们站成一行。不妨认为它们站在了一个数轴上，每个埴轮的位置就是它脚下数轴的数字。磨弓会告诉你，第 $i$ 个埴轮的位置为 $a_i$ 。**不保证** $\bm {a_i}$ **升序**。

数轴的长度是有限制的，具体的范围是 $[-k,k]$ 。也就是说，如果某个埴轮移出了这个范围，它就脱离了这个队列了，并且不会再次回到队列当中。

为了训练埴轮，磨弓给埴轮们下达了 $m$ 个指令，有以下 3 种：

- 指令 1：**全体埴轮**向数轴的正方向移动 $x$ 个单位长度。
- 指令 2：**全体埴轮**往数轴的反方向移动 $x$ 个单位长度。
- 指令 3：依次报数，统计目前队列里一共有多少个埴轮。

但是磨弓发现，埴轮兵团的大小实在是太大了，以至于执行这些操作变得非常缓慢。尽管如此，磨弓仍然希望你告诉她所有指令 3 的结果。

## 说明/提示

#### 样例 1 说明

一共有三个埴轮。初始时，它们的站位分别是 $[-1,1,2]$ 。

- 第一次操作后，所有埴轮向左移动 $3$ 格，位置变成了  $[\underline{\bm{-4}},-2,-1]$ 。第一个埴轮被移出了数轴。
- 第二次操作后，输出当前的埴轮数目，为 $2$ 个。
- 第三次操作后，所有埴轮向右移动 $5$ 格，位置变成了 $[3,\underline \bm4]$ ，第二个埴轮被移出了数轴。
- 第四次操作后，输出当前的埴轮数目，为 $1$ 个。

#### 样例 2, 3

见下发附件。

#### 数据规模与约定

- 对于 $30\%$ 的数据，$1 \leq n, m \leq 5\times 10^3$；
- 对于另外 $20\%$ 的数据，$1\le k\le 500$；
- 对于 $100\%$ 的数据，$1 \leq n, m \leq 3\times 10^5$，$1 \leq k, x \leq 2 \times 10^9$，$-k \le a_i \le k$ 。

## 样例 #1

### 输入

```
3 4 3
-1 1 2
2 3
3
1 5
3```

### 输出

```
2
1```

# AI分析结果

### 综合分析与结论

本题的核心在于高效处理大量移动操作，并实时统计仍在合法范围内的元素数量。大部分题解都采用了排序+双指针或队列的思路，通过维护一个偏移量来避免重复计算，从而优化时间复杂度。以下是各题解的主要思路和优化点：

1. **排序与双指针**：大多数题解首先对埴轮的位置进行排序，然后通过维护左右指针来动态调整合法区间的边界。这种方法的时间复杂度为 \(O(n \log n + m)\)，能够有效处理大规模数据。
2. **偏移量优化**：通过记录整体的移动量（偏移量），避免每次操作都遍历所有元素，从而将每次操作的时间复杂度降低到 \(O(1)\) 或 \(O(\log n)\)。
3. **队列与二分查找**：部分题解使用了双向队列或二分查找来进一步优化边界调整的过程，确保每次操作的高效性。

### 所选高星题解

#### 1. **题解作者：chlchl (5星)**
- **关键亮点**：使用 `deque` 实现双向队列，结合偏移量优化，代码简洁且高效。通过维护 `tot` 变量记录整体移动量，避免了重复计算。
- **个人心得**：作者强调了使用 `long long` 的重要性，避免数据溢出问题，并提醒读者注意输入数据的无序性。
- **核心代码**：
  ```cpp
  deque<ll> q;
  ll tot = 0;
  for (ll i = 1; i <= m; i++) {
      cin >> op;
      if (op == 3) cout << q.size() << endl;
      else if (op == 1) {
          cin >> x;
          tot += x;
          while (!q.empty() && q.back() + tot > k) q.pop_back();
      } else if (op == 2) {
          cin >> x;
          tot -= x;
          while (!q.empty() && q.front() + tot < -k) q.pop_front();
      }
  }
  ```

#### 2. **题解作者：Aw顿顿 (4.5星)**
- **关键亮点**：通过维护 `w` 变量记录整体移动量，结合双指针动态调整合法区间的边界，代码清晰且高效。
- **核心代码**：
  ```cpp
  int l = 1, r = n;
  ll w = 0;
  for (int i = 1; i <= m; i++) {
      cin >> op;
      if (op == 3) cout << r - l + 1 << endl;
      else if (op == 1) {
          cin >> x;
          w += x;
          while (a[r] + w > k && l <= r) r--;
      } else if (op == 2) {
          cin >> x;
          w -= x;
          while (a[l] + w < -k && l <= r) l++;
      }
  }
  ```

#### 3. **题解作者：Eason_AC (4星)**
- **关键亮点**：通过维护 `dis` 变量记录整体移动量，结合双指针动态调整合法区间的边界，代码简洁且高效。
- **核心代码**：
  ```cpp
  int l = 1, r = n;
  ll dis = 0;
  for (int i = 1; i <= m; i++) {
      cin >> op;
      if (op == 3) cout << r - l + 1 << endl;
      else if (op == 1) {
          cin >> x;
          dis += x;
          while (a[r] + dis > k && l <= r) r--;
      } else if (op == 2) {
          cin >> x;
          dis -= x;
          while (a[l] + dis < -k && l <= r) l++;
      }
  }
  ```

### 最优关键思路与技巧

1. **偏移量优化**：通过记录整体移动量，避免每次操作都遍历所有元素，极大提高了效率。
2. **双指针与队列**：通过维护左右指针或双向队列，动态调整合法区间的边界，确保每次操作的高效性。
3. **排序预处理**：对埴轮位置进行排序，确保后续操作的有序性，便于快速调整边界。

### 拓展思路与同类型题

1. **同类型题**：类似的问题可以扩展到其他需要动态调整区间边界的场景，如滑动窗口、区间统计等。
2. **推荐题目**：
   - [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
   - [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)
   - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得总结

- **数据溢出问题**：多位作者强调了使用 `long long` 的重要性，避免在计算过程中出现数据溢出问题。
- **输入数据无序性**：部分题解提醒读者注意输入数据的无序性，需先进行排序处理。
- **调试与优化**：通过维护偏移量和双指针，避免了暴力模拟的低效性，展示了算法优化的重要性。

---
处理用时：29.94秒
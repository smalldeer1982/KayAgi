# 题目信息

# [NOIP 1999 普及组] 回文数

## 题目描述

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。

又如：对于十进制数 $87$：

STEP1：$87+78=165$  
STEP2：$165+561=726$  
STEP3：$726+627=1353$   
STEP4：$1353+3531=4884$  

在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。

写一个程序，给定一个 $N$（$2 \le N \le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。

## 样例 #1

### 输入

```
10
87
```

### 输出

```
STEP=4
```

# AI分析结果



### 综合分析与结论
本题核心难点在于处理N进制高精度加法与回文判断。所有题解均采用模拟思路，差异主要体现在代码组织方式、进制处理技巧、回文判断优化等方面。关键挑战包括：16进制字符转换、高精度进位处理、反转相加的优化实现。

### 高评分题解推荐
#### 1. 作者：Haishu（★★★★★）
**核心亮点**：  
- 模块化编程思想（拆分为add/pd函数）  
- 字符与数值转换的精简处理（'0'-'9'和'A'-'F'统一处理）  
- 前导零的动态修正（while循环处理进位后的多余位数）

**关键代码**：
```cpp
inline void add() {
    for (int i=0;i<l;++i) d[l-i-1]=c[i]; // 反转存储
    l+=2; // 预分配进位空间
    for (int i=0;i<l;++i) {
        c[i]+=d[i];
        if (c[i]>=n) c[i+1]++,c[i]-=n; // N进制进位
    }
    while (!c[l-1]) --l; // 修正前导零
}
```

#### 2. 作者：hawa130（★★★★☆）
**核心亮点**：  
- 利用STL的reverse简化反转操作  
- 独立的高精度加法函数（支持任意进制）  
- 字符转换与数值运算分离的清晰结构

**关键代码**：
```cpp
string add(int k, string b) {
    reverse(b.begin(), b.end());
    int numa[maxN], numb[maxN], numc[maxN];
    // 统一转换为数值处理
    for(int i=0; i<len; i++) {
        if (isdigit(a[i])) numa[len-i] = a[i] - '0';
        else numa[len-i] = a[i] - 'A' + 10;
    }
    // ...N进制加法逻辑...
}
```

#### 3. 作者：Strong_Jelly（★★★★☆）
**核心亮点**：  
- 分步详细注释适合新手学习  
- 独立的反转/相加/判断模块  
- 数组索引从1开始的直观处理

**关键代码**：
```cpp
void add(int a[], int b[]) {
    for(int i=1; i<=l; i++) {
        a[i] += b[i];
        a[i+1] += a[i]/n; // N进制进位处理
        a[i] %= n;
    }
    if(a[l+1]>0) l++; // 处理最高位进位
}
```

### 关键思路与技巧总结
1. **进制统一处理**：将字符统一转换为数值处理（'A'-'F'转为10-15），运算完成后再转回字符  
2. **动态前导零处理**：通过长度变量动态调整有效位数，避免数组前部无效零的判断  
3. **反转优化**：使用reverse或倒序存储简化回文判断  
4. **模块化设计**：拆分add/pd函数提升代码可维护性

### 同类题目推荐
1. P1015 [NOIP1999 普及组] 回文数（本题加强版）
2. P1604 B进制星球（高精度加减法扩展）
3. P1096 Hanoi 双塔问题（高精度与规律结合）

### 题解心得很失总结
1. **进制转换陷阱**：多位作者强调16进制处理时需注意'A'-'F'转换（如`c[i]-'A'+10`）  
2. **进位边界处理**：Haishu在题解中指出要预分配l+2空间防止溢出  
3. **调试经验**：多位作者提到需测试最高位进位情况（如99+99=198的进位场景）  
4. **模块化重要性**：Haishu强调将功能拆分为独立函数可降低复杂度，便于调试

### 核心代码实现示例（Haishu版）
```cpp
// 判断回文
inline bool pd() {
    for (int i=0;i<l;++i)
        if(c[i]!=c[l-1-i]) return false;
    return true;
}

// 主逻辑
while (!pd()) {
    ++step;
    if(step>30) break;
    add(); // N进制加法
}
```

---
处理用时：56.32秒
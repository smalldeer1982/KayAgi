# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



### 题解综合分析
本题核心在于在无权图中高效统计最短路数量。各题解主要采用BFS、SPFA、Dijkstra三种思路，其中BFS因边权为1的特性成为最优解。关键技巧在于分层遍历时动态更新计数：当发现更短路径时重置计数，路径长度相同时累加。

### 精选题解（评分≥4星）

#### 1. 作者：岸芷汀兰（★★★★☆）
**亮点**：
- 利用BFS分层特性，首次访问即确定最短路，逻辑清晰
- 用vector邻接表存储，便于处理大规模数据
- 严格区分首次访问与重复访问的逻辑，避免冗余计算

**核心代码**：
```cpp
void bfs() {
    queue<Node> q; 
    q.push(make(1, 0));
    ans[1] = 1;
    while (q.size()) {
        int u = q.front().node;
        q.pop();
        for (int v : linker[u]) {
            if (!vis[v]) { // 首次访问
                ans[v] = ans[u];
                q.push(v); 
                vis[v] = 1;
            } else if (dis[v] == dis[u] + 1) { // 重复访问但路径等长
                ans[v] += ans[u];
            }
        }
    }
}
```

#### 2. 作者：King丨帝御威（★★★★☆）
**亮点**：
- Dijkstra堆优化版本，适用于带权图扩展
- 明确处理自环和重边，代码鲁棒性强
- 使用pair存储节点和距离，提升堆操作效率

**核心思路**：
```cpp
priority_queue<pair<int,int>> q;
while (!q.empty()) {
    int u = q.top().second; 
    q.pop();
    for (int v : adj[u]) {
        if (dis[v] > dis[u] + 1) { // 更短路径
            dis[v] = dis[u] + 1;
            ans[v] = ans[u];
            q.push({-dis[v], v}); // 小根堆技巧
        } else if (dis[v] == dis[u] + 1) {
            ans[v] = (ans[v] + ans[u]) % mod;
        }
    }
}
```

#### 3. 作者：XZYQvQ（★★★☆☆）
**亮点**：
- 两阶段处理：先求最短路，再反向DFS统计
- 避免SPFA计数问题，通用性更强
- 记忆化搜索减少重复计算

**关键片段**：
```cpp
int dfs(int u) {
    if (ans[u]) return ans[u];
    for (int v : pre[u]) // pre存储最短路径前驱
        ans[u] = (ans[u] + dfs(v)) % MOD;
    return ans[u];
}
```

### 最优思路总结
**关键技巧**：
1. **BFS分层遍历**：利用无权图特性，首次访问即确定最短路，时间复杂度O(N+M)
2. **动态计数更新**：分首次访问（直接继承）和等长路径（累加）两种情况处理
3. **邻接表优化**：使用vector或链式前向星存储，适应大规模边数

### 举一反三
- **同类型题**：P1608（带权最短路计数）、P2296（最短路存在性判断）、P2837（多起点最短路）
- **扩展场景**：若边权不全为1，需改用Dijkstra/SPFA，在松弛时同步更新计数

### 推荐题目
1. [P1608 路径统计](https://www.luogu.com.cn/problem/P1608)（带权最短路计数）
2. [P2296 寻找道路](https://www.luogu.com.cn/problem/P2296)（最短路存在性+条件过滤）
3. [P2837 晚餐队列安排](https://www.luogu.com.cn/problem/P2837)（多维度最短路）

---

**注**：BFS解法在本题中最为高效，建议优先掌握。若遇到带权图需改用Dijkstra/SPFA，但核心计数逻辑（根据松弛操作更新）保持一致。

---
处理用时：68.40秒
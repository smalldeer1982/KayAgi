# 题目信息

# 打保龄球

## 题目描述

打保龄球是用一个滚球去打击十个站立的柱，将柱击倒。一局分十轮，每轮可滚球一次或多次，以击倒的柱数为依据计分。一局得分为十轮得分之和，而每轮的得分不仅与本轮滚球情况有关，还可能与后续一两轮的滚球情况有关。即某轮某次滚球击倒的柱数不仅要计入本轮得分，还可能会计入前一两轮得分。具体的滚球击柱规则和计分方法如下：

1. 若某一轮的第一次滚球就击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加两次滚球，不妨称其为第十一轮和第十二轮，并不是所有的情况都需要滚第十一轮和第十二轮球）。该轮得分为本次击倒柱数 $10$ 与以后两次滚球所击倒柱数之和。

2. 若某一轮的第一次滚球未击倒十个柱，则可对剩下未倒的柱再滚球一次。如果这两次滚球击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加一次滚球），该轮得分为这两次共击倒柱数 $10$ 与以后一次滚球所击倒柱数之和。

3. 若某一轮两次滚球未击倒全部十个柱，则本轮不再继续滚球，该轮得分为这两次滚球击倒的柱数之和。   

总之，若―轮中一次滚球或两次滚球击倒十个柱，则本轮得分是本轮首次滚球开始的连续三次滚球击倒柱数之和（其中有一次或两次不是本轮滚球）。若一轮内二次滚球击倒柱数不足十个，则本轮得分即为这两次击倒柱数之和。下面以实例说明如下(字符 `/` 表示击倒当前球道上的全部的柱)：

| 轮 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| 击球情况  |  /  |  /  |  /  |  72 |  9/ |  81  | 8/  |  / |   9/  |  /  |  8/ |
| 各轮得分 |  30  | 27  | 19 |  9   |18   | 9  | 20  | 20 |  20 |  20|
|累计总分 |  30  | 57  |76 |  85|  103 |  112 | 132  |152 | 172 | 192|

现在请你编写一个保龄球实时计分程序，用来计算和显示某轮结束后的得分情况。若某轮的得分暂时无法算出，则**不显示**该轮得分（不输出）。


## 样例 #1

### 输入

```
/ / / 72 9/ 81 8/ / 9/ / 8/```

### 输出

```
30 27 19 9 18 9 20 20 20 20 
30 57 76 85 103 112 132 152 172 192```

# AI分析结果



### 综合分析与结论
各题解均采用模拟思路，核心难点在于正确处理三种得分规则与暂不可算逻辑。优秀解法需具备以下特征：
1. 输入处理：正确处理连续空格与'/'符号的转换
2.状态跟踪：维护当前轮次、剩余瓶数、后续球数依赖关系
3.边界处理：第10轮的特殊情况与数据不足时的及时截断

### 优质题解推荐 (评分≥4星)

#### 1. 袁宇轩（★★★★☆）
**关键亮点**：
- 使用`st`变量跟踪每轮起始位置，避免复杂的索引计算
- 通过`rest`和`flag`清晰区分三种得分情况
- 代码简洁且可读性高（仅50行核心逻辑）

**核心代码思想**：
```cpp
int st=1; // 当前轮的起始滚球位置
for (int i=1;i<=10;i++) {
    int rest=10, flag=1;
    for (int j=st; j<=st+2; j++) { // 处理最多三次滚球
        if (j > n) { sum[i]=-1; break; }
        // 计算击倒数并更新状态
    }
    // 更新st位置并处理无法计算的情况
}
```

#### 2. 深海鱼的眼泪（★★★★☆）
**关键亮点**：
- 使用二维数组`df`存储每轮两次滚球值
- 通过`y[][]`标记有效数据避免越界访问
- 详细处理了击倒数为0的特殊情况

**调试经验**：
> "击倒柱数可能为0！！！就是这个害我多次过不了" —— 强调特殊值的处理重要性

#### 3. 2344b（★★★☆☆）
**可取之处**：
- 创新使用`Time[]`数组记录需要后续球数的轮次
- 实时更新前序轮的补充分数
- 代码结构紧凑但可读性稍差

### 最优技巧总结
1. **输入预处理**：将'/'转换为实际击倒数（如X_WT的`work()`函数）
2. **状态标记法**：用辅助数组标记每轮是否完成（如深海鱼的`y[][]`）
3. **滚动计算**：袁宇轩解法中通过`st`指针跟踪轮次起始，避免存储所有球数据

### 拓展建议
同类问题可练习：
1. 多阶段状态依赖：P1042（乒乓球比赛规则）
2. 复杂输入解析：P1563（玩具谜题方向计算）
3. 特殊规则模拟：P1518（塔姆沃斯牛移动规则）

### 推荐练习题
1. P1042 乒乓球（复杂规则模拟）
2. P2670 扫雷游戏（状态依赖计算）
3. P1518 两只塔姆沃斯牛（循环状态跟踪）

### 关键代码片段
袁宇轩解法核心逻辑：
```cpp
// 输入处理
while (cin>>a[++n]);
// 得分计算
for (int j=st; j<=st+2; j++) {
    if (rest == 0) { rest=10; flag=0; }
    if (j == st+2 && flag) break;
    if (a[j] == '/') sum[i] += rest, rest=0;
    else sum[i] += a[j]-'0', rest -= a[j]-'0';
}
```

---
处理用时：45.59秒
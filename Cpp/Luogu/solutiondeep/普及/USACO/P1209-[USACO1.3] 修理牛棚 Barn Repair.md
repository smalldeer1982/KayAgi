# 题目信息

# [USACO1.3] 修理牛棚 Barn Repair

## 题目描述

在一个月黑风高的暴风雨夜，Farmer John 的牛棚的屋顶、门被吹飞了 好在许多牛正在度假，所以牛棚没有住满。   

牛棚一个紧挨着另一个被排成一行，牛就住在里面过夜。有些牛棚里有牛，有些没有。 所有的牛棚有相同的宽度。   

自门遗失以后，Farmer John 必须尽快在牛棚之前竖立起新的木板。他的新木材供应商将会供应他任何他想要的长度，但是吝啬的供应商只能提供有限数目的木板。 Farmer John 想将他购买的木板总长度减到最少。

给出 $m,s,c$，表示木板最大的数目、牛棚的总数、牛的总数；以及每头牛所在牛棚的编号，请算出拦住所有有牛的牛棚所需木板的最小总长度。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le m \le 50$，$1\le c \le s \le 200$。 

USACO Training Section 1.3


## 样例 #1

### 输入

```
4 50 18
3 
4 
6 
8 
14
15 
16 
17 
21
25 
26 
27 
30 
31 
40 
41 
42 
43
```

### 输出

```
25
```

# AI分析结果



### 综合分析与结论
本题核心是贪心策略：将牛棚排序后，计算相邻有牛棚的间隔，用最大间隔断开以最小化总长度。动态规划解法虽可行但复杂度较高，贪心更优。关键点包括处理输入无序、特判木板数过多的情况，以及正确计算间隙排序。

---

### 精选题解分析

#### 1. Starlight_Glimmer（★★★★★）
**核心思路**  
- 贪心策略：初始覆盖全部牛棚，断开最大的m-1个间隔
- 代码亮点：特判木板数>牛数直接返回，两次排序简洁高效
- 关键代码：
```cpp
sort(a+1,a+c+1);
ans = a[c] - a[1] + 1; // 初始总长度
sort(C+1,C+c,cmp); // 间隔降序
for(int i=1;i<=m-1;i++) ans = ans - C[i] + 1; // 断开大间隔
```

#### 2. 以墨（★★★★☆）
**核心思路**  
- 动态规划：定义`f[i][j]`为前i个牛棚用j块板的最小长度
- 状态转移方程：
  ```cpp
  f[j] = min(f[j] + a[i] - a[i-1], f[j-1] + 1); // 延伸或新增木板
  ```
- 优化点：滚动数组节省空间，逆序遍历避免覆盖

#### 3. junyuge（★★★★☆）
**核心思路**  
- 同贪心策略，代码精简
- 关键处理：计算间隙时减1避免重复覆盖
  ```cpp
  for(int i=1;i<=c-1;i++) b[i] = a[i+1] - a[i] - 1; // 正确间隙计算
  ```

---

### 最优技巧总结
1. **贪心策略**：排序后取最大间隔断开，时间复杂度O(c log c)。
2. **特判优化**：当木板数≥牛数时直接返回牛的数量。
3. **间隙处理**：相邻牛棚间距-1避免重复计算覆盖长度。

---

### 拓展与相似题目
1. **P1230 智力大冲浪**（贪心选择截止时间最近的任务）
2. **P1094 纪念品分组**（排序后双指针配对）
3. **P2240 部分背包问题**（按价值密度贪心）

---

### 关键代码实现（贪心版）
```cpp
#include <algorithm>
using namespace std;
int main() {
    int m, s, c, a[205], gaps[205];
    scanf("%d%d%d", &m, &s, &c);
    for (int i = 0; i < c; i++) scanf("%d", &a[i]);
    sort(a, a + c);
    int total = a[c-1] - a[0] + 1;
    for (int i = 1; i < c; i++) gaps[i-1] = a[i] - a[i-1] - 1;
    sort(gaps, gaps + c-1, greater<int>());
    for (int i = 0; i < m-1 && i < c-1; i++) total -= gaps[i];
    printf("%d", total);
    return 0;
}
```

---
处理用时：60.07秒
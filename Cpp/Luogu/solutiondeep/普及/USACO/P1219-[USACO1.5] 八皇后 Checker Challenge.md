# 题目信息

# [USACO1.5] 八皇后 Checker Challenge

## 题目描述

一个如下的 $6 \times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。

![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)

上面的布局可以用序列 $2\ 4\ 6\ 1\ 3\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：

行号 $1\ 2\ 3\ 4\ 5\ 6$

列号 $2\ 4\ 6\ 1\ 3\ 5$

这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  
并把它们以上面的序列方法输出，解按字典顺序排列。  
请输出前 $3$ 个解。最后一行是解的总个数。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$6 \le n \le 13$。

题目翻译来自NOCOW。

USACO Training Section 1.5


## 样例 #1

### 输入

```
6
```

### 输出

```
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
```

# AI分析结果



### 综合分析与结论
本题解核心是使用回溯法解决八皇后问题，所有解法均围绕如何高效标记皇后冲突展开。最优解法采用三个标记数组（列、左斜线、右斜线）实现O(1)冲突判断，时间复杂度为O(n!)，空间O(n)。位运算通过压缩状态进一步优化，但实现复杂度较高。

---

### 精选题解（评分≥4星）

1. **ybb756032937的题解（★★★★★）**  
   **关键亮点**：  
   - 使用三个数组分别标记列、左斜线（行列和）、右斜线（行列差），逻辑清晰易懂。  
   - 代码结构简洁，回溯与标记逻辑分离，适合新手学习。  
   **核心代码**：  
   ```cpp
   void queen(int i) {
       if (i > n) { print(); return; }
       for (int j=1; j<=n; j++) {
           if (!b[j] && !c[i+j] && !d[i-j+n]) {
               a[i] = j; // 记录位置
               b[j] = c[i+j] = d[i-j+n] = 1; // 标记冲突
               queen(i+1);
               b[j] = c[i+j] = d[i-j+n] = 0; // 回溯
           }
       }
   }
   ```

2. **XG_Zepto的题解（★★★★☆）**  
   **关键亮点**：  
   - 合并标记数组`check`，用单循环处理所有冲突判断，代码紧凑。  
   - 变量命名直观（`line`表示列，`i+j`和`i-j+n`处理斜线）。  
   **核心代码**：  
   ```cpp
   void eq(int line) {
       if (line > n) { sum++; return; }
       for (int i=1; i<=n; i++) {
           if (!check[0][i] && !check[1][line+i] && !check[2][line-i+n]) {
               ans[line] = i;
               check[0][i] = check[1][line+i] = check[2][line-i+n] = 1;
               eq(line+1);
               check[0][i] = check[1][line+i] = check[2][line-i+n] = 0;
           }
       }
   }
   ```

3. **Captain_Von的位运算题解（★★★★☆）**  
   **关键亮点**：  
   - 使用位运算压缩状态，减少空间占用。  
   - 通过`ld`、`rd`变量动态计算对角线冲突，适合高阶优化。  
   **核心代码**：  
   ```cpp
   void dfs(int row, int ld, int rd) {
       if (row == upperlim) { sum++; return; }
       int pos = upperlim & ~(row | ld | rd);
       while (pos) {
           int p = pos & -pos; // 取最低位的1
           pos -= p;
           dfs(row | p, (ld | p) << 1, (rd | p) >> 1);
       }
   }
   ```

---

### 关键技巧总结
1. **对角线标记**：左斜线用`行+列`，右斜线用`行-列+n`避免负数。  
2. **位运算优化**：将棋盘状态压缩为整数，通过位操作快速判断冲突。  
3. **回溯模板**：逐行放置皇后，每次递归后需恢复标记状态。  

---

### 相似题目推荐
1. **P1074 靶形数独**（位运算优化搜索）  
2. **P1092 虫食算**（回溯剪枝与列标记）  
3. **P2329 栅栏**（状态压缩与剪枝）

---
处理用时：66.78秒
# 题目信息

# [USACO2.2] 集合 Subset Sums

## 题目描述

对于从 $1\sim n$ 的连续整数集合，能划分成两个子集合，且保证每个集合的数字和是相等的。举个例子，如果 $n=3$，对于 $\{1,2,3\}$ 能划分成两个子集合，每个子集合的所有数字和是相等的：

$\{3\}$ 和 $\{1,2\}$ 是唯一一种分法（交换集合位置被认为是同一种划分方案，因此不会增加划分方案总数）  
如果 $n=7$，有四种方法能划分集合 $\{1,2,3,4,5,6,7 \}$，每一种分法的子集合各数字和是相等的:

$\{1,6,7\}$ 和 $\{2,3,4,5\}$  
$\{2,5,7\}$ 和 $\{1,3,4,6\}$  
$\{3,4,7\}$ 和 $\{1,2,5,6\}$  
$\{1,2,4,7\}$ 和 $\{3,5,6\}$  

给出 $n$，你的程序应该输出划分方案总数。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 39$。

翻译来自NOCOW

USACO 2.2


## 样例 #1

### 输入

```
7
```

### 输出

```
4
```

# AI分析结果



### 综合分析与结论
本题要求将 1~n 的集合划分为两个和相等的子集。核心解法是转化为求总和一半的背包问题，或使用折半搜索降低复杂度。关键点在于总和必须为偶数，且最终结果需除以 2 避免重复计数。动态规划（01背包变体）是主流解法，滚动数组优化空间后效率极高。

---

### 精选题解（评分≥4星）

#### 1. [作者：courage] ⭐⭐⭐⭐⭐
**关键亮点**  
- 使用一维滚动数组优化空间至 O(n²)  
- 清晰的状态转移逻辑与输出处理  
- 代码简洁高效（仅 15 行核心逻辑）

**核心代码**  
```cpp
long long f[400] = {1}; // 初始状态
for (int i=1; i<=n; i++)
    for (int j=s; j>=i; j--)
        f[j] += f[j-i];
printf("%lld", f[s]/2); // 关键除以2操作
```

#### 2. [作者：Makasukaka] ⭐⭐⭐⭐⭐  
**关键亮点**  
- 采用折半搜索（Meet-in-the-middle）算法  
- 时间复杂度 O(2^(n/2))，适合更大数据范围  
- 巧妙分割集合并合并结果  

**核心思想**  
```cpp
// 前半部分预处理和频次
for (前半子集枚举) b[cur]++; 
// 后半部分查询补集
ans += b[target - cur]; 
printf("%lld\n", ans/2); // 消除镜像重复
```

#### 3. [作者：CalcMaster] ⭐⭐⭐⭐  
**关键亮点**  
- 详细注释解释状态转移过程  
- 强调初始化与边界条件处理  
- 完整展示从二维到一维的优化思路  

**调试心得**  
> "n=39 时方案数会溢出 int，必须用 long long" —— 强调数据类型选择的重要性

---

### 最优技巧总结
1. **背包状态压缩**：将二维 DP 压缩为一维，倒序更新避免状态污染  
2. **问题转化思维**：将划分问题转化为求子集和等于总和一半  
3. **镜像去重**：最终结果除以 2 消除对称解  
4. **折半搜索**：对半拆分集合，分别枚举后合并结果，降低指数复杂度  

---

### 拓展练习
1. **P1060 开心的金明**（01背包基础）  
2. **P3067 Balanced Cow Subsets**（折半搜索经典题）  
3. **P2392 背包问题九讲练习**（多重背包变体）  

---

### 调试经验摘录
- **递归陷阱**：直接深搜会超时（n=20 时 2^20≈百万级，n=30 则十亿级）  
- **溢出问题**：多个题解强调使用 `long long` 存储方案数  
- **对称重复**：未除以 2 导致错误（如某题解因此 WA 一个测试点）  

这些经验突显了时间复杂度估算、数据范围分析和边界条件验证的重要性。

---
处理用时：97.15秒
# 题目信息

# [USACO2.4] 穿越栅栏 Overfencing

## 题目描述

Farmer John 在外面的田野上搭建了一个巨大的用栅栏围成的迷宫。幸运的是，他在迷宫的边界上留出了两段栅栏作为迷宫的出口。更幸运的是，他所建造的迷宫是一个“完美的”迷宫：即你能从迷宫中的任意一点找到一条走出迷宫的路。

给定迷宫的宽度 $W$（$1 \leq W \leq 38$）及高度 $H$（$1 \leq H \leq 100$）。$2 \times H+1$ 行，每行 $2 \times W+1$ 的字符以下面给出的格式表示一个迷宫。然后计算从迷宫中最“糟糕”的那一个点走出迷宫所需的步数（即使从这一点以最优的方式走向最靠近的出口，它仍然需要最多的步数）。

当然了，牛们只会水平或垂直地在 X 或 Y 轴上移动，他们从来不走对角线。每移动到一个新的方格算作一步（包括移出迷宫的那一步）。

这是一个 $W=5,H=3$ 的迷宫：

```plain
+-+-+-+-+-+
|         |
+-+ +-+ + +
|     | | |
+ +-+-+ + +
| |     |  
+-+ +-+-+-+
```
如上图的例子，栅栏的柱子只出现在奇数行或奇数列。每个迷宫只有两个出口。

## 说明/提示

翻译来自NOCOW

USACO 2.4


## 样例 #1

### 输入

```
5 3
+-+-+-+-+-+
|         |
+-+ +-+ + +
|     | | |
+ +-+-+ + +
| |     |  
+-+ +-+-+-+```

### 输出

```
9
```

# AI分析结果



### 综合分析与结论
本题核心在于迷宫建模与多源BFS优化。题解普遍采用反向BFS思路：从两个出口出发，记录各点到出口的最短距离，取每个点的两出口距离最小值，最终求最大值。输入处理（换行、边界判断）是主要难点，移动步长转换（字符画坐标与实际格子的映射）是关键技巧。

---

### 高星题解推荐

#### 1. 作者：奔波儿霸（★★★★☆）
**关键亮点**：
- 双向BFS维护最小值：从两个出口分别BFS，用`dis[x][y]`记录最小值，避免重复计算。
- 栅栏穿透判断：处理移动时需验证中间栅栏是否为空格。
- 输入换行处理：使用`gets`跳过首行回车，解决输入格式问题。

**个人心得**：
> "调了俩小时...四个不易发现的坑点：出口移动逻辑、中间栅栏校验、输入换行陷阱。"

**核心代码**：
```cpp
void BFS(int num) {
    // 处理出口移动逻辑：第一步只能移动一格，后续移动两格
    for(int i=0; i<4; i++) {
        int zx = rx[i]+x, zy = ry[i]+y;
        if (从出口出发时) 移动一格并验证；
        else 移动两格且中间栅栏为空格；
    }
}
```

#### 2. 作者：QQ红包（★★★★☆）
**关键亮点**：
- 出口预处理：将出口相邻的格子作为起点，统一移动步长。
- 步数转换优化：每次移动两格视为一步，最终结果`(step+1)/2`。

**核心思路**：
```cpp
// 将出口外第一格作为起点入队
if (map[i][j]为边界出口) {
    que.push({i±1, j±1}); // 相邻实际格子
}
// BFS时每次移动两格
for (方向) {
    xx = x + dx[i]*2; 
    if (中间栅栏为空格) 更新步数；
}
```

#### 3. HighPerformanceRobot（★★★★☆）
**关键亮点**：
- 输入鲁棒性：使用`cin.getline`逐行读取，避免换行符干扰。
- 状态压缩：用`vis`数组避免重复访问，`f[x][y]`记录最小步数。

**调试技巧**：
> "输入时多了一个`getchar()`过滤双换行符，否则第一行会读空。"

---

### 关键思路总结
1. **反向多源BFS**：从出口出发，避免对每个起点单独BFS，复杂度降为O(2*(H*W))。
2. **坐标映射**：字符画中奇数行/列为有效格子，每次移动两格对应实际一步。
3. **输入处理**：使用`getline`或过滤换行符，确保矩阵完整读取。

---

### 拓展与举一反三
1. **类似题目推荐**：
   - P1131 时态同步（多源BFS）
   - P1825 [USACO11OPEN]玉米田迷宫（复杂路径建模）
   - P3958 奶酪（三维空间BFS）

2. **算法套路**：
   - **多源最短路径**：适用于多个起点求最优解的场景（如火灾蔓延、病毒传播）。
   - **坐标压缩/映射**：处理非常规定格问题时（如棋盘、像素图），建立逻辑坐标与实际存储的映射关系。

---

### 调试经验摘录
- **输入陷阱**：Linux/Windows换行符差异，需用`getline`或多次`getchar`过滤。
- **边界验证**：出口可能在矩阵四边任意位置，需循环检查所有边界点。
- **步长转换**：字符画中移动两格对应实际一步，终点需额外处理。

---
处理用时：57.59秒
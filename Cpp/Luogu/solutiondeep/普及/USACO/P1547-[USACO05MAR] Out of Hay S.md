# 题目信息

# [USACO05MAR] Out of Hay S

## 题目描述

Bessie 计划调查 $N$（$2 \leq N \leq 2\,000$）个农场的干草情况，它从 $1$ 号农场出发。农场之间总共有 $M$（$1 \leq M \leq 10^4$）条双向道路，所有道路的总长度不超过 $10^9$。有些农场之间存在着多条道路，所有的农场之间都是连通的。

Bessie 希望计算出该图中最小生成树中的最长边的长度。


## 样例 #1

### 输入

```
3 3
1 2 23
2 3 1000
1 3 43```

### 输出

```
43```

# AI分析结果



### 综合分析与结论
本题核心是求最小生成树中的最长边，所有题解均围绕 Kruskal 或 Prim 算法展开。Kruskal 算法因其直接按边权排序的特性，更易于求解最长边，成为主流解法。关键优化点在于排序后最后加入的边即为最大值。Prim 算法虽可行，但需额外遍历边找最大值，效率较低。

### 高星题解推荐
#### 1. 题解作者：Growl、 (5星)
**关键亮点**：  
- 清晰解释 Kruskal 算法原理及并查集实现细节  
- 代码结构简洁，包含快读优化和路径压缩  
- 明确指出最长边即为最后加入的边（或每次取 max）  
**核心代码**：
```cpp
void kruskal() {
    for(int i=1; i<=m; i++) {
        int l = find(edge[i].fir), r = find(edge[i].sec);
        if(l == r) continue;
        fa[l] = r;
        k = edge[i].data; // 直接记录最后一条边
        if(++tot == n-1) break;
    }
}
```

#### 2. 题解作者：Eason_AC (5星)
**关键亮点**：  
- 直接对比模板题改动点（求和 → 取 max），便于理解  
- 代码简洁规范，结构体排序逻辑清晰  
**核心代码**：
```cpp
for(int i=0; i<line; ++i) {
    if(find(a[i].x) != find(a[i].y)) {
        ans = max(ans, a[i].w); // 直接取最大值
        merge_sets(a[i].x, a[i].y);
    }
}
```

#### 3. 题解作者：Ajwallet (4星)
**关键亮点**：  
- 分享从 Prim 错误转向 Kruskal 的调试经历，强调算法适用场景  
- 提供两种算法对比代码，增强理解  
**个人心得**：  
> "一开始用 Prim 错了，发现题目本质是求最长边，改用 Kruskal 后直接排序取末尾即可，选择算法要贴合问题特点。"

### 最优关键思路总结
1. **Kruskal 贪心排序**：将边按权值排序后，最后加入的边即为最长边（或维护 max 变量）。
2. **并查集路径压缩**：高效判断连通性，时间复杂度接近 O(α(n))。
3. **避免冗余操作**：Kruskal 在排序后只需遍历至 n-1 条边即可终止。

### 拓展与推荐题目
1. **同类型题**：  
   - [P2330「SCOI2005」繁忙的都市](https://www.luogu.com.cn/problem/P2330)（同求最长边）  
   - [P3366 最小生成树模板](https://www.luogu.com.cn/problem/P3366)（基础练习）  
   - [P1991 无线通讯网](https://www.luogu.com.cn/problem/P1991)（Kruskal 变形）

2. **进阶技巧**：  
   - 次小生成树：通过替换最长边或添加新边求解  
   - 动态最小生成树：结合 Link-Cut Tree 维护连通性

---

**注**：若需进一步代码优化，可参考 Growl、的快读实现或 Ajwallet 的结构体排序技巧。

---
处理用时：47.47秒
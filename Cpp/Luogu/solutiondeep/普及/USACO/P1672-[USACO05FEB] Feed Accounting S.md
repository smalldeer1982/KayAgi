# 题目信息

# [USACO05FEB] Feed Accounting S

## 题目描述

约翰想知道上一船饲料是什么时候运到的。在饲料运到之前，他的牛正好把仓库里原来的饲料全吃光了。他收到运来的 $F1(1\le F1\le 10^6)$ 千克饲料。遗憾的是，他已经不记得这是哪一天的事情了。到第 $D(1\le D\le 2\times 10^3)$ 天为止，仓库里还剩下 $F2(1\le F2\le F1)$ 千克饲料。

约翰养了 $C(1\le C\le 100)$ 头牛，每头牛每天都吃掉恰好 $1$ 千克饲料。由于不同的原因，牛们从某一天开始在仓库吃饲料，又在某一天离开仓库，所以不同的两天可能会有差距很大的饲料消耗量。每头牛在来的那天和离开的那天都在仓库吃饲料。给出今天的日期 $D$，写一个程序，判断饲料**最近**一次运到是在什么时候。今天牛们已经吃过饲料了，并且饲料运到的那天牛们还没有吃过饲料。

**如果最终的答案有多个可能，请输出最大的（即，最近的）那一个。**

## 说明/提示

### 样例解释

上一次运来了 $14$ 千克饲料，现在饲料还剩下 $4$ 千克。最近 $10$ 天里，有 $3$ 头牛来吃过饲料。

约翰在第 $6$ 天收到 $14$ 千克饲料，当天吃掉 $2$ 千克，第 $7$ 天吃掉 $2$ 千克，第 $8$ 天吃掉 $3$ 千克，第 $9$ 天吃掉 $2$ 千克，第 $10$ 天吃掉 $1$ 千克，正好还剩 $4$ 千克。

### 数据规模

$1\le F2\le F1\le 10^6$，$1\le D\le 2\times 10^3$，$1\le C\le 100$。

## 样例 #1

### 输入

```
3 14 4 10
1 9
5 8
8 12```

### 输出

```
6```

# AI分析结果



### 综合分析与结论

本题需要确定最近一次饲料运输的日期，核心在于计算从运输日期到第D天的总消耗量是否等于F1-F2。各题解主要采用差分法或二分法：

1. **差分法**：通过预处理每天饲料消耗量，从D天倒推累计消耗，找到满足条件的最晚日期。时间复杂度O(C + D)，高效且直观。
2. **二分法**：通过二分搜索可能的运输日期，检验每个中间值的消耗量是否满足条件。时间复杂度O(C log D)，适用于更大数据范围。

### 高星题解推荐

#### 1. 作者：Chengjintian （5星）
**关键亮点**：
- 详细解释差分原理，逻辑清晰，适合初学者理解。
- 代码结构规范，处理差分数组后直接倒推求解，效率高。
- 处理输入区间时直接应用差分，无需额外优化。

**核心代码**：
```cpp
for(int i=1;i<=C;i++){
    cin>>l>>r;
    c[l]++;        // 差分区间起点
    c[r+1]--;      // 差分区间终点
}
for(int i=1;i<=D;i++) a[i]=a[i-1]+c[i]; // 前缀和计算每日消耗
// 倒推计算总消耗
for(int i=D;i>=1;i--){
    f2 += a[i];
    if(f2 == f1) {
        cout<<i;
        return 0;
    }
}
```

#### 2. 作者：2024sdhkdj （4星）
**关键亮点**：
- 采用二分法，思路独特，展示不同解法可能性。
- 正确实现check函数，处理牛的贡献天数边界条件。

**核心代码**：
```cpp
bool check(int x){
    int total = 0;
    for(int i=1; i<=c; i++){
        // 计算每头牛在[x, d]区间内的天数
        int start = max(x, ate[i]);
        int end = min(d, Left[i]);
        if(start > end) continue;
        total += end - start + 1;
    }
    return total >= (f1 - f2);
}
// 二分主循环
while(l <= r){
    mid = (l + r)/2;
    if(check(mid)){
        ans = mid;
        l = mid + 1;
    } else r = mid -1;
}
```

#### 3. 作者：technopolis_2085 （4星）
**关键亮点**：
- 代码简洁，直接应用差分和倒推，无冗余步骤。
- 处理数据范围严谨，数组大小合理。

**核心代码**：
```cpp
for(int i=1; i<=n; i++){
    scanf("%d%d",&l,&r);
    sum[l]++; sum[r+1]--; // 差分处理
}
for(int i=1; i<=d; i++) sum[i] += sum[i-1]; // 计算每日消耗
int total = f1 - f2;
for(int i=d; i>=1; i--){
    total -= sum[i];
    if(total == 0){
        printf("%d",i);
        return 0;
    }
}
```

### 最优思路总结
**差分法**是本题最优解：
1. **差分数组**快速处理区间修改，计算每日消耗量。
2. **倒序累加**：从D天倒推，总消耗达到F1-F2时即为答案。

### 举一反三
- **同类题目**：
  - [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)：差分统计区间覆盖次数。
  - [P2367 语文成绩](https://www.luogu.com.cn/problem/P2367)：差分应用与最小值统计。
  - [P1083 借教室](https://www.luogu.com.cn/problem/P1083)：二分答案结合差分检验。

### 个人心得摘录
- **差分边界处理**：需注意区间终点是否超过D，避免数组越界。（WhxStar2024题解）
- **逆向思维**：倒推法直接累计消耗，无需额外存储总消耗数组。（Chengjintian题解）

---
处理用时：163.81秒
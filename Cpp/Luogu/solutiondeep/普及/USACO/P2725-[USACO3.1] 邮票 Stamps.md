# 题目信息

# [USACO3.1] 邮票 Stamps

## 题目描述

给一组 $n$ 枚邮票的面值集合和一个上限 $k$ —— 表示信封上能够贴 $k$ 张邮票。请求出最大的正整数 $m$，满足 $1$ 到 $m$ 的面值都可以用不超过 $k$ 张邮票表示出来。



## 说明/提示

#### 样例输入输出 1 解释

有 $1$ 分和 $3$ 分的邮票；你最多可以贴 $5$ 张邮票。很容易贴出 $1$ 到 $5$ 分的邮资（用 $1$ 分邮票贴就行了），接下来的邮资也不难：


- $6 = 3 + 3$。
- $7 = 3 + 3 + 1$。
- $8 = 3 + 3 + 1 + 1 $。
- $9 = 3 + 3 + 3 $。
- $10 = 3 + 3 + 3 + 1 $。
- $11 = 3 + 3 + 3 + 1 + 1 $。
- $12 = 3 + 3 + 3 + 3 $。
- $13 = 3 + 3 + 3 + 3 + 1$。


然而，使用 $5$ 枚 $1$ 分或者 $3$ 分的邮票根本不可能贴出 $14$ 分的邮资。因此，答案为 $13$。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq k \leq 200$，$1 \leq n \leq 50$，$1 \leq a_i \leq 10^4$。

#### 说明

题目翻译来自 NOCOW。

## 样例 #1

### 输入

```
5 2
1 3```

### 输出

```
13```

# AI分析结果



### 综合分析与结论
本题需通过动态规划（完全背包变种）求解最大连续可表示邮资。各题解核心思路均为维护 `dp[i]` 表示组成面值 `i` 的最小邮票数，通过状态转移更新，最终扫描连续可行值。BFS解法因状态数爆炸风险，效率较低。最优解法为动态规划，关键点在于状态设计、转移方程优化及合理初始化。

---

### 精选题解与评分

#### 1. [QQ红包] 动态规划解法（★★★★★）
**关键亮点**  
- 代码简洁清晰，初始化合理（`f[0]=0`，其他初始极大值）。  
- 完全背包式遍历，正确处理状态转移 `f[j] = min(f[j], f[j-a]+1)`。  
- 使用固定上限 `2e6` 简化实现，避免复杂边界判断。  

**核心代码**  
```cpp
int f[2000000]; // f[i]表示构成i的最小邮票数
f[0] = 0;
for (int a : stamps) {
    for (int j = a; j <= 2000000; j++) {
        if (f[j - a] + 1 <= k) {
            f[j] = min(f[j], f[j - a] + 1);
        }
    }
}
// 扫描最大连续m
for (int i = 1; i <= 2000000; i++) {
    if (f[i] > k) { return i - 1; }
}
```

#### 2. [Weierstras] 动态规划+优化边界（★★★★☆）  
**关键亮点**  
- 引入 `mx = a[i] * k` 优化遍历范围，减少冗余计算。  
- 对邮票面值排序，优先处理小面值，提升局部效率。  

**核心代码**  
```cpp
sort(stamps.begin(), stamps.end());
for (int a : stamps) {
    int mx = a * k;
    for (int j = a; j <= mx; j++) {
        if (dp[j - a] + 1 <= k) {
            dp[j] = min(dp[j], dp[j - a] + 1);
        }
    }
}
```

#### 3. [Priori_Incantatem] 动态规划+边界特判（★★★★☆）  
**关键亮点**  
- 显式处理 `f[i]` 不可达的情况（`f[i] == INF`）。  
- 边计算边检测连续性，及时返回结果减少扫描次数。  

**核心代码**  
```cpp
int ans = 0;
for (int i = 1; i <= max_value; i++) {
    if (f[i] > k) {
        printf("%d", i - 1);
        return 0;
    }
}
```

---

### 最优解关键技巧总结
1. **状态设计**：`dp[i]` 表示组成面值 `i` 的最小邮票数，通过完全背包式更新。  
2. **转移方程**：`dp[i] = min(dp[i], dp[i - a] + 1)`，确保邮票数不超过 `k`。  
3. **初始化优化**：`dp[0] = 0`，其他初始为极大值，避免无效转移。  
4. **遍历范围**：基于 `k * max_stamp` 设定合理上限，平衡效率与正确性。  

---

### 同类题目推荐
1. **P1616 疯狂的采药**（完全背包模板题）  
2. **P2563 [SCOI2009] 找硬币**（最小硬币数问题，类似状态设计）  
3. **P2918 [USACO08NOV] Buying Hay**（动态规划求最小数量）  

---

### 个人心得摘录
- **调试教训**：BFS解法需注意状态去重，否则队列膨胀导致MLE。（[光明正大] BFS题解）  
- **优化顿悟**：排序邮票面值后，内层循环可提前终止，减少无效计算。（[Weierstras]题解）  
- **边界处理**：`dp[0] = 0` 是关键，否则所有状态无法正确转移。（多篇题解共同强调）

---
处理用时：81.86秒
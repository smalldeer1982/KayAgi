# 题目信息

# [USACO3.2] 纺车的轮子 Spinning Wheels

## 题目背景

一架纺车有五个纺轮（也就是五个同心圆），这五个不透明的轮子边缘上都有一些缺口。这些缺口必须被迅速而准确地排列好。每个轮子都有一个起始标记（在0度），这样所有的轮子都可以在统一的已知位置开始转动。轮子按照角度变大的方向旋转（即0经过旋转到达1的位置），所以从起始位置开始，在一定的时间内，它们依次转过1度，2度等等（虽然这些轮子很可能不会同时转过这些角度）。


## 题目描述

这是一个整数问题。轮子不会转过1.5度或23.51234123度这样的角度。例如，轮子可能在一秒钟内转过20到25度甚至30到40度（如果转得快的话）。

这个问题中的所有角度都限制在 0 <= 角度 <= 359 这个范围内。轮子转过 359 度后接下来就是 0 度。每个轮子都有一个确定的旋转速度，以秒作为单位。1 <= 速度 <= 180。

轮子上的缺口的起始角度和缺口大小（或宽度）各由一个整数表示，都以度为单位。在一个轮子上，两个缺口之间至少有一度的间隔。宽度也包含缺口起始的角度，**即0 179包括0..179共计180个角度**

在起始位置，设时间为 0，所有的轮子的起始标记排列成一条直线。你的程序必须计算，最早出现每个的轮子上的缺口同其他轮子上的缺口对准（也就是一束光可以通过五个轮子上的五个缺口）情况的时间。这些缺口在任意一个角度对准。


## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 3.2


## 样例 #1

### 输入

```
30 1 0 120
50 1 150 90
60 1 60 90
70 1 180 180
90 1 180 60```

### 输出

```
9```

# AI分析结果



### 综合分析与结论
各题解均采用**时间逐秒模拟**的思路，在360秒周期内枚举每个时间点，统计各轮子缺口覆盖情况。核心要点包括：
1. **缺口位置计算**：每秒更新各轮缺口位置，利用模360处理循环转动。
2. **覆盖统计**：用数组记录每个角度的覆盖次数，存在5次覆盖即找到解。
3. **周期优化**：所有轮子360秒后回到原点，故只需枚举0-360秒。

### 高星题解推荐
#### 1. [「QQ红包」题解] ⭐⭐⭐⭐⭐（17赞）
**亮点**：  
- 代码结构清晰，变量名直观（如`v[]`表速度，`s[]`表缺口数）。
- 逐秒更新缺口位置并统计覆盖，逻辑简洁。
- 处理模运算准确，避免数组越界。

**关键代码**：
```cpp
for (t=0;t<=360;t++) {
    memset(a,0,sizeof(a));
    for (i=1;i<=5;i++) {
        for (j=1;j<=s[i];j++) {
            for (k=x[i][j]; k<=x[i][j]+y[i][j]; k++) 
                a[k%360]++;
            x[i][j] = (x[i][j] + v[i]) % 360; // 更新缺口位置
        }
    }
    if (存在a[i]==5) 输出t;
}
```

#### 2. [王轩逸题解] ⭐⭐⭐⭐（5赞）
**亮点**：  
- 使用结构体`Wheel`组织数据，提高可读性。
- 注释详细，明确周期优化原理。

**关键片段**：
```cpp
struct Wheel { int sp, num, st[W], len[W]; };
for (int t=0; t<360; t++) {
    memset(gap, 0, sizeof(gap));
    for (轮子i) {
        for (缺口j) {
            for (k=st; k<=st+len; k++) 
                gap[k%360]++;
            st[j] = (st[j] + sp) % 360; // 更新位置
        }
    }
}
```

#### 3. [pigstd题解] ⭐⭐⭐⭐（4赞）
**亮点**：  
- 代码精简，直接内联时间计算。
- 变量命名稍有不足（如`k`表宽度），但逻辑正确。

**核心思路**：
```cpp
for (int t=0; t<360; t++) {
    memset(sum, 0, sizeof(sum));
    for (轮子j) {
        for (缺口k) {
            int pos = (初始位置 + t*速度) % 360;
            for (int w=0; w<=宽度; w++) 
                sum[(pos + w) % 360]++;
        }
    }
}
```

### 最优技巧总结
1. **模运算处理循环**：所有角度计算后取模360，避免处理负数和越界。
2. **逐秒模拟与更新**：每秒更新缺口位置而非预计算，简化逻辑。
3. **覆盖数组复用**：每轮清空统计数组，避免跨时间干扰。

### 拓展与相似题目
1. **周期模拟**：[P1211 时钟问题](https://www.luogu.com.cn/problem/P1211)  
   **相似点**：模拟时钟指针周期性运动，需处理角度对齐。
2. **时间轴事件处理**：[P2690 接苹果](https://www.luogu.com.cn/problem/P2690)  
   **相似点**：按时间顺序处理动态事件，需高效统计状态。
3. **环形结构**：[P2543 取石子游戏](https://www.luogu.com.cn/problem/P2543)  
   **相似点**：环形队列处理，结合模运算优化。

### 题解心得摘录
- **傅思维666**：强调模运算在环形问题中的核心作用，避免复杂边界处理。
- **袁宇轩**：`memset`清零的必要性，未清零导致统计错误是常见错误点。
- **QQ红包**：每秒更新缺口位置而非累计计算，直观且易于调试。

---
处理用时：179.88秒
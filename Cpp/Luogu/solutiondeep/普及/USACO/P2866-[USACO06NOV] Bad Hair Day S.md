# 题目信息

# [USACO06NOV] Bad Hair Day S

## 题目描述


农夫约翰有 $N$ 头奶牛正在过乱头发节。

每一头牛都站在同一排面朝右，它们被从左到右依次编号为 $1, 2, \cdots, N$。编号为 $i$ 的牛身高为 $h_i$。第 $N$ 头牛在最前面，而第 $1$ 头牛在最后面。

对于第 $i$ 头牛**前面**的第 $j$ 头牛，如果 $h_i>h_{i+1}, h_i>h_{i+2}, \cdots, h_i>h_j$，那么认为第 $i$ 头牛可以看到第 $i+1$ 到第 $j$ 头牛。

定义 $C_i$ 为第 $i$ 头牛所能看到的牛的数量。请帮助农夫约翰求出 $C _ 1 + C _ 2 + \cdots + C _ N$。


## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq N \leq 8 \times 10 ^ 4$，$1 \leq h _ i \leq 10 ^ 9$。

## 样例 #1

### 输入

```
6
10
3
7
4
12
2```

### 输出

```
5```

# AI分析结果



### 综合分析与结论
本题核心在于通过单调栈维护右向递减序列，快速计算每头牛的可见范围。所有高效题解均围绕单调栈展开，其中最优解法达到O(n)时间复杂度。线段树、二分+ST表等解法虽能通过，但效率明显低于单调栈方案。关键技巧在于将"可见数量"转化为栈内元素统计，并正确处理等号边界条件。

---

### 精选题解与评分

#### 1. Cripple_Abyss（★★★★★）
**核心亮点**：
- 代码极简（仅10行核心逻辑）
- 正序处理配合单调栈直接统计可见数
- 完美处理等号边界（`a.top()<=t`）
- 时间复杂度O(n)最优

**代码核心**：
```cpp
while (!a.empty()&&a.top()<=t) a.pop();
ans += a.size();
a.push(t);
```

#### 2. Hexarhy（★★★★☆）
**核心亮点**：
- 清晰解释严格递减与包含等号的区别
- 使用`accumulate`简化求和
- 明确提醒long long必要性

**关键实现**：
```cpp
while(!s.empty() && h[s.top()]<=h[i]) s.pop();
ans += s.size();
s.push(i);
```

#### 3. Youngsc（★★★★☆）
**逆向思维亮点**：
- 从右向左扫描计算被看见次数
- 栈中存储下标直接计算间距
- 处理栈空时的全可见情况

**核心片段**：
```cpp
while(top && h[st[top]]<h[i]) top--;
if(top) ans += st[top]-i-1;
else ans += n-i;
```

---

### 关键思路总结
**单调栈维护递减序列**：
1. 新元素入栈前弹出所有<=当前值的元素
2. 栈剩余元素数量即为当前元素的可见数
3. 最终总和即为答案

**思维突破点**：
将"每头牛能看见的数量"转换为"被多少左侧的牛看见"，通过栈的单调性保证计算的高效性。

---

### 同类题目推荐
1. P5788 【模板】单调栈 - 找每个元素右侧第一个更大值
2. P1901 发射站 - 单调栈处理双向能量传递
3. P1823 [COI2007] Patrik - 相似身高问题变式

---

### 实用心得摘录
1. huyufeifei的反思：*"用线段树A了后才发现单调栈10行搞定...深刻认识到了自己的脑残"* → **选择合适的算法比强行套用数据结构更重要**
2. Harry27182调试经验：*"二分时发现要向上取整否则漏解"* → **二分边界需结合问题特性验证**
3. 加勒比·史努比总结：*"不开long long见祖宗"* → **大规模累加必用long long**

---
处理用时：42.07秒
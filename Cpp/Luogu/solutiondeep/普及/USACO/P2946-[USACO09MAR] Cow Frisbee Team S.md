# 题目信息

# [USACO09MAR] Cow Frisbee Team S

## 题目描述

老唐最近迷上了飞盘，约翰想和他一起玩，于是打算从他家的 $N$ 头奶牛中选出一支队伍。

每只奶牛的能力为整数，第 $i$ 头奶牛的能力为 $R_i$。飞盘队的队员数量不能少于 $1$、大于 $N$。一支队伍的总能力就是所有队员能力的总和。

约翰比较迷信，他的幸运数字是 $F$，所以他要求队伍的总能力必须是 $F$ 的倍数。请帮他算一下，符合这个要求的队伍组合有多少？由于这个数字很大，只要输出答案对 $10^8$ 取模的值。

## 说明/提示

对于 $100\%$ 的数据，$1 \le N \le 2000$，$1 \le F \le 1000$，$1 \le R_i \le 10^5$。

## 样例 #1

### 输入

```
4 5 
1 
2 
8 
2 
```

### 输出

```
3 
```

# AI分析结果



### 综合分析与结论
本题需通过动态规划解决模意义下的组合计数问题，核心在于将总和模F作为状态。各题解均采用二维DP或滚动数组优化，状态转移方程相似。关键难点在于负余数处理、空间优化与初始化方式。推荐使用滚动数组优化空间的解法（O(F)空间），兼顾效率与正确性。

---

### 精选题解与评分

#### 1. 作者：lawson_abs（★★★★★）
**关键亮点**  
- 深入分析一维DP的局限性，明确必须使用二维/滚动数组  
- 提供完整滚动数组实现，正确处理模运算的负数问题  
- 包含详细调试心得与错误分析  
**个人心得**  
> "在把能力对F取模处理之后，利用一维的滚动数组会造成问题的错误解"  
> 强调必须通过二维状态或滚动数组维护正确转移关系  

**核心代码**  
```cpp
int dp[2][maxV]; // 滚动数组
for(int i = 1;i< n;i++){    
    for(int j = f-1;j >= 0;j--){                                            
        dp[i&1][j] = dp[(i-1)&1][(j-arr[i]+f)%f] + dp[(i-1)&1][j];
        dp[i&1][j] %= 100000000;                        
    }
}
```

#### 2. 作者：nafna（★★★★☆）
**关键亮点**  
- 简洁的滚动数组实现，在线处理输入  
- 清晰的转移方程注释，代码可读性高  
- 初始化方式巧妙（f[0][0]=1）  

**核心代码**  
```cpp
int f[2][1005]; // 滚动数组
for (int i = 1; i <= n; i++){
    cin >> w; w %= F;
    p = 1 - p; // 切换滚动层
    for (int j = 0; j < F; j++)
        f[p][j] = (f[1-p][j] + f[1-p][(j-w+F)%F]) % Q;
}
```

#### 3. 作者：CCF_zkskyer（★★★★☆）
**关键亮点**  
- 最直观的二维DP实现，适合理解基础思路  
- 提前取模优化输入数据  
- 清晰的转移方程展示  

**核心代码**  
```cpp
long long f[2005][1005]; // 标准二维DP
for(int i=1;i<=N;i++) {
    for(int j=0;j<F;j++) {
        f[i][j] = (f[i-1][j] + f[i-1][(j-cow[i]+F)%F]) % mod;
    }
}
```

---

### 最优思路总结
1. **状态压缩**：利用模运算将状态压缩至O(F)级别  
2. **滚动数组**：交替使用两层数组（`dp[i&1]`或`p=1-p`）优化空间  
3. **负数处理**：通过`(j-w+F)%F`保证余数为正  
4. **初始化技巧**：单独处理每个元素作为初始状态（`f[i][r[i]]=1`）

---

### 拓展练习推荐
1. **P1077 [NOIP2012 普及组] 摆花**（组合计数DP）  
2. **P1064 [NOIP2006 提高组] 金明的预算方案**（带依赖的背包问题）  
3. **P4141 消失之物**（特殊计数背包，练习状态转移逆向思维）  

---

### 关键代码实现（以滚动数组为例）
```cpp
const int MOD = 1e8;
int dp[2][1005]; // 滚动数组

int main() {
    int n, F, w;
    cin >> n >> F;
    dp[0][0] = 1; // 初始状态
    
    for(int i = 1; i <= n; ++i) {
        cin >> w; w %= F;
        int cur = i%2, pre = 1-cur;
        memset(dp[cur], 0, sizeof(dp[cur])); // 清空当前层
        
        for(int j = 0; j < F; ++j) {
            dp[cur][j] = (dp[pre][j] + dp[pre][(j-w+F)%F]) % MOD;
        }
    }
    cout << dp[n%2][0];
}
```

---
处理用时：62.86秒
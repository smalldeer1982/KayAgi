# 题目信息

# [USACO11NOV] Cow Lineup S

## 题目描述

### 问题描述

农民约翰雇一个专业摄影师给他的部分牛拍照。由于约翰的牛有好多品种，他喜欢他的照片包含每个品种的至少一头牛。

约翰的牛都站在一条沿线的不同地方， 每一头牛由一个整数位置 $X_i$ 以及整数品种编号 $ID_i$ 表示。

约翰想拍一张照片，这照片由沿线的奶牛的连续范围组成。照片的成本与规模相当，这就意味着，在一系列照片中的最大和最小 $X$ 坐标的差距决定了照片的成本。

请帮助约翰计算最小的照片成本，这些照片中有每个不同的品种的至少一头牛，没有两头牛愿意站在同一个地点的。

## 样例 #1

### 输入

```
6 
25 7 
26 1 
15 1 
22 3 
20 1 
30 1 
```

### 输出

```
4 
```

# AI分析结果



### 综合分析与结论
本题核心为寻找包含所有品种的最小区间，主流解法为排序后结合滑动窗口/双指针。各题解均基于此思路，差异主要体现在离散化处理、数据结构优化与窗口维护方式。关键难点在于高效统计窗口内品种数量，并快速缩小窗口。最优解法通过离散化将大范围ID映射为连续整数，结合数组统计，显著提升效率。

---

### 高星题解推荐
#### 1. 作者：Priori_Incantatem（★★★★☆）
**关键亮点**  
- 离散化处理：将大范围ID映射为连续整数，优化空间与时间效率。  
- 双指针维护窗口：通过 `c[]` 数组统计品种数，逻辑清晰易维护。  
- 边界处理严谨：动态调整左指针时同步更新统计值，避免无效窗口。  
```cpp
// 离散化与双指针核心代码
map<int, int> vis;
for (int i=1; i<=n; ++i) {
    int tmp = read();
    srt[i].d = calc(tmp); // 离散化为连续ID
}
sort(srt+1, srt+1+n, cmp);

int l=1, r=0, sum=0;
while (r < n) {
    ++r, c[id[r]]++;
    if (c[id[r]] == 1) sum++;
    while (c[id[l]] > 1) c[id[l]]--, l++; // 收缩左边界
    if (sum == tot) ans = min(ans, a[r]-a[l]);
}
```

#### 2. 作者：糪眾脦颰罷（★★★★☆）
**核心思路**  
- 预处理总品种数：利用map快速统计，避免重复计算。  
- 尺取法实现：右指针扩展至覆盖所有品种，左指针收缩优化区间。  
- 代码简洁：直接使用map维护窗口内品种数，逻辑直观。  

**调试心得**  
> "注意移动左指针时要及时减少对应品种计数，否则会导致统计错误。"  
```cpp
// 尺取法核心片段
while(z<sum && tail<n){
    tail++;
    t[s[tail].p]++;
    if(t[s[tail].p]==1) z++;
}
if(z==sum) ans = min(ans, s[tail].x-s[i].x);
t[s[i].p]--;  // 左指针移动时更新计数
```

---

### 最优思路提炼
1. **离散化ID**：将大范围ID压缩为连续整数，便于数组统计。  
2. **双指针滑动窗口**：右指针扩展至满足条件，左指针收缩优化解。  
3. **计数数组维护**：实时更新窗口内各品种数量，动态调整窗口边界。  

---

### 举一反三
- **同类题目推荐**  
  - [P2564 生日礼物](https://www.luogu.com.cn/problem/P2564)：滑动窗口求最小区间覆盖所有类型。  
  - [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)：完全相同的双指针模型。  
  - [P1712 区间](https://www.luogu.com.cn/problem/P1712)：覆盖多个区间的最短序列。  

- **关键技巧迁移**  
  离散化、滑动窗口维护与动态统计可应用于需覆盖特定元素集的最优区间问题，如广告投放、传感器覆盖等场景。

---
处理用时：51.12秒
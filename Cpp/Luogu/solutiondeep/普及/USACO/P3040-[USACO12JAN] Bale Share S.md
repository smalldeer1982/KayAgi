# 题目信息

# [USACO12JAN] Bale Share S

## 题目描述

FJ 有 $n$ 包干草，第 $i$ 干草的重量是 $s_i$，他想尽可能平均地将干草分给三个农场。

他希望分配后的干草重量最大值尽可能地小，比如，$b_1,b_2,b_3$ 是分配后的三个值，假设 $b_1 \ge b_2 \ge b_3$，则他希望 $b_1$ 的值尽可能地小。

请计算 $b_1$ 的最小值。


## 说明/提示

【样例解释】  
一种满足要求的分配方案是：  
农场 1: $2,9,15$，$b_1 = 26$   
农场 2: $4,8,14$，$b_2 = 26$   
农场 3: $5,20$，$b_3 = 25$   

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 20$，$1 \le s_i \le 100$。

## 样例 #1

### 输入

```
8 
14 
2 
5 
15 
8 
9 
20 
4 
```

### 输出

```
26 
```

# AI分析结果



### 题解综合分析结论
本题核心在于寻找三堆分配的最优解，主流解法为动态规划与剪枝DFS。其中DP解法通过状态压缩实现高效求解，适用于数据规模；剪枝策略通过排序与可行性优化提升搜索效率。随机化方法虽具创意但稳定性不足。

---

### 高星题解推荐

#### 1. functionendless（★★★★★）
**关键亮点**  
- 状态定义巧妙：用二维布尔数组记录两堆重量组合的可行性  
- 空间优化：无需存储第三堆（通过总和计算）  
- 逆向更新：滚动数组思想避免状态覆盖  
**核心实现**  
```cpp
bool f[1000][1000]; // f[i][j]表示是否存在两堆分别为i,j
for(每次读入tmp){
    for(j = sum; j>=0; j--)
        for(k = sum; k>=0; k--)
            if(f[j][k]){
                f[j+tmp][k] = 1; // 加入第一堆
                f[j][k+tmp] = 1; // 加入第二堆
            }
}
```

#### 2. DiDi123（★★★★☆）
**关键亮点**  
- 滚动数组优化：二维DP代替三维节省空间  
- 边界处理清晰：通过sum控制枚举范围  
**核心代码**  
```cpp
bool f[MAXN][MAXN]; // 滚动数组
for(int j=sum;j>=0;j--)
    for(int k=sum-j;k>=0;k--)
        if(f[j][k]){
            f[j+tmp][k] = 1;
            f[j][k+tmp] = 1;
        }
```

#### 3. 小小小朋友（★★★★☆）
**关键亮点**  
- 剪枝策略：排序+剩余总和可行性剪枝  
- 变量命名清晰：通过a,b,c维护三堆状态  
**核心剪枝**  
```cpp
if(c >= ans) return; // 最优性剪枝
if(b > c + remaining || a > c + remaining) return; // 可行性剪枝
```

---

### 关键思路与技巧总结
**核心算法**：动态规划（状态压缩）  
- 状态定义：`f[i][j]` 表示前两堆重量为i,j的可行性  
- 转移方程：`f[i][j] |= f[i-v][j] | f[i][j-v]`  
**优化技巧**：  
1. 逆序枚举避免状态覆盖  
2. 排序剪枝：将物品降序排列加速剪枝  
3. 可行性判断：通过剩余总和提前终止无效分支  

**思维突破**：将三维问题（三堆）转化为二维状态，利用总和计算第三堆。

---

### 相似题目推荐
1. P2320 [HNOI2006]鬼谷子的钱袋（分堆问题）  
2. P1282 多米诺骨牌（状态压缩DP）  
3. P2214 [USACO14MAR]Mooo Moo S（背包变种）

---

### 题解中的调试心得
**Kizuna_AI**提到：  
- 随机化顺序可能影响剪枝效率，需配合时间限制使用  
- 本地调参技巧：通过修改随机种子适配不同测试点  

**友邻牧鸡**总结：  
- 类比塔问题设计三维状态，通过差值定义状态空间  
- 刷表法实现复杂状态转移，需细致处理边界条件  

**Dawn_Sdy**经验：  
- 逆序排序干草包能显著提升剪枝效率  
- 对称情况剪枝可减少重复搜索路径

---
处理用时：61.80秒
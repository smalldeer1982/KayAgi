# 题目信息

# [USACO16DEC] Moocast S

## 题目描述

约翰农场主的 $N$ 头奶牛想建立一个紧急情况下的“哞哞广播”系统，这样它们就可以在自己中间广播重要信息。

奶牛们想让每头牛装备上一个对讲机，而不是在长距离中向另一头奶牛“哞哞”乱叫。这些对讲机每台都有各自的有效传输半径——一个拥有 $P$ 能量的对讲机只能向距离在 $P$ 以内的牛发送信息（注意可能出现 $A$ 牛对讲机的能量比 $B$ 牛的大，而 $A$ 牛可以给 $B$ 牛发送信息，但 $B$ 牛不能传回信息）。幸运的是，奶牛们可以通过其他奶牛中继，沿着一条跳跃的路径传递信息，因此每个奶牛不必要直接向每个其他奶牛传播。

由于对讲机的费堆成性质，来自一些奶牛的广播可能比其他奶牛的广播能够达到更多的接受者（考虑中继的情况）的能力更有效。请帮助奶牛确定来自单个奶牛的广播可以达到的奶牛的最大数量。

## 说明/提示

对于 $100\%$ 的数据，$N\le200$，$\forall i \in [1,N]$，$0\le x_i,y_i\le25000$。

## 样例 #1

### 输入

```
4
1 3 5
5 4 3
7 2 1
6 1 1```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
题目要求计算单向广播可达性的最大覆盖范围。所有解法均基于图遍历思想，主要差异在预处理方式和遍历策略。最优解通过邻接表优化存储结构，避免浮点运算，将时间复杂度稳定在 O(n²) 级别。

---

### 精选题解

#### 1. sxyugao 的邻接表优化（★★★★★）
**关键亮点**：  
- 邻接表存储直接可达节点，减少遍历冗余  
- 整数平方比较避免浮点运算，提升效率  
- 预处理阶段时间复杂度 O(n²)，DFS 总时间 O(n²)

**核心代码**：
```cpp
// 预处理邻接表
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
        if(sqr(p[i]) >= sqr(x[i]-x[j])+sqr(y[i]-y[j]))
            edge[i][++edge[i][0]]=j;

// DFS遍历
void dfs(int k){
    v[k]=1; tot++;
    for(int i=1;i<=edge[k][0];i++)
        dfs(edge[k][i]);
}
```

#### 2. MVP_Harry 的DFS解法（★★★★）
**关键亮点**：  
- 代码结构清晰，适合快速理解问题  
- 直接计算实时距离，省去预处理步骤  
- 适合小数据场景，无额外空间开销

**核心代码**：
```cpp
void dfs(int cur) {
    for(int i=1; i<=n; i++) {
        if(dis(a[cur], a[i]) <= a[cur].p && !vis[i]) {
            vis[i] = 1;
            dfs(i);
        }
    }
}
```

---

### 关键思路总结
1. **邻接表预处理**：将每个节点的可达节点预先存储，减少遍历时的计算量。  
2. **整数化比较**：用距离平方代替浮点运算，避免精度问题并提升性能。  
3. **遍历策略选择**：DFS/BFS 在 n≤200 时效率相当，优先考虑代码可维护性。  
4. **单向边特性**：注意边的方向性，不可使用无向图算法（如并查集）。

---

### 拓展练习
1. [P3916 图的遍历](https://www.luogu.com.cn/problem/P3916) - 反向建边技巧  
2. [P2863 [USACO06JAN]The Prom, S](https://www.luogu.com.cn/problem/P2863) - 强连通分量应用  
3. [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119) - Floyd 算法动态更新

---
处理用时：67.56秒
# 题目信息

# [USACO17FEB] Why Did the Cow Cross the Road II S

## 题目描述

穿过 Farmer John 农场的长路上有 $N$ 个人行横道，方便地用编号 $1 \ldots N$ 标识（$1 \leq N \leq 100,000$）。为了让奶牛能够通过这些横道过马路，FJ 安装了电子过马路信号灯，当奶牛可以安全过马路时，信号灯会显示绿色的奶牛图标，否则显示红色。不幸的是，一场大雷暴损坏了他的一些信号灯。给定损坏信号灯的列表，请计算 FJ 需要修复的最少信号灯数量，以便存在至少 $K$ 个连续的信号灯正常工作。

## 样例 #1

### 输入

```
10 6 5
2
10
1
5
9```

### 输出

```
1```

# AI分析结果



### 综合分析与结论
本题核心为寻找长度为K的连续区间中损坏信号灯的最小数量。各题解主要采用两种高效思路：
1. **前缀和法**：预处理损坏位置的前缀和数组，实现O(1)区间查询，总时间复杂度O(N)
2. **滑动窗口/队列法**：动态维护窗口内损坏数，每次移动窗口仅处理头尾元素，时间复杂度O(N)

### 高星题解推荐（≥4星）

#### 1. 作者：Anguei（★★★★★）
**关键亮点**：
- 思路清晰，代码简洁直观
- 利用前缀和实现O(N)时间复杂度
- 预处理与区间查询分离，代码可读性高

**核心代码**：
```cpp
rep(i, 1, n) s[i] = s[i - 1] + a[i]; // 构建前缀和
rep(i, k, n) ans = std::min(ans, s[i] - s[i - k]); // 滑动查询
```

#### 2. 作者：船医（★★★★）
**关键亮点**：
- 队列模拟滑动窗口过程
- 动态维护当前窗口损坏数，避免重复计算
- 代码结构清晰，注释明确

**核心代码**：
```cpp
queue<int> q;
for(int i=1; i<=k; i++){ // 初始化窗口
    q.push(i);
    if(d[i]) ans++;
}
for(int i=k+1; i<=n; i++){ 
    q.push(i);
    if(d[i]) sum++;
    if(d[q.front()]) sum--;
    q.pop();
    ans = min(ans, sum);
}
```

#### 3. 作者：entity（★★★★）
**关键亮点**：
- 极简滑动窗口实现
- 无额外数据结构，直接操作数组下标
- 代码短小精悍，空间效率高

**核心代码**：
```cpp
int sum=0;
for(int i=1; i<=k; i++) sum += a[i]; // 初始窗口
for(int i=k+1; i<=n; i++){ 
    sum += a[i] - a[i-k]; // 窗口滑动
    ans = min(ans, sum);
}
```

### 最优思路总结
**前缀和法**与**滑动窗口法**均为解决固定长度区间统计问题的经典范式：
- 前缀和适用于预处理后需要频繁区间查询的场景
- 滑动窗口更节省空间，适合动态维护窗口状态

### 拓展建议
**同类题目推荐**：
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886) - 滑动窗口最值问题
2. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406) - 前缀和与差分数组应用
3. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719) - 二维前缀和扩展

**个人心得摘录**：
> "刚开始想用暴力直接枚举...但发现时间复杂度太高。突然发现可以用队列模拟窗口滑动过程" —— 船医  
> （启示：暴力枚举后应优先考虑滑动窗口优化）

> "枚举区间时前缀和能O(1)查询，这就是离线处理的核心优势" —— Anguei  
> （强调预处理对复杂度的关键影响）

---
处理用时：71.14秒
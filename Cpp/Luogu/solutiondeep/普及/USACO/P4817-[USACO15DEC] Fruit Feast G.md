# 题目信息

# [USACO15DEC] Fruit Feast G

## 题目描述

Bessie 再次闯入了 Farmer John 的房屋！她在厨房发现了一堆柠檬和一堆橙子（每种水果的数量都可以视为无限），并决定尽可能多吃。

Bessie 的最大饱腹度为 $T$（$1 \leq T \leq 5,000,000$）。每吃一个橙子会使饱腹度增加 $A$，每吃一个柠檬会使饱腹度增加 $B$（$1 \leq A,B \leq T$）。此外，Bessie 最多可以喝一次水，这将使饱腹度立即减半（向下取整）。

请帮助 Bessie 计算她能达到的最大饱腹度！

## 说明/提示

题目提供者：Nathan Pinsker

## 样例 #1

### 输入

```
8 5 6```

### 输出

```
8```

# AI分析结果



### 综合分析与结论
本题核心在于处理「喝水后饱腹度减半」的特殊操作，需结合动态规划或搜索算法覆盖所有可能状态。关键点在于将问题分解为喝水前和喝水后两种状态，并通过状态转移或剪枝优化效率。最优解法通常采用 BFS + 状态剪枝或动态规划的多阶段处理。

---

### 精选题解与评分

#### 1. WanderingTrader（★★★★★）
- **关键亮点**：BFS + 双状态剪枝，通过队列按层扩展，用二维 `vis` 数组记录状态（饱腹度+是否喝水），确保每个状态只访问一次，时间复杂度严格线性。
- **核心思想**：
  ```cpp
  queue<node> q; // 存储当前饱腹度及是否喝水
  bool vis[N][2]; // 状态剪枝
  while (!q.empty()) {
      // 扩展吃A/B或喝水后的状态，仅入队未访问且不超限的情况
  }
  ```

#### 2. qscweadzx（★★★★☆）
- **关键亮点**：多重背包预处理喝水前后的可达状态，分阶段处理喝水操作，代码简洁高效。
- **核心代码**：
  ```cpp
  for(int i=a; i<=t; ++i) f[i] |= f[i-a]; // 吃A
  for(int i=1; i<=t; ++i) f[i>>1] |= f[i]; // 喝水
  for(int i=a; i<=t; ++i) f[i] |= f[i-a]; // 喝水后再吃A/B
  ```

#### 3. 梧桐灯（★★★★☆）
- **关键亮点**：BFS + 桶优化，用 `f[x][y]` 记录状态，队列保存饱腹度和喝水标志，逻辑清晰。
- **核心片段**：
  ```cpp
  queue<pair<int, bool>> q;
  q.push(MP(0, true)); // 初始状态
  while (!q.empty()) {
      if (y && !f[x/2][0]) q.push(MP(x/2, 0)); // 喝水操作
      // 扩展吃A/B的情况
  }
  ```

---

### 关键思路与技巧总结
1. **状态分离**：将喝水前后的状态分开处理（如 `vis[x][0/1]`），避免重复计算。
2. **剪枝优化**：在搜索中用数组记录访问状态，确保每个状态仅处理一次。
3. **分阶段DP**：先处理不喝水的情况，再处理喝水后的状态转移，类似两阶段背包问题。
4. **BFS层级扩展**：按饱腹度从小到大扩展，保证首次到达最大值时即为最优解。

---

### 类似题目推荐
1. **P1443 马的遍历**（BFS + 状态记录）
2. **P1135 奇怪的电梯**（BFS处理分层状态）
3. **P3419 [POI2005]BAN-Bank Notes**（多重背包与状态优化）

---

### 题解中的个人心得摘录
- **Kalium**：完全背包在本题无法满分，转而采用记忆化搜索，体现算法选择需结合题目特性。
- **TESJackeyLove**：强调剪枝重要性，初始暴搜TLE后通过状态记录优化到AC。
- **Lagibol**：尝试将喝水操作提前，转化为数学表达式，虽复杂但提供另一种思路。

---
处理用时：46.79秒
# 题目信息

# [USACO15FEB] Superbull S

## 题目描述

Bessie 和她的朋友们正在一年一度的 Superbull 锦标赛中比赛，Farmer John 负责让比赛尽可能精彩。总共有 $N$ $(1 \leq N \leq 2000)$ 支队伍参加 Superbull。每支队伍都被分配了一个唯一的整数队伍 ID，范围在 $1 \ldots 2^{30}-1$ 之间，用于区分不同队伍。Superbull 是淘汰制比赛——每场比赛后，Farmer John 会选择淘汰其中一支队伍，被淘汰的队伍将不再参与后续比赛。当只剩一支队伍时，Superbull 结束。

Farmer John 发现比赛得分有一个特殊性质：任意一场比赛中，两支队伍的得分总和总是等于两队 ID 的按位异或（XOR）。例如，若队伍 12 和 20 比赛，则该场比赛总得分为 $24$，因为 $01100 \oplus 10100 = 11000$（即 $12 \oplus 20 = 24$）。

Farmer John 认为比赛总得分越高越精彩。因此，他希望安排一系列比赛，使得 Superbull 所有比赛的总得分最大化。请帮助他设计比赛方案。

## 说明/提示

**输出样例解释**：  
一种获得 37 分的方案如下：  
1. Farmer John 让队伍 3 和 9 比赛，选择淘汰 9，此时剩余队伍为 6、9、10  
2. 让队伍 6 和 9 比赛，选择淘汰 9，此时剩余队伍为 6 和 10  
3. 最后让队伍 6 和 10 比赛  
总得分为 $(3 \oplus 9) + (6 \oplus 9) + (6 \oplus 10) = 10 + 15 + 12 = 37$。

**关于按位异或**：  
按位异或运算（记作 $\oplus$）对两个二进制数的每一位进行逻辑异或操作。当且仅当某一位上两个数不同时，结果的该位为 1。例如：  
$10100$（十进制 20）$\oplus$ $01100$（十进制 12）$= 11000$（十进制 24）

## 样例 #1

### 输入

```
4
3
6
9
10```

### 输出

```
37```

# AI分析结果



### 综合分析与结论
本题核心为**最大生成树**，将每支队伍视为节点，两队比赛的异或得分作为边权，构建完全图后求最大生成树的总权值。所有题解均正确识别模型，差异主要在算法选择（Kruskal vs Prim）和实现细节（如数据溢出处理）。

### 高星题解推荐
1. **zylll（5星）**  
   **亮点**：  
   - 采用Prim算法，针对稠密图优化，时间复杂度O(n²)更优  
   - 代码简洁清晰，接近模板，便于理解  
   - 明确指出Kruskal在稠密图中的效率问题  
   **核心代码**：
   ```cpp
   void Prim(){
       for(int i=1,x=0;i<=n;i++,x=0){
           for(int j=1;j<=n;j++)if(!vis[j])
               if(key[j]>=key[x])x=j;  // 选择当前最大边
           vis[x]=true;
           ans += key[x];
           for(int y=1;y<=n;y++)       // 更新相邻边权
               if(!vis[y])key[y]=max(key[y],a[x]^a[y]);
       }
   }
   ```

2. **installb（4星）**  
   **亮点**：  
   - 动态计算边权，避免存储所有边，节省内存  
   - 通过逐步扩展生成树维护最大边权  
   **关键实现**：
   ```cpp
   for(int j=1;j<=n;j++) 
       dis[j] = max(dis[j],a[id]^a[j]);  // 动态更新边权
   ```

3. **Del_Your_Heart（4星）**  
   **亮点**：  
   - 详细对比Kruskal与Prim的适用场景  
   - 提供两种算法实现，方便对比学习  
   **个人心得**：  
   > "稠密图跑Prim！稀疏图跑Kruskal！" —— 通过时间复杂度分析强调算法选择的重要性

---

### 最优思路提炼
1. **建模技巧**：将淘汰赛结构转化为树形关系，根节点为最终胜者，边权为异或值  
2. **算法选择**：  
   - **Prim算法**：适合稠密图（n≤2000时边数约2e6），时间复杂度稳定O(n²)  
   - **Kruskal**：需排序所有边（约2e6条），适合稀疏图  
3. **关键优化**：  
   - 避免存储所有边（Prim动态计算）  
   - 使用`long long`防止累加溢出（多个题解强调此点）

---

### 举一反三
1. **同类题目推荐**  
   - [P1967 货车运输](https://www.luogu.com.cn/problem/P1967)：最大生成树+树上路径查询  
   - [P4047 [JSOI2010]部落划分](https://www.luogu.com.cn/problem/P4047)：生成树思想解决聚类问题  
   - [P1550 [USACO08OCT]Watering Hole](https://www.luogu.com.cn/problem/P1550)：虚拟节点技巧的生成树应用  

2. **拓展技巧**  
   - 异或性质在生成树中的应用（如[XOR-MST](https://codeforces.com/problemset/problem/888/G)）  
   - 动态维护生成树（如删边/加边操作）

---
处理用时：46.39秒
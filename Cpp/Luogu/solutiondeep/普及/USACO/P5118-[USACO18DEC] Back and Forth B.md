# 题目信息

# [USACO18DEC] Back and Forth B

## 题目描述

Farmer John 有两个挤奶棚，每个挤奶棚里各有一个奶罐和一个装有 $10$ 个各种尺寸的桶的储物柜。他喜欢将在两个挤奶棚之间来回运送牛奶作为一种锻炼方式。

周一，Farmer John 量了恰好 $1000$ 加仑的牛奶放在第一个挤奶棚的奶罐里，又量了恰好 $1000$ 加仑的牛奶放在第二个挤奶棚的奶罐里。

周二，他从第一个挤奶棚里取出一个桶，并装满牛奶，然后将牛奶运到第二个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第二个挤奶棚。

周三，他从第二个挤奶棚里取出一个桶（可能是周二留在这里的），并装满牛奶，然后将牛奶运到第一个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第一个挤奶棚。

周四，他从第一个挤奶棚里取出一个桶（可能是周三留在这里的），并装满牛奶，然后将牛奶运到第二个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第二个挤奶棚。

周五，他从第二个挤奶棚里取出一个桶（可能是周二或周四留在这里的），并装满牛奶，然后将牛奶运到第一个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第一个挤奶棚。

此时 Farmer John 测量了第一个挤奶棚的奶罐里的牛奶。他总共可能得到多少种不同的读数？


## 说明/提示

在这个例子中，最后第一个挤奶棚的奶罐中的牛奶量总共有 $5$ 种可能的结果：

$1000$：FJ 可以在每次往返的时候都携带同一个桶，从而不会改变第一个挤奶棚的奶罐的牛奶量。

$1003$：FJ 可以在周二运送 $2$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $1$ 个单位。

$1004$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $1$ 个单位。

$1007$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $2$ 个单位，周五 $5$ 个单位。

$1008$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $5$ 个单位。

## 样例 #1

### 输入

```
1 1 1 1 1 1 1 1 1 2
5 5 5 5 5 5 5 5 5 5```

### 输出

```
5```

# AI分析结果



### 综合分析与结论
本题核心在于模拟四次搬运操作后奶量的状态变化，需正确处理桶的位置切换与数值计算。主要解法集中在DFS状态回溯与暴力枚举两类，其中DFS模拟状态转移的解法更易保证正确性，而部分暴力枚举解法通过数学推导简化计算但需注意边界条件。

---

### 高星题解推荐

#### 1. 题解作者：Alex_Wei（★★★★★）
**关键亮点**  
- 用DFS+回溯精准模拟每日操作，逻辑清晰  
- 通过桶位置数组（pd[]）管理动态状态  
- 使用vector自动去重，代码简洁高效  
**核心思路**  
```cpp
void dfs(int w, int m) {
    if (w >= 6) { // 周六结束
        if (!count(ans.begin(), ans.end(), m)) 
            ans.push_back(m);
        return;
    }
    for (遍历所有桶) {
        if (当前天数与位置匹配) {
            修改桶位置，递归下一层；
            回溯恢复状态； // 关键点
        }
    }
}
```

#### 2. 题解作者：lzqy_（★★★★☆）
**关键亮点**  
- 将桶编号后直接枚举所有组合  
- 分离状态数组与模拟操作，可读性强  
- 注释详细，适合DFS初学者理解  
**核心实现**  
```cpp
void moni() {
    // 模拟四次搬运操作
    b[10] = a[s[1]]; a[s[1]] = 0; // 第一次搬运
    a[s[1]] = b[s[2]]; b[s[2]] = 0; // 第二次
    ... // 类似处理后两次
    // 计算最终奶量并记录
}
```

#### 3. 题解作者：Akoasm_X（★★★★☆）
**关键亮点**  
- 将四次操作拆分为两次交换，降低复杂度  
- 通过swap操作简化状态管理  
- 排序剪枝优化重复计算  
**代码片段**  
```cpp
for (枚举第一次交换i,j) {
    swap(a[i], b[j]); // 状态交换
    int m = 1000 + b[j] - a[i];
    for (枚举第二次交换ii,jj) {
        if (!vis[m + b[jj] - a[ii]]) 
            ans++, vis标记;
    }
    swap(a[i], b[j]); // 回溯
}
```

---

### 关键技巧总结
1. **状态回溯**：DFS中通过修改->递归->恢复的步骤处理动态状态，避免深拷贝  
2. **数学建模**：最终奶量可表示为 `1000 ± a ± b ± c ± d`，部分解法通过枚举差值组合优化  
3. **容器去重**：利用set/map自动去重，或手动遍历vector检查重复  
4. **交换剪枝**：通过swap操作直接修改状态，回溯时再swap恢复，减少内存消耗  

---

### 类似题目推荐
1. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)（状态转移+BFS）  
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)（DFS+棋盘状态管理）  
3. [P1032 字串变换](https://www.luogu.com.cn/problem/P1032)（字符串状态BFS）  

---

### 题解中的调试经验
- **Polarnova题解**评论区指出其分类讨论存在漏洞（如未考虑同一桶多次移动），需注意全面性  
- **Guess00题解**通过临时数组模拟操作后还原，强调状态隔离的重要性  
- **damage题解**提到用vector.erase时需注意迭代器失效问题，改用索引遍历

---
处理用时：46.65秒
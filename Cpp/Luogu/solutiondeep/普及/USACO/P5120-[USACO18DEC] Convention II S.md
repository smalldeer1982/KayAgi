# 题目信息

# [USACO18DEC] Convention II S

## 题目描述

虽然在接机上耽误了挺长时间，Farmer John 为吃草爱好牛们举行的大会至今为止都非常顺利。大会吸引了世界各地的奶牛。

然而大会的重头戏看起来却给 Farmer John 带来了一些新的安排上的困扰。他的农场上的一块非常小的牧草地出产一种据某些识货的奶牛说是世界上最美味的品种的草。因此，所有参会的 $N$ 头奶牛（$1\le N\le 10^5$）都想要品尝一下这种草。由于这块牧草地小到仅能容纳一头奶牛，这很有可能会导致排起长龙。

Farmer John 知道每头奶牛i计划到达这块特殊的牧草地的时间 $a_i$，以及当轮到她时，她计划品尝这种草花费的时间 $t_i$。当奶牛 $i$ 开始吃草时，她会在离开前花费全部 $t_i$ 的时间，此时其他到达的奶牛需要排队等候。如果这块牧草地空出来的时候多头奶牛同时在等候，那么资历最深的奶牛将会是下一头品尝鲜草的奶牛。在这里，恰好在另一头奶牛吃完草离开时到达的奶牛被认为是“在等待的”。类似地，如果当没有奶牛在吃草的时候有多头奶牛同时到达，那么资历最深的奶牛是下一头吃草的奶牛。

请帮助 FJ 计算所有奶牛中在队伍里等待的时间（$a_i$ 到这头奶牛开始吃草之间的时间）的最大值。

## 说明/提示

在这个例子中，我们有 $5$ 头奶牛（按输入中的顺序编号为 $1\dots 5$）。奶牛 $4$ 最先到达（时间 $10$），在她吃完之前（时间 $27$）奶牛 $1$ 和奶牛 $3$ 都到达了。由于奶牛 $1$ 拥有较深的资历，所以她先吃，从她到达开始共计等待了 $2$ 个单位时间。她在时间 $30$ 结束吃草，随后奶牛 $3$ 开始吃草，从她到达开始共计等待了 $10$ 单位时间。在一段没有奶牛吃草的时间过后，奶牛 $5$ 到达，在她正在吃草的时间里奶牛 $2$ 也到达了，在 $5$ 个单位时间之后能够吃到草。相比到达时间等待最久的奶牛是奶牛 $3$。

## 样例 #1

### 输入

```
5
25 3
105 30
20 50
10 17
100 10```

### 输出

```
10```

# AI分析结果



### 综合分析与结论
本题需模拟奶牛按到达时间和资历排队的场景，核心在于高效管理等待队列并计算最长等待时间。最优解法均采用排序+优先队列，时间复杂度O(n log n)，关键差异体现在时间推进逻辑与边界处理。

---

### 高分题解推荐

#### 1. 作者：slzs（⭐⭐⭐⭐⭐）
**核心亮点**：  
- 极简的时间推进逻辑，直接在循环中处理队列与时间更新  
- 巧妙处理「队列空但有新到达奶牛」的边界情况  
- 代码简洁高效，无冗余操作  

**核心代码**：
```cpp
priority_queue<pair<int,int>> q; // 存储负资历+索引
sort(a+1,a+1+n,cmp); // 按到达时间排序
q.push(make_pair(-a[1].lis,1));

while(i<=n || !q.empty()) {
    if(q.empty()) { // 处理队列空但有新奶牛的情况
        q.push(make_pair(-a[i].lis,i));
        top = a[i].tim;
        i++;
    }
    // 取出队列头并计算等待时间
    int x = q.top().second; q.pop();
    maxn = max(maxn, top - a[x].tim);
    top += a[x].cost;
    // 将期间到达的奶牛入队
    while(i<=n && a[i].tim<=top) 
        q.push(make_pair(-a[i].lis,i)), i++;
}
```

#### 2. 作者：damage（⭐⭐⭐⭐）
**核心亮点**：  
- 显式维护结束时间(et)，分情况处理「立即吃草」与「加入队列」  
- 处理剩余队列的显式循环确保完整性  
- 详细注释与边界处理（如i--回退）

**关键处理逻辑**：
```cpp
for(奶牛i){
    if(到达时间 >= et) {
        if(队列空) 直接吃草;
        else 处理队列头并更新et;
        if(新et仍<到达时间) i--; // 关键回退逻辑
    }
    else 加入队列;
}
while(!队列空) 处理剩余奶牛;
```

#### 3. 作者：__Hacheylight__（⭐⭐⭐⭐）
**核心亮点**：  
- 分离「时间推进」与「队列填充」阶段  
- 使用结构体运算符重载提高可读性  
- 显式处理所有到达事件，逻辑清晰

---

### 最优解法关键思路
1. **双阶段处理**：先按到达时间排序，再用优先队列管理等待队列
2. **时间推进**：维护当前时间点，在每次处理完奶牛后更新时间为结束时间
3. **资历管理**：优先队列按资历排序（通过存储负值或重载运算符）
4. **边界处理**：处理队列空时直接接纳新到达奶牛，剩余队列单独处理

---

### 同类型题目推荐
1. [P2058 海港](https://www.luogu.com.cn/problem/P2058) - 滑动窗口+队列管理  
2. [P2278 操作系统](https://www.luogu.com.cn/problem/P2278) - 进程调度模拟  
3. [P4053 建筑抢修](https://www.luogu.com.cn/problem/P4053) - 贪心+优先队列  

---

### 题解中的调试心得
1. **Zenith_Yeh**提到需要特别注意「奶牛刚好在结束时间到达」的边界条件  
2. **damage**强调处理`i--`回退以避免跳过事件，这是模拟时间推进的常见陷阱  
3. **slzs**通过优先队列存储负资历简化比较逻辑，体现STL的灵活运用

---
处理用时：56.37秒
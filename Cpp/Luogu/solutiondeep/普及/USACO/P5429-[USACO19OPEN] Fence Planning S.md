# 题目信息

# [USACO19OPEN] Fence Planning S

## 题目描述

Farmer John 的 $ N $ 头奶牛，编号为 $ 1 \ldots N $ （ $ 2 \leq N \leq 10^5 $ ），拥有一种围绕“哞网”，一些仅在组内互相交流却不与其他组进行交流的奶牛小组，组成的复杂的社交网络。

每头奶牛位于农场的二维地图上的不同位置 $ (x,y) $ ，并且我们知道有 $ M $ 对奶牛( $ 1 \leq M<10^5 $ )会相互哞叫。两头相互哞叫的奶牛属于同一哞网。

为了升级他的农场，Farmer John 想要建造一个四边与 $ x $ 轴和 $ y $ 轴平行的长方形围栏。Farmer John 想要使得至少一个哞网完全被围栏所包围（在长方形边界上的奶牛计为被包围的）。请帮助 Farmer John 求出满足他的要求的围栏的最小可能周长。有可能出现这一围栏宽为 $0$ 或高为 $0$ 的情况。

## 样例 #1

### 输入

```
7 5
0 5
10 5
5 0
5 10
6 7
8 6
8 4
1 2
2 3
3 4
5 6
7 6```

### 输出

```
10```

# AI分析结果



### 综合分析与结论
本题核心在于找到各连通块的坐标极值，计算最小包围矩形周长。所有题解均采用连通块处理，主要分为DFS和并查集两类方法。DFS存在递归栈溢出风险，而并查集在合并时维护极值是最优解。

---

### 精选题解与评分

#### 1. 作者：purinliang（★★★★★）
**关键亮点**：  
- **实时维护极值**：在并查集合并时直接更新连通块的极值，避免后续遍历。
- **高效路径压缩**：保证近似线性的时间复杂度，适合大数据量。
**代码核心**：
```cpp
void union_set(int x, int y) {
    int fx = find_par(x), fy = find_par(y);
    if (fx != fy) {
        par[fy] = fx;
        u[fx] = max(u[fx], u[fy]); // 合并上下左右极值
        d[fx] = min(d[fx], d[fy]);
        l[fx] = min(l[fx], l[fy]);
        r[fx] = max(r[fx], r[fy]);
    }
}
```

#### 2. 作者：微芒晨曦（★★★★）
**关键亮点**：  
- **两次并查集处理**：先建立连通关系，后统一更新极值。
- **路径压缩优化**：确保父节点统一，便于极值统计。  
**个人心得**：  
> "在合并后需二次遍历所有节点更新极值，虽增加O(n)时间，但思路清晰易理解。"

#### 3. 作者：localhost（★★★★）
**关键亮点**：  
- **极值分离维护**：独立处理x和y的最大最小值，逻辑清晰。  
**核心代码**：
```cpp
for(int i=1;i<=n;++i){
    int fa = find(i);
    X[fa] = min(X[fa], a[i].x);
    XX[fa] = max(XX[fa], a[i].x);
    // 类似处理Y方向极值...
}
```

---

### 最优思路总结
**并查集极值合并**：在合并两个集合时，立即更新父节点的坐标极值（max/min），确保后续查询时无需额外遍历。此方法将时间复杂度优化至近线性，显著优于DFS的潜在栈溢出风险。

---

### 拓展与举一反三
- **同类问题**：涉及连通块属性（如面积、直径）的题目，均可采用类似极值维护策略。
- **优化套路**：在并查集/DFS/BFS中嵌入辅助信息（极值、总和等），实时更新以降低复杂度。

---

### 推荐练习题
1. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)（并查集基础）  
2. [P1197 星球大战](https://www.luogu.com.cn/problem/P1197)（逆向维护连通块）  
3. [P2330 繁忙的都市](https://www.luogu.com.cn/problem/P2330)（最小生成树与连通性结合）

---
处理用时：128.65秒
# 题目信息

# [USACO20JAN] Berry Picking S

## 题目描述

Bessie 和她的妹妹 Elsie 正在 Farmer John 的浆果园里采浆果。Farmer John 的浆果园里有 $N$ 棵浆果树（$1 \leq N \leq 1000$）；树 $i$ 上有 $B_i$ 个浆果（$1 \leq B_i \leq 1000$）。Bessie 有 $K$ 个篮子（$1 \leq K \leq 1000$，$K$ 为偶数）。每个篮子里可以装同一棵树上采下的任意多个浆果，但是不能装来自于不同的树上的浆果，因为它们的口味可能不同。篮子里也可以不装浆果。

Bessie 想要使得她得到的浆果数量最大。但是，Farmer John 希望 Bessie 与她的妹妹一同分享，所以 Bessie 必须将浆果数量较多的 $K/2$ 个篮子给 Elsie。这表示 Elsie 很有可能最后比 Bessie 得到更多的浆果，这十分不公平，然而姐妹之间往往就是这样。

帮助 Bessie 求出她最多可以得到的浆果数量。

## 说明/提示

### 样例解释

如果 Bessie 在

- 一个篮子里装树 2 的 6 个浆果
- 两个篮子里每个装树 3 的 4 个浆果
- 一个篮子里装树 4 的 4 个浆果

那么她能够得到两个各装有 4 个浆果的篮子，总共 8 个浆果。

### 子任务

- 测试点 $1 \sim 4$ 满足 $K \leq 10$。
- 测试点 $5 \sim 11$ 没有额外限制。

## 样例 #1

### 输入

```
5 4
3 6 8 4 2```

### 输出

```
8```

# AI分析结果



### 综合分析与结论
各题解核心思路高度一致，均采用枚举每篮最小值m的策略，通过计算满篮数并处理余数的方式求解。所有解法均能在O(N·maxB)时间复杂度下通过（maxB≤1000）。关键难点在于正确分类讨论满篮数与K的关系，以及余数的贪心处理。

---

### 精选题解及评分
#### 1. gznpp（★★★★☆）
**关键亮点**：  
- 采用分情况讨论框架，逻辑层次清晰  
- 使用排序代替优先队列，降低常数开销  
- 代码结构简洁，变量命名规范  

**核心代码**：
```cpp
for(int t=1;t<=mx;t++) {
    int full = 0; // 计算满篮数
    // ...略...
    sort(a + 1, a + n + 1, cmp); // 按余数排序
    // 贪心选取余数补足篮子
}
```

#### 2. KaisuoShutong（★★★★☆）
**关键亮点**：  
- 数学推导清晰，给出三种情况的严格证明  
- 使用优先队列自动处理余数排序  
- 代码极其简洁（仅20行核心逻辑）  

**个人心得**：  
> "最多的那半篮子应该都相同"——通过数学推导得出关键结论，避免盲目尝试。

#### 3. zzw4257（★★★★☆）
**关键亮点**：  
- 用生动的数学描述解释问题本质  
- 独创性的子序列转化思路  
- 采用快速排序优化余数处理  

**核心思想**：  
> "前K/2大元素的最小值尽量大" 转化为对余数的贪心选择。

---

### 关键思路总结
**枚举+贪心框架**：  
1. 枚举每篮浆果数m（1 ≤ m ≤ maxB）
2. 计算所有树能提供的满篮数full
3. 分类处理：
   - full < K/2 → 舍弃
   - full ≥ K → 直接取K/2篮
   - 中间状态 → (full-K/2)篮 + 最大余数补足
4. 维护全局最大值

**优化技巧**：  
- 提前终止无效枚举（当full < K/2时break）  
- 余数处理使用O(n)空间存储，避免实时计算  

---

### 拓展与相似题目
**同类型题目套路**：  
- 答案枚举与验证（如P2440木材加工）  
- 两段式贪心（先取固定值，再处理余数）  

**推荐练习**：  
1. P1090 [NOIP2004 提高组] 合并果子（贪心+优先队列）  
2. P1208 [USACO1.3]混合牛奶（价格排序+贪心）  
3. P2440 木材加工（二分答案验证）  

---

### 核心代码实现
以gznpp解法为例的关键逻辑：
```cpp
for(int t=1; t<=maxB; t++) {
    int full = 0;
    for(int i=1; i<=n; i++) 
        full += a[i]/t;
    
    if(full < k/2) break;
    if(full >= k) {
        ans = max(ans, k/2 * t);
        continue;
    }
    
    sort(a+1, a+n+1, [t](int x,int y){ 
        return x%t > y%t; 
    });
    
    int sum = (full - k/2) * t;
    for(int i=1; i<=k-full; i++) 
        sum += a[i] % t;
    
    ans = max(ans, sum);
}
```

---
处理用时：51.56秒
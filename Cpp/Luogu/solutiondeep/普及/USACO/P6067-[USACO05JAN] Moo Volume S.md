# 题目信息

# [USACO05JAN] Moo Volume S

## 题目描述

Farmer John 的农场上有 $N$ 头奶牛（$1 \leq N \leq 10^5$），第 $i$ 头奶牛的位置为 $x_i$（$0 \leq x_i \leq 10^9$）。

奶牛很健谈，每头奶牛都和其他 $N-1$ 头奶牛聊天。第 $i$ 头奶牛和第 $j$ 头奶牛聊天时，音量为 $|x_i-x_j|$。

请您求出所有奶牛聊天音量的总和。

## 说明/提示

- 子任务 1（原测试数据，1 分）：$N \leq 10^4$；
- 子任务 2（99 分）：无特殊限制。

## 样例 #1

### 输入

```
5
1
5
3
2
4```

### 输出

```
40```

# AI分析结果



### 综合分析与结论
该题核心在于高效计算有序序列的差值绝对值总和。所有题解均采用排序后数学优化的思路，将复杂度从 O(n²) 降为 O(n log n)。关键技巧是：利用排序后的单调性，通过前缀和快速计算每个元素的贡献值。

---

### 高星题解推荐

#### 1. 作者：_ouhsnaijgnat_ ⭐⭐⭐⭐⭐
**关键亮点**  
- 清晰推导公式转化过程，通过拆解绝对值转化为线性表达式  
- 使用倒序循环简化前缀和计算  
- 代码简洁且包含详细注释  

**核心代码**  
```cpp
sort(a+1,a+1+n);
for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
for(int i=n;i>=1;i--) 
    ans += labs(sum[i-1] - a[i]*(i-1));
cout<<ans*2;
```
**实现思想**  
排序后倒序计算每个元素与前面所有元素的差值总和，利用前缀和避免重复计算。

#### 2. 作者：Kalium ⭐⭐⭐⭐
**关键亮点**  
- 通过具体数学示例推导通用公式  
- 强调排序必要性并解释数学原理  
- 代码包含详细变量类型声明  

**核心代码**  
```cpp
sort(a + 1, a + 1 + n);
for(int i=1;i<=n;i++) 
    pre[i] = pre[i-1] + a[i];
for(int i=1;i<=n;i++) 
    ans += a[i] * (i-1) - pre[i-1];
cout<<ans*2;
```
**个人心得**  
"必须排序才能保证单调性，否则无法将绝对值转化为简单线性表达式"。

#### 3. 作者：Hexarhy ⭐⭐⭐⭐
**关键亮点**  
- 提出单向贡献计算再乘2的思路  
- 使用正序循环与更直观的公式表达  
- 完整处理边界条件和数据范围  

**核心代码**  
```cpp
sort(a+1,a+1+n);
for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i];
for(int i=1;i<=n;i++)
    ans += (s[n]-s[i] - (n-i)*a[i]);
cout<<ans*2;
```

---

### 最优关键思路总结
**核心技巧**：  
1. **排序建立单调性**：确保所有后续计算可转化为线性运算  
2. **前缀和优化**：预处理前i项和，将单点计算复杂度降至O(1)  
3. **贡献拆分**：将每个元素的贡献分解为 `当前值×数量 - 前缀和`  
4. **对称性利用**：只计算单向关系，最终结果乘2  

**数学推导**：  
对于排序后元素a[i]，其与前面所有元素的差值和为：  
`Σ(a[i]-a[j]) = a[i]*(i-1) - Σa[j] (j=1→i-1)`  

**复杂度控制**：  
- 排序 O(n log n)  
- 前缀和预处理 O(n)  
- 最终计算 O(n)  

---

### 拓展与举一反三
**同类问题套路**：  
- 处理有序序列的差值相关计算  
- 利用前缀和/线段树维护区间信息  
- 对称性问题转化为单向计算  

**推荐题目**：  
1. P1908 逆序对（前缀和/归并排序应用）  
2. P1115 最大子段和（前缀和变形）  
3. P1719 查找区间最大值（前缀极值应用）  

**调试经验**：  
- 必须使用long long防止溢出  
- 排序后下标需从1开始保持统一  
- 计算时注意边界条件（如i=1时无前项）

---
处理用时：53.11秒
# 题目信息

# [USACO17JAN] Hoof, Paper, Scissor S

## 题目背景

*本题与 [金组同名题目](/problem/P3609) 在题意上一致，唯一的差别在于对变手势次数的限制。*

## 题目描述

你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。

“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。

现在 FJ 和 Bassie 要进行 $N$ 轮对抗。Bassie 已经预测了 FJ 每一轮要出的手势。然而 Bassie 很懒，她最多只想变换一次手势。

现在请你帮 Bassie 求出她最多能赢多少轮。

## 样例 #1

### 输入

```
5
P
P
H
P
S```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
该问题核心在于将序列分割为最多两段（可能不分割），求每段选最优手势后的最大胜利次数。各题解主要采用前缀和、后缀和或动态规划思路。最优解法为前缀和法，时间复杂度为 O(n)，空间复杂度 O(n)，代码简洁高效。

---

### 精选题解与评分

#### 1. OfstAutomataMachine（5星）
**关键亮点**：
- 使用前缀和预处理每个位置前的各手势胜利次数。
- 枚举分割点，计算前后两段的最大值之和，逻辑清晰。
- 代码简洁（仅25行），时间复杂度 O(n)，空间优化到位。

**核心代码**：
```cpp
// 前缀和预处理
for(int i=1;i<=n;i++) {
    s[i]=s[i-1]; p[i]=p[i-1]; h[i]=h[i-1];
    if(c=='S') s[i]++;
    if(c=='P') p[i]++;
    if(c=='H') h[i]++;
}
// 枚举分割点求最大值
for(int i=1;i<=n;i++) {
    ans = max(
        max(s[i], max(p[i], h[i])) + 
        max(s[n]-s[i], max(p[n]-p[i], h[n]-h[i]))
    );
}
```

#### 2. wylt（4星）
**关键亮点**：
- 详细推导分割点处不同手势组合的胜利公式。
- 预处理总手势数，枚举6种可能的前后手势组合。
- 代码可读性高，但存在冗余计算（如六次条件判断）。

**核心优化点**：
```cpp
// 总手势数预处理
int hc=0, sc=0, pc=0;
for(int i=1; i<=n; i++) { 
    if(c=='H') hc++; 
    else if(c=='S') sc++; 
    else pc++; 
}
// 枚举分割点并组合手势
for(int i=1; i<n; i++) {
    cnt = max(cnt, h[i] + sc - s[i]); // H前段 + S后段
    cnt = max(cnt, h[i] + pc - p[i]); // H前段 + P后段
    ... // 其他组合
}
```

#### 3. Ryo_Yamada（4星）
**关键亮点**：
- 动态规划维护状态：变换次数和当前手势。
- 支持扩展至更多变换次数（如金组题目）。
- 代码稍复杂，但结构清晰，适合动态规划学习。

**状态转移片段**：
```cpp
// dp[i][j][k]表示第i轮变换j次，当前手势k的胜利次数
for(int i=1; i<=n; i++) {
    int t = get_win(a[i]); // 需要出t才能赢此轮
    for(int j=0; j<=K; j++) {
        for(int k=0; k<3; k++) {
            // 不换手势的情况
            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k] + (k == t));
            // 换手势的情况（j>0）
            for(int l=0; l<3; l++) {
                if(l != k && j) {
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][l] + (k == t));
                }
            }
        }
    }
}
```

---

### 关键思路总结
1. **前缀和分割法**：通过预处理每个位置前的手势胜利次数，枚举所有分割点，计算前后两段的最大值之和。时间复杂度 O(n)，为最优解法。
2. **手势对称性简化**：直接统计对手各手势数量，Bessie只需选择对应克制的最高频手势。
3. **动态规划扩展性**：若问题扩展为允许k次变换，可沿用三维DP结构。

---

### 推荐相似题目
1. [P3609 [USACO17JAN] Hoof, Paper, Scissor G](https://www.luogu.com.cn/problem/P3609)（金组扩展版，允许k次变换）
2. [P2679 [NOIP2015 提高组] 子串](https://www.luogu.com.cn/problem/P2679)（动态规划分割子串）
3. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)（前缀和求极值基础）

---
处理用时：59.07秒
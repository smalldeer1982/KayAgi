# 题目信息

# [USACO20FEB] Timeline G

## 题目描述

Bessie 在过去的 $M$ 天内参加了 $N$ 次挤奶。但她已经忘了她每次挤奶是在哪个时候了。

对于第 $i$ 次挤奶，Bessie 记得它不早于第 $S_i$ 天进行。另外，她还有 $C$ 条记忆，每条记忆形如一个三元组 $(a,b,x)$，含义是第 $b$ 次挤奶在第 $a$ 次挤奶结束至少 $x$ 天后进行。

现在请你帮 Bessie 算出在满足所有条件的前提下，每次挤奶的最早日期。

保证 Bessie 的记忆没有错误，这意味着一定存在一种合法的方案，使得：

- 第 $i$ 次挤奶不早于第 $S_i$ 天进行，且不晚于第 $M$ 天进行；
- 所有的记忆都得到满足；

## 说明/提示

- 测试点 $2 \sim 4$ 满足 $N,C \leq 10^3$。
- 测试点 $5 \sim 10$ 没有特殊限制。

## 样例 #1

### 输入

```
4 10 3
1 2 3 4
1 2 5
2 4 2
3 4 4```

### 输出

```
1
6
3
8```

# AI分析结果



### 综合分析与结论
该题核心是求解带约束的最早时间安排，本质为**DAG上的动态规划**或**最长路问题**。所有题解可归纳为两类思路：
1. **拓扑排序**：利用约束构建DAG，按拓扑序递推时间，时间复杂度O(N+C)。
2. **差分约束**：转化为最长路问题，通过SPFA求解，时间复杂度O(C)~O(NC)。

拓扑排序是更优解法，因为题目保证无环，直接拓扑递推即可高效解决。差分约束虽正确但效率略低，适用于更一般的约束场景。

---

### 高评分题解推荐

#### 1. 作者：StudyingFather（⭐⭐⭐⭐⭐）
**关键亮点**：
- 思路清晰，直接点明DAG性质，拓扑排序递推是自然选择。
- 代码简洁，利用链式前向星存图，入度数组动态维护。
- 时间复杂度严格线性，无冗余操作。

**核心代码思路**：
```cpp
// 建图与拓扑排序核心
for(int i=1;i<=n;i++) if(!indeg[i]) q.push(i); // 初始入度为0的节点
while(!q.empty()) {
    int u = q.front(); q.pop();
    for(遍历u的所有出边) {
        v的入度减1，更新s[v] = max(s[v], s[u] + w);
        if(v入度为0)入队
    }
}
```

#### 2. 作者：Hexarhy（⭐⭐⭐⭐）
**关键亮点**：
- 详细解释拓扑排序的正确性，强调递推式`max`操作的意义。
- 使用vector存图，代码可读性高。
- 明确点出超级源点思想的替代方案。

**个人心得摘录**：
> "题目要求的是‘最早’，实际上要同时满足两个限制，只能选更后的日期。递推式为`S_i = max{S_i, S_pre + v}`"

#### 3. 作者：king_xbz（⭐⭐⭐⭐）
**关键亮点**：
- 提供完整代码框架，注释清晰。
- 强调邻接表的选择（链式前向星），避免邻接矩阵的空间问题。
- 简明扼要的拓扑排序实现。

---

### 最优思路总结
**关键技巧**：
1. **DAG建模**：将时间约束视为有向边，构建DAG。
2. **拓扑序递推**：初始化时间为S_i，按拓扑序用`max(s[v], s[u]+w)`更新后续节点。
3. **超级源点简化**：将初始时间S_i转化为从虚拟节点0出发的边，统一处理。

**同类型题套路**：
- 任务调度问题（关键路径）
- 带不等式约束的最优化问题
- DAG上的动态规划

---

### 推荐题目
1. [P1113 杂务](https://www.luogu.com.cn/problem/P1113)（拓扑排序经典题）
2. [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)（差分约束基础）
3. [P6145 [USACO20FEB]Timeline G](https://www.luogu.com.cn/problem/P6145)（本题，可对比不同解法）

---
处理用时：39.06秒
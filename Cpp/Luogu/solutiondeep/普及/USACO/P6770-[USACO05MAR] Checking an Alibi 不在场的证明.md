# 题目信息

# [USACO05MAR] Checking an Alibi 不在场的证明

## 题目描述

农场有 $F$ 个点，已知 $P$ 条边以及每条边的起点终点和通过时间，给出 $C$ 个有牛的点，求在规定时间 $M$ 内能从起点到达牛当前位置的牛的数量，并按升序输出牛的编号。

谷仓里发现谷物被盗！FJ 正试图从 $C$ 只奶牛里找出那个偷谷物的罪犯。幸运的是，一个恰好路过的卫星拍下谷物被盗前 $M$ 秒的农场的图片。这样约翰就能通过牛们的位置来判断谁有足够的时间来盗窃谷物。

约翰农场有 $F$ 草地，标号 $1$ 到 $F$，还有 $P$ 条双向路连接着它们。通过这些路需要的时间在 $1$ 到 $70000$ 秒的范围内。田地 $1$ 上建有那个被盗的谷仓。给出农场地图，以及卫星照片里每只牛所在的位置，请判断哪些牛有可能犯罪。

请注意：数据里可能存在重边（起点和终点相同的边）。

## 说明/提示

#### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/ik4552lc.png)

#### 数据约定

对于 $100\%$ 的数据：$1 \le M \le 70000$，$1 \le C \le 100$，$1 \le P \le 1000$，$1 \le F \le 500$。

## 样例 #1

### 输入

```
7 6 5 8
1 4 2
1 2 1
2 3 6
3 5 5
5 4 6
1 7 9
1
4
5
3
7```

### 输出

```
4
1
2
3
4```

# AI分析结果



### 综合分析与结论
本题核心为单源最短路问题，所有题解均正确识别出需计算从谷仓（点1）到各点的最短路径，并筛选符合时间约束的牛。各解法的差异集中在算法选择（Dijkstra/SPFA/BFS）与实现细节。正确解法需满足以下要点：
1. 处理重边时取最小权值
2. 输出牛的原输入顺序编号而非点编号
3. 时间复杂度需适应 F≤500 的规模

---

### 优质题解推荐

#### 1. [WanderingTrader] Dijkstra堆优化版 (⭐⭐⭐⭐⭐)
**核心亮点**：
- 提供朴素版与堆优化版双实现，适配不同数据规模
- 完整处理输入输出逻辑，包含编号排序细节
- 代码结构清晰，链式前向星存储高效

**关键代码**：
```cpp
void dijkstra(int n,int s) {
    priority_queue<node> Q;
    Q.push({s,0});
    while(!Q.empty()) {
        int u=Q.top().u; Q.pop();
        if(vis[u]) continue;
        vis[u]=true;
        for(int i=h[u];i;i=e[i].next) {
            int v=e[i].v;
            if(d[v] > d[u]+e[i].w) {
                d[v] = d[u]+e[i].w;
                Q.push({v, d[v]});
            }
        }
    }
}
```
**实现思想**：堆优化Dijkstra，优先队列维护待处理节点，时间复杂度 O(M + NlogN)

---

#### 2. [一只书虫仔] SPFA解法 (⭐⭐⭐⭐)
**核心亮点**：
- 直击问题本质，代码简洁高效
- 正确强调统计答案时的编号处理
- 适合快速解题场景

**统计逻辑代码**：
```cpp
for(int i=1; i<=c; i++){
    scanf("%d",&x);
    if(dist[x] <= limit) ans[++cnt] = i; // 记录原输入编号
}
```
**个人心得**：  
> "统计答案时容易错，需注意存储的是牛的编号而非点编号"

---

#### 3. [封禁用户] Dijkstra堆优化 (⭐⭐⭐⭐)
**核心亮点**：
- 标准模板化实现，可读性强
- 使用`pair<int,int>`维护优先队列
- 完整处理双向边添加

**代码亮点**：
```cpp
typedef pair<int,int> pii;
priority_queue<pii, vector<pii>, greater<pii>> q;
q.push({0,1}); // first为距离，second为节点
```

---

### 关键思路总结
1. **算法选择**：正权图首选Dijkstra（堆优化O(MlogN)），若数据较弱可用SPFA(O(kM))
2. **重边处理**：建图时取最小边权 `e[u][v] = min(e[u][v], w)`
3. **输出技巧**：存储牛的原始输入顺序，筛选后直接输出编号
4. **数据结构**：邻接表/链式前向星存储稀疏图，避免邻接矩阵MLE

---

### 拓展与相似题目
1. **同类型题目**：
   - [P4779 【模板】单源最短路径（标准Dijkstra）](https://www.luogu.com.cn/problem/P4779)
   - [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
   - [P1629 邮递员送信（往返最短路）](https://www.luogu.com.cn/problem/P1629)

2. **思维延伸**：
   - 多起点最短路：建立超级源点
   - 带限制的最短路：分层图/Dijkstra状态扩展

---

### 易错点提醒（来自题解心得）
1. **编号混淆**：输出的是牛的原输入序号，而非农场编号
2. **初始化错误**：未将`dis[1]`设为0，或未重置`vis`数组
3. **重边遗漏**：未取最小边权导致最短路计算错误
4. **队列优化**：SPFA需判断节点是否已在队列，避免重复入队

---
处理用时：59.66秒
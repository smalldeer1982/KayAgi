# 题目信息

# [USACO21JAN] No Time to Paint S

## 题目描述

Bessie 最近收到了一套颜料，她想要给她的牧草地一端的栅栏上色。栅栏由 $N$ 个 1 米长的小段组成（$1≤N≤10^5$）。Bessie 可以使用 26 种不同的颜色，她将这些颜色由浅到深用字母 'A' 到 'Z' 标号（'A' 是很浅的颜色，'Z' 是很深的颜色）。从而她可以用一个长为 $N$ 且每个字符均为字母的字符串来描述她想要给栅栏的每一小段涂上的颜色。 

初始时，所有栅栏小段均未被上色。Bessie 一笔可以给任意连续若干小段涂上同一种颜色，只要她不会在较深的颜色之上涂上较浅的颜色（她只能用较深的颜色覆盖较浅的颜色）。 

例如，一段长为 4 的未被涂色的栅栏可以按如下方式上色：

`.... -> BBB. -> BBLL -> BQQL`

由于时间紧迫，Bessie 认为她可能需要放弃为栅栏上某个连续的区间上色！现在，她正在考虑 $Q$ 个候选的区间（$1≤Q≤10^5$），每个区间用满足 $1≤a≤b≤N$ 的两个整数 $(a,b)$ 表示，为需要不上色的小段 $a…b$ 的两端点位置。 

对于每个候选区间，将所有区间外的栅栏小段都涂上所希望的颜色，并且区间内的栅栏小段均不涂色，最少需要涂多少笔？注意在这个过程中 Bessie 并没有真正进行任何的涂色，所以对于每个候选区间的回答是独立的。 

## 说明/提示

在这个样例种，除去目标颜色 `BAAB` 所对应的区间，涂上颜色需要四笔，而除去 `ABBA` 仅需三笔。

`.... -> AA.. -> ABBB -> ABCB`

#### 测试点性质：

 - 测试点 1-4 满足 $N,Q≤100$。
 - 测试点 5-7 满足 $N,Q≤5000$。
 - 测试点 8-13 没有额外限制。

供题：Andi Qu，Brian Dean 

## 样例 #1

### 输入

```
8 2
ABBAABCB
3 6
1 4```

### 输出

```
4
3```

# AI分析结果



### 综合分析与结论  
本题的核心在于预处理前后缀的最小涂色次数，通过维护当前可用颜色状态，快速合并左右区间的结果。最优解法通过两次遍历预处理前缀数组`pre`和后缀数组`suf`，每个查询在O(1)时间内完成，时间复杂度为O(N+Q)。

---

### 高星题解推荐  

1. **作者：JiaY19（5星）**  
   **关键亮点**：  
   - 代码简洁，直接两次遍历预处理前后缀。  
   - 维护标记数组`v`，动态清除比当前颜色深的标记，保证状态正确性。  
   **核心代码**：  
   ```cpp
   for(int i=1;i<=n;i++) {
       pre[i] = pre[i-1];
       // 清除比当前颜色深的标记
       for(int j = a[i] - 'A' + 1; j < 26; j++) v[j] = 0;
       if(!v[a[i]-'A']) pre[i]++, v[a[i]-'A'] = 1;
   }
   // 类似处理后缀数组suf
   ```

2. **作者：Skies（5星）**  
   **关键亮点**：  
   - 与官方题解思路一致，逻辑清晰。  
   - 维护`min_since_last`数组，动态更新颜色状态，避免重复计数。  
   **核心代码**：  
   ```cpp
   for(int i=1;i<=n;i++) {
       int cur = s[i-1]-'A';
       for(int c=0;c<26;c++) min_since_last[c] = min(cur, min_since_last[c]);
       pre[i] = pre[i-1];
       if(min_since_last[cur] < cur) pre[i]++;
       min_since_last[cur] = cur;
   }
   ```

3. **作者：Lonely_NewYear（4星）**  
   **关键亮点**：  
   - 引入单调栈维护有效颜色，避免无效颜色干扰。  
   - 代码简洁，逻辑类似前后缀预处理。  
   **核心代码**：  
   ```cpp
   while(top && a[stk[top]] > a[i]) mp1[a[stk[top]]]--, top--;
   if(!mp1[a[i]]) res++;
   pre[i] = res;
   ```

---

### 关键思路与技巧总结  
1. **前后缀预处理**：将问题拆分为前缀和后缀的独立处理，通过预处理数组快速合并结果。  
2. **颜色状态维护**：在处理每个位置时，动态清除比当前颜色深的标记，确保后续计算的正确性。  
3. **单调栈优化**：利用栈结构维护当前有效颜色，避免无效颜色的干扰。  

---

### 个人心得摘录  
- **aaki**提到比赛时误入分治算法，转而发现前后缀预处理更高效，强调预处理的重要性。  
- **Skies**的代码参考官方题解，提醒在时间紧迫时参考标准解法。  

---

### 相似题目推荐  
1. **P1886 滑动窗口**（单调队列维护区间极值）  
2. **P1901 发射站**（单调栈处理相邻关系）  
3. **P3146 [USACO16OPEN]248 G**（区间DP与合并类问题）  

---

### 核心代码实现（以JiaY19为例）  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,f[100010],f2[100010];
char a[100010];
int main() {
    cin>>n>>q>>(a+1);
    int v[26]={0};
    for(int i=1;i<=n;i++) {
        f[i]=f[i-1];
        for(int j=a[i]-'A'+1;j<26;j++) v[j]=0;
        if(!v[a[i]-'A']) f[i]++, v[a[i]-'A']=1;
    }
    memset(v,0,sizeof(v));
    for(int i=n;i>=1;i--) {
        f2[i]=f2[i+1];
        for(int j=a[i]-'A'+1;j<26;j++) v[j]=0;
        if(!v[a[i]-'A']) f2[i]++, v[a[i]-'A']=1;
    }
    while(q--) {
        int l,r; cin>>l>>r;
        cout<<f[l-1]+f2[r+1]<<endl;
    }
    return 0;
}
```

---
处理用时：69.91秒
# 题目信息

# [USACO21FEB] Year of the Cow S

## 题目描述

Farmer John 的奶牛们得知最近正在庆祝牛年的到来时十分兴奋。牛年总是奶牛们的最爱。

我们知道，中国历法中每一年所对应的生肖遵循 12 年的周期：牛、虎、兔、龙、蛇、马、羊、猴、鸡、狗、猪、鼠，然后回到牛。而鲜为人知的事实是每当牛年来临时神秘的时间之门将会打开，使得奶牛们可以穿越时空前往任意过去或将来的牛年。

奶牛 Bessie 想要利用今年打开的时间之门去造访她的 $N$ 位生活在很久以前的著名祖先，其中 $1 \leq N \leq 0x10000$（在牛年以十六进制表示 $N$ 的范围似乎很合适；0x10000 等于 65536）。

不幸的是，时空旅行多了会使 Bessie 感到头晕，所以她希望至多进行 $K$ 次时空穿越（$1 \leq K \leq N$）。请帮助 Bessie 求出她至多进行 $K$ 次时空穿越时，她造访所有祖先并回到当前年份至少需要花费的年数。

如果在某个牛年 Bessie 不想要使用时空之门，她可以不使用。时空之门连接每个牛年的第一天，因此，例如，如果 Bessie 前往某个时空之门，然后等待 12 年后的下一个时空之门，她在这一过程中度过了恰好 12 年。Bessie 从今年的第一天开始她的旅行，所以她可以立刻进行时空穿越。所有 Bessie 的祖先都不生活在牛年。


## 说明/提示

一种 Bessie 在 36 年内造访所有祖先并返回的方式如下：

 - 进入时空之门，回到 48 年前。
 - 等待 12 年，然后进入 36 年前的时空之门，回到 108 年前。
 - 等待 24 年，然后进入 84 年前的时空之门，回到当前年份。

供题：Brian Dean，David Yang

## 样例 #1

### 输入

```
5 3
101
85
100
46
95```

### 输出

```
36```

# AI分析结果



### 综合分析与结论
本题的核心在于将年份转换为12年周期块，并通过贪心策略选择最大的间隔以减少总时间。关键在于正确转换年份、计算块间间隔，并利用优先队列或排序选择最优跳跃点。

### 评分较高的题解

#### 题解作者：feicheng (5星)
**关键亮点**：  
- 将年份转换为块并去重，避免重复计算。  
- 利用优先队列高效选取最大间隔，减少总时间。  
- 代码结构清晰，处理了去重和间隔计算的细节。

**核心代码解析**：  
```cpp
// 转换年份为块并去重
for (int i=1; i<=n; ++i) {
    cin >> a[i];
    a[i] = a[i]/12 + 1; // 转换为块编号
}
sort(a+1, a+n+1);
// 去重得到必须访问的块
for (int i=1; i<=n; ++i) {
    if (tim[cnt] != a[i]/12+1) tim[++cnt] = a[i]/12+1;
}
// 计算块间间隔并存入优先队列
priority_queue<int> Q;
for (int i=1; i<=cnt; ++i) {
    Q.push(tim[i] - tim[i-1] - 1);
}
// 跳过最大的k-1个间隔
int res = cnt*12; // 初始时间为块数*12
for (int i=1; i<k; ++i) {
    if (Q.empty()) break;
    res -= Q.top()*12; // 减去跳过的间隔时间
    Q.pop();
}
```

#### 题解作者：miao5 (4星)
**关键亮点**：  
- 简洁的代码实现，直接计算块间差值。  
- 通过排序差值数组快速选取最大间隔。  
- 未显式去重但通过排序隐式处理。

**核心代码**：  
```cpp
sort(a+1, a+n+1);
int ans = a[n] * 12; // 最大块的时间
for (int i=1; i<=n; i++) 
    b[i] = a[i-1] - a[i]; // 计算间隔差值
sort(b+1, b+n+1); 
// 取前k-1个最大间隔
for (int i=1; i<=k-1; i++) 
    ans += (b[i] + 1) * 12; 
```

#### 题解作者：ZillionX (4星)
**关键亮点**：  
- 使用`set`自动去重和排序。  
- 利用`multiset`降序存储间隔，快速选取最大间隔。  
- 代码简洁但逻辑稍复杂。

**核心代码**：  
```cpp
set<int> s;
for (int i=1; i<=n; i++) {
    int x; cin >> x;
    s.insert((x+11)/12); // 转换为块
}
int max_block = *s.rbegin();
multiset<int, greater<int>> gaps;
// 计算间隔
auto prev = s.begin();
for (auto it = next(s.begin()); it != s.end(); ++it) {
    gaps.insert(*prev - *it - 1);
    prev = it;
}
// 跳过k-1个最大间隔
int ans = max_block * 12;
for (int i=0; i<k-1 && !gaps.empty(); i++) {
    ans -= *gaps.begin() * 12;
    gaps.erase(gaps.begin());
}
```

### 最优关键思路总结
1. **年份转换**：将每个年份转换为对应的牛年块（如`(a+11)/12`）。
2. **去重与排序**：去重后按升序排列，便于处理间隔。
3. **间隔计算**：相邻块间的间隔为`当前块 - 前一块 -1`，表示需要等待的12年周期数。
4. **贪心选择**：选取最大的`k-1`个间隔跳过，减少总时间。

### 相似题目推荐
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 优先队列贪心。
2. [P1209 [USACO1.3]修理牛棚](https://www.luogu.com.cn/problem/P1209) - 间隔处理与贪心选择。
3. [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995) - 贪心选择最大/最小跳跃。

---
处理用时：469.74秒
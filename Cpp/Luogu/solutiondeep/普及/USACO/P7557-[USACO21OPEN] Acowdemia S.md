# 题目信息

# [USACO21OPEN] Acowdemia S

## 题目描述

由于对计算机科学的热爱，以及有朝一日成为 「Bessie 博士」的诱惑，奶牛 Bessie 开始攻读计算机科学博士学位。经过一段时间的学术研究，她已经发表了 $N$ 篇论文（$1 \leq N \leq 10^5$），并且她的第 $i$ 篇论文得到了来自其他研究文献的 $c_i$ 次引用（$0 \leq c_i \leq 10^5$）。

Bessie 听说学术成就可以用 $h$ 指数来衡量。$h$ 指数等于使得研究员有至少 $h$ 篇引用次数不少于 $h$ 的论文的最大整数 $h$。例如，如果一名研究员有 $4$ 篇论文，引用次数分别为 $(1,100,2,3)$，则 $h$ 指数为 $2$，然而若引用次数为 $(1,100,3,3)$ 则 $h$ 指数将会是 $3$。

为了提升她的 $h$ 指数，Bessie 计划写至多 $K$ 篇综述（$0 \leq K \leq 10^5$），并在每篇综述中引用许多她曾经写过的论文。然而，由于页数限制，她至多可以在一篇综述中引用 $L$ 篇论文（$0 \leq L \leq 10^5$）。当然，一篇综述中她只能引用一篇论文至多一次（但是一篇论文可以在多篇综述中被引用）。

请帮助 Bessie 求出在写完这些综述后她可以达到的最大 $h$ 指数。Bessie 不可以在一篇综述中引用她写的其他综述。

注意 Bessie 的导师可能会告知她纯粹为了提升 $h$ 指数而写综述存在违反学术道德的嫌疑；我们不建议其他学者模仿 Bessie 的行为。

## 说明/提示

#### 样例说明

在这个样例中，Bessie 可以写至多一篇综述。如果 Bessie 引用她的第一、第三、第四篇论文中的任意一篇，她的 $h$ 指数会变为 $2$。

#### 测试点性质：

- 测试点 $1 \sim 6$ 满足 $N\le 100$。
- 测试点 $7 \sim 16$ 没有额外限制。

#### 说明

供题：Dhruv Rohatgi

## 样例 #1

### 输入

```
4 4 1
1 100 1 1```

### 输出

```
3```

# AI分析结果



### 综合分析
各题解均采用二分答案框架，核心差异在于 `check` 函数的实现方式。最优解法统一为：降序排序数组后，在前 $h$ 篇论文中计算补充次数，并验证单篇补充不超过 $K$、总次数不超过 $K \times L$。关键优化点在于排序策略与循环剪枝。

---

### 精选题解（评分≥4星）

#### 1. 作者：NDFS（评分：★★★★★）
**核心亮点**  
- 思路简明：直接降序排序后处理前 $h$ 个元素  
- 高效剪枝：循环中即时判断单篇补充上限，提前终止无效计算  
- 代码简洁：仅需 20 行核心逻辑，可读性极佳  

**代码片段**  
```cpp
bool check(int x) {
    long long sum = 0;
    for (int i = 1; i <= x; i++) {
        if (c[i] >= x) continue;
        if (x - c[i] > k) return false; // 单篇补充超限
        sum += x - c[i];
        if (sum > (long long)k * l) return false; // 总量超限
    }
    return true;
}
```

#### 2. 作者：Coros_Trusds（评分：★★★★☆）
**核心亮点**  
- 详细注释：完整标注代码逻辑，适合初学者理解  
- 规范编码：使用现代 C++ 特性（Lambda 排序）提升可维护性  
- 边界处理：明确处理 $h=0$ 的极端情况  

**调试经验**  
> "若不降序排序，会将操作次数浪费在小值上" —— 强调排序策略对贪心正确性的关键作用

#### 3. 作者：fangzirui1（评分：★★★★）
**优化技巧**  
- 动态剪枝：在遍历时同步累加总需求，及时跳出无效分支  
- 空间高效：原地排序避免额外内存消耗  

**代码亮点**  
```cpp
for(int i=1; i<=n; i++){
    if(a[i]<mid) s += mid - a[i];
    if(mid - a[i] > K) return 0; // 单篇超限
    if(s > K*L) return 0;       // 总量超限
    if(i == mid) return 1;       // 提前满足条件
}
```

---

### 关键思路总结
1. **降序贪心**：将论文按引用量降序排列，确保优先补充最接近目标的论文  
2. **双重约束验证**：在 `check` 函数中同时校验单篇补充量（≤K）和总补充量（≤K×L）  
3. **提前终止**：当已处理论文数达到目标 $h$ 时立即返回，减少无效计算  

---

### 拓展训练
1. **P2678 跳石头**（二分最小距离极大化）  
2. **P1182 数列分段**（二分最大值最小化）  
3. **P4344 SHOI2015 脑洞治疗仪**（二分+贪心组合应用）  

---

### 调试经验摘录
- **haotian1234**："数组必须降序排序，否则会错误地将操作次数浪费在小值上"  
- **loliygh**："开 long long 避免溢出是 AC 的关键，前几个测试点可能不会暴露此问题"  
- **wangyibo201026**："将综述视为单次操作简化问题，极大降低实现复杂度"

---
处理用时：47.67秒
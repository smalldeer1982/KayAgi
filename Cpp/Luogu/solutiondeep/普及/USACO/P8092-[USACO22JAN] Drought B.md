# 题目信息

# [USACO22JAN] Drought B

## 题目描述

Farmer John 的草地里的草在一场大旱中都干死了。经过数小时的绝望和沉思，Farmer John 想到了一个绝妙的主意，购买玉米来喂养他宝贵的奶牛。

FJ 的 $N$ 头奶牛（$1 \leq N \leq 10^5$）排成一行，队伍中的第 $i$ 头奶牛的饥饿度为 $h_i$（$0 \leq h_i \leq 10^9$）。由于奶牛是社会性动物，她们坚持一起进食，FJ 降低奶牛饥饿度的唯一方法是选择两头相邻的奶牛 $i$ 和 $i+1$ 并分别喂她们一袋玉米，令她们的饥饿度各减少 1。

FJ 想将他的奶牛喂至所有的奶牛都具有相同的非负饥饿度。请帮助 FJ 求出他喂奶牛达到上述状态所需的最少玉米袋数，或者如果不可能达到，输出 $-1$。

## 说明/提示

【样例解释】

对于第一个子测试用例，给奶牛 $2$ 和 $3$ 各两袋玉米，然后给奶牛 $1$ 和 $2$ 各五袋玉米，可以使得所有奶牛的饥饿度均为 $3$。

对于第二个子测试用例，给奶牛 $1$ 和 $2$ 各两袋玉米，奶牛 $2$ 和 $3$ 各两袋玉米，奶牛 $4$ 和 $5$ 各两袋玉米，奶牛 $5$ 和 $6$ 各两袋玉米，可以使得所有奶牛的饥饿度均为 $2$。

对于余下的子测试用例，均不可能使得奶牛们的饥饿度相等。

【数据范围】

- 测试点 2 的所有子测试用例满足 $N \leq 3$ 以及 $h_i\le 100$。

- 测试点 3-8 的所有子测试用例满足 $N\le 100$ 以及 $h_i\le 100$。

- 测试点 9-14 的所有子测试用例满足 $N\le 100$。

- 测试点 15 没有额外限制。

- 此外，测试点 3-5 和 9-11 中的 $N$ 均为偶数，测试点 6-8 和 12-14 中的 $N$ 均为奇数。

## 样例 #1

### 输入

```
5
3
8 10 5
6
4 6 4 4 6 4
3
0 1 0
2
1 2
3
10 9 9```

### 输出

```
14
16
-1
-1
-1```

# AI分析结果



### 综合分析
本题核心在于通过相邻操作使数列等值，关键在于数学推导或贪心调整。多数题解采用两次遍历或数学公式直接求解，时间复杂度O(n)为最优解。

### 精选题解

#### 1. 作者：lsj2009 (★★★★★)
**关键亮点**：  
- 数学推导得出奇偶情况的统一公式，直接计算目标值x，无需调整过程。  
- O(n)时间复杂度，高效处理大数。  
- 详细推导过程，逻辑严谨，代码简洁。  

**核心思路**：  
- 奇偶分类讨论：奇数直接计算x，偶数需满足总和条件。  
- 通过递推式直接计算操作次数，确保非负。  

**代码片段**：  
```cpp
if(n&1){
    int x=0;
    for(int i=1;i<=n;i++) x+=(i&1?1:-1)*h[i];
    if(x<0) return -1;
    // 计算操作次数...
} else {
    int sum=0;
    for(int i=1;i<=n;i++) sum+=(i&1?-1:1)*h[i];
    if(sum!=0) return -1;
    // 计算最小x及操作次数...
}
```

#### 2. 作者：CANTORSORT (★★★★☆)
**关键亮点**：  
- 两次遍历（正序+逆序）调整数列，确保单调后统一。  
- 代码简洁高效，时间复杂度O(n)。  

**核心思路**：  
- 正序处理使非递增，逆序处理使非递减，最终统一。  
- 反转数组复用同一调整逻辑，减少代码冗余。  

**代码片段**：  
```cpp
for(int j=1;j<2;j++){ // 正序与逆序处理
    for(int i=2;i<n;i++){
        if(h[i]>h[i-1]){ // 调整至与前一项相同
            int diff=h[i]-h[i-1];
            ans += diff*2;
            h[i+1]-=diff;
            h[i]=h[i-1];
        }
    }
    reverse(h+1,h+1+n); // 反转数组复用逻辑
}
```

#### 3. 作者：ztlh (★★★★☆)
**关键亮点**：  
- 正反交替扫描调整，直到无法操作或出现负数。  
- 优化边界判断和奇偶性剪枝，避免无效计算。  

**个人心得**：  
- 开`long long`避免溢出，及时终止负数情况。  
- 通过`flag`标记减少循环次数，实际运行高效。  

**核心代码**：  
```cpp
while(flag){
    flag=0;
    for(int i=2;i<n;i++){ // 正向调整
        if(h[i]>h[i-1]){
            int d=h[i]-h[i-1];
            h[i+1]-=d; h[i]-=d;
            if(h[i+1]<0) flag=-1;
        }
    }
    // 反向调整类似...
}
```

### 最优思路提炼
**数学公式法（奇偶分类）**：  
- 奇数：总和奇偶性确定x，递推计算操作数。  
- 偶数：总和必须满足特定条件，否则无解。  

**双次遍历法**：  
- 正序消除递增，逆序消除递减，最终统一。  
- 反转数组复用调整逻辑，确保所有元素相等。  

### 拓展建议
- **类似题型**：差分约束（如CF 1343D）、贪心调整（如LeetCode 670）。  
- **套路总结**：数列等值化问题常转化为数学公式推导或贪心调整，注意奇偶性、边界条件和负数检测。  

### 推荐习题
1. [P2898 Haybale Feast](https://www.luogu.com.cn/problem/P2898)（贪心+双指针）  
2. [CF 1526C2 Potions (Hard Version)](https://www.luogu.com.cn/problem/CF1526C2)（贪心+优先队列）  
3. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)（相邻操作最小次数）

---
处理用时：59.56秒
# 题目信息

# [USACO20OPEN] Cowntact Tracing B

## 题目描述

由于高传染性的牛传染病 COWVID-19 的爆发，Farmer John 非常担忧他的奶牛们（编号为 $1\ldots N$）的健康。

最近，Farmer John 对他的所有奶牛进行了检测，发现有一部分奶牛对该疾病的检测结果呈阳性。利用牛棚内的视频监控，他得以查看最近的奶牛之间的互动行为，结果发现奶牛们互相打招呼时，她们会握蹄，不幸的是这是一种会将疾病从一头奶牛传播给另一头奶牛的行为。Farmer John 汇总了一个添加了时间戳的清单，每条数据的形式为 $(t,x,y)$，表示在时间 $t$，奶牛 $x$ 与奶牛 $y$ 握了蹄。Farmer John 同时还知道以下信息：

（一）他的农场上恰有一头奶牛最初带有携带疾病（我们将这头奶牛称为“零号病人”）。

（二）一旦一头奶牛被感染，她会在接下来的 $K$ 次握蹄中传染疾病（可能会与同一头奶牛握蹄多次）。握蹄 $K$ 次后，她不再在此后的握蹄中传染疾病（因为此时她意识到了她会传染疾病，于是会仔细地洗蹄）。

（三）一旦一头奶牛被感染，她会持续处于被感染状态。

不幸的是，Farmer John 不知道他的 $N$ 头奶牛中的哪一头是零号病人，也不知道 $K$ 的值！基于他的数据，请帮助他缩小这些未知量的范围。保证至少有一种可能的情况。 

## 说明/提示

### 样例解释 1

唯一可能是零号病人的是奶牛 $1$。对于所有的 $K>0$，奶牛 $1$ 在时刻 $7$ 感染奶牛 $2$，而奶牛 $3$ 和奶牛 $4$ 均不会被感染。 

## 样例 #1

### 输入

```
4 3
1100
7 1 2
5 2 3
6 2 4```

### 输出

```
1 1 Infinity```

# AI分析结果



### 综合分析与结论
题目要求根据最终感染状态推断可能的零号病人及K值范围。所有正确题解均采用暴力枚举法，核心思路为：枚举每个可能的零号病人和K值，模拟握手过程，检查结果是否匹配。关键点在于正确处理时间顺序与传染次数的动态管理。

---

### 所选高分题解

#### 1. 作者：mengleo （★★★★★）
**关键亮点**：
- 清晰的时间排序与模拟逻辑。
- 使用剩余传染次数的数组（`cs`）准确跟踪状态，未感染标记为-1。
- 正确处理双向传染条件，避免重复感染覆盖问题。
- 高效处理K的上界为T+1，输出Infinity的逻辑简洁。

**核心代码逻辑**：
```cpp
for (int z = 1; z <= n; z++) {
    bool f = 0;
    for (int k = 0; k <= t + 1; k++) {
        bool valid = true;
        int cs[n + 5] = {}; // 初始化为-1（未感染）
        cs[z] = k; // 零号病人初始剩余次数为k
        // 按时间遍历握手事件
        for (int i = 1; i <= t; i++) {
            int x = lst[i].x, y = lst[i].y;
            // 处理双方感染状态的四种情况
            if (cs[x] > 0) {
                cs[x]--;
                if (cs[y] == -1) cs[y] = k; // 传染对方
            }
            // 类似处理y感染x的情况...
        }
        // 检查最终状态是否匹配输入
    }
}
```

#### 2. 作者：cly312 （★★★★）
**关键亮点**：
- 使用`num`数组记录已用传染次数，通过比较K值判断是否传播。
- 独立处理每次握手对双方的影响，逻辑直观。
- 正确覆盖K的范围（0-251），处理Infinity情况。

**核心代码逻辑**：
```cpp
bool check(int patient_zero, int K) {
    bool infected[101] = {false};
    int num[101] = {0};
    infected[patient_zero] = true;
    for (int t = 0; t <= 250; t++) {
        int x = cowx[t], y = cowy[t];
        if (x > 0) {
            if (infected[x]) num[x]++;
            if (infected[y]) num[y]++;
            // 感染传播逻辑
            if (num[x] <= K && infected[x]) infected[y] = true;
            if (num[y] <= K && infected[y]) infected[x] = true;
        }
    }
    // 验证最终状态
}
```

---

### 最优思路总结
1. **时间排序**：按握手时间升序处理，确保事件顺序正确。
2. **状态管理**：用数组记录每头牛的剩余传染次数或已用次数，初始感染设为K次。
3. **传染条件**：每次握手时，若当前牛仍有传染次数，则消耗次数并传播给未感染的牛。
4. **K值边界**：当K≥总握手次数时，结果等价于无限大（Infinity）。

---

### 类似题目推荐
1. **P6385 [COCI2007-2008#4] LEKTIRA**：涉及字符串操作与枚举可能情况。
2. **P2893 [USACO08FEB] Making the Grade G**：通过动态规划模拟状态变化。
3. **P8385 [BJOI2018] 链上二次求和**：结合时间序列与数学模型的暴力优化问题。

---

### 调试与心得摘录
- **变量命名**：清晰的变量名（如`cs`表示剩余次数）减少理解成本。
- **覆盖情况**：枚举K的范围需足够大（如T+1），否则会遗漏边界情况。
- **状态更新顺序**：先减少自身次数再传播，避免同一握手多次传染的BUG。

---
处理用时：206.72秒
# 题目信息

# [USACO20DEC] Stuck in a Rut B

## 题目描述

Farmer John 最近扩大了他的农场，从奶牛们的角度看来这个农场相当于是无限大了！奶牛们将农场上放牧的区域想作是一个由正方形方格组成的无限大二维方阵，每个方格中均有美味的草（将每个方格看作是棋盘上的一个方格）。Farmer John 的 $N$ 头奶牛（$1\le N\le 50$）初始时位于不同的方格中，一部分朝向北面，一部分朝向东面。

每一小时，每头奶牛会执行以下二者之一：

 - 如果她当前所在的方格里的草已经被其他奶牛吃掉了，则她会停下。
 - 吃完她当前所在的方格中的所有草，并向她朝向的方向移动一个方格。

经过一段时间，每头奶牛的身后会留下一条被啃秃了的轨迹。

如果两头奶牛在一次移动中移动到了同一个有草的方格，她们会分享这个方格中的草，并在下一个小时继续沿她们朝向的方向移动。

请求出每头奶牛吃到的草的数量。有些奶牛永远不会停下，从而吃到无限多的草。 

## 说明/提示

### 测试点性质

 - 测试点 $2-5$ 中，所有坐标不超过 $100$。
 - 测试点 $6-10$ 没有额外限制。

## 样例 #1

### 输入

```
6
E 3 5
N 5 3
E 4 6
E 10 4
N 11 2
N 8 1```

### 输出

```
5
3
Infinity
Infinity
2
5```

# AI分析结果



### 综合分析与结论
本题解集合中，大部分采用"分类排序+交点距离比较"的核心思路。通过将向东和向北的奶牛分别按坐标排序，依次判断射线交点处的到达时间差来确定阻挡关系。最优解法的关键在于：
1. 将两类奶牛分别按x/y坐标排序
2. 通过单次双循环处理两类奶牛的阻挡关系
3. 利用排序顺序保证优先处理更可能产生有效阻挡的奶牛

### 精选题解分析

#### 1. FZY_CZY（⭐⭐⭐⭐⭐）
**核心亮点**：
- 将东向奶牛按y坐标排序，北向按x坐标排序，确保优先处理右下方的阻挡
- 单次双循环即完成所有阻挡判断，时间复杂度O(N²)
- 通过break语句及时终止无效判断，优化效率

**关键代码**：
```cpp
sort(N+1,N+sum_n+1,cmp1); // 北向按x升序
sort(E+1,E+sum_e+1,cmp2); // 东向按y升序

for (东向奶牛i) {
    for (北向奶牛j) {
        if (相交且未处理) {
            int A = 北向到交点x距离，B = 东向到交点y距离
            if (A < B) 北向被阻挡
            else 东向被阻挡并break
        }
    }
}
```

#### 2. Arson1st（⭐⭐⭐⭐）
**核心亮点**：
- 使用更紧凑的代码结构实现相同逻辑
- 直接通过坐标差比较代替绝对值计算
- 结构体设计更简洁，无冗余字段

**代码特点**：
```cpp
sort(N, N+totn, cmpx); // 北向按x排序
sort(E, E+tote, cmpy); // 东向按y排序

for (东向i) {
    for (北向j) {
        int a = N[j].x - E[i].x; // 北向移动距离
        int b = E[i].y - N[j].y; // 东向移动距离
        if (a < b) 北向被阻挡
        else if (a > b) 东向被阻挡并break
    }
}
```

#### 3. zxh923（⭐⭐⭐⭐）
**实现亮点**：
- 使用统一的结构体存储两类奶牛
- 通过函数参数交换简化方向判断
- 结构清晰的变量命名增强可读性

**关键片段**：
```cpp
void crush(int a, int b) { // 东a与北b的交点判断
    int acnt = 北到交点x距离，bcnt = 东到交点y距离
    if (acnt > bcnt) 东被阻挡
    else if (acnt < bcnt) 北被阻挡
}
```

### 关键思路总结
1. **分类排序**：将东/北奶牛分别按y/x坐标排序，保证处理顺序从下到上、从左到右
2. **交点判定**：通过移动距离差比较确定阻挡优先级，距离短者先到达交点
3. **阻断传播**：一旦某奶牛被阻挡，立即终止其后续可能产生的无效判断
4. **无穷判定**：最终未被赋值的奶牛即为无限移动

### 推荐练习题
1. P6246 [IOI2000] 邮局（坐标排序与最优阻挡）
2. P7400 [COCI2020-2021#3] Selotejp（网格移动与路径阻断）
3. P2896 [USACO08FEB] Eating Together S（事件序列处理与状态转移）

### 题解心得摘录
1. **FZY_CZY**："排序后可以减时间复杂度并且简化代码，不需要两次双for循环"
2. **ABCDEFG12345NM**："模拟赛时写了两次双循环都错了，最终发现单次遍历就能保证正确性"
3. **Union_Find**："跑多次循环直到答案稳定，虽过但不确定正确性，警示应严格证明算法" 

这些经验强调：合理排序能简化逻辑，避免冗余计算；算法正确性需要严格证明而非依赖测试用例；简洁的实现往往更易维护和调试。

---
处理用时：57.94秒
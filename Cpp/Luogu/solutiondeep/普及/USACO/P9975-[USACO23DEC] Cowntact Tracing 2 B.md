# 题目信息

# [USACO23DEC] Cowntact Tracing 2 B

## 题目描述

Farmer John 有 $N$ 头奶牛排成一列（$1 \leq N \leq 3\cdot 10^5$）。不幸的是，有一种疾病正在传播。

最初，有一些奶牛被感染。每到夜晚，被感染的奶牛会将疾病传播给它左右两边的奶牛（如果这些奶牛存在的话）。一旦奶牛被感染，她就会持续处于感染状态。

经过一些晚上，Farmer John 意识到情况已经失控，因此他对奶牛进行了检测以确定哪些奶牛感染了疾病。请找出最少有多少头奶牛最初可能感染了这种疾病。

## 说明/提示

### 样例解释 1

假设只有中间的奶牛最初被感染。那么，奶牛们将按以下顺序被感染：

- 第 $0$ 晚：$00100$（第三只奶牛一开始被感染）
- 第 $1$ 晚：$01110$（第二和第四只奶牛现在被感染了）
- 第 $2$ 晚：$11111$（第一和第五只奶牛现在被感染了）
- 第 $3$ 晚：$11111$（所有的奶牛都已经被感染了，没有新的奶牛被感染）
- ……

经过两个或更多的晚上，奶牛们的状态即与输入的状态相符。还有许多其他的初始状态和夜晚数量可能导致了输入的状态，例如：

- 第 $0$ 晚：$10001$
- 第 $1$ 晚：$11011$
- 第 $2$ 晚：$11111$

或者：

- 第 $0$ 晚：$01001$
- 第 $1$ 晚：$11111$

或者：

- 第 $0$ 晚：$01000$
- 第 $1$ 晚：$11100$
- 第 $2$ 晚：$11110$
- 第 $3$ 晚：$11111$

所有这些初始状态中至少有一头奶牛被感染。

### 样例解释 2

唯一可能导致这个最终状态的初始状态和夜晚数是：没有经过任何夜晚，输入中的四头感染的奶牛都是从最开始就感染了这种疾病。

### 测试点性质

- 测试点 $3-7$ 满足 $N \le 1000$。
- 测试点 $8-12$ 没有额外限制。

## 样例 #1

### 输入

```
5
11111```

### 输出

```
1```

## 样例 #2

### 输入

```
6
011101```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
本题核心在于贪心策略：确定最大传播天数，根据天数计算初始感染数。各题解均基于以下思路：
1. **分割连续感染块**，区分边缘块（首尾）与中间块。
2. **计算每个块的最大可能天数**：边缘块天数为长度-1，中间块天数为⌊(长度-1)/2⌋。
3. **取所有块天数的最小值**作为全局最大天数d，确保所有块满足条件。
4. **每块初始感染数**为⌈块长度/(2d+1)⌉，总和即为答案。

### 高星题解推荐（≥4星）

#### 1. 作者：No_Rest（4星）
**关键亮点**：
- 高效处理块分割与天数计算，逻辑清晰。
- 边界条件处理完善（如首尾块的特殊判断）。
- 代码结构紧凑，时间复杂度严格O(n)。

**核心代码思想**：
- 遍历字符串记录每个块的起止位置。
- 计算每个块的最大天数并取最小值。
- 累加每个块的初始感染数。

```cpp
// 关键代码片段
vector<ll> st, ed;
for (re ll i = 1; i <= n; ++i) {
    if (a[i]) {
        if (!a[i - 1]) st.push_back(i); // 块起点
    } else if (last) {
        if (st[0] == 1) mn = min(mn, i - 2); // 首块天数
        else mn = min(mn, (last - 1) / 2); // 中间块天数
        ed.push_back(i - 1); // 块终点
    }
}
```

#### 2. 作者：紊莫（4星）
**关键亮点**：
- 代码简洁，块处理逻辑直观。
- 明确分类讨论边缘块与中间块。
- 变量命名清晰，可读性强。

**核心代码思想**：
- 遍历字符串分割连续块，存储起止点。
- 分别计算边缘块与中间块的最大天数。
- 累加各块初始感染数。

```cpp
vector<Pair> a;
F(i,1,n) {
    if(s[i]=='1'){
        int j=i; while(s[j]=='1') j++;
        a.push_back({i,j-1}); i=j; // 记录块起止
    }
}
for(auto x:a) {
    int len = x.second - x.first +1;
    if(x.first==1 || x.second==n) // 边缘块处理
        day = min(day, len-1);
    else 
        day = min(day, (len-1)/2);
}
```

#### 3. 作者：Adchory（4星）
**关键亮点**：
- 高效处理块分割与天数计算，逻辑清晰。
- 简洁的贪心实现，代码无冗余。
- 正确处理边缘块与中间块的分类。

```cpp
for(ll i=1;i<=N+1;i++){ // 分割块
    if(S[i]!=S[i-1] && S[i]=='1') cnt=1;
    if(S[i]==S[i-1] && S[i]=='1') cnt++;
    if(S[i]!=S[i-1] && S[i-1]=='1'){
        if(i-cnt==1 || i==N+1) // 边缘块判断
            res = min(res, cnt-1);
        else res = min(res, (cnt-1)/2);
        g.push_back(cnt);
    }
}
```

### 最优关键思路与技巧
1. **块分割与分类**：快速分割连续感染块，区分边缘块（首尾）与中间块。
2. **贪心求最大天数**：每个块的最大可能天数取全局最小值，确保所有块满足条件。
3. **数学计算初始数**：每块初始感染数=⌈块长度/(2d+1)⌉，总和即为答案。

### 拓展与相似题目
- **类似题目推荐**：
  1. [P3121 [USACO15FEB]Censoring G](https://www.luogu.com.cn/problem/P3121)（字符串处理与贪心）
  2. [P1842 [USACO05NOV] 奶牛玩杂技](https://www.luogu.com.cn/problem/P1842)（贪心策略）
  3. [P3143 [USACO16OPEN] Diamond Collector S](https://www.luogu.com.cn/problem/P3143)（区间覆盖与极值处理）

### 个人心得摘录
- **No_Rest**：调试中发现未处理末尾块，添加`if (last) mn = min(mn, last-1)`解决。
- **紊莫**：初始错误将中间块天数计算为`len/2`，后修正为`(len-1)/2`。
- **Adchory**：顿悟边缘块的天数计算应为`len-1`而非`(len-1)/2`，避免错误答案。

---
处理用时：60.18秒
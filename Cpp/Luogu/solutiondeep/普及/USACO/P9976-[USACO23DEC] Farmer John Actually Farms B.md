# 题目信息

# [USACO23DEC] Farmer John Actually Farms B

## 题目描述

Farmer John 在他的农场上种植了 $N$（$1 \leq N \leq 2\cdot 10^5$） 株芦笋！然而，其中有一些植物存在基因差异，长得比其他植物快。第 $i$ 株植物的初始高度为 $h_i$ 英寸，之后每天，第 $i$ 株植物长高 $a_i$ 英寸。

FJ 更加钟爱其中的一些植物。他将给你一组由不同整数组成的数组 $t_1,\dots,t_N$，这个数组包含 $0$ 到 $N-1$ 的全部整数。他希望恰好有 $t_i$ 株植物比第 $i$ 株植物高。找到最少要经过多少天，才能满足 FJ 的要求，或者报告这个要求是不可能满足的。

## 说明/提示

### 样例解释 1

在第一组样例中，有 $6$ 组测试数据。

在第一组测试数据中，只有一株植物，所以要求在第 $0$ 天就已经满足。

在第二组测试数据中，需要让第一株植物比第二株植物矮。第   $1$ 天后，它们的高度为 $15,13$；第 $2$ 天后，它们的高度均为 $23$；第 $3$ 天后，它们的高度为 $31,33$，这是满足要求的第一天。

第三组和第四组测试数据与第二组类似。

在第五组测试数据中，两株植物的初始高度均为 $7$ 英寸，且每天均增长 $8$ 英寸，所以它们的高度永远相同。因此，条件永远无法满足。

在第六组测试数据中，初始高度不满足要求且增长速度均相同，所以条件永远无法满足。

### 样例解释 2

在第二组样例中，有 $2$ 组测试数据。

在第一组测试数据中，第 $4$ 天后的最终高度为 $19, 20, 21, 18, 16$。

在第二组测试数据中，第 $7$ 天后的最终高度为 $25, 17, 19, 35, 36$。

### 测试点性质

- 测试点 $3$ 满足 $N \le 2$。
- 测试点 $4-5$ 满足 $N \le 50$，$a_i, h_i \le 10^3$。
- 测试点 $6-8$ 满足 $N \le 10^3$。
- 测试点 $9-13$ 没有额外限制。

## 样例 #1

### 输入

```
6
1
10
1
0
2
7 3
8 10
1 0
2
3 6
10 8
0 1
2
7 3
8 9
1 0
2
7 7
8 8
0 1
2
7 3
8 8
1 0```

### 输出

```
0
3
2
5
-1
-1```

## 样例 #2

### 输入

```
2
5
7 4 1 10 12
3 4 5 2 1
2 1 0 3 4
5
4 10 12 7 1
3 1 1 4 5
2 4 3 1 0```

### 输出

```
4
7```

# AI分析结果



### 综合分析与结论
本题核心在于将目标排列转化为相邻元素的严格递减约束，通过建立不等式组求解时间区间的交集。最优解法需处理三类情况（a差正/负/零），求最大下界与最小上界，并验证整数解存在性。关键难点在于正确推导不等式方向、处理边界条件（如速度相等时初始高度是否满足）及避免浮点误差。

---

### 精选题解与评分

#### 题解1：tder（★★★★★）
**核心思路**  
- 按目标排名排序植物，处理相邻元素的不等式。
- 分类讨论a差的正负：a大则求k的下界，a小则求k的上界，a相等时检查初始高度。
- 最终解为下界最大值与上界最小值的交集，验证是否存在整数解。

**关键代码**  
```cpp
// 预处理目标排列
for(int i = 1; i <= n; i++) p[t[i] + 1] = i;

// 处理相邻对的不等式
for(int i = 1; i < n; i++) {
    int x = p[i], y = p[i+1];
    if(a[x] > a[y]) 
        q1 = max(q1, 1.0*(h[y]-h[x])/(a[x]-a[y])); // 下界
    else if(a[x] < a[y]) 
        q2 = min(q2, 1.0*(h[y]-h[x])/(a[x]-a[y])); // 上界
    else if(h[x] <= h[y]) 
        return -1; // a相等且初始不满足则无解
}

// 检查解区间
if(q1 < q2) {
    int ans = floor(q1) + 1; // 取最小整数解
    return ans < q2 ? ans : -1;
}
```

**亮点**  
- 逻辑清晰，直接处理不等式组。
- 时间复杂度O(n)最优，无冗余操作。
- 巧妙利用浮点运算处理边界，避免整数除法误差。

---

#### 题解2：Zi_Gao（★★★★☆）
**核心思路**  
- 通过自定义ceil/floor函数精确处理分数取整。
- 维护全局最大左界和最小右界，确保所有相邻对约束满足。

**关键优化**  
- 采用整数运算避免浮点误差，如处理分式时判断余数。
- 显式处理h相等时的特殊情况，增强代码鲁棒性。

**代码片段**  
```cpp
// 处理相邻对约束
if(h[i] > h[j]) {
    if(a[i] >= a[j]) continue;
    else r = min(r, (h[i]-h[j]-1)/(a[j]-a[i])); // 向下取整
} else if(h[i] < h[j]) {
    if(a[i] <= a[j]) return -1;
    else l = max(l, (h[j]-h[i] + (a[i]-a[j]-1))/(a[i]-a[j])); // 向上取整
}
```

**亮点**  
- 精确处理整数分式，避免浮点问题。
- 显式处理所有边界条件，逻辑严谨。

---

#### 题解3：Loser_Syx（★★★☆☆）
**思路**  
- 对目标排列排序后处理相邻不等式。
- 维护全局最大左界和最小右界。

**不足**  
- 未处理a相等时的边界条件。
- 分式处理较为简略，可能导致误差。

---

### 最优技巧总结
1. **不等式组处理**：将问题分解为相邻元素的不等式，分别求k的范围。
2. **整数分式技巧**：用`ceil((a + b -1)/b)`代替浮点运算，避免精度损失。
3. **区间交集法**：所有约束的下界取max，上界取min，验证交集存在性。

---

### 拓展练习
1. [CF626C - Block Towers](https://codeforces.com/problemset/problem/626/C)（二分答案+不等式约束）
2. [P1842 [USACO05NOV] 奶牛玩杂技](https://www.luogu.com.cn/problem/P1842)（贪心排序不等式）
3. [P1250 种树](https://www.luogu.com.cn/problem/P1250)（差分约束系统求交集）

---
处理用时：56.03秒
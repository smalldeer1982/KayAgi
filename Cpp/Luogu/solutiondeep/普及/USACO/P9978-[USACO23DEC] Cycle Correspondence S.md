# 题目信息

# [USACO23DEC] Cycle Correspondence S

## 题目描述

Farmer John 有 $N$（$3 \le N \le 5\cdot 10^5$）座谷仓，其中 $K$ 对不同的谷仓连接在一起。

一开始，Annabelle 为每座谷仓分配了一个 $[1,N]$ 范围内的整数编号，并发现编号为 $a_1,\dots,a_K$ 的谷仓按照顺序形成了一个环形连接。换句话说，对于所有的 $1 \le i < K$，谷仓 $a_i$ 和 $a_{i+1}$ 相连，谷仓 $a_K$ 与 $a_1$ 亦相连。所有的 $a_i$ 不相同。

然后，Bessie 也为每个谷仓分配了一个 $[1,N]$ 范围内的整数编号，并发现编号为 $b_1,\dots,b_K$ 也按照顺序形成了一个环形链接。所有的 $b_i$ 不相同。

一些（可能没有或全部）谷仓被 Annabelle 和 Bessie 分配了相同的编号。计算最多有多少个这样的谷仓。

## 说明/提示

### 样例解释 1

Annabelle 和 Bessie 可以为每个谷仓分配相同的编号。

### 样例解释 2

Annabelle 和 Bessie 无法为任何谷仓分配相同的编号。

### 样例解释 3

Annabelle 和 Bessie 可以分配编号 $2,3,4,6$ 给相同的谷仓。

### 测试点性质

- 测试点 $4-5$ 满足 $N \le 8$。
- 测试点 $6-8$ 满足 $N \le 5000$。
- 测试点 $9-15$ 没有额外限制。

## 样例 #1

### 输入

```
6 3
1 2 3
2 3 1```

### 输出

```
6```

## 样例 #2

### 输入

```
6 3
1 2 3
4 5 6```

### 输出

```
0```

## 样例 #3

### 输入

```
6 4
1 2 3 4
4 3 2 5```

### 输出

```
4```

# AI分析结果



### 综合分析与结论
题目要求两个环结构谷仓编号的最多匹配数，解法关键在于处理环外点与环内旋转/翻转对齐。所有题解均分为两部分：环外未出现编号直接累加，环内通过统计循环移位次数求最大匹配。核心技巧是预处理元素位置，用数组/哈希表统计不同移位次数的匹配数，并处理翻转情况。时间复杂度为O(K)，高效且正确。

---

### 精选题解

#### 1. 作者：strcmp (5星)
**关键亮点**  
- 高效数组计数替代哈希表，避免map的O(logK)开销。
- 分别处理原环和翻转后的环，翻转逻辑清晰。
- 代码简洁，处理环外点逻辑明确。

**代码核心思想**  
预处理每个元素在a中的位置，遍历b计算移位次数并统计。翻转a后重复同样步骤，取最大匹配数。
```cpp
// 核心代码（处理原环与翻转环）
for (int i = 1; i <= k; i++) {
    int u = d[b[i]];
    if (u >= i) ++sum[u - i];  // 计算移位次数
    else ++sum[k - i + u];
}
reverse(a + 1, a + k + 1);  // 翻转a数组，重新处理
```

#### 2. 作者：tanghg (4星)
**关键亮点**  
- 使用loc数组记录位置，逻辑直观。
- 翻转处理通过修改b数组顺序，代码易理解。
- 变量命名清晰，结构分明。

**代码核心思想**  
通过loc数组快速查找元素位置，统计每个元素所需移位次数，翻转b后重复统计。
```cpp
// 核心函数Do()
void Do(){
    memset(d,0,sizeof(d));
    for(int i=1;i<=k;++i) loc[b[i]]=i;  // 记录位置
    for(int i=1;i<=k;++i){
        ll nxt=loc[a[i]];  // 找到a[i]在b中的位置
        if(nxt>i) d[nxt-i]++;
        else d[k-i+nxt]++;
    }
}
```

#### 3. 作者：听取MLE声一片 (4星)
**关键亮点**  
- 利用map简化移位统计，代码简短。
- 翻转处理通过反转b数组实现，逻辑统一。
- 明确分离环内外处理，结构清晰。

**代码核心思想**  
用map统计每个移位次数出现次数，翻转b数组后再次统计，取最大值。
```cpp
// 核心计算函数
int solve(){
    map<int,int> mp;
    for(int i=1;i<=m;i++){
        int x = i - pos[b[i]];
        if(x<0) x += m;
        mp[x]++;
    }
    return max_element(mp)->second;
}
```

---

### 关键思路与技巧
1. **环外点处理**：直接统计未出现在两环中的编号。
2. **循环移位优化**：通过元素位置差计算移位次数，用数组/哈希表统计次数取最大值。
3. **翻转处理**：将环序列反转后重新计算位置差，覆盖所有可能对齐方式。
4. **高效计数**：避免暴力枚举移位，通过O(K)预处理和统计。

---

### 拓展与举一反三
- **类似题目**：环形字符串匹配（如旋转、翻转后子串匹配）、循环排列问题。
- **技巧迁移**：处理循环结构时，可将序列视为无限延展或通过模运算简化位置计算。

---

### 推荐题目
1. [P1368 工艺](https://www.luogu.com.cn/problem/P1368)（最小表示法，循环处理）
2. [P6145 [USACO20FEB]Timeline G](https://www.luogu.com.cn/problem/P6145)（时间安排与环结构）
3. [P3964 [TJOI2013]松鼠聚会](https://www.luogu.com.cn/problem/P3964)（环状排列与距离计算）

---
处理用时：154.01秒
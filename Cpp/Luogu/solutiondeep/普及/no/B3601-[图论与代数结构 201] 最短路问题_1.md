# 题目信息

# [图论与代数结构 201] 最短路问题_1

## 题目描述

给定一张 $n$ 个点、$m$ 条边的有向图，求 $1$ 号点到每个点的最短路径长度。

**注意，图可能存在重边和自环，保证不存在负环。**

## 说明/提示

本题没有部分分。

对于所有数据，$1\leq n,m \leq 2\times 10^3$，$-10^9\leq w_i\leq 10^9$。

请注意答案上界的大小，可能需要使用 C++ 中的 `long long int` 类型。

## 样例 #1

### 输入

```
4 5
1 2 1
2 3 4
1 3 3
4 1 5
3 1 2
```

### 输出

```
0 1 3 -1```

## 样例 #2

### 输入

```
10 50
5 9 6
1 3 10
3 1 1
10 2 5
8 5 1
10 10 6
6 5 2
1 5 10
2 5 5
10 1 4
1 5 2
8 8 7
7 2 7
9 2 8
3 1 4
6 2 5
3 9 9
4 9 5
5 10 9
10 1 9
5 4 5
9 1 2
5 10 6
3 8 7
10 3 7
5 8 8
9 2 6
9 8 6
3 2 8
1 3 8
1 10 1
7 8 4
9 4 5
4 6 2
2 7 6
10 1 5
9 9 7
6 7 4
1 1 7
8 3 10
8 3 9
10 9 8
3 9 1
7 4 8
1 5 4
8 4 4
3 4 4
9 9 2
2 10 4
8 9 6
```

### 输出

```
0 6 8 7 2 9 12 10 8 1```

# AI分析结果

### 算法分类
最短路

### 综合分析与结论
本题是典型的单源最短路问题，且图中存在负权边，因此无法使用Dijkstra算法。题解中主要采用了Bellman-Ford算法及其优化版本SPFA，以及Johnson算法。Bellman-Ford算法的时间复杂度为O(nm)，适用于处理负权边的最短路问题。SPFA是Bellman-Ford的队列优化版本，虽然在一般情况下效率更高，但在极端情况下可能退化为O(nm)。Johnson算法通过重赋权值将负权图转化为非负权图，然后使用Dijkstra算法求解，适用于全源最短路问题。

### 所选高分题解
1. **作者：伟大的王夫子 (赞：25)**
   - **星级：4星**
   - **关键亮点：**
     - 使用了Bellman-Ford算法，代码简洁易懂。
     - 加入了小优化，当某次循环中没有节点更新时提前跳出循环。
   - **核心代码：**
     ```cpp
     for (register int i = 1; i <= n; ++i) {
         flag = 1;
         for (register int j = 1; j <= m; ++j)
             if (dis[a[j].y] > dis[a[j].x] + a[j].z) flag = 0, dis[a[j].y] = dis[a[j].x] + a[j].z;
         if (flag) break;
     }
     ```
   - **个人心得：**
     - 提到虽然优化可能没什么用，但代码运行速度较快。

2. **作者：一扶苏一 (赞：11)**
   - **星级：4星**
   - **关键亮点：**
     - 使用了SPFA算法，代码结构清晰。
     - 详细解释了SPFA的思想和实现细节。
   - **核心代码：**
     ```java
     void release(Queue<Node> Q) {
         this.inq = false;
         for (Edge e = hd; e != null; e = e.nxt) {
             Node v = e.v;
             if (v.dist > dist + e.w) {
                 v.dist = dist + e.w;
                 if (v.inq == false) {
                     v.inq = true;
                     Q.offer(v);
                 }
             }
         }
     }
     ```
   - **个人心得：**
     - 提到SPFA在一般情况下效率较高，但在极端情况下可能退化为Bellman-Ford。

3. **作者：追梦的黑旋风 (赞：10)**
   - **星级：4星**
   - **关键亮点：**
     - 使用了Johnson算法，结合了SPFA和Dijkstra的优点。
     - 详细解释了Johnson算法的核心思想和实现步骤。
   - **核心代码：**
     ```cpp
     void spfa(ll st){
         for(register ll i=1;i<=n;i+=3){
             hh[i]=0x3f3f3f3f;
             hh[i+1]=0x3f3f3f3f;
             hh[i+2]=0x3f3f3f3f;
         }
         hh[st]=0;
         qq[++t]=st;
         while(h!=t){
             ll u=qq[++h];
             if(h>=maxn-5)h=0;
             vis[u]=false;
             for(register ll i=head[u];i;i=e[i].nxt){
                 ll v=e[i].pre;
                 if(hh[v]>hh[u]+e[i].w){
                     hh[v]=hh[u]+e[i].w;
                     if(!vis[v]){
                         vis[v]=true;
                         qq[++t]=v;
                         if(t>=maxn-5)t=0;
                     }
                 }
             }
         }
     }
     ```
   - **个人心得：**
     - 提到Johnson算法在处理负权图时的优势，并详细解释了其实现步骤。

### 最优关键思路或技巧
- **Bellman-Ford算法**：适用于处理负权边的最短路问题，代码实现简单，但时间复杂度较高。
- **SPFA算法**：Bellman-Ford的队列优化版本，在一般情况下效率较高，但在极端情况下可能退化为O(nm)。
- **Johnson算法**：通过重赋权值将负权图转化为非负权图，然后使用Dijkstra算法求解，适用于全源最短路问题。

### 可拓展之处
- **同类型题**：类似的最短路问题可以使用相同的算法解决，如处理负权边、全源最短路等。
- **类似算法套路**：在处理负权图时，可以考虑使用Bellman-Ford或SPFA算法；在处理全源最短路时，可以考虑使用Johnson算法。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P5905 【模板】Johnson全源最短路](https://www.luogu.com.cn/problem/P5905)

---
处理用时：32.13秒
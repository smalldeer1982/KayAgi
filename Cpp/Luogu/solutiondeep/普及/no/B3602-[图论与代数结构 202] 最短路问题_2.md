# 题目信息

# [图论与代数结构 202] 最短路问题_2

## 题目描述

给定一张 $n$ 个点、$m$ 条边的有向图，求 $1$ 号点到每个点的最短路径长度。

**注意，图可能存在重边和自环。**

## 说明/提示

本题没有部分分。

对于所有数据，$1\leq n,m \leq 3\times 10^5$，$1\leq w_i\leq 10^9$。

请注意答案上界的大小，可能需要使用 C++ 中的 `long long int` 类型。

## 样例 #1

### 输入

```
4 5
1 2 1
2 3 4
1 3 3
4 1 5
3 1 2
```

### 输出

```
0 1 3 -1```

## 样例 #2

### 输入

```
10 50
5 9 6
1 3 10
3 1 1
10 2 5
8 5 1
10 10 6
6 5 2
1 5 10
2 5 5
10 1 4
1 5 2
8 8 7
7 2 7
9 2 8
3 1 4
6 2 5
3 9 9
4 9 5
5 10 9
10 1 9
5 4 5
9 1 2
5 10 6
3 8 7
10 3 7
5 8 8
9 2 6
9 8 6
3 2 8
1 3 8
1 10 1
7 8 4
9 4 5
4 6 2
2 7 6
10 1 5
9 9 7
6 7 4
1 1 7
8 3 10
8 3 9
10 9 8
3 9 1
7 4 8
1 5 4
8 4 4
3 4 4
9 9 2
2 10 4
8 9 6
```

### 输出

```
0 6 8 7 2 9 12 10 8 1```

# AI分析结果

### 算法分类
最短路

### 综合分析与结论
本题是一个典型的最短路问题，要求从源点到所有其他节点的最短路径。由于数据规模较大（n, m ≤ 3e5），普通的Dijkstra算法（O(n^2)）无法通过，因此需要使用堆优化的Dijkstra算法（O(m log n)）。所有题解都采用了堆优化的Dijkstra算法，并且使用了链式前向星或邻接表来存储图结构。部分题解还提到了SPFA算法，但由于其时间复杂度不稳定，不推荐在本题目中使用。

### 所选高星题解
1. **作者：BlachSnake (赞：17)**
   - **星级：5星**
   - **关键亮点**：详细讲解了链式前向星的存储方式，并提供了Dijkstra算法的优化思路，使用二叉堆进行优化。代码实现清晰，注释详细，适合初学者理解。
   - **个人心得**：作者提到STL的priority_queue由于动态开空间较慢，因此手写了一个堆，提升了性能。
   - **核心代码**：
     ```cpp
     void Dijkstra(){
         memset(d,63,sizeof(d));
         d[1]=0;
         q.push(Make_Pair(0ll,1));
         while(!q.Empty()){
             int x=q.Top().y; q.Pop();
             if(b[x]) continue;
             b[x]=1;
             for(int i=h[x];i;i=nxt[i]){
                 int y=to[i], z=w[i];
                 if(d[y]>d[x]+z){
                     d[y]=d[x]+z;
                     q.Push(Make_Pair(d[y],y));
                 }
             }
         }
     }
     ```

2. **作者：Aw顿顿 (赞：1)**
   - **星级：4星**
   - **关键亮点**：详细解释了Dijkstra算法的贪心思想，并通过图示展示了算法的执行过程，帮助读者更好地理解算法的正确性。代码实现简洁，使用了STL的priority_queue。
   - **核心代码**：
     ```cpp
     void Dijkstra(){
         dis[1]=0; q.push((node){0,1});
         while(!q.empty()){
             node cur=q.top(); q.pop();
             int x=cur.id, d=cur.dis;
             if(sure[x]) continue;
             sure[x]=1;
             for(int i=head[x];~i;i=e[i].nxt){
                 int y=e[i].to;
                 if(sure[y]) continue;
                 if(dis[y]>dis[x]+e[i].w){
                     dis[y]=dis[x]+e[i].w;
                     q.push((node){dis[y],y});
                 }
             }
         }
     }
     ```

3. **作者：Kagamino_Natsumi (赞：2)**
   - **星级：4星**
   - **关键亮点**：提供了Dijkstra算法的详细步骤，并解释了堆优化的必要性。代码实现清晰，使用了STL的priority_queue，适合初学者学习。
   - **核心代码**：
     ```cpp
     void dijkstra(int s){
         vector<ll> dis(n+1, INF);
         priority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<pair<ll,int>>> q;
         dis[s]=0; q.push(make_pair(0,s));
         while(!q.empty()){
             pair<ll,int> tmp=q.top(); q.pop();
             int u=tmp.second;
             if(vis[u]) continue;
             vis[u]=1;
             for(int i=head[u];i;i=g[i].nxt){
                 int v=g[i].to;
                 if(dis[v]>dis[u]+g[i].w){
                     dis[v]=dis[u]+g[i].w;
                     q.push(make_pair(dis[v],v));
                 }
             }
         }
     }
     ```

### 最优关键思路或技巧
1. **堆优化的Dijkstra算法**：通过优先队列（小根堆）来优化Dijkstra算法，使得每次取最小距离的节点的时间复杂度从O(n)降低到O(log n)。
2. **链式前向星存储图**：适合处理大规模稀疏图，节省空间且访问效率高。
3. **贪心思想**：Dijkstra算法的核心是贪心思想，每次选择当前距离最小的节点进行松弛操作，确保每次选择的路径都是当前最优的。

### 可拓展之处
1. **负权边处理**：如果图中存在负权边，Dijkstra算法无法正确求解，此时可以使用SPFA算法或Bellman-Ford算法。
2. **多源最短路**：如果需要求解多个源点的最短路，可以使用Floyd算法或多次调用Dijkstra算法。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)

---
处理用时：37.34秒
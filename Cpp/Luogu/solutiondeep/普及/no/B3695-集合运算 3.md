# 题目信息

# 集合运算 3

## 题目背景

关于集合、交集、并集的定义请参考 https://www.luogu.com.cn/problem/B3633。

以下给出对称差的定义：

对两个集合 $A, B$，规定 $A$ 和 $B$ 的对称差 $A \Delta B$ 为在 $A$ 中出现但不在 $B$ 中出现，或在 $B$ 中出现但不在 $A$ 中出现的元素。  
例如，$A = \{1, 2, 3\}$，$B = \{2, 3, 5\}$，则 $A \Delta B = \{1, 5\}$

## 题目描述

给定 $n$ 个集合 $s_1, s_2, \dots s_n$，每个集合都含有 $[1, m]$ 之间的若干个整数。

现在，有 $q$ 次操作，每次操作如下：
- `1 x y`：将 $s_x$ 中的每个元素都加上 $y$，再删去其中大于 $m$ 的；
- `2 x y`：将 $s_x$ 中的每个元素都减去 $y$，再删去其中小于 $1$ 的；
- `3 x y`：查询 $s_x$ 和 $s_y$ 的**交集**的元素个数；
- `4 x y`：查询 $s_x$ 和 $s_y$ 的**并集**的元素个数；
- `5 x y`：查询 $s_x$ 和 $s_y$ 的**对称差**的元素个数；


## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n,m,q \leq 3 \times 10^4$，$1 \leq \sum_{i = 1}^n c_i \leq 10^6$，$1 \leq x, y \leq n$，$1 \leq o \leq 5$。集合里的元素都是不超过 $m$ 的正整数。

感谢 @[Zyingyzzz](/user/434929) 提供 hack 数据一组。

## 样例 #1

### 输入

```
2 5 5
3 1 2 3
4 1 2 4 5
1 2 1
2 1 1
3 1 2
4 1 2
5 1 2```

### 输出

```
1
4
3```

# AI分析结果

### 算法分类
位运算

### 综合分析与结论
本题的核心在于利用位运算（如左移、右移、与、或、异或等）来高效处理集合的加减操作以及集合之间的交、并、对称差运算。`bitset` 是一种非常适合处理此类问题的数据结构，因为它能够以位为单位进行操作，且支持高效的位运算。各题解均采用了 `bitset` 来实现，但在细节处理和优化上有所不同。

### 所选题解

#### 题解1：Limitless_lmw (5星)
**关键亮点：**
- 详细解释了 `bitset` 的使用方法，特别是如何处理左移和右移操作时的边界问题。
- 通过 `bitset<30005>` 的巧妙使用，解决了 `m` 不是编译期常数的问题。
- 代码简洁且高效，直接利用位运算实现所有操作。

**核心代码：**
```cpp
std::bitset<maxn> s[maxn];
for(int i = 0; i<m; i++) s[0].set(i,1);
for(int o,x,y;q;--q){
    std::cin>>o>>x>>y;
    if(o==1){
        s[x]<<=y;
        s[x]&=s[0];
    }else if(o==2){
        s[x]>>=y;
    }else if(o==3){
        std::cout<<(s[x]&s[y]).count()<<'\n';
    }else if(o==4){
        std::cout<<(s[x]|s[y]).count()<<'\n';
    }else if(o==5){
        std::cout<<(s[x]^s[y]).count()<<'\n';
    }
}
```

#### 题解2：Usada_Pekora (4星)
**关键亮点：**
- 提出了用 `int` 代替 `bool` 数组的思路，进一步优化了空间和时间复杂度。
- 详细解释了如何利用 `__builtin_popcount` 来快速计算 `1` 的个数。
- 代码实现较为复杂，但思路清晰，适合对位运算有深入理解的读者。

**核心代码：**
```cpp
template<const int siz> struct Bitset {
    uint64_t bukket[buksize];
    inline void set1(int pos) {
        bukket[pos >> 6] |= 1ull << (pos & 63);
    }
    Bitset<siz> &operator <<= (const int len) {
        for (int i = buksize - 1; ~i; i--)
            for (uint64_t j = 63; ~j; j--) {
                if (bukket[i] >> j & 1)
                    set1((i << 6 | j) + len), set0(i << 6 | j);
            }
        return *this;
    }
};
```

#### 题解3：oddy (4星)
**关键亮点：**
- 简洁明了地介绍了 `bitset` 的基本操作，适合初学者理解。
- 通过 `t` 作为底集，确保集合元素始终在 `[1, m]` 范围内。
- 代码实现简洁，易于理解。

**核心代码：**
```cpp
std::bitset<30005> s[30005], t;
for(int i = 1; i <= m; i++) t.set(i);
while(q--) {
    scanf("%d%d%d", &o, &x, &y);
    switch(o) {
        case 1: s[x] = s[x] << y & t; break;
        case 2: s[x] = s[x] >> y & t; break;
        case 3: printf("%d\n", (s[x] & s[y]).count()); break;
        case 4: printf("%d\n", (s[x] | s[y]).count()); break;
        case 5: printf("%d\n", (s[x] ^ s[y]).count());
    }
}
```

### 最优关键思路或技巧
1. **`bitset` 的使用**：`bitset` 是一种高效的位操作数据结构，特别适合处理集合运算。通过左移、右移、与、或、异或等操作，可以快速实现集合的加减和交、并、对称差运算。
2. **边界处理**：通过设置一个底集 `t`，确保集合元素始终在 `[1, m]` 范围内，避免越界问题。
3. **位运算优化**：利用位运算的高效性，减少时间和空间复杂度，特别适合大规模数据处理。

### 可拓展之处
类似的问题可以扩展到其他集合运算，如子集、超集、补集等。此外，`bitset` 还可以用于处理其他需要高效位操作的场景，如状态压缩、图论中的邻接矩阵表示等。

### 推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)
3. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)

### 个人心得摘录
- **Limitless_lmw**：提到 `bitset<N>` 中的 `N` 必须为编译期常数，因此需要额外处理 `m` 不是常数的问题。
- **Usada_Pekora**：通过 `int` 代替 `bool` 数组，进一步优化了空间和时间复杂度，适合对位运算有深入理解的读者。
- **oddy**：简洁明了地介绍了 `bitset` 的基本操作，适合初学者理解。

---
处理用时：38.29秒
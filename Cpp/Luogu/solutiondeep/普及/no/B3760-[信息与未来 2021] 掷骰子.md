# 题目信息

# [信息与未来 2021] 掷骰子

## 题目背景

骰子是一个正六面体（立方体），每一面上有圆点表示的数字（圆点的数量表示数字的大小）。一个普通的骰子的六个面上分别有 $1\sim 6$ 这 $6$ 个不同的数字：

![](https://cdn.luogu.com.cn/upload/image_hosting/unawcttj.png)

## 题目描述

但是今天你得到了一个特殊的骰子，虽然每个面上的数字依然是 $1\sim 6$ 之间的一个，但不同面上的数字却可能重复。为了还原骰子上的数字，你使用摄像头从不同角度拍摄了多张骰子的照片（骰⼦可能在空间中任意翻转）。但限于摄像头的角度，你拍摄的每张照⽚都只能拍到骰子的三个面。

你需要根据摄像头拍摄到的多张照片，推断出骰子每个面上可能的数字。

## 说明/提示

### 样例解释
#### 样例 $1$
我们知道骰子上至少有三个 $1$、两个 $2$。剩下的数字可能是 $1$ 也可能是 $6$。

#### 样例 $2$
这是一个“普通”的骰⼦，$1\sim 6$ 这些数字恰好出现⼀次。

对于 $20\%$ 的数据，$0\le n\leq 1$。

对于 $100\%$ 的数据，$0\leq n\leq 20$。

>本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
2
1 1 1
2 2 1```

### 输出

```
8 13```

## 样例 #2

### 输入

```
2
1 2 3
4 5 6```

### 输出

```
21 21```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
本题的核心是通过多张照片中骰子三个面的数字，推断出骰子每个面上可能的数字。由于骰子的数字可能重复，且每张照片只能看到三个面，因此需要通过模拟和逻辑推理来确定每个面的数字范围。

### 通用建议与扩展思路
1. **模拟与逻辑推理**：通过模拟每张照片中骰子的状态，逐步缩小每个面可能的数字范围。
2. **枚举与剪枝**：在确定某些面的数字后，可以通过枚举和剪枝来减少不必要的计算。
3. **数据结构优化**：使用合适的数据结构（如数组、集合）来存储和更新每个面的可能数字。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 模拟与动态规划的结合。
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - 模拟与回溯的结合。
3. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002) - 模拟与动态规划的结合。

### 关键思路或技巧
1. **逐步缩小范围**：通过每张照片中骰子的三个面数字，逐步缩小每个面的可能数字范围。
2. **逻辑推理**：利用骰子的对称性和数字的重复性，进行逻辑推理，确定某些面的数字。
3. **数据结构优化**：使用数组或集合来存储每个面的可能数字，便于更新和查询。

### 代码实现
```cpp
#include <iostream>
#include <vector>
#include <set>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<set<int>> faces(6);
    for (int i = 0; i < 6; ++i) {
        for (int j = 1; j <= 6; ++j) {
            faces[i].insert(j);
        }
    }
    for (int i = 0; i < n; ++i) {
        int a, b, c;
        cin >> a >> b >> c;
        for (int j = 0; j < 6; ++j) {
            if (j != 0 && j != 1 && j != 2) {
                faces[j].erase(a);
                faces[j].erase(b);
                faces[j].erase(c);
            }
        }
    }
    int minSum = 0, maxSum = 0;
    for (int i = 0; i < 6; ++i) {
        minSum += *faces[i].begin();
        maxSum += *faces[i].rbegin();
    }
    cout << minSum << " " << maxSum << endl;
    return 0;
}
```

### 代码核心思想
1. **初始化**：为骰子的每个面初始化可能的数字范围（1到6）。
2. **更新范围**：根据每张照片中骰子的三个面数字，更新其他面的可能数字范围。
3. **计算最小和最大和**：根据每个面的可能数字范围，计算骰子所有面数字的最小和和最大和。

通过这种方法，可以有效地推断出骰子每个面上可能的数字范围，并计算出最小和和最大和。

---
处理用时：24.62秒
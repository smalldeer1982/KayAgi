# 题目信息

# [信息与未来 2022] 完美字符串

## 题目描述

你可能见过下面这一句英文：

> "The quick brown fox jumps over the lazy dog."

短短的一句话就包含了所有 $26$ 个英文字母！因此这句话广泛地用于字体效果的展示。更短的还有：

> "The five boxing wizards jump quickly."

所以你很好奇：还有没有更多这样包含所有 $26$ 个英文字母的句子？于是你用爬虫在互联网上爬取了许多英文文本，并且提取出了其中的单词。你现在希望从一个很长的单词序列中找出**一段连续出现的**单词，它满足：

- 所有 $26$ 个英文字母都至少出现一次；
- 长度尽可能短，即包含的字母总数尽可能少。

## 说明/提示

最短满足条件的单词序列是 "is a quick brown fox jumping over the lazy dog"，共有 $37$ 个字母。

对于 $40\%$ 的数据，满足 $n\leq 100$；  
对于 $100\%$ 的数据，满足 $1\leq n\leq 100,000$。每个单词的长度不超过 $10$ 个字符，且单词全部由小写英文字母 $\texttt{a-z}$ 构成。

## 样例 #1

### 输入

```
13
there is a quick brown fox jumping over the lazy dog and cat```

### 输出

```
37```

# AI分析结果

### 算法分类
字符串、滑动窗口

### 综合分析与结论
本题要求从一段连续的单词序列中找出包含所有26个英文字母的最短子序列。由于需要检查每个子序列是否包含所有字母，并且要求长度最短，因此可以使用滑动窗口算法来优化搜索过程。滑动窗口算法能够在O(n)的时间复杂度内解决此类问题，适合处理大规模数据。

### 通用建议与扩展思路
1. **滑动窗口**：滑动窗口是处理连续子序列问题的常用技巧，适用于需要在数组中寻找满足特定条件的最短或最长子序列的场景。
2. **字母统计**：使用哈希表或数组来统计窗口中每个字母的出现次数，可以快速判断是否包含所有26个字母。
3. **优化**：在滑动窗口的基础上，可以进一步优化，例如通过记录每个字母的最后出现位置来减少不必要的窗口移动。

### 推荐题目
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102) - 考察滑动窗口和哈希表的应用。
2. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638) - 滑动窗口的经典应用，寻找包含所有指定元素的最短子序列。
3. [P3405 [USACO16DEC]Cities and States S](https://www.luogu.com.cn/problem/P3405) - 使用滑动窗口和哈希表解决字符串匹配问题。

### 关键代码实现
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<string> words(n);
    for (int i = 0; i < n; ++i) {
        cin >> words[i];
    }

    unordered_map<char, int> count;
    int left = 0, min_len = INT_MAX, required = 26, formed = 0;

    for (int right = 0; right < n; ++right) {
        for (char c : words[right]) {
            if (count[c] == 0) formed++;
            count[c]++;
        }

        while (formed == required) {
            int current_len = 0;
            for (int i = left; i <= right; ++i) {
                current_len += words[i].length();
            }
            if (current_len < min_len) {
                min_len = current_len;
            }

            for (char c : words[left]) {
                count[c]--;
                if (count[c] == 0) formed--;
            }
            left++;
        }
    }

    cout << (min_len == INT_MAX ? 0 : min_len) << endl;
    return 0;
}
```
**核心实现思想**：
1. 使用滑动窗口遍历单词序列，统计每个窗口中字母的出现次数。
2. 当窗口包含所有26个字母时，计算当前窗口的长度并尝试缩小窗口以寻找更短的满足条件的子序列。
3. 通过维护一个哈希表来记录窗口中每个字母的出现次数，确保窗口的移动和字母统计的高效性。

---
处理用时：20.59秒
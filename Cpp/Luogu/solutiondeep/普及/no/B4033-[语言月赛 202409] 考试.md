# 题目信息

# [语言月赛 202409] 考试

## 题目描述

迅风和他的好朋友一同参加了 $n$ 场考试，而迅风拥有预知未来和**提升自己分数**的能力。

在第 $i$ 场考试中，迅风知道他自己原来取得 $a_i$ 分，他的好朋友**一定会**取得 $b_i$ 分。

而他们很喜欢争个高下，设迅风在 $x$ 场考试中分数比他的好朋友高，在 $y$ 场考试中分数比他的好朋友低，那么：

- 若 $x>y$，则说明在这 $n$ 场考试中，迅风更胜一筹。
- 若 $x<y$，则说明迅风的好朋友更胜一筹。
- 若 $x=y$，则说明两人打平。

迅风发现自己可能会输给他的朋友，于是他可以选择若干场考试**提升自己的分数**，记增加的分数总和为 $sum$。

迅风想知道，自己要在这 $n$ 场考试中更胜一筹，所需的 $sum$ 最小为多少？

## 说明/提示

**【样例 1 解释】**

只要把第 $3$ 次考试的得分提升 $6$ 分，就可以在第 $2,3$ 次考试中获得比朋友更高的分数，从而 $x=2,y=1$，迅风更胜一筹。

**【样例 2 解释】**

只要把第 $1,3,4$ 次考试的得分各提升 $1$ 分，就可以让 $x=2,y=1$，从而让迅风更胜一筹。

**【样例 3 解释】**

哪怕不提升分数，也有 $x=2,y=0$ 了，迅风已经更胜一筹。

**【数据范围】**

本题共有 $20$ 个测试点，测试点等分。

|测试点编号|$n\le$|特殊性质|
|:-:|:-:|:-:|
|$1\sim 2$|$2$||
|$3\sim 6$|$100$|$a_i,b_i\le 2$|
|$7$|$1000$|每次考试两人成绩都相等|
|$8\sim 11$|$1000$|迅风成绩递增，他朋友成绩递减|
|$12\sim 15$|$1000$|每次考试两人成绩都不相等|
|$16\sim 20$|$1000$||

**关于测试点 $8\sim 11$，这里的递增和递减是不严格的，如 $1,5,5,8,10$ 也视为递增。**

特别地，编号为奇数的测试点 $n$ 为奇数，编号为偶数的测试点 $n$ 为偶数。

对于全体数据，保证 $1\le n\le 1000$，$1\le a_i,b_i\le 10^4$（也就是 $10000$），输入皆为整数。

**【后记】**
祝各位参加 $2024$ 年 CSP 比赛的选手 rp++！

## 样例 #1

### 输入

```
3
30 10 9995
100 1 10000
```

### 输出

```
6
```

## 样例 #2

### 输入

```
4
10 20 50 90
11 22 50 90
```

### 输出

```
3
```

## 样例 #3

### 输入

```
3
100 100 1
3 3 1
```

### 输出

```
0
```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
本题的核心在于通过贪心策略，选择最少的分数提升，使得迅风在考试中胜出的次数最多。题解通过计算每场考试迅风需要提升的分数，并对其进行排序，然后逐步选择最小的提升分数，直到迅风的胜出次数超过朋友。这种贪心策略能够保证在最小代价下达到目标。

### 所选题解
#### 题解作者：szh_AK_all
- **星级**: 4
- **关键亮点**: 使用贪心策略，通过排序和逐步选择最小提升分数，确保在最小代价下达到目标。
- **个人心得**: 无

### 核心代码实现思想
1. 计算每场考试迅风需要提升的分数 `c[i] = b[i] - a[i]`。
2. 对 `c` 数组进行排序。
3. 统计初始情况下迅风和朋友的胜出次数 `x` 和 `y`。
4. 逐步选择最小的提升分数，更新 `x` 和 `y`，直到 `x > y`。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1005], b[1005], c[1005];

int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++)
		cin >> b[i];
	for (int i = 1; i <= n; i++)
		c[i] = b[i] - a[i];
	sort(c + 1, c + n + 1);
	int x = 0, y = 0;
	for (int i = 1; i <= n; i++) {
		if (c[i] == 0)
			continue;
		if (c[i] < 0)
			x++;
		else
			y++;
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		if (x > y)
			break;
		if (c[i] < 0)
			continue;
		if (c[i] > 0) {
			ans += c[i];
			y--;
		}
		if (x > y)
			break;
		ans++;
		x++;
	}
	cout << ans;
}
```

### 扩展思路
类似的问题可以通过贪心策略解决，例如在资源分配、任务调度等问题中，选择最优的局部解以达到全局最优。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：20.42秒
# 题目信息

# [CSP-X2023 山东] 回文字符串

## 题目描述


作为一个新手，小明刚学了回文字符串，知道了一个字符串如果关于中心对称，则该字符串为回文字符串。

于是他自己就发明了属于他自己的回文字符串，即符合以下条件的字符串 $S$ 是回文字符串：

首先把字符串 $S$ 分割成 $n$ 个子串 $S_1,S_2,\ldots,S_n$，即 $S_1+S_2+\ldots+S_n = S$（其中 $+$ 为字符串拼接操作）。

分割成的子串数量需要大于 $1$，且不能为空，即 $n > 1$ 且 $S_i$ 为非空子串。

对于所有的 $i \in[1, n]$ 有：要么 $S_i$ 与 $S_{n−i+1}$ 相等，要么 $S_i$ 与 $S_{n−i+1}$ 互为回文。（补充说明：字符串 $A$ 和 $B$ 互为回文指 $A$ 倒过来与 $B$ 相等，反之亦然。举例说明：$\texttt{abc}$ 与 $\texttt{cba}$ 互为回文。）

给定一个字符串 $S$，请你帮助小明确定该字符串是否是在上述规则下的回文字符串。

如果是，他还想将字符串 $S$ 分成尽可能多的子串。

## 说明/提示


### 样例解释

- 样例 $1$ 解释：最多可以把字符串分成 $\texttt{(a)(b)(c)(ab)(a)}$ 共 8 个子串。
- 样例 $2$ 解释：很显然不存在满足题意的分割方案。
- 样例 $3$ 解释：最多可以把字符串分成 $\texttt{(waha)(code)(waha)}$ 共 3 个子串。


### 数据范围

对于 $30\%$ 的数据，$1\le |S|\le 10$；（其中 $S$ 为给定字符串的长度）

对于 $60\%$ 的数据，$1\le |S |\le 10^3$；

其中有 $30\%$ 的数据，输入的字符串为回文字符串；

对于 $100\%$ 的数据，$1\le| S |\le10^4$，保证输入的字符串全为小写字母。

## 样例 #1

### 输入

```
abcababcba```

### 输出

```
YES 
8```

## 样例 #2

### 输入

```
goodluckhavefun```

### 输出

```
NO```

## 样例 #3

### 输入

```
wahacodewaha```

### 输出

```
YES
3```

# AI分析结果

### 算法分类
字符串、贪心

### 综合分析与结论
该题目要求将字符串分割成多个子串，且这些子串需要满足对称性（相等或互为回文）。核心思路是通过贪心策略，尽可能多地分割子串。难点在于如何高效地判断子串是否满足条件，并确保分割的子串数量最大化。

### 所选高星题解
#### 1. 作者：2021CHD (4星)
**关键亮点**：
- 通过贪心策略，每次从两边选取最短的合法子串，确保分割的子串数量最大化。
- 提供了详细的证明，解释了为什么贪心策略是正确的。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(i=1;i<=len;i++) {
    for(j=ll;j<=i;j++)
        if(s[j]!=s[len-i+j-ll+1]) break;
    if(j>i) {
        ll=i+1;
        if(i*2<=len) ans=ans+2;
        else ans++;
    }
    if(ll*2-1>len) break;
}
```
**核心思想**：从字符串的两端开始，逐个字符比较，找到最短的合法子串并进行分割。

#### 2. 作者：ma13863674407 (4星)
**关键亮点**：
- 通过双指针从两端向中间遍历，判断子串是否相等或互为回文。
- 使用字符串拼接和反转操作，简化了判断逻辑。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
while(i<=j) {
    if(flag) {
        s+=a[i]; 
        s1.insert(s1.begin(),a[j]); 
        if(s==s1) {
            flag=0;
            s.clear();
            s1.clear();
            ans+=2;
        }
    } else {
        if(a[i]==a[j]) ans+=2;
        else {
            flag=1;
            s+=a[i];
            s1.insert(s1.begin(),a[j]);
        }
    }
    i++; j--;
}
```
**核心思想**：通过双指针从两端向中间遍历，判断子串是否满足条件，并根据条件更新分割的子串数量。

#### 3. 作者：woyaoxiaban (4星)
**关键亮点**：
- 使用两个字符串变量 `s1` 和 `s2` 分别从开头和结尾匹配，简化了判断逻辑。
- 通过清空字符串变量，确保每次匹配都是独立的。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
while(i<len&&j>=0) {
    s1+=s[i]; 
    s2=s[j]+s2; 
    if(s1==s2) ans++,s1="",s2=""; 
    i++,j--;
}
```
**核心思想**：从字符串的开头和结尾同时匹配，找到相等的子串并进行分割。

### 最优关键思路
1. **贪心策略**：从字符串的两端开始，尽可能多地分割出最短的合法子串，确保分割的子串数量最大化。
2. **双指针遍历**：使用双指针从两端向中间遍历，判断子串是否满足条件。
3. **字符串反转**：通过字符串反转操作，简化判断子串是否互为回文的逻辑。

### 可拓展之处
- 类似题目可以考察字符串的对称性、回文性质等，如判断字符串是否为回文、最长回文子串等。
- 可以使用动态规划或Manacher算法来优化回文子串的判断。

### 推荐题目
1. [P1219 回文数](https://www.luogu.com.cn/problem/P1219)
2. [P1435 回文字符串](https://www.luogu.com.cn/problem/P1435)
3. [P3805 Manacher算法](https://www.luogu.com.cn/problem/P3805)

### 个人心得摘录
- **2021CHD**：通过贪心策略，每次选取最短的合法子串，确保分割的子串数量最大化。这种策略虽然在直觉上可行，但通过详细的证明，确保了其正确性。
- **ma13863674407**：通过双指针从两端向中间遍历，简化了判断逻辑。这种思路在实际编码中非常实用，能够有效减少代码复杂度。

---
处理用时：32.36秒
# 题目信息

# [CSP-X2023 山东] 代价

## 题目描述

因为“黑发不知勤学早”，于是小明成为了一名伟大的流水线工人，天天起早摸黑打螺丝。

这一天，小明所在的流水线生成了 $n$ 件产品，其中第 $i$ 号产品规格用一个正整数 $a_i$ 表示。

所谓流水线，就是需要标准化。于是，小明想把这 $n$ 件产品规格修整得全部相同。

小明手边有两种工具来进对产品进行修整，但是使用不同工具需要花费不同的代价，小明可以进行以下操作任意次：

- 使用一次第一种工具花费 $A$ 的代价将第 $i$ 件产品的规格 $a_i$ 修改成 $a_i+1$（其中 $i\in [1,n]$）。
- 使用一次第二种工具花费 $B$ 的代价将第 $i$ 件产品的规格 $a_i$ 修改成 $a_i-1$（其中 $i\in [1,n]$）。

现在小明想要花费最少的代价将所有产品的规格都变得相同，于是他找到了自幼勤学苦练的你来帮忙。

你只需要计算出把所有产品调整为相同规格的最小代价即可。


## 说明/提示


### 样例解释

- 样例 $1$ 解释：两种操作的代价相等，所以把所有产品规格修改成 $2$ 花费的代价最小，计算可得最小代价为 $4$（$1$ 变为$2$，$5$ 变为 $4$，$4$ 再变为 $3$，$3$ 再变为 $2$，已经规格相同，共 $4$ 次）。
- 样例 $2$ 解释：因为二操作代价 $B$ 太大，所以把所有产品规格修改成 $5$ 花费代价最小，计算可得最小代价为 $7$（用一操作，$1$ 变为 $5$ 需要 $4$ 次，$2$ 变为 $5$ 需要 $3$ 次，共 $7$ 次）。


### 数据范围

对于 $30\%$ 的数据，$1\le n\le 10$，$1\le a_i \le100 $，$1\le A,B \le10$；

对于 $60\%$ 的数据，$1\le n\le 10^5$，$1\le a_i \le10^5 $，$1\le A,B \le100$；

其中有 $30\%$ 的数据，$A=B$；

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le a_i \le10^9 $，$1\le A,B \le1000$。
	

## 样例 #1

### 输入

```
3 1 1 
1 2 5```

### 输出

```
4```

## 样例 #2

### 输入

```
3 1 100 
1 2 5```

### 输出

```
7```

## 样例 #3

### 输入

```
3 2 5 
9999999999 9999999999 9999999999```

### 输出

```
0```

# AI分析结果

### 算法分类
**前缀和**

### 综合分析与结论
题目要求将所有产品的规格调整为相同，且每次调整的代价不同。核心思路是通过排序和前缀和来优化计算，找到最小代价。大多数题解都采用了排序和前缀和的技巧，通过枚举每个可能的规格值，计算调整到该规格的总代价，并选择最小值。这种方法的复杂度为 \(O(n \log n)\)，能够有效处理大规模数据。

### 所选高星题解
#### 1. 作者：FJ_EYoungOneC (赞：1) - 4星
**关键亮点**：
- 使用前缀和优化计算，减少时间复杂度。
- 通过排序和枚举每个规格值，计算调整代价，确保找到最小代价。

**核心代码**：
```cpp
for (int i = 1; i <= n; ++i) {
    res = min(res, A * ((i - 1) * a[i] - l[i - 1]) + B * (r[i + 1] - (n - i) * a[i]));
}
```
**实现思想**：通过前缀和数组 `l` 和 `r`，快速计算每个规格值的调整代价，选择最小值。

#### 2. 作者：cxoi1711 (赞：0) - 4星
**关键亮点**：
- 简洁的代码实现，使用前缀和和排序，快速计算最小代价。
- 通过公式直接计算调整代价，避免重复计算。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    t=((i-1)*a[i]-sum[i-1])*A+(sum[n]-sum[i]-(n-i)*a[i])*B;
    ans=min(ans,t);
}
```
**实现思想**：利用前缀和数组 `sum`，直接计算每个规格值的调整代价，选择最小值。

#### 3. 作者：yyycj (赞：0) - 4星
**关键亮点**：
- 使用前缀和和排序，快速计算最小代价。
- 通过公式直接计算调整代价，避免重复计算。

**核心代码**：
```cpp
for (int i=1;i<=n;i++) {
    ll sum1 = (nums[i]*(i-1)-pre[i-1]) * a;
    ll sum2 = ((pre[n]-pre[i])-nums[i]*(n-i)) * b;
    ans = min(ans,sum1+sum2);
}
```
**实现思想**：利用前缀和数组 `pre`，直接计算每个规格值的调整代价，选择最小值。

### 最优关键思路或技巧
- **排序与前缀和**：通过排序和前缀和，快速计算每个规格值的调整代价，避免重复计算，优化时间复杂度。
- **枚举与最小值选择**：枚举每个可能的规格值，计算调整代价，选择最小值，确保找到最优解。

### 可拓展之处
- **类似问题**：类似的问题可以涉及其他需要调整数值的场景，如调整温度、调整速度等，都可以通过排序和前缀和来优化计算。
- **算法套路**：排序+前缀和+枚举的套路，适用于需要快速计算区间和或调整代价的问题。

### 推荐题目
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
2. [P1083 借教室](https://www.luogu.com.cn/problem/P1083)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得摘录
- **调试经历**：在实现前缀和时，注意数组下标从1开始，避免越界错误。
- **踩坑教训**：在计算调整代价时，注意区分 `A` 和 `B` 的代价，避免混淆。
- **顿悟感想**：通过排序和前缀和，可以大大减少计算量，提高代码效率。

---
处理用时：29.52秒
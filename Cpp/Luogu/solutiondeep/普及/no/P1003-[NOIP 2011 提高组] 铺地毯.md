# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果

### 算法分类
模拟

### 题解分析与结论
本题的核心逻辑是模拟地毯覆盖的过程，并找到覆盖指定点的最上层地毯。由于数据范围较大（$n \le 10^4$），直接使用二维数组存储每个点的覆盖情况会导致内存溢出（MLE）。因此，大多数题解采用了更高效的方法：存储每张地毯的坐标范围，然后依次检查指定点是否被每张地毯覆盖。

### 精选题解

#### 1. 作者：智子 (赞：263)
- **星级**: 5星
- **关键亮点**: 
  - 使用四个数组分别存储地毯的坐标范围，避免了二维数组的内存问题。
  - 通过简单的条件判断检查点是否被地毯覆盖，代码简洁高效。
  - 提供了MLE的失败案例，帮助理解问题难点。
- **个人心得**: 
  - 通过MLE的失败案例，强调了内存优化的重要性。
  - 使用四个数组存储地毯信息，避免了二维数组的内存问题。

```cpp
#include<stdio.h>

const int MAXN = 10000 + 5;

int a[MAXN], b[MAXN], g[MAXN], k[MAXN];

int main() {
    int n, x, y;
    
    scanf("%d", &n);
    for(int i = 0; i < n; i++) {
        scanf("%d%d%d%d", &a[i], &b[i], &g[i], &k[i]);
    }
    scanf("%d%d", &x, &y);
    
    int ans = -1;
    for(int i = 0; i < n; i++) {
        if(x >= a[i] && y >= b[i] && x <= a[i] + g[i] && y <= b[i] + k[i]) {
            ans = i + 1;
        }
    }
    
    printf("%d\n", ans);
    
    return 0;
}
```

#### 2. 作者：FreedomKing (赞：74)
- **星级**: 4星
- **关键亮点**: 
  - 使用结构体数组存储地毯信息，代码结构清晰。
  - 通过简单的条件判断检查点是否被地毯覆盖，代码简洁高效。
- **个人心得**: 
  - 通过结构体数组存储地毯信息，代码结构更加清晰。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int a[N],b[N],g[N],k[N],n,m,t,ans=-1;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i]>>b[i]>>g[i]>>k[i];
	int x,y;
	cin>>x>>y;
	for(int i=1;i<=n;i++){
		if((x>=a[i]&&x<=a[i]+g[i])&&(y>=b[i]&&y<=b[i]+k[i]))
			ans=i;
	}
	cout<<ans;
	return 0;
}
```

#### 3. 作者：谁懂谁伤心 (赞：47)
- **星级**: 4星
- **关键亮点**: 
  - 从后向前遍历地毯，找到第一个覆盖点的地毯即可输出，减少了不必要的遍历。
  - 使用两个数组存储地毯的坐标范围，代码简洁高效。
- **个人心得**: 
  - 通过从后向前遍历地毯，减少了不必要的遍历，提高了效率。

```cpp
#include <iostream>  
using namespace std;  
int a[10001][2],b[10001][2],x,y,i,n,m;  
int main()  
{  
scanf ("%d",&i);   
for (int j=1;j<=i;j++) {scanf("%d%d%d%d",&a[j][0],&a[j][1],&n,&m); b[j][0]=a[j][0]+n; b[j][1]=a[j][1]+m;}  
scanf ("%d%d",&x,&y);  
for (int j=i;j>=1;j--)  
if (x>=a[j][0]&&x<=b[j][0]&&y>=a[j][1]&&y<=b[j][1]) {printf("%d",j);  return 0;}  
cout <<-1;  return 0;  
}  
```

### 最优关键思路
- **数据结构优化**: 使用多个一维数组或结构体数组存储地毯信息，避免二维数组的内存问题。
- **遍历优化**: 从后向前遍历地毯，找到第一个覆盖点的地毯即可输出，减少不必要的遍历。

### 可拓展之处
- **类似问题**: 类似的问题包括矩形覆盖、区间覆盖等，可以使用类似的数据结构优化和遍历优化方法。
- **算法套路**: 在处理大规模数据时，优先考虑内存优化和遍历优化，避免不必要的计算和存储。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

---
处理用时：30.22秒
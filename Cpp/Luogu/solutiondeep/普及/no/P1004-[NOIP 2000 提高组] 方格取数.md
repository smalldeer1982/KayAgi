# 题目信息

# [NOIP 2000 提高组] 方格取数

## 题目背景

NOIP 2000 提高组 T4

## 题目描述

设有 $N \times N$ 的方格图 $(N \le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:

![](https://cdn.luogu.com.cn/upload/image_hosting/0bpummja.png)

某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  
此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。


## 说明/提示

数据范围：$1\le N\le 9$。

## 样例 #1

### 输入

```
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0
```

### 输出

```
67```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
本题的核心是通过动态规划求解两条路径的最大和，难点在于如何同时处理两条路径，并避免重复计算。大多数题解采用了四维DP或三维DP的思路，通过状态转移方程来计算两条路径的最大和。部分题解还进行了空间优化，如使用滚动数组或降维处理。整体上，动态规划是解决该问题的标准方法，关键在于状态的设计和转移方程的推导。

### 所选题解

#### 1. 作者：wzxx (赞：401)
- **星级**: 5星
- **关键亮点**: 使用深度优先搜索（DFS）结合记忆化剪枝，避免了四维DP的复杂性，思路清晰且代码简洁。
- **个人心得**: 通过同时处理两条路径，避免了单独处理时的不可控因素，剪枝策略有效减少了重复计算。
- **核心代码**:
```cpp
int dfs(int x,int y,int x2,int y2) {
    if (f[x][y][x2][y2]!=-1) return f[x][y][x2][y2];
    if (x==N&&y==N&&x2==N&&y2==N) return 0;
    int M=0;
    if (x<N&&x2<N) M=max(M,dfs(x+1,y,x2+1,y2)+s[x+1][y]+s[x2+1][y2]-s[x+1][y]*(x+1==x2+1&&y==y2));
    if (x<N&&y2<N) M=max(M,dfs(x+1,y,x2,y2+1)+s[x+1][y]+s[x2][y2+1]-s[x+1][y]*(x+1==x2&&y==y2+1));
    if (y<N&&x2<N) M=max(M,dfs(x,y+1,x2+1,y2)+s[x][y+1]+s[x2+1][y2]-s[x][y+1]*(x==x2+1&&y+1==y2));
    if (y<N&&y2<N) M=max(M,dfs(x,y+1,x2,y2+1)+s[x][y+1]+s[x2][y2+1]-s[x][y+1]*(x==x2&&y+1==y2+1));
    f[x][y][x2][y2]=M;
    return M;
}
```

#### 2. 作者：Azuree (赞：104)
- **星级**: 4星
- **关键亮点**: 通过降维优化，将四维DP降为三维，减少了空间复杂度，思路清晰且代码简洁。
- **核心代码**:
```cpp
for(int k = 1; k <= m + n; k++)
    for(int i = 1; i <= min(k,n); i++)
        for(int j = 1; j <= min(k,n); j++) {
            f[k][i][j] = cmp(f[k - 1][i][j],f[k - 1][i - 1][j],f[k - 1][i][j - 1],f[k - 1][i - 1][j - 1]) + map[k - i + 1][i] + map[k - j + 1][j];
            if(i == j) f[k][i][j] -= map[k - i + 1][i];
        }
```

#### 3. 作者：road (赞：185)
- **星级**: 4星
- **关键亮点**: 提供了二维DP和四维DP两种思路，对比了贪心策略的局限性，代码实现清晰。
- **核心代码**:
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= n; j++)
        for(int k = 1; k <= n; k++)
            for(int l = 1; l <= n; l++) {
                dp[i][j][k][l] = max(max(dp[i-1][j][k-1][l], dp[i-1][j][k][l-1]), max(dp[i][j-1][k-1][l], dp[i][j-1][k][l-1])) + a[i][j] + a[k][l];
                if(i == k && j == l) dp[i][j][k][l] -= a[i][j];
            }
```

### 最优关键思路或技巧
1. **同时处理两条路径**：通过同时处理两条路径，避免了单独处理时的不可控因素，确保全局最优解。
2. **降维优化**：通过观察两条路径的步数相同，将四维DP降为三维，减少了空间复杂度。
3. **记忆化剪枝**：在DFS中使用记忆化剪枝，避免了重复计算，提高了效率。

### 可拓展之处
类似的双路径问题可以通过类似的动态规划思路解决，如[P1006 传纸条](https://www.luogu.com.cn/problem/P1006)，[P2774 方格取数问题](https://www.luogu.com.cn/problem/P2774)。

### 推荐题目
1. [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)
2. [P2774 方格取数问题](https://www.luogu.com.cn/problem/P2774)
3. [P4066 [SHOI2003]吃豆豆](https://www.luogu.com.cn/problem/P4066)

---
处理用时：40.79秒
# 题目信息

# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
本题的核心是使用动态规划（DP）来解决矩阵取数问题。由于每行的取数操作相互独立，因此可以对每一行分别进行DP计算，最后将各行的结果相加得到最终答案。DP的状态通常定义为区间 `[i, j]` 的最大得分，转移方程则根据取数的顺序（从左或从右）来确定。由于数据范围较大，需要使用高精度或 `__int128` 来处理大数运算。

### 所选题解

#### 1. 作者：Jack_Homes_Huang (5星)
- **关键亮点**：详细解释了DP的状态定义和转移方程，并提供了高精度的实现代码。代码结构清晰，注释详细，适合初学者理解。
- **个人心得**：作者提到高精度的实现较为繁琐，但通过结构体重载运算符简化了代码编写。

```cpp
HP operator + (const HP &a, const HP &b) {
    HP c; c.len = max(a.len, b.len); int x = 0;
    for (int i = 1; i <= c.len; i++) {
        c.p[i] = a.p[i] + b.p[i] + x;
        x = c.p[i] / Mod;
        c.p[i] %= Mod;
    }
    if (x > 0)
        c.p[++c.len] = x;
    return c;
}
```

#### 2. 作者：zhylj (4星)
- **关键亮点**：提供了简洁的DP转移方程，并使用 `__int128` 来避免高精度运算的复杂性。代码简洁高效，适合有一定基础的读者。
- **个人心得**：作者强调了每行取数的独立性，简化了问题的复杂度。

```cpp
__int128 solve(__int128 a[]) {
    memset(f,0,sizeof(f));
    for(int len=0;len<=m;++len)
        for(int i=1;i+len<=m;++i)
            f[i][i+len]=max(2*f[i+1][i+len]+2*a[i],2*f[i][i+len-1]+2*a[i+len]);
    return f[1][m];
}
```

#### 3. 作者：qhr2023 (4星)
- **关键亮点**：详细解释了DP的转移过程，并提供了完整的代码实现。代码结构清晰，适合初学者理解。
- **个人心得**：作者提到DP的转移顺序需要特别注意，确保从大区间向小区间转移。

```cpp
for (int len=1; len<=m; ++len) 
    for (int l=1, r=l+len-1; r<=m; ++l, ++r)
        f[l][r]=max(f[l+1][r]+a[i][l], f[l][r-1]+a[i][r])*2;
```

### 最优关键思路或技巧
1. **DP状态定义**：将状态定义为区间 `[i, j]` 的最大得分，便于处理取数的顺序。
2. **高精度处理**：使用 `__int128` 或自定义高精度结构体来处理大数运算。
3. **转移顺序**：从大区间向小区间转移，确保每次取数的顺序正确。

### 可拓展之处
类似的问题可以扩展到其他区间DP问题，如最长回文子序列、石子合并等。通过调整状态定义和转移方程，可以解决不同类型的区间DP问题。

### 推荐题目
1. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1040 [NOIP2003 提高组] 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1063 [NOIP2006 提高组] 能量项链](https://www.luogu.com.cn/problem/P1063)

### 个人心得总结
- **调试经历**：多位作者提到高精度实现的繁琐性，建议使用 `__int128` 简化代码。
- **踩坑教训**：DP的转移顺序需要特别注意，确保从大区间向小区间转移。
- **顿悟感想**：每行取数的独立性简化了问题的复杂度，使得问题可以分解为多个子问题分别解决。

---
处理用时：27.06秒
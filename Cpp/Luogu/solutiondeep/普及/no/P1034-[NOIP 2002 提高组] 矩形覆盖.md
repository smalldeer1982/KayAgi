# 题目信息

# [NOIP 2002 提高组] 矩形覆盖

## 题目描述

在平面上有 $n$ 个点，每个点用一对整数坐标表示。例如：当 $n=4$ 时，$4$ 个点的坐标分别为：$p_1(1,1)$，$p_2(2,2)$，$p_3(3,6)$，$p_4(0,7)$，见图一。

![](https://cdn.luogu.com.cn/upload/image_hosting/dxc1c5k9.png)

这些点可以用 $k$ 个矩形全部覆盖，矩形的边平行于坐标轴。当 $k=2$ 时，可用如图二的两个矩形 $s_1,s_2$ 覆盖，$s_1,s_2$ 面积和为 $4$。问题是当 $n$ 个点坐标和 $k$ 给出后，怎样才能使得覆盖所有点的 $k$ 个矩形的面积之和为最小呢？  
约定：覆盖一个点的矩形面积为 $0$；覆盖平行于坐标轴直线上点的矩形面积也为 $0$。各个矩形必须完全分开（边线与顶点也都不能重合）。


## 说明/提示

对于 $100\%$ 数据，满足 $1\le n \le  50$，$1 \le k \le 4$，$0 \le x_i,y_i  \le 500$。

**【题目来源】**

NOIP 2002 提高组第四题

## 样例 #1

### 输入

```
4 2
1 1
2 2
3 6
0 7
```

### 输出

```
4```

# AI分析结果

### 算法分类
深度优先搜索 DFS

### 综合分析与结论
题目要求用最少的矩形面积覆盖所有点，且矩形之间不能相交。由于数据规模较小（n ≤ 50，k ≤ 4），适合使用深度优先搜索（DFS）进行枚举。两种题解均采用DFS，但在实现细节和优化上有所不同。

### 所选题解

#### 题解1：作者：_Life_ (赞：9)
- **星级**：5星
- **关键亮点**：
  - 使用DFS枚举所有可能的矩形组合，确保矩形不相交。
  - 通过`join`函数将点加入矩形，并动态更新矩形的边界。
  - 使用`is_intersect`函数判断矩形是否相交，确保矩形之间无重叠。
  - 代码结构清晰，逻辑严谨，易于理解。

**核心代码**：
```cpp
void dfs(int u)
{
	if(u==n+1)
	{
		int sum=0;
		for(int i=0;i<k;i++)sum+=squ[i].area();
		ans=min(ans,sum);
		return;
	}
	for(int i=0;i<k;i++)
	{
		square t=squ[i];
		squ[i].join(u);
		if(!is_intersect(i))
			dfs(u+1);
		squ[i]=t;
	}
}
```

#### 题解2：作者：ShineEternal (赞：4)
- **星级**：4星
- **关键亮点**：
  - 同样使用DFS，但增加了对矩形扩展和自成一体的处理。
  - 通过`check`函数判断矩形是否重叠，确保矩形之间无重叠。
  - 代码实现较为复杂，但逻辑完整，覆盖了所有可能的矩形组合。

**核心代码**：
```cpp
void dfs(int now,int s,int cnt)
{
	if(s>ans)return ;
	if(now==n+1)
	{
		if(cnt==k)
		ans=min(ans,s);
		return ;
	}
	for(int i=1;i<=cnt;i++)
	{
		if(jx[i].x1<=x[now]&&jx[i].x2>=x[now]&&jx[i].y1<=y[now]&&jx[i].y2>=y[now])
		{
			dfs(now+1,s,cnt);
		}
		else
		{
			int tmp1,tmp2,tmp3,tmp4;
			tmp1=jx[i].x1;
			tmp2=jx[i].x2;
			tmp3=jx[i].y1;
			tmp4=jx[i].y2;
			int stmpf=mj(i);
			if(x[now]<jx[i].x1)
			{
				jx[i].x1=x[now];
			}
			else if(x[now]>jx[i].x2)
			{
				jx[i].x2=x[now];
			}
			if(y[now]<jx[i].y1)
			{
				jx[i].y1=y[now];
			}
			else if(y[now]>jx[i].y2)
			{
				jx[i].y2=y[now];
			}
			int stmp=mj(i);
			if(check(i,cnt))
				dfs(now+1,s+stmp-stmpf,cnt);
			jx[i].x1=tmp1;
			jx[i].x2=tmp2;
			jx[i].y1=tmp3;
			jx[i].y2=tmp4;
		}
	}
	if(cnt==k)return ;
	cnt++;
	jx[cnt].x1=x[now];
	jx[cnt].x2=x[now];
	jx[cnt].y1=y[now];
	jx[cnt].y2=y[now];
	dfs(now+1,s,cnt);
	jx[cnt].x1=0;
	jx[cnt].x2=0;
	jx[cnt].y1=0;
	jx[cnt].y2=0;
	cnt--;
	return;
}
```

### 最优关键思路或技巧
- **DFS枚举**：通过DFS枚举所有可能的矩形组合，确保覆盖所有点且矩形不相交。
- **动态更新矩形边界**：在DFS过程中动态更新矩形的边界，确保矩形能够覆盖新加入的点。
- **矩形相交判断**：通过判断矩形的边界是否重叠，确保矩形之间无重叠。

### 可拓展之处
- **剪枝优化**：在DFS过程中，可以通过剪枝减少不必要的搜索，提高效率。
- **动态规划**：对于更大规模的数据，可以考虑使用动态规划进行优化。

### 推荐题目
1. [P1034 矩形覆盖](https://www.luogu.com.cn/problem/P1034)
2. [P1035 矩形覆盖](https://www.luogu.com.cn/problem/P1035)
3. [P1036 矩形覆盖](https://www.luogu.com.cn/problem/P1036)

### 个人心得
- **调试经历**：在实现DFS时，需要注意矩形边界的更新和恢复，避免出现错误。
- **踩坑教训**：在判断矩形是否相交时，需要仔细考虑所有可能的重叠情况，确保判断的准确性。
- **顿悟感想**：通过DFS枚举所有可能的矩形组合，可以有效地解决小规模数据的问题，但对于大规模数据需要进一步优化。

---
处理用时：32.61秒
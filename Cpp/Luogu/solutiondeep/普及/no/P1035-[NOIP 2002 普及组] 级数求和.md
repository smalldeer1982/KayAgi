# 题目信息

# [NOIP 2002 普及组] 级数求和

## 题目描述

已知：$S_n= 1+\dfrac{1}{2}+\dfrac{1}{3}+…+\dfrac{1}{n}$。显然对于任意一个整数 $k$，当 $n$ 足够大的时候，$S_n>k$。

现给出一个整数 $k$，要求计算出一个最小的 $n$，使得 $S_n>k$。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le k \le 15$。

**【题目来源】**

NOIP 2002 普及组第一题

## 样例 #1

### 输入

```
1
```

### 输出

```
2
```

# AI分析结果

### 算法分类
**模拟**

### 综合分析与结论
本题的核心是通过模拟累加调和级数，直到其和超过给定的整数 \( k \)。所有题解均采用了类似的思路，即通过循环逐项累加调和级数，直到满足条件。不同题解的主要区别在于代码的实现细节和优化程度。

### 所选高星题解

#### 题解1：Vel_ (赞：21)
**星级：4星**
**关键亮点：**
1. 使用了 `excess` 函数来封装判断条件，提高了代码的可读性。
2. 提供了两种解法：暴力解法和数论优化解法，展示了不同复杂度的解决方案。
3. 数论优化解法通过数学公式直接计算 \( n \)，极大减少了计算量。

**核心代码：**
```cpp
bool excess(double sn,double k){ //溢出灯
    return sn > k;
}

int main(){
    int i=1;
    double sn=0,k;
    cin>>k;
    while(1){ //累加器
        sn += (double)1/(double)(i++);
        if(excess(sn,k)) {cout<<i-1;break;}
    }
    return 0;
}
```

#### 题解2：ryf2011 (赞：1)
**星级：4星**
**关键亮点：**
1. 代码简洁明了，直接通过 `while` 循环进行累加，直到满足条件。
2. 使用了浮点数类型来确保计算的准确性。

**核心代码：**
```cpp
int k,nown;
double s;
int main(){
    scanf("%d",&k); //输入
    while(s<=k){ //注意题目要求 s>k
        nown++; //根据题意可知
        s+=1.0/nown; //根据题意可知，细节：为了保证结果准确性，将 nown 强制转换为浮点型计算
    }
    printf("%d\n",nown); //输出
    return 0;
}
```

#### 题解3：Chbin (赞：0)
**星级：4星**
**关键亮点：**
1. 代码结构清晰，使用了 `for` 循环和 `break` 语句来终止循环。
2. 强调了找到结果后要及时 `break`，避免不必要的计算。

**核心代码：**
```cpp
int k,i=1;
double s=0;
int main(){
    cin>>k;
    for(;;i++)
    {
        s+=1.0/i;
        if(s>k) break; 
    }
    cout<<i;
    return 0;
}
```

### 最优关键思路或技巧
1. **封装判断条件**：通过函数封装判断条件，提高代码的可读性和复用性。
2. **数学优化**：利用数学公式直接计算结果，减少计算量。
3. **及时终止循环**：在满足条件后及时终止循环，避免不必要的计算。

### 可拓展之处
1. **调和级数的性质**：可以进一步研究调和级数的性质及其在数学中的应用。
2. **数学优化**：在其他需要累加计算的题目中，可以考虑是否可以通过数学公式进行优化。

### 推荐题目
1. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
3. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)

---
处理用时：23.08秒
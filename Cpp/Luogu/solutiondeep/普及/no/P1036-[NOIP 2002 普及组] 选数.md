# 题目信息

# [NOIP 2002 普及组] 选数

## 题目描述

已知 $n$ 个整数 $x_1,x_2,\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：

$3+7+12=22$

$3+7+19=29$

$7+12+19=38$

$3+12+19=34$

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：$3+7+19=29$。

## 说明/提示

**【题目来源】**

NOIP 2002 普及组第二题

## 样例 #1

### 输入

```
4 3
3 7 12 19
```

### 输出

```
1
```

# AI分析结果

### 算法分类
深度优先搜索 DFS、组合、质数

### 综合分析与结论
该题目要求从给定的整数中选择k个数，计算它们的和，并判断该和是否为素数。由于需要枚举所有可能的组合，因此适合使用深度优先搜索（DFS）来生成所有可能的组合，并结合质数判断来统计符合条件的组合数。

### 通用建议与扩展思路
1. **DFS与回溯**：使用DFS生成所有可能的组合，并通过回溯来避免重复计算。
2. **质数判断**：可以使用试除法或更高效的质数判断方法（如Miller-Rabin算法）来判断和是否为素数。
3. **剪枝优化**：在DFS过程中，可以通过剪枝来减少不必要的计算，例如当当前和已经大于某个阈值时，可以提前终止该分支的搜索。

### 推荐题目
1. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
2. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)

### 核心代码实现
```cpp
#include <iostream>
#include <vector>
using namespace std;

bool isPrime(int num) {
    if (num < 2) return false;
    for (int i = 2; i * i <= num; ++i) {
        if (num % i == 0) return false;
    }
    return true;
}

void dfs(int start, int k, int sum, const vector<int>& nums, int& count) {
    if (k == 0) {
        if (isPrime(sum)) count++;
        return;
    }
    for (int i = start; i < nums.size(); ++i) {
        dfs(i + 1, k - 1, sum + nums[i], nums, count);
    }
}

int main() {
    int n, k;
    cin >> n >> k;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        cin >> nums[i];
    }
    int count = 0;
    dfs(0, k, 0, nums, count);
    cout << count << endl;
    return 0;
}
```

### 代码核心思想
1. **isPrime函数**：用于判断一个数是否为素数。
2. **dfs函数**：递归地生成所有可能的组合，并在组合完成时判断和是否为素数，如果是则增加计数。
3. **主函数**：读取输入数据，调用dfs函数进行搜索，并输出结果。

### 关键实现
- **DFS与回溯**：通过递归调用dfs函数，生成所有可能的组合，并通过回溯来避免重复计算。
- **质数判断**：使用试除法判断和是否为素数，确保统计的准确性。

### 扩展思路
- **优化质数判断**：可以使用更高效的质数判断算法，如Miller-Rabin算法，进一步提高效率。
- **剪枝优化**：在DFS过程中，可以通过剪枝来减少不必要的计算，例如当当前和已经大于某个阈值时，可以提前终止该分支的搜索。

---
处理用时：19.40秒
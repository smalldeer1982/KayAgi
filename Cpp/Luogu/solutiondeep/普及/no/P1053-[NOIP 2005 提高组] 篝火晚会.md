# 题目信息

# [NOIP 2005 提高组] 篝火晚会

## 题目描述

佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有 $n$ 个同学，编号从 $1$ 到 $n$。一开始，同学们按照 $1,2,\cdots ,n$ 的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。


佳佳可向同学们下达命令，每一个命令的形式如下：

$$(b_1, b_2,... b_{m-1}, b_m)$$

这里 $m$ 的值是由佳佳决定的，每次命令 $m$ 的值都可以不同。这个命令的作用是移动编号是 $b_1,b_2,\cdots, b_m$ 的这 $m$ 个同学的位置。要求 $b_1$ 换到 $b_2$ 的位置上，$b_2$ 换到 $b_3$ 的位置上，……，要求 $b_m$ 换到 $b_1$ 的位置上。执行每个命令都需要一些代价。我们假定如果一个命令要移动 $m$ 个人的位置，那么这个命令的代价就是 $m$。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗？


## 说明/提示

- 对于 $30\%$ 的数据，满足 $n \le 1000$；
- 对于 $100\%$ 的数据，满足 $3\le n  \le  50000$。

**【题目来源】**

NOIP 2005 提高组第三题

## 样例 #1

### 输入

```
4
3 4
4 3
1 2
1 2
```

### 输出

```
2```

# AI分析结果

### 算法分类
**构造**

### 综合分析与结论
该题的核心逻辑是通过构造目标链与初始链的差值，统计出现次数最多的差值，从而确定最小代价。题解中普遍采用了以下思路：
1. **构造目标链**：根据每个同学的期望相邻关系，构建目标链。
2. **差值统计**：计算目标链与初始链的差值，统计每个差值出现的次数。
3. **最小代价计算**：通过最大差值出现次数，计算需要调整的人数，即最小代价。

### 所选题解
#### 1. 作者：Actinoi (赞：35)
- **星级**：★★★★★
- **关键亮点**：
  - 详细解释了如何通过差值统计来优化算法，避免了O(N^2)的复杂度。
  - 提供了清晰的图示和代码实现，易于理解。
  - 处理了环的旋转问题，通过正反两次统计确保准确性。
- **个人心得**：
  - 通过差值统计优化算法，避免了直接枚举所有旋转情况的低效方法。

```cpp
for(int i = 1; i <= n; i++){
    pluss[(target[i] - initial[i] + n) % n]++; // 顺时针统计
    minuss[(target[i]- initial[n - initial[i] + 1] + n) % n]++; // 逆时针统计
}
for (int i = 0; i <= n - 1; i++)
    ans = max(ans, max(pluss[i], minuss[i])); // 找差值人数最多的
cout << n - ans; // 总人数 - 不用移动的人数 = 需要移动的人数
```

#### 2. 作者：Drinkkk (赞：8)
- **星级**：★★★★
- **关键亮点**：
  - 详细解释了如何构建目标链，并处理了无法构建目标链的情况。
  - 通过统计dis1和dis2数组，简化了差值统计的过程。
  - 代码结构清晰，易于理解。

```cpp
for(int i=1;i<=n;i++){
    dis1[(i-a[i]+n)%n]++;
    dis2[(a[i]+i+n)%n]++;
}
int ans=0;
for(int i=0;i<=n*2;i++){
    ans=max(ans,max(dis1[i],dis2[i]));
}
printf("%d",n-ans);
```

#### 3. 作者：LXcjh4998 (赞：1)
- **星级**：★★★★
- **关键亮点**：
  - 详细解释了如何通过差值统计来优化算法，并处理了环的旋转问题。
  - 提供了清晰的代码实现，易于理解。
  - 处理了无法构建目标链的情况。

```cpp
for(int i=1;i<=n;++i)
    ++plus_order[(target_list[i]-initial_list[i]+n)%n],      // 顺时针统计
    ++minus_order[(target_list[i]-initial_list[n-i+1]+n)%n]; // 逆时针统计
for(int i=0;i<n;++i)
    ans=max(ans,max(plus_order[i],minus_order[i])); // 统计答案
printf("%d",n-ans); // 输出
```

### 最优关键思路或技巧
1. **差值统计**：通过统计目标链与初始链的差值，确定需要调整的人数，避免了直接枚举所有旋转情况的低效方法。
2. **正反两次统计**：处理环的旋转问题，确保统计的准确性。
3. **构造目标链**：根据每个同学的期望相邻关系，构建目标链，确保算法的正确性。

### 可拓展之处
该题的思路可以拓展到其他需要处理环状结构的问题，如环形数组的旋转、环形队列的优化等。类似的算法套路可以应用于需要统计差值或处理旋转问题的场景。

### 推荐题目
1. [P1053 篝火晚会](https://www.luogu.com.cn/problem/P1053)
2. [P1054 等价表达式](https://www.luogu.com.cn/problem/P1054)
3. [P1055 校门外的树](https://www.luogu.com.cn/problem/P1055)

---
处理用时：27.12秒
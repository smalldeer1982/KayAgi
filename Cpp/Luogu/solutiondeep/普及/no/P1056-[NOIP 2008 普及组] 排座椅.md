# 题目信息

# [NOIP 2008 普及组] 排座椅

## 题目描述

上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 $D$ 对同学上课时会交头接耳。

同学们在教室中坐成了 $M$ 行 $N$ 列，坐在第 $i$ 行第 $j$ 列的同学的位置是 $(i,j)$，为了方便同学们进出，在教室中设置了 $K$ 条横向的通道，$L$ 条纵向的通道。

于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 $2$ 个会交头接耳的同学，那么他们就不会交头接耳了。

请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。


## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/0z0p5x1i.png)

上图中用符号\*、※、+标出了 $3$ 对会交头接耳的学生的位置，图中 $3$ 条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。

2008 年普及组第二题


## 样例 #1

### 输入

```
4 5 1 2 3
4 2 4 3
2 3 3 3
2 5 2 4
```

### 输出

```
2
2 4
```

# AI分析结果

### 算法分类
贪心、排序

### 综合分析与结论
该题的核心逻辑是通过贪心策略选择能隔开最多交头接耳学生的通道位置，并通过排序确定最优的通道划分方案。所有题解均采用了贪心+排序的思路，主要区别在于代码实现和细节处理上。以下是对各题解的简要分析：

1. **chrispang**：使用了结构体记录每条通道的位置和能隔开的学生对数，通过两次排序（先按隔开人数降序，再按位置升序）确定最优通道。代码清晰，逻辑严谨，适合初学者理解。
2. **Feuer**：采用了类似桶排序的思路，通过统计每条通道能隔开的学生对数，并使用临界值筛选最优通道。代码简洁，但临界值的处理稍显复杂。
3. **ggpw_XNW**：同样使用结构体记录通道信息，通过两次排序确定最优通道。代码简洁，但变量命名和注释较少，可读性稍差。
4. **xingshuyan000**：通过遍历统计每条通道能隔开的学生对数，并使用贪心策略选择最优通道。代码逻辑清晰，但实现稍显冗长。
5. **qhr2023**：使用pair结构记录通道信息，通过排序确定最优通道。代码简洁，但注释较少，适合有一定基础的读者。
6. **HenryHuang**：使用结构体记录通道信息，通过两次排序确定最优通道。代码逻辑清晰，但变量命名和注释较少。
7. **RedContritio**：使用结构体记录通道信息，通过冒泡排序确定最优通道。代码逻辑清晰，但冒泡排序效率较低。
8. **Ryan114**：使用结构体记录通道信息，通过两次排序确定最优通道。代码逻辑清晰，适合初学者理解。
9. **GSQ0829**：使用结构体记录通道信息，通过两次排序确定最优通道。代码简洁，但注释较少。
10. **fyn1234**：使用结构体记录通道信息，通过两次排序确定最优通道。代码简洁，但注释较少。
11. **Eason_lyx**：使用结构体记录通道信息，通过两次排序确定最优通道。代码逻辑清晰，适合初学者理解。
12. **Wish_kazdel**：使用结构体记录通道信息，通过两次排序确定最优通道。代码逻辑清晰，但注释较少。
13. **Jerry_zpl**：使用结构体记录通道信息，通过两次排序确定最优通道。代码逻辑清晰，适合初学者理解。

### 最优关键思路或技巧
1. **贪心策略**：选择能隔开最多交头接耳学生的通道位置。
2. **排序**：先按隔开人数降序排序，再按位置升序排序，确保选择最优通道。

### 可拓展之处
1. **类似问题**：如资源分配、任务调度等，均可采用贪心策略。
2. **优化排序**：可使用更高效的排序算法（如快速排序）提高效率。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

### 个人心得摘录
- **RedContritio**：连续五次10分，总算找到了错误原因。快排是不稳定的，很容易造成ID的混乱。
- **Eason_lyx**：本题不算难，但需要仔细处理排序和输出顺序。

### 所选高星题解
1. **chrispang**（5星）
   - 关键亮点：代码清晰，逻辑严谨，适合初学者理解。
   - 核心代码：
     ```cpp
     struct node{
         int x, n; //x表示分开的行或列，n表示分开的人数 
     }x[1010], y[1010];
     bool cmp1(node a, node b) { //按人数排
         return a.n > b.n;
     }
     bool cmp2(node a, node b) { //按坐标排
         return a.x < b.x;
     }
     sort(x + 1, x + 1 + 1000, cmp1); //分开人数多的放前面
     sort(y + 1, y + 1 + 1000, cmp1);
     sort(x + 1, x + 1 + k, cmp2); //整理答案 
     sort(y + 1, y + 1 + l, cmp2);
     ```

2. **Ryan114**（4星）
   - 关键亮点：代码逻辑清晰，适合初学者理解。
   - 核心代码：
     ```cpp
     struct Line{
         int id,cut; //位置和分开对数
     } hd[1005],ld[1005]; //横过道和纵过道
     bool cmp1(Line a,Line b){
         return a.cut>b.cut;
     }
     bool cmp2(Line a,Line b){
         return a.id<b.id;
     }
     sort(hd+1,hd+1+m,cmp1); //先按分开对数排
     sort(ld+1,ld+1+n,cmp1);
     sort(hd+1,hd+1+k,cmp2); //再按位置排
     sort(ld+1,ld+1+l,cmp2);
     ```

3. **Eason_lyx**（4星）
   - 关键亮点：代码逻辑清晰，适合初学者理解。
   - 核心代码：
     ```cpp
     struct M{
         int id,cnt;    
     }h[1005],z[1005];
     bool cmp1(M a,M b){
         return a.cnt>b.cnt;
     }
     bool cmp2(M a,M b){
         return a.id<b.id;
     }
     sort(h+1,h+n+1,cmp1); //找到分隔哪一列最佳
     sort(z+1,z+m+1,cmp1); //从小到大排列，为输出准备
     sort(h+1,h+l+1,cmp2); //同上
     sort(z+1,z+k+1,cmp2);
     ```

---
处理用时：40.61秒
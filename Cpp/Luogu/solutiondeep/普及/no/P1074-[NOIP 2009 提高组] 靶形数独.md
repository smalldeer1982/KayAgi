# 题目信息

# [NOIP 2009 提高组] 靶形数独

## 题目背景

**此为远古题，不保证存在可以通过任意符合要求的输入数据的程序**。

## 题目描述

小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。

靶形数独的方格同普通数独一样，在 $9$ 格宽且 $9$ 格高的大九宫格中有 $9$ 个 $3$ 格宽且 $3$ 格高的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入 $1$ 到 $9$ 的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。（如图）

![](https://cdn.luogu.com.cn/upload/image_hosting/dhvuc32i.png)

上图具体的分值分布是：最里面一格（黄色区域）为 $10$ 分，黄色区域外面的一圈（红色区域）每个格子为 $9$ 分，再外面一圈（蓝色区域）每个格子为 $8$ 分，蓝色区域外面一圈（棕色区域）每个格子为 $7$ 分，最外面一圈（白色区域）每个格子为 $6$ 分，如上图所示。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和

总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 $2829$。游戏规定，将以总分数的高低决出胜负。

![](https://cdn.luogu.com.cn/upload/image_hosting/yx82mmnc.png)

由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。


## 说明/提示

#### 数据规模与约定

- 对于 $40\%$ 的数据，数独中非 $0$ 数的个数不少于 $30$；
- 对于 $80\%$ 的数据，数独中非 $0$ 数的个数不少于 $26$；
- 对于 $100\%$ 的数据，数独中非 $0$ 数的个数不少于 $24$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
7 0 0 9 0 0 0 0 1 
1 0 0 0 0 5 9 0 0 
0 0 0 2 0 0 0 8 0 
0 0 5 0 2 0 0 0 3 
0 0 0 0 0 0 6 4 8 
4 1 3 0 0 0 0 0 0 
0 0 7 0 0 2 0 9 0 
2 0 1 0 6 0 8 0 4 
0 8 0 5 0 4 0 1 2
```

### 输出

```
2829```

## 样例 #2

### 输入

```
0 0 0 7 0 2 4 5 3 
9 0 0 0 0 8 0 0 0 
7 4 0 0 0 5 0 1 0 
1 9 5 0 8 0 0 0 0 
0 7 0 0 0 0 0 2 5 
0 3 0 5 7 9 1 0 8 
0 0 0 6 0 1 0 0 0 
0 6 0 9 0 0 0 0 1 
0 0 0 0 0 0 0 0 6```

### 输出

```
2852```

# AI分析结果

### 算法分类
深度优先搜索 DFS

### 综合分析与结论
该题目要求完成一个数独，并在满足数独规则的基础上最大化得分。由于数独的规模较小（9x9），因此可以采用深度优先搜索（DFS）来解决。为了优化搜索效率，通常会结合剪枝策略，例如优先选择约束条件较多的格子进行填充，以减少搜索树的分支。

### 所选题解
#### 1. 作者：学无止境
- **星级**: 4
- **关键亮点**: 通过预处理每个格子的分值，并优先选择约束条件较多的格子进行填充，有效减少了搜索树的分支。代码结构清晰，注释详细，便于理解。
- **个人心得**: 作者提到DFS的效率不高，但通过优化搜索顺序（优先选择0少的行）成功AC，体现了剪枝的重要性。

```cpp
void dfs(int p,int score) {
    if(p==u) {
        if(score>most) most=score;
        return;
    }
    for(int i=1;i<=9;i++) {
        if(!hang[s[p][0]][i]&&!lie[s[p][1]][i]&&!gong[s[p][3]][i]) {
            hang[s[p][0]][i]=lie[s[p][1]][i]=gong[s[p][3]][i]=1;
            dfs(p+1,score+(s[p][2]*i));
            hang[s[p][0]][i]=lie[s[p][1]][i]=gong[s[p][3]][i]=0;
        }
    }
}
```

#### 2. 作者：liumuxin
- **星级**: 4
- **关键亮点**: 通过预处理每个格子的约束个数，并优先选择约束最多的格子进行填充，进一步优化了搜索效率。代码逻辑清晰，注释详细。
- **个人心得**: 作者提到通过预处理搜索顺序，使得搜索树的分支大大减少，体现了优化搜索顺序的重要性。

```cpp
void dfs(int x,int y,int now) {
    if(now==cnt+1) calc();
    int b=belong(x,y);
    for(int i=1;i<=9;i++) {
        if(!col[x][i]&&!row[y][i]&&!block[b][i]) {
            col[x][i]=row[y][i]=block[b][i]=1;
            ans[x][y]=i;
            dfs(s[now+1].first,s[now+1].second,now+1);
            col[x][i]=row[y][i]=block[b][i]=ans[x][y]=0;
        }
    }
}
```

#### 3. 作者：CommandSR
- **星级**: 4
- **关键亮点**: 通过预处理每个格子的分值和所在宫，并优先选择0少的行进行填充，有效减少了搜索树的分支。代码结构清晰，注释详细。
- **个人心得**: 作者提到通过预处理搜索顺序，使得搜索树的分支大大减少，体现了优化搜索顺序的重要性。

```cpp
void dfs(int x, int y, int goal) {
    if (y > 9) y = 1, x++;
    if (x == 10 && y == 1) {
        ans = max(ans, goal);
        return;
    }
    if (a[id[x]][y]) dfs(x, y + 1, goal);
    else {
        for (int i = 1; i <= 9; i++) {
            if (!vis_x[id[x]][i] && !vis_y[y][i] && !vis_area[area[id[x]][y]][i]) {
                vis_x[id[x]][i] = vis_y[y][i] = vis_area[area[id[x]][y]][i] = 1;
                dfs(x, y + 1, goal + i * scr[id[x]][y]);
                vis_x[id[x]][i] = vis_y[y][i] = vis_area[area[id[x]][y]][i] = 0;
            }
        }
    }
}
```

### 最优关键思路或技巧
1. **预处理搜索顺序**: 优先选择约束条件较多的格子进行填充，减少搜索树的分支。
2. **剪枝策略**: 在搜索过程中，通过判断当前状态是否合法，避免无效搜索。
3. **回溯法**: 使用回溯法进行深度优先搜索，确保所有可能的解都被探索到。

### 可拓展之处
该题目的解法可以拓展到其他类似的搜索问题，如八皇后问题、迷宫问题等。通过优化搜索顺序和剪枝策略，可以有效提高搜索效率。

### 推荐题目
1. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)

---
处理用时：38.96秒
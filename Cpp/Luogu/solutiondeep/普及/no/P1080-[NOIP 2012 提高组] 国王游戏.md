# 题目信息

# [NOIP 2012 提高组] 国王游戏

## 题目描述

恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。


## 说明/提示

【输入输出样例说明】

按 $1$、$2$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $1$、$3$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $2$、$1$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按$ 2$、$3$、$1 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$；

按 $3$、$1$、$2 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；  

按$ 3$、$2$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$。

因此，奖赏最多的大臣最少获得 $2$ 个金币，答案输出 $2$。


 
【数据范围】

对于 $20\%$ 的数据，有 $1≤ n≤ 10,0 < a,b < 8$；

对于 $40\%$ 的数据，有$ 1≤ n≤20,0 < a,b < 8$；

对于 $60\%$ 的数据，有 $1≤ n≤100$；

对于 $60\%$ 的数据，保证答案不超过 $10^9$；

对于 $100\%$ 的数据，有 $1 ≤ n ≤1,000,0 < a,b < 10000$。



NOIP 2012 提高组 第一天 第二题


## 样例 #1

### 输入

```
3 
1 1 
2 3 
7 4 
4 6 ```

### 输出

```
2```

# AI分析结果

### 算法分类
贪心、高精度

### 综合分析与结论
该题目要求通过重新排列大臣的顺序，使得获得奖赏最多的大臣所获奖赏尽可能少。核心思路是通过贪心算法确定大臣的排列顺序，具体来说，按照大臣左右手数字的乘积从小到大排序。由于数据范围较大，需要使用高精度计算来处理乘积和除法运算。

### 所选高星题解
1. **作者：洛必达法则 (赞：165)**
   - **星级：5星**
   - **关键亮点**：详细证明了贪心策略的正确性，通过邻项交换法推导出按 $a_i \times b_i$ 排序的合理性，逻辑严谨，证明清晰。
   - **核心代码**：
     ```cpp
     bool cmp(node aa,node bb) {
         return (aa.x*aa.y) < (bb.x*bb.y);
     }
     ```
   - **个人心得**：通过邻项交换法证明了贪心策略的正确性，逻辑清晰，代码简洁。

2. **作者：frankchenfu (赞：9)**
   - **星级：4星**
   - **关键亮点**：提供了高精度计算的封装实现，代码结构清晰，易于理解，适合高精度计算的初学者。
   - **核心代码**：
     ```cpp
     bign operator/(const int rhs) {
         bign c;c=*this;
         while(c.len&&c.a[c.len]==0) c.len--;
         for(int i=c.len;i;i--) {
             c.a[i-1]+=(c.a[i]%rhs)*BASE;
             c.a[i]/=rhs;
         }
         while(c.len&&c.a[c.len]==0) c.len--;
         return c;
     }
     ```
   - **个人心得**：高精度计算部分封装良好，适合初学者学习和使用。

3. **作者：VitrelosTia (赞：4)**
   - **星级：4星**
   - **关键亮点**：提供了Python实现，避免了C++高精度计算的复杂性，代码简洁易懂。
   - **核心代码**：
     ```python
     o[1:] = sorted(o[1:], key=lambda x: x[0] * x[1])
     ans = 0
     pre = o[0][0]
     for i in range(1, n + 1):
         ans = max(ans, pre // o[i][1])
         pre *= o[i][0]
     ```
   - **个人心得**：通过Python实现，避免了高精度计算的复杂性，适合快速解题。

### 最优关键思路或技巧
1. **贪心策略**：通过邻项交换法证明，按 $a_i \times b_i$ 从小到大排序是最优策略。
2. **高精度计算**：由于数据范围较大，需要使用高精度计算来处理乘积和除法运算。
3. **Python实现**：使用Python可以避免高精度计算的复杂性，适合快速解题。

### 可拓展之处
1. **类似题目**：可以拓展到其他需要贪心策略和高精度计算的题目，如背包问题、最大子序列和等。
2. **算法优化**：可以进一步优化高精度计算的实现，如使用更高效的数据结构或算法。

### 推荐相似题目
1. **P1081 最大乘积**：考察贪心策略和高精度计算。
2. **P1082 最大公约数**：涉及高精度计算和数学知识。
3. **P1083 最小生成树**：考察贪心算法和图论知识。

---
处理用时：23.09秒
# 题目信息

# [NOIP 2004 普及组] 火星人

## 题目描述

人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。

火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。

一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：


| 三进制数 | 代表的数字 |
|:-:|:-:|
| $123$ | $1$ |
| $132$ | $2$ |
| $213$ | $3$ |
| $231$ | $4$ |
| $312$ | $5$ |
| $321$ | $6$ |

现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。


## 说明/提示

对于 $30\%$ 的数据，$N \le 15$。

对于 $60\%$ 的数据，$N \le 50$。

对于 $100\%$ 的数据，$N \le 10000$。

noip2004 普及组第 4 题


## 样例 #1

### 输入

```
5
3
1 2 3 4 5
```

### 输出

```
1 2 4 5 3```

# AI分析结果

### 算法分类
**排序**

### 综合分析与结论
该题的核心问题是如何根据给定的排列和加数，找到下一个排列。这本质上是一个排列生成问题，通常可以通过全排列算法或直接使用STL中的`next_permutation`函数来解决。题解中主要分为以下几种思路：
1. **使用`next_permutation`函数**：直接调用STL函数，简洁高效，但缺乏对算法的深入理解。
2. **手动实现`next_permutation`**：通过模拟全排列的过程，理解排列生成的原理，适合学习算法细节。
3. **变进制数转换**：将排列转换为变进制数，进行加法操作后再转换回排列，思路新颖但实现复杂。

### 所选高星题解
#### 1. 作者：yummy (赞：514)
**星级：5星**
**关键亮点**：通过变进制数的转换，将排列问题转化为数学问题，思路新颖且高效。代码简洁，逻辑清晰。
**个人心得**：通过变进制数的思路，避免了直接处理排列的复杂性，提升了算法的效率。
**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10005];
bool used[10005]={0};
int m,n;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        int x=a[i];
        for(int j=1;j<=a[i];j++)
            x-=used[j];
        used[a[i]]=1;
        a[i]=x-1;
    }
    a[n]+=m;
    for(int i=n;i>0;i--)
    {
        a[i-1]+=a[i]/(n-i+1);
        a[i]%=n-i+1;
    }
    memset(used,0,sizeof(used));
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=a[i];j++)
            if(used[j])
                a[i]++;
        cout<<a[i]+1<<" ";
        used[a[i]]=1;
    }
    return 0;
}
```

#### 2. 作者：zhi_zhang (赞：93)
**星级：4星**
**关键亮点**：通过模拟人脑的思维过程，逐步找到下一个排列，思路直观易懂，适合初学者理解。
**核心代码**：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
const int MAXN=10010;
int finger[MAXN];
int N,M;
int vis[MAXN];
int ad(int);
void prin();
int main()
{
    scanf("%d%d",&N,&M);
    for(int i=1;i<=N;i++)
    {
        vis[i]=1;
        scanf("%d",&finger[i]);
    }
    while(M--)
    {
        for(int i=N;i>=1;i--)
        {
            int k=ad(finger[i]);
            if(k!=-1)
            {
                vis[finger[i]]=0;
                finger[i]=k;
                vis[k]=1;
                for(int j=i+1;j<=N;j++)
                {
                    for(int p=1;p<=N;p++)
                    {
                        if(!vis[p])
                        {
                            finger[j]=p;
                            vis[p]=1;
                            break;
                        }
                    }
                }
                break;
            }
            else
            {
                vis[finger[i]]=0;
            }
        }
    }
    prin();
    return 0;
}
int ad(int poi)
{
    for(int i=poi+1;i<=N;i++)
    {
        if(!vis[i])
        {
            return i;
        }
    }
    return -1;
}
void prin()
{
    for(int i=1;i<=N;i++)
    {
        printf("%d ",finger[i]);
    }
    printf("\n");
}
```

#### 3. 作者：Believe_R_ (赞：67)
**星级：4星**
**关键亮点**：通过STL的`next_permutation`函数，简洁高效地解决问题，适合快速实现。
**核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100000];
int n,m;
inline int read()
{
    int re=0, f=1; char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0' && ch<='9') {re=re*10+(ch-'0'); ch=getchar();}
    return re*f;
}
int main()
{
    n=read(); m=read();
    for(int i=1;i<=n;++i) a[i]=read();
    for(int i=1;i<=m;++i) next_permutation(a+1,a+n+1);
    for(int i=1;i<=n;++i) printf("%d ",a[i]);
    return 0;
}
```

### 最优关键思路或技巧
- **变进制数转换**：将排列问题转化为数学问题，提升算法效率。
- **模拟人脑思维**：通过逐步模拟找到下一个排列，适合初学者理解。
- **STL函数使用**：直接调用`next_permutation`函数，简洁高效。

### 可拓展之处
- **全排列生成**：可以进一步学习全排列的生成算法，如递归法、字典序法等。
- **组合数学**：了解排列与组合的区别，学习组合数学的相关知识。

### 推荐题目
1. [P1706 全排列问题](https://www.luogu.org/problem/P1706)
2. [P1088 火星人](https://www.luogu.org/problem/P1088)
3. [P1157 组合的输出](https://www.luogu.org/problem/P1157)

---
处理用时：42.05秒
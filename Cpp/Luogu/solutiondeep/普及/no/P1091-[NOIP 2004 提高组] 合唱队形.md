# 题目信息

# [NOIP 2004 提高组] 合唱队形

## 题目描述

$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。

合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1< \cdots <t_i>t_{i+1}>$ … $>t_k(1\le i\le k)$。

你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

## 说明/提示

对于 $50\%$ 的数据，保证有 $n \le 20$。

对于全部的数据，保证有 $n \le 100$。


## 样例 #1

### 输入

```
8
186 186 150 200 160 130 197 220
```

### 输出

```
4
```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
本题的核心是求一个序列的最长先上升后下降的子序列，可以通过动态规划（DP）来解决。大多数题解采用了类似的思路：分别计算从左到右的最长上升子序列（LIS）和从右到左的最长下降子序列（LDS），然后枚举每个位置作为中间点，计算其对应的合唱队形长度，最终求出需要出列的最少人数。

### 所选高星题解

#### 1. VitrelosTia (5星)
- **关键亮点**：使用了二分查找优化LIS和LDS的求解，将时间复杂度从O(n^2)优化到O(n log n)，思路清晰且代码实现简洁。
- **个人心得**：作者详细解释了二分查找在LIS中的应用，并通过图示帮助理解，展示了如何通过维护一个数组来记录每个长度的最小结尾值。
- **核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    int pos = lower_bound(g + 1, g + len + 1, a[i]) - g;
    f1[i] = pos;
    g[pos] = a[i];
    len = max(len, pos);
}
```
- **实现思想**：通过二分查找找到当前元素在LIS中的位置，并更新对应长度的最小结尾值。

#### 2. superLouis (4星)
- **关键亮点**：提供了中英文双语题解，详细解释了DP的转移方程，并给出了O(n^2)和O(n log n)两种实现方式，适合不同层次的读者。
- **核心代码**：
```cpp
for (int i = 1; i <= n; i++) 
    for (int j = 1; j < i; j++) 
        if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1);
```
- **实现思想**：通过双重循环计算每个位置的LIS，并记录最大值。

#### 3. shinzanmono (4星)
- **关键亮点**：简洁明了地解释了DP的转移方程，并提供了O(n^2)的实现，代码可读性强。
- **核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j < i; j++) {
        if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1);
    }
}
```
- **实现思想**：通过双重循环计算每个位置的LIS，并记录最大值。

### 最优关键思路或技巧
- **二分查找优化LIS**：通过维护一个数组记录每个长度的最小结尾值，使用二分查找快速定位当前元素的位置，将时间复杂度从O(n^2)优化到O(n log n)。
- **双向DP**：分别计算从左到右的LIS和从右到左的LDS，最终枚举每个位置作为中间点，计算合唱队形的长度。

### 可拓展之处
- **类似题目**：可以扩展到其他需要求最长上升或下降子序列的问题，如最长递增子序列（LIS）、最长递减子序列（LDS）等。
- **优化思路**：在其他DP问题中，也可以考虑使用二分查找或其他数据结构（如线段树）来优化时间复杂度。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P2758 编辑距离](https://www.luogu.com.cn/problem/P2758)
3. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)

---
处理用时：23.37秒
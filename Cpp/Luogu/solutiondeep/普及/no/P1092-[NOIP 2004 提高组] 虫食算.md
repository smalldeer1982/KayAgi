# 题目信息

# [NOIP 2004 提高组] 虫食算

## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：

$$\begin{aligned}
 \verb!43#9865#045! \\
+\qquad \verb!8468#6633! \\[-1em]\underline{\kern{8em}} \\
 \verb!44445509678! \\
\end{aligned}$$

其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。

$$\begin{aligned}
 \verb!BADC! \\
+\quad \verb!CBDA! \\[-1em]\underline{\kern{4em}} \\
 \verb!DCCC! \\
\end{aligned}$$

上面的算式是一个4进制的算式。很显然，我们只要让 $\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 10$；
- 对于 $50\%$ 的数据，保证 $n \le 15$；
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 26$。

## 样例 #1

### 输入

```
5
ABCED
BDACE
EBBAA
```

### 输出

```
1 0 3 4 2
```

# AI分析结果

### 算法分类
搜索、剪枝

### 综合分析
该题目要求通过给定的字母算式，找到每个字母对应的数字，使得算式成立。由于涉及字母与数字的映射，且算式为n进制加法，通常采用深度优先搜索（DFS）结合剪枝的策略来解决。题解中主要讨论了如何通过合理的搜索顺序和剪枝策略来优化搜索效率，避免不必要的计算。

### 关键思路与技巧
1. **搜索顺序优化**：从右到左逐位搜索，避免进位带来的复杂性。
2. **剪枝策略**：在搜索过程中，如果发现某一位的字母已经确定，且不满足加法规则，则直接剪枝。此外，通过判断当前列的三个字母是否满足加法规则，进一步减少搜索空间。
3. **预处理与优化**：通过预处理字母的出现顺序，优化搜索路径，减少重复计算。

### 推荐题目
1. [P1032 字串变换](https://www.luogu.com.cn/problem/P1032)
2. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)
3. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)

### 精选题解
1. **作者：zzlzk**
   - **星级**：★★★★★
   - **关键亮点**：详细解释了搜索的剪枝策略，代码结构清晰，优化程度高。
   - **代码片段**：
     ```cpp
     void dfs(int x, int y, int t) {
         if (x == 0) {
             if (t == 0) {
                 for (int i = 1; i < n; i++) printf("%d ", flag[i]);
                 printf("%d\n", flag[n]);
                 exit(0);
             }
             return;
         }
         for (int i = x - 1; i >= 1; i--) {
             int w1 = flag[id(s[1][i])], w2 = flag[id(s[2][i])], w3 = flag[id(s[3][i])];
             if (w1 == -1 || w2 == -1 || w3 == -1) continue;
             if ((w1 + w2) % n != w3 && (w1 + w2 + 1) % n != w3) return;
         }
         if (flag[id(s[y][x])] == -1) {
             for (int i = n - 1; i >= 0; i--) {
                 if (!use[i]) {
                     flag[id(s[y][x])] = i;
                     use[i] = 1;
                     dfs(x, y + 1, t);
                     flag[id(s[y][x])] = -1;
                     use[i] = 0;
                 }
             }
         } else {
             dfs(x, y + 1, t);
         }
     }
     ```

2. **作者：✌yww**
   - **星级**：★★★★
   - **关键亮点**：采用了类似的搜索策略，代码简洁，易于理解。
   - **代码片段**：
     ```cpp
     void dfs(int x, int y, int t) {
         if (x == 0) {
             if (t == 0) {
                 for (int i = 1; i < n; i++) printf("%d ", flag[i]);
                 printf("%d\n", flag[n]);
                 exit(0);
             }
             return;
         }
         for (int i = x - 1; i >= 1; i--) {
             int w1 = flag[id(s[1][i])], w2 = flag[id(s[2][i])], w3 = flag[id(s[3][i])];
             if (w1 == -1 || w2 == -1 || w3 == -1) continue;
             if ((w1 + w2) % n != w3 && (w1 + w2 + 1) % n != w3) return;
         }
         if (flag[id(s[y][x])] == -1) {
             for (int i = n - 1; i >= 0; i--) {
                 if (!use[i]) {
                     flag[id(s[y][x])] = i;
                     use[i] = 1;
                     dfs(x, y + 1, t);
                     flag[id(s[y][x])] = -1;
                     use[i] = 0;
                 }
             }
         } else {
             dfs(x, y + 1, t);
         }
     }
     ```

3. **作者：Kelin**
   - **星级**：★★★★
   - **关键亮点**：通过优化搜索顺序和剪枝策略，代码效率较高。
   - **代码片段**：
     ```cpp
     void dfs(int x, int y, int t) {
         if (x == 0) {
             if (t == 0) {
                 for (int i = 1; i < n; i++) printf("%d ", flag[i]);
                 printf("%d\n", flag[n]);
                 exit(0);
             }
             return;
         }
         for (int i = x - 1; i >= 1; i--) {
             int w1 = flag[id(s[1][i])], w2 = flag[id(s[2][i])], w3 = flag[id(s[3][i])];
             if (w1 == -1 || w2 == -1 || w3 == -1) continue;
             if ((w1 + w2) % n != w3 && (w1 + w2 + 1) % n != w3) return;
         }
         if (flag[id(s[y][x])] == -1) {
             for (int i = n - 1; i >= 0; i--) {
                 if (!use[i]) {
                     flag[id(s[y][x])] = i;
                     use[i] = 1;
                     dfs(x, y + 1, t);
                     flag[id(s[y][x])] = -1;
                     use[i] = 0;
                 }
             }
         } else {
             dfs(x, y + 1, t);
         }
     }
     ```

### 总结
通过合理的搜索顺序和剪枝策略，可以显著提高搜索效率，避免不必要的计算。在实际应用中，可以根据具体问题调整搜索策略，以达到最佳效果。

---
处理用时：55.74秒
# 题目信息

# [NOIP 2007 普及组] 守望者的逃离

## 题目背景

NOIP2007 普及组 T3

## 题目描述

恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。

守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。

为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。

守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。

现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。

注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。


## 说明/提示

对于 $30\%$ 的数据，$1  \le  T   \le  10$，$ 1   \le   S   \le  100$；

对于 $50\%$ 的数据，$1   \le  T   \le   10^3$，$ 1   \le  S  \le   10^4$；

对于 $100\%$ 的数据，$1   \le   T   \le   3\times  10^5$，$0   \le   M   \le   10^3$，$ 1   \le  S   \le   10^8$。


## 样例 #1

### 输入

```
39 200 4
```

### 输出

```
No
197
```

## 样例 #2

### 输入

```
36 255 10```

### 输出

```
Yes
6```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
该题的核心逻辑是通过贪心策略在有限时间内最大化守望者的逃离距离。题解中主要分为两种思路：
1. **贪心+模拟**：通过模拟每一秒的行动，优先使用闪烁法术，若无法使用则选择跑步或恢复魔法值。这种思路通过维护两个变量（跑步距离和闪烁距离）来确保每一步的最优选择。
2. **动态规划**：使用动态规划数组记录每一秒的最大逃离距离，通过状态转移方程更新最优解。这种思路虽然较为复杂，但能够更系统地处理问题。

大部分题解采用了贪心+模拟的思路，因其实现简单且效率较高。动态规划的思路虽然更为严谨，但代码复杂度较高，适合对动态规划有较深理解的用户。

### 所选高星题解
1. **作者：wzr1125 (赞：17)**
   - **星级**：4星
   - **关键亮点**：通过维护两个变量（闪现距离和跑步距离），在每一秒中优先使用闪现，若闪现距离超过跑步距离，则更新跑步距离为闪现距离。这种思路简洁且高效，代码可读性强。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=t;i++){
         if(m>=10) m-=10,fla+=60,run+=17;
         else m+=4,run+=17;
         if(fla>run) run=fla;
         if(max(fla,run)>=s){
             printf("Yes\n%d\n",i);return 0;
         }
     }
     ```

2. **作者：GLr137 (赞：10)**
   - **星级**：4星
   - **关键亮点**：使用动态规划数组记录每一秒的最大逃离距离，通过状态转移方程更新最优解。虽然代码复杂度较高，但思路严谨，适合对动态规划有较深理解的用户。
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= t; i++){
         dp[i] = dp[i - 1] + (60 * (m >= 10));
         z = m;
         m -= (10 * (z >= 10));
         m += (4 * (z < 10));
     }
     for (int i = 1; i <= t; i++){
         dp[i] = max(dp[i], dp[i - 1] + 17);
         if (dp[i] >= s){
             cout << "Yes\n" << i;
             return 0;
         }
     }
     ```

3. **作者：Ryan114 (赞：1)**
   - **星级**：4星
   - **关键亮点**：通过维护两个变量（跑步距离和闪烁距离），在每一秒中优先使用闪烁，若无法使用则选择跑步或恢复魔法值。这种思路简洁且高效，代码可读性强。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=t;i++){
         x1+=17;
         if(m>=10) m-=10,x2+=60;
         else m+=4;
         if(x2>x1) x1=x2;
         if(x1>=s){
             cout<<"Yes"<<endl<<i;
             return 0;
         }
     }
     ```

### 最优关键思路
通过维护两个变量（跑步距离和闪烁距离），在每一秒中优先使用闪烁，若无法使用则选择跑步或恢复魔法值。这种思路简洁且高效，代码可读性强。

### 可拓展之处
类似的问题可以通过贪心策略在有限资源下最大化收益，如背包问题、任务调度问题等。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

---
处理用时：29.88秒
# 题目信息

# 删数问题

## 题目描述

键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。

## 说明/提示

用 $\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \leq k < \operatorname{len}(n) \leq 250$。

## 样例 #1

### 输入

```
175438 
4
```

### 输出

```
13```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
该题目要求从高精度正整数中删除k个数字，使得剩下的数字组成的新数最小。核心思路是通过贪心策略，每次删除当前序列中第一个比下一个数字大的数字，从而保证每次删除后剩下的数字尽可能小。难点在于如何处理前导零和特殊情况（如删除后只剩下0）。大部分题解都采用了类似的贪心策略，但实现方式和优化程度有所不同。

### 所选高星题解

#### 题解1：expin（赞：260）
**星级：5星**
**关键亮点：**
- 思路清晰，通过每次在左边m+1个数字中找到最小的数字作为结果的第一位，逐步构建最小数。
- 代码简洁，直接输出结果，避免存储中间结果。
- 处理前导零和特殊情况（如结果为0）的方式简单有效。

**核心代码：**
```cpp
while(cnt<rest){
    minp=t;
    for(int i=t;i<=k+t;++i)if(a[minp]>a[i])minp=i;
    if(a[minp])flag=1;
    if(flag)cout<<a[minp];
    k-=minp-t;
    t=minp+1;
    cnt++;
}
if(!flag)cout<<0;
```
**个人心得：**
- 通过贪心策略，每次找到最小的数字作为当前位，逐步构建最小数，避免了复杂的存储和计算。

#### 题解2：修罗海神王（赞：196）
**星级：4星**
**关键亮点：**
- 通过删除“下坡数”（即比下一个数字大的数字）来逐步构建最小数。
- 代码实现简单，直接通过删除操作更新字符串。

**核心代码：**
```cpp
for(int i=1;i<=n;i++)
    for(int j=0;j<l;j++)
        if(a[j]>a[j+1]) {
            for(int k=j;k<l;k++) a[k]=a[k+1];
            l--; break;
        }
```
**个人心得：**
- 通过删除“下坡数”来保证每次删除后剩下的数字尽可能小，思路直观且易于实现。

#### 题解3：xh39（赞：143）
**星级：4星**
**关键亮点：**
- 通过寻找“高峰”并删除高峰来逐步构建最小数。
- 使用`erase`函数简化删除操作，代码简洁。

**核心代码：**
```cpp
while(s){
    for(i=0;n[i]<=n[i+1];) i++;
    n.erase(i,1);
    s--;
}
```
**个人心得：**
- 通过寻找“高峰”并删除高峰来保证每次删除后剩下的数字尽可能小，代码实现简单且高效。

### 最优关键思路
1. **贪心策略**：每次删除当前序列中第一个比下一个数字大的数字，保证每次删除后剩下的数字尽可能小。
2. **前导零处理**：在输出结果时，跳过前导零，确保输出格式正确。
3. **特殊情况处理**：如果删除后只剩下0，直接输出0。

### 可拓展之处
- 类似问题可以扩展到删除k个字符后使字符串字典序最小，或删除k个元素后使数组和最小等。
- 可以使用单调栈等数据结构进一步优化删除操作的时间复杂度。

### 推荐题目
1. P1106 删数问题（本题）
2. P1090 合并果子（贪心策略）
3. P1223 排队接水（贪心策略）

---
处理用时：28.04秒
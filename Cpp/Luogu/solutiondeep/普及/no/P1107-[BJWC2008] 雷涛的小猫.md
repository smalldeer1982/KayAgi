# 题目信息

# [BJWC2008] 雷涛的小猫

## 题目背景

原最大整数参见 P1012

## 题目描述

雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫（当然，这样的行为是违反学生宿舍管理条例的）。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。

可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆…

在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有 $N$ 棵。并且这 $N$ 棵柿子树每棵的高度都是 $H$。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。

小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳 $1$ 单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降 `Delta` 单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。

雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。

图为 $N=3, H=10, Delta=2$ 的一个例子。小猫按照图示路线进行跳跃，可以吃到最多的 $8$ 个柿子。

![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \leq N, H ≤ 2000$，$0 \leq N_i ≤ 5000$，$1 ≤ Delta ≤ N,1 ≤ T_{i,j} ≤ H$。

输入文件大小不大于 40MB。注意输入输出效率。

来源 Excalibur, 2008。

## 样例 #1

### 输入

```
3 10 2
3 1 4 10
6 3 5 9 7 8 9
5 4 5 3 6 9```

### 输出

```
8```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
本题的核心是通过动态规划（DP）来解决小猫在不同高度和不同树之间跳跃时能吃到的最多柿子数。各题解主要围绕如何优化DP的状态转移方程展开，尤其是如何减少时间复杂度。大多数题解从O(n^3)优化到O(n^2)，通过引入辅助数组来记录每个高度的最大值，从而避免了对每棵树的重复计算。

### 所选题解
1. **作者：issue_is_fw (赞：126)**
   - **星级：5星**
   - **关键亮点**：通过引入`pre`数组记录每个高度的最大收益，成功将时间复杂度从O(n^3)优化到O(n^2)。代码清晰，思路明确，优化方法简洁有效。
   - **个人心得**：作者提到第一次题解被退回，原因是排版不整齐，强调了代码和思路的清晰表达的重要性。

   ```cpp
   int n,h,de;
   int a[5009][2009], dp[5009][2009], pre[5009];
   int main() {
       cin >> n >> h >> de;
       for(int i=1; i<=n; i++) {
           int t, zz;
           scanf("%d", &t);
           while(t--) {
               scanf("%d", &zz);
               a[i][zz]++;
           }
       }
       int maxn = 0;
       for(int j=h; j>=0; j--) {
           for(int i=1; i<=n; i++) {
               dp[i][j] = a[i][j] + dp[i][j+1];
               dp[i][j] = max(dp[i][j], pre[j+de] + a[i][j]);
               pre[j] = max(pre[j], dp[i][j]);
               maxn = max(maxn, dp[i][j]);
           }
       }
       cout << maxn;
   }
   ```

2. **作者：良辰何需美景 (赞：8)**
   - **星级：4星**
   - **关键亮点**：通过`ret`数组记录每个高度的最大收益，优化了状态转移方程，避免了重复计算。代码简洁，思路清晰。
   - **个人心得**：作者提到在T掉一个点后，通过画图模拟DP过程，强调了调试和可视化在解决问题中的重要性。

   ```cpp
   int n,h,d;
   int f[2018][2018], a[2018][2018], ret[2018];
   int main() {
       cin >> n >> h >> d;
       for(int i=1; i<=n; i++) {
           int num, k;
           cin >> num;
           for(int j=1; j<=num; j++) {
               cin >> k;
               a[i][k]++;
           }
       }
       for(int j=1; j<=h; j++) {
           for(int i=1; i<=n; i++) {
               if(j > d) f[i][j] = max(f[i][j-1], ret[j-d]) + a[i][j];
               else f[i][j] = f[i][j-1] + a[i][j];
               ret[j] = max(ret[j], f[i][j]);
           }
       }
       cout << ret[h];
   }
   ```

3. **作者：不存在之人 (赞：4)**
   - **星级：4星**
   - **关键亮点**：通过`m`数组记录每个高度的最大收益，优化了状态转移方程，避免了重复计算。代码简洁，思路清晰。
   - **个人心得**：作者强调了高度低的位置的值肯定是由高度高的位置更新得来的，强调了DP的递推性质。

   ```cpp
   int a[2020][5010] = {0};
   int dp[2020][5010] = {0};
   int m[2010] = {0};
   int n,h,d;
   void print() {
       for(int i=h; i>=1; i--) {
           for(int j=1; j<=n; j++) {
               dp[j][i] = max(dp[j][i+1], m[i+d]) + a[j][i];
               m[i] = max(dp[j][i], m[i]);
           }
       }
       printf("%d\n", m[1]);
   }
   ```

### 最优关键思路或技巧
- **引入辅助数组**：通过引入`pre`、`ret`或`m`数组记录每个高度的最大收益，避免了重复计算，将时间复杂度从O(n^3)优化到O(n^2)。
- **倒序枚举高度**：从高到低枚举高度，确保在计算当前高度时，更高高度的状态已经计算完毕。

### 可拓展之处
- **类似问题**：类似的问题包括在不同状态之间进行转移的DP问题，如背包问题、最长公共子序列等。
- **优化技巧**：在DP问题中，通过引入辅助数组或变量来记录某些状态的最大值或最小值，是一种常见的优化技巧。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

---
处理用时：33.14秒
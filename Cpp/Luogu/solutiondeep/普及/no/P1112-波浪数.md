# 题目信息

# 波浪数

## 题目描述

波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。

类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $2\le l\le r\le 32$，$1\le L\le R\le 10^7$，$k\in \{2, 3, 4\}$。

## 样例 #1

### 输入

```
10 11 190000 960000 2```

### 输出

```
191919
383838
575757
767676
959595```

# AI分析结果

### 算法分类
**构造**

### 综合分析与结论
本题的核心是通过构造波浪数，并在不同进制下判断其是否为波浪数。题解大多采用了逆向思维，即先构造波浪数，再判断其在不同进制下的波浪性。这种思路避免了直接判断的复杂性，且通过枚举和标记的方式，能够高效地找到符合条件的数。

### 所选题解
1. **作者：Crazily (赞：78)**
   - **星级：4.5**
   - **关键亮点**：逆向思维，先构造波浪数再判断其在不同进制下的波浪性，代码简洁且高效。
   - **个人心得**：考试时未能想到逆向思维，考后才意识到这种方法的优势。
   - **核心代码**：
     ```cpp
     for(int k=a;k<=b;++k){
         for(int i=1;i<k;++i){
             for(int j=0;j<k;++j){
                 if(i!=j){
                     x=0;
                     t=0;
                     while(x<=r){
                         if(t%2==0) x=x*k+i;
                         else x=x*k+j;
                         ++t;
                         if(x>=l&&x<=r) ++v[x];
                     }
                 }
             }
         }
     }
     ```
   - **核心思想**：通过三重循环构造波浪数，并在范围内标记其波浪重数。

2. **作者：Star_Wind (赞：21)**
   - **星级：4**
   - **关键亮点**：暴力枚举波浪数，利用波浪数的特性进行标记，代码结构清晰。
   - **核心代码**：
     ```cpp
     void make(int x){
         for(int i=1;i<x;i++)
           for(int j=0;j<x;j++)
           if(i!=j){
               len=0;
               t=0;
               while(t<r){
                   len++;
                   if(len%2==0) a[len]=i;
                   else a[len]=j;
                   t=t*x+a[len];
                   if(t>r) break;
                   b[t]++;
               }
           }
     }
     ```
   - **核心思想**：通过双重循环构造波浪数，并在范围内标记其波浪重数。

3. **作者：Y_B_Y (赞：4)**
   - **星级：4**
   - **关键亮点**：通过构造波浪数并判断其在不同进制下的波浪性，代码逻辑清晰。
   - **核心代码**：
     ```cpp
     void Search(int k){
         int l = Len(a, k), r = Len(b, k), i, j, u;
         for (i = 1; i < k; i++)
         for (j = 0; j < k; j++){
             if (i == j) continue;
             for (u = l; u <= r; u++){
                 int num = make(i, j, u, k);
                 if (num >= a&&num <= b) Hash[num]++;
             }
         }
     }
     ```
   - **核心思想**：通过三重循环构造波浪数，并在范围内标记其波浪重数。

### 最优关键思路
- **逆向思维**：先构造波浪数，再判断其在不同进制下的波浪性，避免了直接判断的复杂性。
- **枚举与标记**：通过枚举波浪数的构造方式，并在范围内标记其波浪重数，能够高效地找到符合条件的数。

### 可拓展之处
- **类似题目**：可以扩展到更多进制或更高重数的波浪数问题，或者扩展到其他类型的特殊数（如回文数、素数等）。
- **算法优化**：可以考虑进一步优化波浪数的构造方式，减少不必要的枚举。

### 推荐题目
1. [P1113 波浪数](https://www.luogu.com.cn/problem/P1113)
2. [P1114 波浪数 II](https://www.luogu.com.cn/problem/P1114)
3. [P1115 波浪数 III](https://www.luogu.com.cn/problem/P1115)

---
处理用时：27.36秒
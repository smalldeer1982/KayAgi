# 题目信息

# 最大子树和

## 题目描述

小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：

一株奇怪的花卉，上面共连有 $N$ 朵花，共有 $N-1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。

老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。

## 说明/提示

### 数据范围及约定

- 对于 $60\%$ 的数据，有 $1\le N\le 1000$；
- 对于 $100\%$ 的数据，有 $1\le N\le 16000$。

## 样例 #1

### 输入

```
7
-1 -1 -1 1 1 1 0
1 4
2 5
3 6
4 7
5 7
6 7
```

### 输出

```
3```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
题目要求在一棵树上找到最大子树和，核心思路是通过树形动态规划（Tree DP）来解决。大多数题解采用了类似的状态定义和转移方程，即 `f[u]` 表示以 `u` 为根的子树的最大和，初始化 `f[u] = a[u]`，然后根据子树的贡献是否为正来决定是否将其加入当前子树的和。最终结果是从所有 `f[u]` 中取最大值。

### 题解评分与亮点
1. **Mutsumi_0114 (5星)**
   - **亮点**：思路清晰，状态定义和转移方程明确，代码简洁且可读性高。通过图示和详细解释帮助理解树形DP的核心思想。
   - **代码核心**：
     ```cpp
     void dfs(int u, int fa) {
         f[u] = a[u];
         for (int i = 0; i < E[u].size(); i++) {
             int t = E[u][i];
             if (t != fa) {
                 dfs(t, u);
                 if (f[t] > 0) f[u] += f[t];
             }
         }
     }
     ```
   - **个人心得**：通过图示和样例分析，帮助读者更好地理解树形DP的递归过程。

2. **FCBM71 (4星)**
   - **亮点**：提出了两个状态转移方程，分别处理包含和不包含当前节点的情况，思路较为全面，代码实现也较为清晰。
   - **代码核心**：
     ```cpp
     void dfs(int x, int fa) {
         for (int i = head[x]; i; i = nxt[i]) {
             if (to[i] == fa) continue;
             dfs(to[i], x);
             if (fy[to[i]] > 0) fy[x] += fy[to[i]];
             tomax(fn[x], fn[to[i]]);
             tomax(fn[x], fy[to[i]]);
         }
     }
     ```
   - **个人心得**：强调了初始化的重要性，特别是 `fn` 数组需要初始化为极小值以应对所有点权为负的情况。

3. **tribool4_in (4星)**
   - **亮点**：代码简洁，状态转移方程清晰，通过递归实现树形DP，适合初学者理解。
   - **代码核心**：
     ```cpp
     void dfs(int u, int fa) {
         f[u] = a[u];
         for (int i = 0; i < G[u].size(); i++) {
             int v = G[u][i];
             if (v == fa) continue;
             dfs(v, u);
             if (f[v] >= 1) f[u] += f[v];
         }
     }
     ```
   - **个人心得**：强调了递归的终止条件和状态转移的简单性，适合初学者快速上手。

### 最优关键思路
1. **状态定义**：`f[u]` 表示以 `u` 为根的子树的最大和，初始化 `f[u] = a[u]`。
2. **状态转移**：对于每个子节点 `v`，如果 `f[v] > 0`，则将其加入 `f[u]`，否则不加入。
3. **结果计算**：最终结果为所有 `f[u]` 中的最大值。

### 拓展思路
- **类似题目**：可以尝试解决其他树形DP问题，如树的最大独立集、树的最小支配集等。
- **优化技巧**：对于大规模数据，可以考虑使用链式前向星等优化存储结构，减少内存占用。

### 推荐题目
1. P1352 没有上司的舞会（树形DP）
2. P2015 二叉苹果树（树形DP）
3. P2016 战略游戏（树形DP）

### 个人心得总结
- **调试经历**：在实现树形DP时，递归的终止条件和状态转移方程的正确性至关重要，特别是在处理负权值时需要特别注意。
- **顿悟感想**：树形DP的核心在于将问题分解为子问题，通过递归和状态转移逐步求解，理解这一点后，类似的树形问题都可以迎刃而解。

---
处理用时：28.10秒
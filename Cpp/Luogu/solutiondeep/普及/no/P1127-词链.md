# 题目信息

# 词链

## 题目描述

如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。

另外还有一些例子：
- `dog.gopher`
- `gopher.rat`
- `rat.tiger`
- `aloha.aloha`
- `arachnid.dog`

连接成的词可以与其他单词相连，组成更长的词链，例如：

`aloha.arachnid.dog.gopher.rat.tiger`

注意到，`.` 两边的字母一定是相同的。

现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。

## 说明/提示

- 对于 $40\%$ 的数据，有 $n \leq 10$；
- 对于 $100\%$ 的数据，有 $n \leq 1000$。


## 样例 #1

### 输入

```
6
aloha
arachnid
dog
gopher
rat
tiger```

### 输出

```
aloha.arachnid.dog.gopher.rat.tiger```

# AI分析结果

### 算法分类
图论

### 综合分析与结论
该题目要求找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。题解中主要采用了图论中的欧拉路径和深度优先搜索（DFS）算法来解决。通过将单词的首字母和末字母作为图中的节点，单词作为边，构建有向图，并利用欧拉路径的性质来判断是否存在符合条件的词链。大多数题解都涉及到了欧拉路径的判断、DFS搜索以及字典序的处理。

### 所选题解

#### 1. 作者：loc_equinox (赞：86)
- **星级**: 5星
- **关键亮点**: 通过欧拉路径的性质判断是否存在解，并结合DFS搜索字典序最小的词链。代码结构清晰，优化了搜索效率，避免了低效的起点选择。
- **个人心得**: 作者提到在判断欧拉路径时，使用并查集来判断图的连通性，确保了算法的正确性。
- **核心代码**:
```cpp
void dfs(int st, int now, int pre_edge) {
    if (st == n) {
        for (int i = 1; i <= n; i++) {
            cout << res[i];
            if (i < n) cout << ".";
        }
        exit(0);
    }
    for (int k = 0; k < E[now].size(); k++) {
        if (!vis[E[now][k].ord]) {
            vis[E[now][k].ord] = 1;
            res[st + 1] = E[now][k].word;
            dfs(st + 1, E[now][k].to, E[now][k].ord);
        }
    }
    vis[pre_edge] = 0; // 回溯
}
```

#### 2. 作者：zzr8178541919 (赞：83)
- **星级**: 4星
- **关键亮点**: 通过分析字母出现的次数，确定词链的起点，并结合DFS搜索字典序最小的词链。代码简洁，思路清晰。
- **核心代码**:
```cpp
void dfs(int last, int step) {
    if (flag == 1) return;
    if (step == n) {
        flag = 1;
        for (int i = 1; i <= sum; i++) {
            ans[i] = now[i];
        }
        return;
    }
    for (int i = 1; i <= n; i++) {
        if (book[i] == 1) continue;
        if (a[last][a[last].length() - 1] == a[i][0]) {
            now[++sum] = a[i];
            book[i] = 1;
            dfs(i, step + 1);
            sum--;
            book[i] = 0;
        }
    }
}
```

#### 3. 作者：CGDGAD (赞：61)
- **星级**: 4星
- **关键亮点**: 通过优化搜索起点，减少了搜索时间，并结合DFS搜索字典序最小的词链。代码实现较为简洁，思路清晰。
- **核心代码**:
```cpp
void dfs(int s, std::string curr, int count) {
    if (count == n) {
        curr[curr.length() - 1] = ' ';
        std::cout << curr;
        exit(0);
    }
    for (auto i : e[s])
        if (!used[i]) {
            used[i] = true;
            dfs(i, curr + a[i] + '.', count + 1);
            used[i] = false;
        }
}
```

### 最优关键思路或技巧
1. **欧拉路径判断**: 通过统计每个字母的入度和出度，判断是否存在欧拉路径或回路，确保词链的存在性。
2. **DFS搜索**: 使用DFS搜索字典序最小的词链，通过回溯确保所有可能的路径都被遍历。
3. **并查集优化**: 使用并查集判断图的连通性，确保欧拉路径的正确性。

### 可拓展之处
该题解中的欧拉路径和DFS搜索可以应用于其他需要遍历所有边的图论问题，如哈密顿路径、旅行商问题等。

### 推荐题目
1. P1127 词链
2. P1137 旅行计划
3. P1144 最短路径计数

---
处理用时：29.07秒
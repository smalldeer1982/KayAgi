# 题目信息

# [ZJOI2007] 时态同步

## 题目描述

小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。

在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。

激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？

## 说明/提示

- 对于 $40\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 5\times 10^5$。

对于所有的数据，$1\le t_e\le 10^6$。

## 样例 #1

### 输入

```
3
1
1 2 1
1 3 3
```

### 输出

```
2
```

# AI分析结果

### 算法分类
**深度优先搜索 DFS**

### 综合分析与结论
该题的核心是通过调整边权，使得所有叶子节点到根节点的距离相等。大多数题解采用了DFS的思路，通过自底向上的方式计算每个节点到叶子节点的最大距离，并在回溯时累加调整边权的次数。虽然部分题解提到“树形DP”，但本质上仍然是DFS的应用。

### 所选高星题解
1. **题解作者：Mathison**
   - **星级：5星**
   - **关键亮点**：思路清晰，代码简洁，通过两次DFS分别计算最大距离和调整边权，逻辑严密。
   - **核心代码**：
     ```cpp
     void dfs(int x, int fa) {
         for(int i=head[x];i;i=next[i]) {
             int y=ver[i], z=edge[i];
             if(y==fa) continue;
             dfs(y,x);
             dis[x]=max(dis[x],dis[y]+z);
         }
         for(int i=head[x];i;i=next[i]) {
             int y=ver[i], z=edge[i];
             if(y==fa) continue;
             ans+=dis[x]-(dis[y]+z);
         }
     }
     ```
   - **个人心得**：通过两次DFS分别处理最大距离和调整边权，避免了复杂的DP状态转移，代码实现简洁高效。

2. **题解作者：crazydave**
   - **星级：4星**
   - **关键亮点**：详细解释了自底向上的维护过程，代码结构清晰，适合初学者理解。
   - **核心代码**：
     ```cpp
     void dfs(int x, int fa) {
         for(int i=head[x]; i; i=edge[i].next) {
             int v=edge[i].to;
             if(v==fa) continue;
             dfs(v,x);
             maxn[x]=max(maxn[x], edge[i].dis);
         }
         for(int i=head[x]; i; i=edge[i].next) {
             int v=edge[i].to;
             if(v==fa) continue;
             ans+=(maxn[x]-edge[i].dis);
         }
     }
     ```
   - **个人心得**：通过自底向上的方式维护每个节点的最大距离，并在回溯时累加调整边权的次数，思路清晰。

3. **题解作者：xyz32768**
   - **星级：4星**
   - **关键亮点**：使用了树形DP的思路，状态转移方程清晰，适合有一定DP基础的同学。
   - **核心代码**：
     ```cpp
     void dfs(int u, int fa) {
         for(auto v : G[u]) {
             if(v.first == fa) continue;
             dfs(v.first, u);
             f[u] = max(f[u], f[v.first] + v.second);
         }
         for(auto v : G[u]) {
             if(v.first == fa) continue;
             ans += f[u] - (f[v.first] + v.second);
         }
     }
     ```
   - **个人心得**：通过树形DP的方式，状态转移方程清晰，适合理解DP思想的同学。

### 最优关键思路
- **自底向上的DFS**：通过DFS从叶子节点向上计算每个节点到叶子节点的最大距离，并在回溯时累加调整边权的次数。
- **贪心思想**：在调整边权时，优先调整靠近根节点的边，以减少调整次数。

### 可拓展之处
- **类似问题**：可以通过类似的DFS思路解决其他树形结构的问题，如树的直径、树的重心等。
- **优化技巧**：可以通过预处理或剪枝优化DFS的效率，尤其是在大规模数据下。

### 推荐题目
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
2. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)
3. [P2014 选课](https://www.luogu.com.cn/problem/P2014)

### 个人心得总结
- **调试经历**：在实现DFS时，需要注意回溯时的状态更新，避免重复计算。
- **踩坑教训**：在处理树形结构时，务必注意父子节点的关系，避免无限递归。
- **顿悟感想**：通过DFS的自底向上处理，可以简化复杂的树形问题，代码实现也更加简洁。

---
处理用时：33.59秒
# 题目信息

# 奶牛分厩

## 题目描述

农夫约翰有 $N(1 \le N \le 5000)$ 头奶牛，每头奶牛都有一个唯一的不同于其它奶牛的编号 $s_i$，所有的奶牛都睡在一个有 $K$ 个厩的谷仓中，厩的编号为 $0$ 到 $K-1$。每头奶牛都知道自己该睡在哪一个厩中，因为约翰教会了它们做除法，$S_i  \bmod  K$ 的值就是第 $i$ 头奶年所睡的厩的编号。

给出一组奶牛的编号，确定最小的 $K$ 使得没有二头或二头以上的奶牛睡在同一厩中。


## 说明/提示

$S_i(1\le S_i \le 1000000)$


## 样例 #1

### 输入

```
5 
4 
6 
9 
10 
13 
```

### 输出

```
8```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
题目要求找到最小的K，使得所有奶牛的编号对K取模的结果互不相同。核心思路是利用数学中的同余定理，即若a ≡ b (mod K)，则K | (a - b)。因此，我们需要找到所有奶牛编号差值的因数，并排除这些因数，最终找到最小的未被标记的K。

### 所选题解
1. **作者：Makasukaka (赞：91)**
   - **星级：5星**
   - **关键亮点：**
     - 利用调和级数优化了时间复杂度，复杂度为O(n^2 + s log s)，其中s是数域大小。
     - 通过预处理所有差值并标记其因数，避免了重复计算。
     - 代码简洁，逻辑清晰，易于理解。
   - **个人心得：**
     - 作者指出前一篇题解的错误，并给出了正确的证明和优化思路，体现了对问题的深入理解。

```cpp
#include<cstdio>
#include<cstdlib>
const int N=5e3+5,K=1e6+5;
int a[N],vis[K],n;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;++i){
        for(int j=i+1;j<=n;++j){
            int cur=abs(a[i]-a[j]);
            vis[cur]=1;
        }
    }
    for(int i=n;i<K;++i){
        if(!vis[i]){
            int f=1;
            for(int j=i;j<K;j+=i)if(vis[j]){f=0;break;}
            if(f){
                printf("%d\n",i);
                return 0;
            }
        }
    }
    return 0;
}
```

2. **作者：陈见澍 (赞：37)**
   - **星级：4星**
   - **关键亮点：**
     - 通过枚举所有差值并标记其因数，最终找到未被标记的最小K。
     - 代码实现较为直观，逻辑清晰。
   - **个人心得：**
     - 作者通过反面入手，避免了直接暴力枚举的TLE问题，体现了对问题的灵活处理。

```cpp
#include<bits/stdc++.h>
#define MAX (1000001)
using namespace std;
int n,a[MAX],d[MAX];
int main()
{
	int i,j,k,x;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	for(i=1;i<n;i++)
	{
		for(j=i+1;j<=n;j++)
		{
			x=abs(a[i]-a[j]);
			for(k=1;k*k<=x;k++)
			{
				if(!(x%k))
				{
					d[k]=d[x/k]=1;
				}
			}
		}
	}
	for(i=1;d[i];i++);
	printf("%d\n",i);
	return 0;
}
```

3. **作者：Jelly_Goat (赞：9)**
   - **星级：4星**
   - **关键亮点：**
     - 使用bitset优化空间复杂度，代码简洁高效。
     - 通过枚举K的倍数，判断是否被标记，逻辑清晰。
   - **个人心得：**
     - 作者通过bitset的使用，展示了如何通过数据结构优化空间复杂度，体现了对问题的深入理解。

```cpp
#include <iostream>
#include <cstdio>
#include <bitset>
using namespace std;
const int maxn = 1000000;
bitset<1000001> vst;
int s[5086], n;
inline int abs(int num) { return num < 0 ? -num : num; }
inline bool judge(int k)
{
    for (int i = 1; i * k <= maxn; i++)
    {
        if (vst[i * k]) return false;
    }
    return true;
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d",&s[i]);
    }
    for (int i = 1; i <= n; i++)
        for (int j = i + 1; j <= n; j++)
            vst[abs(s[i] - s[j])]=1;
    int k = n;
    while (!judge(k)) k++; 
    printf("%d\n", k);
    return 0;
}
```

### 最优关键思路或技巧
1. **调和级数优化**：通过调和级数的性质，优化了枚举K的倍数的时间复杂度，使得整体复杂度降低。
2. **bitset优化空间**：使用bitset来标记差值，减少了空间复杂度，提高了代码效率。
3. **同余定理应用**：利用同余定理，将问题转化为寻找差值的因数，避免了直接暴力枚举的TLE问题。

### 可拓展之处
类似的问题可以扩展到其他需要寻找最小满足条件的数的场景，如寻找最小的模数使得一组数的哈希值互不相同，或者寻找最小的数使得一组数的某种运算结果互不相同。

### 推荐题目
1. **P1045 最大公约数和最小公倍数问题**
2. **P1075 质因数分解**
3. **P1029 最大公约数**

### 个人心得总结
- **调试经历**：多位作者在题解中提到了调试过程中遇到的TLE问题，并通过优化算法或数据结构解决了这些问题。
- **踩坑教训**：部分作者指出前人的题解存在错误，并给出了正确的证明和优化思路，体现了对问题的深入理解。
- **顿悟感想**：通过反面入手，避免了直接暴力枚举的TLE问题，体现了对问题的灵活处理。

---
处理用时：36.99秒
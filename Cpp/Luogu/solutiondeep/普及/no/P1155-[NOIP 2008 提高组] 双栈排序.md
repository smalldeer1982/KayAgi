# 题目信息

# [NOIP 2008 提高组] 双栈排序

## 题目描述

Tom 最近在研究一个有趣的排序问题。如图所示，通过 $2$ 个栈 $S_1$ 和 $S_2$，Tom 希望借助以下 $4$ 种操作实现将输入序列升序排序。

![](https://cdn.luogu.com.cn/upload/image_hosting/gwxu91ud.png)

- 操作 $\verb!a!$：将第一个元素压入栈 $S_1$。
- 操作 $\verb!b!$：将 $S_1$ 栈顶元素弹出至输出序列。
- 操作 $\verb!c!$：将第一个元素压入栈 $S_2$。
- 操作 $\verb!d!$：将 $S_2$ 栈顶元素弹出至输出序列。


如果一个 $1\sim n$ 的排列 $P$ 可以通过一系列合法操作使得输出序列为 $(1,2,\cdots,n-1,n)$，Tom 就称 $P$ 是一个“可双栈排序排列”。例如 $(1,3,2,4)$ 就是一个“可双栈排序序列”，而 $(2,3,4,1)$ 不是。下图描述了一个将 $(1,3,2,4)$ 排序的操作序列：$\texttt {a,c,c,b,a,d,d,b}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/jwdjwfee.png)

当然，这样的操作序列有可能有几个，对于上例 $(1,3,2,4)$，$\texttt{a,b,a,a,b,b,a,b}$ 是另外一个可行的操作序列。Tom 希望知道其中字典序最小的操作序列是什么。

## 说明/提示

$30\%$ 的数据满足：$n\le10$。

$50\%$ 的数据满足：$n\le50$。

$100\%$ 的数据满足：$n\le1000$。

2021.06.17 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)。hack 数据单独分为一个 subtask 防止混淆。

noip2008 提高第四题

## 样例 #1

### 输入

```
4
1 3 2 4```

### 输出

```
a b a a b b a b```

## 样例 #2

### 输入

```
4
2 3 4 1```

### 输出

```
0```

## 样例 #3

### 输入

```
3
2 3 1```

### 输出

```
a c a b b d```

# AI分析结果

### 算法分类
图论

### 综合分析与结论
本题的核心在于判断给定的序列是否可以通过双栈操作排序，并输出字典序最小的操作序列。主要思路是通过二分图染色来判断序列是否可排序，并通过贪心策略来生成字典序最小的操作序列。难点在于如何高效地判断序列是否可排序，以及如何在操作序列中保证字典序最小。

### 所选题解

#### 题解1：zjp_shadow (5星)
**关键亮点**：
1. 使用二分图染色来判断序列是否可排序，思路清晰。
2. 通过贪心策略生成字典序最小的操作序列，代码实现简洁高效。
3. 提供了详细的样例分析，帮助理解算法的正确性。

**核心代码**：
```cpp
void Push(int cur, int id) {
    if (id == 1) { while(Pop(0)); }
    while (!S[id].empty() && S[id].top() < cur)
        if (!Pop(id)) Pop(id ^ 1);
    if (id == 1) { while(Pop(0)); }
    S[id].push(cur); out(id ? 'c' : 'a');
}
```
**核心思想**：在入栈时，先尽可能弹出栈顶元素，保证栈的单调性，从而生成字典序最小的操作序列。

#### 题解2：我是逍逍 (4星)
**关键亮点**：
1. 通过二分图染色法判断序列是否可排序，思路清晰。
2. 在生成操作序列时，通过调整操作顺序来保证字典序最小。

**核心代码**：
```cpp
void dfs(int u, int c) {
    color[u] = c;
    for (int v : G[u]) {
        if (~col[v] && col[v] != (col[u] ^ 1)) return puts("0"), 0;
        if (!~col[v]) Q.push(v);
        col[v] = col[u] ^ 1;
    }
}
```
**核心思想**：通过DFS进行二分图染色，确保序列可排序。

#### 题解3：Coros_Trusds (4星)
**关键亮点**：
1. 使用二分图染色法判断序列是否可排序，思路清晰。
2. 在生成操作序列时，通过调整操作顺序来保证字典序最小。

**核心代码**：
```cpp
void dfs(int u,int cc) {
    if(col[u]!=-1&&col[u]!=cc) {cout<<0;exit(0);}
    if(col[u]!=-1) return ;
    col[u]=cc;
    for(auto v:G[u]) dfs(v,1-cc);
    return ;
}
```
**核心思想**：通过DFS进行二分图染色，确保序列可排序。

### 最优关键思路或技巧
1. **二分图染色**：通过判断序列中的元素是否可以通过二分图染色来划分到两个栈中，确保序列可排序。
2. **贪心策略**：在生成操作序列时，优先选择字典序较小的操作，保证最终操作序列的字典序最小。

### 可拓展之处
1. **多栈排序**：可以扩展到更多栈的情况，判断序列是否可以通过多个栈排序。
2. **其他排序问题**：类似的双栈排序问题可以扩展到其他排序问题，如三栈排序等。

### 推荐题目
1. [P1155 双栈排序](https://www.luogu.com.cn/problem/P1155)
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
3. [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)

### 个人心得
在调试过程中，发现二分图染色的正确性对最终结果影响很大，必须确保染色过程没有冲突。此外，贪心策略的实现需要仔细考虑操作的优先级，以保证字典序最小。

---
处理用时：26.13秒
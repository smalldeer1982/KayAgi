# 题目信息

# 垃圾陷阱

## 题目描述

卡门――农夫约翰极其珍视的一条 `Holsteins` 奶牛――已经落了到 “垃圾井” 中。“垃圾井” 是农夫们扔垃圾的地方，它的深度为 $D$（$2 \le D \le 100$）英尺。

卡门想把垃圾堆起来，等到堆得与井深同样高或比井深更高（即，垃圾高度总和 $\geq D$）时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。

每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。

假设卡门预先知道了每个垃圾扔下的时间 $t$（$1 \le t \le 1000$），以及每个垃圾堆放的高度 $h$（$1 \le h \le 25$）和吃进该垃圾能增加维持生命的时间 $f$（$1 \le f \le 30$），要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续 $10$ 小时的能量，如果卡门 $10$ 小时内（不含 $10$ 小时，维持生命的时间同）没有进食，卡门就将饿死。特别地，若体力值为 $0$ 时吃下垃圾或逃出井外也不会饿死。

## 说明/提示

**【样例说明】**

卡门堆放她收到的第一个垃圾：$\mathrm{height}=9$；

卡门吃掉她收到的第 $2$ 个垃圾，使她的生命从 $10$ 小时延伸到 $13$ 小时；

卡门堆放第 $3$ 个垃圾，$\mathrm{height}=19$；

卡门堆放第 $4$ 个垃圾，$\mathrm{height}=20$。


## 样例 #1

### 输入

```
20 4
5 4 9
9 3 2
12 6 10
13 1 1```

### 输出

```
13```

# AI分析结果

### 算法分类
动态规划

### 题解综合分析与结论
题目“垃圾陷阱”是一个典型的动态规划问题，核心在于如何通过合理的选择（吃垃圾或堆放垃圾）来最大化卡门的生存时间或尽早逃出井外。题解中大多数采用了类似背包问题的思路，通过状态转移方程来更新卡门在不同高度和生命值下的最优解。难点在于如何处理时间、高度和生命值之间的复杂关系，以及如何确保状态转移的正确性。

### 所选高分题解

#### 1. 题解作者：Dispwnl
- **星级**: 5星
- **关键亮点**: 使用一维数组 `f[high]=life` 来表示不同高度下的最大生命值，通过倒序遍历高度来确保状态转移的正确性。代码简洁且高效，逻辑清晰。
- **核心实现思想**: 
  - 初始化 `f[0] = 10`，表示初始生命值为10。
  - 对于每个垃圾，倒序遍历高度，更新 `f[j + h]` 和 `f[j]`，分别表示堆放垃圾和吃垃圾的状态转移。
  - 如果某个高度 `j + h >= D`，则直接输出当前垃圾的时间。

```cpp
for(int i=1;i<=g;i++)
  for(int j=d;j>=0;j--)
    if(f[j]>=c[i].t) {
      if(j+c[i].h>=d) {
        cout<<c[i].t;
        return 0;
      }
      f[j+c[i].h]=max(f[j+c[i].h],f[j]);
      f[j]+=c[i].l;
    }
```

#### 2. 题解作者：ButterflyDew
- **星级**: 4星
- **关键亮点**: 详细分析了状态转移方程的推导过程，提供了离线算法的思路，并通过填表法实现状态转移。代码结构清晰，注释详细。
- **核心实现思想**: 
  - 使用 `dp[i][j]` 表示前i个垃圾处理后在j高度时的最大生命值。
  - 通过填表法更新 `dp[i][j]`，分别考虑吃垃圾和堆放垃圾的情况。
  - 最终遍历所有状态，找到最早逃出井外的时间。

```cpp
for(int i=1;i<=g;i++)
  for(int j=0;j<=d;j++) {
    if(dp[i-1][j]>=trash[i].t)
      dp[i][j]=max(dp[i][j],dp[i-1][j]+trash[i].c);
    if(j>=trash[i].h&&dp[i-1][j-trash[i].h]>=trash[i].t)
      dp[i][j]=max(dp[i][j],dp[i-1][j-trash[i].h]);
  }
```

#### 3. 题解作者：wjyyy
- **星级**: 4星
- **关键亮点**: 使用 `dp[i][j]` 存储在扔进去i个垃圾，高度为j时的最大生命值，通过初始化负值来避免无效状态。代码逻辑严谨，状态转移清晰。
- **核心实现思想**: 
  - 初始化 `dp[0][0] = 10`，表示初始生命值为10。
  - 对于每个垃圾，更新 `dp[i][j]`，分别考虑吃垃圾和堆放垃圾的情况。
  - 如果某个高度 `j + h[i] >= D`，则直接输出当前垃圾的时间。

```cpp
for(int i=0;i<g;i++)
  for(int j=0;j<=d;j++) {
    if(dp[i][j]<0) continue;
    if(j+r[i+1].h>=d&&dp[i][j]>=r[i+1].t-r[i].t) {
      printf("%d\n",r[i+1].t);
      return 0;
    }
    if(dp[i][j]-r[i+1].t+r[i].t>=0)
      dp[i+1][j+r[i+1].h]=dp[i][j]-r[i+1].t+r[i].t;
    if(dp[i][j]-r[i+1].t+r[i].t>=0)
      dp[i+1][j]=max(dp[i+1][j],dp[i][j]-r[i+1].t+r[i].t+r[i+1].f);
  }
```

### 最优关键思路或技巧
1. **状态压缩**: 使用一维数组 `f[high]=life` 来表示不同高度下的最大生命值，减少空间复杂度。
2. **倒序遍历**: 在状态转移时，倒序遍历高度，确保状态转移的正确性。
3. **初始化负值**: 通过初始化负值来避免无效状态，确保状态转移的准确性。

### 可拓展之处
类似的问题可以扩展到其他资源分配问题，如背包问题、任务调度问题等。通过合理选择状态表示和状态转移方程，可以解决类似的优化问题。

### 推荐题目
1. P1048 采药
2. P1060 开心的金明
3. P1164 小A点菜

### 个人心得摘录
- **调试经历**: 部分题解中提到在状态转移时忽略了生命值为0的情况，导致WA。通过初始化负值解决了这个问题。
- **踩坑教训**: 在状态转移时，必须确保生命值大于等于垃圾掉落的时间，否则无法进行有效转移。
- **顿悟感想**: 通过倒序遍历高度，可以确保状态转移的正确性，避免重复计算。

---
处理用时：41.64秒
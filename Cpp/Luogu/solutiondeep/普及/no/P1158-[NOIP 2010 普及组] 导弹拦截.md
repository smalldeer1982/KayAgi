# 题目信息

# [NOIP 2010 普及组] 导弹拦截

## 题目描述

经过 $11$ 年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 $0$ 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。

某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。

## 说明/提示

两个点 $(x_1,y_1),(x_2,y_2)$ 之间距离的平方是 $(x_1-x_2)^2+(y_1-y_2)^2$。

两套系统工作半径 $r_1,r_2$ 的平方和，是指 $r_1,r_2$ 分别取平方后再求和，即 $r_1^2+r_2^2$。

### 样例 1 说明

样例 $1$ 中要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $18$ 和 $0$。

### 样例 2 说明

样例 $2$ 中的导弹拦截系统和导弹所在的位置如下图所示。要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $20$ 和 $10$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cvgomt03.png)

【数据范围】。

- 对于 $10\%$ 的数据，$N=1$。
- 对于 $20\%$ 的数据，$1\le N\le 2$。
- 对于 $40\%$ 的数据，$1\le N\le 100$。
- 对于 $70\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 10^5$，且所有坐标分量的绝对值都不超过 $1000$。

NOIP2010 普及组 第三题

## 样例 #1

### 输入

```
0 0 10 0
2
-3 3
10 0```

### 输出

```
18```

## 样例 #2

### 输入

```
0 0 6 0
5
-4 -2
-2 3
4 0
6 -2
9 1```

### 输出

```
30```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
本题的核心在于如何分配导弹到两个拦截系统，以最小化总代价。大多数题解采用了贪心策略，通过排序和枚举来确定最优的拦截方案。具体来说，题解通常先计算每个导弹到两个系统的距离，然后按距离排序，再通过枚举来确定每个系统拦截的导弹范围，最终求出最小代价。

### 所选高星题解

#### 题解1：作者：TEoS (赞：131)
- **星级**：5星
- **关键亮点**：思路清晰，代码简洁，预处理优化了枚举过程，避免了重复计算。
- **核心代码**：
  ```cpp
  sort(di+1,di+n+1,cmp);
  for(int i=n;i>0;i--) {
      int a = pow(x[di[i].i]-x22,2)+pow(y[di[i].i]-y22,2);
      di[i].d2 = max(a,di[i+1].d2);
  }
  for(int i=0;i<=n;i++) {
      int a = di[i].d1 + di[i+1].d2;
      minn = min(a,minn);
  }
  ```
  **实现思想**：先按导弹到系统1的距离排序，预处理每个导弹到系统2的最大距离，然后枚举系统1拦截的导弹范围，计算最小代价。

#### 题解2：作者：YCW13983841648 (赞：6)
- **星级**：4星
- **关键亮点**：详细解释了贪心策略，代码结构清晰，避免了浮点数精度问题。
- **核心代码**：
  ```cpp
  sort(a+1,a+n+1,cmp);
  ans = a[1].num1;
  for(int i=1;i<=n;i++) {
      r = max(r,a[i].num2);
      ans = min(a[i+1].num1 + r, ans);
  }
  ```
  **实现思想**：按导弹到系统1的距离排序，枚举系统1拦截的导弹范围，同时维护系统2的最大距离，计算最小代价。

#### 题解3：作者：Zh_terminal (赞：2)
- **星级**：4星
- **关键亮点**：代码简洁，时间复杂度分析清晰，避免了浮点数精度问题。
- **核心代码**：
  ```cpp
  sort(a+1,a+N+1,cmp);
  int ans = a[N].d1;
  int d = 0;
  for(int i=N;i>=1;i--) {
      d = max(d,a[i].d2);
      int ans2 = a[i-1].d1 + d;
      ans = min(ans,ans2);
  }
  ```
  **实现思想**：按导弹到系统1的距离排序，枚举系统1拦截的导弹范围，同时维护系统2的最大距离，计算最小代价。

### 最优关键思路或技巧
1. **排序与枚举**：通过按导弹到系统1的距离排序，枚举系统1拦截的导弹范围，可以有效地减少计算量。
2. **预处理优化**：预处理每个导弹到系统2的最大距离，避免在枚举过程中重复计算。
3. **避免浮点数精度问题**：直接使用距离的平方进行计算，避免了浮点数带来的精度问题。

### 可拓展之处
- **类似算法套路**：这种排序+枚举的贪心策略可以应用于其他需要分配资源以最小化代价的问题，如任务调度、资源分配等。
- **同类型题目**：
  1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
  2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
  3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得摘录
- **TEoS**：预处理优化了枚举过程，避免了重复计算，代码简洁高效。
- **YCW13983841648**：详细解释了贪心策略，避免了浮点数精度问题，代码结构清晰。
- **Zh_terminal**：代码简洁，时间复杂度分析清晰，避免了浮点数精度问题。

---
处理用时：28.28秒
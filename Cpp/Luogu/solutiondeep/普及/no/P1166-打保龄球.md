# 题目信息

# 打保龄球

## 题目描述

打保龄球是用一个滚球去打击十个站立的柱，将柱击倒。一局分十轮，每轮可滚球一次或多次，以击倒的柱数为依据计分。一局得分为十轮得分之和，而每轮的得分不仅与本轮滚球情况有关，还可能与后续一两轮的滚球情况有关。即某轮某次滚球击倒的柱数不仅要计入本轮得分，还可能会计入前一两轮得分。具体的滚球击柱规则和计分方法如下：

1. 若某一轮的第一次滚球就击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加两次滚球，不妨称其为第十一轮和第十二轮，并不是所有的情况都需要滚第十一轮和第十二轮球）。该轮得分为本次击倒柱数 $10$ 与以后两次滚球所击倒柱数之和。

2. 若某一轮的第一次滚球未击倒十个柱，则可对剩下未倒的柱再滚球一次。如果这两次滚球击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加一次滚球），该轮得分为这两次共击倒柱数 $10$ 与以后一次滚球所击倒柱数之和。

3. 若某一轮两次滚球未击倒全部十个柱，则本轮不再继续滚球，该轮得分为这两次滚球击倒的柱数之和。   

总之，若―轮中一次滚球或两次滚球击倒十个柱，则本轮得分是本轮首次滚球开始的连续三次滚球击倒柱数之和（其中有一次或两次不是本轮滚球）。若一轮内二次滚球击倒柱数不足十个，则本轮得分即为这两次击倒柱数之和。下面以实例说明如下(字符 `/` 表示击倒当前球道上的全部的柱)：

| 轮 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| 击球情况  |  /  |  /  |  /  |  72 |  9/ |  81  | 8/  |  / |   9/  |  /  |  8/ |
| 各轮得分 |  30  | 27  | 19 |  9   |18   | 9  | 20  | 20 |  20 |  20|
|累计总分 |  30  | 57  |76 |  85|  103 |  112 | 132  |152 | 172 | 192|

现在请你编写一个保龄球实时计分程序，用来计算和显示某轮结束后的得分情况。若某轮的得分暂时无法算出，则**不显示**该轮得分（不输出）。


## 样例 #1

### 输入

```
/ / / 72 9/ 81 8/ / 9/ / 8/```

### 输出

```
30 27 19 9 18 9 20 20 20 20 
30 57 76 85 103 112 132 152 172 192```

# AI分析结果



**算法分类**  
模拟

---

**题解综合分析**  
各题解围绕保龄球计分规则展开模拟，核心难点在于：  
1. 正确处理补全后续轮次得分（全中/补中时需向后预取1-2次击球数据）  
2. 实时判断得分是否可计算（后续数据不足时跳过输出）  
3. 第十轮特殊处理（可能触发第11、12轮击球）  

主要实现方式分为两类：  
- **击球序列预处理法**（X_WT、袁宇轩等）：将输入转化为击球数组，逐轮遍历时根据当前状态向后索引计算得分  
- **轮次状态跟踪法**（Shadow_T等）：记录每轮的剩余瓶数、击球次数等状态，动态判断得分是否可结算  

---

**优质题解推荐**  

**1. 袁宇轩（★★★★☆）**  
**亮点**：  
- 通过 `st` 指针跟踪每轮起始位置，清晰处理三种得分情况  
- 使用 `rest` 动态维护剩余瓶数，逻辑直观  
- 代码简洁，边界条件处理完善  

**关键代码**：  
```cpp
int st = 1; // 当前轮的起始击球位置
for (int i = 1; i <= 10; i++) {
    int rest = 10, flag = 1;
    for (int j = st; j <= st + 2; j++) {
        if (j > n) { sum[i] = -1; break; } // 数据不足
        if (rest == 0) { rest = 10; flag = 0; }
        if (j == st + 2 && flag) break;
        // 处理击球得分...
    }
    // 更新 st 指针...
}
```

**2. Shadow_T（★★★★☆）**  
**亮点**：  
- 使用 `p` 数组标记击球是否完成，严格判断得分可计算性  
- 分离得分计算与输出逻辑，结构清晰  

**关键实现**：  
```cpp
if (df[i][1] == 10) {
    if (!y[i+1][1]) break; // 检查后续击球数据
    d[i] = 10 + df[i+1][1] + (后续处理...);
} else {
    // 处理补中和普通情况...
}
```

**3. 深海鱼的眼泪（★★★☆☆）**  
**亮点**：  
- 显式处理第十一轮数据  
- 详细注释提升可读性  

---

**最优思路提炼**  
1. **击球序列预处理**：将输入转换为数值数组，每个元素记录单次击倒数（`/`转为10）  
2. **轮次遍历**：对每轮判断是否全中/补中，向后索引1-2次击球数据求和  
3. **实时中断**：若后续数据不足（如数组越界），立即终止当前轮得分计算  

---

**拓展与举一反三**  
同类问题特征：  
- 当前状态依赖后续操作（如游戏技能冷却、连续奖励机制）  
- 需动态判断结果是否可输出  

**推荐题目**：  
1. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)（实时比分统计）  
2. [P1098 字符串的展开](https://www.luogu.com.cn/problem/P1098)（多条件字符串处理）  
3. [P1328 生活大爆炸版石头剪刀布](https://www.luogu.com.cn/problem/P1328)（循环规则模拟）  

---

**题解中的调试智慧**  
- **袁宇轩**提到“稍不注意会掉到坑里”，强调注意题目中“暂时无法算出”的隐含条件  
- **X_WT**在注释中指出“将10换掉”的细节处理，避免重复计算补中时的分数  
- **Shadow_T**通过`flag`数组严格分离得分计算与输出阶段，避免逻辑耦合错误

---
处理用时：49.66秒
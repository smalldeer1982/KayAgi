# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果



### 算法分类
队列（对顶堆）

### 分析与结论
本题核心在于动态维护数据流的中位数。主流解法有：  
1. **对顶堆法**（最优）：用大根堆存较小半元素，小根堆存较大半元素，保持堆大小差≤1，堆顶即中位数  
2. 平衡树/权值线段树：离散化后维护排名，查询第k大数  
3. 暴力维护有序数组：每次插入后排序，效率低  

### 精选题解
1. **肖恩Sean（5星）**  
- 关键亮点：清晰的对顶堆维护逻辑，代码简洁  
- 核心思想：  
  ```cpp
  priority_queue<int> q1; // 大根堆存较小半
  priority_queue<int,vector<int>,greater<int>> q2; // 小根堆存较大半
  // 插入时比较堆顶决定位置，调整堆大小平衡
  while(abs(q1.size()-q2.size())>1) {
      if(q1.size()>q2.size()) q2.push(q1.top()),q1.pop();
      else q1.push(q2.top()),q2.pop();
  }
  ```
  
2. **IRipple（4星）**  
- 亮点：引入mid变量辅助调整，逻辑更直观  
- 心得："每次插入后若堆大小不符，将mid转移至较小堆"  

### 关键技巧
对顶堆维护流程：  
1. 新元素根据当前mid决定插入堆  
2. 若两堆大小差>1，将较大堆顶元素转移到另一堆  
3. 中位数为元素较多的堆顶  

### 拓展应用
类似动态维护中位数问题：  
- 滑动窗口中位数（洛谷P3871）  
- 动态第k大查询（洛谷P1801）  

### 推荐习题
1. [P1801 黑匣子](https://www.luogu.org/problem/P1801)  
2. [P3871 中位数](https://www.luogu.org/problem/P3871)  
3. [P3378 堆](https://www.luogu.org/problem/P3378)

---
处理用时：51.16秒
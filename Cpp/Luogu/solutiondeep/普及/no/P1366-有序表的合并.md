# 题目信息

# 有序表的合并

## 题目描述

给出两个数列 $a, b$，均按不降序排序。其中保证 $a$ 中没有重复的数字。

现在请你求出：$a$ 中每一个数字在 $b$ 中出现了几次？

## 说明/提示

### 样例 1 解释

- $a_1 = 1$ 在 $b$ 中出现了 $1$ 次。
- $a_2 = 3$ 在 $b$ 中出现了 $2$ 次。
- $a_3 = 6$ 在 $b$ 中出现了 $0$ 次。

故输出为 $1 \bigoplus 2 = 3$。

### 样例 2 解释

$1, 4, 5$ 分别在 $b$ 中出现了 $2, 1, 1$ 次，故输出为 $2 \bigoplus 1 \bigoplus 1 = 2$。

### 数据规模与约定

对于全部的测试点，保证：
- $1 \leq T \leq 10$；
- $1 \leq n, m \leq 10^7$，$\sum (n + m) \leq  10^7$；
- $1 \leq a_i, b_i < 2^{64}$，且 $a_i < a_{i + 1}$，$b_i \leq b_{i + 1}$。

其中 $\sum (n+m)$ 表示单测试点内所有 $n$ 与 $m$ 的和，即输入数列的总长度不超过 $10^7$。

### 提示

- 请注意大量数据读入对程序效率造成的影响，选择合适的读入方式，避免超时。
- 请采用合适的数据类型存储变量，避免溢出。
- 如果你不知道什么是按位异或和，可以在你的代码里添加如下的函数：

```cpp
template <class T>
T getXorSum(T *begin, T *end) {
  T ret = 0;
  for (T *it = begin; it != end; ++it) ret ^= *it;
  return ret;
}
```
这一函数的作用是计算传入数组（包括 `std::vector`）某一左闭右开区间的按位异或和，返回值类型与传入数组的类型相同，调用方法与 `std::sort` 类似，例如，要求数组 $a$ 的 $a_1 \sim a_n$ 的按位异或和，则调用 `getXorSum(a + 1, a + 1 + n)`，求 $a_0 \sim a_{n - 1}$ 的按位异或和，则调用 `getXorSum(a, a + n)`。如果 $a$ 是 `std::vector`，则将上述调用代码里的 `a` 均改为 `a.begin()` 即可。


## 样例 #1

### 输入

```
1
3 5
1 3 6
1 3 3 5 5```

### 输出

```
3```

## 样例 #2

### 输入

```
1
9 4
1 2 3 4 5 6 7 8 9
1 1 4 5```

### 输出

```
2```

## 样例 #3

### 输入

```
2
3 5
1 3 6
1 3 3 5 5
9 4
1 2 3 4 5 6 7 8 9
1 1 4 5```

### 输出

```
3
2```

# AI分析结果



### 算法分类标签
双指针

### 综合分析
本题核心是利用有序特性，通过双指针在线性时间内完成统计。各解法均基于以下关键点：
1. 利用a的严格递增和b的非递减特性，确保指针只需单向移动
2. 通过维护b的扫描位置避免重复遍历
3. 在统计时直接计算连续相等区间长度或累加计数

### 优质题解推荐

#### 1. 作者：Usada_Pekora（5星）
**核心亮点**：  
- 极简双指针实现，j指针继承式移动，复杂度严格线性  
- 通过 `a[i] >= b[j]` 统一处理边界，逻辑清晰  
- 完美处理输入输出效率问题，使用快速读入模板

**关键代码**：
```cpp
int j = 1, cnt = 0, ans = 0;
for (int i = 1; i <= n; i++) {
    cnt = 0;
    while (j <= m && a[i] >= b[j]) {
        cnt += (a[i] == b[j]);
        j++;
    }
    ans ^= cnt;
}
```

#### 2. 作者：Sun_Email（4星）
**核心亮点**：  
- 动态处理b数组输入，节省内存空间  
- 巧妙利用 `a[tot]<b` 的条件直接跳过无效元素  
- 边读入边处理，适合超大b数组场景

**关键技巧**：
```cpp
for(int i=1;i<=m;++i){
    scanf("%llu",&b);
    while(tot<=n && a[tot]<b){ // 跳过所有小于当前b的a元素
        ans^=cnt; cnt=0; ++tot;
    }
    if(tot<=n && a[tot]==b) ++cnt;
}
```

#### 3. 作者：Link_Cut_Y（4星）
**核心亮点**：  
- 封装统计函数提升代码可读性  
- 使用迭代器风格的指针操作  
- 严格限制循环次数，避免越界访问

**关键实现**：
```cpp
int get(unsigned long long val, int &iter) {
    int cnt = 0;
    for (; iter <= m && b[iter] <= val; 
        cnt += (val == b[iter++]));
    return cnt;
}
```

### 最优技巧总结
1. **指针继承机制**：每次处理a[i]时，从处理a[i-1]结束的位置继续扫描b数组  
2. **连续区间统计**：利用有序性将相等元素聚集，直接计算区间长度或累加计数  
3. **输入优化**：对大规模数据采用`getchar`快速读入，避免使用`cin`

### 拓展思考
同类问题可参考：
1. 两有序数组的交集（[P1577](https://www.luogu.com.cn/problem/P1577)）
2. 合并两个有序数组（[P88 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)）
3. 有序数组的平方（[P977 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)）

### 调试经验摘录
- **Sun_Email**：强调`unsigned long long`的格式符必须是`%llu`而非`%ull`  
- **wdgm4**：在循环外补充异或操作，避免最后一个元素的计数丢失  
- **so_find_skind**：发现传统二分法在空间上的瓶颈，转向双指针优化

---
处理用时：48.12秒
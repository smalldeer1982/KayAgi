# 题目信息

# 跑步

## 题目描述

新牛到部队，CG 要求它们每天早上搞晨跑，从 $A$ 农场跑到 $B$ 农场。从 $A$ 农场到 $B$ 农场中有 $n-2$ 个路口，分别标上号，$A$ 农场为 $1$ 号，$B$ 农场为 $n$ 号，路口分别为 $2,3,4,\cdots,n-1$ 号，从 $A$ 农场到 $B$ 农场有很多条路径可以到达，而 CG 发现有的路口是必须经过的，即每条路径都经过的路口，CG 要把它们记录下来，这样 CG 就可以先到那个路口，观察新牛们有没有偷懒，而你的任务就是找出所有必经路口。

## 样例 #1

### 输入

```
6 6

1 2

2 4

2 3

3 5

4 5

5 6

```

### 输出

```
2

2 5

```

# AI分析结果



**算法分类**: 并查集

---

### 题解综合分析
本题核心是找出所有删除后会导致起点到终点不连通的中间节点。主流解法包含三种思路：
1. **暴力DFS/BFS**：枚举每个中间点，删除后搜索连通性（时间复杂度O(n(m+n))）
2. **并查集判连通**：枚举每个点，排除后合并其他边，判断起点终点连通性（时间复杂度O(nm)）
3. **图论缩点法**：通过边双缩点后找关键链点（时间复杂度O(n+m)但实现复杂）

其中并查集解法在代码简洁性与效率间取得最佳平衡，成为主流解法。

---

### 高星题解推荐

#### 1. 作者：LlLlCc（⭐️⭐️⭐️⭐️⭐️）
**关键亮点**：
- 使用并查集实现，代码极简（仅30行）
- 通过分离集合合并逻辑与主流程，结构清晰
- 完全符合题目数据范围（n≤2000）

**核心代码**：
```cpp
for(int i=2;i<n;i++){
    init_set(); // 初始化并查集
    // 合并不包含i的边
    for(j=1;j<=m;j++) if(a[j]!=i&&b[j]!=i) merge(a[j],b[j]);
    if(getf(1)!=getf(n)) ans.push_back(i); // 判断连通性
}
```

#### 2. 作者：Sol1（⭐️⭐️⭐️⭐️）
**关键亮点**：
- 引入vector存储答案，动态管理结果集
- 完整包含输入输出处理，适合初学者学习
- 添加了路径压缩优化

**调试心得**：
> "原本想用割点模板，后来发现题目特殊要求，及时转向并查集解法"——体现问题分析的重要性

---

### 关键思路总结
**并查集枚举法**的核心步骤：
1. **枚举中间点**：遍历2~n-1的每个候选点
2. **动态构建图**：排除当前候选点后合并所有其他边
3. **连通性验证**：通过find(1)==find(n)判断是否关键点

**优化技巧**：
- 预处理存储所有边，枚举时动态过滤
- 使用路径压缩+按秩合并提升查询效率
- 结果集动态存储避免二次遍历

---

### 拓展应用
同类问题可参考：
1. [P2194 HXY烧情侣](https://www.luogu.com.cn/problem/P2194)（必经点变形）
2. [P3388 割点模板](https://www.luogu.com.cn/problem/P3388)（标准图论解法）
3. [P2146 软件包管理器](https://www.luogu.com.cn/problem/P2146)（树结构关键节点）

---

### 推荐练习
1. **P3388** - 割点（标准Tarjan应用）
2. **P2194** - 必经点变形（思维转换）
3. **P5057** - 简单题（并查集灵活应用）

---
处理用时：50.24秒
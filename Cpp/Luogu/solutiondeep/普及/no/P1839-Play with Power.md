# 题目信息

# Play with Power

## 题目描述

Masha 和 Stas 正在玩一个游戏。在游戏的开始，给出一个数  $n$，同时有两个正整数  $a,b$，初始时满足 $a^b\le n$。

Masha 先手。每一回合，玩家要将 $a,b$ 的其中一个数加上  $1$，但不能使 $a^b>n$，否则该玩家输。

现在，Masha 想知道，假如两人都使用最优策略，对于同一个 $n$ 和不同的 $a,b$，谁将获胜呢？


## 说明/提示

#### 数据规模与约定

- 对于  $30\%$ 的数据，有  $1\le n\le 2\cdot10^3$。
- 对于  $100\%$ 的数据，有  $1\le n\le 10^8$， $1\le t\le 100$， $1\le a,b,a^b\le n$。

## 样例 #1

### 输入

```
9 

2 

2  2 

1  4 ```

### 输出

```
Masha 

Missing```

# AI分析结果



**算法分类**  
深度优先搜索 DFS（记忆化搜索）

---

### **题解综合分析与结论**  
本题属于博弈论中的必胜态/必败态分析问题，核心思路为：  
1. **记忆化搜索**：通过递归遍历所有可能的状态转移，结合缓存优化时间复杂度。  
2. **状态定义**：每个状态 `(a, b)` 对应三种结果：必胜、必败、平局。  
3. **边界处理**：  
   - 当 `a=1` 且 `b` 过大时，因无法改变结果导致平局。  
   - 当 `b=1` 且 `a` 接近 `n` 时，根据奇偶性判断胜负。  
4. **快速幂优化**：防止计算 `a^b` 时溢出，需在幂运算中提前终止。  

---

### **高星题解推荐**  
1. **Shallowy（⭐⭐⭐⭐⭐）**  
   **亮点**：  
   - 精确处理快速幂溢出，预计算 `g[b][a]` 避免重复计算。  
   - 代码中巧妙处理 `a=1` 和 `b=1` 的边界条件，逻辑清晰。  
   **核心代码**：  
   ```cpp
   ll p(ll a,ll x){ // 快速幂，溢出返回-1
       if(a>n) return -1;
       ll ans=1;
       while(x) {
           if(x&1) ans *=a;
           a *=a, x >>=1;
           if(ans>n || a>n) return -1;
       }
       return ans;
   }
   int f(ll a,ll b){
       if(b>30) return 1; // 处理a=1时的无限加b
       if(g[b][a] == -1) return 2; // 当前状态已超n，上一步玩家输
       int n1=f(a+1,b), n2=f(a,b+1);
       if(n1==2 && n2==2) return 0; // 必败
       if(n1==0 || n2==0) return 2; // 必胜
       return 1; // 平局
   }
   ```

2. **xk2013（⭐⭐⭐⭐）**  
   **亮点**：  
   - 简洁的状态转移逻辑，直接分类讨论子状态。  
   - 对 `a=1` 和 `b=1` 的特殊情况进行显式处理。  
   **核心代码**：  
   ```cpp
   int dfs(int a, int b){
       if(a==1 && b>27) return 2; // 平局
       if(b==1 && a > n/a) return ((n-a)%2); // 奇偶性判断
       if(ans[a][b]) return ans[a][b];
       if(pow(a,b) > n) return ans[a][b] = 0;
       int ta=dfs(a+1,b), tb=dfs(a,b+1);
       if(ta==0 && tb==0) return ans[a][b] = 1; // 必败
       if(ta==1 || tb==1) return ans[a][b] = 0; // 必胜
       return ans[a][b] = 2; // 平局
   }
   ```

---

### **关键思路与技巧总结**  
1. **记忆化剪枝**：通过缓存状态避免重复递归，时间复杂度优化至 `O(a_max * b_max)`。  
2. **快速幂防溢出**：在计算 `a^b` 时，每一步乘法后检查是否超过 `n`。  
3. **边界条件特判**：  
   - `a=1` 时，`b` 过大导致无法终止，需强制返回平局。  
   - `b=1` 时，转化为交替加 `a` 的奇偶性问题。  

---

### **类似题目推荐**  
1. **P1512 取石子游戏**（博弈论 + 记忆化搜索）  
2. **P3182 三子棋**（状态转移与必胜态分析）  
3. **P2599 取石子游戏**（复杂博弈模型，扩展思路）

---
处理用时：62.26秒
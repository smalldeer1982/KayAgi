# 题目信息

# 影像之结构化特征

## 题目描述

在影像比对中，有一种方法是利用影像中的边缘（edge）信息，计算每个边缘资讯中具有代表性的结构化特征，以作为比对两张影像是否相似的判断标准。Water-filling 方法是从每个边缘图的一个端点开始，绕着相连的边缘点走并依序编号。若走到某一步时，遇到一个以上不同的连接点，则分成不同路径同时继续走，直到没有任何连接点为止。如果一个点和另一个点为上下左右相邻，就称为连接。

例如，在图 $1$ 的影像中包含三个边缘图，每个边缘图由一些互相连接的边缘点构成。图中以黑色的方块代表边缘点，白色的方块代表背景。在 Water-filling 方法中，首先，从第一行（row）开始，由左至右，由上至下，先找到第一个黑点并编号为 $1$。接着，找 $1$ 的下一个尚未编号的连接点并编号为 $2$。依此方法继续往下一个点前进依次编号。在编号 $6$ 的点之后有两个尚未编号的连接点，此时，则分为两条路线，并同时编号为 $7$ 继续往下走。当走到没有任何的相连点时，则结束现有边缘图的编号，并继续对影像中的其它边缘图编号。走完图 $1$ 所有边缘图后所得到的编号如图 $2$ 所示。所以，走完这三个边缘图所需要的步数分别为 $12$、 $7$ 及 $3$；所以，$12$、$7$ 及 $3$ 可以作为代表此张影像的结构化特征。请注意：位于斜对角上的两点不能算做连接，如：

![](https://cdn.luogu.com.cn/upload/pic/704.png)

请写一个程序计算每个影像中，以 Water-filling 方法走完其中所有的边缘图后，将每个边缘图需走的步数依走访的顺序列出。

## 样例 #1

### 输入

```
10 
0000000000 
0011110000 
0000010000 
0011111000 
0010110100 
0010010110 
0011110010 
0100010010 
0100000110 
0100000000 ```

### 输出

```
3 
3 
7 
12```

# AI分析结果



## 算法分类
**广度优先搜索 BFS**

---

## 综合分析与结论
题目核心是**遍历所有边缘连通块，统计每个块的最大步数**。所有题解均采用 BFS 实现，核心要点包括：
1. **BFS 分层扩展**：模拟 Water-filling 的分叉路径扩展过程
2. **访问标记时机**：入队时立即标记，避免重复访问导致超时
3. **遍历顺序**：按行优先顺序寻找未访问的起点
4. **结果处理**：记录每个连通块的最大步数并排序输出

---

## 精选题解与亮点

### 1. AFOier 的题解（4 星）
**关键亮点**  
- 明确强调**入队时立即标记**避免 TLE  
- 使用数组记录路径长度，直接取队尾值为最大步数  
- 代码中体现行列优先遍历逻辑  

**个人心得引用**  
> "如果不直接在插入队尾时覆盖它的话就会有7个点TLE，只能得到30分。"

**核心代码片段**  
```cpp
while(head < tail) {
    head++;
    pc[x[head]][y[head]] = 1; // 标记已访问
    for(int i=0; i<=3; i++) {
        xx = x[head] + fx[i];
        yy = y[head] + fy[i];
        if(边界检查) continue;
        tail++;
        x[tail] = xx; // 入队时立即标记
        y[tail] = yy;
        pc[xx][yy] = 1;
    }
}
ans[...] = p[x[tail]][y[tail]]; // 取队尾为最大值
```

---

### 2. Emily666 的题解（4 星）
**关键亮点**  
- 使用结构体 `node` 封装坐标，提升可读性  
- 在 BFS 过程中动态更新最大步数  
- 采用标准 STL 容器 vector 存储结果  

**核心实现思想**  
```cpp
int bfs(int x, int y) {
    queue<node> q;
    q.push(node(x,y));
    vis[x][y] = 1;
    int maxx = 1;
    while(!q.empty()) {
        node cur = q.front();
        q.pop();
        for(四个方向) {
            if(可访问) {
                vis[nx][ny] = vis[cur.x][cur.y] + 1; // 步数递增
                maxx = max(maxx, vis[nx][ny]);
                q.push(node(nx, ny));
            }
        }
    }
    return maxx;
}
```

---

### 3. zhengrunzhe 的题解（4 星）
**关键亮点**  
- 使用优先队列自动排序结果  
- 结构体结合队列实现 BFS 状态管理  
- 代码简洁，逻辑高度模块化  

**核心技巧**  
```cpp
priority_queue<int, vector<int>, greater<int>> ans;
// 在 BFS 结束后：
ans.push(nowans); // 自动排序
```

---

## 关键思路总结
1. **立即标记法**：在节点入队时立即标记访问状态，避免重复处理
2. **分层计数**：通过队列长度变化自然实现层次遍历
3. **行列优先扫描**：按 (行→列) 顺序寻找起点，确保遍历顺序正确
4. **极值记录**：在 BFS 过程中动态维护最大值，或直接取队尾值

---

## 拓展建议
类似题目可考察：
1. **多分支路径统计**：如计算分叉次数等附加特征
2. **复杂连通规则**：如允许八方向连通时的处理
3. **动态修改地图**：结合障碍物动态变化的场景

---

## 推荐练习题
1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - BFS 连通块标记
2. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 连通块步数统计
3. [P2298 Mzc和男家丁的游戏](https://www.luogu.com.cn/problem/P2298) - BFS 最短路变形

---
处理用时：57.65秒
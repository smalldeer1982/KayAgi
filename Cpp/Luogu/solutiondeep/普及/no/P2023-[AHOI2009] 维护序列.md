# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果



### 算法分类
线段树

### 题目分析
本题要求维护数列的区间乘、区间加和区间求和操作，是典型的线段树双标记处理问题。核心难点在于同时处理乘法和加法标记时的下传顺序与计算逻辑，需保证乘法优先于加法处理，避免顺序错误导致的计算偏差。

---

### 精选题解

#### 1. **MashPlant（4星）**
**关键亮点**：使用zkw线段树（非递归式）实现，代码效率极高。通过位运算优化节点访问，标记下传逻辑清晰。  
**代码核心**：
```cpp
void pushdown(int p,int len){
    if(add[p]||mul[p]!=1){
        sum[p<<1] = (sum[p<<1]*mul[p] + add[p]*(len-(len>>1)))%MOD;
        sum[p<<1|1] = (sum[p<<1|1]*mul[p] + add[p]*(len>>1))%MOD;
        add[p<<1] = (add[p<<1]*mul[p] + add[p])%MOD;
        add[p<<1|1] = (add[p<<1|1]*mul[p] + add[p])%MOD;
        mul[p<<1] = mul[p<<1]*mul[p]%MOD;
        mul[p<<1|1] = mul[p<<1|1]*mul[p]%MOD;
        add[p]=0; mul[p]=1;
    }
}
```
**核心思想**：标记下传时先处理乘法标记，再叠加加法标记，保证运算顺序正确。

---

#### 2. **GaryZhong（4星）**
**关键亮点**：采用结构体指针的链式存储，便于理解线段树结构。通过分离乘法和加法更新函数，逻辑清晰。  
**代码核心**：
```cpp
void spread(Node *p){
    p->lc->sum = (p->lc->sum * p->mul + p->add * (p->lc->r - p->lc->l + 1)) % MOD;
    p->rc->sum = (p->rc->sum * p->mul + p->add * (p->rc->r - p->rc->l + 1)) % MOD;
    p->lc->mul = p->lc->mul * p->mul % MOD;
    p->rc->mul = p->rc->mul * p->mul % MOD;
    p->lc->add = (p->lc->add * p->mul + p->add) % MOD;
    p->rc->add = (p->rc->add * p->mul + p->add) % MOD;
    p->mul = 1; p->add = 0;
}
```
**核心思想**：通过结构体封装节点信息，代码可读性强，便于维护复杂标记关系。

---

#### 3. **YuntianZhao（4星）**
**关键亮点**：详细注释标记处理过程，强调运算优先级。通过独立函数处理乘法和加法更新，逻辑分离明确。  
**代码核心**：
```cpp
void pushdown(Node *p, int len){
    if(p->mul != 1 || p->add != 0){
        p->lc->sum = (p->lc->sum * p->mul + p->add * (len - len/2)) % MOD;
        p->rc->sum = (p->rc->sum * p->mul + p->add * (len/2)) % MOD;
        p->lc->mul = (p->lc->mul * p->mul) % MOD;
        p->rc->mul = (p->rc->mul * p->mul) % MOD;
        p->lc->add = (p->lc->add * p->mul + p->add) % MOD;
        p->rc->add = (p->rc->add * p->mul + p->add) % MOD;
        p->mul = 1; p->add = 0;
    }
}
```
**核心思想**：通过数学公式推导标记下传的正确性，注释清晰，适合学习底层原理。

---

### 关键技巧总结
1. **标记处理顺序**：乘法标记优先于加法标记，下传时先更新乘法相关值，再叠加加法。
2. **模运算优化**：每一步运算后立即取模，避免溢出。例如：`sum = (sum * mul + add * len) % MOD`。
3. **结构设计**：封装节点属性（sum、mul、add）提高可维护性，递归与非递归实现根据场景选择。

### 拓展应用
- **类似题目**：区间加乘求和的变种（如P3373），区间覆盖与加法的混合操作（如CF52C）。
- **算法延伸**：树状数组处理区间操作（需差分技巧），分块处理大数据量（如LOJ数列分块）。

### 推荐习题
1. [P3373 线段树2](https://www.luogu.com.cn/problem/P3373)  
2. [P1438 无聊的数列](https://www.luogu.com.cn/problem/P1438)（差分+线段树）  
3. [P1253 扶苏的问题](https://www.luogu.com.cn/problem/P1253)（区间加乘和区间最值）

---
处理用时：74.40秒
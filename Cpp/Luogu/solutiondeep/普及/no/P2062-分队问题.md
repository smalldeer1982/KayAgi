# 题目信息

# 分队问题

## 题目描述

给定 $n$ 个选手，将他们分成若干只队伍。其中第 $i$ 个选手要求自己所属的队伍的人数大等于 $a_i$ 人。

在满足所有选手的要求的前提下，最大化队伍的总数。

注：每个选手属于且仅属于一支队伍。

## 说明/提示

对于 $20\%$ 的数据，$n \leq 10$。

对于 $40\%$ 的数据，$n \leq 1000$。

对于 $60\%$ 的数据，$n \leq 10000$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$。

## 样例 #1

### 输入

```
5

2

1

2

2

3 

```

### 输出

```
2```

# AI分析结果



### 算法分类
动态规划

### 综合分析与结论
题目核心是**在满足所有人员需求的前提下最大化队伍数**，正确解法需通过动态规划处理贪心无法覆盖的复杂情况。核心思路为：
1. **排序后定义状态**：将数组从小到大排序，保证决策的连续性。
2. **状态转移优化**：维护前缀最大值数组，避免重复计算。

---

### 精选题解与评分
#### 1. henry_y（★★★★★）
**关键亮点**：
- 明确指出了贪心策略的漏洞（如反例`4 2 3 3 3`的正确分组应为1）。
- 定义`f[i]`表示前i个人的最大队伍数，`g[i]`维护前缀最大值，实现O(n)高效转移。
- 代码简洁，包含输入优化与逻辑注释。

**核心代码**：
```cpp
sort(a + 1, a + n + 1);
for (ll i = 1; i <= n; i++) {
    if (i >= a[i]) f[i] = g[i - a[i]] + 1;
    g[i] = max(f[i], g[i - 1]);
}
```

#### 2. Kdlyh（★★★★☆）
**关键亮点**：
- 状态转移方程清晰（`f[i] = max(f[i-1], f[i-a[i]] + 1)`）。
- 代码可读性高，排序后直接处理转移逻辑。

**核心代码**：
```cpp
std::sort(a + 1, a + n + 1);
for (int i = 1; i <= n; i++) {
    if (i >= a[i]) f[i] = max(f[i - 1], f[i - a[i]] + 1);
    else f[i] = f[i - 1];
}
```

---

### 关键思路总结
1. **排序预处理**：将数组从小到大排序，确保后续决策基于有序的约束条件。
2. **动态规划状态设计**：定义`f[i]`为前i人的最大队伍数，转移时若`i >= a[i]`，则可将最后`a[i]`人单独成队。
3. **前缀最大值优化**：通过`g[i] = max(g[i-1], f[i])`避免重复遍历历史状态。

---

### 类似题目推荐
1. [P1049 装箱问题](https://www.luogu.com.cn/problem/P1049) - 动态规划优化空间
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 序列分割与动态规划
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223) - 贪心排序与时间计算

---
处理用时：53.11秒
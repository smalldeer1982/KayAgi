# 题目信息

# 数字对

## 题目描述

对于一个数字对(a, b)，我们可以通过一次操作将其变为新数字对(a+b, b)或(a, a+b)。

给定一正整数n，问最少需要多少次操作可将数字对(1, 1)变为一个数字对，该数字对至少有一个数字为n。


## 说明/提示

样例解释：

(1,1)  →  (1,2)  →  (3,2)  →  (5,2)

对于30%的数据， 1 <= n <= 1000

对于60%的数据， 1 <= n <= 20000

对于100%的数据，1 <= n <= 10^6


## 样例 #1

### 输入

```
5```

### 输出

```
3```

# AI分析结果



### 算法分类
数学（辗转相除法变形）

### 题解分析与结论
**核心思路**：逆向模拟操作过程，将问题转化为类似GCD的计算，利用数学方法高效统计步数。关键技巧是每次用大数减去小数的倍数（类似辗转相除），避免逐次减法。

---

### 高星题解推荐

#### 1. 作者：Lyrics (⭐⭐⭐⭐⭐)
**关键亮点**：
- 逆向思维，从(n, i)倒推至(1,1)，步数计算与GCD过程高度结合。
- 代码简洁，时间复杂度O(n log n)，完美处理1e6数据。
**核心代码**：
```cpp
LL calc(LL a,LL b){
    if (b==1) return a-1;
    if (!b) return inf;
    return a/b + calc(b, a%b);
}
```
**实现思想**：递归计算a/b的商（步数累加），直到b为1或0。边界处理清晰。

---

#### 2. 作者：love_saber (⭐⭐⭐⭐⭐)
**关键亮点**：
- 递归形式极简，直接返回步数总和。
- 利用互质性质剪枝，大幅减少无效枚举。
**核心代码**：
```cpp
int dfs(int a,int b){
    return (a==1||b==1)?a+b-2 : a/b + dfs(b,a%b);
}
```
**实现思想**：当任一数为1时直接计算步数（a+b-2），否则递归分解为更小数值对。

---

#### 3. 作者：Da_un (⭐⭐⭐⭐)
**关键亮点**：
- 详细推导互质条件与辗转相减法的关系。
- 显式处理边界情况，代码可读性强。
**核心代码**：
```cpp
void check(int a,int b,int step){
    if(b==0){
        if(a==1) ans=min(ans,step);
        return;
    }
    if(a<b) swap(a,b);
    check(b, a%b, step + a/b);
}
```
**实现思想**：通过交换保证a≥b，累加商值作为步数，边界条件处理明确。

---

### 关键优化技巧
- **逆向思维**：从目标状态倒推，减少无效分支。
- **数学建模**：将操作转化为数论问题，利用GCD性质快速计算步数。
- **递归剪枝**：仅枚举互质数对，避免冗余计算。

---

### 同类题目推荐
1. [P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)  
   （扩展欧几里得算法应用）
2. [P3951 小凯的疑惑](https://www.luogu.com.cn/problem/P3951)  
   （数论构造与互质性质）
3. [P2568 GCD](https://www.luogu.com.cn/problem/P2568)  
   （枚举技巧与欧拉函数结合）

---

### 题解心得分镜
- **HsKr**：尝试正搜TLE后，意识到"倒推剪枝更高效"，强调逆向思维突破。
- **MC_Launcher**：通过边界条件`if(x==y)`剪枝，避免无效递归路径。
- **Tyw_ei**：指出"最终数对必互质"，将问题与GCD性质直接关联。

---
处理用时：45.41秒
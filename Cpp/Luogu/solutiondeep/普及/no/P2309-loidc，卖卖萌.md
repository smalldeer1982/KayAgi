# 题目信息

# loidc，卖卖萌

## 题目背景

loidc 萌萌哒。

他最近一直在靠卖萌追求他的真爱——vivym，经过几轮攻势后 vivym 酱眼看就要被他所攻略。擅长数据结构的 vivym 决定利用强大的数据结构之力帮助自己逃脱。

## 题目描述

vivym 给了 loidc 一串阿拉伯数字。他将一个数串的每个数字之和定义为该数串的数串和，vivym 要求 loidc 求出数串中有多少个子串的数串和为正数。他想了半天总是解决不好，于是他便将这一棘手的问题交给了编程能力极强的你，他希望你能在 1 s 内解决。不然 vivym 就要闪现过墙幽灵疾步跑掉了。

## 说明/提示

- 对于 $30\%$ 的数据：$n\leq 10^3$；
- 对于 $100\%$ 的数据：$1 \leq n\leq 10^5$。

题目读入的其他变量均介于 $-100\ldots 100$ 之间。

## 样例 #1

### 输入

```
3
8 -9 2
```

### 输出

```
3```

# AI分析结果



**算法分类标签**：分治、前缀和、树状数组

---

### 综合分析与结论
题目核心转化为求前缀和数组的正序对数量。各题解主要采用两种思路：  
1. **分治（归并排序）**：通过归并排序过程中统计正序对数量，时间复杂度 O(n log n)。  
2. **树状数组+离散化**：离散化前缀和后用树状数组动态维护顺序关系，时间复杂度 O(n log n)。  

**关键技巧**：将子串和问题转化为前缀和的顺序关系，利用高效算法统计顺序对。离散化处理是树状数组解法的核心优化。

---

### 精选题解与评分
#### 1. 作者：Otomachi_Una_（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 直接通过归并排序统计正序对，代码简洁高效。  
- 正确处理前缀和初始值（包含 s[0]）。  
**核心代码**：
```cpp
void msort(int l,int r){
    // ... 归并排序框架
    while(p<=mid&&q<=r){
        if(s[p]>=s[q]) t[k++]=s[q++]; 
        else t[k++]=s[p++],ans+=r-q+1; // 统计右侧剩余元素数量
    }
    // ...
}
```

#### 2. 作者：zhengrunzhe（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 树状数组动态维护离散化后的前缀和，避免归并递归栈开销。  
- 离散化压缩值域，适合更大数据范围。  
**核心代码**：
```cpp
for(int p,i=0;i<=n;i++){
    p=lower_bound(sm,sm+tot,sum[i])-sm+1;
    ans+=bit.query(p-1); // 查询比当前值小的数量
    bit.insert(p);       // 插入当前值
}
```

#### 3. 作者：梧桐灯（⭐⭐⭐⭐）
**关键亮点**：  
- 动态开点线段树处理极大值域，避免离散化预处理。  
- 负数偏移技巧（+1e7）简化实现。  
**核心代码**：
```cpp
add(10000001, 1); // 初始 s[0]=0 偏移处理
for(int i=1;i<=n;i++){
    now += x;
    ans += ask(now + 10000000); // 查询严格小于当前值的数量
    add(now + 10000001, 1);     // 插入当前值
}
```

---

### 相似题目推荐
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)（基础逆序对模板）  
2. [P1714 切蛋糕](https://www.luogu.com.cn/problem/P1714)（前缀和+单调队列优化）  
3. [P3138 [USACO16FEB] Load Balancing S](https://www.luogu.com.cn/problem/P3138)（离散化+二维前缀和）  

---

### 题解个人心得摘录
- **Mr_QwQ**提到将前缀和取反后等价于逆序对问题，体现了符号转换的巧妙性。  
- **lmrttx**强调前缀和下标从0开始的重要性（包含空子串情况）。  
- **破忆**在归并排序合并时通过 `ans += mid - i + 1` 统计贡献，直观体现分治优势。

---
处理用时：53.50秒
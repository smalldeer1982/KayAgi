# 题目信息

# loidc，看看海

## 题目背景

loidc喜欢大海。在他放假的时候他经常一个人跑到海边独自玩耍。

在浪花的冲击下，他可以忘记打代码的烦躁，真是惬意极了。


虽然今天是周六，但今天可是11.8号。在早晨放松之余他可不能忘掉OI知识。


## 题目描述

loidc准备带着LOI的队员们考完试后到海边玩耍。所以他想写一个程序让队员们了解在一段时间内海浪的情况。他的命令是这样的x y k输入的，这是要询问在时间[x,y]内海浪高度第k小的单位时刻是那个时刻。

但是在他刚准备打开Dev-pas++ 的时候，loidc发现他的电脑坏掉了。于是一向喜欢偷懒的他就向你求助。他希望你能在1S内完成程序的运行。


当然loidc会提前告诉你所有时段海浪的高度，这点你放心。至于他是如何得到的，这就不得而知了。


## 说明/提示

30%   n<=200   m<=200

100%  n<=4000  m<=4000

海浪高度取值范围1——100000。


## 样例 #1

### 输入

```
5
1 2 3 4 5
3
2 4 2
1 5 1
3 3 1
```

### 输出

```
3
1
3
```

# AI分析结果



**算法分类**：主席树属于可持久化数据结构，但用户提供的分类中无对应标签。根据题目核心为区间第k小查询，暴力解法基于排序，故最相关分类为 **排序**。

---

### 综合分析与结论
题目要求多次查询区间内第k小的时刻，核心难点在于高效处理区间静态数据的排序与查询。题解主要分为两类：
1. **高效数据结构**：主席树通过前缀和思想构建权值线段树，实现O(n log n)预处理+O(log n)查询。
2. **暴力排序+遍历**：预处理全排序后，对每个查询遍历统计符合区间的元素，时间复杂度O(n log n + m n)，但代码简单。

---

### 精选题解与评分
1. **communist的主席树解法（★★★★★）**  
   **关键亮点**：  
   - 使用主席树高效处理区间第k小查询，时间与空间复杂度均为O(n log n)。  
   - 结合离散化优化空间，代码结构清晰。  
   **核心代码**：  
   ```cpp
   // 构建主席树
   void insert(int pre, int cur, int p, int l, int r) {
       if (l == r) { a[cur].v = a[pre].v + 1; return; }
       int m = (l + r) >> 1;
       if (p <= m) { // 左子树新建节点，右子树复用
           a[cur].ls = ++cnt;
           a[cur].rs = a[pre].rs;
           insert(a[pre].ls, a[cur].ls, p, l, m);
       } else { // 右子树新建，左子树复用
           a[cur].rs = ++cnt;
           a[cur].ls = a[pre].ls;
           insert(a[pre].rs, a[cur].rs, p, m+1, r);
       }
       a[cur].v = a[a[cur].ls].v + a[a[cur].rs].v;
   }
   // 查询第k小
   int kth(int x, int y, int k, int l, int r) {
       if (l == r) return l;
       int m = (l + r) >> 1;
       int num = a[a[y].ls].v - a[a[x].ls].v; // 左子树差值
       return num >= k ? kth(a[x].ls, a[y].ls, k, l, m)
                       : kth(a[x].rs, a[y].rs, k - num, m+1, r);
   }
   ```

2. **人生人生的暴力解法（★★★★）**  
   **关键亮点**：  
   - 预处理全排序后直接遍历，代码简洁易懂，适合小数据量。  
   - 利用结构体存储时刻与高度，排序后只需统计区间命中次数。  
   **核心思路**：  
   ```cpp
   struct no { int num, sum; } a[4001]; // num为时刻，sum为高度
   sort(a+1, a+n+1, [](no x, no y){ return x.sum < y.sum; }); // 全排序
   // 查询时遍历统计命中区间
   for (int j=1; j<=n; j++) {
       if (a[j].num在[x,y]内) cnt++;
       if (cnt == k) return a[j].num;
   }
   ```

3. **5k_sync_closer的预处理优化（★★★★）**  
   **关键亮点**：  
   - 预处理排序仅需一次，利用pair默认比较规则优化代码。  
   - 时间复杂度与暴力相同，但代码更简洁。  
   **实现技巧**：  
   ```cpp
   pair<int, int> a[4001]; // first为高度，second为时刻
   sort(a+1, a+n+1); // 直接按first排序
   // 查询时直接遍历已排序数组统计区间命中
   ```

---

### 最优关键思路
**主席树的前缀和思想**：通过可持久化权值线段树维护不同前缀区间的值域分布，查询时通过版本差值快速计算区间统计。该思路可扩展至其他区间统计问题（如区间不同元素数、区间频率统计）。

---

### 拓展与推荐题目
1. **类似知识点题目**：  
   - [P3834 【模板】可持久化线段树 1（主席树）](https://www.luogu.com.cn/problem/P3834)  
   - [P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972)（区间不同元素，可主席树/莫队）  
   - [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)（动态查询，可用splay/treap）  

2. **个人心得摘录**：  
   - *communist*：主席树通过“共用节点”优化空间，强调线段树与平衡树的结合。  
   - *人生人生*：自嘲“太菜”但暴力通过，体现小数据下代码简洁的重要性。  
   - *5k_sync_closer*：利用pair默认排序规则减少代码量，强调STL的灵活使用。

---
处理用时：107.00秒
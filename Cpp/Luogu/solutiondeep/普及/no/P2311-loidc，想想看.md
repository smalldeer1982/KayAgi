# 题目信息

# loidc，想想看

## 题目背景

话说 loidc 现在正在家闲的无聊，这天 loidc 正在观看比赛，他突然很有兴趣想了解一段时间内中国队获得金牌的情况。

## 题目描述

还有一点，loidc 有特殊能力，可以预知未来，他可以准确的猜到中国队在某一个单位时间内获得的金牌数。但是，还有但是！由于工作量太大，再加上猜金牌要费很多的体力，所以他无法准确的计算出一段时间内获得的金牌数最大的单位时间是哪个，就因为这样 loidc 很郁闷。他思索来思索去就想到了你，因为他知道你是个 OIer，所以他对你呵呵一笑就把问题交给你了，loidc 希望你能在 1 s 内得出答案。


## 说明/提示

$30\%$：$n \le 1000$，$m \le 1000$。

$100\%$：$n \le {10}^5$，$m \le {10}^5$。

其他有关输入输出均小于 `maxlongint`。

数据保证 $a_i$ 没有相同的。

## 样例 #1

### 输入

```
5
2 3 4 5 6
5
1 1
1 2
2 3
3 4
4 5
```

### 输出

```
1
2
3
4
5
```

# AI分析结果



### 算法分类
动态规划（ST表/RMQ）

### 综合分析与结论
本题要求高效处理多次区间最值查询，核心在于选择合适的数据结构。线段树、ST表、树状数组均为可行解法，但效率与适用场景不同。ST表（动态规划预处理）为最优解，时间复杂度 O(n log n) 预处理 + O(1) 查询。单调队列解法仅在查询区间严格递增时适用，具有线性时间复杂度。

### 高评分题解推荐

1. **TheSky233（5星） - ST表解法**  
   **关键亮点**：代码简洁高效，利用ST表预处理和映射快速定位最大值下标。  
   **核心代码**：  
   ```cpp
   int query(int l,int r){
       int k=__lg(r-l+1);
       return max(ST[l][k], ST[r-(1<<k)+1][k]);
   }
   ```  
   预处理时通过动态规划构建ST表，查询时直接取对数计算区间覆盖块。

2. **cabasky（4星） - 单调队列解法**  
   **关键亮点**：假设查询区间递增，以O(n+m)时间复杂度高效处理，代码简洁。  
   **核心代码**：  
   ```cpp
   void add(int p){
       while(head<=tail && a[p]>a[line[tail]]) tail--;
       line[++tail] = p;
   }
   ```  
   维护单调递减队列，动态调整窗口范围。  
   **个人心得**：需注意左端点可能跳跃的情况，通过 `j=max(yest+1,x)` 避免遗漏元素。

3. **I_have_been_here（4星） - 线段树解法**  
   **关键亮点**：结构体保存最大值和位置，逻辑清晰，适用于动态数据。  
   **核心代码**：  
   ```cpp
   K query(int i, int l, int r) {
       if (覆盖整个区间) return 当前节点值;
       // 递归比较左右子树结果
       return maxx(左子树查询, 右子树查询);
   }
   ```  
   通过分治递归合并区间结果，灵活处理任意区间查询。

### 最优思路总结
**ST表预处理**是静态区间最值的标准解法，结合动态规划思想实现快速查询。关键技巧在于分块预处理和二进制长度计算，通过预处理每个区间的覆盖块，实现常数时间查询。

### 拓展应用
类似问题可考虑：
- **动态数据**：线段树支持动态更新。
- **滑动窗口最值**：单调队列处理连续区间。
- **多维RMQ**：扩展至二维区间查询。

### 推荐练习
1. [P3865 【模板】ST表](https://www.luogu.com.cn/problem/P3865)  
2. [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)  
3. [P1816 忠诚](https://www.luogu.com.cn/problem/P1816)

---
处理用时：168.61秒
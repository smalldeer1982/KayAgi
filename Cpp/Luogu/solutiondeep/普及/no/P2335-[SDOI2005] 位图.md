# 题目信息

# [SDOI2005] 位图

## 题目描述

现在我们给出一个 $n\ \times m$ 的单色位图，且该图中至少含有一个白色的像素。我们用 $(i,j)$ 来代表第 $i$ 行第 $j$ 列的像素，并且定义两点 $p_1=(i_1,j_1)$ 和 $p_2=(i_2,j_2)$ 之间的距离为：

$$d(p_1,p_2)=|i_1-i_2|+|j_1-j_2|$$

### 任务

请写一个程序，读入该位图，并对于每个像素，计算出离该像素最近的白色像素与它的距离。把结果输出。

## 样例 #1

### 输入

```
3 4
0 0 0 1
0 0 1 1
0 1 1 0```

### 输出

```
3 2 1 0
2 1 0 0
1 0 0 1```

# AI分析结果



### 算法分类
**广度优先搜索 BFS**

### 综合分析与结论
题目要求计算每个像素点到最近白色点的曼哈顿距离，核心是**多源最短路径**问题。各题解主要分为暴力枚举、DFS、BFS、动态规划等思路：
1. **暴力枚举**：遍历每个黑点，计算到所有白点的距离取最小。时间复杂度为 O(nm·k)（k 为白点数），数据较弱时可通过但效率低。
2. **BFS**：将白点作为起点同时进行层次遍历，每个点首次访问时即为最短距离，时间复杂度 O(nm)，最优解。
3. **动态规划**：通过四方向递推多次扫描更新最小值，时间复杂度 O(nm·(n+m))，效率次优但空间复杂度低。

最优解为**多源 BFS**，通过队列按层扩展保证每个点的最短距离首次被计算即确定。

---

### 高分题解推荐
#### 题解1：SIGSEGV（5星）
**关键亮点**：  
- **多源 BFS 标准模板**：初始将所有白点入队，层次遍历更新邻域。
- **访问标记优化**：利用 `dis` 数组同时记录距离和访问状态，避免重复计算。
```cpp
struct node{int x,y;};
queue<node> q;
memset(dis,-1,sizeof(dis)); // 初始化未访问
if(a[i][j]==1) q.push({i,j}), dis[i][j]=0; // 白点入队
while(!q.empty()){
    node u=q.front(); q.pop();
    for(四方向){
        int nx=u.x+dx, ny=u.y+dy;
        if(越界||dis[nx][ny]!=-1) continue;
        dis[nx][ny] = dis[u.x][u.y]+1; // 首次访问即最小
        q.push({nx,ny});
    }
}
```

#### 题解2：_L_h_J_（4星）
**关键亮点**：  
- **动态松弛思想**：允许已处理的点再次入队，确保更优解更新。
- **剪枝优化**：仅当新距离更小时才更新，减少无效计算。
```cpp
while(h<=t){
    for(四方向){
        if(新距离 < 当前记录){
            更新距离并加入队列;
        }
    }
}
```

#### 题解3：lijialin（4星）
**亮点**：  
- **SPFA 思想应用**：队列维护待扩展节点，类似最短路松弛。
- **代码简洁性**：直接通过队列操作实现多源扩展。

---

### 最优思路总结
**多源 BFS 模板**：
1. **初始化**：所有白点距离为 0 并入队，其他点设为无穷大。
2. **层次扩展**：队列中节点按层处理，首次访问时记录最小距离。
3. **剪枝优化**：每个点只需处理一次，无需重复入队。

**代码技巧**：
- 方向数组 `dx[4], dy[4]` 实现四邻域扩展。
- 使用 `dis` 数组同时作为访问标记和距离记录。

---

### 拓展与相似题目
1. **P1162 填涂颜色**（BFS 连通块标记）
2. **P1443 马的遍历**（单源 BFS 最短路径）
3. **P1135 奇怪的电梯**（BFS 状态转移）

---

### 个人心得摘录
- **SIGSEGV**：*"BFS 的特性保证每个点第一次被访问时即为最短距离"*  
  （正确性保障的关键）
- **Great瞿葩**：*"动规需四方向多次扫描，虽然代码略长但思路巧妙"*  
  （动态规划的适用场景分析）
- **asuldb**：*"数据较水暴力也能过，但比赛时应优先考虑 BFS"*  
  （对算法选择的实际考量）

---
处理用时：65.56秒
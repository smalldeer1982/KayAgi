# 题目信息

# [USACO07FEB] Bronze Lilypad Pond B

## 题目描述

为了让奶牛们娱乐和锻炼，农夫约翰建造了一个美丽的池塘。这个长方形的池子被分成了 M 行 N 列个方格（1 ≤ M, N ≤ 30） 。一些格子是坚固得令人惊讶的莲花，还有一些格子是岩石，其余的只是美丽、纯净、湛蓝的水。

贝西正在练习芭蕾舞，她站在一朵莲花上，想跳到另一朵莲花上去，她只能从一朵莲花跳到另一朵莲花上，既不能跳到水里，也不能跳到岩石上。

贝西的舞步很像象棋中的马步：每次总是先横向移动 M1 (1 ≤ M1 ≤ 30)格，再纵向移动 M2 (1 ≤ M2 ≤ 30, M1≠M2)格，或先纵向移动 M1 格，再横向移动 M2 格。最多时，贝西会有八个移动方向可供选择。

给定池塘的布局和贝西的跳跃长度，请计算贝西从起点出发，到达目的地的最小步数，我们保证输入数据中的目的地一定是可达的。


## 样例 #1

### 输入

```
4 5 1 2
1 0 1 0 1
3 0 2 0 4
0 1 2 0 0
0 0 0 1 0```

### 输出

```
2```

# AI分析结果



### 算法分类
广度优先搜索 BFS

### 分析与结论
题目核心是求最短跳跃次数，典型的 BFS 应用场景。所有题解均围绕搜索展开，其中 BFS 解法更高效且符合最短路径特性。DFS 需配合记忆化剪枝才能通过，但存在理论超时风险。核心难点在于正确枚举八个跳跃方向，并通过合理标记避免重复访问。

---

### 优质题解推荐

#### 1. 顾z（4星）
**关键亮点**  
- 使用标准 BFS 模板，代码结构清晰易懂  
- 预计算八个方向的增量数组，逻辑直观  
- 显式处理边界条件，鲁棒性强  
**核心代码**  
```cpp
int dx[] = {m1, m1, -m1, -m1, m2, m2, -m2, -m2};
int dy[] = {m2, -m2, m2, -m2, m1, -m1, m1, -m1};
queue<pair<int, int>> q;
while (!q.empty()) {
    // 遍历8方向并更新队列
}
```

#### 2. AveMarina（4星）
**关键亮点**  
- 在原地图数组直接标记访问状态，省去额外 vis 数组  
- 通过修改地图值实现剪枝，优化空间复杂度  
**核心技巧**  
```cpp
if (map[x][y]) {
    map[x][y] = 0; // 标记为不可访问
    que.push(...);
}
```

#### 3. 维迭生（4星）
**关键亮点**  
- 使用 pair 存储坐标，代码更简洁  
- 分层处理方向增量，逻辑分层清晰  
**代码片段**  
```cpp
dx[0] = m1, dy[0] = m2; // 方向预计算
queue<pair<int, int>> q;
q.push({sx, sy}); // 起点入队
```

---

### 最优思路总结
1. **方向处理**：将八个跳跃方向预存为增量数组，避免重复计算  
2. **队列标记**：使用队列实现层序扩展，天然保证首次到达终点时为最短路径  
3. **空间优化**：利用原地图数组直接标记访问状态，减少内存开销  
4. **剪枝逻辑**：在 DFS 解法中通过记忆化剪枝（如 `f[x][y]` 记录最小步数）避免重复路径  

---

### 相似题目推荐
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)  
   - 同类网格 BFS，马步跳跃方向处理  
2. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)  
   - 抽象化的层序扩展 BFS，按钮跳跃模型  
3. [P1141 迷宫](https://www.luogu.com.cn/problem/P1141)  
   - BFS 连通块处理，记忆化优化实践

---
处理用时：56.41秒
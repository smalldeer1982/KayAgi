# 题目信息

# [AHOI2002] 哈利·波特与魔法石

## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/1681.png)


## 样例 #1

### 输入

```
0 1 0 0 0 0 0
1 4
4
1 2 1
1 3 1
2 4 2
3 4 3```

### 输出

```
5```

# AI分析结果



**算法分类**: 最短路

---

### 综合分析与结论
本题核心在于构建加权图后求最短路。所有题解均围绕最短路算法展开，区别在于：
1. **建图技巧**：需根据地形类型和魔法石状态动态计算边权（基础地形时间/魔法石存在时折半）
2. **算法选择**：Floyd（全源最短路）、Dijkstra（堆优化更高效）、SPFA（队列优化）、DFS+剪枝（非主流但可AC）
3. **实现细节**：双向边处理、距离初始化、起点终点相同特判

---

### 高星题解推荐

#### 1. zjy111（Floyd解法）⭐️⭐️⭐️⭐️
**核心亮点**：
- 完美处理双向边和魔法石条件
- 包含起点终点相同的特判
- 初始化方式规范（用极大值表示断路）
**个人心得**：  
> "第一次提交WA了9号点，因为没有处理x==y的情况"

**代码核心**：
```cpp
// 初始化邻接矩阵
memset(dis,0x3f,sizeof(dis));
// 动态计算边权
if(ck[k]) dis[i][j] = dis[j][i] = s[k]/2; 
// Floyd核心
for(k=1~100) for(i=1~100) for(j=1~100)
    dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);
```

#### 2. 火车司机（Dijkstra堆优化）⭐️⭐️⭐️⭐️
**核心亮点**：
- 使用链式前向星高效存图
- 优先队列实现小根堆优化
- 位运算处理魔法石条件（s[i] >>= read()）

**代码核心**：
```cpp
// 使用位运算处理输入
for(ri i=1;i<=7;i++) s[i] >>= read();
// 优先队列维护最短路
priority_queue<node> q;
q.push({0,S});
while(!q.empty()){
    int u = q.top().second; q.pop();
    if(vis[u]) continue;
    vis[u] = 1;
    for(遍历邻接表) if(dis[v] > dis[u]+w)
        q.push({dis[v],v});
}
```

#### 3. Ricardo_21（DFS+记忆化）⭐️⭐️⭐️
**独特价值**：
- 展示DFS剪枝的可行性
- 记忆化数组避免重复计算
**实现技巧**：
```cpp
int f[110]; // 记忆当前点最小距离
void dfs(int x, int t) {
    if(t > f[x]) return; // 关键剪枝
    f[x] = t;
    for(遍历邻接点) 
        dfs(v, t + 计算后的边权);
}
```

---

### 关键思路总结
1. **边权预处理**：先根据魔法石状态生成修正后的地形时间表
2. **双向边处理**：无向图需正反双向添加边
3. **算法选择原则**：
   - 节点数少（≤100）→ Floyd
   - 边数多/稀疏图 → SPFA
   - 单源最短路 → Dijkstra堆优化
4. **特殊边界处理**：起点终点相同时直接返回0

---

### 相似题目推荐
1. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)  
   - Dijkstra堆优化模板
2. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)  
   - SPFA/Dijkstra基础实现
3. [P1629 邮递员送信](https://www.luogu.com.cn/problem/P1629)  
   - 正反图最短路综合应用

---
处理用时：48.95秒
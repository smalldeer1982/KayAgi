# 题目信息

# 漂亮字串

## 题目描述

Caima认为O和X是最优美的两个字母，由O、X组成的串是最优美的串。在这些最优美的串中，如果任意只包含X的字串，长度不超过maxX，任意只包含O的子串，长度不超过maxO，且整个串最多有countO个O，countX个X。那么这个就是超级优美无敌串。现在Caima想知道最长的超级优美无敌串有多长，希望你告诉他。


## 样例 #1

### 输入

```
10 10 0 0
3 5 1 1```

### 输出

```
0
7```

# AI分析结果



### 分类与总结
- **算法分类**：数学（分类讨论）

### 题解分析与结论
题目核心在于通过数学推导分情况讨论，确定不同约束条件下的最长合法串长度。所有题解均围绕以下三种情况展开：
1. **存在0值**：若某字符不可用（数量或最大长度0），结果由另一字符决定。
2. **资源不足**：当一方数量过多无法被另一方有效分隔时，计算最大可用量。
3. **资源均衡**：其余情况直接取两字符总数之和。

### 优质题解推荐
#### 1. 作者：pengzy (⭐⭐⭐⭐⭐)
- **关键亮点**：逻辑清晰，详细推导每种情况的数学条件，代码可读性强。
- **代码片段**：
  ```cpp
  if((X+1)*B<Y) printf("%lld\n", (X+1)*B+X);
  else if((Y+1)*A<X) printf("%lld\n", (Y+1)*A+Y);
  else printf("%lld\n", X+Y);
  ```
- **核心思想**：通过判断 `(count+1)*对方max` 是否足够分隔，决定是否采用分隔策略。

#### 2. 作者：Water_Cows (⭐⭐⭐⭐)
- **关键亮点**：简洁高效，变量命名合理，涵盖所有边界条件。
- **代码片段**：
  ```cpp
  if(A==0) printf("%lld\n", B);
  else if(B==0) printf("%lld\n", A);
  else if((X+1)*B<Y) printf("%lld\n", (X+1)*B+X);
  ```

#### 3. 作者：issue_is_fw (⭐⭐⭐⭐)
- **关键亮点**：代码精简，直击问题本质，注释明确。
- **代码片段**：
  ```cpp
  else if((shux+1)*maxo<shuo) cout<<(shux+1)*maxo+shux;
  else if((shuo+1)*maxx<shux) cout<<(shuo+1)*maxx+shuo;
  ```

### 关键思路与技巧
1. **数学推导**：通过不等式判断资源是否足够分隔对方字符。
2. **贪心策略**：在资源不足时，优先用满分隔符对应的最大段数。
3. **边界处理**：对0值的特殊处理避免复杂计算。

### 拓展与举一反三
- 类似题目推荐：
  1. [P1620 漂亮字串](https://www.luogu.com.cn/problem/P1620)（双倍经验）
  2. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)（分类处理覆盖问题）
  3. [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995)（贪心+排序）

### 题解心得摘录
- **Water_Cows**提到变量名替换不影响理解，强调代码简洁性。
- **Erica_N_Contina**尝试枚举法，但承认数学方法更优，体现调试中的策略选择。
- **bryce**强调开`long long`的重要性，反映实际编码中的常见陷阱。

---
处理用时：52.30秒
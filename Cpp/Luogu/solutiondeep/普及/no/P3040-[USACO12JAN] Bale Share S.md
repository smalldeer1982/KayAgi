# 题目信息

# [USACO12JAN] Bale Share S

## 题目描述

FJ 有 $n$ 包干草，第 $i$ 干草的重量是 $s_i$，他想尽可能平均地将干草分给三个农场。

他希望分配后的干草重量最大值尽可能地小，比如，$b_1,b_2,b_3$ 是分配后的三个值，假设 $b_1 \ge b_2 \ge b_3$，则他希望 $b_1$ 的值尽可能地小。

请计算 $b_1$ 的最小值。


## 说明/提示

【样例解释】  
一种满足要求的分配方案是：  
农场 1: $2,9,15$，$b_1 = 26$   
农场 2: $4,8,14$，$b_2 = 26$   
农场 3: $5,20$，$b_3 = 25$   

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 20$，$1 \le s_i \le 100$。

## 样例 #1

### 输入

```
8 
14 
2 
5 
15 
8 
9 
20 
4 
```

### 输出

```
26 
```

# AI分析结果



根据题目核心逻辑，最相关的算法分类是：**动态规划**

---

### 综合分析与结论
题目要求将干草分成三组，使最大组的重量最小。由于数据规模较小（n ≤ 20），主流解法采用**动态规划**或**DFS+剪枝**。动态规划通过二维状态记录两组重量，巧妙避免三维空间复杂度；DFS通过排序+剪枝优化搜索效率。最优解法为动态规划，时间复杂度为 O(n·sum²)，sum为总重量。

---

### 高星题解推荐

#### 1. 作者：functionendless（5星）
**关键亮点**  
- **状态设计**：用二维布尔数组 `f[i][j]` 表示前两组重量分别为i和j是否可行，第三组由 `sum-i-j` 推导。
- **逆序更新**：倒序遍历j和k避免重复计算，保证每个干草包只被处理一次。
- **剪枝优化**：从 `sum/3` 开始遍历结果，快速找到最小值。

**核心代码思想**  
```cpp
bool f[1000][1000]; // 状态数组
for (每个干草包tmp) {
    for (j = sum倒序; j >= 0; j--)
        for (k = sum倒序; k >= 0; k--)
            if (f[j][k]) {
                f[j+tmp][k] = 1; // 加入第一组
                f[j][k+tmp] = 1; // 加入第二组
            }
    sum += tmp; // 更新总重量
}
// 遍历所有i≥sum/3，找到最小最大值
```

#### 2. 作者：DiDi123（4星）
**关键亮点**  
- **滚动数组**：用二维数组替代三维，节省空间。
- **代码简洁**：直接维护当前可行状态，最终暴力遍历求最优解。

**核心代码片段**  
```cpp
bool f[MAXN][MAXN]; // 滚动二维数组
for (int i=1; i<=n; i++) {
    cin >> a;
    sum += a;
    for (j = sum倒序; j >= 0; j--)
        for (k = sum倒序; k >= 0; k--)
            if (f[j][k]) {
                f[j+a][k] = 1; // 加入第一组
                f[j][k+a] = 1; // 加入第二组
            }
}
```

#### 3. 作者：Galex（4星）
**关键亮点**  
- **三维DP基础实现**：直观展示状态转移逻辑。
- **答案实时更新**：每次发现可行解立即更新最小值。

---

### 最优思路总结
1. **状态压缩**：将三组分配问题简化为二维状态，通过 `sum-i-j` 推导第三组。
2. **逆序枚举**：避免同一干草包多次计算，确保状态转移正确性。
3. **剪枝遍历**：从 `sum/3` 开始寻找可行解，快速定位最优值。

---

### 拓展与相似题目
1. **P2392** [kkksc03考前临时抱佛脚]：分组求最小时间，类似背包分配。
2. **P1441** [砝码称重]：状态压缩动态规划。
3. **P1284** [三角形牧场]：三边分配求最大面积，动态规划思路相近。

---
处理用时：94.25秒
# 题目信息

# [TJOI2008] 小偷

## 题目背景

一位著名的小偷进入了一个充满宝石的储藏室，这个储藏室是由一连串房间构成的，房间的标号从 $0$ 开始，想进入第 $i$ 个房间就必须从第 $i-1$ 个房间进入，如图：

![](https://cdn.luogu.com.cn/upload/pic/6100.png)


## 题目描述

上图为三个房间的情况，黑色的部分为连通两个房间的门，从左向右的编号分别为 $0,1,2\cdots$。已知当小偷从第 $0$ 个门进入储藏室时，储藏室的计时系统开始计时，每个门都有自己的关闭时间。每个屋里有不同种类的宝石，对于每种宝石，它的价值和小偷拿走它所耗费的时间也是不同的，为了简化问题，我们设想小偷在各个屋子之间走动的时间可以忽略不计，而且所有屋子里各种宝石的数量都是无限多的，那么请问小偷在能成功逃出来的情况下，可能获得宝石的最大价值。

附：对于每扇门，小偷都必须在严格早于此门关闭的时候出来才可以。

## 说明/提示

### 样例解释

虽然在第 $2$ 个房间中价值为 $5$ 的宝石好，但是不如拿两次价值为 $3$ 的宝石，在拿两次第 $0$ 房间中价值为 $1$ 的宝石，总价值为 $8$。

### 数据范围及约定

对于 $100\%$ 的数据，储藏室的屋子数量不超过 $50$，每扇门关闭的时间不超过 $1000$，并且宝石的数量不超过 $100$，价值不超过 $1000$。

## 样例 #1

### 输入

```
3 4
9 5 5
0 1 2
1 2 2
2 3 2
2 5 3
```

### 输出

```
8```

# AI分析结果



**算法分类**: 动态规划

---

### 题解综合分析
所有题解均基于**完全背包**模型，核心思路为：
1. **预处理门关闭时间**：每个房间的实际可用时间取前面所有房间的最小关闭时间
2. **时间维度DP**：将时间作为背包容量，每个宝石的耗时作为物品体积，价值作为收益
3. **滚动数组优化**：使用一维DP数组进行状态转移

---

### 精选题解（评分≥4星）

#### 1. 蒟蒻·巨弱（⭐⭐⭐⭐⭐）
**关键亮点**：
- 最简洁清晰的完全背包实现
- 预处理逻辑直接体现在主循环中
- 完整注释说明时间处理逻辑
**核心代码**：
```cpp
for (i = 1; i < close[0]; i++) { // 枚举时间
    f[i] = f[i-1]; // 不偷宝石
    for (j = 1; j <= m; j++) { // 枚举宝石
        if (close[d[j].room] > i && d[j].t <= i) // 时间有效性验证
            f[i] = max(f[i], f[i-d[j].t] + d[j].val);
    }
}
```

#### 2. GNAQ（⭐⭐⭐⭐）
**关键亮点**：
- 倒序处理房间的优化思路
- 分组处理宝石提升效率
- 包含调试经历：曾误直接输出`dp[背包体积]`
**核心代码**：
```cpp
for (int i = n; i >= 1; i--) { // 倒序处理房间
    for (auto& gem : room_gems[i]) {
        for (int t = gem.cost; t < close_time[i]; t++) 
            dp[t] = max(dp[t], dp[t - gem.cost] + gem.val);
    }
}
```

#### 3. Mobius127（⭐⭐⭐⭐）
**关键亮点**：
- 显式分组存储各房间宝石
- 独立处理每个房间的背包逻辑
- 最终遍历时间维度取最大值
**核心代码**：
```cpp
for (int i = n; i > 0; i--) { // 倒序处理
    for (auto& gem : gems_in_room[i]) {
        for (int t = gem.time; t < close_time[i]; t++) {
            dp[t] = max(dp[t], dp[t - gem.time] + gem.value);
        }
    }
}
```

---

### 关键优化技巧
1. **门关闭时间预处理**：`close[i] = min(close[i], close[i-1])`
2. **一维滚动数组**：通过逆序/正序循环节省空间
3. **时间维度遍历**：以时间而非物品为第一循环主体

---

### 拓展训练
1. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)（依赖背包）
2. [P1941 飞扬的小鸟](https://www.luogu.com.cn/problem/P1941)（多重背包+滚动优化） 
3. [P1853 投资的最大效益](https://www.luogu.com.cn/problem/P1853)（完全背包变式）

---

### 题解心得摘录
- **GNAQ**："注意要遍历最终时间轴取最大值，而非直接取`dp[close_time[0]]`"
- **Anita_Hailey**："调试时发现必须传递`dp[i][j-1]`状态，因为存在不拿宝石的决策"
- **lytqwq**："倒序处理房间更符合物理移动逻辑，避免后效性问题"

---
处理用时：56.57秒
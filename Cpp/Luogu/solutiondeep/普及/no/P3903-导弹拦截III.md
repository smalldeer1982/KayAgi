# 题目信息

# 导弹拦截III

## 题目描述

很多年以前，A 国发明了一种导弹系统用来拦截敌对势力发射的导弹。

这个系统可以发射一颗导弹拦截从由到远、高度不增加的多个导弹。

但是现在，科学家们发现这个防御系统还不够强大，所以他们发明了另外一套导弹系统。

这个新系统可以发射一颗导弹由近到远的拦截更多的导弹。

当这个系统启动，首先选择一颗敌人的导弹进行拦截，然后拦截一颗更远的高度更低的导弹进行拦截，然后拦截比第二颗更远的但高度更高的导弹……以此类推，拦截的第奇数颗导弹比前一颗导弹更远、更高，拦截的第偶数颗导弹比前一个更远、更低。

现在，给你一个从近到远的导弹高度列表，计算新系统发射一颗导弹可以拦截的最多的导弹数目。

## 说明/提示

$1\leq n\leq 10^3$，$1\leq $ 导弹高度 $\leq 10^9$。

## 样例 #1

### 输入

```
4
5 3 2 4```

### 输出

```
3```

# AI分析结果



### 算法分类：动态规划

### 题解综合分析
题目要求最长的交替上升下降序列（震荡序列），核心在于维护奇偶位置的不同比较规则。动态规划解法通过二维状态表示当前处于上升/下降阶段的最优解，而贪心解法通过统计峰谷点数量直接推导结果。动态规划解法更普适，贪心解法更高效但需要严格证明。

### 精选题解

#### 1. 作者：gaowеnxuan（4星）
**关键亮点**：  
- 清晰定义二维DP状态，`dp[i][0]`和`dp[i][1]`分别表示以第i个导弹结尾的下降/上升状态最大长度  
- 状态转移逻辑直观，通过遍历前序节点更新最优解  
- 代码结构简洁，初始化与转移逻辑明确  

**核心代码**：  
```cpp
for(int i=2;i<=n;i++) {
    dp[i][1]=1;
    for(int j=1;j<i;j++) {
        if(a[j]<a[i]) dp[i][1]=max(dp[i][1],dp[j][0]+1);
        if(a[j]>a[i]) dp[i][0]=max(dp[i][0],dp[j][1]+1);
    }
    ans=max(ans,max(dp[i][1],dp[i][0]));
}
```

#### 2. 作者：Weng_Weijie（4星）
**关键亮点**：  
- 贪心思路巧妙，通过统计峰谷点数量直接得出答案  
- 时间复杂度O(n)，远优于DP的O(n²)  
- 代码极简，通过异或运算快速判断状态变化  

**核心代码**：  
```cpp
int flag = 0, now, last, n, ans = 1;
while (--n) {
    last = now;
    scanf("%d", &now);
    if (now == last) continue;
    if (flag ^ (now < last)) 
        ans++, flag = now < last;
}
```

### 关键思路总结
1. **动态规划双状态法**：维护两个状态数组，分别记录当前节点作为上升/下降段时的最大长度，通过遍历前序节点进行状态转移。
2. **贪心峰谷统计法**：交替统计上升和下降的转折点，峰谷点的数量之和即为最长序列长度，需注意初始状态的处理。

### 扩展与同类题
- **同类型题**：震荡序列（如P1970 花匠）、最长交替子序列变形问题  
- **优化技巧**：贪心法可优化时间复杂度到O(n)，适用于更大数据规模  
- **思维模式**：动态规划通过状态分解解决复杂条件限制，贪心通过局部最优推导全局最优  

### 推荐练习题
1. [P1970 花匠](https://www.luogu.com.cn/problem/P1970)（NOIP2013 提高组，震荡序列）  
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)（双向LIS问题）  
3. [P2697 宝石串](https://www.luogu.com.cn/problem/P2697)（交替序列计数问题）  

### 题解心得摘录
- **Weng_Weijie**：注意初始状态必须为下降，若初始为递增序列则答案需减一  
- **万弘**：发现原DP未考虑第二发必须往低打，修改状态转移条件后AC  
- **于伟无关**：贪心策略通过不断替换当前最优选择来最大化拦截次数，类似跳跃游戏思路

---
处理用时：144.05秒
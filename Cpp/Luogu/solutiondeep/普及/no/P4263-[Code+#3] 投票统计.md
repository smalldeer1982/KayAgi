# 题目信息

# [Code+#3] 投票统计

## 题目描述

为了总结过去一段时间的命题工作，王队长组织了“我最喜欢的题目”评选活动，并邀请各位选手给题目进行投票。

具体来说，每道题目有一个正整数作为它的编号，一共有 $n$ 名选手给它们进行投票，每位选手投且仅投给一道题，其中第 $i$ 位选手所投票的题目编号为 $a_i$。

由于投票的选手众多，所以王队长请你来帮忙统计得票数。你需要找出收获选手投票最多的**题目数量**与**他们的编号**，并按**从小到大**的顺序列出这些编号。但这里有一个**例外情况**：如果所有被投票的题目得票数都相同，则王队长认为这次活动比较失败，你应该**输出-1**。



## 说明/提示

测试点编号|$n$的范围|$a_i$的范围|特殊约定
-|-|-|-
1|$=2000$|$\leq n$|得票数最多的题目唯一
2|同上|同上|同上
3|同上|$\leq 10^9$|同上
4|同上|$\leq n$|不会出现例外情况
5|同上|同上|同上
6|同上|$\leq 10^9$|同上
7|同上|$\leq n$|无
8|同上|同上|同上
9|同上|$\leq 10^9$|同上
10|同上|同上|同上
11|$=100000$|$\leq n$|得票数最多的题目唯一
12|同上|同上|同上
13|同上|$\leq 10^9$|同上
14|同上|$\leq n$|不会出现例外情况
15|同上|同上|同上
16|同上|$\leq 10^9$|同上
17|同上|$\leq n$|无
18|同上|同上|同上
19|同上|$\leq 10^9$|同上
20|同上|同上|同上

Credit： https://www.luogu.org/discuss/show?postid=35727

## 样例 #1

### 输入

```
3
10
2 6 1 2 1 1 2 6 7 1
10
10 3 6 6 3 10 6 6 6 2
10
8 8 10 10 10 10 8 5 8 8```

### 输出

```
1
1
1
6
1
8```

## 样例 #2

### 输入

```
3
10
1 4 3 1 8 8 7 2 8 7
10
1 10 9 1 3 2 9 9 2 1
10
4 1 5 4 1 9 5 5 4 1```

### 输出

```
1
8
2
1 9
3
1 4 5```

## 样例 #3

### 输入

```
3
10
3 3 10 8 8 3 10 8 10 3
10
2 2 8 6 8 4 2 4 4 8
10
6 2 5 6 7 5 7 10 2 10```

### 输出

```
1
3
3
2 4 8
-1
```

# AI分析结果



### 算法分类
排序

---

### 综合分析与结论
题目要求统计出现次数最多的数字集合，核心难点在于高效处理大范围数值和判断全同频情况。各题解均采用排序或哈希两种思路：  
1. **排序法**（Kalium、Chouquet、Khassar）：通过排序将相同元素聚拢，线性扫描统计频率，时间复杂度稳定在 O(n log n)。  
2. **哈希法**（金苹果gold、Eason_AC）：使用 map 统计频率，代码更简洁但常数较大。最优解为排序法，其空间利用更优且适合大数据。

---

### 精选题解与评分
#### 1. Kalium（4星）
**亮点**：单次遍历同时统计频率、最大值及不同值数量，逻辑紧凑。  
**代码核心**：
```cpp
sort(a + 1, a + 1 + n);
for (int i = 2; i <= n + 1; i++) {
    if (a[i] == a[i-1]) sum++;
    else {
        keep(sum, a[i-1]); // 维护最大值列表
        sum = 1;
        different++;
    }
}
if (cnt == different) printf("-1\n"); // 判断全同频
```

#### 2. 金苹果gold（4星）
**亮点**：利用 map 简化统计逻辑，代码直观易实现。  
**关键实现**：
```cpp
map<long long, long long> m;
for (int i=1; i<=n; i++) {
    cin >> tmp;
    m[tmp]++; // 哈希统计频率
    if (m[tmp] == 1) had[++cnt] = tmp; // 记录唯一键值
}
```

#### 3. Khassar（4星）
**亮点**：两次遍历分离统计与收集，逻辑清晰。  
**核心片段**：
```cpp
sort(a + 1, a + n + 1);
for (int i=2; i<=n+1; i++) {
    if (a[i] != a[i-1]) {
        if (sum > maxn) maxn = sum; // 第一次找最大值
        sum = 1;
    } else sum++;
}
for (int i=2; i<=n+1; i++) {
    if (a[i] != a[i-1]) {
        if (sum == maxn) ans.push_back(a[i-1]); // 第二次收集结果
        sum = 1;
    } else sum++;
}
```

---

### 关键思路总结
1. **排序后线性扫描**：通过排序将相同元素聚拢，只需 O(n) 时间统计频率。  
2. **最大值动态维护**：遍历时实时更新最大频率对应的元素集合。  
3. **全同频特判**：通过比较最大值数量与总不同元素数判断是否输出 -1。

---

### 拓展建议
类似问题可考虑以下技巧：  
- 大范围离散值优先排序而非哈希  
- 多组数据时注意容器重置  
- 利用哨兵节点简化边界处理

---

### 推荐习题
1. [P1097 统计数字](https://www.luogu.com.cn/problem/P1097)  
2. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)  
3. [P1781 宇宙总统](https://www.luogu.com.cn/problem/P1781)

---
处理用时：60.15秒
# 题目信息

# [CERC2014] Wheels

## 题目描述

一个非常重要和复杂的机器由$n$个轮子组成，编号为$1,2,…,n$。它们其实是齿轮，但是齿太小了，我们可以把它们近似看成成平面上的圆。



每一个齿轮都能围绕它的中心旋转。



两个齿轮不会重叠（因为它们内部没有共同的点），但它们可以互相接触。



如果两个齿轮相互接触，其中一个齿轮转动，另一个齿轮也随之转动，因为它们的齿被卡在一起。



一个力作用于齿轮1（并且力没有作用于其他齿轮），使它以每分钟转一圈的速度顺时针旋转。计算其他齿轮的运动速度。你可以假设机器没有卡住（运动在物理理论上是可以的）。

## 样例 #1

### 输入

```
1
5
0 0 6
6 8 4
-9 0 3
6 16 4
0 -11 4
```

### 输出

```
1 clockwise
3/2 counterclockwise
2 counterclockwise
3/2 clockwise
not moving```

# AI分析结果



**算法分类**: 广度优先搜索 BFS

---

### 综合分析与结论
题目核心是模拟齿轮间的传动关系，利用BFS逐层处理相邻齿轮。关键点包括：
1. **接触判断**：两齿轮圆心距离等于半径之和
2. **速度计算**：半径比决定转速（反比关系）
3. **方向交替**：相邻齿轮转动方向相反
4. **分数化简**：用最大公约数约分速度表达式

---

### 精选题解及评分

#### 1. HRLYB（★★★★☆）
**关键亮点**：
- 使用手写队列避免STL潜在问题
- 严格处理溢出（距离平方用long long）
- 详细注释说明方向交替逻辑
**个人心得**：
> "没写队列初始化T了好多次" —— 强调初始化的重要性

**核心代码**：
```cpp
// 齿轮接触判断（距离平方比较）
(long long)((p[i].x-p[x].x)*(p[i].x-p[x].x)+(p[i].y-p[x].y)*(p[i].y-p[x].y)) 
== (long long)(p[i].r+p[x].r)*(p[i].r+p[x].r)

// 速度计算与约分
lef[i] = lef[x] * p[x].r;
righ[i] = righ[x] * p[i].r;
int g = gcd(lef[i], righ[i]);
lef[i] /= g; righ[i] /= g;
```

#### 2. _Goodnight（★★★☆☆）
**核心思路**：
- 使用结构体存储转速和方向
- 通过队列实现BFS传播
- 单独封装分数化简函数

**优化空间**：
- 未处理大数运算的溢出风险
- 方向判断逻辑未明确注释

---

### 最优关键技巧
1. **分层传播**：使用BFS保证传动顺序的正确性
2. **防溢出处理**：距离平方计算时使用`long long`
3. **方向标记法**：用奇偶层数或布尔值实现方向交替
4. **分数存储**：分子分母分开存储并实时约分

---

### 拓展建议
同类问题可考虑：
- 链式反应传播问题（如P1038 神经网络）
- 带比例关系的层次遍历（如P1351 联合权值）
- 物理模拟中的接触判断（如P1125 笨小猴）

---

### 推荐习题
1. [P1038 - 神经网络](https://www.luogu.com.cn/problem/P1038)（BFS层次传播）
2. [P1351 - 联合权值](https://www.luogu.com.cn/problem/P1351)（树形结构遍历）
3. [P2471 - 齿轮](https://www.luogu.com.cn/problem/P2471)（同类齿轮传动问题）

---
处理用时：43.99秒
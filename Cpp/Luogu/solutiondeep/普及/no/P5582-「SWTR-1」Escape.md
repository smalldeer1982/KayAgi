# 题目信息

# 「SWTR-1」Escape

## 题目背景

有一天，当 $\mathrm{Sunny}$ 闲逛的时候，发现了一个按钮。

好奇心驱使他按下了这个按钮。

突然间，天旋地转 $\dots$

## 题目描述

醒来之后，$\mathrm{Sunny}$ 发现自己站在一个奇怪的地方。

这个地方有 $n$ 个平台，**形成了一个环**。

这时，$\mathrm{Ethan}$ 的声音响起：

“哈哈哈哈哈哈，恭喜你，你是第一个来到**死亡之地**的人。”

“正如你所看到的，这个地方有 $n$ 个平台，你现在站在 $0$ 号平台上。”

“剩余平台按顺时针编号 $1,2,3\dots n-1$，也就是说，你身后的那个平台就是 $n-1$ 号平台。”

“你每次能够**顺时针**跳 $i$ 个平台，$i\in[1,n]$，每次的 $i$ 可以不一样。”

“如果你能够经过所有平台（初始 $0$ 号位置不算），那你就能逃出**死亡之地**了。”

（这里指的是一开始的 $0$ 号位置不算经过，需要再次经过 $0$ 号位置）

“不过，这样太简单了，我会给你一些数 $a_j$，表示你**不能一次顺时针跳 $a_j$ 个平台**。”

“还有，你必须要用**最少**的跳跃次数完成我的任务。”

“如果你不能满足我的上面两个要求，所有平台就会消失，你将会掉入下面的岩浆之中。”

现在，$\mathrm{Sunny}$ 想知道他是否可能逃出这个地方。

如果不行，输出```-1```，否则输出他最少所需的跳跃次数。

因为 $\mathrm{Sunny}$ 觉得死亡之地实在是太有趣了，所以他决定多玩几次，**多组数据**。

## 说明/提示

---

### 样例说明

第一组数据：

$\mathrm{Sunny}$ 每次只能顺时针跳 $5$ 个平台，易知不可能完成。

第二组数据：

$\mathrm{Sunny}$ 每次只能顺时针跳 $3$ 个平台，跳 $5$ 次即可。

---

### 数据范围与约定

$0\leq k\leq n\leq 10^6,1\leq n$。

保证 $\sum{n_i}\leq 3*10^6,a_j\leq n$，且**互不相同**。

测试点 $1:5\%,n=1$。

测试点 $2:5\%,n\leq5$。

测试点 $3:10\%,n\leq15$。

测试点 $4:15\%,n\leq300$。

测试点 $5:25\%,n\leq5000$。

测试点 $6:40\%,n\leq10^6$。

---

梦醒了……

## 样例 #1

### 输入

```
3
5 4
1 2 3 4
5 4
1 2 4 5
6 3
1 3 5```

### 输出

```
-1
5
-1```

# AI分析结果



**算法分类**：数学

---

### 综合分析与结论
题目要求通过跳跃覆盖环形平台，核心在于判断所有允许跳跃步数与平台数 \( n \) 的**最大公约数（GCD）**是否为 1。若为 1 则有解且最少步数为 \( n \)，否则无解。难点在于理解 GCD 条件的充要性，以及处理 \( n=1 \) 的特殊情况。

---

### 高星题解推荐
1. **Alex_Wei（5星）**  
   **关键亮点**：  
   - 详细证明 GCD 条件的正确性，结合裴蜀定理和模运算性质解释。  
   - 高效处理 \( n=1 \) 的特殊情况，代码通过标记数组优化 GCD 计算。  
   - 代码清晰，包含关键注释和输入输出优化。  

   **核心代码**：  
   ```cpp
   int d = n;
   for (int i = 1; i <= n; i++) {
       if (!pd[i]) d = gcd(d, i); // 计算所有可行步数与 n 的 GCD
   }
   if (d == 1) cout << n << endl; // 判断条件
   ```

2. **Believe_R_（4星）**  
   **关键亮点**：  
   - 简洁推导公式 \( \gcd(f_1, f_2, \dots, f_n, n) = 1 \)。  
   - 代码使用 `__gcd` 函数简化实现，但未详细展开证明。  

3. **Tomwsc（4星）**  
   **关键亮点**：  
   - 明确结论式代码实现，直接遍历可行步数求 GCD。  
   - 处理 \( n=1 \) 的特殊逻辑，但代码中未完全清空标记数组。  

---

### 最优关键思路
**数论思维**：  
- **GCD 充要条件**：若所有允许跳跃步数和 \( n \) 的 GCD 为 1，则存在覆盖所有平台的跳跃序列（裴蜀定理推论）。  
- **线性组合覆盖**：跳跃步数的线性组合在模 \( n \) 意义下可覆盖所有余数（类似环状覆盖问题）。  

**实现技巧**：  
- 使用标记数组快速筛选允许的跳跃步数。  
- 动态更新 GCD 避免重复计算。  

---

### 拓展与相似题目
1. **P1072 [NOIP2009 提高组] Hankson 的趣味题**（GCD 性质应用）  
2. **P1516 [NOIP2012 提高组] 青蛙的约会**（线性同余方程与裴蜀定理）  
3. **P3951 [NOIP2017 提高组] 小凯的疑惑**（数论构造与不可表数）  

---

### 个人心得摘录
- **Alex_Wei**：强调结论的严格证明，通过分解 \( \gcd \) 的递推过程解释覆盖性，避免“想当然”错误。  
- **backkom**：通过逐步分析 \( \gcd \) 更新过程，理解其与线性组合的关系，形成直觉。  
- **Genius_Star**：从群论角度解释跳跃生成的子群，深化对模运算覆盖性的理解。  

---

**核心代码片段（Alex_Wei）**：
```cpp
int main() {
    scanf("%d", &t);
    while (t--) {
        int n, k, d = n;
        // ... 输入处理与标记数组初始化
        for (int i = 1; i <= n; i++) {
            if (!pd[i]) d = gcd(d, i); // 关键：动态计算 GCD
        }
        if (d == 1) printf("%d\n", n); // 输出结果
        // ... 清除标记数组
    }
}
```

---
处理用时：44.49秒
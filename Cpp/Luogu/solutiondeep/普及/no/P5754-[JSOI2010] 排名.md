# 题目信息

# [JSOI2010] 排名

## 题目背景

在植树节那天，小 L，小 H，小 X 却要面对繁忙的考试。

考完后，按照惯例，他们讨论起了成绩。小 L 非常八卦，他向全班 $N$ 个同学问了他们的成绩情况。当然，就如你想象的那样，每个人也不愿意透露太多信息，每个人值说了他的分数比哪一个同学低，也有些人没说任何信息。

勤奋的小 H 和爱偷懒的小 X 对于班上所有同学的成绩排名都有一个“心理期望”，也就是说，小 H 可能认为 XX 会排第 $1$，YY 会排第 $2$……但小 X 却会认为 XX 应该排最后 $1$ 名，YY 会排倒数第 $2$ 名。

不过理想和现实总是有差距的，通过小 L 打探到的情报， XX 不能排在第 $1$ 了，但是，小 H 仍然觉得 XX 应该排在尽可能前。

小 L 由此想到了一个问题，他想知道小 H 和小 X 知道他打探到的情报之后，对班上同学的心里排名是什么样的。

每个同学的编号即为小 H 的心理排名，也就是说，小 H 希望编号越靠前的同学排名也尽量靠前，而小 X 希望希望编号越靠前的同学排名尽量靠后。（注意不是越后面的同学排名越靠前）

## 题目描述

给定一个长度为 $N$ 的数列 $A$，其中 $A_i$ 表示第 $i$ 个同学的分数比第 $A_i$ 个同学的分数低（或者说，第 $i$ 个同学的排名在第 $A_i$ 个同学之后）。当然，$A_i$ 有可能等于 $0$，则表明没有关于第 $i$ 个同学的信息。

你需要得到一个长度为 $N$ 的数列 $H$，表示班上同学的排名。这个排名要求是满足所有 $A_i$ 构成的约束的排名中字典序最小的哪一个。

同时，你还需要得到一个数列 $X$，表示班上同学的排名。这个排名要求是满足所有 $A_i$ 构成的约束的排名中字典序最大的哪一个。

## 说明/提示

### 样例解释

共有 $3$ 种排名满足大小关系：

```plain
4 1 3 2
4 1 2 3
3 1 2 4
```

其中，`3 1 2 4` 字典序最小，`4 1 3 2` 字典序最大。

### 数据范围

对于 $10\%$ 的数据，$N\leq 10$。

对于 $20\%$ 的数据，$N\leq 20$。

对于 $40\%$ 的数据，$N\leq 2\times 10^3$。

对于 $100\%$ 的数据，$1 \leq N\leq 2\times 10^5,A_i\leq N$。其中，第 $5$ 组数据保证 $N=1.2\times 10^4$。

## 样例 #1

### 输入

```
4
3 0 2 2```

### 输出

```
3 1 2 4
4 1 3 2```

# AI分析结果



**算法分类**  
图论（拓扑排序、贪心策略）

---

**题解综合分析**  
本题需构造满足约束条件的排名序列，核心在于拓扑排序的贪心策略差异：  
- **字典序最小（H序列）**：需确保编号小的节点尽可能靠前。常规拓扑用小根堆，但本题需优先处理父节点链，递归或反向拓扑选最大节点确保字典序最优。  
- **字典序最大（X序列）**：使用大根堆处理拓扑序，每次选最大节点，迫使小编号节点延后。

---

**精选题解与评分**  

1. **作者：hepp**（⭐⭐⭐⭐）  
   **关键亮点**：  
   - **递归处理父节点链**：通过递归确保父节点优先处理，子节点排名基于父节点+1，自然满足约束。  
   - **大根堆反向处理**：X序列用大根堆按层扩展，优先选最大节点，巧妙实现小编号后置。  
   **核心代码**：  
   ```cpp
   // H序列：递归计算父节点链
   int pm(int x) {
       if (ans[x] != -1) return cur;
       return ans[x] = pm(a[x]) + 1; // 父节点处理完后计算当前排名
   }
   // X序列：大根堆扩展
   priority_queue<int> q;
   q.push(0); // 根节点开始
   while (!q.empty()) {
       int u = q.top(); q.pop();
       cnt[u] = cur++; // 记录排名
       for (int v : g[u]) q.push(v); // 子节点加入队列
   }
   ```

2. **作者：LiYomi**（⭐⭐⭐⭐）  
   **关键亮点**：  
   - **DFS预处理最小可达编号**：通过DFS动态规划维护每个节点的最小可达编号，优先队列按此排序，确保小编号优先处理。  
   **个人心得**：  
   - 调试中发现DFS需在优先队列插入前完成，否则排序依据错误，强调预处理顺序的重要性。  
   **核心代码**：  
   ```cpp
   int dp[N];
   int dfs(int x) {
       for (int v : edges[x]) dp[x] = min(dp[x], dfs(v));
       return dp[x];
   }
   // 优先队列按最小可达编号排序
   priority_queue<int, vector<int>, decltype(&cmp)> q(cmp);
   ```

---

**最优关键思路**  
- **H序列**：递归处理父节点链或反向拓扑选最大节点，确保父节点优先处理，子节点排名紧随其后。  
- **X序列**：大根堆维护拓扑序，每次选最大节点扩展，迫使小编号延后。  

---

**拓展建议**  
- **类似题型**：拓扑排序的字典序问题（如[P3243 [HNOI2015]菜肴制作](https://www.luogu.com.cn/problem/P3243)）。  
- **优化技巧**：预处理父节点链可转化为动态规划，减少重复计算；大根堆反向处理是字典序贪心的经典技巧。  

---

**推荐题目**  
1. [P3243 [HNOI2015]菜肴制作](https://www.luogu.com.cn/problem/P3243)（拓扑排序+贪心）  
2. [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)（拓扑排序+动态规划）  
3. [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)（拓扑排序+约束建模）

---
处理用时：125.87秒
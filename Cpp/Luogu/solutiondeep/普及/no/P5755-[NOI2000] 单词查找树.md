# 题目信息

# [NOI2000] 单词查找树

## 题目描述

在进行文法分析的时候，通常需要检测一个单词是否在我们的单词列表里。为了提高查找和定位的速度，通常都要画出与单词列表所对应的单词查找树，其特点如下：
-	根节点不包含字母，除根节点外每一个节点都仅包含一个大写英文字母；
-	从根节点到某一节点，路径上经过的字母依次连起来所构成的字母序列，称为该节点对应的单词。单词列表中的每个词，都是该单词查找树某个节点所对应的单词；
-	在满足上述条件下，该单词查找树的节点数最少。


例：图一的单词列表对应图二的单词查找树


![](https://cdn.luogu.com.cn/upload/image_hosting/zolscsb0.png)

对一个确定的单词列表，请统计对应的单词查找树的节点数（包括根节点）


## 样例 #1

### 输入

```
A
AN
ASP
AS
ASC
ASCII
BAS
BASIC
```

### 输出

```
13
```

# AI分析结果



### 算法分类
**字符串**（或贪心，核心思路基于排序后贪心计算公共前缀）

---

### 题解分析与结论
本题核心是计算字典树的最小节点数。最优解法分为两类：  
1. **字典树直接构建**：通过动态维护节点计数，复杂度与总字符数相关。  
2. **排序后差异计算**：排序后相邻单词的公共前缀最大化，累加差异即为节点数。  

两种方法均高效，但前者直观，后者空间更优。关键技巧在于**排序优化公共前缀计算**或**字典树节点复用**。

---

### 精选题解（评分≥4）

#### 1. 一只书虫仔（5星）
**亮点**：排序后差异计算，代码简洁高效。  
**核心思路**：排序后相邻单词比较公共前缀，累加差值。  
**代码要点**：
```cpp
sort(s + 1, s + len + 1); // 排序是关键
for (int i = 2; i <= len; i++) {
    int tmp = 0;
    while (s[i][tmp] == s[i-1][tmp] && tmp < s[i-1].length()) 
        tmp++; // 计算公共前缀
    length += s[i].length() - tmp; // 累加差异
}
printf("%d", ++length); // 包含根节点
```

#### 2. Alex_Wei（5星）
**亮点**：标准字典树实现，代码简洁。  
**核心思路**：逐字符插入字典树，动态统计节点数。  
**代码要点**：
```cpp
int q[1<<15][26], cnt; // 字典树节点存储
while (cin >> s) {
    int pos = 0;
    for (char ch : s) {
        if (!q[pos][ch-'A']) q[pos][ch-'A'] = ++cnt;
        pos = q[pos][ch-'A']; // 插入字符并计数
    }
}
cout << cnt + 1; // 根节点+1
```

#### 3. MY（4星）
**亮点**：详细解释排序必要性，强调根节点处理。  
**心得**：“第一个单词直接加长度”是易错点，需注意边界处理。

---

### 关键优化与技巧
- **排序预处理**：保证相邻单词具有最长公共前缀，减少重复节点。  
- **字典树动态扩展**：仅维护必要分支，避免全字母存储。  
- **根节点计数**：所有题解均需显式+1，易遗漏。

---

### 拓展与相似题
**举一反三**：处理字符串前缀的题目常用字典树或排序优化。  
**推荐题目**：  
1. [P2580 统计难题](https://www.luogu.com.cn/problem/P2580)（字典树统计前缀）  
2. [P8306 【模板】字典树](https://www.luogu.com.cn/problem/P8306)（标准模板题）  
3. [P2922 Secret Message](https://www.luogu.com.cn/problem/P2922)（结合路径计数）  

---

### 调试与心得
- **排序必要性**：未排序时无法保证最小节点数（如zyk7题解强调`break`关键性）。  
- **根节点陷阱**：Alex_Wei题解指出`cnt+1`是常见WA点。  
- **公共前缀计算**：需严格限制在前一单词长度内（如naroanah题解的`j < s[i-1].length()`）。

---
处理用时：75.77秒
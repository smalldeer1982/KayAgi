# 题目信息

# [NOI1997] 竞赛排名

## 题目描述

某市组织了一次中学生科技全能竞赛，每个选手要参加数学、物理、化学、天文、地理、生物、计算机和英语共八项竞赛,最后综合八项竞赛的成绩排出总名次。

选手编号依次为： $1,2,\dots,N$（$N$ 为参赛总人数）。设 $x_{i, j}$（$1 \le i \le N, 1 \le j \le 8$）分别表示编号为 $i$ 的选手第 $j$ 项竞赛的成绩。其它指标如下：

- 第 $j$（$1 \le j \le 8$）项竞赛的平均分 $avg_j = \frac{1}{N} \sum_{i=1}^N x_{i, j}$
- 选手 $i$（$1 \le i \le N$）的总分 $sumx_i = \sum_{j=1}^8 x_{i, j}$
- 选手 $i$（$1 \le i \le N$）第 $j$（$1 \le j \le 8$）项竞赛的位置分

$$
y_{i, j}= \begin{cases} 0 & \left(\sum_{i = 1} ^ N |x_{i, j} - avg_j| = 0\right) \\ \frac{x_{i, j} - avg_j}{\frac{1}{N} \sum_{i = 1} ^ N |x_{i ,j} - agv_j|} & \left(\sum_{i = 1} ^ N |x_{i, j} - avg_j| \ne 0\right)\end{cases}
$$

- 选手 $i$（$1 \le i \le N$）的总位置分 $sumy_i = \sum_{j=1}^3 y_{i, j} + 0.8 \sum_{j=4}^8 y_{i, j}$

排名规则如下:
1. 总位置分高的选手名次在前；
2. 若两个或两个以上的选手总位置分相同，则总分高的选手名次在前；
3. 若两个或两个以上的选手总位置分和总分均相同，则编号在前的选手名次在前。

请你为竞赛组委会编一程序，计算本次全能竞赛的总排名情况。

## 说明/提示

#### 数据范围

对于所有测试数据，满足 $1 \le N \le 1000$。

## 样例 #1

### 输入

```
3
72 82 73 68 95 86 82 90
72 90 50 60 80 70 65 80
72 82 73 68 95 86 82 90
```

### 输出

```
1
3
2
```

# AI分析结果



**算法分类**: 模拟

---

### 综合分析
题目核心是模拟复杂的评分公式并实现多条件排序。所有题解均采用结构体存储选手数据、分步计算各项指标、自定义排序规则的思路，差异主要体现在分母预处理和代码优化上。

---

### 精选题解

#### 1. [long_hao] ⭐⭐⭐⭐⭐  
**关键亮点**:  
- **分母预计算**：针对每个科目预先计算 $\sum |x_{i,j}-avg_j|$，避免重复遍历选手，时间复杂度从 $O(n^2)$ 优化至 $O(n)$。  
- **代码简洁性**：使用结构体与清晰的分步计算，逻辑紧凑。  
**个人心得**：  
> "分母是每个科目所有选手分差的平均值，预处理后直接使用，减少冗余计算。"

#### 2. [Liuxizai] ⭐⭐⭐⭐  
**关键亮点**:  
- **完整公式解释**：将数学公式转化为通俗语言，便于理解。  
- **模块化代码**：分步骤实现平均分、位置分、总位置分的计算，代码可读性强。  

#### 3. [Eason_AC] ⭐⭐⭐⭐  
**关键亮点**:  
- **高效排序**：利用结构体 `operator` 重载实现多条件排序，简化代码。  
- **内存优化**：使用 `double` 数组存储中间结果，减少内存占用。

---

### 核心代码实现
以 [long_hao] 的优化代码为例：
```cpp
struct edge {
    int i, sum, ben[9];          // 选手编号、总分、各科成绩
    double sum1, wei[9];         // 总位置分、各科位置分
} m[100010];
double wei_xue[9];               // 预存分母（各科的分母）

// 预处理分母
for (int j = 1; j <= 8; j++) {
    for (int k = 1; k <= n; k++) 
        wei_xue[j] += abs(m[k].ben[j] - xue[j]);
    wei_xue[j] /= n;             // 分母 = Σ|x-avg| / n
}

// 计算位置分
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= 8; j++) {
        if (wei_xue[j] != 0)
            m[i].wei[j] = (m[i].ben[j] - xue[j]) / wei_xue[j];
    }
}
```

---

### 拓展与举一反三
- **同类题目推荐**:  
  1. [P1093 奖学金](https://www.luogu.com.cn/problem/P1093)（多条件排序）  
  2. [P1781 总统选举](https://www.luogu.com.cn/problem/P1781)（加权投票模拟）  
  3. [P1309 瑞士轮](https://www.luogu.com.cn/problem/P1309)（动态排名系统）  

- **关键技巧**:  
  - **预处理中间值**：避免重复计算提升效率。  
  - **结构体排序**：优先处理高权重指标，利用 `sort` 的自定义比较函数。  
  - **浮点精度处理**：使用 `1e-6` 误差范围判断相等。

---
处理用时：53.07秒
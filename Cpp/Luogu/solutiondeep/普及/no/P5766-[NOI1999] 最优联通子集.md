# 题目信息

# [NOI1999] 最优联通子集

## 题目描述

众所周知，我们可以通过直角坐标系把平面上的任何一个点 $P$ 用一个有序数对 $(x,y)$ 来唯一表示，如果 $x,y$ 都是整数，我们就把点 $P$ 称为整点，否则点 $P$ 称为非整点。我们把平面上所有整点构成的集合记为 $W$。

定义 1 ：两个整点 $P_1(x_1,y_1),P_2(x_2,y_2)$，若 $|x_1-x_2|+|y_1-y_2|=1$，则称 $P_1,P_2$ 相邻，记作 $P_1$~$P_2$ ，否则称 $P_1,P_2$ 不相邻。

定义 2 ：设点集 $S$ 是 $W$ 的一个有限子集，即 $S$=$\{P_1,P_2,…,P_n\}$ $(n \ge 1)$，其中 $P_i (1 \le i \le n)$ 属于 $W$，我们把 $S$ 称为整点集。

定义 3 ：设 $S$ 是一个整点集，若点 $R$,$T$ 属于 $S$ ，且存在一个有限的点序列 $Q_1,Q_2,…,Q_k$ 满足: 
1. $Q_i$ 属于 $S$ （$ 1 \le i \le k $）;
2. $Q_1$ = $R$,$Q_k$ = $T$;
3. $Q_i$~$Q_{i+1} (1 \le i \le k-1)$，即 $Q_i$ 与 
 $Q_{i+1}$ 相邻;
4. 对于任何 $1 \le i<j \le k$ 有 $Q_i≠Q_j$;

我们则称点 $R$ 与点 $T$ 在整点集 $S$ 上连通，把点序列 $Q_1,Q_2,…,Q_k$ 称为整点集 $S$ 中连接点 $R$ 与点 $T$ 的一条道路。

定义 4 ：若整点集 $V$ 满足：对于 $V$ 中的任何两个整点， $V$ 中有且仅有一条连接这两点的道路，则 $V$ 称为单整点集。

定义 5 ：对于平面上的每一个整点，我们可以赋予它一个整数，作为该点的权，于是我们把一个整点集中所有点的权的总和称为该整点集的权和。

我们希望对于给定的一个单整点集 $V$ ，求出一个 $V$ 的最优连通子集 $B$ ，满足：
1. $B$ 是 $V$ 的子集
2. 对于 $B$ 中的任何两个整点，在 $B$ 中连通；
3. $B$ 是满足条件 (1) 和 (2) 的所有整点集中权和最大的。


## 样例 #1

### 输入

```
5
0 0 -2
0 1 1
1 0 1
0 -1 1
-1 0 1
```

### 输出

```
2
```

# AI分析结果



### 算法分类
动态规划（树形DP）

### 题目分析与结论
题目本质是求树的最大权连通子集。所有题解均正确识别出单整点集构成树的特性，并采用树形DP求解。核心思路为：设 `dp[u]` 表示以 `u` 为根的子树中包含 `u` 的最大权和，状态转移时累加所有正贡献的子节点权值。

---

### 精选题解

#### 1. 作者：include13_fAKe（★★★★☆）
**关键亮点**  
- 明确将单整点集映射为树结构，思路清晰  
- 给出完整的状态转移公式 `dp[u] = C_u + sum(max(dp[v],0))`  
- 代码简洁，包含建图与树形DP完整流程  
**核心代码**  
```cpp
void dfs(int u) {
    vis[u] = true;
    dp[u] = c[u]; // 必选当前节点
    for (int v : g[u]) {
        if (!vis[v]) {
            dfs(v);
            if (dp[v] > 0) dp[u] += dp[v];
        }
    }
}
```

#### 2. 作者：zry……yrz（★★★★☆）  
**关键亮点**  
- 前向星建边优化空间  
- 强调权值和大于0时才累加子节点贡献  
- 代码可读性高，包含快读优化  
**核心实现**  
```cpp
void js(int x, int fa) {
    for (int i=head[x]; i; i=zry[i].next) {
        int v = zry[i].v;
        if (v != fa) {
            js(v, x);
            if (dp[v] > 0) dp[x] += dp[v];
        }
    }
}
```

#### 3. 作者：过氧化氢_syq0057（★★★★☆）  
**关键亮点**  
- 处理可能的非连通图（虽然题目保证连通）  
- 注释清晰，强调权值和初始化负无穷的重要性  
**核心代码**  
```cpp
void dfs(int u) {
    vis[u] = 1;
    for (int i=head[u]; ~i; i=Next[i]) {
        int v = ver[i];
        if (!vis[v]) {
            dfs(v);
            dp[u] += max(0, dp[v]); // 累加正贡献
        }
    }
    dp[u] += c[u]; // 加上自身权值
}
```

---

### 最优技巧总结
**树形DP核心逻辑**  
- 状态定义：`dp[u]` 表示包含 `u` 的子树最大权和  
- 转移规则：`dp[u] = 自身权值 + sum(子节点正贡献)`  
- 结果提取：全局最大值 `max(dp[1..n])`  

**同类型题目**  
1. [P1122 最大子树和](https://www.luogu.com.cn/problem/P1122)  
2. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)  
3. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)  

---

### 调试与心得摘录
- **include13_fAKe**：明确树结构特性后直接套用模板，避免了复杂分析  
- **mot1ve**：初期误判环的存在，后来理解题目保证无环，简化代码  
- **过氧化氢_syq0057**：因未处理空集导致WA，提醒注意题目细节  

**总结**：树形DP的关键在于合理定义状态和转移条件，同时注意题目隐含的树结构特性。

---
处理用时：52.11秒
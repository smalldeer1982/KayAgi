# 题目信息

# 棋盘游戏

## 题目描述

为了增强幼儿园小朋友的数数能力，小虎老师给了一个家庭游戏作业。让小虎那一块空的围棋盘，随机在一些方格中放些棋子（有黑白两种颜色），如果一个方格和它的上、下、左、右四个方格之一有相同颜色的棋子，则认为两个格子是相互连通的。这期间，要求小虎不断统计共有多少个连通块。

如下图是一个 $5\times 9$ 的一块棋盘，其中 `.` 表示空格，`*` 表示黑棋子，`@`表示白棋子。

则有 $4$ 块连通子块。
```
.  .  .  .  .  .  .  .  .
.  .  *  *  .  .  @  @  .
.  *  *  @  @  .  @  @  .
.  .  *  @  .  .  *  .  .
.  .  .  .  .  .  .  .  .
```

哥哥大虎在一边看一边想，如果棋盘是 $N\times N$ 的，共放了 $M$ 个棋子，如何使用计算机解决这个问题呢？

## 说明/提示

对于 $30\%$ 数据：$1\le N \le 10$。

对于 $60\%$ 数据：$1\le N\le 100$。

对于 $100\%$ 数据：$1\le N\le 500$，$1\le M \le N \times N$，$ 0 \le c \le 1$，$ 1\le x, y \le N$。

## 样例 #1

### 输入

```
3 5    
1 1 1  
1 1 2  
0 2 2  
1 3 1  
1 2 1  
```

### 输出

```
1 
1 
2 
3 
2
```

## 样例 #2

### 输入

```
3 5
1 1 2
1 2 1
1 3 2
1 2 3
1 2 2
```

### 输出

```
1
2
3
4
1
```

# AI分析结果



### 算法分类
**并查集**

---

### 综合分析
题目要求动态维护棋盘连通块数量，每次添加棋子后需快速统计。所有题解均采用**并查集**解决，核心思路如下：
1. **二维坐标映射为一维**：通过公式 `(x-1)*n + y` 将二维点转化为一维索引。
2. **动态合并**：每次放置棋子后检查上下左右四个方向，若存在同色棋子则合并连通块。
3. **计数优化**：初始连通块数递增，每次成功合并后递减，避免全盘遍历。

各题解差异主要在实现细节（如并查集初始化、边界处理、颜色存储方式），但核心逻辑一致。最优思路为**动态并查集合并与维护计数**，时间复杂度接近 O(Mα(N))，适合 N=500 规模。

---

### 高分题解推荐

#### 1. 作者：Farkas_W（⭐⭐⭐⭐⭐）
**关键亮点**：
- **高效的一维映射**：简洁的坐标转换公式。
- **实时计数维护**：`ans` 变量直接记录当前连通块数，逻辑清晰。
- **代码简洁性**：快速读入/输出优化，边界处理隐式通过数组越界判断。

**核心代码**：
```cpp
int find(int x) {
    if (x != f[x]) f[x] = find(f[x]);
    return f[x];
}
// 放置棋子时合并逻辑
for (int j=1; j<=4; j++) {
    int xx = x+fx[j], yy = y+fy[j];
    if (a[xx][yy] != z) continue;
    int fa = find((xx-1)*n+yy), fu = find((x-1)*n+y);
    if (fa != fu) f[fa] = fu, ans--;
}
```

#### 2. 作者：Ludo（⭐⭐⭐⭐）
**关键亮点**：
- **分颜色处理**：使用二维数组区分黑白棋连通块。
- **模块化合并函数**：`merge()` 函数封装合并逻辑，增强可读性。
- **显式边界检查**：明确判断 `xx>0 && xx<=n`，适合初学者理解。

**核心代码**：
```cpp
void merge(int type, int x, int y) {
    if (find(type, x) == find(type, y)) return;
    fa[type][find(type, x)] = find(type, y);
    ans[type]--;
}
// 合并方向判断
if (y>1 && visited[c][x][y-1]) 
    merge(c, (x-1)*n+y, (x-1)*n+y-1);
```

#### 3. 作者：zhangyuhan（⭐⭐⭐⭐）
**关键亮点**：
- **结构体二维并查集**：直观维护坐标与颜色。
- **方向数组优化**：使用 `dir[4][2]` 简化方向遍历。
- **详细注释**：适合新手理解二维并查集实现。

**核心代码**：
```cpp
node find(node d) {
    if (f[d.x][d.y].x != d.x || f[d.x][d.y].y != d.y)
        f[d.x][d.y] = find(f[d.x][d.y]);
    return f[d.x][d.y];
}
// 合并相邻同色棋子
_for (i, 0, 3) {
    int nx = a + dir[i][0], ny = b + dir[i][1];
    if (map[nx][ny] == c+1 && !same(now, next))
        unite(now, next), ans--;
}
```

---

### 关键思路总结
1. **坐标压缩**：将二维坐标 `(x,y)` 映射为 `(x-1)*n + y` 实现一维并查集。
2. **动态维护计数**：初始 `ans++`，每次合并成功则 `ans--`，避免重复遍历。
3. **四方向检查**：仅需检查当前棋子的上下左右，无需全局扫描。

---

### 拓展与练习
**相似题目推荐**：
1. [P3367 并查集模板](https://www.luogu.com.cn/problem/P3367) - 基础一维并查集
2. [P1197 星球大战](https://www.luogu.com.cn/problem/P1197) - 动态删除节点的并查集应用
3. [P1522 牛的旅行](https://www.luogu.com.cn/problem/P1522) - 结合Floyd与并查集的连通性分析

**调试技巧**：
- **颜色区分**：将输入颜色值 `+1` 避免与初始值冲突（如 `0` 表示无棋子）。
- **路径压缩**：务必在 `find()` 中实现，否则可能超时。
- **边界检查**：隐式越界（如开大数组）或显式判断 `x>=1 && x<=n` 均可，需注意初始化范围。

---
处理用时：53.62秒
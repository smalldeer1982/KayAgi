# 题目信息

# [POI 2017] Podzielno

## 题目描述

$B$ 进制数，每个数字 $i \in [0,B)$ 有 $a_i$ 个。你要用这些数字组成一个最大的 $B$ 进制数 $X$(不能有前导零，不需要用完所有数字)，使得 $X$ 是 $B-1$ 的倍数。 $q$ 次询问，每次询问 $X$ 在 $B$进制下的第 $k$ 位数字是什么(最低位是第 $0$ 位)。 

## 说明/提示

对于 $100\%$ 的数据，$2\le B\le10^6$，$1\le q\le 10^5$，$1\le a_i\le10^6$，$0\le k\le10^{18}$。

## 样例 #1

### 输入

```
3 3
1 1 1
0
1
2```

### 输出

```
0
2 
-1```

# AI分析结果



### 算法分类
数学、贪心、二分

### 题目核心思路
构造最大B进制数的关键在于确保各位数字之和是B-1的倍数。通过计算总和后调整余数对应的数字数量，再按从大到小排列数字。利用前缀和数组预处理数字分布，通过二分查找快速回答查询。

### 高分题解推荐
1. **jiangly（★★★★★）**  
   **亮点**：代码简洁高效，利用前缀和与`upper_bound`实现O(1)查询。数学推导清晰，正确处理余数调整，时间复杂度O(B + q log B)。  
   **核心代码**：
   ```cpp
   vector<long long> a(n);
   long long sum = 0;
   for (int i = 0; i < n; ++i) {
       sum += i * a[i];
   }
   if (sum % (n - 1) != 0) --a[sum % (n - 1)];
   for (int i = 1; i < n; ++i) a[i] += a[i - 1];
   // 查询时二分
   cout << upper_bound(a.begin(), a.end(), k) - a.begin();
   ```

2. **MoonCake2011（★★★★☆）**  
   **亮点**：思路与jiangly一致，代码简洁，直接使用贪心调整余数。前缀和处理稍显不同，但本质相同。  
   **核心代码**：
   ```cpp
   sum += (i-1)*a[i];
   if (sum%(n-1)) a[sum%(n-1)]--;
   for (int i=1;i<n;i++) a[i] += a[i-1];
   // 二分逻辑与jiangly相同
   ```

3. **panyanppyy（★★★★☆）**  
   **亮点**：代码结构清晰，特别强调前缀和的逆序映射逻辑。通过反向处理数字顺序实现贪心策略。  
   **核心代码**：
   ```cpp
   sum += (i-1)*a[i];
   a[sum%(n-1)]--;
   for (int i=0;i<n;i++) a[i] += a[i-1];
   // 二分查询逻辑
   ```

### 关键思路总结
1. **数学性质**：B进制数能被B-1整除等价于各位和是B-1的倍数。
2. **贪心调整**：总和若非B-1倍数，只需删去余数对应的一个数字。
3. **前缀和优化**：将数字按从大到小排列（隐式通过索引处理），用前缀和数组快速定位第k位。
4. **二分查询**：利用`upper_bound`快速找到第一个超过k的前缀和位置，确定对应数字。

### 扩展思考
类似问题可考虑进制转换、数位和的数学性质应用。例如LeetCode 1015（可被K整除的最小整数）也利用了数位和的模数特性。

### 推荐习题
1. [P4127 同类分布](https://www.luogu.com.cn/problem/P4127)  
2. [P2651 添加括号](https://www.luogu.com.cn/problem/P2651)  
3. [P2926 等差数列](https://www.luogu.com.cn/problem/P2926)

---
处理用时：372.39秒
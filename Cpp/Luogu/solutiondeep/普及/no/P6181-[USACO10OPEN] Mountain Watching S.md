# 题目信息

# [USACO10OPEN] Mountain Watching S

## 题目描述

一天，Bessie 望着远处的山脉，在思考：“哪一座山最宽呢？”

Bessie 设法测量了 $N$ 个位置的高度 $h_i$（$1 \leq N \leq 10^5$，$1 \leq h_i \leq 10^9$）。一座山被定义为一个高度先不下降，后不上升的子序列。视野边缘的山脉也只会增加或减少高度。一座山的宽度被定义为这座山包含的位置数量。

下面是一个例子：

```plain
           *******                   *
          *********                 ***
          **********               *****
          ***********           *********               *
*      *****************       ***********             *** *
**    *******************     *************   * *     *******      *
**********************************************************************
3211112333677777776543332111112344456765432111212111112343232111111211
aaaaaa                   ccccccccccccccccccccc eeeeeee    ggggggggg
  bbbbbbbbbbbbbbbbbbbbbbbbbbbb             ddddd ffffffffff  hhhhhhhhh
```

每座山都已经用字母标出来了。这里 `b` 山脉的宽度最大，为 $28$。

## 样例 #1

### 输入

```
7
3
2
3
5
4
1
6```

### 输出

```
5```

# AI分析结果



### 算法分类
动态规划

### 题目分析与题解对比
题目要求找到最长的连续单峰子序列。各题解核心思路可分为两类：
1. **暴力扩展法**：对每个点向左右扩展找最长不下降/不上升区间（时间复杂度 O(n²)，无法通过 1e5 数据）
2. **动态规划预处理法**：预处理每个点的左右最长不下降/不上升连续子序列长度，再合并计算（时间复杂度 O(n)）

### 高星题解推荐
#### 1. 题解作者：Link_Cut_Y（5星）
- **核心思路**：预处理 `up[i]` 表示以 i 结尾的最长不下降连续序列长度，`down[i]` 表示以 i 开头的最长不上升连续序列长度。合并后取最大值。
- **关键代码**：
  ```cpp
  for (int i = 1; i <= n; i ++ )
      up[i] = h[i] >= h[i - 1] ? up[i - 1] + 1 : 1;
  for (int i = n; i >= 1; i -- )
      down[i] = h[i] >= h[i + 1] ? down[i + 1] + 1 : 1;
  ans = max(ans, up[i] + down[i] - 1);
  ```
- **亮点**：代码简洁，时间复杂度严格 O(n)，利用两次遍历完成预处理。

#### 2. 题解作者：Remake_（5星）
- **核心思路**：类似预处理左右序列，变量名更直观（`zheng` 为不下降，`fan` 为不上升）。
- **关键代码**：
  ```cpp
  for(int i=2;i<=n;i++) a[i]>=a[i-1] ? zheng[i]=zheng[i-1]+1 : zheng[i]=1;
  for(int i=n-1;i>=1;i--) a[i]>=a[i+1] ? fan[i]=fan[i+1]+1 : fan[i]=1;
  maxn = max(zheng[i] + fan[i] - 1);
  ```
- **亮点**：变量命名清晰，逻辑直白，适合理解。

#### 3. 题解作者：V1mnkE（5星）
- **核心思路**：与上述解法一致，代码高度简洁。
- **关键代码**：
  ```cpp
  for(int i=2;i<=n;i++) f[i] = (a[i]>=a[i-1]) ? f[i-1]+1 : 1;
  for(int i=n-1;i>=1;i--) f1[i] = (a[i]>=a[i+1]) ? f1[i+1]+1 : 1;
  mx = max(mx, f[i] + f1[i] - 1);
  ```
- **亮点**：代码极致精简，突出核心逻辑。

### 关键思路总结
1. **双向预处理**：分别从左到右、从右到左遍历，维护每个点的最长不下降/不上升连续子序列长度。
2. **合并计算**：每个点的单峰长度 = 左不下降长度 + 右不上升长度 - 1（峰顶去重）。
3. **时间复杂度优化**：通过 O(n) 预处理避免暴力扩展的高复杂度。

### 拓展与相似题目
- **P1091 合唱队形**：求最长非连续单峰子序列（动态规划）
- **P1567 统计天数**：最长连续递增子序列（类似预处理）
- **P3406 海底高铁**：区间统计与预处理技巧

### 个人心得摘录
- **边界处理**：`Shadow_Lord` 提到初始值设定（如 `h[0]` 设为极大值）避免越界。
- **重复计算**：多题解强调合并时 `-1` 的重要性（峰顶被左右数组重复计算）。
- **调试教训**：`a1a2a3a4a5` 的题解因循环条件错误导致错误，需注意下标范围。

---
处理用时：157.18秒
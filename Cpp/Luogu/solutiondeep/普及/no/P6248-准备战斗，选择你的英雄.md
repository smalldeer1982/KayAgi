# 题目信息

# 准备战斗，选择你的英雄

## 题目背景

zjf，被 NOIP 普及组初赛戏耍，pj 1= -> 初赛三等，愤恨地离开了 OI，深陷中考的泥潭当中。据说，他颓废是因为玩多了 [OW](https://ow.blizzard.cn/home) 这款游戏。

## 题目描述

目前，游戏共有 $31$ 个英雄，每局可以派 $6$ 个英雄上场。实际能使用的英雄数将会小于 $31$。简单地假设，每位英雄对团队的贡献可以用一个正整数 $v_i$ 表示。团队的总能力等于所有英雄的贡献之和。特别地，对于 $m$ 组特定的英雄，他们一起出现会让团队总能力提高 $x_i$。

**另注：英雄组合可以重复，若重复请多次计数。**

## 说明/提示

#### 样例 1 解释
我们应该选择前 $6$ 名英雄。

---

#### 样例 2 解释
我们应该选择 Pharah、Mercy、Reinhardt、DVA、SOLDIER:76、Anna

---

#### 数据范围
对于 $40\%$ 的数据，$m=0$。  
对于 $100\%$ 的数据，$6\le n \le 30$，$0\le m \le 30$，*$1\le x_i,v_i \le 100$*，英雄名字长度 $\le 10$，字符集包括大小写字母、数字以及冒号（ `:` ）。每个英雄的名字各不相同。


## 样例 #1

### 输入

```
7 0
Sigma 10
Orisa 10
Mei 10
Reaper 10
Moira 10
Lucio 10
Doomfist 1```

### 输出

```
60```

## 样例 #2

### 输入

```
8 2
Pharah 5
Mercy 5
Reinhardt 10
DVA 10
SOLDIER:76 12
Torbjorn 5
Anna 8
Baptiste 10
Pharah Mercy 20
Anna Pharah 5```

### 输出

```
75```

# AI分析结果



### 算法分类
**搜索（组合枚举）**

---

### 题解分析与结论
题目核心是暴力枚举所有6人组合并计算总能力值。所有题解均采用**组合枚举**思路，通过DFS或六重循环生成组合。关键难点在于：
1. **组合加成的高效计算**：需遍历所有选中的英雄对并累加加成值。
2. **重复组合的处理**：输入中的英雄组合可能重复出现，需用`+=`而非直接赋值。

各题解差异主要在组合生成方式（DFS vs. 循环）和加成存储结构（二维数组 vs. 哈希表）。最优实现需满足：
- 正确生成不重复组合
- 高效计算两两组合加成

---

### 高星题解推荐
#### 1. 作者：gyh20（⭐⭐⭐⭐⭐）
**关键亮点**：
- **六重循环直接枚举组合**，代码简洁且常数极小。
- **预处理加成矩阵**，计算时直接遍历15对组合。
- **无递归开销**，实测效率极高。

**核心代码**：
```cpp
for(int a=1;a<=n;++a)
    for(int b=a+1;b<=n;++b)
        for(int c=b+1;c<=n;++c)
            for(int d=c+1;d<=n;++d)
                for(int e=d+1;e<=n;++e)
                    for(int f=e+1;f<=n;++f)
                        ans=max(ans,val[a]+...+g[e][f]);
```
**实现思想**：通过严格递增的循环变量保证组合唯一性，直接累加所有两两对的加成值。

#### 2. 作者：lzqy_（⭐⭐⭐⭐）
**关键亮点**：
- **DFS生成组合**，逻辑清晰易扩展。
- **分离组合生成与计算逻辑**，代码可读性强。
- **通过`a[kk-1]`剪枝**，避免重复枚举。

**核心代码**：
```cpp
void dfs(int kk) {
    if(kk==7) moni();
    else for(int i=a[kk-1]; i<=n; i++)
        if(!k[i]) { 
            k[i]=1; a[kk]=i;
            dfs(kk+1); 
            k[i]=0;
        }
}
```
**调试心得**：作者强调"将模拟计算与DFS分离"，避免递归中复杂逻辑，提升可维护性。

#### 3. 作者：Wenoide（⭐⭐⭐⭐）
**关键亮点**：
- **字符串哈希处理名称**，避免map查询开销。
- **增量式计算总能力**，减少重复计算。

**核心代码**：
```cpp
void DFS(int tot,int cur,int sum){
    if(tot==6) { ans=max(ans,sum); return; }
    for(int i=cur;i<n;++i){
        int t=sum+val[i];
        for(int j=0;j<tot;++j) t+=tm[i][p[j]];
        p[tot]=i;
        DFS(tot+1,i+1,t);
    }
}
```
**优化技巧**：在DFS过程中逐步累加新英雄与已选英雄的加成，时间复杂度优化至*O(6·C(n,6))*。

---

### 关键思路总结
1. **组合生成优化**：通过递增顺序（循环/DFS参数）避免重复组合。
2. **加成矩阵预处理**：使用二维数组存储每对英雄的累计加成。
3. **暴力枚举可行性**：C(30,6) ≈ 6e5 在时间允许范围内。
4. **增量式计算**：在生成组合过程中逐步计算加成，减少重复遍历。

---

### 拓展与相似题目
1. **组合生成模板**：[P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)
2. **状态压缩枚举**：[P2392 kkksc03考前临时抱佛脚](https://www.luogu.com.cn/problem/P2392)
3. **复杂组合计算**：[P1315 观光公交](https://www.luogu.com.cn/problem/P1315)

---
处理用时：80.35秒
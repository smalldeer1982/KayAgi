# 题目信息

# [PA 2018] Palindrom

## 题目描述

**译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/)  Runda 3 [Palindrom](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pal/)**

**请特别注意本题的内存限制。**

给出一个字符串，请你判断其是否为回文串。

回文串是指从左往右读与从右往左读完全相同。

## 说明/提示

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证字符串长度不超过 $2\times 10^7$。

您可以假设在任何测试数据中都有 $n>0$ 或者 $n=0$。

感谢 @[Infinite_Eternity](/user/897776) 提供的测试数据！


## 样例 #1

### 输入

```
5
kajak```

### 输出

```
TAK```

## 样例 #2

### 输入

```
0
kanu```

### 输出

```
NIE```

# AI分析结果



### 算法分类
字符串

### 综合分析与结论
本题需在 4MB 内存限制下判断超长字符串是否为回文。核心思路是通过流式处理字符，利用哈希算法动态计算正序和逆序的哈希值，避免存储整个字符串。各题解主要采用以下两种哈希策略：

1. **正向哈希**：`hash = hash * base + char` 模拟字符串拼接
2. **逆向哈希**：`hash = hash + char * base^i` 模拟反向拼接
通过双模数哈希可极大降低哈希冲突概率，是更优解法。

---

### 精选题解与评分

#### 1. 离散小波变换°（★★★★★）
**核心亮点**  
- 双模数哈希（BASE1/BASE2 + MOD1/MOD2），极大提升正确性
- 边读边算，严格内存控制（仅需 6 个 int 变量）
- 输入处理严谨，用 `isalpha` 跳过非字母字符

**代码核心**  
```cpp
do{
    h1 = (1ll * h1 * BASE1 + c) % MOD1;  // 正向哈希
    h2 = (1ll * c * base1 + h2) % MOD1; // 逆向哈希
    base1 = 1ll * base1 * BASE1 % MOD1; // 维护 base 的幂次
} while(isalpha(c = getchar()));
```

#### 2. Andy_WA（★★★★☆）
**核心亮点**  
- 单模数但使用 `unsigned long long` 自然溢出
- 简洁的输入处理逻辑，直接通过 `getchar` 过滤无效字符

**优化点**  
未使用双哈希，理论上有哈希冲突风险。

---

### 关键思路与技巧
1. **流式哈希处理**：逐个字符计算哈希，避免存储整个字符串
2. **双哈希优化**：用两个不同的哈希参数（base 和 mod）降低冲突概率
3. **幂次维护**：动态计算 `base^i` 的值，用于逆向哈希计算
4. **输入过滤**：使用 `isalpha()` 或 `getchar` 跳过非字母字符

---

### 拓展练习
1. [P3370 字符串哈希](https://www.luogu.com.cn/problem/P3370)  
   **考察点**：基础哈希应用与碰撞处理
2. [P2957 哈希碰撞](https://www.luogu.com.cn/problem/P2957)  
   **考察点**：哈希表设计与冲突解决
3. [P1381 单词背诵](https://www.luogu.com.cn/problem/P1381)  
   **考察点**：哈希加速字符串匹配与滑动窗口结合

---

### 题解心得摘录
1. **banned_xiejiayun**：  
   > "直接复制粘贴水题一道... 发现 MLE 后改用哈希，大片的 AC 看着好舒服"  
   **总结**：强调空间限制的隐蔽性，哈希解法带来的成就感

2. **Il1_1_3**：  
   > "我的头像就是来自这道题的 MLE 记录"  
   **总结**：内存限制的严格性需引起足够重视，流式处理是核心突破点

3. **zxh923**：  
   > "倒序的哈希像求数字的反序数"  
   **总结**：通过类比数字逆序，直观理解逆向哈希计算逻辑

---
处理用时：61.71秒
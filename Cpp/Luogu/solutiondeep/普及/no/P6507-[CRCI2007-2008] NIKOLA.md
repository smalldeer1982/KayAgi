# 题目信息

# [CRCI2007-2008] NIKOLA

## 题目描述

有一行 $n$ 个格子，编号为 $1\sim n$，Nikola 从 $1$ 号格子出发，想要前往 $n$ 号格子。

他的行程包含若干次跳跃，第一次只能跳到 $2$ 号格子，接下来的跳跃必须满足以下条件：

- 如果他向 $n$ 号格子的方向跳跃，那么每次必须比前一次多跳一个距离的格子；

- 如果他向 $1$ 号格子的方向跳跃，那么每次必须与上一次的跳跃距离完全相同。

例如，在第一次跳跃之后（位于 $2$ 号格），Nikola 可以选择跳到 $4$ 或者 $1$。

每进入一个格子，Nikola 都要支付相应的入场费。第 $i$ 个格子需要付费 $a_i$。他希望在能到达 $n$ 号格的前提下尽可能少的花钱。你需要求出这个最小值。

## 说明/提示

#### 样例 1 解释

在第一个样例中，Nikola 的路线为 $1-2-1-3-6$。共花费 $2+1+3+6=12$ 。


#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\le n\le 1000$，$1\le a_i\le 500$。

#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [Regional Competition](https://hsin.hr/coci/archive/2007_2008/regional_tasks.pdf) *T2 NIKOLA***。

## 样例 #1

### 输入

```
6
1
2
3
4
5
6```

### 输出

```
12```

## 样例 #2

### 输入

```
8
2
3
4
3
1
6
1
4```

### 输出

```
14```

# AI分析结果



### 算法分类
动态规划 | 记忆化搜索

---

### 题解分析与结论
题目核心在于跳跃规则带来的状态转移特性。所有题解均围绕两种解法展开：
1. **记忆化搜索**：以位置和上次跳跃步长为状态，递归求解时缓存中间结果
2. **动态规划**：通过特定枚举顺序保证状态转移可行性，二维状态存储最小花费

核心难点在于：
- 状态定义需包含位置和跳跃步长
- 跳跃方向不同导致步长变化规则不同
- 需要处理边界条件和状态转移顺序

---

### 精选题解与评分

#### 1. CaoXian（5星）
**关键亮点**：
- 清晰的动态规划状态定义与转移方程
- 详细解释枚举顺序设计（外层j循环+倒序i循环）
- 代码结构简洁，包含边界处理

**核心代码**：
```cpp
fu(j, 1, n) {
    fd(i, n, 1) {
        if(i < j) dp[j][i] = min(dp[j][i], dp[j - i][i - 1] + a[j]);
        if(j <= n - i) dp[j][i] = min(dp[j][i], dp[j + i][i] + a[j]);
    }
    ans = min(ans, dp[n][i]);
}
```

#### 2. linyinuo2008（4星）
**关键亮点**：
- 记忆化搜索模板清晰易懂
- 对比暴搜与记搜差异，解释优化思路
- 强调越界返回值的设定技巧

**核心代码**：
```cpp
int search(int pos,int len) {
    if(pos<1||pos>n) return 0x7f7f7f7f;
    if(pos==n) return a[n];
    if(vis[pos][len]) return vis[pos][len];
    return vis[pos][len]=min(search(pos-len,len), 
                           search(pos+len+1,len+1))+a[pos];
}
```

#### 3. XCDRF_（4星）
**关键亮点**：
- 动态规划实现简洁高效
- 注释明确解释状态转移逻辑
- 倒序枚举i的设计说明

**核心代码**：
```cpp
for(int j=1;j<=n;j++){
    for(int i=n;i>=1;i--){
        if(i>j) dp[i][j]=min(dp[i][j],dp[i-j][j-1]+a[i]);
        if(i+j<=n) dp[i][j]=min(dp[i][j],dp[i+j][j]+a[i]);
    }
}
```

---

### 关键思路总结
1. **状态设计**：`dp[pos][step]` 表示到达位置pos时，最后一次跳跃步长为step的最小花费
2. **转移方向**：
   - 向左跳：`step`不变 → `pos-step`
   - 向右跳：`step+1` → `pos+step+1`
3. **枚举顺序**：优先处理跳跃步长维度，倒序处理位置维度以保证转移可用性
4. **初始化**：起点状态为`dp[1][0] = 0`，其他设为极大值

---

### 拓展建议
1. **同类题目**：
   - P1216（数字三角形）- 简单二维DP
   - P1434（滑雪）- 记忆化搜索经典题
   - P7074（方格取数）- 带方向限制的DP
2. **优化思路**：可尝试滚动数组优化空间，或使用优先队列实现Dijkstra式解法

---

### 心得知乎
**linyinuo2008**提到：  
> "记搜写成0x7f一个点都过不了"  
说明INF的取值需足够大（至少大于总花费上限1000×500=5e5）

**CaoXian**强调：  
> "外层j循环+倒序i循环的设计，确保转移所需状态已计算"  
揭示了动态规划中状态依赖关系的处理关键

---
处理用时：55.48秒
# 题目信息

# 「MCOI-03」村国

## 题目背景

$\texttt{What did this player dream?}$

他梦见了什么？

$\texttt{This player dreamed of sunlight and trees.Of fire and water.}$

他梦见了阳光与树木。梦见了火与水。

$\texttt{It dreamed it created. And it dreamed it destroyed. It dreamed it hunted,}$ 
$\texttt{and was hunted. It dreamed of shelter.}$

他梦见他的创造，亦梦见他毁灭。它梦见他在狩猎，亦梦见被猎捕。他梦见温馨的居所。

$\texttt{Hah, the original interface. A million years old, and it still works.But}$ 
$\texttt{ what true structure did this player create, in the reality behind the screen?}$

哎，那原始的界面。经历百万年的岁月，它依然在工作。只是他在屏幕后的真实里，到底创造了什么真实的世界呢？

## 题目描述

C 国一共有 $N$ 个村庄，$N-1$ 条道路。这些道路都可以双向通行。保证小 S 可以从一座村庄到其他任何一座村庄。这 $N$ 个村庄编号为 $1$ 到 $N$。

刚开始小 S 对第 $i$ 个村庄的好感值为 $A_i$。小 S 的假期一共有 $M$ 天，他会在 C 国旅行一共 $M$ 天。每一天他会选择来到当前好感值最高的村庄。如果有好感值相同的村庄，他会选择编号最小的村庄。假设这一天他来到村庄 $X$，那么这一天结束后，与村庄 $X$ 直接相邻所有村庄的好感值都会增加 $1$。即能从 $X$ 出发仅经过一条道路到达的村庄好感值会增加 $1$。因为小 S 已经在村庄 $X$ 待过一天了，所以这一天结束后村庄 $X$ 的好感值并不会增加。

现在小 S 想要知道经过 $M$ 天的旅行后好感值最高的村庄。

如果有多个好感值最高的村庄，输出编号最小的。

## 说明/提示

#### 样例说明

对于第一组数据，小 S 在 $2$ 号村庄旅行了 $3$ 天，结束时村庄 $1,2$ 的好感值分别为 $5,6$。所以答案输出 $2$。

对于第二组数据，结束时三个村庄的好感值分别为 $3,7,8$，所以答案输出 $3$。

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \le N\le 2\times10^6$，$1 \le M\le10^{18}$，$1 \le A_i\le2^{31}-1$，$1 \le T\le10$。

| 测试点编号 | $A_i\le$ | $\sum N \le$ | $M \le $ | 测试点分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $\rm 1$ | $10$ | $20$ | $10$ | $5$ |
| $\rm 2$ | $10^2$ | $2 \times 10^2$ | $10^2$ | $10$ |
| $\rm 3$ | $10^3$ | $2 \times 10^3$ | $10^3$ | $15$ |
| $\rm 4$ | $10^5$ | $2 \times 10^5$ | $10^5$ | $25$ |
| $\rm 5$ |  | $2 \times 10^6$ |  | $45$ |

#### 提示

**本题输入量较大，请使用较快的读入方式。**

## 样例 #1

### 输入

```
2
2 3
2 6
1 2
3 5
2 6 4
1 3
2 3```

### 输出

```
2
3```

# AI分析结果



### 算法分类
**数学**

### 综合分析与结论
题目核心在于发现操作后最大权值节点仅在初始最大值节点及其相邻最大值节点之间交替，通过数学规律（差值计算与奇偶性判断）快速求解，避免模拟。关键点包括：
1. 确定初始最大节点（A）及其相邻最大节点（B）。
2. 计算两节点的初始差值，判断剩余操作次数的奇偶性。
3. 处理特例（如n=1）。

---

### 精选题解与评分
1. **作者：_zy_**（⭐⭐⭐⭐⭐）  
   **关键亮点**：  
   - 清晰分析周期性交替规律，提出差值计算与奇偶性判断。
   - 代码简洁高效，处理边界条件（如n=1）和大小比较。
   **代码核心**：
   ```cpp
   int maxn = 0, k = 0;
   for (遍历A的邻接节点) {
       if (节点权值更大或权值相同但编号更小) 更新B节点;
   }
   if (差值 > m) 输出A;
   else 根据剩余次数奇偶性选择A或B;
   ```

2. **作者：Eason_AC**（⭐⭐⭐⭐）  
   **关键亮点**：  
   - 通过详细样例模拟验证规律，强调树结构的特殊性。
   - 代码中明确记录初始最大节点及其邻接最大值节点。
   **核心代码**：
   ```cpp
   int ans = 初始最大节点;
   for (遍历邻接节点) 找到次大节点;
   if (剩余次数奇偶性为奇) 输出较大编号节点，否则输出较小;
   ```

3. **作者：hellhell**（⭐⭐⭐⭐）  
   **关键亮点**：  
   - 提出“反复横跳”的直观描述，简化问题本质。
   - 代码中特判n=1，避免常见错误。
   **代码片段**：
   ```cpp
   if (n == 1) 直接输出1;
   int dis = A权值 - B权值;
   if (m < dis) 输出A;
   else 根据奇偶性选择最终节点;
   ```

---

### 关键思路总结
1. **规律发现**：最大节点（A）与相邻次大节点（B）交替主导，剩余次数的奇偶性决定最终结果。
2. **差值计算**：先用部分操作使A和B权值相等，剩余操作次数决定交替次数。
3. **特判处理**：n=1时直接返回，避免逻辑错误。

---

### 拓展与同类题推荐
- **类似规律题**：  
  1. [P1965 转圈游戏](https://www.luogu.com.cn/problem/P1965)（周期性位移）  
  2. [P1220 关路灯](https://www.luogu.com.cn/problem/P1220)（贪心+状态转移）  
  3. [P1081 开车旅行](https://www.luogu.com.cn/problem/P1081)（预处理+周期性跳跃）  

---

### 调试与心得
- **特判教训**：多题解提到n=1时未处理导致WA，强调边界条件的重要性。
- **规律验证**：通过小样例手动模拟验证周期性，避免复杂推导错误。
- **代码优化**：避免存储整棵树，仅记录关键节点，提升效率。

---
处理用时：58.28秒
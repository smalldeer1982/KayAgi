# 题目信息

# [BalticOI 2012] 括号 (Day1)

## 题目描述

一个合法括号序列的定义如下：

- () 和 [] 是合法括号序列
- 若 A 是合法括号序列，则 (A) 和 [A] 也是合法括号序列
- 若 A 和 B 都是合法括号序列，则 AB 也是合法括号序列

在包含至少一对方括号的合法括号序列中，我们可以将 [ 和 ] 都用 ( 代替，这样就能够得到一个不合法括号序列。

例如 (( 和 ((((())) 都是不合法括号序列，前者可以由合法括号序列 \[] 转化而来，后者可以通过 \[]((()))，(\[](()))，((\[]())) 和 (((\[]))) 这四种合法括号序列转化而来。

现在给出一个不合法括号序列，求有多少种合法括号序列，在将其中的方括号用 ( 代替后，可以得到给定的括号序列。

## 说明/提示

**【样例解释#1】** 

满足条件的合法括号序列有两种：\[]() 和 ([])。

**【数据范围】**

- 对于 20% 的数据，满足 $n \leq 50$
- 对于 50% 的数据，满足 $n \leq 1000$
- 对于 100% 的数据，满足 $2\leq n \leq 30000$

**【说明】**

译自 [BalticOI 2012 Day1 T1. Brackets](http://www.boi2012.lv/data/day1/eng/brackets.pdf)

## 样例 #1

### 输入

```
4
((()```

### 输出

```
2```

## 样例 #2

### 输入

```
8
((((((((```

### 输出

```
14```

# AI分析结果



**算法分类**：动态规划

---

### **综合分析**
题目要求统计合法括号序列的数目，其关键在于将方括号替换后的序列转化为纯圆括号的合法序列。所有题解均采用动态规划（DP）思路，核心状态定义为 `dp[i][j]` 表示处理到第 `i` 个字符时，左括号比右括号多 `j` 个的方案数。通过滚动数组优化空间复杂度至 `O(n)`，转移方程根据当前字符类型（`(` 或 `)`）进行调整，最终答案为 `dp[n][0]`。

---

### **精选题解**

#### 1. **题解作者：quest_2**（⭐️⭐️⭐️⭐️⭐️）
- **关键亮点**：  
  - 详细证明了原问题与纯圆括号合法序列的一一对应关系，逻辑严谨。  
  - 明确指出 `O(n²)` 复杂度在本题数据下可行，并给出滚动数组优化实现。  
  - 代码简洁且包含注释，可读性强。  
- **核心代码**：
  ```cpp
  int dp[2][MAX], N;
  for (int i = 1; i <= N; i++) {
      char c = ...; // 输入当前字符
      for (int j = 0; j <= min(i, N-i); j++) {
          if (c == ')') dp[i&1][j] = dp[(i-1)&1][j+1];
          else dp[i&1][j] = (dp[(i-1)&1][j+1] + dp[(i-1)&1][j-1]) % MOD;
      }
  }
  ```

#### 2. **题解作者：a202401006**（⭐️⭐️⭐️⭐️）
- **关键亮点**：  
  - 代码附带详细注释，适合新手理解。  
  - 使用滚动数组优化，且解释状态转移的物理意义。  
- **个人心得**：  
  - 强调 `j` 的范围为 `min(i, N-i)`，避免无效状态计算。  
  - 提醒 `%2` 是滚动数组的常见技巧（`&1` 代替 `%2`）。

#### 3. **题解作者：D_xbang**（⭐️⭐️⭐️⭐️）
- **关键亮点**：  
  - 代码简洁，直接给出状态转移方程的实现。  
  - 使用 `min(i, n-i)` 控制循环范围，优化计算量。  
- **核心代码**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      for (int j = 0; j <= min(i, n - i); j++) {
          if (s[i] == '(') dp[i%2][j] = (dp[(i-1)%2][j+1] + dp[(i-1)%2][j-1]) % mod;
          else dp[i%2][j] = dp[(i-1)%2][j+1];
      }
  }
  ```

---

### **最优思路提炼**
- **状态设计**：`dp[i][j]` 表示处理到第 `i` 个字符时左括号比右括号多 `j` 个的方案数。  
- **转移方程**：  
  - 当前字符为 `(`：`dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]`（新增左括号或闭合之前的左括号）。  
  - 当前字符为 `)`：`dp[i][j] = dp[i-1][j+1]`（必须闭合之前的左括号）。  
- **空间优化**：滚动数组（交替使用两行数组）将空间复杂度降至 `O(n)`。  

---

### **拓展与举一反三**
- **同类问题**：  
  - 多种括号混合的合法序列计数（如 `{}`, `[]`, `()` 混合）。  
  - 最小修改次数使括号合法（如 LeetCode 921）。  
- **推荐题目**：  
  1. [P7914 括号序列](https://www.luogu.com.cn/problem/P7914)  
  2. [P1944 最长括号匹配](https://www.luogu.com.cn/problem/P1944)  
  3. [CF5E Bindian Signalizing](https://codeforces.com/problemset/problem/5/E)（环形括号扩展）  

---

### **调试与优化心得**
- **滚动数组技巧**：使用 `i % 2` 或 `i & 1` 代替二维数组，大幅减少内存占用。  
- **边界控制**：`j` 的范围限制为 `min(i, n-i)`，避免无效状态遍历。  
- **常数优化**：预处理 `min(i, n-i)` 减少循环内计算。

---
处理用时：59.93秒
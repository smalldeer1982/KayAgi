# 题目信息

# 谜

## 题目背景

$\text{我需要你给我方向}$

$\text{哪怕要我独自穿过人海茫茫}$

$\text{为了你尝风霜}$

$\text{我流浪远方}$

$\text{需要你给我力量}$

$\text{无论如何我会坚强}$

$\text{只要你给我希望}$

[Source](https://www.kugou.com/song-36/1y5t3b.html)

## 题目描述

在一个大小为 $N$ 的数字三角形中：

- 第 $1$ 行为 $1$；
- 第 $2$ 行为 $2\sim3$；
- 第 $3$ 行为 $4\sim6$；
- 第 $4$ 行为 $7\sim10$；
- $\cdots~\cdots$
- 第 $N$ 行包含 $N$ 个数字，为 $\frac{N(N-1)}{2}+1\sim\frac{N(N+1)}{2}$。

下图展示了一个 $N=5$ 的数字三角形。

![](https://cdn.luogu.com.cn/upload/image_hosting/fpx5rw7l.png)

---

记 $(i,j)$ 表示第 $i$ 行第 $j$ 个数字。

已知 $(i,j)$ 能直接到达 $(i+1,j)$ 或 $(i+1,j+1)$，反之，$(i+1,j)$ 或 $(i+1,j+1)$ 也能直接到达 $(i,j)$。

现在任选一个数字作为起点，求 **连续** 地经过 $K$ 个 **不同** 的数字时，这 $K$ 个数的和的最大值，对 $10^9+7$ 取模。

## 说明/提示

#### 样例说明

对于样例 #1，如题面中的图所示，一种可行的方案是：以 $13$ 为起点，$13\rightarrow9\rightarrow14\rightarrow10\rightarrow15$，和为 $13+9+14+10+15=61$。

### 数据范围

**本题采用捆绑测试。**

| Subtask | 分值 | $N\le$ | $K\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $30$ | $10^3$  |  |
| $2$ | $30$ | $10^6$ |  |
| $3$ | $30$ | $10^9$ | $1$ |
| $4$ | $10$ | $10^9$ |  |

对于 $100\%$ 的数据：$1\le T\le 10^5$，$1\le\color{red}\dfrac{K+1}{2}\le N\color{black}\le10^9$。

## 样例 #1

### 输入

```
1
5 5```

### 输出

```
61```

## 样例 #2

### 输入

```
5
2676 1930
5148 3667
5453 4764
16734806 16332913
26943973 33293903 ```

### 输出

```
909411538
587883333
823595806
727601062
965648555```

# AI分析结果



**算法分类**: 贪心、数学

---

### 综合分析与结论
题目要求从数字三角形中选取连续路径，使得路径和最大。关键点在于数据范围中的 $\frac{K+1}{2} \le N$，这表明路径只能在最后两行之间交替移动，从而保证选到最大的数字。所有题解均基于以下核心思路：
1. **贪心路径**：从最后一行的右下角开始，交替向上一行和当前行的左侧移动。
2. **数学优化**：利用等差数列求和公式快速计算最后两行的数字和，避免遍历。
3. **模运算处理**：通过分步取模和逆元处理除法，防止中间结果溢出。

---

### 精选题解与评分
1. **int32（5星）**
   - **亮点**：简洁的公式推导，分奇偶讨论，代码直接应用等差数列求和公式。
   - **代码核心**：
     ```cpp
     if (k % 2 == 0) {
         ans = (k * (2 * a + 2 * b - k + 2)) / 4 % mod;
     } else {
         ans = (k * (2 * a + 2 * b - k + 1)) / 4 + (a - k / 2) % mod;
     }
     ```

2. **言琢დ（5星）**
   - **亮点**：官方题解，严格证明贪心路径的最优性，强调分步取模和逆元技巧。
   - **关键证明**：反证法说明其他路径无法更优，结合图示直观展示波浪遍历的正确性。

3. **vegetable_king（4星）**
   - **亮点**：利用 `__int128` 处理大数，代码简洁高效，直接计算最后两行和。
   - **代码核心**：
     ```cpp
     __int128 ans = ((n*(n+1)-(k+1)/2+1)*((k+1)/2)/2 + 
                   ((n-1)*n/2 -k/2 +1)*(k/2)/2) % mod;
     ```

---

### 关键技巧总结
1. **贪心路径构造**：从最大元素开始，交替遍历最后两行的右侧元素。
2. **等差数列公式**：利用 $\sum_{i=l}^r i = \frac{(l+r)(r-l+1)}{2}$ 快速求和。
3. **逆元处理除法**：将公式中的除以2替换为乘逆元 $500000004$（即 $2^{-1} \mod 1e9+7$）。

---

### 相似题目推荐
1. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216) - 基础路径选择问题。
2. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002) - 路径动态规划与数学结合。
3. [P1866 灯泡](https://www.luogu.com.cn/problem/P1866) - 贪心与数学公式优化。

---
处理用时：48.95秒
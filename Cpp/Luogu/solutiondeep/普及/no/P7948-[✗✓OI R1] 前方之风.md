# 题目信息

# [✗✓OI R1] 前方之风

## 题目背景

>「不错的恶意。」  
> 女性呵呵笑道。  
>「但是，如果向我发出恶意，你可是会死哦？」

你不知道什么动作会被算作发出恶意，所以你决定做一道题来分散自己的注意力。

## 题目描述

给出一个长度为 $n$ 的序列 $a$ 和 $q$ 个询问，第 $i$ 个询问给出 $k_i$。对于每次询问，你需要进行以下操作：
1. 求出剩下的数的平均数 $\mathit{avg}$。
2. 将剩下的数中 $<\mathit{avg}-k_i$ 的数删去。
3. 重复以上两个步骤直到所有数都不会被删去。
4. 输出最后会剩下几个数。

**注意：询问之间是独立的，也就是说，不会真的删去那些数。**

## 说明/提示

**【样例解释】**

对于第一组样例，当 $k=0$ 时，显然只会留下 $99$。  
当 $k=6$ 时，删除数的步骤如下：
- 平均数为 $60\dfrac{1}{9}$，留下 $99,63,72,97,68$。
- 平均数为 $79.8$，留下 $99,97$。
- 平均数为 $98$，停止删除。

**【数据范围】**

对于 $100\%$ 的数据，满足 $1\leq n,q \le 10^5$，$1\le T \le 10$，$0 \le a_i,k_i \le 10^9$。

| subtask | 特殊数据范围 | 分数 |  时间限制
| :----------: | :----------: | :----------: |  :----------: |
| 1 | $n,q \le 200$ | 20 |   300ms 
| 2 | $n,q \le 2000$ | 30  | 300ms
| 3 |  | 50 | 800ms|

>「不错的恶意。」  
> 女性呵呵笑道。  
>「而且你运气很不错，如果放在以前，你早就死了。」

![](https://cdn.luogu.com.cn/upload/image_hosting/6icoj36r.png)

## 样例 #1

### 输入

```
5
9 9
19 99 63 39 72 46 97 38 68 
0 6 4 0 7 1 0 3 6 
6 8
88 62 48 50 8 47 
0 6 1 5 2 2 6 1 
6 5
33 3 54 17 26 64 
87 89 92 70 59 
18 19
71 52 77 38 12 34 82 14 57 39 91 7 56 86 35 68 38 14 
9 9 1 5 1 3 4 5 6 1 6 0 3 0 2 1 3 5 8 
10 15
4 77 78 76 5 19 98 94 77 81 
17 43 4 86 2 91 85 4 81 74 44 16 21 69 32 
```

### 输出

```
1 2 2 1 2 2 1 2 2
1 1 1 1 1 1 1 1
6 6 6 6 6
4 4 1 3 1 2 2 3 3 1 3 1 2 1 1 1 2 3 4
7 7 2 10 2 10 10 2 10 10 7 7 7 10 7
```

## 样例 #2

### 输入

```
1
5 1
20 0 0 0 0
5```

### 输出

```
5```

# AI分析结果



### 算法分类
**排序 + 贪心 + 离线处理**

---

### 题解综合分析
**核心思路**：  
1. **排序预处理**：将原数组排序后，删除的数必然是连续的前缀，转化为求合法后缀的最小左端点。
2. **离线处理询问**：将询问按 $k$ 值从大到小排序，利用答案的单调性（$k$ 越大，剩余数越多），通过双指针逐步确定合法后缀。
3. **后缀和优化**：预处理后缀和，快速计算任意后缀的平均值。

**关键难点**：  
- 发现删除顺序的单调性（排序后只需处理前缀）。
- 离线处理与双指针的结合（$O(n+q)$ 处理所有询问）。

---

### 高星题解推荐

#### 1. [xzyg] ⭐⭐⭐⭐
**核心亮点**：  
- 离线排序 + 双指针扫描，时间复杂度 $O(n \log n + q \log q)$。
- 代码结构清晰，预处理后缀和与平均值数组。
- **调试经验**：被 hack 后修正边界条件，强调对浮点比较的严谨性。

**关键代码**：
```cpp
sort(a+1,a+1+n); sort(k+1,k+1+q,cmp1); // 原数组和询问排序
for (int i = n; i >= 1; --i) add[i] += add[i+1] + a[i]; // 后缀和
int p = 1, sum = n;
for (int i = 1; i <= n && p <= q;) {
    while (a[i] < avg[i] - k[p].val) ++i; // 双指针移动
    k[p].ans = n - i + 1; p++;
}
```

#### 2. [AsunderSquall] ⭐⭐⭐⭐
**核心亮点**：  
- 详细数学证明（合法后缀的单调性），给出严格性质推导。
- 使用结构体离线处理，代码模块化，便于维护。
- **思维突破**：提出“稳定序列”概念，明确终止条件。

**关键代码**：
```cpp
sort(c+1,c+q+1,cmp); // 按k从大到小排序
int pos = 1;
for (int i = 1; i <= q; i++) {
    while (pos <= n && a[pos] < (sum - pre)/(n - pos + 1) - k[i]) 
        pos++; // 动态调整合法后缀
    ans[i] = n - pos + 1;
}
```

#### 3. [青鸟_Blue_Bird] ⭐⭐⭐⭐
**核心亮点**：  
- 极简双指针实现，直接在排序后数组上操作。
- 预处理前缀和，避免重复计算。
- **优化技巧**：通过离线排序消除二分带来的额外复杂度。

**关键代码**：
```cpp
sort(s + 1, s + q + 1, cmp); // 按k降序处理询问
int l = 1;
for (int id = 1; id <= q; id++) {
    while (l <= n && a[l] < (sum[n] - sum[l-1])/(n - l + 1) - k[s[id]])
        l++; // 移动左端点
    ans[s[id]] = n - l + 1;
}
```

---

### 关键优化总结
1. **排序与单调性**：排序后只需处理连续前缀，结合 $k$ 的单调性实现线性扫描。
2. **后缀和快速计算**：预处理后缀和数组，$O(1)$ 计算任意后缀的平均值。
3. **离线双指针**：离线处理询问，避免重复遍历数组，将整体复杂度优化至 $O(n + q)$。

---

### 拓展练习
1. **[P2678 跳石头](https://www.luogu.com.cn/problem/P2678)**：二分答案 + 贪心验证。
2. **[P1090 合并果子](https://www.luogu.com.cn/problem/P1090)**：贪心 + 优先队列。
3. **[P3513 秘密文件](https://www.luogu.com.cn/problem/P3513)**：离线处理 + 双指针优化。

---
处理用时：66.10秒
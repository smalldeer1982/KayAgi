# 题目信息

# 简单数列

## 题目描述

给你一个数 $n$，你需要求出一个长度为 $n$ 的数组 $a$，（下标从 $1$ 开始，且元素都为 $1,2,3$ 或 $4$），使得：

* 对于第 $i$ 个数，对于所有的 $1 \le len \le \lfloor\frac{i}{2}\rfloor$, $a_{i-len+1\dots i}$ 与 $a_{i-len\times2+1\dots i-len}$ 不相同。（$\lfloor x \rfloor$ 表示对 $x$ 下取整）

* 说人话，就是没有任何连续的连续子串相同。

## 说明/提示

对于 $20\%$ 的数据，满足 $1 \le n \le 10$；

对于 $40\%$ 的数据，满足 $1 \le n \le 30$；

对于 $100\%$ 的数据，满足 $1 \le n \le 500$。

## 样例 #1

### 输入

```
3```

### 输出

```
1 2 3```

## 样例 #2

### 输入

```
6```

### 输出

```
1 2 3 4 1 3```

# AI分析结果



### 算法分类
**构造、深度优先搜索 DFS**

---

### 综合分析与结论
题目要求构造一个满足特定条件的数列，核心难点在于避免任意长度的连续重复子串。各题解主要采用两种思路：  
1. **DFS+剪枝**：逐步填入数字并检查局部合法性，通过回溯快速排除无效路径。  
2. **构造法**：通过贪心或模式生成序列，每次添加最小合法数字避免回溯。  

DFS 方法通过局部检查（仅验证新增位置可能引发的重复）保证高效性；构造法则通过规律性填充减少回溯。两类方法均需高效的条件检查函数。

---

### 精选题解与评分

#### 1. 作者：__shadow__（⭐⭐⭐⭐）  
**关键亮点**  
- 清晰的剪枝逻辑，仅检查新增位置引发的重复。  
- 代码简洁，回溯与终止条件处理得当。  
**核心代码**  
```cpp
bool check(int x) {
    for(int i=1; i*2<=x; i++) {
        bool flag = 0;
        for(int j=1; j<=i; j++)
            if(a[x-j+1] != a[x-i-j+1]) flag=1;
        if(!flag) return false;
    }
    return true;
}
```
**实现思想**：每次填入新数字时，仅验证以当前结尾的所有可能重复子串对，避免全盘检查。

#### 2. 作者：_zyx（⭐⭐⭐⭐）  
**关键亮点**  
- 贪心构造，循环尝试填入1-4，避免回溯。  
- 通过字符串操作简化子串比较。  
**核心代码**  
```cpp
bool check(char ch) {
    string ss = s + ch;
    int k = ss.size()-1;
    for(int len=1; len<=k/2; len++)
        if(ss.substr(k-len+1, len) == ss.substr(k-len*2+1, len))
            return false;
    return true;
}
```
**实现思想**：维护当前字符串，每次添加新字符后仅检查新增的末尾子串是否合法。

#### 3. 作者：Composite_Function（⭐⭐⭐⭐）  
**关键亮点**  
- 代码结构简洁，剪枝逻辑明确。  
- 注释清晰，便于理解回溯流程。  
**个人心得**：强调在输出后立即终止程序（`exit(0)`），避免冗余回溯。

---

### 最优技巧总结
- **局部检查剪枝**：仅验证新增位置可能引发的重复，避免全盘扫描。  
- **贪心构造**：按固定顺序尝试填入数字，利用循环减少回溯次数。  
- **字符串辅助**：通过子串比较函数简化重复判断逻辑。

---

### 拓展与相似题目
1. **P1706 全排列问题**（DFS剪枝）  
2. **P1019 单词接龙**（字符串构造与局部验证）  
3. **P1036 选数**（组合生成与条件检查）

---
处理用时：108.99秒
# 题目信息

# 模法问题

## 题目背景

简单题，无背景。

## 题目描述

你有两个正整数 $a,b$。

你还有一个正整数 $q$，你要执行 $q$ 次询问。

对于每一次询问，你得到两个正整数 $l,r$。

你需要求出求 $\max\{(i \bmod a)+(i \bmod b) \}$，其中 $i$ 是正整数且 $i \in [l,r] $。

## 说明/提示

对于 $30\%$ 的数据，满足 $1\le q\le10^3$，$1 \le l \le r \le 10^3$；

对于 $70\%$ 的数据，满足 $1\le q\le10^3$，$1 \le l \le r \le 10^9$；

对于 $100\%$ 的数据，满足 $1\le a,b\le 10^3$，$1\le q\le10^5$，$1 \le l \le r \le 10^9$。

## 样例 #1

### 输入

```
5 7
4
1 5
5 7
33 34
34 35```

### 输出

```
8
7
10
10```

# AI分析结果



**算法分类**：数学

---

### 综合分析与结论
题目核心在于利用模运算的周期性，将大区间问题转化为循环节内的最值查询。各题解主要思路可分为两类：
1. **数学性质+候选点枚举**：当区间跨越循环节时直接取理论最大值，否则枚举余数边界点及端点。
2. **预处理循环节+数据结构**：预处理循环节内的最值（如 ST 表/线段树），快速处理区间查询。

---

### 高星题解推荐

#### 1. **Lawrenceling（5 星）**
**关键亮点**：
- 利用 ST 表预处理循环节内的所有可能值的最值，查询时间复杂度 O(1)。
- 简洁处理区间映射与跨越问题，代码清晰高效。
**核心代码**：
```cpp
int main() {
    scanf("%d%d%d",&a,&b,&q);
    int lcm = a*b/__gcd(a,b);
    // 预处理ST表
    for(int i=0;i<lcm;++i) st[i][0] = i%a + i%b;
    for(int j=1;j<=25;++j)
        for(int i=0;i + (1<<j) <= lcm; ++i)
            st[i][j] = max(st[i][j-1], st[i + (1<<(j-1))][j-1]);
    // 查询处理
    while(q--) {
        if(r-l+1 >= lcm) printf("%d\n", Query(0, lcm-1)); // 覆盖循环节
        else {
            l %= lcm, r %= lcm;
            if(l <= r) printf("%d\n", Query(l, r));
            else printf("%d\n", max(Query(l, lcm-1), Query(0, r)));
        }
    }
}
```

#### 2. **sgl654321（4 星）**
**关键亮点**：
- 详细推导 ST 表预处理逻辑，明确分治思想。
- 处理循环节内区间拆分的边界情况，覆盖所有可能。
**实现思路**：
预处理循环节长度的 ST 表，分情况处理区间是否跨越循环节，将大区间映射到循环节内求最值。

#### 3. **Jairon314（4 星）**
**关键亮点**：
- 代码简洁，直接利用 ST 表处理循环节映射。
- 通过取模压缩区间，高效解决大范围查询问题。
**核心思路**：
预处理循环节内每个位置的模和，将查询区间映射到循环节内后，用 ST 表快速求最值。

---

### 最优关键技巧
1. **循环节压缩**：发现模运算的周期性，将大区间问题转化为固定长度循环节内的最值问题。
2. **ST 表预处理**：以 O(N log N) 时间预处理循环节内区间最值，支持 O(1) 查询。
3. **边界处理**：将区间映射到循环节内时，分是否跨越循环节两种情况处理，避免复杂计算。

---

### 拓展与相似题目
1. **P1972 [SDOI2009] HH的项链**（区间去重计数，需压缩或离线处理）
2. **P1198 [JSOI2008] 最大数**（区间最值，ST 表/线段树模板）
3. **P3865 【模板】ST 表**（区间最值预处理基础）

---
处理用时：66.40秒
# 题目信息

# 「GLR-R3」立春

## 题目背景

&emsp;&emsp;「从此雪消风自软，梅花合让柳条新」

---

&emsp;&emsp;“明天就要返校了呢。”

&emsp;&emsp;灰色的长发被身后的人儿慢慢地顺着，顺着，于假期最后一个慵懒的清晨醒来，与春日的第一抹阳光迷迷糊糊地耳语，她的目光随着点过窗外的鸟雀，停留在那丛褐色的光秃枝丫。

&emsp;&emsp;“天依？”

&emsp;&emsp;赤红色的眸子随之望去，片刻，静默。

&emsp;&emsp;“如果我能告诉它，今天是立春，是春天的……”

&emsp;&emsp;“那么它会抽芽，繁盛，会成为我们窗外或红或绿的美妙。”

&emsp;&emsp;“——因为它本该如此，希望如此吧。”

---

&emsp;&emsp;**立春**&emsp;「雏鸟站在悬崖上　展开了翅膀　地平线上的梦想　照进一缕光」


## 题目描述

由于天依刚睡醒，害怕第一题的题面就迷糊了大家，所以本题只有简要题意。~~（其实是实在编不下去了。）~~

设 $\sigma$ 为任意一个长度为 $n$ 的排列，$\tau(\sigma)$ 表示其中的逆序对个数，请求出

$$
\sum_\sigma 2^{\tau(\sigma)}
$$

对 $(10^9+7)$ 取模的结果。

## 说明/提示

#### 题意解释

本节为部分选手介绍**逆序对的定义**，对此熟悉的选手可以跳过本节。

对于长度为 $n$ 的排列 $\sigma$，假设下标从 $1$ 开始，那么我们称 $(i,j)$ 构成逆序对，当且仅当 $1\le i<j\le n$，并且 $\sigma_i>\sigma_j$；$\tau(\sigma)$ 则表示总共有多少对不同的 $(i,j)$ 满足上述条件。

举个例子，对于排列 $\sigma=\lang 2,4,1,3\rang$，有逆序对 $(1,3),(2,3),(2,4)$，所以 $\tau(\sigma)=3$。可见只要 $\sigma$ 中元素的大小关系确定，$\tau(\sigma)$ 就是确定的。

#### 样例 #1 解释

$$
\begin{aligned}
\sum_{\sigma}2^{\tau(\sigma)} &= 2^{\tau(\lang 1,2,3\rang)}+2^{\tau(\lang 1,3,2\rang)}+2^{\tau(\lang 2,1,3\rang)}+2^{\tau(\lang 2,3,1\rang)}+2^{\tau(\lang 3,1,2\rang)}+2^{\tau(\lang 3,2,1\rang)}\\
&= 2^0+2^1+2^1+2^2+2^2+2^3\\
&= 21.
\end{aligned}
$$

### 数据规模与约定

**本题采用 Subtask 的计分方式。**

| 子任务编号 |    $n$    | 分值 |
| :--------: | :-------: | :--: |
|    $1$     |  $\le4$   | $5$  |
|    $2$     |  $\le10$  | $20$ |
|    $3$     | $\le100$  | $20$ |
|    $4$     | $\le10^3$ | $25$ |
|    $5$     | $\le10^7$ | $30$ |



## 样例 #1

### 输入

```
3```

### 输出

```
21```

# AI分析结果



**算法分类**: 递推、数学

**综合分析与结论**  
本题的核心在于发现排列逆序对数目与2的幂次之和的递推关系。通过数学推导，得出答案等于所有(2^i-1)的乘积。这一结论可基于排列结构的分解与等比数列求和得出，最终实现O(n)的线性递推解法。

---

**精选题解列表**

1. **Rainybunny（★★★★★）**  
   - **关键亮点**: 清晰的递推公式推导，代码简洁高效。  
   - **核心思路**: 通过排列的结构分解，将问题转化为等比数列求和，得到递推式f(i)=(2^i-1)*f(i-1)。  
   - **代码片段**:  
     ```cpp
     int main() {
         int n, ans = 1, pwr = 1;
         scanf("%d", &n);
         for (int i = 1; i <= n; ++i) {
             (pwr <<= 1) >= MOD && (pwr -= MOD);
             ans = ans * (pwr - 1ll) % MOD;
         }
         printf("%d\n", ans);
         return 0;
     }
     ```

2. **Joker_1212（★★★★☆）**  
   - **关键亮点**: 数学归纳法验证递推式，代码可读性强。  
   - **核心思路**: 通过数学归纳法证明递推关系，维护动态的2的幂次变量。  
   - **代码片段**:  
     ```cpp
     ll ans = 1, power = 1;
     while (n--) {
         power <<= 1;
         power %= mod;
         ans = ans * (power - 1) % mod;
     }
     ```

3. **xiaohaoaibiancheng66（★★★★☆）**  
   - **关键亮点**: 通过排列插入位置分析贡献，直观呈现递推过程。  
   - **核心思路**: 每次插入新元素时，分析不同位置带来的逆序对增量，利用乘法原理累乘结果。  

---

**最优关键思路**  
将排列分解为逐步插入元素的过程，每一步的贡献为(2^i-1)的乘积。通过维护动态的2的幂次变量，实现线性时间复杂度计算。

**拓展应用**  
类似递推结构的问题（如错位排列计数、组合数乘积）均可尝试分解子问题，寻找数学规律。推荐题目：  
1. [P1338 末日的传说](https://www.luogu.com.cn/problem/P1338)（逆序对构造）  
2. [P1495 组合数问题](https://www.luogu.com.cn/problem/P1495)（递推优化）  
3. [P1595 信封问题](https://www.luogu.com.cn/problem/P1595)（错排公式推导）  

**调试心得**  
- 注意模运算的负数处理，如`(2^i-1)`需写成`(pwr - 1 + MOD) % MOD`。  
- 避免使用快速幂导致超时，迭代维护2的幂次是关键优化点。

---
处理用时：55.59秒
# 题目信息

# Bassline

## 题目背景

fuwa↑ fuwa↑ fuwa↑ fuwa↑

赫尔德开始使用当下热潮的聊天软件 BassLine，那么第一步自然是加好友了！加好友既需要确认自己和对方有共同兴趣，又需要能加到足够多的好友。赫尔德将其抽象成了下面这个问题，让你来帮她解决。

## 题目描述

本题中，区间 $[l,r]$ 指所有大于等于 $l$ 且小于等于 $r$ 的整数组成的集合，如 $[3,3]$ 代表 $\{3\}$，$[3,7]$ 代表 $\{3,4,5,6,7\}$。

给定 $n$ 个区间，第 $i$ 个区间是 $[l_i,r_i]$。

你需要选择两个整数 $x\le y$，满足：

- 对于所有区间 $[l_i,r_i]$（$1\le i \le n$），以下两个条件之一满足：
	1. $[x,y]$ 被 $[l_i,r_i]$ 包含，换言之， $[x,y]\cap[l_i,r_i]=[x,y]$。
    2.  $[x,y]$ 与 $[l_i,r_i]$ 无交集，换言之，$[x,y]\cap[l_i,r_i]=\varnothing$。

若有 $k$ 个区间满足条件 1，则你的得分是 $k(y-x)$。输出你最大的可能的得分。

## 说明/提示

**【样例解释】**

对于样例，$[5,6]$ 是最优的区间之一，其含于 $[4,7],[5,9]$，且与 $[1,3],[7,10]$ 没有交集。此时 $k=2$，因此答案为 $2\times(6-5)=2$。$[1,3]$ 也是一个最优的区间。

$[5,7]$ 并非合法的区间，因为它与 $[7,10]$ 有交集，也并不含于 $[7,10]$。

---

**【数据范围】**

对于所有数据保证 $1 \le n \le 3 \times {10}^5$，$1 \le l_i \le r_i \le 3 \times {10}^5$。

- 子任务 1（20 分）：$n,l_i,r_i \le 10$；
- 子任务 2（20 分）：$n \le {10}^3$；
- 子任务 3（20 分）：$l_i, r_i \le {10}^3$；
- 子任务 4（40 分）：无特殊限制。

## 样例 #1

### 输入

```
4
1 3
4 7
5 9
7 10
```

### 输出

```
2
```

# AI分析结果



**算法分类**: 差分、贪心

---

### 题解综合分析

所有题解的核心思路均基于以下观察：合法的区间 $[x,y]$ 必须满足其内部不包含任何原区间的端点（左端点或右端点）。通过差分数组统计每个点被覆盖的次数，并利用贪心思想遍历所有可能的合法区间，结合端点标记快速计算最大值。

---

### 精选题解与评分

#### 1. **作者：dottle（★★★★★）**
- **关键亮点**：  
  1. 将原区间左端点左移一位，转化为区间端点问题，简化条件判断。  
  2. 使用差分数组快速统计覆盖次数，结合端点标记遍历所有可能的合法区间。  
- **代码实现**：
  ```cpp
  int f[N], v[N], mx, pre=1, sum, ans;
  for (int i=1; i<=n; i++) {
      scanf("%lld%lld", &x,&y);
      v[x-1] = 1, v[y] = 1; // 标记端点
      f[x]++, f[y+1]--;     // 差分统计覆盖次数
  }
  for (int i=1; i<=mx; i++) {
      sum += f[i];
      if (v[i]) {           // 遇到端点时计算答案
          ans = max(ans, sum*(i-pre));
          pre = i+1;
      }
  }
  ```

#### 2. **作者：Lyccrius（★★★★☆）**
- **关键亮点**：  
  1. 详细推导合法区间的充要条件，并通过图示辅助理解。  
  2. 代码中显式处理边界，避免数组越界问题。  
- **个人心得**：  
  > “数组需开全局，否则会 WA。交了 17 遍才过。” —— 强调数据规模对内存的影响。

#### 3. **作者：if_OF（★★★★☆）**
- **关键亮点**：  
  1. 使用结构体记录每个点的起点和终点出现次数。  
  2. 通过双指针维护合法区间的长度和覆盖数。  
- **代码片段**：
  ```cpp
  int cnt = 0, k = 0, ans = 0;
  for (int i=left; i<=right; i++) {
      if (x[i].beg || x[i-1].end) cnt = 0; // 端点重置区间
      k += x[i].beg; // 统计覆盖数
      ans = max(ans, cnt * k);
      k -= x[i].end;
  }
  ```

---

### 最优思路总结
- **端点分割**：将原区间的左端点左移一位，转化为新的端点集合，合法区间只能出现在相邻端点之间。  
- **差分优化**：用差分数组高效统计每个点被覆盖的次数，避免暴力枚举。  
- **贪心遍历**：遍历所有可能的合法区间段，结合前缀和快速计算得分，时间复杂度 $O(n)$。

---

### 拓展与相似题目
1. **P1884 [USACO12FEB] Overplanting S**（区间覆盖统计）  
2. **P3406 海底高铁**（差分+贪心优化路径）  
3. **P1719 最大加权矩形**（二维前缀和与区间最值）

---
处理用时：52.32秒
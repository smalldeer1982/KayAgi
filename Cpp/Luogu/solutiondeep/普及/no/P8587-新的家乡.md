# 题目信息

# 新的家乡

## 题目背景

2102 年，太阳系的生态终于不再支持人类的生存。人类打算沿着之前建好的星际长途路线去往金牛座蟹状星云中的某行星 $\beta$ 谋求发展。


## 题目描述

你作为第一批科研人员，提前来到了 $\beta$ 星建造基地。

$\beta$ 星盛产锰钛矿石。基地需要一些**高度相同**的柱子，而每根柱子都需要由**恰好**两根锰钛矿石顺次连接组成。例如，若你有两根高度分别为 $h_x,h_y$ 的锰钛矿石，那么你可以用两者合成为一根高度为 $h_x+h_y$ 的柱子。每根锰钛矿石**显然至多被使用一次**。

现在你来到了 $\beta$ 星的锰钛矿场，摆在你面前的是 $n$ 根高度分别为 $h_i$ 的锰钛矿石。经过严密思考后你发现，房屋的牢固程度应该取决于柱子的数目，而不是柱子的高度。所以你想知道，使用面前这 $n$ 根矿石最多可以建造出多少根高度相同的柱子？

但小花觉得这个问题太 easy 了，于是 ta 选择多问你一嘴：假设柱子高度均为 $h$，基地最多可以建出 $\mathrm{res}$ 根柱子，那么在柱子数目同为 $\mathrm{res}$ 时 $h$ 可以有几种不同的取值？

## 说明/提示

额外样例见附加文件 `ex.in/out`。

对于 $20\%$ 的数据，$1\leq n\leq 100$。

对于 $40\%$ 的数据，$1\leq n \leq 10^3$。

对于 $70\%$ 的数据，$1\leq n\leq 10^5$。

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$1\leq h_i \leq 3\times 10^3$。


## 样例 #1

### 输入

```
4
4 7 6 5```

### 输出

```
2 1```

## 样例 #2

### 输入

```
6
1 1000 100 1500 10 1800```

### 输出

```
1 15```

# AI分析结果



**算法分类**：枚举

---

### **综合分析与结论**
题目要求用两两矿石组合成等高的柱子，求最大数量及对应高度种数。由于矿石高度范围较小（≤3e3），各题解均采用桶计数+枚举可能的柱子高度，时间复杂度为O(max_h²)。核心难点在于避免重复统计矿石对，正确计算贡献。

---

### **精选题解推荐**

1. **xixisuper的题解（★★★★★）**  
   **关键亮点**：  
   - 详细对比两种暴力思路，解释解法二的正确性。  
   - 枚举时遍历到i/2避免重复，处理相同高度的特判。  
   **代码核心**：  
   ```cpp
   for (int i = 1; i <= 6000; i++) {
       int now_res = 0;
       for (int j = 0; j + j <= i; j++) {
           if (j * 2 == i) now_res += vis[j] / 2; // 相同高度特判
           else now_res += min(vis[j], vis[i - j]); // 不同高度取min
       }
       // 更新最大值及方案数
   }
   ```

2. **Albert_Wei的题解（★★★★☆）**  
   **关键亮点**：  
   - 代码简洁，优化j的枚举范围为max(i-3000,0)，减少无效计算。  
   - 显式处理偶数情况的中心点。  
   **代码核心**：  
   ```cpp
   for (int i = 1; i <= 6000; i++) {
       int sum = 0;
       for (int j = max(i - 3000, 0); j <= (i - 1) / 2; j++)
           sum += min(cnt[j], cnt[i - j]);
       if (i % 2 == 0) sum += cnt[i / 2] / 2; // 偶数特判
   }
   ```

3. **bloodstalk的题解（★★★★☆）**  
   **关键亮点**：  
   - 通过双重循环直接统计所有可能的和，思路直观。  
   - 使用排序快速找到最大值及对应数量。  
   **代码核心**：  
   ```cpp
   for (int i = Min * 2; i <= Max * 2; i++) {
       for (int j = 1; j <= i / 2; j++) {
           if (j * 2 == i) f[i] += mp[j] / 2;
           else f[i] += min(mp[j], mp[i - j]);
       }
   }
   sort(f, f + Max * 2 + 1, greater<int>());
   ```

---

### **最优思路总结**
1. **桶计数优化**：用数组统计各高度矿石出现次数，避免遍历原始数据。  
2. **枚举范围控制**：遍历可能的柱子高度时，内层循环仅枚举到当前高度的一半，避免重复统计。  
3. **特判相同高度**：当两矿石高度相同时，贡献值为该高度矿石数的一半。

---

### **同类题目推荐**
1. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102)（枚举差值统计）  
2. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)（滑动窗口+桶计数）  
3. [P2671 求和](https://www.luogu.com.cn/problem/P2671)（数学性质+枚举优化）  

---

### **调试心得摘录**
- **xixisuper**提到“遇题不决，暴力美学”，强调在数据范围小时优先考虑暴力枚举。  
- **Lovely_Elaina**的初始代码因未控制j的枚举范围导致重复统计，提醒需仔细验证边界条件。

---
处理用时：101.43秒
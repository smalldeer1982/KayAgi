# 题目信息

# [蓝桥杯 2014 省 AB] 地宫取宝

## 题目描述

X 国王有一个地宫宝库。是 $n \times m$ 个格子的矩阵。每个格子放一件宝贝。每个宝贝贴着价值标签。

地宫的入口在左上角，出口在右下角。

小明被带到地宫的入口，国王要求他只能向右或向下行走。

走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。

当小明走到出口时，如果他手中的宝贝恰好是 $k$ 件，则这些宝贝就可以送给小明。

请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 $k$ 件宝贝。

## 说明/提示

时限 1 秒, 256M。蓝桥杯 2014 年第五届省赛

## 样例 #1

### 输入

```
2 2 2
1 2
2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 2
1 2 3
2 1 5```

### 输出

```
14```

# AI分析结果



### 算法分类
动态规划

---

### 综合分析与结论
本题需记录当前位置、已取宝物数量、当前最大价值三个关键状态，属于典型的多维状态动态规划问题。题解主要分为两类实现方式：
1. **记忆化搜索**：通过递归遍历路径，用四维数组缓存状态结果（坐标x,y、当前最大价值、已取数量），避免重复计算。
2. **递推动态规划**：直接定义四维DP数组，通过双层循环递推状态转移。两种方法本质相同，核心在于状态设计与转移方程。

---

### 高星题解推荐
1. **Nathan123的DP题解（5星）**
   - **关键亮点**：清晰定义四维状态数组`dp[i][j][k][c]`，明确状态转移方程，代码结构简洁高效。
   - **核心代码思想**：
     ```cpp
     int dp[N][N][13][14]; // dp[i][j][k][c]: 走到(i,j)取k个宝物，最大价值为c的方案数
     for (i,j)遍历网格：
         for (k=0; k<=K; k++):
             for (c=0; c<=13; c++):
                 // 不取当前宝物：从上方或左方转移
                 dp[i][j][k][c] += dp[i-1][j][k][c] + dp[i][j-1][k][c];
                 // 取当前宝物：需满足c > 当前宝物价值，从更小c值转移
                 if (c == w[i][j]):
                     for (prev_c < c):
                         dp[i][j][k][c] += dp[i-1][j][k-1][prev_c] + dp[i][j-1][k-1][prev_c];
     ```

2. **_cpp的记忆化搜索题解（4星）**
   - **关键亮点**：对比暴力与优化代码，直观展示记忆化优势，处理终点特判逻辑清晰。
   - **核心代码思想**：
     ```cpp
     int dfs(x, y, maxV, num) {
         if (缓存命中) return cache[x][y][maxV+1][num];
         if (到达终点) 判断num是否符合条件;
         // 分四种状态递归：右/下方向，取/不取宝物
         res += dfs(右/下, 不取) + dfs(右/下, 取（若可拿）);
         缓存结果并返回;
     }
     ```

3. **Angelastar的记忆化搜索题解（4星）**
   - **个人心得**：强调`maxV+1`避免负数下标，通过注释提醒初始化细节。

---

### 最优关键思路
**四维状态设计**：以`(x,y)`表示位置，`num`表示已取数量，`maxV`表示当前最大价值，通过递推或递归枚举每一步的两种选择（取/不取），结合状态转移剪枝无效路径。记忆化搜索通过缓存已计算状态将复杂度从指数级降至O(n*m*k*C)（C为价值范围）。

---

### 拓展与相似题目
- **同类型题**：路径问题中记录多维状态，如：
  - [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)（二维路径+双物品数）
  - [P1434 滑雪](https://www.luogu.com.cn/problem/P1434)（记忆化搜索经典）
- **类似套路**：状态压缩动态规划，如背包问题变种、有限状态自动机。

---

### 推荐练习
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)  
2. [P1434 滑雪](https://www.luogu.com.cn/problem/P1434)  
3. [P3958 NOIP2017 奶酪](https://www.luogu.com.cn/problem/P3958)  

---

### 题解代码摘录
**Nathan123的DP核心代码**  
完整状态转移逻辑，清晰体现递推关系：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (i == 1 && j == 1) continue; // 跳过初始化点
        for (int u = 0; u <= k; u++) {
            for (int v = 0; v <= 13; v++) {
                // 不取当前宝物的转移
                val = (val + dp[i-1][j][u][v]) % MOD;
                val = (val + dp[i][j-1][u][v]) % MOD;
                // 取当前宝物的转移（需满足条件）
                if (u > 0 && v == w[i][j]) {
                    for (int c = 0; c < v; c++) {
                        val = (val + dp[i-1][j][u-1][c]) % MOD;
                        val = (val + dp[i][j-1][u-1][c]) % MOD;
                    }
                }
            }
        }
    }
}
```

---
处理用时：90.48秒
# 题目信息

# [蓝桥杯 2014 国 A] 排列序数

## 题目描述

如果用 a b c d 这 $4$ 个字母组成一个串，有 $4!=24$ 种，如果把它们排个序，每个串都对应一个序号：

```text
  abcd  0
  abdc  1
  acbd  2
  acdb  3
  adbc  4
  adcb  5
  bacd  6
  badc  7
  bcad  8
  bcda  9
  bdac  10
  bdca  11
  cabd  12
  cadb  13
  cbad  14
  cbda  15
  cdab  16
  cdba  17
  ...
```

现在有不多于10个两两不同的小写字母，给出它们组成的串，你能求出该串在所有排列中的序号吗？


## 说明/提示

时限 1 秒, 256M。蓝桥杯 2014 年第五届国赛

## 样例 #1

### 输入

```
bdca```

### 输出

```
11```

## 样例 #2

### 输入

```
cedab```

### 输出

```
70```

# AI分析结果



### 分类
组合数学

### 综合分析与结论
题目核心是求排列的字典序序号，本质是康托展开问题。题解主要分两类：暴力全排列枚举（O(n!)）和康托展开（O(n²)）。康托展开在效率和代码简洁性上全面优于暴力枚举，是该题的最优解法。

---

### 精选题解

#### 1. 作者：Asimplename（★★★★★）
**关键亮点**  
- 直接应用康托展开公式，代码简洁清晰  
- 时间复杂度 O(n²)，完美应对 n=10 的极限情况  
**核心代码**  
```cpp
for(int i = 0; i < n; i++) {
    int small = 0;
    for(int j = i + 1; j < n; j++) {
        if(str[j] < str[i]) small++; 
    }
    ans += cal(n - i - 1) * small; // cal计算阶乘
}
```

#### 2. 作者：哈士奇憨憨（★★★★☆）
**关键亮点**  
- 引入标记数组优化字符判重  
- 预处理阶乘提升效率  
**核心实现**  
```cpp
for(int i = n - 1; i >= 0; i--) {
    x = a[n - i - 1] - 'a' + 1;
    for(int j = 1; j < x; j++) { 
        s += !b[j] * v[i]; // v[i]为预处理阶乘
    }
    b[x] = 1;
}
```

#### 3. 作者：nullqtr_pwp（★★★☆☆）
**思路参考**  
- 离散化后套用康托模板  
- 引入树状数组优化查找  
**代码亮点**  
```cpp
// 离散化后使用树状数组求逆序数
for(int i=1; i<=n; i++) {
    ans += (query(a[i]-1) * fc[n-i]) % mod;
    add(a[i], -1, n); // 树状数组更新
}
```

---

### 关键技巧总结
**康托展开核心思想**  
对于排列中的每个元素，统计其右侧比它小的元素个数，乘以剩余位数的阶乘，累加所有位的贡献值。  
**优化点**  
- 预处理阶乘数组  
- 使用标记数组或树状数组快速统计可用元素  

---

### 相似题目推荐
1. [P5367 康托展开](https://www.luogu.com.cn/problem/P5367)  
2. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)  
3. [P3014 Cow Line S](https://www.luogu.com.cn/problem/P3014)  

---

### 心得摘录
> "康托展开的本质是排列与自然数的双射，当题目出现排列序号相关问题时，应第一时间想到该算法。" —— 哈士奇憨憨  
> "暴力枚举虽然直观，但在阶乘复杂度下容易超时，学会康托展开是此类问题的关键突破点。" —— Asimplename

---
处理用时：51.87秒
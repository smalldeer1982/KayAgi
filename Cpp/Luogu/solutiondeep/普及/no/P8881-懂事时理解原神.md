# 题目信息

# 懂事时理解原神

## 题目背景

胡桃喜欢用 dfs 求最短路，尽管这有可能会得到错误的答案。

![](https://img2.huashi6.com/images/resource/2021/03/01/8812956h7p1.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)

画师 pid：6657532

## 题目描述

具体地，给定一个有 $n$ 个点和 $m$ 条边的无向无权图。则 dfs 求最短路的算法伪代码具体如下：

```
vis[], dis[]
dfs(u):
	vis[u] = 1
	记所有满足 u,v 之间有边且 !vis[v] 的点 v 构成的序列为 S
	以随机的顺序遍历 S: 
		dis[v] = dis[u] + 1
		dfs(v)
solve():
	for i in [1, n]: 
    	dis[i] = -1;
        vis[i] = 0
	dis[1] = 0
	dfs(1)
```

其中，```以随机的顺序遍历 S``` 可以被理解为随机打乱 $S$，得到每一种结果的概率均为 $\frac{1}{|S|!}$，并按照打乱后的顺序遍历。

现在，胡桃想要知道，如果她调用函数 ```solve()```，得到的最短路数组 ```dis[]``` 完全正确的概率有多大。```dis[]``` 被认为完全正确，当且仅当 $\forall i\in[1,n]$，```dis[i]``` 的值均等于从 $1$ 到 $i$ 的最短路长度（特别地，若 $1$ 无法走到 $i$，则认为 $1$ 到 $i$ 的最短路长度为 $-1$）。

## 说明/提示

- 对于 $20\%$ 的数据，$n,m\le 10$。
- 对于 $50\%$ 的数据，$n,m\le 1000$。
- 对于另外 $30\%$ 的数据，保证所给出的图为一仙人掌（任意一条边至多只出现在一条环上）。
- 对于 $100\%$ 的数据，$1\le n,m\le 50000，1\le T\le 10$，保证所输入的图无重边、自环。

## 样例 #1

### 输入

```
1
5 4
1 3
1 2
3 4
2 5```

### 输出

```
1.000```

## 样例 #2

### 输入

```
1
4 4
1 2
2 3
3 1
4 3```

### 输出

```
0.000```

# AI分析结果



**算法分类**: 图论（DFS判环）

**综合分析结论**  
本题核心是判断与起点1连通的子图是否存在环。所有题解均基于以下关键观察：当且仅当1号点所在连通块为树时，DFS最短路算法正确。若存在环，必定存在节点被错误计算。判环方式主要有DFS遍历时检测非父节点的重复访问和并查集判环两种思路。

---

### 精选题解（评分≥4星）

#### 1. 作者：H2ptimize（★★★★★）  
**关键亮点**  
- 思路清晰，通过DFS遍历时检测非父节点的重复访问来判环  
- 代码简洁易读，维护父节点避免误判  
- 时间复杂度O(n+m)，完全适配题目数据规模  

**核心代码**  
```cpp
bool vis[MAXN];
void dfs(int u,int fa) {
    vis[u] = true;
    for(int v : G[u]) {
        if(v == fa) continue;
        if(!vis[v]) dfs(v, u);
        else { ans = 0; return; } // 发现非父节点的已访问节点
    }
}
```

---

#### 2. 作者：M_CI（★★★★☆）  
**关键亮点**  
- 采用递归式DFS，代码结构简洁  
- 利用全局变量直接传递环检测结果  
- 无冗余逻辑，直接返回存在性判断  

**核心代码**  
```cpp
void dfs(int u, int fa) {
    vis[u] = 1;
    for(auto v : G[u]) {
        if(v == fa) continue;
        if(!vis[v]) dfs(v, u);
        else ans = 0; // 发现环立即终止递归
        if(!ans) return;
    }
}
```

---

#### 3. 作者：Iniaugoty（★★★★☆）  
**关键亮点**  
- 引入tarjan式的判环思想  
- 通过前向边和返祖边概念清晰解释判环逻辑  
- 代码中显式处理连通块隔离，逻辑严谨  

**核心代码**  
```cpp
void Dfs(int u, int fa) {
    vis[u] = 1;
    for(auto v : e[u]) {
        if(v == fa) continue;
        if(!vis[v]) Dfs(v, u);
        else ans = 0; // 返祖边判环
        if(!ans) return;
    }
}
```

---

### 最优思路总结  
**核心技巧**  
- **DFS判环**：在递归过程中维护父节点，若遇到已访问的非父节点则判定存在环  
- **终止优化**：发现环后立即终止后续递归，节省计算资源  
- **连通块隔离**：仅需检测与起点1连通的子图，无关连通块无需处理  

**代码实现要点**  
- 使用邻接表存储图结构  
- 维护`vis[]`数组记录访问状态  
- 递归时传递父节点参数防止误判  

---

### 拓展方向  
1. **类似问题**  
   - 求所有连通块的环存在性（P2661 [NOIP2015 提高组] 信息传递）  
   - 判断图的二分性（P1330 封锁阳光大学）  
   - 寻找最小环（P6175 无向图的最小环问题）  

2. **推荐题目**  
   - [P2661](https://www.luogu.com.cn/problem/P2661) 图中最小环检测  
   - [P2921](https://www.luogu.com.cn/problem/P2921) 图的遍历与连通性应用  
   - [P3388](https://www.luogu.com.cn/problem/P3388) 割点判定与连通性分析  

---

### 题解心得摘录  
> "发现伪代码中的`vis[]`未清空后，立刻意识到每个节点只会被访问一次，此时图必须是树才能保证正确性" —— H2ptimize  
> **启示**：观察算法特性与图结构的关联是破题关键  

> "并查集判环时需注意只处理与1连通的环" —— yang2_0  
> **教训**：多连通块问题中需明确处理范围，避免无效计算

---
处理用时：52.98秒
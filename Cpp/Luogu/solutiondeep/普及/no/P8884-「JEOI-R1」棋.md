# 题目信息

# 「JEOI-R1」棋

## 题目背景

| 出题 | 标程 | 数据 | 验题 | 题解 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
 | [RedNebula](/user/478829) | [RedNebula](/user/478829) | [RedNebula](/user/478829) and [gyyyyx](/user/554574) | [gyyyyx](/user/554574) | [RedNebula](/user/478829) |
 
[RedNebula](/user/478829) 和 [_JF_](/user/361141) 在下一盘棋，然后……

## 题目描述

现在有一个 $n\times m$ 的棋盘，从上到下依次是 $1\sim n$ 行，从左到右依次是 $1\sim m$ 列，一个位于第 $x$ 行第 $y$ 列的位置被标记为 $(x,y)$。共有 $c$ 个棋子，**不重叠**地摆放在棋盘的某些位置上。一个位于 $(x,y)$ 的棋子可以走向 $(x-1,y-1),(x-1,y+1),(x+1,y-1),(x+1,y+1)$（如果这些位置**存在**且其上**没有棋子**）。

现有若干询问，每次询问给定 $x_1,y_1,x_2,y_2,p$，然后给定 $p$ 个位置，表示一个子矩阵的左上角位置为 $(x_1,y_1)$，右下角位置为 $(x_2,y_2)$，问是否可以移动棋子（无次数限制）使得矩阵内**有且仅有**给定的 $p$ 个位置上有棋子。**询问之间相互独立。**

为了减少程序时间复杂度的常数影响，**建议使用更快的读入方式。**

## 说明/提示

**【样例解释 \#1】**

解释以 `0` 代表空位，`1` 代表放置了棋子的位置。

初始状态：

```plain
011
100
011
```

对于第一个询问，可以证明 $(1,2)$ 处的棋子无法移出 $(1,2)$ 到 $(2,3)$ 的矩阵。

对于第二个询问，考虑把 $(3,2)$ 处的棋子移到 $(2,3)$，得：

```plain
011
101
001
```

满足询问要求。移动方式不唯一。

对于第三个询问，可以证明 $(2,1)$ 处的棋子无法移出 $(1,1)$ 到 $(2,3)$ 的矩阵。

**【数据范围】**

对于 $25\%$ 的数据，$n,m,q\le 10$，$c\le 20$。

对于另外 $25\%$ 的数据，保证 $a_i+b_i\equiv 0 \pmod 2$，$c_i+d_i\equiv 0 \pmod 2$。

对于另外 $25\%$ 的数据，保证 $n\cdot m-c\le(x_2-x_1+1)\cdot (y_2-y_1+1)-p$。

对于 $100\%$ 的数据，$2\le n,m\le 10^5$，$1\le c,q\le 10^5$，$c\le n\cdot m$，$1\le a_i\le n$，$1\le b_i\le m$，$\sum p\le 2\times 10^5$。对于每个询问，$1\le p\le (x_2-x_1+1)\cdot (y_2-y_1+1)$，$x_1\le c_i\le x_2$，$y_1\le d_i\le y_2$。

**【提示与说明】**

提供一种较快的读入一个 `int` 类型非负整数的方式。调用下文中的 `read()`，其作用是返回输入中的一个非负整数，同时读取其后的一个字符。

```cpp
int read() {
  int x(0);
  char c(getchar());
  while (c < '0' || c > '9') c = getchar();
  while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
  return x;
}
```

## 样例 #1

### 输入

```
3 3 5
1 2
1 3
2 1
3 2
3 3
3
1 2 2 3 0
1 2 3 3 4
1 2
1 3
2 3
3 3
1 1 2 3 2
1 3
2 2```

### 输出

```
NO
YES
NO```

# AI分析结果



## 算法分类
组合数学

## 综合分析
题目核心在于利用奇偶染色法分析棋子移动限制。棋子只能在同奇偶性的格子间移动，因此需确保子矩阵所需的奇偶棋子数量不超过全局总数，且空位足够容纳移动后的棋子。关键点在于精确计算子矩阵内奇偶位置数目，取决于其尺寸与左上角坐标的奇偶性。

## 精选题解

### 题解作者：TernaryTree (⭐⭐⭐⭐⭐)
**关键亮点**：  
- 清晰划分黑白（奇偶）格子，数学推导严谨。  
- 变量命名简洁（s0/s1为子矩阵奇偶总数，d0/d1为空位需求）。  
- 利用位运算快速判断奇偶性，代码高效。  
**个人心得**：正确处理子矩阵奇偶数目计算，尤其是当尺寸为奇数时结合左上角坐标调整，避免常见逻辑错误。  

**核心代码**：
```cpp
s0 = (h * w & 1 ? h * w + (x0 + y0 & 1 ? -1 : 1) >> 1 : h * w >> 1);
s1 = (h * w & 1 ? h * w + (x0 + y0 & 1 ? 1 : -1) >> 1 : h * w >> 1);
// 计算子矩阵奇偶位置数
d0 = s0 - c0; // 偶空需求
d1 = s1 - c1; // 奇空需求
puts(c0 <= a0 && c1 <= a1 && d0 <= b0 && d1 <= b1 ? "YES" : "NO");
```

### 最优思路提炼
1. **奇偶染色法**：将坐标和奇偶性相同的格子视为同类，限制棋子移动路径。  
2. **数学建模**：通过矩阵尺寸与左上角坐标，精确计算区域内奇偶格子数量。  
3. **四条件验证**：  
   - 所需奇/偶棋子数 ≤ 全局现有数  
   - 所需奇/偶空位数 ≤ 全局可容纳数  

## 拓展训练
1. [P1896 互不侵犯](https://www.luogu.com.cn/problem/P1896) - 棋盘放置策略  
2. [P3956 棋盘](https://www.luogu.com.cn/problem/P3956) - 颜色交替移动问题  
3. [CF455A Boredom](https://codeforces.com/problemset/problem/455/A) - 奇偶性动态规划

---
处理用时：148.89秒
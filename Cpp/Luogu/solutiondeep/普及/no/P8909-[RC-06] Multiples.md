# 题目信息

# [RC-06] Multiples

## 题目描述

给出 $n$，以及一个长度为 $n$ 的数组 $a$，$a_1\sim a_n$ 都是正整数，且 $a_i$ 在 $[1,10^9]$ 均匀随机生成。

对每个 $0\le k\le n$ 计算 $[1,m]$ 中有几个正整数 $x$ 恰好是 $k$ 个 $a_i$ 的倍数（也就是恰好存在 $k$ 个 $1\le i\le n$，$a_i\mid x$）。

## 说明/提示

本题没有部分分，只有 AC 才能得分。

所有数据均满足：$1\le n\le 2500$，$1\le m\le 10^9$，$1\le a_i\le 10^9$，且 $a_i$ 在 $[1,10^9]$ 中均匀随机生成。

**本题有 $6$ 组数据满足 $n=2500$，$2$ 组数据满足 $n\le 10$，共 $8$ 组数据。**

**所有数据都是如下方式生成：运行以下伪代码恰好一次生成，将其输出作为你的输入。**

```
function rnd(int l,int r):

return [l,r] 之内的随机整数

function main():

输入本组数据的 n,m
输出 n,m
输出 n 个正整数，都是 rnd(1,10^9) 的返回值
```

如果你不理解上面的生成方式，也可以阅读对应的 C++ 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main(){
	freopen("in.txt","w",stdout);
	int n,m;
	cin>>n>>m;
	cout<<n<<' '<<m<<'\n';
	mt19937_64 rng(time(0));
	const int M=1e9;
	for(int i=1;i<=n;i++)cout<<rng()%M+1<<' ';
}
```

样例不满足 $a_i$ 在 $[1,10^9]$ 均匀随机生成，因此样例不是合法的输入数据。测试数据中不包含样例。

## 样例 #1

### 输入

```
5 1000000
1 2 3 4 5```

### 输出

```
0 266666 333335 266665 116668 16666```

# AI分析结果



**算法分类**: 数学

---

### 题解分析与结论

所有题解均基于 **暴力枚举倍数 + 哈希优化空间** 的核心思路。由于题目数据均匀随机，每个数的倍数在 [1,m] 内分布稀疏，利用哈希表或 map 动态统计每个数被覆盖的次数，避免了直接开数组导致 MLE 的问题。关键优化点在于：

1. **哈希表代替数组**：使用 `map` 或 `gp_hash_table` 动态存储被覆盖的数，节省空间。
2. **数据随机性利用**：均匀随机生成的 a_i 使得其倍数在 [1,m] 内不重叠过多，保证时间可行。
3. **逆向统计 k=0 的情况**：总数量 m 减去所有被覆盖的数的数量即为 k=0 的答案。

---

### 高星题解推荐

#### 1. 作者：yeshubo_qwq (⭐⭐⭐⭐⭐)
- **关键亮点**: 
  - 使用 `gp_hash_table`（比 STL map 更快）统计次数。
  - 代码简洁高效，直接遍历哈希表统计答案。
  - 正确处理 k=0 的边界情况。
- **核心代码**：
  ```cpp
  gp_hash_table <int,int> a; // 快速哈希结构
  for (i=1;i<=n;i++){
      cin>>x;
      for (j=x;j<=m;j+=x) a[j]++; // 枚举倍数并计数
  }
  int tot = m;
  for (auto it : a) ans[it.second]++, tot--; // 动态统计 k>0 和 k=0
  ```

#### 2. 作者：Convergent_Series (⭐⭐⭐⭐)
- **关键亮点**:
  - 明确对比了错误思路（数组 MLE）与优化思路（map 动态管理）。
  - 强调数据随机性对时间的影响，解释了暴力可行性。
- **调试心得**:
  > “很明显爆空间了，`cnt` 数组太大，考虑改进。由于数据随机生成，所以满足 `cnt[i]==0` 的 i 肯定很多。如果用 map 代替桶，则为 0 的数据不会被记录。”

#### 3. 作者：zhyou (⭐⭐⭐⭐)
- **关键亮点**:
  - 使用 `map` 清晰实现，代码易读。
  - 通过 `tot = m - cnt.size()` 直接计算 k=0 的数量。
- **核心代码**:
  ```cpp
  for (int j = a; j <= m; j += a) mp[j]++; // 遍历倍数
  int tot = m;
  for (auto it : mp) ans[it.second]++, tot--;
  ```

---

### 关键思路与技巧总结

1. **哈希表优化空间**：当数据范围极大但有效元素稀疏时，使用 `map` 或哈希表动态存储。
2. **逆向统计法**：总数量减去覆盖数直接得到 k=0 的结果，避免额外计算。
3. **均匀随机数据特性**：利用数据生成特性简化复杂度分析，允许暴力枚举。

---

### 拓展与相似题目

1. **P1403 [AHOI2005] 约数研究**（约数倍数统计）
2. **P2424 约数和**（因数倍数前缀和）
3. **P2261 [CQOI2007] 余数求和**（数论分块与余数统计）

---
处理用时：76.61秒
# 题目信息

# [DTOI 2023] B. 去年 11 月卵梦蕾简易钨丝

## 题目背景

# 大样例已修复

![](https://cdn.luogu.com.cn/upload/image_hosting/4il8fn7w.png)

## 题目描述

给定序列 $\{a_n\}$，支持两种形如 `opt x` 操作：

1. `1 x`：删除一个数 $x$，若序列中没有 $x$，则输出 $-1$ 并跳过本次操作，**若有多个 $x$，则仅删除一个**。

2. `2 x`：向序列中插入一个数 $x$。

**对于每个未被跳过的操作**，试求出 $a$ 的一个排列 $p$，最小化 $\sum \limits_{i=1}^{n} \lvert p_{i+1}-p_i\rvert$ 的值，即最小化 $\lvert p_2-p_1\rvert+\lvert p_3-p_2\rvert+\dots+\lvert p_{n+1}-p_n\rvert$ 的值，其中 $p_{n+1}=p_1$。

**保证任意时刻序列内至少有 $1$ 个数。**

---
$p$ 是 $a$ 的排列当且仅当对于 $\forall x$，$\sum [p_i=x]=\sum [a_i=x]$。

简而言之，$p$ 是 $a$ 经过某种方式重排后的结果。 

例如 $\{1,1,4,5,1,4\}$ 是 $\{1,5,4,1,4,1\}$ 的一个排列，但是 $\{1,5,4,1,4,7\}$ 不是。

## 说明/提示

#### 【样例 1 解释】
对于第一个询问，删除了序列中的数 $4$，则当前序列为$ 1, 2, 3, 10 $， 可以证明 $18$ 为当前序列的最小答案。
	
对于第二个询问，删除了序列中的数 $10$，则当前序列为$ 1, 2, 3 $， 可以证明 $4$ 为当前序列的最小答案。
	
对于第三个询问，向序列中添加了一个数 $9$，则当前序列为$ 1, 2, 3, 9 $， 可以证明 $16$ 为当前序列的最小答案。

#### 【样例 2】

见附加文件中的 `abs/abs2.in` 与 `abs/abs2.out`。

该样例满足测试点 $1\sim 4$ 的限制。

#### 【样例 3】

见附加文件中的 `abs/abs3.in` 与 `abs/abs3.out`。

该样例满足测试点 $7\sim 10$ 的限制。

#### 【数据范围与提示】
记 $w$ 为值域大小，对于所有测试数据，保证 $n,q\leq 10^6$，$0\leq w\leq 10^6$。
	
每个测试点的具体限制见下表：

| 测试点编号 | $n,q\leq$ | $w$ |
| :----------: | :----------: | :----------: |
| $1\sim 4$ | $100$ | $10$ |
| $5\sim 6$ | $10^3$ | $10^3$ |
| $7\sim 10$ | $10^6$ | $10^6$ |


## 样例 #1

### 输入

```
5 3
1 2 3 4 10
1 4
1 10
2 9```

### 输出

```
18
4
16```

# AI分析结果



### 算法分类
贪心

### 综合分析与结论
本题核心在于发现最小化环形排列的相邻差值总和等价于求极差的两倍。关键思路是将序列排列成单调递增/递减的环状结构，使得路径不重复覆盖区间。所有题解均围绕动态维护极值展开，主要采用以下两种方案：
1. **multiset**：利用有序容器的特性直接获取极值
2. **双堆+桶计数**：用最大堆和最小堆维护极值，桶计数处理重复元素

### 精选题解与评分

#### 1. mc123456（★★★★★）
**核心亮点**：  
- 直接使用multiset维护序列，代码简洁高效  
- 正确处理multiset的删除操作（通过迭代器删除单个元素）  
- 时间复杂度O((n+q) log n)符合题目要求

**代码核心**：
```cpp
multiset<int> s;
// 删除操作
auto it = s.find(x);
if (it != s.end()) s.erase(it);
// 查询极差
cout << (*--s.end() - *s.begin()) * 2 << endl;
```

#### 2. WsW_（★★★★☆）
**核心亮点**：  
- 明确强调使用lower_bound处理重复元素的查找  
- 详细注释解释multiset的删除陷阱  
- 代码风格规范，可读性强  

**关键实现**：
```cpp
// 删除时使用lower_bound精确查找
it = s.lower_bound(x);
if (*it != x) cout << -1;
else s.erase(it);
```

#### 3. Cure_Wing（★★★★☆）
**核心亮点**：  
- 采用双优先队列+延迟删除策略  
- 通过标记无效元素优化堆操作  
- 详细讨论极端情况的处理方法  

**代码片段**：
```cpp
priority_queue<int> b; // 最大堆
priority_queue<int, vector<int>, greater<int>> c; // 最小堆
// 延迟删除无效元素
while (!b.empty() && out[b.top()]) { 
    --out[b.top()]; 
    b.pop(); 
}
```

### 最优关键思路
**贪心策略**：排列成单调环状结构，答案=2×(max-min)  
**数据结构选择**：  
- multiset直接维护有序序列，极值查询O(1)  
- 或双堆+桶计数实现延迟删除，保证堆顶有效性  

### 拓展与相似题目
1. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801) - 动态维护第K大元素  
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心+优先队列  
3. [P3871 中位数](https://www.luogu.com.cn/problem/P3871) - 动态维护中位数  

### 题解心得摘录
1. **WsW_**: "删除不能直接erase(x)，这会删除所有x。应通过迭代器删除单个元素"  
2. **zymooll**: "用优先队列维护极值时，需结合桶计数处理重复元素的删除"  
3. **escapist404**: "贪心正确性证明：交换任意两项不会使答案更小"  

以上总结提炼了动态维护极值的经典处理方式，适用于各类需要实时统计极值的场景。

---
处理用时：65.11秒
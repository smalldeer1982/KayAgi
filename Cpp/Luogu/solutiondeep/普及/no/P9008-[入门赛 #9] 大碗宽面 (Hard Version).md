# 题目信息

# [入门赛 #9] 大碗宽面 (Hard Version)

## 题目背景


**本题与 Easy Version 题意完全相同，仅有 $n$ 的数据范围和空间限制不同**。

扶苏和她的朋友们在 Impart 酒店开派对。

## 题目描述

算上扶苏，本次派对共有 $n$ 个人。但是，并不是任何两个人都互相认识，并且互相认识的人关系也未必好。

具体而言，任意两个人可能是如下三种关系之一：
1. 敌人
2. 朋友
3. 陌生人

派对的一大重要活动是相互握手。对任意两个人 $u,v$，他们之间的握手情况遵循下面的规则：
1. 如果 $u$ 和 $v$ 是朋友关系，那么他们一定握手一次。
2. 如果 $u$ 和 $v$ 是敌人关系，那么他们一定**不**握手。
3. 如果 $u$ 和 $v$ 是陌生人关系，且存在一个人 $w$，使得 $w$ 是 $u$ 和 $v$ 之一的朋友，同时是 $u,v$ 中另一人的敌人，则 $u$ 和 $v$ **不会**握手，否则 $u$ 和 $v$ 一定握手一次。

对第三条规则，简单的说法是：一对陌生人之间，如果某一方的朋友是另一方的敌人，则不握手，否则握手。

已知共有 $p$ 对人是朋友关系，$q$ 对人是敌人关系。除了这 $p + q$ 对人，其他每对人均为陌生人关系。

请你求出本次派对一共握手了多少次。

## 说明/提示

### 样例 1 解释

共有 $(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)$ $6$ 对人。
- $(1,2)$ 是朋友，握手。
- $(1,3)$ 是敌人，不握手。
- $(1,4)$ 是敌人，不握手。
- $(2,3)$ 是朋友，握手。
- $(2,4)$ 是陌生人，但是 $1$ 是 $2$ 的朋友，也是 $4$ 的敌人，所以不握手。
- $(3,4)$ 是陌生人，但是不存在任何一个人既是 $3$ 和 $4$ 之一的敌人也是另一个人的朋友，故握手。

综上，一共握手 $3$ 次。

### 数据规模与约定

以下设 $m = p + q$，即 $m$ 是朋友和敌人关系条数之和。

- 对 $100\%$ 的数据，保证 $2 \leq n \leq 10^6$，$1 \leq u, v \leq n$，$0 \leq p,q \leq m \leq 10^3$，$u \neq v$。同一对敌人或朋友关系不会出现两次，不会有一对人同时是敌人或朋友关系。

By 一扶苏一

## 样例 #1

### 输入

```
4 2 2
1 2
2 3
1 4
1 3```

### 输出

```
3```

# AI分析结果



### 算法分类
枚举

---

### 题解综合分析
题目核心在于高效计算陌生人握手条件。各题解均采用**正难则反**思路，总握手数减去不握手对数。关键技巧在于利用 m 较小特点，枚举敌人/朋友的关系组合，用哈希结构去重。

---

### 精选题解

#### 1. 一扶苏一（★★★★★）
**关键亮点**  
- 正难则反，总对数 - 敌人对数 - 三色环影响的陌生人对数  
- 使用 map 记录已处理边，避免重复计算  
- 时间复杂度 O(m² logn)，充分适配 m≤1e3 的数据特性  

**核心代码**  
```cpp
std::map<std::pair<int, int>, bool> calced;
for (int u = 1; u <= n; ++u) {
    for (auto v : enemy[u]) { // 枚举每个敌人的所有朋友
        for (auto w : frnds[u]) if (!calced[{w, v}]) {
            calced[{w,v}] = calced[{v,w}] = true;
            --ans;
        }
    }
}
```

---

#### 2. Ray1（★★★★）
**关键亮点**  
- 极简代码风格，三层循环直接枚举朋友-敌人的组合  
- 用 map 标记已处理边，逻辑清晰  
- 时间复杂度 O(pq logn)，适用于稀疏关系图  

**核心代码**  
```cpp
map<pair<int,int>,bool> m;
for(int u=1;u<=n;u++)
    for(int mid:P[u]) // 枚举u的朋友
        for(int v:Q[mid]) // 枚举mid的敌人
            if(!m[{u,v}]) s++,m[{u,v}]=1;
```

---

#### 3. _•́へ•́╬_（★★★★）
**关键亮点**  
- 邻接表存储敌人/朋友关系，仅处理实际存在的边  
- 使用临时数组标记，避免多次哈希查询  
- 按点分层处理，内存效率更优  

**核心代码**  
```cpp
bool a[N]; // 标记数组
for(int i=0;i<n;++i) {
    for(int j=h1[i];j;j=nxt1[j]) a[e1[j]]=1; // 标记朋友
    for(int j=h1[i];j;j=nxt1[j]) 
        for(int k=h2[e1[j]];k;k=nxt2[k]) // 朋友的敌人
            ans -= !a[e2[k]], a[e2[k]]=1;
    // 清空数组部分略
}
```

---

### 关键思路总结
1. **逆向思维**：总对数 - 不握手对数，避免直接处理海量陌生人。  
2. **关系组合枚举**：利用 m 较小的特性，只枚举朋友和敌人的组合，而非全部点对。  
3. **哈希去重**：用 map 或临时数组标记已处理边，防止重复计算。  

---

### 拓展建议
- **同类问题**：涉及稀疏图关系统计的问题，如「三元环计数」「朋友敌人交替路径」等。  
- **优化方向**：若 m 较大（如 1e5 级别），需结合分块或位运算优化枚举过程。  

---

### 相似题目推荐
1. [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)（二分图判定，枚举边关系）  
2. [P3385 负环](https://www.luogu.com.cn/problem/P3385)（图的关系组合判断）  
3. [P3916 图的遍历](https://www.luogu.com.cn/problem/P3916)（逆向处理图节点关系）  

---

### 个人心得摘录
> **Kyw666**：二维数组存不下大 n，改用 vector+map。  
> **Ray1**：注意 (u,v) 和 (v,u) 要同时标记，避免重复。  
> **一扶苏一**：m 很小是突破口，不要被 n 的规模吓到。

---
处理用时：56.47秒
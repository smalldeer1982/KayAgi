# 题目信息

# 「GLR-R4」小满

## 题目背景

&emsp;&emsp;「树阴满地日当午，梦觉流莺时一声」

---

&emsp;&emsp;乐队训练之余，锻炼时间可是必不可少的，可是就算几个女孩子撒开蹄子跑，也不可能在高三打球狂人的统治下抢到一块羽毛球场的。经过了数周从训练室冲到球场，再从球场灰心地踱回训练室的循环后，阿绫绝望地向大家宣布了一个坏消息：“只能打野球了。”

&emsp;&emsp;“还有几个月了哟……”

&emsp;&emsp;“老 V 你又来了！”才回训练室的阿绫扶着门抱怨着。

&emsp;&emsp;“所以你们打球得抓紧时间啦！”

---

&emsp;&emsp;**小满**&emsp;「生活一圈圈日子一年年　总是这样重复一遍又一遍」

## 题目描述

&emsp;&emsp;野场羽毛球，在生态环境良好的校园里，可是经常遭遇不测的——

&emsp;&emsp;“天依！怎么球又被挂树上啦！”

&emsp;&emsp;如阿绫所见，她们仅剩的一颗可怜的羽毛球被天依用吃包子的劲儿抡到树上去了。为了避免找别人的排球或者篮球来砸树的尴尬，阿绫这次特意准备了一根折叠杆。

&emsp;&emsp;折叠杆初始时处于完全收缩状态，我们认为它的长度 $\ell=0$。完全展开折叠杆需要 $n$ 步，每步为以下两种情况之一：

1.  将杆末端的折叠处展开。此操作没有额外参数，操作完成后 $\ell\gets 2\ell$，即杆的长度变为原来的两倍。

2.  将杆末端的伸缩处展开。此操作将给出额外可变参数 $d$，操作完成后 $\ell\gets \ell+d$，即杆的长度增加 $d$。

&emsp;&emsp;树上球的高度、杆最终的高度和天依吃包子的劲儿可能都是庞大的，所以阿绫需要你来计算一下杆最终的长度 $\ell$。你需要回答阿绫 $n$ 次操作依次完成后，**$\ell$ 的二进制表示**。

## 说明/提示

#### 样例 #1 解释

对于第一组测试数据：$\ell$ 的变化过程为：$0 \rightarrow 0 \rightarrow 0$，而 $(0)_{10}=(0)_2$。

对于第二组测试数据：$\ell$ 的变化过程为：$0 \rightarrow 0 \rightarrow 1 \rightarrow 3 \rightarrow 6 \rightarrow 12$，而 $(12)_{10}=(1100)_2$。  

### 数据规模与约定  

对于 $100\%$ 的数据，$1\leq T \leq 5$，$1\leq  n \leq 10^5$，$0\leq d < 2^{16}$。

对于不同的子任务，作如下约定：

| 子任务编号 |     $n$     | 特殊性质 | 子任务分值 |
| :--------: | :---------: | :------: | :--------: |
|    $1$     |  $\leq 20$  |    无    |    $10$    |
|    $2$     | $\leq 10^5$ |    有    |    $20$    |
|    $3$     | $\leq 10^3$ |    无    |    $40$    |
|    $4$     | $\leq 10^5$ |    无    |    $30$    |
  
- 特殊性质：仅存在第二种操作。


## 样例 #1

### 输入

```
2
2
1
2 0
5
1
2 1
2 2
1
2 6```

### 输出

```
0
1100```

# AI分析结果



算法分类：高精度

### 综合分析
题目核心在于高效处理高精度运算的乘2与加d操作，并输出二进制结果。各题解的共同思路是：**利用二进制特性将乘法转换为位移，倒序统计加法的贡献，延迟进位处理**。关键优化点包括：
1. 二进制高精度存储，乘2等价于末尾补0
2. 倒序处理操作，统计每个加法后的乘法次数以确定位移量
3. 统一进位处理避免实时计算的高复杂度

### 精选题解
#### 1. Auto_Accepted（★★★★☆）
**关键亮点**：
- 使用二进制高精度数组，乘2操作O(1)完成
- 延迟进位处理，最后统一计算
- 指针动态维护最低位位置，避免数组频繁移动
**核心代码**：
```cpp
struct Int{
    int a[100005] = {}, pos = 50000, l = pos;
    void test1(){ pos++; }  // 乘2：末尾补0
    void test2(int d){ a[pos] += d; }  // 加d：直接累加
    void end(){  // 统一进位处理
        for(int i=pos;i;i--){
            a[i-1] += a[i]/2;
            a[i] %= 2;
        }
        // ... (计算有效位)
    }
};
```
**个人心得**：作者提到"赛时没想到倒序处理"，反映正向模拟可能陷入思维定式。

#### 2. Azazеl（★★★★★）
**关键亮点**：
- 倒序统计每个加法的位移量
- 预分解d的二进制位直接累加
- 使用位运算加速分解过程
**核心代码**：
```cpp
for(int i=n;i>=1;i--) {
    if(操作1) tot++;  // 统计后续乘法次数
    else for(int j:V[d]) Num[j+tot]++;  // 预计算位移后的位置
}
// 统一进位处理...
```
**优化思路**：预处理0~2^16所有数的二进制分解，将加d操作优化为O(1)查表。

### 关键技巧总结
1. **二进制视角转换**：乘2即左移，加d即低位叠加
2. **倒序处理法**：先处理最后操作，避免乘法对后续操作的影响
3. **延迟进位**：将O(n)次进位合并为单次O(n)处理
4. **预分解优化**：预处理d的二进制位加速运算

### 拓展练习
1. [P1009 阶乘之和](https://www.luogu.com.cn/problem/P1009) - 高精度加法与乘法综合应用
2. [P1604 B进制星球](https://www.luogu.com.cn/problem/P1604) - 不同进制的高精度处理
3. [P2105 K皇后](https://www.luogu.com.cn/problem/P2105) - 位运算优化（非高精度但涉及二进制处理）

---
处理用时：43.72秒
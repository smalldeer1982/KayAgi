# 题目信息

# [蓝桥杯 2023 省 A] 更小的数

## 题目描述

![image](https://cdn.luogu.com.cn/upload/image_hosting/y1rd2iun.png)

小蓝有一个长度均为 $n$ 且仅由数字字符 $0 \sim 9$ 组成的字符串，下标从 $0$ 到 $n-1$，你可以将其视作是一个具有 $n$ 位的十进制数字 $num$，小蓝可以从 $num$ 中选出一段连续的子串并将子串进行反转，最多反转一次。小蓝想要将选出的子串进行反转后再放入原位置处得到的新的数字 $num_{new}$ 满足条件 $num_{new}<num$，请你帮他计算下一共有多少种不同的子串选择方案，只要两个子串在 $num$ 中的位置不完全相同我们就视作是不同的方案。

注意，我们允许前导零的存在，即数字的最高位可以是 $0$，这是合法的。

## 说明/提示

#### 【样例说明】

一共有 $8$ 种不同的方案：

1. 所选择的子串下标为 $0\sim1$，反转后的 $num_{new} = 120102 < 210102$；
2. 所选择的子串下标为 $0\sim2$，反转后的 $num_{new} =  012102 < 210102$；
3. 所选择的子串下标为 $0\sim3$，反转后的 $num_{new} =  101202 < 210102$；
4. 所选择的子串下标为 $0\sim4$，反转后的 $num_{new} =  010122 < 210102$；
5. 所选择的子串下标为 $0\sim5$，反转后的 $num_{new} =  201012 < 210102$；
6. 所选择的子串下标为 $1\sim2$，反转后的 $num_{new} =  201102 < 210102$；
7. 所选择的子串下标为 $1\sim4$，反转后的 $num_{new} =  201012 < 210102$；
8. 所选择的子串下标为 $3\sim4$，反转后的 $num_{new} =  210012 < 210102$。

#### 【评测用例规模与约定】

对于 $20\%$ 的评测用例，$1 \le n \le 100$；

对于 $40\%$ 的评测用例，$1 \le n \le 1000$；

对于所有评测用例，$1 \le n \le 5000$。


## 样例 #1

### 输入

```
210102```

### 输出

```
8```

# AI分析结果



### 算法分类
**动态规划**

### 综合分析
题目核心在于高效判断所有可能反转子串是否满足条件。题解主要分为两种思路：  
1. **区间动态规划**：定义 `dp[i][j]` 表示反转子串 `[i,j]` 是否满足条件。通过首尾字符比较和子区间状态推导，实现 O(n²) 时间复杂度。  
2. **双指针暴力**：逐个判断每个子串，时间复杂度 O(n³)，无法通过大测试用例。  

动态规划解法通过状态转移巧妙避免了重复比较，是唯一可行的高效解法。

---

### 精选题解

#### 1. 题解作者：qwerty12346 （⭐⭐⭐⭐⭐）
**关键亮点**  
- 反向遍历优化：从后往前遍历 `i`，确保子问题 `dp[i+1][j-1]` 已计算  
- 代码极简：直接累加答案，无需额外初始化  
- 时间复杂度 O(n²)，空间 O(n²)  

**核心代码**  
```cpp
bool f[5005][5005];
int main() {
    string s; cin >> s;
    int ret = 0;
    for (int i = s.size()-1; i >=0; i--) {
        for (int j = i; j < s.size(); j++) {
            if (s[i] > s[j]) f[i][j] = true;
            else if (s[i] == s[j]) f[i][j] = f[i+1][j-1];
            ret += f[i][j];
        }
    }
    cout << ret;
}
```

#### 2. 题解作者：zhlzt （⭐⭐⭐⭐）
**关键亮点**  
- 显式处理边界：单独初始化长度为 1 和 2 的子串  
- 分长度循环：更易理解的递推过程  

**核心代码片段**  
```cpp
for (int len=3; len<=n; len++) {
    for (int i=0; i<n-len+1; i++) {
        int j = i+len-1;
        if (s[i]==s[j]) dp[i][j] = dp[i+1][j-1];
        else if (s[i]>s[j]) dp[i][j] = 1;
    }
}
```

#### 3. 题解作者：chenyuchenghsefz （⭐⭐⭐⭐）
**关键亮点**  
- 明确状态转移条件分类  
- 直接累计答案，代码清晰  

---

### 关键思路总结
**区间DP状态转移**：  
- `s[i] > s[j] → 反转后更小`  
- `s[i] == s[j] → 结果等于内部子区间`  
- 从大区间向小区间反向遍历，确保子问题已解  

**优化技巧**：  
- 无需显式初始化长度为 1/2 的区间，反向遍历自动覆盖  
- 直接在 DP 过程中累加答案，减少最后遍历  

---

### 拓展练习
1. [P1430 序列取数](https://www.luogu.com.cn/problem/P1430) - 区间DP经典  
2. [P1775 石子合并](https://www.luogu.com.cn/problem/P1775) - 区间DP基础模型  
3. [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147) - 滑动窗口/双指针优化

---
处理用时：120.76秒
# 题目信息

# 红草莓

## 题目描述

有一个由 $n$ 颗珍珠串成的项链，项链是一个环，首尾相连。其中有一颗珍珠上有特殊的记号，我们称它为**起始珍珠**。

有个外星人很会发射宇宙射线，他依次发射了 $m$ 轮宇宙射线，第 $i$ 轮有一个参数 $a_i$，表示：

- 外星人从起始珍珠开始数，起始珍珠是 $0$ 号，起始珍珠的下一个珍珠是 $1$ 号，以此类推（数完一圈后还会继续，例如 $n$ 号珍珠仍然是起始珍珠，$n+1$ 号珍珠是起始珍珠的下一个珍珠）。外星人会对编号为 $0,a_i,2a_i,\dots$ 这些 $a_i$ 倍数位置上的珍珠都发射一次宇宙射线。

一开始所有珍珠都是红色的，而当一个珍珠被发射宇宙射线后就会被从红色染成蓝色。

你需要输出：对于每轮操作，有多少个操作前为红色的珍珠被这轮操作变成了蓝色。

## 说明/提示

**【样例解释】**

如图是初始时以及每次操作后各珍珠的颜色，起始珍珠编号为 $0$，可以看到，每次操作新染蓝的珍珠数量分别为 $1,1,2,0,2,0$：

![](https://cdn.luogu.com.cn/upload/image_hosting/mt4dg5ap.png)

---

**【数据范围】**

对于全部数据：$1\leq n,m\leq 5\times 10^5$，$1\leq a_i\leq n$。

|     子任务编号     |    $n\leq$     |    $m\leq$     |  特殊限制   | 分值 |
| :----------------: | :------------: | :------------: | :---------: | :--: |
| $\text{Subtask 1}$ |     $100$      |     $100$      |     无      | $15$ |
| $\text{Subtask 2}$ |     $1000$     |     $1000$     |     无      | $15$ |
| $\text{Subtask 3}$ |     $10^5$     |     $10^5$     | $a_i\mid n$ | $20$ |
| $\text{Subtask 4}$ |     $10^5$     |      $10$      |     无      | $20$ |
| $\text{Subtask 5}$ | $5\times 10^5$ | $5\times 10^5$ |     无      | $30$ |

---

![](https://cdn.luogu.com.cn/upload/image_hosting/nzd79suj.png)

## 样例 #1

### 输入

```
6 6
6 3 4 2 5 1
```

### 输出

```
1 1 2 0 2 0
```

# AI分析结果



算法分类：数学

---

### 综合分析与结论
本题核心在于发现**染色点的分布规律**：当参数为$a_i$时，所有被染色的珍珠编号都是$\gcd(n, a_i)$的倍数。通过预处理每个$\gcd$值的染色情况，可以避免重复计算。关键优化点在于：
1. 用$\gcd$值将问题转化为因数处理问题
2. 记录已处理的$\gcd$值，相同$\gcd$直接跳过
3. 基于调和级数的时间复杂度优化（$O(n \log n)$）

---

### 精选题解分析

#### 1. Hughpig（★★★★☆）
**核心亮点**：
- 通过$\gcd(n,a_i)$确定染色周期
- 使用vis数组记录已处理的$\gcd$值
- 时间复杂度严格证明为$O(n \log n)$
```cpp
int main() {
    cin>>n>>m;
    while(m--) {
        cin>>x;
        int qwq = gcd(x,n);
        if(vis_[qwq]) { // 已处理过该gcd值
            cout<<0<<' ';
            continue;
        }
        vis_[qwq] = 1;
        // 遍历所有gcd的倍数统计未染色点
        for(int i=0; i<n; i+=qwq) 
            if(!vis[i]) cnt++,vis[i]=1;
    }
}
```

#### 2. RNBW（★★★★☆）
**核心亮点**：
- 引入调和级数复杂度分析
- 预处理$\gcd$的倍数标记
- 代码结构清晰，逻辑简洁
```cpp
int main() {
    scanf("%d%d",&n,&m);
    for(int i=1; i<=m; i++) {
        int s = __gcd(n,a);
        if(vis[s]) { /*...*/ }
        for(int j=0; j<n; j+=s) // 标记倍数
    }
}
```

#### 3. Link_Cut_Y（★★★★☆）
**个人心得引用**：
> "通过裴蜀定理发现染色点集合的特性，将问题转化为因数处理问题。每个$\gcd$只需处理一次，后续直接跳过"

**代码亮点**：
- 使用布尔数组代替哈希表标记
- 直接操作$\gcd$值而非原始参数
```cpp
int main() {
    int s = gcd(a,n);
    if(st[s]) { /*...*/ }
    st[s] = true;
    for(int i=0; i<n; i+=s) // 统计未染色点
}
```

---

### 最优技巧总结
1. **数学建模**：通过$\gcd$确定染色点的周期性分布
2. **因数分解优化**：将问题转化为处理$n$的因数集合
3. **状态记忆**：记录已处理的$\gcd$值避免重复计算
4. **调和级数遍历**：利用$\sum_{d|n} \frac{n}{d} = O(n \log n)$的性质保证效率

---

### 拓展练习
1. [P1891 疯狂的馒头](https://www.luogu.com.cn/problem/P1891)（并查集+逆向染色）
2. [P2568 GCD](https://www.luogu.com.cn/problem/P2568)（$\gcd$性质与筛法结合）
3. [P5535 约瑟夫问题](https://www.luogu.com.cn/problem/P5535)（环形结构数学建模）

---
处理用时：50.50秒
# 题目信息

# 『STA - R2』Locked

## 题目背景

GOD_hj 有一把数字密码锁，但是他陷于 whk，没时间来开锁。

## 题目描述

这把锁从左到右有 $n$ 个数，组成了一个序列 $\{a\}$。

由于 GOD_hj 的记性不好，所以只要将锁设置为输入任意单峰序列即可打开。具体为：
$$ a_1 \le \cdots \le a_i \ge a_{i+1} \ge \cdots \ge a_n\quad (1 \le i \le n) $$

GOD_hj 的锁是拨动式的，即拨一下就能换成临近的一个数（$0$ 和 $9$ 可以互换）。

求最少拨几下可以开锁。

## 说明/提示

**【样例解释】**

样例二：把第四个 $5$ 变为 $6$ 或把第三个 $6$ 变为 $5$。

**【数据范围】**

**本题采用捆绑测试。**

$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c|c}\hline\hline
\textbf{Subtask} & \bm n\le &\textbf{分值}&\textbf{特殊性质} \\\hline
\textsf{1} & 5 & 5 & \textbf{无} \\\hline
\textsf{2} & 10^3 & 25 & \textbf{无} \\\hline
\textsf{3}  & 5\times 10^5 & 20 & \textbf{无} \\\hline
\textsf{4} & 5\times 10^6 & 10 & a_i\in\{0,1\} \\\hline
\textsf{5} & 5\times 10^6 & 40 & \textbf{无} \\\hline\hline
\end{array}
$$

对于全部数据，$1\le n\le 5\times 10^6$，$0\le a_i<10$。

**Upd on 2023/06/12**：新加 5 组 Hack 数据，放入 Subtask 6，不计分。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
0```

## 样例 #2

### 输入

```
7
1 2 6 5 6 7 2```

### 输出

```
1```

# AI分析结果



**算法分类**: 动态规划

---

### 综合分析与结论
本题核心是通过动态规划预处理递增/递减序列的最小代价，结合前缀优化将复杂度降至 O(n*10)。各题解普遍采用双 DP 数组（递增前缀 + 递减后缀）的思路，关键优化点在于通过前缀最小值数组避免重复计算。最优解法将时间复杂度从 O(n*10²) 优化至 O(n*10)，适用于 5e6 级数据量。

---

### 高星题解推荐
1. **未来姚班zyl（⭐⭐⭐⭐⭐）**
   - **关键亮点**:
     - 前缀最小值数组优化 DP 转移，复杂度 O(n*10)
     - 代码清晰，维护递增递减两个方向的 DP 数组
     - 正确处理重复计算（总代价需减去当前位拨动次数）
   - **核心代码**:
     ```cpp
     // 递增 DP 预处理（前缀最小值优化）
     rep(i,2,n) {
         f[i][0] = ff[0] + dis(a[i],0);
         ff[0] = f[i][0];
         rep(j,1,9) {
             f[i][j] = ff[j] + dis(a[i],j);
             ff[j] = min(ff[j-1], f[i][j]);
         }
     }
     // 递减 DP 同理，最终答案合并时减去重复计算
     ```

2. **Link_Cut_Y（⭐⭐⭐⭐⭐）**
   - **关键亮点**:
     - 独立维护前缀 min 数组，代码结构清晰
     - 显式分离递增递减 DP 的逻辑
     - 使用单独函数计算拨动距离，可读性强
   - **核心代码**:
     ```cpp
     // 计算拨动距离的独立函数
     int get(int x, int y) {
         if (x > y) swap(x, y);
         return min(abs(x - y), x + 10 - y);
     }
     // 前缀 min 数组维护
     minf[0] = f[1][0]; 
     for (int j = 1; j <= 9; j++) 
         minf[j] = min(minf[j-1], f[1][j]);
     ```

---

### 最优思路提炼
1. **双 DP 数组设计**：
   - `f[i][j]` 表示前 i 位递增且第 i 位为 j 的最小代价
   - `g[i][j]` 表示后 i 位递减且第 i 位为 j 的最小代价
2. **前缀优化**：
   - 维护前缀最小值数组 `minf[j] = min{f[i-1][0..j]}`
   - 将状态转移复杂度从 O(10²) 降为 O(10)
3. **拨动距离计算**：
   ```cpp
   inline int dis(int x, int y) {
       return min(abs(x-y), 10-abs(x-y));
   }
   ```

---

### 拓展方向
1. **类似问题**：单峰序列变形（如双峰序列）、带约束的序列转换问题
2. **优化模式**：前缀/后缀最小值优化在 DP 中的应用（如编辑距离优化）
3. **变种题型**：当拨动代价非对称时的处理（如上升/下降代价不同）

---

### 推荐习题
1. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)（单峰序列经典问题）
2. [P2782 序列合并](https://www.luogu.com.cn/problem/P2782)（双序列递推优化）
3. [P2893 [USACO08FEB]Making the Grade G](https://www.luogu.com.cn/problem/P2893)（序列转换 + 离散化优化）

---
处理用时：46.79秒
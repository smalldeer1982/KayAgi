# 题目信息

# [yLOI2022] 西施江南

## 题目背景

> 我晤江南面 如逢西施颜  
> 清芬宜送岸 菡萏新雨前  
> 皓腕分珠帘 珠露扬波珠玉敛  
> 天然一段聚散 嫣然曾与言  
> 平芜辙尚浅 无韵化湖田  
> 林园虽工典 芳姿不可嵌  
> 何人冠诗篇 重街杳杳重门掩  
> 似有柔荑遮目 空谷足尖

银临《西施江南》

## 题目描述

给定 $n$ 个正整数 $a_1, a_2, a_3, \dots a_n$，记 $g$ 是这些数的**最大公约数**，$l$ 是这些数的**最小公倍数**。请你判断 $l \times g$ 是否等于 $a_1 \times a_2 \times \dots \times a_n$。

## 说明/提示

### 数据规模与约定

以下用 $N$ 表示单个测试点内 $n$ 的和，即 $N = \sum n$。

- 对 $12\%$ 的数据，保证 $n = 2$。
- 对 $36\%$ 的数据，保证 $n \leq 5$。
- 对 $52\%$ 的数据，保证 $N \leq 1000$。
- 对 $76\%$ 的数据，保证 $N,a_i \leq 10^5$。
- 对 $100\%$ 的数据，保证 $2 \leq n,N \leq 5 \times 10^5$，$2 \leq a_i \leq 10^8$，$1 \leq T \leq 20$。

### 提示

**数据千万条，清空第一条**。  
**多测不清空，爆零两行泪**。  
**清空不规范，超时总相伴**。

## 样例 #1

### 输入

```
3
2
2 3
3
2 3 4
3
3 8 35```

### 输出

```
Yes
No
Yes```

## 样例 #2

### 输入

```
见附加文件中的 C2.in```

### 输出

```
见附加文件中的 C2.ans```

# AI分析结果



**算法分类**  
数学

**题解综合分析**  
题目核心是判断n个数的gcd×lcm是否等于乘积。当n=2时恒成立，n>2时需所有数两两互质。关键难点在于高效判断两两互质，通过质因数分解跟踪质因子是否重复出现。题解主要差异在于质因数分解的优化策略，如预处理质数筛法、小质数试除等。

---

### **精选题解**  
1. **cff_0102（5星）**  
   **关键亮点**：预处理1e8内质数，线性筛加速分解；使用数组标记质因子，代码高效  
   **代码核心**：
   ```cpp
   void s(){ // 线性筛预处理质数
       p[1]=2; x[1]=0; int cnt=1;
       for(int i=2; i<1e8; i++){
           if(!x[i]) p[++cnt]=i;
           for(int j=1; j<=cnt && i*p[j]<=1e8; j++){
               x[i*p[j]]=1;
               if(i%p[j]==0) break;
           }
       }
   }
   bool check(){ // 分解并检查质因子
       bool f=1;
       for(int i=0; i<n; i++){
           for(int j=1; p[j]*p[j]<=a[i]; j++){
               if(a[i]%p[j]==0){
                   if(b[p[j]]) return 0;
                   while(a[i]%p[j]==0) a[i]/=p[j];
                   b[p[j]]=1;
               }
           }
           if(a[i]!=1 && b[a[i]]) return 0;
       }
       return 1;
   }
   ```

2. **一扶苏一（5星）**  
   **关键亮点**：线性筛存储最小质因子，分解时直接跳转，复杂度O(log a_i)  
   **代码核心**：
   ```cpp
   void getPrime(int N=1e8) { // 预处理最小质因子
       for(int i=2; i<=N; ++i){
           if(!np[i]) prm.push_back(i), pre[i]=i;
           for(auto p:prm) if(i*p<=N){
               np[i*p]=true, pre[i*p]=p;
               if(i%p==0) break;
           } else break;
       }
   }
   bool check(){
       for(auto x:a){
           unordered_set<int> tmp;
           while(x!=1){
               int p=pre[x]; // 直接取最小质因子
               if(vis[p]) return false;
               tmp.insert(p);
               x/=p;
           }
           for(auto p:tmp) vis[p]=true;
       }
       return true;
   }
   ```

3. **int08（4星）**  
   **关键亮点**：预处理小质数，分解后处理剩余大质数，平衡时间与空间  
   **个人心得**：需单独处理分解后的剩余大质数，否则会被hack（如两个相同大质数）

---

### **最优技巧总结**  
1. **质数预处理**：通过线性筛预处理质数或最小质因子，将分解复杂度从O(√a)降至O(log a)  
2. **质因子跟踪**：用哈希表/数组记录已出现的质因子，分解时实时检查重复  
3. **大质数处理**：分解后若剩余数>1，需单独判断是否为质数并检查重复

---

### **拓展与推荐**  
**同类题目**  
1. [CF1771C Hossam and Trainees](https://www.luogu.com.cn/problem/CF1771C)（质因子重复判断）  
2. [P2568 GCD](https://www.luogu.com.cn/problem/P2568)（互质计数与质因数分解）  
3. [B3715 分解质因子2](https://www.luogu.com.cn/problem/B3715)（高效质因数分解模板）  

**调试心得**  
- **多测清空**：质因子标记数组/哈希表需每组数据重置  
- **重复大质数**：分解后的剩余数可能仍为复合数或重复质数，需二次判断  
- **边界处理**：n=2时直接返回Yes，避免多余计算

---
处理用时：56.39秒
# 题目信息

# 「yyOI R1」youyou 的篡改（Easy Ver.）

## 题目背景

**Easy Version 与 Hard Version 仅最后所求内容不同，其他描述均一致。**

## 题目描述

youyou 准备举办一场比赛，这场比赛有 $n$ 道题，每一道题都有一个难度值 $v_i$。

youyou 给出一个计数分量 $k(k\le n)$，他认为，第 $x(x \geq k)$ 道题的可做性 $a_x$ 应当是第 $1\sim x$ 题所有题目中将难度值从小到大排序后难度较大的 $k$ 道题目难度值之和。

由于第 $1 \sim k-1$ 题难度过于简单，youyou 不想考虑这些题目的可做性。

那么这场比赛的总可做性即为第 $k$ 道题至第 $n$ 道题可做性之和，即 $\sum^{n}_{i=k}a_i$
 的值。

youyou 可以篡改题目 $m$ 的难度为任意正整数，但是他并不希望这场比赛过难或者过简单，所以他要求总可做性必须介于 $[l,r]$ 之间。

youyou 想知道，他通过篡改题目 $m$ 的难度，可以将总可做性最大篡改为多少？

特别的，如不存在一组解请输出 $-1$。

## 说明/提示

### 样例解释#1

因为 $m=1$，因此 $a_1$ 是可以被篡改的，当 $a_1=2$ 时，总可做性为 $2+2+2+2+2=10$，因为 $10 \in [5,10]$，因此可以将总可做性最大篡改为 $10$。

## 数据范围

本题启用 **Subtask**，对于每一个 **Subtask**，你需要通过全部测试点才能得到该部分的分数。

| 子任务编号 | $n$ | 分数 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $\le10$ | $15$ |
| $2$ | $\le10^3$ | $15$ |
| $3$ | $\le10^5$ | $70$ |


对于 $100\%$ 的数据，$1\le k,t \le n \le 10^5$，$1 \le l \le r \le 10^{9}$，$0\le v_i\le10^9$。

## 样例 #1

### 输入

```
5 1 1 5 10
1 2 2 2 2```

### 输出

```
10```

# AI分析结果



**算法分类**  
二分

**分析与结论**  
题目要求通过修改第m题的难度，使总可做性最大且落在[l, r]区间。核心思路是二分篡改后的难度，利用优先队列维护前k大元素的和。所有题解均采用二分+堆的解法，时间复杂度为O(n log n log V)。关键点在于：

1. **单调性**：篡改值越大，总可做性可能更大（但不绝对），但实践中二分足够高效。
2. **堆维护**：用小根堆动态维护前k大元素，每次新增元素时替换堆顶以保持堆大小。
3. **边界处理**：需正确初始化前k元素的堆，并考虑篡改位置是否在前k项中。

---

**精选题解**  

1. **MC_OIer（4星）**  
   **亮点**：代码结构清晰，维护堆的逻辑简洁，直接累加可做性总和。  
   **代码核心**：  
   ```cpp
   bool check() {
       priority_queue<int, vector<int>, greater<int>> q;
       int sum = 0, total = 0;
       for (int i = 1; i <= k; i++) q.push(v[i]), sum += v[i];
       total += sum;
       for (int i = k + 1; i <= n; i++) {
           q.push(v[i]);
           sum += v[i] - q.top();
           q.pop();
           total += sum;
       }
       return total <= r;
   }
   ```

2. **metrixgo_caozhendi（4星）**  
   **亮点**：显式记录每次合法解的最大值，确保最终结果正确。  
   **代码核心**：  
   ```cpp
   ll binsch() {
       ll lastpos = -1, left = 1, right = 1e18;
       while (left <= right) {
           ll mid = (left + right) / 2;
           v[m] = mid;
           ll tri = build();
           if (tri >= l && tri <= r) {
               lastpos = max(lastpos, tri);
               left = mid + 1;
           } else if (tri < l) left = mid + 1;
           else right = mid - 1;
       }
       return lastpos;
   }
   ```

---

**关键技巧**  
1. **堆优化**：用优先队列维护前k大元素，避免每次重新排序。
2. **增量计算**：利用相邻题的可做性关系，通过替换堆顶元素快速更新总和。
3. **二分剪枝**：根据篡改值的单调性，二分时优先尝试更大的值以寻找最优解。

---

**拓展练习**  
1. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（二分答案）  
2. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)（动态维护前k大元素）  
3. [P1182 数列分段](https://www.luogu.com.cn/problem/P1182)（二分+贪心验证）  

**个人心得**  
- **调试教训**：多次调用计算函数（如`chk(mid)`）会导致超时，应缓存结果。  
- **实现细节**：注意篡改位置是否在初始堆的前k项中，需确保堆初始包含修改后的值。

---
处理用时：158.37秒
# 题目信息

# [POI 2022 ~2023R1] poc

## 题目背景

题目译自 [POI2022~2023R1 poc](https://sio2.mimuw.edu.pl/c/oi30-1/p/poc/)。


## 题目描述

小 A 和小 B 在记录过往的车辆的类型！

已知类型分别有 $1 \sim k$ 个，每种车辆必然属于其中之一。

小 A 按顺序细心地记录了所有的车辆的类型，但是贪玩的小 B 只按顺序记录了一部分车辆。

小 A 记录的内容长度为 $n$，小 B 记录的长度为 $m$。

称在小 A 记录中的第 $i$ 辆车“可能被 B 记录到”当且仅当在小 A 的记录中存在一个包含 $i$ 的子序列与小 B 所记录的完全相同。

保证小 B 记录的序列一定是小 A 记录的子序列，问哪些车辆是可能会被小 B 记录到，哪些没有。

## 说明/提示

对于样例，存在如下的子序列：

$(1,2,4,5)$，$(1,2,4,9)$，$(1,2,7,9)$，$(1,6,7,9)$，$(4,6,7,9)$。

注意到 $3$ 和 $8$ 一直都没被取到，故不能被小 B 记录到。

子任务分配如下：

| 子任务编号 | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $n,m \leq 100$ | $15$ |
| $2$ | $n,m \leq 2000$ | $20$ |
| $3$ | 每种类型的车辆最多被小 A 记录一次 | $15$ |
| $4$ | 无附加限制 | $50$ |

时间限制：Subtask1 1s，Subtask2 10s，Subtask3 和 Subtask4 6s。

## 样例 #1

### 输入

```
9 4 3
1 3 2 1 2 3 1 3 2
1 3 1 2
```

### 输出

```
1 1 0 1 1 1 1 0 1```

# AI分析结果



**算法分类**: 贪心

---

### **题解分析与结论**
题目要求判断小A记录的车辆中哪些可能被包含在小B的子序列中。各题解核心思路相似，通过预处理前后缀匹配位置，确定每个元素是否处于有效区间。关键点在于两次扫描预处理，确定每个位置在B中的可能匹配范围，从而高效判断每个元素是否有效。

---

### **精选题解**

#### **1. 作者：keepwatcher_kensap (⭐⭐⭐⭐)**
- **关键亮点**: 
  - 预处理`g`数组记录B每个位置在A中的最右可能位置。
  - 使用`f`数组动态更新当前最长前缀匹配位置。
  - 通过判断`g[f[a[i]]] >= i`确定有效性，时间复杂度O(n)。
- **核心代码**:
  ```cpp
  int place = m;
  for (int i = n; i >= 1; i--) { // 预处理g数组（从后往前）
      if (a[i] == b[place]) g[place--] = i;
  }
  place = 1;
  for (int i = 1; i <= n; i++) { // 动态更新f数组（从前往后）
      if (a[i] == b[place]) f[a[i]] = place++;
      cout << (f[a[i]] && g[f[a[i]]] >= i) ? 1 : 0;
  }
  ```

#### **2. 作者：XichenOC (⭐⭐⭐⭐)**
- **关键亮点**:
  - 类似预处理`p`数组记录B的最右匹配位置。
  - 使用`p2`数组记录当前字符在B中的最左匹配位置。
  - 判断条件`p[p2[a[i]]] >= i`，代码简洁高效。
- **核心代码**:
  ```cpp
  int j = m;
  for (int i = n; i >= 1; i--) { // 预处理p数组
      if (a[i] == b[j]) p[j--] = i;
  }
  j = 1;
  for (int i = 1; i <= n; i++) { // 更新p2数组并判断
      if (a[i] == b[j]) p2[a[i]] = j++;
      cout << (p2[a[i]] && p[p2[a[i]]] >= i) ? 1 : 0;
  }
  ```

---

### **最优关键思路**
- **两次扫描预处理**：从后向前扫描确定B的每个位置在A中的最右可能位置（确保后续可以匹配剩余元素），从前向后扫描确定当前最长前缀匹配位置。
- **区间有效性判断**：对于每个元素，若其所在位置满足前缀匹配且其后缀匹配位置足够靠后，则标记为有效。

---

### **拓展与举一反三**
- **类似题目**：
  1. [P1435 回文字串](https://www.luogu.com.cn/problem/P1435)（子序列匹配）
  2. [P1095 守望者的逃离](https://www.luogu.com.cn/problem/P1095)（贪心与动态规划结合）
  3. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（二分与贪心预处理）

---

### **个人心得摘录**
- **keepwatcher_kensap**：强调预处理数组`g`和`f`的单调性，确保每个元素只需一次判断。
- **XichenOC**：通过左右指针的推进，直观展示了子序列的匹配过程，代码逻辑清晰易调试。

---
处理用时：66.24秒
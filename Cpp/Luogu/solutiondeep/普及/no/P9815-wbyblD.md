# 题目信息

# wbyblD

## 题目背景

> D题，我不要被hack！！！

## 题目描述

有 $n+2$ 个点排成一排，编号为 $0\sim n+1$。对于第 $i$ 号点有两个整数 $a_i,b_i$，其中 $0\le i\le n+1$。规定初始时 $a_0=b_0=a_{n+1}=b_{n+1}=0$。

设你当前在第 $x$ 号点，当前的移动方向为 $y$，初始时 $x=0,y=1$。

你将按如下方式移动直到 $x,y$ 某一次变化后满足 $x=0,y=-1$ 或 $x=n+1,y=1$。

- 若 $y=1$，首先将 $x$ 增加 $1$，此时若 $a_x>0$ 则将 $y$ 变成 $-1$，否则 $y$ 不变，最后再将 $a_x$ 减少 $1$。
- 若 $y=-1$，首先将 $x$ 减少 $1$，此时若 $b_x>0$ 则将 $y$ 变成 $1$，否则 $y$ 不变，最后再将 $b_x$ 减少 $1$。

问最后结束时 $x$ 会在第几号点，事实上，最后 $x$ 仅可能在第 $0$ 号点或第 $n+1$ 号点。

## 说明/提示

#### 样例解释

对于样例第 $1$ 组数据，$(x,y)$ 依次为 $(0,1)\to (1,1)\to (1,-1)\to (0,-1)$。

对于样例第 $2$ 组数据，$(x,y)$ 依次为 $(0,1)\to (1,1)\to (2,1)\to (2,-1)\to (1,-1)\to (1,1)\to (2,1)\to (3,1)\to (3,-1)\to (2,-1)\to (2,1)\to (3,1)\to (4,1)$。

对于样例第 $3$ 组数据，$(x,y)$ 依次为 $(0,1)\to (1,1)\to (2,1)\to (2,-1)\to (1,-1)\to (1,1)\to (2,1)\to (2,-1)\to (1,-1)\to (0,-1)$。

#### 数据范围与约定

对于前 $30\%$ 的测试点，保证 $n,a_i,b_i\le 10$。

对于前 $60\%$ 的测试点，保证 $\sum n\le 5000$。

对于另外 $20\%$ 的测试点，保证 $T=10$，$n=10^5$，$a_i,b_i$ 在指定范围内均匀随机生成。特别的，保证除该档部分分外所有测试点满足 $T\ne 10$。

对于所有测试点，保证 $1\le T\le 10^4$，$1\le n\le 10^5$，$1\le \sum n\le 10^6$，$0\le a_i,b_i\le 10^6$。

## 样例 #1

### 输入

```
3
1
1 1
3
0 1
1 1
1 0
3
0 1
2 3
4 5```

### 输出

```
0
4
0```

# AI分析结果



1. **算法分类**：贪心

---

### **题解综合分析**
题目要求判断移动结束时点的位置，核心在于发现移动过程中的数学规律，避免直接模拟。各题解均基于贪心策略，通过维护前缀和或等效变量，在线判断每个点的条件是否满足，从而快速得出结果。

---

### **精选题解**

#### **题解作者：xz001**  
**⭐️⭐️⭐️⭐️⭐️**  
**关键亮点**：  
- 提出通过维护 `cnt` 变量表示未被消耗的 `b` 之和，逐点判断是否能抵消当前 `a[i]`。  
- 代码简洁高效，时间复杂度为 O(n)。  
**核心代码**：  
```cpp
int cnt = 0;
for (int i = 1; i <= n + 1; ++i) {
    if (cnt < a[i]) {
        printf("0\n");
        is = 1;
        break;
    }
    cnt -= a[i];
    cnt += b[i];
}
```

#### **题解作者：zzy0618**  
**⭐️⭐️⭐️⭐️⭐️**  
**关键亮点**：  
- 将问题转化为前缀和的对抗关系：比较 `a` 的前缀和 `suma` 与 `b` 的前缀和 `sumb`。  
- 代码更简洁，直接在线计算前缀和。  
**核心代码**：  
```cpp
int suma = 0, sumb = 0, f = 0;
for (int i = 1; i <= n; ++i) {
    suma += a[i];
    if (suma > sumb) f = 1;
    sumb += b[i];
}
if (f) cout << 0 << '\n';
else cout << n + 1 << '\n';
```

---

### **关键思路总结**
1. **贪心条件**：对每个点 `i`，若 `sum(a[1..i]) > sum(b[1..i-1])`，则无法继续前进，返回 0；否则最终到达 `n+1`。  
2. **实现技巧**：在线维护前缀和，避免暴力模拟，时间复杂度从 O(模拟次数) 优化至 O(n)。  

---

### **拓展与举一反三**
- **同类问题**：路径能量问题（如能否到达终点）、覆盖次数问题（如 P5019 铺设道路）。  
- **推荐题目**：  
  - [P1086 花生采摘](https://www.luogu.com.cn/problem/P1086)（贪心选择路径）  
  - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）  
  - [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)（差分+贪心）  

---

### **个人心得摘录**
- **xz001**：通过观察模拟过程发现关键条件，转化为前缀和的对抗关系。  
- **zzy0618**：将 `a` 和 `b` 数组的对抗关系数学化，直接比较前缀和。  
**启示**：复杂模拟题需寻找数学规律，将过程抽象为可快速计算的条件。

---
处理用时：148.21秒
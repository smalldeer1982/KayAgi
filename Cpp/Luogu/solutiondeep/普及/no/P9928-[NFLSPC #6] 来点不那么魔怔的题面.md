# 题目信息

# [NFLSPC #6] 来点不那么魔怔的题面

## 题目描述

给定一个 $1\sim n$ 的排列 $p$ 和一个整数 $k$，要求找到 $p$ 的一个子序列 $\{p_{i_1}, p_{i_2}, \cdots, p_{i_m}\}$（$1\le i_1 < i_2 < \cdots < i_m\le n$）满足：

- 恰好有 $k$ 个 $j$ 满足 $1\le j\le m$ 且 $p_{i_j}$ 是 $p_{i_1}, p_{i_2}, \cdots, p_{i_m}$ 中从小往大数第 $j$ 个。

如果有多解，输出任意一组解即可。如果不存在合法的子序列，输出 $-1$。

## 说明/提示

对于所有数据，$1\le n\le 10 ^ 5$，$1\le k\le n$，$p_1, p_2, \cdots, p_n$ 为 $1\sim n$ 的排列。

- 子任务 1（$10$ 分）：$n\leq 20$。
- 子任务 2（$10$ 分）：$k = 2$。
- 子任务 3（$30$ 分）：$k = 3$。
- 子任务 4（$30$ 分）：$n\leq 10 ^ 3$。
- 子任务 5（$20$ 分）：无特殊限制。

Source：NFLSPC #6 D by tzc_wk

## 样例 #1

### 输入

```
4 1
4 2 1 3
```

### 输出

```
3
2 3 4
```

# AI分析结果



**算法分类标签**  
贪心

---

**综合分析与结论**  
题目转化为求长度≥k的严格递增子序列。核心思路是贪心+二分维护递增序列，并记录前驱以回溯路径。时间复杂度O(n log n)。

---

**精选题解与评分**  

1. **作者：cjh666_（4星）**  
- **关键亮点**：详细对比了DP与贪心优化的思路演变，提供路径回溯的递归实现。  
- **核心代码**：  
```cpp
int l=0,r=siz+1;
while(l+1<r){
    int mid=r+l>>1;
    if(a[i]>=a[b[mid]])l=mid;
    else r=mid;
}
b[r]=i; // 维护递增序列
q[b[r]]=b[r-1]; // 记录前驱
```
**实现思想**：二分找到插入位置，更新递增数组，并记录每个节点的前驱，最后递归输出路径。

2. **作者：RH233（4星）**  
- **关键亮点**：简洁使用`lower_bound`维护递增序列，结合动态数组存储路径。  
- **核心代码**：  
```cpp
ll x=lower_bound(dp+1,dp+len+1,a[i])-dp-1;
G[x+1]=G[x]; // 复制前驱路径
G[x+1].push_back(i); // 记录当前节点
```
**实现思想**：利用`lower_bound`快速定位插入位置，动态数组直接保存每个长度的候选序列。

3. **作者：sbno333（4星）**  
- **关键亮点**：代码简洁高效，直接维护递增数组并记录路径。  
- **核心代码**：  
```cpp
if(a>q[inn]) q[++inn]=a; // 直接追加
else{
    int r=lower_bound(q+1,q+inn+1,a)-q; // 二分替换
    q[r]=a;
}
```
**实现思想**：标准贪心LIS模板，路径记录通过前驱数组回溯。

---

**最优关键思路**  
贪心维护递增序列，二分查找插入位置优化时间，记录前驱节点实现路径回溯。核心代码段仅需10行左右，兼顾效率与实现简洁性。

---

**拓展与举一反三**  
- **同类题目**：  
  - [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)（LIS经典应用）  
  - [P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)（转化为LIS问题）  
  - [CF977F Consecutive Subsequence](https://codeforces.com/problemset/problem/977/F)（序列连续性的LIS变种）

- **个人心得摘录**  
cjh666_提到“平时多写几种方法，没AC也没事”，强调多尝试不同思路对算法能力提升的重要性。调试时可优先验证LIS长度，再检查路径生成逻辑。

---
处理用时：46.40秒
# 题目信息

# [NFLSPC #6] 1064 病毒

## 题目背景

你的电脑中了 1064 病毒，现在电脑里储存的所有数字都开始坍缩了！

为了更彻底地毁灭你的电脑，对于十进制下的 $n$ 位数，邪恶的 1064 病毒会将它按照某种规则迭代至少 $n + 1$ 次，以确保你无法还原。

面对 1064 病毒，你手足无措。但是作为 OIer 的你想知道道道道道道道道道道道到到到到到到到到



## 题目描述

定义数字串为只含有数码 $0\sim 9$ 的串，奇数数码为 $1, 3, 5, 7, 9$，偶数数码为 $0, 2, 4, 6, 8$。

对数字串 $x$，设其中奇数数码，偶数数码和总数码个数分别为 $a, b, c$，则 $a + b = c = |x|$。定义 $g(x)$ 为将 $a, b, c$ 依次写下得到的数字串，**不忽略前导零**。例如 $g(\texttt{0}) = \texttt {011}$，$g(\texttt{1064}) = \texttt{134}$，$g(\texttt {822}) = \texttt {033}$，$g(\texttt{1092515503}) = \texttt{7310}$。

设 $f_k(x)$ 表示将 **数字** $x$ **忽略前导零** 写成数字串 $x'$ 后，将 $g(x')$ 迭代 $k$ 次得到的数字串对应的数字，即设 $x ^ * = g(g(\cdots g(x')))$（共有 $k$ 个 $g$），则 $f_k(x)$ 为将 $x ^ *$ 写成数字后的结果。

给定 $n, k$（**保证 $n < k$**），求 $\sum_{i = 0} ^ {10 ^ n - 1} f_k(i)$。

多组数据。

## 说明/提示

对于所有数据，$1\leq T\leq 60$，$0\leq n < k \leq 10 ^ 5$，$\sum k\leq 10 ^ 5$。

- 测试点 1（$30$ 分）：$n\leq 5$，$k\leq 15$。  
- 测试点 2（$70$ 分）：无特殊限制。

Source：NFLSPC #6 F by Alex_Wei

## 样例 #1

### 输入

```
1
0 1
```

### 输出

```
11
```

# AI分析结果



**算法分类**  
数学

**综合分析与结论**  
本题本质是找规律题，所有题解均基于以下关键观察：  
1. 经过有限次迭代后，所有数字的最终结果会收敛到固定值 `213`  
2. 唯一例外是 `n=0`（即数字0）且 `k=1` 时，结果为 `11`  
3. 总和可简化为 `213 * 10^n`（特例时直接输出11）

**精选题解与评分**  

1. **Iniaugoty（★★★★☆）**  
**关键亮点**：通过数学归纳法证明迭代次数的上界，分规模讨论收敛过程。  
**代码核心**：特判 `n=0 && k=1`，其他情况输出 `213` 后跟 `n` 个零。  

2. **Vct14（★★★★☆）**  
**关键亮点**：以表格形式展示不同位数数字的迭代过程，直观呈现收敛规律。  
**个人心得**："打表永远的神" 体现了通过暴力程序找规律的高效性。  

3. **indream（★★★☆☆）**  
**关键亮点**：通过表格量化迭代次数与位数关系，明确给出收敛时间轴。  

**核心代码实现**  
```cpp
if (n == 0 && k == 1) cout << 11;  
else {  
    cout << 213;  
    while (n--) cout << 0;  
}
```

**拓展与举一反三**  
此类题属于「迭代收敛型」数学题，核心思路：  
1. 通过暴力程序找小规模规律  
2. 数学归纳法证明收敛性  
3. 特判边界条件  

**相似题目推荐**  
- [P1022 计算器的改良](https://www.luogu.com.cn/problem/P1022)：字符串解析与方程求解  
- [P1464 Function](https://www.luogu.com.cn/problem/P1464)：记忆化搜索与状态收敛  
- [P1014 Cantor表](https://www.luogu.com.cn/problem/P1014)：数学规律与坐标映射

---
处理用时：34.41秒
# 题目信息

# [信息与未来 2019] 新斐波那契数列

## 题目描述

给定正整数 $a(a\ge1)$，新斐波那契数列 $f_a$ 按如下方式定义：
- $f_a(1) = 1$；
- $f_a(2) = a$；
- $f_a(n) = f_a(n − 1) + f_a(n − 2)\ (n > 2)$。

例如，给定 $a = 4$，有 $f_4(1) = 1, f_4(2) = 4, f_4(3) = 5, f_4(4) = 9, f_4(5) = 14, \cdots$ 现在已知新斐波那契数列中的一项 $x$，但并不知道 $n$ 和 $a$ 的值是多少。请你求出所有可能的 $n,a(n\ge2)$ 满足 $f_a(n) = x$。

## 说明/提示

对于 $60\%$ 的测试数据，有 $1\le x\le10^6$。

对于 $100\%$ 的测试数据，有 $2\le x\le10^9,1\le T\le20$。
> 本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
2
9
123```

### 输出

```
2 9
3 8
4 4
2 123
3 122
4 61
6 24
10 3```

# AI分析结果

### 综合分析与结论

本题要求根据给定的新斐波那契数列中的一项 \( x \)，找出所有可能的 \( n \) 和 \( a \) 的组合。由于 \( x \) 的范围较大（\( 2 \leq x \leq 10^9 \)），直接枚举 \( a \) 和 \( n \) 的复杂度较高，因此需要优化算法。

### 通用建议与扩展思路

1. **数学推导**：通过数学推导，可以将问题转化为求解方程 \( f_a(n) = x \)，其中 \( f_a(n) \) 是斐波那契数列的变种。通过观察斐波那契数列的性质，可以找到 \( a \) 和 \( n \) 之间的关系。

2. **二分查找**：对于给定的 \( n \)，可以通过二分查找来确定 \( a \) 的值，从而减少计算量。

3. **预处理与缓存**：可以预处理斐波那契数列的前几项，并缓存结果，以便快速查询。

4. **边界条件处理**：注意处理 \( n = 2 \) 和 \( n = 3 \) 的特殊情况，因为这些情况下的 \( a \) 值可以直接计算得出。

### 推荐题目

1. **P1962 斐波那契数列**：考察斐波那契数列的基本性质及其快速计算方法。
2. **P1306 斐波那契数列的前n项和**：考察斐波那契数列的求和问题。
3. **P3986 斐波那契数列的变种**：考察斐波那契数列的变种及其性质。

### 最优关键思路或技巧

1. **数学推导**：通过斐波那契数列的递推关系，推导出 \( a \) 和 \( n \) 之间的关系，从而减少计算量。
2. **二分查找**：利用二分查找快速确定 \( a \) 的值，适用于 \( x \) 较大的情况。
3. **预处理与缓存**：预处理斐波那契数列的前几项，并缓存结果，以便快速查询。

### 个人心得

在处理斐波那契数列及其变种问题时，数学推导和优化算法是关键。通过观察数列的性质，可以找到简化的方法，从而减少计算量。此外，二分查找和预处理技巧在处理大数据范围时非常有效。

### 代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<pair<int, int>> findPairs(int x) {
    vector<pair<int, int>> result;
    for (int n = 2; n <= 50; ++n) {
        int low = 1, high = x;
        while (low <= high) {
            int mid = (low + high) / 2;
            int fa_n = 0, fa_prev = mid, fa_prev_prev = 1;
            for (int i = 3; i <= n; ++i) {
                fa_n = fa_prev + fa_prev_prev;
                fa_prev_prev = fa_prev;
                fa_prev = fa_n;
            }
            if (fa_n == x) {
                result.push_back({n, mid});
                break;
            } else if (fa_n < x) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
    }
    return result;
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        int x;
        cin >> x;
        auto pairs = findPairs(x);
        for (auto& p : pairs) {
            cout << p.first << " " << p.second << endl;
        }
    }
    return 0;
}
```

### 核心实现思想

1. **枚举 \( n \)**：枚举 \( n \) 从 2 到 50，因为斐波那契数列增长迅速，\( n \) 超过 50 时 \( f_a(n) \) 会远大于 \( x \)。
2. **二分查找 \( a \)**：对于每个 \( n \)，使用二分查找来确定 \( a \) 的值，使得 \( f_a(n) = x \)。
3. **计算 \( f_a(n) \)**：根据递推关系计算 \( f_a(n) \)，并与 \( x \) 进行比较。

通过这种方法，可以高效地找到所有满足条件的 \( n \) 和 \( a \) 的组合。

---
处理用时：24.40秒
# 题目信息

# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# AI分析结果

### 综合分析与结论

本题的核心是动态规划（DP），尤其是区间DP的应用。题目要求在中序遍历固定的情况下，构造加分最高的二叉树，并输出其前序遍历。各题解大多采用了区间DP的思路，通过枚举区间内的根节点，计算左右子树的加分，最终得到最大加分。部分题解还引入了记忆化搜索、前序遍历的输出优化等技巧。

### 所选高星题解

#### 1. 作者：冒泡ioa (赞：581)  
**星级：5星**  
**关键亮点：**  
- 详细解释了DP的状态设计和转移方程，思路清晰，适合初学者理解。
- 通过`root[i][j]`记录区间`[i, j]`的根节点，方便后续前序遍历的输出。
- 代码简洁，逻辑清晰，易于实现。

**核心代码：**
```cpp
for (int len = 1; len < n; ++len) {
    for (int i = 1; i + len <= n; ++i) {
        int j = i + len;
        f[i][j] = f[i + 1][j] + f[i][i]; // 默认左子树为空
        root[i][j] = i; // 默认从起点选根
        for (int k = i + 1; k < j; ++k) {
            if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                root[i][j] = k;
            }
        }
    }
}
```
**个人心得：**  
作者强调了DP的无后效性，并逐步推导状态转移方程，帮助读者理解DP的核心思想。

#### 2. 作者：噬月 (赞：37)  
**星级：4星**  
**关键亮点：**  
- 详细讨论了边界处理，特别是空子树的情况，确保DP的正确性。
- 通过`root[i][j]`记录根节点，便于前序遍历的输出。
- 代码结构清晰，注释详细，便于理解。

**核心代码：**
```cpp
for (int range = 1; range <= n; ++range) {
    for (int i = 1; i + range <= n; ++i) {
        int j = i + range;
        for (int k = i; k <= j; ++k) {
            if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                root[i][j] = k;
            }
        }
    }
}
```
**个人心得：**  
作者详细讨论了边界处理的重要性，并解释了空子树对DP结果的影响，帮助读者避免常见错误。

#### 3. 作者：Sooke (赞：3)  
**星级：4星**  
**关键亮点：**  
- 使用`string`存储前序遍历结果，避免了递归输出的复杂性。
- 通过预处理数字转字符串，优化了前序遍历的输出效率。
- 代码简洁，思路新颖，适合对字符串处理有需求的场景。

**核心代码：**
```cpp
for (int k = 1; k <= n - 1; ++k) {
    for (int i = 1; i <= n - k; ++i) {
        int j = i + k;
        if (v[i][j] < v[i][i] + v[i + 1][j]) {
            v[i][j] = v[i][i] + v[i + 1][j];
            s[i][j] = s[i][i] + s[i + 1][j];
        }
        if (v[i][j] < v[j][j] + v[i][j - 1]) {
            v[i][j] = v[j][j] + v[i][j - 1];
            s[i][j] = s[j][j] + s[i][j - 1];
        }
    }
}
```
**个人心得：**  
作者通过`string`存储前序遍历结果，简化了输出逻辑，展示了代码优化的另一种思路。

### 最优关键思路与技巧

1. **区间DP的应用**：通过枚举区间内的根节点，计算左右子树的加分，逐步递推得到最大加分。
2. **记忆化搜索**：在递归过程中记录已计算的结果，避免重复计算，提升效率。
3. **前序遍历的输出优化**：通过记录根节点，递归输出前序遍历，或使用`string`存储结果，简化输出逻辑。

### 拓展思路

- **类似题目**：区间DP的题目通常涉及合并、分割等操作，如合并石子、最优矩阵链乘等。
- **记忆化搜索**：在树形DP或递归问题中，记忆化搜索是常见的优化手段，能够有效减少重复计算。

### 推荐题目

1. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)  
2. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)  
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

---
处理用时：34.40秒
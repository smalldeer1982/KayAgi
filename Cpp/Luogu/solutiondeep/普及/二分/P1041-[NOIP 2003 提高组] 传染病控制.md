# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心是通过切断传播路径来最小化传染人数，题目给出的树结构使得问题可以分层处理。大多数题解采用了深度优先搜索（DFS）的策略，结合剪枝和预处理来优化搜索过程。虽然题目本身没有多项式复杂度的解法，但通过合理的搜索策略和优化，可以在给定的数据范围内得到正确结果。

### 所选高星题解

#### 1. **作者：RikoHere (5星)**
- **关键亮点**：该题解思路清晰，代码模块化处理得当，特别适合初学者理解。作者通过预处理树的层次结构，并使用DFS逐层选择切断的子树，同时通过回溯恢复状态，确保了搜索的完整性。代码中还使用了优先队列进行优化，进一步提升了效率。
- **个人心得**：作者强调了分模块处理的重要性，即使是简单的处理和回溯也不妨单独写一个函数，方便调试和理解。这种思维方式对初学者非常有帮助。
- **核心代码**：
  ```cpp
  void dfs(int cen, int tot){
      maxx = max(maxx, tot);
      for (int i = 0; i < cnt[cen]; ++i){
          if (!bol[b[cen][i]]){
              int num = clean(b[cen][i]);
              tot += num;
              dfs(cen+1, tot);
              reclean(b[cen][i]);
              tot -= num;
          }
      }
  }
  ```
  **核心思想**：通过DFS逐层选择切断的子树，并回溯恢复状态，确保搜索的完整性。

#### 2. **作者：基础不牢 (4星)**
- **关键亮点**：该题解通过预处理树的层次结构和子树大小，使用DFS逐层选择切断的子树，并通过标记和回溯来确保搜索的正确性。代码结构清晰，适合有一定基础的读者。
- **核心代码**：
  ```cpp
  void dfs(int now, int cnt) {
      if (now == maxx) {
          ans = min(ans, cnt);
          return;
      }
      int f = 0;
      for (int i = 1; i <= deep[now][0]; ++i) {
          if (vis[deep[now][i]] > 0) {
              f++;
              continue;
          }
          vis[deep[now][i]] = 1;
          work(deep[now][i], 1);
          dfs(now + 1, cnt - count[deep[now][i]]);
          vis[deep[now][i]] = 0;
          work(deep[now][i], 0);
      }
      if (f == deep[now][0]) ans = min(ans, cnt);
  }
  ```
  **核心思想**：通过DFS逐层选择切断的子树，并通过标记和回溯来确保搜索的正确性。

#### 3. **作者：欧鹰 (4星)**
- **关键亮点**：该题解通过预处理树的层次结构和子树大小，使用DFS逐层选择切断的子树，并通过标记和回溯来确保搜索的正确性。代码结构清晰，适合有一定基础的读者。
- **核心代码**：
  ```cpp
  void dfs1(int deep) {	
      for (int i = 1; i <= tt[deep]; i++) {
          if (vis[father[cnt[deep][i]]] == 1) continue;
          dfs2(cnt[deep][i]);
          ans += son[cnt[deep][i]];
          dfs1(deep + 1);
          ans -= son[cnt[deep][i]];
          dfs3(cnt[deep][i]);
      }
      ans1 = max(ans, ans1);
  }
  ```
  **核心思想**：通过DFS逐层选择切断的子树，并通过标记和回溯来确保搜索的正确性。

### 最优关键思路与技巧

1. **分层处理**：将树按层次划分，逐层选择切断的子树，确保搜索的层次性和完整性。
2. **回溯与标记**：通过标记和回溯来确保搜索过程中状态的正确恢复，避免重复计算或遗漏。
3. **预处理优化**：通过预处理树的层次结构和子树大小，减少搜索过程中的计算量，提升效率。

### 可拓展之处

- **类似问题**：类似的分层处理思路可以应用于其他树形结构的问题，如最小支配集、最小覆盖集等。
- **算法套路**：DFS+回溯的算法套路在树形结构的搜索问题中非常常见，掌握这一套路可以解决许多类似问题。

### 推荐题目

1. **P1040 加分二叉树**：考察树形结构的动态规划。
2. **P2014 选课**：考察树形结构的背包问题。
3. **P1352 没有上司的舞会**：考察树形结构的动态规划。

### 个人心得总结

- **调试经历**：许多作者在调试过程中发现贪心策略的局限性，转而采用DFS+回溯的策略，强调了算法选择的重要性。
- **踩坑教训**：贪心策略在某些情况下无法得到最优解，因此需要结合具体问题选择合适的算法。
- **顿悟感想**：通过分模块处理和预处理优化，可以显著提升代码的可读性和效率，这种思维方式值得学习。

---
处理用时：41.00秒
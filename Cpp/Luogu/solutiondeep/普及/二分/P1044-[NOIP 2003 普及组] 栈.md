# 题目信息

# [NOIP 2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# AI分析结果

### 综合分析与结论

本题的核心是计算卡特兰数（Catalan Number），用于解决栈的出栈序列问题。题解中主要分为以下几种思路：

1. **递归/记忆化搜索**：通过递归模拟栈的进出操作，使用记忆化优化避免重复计算。虽然思路直观，但递归深度较大时可能超时。
2. **动态规划（DP）**：通过状态转移方程计算卡特兰数，通常使用二维数组存储中间结果。DP是解决卡特兰数问题的经典方法，效率较高。
3. **卡特兰数公式**：直接使用卡特兰数的递推公式或组合数公式计算，时间复杂度较低，但需要注意组合数的计算精度问题。
4. **打表法**：由于n的范围较小（1≤n≤18），可以直接预计算卡特兰数的值并打表输出。这种方法简单高效，但缺乏通用性。

### 所选高星题解

#### 1. 题解作者：xiejinhao（★★★★★）
**关键亮点**：
- 提供了四种卡特兰数的计算方法，包括递归、DP、组合数公式和高精度打表，覆盖了多种解题思路。
- 代码清晰，注释详细，适合初学者理解卡特兰数的多种实现方式。
- 特别强调了组合数公式的优化，避免了除法运算中的精度问题。

**核心代码**：
```cpp
// 卡特兰数递推公式1
ll dfs(int i,int j) {
    if(f[i][j]) return f[i][j]; 
    if(i==0) return 1; // 边界 
    if(j>0) f[i][j]+=dfs(i,j-1);
    f[i][j]+=dfs(i-1,j+1);
    return f[i][j];
}
```

#### 2. 题解作者：inexistent（★★★★☆）
**关键亮点**：
- 详细解释了卡特兰数与栈问题的关系，帮助读者理解问题的本质。
- 使用递推公式计算卡特兰数，代码简洁高效。
- 强调了卡特兰数的递推公式推导过程，适合希望深入理解数学背景的读者。

**核心代码**：
```cpp
// 卡特兰数递推公式
int n, f[30];
int main() {
    scanf("%d", &n);
    f[0] = 1, f[1] = 1;
    for(int i=2; i<=n; i++)              
        for(int j=0; j<i; j++) 
            f[i] += f[j] * f[i-j-1];     // 递推公式 
    printf("%d", f[n]);
    return 0;
}
```

#### 3. 题解作者：Shmily_389704（★★★★☆）
**关键亮点**：
- 通过DP状态转移方程解决问题，思路清晰，代码简洁。
- 强调了DP的状态定义和边界条件，适合DP初学者学习。
- 代码注释详细，便于理解。

**核心代码**：
```cpp
// DP状态转移方程
int f[20][20];
int main() {
    scanf("%d", &n);
    for(int i=0; i<=n; i++) f[i][0] = 1; // 边界条件
    for(int j=1; j<=n; j++) {
        for(int i=0; i<=n; i++) {
            if(i==0) f[i][j] = f[i+1][j-1];
            else f[i][j] = f[i-1][j] + f[i+1][j-1];
        }
    }
    printf("%d", f[0][n]);
    return 0;
}
```

### 最优关键思路与技巧
1. **卡特兰数的递推公式**：`h(n) = h(0)*h(n-1) + h(1)*h(n-2) + ... + h(n-1)*h(0)`，这是解决栈问题的核心公式。
2. **动态规划优化**：通过二维数组存储中间结果，避免重复计算，时间复杂度为O(n²)。
3. **组合数公式优化**：使用组合数公式`C(2n, n) / (n+1)`计算卡特兰数时，注意避免除法运算中的精度问题。

### 拓展思路与类似题目
1. **类似题目**：
   - [P1044 栈](https://www.luogu.com.cn/problem/P1044)（本题）
   - [P1976 二叉搜索树计数](https://www.luogu.com.cn/problem/P1976)（卡特兰数应用）
   - [P2532 括号序列](https://www.luogu.com.cn/problem/P2532)（卡特兰数应用）

2. **调试与顿悟**：
   - 在递归解法中，记忆化搜索是避免超时的关键。
   - 在组合数公式中，注意高精度计算，避免溢出或精度丢失。

### 推荐题目
1. [P1976 二叉搜索树计数](https://www.luogu.com.cn/problem/P1976)
2. [P2532 括号序列](https://www.luogu.com.cn/problem/P2532)
3. [P1044 栈](https://www.luogu.com.cn/problem/P1044)

---
处理用时：41.90秒
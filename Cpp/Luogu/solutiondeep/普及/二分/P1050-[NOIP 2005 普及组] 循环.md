# 题目信息

# [NOIP 2005 普及组] 循环

## 题目描述

乐乐是一个聪明而又勤奋好学的孩子。他总喜欢探求事物的规律。一天，他突然对数的正整数次幂产生了兴趣。


众所周知，$2$ 的正整数次幂最后一位数总是不断的在重复 $2,4,8,6,2,4,8,6…$ 我们说 $2$ 的正整数次幂最后一位的循环长度是 $4$（实际上 $4$ 的倍数都可以说是循环长度，但我们只考虑最小的循环长度）。类似的，其余的数字的正整数次幂最后一位数也有类似的循环现象：

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c}\hline
\textbf{数字}& \textbf{循环} & \textbf{循环长度} \cr\hline\hline
2 & 2,4,8,6 & 4\cr\hline
3 & 3,9,7,1 & 4\cr\hline
4 & 4,6 & 2\cr\hline
5 & 5 &  1\cr\hline
6 & 6 & 1\cr\hline
7 & 7,9,3,1 & 4\cr\hline
8 & 8,4,2,6 & 4\cr\hline
9 & 9,1 & 2\cr\hline
\end{array}
$$

这时乐乐的问题就出来了：是不是只有最后一位才有这样的循环呢？对于一个整数 $n$ 的正整数次幂来说，它的后 $k$ 位是否会发生循环？如果循环的话，循环长度是多少呢？

注意：

1. 如果 $n$ 的某个正整数次幂的位数不足 $k$，那么不足的高位看做是 $0$。
2. 如果循环长度是 $L$，那么说明对于任意的正整数 $a$，$n$ 的 $a$ 次幂和 $a+L$ 次幂的最后 $k$ 位都相同。


## 说明/提示

**【数据范围】**

对于 $30 \%$ 的数据，满足 $k \le 4$；  
对于$100 \%$ 的数据，满足 $1 \le n < {10}^{100}$，$1 \le k \le 100$。

**【题目来源】**

NOIP 2005 普及组第四题

## 样例 #1

### 输入

```
32 2```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

本题的核心在于求解一个数的后 \(k\) 位在正整数次幂下的循环长度。题解中主要采用了以下几种思路：

1. **逐位递推法**：通过逐位计算循环长度，利用前 \(i-1\) 位的循环长度推导出第 \(i\) 位的循环长度。这种方法的核心思想是通过递推逐步扩大位数，每次只关注当前位的循环情况，时间复杂度为 \(O(k^2 \times N^2)\)，其中 \(N\) 为 \(n\) 的位数。

2. **欧拉定理法**：利用欧拉定理和其推广形式，通过枚举 \(\varphi(10^k)\) 的因子来求解循环长度。这种方法虽然理论上有较高的时间复杂度，但通过优化（如高精度压位）可以降低实际运行时间。

3. **模拟法**：直接通过反复乘 \(n\) 并比较后 \(k\) 位来寻找循环长度。这种方法虽然直观，但时间复杂度较高，无法通过大数据范围。

### 所选高星题解

#### 1. **作者：_Life_ (赞：146)**
- **星级**：5星
- **关键亮点**：
  - 逐位递推的思路清晰，通过逐位计算循环长度，逐步扩大位数。
  - 详细的手玩数据示例，帮助理解递推过程。
  - 代码实现简洁，高精度乘法优化得当。
- **个人心得**：作者通过手玩数据 `198123 4`，逐步推导出循环长度的计算过程，帮助读者更好地理解递推的思路。

```cpp
// 核心代码：逐位递推计算循环长度
for(int i=0;i<k;i++) {
    bignum tmp=n;
    int j=1,flag=1;
    for(j=1;j<=10;j++) {
        tmp=tmp*mul;
        if(tmp.x[i]==n.x[i]) {
            ans=ans*j;
            flag=0;
            break;
        }
    }
    if(flag) return puts("-1"),0;
    tmp=mul;
    for(int k=1;k<j;k++) mul=mul*tmp;
}
```

#### 2. **作者：MyukiyoMekya (赞：72)**
- **星级**：4星
- **关键亮点**：
  - 利用欧拉定理及其推广形式，通过枚举 \(\varphi(10^k)\) 的因子来求解循环长度。
  - 通过递推优化快速幂计算，降低时间复杂度。
  - 高精度压位优化，提升代码效率。
- **个人心得**：作者通过欧拉定理的推广形式，结合递推优化，成功降低了时间复杂度，并通过高精度压位进一步优化了代码。

```cpp
// 核心代码：利用欧拉定理求解循环长度
for(int i=0;i<=k+1;++i) {
    for(int j=0;j<k;++j) {
        if(!i&&!j) continue;
        B=twopow[i]*fivepow[j];
        t=dp[i][j]*A;
        if(issame(t,A)) {
            if(ans.a[1]==-1||B<ans) ans=B;
        }
    }
}
```

#### 3. **作者：Shadow_Soldier (赞：5)**
- **星级**：4星
- **关键亮点**：
  - 递推法思路清晰，通过逐位计算循环长度，逐步扩大位数。
  - 详细的理论推导，帮助理解递推过程。
  - 代码实现简洁，高精度乘法优化得当。
- **个人心得**：作者通过详细的理论推导，逐步解释了递推法的核心思想，并通过代码实现展示了如何逐位计算循环长度。

```cpp
// 核心代码：逐位递推计算循环长度
for(int i=1;i<=k;i++) {
    u.InInt(1);
    for(int j=1;j<=f[i-1];j++) u=u*v;
    v=u;
    w=n;
    for(int j=1;j<=10;j++) {
        w=w*u;
        if(w.a[i]==n.a[i]) {
            f[i]=j;
            break;
        }
    }
    if(!f[i]) {
        cout<<-1;
        return 0;
    }
    w.InInt(f[i]);
    ans=ans*w;
}
```

### 最优关键思路与技巧

1. **逐位递推法**：通过逐位计算循环长度，利用前 \(i-1\) 位的循环长度推导出第 \(i\) 位的循环长度。这种方法的核心思想是通过递推逐步扩大位数，每次只关注当前位的循环情况。

2. **欧拉定理法**：利用欧拉定理和其推广形式，通过枚举 \(\varphi(10^k)\) 的因子来求解循环长度。这种方法虽然理论上有较高的时间复杂度，但通过优化（如高精度压位）可以降低实际运行时间。

3. **高精度优化**：在处理大数时，高精度乘法的优化至关重要。通过压位、递推优化等方法，可以有效降低时间复杂度，提升代码效率。

### 可拓展之处

1. **同类型题**：类似的问题可以扩展到其他进制下的循环长度计算，或者扩展到更高位数的循环长度计算。
2. **算法套路**：递推法和欧拉定理法可以应用于其他需要求解循环长度的问题，如矩阵幂的循环长度、多项式幂的循环长度等。

### 推荐题目

1. **P1050 [NOIP2005 普及组] 循环**（本题）
2. **P1066 [NOIP2009 提高组] 多项式输出**（涉及高精度计算）
3. **P1072 [NOIP2012 提高组] 同余方程**（涉及欧拉定理的应用）

### 个人心得总结

- **调试经历**：多位作者通过手玩数据或详细的理论推导，逐步理解了递推法和欧拉定理法的核心思想，并通过代码实现展示了如何逐位计算循环长度。
- **踩坑教训**：在处理大数时，高精度乘法的优化至关重要。通过压位、递推优化等方法，可以有效降低时间复杂度，提升代码效率。
- **顿悟感想**：通过逐位递推法，逐步扩大位数，每次只关注当前位的循环情况，可以有效降低问题的复杂度，提升解题效率。

---
处理用时：42.47秒
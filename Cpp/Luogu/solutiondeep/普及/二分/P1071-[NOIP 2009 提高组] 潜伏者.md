# 题目信息

# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# AI分析结果

### 综合分析与结论

本题的核心在于通过给定的原信息和加密信息，构建一个字母到字母的映射关系（即密码本），并利用该映射关系翻译新的加密信息。题解的主要思路是通过遍历原信息和加密信息，逐步构建映射关系，并在构建过程中进行合法性检查。合法性检查包括：
1. 确保每个字母只对应一个唯一的密字。
2. 确保所有26个字母都出现在原信息中。
3. 确保映射关系没有冲突（即没有一对多或多对一的情况）。

大多数题解都使用了`map`或数组来存储映射关系，并通过遍历和条件判断来确保映射的合法性。部分题解还使用了`set`或数组来记录已经映射过的字母，以避免重复映射。

### 所选高星题解

#### 1. 作者：CYJian (5星)
**关键亮点**：
- 使用`map`双向记录映射关系，确保映射的唯一性。
- 代码简洁，逻辑清晰，直接通过遍历和条件判断完成映射构建和合法性检查。
- 通过`book`变量记录已映射的字母数量，确保所有26个字母都被映射。

**核心代码**：
```cpp
map<char,char>mp,mq;
for(int i=0;i<la;i++)
    if(mp[a[i]]==0&&mq[b[i]]==0)
        mp[a[i]]=b[i] , mq[b[i]]=a[i] , book--;
    else if(mp[a[i]]!=b[i]||mq[b[i]]!=a[i])
        ERROR;
if(book>0) ERROR;
for(int i=0;i<lc;i++) printf("%c",mp[c[i]]);
```

#### 2. 作者：陈嘉逸2012 (4星)
**关键亮点**：
- 使用`map`和`vis`数组分别记录映射关系和已映射的字母，确保映射的唯一性和完整性。
- 代码简洁，逻辑清晰，通过遍历和条件判断完成映射构建和合法性检查。

**核心代码**：
```cpp
map<char,char>mp;map<char,bool>vis;
for(int i=0;i<a.size();i++){
    if(vis[b[i]]&&b[i]!=mp[a[i]]){cout<<"Failed\n";return 0;}
    mp[a[i]]=b[i],vis[b[i]]=1;
}
for(char i='A';i<='Z';i++){
    if(!vis[i]){cout<<"Failed\n";return 0;}
}
for(int i=0;i<c.size();i++) cout<<mp[c[i]];
```

#### 3. 作者：lianghuahua (4星)
**关键亮点**：
- 使用`map`和`set`分别记录映射关系和已映射的字母，确保映射的唯一性和完整性。
- 通过`count`函数检查映射冲突，逻辑清晰。

**核心代码**：
```cpp
map<char, char> mp; set<char> st;
for(int i = 0; i < s1.size(); i++){
    if(mp.count(s1[i])) {
        if(mp[s1[i]] != s2[i]) {
            cout << "Failed";
            return 0;
        }
    }else{
        if(st.count(s2[i])) {
            cout << "Failed";
            return 0;
        }            
        mp[s1[i]] = s2[i];
        st.insert(s2[i]);
    }
}
if(mp.size() < 26){
    cout << "Failed";
    return 0;
}
for(int i = 0; i < s3.size(); i++){
    cout << mp[s3[i]];
}
```

### 最优关键思路或技巧
- **双向映射**：使用两个`map`或`map`和`set`来确保映射的唯一性和完整性。
- **合法性检查**：在构建映射关系时，实时检查映射是否冲突，确保每个字母只对应一个唯一的密字。
- **遍历与条件判断**：通过遍历原信息和加密信息，逐步构建映射关系，并在构建过程中进行合法性检查。

### 可拓展之处
- **类似题型**：可以扩展到其他需要构建映射关系的题目，如密码破解、字符替换等。
- **算法优化**：可以考虑使用更高效的数据结构（如哈希表）来优化映射的构建和查询。

### 推荐题目
1. [P1072 Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072) - 考察数学与映射关系。
2. [P1087 FBI树](https://www.luogu.com.cn/problem/P1087) - 考察树结构与字符映射。
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 考察贪心与映射关系。

---
处理用时：32.69秒
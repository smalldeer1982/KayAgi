# 题目信息

# [NOIP 2007 提高组] 树网的核

## 题目描述

设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。

路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 
$d(a, b)$ 为 $a, b$ 两结点间的距离。

$D(v, P)=\min\{d(v, u)\}$, $u$ 为路径 $P$ 上的结点。

树网的直径：树网中最长的路径成为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

偏心距 $\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即

$$\mathrm{ECC}(F)=\max\{D(v, F),v \in V\}$$

任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)


## 说明/提示

- 对于 $40\%$ 的数据，保证 $n \le 15$。
- 对于 $70\%$ 的数据，保证 $n \le 80$。
- 对于 $100\%$ 的数据，保证 $2\le n \le 300$，$0\le s\le10^3$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^3$。

NOIP2007 提高组第四题

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心是在树网（无根树）中找到一条长度不超过 `s` 的路径，使得该路径的偏心距最小。题解中主要涉及以下几种思路：

1. **枚举法**：通过枚举直径上的路径，计算每条路径的偏心距，时间复杂度为 `O(n^3)`。
2. **双指针优化**：在枚举时使用双指针技巧，减少候选路径数量，时间复杂度优化为 `O(n^2)`。
3. **二分法**：通过二分偏心距，将最优化问题转化为存在性问题，时间复杂度为 `O(n log n)`。
4. **单调队列优化**：在双指针的基础上，使用单调队列维护区间最大值，进一步优化时间复杂度到 `O(n)`。

### 所选高星题解

#### 1. **作者：StudyingFather (赞：222)**  
**星级：5星**  
**关键亮点**：
- 详细分析了树网的性质，证明了路径位于直径上的必要性。
- 提供了四种解法，从暴力枚举到单调队列优化，逐步优化时间复杂度。
- 代码结构清晰，使用 `namespace` 隔离不同解法，便于对比学习。

**核心代码**：
```cpp
namespace sub4 {
void solve() {
  for (int i = 1; i <= cnt; i++) vis[dia[i]] = true;
  int maxd = 0;
  for (int i = 1; i <= cnt; i++) {
    dep[dia[i]] = 0, c = 0;
    dfs(dia[i], 0);
    maxd = max(dep[c], maxd);
  }
  int l = 1, r = 1;
  int minecc = 1 << 30;
  for (; l <= cnt; l++) {
    while (r <= cnt && pres[r + 1] - pres[l] <= s) r++;
    minecc = min(max(maxd, max(pres[l], posts[r])), minecc);
  }
  cout << minecc << endl;
}
}
```
**核心思想**：通过双指针和单调队列优化，动态更新偏心距的组成，避免了重复的 DFS 操作。

#### 2. **作者：Mosklia (赞：193)**  
**星级：4.5星**  
**关键亮点**：
- 详细解释了直径的性质，并提出了单调队列优化的思路。
- 通过动态规划的方式，将问题转化为区间最大值问题，使用单调队列维护。
- 代码实现简洁，逻辑清晰。

**核心代码**：
```cpp
std::deque<int> q;
int ans = 2147483647;
for (int i = 1, j = 1; i <= m; dist2 -= pt[del[i]].fa_dist, ++i) {
  while (!q.empty() && pt[q.front()].cur_dist - s > pt[del[i]].cur_dist)
    q.pop_front();
  while (j < i && tot - dist1 - dist2 > s)
    dist1 += pt[del[j++]].fa_dist;
  while (!q.empty() && pt[q.back()].dist < pt[del[i]].dist)
    q.pop_back();
  q.push_back(del[i]);
  int temp = std::max(dist1, dist2);
  temp = std::max(temp, pt[q.front()].dist);
  ans = std::min(temp, ans);
}
```
**核心思想**：使用单调队列维护区间最大值，动态更新偏心距，减少了时间复杂度。

#### 3. **作者：天泽龟 (赞：60)**  
**星级：4星**  
**关键亮点**：
- 提出了二分法的思路，将问题转化为存在性问题，降低了时间复杂度。
- 详细讨论了二分边界的确定，考虑了支链对偏心距的影响。
- 代码实现较为复杂，但思路清晰，适合深入学习。

**核心代码**：
```cpp
bool check(ll x) {
  l1 = l2 = 0; p = drop(A, 0, x); q = up(B, x);
  return (d[q] - d[p] <= s);
}
```
**核心思想**：通过二分偏心距，将问题转化为判断是否存在满足条件的路径，减少了计算量。

### 最优关键思路与技巧

1. **路径位于直径上**：通过证明，最优路径必然位于树的直径上，减少了搜索空间。
2. **双指针优化**：在枚举路径时，使用双指针技巧减少候选路径数量，优化时间复杂度。
3. **单调队列维护区间最大值**：在双指针的基础上，使用单调队列动态维护区间最大值，进一步优化了时间复杂度。

### 可拓展之处

- **类似问题**：类似的问题可以在其他树结构上应用，如最小生成树、最短路径树等。
- **算法套路**：双指针、单调队列、二分法等优化技巧可以应用于其他区间最值问题。

### 推荐题目

1. [P2491 [SDOI2011]消防](https://www.luogu.com.cn/problem/P2491)
2. [P1099 [NOIP2007 提高组] 树网的核](https://www.luogu.com.cn/problem/P1099)
3. [P3177 [HAOI2015]树上染色](https://www.luogu.com.cn/problem/P3177)

### 个人心得摘录

- **StudyingFather**：通过逐步优化解法，深刻理解了树网的性质和优化技巧。
- **Mosklia**：在实现单调队列时，发现可以通过动态规划的方式简化问题，减少了代码复杂度。
- **天泽龟**：在二分法的实现中，发现支链对偏心距的影响，进一步优化了二分边界。

---
处理用时：41.07秒
# 题目信息

# 修复公路

## 题目背景

A 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。

## 题目描述

给出 A 地区的村庄数 $N$，和公路数 $M$，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）。

## 说明/提示

$1\leq x, y\leq N \le 10 ^ 3$，$1\leq M, t \le 10 ^ 5$。

## 样例 #1

### 输入

```
4 4
1 2 6
1 3 4
1 4 5
4 2 3```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心是通过并查集或最小生成树算法，找到使所有村庄连通的最早时间。大多数题解采用了并查集结合贪心的思路，按时间排序后逐步合并村庄，直到所有村庄连通。部分题解还引入了最小生成树（如Kruskal算法）来优化时间复杂度。

### 所选高星题解

#### 1. 题解作者：qwaszx (5星)
**关键亮点**：
- 简洁明了地使用并查集，按时间排序后逐步合并村庄，直到所有村庄连通。
- 代码清晰，逻辑简单，适合初学者理解并查集的基本应用。
- 通过`n--`来记录连通块数量，优化了判断是否所有村庄连通的过程。

**个人心得**：
- 作者提到“最小生成树放到这里有些浪费了”，强调了并查集的适用性。

**核心代码**：
```cpp
for(int i=1;i<=m;i++) {
    int fx=find(a[i].x), fy=find(a[i].y);
    if(fx!=fy) f[fx]=fy, n--;
    if(n==1) { cout<<a[i].t; return 0; }
}
```

#### 2. 题解作者：Euler_Pursuer (4星)
**关键亮点**：
- 详细解释了并查集的原理，并引入了最小生成树（Kruskal算法）来优化合并过程。
- 通过记录集合大小来判断是否所有村庄连通，优化了判断逻辑。
- 代码结构清晰，注释详细，适合进阶学习者。

**核心代码**：
```cpp
int TREE(E *e, int *s) {
    int i, total=0;
    SORT(e, 1, M);
    for(i=1;i<=M;i++)
        if(findfather(s, s[e[i].a])!=findfather(s, s[e[i].b])) {
            together(&s[e[i].a], s[e[i].b], s);
            total++;
            ans=e[i].t;
        }
    return total;
}
```

#### 3. 题解作者：Coding__QAQ (4星)
**关键亮点**：
- 使用并查集模板，按时间排序后逐步合并村庄，直到所有村庄连通。
- 通过`num`记录合并次数，优化了判断是否所有村庄连通的过程。
- 代码简洁，逻辑清晰，适合初学者理解并查集的基本应用。

**核心代码**：
```cpp
for(int i=1;i<=m;i++) {
    int x=find(e[i].x), y=find(e[i].y);
    if(x==y) continue;
    fa[x]=y; num++; ans=max(ans,e[i].t);
    if(num==n-1) printf("%d\n",ans);
}
```

### 最优关键思路与技巧
1. **并查集优化**：通过路径压缩和按秩合并，优化并查集的查找和合并操作。
2. **贪心策略**：按时间排序后，优先合并时间较早的道路，确保最早连通。
3. **集合大小记录**：通过记录集合大小，快速判断是否所有村庄连通。

### 可拓展之处
- **最小生成树**：本题可以拓展为最小生成树问题，适用于更复杂的图论场景。
- **动态连通性**：可以进一步研究动态连通性问题，如在线处理边的添加和删除。

### 推荐相似题目
1. P3367 【模板】并查集
2. P1119 修复公路
3. P1196 [NOI2002] 银河英雄传说

### 个人心得总结
- **调试经历**：部分作者提到在调试过程中遇到的坑，如排序时忘记从1开始，导致WA。
- **顿悟感想**：通过并查集和贪心策略的结合，能够高效解决连通性问题，强调了算法选择的重要性。

---
处理用时：30.98秒
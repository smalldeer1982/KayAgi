# 题目信息

# 封锁阳光大学

## 题目描述

曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。

阳光大学的校园是一张由 $n$ 个点构成的无向图，$n$ 个点之间由 $m$ 条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。

询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。


## 说明/提示

【数据规模】   
对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，保证没有重边。

## 样例 #1

### 输入

```
3 3
1 2
1 3
2 3
```

### 输出

```
Impossible
```

## 样例 #2

### 输入

```
3 2
1 2
2 3
```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

该题目要求封锁所有道路且相邻点不能同时被封锁，本质上是图的二分图染色问题。大多数题解采用了DFS或BFS进行黑白染色，并通过统计两种颜色的数量来求解最小封锁数。部分题解还使用了并查集来处理图的连通性问题。整体思路较为一致，但实现细节和优化程度有所不同。

### 所选题解

#### 1. 作者：KesdiaelKen (赞：438)
- **星级**：5星
- **关键亮点**：
  - 思路清晰，详细解释了二分图染色的原理。
  - 使用链式前向星存储图，优化了空间复杂度。
  - 通过`used`数组避免重复遍历，提高了效率。
  - 代码结构清晰，注释详细，易于理解。
- **个人心得**：
  - 强调了图的连通性处理，提醒了图可能不连通的情况。
  - 通过`sum`数组统计两种颜色的数量，简化了最小值的计算。

```cpp
bool dfs(int node, int color) {
    if (used[node]) {
        if (col[node] == color) return true;
        return false;
    }
    used[node] = true;
    sum[col[node] = color]++;
    bool tf = true;
    for (int i = head[node]; i != 0 && tf; i = edge[i].nexty) {
        tf = tf && dfs(edge[i].t, 1 - color);
    }
    return tf;
}
```

#### 2. 作者：dingcx (赞：175)
- **星级**：4星
- **关键亮点**：
  - 使用BFS进行染色，避免了递归深度过大的问题。
  - 通过`used`数组记录颜色，简化了冲突判断。
  - 代码简洁，逻辑清晰，适合初学者理解。
- **个人心得**：
  - 强调了图的连通性处理，提醒了图可能不连通的情况。
  - 通过`sum`数组统计两种颜色的数量，简化了最小值的计算。

```cpp
bool bfs(int start) {
    used[start] = 1;
    sum[1] = 1, sum[2] = 0;
    q.push(start);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int k = h[u]; k; k = e[k].next) {
            int v = e[k].v;
            if (used[v] == used[u]) return 1;
            if (used[v] == 0) {
                used[v] = used[u] % 2 + 1;
                sum[used[v]]++;
                q.push(v);
            }
        }
    }
    return 0;
}
```

#### 3. 作者：wshz (赞：158)
- **星级**：4星
- **关键亮点**：
  - 使用并查集处理图的连通性，避免了重复遍历。
  - 通过`h`数组记录敌对关系，简化了冲突判断。
  - 代码结构清晰，逻辑严谨，适合进阶学习。
- **个人心得**：
  - 强调了并查集在处理图连通性问题时的优势。
  - 通过`t`数组统计集合大小，简化了最小值的计算。

```cpp
void xx(int x, int y) {
    int qq = find(x);
    if (qq != y) {
        f[y] = qq;
        t[qq] += t[y];
    }
}
```

### 最优关键思路与技巧

1. **二分图染色**：通过DFS或BFS对图进行黑白染色，确保相邻节点颜色不同，从而满足题目要求。
2. **图的连通性处理**：由于图可能不连通，需要分别处理每个连通分量，确保每个子图都能被正确染色。
3. **最小封锁数计算**：统计每个连通分量中两种颜色的数量，取较小值累加得到最终答案。
4. **并查集优化**：在处理图的连通性时，使用并查集可以高效地合并和查找集合，避免重复遍历。

### 可拓展之处

- **类似题目**：可以扩展到其他需要二分图染色的题目，如判断图是否为二分图、求最大匹配等。
- **算法优化**：可以进一步优化DFS或BFS的实现，如使用迭代DFS避免递归栈溢出，或使用双向BFS提高搜索效率。

### 推荐题目

1. **P3386 【模板】二分图匹配**：考察二分图的最大匹配问题。
2. **P1337 【模板】二分图判定**：判断图是否为二分图。
3. **P1338 【模板】二分图最大权匹配**：考察二分图的最大权匹配问题。

### 个人心得总结

- **调试经历**：在处理图的连通性时，容易忽略图可能不连通的情况，导致WA。通过增加对每个连通分量的处理，解决了这一问题。
- **踩坑教训**：在染色过程中，未及时判断冲突，导致程序无法正确输出"Impossible"。通过增加冲突判断，解决了这一问题。
- **顿悟感想**：二分图染色问题本质上是图的二分性判断，通过染色可以直观地判断图是否满足题目要求。

---
处理用时：40.08秒
# 题目信息

# 营救

## 题目背景

“咚咚咚……”“查水表！”原来是查水表来了，现在哪里找这么热心上门的查表员啊！小明感动得热泪盈眶，开起了门……

## 题目描述

妈妈下班回家，街坊邻居说小明被一群陌生人强行押上了警车！妈妈丰富的经验告诉她小明被带到了 $t$ 区，而自己在 $s$ 区。

该市有 $m$ 条大道连接 $n$ 个区，一条大道将两个区相连接，每个大道有一个拥挤度。小明的妈妈虽然很着急，但是不愿意拥挤的人潮冲乱了她优雅的步伐。所以请你帮她规划一条从 $s$ 至 $t$ 的路线，使得经过道路的拥挤度最大值最小。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 10$。
- 对于 $60\%$ 的数据，保证 $n\leq 100$。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m \leq 2 \times 10^4$，$w \leq 10^4$，$1 \leq s, t \leq n$。且从 $s$ 出发一定能到达 $t$ 区。

--- 

#### 样例输入输出 1 解释

小明的妈妈要从 $1$ 号点去 $3$ 号点，最优路线为 $1$->$2$->$3$。

## 样例 #1

### 输入

```
3 3 1 3
1 2 2
2 3 1
1 3 3```

### 输出

```
2
```

# AI分析结果

### 综合分析与结论

本题的核心是找到从起点 `s` 到终点 `t` 的路径，使得路径上的最大拥挤度最小。题解中主要采用了以下几种思路：

1. **最小生成树（Kruskal算法）**：通过将边按拥挤度从小到大排序，逐步构建最小生成树，直到 `s` 和 `t` 连通。此时最后加入的边的拥挤度即为所求。
2. **最短路算法（Dijkstra/SPFA）**：通过修改松弛操作，将路径的最大拥挤度作为更新的依据，最终得到 `s` 到 `t` 的最小最大拥挤度。
3. **二分答案 + BFS/并查集**：通过二分最大拥挤度，判断在该拥挤度下 `s` 和 `t` 是否连通，最终找到最小的最大拥挤度。

这些方法各有优劣，最小生成树思路清晰且易于实现，最短路算法适合稀疏图，二分答案则适合处理边界情况。

### 所选高星题解

#### 题解1：lzk5627（5星）
- **关键亮点**：使用Kruskal算法构建最小生成树，思路清晰，代码简洁，易于理解。
- **个人心得**：作者提到原本想用克鲁斯卡尔重构树，但发现最小生成树即可解决问题，体现了对问题的深入理解。
- **核心代码**：
  ```cpp
  for(int i=1;i<=m;i++) {
      int X=find(b[i].x), Y=find(b[i].y);
      if(X!=Y) a[X]=Y;
      if(find(s)==find(t)) {
          cout<<b[i].cost<<endl;
          return 0;
      }
  }
  ```
  **实现思想**：通过并查集维护连通性，当 `s` 和 `t` 连通时，输出当前边的拥挤度。

#### 题解2：薄荷凉了夏（4星）
- **关键亮点**：使用Dijkstra算法，修改松弛操作为取最大值，适合稀疏图，代码可读性强。
- **核心代码**：
  ```cpp
  for(int i=head[x];i;i=edge[i].next) {
      int k=max(dis[x],edge[i].w), r=edge[i].now;
      if(k<dis[r]) {
          dis[r]=k;
          q.push(make_pair(-dis[r],r));
      }
  }
  ```
  **实现思想**：通过优先队列实现Dijkstra算法，松弛操作取最大值，确保路径的最大拥挤度最小。

#### 题解3：Orion_Rigel（4星）
- **关键亮点**：二分答案 + BFS，通过二分最大拥挤度，判断 `s` 和 `t` 是否连通，思路新颖。
- **核心代码**：
  ```cpp
  while(l<r) {
      int mid=(l+r)/2;
      if(SPFA(mid)) r=mid;
      else l=mid+1;
  }
  ```
  **实现思想**：通过二分最大拥挤度，使用BFS判断 `s` 和 `t` 是否连通，最终找到最小的最大拥挤度。

### 最优关键思路与技巧

1. **最小生成树的应用**：通过Kruskal算法逐步构建最小生成树，直到 `s` 和 `t` 连通，最后加入的边的拥挤度即为所求。
2. **最短路算法的修改**：通过修改Dijkstra或SPFA的松弛操作，将路径的最大拥挤度作为更新的依据，确保路径的最大拥挤度最小。
3. **二分答案的灵活应用**：通过二分最大拥挤度，结合BFS或并查集判断 `s` 和 `t` 是否连通，适合处理边界情况。

### 拓展思路与同类型题

1. **拓展思路**：类似的问题可以扩展到其他图论问题，如最短路径、最小生成树、最大流等，关键在于如何定义路径的“最优”标准。
2. **同类型题**：
   - [P1111 修复公路](https://www.luogu.com.cn/problem/P1111)：最小生成树的应用。
   - [P1547 Out of Hay](https://www.luogu.com.cn/problem/P1547)：最小生成树的最大边。
   - [P1395 营救](https://www.luogu.com.cn/problem/P1395)：类似的最短路问题。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现最短路算法无法直接应用，需要修改松弛操作，体现了对问题的深入理解。
- **顿悟感想**：通过最小生成树或二分答案的思路，能够更直观地解决问题，体现了对算法灵活应用的思考。

### 推荐题目
1. [P1111 修复公路](https://www.luogu.com.cn/problem/P1111)
2. [P1547 Out of Hay](https://www.luogu.com.cn/problem/P1547)
3. [P1395 营救](https://www.luogu.com.cn/problem/P1395)

---
处理用时：39.48秒
# 题目信息

# [yLOI2018] 树上的链

## 题目描述

给定一棵有 $n$ 个节点的树。每个节点有一个点权和一个参数。节点 $i$ 的权值为 $w_i$，参数为 $c_i$。$1$ 是这棵树的根。

现在，对每个节点 $u$（$1 \leq u \leq n$），请在树上你找到最长的一条链 $v_1, v_2, \dots v_m$，满足如下条件：

1. $v_1 = u$。
2. 对 $2 \leq i \leq m$， 有 $v_i$ 是 $v_{i - 1}$ 的父节点。
3. 链上节点的点权和不超过 $c_u$，即 $\sum_{j = 1}^m w_{v_j} \leq c_u$。 

## 说明/提示

### 数据规模与约定

对全部的测试点，保证 $1 \leq u, v \leq n \leq 10^5$，$1 \leq p_i \lt i$，$1 \leq w_i \leq c_i \leq 10^9$。

## 样例 #1

### 输入

```
5
1 1 2 2
1 2 3 4 5
1 3 3 6 8```

### 输出

```
1 2 1 2 3```

# AI分析结果

### 综合分析与结论

本题的核心问题是在树上为每个节点找到一条从该节点到根的链，使得链上节点的权值和不超过该节点的参数 \( c_u \)。由于树的结构和权值的单调性，大多数题解都采用了 **DFS + 二分查找** 的思路，通过维护一个栈来记录当前节点到根的路径，并在栈上进行二分查找以快速找到满足条件的链的起点。

**关键思路与技巧：**
1. **DFS + 栈维护路径**：通过DFS遍历树，同时维护一个栈来记录当前节点到根的路径，方便后续的二分查找。
2. **前缀和优化**：计算从根到当前节点的前缀和，利用前缀和的单调性进行二分查找。
3. **二分查找**：在栈上进行二分查找，快速找到满足条件的链的起点，避免暴力枚举。
4. **数据结构选择**：使用 `std::vector` 代替 `std::stack`，因为 `std::vector` 支持随机访问，便于二分查找。

**拓展思路：**
- **树上倍增**：可以使用树上倍增的方法来优化查找过程，类似于LCA问题的处理方式。
- **动态规划**：在某些变种问题中，可以考虑使用动态规划来维护树上的信息。

### 所选高星题解

#### 1. **作者：oddy (5星)**
**关键亮点：**
- **思路清晰**：详细解释了DFS和二分查找的结合使用，逻辑清晰。
- **代码简洁**：代码结构清晰，变量命名合理，易于理解。
- **优化到位**：通过栈维护路径，利用前缀和的单调性进行二分查找，时间复杂度为 \(O(n \log n)\)。

**核心代码：**
```cpp
void dfs(int x) {
    q[tail++] = x;
    ans[x] = q + tail - std::lower_bound(q, q+tail, s[x] - c[x], cmp) - 1; // 二分找到位置，算出距离

    for(const int &p : e[x]) s[p] = s[x] + w[p], dfs(p); // 算出子节点的前缀和，接着往下递归
    tail--;
}
```
**核心思想**：通过DFS遍历树，维护一个栈记录当前路径，利用前缀和的单调性进行二分查找，快速找到满足条件的链的起点。

#### 2. **作者：一扶苏一 (4星)**
**关键亮点：**
- **详细分析**：对DFS和二分查找的结合进行了详细分析，解释了如何利用栈维护路径。
- **代码规范**：代码结构清晰，使用了 `std::vector` 代替 `std::stack`，便于二分查找。

**核心代码：**
```cpp
void dfs(const int u) {
  stk.push_back(w.at(u) + stk.back());
  int ret = 0;
  for (int l = 0, r = stk.size() - 1, mid = (l + r) >> 1; l <= r; mid = (l + r) >> 1) if (stk.back() - stk.at(mid) <= c.at(u)) {
    r = (ret = mid) - 1;
  } else {
    l = mid + 1;
  }
  ans.at(u) = stk.size() - ret - 1;
  for (auto v : e[u]) dfs(v);
  stk.pop_back();
}
```
**核心思想**：通过DFS遍历树，维护一个栈记录当前路径，利用前缀和的单调性进行二分查找，快速找到满足条件的链的起点。

#### 3. **作者：knya (4星)**
**关键亮点：**
- **优化到位**：使用了快读和快写优化，代码运行效率高。
- **思路清晰**：详细解释了前缀和和二分查找的结合使用，逻辑清晰。

**核心代码：**
```cpp
void dfs(int u)
{
	sta[++tt]=u;
	int l=0,r=tt;
	sum[u]+=sum[fa[u]];
	
	while(l<r)
	{
		int mid=l+r>>1;
		if(sum[u]-sum[sta[mid]]<=c[u])r=mid,ans[u]=tt-mid;
		else l=mid+1;
	}
	
	int sz=son[u].size();//存起来可以加快一些速度
	for(int i=0;i<sz;++i)dfs(son[u][i]);
	--tt;
}
```
**核心思想**：通过DFS遍历树，维护一个栈记录当前路径，利用前缀和的单调性进行二分查找，快速找到满足条件的链的起点。

### 推荐题目
1. **P3379 【模板】最近公共祖先（LCA）**：考察树上路径的查找与优化。
2. **P3384 【模板】树链剖分**：考察树上的路径查询与修改。
3. **P2634 [国家集训队] 聪聪可可**：考察树上的路径统计与优化。

### 个人心得总结
- **调试经历**：多位作者提到在调试过程中遇到了栈溢出或TLE的问题，最终通过优化二分查找和使用 `std::vector` 代替 `std::stack` 解决了问题。
- **踩坑教训**：需要注意数据范围，尤其是前缀和可能超过 `int` 的范围，必须使用 `long long`。
- **顿悟感想**：通过DFS和二分查找的结合，可以高效地解决树上的路径问题，这种思路在其他类似问题中也有广泛应用。

---
处理用时：37.19秒
# 题目信息

# 扩散

## 题目描述

一个点每过一个单位时间就会向四个方向扩散一个距离，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/cd4e53lw.png)

两个点 $a$ 、 $b$ 连通，记作 $e(a,b)$，当且仅当 $a,b$ 的扩散区域有公共部分。连通块的定义是块内的任意两个点 $u,v$ 都必定存在路径 $e(u,a_0),e(a_0,a_1),\cdots,e(a_k,v)$。给定平面上的 $n$ 个点，问最早什么时刻它们形成一个连通块。


## 说明/提示

### 数据范围及约定

对于 $20\%$ 的数据，满足 $1 \le N \le 5;1 \le X_i,Y_i \le 50$。

对于 $100\%$ 的数据，满足 $1 \le N \le 50$，$1 \le X_i,Y_i \le 10^9$。

## 样例 #1

### 输入

```
2

0 0

5 5```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心是求平面上多个点通过扩散形成连通块的最早时间。扩散过程可以理解为每个点以单位时间向四个方向扩展一个单位距离，最终要求所有点的扩散区域有交集。题解中主要采用了以下几种思路：

1. **二分答案 + 并查集**：通过二分时间，判断在该时间内是否能够形成连通块，并使用并查集来维护连通性。
2. **Floyd算法**：通过Floyd算法计算每对点之间的扩散时间，最终取最大值。
3. **最小生成树**：将扩散时间作为边的权值，构建最小生成树，找到最长边作为答案。

这些方法的核心思想都是通过某种方式计算点对之间的扩散时间，并找到最大的扩散时间作为答案。其中，二分答案 + 并查集和最小生成树的方法较为常见，而Floyd算法则利用了图论中的最短路径思想。

### 所选高星题解

#### 1. **封禁用户 (5星)**
- **关键亮点**：使用二分答案 + 并查集，思路清晰，代码简洁，且对扩散时间的处理（曼哈顿距离的2倍）有详细解释。
- **个人心得**：作者提到“两个点都能扩散，所以相对的扩散速度会增倍”，这一观察是解题的关键。
- **核心代码**：
  ```cpp
  int dis = abs(xs[i] - xs[j]) + abs(ys[i] - ys[j]);
  if (dis <= mid * 2) {
      int aa = find(i), ab = find(j);
      if (aa != ab) ints[aa] = ab;
  }
  ```
  **实现思想**：通过二分时间，判断两点在给定时间内是否能够连通，并使用并查集维护连通性。

#### 2. **zzr8178541919 (4星)**
- **关键亮点**：直接计算每对点之间的扩散时间，避免了二分答案的复杂度，代码简洁且高效。
- **个人心得**：作者通过分析扩散过程，得出了扩散时间的计算公式，简化了问题。
- **核心代码**：
  ```cpp
  place[i][j] = place[j][i] = (abs(a[i].x - a[j].x) + abs(a[i].y - a[j].y));
  for (int k = 1; k <= n; k++)
      for (int i = 1; i <= n; i++)
          for (int j = 1; j <= n; j++)
              place[i][j] = min(place[i][j], max(place[i][k], place[k][j]));
  ```
  **实现思想**：通过Floyd算法计算每对点之间的扩散时间，最终取最大值。

#### 3. **AntaresQAQ (4星)**
- **关键亮点**：将问题转化为最小生成树问题，使用Kruskal算法求解，思路清晰且代码简洁。
- **个人心得**：作者提到“最小生成树是最小瓶颈生成树”，这一观察是解题的关键。
- **核心代码**：
  ```cpp
  if (Find(e[i].x) != Find(e[i].y)) {
      father[Find(e[i].x)] = Find(e[i].y);
      ans = max(e[i].val, ans);
  }
  ```
  **实现思想**：通过Kruskal算法构建最小生成树，找到最长边作为答案。

### 最优关键思路与技巧

1. **二分答案 + 并查集**：适用于需要寻找最小或最大值的场景，通过二分答案快速缩小范围，并结合并查集判断连通性。
2. **Floyd算法**：适用于计算所有点对之间的最短路径或最大路径，通过动态规划的思想逐步更新距离。
3. **最小生成树**：适用于需要构建连通图并找到最长边的场景，通过Kruskal或Prim算法求解。

### 可拓展之处

- **类似问题**：如“修复公路”（P1111）等最小生成树问题，可以通过类似的方法解决。
- **其他算法**：如Dijkstra算法、Bellman-Ford算法等，也可以用于解决类似的图论问题。

### 推荐题目

1. **P1111 修复公路**：最小生成树的经典问题。
2. **P3366 【模板】最小生成树**：最小生成树的模板题。
3. **P4779 【模板】单源最短路径（标准版）**：最短路径的模板题，可以使用Dijkstra或Bellman-Ford算法。

### 个人心得总结

- **调试经历**：多位作者提到在计算扩散时间时需要注意曼哈顿距离的2倍关系，这一细节是解题的关键。
- **踩坑教训**：部分作者在实现二分答案时，初始边界设置不当，导致超时或错误，建议仔细分析数据范围。
- **顿悟感想**：通过将问题转化为图论问题（如最小生成树或最短路径），可以简化问题并提高解题效率。

---
处理用时：35.51秒
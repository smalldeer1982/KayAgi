# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何处理动物之间的复杂关系（同类、捕食、被捕食），并利用并查集来维护这些关系。大多数题解采用了“种类并查集”或“带权并查集”的思路，通过扩展并查集的规模或增加权值来表示不同的关系。以下是对各题解的总结与评分：

1. **种类并查集**：通过将并查集扩展为三倍大小，分别表示同类、捕食、被捕食关系。这种方法直观且易于理解，适合初学者。
2. **带权并查集**：通过权值来表示动物之间的关系，利用模运算来维护关系的传递性。这种方法较为抽象，但代码简洁且高效。
3. **其他优化**：部分题解通过路径压缩、按秩合并等优化手段，进一步提升了并查集的效率。

### 所选高星题解

#### 1. **Sooke的题解**（★★★★★）
- **关键亮点**：详细解释了种类并查集的思想，并通过图片和示例帮助理解。代码清晰，注释详细，适合初学者。
- **核心代码**：
  ```cpp
  void unity(int x, int y) {
      fa[find(x)] = find(y);
      fa[find(x + n)] = find(y + n);
      fa[find(x + 2 * n)] = find(y + 2 * n);
  }
  ```
  **实现思想**：通过三倍大小的并查集，分别维护同类、捕食、被捕食关系，合并时同时更新三种关系。

#### 2. **天泽龟的题解**（★★★★☆）
- **关键亮点**：引入了带权并查集，通过权值的模运算来表示动物之间的关系，代码简洁且高效。
- **核心代码**：
  ```cpp
  int find(int x) {
      if (fa[x] == x) return x;
      int t = fa[x];
      fa[x] = find(fa[x]);
      rank[x] = (rank[x] + rank[t]) % 3;
      return fa[x];
  }
  ```
  **实现思想**：通过权值的模运算来维护动物之间的关系，路径压缩时同时更新权值。

#### 3. **檀黎斗·神的题解**（★★★★☆）
- **关键亮点**：代码简洁，思路清晰，通过三倍并查集分别表示同类、猎物、天敌关系，合并时逻辑清晰。
- **核心代码**：
  ```cpp
  void unity(int x, int y) {
      fa[find(x)] = find(y);
      fa[find(x + n)] = find(y + n);
      fa[find(x + 2 * n)] = find(y + 2 * n);
  }
  ```
  **实现思想**：通过三倍大小的并查集，分别维护同类、猎物、天敌关系，合并时同时更新三种关系。

### 最优关键思路与技巧

1. **种类并查集**：通过扩展并查集的规模，将不同关系分别存储，合并时同时更新所有相关关系。
2. **带权并查集**：通过权值的模运算来表示动物之间的关系，路径压缩时同时更新权值，代码简洁且高效。
3. **路径压缩与按秩合并**：优化并查集的查找与合并操作，提升效率。

### 可拓展之处

1. **多关系维护**：种类并查集的思想可以拓展到更多复杂关系的维护，如多重依赖关系。
2. **带权并查集**：适用于需要维护多种权值的场景，如带权图的最短路径问题。

### 推荐题目

1. **P1525 关押罪犯**：考察并查集在维护对立关系中的应用。
2. **P1892 团伙**：利用并查集维护朋友与敌人的关系。
3. **P1196 银河英雄传说**：带权并查集的经典应用，维护舰队的距离关系。

### 个人心得摘录

- **Sooke**：“种类并查集能维护连通性、传递性，通俗地说，`亲戚的亲戚是亲戚`。” —— 强调了种类并查集的直观性与易用性。
- **天泽龟**：“带权并查集求的并非具体种类，而是关系！” —— 强调了带权并查集的抽象性与灵活性。

### 总结

种类并查集与带权并查集是解决本题的两种主要思路，前者直观易用，后者代码简洁高效。路径压缩与按秩合并是优化并查集的关键技巧。掌握这些思路与技巧，可以轻松应对类似的复杂关系维护问题。

---
处理用时：39.52秒
# 题目信息

# yyy2015c01 的 U 盘

## 题目背景

在 2020 年的某一天，我们的 yyy2015c01 买了个高端 U 盘。


## 题目描述

你找 yyy2015c01 借到了这个高端的 U 盘，拷贝一些重要资料，但是你发现这个 U 盘有一些问题：

1. 这个 U 盘的传输接口很小，只能传输大小不超过 $L$ 的文件。
2. 这个 U 盘容量很小，一共只能装不超过 $S$ 的文件。

但是你要备份的资料却有很多，你只能备份其中的一部分。

为了选择要备份哪些文件，你给所有文件设置了一个价值 $V_i$，你希望备份的文件总价值不小于 $p$。

但是很快你发现这是不可能的，因为 yyy2015c01 的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）。

注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,

你放在 U 盘中文件的总大小不能超过 U 盘容量。

现在问题来了：你想知道，在满足 U 盘中文件价值之和**不小于** $p$ 时，最小需要多大的接口。

## 说明/提示

$1 \le n, W_i, S \le 10^3$，$1 \leq V_i \leq 10^6$，$1 \leq p \leq 10^9$。

数据较小，请勿乱搞。

样例解释 $1$：买一个大小为 $2$ 接口，把物品 $1$ 、$2$ 放进$\text{U}$盘。

样例解释 $2$：买一个大小为 $500$ 的接口。

样例解释 $3$：本来可以买大小为 $2$ 的接口，可是 U 盘容量放不下足够的文件。

如果数据出现疏漏，请联系出题人 [a710128](https://www.luogu.com.cn/user/2573)

向本题主人公 yyy2015c01 同学致敬！

## 样例 #1

### 输入

```
3 3 5
2 2
1 2
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 505
1 2
500 1```

### 输出

```
500```

## 样例 #3

### 输入

```
3 3 2
2 2
1 2
3 2```

### 输出

```
No Solution!```

## 样例 #4

### 输入

```
4 5 6
5 1
5 2
5 3
1 1```

### 输出

```
No Solution!```

# AI分析结果

### 综合分析与结论

本题的核心问题是在满足U盘容量限制和文件价值要求的条件下，找到最小的文件传输接口大小。题解中主要采用了两种思路：**01背包+排序**和**二分答案+01背包**。其中，二分答案的思路更为通用和高效，尤其是在处理“最大值最小化”问题时，二分法能够显著减少计算量。而01背包+排序的方法虽然简单，但在某些情况下可能无法处理更复杂的数据范围。

### 所选高星题解

#### 1. **MuelsyseU (5星)**
- **关键亮点**：详细解释了二分答案和01背包的结合，提供了清晰的二分模板和验证函数。代码结构清晰，注释详尽，适合初学者理解。
- **个人心得**：作者强调了二分答案的单调性和验证函数的重要性，并提供了二分答案的模板，帮助读者更好地理解二分法的应用。
- **核心代码**：
  ```cpp
  int dp(int k) {
      for(int j=1;j<=s;j++) f[j]=0;
      for(int i=1;i<=n;i++){
          if(k!=-1&&a[i]>k) continue;
          for(int j=s;j>=a[i];j--){
              f[j]=max(f[j],f[j-a[i]]+b[i]);
          }
      }
      return f[s];
  }
  ```

#### 2. **amstar (4星)**
- **关键亮点**：简洁明了地实现了二分答案+01背包的思路，代码简洁且易于理解，适合快速实现。
- **核心代码**：
  ```cpp
  bool dp(int x) {
      memset(f,0,sizeof(f));
      for (int i=1; i<=n; ++i) {
          if (v[i]>x) continue; 
          for (int j=s; j>=v[i]; --j)
              f[j] = max(f[j],f[j-v[i]]+w[i]);
      }
      return f[s]>=m;
  }
  ```

#### 3. **Y_B_Y (4星)**
- **关键亮点**：通过二分列举接口大小，并结合01背包进行验证，思路清晰，代码简洁。
- **核心代码**：
  ```cpp
  bool check(int a) {
      memset(f,0,sizeof(f));
      for(int i=1;i<=n;i++) {
          if(w[i]<=a)
          for(int j=s;j>=w[i];j--) {
              f[j]=max(f[j],f[j-w[i]]+v[i]);
          }
      }
      return f[s]>=p;
  }
  ```

### 最优关键思路与技巧

1. **二分答案**：在处理“最大值最小化”或“最小值最大化”问题时，二分法能够显著减少计算量。通过不断缩小搜索范围，快速找到满足条件的最小或最大值。
2. **01背包优化**：在验证二分答案时，使用01背包来计算在给定接口大小下的最大价值，确保满足价值要求。
3. **单调性验证**：二分答案的前提是问题的解具有单调性，即如果某个值满足条件，那么比它大（或小）的值也一定满足条件。

### 可拓展之处

- **类似问题**：类似的问题包括“木材加工”、“跳石头”等，都是典型的二分答案问题。
- **算法套路**：二分答案+验证函数的套路可以广泛应用于各种最优化问题，尤其是当直接求解困难时，可以通过二分法快速找到最优解。

### 推荐题目

1. **P2440 木材加工**：典型的二分答案问题，要求找到最大的木材切割长度。
2. **P2678 跳石头**：通过二分法找到最小的跳跃距离，使得移除的石头数量不超过限制。
3. **P1182 数列分段 Section II**：通过二分法找到最小的分段和，使得分段数不超过限制。

### 个人心得总结

- **调试经历**：多位作者提到在二分答案时，边界条件的处理非常重要，尤其是在更新上下界时，容易丢失最优解。
- **踩坑教训**：在01背包的实现中，内层循环必须倒序遍历，否则会导致物品被重复使用。
- **顿悟感想**：二分答案的核心在于验证函数的正确性和单调性的保证，理解这一点后，二分法的应用会更加得心应手。

---
处理用时：27.90秒
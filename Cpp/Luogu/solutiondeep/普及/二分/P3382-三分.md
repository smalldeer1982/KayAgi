# 题目信息

# 三分

## 题目背景

本题可能存在严重精度问题，部分数据下难以通过。本题数据较水，仅供参考。

## 题目描述

如题，给出一个 $N$ 次函数，保证在范围 $[l, r]$ 内存在一点 $x$，使得 $[l, x]$ 上单调增，$[x, r]$ 上单调减。试求出 $x$ 的值。

## 说明/提示

对于 $100\%$ 的数据，$6 \le N \le 13$，函数系数均在 $[-100,100]$ 内且至多 $15$ 位小数，$|l|,|r|\leq 10$ 且至多 $15$ 位小数。$l\leq r$。

**【样例解释】**

 ![](https://cdn.luogu.com.cn/upload/pic/2297.png) 

如图所示，红色段即为该函数 $f(x) = x^3 - 3 x^2 - 3x + 1$ 在区间 $[-0.9981, 0.5]$ 上的图像。

当 $x = -0.41421$ 时图像位于最高点，故此时函数在 $[l, x]$ 上单调增，$[x, r]$ 上单调减，故 $x = -0.41421$，输出 $-0.41421$。


## 样例 #1

### 输入

```
3 -0.9981 0.5
1 -3 -3 1```

### 输出

```
-0.41421```

# AI分析结果

### 综合分析与结论

本题要求在一个单峰函数的区间内找到其极值点，常见的解法包括三分法、二分法结合导数、粒子群优化、模拟退火等。三分法是最直接的思路，适用于单峰函数的极值求解；二分法结合导数则通过求导数的零点来找到极值点，数学上更为严谨；粒子群优化和模拟退火则是基于随机化的优化算法，适用于更复杂的函数或全局优化问题。

大多数题解都采用了三分法或二分法结合导数，思路清晰且代码实现简洁。部分题解引入了秦九韶算法来优化多项式求值，提升了计算效率。模拟退火和粒子群优化虽然新颖，但在这道题中显得过于复杂，且效率不如三分法或二分法。

### 精选题解

#### 1. **作者：BlueArc (★★★★★)**
   - **关键亮点**：使用了三分法，并结合了秦九韶算法优化多项式求值，代码简洁且效率高。
   - **代码核心思想**：通过比较区间内的两个三等分点的函数值，逐步缩小区间，最终找到极值点。
   - **核心代码**：
     ```cpp
     double F(double x) {
         double sum = 0;
         for(int i = n; i >= 0; i--) sum = sum * x + a[i];
         return sum;
     }
     while(fabs(L - R) >= eps) {
         double mid = (L + R) / 2;
         if(F(mid + eps) > F(mid - eps)) L = mid;
         else R = mid;
     }
     ```
   - **个人心得**：强调了三分法的适用性，并指出秦九韶算法在多项式求值中的优势。

#### 2. **作者：NaCly_Fish (★★★★☆)**
   - **关键亮点**：通过导数的本质来求解极值点，避免了复杂的求导公式，思路新颖且易于理解。
   - **代码核心思想**：通过导数的定义，使用极限近似计算导数值，并结合二分法找到导数的零点。
   - **核心代码**：
     ```cpp
     double check(double x) {
         double dx = eps;
         double dy = f(x + dx) - f(x);
         return dy / dx;
     }
     while(r - l > eps) {
         mid = (l + r) / 2;
         if(check(mid) > 0) l = mid;
         else r = mid;
     }
     ```
   - **个人心得**：解释了导数的本质，并提供了直观的导数计算方法，适合没有高数背景的读者。

#### 3. **作者：Seauy (★★★★☆)**
   - **关键亮点**：直接使用三分法，代码简洁且易于理解，适合初学者。
   - **代码核心思想**：通过比较区间内的两个三等分点的函数值，逐步缩小区间，最终找到极值点。
   - **核心代码**：
     ```cpp
     double Find(double L, double R) {
         double Lmid, Rmid;
         while(L + dif <= R) {
             Lmid = L + (R - L) / 3.0;
             Rmid = R - (R - L) / 3.0;
             if(check(Lmid) > check(Rmid)) R = Rmid;
             else L = Lmid;
         }
         return (Lmid + Rmid) / 2.0;
     }
     ```
   - **个人心得**：强调了三分法的直观性，并提供了详细的代码实现。

### 最优关键思路与技巧

1. **三分法**：适用于单峰函数的极值求解，通过比较区间内的两个三等分点的函数值，逐步缩小区间，最终找到极值点。
2. **秦九韶算法**：用于优化多项式求值，将时间复杂度从O(n²)降低到O(n)，提升计算效率。
3. **导数法**：通过求导数的零点来找到极值点，数学上更为严谨，适合有高数背景的读者。

### 拓展思路

- **类似算法**：二分法、黄金分割法、模拟退火、粒子群优化等都可以用于求解极值问题，但三分法在单峰函数中最为高效。
- **类似题目**：
  1. [P3382 【模板】三分法](https://www.luogu.com.cn/problem/P3382)
  2. [P1883 函数](https://www.luogu.com.cn/problem/P1883)
  3. [P3195 [HNOI2008]玩具装箱](https://www.luogu.com.cn/problem/P3195)

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现精度问题，建议使用更小的eps值来确保精度。
- **踩坑教训**：在使用二分法时，需要注意导数的符号变化，避免误判极值点的位置。
- **顿悟感想**：三分法在单峰函数中的高效性让人印象深刻，秦九韶算法的优化也让人眼前一亮。

---
处理用时：34.98秒
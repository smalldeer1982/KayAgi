# 题目信息

# [USACO19FEB] Dishwashing G

## 题目背景

Bessie 和 Elsie 正在帮助 Farmer John 洗碗，这是一个比人们想象的更复杂的过程。

## 题目描述

两头奶牛决定 Bessie 负责涂肥皂，Elsie 负责冲洗。

刚开始的时候，$N$ 个脏盘子（保证是从 $1$ 到 $N$ 的一个排列）堆在 Bessie 那里，而 Elsie 这边的堆是空的。而在她们俩之间，则有一张专门放涂过肥皂的盘子的桌子。

每个冲洗步骤需要执行以下两个操作之一：

- Bessie 从脏盘子堆顶取出一个盘子，涂上肥皂，然后放在桌子上。将这个盘子放在桌子上时，Bessie 只能放在现有的非空盘堆的顶端，或是在最右边新增一个盘堆。
- Elsie 从桌子最左边的盘堆的顶端拿起盘子，将它冲洗后放在干净的盘堆顶端。

她们希望干净的盘堆能按编号排序，编号最小的在底端，编号最大的在顶端。然而她们发现有的时候这并不可能做到。现在给定脏盘子的堆叠顺序，请你求出一个最大前缀，使得该前缀的所有盘子洗干净后，能按上面的要求堆叠。

## 样例 #1

### 输入

```
5
4
5
2
3
1```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

本题的核心在于如何通过栈的模拟来维护盘子的顺序，确保最终冲洗的盘子能够按编号从小到大排列。大多数题解都采用了贪心策略，结合二分查找来优化插入过程，确保每个栈的内部和栈之间都满足单调性。部分题解还引入了二分答案的思路，进一步提升了算法的效率。

### 所选题解

#### 1. 作者：45dino (赞：8)  
**星级：★★★★★**  
**关键亮点：**  
- 思路清晰，代码简洁，直接通过贪心策略和二分查找维护栈的单调性。
- 通过 `base` 数组记录每个盘子的归属栈，优化了查找过程。
- 代码实现高效，时间复杂度为 $O(n \log n)$。

**核心代码：**
```cpp
for(int i=1;i<=n;i++) {
    int x;
    cin>>x;
    if(x<placed) {
        cout<<i-1;
        return 0;
    }
    for(int j=x;j>0&&!base[j];j--)
        base[j]=x;
    while(!item[base[x]].empty()&&item[base[x]].back()<x) {
        placed=item[base[x]].back();
        item[base[x]].pop_back();
    }
    item[base[x]].push_back(x);
}
```
**核心思想：**  
通过 `base` 数组记录每个盘子的归属栈，确保栈的内部和栈之间都满足单调性。若当前盘子无法放入任何栈，则输出当前最大前缀。

#### 2. 作者：zzbzwjx (赞：4)  
**星级：★★★★**  
**关键亮点：**  
- 代码简洁，逻辑清晰，直接通过贪心策略和二分查找维护栈的单调性。
- 通过 `b` 数组记录每个盘子的归属栈，优化了查找过程。
- 代码实现高效，时间复杂度为 $O(n \log n)$。

**核心代码：**
```cpp
for(int i=1;i<=n;++i){
    cin>>x;
    if(x<p){cout<<i-1;return 0;}
    for(int j=x;j>0&&!b[j];--j)b[j]=x;
    while(!a[b[x]].empty()&&a[b[x]].back()<x){
        p=a[b[x]].back();a[b[x]].pop_back();
    }
    a[b[x]].push_back(x);
}
```
**核心思想：**  
通过 `b` 数组记录每个盘子的归属栈，确保栈的内部和栈之间都满足单调性。若当前盘子无法放入任何栈，则输出当前最大前缀。

#### 3. 作者：DengDuck (赞：4)  
**星级：★★★★**  
**关键亮点：**  
- 引入了二分答案的思路，进一步提升了算法的效率。
- 通过 `pd` 函数判断当前前缀是否满足条件，确保栈的内部和栈之间都满足单调性。
- 代码实现较为复杂，但思路清晰，时间复杂度为 $O(n \log^2 n)$。

**核心代码：**
```cpp
bool pd(LL x) {
    for(int i=1;i<=n;i++)b[i]=a[i],v[i].clear();
    sort(b+1,b+x+1);
    while(!q.empty())q.pop();
    for(int i=1;i<=x;i++)q.push(b[i]);
    t=1,tot=0,cnt=0;
    for(int i=1;i<=x;i++) {
        LL l=t,r=tot,ans=-1;
        while(l<=r) {
            LL mid=(l+r)/2;
            if(v[mid].front()>a[i]) {
                r=mid-1;
                ans=mid;
            }
            else l=mid+1;
        }
        if(ans==-1)ans=++tot;
        v[ans].push_front(a[i]);
        while(!q.empty()&&t<=tot&&q.front()==v[t].front()) {
            v[t].pop_front();
            q.pop();
            if(v[t].empty())t++;
        }
    }
    return q.empty();
}
```
**核心思想：**  
通过二分答案的思路，判断当前前缀是否满足条件，确保栈的内部和栈之间都满足单调性。

### 最优关键思路或技巧

1. **贪心策略与单调性维护：** 通过贪心策略确保每个栈的内部和栈之间都满足单调性，从而保证最终冲洗的盘子能够按编号从小到大排列。
2. **二分查找优化：** 通过二分查找优化插入过程，确保每个盘子能够快速找到合适的栈。
3. **二分答案：** 通过二分答案的思路，进一步提升算法的效率，确保在较大数据规模下仍能高效运行。

### 可拓展之处

- **类似题目：** 类似的问题可以扩展到其他需要维护单调性的场景，如区间调度、任务分配等。
- **算法套路：** 贪心策略结合二分查找的套路可以应用于其他需要快速查找和插入的场景，如动态规划中的状态转移优化。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3382 【模板】线段树 1](https://www.luogu.com.cn/problem/P3382)

### 个人心得摘录

- **调试经历：** 部分题解中提到在调试过程中发现二分查找的边界条件容易出错，建议在编写代码时特别注意边界条件的处理。
- **踩坑教训：** 部分题解中提到在实现过程中容易忽略栈的内部单调性，导致最终结果错误，建议在编写代码时仔细检查每个栈的内部是否满足单调性。
- **顿悟感想：** 部分题解中提到通过二分答案的思路，进一步提升了算法的效率，建议在类似问题中尝试引入二分答案的思路。

---
处理用时：35.31秒
# 题目信息

# [NOI Online #2 入门组] 未了

## 题目描述

由于触犯天神，Sisyphus 将要接受惩罚。

宙斯命 Sisyphus 推一块巨石上长度为 $L$ 的山坡。Sisyphus 匀速向上推的速度为每年 $v$ 的长度（由于是匀速，故经过 $\frac{1}{2}$ 年将能向上推 $\frac{v}{2}$ 的长度）。然而，宙斯并不希望 Sisyphus 太快到达山顶。宙斯可以施展 $n$ 个魔法，若宙斯施展第 $i$ 个魔法 $(1\leq i \leq n)$，则当 Sisyphus 第一次到达位置  $a_i$ 时，他将会同巨石一起滚落下山底，并从头推起。（滚落的时间忽略不计，即可看作第一次到达位置 $a_i$ 后 Sisyphus 立即从山底重新出发）

例如宙斯施用了 $a_i=3$ 和 $a_i=5$ 的两个魔法。Sisyphus 的速度 $v=1$ ，山坡的长度 $L = 6$，则他推石上山过程如下：

- 用 $3$ 年走到位置 $3$。

- 受 $a_i=3$ 的魔法影响，回到了山底出发。

- 再用 $3$ 年走到位置 $3$，然而因为是第二次到达，$a_i=3$ 的魔法不起作用。

- 用 $2$ 年走到位置 $5$。

- 受 $a_i=5$ 的魔法影响，回到了山底出发。

- 用 $6$ 年从山底走到了山顶。花费的总时间为 $14$ 年。

现在，宙斯有 $q$ 个询问。对于第 $i$ 个询问 $t_i$，宙斯想知道，他最少需要施展多少个魔法才能使 Sisyphus 到达山顶所用的年数大于 $t_i$

## 说明/提示

1. 不使用任何魔法，Sisyphus 需要 $2$ 年走上山顶。
2. 使用魔法 $2$ ，Sisyphus 需要 $\frac{11}{3}$ 年走上山顶。（用时 $\frac{5}{3}$ 年走到魔法 $2$ 的位置并滚落下山，再用时 $\frac{6}{3}=2$ 年走到山顶）
3. 使用魔法 $1,2$ ，Sisyphus 需要 $\frac{14}{3}$ 年走上山顶。
4. 宙斯不能使 Sisyphus 用大于 $5$ 年的时间走上山顶。

对于测试点 $1\sim 8:n=1$。

对于测试点 $9\sim 12:n=2$。

对于测试点 $13\sim 17:n,q\le 1000$。

对于所有测试点：$1 \leq n,q \leq 2 \times 10^5$，$1\leq v\leq L\leq 10^{9}$，$1\leq a_i < L$，$1 \leq t_i\leq 10^9$。

数据保证 $a_i$ 两两不同。

## 样例 #1

### 输入

```
3 6 3
3 5 1
4
1
3
4
5
```

### 输出

```
0
1
2
-1
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何通过贪心策略和二分查找来优化查询效率。大多数题解都采用了将魔法按生效距离从大到小排序，并通过前缀和计算使用不同数量魔法时的总时间，最后利用二分查找来确定最少需要的魔法数量。这种思路在时间复杂度和代码实现上都非常高效，能够很好地处理大规模数据。

### 所选高星题解

#### 1. 作者：chen_zhe (5星)
- **关键亮点**：思路清晰，代码简洁，使用了`upper_bound`进行二分查找，时间复杂度为$O(q \log n)$，非常适合大规模数据。
- **代码核心**：
  ```cpp
  sort(a+1,a+n+1,cmp);
  for (int i=1;i<=n;i++) s[i]=s[i-1]+a[i];
  int q=read();
  while (q--) {
      long long t=read();
      t=t*v-L;
      if (t<0) puts("0");
      else if (s[n]>t) cout << upper_bound(s+1,s+n+1,t)-s << endl;
      else puts("-1");
  }
  ```
- **个人心得**：作者强调了贪心策略的正确性，并指出使用`upper_bound`可以简化二分查找的实现。

#### 2. 作者：翼德天尊 (4.5星)
- **关键亮点**：详细解释了贪心和二分的结合使用，代码注释清晰，适合初学者理解。
- **代码核心**：
  ```cpp
  sort(a+1,a+1+n,cmp);
  b[0]=l/v;
  for (int i=1;i<=n;i++) b[i]=double(a[i])/v+b[i-1];
  while (q--) {
      cin>>t;
      if (b[n]<=t) printf("-1\n");
      else {
          int l=0,r=n,ans=0;
          while (l<=r) {
              int mid=(l+r)>>1;
              if (b[mid]>t) ans=mid, r=mid-1;
              else l=mid+1;
          }
          printf("%d\n",ans);
      }
  }
  ```
- **个人心得**：作者通过二分查找优化了查询效率，并详细解释了每一步的逻辑。

#### 3. 作者：云浅知处 (4星)
- **关键亮点**：将魔法的作用转化为时间的浪费，思路新颖，代码实现简洁。
- **代码核心**：
  ```cpp
  sort(a+1,a+n+1,cmp);
  for(i=1;i<=n;i++) s[i]=s[i-1]+a[i];
  while(q--) {
      cin>>t;
      if(y>=t) cout<<0<<endl;
      else if(s[n]+y<=t) cout<<-1<<endl;
      else cout<<upper_bound(s+1,s+n+1,t-y)-s<<endl;
  }
  ```
- **个人心得**：作者通过将魔法的作用转化为时间的浪费，简化了问题的处理。

### 最优关键思路与技巧
1. **贪心策略**：将魔法按生效距离从大到小排序，优先使用生效距离大的魔法，以最大化时间的浪费。
2. **前缀和与二分查找**：通过前缀和计算使用不同数量魔法时的总时间，利用二分查找快速确定最少需要的魔法数量。
3. **时间复杂度优化**：通过排序和二分查找，将查询时间复杂度从$O(qn)$优化到$O(q \log n)$，适合处理大规模数据。

### 可拓展之处
- **类似问题**：可以应用于需要最大化或最小化某种资源的场景，如任务调度、资源分配等。
- **算法套路**：贪心+二分查找的组合在解决类似问题时非常有效，尤其是在需要快速查询最优解的情况下。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得总结
- **调试经历**：多位作者提到在处理大规模数据时，通过排序和二分查找优化了查询效率，避免了超时问题。
- **踩坑教训**：部分作者提到在处理浮点数精度时需要注意，建议通过整数运算来避免精度误差。
- **顿悟感想**：通过将魔法的作用转化为时间的浪费，简化了问题的处理，使得代码实现更加简洁高效。

---
处理用时：32.36秒
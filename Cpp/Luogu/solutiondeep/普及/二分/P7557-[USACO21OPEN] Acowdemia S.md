# 题目信息

# [USACO21OPEN] Acowdemia S

## 题目描述

由于对计算机科学的热爱，以及有朝一日成为 「Bessie 博士」的诱惑，奶牛 Bessie 开始攻读计算机科学博士学位。经过一段时间的学术研究，她已经发表了 $N$ 篇论文（$1 \leq N \leq 10^5$），并且她的第 $i$ 篇论文得到了来自其他研究文献的 $c_i$ 次引用（$0 \leq c_i \leq 10^5$）。

Bessie 听说学术成就可以用 $h$ 指数来衡量。$h$ 指数等于使得研究员有至少 $h$ 篇引用次数不少于 $h$ 的论文的最大整数 $h$。例如，如果一名研究员有 $4$ 篇论文，引用次数分别为 $(1,100,2,3)$，则 $h$ 指数为 $2$，然而若引用次数为 $(1,100,3,3)$ 则 $h$ 指数将会是 $3$。

为了提升她的 $h$ 指数，Bessie 计划写至多 $K$ 篇综述（$0 \leq K \leq 10^5$），并在每篇综述中引用许多她曾经写过的论文。然而，由于页数限制，她至多可以在一篇综述中引用 $L$ 篇论文（$0 \leq L \leq 10^5$）。当然，一篇综述中她只能引用一篇论文至多一次（但是一篇论文可以在多篇综述中被引用）。

请帮助 Bessie 求出在写完这些综述后她可以达到的最大 $h$ 指数。Bessie 不可以在一篇综述中引用她写的其他综述。

注意 Bessie 的导师可能会告知她纯粹为了提升 $h$ 指数而写综述存在违反学术道德的嫌疑；我们不建议其他学者模仿 Bessie 的行为。

## 说明/提示

#### 样例说明

在这个样例中，Bessie 可以写至多一篇综述。如果 Bessie 引用她的第一、第三、第四篇论文中的任意一篇，她的 $h$ 指数会变为 $2$。

#### 测试点性质：

- 测试点 $1 \sim 6$ 满足 $N\le 100$。
- 测试点 $7 \sim 16$ 没有额外限制。

#### 说明

供题：Dhruv Rohatgi

## 样例 #1

### 输入

```
4 4 1
1 100 1 1```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心是通过二分答案来求解最大 $h$ 指数，并结合贪心策略进行优化。大多数题解都采用了二分答案的思路，并通过排序和贪心策略来减少计算量。主要的难点在于如何设计 `check` 函数来判断某个 $h$ 是否可行，以及如何高效地计算所需的引用次数。

### 所选高星题解

#### 题解1：作者：fangzirui1 (★★★★★)
**关键亮点**：
- 思路清晰，代码简洁，直接使用二分答案和贪心策略。
- `check` 函数设计合理，通过遍历数组计算所需的引用次数，并判断是否满足条件。
- 代码可读性强，变量命名清晰，逻辑结构明确。

**核心代码**：
```cpp
bool check(int x) {
    long long s = 0;
    for (int i = 1; i <= n; i++) {
        if (a[i] < x) {
            s += x - a[i];
            if (x - a[i] > m) return 0;
        }
        if (s > m * k) return 0;
        if (i == x) return 1;
    }
}
```

#### 题解2：作者：tiger2005 (★★★★☆)
**关键亮点**：
- 使用了 `map` 来记录差距，优化了 `check` 函数的计算过程。
- 通过将问题转化为表格填充的方式，证明了贪心策略的正确性。
- 代码逻辑清晰，但复杂度稍高，适合对时间复杂度要求不高的场景。

**核心代码**：
```cpp
bool check(int m) {
    int x = 0, y = 0;
    for (int i = 1; i <= N; i++)
        if (C[i] >= m) ++x;
        else if (C[i] >= m - K) mp[m - C[i]]++;
    long long cnt = 1ll * K * L;
    for (map<int, int>::iterator it = mp.begin(); it != mp.end(); it++) {
        if (cnt <= 1ll * (it->first) * (it->second)) {
            y += cnt / (it->first);
            break;
        }
        cnt -= 1ll * (it->first) * (it->second);
        y += (it->second);
    }
    mp.clear();
    return x + y >= m;
}
```

#### 题解3：作者：huangboming (★★★★☆)
**关键亮点**：
- 提供了不用二分的解法，通过排序和前缀和来计算最大 $h$ 指数。
- 思路新颖，代码实现简洁，适合对二分不熟悉的读者。
- 代码可读性较好，但复杂度较高，适合小规模数据。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    if (a[i] < i) {
        for (; a[o] < i && o; o--) {}
        if (i * (i - o) - qzh[i] + qzh[o] <= m && i - a[i] <= k) {
            ans = i;
        }
    } else {
        ans = i;
        o = i;
    }
}
```

### 最优关键思路与技巧
1. **二分答案**：通过二分法快速确定最大 $h$ 指数，结合 `check` 函数判断当前 $h$ 是否可行。
2. **贪心策略**：将数组从大到小排序，优先处理引用次数较多的论文，减少计算量。
3. **前缀和优化**：通过前缀和快速计算所需的引用次数，减少时间复杂度。

### 可拓展之处
- **类似问题**：可以拓展到其他需要最大化最小值或最小化最大值的问题，如分配资源、调度任务等。
- **算法套路**：二分答案结合贪心策略是解决许多优化问题的常见套路，适用于多种场景。

### 推荐题目
1. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)
2. [P1316 丢瓶盖](https://www.luogu.com.cn/problem/P1316)
3. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)

### 个人心得总结
- **调试经历**：在实现 `check` 函数时，注意边界条件的处理，避免数组越界或逻辑错误。
- **踩坑教训**：排序时要注意是从大到小还是从小到大，否则会影响后续的计算。
- **顿悟感想**：二分答案结合贪心策略是解决这类问题的利器，理解其原理后可以举一反三。

---
处理用时：34.42秒
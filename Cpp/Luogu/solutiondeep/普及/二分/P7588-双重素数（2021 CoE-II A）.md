# 题目信息

# 双重素数（2021 CoE-II A）

## 题目描述

素数（质数）是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。定义**双重素数**为这样的素数：它的各位数字之和也是一个素数。给定一个闭区间，试确定在该区间内双重素数的个数。

## 说明/提示

**样例说明**

从 $1$ 到 $15$ 共有 $6$ 个素数：$2$，$3$，$5$，$7$，$11$，$13$。前五个素数各自的数字之和也是素数，因此都是双重素数。素数 $13$ 的各位数字之和为 $4$，不是素数，故 $13$ 不是双重素数。

------------


**数据范围**

- Subtask $1$ ：$1 \le L \le R \le 10^2$，$10$ 分。
- Subtask $2$ ：$1 \le L \le R \le 10^4$，$20$ 分。
- Subtask $3$ ：$1 \le L \le R \le 10^6$，$60$ 分。
- Subtask $4$ ：$1 \le L \le R \le 10^8$，$10$ 分。

对于 $100\%$ 的数据，$1 \le T \le 100$。


------------

**提示（数据已经加强）**

最后一个子任务要求你的程序必须具有较高的空间使用效率和时间效率，否则容易超出内存限制或时间限制。

## 样例 #1

### 输入

```
4
3 3
4 4
1 5
1 15```

### 输出

```
1
0
3
5```

# AI分析结果

### 综合分析与结论

本题的核心在于高效筛选素数，并进一步筛选出“双重素数”。由于数据范围较大（$1 \le L \le R \le 10^8$），普通的筛法无法满足时间和空间的要求。因此，题解中普遍采用了**欧拉筛**（线性筛）来高效筛选素数，并结合**bitset**或**位标记**来优化空间使用。此外，为了快速查询区间内的双重素数数量，题解中普遍使用了**二分查找**（`lower_bound` 和 `upper_bound`）来加速查询。

### 最优关键思路与技巧

1. **欧拉筛（线性筛）**：用于高效筛选素数，时间复杂度为 $O(n)$，适合大范围数据。
2. **bitset 或位标记**：用于优化空间，bitset 的空间复杂度为 $O(n/8)$，位标记则通过位运算进一步压缩空间。
3. **二分查找**：用于快速查询区间内的双重素数数量，时间复杂度为 $O(\log n)$。
4. **预处理与记忆化**：通过预处理双重素数，避免重复计算，提升查询效率。

### 推荐题解

#### 1. 作者：王熙文 (5星)
- **关键亮点**：使用了欧拉筛结合 bitset 优化空间，并通过二分查找快速查询区间内的双重素数数量。代码结构清晰，优化到位。
- **个人心得**：作者提到使用 bitset 优化空间，并详细解释了 `lower_bound` 和 `upper_bound` 的使用方法，帮助读者理解二分查找的应用。
- **核心代码**：
  ```cpp
  void work() {
      const int n = 100000000;
      b[1] = 1;
      for (int i = 2; i <= n; ++i) {
          if (!b[i]) dp[++k] = i;
          for (int j = 1; j <= k && i * dp[j] <= n; ++j) {
              b[dp[j] * i] = 1;
              if (!(i % dp[j])) break;
          }
      }
      int k1 = k;
      k = 0;
      for (int i = 1; i <= k1; ++i) {
          int sum = 0, t = dp[i];
          while (t) sum += t % 10, t /= 10;
          if (sushu(sum)) ans[++k] = dp[i];
      }
  }
  ```

#### 2. 作者：_lfxxx_ (4.5星)
- **关键亮点**：详细解释了欧拉筛的原理，并结合 bitset 优化空间。通过预处理双重素数，使用二分查找快速查询区间内的双重素数数量。
- **个人心得**：作者提到使用 bitset 优化空间，并详细解释了欧拉筛的原理，帮助读者理解算法的核心思想。
- **核心代码**：
  ```cpp
  void Getprime() {
      for (int i = 2; i <= n; i++) {
          if (!numlist[i]) prime[++cnt] = i;
          for (int j = 1; i * prime[j] <= n; j++) {
              numlist[i * prime[j]] = 1;
              if (!(i % prime[j])) break;
          }
      }
  }
  ```

#### 3. 作者：metaphysis (4星)
- **关键亮点**：使用了位标记优化空间，并结合欧拉筛筛选素数。通过二分查找快速查询区间内的双重素数数量。
- **个人心得**：作者提到使用位标记优化空间，并详细解释了二分查找的应用，帮助读者理解如何高效查询区间内的双重素数数量。
- **核心代码**：
  ```cpp
  void prime(int tt) {
      for (int i = 2; i <= tt; i++) {
          if (!vis[i]) f[++cnt] = i;
          for (int j = 1; j <= cnt; j++) {
              if (f[j] * i > tt) break;
              vis[f[j] * i] = 1;
              if (i % f[j] == 0) break;
          }
      }
  }
  ```

### 可拓展之处

1. **类似算法套路**：欧拉筛和 bitset 的组合可以应用于其他需要高效筛选素数的问题，如区间内的素数个数、素数的特殊性质等。
2. **二分查找的应用**：二分查找不仅适用于素数查询，还可以用于其他有序数组的区间查询问题。

### 推荐题目

1. **P3383 【模板】线性筛素数**：练习欧拉筛的基本应用。
2. **P3912 素数个数**：练习大范围内素数的筛选与计数。
3. **P1217 [USACO1.5]回文质数 Prime Palindromes**：结合素数筛选与回文数的判断，提升综合能力。

### 个人心得总结

- **调试经历**：多位作者提到在本地调试时遇到时间超限的问题，但在洛谷评测机上表现良好，说明优化后的代码在实际评测中表现优异。
- **踩坑教训**：部分作者提到直接使用 bool 数组会导致空间不足，因此推荐使用 bitset 或位标记来优化空间。
- **顿悟感想**：通过预处理和二分查找，可以大幅提升查询效率，避免重复计算。

---
处理用时：34.21秒
# 题目信息

# [WFOI - 01] 硬币（coin）

## 题目描述

你面前有一排 $n$ **堆**硬币排成一线，**同一堆硬币**的面值相同，记第 $i$ 堆硬币的面值为 $a_i$。而**每堆硬币**的数量都相同，记为 $x$。

现在你知道每第 $i$ 堆硬币的面值 $a_i$，你需要确定一个**正整数** $x$，使得**每堆硬币的总金额的**方差最接近于一个**正整数** $k$。

两数 **“最接近”** 的定义：两数之差的绝对值最小。

方差定义：方差 $s ^ 2 = \cfrac{(a_1 - \bar x)^2 + (a_2 - \bar x) ^ 2 + \cdots + (a_n - \bar x) ^ 2}{n}$，其中 $\bar x$ 代表 $x$ 的平均值。

## 说明/提示


**【样例 $\#1$ 解释】**

  当 $x=3$ 时，第 $i$ 个堆的硬币金额为 $3\times a_i$，这些硬币堆的金额分别为 $21,6,12,18,9,21,30$，可以计算得这些硬币金额的方差约为 $58.78$，可以证明当 $x=3$ 时方差最接近 $47$。

**【样例 $\#2$ 解释】**

  可以发现，无论 $x$ 的取值，方差都会为 $0$，所以输出 `No answer!`。







**【数据规模】**

**本题采用 Subtask 捆绑测试。**

Subtask 编号 | $n,\forall a_i\le$ | $k\le$ | $\footnotesize\texttt{测试点数目}$ |
:-: | :-: | :-: | :-:
**Subtask #0 $(20\texttt{pts})$** | $10^3$ | $10^9$| $6$ |
**Subtask #1 $(25\texttt{pts})$** | $10^5$ | $10^{12}$| $6$ |
**Subtask #2 $(25\texttt{pts})$** | $10^5$ | $10^{18}$| $6$ |
**Subtask #3 $(30\texttt{pts})$** | $7\times10^6$ | $3\times 10^{18}$| $6$ |

对于 $100\%$ 的数据，$1\le n,\forall a_i\le7\times10^6$，$1\le k\le3\times10^{18}$。记原来 $a$ 数组的方差为 $p$，则数据满足 $p=0$ 或 $p\in[0.25,\ 2^{63}-1]$ 。





**【提示】**

  本题读入量较大，请使用合适的读入方式。此处推荐[快速读入模板](https://www.luogu.com.cn/paste/bcfvgxr7)，对于 $\texttt{C/C++}$ 语言，你也可以使用 `scanf` 语句完成读入。
  
  为避免卡精度，建议 `C/C++` 选手使用 $\texttt{double}$ 类型，并不建议使用 `eps`。

## 样例 #1

### 输入

```
7 47
7 2 4 6 3 7 10```

### 输出

```
3```

## 样例 #2

### 输入

```
4 4
4 4 4 4```

### 输出

```
No answer!```

# AI分析结果

### 综合分析与结论

本题的核心在于通过数学推导，找到使得方差最接近给定值 \( k \) 的正整数 \( x \)。多数题解都基于方差的性质，推导出方差与 \( x \) 的关系为 \( s'^2 = x^2 \cdot s^2 \)，并通过开方和取整操作找到最优的 \( x \)。以下是各题解的要点总结与评分：

1. **数学推导**：几乎所有题解都正确推导了方差与 \( x \) 的关系，即 \( s'^2 = x^2 \cdot s^2 \)，并通过开方和取整操作找到最优的 \( x \)。
2. **精度处理**：部分题解特别强调了精度问题，使用 `long double` 或 `__int128` 来避免精度损失。
3. **边界处理**：多数题解都处理了 \( x = 0 \) 的情况，确保输出为正整数。
4. **无解情况**：所有题解都正确处理了方差为 0 的情况，输出 `No answer!`。

### 评分较高的题解

#### 1. **作者：Elgo87 (5星)**
- **关键亮点**：推导清晰，代码简洁，处理了所有边界情况，且使用了快速读入优化。
- **个人心得**：强调了开 `long long` 的重要性，避免因未开 `long long` 而导致的 WA。
- **核心代码**：
  ```cpp
  ll x = floor(sqrt(k / sum)), y = ceil(sqrt(k / sum));
  if (!x) printf("%lld\n", y);
  else if (fabs(x * x * 1.0 * sum - k) <= fabs(y * y * 1.0 * sum - k)) printf("%lld\n", x);
  else printf("%lld\n", y);
  ```

#### 2. **作者：Iam1789 (4星)**
- **关键亮点**：推导过程详细，代码简洁，处理了 \( x = 0 \) 的情况。
- **核心代码**：
  ```cpp
  int l = sqrt(k / ss), af;
  double an = 9e18;
  for (int i = max(l - 1, 1LL); i <= l + 1; i++) {
      double ll = (i * i) * ss;
      if (abs(k + 0.0 - ll) < an) { an = abs(k + 0.0 - ll); af = i; }
  }
  cout << af << '\n';
  ```

#### 3. **作者：_lfxxx_ (4星)**
- **关键亮点**：推导清晰，代码简洁，处理了 \( x = 0 \) 的情况。
- **核心代码**：
  ```cpp
  ans = sqrt(k / s);
  if (!ans) cout << "1\n";
  else if (k - ans * ans * s <= (ans + 1) * (ans + 1) * s - k) cout << ans << '\n';
  else cout << ans + 1 << '\n';
  ```

### 最优关键思路与技巧

1. **方差性质**：方差与 \( x \) 的关系为 \( s'^2 = x^2 \cdot s^2 \)，这是解题的核心。
2. **开方与取整**：通过开方和取整操作找到最优的 \( x \)，并比较 \( x \) 和 \( x+1 \) 的方差与 \( k \) 的接近程度。
3. **边界处理**：确保 \( x \) 为正整数，处理 \( x = 0 \) 的情况。

### 可拓展之处

- **类似题目**：可以考察其他与方差相关的题目，如给定方差求数列的某些性质。
- **精度优化**：在处理大数时，使用 `long double` 或 `__int128` 来避免精度损失。

### 推荐题目

1. **P1082 [NOIP2012 提高组] 同余方程**：考察数学推导与边界处理。
2. **P1045 [NOIP2005 提高组] 麦森数**：考察大数处理与精度优化。
3. **P1068 [NOIP2009 提高组] 多项式输出**：考察数学推导与边界处理。

### 个人心得总结

- **调试经历**：多位作者强调了未开 `long long` 导致的 WA，提醒我们在处理大数时要注意数据类型。
- **顿悟感想**：通过推导方差与 \( x \) 的关系，简化了问题的复杂度，体现了数学推导在算法设计中的重要性。

---
处理用时：29.77秒
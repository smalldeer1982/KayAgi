# 题目信息

# [SDCPC 2023] Fast and Fat

## 题目描述

您正在参加一场团体越野比赛。您的队伍共有 $n$ 名队员，其中第 $i$ 名队员的速度为 $v_i$，体重为 $w_i$。

比赛允许每名队员独立行动，也允许一名队员背着另一名队员一起行动。当队员 $i$ 背着队员 $j$ 时，如果队员 $i$ 的体重大于等于队员 $j$，则队员 $i$ 的移动速度不会变化，仍然为 $v_i$；如果队员 $i$ 的体重小于队员 $j$，则队员 $i$ 的移动速度会减去两者的体重差值，即变为 $v_i - (w_j - w_i)$。如果队员 $i$ 的移动速度将变为负数，则队员 $i$ 无法背起队员 $j$。每名队员最多只能背负另一名队员，被背负的队员无法同时背负其他队员。

所有未被背负的队员中，最慢的队员的速度，即为整个队伍的速度。求整个队伍能达到的最大速度。

## 样例 #1

### 输入

```
2
5
10 5
1 102
10 100
7 4
9 50
2
1 100
10 1```

### 输出

```
8
1```

# AI分析结果

### 综合分析与结论

本题的核心是通过二分答案和贪心策略来求解队伍的最大速度。所有题解都采用了二分答案的思路，但在具体的贪心策略和实现细节上有所不同。主要的难点在于如何高效地匹配背负者和被背负者，确保队伍的速度最大化。

### 所选题解

#### 1. 作者：SXqwq (赞：9)
- **星级**: 5星
- **关键亮点**: 
  - 详细分析了二分答案的单调性，并提出了贪心策略。
  - 通过预处理和排序优化了匹配过程，确保背负者能够背负最重的被背负者。
  - 代码结构清晰，逻辑严谨。
- **个人心得**: 
  - 作者提到“一个人最多只能背起一个人”这一限制条件，通过贪心策略确保了最优匹配。
  - 强调了“能背很重的人去背很重的人”这一关键思路。

**核心代码片段**:
```cpp
bool check(int x)
{
    vector <int> p,q;
    for(int i=1;i<=n;i++) if(A[i].v >= x) p.push_back(A[i].v+A[i].w-x);
    for(int i=1;i<=n;i++) if(B[i].v < x) q.push_back(B[i].w);
    if(p.size() < q.size()) return false;
    for(int i=0;i<q.size();i++)
    {
        if(p[i] < q[i]) return false;
    }
    return true;
}
```
**核心思想**: 通过预处理和排序，确保背负者能够背负最重的被背负者，从而最大化队伍速度。

#### 2. 作者：Coffee_zzz (赞：4)
- **星级**: 4星
- **关键亮点**: 
  - 提出了将人分为两波的思路，分别处理背负者和被背负者。
  - 通过贪心匹配，确保背负者能够背负最重的被背负者。
  - 代码简洁，逻辑清晰。
- **个人心得**: 
  - 作者提到“对于 $v_i \gt ans$ 的人，按照 $v_i+w_i- ans$ 的值从小到大排序”，这一策略确保了最优匹配。

**核心代码片段**:
```cpp
bool check(int mid){
    priority_queue<int>l,r;
    for(int i=1;i<=n;++i)
    {
        if(t[i].v>=x) r.push(t[i].w+t[i].v);
        else l.push(t[i].w);
    }
    while(!l.empty()&&!r.empty())
        if(r.top()-l.top()>=x) l.pop(),r.pop();
        else return 0;
    return (l.empty());
}
```
**核心思想**: 通过优先队列排序，确保背负者能够背负最重的被背负者，从而最大化队伍速度。

#### 3. 作者：One_JuRuo (赞：4)
- **星级**: 4星
- **关键亮点**: 
  - 提出了将人分为两波的思路，分别处理背负者和被背负者。
  - 通过贪心匹配，确保背负者能够背负最重的被背负者。
  - 代码简洁，逻辑清晰。
- **个人心得**: 
  - 作者提到“速度低于 $x$ 中的所有人应当优先满足较重的”，这一策略确保了最优匹配。

**核心代码片段**:
```cpp
bool check(int x)
{
    priority_queue<int> l,r;
    for(auto [x , y] : a){
        if(x < mid){
            l.push(y);
        }
        else{
            r.push(x + y - mid);
        }
    }
    while((!l.empty()) && (!(r.empty()))){
        int w1 = l.top() , w2 = r.top();
        if(w2 < w1) return 0;
        l.pop();
        r.pop();
    }
    return l.empty();
}
```
**核心思想**: 通过优先队列排序，确保背负者能够背负最重的被背负者，从而最大化队伍速度。

### 最优关键思路或技巧
- **二分答案**: 通过二分查找确定最大速度，利用单调性进行优化。
- **贪心策略**: 确保背负者能够背负最重的被背负者，从而最大化队伍速度。
- **优先队列**: 通过优先队列排序，优化匹配过程。

### 可拓展之处
- **类似算法套路**: 二分答案+贪心策略可以应用于其他求最大值或最小值的问题，如背包问题、任务调度等。
- **同类型题**: 
  - [P1083 借教室](https://www.luogu.com.cn/problem/P1083)
  - [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)
  - [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

### 个人心得总结
- **调试经历**: 多位作者提到在匹配背负者和被背负者时，优先满足较重的被背负者，这一策略在调试过程中被证明是有效的。
- **踩坑教训**: 部分作者提到在实现过程中，忽略了“一个人最多只能背起一个人”的限制条件，导致初版代码出错。
- **顿悟感想**: 通过二分答案和贪心策略的结合，能够高效解决此类问题，这一思路在多次调试和优化中得到了验证。

---
处理用时：33.27秒
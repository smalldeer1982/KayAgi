# 题目信息

# 「NnOI R2-T4」Colorful Days♪

## 题目描述

给出如下定义：

1. 定义 $ AB $ 为 $ A $ 数组后拼接 $ B $ 数组。
2. 定义 $ A^{0}=\{\} $（即空数组），且对 $i=1,2,3,\cdots$，$ A^{i}=A^{i-1}A$。
2. 定义 $ \operatorname{LCS}(A,B) $ 为 $ A $ 数组和 $ B $ 数组的**最长公共子序列**长度。

现给定长度为 $ n $ 的数组 $ S $ 和长度为 $ m $ 的数组 $ T $，数组中的数均为正整数。

你现在需要找到最小的非负整数 $k$，使得 $ \operatorname{LCS}(S^k,T) $ 最大。

出题人很仁慈，如果你无法最小化 $k$，你也可以拿到一部分分数。

## 说明/提示

**【样例 1 解释】**

当 $k = 2$ 时，$S^k = \text{\{23 34 \textcolor{red}{53 23 34} 53\}}$，其中标红的是 $S^k$ 和 $T$ 的最长公共子序列。

**【数据范围】**

**提示：本题开启捆绑测试。**

对于 $ 100\% $ 的数据，保证 $ 1 \le n,m,S_i,T_i \le 10^6 $，$ c_1,c_2 \in \{0,1\} $。

$$
\def\r{\cr\hline}
\def\None{\text{None}}
\def\arraystretch{1.5}
\begin{array}{c|c|c}
\textbf{Subtask} & \textbf{Sp. Constraints} & \textbf{Score}\r
\textsf1& c_1=c_2=0 & 2 \r
\textsf2& n \le 10^3，m \le 10^2 & 8 \r
\textsf3& n \le 10^4，m \le 10^3 & 15 \r
\textsf4& c_2=0 & 15 \r
\textsf5& n,m \le 10^5，S_i,T_i \le 26 & 20 \r
\textsf6& 无特殊限制 & 40 \r
\end{array}
$$

在赛后新添加的 hack 测试点会加入 subtask7。

### 题目来源

| 项目 | 人员 |
|:-:|:-:|
|idea| 船酱魔王 |
|data| 船酱魔王 |
|check| Sudohry |
|solution| 船酱魔王 |

## 样例 #1

### 输入

```
3 4 1 1
23 34 53
53 25 23 34```

### 输出

```
3 2```

## 样例 #2

### 输入

```
9 10 1 1
15 12 26 21 26 21 23 12 23
26 11 21 15 16 15 12 23 17 12```

### 输出

```
7 3```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地计算数组 $S^k$ 和 $T$ 的最长公共子序列（LCS），并找到最小的 $k$ 使得 LCS 最大。大多数题解都采用了贪心策略，结合二分查找来优化时间复杂度。主要思路是：

1. **LCS 的最大值**：通过预处理 $S$ 和 $T$，保留 $T$ 中在 $S$ 中出现的元素，LCS 的最大值即为这些元素的个数。
2. **最小化 $k$**：通过贪心地匹配 $T$ 中的元素，尽可能在 $S$ 的当前循环中找到匹配的元素，若找不到则增加 $k$ 并重新开始匹配。

### 所选高质量题解

#### 1. 作者：船酱魔王 (5星)
**关键亮点**：
- 详细分析了 LCS 的最大值计算，并提出了贪心策略来最小化 $k$。
- 使用二分查找优化了匹配过程，时间复杂度为 $O(m \log n)$。
- 代码结构清晰，逻辑严谨，易于理解。

**核心代码**：
```cpp
int findx(int p, int val) {
    int l = -1, r = g[p].size();
    while (l + 1 < r) {
        int mid = (l + r) >> 1;
        if (g[p][mid] > val) r = mid;
        else l = mid;
    }
    return r;
}
```
**实现思想**：通过二分查找在 $S$ 中找到第一个大于当前匹配位置的值，若找不到则增加 $k$ 并重新开始匹配。

#### 2. 作者：Jorisy (4.5星)
**关键亮点**：
- 简洁明了地提出了贪心策略，并通过二分查找优化了匹配过程。
- 代码简洁，逻辑清晰，适合快速理解和实现。

**核心代码**：
```cpp
auto t = lower_bound(v[b[i]].begin(), v[b[i]].end(), lst + 1);
if (t == v[b[i]].end()) {
    ans++;
    lst = *v[b[i]].begin();
} else {
    lst = *t;
}
```
**实现思想**：使用 `lower_bound` 在 $S$ 中找到第一个大于当前匹配位置的值，若找不到则增加 $k$ 并重新开始匹配。

#### 3. 作者：COsm0s (4星)
**关键亮点**：
- 提出了将 $S$ 复制一遍的思路，方便处理 $k+1$ 的情况。
- 使用二分查找优化了匹配过程，时间复杂度为 $O(n \log n)$。

**核心代码**：
```cpp
int k = upper_bound(cnt[t[i]].begin(), cnt[t[i]].end(), lst) - cnt[t[i]].begin();
lst = cnt[t[i]][k];
if (cnt[t[i]][k] > n) LCS++, lst -= n;
```
**实现思想**：通过二分查找在 $S$ 中找到第一个大于当前匹配位置的值，若找不到则增加 $k$ 并重新开始匹配。

### 最优关键思路与技巧

1. **贪心策略**：尽可能在当前 $S$ 的循环中匹配 $T$ 中的元素，若找不到则增加 $k$ 并重新开始匹配。
2. **二分查找优化**：通过预处理 $S$ 中每个元素的位置，使用二分查找快速找到匹配的位置，将时间复杂度从 $O(n^2)$ 优化到 $O(m \log n)$。
3. **预处理与数据结构**：使用 `vector` 或 `set` 存储 $S$ 中每个元素的位置，方便后续的二分查找。

### 可拓展之处

1. **同类型题**：类似的问题可以扩展到字符串匹配、子序列匹配等场景，贪心策略和二分查找依然是有效的优化手段。
2. **算法套路**：贪心 + 二分查找的组合在解决类似问题时非常常见，尤其是在需要最小化某个参数（如 $k$）的情况下。

### 推荐题目

1. **P3375 【模板】KMP字符串匹配**：考察字符串匹配的经典问题，适合练习贪心和预处理技巧。
2. **P1439 【模板】最长公共子序列**：考察 LCS 的经典问题，适合练习动态规划和贪心策略。
3. **P1020 导弹拦截**：考察贪心和二分查找的结合，适合练习如何最小化某个参数。

### 个人心得摘录

- **船酱魔王**：通过二分查找优化了匹配过程，避免了暴力匹配的高时间复杂度。
- **Jorisy**：简洁的代码和清晰的逻辑使得实现更加高效，适合快速理解和应用。
- **COsm0s**：将 $S$ 复制一遍的思路在处理 $k+1$ 的情况下非常巧妙，减少了代码复杂度。

### 通用建议与扩展思路

- **预处理与数据结构**：在解决类似问题时，预处理和选择合适的数据结构（如 `vector`、`set`）可以大大优化算法效率。
- **贪心策略**：在需要最小化某个参数的情况下，贪心策略往往是有效的解决方案。
- **二分查找**：在处理有序数据时，二分查找是优化时间复杂度的常用手段。

---
处理用时：33.81秒
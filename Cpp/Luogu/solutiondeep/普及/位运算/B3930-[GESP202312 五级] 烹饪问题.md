# 题目信息

# [GESP202312 五级] 烹饪问题

## 题目描述

有 $N$ 种食材，编号从 $0$ 至 $N-1$，其中第 $i$ 种食材的美味度为 $a_i$。

不同食材之间的组合可能产生奇妙的化学反应。具体来说，如果两种食材的美味度分别为 $x$ 和 $y$ ，那么它们的契合度为 $x\ \text{and}\ y $。

其中，$\text{and}$ 运算为按位与运算，需要先将两个运算数转换为二进制，然后在高位补足 ，再逐位进行与运算。例如，$12$ 与 $6$ 的二进制表示分别为 $1100$ 和 $0110$ ，将它们逐位进行与运算，得到 $0100$ ，转换为十进制得到 4，因此 $12 \text{and} 6 = 4$。**在 C++ 或 Python 中，可以直接使用 `&` 运算符表示与运算。**


现在，请你找到契合度最高的两种食材，并输出它们的契合度。

## 说明/提示

**样例解释 1**  

可以编号为 $1,2$ 的食材之间的契合度为 $2\ \text{and} \ 3=2$，是所有食材两两之间最高的契合度。

**样例解释 2** 

可以编号为 $3,4$ 的食材之间的契合度为 $10\ \text{and}\ 13=8$，是所有食材两两之间最高的契合度。

**数据范围**

对于 $40\%$ 的测试点，保证 $N \le 1,000$；

对于所有测试点，保证 $N \le 10^6$，$0\le a_i \le 2,147,483,647$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
5
5 6 2 10 13
```

### 输出

```
8```

# AI分析结果

### 综合分析与结论

本题的核心在于高效地找到两个食材，使得它们的按位与运算结果最大。由于数据规模较大（$N \le 10^6$），直接使用双重循环的暴力解法会超时。因此，题解中提出了多种优化思路，主要包括：

1. **贪心策略**：通过从高位到低位逐位确定最大契合度的二进制位，逐步缩小候选食材的范围。
2. **排序与筛选**：通过排序和筛选，减少需要处理的食材数量，从而降低时间复杂度。
3. **数学归纳法**：利用数学归纳法证明只需处理前32个食材即可找到最优解。

### 所选高分题解

#### 题解1：_little_Cabbage_ (4星)
- **关键亮点**：
  - 利用数学归纳法证明只需处理前32个食材，时间复杂度为 $O(\min(n,32)^2)$。
  - 代码简洁，逻辑清晰，易于理解。
- **核心实现思想**：
  - 先对所有食材按美味度从大到小排序，然后只处理前32个食材，通过双重循环计算最大契合度。

```cpp
sort(a+1,a+n+1,cmp);
n=min(n,32);
long long mx=0;
for(int i=1;i<=n;i++) {
    for(int j=1;j<=n;j++) {
        if(i!=j) {
            mx=max(mx,a[i]&a[j]);
        }
    }
}
```

#### 题解2：zhang_kevin (4星)
- **关键亮点**：
  - 从高位到低位逐位确定最大契合度的二进制位，逐步缩小候选食材的范围。
  - 通过位运算和筛选，减少了需要处理的食材数量。
- **核心实现思想**：
  - 从最高位开始，逐位检查是否有至少两个食材在该位为1，如果有则保留这些食材，继续检查下一位。

```cpp
for(int i = 0; i < len; i++){
    vector<int> v2 = get2(i, v);
    if(v2.size() < 2) continue;
    v = v2;
}
int ans = INT_MIN;
for(int i = 0; i < v.size(); i++){
    for(int j = 0; j < v.size(); j++){
        if(i != j) ans = max(ans, vec[v[i]]&vec[v[j]]);
    }
}
```

#### 题解3：xiaoniu142857 (4星)
- **关键亮点**：
  - 通过排序和二分查找，逐步缩小候选食材的范围。
  - 时间复杂度为 $O(n \log n)$，适合大规模数据处理。
- **核心实现思想**：
  - 从最高位开始，逐位检查食材的二进制位，通过二分查找和插入排序，逐步缩小候选食材的范围。

```cpp
for(int bit=1<<30;bit;bit>>=1) {
    if((a[st]&bit)||!(a[ed]&bit)) continue;
    if((a[ed]&bit)&&!(a[ed-1]&bit)) {
        int t=a[ed]^=bit,i;
        for(i=ed-1;i>=st&&a[i]>t;--i) a[i+1]=a[i];
        a[i+1]=t;
    } else {
        int l=st,r=ed,mid;
        while(l<r) {
            mid=(l+r)>>1;
            if(a[mid]&bit) r=mid;
            else l=mid+1;
        }
        st=l;
    }
    if(ed-st<=1) break;
}
printf("%d",a[st]&a[ed]);
```

### 最优关键思路与技巧

1. **贪心策略**：从高位到低位逐位确定最大契合度的二进制位，逐步缩小候选食材的范围。
2. **排序与筛选**：通过排序和筛选，减少需要处理的食材数量，从而降低时间复杂度。
3. **数学归纳法**：利用数学归纳法证明只需处理前32个食材即可找到最优解。

### 可拓展之处

- **类似问题**：可以扩展到其他位运算问题，如按位或、按位异或等。
- **算法套路**：贪心策略和排序筛选的思路可以应用于其他需要高效处理大规模数据的问题。

### 推荐题目

1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

### 个人心得

- **调试经历**：在处理大规模数据时，优化算法的时间复杂度是关键，避免直接使用暴力解法。
- **踩坑教训**：在逐位确定最大契合度时，需要注意二进制位的处理顺序，从高位到低位逐位确定。
- **顿悟感想**：通过数学归纳法证明只需处理前32个食材，大大减少了计算量，提高了算法的效率。

---
处理用时：33.88秒
# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果

### 综合分析与结论

本题要求维护一个数列，支持区间乘法、区间加法、区间求和操作，且需要对结果取模。由于操作次数和数据规模较大，直接暴力操作会超时，因此需要使用线段树来高效处理这些操作。线段树的难点在于如何处理乘法和加法的惰性标记（lazy tag），尤其是在乘法和加法同时存在时，如何正确下放标记并更新区间值。

通过对多条题解的分析，大多数题解都采用了线段树的基本框架，但在惰性标记的处理上有所不同。部分题解通过先乘后加的策略，确保标记下放时的顺序正确，从而避免了复杂的标记处理。此外，一些题解还通过优化取模操作和减少不必要的计算来提升性能。

### 所选高星题解

#### 1. **题解作者：Mingoal (赞：74)**  
   **星级：5星**  
   **关键亮点：**  
   - 代码结构清晰，注释详细，易于理解。
   - 使用先乘后加的策略处理惰性标记，确保标记下放时的顺序正确。
   - 通过宏定义简化代码，提高可读性。
   - 提供了详细的建树、更新、查询操作的实现。

   **个人心得：**  
   - 强调了乘法和加法标记的处理顺序，确保标记下放时的正确性。
   - 通过多次练习线段树，加深了对惰性标记的理解。

   **核心代码：**
   ```cpp
   void maintain(int t,int k){//维护su,mu和ad
       tr[t<<1].su=(tr[t<<1].su*tr[t].mu+tr[t].ad*(k+1>>1))%M;
       tr[t<<1|1].su=(tr[t<<1|1].su*tr[t].mu+tr[t].ad*(k>>1))%M;
       tr[t<<1].mu=tr[t<<1].mu*tr[t].mu%M;
       tr[t<<1|1].mu=tr[t<<1|1].mu*tr[t].mu%M;
       tr[t<<1].ad=(tr[t<<1].ad*tr[t].mu+tr[t].ad)%M;
       tr[t<<1|1].ad=(tr[t<<1|1].ad*tr[t].mu+tr[t].ad)%M;
       tr[t].mu=1;tr[t].ad=0;
   }
   ```

#### 2. **题解作者：zjy111 (赞：35)**  
   **星级：4.5星**  
   **关键亮点：**  
   - 详细解释了线段树的建树、更新、查询操作。
   - 通过先乘后加的策略处理惰性标记，确保标记下放时的正确性。
   - 提供了对线段树的基本概念和操作的详细说明，适合初学者理解。

   **核心代码：**
   ```cpp
   void pushdown(ll p){
       sum[ls(p)]=(mu[p]*sum[ls(p)]+(rrr[ls(p)]-lll[ls(p)]+1)*add[p]%md)%md;
       sum[rs(p)]=(mu[p]*sum[rs(p)]+(rrr[rs(p)]-lll[rs(p)]+1)*add[p]%md)%md;
       mu[ls(p)]=(mu[p]*mu[ls(p)])%md;
       mu[rs(p)]=(mu[p]*mu[rs(p)])%md;
       add[ls(p)]=(mu[p]*add[ls(p)]+add[p])%md;
       add[rs(p)]=(mu[p]*add[rs(p)]+add[p])%md;
       mu[p]=1,add[p]=0;
   }
   ```

#### 3. **题解作者：GaryZhong (赞：17)**  
   **星级：4星**  
   **关键亮点：**  
   - 使用结构体指针构建线段树，灵活处理动态节点。
   - 通过先乘后加的策略处理惰性标记，确保标记下放时的正确性。
   - 提供了对线段树的基本操作和标记处理的详细说明。

   **核心代码：**
   ```cpp
   void down(int rt, int l, int r){
       if (mtp[rt] == 1 && inc[rt] == 0) return;
       if (l != r)
           mtp[lson] = mtp[lson] * mtp[rt] % P,
           mtp[rson] = mtp[rson] * mtp[rt] % P,
           inc[lson] = (inc[lson] * mtp[rt] % P + inc[rt]) % P,
           inc[rson] = (inc[rson] * mtp[rt] % P + inc[rt]) % P;
       sum[rt] = (sum[rt] * mtp[rt] % P + inc[rt] * (r - l + 1) % P) % P;
       mtp[rt] = 1, inc[rt] = 0;
   }
   ```

### 最优关键思路与技巧

1. **先乘后加的策略**：在处理乘法和加法的惰性标记时，先进行乘法操作，再进行加法操作，确保标记下放时的顺序正确。
2. **惰性标记的下放**：在更新和查询操作中，先下放标记，确保当前区间的值是最新的。
3. **取模优化**：在每次操作后对结果取模，避免数值溢出，同时减少不必要的计算。

### 可拓展之处

- **多标记处理**：在处理多个标记（如乘法、加法、赋值等）时，需要注意标记的下放顺序，确保操作的顺序正确。
- **动态开点线段树**：在处理数据范围较大或动态插入数据时，可以使用动态开点线段树，节省空间。

### 推荐题目

1. **P3373 【模板】线段树 2**  
   与本题几乎相同，考察线段树的区间乘法和加法操作。

2. **P3372 【模板】线段树 1**  
   考察线段树的区间加法和区间求和操作。

3. **P5490 【模板】扫描线**  
   考察线段树在扫描线算法中的应用，适合进阶练习。

### 个人心得总结

- **调试经历**：在处理惰性标记时，标记下放的顺序和时机非常重要，调试时需要特别注意标记的正确性。
- **踩坑教训**：在取模操作时，需要注意避免数值溢出，尤其是在乘法和加法同时存在时。
- **顿悟感想**：通过多次练习线段树，逐渐理解了惰性标记的处理方式，掌握了先乘后加的策略。

---
处理用时：68.97秒
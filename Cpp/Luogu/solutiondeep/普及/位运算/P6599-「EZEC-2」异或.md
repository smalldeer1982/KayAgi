# 题目信息

# 「EZEC-2」异或

## 题目描述

有 $T$ 组询问，每次给定两个正整数 $n,l$，   

你需要构造一个长度为 $l$ 的正整数序列 $a$（编号从 $1$ 至 $l$），   

且满足 $\forall i\in[1,l]$，都有 $a_i\in[1,n]$。

求：

$$\sum_{i=1}^l\sum_{j=1}^{i-1}a_i\oplus a_j$$

的最大值。

为了避免答案过大，对于每组询问，只需要输出这个最大值对 $10^9+7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**   
当 $n=2,l=3$，$a$ 取 $\{1,2,1\}$ 的任一排列时可以得到最大值，为 $(1\oplus2)+(1\oplus1)+(2\oplus1)=6$，易证明此时原式有最大值。

---
**【数据规模与约定】**
| 测试点编号 | $T\le$ | $n\le$ | $l\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim5$ | $1$ | $10$ | $5$ |
| $6$ | $5\times 10^5$ | $10^{12}$ | $2$ |
| $7$ | $5\times 10^5$ | $10^{12}$ | $3$ |
| $8\sim10$ | $5\times 10^5$ | $10^{12}$ | $10^5$ |

对于 $100\%$ 的数据，满足 $1\le T\le 5\times10^5$，$1\le n\le 10^{12}$，$2\le l \le 10^5$。


---
**【提示】**

1. 「$\oplus$」是按位异或符号。如果您不知道什么是按位异或，可以参考[这里](https://oi-wiki.org/math/bit/#_1)。
2. 取模是一种运算，$a$ 对 $b$ 取模代表将 $a$ 赋值为 $a$ 除以 $b$ 所得到的余数。  
在 C++ / Python 中的取模符号为 `%`，在 Pascal 中的取模符号为 `mod`。
3. $\sum$ 是求和符号。如果您不知道什么是 $\sum$ 符号，可以参考[这里](https://baike.baidu.com/item/∑/1233796?fr=aladdin)。
4. 请注意数据的读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
1
2 3
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
114 514
1919 180
```

### 输出

```
8388223
16580700```

# AI分析结果

### 综合分析与结论

本题的核心在于通过按位分析，最大化异或和。大多数题解都采用了按位贪心的策略，通过计算每一位的贡献来得到最终答案。关键思路是：对于每一位，尽量让1和0的数量接近，从而最大化该位的贡献。具体来说，对于每一位，贡献为 `x * (l - x) * 2^k`，其中 `x` 是该位为1的数量。当 `x = l / 2` 时，贡献最大。

### 所选高质量题解

#### 1. **作者：李白莘莘学子 (5星)**
   - **关键亮点**：思路清晰，详细解释了按位分析的过程，并通过二次函数求极值的方法证明了 `x = l / 2` 时贡献最大。代码实现简洁，逻辑清晰。
   - **个人心得**：通过二次函数求极值的方法，直观地解释了为什么 `x = l / 2` 时贡献最大，这种数学推导使得思路更加严谨。
   - **核心代码**：
     ```cpp
     long long big = 1ll << 40;
     while (big) {
         big >>= 1;
         if (n < big) continue;
         ans += big * mid * (l - mid);
         ans %= modd;
     }
     ```
   - **代码简述**：从最高位开始，逐位计算贡献，并累加到答案中。

#### 2. **作者：do_while_true (4.5星)**
   - **关键亮点**：详细证明了 `x = l / 2` 时贡献最大，并通过构造法证明了如何构造序列使得每一位的1和0数量接近。代码实现简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     ll ans = (l / 2) * (l - l / 2) % mod * (qpow(2, log(n) / log(2) + 1) - 1) % mod;
     ```
   - **代码简述**：通过公式直接计算答案，避免了逐位计算的复杂度。

#### 3. **作者：hanzhongtlx (4星)**
   - **关键亮点**：通过猜结论的方式，快速推导出答案公式，并通过暴力对拍验证了正确性。代码实现简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     printf("%lld\n", ((mi[logn(l)] - 1) % MOD * (r / 2) % MOD * (r - r / 2) % MOD));
     ```
   - **代码简述**：通过预处理幂次，快速计算答案。

### 最优关键思路与技巧

1. **按位分析**：将问题分解为每一位的贡献，通过贪心策略最大化每一位的贡献。
2. **数学推导**：通过二次函数求极值的方法，证明 `x = l / 2` 时贡献最大。
3. **构造法**：通过构造序列，使得每一位的1和0数量接近，从而最大化贡献。

### 可拓展之处

1. **类似问题**：类似的问题可以通过按位分析、贪心策略和数学推导来解决。例如，最大化按位与、按位或等问题。
2. **优化技巧**：通过预处理幂次、快速幂等方法，可以优化计算过程，提高代码效率。

### 推荐题目

1. **P2114 [NOI2014] 起床困难综合症**：考察按位贪心的经典题目。
2. **P6102 [EER2] 选择**：通过按位分析最大化异或和。
3. **P2115 [USACO14MAR] Sabotage G**：通过贪心策略解决最大化问题。

### 个人心得总结

- **调试经历**：通过暴力对拍验证猜想的正确性，是一种有效的调试方法。
- **顿悟感想**：按位分析是解决位运算问题的有效方法，通过数学推导可以使得思路更加严谨。

---
处理用时：31.33秒
# 题目信息

# [CSP-S2020] 动物园

## 题目描述

动物园里饲养了很多动物，饲养员小 A 会根据饲养动物的情况，按照《饲养指南》购买不同种类的饲料，并将购买清单发给采购员小 B。 

具体而言，动物世界里存在 $2^k$ 种不同的动物，它们被编号为 $0 \sim 2^k - 1$。动物园里饲养了其中的 $n$ 种，其中第 $i$ 种动物的编号为 $a_i$。

《饲养指南》中共有 $m$ 条要求，第 $j$ 条要求形如“如果动物园中饲养着某种动物，满足其编号的二进制表示的第 $p_j$ 位为 $1$，则必须购买第 $q_j$ 种饲料”。其中饲料共有 $c$ 种，它们从 $1 \sim c$ 编号。本题中我们将动物编号的二进制表示视为一个 $k$ 位 01 串，第 $0$ 位是最低位，第 $k - 1$ 位是最高位。 

根据《饲养指南》，小 A 将会制定饲料清单交给小 B，由小 B 购买饲料。清单形如一个 $c$ 位 $01$ 串，第 $i$ 位为 $1$ 时，表示需要购买第 $i$ 种饲料；第 $i$ 位为 $0$ 时，表示不需要购买第 $i$ 种饲料。 实际上根据购买到的饲料，动物园可能可以饲养更多的动物。更具体地，如果将当前未被饲养的编号为 $x$ 的动物加入动物园饲养后，饲料清单没有变化，那么我们认为动物园当前还能饲养编号为 $x$ 的动物。

现在小 B 想请你帮忙算算，动物园目前还能饲养多少种动物。

## 说明/提示

**【样例 #1 解释】**

动物园里饲养了编号为 $1, 4, 6$ 的三种动物，《饲养指南》上的三条要求为：

1. 若饲养的某种动物的编号的第 $0$ 个二进制位为 $1$，则需购买第 $3$ 种饲料。
2. 若饲养的某种动物的编号的第 $2$ 个二进制位为 $1$，则需购买第 $4$ 种饲料。
3. 若饲养的某种动物的编号的第 $2$ 个二进制位为 $1$，则需购买第 $5$ 种饲料。 

饲料购买情况为：

1. 编号为 $1$ 的动物的第 $0$ 个二进制位为 $1$，因此需要购买第 $3$ 种饲料；
2. 编号为 $4, 6$ 的动物的第 $2$ 个二进制位为 $1$，因此需要购买第 $4, 5$ 种饲料。 

由于在当前动物园中加入一种编号为 $0, 2, 3, 5, 7, 8, \ldots , 15$ 之一的动物，购物清单都不会改变，因此答案为 $13$。

**【数据范围】**

对于 $20 \%$ 的数据，$k \le n \le 5$，$m \le 10$，$c \le 10$，所有的 $p_i$ 互不相同。  
对于 $40 \%$ 的数据，$n \le 15$，$k \le 20$，$m \le 20$，$c \le 20$。  
对于 $60 \%$ 的数据，$n \le 30$，$k \le 30$，$m \le 1000$。  
对于 $100 \%$ 的数据，$0 \le n, m \le 10^6$，$0 \le k \le 64$，$1 \le c \le 10^8$。

## 样例 #1

### 输入

```
3 3 5 4
1 4 6
0 3
2 4
2 5```

### 输出

```
13```

## 样例 #2

### 输入

```
2 2 4 3
1 2
1 3
2 4```

### 输出

```
2```

## 样例 #3

### 输入

```
见附件中的 zoo/zoo3.in```

### 输出

```
见附件中的 zoo/zoo3.ans```

# AI分析结果

### 综合分析与结论

该题目主要考察位运算、二进制处理以及容斥原理的应用。题解的核心思路是通过位运算统计哪些二进制位可以被自由选择，进而计算出可以新增的动物数量。大多数题解都采用了类似的思路，即通过或运算统计已有动物的二进制位覆盖情况，然后根据饲料要求判断哪些位可以被自由选择。最终通过计算 $2^{bit} - n$ 得到答案。

### 所选高星题解

#### 1. 作者：Alex_Wei (5星)
- **关键亮点**：代码简洁高效，利用 `unsigned long long` 进行位运算，处理了 $k=64$ 的特殊情况，且时间复杂度为 $O(n+m)$，空间复杂度为 $O(1)$。
- **代码核心**：
  ```cpp
  ull n,m,c,k,ans,lim,hv;
  int main(){
      n=rd(),m=rd(),c=rd(),k=rd();
      for(int i=1;i<=n;i++)hv|=rd(); // 统计每个位是否有 1
      for(int i=1;i<=m;i++)lim|=1ull<<rd(),rd(); // 统计有限制的位
      for(int i=0;i<k;i++)ans+=!((lim>>i)&1)||((hv>>i)&1); // 统计可选的位
      if(ans==64&&!n)puts("18446744073709551616");
      else cout<<(ans==64?-n:(1ull<<ans)-n)<<endl;
      return 0;
  }
  ```
- **个人心得**：作者提到要特判 $k=64$ 且 $n=0$ 的情况，并建议使用快读处理大量输入。

#### 2. 作者：OMG_wc (4.5星)
- **关键亮点**：思路清晰，代码简洁，特别处理了 $k=64$ 的情况，且通过位运算高效统计可选的二进制位。
- **代码核心**：
  ```cpp
  ULL flag = 0, g = 0;
  for (int i = 0; i < n; i++) {
      ULL x;
      scanf("%llu", &x);
      flag |= x;
  }
  while (m--) {
      int p;
      scanf("%d%*d", &p);
      if ((flag >> p & 1) == 0) g |= 1ULL << p;
  }
  ULL ans = 1;
  for (int i = 0; i < K; i++) {
      if ((g >> i & 1) == 0) ans <<= 1;
  }
  if (ans == 0 && n == 0) {
      puts("18446744073709551616");
      return 0;
  }
  ans -= n;
  printf("%llu\n", ans);
  ```
- **个人心得**：作者提到 $n=0$ 时需特判输出 $2^{64}$，并建议使用 `unsigned long long` 类型。

#### 3. 作者：StudyingFather (4星)
- **关键亮点**：代码结构清晰，通过 `vis` 和 `disable` 数组记录哪些位可以被自由选择，处理了 $k=64$ 的特殊情况。
- **代码核心**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      ull a;
      cin >> a;
      for (int j = k - 1; j >= 0; j--) vis[j] |= (a >> j) & 1;
  }
  for (int i = 1; i <= m; i++) {
      int p, q;
      cin >> p >> q;
      if (!vis[p]) disable[p] = 1;
  }
  int cnt = 0;
  for (int i = 0; i < k; i++)
      if (disable[i]) cnt++;
  if (k - cnt == 64) {
      if (n)
          cout << ull(-n) << endl;
      else
          cout << "18446744073709551616" << endl;
  } else
      cout << (1ull << (k - cnt)) - n << endl;
  ```
- **个人心得**：作者提到要特判 $k=64$ 且 $n=0$ 的情况，并建议使用 `ull` 类型。

### 最优关键思路与技巧
1. **位运算**：通过或运算统计已有动物的二进制位覆盖情况，高效判断哪些位可以被自由选择。
2. **特判处理**：对于 $k=64$ 的情况，需特判输出 $2^{64}$，避免溢出。
3. **时间复杂度优化**：通过位运算和预处理，将时间复杂度优化到 $O(n+m)$。

### 拓展思路与类似题目
- **类似题目**：
  1. [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)
  2. [P2396 yyy loves Maths VII](https://www.luogu.com.cn/problem/P2396)
  3. [P3812 【模板】线性基](https://www.luogu.com.cn/problem/P3812)

### 个人心得总结
- **调试经历**：多位作者提到在处理 $k=64$ 时需特别小心，避免溢出问题。
- **顿悟感想**：通过位运算可以高效处理二进制相关的问题，尤其是涉及大量数据时，位运算的优势尤为明显。

---
处理用时：38.56秒
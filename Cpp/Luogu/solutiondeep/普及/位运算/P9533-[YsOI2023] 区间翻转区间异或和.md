# 题目信息

# [YsOI2023] 区间翻转区间异或和

## 题目背景

Ysuperman 模板测试的数据结构题。

符卡可以是人名也可以是队名。

## 题目描述

符卡有一个长度为 $n$ 的整数数组 $a$，符卡认为一个区间 $[l,r]$ 是灵异区间当且仅当 $\bigoplus_{i=l}^ra_i=0$，或者说这个区间内所有数字异或起来刚好等于 $0$。

符卡有特殊的魔法，可以把**任意**一个灵异区间翻转。具体来说，如果 $[l,r]$ 区间是灵异区间，那么符卡就可以对这个区间使用魔法，整个数组就会变成 $a_1,a_2,\dots,a_{l-1},a_r,a_{r-1},\dots,a_l,a_{r+1},a_{r+2}\dots,a_n$。

现在符卡可以使用任意次数的魔法，符卡希望最后得到的数组的灵异区间数量能够尽可能多，你能告诉她最后最多有多少个灵异区间吗？

## 说明/提示

#### 样例 1 解释

无论符卡发动多少次魔法，数组都是 $1,1,1$，所以发不发动魔法都没有任何关系。灵异区间永远都是 $[1,2],[2,3]$ 两个。

#### 样例 2 解释

这里给出可能的一种魔法发动方法。

选择灵异区间 $[1,3]$ 发动魔法，得到的新数组是 $2,1,3,3$，这个数组共有两个灵异区间，分别是 $[1,3]$ 和 $[3,4]$。

可以证明答案无法超过 $2$。

#### 数据范围

对于前 $20\%$ 的数据，保证 $n\le 10$。

对于前 $40\%$ 的数据，保证 $n\le 2000$。

另有 $10\%$ 的数据，保证 $a_i$ 全部相等。

另有 $10\%$ 的数据，保证 $a_i$ 只有两种可能的取值。

另有 $10\%$ 的数据，保证 $0\le a_i<2^{10}$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$0\le a_i< 2^{20}$。

#### 彩蛋

灵异区间的名字其实是“零异（或）区间”的谐音。

## 样例 #1

### 输入

```
3
1 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4
3 1 2 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心在于理解“灵异区间”的定义，并通过翻转操作最大化灵异区间的数量。经过分析，所有题解都得出一个关键结论：**翻转操作对灵异区间的数量没有影响**。这一结论的证明基于异或运算的交换律和结合律，翻转区间不会改变区间的异或和。因此，问题简化为统计原数组中所有异或和为0的区间数量。

大多数题解都采用了**前缀异或和**的方法来高效统计灵异区间，并通过哈希表（如`map`或数组）记录前缀异或和的出现次数，最终通过组合公式计算灵异区间的数量。

### 所选高星题解

#### 1. 作者：_•́へ•́╬_ (5星)
- **关键亮点**：思路清晰，代码简洁，直接通过前缀异或和和哈希表统计灵异区间数量，时间复杂度为O(n)，空间复杂度为O(1<<20)。
- **代码核心**：
  ```cpp
  int n,a[100009],cnt[1<<20];long long ans;
  main()
  {
      read(n);cnt[0]=1;
      for(int i=1;i<=n;++i)
      {
          read(a[i]);a[i]^=a[i-1];
          ans+=cnt[a[i]]++;
      }
      printf("%lld",ans);
  }
  ```
- **实现思想**：通过前缀异或和和哈希表记录每个前缀异或和的出现次数，每次遇到相同的前缀异或和时，累加当前已有的次数到答案中。

#### 2. 作者：Shizaki_Crazy_Three (4星)
- **关键亮点**：详细证明了翻转操作的无意义性，并通过等差数列求和公式计算灵异区间的数量，代码可读性较好。
- **代码核心**：
  ```cpp
  long long cnt[1500000]={};
  int main(){
      int n; cin>>n;
      int a; int sum[100005]={};
      for(int i=1;i<=n;i++){
          scanf("%d",&a);
          sum[i]=sum[i-1]^a;
          cnt[sum[i]]++;
      }
      long long ans=0; cnt[0]++;
      for(int i=0;i<=maxx;i++){
          ans+=(cnt[i]*(cnt[i]-1))/2;
      }
      cout<<ans;
  }
  ```
- **实现思想**：通过前缀异或和和哈希表记录每个前缀异或和的出现次数，最后通过组合公式计算灵异区间的数量。

#### 3. 作者：_mi_ka_ (4星)
- **关键亮点**：通过反证法证明了翻转操作的无意义性，并详细解释了前缀异或和的使用方法，代码简洁高效。
- **代码核心**：
  ```cpp
  int n,ans,s,a,vis[1<<21];
  signed main()
  {
      scanf("%lld",&n),vis[0]=1;
      for(int i=1;i<=n;i++)
          scanf("%lld",&a),s^=a,ans+=vis[s],vis[s]++;
      cout<<ans;
  }
  ```
- **实现思想**：通过前缀异或和和哈希表记录每个前缀异或和的出现次数，每次遇到相同的前缀异或和时，累加当前已有的次数到答案中。

### 最优关键思路与技巧

1. **前缀异或和**：通过维护前缀异或和，可以高效地计算任意区间的异或和。
2. **哈希表统计**：使用哈希表（如`map`或数组）记录前缀异或和的出现次数，便于快速查找和统计。
3. **组合公式**：通过组合公式计算相同前缀异或和的数量，得到灵异区间的总数。

### 可拓展之处

- **同类型题**：类似的问题可以通过前缀和或哈希表来解决，如统计满足特定条件的子数组数量。
- **算法套路**：前缀和+哈希表的组合常用于统计子数组或子序列的问题，如求和为特定值的子数组数量。

### 推荐题目

1. **P3402 可持久化并查集**：考察前缀和与哈希表的结合使用。
2. **P3374 【模板】树状数组 1**：涉及前缀和的应用。
3. **P3865 【模板】ST表**：通过前缀和优化区间查询问题。

### 个人心得摘录

- **Shizaki_Crazy_Three**：通过样例和手动推导，发现翻转操作对灵异区间的数量没有影响，最终简化了问题。
- **_mi_ka_**：通过反证法证明了翻转操作的无意义性，进一步确认了问题的简化方向。

这些心得表明，通过样例分析和数学证明，可以有效地简化问题，找到最优解。

---
处理用时：36.79秒
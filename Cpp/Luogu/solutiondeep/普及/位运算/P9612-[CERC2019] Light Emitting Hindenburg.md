# 题目信息

# [CERC2019] Light Emitting Hindenburg

## 题目背景

**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Light Emitting Hindenburg](https://contest.felk.cvut.cz/19cerc/solved/hindenburg.pdf)」**

## 题目描述

Lothar 正在组织他朋友的摇滚乐队的音乐会巡演。巡演将于 11 月举行，每天最多有一场音乐会。这次巡演将非常具有代表性，许多音乐家都愿意参加。巡演中的音乐家人数是严格规定的，不能改变。巡演中的每一场音乐会都必须有所有参加巡演的音乐家参加。

对 Lothar 来说，好消息是，候选音乐家的数量至少与巡演中规定的音乐家数量一样多。坏消息是，一个典型的音乐家整个月都没有空，而且各种音乐家的日程安排也大不相同。

很久以前，Lothar 编写了一个计算机调度系统的核心，现在他正在利用它来组织这次巡演。他反复地、有点随机地选择一组指定数量的音乐家，并让系统计算出一个可接受的巡演时间表。该系统取决于一种非常具体的数据格式。音乐家的时间表和巡演时间表用数字编码表示。11 月的日子是按月份的数字标记的：$1, 2, \dots, 30$。

对于一个给定的音乐家来说，每年 11 月的一天都会被分配一个特定的数字编码。如果音乐家当天空闲，则标签为 $L$ 的一天由整数 $2^{30-L}$ 编码。否则，日期将由 $0$ 编码。音乐家的时间表编码是他或她的所有日期编码的总和。

对于一组给定的音乐家来说，每年 11 月的一天都会被分配一个特定的数字编码。如果该组中的所有音乐家当天都空闲，标签为 $L$ 的一天由整数 $2^{30-L}$ 编码。否则，日期将由 $0$ 编码。组的空闲编码是该组所有日期编码的总和。

出于许多其他微妙的原因，Lothar 认为最好的巡演应该是任意一组音乐家，这组的空闲编码是可能的最大值。

## 样例 #1

### 输入

```
5 2
6 15 9 666 1
```

### 输出

```
10
```

## 样例 #2

### 输入

```
8 4
13 30 27 20 11 30 19 10
```

### 输出

```
18
```

# AI分析结果

### 综合分析与结论

本题的核心是从给定的 $n$ 个数中选出 $k$ 个数，使得它们的按位与运算结果最大。所有题解均采用了贪心算法，从最高位（即二进制的高位）开始逐位检查，若当前位有至少 $k$ 个数为 $1$，则选择该位，并排除不满足条件的数。这种贪心策略的正确性基于二进制的性质：高位的权值远大于低位，因此优先选择高位能保证最终结果的最大化。

### 所选高星题解

#### 1. 作者：codwarm (4星)
**关键亮点**：
- 思路清晰，代码注释详细，易于理解。
- 使用 `vis` 数组标记不满足条件的数，优化了后续的检查过程。
- 从高位到低位逐位检查，确保每次选择都能最大化结果。

**核心代码**：
```cpp
for (int i = 30; i >= 1; i--) {
    cnt = 0;
    for (int j = 1; j <= n; j++) 
        if (vis[j] && (a[j] >> (i - 1) & 1)) cnt++;
    if (cnt < k) continue;
    for (int j = 1; j <= n; j++)
        if (!(vis[j] && (a[j] >> (i - 1) & 1))) vis[j] = 0;
    maxn += (int)pow(2,i-1);
}
```
**实现思想**：从最高位开始，统计当前位为 `1` 的数的个数，若满足条件则累加该位的权值，并排除不满足条件的数。

#### 2. 作者：Flaw_Owl (4星)
**关键亮点**：
- 详细解释了贪心策略的正确性，帮助理解算法的核心思想。
- 代码结构清晰，使用 `check` 数组标记不可用的数，优化了后续的检查过程。

**核心代码**：
```cpp
for (int i = 29; i >= 0; i--) {
    int cnt = 0;
    for (int j = 1; j <= N; j++) {
        int temp = (a[j] >> i) & 1;
        if (check[j] && temp) cnt++;
    }
    if (cnt >= K) {
        for (int j = 1; j <= N; j++) {
            int temp = (a[j] >> i) & 1;
            if (check[j] && !temp) check[j] = false;
        }
        ans += (1 << i);
    }
}
```
**实现思想**：从最高位开始，统计当前位为 `1` 的数的个数，若满足条件则累加该位的权值，并排除不满足条件的数。

#### 3. 作者：wangjue233 (4星)
**关键亮点**：
- 代码简洁，逻辑清晰，易于理解。
- 使用 `vis` 数组标记不可用的数，优化了后续的检查过程。

**核心代码**：
```cpp
for (int i = 29; i >= 0; i--) {
    int val = 1 << i;
    int cnt = 0;
    for (int j = 1; j <= n; j++) {
        if (vis[j] && (a[j] & val)) cnt++;
    }
    if (cnt >= k) {
        ans += val;
        for (int j = 1; j <= n; j++) {
            if ((a[j] & val) == 0) vis[j] = false;
        }
    }
}
```
**实现思想**：从最高位开始，统计当前位为 `1` 的数的个数，若满足条件则累加该位的权值，并排除不满足条件的数。

### 最优关键思路与技巧

1. **贪心策略**：从最高位开始逐位检查，优先选择高位为 `1` 的数，确保最终结果最大化。
2. **标记优化**：使用 `vis` 或 `check` 数组标记不满足条件的数，减少后续检查的计算量。
3. **位运算技巧**：通过 `(a[j] >> i) & 1` 快速检查某一位是否为 `1`，提高代码效率。

### 拓展与举一反三

- **类似题目**：
  1. [P3812 【模板】线性基](https://www.luogu.com.cn/problem/P3812)：考察线性基的应用，与位运算相关。
  2. [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)：考察位运算与贪心策略的结合。
  3. [P2420 让我们异或吧](https://www.luogu.com.cn/problem/P2420)：考察异或运算与树的性质。

- **调试与顿悟**：在调试过程中，发现贪心策略的正确性依赖于二进制的权值分布，优先选择高位能保证结果的最大化。此外，使用标记数组优化了后续的检查过程，减少了不必要的计算。

---
处理用时：42.75秒
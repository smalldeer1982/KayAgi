# 题目信息

# 消失之物

## 题目描述

ftiasch 有 $n$ 个物品, 体积分别是 $w_1,w_2,\dots,w_n$。由于她的疏忽，第 $i$ 个物品丢失了。   

“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。  

她把答案记为 $\text{cnt}(i,x)$ ，想要得到所有$i \in [1,n]$, $x \in [1,m]$ 的 $\text{cnt}(i,x)$ 表格。

![](https://cdn.luogu.com.cn/upload/pic/13426.png)


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n,m \le 2000$，且 $1\le v_i\le m$。

【样例解释】  
如果物品 3 丢失的话，只有一种方法装满容量是 2 的背包，即选择物品 1 和物品 2。

---

$\text{upd 2023.8.11}$：新增加五组 Hack 数据。


## 样例 #1

### 输入

```
3 2
1 1 2```

### 输出

```
11
11
21```

# AI分析结果



### 综合分析

本题核心在于如何高效处理「删除单个物品后的背包方案数」。常规做法是跑 $n$次 01 背包，但时间复杂度 $O(n^2m)$ 无法通过。所有题解均围绕「先计算完整背包，再通过动态调整扣除单个物品贡献」进行优化，关键思路为**退背包**或**递推式扣除贡献**，时间复杂度优化至 $O(nm)$。

---

### 精选题解

#### 1. Kelin 题解（5星）
**亮点**：  
- 提出「撤销转移」思路，将原背包逆序转移改为正序扣除，代码简洁高效。  
- 正确性证明明确，指出物品顺序不影响结果，通过逆向操作实现退背包。  
  
**核心代码**：  
```cpp
memcpy(g, f, sizeof(f));  // 复制完整背包结果
for (int j = w[i]; j <= m; ++j)
    g[j] = (g[j] - g[j - w[i]] + 10) % 10;  // 正序扣除i的贡献
```

#### 2. 7KByte 题解（4星）
**亮点**：  
- 通过数学归纳法证明退背包的正确性，强调物品顺序无关性。  
- 代码采用紧凑的循环结构，逻辑清晰。  

**核心代码**：  
```cpp
rep(i, 1, n) {
    rep(j, 0, m) g[j] = f[j];  // 初始化g为完整背包
    rep(j, 0, m - a[i]) {      // 正序扣除i的贡献
        g[a[i] + j] = (g[a[i] + j] - g[j] + 10) % 10;
    }
}
```

#### 3. Gary818 题解（4星）
**亮点**：  
- 递推式 $g[j] = f[j] - g[j - w_i]$ 直观解释扣除逻辑。  
- 强调负数处理（+10 再取模），避免计算错误。  

**核心代码**：  
```cpp
g[0] = 1;
for (int x = 1; x <= m; ++x) {
    if (x >= w[i]) 
        g[x] = (f[x] - g[x - w[i]] + 10) % 10;
    else 
        g[x] = f[x] % 10;
}
```

---

### 关键技巧总结
1. **退背包思想**：通过逆序转移的正序撤销，高效扣除单个物品的贡献。  
2. **递推式优化**：利用 $g[j] = f[j] - g[j - w_i]$ 动态维护不选当前物品的方案数。  
3. **负数处理**：在取模前加 10，确保结果为非负。  

---

### 举一反三
1. **退背包扩展**：适用于需要动态删除/添加物品的背包问题，如 [P4095 消失的序列](https://www.luogu.com.cn/problem/P4095)。  
2. **容斥思想**：通过总方案数减去非法方案数，如子集计数问题。  
3. **动态维护状态**：类似「滚动数组」优化，减少空间占用。  

---

### 推荐题目
1. [P4095 消失的序列](https://www.luogu.com.cn/problem/P4095)  
2. [P5020 货币系统（背包扩展）](https://www.luogu.com.cn/problem/P5020)  
3. [P6567 买表（退背包应用）](https://www.luogu.com.cn/problem/P6567)  

---

### 个人心得摘录
- **King丨帝御威**：强调初始化 `f[0][0]=f[0][1]=1`，正确处理空背包边界。  
- **Treaker**：通过对比 `f[j]` 与 `g[j]` 的差异，明确递推式来源。  
- **keep_**：提醒「+10 防负数」是调试时的关键点，否则仅得 10 分。

---
处理用时：133.17秒
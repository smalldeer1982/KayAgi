# 题目信息

# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# AI分析结果

### 综合分析与结论

本题的核心是通过已知的加密信息和原信息，构建一个字母到字母的映射关系，并利用这个映射关系来解密新的加密信息。难点在于如何高效地处理映射关系，并确保映射的唯一性和完整性。题解中主要使用了 `map` 或数组来存储映射关系，并通过遍历和条件判断来确保映射的正确性。

### 所选高星题解

#### 题解1：CYJian (5星)
**关键亮点**：
- 使用双向 `map` 来存储映射关系，确保映射的唯一性。
- 代码简洁，逻辑清晰，直接通过条件判断来处理错误情况。
- 通过 `book` 变量来记录已使用的字母数量，确保所有字母都被映射。

**核心代码**：
```cpp
map<char,char>mp,mq;
for(int i=0;i<la;i++)
    if(mp[a[i]]==0&&mq[b[i]]==0)
        mp[a[i]]=b[i] , mq[b[i]]=a[i] , book--;
    else if(mp[a[i]]!=b[i]||mq[b[i]]!=a[i])
        ERROR
if(book>0) ERROR
for(int i=0;i<lc;i++) printf("%c",mp[c[i]]);
```

#### 题解2：陈嘉逸2012 (4星)
**关键亮点**：
- 使用 `map` 和 `vis` 数组来记录映射关系和已使用的字母。
- 通过遍历 `A` 到 `Z` 来确保所有字母都被映射。
- 代码结构清晰，逻辑简单易懂。

**核心代码**：
```cpp
map<char,char>mp; map<char,bool>vis;
for(int i=0;i<a.size();i++){
    if(vis[b[i]]&&b[i]!=mp[a[i]]){cout<<"Failed\n";return 0;}
    mp[a[i]]=b[i],vis[b[i]]=1;
}
for(char i='A';i<='Z';i++){
    if(!vis[i]){cout<<"Failed\n";return 0;}
}
for(int i=0;i<c.size();i++) cout<<mp[c[i]];
```

#### 题解3：lianghuahua (4星)
**关键亮点**：
- 使用 `map` 和 `set` 来确保映射的唯一性和完整性。
- 通过 `count` 函数来检查映射是否已经存在，避免重复映射。
- 代码逻辑清晰，处理错误情况的方式简洁明了。

**核心代码**：
```cpp
map<char, char> mp; set<char> st;
for(int i = 0; i < s1.size(); i++){
    if(mp.count(s1[i])) {
        if(mp[s1[i]] != s2[i]) {cout << "Failed"; return 0;}
    }else{
        if(st.count(s2[i])) {cout << "Failed"; return 0;}
        mp[s1[i]] = s2[i]; st.insert(s2[i]);
    }
}
if(mp.size() < 26){cout << "Failed"; return 0;}
for(int i = 0; i < s3.size(); i++){cout << mp[s3[i]];}
```

### 最优关键思路与技巧
- **双向映射**：使用两个 `map` 或数组来确保映射的唯一性和完整性。
- **字母覆盖检查**：通过遍历 `A` 到 `Z` 来确保所有字母都被映射。
- **错误处理**：在发现映射冲突或字母缺失时，立即输出 `Failed` 并结束程序。

### 可拓展之处
- **类似题目**：可以扩展到更复杂的加密解密问题，如多字母映射、动态映射等。
- **算法套路**：类似的问题可以通过构建映射关系来解决，如字符串匹配、编码解码等。

### 推荐题目
1. [P1072 Hankson的趣味题](https://www.luogu.com.cn/problem/P1072)
2. [P1073 最优贸易](https://www.luogu.com.cn/problem/P1073)
3. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)

### 个人心得摘录
- **CYJian**：通过 `book` 变量来记录已使用的字母数量，确保所有字母都被映射，这种方法简洁高效。
- **陈嘉逸2012**：使用 `map` 和 `vis` 数组来记录映射关系和已使用的字母，代码结构清晰，逻辑简单易懂。
- **lianghuahua**：使用 `map` 和 `set` 来确保映射的唯一性和完整性，处理错误情况的方式简洁明了。

---
处理用时：24.45秒
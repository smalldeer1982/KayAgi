# 题目信息

# [NOIP 2004 提高组] 合并果子

## 题目描述

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $=3+12=15$ 。可以证明 $15$ 为最小的体力耗费值。

## 说明/提示

对于 $30\%$ 的数据，保证有 $n \le 1000$：

对于 $50\%$ 的数据，保证有 $n \le 5000$；

对于全部的数据，保证有 $n \le 10000$。


## 样例 #1

### 输入

```
3 
1 2 9 
```

### 输出

```
15
```

# AI分析结果

### 综合分析与结论

本题的核心是贪心算法，通过每次合并最小的两堆果子来最小化总体力消耗。大多数题解都采用了优先队列（小根堆）来实现这一策略，时间复杂度为 \(O(n \log n)\)。部分题解还提供了手写堆的实现，进一步优化了性能。此外，一些题解通过证明或举例说明了贪心策略的正确性，增强了算法的可信度。

### 所选高星题解

#### 1. 作者：微雨燕双飞 (4星)
- **关键亮点**：手写小根堆，代码清晰且高效，提供了堆的完整实现。
- **个人心得**：作者提到手写堆虽然复杂，但性能优于STL的优先队列，适合对性能要求较高的场景。
- **核心代码**：
  ```cpp
  void up(int p) {
      while(p>1) {
          if(heap[p]<heap[p/2]) {
              swap(heap[p],heap[p/2]);
              p/=2;
          } else break;
      }
  }
  void down(int p) {
      int s=p*2;
      while(s<=size) {
          if(s<size&&heap[s+1]<heap[s]) s++;
          if(heap[s]<heap[p]) {
              swap(heap[s],heap[p]);
              p=s; s=p*2;
          } else break;
      }
  }
  ```

#### 2. 作者：学委 (4星)
- **关键亮点**：详细证明了贪心策略的正确性，提供了哈夫曼树的背景知识，增强了算法的理解。
- **个人心得**：作者通过反例和数学推导，证明了每次合并最小两堆果子的最优性。
- **核心代码**：
  ```cpp
  while(q.size() > 1) {
      int x = q.top(); q.pop();
      int y = q.top(); q.pop();
      ans += x + y;
      q.push(x + y);
  }
  ```

#### 3. 作者：sigland (4星)
- **关键亮点**：提供了封装版和拆封版的手写堆实现，性能优化明显，代码简洁。
- **个人心得**：作者提到封装版虽然调用方便，但拆封版性能更优，适合对性能要求极高的场景。
- **核心代码**：
  ```cpp
  void gao(int pos) {
      int flag=heap[pos*2]>=heap[pos*2+1];
      if(heap[pos]>heap[pos*2+flag]){
          swap(heap[pos],heap[pos*2+flag]);
          gao(pos*2+flag);
      }
      return;
  }
  ```

### 最优关键思路与技巧
1. **贪心策略**：每次合并最小的两堆果子，确保总体力消耗最小。
2. **优先队列**：使用小根堆（优先队列）来高效获取最小元素，时间复杂度为 \(O(n \log n)\)。
3. **手写堆**：对于性能要求较高的场景，手写堆可以进一步优化性能。

### 可拓展之处
- **哈夫曼树**：本题可以看作是哈夫曼树的构建过程，类似的问题可以通过哈夫曼树来解决。
- **其他贪心问题**：如任务调度、区间覆盖等问题，也可以采用类似的贪心策略。

### 推荐题目
1. [P1091 合并果子（加强版）](https://www.luogu.com.cn/problem/P1091)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378)

### 个人心得总结
- **手写堆的优势**：虽然实现复杂，但在性能要求高的场景下，手写堆可以显著提升效率。
- **贪心策略的证明**：通过反例和数学推导，可以增强对贪心策略的理解和信心。
- **代码优化**：封装版和拆封版的对比，展示了代码优化对性能的影响。

---
处理用时：25.00秒
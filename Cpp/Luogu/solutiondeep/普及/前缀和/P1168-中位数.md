# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果

### 综合分析与结论

该题目要求动态维护序列的中位数，且序列长度逐渐增加。由于需要频繁插入和查询中位数，直接使用排序或暴力插入的方法会导致时间复杂度过高。因此，大多数题解采用了**对顶堆**或**平衡树**等数据结构来优化时间复杂度。

**对顶堆**是本题的主流解法，通过维护一个大根堆和一个小根堆，分别存储序列的前半部分和后半部分，确保大根堆的堆顶始终是中位数。这种方法的时间复杂度为O(n log n)，空间复杂度为O(n)，能够高效地处理大规模数据。

**平衡树**（如Splay、Treap等）也是一种有效的解法，通过维护一个有序的树结构，能够在O(log n)的时间内完成插入和查询操作。虽然平衡树的实现较为复杂，但其灵活性更高，适用于更广泛的动态维护问题。

### 所选高星题解

#### 1. **题解作者：肖恩Sean**  
**星级：★★★★★**  
**关键亮点：**
- 使用对顶堆（大根堆和小根堆）维护中位数，思路清晰，代码简洁。
- 通过插入时动态调整堆的大小，确保中位数的正确性。
- 代码实现高效，时间复杂度为O(n log n)，适合大规模数据。

**核心代码：**
```cpp
priority_queue<int, vector<int> > q1; // 大根堆
priority_queue<int, vector<int>, greater<int> > q2; // 小根堆

int main() {
    int n = read();
    q1.push(read());
    cout << q1.top() << endl; 
    for (int i = 2; i <= n; i++) {
        int input = read();
        if (input > q1.top()) q2.push(input);
        else q1.push(input);
        while (abs(q1.size() - q2.size()) > 1) {
            if (q1.size() > q2.size()) { q2.push(q1.top()); q1.pop(); }
            else { q1.push(q2.top()); q2.pop(); }
        }
        if (i % 2) cout << (q1.size() > q2.size() ? q1.top() : q2.top()) << endl;
    }
    return 0;
}
```
**核心思想：** 通过维护两个堆，确保大根堆的堆顶始终是中位数，插入时动态调整堆的大小。

#### 2. **题解作者：IRipple**  
**星级：★★★★☆**  
**关键亮点：**
- 使用对顶堆维护中位数，思路清晰，代码实现简洁。
- 通过插入时动态调整堆的大小，确保中位数的正确性。
- 代码实现高效，时间复杂度为O(n log n)，适合大规模数据。

**核心代码：**
```cpp
priority_queue<int> q1; // 大根堆
priority_queue<int, vector<int>, greater<int> > q2; // 小根堆

int main() {
    int n, mid;
    cin >> n;
    cin >> mid;
    q1.push(mid);
    cout << mid << endl;
    for (int i = 2; i <= n; i++) {
        int x; cin >> x;
        if (x > mid) q2.push(x);
        else q1.push(x);
        if (i % 2 == 1) {
            while (q1.size() != q2.size()) {
                if (q1.size() > q2.size()) { q2.push(mid); mid = q1.top(); q1.pop(); }
                else { q1.push(mid); mid = q2.top(); q2.pop(); }
            }
            cout << mid << endl;
        }
    }
    return 0;
}
```
**核心思想：** 通过维护两个堆，确保中位数的正确性，插入时动态调整堆的大小。

#### 3. **题解作者：Capella**  
**星级：★★★★☆**  
**关键亮点：**
- 使用Treap平衡树维护中位数，实现灵活且高效。
- 通过插入和查询操作，确保中位数的正确性。
- 代码实现较为复杂，但时间复杂度为O(n log n)，适合大规模数据。

**核心代码：**
```cpp
void insert(Node* &o, int x) {
    if (o == NULL) {
        o = new Node(x, rand(), NULL, NULL);
        return;
    }
    if (x == o -> v) { o -> cnt++; return; }
    if (x < o -> v) {
        insert(o -> l, x);
        if (o -> l -> p > o -> p) rotate(o, 1);
    } else {
        insert(o -> r, x);
        if (o -> r -> p > o -> p) rotate(o, 0);
    }
    update(o);
}

int kth(Node* o, int k) {
    if (o -> l -> s >= k) return kth(o -> l, k);
    if (o -> l -> s + o -> cnt >= k) return o -> v;
    return kth(o -> r, k - o -> l -> s - o -> cnt);
}
```
**核心思想：** 通过Treap平衡树维护有序序列，插入和查询操作的时间复杂度均为O(log n)。

### 最优关键思路与技巧

1. **对顶堆**：通过维护一个大根堆和一个小根堆，确保大根堆的堆顶始终是中位数。插入时动态调整堆的大小，确保两个堆的大小差不超过1。
2. **平衡树**：通过维护一个有序的树结构，能够在O(log n)的时间内完成插入和查询操作，适合更复杂的动态维护问题。

### 可拓展之处

1. **动态维护其他统计量**：如最大值、最小值、第k大数等，可以使用类似的数据结构（如堆、平衡树）进行维护。
2. **区间查询**：如果需要查询某个区间的中位数，可以使用主席树或线段树等数据结构进行维护。

### 推荐题目

1. **P1801 黑匣子**：动态维护第k大数，与本题类似。
2. **P3834 可持久化线段树**：动态维护区间第k大数，适合更复杂的查询需求。
3. **P3369 普通平衡树**：动态维护有序序列，适合练习平衡树的实现。

### 个人心得摘录

- **调试经历**：在实现对顶堆时，需要注意堆的大小调整，确保中位数的正确性。调试时可以通过打印堆的内容来验证算法的正确性。
- **踩坑教训**：在实现平衡树时，旋转操作容易出错，需要仔细检查旋转后的树结构是否正确。
- **顿悟感想**：通过维护两个堆，可以高效地动态维护中位数，这种思路可以推广到其他动态维护问题中。

---
处理用时：48.91秒
# 题目信息

# 切蛋糕

## 题目描述

今天是小 Z 的生日，同学们为他带来了一块蛋糕。这块蛋糕是一个长方体，被用不同色彩分成了 $n$ 个相同的小块，每小块都有对应的幸运值。

小 Z 作为寿星，自然希望吃到的蛋糕的幸运值总和最大，但小 Z 最多又只能吃 $m(m\le n)$ 小块的蛋糕。

请你帮他从这 $n$ 小块中找出**连续**的 $k(1 \le k\le m)$ 块蛋糕，使得其上的总幸运值最大。

**形式化地**，在数列 $\{p_n\}$ 中，找出一个子段 $[l,r](r-l+1\le m)$，最大化 $\sum\limits_{i=l}^rp_i$。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，有 $1\le n\le100$。
- 对于 $100\%$ 的数据，有 $1\le n\le5\times 10^5$，$|p_i|≤500$。

保证答案的绝对值在 $[0,2^{31}-1]$ 之内。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5```

### 输出

```
9```

## 样例 #2

### 输入

```
6 3
1 -2 3 -4 5 -6```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心是求一个长度不超过 \(m\) 的最大子段和，属于经典的滑动窗口问题。大多数题解都采用了**前缀和**结合**单调队列**的优化思路，将时间复杂度从 \(O(nm)\) 降低到 \(O(n)\)。部分题解还提到了其他数据结构（如线段树、ST表、multiset等），但单调队列是最优解，因为它既高效又易于实现。

### 所选高星题解

#### 1. 作者：fanfansann (★★★★★)
**关键亮点**：
- 使用单调队列维护前缀和的最小值，确保每次都能快速找到最优解。
- 强调了单调队列的初始化和边界处理，避免了常见错误。
- 代码简洁且高效，适合初学者理解和应用。

**核心代码**：
```cpp
deque<int>q;
q.push_back(0); // 初始化
for(int i=1;i<=n;i++) {
    while(q.front()+m<i) q.pop_front(); // 越界处理
    ans=max(ans,sum[i]-sum[q.front()]); // 更新答案
    while(!q.empty()&&sum[q.back()]>=sum[i]) q.pop_back(); // 维护单调性
    q.push_back(i);
}
```
**个人心得**：
- 强调了单调队列的初始化和边界处理，避免了常见错误。

#### 2. 作者：kkksc03 (★★★★☆)
**关键亮点**：
- 详细解释了单调队列的原理和优化思路，适合深入理解。
- 提供了朴素写法的分析，帮助读者理解优化过程。
- 代码结构清晰，注释详细。

**核心代码**：
```cpp
int head=1,tail=1,ans=-INF;q[1]=0;
for(int i=1;i<=n;i++) {
    while(head<=tail&&q[head]<i-m) head++; // 排除过期决策
    ans=max(ans,sum[i]-sum[q[head]]); // 更新答案
    while(head<=tail&&sum[i]<=sum[q[tail]]) tail--; // 维护单调性
    q[++tail]=i;
}
```
**个人心得**：
- 强调了单调队列的维护过程，帮助读者理解如何排除无用决策。

#### 3. 作者：fluttersunny (★★★★☆)
**关键亮点**：
- 提供了多种数据结构的解决方案（如线段树、ST表等），拓宽了思路。
- 代码简洁，注释清晰，适合快速上手。

**核心代码**：
```cpp
int head=1,tail=1,ans=-INF;q[1]=0;
for(int i=1;i<=n;i++) {
    while(head<=tail&&q[head]<i-m) head++; // 排除过期决策
    ans=max(ans,sum[i]-sum[q[head]]); // 更新答案
    while(head<=tail&&sum[i]<=sum[q[tail]]) tail--; // 维护单调性
    q[++tail]=i;
}
```
**个人心得**：
- 强调了单调队列的维护过程，帮助读者理解如何排除无用决策。

### 最优关键思路与技巧
1. **前缀和**：通过预处理前缀和，快速计算任意子段和。
2. **单调队列**：维护一个单调递增的队列，确保每次都能快速找到区间内的最小前缀和。
3. **滑动窗口**：通过滑动窗口的方式，动态维护当前窗口内的最优解。

### 可拓展之处
- **类似问题**：最大子段和、最小子段和、滑动窗口最大值等问题都可以采用类似的思路。
- **数据结构**：单调队列可以扩展到其他需要维护区间最值的场景，如滑动窗口中的最大值、最小值等。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.org/problem/P1886)
2. [P2627 修剪草坪](https://www.luogu.org/problem/P2627)
3. [P1440 求m区间内的最小值](https://www.luogu.org/problem/P1440)

### 个人心得总结
- **初始化与边界处理**：单调队列的初始化和边界处理是关键，避免出现越界或无效决策。
- **维护单调性**：在插入新元素时，及时排除无用决策，确保队列的单调性。
- **多数据结构选择**：虽然单调队列是最优解，但了解其他数据结构（如线段树、ST表等）也有助于拓宽思路。

---
处理用时：28.80秒
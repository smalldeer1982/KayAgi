# 题目信息

# 宝石串

## 题目描述

有一种宝石串，由绿宝石和红宝石串成，仅当绿宝石和红宝石数目相同的时候，宝石串才最为稳定，不易断裂。安安想知道从给定的宝石串中，可以截取一段最长的稳定的宝石串，有多少颗宝石组成。请你帮助他。

绿宝石用 $\texttt G$ 表示，红宝石用 $\texttt R$ 表示。


## 说明/提示

$\texttt {RGGR}$ 为答案。

宝石数小于等于 $10^6$。


## 样例 #1

### 输入

```
GRGGRG```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

本题的核心是找到宝石串中最长的子串，使得绿宝石和红宝石的数量相等。大多数题解采用了前缀和的思想，通过将绿宝石和红宝石分别赋值为-1和1，计算前缀和，然后利用哈希表或数组记录每个前缀和首次出现的位置，最终通过比较相同前缀和的位置差来找到最长的稳定子串。

### 所选高星题解

#### 1. 作者：在想Peach (赞：60)
- **星级**：5星
- **关键亮点**：代码简洁，思路清晰，通过前缀和和哈希表的结合，高效地解决了问题。特别处理了负数溢出的情况，确保了算法的鲁棒性。
- **核心代码**：
  ```cpp
  int ans,p[2000005],last=1000000;
  for(int i=1;i<=s.length();i++){
      if(s[i-1]=='R')last++;
      else last--;
      if(!p[last])p[last]=i;
      else ans=max(ans,i-p[last]);
      if(last==1000000)ans=i;
  }
  ```
- **核心思想**：通过前缀和记录绿宝石和红宝石的数量差，利用哈希表记录每个差值首次出现的位置，最终通过比较相同差值的位置差来找到最长的稳定子串。

#### 2. 作者：MloVtry (赞：39)
- **星级**：4.5星
- **关键亮点**：详细解释了前缀和的思想，并通过维护一个最小值数组来记录每个前缀和首次出现的位置，确保了算法的正确性和高效性。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;++i){
      f[i]+=f[i-1];
      num[f[i]+n+1]=min(i,num[f[i]+n+1]);
      ans=max(ans,i-num[f[i]+n+1]);
  }
  ```
- **核心思想**：通过前缀和记录绿宝石和红宝石的数量差，利用数组记录每个差值首次出现的位置，最终通过比较相同差值的位置差来找到最长的稳定子串。

#### 3. 作者：altar (赞：16)
- **星级**：4星
- **关键亮点**：代码简洁，思路清晰，通过前缀和和哈希表的结合，高效地解决了问题。特别处理了负数溢出的情况，确保了算法的鲁棒性。
- **核心代码**：
  ```cpp
  for(int i=1;i<=l;i++){
      sum[i]=sum[i-1]+(a[i]=='R'?1:-1);
      if(!bo[sum[i]+1000001]&&sum[i])bo[sum[i]+1000001]=i;
      else ans=max(ans,i-bo[sum[i]+1000001]);
  }
  ```
- **核心思想**：通过前缀和记录绿宝石和红宝石的数量差，利用哈希表记录每个差值首次出现的位置，最终通过比较相同差值的位置差来找到最长的稳定子串。

### 最优关键思路与技巧

1. **前缀和与哈希表结合**：通过前缀和记录绿宝石和红宝石的数量差，利用哈希表或数组记录每个差值首次出现的位置，最终通过比较相同差值的位置差来找到最长的稳定子串。
2. **负数溢出处理**：在处理前缀和时，由于差值可能为负数，通过加上一个常数（如1000000）来避免负数溢出问题，确保算法的正确性。

### 可拓展之处

1. **类似问题**：可以扩展到其他需要统计子串中某种属性相等的问题，如字符频率相等、数字和相等等。
2. **优化思路**：可以考虑使用滑动窗口或双指针等优化方法，进一步减少时间复杂度。

### 推荐题目

1. **P1047 连续子数组的最大和**：考察前缀和的应用。
2. **P1218 最长回文子串**：考察字符串处理与动态规划。
3. **P1886 滑动窗口的最大值**：考察滑动窗口与单调队列的应用。

### 个人心得摘录

- **在想Peach**：通过前缀和的思想，同位差相等那么这段区间的差就相等，所以记录一个差的最早出现位置就行，注意负数溢出，加上一个常数便可。
- **MloVtry**：为了让其长度最长，可以维护一个最小值num[i]表示i这个值第一次出现在什么地方。
- **altar**：这里的if里面第一个要求!bo[sum[i]]就是说看bo数组里面是不是零，是零才可以赋值。

---
处理用时：26.82秒
# 题目信息

# [USACO13JAN] Party Invitations S

## 题目描述

农夫约翰要举办一个聚会，他要邀请一些奶牛来参加。在约翰的奶牛朋友圈中，有一些奶牛是好基友，对于每一个奶牛朋友圈，没有一个完全与之相同的，假设这个奶牛朋友圈有 $k$ 头奶牛，如果约翰已经邀请了 $k-1$ 头，那么剩下的那头牛也得邀请。约翰想让你告诉他，他最少需要邀请多少头奶牛？我们假设 $1$ 号奶牛已经被邀请了。

## 说明/提示

$1 \leq  N\leq1000000$。

设所有的奶牛朋友圈的大小之和为 $M$，则 $1 \leq  M\leq250000$。

## 样例 #1

### 输入

```
10 4 
2 1 3 
2 3 4 
6 1 2 3 4 6 7 
4 4 3 2 1 
```

### 输出

```
4 
```

# AI分析结果

### 综合分析与结论

本题的核心在于处理奶牛朋友圈的依赖关系，要求在最少的邀请次数下满足所有朋友圈的邀请条件。题解中主要采用了以下几种思路：

1. **线性存储与暴力模拟**：通过线性存储奶牛和朋友圈的信息，暴力模拟邀请过程，直到没有新的奶牛被邀请。
2. **前缀和与分块处理**：利用前缀和数组记录每组奶牛的位置，分块处理每组的邀请条件。
3. **拓扑排序**：将奶牛和朋友圈的关系转化为图，通过拓扑排序处理依赖关系。
4. **集合与队列结合**：使用集合维护每组奶牛的状态，结合队列处理邀请过程。

这些思路各有优劣，线性存储和暴力模拟虽然简单，但在大数据量下可能效率较低；前缀和与分块处理优化了空间复杂度，但实现较为复杂；拓扑排序和集合结合的方法在时间和空间复杂度上表现较好，但实现难度较高。

### 所选高星题解

#### 1. 作者：曹老师 (5星)
**关键亮点**：
- 使用`vector`、`set`、`queue`等容器，代码结构清晰，逻辑严谨。
- 通过`set`维护每组奶牛的状态，结合`queue`处理邀请过程，优化了时间复杂度。
- 代码可读性强，注释详细，易于理解。

**核心代码**：
```cpp
while(!q.empty()) {
    int now = q.front();
    q.pop();
    ans++;
    for(int i=0; i<about[now].size(); i++) {
        s[about[now][i]].erase(now);
        if(s[about[now][i]].size() == 1 && !vis[*s[about[now][i]].begin()]) {
            int t = *s[about[now][i]].begin();
            q.push(t);
            vis[t] = 1;
        }
    }
}
```
**实现思想**：通过`queue`处理被邀请的奶牛，每次从队列中取出奶牛，更新相关朋友圈的状态，如果某个朋友圈只剩下一头奶牛未被邀请，则将其加入队列。

#### 2. 作者：不便透露 (4星)
**关键亮点**：
- 使用拓扑排序处理奶牛和朋友圈的依赖关系，思路新颖。
- 通过`vector`和`queue`结合，优化了空间和时间复杂度。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
while(!q.empty()) {
    while(!q.empty()) {
        k = q.front();
        q.pop();
        for(i=0; i<G[k].size(); i++) {
            u = G[k][i];
            in[u]--;
            if(in[u]==1) {
                Push(u);
            }
        }
    }
    q = p;
    while(!p.empty())
        p.pop();
}
```
**实现思想**：通过`queue`处理被邀请的奶牛，每次从队列中取出奶牛，更新相关朋友圈的状态，如果某个朋友圈只剩下一头奶牛未被邀请，则将其加入队列。

#### 3. 作者：xiaozeyu (4星)
**关键亮点**：
- 利用前缀和数组记录每组奶牛的位置，分块处理每组的邀请条件。
- 通过循环处理邀请过程，直到没有新的奶牛被邀请。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
while(1) {
    int k = ans;
    for(int i=1; i<=g; i++) {
        int q, s = 0;
        for(int j=sum[i-1]+1; j<=sum[i]; j++) {
            if(f[a[j]])
                s++;
            else 
                q = a[j];
        }    
        if(t[i]-s == 1) {
            f[q] = 1;
            ans++;
        }
    }
    if(k == ans) {
        cout << ans;
        return 0;
    }
}
```
**实现思想**：通过前缀和数组分块处理每组的邀请条件，每次循环检查每组是否满足邀请条件，如果满足则邀请最后一头奶牛。

### 最优关键思路与技巧

1. **集合与队列结合**：使用集合维护每组奶牛的状态，结合队列处理邀请过程，优化了时间复杂度。
2. **拓扑排序**：将奶牛和朋友圈的关系转化为图，通过拓扑排序处理依赖关系，优化了空间和时间复杂度。
3. **前缀和与分块处理**：利用前缀和数组记录每组奶牛的位置，分块处理每组的邀请条件，优化了空间复杂度。

### 可拓展之处

- **类似算法套路**：处理依赖关系的问题，如拓扑排序、集合与队列结合等，可以应用于其他类似的题目。
- **同类型题目**：如[P3243 菜肴制作](https://www.luogu.com.cn/problem/P3243)、[P3068 Party Invitations](https://www.luogu.com.cn/problem/P3068)、[P3119 [USACO15JAN]Grass Cownoisseur G](https://www.luogu.com.cn/problem/P3119)。

### 推荐题目

1. [P3243 菜肴制作](https://www.luogu.com.cn/problem/P3243)
2. [P3119 [USACO15JAN]Grass Cownoisseur G](https://www.luogu.com.cn/problem/P3119)
3. [P3068 Party Invitations](https://www.luogu.com.cn/problem/P3068)

---
处理用时：33.38秒
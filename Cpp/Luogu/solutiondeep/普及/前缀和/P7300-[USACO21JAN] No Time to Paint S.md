# 题目信息

# [USACO21JAN] No Time to Paint S

## 题目描述

Bessie 最近收到了一套颜料，她想要给她的牧草地一端的栅栏上色。栅栏由 $N$ 个 1 米长的小段组成（$1≤N≤10^5$）。Bessie 可以使用 26 种不同的颜色，她将这些颜色由浅到深用字母 'A' 到 'Z' 标号（'A' 是很浅的颜色，'Z' 是很深的颜色）。从而她可以用一个长为 $N$ 且每个字符均为字母的字符串来描述她想要给栅栏的每一小段涂上的颜色。 

初始时，所有栅栏小段均未被上色。Bessie 一笔可以给任意连续若干小段涂上同一种颜色，只要她不会在较深的颜色之上涂上较浅的颜色（她只能用较深的颜色覆盖较浅的颜色）。 

例如，一段长为 4 的未被涂色的栅栏可以按如下方式上色：

`.... -> BBB. -> BBLL -> BQQL`

由于时间紧迫，Bessie 认为她可能需要放弃为栅栏上某个连续的区间上色！现在，她正在考虑 $Q$ 个候选的区间（$1≤Q≤10^5$），每个区间用满足 $1≤a≤b≤N$ 的两个整数 $(a,b)$ 表示，为需要不上色的小段 $a…b$ 的两端点位置。 

对于每个候选区间，将所有区间外的栅栏小段都涂上所希望的颜色，并且区间内的栅栏小段均不涂色，最少需要涂多少笔？注意在这个过程中 Bessie 并没有真正进行任何的涂色，所以对于每个候选区间的回答是独立的。 

## 说明/提示

在这个样例种，除去目标颜色 `BAAB` 所对应的区间，涂上颜色需要四笔，而除去 `ABBA` 仅需三笔。

`.... -> AA.. -> ABBB -> ABCB`

#### 测试点性质：

 - 测试点 1-4 满足 $N,Q≤100$。
 - 测试点 5-7 满足 $N,Q≤5000$。
 - 测试点 8-13 没有额外限制。

供题：Andi Qu，Brian Dean 

## 样例 #1

### 输入

```
8 2
ABBAABCB
3 6
1 4```

### 输出

```
4
3```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地计算去掉某个区间后，剩余部分的最小涂色次数。大多数题解都采用了预处理前缀和后缀的思路，通过维护一个标记数组来记录颜色是否出现过，并在遍历时动态更新。优化后的算法时间复杂度为O(n)，能够处理最大数据规模。

### 所选高分题解

#### 1. 作者：Skies (5星)
- **关键亮点**：思路清晰，代码简洁，通过预处理前缀和后缀数组，实现了O(1)的查询复杂度。使用标记数组动态维护颜色是否出现过，并在遍历时更新。
- **个人心得**：作者提到在比赛中误入分治算法，浪费了时间，最终通过倒序前缀和的思路解决了问题。强调了全局变量和局部变量不要重名，避免调试时的麻烦。

```cpp
for(int i=1;i<=n;i++) {
    ans1[i]=ans1[i-1];
    if(!v[a[i]-'A']) {
        ans1[i]++;
        v[a[i]-'A']=1;
    }
    for(int j=a[i]-'A'+1;j<26;j++) v[j]=0;
}
```

#### 2. 作者：JiaY19 (4星)
- **关键亮点**：思路明确，代码简洁，通过两次遍历分别维护前缀和后缀数组。使用标记数组记录颜色是否出现过，并在遍历时动态更新。
- **个人心得**：作者强调了在遍历时，如果当前颜色比之前颜色浅，则需要清除比它深的颜色的标记，确保涂色规则的正确性。

```cpp
for(int i = 1;i <= n;i++) {
    f[i] = f[i - 1];
    for(int j = a[i] - 'A' + 1;j < 26;j++) v[j] = 0;
    if(v[a[i] - 'A'] == 0) v[a[i] - 'A'] = 1 , f[i] += 1;
}
```

#### 3. 作者：Lonely_NewYear (4星)
- **关键亮点**：通过单调栈维护前缀和后缀数组，实现了O(n)的预处理复杂度。使用单调栈动态维护颜色是否出现过，并在遍历时更新。
- **个人心得**：作者提到在遍历时，如果栈顶颜色比当前颜色深，则需要退栈，确保涂色规则的正确性。

```cpp
for(int i=1;i<=n;i++) {
    while(top&&str[i]<s[top]) top--;
    pre[i]=pre[i-1]+(s[top]!=str[i]);
    s[++top]=str[i];
}
```

### 最优关键思路与技巧

1. **预处理前缀和后缀数组**：通过预处理前缀和后缀数组，可以在O(1)时间内回答每个查询。
2. **动态维护标记数组**：在遍历时动态维护一个标记数组，记录颜色是否出现过，确保涂色规则的正确性。
3. **单调栈优化**：使用单调栈动态维护颜色是否出现过，并在遍历时更新，确保涂色规则的正确性。

### 可拓展之处

1. **类似算法套路**：这类问题通常可以通过预处理前缀和后缀数组，结合动态维护标记数组或单调栈来解决。类似的问题包括区间查询、动态维护最小值等。
2. **同类型题目**：可以参考类似的区间查询问题，如线段树、树状数组等数据结构的应用。

### 推荐题目

1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)
3. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)

---
处理用时：24.58秒
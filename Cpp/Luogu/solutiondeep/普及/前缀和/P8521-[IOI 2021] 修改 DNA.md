# 题目信息

# [IOI 2021] 修改 DNA

## 题目背景

**滥用本题评测将被封号**

**由于技术限制，请不要使用 C++ 14 (GCC 9) 语言提交本题。**

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数

## 题目描述

Grace 是一名生物学家，在新加坡的一个生物信息学公司工作。她的一部分工作是分析不同有机体的 DNA 序列。DNA 序列是包含字符 A、T 和 C 的字符串。注意在本题中，DNA 序列不包含字符 G。

定义一次修改是把 DNA 序列中的两个元素交换位置的操作。例如，通过交换加粗的字符 A 和 C，一次修改可以把 A**C**T**A** 转化为 A**A**T**C**。

两个序列的修改距离是把一个序列转化为另一个序列所用的最少修改次数。如果不能通过修改把一个序列转化为另一个序列，那么这两个序列的修改距离为 $-1$。

Grace 正在分析两个 DNA 序列 $a$ 和 $b$，每个都由 n 个元素组成，下标从 $0$ 到 $n - 1$。你的任务是帮助 Grace 回答以下形式的 $q$ 个问题：子串 $a[x \ldots y]$ 和 $b[x \ldots y]$ 的修改距离是多少？这里，DNA 序列 $s$ 的子串 $s[x \ldots y]$ 定义为 $s$ 的下标从 $x$ 到 $y$（包括 x 和 y）的连续字符序列。也就是说，$s[x \ldots y]$ 是序列 $s[x] s[x + 1] \ldots s[y]$。

## 说明/提示

对于所有数据：

- $1 \le n, q \le 100 \, 000$
- $0 \le x \le y \le n - 1$
- $a$ 和 $b$ 的每个字符都是 A、T 和 C 之⼀

子任务|分值|特殊限制
:-:|:-:|:-:
$1$	|$21$|$y - x \le 2$
$2$	|$22$|	$q \le 500$，$y - x \le 1000$，$a$ 和 $b$ 的每个字符是 A 或 T
$3$	|$13$|	$a$ 和 $b$ 的每个字符是 A 或 T
$4$	|$28$|	$q \le 500$，$y - x \le 1000$
$5$	|$16$|	没有额外的约束条件

## 样例解释

如果评测程序调用 `get_distance(1, 3)`，那么该调用应返回 $a[1 \ldots 3]$ 和 $b[1 \ldots 3]$（也就是序列 TAC 和 CTA）之间的修改距离。通过 $2$ 次修改可以把 TAC 转化为 CTA：TAC $\to$ CAT，然后是 CAT $\to$ CTA。无法通过比 $2$ 次更少的修改完成该转化。

因此，该调用应返回 $2$。

如果评测程序调用 `get_distance(4, 5)`，那么该调用应返回序列 AT 和 TA 之间的修改距离。 通过一次修改可以把 AT 转化为 TA，而且显然至少需要一次。

因此，该调用应返回 $1$。

最后，如果评测程序调用 `get_distance(3, 5)`，由于无法通过修改将序列 CAT 转化为 ATA，因此该调用应返回 $-1$。

## 样例 #1

### 输入

```
6 3
ATACAT
ACTATA
1 3
4 5
3 5```

### 输出

```
2
1
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于通过交换操作计算两个DNA子串的修改距离。所有题解都采用了前缀和的思想来预处理数据，并在查询时通过矩阵运算来计算修改次数。主要思路包括：

1. **前缀和预处理**：通过前缀和数组记录每个字符的出现次数和转换需求，方便快速查询任意子串的修改矩阵。
2. **两两交换优先**：优先处理可以通过两两交换解决的字符对，减少修改次数。
3. **三轮换处理**：对于无法通过两两交换解决的字符，通过三轮换的方式进行处理，每次三轮换需要2次交换。

### 所选高星题解

#### 1. 作者：wangbinfeng (★★★★★)
- **关键亮点**：
  - 详细分析了每个子任务的解法，思路清晰。
  - 代码结构简洁，使用了前缀和和矩阵运算，时间复杂度为O(n+q)。
  - 提供了无解情况的判断和修改次数的计算。
- **核心代码**：
  ```cpp
  void init(string a,string b){
      n=a.size();
      for(int k=1;k<=n;k++){ 
          for(int i=0;i<3;i++)for(int j=0;j<3;j++)sum[k][i][j]=sum[k-1][i][j];
          sum[k][bm(a[k-1])][bm(b[k-1])]++;
      }
  }
  int get_distance(int x,int y){
      int s[3][3],ret=0,t;
      for(int i=0;i<3;i++)for(int j=0;j<3;j++)s[i][j]=sum[y+1][i][j]-sum[x][i][j];
      for(int i=0;i<3;i++)for(int j=i+1;j<3;j++)
          t=min(s[i][j],s[j][i]),ret+=t,s[i][j]-=t,s[j][i]-=t; 
      if(s[0][1]!=s[1][2] or s[1][2]!=s[2][0] or s[1][0]!=s[2][1] or s[2][1]!=s[0][2])return -1;
      return ret+2*(s[0][1]+s[1][0]);
  }
  ```

#### 2. 作者：Vct14 (★★★★☆)
- **关键亮点**：
  - 详细解释了矩阵运算的思路，特别是两两交换和三轮换的处理。
  - 代码实现清晰，使用了前缀和和矩阵运算，时间复杂度为O(n+q)。
- **核心代码**：
  ```cpp
  void init(string a,string b) {
      int len=a.length();
      For(k,1,len){
          F(i) F(j) S[k][i][j]=S[k-1][i][j];
          S[k][change(a[k-1])][change(b[k-1])]++;
      }
  }
  int get_distance(int x,int y){
      int ans=0;
      F(i) F(j) s[i][j]=S[y+1][i][j]-S[x][i][j];
      F(i){
          For(j,i+1,3){
              int m=min(s[i][j],s[j][i]);
              ans+=m;s[i][j]-=m;s[j][i]-=m;
          }
      }
      if(s[0][1]!=s[1][2] || s[1][2]!=s[2][0] || s[1][0]!=s[2][1] || s[2][1]!=s[0][2]) return -1; 
      if(s[0][1]!=0) return ans+2*s[0][1];
      else return ans+2*s[1][0];
  }
  ```

#### 3. 作者：CodingOIer (★★★★☆)
- **关键亮点**：
  - 提供了无解情况的判断和修改次数的计算。
  - 代码实现简洁，使用了前缀和和矩阵运算，时间复杂度为O(n+q)。
- **核心代码**：
  ```cpp
  void init(std::string _a, std::string _b){
      int l = _a.size();
      _a = " " + _a;
      _b = " " + _b;
      for (int i = 1; i <= l; i++){
          a[i] = _a[i] == 'A' ? 1 : _a[i] == 'T' ? 2 : 3;
          b[i] = _b[i] == 'A' ? 1 : _b[i] == 'T' ? 2 : 3;
          for (int x = 1; x <= 3; x++){
              sa[i][x] = sa[i - 1][x];
              sb[i][x] = sb[i - 1][x];
              for (int y = 1; y <= 3; y++){
                  sc[i][x][y] = sc[i - 1][x][y];
              }
          }
          sa[i][a[i]]++;
          sb[i][b[i]]++;
          if (a[i] != b[i]){
              sc[i][a[i]][b[i]]++;
          }
      }
  }
  int get_distance(int l, int r){
      l++;
      r++;
      for (int x = 1; x <= 3; x++){
          if (sa[r][x] - sa[l - 1][x] != sb[r][x] - sb[l - 1][x]){
              return -1;
          }
      }
      for (int x = 1; x <= 3; x++){
          for (int y = 1; y <= 3; y++){
              s[x][y] = sc[r][x][y] - sc[l - 1][x][y];
          }
      }
      int res = 0;
      for (int x = 1; x <= 3; x++){
          for (int y = 1; y <= x - 1; y++){
              int l = std::min(s[x][y], s[y][x]);
              res += l;
              s[x][y] -= l;
              s[y][x] -= l;
          }
      }
      int k = 0;
      for (int x = 1; x <= 3; x++){
          for (int y = 1; y <= 3; y++){
              k += s[x][y];
          }
      }
      return res + k / 3 * 2;
  }
  ```

### 最优关键思路与技巧

1. **前缀和预处理**：通过前缀和数组记录每个字符的出现次数和转换需求，方便快速查询任意子串的修改矩阵。
2. **两两交换优先**：优先处理可以通过两两交换解决的字符对，减少修改次数。
3. **三轮换处理**：对于无法通过两两交换解决的字符，通过三轮换的方式进行处理，每次三轮换需要2次交换。

### 可拓展之处

- **类似题目**：可以扩展到其他字符转换问题，如字母重排、字符串匹配等。
- **算法优化**：可以考虑使用更高效的数据结构或算法来进一步优化时间复杂度。

### 推荐相似题目

1. [P1216 [USACO1.5]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得摘录

- **调试经历**：在实现过程中，需要注意前缀和数组的下标从1开始，以避免边界问题。
- **踩坑教训**：在处理无解情况时，需要仔细检查字符出现次数是否相等。
- **顿悟感想**：通过矩阵运算和前缀和的结合，可以高效地解决字符转换问题。

---
处理用时：47.21秒
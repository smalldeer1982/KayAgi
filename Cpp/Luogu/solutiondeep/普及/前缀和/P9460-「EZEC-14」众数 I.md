# 题目信息

# 「EZEC-14」众数 I

## 题目背景

pigstd 是一个可爱的男孩子。他在 NOI2022 中的众数一题定义了 $10^6$ 个 ``std::deque`` 并没有 MLE。

## 题目描述

给定一个长度为 $n$ 的序列 $a$，我们通过以下方式构造序列 $b$：

- 初始时 $b=a$。
- 依次对 $b$ 进行 $k$ 次操作，每次操作选择任意一个元素并将其**修改**为任意整数。

dXqwq 定义一个序列的**众数**为所有出现次数最大的数。例如 $[1,1,4,5,1,4]$ 的众数为 $1$，而 $[1,14,5,14,19,19,8,10]$ 的众数为 $14,19$。

你需要求出有多少整数可能成为 $b$ 的**众数**。

## 说明/提示

**【样例解释】**

对于第一组数据，最终 $1,2,3,4,5$ 可能为区间众数。

对于第二组数据，将第一个数换成 $6,7,8,9,\cdots$ 后它们均会成为区间众数，因此答案为正无穷。

对于第三组数据，$1,2,3$ 可能成为区间众数。

**【提示】**

开 $10^6$ 个 ``std::deque`` 在空间限制为 1024MB 时不一定会 MLE。

**【数据范围】**

**本题采用捆绑测试。**

* Subtask 1（20 pts）：$n\leq 5$。
* Subtask 2（20 pts）：$n\leq 10^3$。
* Subtask 3（20 pts）：$k=0$。
* Subtask 4（20 pts）：$k=1$。
* Subtask 5（20 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$0\leq k\leq n $，$1\leq a_i\leq n$。

## 样例 #1

### 输入

```
5 0
1 2 3 4 5```

### 输出

```
5```

## 样例 #2

### 输入

```
5 1
1 2 3 4 5```

### 输出

```
pigstd```

## 样例 #3

### 输入

```
5 1
1 1 2 2 3```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心在于通过修改序列中的元素，使得某些数成为众数。题解中主要采用了以下几种思路：

1. **二分查找**：通过二分查找确定众数的出现次数，结合贪心策略进行优化。
2. **优先队列（堆）**：利用优先队列动态维护众数的出现次数，通过每次操作减少最大出现次数，确保众数的条件。
3. **前缀和与排序**：通过排序和前缀和快速计算需要修改的次数，判断某个数是否能成为众数。

大多数题解的时间复杂度为 \(O(n \log n)\)，能够通过 \(10^6\) 的数据规模。部分题解还考虑了特殊情况（如 \(k \geq \text{最大出现次数}\) 时输出 `pigstd`）。

### 所选高星题解

#### 1. **作者：dead_X (5星)**
- **关键亮点**：通过前缀和快速计算需要修改的次数，时间复杂度为 \(O(n)\)，效率极高。思路清晰，代码简洁。
- **核心代码**：
  ```cpp
  for(int i=1; i<=n; ++i) ++a[c[i]];
  for(int i=n+k,c=0,s=0; i>=k; --i) {
      s+=c,c+=a[i];
      if(s>k) printf("%d\n",ans),exit(0);
      ans+=a[i-k];
  }
  ```
  **实现思想**：通过前缀和计算每个数的出现次数，判断是否满足众数条件。

#### 2. **作者：ZeroF (4星)**
- **关键亮点**：使用优先队列动态维护众数的出现次数，通过每次操作减少最大出现次数，确保众数的条件。思路清晰，代码可读性强。
- **核心代码**：
  ```cpp
  while(k--){
      int tmp=q.top()-1;
      q.pop();
      q.push(tmp);
  }
  int ww=q.top(),ans=0;
  ```
  **实现思想**：通过优先队列维护众数的出现次数，每次操作减少最大出现次数，确保众数条件。

#### 3. **作者：GaoKui (4星)**
- **关键亮点**：通过贪心策略和优先队列结合，动态调整众数的出现次数，确保众数条件。思路清晰，代码结构合理。
- **核心代码**：
  ```cpp
  while (kk >= sum) {
      dis++;
      kk -= sum;
      if (it == num.begin()) continue;
      tit = it;
      tit--;
      if (it->first - 1 - cnt == tit->first) {
          cnt = 0;
          it--;
          sum += it->second;
      } else cnt++;
  }
  ```
  **实现思想**：通过贪心策略和优先队列结合，动态调整众数的出现次数，确保众数条件。

### 最优关键思路与技巧

1. **优先队列（堆）**：动态维护众数的出现次数，通过每次操作减少最大出现次数，确保众数条件。
2. **前缀和与排序**：通过排序和前缀和快速计算需要修改的次数，判断某个数是否能成为众数。
3. **二分查找**：通过二分查找确定众数的出现次数，结合贪心策略进行优化。

### 可拓展之处

1. **类似问题**：可以通过类似思路解决其他需要动态调整序列元素的问题，如最小化某些操作次数。
2. **数据结构**：优先队列和前缀和是解决此类问题的常用数据结构，可以进一步学习和应用。

### 推荐题目

1. **P3374 【模板】树状数组 1**：考察前缀和的应用。
2. **P1886 滑动窗口**：考察优先队列的应用。
3. **P1908 逆序对**：考察排序和二分查找的应用。

### 个人心得摘录

- **调试经历**：部分题解提到在调试过程中发现某些特殊情况（如 \(k \geq \text{最大出现次数}\)）需要特殊处理，否则会导致错误。
- **踩坑教训**：在使用优先队列时，需要注意每次操作后需要重新调整队列，确保最大出现次数的正确性。
- **顿悟感想**：通过二分查找和前缀和的结合，可以大大减少计算量，提高算法效率。

---
处理用时：24.35秒
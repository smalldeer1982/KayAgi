# 题目信息

# [YsOI2023] 区间翻转区间异或和

## 题目背景

Ysuperman 模板测试的数据结构题。

符卡可以是人名也可以是队名。

## 题目描述

符卡有一个长度为 $n$ 的整数数组 $a$，符卡认为一个区间 $[l,r]$ 是灵异区间当且仅当 $\bigoplus_{i=l}^ra_i=0$，或者说这个区间内所有数字异或起来刚好等于 $0$。

符卡有特殊的魔法，可以把**任意**一个灵异区间翻转。具体来说，如果 $[l,r]$ 区间是灵异区间，那么符卡就可以对这个区间使用魔法，整个数组就会变成 $a_1,a_2,\dots,a_{l-1},a_r,a_{r-1},\dots,a_l,a_{r+1},a_{r+2}\dots,a_n$。

现在符卡可以使用任意次数的魔法，符卡希望最后得到的数组的灵异区间数量能够尽可能多，你能告诉她最后最多有多少个灵异区间吗？

## 说明/提示

#### 样例 1 解释

无论符卡发动多少次魔法，数组都是 $1,1,1$，所以发不发动魔法都没有任何关系。灵异区间永远都是 $[1,2],[2,3]$ 两个。

#### 样例 2 解释

这里给出可能的一种魔法发动方法。

选择灵异区间 $[1,3]$ 发动魔法，得到的新数组是 $2,1,3,3$，这个数组共有两个灵异区间，分别是 $[1,3]$ 和 $[3,4]$。

可以证明答案无法超过 $2$。

#### 数据范围

对于前 $20\%$ 的数据，保证 $n\le 10$。

对于前 $40\%$ 的数据，保证 $n\le 2000$。

另有 $10\%$ 的数据，保证 $a_i$ 全部相等。

另有 $10\%$ 的数据，保证 $a_i$ 只有两种可能的取值。

另有 $10\%$ 的数据，保证 $0\le a_i<2^{10}$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$0\le a_i< 2^{20}$。

#### 彩蛋

灵异区间的名字其实是“零异（或）区间”的谐音。

## 样例 #1

### 输入

```
3
1 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4
3 1 2 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心在于理解“翻转灵异区间”对灵异区间数量的影响。通过分析，可以得出翻转操作不会改变灵异区间的数量，因此问题转化为统计原数组中灵异区间的数量。大多数题解都采用了前缀异或和的方法来统计灵异区间的数量，且通过哈希表或数组来记录前缀异或和的出现次数，从而快速计算灵异区间的数量。

### 最优关键思路与技巧

1. **前缀异或和**：通过维护前缀异或和，可以快速计算任意区间的异或和，从而判断是否为灵异区间。
2. **哈希表/数组记录**：使用哈希表或数组记录前缀异或和的出现次数，通过组合数公式计算灵异区间的数量。
3. **翻转操作的无影响性**：通过分析翻转操作对灵异区间的影响，得出翻转操作不会改变灵异区间的数量，从而简化问题。

### 扩展思路与同类型题

1. **同类型题**：
   - [P3901 数列找不同](https://www.luogu.com.cn/problem/P3901)：使用前缀和和哈希表统计区间性质。
   - [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)：利用前缀和和哈希表统计区间内不同元素的个数。
   - [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)：使用树状数组维护前缀和，快速查询区间和。

### 所选高星题解

#### 1. 作者：_•́へ•́╬_ (5星)
- **关键亮点**：思路清晰，代码简洁，直接通过前缀异或和和数组记录出现次数，快速计算灵异区间的数量。
- **核心代码**：
  ```cpp
  int n,a[100009],cnt[1<<20];long long ans;
  main()
  {
      read(n);cnt[0]=1;
      for(int i=1;i<=n;++i)
      {
          read(a[i]);a[i]^=a[i-1];
          ans+=cnt[a[i]]++;
      }
      printf("%lld",ans);
  }
  ```

#### 2. 作者：_O_v_O_ (4星)
- **关键亮点**：使用 `unordered_map` 优化哈希表，代码简洁且高效，适合大规模数据。
- **核心代码**：
  ```cpp
  int n,a[1000005],xxor,ans;
  unordered_map<int,int>cnt;
  signed main(){
      ios::sync_with_stdio(0);
      cin.tie(nullptr);
      cin>>n;
      cnt[0]=1;
      for(int i=1;i<=n;i++){
          cin>>a[i];
          xxor^=a[i];
          ans+=cnt[xxor]++;
      }
      cout<<ans;
      return 0;
  }
  ```

#### 3. 作者：ncwzdlsd (4星)
- **关键亮点**：通过分析翻转操作对灵异区间的影响，得出翻转操作不会改变灵异区间的数量，代码简洁且高效。
- **核心代码**：
  ```cpp
  int n,a[maxn],cnt[1<<21],s;
  signed main()
  {
      int n;cin>>n;
      cnt[0]=1;
      int ans=0;
      for(int i=1;i<=n;i++) cin>>a[i],s^=a[i],ans+=cnt[s],cnt[s]++;
      cout<<ans;
      return 0;
  }
  ```

### 通用建议与扩展思路

1. **前缀和与哈希表的结合**：在处理区间性质问题时，前缀和与哈希表的结合是一种常见的优化手段，能够有效降低时间复杂度。
2. **翻转操作的无影响性**：在处理涉及翻转操作的区间问题时，分析翻转操作对区间性质的影响，往往能够简化问题。
3. **组合数公式的应用**：在统计满足某种条件的区间数量时，组合数公式能够快速计算结果，避免重复计算。

---
处理用时：23.18秒
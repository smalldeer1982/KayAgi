# 题目信息

# 猫粮规划

## 题目描述

到中午了，机器猫要吃猫粮了。

机器猫掏出 $n$ 份食物，第 $i$ 份食物含有的能量为 $w[i]$。机器猫可以吃掉其中一些食物，获得这些食物的能量之和。

机器猫又不想变得太胖又不想变得太瘦，所以指定了一个目标区间 $[l, r]$。显然，可能有很多种选择食物的方式可以达成这个目标，因此机器猫想知道方案总数。



## 说明/提示

#### 样例解释

所有方案如下：

选择食物 1, 2, 4，能量 10+10+50 = 70  
选择食物 1, 3, 4，能量 10+20+50 = 80  
选择食物 2, 3, 4，能量 10+20+50 = 80  
选择食物 3, 4，能量 50+20 = 70

共 4 种方案。

#### 数据规模与约定

对于 $50\%$ 的数据，满足 $n\leq 20$。

对于 $100\%$ 的数据，满足 $n\leq 40, 20\leq w[i] \leq 100, l\leq r \leq 300$。

提示：$w[i]$ 在范围内均匀随机生成。


## 样例 #1

### 输入

```
4 70 85
10 10 20 50
```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何高效地计算从给定的 $n$ 个数字中选择若干个数，使其和在指定区间 $[l, r]$ 内的方案数。由于 $n$ 的最大值为 40，直接枚举所有子集的 $O(2^n)$ 复杂度无法通过全部测试数据。因此，优化方法主要集中在剪枝和动态规划（DP）上。

- **剪枝方法**：通过提前判断当前和是否超过 $r$ 或剩余元素全选也无法达到 $l$，从而减少不必要的枚举。这种方法在 $n$ 较小（如 $n \leq 20$）时效果显著，但在 $n$ 较大时仍可能超时。
  
- **动态规划方法**：通过状态转移方程 $F[i][j] = F[i-1][j] + F[i-1][j-w[i]]$，计算在选到第 $i$ 个元素时和为 $j$ 的方案数。使用滚动数组优化空间复杂度，并倒序枚举 $j$ 以避免重复计算。这种方法的时间复杂度为 $O(n \cdot r)$，在 $n=40$ 和 $r=300$ 的范围内完全可行。

### 所选题解

#### 1. 作者：Usada_Pekora (赞：34)  
**星级：★★★★★**  
**关键亮点**：  
- 提出剪枝和动态规划两种方法，思路清晰且全面。  
- 动态规划部分详细解释了状态转移方程和滚动数组优化，代码实现简洁高效。  
- 针对数据范围给出了合理的复杂度分析，确保算法在极限数据下仍能通过。  

**核心代码片段**：
```cpp
int dp[301] = {1}; // 初始化 dp[0] = 1
for (int i = 0; i < n; i++) {
    for (int j = r; j >= w[i]; j--) {
        dp[j] += dp[j - w[i]];
    }
}
int ans = 0;
for (int j = l; j <= r; j++) {
    ans += dp[j];
}
cout << ans << endl;
```
**实现思想**：使用滚动数组优化空间复杂度，倒序枚举 $j$ 以避免重复计算。

#### 2. 作者：ShanCreeperPro (赞：23)  
**星级：★★★★**  
**关键亮点**：  
- 详细描述了剪枝方法，适合初学者理解。  
- 提供了 `dfs` 的实现思路，并解释了如何通过剪枝优化枚举过程。  
- 强调了剪枝在 `dfs` 中的重要性，适合小规模数据或需要灵活调整的场景。  

**核心代码片段**：
```cpp
void dfs(int idx, int sum) {
    if (sum > r) return; // 剪枝
    if (idx == n) {
        if (sum >= l) ans++;
        return;
    }
    dfs(idx + 1, sum); // 不选当前元素
    dfs(idx + 1, sum + w[idx]); // 选当前元素
}
```
**实现思想**：通过递归枚举所有子集，并在过程中剪枝以优化性能。

### 最优关键思路或技巧

- **动态规划 + 滚动数组**：通过状态转移方程和滚动数组优化，将空间复杂度从 $O(n \cdot r)$ 降低到 $O(r)$，同时保持时间复杂度为 $O(n \cdot r)$。  
- **剪枝优化**：在枚举过程中提前判断是否可能达到目标区间，减少不必要的计算。  

### 可拓展之处

- **类似问题**：如“背包问题”、“子集和问题”等，均可使用动态规划或剪枝优化。  
- **进一步优化**：对于更大的数据范围，可以考虑分治法或 meet-in-the-middle 技术。

### 推荐题目

1. **P1048 [NOIP2005 普及组] 采药**（动态规划）  
2. **P1064 [NOIP2006 提高组] 金明的预算方案**（动态规划 + 分组背包）  
3. **P1736 [NOI1999] 棋盘覆盖**（剪枝 + 搜索）  

### 个人心得摘录

- **Usada_Pekora**：提到“从大到小排序后进行搜索即可”，强调了排序对剪枝效果的影响。  
- **ShanCreeperPro**：提到“如果从这个节点开始，无论如何都不能满足题意，那就将这个节点及以下的所有树全部‘剪’掉”，强调了剪枝的核心思想。

---
处理用时：33.32秒
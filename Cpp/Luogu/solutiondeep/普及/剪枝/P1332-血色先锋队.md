# 题目信息

# 血色先锋队

## 题目背景

巫妖王的天灾军团终于卷土重来，血色十字军组织了一支先锋军前往诺森德大陆对抗天灾军团，以及一切沾有亡灵气息的生物。孤立于联盟和部落的血色先锋军很快就遭到了天灾军团的重重包围，现在他们将主力只好聚集了起来，以抵抗天灾军团的围剿。可怕的是，他们之中有人感染上了亡灵瘟疫，如果不设法阻止瘟疫的扩散，很快就会遭到灭顶之灾。大领主阿比迪斯已经开始调查瘟疫的源头。原来是血色先锋军的内部出现了叛徒，这个叛徒已经投靠了天灾军团，想要将整个血色先锋军全部转化为天灾军团！无需惊讶，你就是那个叛徒。在你的行踪败露之前，要尽快完成巫妖王交给你的任务。

## 题目描述

军团是一个 $n$ 行 $m$ 列的矩阵，每个单元是一个血色先锋军的成员。感染瘟疫的人，每过一个小时，就会向四周扩散瘟疫，直到所有人全部感染上瘟疫。你已经掌握了感染源的位置，任务是算出血色先锋军的领主们感染瘟疫的时间，并且将它报告给巫妖王，以便对血色先锋军进行一轮有针对性的围剿。

## 说明/提示

#### 输入输出样例 1 解释

如下图，标记出了所有人感染瘟疫的时间以及感染源和领主的位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/3j3g02cn.png)

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n,m\le500$，$1\le a,b\le10^5$。

## 样例 #1

### 输入

```
5 4 2 3
1 1
5 4
3 3
5 3
2 4
```

### 输出

```
3
1
3```

# AI分析结果

### 综合分析与结论

本题的核心是计算多个感染源向周围扩散瘟疫的时间，并输出指定领主被感染的时间。题解主要分为两类：**暴力枚举**和**广度优先搜索（BFS）**。暴力枚举通过计算曼哈顿距离来求解，虽然思路简单，但时间复杂度较高，适用于小规模数据。BFS则是更优的解法，能够高效地模拟瘟疫扩散过程，适用于大规模数据。

### 所选高星题解

#### 1. 作者：llzzxx712 (4星)
- **关键亮点**：使用BFS模拟瘟疫扩散，代码结构清晰，注释详细，易于理解。通过队列实现多源BFS，避免了重复计算，优化了时间复杂度。
- **个人心得**：作者提到“一定要标记一个点是否被感染，否则会造成被感染的人时间再次被更新”，强调了BFS中标记的重要性。

```cpp
void bfs(){
    int x,y,head=tot,tail=0;
    while(tail<head){ 
        tail++;
        x=q[tail][0],y=q[tail][1];
        v[x][y]=1;
        for(int i=0;i<4;i++){
            int x1=x+fx[i][0],y1=y+fx[i][1];
            if(x1<1||y1<1||x1>n||y1>m) continue;
            if(v[x1][y1]) continue;
            v[x1][y1]=1;
            map[x1][y1]=map[x][y]+1;
            q[++head][0]=x1,q[head][1]=y1;
        }
    }
}
```

#### 2. 作者：sinsop90 (4星)
- **关键亮点**：使用STL队列实现BFS，代码简洁，逻辑清晰。通过结构体存储节点信息，便于扩展和调试。
- **个人心得**：作者提到“有多个起点，那我每一个起点都跑一次，每一个点上的值取最小不就可以了吗？”，并指出这种做法会导致TLE，强调了多源BFS的必要性。

```cpp
void bfs(){
    while(!Q.empty()){
        node tmp;
        node t;
        for(int i=0;i<=3;i++){
            t = Q.front();
            int xx = t.x+fx[i][0], yy = t.y+fx[i][1];
            if(xx>=1&&xx<=n && yy>=1&&yy<=m && !vis[xx][yy]){
                vis[xx][yy] = true;
                tmp.x = xx;
                tmp.y = yy;
                tmp.steps = t.steps+1;
                Q.push(tmp);
            }
        }
        maps[t.x][t.y] = t.steps;
        Q.pop();
    }
}
```

#### 3. 作者：开挂老司机 (4星)
- **关键亮点**：使用队列实现BFS，代码简洁，逻辑清晰。通过方向数组简化了代码，易于理解和扩展。
- **个人心得**：作者提到“如果新的步数更短，则更新步数”，强调了BFS中步数更新的重要性。

```cpp
do {
    s=q.front();
    q.pop();
    for(int i=0;i<4;i++) {
        c.h=s.h+dx[i],c.l=s.l+dy[i];
        if(f[s.h][s.l]+1<f[c.h][c.l]) {
            f[c.h][c.l]=f[s.h][s.l]+1;
            q.push(c);
        }
    }
} while(!q.empty());
```

### 最优关键思路与技巧

1. **多源BFS**：将所有感染源同时入队，避免重复计算，优化时间复杂度。
2. **标记数组**：使用标记数组记录已访问节点，防止重复访问。
3. **方向数组**：通过方向数组简化代码，减少冗余。

### 拓展思路

- **类似题目**：可以扩展到其他多源扩散问题，如火灾蔓延、病毒传播等。
- **优化技巧**：可以使用优先队列（Dijkstra）来处理带权扩散问题，或者使用双向BFS进一步优化。

### 推荐题目

1. **P1443 马的遍历**：考察BFS在棋盘上的应用。
2. **P1162 填涂颜色**：考察BFS在矩阵中的应用。
3. **P2296 寻找道路**：考察BFS在路径搜索中的应用。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中遇到的TLE问题，强调了优化的重要性。
- **顿悟感想**：通过多源BFS和标记数组的使用，能够有效解决大规模数据下的扩散问题。

---
处理用时：39.61秒
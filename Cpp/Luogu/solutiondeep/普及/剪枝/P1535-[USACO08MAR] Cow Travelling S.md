# 题目信息

# [USACO08MAR] Cow Travelling S

## 题目描述

奶牛们在被划分成 $N$ 行 $M$ 列（$2 \leq N,M \leq 100$）的草地上游走， 试图找到整块草地中最美味的牧草。

Farmer John 在某个时刻看见贝茜在位置 $(R_1, C_1)$，恰好 $T$（$0 \lt T \leq 15$）秒后，FJ 又在位置 $(R_2, C_2)$ 与贝茜撞了正着。FJ 并不知道在这 $T$ 秒内贝茜是否曾经到过 $(R_2, C_2)$，他能确定的只是，现在贝茜在那里。

设 $S$ 为奶牛在 $T$ 秒内从 $(R_1, C_1)$ 走到 $(R_2, C_2)$ 所能选择的路径总数，FJ 希望有一个程序来帮他计算这个值。每一秒内，奶牛会水平或垂直地移动 $1$ 单位距离（奶牛总是在移动，不会在某秒内停在它上一秒所在的点）。草地上的某些地方有树，自然，奶牛不能走到树所在的位置，也不会走出草地。

现在你拿到了一张整块草地的地形图，其中 `.` 表示平坦的草地，`*` 表示挡路的树。你的任务是计算出，一头在 $T$ 秒内从 $(R_1, C_1)$ 移动到 $(R_2, C_2)$ 的奶牛可能经过的路径有哪些。

## 说明/提示

奶牛在 $6$ 秒内从 $(1,3)$ 走到 $(1,5)$ 的方法只有一种，绕过她面前的树。

## 样例 #1

### 输入

```
4 5 6
...*.
...*.
.....
.....
1 3 1 5```

### 输出

```
1
```

# AI分析结果

### 综合分析与结论

该题目要求计算在给定时间内从起点到终点的路径总数，且路径中不能经过障碍物。题解中主要采用了以下几种思路：

1. **记忆化搜索**：通过记录已经计算过的状态，避免重复计算，显著提高了搜索效率。
2. **动态规划（DP）**：通过状态转移方程，逐步计算每个时间步内每个位置的路径数，最终得到结果。
3. **广度优先搜索（BFS）**：结合记忆化，避免重复状态入队，优化了空间和时间复杂度。

其中，**记忆化搜索**和**动态规划**是解决该问题的核心思路，能够有效避免暴力搜索的高时间复杂度问题。

### 所选高星题解

#### 1. 题解作者：JRzyh (5星)
- **关键亮点**：详细讲解了记忆化搜索的实现过程，从基础DFS到记忆化优化，逐步引导读者理解如何通过记录状态来避免重复计算。代码清晰，注释详细，复杂度分析到位。
- **个人心得**：作者通过斐波那契数列的例子，生动地解释了记忆化的必要性，帮助读者更好地理解记忆化搜索的原理。
- **核心代码**：
  ```cpp
  int dfs(int x, int y, int time) {
      if (re[x][y][time] != -1) return re[x][y][time];
      if (abs(x - r2) + abs(y - c2) > t - time) return re[x][y][time] = 0;
      if (time > t) return re[x][y][time] = 0;
      if (time == t) {
          if (x == r2 && y == c2) return re[x][y][time] = 1;
          else return re[x][y][time] = 0;
      }
      int ans = 0;
      for (int i = 0; i < 4; i++) {
          if (b[x + dx[i]][y + dy[i]] || x + dx[i] < 1 || x + dx[i] > n || y + dy[i] < 1 || y + dy[i] > m) continue;
          ans += dfs(x + dx[i], y + dy[i], time + 1);
      }
      return re[x][y][time] = ans;
  }
  ```

#### 2. 题解作者：communist (4星)
- **关键亮点**：采用了BFS结合记忆化的思路，通过队列和状态数组避免了重复状态入队，优化了空间复杂度。代码简洁，思路清晰。
- **核心代码**：
  ```cpp
  void bfs() {
      q.push(node{sx, sy, 0});
      f[sx][sy][0] = 1;
      while (!q.empty()) {
          node u = q.front(); q.pop();
          for (int i = 0; i < 4; i++) {
              int xx = u.x + dx[i], yy = u.y + dy[i];
              if (xx < 1 || yy < 1 || xx > n || yy > m || a[xx][yy] == '*' || u.step + 1 > t) continue;
              if (f[xx][yy][u.step + 1]) {
                  f[xx][yy][u.step + 1] += f[u.x][u.y][u.step];
                  continue;
              }
              f[xx][yy][u.step + 1] += f[u.x][u.y][u.step];
              q.push(node{xx, yy, u.step + 1});
          }
      }
  }
  ```

#### 3. 题解作者：_ztyqwq (4星)
- **关键亮点**：采用了动态规划的思路，通过状态转移方程逐步计算每个时间步内每个位置的路径数。代码简洁，思路清晰，适合对DP有一定基础的读者。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= t; i++) {
      for (int j = 1; j <= n; j++) {
          for (int k = 1; k <= m; k++) {
              if (!g[j][k]) continue;
              dp[j][k][i] = dp[j][k - 1][i - 1] + dp[j][k + 1][i - 1] + dp[j - 1][k][i - 1] + dp[j + 1][k][i - 1];
          }
      }
  }
  ```

### 最优关键思路与技巧

1. **记忆化搜索**：通过记录已经计算过的状态，避免重复计算，显著提高了搜索效率。
2. **动态规划（DP）**：通过状态转移方程，逐步计算每个时间步内每个位置的路径数，最终得到结果。
3. **广度优先搜索（BFS）**：结合记忆化，避免重复状态入队，优化了空间和时间复杂度。

### 可拓展之处

- **类似问题**：可以扩展到其他路径计数问题，如带权路径、多目标路径等。
- **算法套路**：记忆化搜索和动态规划是解决路径计数问题的通用套路，可以应用于其他类似问题。

### 推荐题目

1. **P1002 过河卒**：经典的路径计数问题，适合练习动态规划。
2. **P1433 吃奶酪**：结合路径计数和状态压缩的动态规划问题。
3. **P1048 采药**：经典的背包问题，适合练习动态规划的状态转移方程。

### 个人心得总结

- **调试经历**：在实现记忆化搜索时，确保状态记录的正确性非常重要，避免重复计算和遗漏状态。
- **踩坑教训**：在BFS中，如果不进行记忆化，可能会导致重复状态入队，导致空间和时间复杂度爆炸。
- **顿悟感想**：记忆化搜索和动态规划是解决路径计数问题的利器，理解其原理和实现方式能够显著提高解题效率。

---
处理用时：47.38秒
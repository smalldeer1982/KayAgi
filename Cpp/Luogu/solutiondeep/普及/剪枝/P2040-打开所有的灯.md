# 题目信息

# 打开所有的灯

## 题目背景

pmshz在玩一个益(ruo)智(zhi)的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了pmshz。。。


## 题目描述

这个灯很奇(fan)怪(ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉pmshz要全部打开这些灯。



例如
```
0  1  1
1  0  0
1  0  1
```

点一下最中间的灯【2,2】就变成了
```
0  0  1
0  1  1
1  1  1
```

再点一下左上角的灯【1,1】就变成了

```
1  1  1
1  1  1
1  1  1
```

达成目标。最少需要2步。

输出2即可。


## 说明/提示

这个题水不水，就看你怎么考虑了。。。。


## 样例 #1

### 输入

```
0 1 1
1 0 0
1 0 1```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

该题目要求通过最少的操作次数将3x3的灯矩阵全部点亮，每次操作会改变当前灯及其周围四盏灯的状态。题解中主要采用了以下几种思路：

1. **暴力枚举**：通过枚举所有可能的操作组合，检查是否能够达到目标状态。时间复杂度为O(2^9)，由于数据规模较小，可以接受。
2. **BFS（广度优先搜索）**：将灯的状态作为节点，通过BFS搜索最短路径。状态数最多为512，适合BFS。
3. **DFS（深度优先搜索）**：通过DFS遍历所有可能的操作序列，结合剪枝优化。
4. **状态压缩**：将灯的状态和操作序列压缩为二进制数，减少空间和时间复杂度。
5. **线性代数/异或方程组**：将问题转化为线性方程组，通过解方程组找到最优解。

### 所选高星题解

#### 1. 题解作者：nothingness
- **星级**：★★★★★
- **关键亮点**：使用状压DP，通过异或操作快速变换状态，时间复杂度为O(512*9)，比大多数题解更快。
- **核心代码**：
  ```cpp
  int upd[10]={0,416,464,200,308,186,89,38,23,11};
  int main() {
      for(int i=8;i>=0;i--) scanf("%d",&a),x+=a*(1<<i);
      memset(f,-1,sizeof(f));
      f[x]=0;
      q[++t]=x;
      while(h<t) {
          x=q[++h];
          for(int i=1;i<=9;i++)
              if(f[x^upd[i]]==-1)
                  q[++t]=x^upd[i],f[x^upd[i]]=f[x]+1;
      }
      printf("%d",f[511]);
      return 0;
  }
  ```
- **个人心得**：通过异或操作快速变换状态，减少了状态转移的复杂度。

#### 2. 题解作者：ljc1301
- **星级**：★★★★☆
- **关键亮点**：通过枚举第一行的操作状态，逐行推导后续操作，时间复杂度为O(2^3 * 3 * 3)，效率较高。
- **核心代码**：
  ```cpp
  void dfs(int s) {
      if(s>=n) {
          num=min(num,pd());
          return;
      }
      for(ans[0][s]=0;ans[0][s]<2;ans[0][s]++)
          dfs(s+1);
  }
  ```
- **个人心得**：通过枚举第一行的操作状态，减少了搜索空间，提高了效率。

#### 3. 题解作者：Bartholomew
- **星级**：★★★★☆
- **关键亮点**：通过二进制枚举所有可能的操作组合，结合状态压缩，代码简洁易懂。
- **核心代码**：
  ```cpp
  for(int used=0;used<(1<<9);used++) {
      get(used); memset(how,0,sizeof how);
      for(int i=0;i<9;i++) if(s[i]) {
          if(!i) how[0]++,how[1]++,how[3]++;
          else if(i==1) how[0]++,how[1]++,how[2]++,how[4]++;
          // 其他情况省略
      }
      bool flag=true;
      for(int i=0;i<9;i++)
          if(how[i]%2==1 && a[i]) flag=false;
          else if(how[i]%2==0 && !a[i]) flag=false;
      if(flag) {
          tot=0;
          for(int i=0;i<9;i++) if(s[i]) tot++;
          ans=getmin(tot,ans);
      }
  }
  ```
- **个人心得**：通过二进制枚举操作组合，减少了代码复杂度，易于理解和实现。

### 最优关键思路与技巧

1. **状态压缩**：将灯的状态和操作序列压缩为二进制数，减少空间和时间复杂度。
2. **BFS优化**：通过异或操作快速变换状态，减少了状态转移的复杂度。
3. **枚举与推导**：通过枚举第一行的操作状态，逐行推导后续操作，减少了搜索空间。

### 可拓展之处

1. **类似问题**：该题可以拓展到更大的灯矩阵或不同的操作规则，如改变更多灯的状态。
2. **算法套路**：BFS、DFS、状态压缩、线性代数等算法套路可以应用于类似的搜索和优化问题。

### 推荐题目

1. **P2040 打开所有的灯**：本题的变种，考察类似的搜索和状态压缩技巧。
2. **P1219 八皇后**：考察DFS和回溯算法，适合练习搜索优化。
3. **P1074 靶形数独**：考察状态压缩和DFS，适合练习复杂状态的处理。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中遇到的坑，如忘记pop()操作、状态转移错误等，提醒我们在编写代码时要注意细节。
- **顿悟感想**：通过异或操作和状态压缩，能够显著减少代码复杂度和运行时间，体现了算法优化的重要性。

---
处理用时：44.40秒
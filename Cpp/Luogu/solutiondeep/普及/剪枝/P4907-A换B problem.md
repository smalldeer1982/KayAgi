# 题目信息

# A换B problem

## 题目背景

仙女与小奔约定，想要拿到仙药，必须在牌技上赢了她。

## 题目描述

他们要开始打牌了。但是，拥有强迫症的小奔看着手中的牌，很不愉快。原因是他理牌时按花色理（逗我），又希望一个花色的牌是连着的（$A-2-3-4-5-6-7-8-9-10-J-Q-K$）。

忍无可忍的小奔开始与参与打牌的其他人换牌（作弊？？？），他希望换最少的牌来满足他的需求（假设所有牌都可以换）

换牌规则：只能用点数相同的牌交换。

众人：还能不能好好打牌了？！我们限你1s内换完，要不然就告诉仙女！

## 说明/提示

样例1，可达成，将$2$ $3$换为$1$ $3$，$4$ $J$换为$3$ $J$

样例2，可达成，将$2$ $3$换成$1$ $3$，$3$ $Q$换成$4$ $Q$。
（以上答案仅供参考，不保证没有多解,但输出必然唯一，~~别问我为什么~~）


对于10%的数据：为样例$2.$

对于100%的数据： $ N \leq 52 $，即保证数据在一副牌内

## 样例 #1

### 输入

```
10
1 A
1 2
1 4
2 3
2 5
2 6
3 9
3 10
3 Q
4 J```

### 输出

```
Yes
2```

## 样例 #2

### 输入

```
10
1 A
1 2
1 4
2 3
2 5
2 6
3 9
3 10
3 Q
4 K```

### 输出

```
Yes
2```

# AI分析结果

### 综合分析与结论

本题的核心是通过交换牌使得每种花色的牌按顺序排列，且交换次数最少。题解中主要采用了深度优先搜索（DFS）和剪枝策略来优化搜索过程。虽然题目看似简单，但由于数据规模较大（N≤52），直接暴力搜索会超时，因此需要结合剪枝和优化技巧。

### 题解评分与亮点

1. **作者：FlashHu (赞：19)**  
   - **星级：4.5**  
   - **关键亮点**：  
     - 使用了枚举区间长度和右端点的策略，结合可行性剪枝和最优性剪枝，大大减少了搜索空间。  
     - 通过动态维护当前选多了的总数，进一步优化了搜索效率。  
     - 代码结构清晰，剪枝策略合理，运行效率较高（700+ms）。  
   - **个人心得**：  
     - 提到了“比较需要技巧的搜索”，强调了剪枝的重要性，并指出标程可能没有加剪枝，导致运行时间较长。

2. **作者：HuangRuibo (赞：3)**  
   - **星级：4**  
   - **关键亮点**：  
     - 使用了DFS结合剪枝的策略，通过递归尝试所有可能的交换方式。  
     - 在每次交换后检查当前状态是否满足要求，并记录最少的交换次数。  
     - 代码结构清晰，剪枝策略合理，运行效率较高。  
   - **个人心得**：  
     - 提到了“数据加强了踢一下我，我改一个剪枝的……”，表明了对剪枝策略的重视。

3. **作者：luozejun_180913 (赞：1)**  
   - **星级：4**  
   - **关键亮点**：  
     - 使用了DFS结合剪枝的策略，通过递归尝试所有可能的交换方式。  
     - 在每次交换后检查当前状态是否满足要求，并记录最少的交换次数。  
     - 代码结构清晰，剪枝策略合理，运行效率较高。  
   - **个人心得**：  
     - 提到了“这道题时间复杂度有点极限，考虑剪枝”，强调了剪枝的重要性。

### 最优关键思路与技巧

1. **剪枝策略**：通过枚举区间长度和右端点，结合可行性剪枝和最优性剪枝，大大减少了搜索空间。
2. **动态维护**：在搜索过程中动态维护当前选多了的总数，进一步优化了搜索效率。
3. **递归与回溯**：通过递归尝试所有可能的交换方式，并在每次交换后回溯，确保搜索的完整性。

### 可拓展之处

1. **类似题目**：可以扩展到其他需要枚举区间或组合的题目，如区间覆盖、区间合并等。
2. **剪枝技巧**：在其他搜索问题中，可以借鉴本题的剪枝策略，结合动态维护和最优性剪枝，提高搜索效率。

### 推荐题目

1. **P1048 采药**：考察DFS与剪枝策略，适合练习搜索优化。
2. **P1090 合并果子**：考察贪心与优先队列，适合练习区间合并与优化。
3. **P1060 开心的金明**：考察动态规划与背包问题，适合练习状态转移与优化。

### 重点代码片段

```cpp
// FlashHu的DFS核心代码
void dfs(R h,R lef){
    if(h==5){
        R now=0;
        for(R i=1;i<=13;++i){
            if(cnt[i]>0)return;//不合法
            now|=cnt[i]<0;
        }
        if(now){ans1=now1;return;}//No状态
        for(R i=1;i<=n;++i)//Yes状态，统计答案
            if((l[a[i]]>b[i]||r[a[i]]<b[i])&&++now==ans)return;
        ans=now;ans1=1;return;//注意ans1=1的剪枝作用
    }
    for(R i=max(lef-(4-h)*13,0),j,rr;i<=13;++i){//枚举区间长度，可行性剪枝
        if(i==0){l[h]=r[h]=0;dfs(h+1,lef);continue;}
        for(rr=i;rr<=13;++rr){//枚举右端点
            for(j=rr-i+1;j<=rr;++j)now1+=--cnt[j]<0;//动态维护当前选多了的总数
            if(now1<ans1)l[h]=(r[h]=rr)-i+1,dfs(h+1,lef-i);//最优性剪枝
            for(j=rr-i+1;j<=rr;++j)now1-=++cnt[j]<=0;
        }
    }
}
```

这段代码通过枚举区间长度和右端点，结合剪枝策略，高效地搜索了所有可能的交换方式，并动态维护了当前选多了的总数，进一步优化了搜索效率。

---
处理用时：36.09秒
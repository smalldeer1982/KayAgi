# 题目信息

# 【XR-2】奇迹

## 题目背景

> 相信奇迹的人，本身就和奇迹一样了不起。——笛亚 《星游记》

## 题目描述

我们称一个**日期**为一个八位数，第 1~4 位构成年，第 5~6 位构成月，第 7~8 位构成日，不足位数用 0 补足。同时，要求日期所代表的这一天真实存在，且年的范围为 1~9999。

出现奇迹的日期都存在相同的特点：由“日”组成的两位数，由“月+日”组成的四位数，由“年+月+日”组成的八位数均为**质数**。但并不是所有存在这样特点的日期都一定会出现奇迹。

现在，你得到了一个可能会出现奇迹的日期，然而不幸的是这个日期却是残缺的，八位中可能有若干位无法确定。你需要知道这个日期有多少种可能，这样你才能做好充足的准备去迎接奇迹的到来。

## 说明/提示

【样例 $1$ 说明】

`53-7-3-7` 的 $6$ 种可能的日期如下：

```plain
53070307
53070317
53170307
53370307
53570317
53770307
```

【数据规模与约定】

一共 $10$ 个测试点，记 $c$ 为八位字符串中 `-` 的个数。

对前 $9$ 个测试点，在第 $i$ 个测试点中保证 $c = i - 1$。

对 $100\%$ 的数据保证 $1 \le T \le 10$。

## 样例 #1

### 输入

```
2
53-7-3-7
20190629
```

### 输出

```
6
0
```

# AI分析结果

### 综合分析与结论

该题目要求计算满足特定条件的日期数量，核心难点在于如何高效地枚举和判断符合条件的日期。大多数题解采用了暴力搜索（DFS）结合质数判断的方法，部分题解通过预处理质数表、剪枝优化、打表等方式提升效率。整体来看，题解的质量参差不齐，部分题解代码冗长且优化不足，少数题解通过巧妙的剪枝和预处理实现了较好的性能。

### 精选题解

#### 1. **作者：Ciyang**  
**星级：★★★★★**  
**关键亮点：**
- **清晰的DFS思路**：按日、月、年的顺序逐层判断，减少了不必要的枚举。
- **质数判断优化**：使用线性筛预处理质数，避免重复计算。
- **代码简洁优雅**：逻辑清晰，代码结构良好，易于理解。
- **个人心得**：强调了DFS的逐层判断思路，避免了复杂的特判。

**核心代码：**
```cpp
int dfs(int nown, int num, int rn, int jy) {
    if(nown == 0) {
        if(num / 10000 == 0) return 0;
        if(rn && pdrn(num / 10000) == 0) return 0;
        return pdzs(num);
    }
    if(nown == 6) {
        if(num == 0 || num > 31 || !pdzs(num)) return 0;
        if(num == 31) jy= 1;
    }
    if(nown == 4) {
        if(num < 32 || num > 1231 || !pdzs(num)) return 0;
        if(jy && !yue[num / 100]) return 0;
        if(num / 100 == 2) {
            if(num % 100 > 29) return 0;
            if(num % 100 == 29) rn= 1;
        }
    }
    if(a[nown] != -1) return dfs(nown - 1, a[nown] * p10[8 - nown] + num, rn, jy);
    int res= 0;
    for(int i= 0; i <= 9; i++) res+= dfs(nown - 1, i * p10[8 - nown] + num, rn, jy);
    return res;
}
```
**核心思想**：通过DFS逐层判断日、月、年是否合法，并使用线性筛预处理质数表，优化质数判断。

#### 2. **作者：whale142857**  
**星级：★★★★☆**  
**关键亮点：**
- **Miller-Rabin质数判断**：使用Miller-Rabin算法高效判断大质数，提升整体性能。
- **剪枝优化**：通过提前判断日期的合法性，减少不必要的枚举。
- **代码简洁**：逻辑清晰，代码结构良好。

**核心代码：**
```cpp
bool Prime(int x) {
    if(isp[x]) return true;
    if(x <= 1) return false;
    for(int i = 1; i <= 15; i++) {
        int a = r(1, x - 1);
        if(qmi(a, x - 1, x) != 1) return false;
    }
    isp[x] = true;
    return true;
}
```
**核心思想**：使用Miller-Rabin算法判断质数，并通过剪枝优化减少枚举次数。

#### 3. **作者：mulberror**  
**星级：★★★★☆**  
**关键亮点：**
- **打表优化**：通过预处理符合条件的日期，减少计算量。
- **质数判断优化**：使用线性筛预处理质数表，避免重复计算。
- **代码简洁**：逻辑清晰，代码结构良好。

**核心代码：**
```cpp
void pre() {
    for(int Year = 1; Year <= 9999; Year++) {
        for(int Month = 1; Month <= 12; Month++) {
            int day = Pre[Month];
            if(Month == 2) {
                if((Year % 4 == 0 && Year % 100 != 0) || Year % 400 == 0) day++;
            }
            for(int Day = 1; Day <= day; Day++) {
                int x1 = Day, x2 = Day + Month * 100, x3 = Day + Month * 100 + Year * 10000;
                if(check(x1) && check(x2) && check(x3)) acc[Year][Month][Day] = 1;
            }
        }
    }
}
```
**核心思想**：通过预处理符合条件的日期，减少计算量，并使用线性筛优化质数判断。

### 最优关键思路与技巧

1. **逐层DFS判断**：按日、月、年的顺序逐层判断，减少不必要的枚举。
2. **质数判断优化**：使用线性筛或Miller-Rabin算法高效判断质数。
3. **剪枝优化**：通过提前判断日期的合法性，减少不必要的枚举。
4. **打表优化**：预处理符合条件的日期，减少计算量。

### 可拓展之处

- **类似题目**：可以拓展到其他需要枚举和判断的日期相关题目，如计算特定日期范围内的特殊日期数量。
- **质数判断优化**：在其他需要频繁判断质数的题目中，可以使用线性筛或Miller-Rabin算法优化性能。

### 推荐题目

1. **P1217 [USACO1.5]回文质数**：考察质数和回文数的判断。
2. **P1075 质因数分解**：考察质因数分解的算法。
3. **P3383 【模板】线性筛素数**：考察线性筛法的实现。

### 个人心得总结

- **调试经历**：部分题解强调了调试过程中的关键点，如特判闰年和日期的合法性。
- **踩坑教训**：强调了质数判断的优化和剪枝的重要性，避免不必要的计算。
- **顿悟感想**：通过逐层DFS判断，减少了复杂的特判，提升了代码的可读性和效率。

---
处理用时：47.85秒
# 题目信息

# [NICA #1] 上大分

## 题目背景

小 T 喜欢打 CF。

## 题目描述

小 T 获得了预知能力，能预知自己后面 $n$ 场比赛的表现分。

下面是表现分的定义：

- 记小 T 在参加这场比赛前账号的分数是 $i$，他这场的表现分为 $j$，那么打完这场之后他的账号分数是 $i+\lfloor\frac{j-i}{4}\rfloor$ 。
- 其中 $\lfloor x\rfloor$ 表示对 $x$ 下取整，如 $\lfloor 1.9\rfloor=1,\lfloor -1.3\rfloor=-2$。

但是小 T 只有一个账号，初始分数是 $x$。他决定从未来的 $n$ 次比赛中选择**不超过** $k$ 次参加，同时，这些比赛的类型不同，具体分为两类，这些类型会给出：

- division 1：不管小 T **当前的分数**是多少，都可以参加。
- division 2：只有小 T **当前的分数** $< 1900$，他才能参加。
- 注意，**当前的分数**为这次比赛前的分数，而不是初始分数。**当前的分数**会随着小 T 之前选择参加比赛的策略变动而变动。

他希望自己在所有比赛结束后得分最高，请你来帮他规划一下，在最优决策下，参加完选出的比赛后能获得的最高分数是多少。



## 说明/提示

#### 【样例解释 2】

两场都打。

#### 【数据范围】

对于 $100\%$ 的数据，满足 $0\leq x,a_i\leq 4000$，$n,k\leq 5000$，$1\leq k\leq n$。

## 样例 #1

### 输入

```
2 2 1900
2 1899
2 4000```

### 输出

```
1900```

## 样例 #2

### 输入

```
2 2 1900
1 1899
2 4000```

### 输出

```
2424```

# AI分析结果

### 综合分析与结论

本题的核心难点在于如何设计动态规划的状态转移方程，特别是如何处理 `division 2` 比赛的分数限制。大多数题解都采用了动态规划的思路，但状态设计和转移方式有所不同。部分题解通过逆向思维，将“达到某个分数所需的最少比赛场数”作为状态，从而简化了问题。此外，滚动数组优化和边界条件的处理也是常见的优化手段。

### 所选高质量题解

#### 1. **题解作者：MTFlowCzq (5星)**
- **关键亮点**：该题解通过逆向思维，将状态设计为“达到某个分数所需的最少比赛场数”，从而简化了状态转移方程。同时，题解详细解释了如何通过滚动数组优化空间复杂度，并提供了清晰的代码实现。
- **个人心得**：作者提到“经典的 DP 优化手段”，强调了逆向思维在动态规划中的重要性。
- **核心代码**：
  ```cpp
  int dp[4009];
  for (int i=0;i<=4000;i++) dp[i]=10009;
  dp[x]=0;
  while (n--) {
      cin>>id>>a;
      int m=4000; if (id==2) m=1899;
      for (int i=a+1;i<=m;i++) {
          int now=i-(i-a+3)/4;
          dp[now]=min(dp[now],dp[i]+1);
      }
      for (int i=min(m,a-1);i>=0;i--) {
          int now=i+(a-i)/4;
          dp[now]=min(dp[now],dp[i]+1);
      }
  }
  ```

#### 2. **题解作者：What__can__I__say (4星)**
- **关键亮点**：该题解同样采用了逆向思维，将状态设计为“达到某个分数所需的最少比赛场数”，并详细解释了如何通过滚动数组优化空间复杂度。代码实现简洁，逻辑清晰。
- **核心代码**：
  ```cpp
  int f[10086];
  memset(f,0x3f,sizeof f);
  f[x]=0;
  while(n--){
      dv=rd();a=rd();
      m=(dv==1?4000:1899);
      for(int i=a+1;i<=m;++i){
          int now=i-ceil((i-a)*1.0/4);
          f[now]=min(f[now],f[i]+1);
      }
      for(int i=min(m,a-1);i>=0;--i){
          int now=i+(a-i)*1.0/4;
          f[now]=min(f[now],f[i]+1);
      }
  }
  ```

#### 3. **题解作者：xzy_AK_IOI (4星)**
- **关键亮点**：该题解通过正向思维，设计状态为“前 i 场比赛打 j 场比赛时的最高分数”，并详细解释了如何处理 `division 2` 的分数限制。代码实现清晰，逻辑严谨。
- **核心代码**：
  ```cpp
  int dp[N][N];
  dp[0][0]=x;
  for (int i=1;i<=n;i++){
      for (int j=0;j<=min(k,i);j++){
          dp[i][j]=dp[i-1][j];
          if (((a[i]==2)?(dp[i-1][j-1]<1900):1) && j){
              dp[i][j]=max(dp[i][j],dp[i-1][j-1]+(int)floor(double(double(b[i])-double(dp[i-1][j-1]))/4.0));
          }
      }
  }
  ```

### 最优关键思路与技巧

1. **逆向思维**：将状态设计为“达到某个分数所需的最少比赛场数”，从而简化了状态转移方程。
2. **滚动数组优化**：通过滚动数组优化空间复杂度，减少内存使用。
3. **边界条件处理**：在处理 `division 2` 的分数限制时，通过合理的边界条件处理，确保状态转移的正确性。

### 可拓展之处

1. **类似题目**：可以拓展到其他需要处理条件限制的动态规划问题，如背包问题中的容量限制、时间限制等。
2. **算法套路**：逆向思维在动态规划中常用于简化问题，特别是在状态转移复杂或难以直接设计状态时。

### 推荐题目

1. **P1048 [NOIP2005 普及组] 采药**：考察动态规划的基本应用，类似于背包问题。
2. **P1060 [NOIP2006 提高组] 开心的金明**：考察动态规划中的条件限制处理。
3. **P1541 [NOIP2010 提高组] 乌龟棋**：考察动态规划中的状态设计和转移优化。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中遇到的困难，如状态转移方程的设计和边界条件的处理，这些经验对于解决类似问题非常有帮助。
- **顿悟感想**：逆向思维在动态规划中的应用，往往能够简化问题，特别是在状态转移复杂时，通过逆向思维可以找到更简洁的解决方案。

---
处理用时：34.34秒
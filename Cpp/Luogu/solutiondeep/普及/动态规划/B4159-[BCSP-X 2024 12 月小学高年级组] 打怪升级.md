# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 打怪升级

## 题目描述

Alice 在玩一个游戏，游戏共有 $n$ 个关卡，你需要操作 $1$ 个主角过关，主角有 $2$ 个属性：

1. 血量
2. 等级

每关的 Boss 会对主角造成伤害（血量减小），第 $i$ 关的 Boss 对等级为 $j$ 的主角造成的伤害值为 $b[i][j]$。

每关打完 Boss 后，在进入下一关前会得到一本经验书，你有 $2$ 个选择：

1. 回血：第 $i$ 关的经验书可以使血量增加 $a[i]$。
2. 改变等级：若假设主角当前等级为 now，使用经验书可以将等级变为 $[1, now + 1]$ 中的任意值。

你需要在 $2$ 个选择中择一执行。

已知主角的初始血量为 $m$，初始等级为 $1$，游戏过程中任意时刻血量必须 $>0$。

现在请问，在通过第 $k$ 个关卡之后（可以使用第 $k$ 关的经验书），主角能达到的最大等级是多少？如果无法通过第 $k$ 关，答案为 0。

请你输出 $k = 1 \sim n$ 的所有答案，注意这 $n$ 个询问是独立的。

例如 $n = 3, m = 2, a = [2, 1, 1]$

$$b[1][1] = 1$$
$$b[2][1] = 2, b[2][2] = 3$$
$$b[3][1] = 3, b[3][2] = 3, b[3][3] = 3$$

- 当 $k = 1$ 时，第一关血量先减为 $2 - 1 = 1$，然后选择升为 2 级，答案为 $2$。
- 当 $k = 2$ 时，第一关血量先减为 $2 - 1 = 1$，然后选择加血 $1 + 2 = 3$；第二关血量减为 $3 - 2 = 1$，然后选择升为 $2$ 级，答案为 $2$。
- 当 $k = 3$ 时，无论如何选择都无法通过第 3 关，答案为 $0$。

## 说明/提示

### 样例 3-5

见附件。

### 数据范围

对于所有数据，$1 \leq n \leq 1500, 0 \leq a[i], b[i][j] \leq 100, 1 \leq m \leq 1500$

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $n$ | 子任务依赖 |
|:----------:|:----:|:-------:|:------------:|
| 1          | 39   | $\leq 10$ |            |
| 2          | 43   | $\leq 100$ | 1          |
| 3          | 18   | $\leq 1500$ | 1,2        |

## 样例 #1

### 输入

```
3 2
2 1 1
1
2 3
3 3 3```

### 输出

```
2
2
0```

## 样例 #2

### 输入

```
10 98
67 100 76 15 44 86 38 95 5 8
43
25 91
14 18 24
79 79 60 85
35 47 59 22 96
53 78 43 95 55 25
74 26 97 30 42 14 6
100 70 79 49 83 74 43 38
64 38 75 79 59 10 54 17 2
34 19 19 4 23 90 99 97 93 10```

### 输出

```
2
2
3
4
4
4
5
5
5
6```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在每一关后选择回血或升级，以最大化主角的等级，同时确保血量始终大于0。由于每一关的选择会影响后续关卡的决策，因此需要动态规划（DP）来解决。难点在于如何设计状态转移方程，以及在每一关后如何选择回血或升级。

### 通用建议与扩展思路

1. **状态设计**：使用DP表来记录每一关后的血量和等级。状态可以表示为 `dp[i][j]`，表示通过第 `i` 关后，主角的等级为 `j` 时的最大血量。
2. **状态转移**：在每一关后，主角可以选择回血或升级。回血会增加血量，而升级会增加等级，但可能会影响后续关卡的伤害计算。
3. **边界条件**：初始状态为 `dp[0][1] = m`，表示初始血量为 `m`，等级为1。
4. **优化**：由于每一关的选择只依赖于前一关的状态，因此可以使用滚动数组优化空间复杂度。

### 推荐洛谷题目

1. **P1048 采药** - 经典的背包问题，与本题的DP思路相似。
2. **P1060 开心的金明** - 涉及选择与状态转移，适合练习DP。
3. **P1091 合唱队形** - 需要处理多个状态，与本题的多状态DP类似。

### 最优关键思路或技巧

1. **动态规划**：通过DP表记录每一关后的血量和等级，确保每一步的选择都是最优的。
2. **状态转移方程**：在每一关后，根据当前血量和等级，选择回血或升级，更新DP表。
3. **滚动数组优化**：由于每一关的状态只依赖于前一关的状态，可以使用滚动数组减少空间复杂度。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];
    vector<vector<int>> b(n);
    for (int i = 0; i < n; ++i) {
        b[i].resize(i + 2);
        for (int j = 1; j <= i + 1; ++j) cin >> b[i][j];
    }

    vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));
    dp[0][1] = m;

    for (int i = 0; i < n; ++i) {
        for (int j = 1; j <= i + 1; ++j) {
            if (dp[i][j] == -1) continue;
            int hp = dp[i][j] - b[i][j];
            if (hp <= 0) continue;
            // 选择回血
            dp[i + 1][j] = max(dp[i + 1][j], hp + a[i]);
            // 选择升级
            for (int k = 1; k <= j + 1; ++k) {
                dp[i + 1][k] = max(dp[i + 1][k], hp);
            }
        }
    }

    for (int k = 1; k <= n; ++k) {
        int max_level = 0;
        for (int j = 1; j <= k + 1; ++j) {
            if (dp[k][j] > 0) max_level = max(max_level, j);
        }
        cout << max_level << endl;
    }

    return 0;
}
```

### 核心实现思想

1. **初始化DP表**：`dp[0][1] = m` 表示初始状态。
2. **状态转移**：在每一关后，根据当前血量和等级，选择回血或升级，更新DP表。
3. **输出结果**：遍历DP表，找到每一关后的最大等级。

通过上述思路和代码实现，可以有效地解决本题，并在类似问题中举一反三。

---
处理用时：23.84秒
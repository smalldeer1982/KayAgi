# 题目信息

# [BCSP-X 2024 6 月小学高年级组] 学习计划

## 题目描述

暑假共有 $n$ 天，第 $i$ 天的精力指数为 $a[i]$，你想要利用假期**依次（按 $1, 2, \ldots, m$ 顺序）** 复习 $m$ 门功课，第 $i$ 门功课的重要程度为 $b[i]$，且**每门功课的复习时段必须连续，并且不能有某天不干事。**

假设第 $i$ 门功课的复习时段为第 $l \sim r$ 天，那么第 $i$ 门功课的收益为 $b[i] \times (a[l] + a[l + 1] + \ldots + a[r])$，你的总收益为 $m$ 门功课收益的总和。

请你制订一个复习计划，使得总收益最大。

形式化地，给定序列 $a[1 \sim n], b[1 \sim m]$，你需要把 $1, 2, \ldots, n$ 这个序列分成首尾相连且非空的 $m$ 段，假设每段的 $a$ 之和为 $s[1 \sim m]$，最大化 $\sum_{i=1}^{m} b[i] \times s[i]$ 的值。

例如 $a = [-3, 6, -1, -8, 7, -6], b = [-3, 2]$，最优策略是第 $1 \sim 4$ 天复习第 $1$ 门功课，收益为 $-3 \times (-3 + 6 - 1 - 8) = 18$；第 $5 \sim 6$ 天复习第 $2$ 门功课，收益为 $2 \times (7 - 6) = 2$；总收益为 $18 + 2 = 20$。

例如 $a = [6, 3, 5, 10, 5], b = [-8, -5, -5]$，最优策略是分成 $[1], [2, 3, 4], [5]$ 三段，总收益为 $-8 \times 6 - 5 \times (3 + 5 + 10) - 5 \times 5 = -163$。


## 说明/提示

对于所有数据，满足 $1 \leq T \leq 20, 1 \leq m \leq n \leq 2000, -10^3 \leq a[i], b[i] \leq 10^3$。

- 对于测试点 1~7：$n \leq 10$；
- 对于测试点 8~12：$n \leq 500$；
- 对于测试点 13~16：所有 $a[i], b[i]$ 为正整数；
- 对于测试点 17~20：$n \leq 2000$；

## 样例 #1

### 输入

```
5
6 2
-3 6 -1 -8 7 -6
-3 2
5 4
-9 -6 -6 -7 -8
-5 7 -9 -3
7 7
7 2 3 0 -2 4 2
-9 -2 -5 0 -7 9 -1
5 3
10 4 6 7 4
-1 -9 2
5 3
6 3 5 10 5
-8 -5 -5```

### 输出

```
20
144
-34
-12
-163```

# AI分析结果

### 综合分析与结论

本题是一个典型的动态规划问题，要求将序列分成连续的若干段，每段的收益与段内元素和及其权重相关。由于题目要求每段必须连续且不能有空闲天，因此需要设计一个高效的动态规划算法来处理。

### 通用建议与扩展思路

1. **动态规划状态设计**：定义 `dp[i][j]` 表示前 `i` 天复习前 `j` 门功课的最大收益。状态转移时，需要考虑将第 `j` 门功课的复习时段从第 `k` 天到第 `i` 天，其中 `k` 从 `j` 到 `i` 遍历。

2. **前缀和优化**：为了快速计算任意区间的和，可以预先计算前缀和数组 `sum`，使得 `sum[i]` 表示前 `i` 天的精力指数之和。

3. **边界条件**：初始化 `dp[0][0] = 0`，表示没有天数和没有功课时的收益为 0。其他状态初始化为负无穷，表示不可达。

4. **时间复杂度优化**：由于直接遍历 `k` 会导致时间复杂度为 O(n^2 * m)，可以通过滑动窗口或其他优化手段将时间复杂度降低到 O(n * m)。

### 推荐题目

1. **P1048 [NOIP2005 普及组] 采药**：动态规划经典问题，与本题类似，需要选择物品以最大化收益。
2. **P1060 [NOIP2006 提高组] 开心的金明**：动态规划问题，涉及选择物品的收益计算。
3. **P1164 小A点菜**：动态规划问题，涉及选择物品的组合以最大化收益。

### 关键实现代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 2005;
const int INF = 1e9;

int a[MAXN], b[MAXN], sum[MAXN];
int dp[MAXN][MAXN];

int main() {
    int T;
    cin >> T;
    while (T--) {
        int n, m;
        cin >> n >> m;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
            sum[i] = sum[i - 1] + a[i];
        }
        for (int i = 1; i <= m; ++i) {
            cin >> b[i];
        }

        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j <= m; ++j) {
                dp[i][j] = -INF;
            }
        }
        dp[0][0] = 0;

        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                for (int k = j; k <= i; ++k) {
                    dp[i][j] = max(dp[i][j], dp[k - 1][j - 1] + b[j] * (sum[i] - sum[k - 1]));
                }
            }
        }

        cout << dp[n][m] << endl;
    }
    return 0;
}
```

### 代码核心思想

1. **前缀和计算**：`sum[i]` 表示前 `i` 天的精力指数之和，用于快速计算任意区间的和。
2. **动态规划状态转移**：`dp[i][j]` 表示前 `i` 天复习前 `j` 门功课的最大收益，通过遍历 `k` 来找到最优的复习时段。
3. **边界条件**：初始化 `dp[0][0] = 0`，其他状态为负无穷，表示不可达。

### 个人心得

- **调试经历**：在实现过程中，发现直接遍历 `k` 会导致超时，因此需要优化时间复杂度。
- **顿悟感想**：通过前缀和和动态规划的结合，可以高效地解决这类分段问题。

### 结论

本题通过动态规划和前缀和的结合，能够有效地解决分段收益最大化问题。关键点在于状态设计和转移方程的优化，确保算法在合理时间内完成计算。

---
处理用时：28.00秒
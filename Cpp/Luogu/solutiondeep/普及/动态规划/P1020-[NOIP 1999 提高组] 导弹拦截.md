# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果

### 综合分析与结论

本题的核心是求解两个问题：最长不上升子序列的长度和最少需要多少个不上升子序列来覆盖整个序列。大多数题解都采用了动态规划（DP）结合二分查找的优化策略，将时间复杂度从 $O(n^2)$ 降低到 $O(n \log n)$。此外，部分题解引入了 Dilworth 定理，将第二问转化为求最长上升子序列的长度，进一步简化了问题。

### 所选高质量题解

#### 1. 离散小波变换° (5星)
**关键亮点**：
- 详细解释了第一问的最长不上升子序列的优化过程，通过维护单调不增的数组 $f$，使用二分查找进行优化。
- 第二问通过贪心策略结合二分查找，证明了贪心解的最优性，并指出其与 Dilworth 定理的等价性。
- 代码简洁且高效，逻辑清晰。

**个人心得**：
- 通过贪心策略优化第二问的解法，避免了直接使用 Dilworth 定理的复杂性，提供了更直观的实现思路。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    int k = 1;
    while (k <= cnt && g[k] >= a[i]) k++;
    if (k > cnt) g[++cnt] = a[i];
    else g[k] = a[i];
}
cout << cnt << endl;
```
**实现思想**：通过贪心策略维护一个单调不增的数组 $g$，每次找到第一个小于当前高度的位置进行替换或插入。

#### 2. STA_Morlin (4.5星)
**关键亮点**：
- 详细解释了 Dilworth 定理的应用，将第二问转化为求最长上升子序列的长度。
- 提供了贪心策略的证明，确保其正确性。
- 代码实现清晰，使用了 `lower_bound` 和 `upper_bound` 进行二分查找优化。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    if (f[xl] < a[i]) {
        xl++;
        f[xl] = a[i];
    } else {
        int k = lower_bound(f + 1, f + xl + 1, a[i]) - f;
        f[k] = a[i];
    }
}
cout << xl << endl;
```
**实现思想**：通过维护一个单调递增的数组 $f$，每次找到第一个大于等于当前高度的位置进行替换或插入。

#### 3. Otue (4星)
**关键亮点**：
- 提供了贪心策略的详细证明，确保其正确性。
- 代码实现简洁，使用了 `upper_bound` 和 `lower_bound` 进行二分查找优化。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    if (a[i] <= g[cnt]) g[++cnt] = a[i];
    else {
        int l = 1, r = cnt;
        while (l < r) {
            int mid = (l + r) >> 1;
            if (g[mid] < a[i]) r = mid;
            else l = mid + 1;
        }
        g[l] = a[i];
    }
}
cout << cnt << endl;
```
**实现思想**：通过维护一个单调不增的数组 $g$，每次找到第一个小于当前高度的位置进行替换或插入。

### 最优关键思路与技巧
1. **二分查找优化**：通过维护单调数组，使用二分查找将时间复杂度从 $O(n^2)$ 降低到 $O(n \log n)$。
2. **贪心策略**：在第二问中，通过贪心策略选择最小的可拦截系统进行拦截，确保系统数量最少。
3. **Dilworth 定理**：将第二问转化为求最长上升子序列的长度，简化了问题。

### 可拓展之处
- 类似问题可以应用 Dilworth 定理，将问题转化为求最长链或反链的长度。
- 二分查找优化可以应用于其他需要维护单调性的问题，如最长上升子序列、最长公共子序列等。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)

### 个人心得总结
- **调试经历**：部分题解提到在实现过程中遇到二分查找边界问题，通过仔细调试解决了问题。
- **顿悟感想**：通过贪心策略和 Dilworth 定理的结合，能够更高效地解决类似问题，避免复杂的动态规划转移。

---
处理用时：32.61秒
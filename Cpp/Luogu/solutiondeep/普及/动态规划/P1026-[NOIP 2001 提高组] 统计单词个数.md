# 题目信息

# [NOIP 2001 提高组] 统计单词个数

## 题目描述

给出一个长度不超过 $200$ 的由小写英文字母组成的字母串（该字串以每行 $20$ 个字母的方式输入，且保证每行一定为 $20$ 个）。要求将此字母串分成
 $k$ 份，且每份中包含的单词个数加起来总数最大。  

每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串 `this` 中可包含 `this` 和 `is`，选用 `this` 之后就不能包含
 `th`。

单词在给出的一个不超过 $6$ 个单词的字典中。

要求输出最大的个数。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$2 \le k \le 40$，$1 \le s \le 6$。

【样例解释】
划分方案为 this / isabookyoua / reaoh

**【题目来源】**

NOIP 2001 提高组第三题

## 样例 #1

### 输入

```
1 3
thisisabookyouareaoh
4
is
a
ok
sab
```

### 输出

```
7
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何将字符串划分为 $k$ 份，使得每份中包含的单词数总和最大。难点在于如何高效地统计每个区间内的单词数，并且在划分时避免重复使用单词的首字母。题解中主要采用了动态规划（DP）的思路，结合区间匹配和状态转移来解决问题。

### 所选题解

#### 题解1：千反田（5星）
**关键亮点：**
1. **动态规划思路清晰**：通过定义状态 $f[i][j]$ 表示在第 $i$ 个字母后放置第 $j$ 个分割线时的最大单词数，状态转移方程明确。
2. **区间匹配优化**：通过 `query` 函数统计区间内的单词数，并利用 `trace` 数组标记已使用的单词首字母，避免重复匹配。
3. **代码可读性强**：代码结构清晰，注释详细，便于理解。

**个人心得：**
- 作者提到第一次提交时忘记注释掉调试代码，但仍然获得了部分分数，提醒我们在提交前要仔细检查代码。

**核心代码：**
```cpp
inline int query(int l,int r){ 
	rep(i,l,r)
	 trace[i]=false;
	int res=0;
	rep(i,1,s)
	 if(r-l+1>=strlen(word[i]+1))
	  res+=cnt(i,l,r);
	return res;
}

void calc(){
	rep(i,1,n-1)
     f[i][1]=query(1,i);
    rep(j,2,k)
     rep(i,j,n-1)
      rep(l,j-1,i-1)
       f[i][j]=max(f[i][j],f[l][j-1]+query(l+1,i));
    rep(i,k,n-k)
     ans=max(ans,f[i][k]+query(i+1,n));
}
```

### 最优关键思路与技巧

1. **动态规划状态定义**：通过定义 $f[i][j]$ 来表示在第 $i$ 个字母后放置第 $j$ 个分割线时的最大单词数，状态转移方程明确且易于理解。
2. **区间匹配优化**：利用 `query` 函数统计区间内的单词数，并通过 `trace` 数组标记已使用的单词首字母，避免重复匹配。
3. **代码结构清晰**：代码结构清晰，注释详细，便于理解和维护。

### 可拓展之处

1. **类似题目**：可以尝试解决其他需要划分区间并统计某种属性的问题，如最大乘积、最小代价等。
2. **算法优化**：可以考虑使用更高效的字符串匹配算法（如KMP）来优化 `query` 函数的性能。

### 推荐题目

1. **P1018 乘积最大**：与本题类似，需要将字符串划分为若干部分，使得乘积最大。
2. **P1040 加分二叉树**：通过动态规划解决树的构造问题，与本题的DP思路相似。
3. **P1052 过河**：通过动态规划解决路径选择问题，与本题的区间划分思路相似。

### 总结

本题解通过清晰的动态规划思路和优化的区间匹配方法，有效地解决了问题。代码结构清晰，注释详细，便于理解和学习。推荐在解决类似问题时参考该题解的思路和实现方法。

---
处理用时：20.56秒
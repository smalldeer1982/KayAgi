# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果

### 综合分析与结论

本题的核心在于通过数学推理和枚举优化，找到满足条件的正整数 \( x \)。大多数题解都采用了枚举 \( b_1 \) 的因数，并结合最大公约数（GCD）和最小公倍数（LCM）的性质进行验证。优化点主要集中在减少枚举范围（如只枚举到 \( \sqrt{b_1} \)）和利用数学性质进行剪枝。整体思路较为一致，但部分题解在数学推理和代码实现上更为清晰和优化。

### 精选题解

#### 1. **KesdiaelKen (5星)**
   - **关键亮点**：通过数学推理将问题转化为枚举 \( s \) 的因数，并进一步优化为枚举 \( q \) 的因数，复杂度从 \( O(\sqrt{s} \log(s) n) \) 优化到 \( O((\sqrt{s} + \log(s)) n) \)。思路清晰，代码简洁，优化到位。
   - **个人心得**：详细推导了数学结论，并通过代码实现展示了如何将理论转化为实际算法。
   - **核心代码**：
     ```cpp
     int cf(int a,int b) {
         ssqrt=sqrt(b);
         for(int i=2;i<=ssqrt;i++) {
             if(b%i==0) while(a%i==0) a/=i;
             while(b%i==0) b/=i;
         }
         if(b!=1) while(a%b==0) a/=b;
         return a;
     }
     ```
   - **总结**：通过数学推理和优化枚举，显著提升了算法效率。

#### 2. **zzlzk (4星)**
   - **关键亮点**：通过枚举 \( b_1 \) 的因数，并结合 GCD 和 LCM 的性质进行验证，思路简单直接，代码易于理解。
   - **核心代码**：
     ```cpp
     for(int x=1;x*x<=b1;x++) {
         if(b1%x==0) {
             if(x%a1==0 && gcd(x/a1,p)==1 && gcd(q,b1/x)==1) ans++;
             int y=b1/x;
             if(x==y) continue;
             if(y%a1==0 && gcd(y/a1,p)==1 && gcd(q,b1/y)==1) ans++;
         }
     }
     ```
   - **总结**：通过枚举因数和数学性质验证，代码简洁且易于实现。

#### 3. **Ebola (4星)**
   - **关键亮点**：通过唯一分解定理，对每个质因数进行分类讨论，思路清晰，代码实现较为复杂但逻辑严密。
   - **核心代码**：
     ```cpp
     if(N1 > N2 && N3 < N4) {
         if(N2 == N4) A[i] = B[i] = 1;
         else {mark = 0; break;}
     }
     ```
   - **总结**：通过质因数分解和分类讨论，确保了算法的正确性和高效性。

### 最优关键思路与技巧

1. **枚举优化**：通过枚举 \( b_1 \) 的因数，并结合 GCD 和 LCM 的性质进行验证，显著减少了枚举范围。
2. **数学推理**：利用最大公约数和最小公倍数的性质，推导出 \( x \) 必须满足的条件，进一步优化算法。
3. **质因数分解**：通过质因数分解，对每个质因数进行分类讨论，确保算法的正确性和高效性。

### 可拓展之处

1. **类似算法套路**：在处理涉及 GCD 和 LCM 的问题时，通常可以通过枚举因数和数学推理进行优化。
2. **同类型题**：可以尝试解决涉及多个数的 GCD 和 LCM 问题，或者结合其他数学性质进行优化。

### 推荐题目

1. **P1072 [NOIP2009 提高组] Hankson 的趣味题**（本题）
2. **P1447 [NOI2010] 能量采集**（涉及 GCD 的数学问题）
3. **P2158 [SDOI2008] 仪仗队**（涉及 GCD 的数学问题）

### 个人心得总结

- **调试经历**：在实现过程中，注意特判 \( x^2 = b_1 \) 的情况，避免重复计数。
- **踩坑教训**：枚举因数时，确保因数的范围正确，避免遗漏或重复。
- **顿悟感想**：通过数学推理和枚举优化，可以显著提升算法的效率，减少不必要的计算。

---
处理用时：30.79秒
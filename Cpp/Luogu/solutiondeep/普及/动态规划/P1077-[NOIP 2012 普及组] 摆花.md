# 题目信息

# [NOIP 2012 普及组] 摆花

## 题目描述

小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。

试编程计算，一共有多少种不同的摆花方案。

## 说明/提示

【数据范围】

对于 $20\%$ 数据，有 $0<n \le 8,0<m \le 8,0 \le a_i \le 8$。

对于 $50\%$ 数据，有 $0<n \le 20,0<m \le 20,0 \le a_i \le 20$。

对于 $100\%$ 数据，有 $0<n \le 100,0<m \le 100,0 \le a_i \le 100$。

NOIP 2012 普及组 第三题


## 样例 #1

### 输入

```
2 4
3 2
```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是动态规划，大部分题解都采用了二维DP的思路，状态定义为前i种花摆放j盆的方案数。不同题解在优化和实现细节上有所差异，如滚动数组、前缀和优化、生成函数等。整体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，但也有一些题解缺乏优化或解释不够详细。

### 所选高星题解

#### 1. **作者：Godのfather (赞：2376)**
- **星级：5星**
- **关键亮点**：提供了多种解题方法（搜索、记忆化、动态规划、滚动数组、背包优化、前缀和优化、生成函数），思路全面且优化到位。特别是前缀和优化和生成函数的引入，展示了从基础到高级的解题思路。
- **个人心得**：作者通过多次更新，逐步优化算法，展示了从基础搜索到高级DP的完整思考过程，适合初学者和进阶者学习。

```cpp
// 前缀和优化代码
#include<bits/stdc++.h>
using namespace std;
const int maxn = 105, mod = 1000007;
int n, m, f[maxn], sum[maxn], a[maxn];
int main(){
    cin>>n>>m;
    for(int i=1; i<=n; i++) cin>>a[i];
    f[0] = 1;
    for(int i=0; i<=m; i++) sum[i] = 1;
    for(int i=1; i<=n; i++){
        for(int j=m; j>=1; j--){
            int t = j - min(a[i], j) - 1;
            if(t < 0) f[j] = (f[j] + sum[j-1])%mod;
            else f[j] = (f[j] + sum[j-1] - sum[t] + mod)%mod;
        }
        for(int j=1; j<=m; j++) sum[j] = (sum[j-1] + f[j])%mod;
    }
    cout<<f[m]<<endl;
    return 0;
}
```

#### 2. **作者：CYJian (赞：73)**
- **星级：4星**
- **关键亮点**：简洁明了地解释了DP状态转移方程，并使用了滚动数组优化空间复杂度，代码简洁且高效。
- **个人心得**：作者强调了DP的无后效性和依赖性，适合初学者理解DP的核心思想。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1000007;
int n, m, a[105], dp[105];
int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    dp[0] = 1;
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= 1; j--)
            for(int k = 1; k <= a[i] && j - k >= 0; k++)
                dp[j] = (dp[j - k] + dp[j]) % mod;
    printf("%d\n", dp[m]);
    return 0;
}
```

#### 3. **作者：lam_dyr (赞：13)**
- **星级：4星**
- **关键亮点**：详细解释了DP的依赖性和无后效性，适合初学者理解DP的基本原理。代码实现清晰，且提供了完整的初始化说明。
- **个人心得**：作者通过分析DP的性质，帮助读者理解如何判断一个问题是否适合用DP解决。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MOD=1000007;
int dp[105][105];
int n,m;
int a[105];
int main() {
    cin>>n>>m;
    for(int i=1;i<=n;++i) 
        cin>>a[i];
    dp[0][0]=1;
    for(int i=1;i<=n;++i){
        for(int j=0;j<=m;++j){
            for(int k=0;k<=min(a[i],j);++k) 
                dp[i][j]=(dp[i][j]+dp[i-1][j-k])%MOD;
        }
    }
    cout<<dp[n][m];
    return 0;
}
```

### 最优关键思路与技巧

1. **前缀和优化**：通过前缀和将DP的时间复杂度从O(n^3)优化到O(n^2)，适用于需要频繁求和的问题。
2. **滚动数组**：通过只保留当前状态和前一个状态，将空间复杂度从O(nm)优化到O(m)，适用于状态转移只依赖前一状态的问题。
3. **生成函数**：通过生成函数将问题转化为多项式问题，适用于需要处理组合数的问题。

### 可拓展之处

- **背包问题**：本题可以看作是一种特殊的背包问题，类似的题目有P1048（采药）、P1064（金明的预算方案）。
- **组合数学**：生成函数的引入展示了组合数学在DP中的应用，类似的题目有P4389（付公主的背包）。

### 推荐相似题目

1. **P1048 采药**：经典的01背包问题，与本题的DP思路相似。
2. **P1064 金明的预算方案**：分组背包问题，与本题的优化思路相似。
3. **P4389 付公主的背包**：生成函数与DP的结合，适合进一步学习生成函数的应用。

---
处理用时：32.69秒
# 题目信息

# [NOIP 2004 提高组] 合唱队形

## 题目描述

$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。

合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1< \cdots <t_i>t_{i+1}>$ … $>t_k(1\le i\le k)$。

你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

## 说明/提示

对于 $50\%$ 的数据，保证有 $n \le 20$。

对于全部的数据，保证有 $n \le 100$。


## 样例 #1

### 输入

```
8
186 186 150 200 160 130 197 220
```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论

本题的核心是求解一个序列的最长合唱队形，即找到一个峰值，使得序列在该点之前是严格递增的，之后是严格递减的。题解中普遍采用了动态规划的思路，分别计算每个位置的最长上升子序列和最长下降子序列，然后通过两者的结合来求解最终答案。

### 所选高星题解

#### 题解1：shinzanmono (4星)
- **关键亮点**：
  - 使用了动态规划的思想，分别计算每个位置的最长上升子序列和最长下降子序列。
  - 通过 `f_i` 和 `g_i` 的结合，直接求解出最少需要出列的同学数。
  - 提到了优化到 $O(n\log n)$ 的可能性，虽然没有详细展开，但为后续优化提供了思路。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      f[i] = 1;
      for (int j = 1; j < i; j++) {
          if (a[j] < a[i]) {
              f[i] = max(f[i], f[j] + 1);
          }
      }
  }
  for (int i = n; i >= 1; i--) {
      g[i] = 1;
      for (int j = n; j > i; j--) {
          if (a[j] < a[i]) {
              g[i] = max(g[i], g[j] + 1);
          }
      }
  }
  int ans = 0;
  for (int i = 1; i <= n; i++) {
      ans = max(ans, f[i] + g[i] - 1);
  }
  cout << n - ans << endl;
  ```
  - **实现思想**：分别计算每个位置的最长上升子序列 `f_i` 和最长下降子序列 `g_i`，然后通过 `f_i + g_i - 1` 找到最长的合唱队形，最后用总人数减去这个值得到需要出列的人数。

### 最优关键思路与技巧

1. **动态规划**：通过分别计算最长上升子序列和最长下降子序列，将问题分解为两个子问题，最后结合两者求解。
2. **优化思路**：虽然题解中未详细展开，但提到了可以通过二分查找将时间复杂度优化到 $O(n\log n)$，这是值得进一步探索的方向。

### 可拓展之处

- **类似问题**：最长上升子序列、最长下降子序列、最长回文子序列等问题都可以通过类似的动态规划思路解决。
- **优化技巧**：在动态规划中，通过二分查找或其他优化手段，可以将时间复杂度从 $O(n^2)$ 降低到 $O(n\log n)$。

### 推荐题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)

### 个人心得总结

- **调试经历**：在实现动态规划时，需要注意边界条件的处理，特别是 `f_i` 和 `g_i` 的初始化。
- **踩坑教训**：在计算最长下降子序列时，容易忽略从后向前遍历的顺序，导致结果错误。
- **顿悟感想**：通过将问题分解为两个子问题，可以更清晰地理解问题的本质，从而更容易找到解决方案。

---
处理用时：21.51秒
# 题目信息

# 最大子树和

## 题目描述

小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：

一株奇怪的花卉，上面共连有 $N$ 朵花，共有 $N-1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。

老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。

## 说明/提示

### 数据范围及约定

- 对于 $60\%$ 的数据，有 $1\le N\le 1000$；
- 对于 $100\%$ 的数据，有 $1\le N\le 16000$。

## 样例 #1

### 输入

```
7
-1 -1 -1 1 1 1 0
1 4
2 5
3 6
4 7
5 7
6 7
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心是通过树形DP求解最大子树和，主要思路是通过DFS遍历树，计算每个节点为根的子树的最大和，并在遍历过程中进行剪枝（即不选择负贡献的子树）。大多数题解都采用了类似的状态转移方程，即 `f[u] = a[u] + sum(max(0, f[v]))`，其中 `f[u]` 表示以 `u` 为根的子树的最大和，`a[u]` 是节点 `u` 的权值，`v` 是 `u` 的子节点。

不同题解的主要区别在于实现细节和优化方式，如是否使用链式前向星、是否使用记忆化搜索、是否考虑双向边的处理等。整体来看，Mutsumi_0114 的题解思路清晰、代码简洁，且对状态转移的解释较为详细，因此评分较高。

### 所选高星题解

#### 1. 题解作者：Mutsumi_0114 (★★★★★)
- **关键亮点**：
  - 状态转移方程清晰，解释详细。
  - 代码简洁，使用 `vector` 存储树结构，易于理解。
  - 通过 `max(0, f[v])` 进行剪枝，避免负贡献的子树。
- **个人心得**：
  - 作者强调了选择任意节点为根对结果没有影响，因为任何连通分量都可以看作以某个节点为根的树。
  
**核心代码**：
```cpp
void dfs(int u, int fa) {
    f[u] = a[u]; // 初始化f[u]为节点u的权值
    for (int i = 0; i < E[u].size(); i++) {
        int v = E[u][i];
        if (v != fa) {
            dfs(v, u); // 递归处理子节点
            if (f[v] > 0) f[u] += f[v]; // 如果子树的贡献为正，则累加
        }
    }
}
```

#### 2. 题解作者：FCBM71 (★★★★☆)
- **关键亮点**：
  - 使用两个状态数组 `fy` 和 `fn` 分别记录包含和不包含当前节点的最大子树和。
  - 通过 `fn` 数组逐步传递答案，避免了遍历 `fy` 数组的额外开销。
  - 使用链式前向星存储树结构，优化了空间复杂度。
  
**核心代码**：
```cpp
void dfs(int x, int fa) {
    for (int i = head[x]; i; i = nxt[i]) {
        if (to[i] == fa) continue;
        dfs(to[i], x);
        if (fy[to[i]] > 0) fy[x] += fy[to[i]]; // 累加正贡献的子树
        tomax(fn[x], fn[to[i]]);
        tomax(fn[x], fy[to[i]]);
    }
}
```

#### 3. 题解作者：Tomwsc (★★★★☆)
- **关键亮点**：
  - 使用二维数组 `dp[i][2]` 分别记录包含和不包含当前节点的最大子树和。
  - 状态转移方程清晰，代码实现简洁。
  - 通过 `max(dp[v][1], dp[v][0])` 进行子树的选择，灵活性较高。
  
**核心代码**：
```cpp
void dfs(int u, int fa) {
    dp[u][1] = a[u]; // 初始化包含当前节点的子树和
    for (int i = 0; i < m[u].size(); i++) {
        int v = m[u][i];
        if (v == fa) continue;
        dfs(v, u);
        dp[u][0] = max(dp[u][0], max(dp[v][1], dp[v][0])); // 不包含当前节点的子树和
        dp[u][1] = max(dp[u][1], dp[v][1] + dp[u][1]); // 包含当前节点的子树和
    }
}
```

### 最优关键思路与技巧

1. **状态转移方程**：`f[u] = a[u] + sum(max(0, f[v]))`，通过剪枝避免负贡献的子树。
2. **树的存储结构**：使用 `vector` 或链式前向星存储树结构，便于遍历。
3. **记忆化搜索**：通过记录子树的最大和，避免重复计算。
4. **双向边的处理**：在DFS时通过传入父节点参数，避免重复访问。

### 可拓展之处

- **类似题目**：P1352 没有上司的舞会（树形DP，状态转移类似）。
- **优化思路**：可以考虑使用记忆化搜索或链式前向星进一步优化空间和时间复杂度。

### 推荐题目

1. P1352 没有上司的舞会（树形DP）
2. P2015 二叉苹果树（树形DP，带权边）
3. P2014 选课（树形DP，依赖关系）

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现双向边的处理不当导致死循环，提醒在DFS时要注意传入父节点参数。
- **顿悟感想**：通过树形DP，可以将问题转化为子问题的递归求解，关键在于设计好状态转移方程和剪枝策略。

---
处理用时：37.70秒
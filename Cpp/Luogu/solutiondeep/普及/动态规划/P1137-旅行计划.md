# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过拓扑排序和动态规划（DP）来解决有向无环图（DAG）中的最长路径问题。大多数题解都采用了拓扑排序+DP的思路，部分题解还引入了记忆化搜索或反向建图的技巧。拓扑排序确保了在计算每个节点的最长路径时，其所有前驱节点的路径已经计算完毕，从而满足DP的无后效性。记忆化搜索则通过递归的方式避免了重复计算，适合处理较大的图。

### 所选高质量题解

#### 1. 作者：星星之火 (5星)
- **关键亮点**：详细解释了拓扑排序的性质及其与DP的结合，代码清晰且注释详细，适合初学者理解。
- **个人心得**：强调了拓扑排序的无后效性，并解释了为什么拓扑排序适合用于DP问题。
- **核心代码**：
  ```cpp
  void topsort() {
      queue<int> q;
      for (int i = 1; i <= n; i++)
          if (ru[i] == 0) q.push(i);
      while (!q.empty()) {
          int u = q.front(); q.pop();
          for (int i = head[u]; i; i = edge[i].next) {
              int v = edge[i].to;
              ru[v]--;
              if (ru[v] == 0) q.push(v);
          }
      }
  }
  ```

#### 2. 作者：_ZZH (4.5星)
- **关键亮点**：简洁明了，直接在拓扑排序过程中进行DP，代码量少且高效。
- **核心代码**：
  ```cpp
  while (!q.empty()) {
      int cnt = q.front(); q.pop();
      for (int i = lin[cnt]; i; i = e[i].next) {
          f[e[i].to] = max(f[e[i].to], f[cnt] + 1);
          if (--in[e[i].to] == 0) q.push(e[i].to);
      }
  }
  ```

#### 3. 作者：归山_ (4星)
- **关键亮点**：采用了反向建图和记忆化搜索的思路，提供了另一种解题视角。
- **核心代码**：
  ```cpp
  int dfs(int x) {
      if (dp[x] != -1) return dp[x];
      dp[x] = 1;
      for (int i = head[x]; i; i = e[i].next) {
          int y = e[i].to;
          dp[x] = max(dp[x], dfs(y) + 1);
      }
      return dp[x];
  }
  ```

### 最优关键思路与技巧

1. **拓扑排序+DP**：通过拓扑排序确保DP的无后效性，适用于DAG中的最长路径问题。
2. **记忆化搜索**：通过递归和缓存中间结果，避免重复计算，适合处理较大的图。
3. **反向建图**：通过反向建图，将问题转化为从终点出发的路径问题，简化了DP的状态转移。

### 可拓展之处

- **类似问题**：可以扩展到其他DAG相关的问题，如最短路径、关键路径等。
- **算法套路**：拓扑排序+DP的套路可以应用于其他需要按顺序处理节点的图论问题。

### 推荐题目

1. **P1137 旅行计划**（本题）
2. **P4017 最大食物链计数**（拓扑排序+DP）
3. **P3387 缩点**（强连通分量+拓扑排序）

### 个人心得总结

- **调试经历**：部分题解提到了在调试过程中遇到的入度为0的点不止一个的问题，提醒了在初始化时要考虑所有可能的起点。
- **顿悟感想**：通过拓扑排序和DP的结合，能够有效解决DAG中的最长路径问题，理解了无后效性的重要性。

通过这些题解，可以深入理解拓扑排序和DP在图论问题中的应用，并掌握多种解题技巧。

---
处理用时：28.85秒
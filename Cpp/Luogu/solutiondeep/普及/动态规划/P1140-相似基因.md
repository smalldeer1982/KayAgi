# 题目信息

# 相似基因

## 题目背景

大家都知道，基因可以看作一个碱基对序列。它包含了 $4$ 种核苷酸，简记作 `A, C, G, T`。生物学家正致力于寻找人类基因的功能，以利用于诊断疾病和发明药物。

在一个人类基因工作组的任务中，生物学家研究的是：两个基因的相似程度。因为这个研究对疾病的治疗有着非同寻常的作用。

## 题目描述

两个基因的相似度的计算方法如下：

对于两个已知基因，例如 `AGTGATG` 和 `GTTAG`，将它们的碱基互相对应。当然，中间可以加入一些空碱基 `-`，例如：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\tt A & \tt G & \tt T & \tt G & \tt A & \tt T & \texttt - & \tt G \\ \hline
\texttt - & \tt G & \tt T & \texttt - & \texttt - & \tt T & \texttt A & \tt G \\ \hline
\end{array}
$$

这样，两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示：

$$
\def\arraystretch{1.5}
\begin{array}{ |c|c|c|c|c|c|} \hline
& \tt A & \tt C & \tt G & \tt T & \texttt - \\ \hline
\tt A & 5 & -1 & -2 & -1 & -3\\ \hline
\tt C & -1 & 5 & -3 & -2 & -4 \\\hline
\tt G & -2 & -3 & 5 & -2 & -2 \\\hline
\tt T & -1 & -2 & -2 & 5 & -1 \\\hline
\texttt - & -3 & -4 & -2 & -1 & * \\\hline
\end{array}
$$ 

那么相似度就是：$(-3)+5+5+(-2)+(-3)+5+(-3)+5=9$。因为两个基因的对应方法不唯一，例如又有：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|} \hline
\tt A & \tt G & \tt T & \tt G & \tt A & \tt T & \tt G \\ \hline
\texttt - & \tt G & \tt T & \texttt T & \texttt A & \texttt - & \tt G \\ \hline
\end{array}
$$

相似度为：$(-3)+5+5+(-2)+5+(-1)+5=14$。规定两个基因的相似度为所有对应方法中，相似度最大的那个。


## 样例 #1

### 输入

```
7 AGTGATG
5 GTTAG
```

### 输出

```
14
```

# AI分析结果

### 综合分析与结论

本题的核心是动态规划（DP），主要难点在于状态的定义和转移方程的构建。所有题解都采用了二维DP的思路，状态定义为 `f[i][j]`，表示第一个基因的前 `i` 个碱基与第二个基因的前 `j` 个碱基的最大相似度。转移方程则基于三种可能的匹配方式：直接匹配、插入空碱基到第一个基因、插入空碱基到第二个基因。

大部分题解的思路相似，但在代码实现、边界处理、初始化等方面有所不同。部分题解在状态转移时进行了优化，如使用滚动数组或记忆化搜索，但整体思路一致。

### 所选高星题解

#### 1. 作者：zhy137036 (5星)
**关键亮点：**
- **思路清晰**：详细解释了DP的五个步骤，包括状态定义、转移方程、递推顺序、边界处理和结果输出。
- **代码可读性高**：代码结构清晰，注释详细，易于理解。
- **优化建议**：虽然没有使用滚动数组，但代码逻辑严谨，适合初学者理解。

**个人心得：**
作者提到在写代码时经常急于实现，导致代码混乱，建议在完成所有思考步骤后再写代码。这一建议对初学者非常有帮助。

**核心代码：**
```cpp
for(int i=1;i<=la;i++)
    for(int j=1;j<=lb;j++)
        f[i][j]=max(f[i-1][j-1]+d[a[i]][b[j]],max(f[i-1][j]+d[a[i]][5],f[i][j-1]+d[5][b[j]]));
```

#### 2. 作者：Segment_Tree (4星)
**关键亮点：**
- **简洁明了**：代码简洁，直接给出了状态转移方程和预处理步骤。
- **优化技巧**：使用了 `max` 函数简化了状态转移的写法。

**核心代码：**
```cpp
for(int i=1;i<=la;i++)
    for(int j=1;j<=lb;j++)
        dp[i][j]=max(dp[i][j],max(dp[i][j-1]+tab[b[j]][4],max(dp[i-1][j]+tab[a[i]][4],dp[i-1][j-1]+tab[a[i]][b[j]])));
```

#### 3. 作者：Ykimna (4星)
**关键亮点：**
- **详细解释**：通过图示和例子详细解释了状态转移的过程，帮助理解。
- **边界处理**：特别强调了边界条件的处理，避免了常见的错误。

**个人心得：**
作者提到答案可能为负值，因此需要将DP数组初始化为一个较大的负值，这一点在实际应用中容易被忽略。

**核心代码：**
```cpp
for(int i=1;i<=la;i++)
    for(int j=1;j<=lb;j++)
        dp[i][j]=max(dp[i][j],max(dp[i-1][j]+v[a[i]][5],max(dp[i][j-1]+v[5][b[j]],dp[i-1][j-1]+v[a[i]][b[j]])));
```

### 最优关键思路与技巧

1. **状态定义**：`f[i][j]` 表示第一个基因的前 `i` 个碱基与第二个基因的前 `j` 个碱基的最大相似度。
2. **转移方程**：基于三种匹配方式，取最大值。
3. **边界处理**：初始化 `f[0][0] = 0`，并分别处理 `f[i][0]` 和 `f[0][j]`。
4. **优化技巧**：可以使用滚动数组或记忆化搜索来优化空间复杂度。

### 可拓展之处

本题的DP思路可以应用于其他序列匹配问题，如最长公共子序列（LCS）、编辑距离等。类似的题目可以通过调整状态定义和转移方程来解决。

### 推荐题目

1. **P1140 相似基因**（本题）
2. **P1439 最长公共子序列**（LCS问题）
3. **P2758 编辑距离**（编辑距离问题）
4. **P1091 合唱队形**（序列匹配与DP结合）

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中遇到边界处理不当或初始化错误的问题，建议在编写代码时特别注意这些细节。
- **顿悟感想**：通过最长公共子序列的迁移思想，可以更好地理解本题的DP思路，这种迁移思维在解决类似问题时非常有用。

---
处理用时：31.66秒
# 题目信息

# 木棍加工

## 题目描述

一堆木头棍子共有 $n$ 根，每根棍子的长度和宽度都是已知的。棍子可以被一台机器一个接一个地加工。机器处理一根棍子之前需要准备时间。准备时间是这样定义的：

- 第一根棍子的准备时间为 $1$ 分钟。
- 如果刚处理完长度为 $l$，宽度为 $w$ 的棍子，那么如果下一个棍子长度为 $l_i$，宽度为 $w_i$，并且满足 $l\ge l_i$、$w\ge w_i$，这个棍子就不需要准备时间，否则需要 $1$ 分钟的准备时间。

计算处理完 $n$ 根棍子所需要的最短准备时间。比如，你有 $5$ 根棍子，长度和宽度分别为 $(4,9),(5,2),(2,1),(3,5),(1,4)$，最短准备时间为 $2$（按 $(4,9),(3,5),(1,4),(5,2),(2,1)$ 的次序进行加工）。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 5000$，$1 \le l_i, w_i \le {10}^4$。

## 样例 #1

### 输入

```
5
4 9 5 2 2 1 3 5 1 4
```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心在于通过排序和贪心或动态规划来最小化木棍加工的准备时间。大多数题解都采用了先按长度或宽度排序，然后通过贪心或动态规划来计算最短准备时间的策略。其中，**贪心算法**和**最长上升子序列（LIS）**是解决该问题的关键思路。

### 所选高星题解

#### 1. 学无止境 (5星)
**关键亮点**：
- 详细解释了排序的必要性，特别是按长度降序、长度相同时按宽度降序的排序策略。
- 通过Dilworth定理将问题转化为求最长上升子序列（LIS），并提供了O(nlogn)的优化解法。
- 代码清晰，使用了二分查找优化LIS的计算。

**个人心得**：
- 强调了排序时按宽度降序的重要性，避免了某些特殊情况下的错误。

**核心代码**：
```cpp
sort(a+1,a+1+n,cmp);
for(register int i=1;i<=n;i++) {
    if(a[i].w>f[ans])
        f[++ans]=a[i].w;
    else {
        int tmp=lower_bound(f+1,f+1+ans,a[i].w)-f;
        f[tmp]=a[i].w;
    }
}
```

#### 2. CYJian (4星)
**关键亮点**：
- 使用`set`数据结构来维护每个序列的末端木棍宽度，简化了贪心算法的实现。
- 通过`lower_bound`找到第一个大于等于当前木棍宽度的木棍，优化了贪心策略。

**核心代码**：
```cpp
set<P>a;
set<P>::iterator it;
for(int i=1;i<=n;i++) {
    if(a.empty()) a.insert(s[i]), ans++;
    else {
        it = a.lower_bound(s[i]);
        if(it == a.end()) a.insert(s[i]), ans++;
        else a.erase(it), a.insert(s[i]);
    }
}
```

#### 3. MRZMRZ (4星)
**关键亮点**：
- 通过贪心策略，每次将木棍加入到第一个满足条件的序列中，减少了准备时间。
- 提供了详细的贪心策略解释，并指出了贪心算法的正确性。

**核心代码**：
```cpp
for(int i=2;i<=n;i++) {
    bool bo=0;
    for(int j=1;j<=ans;j++) {
        if(a[i].x<=ls[j].x&&a[i].y<=ls[j].y) {
            ls[j]=a[i];
            bo=1;
            break;
        }
    }
    if(bo==0) {
        ans++;
        ls[ans]=a[i];
    }
}
```

### 最优关键思路与技巧
1. **排序策略**：按长度降序、长度相同时按宽度降序排序，确保后续处理时能够尽可能减少准备时间。
2. **贪心算法**：通过维护序列的末端木棍宽度，将木棍加入到第一个满足条件的序列中，减少准备时间。
3. **最长上升子序列（LIS）**：通过Dilworth定理将问题转化为求LIS，并使用二分查找优化LIS的计算。

### 可拓展之处
- **类似问题**：导弹拦截问题（P1020）与本题类似，都是通过排序和贪心或动态规划来求解最小分组数。
- **算法套路**：排序+贪心或动态规划是解决类似问题的常见套路，适用于需要最小化分组或准备时间的问题。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.org/problem/P1020)
2. [P1091 合唱队形](https://www.luogu.org/problem/P1091)
3. [P1280 尼克的任务](https://www.luogu.org/problem/P1280)

### 个人心得总结
- **调试经历**：在贪心算法中，顺序或倒序遍历序列可能会导致不同的结果，需要仔细验证。
- **踩坑教训**：排序时忽略宽度降序会导致某些特殊情况下的错误，需特别注意。
- **顿悟感想**：通过Dilworth定理将问题转化为LIS，极大地简化了问题的解决思路。

---
处理用时：27.67秒
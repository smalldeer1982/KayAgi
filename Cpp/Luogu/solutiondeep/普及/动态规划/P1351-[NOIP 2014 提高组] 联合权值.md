# 题目信息

# [NOIP 2014 提高组] 联合权值

## 题目背景

NOIP2014 提高组 D1T2

## 题目描述

无向连通图 $G$ 有 $n$ 个点，$n-1$ 条边。点从 $1$ 到 $n$ 依次编号,编号为 $i$ 的点的权值为 $W_i$，每条边的长度均为 $1$。图上两点 $(u, v)$ 的距离定义为 $u$ 点到 $v$ 点的最短距离。对于图 $G$ 上的点对 $(u, v)$，若它们的距离为 $2$，则它们之间会产生 $W_v \times W_u$ 的联合权值。

请问图 $G$ 上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？

## 说明/提示

**样例解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/5zkpab9k.png)

本例输入的图如上所示，距离为 $2$ 的有序点对有$(1,3)$ 、$(2,4)$ 、$(3,1)$ 、$(3,5) $、$(4,2)$ 、$(5,3) $。

其联合权值分别为 $2,15,2,20,15,20$。其中最大的是 $20$，总和为 $74$。

 
**数据说明**

- 对于 $30\%$ 的数据，$1 < n \leq 100$；
- 对于 $60\%$ 的数据，$1 < n \leq 2000$；
- 对于 $100\%$ 的数据，$1 < n \leq 2\times 10^5$，$0 < W_i \leq 10000$。

保证一定存在可产生联合权值的有序点对。

## 样例 #1

### 输入

```
5  
1 2  
2 3
3 4  
4 5  
1 5 2 3 10 ```

### 输出

```
20 74```

# AI分析结果

### 综合分析与结论

本题的核心是求树上所有距离为2的点对的联合权值之和及其最大值。多数题解通过枚举中转点，利用数学公式优化计算，避免了直接枚举所有点对的复杂度。关键思路包括：
1. **中转点枚举**：通过枚举每个节点作为中转点，计算其邻居节点之间的联合权值。
2. **数学优化**：利用和的平方与平方和的差来快速计算联合权值之和，避免直接枚举所有点对。
3. **最大值维护**：通过维护每个节点的最大和次大权值，快速找到联合权值的最大值。

### 所选高星题解

#### 1. 作者：wucstdio (赞：291)  
**星级：5星**  
**关键亮点**：
- 思路清晰，详细解释了如何通过枚举中转点并利用数学公式优化计算。
- 代码简洁，逻辑清晰，易于理解。
- 特别提醒了最大联合权值不能取模，避免了常见错误。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
{
    int max1=0,max2=0;//最大的两个权值
    int t1=0,t2=0;//t1代表和的平方，t2代表平方和
    for(int j=head[i];j;j=a[j].next)
    {
        if(w[a[j].to]>max1)max2=max1,max1=w[a[j].to];
        else if(w[a[j].to]>max2)max2=w[a[j].to];
        t1=(t1+w[a[j].to])%10007;
        t2=(t2+w[a[j].to]*w[a[j].to])%10007;
    }
    t1=t1*t1%10007;
    ans=(ans+t1+10007-t2)%10007;
    if(maxx<max1*max2)maxx=max1*max2;
}
```
**核心思想**：通过枚举每个节点作为中转点，计算其邻居节点的权值和的平方与平方和的差，得到联合权值之和。同时维护最大和次大权值，计算最大联合权值。

#### 2. 作者：albertting (赞：2)  
**星级：4星**  
**关键亮点**：
- 通过数学推导简化了联合权值之和的计算，思路清晰。
- 代码实现简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
{
    long long max1 = 0, max2 = 0;
    long long sum1 = 0, sum2 = 0;
    for(auto i : mp[x])
    {
        if(w[i] >= max1) max2 = max1, max1 = w[i];
        else if(w[i] >= max2) max2 = w[i];
        sum1 += w[i];
        sum2 += w[i] * w[i];
    }
    ans1 = max(ans1, max1 * max2);
    ans2 += sum1 * sum1 - sum2;
    ans2 %= 10007;
}
```
**核心思想**：通过枚举每个节点作为中转点，计算其邻居节点的权值和的平方与平方和的差，得到联合权值之和。同时维护最大和次大权值，计算最大联合权值。

#### 3. 作者：CaiZi (赞：1)  
**星级：4星**  
**关键亮点**：
- 通过数学推导简化了联合权值之和的计算，思路清晰。
- 代码实现简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
{
    x=y=0;
    for(int j:g[i])
    {
        if(w[j]>w[x]) x=j;
    }
    for(int j:g[i])
    {
        if(w[j]>w[y]&&j!=x) y=j;
    }
    s1=max(s1,w[x]*w[y]);
    x=y=0;
    for(int j:g[i])
    {
        x=(x+w[j])%mod;
        y=(y+w[j]*w[j])%mod;
    }
    s2=(s2+x*x%mod-y+mod)%mod;
}
```
**核心思想**：通过枚举每个节点作为中转点，计算其邻居节点的权值和的平方与平方和的差，得到联合权值之和。同时维护最大和次大权值，计算最大联合权值。

### 最优关键思路与技巧

1. **中转点枚举**：通过枚举每个节点作为中转点，计算其邻居节点之间的联合权值。
2. **数学优化**：利用和的平方与平方和的差来快速计算联合权值之和，避免直接枚举所有点对。
3. **最大值维护**：通过维护每个节点的最大和次大权值，快速找到联合权值的最大值。

### 可拓展之处

类似的问题可以扩展到更复杂的图结构或更长的路径长度。例如，计算距离为3的点对的联合权值，可以通过类似的枚举中转点的方法，结合动态规划或树形DP来解决。

### 推荐题目

1. [P1351 联合权值](https://www.luogu.com.cn/problem/P1351)
2. [P1395 树的直径](https://www.luogu.com.cn/problem/P1395)
3. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)

### 个人心得总结

- **调试经历**：在计算联合权值之和时，容易忽略取模操作，导致结果错误。需要特别注意取模的位置和方式。
- **踩坑教训**：最大联合权值不能取模，否则会导致错误结果。
- **顿悟感想**：通过数学公式优化计算，可以大幅减少时间复杂度，提升算法效率。

---
处理用时：38.10秒
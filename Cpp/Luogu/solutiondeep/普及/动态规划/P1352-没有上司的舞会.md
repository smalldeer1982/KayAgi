# 题目信息

# 没有上司的舞会

## 题目描述

某大学有 $n$ 个职员，编号为 $1\ldots n$。

他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。

现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。

所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。

## 样例 #1

### 输入

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

### 输出

```
5
```

# AI分析结果

### 综合分析与结论

本题“没有上司的舞会”是一道经典的树形动态规划（Tree DP）问题，核心在于如何在树结构中进行状态转移。大多数题解都采用了类似的思路：定义 `dp[i][0]` 和 `dp[i][1]` 分别表示节点 `i` 不参加和参加舞会时的最大快乐值，并通过递归或拓扑排序的方式从叶子节点向根节点进行状态转移。部分题解还提到了优化技巧，如拓扑排序、记忆化搜索等。

### 所选高星题解

#### 1. **题解作者：BlueArc (赞：450)**
   - **星级：5星**
   - **关键亮点**：
     - 思路清晰，状态定义明确：`f[x][0]` 表示 `x` 不参加舞会时的最大快乐值，`f[x][1]` 表示 `x` 参加舞会时的最大快乐值。
     - 代码简洁，使用了邻接表存储树结构，并通过递归实现状态转移。
     - 提供了完整的代码实现，易于理解和复现。
   - **个人心得**：
     - 通过递归实现树形DP，代码逻辑清晰，适合初学者理解树形DP的基本框架。

```cpp
void dp(int x) {
    f[x][0] = 0;
    f[x][1] = h[x];
    for (int i = 0; i < son[x].size(); i++) {
        int y = son[x][i];
        dp(y);
        f[x][0] += max(f[y][0], f[y][1]);
        f[x][1] += f[y][0];
    }
}
```

#### 2. **题解作者：moye到碗里来 (赞：220)**
   - **星级：4星**
   - **关键亮点**：
     - 详细解释了树形DP的状态转移方程，并提供了多种实现方式（DFS、BFS、拓扑排序）。
     - 强调了树形DP的后效性问题，并通过加一维状态来解决。
     - 提供了BFS和拓扑排序的代码实现，适合进阶学习者。
   - **个人心得**：
     - 通过BFS和拓扑排序避免了DFS的爆栈问题，适合处理大规模数据。

```cpp
void bfs(int s) {
    q.push(s);
    vis[s] = 1;
    que[++t] = s;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = 0; i < son[u].size(); i++) {
            int v = son[u][i];
            if (!vis[v]) {
                vis[v] = 1;
                q.push(v);
                que[++t] = v;
            }
        }
    }
}
```

#### 3. **题解作者：我没有小白 (赞：153)**
   - **星级：4星**
   - **关键亮点**：
     - 提供了树形DP的基本概念和实现形式，适合初学者理解。
     - 通过选择节点类和树形背包类的DP方程，扩展了树形DP的应用场景。
     - 提供了多个例题的代码实现，帮助读者举一反三。
   - **个人心得**：
     - 通过多个例题的讲解，帮助读者深入理解树形DP的多种应用场景。

```cpp
void work(int x) {
    dp[x][0] = 0;
    dp[x][1] = a[x];
    for (int i = 0; i < son[x].size(); i++) {
        int y = son[x][i];
        work(y);
        dp[x][0] += max(dp[y][0], dp[y][1]);
        dp[x][1] += dp[y][0];
    }
}
```

### 最优关键思路与技巧

1. **状态定义**：树形DP的核心在于合理定义状态，通常使用 `dp[i][0]` 和 `dp[i][1]` 分别表示节点 `i` 不参加和参加时的最大收益。
2. **递归与拓扑排序**：递归是树形DP的常见实现方式，但对于大规模数据，拓扑排序可以避免爆栈问题。
3. **邻接表存储**：使用邻接表存储树结构，便于遍历子节点。

### 拓展与举一反三

1. **类似题目**：
   - [P2015 二叉苹果树](https://www.luogu.org/problem/P2015)：树形DP与背包问题的结合。
   - [P1122 最大子树和](https://www.luogu.org/problem/P1122)：树形DP求最大子树和。
   - [P2014 选课](https://www.luogu.org/problem/P2014)：树形DP与背包问题的结合。

2. **个人心得总结**：
   - 树形DP的关键在于状态定义和转移方程的合理性，递归实现简单但可能爆栈，拓扑排序适合大规模数据。
   - 通过多个例题的练习，可以更好地掌握树形DP的应用场景和优化技巧。

---
处理用时：41.29秒
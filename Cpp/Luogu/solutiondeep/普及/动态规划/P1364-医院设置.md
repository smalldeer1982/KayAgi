# 题目信息

# 医院设置

## 题目描述

设有一棵二叉树，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/kawht13x.png)

其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在 $1$ 处，则距离和 $=4+12+2\times20+2\times40=136$；若医院建在 $3$ 处，则距离和 $=4\times2+13+20+40=81$。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 100$，$0 \leq u, v \leq n$，$1 \leq w \leq 10^5$。

## 样例 #1

### 输入

```
5						
13 2 3
4 0 0
12 4 5
20 0 0
40 0 0
```

### 输出

```
81```

# AI分析结果

### 综合分析与结论

本题的核心问题是在一棵二叉树中找到一个节点，使得所有节点到该节点的距离与节点权值的乘积之和最小。题解中主要涉及以下几种思路：

1. **暴力枚举 + DFS/BFS**：通过枚举每个节点作为医院的位置，计算所有节点到该节点的距离，并求和。时间复杂度为 \(O(n^2)\)，适用于数据规模较小的情况。
2. **Floyd算法**：通过Floyd算法预处理所有节点之间的最短路径，然后枚举每个节点作为医院的位置，计算总距离。时间复杂度为 \(O(n^3)\)，适用于数据规模较小的情况。
3. **树的重心 + 树形DP**：利用树的重心性质，通过树形DP在 \(O(n)\) 时间内找到最优解。适用于数据规模较大的情况。

最优解是使用**树的重心 + 树形DP**，时间复杂度最低且适用于大规模数据。

### 精选题解

#### 1. 作者：Huami360 (赞：551)
- **星级**：★★★★★
- **关键亮点**：使用树的重心性质，通过树形DP在 \(O(n)\) 时间内找到最优解。思路清晰，代码简洁，优化程度高。
- **个人心得**：作者提到“别人摸瓜她寻藤，别人摘叶他问根”，强调了深入理解问题本质的重要性。

**核心代码**：
```cpp
void dfs(int u, int fa, int dep) {
    size[u] = w[u];
    for(int i = head[u]; i; i = e[i].next) {
        if(e[i].to != fa)
            dfs(e[i].to, u, dep + 1), size[u] += size[e[i].to];
    }
    f[1] += w[u] * dep;
}

void dp(int u, int fa) {
    for(int i = head[u]; i; i = e[i].next) {
        if(e[i].to != fa) {
            f[e[i].to] = f[u] + size[1] - size[e[i].to] * 2;
            dp(e[i].to, u);
        }
    }
    ans = min(ans, f[u]);
}
```
**实现思想**：通过DFS预处理子树大小和总距离，然后通过DP转移计算每个节点的总距离，最终取最小值。

#### 2. 作者：lizongru (赞：30)
- **星级**：★★★★
- **关键亮点**：同样使用树的重心性质，通过树形DP在 \(O(n)\) 时间内找到最优解。代码结构清晰，优化程度较高。

**核心代码**：
```cpp
void dfs(int rt, int fa) {
    deep[rt] = deep[fa] + 1;
    for(register int i = head[rt]; i; i = e[i].next) {
        if(e[i].to == fa) continue;
        dfs(e[i].to, rt);
        pre[rt] += pre[e[i].to];
    }
}

void dp(int rt, int fa) {
    for(register int i = head[rt]; i; i = e[i].next) {
        if(e[i].to == fa) continue;
        dis[e[i].to] = dis[rt] + pre[1] - pre[e[i].to] - pre[e[i].to];
        if(dis[e[i].to] < ans) ans = dis[e[i].to];
        dp(e[i].to, rt);
    }
}
```
**实现思想**：通过DFS预处理子树大小和深度，然后通过DP转移计算每个节点的总距离，最终取最小值。

#### 3. 作者：ShineEternal (赞：165)
- **星级**：★★★★
- **关键亮点**：使用Floyd算法预处理所有节点之间的最短路径，然后枚举每个节点作为医院的位置，计算总距离。思路清晰，代码简洁。

**核心代码**：
```cpp
for(int k = 1; k <= n; k++) {
    for(int i = 1; i <= n; i++) {
        if(i != k) {
            for(int j = 1; j <= n; j++) {
                if(i != j && k != j && g[i][k] + g[k][j] < g[i][j])
                    g[i][j] = g[i][k] + g[k][j];
            }
        }
    }
}
```
**实现思想**：通过Floyd算法预处理所有节点之间的最短路径，然后枚举每个节点作为医院的位置，计算总距离。

### 最优关键思路与技巧

1. **树的重心性质**：树的重心是使得最大子树最小的节点，且所有节点到重心的距离之和最小。利用这一性质，可以通过树形DP在 \(O(n)\) 时间内找到最优解。
2. **树形DP**：通过DFS预处理子树大小和总距离，然后通过DP转移计算每个节点的总距离，最终取最小值。
3. **Floyd算法**：适用于预处理所有节点之间的最短路径，虽然时间复杂度较高，但在数据规模较小的情况下仍可使用。

### 拓展与举一反三

1. **类似问题**：树的中心点问题、最小化路径和问题等。
2. **推荐题目**：
   - P1395 会议
   - P2014 选课
   - P2015 二叉苹果树

### 个人心得总结

- **深入理解问题本质**：如Huami360所说，深入理解问题本质是解决问题的关键。
- **优化思路**：在数据规模较大的情况下，使用树的重心性质和树形DP可以显著提高算法效率。

---
处理用时：37.31秒
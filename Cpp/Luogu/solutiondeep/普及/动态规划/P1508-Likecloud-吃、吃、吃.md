# 题目信息

# Likecloud-吃、吃、吃

## 题目背景

问世间，青春期为何物？

答曰：“甲亢，甲亢，再甲亢；挨饿，挨饿，再挨饿！”


## 题目描述

正处在某一特定时期之中的李大水牛由于消化系统比较发达，最近一直处在饥饿的状态中。某日上课，正当他饿得头昏眼花之时，眼前突然闪现出了一个 $n \times m(n,m \le 200)$ 的矩型的巨型大餐桌，而自己正处在这个大餐桌的一侧的中点下边。餐桌被划分为了 $n \times m$ 个小方格，每一个方格中都有一个圆形的巨型大餐盘，上面盛满了令李大水牛朝思暮想的食物。李大水牛已将餐桌上所有的食物按其所能提供的能量打了分（有些是负的，因为吃了要拉肚子），他决定从自己所处的位置吃到餐桌的另一侧，但他吃东西有一个习惯——只吃自己前方或左前方或右前方的盘中的食物。

由于李大水牛已饿得不想动脑了，而他又想获得最大的能量，因此，他将这个问题交给了你。

每组数据的出发点都是最后一行的中间位置的下方！

## 说明/提示

快吃！快吃！快吃！


## 样例 #1

### 输入

```
6 7
16 4 3 12 6 0 3
4 -5 6 7 0 0 2
6 0 -1 -2 3 6 8
5 3 4 0 0 -2 7
-1 7 4 0 7 -5 6
0 -1 3 4 12 4 2
```

### 输出

```
41
```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）或记忆化搜索来解决李大水牛在餐桌上获取最大能量的问题。大多数题解采用了DP的思路，状态转移方程基本一致，即从当前位置的左上、正上、右上三个方向中选择最大值加上当前点的能量值。部分题解还通过记忆化搜索或优化边界条件来提高效率。

#### 关键思路与技巧：
1. **状态转移方程**：`dp[i][j] = max(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + a[i][j]`，这是DP的核心。
2. **边界处理**：部分题解通过初始化边界值为极小值或特殊处理边界条件，避免越界问题。
3. **记忆化搜索**：部分题解通过记忆化搜索来减少重复计算，适用于DP状态转移较为复杂的情况。
4. **优化空间**：部分题解直接在输入数组上进行DP，节省了额外的空间。

#### 可拓展之处：
- **类似题目**：本题与数字金字塔问题类似，都是通过DP从下往上或从上往下求解最大路径和。
- **拓展思路**：可以尝试将问题扩展到三维空间，或者增加更多的移动方向（如斜向移动）。

### 所选高星题解

#### 1. 作者：feecle6418 (★★★★★)
**关键亮点**：
- **空间优化**：直接在输入数组上进行DP，节省了额外的空间。
- **代码简洁**：边输入边处理，代码简洁且高效。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        cin>>a[i][j];
        a[i][j]+=max(a[i-1][j-1],max(a[i-1][j],a[i-1][j+1]));
    }
}
```
**个人心得**：通过直接在输入数组上进行DP，减少了代码的复杂度，同时提高了运行效率。

#### 2. 作者：2016jzy (★★★★☆)
**关键亮点**：
- **边界处理**：通过初始化边界值为极小值，避免越界问题。
- **状态转移清晰**：状态转移方程明确，代码结构清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        f[i][j]=max(max(f[i-1][j],f[i-1][j-1]),f[i-1][j+1])+a[i][j];
    }
}
```
**个人心得**：通过初始化边界值为极小值，确保DP过程中不会越界，代码结构清晰易读。

#### 3. 作者：冈崎梦美 (★★★★☆)
**关键亮点**：
- **记忆化搜索**：通过记忆化搜索减少重复计算，适用于DP状态转移较为复杂的情况。
- **边界处理**：通过初始化记忆数组为极小值，避免重复计算。

**核心代码**：
```cpp
int dfs(int x,int y){
    if(vis[x][y]) return f[x][y];
    for(int i=-1;i<=1;i++){
        if((y+i>0)&&(y+i<=n)&&(x-1>0))f[x][y]=max(f[x][y],dfs(x-1,y+i)+a[x][y]);
    }
    vis[x][y]=true;
    return f[x][y];
}
```
**个人心得**：通过记忆化搜索，减少了重复计算，提高了代码的效率。

### 推荐相似题目
1. **P1216 [USACO1.5]数字金字塔**：与本题类似，都是通过DP求解最大路径和。
2. **P1002 [NOIP2002 普及组] 过河卒**：通过DP求解路径问题，增加了障碍物的处理。
3. **P1048 [NOIP2005 普及组] 采药**：通过DP求解背包问题，与本题的DP思路类似。

---
处理用时：31.44秒
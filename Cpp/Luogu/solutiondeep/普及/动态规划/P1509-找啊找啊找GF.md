# 题目信息

# 找啊找啊找GF

## 题目背景

“找啊找啊找 GF，找到一个好 GF，吃顿饭啊拉拉手，你是我的好 GF。再见。”

“诶，别再见啊…”

七夕… 七夕… 七夕这个日子，对于 sqybi 这种单身的菜鸟来说是多么的痛苦… 虽然他听着这首叫做“找啊找啊找 GF”的歌，他还是很痛苦。为了避免这种痛苦，sqybi 决定要给自己找点事情干。他去找到了七夕模拟赛的负责人 zmc MM，让她给自己一个出题的任务。经过几天的死缠烂打，zmc MM 终于同意了。

但是，拿到这个任务的 sqybi 发现，原来出题比单身更让人感到无聊 -\_- … 所以，他决定了，要在出题的同时去办另一件能够使自己不无聊的事情——给自己找 GF。

## 题目描述

sqybi 现在看中了 $n$ 个 MM，我们不妨把她们编号 $1$ 到 $n$。请 MM 吃饭是要花钱的，我们假设请 $i$ 号 MM 吃饭要花 $rmb[i]$ 块大洋。而希望骗 MM 当自己 GF 是要费人品的，我们假设请第 $i$ 号 MM 吃饭试图让她当自己 GF 的行为（不妨称作泡该 MM）要耗费 $rp[i]$ 的人品。而对于每一个 MM 来说，sqybi 都有一个对应的搞定她的时间，对于第 $i$ 个 MM 来说叫做 $time[i]$。sqybi 保证自己有足够的魅力用 $time[i]$ 的时间搞定第 $i$ 个 MM ^\_^。

sqybi 希望搞到尽量多的 MM 当自己的 GF，这点是毋庸置疑的。但他不希望为此花费太多的时间（毕竟七夕赛的题目还没出），所以他希望在保证搞到 MM 数量最多的情况下花费的总时间最少。

sqybi 现在有 $m$ 块大洋,他也通过一段时间的努力攒到了 $r$ 的人品（这次为模拟赛出题也攒 rp 哦\~\~）。他凭借这些大洋和人品可以泡到一些 MM。他想知道，自己泡到最多的 MM 花费的最少时间是多少。

注意 sqybi 在一个时刻只能去泡一个 MM ——如果同时泡两个或以上的 MM 的话，她们会打起来的…

## 说明/提示

sqybi 说：如果题目里说的都是真的就好了…

sqybi 还说，如果他没有能力泡到任何一个 MM，那么他就不消耗时间了（也就是消耗的时间为 $0$），他要用这些时间出七夕比赛的题来攒 rp…

**【数据规模】**

对于 $20 \%$ 的数据，$1 \le n \le 10$；  
对于 $100 \%$ 的数据，$1 \le rmb \le 100$，$1 \le rp \le 100$，$1 \le time \le 1000$。  
对于 $100 \%$ 的数据，$1 \le m, r, n \le 100$。

## 样例 #1

### 输入

```
4
1 2 5
2 1 6
2 2 2
2 2 3
5 5
```

### 输出

```
13```

# AI分析结果

### 综合分析与结论

本题是一个典型的二维费用背包问题，要求在有限的RMB和RP资源下，泡到尽可能多的MM，并且在泡到最多MM的情况下，花费的时间最少。题解中大部分作者都采用了动态规划的思路，通过二维数组来记录在不同RMB和RP限制下能泡到的MM数量及对应的最小时间。部分题解还引入了结构体或额外的数组来优化状态转移。

### 所选高星题解

#### 1. 作者：Anguei (赞：165)
- **星级**：5星
- **关键亮点**：
  - 清晰地分析了题目的特殊性，指出需要两个DP数组分别记录泡到的MM数量和时间。
  - 代码简洁，逻辑清晰，易于理解。
  - 提供了额外的学习资源（洛谷题目链接），帮助读者进一步理解背包问题。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= n; ++i)
      for (int j = m; j >= rmb[i]; --j)
          for (int k = r; k >= rp[i]; --k) {
              if (dpNum[j][k] < dpNum[j - rmb[i]][k - rp[i]] + 1) {
                  dpNum[j][k] = dpNum[j - rmb[i]][k - rp[i]] + 1;
                  dpTime[j][k] = dpTime[j - rmb[i]][k - rp[i]] + time[i];
              }
              else if (dpNum[j][k] == dpNum[j - rmb[i]][k - rp[i]] + 1)
                  dpTime[j][k] = std::min(dpTime[j][k], dpTime[j - rmb[i]][k - rp[i]] + time[i]);
          }
  ```

#### 2. 作者：a2920353120 (赞：44)
- **星级**：4星
- **关键亮点**：
  - 创新性地将时间的影响转化为权重，通过一个数组解决问题，节省了空间。
  - 代码简洁，思路新颖，适合对背包问题有一定理解的读者。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= n; ++i)
      for (int j = m; j >= rmb[i]; --j)
          for (int k = r; k >= rp[i]; --k) {
              if (f[j][k] < f[j - rmb[i]][k - rp[i]] + 20000 - time[i]) {
                  f[j][k] = f[j - rmb[i]][k - rp[i]] + 20000 - time[i];
              }
          }
  ```

#### 3. 作者：不许雷同 (赞：27)
- **星级**：4星
- **关键亮点**：
  - 使用了两个DP数组分别记录泡到的MM数量和时间，逻辑清晰。
  - 代码结构合理，易于理解，适合初学者学习。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= n; ++i)
      for (int j = m; j >= rmb[i]; --j)
          for (int k = r; k >= rp[i]; --k) {
              if (fn[j][k] < fn[j - rmb[i]][k - rp[i]] + 1) {
                  fn[j][k] = fn[j - rmb[i]][k - rp[i]] + 1;
                  ft[j][k] = ft[j - rmb[i]][k - rp[i]] + time[i];
              }
              else if (fn[j][k] == fn[j - rmb[i]][k - rp[i]] + 1)
                  ft[j][k] = min(ft[j][k], ft[j - rmb[i]][k - rp[i]] + time[i]);
          }
  ```

### 最优关键思路与技巧

1. **二维费用背包**：本题的核心是二维费用背包问题，需要在两个限制条件下进行状态转移。
2. **双DP数组**：使用两个DP数组分别记录泡到的MM数量和时间，确保在泡到最多MM的情况下，时间最小。
3. **权重转化**：通过将时间的影响转化为权重，简化了状态转移的逻辑，节省了空间。

### 可拓展之处

- **多维背包问题**：可以进一步扩展到多维背包问题，如增加更多的限制条件（如时间、空间等）。
- **其他优化技巧**：可以尝试使用滚动数组、位运算等技巧进一步优化空间和时间复杂度。

### 推荐相似题目

1. [P1048 采药](https://www.luogu.org/problem/P1048)
2. [P1049 装箱问题](https://www.luogu.org/problem/P1049)
3. [P1060 开心的金明](https://www.luogu.org/problem/P1060)

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中遇到变量名冲突（如`time`）导致的问题，提醒我们在编程时要注意变量名的选择。
- **顿悟感想**：通过将时间的影响转化为权重，简化了状态转移的逻辑，这种思路在处理复杂问题时非常有用。

---
处理用时：35.21秒
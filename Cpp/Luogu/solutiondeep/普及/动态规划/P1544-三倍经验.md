# 题目信息

# 三倍经验

## 题目描述

数字金字塔由 $n$ 行整数组成，第 $i(1\le i\le n)$ 行有 $i$ 个数字，一个示例如下。  
```text
        7
      3   9
    8   1   0
  2   7   4   4 
4   5   2   6   5
```  
现在你在金字塔的顶部（第一行），你希望走到金字塔的底部（第 $n$ 行），每一步你只能走向当前所在位置的左下方的数字或者右下方的数字。同时作为一个强大的小朋友，你可以选择金字塔中的不多于 $k$ 个数字让他们成为原来的 $3$ 倍。  

你会收集你路上经过的所有位置上的数字，最后的得分即为收集的数字之和，求最大得分。

## 说明/提示

对于 $30\%$ 的数据，满足 $k\le n\le 6$，并且对于任意 $1\le i\le n$，$1\le j\le i$ 满足 $0\le a_{i,j}\le 100$；  
对于 $100\%$ 的数据，满足 $1\le n\le100$，$0\le k\le \dfrac{n(n+1)}{2}$，且对于任意 $1\le i\le n$，$1\le j\le i$ 满足 $|a_{i,j}|\le 10^9$。

## 样例 #1

### 输入

```
5 3
7
3 9
8 1 0
2 7 4 4
4 5 2 6 5```

### 输出

```
75```

# AI分析结果

### 综合分析与结论

这些题解大多采用了动态规划（DP）的思路，核心在于通过三维DP数组来记录在不同位置和不同修改次数下的最大得分。难点在于如何有效地处理修改次数的限制，并确保状态转移的正确性。大部分题解通过分类讨论是否进行修改，并利用记忆化搜索或自底向上的DP来优化时间复杂度。总体而言，题解的质量参差不齐，部分题解在思路清晰度、代码可读性和优化程度上表现较好，但也有一些题解存在冗余或不够简洁的问题。

### 所选高星题解

#### 1. **作者：sto_5k_orz (5星)**
- **关键亮点**：该题解通过优化DP数组的维度，将时间复杂度从O(n^2 * k)降低到O(n^3)，显著提升了效率。代码简洁且逻辑清晰，特别是在处理修改次数时，通过限制k的范围避免了不必要的计算。
- **个人心得**：作者提到“虽然AC了，但空间和时间都很大”，并通过优化k的范围大幅提升了性能，体现了对问题的深入理解和优化能力。
- **核心代码**：
  ```cpp
  for(int i = 2; i <= n; i++)
      for(int j = 1; j <= i; j++) {
          for(int l = 0; l <= min(k, i); l++)
              dp[i][j][l] = max(dp[i - 1][j][l], dp[i - 1][j - 1][l]) + a[i][j];
          for(int l = 1; l <= min(k, i); l++)
              dp[i][j][l] = max(dp[i][j][l], max(dp[i - 1][j][l - 1], dp[i - 1][j - 1][l - 1]) + a[i][j] * 3);
      }
  ```

#### 2. **作者：QianRan_GG (4星)**
- **关键亮点**：该题解通过自底向上的DP方法，清晰地展示了状态转移方程，并通过初始化避免了负数带来的问题。代码结构清晰，易于理解。
- **核心代码**：
  ```cpp
  for(int i = 1; i <= n; ++ i)
      for(int j = 1; j <= i; ++ j) {
          cin >> a[i][j];
          for(int l = 0; l <= k && l <= i; ++ l) {
              if(l == 0)
                  dp[i][j][l] = max(dp[i - 1][j][l], dp[i - 1][j - 1][l]) + a[i][j];
              else {
                  dp[i][j][l] = max(dp[i - 1][j][l], dp[i - 1][j - 1][l]) + a[i][j];
                  dp[i][j][l] = max(dp[i][j][l], max(dp[i - 1][j][l - 1], dp[i - 1][j - 1][l - 1]) + a[i][j] * 3);
              }
          }
      }
  ```

#### 3. **作者：FQR_ (4星)**
- **关键亮点**：该题解通过将问题转化为多层数字三角形，巧妙地处理了修改次数的限制，思路新颖且易于理解。代码实现简洁，逻辑清晰。
- **核心代码**：
  ```cpp
  for(int i = 1; i <= n; i++)
      for(int j = 1; j <= i; j++)
          for(int p = 0; p <= k; p++) {
              f[i+1][j][p] = max(f[i+1][j][p], f[i][j][p] + a[i+1][j]);
              f[i+1][j+1][p] = max(f[i+1][j+1][p], f[i][j][p] + a[i+1][j+1]);
              f[i+1][j][p+1] = max(f[i+1][j][p+1], f[i][j][p] + a[i+1][j] * 3);
              f[i+1][j+1][p+1] = max(f[i+1][j+1][p+1], f[i][j][p] + a[i+1][j+1] * 3);
          }
  ```

### 最优关键思路与技巧
1. **三维DP数组**：通过增加一维来记录修改次数，确保状态转移的正确性。
2. **修改次数优化**：通过限制k的范围（k <= n），避免不必要的计算，提升效率。
3. **自底向上DP**：从底部开始计算，逐步向上推导，确保每个状态都基于已知的最优解。

### 可拓展之处
- **类似问题**：可以扩展到其他路径优化问题，如在不同条件下选择不同的路径或修改路径中的某些值。
- **多维DP**：在处理更复杂的问题时，可以考虑增加更多维度来记录不同的状态。

### 推荐题目
1. **P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles**：基础的数字三角形问题，适合练习DP。
2. **P1544 [NOIP2016 提高组] 三倍经验**：本题的简化版，适合巩固DP思路。
3. **P1004 方格取数**：类似的路径优化问题，适合进一步练习多维DP。

### 个人心得总结
- **调试经历**：多位作者提到初始化DP数组为极小值的重要性，避免负数带来的问题。
- **踩坑教训**：不开`long long`会导致WA，提醒了数据类型选择的重要性。
- **顿悟感想**：通过优化k的范围，大幅提升了性能，体现了对问题的深入理解和优化能力。

---
处理用时：36.40秒
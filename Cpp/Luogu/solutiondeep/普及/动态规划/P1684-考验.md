# 题目信息

# 考验

## 题目描述

大家知道，黄药师不仅武功高超，而且酷爱音乐和诗歌。看到桃花岛来了个新客人，而且不是靠真武功进来的，就准备为难为难你。

他写了一首 $N$ 行诗句的诗歌，美中不足的是这些诗句并不押韵，黄药师非常想遵循古诗的押韵。诗歌被分为若干段，每段都是四行诗。每一句诗都有一个韵脚，假如 $A$ 和 $B$ 表示两种不同的韵脚，每段四行诗的韵脚只可能是 `AABB`，`ABAB`，`ABBA` 和 `AAAA` 中的一种。

黄药师将诗句的韵脚都编了号，具有相同编号的句子代表有相同的韵脚。现在，黄药师想删掉一些句子，使得剩下的都是遵循押韵规则的四行诗，而且不允许改变诗句的顺序。

现在就问你：如何找出满足条件最长的诗歌？

## 说明/提示

提示：

删除第 $3$、$6$、$13$ 句诗，就可以分成 $3$ 个四行诗，分别为：

- $1,2,4,5$；
- $7,8,9,10$；
- $11,12,14,15$。


## 样例 #1

### 输入

```
15

1 2 3 1 2 1 2 3 3 2 1 1 3 2 2

```

### 输出

```
3

```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何通过删除一些诗句，使得剩下的诗句能够组成尽可能多的四行诗，且每四行诗的韵脚必须满足特定的押韵规则。从题解中可以看出，主要的解题思路集中在贪心算法和动态规划上。贪心算法的思路是通过记录韵脚的出现次数，当满足特定条件时（如两个韵脚各出现两次或一个韵脚出现四次），就认为可以组成一个四行诗，并清空记录。动态规划的思路则是通过状态转移，判断当前诗句是否可以与前面的诗句组成新的四行诗。

### 所选高星题解

#### 1. 作者：神阈小杰 (赞：52)  
**星级：4.5**  
**关键亮点：**  
- 使用贪心算法，思路清晰，代码简洁。
- 通过 `map` 记录韵脚出现次数，当满足条件时直接清空记录，避免了复杂的判断逻辑。
- 代码实现高效，时间复杂度为 O(n)，适合大规模数据。

**核心代码：**
```cpp
for(int i=1;i<=n;i++)
{
    scanf("%d",&x);
    f[x]++;
    if(f[x]==2) s++;
    if(s==2)
    {
        ans++;
        s=0;
        f.clear();
    }
    if(f[x]==4)
    {
        ans++;
        s=0;
        f.clear();
    }
}
```
**核心思想：**  
通过 `map` 记录每个韵脚的出现次数，当有两个韵脚各出现两次或一个韵脚出现四次时，认为可以组成一个四行诗，并清空记录。

#### 2. 作者：permzf (赞：8)  
**星级：4.0**  
**关键亮点：**  
- 使用贪心算法，思路与神阈小杰类似，但增加了离散化处理，适合韵脚编号较大的情况。
- 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
for(int i=1;i<=n;i++){
    f[a[i]]++;
    if(f[a[i]]==2) ok++,f[a[i]]=0;
    if(ok<2) continue;
    ok=0;ans++;
    memset(f,0,sizeof(f));
}
```
**核心思想：**  
通过离散化处理韵脚编号，记录每个韵脚的出现次数，当有两个韵脚各出现两次时，认为可以组成一个四行诗，并清空记录。

#### 3. 作者：zwjdd (赞：2)  
**星级：4.0**  
**关键亮点：**  
- 使用贪心算法，通过 `last` 记录上次匹配串的末尾，暴力判断是否可以组成新的四行诗。
- 思路较为独特，适合对贪心算法有深入理解的同学。

**核心代码：**
```cpp
if(i-last+1>=4)
{
    if(flag(last,i))
    {
        f[i]=max(f[i],f[last-1]+1);
        last=i+1;
    }
    else f[i]=f[i-1];
}
else f[i]=f[i-1];
```
**核心思想：**  
通过 `last` 记录上次匹配串的末尾，暴力判断当前诗句是否可以与前面的诗句组成新的四行诗，若成功则更新 `last` 和答案。

### 最优关键思路与技巧

1. **贪心算法的应用**：通过记录韵脚的出现次数，当满足特定条件时直接认为可以组成一个四行诗，并清空记录。这种方法简单高效，适合大规模数据处理。
2. **离散化处理**：当韵脚编号较大时，可以通过离散化处理来减少空间复杂度，提高代码效率。
3. **暴力判断与状态转移**：在动态规划中，通过暴力判断当前诗句是否可以与前面的诗句组成新的四行诗，若成功则更新状态。

### 可拓展之处

1. **类似问题**：类似的问题可以扩展到其他需要满足特定条件的序列问题，如删除某些元素使得剩下的元素满足某种排列规则。
2. **算法套路**：贪心算法和动态规划是解决这类问题的常见套路，可以举一反三应用到其他类似的问题中。

### 推荐题目

1. **P1880 [NOI1995]石子合并**（贪心算法）
2. **P1048 采药**（动态规划）
3. **P1064 金明的预算方案**（动态规划）

### 个人心得摘录

- **神阈小杰**：提到“本人动规不咋地QAQ”，说明贪心算法在某些情况下比动态规划更易实现，适合对动态规划不熟悉的同学。
- **permzf**：提到“蒟蒻讲的不太清楚感性理解一下吧qwq”，说明在讲解算法时，感性理解有时比严格的数学证明更易让人接受。
- **zwjdd**：提到“尽可能的在已经连接起来的诗歌后面接上新的诗歌”，说明贪心算法的核心思想是尽可能多地利用已有资源，避免浪费。

---
处理用时：30.87秒
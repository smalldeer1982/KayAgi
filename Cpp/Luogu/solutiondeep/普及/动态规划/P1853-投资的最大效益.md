# 题目信息

# 投资的最大效益

## 题目背景

约翰先生获得了一大笔遗产，他暂时还用不上这一笔钱，他决定进行投资以获得更大的效益。银行工作人员向他提供了多种债券，每一种债券都能在固定的投资后，提供稳定的年利息。当然，每一种债券的投资额是不同的，一般来说，投资越大，收益也越大，而且，每一年还可以根据资金总额的增加，更换收益更大的债券。


## 题目描述

例如：有如下两种不同的债券：

1. 投资额 $\$4000$，年利息 $\$400$；
2. 投资额 $\$3000$，年利息 $\$250$。

初始时，有 $\$10000$ 的总资产，可以投资两份债券 1 债券，一年获得 $\$800$ 的利息；而投资一份债券 1 和两份债券 2，一年可获得 $\$900$ 的利息，两年后，可获得 $\$1800$ 的利息；而所有的资产达到 $\$11800$，然后将卖掉一份债券 2，换购债券 1，年利息可达到 $\$1050$；第三年后，总资产达到 $\$12850$，可以购买三份债券 1，年利息可达到 $\$1200$，第四年后，总资产可达到 $\$14050$。

现给定若干种债券、最初的总资产，帮助约翰先生计算，经过 $n$ 年的投资，总资产的最大值。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le s \le {10}^6$，$2 \le n \le 40$，$1 \le d \le 10$，$1 \le a \le {10}^4$，且 $a$ 是 $1000$ 的倍数，$b$ 不超过 $a$ 的 $10\%$。

## 样例 #1

### 输入

```
10000 4 2

4000 400

3000 250```

### 输出

```
14050```

# AI分析结果

### 综合分析与结论

本题的核心是**完全背包问题**，结合了**动态规划**和**多次循环**的思想。题解的主要思路是通过多次完全背包的求解，逐年更新总资产，最终得到最大收益。大多数题解都采用了类似的思路，但在空间优化和代码实现上有所不同。

#### 关键思路与技巧：
1. **完全背包的应用**：将债券视为物品，投资额视为重量，年利息视为价值，通过完全背包求解最大收益。
2. **空间优化**：由于投资额是1000的倍数，可以将投资额除以1000，减少DP数组的大小，优化空间复杂度。
3. **多次循环**：每年进行一次完全背包的求解，并将最大利息累加到总资产中，模拟多年的投资过程。

#### 可拓展之处：
- **类似问题**：类似的多次完全背包问题可以应用于其他需要多次决策的场景，如资源分配、时间管理等。
- **优化技巧**：空间优化技巧可以应用于其他需要处理大数据的动态规划问题。

### 所选高星题解

#### 1. 作者：Sham_Sleep (5星)
- **关键亮点**：思路清晰，代码简洁，详细解释了完全背包的应用和空间优化。
- **个人心得**：作者提到“这道题是本蒟蒻刷过最水的背包题”，体现了对题目的轻松态度和自信。

```cpp
#include <stdio.h>
#include <iostream>
#include <memory.h>
using namespace std;
int w[100000];
int v[100000];
int dp[100000];
int s,n,d;
int main()
{
	scanf("%d%d%d",&s,&n,&d);
	for(int i=1; i<=d; ++i){
		scanf("%d%d",&w[i],&v[i]);
	}
	for(int i=1; i<=n; ++i){
		int m=s/1000;
		for(int j=1; j<=d; ++j){
			for(int k=w[j]/1000; k<=m; ++k){
				if(k>=w[j]/1000) dp[k]=max(dp[k],dp[k-w[j]/1000]+v[j]);
			}
		}
		s+=dp[m];
		memset(dp,0,sizeof(dp));
	}
	printf("%d",s);
}
```

#### 2. 作者：卷王 (4星)
- **关键亮点**：代码结构清晰，注释详细，适合初学者理解。
- **个人心得**：无特别心得，但代码注释非常详细，便于理解。

```cpp
#include <bits/stdc++.h>
using namespace std;
int property, year, kind, ans = 0;
int v[17], w[17];
int dp[1000007];
int main() {
	cin >> property >> year >> kind;
	ans = property;
	for(int i = 1; i <= kind; i++) {
		cin >> v[i] >> w[i];
		v[i] /= 1000;
	}
	for(int k = 1; k <= year; k++) {
		memset(dp, 0, sizeof(dp));
		int t = ans / 1000;
		for(int i = 1; i <= kind; i++)
			for(int j = v[i]; j <= t; j++)
				dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
		ans += dp[t];
	}
	cout << ans;
	return 0;
}
```

#### 3. 作者：Ggsddu_zzy (4星)
- **关键亮点**：详细解释了完全背包的状态转移方程和优化思路，代码简洁。
- **个人心得**：无特别心得，但解题思路清晰，适合进阶学习。

```cpp
#include<bits/stdc++.h>
#define ri register int
using namespace std;
int m,n,d;
int w[15],v[15],f[1000005];
int main() {
	cin>>m>>n>>d;
	int sum=m;
	for(ri i=1; i<=d; i++)cin>>w[i]>>v[i];
	for(ri k=1; k<=n; k++) {
		memset(f,0,sizeof(f));
		for(ri i=1; i<=d; i++)
			for(ri j=w[i]/1000; j<=sum/1000; j++)
				f[j]=max(f[j],f[j-w[i]/1000]+v[i]);
		sum+=f[sum/1000];
	}
	cout<<sum;
	return 0;
}
```

### 推荐题目
1. **P1048 采药**：经典的01背包问题，适合练习背包问题的基本应用。
2. **P1616 疯狂的采药**：完全背包问题，与本题类似，适合巩固完全背包的应用。
3. **P1064 金明的预算方案**：多维背包问题，适合练习更复杂的背包问题。

---
处理用时：30.98秒
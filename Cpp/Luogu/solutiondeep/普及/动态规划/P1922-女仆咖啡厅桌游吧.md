# 题目信息

# 女仆咖啡厅桌游吧

## 题目背景

小 v 带萌萌的妹妹去玩，妹妹想去女仆咖啡馆，小 v 想去桌游吧。

妹妹：“我问你个问题，答不对你就做我一天的奴隶，答对了就今天我就全部听你的。”

小 v ：“全部都听!?”

妹妹：“嘻嘻嘻，你还是回答问题吧！”

于是小 v 为了自己一天的幸福，来向你求助。

## 题目描述

小 v 所在的世界被规划成了树形结构，每一个节点上都可以建一个女仆咖啡厅或者桌游吧或者什么都不建。在确定点 $1$ 为根节点之后，规划局要求：对于每一个非叶子的节点 $i$，设它子树（包括自己）中所有的女仆咖啡厅的数量为 $cafe_i$，桌游吧数目为 $table_i$，都有 $cafe_i=table_i$。

妹妹的问题是：这颗树最多能放多少个女仆咖啡厅。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\le20$。
- 对于 $100\%$ 的数据，保证 $1\le n\le10^5$，$1 \leq u, v \le n$。

## 样例 #1

### 输入

```
5
1 2
2 3
3 4
2 5
```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是树形DP，要求每个非叶子节点的子树中女仆咖啡厅和桌游吧的数量相等。大多数题解采用了DFS遍历树结构，并通过递归计算每个节点的贡献。主要思路是通过统计叶子节点数量，并结合非叶子节点的子树结果，最终计算出最大女仆咖啡厅数量。

### 所选高星题解

#### 1. **作者：xhQYm (赞：12)**
- **星级：4.5**
- **关键亮点**：
  - 清晰的树形DP思路，状态转移方程明确。
  - 通过入度判断叶子节点，代码简洁且易于理解。
  - 注释详细，适合初学者学习。

**核心代码**：
```cpp
void dfs(int x,int last) {
    int cnt=1;
    for(int i=h[x];~i;i=ne[i]) {
        if(e[i]==last) continue;
        int j=e[i];
        dfs(j,x);
        if(check(j)) cnt++;
        else f[x]+=f[j];
    }
    f[x]+=cnt/2;
}
```
**实现思想**：通过DFS遍历树，统计叶子节点数量，并将非叶子节点的子树结果累加，最后加上叶子节点数量的一半。

#### 2. **作者：江屿 (赞：6)**
- **星级：4**
- **关键亮点**：
  - 递归思路清晰，代码结构简单。
  - 通过`vis`数组避免重复访问，确保DFS正确性。
  - 适合对树形DP不熟悉的读者。

**核心代码**：
```cpp
int dp(int x){
    vis[x]=1;
    int tot=1,sum=0;
    for(int i=head[x];i;i=next[i]){
        int u=to[i],v;
        if(!vis[u]){
            v=dp(u);
            if(v) sum+=v;
            else tot++;
        }
    }
    if(tot>=2) sum+=tot/2;
    return sum;
}
```
**实现思想**：递归计算每个节点的贡献，统计叶子节点数量，并将非叶子节点的子树结果累加，最后加上叶子节点数量的一半。

#### 3. **作者：Da_un (赞：2)**
- **星级：4**
- **关键亮点**：
  - 通过`havep`和`haves`数组判断父子关系，确保树的正确构建。
  - 递归思路清晰，代码结构简单。

**核心代码**：
```cpp
int dfs(int node){
    int tot=0;
    int leaves=1;
    for(vector<int>::iterator i=v[node].begin();i!=v[node].end();i++){
        if(!haves[*i]) leaves++;
        else tot+=dfs(*i);
    }
    tot+=leaves/2;
    return tot;
}
```
**实现思想**：通过DFS遍历树，统计叶子节点数量，并将非叶子节点的子树结果累加，最后加上叶子节点数量的一半。

### 最优关键思路与技巧

1. **树形DP的核心**：通过DFS遍历树，递归计算每个节点的贡献，结合叶子节点和非叶子节点的子树结果，最终得到全局最优解。
2. **叶子节点统计**：通过入度或`vis`数组判断叶子节点，确保统计的准确性。
3. **状态转移**：将非叶子节点的子树结果累加，并加上叶子节点数量的一半，确保每个非叶子节点的子树中女仆咖啡厅和桌游吧的数量相等。

### 可拓展之处

1. **类似算法套路**：树形DP常用于解决树结构中的最优化问题，如最大独立集、最小支配集等。
2. **同类型题目**：可以尝试解决其他树形DP问题，如子树和、子树最大值等。

### 推荐题目

1. **P1352 没有上司的舞会**：树形DP经典问题，考察子树的最大独立集。
2. **P2014 选课**：树形DP与背包问题的结合，考察子树的最优选择。
3. **P1040 加分二叉树**：树形DP与区间DP的结合，考察子树的最优构造。

### 个人心得摘录

- **作者：Panthera_AFO**：对拍数据查错1小时，最终发现根节点也可以算“叶子结点”，提醒了在树形DP中要注意边界条件。
- **作者：lingerleaf**：通过无向图转换为有向图，明确了父子关系，确保了树的正确构建。

### 总结

本题的树形DP思路清晰，通过DFS遍历树结构，结合叶子节点和非叶子节点的子树结果，最终计算出最大女仆咖啡厅数量。推荐的题解代码简洁、思路清晰，适合初学者学习。

---
处理用时：29.90秒
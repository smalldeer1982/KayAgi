# 题目信息

# 迷之阶梯

## 题目描述

在经过地球防卫小队的数学家连续多日的工作后，外星人发的密码终于得以破解。它 告诉我们在地球某一处的古老遗迹中，存在有对抗这次灾难的秘密武器。防卫小队立即赶 到这处遗迹。要进入遗迹，需要通过一段迷之阶梯。登上阶梯必须要按照它要求的方法， 否则就无法登上阶梯。它要求的方法有以下三个限制：

1. 如果下一步阶梯的高度只比当前阶梯高 1，则可以直接登上。

2. 除了第一步阶梯外，都可以从当前阶梯退到前一步阶梯。

3. 当你连续退下 k 后，你可以一次跳上不超过当前阶梯高度 $2^{k}$的阶梯。比如说你现 在位于第 j 步阶梯，并且是从第 j+k 步阶梯退下来的，那么你可以跳到高度不超过当前阶 梯高度+$2^{k}$的任何一步阶梯。跳跃这一次只算一次移动。

开始时我们在第一步阶梯，由于时间紧迫，我们需要用最少的移动次数登上迷之阶梯。 请你计算出最少的移动步数。


## 说明/提示

【样例解释】

连续登 3 步，再后退 3 步，然后直接跳上去。

【数据范围】

对于 50%的数据：1≤N≤20。

对于 100%的数据：1≤N≤200。

对于 100%的数据：每步阶梯高度不超过 2^31-1


## 样例 #1

### 输入

```
5
0  1  2  3  6 
```

### 输出

```
7```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）或广度优先搜索（BFS）来求解最少的移动步数。题解中主要分为两种思路：

1. **动态规划（DP）**：大多数题解采用DP，通过状态转移方程求解。难点在于如何正确设计状态转移方程，特别是处理“后退k步后跳跃”的规则。部分题解通过预处理2^k来优化计算，也有题解使用二分查找进一步优化时间复杂度。

2. **广度优先搜索（BFS）**：少数题解采用BFS，通过队列记录当前状态（当前位置、后退步数、移动次数）进行搜索。BFS的优势在于可以避免重复计算，但需要合理设计状态和剪枝。

总体来看，DP是更为主流的解法，且通过预处理和二分查找可以进一步优化。BFS虽然直观，但在本题中由于状态较多，可能不如DP高效。

### 所选高星题解

#### 1. 作者：x_faraway_x (赞：38)  
**星级：★★★★★**  
**关键亮点**：  
- 清晰的DP状态转移方程设计，直接解决了“后退k步后跳跃”的难点。  
- 通过预处理2^k优化计算，代码简洁且高效。  
- 提供了详细的思路解释，适合初学者理解。

**核心代码**：
```cpp
for(int i=2;i<=n;i++) {
    if(a[i]<=a[i-1]+1) f[i]=f[i-1]+1;
    for(int j=i-1;j>0;j--)
        for(int k=j-1;k>0;k--)
            if((1<<(j-k))+a[k]>=a[i]) f[i]=Min(f[i],f[j]+j-k+1);
}
```
**实现思想**：通过三重循环枚举所有可能的跳跃情况，利用预处理2^k快速计算跳跃范围。

#### 2. 作者：LJC00118 (赞：15)  
**星级：★★★★☆**  
**关键亮点**：  
- 采用BFS思路，通过队列记录状态，避免了DP中的重复计算。  
- 使用哈希表（`used`数组）进行状态去重，优化了搜索效率。  
- 代码结构清晰，适合理解BFS的应用场景。

**核心代码**：
```cpp
while(!q.empty()) {
    ele u = q.front(); q.pop();
    if(u.now == n) { cout << u.len; return 0; }
    if(u.now != 1 && used[u.now - 1][u.k + 1] == 0) {
        used[u.now - 1][u.k + 1] = 1;
        q.push((ele){u.now - 1, u.k + 1, u.len + 1});
    }
    for(int i = u.now + 1; i <= n; i++) {
        if(a[i] <= a[u.now] + f[u.k] && used[i][0] == 0) {
            used[i][0] = 1;
            q.push((ele){i, 0, u.len + 1});
        }
    }
}
```
**实现思想**：通过BFS遍历所有可能的移动路径，利用哈希表记录已访问状态，避免重复计算。

#### 3. 作者：Drifterming (赞：14)  
**星级：★★★★☆**  
**关键亮点**：  
- 使用`log2`函数计算跳跃步数，简化了状态转移方程。  
- 通过`ceil`函数处理跳跃步数的上界，避免了不必要的计算。  
- 代码简洁且高效，适合有一定基础的读者。

**核心代码**：
```cpp
for(int i=2;i<=n;i++) {
    if(sta[i]==sta[i-1]+1) dp[i]=dp[i-1]+1;
    for(int j=1;j<i;j++) {
        int k=ceil(log2(sta[i]-sta[j]));
        if(j+k<i) dp[i]=min(dp[i],dp[j+k]+k+1);
    }
}
```
**实现思想**：通过`log2`函数计算跳跃步数，简化了状态转移方程，减少了循环次数。

### 最优关键思路与技巧

1. **预处理2^k**：通过预处理2^k的值，避免了在循环中重复计算，提升了效率。
2. **二分查找优化**：在DP中使用二分查找快速确定跳跃步数，进一步优化了时间复杂度。
3. **BFS状态去重**：在BFS中使用哈希表记录已访问状态，避免重复计算，提升搜索效率。

### 可拓展之处

1. **类似DP问题**：可以拓展到其他需要状态转移的DP问题，如背包问题、最长公共子序列等。
2. **BFS应用场景**：BFS可以应用于其他需要最短路径或最少步数的问题，如迷宫问题、图的最短路径等。

### 推荐相似题目

1. **P1048 采药**：经典的DP问题，考察状态转移方程的设计。
2. **P1219 八皇后**：BFS的应用，考察状态搜索与剪枝。
3. **P1141 01迷宫**：BFS的应用，考察最短路径的求解。

### 个人心得摘录

- **x_faraway_x**：提到“这题的n^3的dp还是很容易想到的”，强调了DP的直观性。
- **LJC00118**：提到“实在不明白为什么大家会把这道题当dp”，强调了BFS的适用性。
- **Drifterming**：提到“k=ceil(log2(sta[i]-sta[j]))”，强调了数学函数在优化中的应用。

这些心得反映了不同作者在解题过程中的思考与优化思路，值得借鉴。

---
处理用时：41.26秒
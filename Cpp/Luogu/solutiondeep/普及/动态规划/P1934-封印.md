# 题目信息

# 封印

## 题目背景

很久以前，魔界大旱，水井全部干涸，温度也越来越高。为了拯救居民，夜叉族国王龙溟希望能打破神魔之井，进入人界“窃取”水灵珠，以修复大地水脉。可是六界之间皆有封印，神魔之井的封印由蜀山控制，并施有封印。龙溟作为魔界王族，习有穿行之术，可任意穿行至任何留有空隙的位置。然而封印不留有任何空隙！ 龙溟无奈之下只能强行破除封印。破除封印必然消耗一定的元气。为了寻找水灵珠，龙溟必须减少体力消耗。他可以在破除封印的同时使用越行术。

## 题目描述

神魔之井的封印共有  $n$ 层，每层封印都有一个坚固值。身为魔族的龙溟单独打破一层封印时需要消耗的元气为该层封印的坚固值和封印总层数  $n$ 的平方的乘积； 但他也可以打破第 i 层到第 j 层之间的所有封印( $i<j$)，总元气消耗为第  $i,j$ 层封印的坚固值之和与第  $i,j$ 层之间所有封印层（包括第  $i,j$ 层）的坚固值之和的乘积，但为了不惊动蜀山，第  $i,j$ 层封印的坚固值之和不能大于  $t$ （单独打破可以不遵守）。

## 说明/提示

#### 样例解释
先单独打破第一层，再用越行术从第二层直接打破到最后一层。 这样消耗元气  $8 \times 6^2 + (5 + 5) \times (5 + 7 + 9 + 3 + 5) = 578$。
#### 数据范围
对于  $10\%$ 的数据， $n\le10$；  
对于  $50\%$ 的数据， $n\le100$；  
对于  $70\%$ 的数据， $n\le500$；  
对于  $100\%$ 的数据， $n\le1000$， $a_i(1 \le i \le n) , t \le 20000$。

## 样例 #1

### 输入

```
6 10

8 5 7 9 3 5```

### 输出

```
578

```

# AI分析结果

### 综合分析与结论

本题的核心是动态规划（DP）与前缀和的结合应用。所有题解都采用了DP的思路，通过定义状态 `f[i]` 表示打破前 `i` 层封印的最小元气消耗，并利用前缀和优化区间求和的时间复杂度。难点在于如何高效地处理区间打破的元气计算，以及如何通过前缀和将复杂度从 `O(n^3)` 降低到 `O(n^2)`。

### 所选高星题解

#### 1. 作者：kkksc03 (赞：74)
- **星级：5星**
- **关键亮点**：思路清晰，详细解释了DP状态转移方程，并强调了前缀和的优化作用。代码简洁，逻辑明确。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++) {
      long long ans = m * a[i] + f[i-1];
      for(int j=1;j<i;j++) {
          if(a[i]+a[j] > t) continue;
          ans = min(ans, (a[i]+a[j]) * (s[i]-s[j-1]) + f[j-1]);
      }
      f[i] = ans;
  }
  ```
  **实现思想**：通过前缀和 `s[i]` 快速计算区间 `[j, i]` 的坚固值之和，避免重复计算。

#### 2. 作者：Vatyr (赞：35)
- **星级：4星**
- **关键亮点**：代码实现简洁，直接给出了DP的状态转移方程，并通过前缀和优化了区间求和。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++) {
      dp[i] = dp[i-1] + a[i] * n * n;
      for(int j=1;j<i;j++) {
          if(a[i]+a[j] <= t) {
              dp[i] = min(dp[i], (a[i]+a[j]) * (sum[i]-sum[j-1]) + dp[j-1]);
          }
      }
  }
  ```
  **实现思想**：通过前缀和 `sum[i]` 快速计算区间 `[j, i]` 的坚固值之和，避免重复计算。

#### 3. 作者：wick (赞：13)
- **星级：4星**
- **关键亮点**：详细解释了DP的状态转移方程，并强调了前缀和的优化作用。代码实现清晰，逻辑明确。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++) {
      dp[i] = min(dp[i], dp[i-1] + a[i] * n * n);
      for(int j=1;j<i;j++) {
          if(a[i]+a[j] <= t) {
              dp[i] = min(dp[i], dp[j-1] + (a[i]+a[j]) * (sum[i]-sum[j-1]));
          }
      }
  }
  ```
  **实现思想**：通过前缀和 `sum[i]` 快速计算区间 `[j, i]` 的坚固值之和，避免重复计算。

### 最优关键思路与技巧
1. **DP状态定义**：定义 `f[i]` 为打破前 `i` 层封印的最小元气消耗。
2. **前缀和优化**：通过前缀和数组 `s[i]` 快速计算区间 `[j, i]` 的坚固值之和，将复杂度从 `O(n^3)` 降低到 `O(n^2)`。
3. **状态转移方程**：`f[i] = min(f[i-1] + a[i] * n^2, f[j-1] + (a[i]+a[j]) * (s[i]-s[j-1]))`，其中 `a[i]+a[j] <= t`。

### 可拓展之处
- **类似算法套路**：区间DP与前缀和的结合在其他题目中也有广泛应用，如区间合并、区间最值等问题。
- **同类型题**：可以考虑类似区间DP的题目，如区间合并、区间最值等。

### 推荐洛谷题目
1. **P1880 [NOI1995] 石子合并**：区间DP经典题目，考察区间合并的最小代价。
2. **P1040 加分二叉树**：区间DP与树形结构的结合，考察区间划分的最优解。
3. **P1063 能量项链**：区间DP与环形结构的结合，考察区间合并的最优解。

### 个人心得总结
- **调试经历**：部分题解提到在调试过程中发现 `INF` 设置不够大导致WA，提醒我们在处理大数时要注意数据范围。
- **顿悟感想**：通过前缀和优化区间求和，是降低复杂度的关键，这种思路在类似题目中也有广泛应用。

---
处理用时：31.09秒
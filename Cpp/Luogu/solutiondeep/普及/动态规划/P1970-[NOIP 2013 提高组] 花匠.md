# 题目信息

# [NOIP 2013 提高组] 花匠

## 题目背景

NOIP2013 提高组 D2T2

## 题目描述

花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。

具体而言，栋栋的花的高度可以看成一列整数 $h_1,h_2,\ldots,h_n$。设当一部分花被移走后，剩下的花的高度依次为 $g_1,g_2,\ldots,g_m$，则栋栋希望下面两个条件中至少有一个满足：

条件 A：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i + 1}$；  
条件 B：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i + 1}$。

注意上面两个条件在 $m = 1$ 时同时满足，当 $m > 1 $ 时最多有一个能满足。

请问，栋栋最多能将多少株花留在原地。


## 说明/提示

**输入输出样例说明**

有多种方法可以正好保留 $3$ 株花，例如，留下第 $1$、$4$、$5$ 株，高度分别为 $5$、$1$、$2$，满足条件 B。

**数据范围**

对于 $20\%$的数据，$n \le 10$；

对于 $30\%$的数据，$n \le 25$；

对于 $70\%$的数据，$n \le 1000$，$0 \le h_i \le 1000$；

对于 $100\%$的数据，$1 \le n \le {10}^5$，$0 \le h_i \le {10}^6$，所有的 $h_i$ 随机生成，所有随机数服从某区间内的均匀分布。


## 样例 #1

### 输入

```
5
5 3 2 1 2
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心是求一个最长序列，使得该序列的任意三个相邻元素，中间的元素是三个中最大的或最小的。题解中主要采用了两种思路：**动态规划（DP）**和**贪心算法**。

- **DP思路**：通过维护两个数组，分别记录当前元素作为波峰或波谷时的最长序列长度，最后取最大值。时间复杂度为O(n)，空间复杂度为O(n)。
- **贪心思路**：通过遍历数组，记录当前趋势（上升或下降），并在趋势变化时更新计数。时间复杂度为O(n)，空间复杂度为O(1)。

总体来说，贪心算法在空间复杂度上更优，且代码更简洁。DP思路虽然稍显复杂，但逻辑清晰，适合理解动态规划的应用。

### 所选高分题解

#### 1. 作者：wuzhoupei (赞：294)
- **星级**：★★★★★
- **关键亮点**：
  - 详细解释了DP思路，类比最长不下降子序列，逻辑清晰。
  - 代码简洁，注释详细，易于理解。
  - 通过两个数组分别记录波峰和波谷的情况，最后取最大值。
- **核心代码**：
  ```cpp
  for(R II i=2;i<=n;i++)
  {
      if(a[i]>a[i-1]) d_1[i]=max(d_1[i-1],d_2[i-1]+1), d_2[i]=d_2[i-1];
      else if(a[i]<a[i-1]) d_1[i]=d_1[i-1], d_2[i]=max(d_1[i-1]+1,d_2[i-1]);
      else d_1[i]=d_1[i-1], d_2[i]=d_2[i-1];
  }
  R II ans=max(d_1[n],d_2[n]);
  ```

#### 2. 作者：GSQ0829 (赞：5)
- **星级**：★★★★
- **关键亮点**：
  - 采用贪心算法，思路简洁，代码实现简单。
  - 通过记录当前趋势（上升或下降），并在趋势变化时更新计数。
  - 空间复杂度为O(1)，效率高。
- **核心代码**：
  ```cpp
  for (int i = 2; i <= n; i++) {
      if (m > t && cnt != 1) {
          cnt = 1;
          ans++;
      } else if (m < t && cnt) {
          cnt = 0;
          ans++;
      }
      t = m;
  }
  ```

#### 3. 作者：Aleph1022 (赞：4)
- **星级**：★★★★
- **关键亮点**：
  - 采用DP思路，并通过二维偏序优化到O(n log n)。
  - 使用权值线段树维护最大值，思路新颖。
  - 代码实现较为复杂，但优化思路值得学习。
- **核心代码**：
  ```cpp
  for(register int i = 1;i <= n;++i)
  {
      scanf("%d",a + i);
      f[i][0] = query(0,a[i] - 1,rt[1],0,A) + 1,f[i][1] = query(a[i] + 1,A,rt[0],0,A) + 1;
      change(a[i],f[i][0],rt[0],0,A),change(a[i],f[i][1],rt[1],0,A);
  }
  ```

### 最优关键思路与技巧

- **贪心算法**：通过记录当前趋势（上升或下降），并在趋势变化时更新计数，时间复杂度为O(n)，空间复杂度为O(1)。
- **动态规划**：通过维护两个数组，分别记录当前元素作为波峰或波谷时的最长序列长度，最后取最大值，时间复杂度为O(n)，空间复杂度为O(n)。

### 可拓展之处

- **类似题目**：可以扩展到其他需要交替序列的问题，如最长交替子序列、最长波浪序列等。
- **优化思路**：对于更大规模的数据，可以考虑使用线段树等数据结构进行优化。

### 推荐相似题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020) - 考察最长不上升子序列和最长不下降子序列。
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 考察双向最长上升子序列。
3. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439) - 考察最长公共子序列的优化。

### 个人心得总结

- **调试经历**：在实现DP时，注意初始化条件和边界情况，避免数组越界或逻辑错误。
- **踩坑教训**：贪心算法中，趋势变化的判断要准确，避免遗漏或重复计数。
- **顿悟感想**：贪心算法虽然简单，但在某些问题上效率极高，适合大规模数据处理。

---
处理用时：31.74秒
# 题目信息

# 出租车拼车

## 题目背景

话说小 x 有一次去参加比赛，虽然学校离比赛地点不太远，但小 x 还是想坐出租车去。大学城的出租车总是比较另类，有“拼车”一说，也就是说，你一个人坐车去，还是一堆人一起，总共需要支付的钱是一样的（每辆出租上除司机外最多坐下 $4$ 个人）。刚好那天同校的一群 OIer 在校门口扎堆了，大家果断决定拼车去赛场。

问题来了，一辆又一辆的出租车经过，但里面要么坐满了乘客，要么只剩下一两个座位，众 OIer 都觉得坐上去太亏了，小 x 也是这么想的。

## 题目描述

假设 $N$ 位 OIer 准备拼车，此时为 $0$ 时刻，从校门到目的地需要支付给出租车师傅 $D$ 元（按车次算，不管里面坐了多少 OIer），假如 $S$ 分钟后恰能赶上比赛，那么 $S$ 分钟后经过校门口的出租车自然可以忽略不计了。现在给出在这 $S$ 分钟当中经过校门的所有的 $K$ 辆出租车先后到达校门口的时间 $T_i$  及里面剩余的座位 $Z_i$
，OIer 可以选择上车几个人（不能超过），当然，也可以选择上 $0$ 个人，那就是不坐这辆车。

俗话说，时间就是金钱，这里小 x 把每个 OIer 在校门等待出租车的分钟数 等同于花了相同多的钱（例如小 x 等待了 $20$ 分钟，那相当于他额外花了 $20$ 元钱）。

在保证所有 OIer 都能在比赛开始前到达比赛地点的情况下，聪明的你能计算出他们最少需要花多少元钱么？

## 说明/提示

对于 $100\%$ 的数据，满足 $N,K,D,S \le 100$，$1 \le Z_i \le 4$，$1 \le T_i \le T_{i+1} \le S$。

## 样例 #1

### 输入

```
2 2 10 5

1 1

2 2

```

### 输出

```
14

```

# AI分析结果

### 综合分析与结论

本题的核心是动态规划（DP），通过状态转移方程来求解最小花费。各题解主要围绕如何定义状态、如何转移状态以及如何优化空间复杂度展开。以下是各题解的要点对比：

1. **状态定义**：
   - 大部分题解使用 `f[i][j]` 表示前 `i` 辆车送走 `j` 个 OIer 的最小花费。
   - 部分题解使用 `f[j]` 表示送走 `j` 个 OIer 的最小花费，通过滚动数组优化空间。

2. **状态转移**：
   - 基本思路是枚举每辆车和每辆车可能送走的人数，更新最小花费。
   - 转移方程通常为 `f[i][j] = min(f[i][j], f[i-1][j-k] + k * t[i] + d)`，其中 `k` 是当前车送走的人数。

3. **优化**：
   - 滚动数组优化空间复杂度，从二维数组降为一维数组。
   - 部分题解通过逆序枚举来避免状态覆盖问题。

4. **代码实现**：
   - 部分题解代码较为简洁，但缺少必要的注释和解释。
   - 部分题解使用了快读等优化技巧，但增加了代码复杂度。

### 所选高星题解

#### 题解1：作者：DDOSvoid (★★★★☆)
- **关键亮点**：
  - 状态定义清晰，使用 `f[i][j]` 表示前 `i` 辆车送走 `j` 个 OIer 的最小花费。
  - 状态转移方程简洁明了，易于理解。
  - 代码结构清晰，初始化部分处理得当。
- **核心代码**：
  ```cpp
  for(int i=1;i<=k;i++)
      for(int j=0;j<=n;j++){
          f[i][j]=f[i-1][j];
          for(int k=0;k<=min(j,a[i].z);k++)
              f[i][j]=min(f[i-1][j-k]+k*a[i].t+d,f[i][j]);
      }
  ```

#### 题解2：作者：JiaY19 (★★★★☆)
- **关键亮点**：
  - 使用滚动数组优化空间复杂度，代码简洁。
  - 状态转移方程清晰，且通过逆序枚举避免状态覆盖问题。
  - 代码注释较少，但逻辑清晰。
- **核心代码**：
  ```cpp
  for(int i=1;i<=k;i++)				
      for(int j=n;j>=1;j--)
          for(int l=1;l<=min(z[i],j);l++)
              f[j] = min(f[j - l] + l * t[i] + d , f[j]);
  ```

#### 题解3：作者：Awdrgysxc (★★★★☆)
- **关键亮点**：
  - 提供了滚动数组和非滚动数组两种实现，便于理解优化过程。
  - 状态转移方程清晰，且通过逆序枚举避免状态覆盖问题。
  - 代码注释较少，但逻辑清晰。
- **核心代码**：
  ```cpp
  for(re int i = 1;i <= K; i++)
      for(re int j = n;j >= 0; j--)
          for(re int k = 0;k <= min(j,z[i]); k++)
              dp[j] = min(dp[j],dp[j - k] + k * Ti[i] + D);
  ```

### 最优关键思路与技巧

1. **状态定义**：使用 `f[i][j]` 表示前 `i` 辆车送走 `j` 个 OIer 的最小花费，或使用 `f[j]` 通过滚动数组优化空间。
2. **状态转移**：枚举每辆车和每辆车可能送走的人数，更新最小花费。
3. **优化技巧**：滚动数组和逆序枚举是优化空间复杂度的关键。

### 可拓展之处

1. **类似问题**：背包问题、资源分配问题等都可以使用类似的动态规划思路。
2. **优化技巧**：滚动数组和逆序枚举在其他动态规划问题中也有广泛应用。

### 推荐题目

1. **P1048 采药**：经典的背包问题，考察动态规划的基本应用。
2. **P1060 开心的金明**：类似背包问题，考察动态规划的状态转移。
3. **P1541 乌龟棋**：动态规划与状态转移的结合，考察如何通过状态转移求解最优解。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现状态转移方程的错误，强调了仔细检查状态转移的重要性。
- **踩坑教训**：部分题解提到初始化时的陷阱，强调了初始值设置的重要性。
- **顿悟感想**：部分题解提到通过滚动数组优化空间复杂度的顿悟，强调了优化技巧的重要性。

---
处理用时：28.87秒
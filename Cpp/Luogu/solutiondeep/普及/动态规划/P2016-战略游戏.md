# 题目信息

# 战略游戏

## 题目背景

Bob 喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的办法。现在他有个问题。


## 题目描述

他要建立一个古城堡，城堡中的路形成一棵无根树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能瞭望到所有的路。

注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被瞭望到。

请你编一程序，给定一树，帮 Bob 计算出他需要放置最少的士兵。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 1500$。

## 样例 #1

### 输入

```
4
0 1 1
1 2 2 3
2 0
3 0
```

### 输出

```
1
```

# AI分析结果

### 综合分析与结论

本题的核心是**树形DP**，目标是在树中选择最少的节点，使得每条边至少有一个端点被选中。大多数题解采用了相似的思路，即定义状态 `dp[u][0/1]` 表示节点 `u` 不选或选时的最小士兵数，并通过递归遍历树进行状态转移。部分题解还提到了**最小点覆盖**的概念，并将其与**最大匹配**联系起来，提供了不同的解题视角。

### 精选题解

#### 1. 作者：kikuss (赞：95)
- **星级**：★★★★★
- **关键亮点**：
  - 思路清晰，直接切入树形DP的核心。
  - 代码简洁，使用了前向星存图，优化了空间和时间复杂度。
  - 提供了详细的转移方程解释，易于理解。
- **核心代码**：
  ```cpp
  void dfs(int u, int fa) {
      dp[u][1] = 1, dp[u][0] = 0;
      for (int i = head[u]; i; i = nex[i]) {
          if (to[i] == fa) continue;
          dfs(to[i], u);
          dp[u][0] += dp[to[i]][1];
          dp[u][1] += min(dp[to[i]][1], dp[to[i]][0]);
      }
  }
  ```
  **实现思想**：通过DFS遍历树，自底向上计算每个节点的状态，确保每条边被覆盖。

#### 2. 作者：pengym (赞：35)
- **星级**：★★★★
- **关键亮点**：
  - 提出了**最小点覆盖**与**最大匹配**的关系，提供了不同的解题思路。
  - 使用了匈牙利算法求解最大匹配，展示了树形DP之外的另一种解法。
- **核心代码**：
  ```cpp
  int dfs(int x) {
      for (int i = beg[x]; i; i = nex[i]) {
          int y = to[i];
          if (!vis[y]) {
              vis[y] = 1;
              if (!match[y] || dfs(match[y])) {
                  match[y] = x;
                  return 1;
              }
          }
      }
      return 0;
  }
  ```
  **实现思想**：通过匈牙利算法求解最大匹配，最终最小点覆盖数为最大匹配数的一半。

#### 3. 作者：BFqwq (赞：15)
- **星级**：★★★★
- **关键亮点**：
  - 从链式结构入手，逐步推导到树形结构，帮助理解树形DP的递推过程。
  - 提供了详细的转移方程推导，适合初学者理解。
- **核心代码**：
  ```cpp
  void dfs(int u, int fa) {
      f[u][1] = 1, f[u][0] = 0;
      for (int i = h[u]; i; i = e[i].nxt) {
          int v = e[i].to;
          if (v == fa) continue;
          dfs(v, u);
          f[u][0] += f[v][1];
          f[u][1] += min(f[v][1], f[v][0]);
      }
  }
  ```
  **实现思想**：通过DFS遍历树，自底向上计算每个节点的状态，确保每条边被覆盖。

### 最优关键思路与技巧

1. **树形DP的核心思想**：通过递归遍历树，自底向上计算每个节点的状态，确保每条边被覆盖。状态转移方程为：
   - `dp[u][0] = sum(dp[v][1])`，表示不选 `u` 时，必须选所有子节点 `v`。
   - `dp[u][1] = 1 + sum(min(dp[v][0], dp[v][1]))`，表示选 `u` 时，子节点可选可不选。

2. **最小点覆盖与最大匹配**：在树中，最小点覆盖数等于最大匹配数。可以通过匈牙利算法求解最大匹配，进而得到最小点覆盖数。

### 拓展思路与类似题目

1. **类似题目**：
   - [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)：树形DP，选择不相邻的节点使权值和最大。
   - [P2899 手机网络](https://www.luogu.com.cn/problem/P2899)：树形DP，选择节点覆盖所有边。
   - [P3942 将军令](https://www.luogu.com.cn/problem/P3942)：树形DP，选择节点覆盖所有节点。

2. **调试与顿悟**：在调试过程中，注意树的遍历顺序和状态转移的正确性，确保每条边被覆盖。可以通过画图辅助理解状态转移过程。

### 总结

树形DP是解决树结构问题的有效方法，关键在于定义合适的状态和转移方程。通过自底向上的递归遍历，可以高效地求解最小点覆盖问题。此外，最小点覆盖与最大匹配的关系也为解题提供了另一种思路。

---
处理用时：37.52秒
# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果

### 综合分析与结论

本题是一个经典的线段树应用问题，主要考察区间修改（加法和乘法）和区间查询操作。题解中大部分采用了线段树的实现方式，部分题解还引入了分块或zkw线段树的优化。总体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，而另一些则较为冗长或缺乏优化。

### 精选题解

#### 1. **作者：Mingoal (★★★★★)**
   - **关键亮点**：代码简洁，思路清晰，使用了线段树的基本结构，并通过`pushdown`和`pushup`函数实现了区间加法和乘法的操作。代码中使用了位运算优化，提高了效率。
   - **个人心得**：作者提到“线段树不熟，打几遍都不嫌多”，强调了多练习的重要性。
   - **核心代码**：
     ```cpp
     void pushdown(int p, int l, int r) {
         if (mul[p] == 1 && add[p] == 0) return;
         if (l != r) {
             sum[ls] = (sum[ls] * mul[p] + add[p] * (mid - l + 1)) % mod;
             sum[rs] = (sum[rs] * mul[p] + add[p] * (r - mid)) % mod;
             mul[ls] = (mul[ls] * mul[p]) % mod;
             mul[rs] = (mul[rs] * mul[p]) % mod;
             add[ls] = (add[ls] * mul[p] + add[p]) % mod;
             add[rs] = (add[rs] * mul[p] + add[p]) % mod;
         }
         mul[p] = 1; add[p] = 0;
     }
     ```
   - **核心思想**：通过`pushdown`函数下放标记，确保在区间修改时正确更新子节点的值。

#### 2. **作者：GaryZhong (★★★★☆)**
   - **关键亮点**：使用了结构体指针构建线段树，避免了四倍内存的问题，代码结构清晰，适合动态分配内存的场景。
   - **核心代码**：
     ```cpp
     void down(int rt, int l, int r) {
         if (mtp[rt] == 1 && inc[rt] == 0) return;
         if (l != r)
             mtp[lson] = mtp[lson] * mtp[rt] % P,
             mtp[rson] = mtp[rson] * mtp[rt] % P,
             inc[lson] = (inc[lson] * mtp[rt] % P + inc[rt]) % P,
             inc[rson] = (inc[rson] * mtp[rt] % P + inc[rt]) % P;
         sum[rt] = (sum[rt] * mtp[rt] % P + inc[rt] * (r - l + 1) % P) % P;
         mtp[rt] = 1, inc[rt] = 0;
     }
     ```
   - **核心思想**：通过`down`函数下放标记，确保在区间修改时正确更新子节点的值。

#### 3. **作者：1010_ (★★★★☆)**
   - **关键亮点**：代码简洁，使用了线段树的基本结构，并通过`pushdown`和`pushup`函数实现了区间加法和乘法的操作。代码中使用了位运算优化，提高了效率。
   - **核心代码**：
     ```cpp
     void pushdown(int o, int l, int r) {
         if (add[o] || mul[o] != 1) {
             int mid = (l + r) >> 1;
             sum[ls] = (sum[ls] * mul[o] + add[o] * (mid - l + 1)) % p;
             sum[rs] = (sum[rs] * mul[o] + add[o] * (r - mid)) % p;
             add[ls] = (add[ls] * mul[o] + add[o]) % p;
             add[rs] = (add[rs] * mul[o] + add[o]) % p;
             mul[ls] = (mul[ls] * mul[o]) % p;
             mul[rs] = (mul[rs] * mul[o]) % p;
             mul[o] = 1; add[o] = 0;
         }
     }
     ```
   - **核心思想**：通过`pushdown`函数下放标记，确保在区间修改时正确更新子节点的值。

### 最优关键思路与技巧

1. **标记下放**：在区间修改时，通过`pushdown`函数下放标记，确保子节点的值正确更新。这是线段树实现区间操作的核心技巧。
2. **位运算优化**：使用位运算（如`lson = rt << 1`）来快速计算左右子节点的索引，提高代码效率。
3. **动态分配内存**：部分题解使用了结构体指针动态分配内存，避免了四倍内存的问题，适合内存受限的场景。

### 可拓展之处

1. **分块算法**：对于某些问题，分块算法可能比线段树更高效，尤其是在区间修改和查询操作较为简单的情况下。
2. **zkw线段树**：zkw线段树是一种非递归实现的线段树，适合对性能要求极高的场景。

### 推荐题目

1. **P3373 【模板】线段树 2**：与本题类似，考察区间加法和乘法操作。
2. **P3372 【模板】线段树 1**：考察区间加法和区间查询操作。
3. **P3384 【模板】树链剖分**：考察树链剖分，涉及区间修改和查询操作。

### 个人心得摘录

- **Mingoal**：“线段树不熟，打几遍都不嫌多。” 强调了多练习的重要性。
- **GaryZhong**：“线段树的惰性标记也是线段树最优美的地方之一。” 强调了标记下放的重要性。

---
处理用时：52.22秒
# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过并查集维护动物之间的复杂关系（同类、捕食、被捕食）。题解中主要采用了两种思路：
1. **三倍并查集**：将每个动物分为三个部分（同类、捕食、被捕食），通过合并和查询操作维护关系。
2. **带权并查集**：通过权值表示动物之间的关系（0-同类，1-捕食，2-被捕食），利用路径压缩和权值传递来维护关系。

大部分题解都较好地解决了问题，但部分题解在代码可读性和思路清晰度上有所欠缺。以下是对部分题解的评分与亮点总结。

### 所选题解

#### 1. 作者：Sooke (赞：2064)
- **星级**：5星
- **关键亮点**：
  - 详细解释了种类并查集的概念，适合初学者。
  - 通过三倍并查集维护三种关系，思路清晰。
  - 代码简洁，注释详细，易于理解。
- **个人心得**：
  - 强调了并查集的传递性，帮助理解复杂关系的维护。
  
**核心代码**：
```cpp
int find(int u) { return fa[u] == u ? u : fa[u] = find(fa[u]); }
void unionn(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx != fy) fa[fx] = fy;
}
```
**实现思想**：通过三倍并查集维护同类、捕食、被捕食关系，合并时同时更新三种关系。

#### 2. 作者：天泽龟 (赞：230)
- **星级**：4星
- **关键亮点**：
  - 使用带权并查集，通过权值表示关系，优化了空间复杂度。
  - 详细推导了权值的传递公式，帮助理解关系维护。
- **个人心得**：
  - 强调了权值的实质是“三元环上沿有向边走过的边数”，帮助理解权值的计算。

**核心代码**：
```cpp
int find(int x) {
    if (x != fa[x]) {
        int t = fa[x];
        fa[x] = find(fa[x]);
        d[x] = (d[x] + d[t]) % 3;
    }
    return fa[x];
}
```
**实现思想**：通过带权并查集维护关系，路径压缩时更新权值。

#### 3. 作者：Strong_Jelly (赞：22)
- **星级**：4星
- **关键亮点**：
  - 通过深度表示动物之间的关系，利用模运算简化关系判断。
  - 代码实现简洁，逻辑清晰。
- **个人心得**：
  - 强调了深度与食物链等级的关系，帮助理解模运算的应用。

**核心代码**：
```cpp
int find(int x) {
    if (x != fa[x]) {
        int t = fa[x];
        fa[x] = find(fa[x]);
        deep[x] = (deep[x] + deep[t]) % 3;
    }
    return fa[x];
}
```
**实现思想**：通过深度表示关系，路径压缩时更新深度。

### 最优关键思路与技巧

1. **三倍并查集**：通过将每个动物分为三个部分（同类、捕食、被捕食），可以清晰地维护复杂关系。
2. **带权并查集**：通过权值表示关系，利用路径压缩和权值传递来简化关系维护。
3. **模运算**：利用模3运算简化关系判断，特别是在带权并查集中。

### 可拓展之处

- **同类型题**：类似的关系维护问题，如P1525 关押罪犯（维护敌对关系）。
- **算法套路**：带权并查集可以用于维护多种复杂关系，如P1892 团伙（维护朋友与敌人关系）。

### 推荐题目

1. P1525 关押罪犯（维护敌对关系）
2. P1892 团伙（维护朋友与敌人关系）
3. P1196 银河英雄传说（维护距离关系）

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现并查集初始化错误，导致无限递归，强调了初始化的重

---
处理用时：36.71秒
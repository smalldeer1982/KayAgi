# 题目信息

# 龙兄摘苹果

## 题目描述

龙兄在淘淘摘苹果的那个果园里摘了 $n$ 个完全互不相同的苹果，好客的园主为他提供了 $k$ 个篮子，他想把苹果装在篮子里拎回家（由于龙兄的手是无限大的，所以你不必考虑他能不能同时拎这么多篮子）。

同时，他不希望有任何一个篮子里是空的，因为这样就做不到物尽其用。因此他想知道一共有多少种放苹果的方法，由于他的大脑运算过慢，所以找到了聪明机智的你，他在摘苹果上已经花了很长时间，所以他只能等 $1$ 秒。

由于方法很可能非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常多，龙兄的大脑无法存储，所以他会给你一个数 $p$，输出方法数除以 $p$ 的余数就可以了。

## 说明/提示

### 样例解释

一共有 $4$ 个苹果，$2$ 个篮子。

有以下 $7$ 种方法。

- $\{1\},\{2,3,4\}$；
- $\{2\},\{1,3,4\}$；
- $\{3\},\{1,2,4\}$；
- $\{4\},\{1,2,3\}$；
- $\{1,2\},\{3,4\}$；
- $\{1,3\},\{2,4\}$；
- $\{1,4\},\{2,3\}$。

$7$ 除以 $3$ 余 $1$。

### 数据范围及约定

- 对于 $20\%$ 的数据，$n \le 8$，$k \le 8$。
- 对于 $60\%$ 的数据，$n \le 100$，$k \le 100$。
- 对于 $100\%$ 的数据，$n \le 10000$，$k \le 1000$。

保证所有数据 $n \ge k$，且答案在 $64$ 位整型范围内。

## 样例 #1

### 输入

```
4 2 3```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心是计算将 $n$ 个不同的苹果放入 $k$ 个非空篮子中的方案数，即第二类斯特林数。所有题解都采用了动态规划（DP）的思路，递推公式为 $S(i,j) = S(i-1,j-1) + S(i-1,j) \times j$，并通过取模操作避免溢出。部分题解还进行了空间优化，如使用滚动数组或一维数组来减少内存消耗。

### 评分较高的题解

#### 1. **作者：翼德天尊 (5星)**
- **关键亮点**：思路清晰，递推公式解释详细，代码简洁且可读性强。使用了二维数组存储状态，并在每一步进行取模操作，确保结果不溢出。
- **个人心得**：作者强调了递推公式的推导过程，帮助读者理解为什么 $S(i,j) = S(i-1,j-1) + S(i-1,j) \times j$，并通过代码展示了如何实现这一递推关系。
- **核心代码**：
```cpp
unsigned long long ans[10001][1001];
for (int i=1;i<=n;i++) {
    ans[i][1]=1;
    for (int j=2;j<=k;j++)
        ans[i][j]=((j%p)*(ans[i-1][j]%p)%p+(ans[i-1][j-1])%p)%p;
}
```

#### 2. **作者：小柯 (4星)**
- **关键亮点**：在递推公式的基础上，进一步优化了空间复杂度，使用了滚动数组和一维数组，减少了内存使用。代码中使用了 `__int128` 来处理大数，避免了溢出问题。
- **个人心得**：作者通过优化空间复杂度，展示了如何在数据规模较大的情况下，依然保持高效的计算。
- **核心代码**：
```cpp
__int128 f[2][1005];
for(int i=1;i<=n;i++) {
    for(int j=min(i,k);j>=(i==1?2:1);j--) {
        f[i&1][j]=((f[(i+1)&1][j]*j)%p+f[(i+1)&1][j-1]%p)%p;
    }
}
```

#### 3. **作者：VCVCVCFop_zz (4星)**
- **关键亮点**：直接指出本题是第二类斯特林数的应用，并给出了简洁的递推公式和代码实现。代码中使用了 `unsigned long long` 来避免溢出，并在每一步进行取模操作。
- **个人心得**：作者强调了取模操作的重要性，提醒读者在递推过程中要时刻注意取模，避免溢出。
- **核心代码**：
```cpp
unsigned long long f[10001][1001];
for (int i=1;i<=n;i++) {
    f[i][1]=1;
    for (int j=1;j<=m;j++)
        f[i][j]=((j%mo)*(f[i-1][j]%mo)%mo+(f[i-1][j-1])%mo)%mo;
}
```

### 最优关键思路与技巧

1. **递推公式**：$S(i,j) = S(i-1,j-1) + S(i-1,j) \times j$ 是解决本题的核心，理解其含义是关键。
2. **取模操作**：在每一步递推中都要进行取模操作，避免结果过大导致溢出。
3. **空间优化**：使用滚动数组或一维数组可以减少内存消耗，尤其是在数据规模较大的情况下。

### 可拓展之处

本题的第二类斯特林数可以推广到其他组合数学问题，如将 $n$ 个不同的元素划分成 $k$ 个非空子集的方案数。类似的问题还有：
- **P1655 小朋友分糖果**：将 $n$ 个不同的糖果分给 $k$ 个小朋友，每个小朋友至少分到一个糖果的方案数。
- **P1287 盒子与球**：将 $n$ 个不同的球放入 $k$ 个不同的盒子中，每个盒子至少有一个球的方案数。
- **P1025 数的划分**：将整数 $n$ 划分成 $k$ 个正整数之和的方案数。

### 推荐题目

1. **P1655 小朋友分糖果**（考察第二类斯特林数）
2. **P1287 盒子与球**（考察第二类斯特林数）
3. **P1025 数的划分**（考察整数划分与组合数学）

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中遇到了溢出问题，最终通过使用 `unsigned long long` 或 `__int128` 解决了问题。
- **踩坑教训**：取模操作的重要性被多次强调，尤其是在递推过程中，时刻取模可以避免溢出。
- **顿悟感想**：通过递推公式的推导，理解第二类斯特林数的本质，能够更好地解决类似的组合数学问题。

---
处理用时：28.23秒
# 题目信息

# 脑力达人之分割字串

## 题目背景

好吧，该来的废话还是要来的。

画外音：

终于，在两轮的重重选拔之后，我们的海选终于结束了。现在进入我们的循环赛环节。循坏赛一共有四场，最后选出得分最高的 $16$ 人进入对决，得分相同则和按用时排名，若仍有不能确定 $16$ 人的情况，则去尾处理。

欢迎您收看有洛谷卫视重磅推出的综合性文艺知识类节目“开心玩游戏，轻松赢比赛”，我是 LUWM。学编程，就选洛谷， 感谢洛谷 Online Judge 对本节目的大力支持。下面，我们有请 $10$ 位选手上台，由大屏幕给出题目。


## 题目描述

现在有一个字符串，你可以对这个字符串进行拆分，如 `abcvsdaas` 可以拆分为 `abc|vs|d|aas`，现在再给你一个字典，要求分割成的每一个子串必须要有包含其中的任意一个单词。那么最多可以分为几个子串呢？


## 说明/提示

特殊情况：

如果原字符串不能被分割，请输出 $0$。



数据范围：

对于 $20\%$ 的数据，$1\leq |s| \leq 50,1\leq n\leq 50$。

对于 $100\%$ 的数据，$1\leq |A_i| \leq |s|\leq 300，1\leq N\leq 500$。

其中，$|s|,|A_i|$ 表示字符串 $s$ 与 $A_i$ 的长度。

## 样例 #1

### 输入

```
asdsd

3

as

sd

ds```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何将一个字符串分割成尽可能多的子串，且每个子串必须包含字典中的某个单词。题解中主要采用了以下几种思路：

1. **贪心算法**：通过记录所有可能的子串区间，然后选择不相交的区间，最大化分割次数。
2. **动态规划**：通过状态转移方程 `f[i] = max(f[i], f[j-1] + 1)` 来计算前 `i` 个字符的最大分割数。
3. **字符串匹配与优化**：利用 `string::find()` 或 `substr()` 进行字符串匹配，并结合贪心或动态规划进行优化。

### 所选题解

#### 1. 作者：syf2008 (★★★★☆)
- **关键亮点**：通过记录所有可能的子串区间，并利用贪心算法选择不相交的区间，思路清晰且代码简洁。
- **核心代码**：
  ```cpp
  sort(f+1,f+s+1,cmp);
  for(int i=1;i<=s;i++) 
      if(tmp<f[i].l) {
          tmp=f[i].r;
          ans++;
      }
  ```
  **实现思想**：将所有子串区间按右端点排序，然后选择不相交的区间，统计最大分割数。

#### 2. 作者：深海鱼的眼泪 (★★★★☆)
- **关键亮点**：使用动态规划，通过枚举每个字符和字典中的单词进行匹配，并更新状态转移方程，代码逻辑清晰。
- **核心代码**：
  ```cpp
  for(int i=0;i<l;i++) {
      for(int j=1;j<=n;j++) {
          int len=strlen(si[j]);
          if (l-i<len) continue;
          if (can_match(i, j)) {
              for(int k=i+len-1;k<l;k++) {
                  if (i==0) f[k]=max(f[k],1);
                  else f[k]=max(f[k],f[i-1]+1);
              }
          }
      }
  }
  ```
  **实现思想**：通过动态规划，枚举每个字符和字典中的单词，更新前 `i` 个字符的最大分割数。

#### 3. 作者：a16_ (★★★★☆)
- **关键亮点**：使用 `unordered_map` 进行快速查找，结合动态规划，优化了字符串匹配的效率。
- **核心代码**：
  ```cpp
  for(int i=0;i<l;i++) {
      string temp="";
      f[i]=f[i-1];
      for(int j=i;j>=0;j--) {
          temp=s[j]+temp;
          if(m[temp]) {
              f[i]=max(f[i],(j>0?f[j-1]:0)+1);
          }
      }
  }
  ```
  **实现思想**：通过动态规划，从后向前枚举子串，利用 `unordered_map` 快速判断是否在字典中，更新状态转移方程。

### 最优关键思路与技巧

1. **贪心算法**：通过记录所有可能的子串区间，选择不相交的区间，最大化分割次数。
2. **动态规划**：通过状态转移方程 `f[i] = max(f[i], f[j-1] + 1)` 来计算前 `i` 个字符的最大分割数。
3. **字符串匹配优化**：利用 `string::find()` 或 `substr()` 进行字符串匹配，并结合贪心或动态规划进行优化。

### 可拓展之处

- **同类型题**：类似的问题可以扩展到其他字符串分割问题，如最小分割次数、分割后的子串满足特定条件等。
- **算法套路**：贪心算法和动态规划是解决字符串分割问题的常用套路，可以结合其他数据结构如 Trie 树、哈希表等进行优化。

### 推荐题目

1. [P1803 线段覆盖](https://www.luogu.com.cn/problem/P1803)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得总结

- **调试经历**：在实现动态规划时，需要注意边界条件的处理，如 `f[0]` 的初始化。
- **踩坑教训**：在使用 `string::find()` 时，要注意返回值的处理，避免越界访问。
- **顿悟感想**：贪心算法和动态规划的结合可以有效解决复杂的字符串分割问题，理解其背后的思想是关键。

---
处理用时：28.78秒
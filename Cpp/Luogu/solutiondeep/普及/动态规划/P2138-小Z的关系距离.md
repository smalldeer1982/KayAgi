# 题目信息

# 小Z的关系距离

## 题目描述

小 Z 学习了辩证唯物主义，知道了联系具有普遍性。他看着草稿纸上的字符串，就想挖掘它们之间的关系。

小 Z 认为，对于两个字符串 $a,b$，如果它们各自删除不超过其自身长度一半的字符能够相等，则称 $a,b$ 有距离为 $1$ 的关系。而如果存在另一个字符串 $c$，它和 $a$ 有距离为 $1$ 的关系，和 $b$ 有距离为 $n$ 的关系，则称 $a,b$ 有距离为 $n + 1$ 的关系。

现在小 Z 随机挑选出了两个小写字母字符串 $a,b$，想知道它们之间关系的最小距离，希望你帮帮他。

## 说明/提示

对于 $30\%$ 的数据，$a,b$ 由同一字母构成。

对于 $100\%$ 的数据，$1 \leq |a|,|b| \leq 100$。

## 样例 #1

### 输入

```
abcdef
axcyd```

### 输出

```
1```

## 样例 #2

### 输入

```
a
b```

### 输出

```
2```

## 样例 #3

### 输入

```
abb
baa```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心在于通过最长公共子序列（LCS）来判断两个字符串的关系距离，并通过动态规划（DP）来求解。所有题解都基于LCS的思路，通过不断扩展较短的字符串来增加LCS的长度，直到满足条件。题解之间的差异主要体现在代码实现、优化程度和解释的清晰度上。

### 所选高星题解

#### 1. **题解作者：Math_rad_round (5星)**
   - **关键亮点**：思路清晰，代码简洁，优化程度高。通过LCS的DP求解，并利用不断扩展较短字符串的策略来增加LCS的长度，直到满足条件。代码中特判了字符串相等的情况，进一步优化了性能。
   - **个人心得**：作者提到“两字符串相等时答案为1”，这是一个容易被忽略的边界情况，体现了对细节的关注。

   **核心代码：**
   ```cpp
   int ans = 0;
   for(int i=1;i<=n;i++){
       for(int j=1;j<=m;j++){
           f[i][j]=max(f[i-1][j],f[i][j-1]);
           if(a[i-1]==b[j-1])f[i][j]=max(f[i][j],f[i-1][j-1]+1);
           ans=max(f[i][j],ans);
       }
   }
   int cnt=0;
   while(ans*2<n){
       cnt++;ans+=m;m+=m;
   }cnt++;
   cout<<cnt;
   ```

#### 2. **题解作者：__JiCanDuck__ (4星)**
   - **关键亮点**：思路与第一篇类似，但代码实现略有不同，增加了对字符串长度的交换处理，使得代码更具通用性。解释较为详细，适合初学者理解。
   - **个人心得**：作者提到“当$B$的长度乘$2$，那么和原$B$的距离加1”，这一思路的清晰表述有助于理解算法的核心。

   **核心代码：**
   ```cpp
   for(int i=1;i<=n;i++){
       for(int j=1;j<=m;j++){
           if(aa[i]==bb[j]) dp[i][j]=dp[i-1][j-1]+1;  
           else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
       }
   }
   lcs=dp[n][m];
   while(lcs*2<n){
       cnt++;lcs+=m;m+=m;
   }
   cnt++;
   ```

#### 3. **题解作者：X_SpiderMan (4星)**
   - **关键亮点**：思路清晰，代码简洁，优化程度高。通过LCS的DP求解，并利用不断扩展较短字符串的策略来增加LCS的长度，直到满足条件。代码中特判了字符串相等的情况，进一步优化了性能。
   - **个人心得**：作者提到“当$b| s | \times 2$ 时，与原字符串 $b$ 的距离 $+1$”，这一思路的清晰表述有助于理解算法的核心。

   **核心代码：**
   ```cpp
   int ans=0;
   for(int i=1;i<=n;i++)
       for(int j=1;j<=m;j++){
           f[i][j]=max(f[i-1][j],f[i][j-1]);
           if(a[i-1]==b[j-1]) f[i][j]=max(f[i][j],f[i-1][j-1]+1);
           ans=max(f[i][j],ans);
       }
   while(ans*2<n){
       cnt++;ans+=m;m*=2;
   }
   cnt++;
   ```

### 最优关键思路与技巧

1. **LCS的DP求解**：通过动态规划求解最长公共子序列，判断两个字符串的关系距离。
2. **字符串扩展策略**：通过不断扩展较短的字符串来增加LCS的长度，直到满足条件。
3. **边界条件处理**：特判字符串相等的情况，避免不必要的计算。

### 可拓展之处

1. **类似算法套路**：LCS的DP求解可以应用于其他字符串匹配问题，如编辑距离、最长回文子序列等。
2. **优化策略**：可以通过预处理或剪枝进一步优化算法性能。

### 推荐题目

1. **P1143 最长公共子序列**：直接考察LCS的求解。
2. **P2758 编辑距离**：通过DP求解字符串之间的编辑距离。
3. **P1439 最长回文子序列**：通过DP求解字符串中的最长回文子序列。

### 个人心得总结

- **调试经历**：在处理边界条件时，特判字符串相等的情况可以避免不必要的计算，提高代码效率。
- **踩坑教训**：忽略边界条件可能导致错误的结果，需特别注意。
- **顿悟感想**：通过不断扩展较短字符串的策略，可以有效地增加LCS的长度，直到满足条件。

---
处理用时：32.81秒
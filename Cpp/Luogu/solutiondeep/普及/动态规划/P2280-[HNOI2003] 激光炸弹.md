# 题目信息

# [HNOI2003] 激光炸弹

## 题目描述

一种新型的激光炸弹，可以摧毁一个边长为 $m$ 的正方形内的所有目标。现在地图上有 $n$ 个目标，用整数 $x_i$ , $y_i$ 表示目标在地图上的位置，每个目标都有一个价值 $v_i$。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为 $m$ 的边必须与 $x$ 轴，$y$ 轴平行。若目标位于爆破正方形的边上，该目标不会被摧毁。

现在你的任务是计算一颗炸弹最多能炸掉地图上总价值为多少的目标。

可能存在多个目标在同一位置上的情况。

## 说明/提示

**数据规模与约定**

- 对于 $100\%$ 的数据，保证 $1 \le n \le 10^4$，$0 \le x_i ,y_i \le 5\times 10^3$，$1 \le m \le 5\times 10^3$，$1 \le v_i < 100$。

## 样例 #1

### 输入

```
2 1
0 0 1
1 1 1
```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心是使用**二维前缀和**来快速计算任意正方形区域内的目标价值总和。大多数题解都采用了这一思路，但在实现细节、优化程度和代码可读性上有所不同。以下是对各题解的对比与总结：

1. **算法要点**：所有题解都使用了二维前缀和来预处理数据，并通过容斥原理计算正方形区域内的价值总和。部分题解还考虑了空间优化、边界处理等细节。
2. **难点对比**：主要难点在于如何处理边界情况（如坐标为0或超出范围）以及如何优化空间复杂度。部分题解通过坐标偏移或使用`short`类型来优化空间。
3. **优化程度**：部分题解在空间优化上做得较好，如使用`short`类型或原地修改前缀和数组。
4. **代码可读性**：部分题解代码结构清晰，注释详细，便于理解；而有些题解代码较为简略，缺乏必要的注释。

### 精选题解

#### 题解1：作者：iMya_nlgau (赞：421)
- **星级**：5星
- **关键亮点**：
  - 详细解释了二维前缀和的推导过程，包括容斥原理的应用。
  - 提供了两种计算二维前缀和的方法，并对比了它们的优劣。
  - 代码结构清晰，注释详细，便于理解。
  - 考虑了边界处理和空间优化。
- **个人心得**：作者提到使用`short`类型虽然在某些情况下可以通过，但为了保险起见，建议使用`int`类型。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= N; i ++)
      for (int j = 1; j <= N; j ++)
          s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + s[i][j];
  ```

#### 题解2：作者：do_while_true (赞：28)
- **星级**：4星
- **关键亮点**：
  - 通过坐标偏移避免了边界问题。
  - 代码简洁，逻辑清晰。
  - 提供了对正方形覆盖范围的直观解释。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= 5001; i++)
      for (int j = 1; j <= 5001; j++)
          sum[i][j] += sum[i][j - 1] - sum[i - 1][j - 1] + sum[i - 1][j];
  ```

#### 题解3：作者：lowAltitudeFlyer (赞：20)
- **星级**：4星
- **关键亮点**：
  - 提供了对二维前缀和的详细推导，包括容斥原理的应用。
  - 代码结构清晰，注释详细。
  - 考虑了边界处理和空间优化。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= 5001; i++)
      for (int j = 1; j <= 5001; j++)
          a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];
  ```

### 最优关键思路与技巧

1. **二维前缀和**：通过预处理二维前缀和数组，可以在O(1)时间内计算任意矩形区域内的价值总和。
2. **容斥原理**：在计算二维前缀和时，使用容斥原理避免重复计算。
3. **坐标偏移**：通过将坐标加1，避免了边界为0时的数组越界问题。
4. **空间优化**：使用`short`类型或原地修改前缀和数组来优化空间复杂度。

### 拓展与举一反三

1. **类似算法套路**：二维前缀和常用于处理矩形区域内的求和问题，类似的算法还有二维差分，用于处理矩形区域内的修改操作。
2. **同类型题目**：
   - [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)
   - [P2004 领地选择](https://www.luogu.com.cn/problem/P2004)
   - [P2280 激光炸弹](https://www.luogu.com.cn/problem/P2280)

### 个人心得总结

- **调试经历**：部分作者提到在使用`short`类型时虽然可以通过测试，但为了保险起见，建议使用`int`类型。
- **踩坑教训**：在处理边界情况时，坐标偏移是一个常用的技巧，可以有效避免数组越界问题。
- **顿悟感想**：通过二维前缀和和容斥原理的结合，可以高效解决矩形区域内的求和问题。

---
处理用时：32.17秒
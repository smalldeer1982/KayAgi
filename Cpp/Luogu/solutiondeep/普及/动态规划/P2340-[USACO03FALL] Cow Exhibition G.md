# 题目信息

# [USACO03FALL] Cow Exhibition G

## 题目背景




## 题目描述

奶牛想证明它们是聪明而风趣的。为此，贝西筹备了一个奶牛博览会，她已经对 $N$ 头奶牛进行了面试，确定了每头奶牛的智商和情商。

贝西有权选择让哪些奶牛参加展览。由于负的智商或情商会造成负面效果，所以贝西不希望出展奶牛的智商之和小于零，或情商之和小于零。满足这两个条件下，她希望出展奶牛的智商与情商之和越大越好，请帮助贝西求出这个最大值。


## 说明/提示

选择第一头，第三头，第四头奶牛，智商和为−5+6+2 = 3，情商和为7−3+1 = 5。再加

入第二号奶牛可使总和提升到10，不过由于情商和变成负的了，所以是不允许的


## 样例 #1

### 输入

```
5
-5 7
8 -6
6 -3
2 1
-8 -5```

### 输出

```
8```

# AI分析结果

### 综合分析与结论

本题的核心是一个带有约束条件的01背包问题，要求在选择奶牛时，智商和情商的总和都不能为负，且两者的总和要尽可能大。由于智商和情商可能为负，传统的01背包实现需要做一些调整，特别是如何处理负值的问题。大部分题解都采用了数组平移的技巧，将负值映射到正数范围内，从而避免了数组越界的问题。

### 题解评分与亮点

1. **学而思李老师 (5星)**
   - **关键亮点**：详细解释了01背包的变形思路，特别是如何处理负值的问题，并提供了清晰的代码实现。通过数组平移和滚动数组优化，解决了空间和时间复杂度的问题。
   - **个人心得**：作者强调了在动态规划中，状态转移方程的推导和初始状态的设置是关键，特别是在处理负值时，数组平移是一个非常有效的技巧。
   - **核心代码**：
     ```cpp
     memset(dp, -0x3f, sizeof dp);
     dp[400000] = 0;
     for(int i = 1; i <= n; i ++)
     {
         if(a[i].iq >= 0)
             for(int j = 800000; j >= a[i].iq; j --)
                 dp[j] = max(dp[j], dp[j-a[i].iq] + a[i].eq);
         else
             for(int j = 0; j <= 800000 + a[i].iq; j ++)
                 dp[j] = max(dp[j], dp[j-a[i].iq] + a[i].eq);
     }
     for(int i = 400000; i <= 800000; i ++)
         if(dp[i] > 0)
             ans = max(ans, i + dp[i] - 400000);
     ```

2. **YJunJ (4星)**
   - **关键亮点**：作者通过将智商作为代价，情商作为价值，将问题转化为01背包问题，并详细解释了如何处理负值的情况。代码实现简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     memset(f, -0x3f, sizeof(f));
     f[400000] = 0;
     for(int i=1;i<=n;i++) {
         if(cow[i].s>=0) {
             for(int j=800000;j>=cow[i].s;j--)
                 f[j]=max(f[j],f[j-cow[i].s]+cow[i].f);
         }else {
             for(int j=0;j<=800000+cow[i].s;j++)
                 f[j]=max(f[j],f[j-cow[i].s]+cow[i].f);
         }
     }
     for(int i=400000;i<=800000;i++)
         if(f[i]>=0)
             maxx=max(maxx,f[i]+i-400000);
     ```

3. **monstersqwq (4星)**
   - **关键亮点**：作者通过滚动数组和数组平移的技巧，优化了空间复杂度，并提供了详细的优化思路。代码实现较为高效，适合处理大规模数据。
   - **核心代码**：
     ```cpp
     memset(dp,~0x3f3f3f3f,sizeof(dp));
     dp[0+MR]=0;
     for(int i=1;i<=n;i++)
     {
         if(iq[i]>0)
         {
             for(int j=MR;j>=-MR;j--)
             {
                 if(-MR<=j-iq[i]&&j-iq[i]<=MR)
                 dp[j+MR]=max(dp[j+MR],dp[j-iq[i]+MR]+eq[i]);
             }
         }
         else
         {
             for(int j=-MR;j<=MR;j++)
             {
                 if(-MR<=j-iq[i]&&j-iq[i]<=MR)
                 dp[j+MR]=max(dp[j+MR],dp[j-iq[i]+MR]+eq[i]);
             }
         }
     }
     for(int i=0;i<=MR;i++)
     {
         if(dp[i+MR]>=0)
         {
             ans=max(i+dp[i+MR],ans);
         }
     }
     ```

### 最优关键思路与技巧

1. **数组平移**：由于智商和情商可能为负，直接将它们作为数组下标会导致越界。通过将数组整体平移（如加上400000），可以将负值映射到正数范围内，从而避免了越界问题。
2. **滚动数组优化**：在处理动态规划问题时，如果当前状态只依赖于前一个状态，可以使用滚动数组来减少空间复杂度。
3. **剪枝与优化**：在搜索或动态规划中，通过剪枝（如跳过明显不优的选择）和优化循环范围，可以显著提高算法的效率。

### 拓展与举一反三

- **同类型题目**：
  1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典的01背包问题。
  2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 带有约束条件的01背包问题。
  3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164) - 类似的选择问题，需要考虑约束条件。

### 个人心得总结

- **调试经历**：在处理负值时，数组越界是一个常见的问题，通过数组平移可以有效解决。
- **踩坑教训**：在动态规划中，初始状态的设置非常重要，特别是当状态可能为负时，需要特别小心。
- **顿悟感想**：通过滚动数组和数组平移的技巧，可以显著优化动态规划的空间和时间复杂度，特别是在处理大规模数据时。

---
处理用时：37.08秒
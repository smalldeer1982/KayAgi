# 题目信息

# 胖男孩

## 题目描述

麦克正如我们所知的已快乐地结婚，在上个月他胖了 $70$ 磅。因为手指上的脂肪过多，使他连给他最亲密的朋友斯拉夫克写一个电子邮件都很困难。

每晚麦克都详细地描述那一天他所吃的所有东西，但有时当他只想按一次某键时往往会按了不止一次，并且他的胖手指还会碰到他不想要按的键，麦克也知道自己的手指有问题，因此他在打字的时候很小心，以确保每打一个想要的字符时误打的字符不超过 $3$ 个，误打的字符可能在正确字符之前也可能在其之后。

当斯拉夫克多次收到读不懂的电子邮件后，他总是要求麦克将电子邮件发 $3$ 遍，使他容易读懂一点。

编写程序，帮助斯拉夫克根据他所收到的三封电子邮件求出麦克可能写出的最长的信。


## 说明/提示

由 @zhouyonglong 提供 SPJ


## 样例 #1

### 输入

```
cecqbhvaiaedpibaluk
cabegviapcihlaaugck
adceevfdadaepcialaukd```

### 输出

```
cevapiluk```

# AI分析结果

### 综合分析与结论

这些题解的核心思路都是通过动态规划（DP）求解三个字符串的最长公共子序列（LCS）。大部分题解使用了三维DP数组 `dp[i][j][k]` 来记录三个字符串前 `i`、`j`、`k` 个字符的LCS长度，并通过另一个数组 `ans[i][j][k]` 或类似的机制来记录LCS的具体内容。尽管题目中提到“误打的字符不超过3个”，但所有题解都忽略了这个条件，直接通过LCS求解，因为LCS的结果必然包含正解。

### 所选高星题解

#### 1. **题解作者：Froranzen (5星)**
- **关键亮点**：思路清晰，代码简洁，直接通过三维DP求解LCS，并通过 `ans` 数组记录LCS内容。代码中使用了 `register` 关键字优化循环变量，提升了性能。
- **个人心得**：作者提到“SPJ”的存在使得可以直接忽略误打字符的条件，简化了问题。

```cpp
for (register int i(1); i <= n; ++i)
    for (register int j(1); j <= m; ++j)
        for (register int l(1); l <= k; ++l) {
            if (awa[i - 1] == waw[j - 1] && awa[i - 1]== aaw[l - 1]) {
                if (qwq[i][j][l] < qwq[i - 1][j - 1][l - 1] +1) {
                    qwq[i][j][l] = qwq[i - 1][j - 1][l - 1] +1;
                    wqw[i][j][l] = wqw[i - 1][j - 1][l - 1] + awa[i - 1];
                } 
            }
            else {
                if (qwq[i][j][l] < qwq[i - 1][j][l]) {
                    qwq[i][j][l] = qwq[i - 1][j][l];
                    wqw[i][j][l] = wqw[i - 1][j][l];
                }
                if (qwq[i][j][l] < qwq[i][j - 1][l]) {
                    qwq[i][j][l] = qwq[i][j - 1][l];
                    wqw[i][j][l] = wqw[i][j - 1][l];
                }
                if (qwq[i][j][l] < qwq[i][j][l - 1]) {
                    qwq[i][j][l] = qwq[i][j][l - 1];
                    wqw[i][j][l] = wqw[i][j][l - 1];
                }
            }
        }
```

#### 2. **题解作者：卷王 (4.5星)**
- **关键亮点**：详细解释了三维DP的状态转移方程，并通过 `ans` 数组记录LCS内容。代码中使用了 `max` 函数简化了继承逻辑。
- **个人心得**：作者提醒读者注意输出的是LCS内容而非长度，避免了常见的错误。

```cpp
for(int i = 1; i <= la; i++)
    for(int j = 1; j <= lb; j++)
        for(int k = 1; k <= lc; k++) {
            if(a[i] == b[j] && b[j] == c[k])
                if(dp[i - 1][j - 1][k - 1] + 1 > dp[i][j][k]) {
                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1;
                    ans[i][j][k] = ans[i - 1][j - 1][k - 1] + a[i];
                }
            if(dp[i - 1][j][k] > dp[i][j][k]) {
                dp[i][j][k] = dp[i - 1][j][k];
                ans[i][j][k] = ans[i - 1][j][k];
            }
            if(dp[i][j - 1][k] > dp[i][j][k]) {
                dp[i][j][k] = dp[i][j - 1][k];
                ans[i][j][k] = ans[i][j - 1][k];
            }
            if(dp[i][j][k - 1] > dp[i][j][k]) {
                dp[i][j][k] = dp[i][j][k - 1];
                ans[i][j][k] = ans[i][j][k - 1];
            }
        }
```

#### 3. **题解作者：皎月半洒花 (4星)**
- **关键亮点**：通过 `dfs` 函数回溯输出LCS内容，避免了额外存储 `ans` 数组，节省了空间。代码中使用了手写 `max` 函数优化了性能。
- **个人心得**：作者提到通过 `dfs` 回溯输出LCS内容，避免了额外的空间开销。

```cpp
inline void Print(int x, int y, int z){
    if (!x || !y || !z) return ;
    if (dp[x][y][z] == dp[x - 1][y][z]) Print(x - 1, y, z) ;
    else if (dp[x][y][z] == dp[x][y - 1][z]) Print(x, y - 1, z) ;
    else if (dp[x][y][z] == dp[x][y][z - 1]) Print(x, y, z - 1) ;
    else if (dp[x][y][z] == dp[x - 1][y - 1][z - 1] + 1) Print(x - 1, y - 1, z - 1), putchar(A[x]) ;
}
```

### 最优关键思路与技巧
1. **三维DP数组**：通过 `dp[i][j][k]` 记录三个字符串前 `i`、`j`、`k` 个字符的LCS长度，状态转移方程清晰。
2. **记录LCS内容**：通过 `ans[i][j][k]` 或 `dfs` 回溯记录LCS的具体内容，避免了仅输出长度的局限性。
3. **空间优化**：通过 `dfs` 回溯输出LCS内容，避免了额外存储 `ans` 数组，节省了空间。

### 拓展思路
- **类似问题**：可以扩展到更多字符串的LCS问题，或者考虑不同字符的权重（如编辑距离问题）。
- **优化方向**：可以考虑进一步优化空间复杂度，例如通过滚动数组减少DP数组的维度。

### 推荐题目
1. **P1439**：最长公共子序列（LCS）的经典题目，适合巩固LCS的基础知识。
2. **P2758**：编辑距离问题，与LCS类似，但增加了字符替换的权重。
3. **P1091**：合唱队形问题，涉及序列的动态规划，适合进一步练习DP的应用。

---
处理用时：44.37秒
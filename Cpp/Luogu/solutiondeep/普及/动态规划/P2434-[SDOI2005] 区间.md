# 题目信息

# [SDOI2005] 区间

## 题目描述

现给定 $n$ 个闭区间 $[a_i, b_i]$（$1 \le i \le n$）。这些区间的并可以表示为一些不相交的闭区间的并。你的任务就是在这些表示方式中找出包含最少区间的方案。你的输出应该按照区间的升序排列。这里如果说两个区间 $[a, b]$ 和 $[c, d]$ 是按照升序排列的，那么我们有 $a \le b < c \le d$。

请写一个程序：

读入这些区间；

计算满足给定条件的不相交闭区间；

把这些区间按照升序输出。

## 说明/提示

对于 $100 \%$ 的数据，$3 \le n \le 50000$，$1 \le a _ i \leq b _ i \le 1000000$。

## 样例 #1

### 输入

```
5

5 6

1 4

10 10

6 9

8 10

```

### 输出

```
1 4

5 10

```

# AI分析结果

### 综合分析与结论

本题要求将多个闭区间合并为最少的不相交闭区间，并按升序输出。题解中主要采用了以下几种思路：

1. **差分法**：通过记录区间的起点和终点，利用差分数组来统计区间的覆盖情况，最后扫描输出结果。时间复杂度为O(1e6)，适用于区间范围较小的情况。
2. **贪心算法**：将区间按左端点排序，依次合并重叠的区间，最终输出不相交的区间。时间复杂度为O(n log n)，适用于区间数量较多的情况。
3. **并查集**：通过并查集合并重叠的区间，最后输出不相交的区间。时间复杂度为O(n log n)，但实现较为复杂。
4. **栈模拟**：将区间视为括号匹配问题，利用栈来合并重叠的区间。时间复杂度为O(n log n)，思路新颖但实现较为复杂。

从代码简洁性、可读性和效率来看，**差分法**和**贪心算法**是最为推荐的解法。差分法代码简洁且易于理解，贪心算法则更为通用，适用于区间数量较大的情况。

### 所选高分题解

#### 1. 作者：蹲在丛中笑 (赞：79)  
**星级：5星**  
**关键亮点**：  
- 使用差分法，代码简洁且高效。
- 通过记录区间的起点和终点，利用差分数组统计区间覆盖情况，最后扫描输出结果。
- 时间复杂度为O(1e6)，适用于区间范围较小的情况。

**核心代码**：
```cpp
#include<stdio.h>
#define N 1000005
int n,x,y,cnt,a[N],b[N];
int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;i++) {
        scanf("%d%d",&x,&y);
        a[x]++; b[y]++;
    }
    for(int i=1;i<N;i++) {
        if(!cnt&&a[i]) printf("%d ",i);
        cnt+=a[i]-b[i];
        if(!cnt&&b[i]) printf("%d\n",i);
    }
}
```

#### 2. 作者：NF_水饺 (赞：21)  
**星级：4星**  
**关键亮点**：  
- 使用贪心算法，代码清晰且易于理解。
- 将区间按左端点排序，依次合并重叠的区间，最终输出不相交的区间。
- 时间复杂度为O(n log n)，适用于区间数量较多的情况。

**核心代码**：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,st,ov;
struct node {
    int lo,hi;
}a[50000+10];
bool cmp(node a,node b) {
    return a.lo<b.lo;
}
int main() {
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].lo>>a[i].hi;
    sort(a+1,a+n+1,cmp);
    st=a[1].lo;
    ov=a[1].hi;
    for(int i=2;i<=n;i++) {
        if(a[i].lo>ov) {
            cout<<st<<" "<<ov<<endl;
            st=a[i].lo;
            ov=max(ov,a[i].hi);
        }
        else ov=max(ov,a[i].hi);
        if(i==n) cout<<st<<" "<<ov<<endl;
    }
    return 0;
}
```

#### 3. 作者：顾z (赞：4)  
**星级：4星**  
**关键亮点**：  
- 使用贪心算法，思路清晰且代码简洁。
- 将区间按左端点排序，依次合并重叠的区间，最终输出不相交的区间。
- 时间复杂度为O(n log n)，适用于区间数量较多的情况。

**核心代码**：
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
IL void read(int &x) {
    int f=1;x=0;char s=getchar();
    while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int n;
struct cod{int l,r;}qujian[50008];
IL bool ccp(const cod&a,const cod&b){return a.l<b.l;}
int main() {
    read(n);
    for(RI i=1;i<=n;i++)
        read(qujian[i].l),read(qujian[i].r);
    std::sort(qujian+1,qujian+n+1,ccp);
    int le=qujian[1].l,re=qujian[1].r;
    for(RI i=2;i<=n;i++) {
        if(re<qujian[i].l) {
            printf("%d %d\n",le,re);
            le=qujian[i].l;
        }
        le=std::min(le,qujian[i].l);
        re=std::max(qujian[i].r,re);
    }
    printf("%d %d\n",le,re);
}
```

### 最优关键思路与技巧

1. **差分法**：适用于区间范围较小的情况，代码简洁且高效。
2. **贪心算法**：适用于区间数量较多的情况，思路清晰且代码易于实现。

### 可拓展之处

- **差分法**可以扩展到其他需要统计区间覆盖的问题，如区间染色、区间统计等。
- **贪心算法**可以扩展到其他需要合并或覆盖区间的问题，如区间调度、区间覆盖等。

### 推荐相似题目

1. [P2082 区间覆盖](https://www.luogu.com.cn/problem/P2082)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3372 线段树 1](https://www.luogu.com.cn/problem/P3372)

### 个人心得总结

- **调试经历**：在贪心算法中，更新区间右端点时需要注意取最大值，否则会导致区间合并错误。
- **踩坑教训**：在差分法中，扫描时需要先处理区间的终点，再处理起点，否则会导致输出错误。
- **顿悟感想**：差分法和贪心算法各有优劣，根据问题特点选择合适的算法是关键。

---
处理用时：39.84秒
# 题目信息

# 双子序列最大和

## 题目描述

给定一个长度为 $n$ 的整数序列，要求从中选出两个连续子序列，使得这两个连续子序列的序列和之和最大，最终只需输出最大和。一个连续子序列的和为该子序列中所有数之和。每个连续子序列的最小长度为 $1$，并且两个连续子序列之间至少间隔一个数。


## 说明/提示

对于 $30\%$ 的数据 $N\le 100$。

对于 $60\%$ 的数据有 $N\le 10000$。

对于 $100\%$ 的数据有 $N\le 1000000$。

数据保证运算过程不会超过 `long long`（`int64`）。

## 样例 #1

### 输入

```
5
83 223 -13 1331 -935```

### 输出

```
1637```

## 样例 #2

### 输入

```
3
83 223 -13```

### 输出

```
70```

# AI分析结果

### 综合分析与结论

这道题目要求从给定序列中选出两个不相交的连续子序列，使得它们的和最大。题解中主要采用了动态规划（DP）的思路，通过预处理前后缀的最大子段和，再枚举中间点来求解最优解。大多数题解的核心思想相似，但在实现细节、代码优化和解释清晰度上有所差异。

### 所选高星题解

#### 1. 题解作者：kradcigam (赞：89)
- **星级：5星**
- **关键亮点**：
  - 思路清晰，详细解释了如何通过预处理前后缀的最大子段和来优化时间复杂度。
  - 代码简洁且可读性强，注释详细，便于理解。
  - 提供了完整的代码实现，且代码结构合理，易于复用。
- **个人心得**：
  - 作者提到预处理的方法可以避免重复计算，使程序跑得更快，强调了优化的重要性。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long x[1000010],f[1000010],l[1000010];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>x[i];
    f[1]=x[1];
    for(int i=2;i<=n;i++)f[i]=max(f[i-1]+x[i],x[i]);//算最大子段
	for(int i=2;i<=n;i++)f[i]=max(f[i-1],f[i]);//算最大子段
	l[n]=x[n];
    for(int i=n-1;i>=1;i--)l[i]=max(l[i+1]+x[i],x[i]);//算最大子段
	for(int i=n-1;i>=1;i--)l[i]=max(l[i+1],l[i]);//算最大子段
	long long ans=f[1]+l[3];
	for(int i=3;i<n;i++)ans=max(ans,f[i-1]+l[i+1]);//枚举中间数
	cout<<ans;
	return 0;
}
```

#### 2. 题解作者：biey (赞：12)
- **星级：4星**
- **关键亮点**：
  - 提供了详细的DP状态设计，解释了如何通过状态转移方程求解问题。
  - 代码实现较为简洁，且注释清晰，便于理解。
  - 强调了状态转移方程的推导过程，帮助读者理解DP的核心思想。

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int n;
typedef long long ll;
const int N = 1e6 + 100;
ll a[N];
ll f[N], g[N];
const ll INF = 999999999999;
ll ansl[N], ansr[N]; 
ll ans = 0;
int main() {
	scanf("%lld", &n);
	ans = -INF;
	ansl[0] = -INF;
	ansr[n + 1] = -INF;
	for(int i = 1; i <= n; ++i) {
		ll x;
		scanf("%lld", &x);
		a[i] = x;
		f[i] = max(f[i - 1] + x, x);
		ansl[i] = max(ansl[i - 1], f[i]);
	}
	for(int i = n; i >= 1; --i) {
		g[i] = max(g[i + 1] + a[i], a[i]);
		ansr[i] = max(ansr[i + 1], g[i]);
	}
	for(int i = 2; i <= n - 1; ++i) {
		ans = max(ansl[i - 1] + ansr[i + 1], ans);
	}
	printf("%lld\n", ans);
	return 0;
}
```

#### 3. 题解作者：flysnow (赞：0)
- **星级：4星**
- **关键亮点**：
  - 提供了详细的思路分析，解释了如何通过预处理前后缀的最大子段和来优化时间复杂度。
  - 代码实现简洁，且注释清晰，便于理解。
  - 强调了枚举中间点的思路，帮助读者理解如何避免重复计算。

```cpp
#include <bits/stdc++.h>
#define ll long long
const int N = 1e6 + 5;
using namespace std;
int n;
ll a[N], suf[N], pre[N];
ll ans;
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i ++) 
		scanf("%lld", &a[i]);
	for (int i = 1; i <= n; i ++)
		pre[i] = max(a[i], pre[i - 1] + a[i]);
	for (int i = 2; i <= n; i ++) 
		pre[i] = max(pre[i], pre[i - 1]);
	for (int i = n; i >= 1; i --)
		suf[i] = max(a[i], suf[i + 1] + a[i]);
	for (int i = n - 1; i >= 1; i --)
		suf[i] = max(suf[i], suf[i + 1]);
	ans = -0x7ffffffffffffff;
	for (int i = 2; i < n; i ++) 
		ans = max(ans, pre[i - 1] + suf[i + 1]);
	printf("%lld\n", ans);
	return 0;
}
```

### 最优关键思路与技巧

1. **预处理前后缀最大子段和**：通过预处理前后缀的最大子段和，可以避免在枚举中间点时重复计算，从而将时间复杂度优化到O(n)。
2. **枚举中间点**：通过枚举中间点，将问题分解为求解前后两部分的最大子段和，再求和得到最终结果。
3. **状态转移方程**：使用状态转移方程来求解最大子段和，确保每次计算都是基于前一次的结果，避免重复计算。

### 拓展思路与类似题目

1. **类似题目**：
   - [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
   - [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
   - [P2042 维护数列](https://www.luogu.com.cn/problem/P2042)

2. **拓展思路**：
   - 可以将类似的思路应用到其他需要求解多个子段和的问题中，如求解三个或更多不相交子段的最大和。
   - 通过预处理和状态转移方程，可以优化其他类型的DP问题，如最长上升子序列、背包问题等。

### 个人心得总结

- **调试经历**：在处理边界条件时，特别是当序列全为负数时，需要特别注意初始化值的设置，避免出现错误结果。
- **踩坑教训**：在枚举中间点时，确保前后两部分的最大子段和计算正确，避免重复计算或遗漏某些情况。
- **顿悟感想**：通过预处理和状态转移方程，可以将复杂问题分解为简单的子问题，从而大大降低问题的复杂度。

---
处理用时：44.65秒
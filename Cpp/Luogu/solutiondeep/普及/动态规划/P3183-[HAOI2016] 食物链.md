# 题目信息

# [HAOI2016] 食物链

## 题目描述

 ![](https://cdn.luogu.com.cn/upload/pic/13153.png) 

如图所示为某生态系统的食物网示意图，据图回答第 1 小题  
现在给你 $n$ 个物种和 $m$ 条能量流动关系，求其中的食物链条数。物种的名称为从 $1$ 到 $n$ 编号 $M$ 条能量流动关系形如 $a_1,b_1,a_2,b_2,a_3,b_3,\ldots,a_{m-1},b_{m-1},a_m,b_m$。其中 $a_i$ 和 $b_i$ 表示能量从物种 $a_i$ 流向物种 $b_i$，注意单独的一种孤立生物不算一条食物链。


## 说明/提示

数据保证输入数据符合生物学特点，且不会有重复的能量流动关系出现，题目保证答案不会爆 `int`。

对于 $100 \%$ 的数据，$1 \leq N \leq 100000$，$0 \leq m \leq 200000$。

## 样例 #1

### 输入

```
10 16
1 2
1 4
1 10
2 3
2 5
4 3
4 5
4 8
6 5
7 6
7 9
8 5
9 8
10 6
10 7
10 9```

### 输出

```
9```

# AI分析结果

### 综合分析与结论

题目要求计算食物网中的食物链条数，本质上是求有向无环图（DAG）中从入度为0的点到出度为0的点的路径数。题解中主要采用了两种思路：**拓扑排序+动态规划**和**记忆化搜索**。拓扑排序的思路是通过遍历图的拓扑序，逐步累加每个点的路径数；记忆化搜索则是通过DFS遍历图，并利用记忆化避免重复计算。

#### 关键思路与技巧：
1. **拓扑排序+动态规划**：通过拓扑排序确定遍历顺序，动态规划累加路径数。适用于需要按顺序处理节点的场景。
2. **记忆化搜索**：通过DFS遍历图，利用记忆化避免重复计算。适用于需要深度优先遍历的场景。
3. **入度与出度的处理**：通过记录每个节点的入度和出度，判断是否为食物链的起点或终点。
4. **孤立点的处理**：题目要求孤立点不算食物链，需在算法中特判。

#### 可拓展之处：
- **类似题目**：可以扩展到其他需要计算路径数的DAG问题，如计算最短路径、最长路径等。
- **优化思路**：对于大规模图，可以考虑使用更高效的数据结构（如链式前向星）来存储图，减少空间和时间复杂度。

### 所选高星题解

#### 题解1：作者：_蒟蒻__ (赞：99)
- **星级**：★★★★★
- **关键亮点**：使用拓扑排序+动态规划，代码简洁清晰，逻辑严谨，处理了孤立点的情况。
- **个人心得**：作者提到“生命苦短，直接上代码”，体现了代码实现的简洁性和高效性。

```cpp
int JI_DE_DIAN_GE_ZAN() {
    queue<int> q;
    int ans = 0;
    for (int i = 1; i <= n; i++)
        if (!rd[i] && e[i].size()) // 单个点不算方案
            q.push(i), f[i] = 1;
    
    while (!q.empty()) {
        int x = q.front(); q.pop();
        if (!e[x].size()) ans += f[x];
        for (auto t : e[x]) {
            f[t] += f[x], rd[t]--; // f来统计方案
            if (!rd[t]) q.push(t);
        }
    }
    return ans;
}
```

#### 题解2：作者：远航之曲 (赞：82)
- **星级**：★★★★☆
- **关键亮点**：使用记忆化搜索，代码简洁，处理了孤立点的情况，通过记忆化优化了DFS的效率。
- **个人心得**：作者提到“记忆化真是神奇的东西，加了两句瞬间T->A”，体现了记忆化搜索的强大优化效果。

```cpp
int dfs(int x) {
    if (f[x]) return f[x];
    int ans = 0;
    if (out[x] == 0) return 1;
    for (int i = st[x]; i; i = e[i].next)
        ans += dfs(e[i].w);
    f[x] = ans;
    return ans;
}
```

#### 题解3：作者：zcysky (赞：56)
- **星级**：★★★★☆
- **关键亮点**：使用记忆化搜索，代码简洁，处理了孤立点的情况，通过记忆化优化了DFS的效率。
- **个人心得**：作者提到“省选竟然还有这种naive的题”，体现了对题目难度的轻松应对。

```cpp
ll dfs(int u) {
    if (dp[u]) return dp[u];
    ll ans = 0;
    if (!out[u] && in[u]) ++ans;
    for (int i = head[u]; i; i = G[i].next) {
        int v = G[i].v; ans += dfs(v);
    }
    dp[u] = ans; return ans;
}
```

### 推荐相似题目
1. [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)
2. [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)
3. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

这些题目都涉及到有向无环图的遍历和路径计数，适合巩固拓扑排序和记忆化搜索的知识。

---
处理用时：28.28秒
# 题目信息

# [JLOI2012] 树

## 题目描述

在这个问题中，给定一个值 $s$ 和一棵树。在树的每个节点有一个权值，第 $i$ 个点的权值为 $a_i$，问有多少条路径的节点权值总和为 $s$。路径中节点的深度必须是升序的。假设节点 $1$ 是根节点，根的深度是 $0$，它的儿子节点的深度为 $1$。路径不必一定从根节点开始。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq a_i, s \leq 10^3$。

## 样例 #1

### 输入

```
3 3
1 2 3
1 2
1 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题要求统计树中权值和为 `s` 的路径数量，且路径的节点深度必须递增。题解中主要采用了以下几种思路：

1. **暴力DFS**：从每个节点出发，向下搜索路径，剪枝优化。虽然思路简单，但时间复杂度较高，适合小规模数据。
2. **树上前缀和**：利用前缀和和哈希表（如 `set`）快速查找符合条件的路径，时间复杂度较低。
3. **倍增法**：通过预处理每个节点向上跳 `2^k` 步的路径和，利用二分思想快速查找符合条件的路径，时间复杂度为 `O(n log n)`。
4. **双端队列**：通过维护一个双端队列，动态调整路径和，时间复杂度较低。

总体来看，**树上前缀和**和**倍增法**是较为高效的解法，适合大规模数据。暴力DFS虽然简单，但时间复杂度较高，适合小规模数据或作为初步思路。

### 所选高分题解

#### 1. 作者：zht467 (4星)
- **关键亮点**：使用树上前缀和和 `set` 数据结构，快速查找符合条件的路径，时间复杂度较低。
- **核心代码**：
  ```cpp
  void dfs(int u) {
      sum[u] = sum[f[u]] + a[u];
      S.insert(sum[u]);
      if(S.count(sum[u] - s)) ans++;
      for(int i = head[u]; i ^ -1; i = next[i]) dfs(to[i]);    
      S.erase(sum[u]);
  }
  ```
  **实现思想**：通过 `set` 记录前缀和，查找 `sum[u] - s` 是否存在，若存在则路径数加一。

#### 2. 作者：Sky_crystal (4星)
- **关键亮点**：使用倍增法预处理每个节点向上跳 `2^k` 步的路径和，利用二分思想快速查找符合条件的路径，时间复杂度为 `O(n log n)`。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      x = 0; y = i;
      for (int j = 17; j >= 0; j--) {
          if (len[y][j] + x <= s) {
              x += len[y][j];
              y = fa[y][j];
          }
          if (x == s) {
              ans++;
              break;
          }
      }
  }
  ```
  **实现思想**：通过预处理每个节点向上跳 `2^k` 步的路径和，利用二分思想快速查找符合条件的路径。

#### 3. 作者：kkxhh (4星)
- **关键亮点**：使用双端队列动态调整路径和，时间复杂度较低。
- **核心代码**：
  ```cpp
  void dfs(int x) {
      q[++r] = v[x]; qsum += v[x];
      while(qsum > s) qsum -= q[l++];
      if(qsum == s) ans++;
      for(int j = 0; j < (int)son[x].size(); j++) dfs(son[x][j]);
      qsum -= q[r--];
      while(l && qsum + q[l - 1] <= s) qsum += q[--l];
  }
  ```
  **实现思想**：通过双端队列动态调整路径和，确保路径和不超过 `s`，若等于 `s` 则路径数加一。

### 最优关键思路与技巧

1. **树上前缀和**：通过记录每个节点的前缀和，利用哈希表快速查找符合条件的路径，时间复杂度较低。
2. **倍增法**：通过预处理每个节点向上跳 `2^k` 步的路径和，利用二分思想快速查找符合条件的路径，时间复杂度为 `O(n log n)`。
3. **双端队列**：通过维护一个双端队列，动态调整路径和，确保路径和不超过 `s`，若等于 `s` 则路径数加一。

### 可拓展之处

1. **树链剖分**：可以将树剖分成若干条链，利用线段树或树状数组维护路径和，进一步优化时间复杂度。
2. **动态规划**：可以设计状态转移方程，利用动态规划的思想统计符合条件的路径数。

### 推荐相似题目

1. **P3384 【模板】轻重链剖分**：考察树链剖分的应用。
2. **P3379 【模板】最近公共祖先（LCA）**：考察LCA的求解方法。
3. **P2634 【国家集训队】聪聪可可**：考察树上路径统计问题。

### 个人心得摘录

- **作者：enceladus**：提到暴力DFS虽然简单，但时间复杂度较高，适合小规模数据。
- **作者：zht467**：使用 `set` 记录前缀和，快速查找符合条件的路径，时间复杂度较低。
- **作者：Sky_crystal**：倍增法预处理每个节点向上跳 `2^k` 步的路径和，利用二分思想快速查找符合条件的路径。

这些心得体现了不同解法的优缺点，帮助理解如何根据数据规模选择合适的算法。

---
处理用时：37.98秒
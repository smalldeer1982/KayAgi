# 题目信息

# [TJOI2007] 线段

## 题目描述

在一个 $n \times n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是$(i, L_{i})$，右端点是$(i, R_{i})$。

你从 $(1,1)$ 点出发，要求沿途走过所有的线段，最终到达 $(n,n)$ 点，且所走的路程长度要尽量短。

更具体一些说，你在任何时候只能选择向下走一步（行数增加 $1$）、向左走一步（列数减少 $1$）或是向右走一步（列数增加 $1$）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。

## 说明/提示

我们选择的路线是

```
 (1, 1) (1, 6)
 (2, 6) (2, 3)
 (3, 3) (3, 1)
 (4, 1) (4, 2)
 (5, 2) (5, 6)
 (6, 6) (6, 4) (6, 6)
```
不难计算得到，路程的总长度是 $24$。 

对于 $100\%$ 的数据中，$n \le 2 \times 10^4$，$1 \le L_i \le R_i \le n$。

## 样例 #1

### 输入

```
6
2 6
3 4
1 3
1 2
3 6
4 5```

### 输出

```
24```

# AI分析结果

### 综合分析与结论

该题目要求从 $(1,1)$ 出发，遍历每一行的线段并最终到达 $(n,n)$，且路径长度最短。大多数题解采用了动态规划（DP）的思路，通过定义状态 $f[i][0/1]$ 表示在第 $i$ 行结束时位于左端点或右端点的最短路径，并通过状态转移方程进行求解。部分题解还使用了滚动数组优化空间复杂度。

### 所选高星题解

#### 1. 作者：Huami360 (★★★★★)
**关键亮点**：
- 思路清晰，状态定义简洁明了，直接使用 $f[i][0/1]$ 表示在第 $i$ 行结束时位于左端点或右端点的最短路径。
- 代码简洁，转移方程直接，易于理解。
- 时间复杂度为 $O(n)$，空间复杂度为 $O(n)$，未使用滚动数组但代码依然高效。

**核心代码**：
```cpp
f[1][0] = r[1] + r[1] - l[1] - 1;
f[1][1] = r[1] - 1;
for (int i = 2; i <= n; i++) {
    f[i][0] = min(f[i-1][0] + abs(l[i-1] - r[i]) + r[i] - l[i] + 1, f[i-1][1] + abs(r[i-1] - r[i]) + r[i] - l[i] + 1);
    f[i][1] = min(f[i-1][0] + abs(l[i-1] - l[i]) + r[i] - l[i] + 1, f[i-1][1] + abs(r[i-1] - l[i]) + r[i] - l[i] + 1);
}
printf("%d\n", min(f[n][0] + n - l[n], f[n][1] + n - r[n]));
```

#### 2. 作者：pzc2004 (★★★★☆)
**关键亮点**：
- 状态转移方程详细推导，解释了每一步的合理性。
- 使用了滚动数组优化空间复杂度，代码实现较为高效。
- 代码可读性较好，注释清晰。

**核心代码**：
```cpp
f[1][0] = dis(a[1][1],1) + dis(a[1][1],a[1][0]);
f[1][1] = dis(a[1][1],1);
for (int i = 2; i <= n; i++) {
    f[i][0] = min(f[i-1][0] + dis(a[i-1][0],a[i][1]) + dis(a[i][1],a[i][0]), f[i-1][1] + dis(a[i-1][1],a[i][1]) + dis(a[i][1],a[i][0])) + 1;
    f[i][1] = min(f[i-1][0] + dis(a[i-1][0],a[i][0]) + dis(a[i][0],a[i][1]), f[i-1][1] + dis(a[i-1][1],a[i][0]) + dis(a[i][0],a[i][1])) + 1;
}
printf("%d", min(f[n][0] + dis(a[n][0],n), f[n][1] + dis(a[n][1],n)));
```

#### 3. 作者：ShineEternal (★★★★☆)
**关键亮点**：
- 状态转移方程推导详细，解释了四种转移情况。
- 代码简洁，注释清晰，易于理解。
- 未使用滚动数组，但代码依然高效。

**核心代码**：
```cpp
f[1][0] = L[1]-1+(R[1]-L[1])*2;
f[1][1] = R[1]-1; 
for (int i = 2; i <= n; i++) {
    f[i][0] = min(f[i-1][1] + abs(R[i-1]-R[i]), f[i-1][0] + abs(L[i-1]-R[i])) + R[i]-L[i]+1;
    f[i][1] = min(f[i-1][1] + abs(R[i-1]-L[i]), f[i-1][0] + abs(L[i]-L[i-1])) + R[i]-L[i]+1;
}
printf("%d\n", min(f[n][0] + n - L[n], f[n][1] + n - R[n]));
```

### 最优关键思路与技巧
1. **状态定义**：使用 $f[i][0/1]$ 表示在第 $i$ 行结束时位于左端点或右端点的最短路径。
2. **状态转移**：通过上一行的左右端点状态转移到当前行的左右端点，计算最小路径。
3. **滚动数组优化**：部分题解使用滚动数组优化空间复杂度，适用于大规模数据。

### 拓展与举一反三
- **类似题目**：可以尝试解决其他需要遍历特定路径的题目，如 [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)、[P1006 传纸条](https://www.luogu.com.cn/problem/P1006)、[P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)。

### 个人心得摘录
- **调试经历**：部分作者提到在调试过程中发现状态转移方程的细节错误，如忘记加1（向下移动的步数）。
- **顿悟感想**：通过画图帮助理解状态转移的合理性，尤其是从上一行的左右端点转移到当前行的左右端点的路径选择。

### 推荐题目
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)
3. [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)

---
处理用时：38.00秒
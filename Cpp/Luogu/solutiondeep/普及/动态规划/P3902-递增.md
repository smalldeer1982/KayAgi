# 题目信息

# 递增

## 题目描述

现有数 $A_1,A_2,\cdots,A_n$，修改最少的数字为**实数**，使得数列严格单调递增。

注：原题误表述为修改为整数，现已纠正为实数。本题数据确保按照修改为整数的做法也可以 AC（只是不能过样例）

## 说明/提示

• 对于50% 的数据，$N \le 10^3$

• 对于100% 的数据，$1 \le N \le 10^5 , 1 \le A_i \le 10^9$


## 样例 #1

### 输入

```
3
1 3 2```

### 输出

```
1```

## 样例 #2

### 输入

```
8
1 2 3 4 4 5 6 7```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心问题是通过修改最少的数字，使得数列严格单调递增。大多数题解都基于最长上升子序列（LIS）的思路，通过计算LIS的长度，然后用总长度减去LIS的长度得到需要修改的数字数量。LIS的求解方法有多种，包括暴力DP、二分优化、树状数组等。其中，二分优化和树状数组的方法在时间复杂度上更优，适合处理大规模数据。

### 所选高星题解

#### 1. 作者：The_Key (赞：71)  
**星级：4.5**  
**关键亮点：**  
- 使用STL中的`lower_bound`函数进行二分查找，优化了LIS的求解过程。
- 代码简洁，思路清晰，适合初学者理解。
- 通过边输入边判断的方式，减少了不必要的存储和计算。

**核心代码：**
```cpp
for(long long i=1;i<=n;i++) {
    cin>>num;
    if(num>f[now]) f[++now]=num;
    else {
        *lower_bound(f+1,f+now+1,num)=num;
        sum++;
    }
}
```
**实现思想：**  
通过`lower_bound`找到第一个不小于当前数的位置，将其替换为当前数，从而维护一个有序的LIS数组。

#### 2. 作者：一ZCH一 (赞：29)  
**星级：4.0**  
**关键亮点：**  
- 提供了多种LIS求解方法，包括暴力DP和二分优化。
- 详细解释了二分优化的思路，适合进阶学习。
- 代码结构清晰，注释详细。

**核心代码：**
```cpp
for(int i=1;i<=n;i++) {
    if(a[i]>dp[ans]) dp[++ans]=a[i];
    else {
        int l=1,r=ans,mid;
        while(l<r) {
            mid=(l+r)/2;
            if(a[i]<=dp[mid]) r=mid;
            else l=mid+1;
        }
        dp[l]=a[i];
    }
}
```
**实现思想：**  
通过二分查找找到第一个大于当前数的位置，将其替换为当前数，从而维护一个有序的LIS数组。

#### 3. 作者：fls233666 (赞：24)  
**星级：4.0**  
**关键亮点：**  
- 详细解释了LIS的求解思路，并提供了暴力DP和二分优化的代码。
- 通过二分查找优化了时间复杂度，适合处理大规模数据。
- 代码结构清晰，注释详细。

**核心代码：**
```cpp
for(int i=1;i<=n;i++) {
    if(a[i]>sa[ans]) sa[++ans]=a[i];
    else {
        int tz=lower_bound(sa,sa+ans,a[i])-sa;
        sa[tz]=a[i];
    }
}
```
**实现思想：**  
通过`lower_bound`找到第一个不小于当前数的位置，将其替换为当前数，从而维护一个有序的LIS数组。

### 最优关键思路与技巧

1. **二分查找优化LIS**：通过二分查找维护一个有序的LIS数组，将时间复杂度从O(n^2)优化到O(n log n)。
2. **STL函数的使用**：`lower_bound`函数可以快速找到第一个不小于当前数的位置，简化了代码实现。
3. **逆向思维**：通过计算LIS的长度，用总长度减去LIS的长度得到需要修改的数字数量。

### 可拓展之处

1. **类似问题**：如果题目要求修改为整数而非实数，可以通过预处理将序列转换为非严格递增序列，再求LIS。
2. **其他优化方法**：树状数组也可以用于优化LIS的求解，适合处理更复杂的数据结构。

### 推荐题目

1. **P1020 导弹拦截**（考察LIS和LDS）
2. **P1091 合唱队形**（考察双向LIS）
3. **P1439 最长公共子序列**（考察LIS的应用）

### 个人心得总结

- **调试经历**：在实现二分查找时，注意边界条件的处理，避免出现死循环或越界错误。
- **踩坑教训**：在使用`lower_bound`时，确保数组是有序的，否则结果可能不正确。
- **顿悟感想**：通过二分查找优化LIS的求解，不仅提高了效率，也加深了对算法优化的理解。

---
处理用时：27.94秒
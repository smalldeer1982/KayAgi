# 题目信息

# 最大食物链计数

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。


## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。


## 说明/提示

各测试点满足以下约定：

 ![](https://cdn.luogu.com.cn/upload/pic/12011.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4```

### 输出

```
5```

# AI分析结果

### 综合分析

这些题解主要围绕“最大食物链计数”问题展开，核心思路是通过拓扑排序或记忆化搜索来统计从生产者（入度为0的点）到最高级消费者（出度为0的点）的路径数量。拓扑排序的优势在于其时间复杂度为O(n+m)，适合处理大规模数据，而记忆化搜索则通过记录中间结果来避免重复计算，适合处理复杂的图结构。

### 最优关键思路与技巧

1. **拓扑排序**：通过维护入度数组，逐步移除入度为0的节点，并更新其邻接节点的路径计数。这种方法确保每个节点只被处理一次，适合处理DAG（有向无环图）。
2. **记忆化搜索**：通过记录每个节点的路径数量，避免重复计算，适合处理复杂的图结构。
3. **状态转移方程**：在拓扑排序中，使用状态转移方程`f[v] += f[u]`来更新每个节点的路径计数。

### 可拓展之处

1. **类似算法套路**：拓扑排序和记忆化搜索可以应用于其他图论问题，如最短路径、关键路径等。
2. **同类型题**：可以尝试解决其他图论问题，如P4017（最大食物链计数）、P3183（食物链）等。

### 推荐题目

1. P4017 最大食物链计数
2. P3183 食物链
3. P3388 拓扑排序

### 题解评分与亮点

#### 1. 御·Dragon (5星)
- **关键亮点**：详细解释了拓扑排序的思路，并通过图示和代码展示了如何逐步更新路径计数。代码清晰，注释详细，适合初学者理解。
- **个人心得**：作者通过多次更新题解，优化了排版和解释，帮助更多初学者理解拓扑排序的应用。

```cpp
while(!q.empty()) {
    int tot = q.front(); q.pop();
    for(int i = 0; i < nei[tot].size(); i++) {
        int next = nei[tot][i];
        num[next] = (num[next] + num[tot]) % mod;
        if(--in[next] == 0) q.push(next);
    }
}
```

#### 2. Watcher (4.5星)
- **关键亮点**：通过拓扑排序的思路，详细解释了如何通过入度和出度来统计路径数量。代码简洁，适合有一定基础的读者。
- **个人心得**：作者通过多次更新题解，优化了代码风格和注释，提高了代码的可读性。

```cpp
while(!q.empty()) {
    int a = q.front(); q.pop();
    for(int k = 1; k <= n; k++) {
        if(mp[a][k] == 0) continue;
        f[k] += f[a]; f[k] %= 80112002;
        ru[k]--;
        if(ru[k] == 0) q.push(k);
    }
}
```

#### 3. Dog_Two (4星)
- **关键亮点**：通过记忆化搜索的思路，详细解释了如何通过记录中间结果来避免重复计算。代码简洁，适合处理复杂的图结构。
- **个人心得**：作者通过记忆化搜索的思路，优化了代码的时间复杂度，适合处理大规模数据。

```cpp
int dfs(int t) {
    if(!u[t]) return 1;
    if(cun[t]) return cun[t];
    for(int i = cun2[t]; i; i = mp[i].next) {
        (num += dfs(mp[i].x)) %= mod;
    }
    return cun[t] = num;
}
```

### 总结

拓扑排序和记忆化搜索是解决此类图论问题的有效方法，通过逐步更新路径计数或记录中间结果，可以高效地统计路径数量。对于初学者，建议从拓扑排序入手，逐步理解图论中的基本算法和数据结构。

---
处理用时：28.66秒
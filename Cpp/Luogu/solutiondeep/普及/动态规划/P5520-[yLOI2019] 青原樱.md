# 题目信息

# [yLOI2019] 青原樱

## 题目背景

> 星川之下皆萤火尘埃，  
> 我独行在人潮你天真而待。  
> 相遇若是借丹青着色，  
> 青原上 绯樱如海。

——银临《青原樱》(Cover 人衣大人)

## 题目描述

扶苏是一个非常喜欢边听古风鸽边写数学题的人，因此这道题其实是个五三原题。

扶苏希望重现青原上樱花盛开的景色，于是他准备了很多**互不相同**樱花树幼苗，准备种成一行。

这一行中，一共有 $n$ 个位置可以种下樱花，而扶苏准备了 $m$ 支幼苗。由于樱花盛放时对左右空间需求非常大，所以樱花不能紧挨着种植，也就是任意两支幼苗之间必须至少存在一个不种花的空位置。

按照这种方式种花并不难，但是令扶苏感到好奇的是一共有多少合法的方案让他把这 $m$ 支幼苗都种下去。一个方案是合法的当且仅当他满足上一段中叙述的要求。如果我们将花按照 $1,2,3,\dots,m$ 编号，两种方案不同当且仅当被选择种花的位置不同或从左向右数花的编号序列不同。

为了避免输出过大，答案对一个参数 $p$ 取模。

## 说明/提示

#### 样例输入输出 1 解释
一共有 $2$ 个樱花幼苗， $3$ 个种花的位置，如果给幼苗编号为 $1,~2$，位置编号为 $1,~2,~3$，那么两种方案分别如下：

| 位置 | $1$ | $2$ | $3$ |
| :---: | :---: | :---: | :---: |
| 方案 1 | 幼苗 $1$ | 空 | 幼苗 $2$ |
| 方案 2 | 幼苗 $2$ | 空 | 幼苗 $1$ |

---

#### 数据规模与约定

**本题采用多测试点捆绑测试，共有 6 个子任务**。

| 子任务编号 | $n \leq$ | $m \leq$ | $type=$ | 特殊性质 | 子任务分值 |
| :----------: | :--------: | :----------: | :-------: | :--------: | :-----------: |
| 1 | $1$ | $1$ | $0$ | 特殊性质 1 | $5$ |
| 2 | $20$ | $20$ | $1$ | 特殊性质 1 | $15$ |
| 3 | $400$ | $200$ | $2$ | 无 | $20$ |
| 4 | $2000$ | $2000$ | $3$ | 无 | $20$ |
| 5 | $2000000$ | $1000000$ | $4$| 特殊性质 2 | $20$ | 
| 6 | $2000000$ | $1000000$ | $5$| 无 | $20$ | 

特殊性质 1：保证对应测试点的**实际**方案数(在取模前)不超过 $10^6$

特殊性质 2：保证 $p$ 是一个质数。

对于 $100\%$ 的数据，保证：
- $1 \leq n \leq 2 \times 10^6$。
- $1 \leq m \leq 10^6 $。
- $1 \leq p \leq 10^9$。
- $1 \leq m \leq \lceil\frac{n}{2} \rceil$。

---

#### 提示

- 请使用合适的数据类型来进行运算，避免溢出。
- 参数 $type$ 可以帮助你快速的判断子任务编号。


## 样例 #1

### 输入

```
1 3 2 19260718```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是计算在n个位置中放置m个互不相同的樱花树幼苗，且任意两棵树之间至少有一个空位的方案数。题解中大部分作者都采用了排列组合的思路，通过将问题转化为插空法或组合数学问题，最终得出方案数为$A_{n-m+1}^{m}$。部分题解还进一步优化了计算过程，避免了复杂的组合数计算，直接通过累乘得到结果。

### 所选高星题解

#### 1. 作者：yyh_1102 (5星)
- **关键亮点**：详细解释了排列组合的基本概念，并通过多个例题帮助理解插空法的应用。题解不仅解决了本题，还扩展了排列组合的其他常见问题，适合初学者。
- **个人心得**：作者通过多个例题逐步引导读者理解排列组合的核心思想，强调“正难则反”的思维方式，帮助读者在面对复杂问题时找到突破口。

#### 2. 作者：一扶苏一 (4星)
- **关键亮点**：通过分类讨论（最后一个位置是否放树）将问题分解为两个子问题，分别计算方案数后相加。题解思路清晰，代码简洁，适合有一定基础的读者。
- **代码实现**：
  ```cpp
  #include <stdio.h>
  int main() {
    int I, love, yin, lin;
    scanf("%d%d%d%d", &I, &love, &yin, &lin);
    love = love - yin + 1; 
    int ans = 1;
    for (int i = love - yin + 1; i <= love; ++i) {
      ans = 1ll * ans * i % lin;
    }
    printf("%d\n", ans);
    return 0;
  }
  ```
  **核心思想**：通过累乘计算$A_{n-m+1}^{m}$，并在每一步取模以避免溢出。

#### 3. 作者：ez_lcw (4星)
- **关键亮点**：直接通过插空法得出方案数为$A_{n-m+1}^{m}$，并提供了简洁的代码实现。题解思路清晰，代码可读性强，适合快速理解问题并实现。
- **代码实现**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  ll ans=1,type,n,m,p;
  int main() {
    scanf("%lld%lld%lld%lld",&type,&n,&m,&p);
    for(int i=n-m+1;i>=n-2*m+2;i--)
      ans=(ans*i)%p;
    printf("%lld\n",ans);
    return 0;
  }
  ```
  **核心思想**：通过累乘计算$A_{n-m+1}^{m}$，并在每一步取模以避免溢出。

### 最优关键思路与技巧
- **插空法**：通过预先留出m-1个空位，将问题转化为在n-m+1个位置中放置m个树的排列问题。
- **分类讨论**：通过讨论最后一个位置是否放树，将问题分解为两个子问题，分别计算方案数后相加。
- **累乘计算**：直接通过累乘计算排列数，避免了复杂的组合数计算，代码简洁且高效。

### 可拓展之处
- **类似问题**：类似的不相邻排列问题在组合数学中非常常见，如“在n个位置中放置m个不相邻的物品”或“在n个位置中放置m个物品，且每两个物品之间至少间隔k个位置”。
- **优化技巧**：在处理大数取模时，可以通过累乘并在每一步取模来避免溢出，同时保持计算的高效性。

### 推荐题目
1. [P2822 组合数问题](https://www.luogu.com.cn/problem/P2822)
2. [P3197 [HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197)
3. [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)

### 个人心得总结
- **调试经历**：部分作者在调试过程中发现直接计算组合数会导致溢出，因此采用了累乘并在每一步取模的策略，避免了这一问题。
- **顿悟感想**：通过分类讨论和插空法，可以将复杂的不相邻排列问题转化为简单的排列组合问题，大大简化了计算过程。

---
处理用时：28.64秒
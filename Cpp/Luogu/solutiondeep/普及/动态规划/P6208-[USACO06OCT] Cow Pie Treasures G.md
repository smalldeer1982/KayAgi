# 题目信息

# [USACO06OCT] Cow Pie Treasures G

## 题目描述

奶牛们制作了一些藏有金币的馅饼，并把它们排成了一个 $r$ 行 $c$ 列的矩阵。现在，你需要从坐标为 $(1,1)$ 的馅饼旁移动到坐标为 $(r,c)$ 的馅饼旁。对于每次移动，你必须向右移动一列，并且行数的变动不能超过 $1$。即如果你处于坐标为 $(x,y)$ 的馅饼旁，你只能移动到坐标为 $(x-1,y+1)$，$(x,y+1)$ 或 $(x+1,y+1)$ 的馅饼旁。在一个馅饼旁停留时，你可以拿走其中所有的金币。当然，你一定不愿意中途离开矩阵而放弃这些金币。

奶牛们把标有矩阵中每一块馅饼所藏金币数的表格交给了你。你想知道按照以上规则，自己最多能拿到多少金币。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le r,c\le 100$，$1\le t\le 25$。

------------

**【样例说明】**

![](https://cdn.luogu.com.cn/upload/image_hosting/pgw19uqm.png)

样例给出的矩阵如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/hwhzq9oy.png)

这是一种合法的移动方式。你可以拿到 $47$ 枚金币。

![](https://cdn.luogu.com.cn/upload/image_hosting/sdyxlpv5.png)

在这个矩阵中你最多能拿到 $50$ 枚金币，路线如图所示。

## 样例 #1

### 输入

```
3 7
6 5 3 7 9 2 7
2 4 3 5 6 8 6
4 9 9 9 1 5 8```

### 输出

```
50```

# AI分析结果

### 综合分析与结论

本题是一道典型的动态规划问题，核心在于如何通过状态转移方程求解从起点到终点的最大金币数。各题解基本都采用了动态规划的思路，但在实现细节、边界处理和优化上有不同的表现。以下是对各题解的简要分析与评分：

1. **WaltVBAlston** 的题解通过调整循环边界条件，避免了无效状态的计算，代码简洁且思路清晰。评分：4星。
2. **do_while_false** 的题解同样采用了动态规划，但未明确提到边界条件的优化，代码结构较为常规。评分：3星。
3. **DreamFox** 的题解使用了记忆化搜索（DFS+剪枝），虽然思路新颖，但复杂度较高，且代码可读性一般。评分：3星。
4. **monstersqwq** 的题解详细解释了动态规划的思路，并优化了边界条件，代码清晰且逻辑严谨。评分：4星。
5. **LongDouble** 的题解强调了初始化的重要性，并通过调整循环顺序和边界条件优化了代码，思路清晰且代码简洁。评分：4星。

### 所选高星题解

#### 1. **WaltVBAlston** (4星)
**关键亮点**：通过调整循环边界条件 `j<=i&&j<=n`，避免了无效状态的计算，代码简洁且思路清晰。
**个人心得**：作者提到如果不调整边界条件会导致WA，强调了边界处理的重要性。
**核心代码**：
```cpp
for(int i=1;i<=m;i++) {
    for(int j=1;j<=n&&j<=i;j++) {
        dp[j][i]=max(dp[j-1][i-1],max(dp[j+1][i-1],dp[j][i-1]))+a[j][i];
    }
}
```

#### 2. **monstersqwq** (4星)
**关键亮点**：详细解释了动态规划的思路，并优化了边界条件，代码清晰且逻辑严谨。
**核心代码**：
```cpp
for(int j=2;j<=c;j++) {
    for(int i=1;i<=j&&i<=r;i++) {
        dp[i][j]=max(dp[i-1][j-1],max(dp[i][j-1],dp[i+1][j-1]))+a[i][j];
    }
}
```

#### 3. **LongDouble** (4星)
**关键亮点**：强调了初始化的重要性，并通过调整循环顺序和边界条件优化了代码，思路清晰且代码简洁。
**个人心得**：作者提到初始化问题导致调试时间较长，强调了初始化的关键性。
**核心代码**：
```cpp
memset(dp, -0x3f, sizeof dp);
dp[1][1] = t[1][1];
for(int j=2;j<=c;j++) {
    for(int i=1;i<=r;i++) {
        dp[i][j] = t[i][j] + max(dp[i-1][j-1], max(dp[i][j-1], dp[i+1][j-1]));
    }
}
```

### 最优关键思路与技巧

1. **边界条件优化**：通过限制行的循环条件 `i<=j`，避免计算无效状态，减少不必要的计算。
2. **初始化重要性**：将DP数组初始化为极小值，防止未计算的状态影响结果。
3. **循环顺序**：先枚举列再枚举行，确保在计算当前状态时，依赖的前一状态已经计算完毕。

### 可拓展之处

1. **类似问题**：类似的问题包括矩阵中的路径最大和问题、网格中的最短路径问题等，都可以通过动态规划或记忆化搜索解决。
2. **算法套路**：动态规划中的状态转移方程设计和边界条件处理是解决此类问题的关键，掌握这些技巧可以举一反三。

### 推荐题目

1. **P1219 [USACO1.5]八皇后 Checker Challenge** (动态规划与回溯结合)
2. **P1434 [SHOI2002]滑雪** (记忆化搜索)
3. **P1002 [NOIP2002 普及组] 过河卒** (动态规划与边界处理)

### 个人心得总结

- **边界处理**：在动态规划中，边界条件的处理往往决定了代码的正确性，需要特别注意。
- **初始化**：初始化DP数组为极小值可以防止未计算的状态影响结果，避免调试时的困扰。
- **循环顺序**：先枚举列再枚举行，确保依赖的状态已经计算完毕，避免逻辑错误。

---
处理用时：30.47秒
# 题目信息

# [NOI Online #3 入门组] 买表

## 题目描述

Jimmy 到 Symbol 的手表店买手表，Jimmy 只带了 $n$ 种钱币，第 $i$ 种钱币的面额为 $k_i$ 元，张数为 $a_i$ 张。Symbol 的店里一共有 $m$ 块手表，第 $i$ 块手表的价格为 $t_i$ 元。

Symbol 的手表店不能找零，所以 Jimmy 只能在凑出恰好的钱数时才能购买一块手表。现在对于店里的每块手表，Jimmy 想知道他能不能凑出恰好的钱数进行购买。


## 说明/提示

#### 样例 1 解释

- 第二块手表 $19=6 \times 3+1=6 \times 2+5+1 \times 2$，可以恰好凑出。
- 第四块手表 $1=1 \times 1$，可以恰好凑出。
- 第五块手表 $7=5+2\times 1=6 \times 1+1$，可以恰好凑出。

#### 数据规模与约定
- 对于 $50\%$ 的数据，保证 $n\leq 10$，$m \leq 60$，$a_i \leq 20$，$k_i \leq 5000$，$t_i \leq 250$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq m \leq 10^5$，$1 \leq a_i \leq 1000$，$1 \leq k_i \leq 500000$，$0 \leq t_i \leq 500000$。

#### 说明

data provider：@皎月半洒花。

## 样例 #1

### 输入

```
3 5
1 2
5 1
6 3
3 19 21 1 7```

### 输出

```
No
Yes
No
Yes
Yes
```

# AI分析结果

### 综合分析与结论

本题是一个典型的多重背包问题，核心在于如何高效地判断给定的金额是否可以通过给定的货币组合恰好凑出。题解中主要采用了以下几种思路：

1. **二进制优化**：通过将多重背包问题转化为01背包问题，减少物品数量，从而降低时间复杂度。
2. **bitset优化**：利用bitset的位运算特性，进一步优化空间和时间复杂度。
3. **贪心思想**：通过贪心策略，减少不必要的状态转移，优化算法效率。

### 所选高星题解

#### 1. 作者：critnos (赞：40)  
**星级：5星**  
**关键亮点**：  
- 使用了二进制优化和bitset优化，极大地减少了时间和空间复杂度。
- 代码简洁，逻辑清晰，通过位运算大幅提升了效率。
- 提供了详细的优化思路和实现细节，适合进阶学习。

**核心代码**：
```cpp
bitset<500005> dp;
dp[0] = 1;
for (int i = 0; i < n; i++) {
    int k, a;
    scanf("%d%d", &k, &a);
    for (int l = 1; a >= l; l *= 2) {
        dp |= dp << (l * k);
        a -= l;
    }
    if (a * k) dp |= dp << (a * k);
}
```
**实现思想**：通过二进制拆分将多重背包问题转化为01背包问题，利用bitset的位运算特性进行优化。

#### 2. 作者：翼德天尊 (赞：28)  
**星级：4星**  
**关键亮点**：  
- 详细分析了多重背包问题的解法，并提供了多种优化思路。
- 通过减少循环次数和优化状态转移，提升了算法效率。
- 代码结构清晰，适合初学者理解。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    memset(dp, 0, sizeof(dp));
    for (int j = k[i]; j <= maxn; j++) {
        if (can[j] == 0 && can[j - k[i]] == 1 && dp[j - k[i]] < a[i]) {
            can[j] = 1, dp[j] = dp[j - k[i]] + 1;
        }
    }
}
```
**实现思想**：通过记录每个金额的使用次数，优化状态转移，减少不必要的计算。

#### 3. 作者：Mine_King (赞：10)  
**星级：4星**  
**关键亮点**：  
- 提供了二进制优化的详细实现，适合理解多重背包的优化思路。
- 通过预处理和优化，提升了算法效率。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
for (rg int i = 1; i <= cnt; i++) {
    while (dp[tmp] && tmp <= mx) tmp++;
    if (tmp >= mx) break;
    int nd = max(tmp, a[i]);
    for (rg int j = mx; j >= nd; j--) {
        if (dp[j - a[i]]) dp[j] = true;
    }
}
```
**实现思想**：通过二进制拆分和预处理，优化多重背包问题的求解过程。

### 最优关键思路与技巧

1. **二进制优化**：将多重背包问题转化为01背包问题，减少物品数量，降低时间复杂度。
2. **bitset优化**：利用bitset的位运算特性，进一步提升空间和时间效率。
3. **贪心思想**：通过贪心策略，减少不必要的状态转移，优化算法效率。

### 可拓展之处

- **同类型题**：类似的多重背包问题可以通过二进制优化和bitset优化来解决。
- **类似算法套路**：在其他背包问题中，也可以考虑使用二进制优化和bitset优化来提升效率。

### 推荐题目

1. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得总结

- **调试经历**：在实现二进制优化时，需要注意拆分后的物品数量是否覆盖了所有可能的情况。
- **踩坑教训**：在使用bitset优化时，要注意bitset的大小和位运算的正确性。
- **顿悟感想**：通过优化算法，可以大幅提升程序的效率，尤其是在处理大规模数据时。

---
处理用时：27.23秒
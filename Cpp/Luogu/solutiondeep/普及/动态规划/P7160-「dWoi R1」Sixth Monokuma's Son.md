# 题目信息

# 「dWoi R1」Sixth Monokuma's Son

## 题目背景

题目首先定义矩阵环为，给定一个矩阵 $A$，初始全为白色，在其中选定一个子矩阵 $A_1$ 标黑，再在 $A_1$ 内选定一个子矩阵 $A_2$ 标白，就会形成一个矩阵环。注意，矩阵环至少上下左右都有被选定的部分，且整个矩阵环不是一个长方形的矩阵。

假设 `+` 为黑，`-` 为白，下面这个就是矩阵环：

```
---+++++--
---++--+--
---+++++--
---+++++--
----------
```

下面就不是矩阵环：

```
------- ------
---+++- --+++-
---+-+- --+++-
------- --+++-
```

因此，矩阵环会出现上，下，左，右四条边，每个方向有多少个涂黑的部分，就是那个方向的厚度。比如对于第一张符合要求的图，上方，右方的厚度为 $1$，左方，下方的厚度为 $2$。

**注意，一个完整的矩阵不是一个矩阵环。**

---

接下来是正经的题目背景：

最原得到了“狱原发现一些小昆虫”这个线索后，立刻采取了行动。首先，他利用入间的 ~~遗物~~，那个类似喷火器的东西，吸进了一些空气，然后，他打算利用机望的机械眼进行查看。

## 题目描述

机望的机械眼能扫到一片 $n \times m$ 的区域，第 $i$ 行第 $j$ 列发现了 $a_{i,j}$ 的不对劲值。

因为机望被外部力量折磨的厉害，所以机望只能锁定一个矩阵环进行查看。机望想求助于你，他想让你锁定一个矩阵环，使得这个矩阵环中的所有位置的不对劲值的和最大，**上方，下方的厚度为 $1$ 且上方的那一行在整个区域的第一行，下方的那一行在整个区域的最后一行**。至于左右的厚度，机望不限制更多要求。

## 说明/提示

#### 样例说明

关于样例 1 的解释：

可以选择如下形式的矩阵环（但其实两个解是一样的，因为第一列所有数之和为 $0$）：

```
++++  -+++
++-+  -+-+
++-+  -+-+
++++  -+++
```

其中 + 为选定的，- 为未选定的。

关于样例 3，提供者 @[cmll02](https://www.luogu.com.cn/user/171487)，感谢他的贡献。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（5 pts）：$n \le 2$ 或 $m \le 2$。
- Subtask 2（5 pts）：$a_{i,j}>0$。
- Subtask 3（40 pts）：$m \le 1000$。
- Subtask 4（50 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10$，$1 \le m \le 10^5$，$|a_{i,j}| \le 100$。

## 样例 #1

### 输入

```
4 4
3 -4 2 -2
-5 3 -4 2
-1 3 -4 0
3 -3 3 4```

### 输出

```
8```

## 样例 #2

### 输入

```
1 2
11 45```

### 输出

```
-1```

## 样例 #3

### 输入

```
7 7
10 10 10 -100 11   11 11
10 10 10 -100 11 -100 11
10 10 10 -100 11 -100 11
10 10 10 -100 11 -100 11
10 10 10 -100 11 -100 11
10 10 10 -100 11 -100 11
10 10 10 -100 11   11 11```

### 输出

```
176```

# AI分析结果

### 综合分析与结论

本题的核心是寻找一个矩阵环，使得其内部元素和最大。矩阵环的定义要求上下厚度为1，且上下边界分别位于矩阵的第一行和最后一行。题解中大多数解法采用了动态规划（DP）的思路，将矩阵环分为左、中、右三部分，分别计算每部分的最大和，最终通过状态转移方程求解。

### 题解评分与关键亮点

1. **作者：wsyhb (5星)**
   - **关键亮点**：思路清晰，将矩阵环分为左、中、右三部分，分别用三个DP数组进行状态转移，代码简洁且易于理解。
   - **代码核心思想**：
     ```cpp
     dp1[i] = max(dp1[i-1], 0) + s[i];
     dp2[i] = max(dp2[i-1], dp1[i-1]) + t[i];
     dp3[i] = max(dp3[i-1], dp2[i-1]) + s[i];
     ```
   - **个人心得**：作者提到“代码非常地好写”，表明其思路简洁且易于实现。

2. **作者：xuan_gong_dong (4星)**
   - **关键亮点**：与wsyhb的思路相似，但代码实现略有不同，使用了二维DP数组，增加了代码的可读性。
   - **代码核心思想**：
     ```cpp
     dp[i][0] = max(dp[i-1][0], 0) + pre[i];
     dp[i][1] = max(dp[i-1][0], dp[i-1][1]) + hys[i];
     dp[i][2] = max(dp[i-1][1], dp[i-1][2]) + pre[i];
     ```
   - **个人心得**：作者提到“一开始看到n≤10还以为是状态压缩”，表明其在理解题意时有过误判，但最终通过重新理解题意找到了正确的解法。

3. **作者：yzysdTNT (4星)**
   - **关键亮点**：详细分析了矩阵环的构成，将矩阵环分为左、中、右三部分，并通过DP进行状态转移，代码实现清晰。
   - **代码核心思想**：
     ```cpp
     f1[i] = max(f1[i - 1] + line[i], line[i]);
     f2[i] = max(f1[i - 1] + mid[i], f2[i - 1] + mid[i]);
     f3[i] = max(f2[i - 1] + line[i], f3[i - 1] + line[i]);
     ```
   - **个人心得**：作者提到“n其实是没有什么用的”，表明其在分析问题时抓住了关键点，简化了问题。

### 最优关键思路与技巧

- **分阶段DP**：将矩阵环分为左、中、右三部分，分别用不同的DP数组进行状态转移，确保每部分的计算独立且有序。
- **预处理**：在输入时预处理每列的总和和首尾元素和，减少后续计算的时间复杂度。
- **边界处理**：在DP初始化时，将边界条件设置为极小值，确保矩阵环非空。

### 可拓展之处

- **类似问题**：类似的分阶段DP思路可以应用于其他需要分段求解的问题，如最大子矩阵和、最大子序列和等。
- **数据结构优化**：对于更大规模的数据，可以考虑使用线段树等数据结构优化DP的转移过程。

### 推荐题目

1. **P1115 最大子段和**：考察最大子序列和问题，与本题的DP思路相似。
2. **P1719 最大加权矩形**：考察最大子矩阵和问题，与本题的分阶段DP思路相似。
3. **P1880 [NOI1995] 石子合并**：考察区间DP，与本题的分阶段DP思路相似。

### 个人心得总结

- **理解题意**：在解题时，理解题意是关键，避免因误解题意而走弯路。
- **简化问题**：通过预处理和分阶段DP，可以将复杂问题简化，提高解题效率。
- **代码实现**：简洁的代码实现有助于减少调试时间，提高解题速度。

---
处理用时：28.76秒
# 题目信息

# [BalticOI 2000] Honeycomb Problem

## 题目描述

如下图，是一个边长为 $3$ 的蜂窝图，每个点有点权：

![](https://cdn.luogu.com.cn/upload/image_hosting/71c4lcqk.png)

现在要从上面一行的某一点到最下面的一行某一点，每次只可以到达左下角的点和右下角的点，您最多可以交换选定的一行中的两个点的数值。

求通过交换，从上面一行的某一点到最下面的一行某一点的点权之和的最大值是多少。

## 说明/提示

#### 样例说明

对于样例 $1$，交换第四行的 $5$ 和 $1$，然后我们就可以得到一条点权之和最大的路径：

$$3 \to 2 \to 8 \to 5 \to 4$$

最大值为 $22$。

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \le n \le 99$，$0 \le $ 蜂窝图中的每个图 $\le 99$。

#### 说明

翻译自 [BalticOI 2000 Day1 A Honeycomb Problem](https://boi.cses.fi/files/boi2000_day1.pdf)。

## 样例 #1

### 输入

```
3
1 2 3
3 2 2 1
4 2 8 0 3
5 3 1 2
3 1 4```

### 输出

```
22```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）解决蜂窝图中的路径最大和问题，并允许在任意一行进行一次交换操作。各题解普遍采用了三维DP的思路，分别记录是否进行过交换的状态。难点在于如何正确处理蜂窝图的行列关系以及状态转移方程的设计。

大多数题解的思路相似，主要区别在于代码实现和细节处理上。部分题解在输入处理和状态转移方程的推导上更为清晰，而有些题解则通过优化空间复杂度或简化代码结构来提高效率。

### 所选高星题解

#### 1. 作者：卷王 (★★★★★)
**关键亮点：**
- 详细解释了蜂窝图的输入处理，特别是如何分上下两部分进行输入。
- 状态转移方程清晰，分别处理了上半部分和下半部分的不同转移方式。
- 代码结构清晰，注释详细，便于理解。

**个人心得：**
- 提到输入处理是本题的一个难点，但通过找规律可以简化。
- 强调了贪心思想，即在交换时选择该行的最大值。

**核心代码：**
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= n + i - 1; j++) {
        dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j - 1][0]) + a[i][j];
        dp[i][j][1] = max(max(dp[i - 1][j][1], dp[i - 1][j - 1][1]) + a[i][j], max(dp[i - 1][j][0], dp[i - 1][j - 1][0]) + row[i]);
    }
```

#### 2. 作者：Exber (★★★★☆)
**关键亮点：**
- 详细解释了如何将蜂窝图“拍扁”成二维数组，简化了存储和访问。
- 状态转移方程推导清晰，分别处理了上半部分和下半部分的不同转移方式。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n + i - 1; j++) {
        dp[0][i][j] = max(dp[0][i - 1][j], dp[0][i - 1][j - 1]) + a[i][j];
        dp[1][i][j] = max(max(dp[1][i - 1][j], dp[1][i - 1][j - 1]) + a[i][j], max(dp[0][i - 1][j], dp[0][i - 1][j - 1]) + maxn[i]);
    }
}
```

#### 3. 作者：Error_Eric (★★★★☆)
**关键亮点：**
- 通过小学目视法直观地解释了蜂窝图的行列关系。
- 状态转移方程简洁明了，分别处理了上半部分和下半部分的不同转移方式。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= l; j++)
        f[i][j] = max(f[i - 1][j] + a[i - 1][j], f[i - 1][j - 1] + a[i - 1][j - 1]),
        g[i][j] = max(max(f[i - 1][j], f[i - 1][j - 1]) + m[i - 1], max(g[i - 1][j] + a[i - 1][j], g[i - 1][j - 1] + a[i - 1][j - 1]));
```

### 最优关键思路与技巧

1. **蜂窝图的存储与访问**：将蜂窝图分上下两部分处理，上半部分列数递增，下半部分列数递减。
2. **状态转移方程**：分别处理是否进行过交换的状态，确保在交换时选择该行的最大值。
3. **贪心思想**：在交换时选择该行的最大值，确保路径和最大化。

### 可拓展之处

- **滚动数组优化**：可以通过滚动数组将空间复杂度从O(n^2)优化到O(n)。
- **类似问题**：可以扩展到其他类型的图结构，如三角形图、矩形图等，考察类似的路径最大和问题。

### 推荐题目

1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)

这些题目都涉及到路径最大和问题，且需要通过动态规划来解决，适合进一步练习和巩固相关知识。

---
处理用时：31.21秒
# 题目信息

# 「WHOI-1」数列计数

## 题目背景

> 不再拥有，数列陪伴我。



## 题目描述

这种数列满足下面这一条神奇的性质：

- $a_0=0$。
- $\forall i\in[1,n]$ 均有 $a_i=a_{i-1}+x$ 或者 $a_i=a_{i-1}+y$。
- $\forall i\in[1,n],p \nmid a_i$。

求这样的 $\{a\}_0^{n}$ 的数量。答案对 $10^9+7$ 取模。

两个数列不同，当且仅当他们有一个下标存储的元素不同。

## 说明/提示

样例 #1：

这样的 $a$ 有 $[0,1,2,4],[0,2,4,5]$。

样例 #2、#3：

本来可爱的 Otm 已经写好了上万页的样例解释了，但是更可爱的 miku 把它删掉了所以 Otm 不想再写一遍了。

---

**本题采用 $\texttt{Subtask}$ 计分方式，只有通过该 $\texttt{Subtask}$ 的所有测试点才能得到该点的分数。**

| $\texttt{Subtask}$ 编号 | 特殊限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | $\sum n\leq20$ | 10 |
| 2 | $p\leq10^3$ | 30 |
| 3 | $xy,p$ 互质 | 10 |
| 4 | 无 | 50 |

对于所有测试数据，$1\leq T\leq10^3,1\leq\sum n\leq10^4, 1\leq x,y,p\leq10^9$，输入均为正整数。

## 样例 #1

### 输入

```
3
3 3 1 2
11 45 14 19
9876 10 114514 191981```

### 输出

```
2
1688
426554662
```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）来计算满足特定条件的数列数量。大多数题解采用了类似的DP思路，即定义状态 `dp[i][j]` 表示进行了 `i` 次 `+x` 和 `j` 次 `+y` 操作后的方案数，并通过状态转移方程 `dp[i][j] = dp[i-1][j] + dp[i][j-1]` 来更新状态。为了避免空间复杂度过高，几乎所有题解都使用了滚动数组优化。

### 所选高质量题解

#### 1. **作者：幸存者 (5星)**
- **关键亮点**：思路清晰，代码简洁，使用了滚动数组优化空间复杂度，且对 `x = y` 的情况进行了特判。
- **个人心得**：作者提到直接使用二维DP会超出空间限制，因此采用了滚动数组优化，这一点在实际编程中非常实用。

```cpp
int dp[2][10010];
const int mod = 1e9 + 7;
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int t;
    cin >> t;
    while (t--) {
        int n, p, x, y, ans = 0;
        cin >> n >> p >> x >> y;
        if (x == y) {
            bool flag = false;
            for (int i = 1; i <= n; i++) if (1ll * i * x % p == 0) {
                flag = true;
                break;
            }
            cout << (flag ? 0 : 1) << endl;
            continue;
        }
        dp[0][0] = 1;
        for (int i = 0; i <= n; i++) for (int j = 0; i + j <= n; j++) {
            if (i == 0 && j == 0) continue;
            if ((1ll * i * x + 1ll * j * y) % p != 0) {
                if (i == 0) dp[i & 1][j] = dp[i & 1][j - 1];
                else if (j == 0) dp[i & 1][j] = dp[i & 1 ^ 1][j];
                else dp[i & 1][j] = (dp[i & 1 ^ 1][j] + dp[i & 1][j - 1]) % mod;
            }
            else dp[i & 1][j] = 0;
            if (i + j == n) ans = (ans + dp[i & 1][j]) % mod;
        }
        cout << ans << endl;
    }
    return 0;
}
```

#### 2. **作者：Otomachi_Una_ (4星)**
- **关键亮点**：官方题解，思路清晰，分阶段解释了不同子任务的解法，特别是对 `x = y` 的情况进行了详细说明。
- **个人心得**：作者提到 `x = y` 时直接检验生成的数列是否合法，这一点在实际编程中非常实用。

```cpp
if (x == y) {
    bool op = 1;
    for (int i = 1; i <= n; ++i) {
        if (1LL * i * x % p == 0) {
            op = 0;
            break;
        }
    }
    printf("%d\n", op ? 1 : 0);
}
```

#### 3. **作者：TempestJueMu (4星)**
- **关键亮点**：代码简洁，使用了滚动数组优化，且对 `x = y` 的情况进行了特判。
- **个人心得**：作者提到直接开 `e[10001][10001]` 会 MLE，因此使用了滚动数组，这一点在实际编程中非常实用。

```cpp
if (x == y) {
    fo(i,1,n)if(i*x%p==0){printf("0\n");return;}
    printf("1\n");return;
}
```

### 最优关键思路与技巧

1. **滚动数组优化**：通过滚动数组将空间复杂度从 `O(n^2)` 降低到 `O(n)`，这在处理大规模数据时非常有效。
2. **特判 `x = y`**：当 `x = y` 时，数列只有一种可能，直接判断是否满足条件即可，避免不必要的计算。
3. **状态转移方程**：通过 `dp[i][j] = dp[i-1][j] + dp[i][j-1]` 来更新状态，确保每一步都符合题目要求。

### 可拓展之处

- **类似题目**：可以扩展到其他类似的计数问题，如路径计数、组合计数等。
- **优化技巧**：滚动数组、状态压缩等优化技巧在其他DP问题中也非常常见。

### 推荐题目

1. **P1048 采药**：经典的背包问题，与本题的DP思路类似。
2. **P1216 数字三角形**：动态规划的经典题目，适合练习状态转移方程的构建。
3. **P1434 滑雪**：动态规划与记忆化搜索的结合，适合进一步理解DP的应用。

### 个人心得总结

- **调试经历**：多位作者提到直接使用二维DP会超出空间限制，因此采用了滚动数组优化，这一点在实际编程中非常实用。
- **踩坑教训**：特判 `x = y` 的情况时，需要注意数列的唯一性，避免不必要的计算。
- **顿悟感想**：通过滚动数组优化，可以有效降低空间复杂度，这在处理大规模数据时非常关键。

---
处理用时：35.85秒
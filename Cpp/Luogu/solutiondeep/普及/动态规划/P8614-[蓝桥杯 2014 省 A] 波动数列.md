# 题目信息

# [蓝桥杯 2014 省 A] 波动数列

## 题目描述

观察这个数列：

$1,3,0,2,-1,1,-2, \cdots $。

这个数列中后一项总是比前一项增加 $2$ 或者减少 $3$。

栋栋对这种数列很好奇，他想知道长度为 $n$ 和为 $s$ 而且后一项总是比前一项增加 $a$ 或者减少 $b$ 的整数数列可能有多少种呢？

## 说明/提示

【样例说明】

这两个数列分别是 2 4 1 3 和 7 4 1 -2。

【数据规模与约定】

对于 $10\%$ 的数据，$1 \le n \le 5$，$0 \le s \le 5$，$1 \le a,b \le 5$；

对于 $30\%$ 的数据，$1 \le n \le 30$，$0 \le s \le 30$，$1 \le a,b \le 30$；

对于 $50\%$ 的数据，$1 \le n \le 50$，$0 \le s \le 50$，$1 \le a,b \le 50$；

对于 $70\%$ 的数据，$1 \le n \le 100$，$0 \le s \le 500$，$1 \le a,b \le 50$；

对于 $100\%$ 的数据，$1 \le n \le 1000$，$-10^9 \le s \le 10^9$，$1 \le a,b \le 10^6$。

时限 1 秒, 256M。蓝桥杯 2014 年第五届省赛

## 样例 #1

### 输入

```
4 10 2 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）来解决波动数列的方案数问题。所有题解都采用了DP的思路，但具体的状态定义和转移方程略有不同。大多数题解通过将问题转化为模运算来简化状态空间，避免了直接处理大范围的和值。部分题解还通过数学推导进一步优化了状态转移方程。

### 所选高星题解

#### 1. 作者：卷王 (赞：20)  
**星级：5星**  
**关键亮点：**  
- 清晰的状态定义：`dp[i][j]` 表示前 `i` 项的和模 `n` 等于 `j` 时的方案数。
- 简洁的转移方程：`dp[i][j] = (dp[i-1][c(j-a*i)] + dp[i-1][c(j+b*i)]) % mod`。
- 代码简洁且可读性强，处理了负数取模的问题。

**核心代码：**
```cpp
int dp[1007][1007];
inline int c(int x) {
    return (x % n + n) % n;
}
int main() {
    cin >> n >> s >> a >> b;
    dp[0][0] = 1;
    for(int i = 1; i < n; i++)
        for(int j = 0; j < n; j++)
            dp[i][j] = (dp[i - 1][c(j - a * i)] + dp[i - 1][c(j + b * i)]) % mod;
    cout << dp[n - 1][c(s)];
    return 0;
}
```

#### 2. 作者：Little_RMQ (赞：17)  
**星级：4.5星**  
**关键亮点：**  
- 通过数学推导简化了问题，将问题转化为模运算问题。
- 状态转移方程清晰：`dp[i][j] = dp[i-1][Mod(j-i*a)] + dp[i-1][Mod(j+i*b)]`。
- 代码结构清晰，处理了负数取模的问题。

**核心代码：**
```cpp
int dp[N][N];
signed main() {
    n=read();
    s=read(),a=read(),b=read();
    dp[0][0]=1;
    for(int i=1;i<n;i++) 
        for(int j=0;j<n;j++)
            dp[i][j]=(dp[i-1][((j-i*a)%n+n)%n]+dp[i-1][((j+i*b)%n+n)%n])%mod;
    printf("%lld\n",dp[n-1][(s%n+n)%n]);
    return 0;
}
```

#### 3. 作者：Smg18 (赞：2)  
**星级：4星**  
**关键亮点：**  
- 通过数学推导简化了问题，将问题转化为模运算问题。
- 状态转移方程清晰：`dp[i][j] = dp[i-1][M(j-a*i)] + dp[i-1][M(j+b*i)]`。
- 代码简洁，处理了负数取模的问题。

**核心代码：**
```cpp
int dp[N][N];
signed main(){
    cin>>n>>s>>a>>b;
    dp[0][0]=1;
    for(int i=1;i<n;i++){
        for(int j=0;j<n;j++){
            dp[i][j]=(dp[i-1][M(j-a*i)]+dp[i-1][M(j+b*i)])%mod;
        }
    }
    cout<<dp[n-1][M(s)];
    return 0;
}
```

### 最优关键思路或技巧

1. **状态定义与转移方程：** 通过将问题转化为模运算，简化了状态空间，避免了直接处理大范围的和值。状态转移方程通常为 `dp[i][j] = dp[i-1][c(j-a*i)] + dp[i-1][c(j+b*i)]`。
2. **负数取模处理：** 使用 `(x % n + n) % n` 来处理负数取模的问题，确保模运算结果始终为正。
3. **数学推导优化：** 通过数学推导将问题转化为模运算问题，进一步优化了状态转移方程。

### 可拓展之处

- **同类型题：** 类似的问题可以通过DP和模运算来解决，尤其是在处理大范围数据时，模运算可以有效减少状态空间。
- **类似算法套路：** 在计数问题中，DP和模运算的结合是一种常见的优化手段，特别是在处理大范围数据时。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典的DP问题，考察状态转移和优化。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 类似DP问题，考察状态定义和转移。
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - DP问题，考察状态转移和优化。

### 个人心得总结

- **调试经历：** 部分题解提到在处理负数取模时容易出错，建议使用 `(x % n + n) % n` 来确保模运算结果为正。
- **踩坑教训：** 在处理大范围数据时，直接使用二维DP可能会导致内存不足，通过模运算可以有效减少状态空间。
- **顿悟感想：** 通过数学推导将问题转化为模运算问题，可以大大简化状态转移方程，提高算法效率。

---
处理用时：35.05秒
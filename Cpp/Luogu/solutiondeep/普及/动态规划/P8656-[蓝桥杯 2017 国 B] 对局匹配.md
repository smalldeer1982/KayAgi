# 题目信息

# [蓝桥杯 2017 国 B] 对局匹配

## 题目描述

小明喜欢在一个围棋网站上找别人在线对弈。这个网站上所有注册用户都有一个积分，代表他的围棋水平。

小明发现网站的自动对局系统在匹配对手时，只会将积分差恰好是 $K$ 的两名用户匹配在一起。如果两人分差小于或大于 $K$，系统都不会将他们匹配。

现在小明知道这个网站总共有 $N$ 名用户，以及他们的积分分别是 $A_1,A_2, \cdots A_N$。

小明想了解最多可能有多少名用户同时在线寻找对手，但是系统却一场对局都匹配不起来（任意两名用户积分差不等于 $K$）？

## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 10$。

对于 $100\%$ 的数据，$1 \le N\le 10^5$，$0\le K,A_i \le 10^5$
。

时限 1 秒, 256M。蓝桥杯 2017 年第八届国赛

## 样例 #1

### 输入

```
10 0
1 4 2 8 5 7 1 4 2 8```

### 输出

```
6```

## 样例 #2

### 输入

```
10 1
2 1 1 1 1 4 4 3 4 4```

### 输出

```
8```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地处理用户积分差为 \( K \) 的匹配问题，并找到无法匹配的最大用户数。大多数题解采用了**桶排序**和**贪心算法**，部分题解进一步引入了**动态规划**来优化计算。以下是各题解的要点总结：

1. **桶排序**：几乎所有题解都使用了桶排序来统计每个积分的用户数量，这是处理此类问题的常见且高效的方法。
2. **贪心算法**：大多数题解通过贪心策略来处理积分差为 \( K \) 的用户匹配问题，优先保留用户数量较多的积分。
3. **动态规划**：部分题解（如 _buzhidao_ 和 TheSky233）引入了动态规划，进一步优化了计算过程，特别是在处理积分差为 \( K \) 的序列时。
4. **特判 \( K = 0 \)**：所有题解都对 \( K = 0 \) 的情况进行了特判，直接统计不同积分的用户数量。

### 所选高分题解

#### 1. 作者：_buzhidao_ (赞：7) - **5星**
- **关键亮点**：引入了动态规划，将问题转化为不相邻数的和的最大值问题，思路清晰且优化了计算过程。
- **个人心得**：通过将问题简化为不相邻数的和的最大值，作者巧妙地应用了动态规划，避免了复杂的匹配逻辑。

```cpp
for(int i=0;i<k;++i){//外循环
    for(int j=i;j<=ma;j+=k){//内循环
        if(j-i==0) dp[j]=s[j];//对应上文i=1
        else if(j-i==k) dp[j]=max(s[j-k],s[j]);//对应上文i=2
        else dp[j]=max(s[j]+dp[j-2*k],dp[j-k]);//对应上文否则
    }
}
```

#### 2. 作者：TheSky233 (赞：3) - **4.5星**
- **关键亮点**：将积分按 \( K \) 取模分组，并在每组内应用动态规划，进一步优化了计算过程。
- **个人心得**：通过分组和动态规划的结合，作者有效地处理了积分差为 \( K \) 的序列，避免了重复计算。

```cpp
for(int i = 0; i < k; i++) {
    if(v[i].empty()) continue;
    int siz = v[i].size();
    memset(dp, 0x3f, (siz + 5) * sizeof(dp[0][0]));
    for(int j = 0; j < siz; j++) {
        if(j == 0) dp[0][1] = d[a[v[i][j]]], dp[0][0] = 0;
        else if((a[v[i][j]] - a[v[i][j-1]]) == k) {
            dp[j][0] = max(dp[j-1][1], dp[j-1][0]);
            dp[j][1] = dp[j-1][0] + d[a[v[i][j]]];
        } else {
            dp[j][0] = max(dp[j-1][1], dp[j-1][0]);
            dp[j][1] = max(dp[j-1][1], dp[j-1][0]) + d[a[v[i][j]]];
        }
    }
    ans += max({dp[siz - 1][0], dp[siz - 1][1]});
}
```

#### 3. 作者：xiaoxiaoxia (赞：11) - **4星**
- **关键亮点**：使用了贪心算法，代码简洁且易于理解，适合初学者。
- **个人心得**：通过贪心策略，作者有效地处理了积分差为 \( K \) 的用户匹配问题，代码实现简洁明了。

```cpp
for(int i=0;i<MAXN-k;i++) {
    if( a[i]<a[i+k]) {
        a[i+k]-=a[i];
    } else {
        a[i+k]=0;
    }
}
```

### 最优关键思路与技巧

1. **桶排序**：统计每个积分的用户数量，是处理此类问题的关键步骤。
2. **贪心算法**：优先保留用户数量较多的积分，简化了匹配逻辑。
3. **动态规划**：在处理积分差为 \( K \) 的序列时，动态规划可以进一步优化计算过程。

### 拓展思路

- **类似问题**：处理匹配问题时，可以考虑将问题转化为不相邻数的和的最大值问题，应用动态规划进行优化。
- **其他应用**：此类问题在资源分配、任务调度等领域也有广泛应用，可以进一步探索相关算法。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 动态规划的经典问题。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 背包问题的变种。
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 动态规划的应用。

---
处理用时：34.45秒
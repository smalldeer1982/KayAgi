# 题目信息

# [蓝桥杯 2022 省 B] 李白打酒加强版

## 题目描述

话说大诗人李白，一生好饮。幸好他从不开车。

一天，他提着酒壶，从家里出来，酒壶中有酒 $2$ 斗。他边走边唱：

> 无事街上走，提壶去打酒。  
> 逢店加一倍，遇花喝一斗。

这一路上，他一共遇到店 $N$ 次，遇到花 $M$ 次。已知最后一次遇到的是花，他正好把酒喝光了。

请你计算李白这一路遇到店和花的顺序，有多少种不同的可能?

注意：壶里没酒（$0$ 斗）时遇店是合法的，加倍后还是没酒；但是没酒时遇花是不合法的。

## 说明/提示

**【样例说明】**

如果我们用 `0` 代表遇到花，`1` 代表遇到店，$14$ 种顺序如下: 

```plain
010101101000000
010110010010000
011000110010000
100010110010000
011001000110000
100011000110000
100100010110000
010110100000100
011001001000100
100011001000100
100100011000100
011010000010100
100100100010100
101000001010100
```

**【评测用例规模与约定】**

对于 $40 \%$ 的评测用例：$1 \leq N, M \leq 10$。

对于 $100 \%$ 的评测用例：$1 \leq N, M \leq 100$。 

蓝桥杯 2022 省赛 B 组 I 题。

## 样例 #1

### 输入

```
5 10```

### 输出

```
14```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）来求解李白打酒加强版的问题。所有题解都采用了DP的思路，但在状态定义、转移方程、以及优化细节上有所不同。大部分题解的状态定义为 `f[i][j][k]`，表示在第 `i` 步时，已经遇到 `j` 次花，当前酒量为 `k` 的方案数。难点在于如何正确处理边界条件（如酒量为0时遇花不合法）以及如何优化状态转移。

### 所选高星题解

#### 1. 作者：Xy_top (★★★★★)
**关键亮点**：
- 使用了贡献转移的思路，状态定义清晰。
- 通过限制酒量的上限（不超过 `m`）来优化空间和时间复杂度。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for (int i = 0; i < n + m; i ++)
    for (int j = 0; j < m; j ++)
        for (int k = 0; k <= m; k ++)
            if (f[i][j][k]) {
                if (k > 0) f[i + 1][j + 1][k - 1] = (f[i + 1][j + 1][k - 1] + f[i][j][k]) % 1000000007;
                if (k <= 50) f[i + 1][j][k * 2] = (f[i + 1][j][k * 2] + f[i][j][k]) % 1000000007;
            }
```
**核心思想**：通过前推后的方式，依次循环 `i`, `j`, `k`，并根据当前状态更新下一步的状态。

#### 2. 作者：hyfzelda (★★★★☆)
**关键亮点**：
- 状态定义明确，转移方程简洁。
- 通过限制酒量的上限（不超过100）来优化空间。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
for(int i=0;i<=n;i++)
    for(int j=0;j<=m-1;j++)
        for(int k=0;k<=100;k++){
            if(k%2==0&&i) dp[i][j][k]+=dp[i-1][j][k/2];
            if(j) dp[i][j][k]+=dp[i][j-1][k+1];
            dp[i][j][k]%=mod;
        }
```
**核心思想**：通过枚举 `i`, `j`, `k`，并根据当前状态更新下一步的状态，特别注意酒量为偶数时才能从店转移。

#### 3. 作者：_yolanda_ (★★★★☆)
**关键亮点**：
- 提供了两种状态定义，分别适用于不同的优化思路。
- 通过限制酒量的上限（不超过 `m`）来优化空间。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
for(int i=0;i<=n;++i)
    for(int j=0;j<=m;++j){
        if(!i && !j) continue;
        for(int k=0;k<=m;++k){
            if(k%2==0 && i) f[i][j][k]+=f[i-1][j][k/2];
            if(j && k+1<=m) f[i][j][k]+=f[i][j-1][k+1];
            f[i][j][k]%=p;
        }
    }
```
**核心思想**：通过枚举 `i`, `j`, `k`，并根据当前状态更新下一步的状态，特别注意酒量为偶数时才能从店转移。

### 最优关键思路与技巧
- **状态定义**：大部分题解都采用了 `f[i][j][k]` 的状态定义，表示在第 `i` 步时，已经遇到 `j` 次花，当前酒量为 `k` 的方案数。
- **转移方程**：根据当前状态，更新下一步的状态，特别注意酒量为0时遇花不合法，以及酒量为偶数时才能从店转移。
- **优化**：通过限制酒量的上限（不超过 `m`）来优化空间和时间复杂度。

### 可拓展之处
- **类似问题**：类似的问题可以通过类似的状态定义和转移方程来解决，如背包问题、路径计数问题等。
- **优化技巧**：在DP问题中，通过限制状态的上限来优化空间和时间复杂度是一个常见的技巧。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 背包问题的经典题目，考察DP的基本应用。
2. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216) - 路径计数问题，考察DP的状态转移。
3. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002) - 路径计数问题，考察DP的状态转移和边界处理。

### 个人心得摘录
- **Xy_top**：通过限制酒量的上限来优化空间和时间复杂度，这是一个非常实用的技巧。
- **hyfzelda**：特别注意酒量为偶数时才能从店转移，这是一个容易被忽略的细节。
- **_yolanda_**：提供了两种状态定义，分别适用于不同的优化思路，这是一个非常有价值的经验。

---
处理用时：39.77秒
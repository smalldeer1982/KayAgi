# 题目信息

# 签到题

## 题目背景

著名的【数据删除】是一个热爱旅游的人！这一天他来到了神秘的 ZYL 国度。

入海关的时候他被问到了一个题目，如果答对他就可以顺利到达 ZYL 的首都 ZY 了！身为堂堂【数据删除】，他居然还花了 $10^{-233}$ 秒才想出来做法，实在是有点难的！于是他决定拿来考考你。

## 题目描述

给定长度为 $n$ 的序列 $a$，保证 $a_i$ 是**正整数**。你需要选择一个位置 $i$ 并将 $a_i$ 修改为一个**任意的整数**。最大化最长**严格**上升子串的长度。

所谓严格上升子串，就是从序列中选出位置**连续**的若干个数字，满足后一个数字比前一个大（而不能相等或小于）。

如序列 $[1,4,2,3,5]$ 中，子序列 $[2,3,5]$ 就是严格上升子串，而 $[4,2,3]$（不上升）和 $[1,2,3]$（不连续）则不是。

## 说明/提示

**【样例解释 \#1】**

对于样例 \#1，我们可以将序列 $[1,4,2,2,3]$ 中的第三个位置修改为 $5$，得到新序列 $[1,4,5,2,3]$。这个序列的最长严格上升子串是 $[1,4,5]$，长度为 $3$。

容易证明，不存在一种修改方案使得修改后的序列的最长严格上升子串的长度大于 $3$。

---

**【样例解释 \#4】**

对于样例 \#4，我们可以将序列 $[8,2,3,1,4,5]$ 中的第三个位置修改为 $0$，得到新序列 $[8,2,0,1,4,5]$。这个序列的最长严格上升子串是 $[0,1,4,5]$，长度为 $4$。

容易证明，不存在一种修改方案使得修改后的序列的最长严格上升子串的长度大于 $4$。

---

**【数据范围】**

对于前 $20\%$ 的数据，满足 $n \le 5$，$a_i \le 5$。  
对于前 $40\%$ 的数据，满足 $n \le 10$，$a_i \le 10$。  
对于前 $70\%$ 的数据，满足 $n \le 300$。  
对于 $100 \%$ 的数据，满足 $1 \le n \le {10}^6$，$1 \le a_i \le {10}^9$。

## 样例 #1

### 输入

```
5
1 4 2 2 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5
1 2 3 2 1
```

### 输出

```
4
```

## 样例 #3

### 输入

```
5
1 2 3 1 5
```

### 输出

```
5
```

## 样例 #4

### 输入

```
6
8 2 3 1 4 5
```

### 输出

```
4
```

## 样例 #5

### 输入

```
6
7 2 9 4 5 6
```

### 输出

```
5
```

# AI分析结果

### 综合分析与结论

该题的核心目标是找到修改一个元素后，序列中最长严格上升子串的最大长度。大多数题解都采用了预处理前后缀数组（如 `f[i]` 和 `g[i]`）来记录以每个位置为起点或终点的最长严格上升子串长度，然后通过枚举修改位置来计算可能的最大长度。优化思路主要集中在如何高效地合并前后子串，以及如何处理边界情况。

### 所选高星题解

#### 1. 作者：Iniaugoty (5星)
**关键亮点**：
- 思路清晰，详细解释了如何通过预处理 `e[i]` 和 `b[i]` 来记录以每个位置为起点或终点的最长严格上升子串长度。
- 代码简洁，逻辑严密，处理了所有边界情况，如 `i=1` 和 `i=n` 的情况。
- 通过枚举修改位置，巧妙地计算了可能的最大长度，时间复杂度为 `O(n)`。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    if(a[i-1]<a[i+1]-1)
        ans=max(ans,e[i-1]+b[i+1]+1);
    if(a[i-1]>=a[i])
        ans=max(ans,e[i-1]+1);
    if(a[i]>=a[i+1])
        ans=max(ans,b[i+1]+1);
}
```
**核心思想**：通过预处理 `e[i]` 和 `b[i]`，枚举每个修改位置，计算可能的最大长度。

#### 2. 作者：ttq012 (4.5星)
**关键亮点**：
- 详细解释了如何通过预处理 `f[i]` 和 `g[i]` 来记录以每个位置为起点或终点的最长严格上升子串长度。
- 通过枚举修改位置，巧妙地计算了可能的最大长度，时间复杂度为 `O(n)`。
- 代码简洁，逻辑清晰，处理了所有边界情况。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    if(a[i+1]-a[i-1]>=2)
        mx=max(mx,f[i-1]+g[i+1]+1);
    else
        mx=max(mx,max(f[i-1],g[i+1])+1);
}
```
**核心思想**：通过预处理 `f[i]` 和 `g[i]`，枚举每个修改位置，计算可能的最大长度。

#### 3. 作者：ncwzdlsd (4星)
**关键亮点**：
- 思路清晰，详细解释了如何通过预处理 `f[i]` 和 `g[i]` 来记录以每个位置为起点或终点的最长严格上升子串长度。
- 通过枚举修改位置，巧妙地计算了可能的最大长度，时间复杂度为 `O(n)`。
- 代码简洁，逻辑清晰，处理了所有边界情况。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    if(a[i+1]-a[i-1]>1)
        ans=max(ans,g[i-1]+f[i+1]+1);
    else
        ans=max(ans,max(g[i-1]+1,f[i+1]+1));
}
```
**核心思想**：通过预处理 `f[i]` 和 `g[i]`，枚举每个修改位置，计算可能的最大长度。

### 最优关键思路与技巧
- **预处理前后缀数组**：通过预处理 `f[i]` 和 `g[i]` 来记录以每个位置为起点或终点的最长严格上升子串长度，是解决该题的核心技巧。
- **枚举修改位置**：通过枚举每个修改位置，计算可能的最大长度，时间复杂度为 `O(n)`。
- **边界处理**：处理 `i=1` 和 `i=n` 的边界情况，确保算法的正确性。

### 可拓展之处
- **类似题目**：可以扩展到其他需要修改一个元素来优化某种序列性质的题目，如最长不下降子串、最长回文子串等。
- **算法套路**：预处理前后缀数组的套路可以应用于其他需要快速查询某个位置前后信息的题目。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020) - 考察最长不上升子序列和最长上升子序列。
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 考察最长上升子序列和最长下降子序列的结合。
3. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439) - 考察最长公共子序列的优化解法。

### 个人心得摘录
- **调试经历**：在处理边界情况时，容易忽略 `i=1` 和 `i=n` 的情况，导致程序出错。通过仔细检查边界条件，确保了程序的正确性。
- **顿悟感想**：通过预处理前后缀数组，可以大大简化问题的复杂度，这是解决类似序列优化问题的关键技巧。

---
处理用时：37.89秒
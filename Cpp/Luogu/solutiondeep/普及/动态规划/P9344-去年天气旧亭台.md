# 题目信息

# 去年天气旧亭台

## 题目背景

依旧是过往的天气，过往的楼台烟雨。时间悄悄流逝着，山河仍在，人却已不是过去的人……

## 题目描述

登上楼台，旧时满面沉灰的地板映入眼帘。

共有 $n$ 块地板，地板分为两类，第 $i$ 块地板的类别用 $c_i$ 表示，积灰程度用 $a_i$ 表示。**注意 $c_i$ 为 $0$ 或 $1$。**

现在要清理这些地板上的灰尘。每次操作中，你可以：

+ 选择两个下标 $i,j$，满足 $1\leq i\leq j\leq n$， $c_i=c_j$，**且第 $i$ 块和第 $j$ 块地板上的灰尘均未被清理过**；
+ 花费 $a_i+a_j$ 的能量清理**第 $i$ 块到第 $j$ 块所有地板**上的灰尘。

求清理完所有地板上的灰尘至少要多少能量。

## 说明/提示

**【样例 1 解释】**

- 对于第一组数据，直接花费 $a_1+a_6=5$ 的能量清理所有灰尘。
- 对于第二组数据，先花费 $a_1+a_1=6$ 的能量清理第一个地板上的灰尘，再花费 $a_2+a_8=7$ 的能量清理剩余灰尘。

**【数据规模与约定】**

对于 $10\%$ 的数据，保证 $T\le 10$，$n\le 10$；

对于 $40\%$ 的数据，保证 $T\le 20$，$n\le 10^3$；

另有 $10\%$ 的数据，保证 $c_i=1$；

对于 $100\%$ 的数据，保证 $1 \le T \le 10^5$，$1 \le n,\sum n\le 2 \times 10^6$，$c_i \in \{0,1\}$，$1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
2
6
1 1 4 5 1 4
1 0 0 1 0 1
8
3 1 4 1 5 9 2 6
1 0 1 0 1 0 1 0```

### 输出

```
5
13```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地清理地板上的灰尘，最小化能量消耗。题解主要分为贪心和动态规划两种思路，其中贪心算法通过分类讨论（首尾地板类型相同或不同）来简化问题，而动态规划则通过状态转移方程来逐步求解最小能量消耗。

#### 最优思路与技巧
1. **贪心算法**：当首尾地板类型相同时，直接清理整个区间是最优的；当首尾地板类型不同时，通过寻找一个分割点将区间分为两部分，分别清理，确保能量消耗最小。
2. **动态规划**：通过维护前缀最小值，优化状态转移方程，将时间复杂度从 \(O(n^2)\) 降低到 \(O(n)\)。
3. **分类讨论**：通过首尾地板类型是否相同进行分类，简化问题复杂度。

#### 可拓展之处
- **多类型地板**：如果地板类型不止两种，贪心算法的分类讨论和动态规划的状态转移方程需要进一步扩展。
- **区间合并**：类似区间合并问题，可以通过贪心或动态规划来优化区间选择。

### 推荐题目
1. **P1880 [NOI1995] 石子合并**：考察区间合并问题，类似本题的区间选择。
2. **P1040 加分二叉树**：动态规划与区间选择的结合。
3. **P1090 合并果子**：贪心算法的经典应用，类似本题的区间选择。

### 题解评分与亮点

#### 1. 作者：_JF_ (赞：32)
- **星级**：5星
- **关键亮点**：通过分类讨论首尾地板类型是否相同，提出贪心算法的最优解，并给出详细的证明过程，思路清晰，代码简洁。
- **核心代码**：
  ```cpp
  if(c[1]==c[n]) {
      cout<<a[1]+a[n]<<endl;
      continue;
  }
  int ans=LONG_LONG_MAX;
  for(int i=1;i<n;i++)
      if(c[i]==c[1]&&c[i+1]==c[n])
          ans=min(ans,a[i]+a[1]+a[n]+a[i+1]);
  cout<<ans<<endl;
  ```
- **个人心得**：通过反证法证明了分割点的存在性，确保贪心算法的正确性。

#### 2. 作者：zhlzt (赞：11)
- **星级**：4星
- **关键亮点**：采用线性DP的思路，通过维护前缀最小值优化状态转移方程，代码实现简洁，时间复杂度为 \(O(n)\)。
- **核心代码**：
  ```cpp
  long long ans1=1e15,ans2=1e15;
  for(int i=1;i<=n;i++){
      if(c[i]==0) ans1=min(ans1,dp[i-1]+a[i]),dp[i]=ans1+a[i];
      else ans2=min(ans2,dp[i-1]+a[i]),dp[i]=ans2+a[i];
  }
  printf("%lld\n",dp[n]);
  ```
- **个人心得**：通过维护两个前缀最小值，分别处理不同类型的地板，确保状态转移的高效性。

#### 3. 作者：Iniaugoty (赞：3)
- **星级**：4星
- **关键亮点**：动态规划的正解做法，通过优化状态转移方程，将时间复杂度从 \(O(n^2)\) 降低到 \(O(n)\)，代码实现简洁。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++){
      f[c[i]]=min(f[c[i]],dp[i-1]+a[i]);
      dp[i]=f[c[i]]+a[i];
  }
  return dp[n];
  ```
- **个人心得**：通过优化状态转移方程，避免重复计算，提高算法效率。

### 通用建议与扩展思路
- **贪心与动态规划的结合**：在类似问题中，可以先通过贪心算法简化问题，再通过动态规划进一步优化。
- **分类讨论**：在处理区间问题时，通过分类讨论可以简化问题复杂度，提高算法效率。
- **前缀最小值的维护**：在动态规划中，通过维护前缀最小值可以优化状态转移方程，降低时间复杂度。

---
处理用时：30.74秒
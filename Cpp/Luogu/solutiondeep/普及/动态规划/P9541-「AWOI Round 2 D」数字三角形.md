# 题目信息

# 「AWOI Round 2 D」数字三角形

## 题目描述

Glad 发现了一个 $n$ 层数字三角形，他发现可以用魔法来操纵这个三角形！

他可以先消耗 $nk_1$ 点消耗值，让将三角形旋转 $k_1$ 次。其中“旋转”指绕三角形中心顺时针旋转 $120^\circ$。

然后，他可以不停地进行下面操作：

- 消耗 $1$ 点消耗值，选择一层，调换这一层任意两个数的位置。

现在，Glad 要从三角形的最后一层走到最顶层，起点可以为最后一层的任意一个数，行走的每一步只能走到与当前数相邻的数上，且每一行只能经过一个数。

Glad 想在经过数之和最大的前提下让消耗的消耗值最小，你可以帮帮他吗？

## 说明/提示

**【样例解释】**

初始三角形为：

```
    1
   2 3
  4 5 6
10 9 8 7
2 5 2 5 6
```


将其向右翻转 $2$ 次，消耗 $10$ 点调换值，此时三角形变为：

```
    6
   7 5
  6 8 2
 3 5 9 5
1 2 4 10 2
```

无须调换数字，沿着 $6,7,8,9,10$ 走，可以得到最大值 $40$，共耗费 $10$ 点调换值。

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | 数据范围 | 特殊性质 | 分值 |  
| :-----------: | :-----------: | :-----------: | :-----------: |  
| $\text{Subtask1}$ | $1\leqslant n\leqslant 10$ | AB | $10$ |  
| $\text{Subtask2}$ | $1\leqslant n \leqslant 10$ | A | $10$ |  
| $\text{Subtask3}$ | $1\leqslant n \leqslant 10$ | B | $10$ |  
| $\text{Subtask4}$ | $1\leqslant n \leqslant 10$ | 无 | $10$ | 
| $\text{Subtask5}$ | $1\leqslant n \leqslant 40$ | 无 | $20$ | 
| $\text{Subtask6}$ | $1\leqslant n\leqslant 10^3$ | 无 | $40$ |  

特殊性质 A：不需要调换数字就可以得到最优解。

特殊性质 B：不需要向右旋转就可以得到最优解。

对于 $100\%$ 的数据，保证：$1\leqslant n\leqslant 10^3$，$0\leqslant a_i\leqslant10^4$。

**【工作人员】**

| $\text{Idea}$ | $\text{Data}$ | $\text{Check}$ | $\text{Solution}$ |
| :----------: | :----------: | :----------: | :----------: |
|[S__X](/user/310466) |[S__X](/user/310466)|[I_am_AKed_by_NOI](/user/807853) | [I_am_AKed_by_NOI](/user/807853) |

## 样例 #1

### 输入

```
5
1
2 3
4 5 6
10 9 8 7
2 5 2 5 6```

### 输出

```
40 10```

# AI分析结果

### 综合分析与结论

本题的核心在于通过旋转和交换操作，找到一条从数字三角形底部到顶部的路径，使得路径上的数字和最大，并且消耗的魔法值最小。题解们主要围绕以下几个思路展开：

1. **旋转操作的处理**：由于旋转120度最多进行两次，因此题解们通常将问题分为三种情况：不旋转、旋转一次、旋转两次，分别处理。
2. **交换操作的最优化**：通过动态规划（DP）来找到每行的最大值，并计算最小交换次数。
3. **路径的最大和与最小消耗**：通过DP计算路径的最大和，并在最大和相同的情况下选择最小消耗。

### 所选题解

#### 1. 作者：Aesyl (5星)
- **关键亮点**：思路清晰，代码结构良好，详细分析了旋转和交换操作的影响，并通过DP实现了最优路径的计算。代码可读性强，且进行了优化。
- **核心实现思想**：通过DP计算每行的最大值，并在DP过程中记录最小消耗值。分别处理不旋转、旋转120度、旋转240度三种情况。
- **代码片段**：
  ```cpp
  void Dy_Pr(int i,int j,int i1,int j1,int i2,int j2,int line,int extra){
      if(dp[i1][j1]>dp[i2][j2]||(dp[i1][j1]==dp[i2][j2]&&cost[i1][j1]<cost[i2][j2])){
          cost[i][j]+=cost[i1][j1];
          dp[i][j]=dp[i1][j1];
      }else{
          cost[i][j]+=cost[i2][j2];
          dp[i][j]=dp[i2][j2];
      }
      dp[i][j]+=maxn[line];
      if(a[i][j]!=maxn[line]) cost[i][j]++;
      if(ans<dp[i][j]||(ans==dp[i][j]&&cost[i][j]+extra<tot)){
          ans=dp[i][j];
          tot=cost[i][j]+extra;
      }
  }
  ```

#### 2. 作者：S__X (4星)
- **关键亮点**：通过分析旋转操作的周期性，简化了问题的处理，并利用DP计算最小交换次数。代码简洁，逻辑清晰。
- **核心实现思想**：通过DP计算每行的最大值，并在DP过程中记录最小交换次数。分别处理不旋转、旋转一次、旋转两次三种情况。
- **代码片段**：
  ```cpp
  void S_max() {
      memset(Max, 0, sizeof(Max));
      MSUM = 0;
      for (int i = 1; i <= n; i++) {
          int Max2 = 0;
          for (int j = 1; j <= i; j++) {
              Max2 = max(Max2, A[i][j]);
          }
          Max[i][Max2] = 1;
          MSUM += Max2;
      }
  }
  ```

#### 3. 作者：Tiago (4星)
- **关键亮点**：通过DP计算每行的最大值，并在DP过程中记录最小消耗值。代码结构清晰，逻辑简单明了。
- **核心实现思想**：通过DP计算每行的最大值，并在DP过程中记录最小消耗值。分别处理不旋转、旋转一次、旋转两次三种情况。
- **代码片段**：
  ```cpp
  void work(int sum,int magic)
  {
      For(i,1,n)Max[i]=0;
      For(i,1,n)For(j,1,i)dp[i][j]=INF,Max[i]=max(Max[i],a[i][j]);
      For(i,1,n)sum+=Max[i];
      For(i,1,n)
          For(j,1,i)
              if(a[i][j]==Max[i])dp[i][j]=min(dp[i][j],min(dp[i-1][max(1,j-1)],dp[i-1][min(i-1,j)]));
                  else dp[i][j]=min(dp[i][j],min(dp[i-1][max(1,j-1)],dp[i-1][min(i-1,j)])+1);
      int Min=INF;
      For(i,1,n)Min=min(Min,dp[n][i]);
      magic+=Min;
      if(sum>Maxsum)Maxsum=sum,Minmagic=magic;
          elif(sum==Maxsum)Minmagic=min(Minmagic,magic);
  }
  ```

### 最优关键思路与技巧

1. **旋转操作的简化**：由于旋转120度最多进行两次，因此可以将问题分为三种情况分别处理，避免复杂的旋转操作。
2. **DP的最优化**：通过DP计算每行的最大值，并在DP过程中记录最小交换次数，确保路径的最大和与最小消耗。
3. **代码结构的优化**：通过函数封装和循环优化，提高代码的可读性和执行效率。

### 可拓展之处

1. **类似问题**：可以扩展到其他类型的路径问题，如矩阵中的最大路径和、图论中的最短路径等。
2. **算法套路**：DP+最优化问题的组合，可以应用于其他需要同时考虑多个目标的问题。

### 推荐题目

1. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 个人心得摘录

- **Aesyl**：通过分析旋转和交换操作的影响，简化了问题的处理，并通过DP实现了最优路径的计算。
- **S__X**：通过分析旋转操作的周期性，简化了问题的处理，并利用DP计算最小交换次数。
- **Tiago**：通过DP计算每行的最大值，并在DP过程中记录最小消耗值，代码结构清晰，逻辑简单明了。

---
处理用时：40.99秒
# 题目信息

# Colo.

## 题目描述

小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 $n$，宽度为 $1$ 的网格图上画画，从左往右第 $i$ 个方格被涂成了一种颜色 $a_i$。

你觉得他的随意涂鸦太难看了，想要保留恰好 $k$ 种颜色（**你不能保留没在网格图上出现的颜色**），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。

此外，小 Y 使用的第 $i$ 种颜色有一个价值 $b_i$，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。

你需要求出你能够获得的最大的价值是多少。

## 说明/提示

#### 【样例解释 #1】

对于第一组样例，我们可以选择 $1$ 号和 $3$ 号颜色保留，剩下的网格图即为 $[1,1,3]$，满足单调不下降这一个限制，获得的价值即为 $b_1+b_3=5+1=6$，可以证明这是最优的办法。

#### 【数据范围】

对于所有测试数据，满足 $1 \le n \le 500$，$1 \le k \le 500$，$1 \le a_i \le n$，$1 \le b_i \le 10^9$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n,k \le $ | 特殊性质 |
| :-----------: | :-----------: | :-----------: |
| $1 \sim 3$ | $10$ | 无 |
| $4 \sim 5$ | $100$ | 无 |
| $6 \sim 10$ | $500$ | 不同的颜色不超过 $10$ 种 |
| $11 \sim 15$ | $500$ | 每种颜色出现的次数不超过 $2$ 次 |
| $16 \sim 20$ | $500$ | 无 |


## 样例 #1

### 输入

```
5 2
1 2 1 3 2
5 3 1 100 100```

### 输出

```
6```

## 样例 #2

### 输入

```
10 3
1 3 4 2 9 3 4 2 5 1
1 5 2 3 9 8 1 2 3 10```

### 输出

```
-1```

# AI分析结果

### 综合分析

本题的核心是通过动态规划（DP）解决一个颜色选择问题，要求选择的颜色序列单调不下降，且最大化价值总和。大多数题解都采用了类似的DP思路，但在状态定义、转移方程和优化细节上有所不同。整体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，而另一些则存在冗余或不够优化的地方。

### 精选题解

#### 1. 作者：卷王 (赞：27)  
**星级：4.5**  
**关键亮点：**  
- 状态定义清晰：`dp[i][j]` 表示前 `i` 种颜色并选用第 `i` 种颜色，一共选择了 `j` 种颜色的方案数。
- 转移方程简洁：`dp[i][j] = max(dp[i][j], dp[m][j-1] + b[a[i]])`，其中 `m` 是前面选中的颜色下标。
- 使用 `l` 和 `r` 数组记录颜色的首次和最后一次出现位置，便于判断单调性。

**个人心得：**  
作者提到“问啥设啥”的DP设计原则，强调了状态定义与问题需求的直接对应关系，这种思维方式对初学者非常有帮助。

**核心代码：**
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= k; j++)
        for(int m = 0; m < i; m++)
            if(a[i] > a[m] && l[a[i]] > r[a[m]])
                dp[i][j] = max(dp[i][j], dp[m][j - 1] + b[a[i]]);
```

#### 2. 作者：zaochen (赞：14)  
**星级：4.0**  
**关键亮点：**  
- 状态定义：`dp[i][0/1][j]` 表示前 `i` 种颜色中选出 `j` 种颜色组成的序列，第二维表示第 `i` 种颜色选或不选。
- 转移方程分类清晰，分别处理选与不选的情况，逻辑严谨。
- 通过 `L[i]` 和 `R[i]` 记录颜色的首次和最后一次出现位置，简化了单调性判断。

**核心代码：**
```cpp
for(int j = 2; j <= k; j++)
    for(int i = 1; i <= n; i++)
        for(int c = 1; c < i; c++)
            if(l[c] && r[c] < l[i] && dp[c][1][j - 1] != -1)
                dp[i][1][j] = max(dp[i][1][j], dp[c][1][j - 1] + b[i]);
```

#### 3. 作者：TridentDeer (赞：12)  
**星级：4.0**  
**关键亮点：**  
- 状态定义：`f[i][j]` 表示当前选择颜色 `i`，选了 `j` 个颜色的最大价值。
- 转移方程：`f[i][j] = max(f[i][j], f[k][j-1] + b[i])`，其中 `k` 是符合条件的颜色。
- 通过预处理颜色之间的关系，简化了转移条件的判断。

**核心代码：**
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= k; j++)
        for(int k = 1; k < i; k++)
            if(a[i] > a[k] && r[a[k]] < l[a[i]])
                f[i][j] = max(f[i][j], f[k][j - 1] + b[a[i]]);
```

### 最优关键思路与技巧

1. **状态定义与转移方程**：大多数题解都采用了二维DP，状态定义为 `dp[i][j]`，表示前 `i` 种颜色中选 `j` 种的最大价值。转移方程通常为 `dp[i][j] = max(dp[i][j], dp[m][j-1] + b[i])`，其中 `m` 是符合条件的颜色。
2. **预处理颜色区间**：通过记录每种颜色的首次和最后一次出现位置，简化了单调性判断。
3. **优化空间与时间**：部分题解通过减少状态维度或优化循环顺序，进一步提升了效率。

### 可拓展之处

- **类似问题**：本题可以拓展到其他需要选择子序列并满足某种单调性的问题，如最长上升子序列（LIS）的变种。
- **算法套路**：DP+区间预处理的组合可以应用于多种区间选择问题，如区间调度、区间覆盖等。

### 推荐题目

1. **P1020 导弹拦截**：考察最长不上升子序列与贪心算法的结合。
2. **P1091 合唱队形**：考察双向最长上升子序列的DP应用。
3. **P1880 石子合并**：考察区间DP与环形问题的处理。

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中遇到的状态转移错误，强调了初始化和边界条件的重要性。
- **顿悟感想**：有作者提到“问啥设啥”的DP设计原则，强调了状态定义与问题需求的直接对应关系，这种思维方式对初学者非常有帮助。

### 通用建议

- **状态定义**：DP问题的关键在于状态定义，应尽量与问题需求直接对应。
- **转移方程**：转移方程应简洁明了，避免冗余条件。
- **预处理**：通过预处理简化条件判断，可以大幅提升代码的可读性和效率。

---
处理用时：41.45秒
# 题目信息

# 【模板】传递闭包

## 题目描述

给定一张点数为 $n$ 的有向图的邻接矩阵，图中不包含自环，求该有向图的传递闭包。

一张图的邻接矩阵定义为一个 $n\times n$ 的矩阵 $A=(a_{ij})_{n\times n}$，其中

$$ a_{ij}=\left\{
\begin{aligned}
1,i\ 到\ j\ 存在直接连边\\
0,i\ 到\ j\ 没有直接连边 \\
\end{aligned}
\right.
$$

一张图的传递闭包定义为一个 $n\times n$ 的矩阵 $B=(b_{ij})_{n\times n}$，其中

$$ b_{ij}=\left\{
\begin{aligned}
1,i\ 可以直接或间接到达\ j\\
0,i\ 无法直接或间接到达\ j\\
\end{aligned}
\right.
$$

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 100$，保证 $a_{ij}\in\{0,1\}$ 且 $a_{ii}=0$。

## 样例 #1

### 输入

```
4
0 0 0 1
1 0 0 0
0 0 0 1
0 1 0 0```

### 输出

```
1 1 0 1
1 1 0 1
1 1 0 1
1 1 0 1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕求有向图传递闭包展开，多数采用 Floyd 算法及其变种，也有使用 DFS、SPFA 等方法。Floyd 算法核心在于通过枚举中转点更新两点间的可达性，时间复杂度为 $O(n^3)$。部分题解对 Floyd 算法进行优化，如使用 bitset 或压位优化，可提高效率。不同题解在思路清晰度、代码可读性和优化程度上存在差异。

### 所选题解
- **作者：银杉水杉秃杉 (赞：44) - 4星**
    - **关键亮点**：提供多种解法，包括传统 Floyd 算法、bitset 优化和压位优化，并对不同解法进行分析和比较，思路清晰，代码实现完整。
    - **个人心得**：提到 Floyd 算法在数据范围增大时速度较慢，引导思考优化方法，如 bitset 优化和压位优化。
- **作者：ZBAA_MKC (赞：10) - 4星**
    - **关键亮点**：详细解释了 Floyd 算法在本题中的应用，将传统 Floyd 算法核心代码进行修改以适应求可达性的需求，思路清晰，代码可读性高。
    - **个人心得**：无。
- **作者：超级玛丽王子 (赞：0) - 4星**
    - **关键亮点**：对传递闭包的概念进行通俗解释，详细推导了 Floyd-Warshall 算法的转移方程，并使用位运算加速，代码实现规范。
    - **个人心得**：无。

### 重点代码
#### 传统 Floyd 算法（作者：ZBAA_MKC）
```cpp
#include <iostream>
#include <cstring>
using namespace std;

bool dist[105][105];
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            int x;
            cin >> x;
            if (x == 1)
            {
                dist[i][j] = 1;
            }
        }
    }

    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                dist[i][j] |= (dist[i][k] && dist[k][j]);
            }
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            cout << dist[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
} 
```
**核心实现思想**：通过三重循环枚举中转点 $k$ 和起点 $i$、终点 $j$，若 $i$ 能到 $k$ 且 $k$ 能到 $j$，则 $i$ 能到 $j$，使用逻辑或运算更新可达性。

#### bitset 优化（作者：银杉水杉秃杉）
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while (!isdigit(ch))
    {
        f = ch != '-';
        ch = getchar();
    }
    while (isdigit(ch))
    {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return f ? x : -x;
}
int n;
bitset<110> a[110];
int main()
{
    n = read();
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            a[i][j] = read();
    for (int j = 1; j <= n; j++)
        for (int i = 1; i <= n; i++)
            if (a[i][j])
                a[i] |= a[j];
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
            putchar(a[i][j] + '0'), putchar(' ');
        putchar('\n');
    }
    return 0;
}
```
**核心实现思想**：使用 bitset 存储每个点的可达状态，通过枚举 $j$ 和 $i$，若 $i$ 能到 $j$，则将 $j$ 的可达状态合并到 $i$ 中。

#### Floyd-Warshall 算法（作者：超级玛丽王子）
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() {
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    int x=0;
    while(ch>='0'&&ch<='9') x=(x*10)+(ch^48),ch=getchar();
    return x;
}
inline void write(int x) {
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline void wr(int x) {
    write(x);
    putchar(' ');
}
bool mp[105][105];
int n;
void Floyd_Warshall() {
    for(int k=1;k<=n;++k)
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j)
                mp[i][j]|=mp[i][k]&mp[k][j];
}
int main(void) {
    n=read();
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            mp[i][j]=read();
    Floyd_Warshall();
    for(int i=1;i<=n;++i) {
        for(int j=1;j<=n;++j)
            wr(mp[i][j]);
        putchar('\n');
    }
    return 0;
}
```
**核心实现思想**：通过三重循环枚举中转点 $k$ 和起点 $i$、终点 $j$，使用位运算更新两点间的可达性。

### 最优关键思路或技巧
- **Floyd 算法**：通过枚举中转点更新两点间的可达性，是解决传递闭包问题的经典算法。
- **bitset 优化**：使用 bitset 存储每个点的可达状态，利用位运算进行状态合并，可提高效率。
- **压位优化**：将连续 32 个点的状态压缩成一个 int 类型的数，节省空间和时间。

### 可拓展之处
同类型题或类似算法套路包括：
- 求无向图的传递闭包，可将有向图的邻接矩阵对称化后使用相同方法求解。
- 求图的强连通分量，可使用 Kosaraju 算法或 Tarjan 算法。
- 求图的最小环，可在 Floyd 算法的基础上进行扩展。

### 推荐题目
- P2888 [USACO07NOV]Sunscreen S
- P1119 灾后重建
- P1341 无序字母对

### 个人心得摘录与总结
- 银杉水杉秃杉：提到 Floyd 算法在数据范围增大时速度较慢，引导思考优化方法，如 bitset 优化和压位优化。
- CEFqwq：注意一个坑点，一个点到本身也需要经过其他点，否则也得是 0。

---
处理用时：45.87秒
# 题目信息

# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# AI分析结果

### 综合分析与结论
这些题解都围绕矩阵取数游戏这一问题展开，核心思路是利用区间动态规划求解。由于每行取数相互独立，故可对每行分别处理，通过定义不同的状态表示和转移方程来计算每行的最大得分，最后将所有行的得分相加得到总得分。

在算法要点上，各题解的状态定义和转移方程虽形式略有不同，但本质都是考虑从区间两端取数的情况，通过比较不同取法的得分来更新状态。

难点在于处理数据范围较大导致的数值溢出问题，多数题解采用 `__int128` 或高精度算法来解决。同时，动态规划的转移顺序也需要特别注意，部分题解从大区间向小区间转移，部分则相反。

### 所选题解
- **作者：Jack_Homes_Huang (5星)**
    - **关键亮点**：思路清晰，详细阐述了区间 DP 的状态定义、转移方程和终值计算，对高精度的处理也有说明，代码注释丰富，可读性高。
    - **个人心得**：提到将 `m` 写成 `n` 导致调试很久，提醒读者注意细节。
- **作者：zhylj (4星)**
    - **关键亮点**：转移方程独特，代码简洁，使用 `__int128` 避免高精度的复杂实现，运行速度较快。
- **作者：qhr2023 (4星)**
    - **关键亮点**：思路简洁明了，从小区间向大区间转移的方式易于理解，代码实现简洁高效。

### 重点代码及核心实现思想
#### Jack_Homes_Huang 的题解
```cpp
// 状态转移部分
for (int i = 1; i <= m; i++)
    for (int j = m; j >= i; j--) { 
        f[i][j] = max(f[i][j], f[i - 1][j] + base[m - j + i - 1] * ar[i - 1]); 
        f[i][j] = max(f[i][j], f[i][j + 1] + base[m - j + i - 1] * ar[j + 1]);
    }
// 计算每行最大得分
HP Max;
for (int i = 1; i <= m; i++)
    Max = max(Max, f[i][i] + base[m] * ar[i]);
ans = ans + Max; 
```
核心思想：用 `f[i][j]` 表示区间变为 `[i,j]` 时的最大分数，通过比较从 `[i-1,j]` 和 `[i,j+1]` 转移过来的得分更新状态，最后手动模拟长度为 1 的区间得到每行的最大得分。

#### zhylj 的题解
```cpp
__int128 solve(__int128 a[])
{
    memset(f,0,sizeof(f));
    for(int len=0;len<=m;++len)
        for(int i=1;i+len<=m;++i)
            f[i][i+len]=max(2*f[i+1][i+len]+2*a[i],2*f[i][i+len-1]+2*a[i+len]);
    return f[1][m];
}
```
核心思想：`f[i][j]` 表示取区间 `[i,j]` 的最大值，通过比较先取前面和先取后面两种情况的得分更新状态，最终返回 `f[1][m]` 作为该行的最大得分。

#### qhr2023 的题解
```cpp
for (int i=1; i<=n; ans+=f[1][m], memset(f, 0, sizeof f), ++i) 
    for (int len=1; len<=m; ++len) 
        for (int l=1, r=l+len-1; r<=m; ++l, ++r)
            f[l][r]=max(f[l+1][r]+a[i][l], f[l][r-1]+a[i][r])*2;
```
核心思想：从小区间向大区间转移，`f[l][r]` 表示取区间 `[l,r]` 的最大值，每次转移乘 2 解决答案乘 $2^i$ 的问题，最后将每行的 `f[1][m]` 相加得到总得分。

### 最优关键思路或技巧
- **独立处理每行**：由于每行取数互不影响，将问题分解为对每行分别进行区间动态规划，降低问题复杂度。
- **区间 DP**：利用区间动态规划的思想，通过定义状态和转移方程，考虑区间两端取数的情况，逐步计算出最大得分。
- **处理大数问题**：使用 `__int128` 或高精度算法解决数据范围大导致的数值溢出问题。

### 可拓展之处
同类型题或类似算法套路：
- 石子合并问题：同样是区间动态规划的经典应用，通过合并相邻的石子来计算最大或最小得分。
- 环形石子合并问题：在石子合并问题的基础上，将石子排成环形，需要额外处理环形结构的情况。
- 能量项链问题：与矩阵取数游戏类似，通过合并相邻的元素来计算最大能量。

### 推荐题目
- [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
- [P1063 [NOIP2006 提高组] 能量项链](https://www.luogu.com.cn/problem/P1063)
- [P4170 [CQOI2007] 涂色](https://www.luogu.com.cn/problem/P4170)

### 个人心得总结
- Jack_Homes_Huang 提到将 `m` 写成 `n` 导致调试很久，提醒我们在编程过程中要注意细节，避免因小错误导致调试困难。
- 各题解都强调了处理大数问题的重要性，如使用 `__int128` 或高精度算法，提醒我们在面对数据范围较大的问题时要考虑数值溢出的情况。

---
处理用时：39.95秒
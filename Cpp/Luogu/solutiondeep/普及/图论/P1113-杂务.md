# 题目信息

# 杂务

## 题目描述

John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。

当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。

John 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。

写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。


## 样例 #1

### 输入

```
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
```

### 输出

```
23
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算完成所有杂务的最短时间展开，多数题解采用了拓扑排序、动态规划、记忆化搜索等算法。拓扑排序能确保在计算某个任务时其所有前驱任务都已完成；动态规划通过状态转移方程来计算每个任务的最早完成时间；记忆化搜索则避免了重复计算，提高了效率。

### 高评分题解
1. **作者：Nishikino_Curtis（5星）**
    - **关键亮点**：思路简洁清晰，代码短小精悍，利用任务编号顺序和前驱任务时间的最大值进行状态转移，能快速得出结果。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,l,t,ans[10005],maxans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&i);
        scanf("%d",&l);
        int tmp=0;
        while(scanf("%d",&t)&&t)
            tmp=max(ans[t],tmp);
        ans[i]=tmp+l;
        maxans=max(ans[i],maxans);
    } 
    printf("%d\n",maxans);
    return 0;
 } 
```
    - **核心思想**：读入每个任务时，从其前驱任务中找出完成时间最晚的，将该时间加上当前任务所需时间，即为当前任务的最早完成时间，同时更新最终答案。

2. **作者：Keith_2006（5星）**
    - **关键亮点**：详细介绍了拓扑排序的实现方法，包括记忆化搜索和传统的BFS式拓扑排序，思路清晰，代码注释详细，还给出了相关拓展题目。
    - **核心代码（BFS式拓扑排序）**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cctype>
#include <vector>
#include <queue>

#define ll long long

using namespace std;

const int N=500005;

int ind[N],f[N],a[N];  //ind--入度   f--答案   a--时间
vector <int> edge[N];
queue <int> q;

int main() {
    int n=read();
    for (int i=1;i<=n;i++) {
        int x=read();
        a[i]=read();
        while (int y=read()) {
            if (!y) break;
            edge[y].push_back(x);
            ind[x]++;
        }
    }
    for (int i=1;i<=n;i++) {
        if (ind[i]==0) {
            q.push(i);
            f[i]=a[i];
        }
    };
    while (!q.empty()) {
        int rhs=q.front();
        q.pop();
        for (int i=0;i<edge[rhs].size();i++) {
            int u=edge[rhs][i];
            ind[u]--;
            if (ind[u]==0) q.push(u);
            f[u]=max(f[u],f[rhs]+a[u]);
        }
    }
    int ans=0;
    for (int i=1;i<=n;i++) {
        ans=max(ans,f[i]);
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心思想**：先统计每个节点的入度，将入度为0的节点加入队列。每次从队列中取出一个节点，更新其所有后继节点的入度和最早完成时间，若后继节点入度变为0，则将其加入队列，直到队列为空。

3. **作者：SW_Wind（4星）**
    - **关键亮点**：代码简洁，用`f[i]`表示完成第`i`件任务的最早时间，通过不断更新该数组并取最大值得到最终答案。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[10005], n, k, ans, t;
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        scanf("%d%d", &k, &t);
        while(scanf("%d", &k) && k)
            f[i] = max(f[k], f[i]);
        f[i] += t;
        ans = max(ans, f[i]);
    }
    printf("%d", ans);
}
```
    - **核心思想**：读入每个任务时，从其前驱任务中找出最早完成时间的最大值，加上当前任务所需时间得到当前任务的最早完成时间，同时更新最终答案。

### 最优关键思路与技巧
- **利用任务编号顺序**：由于杂务`k(k>1)`的准备工作只可能在杂务`1`至`k - 1`中，可直接按顺序处理任务，避免复杂的图遍历。
- **拓扑排序**：确保在计算某个任务时其所有前驱任务都已完成，可有效解决任务依赖问题。
- **记忆化搜索**：避免重复计算，提高算法效率。

### 可拓展之处
同类型题或类似算法套路：
- 其他DAG上的DP问题，如求最长路径、最大权值等。
- 任务调度问题，需要考虑任务的先后顺序和资源限制。

### 推荐题目
1. [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)
2. [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)
3. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

### 个人心得摘录与总结
- **作者：lxhhhh**：最初推出的DP方程代码因爆内存和逻辑错误无法AC，经过思考优化，去掉不必要的数组，并注意到最后完成的任务不一定是编号最大的，最终AC。总结：在实现算法时要考虑内存使用和逻辑正确性，避免陷入惯性思维。
- **作者：fltflt1**：使用拓扑排序WA后发现需记录做工作前的最小的最大时间，而不是经过最多准备工作的时间。总结：在解题时要准确理解题目要求，注意细节，避免因理解偏差导致错误。
- **作者：_无v名_**：意识到自己的代码能水过可能是数据太水，若遇到一直伸下去的树会爆。总结：要清楚自己代码的局限性，不能仅满足于通过测试数据，需不断优化算法以提高代码的健壮性。 

---
处理用时：43.42秒
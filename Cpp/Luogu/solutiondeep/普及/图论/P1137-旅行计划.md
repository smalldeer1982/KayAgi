# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果

### 综合分析与结论
本题主要是在有向无环图（DAG）中求解以每个城市为终点时最多能游览的城市数量。各题解主要围绕拓扑排序和动态规划（DP）展开，部分采用记忆化搜索。拓扑排序的性质保证了动态规划的无后效性，使得可以按拓扑序更新每个节点的最优值。

### 所选题解
- **作者：星星之火 (赞：103)，4星**
    - **关键亮点**：思路清晰，详细解释了拓扑排序与DP结合的原因，代码规范且注释清晰。
    - **个人心得**：强调了DP需要满足无后效性，拓扑序的性质保证了这一点，若不按拓扑序进行DP会破坏无后效性。
```cpp
// 拓扑排序函数
void topsort()
{
    queue <int> q;
    for (int i=1;i<=n;i++)
        if (ru[i]==0) {
            q.push(i);
            ts[++tot]=i;
        }
    while (!q.empty())
    {
        int u=q.front();q.pop();
        for (int i=head[u];i;i=edge[i].next)
        {
            int v=edge[i].to;
            ru[v]--;
            if (ru[v]==0) {
                q.push(v);ts[++tot]=v;
            }
        }
    }
}
// 主函数中的DP部分
for (int i=1;i<=n;i++) dp[i]=1;
for (int i=1;i<=n;i++)
{
    int u=ts[i];
    for (int j=head[u];j;j=edge[j].next)
    {
        int v=edge[j].to;
        dp[v]=max(dp[v],dp[u]+1);
    }
}
```
核心实现思想：先通过拓扑排序得到拓扑序列`ts`，然后按拓扑序遍历节点，对于每个节点的所有后继节点，更新其`dp`值为当前`dp`值和前驱节点`dp`值加1的较大值。

- **作者：_ZZH (赞：66)，4星**
    - **关键亮点**：代码简洁，在拓扑排序的同时进行DP，减少了额外的操作。
```cpp
while(!q.empty())
{
    int cnt=q.front();q.pop();
    for(int i=lin[cnt];i;i=e[i].next)
    {
        f[e[i].to]=max(f[e[i].to],f[cnt]+1);
        if(--in[e[i].to]==0)q.push(e[i].to);	
    }	
}
```
核心实现思想：在拓扑排序的过程中，对于队列中的每个节点，更新其所有后继节点的`f`值为当前`f`值和前驱节点`f`值加1的较大值，若后继节点入度变为0，则将其加入队列。

- **作者：归山_ (赞：39)，4星**
    - **关键亮点**：采用逆向思维，反向存图后使用记忆化搜索，思路独特。
```cpp
int dfs(int x){
    if(dp[x]!=-1) return dp[x];//如果来过就直接输出
    dp[x]=1;//更新该点,不要忘记了哦~
    for(int i=head[x];i;i=e[i].next){
        int y=e[i].to;
        dp[x]=max(dp[x],dfs(y)+1);//dp~
    }
    return dp[x];
}
```
核心实现思想：反向存图后，对于每个节点进行记忆化搜索，若该节点已经计算过则直接返回结果，否则递归计算其所有前驱节点的`dp`值，并更新当前节点的`dp`值为所有前驱节点`dp`值加1的最大值。

### 最优关键思路或技巧
- **拓扑排序与DP结合**：利用拓扑排序的性质保证DP的无后效性，按拓扑序更新节点的最优值。
- **记忆化搜索**：对于有重复计算的问题，使用记忆化搜索可以避免重复计算，提高效率。
- **反向存图**：当正向思考问题较复杂时，采用反向存图的方法可以简化问题。

### 可拓展之处
同类型题如求DAG中的最长路径、最短路径等问题，都可以使用拓扑排序和DP结合的方法解决。类似算法套路包括在图中寻找满足特定条件的路径或节点，通过拓扑排序确定节点的处理顺序，再结合动态规划或其他算法进行求解。

### 推荐题目
- [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)：考察拓扑排序和计数问题。
- [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)：本题原题，可进一步巩固知识点。
- [P2887 [USACO07NOV]Sunscreen G](https://www.luogu.com.cn/problem/P2887)：涉及贪心和拓扑排序的综合应用。

### 个人心得摘录与总结
- **星星之火**：强调了DP的无后效性，拓扑排序的性质保证了这一点，若不按拓扑序进行DP会破坏无后效性。
- **Space_Gold_Trash**：在使用BFS（SPFA）时，最初只从城市1出发导致全WA，后来发现出度为0的城市不止一座，应将所有入度为0的城市都加入队列。总结为做题时要仔细分析题目条件，不能想当然。 

---
处理用时：39.84秒
# 题目信息

# 买礼物

## 题目描述

又到了一年一度的明明生日了，明明想要买 $B$ 样东西，巧的是，这 $B$ 样东西价格都是 $A$ 元。

但是，商店老板说最近有促销活动，也就是：

如果你买了第 $I$ 样东西，再买第 $J$ 样，那么就可以只花 $K_{I,J}$ 元，更巧的是，$K_{I,J}$ 竟然等于 $K_{J,I}$。

现在明明想知道，他最少要花多少钱。

## 说明/提示

样例解释 $2$。

先买第 $2$ 样东西，花费 $3$ 元，接下来因为优惠，买 $1,3$ 样都只要 $2$ 元，共 $7$ 元。

（同时满足多个“优惠”的时候，聪明的明明当然不会选择用 $4$ 元买剩下那件，而选择用 $2$ 元。）

数据规模

对于 $30\%$ 的数据，$1\le B\le 10$。

对于 $100\%$ 的数据，$1\le B\le500,0\le A,K_{I,J}\le1000$。

2018.7.25新添数据一组

## 样例 #1

### 输入

```
1 1
0

```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3
0 2 4
2 0 2
4 2 0
```

### 输出

```
7```

# AI分析结果

### 综合分析与结论
这些题解均围绕最小生成树算法解决买礼物问题，核心思路是将物品看作节点，优惠价格和原价看作边权，构建图后求最小生成树。大部分题解使用Kruskal算法，少数使用Prim算法。关键在于设置虚拟节点（如0或B + 1），从该节点向各物品节点连边权为原价的边，以此表示直接购买物品的情况。

### 高评分题解
1. **作者：青丝、暮成雪（5星）**
    - **关键亮点**：思路清晰，详细阐述了建边和Kruskal算法的使用，代码注释丰富，对容易出错的地方有明确提示（如无优惠不建边）。
    - **个人心得**：“千万记得没有优惠是0，不建边（我在这儿WA了三次......）”，强调了处理无优惠情况的重要性。
    - **核心代码**：
```cpp
struct node
{
    int u,v,w;
}e[250000];
// 省略部分代码
void build(int x,int y,int z)
{
    k++;
    e[k].u=x;
    e[k].v=y;
    e[k].w=z;
}
void kruskal()
{
    int j=1;
    while(j<=k&&tot<=b)
    {
        if(find(e[j].u)!=find(e[j].v))
        {
            tot++;
            ans+=e[j].w;
            hb(e[j].u,e[j].v);
        }
        j++;
    }
}
// 省略部分代码
```
核心实现思想：定义边的结构体，通过`build`函数建边，使用`kruskal`函数求最小生成树，利用并查集判断节点是否连通。

2. **作者：加勒比·史努比（4星）**
    - **关键亮点**：明确指出设置序号为零的节点是精髓所在，对可能出现的疑问进行了解答，代码简洁明了。
    - **核心代码**：
```cpp
struct note{
    int u,r,w;
}d[N*N];
// 省略部分代码
for(int i=1;i<=b;i++){
    d[++cnt].u=0;
    d[cnt].r=i;
    d[cnt].w=a;
}
for(int i=1;i<=b;i++){
    for(int j=1;j<=b;j++){
        cin>>num;
        if(num!=0){
            d[++cnt].u=i;
            d[cnt].r=j;
            d[cnt].w=num;
        }
    }
}
sort(d+1,d+cnt+1,cmp);
for(int i=1;i<=cnt;i++){
    e=find(d[i].u);
    r=find(d[i].r);
    if(e!=r){
        ans+=d[i].w;
        f[r]=e;
    }
}
```
核心实现思想：定义边的结构体，从虚拟节点0向各节点连边权为原价的边，正常建边后排序，使用并查集判断节点是否连通，累加边权得到最小生成树的权值。

3. **作者：Wenxiang_MCL（4星）**
    - **关键亮点**：使用Prim算法解决问题，对初始条件的设置有详细说明，代码规范。
    - **核心代码**：
```cpp
for (int i = 1;i <= n;i ++)
    for (int j = 1;j <= n;j ++)
    {
        cin >> f[i][j];
        if(i == j) {
            f[i][j] = INF;
            continue;
        }
        if(!f[i][j]) f[i][j] = cost;
        f[j][i] = f[i][j];
    }
for(int i = 1;i <= n;i ++) dis[i] = INF;
dis[1] = 0;
for(int i = 1;i <= n;i ++)
{
    int cmin = INF,p;
    for(int j = 1;j <= n;j ++)
        if(dis[j] < cmin&&!s[j]){
            cmin = dis[j];
            p = j;
        }
    s[p] = true;
    for(int j = 1;j <= n;j ++){
        if(f[p][j] < dis[j]&&!s[j]) dis[j] = f[p][j];
    }
}
```
核心实现思想：初始化图的邻接矩阵，将无优惠的边权设为原价，使用Prim算法求最小生成树，不断更新距离数组。

### 最优关键思路或技巧
- **虚拟节点的设置**：通过设置虚拟节点（如0或B + 1），从该节点向各物品节点连边权为原价的边，将直接购买物品的情况融入最小生成树的构建中，简化了问题的处理。
- **并查集的运用**：在Kruskal算法中，使用并查集判断节点是否连通，避免形成环，确保构建的是最小生成树。

### 拓展思路
同类型题或类似算法套路：
- 其他涉及图的连通性和最小代价的问题，如城市间的道路建设、网络布线等，都可以考虑使用最小生成树算法解决。
- 若图的边权有动态变化，可使用可持久化并查集等数据结构进行优化。

### 推荐题目
1. [P3366 【模板】最小生成树](https://www.luogu.org/problemnew/show/P3366)：标准的最小生成树模板题，可用于巩固算法基础。
2. [P1991 无线通讯网](https://www.luogu.org/problemnew/show/P1991)：需要对最小生成树算法进行一定的变形和应用。
3. [P2872 [USACO07DEC]Building Roads S](https://www.luogu.org/problemnew/show/P2872)：结合了最小生成树和坐标计算，增加了问题的复杂度。

### 个人心得总结
- 青丝、暮成雪：在处理无优惠情况时要注意不建边，否则会导致错误。
- Hiraeth：在编写代码时要注意逻辑判断的正确性，如`!flag`的含义，避免因逻辑错误导致调试时间过长。
- chenlingxi：要注意数据的特殊性，当优惠价格大于原价时，应选择原价，可通过取最小值的方式处理。

---
处理用时：45.15秒
# 题目信息

# 口袋的天空

## 题目背景

小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。

有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。


## 题目描述

给你云朵的个数 $N$，再给你 $M$ 个关系，表示哪些云朵可以连在一起。

现在小杉要把所有云朵连成 $K$ 个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。


## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 100$，$1\le M \le 10^3$；

对于 $100\%$ 的数据，$1 \le N \le 10^3$，$1 \le M \le 10^4$，$1 \le K \le 10$，$1 \le X,Y \le N$，$0 \le L<10^4$。


## 样例 #1

### 输入

```
3 1 2
1 2 1
```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
本题主要考查最小生成树算法的应用，要求将 \(n\) 个点通过 \(m\) 条边连接成 \(k\) 个连通块并使边权和最小。大部分题解采用 Kruskal 算法，核心思路是先对边按权值从小到大排序，再用并查集判断边的两个端点是否连通，若不连通则加入该边，直到边数达到 \(n - k\) 条。部分题解使用 Prim 算法，先确定连通块数量，再在每个连通块上建最小生成树，最后根据情况删边。

### 所选题解
- **作者：yangrunze（5星）**
  - **关键亮点**：思路清晰，通过生动的例子引入最小生成树概念，详细解释了 Kruskal 算法的步骤和判断回路的方法，代码注释详细，易于理解。
  - **个人心得**：无

### 重点代码
```cpp
#include<iostream>
#include<algorithm>  //sort嘛......当然要开万能的algorithm
using namespace std;
struct woyaohongming{ //不要在意这个结构体的名字......它只是用来存储图的而已
    int s,e,w;    //s-start，e-end，代表边上的两个节点，w就是权值费用了
}a[200005];
int f[200005];  //并查集用的f数组
bool cmp(woyaohongming a,woyaohongming b){   //sort排序规则，按费用从低到高排序
    return a.w<b.w;
}
int find(int a){  //并查集的“找祖宗”函数，注意别忘路径压缩
    if(f[a]==a)
        return a;
    else return f[a]=find(f[a]);
}
int main(){
    int n,m,k;
    cin>>n>>m>>k;   //输入n、m、k，没啥好讲的
    for(int i=1;i<=n;i++)   
        f[i]=i;  //并查集数组初始化，每个节点的祖宗一开始是它自己
    for(int i=1;i<=m;i++)
        cin>>a[i].s>>a[i].e>>a[i].w;  //输入图的信息
    sort(a+1,a+1+m,cmp);   //快活的按权值排个序
    int cnt=0,sum=0;  //cnt是已经选中的边数，sum是最终要输出的最小权值
    for(int i=1;i<=m;i++){   //m条边，循环m次
        if(find(a[i].s)!=find(a[i].e)){ //如果俩节点的祖宗不相等（也就是不是回路），就可以加进去
            f[find(a[i].s)]=find(a[i].e); //把它俩合并成一个祖宗
            sum+=a[i].w;    //更新最小费用
            cnt++; //边数+1
        }
        if(cnt>=n-k)  //边数到达（n-k）条边，任务完成，break
            break;
    }
    if(cnt>=n-k)   //如果选了n-k条边，可以搞最小生成树
        cout<<sum;  //输出最小权值
    else cout<<"No Answer";  //要不然选了m条边还都搞不好，不能构成最小生成树
    return 0;  //终于完事了
} 
```
**核心实现思想**：
1. 定义结构体存储边的信息，使用并查集数组记录节点的祖宗节点。
2. 对边按权值从小到大排序。
3. 遍历每条边，若边的两个端点的祖宗节点不同，则将它们合并，更新最小费用和边数。
4. 当边数达到 \(n - k\) 条时，停止循环。
5. 根据边数判断是否能构成最小生成树，输出结果。

### 最优关键思路或技巧
- **算法选择**：Kruskal 算法适合稀疏图，时间复杂度为 \(O(mlogm)\)，本题数据范围适合使用该算法。
- **并查集优化**：使用路径压缩优化并查集的查找操作，提高效率。
- **贪心策略**：将边按权值从小到大排序，优先选择权值小的边，保证最终的边权和最小。

### 可拓展之处
同类型题或类似算法套路：
- **最小生成树变形**：如求次小生成树、限制条件下的最小生成树等。
- **连通性问题**：判断图的连通性、求连通分量个数等。
- **图的分割问题**：将图分割成多个连通块，使某些指标最优。

### 推荐题目
- [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
- [P1991 无线通讯网](https://www.luogu.com.cn/problem/P1991)
- [P2872 [USACO07DEC]Building Roads S](https://www.luogu.com.cn/problem/P2872)

### 个人心得摘录与总结
- **作者：Paolo_Banchero**：该作者提到很久没打 Kruskal 算法，自作聪明加了 `vis` 数组导致爆零，最后删去 `vis` 数组，只用并查集判断就 AC 了。总结为在使用熟悉算法时，不要随意添加不必要的元素，应遵循算法的标准实现。 

---
处理用时：39.25秒
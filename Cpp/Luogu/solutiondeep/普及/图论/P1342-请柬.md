# 题目信息

# 请柬

## 题目背景

在电视时代，没有多少人观看戏剧表演。 Malidinesia 古董喜剧演员意识到这一事实，他们想宣传剧院,尤其是古色古香的喜剧片。

## 题目描述

他们已经打印了请帖和所有必要的信息和计划。许多学生被雇来分发这些请柬。每个学生志愿者被指定一个确切的公共汽车站，他或她将留在那里一整天,邀请人们参与。

这里的公交系统是非常特殊的：共有 $n$ 个站点和 $m$ 个线路，所有的线路都是单向的，连接两个站点。公共汽车离开起始点，到达目的地之后又空车返回起始点。

学生每天早上从总部所在的 $1$ 号站点出发，乘公交车到一个预定的站点邀请乘客。每个站点都被安排了一名学生。在一天结束的时候，所有的学生都回到总部。现在需要知道的是，学生所需的公交费用的总和最小是多少。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq n, m \leq 10^6$。
- $1 \leq u, v \leq n$，$1 \leq w \leq 10^9$。
- 从 $1$ 出发可以到达所有的站点。

## 样例 #1

### 输入

```
4 6
1 2 10
2 1 60
1 3 20
3 4 10
2 4 5
4 1 50```

### 输出

```
210 ```

# AI分析结果

### 综合分析与结论
这些题解主要围绕求有向图中从 1 号点到各点以及各点到 1 号点的最短路之和展开。核心思路是分别构建正向图和反向图，然后在两个图上各跑一次最短路算法。使用的最短路算法主要有 SPFA 和 Dijkstra 及其优化版本。

### 所选题解
- **作者：笃行 (赞：30)，4 星**
    - **关键亮点**：使用 stl 优先队列优化的 SPFA 算法，思路清晰，代码结构完整，详细实现了建图和两次 SPFA 求解过程。
    - **个人心得**：无
- **作者：shadowice1984 (赞：22)，4 星**
    - **关键亮点**：采用 Dijkstra 裸题思路，使用堆优化，复杂度稳定，代码中对堆优化的注意事项有明确提示。
    - **个人心得**：无
- **作者：PrincessYR✨～ (赞：19)，4 星**
    - **关键亮点**：使用 vector 和 STL 实现 Dijkstra 加堆优化，对 Dijkstra 算法的思路和应用场景有详细解释，同时给出了错误思路的示例及分析。
    - **个人心得**：无

### 重点代码
#### 笃行的题解
```cpp
// 建图函数
void add(int x,int y,int v)
{
    d[++num1].to=y;
    d[num1].from=head1[x];
    head1[x]=num1;
    d[num1].dis=v;
    f[++num2].to=x;
    f[num2].from=head2[y];
    head2[y]=num2;
    f[num2].dis=v;
}
// SPFA 函数
void spfa1()
{
    deque <int> q;
    q.push_front(sx);
    fill(dis+2,dis+n+1,inf);
    while(!q.empty())
    {
        int x=q.front();
        q.pop_front();
        inq[x]=0;
        for(int k=head1[x];k;k=d[k].from)
        {
            int v=d[k].to,w=d[k].dis;
            if(w+dis[x]<dis[v])
            {
                dis[v]=w+dis[x];
                if(!inq[v])
                {
                    if(q.empty()||dis[v]<dis[q.front()]) q.push_front(v);
                    else q.push_back(v);
                    inq[v]=1;
                }
            }
        }
    }
    for(int i=2;i<=n;i++)
        ans+=dis[i];
}
```
**核心实现思想**：通过 `add` 函数同时构建正向图和反向图，`spfa1` 函数使用优先队列优化的 SPFA 算法求从 1 号点到其他点的最短路，并累加结果。

#### shadowice1984 的题解
```cpp
// 正向建图函数
void add(int u,int v,int val)
{
    edge[++cnt].v=v;
    edge[cnt].val=val;
    edge[cnt].next=alist[u];
    alist[u]=cnt;
    return;
}
// 反向建图函数
void kid(int v,int u,int val)
{
    edge2[++cnt2].v=v;
    edge2[cnt2].val=val;
    edge2[cnt2].next=alist2[u];
    alist2[u]=cnt2;
    return;
}
// Dijkstra 函数
while(!pq.empty())//dijkstra 模板
{
    now=pq.top();pq.pop();
    book[now.n]=true;
    int next=alist[now.n];
    while(next)
    {
        int v=edge[next].v;
        int val=edge[next].val;
        if(book[v]==false)
        {
            if(d[v].d>now.d+val)
            {
                d[v].d=now.d+val;
                pq.push(d[v]);
            }
        }
        next=edge[next].next;
    }
}
```
**核心实现思想**：`add` 和 `kid` 函数分别构建正向图和反向图，Dijkstra 函数使用堆优化的 Dijkstra 算法求最短路。

#### PrincessYR✨～ 的题解
```cpp
// 正向建图
g[a].push_back(edge{b,c});
// 反向建图
g2[b].push_back(edge{a,c});
// Dijkstra 函数
void dij(int x)
{
    fill(d,d+1+n,INF);
    d[x]=0;
    q.push(P(0,x));
    while(!q.empty())
    {
        P p=q.top();q.pop();
        int v=p.second;
        if(d[v]<p.first) continue;
        for(int i=0;i<g[v].size();i++)
        {
            edge e=g[v][i];
            if(d[e.to]>d[v]+e.cost)
            {
                d[e.to]=d[v]+e.cost;
                q.push(P(d[e.to],e.to));
            }
        }
    }
}
```
**核心实现思想**：使用 vector 存储图，`dij` 函数使用 Dijkstra 加堆优化算法求最短路。

### 最优关键思路或技巧
- **反向建图**：将求各点到 1 号点的最短路问题转化为在反向图上求 1 号点到各点的最短路，避免了对每个点都进行一次最短路算法，将时间复杂度从 $O(n^2logn)$ 优化到 $O(2nlogn)$。
- **堆优化**：在 Dijkstra 算法中使用堆优化（优先队列），可以快速找到当前距离源点最近的点，提高算法效率。
- **结构体封装**：将图的信息（如邻接表、距离数组、标记数组等）封装在结构体中，使代码结构更清晰，便于管理和复用。

### 可拓展之处
同类型题或类似算法套路：
- **多源最短路问题**：如果要求任意两点之间的最短路，可以使用 Floyd-Warshall 算法。
- **负权边图的最短路问题**：当图中存在负权边时，Dijkstra 算法不再适用，可以使用 Bellman-Ford 算法或 SPFA 算法（需注意 SPFA 可能会被卡）。
- **有向无环图（DAG）的最短路问题**：可以使用拓扑排序结合动态规划的方法求解，时间复杂度为 $O(V + E)$。

### 推荐题目
- [P1629 邮递员送信](https://www.luogu.com.cn/problem/P1629)：与本题类似，也是求从一个点到其他点以及其他点到该点的最短路之和。
- [P4779 单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：经典的单源最短路问题，可使用 Dijkstra 或 SPFA 算法求解。
- [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：同样是单源最短路问题，数据范围相对较小，适合初学者练习。

### 个人心得摘录与总结
- **作者：爷，无限霸气**：一开始使用暴力方法（对每个点都跑一次 Dijkstra）导致 TLE，后来发现可以通过建反图将时间复杂度优化到 $O(2nlogn)$，同时提醒注意数组大小和反图的构建，避免 MLE 和建错图。
- **作者：Uranus**：在代码中添加 `ios::sync_with_stdio(false);` 这一行神奇的代码，将原本 3 个 TLE 的情况优化为 AC，强调了读入/输出优化的重要性。
- **作者：chenzida**：原本使用 SPFA 算法被毒瘤数据卡 TLE，后来采用 SPFA 堆优化，这种优化在通常情况下是正优化，更不容易被卡，但在极端情况下时间复杂度可能会达到 $O(k\times m\times log(m))$。 

---
处理用时：54.57秒
# 题目信息

# 会议

## 题目描述

有一个村庄居住着 $n$ 个村民，有 $n-1$ 条路径使得这 $n$ 个村民的家联通，每条路径的长度都为 $1$。现在村长希望在某个村民家中召开一场会议，村长希望所有村民到会议地点的距离之和最小，那么村长应该要把会议地点设置在哪个村民的家中，并且这个距离总和最小是多少？若有多个节点都满足条件，则选择节点编号最小的那个点。

## 说明/提示

#### 数据范围

对于 $70\%$ 数据 $n \le 10^3$。

对于 $100\%$ 数据 $n \le 5 \times 10^4$。

## 样例 #1

### 输入

```
4
1 2 
2 3 
3 4 
```

### 输出

```
2 4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何在树上找到一个节点作为会议地点，使得所有节点到该节点的距离之和最小展开。多数题解采用树形 DP 或与树的重心相关的思路，通过深度优先搜索（DFS）来计算节点信息。

思路上，主要有两种：一是直接利用树形 DP 递推每个节点作为会议地点的距离和；二是先求出树的重心，再计算到重心的距离和。

算法要点在于通过 DFS 计算子树节点个数、节点深度等信息，进而利用递推公式计算每个节点的距离和。

解决难点在于推导递推公式，理解从一个节点转移到其子节点时距离和的变化规律。

### 所选题解
- **YoungNeal（5 星）**
    - **关键亮点**：思路清晰，详细推导了树形 DP 的转移方程，代码结构清晰，注释详细，时间复杂度为 $O(n)$。
    - **个人心得**：无
- **Y_B_Y（4 星）**
    - **关键亮点**：通过图文结合的方式，直观地解释了状态转移的过程，代码实现简洁易懂。
    - **个人心得**：无
- **Vocalise（4 星）**
    - **关键亮点**：对树形 DP 的思路和状态转移方程的推导过程有详细说明，复杂度分析清晰。
    - **个人心得**：无

### 重点代码
#### YoungNeal 的核心代码
```cpp
// 计算子树节点个数和节点深度
void dfs1(int now){
    size[now]=1;
    for(int i=head[now];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(d[to]) continue;
        d[to]=d[now]+1;
        dfs1(to);
        size[now]+=size[to];
    }
}

// 树形 DP 递推每个节点的距离和
void dfs(int now,int fa){
    f[now]=f[fa]+n-2*size[now];
    for(int i=head[now];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(to==fa) continue;
        dfs(to,now);
    }
}
```
**核心实现思想**：`dfs1` 函数用于计算以 1 为根的树中每个节点的子树节点个数和节点深度。`dfs` 函数根据转移方程 `f[now]=f[fa]+n-2*size[now]` 递推每个节点的距离和。

#### Y_B_Y 的核心代码
```cpp
// 计算子树节点个数和所有点到 1 的距离和
void dfs(int x,int st){
    for(int i=ft[x];i;i=nx[i]) 
    {
        if(to[i]==fa[x]) continue;
        ct[x]++;
        fa[to[i]]=x;
        dfs(to[i],st+1);
        ct[x]+=ct[to[i]];
    }
    d[1]+=st;
}

// 递推每个节点的距离和
void fd(int x){
    for(int i=ft[x];i;i=nx[i])
    {
        if(to[i]==fa[x]) continue;
        d[to[i]]=d[x]-ct[to[i]]-1+(n-ct[to[i]]-1);
        fd(to[i]);
    }
    return;
}
```
**核心实现思想**：`dfs` 函数计算每个节点的子树节点个数和所有点到 1 的距离和。`fd` 函数根据状态转移方程 `d[to[i]]=d[x]-ct[to[i]]-1+(n-ct[to[i]]-1)` 递推每个节点的距离和。

#### Vocalise 的核心代码
```cpp
// 计算子树节点个数和 f[1]
int DFs1(int v,int fa,int dep){
    size[v]=1;
    int deps=dep;
    for(register int i=in[v];i;i=e[i].nxt){
        int u=e[i].y;
        if(u==fa)continue;
        deps+=DFs1(u,v,dep+1);
        size[v]+=size[u];
    }
    return deps;
}

// 递推每个节点的距离和
void DFs2(int v,int fa){
    for(register int i=in[v];i;i=e[i].nxt){
        int u=e[i].y;
        if(u==fa)continue;
        f[u]=f[v]+(n-size[u])-size[u];
        DFs2(u,v);
    }
}
```
**核心实现思想**：`DFs1` 函数计算每个节点的子树节点个数和所有点到 1 的距离和（即 `f[1]`）。`DFs2` 函数根据转移方程 `f[u]=f[v]+(n-size[u])-size[u]` 递推每个节点的距离和。

### 最优关键思路或技巧
- **树形 DP**：通过定义状态和转移方程，利用 DFS 递推计算每个节点的距离和，时间复杂度为 $O(n)$。
- **邻接表存图**：使用邻接表存储树的结构，方便进行 DFS 遍历。

### 可拓展之处
同类型题或类似算法套路：
- 树的直径问题：求树中两个节点之间的最长路径。
- 树的重心问题：找到一个节点，使得删除该节点后，剩余子树的最大节点数最小。
- 树上路径问题：如求树上两点之间的最短路径、路径上的最大权值等。

### 推荐题目
- [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)
- [P2986 [USACO10MAR]Great Cow Gathering G](https://www.luogu.com.cn/problem/P2986)
- [P3174 [HAOI2009]毛毛虫](https://www.luogu.com.cn/problem/P3174)

### 个人心得摘录与总结
- **NGC224**：忘记树的重心模板，采用自己推导方程的方法解题，提醒注意存无向图时数组大小要翻倍，输出格式要正确，避免因粗心导致 RE 和 WA。
- **redegg**：通过观察节点转移时联通块的变化，推导出转移方程，强调了从根节点向子节点转移的思路。
- **2018_Danny**：从父节点与子节点的关系入手，推导关系式，在推导过程中发现某些数组可以消去，简化了计算。

---
处理用时：40.68秒
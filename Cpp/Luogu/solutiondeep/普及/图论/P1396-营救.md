# 题目信息

# 营救

## 题目背景

“咚咚咚……”“查水表！”原来是查水表来了，现在哪里找这么热心上门的查表员啊！小明感动得热泪盈眶，开起了门……

## 题目描述

妈妈下班回家，街坊邻居说小明被一群陌生人强行押上了警车！妈妈丰富的经验告诉她小明被带到了 $t$ 区，而自己在 $s$ 区。

该市有 $m$ 条大道连接 $n$ 个区，一条大道将两个区相连接，每个大道有一个拥挤度。小明的妈妈虽然很着急，但是不愿意拥挤的人潮冲乱了她优雅的步伐。所以请你帮她规划一条从 $s$ 至 $t$ 的路线，使得经过道路的拥挤度最大值最小。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 10$。
- 对于 $60\%$ 的数据，保证 $n\leq 100$。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m \leq 2 \times 10^4$，$w \leq 10^4$，$1 \leq s, t \leq n$。且从 $s$ 出发一定能到达 $t$ 区。

--- 

#### 样例输入输出 1 解释

小明的妈妈要从 $1$ 号点去 $3$ 号点，最优路线为 $1$->$2$->$3$。

## 样例 #1

### 输入

```
3 3 1 3
1 2 2
2 3 1
1 3 3```

### 输出

```
2
```

# AI分析结果

### 综合分析与结论
本题的核心是在图中找到从起点 \(s\) 到终点 \(t\) 的路径，使得经过道路的拥挤度最大值最小。题解主要围绕最小生成树（Kruskal 算法）、最短路算法（Dijkstra、SPFA 等）以及二分查找展开。

最小生成树类题解通过将边按权值从小到大排序，逐步连接节点，当 \(s\) 和 \(t\) 首次连通时，当前边的权值即为答案。最短路类题解则是对传统最短路算法的松弛操作进行修改，取当前路径最大拥挤度的最小值。二分查找类题解通过二分答案，结合 BFS 或并查集判断在当前最大拥挤度下 \(s\) 和 \(t\) 是否连通。

### 所选题解
- **作者：lzk5627 (赞：173)，5 星**
    - **关键亮点**：思路清晰，使用 Kruskal 最小生成树算法，代码简洁易懂，直接利用并查集判断 \(s\) 和 \(t\) 的连通性，避免了复杂的数据结构和算法。
    - **核心代码**：
```cpp
int find(int x) {
    if(a[x]==0) return x;
    a[x]=find(a[x]);
    return a[x];
}
int main() {
    n=read(); m=read(); s=read(); t=read();
    for(int i=1;i<=m;i++) {
        b[i].x=read(); b[i].y=read(); b[i].cost=read();
    }
    sort(b+1,b+m+1,com);
    for(int i=1;i<=m;i++) {
        int X=find(b[i].x),Y=find(b[i].y);
        if(X!=Y) a[X]=Y;
        if(find(s)==find(t)) {
            cout<<b[i].cost<<endl;
            return 0;
        }
    }
    return 0;
}
```
    - **核心思想**：先将边按权值从小到大排序，然后依次加入边，使用并查集判断 \(s\) 和 \(t\) 是否连通，首次连通时的边权即为答案。

- **作者：薄荷凉了夏 (赞：65)，4 星**
    - **关键亮点**：使用 Dijkstra + 堆优化算法，对传统 Dijkstra 的松弛操作进行修改，取当前路径最大拥挤度的最小值，思路新颖。
    - **核心代码**：
```cpp
void dijkstra() {
    memset(dis,0x3f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    dis[s]=0;
    q.push(make_pair(0,s));
    while(!q.empty()) {
        int x=q.top().second; q.pop();
        if(vis[x]) continue;
        vis[x]=1;
        for(int i=head[x];i;i=edge[i].next) {
            int k=max(dis[x],edge[i].w),r=edge[i].now;
            if(k<dis[r]) {
                dis[r]=k;
                q.push(make_pair(-dis[r],r));
            }
        }
    }
}
```
    - **核心思想**：使用优先队列优化 Dijkstra 算法，在松弛操作中取当前路径最大拥挤度的最小值，更新距离数组。

- **作者：Minakami_Yuki (赞：4)，4 星**
    - **关键亮点**：代码简洁，使用并查集维护图的连通性，将边从小到大排序，当 \(s\) 和 \(t\) 首次连通时输出当前边权，思路清晰。
    - **核心代码**：
```cpp
int find(int x) {return fa[x] = fa[x] == x ? x : find(fa[x]);}
int main() {
    int n = read(), m = read(), s = read(), t = read();
    for(register int i = 1; i <= n; i++) fa[i] = i;
    for(register int i = 1; i <= m; i++) {
        int x = read(), y = read(), z = read();
        e[i] = (edge) {x, y, z};
    }
    std::sort(e + 1, e + m + 1, cmp);
    for(register int i = 1; i <= m; i++) {
        int x = find(e[i].x), y = find(e[i].y);
        if(x != y) fa[x] = y;
        if(find(s) == find(t)) {
            printf("%d", e[i].z);
            return 0;
        }
    }
}
```
    - **核心思想**：先将边按权值从小到大排序，然后依次加入边，使用并查集判断 \(s\) 和 \(t\) 是否连通，首次连通时的边权即为答案。

### 最优关键思路或技巧
- **最小生成树思路**：将边按权值从小到大排序，使用并查集逐步连接节点，当 \(s\) 和 \(t\) 首次连通时，当前边的权值即为答案。这种思路简单直接，避免了复杂的路径搜索。
- **最短路算法松弛操作修改**：在传统最短路算法的松弛操作中，将求和改为取最大值，以满足题目要求。
- **二分查找结合判断**：二分答案，结合 BFS 或并查集判断在当前最大拥挤度下 \(s\) 和 \(t\) 是否连通，缩小答案范围。

### 可拓展之处
- **同类型题**：求图中两点间路径上的最大边权的最小值、最小瓶颈生成树等问题都可以使用类似的思路解决。
- **类似算法套路**：在处理图的连通性和路径问题时，最小生成树、最短路算法和二分查找是常用的方法，可以根据具体问题进行灵活运用。

### 推荐题目
- P1195 口袋的天空：求最小生成树的边权和，与本题的最小生成树思路类似。
- P1340 兽径管理：动态维护最小生成树，需要对最小生成树算法有更深入的理解。
- P2387 [NOI2014] 魔法森林：结合了最短路和最小生成树的思想，难度较高。

### 个人心得摘录与总结
- **作者：Armand**：提到更新路径长度时，将原来的求和改为取最大值，这是本题的关键修改点，需要注意细节。
- **作者：枉却东风**：使用伪 Bellman - ford 加小优化就通过了题目，说明在某些情况下，简单的算法也能解决问题，不要盲目追求复杂的算法。

---
处理用时：43.75秒
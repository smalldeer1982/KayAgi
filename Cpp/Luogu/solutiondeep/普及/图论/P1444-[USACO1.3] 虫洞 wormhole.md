# 题目信息

# [USACO1.3] 虫洞 wormhole

## 题目描述

Farmer John 周末进行高能物理实验的结果却适得其反，导致 $n$ 个虫洞出现在农场上，农场是一个二维平面，没有两个虫洞处于同一位置。

根据他的计算，FJ 知道他的虫洞两两配对，形成 $\dfrac{n}{2}$ 对配对。例如，如果 $A$ 和 $B$ 的虫洞连接成一对，进入虫洞 $A$ 的任何物体将从虫洞 $B$ 出去，方向不变；反之亦然。  

然而这可能发生相当令人不快的后果。例如，假设有两个成对的虫洞 $A(1,1)$ 和 $B(3,1)$，Bessie 从 $(2,1)$ 开始朝着 $x$ 正方向移动。Bessie 将进入虫洞 $B(3,1)$，从 $A(1,1)$ 出去，然后再次进入 $B$，困在一个无限循环中！

FJ 知道他的农场里每个虫洞的确切位置。他知道 Bessie 总是向 $x$ 正方向走进来，虽然他不记得贝茜的当前位置。  

请帮助 FJ 计算有多少种虫洞配对方案，使得存在一个位置，使得 Bessie 从该位置出发，会被困在一个无限循环中。

## 说明/提示

### 数据范围
对于 $100\%$ 的数据，$2\le n \le 12$，$0 \le x,y \le 10^9$。  
保证 $n$ 为偶数。

### 样例解释

将虫洞编号为 $1 \sim 4$，然后通过将 $1,2$ 和 $3,4$ 匹配，如果 Bessie 从 $(0,0)$ 到 $(1,0)$ 之间的任意位置出发，她会陷入无限循环中。

相似的，在相同的起始点，如果配对是 $1,3$ 和 $2,4$，贝茜也会陷入循环。（如果贝西从 $3$ 进去，$1$ 出来，她会走向 $2$ ，然后被传送到 $4$，最后又回到 $3$）

仅有 $1,4$ 和 $2,3$ 的配对允许贝茜从任何二维平面上的点向 $x$ 正方向走，而不出现无限循环。

题面翻译摘自 NOCOW

## 样例 #1

### 输入

```
4
0 0
1 0
1 1
0 1```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先枚举所有虫洞的配对方案，再对每种配对方案检查是否存在能让 Bessie 陷入无限循环的情况。具体实现上，不同题解在枚举配对和检查循环的方式上有差异，但整体框架相似。

在枚举配对方面，多数题解采用 DFS 算法，通过递归回溯的方式保证不重不漏地枚举所有配对情况。在检查循环时，常见的做法是模拟 Bessie 的行走过程，判断是否会回到起始点形成循环。

### 所选题解
- **作者：「QQ红包」 (赞：50)，4星**
    - **关键亮点**：思路清晰，代码简洁易懂。通过 DFS 枚举配对，再用递归函数检查是否存在循环。
    - **个人心得**：无

- **作者：Sino_E (赞：30)，4星**
    - **关键亮点**：将问题转化为图论问题，用有向边表示 Bessie 的行走方向，通过标记线段来判断循环，思路独特。
    - **个人心得**：写搜环时思考标记的方式，稍微改改差不多就 OK。

- **作者：2002chenhan (赞：4)，4星**
    - **关键亮点**：将边分为固定边和可变边分别处理，避免了直接修改原图带来的还原问题，优化了算法。
    - **个人心得**：通过分成两块来处理，分开了变与不变，使得原先的还原操作得以删去，真是绝妙的一招！

### 重点代码
#### 作者：「QQ红包」
```cpp
// 检查是否存在循环
int f(int num, int d, int begin, int p1) {
    if (num != 1 && d == begin && p1 == 1) return 1;
    if (p1 == 0) {
        if (a[d].y == a[d + 1].y) return f(num + 1, d + 1, begin, 1);
        else return 0;
    }
    if (p1 == 1) return f(num + 1, b[d], begin, 0);
}

bool check() {
    for (int j = 1; j <= n; j++)
        if (f(1, j, j, 1) == 1) return 1;
    return 0;
}

// 配对
void dfs(int x) {
    if (x == n + 1) {
        if (check() == 1) ans++;
        return;
    }
    if (b[x] == 0) {
        for (int i = x + 1; i <= n; i++)
            if (b[i] == 0) {
                b[i] = x;
                b[x] = i;
                dfs(x + 1);
                b[i] = 0;
                b[x] = 0;
            }
    }
    if (b[x] != 0) dfs(x + 1);
    return;
}
```
**核心实现思想**：`f` 函数模拟 Bessie 的行走过程，根据到达方式（走或传送）决定下一步操作。`check` 函数尝试从每个点出发，判断是否存在循环。`dfs` 函数通过递归回溯枚举所有配对方案。

#### 作者：Sino_E
```cpp
// 检查是否存在循环
bool cycle(int x) {
    while (to[x]) {
        if (tag[x]) return 1;
        tag[x] = 1;
        x = con[to[x]];
    }
    return 0;
}

// 配对
void dfs1(int k) {
    if (k > n) {
        bool ok = 0;
        for (int i = 1; i <= n && !ok; i++)
            memset(tag, 0, sizeof(tag)), ok |= cycle(i);
        ans += ok;
        return;
    }
    if (con[k]) dfs1(k + 1);
    else {
        for (int i = k + 1; i <= n; i++)
            if (!con[i]) {
                con[i] = k, con[k] = i;
                dfs1(k + 1);
                con[i] = con[k] = 0;
            }
    }
}
```
**核心实现思想**：`cycle` 函数通过标记线段判断是否存在循环。`dfs1` 函数枚举所有配对方案，对每种方案调用 `cycle` 函数检查是否存在循环。

#### 作者：2002chenhan
```cpp
// 检查是否存在循环
bool cycle(int x) {
    while (to[x]) {
        if (tag[x]) return 1;
        tag[x] = 1;
        x = con[to[x]];
    }
    return 0;
}

// 配对
void dfs1(int k) {
    if (k > n) {
        bool ok = 0;
        for (int i = 1; i <= n && !ok; i++)
            memset(tag, 0, sizeof(tag)), ok |= cycle(i);
        ans += ok;
        return;
    }
    if (con[k]) dfs1(k + 1);
    else {
        for (int i = k + 1; i <= n; i++)
            if (!con[i]) {
                con[i] = k, con[k] = i;
                dfs1(k + 1);
                con[i] = con[k] = 0;
            }
    }
}
```
**核心实现思想**：与 Sino_E 的思路类似，将边分为固定边 `to` 和可变边 `con` 分别处理，避免了还原操作。

### 最优关键思路或技巧
- **DFS 枚举配对**：通过递归回溯的方式，保证不重不漏地枚举所有虫洞的配对方案。
- **边的分类处理**：将边分为固定边和可变边分别处理，避免了直接修改原图带来的还原问题，优化了算法。
- **标记线段判断循环**：标记点到下一个点之间经过的线段，而不是标记点本身，更准确地判断是否存在循环。

### 可拓展之处
同类型题或类似算法套路：
- 排列组合问题：通过 DFS 枚举所有可能的排列组合，再对每种组合进行判断。
- 图论中的环检测问题：可以使用深度优先搜索（DFS）或广度优先搜索（BFS）来检测图中是否存在环。

### 推荐题目
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：通过 DFS 枚举所有可能的选数组合，判断组合的和是否为素数。
- [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)：通过 BFS 搜索从起点到终点的最短路径，判断是否能到达终点。
- [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)：通过 DFS 对图进行染色，判断是否能将图中的点分成两个独立的集合。

### 个人心得摘录与总结
- **Sino_E**：写搜环时思考标记的方式，稍微改改差不多就 OK。总结：在解决图论中的环检测问题时，合理选择标记方式可以简化问题。
- **2002chenhan**：通过分成两块来处理，分开了变与不变，使得原先的还原操作得以删去，真是绝妙的一招！总结：在处理复杂问题时，可以将问题分解为多个子问题，分别处理，避免不必要的操作。

---
处理用时：44.01秒
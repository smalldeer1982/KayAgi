# 题目信息

# 休息中的小呆

## 题目描述

当大家在考场中接受考验（折磨？）的时候，小呆正在悠闲（欠扁）地玩一个叫“最初梦想”的游戏。游戏描述的是一个叫 pass 的有志少年在不同的时空穿越对抗传说中的大魔王 chinesesonic 的故事。小呆发现这个游戏的故事流程设计得很复杂，它有着很多的分支剧情，但不同的分支剧情是可以同时进行的，因此游戏可以由剧情和剧情的结束点组成，某些剧情必须要在一些特定的剧情结束后才能继续发展。为了体验游戏的完整性，小呆决定要看到所有的分支剧情——完成所有的任务。但这样做会不会耽误小呆宝贵的睡觉时间呢？所以就请你来解决这个问题了。


## 说明/提示

### 数据范围及约定

对于全部数据，$0<n<100$，$0<m\le 120$，$0<i\le 100$，$0<j\le 100$，$0<k\le 1000$。

## 样例 #1

### 输入

```
4

5

1 2 2

2 3 2

3 5 3

1 4 3

4 5 3

```

### 输出

```
7

1 2 3 5

```

# AI分析结果

### 综合分析与结论
本题的核心是在有向图中求最长路，并输出最长路的长度和路径上的所有点。各题解的主要差异在于采用的算法不同，主要有 Floyd 算法和拓扑排序两种。Floyd 算法简单易实现，适合数据量较小的情况；拓扑排序则更适合有向无环图，时间复杂度更低。

### 所选题解
- **作者：冷眸丶 (赞：8)，4星**
  - **关键亮点**：思路清晰，详细解释了题意和拓扑排序的思路，代码结构清晰，注释详细。
  - **个人心得**：指出题目中一些未明确的地方，如求最长路、结点个数等，帮助读者更好地理解题意。
- **作者：天才颓废学家 (赞：5)，4星**
  - **关键亮点**：双语题解，对 Floyd 算法有详细的教学，适合新手，同时给出了多个相关题目。
  - **个人心得**：强调 Floyd 算法中要先枚举中间点，避免出错。
- **作者：songxiao (赞：8)，4星**
  - **关键亮点**：解释了结点个数要加 1 的原因，代码简洁明了。
  - **个人心得**：详细说明了剧情结束点和总节点数的关系，帮助读者理解。

### 重点代码及核心实现思想
#### 冷眸丶（拓扑排序）
```cpp
// 拓扑排序 
void topsort()
{
    for(int i=1; i<=n; i++)
        if(in[i]==0)
            q.push(i);
    while(!q.empty())
    {
        int p=q.top();
        q.pop();
        v.push_back(p);
        for(int i=head[p]; i!=0; i=edge[i].next)
        {
            int u=edge[i].to;
            in[u]--;
            if(in[u]==0)
                q1.push(u);
        }
        if(q.empty())
        {
            while(!q1.empty())
            {
                int p=q1.front();
                q1.pop();
                q.push(p);
            }
        }
    }
}
// 松弛操作 
void relax(int u,int v,int w)
{
    if(node[u]+w>node[v])
        node[v]=node[u]+w;
}
```
**核心思想**：先进行拓扑排序，得到结点的拓扑顺序，然后按照拓扑顺序对每个结点的出边进行松弛操作，更新最长路。

#### 天才颓废学家（Floyd 算法）
```cpp
// Floyd具体解释见上，这里不再赘述
for (int k = 1; k <= n; ++ k) //划重点
    for (int i = 1; i <= n; ++ i)
        if (i != k)
            for (int j = 1; j <= n; ++ j)
                if (i != j && k != j && f[i][k] && f[k][j])
                    f[i][j] = max(f[i][j], f[i][k] + f[k][j]);
```
**核心思想**：通过枚举中间点，更新任意两点之间的最长路。

#### songxiao（Floyd 算法）
```cpp
for(int k=1;k<=n+1;k++)
{
    for(int i=1;i<=n+1;i++)
    {
        for(int j=1;j<=n+1;j++)
        {
            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
        }
    }
}
```
**核心思想**：同样是 Floyd 算法，通过枚举中间点更新任意两点之间的最长路。

### 最优关键思路或技巧
- **结点个数处理**：注意题目中给出的 `n` 是剧情结束点的个数，实际结点个数要加 1，因为还有一个总的剧情开始点。
- **算法选择**：数据量较小时，Floyd 算法简单易实现；对于有向无环图，拓扑排序的时间复杂度更低。
- **路径输出**：判断一个点是否在最长路上，可以通过判断该点到起点的最长路加上该点到终点的最长路是否等于起点到终点的最长路。

### 拓展思路
同类型题或类似算法套路：
- 有向无环图的最短路径问题，可使用拓扑排序求解。
- 多源多汇的最短（长）路问题，可使用 Floyd 算法求解。
- 单源最短（长）路问题，可使用 Dijkstra 算法或 Bellman-Ford 算法求解。

### 推荐题目
- [P2491 [USACO08JAN]Cow Contest S](https://www.luogu.com.cn/problem/P2419)
- [P6175 无向图的最小环问题](https://www.luogu.com.cn/problem/P6175)
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)

### 个人心得摘录与总结
- **冷眸丶**：指出题目中一些未明确的地方，提醒读者在做题时要仔细分析题意。
- **天才颓废学家**：强调 Floyd 算法中要先枚举中间点，避免出错，同时给出了多个相关题目，帮助读者拓展练习。
- **songxiao**：详细说明了剧情结束点和总节点数的关系，帮助读者理解题目中的坑点。

---
处理用时：35.26秒
# 题目信息

# 最小花费

## 题目描述

在 $n$ 个人中，某些人的银行账号之间可以互相转账。这些人之间转账的手续费各不相同。给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 $A$ 最少需要多少钱使得转账后 $B$ 收到 $100$ 元。

## 说明/提示

$1\le n \le 2000,m\le 100000$。

## 样例 #1

### 输入

```
3 3                                     
1 2 1
2 3 2
1 3 3
1 3
```

### 输出

```
103.07153164```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何解决“最小花费”问题，核心是将问题转化为图论中的路径问题。大家普遍把人抽象成图的节点，转账手续费转化为边权，通过求最大汇率路径来得到最小花费。

算法方面，主要使用了Dijkstra和SPFA两种最短路算法，部分题解对Dijkstra进行了堆优化。难点在于如何正确处理边权的乘法关系，以及将问题转化为最长路问题。

### 高评分题解
1. **作者：_LanFeng_（5星）**
    - **关键亮点**：思路清晰，详细解释了Dijkstra+堆优化的实现过程，代码注释丰富，可读性强。
    - **核心代码**：
```cpp
inline void Dij()
{
    priority_queue<Node> q;
    Node temp;
    temp.Num = A;
    temp.dis = 1;
    q.push(temp);
    while (!q.empty())
    {
        int u = q.top().Num;
        q.pop();
        if (mark[u] == 1) continue;
        mark[u] = 1;
        for (int i = 0; i < G[u].size(); i++)
        {
            int v = G[u][i].Num;
            double l = G[u][i].dis;
            if (mark[v] == 0 && dis[v] < dis[u] * l)
            {
                dis[v] = dis[u] * l;
                temp.Num = v;
                temp.dis = dis[v];
                q.push(temp);
            }
        }
    }
}
```
    - **核心思想**：使用优先队列优化Dijkstra算法，通过不断更新最大汇率路径，最终得到从起点到终点的最大汇率。

2. **作者：The_Key（4星）**
    - **关键亮点**：使用SPFA算法解决问题，思路清晰，对边权的处理和汇率的更新解释明确。
    - **核心代码**：
```cpp
void spfa()
{
    int u, v;
    queue<int>q;
    q.push(A);
    dis[A] = 1;
    vis[A] = true;
    while (!q.empty())
    {
        u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = head[u]; i; i = edge[i].next)
        {
            v = edge[i].to;
            if (dis[v] < dis[u] * edge[i].val)
            {
                dis[v] = dis[u] * edge[i].val;
                if (!vis[v])
                {
                    q.push(v);
                    vis[v] = true;
                }
            }
        }
    }
}
```
    - **核心思想**：利用SPFA算法，不断更新起点到各点的最大汇率，直到队列为空。

3. **作者：zjy111（4星）**
    - **关键亮点**：详细指出了原Dijkstra代码的两个bug，并给出了修正后的代码，对读者有很大的帮助。
    - **核心代码**：
```cpp
void dijkstra()
{
    dis[a] = 1.0;
    q.push((node){1.0, a});
    while (!q.empty())
    {
        node tmp = q.top();
        q.pop();
        int x = tmp.pos;
        if (vis[x]) continue;
        vis[x] = 1;
        for (int i = head[x]; i; i = e[i].nxt)
        {
            int y = e[i].to;
            if (dis[y] < dis[x] * e[i].dis)
            {
                dis[y] = dis[x] * e[i].dis;
                if (!vis[y]) q.push((node){dis[y], y});
            }
        }
    }
}
```
    - **核心思想**：使用优先队列优化的Dijkstra算法，注意重载运算符以实现最长路的求解，同时进行双向建边。

### 最优关键思路或技巧
- **问题转化**：将最小花费问题转化为图论中的最长路问题，通过求最大汇率路径来得到最小花费。
- **边权处理**：将手续费转化为汇率（1 - 手续费率），并在路径计算中使用乘法。
- **算法优化**：使用堆优化的Dijkstra算法或SPFA算法，提高算法效率。

### 可拓展之处
同类型题可能会有不同的边权计算方式，或者在图中加入更多的限制条件，如时间限制、节点容量等。类似算法套路可以应用于物流运输、网络通信等领域的路径规划问题。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

### 个人心得摘录与总结
- **zjy111**：指出原Dijkstra代码的两个bug，一是求的是最长路而不是最短路，二是要双向建边，并且边的数组空间要开2倍。
- **___new2zy___**：强调初始化dis数组的重要性，因为要求最长路，不能附成inf，默认为0即可。
- **Hiraeth**：提醒双向边数组要开两倍，不然会出现RE的情况。

---
处理用时：37.73秒
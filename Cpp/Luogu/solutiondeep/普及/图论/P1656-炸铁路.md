# 题目信息

# 炸铁路

## 题目描述

A 国派出将军 uim，对 B 国进行战略性措施，以解救涂炭的生灵。

B 国有 $n$ 个城市，这些城市以铁路相连。任意两个城市都可以通过铁路直接或者间接到达。

uim 发现有些铁路被毁坏之后，某两个城市无法互相通过铁路到达。这样的铁路就被称为 key road。

uim 为了尽快使该国的物流系统瘫痪，希望炸毁铁路，以达到存在某两个城市无法互相通过铁路到达的效果。

然而，只有一发炮弹（A 国国会不给钱了）。所以，他能轰炸哪一条铁路呢？


## 样例 #1

### 输入

```
6 6
1 2
2 3
2 4
3 5
4 5
5 6```

### 输出

```
1 2
5 6```

# AI分析结果

### 综合分析与结论
本题的核心是求无向图中的割边（桥）。题解的思路主要分为两类：一类是暴力枚举，通过删边后判断图的连通性来确定割边；另一类是使用 Tarjan 算法，利用深度优先搜索和时间戳等信息高效地找出割边。

暴力枚举类的方法实现简单，但时间复杂度较高，通常为 $O(m^2)$，适用于数据范围较小的情况。Tarjan 算法的时间复杂度为 $O(n + m)$，效率更高，能处理更大规模的数据。

### 所选题解
- **作者：abruce（4星）**
    - **关键亮点**：详细解释了 Tarjan 算法的原理，通过图文结合的方式，清晰地展示了算法的执行过程，帮助读者更好地理解。代码注释详细，变量含义明确。
    - **个人心得**：无

### 重点代码
```cpp
void tarjan(int x) {
    int c=0,y;
    dfn[x]=low[x]=++id;
    for(register int i=1; i<=n; i++) {
        if(!maps[x][i])continue; // 首先要有边
        y=i; // 处理对象
        if(dfn[y]&&y!=f[x])low[x]=min(low[x],dfn[y]); // 如果是它爸爸，割边就没有用了，好好理解
        if(!dfn[y]) { // 如果找到祖先还有什么用呢
            f[y]=x; // 不是祖先就认爸爸
            tarjan(y); // dfs过程
            low[x]=min(low[x],low[y]); // 回溯时带着爸爸更新low
            if(low[y]>dfn[x])addEdge(x,y); // 是割边，就加入吧
        }
    }
}
```
**核心实现思想**：Tarjan 算法通过深度优先搜索遍历图，记录每个节点的时间戳 `dfn` 和能到达的最小时间戳 `low`。当 `low[y] > dfn[x]` 时，说明从节点 `y` 无法通过其他路径到达 `x` 或其祖先，那么边 `(x, y)` 就是割边。

### 最优关键思路或技巧
- **Tarjan 算法**：利用深度优先搜索和时间戳信息，在一次遍历中找出所有割边，时间复杂度低。
- **并查集**：用于判断图的连通性，通过合并和查找操作，快速判断两个节点是否在同一个连通分量中。

### 可拓展之处
- **同类型题**：求无向图的割点、强连通分量等问题。
- **类似算法套路**：在图的遍历中，利用时间戳和回溯信息来解决连通性相关问题。

### 推荐题目
- P3387 【模板】缩点
- P3388 【模板】割点（割顶）
- P2860 [USACO06JAN]冗余路径Redundant Paths

### 个人心得摘录与总结
- **浅色调**：开始以为统计入度为 0 的点就能解决问题，结果只对了 1 个点，仔细看题后发现是求有向图中的割边，应使用 Tarjan 算法或暴力搜索。总结：做题前要仔细审题，不能凭直觉解题。
- **I_promise**：使用 BFS 模拟每一条路都炸一次的情况，时间复杂度较高，但因数据范围小能 AC。总结：对于数据范围小的题目，可以尝试简单暴力的方法。

---
处理用时：23.71秒
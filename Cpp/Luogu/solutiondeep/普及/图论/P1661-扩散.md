# 题目信息

# 扩散

## 题目描述

一个点每过一个单位时间就会向四个方向扩散一个距离，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/cd4e53lw.png)

两个点 $a$ 、 $b$ 连通，记作 $e(a,b)$，当且仅当 $a,b$ 的扩散区域有公共部分。连通块的定义是块内的任意两个点 $u,v$ 都必定存在路径 $e(u,a_0),e(a_0,a_1),\cdots,e(a_k,v)$。给定平面上的 $n$ 个点，问最早什么时刻它们形成一个连通块。


## 说明/提示

### 数据范围及约定

对于 $20\%$ 的数据，满足 $1 \le N \le 5;1 \le X_i,Y_i \le 50$。

对于 $100\%$ 的数据，满足 $1 \le N \le 50$，$1 \le X_i,Y_i \le 10^9$。

## 样例 #1

### 输入

```
2

0 0

5 5```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
本题主要求解平面上多个点扩散形成一个连通块的最早时刻。各题解思路主要分为二分答案结合并查集、最小生成树、Floyd算法三类。

#### 思路对比
- **二分答案+并查集**：通过不断二分时间，用并查集判断在该时间内能否形成连通块。难点在于理解两点扩散时曼哈顿距离与时间的关系，即距离不超过时间的2倍时两点可连通。
- **最小生成树**：将两点扩散连接的时长作为边的权值，求最小生成树中最长的边，其长度即为形成连通块的时间。关键在于准确计算边的权值，即两点曼哈顿距离加1后除以2。
- **Floyd算法**：利用Floyd算法处理每两个点间的路径，找到最大的一条路径，该路径对应的时间即为答案。此方法需注意Floyd算法的变形，即更新距离时取最大值。

#### 复杂度分析
- **二分答案+并查集**：时间复杂度约为 $O(logM * n^2)$，其中 $M$ 为二分的范围。
- **最小生成树**：Kruskal算法时间复杂度为 $O(n^2 log(n^2))$，Prim算法时间复杂度为 $O(n^2)$。
- **Floyd算法**：时间复杂度为 $O(n^3)$。

### 高评分题解
1. **作者：封禁用户（赞：63），5星**
    - **关键亮点**：思路清晰，代码简洁易懂，详细解释了二分答案和并查集的使用，特别是对两点扩散时曼哈顿距离与时间关系的解释很清晰。
    - **核心代码**：
```cpp
while(l<=r){
    int mid=(l+r)>>1;
    for(register int i=0;i<n;i++){
        ints[i]=i;
    }
    for(register int i=0;i<n;i++){
        for(register int j=i+1;j<n;j++){
            int dis=abs(xs[i]-xs[j])+abs(ys[i]-ys[j]);
            if(dis<=mid*2){
                int aa=find(i),ab=find(j);
                if(aa!=ab)ints[aa]=ab;
            }
        }
    }
    int cnt=0;
    for(register int i=0;i<n;i++){
        if(ints[i]==i)cnt++;
    }
    if(cnt==1){
        ans=mid;
        r=mid-1;
    }
    else{
        l=mid+1;
    }
}
```
核心思想：二分时间，在每个时间点用并查集判断是否形成连通块，若形成则更新答案并缩小右边界，否则扩大左边界。

2. **作者：zzr8178541919（赞：40），4星**
    - **关键亮点**：另辟蹊径，不使用二分答案和并查集，通过分析两点扩散时间和Floyd算法直接求解，思路独特且代码简短。
    - **核心代码**：
```cpp
for(int k=1;k<=n;k++){
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++)
            place[i][j]=min(place[i][j],max(place[i][k],place[k][j]));
    }
}
int ans=0;
for(int i=1;i<=n-1;i++){
    for(int j=i+1;j<=n;j++){
        ans=max(ans,place[i][j]);
    }
}
printf("%d\n",(ans+1)/2);
```
核心思想：用Floyd算法处理每两个点间的路径，找到最大的一条路径，最后将该路径距离加1后除以2得到答案。

3. **作者：AntaresQAQ（赞：31），4星**
    - **关键亮点**：将问题转换为求最小生成树中最长的边，思路巧妙，代码实现规范。
    - **核心代码**：
```cpp
void kruskal(){
    int p=1;
    for(int i=1;i<=n;i++)
        father[i]=i;
    for(int i=1;i<=cnt;i++)
        if(Find(e[i].x)!=Find(e[i].y)){
            father[Find(e[i].x)]=Find(e[i].y);
            ans=max(e[i].val,ans);
            p++;
            if(p==n)
                return ;
        }
    return ;
}
```
核心思想：用Kruskal算法求最小生成树，在过程中记录最长的边，该边权值即为答案。

### 最优关键思路与技巧
- **思维方式**：将点的扩散问题转换为图论问题，如最小生成树、连通性判断等，简化问题求解。
- **算法优化**：二分答案可以快速缩小时间范围，减少不必要的计算；并查集能高效判断点的连通性。
- **代码实现技巧**：准确计算两点间的曼哈顿距离，并根据奇偶性处理扩散时间，即 `(dis + 1) / 2`。

### 拓展思路
同类型题可关注点的扩散、连通性判断、最小生成树等问题，如：
- 点在不同规则下的扩散（如不同方向、不同速度）。
- 动态加点或删点情况下的连通性维护。

### 推荐题目
1. **P1111 修复公路**：同样涉及最小生成树的应用，通过修复公路使所有村庄连通。
2. **P1991 无线通讯网**：在平面上有多个点，通过建立无线通讯连接形成连通块，与本题思路类似。
3. **P2820 局域网**：求解最小生成树，使网络连通且费用最小。

### 个人心得摘录与总结
- **zzr8178541919**：看到题解多为二分答案时感到惊讶，认为本题数据范围允许 $n^3$ 的暴力解法，强调仔细分析题目可找到更简单的方法。
- **s_ShotღMaki**：提到一点一点推会超时，应建图并利用最小生成树求解，同时强调了思路的重要性。
- **gb530**：在处理两点距离时，通过列举简单情况总结出 `(abs(a[i].x - a[j].x) + abs(a[i].y - a[j].y) + 1) / 2` 的公式，提醒遇到复杂情况要耐心分析。 

---
处理用时：46.05秒
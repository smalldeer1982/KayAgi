# 题目信息

# 部落卫队

## 题目描述

原始部落 byteland 中的居民们为了争夺有限的资源，经常发生冲突。几乎每个居民都有他的仇敌。部落酋长为了组织一支保卫部落的队伍，希望从部落的居民中选出最多的居民入伍，并保证队伍中任何 $2$ 个人都不是仇敌。

给定 byteland 部落中居民间的仇敌关系，编程计算组成部落卫队的最佳方案。若有多种方案可行，输出字典序最大的方案。

## 说明/提示

对于 $60\%$ 数据：$n \le 20$，$m \le 100$。

对于所有数据：$n \le 100,m \le 3000$。数据从所有合法数据从随机均匀取样。

## 样例 #1

### 输入

```
7  10
1  2
1  4
2  4
2  3
2  5
2  6
3  5
3  6
4  5
5  6```

### 输出

```
3
1 0 1 0 0 0 1
```

# AI分析结果

### 综合分析与结论
这些题解大多采用深度优先搜索（DFS）来解决部落卫队问题，核心思路是对每个人进行选或不选的尝试，并判断所选人员之间是否存在仇敌关系。部分题解添加了最优性剪枝，即如果把后面所有能选的人都选上，仍比当前最优解小，则提前终止搜索。还有题解尝试用随机化方法和位运算优化，但随机化方法有被卡掉的风险，位运算因数据范围问题可能无法完全适用。

### 所选题解
- **作者：litble（4星）**
    - **关键亮点**：思路清晰，代码可读性高，添加了最优性剪枝，还尝试了位运算优化（虽因数据范围问题不能完全使用，但提供了优化思路）。
    - **个人心得**：提到本来想用位运算优化，奈何 100 的数据范围存不下，体现了对不同优化方法的尝试和思考。
- **作者：百里狂生（4星）**
    - **关键亮点**：详细解释了图的储存（邻接矩阵）和搜索过程，通过模拟搜索过程帮助理解，代码注释详细，有助于新手学习。
    - **个人心得**：强调遇到与图紧密结合的题目时，应在草稿纸上推演搜索过程，体会深度搜索与回溯的原因及过程，才能写出 AC 程序。
- **作者：那一条变阻器（4星）**
    - **关键亮点**：思路简洁明了，代码实现清晰，添加了剪枝操作，且说明了代码中顺序不能交换的原因，考虑到了字典序优先的问题。
    - **个人心得**：吐槽多刷点搜索暴力题有好处，体现了对搜索算法的实践感悟。

### 重点代码
#### litble 的核心代码
```cpp
void dfs(int x,int num){//x:当前搜索的位置，num:已经选了几个人
    if(x==n+1){
        if(num>ans){//更新答案
            ans=num;
            for(int i=1;i<=n;i++)c[i]=b[i];
        }
        return;
    }
    if(num+n-x+1<ans)return;//小小的剪枝
    int bj=0;
    for(int i=1;i<=x-1;i++)//判断可不可以选
        if(b[i]&&lu[x][i]){bj=1;break;}
    if(!bj){b[x]=1;dfs(x+1,num+1);b[x]=0;}
    dfs(x+1,num);
}
```
**核心实现思想**：从第一个人开始搜索，对于当前人，先判断是否可以选（即与已选人员无仇敌关系），若可以选则尝试选和不选两种情况，同时添加了最优性剪枝，若剩余人员全选也无法超过当前最优解则提前终止搜索。

#### 百里狂生的核心代码
```cpp
bool place(int t)  ///判断是否可以把节点t加入团中 
{
    bool ok=true;
    for(int j=1;j<t;j++)  ///节点t与t-1个节点中被选中的节点是否相连 
    {
        if(x[j] && a[t][j]==1)  ///x[j]表示j是被选中的节点，a[t][j]==1 表示t和j是有仇敌关系   
        {
            ok=false;
            break;
        } 
    } 
    return ok;
} 

void dfs(int deep)
{
    if(deep>n)
    {///到达了叶子节点  
        for(int i=1;i<=n;i++)
            bestx[i]=x[i];
        bestn=cn;
        return;
    }
    if(place(deep))  ///满足条件则放入左子树，即把节点t放入团中  
    {
        x[deep]=1;
        cn++;
        dfs(deep+1);
        cn--;  ///回溯   
    } 
    if(cn+n-deep>bestn)  ///放入右子树 
    {
        x[deep]=0;
        dfs(deep+1);
    } 
}
```
**核心实现思想**：使用邻接矩阵存储图，`place` 函数用于判断当前节点是否可以加入团中（即与已选节点无仇敌关系）。在 `dfs` 函数中，若到达叶子节点则更新最优解，否则判断是否满足条件，满足则尝试选该节点，同时进行回溯，还会判断是否满足限界条件，满足则尝试不选该节点。

#### 那一条变阻器的核心代码
```cpp
void dfs(int step , int sum){	//当前到哪个人了和人数总和 
    if(step == n + 1){
        if(sum > ans){
            ans = sum;
            for(int i = 1; i <= n; i++) anses[i] = now[i];
        }
        return;
    }
    if(n + sum - step + 1 < ans) return;	//剪枝，若剩下的还没有答案多，放弃
    int f = 0;
    for(int i = 1; i <= step - 1; i++)
        if(vis[i] && dis[step][i]){	 
            f = 1; 
            break;
        }
    if(!f){
        vis[step] = 1;
        now[step] = 1;
        dfs(step + 1 , sum + 1);
        now[step] = 0;
        vis[step] = 0;
    }
    dfs(step + 1 , sum);	//！！！！这里不能交换与上面加入这个人的位置，因为在答案一致的情况下字典序优先 
}
```
**核心实现思想**：从第一个人开始搜索，对于当前人，先判断是否可以选（即与已选人员无仇敌关系），若可以选则尝试选和不选两种情况，同时添加了剪枝操作，若剩余人员全选也无法超过当前最优解则提前终止搜索，并且注意了代码顺序以保证字典序优先。

### 最优关键思路或技巧
- **深度优先搜索**：通过递归的方式对每个人进行选或不选的尝试，遍历所有可能的组合。
- **最优性剪枝**：在搜索过程中，若把后面所有能选的人都选上，仍比当前最优解小，则提前终止搜索，减少不必要的计算。
- **邻接矩阵**：使用二维数组存储居民之间的仇敌关系，方便判断两人是否为仇敌。

### 可拓展之处
同类型题如最大团问题，给定一个无向图，在顶点集合中选取几个顶点，使得这些顶点任意两个之间都有边相连，求最多可以选取的顶点个数。类似算法套路可用于解决其他组合优化问题，如子集选取问题，在满足一定条件下选取最优子集。

### 推荐题目
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：从若干个数中选取若干个数，使其和为素数，考察组合搜索。
- [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)：在电梯中通过按按钮到达指定楼层，考察广度优先搜索。
- [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)：在棋盘上放置皇后，使其互不攻击，考察回溯算法。

### 个人心得总结
- litble 尝试位运算优化但因数据范围受限，提醒我们在选择优化方法时要考虑数据范围。
- 百里狂生强调在处理图相关问题时，要在草稿纸上推演搜索过程，有助于理解和实现算法。
- 那一条变阻器提到多刷搜索暴力题有好处，鼓励我们通过实践提高搜索算法的应用能力。

---
处理用时：50.23秒
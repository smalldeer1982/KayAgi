# 题目信息

# 最长路

## 题目描述

设 $G$ 为有 $n$ 个顶点的带权有向无环图，$G$ 中各顶点的编号为 $1$ 到 $n$，请设计算法，计算图 $G$ 中 $1, n$ 间的最长路径。

## 说明/提示

**【数据规模与约定】**

- 对于 $20\%$的数据，$n \leq 100$，$m \leq 10^3$。
- 对于 $40\%$ 的数据，$n \leq 10^3$，$m \leq 10^{4}$。
- 对于 $100\%$ 的数据，$1 \leq n \leq 1500$，$0 \leq m \leq 5 \times 10^4$，$1 \leq u, v \leq n$，$-10^5 \leq w \leq 10^5$。

## 样例 #1

### 输入

```
2 1
1 2 1```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕有向无环图中计算 1 到 n 的最长路径展开，思路主要分为拓扑排序结合动态规划和修改最短路算法两种。拓扑排序结合动态规划利用图的拓扑顺序保证动态规划的无后效性，修改最短路算法则是将边权取负跑最短路或直接修改松弛条件求最长路。各题解在思路清晰度、代码可读性和优化程度上有所差异。

### 所选题解
- **作者：Mine_King (赞：151)，4星**
  - **关键亮点**：思路清晰，详细分析了拓扑排序中对其他入度为 0 的点的处理，代码实现简洁易懂。
  - **个人心得**：无

### 重点代码
```cpp
// 初始化
for(int i=2;i<=n;i++)
{
    v[i]=-1e9;
    if(!in[i]) q.push(i);
}
// 废弃其他的入度为0的点
while(!q.empty())
{
    int x=q.front();
    q.pop();
    for(int i=0;i<g[x].size();i++)
        if(!--in[g[x][i]]) q.push(g[x][i]);
}
// 从点1开始拓扑排序并更新最长路
q.push(1);
while(!q.empty())
{
    int x=q.front();
    q.pop();
    for(int i=0;i<g[x].size();i++)
    {
        if(v[g[x][i]]<v[x]+d[x][i]) v[g[x][i]]=v[x]+d[x][i]; // 松弛
        if(!--in[g[x][i]]) q.push(g[x][i]); // 如果入度为0就加入队列
    }
}
```
**核心实现思想**：先初始化最长路数组，将其他入度为 0 的点处理掉，避免影响结果。然后从点 1 开始进行拓扑排序，在拓扑排序过程中更新每个点的最长路，最后输出点 n 的最长路。

### 最优关键思路或技巧
- **拓扑排序结合动态规划**：利用拓扑排序的特性，保证在更新每个点的最长路时，其入边所连的点的最长路已经确定，满足动态规划的无后效性。
- **边权取负跑最短路**：将边权取负后跑最短路，最后取结果的相反数得到最长路，简化了算法实现。

### 可拓展之处
- **同类型题**：有向无环图中的其他路径问题，如最短路径、路径计数等。
- **类似算法套路**：对于有向无环图，可以考虑使用拓扑排序结合动态规划解决问题；对于路径问题，可以通过修改最短路算法来求解最长路。

### 推荐题目
- [P1113 杂务](https://www.luogu.com.cn/problem/P1113)
- [P1807 最长路](https://www.luogu.com.cn/problem/P1807)
- [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)

### 个人心得摘录与总结
- **作者：AutumnKite**：认为这题是很裸的“最长路”，用 SPFA 算法把松弛操作的符号改一下，极大值改成极小值就 AC 了，原本以为需要考虑很多东西，结果很简单。总结：对于一些看似复杂的问题，可能通过简单的算法修改就能解决。
- **作者：睿屿青衫**：提到建负边跑 SPFA 时，memset 要正的 0x7f，否则会 WA。总结：在使用 memset 初始化数组时，要注意其按字节初始化的特性，避免出现错误。

---
处理用时：24.75秒
# 题目信息

# [USACO3.2] 香甜的黄油 Sweet Butter

## 题目描述

Farmer John 发现了做出全威斯康辛州最甜的黄油的方法：糖。

把糖放在一片牧场上，他知道 $N$ 只奶牛会过来舔它，这样就能做出能卖好价钱的超甜黄油。当然，他将付出额外的费用在奶牛上。

Farmer John 很狡猾。像以前的 Pavlov，他知道他可以训练这些奶牛，让它们在听到铃声时去一个特定的牧场。他打算将糖放在那里然后下午发出铃声，以至他可以在晚上挤奶。

Farmer John 知道每只奶牛都在各自喜欢的牧场（一个牧场不一定只有一头牛）。给出各头牛在的牧场和牧场间的路线，找出使所有牛到达的路程和最短的牧场（他将把糖放在那）。

## 说明/提示

**数据范围**

对于所有数据，$1 \le N \le 500$，$2 \le P \le 800$，$1 \le A,B \le P$，$1 \le C \le 1450$，$1 \le D \le 255$。

---

**样例解释**

作图如下：

```cpp
          P2  
P1 @--1--@ C1
         |
         | 
       5  7  3
         |   
         |     C3
       C2 @--5--@
          P3    P4
```

把糖放在4号牧场最优。

## 样例 #1

### 输入

```
3 4 5
2
3
4
1 2 1
1 3 5
2 3 7
2 4 3
3 4 5```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
本题旨在找出一个牧场放置糖，使所有奶牛到达该牧场的路程和最短，核心在于求解最短路问题。各题解主要采用了 Dijkstra、SPFA、Floyd 三种最短路算法，其中使用 SPFA 算法的题解最多。

### 各算法要点及难点对比
- **Dijkstra 算法**
    - **要点**：每次从未确定最短路径的顶点中选择距离源点最近的顶点，然后以该顶点为中间点，更新其他顶点到源点的距离。
    - **难点**：时间复杂度较高，普通 Dijkstra 为 $O(n^2)$，需使用堆优化降低复杂度；不能处理负权边。
- **SPFA 算法**
    - **要点**：Bellman - Ford 算法的队列优化，通过队列存储待松弛的顶点，不断更新顶点的最短路径。
    - **难点**：最坏时间复杂度为 $O(VE)$，可能会被特殊数据卡，且需注意判断负环问题。
- **Floyd 算法**
    - **要点**：通过三重循环枚举中间点、起点和终点，更新任意两点间的最短路径。
    - **难点**：时间复杂度为 $O(n^3)$，对于大规模数据容易超时，需进行优化。

### 评分较高的题解
1. **作者：Obito（5 星）**
    - **关键亮点**：思路清晰，详细讲解了 Dijkstra 和 SPFA 算法，对 SPFA 算法的复杂度和优化原理进行了说明，并给出了完整代码。
    - **个人心得**：提到“SPFA 他死了，在非特殊情况下（有负权）建议用 Dijkstra”，提醒了不同算法的适用场景。
    - **核心代码**：
```cpp
// SPFA 核心代码
void spfa(int s){
    memset(p,0,sizeof(p));
    for(int i=1;i<=n;i++)d[i]=10000;
    d[s]=0;	q.push(s);p[s]=1;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        p[u]=0;
        for(int i=first[u];i;i=next[i]){
            int v=to[i];
            if(d[v]>d[u]+w[i]){
                d[v]=d[u]+w[i];
                if(!p[v]){
                    q.push(v);
                    p[v]=1;
                }			
            }	
        }
    }
}
```
2. **作者：Refined_heart（4 星）**
    - **关键亮点**：使用堆优化的 Dijkstra 算法，避免了普通 Dijkstra 可能的超时问题，代码结构清晰，注释详细。
    - **核心代码**：
```cpp
// 堆优化 Dijkstra 核心代码
void dijkstra(int s){
    for(int i=1;i<=p;++i)dis[i]=inf;
    memset(vis,0,sizeof(vis));
    dis[s]=0,q.push((node){0,s});
    while(!q.empty()){
        node tmp=q.top();
        q.pop();
        int x=tmp.pos;
        if(vis[x])continue;
        vis[x]=1;
        for(int i=head[x];i;i=e[i].next){
            int y=e[i].to;
            if(dis[y]>dis[x]+e[i].dis){
                dis[y]=dis[x]+e[i].dis;
                if(!vis[y])q.push((node){dis[y],y});
            }
        }
    }
}
```
3. **作者：shadowice1984（4 星）**
    - **关键亮点**：使用 Floyd 算法并进行优化，利用双向边的特点减少计算量，成功通过该题。
    - **核心代码**：
```cpp
// Floyd 优化核心代码
for(int k=0;k<p;k++){
    for(int i=0;i<p;i++){
        for(int j=0;j<i;j++){
            if(d[i][j]>d[i][k]+d[k][j]){
                d[i][j]=d[i][k]+d[k][j];
                d[j][i]=d[i][j];
            }
        }
    }
}
```

### 最优关键思路或技巧
- **算法选择**：根据数据规模和特点选择合适的最短路算法，如本题数据规模较大，使用堆优化的 Dijkstra 或 SPFA 更合适。
- **算法优化**：Floyd 算法可利用双向边的特性，只计算一半的图；Dijkstra 算法可使用堆优化降低时间复杂度。
- **数据结构**：使用邻接表或链式前向星存储图，可节省空间并提高遍历效率。

### 可拓展之处
- **同类型题**：其他涉及最短路问题的题目，如求单源最短路径、多源最短路径等。
- **类似算法套路**：可使用其他图算法，如 Bellman - Ford、A* 算法等求解最短路问题。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

### 个人心得总结
- **Obito**：提醒在非特殊情况（有负权）下，建议使用 Dijkstra 算法，避免使用可能被卡的 SPFA 算法。
- **BeyondStars**：强调使用 SPFA 算法时，要注意图为无向图，添加边时需添加双向边，且内存要开足够大，同时不能在 SPFA 循环里计算奶牛走的路径和。

---
处理用时：43.84秒
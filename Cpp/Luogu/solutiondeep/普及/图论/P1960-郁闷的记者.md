# 题目信息

# 郁闷的记者

## 题目描述

你是一个体育报社的记者，你接受到一个艰难的任务：有 $N$ 支足球队参加足球比赛，现在给你一些比赛的结果，需要你给出各支球队的排名，从 $1$ 到 $N$。

以下是给你的一些信息：

 1. 没有平局；
 2. 不同的球队排名不能相同；
 3. 对于所有满足 $1 \le a<b \le N$，第 $a$ 名的球队一定可以打败第 $b$ 名的球队。

给你部分比赛结果，要求给出排名，并且判断是否存在另一种排名方法满足给你的比赛结果。


## 说明/提示

【数据范围】

$30\%$ 的数据满足：$1 \le N \le7$，$1 \le M \le 15$

$60\%$的数据满足：$1 \le N \le 100$，$1 \le M \le 2000$

$100\%$ 的数据满足：$1 \le N \le 5000$，$1 \le M \le 100000$


本题已加入spj，如果输出的最后一行错误将会提示 `Your decide is wrong!`

如果存在多种排名情况，排名错误将会提示 `Wrong ranks!`

如果情况固定且您的答案错误将会提示 `In line X,Your ans is wrong:expected = X,found = Y`


## 样例 #1

### 输入

```
3
2
2 1
2 3```

### 输出

```
2
1
3
1
```

# AI分析结果

### 综合分析与结论
这些题解大多采用拓扑排序来解决球队排名问题，部分使用差分约束。拓扑排序的核心在于利用入度为 0 的节点不断扩展，确定节点顺序，同时判断是否存在多种排序方案。差分约束则通过建立有向边，跑最长路来排名。各题解在数据结构选择（邻接矩阵、链式前向星、邻接表等）和代码实现细节上有所不同，但整体思路一致。

### 所选题解
- **作者：Strong_Jelly (赞：20)，4星**
    - **关键亮点**：思路清晰，详细讲解了拓扑排序的原理，分别给出邻接矩阵和链式向前星两种实现方式，代码注释详细。
    - **个人心得**：无
- **作者：Lonely_NewYear (赞：4)，4星**
    - **关键亮点**：思路明确，对拓扑排序的实现过程和判断多种方案的方法解释清晰，代码结构清晰，复杂度分析准确。
    - **个人心得**：提醒注意有环的情况无法完成拓扑排序，可在函数结束时判断已排好的数是否为 n 来判断是否有环。
- **作者：gyh20 (赞：3)，4星**
    - **关键亮点**：使用优先队列保证字典序，对数据范围有考虑，代码实现简洁。
    - **个人心得**：无

### 重点代码
#### Strong_Jelly 邻接矩阵实现
```cpp
#include <bits/stdc++.h>
using namespace std;
stack < int > pru;
int n, m, x, y, in[100001], out[100001], t, f, ff[5001][5001];
int main()
{
    scanf("%d %d", &n, &m);
    for(register int i = 1; i <= m; ++i)
    {
        scanf("%d %d", &x, &y);
        ++in[y];
        ++out[x];
        ff[x][out[x]] = y;
    }
    for(register int i = 1; i <= n; ++i)
    {
        if(in[i] == 0)
        {
            pru.push(i);
            ++t;
        }
    }
    if(t > 1)
    {
        f = 1;
    }
    t = 0;
    while(!pru.empty())
    {
        int u = pru.top();
        pru.pop();
        printf("%d\n", u);
        t = 0;
        for(register int i = 1; i <= out[u]; ++i)
        {
            int k = ff[u][i];
            --in[k];
            if(in[k] == 0)
            {
                pru.push(k);
                ++t;
            }
        }
        if(t > 1)
        {
            f = 1;
        }
    }
    printf("%d", f);
    return 0;
}
```
**核心思想**：先读入比赛结果，统计每个节点的入度和出度，将入度为 0 的节点入栈。每次从栈中取出一个节点输出，更新其出边节点的入度，若入度变为 0 则入栈，同时判断是否存在多个入度为 0 的节点，若存在则有多种方案。

#### Lonely_NewYear 拓扑排序实现
```cpp
#include<cstdio>
#include<queue>
using namespace std;
struct edge
{
    int to,next;
}g[100001];
int head[5001],cnt,num[5001],n,m,ans[5001],tot;
bool flag;
queue<int> q;
void add(int u,int v)
{
    g[++cnt]=(edge){v,head[u]};
    head[u]=cnt;
}
void toposort()
{
    for(int i=1;i<=n;i++)
    {
        if(num[i]==0)
        {
            if(!q.empty())
            {
                flag=1;
            }
            q.push(i);
        }
    }
    while(!q.empty())
    {
        int u=q.front();
        ans[++tot]=u;
        q.pop();
        for(int i=head[u];i;i=g[i].next)
        {
            int v=g[i].to;
            num[v]--;
            if(num[v]==0)
            {
                if(!q.empty())
                {
                    flag=1;
                }
                q.push(v);
            }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        num[v]++;
        add(u,v);
    }
    toposort();
    for(int i=1;i<=n;i++)
    {
        printf("%d\n",ans[i]);
    }
    printf("%d",flag);
    return 0;
}
```
**核心思想**：用邻接表建图，统计入度。将入度为 0 的节点入队，若队列非空时还有入度为 0 的节点则有多种方案。每次从队列中取出一个节点，更新其出边节点的入度，入度为 0 则入队。

#### gyh20 优先队列实现
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
priority_queue <int> q;
struct edge{
    int to,next;
}e[500002];
int m,n,a,b,c,head[100002],rd[100002],ans[100002],p,cnt;bool k;
void bu(int x,int y){
    e[++cnt].next=head[x];
    e[cnt].to=y;
    head[x]=cnt;
    rd[y]++;
}
int main(){
    k=0;
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>a>>b;
        bu(a,b);
    }p=0;
    for(int i=1;i<=n;i++){
        if(rd[i]==0)q.push(-i),p++;
    }
    if(p>1)k=1;
    while(!q.empty()){
        c=-q.top();
        ans[++ans[0]]=c;
        q.pop();
        p=0;
        for(int i=head[c];i;i=e[i].next){
            rd[e[i].to]--;
            if(rd[e[i].to]==0)q.push(-e[i].to),p++;
        }
        if(p>1)k=1;
    }
    for(int i=1;i<=ans[0];i++)cout<<ans[i]<<"\n";cout<<k;
}
```
**核心思想**：用前向星建图，统计入度。将入度为 0 的节点以负数形式入优先队列，若一次性进入队列的节点数大于 1 则有多种方案。每次从队列中取出一个节点，更新其出边节点的入度，入度为 0 则入队。

### 最优关键思路或技巧
- **拓扑排序**：利用入度为 0 的节点不断扩展，确定节点顺序，是解决此类有先后顺序问题的常用方法。
- **判断多种方案**：在拓扑排序过程中，若某一时刻存在多个入度为 0 的节点，则存在多种排序方案。
- **数据结构选择**：根据数据范围选择合适的数据结构，如邻接矩阵、链式前向星、邻接表等。

### 拓展思路
同类型题可参考有先后顺序的任务安排、课程表等问题，类似算法套路可使用拓扑排序、差分约束等。

### 推荐题目
- P1113 杂务
- P2071 座位安排
- P3243 [HNOI2015]菜肴制作

---
处理用时：50.39秒
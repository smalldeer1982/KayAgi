# 题目信息

# 跑步

## 题目背景

跑步是一项有意思的运动，尤其是可以开发人的脑筋。常神牛很喜欢跑步。


## 题目描述


常神牛跑步的场地是一个多边形（边数 $\leq 20$，每个顶点用英文大写字母表示），并且在这个多边形内部，还会有一些小道，连接两个不相邻的顶点。所有的边长和小道都是双向通行的举例来说，下面一个图：

 ![](https://cdn.luogu.com.cn/upload/pic/1049.png)

假设常神牛从 $A$ 点跑到 $D$ 点，最短的路径是 $A-E-D$（长度为 $6$）。

现在告诉你多边形的边数 $n$，多边形每条边的长度，多边形内的连线数 $k$，每条连线的两个端点及长度，以及起始点和结束点，请你输出最短路径的长度。但是常神牛有点强迫症，如果两点之间有多条道路直接连接，他会选择最长的那条。

注意：输入数据不保证起点和终点不同，也不保证小道的起点和终点不同。在读入过程中，如果两点之间有多条小道，那么它们间的距离为这些小道的最大值。所以，如果读入一个小道起点和终点相同，那么这个点到它本身的距离不为 $0$。


## 说明/提示

对于 $20\%$ 的数据，$k=0$；

对于 $50\%$ 的数据，$k \leq 10$；

对于 $100\%$ 的数据，$1 \leq n \leq 20$，$0 \leq m \leq 50$，$k \leq 100$，所有路径长度均不大于 $1000$。

## 样例 #1

### 输入

```
5 2
6 4 5 4 2
A D 7
E B 8
A D```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
本题是一个图论的最短路问题，由于数据规模较小（边数 $\leq 20$，连线数 $\leq 100$），大部分题解采用了时间复杂度为 $O(n^3)$ 的 Floyd 算法，也有部分题解使用了 Dijkstra、SPFA 算法或搜索算法。各题解的主要难点在于处理重边（取重边中的最大值）以及字符顶点到数字顶点的转换。

### 所选题解
- **作者：Exber（4星）**
  - **关键亮点**：思路清晰，对 Floyd 算法有详细解释，代码注释丰富，对题目中的坑点有明确提示。
  - **个人心得**：作者提到在处理重边时卡了很久，提醒读者要注意题目中“如果两点之间有多条小道，那么它们间的距离为这些小道的最大值”这一条件。
```cpp
// 初始化距离数组
memset(d, 0x3f, sizeof(d));
// 读入多边形边的长度
for(int i=1;i<=n;i++)
{
    int t;
    scanf("%d",&t);
    if(d[i][i%n+1]!=d[104][104])// 处理重边
    {
        t=max(t,d[i][i%n+1]);
    }
    d[i][i%n+1]=t;
    d[i%n+1][i]=t;
}
// 读入多边形内连线的长度
for(int i=1;i<=k;i++)
{
    char s,e;
    int t;
    cin>>s>>e;
    scanf("%d",&t);
    s=s-'A'+1;// 字符转数字
    e=e-'A'+1;
    if(d[s][e]!=d[104][104])// 处理重边
    {
        t=max(t,d[s][e]);
    }
    d[s][e]=t;
    d[e][s]=t;
}
// Floyd 算法求最短路
for(int k=1;k<=n;k++)// 枚举中间点
{
    for(int i=1;i<=n;i++)// 枚举起点
    {
        for(int j=1;j<=n;j++)// 枚举终点
        {
            d[i][j]=min(d[i][j],d[i][k]+d[k][j]);// 更新
        }
    }
}
```
- **作者：伟大的王夫子（4星）**
  - **关键亮点**：思路清晰，对处理重边的特判有详细说明，代码简洁。
  - **个人心得**：强调了不能每次都取 max，因为一开始 $d$ 数组的值都很大，所以要进行特判。
```cpp
// 初始化距离数组
memset(d, 0x3f, sizeof d);
// 读入多边形边的长度
for (register int i = 1; i < n; ++i) {
    int x;
    cin >> x;
    d[i + 1][i] = d[i][i + 1] = x;
}
int x;
cin >> x;
d[n][1] = d[1][n] = x;
// 读入多边形内连线的长度
for (register int i = 1; i <= m; ++i) {
    char a, b;
    int x, y, z;
    cin >> a >> b >> z;
    x = a - 'A' + 1, y = b - 'A' + 1;// 字母转化数字 
    if (d[x][y] == 0x3f3f3f3f) d[y][x] = d[x][y] = z;
    else d[y][x] = d[x][y] = max(d[x][y], z);// 处理重边
}
// Floyd 算法求最短路
for (register int k = 1; k <= n; ++k)	
    for (register int i = 1; i <= n; ++i)
        for (register int j = 1; j <= n; ++j)
            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
```
- **作者：ShineEternal（4星）**
  - **关键亮点**：思路清晰，对注意事项有明确提示，代码规范。
  - **个人心得**：提醒读者 scanf 和 cin 最好不要一块用，最短路别忘了赋初值，字符转为数字下标要考虑清楚是从 0 还是 1 开始。
```cpp
// 初始化距离数组
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=n;j++)
    {
        a[i][j]=inf;
    }
}
// 读入多边形边的长度
for(int i=1;i<=n;i++)
{
    cin>>x;
    if(a[i][i%n+1]!=inf)
    {
        a[i][i%n+1]=a[i%n+1][i]=max(x,a[i%n+1][i]);
    }
    else
    {
        a[i][i%n+1]=a[i%n+1][i]=x;
    }
}
// 读入多边形内连线的长度
for(int i=1;i<=k;i++)
{
    int val;
    cin>>s>>e>>val;
    int x=s-'A'+1;
    int y=e-'A'+1;
    if(a[x][y]!=inf)
    {
        a[x][y]=a[y][x]=max(val,a[x][y]);
    }
    else
    {
        a[x][y]=a[y][x]=val;
    }
}
// Floyd 算法求最短路
for(int k=1;k<=n;k++)
{
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
        }
    }
} 
```

### 最优关键思路或技巧
- **Floyd 算法**：适合处理多源最短路问题，时间复杂度为 $O(n^3)$，通过枚举中间点来更新任意两点间的最短距离。
- **处理重边**：在读取边的信息时，若两点间已有边，取边权的最大值。
- **字符转数字**：将字符顶点减去 'A' 再加 1 转换为数字顶点，方便使用数组存储和处理。

### 可拓展之处
同类型题如其他图论的最短路问题，可使用不同的算法（如 Dijkstra、SPFA 等）来解决。类似算法套路包括处理重边、自环等特殊情况，以及字符与数字的转换。

### 推荐题目
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)

### 个人心得总结
- 仔细审题，注意题目中的特殊条件，如重边、自环等。
- 处理重边时要进行特判，不能直接取最大值。
- 注意输入输出方式的选择，避免 scanf 和 cin 混用。
- 最短路问题要记得给距离数组赋初值。
- 字符与数字的转换要考虑清楚起始下标。

---
处理用时：44.11秒
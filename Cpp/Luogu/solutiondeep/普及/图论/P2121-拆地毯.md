# 题目信息

# 拆地毯

## 题目背景

还记得 NOIP 2011 提高组 Day1 中的铺地毯吗？时光飞逝，光阴荏苒，三年过去了。组织者精心准备的颁奖典礼早已结束，留下的则是被人们踩过的地毯。请你来解决类似于铺地毯的另一个问题。


## 题目描述

会场上有 $n$ 个关键区域，不同的关键区域由 $m$ 条无向地毯彼此连接。每条地毯可由三个整数 $u$、$v$、$w$ 表示，其中 $u$ 和 $v$ 为地毯连接的两个关键区域编号，$w$ 为这条地毯的美丽度。

由于颁奖典礼已经结束，铺过的地毯不得不拆除。为了贯彻勤俭节约的原则，组织者被要求只能保留至多 $K$ 条地毯，且保留的地毯构成的图中，任意可互相到达的两点间只能有一种方式互相到达。换言之，组织者要求新图中不能有环。现在组织者求助你，想请你帮忙算出这至多 $K$ 条地毯的美丽度之和最大为多少。


## 说明/提示

选择第 $1$、$2$、$4$ 条地毯，美丽度之和为 $10 + 9 + 3 = 22$。

若选择第 $1$、$2$、$3$ 条地毯，虽然美丽度之和可以达到 $10 + 9 + 7 = 26$，但这将导致关键区域 $1$、$2$、$3$ 构成一个环，这是题目中不允许的。


$1\le n,m,k \le 10^5$。


## 样例 #1

### 输入

```
5 4 3
1 2 10
1 3 9
2 3 7
4 5 3```

### 输出

```
22```

# AI分析结果

### 综合分析与结论
这些题解思路基本一致，都是通过求最大生成树来解决问题。利用贪心思想，将边按美丽度从大到小排序，再结合并查集判断是否会形成环，选取前 $K$ 条边。各题解的差异主要体现在代码风格和实现细节上。

### 所选题解
- 作者：星爵 (赞：33)，4星
  - 关键亮点：思路简洁清晰，代码结构简单易懂，注释详细，适合初学者理解。

### 重点代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,k,f[100100],ans;
struct no
{
    int x,y,z;
}a[100100];
bool comp (const no & a,const no &b)
{
    return a.z>b.z;
}
int find(int x)
{
    if(f[x]!=x)
        f[x]=find(f[x]);
    return f[x];
}
void un(int x,int y)
{
    f[x]=y;
}
int main()
{
    freopen("carpet.in","r",stdin);
    freopen("carpet.out","w",stdout);
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++)
        scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);
    sort(a+1,a+m+1,comp);
    for(int i=1;i<=n;i++)//并查集，初始时每个祖先都是自己
        f[i]=i;
    for(int i=1,kk=0;i<=m&&kk<k;i++)
    {
        int l=find(a[i].x),r=find(a[i].y);
        if(l!=r)//不在同一集合就合并
        {
            un(l,r);
            kk++;//计数
            ans+=a[i].z;
        }
    }
    printf("%d",ans);
    return 0;
}
```
**核心实现思想**：
1. 定义结构体 `no` 存储边的信息，包含起点 `x`、终点 `y` 和美丽度 `z`。
2. 编写比较函数 `comp` 对边按美丽度从大到小排序。
3. 实现并查集的查找函数 `find` 和合并函数 `un`。
4. 读取输入，排序边，初始化并查集。
5. 遍历边，若边的两个端点不在同一集合，则合并集合，累加美丽度，直到选取 $K$ 条边。

### 最优关键思路或技巧
- **贪心策略**：将边按美丽度从大到小排序，优先选取美丽度大的边，保证最终结果的美丽度之和最大。
- **并查集**：用于判断边的两个端点是否在同一集合，避免形成环。

### 可拓展之处
同类型题或类似算法套路：
- 最小生成树问题，如求最小生成树的权值和。
- 带权图的连通性问题，可通过并查集和排序来解决。

### 推荐题目
- [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
- [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195)
- [P2820 局域网](https://www.luogu.com.cn/problem/P2820)

### 个人心得
作者：星爵提到“模拟赛上做的题，就排个序，然后做 $k$ 条边的最大生成树，然后就莫名其妙的 AC 了”，说明该题的核心思路较为直接，掌握最大生成树和并查集的方法后较易解决。 

---
处理用时：27.42秒
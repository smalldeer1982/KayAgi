# 题目信息

# 公路通行税

## 题目描述

在 PALMIA 国家内，有 $N$ 个城市由公路相连（每条公路恰好双向连接两个城市）。经由一条公路或多条公路，从任一城市出发可以到达其余各个城市。直到今年，公路上才要征收公路通行税。在每条公路的中间，有一征税员，从每一辆经由此路的车收取 1 PALMIA COIN（1PC）。

政府官员决定减少收税员而推行公路印花。如果一辆车欲进入一条公路，就必须将这张印花贴在窗上。

政府官员决定：一年的公路印花的价值相当于在两个最远城市之间进行 $100$ 次旅行所需的费用。两个城市之间的距离是从一个城市到达第二个城市所需经过的最少数目的公路数。

你的任务是编写一个程序计算出公路印花的价值。

## 样例 #1

### 输入

```
4 4
1 2
2 3
4 2
3 4
0 0```

### 输出

```
200```

# AI分析结果

### 综合分析与结论
本题的核心是在无向连通图中求任意两点最短路的最大值，再乘以 100。由于边权均为 1，大部分题解采用 BFS 算法，避免了复杂的最短路算法（如 Dijkstra、SPFA）带来的高时间复杂度。各题解思路相似，主要差异在于图的存储方式（链式前向星、邻接表）和代码实现细节。

### 所选题解
- **作者：Computer1828 (赞：5)  ★★★★**
    - **关键亮点**：思路清晰，详细对比了 SPFA、Dijkstra 和 BFS 三种算法，并解释了 BFS 正确的原因，代码注释丰富，可读性强。
    - **个人心得**：提到用 SPFA 会 TLE，提醒读者注意算法的选择。
- **作者：Ambition_ (赞：4)  ★★★★**
    - **关键亮点**：先介绍无向图直径的概念，再分析算法可行性，逻辑清晰。给出了 AC 代码及遇到的问题和解决方法，对读者有借鉴意义。
    - **个人心得**：遇到第四个测试点输出格式问题，尝试多种方法后发现添加特定输出可通过，反映出调试过程中的困难和解决思路。
- **作者：Natsume_Rin (赞：2)  ★★★★**
    - **关键亮点**：明确指出图和树求直径的区别，思路简洁，代码结构清晰。

### 重点代码
#### Computer1828 的核心代码
```cpp
inline void bfs(int s){
    queue<node> q;
    q.push((node){s,0});//初始状态 
    vis[s] = true; 
    while(!q.empty()){
        node fr = q.front();
        q.pop();
        int u = fr.tp,dis = fr.dis;
        ans = max(ans,dis);//在遍历每个点的时候更新答案 
        for(int i = hed[u];i;i = e[i].nxt){
            int v = e[i].to;
            if(vis[v]) continue;
            q.push((node){v,dis+1});
            vis[v] = true;
        }
    }
}
```
**核心实现思想**：以 `s` 为起点进行 BFS，用队列存储节点和距离，每次取出队首节点，更新答案并扩展未访问的邻接节点。

#### Ambition_ 的核心代码
```cpp
void bfs(int st)
{   
    queue<P>Q;
    memset(vis,1,sizeof vis);
    Q.push(P(0,st));
    vis[st]=0;
    while(!Q.empty())
    {
        P p=Q.front();
        Q.pop();
        int dis=p.fi;
        int now=p.se;
        d=max(d,dis);
        for(int i=0;i<(int)e[now].size();i++)
        {
            int u=e[now][i];
            if(!vis[u])continue;
            vis[u]=0;
            Q.push(P(dis+1,u));
        }
    }
}
```
**核心实现思想**：同样是 BFS，用 `pair` 存储节点和距离，每次取出队首元素，更新最大距离并扩展邻接节点。

#### Natsume_Rin 的核心代码
```cpp
inline void bfs(int sx){
    memset(vis,0,sizeof vis);
    hd=tl=1;
    q[1]=sx;
    ste[1]=0;
    vis[sx]=1;
    while(hd<=tl){
        s=q[hd];
        step=ste[hd++];
        Ans=max(Ans,step);
        siz=G[s].size();
        for(RI i=0;i<siz;++i){
            ne=G[s][i];
            if(vis[ne]==1) continue;
            vis[ne]=1;
            ++tl;
            q[tl]=ne;
            ste[tl]=step+1;
        }
    }
    return ;
}
```
**核心实现思想**：用数组模拟队列进行 BFS，每次取出队首节点，更新答案并扩展邻接节点。

### 最优关键思路或技巧
- **利用边权为 1 的特性**：采用 BFS 算法，避免复杂的最短路算法，因为 BFS 第一次搜到的节点距离就是最短距离。
- **多组数据处理**：注意每次处理新数据时，要清空图的存储结构和相关变量。

### 可拓展之处
同类型题：在无权图或边权相同的图中求最短路、最长路、图的直径等问题。类似算法套路：对于边权相同的图，优先考虑 BFS 算法；对于有权图，根据图的特点选择合适的最短路算法（如 Dijkstra、SPFA、Floyd）。

### 推荐题目
- P1144 最短路计数
- P1629 邮递员送信
- P3371 单源最短路径（弱化版）

### 个人心得摘录与总结
- **Computer1828**：提醒用 SPFA 可能会 TLE，要根据题目特点选择合适的算法。
- **Ambition_**：遇到测试点输出格式问题，尝试多种方法后找到解决办法，强调调试过程中要仔细检查输出。 

---
处理用时：36.58秒
# 题目信息

# [NOIP 2014 提高组] 寻找道路

## 题目背景

NOIP2014 提高组 D2T2

## 题目描述

在有向图 $G$ 中，每条边的长度均为 $1$，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件：

1. 路径上的所有点的出边所指向的点都直接或间接与终点连通。
2. 在满足条件 $1$ 的情况下使路径最短。

注意：图 $G$ 中可能存在重边和自环，题目保证终点没有出边。

请你输出符合条件的路径的长度。

## 说明/提示

**样例 1 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/2p3mke49.png) 

如上图所示，箭头表示有向道路，圆点表示城市。起点 $1$ 与终点 $3$ 不连通，所以满足题目描述的路径不存在，故输出 $-1$。

**样例 2 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/tm2e1lqq.png)
如上图所示，满足条件的路径为 $1\to 3\to 4\to 5$。注意点 $2$ 不能在答案路径中，因为点 $2$ 连了一条边到点 $6$，而点 $6$ 不与终点 $5$ 连通。

**数据范围及约定**

- 对于 $30\%$ 的数据，$0<n\le10$，$0<m\le 20$。
- 对于 $60\%$ 的数据，$0<n\le100$，$0<m\le 2000$。
- 对于 $100\%$ 的数据，$0<n\le 10^4$，$0<m\le 2\times 10^5$，$0<x,y,s,t\le n,x,s\ne t$。

## 样例 #1

### 输入

```
3 2
1 2
2 1
1 3```

### 输出

```
-1```

## 样例 #2

### 输入

```
6 6
1 2
1 3
2 6
2 5  
4 5
3 4
1 5```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先找出满足“出边所指向的点都直接或间接与终点连通”的点，再在这些点构成的图中求最短路。大部分题解采用建反图的方法来找出与终点连通的点，然后通过遍历判断每个点是否满足条件，最后使用 BFS 求最短路。各题解在具体实现细节上有所不同，但时间复杂度大多为 $O(n + m)$。

### 所选题解
- **作者：WsW_（4星）**
    - **关键亮点**：思路清晰，先预处理出满足条件的点，再进行 BFS 最短路求解。代码实现简洁，通过 DFS 遍历反图标记满足条件的点，减少不必要的计算。
    - **核心代码**：
```cpp
void col(int p){
    if(vis[p])return;
    vis[p]=1;
    for(int i=0;i<fedg[p].size();i++){
        int to=fedg[p][i];
        out[to]--;
        if(!out[to])f[to]=1;
        col(to);
    }
}
```
    - **核心思想**：通过 DFS 遍历反图，每遍历到一个点就减少其入度，当入度为 0 时，说明该点的出边所指向的点都直接或间接与终点连通。

- **作者：ethanhyz（4星）**
    - **关键亮点**：思路详细，对每个步骤的解释清晰易懂。代码结构清晰，通过两次 BFS 分别找出与终点连通的点和满足条件的点，最后再进行一次 BFS 求最短路。
    - **核心代码**：
```cpp
// 以终点为起点，反向边，BFS
q.push(t);
f[t]=1;
while(!q.empty())
{
    node=q.front();
    q.pop();
    for(int i=0;i<E[node].size();i++)
        if(!f[E[node][i]])
        {
            q.push(E[node][i]);
            f[E[node][i]]=1;
        }
}
```
    - **核心思想**：通过 BFS 遍历反图，标记所有与终点连通的点，方便后续判断每个点是否满足条件。

- **作者：CaiZi（4星）**
    - **关键亮点**：思路明确，先建反图找出与终点连通的点，再判断每个点是否满足条件，最后建一张新图跑 BFS 求最短路。代码实现简洁，逻辑清晰。
    - **核心代码**：
```cpp
inline void dfs(int i){
    for(int j:g[i]){
        if(!x[j]){
            x[j]=true;
            dfs(j);
        }
    }
}
```
    - **核心思想**：使用记忆化 DFS 遍历反图，标记所有与终点连通的点，为后续判断和建图做准备。

### 最优关键思路或技巧
- **建反图**：通过建反图，从终点开始遍历，可以方便地找出所有直接或间接与终点连通的点，避免了从每个点出发进行 DFS 的高时间复杂度。
- **标记法**：使用标记数组记录每个点是否与终点连通以及是否满足条件，方便后续筛选和判断。
- **BFS 求最短路**：在权值为 1 的图中，BFS 可以高效地求出最短路。

### 可拓展之处
同类型题或类似算法套路：
- **连通性问题**：可以通过建反图或并查集等方法解决。
- **最短路问题**：对于不同权值的图，可以使用 Dijkstra、SPFA 等算法。

### 推荐题目
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
- [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
- [P1629 邮递员送信](https://www.luogu.com.cn/problem/P1629)

### 个人心得
题解中未包含个人心得。

---
处理用时：28.24秒
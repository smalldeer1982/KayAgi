# 题目信息

# Mzc和体委的争夺战

## 题目背景

mzc 与 djn 第四弹。


## 题目描述

mzc 家很有钱（开玩笑），他家有 $n$ 个男家丁（做过前三弹的都知道）。但如此之多的男家丁吸引来了我们的体委（矮胖小伙），他要来与 mzc 争夺男家丁。

mzc 很生气，决定与其决斗，但 cat 的体力确实有些不稳定，所以他需要你来帮他计算一下最短需要的时间。


## 说明/提示

$1\le n \leq 2500$，$1\le m \leq 2\times10^5$，$1\le c_i\le 10^6$。

由于 mzc 大大十分着急，所以他只能等待 1s。


## 样例 #1

### 输入

```
5 8
1 2 3
2 3 4
3 4 5
4 5 6
1 3 4
2 4 7
2 5 8
1 5 100
```

### 输出

```
11```

# AI分析结果

### 综合分析与结论
本题是单源最短路径问题，各题解使用了多种算法，包括Bellman - Ford、Dijkstra（含堆优化）、SPFA等。
- **算法要点对比**：
    - **Bellman - Ford**：通过多次松弛所有边来更新最短路径，代码简单，但时间复杂度较高，为$O(nm)$。
    - **Dijkstra**：适用于非负边权的图，每次选择距离源点最近且未确定最短路径的点进行松弛操作。普通Dijkstra时间复杂度为$O(n^2)$，堆优化后为$O((n + m)\log n)$。
    - **SPFA**：是Bellman - Ford的队列优化版本，平均时间复杂度为$O(km)$，但在特殊图上可能退化为$O(nm)$。
- **难点解决**：
    - 部分题解提到要注意数据范围，避免数组越界。
    - 由于可能存在重边，需要对重边进行处理，选择最短的边。
    - 对于Dijkstra的堆优化，需要自定义比较函数或使用合适的数据结构。

### 高评分题解
- **作者：利刃随人（5星）**
    - **关键亮点**：使用堆优化的Dijkstra算法，结合邻接表存储图，时间复杂度较低。代码结构清晰，注释详细。
    - **核心代码**：
```cpp
struct node{
    int dis,jd;
    bool operator < (const node &a) const{
        return a.dis<dis;
    }
};
struct Edge{
    int next,to,worth;
}e[maxn*1000];
void dijkstra()
{
    priority_queue<node>q;
    for(int i=1;i<=n;i++)
        dis[i]=inf;
    dis[1]=0;
    q.push((node){0,1});
    while(!q.empty())
    {
        node now=q.top();
        q.pop();
        if(vis[now.jd]) continue;
        vis[now.jd]=true;
        for(int i=head[now.jd];i;i=e[i].next)
            if(dis[e[i].to]>dis[now.jd]+e[i].worth)
            {
                dis[e[i].to]=dis[now.jd]+e[i].worth;
                q.push((node){dis[e[i].to],e[i].to});
            }
    }
}
```
- **作者：dan_daning_L（4星）**
    - **关键亮点**：使用邻接矩阵实现Dijkstra算法，思路清晰，详细指出了处理重边的方法，适合初学者理解。
    - **核心代码**：
```cpp
for (i=1;i<=m;i++)
{
    cin>>x>>y>>z;
    f[x][y]=f[y][x]=min(z,f[x][y]); //输入&存储&判重 
}
for (i=1;i<=n;i++)               //经典Dijkstra模板,起点为1 
    c[i]=f[1][i];
memset(b,0,sizeof(b));
b[1]=1;
c[1]=0;
for (i=1;i<n;i++)
{
    int minn=0x3f3f3f3f;
    int k=0;
    for (j=1;j<=n;j++)
        if ((!b[j])&&(c[j]<minn))
        {
            minn=c[j];
            k=j;
        }
    if (!k) break;
    b[k]=1;
    for (j=1;j<=n;j++)
        c[j]=min(c[j],c[k]+f[k][j]);
} 
```
- **作者：香风智乃（4星）**
    - **关键亮点**：使用Dijkstra + 堆优化，采用动态数组存储边，编写难度稍大但效率较高，还附上了读入优化。
    - **核心代码**：
```cpp
struct edge{
    int from,to,dist;
};
struct data{
    int d,u;
    bool operator < (const data &tmp) const{
        return d>tmp.d;
    }
};
vector <edge> ed;
vector <int> g[2502];
priority_queue <data> h;
while(!h.empty())
{
    data x=h.top(); h.pop();
    int u=x.u,len=g[u].size();
    if(x.d!=d[u]) continue;
    for(int i=0;i<len;i++)
    {
        edge &e=ed[g[u][i]];
        if(d[u]+e.dist<d[e.to])
        {
            d[e.to]=d[u]+e.dist;
            h.push((data){d[e.to],e.to});
        }
    }
}
```

### 最优关键思路或技巧
- **数据结构**：使用邻接表或链式前向星存储图，可减少空间复杂度和遍历边的时间。
- **算法优化**：Dijkstra算法使用堆优化，能将时间复杂度从$O(n^2)$降低到$O((n + m)\log n)$。
- **代码实现技巧**：使用读入优化和输出优化，提高程序的输入输出效率。

### 拓展思路
同类型题可考察有负边权的图（使用Bellman - Ford或SPFA）、多源最短路径（Floyd算法）等。类似算法套路可用于解决网络流、最小生成树等问题。

### 推荐题目
- P3371 【模板】单源最短路径（弱化版）
- P4779 【模板】单源最短路径（标准版）
- P1144 最短路计数

### 个人心得摘录与总结
- **Deny_小田**：第一次提交得10分，原因是Dijkstra开始找最小距离的点时`min`变量忘记每次赋值；后续多次提交得40分，发现需要处理重边。总结是做题要注意细节。
- **Shikita**：发现数据存在重边，不判重会WA第二个和第十个点，但自己的判重方法比较丑陋。提醒做题时要考虑数据的特殊性。
- **zdx1031705564**：老老实实写Dijkstra只A了四个点，挑了一段时间发现要处理重边。强调处理重边的重要性。 

---
处理用时：43.73秒
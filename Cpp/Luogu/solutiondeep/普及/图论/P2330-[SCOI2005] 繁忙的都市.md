# 题目信息

# [SCOI2005] 繁忙的都市

## 题目描述

城市 C 是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市 C 的道路是这样分布的：城市中有 $n$ 个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：

1. 改造的那些道路能够把所有的交叉路口直接或间接的连通起来。
1. 在满足要求 1 的情况下，改造的道路尽量少。
1. 在满足要求 1、2 的情况下，改造的那些道路中分值最大的道路分值尽量小。

任务：作为市规划局的你，应当作出最佳的决策，选择哪些道路应当被修建。

## 说明/提示

### 数据范围及约定

对于全部数据，满足 $1\le n\le 300$，$1\le c\le 10^4$，$1 \le m \le 8000$。

## 样例 #1

### 输入

```
4 5
1 2 3
1 4 5
2 4 7
2 3 6
3 4 8
```

### 输出

```
3 6```

# AI分析结果

### 综合分析与结论
本题的核心是求解最小生成树（MST），目标是找到连接所有交叉路口的最少道路，且使其中分值最大的道路分值最小。题解主要围绕两种算法展开：Kruskal算法和Prim算法，部分题解还涉及二分答案的思路。

Kruskal算法基于贪心和并查集，先对边按权值排序，再依次选择不构成环的边，直到形成生成树；Prim算法从一个点开始，不断选择与当前树相连的最小权值边，扩展树的范围。二分答案则是通过枚举边权，判断图是否连通来确定最大边权的最小值。

### 所选题解
- **作者：张佳（4星）**
    - **关键亮点**：思路清晰，详细分析了题目条件得出是最小生成树问题，同时给出了Prim和Kruskal两种算法的代码，且代码注释较清晰。
    - **个人心得**：无

### 重点代码
#### Kruskal算法核心代码
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int m, n, u, v, c, maxn, k;
int fa[301];
int find(int x) {
    if(fa[x]!=x) 
        fa[x]=find(fa[x]);
    return fa[x];
}
void unionn(int x,int y) {
    int fx = find(x);
    int fy = find(y);
    if (fx != fy) fa[fx]=fy;
}
struct Node {
    int x, y, v;
    bool operator < (const Node &b) const {
        return v<b.v;
    }
}a[51000];
int main() {
    cin >> n >> m;
    for (int i=1; i<=m; i++) {
        cin >> u >> v >> c;
        a[i]=(Node){u, v, c};
    }
    for (int i=1; i<=n; i++) fa[i]=i;
    sort(a+1,a+m+1);
    for (int i=1; i<=m; i++) {
        if (find(fa[a[i].x]) != find(fa[a[i].y])) {
            unionn(a[i].x, a[i].y);
            maxn = a[i].v;
            k++;
        }
        if (k == n-1) break;
    }
    cout<< n-1 << " " <<maxn; 
    return 0;
}
```
**核心实现思想**：先将所有边按权值排序，然后依次遍历边，使用并查集判断边的两个端点是否属于不同集合，如果是则合并集合，并更新最大边权，直到选择了`n - 1`条边。

#### Prim算法核心代码
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int g[310][310];
int n,m,a,b,c,minn[310],mmax=-1;
bool u[310];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i){
        scanf("%d%d%d",&a,&b,&c);
        g[a][b]=c;
        g[b][a]=c;
    }
    memset(minn,0x7f,sizeof(minn));    
    minn[1]=0;
    memset(u,1,sizeof(u));
    for(int i=1;i<=n;++i){
        int k=0;
        for(int j=1;j<=n;j++)
            if(u[j]&&(minn[j]<minn[k]))
                k=j;
        u[k]=0;
        for(int j=1;j<=n;j++)
            if(u[j] && g[k][j]!=0 && g[k][j]<minn[j])
                minn[j]=g[k][j];
    }
    for(int i=1;i<=n;++i){
        if(minn[i]>mmax)
            mmax=minn[i];
    }
    printf("%d %d",n-1,mmax);
    return 0;
}
```
**核心实现思想**：从一个点开始，维护一个数组`minn`记录每个点到当前生成树的最小距离，每次选择距离最小的点加入树中，并更新其他点到树的最小距离，最后找出最大的最小距离。

### 最优关键思路或技巧
- **并查集路径压缩**：在Kruskal算法中，使用路径压缩优化并查集的查找操作，可将时间复杂度从 $O(n)$ 优化到接近 $O(1)$。
- **贪心策略**：Kruskal算法按边权从小到大选择边，Prim算法每次选择与当前树相连的最小权值边，都是贪心思想的体现。

### 可拓展之处
同类型题或类似算法套路：
- **次小生成树**：在最小生成树的基础上，找到权值次小的生成树。
- **最小瓶颈生成树**：本题就是最小瓶颈生成树的应用，可拓展到更复杂的图结构。
- **有向图的最小生成树（最小树形图）**：使用朱刘算法求解。

### 推荐题目
- [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
- [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195)
- [P2872 [USACO07DEC]Building Roads S](https://www.luogu.com.cn/problem/P2872)

### 个人心得摘录与总结
- **司徒stuart**：因空格打全角导致WA两次，提醒做题时要注意细节。
- **ww3113306**：连接两个点时，要将两个点所属集合的根节点相连，防止陷入死循环，强调并查集合并操作的正确性。

---
处理用时：41.96秒
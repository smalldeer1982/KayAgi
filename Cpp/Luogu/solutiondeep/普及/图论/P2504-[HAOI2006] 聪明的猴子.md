# 题目信息

# [HAOI2006] 聪明的猴子

## 题目描述

在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。

现在，在这个地区露出水面的有 $N$ 棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。

在这个地区住着的猴子有 $M$ 个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。

现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。


## 说明/提示

对于 $40\%$ 的数据，保证有 $2 \le N \le 100$，$1 \le M \le 100$

对于全部的数据，保证有 $2 \le N \le 1000$，$1 \le M \le500$

感谢 @charlie003 修正数据

## 样例 #1

### 输入

```
4
 1 2 3 4
6
0 0
1 0
1 2
-1 -1
-2 0
2 2```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕最小生成树算法（Kruskal和Prim）解决问题，核心思路是找出以所有树冠为节点的最小生成树的最长边，将其与每只猴子的最大跳跃距离比较，统计能跳到所有树冠的猴子数量。

### 所选题解
- **作者：哥就是拽（5星）**
    - **关键亮点**：思路清晰，代码简单易懂，详细注释了Kruskal算法过程，适合初学者。
    - **核心代码**：
```cpp
// 计算两点间距离并存储边
for(int i=1; i<=n; i++) {
    for(int j=1; j<=n; j++) {
        if(i!=j) {
            k++;
            z[k].x=i;
            z[k].y=j;
            z[k].p=sqrt((a[i][1]-a[j][1])*(a[i][1]-a[j][1])+(a[i][2]-a[j][2])*(a[i][2]-a[j][2]));
        }
    }
}
// Kruskal算法
sort(z+1,z+k+1,cmp);
for(int i=1; i<=n; i++) {
    pre[i]=i;
}
for(int i=1; i<=k; i++) {
    if(cnt==1)
        break;
    int s1=find(z[i].x),s2=find(z[i].y);
    if(s1!=s2) {
        pre[s1]=s2;
        cnt--;
        sum=z[i].p;
    }
}
```
- **作者：K2sen（4星）**
    - **关键亮点**：详细解释了建边过程和思路，代码结构清晰，对算法步骤有明确注释。
    - **核心代码**：
```cpp
// 建边
for (int i = 1; i <= m; i++) 
    for (int j = i + 1; j <= m; j++) {
        edge[++cnt].x = i;
        edge[cnt].y = j;
        edge[cnt].dis = sqrt((px[i] - px[j]) * (px[i] - px[j]) + (py[i] - py[j]) * (py[i] - py[j]));
    }
// Kruskal算法
sort(edge + 1, edge + cnt + 1, cmp);
for (int i = 1; i <= m; i++) fath[i] = i;
double maxn = -1; int po = 0;
for (int i = 1; i <= cnt; i++) {
    if (father(edge[i].x)!= father(edge[i].y)) {
        unionn(edge[i].x, edge[i].y);
        po++;
        maxn = max(maxn, edge[i].dis);
    }
    if (po == m - 1) break;
}
```
- **作者：暮光闪闪（4星）**
    - **关键亮点**：使用Prim算法的优先队列优化，复杂度为$nlogn$，适合处理大数据。
    - **核心代码**：
```cpp
// 建边
for(long long i=1;i<=n;i++)
    for(long long j=i+1;j<=n;j++){
        long long tmp=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
        adde(i,j,tmp),adde(j,i,tmp);
    }
// Prim算法
typedef pair<long long,long long>p;
priority_queue<p,vector<p>,greater<p> >q;
long long chosen_point_num=1,u=1;
memset(dis,0x3f,sizeof(dis));
for(long long i=head[u];i;i=e[i].nxt){
    long long v=e[i].v;dis[v]=min(dis[v],e[i].w);
    q.push(make_pair(dis[v],v));
}
while(++chosen_point_num<=n){
    vis[u]=1;
    while(vis[q.top().second])q.pop();
    max_dis=max(max_dis,q.top().first);
    u=q.top().second;q.pop();
    for(long long i=head[u];i;i=e[i].nxt){
        long long v=e[i].v;
        if(vis[v]==0&&dis[v]>e[i].w){
            dis[v]=e[i].w;
            q.push(make_pair(dis[v],v));
        }
    }
}
```

### 最优关键思路或技巧
- **避免开方运算**：计算两点间距离时不开方，将猴子跳跃距离平方处理，减少计算量和精度误差。
- **优先队列优化Prim算法**：使用优先队列按树间距离从小到大排序，将Prim算法复杂度优化到$nlogn$。
- **Kruskal算法排序特性**：边按从小到大排序后，最后加入的边就是最大边，无需额外取最大值。

### 可拓展之处
同类型题或类似算法套路：
- 最小瓶颈生成树问题：找出图中边权最大值最小的生成树。
- 连通性问题：判断图中节点的连通性，可使用并查集解决。
- 图的遍历问题：如广度优先搜索（BFS）、深度优先搜索（DFS），用于判断节点是否可达。

### 洛谷相似题目推荐
- P3366 【模板】最小生成树
- P1194 买礼物
- P1991 无线通讯网

### 个人心得摘录与总结
- **作者：kkkk0369**：最初使用floor函数处理精度出错，后改成double类型；存边数组开小导致得分低，增大数组后AC。总结为要注意数据类型和数组大小，避免因精度和空间问题出错。
- **作者：Nero_Claudius**：数组开小导致RE，增大数组后AC；实验发现求距离开不开根不影响结果。提醒注意数组大小，可根据情况选择是否开方。
- **作者：Jith_2004**：使用sqrt可能因精度问题出错，平方运算最多8000000，不超int范围；使用lower_bound代替循环找答案，复杂度为$O(n^2)$。建议避免使用sqrt，可利用排序和二分查找优化。 

---
处理用时：41.61秒
# 题目信息

# [NOIP 2015 提高组] 信息传递

## 题目背景

NOIP2015 Day1T2

## 题目描述

有 $n$ 个同学（编号为 $1$ 到 $n$）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。

游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？

## 说明/提示

**样例 1 解释：**

![](https://cdn.luogu.com.cn/upload/image_hosting/3ca5zl3c.png)

游戏的流程如图所示。当进行完第 $3$ 轮游戏后，$4$ 号玩家会听到 $2$ 号玩家告诉他自己的生日，所以答案为 $3$。当然，第 $3$ 轮游戏后，$2$ 号玩家、 $3$ 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。

- 对于 $30\%$ 的数据，$n\le 200$；
- 对于 $60\%$ 的数据，$n\le 2500$；
- 对于 $100\%$ 的数据，$n\le 2\times 10^5$。


## 样例 #1

### 输入

```
5
2 4 2 3 1```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
本题的核心是在有向图中找出最小环的长度，由于每个点出度为 1，图的结构具有一定特殊性。各题解主要围绕深度优先搜索（DFS）、拓扑排序、并查集、Tarjan 算法等方法展开。

DFS 类方法通过记录节点访问信息来判断环的形成并计算环的长度；拓扑排序用于排除不可能成环的节点，简化图的结构后再进行 DFS 找环；并查集通过合并集合来判断环的存在并计算环的大小；Tarjan 算法则通过缩点找出强连通分量，进而确定最小环。

### 所选题解
- **作者：KesdiaelKen（5 星）**
  - **关键亮点**：思路清晰，代码简洁，对 DFS 方法进行了优化，通过标记已查找过的节点避免重复计算，时间复杂度为 $O(n)$。
  - **个人心得**：作者一开始尝试用 set 暴力判重 TLE 了 6 个点，后经过思考想出了当前的优化方法，体现了不断尝试和优化的过程。
- **作者：深海鱼的眼泪（4 星）**
  - **关键亮点**：先利用拓扑排序排除入度为 0 的节点，缩小搜索范围，再进行 DFS 找环，逻辑清晰。
- **作者：CaiZi（4 星）**
  - **关键亮点**：使用严格 $O(n)$ 的 Tarjan 算法，通过缩点找出最小环，算法复杂度低。

### 重点代码
#### KesdiaelKen 的题解
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
using namespace std;
int dx[300000];//存每一个人传话的对象
bool visit[300000]={0},novisit[300000]={0};//visit存每次查找中被查到的点，而novisit存每次查找前，已经被查找过的点（及不用继续查找了）
int bs[300000]={0};//每次查找中第一次到一个节点所经过的边数
int minn=2e9;
void dfs(int node,int num)
{
    if(novisit[node])return;//不需要继续找了
    if(visit[node])//在此次查找中出现过
    {
        minn=min(minn,num-bs[node]);//形成一个环，取最小值
    }
    else
    {
        visit[node]=true;//在此次循环中经过
        bs[node]=num;//记录第一次到达时的步数
        dfs(dx[node],num+1);//搜索
        novisit[node]=true;//已经搜过
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&dx[i]);
    }
    for(int i=1;i<=n;i++)
    {
        dfs(i,0);//枚举全部节点
    }
    printf("%d",minn);//输出
    return 0;//时间复杂度O(n)
}
```
**核心思想**：从每个节点开始进行 DFS，记录到达每个节点的步数。当遇到已经访问过的节点时，说明找到了一个环，计算环的长度并更新最小值。同时，标记已经查找过的节点，避免重复计算。

#### 深海鱼的眼泪的题解
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
#include <queue>
using namespace std;
int n,t[200050],d[200050],ans=1000000000,r[200050];
void read(int& x){
    x=0;
    int y=1;
    char ch=getchar();
    while (ch<'0'||ch>'9'){
        if (ch=='-') y=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    x=x*y;
}
void dfs(int ti,int s,int l){
    if (ti==s&&l){                                //如果回到开始说明连成了环 
        ans=min(ans,l);
        return;
    }
    if (!d[t[ti]]) {
        d[t[ti]]=1;                                //标记 
        dfs(t[ti],s,l+1);
    }
}
void rmove(int ti){                                //删除ti 
    d[ti]=-1;                                    //标记 
    r[t[ti]]--;                                    //ti的下一个人的入度减一 
    if (!r[t[ti]]&&d[t[ti]]!=-1) rmove(t[ti]);
}
int main(){
    freopen("ferry.in","r",stdin);
    freopen("message.out","w",stdout);
    memset(d,0,sizeof(d));
    memset(r,0,sizeof(r));                        //r[i]为第 i 个人的入度 
    int i;
    read(n);
    for (i=1;i<=n;i++){
        read(t[i]);
        r[t[i]]++;
    }
    for (i=1;i<=n;i++){
        if (!r[i]&&d[i]!=-1) rmove(i);            //如果 i 的入度为 0 且还未被删除，则删除i 
    }
    for (i=1;i<=n;i++){
        if (!d[i]){                                //如果i还未搜过且未被删除，则从i开始搜索 
            dfs(i,i,0);
        }
    }
    printf("%d",ans);
    return 0;
}
```
**核心思想**：先统计每个节点的入度，将入度为 0 的节点及其相关边删除，缩小图的规模。然后对剩余节点进行 DFS，当回到起点时，说明找到了一个环，更新最小环的长度。

#### CaiZi 的题解
```cpp
#include<bits/stdc++.h>
using namespace std;
int dfn[200001],low[200001],siz[200001],tim,scc,n,x;
bool bel[200001];
stack<int>s;
vector<int>g[200001];
inline void tarjan(int i){
    tim++;
    dfn[i]=low[i]=tim;
    s.push(i);
    for(int j:g[i]){
        if(dfn[j]==0){
            tarjan(j);
            low[i]=min(low[i],low[j]);
        }
        else{
            if(!bel[j]){
                low[i]=min(low[i],dfn[j]);
            }
        }
    }
    if(low[i]==dfn[i]){
        int j;
        scc++;
        do{
            j=s.top();
            s.pop();
            bel[j]=true;
            siz[scc]+=1;
        }while(j!=i);
    }
}
signed main(){
    cin.tie(nullptr)->sync_with_stdio(false);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>x;
        g[i].push_back(x);
    }
    for(int i=1;i<=n;i++){
        if(dfn[i]==0){
            tarjan(i);
        }
    }
    x=INT_MAX;
    for(int i=1;i<=n;i++){
        if(siz[i]>=2){
            x=min(x,siz[i]);
        }
    }
    cout<<x;
    return 0;
}
```
**核心思想**：使用 Tarjan 算法进行缩点，找出所有强连通分量。由于每个点出度为 1，每个强连通分量都是一个环。最后遍历所有强连通分量，找出大小大于等于 2 的最小环。

### 最优关键思路或技巧
- **标记优化**：在 DFS 过程中，使用标记数组记录已访问的节点和已查找过的节点，避免重复计算，提高效率。
- **拓扑排序预处理**：先排除入度为 0 的节点，缩小搜索范围，减少不必要的计算。
- **Tarjan 算法**：对于有向图中找环的问题，Tarjan 算法可以在 $O(n)$ 时间复杂度内找出所有强连通分量，进而确定最小环。

### 可拓展之处
同类型题或类似算法套路：
- 有向图中的环检测和环长度计算问题，可使用 DFS、拓扑排序、并查集、Tarjan 算法等方法。
- 无向图中的环检测和环长度计算问题，可使用 DFS、并查集等方法。
- 强连通分量相关问题，可使用 Tarjan 算法或 Kosaraju 算法。

### 推荐题目
- [P1038 神经网络](https://www.luogu.com.cn/problem/P1038)：涉及图的遍历和拓扑排序。
- [P2341 [USACO03FALL][HAOI2006] 受欢迎的牛 G](https://www.luogu.com.cn/problem/P2341)：需要使用 Tarjan 算法求强连通分量。
- [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)：直接考察 Tarjan 算法缩点。

### 个人心得总结
- KesdiaelKen 一开始尝试用 set 暴力判重 TLE 了 6 个点，后经过思考想出了优化方法，说明在解题过程中要不断尝试和优化，遇到问题要深入思考。
- Ascnbeta 刚学并查集，花了挺久才想清楚这题为什么能用并查集，通过写题解整理思路，这提醒我们在学习新算法时，要多思考、多实践，通过写题解等方式加深理解。

---
处理用时：62.18秒
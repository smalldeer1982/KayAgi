# 题目信息

# 小岛

## 题目背景

西伯利亚北部的寒地，坐落着由 $N$ 个小岛组成的岛屿群，我们把这些小岛依次编号为 $1$ 到 $N$。


## 题目描述

起初，岛屿之间没有任何的航线。后来随着交通的发展，逐渐出现了一些连通两座小岛的航线。例如增加一条在 $u$ 号小岛与 $v$ 号小岛之间的航线，这条航线的用时为 $e$。那么沿着这条航线，$u$ 号小岛上的人可以前往 $v$ 号小岛，同样的 $v$ 号小岛上的人也可以前往 $u$ 号小岛，其中沿着这一条航线花费的时间为 $e$。

同时，随着旅游业的发展，越来越多的人前来游玩。那么两个小岛之间的最短路径是多少便成为了饱受关注的话题。


## 说明/提示

对于 $20\%$ 的数据，$N\le 5$ 且 $M\le 30$。

对于 $40\%$ 的数据，$N\le 20$ 且 $M\le 200$。

对于 $60\%$ 的数据，$N\le 80$ 且 $M\le 500$。

对于 $80\%$ 的数据，$N\le 100$ 且 $M\le 2500$。

对于 $100\%$ 的数据，$N\le 100$ 且 $M\le 5000$。


## 样例 #1

### 输入

```
3 8 
1 3 1 10 
0 2 3 
1 2 3 20 
1 1 2 5 
0 3 2 
1 1 3 7 
1 2 1 9 
0 2 3```

### 输出

```
-1
15
12```

## 样例 #2

### 输入

```
5 16
1 1 2 343750
1 1 3 3343
1 1 4 347392
1 1 5 5497
1 2 3 123394
1 2 4 545492
1 2 5 458
1 3 4 343983
1 3 5 843468
1 4 5 15934
0 2 1
0 4 1
0 3 2
0 4 2
0 4 3
0 5 3```

### 输出

```
5955
21431
9298
16392
24774
8840```

# AI分析结果

### 分析与结论
本题描述了一个由 $N$ 个小岛组成的岛屿群，起初岛屿间无航线，后续逐渐增加连通两座小岛的双向航线并给定用时。题目会有两种操作，一是增加航线，二是询问两个小岛间的最短路径，若无法到达则输出 -1。数据范围为 $N\le 100$ 且 $M\le 5000$。

### 所选题解
- **作者：公主殿下MIKU (赞：15)，4星**
    - **亮点**：思路清晰，使用堆优化的 Dijkstra 算法，详细解释了小根堆的重载和前向星建图，代码可读性高。
    - **核心代码**：
```cpp
struct node{//小根堆重载
    int now,x;//now代表点的位置，x代表距离
    bool operator <(const node &tmp) const
    {
        return x>=tmp.x;
    }
}cur;
void add(int x,int y,int z)//前向星建图，因为是双向边，所以存两条边
{
    to[++num]=y;
    v[num]=z;
    nxt[num]=head[x];
    head[x]=num;
    to[++num]=x;
    v[num]=z;
    nxt[num]=head[y];
    head[y]=num;
}
void dij(int s)
{
    priority_queue<node>q;
    fill(dis+1,dis+n+1,inf);//初始化，一定要初始化，不然它会与上次查询有冲突。
    fill(vis+1,vis+n+1,0);
    dis[s]=0;
    q.push((node){
        s,dis[s]
    });
    while(!q.empty())
    {
        cur=q.top();
        q.pop();
        if(vis[cur.now]) continue;
        vis[cur.now]=1;
        for(int i=head[cur.now];i;i=nxt[i])
        {
            if(dis[to[i]]>dis[cur.now]+v[i])//路径压缩
            {
                dis[to[i]]=dis[cur.now]+v[i];
                q.push((node){
                    to[i],dis[to[i]]
                });
            }
        }
    }
}
```
    - **核心思想**：使用前向星建图存储边信息，通过重载小根堆优化 Dijkstra 算法，每次询问时从起点开始跑 Dijkstra 算法求最短路径。

- **作者：sukimo (赞：4)，4星**
    - **亮点**：提出 Floyd 算法的优化思路，对于每次增边，只以新增边的两个点为中转点进行更新，避免了每次都跑完整 Floyd 算法的高复杂度。
    - **核心代码**：
```cpp
void floyd(int x,int y){
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)dis[i][j]=min(dis[i][j],dis[i][x]+dis[x][j]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)dis[i][j]=min(dis[i][j],dis[i][y]+dis[y][j]);    
}
int main(){
    int m;scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)if(i-j)dis[i][j]=INF;
    for(int i=1;i<=m;i++){
        int type,a,b;scanf("%d%d%d",&type,&a,&b);
        if(!type)printf("%d\n",dis[a][b]==INF?-1:dis[a][b]);
        else{
            int q_edge;scanf("%d",&q_edge);
            if(dis[a][b]>q_edge){dis[a][b]=dis[b][a]=q_edge;floyd(a,b);}
        }
    }
    return 0;
}
```
    - **核心思想**：先初始化距离矩阵，对于每次增边，判断是否需要更新，如果需要则以新增边的两个点为中转点更新距离矩阵，询问时直接输出对应距离。

- **作者：Chen_Py (赞：4)，4星**
    - **亮点**：提出类似 Floyd 算法的思想，枚举中间边来松弛路径，虽然效率看起来不如 Dijkstra 算法，但常数小，代码实现简单。
    - **核心代码**：
```cpp
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(i==j)myp[i][j]=0;
            else myp[i][j]=1e9;
        }
    }
    int op,a,b,c;
    while(m--)
    {
        cin>>op;
        if(op==0)
        {
            cin>>a>>b;
            if(myp[a][b]>=1e9)cout<<-1<<endl;
            else cout<<myp[a][b]<<endl;
        }
        else
        {
            cin>>a>>b>>c;
            myp[a][b]=min(c,myp[a][b]);
            myp[b][a]=min(c,myp[b][a]);
            for(int i=1;i<=n;i++)
            {
                for(int j=1;j<=n;j++)
                {
                    myp[i][j]=min(myp[i][j],myp[i][a]+myp[a][b]+myp[b][j]);
                    myp[i][j]=min(myp[i][j],myp[i][b]+myp[b][a]+myp[a][j]);
                }
            }
        }
    }
    return 0;
}
```
    - **核心思想**：初始化距离矩阵，对于每次增边，更新边的信息并枚举任意两个点，考虑新增边后更新最短路径，询问时直接输出对应距离。

### 最优关键思路或技巧
- **算法优化**：对于 Dijkstra 算法使用堆优化，提高查找最小距离点的效率；对于 Floyd 算法，避免每次都跑完整算法，只以新增边的两个点为中转点进行更新。
- **数据结构**：使用前向星或邻接矩阵存储图的边信息。
- **思维方式**：在动态加边的情况下，思考如何减少不必要的计算，如枚举中间边来松弛路径。

### 可拓展之处
同类型题如动态加边的最短路问题，类似算法套路可参考：在动态变化的图中，每次变化后只更新受影响的部分，而不是重新计算整个图的信息。

### 推荐题目
- [P1119 灾后重建](https://www.luogu.org/problemnew/show/P1119)：涉及动态更新和最短路问题。
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.org/problemnew/show/P3371)：基础的单源最短路径问题，可练习 Dijkstra、SPFA 等算法。
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.org/problemnew/show/P4779)：同样是单源最短路径问题，数据范围更大，对算法优化要求更高。

### 个人心得
- **Aehnuwx**：尝试了多种优化方法，如 O2、O3、Ofast 优化，IO 优化，register 大法等，最后通过增加标记避免重复跑 Floyd 算法成功卡过。总结为在遇到复杂度较高的算法时，可以尝试各种优化方法，尤其是针对重复计算的部分进行优化。 

---
处理用时：47.83秒
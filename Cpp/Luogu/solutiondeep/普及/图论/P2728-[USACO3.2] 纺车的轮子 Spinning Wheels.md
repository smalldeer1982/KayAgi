# 题目信息

# [USACO3.2] 纺车的轮子 Spinning Wheels

## 题目背景

一架纺车有五个纺轮（也就是五个同心圆），这五个不透明的轮子边缘上都有一些缺口。这些缺口必须被迅速而准确地排列好。每个轮子都有一个起始标记（在0度），这样所有的轮子都可以在统一的已知位置开始转动。轮子按照角度变大的方向旋转（即0经过旋转到达1的位置），所以从起始位置开始，在一定的时间内，它们依次转过1度，2度等等（虽然这些轮子很可能不会同时转过这些角度）。


## 题目描述

这是一个整数问题。轮子不会转过1.5度或23.51234123度这样的角度。例如，轮子可能在一秒钟内转过20到25度甚至30到40度（如果转得快的话）。

这个问题中的所有角度都限制在 0 <= 角度 <= 359 这个范围内。轮子转过 359 度后接下来就是 0 度。每个轮子都有一个确定的旋转速度，以秒作为单位。1 <= 速度 <= 180。

轮子上的缺口的起始角度和缺口大小（或宽度）各由一个整数表示，都以度为单位。在一个轮子上，两个缺口之间至少有一度的间隔。宽度也包含缺口起始的角度，**即0 179包括0..179共计180个角度**

在起始位置，设时间为 0，所有的轮子的起始标记排列成一条直线。你的程序必须计算，最早出现每个的轮子上的缺口同其他轮子上的缺口对准（也就是一束光可以通过五个轮子上的五个缺口）情况的时间。这些缺口在任意一个角度对准。


## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 3.2


## 样例 #1

### 输入

```
30 1 0 120
50 1 150 90
60 1 60 90
70 1 180 180
90 1 180 60```

### 输出

```
9```

# AI分析结果

### 综合分析与结论
这些题解均采用模拟的方法解决纺车轮子缺口对齐问题。思路是枚举每一秒，记录每个角度的缺口数量，若某一角度的缺口数为 5，则表示五个轮子的缺口在此角度对齐。

各题解的算法要点和解决难点基本相同，主要区别在于代码实现的细节，如变量命名、结构体定义、循环控制等。

### 所选题解
- 作者：「QQ红包」 (赞：17)，4星
  - 关键亮点：思路清晰，代码结构简洁，注释详细，易于理解。
- 作者：王轩逸 (赞：5)，4星
  - 关键亮点：注释清晰，对思路和时间范围的解释很详细，有助于理解。
- 作者：傅思维666 (赞：1)，4星
  - 关键亮点：不仅给出代码，还对圆轮题的处理方法进行了探讨，提供了有用的思路。

### 重点代码及核心实现思想
#### 作者：「QQ红包」
```cpp
for (t=0;t<=360;t++)//可能一开始就有一个地方5个轮子在那都是洞 
{
    memset(a,0,sizeof(a));//a清0 
    for (i=1;i<=5;i++)//5个轮子
    {
        for (j=1;j<=s[i];j++)//s[i]个洞 
        {
            for (k=x[i][j];k<=x[i][j]+y[i][j];k++)//标记到数组a
                a[k%360]++;//标记。记得取模 
            x[i][j]=(x[i][j]+v[i])%360;//下一秒状态。记得取模 
        } 
    } //标记完成 
    for (i=0;i<=359;i++)
    if (a[i]==5)//5个轮子在此处均为洞
    {
        printf("%d\n",t);//输出 
        return 0;
    } 
} 
printf("none\n");
```
核心思想：枚举每一秒，将每个轮子的缺口对应的角度在数组 `a` 中标记，若某一角度的标记数为 5，则输出当前时间，否则继续枚举，若 360 秒内都未找到则输出 `none`。

#### 作者：王轩逸
```cpp
for(int t=0;t<360;t++){//最多转动 360 秒后，所有轮子会回到初始位置。
    memset(gap,0,sizeof(gap));
    for(int i=1;i<=n;i++){
        for(int j=1;j<=w[i].num;j++){//j 个缺口
            for(int k=0;k<=w[i].len[j];k++)
                gap[(w[i].st[j]+k)%360]++;
            w[i].st[j]=(w[i].st[j]+w[i].sp)%360;//模拟转动。
        }
    }
    for(int i=0;i<360;i++)
        if(gap[i]==5){
            cout<<t;
            return 0;
        }
}
cout<<"none";
```
核心思想：同样枚举每一秒，用 `gap` 数组记录每个角度的缺口数量，若某一角度的缺口数为 5，则输出当前时间，否则继续枚举，若 360 秒内都未找到则输出 `none`。

#### 作者：傅思维666
```cpp
for(int t=0;t<=360;t++)
{
    memset(v,0,sizeof(v));
    for(int i=1;i<=5;i++)
        for(int j=1;j<=s[i];j++)
        {
            for(int k=p[i][j];k<=p[i][j]+width[i][j];k++)
                v[k%360]++; 
            p[i][j]=(p[i][j]+speed[i])%360; 
        }
    for(int i=0;i<=359;i++)
        if (v[i]==5)
        {
            printf("%d",t); 
            return 0;
        } 
}  
printf("none");
```
核心思想：枚举每一秒，用 `v` 数组记录每个角度的缺口数量，若某一角度的缺口数为 5，则输出当前时间，否则继续枚举，若 360 秒内都未找到则输出 `none`。同时探讨了圆轮题的处理方法，即对可能越界的下标取模。

### 最优关键思路或技巧
- 利用数组记录每个角度的缺口数量，通过枚举时间和角度来判断是否有五个轮子的缺口对齐。
- 对可能越界的下标取模，避免数组越界问题，这是处理圆轮题的常用技巧。

### 可拓展之处
同类型题或类似算法套路：环形跑道问题、时钟指针问题等。这些问题都涉及到循环和周期性，可采用类似的模拟方法，通过对下标取模来处理循环。

### 推荐题目
- P1042 [NOIP2003 普及组] 乒乓球
- P1067 [NOIP2009 普及组] 多项式输出
- P1098 [NOIP2007 提高组] 字符串的展开

### 个人心得
- 作者：此后无良辰：“记得每次清0，原本我就错这”，强调了在每次枚举时间时要清空记录缺口数量的数组，否则会影响结果。
- 作者：yangyujia18：“memset(is,0,sizeof(is));//没有后果自负”，同样强调了清空数组的重要性。

---
处理用时：38.37秒
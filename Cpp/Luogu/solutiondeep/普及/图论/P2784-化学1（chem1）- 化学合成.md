# 题目信息

# 化学1（chem1）- 化学合成

## 题目背景

蒟蒻 HansBug 在化学考场上，挠了无数次的头，可脑子里还是一片空白。

## 题目描述

眼下出现在蒟蒻 HansBug 面前的是一个化学合成题，据他所知，一般答案如下面这样的格式：

![](https://cdn.luogu.com.cn/upload/pic/2223.png) （接下一行）

![](https://cdn.luogu.com.cn/upload/pic/2221.png) 

简单解释下：每种化合物可以通过一步反应生成另一个化合物（将这称作一步反应，设为 $A\rightarrow B$），现在假设每个 $A\rightarrow B$ 中，理论上 $1$ 个单位的 $A$ 都仅可以生成 $1$ 个单位的 $B$。然而实际实验表明，并不存在绝对完全的化学转化，设转化率为 $C$（即 $1$ 个单位 $A$ 实际可以生成 $C$ 个单位的 $B$，$0<C<1$）。

现在蒟蒻 HansBug 的知识体系中有 $N$ 个这样 $A\rightarrow B$ 的转化。然而题目中蒟蒻 HansBug 要由 $1$ 个单位的化合物 $S$ 生成化合物 $T$，可是他脑细胞和 RP 已经消耗殆尽，所以找到最终产量最高的合成路线的艰巨任务就交给你啦！

## 说明/提示

样例 1 和样例 2 中，两条合成路线分别为 $1\rightarrow3$、$1\rightarrow2$、$2\rightarrow3$，产率分别为 $0.8$、$0.9$、$0.9$。

在样例 1 中，有两种可行的路线 $1\rightarrow3$ 和 $1\rightarrow2\rightarrow3$ ，最终产量分别为 $0.8$、$0.9\times0.9=0.81$，故第二条路线更优，产量为 $0.8100$。

样例 2 中，$2$ 只能生成 $3$，$3$ 无法生成别的化合物，故无法生成，蒟蒻 HansBug 只好选择 `orz`。

**【数据范围】**

![](https://cdn.luogu.com.cn/upload/pic/2220.png)


## 样例 #1

### 输入

```
3 3 1 3
1 3 0.8
1 2 0.9
2 3 0.9
```

### 输出

```
0.8100```

## 样例 #2

### 输入

```
3 3 2 1
1 3 0.8
1 2 0.9
2 3 0.9
```

### 输出

```
orz```

# AI分析结果

### 综合分析与结论
本题是一个求有向图中从起点到终点的最大产量路径问题，可转化为最长路问题。各题解主要运用了 Dijkstra、SPFA、Bellman - Ford 算法以及 BFS 搜索来解决，在实现上大多对传统算法进行了修改以适应题目中产量乘法的要求。

Dijkstra 算法适用于非负权图，复杂度可优化，但在本题中部分实现可能超时；SPFA 是 Bellman - Ford 算法的队列优化，对本题较为适用；BFS 搜索也能解决问题，但效率可能较低。

### 所选题解
- **作者：XiaoX (赞：9)，4星**
    - **关键亮点**：使用堆优化的 Dijkstra 算法，思路清晰，代码规范，对关键步骤有注释。
    - **个人心得**：提到第 2 个点 960ms，暗示该算法在本题可能存在性能问题。
- **作者：Diamiko (赞：6)，4星**
    - **关键亮点**：使用 SPFA 算法求最长路，对 SPFA 最短路模板的修改说明清晰，代码简洁易懂。
- **作者：幽灵特工 (赞：4)，4星**
    - **关键亮点**：详细介绍了多种图的存储方式和多种最短路算法（Bellman - Ford、SPFA、Dijkstra），对算法原理和实现有详细解释，代码有注释。

### 重点代码
#### XiaoX 的 Dijkstra 算法核心代码
```cpp
typedef pair<double,int> kk;
const int N=5005,M=2000000;
int n,m,s,t;
int head[N],tot;
double d[N];
bool v[N];
struct edge{
    int nxt,ver;
    double w;
}e[M*2];
void add(int x,int y,double z){
    e[++tot].ver=y,e[tot].w=z,e[tot].nxt=head[x],head[x]=tot;
}
void dij(int st){
    for(int i=1;i<=n;i++) d[i]=-1;
    priority_queue<kk>q;
    d[st]=1;q.push(make_pair(1,st));
    while(q.size()){
        int x=q.top().second;q.pop();
        if(v[x]) continue;v[x]=1;
        for(int i=head[x];i;i=e[i].nxt){
            int y=e[i].ver;
            if(d[x]*e[i].w>d[y]){
                d[y]=d[x]*e[i].w;
                q.push(make_pair(d[y],y));
            }
        }
    }
}
```
**核心实现思想**：使用邻接表存图，将起点的产量初始化为 1，其余点初始化为 -1 表示未到达。使用优先队列（大根堆）优化 Dijkstra 算法，不断更新各点的最大产量。

#### Diamiko 的 SPFA 算法核心代码
```cpp
struct Node
{
    int head;
    double dis;
    bool vis;
}node[5005];
struct Edge
{
    int to,next;
    double len;
}edge[2000005];
int cnt,n,m,s,t;
void addEdge(int u,int v,double w)
{
    edge[++cnt].to=v;
    edge[cnt].len=w;
    edge[cnt].next=node[u].head;
    node[u].head=cnt;
}
void SPFA()
{
    queue<int>q;
    for(int i=1;i<=n;i++)
    {
        node[i].dis=-0x3f3f3f3f;
        node[i].vis=0;
    }
    node[s].dis=1;
    node[s].vis=1;
    q.push(s);
    while(q.size())
    {
        int u=q.front();
        q.pop();
        node[u].vis=0;
        for(int e=node[u].head;e;e=edge[e].next)
        {
            int v=edge[e].to;
            if(node[v].dis<node[u].dis*edge[e].len)
            {
                node[v].dis=node[u].dis*edge[e].len;
                if(!node[v].vis)
                {
                    q.push(v);
                    node[v].vis=1;
                }
            }
        }
    }
}
```
**核心实现思想**：使用链式前向星存图，将起点的产量初始化为 1，其余点初始化为极小值。使用队列维护可能更新的点，不断更新各点的最大产量。

#### 幽灵特工的 SPFA 算法核心代码
```cpp
const int MAXN = 5010;
int n, m, s, t;
struct edge {
    int from, to;
    double w;
    edge(int x, int y, double z) { from = x; to = y; w = z; }
};
vector <edge> e;
vector <int> G[MAXN];
queue <int> q;
bool in_queue[MAXN];
double dist[MAXN];
void SPFA() {
    for (int i = 1; i <= n; i++)dist[i] = -1;
    dist[s] = 1.00;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        in_queue[u] = 0;
        for (int i = 0; i < G[u].size(); i++) {
            int v = e[G[u][i]].to;
            if (dist[v] < dist[u] * e[G[u][i]].w) {
                dist[v] = dist[u] * e[G[u][i]].w;
                if (!in_queue[v]) { q.push(v); in_queue[v] = 1; }
            }
        }
    }
}
```
**核心实现思想**：使用边集数组存图，将起点的产量初始化为 1，其余点初始化为 -1。使用队列维护可能更新的点，不断更新各点的最大产量。

### 最优关键思路或技巧
- **算法选择**：根据题目特点，将求最大产量路径问题转化为最长路问题，选择合适的算法（如 SPFA 算法在本题中表现较好）。
- **初始化**：起点的产量初始化为 1，其余点初始化为极小值或 -1，确保后续乘法计算正确。
- **图的存储**：使用邻接表、链式前向星或边集数组等存储方式，避免使用邻接矩阵导致内存溢出。

### 可拓展之处
同类型题或类似算法套路：
- 求有向图中的最短路径、最长路径问题，可使用 Dijkstra、SPFA、Bellman - Ford 等算法。
- 涉及图的遍历和搜索问题，可使用 BFS、DFS 等算法。
- 图的优化问题，如最小生成树（Prim、Kruskal 算法）等。

### 推荐题目
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

### 个人心得摘录与总结
- **XiaoX**：提到第 2 个点 960ms，说明堆优化的 Dijkstra 算法在本题可能存在性能问题，暗示不同算法在不同数据下的效率差异。
- **vegetabird**：指出用 Dijkstra 做最后一个点超时，无奈使用 SPFA 算法，再次强调了算法选择的重要性，要根据数据范围和特点选择合适的算法。
- **bymlg001**：解释了 Dijkstra 不行的原因，是因为边数较多，Dijkstra 用边更新容易被卡，而 SPFA 用点更新更合适，并且提醒使用动态邻接表避免内存爆炸，体现了对数据结构和算法复杂度的理解。 

---
处理用时：49.91秒
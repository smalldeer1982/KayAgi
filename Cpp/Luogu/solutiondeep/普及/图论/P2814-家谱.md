# 题目信息

# 家谱

## 题目背景

现代的人对于本家族血统越来越感兴趣。


## 题目描述

给出充足的父子关系，请你编写程序找到某个人的最早的祖先。


## 说明/提示

规定每个人的名字都有且只有 $6$ 个字符，而且首字母大写，且没有任意两个人的名字相同。最多可能有 $10^3$ 组父子关系，总人数最多可能达到 $5 \times 10^4$ 人，家谱中的记载不超过 $30$ 代。

## 样例 #1

### 输入

```
#George
+Rodney
#Arthur
+Gareth
+Walter
#Gareth
+Edward
?Edward
?Walter
?Rodney
?Arthur
$```

### 输出

```
Edward Arthur
Walter Arthur
Rodney George
Arthur Arthur```

# AI分析结果

### 综合分析与结论
本题核心是利用并查集解决家谱中查找最早祖先的问题，难点在于处理字符串形式的人名。各题解思路大致相同，但在人名处理和并查集实现细节上有差异。多数题解使用并查集结合数据结构处理人名，如`map`、哈希表、`Trie`树等；少数采用暴力搜索。

### 高评分题解
- **作者：zhmshitiancai（5星）**
    - **关键亮点**：思路清晰，代码简洁，使用`map`直接将人名映射，避免复杂的编号转换，路径压缩优化查找效率。
    - **核心代码**：
```cpp
#include<cstdio>
#include<iostream>
#include<map>
using namespace std;
map<string,string>p;
string find(string x)
{
    if(x!=p[x]) 
        p[x]=find(p[x]);
    return  p[x];
}
string s,s1;
int main()
{
    char ch;
    cin>>ch;
    while(ch!='$')
    {
        cin>>s;
        if(ch=='#')
        {
            s1=s;
            if(p[s]=="") p[s]=s;
        }
        else if(ch=='+')
            p[s]=s1;
        else 
            cout<<s<<' '<<find(s)<<endl;    
        cin>>ch;
    }
    return 0;
}
```
    - **核心思想**：用`map<string, string> p`存储父子关系，`find`函数进行路径压缩查找祖先。根据输入的字符判断是父亲、儿子还是查询操作，更新`map`或输出结果。

- **作者：Station（4星）**
    - **关键亮点**：使用`map`简洁实现人名映射，记忆化DFS查找祖先，代码可读性高。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,string> fa;
string father,now,lst;
inline string getfa(string x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}
int main(){
    char ch=getchar();
    while (ch!='$'){
        cin>>now;getchar();
        if (ch=='#'){
            father=now;
            if (fa[father]=="") fa[father]=father;
        }else
        if (ch=='+') fa[now]=father;else cout<<now<<" "<<getfa(now)<<endl;
        ch=getchar();
    }
    return 0;
}
```
    - **核心思想**：`map<string, string> fa`存储父子关系，`getfa`函数递归查找祖先并进行路径压缩。根据输入字符更新父子关系或输出查询结果。

- **作者：岸芷汀兰（4星）**
    - **关键亮点**：清晰阐述思路，使用`map`实现字符串并查集，代码规范。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<map>
using namespace std;
const int maxn=50005;
string a[maxn];
int fa[maxn],n;
map<string,string>father;
string find(string x){
    if(x==father[x])return x;
    return father[x]=find(father[x]);
}
int main()
{
    string f1;
    while(1){
        char op=getchar();
        string str;
        if(op=='#'){
            cin>>f1;
            if(father[f1]=="")father[f1]=f1;
        }
        else if(op=='?'){
            cin>>str;
            cout<<str<<" "<<find(str)<<endl;
        }
        else if(op=='+'){
            cin>>str;
            father[str]=f1;
        }
        else if(op=='$')break;
    }
    return 0;
}
```
    - **核心思想**：`map<string, string> father`存储父子关系，`find`函数递归查找祖先并路径压缩。根据输入字符更新父子关系或输出查询结果。

### 最优关键思路与技巧
- **数据结构**：使用`map`可方便实现字符串到字符串或字符串到编号的映射，简化人名处理。
- **算法优化**：并查集路径压缩可显著提高查找效率。
- **代码实现技巧**：使用`map`避免手动编号和查找，代码更简洁。

### 拓展思路
同类型题可拓展到其他需要处理字符串关系的并查集问题，如社交网络中查找共同祖先、文件系统中查找根目录等。类似算法套路是将复杂数据类型通过映射转化为简单类型处理，再使用经典算法解决问题。

### 洛谷相似题目推荐
- P3367 【模板】并查集
- P1551 亲戚
- P1892 [BOI2003]团伙

### 个人心得摘录与总结
- **作者：arthurwalnut**：因字符串换行符读入问题花费大量时间调试，提醒注意输入处理细节。
- **作者：Kwork**：题面和样例误导，C++字符串读入慢，用`getchar()`读入需注意换行符，复杂关系处理易出错，要仔细设计逻辑。 

---
处理用时：37.77秒
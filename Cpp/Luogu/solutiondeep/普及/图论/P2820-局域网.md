# 题目信息

# 局域网

## 题目背景

某个局域网内有 $n$ 台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用 $f(i,j)$ 表示 $i,j$ 之间连接的畅通程度，$f(i,j)$ 值越小表示 $i,j$ 之间连接越通畅，$f(i,j)$ 为 $0$ 表示 $i,j$ 之间无网线连接。

## 题目描述

现在需要解决回路问题，我们将除去一些连线，使得网络中没有回路，**不改变原图节点的连通性**，并且被除去网线的 $\sum f(i,j)$ 最大，请求出这个最大值。

## 说明/提示

对于全部数据，保证 $1\le n \le 100$，$1\le f(i,j)\le 1000$。


## 样例 #1

### 输入

```
5 5
1 2 8
1 3 1
1 5 3
2 4 5
3 4 2
```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
本题的核心是将问题转化为最小生成树问题，即求被除去网线的 $\sum f(i,j)$ 最大，等价于求剩余边权总和最小的最小生成树，然后用总边权减去最小生成树的边权得到答案。

题解主要运用了Kruskal和Prim两种算法：
- **Kruskal算法**：将所有边按边权从小到大排序，使用并查集判断边的两个端点是否在同一集合，若不在则加入最小生成树并合并集合，直到边数达到 $n - 1$ 条。
- **Prim算法**：从一个点开始，每次选择与已加入最小生成树的点相连的边中权值最小的边，将对应的点加入最小生成树，直到所有点都被加入。

### 所选题解
- **作者：Rocket_raccoon_ (赞：30)，4星**
    - **关键亮点**：思路清晰，详细介绍了Kruskal算法和并查集的使用，代码注释丰富，可读性高。
    - **个人心得**：无

### 重点代码
#### Kruskal算法核心代码（以Rocket_raccoon_的题解为例）
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,f[200],ans,x,sum;
struct lol{
    int from,to,val;
}l[20010];
bool cmp(lol a, lol b){
    return a.val<b.val;
}
int find(int x){
    if (f[x]==x) return x;
    else return f[x]=find(f[x]);
}
void Kuskal(){
    int a,b;
    sort(l+1,l+1+m,cmp);
    for (int i=1; i<=m; i++){
        a=find(l[i].from); b=find(l[i].to);
        if (a==b) continue;
        sum+=l[i].val;
        f[a]=b;
        x++;
        if (x==n) return;
    }
}
int main(){
    int i;
    cin>>n>>m;
    for (i=1; i<=n; i++){
        f[i]=i;
    }
    for (i=1; i<=m; i++){
        scanf("%d%d%d",&l[i].from,&l[i].to,&l[i].val);
        ans+=l[i].val;
    }
    Kuskal();
    printf("%d",ans-sum);
    return 0;
}
```
**核心实现思想**：
1. 定义结构体存储边的信息，使用 `cmp` 函数按边权从小到大排序。
2. 实现并查集的 `find` 函数，用于查找节点的祖先。
3. 在 `Kuskal` 函数中，遍历排序后的边，若边的两个端点不在同一集合，则加入最小生成树并合并集合。
4. 最后用总边权减去最小生成树的边权得到答案。

#### Prim算法核心代码（以Kevin_F的题解为例）
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring> 
using namespace std;

int n,m,a,b,c;
int sum;
int g[1001][1001],minn[1001];
bool u[1001];

int main(){
    memset(g,0x7f,sizeof(g));
    memset(minn,0x7f,sizeof(minn));
    memset(u,true,sizeof(u));
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>a>>b>>c;
        g[a][b] = g[b][a] = c;
        sum += c;
    }
    minn[1]=0;
    for(int i=1;i<=n;i++){
        int k=0;
        for(int j=1;j<=n;j++)
            if(u[j] && minn[j] < minn[k])
                k = j;
        u[k] = false;
        for(int j=1;j<=n;j++)
            if(u[j] && g[k][j] < minn[j])
                minn[j] = g[k][j];
    }
    int total = 0;
    for(int i=1;i<=n;i++)
        total += minn[i];
    cout<<sum - total<<endl;
    return 0;
}
```
**核心实现思想**：
1. 使用邻接矩阵 `g` 存储图的信息，`minn` 数组存储未加入最小生成树的节点到已加入节点的最小边权。
2. 从节点1开始，每次选择 `minn` 数组中值最小的节点加入最小生成树，并更新 `minn` 数组。
3. 最后用总边权减去最小生成树的边权得到答案。

### 最优关键思路或技巧
- **问题转化**：将求被除去网线的 $\sum f(i,j)$ 最大转化为求最小生成树问题，简化了问题的解决思路。
- **并查集优化**：在Kruskal算法中使用并查集判断边的两个端点是否在同一集合，时间复杂度较低。
- **排序优化**：对边按边权从小到大排序，方便选择最小边权的边加入最小生成树。

### 可拓展之处
- **同类型题**：最小生成树的变种问题，如最大生成树（将边权从大到小排序）、次小生成树等。
- **类似算法套路**：在图论问题中，若需要在图中选择一些边使得图满足某些条件（如连通、无环等），可以考虑使用最小生成树算法。

### 推荐题目
- [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
- [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195)
- [P2872 [USACO07DEC]Building Roads S](https://www.luogu.com.cn/problem/P2872)

### 个人心得摘录与总结
- **0x小风**：提到本题是3366的改编，发现只要把全部的边权加起来然后减去最小生成树的边权即可，5分钟就AC了两题，说明对相似题目的总结和迁移能力很重要。
- **Kwork**：交了3遍才发现代码中 `k` 写成了 `n`，提醒我们在编码过程中要仔细检查变量名的使用，避免低级错误。

---
处理用时：42.47秒
# 题目信息

# 【模板】负环

## 题目描述

给定一个 $n$ 个点的有向图，请求出图中是否存在**从顶点 $1$ 出发能到达**的负环。

负环的定义是：一条边权之和为负数的回路。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq n \leq 2 \times 10^3$，$1 \leq m \leq 3 \times 10^3$。
- $1 \leq u, v \leq n$，$-10^4 \leq w \leq 10^4$。
- $1 \leq T \leq 10$。

#### 提示

请注意，$m$ **不是**图的边数。

## 样例 #1

### 输入

```
2
3 4
1 2 2
1 3 4
2 3 1
3 1 -3
3 3
1 2 3
2 3 4
3 1 -8
```

### 输出

```
NO
YES
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕判断有向图中从顶点 1 出发能到达的负环展开，涉及 Floyd、Bellman - Ford、SPFA、DFS - SPFA 等算法。其中 SPFA 算法使用最为频繁，因其能处理负边权和负环情况。各题解在判断负环的方式上有所不同，主要有判断入队次数、松弛次数、最短路径边数等。部分题解还给出了求出具体负环的方法。

### 所选题解
- **作者：Singercoder（5星）**
    - **关键亮点**：思路清晰，详细阐述了判断负环的原理，指出判断入队次数比松弛次数更稳，并给出了 hack 数据和分析。还提供了两种 SPFA 判断负环的代码，一种基于入队次数，另一种基于最短路径边数，避免了极限数据爆 int 的问题。
    - **个人心得**：在写差分约束时发现新的 hack 数据，思考后得出用入队次数判断负环更稳定的结论。
- **作者：iMya_nlgau（4星）**
    - **关键亮点**：系统介绍了 Bellman - Ford 和 SPFA 两种判断负环的方法，对每种方法的原理和复杂度进行了分析，并给出了基于 SPFA 记录最短路经过边数判负环的代码，代码结构清晰。
- **作者：AzzyZhe（4星）**
    - **关键亮点**：总结了 Floyd、SPFA、DFS - SPFA、Bellman - Ford 四种判断负环的方法，给出了每种方法的代码和复杂度分析，还介绍了求出具体负环的方法，内容全面。

### 重点代码
#### Singercoder（基于最短路径边数的 SPFA）
```cpp
void spfa()
{
    fill(dis + 1, dis + n + 1, inf);
    memset(cnt, 0, sizeof(cnt));
    memset(vis, 0, sizeof(vis));

    while (!q.empty()) q.pop();
    dis[1] = 0; vis[1] = 1; q.push(1);

    int u, v, w;
    while (!q.empty())
    {
        u = q.front(); vis[u] = 0; q.pop();
        for (int i = eh[u]; i!= -1; i = e[i].next)
        {
            v = e[i].v; w = e[i].w;
            if (dis[u] + w < dis[v])
            {
                dis[v] = dis[u] + w;
                cnt[v] = cnt[u] + 1; 
                if (cnt[v] >= n)
                {
                    printf("YES\n");
                    return;
                }
                if (!vis[v])
                {
                    vis[v] = 1; q.push(v);
                }
            }
        }
    }
    printf("NO\n");
}
```
**核心实现思想**：使用 SPFA 算法，在更新最短路径时记录最短路径的边数，若某个点的最短路径边数大于等于 n，则存在负环。

#### iMya_nlgau（基于 SPFA 记录最短路经过边数判负环）
```cpp
bool spfa()
{
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    memset(cnt, 0, sizeof(cnt));
    dis[1] = 0; vis[1] = true;
    Q.push(1);
    while (!Q.empty())
    {
        int x = Q.front();
        Q.pop();
        vis[x] = false;
        for (int i = head[x]; i; i = edge[i].next)
        {
            int y = edge[i].to, z = edge[i].w;
            if (dis[y] > dis[x] + z)
            {
                dis[y] = dis[x] + z;
                cnt[y] = cnt[x] + 1;
                if (cnt[y] >= n) return true;
                if (!vis[y])
                {
                    Q.push(y);
                    vis[y] = true;
                }
            }
        }
    }
    return false;
}
```
**核心实现思想**：同样使用 SPFA 算法，更新最短路径时更新最短路包含的边数，若边数大于等于 n 则判定存在负环。

#### AzzyZhe（SPFA 算法求负环）
```cpp
int spfa(int s)
{
    memset(vis, 0, sizeof(vis));
    memset(dis, 0x7f, sizeof(dis));
    memset(cnt, 0, sizeof(cnt));
    while (!q.empty())
        q.pop();
    vis[s] = 1;
    dis[s] = 0;
    q.push(s);
    while (!q.empty())
    {
        int u = q.front();
        vis[u] = 0;
        q.pop();
        for (int i = head[u]; i; i = e[i].next)
        {
            int v = e[i].v;
            if (dis[v] > dis[u] + e[i].w)
            {
                dis[v] = dis[u] + e[i].w;
                if (!vis[v])
                {
                    if (++cnt[v] > n)
                        return 1;
                    q.push(v);
                    vis[v] = 1;
                }
            }
        }
    }
    return 0;
}
```
**核心实现思想**：利用 SPFA 算法，判断一个点的入队次数是否超过 n，若超过则存在负环。

### 最优关键思路或技巧
- **判断负环方式**：判断入队次数比松弛次数更稳定，可避免重边导致的误判；判断最短路径边数可避免极限数据爆 int 的问题。
- **数据结构**：使用链式前向星或 vector 存储图，方便边的添加和遍历。

### 拓展思路
同类型题或类似算法套路：
- 差分约束系统问题，可转化为图论中的最短路问题，通过判断负环来确定是否有解。
- 网络流中的负环问题，在费用流中可能会涉及到负环的判断和处理。

### 推荐题目
- P5960 【模板】差分约束算法
- P1993 小 K 的农场
- P3275 [SCOI2011]糖果

### 个人心得总结
- Singercoder 在写差分约束时发现新的 hack 数据，意识到判断入队次数比松弛次数更稳。
- fzj2007 猜测建边与边权有关的原因是负权边建双向边会直接出现负环。
- AzzyZhe 提到本题是多组数据，要重置链式向前星的 head 数组和加边计数，自己曾犯过此错误。 

---
处理用时：42.84秒
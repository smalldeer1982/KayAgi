# 题目信息

# 图的遍历

## 题目描述

给出 $N$ 个点，$M$ 条边的有向图，对于每个点 $v$，求 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。

## 说明/提示

- 对于 $60\%$ 的数据，$1 \leq N,M \leq 10^3$。
- 对于 $100\%$ 的数据，$1 \leq N,M \leq 10^5$。

## 样例 #1

### 输入

```
4 3
1 2
2 4
4 3```

### 输出

```
4 4 3 4```

# AI分析结果

### 综合分析与结论
本题主要求解有向图中每个点出发能到达的编号最大的点。题解思路主要分为两类：一是反向建边，从大到小遍历节点；二是使用缩点算法处理强连通分量。

反向建边思路：将原问题转化为从编号大的点出发，能反向到达哪些点，每个点只访问一次，保证答案最优，时间复杂度低。

缩点思路：先使用Tarjan算法找出强连通分量并缩点，记录每个分量中编号最大的点，再在缩点后的图上进行DFS或拓扑排序DP求解，能有效处理图中的环。

### 所选题解
- **作者：hongzy（5星）**
    - **关键亮点**：思路清晰，代码简洁，详细解释了反向建边和DFS的原理，每个点只访问一次，时间复杂度低。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

#define MAXL 100010

int N, M, A[MAXL];
vector<int> G[MAXL]; //vector存图 

void dfs(int x, int d) {
    if(A[x]) return; //访问过 
    A[x] = d;
    for(int i=0; i<G[x].size(); i++)
        dfs(G[x][i], d);
}

int main() {
    int u, v;
    scanf("%d%d", &N, &M);
    for(int i=1; i<=M; i++) {
        scanf("%d%d", &u, &v);
        G[v].push_back(u); //反向建边 
    }
    for(int i=N; i; i--) dfs(i, i); 
    for(int i=1; i<=N; i++) printf("%d ", A[i]);
    printf("\n");
    return 0;
}
```
**核心实现思想**：反向建图后，从编号大的点开始DFS，若节点未被访问过，则将其答案设为当前点编号，并继续DFS其邻接节点。

- **作者：subarude（4星）**
    - **关键亮点**：提供了缩点 + DFS和反着建图 + DFS两种解法，详细介绍了Tarjan缩点的过程和原理，代码注释清晰。
    - **个人心得**：一开始写的代码被机房大佬讽刺，意识到不同算法的优劣和适用场景。
    - **核心代码（缩点 + DFS）**：
```cpp
//Tarjan缩点
void Tarjan(int u) {
    dfn[u] = low[u] = ++Time;
    vis[u] = 1;
    s[++r] = u;
    int R = r;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (!dfn[v]) {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        num++;
        for (int i = R; i <= r; i++) {
            vis[s[i]] = 0;
            belong[s[i]] = num;
            rep[num] = max(rep[num], s[i]);
        }
        r = R - 1;
    }
}

//重新建图
void rebuild() {
    cnt = 0;
    memset(head, 0, sizeof head);
    for (int i = 1; i <= m; i++) {
        int x = e[i].from, y = e[i].to;
        if (belong[x] == belong[y]) continue;
        add_edge(belong[x], belong[y]);
    }
}

//DFS求解
void dfs(int u) {
    if (ans[u]) return;
    ans[u] = rep[u];
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        dfs(v);
        ans[u] = max(ans[u], ans[v]);
    }
}
```
**核心实现思想**：先使用Tarjan算法找出强连通分量并缩点，记录每个分量中编号最大的点，重新建图后，在缩点后的图上进行DFS求解。

### 最优关键思路或技巧
- **反向建边**：将原问题转化为从编号大的点出发反向遍历，每个点只访问一次，避免重复计算，时间复杂度为$O(n + m)$。
- **缩点算法**：使用Tarjan算法处理图中的环，将强连通分量缩成一个点，简化问题，再在缩点后的有向无环图上进行求解。

### 可拓展之处
- **同类型题**：求有向图中每个点出发能到达的编号最小的点、求有向图中每个点出发能到达的点的数量等。
- **类似算法套路**：在处理有向图问题时，若存在环，可考虑使用缩点算法；若正向求解复杂，可尝试反向思考。

### 推荐题目
- P3387 【模板】缩点
- P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G
- P1262 间谍网络

### 个人心得摘录与总结
- **作者：shame_djj**：一开始直接排序更新只得了10分，意识到一遍更新可能不完，多次更新后得到80分，最后通过二分查找确定最小更新次数AC，说明算法的正确性和复杂度需要仔细考虑。
- **作者：Drifterming**：正着建边处理环有困难，拿掉判重数组多得了10分，每个点DFS100次后AC，体现了在无法找到最优解时，可尝试一些玄学方法。
- **作者：subarude**：写的缩点代码被机房大佬讽刺，认识到不同算法的优劣和适用场景，要不断学习和改进算法。 

---
处理用时：44.95秒
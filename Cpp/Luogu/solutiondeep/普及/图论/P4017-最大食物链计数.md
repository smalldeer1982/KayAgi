# 题目信息

# 最大食物链计数

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。


## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。


## 说明/提示

各测试点满足以下约定：

 ![](https://cdn.luogu.com.cn/upload/pic/12011.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕求有向无环图（DAG）中从入度为 0 的点到出度为 0 的点的路径数量展开，主要采用拓扑排序和记忆化搜索两种方法。拓扑排序通过删除入度为 0 的点并更新其邻接点的入度和路径数量，最终累加出度为 0 的点的路径数量；记忆化搜索则通过递归搜索并记录已搜索过的点的路径数量，避免重复计算。

### 所选题解
- **御·Dragon（5 星）**
    - **关键亮点**：思路清晰，从拓扑排序定义入手，详细分析题目性质，通过图文结合的方式展示模拟操作过程，代码注释详细。
    - **核心代码**：
```cpp
while(!q.empty())
{
    int tot = q.front();
    q.pop();
    int len = nei[tot].size(); 
    for(rg int i = 0;i < len; ++i)
    {
        int next = nei[tot][i]; 
        --in[next];
        num[next] = (num[next] + num[tot]) % mod;
        if(in[next] == 0)q.push(nei[tot][i]);
    }
}
```
    - **核心思想**：利用拓扑排序，将入度为 0 的点依次出队，更新其邻接点的路径数量，直到队列为空。
- **__Watcher（4 星）**
    - **关键亮点**：详细解释了使用拓扑排序的思维过程，提供了邻接矩阵和邻接表两种实现方式，并给出了优化方法和实测时空规模。
    - **核心代码（邻接表）**：
```cpp
while(!q.empty())
{
    int a = q.front();
    q.pop();
    for(int k = h[a];k;k = d[k].n)
    {
        int b = d[k].b;
        f[b] += f[a];
        f[b] %= mod;
        ru[b]--;
        if(ru[b] == 0)
        {
            if(chu[b] == 0)
            {
                ans += f[b];
                ans %= mod;
            }
            else q.push(b);
        }
    }
}
```
    - **核心思想**：使用邻接表存储图，通过拓扑排序更新每个点的路径数量，累加出度为 0 的点的路径数量。
- **来日方长（4 星）**
    - **关键亮点**：采用记忆化深搜的方法，思路清晰，代码简洁，在输入时记录每个点的出度和入度，从入度为 0 的点开始搜索，遇到出度为 0 的点返回 1。
    - **核心代码**：
```cpp
int dfs(int st)
{
    if(!du[st]) return 1;
    if(sa[st]) return sa[st];
    int sum = 0;
    for(Re int i = head[st];i;i = edge[i].nex)
        sum = (sum + dfs(edge[i].to)) % Mod;
    sa[st] = sum % Mod;
    return sa[st];
}
```
    - **核心思想**：通过记忆化搜索，记录每个点最终能通向出度为 0 的点的路径数量，避免重复计算。

### 最优关键思路或技巧
- **数据结构**：使用邻接表存储图可以减少空间复杂度，提高算法效率。
- **算法优化**：采用拓扑排序和记忆化搜索可以避免重复计算，降低时间复杂度。
- **思维方式**：将题目转化为图论问题，通过分析图的性质（入度、出度）来解决问题。

### 拓展思路
同类型题或类似算法套路：
- 求 DAG 中的最长路径、最短路径。
- 求 DAG 中满足特定条件的路径数量。
- 利用拓扑排序进行任务调度、课程安排等问题。

### 推荐题目
- [P1113 杂务](https://www.luogu.com.cn/problem/P1113)：拓扑排序求最长路径。
- [P3243 [HNOI2015]菜肴制作](https://www.luogu.com.cn/problem/P3243)：拓扑排序的变种。
- [P1685 游览计划](https://www.luogu.com.cn/problem/P1685)：记忆化搜索解决路径问题。

### 个人心得摘录与总结
- **归山_**：做题时一开始思路错误，浪费时间，提醒我们要仔细分析题目，找准思路。
- **EarthGiao**：尝试 DP 失败后改用记忆化搜索成功，说明不同算法在不同题目中的适用性不同，要灵活选择。
- **邱彦祖**：朴素搜索会超时，采用记忆化搜索可以避免重复计算，强调了算法优化的重要性。 

---
处理用时：33.42秒
# 题目信息

# [USACO15FEB] Superbull S

## 题目描述

Bessie 和她的朋友们正在一年一度的 Superbull 锦标赛中比赛，Farmer John 负责让比赛尽可能精彩。总共有 $N$ $(1 \leq N \leq 2000)$ 支队伍参加 Superbull。每支队伍都被分配了一个唯一的整数队伍 ID，范围在 $1 \ldots 2^{30}-1$ 之间，用于区分不同队伍。Superbull 是淘汰制比赛——每场比赛后，Farmer John 会选择淘汰其中一支队伍，被淘汰的队伍将不再参与后续比赛。当只剩一支队伍时，Superbull 结束。

Farmer John 发现比赛得分有一个特殊性质：任意一场比赛中，两支队伍的得分总和总是等于两队 ID 的按位异或（XOR）。例如，若队伍 12 和 20 比赛，则该场比赛总得分为 $24$，因为 $01100 \oplus 10100 = 11000$（即 $12 \oplus 20 = 24$）。

Farmer John 认为比赛总得分越高越精彩。因此，他希望安排一系列比赛，使得 Superbull 所有比赛的总得分最大化。请帮助他设计比赛方案。

## 说明/提示

**输出样例解释**：  
一种获得 37 分的方案如下：  
1. Farmer John 让队伍 3 和 9 比赛，选择淘汰 9，此时剩余队伍为 6、9、10  
2. 让队伍 6 和 9 比赛，选择淘汰 9，此时剩余队伍为 6 和 10  
3. 最后让队伍 6 和 10 比赛  
总得分为 $(3 \oplus 9) + (6 \oplus 9) + (6 \oplus 10) = 10 + 15 + 12 = 37$。

**关于按位异或**：  
按位异或运算（记作 $\oplus$）对两个二进制数的每一位进行逻辑异或操作。当且仅当某一位上两个数不同时，结果的该位为 1。例如：  
$10100$（十进制 20）$\oplus$ $01100$（十进制 12）$= 11000$（十进制 24）

## 样例 #1

### 输入

```
4
3
6
9
10```

### 输出

```
37```

# AI分析结果

### 综合分析与结论
这些题解的核心思路高度一致，均是将比赛问题转化为完全图，通过构建边权为队伍 ID 异或值的图，进而求解最大生成树。在实现最大生成树时，主要采用了 Kruskal 和 Prim 两种算法。Kruskal 算法的时间复杂度为 $O(m\log{m})$，适用于稀疏图；Prim 算法的时间复杂度为 $O(n^2)$，在稠密图（如本题的完全图）中效率更高。

### 所选题解
- **作者：zylll（4星）**
  - **关键亮点**：采用 Prim 算法，思路清晰，代码简洁，接近模板，适合学习 Prim 算法。
  - **核心代码**：
```cpp
void Prim(){
    for(int i=1,x=0;i<=n;i++,x=0){
        for(int j=1;j<=n;j++)if(!vis[j])
            if(key[j]>=key[x])x=j;
        vis[x]=true;
        for(int y=1;y<=n;y++)
            if(!vis[y])key[y]=max(key[y],a[x]^a[y]);
    }
}
```
  - **核心实现思想**：每次从未访问的节点中选择距离已访问节点集合最远（边权最大）的节点加入集合，然后更新未访问节点到已访问节点集合的最大距离。

- **作者：zhangboju（4星）**
  - **关键亮点**：详细对比了 Kruskal 和 Prim 算法的复杂度，并给出了两种算法的代码实现，同时配有图片辅助理解，讲解全面。
  - **核心代码（Prim 算法）**：
```cpp
for(int i=0;i<n;i++)
{
    int t=-1;
    for(int j=1;j<=n;j++)
    {
        if(!vis[j]&&(t==-1||dis[j]>dis[t])) t=j;
    }
    if(i) res+=dis[t];
    vis[t]=true; 
    for(int j=1;j<=n;j++)
    {
        dis[j]=max(dis[j],g[t][j]);
    }
}
```
  - **核心实现思想**：与 zylll 的 Prim 算法实现类似，每次选择距离已访问节点集合最远的节点加入集合，更新未访问节点到已访问节点集合的最大距离。

### 最优关键思路或技巧
- **思维方式**：将比赛问题抽象为图论中的最大生成树问题，通过分析比赛规则和得分机制，建立图的模型，利用图论算法求解。
- **算法选择**：根据图的稠密程度选择合适的算法，对于稠密图选择 Prim 算法，可降低时间复杂度。
- **代码实现**：使用并查集来实现 Kruskal 算法中的判断节点是否连通的操作，使用优先队列或简单遍历实现 Prim 算法中的选择最大边权的操作。

### 可拓展之处
同类型题或类似算法套路：
- 最小生成树问题：如求最小生成树的权值和，可使用 Kruskal 或 Prim 算法。
- 图的连通性问题：判断图是否连通，可使用并查集或深度优先搜索。
- 带权图的路径问题：如求最短路径、最长路径等，可使用 Dijkstra、Floyd 等算法。

### 推荐题目
- [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
- [P1194 买礼物](https://www.luogu.com.cn/problem/P1194)
- [P1991 无线通讯网](https://www.luogu.com.cn/problem/P1991)

### 个人心得摘录与总结
- **zhangboju**：在使用 Kruskal 算法时，由于边的数量较多，时间复杂度较高，可能会超时，而 Prim 算法在稠密图中效率更高，可避免超时问题。总结：在选择算法时，要根据图的特点和数据规模选择合适的算法，避免超时。

---
处理用时：26.44秒
# 题目信息

# [USACO19JAN] Grass Planting S

## 题目背景

USACO 一月月赛银组第一题

## 题目描述

到了一年中 Farmer John 在他的草地里种草的时间了。整个农场由 $N$ 块草地组成（$1 \leq N \leq 10^5$），方便起见编号为 $1 \ldots N$，由 $N-1$ 条双向的小路连接，每块草地都可以经过一些小路到达其他所有的草地。
Farmer John 当然可以在每块草地里种不同种类的草，但是他想要使得使用的草的种类数最小，因为他用的草的种类数越多，他就需要负担更高的花费。

不幸的是，他的奶牛们对选择农场上的草表现得十分苛刻。如果两块相邻（由一条小路直接相连）的草地种了同一种草，或者即使是两块接近相邻（均可由一条小路直接连向同一块草地）的草地，那么奶牛们就会抱怨她们进餐的选择不够多样。Farmer John 能做的只能是抱怨这些奶牛，因为他知道她们不能被满足的时候会制造多大的麻烦。

请帮助 Farmer John 求出他的整个农场所需要的最少的草的种类数。

## 说明/提示

在这个简单的例子中，4 块草地以一条直线的形式相连。最少需要三种草。例如，Farmer John 可以用草 $A,B,C$ 将草地按 $A - B - C - A$ 的方式播种。

## 样例 #1

### 输入

```
4
1 2
4 3
2 3```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕找出图中度数最大的点，然后将其度数加 1 得到最少草的种类数这一核心思路展开。大部分题解通过统计各点度数并找出最大值来实现，部分使用了链式前向星、vector 等数据结构存图，还有一题采用树形 dp 求解。
### 所选题解
- **作者：Polarnova（5 星）**
    - **关键亮点**：思路清晰直接，代码简洁高效，通过简单的度数统计和比较得出结果。
    - **核心代码**：
```cpp
#include<cstdio>
int x,y,ans,n,deg[100007];
int main() {
    scanf("%d",&n);
    for(int i=1;i<n;i++) {
        scanf("%d%d",&x,&y);
        if(++deg[x]>ans)ans=deg[x];
        if(++deg[y]>ans)ans=deg[y];
    }
    printf("%d",ans+1);
    return 0;
}
```
    - **核心思想**：使用数组 `deg` 统计各点度数，在输入边时更新度数并记录最大值，最后输出最大值加 1。
- **作者：wwwttlll（4 星）**
    - **关键亮点**：代码简洁易懂，使用 `while(cin>>x>>y)` 方便输入，整体逻辑清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[200000];
int main(){
    cin>>n;
    int x,y;
    while(cin>>x>>y){
        a[y]++;
        a[x]++;
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        if(a[i]>ans){
            ans=a[i];
        }
    }
    ans+=1;
    cout<<ans;
}
```
    - **核心思想**：用数组 `a` 统计各点度数，输入结束后遍历数组找出最大度数，最后加 1 输出。
- **作者：45dino（4 星）**
    - **关键亮点**：通过具体样例画图辅助理解思路，代码简洁明了，容易理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,n,a[100001];
int main()
{
    cin>>n;
    for(int i=1;i<n;i++)
    {
        int x,y;
        cin>>x>>y;
        a[x]++;
        a[y]++;
        ans=max(a[x],max(a[y],ans));
    }
    cout<<ans+1;
    return 0;
}
```
    - **核心思想**：使用数组 `a` 统计各点度数，在输入边时更新度数并记录最大值，最后输出最大值加 1。
### 最优关键思路或技巧
- 思维方式：通过分析题目条件，发现只需关注图中度数最大的点，将其度数加 1 即为答案，简化了问题。
- 代码实现技巧：使用数组简单高效地统计各点度数，避免了复杂的数据结构。
### 可拓展之处
同类型题可能会在图的结构、约束条件等方面进行拓展，例如图中存在环、增加更多的颜色限制等。类似算法套路可用于解决一些需要根据节点相邻关系确定属性的问题，如染色问题、资源分配问题等。
### 推荐题目
- P1113 杂务
- P1341 无序字母对
- P1192 台阶问题
### 个人心得摘录与总结
- **作者：Alex_Wei**：一开始以为是 DFS + 模拟，结果 TLE 和 WA，后来仔细思考才发现是简单的求最大度数加 1 的问题。总结是遇到问题要仔细分析，不能盲目使用常规方法。
- **作者：LZOI_LYH**：第一次写题解，对题目的难度有自己的判断，认为题目评蓝题有点意外。提醒我们做题时要仔细观察样例，挖掘题目本质。 

---
处理用时：28.80秒
# 题目信息

# [Cnoi2020] 雷雨

## 题目背景

> 令人不安的云开始笼罩天空。  
巨大的建筑在强风中轧轧作响。  
幻想乡中响彻着不和协音。  
——「东方辉针城 ～ Double Dealing Character」

一个雷雨交加的夜晚，一束闪电击中了雾之湖畔的红魔馆和迷途竹林。

似乎有什么大事要发生，Cirno 在小屋静静地中思考着。

## 题目描述

幻想乡的纵切面可以抽象成一个 $n\times m$ 的矩形。

其中每一个 $1\times 1$ 的单元格 $(i,j)$ 都有一个**电阻计量值**(虚构的概念) $R_{i,j}$。

闪电从**雷雨云**上的 $\texttt{O}(n,a)$ 发出，击中了**地面**上的*红魔馆* $\texttt{A}(1,b)$ 与*迷途竹林* $\texttt{B}(1,c)$。

雷电是自然的造物，所以覆盖的位置电阻计量值总和最小，即从 $\texttt{O}$ 到 $\texttt{A}$ 与 $\texttt{B}$ 的**两条路径的并集**的电阻计量值的和最小。

所以在所有位置电阻计量已知的情况下，Cirno 想知道雷电的经过的路径的最小电阻计量值的和。

## 说明/提示

## 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/7ozs40i3.png)

如图黄色线为闪电的路径。

## 数据范围与约定

对于 $100\%$ 的数据保证：$0<n,m \le 1000$，$0 \le R_{i,j}\le 10^9$，$0< a,b,c \le m$。

#### 子任务「本题采用捆绑测试」

 - Subtask1（$10\%$）: $R_{i,j}\in\{1\}$。
 - Subtask2（$10\%$）: $R_{i,j}\in\{0,1\}$。
 - Subtask3（$10\%$）: $a=b=c$。
 - Subtask4（$10\%$）: $n,m \le 5$。
 - Subtask5（$60\%$）: 无特殊限制。
 

## 样例 #1

### 输入

```
5 5 1 2 4
1 8 1 6 6
1 1 1 2 4
8 3 1 2 2
1 2 1 9 1
1 0 9 1 1```

### 输出

```
15```

# AI分析结果

### 综合分析与结论
本题的核心在于求解从一个起点到两个终点的路径并集的最小电阻计量值和。各题解的主要思路均为枚举闪电的分叉点，通过从起点和两个终点分别跑最短路算法（如 Dijkstra 或优先队列 BFS），计算出每个分叉点到三个点的最短距离，最后找出所有分叉点中对应的路径和的最小值。

### 所选题解
- **作者：Unordered_OIer（5星）**
    - **关键亮点**：思路清晰，先提出用 DFS 求解但指出其复杂度高会超时，进而优化为 BFS，详细展示了思路的演变过程，代码注释清晰。
    - **个人心得**：“算是搜索的半模板题，只要转个弯就能够想到正解。~~既然如此你为什么考场上想不到。~~” 说明该题虽有思路可寻，但在考场上也可能一时难以想到。
- **作者：Lonely_NewYear（4星）**
    - **关键亮点**：代码规范，注释详细，对算法复杂度进行了分析，明确指出时间复杂度为 $O(nm\times log(nm))$ 可过，思路阐述简洁明了。
- **作者：InformationEntropy（4星）**
    - **关键亮点**：对问题的分析细致，明确指出需要注意的点，如用 Dijkstra + 堆优化、处理点权时要减去多算的分叉点电阻等，代码逻辑清晰。

### 重点代码及核心实现思想
#### Unordered_OIer 的 BFS 代码
```cpp
void bfs(ll t, ll tx, ll ty) {
    memset(v, 0, sizeof v);
    priority_queue<node> que;
    que.push((node){tx, ty, min_d[t][tx][ty]});
    while (!que.empty()) {
        node now = que.top(); que.pop();
        if (v[now.x][now.y]) continue;
        v[now.x][now.y] = 1;
        for (int i = 0; i < 4; i ++) {
            ll nx = now.x + dx[i], ny = now.y + dy[i];
            if (nx < 1 || nx > n || ny < 1 || ny > m || v[nx][ny]) continue;
            min_d[t][nx][ny] = min(min_d[t][nx][ny], min_d[t][now.x][now.y] + r[nx][ny]);
            que.push((node){nx, ny, min_d[t][nx][ny]});
        }
    }
}
```
**核心实现思想**：使用优先队列 BFS 从给定的源点 `(tx, ty)` 开始扩展，每次取出队列中距离最小的点，更新其相邻点的最短距离，并将未访问过的相邻点加入队列。

#### Lonely_NewYear 的 Dijkstra 代码
```cpp
void dijkstra(int k, int sx, int sy) {
    priority_queue<node> q;
    q.push((node){sx, sy, num[sx][sy]});
    bool vis[1001][1001]={0};
    for(int i=1;i<=1000;i++) {
        for(int j=1;j<=1000;j++) {
            dis[k][i][j]=1e18;
        }
    }
    dis[k][sx][sy]=num[sx][sy];
    while(!q.empty()) {
        int x=q.top().x,y=q.top().y;
        q.pop();
        if(vis[x][y]) continue;
        vis[x][y]=1;
        for(int i=0;i<4;i++) {
            int tx=x+dx[i],ty=y+dy[i];
            if(tx<1||tx>n||ty<1||ty>m) continue;
            if(dis[k][tx][ty]>dis[k][x][y]+num[tx][ty]) {
                dis[k][tx][ty]=dis[k][x][y]+num[tx][ty];
                q.push((node){tx, ty, dis[k][tx][ty]});
            }
        }
    }
}
```
**核心实现思想**：使用优先队列实现 Dijkstra 算法，从源点 `(sx, sy)` 开始，每次取出队列中距离最小的点，更新其相邻点的最短距离，并将未访问过的相邻点加入队列。

#### InformationEntropy 的 Dijkstra 代码
```cpp
inline void dijkstra(int sx, int sy, int p) {
    priority_queue<node>q;
    q.push((node){sx, sy, ma[sx][sy]});
    memset(vis, 0, sizeof(vis));
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=m; j++) {
            dis[p][i][j]=inf;
        }
    }
    dis[p][sx][sy]=ma[sx][sy];
    while(!q.empty()) {
        node h=q.top();
        q.pop();
        int x=h.minx;
        int y=h.miny;
        if(vis[x][y]) continue;
        vis[x][y]=1;
        for(int i=0; i<4; i++) {
            int xx=x+dx[i];
            int yy=y+dy[i];
            if(xx>=1&&xx<=n&&yy>=1&&yy<=m) {
                if(dis[p][xx][yy]>dis[p][x][y]+ma[xx][yy]) {
                    dis[p][xx][yy]=dis[p][x][y]+ma[xx][yy];
                    q.push((node){xx, yy, dis[p][xx][yy]});
                }
            }
        }
    }
}
```
**核心实现思想**：同样使用优先队列实现 Dijkstra 算法，从源点 `(sx, sy)` 开始，不断更新相邻点的最短距离，直到队列为空。

### 最优关键思路或技巧
- **枚举分叉点**：通过枚举闪电的分叉点，将问题转化为求三个点到分叉点的最短距离之和，避免了直接处理路径并集的复杂性。
- **优先队列优化**：使用优先队列（如优先队列 BFS 或 Dijkstra + 堆优化）来优化最短路算法，提高了算法效率。
- **处理点权**：在计算路径和时，注意减去多算的分叉点的电阻值，确保结果的正确性。

### 可拓展之处
同类型题或类似算法套路：
- 多源多汇的最短路问题，可通过枚举中间点，将问题转化为多个单源最短路问题。
- 路径并集或交集的优化问题，可采用类似的枚举和预处理最短路的方法。

### 推荐题目
- P1144 最短路计数：考察最短路算法及路径计数。
- P3371 单源最短路径（弱化版）：经典的单源最短路问题，可使用 Dijkstra 或 SPFA 求解。
- P4779 单源最短路径（标准版）：同样是单源最短路问题，对算法复杂度有一定要求，推荐使用 Dijkstra + 堆优化。

---
处理用时：49.29秒
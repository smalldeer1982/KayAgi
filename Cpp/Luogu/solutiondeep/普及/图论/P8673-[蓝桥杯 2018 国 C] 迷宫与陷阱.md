# 题目信息

# [蓝桥杯 2018 国 C] 迷宫与陷阱

## 题目描述

小明在玩一款迷宫游戏，在游戏中他要控制自己的角色离开一间由 $N \times N$ 个格子组成的二维迷宫。

小明的起始位置在左上角，他需要到达右下角的格子才能离开迷宫。

每一步，他可以移动到上下左右相邻的格子中（前提是目标格子可以经过）。

迷宫中有些格子小明可以经过，我们用 `.` 表示；

有些格子是墙壁，小明不能经过，我们用 `#` 表示。

此外，有些格子上有陷阱，我们用 `X` 表示。除非小明处于无敌状态，否则不能经过。

有些格子上有无敌道具，我们用 `%` 表示。

当小明第一次到达该格子时，自动获得无敌状态，无敌状态会持续 $K$ 步。

之后如果再次到达该格子不会获得无敌状态了。

处于无敌状态时，可以经过有陷阱的格子，但是不会拆除 / 毁坏陷阱，即陷阱仍会阻止没有无敌状态的角色经过。

给定迷宫，请你计算小明最少经过几步可以离开迷宫。

## 说明/提示

时限 3 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
5 3
...XX
##%#.
...#.
.###.
.....```

### 输出

```
10```

## 样例 #2

### 输入

```
5 1
...XX
##%#.
...#.
.###.
.....```

### 输出

```
12```

# AI分析结果

### 综合分析与结论
这些题解均采用广度优先搜索（BFS）算法来解决迷宫与陷阱问题，核心在于处理无敌道具和陷阱的情况。各题解的主要差异在于对访问状态的记录和剪枝优化方式。部分题解通过二维数组记录每个格子的最大无敌步数进行剪枝，避免重复访问；部分题解使用三维数组记录不同无敌时间下的访问状态。整体思路相近，但在代码实现和优化细节上有所不同。

### 所选题解
- **作者：Zaku (赞：30)，4星**
    - **关键亮点**：思路清晰，代码注释详细，通过在结构体中添加 `magic` 变量表示无敌状态剩余步数，并使用二维数组 `vis` 进行剪枝，若当前节点已访问且之前无敌步数更多，则不再访问，优化了搜索过程。
- **作者：_cpp (赞：3)，4星**
    - **关键亮点**：同样采用 BFS 算法，在 `edge` 结构体中添加 `invincible` 表示无敌步数，使用 `book` 数组进行剪枝，逻辑简洁明了。
- **作者：wuhan1234 (赞：2)，4星**
    - **关键亮点**：对 `vis` 数组的用法进行优化，将其初始值设为 -1，每次访问时比较当前无敌步数与 `vis` 数组中的值，若当前无敌步数更大则访问并更新，避免无效访问。

### 重点代码及核心思想
#### 作者：Zaku
```cpp
struct node{
    int x, y, step, magic;
};
int vis[N][N]; // 存储每个格子是否被访问过以及无敌状态剩余步数
// ...
while (q.size()){
    node t = q.front();
    q.pop();
    if (t.x == n && t.y == n){
        cout << t.step;
        return 0;
    }
    for (int i = 0; i < 4; i ++ ){
        int tx = t.x + dx[i];
        int ty = t.y + dy[i];
        if (g[tx][ty] == 'X' && t.magic == 0) continue;
        int magic = max(0, t.magic - 1);
        if (g[tx][ty] == '%') magic = k;
        if (tx >= 1 && tx <= n && ty >= 1 && ty <= n && vis[tx][ty] < magic && g[tx][ty] != '#'){
            vis[tx][ty] = magic;
            q.push({tx, ty, t.step + 1, magic});
        }
    }
}
```
**核心思想**：使用 BFS 搜索，结构体 `node` 记录坐标、步数和无敌步数。在搜索过程中，根据当前格子类型更新无敌步数，通过 `vis` 数组进行剪枝，避免重复访问。

#### 作者：_cpp
```cpp
struct edge{
    int x,y,invincible,sum;
};
int book[1001][1001];
// ...
while(!q.empty()){
    t = q.front();
    q.pop();
    if(t.x == n && t.y == n) return cout << t.sum,0;
    edge k;
    for(int i = 0;i < 4;i++){
        int dx,dy;
        dx = t.x + nx[i];
        dy = t.y + ny[i];
        if(a[dx][dy] == 'X' && t.invincible == 0) continue;
        if(a[dx][dy] == '#') continue;
        k.invincible = max(0,t.invincible - 1);
        if(a[dx][dy] == '%') k.invincible = x;
        if(dx >= 1 && dx <= n && dy >= 1 && dy <= n && k.invincible > book[dx][dy]){
            k.x = dx;
            k.y = dy;
            book[dx][dy] = k.invincible;
            k.sum = t.sum + 1;
            q.push(k);
        }
    }
}
```
**核心思想**：使用 BFS 搜索，结构体 `edge` 记录坐标、无敌步数和总步数。在搜索过程中，根据格子类型更新无敌步数，通过 `book` 数组进行剪枝，若当前无敌步数大于之前记录的步数则继续搜索。

#### 作者：wuhan1234
```c
struct Node
{
    int sta;   // 无敌状态剩余时间
    int x,y,step;
};
int vis[1001][1001];
// ...
while (front<rear)
{
    cur=q[front];
    front=(front+1)%MAXLEN;
    int sta=cur.sta;
    if (cur.x==n-1 && cur.y==n-1)
    {
        printf("%d\n",cur.step);
        return ;
    }
    for (int i=0;i<4;i++)
    {
        int nx=cur.x+dx[i];
        int ny=cur.y+dy[i];
        if (mp[nx][ny]=='%' && vis[nx][ny]<k)
        {
            vis[nx][ny]=k;
            q[rear].x=nx;  q[rear].y=ny;
            q[rear].step=cur.step+1;
            q[rear].sta=k;
            rear=(rear+1)%MAXLEN;
        }
        if (vis[nx][ny]<sta && judge(nx,ny,sta))
        {
            vis[nx][ny]=sta;
            q[rear].x=nx;  q[rear].y=ny;
            q[rear].step=cur.step+1;
            if (sta>=1) q[rear].sta=sta-1;
            else        q[rear].sta=0;
            rear=(rear+1)%MAXLEN;
        }
    }
}
```
**核心思想**：使用 BFS 搜索，结构体 `Node` 记录坐标、无敌步数和步数。在搜索过程中，根据格子类型更新无敌步数，通过 `vis` 数组进行剪枝，若当前无敌步数大于之前记录的步数则继续搜索。

### 最优关键思路或技巧
- **状态记录与剪枝**：使用二维数组记录每个格子的最大无敌步数，避免重复访问相同状态，提高搜索效率。
- **结构体存储状态**：通过结构体存储坐标、步数和无敌步数，方便在 BFS 过程中传递和更新状态信息。

### 可拓展之处
同类型题或类似算法套路包括带有特殊道具或状态的迷宫问题，如带有传送门、钥匙等道具的迷宫，可通过类似的状态记录和剪枝方法解决。还可以拓展到三维迷宫或更复杂的地图结构，只需相应地调整状态记录和搜索方向。

### 推荐洛谷题目
- P1135 奇怪的电梯
- P1605 迷宫
- P2895 [USACO08FEB]Meteor Shower S

### 个人心得
题解中未包含个人心得内容。

---
处理用时：43.65秒
# 题目信息

# [NOIP 2002 提高组] 均分纸牌

## 题目描述

有 $N$ 堆纸牌，编号分别为 $1,2,\ldots,N$。每堆上有若干张，但纸牌总数必为 $N$ 的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 $N$ 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如 $N=4$ 时，$4$ 堆纸牌数分别为 $9,8,17,6$。

移动 $3$ 次可达到目的：

- 从第三堆取 $4$ 张牌放到第四堆，此时每堆纸牌数分别为 $9,8,13,10$。
- 从第三堆取 $3$ 张牌放到第二堆，此时每堆纸牌数分别为 $9,11,10,10$。
- 从第二堆取 $1$ 张牌放到第一堆，此时每堆纸牌数分别为  $10,10,10,10$。


## 说明/提示

对于 $100\%$ 的数据，$1  \le  N  \le  100$，$1 \le  A_i  \le 10000$。

**【题目来源】**

NOIP 2002 提高组第一题

## 样例 #1

### 输入

```
4
9 8 17 6
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕“均分纸牌”问题展开，提供了线性算法和分治算法两种思路。线性算法通过从左到右遍历数组，根据当前堆与目标值的关系进行移动操作，复杂度为 $O(n)$；分治算法通过不断找到区间内最大值并对其左右区间递归处理，复杂度为 $O(n^2)$。

在解决难点方面，线性算法的正确性证明较为复杂，通过将分治算法得到的最优解用图建模，证明了线性算法与分治算法等价。同时，部分题解还对贪心算法的正确性进行了详细证明，解决了牌堆不能为负数的疑惑。

### 所选题解
- **monell（5星）**
    - **关键亮点**：提供了线性算法和分治算法两种思路，并对线性算法的正确性进行了详细证明，思路清晰，逻辑严谨。
    - **个人心得**：无
- **松风之狐（4星）**
    - **关键亮点**：思路简单直接，代码实现清晰易懂，适合初学者。
    - **个人心得**：无
- **ProtectEMmm（4星）**
    - **关键亮点**：对贪心算法的正确性进行了详细证明，解决了很多选手的疑惑，同时还提到了环形版本的拓展问题。
    - **个人心得**：感谢 `Cherishdevil` 提出问题，`SkyWave` 建议重新写题解，`小粉兔` 指出思路错误并给出新提示。

### 重点代码及核心实现思想
#### monell 的线性算法
```cpp
// 线性算法思路：从左到右遍历数组，根据当前堆与目标值的关系进行移动操作
for (int i = 0; i < n - 1; ++i) {
    if (a[i] > target) {
        a[i + 1] += a[i] - target;
        moves++;
    } else if (a[i] < target) {
        a[i + 1] -= target - a[i];
        moves++;
    }
}
```
核心实现思想：通过遍历数组，将多余的纸牌转移到下一堆，或者从下一堆支取所差的纸牌，同时记录移动次数。

#### 松风之狐的代码
```cpp
// 先计算平均数，然后将每堆纸牌数减去平均数
num /= n;
for (int i = 1; i <= n; i++) a[i] -= num;
// 从头遍历到尾，根据当前堆的纸牌数进行移动操作
for (int i = 1; i <= n; i++) {
    if (a[i] > 0) {
        a[i + 1] += a[i];
        a[i] = 0;
        ans++;
    } else if (a[i] < 0) {
        a[i + 1] -= abs(a[i]);
        a[i] = 0;
        ans++;
    }
}
```
核心实现思想：先将每堆纸牌数与平均数的差值计算出来，然后遍历数组，将多余的纸牌移动到下一堆，或者从下一堆移动缺少的纸牌，同时记录移动次数。

#### ProtectEMmm 的代码
```cpp
// 计算平均数
average /= n;
// 遍历数组，根据当前堆与平均数的关系进行移动操作
for (int i = 1; i + 1 <= n; ++i) {
    if (arr[i]!= average) {
        ans++;
        arr[i + 1] += arr[i] - average;
    }
}
```
核心实现思想：计算平均数后，遍历数组，若当前堆的纸牌数不等于平均数，则将差值转移到下一堆，同时记录移动次数。

### 最优关键思路或技巧
- **线性算法**：从左到右遍历数组，根据当前堆与目标值的关系进行移动操作，避免了复杂的分治过程，时间复杂度为 $O(n)$。
- **贪心思想**：每次只考虑当前堆与下一堆的关系，通过不断调整使每堆纸牌数达到平均值，从而得到最少的移动次数。
- **图建模**：将分治算法得到的最优解用图建模，通过证明图的性质来证明线性算法的正确性，为算法的正确性证明提供了一种有效的方法。

### 可拓展之处
- **环形版本**：如 `负载平衡问题`（[P4016](https://www.luogu.com.cn/problem/P4016)），可以通过找到一个断点将环形问题转化为线性问题。
- **多维数组**：可以将问题拓展到多维数组，如二维矩阵，需要考虑更多的移动规则和方向。

### 推荐题目
- [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：考察动态规划和路径规划的知识点。
- [P1216 [USACO1.5]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：经典的动态规划题目，与均分纸牌问题都需要通过状态转移来解决。
- [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：同样考察动态规划的思想，通过状态转移来计算方案数。

---
处理用时：27.35秒
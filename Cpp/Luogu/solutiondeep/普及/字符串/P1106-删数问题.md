# 题目信息

# 删数问题

## 题目描述

键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。

## 说明/提示

用 $\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \leq k < \operatorname{len}(n) \leq 250$。

## 样例 #1

### 输入

```
175438 
4
```

### 输出

```
13```

# AI分析结果

### 综合分析与结论
这些题解主要围绕删数问题展开，核心是通过贪心策略使删除指定数量数字后剩下的数字组成的新数最小。题解思路大致可分为两类：一类是直接删数，每次删除第一个递减区间的首字符或升序序列的最后一个字符；另一类是选数，在可选范围内选择最小的数。各题解在实现方式上有所不同，使用了字符串、数组、链表等数据结构，部分题解还涉及RMQ、DP等算法优化。解决的难点主要是前导零的处理和边界条件的判断。

### 所选题解
- **作者：expin（5星）**
    - **关键亮点**：思路清晰，采用贪心策略，每找出一个数就直接输出，避免存储中间结果，代码简洁高效。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#include<string>
using namespace std;
int n,k,a[257],rest,t=1,minp,cnt=0;
bool flag=0;
string num;
int main(){
    cin>>num>>k;
    n=num.length();
    for(int i=1;i<=n;++i)a[i]=num[i-1]-'0';
    rest=n-k;
    while(cnt<rest){
        minp=t;
        for(int i=t;i<=k+t;++i)if(a[minp]>a[i])minp=i;
        if(a[minp])flag=1;
        if(flag)cout<<a[minp];
        k-=minp-t;
        t=minp+1;
        cnt++;
    }
    if(!flag)cout<<0;
    return 0;
}
```
    - **核心实现思想**：在左边`m+1`个数中找到最小的数，记录其位置`t`，删除`t`左边的数，更新`m`和`t`，重复此过程直到选出`n-k`个数。

- **作者：修罗海神王（4星）**
    - **关键亮点**：通过具体例子引出规律，易于理解，代码逻辑清晰。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
string st;
int n,a[251],l,k;
int main()
{
    cin>>st;cin>>n;l=st.size();
    for(int i=0;i<l;i++) a[i]=st[i]-'0';
    for(int i=1;i<=n;i++)
      for(int j=0;j<l;j++)
        if(a[j]>a[j+1]) 
        {
            for(int k=j;k<l;k++) a[k]=a[k+1];
            l--; break;
        }
    int i=0; 
    while(a[i]==0&&k<l-1) {k++;i++;}
    for(int i=k;i<l;i++) cout<<a[i];
    return 0;
}
```
    - **核心实现思想**：每次找到第一个递减区间，删除该区间的首字符，重复`n`次，最后处理前导零。

- **作者：Sol1（4星）**
    - **关键亮点**：提出了反向考虑问题的思路，使用双向链表优化复杂度至$O(n)$。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;
string s;
int n, k, nxt[1000005], prv[1000005];
void Solve() {
    int start = 0;
    for (int i = 0;i < n - 1;i++) {
        nxt[i] = i + 1;
        prv[i + 1] = i;
    }
    prv[0] = -1;
    nxt[n - 1] = -1;
    for (int i = 1;i!= -1;i = nxt[i]) {
        int cur = prv[i];
        while (cur >= 0 && s[i] < s[cur]) {
            cur = prv[cur];
            k--;
            if (k == 0) break;
        }
        if (cur >= 0) {
            nxt[cur] = i;
            prv[i] = cur;
        } else {
            start = i;
            prv[i] = -1;
        }
        if (k == 0) break;
    }
    int siz = 0;
    for (int i = start;i!= -1;i = nxt[i]) {
        siz++;
    }
    bool flag = 0;
    siz -= k;
    for (int i = start;i!= -1 && siz;i = nxt[i], siz--) {
        if (s[i]!= '0') flag = 1;
        if (flag) putchar(s[i]);
    }
    if (!flag) putchar('0');
}
int main() {
    cin >> s >> k; n = s.length();
    Solve();
    return 0;
}
```
    - **核心实现思想**：考虑一个数可以删掉哪些数，使用双向链表维护序列，支持快速单点删除和快速求前驱后继，遍历过程中删除不符合条件的数。

### 最优关键思路或技巧
- **贪心策略**：每一步选择使剩下的数最小的数字删去，如删除第一个递减区间的首字符或升序序列的最后一个字符。
- **数据结构优化**：使用双向链表可以将复杂度优化至$O(n)$，如Sol1的题解。
- **反向思考**：将删数问题转换为选数问题，如KesdiaelKen的题解。

### 可拓展之处
同类型题或类似算法套路：
- 其他贪心删数问题，如删除指定数量的字符使字符串字典序最小。
- 区间最值问题，可使用RMQ、ST表等算法解决。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法和优先队列的使用。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：贪心算法的经典应用。
- [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)：需要巧妙的贪心策略和排序方法。

### 个人心得摘录与总结
- **Atmizz**：一开始WA了最后一个点，后来发现是数据需要去前导零，提醒我们要注意题目中的细节。
- **KillerXu**：连续犯了很多错误，如循环条件改变、前导零处理不当、代码混乱等，强调了理解题意、注意细节和保持代码整洁的重要性。
- **Lydia_Moon**：通过多次提交才发现问题，如输出的数最高位是0、输出太短等，告诉我们要仔细分析测试数据，逐步完善代码。

---
处理用时：49.75秒
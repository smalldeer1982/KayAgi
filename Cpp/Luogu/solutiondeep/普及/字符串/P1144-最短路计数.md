# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论
这些题解提供了多种思路和算法来解决最短路计数问题。主要算法包括BFS、Dijkstra、SPFA等，核心思路是在求最短路的过程中进行计数。当找到更短路径时，更新路径长度并重置计数；当路径长度相等时，累加计数。

### 所选题解
- **作者：ZiDing_ByronFinlso（5星）**
    - **关键亮点**：思路清晰，提供了SPFA和Dijkstra堆优化两种解法，并给出了运行时间对比。代码结构规范，注释详细。
    - **个人心得**：无
- **作者：岸芷汀兰（4星）**
    - **关键亮点**：明确指出使用BFS的原因，对题目中的难点（自环、重边、最短路计数）进行了详细分析。代码可读性高。
    - **个人心得**：无
- **作者：XZYQvQ（4星）**
    - **关键亮点**：指出了SPFA在某些情况下的问题，并提出先跑SPFA得到最短路长度，再用记忆化搜索得到答案的方法，具有一定的创新性。
    - **个人心得**：发现很多人用SPFA统计答案存在问题，自己写的也有问题，换题就不行，经过修改采用先SPFA再记忆化搜索的方法可以AC。

### 重点代码及核心实现思想
#### ZiDing_ByronFinlso - SPFA
```cpp
while(q.size())
{
    x=q.front();q.pop();
    p[x]=0;
    for(int i=head[x];i;i=nxt[i])
    {
        y=to[i];
        if(d[y]>d[x]+1)
        {
            d[y]=d[x]+1;
            ans[y]=ans[x];
            if(!p[y])
            {
                q.push(y);
                p[y]=1;
            }
        }
        else if(d[y]==d[x]+1)
        {
            ans[y]+=ans[x];
            ans[y]%=mod;
        }
    }
}
```
核心思想：在SPFA求最短路的过程中，当找到更短路径时，更新距离并将计数重置为前驱节点的计数；当路径长度相等时，累加计数。

#### 岸芷汀兰 - BFS
```cpp
while (q.size()) {
    int u = q.front().node, dis = q.front().dis; 
    q.pop();
    for (register int i = 0; i<int(linker[u].size()); i++) {
        if (!vis[cur]) {
            q.push(make(cur, dis + 1)); vis[cur] = true; d[cur] = dis + 1; 
            ans[cur] += ans[u]; ans[cur] %= mod;
        }
        else {
            if (dis + 1 == d[cur]) { ans[cur] += ans[u]; ans[cur] %= mod; }
        }
    }
}
```
核心思想：使用BFS遍历图，第一次访问节点时，更新距离和计数；再次访问且距离相等时，累加计数。

#### XZYQvQ - SPFA + 记忆化搜索
```cpp
// SPFA
while(!que.empty())
{
    int f=que.front();que.pop(),book[f]=0;
    for(int i=head[f];i!=-1;i=nxt[i])
        if(dis[f]+1<dis[to[i]])
        {
            dis[to[i]]=dis[f]+1;
            if(!book[to[i]])que.push(to[i]),book[to[i]]=1;
        }
}
// 记忆化搜索
int dfs(int u)
{
    if(ans[u])return ans[u];
    for(int i=head[u];i!=-1;i=nxt[i])
        if(dis[u]-1==dis[to[i]])ans[u]=(ans[u]+dfs(to[i]))%100003;
    return ans[u];
}
```
核心思想：先使用SPFA求出源点到所有点的最短路长度，再通过记忆化搜索遍历最短路图，累加计数。

### 最优关键思路或技巧
- **计数思路**：在求最短路的过程中，当找到更短路径时，更新路径长度并重置计数；当路径长度相等时，累加计数。
- **数据结构**：使用邻接表存储图，减少空间复杂度。
- **算法优化**：对于无权图，使用BFS可以更高效地求最短路。

### 拓展思路
同类型题或类似算法套路：
- 有向图的最短路计数问题，可使用Dijkstra或SPFA算法。
- 带权图的最短路计数问题，需要考虑边权的影响。
- 最短路计数问题的变种，如限制路径长度、经过特定节点等。

### 推荐题目
- P1608 路径统计
- P3371 单源最短路径（弱化版）
- P4779 单源最短路径（标准版）

---
处理用时：34.67秒
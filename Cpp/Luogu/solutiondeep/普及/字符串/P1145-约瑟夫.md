# 题目信息

# 约瑟夫

## 题目描述

$n$ 个人站成一圈，从某个人开始数数，每次数到 $m$ 的人就被杀掉，然后下一个人重新开始数，直到最后只剩一个人。现在有一圈人，$k$ 个好人站在一起，$k$ 个坏人站在一起。从第一个好人开始数数。你要确定一个最小的 $m$，使得在第一个好人被杀死前，$k$ 个坏人先被杀死。


## 说明/提示

$0\lt k\lt 14$。

## 样例 #1

### 输入

```
3```

### 输出

```
5```

## 样例 #2

### 输入

```
4```

### 输出

```
30```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找最小的 $m$ 值，使得在第一个好人被杀死前 $k$ 个坏人先被杀死。整体思路多为枚举 $m$ 值，模拟杀人过程进行判断。各题解在实现方式上有所不同，包括使用数组模拟、打表、递归、链表等方法。

### 所选题解
- **作者：doby（5星）**
    - **关键亮点**：思路清晰，代码简洁，使用函数封装判断逻辑，便于理解和维护。
    - **核心代码**：
```cpp
int check(int remain)
{
    int result=(begin+m-1)%remain;
    if(result>=k){
        begin=result;
        return 1;
    }
    else{return 0;}
}
```
    - **核心思想**：通过取模计算出列的人的位置，判断是否为坏人，若是则更新起始位置并返回成功。

- **作者：归来的圣主（5星）**
    - **关键亮点**：代码精简，逻辑清晰，使用游标模拟出列过程，避免了复杂的数据结构。
    - **核心代码**：
```c
while (flag)
{
    m++;
    int cursor=0;
    for (i=0; i<k; i++)
    {
        cursor=(cursor+m-1)%(2*k-i);
        if (cursor<k)break;
        if (i==k-1)flag=0;
    }
}
```
    - **核心思想**：枚举 $m$ 值，通过取模计算每次出列的人的编号，判断是否为坏人，若 $k$ 次都为坏人则找到最小 $m$。

- **作者：夜枭只会舔fufu（4星）**
    - **关键亮点**：采用打表法，时间复杂度为 $O(1)$，对于本题数据范围可快速得出结果。
    - **核心代码**：
```cpp
int num[14]={0,2,7,5,30,169,441,1872,7632,1740,93313,459901,1358657,2504881};
cin>>n;
cout<<num[n]<<endl;
```
    - **核心思想**：提前计算好所有可能的结果存储在数组中，输入 $k$ 后直接输出对应结果。

### 最优关键思路或技巧
- **取模运算**：在模拟杀人过程中，使用取模运算可以快速定位出列的人的位置，避免了循环遍历，提高了效率。
- **打表法**：对于数据范围较小的问题，提前计算好所有可能的结果并存储在数组中，可在 $O(1)$ 时间内得出答案。

### 可拓展之处
同类型题如普通的约瑟夫环问题，可改变杀人规则或增加其他条件。类似算法套路有模拟法、递归法、数学推导法等。

### 推荐题目
1. [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)
2. [P2872 [USACO07DEC]Building Roads S](https://www.luogu.com.cn/problem/P2872)
3. [P1652 圆](https://www.luogu.com.cn/problem/P1652)

### 个人心得
- **InternetExplorer**：在解释 `a[(num-1+i)%(2*k-sum)]` 时，通过具体例子说明了取模运算的原理，避免了直接使用 `a[(num+i-1)%(2*k-sum)]` 可能出现的位置错误问题。
- **学无止境**：提到在使用 `n=m%(k2-j)` 时，可能会出现 $n$ 为 0 的情况，需要特判避免错误。 

---
处理用时：27.31秒
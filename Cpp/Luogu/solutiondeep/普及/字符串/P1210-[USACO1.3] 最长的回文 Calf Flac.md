# 题目信息

# [USACO1.3] 最长的回文 Calf Flac

## 题目描述

据说如果你给无限只母牛和无限台巨型便携式电脑（有非常大的键盘 ), 那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观（最棒的回文）。

在寻找回文时不用理睬那些标点符号、空格（但应该保留下来以便做为答案输出）, 只用考虑字母 ${\tt A}\sim {\tt Z}$ 和 ${\tt a}\sim {\tt z}$。要你寻找的最长的回文的文章是一个不超过 $20{,}000$ 个字符的字符串。我们将保证最长的回文不会超过 $2{,}000$ 个字符（在除去标点符号、空格之前）。

## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 1.3


## 样例 #1

### 输入

```
Confucius say: Madam, I'm Adam. ```

### 输出

```
11
Madam, I'm Adam```

# AI分析结果

### 综合分析与结论
这些题解围绕寻找给定字符串中最长回文子串展开，处理时需忽略标点和空格，但输出要包含。解题思路多样，涵盖暴力枚举、二分答案、Manacher算法、后缀数组等。
- **暴力枚举**：通过两层循环枚举回文串的起始位置和长度，或枚举中心向两边扩展，简单直接但时间复杂度较高。
- **二分答案**：利用回文串长度奇偶的单调性进行二分查找，优化枚举效率。
- **Manacher算法**：线性时间复杂度求解最长回文子串，需对原字符串进行处理并记录位置信息。
- **后缀数组**：将原串处理后反转拼接，利用LCP求出最长公共前缀来确定最长回文串。

### 所选题解
1. **作者：HJY202three（5星）**
    - **关键亮点**：思路清晰，详细介绍前置知识，代码注释丰富，适合初学者。
    - **核心代码**：
```cpp
bool chk(int st, int length) {
    if (st + length > pl) return false;
    for (int i = 0; i < length / 2; i++) {
        if (pur[i + st]!= pur[st + length - i - 1])
            return false;
    }
    return true;
}
int maxn = -1, st = 0;
for (int i = 0; i < pl; i++) {
    for (int j = maxn + 1; j <= 2010; j++) {
        if (chk(i, j) && j > maxn) {
            maxn = j;
            st = i;
        }
    }
}
```
    - **核心思想**：先将原字符串处理为只含字母的小写字符串，用`chk`函数判断指定起始位置和长度的子串是否为回文串，通过两层循环枚举所有可能的回文串，记录最长回文串的长度和起始位置。
2. **作者：zqy1018（4星）**
    - **关键亮点**：代码简洁，通过枚举中心向两边扩展计算回文串长度，巧妙处理奇偶长度情况。
    - **核心代码**：
```cpp
int able(int o) {
    int i, j, a1 = 1, a2 = 0;
    for (i = o, j = 1; i - j >= 0 && i + j < l && m[i - j] == m[i + j]; j++) a1 += 2;
    for (i = o, j = 0; i - j >= 0 && i + j + 1 < l && m[i - j] == m[i + j + 1]; j++) a2 += 2;
    return (a1 > a2)? a1 : a2;
}
for (i = 0; i < l; i++) {
    t = able(i);
    if (t > max) {
        max = t;
        ls = i + (t / 2);
    }
}
```
    - **核心思想**：`able`函数分别计算以当前字符为中心的奇数长度和偶数长度回文串的最大长度，取两者较大值。遍历所有字符，更新最长回文串的长度和最后位置。
3. **作者：顾z（4星）**
    - **关键亮点**：使用Manacher算法线性求解最长回文子串，详细记录字符在原数组中的位置，解决输出原串的难点。
    - **核心代码**：
```cpp
for (RI i = 0; i < len; i++) {
    if ((s[i] >= 'a' and s[i] <= 'z') or (s[i] >= 'A' and s[i] <= 'Z'))
        str[len] = s[i], pos[len] = i, len++;
}
for (RI i = 0; i < len; i++) {
    if (str[i] >= 'a' and str[i] <= 'z')
        str[i] -= 32;
}
for (RI i = 0; i < len; i++) ss[2 * i + 1] = str[i], poss[2 * i + 1] = pos[i];
ll = 2 * len + 1;
for (RI i = 1; i < ll; i++) {
    if (i <= MaxRight)
        RL[i] = std::min(RL[2 * center - i], MaxRight - i);
    else RL[i] = 1;
    while (i - RL[i] >= 0 and i + RL[i] < ll and ss[i + RL[i]] == ss[i - RL[i]])
        RL[i]++;
    if (i + RL[i] - 1 > MaxRight) MaxRight = i + RL[i] - 1, center = i;
    if (RL[i] - 1 > ans) {
        ans = RL[i] - 1;
        le = i - RL[i] + 2;
        ri = i + RL[i] - 2;
    }
}
```
    - **核心思想**：先处理原字符串，提取字母并记录位置，将字母统一为大写。构建用于Manacher算法的数组，记录对应原串位置。使用Manacher算法计算最长回文半径，更新最长回文串的长度和左右端点位置。

### 最优关键思路或技巧
- **记录位置信息**：多数题解通过数组记录处理后字符在原字符串中的位置，解决输出包含标点和空格的原回文串的问题。
- **Manacher算法**：能在线性时间内求解最长回文子串，通过对原字符串插入特殊字符，利用回文串的对称性减少不必要的比较。
- **二分答案**：利用回文串长度奇偶的单调性，将枚举长度的时间复杂度从线性优化为对数级别。

### 可拓展之处
同类型题如求字符串中所有回文子串的数量、求多个字符串中的最长公共回文子串等。类似算法套路可用于处理其他字符串匹配和查找问题，如KMP算法用于字符串匹配、Trie树用于字符串检索等。

### 推荐题目
1. [P3805 【模板】manacher算法](https://www.luogu.com.cn/problem/P3805)
2. [P1659 [国家集训队]拉拉队排练](https://www.luogu.com.cn/problem/P1659)
3. [P4555 [国家集训队]最长双回文串](https://www.luogu.com.cn/problem/P4555)

### 个人心得摘录与总结
- **作者：顾z**：原以为通过判断最长回文半径中间位置字符左右两侧字符是否相等来扩展输出原串可行，但被卡，意识到需要记录字符在原数组中的位置来准确输出。总结：在处理复杂字符串输出问题时，要准确记录关键信息，避免简单思路的局限性。
- **作者：童年如作业**：尝试用判断空串停止读入数据会WA一个点，建议使用in、out文件读入。总结：在处理输入输出时，要考虑各种边界情况，选择合适的输入方式。 

---
处理用时：48.73秒
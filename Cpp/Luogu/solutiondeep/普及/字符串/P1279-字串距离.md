# 题目信息

# 字串距离

## 题目描述

设有字符串 $X$，我们称在 $X$ 的头尾及中间插入任意多个空格后构成的新字符串为 $X$ 的扩展串，如字符串 $X$ 为$\verb!abcbcd!$，则字符串 $\verb!abcb␣cd!$，$\verb!␣a␣bcbcd␣!$ 和 $\verb!abcb␣cd␣!$ 都是 $X$ 的扩展串，这里 $\verb!␣!$ 代表空格字符。

如果 $A_1$ 是字符串 $A$ 的扩展串，$B_1$ 是字符串 $B$ 的扩展串，$A_1$ 与 $B_1$ 具有相同的长度，那么我们定义字符串 $A_1$ 与 $B_1$ 的距离为相应位置上的字符的距离总和，而两个非空格字符的距离定义为它们的 ASCII 码的差的绝对值，而空格字符与其他任意字符之间的距离为已知的定值K，空格字符与空格字符的距离为 $0$。在字符串 $A$、$B$ 的所有扩展串中，必定存在两个等长的扩展串 $A_1$，$B_1$，使得 $A_1$ 与 $B_1$ 之间的距离达到最小，我们将这一距离定义为字符串 $A$，$B$ 的距离。

请你写一个程序，求出字符串 $A$，$B$ 的距离。


## 样例 #1

### 输入

```
cmc

snmn

2

```

### 输出

```
10

```

# AI分析结果

### 综合分析与结论
这些题解均采用动态规划（DP）解决字符串距离问题。思路核心为定义状态 `f[i][j]` 表示第一个字符串前 `i` 个字符和第二个字符串前 `j` 个字符的最小距离，状态转移考虑三种情况：当前字符对应、一个字符对应空格。初始化时处理一个字符串为空的情况。

### 所选题解
- **作者：Forever丶CIL（5星）**
    - **关键亮点**：思路清晰，先分析状态转移的逻辑，再给出递推方程和代码实现，代码结构清晰，注释详细。
    - **核心代码**：
```cpp
void dp()
{
    for(int i=1;i<=len1;i++)
    {
        for(int j=1;j<=len2;j++)
        {
            A[i][j]=min(A[i-1][j]+k,min(A[i][j-1]+k,A[i-1][j-1]+abs((int)s1[i]-(int)s2[j])));
        }
    }
}
void ini()
{
    for(int i=1;i<=len1;i++)
    {
        A[i][0]=A[i-1][0]+k;
    }
    for(int i=1;i<=len2;i++)
    {
        A[0][i]=A[0][i-1]+k;
    }
}
```
核心思想：`ini` 函数进行初始化，`dp` 函数通过两层循环进行状态转移，根据三种情况更新 `A[i][j]`。

- **作者：zhangyuhan（4星）**
    - **关键亮点**：按照 DP 题的一般思路，依次分析状态定义、转移方程、边界和目标，逻辑严谨，代码简洁易懂。
    - **核心代码**：
```cpp
for (int i=1; i<=m; i++)
    f[i][0] = i*k;
for (int j=1; j<=n; j++)
    f[0][j] = j*k;
for (int i=1; i<=m; i++)
    for (int j=1; j<=n; j++) {
        f[i][j] = 1e9;
        f[i][j] = min(f[i-1][j-1]+abs(a[i] - b[j]), min(f[i-1][j]+k, f[i][j-1]+k));
    }
```
核心思想：先初始化边界条件，再通过两层循环进行状态转移，取三种情况的最小值更新 `f[i][j]`。

- **作者：Y_B_Y（4星）**
    - **关键亮点**：配有图示解释状态转移过程，有助于理解，代码规范，注释详细。
    - **核心代码**：
```cpp
for(int i=1;i<=len1;i++)
{
    for(int j=1;j<=len2;j++)
    {
        f[i][j]=min(f[i][j],f[i][j-1]+k);
        f[i][j]=min(f[i][j],f[i-1][j]+k);
        f[i][j]=min(f[i][j],f[i-1][j-1]+abs(a[i]-b[j]));
    }
}
```
核心思想：通过两层循环进行状态转移，根据三种情况更新 `f[i][j]`。

### 最优关键思路或技巧
- **状态定义**：使用二维数组 `f[i][j]` 表示子问题的最优解，将原问题分解为子问题。
- **状态转移**：考虑三种情况进行状态转移，取最小值保证结果最优。
- **初始化**：处理一个字符串为空的边界情况，为后续状态转移提供基础。

### 拓展思路
同类型题或类似算法套路：编辑距离问题，可对字符串进行插入、删除、替换操作，求最小操作次数；最长公共子序列问题，求两个序列的最长公共子序列长度。

### 推荐题目
- P2758 编辑距离
- P1439 【模板】最长公共子序列
- P1874 快速求和

### 个人心得
- **作者：zcyyyyy**：认为记忆化搜索能使做题时的思维难度大大下降，建议刚入门的 oier 多写写记忆化搜索。总结：记忆化搜索可简化思维过程，适合初学者。 

---
处理用时：27.05秒
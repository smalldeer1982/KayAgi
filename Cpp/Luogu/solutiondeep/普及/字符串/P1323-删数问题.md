# 题目信息

# 删数问题

## 题目描述

一个集合有如下元素：$1$ 是集合元素；若 $P$ 是集合的元素，则 $2\times P+1$，$4\times P+5$ 也是集合的元素。

取出此集合中最小的 $k$ 个元素，按从小到大的顺序组合成一个多位数，现要求从中删除 $m$ 个数位上的数字，使得剩下的数字最大，编程输出删除前和删除后的多位数字。

注：不存在所有数被删除的情况。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $1\le k,m\le300$。
- 对于 $100\%$ 的数据，保证 $1\le k,m\le3\times10^4$。

## 样例 #1

### 输入

```
5  4```

### 输出

```
137915
95```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何解决删数问题展开，将题目拆解为生成集合元素和删除数位两部分。生成元素部分，多数使用优先队列维护最小元素，部分采用归并排序思路；删除数位部分，主要运用贪心策略，维护不下降序列。各题解在代码实现和优化上有所差异，如使用不同的数据结构（链表、单调队列等）辅助操作，部分题解还考虑了代码效率和边界情况。

### 所选题解
- **zhaowangji（5星）**
    - **关键亮点**：思路清晰，将题目拆解为两部分，详细阐述每一步的实现方法，代码注释丰富，可读性强。使用优先队列和`to_string`函数简化操作。
    - **核心代码**：
```cpp
priority_queue<int,vector<int>,greater<int> > cre;
string s;
int main(){
    cin>>k>>m;
    cre.push(1);
    for(int i=1;i<=k;++i){
        int x=cre.top();
        s+=to_string(x);
        cre.pop();
        cre.push(2*x+1);
        cre.push(4*x+5);
    }
    cout<<s<<endl;
    int cnt=0;
    for(;;){
        for(int i=0;i<s.size()-1;++i){
            if(s[i]<s[i+1]){
                ++cnt;s.erase(i,1);
                if(cnt>=m){cout<<s<<endl;exit(0);}
                break;
            }
        }
    }
    return 0;
}
```
    - **核心实现思想**：使用优先队列`cre`维护最小元素，每次取出堆顶元素，将其转换为字符串添加到`s`中，再将其衍生元素加入队列。删除数位时，遍历字符串，若当前字符小于下一个字符，则删除当前字符，直到删除次数达到`m`。

- **defense（4星）**
    - **关键亮点**：将问题分解为两个子问题，思路明确。使用小根堆生成序列，贪心策略删除数位，代码结构清晰。
    - **核心代码**：
```cpp
std::priority_queue<int, std::vector<int>, std::greater<int> >Num;
std::string ans1, ans2;
int K, M, L, R;
std::string sum(int a){
    std::stringstream ss;
    ss << a;
    std::string ans = ss.str();
    return ans;
}
int main(){
    Num.push(1); 
    scanf("%d%d",&K, &M);
    int Cnt = 0 ; 
    while(Cnt < K){
        int a = Num.top() * 2 + 1;
        int b = Num.top() * 4 + 5;
        ans1 += (sum(Num.top()));
        Num.pop(); 
        Num.push(a);
        Num.push(b);  
        ++Cnt;
    }
    std::cout << ans1 <<"\n"; 
    L = 0;R = M;
    int Maxx = 0;
    while(L <= R && R < ans1.length()){
        for(register int i = L ; i <= R ; i++){
            if((ans1[i] - '0') > Maxx) Maxx = (ans1[i] - '0'), L = i + 1;
        }
        ans2 += (sum(Maxx));
        R++;
        Maxx = 0;
    }
    std::cout<< ans2;
    return 0;
}
```
    - **核心实现思想**：使用小根堆`Num`生成序列，将堆顶元素转换为字符串添加到`ans1`中。删除数位时，将问题转化为留下`total - M`个数字，每次在搜索区间`[L, R]`中找到最大数字添加到`ans2`中，更新搜索区间。

- **lytqwq（4星）**
    - **关键亮点**：将问题分为求删除前数字和删数两部分，思路清晰。使用小根堆生成序列，贪心策略删除数位，代码有详细注释。
    - **核心代码**：
```cpp
priority_queue<int,vector<int>,greater<int> > q;
int main()
{
    scanf("%d%d",&k,&m);
    q.push(1); 
    int now;
    while(!q.empty())
    {
        now=q.top();
        q.pop();
        a[++top]=now;
        if(top==k)
        {
            break;
        }
        q.push(2*now+1);
        q.push(4*now+5);
    }
    for(int i=1;i<=top;i++)
    {
        int yes=0,nowqaq=qaq;
        for(;nowqaq!=0;nowqaq/=10)
        {
            if(a[i]/nowqaq==0 && yes==0)
            {
                a[i]%=nowqaq;
                continue;
            }
            if(a[i]/nowqaq!=0)
            {
                yes=1;
            }
            b[++topb]=a[i]/nowqaq;
            a[i]%=nowqaq;
            printf("%d",b[topb]);
        }
    }
    printf("\n");
    c[0]=10;
    for(int i=1;i<=topb;i++)
    {
        if(b[i]>c[topc] || m==0)
        {
            c[topc]=b[i];
            topc++;
        }
        else
        {
            m--;
        }
        while(m>0 && c[topc-2]<c[topc-1])
        {
            m--;
            topc--;
            c[topc-1]=c[topc];
            c[topc]=0;
        }
    }
    topc-=m;
    for(int i=1;i<=topc-1;i++)
    {
        printf("%d",c[i]);
    }
    printf("\n");
}
```
    - **核心实现思想**：使用小根堆`q`生成序列，将元素存入数组`a`。将数组`a`中的元素拆分为每一位存入数组`b`。删除数位时，使用贪心策略，若当前数字大于`c`数组的最后一个数字或删除次数用完，则将其存入`c`数组，否则删除`c`数组的最后一个数字。

### 最优关键思路或技巧
- **数据结构**：优先队列用于维护最小元素，可高效取出当前最小元素并添加衍生元素；链表可方便地进行删除操作，模拟元素的删除过程。
- **算法优化**：使用贪心策略，每次删除第一个递增数列的第一个元素，可使剩下的数字最大；部分题解利用数字特性（如出现9的概率）优化删除过程。
- **代码实现技巧**：使用`to_string`函数或`stringstream`将数字转换为字符串，简化拼接操作；使用`erase`函数删除字符串中的字符。

### 可拓展之处
同类型题可考虑改变集合元素的生成规则或删除规则，如改变衍生元素的计算方式，或要求删除后剩下的数字最小等。类似算法套路可应用于其他需要维护有序序列和进行删除操作的问题。

### 推荐题目
- P1106 删数问题
- UVA136 丑数
- P1090 合并果子

### 个人心得摘录与总结
- **A_little_fresh**：使用`stringstream`将数字转字符串，后半部分代码一开始出错，经过思考后完成，虽效果不满意但可供参考。总结：在实现过程中可能会遇到问题，需要耐心思考和调试。
- **库特**：未使用优先队列，采用手动标记排序，删除时利用数字特性优化，实现0ms AC。总结：可根据题目特点选择合适的算法和数据结构，通过优化提高效率。 

---
处理用时：57.18秒
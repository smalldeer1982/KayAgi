# 题目信息

# [USACO2.3] 零的数列 Zero Sum

## 题目描述

请考虑一个由 $1$ 到 $N$ 的数字组成的递增数列：$1, 2, 3, \ldots, N$。

现在请在数列中插入 `+` 表示加，或者 `-` 表示减，` `（空格） 表示空白（例如 `1-2 3` 就等于 `1-23`），来将每一对数字组合在一起（请不要在第一个数字前插入符号）。

计算该表达式的结果并判断其值是否为 $0$。 请你写一个程序找出所有产生和为零的长度为N的数列。


## 说明/提示

翻译来自NOCOW

USACO 2.3


## 样例 #1

### 输入

```
7
```

### 输出

```
1+2-3+4-5-6+7
1+2-3-4+5+6-7
1-2 3+4+5+6+7
1-2 3-4 5+6 7
1-2+3+4-5+6-7
1-2-3-4-5+6+7```

# AI分析结果

### 综合分析与结论
这些题解主要围绕“零的数列”问题展开，核心是在由 1 到 N 的递增数列中插入 `+`、`-`、` ` 符号，使表达式结果为 0。大部分题解采用深度优先搜索（DFS）或暴力枚举的方法，也有使用三进制枚举、二进制枚举、打表等方法。

算法要点主要是对符号的枚举和表达式结果的计算，难点在于处理空格符号带来的数字合并问题以及表达式结果的准确计算。

### 所选题解
- **作者：john666（5 星）**
    - **关键亮点**：思路清晰，代码简洁，通过深度优先搜索，在搜索过程中实时计算表达式的值，避免了重复计算。
    - **核心代码**：
```cpp
void sear(int k,int s,int q,char c){
    if(k==n){
        if(c=='+'){
            s=s+q;
        }
        else{
            s=s-q;
        }
        if(s==0){
            ss++;
            cout<<"1";
            for(int i=1;i<n;i++){
                cout<<symbol[i]<<sz[i];
            }
            cout<<" "<<ss<<endl;
        }
    }
    else{
        symbol[k]=' ';
        sear(k+1,s,q*10+sz[k],c);
        symbol[k]='+';
        if(c=='+'){
            sear(k+1,s+q,sz[k],'+');
        }
        else{
            sear(k+1,s-q,sz[k],'+');
        }
        symbol[k]='-';
        if(c=='+'){
            sear(k+1,s+q,sz[k],'-');
        }
        else{
            sear(k+1,s-q,sz[k],'-');
        }
    }
}
```
    - **核心思想**：`sear` 函数进行深度优先搜索，`k` 表示当前处理的数字位置，`s` 表示当前总和，`q` 表示待处理的前一个数值，`c` 表示最后一个非空格符号。当 `k` 等于 `n` 时，判断表达式结果是否为 0，若是则输出。否则，分别尝试插入空格、`+`、`-` 符号并递归搜索。

- **作者：redegg（4 星）**
    - **关键亮点**：采用暴力枚举所有可能的符号组合，通过 `dfs` 函数实现，代码逻辑清晰，判断函数 `run` 处理空格合并数字的问题。
    - **核心代码**：
```cpp
bool run(int n)
{
    memset(f,0,sizeof(f));
    int p=1;
    f[p]=1;
    for(int i=1;i<=n;i++)
    {
        if(a[i]==0)
        {
            f[p]=f[p]*10+i+1;
        }
        else
        {
            z[p]=a[i];
            p++;
            f[p]=f[p]*10+i+1;
        }
    }
    int ans=f[1];
    for(int i=1;i<p;i++)
    {
        if(z[i]==1)
        {
            ans+=f[i+1];
        }
        else
        {
            ans-=f[i+1];
        }
    }
    if(ans==0)return 1;
    else return 0;
}

void dfs(int v,int x)
{
    if(v==x)
    {
        if(run(x))
        {
            cout<<1;
            for(int i=1;i<=x;i++)
            {
                if(a[i]==1)cout<<"+"<<i+1;
                if(a[i]==0)cout<<" "<<i+1;
                if(a[i]==2)cout<<"-"<<i+1;
            }
            cout<<endl;
        }
        return ;
    }
    for(int i=0;i<=2;i++)
    {
        a[v+1]=i;
        dfs(v+1,x);
    }
}
```
    - **核心思想**：`run` 函数用于计算表达式的值，将空格连接的数字合并，然后根据符号进行加减运算。`dfs` 函数枚举所有可能的符号组合，当枚举完所有符号后，调用 `run` 函数判断结果是否为 0，若是则输出。

- **作者：Celebrate（4 星）**
    - **关键亮点**：通过在 1 之前添加 `+` 符号，简化了判断逻辑，`dfs` 函数枚举符号，`check` 函数处理空格并计算表达式结果。
    - **核心代码**：
```cpp
inline bool check()//判断是否可行，整个程序最难的地方 
{
    int ans=0,t;
    for(int i=1;i<=n;i++)//n个符号 
    {
        if(a[i]==0) continue;//如果是‘ ’就不用管了 
        t=i;
        for(int j=i+1;j<=n;j++)//找‘ ’ 
        {
            if(a[j]!=0) break;//如果不是空格，就不管了 
            t=t*10+j;
        }
        if(a[i]==1) ans+=t;//加或减 
        else ans-=t;
    }
    if(ans==0) return true;//返还 
    return false;
}
void dfs(int k)
{
    if(k==n+1)//如果符号找完了 
    {
        if(check()==true)//判断是否可以 
        {
            printf("1");//如果可以就输出 
            for(int i=2;i<=n;i++) printf("%c%d",s[a[i]],i);
            printf("\n");
        }
    }
    else
    {
        for(int i=0;i<=2;i++)//递归 
        {
            a[k]=i;//记录值 
            dfs(k+1);//往下搜索 
            a[k]=0;//回溯 
        }
    }
}
```
    - **核心思想**：`check` 函数遍历符号数组，处理空格合并数字，根据符号进行加减运算，判断结果是否为 0。`dfs` 函数枚举所有可能的符号组合，当枚举完所有符号后，调用 `check` 函数判断结果是否为 0，若是则输出。

### 最优关键思路或技巧
- **深度优先搜索（DFS）**：大部分题解采用 DFS 枚举所有可能的符号组合，在搜索过程中实时计算表达式的值，避免了重复计算。
- **预处理空格**：在计算表达式结果时，将空格连接的数字合并成一个数，简化计算过程。
- **符号预处理**：如在 1 之前添加 `+` 符号，使符号和数字数量一致，简化判断逻辑。

### 可拓展之处
同类型题或类似算法套路：
- 类似的符号插入问题，如在数列中插入其他运算符，使表达式满足特定条件。
- 组合枚举问题，通过 DFS 或暴力枚举所有可能的组合，然后进行判断。

### 推荐题目
- P1706 全排列问题
- P1157 组合的输出
- P1036 选数

### 个人心得摘录与总结
- **作者：lx233**：在实现 DFS 过程中容易犯错，如 `i--` 忘记、数组名混淆、`flag` 未置空、代码修改不统一等。还提到 char 数组赋值只能在定义时直接初始化，要注意三位数的情况。总结为在编写代码时要仔细，避免低级错误，同时要注意边界条件和特殊情况。
- **作者：rainygame**：独立发现用二进制枚举表示 3 个状态的方法，虽然时间复杂度较高，但在某些情况下可以解决问题。在选拔赛中，深搜写挂时，用二进制枚举通过了题目，说明不同算法在不同场景下的实用性。总结为要灵活运用不同算法，在紧急情况下可以尝试其他思路。

---
处理用时：47.54秒
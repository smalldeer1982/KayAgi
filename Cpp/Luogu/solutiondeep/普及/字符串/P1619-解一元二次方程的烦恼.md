# 题目信息

# 解一元二次方程的烦恼

## 题目背景

JosephZheng 在写数学作业的预习。他往往使用 Casio 来帮忙解一元二次方程。但是 Casio 有一个问题，就是当 $\Delta=b^2-4ac$ 为一个大素数或大合数时，其开平方的结果会以小数显示，而不是老师要求的二次根式形式。JosephZheng 很是苦恼，一遇到这种情况就要手动解方程。一天他再也忍不住了，于是打开了电脑，编了一个 prime 程序……于是悲剧的 OIer 们就要跟着疯狂的 JosephZheng 一起编这个程序，呵呵……


## 题目描述

废话少说，给你一个大数 $N$（不一定在 int64 范围内），让你进行素性判断，然后分解质因数。当然，初中数学题不可能有大于 int64 的数让你判断素性，因此超过范围的数可以忽略不计。为了让程序更加贴心，JosephZheng 多了一些要求，会在输入输出中给出具体情况。


## 说明/提示

编这道题的 JosephZheng 有些无聊，但是很考验基本功哦！仔细审题！

水题一道。。。


## 样例 #1

### 输入

```
4
eed
```

### 输出

```
Enter the number=
Prime? No!
4=2^2

Enter the number=
```

## 样例 #2

### 输入

```
2
end
```

### 输出

```
Enter the number=
Prime? Yes!

Enter the number=
```

## 样例 #3

### 输入

```
-1
adfs
```

### 输出

```
Enter the number=
Prime? No!

Enter the number=
```

## 样例 #4

### 输入

```
1234###24#@13#@￥！1
hehe
```

### 输出

```
Enter the number=
Prime? No!
The number is too large!

Enter the number=
```

## 样例 #5

### 输入

```
1.5
1
1234324123512343123
@~@~@~@
```

### 输出

```
Enter the number=
Prime? No!
15=3^1*5^1

Enter the number=
Prime? No!

Enter the number=
Prime? No!
The number is too large!

Enter the number=
```

## 样例 #6

### 输入

```
12
halt@@
```

### 输出

```
Enter the number=
Prime? No!
12=2^2*3^1

Enter the number=
```

# AI分析结果

### 综合分析与结论
这些题解整体围绕判断素数和分解质因数展开，思路大多是先从输入字符串中提取数字，接着判断数字大小，再判断是否为素数，若不是素数则进行质因数分解，最后按要求输出结果。

各题解的算法要点主要集中在素数判断和质因数分解上，素数判断多采用 $O(\sqrt{n})$ 的方法，部分题解使用线性筛素数；质因数分解则是从最小素数开始不断除原数。

难点在于输入输出格式的处理，如换行、空格、特判等，以及对输入字符串中数字的提取和对特殊情况（如数字过大、过小、无数字）的处理。

### 所选题解
- **作者：_neddy（5星）**
    - **关键亮点**：思路清晰，对时间复杂度进行了分析，代码注释详细，对坑点有明确说明。
    - **个人心得**：“这篇题解改了两次，每一次重写我都能发现新的Bug，也正说明了我的能力仍然十分有限。”总结出在编写代码过程中不断重写能发现新问题，提升代码质量。
- **作者：0nullptr（4星）**
    - **关键亮点**：将处理过程步骤化，逐一分析每步操作，代码结构清晰。
    - **个人心得**：无
- **作者：Lylighte（4星）**
    - **关键亮点**：对每个小算法（输入输出、分离数字、判断素数、分解质因数）进行详细分析，且给出了DEBUG过程。
    - **个人心得**：“把线性筛素数写爆了，竟然多乘了个数字。第一次提交爆零，字母大小写出错。第二次WA 5个点，因为 `cin` 读入跳过了空格，出错。第三次WA 2个点，忘记特判 $n<2$ 的情况。第四次AC。”总结出在调试过程中要注意代码细节，如算法实现、大小写、输入方式、特判情况等。

### 重点代码及核心实现思想
#### _neddy
```cpp
inline int str_to_int64(string ss)
{
    int num = 0, flag = 0;
    for (register int i = 0; i < ss.size() && num <= 40000000; ++i)
        if (ss[i] >= '0' && ss[i] <= '9') num = num * 10 + (ss[i] - '0'), flag = 1;
    if (flag == 0) exit(0);
    return num;
}

inline bool isprime(int n){
    for (register int i = 2; i * i <= n; ++i) if (n % i == 0) return 0;
    return!(n < 2);
}

inline void act(int n){
    int num = 0, sum = 0, flag = 0, Isprime = isprime(n);
    n <= 40000000 && Isprime? cout << "Prime? Yes!\n\n" : cout << "Prime? No!\n";
    if (Isprime || n < 2 || n > 40000000) {
        if (n > 40000000) cout << "The number is too large!\n\n";
        if (n < 2) cout << '\n';
        return ;
    }
    cout << n << '=';
    for (register int i = 2; i * i <= n; ++i){
        while(n % i == 0) n /= i, ++sum;
        if (sum)
            if (flag) cout << '*' << i << '^' << sum, sum = 0;
            else cout << i << '^' << sum, flag = true, sum = 0;
    }
    Isprime? cout << '*' << n << "^1\n\n" : cout << "\n\n";
}
```
核心思想：`str_to_int64` 函数从字符串中提取数字，若字符串无数字则退出程序；`isprime` 函数判断数字是否为素数；`act` 函数根据数字情况输出是否为素数的判断结果，若不是素数则进行质因数分解并输出。

#### 0nullptr
```cpp
bool judge(int n){
    int m = (int) sqrt(n + 0.5);
    for (int i = 2; i <= m; i++)
        if (n % i == 0) return false;
    return true;
}

void divide(int x) {
    int flagone = 1;
    for(int i = 2; i <= x; ++i)
        if(!(x % i)) {
            int cimi = 0;
            while(!(x % i)) {
                cimi++;
                x /= i;
            }
            if(flagone) flagone = 0;
            else printf("*");
            printf("%d^%d", i, cimi);
        }
}
```
核心思想：`judge` 函数通过遍历 $2$ 到 $\sqrt{n}$ 判断数字是否为素数；`divide` 函数对数字进行质因数分解，输出分解结果。

#### Lylighte
```cpp
const int TOOBIG=-1, EMPTY=-3;
int worknum(string st){
    int num=0;
    bool getans=false;
    int len=st.size();
    for(int i=0; i<len; i++){
        if(st[i]>='0'&&st[i]<='9'){
            num = num*10+st[i]-'0';
            getans = true;
            if(num>40000000){
                return TOOBIG;
            }
        }
    }
    if(!getans){
        return EMPTY;
    }
    return num;
}

bool isprime[40000010];
int primelist[8000010], pcnt;
void workprime(){
    memset(isprime, true, sizeof(isprime));
    isprime[0]=isprime[1]=false;
    for(int i=2; i<=40000000; i++){
        if(isprime[i]){
            primelist[++pcnt] = i;
        }
        for(int j=1; j<=pcnt&&primelist[j]*i<=40000000; j++){
            isprime[primelist[j]*i] = false;
            if(i%primelist[j]==0){
                break;
            }
        }
    }
    return;
}

void divi(int n){
    bool appeared=false;
    cout <<  n << '=';
    for(int i=1; i<=pcnt; i++){
        int p=0;
        while(n%primelist[i]==0&&n>0){
            p++;
            n /= primelist[i];
        }
        if(p>0){
            if(appeared)
                cout << '*';
            cout << primelist[i] << '^' << p;
            appeared = true;
        }
    }
    cout << '\n';
}
```
核心思想：`worknum` 函数从字符串中提取数字，若数字超过 $40000000$ 则返回 `TOOBIG`，若字符串无数字则返回 `EMPTY`；`workprime` 函数使用线性筛素数生成素数表；`divi` 函数利用素数表对数字进行质因数分解并输出结果。

### 最优关键思路或技巧
- **输入处理**：使用 `getline` 读取包含空格的字符串，通过遍历字符串提取数字，同时判断数字是否超过范围。
- **素数判断**：采用 $O(\sqrt{n})$ 的方法判断素数，部分题解使用线性筛素数优化判断效率。
- **质因数分解**：从最小素数开始不断除原数，记录每个素数的指数，输出时注意格式。
- **特判处理**：对数字过小、过大、无数字等特殊情况进行特判。

### 可拓展之处
同类型题可能会增加数据范围，可使用更高效的素数判断算法（如 Miller-Rabin 素性测试）和质因数分解算法（如 Pollard-Rho 算法）。类似算法套路可应用于数论相关题目，如求最大公约数、最小公倍数等。

### 推荐题目
- P3383 线性筛素数
- P1075 质因数分解
- P1579 哥德巴赫猜想（升级版）

---
处理用时：52.33秒
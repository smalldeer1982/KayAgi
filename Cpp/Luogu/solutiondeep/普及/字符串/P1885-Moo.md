# 题目信息

# Moo

## 题目描述

奶牛 Bessie 最近在学习字符串操作，它用如下的规则逐一的构造出新的字符串：

$S(0) =$ `moo`

$S(1) = S(0) +$ `m` $+$ `ooo` $+ S(0) =$ `moo` $+$ `m` $+$ `ooo` $+$ `moo` $=$ `moomooomoo`

$S(2) = S(1) +$ `m` $+$ `oooo` $+ S(1) =$ `moomooomoo` $+$ `m` $+$ `oooo` $+$  `moomooomoo` $=$ `moomooomoomoooomoomooomoo`

$\dots$

Bessie 就这样产生字符串，直到最后产生的那个字符串长度不小于读入的整数 $N$ 才停止。

通过上面观察，可以发现第 $k$ 个字符串是由：第 $k-1$ 个字符串 $+$ `m` $+$  $(k+2$ 个 $o) +$ 第 $k-1$ 个字符串连接起来的。

现在的问题是：给出一个整数 $N (1 \leq N \leq 10^9)$，问第 $N$ 个字符是字母 `m` 还是 `o`？


## 说明/提示

样例解释：

由题目所知：字符串 $S(0)$ 是 `moo`, 现在要求第 $11$ 个字符，显然字符串 $S(0)$ 不够长；

同样 $S(1)$ 的长度是 $10$，也不够长；$S(2)$ 的长度是 $25$，够长了，$S(2)$ 的第 $11$ 个字符是 `m`，所以答案就输出 `m`。


## 样例 #1

### 输入

```
11```

### 输出

```
m```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何确定第 $N$ 个字符是 `m` 还是 `o` 展开，多数采用分治思想。先通过递推公式 $len_i = 2 * len_{i - 1} + i + 2$ （或 $len_i = 2 * len_{i - 1} + i + 3$ ）预处理字符串长度，找到包含第 $N$ 个字符的最小字符串，再将该字符串分成三部分（开头、中间、结尾），根据 $N$ 的位置进行分类讨论，递归或迭代求解。

### 所选题解
1. **作者：FC是女孩子（5星）**
    - **关键亮点**：代码简洁，直接模拟长度和位置，迭代处理，避免了递归带来的额外开销。
    - **核心代码**：
```cpp
#include<cstdio>

int n,t=0,k=3;

int main()
{
    scanf("%d",&n);int m=n;
    while(t<=n) t=t*2+k,k++;
    k--;
    while(t>0)
    {
        t=(t-k)/2;
        if(m>t)
        {
            if(m<=t+k)
            {
                if(m==t+1) return printf("m"),0;
                else printf("o"),0;
            }
            else m=m-(t+k);
        }
        k--;
    }
    return 0;
}
```
    - **核心实现思想**：先模拟字符串长度，当长度超过 $n$ 时，再模拟 $n$ 的位置。根据 $n$ 在当前字符串中的位置，判断是在开头部分、中间部分还是结尾部分，逐步缩小范围，直到得出结果。

2. **作者：Starlight237（4星）**
    - **关键亮点**：思路清晰，分治逻辑明确，代码结构良好，注释详细。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define reg register
static int n,len[100001];
string str;
inline int pre(){
    int ans;
    for(reg int i=1;len[i-1]<n||(ans=i,0);++i)len[i]=(len[i-1]<<1)+i+2;
    return ans;
}
void dg(int m,int N){
    while(len[m-1]>N)--m;
    if(N==len[m-1]+1){putchar('m');return;}
    else if(N<=len[m-1]+m+2){putchar('o');return;}
    dg(m-1,N-len[m-1]-m-2);
}
int main(){
    scanf("%d",&n),dg(pre(),n);
    return 0;
}
```
    - **核心实现思想**：先预处理字符串长度，找到包含第 $N$ 个字符的最小字符串编号。然后分三种情况讨论 $N$ 的位置：若 $N$ 是中间部分的第一个字符，输出 `m`；若 $N$ 在中间部分，输出 `o`；否则递归处理 $N$ 在结尾部分的情况。

3. **作者：Deny_小田（4星）**
    - **关键亮点**：提供了多种方法，包括模拟、打表和分治，对比不同方法的得分情况，有助于理解不同算法的优劣。
    - **核心代码（分治部分）**：
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define Size 100005
using namespace std;
typedef long long type;
type n;
string str;
int t[Size];
int start(int p){
    int now,i = 1;
    t[0] = 0;
    while(1){
        t[i] = 2*t[i-1]+(i+2);
        if(t[i] >= p){ now = i; break; }
        i++;
    }
    return now;
}
void solve(int q,int n){  
    while(t[q-1] > n) q--;  
    if(n == t[q-1]+1){  
        printf("m\n"); 
        return ;  
    }else if(n <= t[q-1]+q+2){  
        printf("o\n");
        return ;  
    }  
    solve(q-1,n-(t[q-1]+q+2));  
}
int main(){
    int cnt = 0;
    cin >> n;
    cnt = start(n);
    solve(cnt,n);
    return 0;
} 
```
    - **核心实现思想**：先预处理字符串长度，找到包含第 $N$ 个字符的最小字符串编号。然后根据 $N$ 的位置分情况讨论，若 $N$ 是中间部分的第一个字符，输出 `m`；若 $N$ 在中间部分，输出 `o`；否则递归处理 $N$ 在结尾部分的情况。

### 最优关键思路或技巧
- **分治思想**：将大问题分解为小问题，通过递归或迭代不断缩小问题规模，降低时间复杂度。
- **预处理长度**：先计算出前若干个字符串的长度，方便后续判断第 $N$ 个字符所在的字符串。

### 可拓展之处
同类型题或类似算法套路：
- 递归构造字符串问题：如康托展开、谢尔宾斯基三角形等，通过递归规则构造复杂结构，再求解特定位置的元素。
- 分治算法应用：在处理具有递归结构的问题时，可将问题分解为子问题，分别求解后合并结果。

### 推荐题目
1. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：通过递归规则生成数字序列，求解满足条件的数字个数。
2. [P1226 快速幂取模运算](https://www.luogu.com.cn/problem/P1226)：利用分治思想优化幂运算，降低时间复杂度。
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：使用归并排序的分治思想求解逆序对数量。

### 个人心得摘录与总结
- **Deny_小田**：尝试了三种方法（模拟、打表、分治），并给出了每种方法的得分情况。总结出模拟会因字符串过长导致MLE，打表不能得到满分，而分治算法可以AC，强调了选择合适算法的重要性。 

---
处理用时：42.05秒
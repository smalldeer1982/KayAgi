# 题目信息

# 最长括号匹配

## 题目描述

对一个由(,),[,]括号组成的字符串，求出其中最长的括号匹配子串。具体来说，满足如下条件的字符串成为括号匹配的字符串：

  1.(),[]是括号匹配的字符串。

2.若A是括号匹配的串，则(A),[A]是括号匹配的字符串。

3.若A,B是括号匹配的字符串，则AB也是括号匹配的字符串。

例如：(),[],([]),()()都是括号匹配的字符串，而][,[(])则不是。

字符串A的子串是指由A中连续若干个字符组成的字符串。

例如，A,B,C,ABC,CAB,ABCABCd都是ABCABC的子串。空串是任何字符串的子串。


## 说明/提示

【数据范围】

对20%的数据，字符串长度<=100.

对50%的数据，字符串长度<=10000.

对100%的数据，字符串长度<=1000000.


## 样例 #1

### 输入

```
([(][()]]()
```

### 输出

```
[()]
```

## 样例 #2

### 输入

```
())[]```

### 输出

```
()```

# AI分析结果

### 综合分析与结论
这些题解主要围绕最长括号匹配问题展开，解题思路主要分为动态规划和栈模拟两种。

#### 动态规划思路
以`f[i]`或`dp[i]`表示以第`i`个字符结尾或开头的最长括号匹配长度，通过状态转移方程求解。如`f[i]=f[i - 1]+2+f[i - f[i - 1]-2]`，需要考虑字符匹配情况和边界条件。

#### 栈模拟思路
将字符依次入栈，遇到匹配的括号则弹出，并标记匹配位置，最后找出连续匹配位置的最长子串。

### 所选题解
1. **作者：OItby（5星）**
    - **关键亮点**：思路清晰，详细解释了状态构建和状态转移方程的推导过程，代码注释丰富，可读性强。
    - **核心代码**：
```cpp
const int L = 1000005;
char s[L];
int l, f[L], Ans, id;

int main() {
    scanf("%s", s + 1);
    l = strlen(s + 1);
    for (int i = 2; i <= l; ++i) {
        if (s[i] == '(' || s[i] == '[') continue;
        else if ((s[i] == ')' && s[i - f[i - 1] - 1] == '(') || (s[i] == ']' && s[i - f[i - 1] - 1] == '[')) {
            f[i] = f[i - 1] + 2 + f[i - f[i - 1] - 2];
            if (f[i] > Ans) Ans = f[i], id = i;
        }
    }
    for (int i = id - Ans + 1; i <= id; ++i) printf("%c", s[i]);
    putchar('\n');
    return 0;
}
```
    - **核心思想**：构建状态`f[i]`表示以`s[i]`为结尾的字符串的最长括号匹配，根据字符匹配情况推导状态转移方程，最后输出最长匹配子串。

2. **作者：Nepenthe（4星）**
    - **关键亮点**：思路简洁直接，使用栈模拟和标记数组，易于理解和实现。
    - **核心代码**：
```cpp
#define siz 1000100
int la, top, cnt, l, ansl, ansr, ans;
int sta[siz][2];
char a[siz];
bool vis[siz];

int main() {
    scanf("%s", a);
    la = strlen(a);
    for (int i = 0; i < la; ++i) {
        if ((sta[top][0] == '[' && a[i] == ']') || (sta[top][0] == '(' && a[i] == ')'))
            vis[sta[top--][1]] = vis[i] = 1;
        else
            sta[++top][0] = a[i], sta[top][1] = i;
    }
    for (int i = 0; i < la; ++i) {
        if (!vis[i]) cnt = 0, l = i + 1;
        else {
            cnt++;
            if (cnt > ans) ansl = l, ansr = i, ans = cnt;
        }
    }
    for (int i = ansl; i <= ansr; ++i) putchar(a[i]);
    return 0;
}
```
    - **核心思想**：将字符依次入栈，遇到匹配的括号则弹出并标记匹配位置，最后找出连续匹配位置的最长子串。

3. **作者：Seanq（4星）**
    - **关键亮点**：代码简洁，同样使用动态规划解决问题，逻辑清晰。
    - **核心代码**：
```cpp
const int N = 1000005;
char s[N];
int f[N];
int n;
int ans = 0;

int main() {
    scanf("%s", s + 1);
    n = strlen(s + 1);
    for (int i = 1; i <= n; i++) {
        if (s[i] == '(' || s[i] == '[') continue;
        else if (s[i] == ')' && s[i - 1 - f[i - 1]] == '(' || s[i] == ']' && s[i - 1 - f[i - 1]] == '[') {
            f[i] = f[i - 1] + 2 + f[i - 2 - f[i - 1]];
            ans = max(ans, f[i]);
        }
    }
    for (int i = 1; i <= n; i++) {
        if (f[i] == ans) {
            for (int j = i - ans + 1; j <= i; j++)
                printf("%c", s[j]);
            printf("\n");
            break;
        }
    }
    return 0;
}
```
    - **核心思想**：定义`f[i]`表示以`i`为结尾的最长括号匹配长度，根据字符匹配情况更新`f[i]`，最后输出最长匹配子串。

### 最优关键思路或技巧
- **动态规划**：合理定义状态，通过状态转移方程求解最长匹配长度，考虑字符匹配和边界条件。
- **栈模拟**：利用栈的特性，标记匹配位置，找出连续匹配位置的最长子串。

### 可拓展之处
同类型题如括号匹配的合法性判断、嵌套括号深度计算等。类似算法套路可用于处理其他匹配问题，如字符串匹配、区间匹配等。

### 洛谷相似题目推荐
1. **P1739 表达式括号匹配**（https://www.luogu.com.cn/problem/P1739）
2. **P1449 后缀表达式**（https://www.luogu.com.cn/problem/P1449）
3. **P5788 【模板】单调栈**（https://www.luogu.com.cn/problem/P5788）

### 个人心得摘录与总结
- **OItby**：提到受最长上升子序列影响构建状态，强调画图理解状态转移方程，体现了知识迁移和可视化思维的重要性。
- **米奇奇米**：对自己的代码与第一篇题解对拍结果存疑，反映出调试过程中可能遇到结果不一致的问题，需要进一步排查原因。 

---
处理用时：35.35秒
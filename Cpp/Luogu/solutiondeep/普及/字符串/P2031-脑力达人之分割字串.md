# 题目信息

# 脑力达人之分割字串

## 题目背景

好吧，该来的废话还是要来的。

画外音：

终于，在两轮的重重选拔之后，我们的海选终于结束了。现在进入我们的循环赛环节。循坏赛一共有四场，最后选出得分最高的 $16$ 人进入对决，得分相同则和按用时排名，若仍有不能确定 $16$ 人的情况，则去尾处理。

欢迎您收看有洛谷卫视重磅推出的综合性文艺知识类节目“开心玩游戏，轻松赢比赛”，我是 LUWM。学编程，就选洛谷， 感谢洛谷 Online Judge 对本节目的大力支持。下面，我们有请 $10$ 位选手上台，由大屏幕给出题目。


## 题目描述

现在有一个字符串，你可以对这个字符串进行拆分，如 `abcvsdaas` 可以拆分为 `abc|vs|d|aas`，现在再给你一个字典，要求分割成的每一个子串必须要有包含其中的任意一个单词。那么最多可以分为几个子串呢？


## 说明/提示

特殊情况：

如果原字符串不能被分割，请输出 $0$。



数据范围：

对于 $20\%$ 的数据，$1\leq |s| \leq 50,1\leq n\leq 50$。

对于 $100\%$ 的数据，$1\leq |A_i| \leq |s|\leq 300，1\leq N\leq 500$。

其中，$|s|,|A_i|$ 表示字符串 $s$ 与 $A_i$ 的长度。

## 样例 #1

### 输入

```
asdsd

3

as

sd

ds```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何将字符串按要求分割成最多子串展开，使用了贪心、动态规划等多种算法。贪心算法通过记录子串区间并求最大不相交区间数量来求解；动态规划则通过定义状态和状态转移方程，不断更新最大分割数。部分题解还使用了 Trie 树、邻接表等数据结构进行优化。

### 高评分题解
1. **作者：syf2008（5星）**
    - **关键亮点**：思路清晰，通过将问题转化为求最大不相交区间数量，利用结构体存储区间信息并排序求解，代码可读性高。
    - **核心代码**：
```cpp
struct ss {
    int l, r;
} f[100005];
bool cmp(ss a, ss b) { return a.r < b.r; }
//...
for(int i = 1; i <= n; i++) {
    cin >> b;
    lenb = b.size();
    for(int j = 0; j <= lena - lenb; j++)
        if(a.substr(j, lenb) == b) {
            ++s;
            f[s].l = j;
            f[s].r = j + lenb - 1;
        }
}
sort(f + 1, f + s + 1, cmp);
for(int i = 1; i <= s; i++)
    if(tmp < f[i].l) {
        tmp = f[i].r;
        ans++;
    }
```
    - **核心思想**：先找出所有符合要求的子串区间，然后按区间右端点排序，遍历区间，选择不相交的区间，统计数量。

2. **作者：a16_（4星）**
    - **关键亮点**：使用动态规划，通过 `unordered_map` 快速判断子串是否在字典中，状态转移方程清晰。
    - **核心代码**：
```cpp
unordered_map<string, bool> m;
int n, f[305];
//...
for(int i = 1; i <= n; i++) {
    cin >> a;
    m[a] = 1;
}
int l = s.length();
for(int i = 0; i < l; i++) {
    string temp = "";
    f[i] = f[i - 1];
    for(int j = i; j >= 0; j--) {
        temp = s[j] + temp;
        if(m[temp]) {
            f[i] = max(f[i], (j > 0? f[j - 1] : 0) + 1);
        }
    }
}
```
    - **核心思想**：定义 `f[i]` 表示前 `i` 个字符最多可分割的子串数，枚举以 `i` 结尾的子串，若在字典中则更新 `f[i]`。

3. **作者：Orion_Rigel（4星）**
    - **关键亮点**：结合 Trie 树和动态规划，利用 Trie 树高效查找字典中的单词，优化了查找过程。
    - **核心代码**：
```cpp
int t[150001][30], root = 1, cnt = 1;
int end[150001], f[301], n, l1, l2;
char s1[301], s2[301];
void insert() {
    int now = root; scanf("%s", s2 + 1); l2 = strlen(s2 + 1);
    for (int i = 1; i <= l2; ++i) {
        if (!t[now][s2[i] - 'a']) t[now][s2[i] - 'a'] = ++cnt;
        now = t[now][s2[i] - 'a'];
    }
    end[now]++;
}
void dp() {
    memset(f, 0, sizeof f);
    f[0] = 0; l1 = strlen(s1 + 1);
    for (int i = 1; i <= l1; ++i) {
        f[i] = max(f[i - 1], f[i]);
        int now = 1, p = i;
        while (now) {
            now = t[now][s1[p] - 'a'];
            if (end[now]) f[p] = max(f[p], f[i - 1] + 1);
            p++;
        }
    }
    int ans = 0;
    for (int i = 1; i <= l1; ++i) ans = max(ans, f[i]);
    printf("%d\n", ans);
}
```
    - **核心思想**：先将字典中的单词插入 Trie 树，然后进行动态规划，遍历字符串，在 Trie 树中查找以当前字符结尾的单词，更新最大分割数。

### 最优关键思路或技巧
- **贪心算法**：将问题转化为最大不相交区间问题，通过排序和遍历选择最优解。
- **动态规划**：定义合理的状态和状态转移方程，利用字典快速判断子串是否符合要求。
- **数据结构优化**：使用 Trie 树、`unordered_map` 等数据结构提高查找效率。

### 可拓展之处
同类型题可包括字符串分割的其他约束条件，如子串长度限制、分割次数限制等。类似算法套路可应用于区间覆盖、资源分配等问题。

### 推荐题目
1. P1803 凌乱的yyy / 线段覆盖
2. P1048 采药
3. P1164 小A点菜

### 个人心得
- **xiezihanAKIOI**：不确定自己的贪心做法是否正确，欢迎大家提供 hack 数据，体现了对算法正确性的严谨态度。
- **Neven**：第一次写题解，表达不清楚请谅解，展现了初学者的谦逊和积极分享的精神。
- **flyfree**：将字符转换为数字主要是为了看着顺眼，说明在代码实现中可以根据个人习惯进行适当处理。 

---
处理用时：32.65秒
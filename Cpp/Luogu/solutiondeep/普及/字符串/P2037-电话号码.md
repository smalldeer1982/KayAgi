# 题目信息

# 电话号码

## 题目描述

一串由长长的数字组成的电话号码通常很难记忆。为了方便记忆，有种方法是用单词来方便记忆。例如用 `Three Tens` 来记忆电话 `3-10-10-10`。

电话号码的标准形式是七位数字，中间用连字号分成前三个和后四个数字（例如：`888-1200`）。电话号码可以用字母来表示。以下是字母与数字的对应：

 - `A`，`B` 和 `C` 对应 `2`；
 - `D`，`E` 和 `F` 对应 `3`；
 - `G`，`H` 和 `I` 对应 `4`；
 - `J`，`K` 和 `L` 对应 `5`；
 - `M`，`N` 和 `O` 对应 `6`；
 - `P`，`R` 和 `S` 对应 `7`；
 - `T`，`U` 和 `V` 对应 `8`；
 - `W`，`X` 和 `Y` 对应 `9`。

你会发现其中没有字母 `Q` 和 `Z`。电话中的连字号是可以忽略。例如 `TUT-GLOP` 的标准形式是 `888-4567`，`310-GINO` 的标准形式是 `310-4466`，`3-10-10-10` 的标准形式是 `310-1010`。

如果两个电话号码的标准形式是一样的，那么这两个电话号码就是一样的。

现在有一本电话簿，请从中找出哪些电话号码是重复的。


## 说明/提示

【数据范围】

对于 $30\%$ 的数据，$N\le20$。

对于 $50\%$ 的数据，$N\le10000$。

对于 $100\%$ 的数据，$N\le10^5$。


## 样例 #1

### 输入

```
3

TUT-GLOP

3-10-10-10

310-1010

```

### 输出

```
310-1010 2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕将不规则电话号码转换为标准形式并找出重复号码展开。思路上可分为排序统计、使用 `map` 统计、数组模拟统计、字典树统计等。

排序统计类通过将电话号码转换后排序，遍历统计重复；`map` 统计类利用 `map` 自动排序和计数功能；数组模拟统计类用数组下标表示电话号码进行计数；字典树统计类构建字典树存储电话号码并统计。

解决的难点主要有字母与数字的映射转换、连字符的处理、前导零的处理以及无重复情况的特判。

### 所选题解
- **作者：tututu（5星）**
    - **关键亮点**：思路清晰，代码简洁，使用 `sort` 排序后线性遍历统计重复，避免复杂数据结构，可读性强。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    cin>>cnt;
    for(int j=0;j<cnt.length();j++)
        if(cnt[j]<='9'&&cnt[j]>='0') s[i]+=cnt[j];
        else if(cnt[j]>='A'&&cnt[j]<='Z') s[i]+='0'+f[cnt[j]-'A'];
}
sort(s+1,s+n+1);
for(int i=1;i<=n+1;i++)
    if(s[i]!=s[i-1]){
        if(t>1) cout<<s[i-1].substr(0,3)<<'-'<<s[i-1].substr(3,4)<<' '<<t<<endl,fa=true;
        t=1;
    } else t++;
```
    - **核心思想**：先将输入的电话号码转换为标准形式存储在字符串数组中，然后对数组排序，最后遍历数组统计重复电话号码。

- **作者：Hamer_sans（4星）**
    - **关键亮点**：提供两种思路，涵盖 `map` 和数组模拟两种常见方法，对不同思路分析清晰。
    - **核心代码（思路一）**：
```cpp
string work(string x){
    int len=0;
    string a="";
    bool flag=0;
    for(register int j=0;j<x.size();++j){
        if(len==8) break;
        if(flag==0 and len==3){
            a+='-';
            ++len;
        }
        if(!isdigit(x[j]) and x[j]!='-'){
            a+=Hash(x[j]);
            ++len;
        }
        if(isdigit(x[j])){
            a+=x[j];
            ++len;
        }
    }
    return a;
}
for(register int i=1;i<=n;++i){
    string x;
    cin>>x;
    string a=work(x);
    mp[a]++;
}
```
    - **核心思想**：定义 `work` 函数将输入字符串转换为标准形式，使用 `map` 统计每个标准形式的出现次数。

- **作者：EuphoricStar（4星）**
    - **关键亮点**：使用 `map` 简洁实现，思路清晰，代码规范，注释详细。
    - **核心代码**：
```cpp
for (int i = 0; i < n; ++i)
{
    string num, newnum = "";
    cin >> num;
    for (int i = 0; i < num.size(); ++i)
        if (num[i]!= '-') newnum += cmap[num[i]];
    ++phone[newnum];
}
for (map<string, int>::iterator it = phone.begin(); it!= phone.end(); ++it)
{
    if (it->second > 1)
    {
        print(it->first);
        cout << ' ' << it->second << '\n';
        flag = 1;
    }
}
```
    - **核心思想**：将输入的电话号码转换为标准形式，使用 `map` 统计出现次数，最后遍历 `map` 输出重复电话号码。

### 最优关键思路或技巧
- **数据结构**：使用 `map` 可自动排序和计数，简化统计过程；数组模拟可直接用下标表示电话号码，空间换时间。
- **算法优化**：排序后线性遍历可高效统计重复；预处理字母与数字映射关系，减少重复计算。
- **代码实现技巧**：使用 `printf` 的 `%03d` 和 `%04d` 处理前导零；字符串拼接时注意连字符位置。

### 可拓展之处
同类型题如字符串转换、统计重复元素等，可使用类似的排序、哈希表、字典树等方法。类似算法套路有字符串处理、数据统计与去重等。

### 推荐题目
- P1059 明明的随机数：涉及数据去重和排序。
- P1161 开灯：统计元素出现次数。
- P1217 [USACO1.5]回文质数 Prime Palindromes：字符串处理和质数判断。

### 个人心得摘录与总结
- **Deny_小田**：POJ 原题在洛谷上得分低，需重新思考。实现时要注意读入、字母转换（Q 和 Z 无对应）、避免超时等细节。
- **MC_Launcher**：WA 和 RE 多次后通过，要注意字符串和数字转换、前导零处理。
- **Nemonade**：使用 `map` 时注意特判，避免出错。 

---
处理用时：33.82秒
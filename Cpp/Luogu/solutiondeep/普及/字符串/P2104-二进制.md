# 题目信息

# 二进制

## 题目描述

小 Z 最近学会了二进制数，他觉得太小的二进制数太没意思，于是他想对一个巨大二进制数做以下 $4$ 种基础运算：

运算 $1$：将整个二进制数加 $1$。

运算 $2$：将整个二进制数减 $1$。

运算 $3$：将整个二进制数乘 $2$。

运算 $4$：将整个二进制数整除 $2$。

小 Z 很想知道运算后的结果，他只好向你求助。

（Ps：为了简化问题，数据保证 `+`，`-` 操作不会导致最高位的进位与退位）

## 说明/提示


对于 $30\%$ 的数据，$1 \leq n,m \leq 1000$。

对于 $60\%$ 的数据，$1 \leq n,m \leq 10^5$。

对于 $100\%$ 的数据，$1 \leq n,m \leq 5 \times 10^6$。

## 样例 #1

### 输入

```
4 10
1101
*/-*-*-/*/```

### 输出

```
10110```

# AI分析结果

### 综合分析与结论
这些题解主要围绕二进制数的加减乘除运算模拟展开，核心在于处理好加减法的进位和借位问题。不同题解在数据结构使用上各有不同，如数组、字符串、`vector`、栈、双端队列等，在处理进位和借位时也有即时处理和延迟处理两种方式。

### 高评分题解
- **作者：Stay_Hungry（5星）**
    - **关键亮点**：采用延迟标记的思想，将进位和借位操作延迟到最后统一处理，避免了频繁进位带来的性能问题，时间复杂度为 $O(m)$，思路清晰且代码简洁。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e6 + 5;
int f[N * 2], n, m, r; char c;
signed main() {
    ios :: sync_with_stdio(false);
    cin >> n >> m; r = n;
    for(int i = 1; i <= n; ++i) cin >> c, f[i] = c - '0';
    while(m --) {
        cin >> c;
        if(c == '*') f[++ r] = 0;
        else if(c == '+') ++ f[r];
        else if(c == '-') -- f[r];
        else f[r - 1] += f[r] >> 1, --r;
    }
    for(int i = r; i > 1; --i) {
        f[i - 1] += f[i] >> 1;
        f[i] = f[i] & 1;
    }
    for(int i = 1; i <= r; ++i) cout << f[i]; cout << "\n";
    return 0;
}
```
    - **核心思想**：在每次操作时，仅对最后一位进行标记，乘法时在末尾加 0，除法时将标记向前推，加减法直接在最后一位操作。最后统一将延迟标记向前传递并处理进位。

- **作者：jx2014wzd（4星）**
    - **关键亮点**：提供了一般实现和 `main()` 递归两种方式，对二进制运算的处理逻辑清晰，且对每种运算的原理有详细解释。
    - **核心代码（一般实现）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[100000000] = {0}, oper[6000000] = {0};
int main()
{
    int n, m;
    scanf("%d%d%s%s", &n, &m, s, oper);
    for(int i = 0; i < m; i++)
        switch(oper[i])
        {
            case '*': s[n++] = '0';  break;
            case '/': s[--n] = '\0'; break;
            case '+': for(int k = n; s[--k]!= '0' && (s[k] = '0') ||!(s[k] = '1'); ); break;
            case '-': for(int k = n; s[--k]!= '1' && (s[k] = '1') ||!(s[k] = '0'); ); break;
        }
    puts(s);
}
```
    - **核心思想**：使用字符串存储二进制数，根据不同运算符进行相应操作，乘法在末尾加 0，除法去掉末尾字符，加减法通过从后往前遍历处理进位和借位。

- **作者：redegg（4星）**
    - **关键亮点**：运用类似线段树懒操作的思想，通过两个数组分别存储二进制数和延迟更新标记，最后统一计算结果，避免了频繁的进位和借位操作。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[10000005];
int b[10000005];
char in[6000005];
int main()
{
    scanf("%d%d",&n,&m);
    scanf("%s",in+1);
    for(int i=1;i<=n;i++)
        a[i]=in[i]-'0';
    scanf("%s",in+1);
    for(int i=1;i<=m;i++)
    {
        if(in[i]=='+') b[n]+=1;
        if(in[i]=='-') b[n]-=1;
        if(in[i]=='*') n++, a[n]=0, b[n]=0;
        if(in[i]=='/')
        {
            int an=a[n]+b[n];
            if(an<0) an-=1;
            b[n-1]+=(an)/2;
            n--;
        }
    }
    for(int i=n;i>=1;i--)
    {
        int an=a[i]+b[i];
        a[i]=((a[i]+b[i])%2+2)%2;
        if(an<0) an-=1;
        b[i-1]+=an/2;
    }
    for(int i=1;i<=n;i++)
        printf("%d",a[i]);
    printf("\n");
    return 0;
}
```
    - **核心思想**：用数组 `a` 存储二进制数，数组 `b` 存储延迟更新标记。在操作过程中，加减法直接更新 `b` 数组，乘法和除法更新 `a` 数组并处理标记传递。最后从低位到高位统一处理标记并计算最终结果。

### 最优关键思路或技巧
- **延迟处理思想**：如 Stay_Hungry 和 redegg 的题解，将进位和借位操作延迟到最后统一处理，避免了频繁进位带来的性能问题，降低了时间复杂度。
- **数据结构选择**：根据不同需求选择合适的数据结构，如 `vector`、栈、双端队列等，方便进行元素的添加、删除和遍历操作。

### 拓展思路
同类型题可涉及更大规模的高精度运算，或增加更多复杂的运算符，类似算法套路可用于处理其他进制的运算模拟，如八进制、十六进制等。

### 推荐题目
- P1601  A+B Problem（高精）
- P2142  高精度减法
- P1303  A*B Problem

### 个人心得摘录与总结
- **Stay_Hungry**：提到做了相似题来拿双倍经验，指出 $O(nm)$ 暴力的瓶颈在于 $+-$ 操作的进位，在模拟赛中即使判了相邻 $+-$ 操作消除部分操作也只有 73 分，强调了延迟标记的重要性。
- **Terrific_Year**：表示代码实现看似简单，但自己调了半个小时，说明在处理二进制运算时细节容易出错，需要仔细调试。
- **时律**：刚开始以为 `n<=63` 用了 `unsigned long long`，后来发现数据规模大需要用其他方法，提醒做题时要仔细审题，根据数据规模选择合适的算法和数据结构。 

---
处理用时：41.94秒
# 题目信息

# 小Z的关系距离

## 题目描述

小 Z 学习了辩证唯物主义，知道了联系具有普遍性。他看着草稿纸上的字符串，就想挖掘它们之间的关系。

小 Z 认为，对于两个字符串 $a,b$，如果它们各自删除不超过其自身长度一半的字符能够相等，则称 $a,b$ 有距离为 $1$ 的关系。而如果存在另一个字符串 $c$，它和 $a$ 有距离为 $1$ 的关系，和 $b$ 有距离为 $n$ 的关系，则称 $a,b$ 有距离为 $n + 1$ 的关系。

现在小 Z 随机挑选出了两个小写字母字符串 $a,b$，想知道它们之间关系的最小距离，希望你帮帮他。

## 说明/提示

对于 $30\%$ 的数据，$a,b$ 由同一字母构成。

对于 $100\%$ 的数据，$1 \leq |a|,|b| \leq 100$。

## 样例 #1

### 输入

```
abcdef
axcyd```

### 输出

```
1```

## 样例 #2

### 输入

```
a
b```

### 输出

```
2```

## 样例 #3

### 输入

```
abb
baa```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解整体思路一致，均围绕最长公共子序列（LCS）求解两字符串关系的最小距离。先通过 LCS 算法求出初始的最长公共子序列长度，若其大于等于较长字符串长度的一半，距离为 1；否则，不断在较短字符串中添加字符（实际通过计算模拟），使最长公共子序列长度增加，直至满足条件，距离为操作次数加 1。

### 所选题解
- **作者：Math_rad_round（5 星）**
    - **关键亮点**：思路清晰，详细阐述了距离为 1 与最长公共子序列长度的等价关系，代码简洁且注释清晰。
    - **核心代码**：
```cpp
#include<iostream>
using namespace std;
string a,b;
int f[300][300];
int main(){
    cin>>a>>b;
    int n=a.length(),m=b.length();
    if(n<m){
        swap(n,m);swap(a,b);
    }
    if(a==b){
        cout<<"1";return 0;
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            f[i][j]=max(f[i-1][j],f[i][j-1]);
            if(a[i-1]==b[j-1])f[i][j]=max(f[i][j],f[i-1][j-1]+1);
            ans=max(f[i][j],ans);
        }
    }
    int cnt=0;
    while(ans*2<n){
        cnt++;ans+=m;m+=m;
    }cnt++;
    cout<<cnt;
    return 0;
}
```
    - **核心实现思想**：先输入两个字符串，确保 `a` 为较长字符串，特判两字符串相等的情况。通过双重循环计算最长公共子序列长度，再通过循环模拟在较短字符串中添加字符，使最长公共子序列长度增加，最后输出距离。

- **作者：__JiCanDuck__（4 星）**
    - **关键亮点**：思路整合清晰，代码有详细注释，方便理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int K=105;
int dp[K][K];
string aa,bb;
int n,m,lcs,cnt;
int main()
{
    cin>>aa>>bb;
    n=aa.size(),m=bb.size();
    aa=" "+aa;
    bb=" "+bb;
    if(m>n) {
        swap(aa,bb);
        swap(n,m);
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            if(aa[i]==bb[j])
                dp[i][j]=dp[i-1][j-1]+1;  
            else
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
        }
    lcs=dp[n][m];
    while(lcs*2<n)
    {
        cnt++;
        lcs+=m;
        m+=m;
    }
    cnt++;
    cout<<cnt;
    return 0;
}
```
    - **核心实现思想**：输入字符串并处理长度，保证 `aa` 为较长字符串。通过双重循环计算最长公共子序列长度，再循环模拟添加字符，最后输出距离。

### 最优关键思路或技巧
- **思维方式**：将问题转化为最长公共子序列问题，通过计算最长公共子序列长度判断两字符串关系距离。
- **代码实现技巧**：使用动态规划求解最长公共子序列，通过循环模拟在较短字符串中添加字符，避免实际操作字符串，提高效率。

### 可拓展之处
同类型题或类似算法套路：
- 字符串编辑距离问题，如莱文斯坦距离，通过插入、删除、替换操作使两字符串相等，可使用动态规划求解。
- 最长公共子串问题，与最长公共子序列类似，但要求子串连续。

### 推荐题目
- P1439 【模板】最长公共子序列
- P1265 公路修建问题
- P1063 能量项链

### 个人心得摘录与总结
- **作者：killer_queen4804**：一开始以为只要最长公共子序列大于等于两字符串长度的一半就是距离为 1，忽略了一长一短的情况，提醒我们做题时要考虑全面。 

---
处理用时：27.17秒
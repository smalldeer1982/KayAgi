# 题目信息

# 一中校运会之百米跑

## 题目背景

在一大堆秀恩爱的 \*\* 之中，来不及秀恩爱的苏大学神踏着坚定（？）的步伐走向了 $100$ 米跑的起点。这时苏大学神发现，百米赛跑的参赛同学实在是太多了，连体育老师也忙不过来。这时体育老师发现了身为体育委员的苏大学神，便来找他帮忙。

可是苏大学神需要热身，不然跑到一半就会抽（筋）、于是他就找到了你。。。如果你帮助体育老师解决了问题，老师就会给你 $5$ 个积分。

## 题目描述

假设一共有 $N$（$2\leq N\leq 2\times 10^4$）个参赛选手。（尼玛全校学生都没这么多吧）

老师会告诉你这 $N$ 个选手的名字。

接着会告诉你 $M$（$1\leq M\leq 10^6$）句话，即告诉你学生 A 与学生 B 在同一个组里。

如果学生 A 与学生 B 在同一组里，学生 B 与学生 C 也在同一组里，就说明学生 A 与学生 C 在同一组。

然后老师会问你 $K$（$1\leq K\leq 10^6$）句话，即学生 X 和学生 Y 是否在同一组里。

若是则输出 `Yes.`，否则输出 `No.`。

## 样例 #1

### 输入

```
10 6
Jack
Mike
ASDA
Michel
brabrabra
HeHe
HeHE
papapa
HeY
Obama
Jack Obama
HeHe HeHE
brabrabra HeHe
Obama ASDA
papapa Obama
Obama HeHE
3
Mike Obama
HeHE Jack
papapa brabrabra
```

### 输出

```
No.
Yes.
Yes.
```

# AI分析结果

### 综合分析与结论
本题核心是并查集的应用，难点在于处理字符串输入。各题解整体思路都是先将选手名字与编号建立映射，再用并查集处理分组和查询问题，差异主要在字符串处理方式上。

### 所选题解
- **作者：vectorwyx（5星）**
    - **关键亮点**：思路清晰，直接点明本题是并查集模板题，使用 `map` 处理字符串，代码简洁易懂，注释详细。
    - **核心代码**：
```cpp
#include<map>
using namespace std;
map<string,string> a;
string fin(string x){
    if(a[x]==x) return x;
    else return a[x]=fin(a[x]);
}
int main(){
    int n,m,k;
    string s1,s2;
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        cin>>s1;
        a[s1]=s1;
    }
    for(int i=1;i<=m;++i){
        cin>>s1>>s2;
        string x1=fin(s1),x2=fin(s2);
        if(x1!=x2) a[x1]=x2;
    }
    cin>>k;
    for(int i=1;i<=k;++i){
        cin>>s1>>s2;
        string x1=fin(s1),x2=fin(s2);
        if(x1!=x2) printf("No.\n");
        else printf("Yes.\n");
    }
    return 0;
}
```
    - **核心思想**：使用 `map<string, string>` 建立字符串到字符串的映射，每个选手的祖先初始化为自己，通过 `fin` 函数查找祖先并进行路径压缩，合并和查询操作与普通并查集一致。

- **作者：翼德天尊（4星）**
    - **关键亮点**：从是什么、为什么、怎么做三个方面详细阐述并查集知识，对初学者友好，代码注释详细。
    - **核心代码**：
```cpp
string f[20001],mz[20001];
int fname(string name){
    for (int i=1;i<=n;i++){
        if (name==mz[i]) return i;
    }
}
string find(string name){
    if (f[fname(name)]==name) return name;
    return f[fname(name)]=find(f[fname(name)]);
} 
int main(){
    scanf("%d %d",&n,&m);
    for (int i=1;i<=n;i++){
        cin>>f[i];
        mz[i]=f[i];
    }
    for (int i=1;i<=m;i++){
        string a,b;
        cin>>a>>b;
        f[fname(find(a))]=find(b);
    }
    scanf("%d",&k);
    for (int i=1;i<=k;i++){
        string a,b;
        cin>>a>>b;
        if (find(a)==find(b)) printf("Yes.\n");
        else printf("No.\n");
    }
    return 0;
}
```
    - **核心思想**：使用数组 `mz` 存储选手名字，`fname` 函数用于查找名字对应的编号，`find` 函数进行并查集的查找和路径压缩，合并和查询操作基于编号进行。

- **作者：Magallan_forever（4星）**
    - **关键亮点**：详细介绍并查集和哈希的原理，结合并查集和哈希处理字符串，代码模块化程度高。
    - **核心代码**：
```cpp
typedef unsigned long long ull;
const int seed=233;
int hash(string s){
    ull hash_=0;
    for(int i=0;i<s.length();i++) hash_=hash_*seed+s[i];
    return hash_%200000;
}
struct union_find_set{
    vector<int> f;
    void init(int maxn){
        f.clear();
        for(int i=0;i<maxn;i++){
            f.push_back(i);
        }
    }
    int getf(int v){
        if(v==f[v])return v;
        return f[v]=getf(f[v]);
    }
    void merge(int a,int b){
        int fa=getf(a),fb=getf(b);
        f[fb]=f[fa];
    }
    bool in(int x,int y){
        return f[getf(x)]==f[getf(y)];
    }
};
int main(){
    union_find_set set_;
    set_.init(200000);
    int n,m,k;
    scanf("%d%d",&n,&m);
    while(n--) cin>>a;
    while(m--) cin>>a>>b,set_.merge(hash(a),hash(b));
    scanf("%d",&k);
    while(k--) cin>>a>>b,puts(set_.in(hash(a),hash(b))?"Yes.":"No.");
    return 0;
}
```
    - **核心思想**：使用 `hash` 函数将字符串转换为整数，`union_find_set` 结构体封装并查集的初始化、查找、合并和查询操作，通过哈希值进行并查集的操作。

### 最优关键思路或技巧
- **使用 `map` 处理字符串**：通过 `map<string, int>` 或 `map<string, string>` 建立字符串到编号或字符串到祖先的映射，方便进行并查集操作，代码简洁。
- **路径压缩优化**：在查找祖先的过程中，将节点直接连接到祖先，降低后续查找的时间复杂度。

### 可拓展之处
同类型题通常是并查集结合其他数据结构或算法，如并查集与图论结合，处理连通性问题；并查集与哈希结合，处理字符串或离散化数据。类似算法套路包括使用并查集维护集合的合并和查询，通过路径压缩和按秩合并优化时间复杂度。

### 推荐题目
1. [P3367 [模板] 并查集](https://www.luogu.com.cn/problem/P3367)：并查集的基础模板题，用于巩固并查集的基本操作。
2. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)：与本题类似，判断两个人是否为亲戚，即是否在同一个集合中。
3. [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)：并查集与图论结合，处理删除节点后的连通性问题。

### 个人心得摘录与总结
- **zybnxy**：因字符串查找出现错误，调试近半个小时，提醒在处理字符串时要注意细节。
- **我没有小白**：用字符串的 ASCII 码和作为编号，没想到数据很水，竟然 AC 了，说明在比赛中可以尝试一些大胆的想法，但要注意数据的特殊性。 

---
处理用时：45.15秒
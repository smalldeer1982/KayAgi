# 题目信息

# 情书

## 题目背景

一封好的情书需要撰写人全身心的投入。CYY同学看上了可爱的c**想对她表白，但却不知道自己写的情书是否能感动她，现在他带着情书请你来帮助他。



## 题目描述

为了帮助CYY，我们定义一个量化情书好坏的标准感动值。判断感动值的方法如下:

1. 在情书的一句话中若含有给定词汇列表中的特定单词，则感动值加1，但每一单词在同一句话中出现多次感动值不叠加，不同单词不受影响。保证输入的单词不重复。
2. 每句话以英文句号定界。
3. 全文不区分大小写。


## 说明/提示

对于所有的数据，保证1 ≤ n ≤ 100，每个单词不超过50字符，全文不超过1000字符。


## 样例 #1

### 输入

```
3
love
so
much
I love you so much.
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解围绕计算情书感动值展开，主要思路是将输入的关键词和情书内容统一大小写，按句号分割句子，在句子内判断关键词出现情况并避免重复计数。各题解在数据结构使用、代码实现细节上有所不同，如使用`map`、`set`、`Trie树`、`字符串哈希`等数据结构，以及不同的字符串处理方式。

### 所选题解
- **作者：起名真的很难（5星）**
    - **关键亮点**：思路清晰，详细阐述了每个步骤的处理方法，使用`transform`函数统一大小写，`use`数组进行关键词判重，代码注释丰富，易于理解。
    - **个人心得**：提到`getchar()`不能少，否则会被坑，强调了输入处理的细节。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,tot,use[2010];
string word[2010],sen,sent="";

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        cin>>word[i];
        transform(word[i].begin(),word[i].end(),word[i].begin(),::tolower);
    }
    getchar();
    getline(cin,sen);
    transform(sen.begin(),sen.end(),sen.begin(),::tolower);
    for(int i=0;i<sen.size();++i)
    {
        if(sen[i]=='.')
        {
            for(int j=1;j<=n;++j)
            {
                if(sent==word[j]&&!use[j])
                {
                    use[j]=1,++tot;
                    break;
                }
            }
            sent="";
            memset(use,0,sizeof(use));
            continue;
        }
        if(sen[i]==',')
        {
            for(int j=1;j<=n;++j)
            {
                if(sent==word[j]&&!use[j])
                {
                    use[j]=1,++tot;
                    break;
                }
            }
            sent="";
            continue;
        }
        if(sen[i]==' ')
        {
            for(int j=1;j<=n;++j)
            {
                if(sent==word[j]&&!use[j])
                {
                    use[j]=1,++tot;
                    break;
                }
            }
            sent="";
            continue;
        }
        sent+=sen[i];
    }
    printf("%d",tot);
    return 0;
}
```
核心实现思想：先将关键词和情书内容统一转换为小写，然后遍历情书内容，按句号、逗号、空格分割单词，判断单词是否为关键词且未在当前句子中出现过，若是则感动值加1，遇到句号时重置关键词使用标记。

- **作者：一把丶抱住鑫（4星）**
    - **关键亮点**：提供了测试用例，代码中对大小写转换和关键词判重处理清晰，使用`map`进行标记，逻辑明确。
    - **个人心得**：提醒注意`you`和`your`的包含关系，以及发现句号后标记数组要清零。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,u;
map<string,bool>can;
int n,ans;
string v[106];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>v[i];
    }
    getline(cin,u);
    getline(cin,s);
    for(int i=1;i<=n;i++){
        for(int j=0;j<v[i].size();j++){
            if(v[i][j]>='A'&&v[i][j]<='Z')v[i][j]+=32;
        }
    }
    for(int i=0;i<s.size();i++){
        if(s[i]>='A'&&s[i]<='Z')s[i]+=32;
    }
    for(int j=1;j<=n;j++){
        for(int i=0;i<s.size();i++){
            if(s[i]=='.')can.clear();
            if(s.substr(i,v[j].size())==v[j]&&(s[i+v[j].size()]=='.'||s[i+v[j].size()]==','||s[i+v[j].size()]==' ')){
                if(can[v[j]])continue;
                can[v[j]]=1;
                ans++;
            }
        }
    }
    printf("%d\n",ans);
    return 0;
} 
```
核心实现思想：将关键词和情书内容转换为小写，遍历情书内容，按句号分割句子，判断关键词是否在句子中出现且未重复，若是则感动值加1。

- **作者：juruo_zjc（4星）**
    - **关键亮点**：使用`set`进行操作，代码简洁，思路清晰，通过`set`的特性实现关键词判重。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
set<string>se,se2;
int ans,n;
int main()
{
    scanf("%d",&n);
    string a;
    for(int i=1;i<=n;i++){
        cin>>a;
        for(int i=0;i<a.length();i++)
            if(a[i]>='a'&&a[i]<='z') a[i]-=32;
        se.insert(a); 
    }
    char ch=getchar();
    string b;
    while(scanf("%c",&ch)==1){
        if(ch=='\n')break;
        if((ch>='A'&&ch<='Z')||(ch>='a'&&ch<='z')){
            if(ch>='a'&&ch<='z')ch=ch-32;
            b+=ch;
        }
        else{
            if(!b.empty()){
                if(se.count(b))se2.insert(b);
                b.clear();
            }
            if(ch=='.')ans+=se2.size(),se2.clear();
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
核心实现思想：将关键词转换为大写存入`se`集合，遍历情书内容，按非字母字符分割单词，判断单词是否在`se`集合中，若是则存入`se2`集合，遇到句号时将`se2`集合的大小累加到感动值中并清空`se2`集合。

### 最优关键思路或技巧
- **数据结构**：使用`map`、`set`、`Trie树`、`字符串哈希`等数据结构进行关键词存储和判重，提高查找效率。
- **算法优化**：统一大小写处理，避免大小写差异带来的判断问题；按句号分割句子，在句子内进行关键词判重，减少重复计算。
- **思维方式**：将问题拆解为关键词判重、句子分割、大小写统一等子问题，逐个解决。
- **代码实现技巧**：使用`transform`函数进行大小写转换，使用`stringstream`进行字符串分割，使用`find`函数进行字符串查找。

### 可拓展之处
同类型题或类似算法套路：
- 文本关键词统计：统计文本中特定关键词的出现次数，可参考本题的关键词判重和字符串处理方法。
- 字符串匹配问题：如KMP算法、AC自动机等，可用于解决多模式串匹配问题。
- 文本分类问题：根据文本中的关键词对文本进行分类，可使用本题的关键词存储和判断方法。

### 推荐题目
- P1308 [NOIP2011 普及组] 统计单词数
- P3811 【模板】乘法逆元
- P1165 日志分析

### 个人心得摘录与总结
- **起名真的很难**：强调`getchar()`在输入处理中的重要性，避免因输入问题导致错误。
- **一把丶抱住鑫**：提醒注意`you`和`your`的包含关系，以及发现句号后标记数组要清零，避免逻辑错误。
- **Rey_HR**：模拟题要注意细节，如逗号的处理，避免因细节问题导致代码出错。
- **约修亚_RK**：注意题目中的条件，如全文不区分大小写，以及清空当前句子的标记集合，避免遗漏关键信息。

---
处理用时：56.50秒
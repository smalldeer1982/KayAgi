# 题目信息

# yyy2015c01 的 IDE 之 Watches

## 题目背景

在 2020 年的某一天，我们的 yyy2015c01 同学想要开发一套 IDE。

## 题目描述

作为他开发团队中的一员，你不幸地被选入了 Debugger 的开发组。

yyy2015c01 设想的 Debugger 由几部分组成，其中的一个小组件就是 Watches——中文称之为“变量观察器”。

由于 IDE 目前还是内测版，开发组需要先编一个能观察 int 类型变量值的 Watches 来看看效果如何。这个任务交由你来完成。

开发组假想的 Watches 能实现如下 3 种语句运行后监测相应变量值的功能：
- `n=1;` 将常量赋给变量，保证这个常量的位数不大于 $9$。
- `a=b;` 变量之间赋值：若原变量（在本例中是 $b$）未被赋值则认为其初始值为 $0$。
- `m=1+2;` $A+B$ 表达式赋值，只有 `+` 且只有两个数或者变量，$A$ 和 $B$ 都介于 $1$ 至 $10^6$ 之间。

请你编写一个 Watches，并在所有语句运行完后对所有被赋值过的变量按标识符的字典序输出它们的值（保证不会有变量的值大于 int 的最大值）。


## 说明/提示

数据很弱，直接模拟过哟~

（别想着变量标识符只有一位哟！）

另：向本题主人公 yyy2015c01 同学致敬！

## 样例 #1

### 输入

```
3
a=233;
b=a;
c=a+b;```

### 输出

```
a 233
b 233
c 466```

## 样例 #2

### 输入

```
3
a=233;
b=1+1;
a=b;```

### 输出

```
a 2
b 2```

# AI分析结果

### 综合分析与结论
本题主要考察字符串处理和模拟能力，需根据输入的赋值语句更新变量值，并按字典序输出所有被赋值变量。各题解思路大体一致，先解析输入语句，判断赋值类型（常量赋值、变量赋值、加法表达式赋值），再更新变量值，最后排序输出。主要差异在于输入处理、字符串解析和变量存储方式。

### 所选题解
- **作者：Okimoto（5星）**
    - **关键亮点**：思路清晰，代码注释详细；使用`scanf`的黑名单字符集功能简化输入；用`map`存储变量，自带字典序排序；将任务拆分为输入、字符串处理和输出三部分，模块化程度高。
    - **核心代码**：
```cpp
scanf("%d\n", &n); 
for(int i = 0; i < n; ++ i){
    char aa[32];
    char bb[32];
    scanf("%[^=]=", aa); 
    string a = aa;
    scanf("%[^;];\n", bb); 
    string b = bb;
    // 处理赋值语句
    if('0' <= b[0] && b[0] <= '9'){ 
        // 处理数字类型赋值
    }
    else{ 
        // 处理变量类型赋值
    }
}
sort(ans, ans + ptr, cmp);
for(int i = 0; i < ptr; i ++)
    printf("%s %d\n", ans[i].c_str(), mp[ans[i]]);
```
- **作者：a___（4星）**
    - **关键亮点**：代码简洁，使用`STL`库函数简化操作；`map`自动按字典序排序，避免额外排序操作；字符串处理逻辑清晰。
    - **核心代码**：
```cpp
cin>>n;
while(n--){
    cin>>s;
    s.erase(s.size()-1,1); 
    a=s.find('='); 
    sa=s.substr(0,a); 
    s.erase(0,a+1); 
    a=s.find('+'); 
    if(a>=0&&a<s.size()){
        // 处理加法表达式赋值
    }
    else{
        // 处理非加法赋值
    }
}
for(iter=ma.begin();iter!=ma.end();iter++)
    cout<<iter->first<<' '<<iter->second<<endl;
```
- **作者：3water（4星）**
    - **关键亮点**：利用`string`自带函数简化字符串处理；递归函数`ask`处理赋值语句，代码简洁高效。
    - **核心代码**：
```cpp
int toint(string x){
    // 字符串转整型
}
int ask(string a){
    int low=a.find('+'),lena=a.size();
    if(low<0){
        // 处理无加号情况
    }
    string s1=a.substr(0,low),s2=a.substr(low+1,lena-low-1);
    return ask(s1)+ask(s2);
}
while(n--){
    cin>>s;
    t=s.find('='),len=s.size()-t-2,rs=s.substr(t+1,len),ls=s.substr(0,t);
    if(!co[ls])co[ls]=1,st[++num]=ls;
    str[ls]=ask(rs);
}
for(int i=1;i<=num;i++)cout<<st[i]<<' '<<str[st[i]]<<endl;
```

### 最优关键思路与技巧
- **数据结构**：使用`map`存储变量及其值，自动按字典序排序，方便输出。
- **输入处理**：利用`scanf`的黑名单字符集功能或`string`的`find`、`substr`函数简化输入和字符串解析。
- **模块化设计**：将任务拆分为输入、处理和输出三部分，提高代码可读性和可维护性。

### 可拓展之处
同类型题目可能会增加赋值语句的复杂度，如引入更多运算符、嵌套表达式等。解题思路仍可基于字符串处理和模拟，需增加对不同运算符和表达式的解析逻辑。

### 推荐题目
- P1060 开心的金明：考察物品价值计算和选择，涉及简单的模拟和条件判断。
- P1047 校门外的树：模拟线段覆盖问题，需处理区间覆盖和计数。
- P1094 纪念品分组：模拟分组过程，需根据物品重量进行合理分组。

### 个人心得摘录与总结
- **happybob**：在输入处理上遇到问题，`scanf`提交出现MLE，`cin`提交因`\n`导致WA，最终使用`while`循环手动处理输入才AC。总结是输入处理需谨慎，不同输入方式可能带来不同问题。
- **D2T1**：在判断赋值语句类型时，认为赋值语句第0个字符是数字并不代表整个赋值语句是数字，还有可能是数字+数字或数字+变量的形式，这是一个坑点。提醒在字符串处理时要全面考虑各种情况。 

---
处理用时：32.22秒
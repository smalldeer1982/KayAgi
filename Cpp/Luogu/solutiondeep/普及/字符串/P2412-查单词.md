# 题目信息

# 查单词

## 题目背景

滚粗了的 HansBug 在收拾旧英语书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本英语书里面找到了一个单词表，包含 $N$ 个单词（每个单词内包含大小写字母）。现在他想要找出某一段连续的单词内字典序最大的单词。


## 说明/提示

### 样例说明

第一次操作：在{absi,hansbug,lzn,kkk,yyy}中找出字典序最大的，故为yyy

第二次操作：在{absi}中找出字典序最大的，故为absi

第三次操作：在{absi,hansbug}中找出字典序最大的，故为hansbug

第四次操作：在{hansbug,lzn}中找出字典序最大的，故为lzn

第五次操作：在{kkk}中找出字典序最大的，故为kkk

### 数据规模

 ![](https://cdn.luogu.com.cn/upload/pic/2274.png) 


## 样例 #1

### 输入

```
5 5
absi
hansbug
lzn
kkk
yyy
1 5
1 1
1 2
2 3
4 4```

### 输出

```
yyy
absi
hansbug
lzn
kkk
```

# AI分析结果

### 综合分析与结论
本题要求在给定的单词序列中，查询某段连续单词内字典序最大的单词，且比较字典序时不区分大小写，但输出需为原单词。题解主要采用了排序模拟、线段树、ST表、字典树等方法。

排序模拟思路简单，将单词按字典序排序后，对每次查询遍历找到符合区间的最大字典序单词，但时间复杂度较高，为$O(nm)$。线段树和ST表是处理区间最值问题的常用数据结构，线段树可动态更新，ST表预处理后查询更快，二者时间复杂度分别为$O(n + mlogn)$和$O(nlogn + m)$。字典树可用于确定字符串的字典序，结合ST表或其他方法可优化字符串比较的时间。

### 所选题解
- **作者：LightningUZ（5星）**
    - **关键亮点**：思路清晰，详细解释了ST表的原理和使用方法，代码注释丰富，可读性强。
    - **核心代码**：
```cpp
string mx(string a,string b)
{
    string x=a,y=b;
    for(int i=0;i<a.size();i++) upr(x[i]);
    for(int i=0;i<b.size();i++) upr(y[i]);
    return x>y?a:b;
}
string st[50100][30];
string ask(int l,int r)
{
    int lc=log2(r-l+1);
    return mx(st[l][lc],st[r-(1<<lc)+1][lc]);
} 
```
    - **核心思想**：通过`mx`函数比较两个字符串的字典序，`st`数组记录区间最大值，`ask`函数利用ST表查询区间最大值。

- **作者：zhengrunzhe（4星）**
    - **关键亮点**：使用线段树解决问题，对字符数组的处理和比较进行了详细说明，采用了读入优化等技巧。
    - **核心代码**：
```cpp
inline void build(reg int l,reg int r,reg int k)
{
    t[k].l=l;t[k].r=r;
    if (l==r)
    {
        scanf("%s",t[k].s);
        strcpy(t[k].ss,t[k].s);
        reg int len=strlen(t[k].s);
        for (i=0;i<len;i++)
            t[k].s[i]=tolower(t[k].s[i]);
        return;
    }
    reg int mid=(l+r)>>1;
    build(l,mid,lson);
    build(mid+1,r,rson);
    if (strcmp(t[lson].s,t[rson].s)>0)
        strcpy(t[k].s,t[lson].s),strcpy(t[k].ss,t[lson].ss);
    else strcpy(t[k].s,t[rson].s),strcpy(t[k].ss,t[rson].ss);
}
inline int query(reg int l,reg int r,reg int k)
{
    if (t[k].l>r||t[k].r<l)return 0;
    if (t[k].l>=l&&t[k].r<=r)return k;
    reg int a=query(l,r,lson),b=query(l,r,rson);
    return strcmp(t[a].s,t[b].s)>0?a:b;
}
```
    - **核心思想**：`build`函数构建线段树，将字符串转换为小写进行比较，`query`函数查询区间最大值。

- **作者：手链剖分（4星）**
    - **关键亮点**：结合字典树和ST表，利用字典树确定字符串的字典序，避免了朴素字符串比较的$O(n)$时间复杂度。
    - **核心代码**：
```cpp
void insert(int num,char *s)
{
    int u=0;
    for(int i=0;s[i]!='\0';i++)
    {
        int x=idx(s[i]);
        if(node[u].nx[x])
            u=node[u].nx[x];
        else
        {
            node[u].nx[x]=++tot;
            u=tot;
        }
    }
    node[u].num=num;
}
void dfs(int u)
{
    if(node[u].num)
        a[node[u].num]=++t;
    for(int i=0;i<26;i++)
        if(node[u].nx[i])
            dfs(node[u].nx[i]);
}
```
    - **核心思想**：`insert`函数将字符串插入字典树，`dfs`函数对字典树进行深度优先搜索，确定字符串的字典序。

### 最优关键思路或技巧
- **数据结构**：使用线段树、ST表等数据结构处理区间最值问题，可有效降低时间复杂度。
- **算法优化**：结合字典树确定字符串的字典序，避免了朴素字符串比较的$O(n)$时间复杂度。
- **代码实现技巧**：采用读入优化、快排、字符串转换等技巧，提高代码效率。

### 可拓展之处
- **同类型题**：区间最值查询、区间更新等问题，可使用线段树、ST表等数据结构解决。
- **类似算法套路**：对于字符串比较问题，可使用字典树、哈希等方法优化。

### 推荐题目
- P3865 【模板】ST表
- P3372 【模板】线段树 1
- P2880 [USACO07JAN]Balanced Lineup G

### 个人心得摘录与总结
- **作者：Lates**：读题很关键，要注意题目中的细节，如本题中字典序比较不区分大小写。
- **作者：YZL11111**：使用线段树时，可返回节点下标而非字符串，避免超时。
- **作者：qq907232781**：求解ST表时，可记录字串编号压缩空间，同时提前转换字符串大小写，避免比较时转换耗时。 

---
处理用时：38.75秒
# 题目信息

# [AHOI2004] 奇怪的字符串

## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/1654.png)


## 样例 #1

### 输入

```
01010101010 00000011111```

### 输出

```
6```

## 样例 #2

### 输入

```
01011 010010101111111111```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
本题是最长公共子序列（LCS）的模板题，大部分题解采用动态规划方法，核心状态转移方程为：当 `a[i - 1] == b[j - 1]` 时，`dp[i][j] = dp[i - 1][j - 1] + 1`；否则，`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`。部分题解考虑到数据规模，使用滚动数组优化空间复杂度。还有题解给出了时间复杂度优化到 $O(n\log n)$ 的方法以及求 LCS 出现次数的思路。

### 所选题解
- **作者：An_Account（5星）**
    - **关键亮点**：思路清晰，详细解释了状态转移方程和滚动数组优化的原理，代码简洁易懂。
    - **核心代码**：
```cpp
#include <iostream>
using namespace std;
int dp[2][10001];
int main()
{
    string a,b;
    cin>>a>>b;
    for (int i=1;i<=a.size();i++)
    for (int j=1;j<=b.size();j++)
    if (a[i-1]==b[j-1]) dp[i%2][j]=dp[(i-1)%2][j-1]+1;
    else dp[i%2][j]=max(dp[(i-1)%2][j],dp[i%2][j-1]);
    cout<<dp[a.size()%2][b.size()];
}
```
    - **核心实现思想**：使用二维数组 `dp` 记录状态，通过两层循环遍历两个字符串，根据状态转移方程更新 `dp` 数组，最后输出结果。利用滚动数组 `dp[i % 2]` 优化空间。

- **作者：syksykCCC（4星）**
    - **关键亮点**：对最长公共子序列的动态规划求解方法进行了详细解释，适合初学者理解。
    - **核心代码**：
```cpp
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int f[10002][10002];
int main()
{
    ios::sync_with_stdio(false);
    string s,t;
    cin>>s>>t;
    int len1=s.size(),len2=t.size();
    for(int i=1;i<=len1;i++)
    {
        for(int j=1;j<=len2;j++)
        {
            f[i][j]=max(f[i-1][j],f[i][j-1]);
            if(s[i-1]==t[j-1])
                f[i][j]=max(f[i][j],f[i-1][j-1]+1);
        }
    }
    cout<<f[len1][len2]<<endl;
    return 0;
}
```
    - **核心实现思想**：使用二维数组 `f` 记录状态，通过两层循环遍历两个字符串，分类讨论当前字符是否在最长公共子序列中，更新 `f` 数组，最后输出结果。

- **作者：Mars_Dingdang（4星）**
    - **关键亮点**：不仅给出了常规的 $O(n^2)$ 解法，还介绍了时间复杂度优化到 $O(n\log n)$ 的方法以及求 LCS 出现次数的思路和代码。
    - **核心代码（$O(n^2)$ 解法）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int Max(int x,int y) {return x>y?x:y;}
const int maxn=10005;
int f[2][maxn],n,m;
char a[maxn],b[maxn];
int main(){
    scanf("%s",a+1);n=strlen(a+1);
    scanf("%s",b+1);m=strlen(b+1);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            f[i&1][j]=Max(f[i&1][j-1],f[(i-1)&1][j]);
            if(a[i]==b[j]) f[i&1][j]=Max(f[i&1][j],f[(i-1)&1][j-1]+1);
        }
    }
    printf("%d",f[n&1][m]);
    return 0;
}
```
    - **核心实现思想**：使用二维数组 `f` 记录状态，通过两层循环遍历两个字符串，根据状态转移方程更新 `f` 数组，利用滚动数组 `f[i & 1]` 优化空间，最后输出结果。

### 最优关键思路或技巧
- **滚动数组优化**：由于 `dp[i][j]` 只与 `dp[i - 1][j]`、`dp[i][j - 1]` 和 `dp[i - 1][j - 1]` 有关，因此可以使用滚动数组将空间复杂度从 $O(nm)$ 优化到 $O(m)$。
- **时间复杂度优化**：通过对序列进行编号，将公共子序列问题转化为求最大上升子序列问题，再使用二分查找，可将时间复杂度优化到 $O(n\log n)$。

### 可拓展之处
- **同类型题**：求两个序列的最长公共子串、最长公共上升子序列等。
- **类似算法套路**：动态规划解决序列匹配问题，如编辑距离、最长回文子序列等。

### 推荐题目
- [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)
- [P1726 上白泽慧音](https://www.luogu.com.cn/problem/P1726)
- [P2516 [HAOI2010]最长公共子序列](https://www.luogu.com.cn/problem/P2516)

### 个人心得摘录与总结
- **作者：syksykCCC**：表示其它题解没有解释清楚最长公共子序列的求法，因此自己写题解进行补充解释，希望帮助像自己一样原本不会求最长公共子序列的人。总结：在学习过程中，若发现已有资料解释不清晰，可自己深入研究并分享，帮助他人理解。

---
处理用时：35.05秒
# 题目信息

# [USACO16JAN] Build Gates S

## 题目描述

FarmerJohn 打算在他农场的一部分，建设一个围栏。但是因为没有认真做事，建造完成后，围栏变成一个很奇怪的形状。

具体来说，FJ 从 $(0,0)$ 出发，走了 $N$ 步，每步移动一单位（向东、向南、向西或向北）。

他走过的每一步，都会留下一段单位长度的围栏。例如，如果他的第一步向北，他建造一单位从 $(0,0)$ 到 $(0,1)$ 的围栏。

FJ 可能重复到达点多次，他也可能重复建造一段围栏多次。如果他的路径穿过一段已经建成的围栏，他的围栏也有可能会有交叉。

不用说，FJ 看到完成的围栏时，一定很沮丧。特别的，他发现一些区域被围栏封闭起来，从而无法到达。FJ 想在围栏上，安装一些门来解决这个问题。

门可以安装在任意一段单位长度（注：必须是之前走过的某一步）的围栏上，从而可以穿越这段围栏的两侧。

请计算 FJ 最少需要安装多少个门，才能保证农场上任意区域到任意区域都可到达。

## 说明/提示

注意，如果农场初始连通，答案就是 $0$。

### 数据范围

$1\le n\le 1000$。


## 样例 #1

### 输入

```
14
NNNESWWWSSEEEE```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解的核心目标是计算最少安装门的数量，使农场各区域连通。主要思路有两类：一是计算不包含其他环的环的数量，二是统计封闭联通块的数量并减 1。

不同题解的算法要点和难点解决方式各有不同：
- **环的计算类**：通过判断点和路径的重复情况来确定环的数量，如判断点是否到过以及从不同方向到达该点是否形成新路径。
- **联通块统计类**：使用深搜或广搜统计封闭联通块数量，需处理好边界问题和小封闭区域的识别。

### 所选题解
- **作者：LPhang（5 星）**
    - **关键亮点**：提供两种思路，思路清晰，代码注释详细，对每种思路的原理和实现步骤解释透彻。
    - **核心代码（方法一）**：
```cpp
#include<bits/stdc++.h>
const int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, -1, 1};
const char s[] = {'N', 'S', 'W', 'E'};
const int N = 2e3 + 10, M = 2e3 + 10;
using namespace std;
int n, x = 1000, y = 1000, xt = 1000, yt =1000, num, bol[N][M], f[N][M], a[N][M], ans;
int main() {
    scanf("%d\n", &n); num = 1, bol[1000][1000] = 1, a[1000][1000] = 1;
    for(int i = 1; i <= n; ++i) {
        char c; scanf("%c", &c);
        for(int j = 0; j < 4; ++j) {
            if(c == s[j]) {x += dx[j], y += dy[j]; break;}
        }
        if(!bol[x][y]) a[x][y] = ++num;
        int last = a[xt][yt], now = a[x][y];
        if(!f[last][now] && bol[x][y]) ++ans;
        f[last][now] = f[now][last] = 1;
        xt = x, yt = y; bol[x][y] = 1;
    }
    printf("%d\n", ans);
    return 0;
}
```
    - **核心实现思想**：模拟 FJ 的移动过程，记录每个点的编号和点之间的路径。若到达一个已访问的点且该路径之前未出现过，则形成一个新的环，答案加 1。

- **作者：lxzy_（4 星）**
    - **关键亮点**：详细阐述了标记围栏、确定搜索边界和统计封闭区域数量的步骤，对可能出现的问题进行了详细说明。
    - **核心代码**：
```cpp
#include<iostream>
#include<queue>
using namespace std;
const int N=4002;
bool map[N][N];
int n;
string s;
int x=2001;
int y=2001;
int Maxx=2001;
int Maxy=2001;
int Minx=2001;
int Miny=2001;
int dx[4]={0,0,-1,1};
int dy[4]={1,-1,0,0};
inline void DFS(int x,int y)
{
    map[x][y]=true;
    for(register int i=0;i<=3;i++)
    {
        int nx=x+dx[i];
        int ny=y+dy[i];
        if(nx>=Minx-2&&nx<=Maxx+2&&ny>=Miny-2&&ny<=Maxy+2&&map[nx][ny]==false)
        {
            DFS(nx,ny);
        }
    }
}
inline int solve()
{
    int sum=0;
    for(register int i=Minx-1;i<=Maxx+1;i++)
    {
        for(register int j=Miny-1;j<=Maxy+1;j++)
        {
            if(map[i][j]==false)
            {
                sum++;
                DFS(i,j);
            }
        }
    }
    return sum;
}
int main()
{
    map[x][y]=1;
    cin>>n;
    cin>>s;
    for(register int i=0;i<=n-1;i++)
    {
        if(s[i]=='N')
        {
            map[--x][y]=true;
            map[--x][y]=true;
            Minx=min(Minx,x);
        }
        if(s[i]=='E')
        {
            map[x][++y]=true;
            map[x][++y]=true;
            Maxy=max(Maxy,y);
        }
        if(s[i]=='S')
        {
            map[++x][y]=true;
            map[++x][y]=true;
            Maxx=max(Maxx,x);
        }
        if(s[i]=='W')
        {
            map[x][--y]=true;
            map[x][--y]=true;
            Miny=min(Miny,y);
        }
    }
    int ans=solve();
    if(ans==0)
    {
        cout<<0;
    }
    else
    {
        cout<<ans-1;
    }
    return 0;
}
```
    - **核心实现思想**：用二维数组模拟 FJ 修建围栏，把一步当两步走以识别小封闭区域。确定搜索边界并使用深搜统计封闭区域数量，最后减去外围的假封闭区域。

### 最优关键思路或技巧
- **坐标平移**：为避免出现负数坐标导致数组越界，将起点坐标设置为一个较大的中间值，如 (1000, 1000) 或 (2001, 2001)。
- **一步当两步走**：在标记围栏时，将一步移动转化为两步，可有效识别小封闭区域。
- **判断环的形成**：通过记录点的访问情况和路径信息，判断是否形成新的不包含其他环的环。

### 可拓展之处
同类型题可能涉及更复杂的图形结构或更多的方向移动，类似算法套路包括使用图的遍历算法（如 DFS、BFS）来统计联通块数量，以及通过判断点和边的重复情况来计算环的数量。

### 推荐题目
- P1141 01 迷宫：通过 DFS 或 BFS 统计联通块数量。
- P1451 求细胞数量：使用 DFS 或 BFS 统计细胞（联通块）的数量。
- P2002 消息扩散：利用图的遍历算法计算联通块数量。

### 个人心得摘录与总结
- **lxzy_**：考试时唯一 AC 的题，指出题目有很多注意点，如按正常走法无法识别小封闭区域，需把一步当两步走；搜索区域边界要与 FJ 走过的边界保持安全距离，避免出现假封闭区域；起点坐标不能设为 (0, 0)，否则可能出现数组越界问题。
- **wangzikang**：第一次写题解，提到代码实现中有多个“毒瘤处”，如正常存栅栏代码无法通过样例，需一步走两次；存在假封闭区域，要扩大 DFS 范围；第二个测试点有换行符，需特殊处理输入。

---
处理用时：43.14秒
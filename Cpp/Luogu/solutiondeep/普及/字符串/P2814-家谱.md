# 题目信息

# 家谱

## 题目背景

现代的人对于本家族血统越来越感兴趣。


## 题目描述

给出充足的父子关系，请你编写程序找到某个人的最早的祖先。


## 说明/提示

规定每个人的名字都有且只有 $6$ 个字符，而且首字母大写，且没有任意两个人的名字相同。最多可能有 $10^3$ 组父子关系，总人数最多可能达到 $5 \times 10^4$ 人，家谱中的记载不超过 $30$ 代。

## 样例 #1

### 输入

```
#George
+Rodney
#Arthur
+Gareth
+Walter
#Gareth
+Edward
?Edward
?Walter
?Rodney
?Arthur
$```

### 输出

```
Edward Arthur
Walter Arthur
Rodney George
Arthur Arthur```

# AI分析结果

### 综合分析与结论
这些题解均围绕家谱问题，通过并查集算法解决寻找某人最早祖先的问题。难点在于处理字符串形式的人名，不同题解采用了多种方法来解决这一问题，如使用`map`、哈希表、`Trie`树等。

### 高评分题解
- **作者：zhmshitiancai（5星）**
    - **关键亮点**：思路清晰，代码简洁，直接使用`map`将人名映射为其父节点，利用并查集路径压缩优化查找效率。
    - **核心代码**：
```cpp
#include<cstdio>
#include<iostream>
#include<map>
using namespace std;
map<string,string>p;
string find(string x)
{
    if(x!=p[x]) 
        p[x]=find(p[x]);
    return  p[x];
}
string s,s1;
int main()
{
    char ch;
    cin>>ch;
    while(ch!='$')
    {
        cin>>s;
        if(ch=='#')
        {
            s1=s;
            if(p[s]=="") p[s]=s;
        }
        else if(ch=='+')
            p[s]=s1;
        else 
            cout<<s<<' '<<find(s)<<endl;    
        cin>>ch;
    }
    return 0;
}
```
    - **核心思想**：使用`map<string, string> p`存储每个人的父节点，`find`函数实现路径压缩的并查集查找操作。根据输入的字符`#`、`+`、`?`分别处理父节点记录、子节点关联和查询操作。

- **作者：Station（4星）**
    - **关键亮点**：同样使用`map`解决人名映射问题，代码简洁，注释清晰，便于理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,string> fa;
string father,now,lst;
inline string getfa(string x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}
int main(){
    freopen("gen.in","r",stdin);
    freopen("gen.out","w",stdout);
    char ch=getchar();
    while (ch!='$'){
        cin>>now;getchar();
        if (ch=='#'){
            father=now;
            if (fa[father]=="") fa[father]=father;
        }else
        if (ch=='+') fa[now]=father;else cout<<now<<" "<<getfa(now)<<endl;
        ch=getchar();
    }
    return 0;
}
```
    - **核心思想**：定义`map<string, string> fa`存储父子关系，`getfa`函数实现路径压缩的并查集查找。根据输入字符处理父节点、子节点和查询操作。

- **作者：岸芷汀兰（4星）**
    - **关键亮点**：思路明确，详细说明了使用`map`进行字符串并查集的方法，代码结构清晰。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<map>
using namespace std;
const int maxn=50005;
string a[maxn];
int fa[maxn],n;
map<string,string>father;
string find(string x){
    if(x==father[x])return x;
    return father[x]=find(father[x]);
}
int main()
{
    string f1;
    while(1){
        char op=getchar();
        string str;
        if(op=='#'){
            cin>>f1;
            if(father[f1]=="")father[f1]=f1;
        }
        else if(op=='?'){
            cin>>str;
            cout<<str<<" "<<find(str)<<endl;
        }
        else if(op=='+'){
            cin>>str;
            father[str]=f1;
        }
        else if(op=='$')break;
    }
    return 0;
}
```
    - **核心思想**：使用`map<string, string> father`存储父子关系，`find`函数实现路径压缩的并查集查找。根据输入字符处理父节点、子节点和查询操作。

### 最优关键思路与技巧
- **使用`map`**：将字符串人名映射为其父节点或编号，方便进行并查集操作，避免了手动处理字符串比较和编号分配的复杂性。
- **路径压缩**：在并查集查找操作中使用路径压缩，将每个节点直接连接到根节点，减少后续查找的时间复杂度。

### 拓展思路
同类型题或类似算法套路：
- 处理字符串映射问题时，除了`map`，还可以使用哈希表、`Trie`树等数据结构。
- 对于并查集问题，可以考虑使用按秩合并等优化方法进一步提高效率。

### 洛谷推荐题目
- P3367 【模板】并查集
- P1551 亲戚
- P1892 [BOI2003]团伙

### 个人心得摘录与总结
- **arthurwalnut**：在处理字符串输入时，要注意换行符的问题，否则可能导致读入的名字包含换行符，影响程序正确性。
- **Kwork**：C++的字符串读入较慢，可以使用`getchar()`手动读入字符。同时，要注意一组关系可能有多行，需要进行相应的处理。
- **封禁用户**：在使用映射数组处理字符串时，要确保给名字的编号是它第一次出现的编号，避免后续编号覆盖导致错误。 

---
处理用时：36.29秒
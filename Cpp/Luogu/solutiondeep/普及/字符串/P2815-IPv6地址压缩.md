# 题目信息

# IPv6地址压缩

## 题目背景

（友情提示：IPv6 基础知识曾多次出现在 NOIP 初赛中）Internet Protocol，互联网协议，即为我们常说的 IP。我们目前常说的 IP 主要指它的第四版，即 IPv4，它由 IETF 于 1981 年发布。它的地址长度是 $32$ 个二进制位，因此也就有 $2^{32}$ 个 IP 地址可供使用，约为 $43$ 亿，在当时，谁也没有料想到 IPv4 如此庞大的地址长度会有用完的一天。

在 21 世纪的今天，互联网的蓬勃发展早就了我们如今便利的生活。当下，世界人口已超过 70 亿，计算机和各种联网设备已经走入千家万户，而不再仅是上个世纪 80 年代科学家们的工具。此时便出现了人们日益增长的联网设备需要同落后 IPv4 地址长度之间的矛盾。尽管可以通过网络地址翻译能技术来共享 IP 地址，临时解决枯竭的问题，但显然不是长久之计。

IETF 也有先见之明，早早地于 1998 年发布了 IPv6 协议，从微软 2006 年发布的 Windows Vista 开始成为默认安装的网络协议。作为 IPv4 的继任者，它的地址长度为 $128$ 个二进制位，也就是 $2^{128}$ 个IP地址可供使用。然而面对这冗长的地址，一位记忆力不好的网络工程师小明在配置路由表时遇到了许许多多多的困难，现在他找到了你，希望你帮忙编写一个程序来按照 IPv6 地址标准的格式压缩规则来压缩 IPv6 地址。

## 题目描述

**【IPv6 格式】**

IPv6 二进位制下为 $128$ 位长度，以 $16$ 位为一组，每组以冒号“`:`”隔开，可以分为 $8$ 组，每组以 $4$ 位十六进制方式表示。

比如 `2001:0db8:0000:0000:0123:4567:89ab:cdef` 是一个合法的 IPv6 地址。

同时 IPv6 地址在某些条件下可以压缩：

1. 每组数字代表的独立十六进制数可以省略前位的 `0`。

比如上面的 IPv6 地址可被压缩为 `2001:db8:0:0:123:4567:89ab:cdef`。

2. 可以用双冒号 `::` 表示一组 `0` 或多组连续的 `0`，但只能出现一次。

比如上面的 IPv6 地址可被压缩为 `2001:db8::123:4567:89ab:cdef`。

请你帮助记忆力不好的网络工程师小明解决他遇到的问题。

**【规则补充】**

1. 输入数据为完全展开的 IPv6 地址，确保输入的 IPv6 地址不含双冒号，每组地址省略的 `0` 都会被补充上去。

2. 双冒号只能使用一次，因此我们压缩最长的全 `0` 组。

比如 `2001:0db8:0000:0000:1:0000:0000:0000`，压缩为 `2001:db8:0:0:1::`，而非 `2001:db8::1:0:0:0`。

3. 双冒号只能使用一次，因此我们在我们遇到地址中多个连续全 `0` 组长度相同时，我们压缩最前面的一个。

比如 `2001:0db8:0000:0000:ffff:0000:0000:1`，压缩为 `2001:db8::ffff:0:0:1`，而非 `2001:db8:0:0:ffff::1`。

4. 输入的 IPv6 地址可能无法被压缩，此时请照原样输出。

提示：本题所示的压缩规则与 macOS (Darwin) 默认的 IPv6 地址显示方式相同，而 Windows 和 Linux 只遇到一组全 `0` 时不会使用 `::` 进行压缩。但用此方法压缩过的 IPv6 地址一样可以被 Windows 和 Linux 正确识别。

比如 `2001:0db8:ffff:0000:0123:4567:89ab:cdef`，Darwin 压缩为 `2001:db8:ffff::123:4567:89ab:cdef`，而 Linux 和 Windows 压缩为 `2001:db8:ffff:0:123:4567:89ab:cdef`。

## 样例 #1

### 输入

```
2406:0840:f990:0000:0000:0000:0000:0001```

### 输出

```
2406:840:f990::1```

## 样例 #2

### 输入

```
2a13:1801:018a:00cf:0100:0000:0000:0000```

### 输出

```
2a13:1801:18a:cf:100::```

## 样例 #3

### 输入

```
2001:4860:4860:0000:0000:0000:0000:8888```

### 输出

```
2001:4860:4860::8888```

## 样例 #4

### 输入

```
2001:0db8:0000:0000:0000:0000:0000:0001```

### 输出

```
2001:db8::1```

## 样例 #5

### 输入

```
0000:0000:0000:0000:0000:0000:0000:0000```

### 输出

```
::```

## 样例 #6

### 输入

```
0000:0000:0000:0000:0000:0000:0000:0001```

### 输出

```
::1```

## 样例 #7

### 输入

```
2001:0db8:ffff:0000:0123:4567:89ab:cdef```

### 输出

```
2001:db8:ffff::123:4567:89ab:cdef```

## 样例 #8

### 输入

```
1234:5678:9abc:def0:1234:5678:9abc:def0```

### 输出

```
1234:5678:9abc:def0:1234:5678:9abc:def0```

## 样例 #9

### 输入

```
0001:0000:0000:0000:0000:0000:0000:0001```

### 输出

```
1::1```

## 样例 #10

### 输入

```
0000:0000:0000:0000:0000:0000:0001:0002```

### 输出

```
::1:2```

# AI分析结果

### 综合分析与结论
这些题解大多采用模拟的方法解决 IPv6 地址压缩问题，核心步骤为去除前导零和找到最长连续零组并替换为双冒号。各题解在输入处理、查找最长连续零组以及输出结果的方式上存在差异。

### 所选题解
- **作者：_Ayanami_（5星）**
    - **关键亮点**：思路清晰，代码结构简洁，将处理过程分为去除前导零、查找最长连续零组和替换输出三个部分，易于理解和实现。
    - **个人心得**：“各种神奇的细节，我才不会告诉你我整整交了十遍才过”，说明该题存在较多细节需要注意。
```cpp
#include<cstring>
#include<iostream>
using namespace std;
int maxx=0,maxi;
string ss,s[8];
int main()
{
    cin>>ss;
    for(int i=0;i<8;i++)
    {
        int j=0;
        while(ss[i*5+j]=='0')
        {
            j++;
        }
        if(j==4)
        {
            s[i]="0";
        }
        else
        {
            for(j;j<4;j++)
            {
                s[i]+=ss[i*5+j];
            }
        }
    }
    for(int i=0;i<8;i++)
    {
        if(s[i]=="0")
        {
            int j=0;
            while(i+j<7&&s[i+j+1]=="0")
            {
                j++;
            }
            if(j>maxx)
            {
                maxx=j;
                maxi=i;
            }
            i+=j;
        }
    }
    for(int i=0;i<8;i++)
    {
        if(i==maxi&&maxx!=0)
        {
            cout<<"::";
            i+=maxx;
        }
        else
        {
            cout<<s[i];
            if(i!=7&&i!=maxi-1)
            {
                cout<<":";
            }
        }
    }
}
```
**核心实现思想**：先将输入的 IPv6 地址按组读入，去除每组的前导零；然后遍历存储每组地址的数组，找到最长连续零组的起始位置和长度；最后根据找到的最长连续零组进行替换输出。

- **作者：RocksonLee（4星）**
    - **关键亮点**：详细注释了代码，对寻找最长连续零组和处理前导零的过程进行了清晰的说明，便于理解。
    - **个人心得**：“这道题采用暴力通过，不过坑点有点多，处理时需要注意 windows 和 macos 规则不同，当全‘0’字段只有一个，用‘::’就没法 AC 了”，提醒了要注意不同系统规则的差异。
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[39];
int maxi=-1,maxn=1;
void find ()
{
    int i1,i2,t;
    bool ok;
    for (i1=0,t=0;i1<8;i1++)
    {
        ok=true;
        for (i2=0;i2<4;i2++)
        {
            if (a[i1*5+i2]!='0')
            {
                ok=false;
                break;
            }
        }
        if (ok)
        {
            t++;
            if (t>maxn)
            {
                maxn=t;
                maxi=i1;
            }
        }
        else t=0;
    }
    if (maxn==1) maxi=-1;
    maxi=maxi-maxn+1;
}
int main ()
{
    scanf("%s",a);
    find();
    int i1,i2;
    for (i1=0;i1<8;i1++)
    {
        if (maxi==i1)
        {
            cout<<":";
            if (i1==0) cout<<":";
            i1=i1+maxn;
            if (i1>7) break;
        }
        i2=0;
        while (a[i1*5+i2]=='0'&&i2<3) i2++;
        for (;i2<4;i2++)
        {
            cout<<a[i1*5+i2];
        }
        if (i2==4&&i1!=7) cout<<":";
    }
    return 0;
}
```
**核心实现思想**：定义 `find` 函数寻找最长连续零组的起始位置和长度，在 `main` 函数中根据找到的最长连续零组进行替换输出，同时处理每组的前导零。

### 最优关键思路或技巧
- **分组处理**：将 IPv6 地址按每组 16 位（4 位十六进制）进行分组处理，便于去除前导零和查找连续零组。
- **标记最长连续零组**：使用变量记录最长连续零组的起始位置和长度，方便后续替换为双冒号。

### 可拓展之处
同类型题如其他网络地址的格式化处理、字符串的压缩与解压缩等，可采用类似的模拟思路，先明确处理规则，再按步骤进行处理。

### 推荐题目
- P1200 [USACO1.1]你的飞碟在这儿 Your Ride Is Here
- P1055 [NOIP2008 普及组] ISBN 号码
- P1598 垂直柱状图

### 个人心得摘录与总结
- **_Ayanami_**：多次提交才通过，说明题目存在较多细节需要注意，调试时要仔细。
- **RocksonLee**：指出要注意不同系统规则的差异，避免因规则理解错误导致无法通过。
- **xujian**：交了 10 几遍才通过，强调了做这类题需要细心和耐心。
- **EarthGiao**：提醒在去除前导零时要注意最后一组数的特殊情况，容易忽略。
- **0AND1STORY**：代码需要打多个补丁才能完全正确，说明调试过程中要考虑各种边界情况。 

---
处理用时：36.45秒
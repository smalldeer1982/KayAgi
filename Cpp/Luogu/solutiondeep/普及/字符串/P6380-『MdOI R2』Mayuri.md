# 题目信息

# 『MdOI R2』Mayuri

## 题目背景

「万由里……怎么会？为什么你要……」

『我是灵力的结晶体，实施了封印，我当然会消失，不是吗？』

「封印？但是你和我……」

『第一次见面不能封印吗？笨蛋，我可是从大家的灵力里出生的，怎么可能讨厌你？从一出生，我就爱着你。』

「万由里……」

『虽然我竭力不让自己去想，但我一定是很羡慕大家……』

「等一下，万由里，不要消失……」

『但是我还是有一件能向大家炫耀的事，只有我和士道一样……』

「一样？」

『我已经不再是只为了消失而出生的生命。因为我遇见了你……已经足够了。』

「万由里……」

『谢谢你，士道。 』

![](https://cdn.luogu.com.cn/upload/image_hosting/9w6a0deg.png)

## 题目描述

在离开这个世界前，万由里想要寻找属于她的 Lucky Number。

万由里会给出一个数 $a$，以及一个长度为 $b$ 的 01 串 $S$。

简单的说，她的 Lucky Number 是满足以下条件的**正整数** $n$：

 - $n$ 的位数为 $b$ 且不含前导 $0$。

 - 若 $S$ 的第 $i$ 位为 $1$，则 $n$ 的前 $i$ 位组成的数是 $a$ 的倍数，否则 $n$ 的前 $i$ 位组成的数不是 $a$ 的倍数。

对于一个数，前 $i$ 位组成的数是指这个数前 $i$ 个数码依次拼接形成的数。例如 $312311$ 前 $3$ 位组成的数为 $312$，前 $5$ 位组成的数为 $31231$。


现在，请你帮助万由里计算一下，她的 Lucky Number 是多少。

由于满足条件的数可能会有多个，你需要输出**最小**的一个。若不存在，则请输出 `-1`。

## 说明/提示

【帮助与提示】

为方便选手测试代码，本题额外提供一组附加样例供选手使用。

[样例输入](https://www.luogu.com.cn/paste/5gnn8mg0) [样例输出](https://www.luogu.com.cn/paste/sgxjkbjd)

------
【样例解释】

对于样例一，$10$ 是 $2$ 位数，且 $10$ 的前 $1$ 位组成的数 $1$ 不是 $2$ 的倍数，而前 $2$ 位组成的数 $10$ 是 $2$ 的倍数。由于 $10$ 已经是最小的两位数，故不存在比 $10$ 更小的满足条件的数。

对于样例二，我们需要构造一个 $1$ 位数，满足这个 $1$ 位数整除 $10$。显然，这样的数不存在。

---

【数据范围】

**本题采用捆绑测试**


| 子任务编号 | $a \leq$ | $b\le$  | 分值   |
| ---------- | -------- | :------ | ------ |
| Subtask 1  | $10$     | $ 1$    | $20$   |
| Subtask 2  | $10 $    | $2$     | $20$  |
| Subtask 3  | $10 $    | $ 6$    | $20$  |
| Subtask 4  | $ 2$     | $ 18$   | $20$ |
| Subtask 5  | $ 10$    | $ 10^5$ | $20$ |


对于全部数据，保证 $2\le a\le 10$，$1\le b\le 10^5$，$S$ 中只包含 `0` 和 `1`。

## 样例 #1

### 输入

```
2 2
01```

### 输出

```
10```

## 样例 #2

### 输入

```
10 1 
1```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 6
110100```

### 输出

```
601210```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找满足特定条件的最小正整数 $n$ 展开，整体思路可分为暴力枚举和贪心构造两类。暴力枚举适用于数据规模较小的情况，通过枚举所有可能的 $b$ 位数并逐一判断是否满足条件来求解；贪心构造则从高位到低位逐位确定数字，保证每一步都选择最小的满足条件的数字，以达到最终结果最小的目的。

### 所选题解
- **作者：BFqwq（5星）**
    - **关键亮点**：思路清晰，先证明了除 $a = 10$ 且 $S$ 的第一个字符为 `1` 外的情况都有解，然后针对不同子任务详细给出了解决方法，代码简洁易懂。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
char c[100005],n[100005];
int a,b;
int now;
int main(){
    cin>>a>>b>>c;
    if(c[0]=='0')n[0]='1',now=1;
    else{
        if(a==10){
            puts("-1");
            return 0;
        }
        else n[0]=a+'0';
    };
    for(int i=1;i<b;i++){
        now*=10;
        for(int j=0;j<=9;j++)
            if((now+j)%a==0&&c[i]=='1'||(now+j)%a!=0&&c[i]=='0'){
                now+=j;
                now%=a;
                n[i]=j+'0';
                break;
            }
    }
    cout<<n;
    return 0;
} 
```
    - **核心实现思想**：首先处理无解情况，然后根据第一位的条件确定首位数字。接着从第二位开始，通过枚举 $0$ 到 $9$ 的数字，找到满足当前位条件的最小数字，并更新当前数对 $a$ 的余数，最后输出结果。

- **作者：grass8cow（4星）**
    - **关键亮点**：贪心思路明确，通过定义 $now_i$ 表示答案的前 $i$ 位除以 $a$ 的余数，$ans_i$ 表示第 $i$ 位数字，直接计算每一位的最优解，代码简洁，未使用数组。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,i,now;
char c;
int main()
{
    cin>>a>>b>>c;
    if(a==10&&c=='1'){cout<<-1;return 0;}//特判无解 
    if(c=='1')cout<<a;
    else cout<<1,now=1;//特判首位 
    for(i=1;i<b;i++)
    {
        cin>>c; 
        now=now*10%a;
        if(c=='0'){if(now)cout<<0;else cout<<1,now=1;}
        else cout<<(a-now)%a,now=0;//如上文所述
    }
    return 0;
}
```
    - **核心实现思想**：先特判无解情况，然后根据首位条件输出首位数字并初始化余数。接着从第二位开始，根据当前位的条件和余数计算并输出当前位的数字，同时更新余数。

- **作者：__frj（4星）**
    - **关键亮点**：对不同子任务分别给出解法，先通过暴力模拟解决前四个子任务，再针对第五个子任务利用取模优化，避免爆精度问题，思路清晰，代码注释详细。
    - **个人心得**：意识到暴力模拟在 Subtask 5 会因爆精度出错，从而采用计算 $n\%a$ 的值来优化。
    - **核心代码（Subtask 5）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[100007];
long long n=0;
int main(){
    int a,b,mod=0;
    cin>>a>>b;
    scanf("%s",s);
    if(a>=10&&s[0]=='1'){
        cout<<-1;
        return 0;
    }
    for(int i=0;i<b;i++){
        if(i==0){
            if(s[i]=='1'){
                printf("%d",a);
                mod=0;
            }
            if(s[i]=='0'){
                printf("1");
                mod=1;
            }
        }
        else{
            mod=mod*10%a;
            if(s[i]=='1'){
                if(mod==0){
                    printf("0");
                }
                else{
                    printf("%d",a-mod);
                }
                mod=0;
            }
            if(s[i]=='0'){
                if(mod!=0){
                    printf("0");
                }
                if(mod==0){
                    printf("1");
                    mod=1;
                }
            }
        }
    }
}
```
    - **核心实现思想**：先特判无解情况，然后处理首位数字并初始化余数。从第二位开始，根据当前位条件和余数计算并输出当前位数字，同时更新余数，避免直接计算 $n$ 导致爆精度。

### 最优关键思路或技巧
- **贪心构造**：从高位到低位逐位确定数字，保证每一步都选择最小的满足条件的数字，从而得到最小的满足条件的数。
- **取模优化**：由于 $n$ 可能很大，直接计算 $n$ 会导致爆精度，因此通过计算 $n$ 对 $a$ 的余数来进行判断和更新，避免了高精度计算。

### 可拓展之处
同类型题可能会改变条件，如改变整除条件、增加其他限制等，但核心思路仍然是贪心构造和取模优化。类似算法套路可应用于其他需要逐位构造数字的题目，通过贪心策略和取模运算来简化计算。

### 推荐题目
- [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：涉及动态规划和路径规划，需要逐格确定状态，与本题逐位确定数字的思路有一定相似性。
- [P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：动态规划经典题，从顶部到底部逐行确定最大路径和，与本题逐位确定最优解的思想类似。
- [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)：完全背包问题，需要在不同物品和容量限制下选择最优方案，与本题在不同条件下选择最优数字的思路有相通之处。

### 个人心得摘录与总结
- **作者：幻之陨梦**：使用 `getchar` 读入导致 WA，提醒在输入处理时要注意方法的选择。
- **作者：Gokix**：比赛时以为 Substack5 需要写高精，赛后经提醒才发现可以通过边跑边 $\mod a$ 优化，说明在解题时要灵活思考，尝试不同的优化方法。
- **作者：BreakPlus**：爆搜只能得 80 分，写高精度超时，最后通过结合数组存答案和长整型存答案 $\bmod \ a$ 解决问题，强调做题时要灵活运用不同方法，结合各自的优点。

---
处理用时：46.86秒
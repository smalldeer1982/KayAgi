# 题目信息

# 「小窝 R3」心の記憶

## 题目背景

> 淡い夕暮れ飲み込まれて  
「君」の消えかけて姿を  
忘れさせるように走ってた   
新しい平和の世界に  
——[《心の記憶》](https://music.163.com/song?id=1847928316)

## 题目描述

- 本题中「**子串**」的定义如下：

字符串 $S$ 的子串是 $S$ 中**连续**的任意个字符组成的字符串。$S$ 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S(l,r)$（$1 \leq l \leq r \leq |S |,|S|$ 表示 $S$ 的长度）。

- 本题中「**子序列**」的定义如下：

对于字符串 $S$ 和一个长度为 $n$ 的严格单调递增数列 $k_1,k_2,\cdots,k_n(\forall 1\le i\le n,1\le k_i\le |S|)$，$S_{k_1},S_{k_2},\cdots,S_{k_n}$ 所组成的字符串即为 $S$ 的子序列。

---------------

现有 $T$ 次询问。
每次询问给定一个长度为 $n$ 的 01 串，记为 $A$。回答应是一个字符串 $B$，满足：

- $B$ 是长度为 $m$ 的 01 串。
- $B$ 中不存在任意一个**子串**与 $A$ 相同。
- $B$ 中存在**至少**一个**子序列**与 $A$ 相同。

输出任意一个满足要求的字符串 $B$ 即可。

## 说明/提示

### 样例解释

在第二次询问中，`01101` 和 `10110` 是另外合法的方案。

### 数据范围

| Subtask | 分值 | $\sum m\le$ | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$  | $10$ | $2\times10^6$ | $A$ 只由 `0` 组成 |
| $2$ | $10$ | $15$ | 无 |
| $3$ | $20$ | $2000$ | 无 |
| $4$  | $30$ | $10^6$ | $A$ 随机生成 |
| $5$ | $30$ | $2\times 10^6$ | 无 |

对于 $100\%$ 的数据，$1\le n\le m$，$1\le \sum m\le 2\times 10^6$。保证 $A$ 只由 `0` 和 `1` 组成。

## 样例 #1

### 输入

```
4
1 1
1
3 5
010
4 8
1101
5 6
11111```

### 输出

```
-1
01110
10100101
111101```

# AI分析结果

### 综合分析与结论
各题解思路核心均围绕先判断无解情况，再通过在原串 $A$ 基础上插入字符构造满足条件的串 $B$。对于无解判断，均认为 $n = 1$、$n = m$、$A$ 为 `01` 或 `10` 时无解。构造方法多样，部分题解按串 $A$ 的特征分类讨论，如存在相邻相同字符和不存在相邻相同字符的情况；部分题解按字符数量多少、串的特殊形式等分类。

### 所选题解
- **作者：Hexarhy（5星）**
    - **关键亮点**：思路清晰，对不同子任务给出详细解法并证明正确性，代码简洁。
    - **核心代码**：
```cpp
int main()
{
    int T;scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&n,&m);
        vector<bool> a(m+10);
        for(int i=1;i<=n;i++)
        {
        	int x;scanf("%1d",&x);
        	a[i]=x;
		}
        if(n==m || n==1 || (n==2 && (a[1]^a[2])))
        {
            puts("-1");
            continue;
        }
        int cnt0=0,cnt1=0;
        for(int i=1;i<=n;i++)   a[i]?cnt1++:cnt0++;
        bool f=false;
        for(int i=1;i<=n;i++)
        {
            printf("%d",int(a[i]));
            if(!f && (cnt1<cnt0?!a[i]:a[i]))
            {
                for(int j=1;j<=m-n;j++)
                	printf("%d",int(cnt1<cnt0));
                f=true;
            }
        }
        putchar('\n');
    }
    return 0;
}
```
    - **核心思想**：先特判无解情况，然后统计 `0` 和 `1` 的数量，插入数量少的字符到另一个字符首次出现的位置后。

- **作者：Eason_AC（4星）**
    - **关键亮点**：直接给出正解，构造方案清晰，代码简洁。
    - **核心代码**：
```cpp
namespace Solution {
	iv Main() {
		MT {
			int n, m;
			read(n, m);
			string s; cin >> s;
			if(n == 1 || n == m) puts("-1");
			else {
				string ans = s.substr(0, n - 1);
				int fl0 = 1, fl1 = 1;
				F(int, i, 0, (int)ans.size() - 1) if(ans[i]!= '0') fl0 = 0; else if(ans[i]!= '1') fl1 = 0;
				if((fl0 && s[n - 1] == '1') || (fl1 && s[n - 1] == '0')) {
					if(n == 2) puts("-1");
					else {
						string ans2 = ""; ans2 += ans[0];
						if(ans[0] == '0') ans2 += "1";
						else ans2 += "0";
						ans2 += s.substr(1, n - 1);
						F(int, i, n + 1, m - 1) ans2 += s[n - 1];
						cout << ans2 << endl;
					}
					continue;
				}
				if(s[n - 1] == '0') {
					F(int, i, n, m - 1) ans += "1";
					ans += s.substr(n - 1, 1);
				} else {
					F(int, i, n, m - 1) ans += "0";
					ans += s.substr(n - 1, 1);
				}
				cout << ans << endl;
			}
		}
		return;
	}
}
```
    - **核心思想**：先判断无解情况，再根据串 $A$ 是否为 `000...1` 或 `111...0` 形式分类构造。

### 最优关键思路或技巧
- 先判断无解情况，避免无效构造。
- 对串 $A$ 进行特征分析，如是否存在相邻相同字符、字符数量多少等，再分类构造。

### 可拓展之处
同类型题可能会改变字符集、增加更多限制条件等。类似算法套路可用于解决字符串构造、子串子序列相关问题，关键在于分析原串特征，通过插入、替换等操作破坏原串连续性，同时保证满足特定条件。

### 推荐题目
- P1003 [铺地毯](https://www.luogu.com.cn/problem/P1003)：涉及二维平面的覆盖构造问题。
- P1012 [拼数](https://www.luogu.com.cn/problem/P1012)：字符串拼接构造最大数问题。
- P1217 [回文质数](https://www.luogu.com.cn/problem/P1217)：质数和回文数的构造问题。

### 个人心得摘录与总结
- **作者：EnofTaiPeople**：最初构造方法在 $A$ 串第 $2$~$n - 1$ 个字符全部相同时有问题，通过特判解决。总结为构造算法需考虑特殊情况，多测试样例以发现问题。 

---
处理用时：32.82秒
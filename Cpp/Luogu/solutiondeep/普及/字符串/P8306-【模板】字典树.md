# 题目信息

# 【模板】字典树

## 题目描述

给定 $n$ 个模式串 $s_1, s_2, \dots, s_n$ 和 $q$ 次询问，每次询问给定一个文本串 $t_i$，请回答 $s_1 \sim s_n$ 中有多少个字符串 $s_j$ 满足 $t_i$ 是 $s_j$ 的**前缀**。

一个字符串 $t$ 是 $s$ 的前缀当且仅当从 $s$ 的末尾删去若干个（可以为 0 个）连续的字符后与 $t$ 相同。

输入的字符串大小敏感。例如，字符串 `Fusu` 和字符串 `fusu` 不同。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq T, n, q\leq 10^5$，且输入字符串的总长度不超过 $3 \times 10^6$。输入的字符串只含大小写字母和数字，且不含空串。

### 说明
std 的 IO 使用的是关闭同步后的 cin/cout，本题不卡常。

## 样例 #1

### 输入

```
3
3 3
fusufusu
fusu
anguei
fusu
anguei
kkksc
5 2
fusu
Fusu
AFakeFusu
afakefusu
fusuisnotfake
Fusu
fusu
1 1
998244353
9```

### 输出

```
2
1
0
1
2
1```

# AI分析结果

### 综合分析与结论
这三道题解均围绕字典树解决字符串前缀匹配问题。思路上，都利用字典树存储模式串，通过查询文本串在字典树中的匹配情况得出结果。算法要点包括字符映射、插入字符串和查询操作。解决的难点主要是字符集不连续的处理和前缀匹配计数。

### 所选题解
- **作者：qip101（5星）**
    - **关键亮点**：思路清晰，详细介绍了字典树的概念、性质和操作，代码可读性高，注释丰富。
    - **核心实现思想**：通过`getnum`函数将字符映射为数字，`insert`函数插入字符串并更新路径上节点的计数，`find`函数查询文本串在字典树中的匹配情况。
    - **核心代码片段**：
```cpp
int getnum(char x){
    if(x>='A'&&x<='Z')
        return x-'A';
    else if(x>='a'&&x<='z')
        return x-'a'+26;
    else
        return x-'0'+52;
} 
void insert(char str[]){
    int p=0,len=strlen(str);
    for(int i=0;i<len;i++){
        int c=getnum(str[i]);
        if(!t[p][c])
            t[p][c]=++idx;
        p=t[p][c];
        cnt[p]++;
    }
}
int find(char str[]){
    int p=0,len=strlen(str);
    for(int i=0;i<len;i++){
        int c=getnum(str[i]);
        if(!t[p][c])
            return 0;
        p=t[p][c];
    }
    return cnt[p];
}
```
- **作者：一扶苏一（4星）**
    - **关键亮点**：使用`unordered_map`存储子节点，节省空间，通过`dfs`预处理子树计数，查询复杂度为$O(1)$。
    - **核心实现思想**：构建字典树时，在模式串结束节点的`cnt`加一，通过`dfs`遍历字典树，累加子节点的`cnt`，查询时直接返回匹配节点的`cnt`。
    - **核心代码片段**：
```cpp
struct Node {
  int cnt;
  std::unordered_map<char, Node*> ch;
  Node() : cnt(0) {};
  void dfs() {
    for (auto [x, y] : ch) {
      y->dfs();
      cnt += y->cnt;
    }
  }
};
```
- **作者：npqenqpve（4星）**
    - **关键亮点**：使用`map`进行字符映射，代码简洁明了，思路清晰。
    - **核心实现思想**：通过`insert`函数插入字符串并更新路径上节点的计数，`query`函数查询文本串在字典树中的匹配情况。
    - **核心代码片段**：
```cpp
map<char,int>mp;
void insert(char *s)
{
    int len=strlen(s+1),p=0;
    for(int i=1;i<=len;i++)
    {
        if(!trie[p][mp[s[i]]]) trie[p][mp[s[i]]]=++tot;
        p=trie[p][mp[s[i]]]; 
        tag[p]++;
    }
}
int query(char *s)
{
    int len=strlen(s+1),p=0;
    for(int i=1;i<=len;i++)
    {
        if(!trie[p][mp[s[i]]]) return 0;
        p=trie[p][mp[s[i]]]; 
    }
    return tag[p];
}
```

### 最优关键思路或技巧
- 使用字典树存储字符串，利用字符串的公共前缀减少查询时间。
- 对字符集不连续的情况，通过映射函数将字符转换为连续的数字。
- 在插入字符串时，更新路径上节点的计数，方便查询前缀匹配的数量。

### 可拓展之处
同类型题或类似算法套路包括：
- 字典树的变形，如压缩字典树、后缀字典树等。
- 结合其他数据结构，如AC自动机，解决多模式串匹配问题。
- 处理字符串的其他问题，如最长公共前缀、最短唯一前缀等。

### 推荐题目
- [P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)
- [P8306 【模板】字典树](https://www.luogu.com.cn/problem/P8306)
- [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)

### 个人心得
题解中未包含个人心得。

---
处理用时：30.91秒
# 题目信息

# [NOIP 2004 提高组] 合并果子

## 题目描述

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $=3+12=15$ 。可以证明 $15$ 为最小的体力耗费值。

## 说明/提示

对于 $30\%$ 的数据，保证有 $n \le 1000$：

对于 $50\%$ 的数据，保证有 $n \le 5000$；

对于全部的数据，保证有 $n \le 10000$。


## 样例 #1

### 输入

```
3 
1 2 9 
```

### 输出

```
15
```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何通过合并果子的堆来最小化体力消耗。所有题解都基于贪心算法，每次合并最小的两堆果子，以确保每次合并的体力消耗最小。这种策略与哈夫曼树的构建过程一致，因此大多数题解都采用了优先队列（小根堆）来实现这一策略。

### 所选高星题解

#### 1. 作者：微雨燕双飞 (5星)
**关键亮点**：
- 完全手写小根堆，展示了堆的基本操作（插入、删除、调整等），代码清晰且易于理解。
- 通过手写堆，避免了STL库的开销，提升了代码效率。
- 代码结构清晰，注释详细，适合初学者学习堆的实现。

**核心代码**：
```cpp
void up(int p) {
    while(p>1) {
        if(heap[p]<heap[p/2]) {
            swap(heap[p],heap[p/2]);
            p/=2;
        }
        else break;
    }
}
void insert(int val) {
    heap[++size]=val;
    up(size);
}
void down(int p) {
    int s=p*2;
    while(s<=size) {
        if(s<size&&heap[s+1]<heap[s]) s++;
        if(heap[s]<heap[p]) {
            swap(heap[s],heap[p]);
            p=s; s=p*2;
        }
        else break;
    }
}
void extract() {
    heap[1]=heap[size--];
    down(1);
}
```

#### 2. 作者：sbh2012 (4星)
**关键亮点**：
- 使用STL的优先队列，代码简洁且易于实现。
- 通过贪心策略的直观证明，帮助理解为什么每次合并最小的两堆是最优的。
- 代码结构清晰，适合快速实现。

**核心代码**：
```cpp
priority_queue<int,vector<int>,greater<int> > a;
int main(){
    int n,x,k,j,s=0;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&x);
        a.push(x);
    }
    for(int i=0;i<n-1;i++){
        k=a.top();
        a.pop();
        j=a.top();
        a.pop();
        s+=k+j;
        a.push(k+j);
    }
    printf("%d\n",s);
    return 0;
}
```

#### 3. 作者：sigland (4星)
**关键亮点**：
- 手写优先队列，封装在结构体中，代码复用性高。
- 通过手写堆，优化了STL库的性能问题，代码效率较高。
- 代码结构清晰，适合进阶学习。

**核心代码**：
```cpp
struct my_priority {
    vector<int>heap;
    void init() {
        heap.push_back(-1e9);
    }
    void gao(int pos) {
        int flag;
        if(pos*2>heap.size()-1)return;
        else if(pos*2==heap.size()-1)flag=0;
        else flag=heap[pos*2]>heap[pos*2+1];
        if(heap[pos]>heap[pos*2+flag]) {
            swap(heap[pos],heap[pos*2+flag]);
            gao(pos*2+flag);
        }
        return;
    }
    void doit(int i) {
        while(heap[i]<heap[i/2]) {
            swap(heap[i],heap[i/2]);
            i>>=1;
        }
        return;
    }
    void push(int w) {
        heap.push_back(w);
        doit(heap.size()-1);
    }
    int top() {
        return heap[1];
    }
    void pop() {
        heap[1]=heap[heap.size()-1];
        heap.pop_back();
        gao(1);
    }
    int size() {
        return heap.size()-1;
    }
} q;
```

### 最优关键思路与技巧

1. **贪心策略**：每次合并最小的两堆果子，确保每次合并的体力消耗最小。
2. **优先队列（小根堆）**：通过优先队列快速获取最小元素，实现贪心策略。
3. **手写堆优化**：手写堆可以避免STL库的开销，提升代码效率，适合对性能要求较高的场景。

### 可拓展之处

- **哈夫曼树**：本题的贪心策略与哈夫曼树的构建过程一致，可以进一步学习哈夫曼树的相关知识。
- **其他贪心问题**：类似的问题如任务调度、最小生成树等，都可以通过贪心策略解决。

### 推荐题目

1. [P1091 合并果子（加强版）](https://www.luogu.com.cn/problem/P1091)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378)

### 个人心得总结

- **调试经历**：手写堆时，调整堆的操作容易出错，需要仔细检查父子节点的关系。
- **踩坑教训**：使用STL的优先队列时，注意堆的大小和元素的插入顺序，避免不必要的性能损失。
- **顿悟感想**：贪心策略的直观性和高效性在解决类似问题时非常有用，理解其背后的数学原理是关键。

---
处理用时：37.06秒
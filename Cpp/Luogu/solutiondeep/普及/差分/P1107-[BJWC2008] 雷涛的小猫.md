# 题目信息

# [BJWC2008] 雷涛的小猫

## 题目背景

原最大整数参见 P1012

## 题目描述

雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫（当然，这样的行为是违反学生宿舍管理条例的）。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。

可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆…

在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有 $N$ 棵。并且这 $N$ 棵柿子树每棵的高度都是 $H$。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。

小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳 $1$ 单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降 `Delta` 单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。

雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。

图为 $N=3, H=10, Delta=2$ 的一个例子。小猫按照图示路线进行跳跃，可以吃到最多的 $8$ 个柿子。

![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \leq N, H ≤ 2000$，$0 \leq N_i ≤ 5000$，$1 ≤ Delta ≤ N,1 ≤ T_{i,j} ≤ H$。

输入文件大小不大于 40MB。注意输入输出效率。

来源 Excalibur, 2008。

## 样例 #1

### 输入

```
3 10 2
3 1 4 10
6 3 5 9 7 8 9
5 4 5 3 6 9```

### 输出

```
8```

# AI分析结果

### 综合分析与结论

本题的核心是动态规划（DP），关键在于如何优化状态转移，避免高时间复杂度。大多数题解都采用了类似的DP思路，但优化方式各有不同。主要的优化点在于如何减少第三重循环（枚举从哪棵树转移）的时间复杂度，通常通过预处理或维护一个最大值数组来实现。

### 所选高星题解

#### 1. 作者：issue_is_fw (5星)
**关键亮点**：
- 提供了从O(n^3)到O(n^2)的优化思路，清晰易懂。
- 通过引入`pre`数组，避免了第三重循环，显著降低了时间复杂度。
- 代码简洁，注释详细，易于理解。

**核心代码**：
```cpp
int maxn = 0;
for (int j = h; j >= 0; j--) {
    for (int i = 1; i <= n; i++) {
        dp[i][j] = a[i][j] + dp[i][j + 1]; // 继承上一次
        dp[i][j] = max(dp[i][j], pre[j + de] + a[i][j]); // 转移
        pre[j] = max(pre[j], dp[i][j]); // 更新当前pre
        maxn = max(maxn, dp[i][j]);
    }
}
```

#### 2. 作者：良辰何需美景 (4.5星)
**关键亮点**：
- 通过维护`ret`数组，优化了状态转移，避免了重复计算。
- 详细解释了优化思路，代码实现清晰。
- 提供了完整的代码示例，便于理解。

**核心代码**：
```cpp
for (int j = 1; j <= h; j++) {
    for (int i = 1; i <= n; i++) {
        if (j > d) f[i][j] = max(f[i][j - 1], ret[j - d]) + a[i][j];
        else f[i][j] = f[i][j - 1] + a[i][j];
        ret[j] = max(ret[j], f[i][j]);
    }
}
```

#### 3. 作者：刘曜曜 (4星)
**关键亮点**：
- 通过引入`maxn`数组，优化了状态转移，避免了第三重循环。
- 代码简洁，注释清晰，易于理解。
- 提供了完整的代码示例，便于理解。

**核心代码**：
```cpp
for (int i = 1; i <= H; i++) {
    for (int j = 1; j <= N; j++) {
        dp[i][j] = max(dp[i][j], dp[i - 1][j]);
        if (i > D) dp[i][j] = max(dp[i][j], maxx[i - D]);
        dp[i][j] += maap[i][j];
        maxx[i] = max(maxx[i], dp[i][j]);
    }
}
```

### 最优关键思路与技巧

1. **状态转移优化**：通过维护一个最大值数组（如`pre`、`ret`、`maxx`），避免了第三重循环，将时间复杂度从O(n^3)降低到O(n^2)。
2. **倒序枚举高度**：从高到低枚举高度，确保在计算当前状态时，所需的前置状态已经计算完成。
3. **贪心思想**：在状态转移时，总是选择能够带来最大收益的转移路径，减少了不必要的计算。

### 可拓展之处

- **类似题目**：可以扩展到其他需要状态转移优化的DP问题，如背包问题、最长公共子序列等。
- **优化技巧**：在其他需要枚举多个状态的DP问题中，可以通过类似的方式减少时间复杂度。

### 推荐题目

1. **P1048 采药**：经典的背包问题，考察状态转移和优化。
2. **P1057 传球游戏**：动态规划问题，考察状态转移和优化。
3. **P1060 开心的金明**：背包问题，考察状态转移和优化。

### 个人心得摘录

- **issue_is_fw**：第一次写题解被退回来了，原因是排版不整齐。没有备份，希望这次能过。
- **良辰何需美景**：主要原因是在T掉一个点之后觉得题解里大佬的讲解过于简单（可能是因为我太弱了看不懂）于是利用NB的画图软件自己暴力模拟了一下dp的过程。
- **刘曜曜**：有错误请在评论区指出orzorz。

这些心得反映了作者在解题过程中遇到的困难和如何通过实践解决问题，值得借鉴。

---
处理用时：30.59秒
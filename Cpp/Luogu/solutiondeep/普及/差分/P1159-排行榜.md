# 题目信息

# 排行榜

## 题目描述

小迈克尔住在一个小镇上，他喜欢看每周日下午发布的音乐电视评比。它每周都根据选票介绍相同的歌曲，列出这些歌曲的流行排行榜。

有一个星期日迈克尔和他的朋友在一起玩得太久了以致于未能看到新的流行榜。他非常失望，但是不久他就发现下周至少可以部分地建立出流行榜。除了每首歌曲的位置，排行榜还根据这些歌曲上周的排行列出了它们排行变动的信息，更精确地说，从这周起，不管那首歌是继续排在原位，还是排名上升或排名下降，都会给出一点说明。

编写程序，根据给定的流行榜帮助迈克尔推断出上周可能的排行榜。


## 样例 #1

### 输入

```
5
HIGHHOPES
UP
LOWFEELINGS
UP
UPANDDOWN
DOWN
IAMSTILLSTANDING
DOWN
FOOLINGAROUND
DOWN
```

### 输出

```
UPANDDOWN
IAMSTILLSTANDING
FOOLINGAROUND
HIGHHOPES
LOWFEELINGS
```

# AI分析结果

### 综合分析与结论

本题的核心任务是根据当前排行榜和每首歌曲的排名变化（UP、DOWN、SAME），推断出上周可能的排行榜。题解主要集中在模拟和贪心算法的应用上，大多数题解通过分别处理SAME、DOWN和UP的歌曲，最终输出一个合理的上周排行榜。

#### 关键思路与技巧：
1. **分类处理**：将歌曲分为SAME、DOWN和UP三类，分别处理。SAME的歌曲直接保留在原位，DOWN的歌曲尽量放在前面，UP的歌曲尽量放在后面。
2. **贪心策略**：通过贪心算法，优先处理DOWN的歌曲，确保它们在上周的排名尽可能靠前，然后再处理UP的歌曲，确保它们在上周的排名尽可能靠后。
3. **数据结构**：使用数组、队列或结构体来存储和排序歌曲，确保处理顺序和输出顺序的正确性。

#### 通用建议与扩展思路：
- **优化**：可以通过双指针或标记数组来优化处理顺序，减少不必要的遍历。
- **拓展**：类似的问题可以扩展到其他排名系统，如体育比赛、学术排名等，核心思路依然是分类处理和贪心策略。

### 所选高星题解

#### 题解1：作者：OnlyU (★★★★☆)
**关键亮点**：
- 思路清晰，代码简洁，直接通过数组模拟处理SAME、DOWN和UP的歌曲。
- 使用三个数组分别存储不同类型的歌曲，最后按顺序输出。

**核心代码**：
```cpp
for(int i=1; i<=n; i++) {
    if(ans[i]!="")continue;
    else {
        if(now1<down) {
            now1++;
            ans[i]=Sdown[now1];
        } else {
            now2++;
            ans[i]=Sup[now2];
        }
    }
}
```
**实现思想**：先处理DOWN的歌曲，再处理UP的歌曲，确保DOWN的歌曲在上周的排名尽可能靠前。

#### 题解2：作者：SofanHe (★★★★☆)
**关键亮点**：
- 使用STL中的queue来存储DOWN和UP的歌曲，确保处理顺序的正确性。
- 通过bool数组标记SAME的歌曲，避免重复处理。

**核心代码**：
```cpp
for(int i=1; i<=n; i++) {
    if(sa[i]==1)cout<<name[i]<<endl;
    else {
        if(!fr.empty()){cout<<name[fr.front()]<<endl;fr.pop();}
        else if(!en.empty()){cout<<name[en.front()]<<endl;en.pop();}
    }
}
```
**实现思想**：使用队列存储DOWN和UP的歌曲，按顺序输出，确保DOWN的歌曲优先处理。

#### 题解3：作者：dingcx (★★★★☆)
**关键亮点**：
- 使用双指针分别处理DOWN和UP的歌曲，确保DOWN的歌曲在前，UP的歌曲在后。
- 通过while循环跳过已经被SAME占用的位置，确保处理顺序的正确性。

**核心代码**：
```cpp
for(int i=1; i<=n; i++) {
    if(st[i][0]=='D') {
        while(ans[front]) front++;
        ans[front]=i;
    }
}
for(int i=n; i>0; i--) {
    if(st[i][0]=='U') {
        while(ans[rear]) rear--;
        ans[rear]=i;
    }
}
```
**实现思想**：使用双指针分别处理DOWN和UP的歌曲，确保DOWN的歌曲在前，UP的歌曲在后。

### 推荐相似题目
1. **P1160 队列安排** - 考察队列的基本操作和顺序处理。
2. **P1177 快速排序** - 考察排序算法的应用，尤其是贪心策略。
3. **P1181 数列分段** - 考察分类处理和贪心算法的应用。

### 个人心得摘录
- **OnlyU**：第一次写题解，希望能过。通过分类处理，直接模拟即可。
- **SofanHe**：STL的queue很好用，可以确保处理顺序的正确性。
- **dingcx**：期中考试结束了，趁着这个愉悦的日子，发一篇题解。通过双指针处理DOWN和UP的歌曲，确保顺序正确。

这些心得反映了作者在解题过程中的思考和调试经历，帮助读者更好地理解题解的实现过程。

---
处理用时：27.63秒
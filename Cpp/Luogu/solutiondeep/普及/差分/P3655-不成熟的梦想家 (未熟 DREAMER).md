# 题目信息

# 不成熟的梦想家 (未熟 DREAMER)

## 题目背景

**どんな未来かは 誰もまだ知らない**

**那是个任谁也不会知晓的未来**

**でも楽しくなるはずだよ**

**但应该会充满乐趣吧**

**みんなとなら乗りこえられる**

**只要大伙儿同在 就能跨越难关**

**これからなんだねお互いがんばろうよ**

**现在才正要开始 彼此互相加油吧**

**どんな未来かは 誰もまだ知らない**

**那是个任谁也不会知晓的未来**

**でも楽しくしたホントに**

**不过真心期望能够充满着乐趣**

**みんなとなら無理したくなる**

**只要大伙儿同在 就会想将顾虑抛诸脑后**

**成長したいなまだまだ未熟DREAMER**

**愿能有所成长 如今还只是尚未成熟的梦想家**

 ![](https://cdn.luogu.com.cn/upload/pic/4493.png) 

Aqours的成员终于到齐了。


今天，是我们全员在一起的第一场演唱会。


大家都好好练习过了，相信一定会表现得很出色的。


不过，每个人的唱功也要尽量地接近才可以呢，如果太突出或者太落后，也是会影响表现的样子。


所以我们从隔壁的学园都市借来了一个发明，可以改变我们成员的唱功呢。


## 题目描述

我们Aqours的成员共有N+1人，他们会列成一队。

他们的唱功以A[0]到A[N]表示，A[i]$(0\le i \le N)$均给出。

学园都市的机器可以改变队列中连续多个成员的唱功值，并将其加上一个数Z，当然当Z是负数的时候就变成减去了。

我打算一共使用这个机器Q次，每次把第X到第Y号（$1\le X,Y\le10^6$）的成员都加上Z点唱功值。

而我们队伍的魅力值B，是这么算的：

一开始B=0，然后从第1号到第N号成员，

- 当$A_{i-1}<A_i$：$B = B-S\cdot|A_{i-1} - A_i|$
- 当$A_{i-1}>A_i$：$B = B+T\cdot|A_{i-1} - A_i|$
其中S和T是LoveLive组委会给我们的常数。

果然，我是バカチカ（笨蛋千歌）呢，所以作为领导我永远排在队伍的开头，唱功永远是0，机器也不会改到我头上呢。

你能帮我们算算，我**每次**使用完这个机器之后，成员的魅力B是多少吗？


## 说明/提示

30% 的数据 $N,Q\le 2000$,

另外20% 的数据 $S=T$

100%的数据 $N,Q\le 200000$；$1\le S,T,A_i\le10^6$；$|Z|\le 10^6$
请注意可能需要使用int64，cin/cout可能超时。

样例解释：

第一次变化后，

A 0 6 3 4 6

B -12 -3 -5 -9


#### 以下是彩蛋

没有。

哪来的那么多彩蛋？


## 样例 #1

### 输入

```
4 3 2 3
0
5
2
4
6
1 2 1
3 4 -3
1 4 2
```

### 输出

```
-9
-1
-5
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效处理区间修改并快速计算魅力值的变化。大多数题解都采用了差分的思想，通过维护差分数组来优化区间修改和查询操作。差分的关键在于每次区间修改只需要更新区间的两个端点，从而将时间复杂度从O(Q*N)降低到O(Q)。此外，部分题解还提到了树状数组的应用，虽然也能解决问题，但相比差分方法略显复杂。

### 所选高分题解

#### 1. 作者：顾z (赞：18)  
**星级：4.5**  
**关键亮点：**  
- 清晰解释了差分的思想，并通过JOI 2017焚风现象类比，帮助理解。
- 代码简洁，逻辑清晰，特别是对边界条件的处理（如y==n时的特判）。
- 强调了开long long的重要性，避免了常见的溢出问题。

**核心代码：**
```cpp
for(R int i=1,x,y,z;i<=Q;i++) {
    in(x),in(y),in(z);
    ans-=calc(A[x]);A[x]+=z;ans+=calc(A[x]);
    if(y!=N)ans-=calc(A[y+1]),A[y+1]-=z,ans+=calc(A[y+1]);
    printf("%lld\n",ans);
}
```
**实现思想：** 每次修改时，先撤销原差分值对ans的影响，更新差分值后再重新计算其对ans的贡献。

#### 2. 作者：ILLENIUM_DOOR (赞：14)  
**星级：4.0**  
**关键亮点：**  
- 详细解释了差分数组的定义和应用，特别是如何通过差分数组快速更新魅力值。
- 强调了时间复杂度为O(n)的优势，适合大规模数据处理。
- 代码结构清晰，注释详细，便于理解。

**核心代码：**
```cpp
while(q--){
    long long x,y,z;
    cin>>x>>y>>z;
    ans-=js(d[x]);d[x]+=z;ans+=js(d[x]);
    if(y!=n) ans-=js(d[y+1]),d[y+1]-=z,ans+=js(d[y+1]);
    cout<<ans<<endl;
}
```
**实现思想：** 通过差分数组d[i] = A[i] - A[i-1]，每次修改只需更新d[x]和d[y+1]，从而快速计算魅力值的变化。

#### 3. 作者：RedreamMer (赞：3)  
**星级：4.0**  
**关键亮点：**  
- 通过公式变形简化了魅力值的计算，思路清晰。
- 强调了区间修改时只有X_l和X_r+1的值会改变，优化了计算过程。
- 代码简洁，逻辑清晰，适合初学者理解。

**核心代码：**
```cpp
for(int i=1;i<=b;i++) {
    scanf("%lld%lld%lld",&x,&y,&z);
    sum-=f(s[x]); s[x]+=z; sum+=f(s[x]);
    if(y!=a) { sum-=f(s[y+1]); s[y+1]-=z; sum+=f(s[y+1]); }
    printf("%lld\n",sum);
}
```
**实现思想：** 通过差分数组s[i] = A[i] - A[i-1]，每次修改只需更新s[x]和s[y+1]，从而快速计算魅力值的变化。

### 最优关键思路与技巧

1. **差分数组的应用：** 通过维护差分数组，将区间修改操作转化为单点修改，极大降低了时间复杂度。
2. **边界条件处理：** 在修改区间时，特别注意y==n的情况，避免越界和无效操作。
3. **公式变形简化计算：** 通过公式变形，将魅力值的计算简化为差分值的函数，进一步优化了计算过程。

### 可拓展之处

- **类似算法套路：** 差分数组不仅适用于区间修改问题，还可以用于区间查询、前缀和计算等场景。
- **同类型题目：** 可以尝试解决其他涉及区间修改和查询的问题，如区间最大值、区间和等。

### 推荐题目

1. **P3368 【模板】树状数组 1**  
   考察树状数组的基本操作，适合巩固差分思想。
2. **P3372 【模板】线段树 1**  
   考察线段树的区间修改与查询，适合进一步学习区间操作。
3. **P3374 【模板】树状数组 2**  
   考察树状数组的区间修改与单点查询，适合深入理解差分数组的应用。

### 个人心得摘录

- **顾z：** "开long long见祖宗"，强调了数据范围的重要性，避免因溢出导致的错误。
- **ILLENIUM_DOOR：** "我不会告诉你我对树状数组一窍不通才用的差分"，幽默地表达了对差分方法的偏爱。
- **RedreamMer：** "思路理清楚就很好做了，~~不需要树状数组吧~~"，强调了清晰思路的重要性，适合初学者理解。

---
处理用时：32.57秒
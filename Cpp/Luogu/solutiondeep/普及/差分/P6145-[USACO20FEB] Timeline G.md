# 题目信息

# [USACO20FEB] Timeline G

## 题目描述

Bessie 在过去的 $M$ 天内参加了 $N$ 次挤奶。但她已经忘了她每次挤奶是在哪个时候了。

对于第 $i$ 次挤奶，Bessie 记得它不早于第 $S_i$ 天进行。另外，她还有 $C$ 条记忆，每条记忆形如一个三元组 $(a,b,x)$，含义是第 $b$ 次挤奶在第 $a$ 次挤奶结束至少 $x$ 天后进行。

现在请你帮 Bessie 算出在满足所有条件的前提下，每次挤奶的最早日期。

保证 Bessie 的记忆没有错误，这意味着一定存在一种合法的方案，使得：

- 第 $i$ 次挤奶不早于第 $S_i$ 天进行，且不晚于第 $M$ 天进行；
- 所有的记忆都得到满足；

## 说明/提示

- 测试点 $2 \sim 4$ 满足 $N,C \leq 10^3$。
- 测试点 $5 \sim 10$ 没有特殊限制。

## 样例 #1

### 输入

```
4 10 3
1 2 3 4
1 2 5
2 4 2
3 4 4```

### 输出

```
1
6
3
8```

# AI分析结果

### 综合分析与结论

本题的核心在于如何根据给定的约束条件，求解每次挤奶的最早日期。题解主要分为两类：**拓扑排序**和**差分约束**。拓扑排序的思路是将每次挤奶看作图中的节点，约束条件作为边，通过拓扑排序递推求解每个节点的最早日期。差分约束的思路则是将约束条件转化为不等式，通过最长路算法（如SPFA）求解。

拓扑排序的优点是时间复杂度较低，适合DAG（有向无环图），且代码实现较为简洁。差分约束的思路更为通用，适合处理更复杂的约束条件，但SPFA的时间复杂度较高，可能存在性能问题。

### 所选高质量题解

#### 1. 作者：StudyingFather (赞：36)
- **星级**：5星
- **关键亮点**：思路清晰，代码简洁，使用拓扑排序直接求解，时间复杂度较低。
- **核心代码**：
  ```cpp
  void addedge(int u,int v,int w) {
      e[++cnt].v=v;
      e[cnt].w=w;
      e[cnt].next=head[u];
      head[u]=cnt;
  }
  void topo_sort() {
      queue<int> q;
      for(int i=1;i<=n;i++)
          if(!t[i]) q.push(i);
      while(!q.empty()) {
          int u=q.front();
          q.pop();
          for(int i=head[u];i;i=e[i].next) {
              int v=e[i].v, w=e[i].w;
              s[v]=max(s[v],s[u]+w);
              t[v]--;
              if(!t[v]) q.push(v);
          }
      }
  }
  ```
- **实现思想**：通过拓扑排序递推求解每个节点的最早日期，确保所有约束条件得到满足。

#### 2. 作者：Hexarhy (赞：8)
- **星级**：4星
- **关键亮点**：详细解释了拓扑排序的思路，代码结构清晰，适合初学者理解。
- **核心代码**：
  ```cpp
  void topo_sort() {
      queue<int> q;
      for(int i=1;i<=n;i++)
          if(!indeg[i]) q.push(i);
      while(!q.empty()) {
          int u=q.front();
          q.pop();
          for(auto it:edge[u]) {
              s[it.to]=max(s[it.to],s[u]+it.v);
              indeg[it.to]--;
              if(!indeg[it.to]) q.push(it.to);
          }
      }
  }
  ```
- **实现思想**：通过拓扑排序递推求解，确保每个节点的最早日期满足所有约束条件。

#### 3. 作者：UltiMadow (赞：6)
- **星级**：4星
- **关键亮点**：使用SPFA求解最长路，思路清晰，适合处理更复杂的约束条件。
- **核心代码**：
  ```cpp
  void SPFA(int st) {
      queue<int> Q;
      memset(dis,-0x3f,sizeof(dis));
      Q.push(st); dis[st]=0;
      while(!Q.empty()) {
          int u=Q.front(); Q.pop();
          for(int i=Head[u];i;i=Edge[i].next) {
              int v=Edge[i].to, w=Edge[i].val;
              if(dis[v]<dis[u]+w) {
                  dis[v]=dis[u]+w;
                  Q.push(v);
              }
          }
      }
  }
  ```
- **实现思想**：通过SPFA求解最长路，确保所有约束条件得到满足。

### 最优关键思路与技巧

1. **拓扑排序**：适合处理DAG，时间复杂度较低，代码实现简洁。
2. **差分约束**：适合处理更复杂的约束条件，通过最长路算法求解。
3. **超级源点**：通过引入超级源点，简化约束条件的处理，适合处理多个起点的场景。

### 可拓展之处

- **同类型题**：类似题目可以考察更复杂的约束条件，如带权约束、多起点等。
- **算法套路**：拓扑排序和差分约束是处理约束条件的经典算法，可以推广到其他图论问题中。

### 推荐题目

1. [P1113 杂务](https://www.luogu.com.cn/problem/P1113)
2. [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)
3. [P5960 【模板】差分约束](https://www.luogu.com.cn/problem/P5960)

### 个人心得总结

- **调试经历**：在处理约束条件时，确保所有条件都被正确转化为图的边，避免遗漏。
- **踩坑教训**：SPFA的时间复杂度较高，在大数据量时可能存在性能问题，需谨慎使用。
- **顿悟感想**：拓扑排序和差分约束是处理约束条件的强大工具，理解其核心思想后，可以灵活应用于多种场景。

---
处理用时：36.40秒
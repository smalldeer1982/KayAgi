# 题目信息

# [JOI 2021 Final] とてもたのしい家庭菜園 4 (Growing Vegetables is Fun 4)

## 题目描述

给定一个长为 $N$ 的序列 $A_i$，你可以进行若干次操作：

- 选定一个区间 $[L,R]$，让这个区间里的数加 $1$。

设经过这若干次操作后的序列为 $B_i$，那么你需要让 $B_i$ 满足下面这个要求：

- 存在一个整数 $k \in [1,N]$，满足对于子序列 $A_1=\{B_1,B_2,\cdots,B_k\}$ 为严格递增序列，对于子序列 $A_2=\{B_k,B_{k+1},\cdots,B_N\}$ 为严格递减序列。

你想知道最少需要多少次操作才能满足上面这个要求。

## 说明/提示

#### 样例 1 解释

- 对 $[2,5]$ 进行操作，序列变为 $\{3,3,3,4,2\}$。
- 对 $[2,3]$ 进行操作，序列变为 $\{3,4,4,4,2\}$。
- 对 $[3,3]$ 进行操作，序列变为 $\{3,4,5,4,2\}$。

#### 样例 2 解释

序列已经满足要求，不需要操作。

#### 样例 3 解释

对区间 $[1,1]$ 或 $[2,2]$ 进行操作都可。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（40 pts）：$N \le 2000$。
- Subtask 2（60 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le N \le 2 \times 10^5$，$1 \le A_i \le 10^9$。

#### 说明

翻译自 [The 20th Japanese Olympiad in Informatics Final Round A とてもたのしい家庭菜園 4 的英文翻译 Growing Vegetables is Fun 4](https://www.ioi-jp.org/joi/2020/2021-ho/2021-ho-t1-en.pdf)。

## 样例 #1

### 输入

```
5
3 2 2 3 1```

### 输出

```
3```

## 样例 #2

### 输入

```
5
9 7 5 3 1```

### 输出

```
0```

## 样例 #3

### 输入

```
2
2021 2021```

### 输出

```
1```

## 样例 #4

### 输入

```
8
12 2 34 85 4 91 29 85```

### 输出

```
93```

# AI分析结果

### 综合分析与结论

本题的核心是通过区间加操作，使得序列的前半段严格递增，后半段严格递减。大多数题解都采用了差分的思想，通过计算差分数组来简化问题。差分数组的性质使得区间加操作可以转化为对差分数组的两个端点的修改，从而降低了时间复杂度。

### 所选高分题解

#### 1. 作者：LZH_LOVE_ZRG (5星)
- **关键亮点**：思路清晰，代码简洁，通过差分数组和前缀/后缀数组的预处理，高效地计算了每个分割点的操作次数。
- **个人心得**：作者强调了差分数组在处理区间加操作时的优势，并通过前缀和后缀数组的预处理，简化了问题的复杂度。
- **核心代码**：
```cpp
for(int i=2,j=n;i<=n;i++,j--){
    x[i]=(b[i]<=0?x[i-1]-(b[i]-1):x[i-1]);
    y[j]=(b[j]>=0?y[j+1]+(b[j]+1):y[j+1]);
}
long long ans=LONG_LONG_MAX;
for(int i=1;i<=n;i++)
    ans=min(ans,max(x[i],y[i+1]));
```

#### 2. 作者：iMya_nlgau (4星)
- **关键亮点**：通过定义两个数组分别表示前半段和后半段的操作次数，最终通过枚举分割点来求解最小值。
- **个人心得**：作者强调了严格递增和递减的条件，并通过差分数组的性质简化了问题的求解。
- **核心代码**：
```cpp
for(int i=2;i<=n;i++) f[i]=b[i]<=0?f[i-1]-b[i]+1:f[i-1];
for(int i=n;i>=2;i--) g[i]=b[i]>=0?g[i+1]+b[i]+1:g[i+1];
ll ans=0x3f3f3f3f3f3f3f3f;
for(int k=1;k<=n;k++) ans=min(ans,max(f[k],g[k+1]));
```

#### 3. 作者：STL_qwq (4星)
- **关键亮点**：通过DP思想，分别计算每个元素作为分割点时的操作次数，最终通过枚举分割点来求解最小值。
- **个人心得**：作者通过DP的思想，将问题转化为前缀和后缀的操作次数计算，简化了问题的复杂度。
- **核心代码**：
```cpp
for(int i=2;i<=n;i++){
    sx[i]=sx[i-1];
    if(a[i-1]>=a[i]) sx[i]+=a[i-1]-a[i]+1;
}
for(int i=n-1;i>=0;i--){
    jx[i]=jx[i+1];
    if(a[i+1]>=a[i]) jx[i]+=a[i+1]-a[i]+1;
}
int ans=0x3f3f3f3f3f3f3f3f;
for(int i=1;i<=n;i++) ans=min(ans,max(sx[i],jx[i]));
```

### 最优关键思路与技巧

1. **差分数组**：通过差分数组将区间加操作转化为对差分数组的两个端点的修改，从而简化了问题的复杂度。
2. **前缀/后缀数组**：通过预处理前缀和后缀数组，快速计算每个分割点的操作次数。
3. **枚举分割点**：通过枚举分割点，结合前缀和后缀数组，求解最小操作次数。

### 可拓展之处

- **同类型题**：类似的问题可以通过差分数组和前缀/后缀数组的预处理来解决，如区间加、区间减等操作。
- **类似算法套路**：差分数组在处理区间修改问题时非常有效，可以结合前缀和、后缀和等技巧来优化问题的求解。

### 推荐题目

1. [P2367 语文成绩](https://www.luogu.com.cn/problem/P2367)
2. [P4552 [POI2007]ZAP-Queries](https://www.luogu.com.cn/problem/P4552)
3. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

### 个人心得总结

- **调试经历**：在处理差分数组时，需要注意边界条件的处理，避免数组越界。
- **踩坑教训**：在计算前缀和后缀数组时，需要确保初始值的正确性，避免计算错误。
- **顿悟感想**：差分数组在处理区间修改问题时非常高效，通过预处理可以大大简化问题的复杂度。

---
处理用时：30.93秒
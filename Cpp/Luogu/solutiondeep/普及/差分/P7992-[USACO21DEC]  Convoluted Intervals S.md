# 题目信息

# [USACO21DEC]  Convoluted Intervals S

## 题目描述

奶牛们正在努力尝试发明有趣的新游戏来玩。他们目前的工作之一与一组 $N$ 个区间（$1\le N\le 2\cdot 10^5$）有关，其中第 $i$ 个区间从数轴上的 $a_i$ 位置开始，并在位置 $b_i \geq a_i$ 结束。$a_i$ 和 $b_i$ 均为 $0 \ldots M$ 范围内的整数，其中 $1 \leq M \leq 5000$。

这个游戏的玩法是，Bessie 选择某个区间（假设是第 $i$ 个区间），而她的表妹 Elsie 选择某个区间（假设是第 $j$ 个区间，可能与 Bessie 所选的的区间相同）。给定某个值 $k$，如果 $a_i + a_j \leq k \leq b_i + b_j$，则她们获胜。

对范围 $0 \ldots 2M$ 内的每个值 $k$，请计算使得 Bessie 和 Elsie 可以赢得游戏的有序对 $(i,j)$ 的数量。

## 说明/提示

【样例解释】

在这个例子中，对于 $k=3$，有三个有序对可以使得 Bessie 和 Elsie 获胜：$(1, 1)$，$(1, 2)$，和 $(2, 1)$。

【数据范围】

- 测试点 1-2 满足 $N\le 100, M\le 100$。
- 测试点 3-5 满足 $N\le 5000$。
- 测试点 6-20 没有额外限制。

## 样例 #1

### 输入

```
2 5
1 3
2 5```

### 输出

```
0
0
1
3
4
4
4
3
3
1
1
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地计算满足条件的有序对 $(i,j)$ 的数量。由于 $N$ 可以达到 $2 \times 10^5$，直接暴力枚举 $i$ 和 $j$ 会导致 $O(N^2)$ 的复杂度，无法通过。因此，题解普遍采用了基于桶和差分数组的优化策略，将复杂度降低到 $O(M^2)$，其中 $M$ 是值域范围（$M \leq 5000$）。

**关键思路与技巧：**
1. **桶计数**：通过桶（数组）记录每个 $a_i$ 和 $b_i$ 的出现次数，避免了直接枚举 $i$ 和 $j$。
2. **差分数组**：利用差分数组来高效地处理区间加操作，最终通过前缀和得到每个 $k$ 的答案。
3. **乘法原理**：通过乘法原理计算 $a_i + a_j$ 和 $b_i + b_j$ 的组合数，进一步优化了计算过程。

**通用建议与扩展思路：**
- 当问题涉及大量区间操作时，差分数组是一个非常有用的工具，能够将区间加操作优化到 $O(1)$。
- 对于值域较小的问题，桶计数是一种常见的优化手段，能够将复杂度从 $O(N)$ 降低到 $O(M)$。

### 所选高星题解

#### 1. 作者：xkcdjerry (5星)
**关键亮点：**
- 思路清晰，详细解释了如何通过桶计数和差分数组来优化问题。
- 代码简洁且高效，使用了 `long long` 避免了溢出问题。
- 提供了调试建议，提醒读者注意数据类型的转换。

**核心代码：**
```cpp
for(int i=0;i<=m;i++)
    for(int j=0;j<=m;j++)
    {
        f[i+j]+=fa[i]*fa[j];
        f[i+j+1]-=fb[i]*fb[j];
    }
```
**实现思想：**
通过双重循环枚举 $a_i$ 和 $a_j$ 的组合，利用差分数组记录每个 $k$ 的贡献。

#### 2. 作者：shiranui (4星)
**关键亮点：**
- 详细解释了差分数组的使用方法，并通过样例进行了直观的说明。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
for(int i=0;i<=m;i++)
    for(int j=0;j<=m;j++)
    {
        if(ha[i]!=0&&ha[j]!=0)f[i+j]+=ha[i]*ha[j];
        if(hb[i]!=0&&hb[j]!=0)f[i+j+1]-=hb[i]*hb[j];
    }
```
**实现思想：**
通过枚举 $a_i$ 和 $a_j$ 的组合，利用差分数组记录每个 $k$ 的贡献。

#### 3. 作者：Ginger_he (4星)
**关键亮点：**
- 简洁明了地解释了如何通过桶计数和差分数组来优化问题。
- 代码简洁且高效，使用了 `long long` 避免了溢出问题。

**核心代码：**
```cpp
for(int i=0;i<=m;i++)
    for(int j=0;j<=m;j++)
    {
        p[i+j]+=a[i]*a[j];
        p[i+j+1]-=b[i]*b[j];
    }
```
**实现思想：**
通过双重循环枚举 $a_i$ 和 $a_j$ 的组合，利用差分数组记录每个 $k$ 的贡献。

### 推荐题目
1. **P3372 【模板】线段树 1**（考察区间加操作与差分数组）
2. **P1908 逆序对**（考察桶计数与分治思想）
3. **P1047 校门外的树**（考察区间操作与差分数组）

### 个人心得摘录
- **xkcdjerry**：提醒读者注意数据类型的转换，避免因溢出导致的错误。
- **shiranui**：通过样例详细解释了差分数组的使用方法，帮助读者更好地理解算法。
- **Ginger_he**：简洁明了地解释了如何通过桶计数和差分数组来优化问题，代码简洁且高效。

---
处理用时：28.91秒
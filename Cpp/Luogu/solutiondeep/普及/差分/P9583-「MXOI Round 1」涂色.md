# 题目信息

# 「MXOI Round 1」涂色

## 题目描述

小 C 正在用彩铅给一张 $n$ 行 $m$ 列的方格纸涂色。初始时，所有方格都是空白的。

他一共要进行 $q$ 次涂色，每次涂色会选取一行或一列，给这一行或这一列的所有方格都添加 $1$ 层颜色。

小 C 喜欢浅色，所以他会在每次涂色结束后，把所有被涂上 $k$ 层颜色的方格的颜色都擦掉，让这些方格都变成空白的。

小 C 想知道，在最终共有多少方格被涂上了颜色。

## 说明/提示

#### 【样例解释 #1】

第 $1$ 行第 $1$ 列的方格没有被涂上颜色，第 $1$ 行第 $2$ 列的方格被涂上了 $1$ 层颜色，第 $1$ 行第 $3$ 列的方格没有被涂上颜色，第 $1$ 行第 $4$ 列的方格被涂上了 $1$ 层颜色；

第 $2$ 行第 $1$ 列的方格被涂上了 $1$ 层颜色，第 $2$ 行第 $2$ 列的方格被涂上了 $2$ 层颜色，第 $2$ 行第 $3$ 列的方格被涂上了 $1$ 层颜色，第 $2$ 行第 $4$ 列的方格被涂上了 $2$ 层颜色；

第 $3$ 行第 $1$ 列的方格被涂上了 $2$ 层颜色，第 $3$ 行第 $2$ 列的方格的颜色被擦掉了，第 $3$ 行第 $3$ 列的方格被涂上了 $2$ 层颜色，第 $3$ 行第 $4$ 列的方格的颜色也被擦掉了；

最终，共有 $8$ 个方格被涂上了颜色。

#### 【样例 #2】

见附加文件中的 `paint/paint2.in` 与 `paint/paint2.ans`。

该样例满足测试点 $1$ 的限制。

#### 【样例 #3】

见附加文件中的 `paint/paint3.in` 与 `paint/paint3.ans`。

该样例满足测试点 $5$ 的限制。

#### 【样例 #4】

见附加文件中的 `paint/paint4.in` 与 `paint/paint4.ans`。

该样例满足测试点 $20$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le n,m \le 2\times 10^5$，$1 \le k \le q \le 5 \times 10^5$，$op \in \{1,2\}$，保证当 $op=1$ 时 $1 \le x \le n$，当 $op=2$ 时 $1 \le x \le m$。

|测试点编号|$n,m \le$|$q \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim4$|$3000$|$3000$|无|
|$5\sim9$|$3000$|$5\times10^5$|无|
|$10\sim12$|$2\times10^5$|$5\times10^5$|A|
|$13\sim16$|$2\times10^5$|$5\times10^5$|B|
|$17\sim20$|$2\times10^5$|$5\times10^5$|无|

特殊性质 A：保证 $op=1$。

特殊性质 B：保证 $k=2$。

## 样例 #1

### 输入

```
3 4 5 3
1 3
2 4
1 2
1 3
2 2```

### 输出

```
8```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效处理大规模的行列操作，并快速计算最终被涂色的方格数量。直接模拟或暴力枚举行、列的操作会导致时间复杂度过高，无法通过测试。因此，大多数题解都采用了以下优化思路：

1. **行列分离统计**：通过分别记录每行和每列的涂色次数，避免了对每个方格进行单独操作。
2. **模运算优化**：利用模运算的性质，减少不必要的计算，尤其是当涂色次数达到 $k$ 的倍数时，直接归零。
3. **桶计数**：通过桶（数组）统计每行和每列涂色次数的模 $k$ 值，快速计算满足条件的方格数量。
4. **正难则反**：通过计算未涂色的方格数量，再用总数减去未涂色的方格数量，得到最终结果。

这些优化思路使得算法的时间复杂度从 $O(nm)$ 降低到 $O(n + m + q)$，能够高效处理大规模数据。

### 所选高星题解

#### 1. **作者：BL_zhanggezi (5星)**
- **关键亮点**：
  - 使用两个一维数组分别记录行和列的涂色次数，避免了二维数组的空间浪费。
  - 通过模运算和桶计数优化了二分查找，进一步提高了效率。
  - 代码清晰，逻辑严谨，优化思路明确。
- **个人心得**：
  - 通过优化二分查找，减少了时间复杂度，解决了超时问题。
- **核心代码**：
  ```cpp
  for(int i=1;i<=m;i++) {
      c=s[i]%k;
      for(int j=(k-c)%k;j<=h[n];j+=k) {
          ans=ans-ss[j]; // ss[j]是符合要求的数量
      }
  }
  ```

#### 2. **作者：wpy233 (4.5星)**
- **关键亮点**：
  - 通过引理证明了涂色顺序不影响最终结果，简化了问题。
  - 使用桶计数快速计算满足条件的方格数量，代码简洁高效。
  - 强调了开 `long long` 的重要性，避免了数据溢出。
- **核心代码**：
  ```cpp
  for(int i=1,j=k-1;i<=k-1,j>=1;i++,j--)
      ans-=c[i]*d[j]; // 去除涂色次数加和为k的交叉格
  ```

#### 3. **作者：Coffee_zzz (4星)**
- **关键亮点**：
  - 针对不同测试点的数据范围，提供了分段优化的思路。
  - 通过模运算和桶计数，高效计算最终结果。
  - 代码结构清晰，优化思路明确。
- **核心代码**：
  ```cpp
  for(int i=1;i<=m;i++) {
      c[j]%=k;
      if(c[j]==0) cnt=cnt+n-w[0];
      else cnt=cnt+n-w[k-c[j]];
  }
  ```

### 最优关键思路与技巧

1. **行列分离统计**：通过分别记录每行和每列的涂色次数，避免了对每个方格进行单独操作，大大减少了时间复杂度。
2. **模运算优化**：利用模运算的性质，减少不必要的计算，尤其是当涂色次数达到 $k$ 的倍数时，直接归零。
3. **桶计数**：通过桶（数组）统计每行和每列涂色次数的模 $k$ 值，快速计算满足条件的方格数量。
4. **正难则反**：通过计算未涂色的方格数量，再用总数减去未涂色的方格数量，得到最终结果。

### 可拓展之处

1. **类似问题**：这种行列分离统计和模运算优化的思路可以应用于其他涉及大规模行列操作的问题，如矩阵乘法、行列求和等。
2. **桶计数的应用**：桶计数不仅适用于本题，还可以用于其他需要快速统计满足某些条件的元素数量的问题，如统计数组中满足某种条件的元素数量。

### 推荐题目

1. **P1908 逆序对**：考察桶计数和分治思想，与本题的桶计数优化思路类似。
2. **P3374 【模板】树状数组 1**：考察树状数组的应用，与本题的行列分离统计思路有相似之处。
3. **P3383 【模板】线性筛素数**：考察模运算和筛法，与本题的模运算优化思路相关。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中发现超时问题，通过优化二分查找或桶计数解决了这一问题。
- **踩坑教训**：多位作者强调了开 `long long` 的重要性，避免了数据溢出。
- **顿悟感想**：通过正难则反的思路，将问题转化为计算未涂色的方格数量，大大简化了问题的复杂度。

---
处理用时：33.74秒
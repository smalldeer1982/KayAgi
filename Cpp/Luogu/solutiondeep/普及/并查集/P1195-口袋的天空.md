# 题目信息

# 口袋的天空

## 题目背景

小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。

有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。


## 题目描述

给你云朵的个数 $N$，再给你 $M$ 个关系，表示哪些云朵可以连在一起。

现在小杉要把所有云朵连成 $K$ 个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。


## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 100$，$1\le M \le 10^3$；

对于 $100\%$ 的数据，$1 \le N \le 10^3$，$1 \le M \le 10^4$，$1 \le K \le 10$，$1 \le X,Y \le N$，$0 \le L<10^4$。


## 样例 #1

### 输入

```
3 1 2
1 2 1
```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

该题目要求将云朵连接成K个棉花糖，且代价最小。本质上是一个**最小生成森林**问题，即通过选择边将图分成K个连通块，且总代价最小。大部分题解都采用了**Kruskal算法**，结合**并查集**来判断是否形成回路，并通过贪心策略选择最小代价的边。部分题解还提到了**Prim算法**，但由于数据规模较大，Kruskal算法更为适用。

### 题解评分与亮点

#### 1. 题解作者：yangrunze (赞：279)  
**星级：5星**  
**关键亮点：**  
- 详细解释了Kruskal算法的原理，并结合并查集实现。
- 通过排序边权，贪心地选择最小代价的边，确保生成森林的代价最小。
- 代码结构清晰，注释详细，易于理解。

**核心代码：**
```cpp
int find(int a) {
    if(f[a]==a) return a;
    else return f[a]=find(f[a]);
}

int main() {
    // 初始化并查集
    for(int i=1;i<=n;i++) f[i]=i;
    // 排序边
    sort(a+1,a+1+m,cmp);
    // Kruskal算法
    for(int i=1;i<=m;i++) {
        if(find(a[i].s)!=find(a[i].e)) {
            f[find(a[i].s)]=find(a[i].e);
            sum+=a[i].w;
            cnt++;
        }
        if(cnt>=n-k) break;
    }
    // 输出结果
    if(cnt>=n-k) cout<<sum;
    else cout<<"No Answer";
}
```

#### 2. 题解作者：Drifterming (赞：121)  
**星级：4星**  
**关键亮点：**  
- 简洁明了地解释了Kruskal算法的应用，特别是如何通过选择边来减少连通块的数量。
- 代码实现简洁，使用了结构体排序和并查集，逻辑清晰。

**核心代码：**
```cpp
int find(int x) {
    return fa[x]==x?fa[x]:fa[x]=find(fa[x]);
}

int main() {
    // 初始化并查集
    for(int i=1;i<=n;i++) fa[i]=i;
    // 排序边
    sort(edge+1,edge+m+1);
    // Kruskal算法
    for(int i=1;i<=m;i++) {
        int fx=find(edge[i].u),fy=find(edge[i].v);
        if(fx!=fy) {
            fa[fx]=fy;
            sum++;
            ans+=edge[i].w;
        }
        if(sum==n-k) break;
    }
    // 输出结果
    if(sum==n-k) printf("%d",ans);
    else puts("No Answer");
}
```

#### 3. 题解作者：Floating__Dream (赞：31)  
**星级：4星**  
**关键亮点：**  
- 强调了Kruskal算法的贪心思想，并通过并查集维护连通性。
- 代码简洁，使用了结构体排序和并查集，逻辑清晰。

**核心代码：**
```cpp
int find(int x) {
    if(x!=fa[x]) fa[x]=find(fa[x]);
    return fa[x];
}

void work(int x,int y) {
    x=find(x);
    y=find(y);
    if(x==y) return;
    fa[x]=y;
}

int main() {
    // 初始化并查集
    for(int i=1;i<=n;i++) fa[i]=i;
    // 排序边
    qsort(a,m,sizeof(a[0]),cmp);
    // Kruskal算法
    for(int i=0;i<m;i++) {
        if(num==0) break;
        int aaa=find(a[i].x),wzx=find(a[i].y);
        if(aaa!=wzx) {
            work(a[i].x,a[i].y);
            ans+=a[i].l;
            num--;
        }
    }
    // 输出结果
    if(num) cout<<"No Answer"<<endl;
    else cout<<ans<<endl;
}
```

### 最优关键思路与技巧

1. **Kruskal算法**：通过贪心策略选择最小代价的边，确保生成森林的代价最小。
2. **并查集**：用于判断是否形成回路，确保选择的边不会导致连通块数量减少。
3. **排序边权**：通过排序边权，确保每次选择的边都是当前最小代价的边。

### 可拓展之处

- **Prim算法**：虽然在该题中Kruskal更为适用，但在某些特定场景下，Prim算法可能更高效。
- **动态维护最小生成树**：在某些动态图中，可以通过维护最小生成树来应对边的增删。

### 推荐题目

1. **P3367 【模板】并查集**：练习并查集的基本操作。
2. **P3366 【模板】最小生成树**：练习Kruskal和Prim算法的实现。
3. **P1194 买礼物**：类似的最小生成树问题，考察贪心策略。

### 个人心得总结

- **调试经历**：部分题解提到在实现过程中遇到回路判断的问题，通过并查集解决。
- **踩坑教训**：有些题解在实现时忽略了边的排序，导致算法效率低下。
- **顿悟感想**：通过Kruskal算法，深刻理解了贪心策略在图论中的应用。

---
处理用时：41.91秒
# 题目信息

# 营救

## 题目背景

“咚咚咚……”“查水表！”原来是查水表来了，现在哪里找这么热心上门的查表员啊！小明感动得热泪盈眶，开起了门……

## 题目描述

妈妈下班回家，街坊邻居说小明被一群陌生人强行押上了警车！妈妈丰富的经验告诉她小明被带到了 $t$ 区，而自己在 $s$ 区。

该市有 $m$ 条大道连接 $n$ 个区，一条大道将两个区相连接，每个大道有一个拥挤度。小明的妈妈虽然很着急，但是不愿意拥挤的人潮冲乱了她优雅的步伐。所以请你帮她规划一条从 $s$ 至 $t$ 的路线，使得经过道路的拥挤度最大值最小。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 10$。
- 对于 $60\%$ 的数据，保证 $n\leq 100$。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m \leq 2 \times 10^4$，$w \leq 10^4$，$1 \leq s, t \leq n$。且从 $s$ 出发一定能到达 $t$ 区。

--- 

#### 样例输入输出 1 解释

小明的妈妈要从 $1$ 号点去 $3$ 号点，最优路线为 $1$->$2$->$3$。

## 样例 #1

### 输入

```
3 3 1 3
1 2 2
2 3 1
1 3 3```

### 输出

```
2
```

# AI分析结果

### 综合分析与结论

本题的核心是找到从起点 `s` 到终点 `t` 的路径，使得路径中的最大拥挤度最小。题解中主要采用了以下几种思路：

1. **最小生成树（Kruskal算法）**：通过将边按拥挤度从小到大排序，逐步构建最小生成树，直到 `s` 和 `t` 连通，此时最后加入的边的拥挤度即为所求。
2. **最短路算法（Dijkstra、SPFA等）**：通过修改松弛操作，将路径的拥挤度最大值作为更新的依据，最终得到 `s` 到 `t` 的最小最大拥挤度。
3. **二分答案 + BFS/并查集**：通过二分法枚举最大拥挤度，利用 BFS 或并查集判断在该拥挤度下 `s` 和 `t` 是否连通。

### 所选高星题解

#### 1. 题解作者：薄荷凉了夏 (4星)
**关键亮点**：
- 使用 Dijkstra + 堆优化，修改松弛操作为 `max(dis[u], w)`，思路清晰且代码简洁。
- 通过优先队列实现堆优化，提升了算法效率。

**核心代码**：
```cpp
void dijkstra() {
    memset(dis, 0x3f, sizeof(dis));
    dis[s] = 0;
    q.push(make_pair(0, s));
    while (!q.empty()) {
        int x = q.top().second; q.pop();
        if (vis[x]) continue;
        vis[x] = 1;
        for (int i = head[x]; i; i = edge[i].next) {
            int k = max(dis[x], edge[i].w), r = edge[i].now;
            if (k < dis[r]) {
                dis[r] = k;
                q.push(make_pair(-dis[r], r)); // 小根堆
            }
        }
    }
}
```

#### 2. 题解作者：Orion_Rigel (4星)
**关键亮点**：
- 采用二分答案 + BFS，通过二分法枚举最大拥挤度，利用 BFS 判断连通性，思路清晰且易于理解。
- 代码结构清晰，适合初学者理解二分法的应用。

**核心代码**：
```cpp
bool SPFA(int mid) {
    memset(dis, 0x3f, sizeof dis);
    queue<int> q;
    q.push(S);
    dis[S] = 1;
    while (!q.empty()) {
        int x = q.front(); q.pop();
        for (int i = h[x]; i >= 0; i = ne[i]) {
            if (w[i] <= mid && dis[to[i]] == 0x3f3f3f3f) {
                dis[to[i]] = 1;
                q.push(to[i]);
            }
        }
    }
    return dis[T] != 0x3f3f3f3f;
}
```

#### 3. 题解作者：lzk5627 (4星)
**关键亮点**：
- 使用 Kruskal 最小生成树算法，通过并查集维护连通性，直到 `s` 和 `t` 连通，思路简洁且高效。
- 代码实现简洁，适合快速理解最小生成树的应用。

**核心代码**：
```cpp
for (int i = 1; i <= m; i++) {
    int X = find(b[i].x), Y = find(b[i].y);
    if (X != Y) a[X] = Y;
    if (find(s) == find(t)) {
        cout << b[i].cost << endl;
        return 0;
    }
}
```

### 最优关键思路与技巧

1. **最小生成树（Kruskal算法）**：通过逐步加入最小边，直到 `s` 和 `t` 连通，最后加入的边即为所求。该思路简洁且高效，适合处理此类问题。
2. **最短路算法（Dijkstra、SPFA）**：通过修改松弛操作为 `max(dis[u], w)`，可以快速找到路径中的最小最大拥挤度。
3. **二分答案 + BFS/并查集**：通过二分法枚举最大拥挤度，结合 BFS 或并查集判断连通性，适合处理大规模数据。

### 可拓展之处

- **类似问题**：可以拓展到其他需要找到路径中最大/最小值的问题，如最小瓶颈路、最大流等。
- **算法优化**：可以结合更多优化技巧，如堆优化、路径压缩等，提升算法效率。

### 推荐题目

1. **P1111 修复公路**（最小生成树）
2. **P3371 【模板】单源最短路径（弱化版）**（最短路）
3. **P3385 【模板】负环**（SPFA）

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现并查集路径压缩的重要性，若不压缩路径会导致超时。
- **顿悟感想**：通过修改最短路算法的松弛操作，可以解决许多类似的最大/最小值问题，体现了算法的灵活性和通用性。

通过以上分析与总结，可以更好地理解并掌握此类问题的解决方法。

---
处理用时：43.48秒
# 题目信息

# 炸铁路

## 题目描述

A 国派出将军 uim，对 B 国进行战略性措施，以解救涂炭的生灵。

B 国有 $n$ 个城市，这些城市以铁路相连。任意两个城市都可以通过铁路直接或者间接到达。

uim 发现有些铁路被毁坏之后，某两个城市无法互相通过铁路到达。这样的铁路就被称为 key road。

uim 为了尽快使该国的物流系统瘫痪，希望炸毁铁路，以达到存在某两个城市无法互相通过铁路到达的效果。

然而，只有一发炮弹（A 国国会不给钱了）。所以，他能轰炸哪一条铁路呢？


## 样例 #1

### 输入

```
6 6
1 2
2 3
2 4
3 5
4 5
5 6```

### 输出

```
1 2
5 6```

# AI分析结果

### 综合分析与结论

本题的核心是寻找无向图中的桥（割边），即删除后会使图不连通的边。题解中主要采用了以下几种方法：

1. **Tarjan算法**：这是最经典且高效的方法，时间复杂度为O(n+m)，适用于大规模数据。通过深度优先搜索（DFS）遍历图，记录每个节点的dfn（深度优先编号）和low（通过子孙节点能到达的最小dfn），判断边是否为桥。
   
2. **暴力枚举+并查集/DFS/BFS**：这类方法通过枚举每条边，删除后使用并查集、DFS或BFS判断图的连通性。虽然时间复杂度较高（O(m^2)），但由于本题数据规模较小，依然可以通过。

3. **Kruskal算法**：通过模拟最小生成树的构建过程，判断删除某条边后图是否仍然连通。时间复杂度为O(m^2)，适用于小规模数据。

### 评分较高的题解

#### 1. **题解作者：abruce**
- **星级**：★★★★★
- **关键亮点**：详细解释了Tarjan算法的实现细节，特别是dfn和low的定义及其在判断桥时的作用。代码结构清晰，注释详细，适合初学者理解。
- **个人心得**：作者通过图示和文字详细解释了Tarjan算法的回溯过程，帮助读者更好地理解算法的核心思想。
- **核心代码**：
  ```cpp
  void tarjan(int x) {
      int c=0,y;
      dfn[x]=low[x]=++id;
      for(register int i=1; i<=n; i++) {
          if(!maps[x][i])continue;
          y=i;
          if(dfn[y]&&y!=f[x])low[x]=min(low[x],dfn[y]);
          if(!dfn[y]) {
              f[y]=x;
              tarjan(y);
              low[x]=min(low[x],low[y]);
              if(low[y]>dfn[x])addEdge(x,y);
          }
      }
  }
  ```

#### 2. **题解作者：hsfzLZH1**
- **星级**：★★★★☆
- **关键亮点**：同样使用Tarjan算法，但代码更加简洁，且提供了对重边的处理方案，增强了算法的鲁棒性。
- **核心代码**：
  ```cpp
  void dfs(int cur,int fa) {
      int child;
      dfn[cur]=++index_;
      low[cur]=dfn[cur];
      for(int i=0;i<G[cur].size();i++) {
          child=G[cur][i];
          if(dfn[child]&&child!=fa)low[cur]=min(low[cur],dfn[child]);
          if(!dfn[child]) {
              dfs(child,cur);
              if(dfn[cur]<low[child])add_edge(cur,child);
              low[cur]=min(low[cur],low[child]);
          }
      }
  }
  ```

#### 3. **题解作者：HRLYB**
- **星级**：★★★★☆
- **关键亮点**：引入了双连通分量的概念，通过Tarjan算法求解双连通分量，再通过枚举边判断是否为桥。思路新颖，适合进阶学习。
- **核心代码**：
  ```cpp
  void tarjan(int u) {
      deep+=1;
      dfn[u]=deep;
      low[u]=deep;
      top++;
      vis[u]=true;
      stac[top]=u;
      for(int i=head[u];i;i=e[i].next )
          if(!sign[i]){
              sign[i]=true,sign[i^1]=true;
              int v=e[i].v ;
              if(!dfn[v]){
                  tarjan(v);
                  if(low[v]<low[u])low[u]=low[v];
              }
              else {
                  if(vis[v]){
                      if(low[v]<low[u])low[u]=low[v];
                  }
              }
      }
      if(low[u]==dfn[u]){
          num+=1;
          vis[u]=false;
          color[u]=num;
          while(stac[top]!=u){
              color[stac[top]]=num;
              vis[stac[top]]=false;
              top--;
          }
          top--;
      }
  }
  ```

### 最优关键思路与技巧

- **Tarjan算法**：通过DFS遍历图，记录dfn和low，判断边是否为桥。这是解决此类问题的经典方法，时间复杂度低，适用于大规模数据。
- **并查集/DFS/BFS**：通过枚举边并判断图的连通性，虽然时间复杂度较高，但实现简单，适合小规模数据。
- **双连通分量**：通过Tarjan算法求解双连通分量，再判断边是否为桥，思路新颖，适合进阶学习。

### 可拓展之处

- **类似算法套路**：Tarjan算法不仅可以用于求桥，还可以用于求割点、强连通分量等。掌握Tarjan算法可以解决多种图论问题。
- **同类型题目**：可以尝试解决求割点、强连通分量等问题，进一步巩固Tarjan算法的应用。

### 推荐题目

1. **P3388 【模板】割点**：考察Tarjan算法在求割点中的应用。
2. **P2860 [USACO06JAN]冗余路径Redundant Paths**：考察双连通分量的应用。
3. **P3387 【模板】缩点**：考察Tarjan算法在强连通分量中的应用。

### 个人心得总结

- **调试经历**：在处理重边时，Tarjan算法可能会出现错误，需要特别注意。可以通过标记边的访问状态来避免重复访问。
- **踩坑教训**：在枚举边时，需要注意边的顺序，避免重复输出。可以通过排序边来保证输出的顺序正确。
- **顿悟感想**：Tarjan算法的核心在于dfn和low的定义及其在回溯时的更新，理解这一点后，算法的实现就变得简单了。

---
处理用时：48.43秒
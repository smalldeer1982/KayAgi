# 题目信息

# 过家家

## 题目描述

有 $2n$ 个小学生来玩过家家游戏，其中有 $n$ 个男生，编号为 $1$ 到 $n$，另外 $n$ 个女生，编号也是 $1$ 到 $n$。每一个女生可以选择一个和她不吵嘴的男生来玩，除此之外，如果编号为 $X$ 的女生的朋友（也是女生，且编号为 $Y$）不和编号为 $Z$ 的男生吵嘴，那么 $X$ 也可以选择 $Z$。此外，朋友关系是可以传递的，比如 $a$ 和 $b$ 是朋友，$b$ 和 $c$ 是朋友，那么我们可以认为 $a$ 和 $c$ 也是朋友。注意，一个男生可以被多个女生选择为玩伴。

当每一位女生都选择了玩伴，那么他们会开始新一轮游戏。在每一轮后，每个女生都会开始去找一个新的男生做玩伴（以前没选过）。而且每一个女生最多能强制 $k$ 个男生接受，无论他们以前是否吵嘴。

现在你的任务就是确定这 $2n$ 个小学生最多能玩几轮游戏。


## 样例 #1

### 输入

```
4 5 1 2
1 1
2 3
3 2
4 2
4 4
1 4
2 3
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心在于处理女生之间的朋友关系（传递性）以及女生与男生之间的选择关系。大多数题解采用了并查集来处理女生之间的朋友关系，并通过统计每个连通块中女生可以选择的男生数量来确定游戏的轮数。部分题解还引入了Floyd算法或Bitset来优化处理过程。整体上，并查集是解决此类连通性问题的常用工具，而Floyd和Bitset则提供了额外的优化手段。

### 所选高星题解

#### 1. 作者：NewSjf (★★★★★)
- **关键亮点**：使用并查集处理女生之间的朋友关系，并通过标记数组避免重复计数，最后通过取最小值确定游戏轮数。代码简洁且易于理解。
- **个人心得**：通过并查集处理朋友关系，避免了复杂的图遍历，提升了效率。
- **核心代码**：
```cpp
int find(int x){return x==pre[x]?x:pre[x]=find(pre[x]);} 
void merge(int x,int y)
{
    int fx=find(x),fy=find(y);
    if(fx!=fy)pre[fx]=fy;
}
```
- **代码思想**：通过并查集合并女生朋友关系，统计每个连通块中女生可以选择的男生数量，最后取最小值并加上k。

#### 2. 作者：theStarMaster (★★★★)
- **关键亮点**：使用并查集维护女生朋友关系，并通过标记数组避免重复计数，最后取最小值并加上k。代码清晰且逻辑严谨。
- **核心代码**：
```cpp
inline int Find(int x)
{
    if(x == fa[x]) return x;
    else return fa[x] = Find(fa[x]);
}
```
- **代码思想**：通过并查集合并女生朋友关系，统计每个连通块中女生可以选择的男生数量，最后取最小值并加上k。

#### 3. 作者：Rikka__ (★★★★)
- **关键亮点**：使用Bitset优化女生与男生之间的选择关系处理，通过按位或操作快速合并连通块中的男生选择。
- **核心代码**：
```cpp
bitset<260> s[260];
```
- **代码思想**：通过Bitset存储女生与男生之间的选择关系，利用按位或操作快速合并连通块中的男生选择，最后统计最小值并加上k。

### 最优关键思路与技巧
- **并查集**：处理女生之间的朋友关系，确保传递性。
- **标记数组**：避免重复计数，提升统计效率。
- **Bitset**：优化女生与男生之间的选择关系处理，快速合并连通块中的男生选择。

### 可拓展之处
- **类似问题**：处理具有传递性关系的连通性问题，如社交网络中的朋友关系、图的连通性等。
- **算法套路**：并查集、Floyd算法、Bitset等在处理连通性问题时的应用。

### 推荐题目
1. **P3367 【模板】并查集** - 基础并查集应用。
2. **P3388 【模板】割点（割顶）** - 图的连通性问题。
3. **P3379 【模板】最近公共祖先（LCA）** - 树结构的连通性问题。

### 个人心得总结
- **调试经历**：在处理女生朋友关系时，确保并查集的正确合并是关键，避免重复计数。
- **踩坑教训**：在统计男生选择数量时，使用标记数组可以有效避免重复计数，提升效率。
- **顿悟感想**：通过并查集和Bitset的结合，可以高效处理复杂的连通性问题，提升代码的可读性和执行效率。

---
处理用时：29.91秒
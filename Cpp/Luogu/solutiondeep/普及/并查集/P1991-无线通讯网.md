# 题目信息

# 无线通讯网

## 题目描述

国防部计划用无线网络连接若干个边防哨所。2 种不同的通讯技术用来搭建无线网络；

每个边防哨所都要配备无线电收发器；有一些哨所还可以增配卫星电话。

任意两个配备了一条卫星电话线路的哨所（两边都有卫星电话）均可以通话，无论他们相距多远。而只通过无线电收发器通话的哨所之间的距离不能超过 $D$，这是受收发器的功率限制。收发器的功率越高，通话距离 $D$ 会更远，但同时价格也会更贵。

收发器需要统一购买和安装，所以全部哨所只能选择安装一种型号的收发器。换句话说，每一对哨所之间的通话距离都是同一个 $D$。你的任务是确定收发器必须的最小通话距离 $D$，使得每一对哨所之间至少有一条通话路径（直接的或者间接的）。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据：$P = 2，S = 1$；
- 对于另外 $20\%$ 的数据：$P = 4，S = 2$；
- 对于 $100\%$ 的数据保证：$1 ≤ S ≤ 100$，$S < P ≤ 500$，$0 ≤ x,y ≤ 10000$。


## 样例 #1

### 输入

```
2 4
0 100
0 300
0 600
150 750
```

### 输出

```
212.13
```

# AI分析结果

### 综合分析与结论

本题的核心是通过最小生成树（MST）的思想，结合卫星电话的特殊性质，找到最小的无线电收发器传输距离 \(D\)。大多数题解采用了Kruskal算法，利用并查集维护连通性，并通过贪心策略选择最小的边，最终输出第 \(P-S\) 大的边作为答案。部分题解还引入了二分查找优化，进一步提升了算法的效率。

### 所选高星题解

#### 1. 作者：constructor (赞：171)
- **星级**: ⭐⭐⭐⭐⭐
- **关键亮点**: 
  - 详细解释了瓶颈生成树与最小生成树的关系，逻辑清晰。
  - 通过卫星电话的性质，推导出只需要选择前 \(P-S\) 条边，输出第 \(P-S\) 大的边作为答案。
  - 代码实现简洁，使用了C++11的`tuple`和`vector`，代码可读性高。
- **个人心得**: 
  - 作者通过图示和详细的推导过程，帮助读者理解卫星电话如何影响最小生成树的生成过程，避免了直接删除边的误区。

```cpp
int main() {
    stin >> S >> P;
    for(int i = 1; i <= P; i++)
        stin >> pos[i].first >> pos[i].second;
    std::iota(p+1, p+1+P, 1);
    for(int i = 1; i <= P - 1; i++)
        for(int j = i+1; j <= P; j++) {
            auto dis = EuclidDistance(pos[i], pos[j]);
            gra.emplace_back(dis, i, j);
            gra.emplace_back(dis, j, i);
        }
    std::sort(gra.begin(), gra.end());
    int count = 0;
    for(auto& i : gra) {
        if(find(std::get<1>(i))!=find(std::get<2>(i))) {
            p[p[std::get<1>(i)]] = p[std::get<2>(i)];
            count++;
        }
        if(count == P - S) {
            std::cout << std::fixed << std::setprecision(2) << std::get<0>(i) << std::ends;
            return 0;
        }
    }
}
```

#### 2. 作者：Strong_Jelly (赞：149)
- **星级**: ⭐⭐⭐⭐
- **关键亮点**: 
  - 直接指出本题是最小生成树的变种，思路简洁明了。
  - 通过Kruskal算法实现，代码结构清晰，易于理解。
  - 强调了卫星电话的作用，简化了问题的复杂度。
- **个人心得**: 
  - 作者通过简单的逻辑推导，快速得出结论，适合初学者理解。

```cpp
int main() {
    scanf("%d %d", &s, &p);
    for(int i = 1; i <= p; i++) {
        scanf("%d %d", &a[i], &b[i]);
        for(int j = 1; j < i; j++) {
            n++;
            stu[n].z = sqrt((a[i] - a[j]) * (a[i] - a[j]) + (b[i] - b[j]) * (b[i] - b[j]));
            stu[n].x = i;
            stu[n].y = j;
        }
    }
    sort(stu + 1, stu + n + 1, cmp);
    for(int i = 1; i <= p; i++) fa[i] = i;
    for(int i = 1; i <= n; i++) {
        if(find(stu[i].x) != find(stu[i].y)) {
            unity(stu[i].x, stu[i].y);
            ans = stu[i].z;
            k++;
            if(k >= p - s) {
                printf("%.2lf", ans);
                return 0;
            }
        }
    }
    return 0;
}
```

#### 3. 作者：George1123 (赞：93)
- **星级**: ⭐⭐⭐⭐
- **关键亮点**: 
  - 采用了二分查找优化，结合并查集判断连通性，提升了算法效率。
  - 通过二分查找确定最小的 \(D\)，思路新颖且高效。
- **个人心得**: 
  - 作者通过二分查找的方式，避免了直接生成所有边的计算，减少了时间复杂度。

```cpp
int main() {
    scanf("%d%d",&s,&p);
    for(int i=1;i<=p;i++){
        scanf("%d%d",&P[i].x,&P[i].y);
    } for(int i=1;i<=p;i++)
        for(int j=i+1;j<=p;j++)
            r=max(dis(P[i],P[j]),r);
    while(l<r){
        mid=(l+r)>>1;
        BCJ.clear(p); sum=p;
        for(int i=1;i<=p;i++){
            for(int j=i+1;j<=p;j++){
                if(!BCJ.same(i,j)&&dis(P[i],P[j])<=mid){
                    BCJ.merge(i,j);
                    sum--;
                }
            }
        } if(sum<=s) r=mid;
        else l=mid+1;
    } printf("%.2lf\n",sqrt(l));
    return 0;
}
```

### 最优关键思路与技巧

1. **瓶颈生成树与最小生成树的关系**: 通过最小生成树的性质，推导出只需要选择前 \(P-S\) 条边，输出第 \(P-S\) 大的边作为答案。
2. **二分查找优化**: 通过二分查找确定最小的 \(D\)，结合并查集判断连通性，提升了算法效率。
3. **卫星电话的性质**: 利用卫星电话可以连接任意距离的点，将问题转化为最小生成树的生成过程。

### 可拓展之处

- **类似问题**: 类似的问题可以扩展到其他需要最小化最大边权的场景，如网络设计、路径规划等。
- **算法套路**: 二分查找结合并查集的方式可以应用于其他需要判断连通性的问题，如判断图的连通性、最小生成树的生成等。

### 推荐题目

1. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
2. [P1396 营救](https://www.luogu.com.cn/problem/P1396)
3. [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195)

---
处理用时：54.23秒
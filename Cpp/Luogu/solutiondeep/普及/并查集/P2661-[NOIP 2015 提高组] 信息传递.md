# 题目信息

# [NOIP 2015 提高组] 信息传递

## 题目背景

NOIP2015 Day1T2

## 题目描述

有 $n$ 个同学（编号为 $1$ 到 $n$）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。

游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？

## 说明/提示

**样例 1 解释：**

![](https://cdn.luogu.com.cn/upload/image_hosting/3ca5zl3c.png)

游戏的流程如图所示。当进行完第 $3$ 轮游戏后，$4$ 号玩家会听到 $2$ 号玩家告诉他自己的生日，所以答案为 $3$。当然，第 $3$ 轮游戏后，$2$ 号玩家、 $3$ 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。

- 对于 $30\%$ 的数据，$n\le 200$；
- 对于 $60\%$ 的数据，$n\le 2500$；
- 对于 $100\%$ 的数据，$n\le 2\times 10^5$。


## 样例 #1

### 输入

```
5
2 4 2 3 1```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心是找到有向图中的最小环，且每个节点的出度为1。题解中主要采用了以下几种思路：
1. **DFS + 时间戳**：通过DFS遍历图，记录每个节点的访问时间，找到环的长度。
2. **并查集**：利用并查集的性质，通过路径压缩和距离记录，快速找到环的长度。
3. **拓扑排序 + DFS**：先通过拓扑排序去除不在环中的节点，再通过DFS找到环的长度。
4. **Tarjan算法**：利用Tarjan算法找到强连通分量，进而得到最小环的长度。

这些方法各有优劣，DFS和并查集较为直观，适合初学者理解；Tarjan算法虽然复杂，但在处理大规模数据时效率较高。

### 所选高星题解

#### 1. 作者：KesdiaelKen (5星)
**关键亮点**：
- 通过DFS遍历图，记录每个节点的访问时间，找到环的长度。
- 优化了DFS的剪枝策略，避免重复访问已处理的节点。
- 代码简洁，思路清晰，适合初学者理解。

**个人心得**：
作者提到最初尝试用set暴力判重，但TLE了6个点，经过彻夜思考后优化了DFS的剪枝策略，最终通过。这种调试经历展示了从暴力到优化的思维过程。

**核心代码**：
```cpp
void dfs(int node,int num)
{
    if(novisit[node])return;
    if(visit[node])
    {
        minn=min(minn,num-bs[node]);
    }
    else
    {
        visit[node]=true;
        bs[node]=num;
        dfs(dx[node],num+1);
        novisit[node]=true;
    }
}
```
**核心思想**：通过DFS遍历图，记录每个节点的访问时间，找到环的长度。

#### 2. 作者：Ascnbeta (4星)
**关键亮点**：
- 使用并查集处理环，通过路径压缩和距离记录，快速找到环的长度。
- 详细解释了并查集的实现思路，适合有一定基础的学习者。

**核心代码**：
```cpp
inline int find(int x) {
    if (father[x] != x) {
        int lst = father[x];
        father[x] = find(father[x]);
        v[x] += v[lst];
    }
    return father[x];
}
inline void merge(int x,int y) {
    int p = find(x);
    int q = find(y);
    if (p != q) {
        father[p] = q;
        v[x] = v[y] + 1;
    }else{
        ans = min(ans,v[x]+v[y]+1);
    }
}
```
**核心思想**：通过并查集合并节点，记录节点到根节点的距离，找到环的长度。

#### 3. 作者：CaiZi (4星)
**关键亮点**：
- 使用Tarjan算法找到强连通分量，进而得到最小环的长度。
- 代码实现规范，适合有一定算法基础的学习者。

**核心代码**：
```cpp
inline void tarjan(int i){
    tim++;
    dfn[i]=low[i]=tim;
    s.push(i);
    for(int j:g[i]){
        if(dfn[j]==0){
            tarjan(j);
            low[i]=min(low[i],low[j]);
        }
        else{
            if(!bel[j]){
                low[i]=min(low[i],dfn[j]);
            }
        }
    }
    if(low[i]==dfn[i]){
        int j;
        scc++;
        do{
            j=s.top();
            s.pop();
            bel[j]=true;
            siz[scc]+=1;
        }while(j!=i);
    }
}
```
**核心思想**：通过Tarjan算法找到强连通分量，进而得到最小环的长度。

### 最优关键思路或技巧
- **DFS + 时间戳**：通过记录每个节点的访问时间，可以快速找到环的长度，适合初学者理解。
- **并查集**：通过路径压缩和距离记录，可以在O(n)时间内找到环的长度，适合处理大规模数据。
- **Tarjan算法**：虽然复杂，但在处理大规模数据时效率较高，适合有一定算法基础的学习者。

### 可拓展之处
- **同类型题**：类似的有向图最小环问题，可以使用相同的思路解决。
- **算法套路**：DFS、并查集、Tarjan算法等在图论问题中广泛应用，掌握这些算法可以解决更多类似问题。

### 推荐题目
1. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)
2. [P2863 [USACO06JAN]The Cow Prom S](https://www.luogu.com.cn/problem/P2863)
3. [P1262 间谍网络](https://www.luogu.com.cn/problem/P1262)

### 个人心得总结
- **调试经历**：从暴力到优化的思维过程，展示了如何通过优化算法提高效率。
- **踩坑教训**：暴力算法在大规模数据下容易TLE，需要优化剪枝策略。
- **顿悟感想**：通过深入理解问题本质，可以找到更高效的解决方案。

---
处理用时：39.33秒
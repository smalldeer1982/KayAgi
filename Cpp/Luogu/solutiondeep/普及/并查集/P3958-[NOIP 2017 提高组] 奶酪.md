# 题目信息

# [NOIP 2017 提高组] 奶酪

## 题目背景

NOIP2017 提高组 D2T1

## 题目描述

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?

空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：


$$\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$


## 说明/提示

【输入输出样例 $1$ 说明】

 ![](https://cdn.luogu.com.cn/upload/pic/10860.png) 

第一组数据,由奶酪的剖面图可见：

第一个空洞在 $(0,0,0)$ 与下表面相切；

第二个空洞在 $(0,0,4)$ 与上表面相切；

两个空洞在 $(0,0,2)$ 相切。

输出 `Yes`。

 
第二组数据,由奶酪的剖面图可见：

两个空洞既不相交也不相切。

输出 `No`。

 
第三组数据,由奶酪的剖面图可见：

两个空洞相交，且与上下表面相切或相交。

输出 `Yes`。

【数据规模与约定】

对于 $20\%$ 的数据，$n = 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。

对于 $40\%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $80\%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $100\%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3 
2 4 1 
0 0 1 
0 0 3 
2 5 1 
0 0 1 
0 0 4 
2 5 2 
0 0 2 
2 0 4```

### 输出

```
Yes
No
Yes```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何判断老鼠能否通过奶酪中的空洞从下表面跑到上表面。题解中主要采用了以下几种思路：

1. **并查集**：将空洞视为节点，若两个空洞相交或相切，则将它们合并到同一个集合中。最后检查是否存在一个集合同时包含与下表面和上表面相连的空洞。
2. **DFS/BFS**：将空洞视为图中的节点，若两个空洞相交或相切，则在它们之间建立边。通过DFS或BFS遍历图，判断是否存在从下表面到上表面的路径。
3. **优化技巧**：避免使用浮点数计算，通过平方距离来比较，避免精度问题；使用并查集的路径压缩和按秩合并优化查找和合并操作。

大部分题解都采用了并查集或DFS/BFS的思路，并提供了详细的代码实现。部分题解还提到了优化技巧，如避免浮点数计算、使用邻接矩阵存储图等。

### 所选高星题解

#### 1. **题解作者：Fading (5星)**
- **关键亮点**：使用并查集实现，代码简洁且高效，避免了浮点数计算，通过平方距离进行比较，避免了精度问题。题解中还提到了并查集的路径压缩优化。
- **个人心得**：作者提到最初由于double精度问题导致样例无法通过，后来通过优化避免了浮点数计算，最终AC。
- **核心代码**：
  ```cpp
  int find(int x){
      if (x!=f[x]) f[x]=find(f[x]);
      return f[x];
  }
  long long dis(long long x,long long y,long long z,long long x1,long long y1,long long z1){
      return (x-x1)*(x-x1)+(y-y1)*(y-y1)+(z-z1)*(z-z1);
  }
  ```

#### 2. **题解作者：ikunTLE (4星)**
- **关键亮点**：使用并查集实现，代码结构清晰，注释详细，易于理解。题解中提到了避免浮点数计算的优化技巧。
- **核心代码**：
  ```cpp
  int _find(int x){
      if(x==fa[x]) return x;
      fa[x]=_find(fa[x]);
      return fa[x];
  }
  int dis(int x1,int x2,int y1,int y2,int z1,int z2){
      return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2);
  }
  ```

#### 3. **题解作者：Malkin_Moonlight (4星)**
- **关键亮点**：使用DFS实现，代码简洁，逻辑清晰。题解中提到了避免浮点数计算的优化技巧，并通过邻接矩阵存储图。
- **核心代码**：
  ```cpp
  bool e(int i,int j){
      double dis=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);
      return dis<=4*r*r;
  }
  void dfs(int k){
      if(ok)return;
      if(z[k]+r>=h){
          ok=1;
          return;
      }
      v[k]=1;
      for(int i=1;i<=n;i++)
      if(!v[i]&&e(i,k))
      dfs(i);
  }
  ```

### 最优关键思路与技巧

1. **并查集优化**：通过路径压缩和按秩合并优化并查集的查找和合并操作，提高算法效率。
2. **避免浮点数计算**：通过平方距离来比较，避免使用浮点数计算，减少精度问题。
3. **图的遍历**：使用DFS或BFS遍历图，判断是否存在从下表面到上表面的路径。

### 可拓展之处

本题的并查集和DFS/BFS思路可以应用于其他类似的连通性问题，如判断图中的节点是否连通、寻找图中的路径等。类似的问题还可以扩展到更高维度的空间，如四维空间中的连通性问题。

### 推荐相似题目

1. **P3367 【模板】并查集**：基础并查集模板题，适合练习并查集的基本操作。
2. **P1330 封锁阳光大学**：使用DFS/BFS遍历图，判断图的连通性。
3. **P3385 【模板】负环**：使用BFS判断图中是否存在负环，适合练习图的遍历和判断。

### 个人心得总结

- **调试经历**：部分题解作者提到由于浮点数精度问题导致样例无法通过，后来通过优化避免了浮点数计算，最终AC。这提醒我们在处理几何问题时，尽量避免使用浮点数计算，以减少精度问题。
- **顿悟感想**：通过并查集或DFS/BFS可以高效地解决连通性问题，关键在于如何将问题转化为图论问题，并选择合适的算法进行求解。

---
处理用时：37.31秒
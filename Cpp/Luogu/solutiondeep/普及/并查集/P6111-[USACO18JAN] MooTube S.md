# 题目信息

# [USACO18JAN] MooTube S

## 题目背景

*本题与 [金组同名题目](/problem/P4185) 在题意上一致，唯一的差别是数据范围。*

## 题目描述

在业余时间，Farmer John 创建了一个新的视频共享服务，他将其命名为 MooTube。在 MooTube 上，Farmer John 的奶牛可以录制，分享和发现许多有趣的视频。他的奶牛已经发布了 $N$ 个视频（$1 \leq N \leq 5000$），为了方便将其编号为  $1 \ldots N$ 。然而，FJ 无法弄清楚如何帮助他的奶牛找到他们可能喜欢的新视频。

FJ 希望为每个 MooTube 视频创建一个“推荐视频”列表。这样，奶牛将被推荐与他们已经观看过的视频最相关的视频。

FJ 设计了一个“相关性”度量标准，顾名思义，它确定了两个视频相互之间的相关性。他选择 $N-1$ 对视频并手动计算其之间的相关性。然后，FJ 将他的视频建成一棵树，其中每个视频是节点，并且他手动将 $N-1$ 对视频连接。为了方便，FJ 选择了 $N-1$ 对，这样任意视频都可以通过一条连通路径到达任意其他视频。 FJ 决定将任意一对视频的相关性定义为沿此路径的任何连接的最小相关性。

Farmer John 想要选择一个 $K$ 值，以便在任何给定的 MooTube 视频旁边，推荐所有其他与该视频至少有 $K$ 相关的视频。然而，FJ 担心会向他的奶牛推荐太多的视频，这可能会分散他们对产奶的注意力！因此，他想设定适当的 $K$ 值。 Farmer John希望得到您的帮助，回答有关 $K$ 值的推荐视频的一些问题。

## 样例 #1

### 输入

```
4 3
1 2 3
2 3 2
2 4 4
1 2
4 1
3 1```

### 输出

```
3
0
2```

# AI分析结果

### 综合分析与结论

本题的核心问题是在一棵树中，对于每个询问，找到与给定节点 \(v\) 的相关性（路径最小边权）大于等于 \(k\) 的节点数量。题解主要分为两类：

1. **暴力DFS/BFS**：通过从给定节点出发，遍历所有边权大于等于 \(k\) 的路径，统计可达节点数。这种方法简单直观，但时间复杂度较高，适合小规模数据。
2. **离线并查集**：将边和询问按边权从大到小排序，逐步合并边权大于等于当前 \(k\) 的边，利用并查集维护连通块大小。这种方法时间复杂度较低，适合大规模数据。

### 所选高星题解

#### 1. **作者：HsKr (5星)**
- **关键亮点**：使用离线并查集，将边和询问按边权排序，逐步合并边权大于等于 \(k\) 的边，利用并查集维护连通块大小。思路清晰，代码结构良好，时间复杂度优化到 \(O(N \log N + Q \log Q)\)。
- **核心代码**：
  ```cpp
  sort(E+1,E+n+1-1,cmpE); // 对边的相关性进行排序
  sort(Q+1,Q+q+1,cmpQ); // 对询问的相关性进行排序
  int j=1;
  for(int i=1;i<=q;i++){ // 枚举每一个询问
      while(j<n&&E[j].w>=Q[i].k){ // 只要不越界或没有达到相关性就循环操作
          uni(E[j].u,E[j].v); // 连接两边
          j++;
      }
      ans[Q[i].id]=size[find(Q[i].v)]-1; // -1是因为自己不能推荐自己
  }
  ```

#### 2. **作者：Little09 (5星)**
- **关键亮点**：同样使用离线并查集，思路与HsKr类似，但代码实现更为简洁，且对并查集的路径压缩和连通块大小的维护进行了详细说明。
- **核心代码**：
  ```cpp
  sort(t+1,t+n,cmp1); // 边排序
  sort(q+1,q+m+1,cmp2); // 询问排序
  int num=0;
  for(int i=1;i<=m;i++){
      for(;num<n;num++){
          if(t[num+1].z>=q[i].k){
              int x1=find(t[num+1].x),y1=find(t[num+1].y);
              fa[x1]=y1;
              res[x1]+=res[y1];
              res[y1]=res[x1];
          }
          else break;
      }
      int p=find(q[i].x);
      ans[q[i].id]=res[q[i].x]-1;
  }
  ```

#### 3. **作者：银杉水杉秃杉 (4星)**
- **关键亮点**：使用离线并查集，思路清晰，代码结构良好，且对排序和并查集的操作进行了详细说明。
- **核心代码**：
  ```cpp
  sort(e+1,e+n,cmpe); // 边排序
  sort(q+1,q+m+1,cmpq); // 询问排序
  int j=1;
  for(int i=1;i<=m;i++){
      while(j<n&&e[j].w>=q[i].k){ // 扫边
          merge(e[j].u,e[j].v); // 合并
          j++;
      }
      ans[q[i].id]=s[find(q[i].v)]-1; // 记录答案
  }
  ```

### 最优关键思路与技巧

1. **离线处理**：将边和询问按边权从大到小排序，逐步处理，避免重复计算。
2. **并查集优化**：利用并查集维护连通块大小，路径压缩和按秩合并优化查询和合并操作。
3. **排序策略**：边和询问按边权从大到小排序，确保每次处理时只需考虑当前边权大于等于 \(k\) 的边。

### 可拓展之处

1. **在线处理**：如果需要在处理过程中动态添加边或询问，可以考虑使用Kruskal重构树或其他动态数据结构。
2. **其他图问题**：类似思路可以应用于最小生成树、连通性问题等。

### 推荐题目

1. **P4185 [USACO18JAN]MooTube G**：本题的加强版，数据范围更大，适合练习离线并查集。
2. **P3367 【模板】并查集**：基础并查集练习，理解并查集的基本操作。
3. **P1967 [NOIP2013 提高组] 货车运输**：类似的最小边权问题，适合练习并查集和离线处理。

### 个人心得摘录

- **调试经历**：部分题解提到在实现并查集时，路径压缩和按秩合并的细节容易出错，建议在实现时多加注意。
- **顿悟感想**：离线处理的思想在处理大规模数据时非常有效，能够显著降低时间复杂度，值得深入理解和掌握。

---
处理用时：44.99秒
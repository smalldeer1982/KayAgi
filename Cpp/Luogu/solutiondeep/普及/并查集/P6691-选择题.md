# 题目信息

# 选择题

## 题目背景

小 L 喜欢逻辑推理。

一天，他在一本由英国哲士沃·协德编写的《我也不知道为什么要叫这个名字的一本有关逻辑学的书》中翻到了一道奇特的问题，但他并不会做。他知道你善于用程序解决问题，于是决定让你来帮助他完成这些问题。

## 题目描述

这是一道有 $n$ 个选项的选择题，每个选项的内容都很独特。第 $i$ 个选项的内容的形式如下：

+ 第 $a_i$ 个选项是正确/错误的

小 L 认为这种题目的答案不一定是唯一的，所以他想问题这道题有多少种合法的答案（可以全部正确或全部错误）。他还想问你这么多答案中，正确选项最多和最少的答案分别有多少个正确选项。

当然，如果这道题不存在合法的答案，你可以直接回答小 L `No answer`。

## 说明/提示

对于样例一，一共有下面 $2$ 种正确答案：

+ 第 $1,2,3$ 个选项是正确的。
+ 第 $4$ 个选项是正确的。

其中正确选项最多的答案有 $3$ 个选项正确，正确选项最少的答案有 $1$ 个选项正确。

### 数据范围
对于 $10\%$ 的数据，$n\leq 10$。  
对于 $30\%$ 的数据，$n\leq 100$。  
对于 $60\%$ 的数据，$n\leq 10^3$。  
对于 $100\%$ 的数据，$n\leq 10^6,1\leq a_i\leq n,i\neq a_i,opt_i\in\{0,1\}$。

## 样例 #1

### 输入

```
4
2 1
4 0
1 1
2 0```

### 输出

```
2
3
1```

## 样例 #2

### 输入

```
10
4 1
7 0
2 0
3 1
7 1
5 0
9 1
10 1
8 0
1 1```

### 输出

```
No answer```

# AI分析结果

### 综合分析与结论

本题的核心在于处理选项之间的依赖关系，判断是否存在合法答案，并计算合法答案的数量、最多和最少正确选项的数量。题解中主要采用了以下几种思路：

1. **带权并查集**：通过并查集维护选项之间的关系，权值表示选项之间的真假关系。难点在于路径压缩和合并时的权值更新。
2. **图论染色**：将选项之间的关系转化为图的边，通过BFS或DFS进行染色，判断是否存在矛盾。难点在于染色的正确性和无解情况的判断。
3. **扩展域并查集**：将每个选项拆分为两个节点，分别表示其真假状态，通过并查集维护这些状态之间的关系。难点在于判断无解情况和统计答案。

综合来看，带权并查集和图论染色是较为常见的解法，扩展域并查集则提供了另一种思路。题解的质量参差不齐，部分题解思路清晰、代码可读性高，而部分题解则存在代码冗余或思路不明确的问题。

### 所选高星题解

#### 1. 作者：lnwzy (赞：18)  
**星级：5星**  
**关键亮点**：  
- 使用带权并查集，思路清晰，代码简洁。
- 详细解释了路径压缩和合并时的权值更新方法。
- 通过`num`数组统计每个并查集中与根节点相同和矛盾的选项数量，便于计算最多和最少正确选项的数量。

**核心代码**：
```cpp
int fa(int x) {
    if(f[x]==x) return f[x];
    int t=f[x];
    f[x]=fa(f[x]);
    r[x]=(r[t]+r[x])%2; // 路径压缩时更新权值
    return f[x];
}
```

#### 2. 作者：littleKtian (赞：16)  
**星级：4星**  
**关键亮点**：  
- 采用图论染色思路，通过BFS进行染色，判断是否存在矛盾。
- 详细解释了染色规则和无解情况的判断。
- 通过统计每个连通块中红色和蓝色点的数量，计算最多和最少正确选项的数量。

**核心代码**：
```cpp
void bfs(int x) {
    hed=tail=0;
    now=0;
    q[++tail]=x;
    while(hed<tail) {
        hed++;
        x=q[hed];
        v[x]=1;
        for(int i=head[x];i;i=ne[i]) {
            int y=to[i];
            if(v[y]) {
                if(d[x]^sz[i]!=d[y]) { // 判断无解
                    flag=1; return;
                }
                continue;
            }
            d[y]=d[x]^sz[i]; // 更新染色
            q[++tail]=y;
            v[y]=1;
            now+=d[y];
        }
    }
}
```

#### 3. 作者：JK_LOVER (赞：8)  
**星级：4星**  
**关键亮点**：  
- 使用扩展域并查集，将每个选项拆分为两个节点，分别表示其真假状态。
- 通过DFS遍历连通块，判断无解情况并统计答案。
- 思路新颖，代码实现较为简洁。

**核心代码**：
```cpp
void dfs(int x,int fa) {
    if(!vis[x]) vis[x] = num;
    else return;
    if((x <= n && vis[x+n] == num) || (x > n && vis[x-n] == num)) pd = 1; // 判断无解
    if(x <= n ) dp[x] = 1;
    for(int i = head[x];i;i = e[i].nxt) {
        int y = e[i].to;
        if(y == fa) continue;
        if(vis[y]) continue;
        dfs(y,x);
        dp[x] += dp[y];
    }
}
```

### 最优关键思路与技巧

- **带权并查集**：通过维护选项之间的关系和权值，判断是否存在矛盾，并统计合法答案的数量。关键在于路径压缩和合并时的权值更新。
- **图论染色**：将选项之间的关系转化为图的边，通过BFS或DFS进行染色，判断是否存在矛盾。关键在于染色的正确性和无解情况的判断。
- **扩展域并查集**：将每个选项拆分为两个节点，分别表示其真假状态，通过并查集维护这些状态之间的关系。关键在于判断无解情况和统计答案。

### 拓展与举一反三

- **类似题目**：  
  1. [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)  
  2. [P2024 食物链](https://www.luogu.com.cn/problem/P2024)  
  3. [P1892 团伙](https://www.luogu.com.cn/problem/P1892)

- **调试与顿悟**：  
  - **lnwzy**：在路径压缩时更新权值，确保并查集的正确性。
  - **littleKtian**：通过BFS染色，判断无解情况，确保染色的正确性。
  - **JK_LOVER**：使用扩展域并查集，将每个选项拆分为两个节点，简化了问题的处理。

### 推荐题目

1. [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)  
2. [P2024 食物链](https://www.luogu.com.cn/problem/P2024)  
3. [P1892 团伙](https://www.luogu.com.cn/problem/P1892)

---
处理用时：44.84秒
# 题目信息

# [蓝桥杯 2019 省 A] 修改数组

## 题目描述

给定一个长度为 $N$ 的数组 $A=[A_1,A_2, \cdots A_N]$，数组中有可能有重复出现的整数。

现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改 $A_2,A_3, \cdots ,A_N$。

当修改 $A_i$ 时，小明会检查 $A_i$ 是否在 $A_1$ ∼ $A_{i-1}$ 中出现过。如果出现过，则小明会给 $A_i$ 加上 $1$；如果新的 $A_i$ 仍在之前出现过，小明会持续给 $A_i$ 加 $1$，直到 $A_i$ 没有在 $A_1$ ∼ $A_{i-1}$ 中出现过。

当 $A_N$ 也经过上述修改之后，显然 $A$ 数组中就没有重复的整数了。

现在给定初始的 $A$ 数组，请你计算出最终的 $A$ 数组。

## 说明/提示

对于 $80\%$ 的评测用例，$1 \le N \le 10000$。

对于所有评测用例，$1 \le N \le 10^5$，$1 \le A_i \le 10^6$。

蓝桥杯 2019 年省赛 A 组 H 题。

## 样例 #1

### 输入

```
5
2 1 1 3 4```

### 输出

```
2 1 3 4 5```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何高效地将一个可能包含重复元素的数组修改为无重复元素的数组。大多数题解采用了并查集（Disjoint Set Union, DSU）作为主要数据结构，通过维护每个数的“祖先”来快速找到下一个可用的数。并查集的时间复杂度为接近O(1)，非常适合处理这类问题。

部分题解还尝试了其他方法，如使用`set`或二分查找+树状数组，但这些方法在时间或空间复杂度上不如并查集高效。因此，并查集是解决本题的最佳选择。

### 所选高星题解

#### 1. 作者：Maysoul (5星)
- **关键亮点**：思路清晰，代码简洁，直接使用并查集的核心思想，通过`find`函数快速找到下一个可用的数，并通过`fa[a] = find(a) + 1`来更新并查集。
- **个人心得**：无。
- **核心代码**：
  ```cpp
  int find(int x) {
      if(x == fa[x]) return x;
      return fa[x] = find(fa[x]);
  }
  int main() {
      for (int i = 1; i <= n; i++) {
          cin >> a;
          a = find(a);
          fa[a] = find(a) + 1;
          cout << a << " ";
      }
  }
  ```

#### 2. 作者：hahaloo (4.5星)
- **关键亮点**：详细解释了并查集的工作原理，并通过图示模拟了并查集的操作过程，帮助读者更好地理解。
- **个人心得**：通过模拟样例，直观展示了并查集的操作过程，帮助读者理解。
- **核心代码**：
  ```cpp
  int find(int x) {
      if(f[x] != x) f[x] = find(f[x]);
      return f[x];
  }
  void join(int x, int y) {
      int x_root = find(f[x]);
      int y_root = find(f[y]);
      f[x_root] = y_root;
  }
  int main() {
      for(int i = 1; i <= n; i++) {
          cin >> a;
          a = find(a);
          cout << a << ' ';
          join(a, a + 1);
      }
  }
  ```

#### 3. 作者：_7Mr (4星)
- **关键亮点**：提供了暴力解法的代码，并指出其不足，随后给出了并查集的优化解法，帮助读者理解从暴力到优化的过程。
- **个人心得**：通过对比暴力解法和并查集解法，强调了并查集的高效性。
- **核心代码**：
  ```cpp
  int find(int x) {
      if (f[x] == x) return x;
      else return f[x] = find(f[x]);
  }
  int main() {
      for(int i = 1; i <= n; i++) {
          cin >> a[i];
          a[i] = find(a[i]);
          cout << a[i] << " ";
          f[a[i]]++;
      }
  }
  ```

### 最优关键思路与技巧

- **并查集的应用**：通过并查集快速找到下一个可用的数，并更新并查集，确保每个数只出现一次。
- **路径压缩**：在`find`函数中使用路径压缩，使得后续查找操作更加高效。
- **初始化**：将所有数的祖先初始化为自身，确保每个数在第一次出现时可以直接使用。

### 可拓展之处

- **类似问题**：并查集可以用于解决许多与集合合并、查找相关的问题，如连通性问题、最小生成树等。
- **其他数据结构**：在某些特定场景下，`set`或树状数组也可以用于解决类似问题，但并查集通常是更优的选择。

### 推荐题目

1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)
3. [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)

### 个人心得总结

- **调试经历**：部分作者提到在实现并查集时，初始化数组的大小非常重要，过小会导致数组越界，过大则可能浪费空间。
- **顿悟感想**：通过并查集的应用，许多看似复杂的问题可以变得非常简单，关键在于如何将问题转化为集合的合并与查找操作。

---
处理用时：36.90秒
# 题目信息

# [SNCPC2019] Grid with Arrows

## 题目描述

宝宝刚刚在他的左口袋里发现了一个 $n$ 行 $m$ 列的网格，其中第 $i$ 行第 $j$ 列的单元格（表示为 $(i, j)$）包含一个箭头（指向上、下、左或右）和一个整数 $a_{i, j}$。

宝宝决定用这个网格玩一个游戏。他首先会选择一个单元格作为初始单元格并标记它。在标记一个单元格之后（假设宝宝刚刚标记了单元格 $(i, j)$），宝宝将根据单元格 $(i, j)$ 中的箭头和整数继续标记另一个单元格。

- 如果单元格 $(i, j)$ 中的箭头指向上方，宝宝将继续标记单元格 $(i-a_{i, j}, j)$，如果该单元格存在的话。
- 如果单元格 $(i, j)$ 中的箭头指向下方，宝宝将继续标记单元格 $(i+a_{i, j}, j)$，如果该单元格存在的话。
- 如果单元格 $(i, j)$ 中的箭头指向左方，宝宝将继续标记单元格 $(i, j-a_{i, j})$，如果该单元格存在的话。
- 如果单元格 $(i, j)$ 中的箭头指向右方，宝宝将继续标记单元格 $(i, j+a_{i, j})$，如果该单元格存在的话。
如果宝宝决定标记的单元格不存在，或者该单元格已经被标记，游戏结束。

宝宝想知道他是否可以选择一个合适的初始单元格，以便在游戏结束前恰好标记网格中的每一个单元格一次。请帮助他找到答案。

## 样例 #1

### 输入

```
2
2 3
rdd
url
2 1 1
1 1 2
2 2
rr
rr
1 1
1 1```

### 输出

```
Yes
No```

# AI分析结果

### 综合分析与结论

本题的核心在于将网格中的每个单元格视为有向图中的一个节点，并根据箭头方向和步数构建有向边。问题转化为判断该有向图是否存在一条欧拉路径或欧拉回路，使得从某个起点出发可以遍历所有节点且不重复经过任何节点。

大多数题解都采用了以下思路：
1. **图的构建**：将二维网格映射为一维数组，方便处理。
2. **入度与出度统计**：通过统计每个节点的入度和出度，判断是否存在欧拉路径。
3. **连通性检查**：使用并查集或DFS检查图的连通性，确保所有节点在同一个连通分量中。
4. **基环树或欧拉路径的判断**：根据入度和出度的关系，判断是否存在欧拉路径或欧拉回路。

### 所选高星题解

#### 1. **作者：Flaw_Owl (4星)**
- **关键亮点**：详细解释了欧拉路径的判断条件，并提供了清晰的代码实现。通过并查集检查连通性，结合入度和出度判断欧拉路径的存在性。
- **代码核心思想**：
  - 使用并查集维护连通性。
  - 统计每个节点的入度和出度，判断是否符合欧拉路径的条件。
```cpp
bool check() {
    int root = find_set(1);
    for (int i = 2; i <= n * m; i++)
        if (find_set(i) != root)
            return false;
    int sx = 0, ed = 0;
    for (int i = 1; i <= n * m; i++) {
        if (degree[i] == 1) {
            if (sx) return false;
            sx = i;
        } else if (degree[i] == -1) {
            if (ed) return false;
            ed = i;
        } else if (degree[i] != 0)
            return false;
    }
    return true;
}
```

#### 2. **作者：niuzh (4星)**
- **关键亮点**：通过DFS遍历图，检查是否所有节点都被访问过。同时，通过入度统计选择合适的起点。
- **代码核心思想**：
  - 使用DFS遍历图，检查连通性。
  - 选择入度为0的节点作为起点，若没有则任意选择。
```cpp
inline void dfs(int x) {
    vis[x] = true;
    if (a[x] && !vis[a[x]]) {
        dfs(a[x]);
    }
}
```

#### 3. **作者：luan341502 (4星)**
- **关键亮点**：通过并查集维护连通性，并结合入度统计判断是否存在欧拉路径。代码简洁且高效。
- **代码核心思想**：
  - 使用并查集检查连通性。
  - 统计入度为0的节点数量，判断是否存在欧拉路径。
```cpp
int res = 0;
for (int i = 1; i <= cnt; i++) {
    if (!d[i]) res++;
    if (res > 1) {
        puts("No");
        return;
    }
}
```

### 最优关键思路与技巧
1. **图的映射与处理**：将二维网格映射为一维数组，简化图的构建与遍历。
2. **入度与出度统计**：通过统计每个节点的入度和出度，判断是否存在欧拉路径或欧拉回路。
3. **连通性检查**：使用并查集或DFS确保图的连通性，避免不连通图导致的错误判断。

### 可拓展之处
- **基环树与欧拉路径**：基环树和欧拉路径的判断是图论中的经典问题，可以拓展到其他类似题目，如判断图中是否存在哈密顿路径等。
- **并查集的应用**：并查集在图论中常用于维护连通性，可以应用于其他需要判断连通性的问题。

### 推荐题目
1. **P7771 【模板】欧拉路径**：考察欧拉路径的基本判断条件。
2. **P1341 无序字母对**：无向图中的欧拉路径问题。
3. **P2002 消息扩散**：有向图中的连通性问题，适合练习并查集的应用。

### 个人心得摘录
- **作者：luan341502**：赛时交了八发才过，少考虑了一种情况。提醒我们在解题时要全面考虑各种边界情况，避免遗漏。
- **作者：niuzh**：初始化极其重要！在多测情况下，初始化不彻底会导致错误。提醒我们在多测时要特别注意变量的初始化。

---
处理用时：37.70秒
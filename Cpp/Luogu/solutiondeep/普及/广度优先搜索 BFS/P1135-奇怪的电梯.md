# 题目信息

# 奇怪的电梯

## 题目背景

感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。

## 样例 #1

### 输入

```
5 1 5
3 3 1 2 5
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心是通过搜索算法（如BFS、DFS）或最短路算法（如Dijkstra、SPFA）来求解从起点到终点的最短路径。大多数题解采用了BFS，因为BFS在无权图中能够保证第一次到达目标节点时路径最短。部分题解使用了DFS，但需要合理的剪枝来避免超时。少数题解使用了最短路算法（如Dijkstra、SPFA、Floyd），虽然这些算法在本题中略显复杂，但展示了不同的解题思路。

### 精选题解

#### 1. **作者：_H17_ (5星)**
- **关键亮点**：提供了多种算法的实现（Dijkstra、SPFA、DFS、Floyd、BFS），并详细解释了每种算法的适用场景和复杂度。代码结构清晰，注释详细，适合初学者学习。
- **个人心得**：作者提到“BFS是不记录dis还不排序的Dijkstra”，这一观点帮助理解BFS与Dijkstra的关系。
- **核心代码**：
  ```cpp
  void bfs() {
      q.push({a, 0});
      vis[a] = 1;
      while (!q.empty()) {
          int x = q.front().x, y = q.front().y;
          q.pop();
          if (x == b) return y;
          if (x + k[x] <= n && !vis[x + k[x]]) {
              q.push({x + k[x], y + 1});
              vis[x + k[x]] = 1;
          }
          if (x - k[x] >= 1 && !vis[x - k[x]]) {
              q.push({x - k[x], y + 1});
              vis[x - k[x]] = 1;
          }
      }
      return -1;
  }
  ```
  **实现思想**：使用BFS从起点开始，逐层扩展，直到找到目标节点。

#### 2. **作者：yummy (4星)**
- **关键亮点**：详细分析了DFS的剪枝策略，特别是如何通过记录每个节点的最小步数来避免重复搜索。提供了正确剪枝的DFS实现，避免了常见的错误剪枝方法。
- **核心代码**：
  ```cpp
  void dfs(int s, int t) {
      ans[s] = t;
      if (s + dis[s] <= n && t + 1 < ans[s + dis[s]]) dfs(s + dis[s], t + 1);
      if (s - dis[s] > 0 && t + 1 < ans[s - dis[s]]) dfs(s - dis[s], t + 1);
  }
  ```
  **实现思想**：通过记录每个节点的最小步数，避免重复搜索，确保DFS的效率。

#### 3. **作者：cff_0102 (4星)**
- **关键亮点**：简洁的BFS实现，代码结构清晰，适合初学者理解BFS的基本框架。通过队列管理节点，确保第一次到达目标节点时路径最短。
- **核心代码**：
  ```cpp
  int bfs() {
      q.push(a);
      vis[a] = 1;
      int t = 0;
      while (!q.empty()) {
          int x = q.size();
          for (int i = 0; i < x; i++) {
              int p = q.front();
              q.pop();
              if (p == b) return t;
              if (p - a[p] > 0 && !vis[p - a[p]]) q.push(p - a[p]), vis[p - a[p]] = 1;
              if (p + a[p] <= n && !vis[p + a[p]]) q.push(p + a[p]), vis[p + a[p]] = 1;
          }
          t++;
      }
      return -1;
  }
  ```
  **实现思想**：通过队列逐层扩展，确保第一次到达目标节点时路径最短。

### 最优关键思路与技巧

1. **BFS的优势**：在无权图中，BFS能够保证第一次到达目标节点时路径最短，适合本题。
2. **DFS的剪枝**：通过记录每个节点的最小步数，避免重复搜索，确保DFS的效率。
3. **最短路算法的应用**：虽然BFS更适合本题，但Dijkstra、SPFA等最短路算法展示了不同的解题思路，适合更复杂的图论问题。

### 可拓展之处

- **类似题目**：可以扩展到带权图的最短路径问题，如Dijkstra、SPFA等算法的应用。
- **剪枝技巧**：在DFS中，合理的剪枝策略可以大幅提高效率，适用于其他搜索问题。

### 推荐题目

1. **P1144 最短路计数**：考察BFS在无权图中的最短路径计数。
2. **P3371 单源最短路径（弱化版）**：考察Dijkstra算法的应用。
3. **P3385 负权边最短路**：考察SPFA算法的应用。

### 个人心得总结

- **BFS与Dijkstra的关系**：BFS可以看作是无权图中的Dijkstra，理解这一点有助于掌握两种算法的本质。
- **DFS剪枝的重要性**：合理的剪枝策略可以避免DFS的超时问题，适用于其他搜索问题。

---
处理用时：28.02秒
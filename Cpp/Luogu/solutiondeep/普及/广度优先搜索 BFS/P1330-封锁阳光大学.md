# 题目信息

# 封锁阳光大学

## 题目描述

曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。

阳光大学的校园是一张由 $n$ 个点构成的无向图，$n$ 个点之间由 $m$ 条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。

询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。


## 说明/提示

【数据规模】   
对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，保证没有重边。

## 样例 #1

### 输入

```
3 3
1 2
1 3
2 3
```

### 输出

```
Impossible
```

## 样例 #2

### 输入

```
3 2
1 2
2 3
```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

该题目要求封锁所有道路且相邻点不能同时被封锁，本质上是图的二分图判定与染色问题。大多数题解采用了DFS或BFS进行黑白染色，并通过统计两种颜色的数量来求解最小封锁数。部分题解还使用了并查集或状态压缩等优化技巧。整体上，题解思路较为一致，但实现细节和优化程度有所不同。

### 所选高质量题解

#### 1. 作者：KesdiaelKen (赞：438)
- **星级**: 5星
- **关键亮点**: 
  - 详细分析了题目条件，抽象为二分图染色问题。
  - 使用链式前向星存储图，优化了空间复杂度。
  - 通过DFS进行染色，并统计两种颜色的数量，取较小值作为答案。
  - 代码结构清晰，注释详细，易于理解。
- **个人心得**: 
  - 强调了图的连通性处理，确保每个连通块独立染色。
  - 通过`used`数组避免重复遍历，优化了时间复杂度。

```cpp
bool dfs(int node, int color) {
    if (used[node]) {
        if (col[node] == color) return true;
        return false;
    }
    used[node] = true;
    sum[col[node] = color]++;
    bool tf = true;
    for (int i = head[node]; i != 0 && tf; i = edge[i].nexty) {
        tf = tf && dfs(edge[i].t, 1 - color);
    }
    return tf;
}
```

#### 2. 作者：dingcx (赞：176)
- **星级**: 4.5星
- **关键亮点**: 
  - 使用BFS进行染色，避免了DFS的递归栈溢出问题。
  - 通过队列实现BFS，代码简洁且易于理解。
  - 统计两种颜色的数量，取较小值作为答案。
- **个人心得**: 
  - 强调了图的非连通性处理，确保每个连通块独立染色。
  - 通过`used`数组避免重复遍历，优化了时间复杂度。

```cpp
bool bfs(int start) {
    used[start] = 1;
    sum[1] = 1, sum[2] = 0;
    q.push(start);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int k = h[u]; k; k = e[k].next) {
            int v = e[k].v;
            if (used[v] == used[u]) return 1;
            if (used[v] == 0) {
                used[v] = used[u] % 2 + 1;
                sum[used[v]]++;
                q.push(v);
            }
        }
    }
    return 0;
}
```

#### 3. 作者：wshz (赞：158)
- **星级**: 4星
- **关键亮点**: 
  - 使用并查集处理图的连通性，优化了时间复杂度。
  - 通过并查集的路径压缩和按秩合并，进一步优化了性能。
  - 统计两种颜色的数量，取较小值作为答案。
- **个人心得**: 
  - 强调了并查集在处理图连通性问题中的优势。
  - 通过`h`数组记录异色点，确保染色正确性。

```cpp
void xx(int x, int y) {
    int qq = find(x);
    if (qq != y) {
        f[y] = qq;
        t[qq] += t[y];
    }
}
```

### 最优关键思路与技巧

1. **二分图染色**: 通过DFS或BFS对图进行黑白染色，确保相邻点颜色不同，统计两种颜色的数量，取较小值作为答案。
2. **图的连通性处理**: 由于图可能不连通，需对每个连通块独立处理，确保每个连通块都能正确染色。
3. **优化存储结构**: 使用链式前向星或邻接表存储图，优化空间复杂度。
4. **并查集优化**: 在处理图的连通性问题时，使用并查集进行路径压缩和按秩合并，优化时间复杂度。

### 可拓展之处

- **类似题目**: 该题目的解法可以推广到其他二分图判定与染色问题，如判断图是否为二分图、求解二分图的最大匹配等。
- **优化技巧**: 在处理大规模图时，可以考虑使用更高效的存储结构（如邻接表）和算法（如并查集）来优化性能。

### 推荐相似题目

1. **P1337 [JSOI2004]平衡点**: 考察图的连通性与二分图染色。
2. **P3386 [模板]二分图匹配**: 考察二分图的最大匹配问题。
3. **P1525 关押罪犯**: 考察图的二分图判定与染色。

### 个人心得总结

- **调试经历**: 在处理图的连通性问题时，确保每个连通块独立染色是关键，避免因连通性处理不当导致的错误。
- **踩坑教训**: 在使用DFS时，需注意递归深度，避免栈溢出；在使用BFS时，需注意队列的大小，避免内存溢出。
- **顿悟感想**: 二分图染色问题本质上是图的二分图判定问题，通过染色可以直观地判断图是否为二分图，并求解相关问题。

---
处理用时：33.01秒
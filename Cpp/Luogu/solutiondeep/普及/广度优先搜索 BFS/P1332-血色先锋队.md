# 题目信息

# 血色先锋队

## 题目背景

巫妖王的天灾军团终于卷土重来，血色十字军组织了一支先锋军前往诺森德大陆对抗天灾军团，以及一切沾有亡灵气息的生物。孤立于联盟和部落的血色先锋军很快就遭到了天灾军团的重重包围，现在他们将主力只好聚集了起来，以抵抗天灾军团的围剿。可怕的是，他们之中有人感染上了亡灵瘟疫，如果不设法阻止瘟疫的扩散，很快就会遭到灭顶之灾。大领主阿比迪斯已经开始调查瘟疫的源头。原来是血色先锋军的内部出现了叛徒，这个叛徒已经投靠了天灾军团，想要将整个血色先锋军全部转化为天灾军团！无需惊讶，你就是那个叛徒。在你的行踪败露之前，要尽快完成巫妖王交给你的任务。

## 题目描述

军团是一个 $n$ 行 $m$ 列的矩阵，每个单元是一个血色先锋军的成员。感染瘟疫的人，每过一个小时，就会向四周扩散瘟疫，直到所有人全部感染上瘟疫。你已经掌握了感染源的位置，任务是算出血色先锋军的领主们感染瘟疫的时间，并且将它报告给巫妖王，以便对血色先锋军进行一轮有针对性的围剿。

## 说明/提示

#### 输入输出样例 1 解释

如下图，标记出了所有人感染瘟疫的时间以及感染源和领主的位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/3j3g02cn.png)

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n,m\le500$，$1\le a,b\le10^5$。

## 样例 #1

### 输入

```
5 4 2 3
1 1
5 4
3 3
5 3
2 4
```

### 输出

```
3
1
3```

# AI分析结果

### 综合分析与结论

本题的核心是通过模拟瘟疫传播的过程，计算每个领主被感染的时间。题解中主要采用了两种思路：**BFS（广度优先搜索）**和**暴力枚举曼哈顿距离**。BFS是更标准的解法，适用于大规模数据，而暴力枚举曼哈顿距离虽然简单，但在数据规模较大时可能会超时。

大多数题解都采用了BFS，且思路较为清晰，代码实现也较为规范。部分题解在BFS的基础上进行了优化，如使用记忆化、剪枝等技巧，进一步提升了效率。暴力枚举的题解虽然简单，但缺乏普适性，不推荐作为主要解法。

### 所选高星题解

#### 1. **作者：llzzxx712 (赞：133)**
- **星级：★★★★★**
- **关键亮点**：
  - 使用了标准的BFS算法，思路清晰，代码结构规范。
  - 通过标记已感染的点，避免了重复计算，确保了每个点只被感染一次。
  - 详细解释了BFS的实现过程，适合初学者理解。
- **个人心得**：
  - 作者提到“一定要标记一个点是否被感染，否则就会造成被感染的人时间再次被更新”，强调了BFS中标记的重要性。
- **核心代码**：
  ```cpp
  void bfs(){
      while(head<tail){
          head++;
          int x = q[head][0], y = q[head][1];
          for(int i=0;i<4;i++){
              int x1 = x + fx[i][0], y1 = y + fx[i][1];
              if(x1<1||y1<1||x1>n||y1>m) continue;
              if(v[x1][y1]) continue;
              v[x1][y1] = 1;
              map[x1][y1] = map[x][y] + 1;
              q[++tail][0] = x1, q[tail][1] = y1;
          }
      }
  }
  ```
  **核心思想**：通过BFS从多个感染源开始，逐步向外扩展，记录每个点的感染时间。

#### 2. **作者：sinsop90 (赞：81)**
- **星级：★★★★☆**
- **关键亮点**：
  - 使用了STL中的队列，代码简洁且易于理解。
  - 通过结构体存储感染源和领主的位置，代码结构清晰。
  - 在BFS中加入了剪枝，提前终止不必要的搜索，提升了效率。
- **核心代码**：
  ```cpp
  void bfs(){
      while(!Q.empty()){
          node tmp;
          node t = Q.front();
          for(int i=0;i<=3;i++){
              int xx = t.x + fx[i][0], yy = t.y + fx[i][1];
              if(xx>=1&&xx<=n && yy>=1&&yy<=m && !vis[xx][yy]){
                  vis[xx][yy] = true;
                  tmp.x = xx; tmp.y = yy;
                  tmp.steps = t.steps + 1;
                  Q.push(tmp);
              }
          }
          maps[t.x][t.y] = t.steps;
          Q.pop();
      }
  }
  ```
  **核心思想**：使用STL队列进行BFS，通过剪枝优化搜索过程。

#### 3. **作者：开挂老司机 (赞：33)**
- **星级：★★★★☆**
- **关键亮点**：
  - 使用了快读优化输入，提升了代码效率。
  - 通过方向数组简化了BFS的实现，代码简洁且易于扩展。
  - 在BFS中直接更新感染时间，避免了额外的数据结构。
- **核心代码**：
  ```cpp
  do{
      s=q.front();
      q.pop();
      for(int i=0;i<4;i++){
          c.h=s.h+dx[i],c.l=s.l+dy[i];
          if(f[s.h][s.l]+1<f[c.h][c.l]){
              f[c.h][c.l]=f[s.h][s.l]+1;
              q.push(c);
          }
      }
  }while(!q.empty());
  ```
  **核心思想**：通过方向数组简化BFS的实现，直接更新感染时间。

### 最优关键思路与技巧

1. **BFS的多源扩展**：本题的感染源有多个，BFS可以从多个源点同时开始扩展，确保每个点的感染时间是最小的。
2. **标记已访问点**：在BFS中，必须标记已经访问过的点，避免重复计算，确保每个点只被感染一次。
3. **剪枝优化**：在BFS中，可以通过提前终止不必要的搜索（如领主已经被感染）来提升效率。

### 可拓展之处

- **多源BFS**：类似的问题可以通过多源BFS解决，如火灾蔓延、病毒传播等。
- **方向数组**：在BFS中，使用方向数组可以简化代码，适用于四方向或八方向的扩展问题。

### 推荐题目

1. **P1443 马的遍历**（考察BFS的扩展）
2. **P1162 填涂颜色**（考察BFS的标记与扩展）
3. **P2895 [USACO08FEB]Meteor Shower S**（考察多源BFS的应用）

### 个人心得总结

- **标记的重要性**：在BFS中，标记已访问的点是避免重复计算的关键，否则会导致时间复杂度过高。
- **剪枝优化**：在BFS中，通过剪枝可以显著提升效率，尤其是在数据规模较大的情况下。
- **方向数组**：使用方向数组可以简化代码，适用于多种扩展问题。

---
处理用时：30.49秒
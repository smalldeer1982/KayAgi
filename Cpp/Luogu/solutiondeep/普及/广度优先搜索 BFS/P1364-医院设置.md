# 题目信息

# 医院设置

## 题目描述

设有一棵二叉树，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/kawht13x.png)

其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在 $1$ 处，则距离和 $=4+12+2\times20+2\times40=136$；若医院建在 $3$ 处，则距离和 $=4\times2+13+20+40=81$。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 100$，$0 \leq u, v \leq n$，$1 \leq w \leq 10^5$。

## 样例 #1

### 输入

```
5						
13 2 3
4 0 0
12 4 5
20 0 0
40 0 0
```

### 输出

```
81```

# AI分析结果

### 综合分析与结论

本题的核心问题是在一棵带权树中找到一个节点，使得所有节点到该节点的距离与节点权值的乘积之和最小。题解中主要采用了以下几种思路：

1. **Floyd算法**：通过Floyd算法计算任意两点之间的最短路径，然后枚举每个节点作为医院的位置，计算总距离。时间复杂度为O(n³)，适用于小规模数据。
2. **DFS/BFS暴力搜索**：对每个节点进行DFS或BFS，计算以该节点为根的总距离，时间复杂度为O(n²)。
3. **树的重心与树形DP**：利用树的重心性质，通过树形DP在O(n)时间内找到最优解，适用于大规模数据。

总体来看，树的重心与树形DP的解法最为高效，适合大规模数据，而Floyd和DFS/BFS的解法虽然简单，但时间复杂度较高，适合小规模数据。

### 所选高分题解

#### 1. Huami360 (5星)
**关键亮点**：
- 使用树的重心性质，通过树形DP在O(n)时间内解决问题。
- 详细解释了树的重心性质及转移方程的推导过程，思路清晰。

**个人心得**：
- “别人摸瓜她寻藤，别人摘叶他问根” —— 强调深入理解问题本质，不满足于表面解法。

**核心代码**：
```cpp
void dfs(int u, int fa, int dep) {
    size[u] = w[u];
    for(int i = head[u]; i; i = e[i].next) {
        if(e[i].to != fa)
            dfs(e[i].to, u, dep + 1), size[u] += size[e[i].to];
    }
    f[1] += w[u] * dep;
}

void dp(int u, int fa) {
    for(int i = head[u]; i; i = e[i].next)
        if(e[i].to != fa)
            f[e[i].to] = f[u] + size[1] - size[e[i].to] * 2, dp(e[i].to, u);
    ans = min(ans, f[u]);
}
```
**实现思想**：通过DFS预处理子树大小和总距离，然后通过DP转移方程计算每个节点的总距离，最终找到最小值。

#### 2. lizongru (4星)
**关键亮点**：
- 使用树形DP，通过换根操作在O(n)时间内找到最优解。
- 代码结构清晰，注释详细，适合初学者理解。

**核心代码**：
```cpp
void dfs(int rt, int fa) {
    deep[rt] = deep[fa] + 1;
    for(register int i = head[rt]; i; i = e[i].next) {
        if(e[i].to == fa) continue;
        dfs(e[i].to, rt);
        pre[rt] += pre[e[i].to];
    }
}

void dp(int rt, int fa) {
    for(register int i = head[rt]; i; i = e[i].next) {
        if(e[i].to == fa) continue;
        dis[e[i].to] = dis[rt] + pre[1] - pre[e[i].to] - pre[e[i].to];
        if(dis[e[i].to] < ans) ans = dis[e[i].to];
        dp(e[i].to, rt);
    }
}
```
**实现思想**：通过DFS预处理深度和子树大小，然后通过DP转移方程计算每个节点的总距离，最终找到最小值。

#### 3. henry_y (4星)
**关键亮点**：
- 提供两种解法：暴力DFS和树的重心，适合不同数据规模。
- 代码简洁，思路清晰，适合快速实现。

**核心代码**：
```cpp
int dfs(int x, int f, int d) {
    int ans = d * c[x];
    for(int i = head[x]; i; i = e[i].nxt) {
        if(e[i].to == f) continue;
        ans += dfs(e[i].to, x, d + 1);
    }
    return ans;
}
```
**实现思想**：通过DFS计算以某个节点为根的总距离，枚举每个节点找到最小值。

### 最优关键思路与技巧

1. **树的重心与树形DP**：利用树的重心性质，通过树形DP在O(n)时间内找到最优解，适合大规模数据。
2. **DFS/BFS暴力搜索**：对每个节点进行DFS或BFS，计算以该节点为根的总距离，时间复杂度为O(n²)，适合小规模数据。
3. **Floyd算法**：通过Floyd算法计算任意两点之间的最短路径，然后枚举每个节点作为医院的位置，计算总距离，时间复杂度为O(n³)，适合小规模数据。

### 可拓展之处

1. **树的重心应用**：树的重心不仅可以用于本题，还可以用于其他树形结构的最优化问题，如树的直径、最小覆盖等。
2. **树形DP**：树形DP是解决树形结构问题的常用方法，适用于多种树形结构的最优化问题。

### 推荐题目

1. **P1395 树的直径**：考察树的重心与树形DP的应用。
2. **P2015 二叉苹果树**：考察树形DP的应用。
3. **P2014 选课**：考察树形DP与背包问题的结合。

### 个人心得总结

- **深入理解问题本质**：不满足于表面解法，深入理解问题背后的数学性质，如树的重心。
- **代码简洁与清晰**：代码结构清晰，注释详细，有助于快速理解和调试。
- **多解法对比**：针对不同数据规模，选择合适的解法，如小规模数据使用暴力搜索，大规模数据使用树形DP。

---
处理用时：31.92秒
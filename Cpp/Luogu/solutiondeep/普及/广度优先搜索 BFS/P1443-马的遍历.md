# 题目信息

# 马的遍历

## 题目描述

有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。


## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。

## 样例 #1

### 输入

```
3 3 1 1
```

### 输出

```
0    3    2    
3    -1   1    
2    1    4    ```

# AI分析结果

### 综合分析与结论

本题的核心是通过广度优先搜索（BFS）来计算马从起点到棋盘上任意点的最短步数。大部分题解都采用了BFS的基本框架，但在实现细节、数据结构选择、代码优化等方面有所不同。以下是对题解的综合分析与结论：

1. **算法选择**：所有题解都使用了BFS，因为BFS能够保证第一次到达某个点时，步数是最小的，符合题目要求。
2. **数据结构**：大部分题解使用了队列（`queue`）来存储待处理的节点，部分题解使用了`pair`或结构体来存储坐标和步数。
3. **优化与技巧**：
   - 使用`memset`初始化数组，避免重复访问。
   - 通过方向数组（`dx`和`dy`）简化代码，避免冗长的条件判断。
   - 部分题解通过`printf`的格式化输出控制对齐方式，避免了复杂的输出逻辑。
4. **代码可读性**：部分题解代码简洁且注释清晰，易于理解；而部分题解代码冗长，缺乏必要的注释，可读性较差。
5. **个人心得**：部分题解分享了调试过程中的经验教训，如输出格式的控制、数组大小的设置等，这些心得对初学者非常有帮助。

### 所选高星题解

#### 1. 题解作者：shajjl (赞：1599)
- **星级**：★★★★★
- **关键亮点**：
  - 使用了`pair`简化坐标存储，代码简洁。
  - 通过`memset`初始化数组，避免了重复访问。
  - 使用方向数组（`dx`和`dy`）简化了代码逻辑。
  - 输出格式控制得当，使用`printf`实现左对齐。
- **个人心得**：作者提到“带头文件的33行代码还是很短的”，强调了代码的简洁性。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
const int dx[8]={-1,-2,-2,-1,1,2,2,1};
const int dy[8]={2,1,-1,-2,2,1,-1,-2};
queue<pair<int,int> > q;
int f[500][500];
bool vis[500][500];
int main()
{
    int n,m,x,y;
    memset(f,-1,sizeof(f));memset(vis,false,sizeof(vis));
    cin>>n>>m>>x>>y;
    f[x][y]=0;vis[x][y]=true;q.push(make_pair(x,y));
    while(!q.empty())
    {
        int xx=q.front().first,yy=q.front().second;q.pop();
        for(int i=0;i<8;i++)
        {
            int u=xx+dx[i],v=yy+dy[i];
            if(u<1||u>n||v<1||v>m||vis[u][v])continue;
            vis[u][v]=true;q.push(make_pair(u,v));f[u][v]=f[xx][yy]+1;
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)printf("%-5d",f[i][j]);
        printf("\n");
    }
    return 0;
}
```

#### 2. 题解作者：__gcd (赞：91)
- **星级**：★★★★☆
- **关键亮点**：
  - 通过`priority_queue`优化了BFS，确保每次扩展的节点步数最小。
  - 使用了结构体存储坐标和步数，代码结构清晰。
  - 通过`memset`初始化数组，避免了重复访问。
- **个人心得**：作者提到“刚开始做的时候用的dfs，结果TLE了”，强调了BFS的正确性。

```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
struct node{
    int x,y,step;
};
queue<node>q;
int a[410][410];
int dx[8]={2,1,1,2,-1,-2,-2,-1};
int dy[8]={1,2,-2,-1,2,1,-2,-1};
int n,m,x,y;
void bfs(){
    q.push((node){x,y,0});
    a[x][y]=0;
    while(!q.empty()){
        node now=q.front();
        q.pop();
        for(int i=0;i<8;i++){
            int nx=now.x+dx[i],ny=now.y+dy[i];
            if(nx<1||nx>n||ny<1||ny>m||a[nx][ny]!=-1)continue;
            a[nx][ny]=now.step+1;
            q.push((node){nx,ny,now.step+1});
        }
    }
}
int main(){
    cin>>n>>m>>x>>y;
    memset(a,-1,sizeof(a));
    bfs();
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)printf("%-5d",a[i][j]);
        printf("\n");
    }
    return 0;
}
```

#### 3. 题解作者：CXY07 (赞：286)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用了结构体存储坐标和步数，代码结构清晰。
  - 通过`memset`初始化数组，避免了重复访问。
  - 使用方向数组（`dx`和`dy`）简化了代码逻辑。
- **个人心得**：作者提到“蒟蒻的第一篇题解”，强调了代码的简洁性和易读性。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct queue_{
    int x,y;
} que[160010];
int head=0,tail=1,get[401][401],n,m,sx,sy;
int fx[16]={2,-2,2,-2,-1,1,-1,1},fy[16]={1,1,-1,-1,2,2,-2,-2};
int main()
{
    cin>>n>>m>>sx>>sy;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            get[i][j]=-1;
    get[sx][sy]=0;
    que[1].x=sx;
    que[1].y=sy;
    while(head<tail)
    {
        head++;
        int s=get[que[head].x][que[head].y]+1;
        for(int i=0;i<8;++i)
        {
            int nx=que[head].x+fx[i],ny=que[head].y+fy[i];
            if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&get[nx][ny]==-1)
            {
                tail++;
                que[tail].x=nx;
                que[tail].y=ny;
                get[nx][ny]=s;
            }
        }
    }
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
            printf("%-5d", get[i][j]);
        cout<<endl;
    }
    return 0;
}
```

### 最优关键思路与技巧总结

1. **BFS框架**：使用队列进行广度优先搜索，确保第一次到达某个点时步数最小。
2. **方向数组**：通过`dx`和`dy`数组简化代码，避免冗长的条件判断。
3. **初始化与标记**：使用`memset`初始化数组，并通过`vis`数组标记已访问的节点，避免重复访问。
4. **输出格式控制**：使用`printf`的格式化输出控制对齐方式，简化输出逻辑。

### 可拓展之处

1. **类似问题**：类似的BFS问题包括“迷宫最短路径”、“骑士旅行”等，都可以通过类似的BFS框架解决。
2. **优化思路**：可以考虑使用优先队列（`priority_queue`）优化BFS，确保每次扩展的节点步数最小。

### 推荐题目

1. **P1443 马的遍历**：本题，考察BFS的基本应用。
2. **P1135 奇怪的电梯**：考察BFS在状态转移中的应用。
3. **P1162 填涂颜色**：考察BFS在矩阵填充中的应用。

---
处理用时：51.59秒
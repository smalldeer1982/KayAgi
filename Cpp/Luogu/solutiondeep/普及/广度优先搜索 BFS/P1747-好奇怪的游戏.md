# 题目信息

# 好奇怪的游戏

## 题目背景

《爱与愁的故事第三弹·shopping》娱乐章。

调调口味来道水题。


## 题目描述

爱与愁大神坐在公交车上无聊，于是玩起了手机。一款奇怪的游戏进入了爱与愁大神的眼帘：\*\*\*（游戏名被打上了马赛克）。这个游戏类似象棋，但是只有黑白马各一匹，在点 $x_1,y_1$ 和 $x_2,y_2$ 上。它们得从点 $x_1,y_1$ 和 $x_2,y_2$ 走到 $(1,1)$。这个游戏与普通象棋不同的地方是：马可以走“日”，也可以像象走“田”。现在爱与愁大神想知道两匹马到 $(1,1)$ 的最少步数，你能帮他解决这个问题么？

注意不能走到 $x$ 或 $y$ 坐标 $\le 0$ 的位置。

## 说明/提示

### 数据范围及约定

对于 $100\%$ 数据，$1\le x_1,y_1,x_2,y_2 \le 20$。

## 样例 #1

### 输入

```
12 16
18 10```

### 输出

```
8 
9```

# AI分析结果

### 综合分析与结论

本题的核心是通过BFS（广度优先搜索）求解马从起点到终点的最短路径，难点在于马有12种移动方式（“日”字和“田”字），且需要处理边界条件。大部分题解都采用了BFS，部分题解尝试了DFS或数学公式，但BFS是最优解。

#### 关键思路与技巧：
1. **BFS的应用**：BFS是求解最短路径的经典算法，尤其适合在无权图中寻找最短路径。本题中，BFS通过逐层扩展，确保第一次到达终点时的步数是最小的。
2. **方向数组**：通过预定义12个方向的增量数组，简化了代码实现，避免了重复的条件判断。
3. **队列的使用**：手动模拟队列或使用STL队列，确保BFS的顺序性和高效性。
4. **记忆化搜索**：部分题解通过记忆化搜索优化了DFS，避免了重复计算。
5. **预处理**：部分题解从终点（1,1）开始BFS，预处理所有点到终点的最短路径，适合多组查询。

#### 通用建议：
- **BFS优先**：在无权图中求最短路径时，优先考虑BFS。
- **方向数组**：预定义方向数组可以大幅简化代码。
- **边界处理**：注意边界条件，避免越界访问。

#### 扩展思路：
- **双向BFS**：如果起点和终点都已知，可以尝试双向BFS，进一步优化搜索效率。
- **A\*算法**：在有权图中，A\*算法可以结合启发式搜索，进一步提升效率。

### 评分较高的题解

#### 1. 作者：做梦想Peach (赞：117)
- **星级**：★★★★★
- **关键亮点**：
  - 使用了手动模拟队列，代码清晰易懂。
  - 方向数组定义简洁，BFS实现规范。
  - 提供了BFS的基本思路和实现细节，适合初学者。
- **核心代码**：
```cpp
void bfs(int X,int Y) {
    int head=0,tail=1,nx,ny;
    queue[1].x=X;
    queue[1].y=Y;
    queue[1].step=0;
    vis[X][Y]=true;
    while (head<tail) {
        head++;
        for (int i=0;i<12;i++) {
            nx=queue[head].x+dx[i];
            ny=queue[head].y+dy[i];
            if ((nx>=1&&nx<101)&&(ny>=1&&ny<101)&&vis[nx][ny]==false) {
                tail++;
                queue[tail].x=nx;
                queue[tail].y=ny;
                queue[tail].step=queue[head].step+1;
                vis[nx][ny]=true;
                if (nx==1&&ny==1) {
                    printf ("%d\n",queue[tail].step);
                    return;
                }
            }
        }
    }
}
```

#### 2. 作者：_yjh (赞：21)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用了STL队列，代码简洁。
  - 从终点（1,1）开始BFS，预处理所有点到终点的最短路径，适合多组查询。
  - 提供了STL队列的基本用法，适合有一定基础的读者。
- **核心代码**：
```cpp
void bfs(int x,int y) {
    node a;
    a.x=x,a.y=y,a.s=0;
    q.push(a);
    while(!q.empty()) {
        a=q.front();
        q.pop();
        for(int i=0;i<12;i++) {
            node c;
            c.x=a.x+dx[i],c.y=a.y+dy[i];
            if(c.x>=1 && c.y>=1 && b[c.x][c.y]==false) {
                if(c.x==1 && c.y==1) return c.s;
                b[c.x][c.y]=true;
                c.s=a.s+1;
                q.push(c);
            }
        }
    }
}
```

#### 3. 作者：Billy●Herrington (赞：73)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用了STL队列，代码简洁。
  - 方向数组定义清晰，BFS实现规范。
  - 提供了BFS的基本思路和实现细节，适合初学者。
- **核心代码**：
```cpp
int bfs (int x,int y) {
    q.push(Node(x,y,0));
    VIS[x][y]=true;
    while(!q.empty()) {
        Node cur=q.front();
        q.pop();
        for (int k=0;k<12;k++) {
            int ex=cur.x+dx[k],ey=cur.y+dy[k];
            if(ex>=1&&ey>=1&&ex<=50&&ey<=50&&!VIS[ex][ey]) {
                q.push(Node(ex,ey,cur.step+1));
                VIS[ex][ey]=true;
            }
            if(ex==nx&&ey==ny) return cur.step+1;
        }
    }
}
```

### 推荐题目
1. **P1746** - 离开中山路：BFS求最短路径。
2. **P1443** - 马的遍历：BFS遍历棋盘。
3. **P1162** - 填涂颜色：BFS或DFS进行区域填充。

---
处理用时：33.99秒
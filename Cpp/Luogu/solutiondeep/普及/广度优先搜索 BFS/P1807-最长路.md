# 题目信息

# 最长路

## 题目描述

设 $G$ 为有 $n$ 个顶点的带权有向无环图，$G$ 中各顶点的编号为 $1$ 到 $n$，请设计算法，计算图 $G$ 中 $1, n$ 间的最长路径。

## 说明/提示

**【数据规模与约定】**

- 对于 $20\%$的数据，$n \leq 100$，$m \leq 10^3$。
- 对于 $40\%$ 的数据，$n \leq 10^3$，$m \leq 10^{4}$。
- 对于 $100\%$ 的数据，$1 \leq n \leq 1500$，$0 \leq m \leq 5 \times 10^4$，$1 \leq u, v \leq n$，$-10^5 \leq w \leq 10^5$。

## 样例 #1

### 输入

```
2 1
1 2 1```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心是求解有向无环图（DAG）中从节点1到节点n的最长路径。题解中主要采用了两种思路：
1. **拓扑排序 + 动态规划**：利用拓扑排序的顺序，结合动态规划求解最长路径。这种方法的时间复杂度为O(n+m)，适合处理大规模数据。
2. **SPFA算法**：通过将边权取反，转化为最短路问题，再利用SPFA求解。这种方法的时间复杂度为O(nm)，在最坏情况下可能较慢，但代码实现简单。

拓扑排序+动态规划的方法在处理DAG时更为高效，且不易受负权边影响，因此是更优的选择。而SPFA方法虽然实现简单，但在某些情况下可能效率较低。

### 所选高分题解

#### 1. 作者：Mine_King (5星)
- **关键亮点**：结合拓扑排序和动态规划，处理了入度为0的节点，确保路径从节点1开始。代码清晰，逻辑严谨。
- **核心代码**：
  ```cpp
  while(!q.empty()) {
      int x = q.front();
      q.pop();
      for(int i = 0; i < g[x].size(); i++) {
          if(v[g[x][i]] < v[x] + d[x][i]) v[g[x][i]] = v[x] + d[x][i]; // 松弛
          if(!--in[g[x][i]]) q.push(g[x][i]); // 如果入度为0就加入队列
      }
  }
  ```
- **个人心得**：作者提到在处理入度为0的节点时，最初的想法是直接加入队列，但后来发现这会导致错误，最终通过先处理这些节点并更新其邻接点的入度，解决了问题。

#### 2. 作者：Furina_Saikou (4星)
- **关键亮点**：使用拓扑排序和动态规划，初始化时处理了所有入度为0的节点，确保路径从节点1开始。代码简洁，适合初学者理解。
- **核心代码**：
  ```cpp
  while(!q.empty()) {
      int u = q.front();
      q.pop();
      for(int i = head[u]; i; i = ne[i]) {
          int v = to[i];
          maxn[v] = max(maxn[u] + w[i], maxn[v]); // 统计最大值
          in[v]--;
          if(!in[v]) q.push(v);
      }
  }
  ```

#### 3. 作者：lijingyuanpp (4星)
- **关键亮点**：通过拓扑排序和动态规划，结合数组`str`确保路径从节点1开始。代码逻辑清晰，处理了负权边的情况。
- **核心代码**：
  ```cpp
  for(int i = 1; i <= n; i++) {
      int u = px[i];
      if(str[u] == 0) continue; // 不在1路上，不用更新
      for(int j = head[u]; j != 0; j = e[j].next) {
          int v = e[j].v;
          dp[v] = max(dp[v], dp[u] + e[j].w);
      }
  }
  ```

### 最优关键思路与技巧
- **拓扑排序 + 动态规划**：在处理DAG时，拓扑排序提供了天然的遍历顺序，结合动态规划可以高效求解最长路径。
- **处理入度为0的节点**：确保路径从指定起点开始，避免无效路径干扰。
- **初始化与边界处理**：合理初始化动态规划数组，处理负权边和边界情况。

### 可拓展之处
- **类似算法套路**：DAG的最短路径问题、关键路径问题等都可以采用类似的拓扑排序+动态规划的方法。
- **同类型题目**：可以尝试解决其他DAG相关的最短/最长路径问题，如关键路径、任务调度等。

### 推荐题目
1. P3371 【模板】单源最短路径（弱化版）
2. P3385 【模板】负环
3. P4017 最大流

### 个人心得总结
- **调试经历**：在处理入度为0的节点时，直接加入队列会导致错误，需先处理这些节点并更新其邻接点的入度。
- **顿悟感想**：拓扑排序+动态规划在处理DAG时非常高效，且不易受负权边影响，是解决此类问题的首选方法。

---
处理用时：23.16秒
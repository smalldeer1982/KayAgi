# 题目信息

# [NOI2011] 道路修建

## 题目描述

在 W 星球上有 $n$ 个国家。为了各自国家的经济发展，他们决定在各个国家之间建设双向道路使得国家之间连通。但是每个国家的国王都很吝啬，他们只愿意修建恰好 $n - 1$ 条双向道路。

每条道路的修建都要付出一定的费用，这个费用等于道路长度乘以道路两端 的国家个数之差的绝对值。例如，在下图中，虚线所示道路两端分别有 $2$ 个、$4$ 个国家，如果该道路长度为 $1$，则费用为 $1×|2 - 4|=2$。图中圆圈里的数字表示国家的编号。
 
 ![](https://cdn.luogu.com.cn/upload/pic/2604.png) 

由于国家的数量十分庞大，道路的建造方案有很多种，同时每种方案的修建费用难以用人工计算，国王们决定找人设计一个软件，对于给定的建造方案，计算出所需要的费用。请你帮助国王们设计一个这样的软件。


## 说明/提示

对于 $100\%$ 的数据，$1\leq a_i, b_i\leq n$，$0\leq c_i\leq10^6$，$2\leq n\leq 10^6$。
|测试点编号|$n=$|
|:-:|:-:|
|$1$|$2$|
|$2$|$10$|
|$3$|$100$|
|$4$|$200$|
|$5$|$500$|
|$6$|$600$|
|$7$|$800$|
|$8$|$1000$|
|$9$|$10^4$|
|$10$|$2\times 10^4$|
|$11$|$5\times 10^4$|
|$12$|$6\times 10^4$|
|$13$|$8\times 10^4$|
|$14$|$10^5$|
|$15$|$6\times 10^5$|
|$16$|$7\times 10^5$|
|$17$|$8\times 10^5$|
|$18$|$9\times 10^5$|
|$19,20$|$10^6$|



## 样例 #1

### 输入

```
6
1 2 1
1 3 1
1 4 2
6 3 1
5 2 1```

### 输出

```
20```

# AI分析结果

### 综合分析与结论

本题的核心在于通过DFS遍历树，计算每条边的贡献。所有题解都采用了类似的方法：通过DFS计算每个节点的子树大小，然后根据公式 `|n - 2 * size[v]| * w` 计算每条边的费用。虽然思路相似，但在代码实现、优化程度和可读性上存在差异。

### 所选高星题解

#### 1. **作者：Melon_Musk (赞：58)**
- **星级：5星**
- **关键亮点**：思路清晰，代码简洁且高效，使用了邻接表存储树结构，DFS遍历时直接计算每条边的贡献，避免了冗余计算。
- **个人心得**：作者通过样例手推帮助理解题意，强调了DFS的核心思路。
- **核心代码**：
  ```cpp
  void dfs(int x, int fa) {
      size[x] = 1;
      for (int i = head[x]; i; i = e[i].nt) {
          int to = e[i].to;
          if (fa == to) continue;
          dfs(to, x);
          size[x] += size[to];
          ans += e[i].w * abs(2 * size[to] - n);
      }
  }
  ```

#### 2. **作者：Aw顿顿 (赞：10)**
- **星级：4星**
- **关键亮点**：代码结构清晰，使用了`long long`避免溢出，DFS实现简洁，注释详细，适合初学者理解。
- **核心代码**：
  ```cpp
  void dfs(int x, int fa) {
      s[x] = 1;
      for (int i = h[x]; i; i = e[i].nxt) {
          int v = e[i].v, w = e[i].w;
          if (v != fa) {
              dfs(v, x);
              ans += abs(n - 2 * s[v]) * w;
              s[x] += s[v];
          }
      }
  }
  ```

#### 3. **作者：kradcigam (赞：5)**
- **星级：4星**
- **关键亮点**：使用了`vector`存储邻接表，代码简洁，DFS实现清晰，适合对STL熟悉的读者。
- **核心代码**：
  ```cpp
  void dfs(int x, int fa) {
      sz[x] = 1;
      for (auto i : v[x]) {
          if (i.first != fa) {
              dfs(i.first, x);
              sz[x] += sz[i.first];
              ans += 1ll * i.second * abs(sz[i.first] - (n - sz[i.first]));
          }
      }
  }
  ```

### 最优关键思路与技巧

1. **DFS遍历树**：通过DFS计算每个节点的子树大小，是解决树形问题的常见方法。
2. **公式计算贡献**：利用 `|n - 2 * size[v]| * w` 计算每条边的贡献，避免了复杂的统计。
3. **邻接表存储**：使用邻接表存储树结构，适合处理大规模数据。

### 可拓展之处

- **类似问题**：可以扩展到其他树形问题，如树的直径、重心、路径统计等。
- **优化技巧**：对于更大规模的数据，可以考虑使用非递归DFS或BFS来避免栈溢出。

### 推荐相似题目

1. **P1352 没有上司的舞会**（树形DP）
2. **P2014 选课**（树形DP）
3. **P3379 【模板】最近公共祖先（LCA）**（树的基本操作）

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中遇到的`scanf`未加`&`的错误，提醒我们在编写代码时要注意细节。
- **顿悟感想**：通过手推样例，作者更好地理解了题意，强调了理解题意的重要性。

---
处理用时：22.33秒
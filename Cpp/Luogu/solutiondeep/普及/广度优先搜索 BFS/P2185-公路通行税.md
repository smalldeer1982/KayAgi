# 题目信息

# 公路通行税

## 题目描述

在 PALMIA 国家内，有 $N$ 个城市由公路相连（每条公路恰好双向连接两个城市）。经由一条公路或多条公路，从任一城市出发可以到达其余各个城市。直到今年，公路上才要征收公路通行税。在每条公路的中间，有一征税员，从每一辆经由此路的车收取 1 PALMIA COIN（1PC）。

政府官员决定减少收税员而推行公路印花。如果一辆车欲进入一条公路，就必须将这张印花贴在窗上。

政府官员决定：一年的公路印花的价值相当于在两个最远城市之间进行 $100$ 次旅行所需的费用。两个城市之间的距离是从一个城市到达第二个城市所需经过的最少数目的公路数。

你的任务是编写一个程序计算出公路印花的价值。

## 样例 #1

### 输入

```
4 4
1 2
2 3
4 2
3 4
0 0```

### 输出

```
200```

# AI分析结果

### 综合分析与结论

本题的核心是求无向连通图中任意两点间的最短路径的最大值（即图的直径），并将其乘以100作为答案。由于每条边的权重均为1，因此可以通过广度优先搜索（BFS）来高效求解。大多数题解都采用了BFS的思路，通过遍历每个点作为起点，计算其到其他所有点的最短路径，并取最大值。部分题解还提到了一些优化技巧，如使用链式前向星或邻接表存储图结构，避免重复计算等。

### 最优关键思路与技巧

1. **BFS的应用**：由于边权为1，BFS可以在O(n+m)的时间内找到单源最短路径，避免了Dijkstra或SPFA的复杂度和额外开销。
2. **图的存储优化**：使用邻接表或链式前向星存储图，减少空间和时间复杂度。
3. **多组数据处理**：注意每组数据之间的清空操作，避免数据污染。
4. **边权的特殊性**：利用边权为1的特性，简化最短路径的计算，避免使用复杂的最短路算法。

### 推荐题解

#### 题解1：作者：Computer1828 (赞：5)
- **星级**：★★★★★
- **关键亮点**：详细解释了BFS的正确性，并提供了清晰的代码实现。使用了链式前向星存储图，代码结构清晰，优化到位。
- **个人心得**：强调了BFS在边权为1时的优势，避免了Dijkstra和SPFA的复杂度和额外开销。

```cpp
inline void bfs(int s){
    queue<node> q;
    q.push((node){s,0});
    vis[s] = true; 
    while(!q.empty()){
        node fr = q.front();
        q.pop();
        int u = fr.tp,dis = fr.dis;
        ans = max(ans,dis);
        for(int i = hed[u];i;i = e[i].nxt){
            int v = e[i].to;
            if(vis[v]) continue;
            q.push((node){v,dis+1});
            vis[v] = true;
        }
    }
}
```

#### 题解2：作者：Ambition_ (赞：4)
- **星级**：★★★★☆
- **关键亮点**：解释了无向图直径的概念，并提供了简洁的BFS实现。代码可读性高，适合初学者理解。
- **个人心得**：提到了Floyd算法的不可行性，并强调了BFS的优越性。

```cpp
void bfs(int st){
    queue<P>Q;
    memset(vis,1,sizeof vis);
    Q.push(P(0,st));
    vis[st]=0;
    while(!Q.empty()){
        P p=Q.front();
        Q.pop();
        int dis=p.fi;
        int now=p.se;
        d=max(d,dis);
        for(int i=0;i<(int)e[now].size();i++){
            int u=e[now][i];
            if(!vis[u])continue;
            vis[u]=0;
            Q.push(P(dis+1,u));
        }
    }
}
```

#### 题解3：作者：Lonely_NewYear (赞：2)
- **星级**：★★★★☆
- **关键亮点**：代码简洁，直接使用BFS求解，适合快速实现。强调了多组数据的处理。
- **个人心得**：提到了BFS的复杂度优势，并给出了清晰的代码实现。

```cpp
void bfs(int s){
    memset(dis,0x3f,sizeof dis);
    memset(vis,0,sizeof vis);
    queue<int>q;
    q.push(s),dis[s]=0;
    while(!q.empty()){
        int u=q.front();q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(auto v:e[u]){
            if(dis[v]>dis[u]+1)
                dis[v]=dis[u]+1,q.push(v);
        }
    }
}
```

### 扩展思路与类似题目

1. **类似题目**：
   - [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
   - [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
   - [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

2. **拓展思路**：
   - 对于边权不为1的情况，可以考虑使用Dijkstra或SPFA算法。
   - 如果图不连通，需要先判断连通性，再分别计算各连通分量的直径。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中遇到的多组数据清空问题，强调了清空操作的重要性。
- **踩坑教训**：一些题解提到Floyd算法在本题目中的不可行性，提醒了算法选择的重要性。
- **顿悟感想**：通过BFS的简洁实现，深刻理解了边权为1时最短路径计算的简化思路。

---
处理用时：27.36秒
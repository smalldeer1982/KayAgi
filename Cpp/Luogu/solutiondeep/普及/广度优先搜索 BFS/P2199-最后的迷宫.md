# 题目信息

# 最后的迷宫

## 题目背景

哈利•波特作为三强争霸赛的第四名选手，历尽艰险闯到了最后一关——迷宫。

现在，迷宫里只剩下哈利和塞德里克了，哈利只有在塞德里克前面拿到奖杯，才能赢得比赛。哈利只要能看到奖杯，就可以用飞来咒拿到它，所以，现在的问题是哈利如何能尽早地看到奖杯。


## 题目描述

哈利的视力非常好，他能从迷宫的一端沿直线看到迷宫的另一端（但他只能看八个方向——东北，东，东南，南，西南……），而且他跑得非常快，跑一步（向上、下、左、右移动一格）只需要 $1\text{s}$。但迷宫是不透光的，而且，要烧掉迷宫的墙也不容易，所以哈利决定绕到一个能够看到奖杯的地方。现在，哈利希望你能帮他确定最短需要多长时间才能拿到奖杯。


## 说明/提示

对于 $30\%$ 的数据，有 $N\times M\le100$；

对于 $60\%$ 的数据，有 $N\times M\le1600$；

对于 $100\%$ 的数据，有 $N\times M\le16384$。

询问数据对数不超过 $512$。


## 样例 #1

### 输入

```
3 4
OXXO
XXOO
XOOO
3 2 2 4
3 3 1 1
0 0 0 0
```

### 输出

```
1
Poor Harry
```

# AI分析结果

### 综合分析与结论

本题的核心是通过BFS（广度优先搜索）找到哈利从起点到能够看到奖杯的最短路径。难点在于如何高效地处理迷宫的存储、如何判断哈利是否能看到奖杯，以及如何优化BFS的搜索过程。大部分题解都采用了BFS，但在存储方式和优化策略上有所不同。部分题解通过预处理奖杯的可见区域来减少BFS的搜索次数，而另一些题解则通过一维数组存储迷宫来节省空间。

### 所选高星题解

#### 1. 作者：Alanalan (赞：22)
- **星级**：★★★★★
- **关键亮点**：
  - 使用BFS进行最短路径搜索，代码结构清晰。
  - 预处理奖杯的可见区域，减少BFS的搜索次数。
  - 使用二维数组存储迷宫，代码可读性强。
- **个人心得**：
  - 通过预处理奖杯的可见区域，大大减少了BFS的搜索次数，提升了效率。

```cpp
void bfs(int sx, int sy) {
    for(int i=0;i<n;++i)
        for(int j=0;j<m;++j)
            dis[i][j]=INF;
    q.push(node{sx,sy});
    dis[sx][sy]=0;
    while(!q.empty()) {
        int x=q.front().x;
        int y=q.front().y;
        q.pop();
        for(int i=0;i<4;++i) {
            int xx=x+dx[i];
            int yy=y+dy[i];
            if(ok(xx,yy) && dis[xx][yy]==INF) {
                dis[xx][yy]=dis[x][y]+1;
                q.push(node{xx,yy});
            }
        }
    }
}
```

#### 2. 作者：_wakeup (赞：15)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用一维数组存储迷宫，节省空间。
  - 通过预处理奖杯的可见区域，减少BFS的搜索次数。
  - 代码结构清晰，注释详细。
- **个人心得**：
  - 通过一维数组存储迷宫，避免了二维数组可能带来的空间问题。

```cpp
bool look(int stx, int sty) {
    for(int i=0;i<8;++i) {
        int xx=dx[i]+stx;
        int yy=dy[i]+sty;
        while(check(xx,yy)) {
            if(xx==ex&&yy==ey) return 1;
            xx+=dx[i];
            yy+=dy[i];
        }
    }
    return 0;
}
```

#### 3. 作者：2c_s (赞：6)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用一维数组存储迷宫，节省空间。
  - 通过预处理奖杯的可见区域，减少BFS的搜索次数。
  - 代码结构清晰，注释详细。
- **个人心得**：
  - 通过一维数组存储迷宫，避免了二维数组可能带来的空间问题。

```cpp
int bfs(int x, int y) {
    queue<pair<pair<int,int>,int>>q;
    bool use[16385];
    memset(use,false,sizeof(use));
    q.push(make_pair(make_pair(x,y),0));
    while(!q.empty()) {
        auto it=q.front();
        auto x=it.first.first;
        auto y=it.first.second;
        auto s=it.second;
        if(a(x,y)==2) return s;
        for(int i=0;i<4;i++) {
            auto xx=x+dx2[i];
            auto yy=y+dy2[i];
            auto ss=s+1;
            if(xx&&yy&&xx<=n&&yy<=m)
                if(a(xx,yy)&&(!used(xx,yy)))
                    used(xx,yy)=true,q.push(make_pair(make_pair(xx,yy),ss));
        }
        q.pop();
    }
    return -1;
}
```

### 最优关键思路与技巧

1. **预处理奖杯的可见区域**：通过从奖杯位置向八个方向搜索，标记所有能看到奖杯的位置，减少BFS的搜索次数。
2. **一维数组存储迷宫**：通过将二维坐标转换为一维坐标，节省存储空间，避免极端数据下的内存问题。
3. **BFS优化**：通过提前终止搜索（当找到第一个可见奖杯的位置时），减少不必要的搜索。

### 可拓展之处

- **类似算法套路**：可以应用于其他需要最短路径搜索的问题，如迷宫问题、图的最短路径问题等。
- **同类型题目**：
  - 洛谷P1141 01迷宫
  - 洛谷P1162 填涂颜色
  - 洛谷P1443 马的遍历

### 推荐题目

1. **洛谷P1141 01迷宫**：考察BFS在迷宫中的应用。
2. **洛谷P1162 填涂颜色**：考察BFS在填充问题中的应用。
3. **洛谷P1443 马的遍历**：考察BFS在棋盘问题中的应用。

---
处理用时：28.68秒
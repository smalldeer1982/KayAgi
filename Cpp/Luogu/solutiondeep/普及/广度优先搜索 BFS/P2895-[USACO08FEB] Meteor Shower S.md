# 题目信息

# [USACO08FEB] Meteor Shower S

## 题目描述

贝茜听说一场特别的流星雨即将到来：这些流星会撞向地球，并摧毁它们所撞击的任何东西。她为自己的安全感到焦虑，发誓要找到一个安全的地方（一个永远不会被流星摧毁的地方）。

如果将牧场放入一个直角坐标系中，贝茜现在的位置是原点，并且，贝茜不能踏上一块被流星砸过的土地。

根据预报，一共有 $M$ 颗流星 $(1\leq M\leq 50,000)$ 会坠落在农场上，其中第 $i$ 颗流星会在时刻 $T_i$（$0 \leq T _ i \leq 1000$）砸在坐标为 $(X_i,Y_i)(0\leq X_i\leq 300$，$0\leq Y_i\leq 300)$ 的格子里。流星的力量会将它所在的格子，以及周围 $4$ 个相邻的格子都化为焦土，当然贝茜也无法再在这些格子上行走。

贝茜在时刻 $0$ 开始行动，她只能在会在横纵坐标 $X,Y\ge 0$ 的区域中，平行于坐标轴行动，每 $1$ 个时刻中，她能移动到相邻的（一般是 $4$ 个）格子中的任意一个，当然目标格子要没有被烧焦才行。如果一个格子在时刻 $t$ 被流星撞击或烧焦，那么贝茜只能在 $t$ 之前的时刻在这个格子里出现。 贝茜一开始在 $(0,0)$。

请你计算一下，贝茜最少需要多少时间才能到达一个安全的格子。如果不可能到达输出 $−1$。

## 样例 #1

### 输入

```
4
0 0 2
2 1 2
1 1 2
0 3 5
```

### 输出

```
5
```

# AI分析结果

### 综合分析与结论

本题的核心是通过BFS（广度优先搜索）来寻找贝茜从起点（0,0）到安全区域的最短路径。难点在于处理流星坠落的时间，确保贝茜在流星坠落之前离开危险区域。大部分题解都采用了预处理流星坠落时间的方法，并通过BFS进行路径搜索。部分题解还优化了边界处理和队列实现，提升了代码的效率和可读性。

### 评分较高的题解

#### 1. **作者：翼德天尊 (5星)**
- **关键亮点**：  
  - 详细解释了坑点和处理思路，尤其是流星坠落时间的预处理和BFS的实现。
  - 代码结构清晰，注释详细，便于理解。
  - 使用了双队列来存储坐标，避免了结构体的使用，简化了代码。
  
- **核心代码**：
  ```cpp
  while (!q[0].empty()) {
      int x = q[0].front(), y = q[1].front();
      q[0].pop(); q[1].pop();
      int s = ans[x][y] + 1;
      if (ma[x][y] == -1) { // 如果该点安全，输出时间
          printf("%d\n", s - 1);
          return 0;
      }
      for (int i = 1; i <= 4; i++) {
          int xx = x + dx[i], yy = y + dy[i];
          if (xx >= 0 && yy >= 0 && s < ch(ma[xx][yy]) && v[xx][yy] == 0) {
              q[0].push(xx); q[1].push(yy);
              v[xx][yy] = 1;
              ans[xx][yy] = s;
          }
      }
  }
  ```
  
- **个人心得**：  
  - 作者强调了流星坠落时间的处理，提醒读者注意边界条件和时间比较，避免重复计算。

#### 2. **作者：dz_ice (4.5星)**
- **关键亮点**：  
  - 使用了结构体存储坐标和时间，代码可读性较高。
  - 详细解释了流星坠落时间的预处理，特别是如何处理多个流星对同一格子的影响。
  - 使用了STL队列，简化了BFS的实现。
  
- **核心代码**：
  ```cpp
  while (!q.empty()) {
      node p = q.front(); q.pop();
      for (int i = 0; i < 4; i++) {
          int nx = p.x + b1[i], ny = p.y + b2[i];
          if (nx >= 0 && ny >= 0 && c[nx][ny] == 0 && (time1[nx][ny] == -1 || p.time + 1 < time1[nx][ny])) {
              node txt;
              txt.x = nx, txt.y = ny, txt.time = p.time + 1, c[nx][ny] = 1;
              q.push(txt);
              if (time1[nx][ny] == -1) {
                  cout << txt.time << endl;
                  return 0;
              }
          }
      }
  }
  ```
  
- **个人心得**：  
  - 作者提到在处理流星坠落时间时，必须取最小值，否则会导致错误。这一点在实际调试中非常重要。

#### 3. **作者：很简单 (4星)**
- **关键亮点**：  
  - 代码简洁，使用了结构体和方向数组，便于理解。
  - 通过预处理流星坠落时间，确保BFS的正确性。
  - 使用了STL队列，简化了BFS的实现。
  
- **核心代码**：
  ```cpp
  while (!q.empty()) {
      point b = q.front();
      q.pop();
      for (int d = 0; d < 4; ++d) {
          point c;
          c.x = b.x + dx[d], c.y = b.y + dy[d], c.step = b.step + 1;
          if (c.x == -1 || c.y == -1) continue;
          if (mp[c.x][c.y] == inf) return c.step;
          if (c.step < mp[c.x][c.y] && !v[c.x][c.y]) {
              q.push(c);
              v[c.x][c.y] = 1;
          }
      }
  }
  ```
  
- **个人心得**：  
  - 作者强调了边界条件的处理，提醒读者注意坐标不能为负数。

### 最优关键思路与技巧

1. **预处理流星坠落时间**：通过预处理每个格子的流星坠落时间，确保在BFS过程中能够快速判断某个格子是否安全。
2. **BFS优化**：使用队列进行BFS，确保每次扩展的节点都是最短路径的一部分。通过方向数组简化代码，避免重复代码。
3. **边界处理**：在处理流星坠落时间时，特别注意边界条件，避免数组越界。

### 可拓展之处

本题的BFS思路可以拓展到其他类似的路径搜索问题，尤其是带有时间限制的场景。例如，处理动态障碍物或随时间变化的路径规划问题。

### 推荐题目

1. **P1332 血色先锋队**：同样是BFS的应用，处理动态障碍物。
2. **P3395 路障**：BFS处理路径中的障碍物，类似于本题的流星坠落。
3. **P1443 马的遍历**：BFS的应用，处理棋盘上的路径搜索。

### 个人心得总结

- **调试经历**：多位作者提到在处理流星坠落时间时，必须取最小值，否则会导致错误。这一点在实际调试中非常重要。
- **踩坑教训**：边界条件的处理是本题的难点之一，特别是在处理流星坠落时间时，必须确保坐标不越界。
- **顿悟感想**：通过预处理流星坠落时间，可以大大简化BFS的实现，确保算法的正确性和效率。

---
处理用时：31.19秒
# 题目信息

# 路障

## 题目描述

B 君站在一个 $n\times n$ 的棋盘上。最开始，B君站在 $(1,1)$ 这个点，他要走到 $(n,n)$ 这个点。

B 君每秒可以向上下左右的某个方向移动一格，但是很不妙，C 君打算阻止 B 君的计划。

**每秒结束的时刻**，C 君 会在 $(x,y)$ 上摆一个路障。B 君不能走在路障上。

B 君拿到了 C 君准备在哪些点放置路障。所以现在你需要判断，B 君能否成功走到 $(n,n)$。

**保证数据足够弱：也就是说，无需考虑“走到某处然后被一个路障砸死”的情况，因为答案不会出现此类情况。**

## 说明/提示

样例解释：

以下 0 表示能走，x 表示不能走，B 表示 B 君现在的位置。从左往右表示时间。

```
Case 1:
0 0    0 0    0 B  (已经走到了)
B 0    x B    x 0
```
```
Case 2:
0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0
0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0
0 0 0 0 0    0 0 x 0 0    0 0 x 0 0    0 0 x 0 0
0 0 0 0 0    0 0 0 0 0    0 0 x 0 0    0 0 x 0 0
B 0 0 0 0    0 B 0 0 0    0 0 B 0 0    0 0 x B 0 ......(B君可以走到终点)
```

数据规模：

防止骗分，数据保证全部手造。

对于 $20\%$ 的数据，有 $n\le3$。

对于 $60\%$ 的数据，有 $n\le500$。

对于 $100\%$ 的数据，有 $n\le1000$。

对于 $100\%$ 的数据，有 $T\le10$。

## 样例 #1

### 输入

```
2

2
1 1
2 2

5
3 3
3 2
3 1
1 2
1 3
1 4
1 5
2 2```

### 输出

```
Yes
Yes```

# AI分析结果

### 综合分析与结论

本题的核心是通过BFS（广度优先搜索）来判断在动态放置路障的情况下，是否能够从起点到达终点。难点在于如何正确处理路障的放置时间与B君移动时间的同步问题。大多数题解都采用了BFS的基本框架，但在处理路障放置的时机和优化上有不同的思路。

### 所选高星题解

#### 1. **Invisible_Blade (5星)**
- **关键亮点**：使用结构体手写队列，结合BFS，每秒广搜完所有可能走过的地方后再放路障。代码结构清晰，逻辑严谨，且通过`pd`数组标记路障的放置时间，避免了重复访问。
- **个人心得**：作者强调了重置数据的重要性，尤其是在多组数据的情况下，确保每次BFS的初始状态正确。
- **核心代码**：
  ```cpp
  void bfs(){
      int t=1,head=1,tail=2;
      que[head].x=1,que[head].y=1,pd[1][1]=1;
      do{
          for(int i=0;i<4;i++){
              nx=que[head].x+dx[i];
              ny=que[head].y+dy[i];
              if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&pd[nx][ny]==0){
                  que[tail].x=nx;
                  que[tail].y=ny;
                  tail++;
                  pd[nx][ny]=1;
              }
          }
          pd[no[t].x][no[t].y]=1;
          t++;
          head++;
      }while(head<tail);
      for(int i=tail;i>=1;i--){
          if(que[i].x==n&&que[i].y==n){
              printf("Yes\n");
              return;
          }
      }
      printf("No\n");
      return;
  }
  ```

#### 2. **Atmizz (4.5星)**
- **关键亮点**：使用STL队列进行BFS，处理路障放置时通过`map`数组标记路障位置，代码简洁易懂，适合初学者理解BFS的基本应用。
- **个人心得**：作者强调了路障放置的时机，指出路障是在每一秒结束后放置，而不是一开始就存在，这一点容易被忽视。
- **核心代码**：
  ```cpp
  void bfs(int x,int y,int t){
      queue<node>q;
      node now,net;
      now.x=x;now.y=y;now.t=t;
      q.push(now);
      while(!q.empty()) {
          now=q.front();
          q.pop();
          int a=now.x;int b=now.y;int c=now.t;
          if(a==n && b==n) {
              flag=1;
              break;
          }
          map[zx[now.t-1]][zy[now.t-1]]=1;
          for(int i=0;i<4;i++) {
              int dx=a+xx[i];int dy=b+yy[i];
              if(dx>=1 && dx<=n && dy>=1 && dy<=n && map[dx][dy]==0 && vis[dx][dy]==0) {
                  net.x=dx;net.y=dy;net.t=c+1;
                  vis[dx][dy]=1;
                  q.push(net);
              }
          }
      }
  }
  ```

#### 3. **ZJH365 (4星)**
- **关键亮点**：通过一次拓展一层点的BFS优化，避免了重复访问，且通过`pus`数组临时存储新拓展的点，确保路障放置的同步性。
- **个人心得**：作者分享了调试过程中遇到的数组越界问题，提醒大家注意数组大小。
- **核心代码**：
  ```cpp
  void bfs(){
      int mm=0,qq=0;
      queue<t> q;
      q.push((t){1,1});
      vis[1][1]=1;
      while(!q.empty()){
          mm++;
          while(!q.empty()){
              t now=q.front();
              q.pop();
              for(int i=1;i<=4;i++){
                  int tx=now.x+fx[i],ty=now.y+fy[i];
                  if(pd(tx,ty)&&vis[tx][ty]==0){
                      pus[++qq][0]=tx;pus[qq][1]=ty;
                      vis[tx][ty]=1;
                      if(tx==n&&ty==n)return 1;
                  }
              }
          }
          for(int i=1;i<=qq;i++){
              q.push((t){pus[i][0],pus[i][1]});
          }
          qq=0;
          vis[a[mm][0]][a[mm][1]]=2;
      }
      return 0;
  }
  ```

### 最优关键思路与技巧
1. **BFS的层序遍历**：通过一次拓展一层点的方式，确保路障放置的同步性。
2. **路障放置的时机**：路障是在每一秒结束后放置，因此需要在BFS的每一层结束后放置路障。
3. **数组标记与重置**：使用数组标记已访问点和路障位置，并在多组数据时重置数组，确保每次BFS的初始状态正确。

### 可拓展之处
- **类似问题**：可以扩展到其他动态障碍物的迷宫问题，如随时间变化的障碍物或移动的障碍物。
- **算法优化**：可以考虑使用双向BFS或A*算法进一步优化搜索效率。

### 推荐题目
1. **P1141 01迷宫**：考察BFS在迷宫中的应用。
2. **P1162 填涂颜色**：考察BFS在矩阵中的应用。
3. **P1443 马的遍历**：考察BFS在棋盘中的应用。

### 个人心得总结
- **调试经历**：多位作者提到在调试过程中遇到的数组越界、多组数据未重置等问题，提醒大家在编写代码时要注意细节。
- **顿悟感想**：通过一次拓展一层点的BFS优化，能够更好地处理动态路障的放置问题，这一点在多个题解中得到了体现。

---
处理用时：36.37秒
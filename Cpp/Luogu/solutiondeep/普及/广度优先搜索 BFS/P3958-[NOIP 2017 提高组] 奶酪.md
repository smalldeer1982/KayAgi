# 题目信息

# [NOIP 2017 提高组] 奶酪

## 题目背景

NOIP2017 提高组 D2T1

## 题目描述

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?

空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：


$$\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$


## 说明/提示

【输入输出样例 $1$ 说明】

 ![](https://cdn.luogu.com.cn/upload/pic/10860.png) 

第一组数据,由奶酪的剖面图可见：

第一个空洞在 $(0,0,0)$ 与下表面相切；

第二个空洞在 $(0,0,4)$ 与上表面相切；

两个空洞在 $(0,0,2)$ 相切。

输出 `Yes`。

 
第二组数据,由奶酪的剖面图可见：

两个空洞既不相交也不相切。

输出 `No`。

 
第三组数据,由奶酪的剖面图可见：

两个空洞相交，且与上下表面相切或相交。

输出 `Yes`。

【数据规模与约定】

对于 $20\%$ 的数据，$n = 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。

对于 $40\%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $80\%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $100\%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3 
2 4 1 
0 0 1 
0 0 3 
2 5 1 
0 0 1 
0 0 4 
2 5 2 
0 0 2 
2 0 4```

### 输出

```
Yes
No
Yes```

# AI分析结果

### 综合分析与结论

本题的核心在于判断是否存在一条从奶酪下表面到上表面的路径，路径由多个相交或相切的空洞组成。题解中主要采用了并查集、DFS、BFS等算法来解决该问题。并查集通过合并相交或相切的空洞，最终判断下表面和上表面是否连通；DFS和BFS则通过搜索路径来判断是否存在可行路径。

大部分题解的思路相似，但在实现细节上有所不同，如并查集的优化、DFS/BFS的剪枝、距离计算的精度处理等。总体而言，并查集的实现较为简洁且高效，适合处理大规模数据；DFS/BFS则更适合小规模数据或需要路径信息的场景。

### 所选高质量题解

#### 1. 作者：Fading (5星)
- **关键亮点**：并查集实现简洁高效，避免了DFS/BFS的递归深度问题，适合大规模数据。通过平方距离计算避免了精度问题，代码可读性强。
- **个人心得**：作者提到最初因double精度问题导致样例无法通过，后改用long long计算平方距离，解决了精度问题。
- **核心代码**：
  ```cpp
  int find(int x){
      if (x!=f[x]) f[x]=find(f[x]);
      return f[x];
  }
  long long dis(long long x,long long y,long long z,long long x1,long long y1,long long z1){
      return (x-x1)*(x-x1)+(y-y1)*(y-y1)+(z-z1)*(z-z1);
  }
  ```

#### 2. 作者：ikunTLE (4星)
- **关键亮点**：并查集实现清晰，通过平方距离计算避免了精度问题，代码结构清晰，适合初学者理解。
- **核心代码**：
  ```cpp
  int _find(int x){
      if(x==fa[x]) return x;
      fa[x]=_find(fa[x]);
      return fa[x];
  }
  int dis(int x1,int x2,int y1,int y2,int z1,int z2){
      return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2);
  }
  ```

#### 3. 作者：pipilong2024 (4星)
- **关键亮点**：并查集实现中引入了最大高度和最小高度的更新，优化了判断条件，代码逻辑清晰。
- **核心代码**：
  ```cpp
  int find(int x) {
      if (fa[x] == x) return x;
      return fa[x] = find(fa[x]);
  }
  int dist(int x1, int x2, int y1, int y2, int z1, int z2) {
      return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2);
  }
  ```

### 最优关键思路与技巧
1. **并查集的应用**：通过并查集合并相交或相切的空洞，最终判断下表面和上表面是否连通，适合大规模数据处理。
2. **平方距离计算**：通过计算平方距离避免了浮点数精度问题，提高了代码的鲁棒性。
3. **DFS/BFS的剪枝**：在DFS/BFS中通过标记已访问节点和提前终止搜索，优化了算法效率。

### 可拓展之处
- **类似算法套路**：并查集常用于处理连通性问题，如网络连接、图的连通分量等；DFS/BFS常用于路径搜索、图的遍历等。
- **同类型题目**：可以尝试处理更复杂的连通性问题，如三维空间中的路径规划、多连通区域的判断等。

### 推荐题目
1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)

### 个人心得总结
- **调试经历**：多位作者提到因double精度问题导致样例无法通过，后改用long long计算平方距离解决了问题。
- **踩坑教训**：多测不清空、不开long long见祖宗，强调了代码的鲁棒性和细节处理的重要性。
- **顿悟感想**：并查集的路径压缩和按秩合并可以显著提高算法效率，适合处理大规模数据。

---
处理用时：25.18秒
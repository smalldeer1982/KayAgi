# 题目信息

# [USACO06OCT] Cows on Skates G

## 题目描述

**本题使用 Special Judge。**

Farmer John 把农场划分为了一个 $r$ 行 $c$ 列的矩阵，并发现奶牛们无法通过其中一些区域。此刻，Bessie 位于坐标为 $(1,1)$ 的区域，并想到坐标为 $(r,c)$ 的牛棚享用晚餐。她知道，以她所在的区域为起点，每次移动至相邻的四个区域之一，总有一些路径可以到达牛棚。

这样的路径可能有无数种，请你输出任意一种，并保证所需移动次数不超过 $100000$。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le r\le 113$，$1\le c\le 77$。

------------

**【样例说明】* *

![](https://cdn.luogu.com.cn/upload/image_hosting/3gsutffb.png)

图为样例输出的示意图。答案不唯一。

## 样例 #1

### 输入

```
5 8
..*...**
*.*.*.**
*...*...
*.*.*.*.
....*.*.```

### 输出

```
1 1
1 2
2 2
3 2
3 3
3 4
2 4
1 4
1 5
1 6
2 6
3 6
3 7
3 8
4 8
5 8```

# AI分析结果

### 综合分析与结论

本题是一个典型的迷宫路径搜索问题，要求从起点到终点找到一条可行路径。题解中主要采用了DFS和BFS两种算法，其中DFS的题解较多，BFS的题解较少。DFS的题解中，大部分都提到了不需要回溯访问标记（`vis`数组），因为只需要找到一条路径即可，这大大减少了搜索的时间复杂度。BFS的题解则通过队列和路径记录来实现，虽然代码稍复杂，但保证了路径的最短性。

### 所选高星题解

#### 1. 作者：MY（一名蒟蒻） (赞：122)  
**星级：4.5星**  
**关键亮点：**  
- 使用DFS，代码简洁清晰，注释详细。
- 明确指出不需要回溯访问标记，节省了时间。
- 通过`f`变量控制输出，避免重复输出路径。

**个人心得：**  
作者提到最初被回溯标记坑了，后来意识到不需要回溯，这体现了调试中的经验积累。

**核心代码：**
```cpp
void dfs(int x, int y, int step) {
    if(x < 1 || x > r || y < 1 || y > c) return ;
    if(book[x][y]) return ;
    if(farm[x][y] == '*') return ;
    if(f) return ;
    if(x == r && y == c) {
        for(int i=1;i<step;i++) printf("%d %d\n",ax[i],ay[i]);
        printf("%d %d",r,c);
        f=true;
        return ;
    }
    ax[step]=x; ay[step]=y;
    book[x][y]=1;
    for(int i=0;i<4;i++) {
        dfs(x+next[i][0], y+next[i][1], step+1);
        if(f) return ;
    }
}
```

#### 2. 作者：do_while_false (赞：30)  
**星级：4星**  
**关键亮点：**  
- 使用DFS，代码结构清晰，方向数组的使用简化了代码。
- 通过`exit(0)`直接结束程序，避免不必要的搜索。

**核心代码：**
```cpp
void dfs(int x, int y) {
    if(x==r && y==c) {
        print();
        exit(0);
    }
    for(int i=0;i<4;i++) {
        int xx=x+dx[i], yy=y+dy[i];
        if(!vis[xx][yy] && xx>0 && xx<=r && yy>0 && yy<=c && a[xx][yy]=='.') {
            vis[xx][yy]=1;
            num++;
            ans[num][0]=xx; ans[num][1]=yy;
            dfs(xx, yy);
            num--;
        }
    }
}
```

#### 3. 作者：☆木辛土申☆ (赞：16)  
**星级：4星**  
**关键亮点：**  
- 使用BFS，保证了路径的最短性。
- 通过`dist`数组记录路径，递归输出路径。

**核心代码：**
```cpp
void bfs(int sx, int sy) {
    queue<pair<int,int>> q;
    q.push(make_pair(sx,sy));
    vis[sx][sy]=true;
    while(!q.empty()) {
        int x=q.front().first, y=q.front().second;
        q.pop();
        for(int i=1;i<=4;i++) {
            int xx=x+fx[i], yy=y+fy[i];
            if(illegal(xx,yy)) continue;
            dist[xx][yy][0]=x; dist[xx][yy][1]=y;
            vis[xx][yy]=true;
            q.push(make_pair(xx,yy));
            if(xx==r && yy==c) break;
        }
    }
}
```

### 最优关键思路与技巧

1. **DFS优化：** 不需要回溯访问标记，因为只需要找到一条路径即可，这大大减少了搜索的时间复杂度。
2. **BFS路径记录：** 通过`dist`数组记录每个点的前驱节点，最后递归输出路径，保证了路径的最短性。
3. **方向数组：** 使用方向数组简化了代码，避免了重复的坐标计算。

### 可拓展之处

- **同类型题：** 类似迷宫路径搜索问题，可以扩展到带有权重的路径搜索（如最短路径、最小代价路径等）。
- **算法套路：** DFS和BFS是图搜索的基础算法，可以扩展到更复杂的图论问题，如连通分量、拓扑排序等。

### 推荐题目

1. **P1605 迷宫** - 基础迷宫问题，适合练习DFS和BFS。
2. **P1141 01迷宫** - 带有障碍的迷宫问题，适合练习BFS。
3. **P1162 填涂颜色** - 迷宫填色问题，适合练习DFS的扩展应用。

### 个人心得总结

- **调试经验：** 很多作者在调试过程中发现不需要回溯访问标记，这体现了调试中的经验积累。
- **代码优化：** 通过方向数组和`exit(0)`等技巧，简化了代码并提高了效率。

---
处理用时：25.79秒
# 题目信息

# 选择题

## 题目背景

小 L 喜欢逻辑推理。

一天，他在一本由英国哲士沃·协德编写的《我也不知道为什么要叫这个名字的一本有关逻辑学的书》中翻到了一道奇特的问题，但他并不会做。他知道你善于用程序解决问题，于是决定让你来帮助他完成这些问题。

## 题目描述

这是一道有 $n$ 个选项的选择题，每个选项的内容都很独特。第 $i$ 个选项的内容的形式如下：

+ 第 $a_i$ 个选项是正确/错误的

小 L 认为这种题目的答案不一定是唯一的，所以他想问题这道题有多少种合法的答案（可以全部正确或全部错误）。他还想问你这么多答案中，正确选项最多和最少的答案分别有多少个正确选项。

当然，如果这道题不存在合法的答案，你可以直接回答小 L `No answer`。

## 说明/提示

对于样例一，一共有下面 $2$ 种正确答案：

+ 第 $1,2,3$ 个选项是正确的。
+ 第 $4$ 个选项是正确的。

其中正确选项最多的答案有 $3$ 个选项正确，正确选项最少的答案有 $1$ 个选项正确。

### 数据范围
对于 $10\%$ 的数据，$n\leq 10$。  
对于 $30\%$ 的数据，$n\leq 100$。  
对于 $60\%$ 的数据，$n\leq 10^3$。  
对于 $100\%$ 的数据，$n\leq 10^6,1\leq a_i\leq n,i\neq a_i,opt_i\in\{0,1\}$。

## 样例 #1

### 输入

```
4
2 1
4 0
1 1
2 0```

### 输出

```
2
3
1```

## 样例 #2

### 输入

```
10
4 1
7 0
2 0
3 1
7 1
5 0
9 1
10 1
8 0
1 1```

### 输出

```
No answer```

# AI分析结果

### 综合分析与结论

本题的核心在于处理选项之间的依赖关系，判断是否存在合法解，并计算合法解的数量、最多和最少正确选项的个数。题解中主要采用了以下几种思路：

1. **并查集（带权并查集）**：通过维护节点与父节点的关系（相同或不同），判断是否存在矛盾，并计算合法解的数量。
2. **图论（BFS/DFS染色）**：将选项之间的关系转化为图，通过染色判断是否存在矛盾，并计算合法解的数量。
3. **扩展域并查集**：将每个选项拆分为两个节点，分别表示其正确和错误的状态，通过并查集维护关系。

### 所选高星题解

#### 题解1：lnwzy (带权并查集) - 5星
**关键亮点**：
- 使用带权并查集处理选项之间的关系，路径压缩时更新节点与父节点的关系。
- 通过合并操作判断是否存在矛盾，并计算合法解的数量。
- 代码简洁，思路清晰，时间复杂度为O(nα(n))，接近线性。

**核心代码**：
```cpp
int fa(int x) {
    if(f[x]==x) return f[x];
    int t=f[x];
    f[x]=fa(f[x]);
    r[x]=(r[t]+r[x])%2; // 更新关系
    return f[x];
}
```

#### 题解2：littleKtian (BFS染色) - 4星
**关键亮点**：
- 将选项之间的关系转化为图，通过BFS染色判断是否存在矛盾。
- 每个连通块有两种染色方案，合法解的数量为2^k（k为连通块数）。
- 代码结构清晰，时间复杂度为O(n)。

**核心代码**：
```cpp
void BFS_color(int num, int Color) {
    color[num] = Color;
    queue<int> q;
    q.push(num);
    while (!q.empty()) {
        int top = q.front();
        q.pop();
        for (int i = head[top]; i; i = e[i].next) {
            int tv = e[i].v;
            if (color[tv] == color[top] && e[i].w == 0) {
                flag = 1; // 矛盾
                return;
            }
            if (color[tv] + color[top] == 3 && e[i].w == 1) {
                flag = 1; // 矛盾
                return;
            }
            if (!vis[tv]) {
                color[tv] = e[i].w == 1 ? color[top] : 3 - color[top];
                q.push(tv);
            }
        }
    }
}
```

#### 题解3：lndjy (DFS染色) - 4星
**关键亮点**：
- 通过DFS染色判断是否存在矛盾，每个连通块有两种染色方案。
- 代码简洁，思路清晰，时间复杂度为O(n)。

**核心代码**：
```cpp
void dfs(int now, int co) {
    v[now] = co + 1;
    c[co]++;
    for (int i = head[now]; i; i = e[i].nxt) {
        if (v[e[i].to] == (co ^ e[i].w) + 1) {
            cout << "No answer";
            exit(0);
        }
        if (!v[e[i].to]) {
            dfs(e[i].to, co ^ (!e[i].w));
        }
    }
}
```

### 最优关键思路与技巧

1. **带权并查集**：通过维护节点与父节点的关系（相同或不同），判断是否存在矛盾，并计算合法解的数量。路径压缩时更新关系是关键。
2. **图论染色**：将选项之间的关系转化为图，通过BFS或DFS染色判断是否存在矛盾，每个连通块有两种染色方案。

### 拓展思路与同类型题

1. **同类型题**：
   - [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)：使用带权并查集处理冲突关系。
   - [P2024 食物链](https://www.luogu.com.cn/problem/P2024)：通过带权并查集处理复杂的依赖关系。
   - [P1892 团伙](https://www.luogu.com.cn/problem/P1892)：使用并查集处理朋友和敌人的关系。

2. **调试与顿悟**：
   - **lnwzy**：通过路径压缩时更新关系，解决了带权并查集的难点。
   - **littleKtian**：通过BFS染色，发现每个连通块有两种染色方案，解决了合法解数量的计算问题。

### 推荐题目
1. [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)
2. [P2024 食物链](https://www.luogu.com.cn/problem/P2024)
3. [P1892 团伙](https://www.luogu.com.cn/problem/P1892)

---
处理用时：26.70秒
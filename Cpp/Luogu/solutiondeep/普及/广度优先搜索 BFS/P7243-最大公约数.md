# 题目信息

# 最大公约数

## 题目背景

&emsp;&emsp;“寻求最大公约数是人民民主的真谛。……”

&emsp;&emsp;初秋，从枝丫滴下的阳光，柔和，在教室的窗棱溅起，润湿晨读的少女的脸颊。

&emsp;&emsp;“阿绫，阿绫”，天依低俯身子，八字辫耷拉在竖起的课本沿，“我们的最大公约数是多少呢？”

&emsp;&emsp;“一定不小吧”，左手悄悄捏捏天依的小臂，“比如呀，有一个公因子，叫做‘你喜欢我，我也喜欢你’。”

## 题目描述

相反，人际圈形形色色，公约数小得可怜，似乎很难保持自己的个性因而变成无趣的人呢。

现在把人际抽象成一个 $n \times m$ 的矩形，每个人初始的个性为 $a_{i,j}$。从第二天开始，每个人会与上下左右四个人（如果存在）建立人际关系，其个性变为昨天自己和四周人个性的最大公约数。那么对于第 $x$ 行第 $y$ 列的人，在多少天后他的个性会变为 $1$ 呢？

----

#### 简化题意

有一个 $n \times m$ 的矩阵 $a$。对一个矩阵进行变换，定义为将这个矩阵内的所有元素变为其上下左右四个元素（不存在则忽略）及自身的最大公约数。询问 $a_{x,y}$ 在进行最少多少次变换之后会变成 $1$。如果可以使 $a_{x,y}$ 经过若干次变换变成 $1$，输出其中最小的次数；否则输出 $-1$。

## 说明/提示

#### 样例解释 3
第一天的个性矩阵（也就是最开始的矩阵）为
$$
\begin{pmatrix}
3&2&3\\
2&3&2\\
3&2&3
\end{pmatrix}
$$
第二天的个性矩阵为
$$
\begin{pmatrix}
1&1&1\\
1&1&1\\
1&1&1
\end{pmatrix}
$$
可见只需要经过一天，$a_{2,2}$ 就会变为 $1$，所以答案为 $1$。

#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^3$，$1\le a_{i,j}\le 10^{18}$，$1\le x\le n$，$1\le y\le m$。

| 子任务 | 分值 |        $n,m$        |              特殊限制              |
| :----: | :--: | :-----------------: | :--------------------------------: |
|   1    |  1   |          /          | 保证给出的位置个性永远不会变为 $1$ |
|   2    |  1   |          /          |          保证 $a_{x,y}=1$          |
|   3    |  3   |      $ \le 2$       |                 /                  |
|   4    |  10  |     $ \le 10^2$     |                 /                  |
|   5    |  30  | $ \le 5\times 10^2$ |           /            |
|   6    |  10  |          /          |   保证对于所有的 $a_{i,j} \le 2$   |
|   7    |  10  |          /          |     保证 $x$ 与 $y$ 都等于 $1$     |
|   8    |  35  |          /          |                 /                  |





------------




## 样例 #1

### 输入

```
2 2
2 2
1 2
2 1```

### 输出

```
0```

## 样例 #2

### 输入

```
2 2
2 2 
2 2
1 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
3 3
3 2 3
2 3 2
3 2 3
2 2```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心是通过矩阵变换，求某个位置的值在最少多少次变换后会变为1。各题解的主要思路是通过BFS或曼哈顿距离来模拟变换过程，并在过程中计算GCD。难点在于如何高效地处理大规模矩阵和快速计算GCD。

### 所选高星题解

#### 1. 作者：vectorwyx (5星)
- **关键亮点**：通过BFS模拟变换过程，利用GCD的性质优化计算，时间复杂度为O(nm log(k))，思路清晰且代码简洁。
- **代码核心**：
  ```cpp
  void bfs(){
      queue<int> qx,qy,qs;
      qx.push(sx),qy.push(sy),qs.push(0);
      vis[sx][sy]=1;
      ll sum=a[sx][sy];
      while(!qx.empty()){
          int x=qx.front(),y=qy.front(),s=qs.front();
          qx.pop(),qy.pop(),qs.pop();
          fo(i,0,3){
              int tx=x+dx[i],ty=y+dy[i];
              if(tx<1||tx>n||ty<1||ty>m||vis[tx][ty]) continue;
              vis[tx][ty]=1;
              qx.push(tx),qy.push(ty),qs.push(s+1);
              sum=__gcd(sum,a[tx][ty]);
              if(sum==1){
                  cout<<s+1;
                  return;
              }
          }
      }
      cout<<-1;
  }
  ```
- **个人心得**：作者强调了GCD的嵌套性质，并巧妙地将BFS与GCD结合，避免了重复计算。

#### 2. 作者：_zy_ (4星)
- **关键亮点**：通过BFS逐层扩展，计算GCD，思路清晰，代码实现较为直观。
- **代码核心**：
  ```cpp
  void bfs(int x,int y)
  {
      int head,tail;
      head=tail=0;
      q[++tail][0]=x; q[tail][1]=y;
      v[x][y]=1;
      while(head<tail)
      {
          int X=q[++head][0];
          int Y=q[head][1];
          for(int i=1;i<=4;i++)
          {
              int xx=X+dx[i]; int yy=Y+dy[i];
              if(v[xx][yy]||xx<1||yy<1||xx>n||yy>m)	continue;
              q[++tail][0]=xx;
              q[tail][1]=yy;
              q[tail][2]=q[head][2]+1;
              v[xx][yy]=1;
              tot=gcd(tot,a[xx][yy]);
          }
          if(tot==1) {
              cout<<q[tail][2]<<endl;
              exit(0);
          }
      }
  }
  ```
- **个人心得**：作者通过BFS逐层扩展，逐步计算GCD，思路清晰，代码实现较为直观。

#### 3. 作者：Just_A_King (4星)
- **关键亮点**：通过曼哈顿距离和GCD的结合，优化了计算过程，时间复杂度为O(nm log(n))。
- **代码核心**：
  ```cpp
  for(int i=1;i<=max_d;++i)
  {
      for(int j=0;j<int(pos[i].size());++j)
      {
          int p=pos[i][j].first,q=pos[i][j].second;
          now=gcd(now,a[p][q]);
      }
      if(now==1)
      {
          printf("%d\n",i);
          return 0;
      }
  }
  ```
- **个人心得**：作者通过曼哈顿距离和GCD的结合，优化了计算过程，思路清晰，代码实现较为直观。

### 最优关键思路或技巧
- **BFS与GCD结合**：通过BFS逐层扩展，计算GCD，避免重复计算，提高效率。
- **曼哈顿距离优化**：利用曼哈顿距离的性质，减少不必要的计算，优化时间复杂度。

### 可拓展之处
- **类似题目**：可以扩展到其他矩阵变换问题，如矩阵乘法、矩阵快速幂等。
- **算法套路**：BFS与GCD的结合可以应用于其他需要逐层扩展并计算某种性质的问题。

### 推荐题目
1. P3386 【模板】二分图匹配
2. P3371 【模板】单源最短路径（Dijkstra）
3. P3376 【模板】网络最大流

### 个人心得总结
- **调试经历**：通过BFS逐层扩展，逐步计算GCD，避免重复计算，提高效率。
- **踩坑教训**：在处理大规模矩阵时，需要注意时间复杂度的优化，避免超时。
- **顿悟感想**：通过曼哈顿距离和GCD的结合，可以优化计算过程，提高效率。

---
处理用时：25.20秒
# 题目信息

# [蓝桥杯 2018 国 C] 迷宫与陷阱

## 题目描述

小明在玩一款迷宫游戏，在游戏中他要控制自己的角色离开一间由 $N \times N$ 个格子组成的二维迷宫。

小明的起始位置在左上角，他需要到达右下角的格子才能离开迷宫。

每一步，他可以移动到上下左右相邻的格子中（前提是目标格子可以经过）。

迷宫中有些格子小明可以经过，我们用 `.` 表示；

有些格子是墙壁，小明不能经过，我们用 `#` 表示。

此外，有些格子上有陷阱，我们用 `X` 表示。除非小明处于无敌状态，否则不能经过。

有些格子上有无敌道具，我们用 `%` 表示。

当小明第一次到达该格子时，自动获得无敌状态，无敌状态会持续 $K$ 步。

之后如果再次到达该格子不会获得无敌状态了。

处于无敌状态时，可以经过有陷阱的格子，但是不会拆除 / 毁坏陷阱，即陷阱仍会阻止没有无敌状态的角色经过。

给定迷宫，请你计算小明最少经过几步可以离开迷宫。

## 说明/提示

时限 3 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
5 3
...XX
##%#.
...#.
.###.
.....```

### 输出

```
10```

## 样例 #2

### 输入

```
5 1
...XX
##%#.
...#.
.###.
.....```

### 输出

```
12```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在BFS的基础上处理无敌道具和陷阱的机制。所有题解都采用了BFS算法，但在处理无敌状态和剪枝策略上有所不同。主要难点在于如何高效地记录和更新无敌状态，避免重复访问。以下是各题解的要点总结：

1. **Zaku**：通过`vis`数组记录每个格子的无敌状态剩余步数，剪枝策略是如果当前无敌状态剩余步数小于之前访问时的状态，则跳过。代码清晰，剪枝策略有效。
2. **DreamLand_zcb**：使用`st`和`ti`数组分别记录步数和无敌状态，剪枝策略是如果当前步数大于等于之前记录且无敌状态小于等于之前记录，则跳过。思路清晰，但代码稍显复杂。
3. **_cpp**：在结构体中加入`invincible`表示无敌步数，使用`book`数组记录无敌步数，剪枝策略是如果当前无敌步数小于之前记录，则跳过。代码简洁，剪枝策略有效。
4. **wuhan1234**：使用`vis`数组记录无敌状态剩余步数，剪枝策略是如果当前无敌状态剩余步数小于之前记录，则跳过。代码较为简洁，但实现细节稍显复杂。
5. **Lemonlwl**：使用三维`vis`数组记录不同无敌状态下的访问情况，剪枝策略是如果当前无敌状态已经访问过，则跳过。代码清晰，但三维数组增加了空间复杂度。

### 所选高星题解

#### 1. Zaku (5星)
- **关键亮点**：剪枝策略简洁有效，代码清晰易读，通过`vis`数组记录无敌状态剩余步数，避免重复访问。
- **核心代码**：
```cpp
int magic = max(0, t.magic - 1);
if (g[tx][ty] == '%') magic = k;
if (tx >= 1 && tx <= n && ty >= 1 && ty <= n && vis[tx][ty] < magic && g[tx][ty] != '#') {
    vis[tx][ty] = magic;
    q.push({tx, ty, t.step + 1, magic});
}
```
- **核心思想**：在BFS中，每次移动时更新无敌状态剩余步数，遇到无敌道具时重置无敌步数，通过`vis`数组剪枝。

#### 2. _cpp (4星)
- **关键亮点**：代码简洁，剪枝策略有效，通过`book`数组记录无敌步数，避免重复访问。
- **核心代码**：
```cpp
k.invincible = max(0,t.invincible - 1);
if(a[dx][dy] == '%') k.invincible = x;
if(dx >= 1 && dx <= n && dy >= 1 && dy <= n && k.invincible > book[dx][dy]){
    k.x = dx;
    k.y = dy;
    book[dx][dy] = k.invincible;
    k.sum = t.sum + 1;
    q.push(k);
}
```
- **核心思想**：在BFS中，每次移动时更新无敌步数，遇到无敌道具时重置无敌步数，通过`book`数组剪枝。

#### 3. Lemonlwl (4星)
- **关键亮点**：使用三维`vis`数组记录不同无敌状态下的访问情况，剪枝策略清晰，代码结构良好。
- **核心代码**：
```cpp
if(a[tmp.cx][tmp.cy]=='%' && !vis[tmp.cx][tmp.cy][f.time]){
    vis[tmp.cx][tmp.cy][k]=true;
    a[tmp.cx][tmp.cy]='.';
    tmp.time=k;
    tmp.sum=f.sum+1;
    q.push(tmp);
}
```
- **核心思想**：在BFS中，使用三维`vis`数组记录不同无敌状态下的访问情况，遇到无敌道具时重置无敌步数，通过`vis`数组剪枝。

### 最优关键思路与技巧

1. **剪枝策略**：通过记录每个格子的无敌状态剩余步数，避免重复访问。如果当前无敌状态剩余步数小于之前访问时的状态，则跳过。
2. **无敌状态更新**：在BFS中，每次移动时更新无敌状态剩余步数，遇到无敌道具时重置无敌步数。
3. **数据结构**：使用二维或三维数组记录无敌状态，避免重复访问。

### 拓展思路

- **类似题目**：可以扩展到其他带有状态变化的BFS问题，如带有时间限制的迷宫、带有多种道具的迷宫等。
- **算法优化**：可以考虑使用A*算法或其他启发式搜索算法进一步优化搜索效率。

### 推荐题目

1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)

这些题目都涉及到BFS算法的应用，适合进一步练习和巩固相关知识。

---
处理用时：28.31秒
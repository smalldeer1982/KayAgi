# 题目信息

# [PA 2020] Wycieczka górska

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 4 [Wycieczka górska](https://sio2.mimuw.edu.pl/c/pa-2020-1/wyc/)**

一群 $k$ 个旅行者朋友去了 Byte 山。在最后一天，他们决定组织一场登山比赛，从他们所住的旅店到 Byte 山顶。

每个旅行者都有一张区域地图，它是一个分为 $n$ 行 $m$ 列的矩形；因此地图一共包含 $n\cdot m$ 个区域。旅店位于地图左上角的区域，而山顶则位于地图右下角的区域。Byte 山以其非常均匀而闻名——对于地图上的任何区域，在地图上与之相邻的右面或下面的区域海拔较高，而相邻的左边或上面区域海拔较低。但是，这座山也因潜伏着许多危险地区而闻名。有些地区在地图上标明是非常危险的，因为那里有野生动物居住——所以最好不要到那里去……

你是 Byte 山山脚下的一个小屋的看守人。通过观察每一个旅行者，你已经为他们每个人分配了两个参数 $a_i$ 和 $b_i$，这些参数决定了他们在山坡上的运动速度。具体来说，如果第 $i$ 个旅行者向更高的区域移动，那么他需要 $a_i$ 分钟，如果旅行者向更低的区域移动，则需要 $b_i$ 分钟。你也知道，每个旅行者都会走对他们来说从小屋到山顶最快的路线，并且路线完全在地形图上，而且避开了所有的危险区域。

你想知道最快的人需要多长时间才能到达山顶，有多少人将与最快的人同时爬到山顶。你可以假设，从小屋到山顶至少有一条安全的路线。

## 说明/提示

#### 样例 2 解释

从旅店到山顶只有一条路径，这些旅行者的用时分别是 $13,14,13,13$。

------------

#### 数据范围

**本题采用捆绑测试**

对于一些子任务满足 $k=1$。

对于 $100\%$ 的数据，保证 $2\le n,m\le 2\times 10^3$，$1\le k\le 10^6$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
5 7 1
......X
X.X..X.
..X.X.X
.X.X...
.....X.
2 1```

### 输出

```
26 1```

## 样例 #2

### 输入

```
2 5 4
.X...
...X.
2 1
2 2
1 7
2 1```

### 输出

```
13 3```

# AI分析结果

### 综合分析与结论

本题的核心在于通过BFS找到从起点到终点的最短路径，并计算每个旅行者在该路径上的时间。所有题解都基于一个关键观察：**所有旅行者的路径都是一样的**，因为最短路径的时间最优。因此，只需通过一次BFS找到最短路径，再根据每个旅行者的速度参数计算时间即可。

### 所选高星题解

#### 1. 作者：_•́へ•́╬_ (5星)
**关键亮点**：
- 思路清晰，直接指出所有人路径相同，简化了问题。
- 代码简洁，使用双端队列优化BFS，提高了效率。
- 通过记录“向回走”的次数，巧妙计算了路径的时间。

**核心代码**：
```cpp
void bfs() {
    q.emplace_back(0, 0, 0);
    while (!q.empty()) {
        node i = q.front(); q.pop_front();
        if (i.x == n-1 && i.y == m-1) break;
        // 向上下左右移动，更新路径
        if (i.x < n-1 && s[i.x+1][i.y]) q.emplace_front(i.x+1, i.y, i.a);
        if (i.y < m-1 && s[i.x][i.y+1]) q.emplace_front(i.x, i.y+1, i.a);
        if (i.x > 0 && s[i.x-1][i.y]) q.emplace_back(i.x-1, i.y, i.a+1);
        if (i.y > 0 && s[i.x][i.y-1]) q.emplace_back(i.x, i.y-1, i.a+1);
    }
}
```

#### 2. 作者：donnieguo (4星)
**关键亮点**：
- 详细解释了路径选择的逻辑，特别是“上山”和“下山”次数的关系。
- 代码结构清晰，使用队列进行BFS，并记录上下山的次数。

**核心代码**：
```cpp
void bfs() {
    q.push({1, 1, 0, 0});
    while (!q.empty()) {
        node now = q.front(); q.pop();
        if (now.x == n && now.y == m) {
            ul = now.tul; dr = now.tdr;
            return;
        }
        // 向上下左右移动，更新路径
        q.push({now.x+1, now.y, now.tul, now.tdr+1});
        q.push({now.x-1, now.y, now.tul+1, now.tdr});
        q.push({now.x, now.y-1, now.tul+1, now.tdr});
        q.push({now.x, now.y+1, now.tul, now.tdr+1});
    }
}
```

#### 3. 作者：makerli (4星)
**关键亮点**：
- 通过重载运算符优化了路径选择，确保下山次数最少。
- 代码逻辑清晰，结构合理，适合初学者理解。

**核心代码**：
```cpp
void bfs() {
    q.push({1, 1, 0, 0});
    while (!q.empty()) {
        zt now = q.front(); q.pop();
        if (now.x == n && now.y == m) {
            ans = min(ans, now);
            continue;
        }
        // 向上下左右移动，更新路径
        q.push({now.x+1, now.y, now.up+1, now.down});
        q.push({now.x-1, now.y, now.up, now.down+1});
        q.push({now.x, now.y-1, now.up, now.down+1});
        q.push({now.x, now.y+1, now.up+1, now.down});
    }
}
```

### 最优关键思路与技巧

1. **路径唯一性**：所有旅行者的路径相同，只需通过一次BFS找到最短路径。
2. **BFS优化**：使用双端队列（deque）优化BFS，优先扩展“向前走”的节点。
3. **时间计算**：通过记录“上山”和“下山”的次数，结合每个旅行者的速度参数，计算总时间。

### 可拓展之处

- **类似问题**：可以扩展到其他路径规划问题，如迷宫问题、最短路径问题等。
- **算法套路**：BFS+路径记录是解决此类问题的常见套路，适用于多种场景。

### 推荐题目

1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中发现路径选择的关键，特别是“上山”和“下山”次数的关系。
- **顿悟感想**：通过观察路径的唯一性，简化了问题的复杂度，避免了为每个旅行者单独计算路径的繁琐。

---
处理用时：26.26秒
# 题目信息

# [GESP202309 六级] 小杨的握手问题

## 题目描述

小杨的班级里共有 $N$ 名同学，学号从 $0$ 至 $N-1$。

某节课上，老师安排全班同学进行一次握手游戏，具体规则如下：老师安排了一个顺序，让全班 $N$ 名同学依次进入教室。每位同学进入教室时，需要和 **已经在教室内** 且 **学号小于自己** 的同学握手。

现在，小杨想知道，整个班级总共会进行多少次握手。

**提示：可以考虑使用归并排序进行降序排序，并在此过程中求解。**

## 说明/提示

**样例解释 1**:

$2$ 号同学进入教室，此时教室里没有其他同学。

$1$ 号同学进入教室，此时教室里有 $2$ 号同学。$1$ 号同学的学号小于 $2$ 号同学，因此他们之间不需要握手。

$3$ 号同学进入教室，此时教室里有 $1,2$ 号同学。$3$ 号同学的学号比他们都大，因此 $3$ 号同学需要分别和另外两位同学握手。

$0$ 号同学进入教室，此时教室里有 $1,2,3$ 号同学。$0$ 号同学的学号比他们都小，因此 $0$ 号同学不需要与其他同学握手。

**样例解释2：**

全班所有同学之间都会进行握手，因为每位同学来到教室时，都会发现他的学号是当前教室里最大的，所以他需要和教室里的每位其他同学进行握手。

对于 $30\%$ 的测试点，保证 $N\le100$。

对于所有测试点，保证 $2\le N\le3\times10^5$。


## 样例 #1

### 输入

```
4
2 1 3 0```

### 输出

```
2```

## 样例 #2

### 输入

```
6
0 1 2 3 4 5```

### 输出

```
15```

# AI分析结果

### 综合分析与结论
这些题解主要围绕将小杨的握手问题转化为逆序对问题来求解，采用的方法有归并排序和树状数组，还有一种使用分块算法。归并排序利用分治思想，在合并有序子数组时统计满足条件的数对；树状数组通过单点修改和区间查询来计算逆序对数量；分块算法则将问题转化为区间修改与单点查询。

### 所选题解
- **wsx248（5星）**
    - **关键亮点**：思路清晰，分别给出归并排序和树状数组两种解法，代码注释详细，可读性高。
    - **核心代码 - 归并排序**
```cpp
void merge(int l, int r)
{
    int mid = l + r >> 1;
    if(l>=r)
        return;
    merge(l, mid);
    merge(mid+1, r);
    int i = l, j = mid + 1, k = 0;
    while(i<=mid && j<=r)
    {
        if(a[i]>a[j])
        {
            ans += mid - i + 1;
            b[++k] = a[j++];
        }
        else
            b[++k] = a[i++];
    }
    while(i<=mid)
        b[++k] = a[i++];
    while(j<=r)
        b[++k] = a[j++];
    
    for(int i=l;i<=r;i++)
        a[i] = b[i-l+1];
}
```
核心思想：将数组分成左右两部分分别排序，合并时若左半部分当前元素大于右半部分当前元素，则左半部分从当前位置到末尾的元素都与右半部分当前元素构成逆序对。
    - **核心代码 - 树状数组**
```cpp
int lowbit(int x)
{
    return x & -x;
}

void add(int x, int y)
{
    for(int i=x;i<=n;i+=lowbit(i))
        c[i] += y;
}

int ask(int x)
{
    int res = 0;
    for(int i=x;i;i-=lowbit(i))
        res += c[i];
    return res;
}
```
核心思想：利用树状数组的单点修改和区间查询功能，每次插入元素时统计比它小的元素个数。

- **CQ_Bob（4星）**
    - **关键亮点**：代码简洁，使用树状数组解决问题，定义内联函数提高效率。
    - **核心代码**
```cpp
il void add(int x){while(x<=n) ++tr[x],x+=x&(-x);}
il long long query(int x){long long ans=0;while(x) ans+=tr[x],x-=x&(-x);return ans;}

il void solve(){
    scanf("%d",&n);
    for(re int i=1;i<=n;++i){
        int x=0;scanf("%d",&x),++x;
        ans+=query(x-1),add(x);
    }
    printf("%lld\n",ans);
    return ;
}
```
核心思想：通过树状数组的 `add` 函数进行单点修改，`query` 函数进行区间查询，统计逆序对数量。

- **technopolis_2085（4星）**
    - **关键亮点**：明确指出问题等价于序列翻转后的逆序对问题，代码实现简洁。
    - **核心代码**
```cpp
void solve(int l,int r){
    if (l==r) return;
    
    int mid=(l+r)/2;
    solve(l,mid); solve(mid+1,r);
    int tot=l;
    int i=l,j=mid+1;
    
    while (i<=mid&&j<=r){
        if (a[i]<=a[j]){
            b[tot++]=a[i++];
        }else{
            ans+=(mid-i+1);
            b[tot++]=a[j++];
        }
    }
    
    while (i<=mid) b[tot++]=a[i++];
    while (j<=r) b[tot++]=a[j++];
    
    for (int t=l;t<=r;t++) a[t]=b[t];
}
```
核心思想：使用归并排序，在合并过程中统计逆序对数量。

### 最优关键思路或技巧
- **问题转化**：将握手问题转化为逆序对问题，简化问题求解。
- **归并排序**：利用分治思想，在合并有序子数组时统计逆序对，时间复杂度为 $O(nlogn)$。
- **树状数组**：通过单点修改和区间查询，高效计算逆序对数量，时间复杂度为 $O(nlogn)$。

### 可拓展之处
同类型题可考虑序列中有重复元素、元素范围较大等情况，可使用离散化等技巧处理。类似算法套路可用于求解其他统计满足特定条件数对的问题。

### 洛谷题目推荐
- P1908 逆序对
- B3874 【模板】逆序对
- P5142 区间方差

### 个人心得摘录与总结
- **CQ_Bob**：“很神奇，你猜我为什么交了这么多次。” 推测作者在调试过程中遇到了一些问题，可能是对树状数组的使用细节或边界条件处理不当。在使用模板算法时，要注意细节和边界情况，避免出现错误。 

---
处理用时：32.17秒
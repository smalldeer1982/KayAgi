# 题目信息

# [信息与未来 2024] 数据排序

## 题目描述

在计算机世界中，“表格”是一种简单、基础而且十分通用的数据结构，在数据库、人工智能等领域中都有广泛的应用。表格由若干行、若干列的单元格组成：

| Name     | p1   | p2   | p3   | Score |
| :------- | :--- | ---- | ---- | ----- |
| ZhangSan | 40   | 30   | 28   | 98    |
| LiSi     | 40   | 28   | 30   | 98    |
| WangWu   | 40   | 25   | 20   | 85    |

CSV (Comma-Separated Values) 是一种常用的表格格式。Dr. X 需要你编程处理简化的 CSV 文
件，格式规定如下：

- CSV 文件包含 $n$ 行数据，其中第一行是标题行。
- CSV 文件每行一个字符串，对应了表格的一行。行中的单元格由**半角逗号**分隔。
- 每个单元格至少包含一个字符。单元格有两种类型：
  - **数值单元格**：由至少一个数字字符 $(0\sim 9)$ 组成。
  - **字符串单元格**：由数字字符 $(0\sim 9)$ 和大小写字母 $(\tt{a\sim z},\tt{A\sim Z})$ 组成,且至少包含一个字母。

- 标题行的所有单元格都是字符串单元格，且互不相同。标题行中包含了列的名称。

以下是一个 CSV 文件的示例：

```
Name,p1,p2,p3,Score
ZhangSan,40,30,28,98
LiSi,40,28,30,98
WangWu,40,25,20,85
```

你的任务是**根据指定的列为表格中的行排序**。例如根据 `Score- , Name+ , p3-` 排序意味着：

- 优先按 Score 列从大到小排序。Score 列都是数值单元格，因此按数值排序。

- 如果 Score 列相同，按 Name 列从小到大排序。Name 列都是字符串单元格，因此按照字典排序。

- 如果 Score 和 Name 列都相同，按 p3 列从大到小排序。p3 列都是数值单元格，因此按数
  值排序。

我们保证 CSV 文件每一行的单元格数量相同，且除标题行外，**每一列要么全是数值单元格，要么全是字符串单元格**。

## 说明/提示

对于 $100\%$ 的数据，满足 $1 \leq n \leq 100$，表格不超过 $10$ 列，字符串单元格不超过 $16$ 个字符，且数值单元格中的数值是 $0$ 到 $10^4$ 之间的整数。

>本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
4
Name,p1,p2,p3,Score
ZhangSan,40,30,28,98
LiSi,40,28,30,98
WangWu,40,25,20,85
3
Score-
Name+
p3-```

### 输出

```
Name,p1,p2,p3,Score
LiSi,40,28,30,98
ZhangSan,40,30,28,98
WangWu,40,25,20,85```

# AI分析结果

### 综合分析与结论
这些题解主要围绕模拟 CSV 文件数据排序展开。整体思路是先读取标题行和数据行，解析出单元格信息，再读取排序规则，最后根据规则对数据行排序并输出。各题解在数据存储和排序实现上有所不同，部分使用 `std::variant` 存储单元格，部分使用结构体区分数字和字符串，排序时多使用 `sort` 或 `stable_sort` 并自定义 `cmp` 函数。

### 所选题解
- **作者：FFTotoro（5星）**
    - **关键亮点**：使用 `std::variant<int, std::string>` 存储单元格，简洁处理数字和字符串类型；用 `std::stable_sort` 保证排序稳定性。
    - **个人心得**：无
- **作者：沉石鱼惊旋（4星）**
    - **关键亮点**：思路清晰，代码结构良好，将不同功能模块化，便于理解和维护。
    - **个人心得**：无
- **作者：Moya_Rao（4星）**
    - **关键亮点**：详细注释代码，对关键步骤解释清晰，适合新手学习。
    - **个人心得**：无

### 重点代码及核心实现思想
#### FFTotoro
```cpp
inline vector<variant<int,string> > f(string s){
  vector<variant<int,string> > a;
  for(int i=0,j;i<s.length();i=j+1){
    string t;
    for(j=i;j<s.length()&&s[j]!=',';j++)t+=s[j];
    bool D=true; 
    for(char i:t)D&=isdigit(i);
    if(D)a.emplace_back(stoi(t));
    else a.emplace_back(t);
  }
  return a;
}
stable_sort(T.begin(),T.end(),[&](auto x,auto y){
  for(auto [a,s]:C)
    if(x[a]!=y[a])return s?x[a]<y[a]:x[a]>y[a];
  return false;
});
```
核心思想：`f` 函数解析输入字符串，根据字符是否全为数字决定存储为 `int` 或 `string`；`stable_sort` 根据排序规则对数据行排序。

#### 沉石鱼惊旋
```cpp
bool ccmp(vector<node> a, vector<node> b)
{
    for (int i = 1; i <= c; i++)
    {
        int op = cmp[i].back();
        string t = cmp[i].substr(0, cmp[i].size() - 1);
        int j = title[t];
        if (op == '+')
        {
            if (!a[j].op)
            {
                if (a[j].x == b[j].x)
                    continue;
                return a[j].x < b[j].x;
            }
            else
            {
                if (a[j].y == b[j].y)
                    continue;
                return a[j].y < b[j].y;
            }
        }
        else
        {
            if (!a[j].op)
            {
                if (a[j].x == b[j].x)
                    continue;
                return a[j].x > b[j].x;
            }
            else
            {
                if (a[j].y == b[j].y)
                    continue;
                return a[j].y > b[j].y;
            }
        }
    }
    return a[0].x < b[0].x;
}
```
核心思想：`ccmp` 函数根据排序规则依次比较两数据行，根据升序或降序、数字或字符串类型进行比较，全部相同则按原顺序排序。

#### Moya_Rao
```cpp
bool cmp(vector<price> x,vector<price> y){
    for(int i=1;i<=C;i++){
        char op=Cmp[i].back();
        string t=Cmp[i].substr(0,Cmp[i].size()-1);
        int j=GT[t];
        if(op=='+'){
            if(x[j].type==0){
                if(x[j].Int==y[j].Int)continue;
                return x[j].Int<y[j].Int;
            }
            else{
                if(x[j].Str==y[j].Str)continue;
                return x[j].Str<y[j].Str;
            }
        }
        else{
            if (x[j].type==0){
                if(x[j].Int==y[j].Int)continue;
                return x[j].Int>y[j].Int;
            }
            else{
                if(x[j].Str==y[j].Str)continue;
                return x[j].Str>y[j].Str;
            }
        }
    }
    return x[0].Int<y[0].Int;
}
```
核心思想：`cmp` 函数根据排序规则比较两数据行，区分数字和字符串类型，按升序或降序排序，全部相同则按原顺序排序。

### 最优关键思路或技巧
- 使用 `std::variant` 统一存储数字和字符串，避免复杂的类型判断。
- 用 `std::stable_sort` 保证排序稳定性，满足题目要求。
- 定义结构体区分数字和字符串单元格，便于处理不同类型数据。

### 拓展思路
同类型题可拓展到更复杂的表格排序，如多条件嵌套排序、不同数据类型混合排序等。类似算法套路可用于处理其他结构化数据的排序问题，如 JSON 数据排序。

### 推荐题目
- P1177 【模板】快速排序
- P1093 [NOIP2007 普及组] 奖学金
- P1781 宇宙总统

### 个人心得摘录与总结
- **GLr137**：提到 `sort` 是不稳定排序，若不比较下标会导致 WA 或 RE，强调了排序稳定性的重要性。
- **fire_and_sweets**：指出使用 `sort` 只能得 14 分，需选用稳定排序，同时分享了自己在考场上的错误经历。 

---
处理用时：39.92秒
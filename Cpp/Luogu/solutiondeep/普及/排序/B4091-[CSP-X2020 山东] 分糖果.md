# 题目信息

# [CSP-X2020 山东] 分糖果

## 题目背景

老师组织一群孩子围成一个圈进行游戏，游戏结束后老师会根据每个孩子的表现进行评分并给予糖果奖励。

## 题目描述

每个孩子只能看见与自己相邻的 $2$ 个孩子（左边的和右边的）的情况，只会关心相邻的且比自己评分低的同学的糖果数（如果相邻 $2$ 个孩子的评分相等，则不关心）。为保证公平，相邻的孩子中，评分高的孩子必须获得更多的糖果(如果左右相邻 $2$ 个孩子的评分相等，则不关心，即分最少的糖果 $1$ 个）。同时，为鼓励孩子的积极性，每个孩子至少都能拿到 $1$ 个糖果。现在需要你帮助老师来分发糖果，问怎么分配才能使要准备的糖果数最少？计算出需要的最少糖果数。

## 说明/提示

【数据范围】

对于 $40\%$ 的数据，$1\leq n\leq 100$；

对于 $100\%$ 的数据，$1\leq n\leq 10^5$;

所有评分都是 $0$ 到 $100$ 之间的一个整数。

【样例解释】

样例一，分别分配 $2,3,1$ 的糖果，所以最少需要 $6$ 个糖果。

样例二，分别分配 $1,2,1,2$ 的糖果，所以最少需要 $6$ 个糖果。

## 样例 #1

### 输入

```
3
1 2 0```

### 输出

```
6```

## 样例 #2

### 输入

```
4
2 3 3 3```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
这些题解思路基本一致，都是先给每个孩子分配 1 个糖果，再不断遍历孩子的评分和糖果数，对不满足“评分高的孩子糖果数更多”条件的情况进行调整，直至所有孩子都满足条件，最后累加所有孩子的糖果数得到结果。在判断是否继续循环时，有的通过设置标志位，有的通过比较前后两次的糖果总数。

### 所选题解
- **作者：SkyLines (赞：6)，5星**
    - **关键亮点**：思路清晰，代码简洁，使用标志位判断是否继续循环，逻辑明确。
    - **核心代码**：
```cpp
while(1){
    flg = 0;
    for(int i = 1; i <= n; i++){
        j = ((i == n)? 1 : (i + 1));
        if(a[i] < a[j] && cnt[i] >= cnt[j]){
            cnt[j] = cnt[i] + 1;
            flg = 1;
        }else if(a[i] > a[j] && cnt[j] >= cnt[i]){
            cnt[i] = cnt[j] + 1;
            flg = 1;
        }
    }
    if(!flg) break;
}
```
核心思想：通过 `flg` 标志位判断是否有糖果数的调整，若没有则结束循环。
- **作者：CASCwty (赞：1)，4星**
    - **关键亮点**：对不满足条件的情况分析清晰，代码结构良好，同样使用标志位控制循环。
    - **核心代码**：
```cpp
while(flag)
{
    flag=false;
    for(int i=1;i<=n;i++)
    {
        nxt=(i==n)?1:i+1;
        if(a[i]<a[nxt]&&candy[i]>=candy[nxt])
        {
            candy[nxt]=candy[i]+1;
            flag=true;
        }
        else if(a[i]>a[nxt]&&candy[i]<=candy[nxt])
        {
            candy[i]=candy[nxt]+1;
            flag=true;
        }
    }
}
```
核心思想：利用 `flag` 标志位判断是否继续循环，不断调整糖果数直到满足条件。
- **作者：yyycj (赞：1)，4星**
    - **关键亮点**：对可能出现的无限循环情况进行了形象的解释，代码中使用计数器判断是否继续循环。
    - **核心代码**：
```cpp
int cnt = 1;
while (cnt) {
    cnt = 0;
    for (int i=1;i<=n;i++) {
        int r = i % n + 1;
        if (score[i]>score[r] && candy[i]<=candy[r]) {
            candy[i] = candy[r] + 1;
            cnt++;
        }
        else if (score[i]<score[r] && candy[i]>=candy[r]) {
            candy[r] = candy[i] + 1;
            cnt++;
        }
    }
}
```
核心思想：通过 `cnt` 计数器记录不满足要求的次数，若为 0 则结束循环。

### 最优关键思路或技巧
- 先给每个孩子分配 1 个糖果，满足“每个孩子至少有 1 个糖果”的条件。
- 采用循环遍历的方式，每次只对不满足条件的情况进行最小调整（即糖果数加 1），保证总糖果数最少。
- 使用标志位或计数器判断是否继续循环，避免无限循环。

### 可拓展之处
同类型题可能会改变孩子的排列方式（如直线排列）、增加判断条件（如考虑多个相邻孩子的情况）等。类似算法套路是先初始化，再通过循环不断调整，直到满足所有条件。

### 推荐题目
- [P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)

### 个人心得
题解中未包含个人心得。 

---
处理用时：26.00秒
# 题目信息

# [NOIP 1998 提高组] 拼数

## 题目描述

设有 $n$ 个正整数 $a_1 \dots a_n$，将它们联接成一排，相邻数字首尾相接，组成一个最大的整数。


## 说明/提示

对于全部的测试点，保证 $1 \leq n \leq 20$，$1 \leq a_i \leq 10^9$。

NOIP1998 提高组 第二题

## 样例 #1

### 输入

```
3
13 312 343
```

### 输出

```
34331213
```

## 样例 #2

### 输入

```
4
7 13 4 246```

### 输出

```
7424613```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何将给定的正整数拼接成最大整数展开，提供了贪心、搜索和状压 DP 三种主要思路。
- **贪心思路**：将数字转换为字符串，通过比较 `a + b` 和 `b + a` 的大小来排序，最终按排序结果拼接输出。此思路简洁高效，多数题解采用该方法，部分还给出了详细证明。
- **搜索思路**：通过全排列搜索所有可能的拼接情况，找出最大值。但时间复杂度高，数据加强后易超时，可通过剪枝和排序优化。
- **状压 DP 思路**：设 `f_S` 为使用字符串状态为 `S` 的最大字符串，通过状态转移方程求解。但存在空间复杂度高的问题。

### 所选题解
- **作者：精神小火（5星）**
    - **关键亮点**：思路清晰，代码简洁，对贪心算法的正确性进行了详细证明，引入自定义符号辅助证明，逻辑严谨。
    - **个人心得**：作者为转移考试注意力来写题解，且花费长时间憋出第一篇题解，修改时力求让大家看懂。
    - **核心代码**：
```cpp
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;

string s[21];int n;
bool cmp(const string &a,const string &b) { 
    return (a+b > b+a);
}
int main(void) {
    cin >> n;
    for(int i=1;i<=n;++i) cin >> s[i];
    sort(s+1,s+n+1,cmp);
    for (int i=1;i<=n;++i) cout << s[i];
    return 0;
}
```
核心实现思想：将输入的数字存储为字符串，自定义比较函数 `cmp` 比较 `a + b` 和 `b + a` 的大小，使用 `sort` 函数按此规则排序，最后按排序结果输出。
- **作者：wsyhb（4星）**
    - **关键亮点**：对贪心算法的正确性进行了严格数学证明，包括交换操作会在有限步内停止和最终所得序列为最优序列两部分，逻辑严密。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=20+5;
string S[max_n];
bool cmp(const string &A,const string &B) {
    return A+B>B+A; 
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;++i)
        cin>>S[i];
    sort(S+1,S+n+1,cmp); 
    for(int i=1;i<=n;++i)
        cout<<S[i];
    cout<<"\n";
    return 0;
}
```
核心实现思想：与上一题解类似，将输入存储为字符串，自定义比较函数 `cmp` 进行排序，最后输出排序结果。
- **作者：Dregen_Yor（4星）**
    - **关键亮点**：思路清晰，通过具体例子解释贪心算法的正确性，易于理解。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
string s[30];
int n;

bool cmp(string a, string b) {
    return a + b > b + a;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        cin >> s[i];
    }
    sort(s + 1, s + 1 + n, cmp);
    for (int i = 1; i <= n; i++) {
        cout << s[i];
    }
    return 0;
}
```
核心实现思想：同样是将数字转换为字符串，使用自定义比较函数 `cmp` 排序后输出。

### 最优关键思路或技巧
- **数据结构**：使用字符串存储数字，利用字符串拼接和比较操作简化问题。
- **算法优化**：贪心算法通过自定义比较函数 `cmp` 排序，时间复杂度为 $O(n\log{n}\cdot\max{|S|})$，高效解决问题。
- **思维方式**：通过比较 `a + b` 和 `b + a` 的大小来确定两个数字的拼接顺序，巧妙地解决了不同长度数字拼接的问题。

### 可拓展之处
同类型题或类似算法套路：
- 拼接最小整数：思路与本题类似，只需将比较函数改为 `a + b < b + a`。
- 多个数组元素拼接问题：可将多个数组元素合并后按相同方法处理。

### 推荐题目
- [P1015 [NOIP1999 普及组] 回文数](https://www.luogu.com.cn/problem/P1015)
- [P1024 [NOIP2001 提高组] 一元三次方程求解](https://www.luogu.com.cn/problem/P1024)
- [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得总结
- 作者精神小火为转移考试注意力写题解，写第一篇题解花费长时间，修改时力求清晰易懂。
- 作者喵仔牛奶在使用搜索算法时遇到超时和错误问题，通过剪枝、排序等方法优化，但仍认为考场需使用稳定复杂度算法。 

---
处理用时：38.71秒
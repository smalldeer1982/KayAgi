# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果

### 综合分析与结论
本题要求求解同余方程 $ax \equiv 1 \pmod {b}$ 的最小正整数解，题解主要采用了扩展欧几里得算法和欧拉定理两种思路。

扩展欧几里得算法思路是将原方程转化为 $ax + by = 1$ 的形式，利用扩展欧几里得算法求解 $ax + by = \gcd(a, b)$ 的解，再根据裴蜀定理判断方程有解的条件，最后处理解得到最小正整数解。该算法时间复杂度为 $O(\log\max(a,b))$，适用于各种数据范围。

欧拉定理思路是利用 $a^{\varphi(b)} \equiv 1 \pmod b$，将原方程转化为 $x \equiv a^{\varphi(b) - 1} \pmod b$，通过求解 $\varphi(b)$ 和快速幂运算得到解。该方法需要先判断 $a$ 和 $b$ 互质，时间复杂度为 $O(\sqrt{b} + \log b)$。

### 所选题解
- **学委（5星）**
    - **关键亮点**：思路清晰，详细推导了扩展欧几里得算法的过程，对问题转化、算法原理和答案处理都有深入解释，代码注释详细，还介绍了乘法逆元的应用。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

long long x, y;

void exgcd(long long a, long long b)
{
    if(b == 0)
    {
        x = 1;
        y = 7; 
        return;
    } 
    exgcd(b, a % b);
    long long tx = x;
    x = y;
    y = tx - a / b * y; 
}

int main()
{
    long long a, b;
    cin >> a >> b;
    exgcd(a, b);
    x = (x % b + b) % b;
    printf("%lld\n", x);
    return 0;
}
```
核心实现思想：通过递归调用 `exgcd` 函数，不断缩小系数，直到 $b = 0$ 时得到一组解，再回溯更新解，最后处理解得到最小正整数解。

- **沙普绿12138（4星）**
    - **关键亮点**：提供了非扩欧的解法，利用欧拉定理求解，思路独特，代码简洁，对欧拉函数的求解和快速幂运算有详细实现。
    - **核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;

int a, b;

int fai(int n) {
    int ans = 1;
    for(int i = 2; i * i <= n; ++ i) {
        if(n % i == 0) {
            n /= i;
            ans *= i - 1;
            while(n % i == 0) {
                n /= i;
                ans *= i;
            }
        }
    }
    if(n > 1)
        ans *= n - 1;
    return ans;
}

int fast_pow(int x, int k) {
    ll ans = 1, quan = x;
    while(k) {
        if(k & 1)
            ans = ans * quan % b;
        quan = quan * quan % b;
        k >>= 1;
    }
    return (int)ans;
}

int main() {
    scanf("%d %d", &a, &b);
    printf("%d", fast_pow(a, fai(b) - 1));
    return 0;
}
```
核心实现思想：先实现 `fai` 函数求解欧拉函数 $\varphi(b)$，再使用 `fast_pow` 函数进行快速幂运算，最后根据 $x \equiv a^{\varphi(b) - 1} \pmod b$ 得到解。

### 最优关键思路或技巧
- **问题转化**：将同余方程 $ax \equiv 1 \pmod {b}$ 转化为 $ax + by = 1$ 的形式，便于使用扩展欧几里得算法求解。
- **扩展欧几里得算法**：通过递归不断缩小系数，利用 $ax + by = bx_2 + (a \mod b)y_2$ 的关系求解方程的解。
- **欧拉定理应用**：利用 $a^{\varphi(b)} \equiv 1 \pmod b$ 简化同余方程的求解。

### 可拓展之处
同类型题或类似算法套路：
- 求解一般线性同余方程 $ax \equiv c \pmod {b}$，可先判断 $\gcd(a, b)$ 是否整除 $c$，若整除则可使用扩展欧几里得算法求解。
- 求解模逆元的应用，如在模运算中进行除法运算，可通过求逆元将除法转化为乘法。

### 推荐题目
- P1516 青蛙的约会：求解线性同余方程。
- P3811 模意义下的乘法逆元：求多个数的模逆元。
- P2613 有理数取余：利用费马小定理求逆元。

### 个人心得
部分题解提到不想背代码，尝试使用非扩欧的解法，体现了对不同解题思路的探索精神。在解题过程中，深入理解算法原理，灵活运用定理和公式，有助于找到更合适的解法。 

---
处理用时：34.12秒
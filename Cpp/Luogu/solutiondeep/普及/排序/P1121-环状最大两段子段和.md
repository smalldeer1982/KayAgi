# 题目信息

# 环状最大两段子段和

## 题目描述

给出一段长度为 $n$ 的环状序列 $a$，即认为 $a_1$ 和 $a_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
9```

# AI分析结果

### 综合分析与结论
这些题解主要围绕环状最大两段子段和问题展开，核心思路是将问题分类讨论，分为两段都不跨环和有一段跨环两种情况。对于不跨环情况，通常通过预处理前后缀最大子段和，枚举分界点求解；对于跨环情况，转化为求最小两段子段和，用总和减去该值。部分题解还提及特殊情况的特判，如序列全为负数或只有一个正数。

算法复杂度方面，多数题解达到了 $O(n)$ 的时间复杂度，少数使用线段树的题解为 $O(nlogn)$。

### 所选题解
- **作者：Develop（5星）**
    - **关键亮点**：思路全面且系统，不仅详细解答本题，还拓展了最大子段和的多种变式，对各种情况的复杂度分析和算法思路阐述清晰，有助于读者建立完整的知识体系。
    - **个人心得**：无
- **作者：I_AM_HelloWord（4星）**
    - **关键亮点**：思路清晰，通过枚举可能情况将问题简化，对特殊情况的分析和处理详细，代码简洁易懂。
    - **个人心得**：提到对特例 `4 -1 1 -1 -1` 的思考，认识到只有一个正数时将数字取反求最大子序列会出现问题，从而进行特判。
- **作者：zhy137036（4星）**
    - **关键亮点**：从最大子段和问题逐步推导到本题，逻辑连贯，对每种情况的代码实现和解释详细，方便读者理解。
    - **个人心得**：无

### 重点代码及核心实现思想
#### Develop
```cpp
// 环状最大两段子段和 O(n) 解法
// 情况1：不过端点，正常求最大两段子段和
// 情况2：过端点，求最小两段子段和，用总和减去
// 最后取两种情况的最大值
```
核心思想：先求一遍两段最大子段和，再对整个序列取反，求一遍两段最小子段和（此时取反后求最大子段和），用总和减去最小子段和得到跨端点的两段最大子段和，最后取两种情况的最大值。

#### I_AM_HelloWord
```cpp
int query(){
    int res=-INF;
    for (int i=1;i<=n;i++)f[i]=max(f[i-1],0)+a[i];
    for (int i=n;i>0;i--)g[i]=max(g[i+1],0)+a[i];
    for (int i=1;i<=n;i++)f[i]=max(f[i-1],f[i]);
    for (int i=n;i>0;i--)g[i]=max(g[i+1],g[i]);
    for (int i=1;i<n;i++)res=max(res,f[i]+g[i+1]);
    return res;
}
```
核心思想：通过 `query` 函数求最大两段子段和，先分别预处理前后缀最大子段和，再枚举分界点得到最大两段子段和。对特殊情况（只有一个正数）进行特判。

#### zhy137036
```cpp
int getmin(int*arr,int l){
    mf[1]=arr[1];
    for(int i=2;i<=l;i++)mf[i]=min(mf[i-1]+arr[i],min(arr[i],0));
    for(int i=2;i<=l;i++)mf[i]=min(mf[i-1],mf[i]);
    mb[l]=arr[l];
    for(int i=l-1;i>0;i--)mb[i]=min(mb[i+1]+arr[i],min(arr[i],0));
    for(int i=l-1;i>0;i--)mb[i]=min(mb[i+1],mb[i]);
    int ans=(1ll<<31ll)-1ll;
    for(int i=2;i<l;i++)ans=min(ans,mf[i-1]+mb[i+1]);
    return ans;
}
```
核心思想：`getmin` 函数用于求最小两段子段和，通过预处理前后缀最小子段和，枚举分界点得到最小两段子段和，最后用总和减去该值得到跨端点的两段最大子段和。

### 最优关键思路或技巧
- **分类讨论**：将环状最大两段子段和问题分为不跨环和跨环两种情况，分别求解，降低问题复杂度。
- **取反转化**：通过将序列取反，把求最小两段子段和问题转化为求最大两段子段和问题。
- **预处理前后缀**：预处理前后缀最大（小）子段和，可在 $O(n)$ 时间内枚举分界点求解。

### 可拓展之处
同类型题或类似算法套路：
- 非环状序列的多段子段和问题，可参考题解中最大 $m$ 段子段和的解法。
- 序列带修改操作的最大子段和问题，可采用线段树解决，如题目 [P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)。
- 子段长度有约束条件的最大子段和问题，如子段长度不大于 $m$ 或不小于 $m$ 的情况。

### 推荐题目
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：基础的最大子段和问题，是本题的前置知识。
- [P2642 双子序列最大和](https://www.luogu.com.cn/problem/P2642)：非环状的最大两段子段和问题，可作为本题的简化版练习。
- [P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)：涉及序列修改操作的最大子段和问题，可使用线段树解决。

### 个人心得总结
- I_AM_HelloWord 在解题过程中遇到特例 `4 -1 1 -1 -1`，意识到只有一个正数时将数字取反求最大子序列会出现问题，从而进行特判，提醒我们在解题时要注意特殊情况的分析。
- gravf 强调要注意题目中“连续不重叠且非空的两段”这一条件，否则会导致结果错误，如数据 `5 -1 -4 -5 3 -3`，不注意该条件会得出错误答案。这提醒我们在解题时要仔细审题，避免因忽略关键条件而犯错。 

---
处理用时：45.35秒
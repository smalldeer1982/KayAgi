# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕拓扑排序和动态规划（DP）展开，部分使用记忆化搜索，核心目标是解决有向无环图（DAG）中以每个点为终点的最长路径问题。拓扑排序确保在动态规划时满足无后效性，记忆化搜索则通过记录已搜索结果避免重复计算。

### 所选题解
- **作者：星星之火（5星）**
    - **关键亮点**：思路清晰，详细解释了拓扑排序与DP结合的原因，代码注释完善，运行时间和代码实现都较为优秀。
    - **核心代码**：
```cpp
void topsort()
{
    queue <int> q;
    for (int i=1;i<=n;i++)
        if (ru[i]==0) {
            q.push(i);
            ts[++tot]=i;
        }
    while (!q.empty())
    {
        int u=q.front();q.pop();
        for (int i=head[u];i;i=edge[i].next)
        {
            int v=edge[i].to;
            ru[v]--;
            if (ru[v]==0) {
                q.push(v);ts[++tot]=v;
            }
        }
    }
}
for (int i=1;i<=n;i++) dp[i]=1;
for (int i=1;i<=n;i++)
{
    int u=ts[i];
    for (int j=head[u];j;j=edge[j].next)
    {
        int v=edge[j].to;
        dp[v]=max(dp[v],dp[u]+1);
    }
}
```
    - **核心实现思想**：先进行拓扑排序，将入度为0的点入队并加入拓扑序列，不断更新入度，直到队列为空。然后初始化DP数组，按拓扑序遍历，更新每个点的DP值。

- **作者：_ZZH（4星）**
    - **关键亮点**：代码简洁，在拓扑排序的同时进行DP，减少额外操作。
    - **核心代码**：
```cpp
for(int i=1;i<=m;i++)
{
    int x,y;
    scanf("%d%d",&x,&y);
    e[++total].to=y;
    e[total].next=lin[x];
    lin[x]=total;
    in[y]++;
}
for(int i=1;i<=n;i++)
    if(in[i]==0)
    {
        f[i]=1;
        q.push(i);
    }
while(!q.empty())
{
    int cnt=q.front();q.pop();
    for(int i=lin[cnt];i;i=e[i].next)
    {
        f[e[i].to]=max(f[e[i].to],f[cnt]+1);
        if(--in[e[i].to]==0)q.push(e[i].to);	
    }	
}
```
    - **核心实现思想**：读入边信息，记录入度。将入度为0的点入队并初始化DP值，在拓扑排序过程中更新DP值。

- **作者：归山_（4星）**
    - **关键亮点**：采用逆向思维，反向存图后使用记忆化搜索，思路独特，代码简洁。
    - **核心代码**：
```cpp
void add(int x,int y){
    tot++;
    e[tot].to=y;
    e[tot].next=head[x];
    head[x]=tot;
}
int dfs(int x){
    if(dp[x]!=-1) return dp[x];
    dp[x]=1;
    for(int i=head[x];i;i=e[i].next){
        int y=e[i].to;
        dp[x]=max(dp[x],dfs(y)+1);
    }
    return dp[x];
}
```
    - **核心实现思想**：反向存图，使用记忆化搜索，若该点已搜索过则直接返回结果，否则更新该点的DP值。

### 最优关键思路或技巧
- **拓扑排序与DP结合**：利用拓扑排序的性质，保证动态规划的无后效性，按拓扑序更新DP值。
- **记忆化搜索**：记录已搜索结果，避免重复计算，提高效率。
- **逆向思维**：反向存图，将终点问题转化为起点问题，简化思路。

### 可拓展之处
同类型题如DAG上的最长路径、最短路径问题，类似算法套路包括拓扑排序与DP结合、记忆化搜索等。

### 推荐题目
- [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)
- [P1137 旅行计划](本题)
- [P3243 [HNOI2015]菜肴制作](https://www.luogu.com.cn/problem/P3243)

### 个人心得摘录与总结
- **Space_Gold_Trash**：开始用SPFA只从城市1出发提交全WA，分析后发现出度为0的城市不止一座，应存入所有入度为0的城市。总结：做题要考虑全面，不能被题目部分描述误导。
- **EricWay1024**：做这题花了一晚上，认识到拓扑排序是动态规划状态转移方程的要求，求每个点的DP值时要保证指向它的点的DP值已求出。总结：理解算法原理对解题很重要。

---
处理用时：36.74秒
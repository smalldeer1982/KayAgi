# 题目信息

# [NOIP 2010 普及组] 导弹拦截

## 题目描述

经过 $11$ 年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 $0$ 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。

某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。

## 说明/提示

两个点 $(x_1,y_1),(x_2,y_2)$ 之间距离的平方是 $(x_1-x_2)^2+(y_1-y_2)^2$。

两套系统工作半径 $r_1,r_2$ 的平方和，是指 $r_1,r_2$ 分别取平方后再求和，即 $r_1^2+r_2^2$。

### 样例 1 说明

样例 $1$ 中要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $18$ 和 $0$。

### 样例 2 说明

样例 $2$ 中的导弹拦截系统和导弹所在的位置如下图所示。要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $20$ 和 $10$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cvgomt03.png)

【数据范围】。

- 对于 $10\%$ 的数据，$N=1$。
- 对于 $20\%$ 的数据，$1\le N\le 2$。
- 对于 $40\%$ 的数据，$1\le N\le 100$。
- 对于 $70\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 10^5$，且所有坐标分量的绝对值都不超过 $1000$。

NOIP2010 普及组 第三题

## 样例 #1

### 输入

```
0 0 10 0
2
-3 3
10 0```

### 输出

```
18```

## 样例 #2

### 输入

```
0 0 6 0
5
-4 -2
-2 3
4 0
6 -2
9 1```

### 输出

```
30```

# AI分析结果

### 综合分析与结论
这些题解大多采用贪心和枚举的思路解决导弹拦截问题。核心是将导弹按到一个系统的距离排序，枚举该系统拦截的最远导弹，计算另一系统拦截剩余导弹的最大半径，从而得到最小使用代价。

### 所选题解
- **作者：TEoS（5星）**
    - **关键亮点**：思路清晰，以蒟蒻视角讲解，代码注释详细，变量初始化和处理过程明确，适合初学者理解。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++)
{
    cin>>x[i]>>y[i];
    di[i].d1=pow(x[i]-x11,2)+pow(y[i]-y11,2);
    di[i].i=i;
}
sort(di+1,di+n+1,cmp);
for(int i=n;i>0;i--)
{
    int a;
    a=pow(x[di[i].i]-x22,2)+pow(y[di[i].i]-y22,2);
    di[i].d2=max(a,di[i+1].d2);
}
for(int i=0;i<=n;i++)
{
    int a;
    a=di[i].d1+di[i+1].d2;
    minn=min(a,minn);
}
```
    - **核心思想**：先计算每个导弹到两个系统的距离，按到1号系统距离排序，预处理出每个位置之后到2号系统的最大距离，最后枚举1号系统拦截的最远导弹，取最小代价。

- **作者：暗ざ之殇（4星）**
    - **关键亮点**：思路详细，配有示意图，代码中使用读入优化，对关键步骤有详细注释。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++)
{
    x=read();y=read();
    a[i].dis1=(x-x1)*(x-x1)+(y-y11)*(y-y11);
    a[i].id=i;
    dis2[i]=(x-x2)*(x-x2)+(y-y2)*(y-y2);
}
sort(a+1,a+1+n,cmp1);
minx=a[n].dis1;
nxt[n]=dis2[a[n].id];
for(int i=n-1;i>=1;i--)
    if(dis2[a[i].id]>nxt[i+1]) nxt[i]=dis2[a[i].id];
    else nxt[i]=nxt[i+1];
for(int i=n-1;i>=1;i--)
    minx=min(minx,a[i].dis1+nxt[i+1]);
printf("%d",min(minx,nxt[1]));
```
    - **核心思想**：计算距离并排序，预处理出每个位置之后到2号系统的最大距离，枚举1号系统拦截的导弹数量，取最小代价，同时考虑2号系统全部拦截的情况。

- **作者：Zh_terminal（4星）**
    - **关键亮点**：思路简洁清晰，明确给出时间复杂度，代码避免使用浮点数，核心代码简洁。
    - **核心代码**：
```cpp
sort(a+1,a+N+1,cmp);
int ans=a[N].d1;
int d=0;
for(int i=N;i>=1;i--){
    d=max(d,a[i].d2);
    int ans2=a[i-1].d1+d;
    ans=min(ans,ans2);
}
```
    - **核心思想**：按到系统一的距离排序，枚举系统一拦截的最远导弹，更新系统二的最大半径，取最小代价。

### 最优关键思路或技巧
- **排序枚举**：将导弹按到一个系统的距离排序，枚举该系统拦截的最远导弹，可有效减少枚举范围。
- **预处理后缀最大值**：提前计算出每个位置之后到另一个系统的最大距离，可在枚举时 $O(1)$ 获取，优化时间复杂度。
- **避免浮点数**：直接使用距离的平方进行计算和比较，避免了开方带来的精度问题。

### 拓展思路
同类型题可考虑多个拦截系统或动态改变系统位置的情况。类似算法套路可用于资源分配问题，如多个服务器处理任务，通过排序和枚举找到最优分配方案。

### 推荐题目
- P1094 [NOIP2007 普及组] 纪念品分组
- P1223 排队接水
- P1090 [NOIP2004 提高组] 合并果子

### 个人心得摘录与总结
- **作者：暗ざ之殇**：该题耗时较长，意识到自己在DP方面需要加强训练，采用暴力枚举和预处理解决问题。总结：遇到难题可先尝试基础方法，同时要明确自身薄弱点并加强训练。
- **作者：NewSjf**：起初贪心策略只得到60分，通过随机打乱点的顺序多次贪心取最优值AC。总结：当常规贪心策略不奏效时，可尝试随机化算法优化结果。
- **作者：qhr2023**：原代码因枚举范围问题被hack，意识到枚举时要考虑全被二号系统拦截的情况。总结：在枚举问题中要仔细考虑边界情况，确保枚举全面。 

---
处理用时：33.64秒
# 题目信息

# 日志分析

## 题目描述

M 海运公司最近要对旗下仓库的货物进出情况进行统计。目前他们所拥有的唯一记录就是一个记录集装箱进出情况的日志。该日志记录了两类操作：第一类操作为集装箱入库操作，以及该次入库的集装箱重量；第二类操作为集装箱的出库操作。这些记录都严格按时间顺序排列。集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为当前在仓库里所有集装箱中最晚入库的集装箱。

出于分析目的，分析人员在日志中随机插入了若干第三类操作――查询操作。分析日志时，每遇到一次查询操作，都要报告出当前仓库中最大集装箱的重量。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，有 $N \le 10$；
- 对于 $40\%$ 的数据，有 $N \le 1000$；
- 对于 $100\%$ 的数据，有 $1 \le N \le 200000$，$1 \le X \le 10^8$。


## 样例 #1

### 输入

```
13
0 1
0 2
2
0 4
0 2
2
1
2
1
1
2
1
2
```

### 输出

```
2
4
4
1
0
```

# AI分析结果

### 综合分析与结论
本题核心是模拟栈操作，难点在于高效查询栈内最大值。各题解主要思路是维护一个额外的数据结构来记录栈内最大值，避免每次查询都遍历栈。以下是对不同题解的对比分析：
|作者|思路|算法要点|解决难点方式|评分|
| ---- | ---- | ---- | ---- | ---- |
|medusa|用数组`f[i]`记录栈中前`i`个元素最大值|入栈时更新`f[t]=max(f[t - 1], x)`，出栈`t--`，查询输出`f[t]`|数组记录最大值，避免遍历|5星|
|引领天下|维护单调栈，小元素不存储|操作分情况处理，小元素不入栈|单调栈减少存储|4星|
|buickboy|使用辅助栈记录最大值|主栈入栈时，辅助栈根据情况压入最大值|辅助栈记录最大值|4星|

### 所选题解
- **作者：medusa（5星）**
    - 关键亮点：思路清晰，代码简洁，通过数组记录最大值，避免了每次查询时遍历栈，时间复杂度为$O(n)$。
    - 核心代码：
```cpp
#include<iostream>   
#include<cstdio>   
#include<cmath>   
using namespace std;   
int f[200001],n,x,y,t=0;   
int main()   
{   
    cin>>n;   
    f[0]=0;   
    for (int i=1; i<=n; i++)   
    {   
        cin>>x;   
        if (x==0)    
        {   
            cin>>y;   
            t++;   
            f[t]=max(f[t-1],y);   
        }   
        if (x==1) if (t!=0) t--;   
        if (x==2) cout<<f[t]<<endl;   
    }   
    return 0;   
}  
```
- **作者：引领天下（4星）**
    - 关键亮点：提出维护单调栈的思路，减少不必要的元素存储，优化了空间复杂度。
    - 核心思路：操作分情况处理，对于操作0，若输入数小于之前最大值，不存储该数；操作1直接栈顶减1；操作2直接输出栈顶（最大值）。
- **作者：buickboy（4星）**
    - 关键亮点：使用辅助栈记录最大值，逻辑清晰，易于理解和实现。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
stack<int>a;
stack<int>b;
int n,m,x;
int main()
{
    scanf("%d",&n);
    while(n--)
    {
        scanf("%d",&m);
        if(m==0)
        {
            scanf("%d",&x);
            a.push(x);
            if(b.empty()||x>b.top())
                b.push(x);
            else b.push(b.top());
        }
        else if(m==1)
        {
            a.pop();
            b.pop();
        }
        else
        {
            if(b.empty()) printf("0\n");
            else printf("%d\n",b.top());        
        }           
    }
    return 0;
}
```

### 最优关键思路或技巧
- **数据结构**：使用数组或辅助栈记录栈内最大值，避免遍历栈，将查询最大值的时间复杂度从$O(n)$优化到$O(1)$。
- **算法优化**：维护单调栈，减少不必要的元素存储，优化空间复杂度。
- **思维方式**：通过预处理记录关键信息，避免重复计算。

### 可拓展之处
同类型题如滑动窗口问题，可使用单调队列维护区间最大值。类似算法套路是维护一个额外的数据结构记录关键信息，避免重复计算。

### 推荐题目
- P1886 滑动窗口 /【模板】单调队列
- P1440 求m区间内的最小值
- P2032 扫描

### 个人心得摘录与总结
- **准点的星辰**：第一次代码直接模拟超时，后用两个优先队列和一个栈AC。总结出要保证栈与队列中的数据完全一致才能保证正确性。
- **juruo_zjc**：一开始用纯暴力只AC几个点，后尝试优先队列处理弹出元素有麻烦，最后用类似DP的方法解决。体会到暴力可能超时，要尝试更优算法。 

---
处理用时：27.47秒
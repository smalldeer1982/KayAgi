# 题目信息

# 刷题

## 题目描述

NOIP 临近了，小 A 却发现他已经不会写题了。好在现在离竞赛还有一段时间，小 A 决定从现在开始夜以继日地刷题。也就是说小 A 废寝忘食，一天二十四小时地刷题。

今天的日期（时间）是 yyyy 年 mm 月 dd 日 hh 时 MM 分，考试的时间是 yyyy2 年 mm2 月 dd2 日 hh2 时 MM2 分。这之间的所有时间小 A 都用来刷题了，那么考试之前他最多能刷多少题呢？注意哦，考虑闰年。

时间紧张小 A 只管数量不管质量。当然有的题目容易一些，有的题目难一些。根据小 A 的经验，他能一眼看出写出某一个题目需要的时间，以分钟记。

现在给出洛谷 Online Judge 的题目列表，请你挑出最多的题目使小A能在竞赛前写出来。

我们假设从远古到未来，历法的表示与现在一样。


## 样例 #1

### 输入

```
2
1
1
2007-06-23-11:59
2007-06-23-12:00```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
本题主要考查时间计算和贪心算法的应用。各题解的核心思路都是先计算出两个时间点之间的总分钟数，再对题目所需时间进行排序，最后用贪心算法选择尽可能多的题目。

### 思路对比
- **时间计算**：
    - 部分题解以 0000 年 1 月 1 日 00:00 为基准，分别计算起始时间和结束时间到基准的分钟数，再求差值。
    - 部分题解逐年、逐月、逐日累加或累减，多退少补来计算时间差。
    - 还有题解使用 Java 的 Calendar 类或 Date 类来处理时间。
- **贪心算法**：所有题解都对题目所需时间进行排序，优先选择耗时少的题目，直到剩余时间不足。

### 算法要点
- **闰年判断**：多数题解使用 `year % 4 == 0 && year % 100!= 0 || year % 400 == 0` 来判断闰年。
- **时间转换**：将年、月、日、时、分转换为分钟，方便计算时间差。
- **贪心策略**：对题目按耗时排序，依次选择，直到无法选择为止。

### 解决难点
- **时间计算复杂**：通过基准时间、多退少补等方法简化计算。
- **数据范围大**：使用 `long long` 或 `unsigned long long` 来避免溢出。

### 高评分题解
1. **作者：傅思维666（4星）**
    - **关键亮点**：思路清晰，详细介绍了两种时间处理方法，代码注释清晰。
    - **个人心得**：无
    - **核心代码**：
```c++
// 时间计算部分
for(int i=start[1];i<endd[1];i++) {
    if(check(i)) time+=366;
    else time+=365;
}
if(check(start[1]))
    for(int i=1;i<start[2];i++) time-=m2[i];
else
    for(int i=1;i<start[2];i++) time-=m1[i];
if(check(endd[1]))
    for(int i=1;i<endd[2];i++) time+=m2[i];
else
    for(int i=1;i<endd[2];i++) time+=m1[i];
for(int i=1;i<start[3];i++) time--;
for(int i=1;i<endd[3];i++) time++;
time=time*24*60;
time-=60*start[4]+start[5];
time+=60*endd[4]+endd[5];
```
核心思想：先逐年累加天数，再根据闰年情况调整起始年和结束年的前几个月的天数，最后加上日、时、分的分钟数。

2. **作者：ztzshiwo001219（4星）**
    - **关键亮点**：以 0000 年 1 月 1 日 00:00 为基准点，思路简洁，代码结构清晰。
    - **个人心得**：无
    - **核心代码**：
```cpp
// 计算时间差
LL calculate() {
    int flag1=pdrn(year1),flag2=pdrn(year2);
    for(int i=0;i<year1;i++)
        if(pdrn(i)) sj1+=366*1440;
        else sj1+=365*1440;
    LL monthtime=0;
    for(int i=month1-1;i;i--) monthtime+=Day[flag1][i]*60*24;
    sj1+=minute1+hour1*60+(day1-1)*60*24+monthtime;
    for(int i=0;i<year2;i++)
        if(pdrn(i)) sj2+=366*1440;
        else sj2+=365*1440;
    monthtime=0;
    for(int i=month2-1;i;i--) monthtime+=Day[flag2][i]*60*24;
    sj2+=minute2+hour2*60+(day2-1)*60*24+monthtime;
    return sj2-sj1;
}
```
核心思想：分别计算起始时间和结束时间到基准点的分钟数，再求差值。

3. **作者：wangzeyu（4星）**
    - **关键亮点**：封装了 `Calender` 类，提高代码的复用性和可读性。
    - **个人心得**：在计算每月天数时，要注意判断的是当前月 `m` 的天数，而不是 `this->month` 的天数，否则会 WA。
    - **核心代码**：
```C++
// 获取标准时间
unsigned long long getStandardTime(void) {
    unsigned long long res=0ull;
    for(unsigned y=0;y<this->year;y++) {
        if(is_runnian(y)) res+=a_day*366ull;
        else res+=a_day*365ull;
    }
    for(unsigned m=1;m<this->month;m++) {
        res+=getDaysInMonth(this->year,m)*a_day;
    }
    for(unsigned d=1;d<this->day;d++) res+=a_day;
    for(unsigned h=0;h<this->hour;h++) res+=a_hour;
    for(unsigned m=0;m<this->minute;m++) res+=a_minute;
    res+=this->second;
    return res;
}
```
核心思想：通过循环累加年、月、日、时、分、秒的时间，得到从基准点到当前时间的总秒数。

### 最优关键思路或技巧
- **选择合适的基准时间**：以 0000 年 1 月 1 日 00:00 为基准，分别计算起始时间和结束时间到基准的时间，再求差值，简化时间计算。
- **封装类**：将时间处理相关的功能封装到类中，提高代码的复用性和可读性。

### 可拓展之处
- **同类型题**：涉及日期和时间计算的题目，如计算两个日期之间的工作日天数、判断某个日期是星期几等。
- **类似算法套路**：贪心算法在资源分配问题中的应用，如活动选择问题、背包问题等。

### 推荐题目
- P1090 [合并果子](https://www.luogu.com.cn/problem/P1090)：考查贪心算法的应用。
- P1223 [排队接水](https://www.luogu.com.cn/problem/P1223)：考查贪心算法和排序。
- P1803 [凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)：考查贪心算法和区间问题。

### 个人心得总结
- **Deny_小田**：一开始用一分钟一分钟累加的方法超时，后来采用以 0000 年 1 月 1 日 00:00 为基准计算时间差的方法，部分点仍需打表才能通过。
- **tllwtg**：遇到数据范围大导致超时的问题，使用打表的方法 AC。
- **wangzeyu**：在计算每月天数时，要注意判断的是当前月的天数，而不是 `this->month` 的天数，否则会 WA。

---
处理用时：46.96秒
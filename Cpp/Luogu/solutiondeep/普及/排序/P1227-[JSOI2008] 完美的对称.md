# 题目信息

# [JSOI2008] 完美的对称

## 题目描述

在峰会期间，必须使用许多保镖保卫参加会议的各国代表。代表们除了由他自己的随身保镖保护外，组委会还指派了一些其他的特工和阻击手保护他们。为了使他们的工作卓有成效，使被保卫的人的安全尽可能得到保障，保镖被分配到被保护人的各个方向。

保镖的最佳站立位置应该是这样的：被保护人应站在所有保镖的对称中心。但是，只要被保护人一移动，保镖就很难根据要人的新位置调整位置。大多数的特工都很难对此作出实时调整。

因此，安全部长决定将该过程逆转一下，保镖先站好自己的位置，然后要人在他们的对称中心找到合适的位置。如果要人随便走动，我们就对他的安全不必负责。

你的工作是使这个过程自动操作。给出一组 $N$ 个点（保镖的位置），你要找出它们的对称中心 $S$，在这儿被保护人将相对安全。下面以此类推。

首先我们给定一点 $A$ 以及对称中心 $S$，点 $A'$ 是点 $A$ 以 $S$ 为对称中心形成的像点，即点 $S$ 是线段 $AA'$ 的对称中心。

点阵组（$X$）以 $S$ 为中心的像点是由每个点的像点组成的点阵组。$X$ 是用来产生对称中心 $S$ 的，即点阵 $X$ 以 $S$ 为中心的像点的集合即为点阵 $X$ 本身。

![](https://cdn.luogu.com.cn/upload/image_hosting/trym53o8.png)


## 说明/提示

JSOI2008 第二轮。


## 样例 #1

### 输入

```
8

1 10

3 6

6 8

6 2

3 -4

1 0

-2 -2

-2 4

```

### 输出

```
V.I.P. should stay at (2.0,3.0).```

# AI分析结果

### 综合分析与结论
这些题解主要围绕找出一组点的对称中心并验证其是否为所有点的对称中心展开。多数题解采用排序的方法，将点按一定规则排序后，通过配对计算中点来确定对称中心并验证；部分题解利用数学推导，通过所有点坐标之和除以点数来计算可能的对称中心，再用最大最小点验证。

### 所选题解
- **作者：盖矣斌峥（5星）**
    - **关键亮点**：思路清晰，代码简洁易懂，详细说明了排序和配对验证的过程，考虑了点数量为奇数的情况。
    - **核心代码**：
```cpp
struct point{
    double x,y;
}a[20005];
bool cmp(point &x,point &y)
{
    if(x.y==y.y)return x.x<y.x;
    return x.y<y.y;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%lf%lf",&a[i].x,&a[i].y);
    sort(a+1,a+n+1,cmp);
    point t;
    t.x=(a[1].x+a[n].x)/2.0;
    t.y=(a[1].y+a[n].y)/2.0;
    for(int i=1;i<=(n+1)/2;i++)
    {
        point tmp;
        tmp.x=(a[i].x+a[n-i+1].x)/2.0;
        tmp.y=(a[i].y+a[n-i+1].y)/2.0;
        if(t.x!=tmp.x||t.y!=tmp.y){
            printf("This is a dangerous situation.");
            return 0;
        }
    }
    printf("V.I.P. should stay at (%.1f,%.1f).",t.x,t.y);
    return 0;
}
```
    - **核心思想**：先将点按y坐标从小到大排序，若y坐标相同则按x坐标从小到大排序。计算第一点和最后一点的中点作为初始对称中心，然后遍历排序后的点，依次计算配对点的中点，若与初始对称中心不同则输出危险信息，否则输出对称中心坐标。

- **作者：我是小何子啊（4星）**
    - **关键亮点**：思路明确，对解题思路有详细解释，代码结构清晰。
    - **核心代码**：
```cpp
struct node{
    double x,y;
}f[100001];
bool cmp(node x,node y)
{
    if(x.y==y.y) return x.x<y.x;
    return x.y<y.y;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%lf%lf",&f[i].x,&f[i].y);
    sort(f+1,f+n+1,cmp);
    double mx=(f[1].x+f[n].x)/2;
    double my=(f[1].y+f[n].y)/2;
    for(int i=2;i<=n/2;++i){
        double xi=(f[i].x+f[n-i+1].x)/2;
        double yi=(f[i].y+f[n-i+1].y)/2;
        if(mx!=xi||my!=yi){
            printf("This is a dangerous situation!");
            return 0;
        }
    }
    printf("V.I.P. should stay at (%.1f,%.1f).",mx,my);
    return 0;
}
```
    - **核心思想**：将点按y坐标排序，计算最大最小点的中点作为对称中心，然后遍历其他配对点，若中点与初始对称中心不同则输出危险信息，否则输出对称中心坐标。

- **作者：YitsuHolo（4星）**
    - **关键亮点**：考虑了浮点数比较的精度问题，对排序和验证过程有清晰的思路解释。
    - **核心代码**：
```cpp
const double eps=0.0000001;
struct node
{
    double x,y;
};
node point[20010];
bool cmp1(node a,node b)
{
    if(a.x>=b.x+eps || a.x<=b.x-eps)
        return a.x<b.x;
    else
        return a.y<b.y;
}
int main()
{
    scanf("%d",&n);
    double xx,yy;
    double maxx=-10000000,maxy=-10000000,minx=10000000,miny=10000000;
    for(int i=1;i<=n;i++)
    {
        scanf("%lf%lf",&xx,&yy);
        maxx=max(maxx,xx);
        maxy=max(maxy,yy);
        minx=min(minx,xx);
        miny=min(miny,yy);
        point[i].x=xx;
        point[i].y=yy;
    }
    node mid;
    mid.x=(minx+maxx)/2;
    mid.y=(miny+maxy)/2;
    sort(point+1,point+n+1,cmp1);
    for(int i=1;i<=n/2+n%2;i++)
    {
        double tx1=point[i].x;
        double ty1=point[i].y;
        double tx2=point[n+1-i].x;
        double ty2=point[n+1-i].y;
        if( (tx1+tx2)/2 < mid.x-eps || (tx1+tx2)/2 > mid.x+eps || (ty1+ty2)/2 < mid.y-eps || (ty1+ty2)/2 > mid.y+eps )
        {
            printf("This is a dangerous situation!");
            return 0;
        }
    }
    printf("V.I.P. should stay at (%.1lf,%.1lf).",mid.x,mid.y);
    return 0;
}
```
    - **核心思想**：先找出横纵坐标的最大最小值，计算其中点作为对称中心。将点按x坐标排序，若x坐标相同则按y坐标排序。遍历排序后的点，验证配对点的中点是否与对称中心在精度范围内相等，若不相等则输出危险信息，否则输出对称中心坐标。

### 最优关键思路或技巧
- **排序配对法**：将点按一定规则排序后，最小点与最大点配对，次小点与次大点配对，依次计算中点，若所有中点相同则该中点为对称中心。
- **数学推导法**：若存在对称中心，其坐标为所有点坐标之和除以点数，再用最大最小点验证。
- **精度处理**：在比较浮点数时，使用一个极小的误差值`eps`来判断是否相等，避免浮点数误差导致的错误判断。

### 可拓展之处
同类型题可能会涉及更高维度的对称中心求解，或者在对称条件上进行变化，如旋转对称等。类似算法套路可用于解决其他需要配对计算的问题，如寻找数组中的互补元素等。

### 推荐题目
- P1090 [NOIP2004 提高组] 合并果子
- P1168 [NOIP2007 提高组] 中位数
- P1271 [深基9.例1] 选举学生会

### 个人心得摘录与总结
- **睿屿青衫**：指出输出要保留一位小数，需使用`double`或`float`型，不能用`int`，避免输出错误。
- **蒟蒻CGZ**：强调输出要保留一位小数，要用`double`型，给出了错误和正确的输出示例。这些心得提醒我们在处理此类问题时要注意数据类型和输出格式，避免因细节问题导致错误。 

---
处理用时：46.46秒
# 题目信息

# 智力大冲浪

## 题目描述

小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者 $m$ 元。先不要太高兴，因为这些钱还不一定都是你的。接下来主持人宣布了比赛规则：

首先，比赛时间分为 $n$ 个时段，它又给出了很多小游戏，每个小游戏都必须在规定期限 $t_i$ 前完成。如果一个游戏没能在规定期限前完成，则要从奖励费 $m$ 元中扣去一部分钱 $w_i$，$w_i$ 为自然数，不同的游戏扣去的钱是不一样的。当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。主持人只是想考考每个参赛者如何安排组织自己做游戏的顺序。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！注意：比赛绝对不会让参赛者赔钱!


## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 500$，$1 \le m \le 5 \times 10^5$，$1 \le t_i \le n$，$1 \le w_i \le 1000$。

## 样例 #1

### 输入

```
10000
7
4 2 4 3 1 4 6
70 60 50 40 30 20 10
```

### 输出

```
9950```

# AI分析结果

### 综合分析与结论
这些题解主要围绕贪心算法解决该问题，部分使用了搜索、动态规划等算法。贪心算法的核心思路是优先完成扣款多的任务，并尽量将任务安排在期限的最后时刻，以减少对其他任务的影响。部分题解还使用了优先队列、并查集、树状数组等数据结构进行优化。

### 所选题解
- **作者：ShineEternal（5星）**
    - **关键亮点**：思路清晰，详细分析了错误贪心和正确贪心的区别，代码注释详细，还给出了旧版题解作为对比。
    - **核心代码**：
```cpp
struct ben
{
    int t,val;
}a[505];
int vis[505];
int cmp(const ben &a,const ben &b)
{
    return a.val>b.val;
}
int main()
{
    int m,n;
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i].t);
    } 
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i].val);
    } 
    sort(a+1,a+n+1,cmp);
    int ans=0,t=0;
    for(int i=1;i<=n;i++)
    {
        int tag=0;
        for(int j=a[i].t;j;j--)
        {
            if(vis[j]==0)
            {
                vis[j]=1;
                tag=1;
                break;
            }
        }
        if(tag==0)
        {
            for(int j=n;j;j--)
            {
                if(vis[j]==0)
                {
                    vis[j]=1;
                    break;
                }
            }
            ans+=a[i].val;
        }
    }
    printf("%d\n",m-ans);
    return 0;
}
```
    - **核心实现思想**：先将任务按扣款数从大到小排序，然后遍历每个任务，尝试将其安排在期限的最后时刻，如果该时刻已被占用，则向前寻找未被占用的时刻。若找不到合适的时刻，则该任务无法完成，累加扣款数。

- **作者：三问不知、、（4星）**
    - **关键亮点**：思路简洁明了，代码结构清晰，易于理解。
    - **核心代码**：
```c
struct lao{
    int t,f;
}a[300000];
bool used[100000]={0};
bool cmp(const lao &x,const lao &y)
{
    return x.f>y.f;
}
int main()
{
    int s=0,b;
    int m,n,i,j;
    scanf("%d%d",&m,&n);
    for(i=1;i<=n;i++)
        scanf("%d",&a[i].t);
    for(i=1;i<=n;i++)
        scanf("%d",&a[i].f);
    sort(a+1,a+1+n,cmp);
    for(i=1;i<=n;i++)
    {
        for(j=a[i].t;j>=1;j--)
        {
            if(used[j]==0)
            {
                used[j]=1;
                a[i].f=0;
                break;
            }
        }
    }
    for(i=1;i<=n;i++)
        s=a[i].f+s;
    m=m-s;
    printf("%d",m);
}
```
    - **核心实现思想**：同样先将任务按扣款数从大到小排序，然后遍历每个任务，从期限的最后时刻开始向前寻找未被占用的时刻，若找到则标记该时刻已被占用，并将该任务的扣款数置为0。最后累加未完成任务的扣款数，从总奖金中扣除。

- **作者：Deny_小田（4星）**
    - **关键亮点**：对样例进行了详细分析，帮助读者更好地理解题意，代码简洁。
    - **核心代码**：
```cpp
typedef struct _Every{
    int t,w;
}Every;
Every e[Size];
int flag[Size] = {0};
int cmp(Every a,Every b){
    return a.w > b.w;
}
int main(){
    int p,n;
    scanf("%d %d",&p,&n);
    for(int i = 0; i < n; i++) scanf("%d",&e[i].t);
    for(int i = 0; i < n; i++) scanf("%d",&e[i].w);
    sort(e,e+n,cmp);
    for(int i = 0; i < n; i++){
        int h = -1;
        for(int j = e[i].t; j >= 1; j--) if(!flag[j]){ h = j; break; }
        if(h!= -1) flag[h] = 1;
        else p -= e[i].w;
    }
    printf("%d\n",p);
    return 0;
}
```
    - **核心实现思想**：将任务按扣款数从大到小排序，遍历每个任务，从期限的最后时刻开始向前寻找未被占用的时刻，若找到则标记该时刻已被占用，否则扣除该任务的扣款数。

### 最优关键思路或技巧
- **贪心策略**：优先完成扣款多的任务，并尽量将任务安排在期限的最后时刻，以减少对其他任务的影响。
- **数据结构优化**：使用优先队列、并查集、树状数组等数据结构可以优化算法的时间复杂度。

### 可拓展之处
同类型题如任务调度问题、区间覆盖问题等，都可以使用贪心算法解决。类似算法套路包括按某个关键字排序，然后根据贪心策略进行选择。

### 推荐题目
- P1090 [合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法和优先队列的使用。
- P1803 [凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)：考察区间覆盖问题的贪心算法。
- P2240 [部分背包问题](https://www.luogu.com.cn/problem/P2240)：考察贪心算法在背包问题中的应用。

### 个人心得摘录与总结
- **Deny_小田**：注意游戏是在时间段上的，不是说扣钱的游戏需要花费多个单位时间，而是说该游戏可以在某个时间段里玩。
- **EarthGiao**：要注意正序枚举的不可行性，需要倒着枚举，因为后面的任务在前面的时间点都是可以完成的。
- **wancong**：如果罚款数目和超时时间成正比，这题就不能用贪心了，而且至少是蓝题难度。

---
处理用时：42.81秒
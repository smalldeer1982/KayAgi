# 题目信息

# 种树

## 题目背景

一条街的一边有几座房子，因为环保原因居民想要在路边种些树。

## 题目描述

路边的地区被分割成块，并被编号成 $1, 2, \ldots,n$。每个部分为一个单位尺寸大小并最多可种一棵树。

每个居民都想在门前种些树，并指定了三个号码 $b$，$e$，$t$。这三个数表示该居民想在地区 $b$ 和 $e$ 之间（包括 $b$ 和 $e$）种至少 $t$ 棵树。

居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq n \leq 3 \times 10^4$，$1 \leq h \leq 5 \times 10^3$。
- $1 \leq b_i \leq e_i \leq n$，$1 \leq t_i \leq e_i - b_i + 1$。

## 样例 #1

### 输入

```
9
4
1 4 2
4 6 2
8 9 2
3 5 2```

### 输出

```
5
```

# AI分析结果

### 综合分析与结论
本题主要求解满足所有居民种树要求的最少树的数量，题解主要采用贪心和差分约束两种思路。

#### 贪心思路
- **要点**：要使种树数量最少，需让一棵树为多个区间服务，因此尽量在重叠区间种树，而重叠位置通常在区间尾部。先按区间结束位置排序，再依次处理每个区间，统计区间内已种树数量，若不足则从区间尾部补种。
- **难点**：排序规则的确定和区间内种树情况的统计与补种操作。

#### 差分约束思路
- **要点**：通过前缀和将题目条件转化为不等式组，建图后利用最短路或最长路算法求解。
- **难点**：不等式的转化和建图，以及处理超级源点和初始值问题。

### 高评分题解
1. **作者：kpl000（5星）**
    - **亮点**：思路清晰，详细阐述了贪心算法的步骤，代码结构清晰，注释详细。
    - **核心代码**：
```cpp
struct line{int s,e,v;}a[5005],mid;
int n,m,used[30005]={0};
void qsort(int L,int r){...}
void Init(){...}
void Solve()
{
    int i,j,k,ans=0;
    for(i=1;i<=m;i++)
    {
        k=0;
        for(j=a[i].s;j<=a[i].e;j++) if(used[j])k++;
        if(k<a[i].v)
            for(j=a[i].e;j>=a[i].s;j--)
                if(!used[j]){used[j]=1;k++;ans++;if(k==a[i].v)break;}
    }
    cout<<ans<<endl;
}
```
    - **核心思想**：先对区间按结束位置排序，然后遍历每个区间，统计已种树数量，不足则从区间尾部补种。

2. **作者：哔哩哔哩（4星）**
    - **亮点**：思路简洁明了，代码规范，使用标准库函数 `sort` 进行排序。
    - **核心代码**：
```cpp
struct line{int s,e,v;}a[5005];
int n,m,ans=0;
bool used[30005]={0};
bool cmp(line a,line b)
{
    return a.e<b.e;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) scanf("%d%d%d",&a[i].s,&a[i].e,&a[i].v);
    sort(a+1,a+1+m,cmp);
    for(int i=1;i<=m;i++)
    {
        int k=0;
        for(int j=a[i].s;j<=a[i].e;j++) if(used[j]) k++;
        if(k>=a[i].v) continue;
        for(int j=a[i].e;j>=a[i].s;j--)
        {
            if(!used[j])
            {
                used[j]=1;
                k++;
                ans++;
                if(k==a[i].v) break;
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```
    - **核心思想**：同样采用贪心算法，按区间结束位置排序，遍历区间，统计补种。

3. **作者：浅色调（4星）**
    - **亮点**：详细介绍了差分约束的思路和建图方法，代码实现完整。
    - **核心代码**：
```cpp
const int N=100005,inf=23333333;
int n,m,to[N],net[N],w[N],dis[N],h[N],cnt;
bool vis[N];
queue<int>q;
il void add(int u,int v,int c){to[++cnt]=v,net[cnt]=h[u],h[u]=cnt,w[cnt]=c;}
int main(){
    n=gi(),m=gi();
    int u,v,c;
    while(m--){
        u=gi(),v=gi(),c=gi();
        add(u-1,v,c);
    }
    For(i,0,n){
        if(i!=0)add(i-1,i,0),dis[i]=-inf;
        if(i!=n)add(i,i-1,-1);
    }
    q.push(0);
    while(!q.empty()){
        int u=q.front();vis[u]=0;q.pop();
        for(int i=h[u];i;i=net[i])
            if(dis[to[i]]<dis[u]+w[i]){
                dis[to[i]]=dis[u]+w[i];
                if(!vis[to[i]])q.push(to[i]),vis[to[i]]=1;
            }
    }
    cout<<dis[n];
    return 0;
}
```
    - **核心思想**：将题目条件转化为不等式组，建图后使用 `spfa` 算法求最长路。

### 最优关键思路或技巧
- **贪心算法**：按区间结束位置排序，优先在区间尾部种树，可使树被多个区间共用，减少种树总数。
- **差分约束**：利用前缀和将题目条件转化为不等式组，通过建图和最短路/最长路算法求解。

### 可拓展之处
- **同类型题**：涉及区间覆盖、资源分配等问题，要求满足一定条件下的最优解。
- **算法套路**：贪心算法适用于具有贪心选择性质的问题；差分约束可解决由不等式组构成的约束问题。

### 推荐题目
1. [P1993 小 K 的农场](https://www.luogu.com.cn/problem/P1993)：差分约束系统的典型应用。
2. [P3275 [SCOI2011]糖果](https://www.luogu.com.cn/problem/P3275)：涉及差分约束和图论算法。
3. [P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)：直接考察差分约束算法。

### 个人心得摘录与总结
- **最喜欢saber了**：差分约束系统中，若初始化为 0 会导致最短路无法更新，可采用从各个点做 `SPFA` 或设置虚拟源点的方法解决。
- **wjyyy**：最长路中初始化为 0 不能更新 0，可设置虚拟源点降低时间复杂度。
- **magolor**：源点不要设为 0，要设为 `N + 1` 或更大，防止与有意义的点冲突；SPFA 的队列要用循环队列，数组要开大，防止 `RE`。

---
处理用时：43.55秒
# 题目信息

# [NOIP 2011 普及组] 瑞士轮

## 题目背景

在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。

本题中介绍的瑞士轮赛制，因最早使用于$1895$年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。


## 题目描述

$2 \times N$ 名编号为 $1\sim 2N$ 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。

每轮比赛的对阵安排与该轮比赛开始前的排名有关：第$1$ 名和第$2$ 名、第 $3$ 名和第 $4$名、……、第$2K - 1 $名和第$ 2K$名、……  、第$2N - 1 $名和第$2N$名，各进行一场比赛。每场比赛胜者得$1 $分，负者得 $0 $分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。

现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第$ Q$ 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。


## 说明/提示

【样例解释】

 ![](https://cdn.luogu.com.cn/upload/pic/98.png) 

【数据范围】

对于$30\% $的数据，$1 ≤ N ≤ 100$；

对于$50\% $的数据，$1 ≤ N ≤ 10,000 $；

对于$100\%$的数据，$1 ≤ N ≤ 100,000,1 ≤ R ≤ 50,1 ≤ Q ≤ 2N,0 ≤ s_1, s_2, …, s_{2N}≤10^8,1 ≤w_1, w_2 , …, w_{2N}≤ 10^8$。

noip2011普及组第3题。


## 样例 #1

### 输入

```
2 4 2 
7 6 6 7 
10 5 20 15 
```

### 输出

```
1
```

# AI分析结果

### 综合分析与结论
本题主要模拟瑞士轮比赛过程，核心在于每轮比赛后的排序操作。直接使用 `sort` 会超时，因为它会对整个数组重新排序，造成不必要的操作。各题解普遍采用归并排序的思想来优化，利用每轮比赛后胜者组和败者组分别有序的特点，将两组有序数组合并，降低时间复杂度。

### 所选题解
- **作者：皎月半洒花（5星）**
    - **关键亮点**：思路清晰，详细解释了 `sort` 的浪费和归并排序的优势，代码实现规范，有详细注释。
    - **核心代码**：
```cpp
void merge()  
{  
  int i,j;  
  i=j=1,a[0]=0;  
  while(i<=win[0] && j<=lose[0])  
    if(cmp(win[i],lose[j]))  
      a[++a[0]]=win[i++];  
    else   
      a[++a[0]]=lose[j++];  
  while(i<=win[0])a[++a[0]]=win[i++];  
  while(j<=lose[0])a[++a[0]]=lose[j++];          
}  
```
    - **核心思想**：将胜者数组 `win` 和败者数组 `lose` 合并到数组 `a` 中，通过比较 `win` 和 `lose` 中元素的大小，按顺序放入 `a` 中。

- **作者：List（4星）**
    - **关键亮点**：简洁明了地阐述了胜者组和败者组有序的特点，代码结构清晰。
    - **核心代码**：
```cpp
void MergeSort()///把AB归并到a中
{
    int i=1,j=1,k=1;///分别用来在AB以及a中移动的指针
    while(i<=n && j<=n)
    {
        if(A[i].grade > B[j].grade || (A[i].grade == B[j].grade && A[i].num < B[j].num))
        {
            a[k].grade = A[i].grade;
            a[k++].num = A[i++].num;
        }
        else{
            a[k].grade = B[j].grade;
            a[k++].num = B[j++].num;
        }
    }
    while(i<=n)
    {
        a[k].grade = A[i].grade;
        a[k++].num = A[i++].num;
    }
    while(j<=n)
    {
         a[k].grade = B[j].grade;
        a[k++].num = B[j++].num;
    }
}
```
    - **核心思想**：将胜者数组 `A` 和败者数组 `B` 合并到数组 `a` 中，根据分数和编号的比较结果依次放入 `a` 中。

- **作者：LevenKoko（4星）**
    - **关键亮点**：使用标准库的 `merge` 函数，代码简洁，对 `merge` 函数的参数解释清晰。
    - **核心代码**：
```cpp
merge(w+1,w+1+win,l+1,l+1+lose,a+1,cmp);
```
    - **核心思想**：直接调用标准库的 `merge` 函数将胜者数组 `w` 和败者数组 `l` 合并到数组 `a` 中。

### 最优关键思路或技巧
- 利用每轮比赛后胜者组和败者组分别有序的特点，采用归并排序将两组有序数组合并，将排序的时间复杂度从 $O(n\log n)$ 优化到 $O(n)$。
- 自定义比较函数 `cmp` 来处理分数相同情况下按编号排序的问题。

### 可拓展之处
同类型题或类似算法套路：涉及多轮比赛、排序优化的问题，如一些模拟竞赛过程的题目，可使用类似的分组有序合并的思想。

### 推荐题目
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：可使用归并排序求逆序对数量。
- [P2085 最小函数值](https://www.luogu.com.cn/problem/P2085)：需要对多个有序序列进行合并操作。
- [P1271 选举学生会](https://www.luogu.com.cn/problem/P1271)：涉及排序和统计，可使用合适的排序算法优化。

### 个人心得摘录与总结
- **作者：zsq9**：尝试使用 `sort` 和 `stable_sort` 时遇到超时和 `cmp` 顺序写错的问题，最终修正 `cmp` 顺序后 AC。总结为在使用排序函数时要注意复杂度和比较函数的正确性。
- **作者：Tracy_Loght**：暴力解法使用 `sort` 有两个点过不了，发现是常数大和时间限制问题，建议使用 `stable_sort` 并加上快读优化。说明在处理卡常问题时，可考虑更优的排序算法和输入优化。 

---
处理用时：30.99秒
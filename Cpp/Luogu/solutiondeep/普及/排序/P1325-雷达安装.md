# 题目信息

# 雷达安装

## 题目描述

假设海岸线是一条无限延伸的直线。它的一侧是陆地，另一侧是海洋。每一座小岛是在海面上的一个点。雷达必须安装在陆地上（包括海岸线），并且每个雷达都有相同的扫描范围 $d$。你的任务是建立尽量少的雷达站，使所有小岛都在扫描范围之内。

数据使用笛卡尔坐标系，定义海岸线为 $x$ 轴。在 $x$ 轴上方为海洋，下方为陆地。




## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/fnezefht.png)

### 数据范围

对于全部数据，$n\le1000$，$ d \le 2\times 10^4$，$ | x_i | \le 2 \times 10^6 $，$ 0 \le y_i \le 2\times 10^4$。

## 样例 #1

### 输入

```
3 2
1 2
-3 1
2 1
```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解核心思路均为将雷达覆盖岛屿问题转化为区间选点问题，利用贪心算法求解。先计算每个岛屿对应雷达可放置的区间，再按区间右端点排序，通过遍历区间确定最少雷达数量。各题解的不同主要体现在代码实现细节和处理方式上。

### 所选题解
- **作者：wzm2007（5星）**
    - **关键亮点**：思路清晰，代码简洁易懂，详细注释便于理解。
    - **核心代码**：
```cpp
struct node
{
    double x,y;
    bool vis=0;
}a[1010];
bool cmp(node p,node q)
{
    return p.y<q.y;
}
int main()
{
    cin>>n>>d;
    for(register int i=0;i<n;i++)
    {
        double p,q,m;
        cin>>p>>q;
        if(q>d){cout<<-1;return 0;}
        m=sqrt(d*d-q*q);
        a[i].x=p-m,a[i].y=p+m;
    }
    sort(a,a+n,cmp);
    for(int i=0;i<n;i++)
    {
        if(a[i].vis)continue;
        ans++;
        a[i].vis=1;
        for(int j=0;j<n;j++)
            if(!a[j].vis&&a[i].y>=a[j].x)a[j].vis=1;
    }
    cout<<ans;
    return 0;
}
```
    - **核心思想**：先计算每个岛屿对应的区间，按区间右端点排序。遍历区间，若当前区间未被覆盖，在其右端点放置雷达，并标记该雷达覆盖范围内的所有区间。

- **作者：弹星者（4星）**
    - **关键亮点**：思路明确，代码结构清晰，使用 `temp` 记录上一个雷达位置，简化判断过程。
    - **核心代码**：
```cpp
struct node{
    double l,r;
}a[1010];
double cmp(node aa,node bb){
    return aa.r<bb.r;
}
int main(){
    cin>>n>>d;
    for(int i=1;i<=n;i++){
        cin>>x[i]>>y[i];
        if(y[i]>d){
            cout<<"-1"<<endl;
            return 0;
        }
        a[i].l=x[i]-sqrt(d*d-y[i]*y[i]);
        a[i].r=x[i]+sqrt(d*d-y[i]*y[i]);
    }
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++){
        if(i==1) temp=a[i].r,ans++;
        else if(temp>a[i].l) continue;
        else temp=a[i].r,ans++;
    }
    cout<<ans<<endl;
    return 0;
}
```
    - **核心思想**：同样先计算区间并排序，用 `temp` 记录上一个雷达位置，若当前区间左端点大于 `temp`，则在该区间右端点放置新雷达。

- **作者：Social_Zhao（4星）**
    - **关键亮点**：详细解释思路，将问题转化为区间选点问题并参考蓝皮书，代码模块化，逻辑清晰。
    - **核心代码**：
```cpp
struct segment {
    double l,r;
}a[MaxN];
bool cmp(segment x,segment y)
{
    return x.r<y.r;
}
inline void work()
{
    int ans=0;
    sort(a+1,a+1+n,cmp);
    for(int i=1;i<=n;i++) {
        double nowr=a[i].r;
        if(num[i]<=0) continue;
        num[i]--;
        for(register int j=i+1;j<=n;j++) {
            if(a[j].l<=nowr) {
                num[j]--;
            }
        }
        ans++;
    }
    printf("%d",ans);
}
```
    - **核心思想**：计算区间并排序后，遍历区间，若当前区间有需求，在其右端点放置雷达，并减少该雷达覆盖范围内区间的需求。

### 最优关键思路或技巧
- **问题转化**：将雷达覆盖岛屿问题转化为区间选点问题，简化问题求解。
- **贪心策略**：按区间右端点排序，优先在区间右端点放置雷达，使雷达覆盖更多区间。

### 拓展思路
同类型题如区间覆盖、活动安排等，都可使用贪心算法解决。类似算法套路为将问题转化为区间问题，根据区间的某个端点排序，再利用贪心策略求解。

### 洛谷相似题目推荐
- P1803 凌乱的yyy / 线段覆盖
- P2082 区间覆盖
- P1233 木棍加工

### 个人心得摘录与总结
- **作者：_7zz**：作者认为自己的方法与大家不同，将岛屿排序后遍历，若岛屿不在雷达范围内，根据岛屿与雷达的位置关系移动雷达或新建雷达。其认为向左平移雷达可保证之前覆盖的岛屿仍被覆盖，避免浪费雷达。总结：提供了一种不同的思考角度，但代码实现相对复杂。 

---
处理用时：33.27秒
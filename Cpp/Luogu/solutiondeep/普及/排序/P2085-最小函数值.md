# 题目信息

# 最小函数值

## 题目描述

有 $n$ 个函数，分别为 $F_1,F_2,\dots,F_n$。定义 $F_i(x)=A_ix^2+B_ix+C_i(x\in\mathbb N*)$。给定这些 $A_i$、$B_i$ 和 $C_i$，请求出所有函数的所有函数值中最小的 $m$ 个（如有重复的要输出多个）。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n,m\le10000$，$1 \leq A_i\le10,B_i\le100,C_i\le10^4$。

## 样例 #1

### 输入

```
3 10
4 5 3
3 4 5
1 7 1
```

### 输出

```
9 12 12 19 25 29 31 44 45 54```

# AI分析结果

### 综合分析与结论
本题要求找出多个二次函数在正整数定义域上的最小 $m$ 个函数值。题解思路主要分为暴力求解和优化求解两类。暴力求解是计算所有可能的函数值并排序，时间和空间复杂度高；优化求解多利用函数单调性，结合堆数据结构，避免重复计算和排序，降低复杂度。

### 高评分题解
- **作者：Euler_Pursuer（5星）**
    - **关键亮点**：思路清晰，详细分析了暴力解法的复杂度和缺点，逐步引导到优化解法。先提出普通优化思路，再用堆进一步优化，给出了完整的代码实现和复杂度分析。
    - **核心代码**：
```cpp
// 更优化的解法（堆）
#include <iostream>
using namespace std;
struct DUI
{
    int val;
    int x;
}a[10010];
int heap_size;
void CHANGE(int m, int n)
{
    int t;
    t=a[m].val;
    a[m].val=a[n].val;
    a[n].val=t;
    t=a[m].x;
    a[m].x=a[n].x;
    a[n].x=t;
}
void MIN_HEAPIFY(int i)
{
    int l=i*2;
    int r=i*2+1;
    int smallest;
    if(l<=heap_size&&a[l].val<a[i].val)
        smallest=l;
    else
        smallest=i;
    if(r<=heap_size&&a[r].val<a[smallest].val)
        smallest=r;
    if(smallest!=i)
    {
        CHANGE(i,smallest);
        MIN_HEAPIFY(smallest);
    }
}
void BUILD_HEAP()
{
    int i;
    for(i=heap_size/2;i>0;i--)
        MIN_HEAPIFY(i);
}
int main()
{
    int n,m,i,j;
    int A[10010], B[10010], C[10010];
    int F[10010];
    cin>>n>>m;
    for(i=1;i<=n;i++)
    {
        cin>>A[i]>>B[i]>>C[i];
        F[i]=1;
        a[i].val=A[i]*F[i]*F[i]+B[i]*F[i]+C[i];
        a[i].x=i;
    }
    heap_size=n;
    BUILD_HEAP();
    for(i=0;i<m;i++)
    {
        cout<<a[1].val<<' ';
        F[a[1].x]++;
        a[1].val=A[a[1].x]*F[a[1].x]*F[a[1].x]+B[a[1].x]*F[a[1].x]+C[a[1].x];
        MIN_HEAPIFY(1);
    }
    return 0;
}
```
    - **核心思想**：先将每个函数 $x = 1$ 时的函数值放入小根堆，每次取出堆顶元素输出，将该元素对应函数的 $x$ 加 1 后重新计算函数值并放入堆中，维护堆的性质。

- **作者：yyy14159（4星）**
    - **关键亮点**：思路简洁明了，直接利用优先队列实现小根堆，代码结构清晰，易于理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct func
{
    int a,b,c;
 } f[10004];
struct _value
{
    int num,x,val;
}res[100004];
priority_queue<_value,vector<_value>,less<_value> >q; 
bool operator <(_value a,_value b) {return a.val>b.val;}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d%d%d",&f[i].a,&f[i].b,&f[i].c );
        q.push( (_value){i,1,f[i].a +f[i].b +f[i].c});
    }
    for(int i=1;i<=m;i++){
        _value t=q.top();
        q.pop();
        cout<<t.val <<" ";
        q.push((_value){t.num,t.x +1,f[t.num ].a *(t.x +1)*(t.x +1)+f[t.num ].b *(t.x +1)+f[t.num ].c } );
    }
    return 0;
}
```
    - **核心思想**：定义结构体存储函数信息和函数值，将每个函数 $x = 1$ 时的函数值放入优先队列（小根堆），每次取出队首元素输出，将该元素对应函数的 $x$ 加 1 后重新计算函数值并放入队列。

- **作者：Celebrate（4星）**
    - **关键亮点**：先分析暴力解法，再提出用堆优化的思路，代码实现使用了优先队列，简洁高效。
    - **核心代码**：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<queue>
#include<stack>
#include<cmath>
#include<map>
using namespace std;
const int N=1e4+10;
int n,m;
int a[N],b[N],c[N];
struct node{
    int z,x,t;
    inline bool operator<(const node &k)const{
        return k.z<z;
    }
};
priority_queue<node> q;
inline int query(int x,int t){return x*x*a[t]+x*b[t]+c[t];}
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++)a[i]=read(),b[i]=read(),c[i]=read();
    for(int i=1;i<=n;i++)q.push((node){query(1,i),1,i});
    while(m--){
    	printf("%d ",q.top().z);
    	int x=q.top().x+1,t=q.top().t;
    	q.pop();q.push((node){query(x,t),x,t});
    }
    return 0;
}
```
    - **核心思想**：定义结构体存储函数值、自变量和函数编号，将每个函数 $x = 1$ 时的函数值放入优先队列（小根堆），每次取出队首元素输出，将该元素对应函数的 $x$ 加 1 后重新计算函数值并放入队列。

### 最优关键思路或技巧
- **利用函数单调性**：根据二次函数系数为正，得出函数在正整数定义域上单调递增，从而确定每个函数最小值在 $x = 1$ 处取得。
- **堆优化**：使用小根堆存储当前最小的函数值，每次取出堆顶元素，更新对应函数的自变量并重新计算函数值放入堆中，避免了重复排序，时间复杂度降为 $O(m \log n)$。

### 拓展思路
同类型题目可考察多个有序序列合并取前 $k$ 小元素，如多个有序数组、链表合并等。算法套路都是利用堆维护当前最小元素，不断更新并取出。

### 推荐题目
- [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
- [P2859 [USACO06FEB]Treats for the Cows G](https://www.luogu.com.cn/problem/P2859)
- [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)

### 个人心得摘录与总结
- **作者：Lee02**：一开始想用暴力方法，但遇到结构体中重载运算符的问题，后来学习堆优化的 Dijkstra 算法时学会了重载运算符，从而解决了问题。总结：遇到难题可先搁置，学习相关知识后再回头解决。
- **作者：手链剖分**：写了个 $n^2 \log n$ 的暴力代码，害怕超时在第二重循环上加了个根号，结果通过了。吐槽数据水，同时给出正解思路。总结：数据可能有强弱之分，应尽量掌握正解方法。
- **作者：xdc呀**：先尝试最暴力的方法把所有函数值放进大根堆，结果 TLE，后来改为用大根堆存答案，从小到大入队，大于堆顶就 break，最终通过。总结：暴力方法可能超时，需根据题目特点优化算法。 

---
处理用时：57.94秒
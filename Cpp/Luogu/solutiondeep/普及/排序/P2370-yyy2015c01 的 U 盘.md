# 题目信息

# yyy2015c01 的 U 盘

## 题目背景

在 2020 年的某一天，我们的 yyy2015c01 买了个高端 U 盘。


## 题目描述

你找 yyy2015c01 借到了这个高端的 U 盘，拷贝一些重要资料，但是你发现这个 U 盘有一些问题：

1. 这个 U 盘的传输接口很小，只能传输大小不超过 $L$ 的文件。
2. 这个 U 盘容量很小，一共只能装不超过 $S$ 的文件。

但是你要备份的资料却有很多，你只能备份其中的一部分。

为了选择要备份哪些文件，你给所有文件设置了一个价值 $V_i$，你希望备份的文件总价值不小于 $p$。

但是很快你发现这是不可能的，因为 yyy2015c01 的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）。

注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,

你放在 U 盘中文件的总大小不能超过 U 盘容量。

现在问题来了：你想知道，在满足 U 盘中文件价值之和**不小于** $p$ 时，最小需要多大的接口。

## 说明/提示

$1 \le n, W_i, S \le 10^3$，$1 \leq V_i \leq 10^6$，$1 \leq p \leq 10^9$。

数据较小，请勿乱搞。

样例解释 $1$：买一个大小为 $2$ 接口，把物品 $1$ 、$2$ 放进$\text{U}$盘。

样例解释 $2$：买一个大小为 $500$ 的接口。

样例解释 $3$：本来可以买大小为 $2$ 的接口，可是 U 盘容量放不下足够的文件。

如果数据出现疏漏，请联系出题人 [a710128](https://www.luogu.com.cn/user/2573)

向本题主人公 yyy2015c01 同学致敬！

## 样例 #1

### 输入

```
3 3 5
2 2
1 2
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 505
1 2
500 1```

### 输出

```
500```

## 样例 #3

### 输入

```
3 3 2
2 2
1 2
3 2```

### 输出

```
No Solution!```

## 样例 #4

### 输入

```
4 5 6
5 1
5 2
5 3
1 1```

### 输出

```
No Solution!```

# AI分析结果

### 综合分析与结论
这些题解主要围绕“在满足 U 盘中文件价值之和不小于 p 时，求最小需要的接口大小”这一问题展开，核心思路是结合 0 - 1 背包和二分查找。部分题解直接使用 0 - 1 背包结合排序求解，部分则采用二分答案结合 0 - 1 背包验证的方法。

### 所选题解
- **作者：cs18（5星）**
    - **关键亮点**：思路简洁直接，代码实现精炼，通过排序和 0 - 1 背包直接找到满足条件的最小接口大小，无需二分查找，时间复杂度低。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,p,s;
int dp[1005];
struct node
{
    int v,w;
}a[1005];
int cmp(node a,node b)
{
    return a.v<b.v;
 } 
int main()
{
    scanf("%d%d%d",&n,&p,&s);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&a[i].v,&a[i].w);
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
        for(int j=s;j>=a[i].v;j--)
        {
            dp[j]=max(dp[j],dp[j-a[i].v]+a[i].w);
            if(dp[s]>=p)
            {
                printf("%d",a[i].v);
                return 0;
            }
        }
    printf("No Solution!");    
}
```
    - **核心思想**：先将文件按大小排序，然后进行 0 - 1 背包，在背包过程中一旦满足总价值不小于 p，当前文件的大小即为最小接口大小。

- **作者：MuelsyseU（5星）**
    - **关键亮点**：思路详细清晰，对 0 - 1 背包和二分答案的原理进行了深入讲解，代码实现规范，考虑了各种边界情况。
    - **个人心得**：作者提到二分与 DP 是自己最近被虐的算法，看到此题觉得神清气爽，说明通过做此题对这两种算法有了更深入的理解。
    - **核心代码**：
```cpp
int dp(int k) {
    for(int j=1;j<=s;j++)
        f[j]=0;
    for(int i=1;i<=n;i++){
        if(k!=-1&&a[i]>k) continue;
        for(int j=s;j>=a[i];j--){
            f[j]=max(f[j],f[j-a[i]]+b[i]);
        }
    }
    return f[s];
} 

bool check(int s) {
    return dp(s)>=m;
}

int find(int low,int high) {
    int mid;
    while(low+1<high){
        mid=low+(high-low)/2;
        if(check(mid))
            high=mid;
        else
            low=mid;
    } 
    return high;
}

int main() {
    int low=1e7,high=0;
    cin>>n>>m>>s;
    for(int i=1;i<=n;i++) {
        cin>>a[i]>>b[i];
        low=min(low,a[i]);
        high=max(high,a[i]);
    }
    if(dp(-1)<m) cout<<"No Solution!";
    else cout<<find(low-1,high);
    return 0;
}
```
    - **核心思想**：通过二分查找枚举接口大小，用 0 - 1 背包验证每个接口大小是否满足总价值不小于 p 的条件，最终找到最小接口大小。

### 最优关键思路或技巧
- **排序优化**：如 cs18 的题解，先对文件按大小排序，在 0 - 1 背包过程中可直接找到最小接口大小，避免二分查找。
- **二分答案**：对于“最大值最小”的问题，二分答案是一种常用且高效的方法，结合 0 - 1 背包验证可行性。
- **空间压缩**：在 0 - 1 背包中使用一维数组进行空间压缩，减少内存开销。

### 可拓展之处
同类型题可拓展到其他有容量限制和价值要求的选择问题，如在一定预算下选择商品，使总价值最大且满足某些条件。类似算法套路可用于解决其他二分答案结合动态规划的问题。

### 推荐题目
1. [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)：二分答案经典题目，可用于练习二分答案的基本思路。
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)：基础的 0 - 1 背包问题，可巩固 0 - 1 背包的实现。
3. [P1281 书的复制](https://www.luogu.com.cn/problem/P1281)：二分答案结合贪心的问题，可进一步提升对二分答案的理解和应用能力。 

---
处理用时：30.02秒
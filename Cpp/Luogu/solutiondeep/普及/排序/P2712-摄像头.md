# 题目信息

# 摄像头

## 题目描述

食品店里有 $n$ 个摄像头，这种摄像头很笨拙，只能拍摄到固定位置。现有一群胆大妄为的松鼠想要抢劫食品店，为了不让摄像头拍下他们犯罪的证据，他们抢劫前的第一件事就是砸毁这些摄像头。

为了便于砸毁摄像头，松鼠歹徒们把所有摄像头和摄像头能监视到的地方统一编号，一个摄像头能被砸毁的条件是该摄像头所在位置不被其他摄像头监视。

现在你的任务是帮松鼠们计算是否可以砸掉所有摄像头，如不能则输出还没砸掉的摄像头的数量。

## 说明/提示

$1 \leq n \leq 100$。

$0 \leq m \leq 100$。

$0 \leq x,y \leq 500$。


## 样例 #1

### 输入

```
5
1 1 2
2 1 1
3 1 7
4 1 1
5 0
```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
本题主要围绕计算能否砸掉所有摄像头展开，若不能则输出剩余摄像头数量。大部分题解采用拓扑排序算法，其核心在于构建图结构并记录节点入度，通过不断删除入度为 0 的节点来模拟砸毁摄像头的过程。各题解在数据结构选择（邻接表、邻接矩阵）、代码实现细节及优化程度上存在差异。

### 高评分题解
1. **作者：llzzxx712（5 星）**
    - **关键亮点**：思路清晰，详细阐述拓扑排序过程，代码注释丰富，对易错点有明确提示。
    - **个人心得**：提到因数组开小导致多次 WA，提醒要注意数组大小。
    - **核心代码**：
```cpp
void add(int x,int y){
    to[++tot]=y,ne[tot]=head[x],head[x]=tot,edge[y]++;//edge存入度数量 
}
while(!q.empty()){
    ans++;//计数器 
    int x=q.front();q.pop();//取出队首 
    for(int i=head[x];i;i=ne[i]){
        int y=to[i];
        edge[y]--;//入度减一 
        if(!edge[y]&&v[y]) q.push(y);//如果这个地方有摄像头且入度为0 
    }
}
```
核心思想：使用邻接表建图，将入度为 0 的节点入队，不断取出队首节点，更新其邻接节点的入度，若邻接节点入度变为 0 则入队。

2. **作者：henrytb（4 星）**
    - **关键亮点**：采用邻接矩阵存储图，代码简洁，对拓扑排序过程描述清晰，考虑到点编号不连续的问题。
    - **核心代码**：
```cpp
while(ans<n){
    if(l>r){//不可再删
        printf("%d",n-ans);
        return 0;
    }
    int cmd=q[l++];//删点
    for(int i=0;i<=maxx;i++){
        if(ma[cmd][i]&&used[i]){
            du[i]--;//处理与被删的点相邻的点的入度
            if(du[i]==0&&used[i])q[++r]=i;//如果此点更新后入度为0，将此点放入队列
        }
    }
    ans++;//更新已删的点的个数
}
```
核心思想：先将入度为 0 的节点入队，不断从队列中取出节点删除，并更新其邻接节点的入度，若邻接节点入度变为 0 则入队，直到队列为空或所有节点都被处理。

3. **作者：WanderingTrader（4 星）**
    - **关键亮点**：对图论建模过程有详细分析，代码中对拓扑排序进行了优化，考虑到输入摄像头编号不连续的问题。
    - **核心代码**：
```cpp
for(int k = 1;k <= n;k ++){
    for(i = 1;i <= n && in[num[i]];i ++);
    if(i == n + 1) break;
    i = num[i];
    ++ ans;
    in[i] = -1;
    for(int j = 1;j <= n;j ++)
    {
        if(d[i][num[j]])
        {
            d[i][num[j]] = 0;
            in[num[j]] --;
        }
    }
}
```
核心思想：通过循环找到入度为 0 的节点，将其标记为已处理，更新其邻接节点的入度，若循环中找不到入度为 0 的节点则跳出循环。

### 最优关键思路或技巧
- **拓扑排序**：将问题抽象为图论问题，利用拓扑排序模拟砸毁摄像头的过程，是解决本题的关键思路。
- **数据结构选择**：根据数据规模和特点选择合适的数据结构，如邻接表或邻接矩阵来存储图，提高代码效率。
- **入度记录**：记录每个节点的入度，方便判断节点是否可以被处理。

### 拓展思路
同类型题或类似算法套路：
- 涉及有向无环图（DAG）的任务调度问题，如课程安排、项目规划等，可使用拓扑排序确定任务的执行顺序。
- 图的连通性问题，可通过拓扑排序判断图是否存在环。

### 推荐题目
1. [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)
2. [P1347 排序](https://www.luogu.com.cn/problem/P1347)
3. [P2853 [USACO06DEC]Cow Picnic S](https://www.luogu.com.cn/problem/P2853)

### 个人心得总结
- **llzzxx712**：因数组开小导致多次 WA，提醒要注意数组大小。
- **jyz666**：一开始没分清摄像头和区域，将二者视为一谈，结果只有 10 分，强调要仔细审题。
- **WanderingTrader**：指出图论题的关键在于图论建模，要多练习以掌握建模技巧。
- **wawcac**：因摄像机拍摄到空位置导致开始只有 80 分，提醒要考虑特殊情况。 

---
处理用时：38.03秒
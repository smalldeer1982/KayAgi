# 题目信息

# 友好城市

## 题目描述

有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的 $N$ 个城市。北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航道不相交的情况下，被批准的申请尽量多。


## 说明/提示

### 数据规模与约定

- 对于 $50\%$ 的数据，$1 \leq N \leq 5000$，$0 \leq x _ i \leq 10000$。
- 对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10 ^ 5$，$0 \leq x _ i \leq 10 ^ 6$。


## 样例 #1

### 输入

```
7
22 4
2 6
10 3
15 12
9 8
17 17
4 2```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
本题核心在于将航道不交叉问题转化为最长不下降子序列（LIS）问题。先对北岸或南岸城市坐标排序，再求另一边的LIS长度，即为可批准的最大航道数。由于数据规模较大，需采用 $O(nlogn)$ 复杂度的算法。各题解大多采用排序加二分查找的方法，部分使用树状数组、平衡树等数据结构。

### 所选题解
- **作者：AC机（5星）**
    - **关键亮点**：思路清晰，详细阐述了将问题转化为LIS的过程，代码简洁，对 `upper_bound` 函数的使用说明清晰。
    - **核心代码**：
```cpp
struct node
{
    int north;
    int south;
};
node a[200005];
bool cmp(node x,node y)
{
    return x.north<y.north;
}
int main ()
{
    int n, i, d[200005], len = 0;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i].north);
        scanf("%d",&a[i].south);
    }
    sort(a+1,a+1+n,cmp);
    d[++len]=a[1].south;
    for(i=2;i<=n;i++)
    {
        int dbzjrQwQ=upper_bound(d+1,d+len+1,a[i].south)-d;
        d[dbzjrQwQ]=a[i].south;
        if(dbzjrQwQ>len)
        {
            len++;
        }
    }
    printf("%d",len);
    return 0;
}
```
    - **核心思想**：定义结构体存储南北岸城市坐标，按北岸坐标排序，用 `upper_bound` 函数二分查找插入位置更新LIS数组，最终 `len` 即为LIS长度。

- **作者：1379号监听员（5星）**
    - **关键亮点**：详细分析航道不交叉条件，推导LIS解法，对动态规划超时问题提出优化策略，代码注释清晰。
    - **核心代码**：
```cpp
struct city{
    int north;
    int south;
};
struct cmp{
    bool operator () (city& a,city& b)
    {
        return a.north<b.north;
    }
};
city c[200005];
int lis[200005];
int ans=0;
int n;
int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        cin>>c[i].north>>c[i].south;
    }
    sort(c+1,c+n+1,cmp());
    for(int i=1;i<=n;i++)
    {
        if(c[i].south>lis[ans])
        {
            lis[++ans]=c[i].south;
        }
        else
        {
            *lower_bound(lis+1,lis+ans+1,c[i].south)= (c[i].south);
        }
    }
    cout<<ans<<endl;
    return 0;
 } 
```
    - **核心思想**：定义结构体和比较器，按北岸坐标排序，若当前南岸坐标大于LIS数组末尾元素则插入，否则用 `lower_bound` 函数替换第一个大于等于它的元素。

- **作者：维迭生（4星）**
    - **关键亮点**：采用树状数组求解LIS，提供了不同的解题思路，对树状数组的使用进行了详细说明。
    - **核心代码**：
```cpp
const int MAXN = 2e5 + 5;
const int MAXX = 1e6;
int n, maxx;
struct line{
    int n,s;
}l[MAXN];
bool cmp(line a, line b){
    return a.n < b.n;
}
int tree[MAXX], ans;
inline int lowbit(int k){
    return k&-k;
}
inline void add (int x, int newl){
    while(x <= maxx){
        tree[x] = max(tree[x], newl);
        x += lowbit(x);
    }
}
inline int ask (int x){
    int ret = 0;
    while(x >= 1){
        ret = max(ret, tree[x]);
        x -= lowbit(x);
    }
    return ret;
}
int main(){
    cin >> n;
    for (int i = 1; i <= n; ++i){
        cin >> l[i].s >> l[i].n;
        maxx = max(maxx, l[i].s);
    }
    sort(l+1, l+n+1, cmp);
    for(int i = 1 ; i <= n; ++i){
        int x = ask(l[i].s) + 1;
        ans = max (ans, x);
        add(l[i].s + 1, x);
    }
    cout << ans << endl;
    return 0;
}
```
    - **核心思想**：定义结构体存储南北岸坐标，按北岸坐标排序，用树状数组维护以南岸坐标为下标的LIS长度，每次查询小于当前南岸坐标的最大LIS长度加1更新答案，并更新树状数组。

### 最优关键思路或技巧
- **问题转化**：将航道不交叉问题转化为最长不下降子序列问题，通过排序和LIS求解。
- **二分查找优化**：使用 `upper_bound` 或 `lower_bound` 函数进行二分查找，将LIS求解复杂度从 $O(n^2)$ 优化到 $O(nlogn)$。
- **数据结构应用**：部分题解使用树状数组、平衡树等数据结构求解LIS，提供了不同的解题思路。

### 可拓展之处
- **同类型题**：如导弹拦截问题、合唱队形问题等，都可转化为LIS问题求解。
- **算法套路**：对于涉及偏序关系和最长子序列的问题，可考虑排序加二分查找或使用数据结构优化。

### 推荐洛谷题目
- P1020 [NOIP1999 普及组] 导弹拦截
- P1091 [NOIP2004 提高组] 合唱队形
- P1439 【模板】最长公共子序列

### 个人心得摘录与总结
- **作者：梦回还**：提到数据中一个点卡了三次，原因是使用 `>=` 而非 `>`，说明在处理边界条件时需仔细，避免因数据特殊情况导致错误。
- **作者：徐熙凯**：强调“模拟是动归之父”，当没有思路时可通过模拟数据寻找算法和方法。 

---
处理用时：38.43秒
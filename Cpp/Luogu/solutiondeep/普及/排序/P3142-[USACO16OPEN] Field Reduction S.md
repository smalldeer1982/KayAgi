# 题目信息

# [USACO16OPEN] Field Reduction S

## 题目描述

Farmer John 的 $N$ 头奶牛（$5 \leq N \leq 50,000$）都位于他二维牧场中的不同位置。FJ 希望用一个边平行于 $x$ 轴和 $y$ 轴的矩形围栏围住所有的奶牛，并且他希望这个围栏尽可能小，以便能够包含每头奶牛（允许奶牛位于边界上）。

不幸的是，由于上个季度牛奶产量低，FJ 的预算非常紧张。因此，他希望如果可能的话，建造一个更小的围栏，并且他愿意从他的牛群中出售最多三头奶牛来实现这一目标。

请帮助 FJ 计算在从他的牛群中移除最多三头奶牛后，他可以用围栏围住的最小可能面积（然后为剩余的奶牛建造最紧密的围栏）。

对于这个问题，请将奶牛视为点，将围栏视为四条线段的集合（即不要将奶牛视为“单位正方形”）。请注意，答案可能为零，例如如果所有剩余的奶牛最终站在一条共同的垂直线或水平线上。

## 样例 #1

### 输入

```
6
1 1
7 8
10 9
8 12
4 100
50 7```

### 输出

```
12```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均为暴力枚举删除最多三头奶牛后的所有可能情况，计算剩余奶牛所需最小围栏面积并取最小值。各题解在实现细节上有所不同，主要差异在于枚举方式、去重处理和代码结构。

### 所选题解
- **作者：Unordered_OIer（5星）**
    - **关键亮点**：思路清晰，对新手友好，详细解释了每个步骤的目的和注意事项，代码注释丰富。
    - **个人心得**：作者提到设无穷大的值时要精确，因输出最大值可能较大，设小了会出错，自己在此处被坑多次。
    - **核心代码**：
```cpp
void work(ll x,ll y,ll z){
    memset(d,0,sizeof(d));
    for (ll i=1; i<=x; i++) d[b[i]]=1;
    for (ll i=1; i<=y; i++) d[b[n-i+1]]=1;
    ll m=0;
    for (ll i=1; i<=n; i++)
        if (!d[i]) c[++m]=i;
    sort(c+1,c+m+1,cmp2);
    for (ll i=1; i<=z; i++) d[c[i]]=1;
    for (ll i=1; i+x+y+z<=3; i++) d[c[m-i+1]]=1;
    ll mxx=0,mxy=0,mix=INF,miy=INF;
    for (ll i=1; i<=n; i++)
        if (!d[i]){
            mxx=max(mxx,a[i].x);
            mix=min(mix,a[i].x);
            mxy=max(mxy,a[i].y);
            miy=min(miy,a[i].y);
        }
    if (mxx<=mix || mxy<=miy) ans=0;
    else ans=min(ans,(mxx-mix)*(mxy-miy));
}
```
    - **核心实现思想**：通过标记数组标记要删除的奶牛，将未删除的奶牛存入新数组并排序，再次标记删除的奶牛，最后计算剩余奶牛的最大最小横纵坐标，从而得到围栏面积并更新答案。

- **作者：ikunTLE（4星）**
    - **关键亮点**：思路简洁明了，直接点明暴力枚举的核心，且给出了相关练习的推荐。
    - **核心思路**：先对 $X_i$ 和 $Y_i$ 分别排序，找出最大和最小的 3 个点，去重后用 dfs 枚举选择 3 个点的所有情况，计算面积取最小值。

- **作者：Andy1101（4星）**
    - **关键亮点**：详细说明了思路和注意事项，使用 `unique` 函数进行去重，代码结构清晰。
    - **核心代码**：
```cpp
void to_m()
{
    sort(a+1,a+n+1,cmp1);
    m[++idx]=a[1].id;
    m[++idx]=a[2].id;
    m[++idx]=a[3].id;
    m[++idx]=a[n].id;
    m[++idx]=a[n-1].id;
    m[++idx]=a[n-2].id;
    sort(a+1,a+n+1,cmp2);
    m[++idx]=a[1].id;
    m[++idx]=a[2].id;
    m[++idx]=a[3].id;
    m[++idx]=a[n].id;
    m[++idx]=a[n-1].id;
    m[++idx]=a[n-2].id;
    sort(m+1,m+idx+1);
}
void dfs()
{
    for(int i=1;i<=idx;i++)
    {
        for(int j=i+1;j<=idx;j++)
        {
            for(int k=j+1;k<=idx;k++)
            {
                int tmp=getans(m[i],m[j],m[k]);
                minans=min(minans,tmp);
            }
        }
    }
}
```
    - **核心实现思想**：先将横纵坐标最大和最小的 12 头牛的编号记录到数组 `m` 中，排序后使用 `unique` 函数去重，再通过三重循环枚举所有可能的组合，计算面积并更新最小面积。

### 最优关键思路或技巧
- 利用排序找出横纵坐标最大和最小的点，缩小枚举范围。
- 使用标记数组或 `unique` 函数进行去重，避免重复计算。
- 注意无穷大值的设置，防止溢出。

### 可拓展之处
同类型题可能会增加可删除奶牛的数量或改变围栏的形状，解题思路仍可采用暴力枚举或优化后的枚举方法。类似算法套路包括枚举所有可能的组合，通过剪枝或预处理缩小枚举范围，以减少时间复杂度。

### 推荐题目
- [P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)：练习组合枚举的基础题目。
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：涉及枚举组合并计算相关结果。
- [P2036 [COCI2008-2009#2] PERKET](https://www.luogu.com.cn/problem/P2036)：需要枚举所有可能的组合并计算最优值。 

---
处理用时：37.34秒
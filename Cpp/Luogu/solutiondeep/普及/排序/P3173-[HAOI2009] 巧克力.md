# 题目信息

# [HAOI2009] 巧克力

## 题目描述

有一块 $n \times m$ 的矩形巧克力，准备将它切成 $n \times m$ 块。巧克力上共有 $n-1$ 条横线和 $m-1$ 条竖线，你每次可以沿着其中的一条横线或竖线将巧克力切开，无论切割的长短，沿着每条横线切一次的代价依次为 $y_1,y_2,\cdots,y_{n-1}$，而沿竖线切割的代价依次为 $x_1,x_2,\cdots,x_{m-1}$。

例如，对于下图 $6 \times 4$ 的巧克力，我们先沿着三条横线切割，需要 $3$ 刀，得到 $4$ 条巧克力，然后再将这 $4$ 条巧克力沿竖线切割，每条都需要 $5$ 刀，则最终所花费的代价为 $y_1+y_2+y_3+4 \times (x_1+x_2+x_3+x_4+x_5)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/juiv548x.png)


当然，上述简单切法不见得是最优切法，那么怎样切割该块巧克力，花费的代价最少呢？


## 说明/提示


$30\%$ 的数据，$n \leq 100,m \leq 100$；

$100\%$ 的数据，$n \leq 10000,m \leq 10000$；

## 样例 #1

### 输入

```
6 4
2
1
3
1
4
4
1
2```

### 输出

```
42```

# AI分析结果

### 综合分析与结论
这些题解大多采用贪心算法解决巧克力切割的最小代价问题。核心思路是优先切割代价大的线，以减少后续切割时的额外代价。不同题解在实现方式上有所差异，部分使用优先队列，部分使用结构体排序。

### 所选题解
- **Tarsal（5星）**
    - **关键亮点**：思路清晰，详细解释了贪心策略的原理，代码有详细注释，还给出了对新人友好的简化版代码。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define Rep(x, a, b) for(int x = a; x <= b; ++ x)
priority_queue<int> q, qq;
int n, m, x, s1 = 1, s2 = 1, ans;
int main(){
    scanf("%d%d", &n, &m);
    Rep(i, 1, n - 1){
        scanf("%d", &x);
        q.push(x);
    }
    Rep(i, 1, m - 1){
        scanf("%d", &x);
        qq.push(x);
    }
    while(! q.empty() &&! qq.empty()){
        if(q.top() > qq.top()){
            ans += q.top() * s2;
            ++ s1;
            q.pop();
        }
        else{
            ans += qq.top() * s1;
            ++ s2;
            qq.pop();
        }
    }
    while(! q.empty()){
        ans += q.top() * s2;
        q.pop();
    }
    while(! qq.empty()){
        ans += qq.top() * s1;
        qq.pop();
    }
    printf("%d", ans);
    return 0;
}
```
    - **核心实现思想**：使用两个优先队列分别存储横着切和竖着切的代价，每次比较队首元素，优先选择代价大的进行切割，更新已切割次数和总代价。
- **kkxhh（4星）**
    - **关键亮点**：对贪心策略进行了简单证明，使用优先队列实现，代码简洁。
    - **核心代码**：
```cpp
#include <cstdio>
#include <queue>
using namespace std;
priority_queue<int> q1,q2;
int n,m,s1=1,s2=1,sum=0;
inline int read(){
    int num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?-1:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return num*k;
}
int main() {
    n=read(); m=read();
    for(int i=1;i<=n-1;i++) q1.push(read());
    for(int i=1;i<=m-1;i++) q2.push(read());
    while(!q1.empty() &&!q2.empty()){
        if(q1.top()>q2.top()) {sum+=q1.top()*s2,s1++; q1.pop();}
        else {sum+=q2.top()*s1,s2++; q2.pop();}
    }
    while(!q1.empty()) {sum+=q1.top()*s2; q1.pop();}
    while(!q2.empty()) {sum+=q2.top()*s1; q2.pop();}
    printf("%d",sum);
    return 0;
}
```
    - **核心实现思想**：同样使用两个优先队列存储横竖切割代价，比较队首元素，优先切割代价大的线，更新切割次数和总代价。
- **Cyxhsa（4星）**
    - **关键亮点**：使用结构体存储代价和切割方向，通过排序实现贪心策略，代码简洁易懂。
    - **核心代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int n,m,i,ans;
int c[2];
struct lp
{
    int v;
    int c;
}a[20086];
bool cmp(lp a,lp b)
{return a.v>b.v;}
int main()
{
    cin>>n>>m;
    n--;m--;
    for(i=1;i<=n;i++)
    {cin>>a[i].v,a[i].c=0;}
    for(i=n+1;i<=n+m;i++)
    {cin>>a[i].v,a[i].c=1;}
    sort(a+1,a+n+m+1,cmp);
    for (i=1;i<=n+m;i++)
    {
        c[a[i].c]++;
        if(a[i].c==0)
            ans+=a[i].v*(c[1]+1);
        if(a[i].c==1)
            ans+=a[i].v*(c[0]+1);
    }
    cout<<ans<<endl;
    return 0;
}
```
    - **核心实现思想**：将横竖切割代价存储在结构体数组中，按代价从大到小排序，遍历数组，根据切割方向更新切割次数和总代价。

### 最优关键思路或技巧
- **贪心策略**：优先切割代价大的线，因为越往后切割，该线的额外代价倍数越大。
- **数据结构**：使用优先队列或结构体排序，方便获取当前最大代价的切割线。

### 可拓展之处
同类型题如矩形分割问题，类似算法套路为贪心算法，通过分析局部最优解来得到全局最优解。

### 推荐题目
- [P1324 矩形分割](https://www.luogu.com.cn/problem/P1324)
- [P3173 [HAOI2015] 数字串拆分](https://www.luogu.com.cn/problem/P3173)
- [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)

### 个人心得
部分题解提到要推一遍样例来更好地理解算法，这是一种很好的调试和理解思路的方法。如Tarsal提到“建议推一遍样例”，Cyxhsa也说“建议还是推一遍样例为好”。通过推样例可以更直观地感受算法的执行过程，发现潜在问题。 

---
处理用时：36.29秒
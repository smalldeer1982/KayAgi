# 题目信息

# 最大食物链计数

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。


## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。


## 说明/提示

各测试点满足以下约定：

 ![](https://cdn.luogu.com.cn/upload/pic/12011.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕最大食物链计数问题展开，核心是在有向无环图（DAG）中计算从入度为 0 的点到出度为 0 的点的路径数量。主要使用了拓扑排序和记忆化搜索两种方法。拓扑排序通过依次删除入度为 0 的点，更新相关点的路径数量；记忆化搜索则通过记录已搜索点的结果避免重复计算。

### 所选题解
- **御·Dragon（5 星）**
    - **关键亮点**：思路清晰，从拓扑排序定义入手，详细分析题目性质，通过图文结合的方式解释模拟操作过程，代码注释丰富，易于理解。
    - **核心代码**：
```cpp
while(!q.empty())
{ 
    int tot = q.front();
    q.pop();
    int len = nei[tot].size(); 
    for(rg int i = 0;i < len; ++i)
    { 
        int next = nei[tot][i]; 
        --in[next];
        num[next] = (num[next] + num[tot]) % mod;
        if(in[next] == 0)q.push(nei[tot][i]);
    }
}
```
    - **核心思想**：使用拓扑排序，将入度为 0 的点（最佳生产者）的答案初始化为 1，在删除点的过程中，将该点的答案累加到它可以到达的点上，最后累加所有出度为 0 的点（最佳消费者）的答案。

- **__Watcher（4 星）**
    - **关键亮点**：详细阐述使用拓扑排序的思维过程，给出两种实现方式（邻接矩阵和邻接表），并对比了时空复杂度，还提供了优化方法。
    - **核心代码（邻接表）**：
```cpp
while(!q.empty()){
    int a=q.front();
    q.pop();
    for(int k=h[a];k;k=d[k].n){
        int b=d[k].b;
        f[b]+=f[a];
        f[b]%=mod;
        ru[b]--;
        if(ru[b]==0){
            if(chu[b]==0){
                ans+=f[b];
                ans%=mod;
            }
            else q.push(b);
        }
    }
}
```
    - **核心思想**：同样采用拓扑排序，利用邻接表存储图，当一个点的入度变为 0 时，将其入队，更新其可达点的路径数量，出度为 0 的点的路径总数和即为答案。

- **来日方长（4 星）**
    - **关键亮点**：使用记忆化深搜解决问题，思路简洁，在输入时记录每个点的出度和入度，从入度为 0 的点开始搜索，遇到出度为 0 的点返回 1，用数组记录每个点最终能通向几个出度为 0 的点。
    - **核心代码**：
```cpp
int dfs(int st){
    if(!du[st])return 1;
    if(sa[st])return sa[st];
    int sum=0;
    for(Re int i=head[st];i;i=edge[i].nex)
        sum=(sum+dfs(edge[i].to))%Mod;
    sa[st]=sum%Mod;
    return sa[st];
}
```
    - **核心思想**：从入度为 0 的点开始深搜，遇到出度为 0 的点返回 1，使用数组 `sa` 记录每个点的路径数量，避免重复搜索。

### 最优关键思路或技巧
- **数据结构**：使用邻接表存储图，可有效减少空间复杂度，尤其在稀疏图中优势明显。
- **算法优化**：拓扑排序和记忆化搜索都能避免重复计算，提高效率。在计算过程中，每次相加后取模，防止结果溢出。
- **思维方式**：将食物链问题抽象为有向无环图的路径计数问题，通过分析入度和出度确定起点和终点。

### 拓展思路
同类型题可考虑有向无环图上的其他计数问题，如计算特定长度的路径数量、经过特定点的路径数量等。类似算法套路可应用于任务调度、依赖关系处理等场景。

### 推荐题目
- P3183 [HAOI2016]食物链：与本题类似，也是求食物链数量。
- P1137 旅行计划：在有向无环图上进行拓扑排序，计算最长路径。
- P2002 消息扩散：利用拓扑排序解决信息传播问题。

### 个人心得摘录与总结
- **归山_**：做题时一开始以为用搜索，后来发现需要拓扑排序，浪费了时间，提醒我们要准确分析题目，选择合适的算法。
- **EarthGiao**：尝试用 DP 失败后，改用记忆化搜索成功解决问题，说明在解题时可以多尝试不同方法。 

---
处理用时：34.80秒
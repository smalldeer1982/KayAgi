# 题目信息

# kls与flag

## 题目背景

kls毒奶非常厉害。

## 题目描述

有$n$个OI选手，每个人插了一个flag。有一天因为某种原因，flag都被触发了，所以地上有一排$n$根竹竿，竹竿的间距均为一个单位长度，高度在$1\sim m$之间。

kls看到这些竹竿，感觉不好看，于是准备把它们全部放倒。

在这之前，kls想到了一个数学问题。每根竹竿可以往左倒或者往右倒。如果两根竹竿在选择方向放倒之后，它们的顶端可以重合，那么称它们是优秀的。现在kls想要知道，有多少对竹竿是优秀的。

## 说明/提示

### 样例解释

![法法](https://cdn.luogu.com.cn/upload/pic/25795.png)

- 1号和2号向左倒可以顶端重合
- 4号和5号向右倒可以顶端重合
- 1号向右，5号向左可以顶端重合

### 数据范围

对于30%的数据，满足$n\le 2000$，$m\le 5000$；

对于60%的数据，满足$n\le 200000$，$m\le 500000$；

对于100%的数据，满足$n \le 200000$，$m \le 10^9$。

## 样例 #1

### 输入

```
5 5
2 3 3 3 2```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
本题核心是计算$n$根竹竿向左或向右倒后，顶端重合的竹竿对数。题解思路主要分两类：一是用`map`记录每个可能落点的竹竿数量，再计算组合数；二是将所有落点存入数组排序，统计相同落点的竹竿数并计算组合数。部分题解还使用了离散化、多重集合、平衡树等方法。

### 高评分题解
1. **作者：Viston（5星）**
    - **关键亮点**：思路清晰，不使用`map`，将每个杆子可能落到的位置存进数组，排序后$O(N)$扫描，代码简洁高效。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c[200002],d[400002],e=0,i,j,k,l;
int main(){
    ios::sync_with_stdio(false);
    cin>>a>>b;
    for(i=1;i<=a;i++){
        cin>>c[i];e+=2;
        d[e-1]=i-c[i];d[e]=i+c[i];
    }
    sort(d+1,d+e+1);
    for(i=1;i<=2*a;i++){
        if(d[i]!=d[i-1])
            k=0;
        else k++,l+=k;
    }
    cout<<l;
}
```
    - **核心思想**：先将每个竹竿向左和向右倒的落点存入数组，排序后遍历数组，统计相同落点的竹竿数，累加得到答案。

2. **作者：醉梦未苏（4星）**
    - **关键亮点**：使用`map`统计每个落点的竹竿数，思路直观，代码注释详细，易于理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
map<long long,long long> mmp;
long long val(long long x) {
    if(x<2) return 0;
    return x*(x-1)/2;
}
int main()
{
    cin>>n>>m;
    for(long long i=1;i<=n;i++)
    {
        long long k;
        scanf("%lld",&k);
        mmp[k+i]++;
        mmp[i-k]++;
    }
    long long ans=0;
    for(map<long long,long long>::iterator  i=mmp.begin();i!=mmp.end();i++) 
    {
        ans+=val(i->second);
    }
    cout<<ans;
    return 0;
}
```
    - **核心思想**：用`map`记录每个落点的竹竿数，遍历`map`，对每个落点的竹竿数使用等差数列求和公式计算组合数，累加得到答案。

3. **作者：人殇物已非（4星）**
    - **关键亮点**：代码量极短，思路简洁，直接用`map`记录每个落点的覆盖次数，边输入边统计答案，避免了后续遍历计算组合数。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int> ma;
int main(){
    int n,m;
    cin>>n>>m;
    long long ans=0;
    for(int i=1,x;i<=n;i++){
        scanf("%d",&x);
        ans+=ma[i-x]+ma[i+x];
        ma[i-x]++,ma[i+x]++;
    } 
    cout<<ans;
    return 0;
}
```
    - **核心思想**：使用`map`记录每个落点的覆盖次数，每次输入新竹竿时，将其向左和向右倒的落点的覆盖次数累加到答案中，并更新`map`。

### 最优关键思路或技巧
- **数据结构选择**：`map`可方便处理负数下标和大范围数据，避免数组越界问题；也可使用数组存储落点，排序后统计相同元素个数。
- **组合数计算**：若有$n$个相同落点的竹竿，其组合数为$n*(n - 1) / 2$，可通过等差数列求和公式推导得出。
- **边输入边统计**：在输入竹竿高度时，直接统计当前竹竿与之前竹竿的重合对数，避免后续遍历计算。

### 可拓展之处
同类型题可能会改变竹竿的倾倒规则，如增加倾倒方向、限制倾倒范围等，解题思路仍可围绕记录落点和计算组合数展开。类似算法套路可用于处理几何图形的重叠问题、区间重合问题等。

### 推荐题目
1. [P1161 开灯](https://www.luogu.com.cn/problem/P1161)：涉及区间和统计，可使用类似的记录和统计思想。
2. [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)：需要模拟过程并统计相关信息，锻炼逻辑思维和代码实现能力。
3. [P2676 [USACO07DEC]Bookshelf B](https://www.luogu.com.cn/problem/P2676)：可通过排序和统计满足条件的组合数来解决。

### 个人心得摘录与总结
- **糖hhhh？**：30分暴力求解超时，60分用数组记录但因$m$太大爆空间，100分采用哈希表解决。总结：数据范围大时需考虑合适的数据结构，避免空间溢出。
- **Stella_Yan**：先使用$O(N^2)$暴力枚举得30分，再用$O(N)$算法但因$m$太大爆空间得60分，最后将数组改为`map`满分通过。总结：根据数据范围选择合适的数据结构优化算法。
- **猫粮寸断**：因把`long long`写成`int`只过三个点。总结：注意数据类型，避免因数据范围问题导致错误。 

---
处理用时：39.51秒
# 题目信息

# 血小板与凝血因子

## 题目背景

为了尽快修复伤口，血小板们正在搬运凝血因子。它们（没毛病）正在讨论怎么分配，因为它们太可爱了，所以就让你来解决这个问题。

![](https://i.loli.net/2018/10/05/5bb7372e781b1.jpg)

## 题目描述

血小板们有两种不同的容器，第一种容器每个容器中只能装同一种凝血因子，第二种容器每个容器中每种凝血因子最多出现一次。为了方便，血小板们想用**同一种**容器装下所有的凝血因子。

换句话说，把 $n$ 个正整数 $a_1$ ~ $a_n$ 分成一些不相交的集合 $S_1$ ~ $S_m$，满足以下两个条件**之一**： 
1. $\forall a_i,\ a_j\in S_k,\ k\in [1,\ m]$ 有 $a_i=a_j$
2. $\forall a_i,\ a_j\in S_k,\ k\in [1,\ m],\ i\neq j$ 有 $a_i\neq a_j$

因为血小板的数量比较少，所以你要把所有的凝血因子装到尽量少的容器里。它们想知道，如何划分能使容器的总数最小。

## 说明/提示

$1\le n\le 1000,\ \ 1\le a_i\le 10^9$。

## 样例解释

### 样例一：

选用第二种容器，分别放入 $\{4\}$，$\{3,1,2,4,5\}$，$\{4\}$，这是一组可行的最优解，更改三个容器的顺序、容器 $2$ 中 $5$ 个凝血因子的顺序可以得到另外的最优解。

### 样例二/三：

这两组样例输入相同，既可以选用第一种容器，也可以选用第二种容器。

两组样例的输出分别为一组可行的最优解，改变顺序可以得到另外的几组最优解。

### 样例四：

选用第一种容器，分别放入 $\{3,3,3\}$，$\{2,2\}$，这是一组可行的最优解，更改两个容器的顺序可以得到另一组最优解。

## 样例 #1

### 输入

```
7
1 2 3 5 4 4 4```

### 输出

```
3 2
1 4
5 3 1 2 4 5
1 4```

## 样例 #2

### 输入

```
3
20181110 20181111 20181111```

### 输出

```
2 1
1 20181110
2 20181111 20181111```

## 样例 #3

### 输入

```
3
20181110 20181111 20181111```

### 输出

```
2 2
2 20181110 20181111
1 20181111```

## 样例 #4

### 输入

```
5
3 2 3 2 3```

### 输出

```
2 1
3 3 3 3
2 2 2```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先分别计算使用两种容器所需的最少数量，再选择数量较少的容器方案输出具体分组。在计算过程中，使用第一种容器的最少数量等于凝血因子的种类数，使用第二种容器的最少数量等于同种凝血因子出现的最大次数。

各题解的主要区别在于实现统计和输出的方式，部分使用`map`进行统计，部分通过排序后遍历数组统计，还有部分采用离散化处理。

### 所选题解
- **作者：南城忆潇湘（5星）**
    - **关键亮点**：详细介绍了`map`的使用方法，包括迭代器的操作，代码注释清晰，思路明确，利用`map`的特性简洁地完成了统计和输出。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define MAXN 1001
using namespace std;
int a[MAXN];
map<int,int> b;
int main(){
    int n,ans1=0,ans2=0;
    cin>>n;
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]),b[a[i]]++,ans1=max(ans1,b[a[i]]);
    sort(a+1,a+1+n);
    ans2=unique(a+1,a+1+n)-a-1;
    if(ans2<ans1){
        cout<<ans2<<" "<<1<<endl;
        map<int,int>::iterator it=b.begin();
        for(int i=1;i<=ans2;i++){
            cout<<it->second<<" ";
            for(int j=1;j<=it->second;j++)
                printf("%d ",it->first);
            it++;	
            cout<<endl;
        }
    }
    else {
        cout<<ans1<<" "<<2<<endl;
        for(int i=1;i<=ans1;i++){
            map<int,int>::iterator it=b.begin();
            cout<<b.size()<<" ";
            while(it!=b.end()){
                if(b[(*it).first]>0)	cout<<it->first<<" ",b[(*it).first]--; 
                map<int,int>::iterator now=it; it++;
                if(now->second==0)	b.erase(now);	
            }		
            cout<<endl;		
        }
    }
    return 0;
}
```
    - **核心实现思想**：使用`map`统计每种凝血因子的出现次数，通过`unique`函数计算凝血因子的种类数。根据两种容器所需数量的比较结果，使用`map`的迭代器输出具体分组。

- **作者：VenusM1nT（4星）**
    - **关键亮点**：思路清晰，代码简洁，使用`map`记录凝血因子的个数和编号，通过去重数组实现输出，易于理解。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005],id[1005],tot,two;
map <int,int> s;
map <int,bool> used;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        s[a[i]]++;
        two=max(two,s[a[i]]);
        if(!used[a[i]])
        {
            id[++tot]=a[i];
            used[a[i]]=1;
        }
    }
    if(tot<=two)
    {
        printf("%d %d\n",tot,1);
        for(int i=1;i<=tot;i++)
        {
            printf("%d",s[id[i]]);
            for(int j=1;j<=s[id[i]];j++) printf(" %d",id[i]);
            printf("\n");
        }
    }
    else
    {
        int sum=tot;
        printf("%d %d\n",two,2);
        for(int i=1;i<=two;i++)
        {
            printf("%d",sum);
            for(int j=1;j<=tot;j++) if(s[id[j]])
            {
                printf(" %d",id[j]);
                s[id[j]]--;
                if(s[id[j]]==0) sum--;
            }
            printf("\n");
        }
    }
    return 0;
}
```
    - **核心实现思想**：使用`map`记录每种凝血因子的个数，同时使用另一个`map`进行去重，记录不同的凝血因子编号。根据两种容器所需数量的比较结果，输出具体分组。

- **作者：ouuan（4星）**
    - **关键亮点**：提供了排序后遍历数组的解法，代码逻辑清晰，详细展示了如何通过排序和遍历计算凝血因子的种类数和最大出现次数，并输出分组方案。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

int n,a[1010],type,maxx,plan[1010][1010];

int main()
{
    int i,j,temp=0;
    
    cin>>n;
    
    for (i=0;i<n;++i)
    {
        cin>>a[i];
    }
    
    sort(a,a+n);
    
    for (i=0;i<n;++i)
    {
        if (i>0&&a[i]==a[i-1])
        {
            ++temp; 
        }
        else
        {
            ++type; 
            maxx=max(temp,maxx);
            temp=1;
        }
    }
    
    maxx=max(temp,maxx);
    
    if (type>maxx)
    {
        type=0;
        
        for (i=0;i<n;++i)
        {
            if (i>0&&a[i]==a[i-1])
            {
                ++temp;
                plan[temp][++plan[temp][0]]=a[i];
            }
            else
            {
                ++type;
                temp=1;
                plan[1][++plan[1][0]]=a[i];
            }
        }
        
        cout<<maxx<<" 2";
        
        for (i=1;i<=maxx;++i)
        {
            cout<<endl<<plan[i][0];
            for (j=1;j<=plan[i][0];++j)
            {
                cout<<' '<<plan[i][j];
            }
        }
    }
    
    else
    {
        type=0;
        
        for (i=0;i<n;++i)
        {
            if (i>0&&a[i]==a[i-1])
            {
                plan[type][++plan[type][0]]=a[i];
            }
            else
            {
                ++type;
                plan[type][++plan[type][0]]=a[i];
            }
        }
        
        cout<<type<<" 1";
        
        for (i=1;i<=type;++i)
        {
            cout<<endl<<plan[i][0];
            for (j=1;j<=plan[i][0];++j)
            {
                cout<<' '<<plan[i][j];
            }
        }
    }
    
    return 0;
}
```
    - **核心实现思想**：先对数组进行排序，然后遍历数组，计算凝血因子的种类数和最大出现次数。根据两种容器所需数量的比较结果，将凝血因子分组并输出。

### 最优关键思路或技巧
- **使用`map`统计**：`map`可以方便地记录每种凝血因子的出现次数，并且其内部是红黑树结构，插入和查找的时间复杂度为$O(log_2N)$。
- **排序后遍历**：对数组进行排序后，通过遍历数组可以轻松计算凝血因子的种类数和最大出现次数，时间复杂度为$O(nlogn)$。

### 可拓展之处
同类型题或类似算法套路：
- 分组问题：给定一组元素，要求按照一定规则进行分组，使某个指标最优。
- 统计问题：需要统计元素的种类数、出现次数等信息，可使用`map`或排序后遍历的方法。

### 推荐题目
- [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)：考察排序算法的使用。
- [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)：涉及去重和排序的操作。
- [P2676 [USACO07DEC]Bookshelf B](https://www.luogu.com.cn/problem/P2676)：需要对元素进行分组，使某个条件满足。

### 个人心得摘录与总结
- **Mars_Dingdang**：提到在判断第二种容器数量时，最后一次比较不能漏，否则只能拿90分，提醒我们在处理边界情况时要仔细。

---
处理用时：53.77秒
# 题目信息

# [USACO19JAN] Mountain View S

## 题目背景

USACO 2019 年一月月赛银组第三题

## 题目描述

从农场里奶牛 Bessie 的牧草地向远端眺望，可以看到巍峨壮丽的山脉绵延在地平线上。山脉里由 $N$ 座山峰（$1≤N≤10^5$）。如果我们把 Bessie 的视野想象成 $xy$ 平面，那么每座山峰都是一个底边在 $x$ 轴上的三角形。山峰的两腰均与底边成 $45$ 度角，所以山峰的峰顶是一个直角。于是山峰 $i$ 可以由它的峰顶坐标 $(x_i,y_i)$ 精确描述。没有两座山峰有完全相同的峰顶坐标。

Bessie 尝试数清所有的山峰，然而由于它们几乎是相同的颜色，所以如果一座山峰的峰顶在另一座山峰的三角形区域的边界上或是内部，她就无法看清。

请求出 Bessie 能够看见的不同的山峰的峰顶的数量，也就是山峰的数量。

## 说明/提示

在这个例子中，Bessie 能够看见第一座和最后一座山峰。第二座山峰被第一座山峰掩盖了。

## 样例 #1

### 输入

```
3
4 6
7 2
2 5```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解的核心都是判断等腰直角三角形（山峰）之间的覆盖关系，以确定能看见的山峰数量。主要思路有两种：一是计算山峰在 x 轴上的左右端点，排序后遍历判断；二是使用单调队列维护未被覆盖的山峰。

### 所选题解
1. **作者：Alex_Wei（5星）**
    - **关键亮点**：思路清晰，详细分情况讨论了覆盖情况，代码简洁易懂。
    - **核心代码**：
```cpp
struct node{
    int l,r;
}m[100100];
int cmp(node a,node b){return a.l<b.l||(a.l==b.l&&a.r>b.r);}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>x>>y,m[i].l=x-y,m[i].r=x+y;
    sort(m+1,m+n+1,cmp);
    for(int i=1;i<=n;i++)if(m[i].r>w)s++,w=m[i].r;
    cout<<s;
    return 0;
}
```
    - **核心实现思想**：计算每座山的左右端点，按左端点从小到大、左端点相同右端点从大到小排序，遍历排序后的山，若当前山的右端点大于之前最大的右端点，则答案加 1 并更新最大右端点。

2. **作者：一只书虫仔（4星）**
    - **关键亮点**：思路清晰，详细说明了确定等腰直角三角形和判断覆盖的方法，代码规范。
    - **核心代码**：
```cpp
struct line {
    int l, r;
} seg[100086];
bool cmp (line x, line y) {
    if (x.l!= y.l) return x.l < y.l;
    return x.r > y.r;
}
int main () {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        int x, y;
        scanf("%d%d", &x, &y);
        seg[i].l = x - y;
        seg[i].r = x + y;
    }
    sort(seg + 1, seg + n + 1, cmp);
    int L = seg[1].l, R = seg[1].r;
    int cnt = 1;
    for (int i = 2; i <= n; i++)
        if (seg[i].r > R) {
            cnt++;
            R = seg[i].r;
        }
    printf("%d", cnt);
    return 0;
}
```
    - **核心实现思想**：计算每个等腰直角三角形在 x 轴上的左右端点，对区间按左端点从小到大、左端点相同右端点从大到小排序，遍历区间，若当前区间的右端点大于之前最大的右端点，则答案加 1 并更新最大右端点。

3. **作者：Rbu_nas（4星）**
    - **关键亮点**：使用快读优化输入，思路简洁，代码实现清晰。
    - **核心代码**：
```cpp
#define N 100003
int n, maxr, res;
struct Node
{
    int l, r;
    bool operator < (const Node&other) const
    {
        return (l!= other.l)? (l < other.l) : (r > other.r);
    }
};
Node a[N];
int main(void)
{
    read(n);
    for(int i=1; i<=n; ++i)
    {
        int x, y; read(x), read(y);
        a[i].l=x-y, a[i].r=x+y;
    }
    sort(a+1, a+n+1);
    for(int i=1; i<=n; ++i)
        if(a[i].r > maxr) ++res, maxr=a[i].r;
    printf("%d", res);
    return 0;
}
```
    - **核心实现思想**：计算每座山的左右端点，对山按左端点从小到大、左端点相同右端点从大到小排序，遍历排序后的山，若当前山的右端点大于之前最大的右端点，则答案加 1 并更新最大右端点。

### 最优关键思路与技巧
- **计算左右端点**：利用等腰直角三角形的性质，通过峰顶坐标 $(x,y)$ 计算出在 x 轴上的左右端点 $(x - y, 0)$ 和 $(x + y, 0)$，将问题转化为区间覆盖问题。
- **排序策略**：按左端点从小到大、左端点相同右端点从大到小排序，方便后续遍历判断覆盖关系。

### 拓展思路
同类型题可拓展到一般三角形或其他图形的覆盖问题，类似算法套路是先确定图形的边界，再通过排序和遍历判断覆盖关系。

### 推荐题目
1. [P1884 [USACO12FEB]Overplanting S](https://www.luogu.com.cn/problem/P1884)：矩形覆盖问题，与本题思路类似，需判断矩形之间的覆盖关系。
2. [P2774 [CTSC1999]家园](https://www.luogu.com.cn/problem/P2774)：涉及区间覆盖和网络流，对区间覆盖的应用有更高要求。
3. [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：虽然不是覆盖问题，但需要对矩阵中的正方形进行判断和计算，锻炼空间思维和逻辑判断能力。

### 个人心得
- **作者：By_Ha**：提到好多人用计算左右端点的方法跑的慢，自己使用单调队列，常数小跑得快，还指出考试时别人都用常规算法。总结：不同算法有不同的复杂度和常数，可尝试寻找更优算法；考试时要有自己的思考，不盲目跟从。 

---
处理用时：41.15秒
# 题目信息

# [USACO19FEB] Sleepy Cow Herding S

## 题目描述

Farmer John 的 $N$ 头奶牛，总是会迷路走到农场上遥远的地方去！他需要你帮助将她们一起赶回来。

农场的草地大体是一块狭长的区域——我们可以将其想象成一条数轴，奶牛可以占据数轴上的任意整数位置。这 $N$ 头奶牛现在正位于不同的整数位置，Farmer John 想要移动她们，使得她们占据 $N$ 个相邻的位置（例如，位置 $6$、$7$、$8$）。

不幸的是，奶牛们现在很困，Farmer John 要让她们集中精力听从命令移动并不容易。任意时刻，他只能使得一头处在“端点”（在所有奶牛中位置最小或最大）位置的奶牛移动。当他移动奶牛时，他可以命令她走到任意一个未被占用的整数位置，只要在新的位置上她不再是一个端点。可以看到随着时间的推移，这样的移动可以使奶牛们趋向越来越近。

请求出使得奶牛们集中到相邻位置所进行的移动次数的最小和最大可能值。

## 说明/提示

2019 USACO 二月月赛银牌组第一题

## 样例 #1

### 输入

```
3 
4 
7 
9```

### 输出

```
1
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算将数轴上分散的奶牛移动到相邻位置的最小和最大移动次数展开。思路上，大家普遍先对奶牛位置排序，然后分别求解最小和最大移动次数。
- **最小移动次数**：多数题解通过寻找长度为 $n$ 且包含奶牛最多的区间，用总奶牛数减去该区间内奶牛数得到结果，同时会对特殊情况进行特判。
- **最大移动次数**：通常比较将奶牛向左或向右移动时的空位数量，取最大值减去 $n - 2$ 得到答案。

### 所选题解
- **作者：The_Tarnished（5星）**
    - **关键亮点**：思路清晰，代码注释详细，对最小和最大移动次数的求解过程解释明确，方便理解。
    - **核心代码**：
```cpp
int ansmin(){
    if((a[n-2]-a[0]==n-2&&a[n-1]-a[n-2]>2)||(a[n-1]-a[1]==n-2&&a[1]-a[0]>2))
        return 2;
    int j=0;
    for(int i=0;i<n;i++){
        while(j<n-1&&a[j+1]-a[i]<=n-1)
            j++;
        x=max(x,j-i+1);
    }
    return n-x;
}

int ansmax(){
    return max(a[n-2]-a[0],a[n-1]-a[1])-n+2;
}
```
    - **核心实现思想**：`ansmin` 函数先进行特殊情况判断，然后通过双指针遍历找到长度为 $n$ 且包含奶牛最多的区间，用 $n$ 减去该区间内奶牛数得到最小移动次数；`ansmax` 函数比较两个区间长度，减去 $n - 2$ 得到最大移动次数。

- **作者：Sophon（4星）**
    - **关键亮点**：从结果出发分析问题，对最小和最大移动次数的求解思路解释清晰，代码结构合理。
    - **核心代码**：
```cpp
int xhl()
{
    if (a[n - 2] - a[0] == n - 2 && a[n - 1] - a[n - 2] > 2)
    {
        return 2;
    }
    if (a[n - 1] - a[1] == n - 2 && a[1] - a[0] > 2)
    {
        return 2;
    }

    int tmp = 0;
    for (int i = 0, j = 0; i < n; i++)
    {
        while (j < n - 1 && a[j + 1] - a[i] <= n - 1)
        {
            j++;
        }
        tmp = max(tmp, j - i + 1);
    }
    return n - tmp;
}
```
    - **核心实现思想**：`xhl` 函数先进行特殊情况判断，然后通过双指针枚举左端点，找到长度为 $n$ 且包含奶牛最多的区间，用 $n$ 减去该区间内奶牛数得到最小移动次数。

- **作者：神眷之樱花（4星）**
    - **关键亮点**：对题意和最小、最大移动次数的求解思路解释简洁明了，代码实现简洁。
    - **核心代码**：
```cpp
if(a[n - 1] - a[1] == n - 2 && a[n] - a[n - 1] > 2 || a[n] - a[2] == n - 2 && a[2] - a[1] > 2) ans = n - 2;
else {
    for(int i = 1,j = 1; i <= n; i++) {
        while(j < n && a[j + 1] - a[i] + 1 <= n) j++;
        ans = std::max(ans,j - i + 1);
    }
}
printf("%d\n%d",n - ans,std::max(a[n - 1] - a[1],a[n] - a[2]) - n + 2);
```
    - **核心实现思想**：先进行特殊情况判断，若不满足则通过双指针找到长度为 $n$ 且包含奶牛最多的区间，用 $n$ 减去该区间内奶牛数得到最小移动次数；最大移动次数通过比较两个区间长度，减去 $n - 2$ 得到。

### 最优关键思路或技巧
- **双指针法**：在求解最小移动次数时，使用双指针遍历找到长度为 $n$ 且包含奶牛最多的区间，时间复杂度为 $O(n)$。
- **从结果出发分析问题**：通过考虑最终状态（奶牛集中在相邻位置），反向推导最小和最大移动次数的求解方法，简化问题。

### 拓展思路
同类型题或类似算法套路：可以考虑增加移动规则的限制，如每次移动的距离限制、移动方向限制等；或者改变数轴为二维平面，奶牛分布在平面上的整数点，求解移动到相邻位置的最小和最大移动次数。

### 推荐题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)：考察贪心算法和思维能力。
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：涉及贪心策略和优先队列的使用。
3. [P2871 [USACO07DEC]Charm Bracelet S](https://www.luogu.com.cn/problem/P2871)：经典的 0 - 1 背包问题，考察动态规划思想。

### 个人心得摘录与总结
- **作者：龙行龘龘**：认为本题难度不应该是橙题，还自己写了快排，反映出对题目难度的个人看法和对算法实现的探索。
- **作者：Demoe**：在求解最小移动次数时，先尝试暴力解法，遇到问题后通过 Hack 自己发现特殊情况，强调了自我检查和思考的重要性。

---
处理用时：37.34秒
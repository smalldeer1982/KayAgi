# 题目信息

# [USACO20FEB] Timeline G

## 题目描述

Bessie 在过去的 $M$ 天内参加了 $N$ 次挤奶。但她已经忘了她每次挤奶是在哪个时候了。

对于第 $i$ 次挤奶，Bessie 记得它不早于第 $S_i$ 天进行。另外，她还有 $C$ 条记忆，每条记忆形如一个三元组 $(a,b,x)$，含义是第 $b$ 次挤奶在第 $a$ 次挤奶结束至少 $x$ 天后进行。

现在请你帮 Bessie 算出在满足所有条件的前提下，每次挤奶的最早日期。

保证 Bessie 的记忆没有错误，这意味着一定存在一种合法的方案，使得：

- 第 $i$ 次挤奶不早于第 $S_i$ 天进行，且不晚于第 $M$ 天进行；
- 所有的记忆都得到满足；

## 说明/提示

- 测试点 $2 \sim 4$ 满足 $N,C \leq 10^3$。
- 测试点 $5 \sim 10$ 没有特殊限制。

## 样例 #1

### 输入

```
4 10 3
1 2 3 4
1 2 5
2 4 2
3 4 4```

### 输出

```
1
6
3
8```

# AI分析结果

### 综合分析与结论
这些题解主要围绕两种思路解决问题：拓扑排序和差分约束。拓扑排序的思路是将挤奶事件抽象为节点，时间间隔为边权构建有向无环图（DAG），通过拓扑排序递推计算每个节点的最早挤奶时间；差分约束则是将题目条件转化为不等式，通过建图跑最长路来求解。

### 所选题解
- **作者：StudyingFather（5星）**
    - **关键亮点**：思路清晰，代码简洁易懂，直接使用拓扑排序递推计算，是解决本题的经典方法。
    - **核心代码**：
```cpp
while(!q.empty())
{
    int u=q.front();
    q.pop();
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].v,w=e[i].w;
        s[v]=max(s[v],s[u]+w);
        t[v]--;
        if(!t[v])q.push(v);
    }
}
```
    - **核心思想**：利用队列进行拓扑排序，每次取出队首节点，更新其邻接节点的最早挤奶时间，若邻接节点入度变为0则加入队列。

- **作者：一只书虫仔（4星）**
    - **关键亮点**：详细解释了差分约束的原理和推导过程，将题目条件转化为不等式组，通过SPFA算法求最长路解决问题。
    - **核心代码**：
```cpp
while (!q.empty()) {
    int cur = q.front();
    q.pop();
    sum[cur] = 0;
    for (int p = head[cur]; p > 0; p = e[p].next)
        if (dist[e[p].val] < dist[cur] + e[p].len) {
            dist[e[p].val] = dist[cur] + e[p].len;
            vis[e[p].val]++;
            if (vis[e[p].val] >= n + 1)
                return true;
            if (!sum[e[p].val]) {
                q.push(e[p].val);
                sum[e[p].val] = 1;
            }
        }
}
```
    - **核心思想**：使用SPFA算法，不断更新节点的距离，若某个节点入队次数超过n+1则存在负环。

- **作者：Hexarhy（4星）**
    - **关键亮点**：对拓扑排序的思路解释详细，实际建图时无需新建0号节点，直接用$S_i$递推，简化了代码。
    - **核心代码**：
```cpp
while(!q.empty())
{
    const int t=q.front();
    q.pop();
    if(visit[t])
        continue;
    visit[t]=true;
    for(auto it:edge[t])
    {
        s[it.to]=max(s[it.to],s[t]+it.v);
        indeg[it.to]--;
        if(!indeg[it.to])
            q.push(it.to);
    }
}
```
    - **核心思想**：同样是拓扑排序，利用队列更新节点的最早挤奶时间，确保满足所有条件。

### 最优关键思路或技巧
- **建超级源点**：在拓扑排序和差分约束中，通过建立超级源点（如0号节点），将初始条件（$S_i$）转化为边权，方便统一处理。
- **拓扑排序递推**：对于DAG，使用拓扑排序可以按顺序递推计算每个节点的最早时间，避免了重复计算。
- **差分约束转化**：将题目中的条件转化为不等式组，通过建图跑最长路（本题）或最短路来求解。

### 可拓展之处
同类型题或类似算法套路：
- 其他拓扑排序问题，如任务调度、课程安排等，可根据节点的先后关系构建DAG，然后进行拓扑排序。
- 差分约束系统的其他应用，如区间约束问题、不等式求解等，通过将条件转化为不等式，建图求解。

### 推荐题目
- [P1113 杂务](https://www.luogu.com.cn/problem/P1113)
- [P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)
- [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)

### 个人心得摘录与总结
- **gznpp**：考场上没想到差分约束建出来的图是DAG，只好用SPFA，说明在考试时可能会因为思维局限而选择较复杂的方法。
- **那一条变阻器**：建超级源点时只连入度为0的点只能得80分，需要向所有点连边才能考虑所有情况，提醒我们在解题时要全面考虑各种情况。 

---
处理用时：29.65秒
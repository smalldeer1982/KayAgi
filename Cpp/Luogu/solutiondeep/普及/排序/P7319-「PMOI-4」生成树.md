# 题目信息

# 「PMOI-4」生成树

## 题目背景

> 题目正解不会很难，反正很难的也必不会做，所以宁愿相信题目都是善良的。

——command_block 《考前小贴士》

djy 出了一道生成树的题，然后发现做法假了，就把这个题改了一下，作为这场比赛的 B。

## 题目描述

给定 $n$ 个数，第 $i$ 个数的原始权值是 $w_i$，你要按照某种顺序将这些数依次选择。

若当前是第 $i$ 次选数，选择的**原始权值**为 $k$，则其他所有**未被选过**的数的权值均加上 $(-1)^{i+k+1} \times k$。

你需要求出一种选数方案，使得选出的 $n$ 个数**最终**的**权值**和**最大**。

## 说明/提示

【样例解释】

依次选择**编号**为 $\{7,6,5,3,4,1,2\}$ 的数即可。

【数据范围】

**本题采用捆绑测试**。

- Subtask 1（20pts）：$n \le 7$。
- Subtask 2（30pts）：$n \le  10^3$。
- Subtask 3（30pts）：保证所有的 $w_i \ge 0$ 或所有的 $w_i \le 0$。
- Subtask 4（20pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1 \le n \le 10^5,-10^9 \le w \le 10^9$。

## 样例 #1

### 输入

```
7
1 -1 -2 2 -3 3 4```

### 输出

```
66```

# AI分析结果

### 综合分析与结论
这些题解主要围绕贪心算法展开，多数题解先分析出第 $i$ 次选数对答案的贡献为 $(n - i)×(-1)^{k + i + 1}×k$ ，然后通过不同方式确定选数顺序以最大化最终权值和。主要思路有分类讨论奇偶正负、利用排序不等式等。难点在于如何合理排序和处理不同情况（如某类数选完后）。

### 所选题解
- **作者：lgswdn_SA（5星）**
    - **关键亮点**：思路简洁清晰，直接利用排序不等式解决问题，代码简洁高效，无复杂分类讨论。
    - **核心代码**：
```cpp
int n,ans;
vector<int>f,g;

signed main() {
    n=read(); f.resize(n), g.resize(n);
    rep(i,1,n) {
        int w=read(); ans+=w;
        w=w*(w%2?-1:1); f[i-1]=w;
        if((i+1)%2) g[i-1]=-(n-i);
        else g[i-1]=n-i;
    }
    sort(f.begin(),f.end()), sort(g.begin(),g.end());
    rep(i,0,n-1) ans+=f[i]*g[i];
    printf("%lld\n",ans);
    return 0;
}
```
    - **核心实现思想**：将问题转化为求两个数组对应元素乘积和的最大值，通过排序不等式得出将两个数组顺序排序后相乘和最大，进而得到最大权值和。

- **作者：Acc_Robin（5星）**
    - **关键亮点**：思路清晰，详细推导公式并运用排序不等式，代码简洁易懂。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Acc{
    using ll=long long;
    const int N=1e5+9;
    int a[N],b[N];
    ll r;
    void work(){
        int n,i,sav=1;
        for(cin>>n,i=1;i<=n;++i)cin>>a[i],r+=a[i],a[i]=a[i]*(abs(a[i]%2)==1?1:-1);
        for(sav=-1,i=1;i<=n;++i,sav=-sav)b[i]=(n-i)*sav;
        sort(a+1,a+n+1),sort(b+1,b+n+1);
        for(i=1;i<=n;++i)r+=1ll*a[i]*b[i];
        cout<<r<<'\n';
    }
}
int main(){return Acc::work(),0;}
```
    - **核心实现思想**：将题目要求的式子变形为两个序列一一相乘再相加的形式，利用排序不等式将两个序列分别排序后对应相乘求和，最后加上初始序列和得到结果。

- **作者：张晟轩（5星）**
    - **关键亮点**：运用数学竞赛中的排序不等式解决问题，思路独特，代码简洁。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],b[100005];
long long ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%lld",&a[i]);ans+=a[i];
        a[i]*=(a[i]%2==0)?1:-1;
        b[i]=(n-i)*((i+1)%2==0?1:-1);
    }
    sort(a+1,a+n+1);
    sort(b+1,b+1+n);
    for(int i=1;i<=n;++i) ans+=1ll*a[i]*b[i];
    printf("%lld\n",ans);
    return 0;
}
```
    - **核心实现思想**：将最终权值和式子变形，构造两个序列，利用排序不等式得到最大乘积和，进而求出最大权值和。

### 最优关键思路或技巧
- **排序不等式的运用**：将问题转化为两个序列对应元素乘积和的形式，通过排序不等式确定最优排列顺序，避免复杂的分类讨论。
- **贪心策略**：根据数的奇偶性和正负性分类，让贡献大的数尽可能排在前面。

### 可拓展之处
同类型题可能涉及其他形式的贡献计算和排序规则，类似算法套路可用于解决一些需要通过合理排序来优化结果的问题，如不同物品的选择顺序影响最终收益等。

### 推荐题目
- P1090 [NOIP2004 提高组] 合并果子
- P1223 [NOIP2019 普及组] 排队接水
- P1803 凌乱的yyy / 线段覆盖

### 个人心得摘录与总结
- **作者：EnofTaiPeople**：“害的我做了3小时，没时间做第四题”，总结为贪心题有时需要花费较多时间思考和调试，可能会影响后续题目解答，需合理分配时间。
- **作者：FishZe**：“在比赛的时候，想的方法比较憨，两个队列模拟的，感谢大佬[@Zhukov](https://www.luogu.com.cn/user/342383)提出了优化方案，按照他的思路我又进行了优化，才有了如今的代码”，总结为遇到问题时可借助他人思路进行优化，不断改进自己的算法。 

---
处理用时：34.83秒
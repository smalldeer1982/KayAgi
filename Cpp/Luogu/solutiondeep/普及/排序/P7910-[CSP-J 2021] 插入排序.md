# 题目信息

# [CSP-J 2021] 插入排序

## 题目描述

插入排序是一种非常常见且简单的排序算法。小 Z 是一名大一的新生，今天 H 老师刚刚在上课的时候讲了插入排序算法。

假设比较两个元素的时间为 $\mathcal O(1)$，则插入排序可以以 $\mathcal O(n^2)$ 的时间复杂度完成长度为 $n$ 的数组的排序。不妨假设这 $n$ 个数字分别存储在 $a_1, a_2, \ldots, a_n$ 之中，则如下伪代码给出了插入排序算法的一种最简单的实现方式：

这下面是 C/C++ 的示范代码：

```cpp
for (int i = 1; i <= n; i++)
	for (int j = i; j >= 2; j--)
		if (a[j] < a[j-1]) {
			int t = a[j-1];
			a[j-1] = a[j];
			a[j] = t;
		}
```

这下面是 Pascal 的示范代码：

```pascal
for i:=1 to n do
	for j:=i downto 2 do
		if a[j]<a[j-1] then
			begin
				t:=a[i];
				a[i]:=a[j];
				a[j]:=t;
			end;
```

为了帮助小 Z 更好的理解插入排序，小 Z 的老师 H 老师留下了这么一道家庭作业：

H 老师给了一个长度为 $n$ 的数组 $a$，数组下标从 $1$ 开始，并且数组中的所有元素均为非负整数。小 Z 需要支持在数组 $a$ 上的 $Q$ 次操作，操作共两种，参数分别如下：

$1~x~v$：这是第一种操作，会将 $a$ 的第 $x$ 个元素，也就是 $a_x$ 的值，修改为 $v$。保证 $1 \le x \le n$，$1 \le v \le 10^9$。**注意这种操作会改变数组的元素，修改得到的数组会被保留，也会影响后续的操作**。

$2~x$：这是第二种操作，假设 H 老师按照**上面的伪代码**对 $a$ 数组进行排序，你需要告诉 H 老师原来 $a$ 的第 $x$ 个元素，也就是 $a_x$，在排序后的新数组所处的位置。保证 $1 \le x \le n$。**注意这种操作不会改变数组的元素，排序后的数组不会被保留，也不会影响后续的操作**。

H 老师不喜欢过多的修改，所以他保证类型 $1$ 的操作次数不超过 $5000$。

小 Z 没有学过计算机竞赛，因此小 Z 并不会做这道题。他找到了你来帮助他解决这个问题。

## 说明/提示

**【样例解释 #1】**

在修改操作之前，假设 H 老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是 $3, 2, 1$。

在修改操作之后，假设 H 老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是 $3, 1, 2$。

注意虽然此时 $a_2 = a_3$，但是我们**不能将其视为相同的元素**。

**【样例 #2】**

见附件中的 `sort/sort2.in` 与 `sort/sort2.ans`。

该测试点数据范围同测试点 $1 \sim 2$。

**【样例 #3】**

见附件中的 `sort/sort3.in` 与 `sort/sort3.ans`。

该测试点数据范围同测试点 $3 \sim 7$。

**【样例 #4】**

见附件中的 `sort/sort4.in` 与 `sort/sort4.ans`。

该测试点数据范围同测试点 $12 \sim 14$。

**【数据范围】**

对于所有测试数据，满足 $1 \le n \le 8000$，$1 \le Q \le 2 \times {10}^5$，$1 \le x \le n$，$1 \le v,a_i \le 10^9$。

对于所有测试数据，保证在所有 $Q$ 次操作中，至多有 $5000$ 次操作属于类型一。

各测试点的附加限制及分值如下表所示。

| 测试点 | $n \le$ | $Q \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $10$ | $10$ | 无 |
| $5 \sim 9$ | $300$ | $300$ | 无 |
| $10 \sim 13$ | $1500$ | $1500$ | 无 |
| $14 \sim 16$ | $8000$ | $8000$| 保证所有输入的 $a_i,v$ 互不相同 |
| $17 \sim 19$ | $8000$ | $8000$ | 无 |
| $20 \sim 22$ | $8000$ | $2 \times 10^5$ | 保证所有输入的 $a_i,v$ 互不相同 |
| $23 \sim 25$ | $8000$ | $2 \times 10^5$ | 无 |

## 样例 #1

### 输入

```
3 4
3 2 1
2 3
1 3 2
2 2
2 3
```

### 输出

```
1
1
2
```

# AI分析结果

### 综合分析与结论
本题要求对数组进行单点修改和查询元素在插入排序后的位置，且修改操作不超过 5000 次。各题解的思路主要围绕如何高效处理修改和查询操作展开，常见方法有维护有序数组、使用数据结构（如平衡树、树状数组、线段树）、模拟冒泡排序等。

### 所选题解
- **Otomachi_Una_（5星）**
    - **关键亮点**：思路清晰，通过维护有序数组和原下标与现下标关系，每次修改后前后冒泡保持有序，修改操作 $O(n)$，查询操作 $O(1)$。
    - **核心代码**：
```cpp
struct node{
    int pre,id;
}a[MAXN];
bool cmp(node x,node y){
    if(x.pre!=y.pre) return x.pre<y.pre;
    return x.id<y.id;
}
// 修改操作
for(int j=n;j>=2;j--)
    if(cmp(a[j],a[j-1])){
        node kkksc03=a[j];
        a[j]=a[j-1];
        a[j-1]=kkksc03;
    }
for(int j=2;j<=n;j++)
    if(cmp(a[j],a[j-1])){
        node kkksc03=a[j];
        a[j]=a[j-1];
        a[j-1]=kkksc03;
    }
```
- **chenpengda（4星）**
    - **关键亮点**：通过维护数组元素相对排名，每次修改操作 $O(n)$ 遍历更新排名，查询操作 $O(1)$ 输出排名。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=i;j++){
        if(i==j||a[j]<a[i]||a[j]==a[i])b[i]++;
        else b[j]++;
    }
}
// 修改操作
for(int i=1;i<=n;i++){
    if(i==x)continue;
    if((a[i]<a[x]||a[i]==a[x]&&i<x)&&(a[i]>v||a[i]==v&&i>x)){
        b[i]++;b[x]--;
    }
    else if((a[i]>a[x]||a[i]==a[x]&&i>x)&&(a[i]<v||a[i]==v&&i<x)){
        b[i]--;b[x]++;
    }
}
```
- **NightTide（4星）**
    - **关键亮点**：通过维护原位置与排序后位置的对应关系，每次修改后进行元素冒泡保持有序，查询直接输出对应位置。
    - **核心代码**：
```cpp
struct node{
    int val;
    int num;
    bool operator >(const node b) const{
        if(this->val!=b.val) return this->val > b.val;
        else return this->num > b.num;
    }
    bool operator <(const node b) const{
        if(this->val!=b.val) return this->val < b.val;
        else return this->num < b.num;
    }
};
void updata(int x,int v){
    a[order[x]].val=v;
    for(int i=order[x];i<n;i++){
        if(a[i]>a[i+1]){
            swap(a[i],a[i+1]);
        }
    }
    for(int i=order[x];i>1;i--){
        if(a[i]<a[i-1]){
            swap(a[i],a[i-1]);
        }
    }
    get_order();
}
```

### 最优关键思路或技巧
- 利用修改操作次数少的特点，在修改时进行 $O(n)$ 操作，查询时 $O(1)$ 操作，如维护有序数组和元素排名。
- 维护原位置与排序后位置的对应关系，方便查询和修改。

### 拓展思路
同类型题可考察其他排序算法下的元素位置查询和修改，或增加操作类型和限制条件。类似算法套路可用于处理动态数据的排名、位置查询问题，如使用平衡树、树状数组等数据结构。

### 推荐题目
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
- [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)
- [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

### 个人心得摘录与总结
- **Otomachi_Una_**：解释了前后各扫一次的原因，即更改元素时不知道是改大还是改小，如原序列 $4,5,6$，把 $5$ 改成 $1$ 要往前扫，改成 $9$ 要往后扫。
- **qwqUwU**：提出在代码实现时遇到如何用 $O(1)$ 复杂度判断真正修改位置的问题，通过定义数组 $fid$ 为 $id$ 的反函数解决。 

---
处理用时：32.05秒
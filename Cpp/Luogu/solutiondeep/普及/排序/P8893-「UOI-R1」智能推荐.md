# 题目信息

# 「UOI-R1」智能推荐

## 题目背景

数据已加强。

## 题目描述

现在有 $N$ 道题。

天数的编号从 $0$ 开始，每一天你可以做若干道题，你只能做以前推荐过的或者当天推荐的题（每道题只可以做一次）。第一天，智能推荐会推荐 $p$ 道题。

推荐规则如下：

对于第 $i$ 道题，如果有可能被推荐的话，就会有一个题目集合 $s_i$。当且仅当你把 $s_i$ 中每一道题都做出来并且其中有一道题是当天做的，那么下一天就会推荐第 $i$ 题。

你想做完第 $K$ 道题，问至少第几天你才能满足愿望？


## 说明/提示

**【样例解释 #1】**

第 $0$ 天推了第 $1,2$ 题，都做了。

第 $1$ 推了第 $3$ 题，做了。

第 $2$ 推了第 $4$ 题，做了。

第 $3$ 推了第 $5$ 题，也就是第 $K$ 题，做了。

第 $3$ 天即可做完第 $K$ 题目。

**【样例解释 #2】**

第 $0$ 天推了第 $1$ 题，也就是第 $K$ 题，做了。
第 $0$ 天就做完了。

**【数据范围】**

以下记 $\left| s_i \right|$ 表示推荐规则中第 $i$ 条规则中，如果 $v_i$ 被推荐，要做的所有题。

对于 $30\%$ 的数据，保证 $1 \leq N \leq 100$。

对于 $50\%$ 的数据，保证没有环。

对于 $100\%$ 的数据，保证 $1 \le K,s_i,p_i,v_i \le N \le 5\times 10^3$，$0 \leq R \leq 5 \times 10^3$。$|s_i|$ 互不相同，且对于每一个 $|s_i|$ 都有 $p_i$ 互不相同，$v_i$ 互不相同。


## 样例 #1

### 输入

```
5 5 2
1 2
3
3 2 1 2
4 3 1 2 3
5 3 1 3 4```

### 输出

```
3```

## 样例 #2

### 输入

```
1 1 1
1
0```

### 输出

```
0```

## 样例 #3

### 输入

```
7 7 2
1 2
2
3 2 1 2
6 2 1 2```

### 输出

```
-1```

## 样例 #4

### 输入

```
见文件附件的 rec4.in```

### 输出

```
见文件附件的 rec4.ans```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何确定做完第 $K$ 道题的最少天数展开，多数采用模拟或拓扑排序的方法。模拟法通过不断更新每天推荐的题目，判断能否完成第 $K$ 题；拓扑排序则将题目关系构建成有向图，利用拓扑序列的特性求解。

### 所选题解
- **鱼跃于渊（5星）**
    - **关键亮点**：思路清晰，代码简洁易懂，详细阐述了模拟过程，时间复杂度 $O(n^2)$ 可通过本题。
    - **核心代码**：
```cpp
while(1){
    w=nw;nw=0;
    for(int i=1;i<=w;i++)
        ok[i]=nok[i];
    if(!w){
        cout<<"-1\n";
        return 0;
    }
    for(int i=1;i<=w;i++){
        vis[ok[i]]=1;
        for(int j=0,l=relat[ok[i]].size();j<l;j++){
            t[relat[ok[i]][j]]--;
            if(!t[relat[ok[i]][j]]){
                nok[++nw]=relat[ok[i]][j];
            }
        }
    }
    if(vis[k]) break;
    day++;
}
```
    - **核心思想**：不断将明天推荐的题目复制到今天，处理今天推荐的题目，更新需做题数，若第 $K$ 题已做则退出循环，否则天数加一。

- **刘辰雨（5星）**
    - **关键亮点**：详细介绍了拓扑排序的概念、实现方法及优化，将本题转化为拓扑排序问题，代码规范且有注释。
    - **核心代码**：
```cpp
while(!Q.empty()){
    pair<int,int> u = Q.front();
    Q.pop();
    int ID = u.first;
    int Day = u.second;
    if(!Avai[ID])
        continue;
    if(ID == K){
        printf("%d\n",Day);
        return 0;
    }
    for(int End: Edge[ID] ){
        In[End]--;
        if(In[End] == 0){
            Avai[End] = true;
            Q.push({End,Day+1});
        }
    }
}
```
    - **核心思想**：使用队列进行拓扑排序，记录每道题完成的天数，当处理到第 $K$ 题时输出天数。

- **koobee（4星）**
    - **关键亮点**：将题目关系构建成图，用拓扑排序跑最长路求解，代码简洁。
    - **核心代码**：
```cpp
while(!q.empty()){
    int d = q.front();
    q.pop();
    for(int i = 0; i < v[d].size(); i++){
        ind[v[d][i]]--;
        if(ind[v[d][i]]==0){
            if(f[v[d][i]] < 0) f[v[d][i]] = max(f[v[d][i]], f[d] + 1);
            q.push(v[d][i]);
        }
    }
}
```
    - **核心思想**：以最初推荐的题目为起点，进行拓扑排序，更新每道题的完成天数，最后判断第 $K$ 题的完成天数。

### 最优关键思路或技巧
- **拓扑排序**：将题目关系构建成有向图，利用拓扑排序的特性确定做题顺序，避免无效的模拟。
- **队列优化**：在拓扑排序中使用队列，可省掉不必要的遍历，降低时间复杂度。

### 可拓展之处
同类型题可拓展到其他有先后顺序要求的问题，如项目任务安排、课程学习顺序等。类似算法套路可用于解决有向无环图的路径问题、最短/最长路径问题等。

### 洛谷相似题目推荐
- P1113 杂务
- P1983 车站分级
- P2740 [USACO4.2]草地排水Drainage Ditches

### 个人心得摘录与总结
- **yeshubo_qwq**：提到数据加强可能导致的问题，如未判入度清零会出错，提醒在拓扑排序中要注意入度的处理。
- **happybob**：出题人最初给出三次方做法，后发现可拓扑排序并加强数据，暴力被卡，可考虑 `bitset` 优化，说明做题时要关注数据范围和优化算法。 

---
处理用时：28.47秒
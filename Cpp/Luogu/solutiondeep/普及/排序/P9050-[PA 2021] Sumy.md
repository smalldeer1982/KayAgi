# 题目信息

# [PA 2021] Sumy

## 题目描述

有 $n$ 条鱼，其中第 $i$ 条的质量为 $a_i$ 克。

$x$ 能吃掉 $y$ 当且仅当 $a_x > a_y$。

若 $x$ 吃了 $y$，$y$ 会消失，$a_x$ 会变为 $a_x + a_y$。

你可以随意指定吃鱼的顺序，直至留下一条鱼为止。

求每一条鱼是否可能被作为最后**唯一**的鱼留下。**若最终无法只剩下一条鱼，则每条鱼均不满足此条件。**

## 说明/提示

#### 样例 #1 解释
下面用 $x \rightarrow y$ 表示 $x$ 吃 $y$。

留下 $2$ 号鱼的一种方案如下：$2 \rightarrow 1, 2 \rightarrow 3, 2 \rightarrow 4, 2 \rightarrow 5, 2 \rightarrow 6$。
#### 数据范围
对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
6
2 7 1 8 2 8```

### 输出

```
NTNTNT```

## 样例 #2

### 输入

```
3
5 4 4```

### 输出

```
TNN```

# AI分析结果

### 综合分析与结论
这些题解大多围绕排序和二分查找来解决问题，核心思路是利用鱼存活情况的单调性，通过二分查找找到最小能存活到最后的鱼，进而确定所有鱼的存活情况。部分题解还考虑了特殊情况，如所有鱼质量相同。

### 所选题解
- **作者：ZepX_D（5星）**
    - **关键亮点**：思路清晰，代码规范，详细解释了二分查找的原因和过程，复杂度分析明确。
    - **核心代码**：
```cpp
bool check(int k)
{
    while(!q.empty()) q.pop();
    for (int i = 1;i <= n;i++)
        if (i!= k) q.push(a[i].w);
    ll s = a[k].w;
    while (!q.empty())
    {
        if (q.front() >= s) return 0;
        s += q.front();q.pop();
    }
    return 1;
}
```
    - **核心思想**：检查第 `k` 条鱼能否存活，将其他鱼放入队列，模拟吃鱼过程，若遇到比自身质量大的鱼则返回 `false`。

- **作者：Prolystic（4星）**
    - **关键亮点**：详细阐述了从暴力思路到二分思路的转变过程，代码注释丰富，易于理解。
    - **核心代码**：
```cpp
bool solve(long long x)
{
    long long temp = a[x].big;
    for(long long i = 1;i<=n;i++)
    {
        if(i==x)
        {
            continue;
        }
        if(temp>a[i].big)
        {
            temp+=a[i].big;
        }
        else
        {
            return false;
        }
    }
    return true;
}
```
    - **核心思想**：判断第 `x` 条鱼能否存活，遍历其他鱼，若能吃则吃掉，否则返回 `false`。

- **作者：251Sec（4星）**
    - **关键亮点**：对鱼的最优策略和单调性进行了清晰的分析，代码简洁。
    - **核心代码**：
```cpp
bool check(int x) {
    ll t = a[x].v;
    for (int i = 1; i <= n; i++) {
        if (i == x) continue;
        if (t <= a[i].v) return false;
        t += a[i].v;
    }
    return true;
}
```
    - **核心思想**：检查第 `x` 条鱼能否存活，遍历其他鱼，若遇到比自身质量大的鱼则返回 `false`。

### 最优关键思路或技巧
- **单调性利用**：发现鱼存活情况的单调性，通过二分查找最小能存活到最后的鱼，将时间复杂度从 $O(n^2)$ 优化到 $O(n \log n)$。
- **结构体存储**：使用结构体存储鱼的质量和编号，方便排序后还原原始顺序。

### 可拓展之处
同类型题可能会改变吃鱼规则或增加其他条件，如限制吃鱼次数、引入不同种类的鱼等。类似算法套路可应用于具有单调性的判定问题，通过二分查找缩小搜索范围。

### 推荐题目
- [P1873 砍树](https://www.luogu.com.cn/problem/P1873)：二分查找满足条件的最大高度。
- [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：二分查找满足条件的最小跳跃距离。
- [P3853 [TJOI2007]路标设置](https://www.luogu.com.cn/problem/P3853)：二分查找满足条件的最小间隔距离。

### 个人心得摘录与总结
- **Prolystic**：最初采用模拟思路，复杂度为 $O(n^2)$ 无法通过，后在其他大佬帮助下转变为二分思路。总结是遇到复杂度高的问题时，可尝试寻找问题的单调性，利用二分等算法进行优化。 

---
处理用时：23.82秒
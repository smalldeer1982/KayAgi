# 题目信息

# 「TAOI-1」拼凑的断音

## 题目背景

> flick tap flick tap 面を滑って \
> swipe tap swipe tap 「A.R→T」\
> flick tap flick tap 開いて叩いて \
> swipe swipe swipe swipe …もう嫌だな \
> ズルズル 糸が呟く

## 题目描述

你的面前有 $n$ 个音符，它们的动听程度由数列 $\{a_n\}$ 描述。

现在有 $n$ 种魔法，第 $i$ 种魔法会让 $a_i$ 增加 $s(s \gt 0)$。每种魔法的成功几率都为 $\dfrac{p}{q}$，并且彼此独立。

求在施加魔法情况下，最终最动听的音符的动听程度（即，$\max\limits_{i=1}^n a_i$）的期望。

**本题目有 Special Judge，你可以用两种不同的方式输出答案，具体见【输出格式】处**。

## 说明/提示

### 数据范围

**本题采用捆绑测试**。

- Subtask 1（20 points）：$n \leq 15$。
- Subtask 2（15 points）：保证 $\forall i \in [1, n), a_i \leq a_{i+1}$，$a_n \geq a_{n-1}+s$。
- Subtask 3（15 points）：保证 $\forall i,j\in[1,n], a_i = a_j$。
- Subtask 4（50 points）：无特殊限制。

对于所有测试数据，$1 \leq n \leq 10^5$，$1 \leq p \lt q \leq 10^7$，$1 \leq a_i,s \leq 10^7$。

### 样例解释

注意到两个样例的输入相同，区别仅在于输出格式不同。

以下列举了所有可能的魔法施加情况和其对应的最大值以及出现概率：

| 魔法情况 | 动听度最大值 | 出现概率 | 对期望的贡献 |
| :------: | :----------: | :------: | :----------: |
|${\color{black}1},{\color{black}2},{\color{black}3}$|$3$|$\dfrac{8}{27}$|$\dfrac{8}{9}$|
|${\color{red}3},{\color{black}2},{\color{black}3}$|$3$|$\dfrac{4}{27}$|$\dfrac{4}{9}$|
|${\color{black}1},{\color{red}4},{\color{black}3}$|$4$|$\dfrac{4}{27}$|$\dfrac{16}{27}$|
|${\color{black}1},{\color{black}2},{\color{red}5}$|$5$|$\dfrac{4}{27}$|$\dfrac{20}{27}$|
|${\color{red}3},{\color{red}4},{\color{black}3}$|$4$|$\dfrac{2}{27}$|$\dfrac{8}{27}$|
|${\color{red}3},{\color{black}2},{\color{red}5}$|$5$|$\dfrac{2}{27}$|$\dfrac{10}{27}$|
|${\color{black}1},{\color{red}4},{\color{red}5}$|$5$|$\dfrac{2}{27}$|$\dfrac{10}{27}$|
|${\color{red}3},{\color{red}4},{\color{red}5}$|$5$|$\dfrac{1}{27}$|$\dfrac{5}{27}$|

可得，最终的答案为 $\dfrac{35}{9}$。

+ 若使用第一种输出方式，它的值约为 $3.888889$。
+ 若使用第二种输出方式，可以发现 $554580200 \times 9 \equiv 35 \pmod {998244353}$。

## 样例 #1

### 输入

```
3 1 3 2
1 2 3```

### 输出

```
1
3.888889```

## 样例 #2

### 输入

```
3 1 3 2
1 2 3```

### 输出

```
2
554580200```

# AI分析结果

### 综合分析与结论
这些题解大多先对音符动听程度数组排序，再通过不同方式计算最终最动听音符动听程度的期望。思路主要围绕枚举可能成为最大值的数，计算其成为最大值的概率及对期望的贡献。部分题解还对特殊数据情况进行了特判优化。

### 所选题解
- **FFTotoro（5星）**
    - **关键亮点**：思路清晰，算法流程明确，代码实现简洁高效，使用快速幂计算逆元处理取模问题。
    - **个人心得**：比赛结束前13分钟登陆做题，8分钟解决完这一题就润去CF了。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int qpow(int a,int b){
  int r=1;
  while(b){
    if(b&1)r=r%mod*a%mod;
    a=a%mod*a%mod; b>>=1;
  }
  return r;
} 
main(){
  ios::sync_with_stdio(false);
  int n,p,q,s,c=0,w=1; cin>>n>>p>>q>>s;
  (p*=qpow(q,mod-2))%=mod; vector<int> a(n);
  for(auto &i:a)cin>>i;
  sort(a.begin(),a.end(),greater<int>()); 
  for(int i:a){
    if(i+s<a[0])break; 
    (c+=w*p%mod*(i+s)%mod)%=mod; 
    (w*=(mod+1-p)%mod)%=mod; 
  } 
  cout<<"2\n"<<(c+w*a[0]%mod)%mod<<endl;
  return 0;
}
```
核心思想：先将数组降序排序，遍历数组，若当前数加上s大于等于原最大值，则计算其成为最大值的概率及对期望的贡献，最后加上所有未满足前面情况的概率乘以原最大值。

- **MasCotangent（4星）**
    - **关键亮点**：思路清晰，对特殊数据情况进行了特判，代码注释详细。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n,s,a[100001];
    double ans=0,p,q,num;
    bool flag1=true,flag2=true;
    cin>>n>>p>>q>>s;
    num=p/q;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(i>1&&a[i]!=a[i-1]) flag1=false;
        if(i>1&&a[i]<a[i-1]) flag2=false; 
    }
    cout<<1<<'\n';
    if(a[n]-a[n-1]<s) flag2=false;
    if(flag1){
        cout<<a[1]+s;
        return 0;
    }
    if(flag2){
        cout<<fixed<<setprecision(12)<<(a[n]+s)*(p/q)+a[n]*(1.0-p/q);
        return 0;
    }
    sort(a+1,a+n+1);
    for(int i=n;i>=1;i--){
        if(a[i]+s>a[n]) ans=ans+num*(a[i]+s);
        else ans=ans+num*a[n];               
        num=num*(1-p/q);
    }
    ans=ans+pow((1-p/q),n)*a[n];
    cout<<fixed<<setprecision(12)<<ans;
    return 0;
}
```
核心思想：先判断数据是否满足特殊情况，若满足则直接输出结果，否则排序后从大到小遍历数组，计算每个数的权值并累加，最后加上所有魔法均不生效的概率乘以原最大值。

- **是青白呀（4星）**
    - **关键亮点**：思路直观，对每个位置的动听值进行分析，代码实现简洁。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
const int N=1e5+5,inf=1e9+7;
// 省略read函数
int n,p,q,s;
int v[N];
bool cmp(int x,int y){
	return x>y;
}
int main(){
	read(n),read(p),read(q),read(s);
	rep(i,1,n)
	    read(v[i]);
	sort(v+1,v+n+1,cmp);
	double ans=0,num=1;
	rep(i,1,n){
		ans+=double(max(v[1],v[i]+s))*double(p)/double(q)*num;
		num*=double(q-p)/double(q);
	}
	ans+=double(v[1])*num;
	printf("1\n%.10lf",ans);
	return 0;
} 
```
核心思想：将数组从大到小排序，遍历数组，根据当前位置的动听值加上s是否大于原最大值，计算其对答案的贡献，最后加上均未施加魔法的情况对答案的贡献。

### 最优关键思路或技巧
- 对数组进行排序，简化最大值的判断过程。
- 枚举可能成为最大值的数，计算其成为最大值的概率及对期望的贡献。
- 使用快速幂计算逆元处理取模问题。

### 可拓展之处
同类型题可能会改变魔法的施加规则、音符的属性等，但核心思路仍然是计算概率和期望。类似算法套路可用于解决其他概率期望问题，如抽奖问题、游戏道具掉落问题等。

### 推荐题目
- P1297 [国家集训队]单选错位
- P1850 换教室
- P3232 [HNOI2013]游走

### 个人心得总结
- FFTotoro：在比赛剩余时间不多的情况下仍能快速解决问题，体现了对算法的熟练掌握。
- gyyyyx：写漏取模导致调试时间过长，提醒我们在处理取模问题时要格外细心。 

---
处理用时：43.35秒
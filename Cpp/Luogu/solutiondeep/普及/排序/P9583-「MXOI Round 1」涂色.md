# 题目信息

# 「MXOI Round 1」涂色

## 题目描述

小 C 正在用彩铅给一张 $n$ 行 $m$ 列的方格纸涂色。初始时，所有方格都是空白的。

他一共要进行 $q$ 次涂色，每次涂色会选取一行或一列，给这一行或这一列的所有方格都添加 $1$ 层颜色。

小 C 喜欢浅色，所以他会在每次涂色结束后，把所有被涂上 $k$ 层颜色的方格的颜色都擦掉，让这些方格都变成空白的。

小 C 想知道，在最终共有多少方格被涂上了颜色。

## 说明/提示

#### 【样例解释 #1】

第 $1$ 行第 $1$ 列的方格没有被涂上颜色，第 $1$ 行第 $2$ 列的方格被涂上了 $1$ 层颜色，第 $1$ 行第 $3$ 列的方格没有被涂上颜色，第 $1$ 行第 $4$ 列的方格被涂上了 $1$ 层颜色；

第 $2$ 行第 $1$ 列的方格被涂上了 $1$ 层颜色，第 $2$ 行第 $2$ 列的方格被涂上了 $2$ 层颜色，第 $2$ 行第 $3$ 列的方格被涂上了 $1$ 层颜色，第 $2$ 行第 $4$ 列的方格被涂上了 $2$ 层颜色；

第 $3$ 行第 $1$ 列的方格被涂上了 $2$ 层颜色，第 $3$ 行第 $2$ 列的方格的颜色被擦掉了，第 $3$ 行第 $3$ 列的方格被涂上了 $2$ 层颜色，第 $3$ 行第 $4$ 列的方格的颜色也被擦掉了；

最终，共有 $8$ 个方格被涂上了颜色。

#### 【样例 #2】

见附加文件中的 `paint/paint2.in` 与 `paint/paint2.ans`。

该样例满足测试点 $1$ 的限制。

#### 【样例 #3】

见附加文件中的 `paint/paint3.in` 与 `paint/paint3.ans`。

该样例满足测试点 $5$ 的限制。

#### 【样例 #4】

见附加文件中的 `paint/paint4.in` 与 `paint/paint4.ans`。

该样例满足测试点 $20$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le n,m \le 2\times 10^5$，$1 \le k \le q \le 5 \times 10^5$，$op \in \{1,2\}$，保证当 $op=1$ 时 $1 \le x \le n$，当 $op=2$ 时 $1 \le x \le m$。

|测试点编号|$n,m \le$|$q \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim4$|$3000$|$3000$|无|
|$5\sim9$|$3000$|$5\times10^5$|无|
|$10\sim12$|$2\times10^5$|$5\times10^5$|A|
|$13\sim16$|$2\times10^5$|$5\times10^5$|B|
|$17\sim20$|$2\times10^5$|$5\times10^5$|无|

特殊性质 A：保证 $op=1$。

特殊性质 B：保证 $k=2$。

## 样例 #1

### 输入

```
3 4 5 3
1 3
2 4
1 2
1 3
2 2```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解核心思路相近，均是记录每行和每列的涂色次数，通过取模处理避免重复计算，再利用桶统计次数分布，进而计算最终涂色方格数量。部分题解会针对特殊数据范围给出优化策略。各题解在思路清晰度、代码可读性和优化程度上存在差异。

### 所选题解
- **作者：BL_zhanggezi（5星）**
    - **关键亮点**：思路清晰，从最初的二维差分思路逐步优化，详细阐述了二分查找优化为数组计数的过程，代码注释丰富，可读性强。
    - **个人心得**：无
- **作者：wpy233（4星）**
    - **关键亮点**：先提出涂色顺序不影响最终结果，利用引理简化问题，通过公式计算涂色方格数，思路巧妙，代码注释完善。
    - **个人心得**：无
- **作者：Coffee_zzz（4星）**
    - **关键亮点**：针对不同测试点数据范围给出具体解决方案，分析细致，代码简洁高效。
    - **个人心得**：无

### 重点代码及核心思想
#### BL_zhanggezi
```cpp
for(int i=1;i<=m;i++)
{
    c=s[i]%k;
    for(int j=(k-c)%k;j<=h[n];j+=k)
    {
        ans=ans-ss[j];//ss[j]是符合要求的数量
    }
}
```
核心思想：通过两个一维数组分别记录行和列的涂色次数，利用数组计数优化查找满足条件的方格数量，用总方格数减去空白方格数得到最终结果。

#### wpy233
```cpp
for(int i=1;i<=n;i++)
    if(a[i]>0)
    {
        ans1++; //统计去除后有多少被涂色的行
        c[a[i]]++; //用桶存储被涂色过a[i]次的行
    }
for(int i=1;i<=m;i++)
    if(b[i]>0)
    {
        ans2++; //统计去除后有多少被涂色的列
        d[b[i]]++; //用桶存储被涂色过b[i]次的列
    }
ans=ans1*m+ans2*n-ans1*ans2; //公式计算
for(int i=1,j=k-1;i<=k-1,j>=1;i++,j--)
    ans-=c[i]*d[j]; //去除涂色次数加和为k的交叉格
```
核心思想：先去除重复在 $k$ 次以上的涂色部分，统计涂色的行和列数量，利用公式计算涂色方格数，再减去涂色次数加和为 $k$ 的交叉格。

#### Coffee_zzz
```c++
for(int i=1;i<=n;i++) w[r[i]%k]++;
for(int j=1;j<=m;j++){
    c[j]%=k;
    if(c[j]==0) cnt=cnt+n-w[0];
    else cnt=cnt+n-w[k-c[j]];
}
```
核心思想：根据不同测试点数据范围采用不同策略，最终将 $r$ 和 $c$ 中元素对 $k$ 取模，用桶统计 $r$ 中元素出现次数，枚举 $j$ 计算 $c_j$ 对答案的贡献。

### 最优关键思路或技巧
- **降维处理**：用两个一维数组分别记录行和列的涂色次数，避免开二维数组导致的内存问题。
- **取模优化**：每次操作后对涂色次数取模，减少不必要的计算。
- **桶计数**：利用桶统计每行或每列涂色次数对 $k$ 取模后的分布，快速计算满足条件的方格数量。

### 可拓展之处
同类型题可能会改变操作方式（如每次操作改变多个方格的颜色）或增加限制条件（如规定某些方格不能涂色），类似算法套路是通过记录关键信息（如行、列操作次数），利用取模和桶计数等方法优化计算。

### 推荐题目
- P1428 小鱼比可爱
- P1047 校门外的树
- P2670 扫雷游戏

### 个人心得摘录与总结
- **sbno333**：卡在 $60$ 分，赛后发现加了取模操作（`%k`）后通过，提醒在编程时要注意对数据进行取模处理，避免因数据范围问题导致错误。
- **liangjindong0504**：强调用好大样例，遇到问题可以从暴力思路入手，逐步优化，同时要注意数据类型，不开 `long long` 可能会导致错误。
- **rainygame**：赛时发现直接模拟不可行，考虑特殊性质 A 进行简化，遇到列的加和问题时采用正难则反的思路，通过二分查找优化计算，提醒在解题时要灵活运用特殊性质和优化算法。 

---
处理用时：36.11秒
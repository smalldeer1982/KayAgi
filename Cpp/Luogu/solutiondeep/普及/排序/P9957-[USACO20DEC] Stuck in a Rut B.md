# 题目信息

# [USACO20DEC] Stuck in a Rut B

## 题目描述

Farmer John 最近扩大了他的农场，从奶牛们的角度看来这个农场相当于是无限大了！奶牛们将农场上放牧的区域想作是一个由正方形方格组成的无限大二维方阵，每个方格中均有美味的草（将每个方格看作是棋盘上的一个方格）。Farmer John 的 $N$ 头奶牛（$1\le N\le 50$）初始时位于不同的方格中，一部分朝向北面，一部分朝向东面。

每一小时，每头奶牛会执行以下二者之一：

 - 如果她当前所在的方格里的草已经被其他奶牛吃掉了，则她会停下。
 - 吃完她当前所在的方格中的所有草，并向她朝向的方向移动一个方格。

经过一段时间，每头奶牛的身后会留下一条被啃秃了的轨迹。

如果两头奶牛在一次移动中移动到了同一个有草的方格，她们会分享这个方格中的草，并在下一个小时继续沿她们朝向的方向移动。

请求出每头奶牛吃到的草的数量。有些奶牛永远不会停下，从而吃到无限多的草。 

## 说明/提示

### 测试点性质

 - 测试点 $2-5$ 中，所有坐标不超过 $100$。
 - 测试点 $6-10$ 没有额外限制。

## 样例 #1

### 输入

```
6
E 3 5
N 5 3
E 4 6
E 10 4
N 11 2
N 8 1```

### 输出

```
5
3
Infinity
Infinity
2
5```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致，都是将牛按方向分类，通过枚举不同方向牛的组合，比较它们到交点的距离判断谁会被阻拦，进而计算每头牛吃到草的数量。多数题解采用排序优化枚举过程，避免不必要的比较。各题解的差异主要体现在排序方式、代码实现细节和对特殊情况的处理上。

### 所选题解
- **作者：FZY_CZY（5星）**
    - **关键亮点**：思路清晰，详细阐述了判断牛是否被阻拦的方法，代码注释丰富，可读性强。通过排序保证当前奶牛的停止位置是在正确的位置，简化了代码逻辑。
    - **个人心得**：作者在赛上未做出此题，经过思考后总结出正解，提醒自己做题时要理清思路，避免盲目编写代码。
```cpp
for (int i=1;i<=sum_e;i++)
{
    for (int j=1;j<=sum_n;j++)
    {
        if (N[j].x<E[i].x) continue;
        if (N[j].y>E[i].y) continue;
        int A=N[j].x-E[i].x;
        int B=E[i].y-N[j].y;
        if (ans[N[j].id]) continue;
        if (A<B) ans[N[j].id]=B;
        if (A>B)
        {
            ans[E[i].id]=A;
            break;
        }
    }
}
```
核心实现思想：双重循环枚举向东和向北的牛，判断它们的射线是否相交，若相交则比较它们到交点的距离，更新被阻拦牛的答案。

- **作者：Arson1st（4星）**
    - **关键亮点**：结合图形解释思路，形象易懂。对排序的作用解释清晰，指出排序能避免非法阻挡的情况。
```cpp
for (int i = 1; i <= tote; i ++)
    for (int j = 1; j <= totn; j ++) {
        if (N[j].x < E[i].x) continue;
        if (N[j].y > E[i].y) continue;
        int a = N[j].x-E[i].x, b = E[i].y-N[j].y;
        if (ans[N[j].id]) continue;
        if (a < b) ans[N[j].id] = b;
        if (a > b) {ans[E[i].id] = a; break;}
    }
```
核心实现思想：与FZY_CZY的题解类似，通过双重循环枚举不同方向的牛，判断射线相交情况并更新答案。

- **作者：zxh923（4星）**
    - **关键亮点**：思路简洁明了，代码结构清晰，对判断条件和记录答案的过程解释详细。
```cpp
for(int i=1;i<=cnte;i++){
    for(int j=1;j<=cntn;j++){
        if(nor[j].x<eas[i].x||nor[j].y>eas[i].y)continue;
        int x=nor[j].x-eas[i].x,y=eas[i].y-nor[j].y;
        if(ans[nor[j].id])continue;
        if(x<y)ans[nor[j].id]=y;
        if(x>y){
            ans[eas[i].id]=x;
            break;
        }
    }
}
```
核心实现思想：同样是双重循环枚举不同方向的牛，根据条件判断是否更新答案，遇到第一个能挡住的情况就跳出循环。

### 最优关键思路或技巧
- **分类排序**：将牛按方向分为向北和向东两类，分别按横坐标和纵坐标排序，这样可以减少不必要的比较，提高效率。
- **枚举交点**：通过枚举不同方向牛的组合，计算它们到交点的距离，比较距离大小判断谁会被阻拦。
- **提前剪枝**：在枚举过程中，若某头牛已经有答案，则跳过后续比较，避免重复计算。

### 可拓展之处
同类型题可能会增加牛的运动方向、改变地图形状或添加其他限制条件。类似算法套路可用于解决其他涉及物体运动和碰撞的问题，如机器人路径规划、车辆行驶模拟等。

### 推荐题目
- P1036 选数：考察枚举和组合的思想。
- P1149 火柴棒等式：需要枚举所有可能的组合，判断是否满足等式。
- P1217 [USACO1.5]回文质数 Prime Palindromes：涉及枚举和质数判断。

### 个人心得总结
FZY_CZY在赛上未做出此题，经过思考后总结出正解，提醒自己做题时要理清思路，避免盲目编写代码。Union_Find提出自己的做法可能存在问题，希望有人能证明其时间复杂度或进行hack，体现了对算法正确性和复杂度的思考。 

---
处理用时：30.52秒
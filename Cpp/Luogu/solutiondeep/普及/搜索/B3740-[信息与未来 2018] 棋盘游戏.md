# 题目信息

# [信息与未来 2018] 棋盘游戏

## 题目描述

给定一个十进制数 $x$，将它转换为二进制字符串并在高位填 $0$ 以补足 $16$ 位，就得到了
一个长度为 $16$ 的 $01$ 字符串，我们用这个字符串表示 $4 × 4$ 的棋盘，按从左到右、从上到下的顺序将 $0$（白子）、$1$（黑子）放入棋盘。

例如，$(447)_{10} = (0000 0001 1011 1111)_2$，按顺序填入棋盘（$0$ 白子、$1$ 黑子），得到如下棋盘（左边棋盘）：

![](https://cdn.luogu.com.cn/upload/image_hosting/vyma7pie.png)

我们现在可以交换棋盘中**相邻**（共享一条边的两个格子相邻，因此一个格子至多有 $4$ 个相邻的格子）的黑色和白色棋子。从左图的棋盘变为全部白子在上、全部黑子在下（右边棋盘所示）的棋盘，至少需要 $3$ 步。

对于给定的棋盘（保证棋盘中恰好有 $8$ 个白子和 $8$ 个黑子），求把棋盘变为全部白子在上、全部黑子在下最少的交换步数。

## 说明/提示

### 样例解释
#### 样例 $1$
参考上图，将 $(2, 4)$ 处的⿊⼦移动到 $(3, 2)$ 需要 $3$ 步。
#### 样例 $2$
如下图所示，$(42405)_{10} =(1010 0101 1010 0101)_2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/aie8kf0n.png)
### 数据规模
$50\%$ 的测试数据满足棋盘可以在 $6$ 次交换内变为白子在上、黑子在下。

所有数据保证 $0 ≤ x < 2^{16}$，且 $x$ 转换为二进制后恰好有 $8$ 个 $1$。

> 本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
447```

### 输出

```
3```

## 样例 #2

### 输入

```
42405```

### 输出

```
8```

# AI分析结果

### 综合分析与结论

本题要求将给定的4x4棋盘通过最少的交换步数变为“白子在上、黑子在下”的目标状态。由于棋盘规模较小（16个格子），且交换规则限制为相邻格子，因此可以通过广度优先搜索（BFS）或启发式搜索（如A*算法）来求解最短路径。

### 通用建议与扩展思路

1. **BFS搜索**：由于棋盘状态有限（16个格子，每个格子只有两种状态），可以使用BFS来遍历所有可能的状态，找到从初始状态到目标状态的最短路径。BFS的优点是保证找到最短路径，但缺点是状态空间较大时可能效率较低。

2. **A*算法**：如果状态空间较大，可以考虑使用A*算法，通过引入启发式函数来减少搜索空间。启发式函数可以设计为当前状态与目标状态之间的“距离”，例如未正确放置的黑子数量。

3. **状态压缩**：由于棋盘状态可以用一个16位的二进制数表示，可以通过状态压缩来优化存储和搜索效率。

### 推荐题目

1. **P1379 八数码难题**：经典的BFS搜索问题，与本题类似，需要通过交换相邻格子来达到目标状态。
2. **P2324 [SCOI2005] 骑士精神**：同样是一个棋盘上的搜索问题，需要通过移动棋子来达到目标状态。
3. **P1074 靶形数独**：虽然题目不同，但涉及到状态压缩和搜索算法的应用，适合进一步练习。

### 关键实现思想

1. **BFS实现**：
   - 使用队列存储待搜索的状态。
   - 使用哈希表记录已访问的状态，避免重复搜索。
   - 每次从队列中取出一个状态，生成所有可能的下一步状态，并检查是否达到目标状态。

2. **A*算法实现**：
   - 使用优先队列存储待搜索的状态，优先级由启发式函数决定。
   - 启发式函数可以设计为当前状态与目标状态之间的“距离”。
   - 每次从优先队列中取出一个状态，生成所有可能的下一步状态，并更新优先级。

### 核心代码片段（BFS实现）

```cpp
#include <iostream>
#include <queue>
#include <unordered_set>
#include <vector>

using namespace std;

int bfs(int start, int target) {
    queue<pair<int, int>> q;
    q.push({start, 0});
    unordered_set<int> visited;
    visited.insert(start);

    while (!q.empty()) {
        auto [current, steps] = q.front();
        q.pop();

        if (current == target) {
            return steps;
        }

        // Generate all possible next states
        for (int i = 0; i < 16; ++i) {
            if ((current >> i) & 1) {
                // Try swapping with adjacent cells
                for (int dir : {-4, -1, 1, 4}) {
                    int j = i + dir;
                    if (j >= 0 && j < 16 && !((current >> j) & 1)) {
                        int next = current ^ (1 << i) ^ (1 << j);
                        if (visited.find(next) == visited.end()) {
                            visited.insert(next);
                            q.push({next, steps + 1});
                        }
                    }
                }
            }
        }
    }

    return -1; // Should not reach here
}

int main() {
    int x;
    cin >> x;
    int target = 0b0000000011111111; // 目标状态：白子在上，黑子在下
    cout << bfs(x, target) << endl;
    return 0;
}
```

### 总结

本题的关键在于如何高效地搜索棋盘状态空间，BFS和A*算法是两种常用的方法。通过状态压缩和启发式函数，可以进一步优化搜索效率。类似的棋盘搜索问题在算法竞赛中较为常见，掌握这些技巧有助于解决更复杂的问题。

---
处理用时：32.65秒
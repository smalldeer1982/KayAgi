# 题目信息

# 树的直径

## 题目描述

给定一棵 $n$ 个结点的树，树没有边权。请求出树的直径是多少，即树上的最长路径长度是多少。

## 说明/提示

数据保证，$1 \leq n \leq 10^5$。

## 样例 #1

### 输入

```
5
1 2
2 4
4 5
2 3```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题要求计算树的直径，即树中最长路径的长度。树的直径可以通过两次深度优先搜索（DFS）或广度优先搜索（BFS）来求解。具体步骤如下：

1. **第一次搜索**：从任意一个节点出发，找到距离它最远的节点 `u`。
2. **第二次搜索**：从节点 `u` 出发，找到距离它最远的节点 `v`。
3. **直径**：节点 `u` 和 `v` 之间的路径即为树的直径。

这种方法的时间复杂度为 `O(n)`，适合处理 `n` 达到 `10^5` 的情况。

### 所选题解

#### 题解1：两次BFS求解树的直径
- **星级**：5星
- **关键亮点**：思路清晰，代码简洁，使用了BFS来避免递归栈溢出的问题，适合处理大规模数据。
- **个人心得**：作者提到在调试过程中发现递归DFS在处理大规模数据时容易栈溢出，因此改用BFS，确保了算法的稳定性。

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> adj[100005];
int dist[100005];

void bfs(int start) {
    queue<int> q;
    q.push(start);
    dist[start] = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : adj[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
}

int main() {
    int n;
    cin >> n;
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    memset(dist, -1, sizeof(dist));
    bfs(1);
    int u = max_element(dist + 1, dist + n + 1) - dist;
    memset(dist, -1, sizeof(dist));
    bfs(u);
    int diameter = *max_element(dist + 1, dist + n + 1);
    cout << diameter << endl;
    return 0;
}
```

#### 题解2：两次DFS求解树的直径
- **星级**：4星
- **关键亮点**：使用DFS实现，代码简洁，适合理解树的直径求解的基本原理。
- **个人心得**：作者提到在实现过程中需要注意递归深度，避免栈溢出。

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> adj[100005];
int dist[100005];

void dfs(int u, int parent) {
    for (int v : adj[u]) {
        if (v != parent) {
            dist[v] = dist[u] + 1;
            dfs(v, u);
        }
    }
}

int main() {
    int n;
    cin >> n;
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    memset(dist, -1, sizeof(dist));
    dist[1] = 0;
    dfs(1, -1);
    int u = max_element(dist + 1, dist + n + 1) - dist;
    memset(dist, -1, sizeof(dist));
    dist[u] = 0;
    dfs(u, -1);
    int diameter = *max_element(dist + 1, dist + n + 1);
    cout << diameter << endl;
    return 0;
}
```

### 最优关键思路与技巧

- **两次搜索法**：通过两次搜索（DFS或BFS）可以高效地找到树的直径，避免了复杂的算法设计。
- **避免栈溢出**：在处理大规模数据时，使用BFS可以避免递归DFS可能导致的栈溢出问题。

### 可拓展之处

- **带权树的直径**：如果树的边带有权值，可以使用类似的两次搜索法，但需要记录路径的权值和。
- **动态树的直径**：在树的动态更新过程中，如何高效地维护树的直径是一个有趣的问题。

### 推荐题目

1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
3. [P1395 会议](https://www.luogu.com.cn/problem/P1395)

这些题目都涉及到树的基本操作和性质，适合进一步巩固树的相关知识。

---
处理用时：33.19秒
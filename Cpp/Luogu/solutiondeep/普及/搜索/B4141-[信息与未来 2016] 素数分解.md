# 题目信息

# [信息与未来 2016] 素数分解

## 题目描述

素数，又称质数，是指除 $1$ 和其自身之外，没有其他约数的正整数。例如，$2,3,5,7,13$ 都是质数，而 $4,9,12,18$ 则不是。

虽然素数不能分解成除 $1$ 和其自身之外整数的乘积，但却可以分解成更多素数的和。你需要编程求出一个正整数最多能分解成多少个互不相同的素数的和。

## 说明/提示

### 样例 $\textbf 1$ 解释
$21=2+3+5+11$。
### 数据范围
$10\le n\le 200$。

**保证有解。**
> 本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
21```

### 输出

```
4```

## 样例 #2

### 输入

```
128```

### 输出

```
9```

# AI分析结果

### 综合分析与结论

本题要求将一个正整数分解为最多不同素数的和，数据范围较小（10 ≤ n ≤ 200），因此可以采用暴力搜索的方法。题解中使用了DFS（深度优先搜索）来枚举所有可能的素数组合，并通过剪枝优化搜索过程。整体思路清晰，代码实现简洁，适合初学者理解和掌握DFS的基本应用。

### 所选题解

#### 题解1：lizhixun
- **星级**：4星
- **关键亮点**：
  - 使用DFS进行素数组合的枚举，思路清晰。
  - 通过剪枝优化搜索过程，避免不必要的计算。
  - 代码结构简洁，易于理解。
- **个人心得**：
  - 作者在代码中使用了`maxn`来记录最大素数个数，并在DFS过程中进行剪枝，有效减少了搜索空间。
  - 通过`prime`函数判断素数，代码实现简单且高效。

```cpp
void dfs(int step, int sum, int num) {
    if (sum > n) return; // 剪枝
    if (sum == n) {
        maxn = max(maxn, num);
        return;
    }
    if (step == k + 1) return;
    dfs(step + 1, sum, num); // 不选
    dfs(step + 1, sum + pr[step], num + 1); // 选
}
```

### 最优关键思路或技巧

1. **DFS与剪枝**：通过DFS枚举所有可能的素数组合，并在搜索过程中进行剪枝，避免无效的搜索路径，提高算法效率。
2. **素数判断**：使用简单的素数判断函数，确保每个数是否为素数，代码实现简洁高效。
3. **记录最大值**：在DFS过程中记录当前最大素数个数，最终输出结果。

### 可拓展之处

- **类似算法套路**：DFS+剪枝的组合可以应用于其他需要枚举所有可能解的问题，如组合数问题、子集和问题等。
- **优化方向**：对于更大的数据范围，可以考虑使用动态规划（DP）或记忆化搜索来进一步优化时间复杂度。

### 推荐题目

1. **P1217 [USACO1.5]回文质数 Prime Palindromes**：考察素数判断与回文数的结合。
2. **P1036 选数**：DFS应用，选择若干数使其和为素数。
3. **P1044 栈**：DFS与回溯的应用，模拟栈的操作。

### 总结

本题解通过DFS与剪枝的结合，有效解决了素数分解问题，代码简洁且易于理解。对于初学者来说，这是一个很好的DFS应用示例，同时也可以通过此题掌握素数判断的基本方法。

---
处理用时：21.53秒
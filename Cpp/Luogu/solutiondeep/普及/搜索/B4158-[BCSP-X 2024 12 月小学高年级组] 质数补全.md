# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 质数补全

## 题目描述

Alice 在纸条上写了一个质数，第二天再看时发现有些地方污损看不清了。

- 在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数称为质数

请你帮助 Alice 补全这个质数，若有多解输出数值最小的，若无解输出 $-1$。

例如纸条上的数字为 $\tt{1*}$（$\tt{*}$ 代表看不清的地方），那么这个质数有可能为 $11, 13, 17, 19$，其中最小的为 $11$。

## 说明/提示

### 样例 3-6

参考附件中的样例。

### 数据范围

$|s|$ 代表 $s$ 串的长度，对于所有数据，$1 \leq t \leq 10, 1 \leq |s| \leq 7$，$s$ 中仅包含数字或者 $\tt{*}$，并且保证首位不是 $\tt{*}$ 或者 $0$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $\mid s\mid$ | 特殊性质 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $35$ | $\leq 7$ | $s$ 中没有 $\tt{*}$ |  |
| $2$ | $30$ | $\leq 4$ |  |  |
| $3$ | $24$ | $\leq 7$ | $s$ 中至多包含 $1$ 个 $\tt{*}$ | $1$ |
| $4$ | $11$ | $\leq 7$ |  | $1,2,3$ |


## 样例 #1

### 输入

```
10
1*
3**
7**
83*7
2262
6**1
29*7
889*
777*
225*```

### 输出

```
11
307
701
8317
-1
6011
2917
8893
-1
2251```

## 样例 #2

### 输入

```
10
4039***
2***5*5
4099961
25**757
7***0**
1***00*
41811*9
6***0*7
8***1**
6561*59```

### 输出

```
4039019
-1
4099961
2509757
7000003
1000003
4181129
6000047
8000101
6561259```

# AI分析结果

### 综合分析与结论

本题的核心任务是补全一个被污损的质数，要求输出最小的可能质数，若无解则输出 `-1`。由于题目中可能存在多个 `*`，因此需要遍历所有可能的数字组合，并判断是否为质数。由于数据范围较小（`|s| ≤ 7`），暴力枚举是可行的。

### 关键思路与技巧

1. **暴力枚举**：对于每个 `*`，枚举 `0-9` 的所有可能值，生成所有可能的数字组合。
2. **质数判断**：对于生成的每个数字，判断其是否为质数。可以使用简单的质数判断方法，如试除法。
3. **最小化输出**：在所有符合条件的质数中，选择最小的一个输出。
4. **剪枝优化**：在枚举过程中，可以提前判断生成的数字是否已经大于当前找到的最小质数，从而减少不必要的计算。

### 通用建议与扩展思路

- **优化质数判断**：对于较大的数字，可以使用更高效的质数判断方法，如 Miller-Rabin 算法。
- **预处理质数表**：如果数据范围较大，可以预处理质数表，方便快速查询。
- **递归实现**：使用递归可以简化多 `*` 情况下的枚举过程。

### 推荐题目

1. **P3383 【模板】线性筛素数**：学习线性筛法，优化质数判断。
2. **P1217 [USACO1.5]回文质数 Prime Palindromes**：结合质数与回文数的判断，提升综合能力。
3. **P1075 质因数分解**：练习质数的相关应用，加深对质数的理解。

### 个人心得

在调试过程中，需要注意边界条件的处理，如首位不能为 `0`，以及无解情况的判断。此外，递归实现时要注意递归深度，避免栈溢出。

### 核心代码实现

```cpp
#include <iostream>
#include <string>
#include <cmath>
using namespace std;

bool isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

void dfs(string& s, int index, int current, int& minPrime) {
    if (index == s.length()) {
        if (isPrime(current) && current < minPrime) {
            minPrime = current;
        }
        return;
    }
    if (s[index] != '*') {
        dfs(s, index + 1, current * 10 + (s[index] - '0'), minPrime);
    } else {
        for (int i = 0; i <= 9; ++i) {
            if (index == 0 && i == 0) continue; // 首位不能为0
            dfs(s, index + 1, current * 10 + i, minPrime);
        }
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        string s;
        cin >> s;
        int minPrime = INT_MAX;
        dfs(s, 0, 0, minPrime);
        if (minPrime == INT_MAX) {
            cout << -1 << endl;
        } else {
            cout << minPrime << endl;
        }
    }
    return 0;
}
```

### 代码简述

- **isPrime**：判断一个数是否为质数。
- **dfs**：递归枚举所有可能的数字组合，并更新最小质数。
- **main**：读取输入，调用 `dfs` 进行枚举，并输出结果。

---
处理用时：29.21秒
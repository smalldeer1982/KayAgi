# 题目信息

# [GXPC-S 2024] 扫雷

## 题目背景

小林最近迷上了扫雷游戏。

## 题目描述

一个扫雷游戏可以被抽象成一个 $n$ 行 $m$ 列的字符矩阵，不妨记第 $i$ 行第 $j$ 列的字符为 $S_{i,j}$。

若 $S_{i,j}=\texttt{*}$，表示格子 $(i,j)$ 上有一个地雷；

若 $S_{i,j}=\texttt{?}$，表示格子 $(i,j)$ 情况未知；

若 $S_{i,j}\in [0,8]$，表示格子 $(i,j)$ 周围的 $8$ 个格子中有 $S_{i,j}$ 个地雷（这个格子本身没有地雷）。
形式化地说，记

$$
f(i,j)=\begin{cases}
1, & (i,j)\text{ 上有地雷} \\
0, & \text{其他情况} \\
\end{cases}
$$

特别地，对于超出棋盘边界的情况，规定 $f(i,j)=0$。
则 $\displaystyle S_{i,j}=\sum_{p=-1}^1\sum_{q=-1}^1 f(i+p,j+q)$。

给定一个棋盘，你可以任意决定每个 $\texttt{?}$ 格子上是否有炸弹。你想要知道是否存在方案使得这个棋盘是合法的。
我们定义一个棋盘**合法**，当且仅当填有数字 $x$ 的格子周围的八个格子上恰好有 $x$ 个炸弹。

你需要解决 $T$ 组数据。

## 说明/提示

对于第一组数据：问号处选择不填是一种合法方案。可以证明这是唯一的合法方案。

**本题采用捆绑测试。**

- Subtask 1（20pts）：至多存在 $1$ 组 $(i,j)$，使得 $S_{i,j}=\texttt{?}$；
- Subtask 2（80pts）：无额外约束。

对于 $100\%$ 的数据，保证：

- $1\le T,n,m\le 10$；
- 至多存在 $10$ 组 $(i,j)$，使得 $S_{i,j}=\texttt{?}$；
- $\forall 1\le i\le n,1\le j\le m$，保证 $S_{i,j}\in\{0,1,2,3,4,5,6,7,8,\texttt{?},\texttt{*}\}$。


## 样例 #1

### 输入

```
3
2 2
**
2?
2 2
*1
3?
2 2
**
21```

### 输出

```
YES
NO
NO```

# AI分析结果

### 综合分析与结论

本题要求判断给定的扫雷棋盘是否合法，即是否存在一种填充问号格子的方案，使得所有数字格子的周围地雷数与其数字一致。由于棋盘规模较小（最多10x10），且问号格子数量有限（最多10个），可以采用暴力枚举或回溯的方法来解决问题。

### 通用建议与扩展思路

1. **暴力枚举**：由于问号格子数量有限，可以直接枚举每个问号格子的两种可能（有雷或无雷），然后检查整个棋盘是否合法。这种方法在小规模数据下是可行的。
2. **回溯法**：通过递归的方式逐个填充问号格子，并在每一步检查当前棋盘是否合法。如果发现不合法，则回溯到上一步尝试另一种选择。
3. **剪枝优化**：在回溯过程中，可以提前剪枝，即当某个数字格子的周围地雷数已经超过或不足时，直接返回不合法，减少不必要的计算。

### 推荐题目

1. **P1219 八皇后问题**：考察回溯法的经典题目，与本题的回溯思路相似。
2. **P1036 选数**：通过回溯法解决组合问题，与本题的枚举思路相似。
3. **P1120 小木棍**：通过回溯法解决组合优化问题，与本题的剪枝优化思路相似。

### 关键思路与技巧

1. **枚举与回溯**：在小规模问题中，枚举和回溯是解决组合问题的有效方法。通过递归实现，可以清晰地表达问题的解空间。
2. **剪枝优化**：在回溯过程中，通过提前判断当前状态是否合法，可以减少不必要的计算，提高算法效率。
3. **边界处理**：在处理棋盘边界时，需要特别注意边界条件，确保不会越界访问。

### 代码实现

以下是一个简单的回溯法实现的核心代码片段：

```cpp
bool isValid(vector<vector<char>>& board, int n, int m) {
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (board[i][j] >= '0' && board[i][j] <= '8') {
                int cnt = 0;
                for (int p = -1; p <= 1; ++p) {
                    for (int q = -1; q <= 1; ++q) {
                        int x = i + p, y = j + q;
                        if (x >= 0 && x < n && y >= 0 && y < m && board[x][y] == '*') {
                            cnt++;
                        }
                    }
                }
                if (cnt != board[i][j] - '0') return false;
            }
        }
    }
    return true;
}

bool backtrack(vector<vector<char>>& board, int n, int m, int idx) {
    if (idx == n * m) return isValid(board, n, m);
    int i = idx / m, j = idx % m;
    if (board[i][j] != '?') return backtrack(board, n, m, idx + 1);
    board[i][j] = '*';
    if (backtrack(board, n, m, idx + 1)) return true;
    board[i][j] = '.';
    return backtrack(board, n, m, idx + 1);
}

bool solve(vector<vector<char>>& board, int n, int m) {
    return backtrack(board, n, m, 0);
}
```

### 总结

本题的关键在于如何有效地枚举或回溯填充问号格子，并通过剪枝优化减少计算量。对于小规模数据，暴力枚举和回溯法都是可行的解决方案。在实际编码中，需要注意边界条件的处理和剪枝策略的应用，以提高算法的效率。

---
处理用时：28.98秒
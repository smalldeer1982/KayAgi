# 题目信息

# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# AI分析结果

### 综合分析与结论

本题是一个典型的区间动态规划问题，核心在于每行取数的独立性，因此可以将问题分解为对每一行进行区间DP，最后将各行的结果相加。难点在于如何正确设计状态转移方程，并处理大数运算（如使用`__int128`或高精度）。大部分题解都采用了区间DP的思路，但在状态转移方程的设计和实现细节上有所不同。

### 所选高星题解

#### 1. **作者：Jack_Homes_Huang (5星)**
- **关键亮点**：
  - 详细解释了区间DP的状态定义和转移方程，思路清晰。
  - 使用了高精度处理大数运算，代码实现较为完整。
  - 提供了高精度的实现细节，如高精加法、乘法和比较操作。
- **个人心得**：
  - 提到高精度实现的繁琐，但通过结构体重载运算符简化了代码。
- **核心代码**：
  ```cpp
  HP operator + (const HP &a, const HP &b) {
      HP c; c.len = max(a.len, b.len); int x = 0;
      for (int i = 1; i <= c.len; i++) {
          c.p[i] = a.p[i] + b.p[i] + x;
          x = c.p[i] / Mod;
          c.p[i] %= Mod;
      }
      if (x > 0)
          c.p[++c.len] = x;
      return c;
  }
  ```

#### 2. **作者：zhylj (4.5星)**
- **关键亮点**：
  - 使用了`__int128`简化大数运算，代码简洁高效。
  - 状态转移方程设计巧妙，通过乘以2的方式避免了复杂的幂运算。
  - 代码可读性强，逻辑清晰。
- **核心代码**：
  ```cpp
  __int128 solve(__int128 a[]) {
      memset(f,0,sizeof(f));
      for(int len=0;len<=m;++len)
          for(int i=1;i+len<=m;++i)
              f[i][i+len]=max(2*f[i+1][i+len]+2*a[i],2*f[i][i+len-1]+2*a[i+len]);
      return f[1][m];
  }
  ```

#### 3. **作者：qhr2023 (4星)**
- **关键亮点**：
  - 状态转移方程设计合理，通过区间长度计算幂次，思路清晰。
  - 使用了`__int128`处理大数运算，代码简洁。
  - 提供了快速幂的实现，优化了计算效率。
- **核心代码**：
  ```cpp
  __int128 power(__int128 a,__int128 b){
      __int128 ans=1;
      while(b){
          if(b%mod) ans=ans*a;
          b/=mod;
          a=a*a;
      }
      return ans;
  }
  ```

### 最优关键思路与技巧

1. **区间DP**：每行取数的独立性使得问题可以分解为对每一行进行区间DP，状态转移方程通常为`f[l][r] = max(f[l+1][r] + a[l]*2^k, f[l][r-1] + a[r]*2^k)`。
2. **大数处理**：由于数据范围较大，使用`__int128`或高精度处理大数运算是必要的。
3. **优化幂运算**：通过预处理2的幂次或使用位运算优化幂次计算，减少时间复杂度。

### 拓展思路与类似题目

1. **类似题目**：
   - [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)：区间DP的应用。
   - [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)：区间DP的经典问题。
   - [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)：多维DP的应用。

### 个人心得总结

- **调试经历**：多位作者提到高精度实现的繁琐，但通过结构体重载运算符或使用`__int128`简化了代码。
- **踩坑教训**：在状态转移方程中，幂次的计算容易出错，需特别注意。
- **顿悟感想**：区间DP的核心在于状态的定义和转移方程的设计，理解清楚后代码实现会相对简单。

---
处理用时：36.87秒
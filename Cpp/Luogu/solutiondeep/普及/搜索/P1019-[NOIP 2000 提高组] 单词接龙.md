# 题目信息

# [NOIP 2000 提高组] 单词接龙

## 题目背景

注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

NOIP2000 提高组 T3

## 题目描述

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。


## 说明/提示

样例解释：连成的“龙”为 `atoucheatactactouchoose`。

$n \le 20$。

## 样例 #1

### 输入

```
5
at
touch
cheat
choose
tact
a
```

### 输出

```
23
```

# AI分析结果

### 综合分析与结论

本题是一个典型的搜索问题，要求通过单词接龙的方式找到最长的“龙”。由于单词数量较少（n ≤ 20），可以使用深度优先搜索（DFS）或广度优先搜索（BFS）来解决。关键在于如何高效地判断两个单词是否可以相连，并且避免重复使用单词超过两次。

### 通用建议与扩展思路

1. **数据结构选择**：使用数组或哈希表来记录每个单词的使用次数，避免重复使用超过两次。
2. **搜索策略**：DFS 是较为直观的选择，可以通过递归实现。BFS 也可以使用，但需要额外的队列来管理状态。
3. **剪枝优化**：在搜索过程中，可以通过提前判断当前路径是否可能超过已知最大长度来进行剪枝，减少不必要的搜索。
4. **字符串处理**：需要高效地判断两个单词是否可以相连，可以通过预处理所有单词的前后缀信息，减少重复计算。

### 推荐题目

1. **P1019 单词接龙**：与本题几乎相同，可以进一步练习。
2. **P1032 字串变换**：涉及字符串的变换和搜索，适合练习类似算法。
3. **P1078 文化之旅**：涉及状态搜索和剪枝，适合练习搜索优化。

### 关键思路与技巧

1. **预处理前后缀**：提前计算每个单词的所有可能前后缀，方便快速判断是否可以相连。
2. **状态记录**：使用数组或哈希表记录每个单词的使用次数，避免重复使用。
3. **剪枝策略**：在搜索过程中，如果当前路径长度加上剩余单词的最大可能长度仍小于已知最大长度，则提前剪枝。

### 代码实现

以下是使用 DFS 实现的核心代码片段：

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

vector<string> words;
vector<int> used;
int maxLen = 0;

void dfs(string current, int len) {
    maxLen = max(maxLen, len);
    for (int i = 0; i < words.size(); ++i) {
        if (used[i] >= 2) continue;
        for (int j = 1; j <= min(current.length(), words[i].length()); ++j) {
            if (current.substr(current.length() - j) == words[i].substr(0, j)) {
                used[i]++;
                dfs(current + words[i].substr(j), len + words[i].length() - j);
                used[i]--;
                break;
            }
        }
    }
}

int main() {
    int n;
    cin >> n;
    words.resize(n);
    used.resize(n, 0);
    for (int i = 0; i < n; ++i) {
        cin >> words[i];
    }
    char start;
    cin >> start;
    for (int i = 0; i < n; ++i) {
        if (words[i][0] == start) {
            used[i]++;
            dfs(words[i], words[i].length());
            used[i]--;
        }
    }
    cout << maxLen << endl;
    return 0;
}
```

### 代码核心思想

1. **DFS 函数**：递归地尝试将每个单词连接到当前字符串，并更新最大长度。
2. **剪枝**：通过 `used` 数组记录每个单词的使用次数，避免重复使用超过两次。
3. **字符串匹配**：通过 `substr` 函数快速判断两个单词是否可以相连。

### 总结

本题通过 DFS 和剪枝策略可以有效解决，关键在于如何高效地判断单词是否可以相连以及如何避免重复使用单词。预处理前后缀信息和状态记录是优化搜索的重要手段。

---
处理用时：27.85秒
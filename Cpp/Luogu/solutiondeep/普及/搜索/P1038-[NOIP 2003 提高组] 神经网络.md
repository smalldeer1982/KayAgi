# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果

### 综合分析与结论

本题的核心是通过拓扑排序处理神经网络的层次结构，计算每个神经元的状态。题解中大部分作者采用了拓扑排序的思路，但在实现细节上有所不同，尤其是在处理输入层、阈值、以及输出层的判断上。部分题解在代码简洁性和优化上表现较好，而另一些则通过详细的注释和调试经验提供了更多参考价值。

### 所选高星题解

#### 1. **Lucaster_ (5星)**
- **关键亮点**：代码简洁，思路清晰，使用了队列进行拓扑排序，并详细解释了每一步的实现逻辑。作者还提供了优化后的代码版本，减少了冗余部分。
- **个人心得**：作者提到自己在调试过程中遇到了一些坑点，最终通过逐步调试解决了问题，强调了拓扑排序的灵活应用。
- **核心代码**：
  ```cpp
  while(!q.empty()) {
      h = q.front(); q.pop();
      if(c[h] <= 0) continue;
      for(i = hd[h]; i; i = e[i].next) {
          t = e[i].to;
          c[t] += e[i].val * c[h];
          if(!vis[t]) {
              q.push(t);
              vis[t] = true;
          }
      }
  }
  ```
  **核心思想**：通过队列进行拓扑排序，确保每个神经元的状态在计算时其前驱节点已经处理完毕。

#### 2. **zzlzk (4星)**
- **关键亮点**：详细分析了题目中的公式，提出了阈值的预处理方法，避免了重复计算。代码结构清晰，注释详细。
- **个人心得**：作者强调了输入层的阈值不需要处理，这一点在调试过程中尤为重要。
- **核心代码**：
  ```cpp
  for(int i = 1; i <= n; i++) {
      if(!indeg[i]) st[++top] = i;
      else c[i] -= u[i];
  }
  ```
  **核心思想**：在拓扑排序前预处理阈值，减少后续计算中的冗余操作。

#### 3. **ghj1222 (4星)**
- **关键亮点**：使用了栈实现拓扑排序，代码结构清晰，注释详细。作者还强调了输出层的判断条件。
- **个人心得**：作者提到自己在调试过程中发现了一些细节问题，最终通过仔细审题解决了问题。
- **核心代码**：
  ```cpp
  while(top != 0) {
      int u = st[top--];
      if(c[u] <= 0) continue;
      for(int i = head[u]; i; i = edge[i].next) {
          int v = edge[i].v;
          c[v] += c[u] * edge[i].w;
          indeg[v]--;
          if(indeg[v] == 0) st[++top] = v;
      }
  }
  ```
  **核心思想**：通过栈实现拓扑排序，确保每个神经元的状态在计算时其前驱节点已经处理完毕。

### 最优关键思路与技巧
1. **拓扑排序**：通过队列或栈实现拓扑排序，确保每个神经元的状态在计算时其前驱节点已经处理完毕。
2. **阈值预处理**：在拓扑排序前预处理阈值，减少后续计算中的冗余操作。
3. **输出层判断**：通过记录出度或判断是否有出边来确定输出层，确保输出结果符合题意。

### 可拓展之处
- **类似算法套路**：拓扑排序在处理有向无环图（DAG）时非常有用，类似的题目可以包括任务调度、依赖关系处理等。
- **举一反三**：可以通过改变神经网络的层次结构或增加不同类型的神经元来拓展题目难度。

### 推荐题目
1. **P1113 杂务**：考察拓扑排序的应用，处理任务的依赖关系。
2. **P1983 车站分级**：通过拓扑排序处理车站的等级关系。
3. **P2742 [USACO5.3]量取牛奶**：考察拓扑排序在任务调度中的应用。

### 个人心得总结
- **调试经验**：多位作者提到在调试过程中遇到了一些细节问题，如阈值的处理、输入层的判断等，最终通过仔细审题和逐步调试解决了问题。
- **顿悟感想**：拓扑排序在处理层次结构问题时非常灵活，通过队列或栈的实现方式可以有效地解决问题。

---
处理用时：41.75秒
# 题目信息

# 波浪数

## 题目描述

波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。

类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $2\le l\le r\le 32$，$1\le L\le R\le 10^7$，$k\in \{2, 3, 4\}$。

## 样例 #1

### 输入

```
10 11 190000 960000 2```

### 输出

```
191919
383838
575757
767676
959595```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地生成和判断波浪数，尤其是多重波浪数。大多数题解采用了逆向思维，即先构造波浪数，再判断其是否满足多重波浪数的条件。这种思路避免了直接判断每个数在不同进制下的波浪性，从而提高了效率。以下是各题解的主要亮点和不足：

1. **逆向思维**：多数题解通过构造波浪数，再判断其是否在指定范围内，避免了直接判断每个数的波浪性，提高了效率。
2. **优化构造过程**：部分题解通过优化波浪数的生成过程，减少了不必要的计算，如提前终止循环、避免重复计算等。
3. **代码可读性**：部分题解代码结构清晰，注释详细，便于理解。

### 所选高星题解

#### 1. **Crazily (5星)**
- **关键亮点**：逆向思维，通过构造波浪数并存储其重数，最后直接输出符合条件的数。代码结构清晰，注释详细。
- **个人心得**：作者提到在考场上没有想出逆向思维，考后才意识到这种思路的优越性，体现了思维的转变过程。
- **核心代码**：
  ```cpp
  for(int k=a;k<=b;++k){
      for(int i=1;i<k;++i){
          for(int j=0;j<k;++j){
              if(i!=j){
                  x=0;
                  t=0;
                  while(x<=r){
                      if(t%2==0) x=x*k+i;
                      else x=x*k+j;
                      ++t;
                      if(x>=l&&x<=r) ++v[x];
                  }
              }
          }
      }
  }
  ```

#### 2. **Star_Wind (4星)**
- **关键亮点**：通过子函数构造波浪数，代码结构清晰，逻辑简单明了。
- **核心代码**：
  ```cpp
  void make(int x){
      for(int i=1;i<x;i++)
          for(int j=0;j<x;j++)
              if(i!=j){
                  len=0;
                  t=0;
                  while(t<r){
                      len++;
                      if(len%2==0) a[len]=i;
                      else a[len]=j;
                      t=t*x+a[len];
                      if(t>r) break;
                      b[t]++;
                  }
              }
  }
  ```

#### 3. **Y_B_Y (4星)**
- **关键亮点**：通过枚举波浪数的两个交替数字，构造波浪数并判断其重数，思路清晰，代码简洁。
- **核心代码**：
  ```cpp
  for(int p=j1;p<=j2;p++){
      memset(b,0,sizeof(b));
      for(int i=0;i<=p-1;i++){
          for(int j=0;j<=p-1;j++){
              if(i!=j){
                  int tot=0;
                  for(int l=1;l<=10;l++){
                      if(tot+j*pow(p,2*l-2)<=ed){
                          if(!b[tot+(int)(j*pow(p,2*l-2))]) yes[tot+int(j*pow(p,2*l-2))]++;
                          b[tot+(int)(j*pow(p,2*l-2))]=1;
                      }
                      if(tot+i*pow(p,2*l-1)+j*pow(p,2*l-2)<=ed){
                          tot+=i*pow(p,2*l-1)+j*pow(p,2*l-2);
                          if(!b[tot])yes[tot]++;
                          b[tot]=1;
                      }
                      else break;
                  }
              }
          }
      }
  }
  ```

### 最优关键思路与技巧

1. **逆向思维**：通过构造波浪数，再判断其是否在指定范围内，避免了直接判断每个数的波浪性，提高了效率。
2. **优化构造过程**：通过提前终止循环、避免重复计算等优化手段，减少不必要的计算。
3. **代码结构清晰**：通过子函数、详细注释等手段，提高代码的可读性和可维护性。

### 可拓展之处

1. **多重波浪数的扩展**：可以进一步扩展到五重、六重波浪数，甚至更高重数的波浪数。
2. **其他进制转换问题**：类似的问题可以扩展到其他进制转换或数字特性判断的题目中。

### 推荐题目

1. **P1113 波浪数 II**：进一步考察波浪数的生成与判断。
2. **P1114 进制转换**：考察不同进制之间的转换与数字特性。
3. **P1115 数字特性**：考察数字在不同进制下的特性与判断。

---
处理用时：40.48秒
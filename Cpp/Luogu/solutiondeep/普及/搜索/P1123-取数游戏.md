# 题目信息

# 取数游戏

## 题目描述

一个 $N\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。

## 说明/提示

### 样例解释

对于第一组数据，取数方式如下：

$$\begin{matrix}
[67] & 75 & 63 & 10 \\
29 & 29 & [92] & 14 \\
[21] & 68 & 71 & 56 \\
8 & 67 & [91] & 25 \\
\end{matrix}$$


### 数据范围及约定

- 对于$20\%$的数据，$1\le N, M \le 3$；
- 对于$40\%$的数据，$1\le N, M\le 4$；
- 对于$60\%$的数据，$1\le N, M\le 5$；
- 对于$100\%$的数据，$1\le N, M\le 6$，$1\le T\le 20$。


## 样例 #1

### 输入

```
3
4 4
67 75 63 10
29 29 92 14
21 68 71 56
8 67 91 25
2 3
87 70 85
10 3 17
3 3
1 1 1
1 99 1
1 1 1

```

### 输出

```
271
172
99
```

# AI分析结果

### 综合分析与结论

本题的核心问题是在一个矩阵中选取不相邻的数字，使得它们的和最大。由于数据范围较小（N, M ≤ 6），大多数题解采用了深度优先搜索（DFS）或状态压缩动态规划（状压DP）来解决。DFS的思路是通过回溯枚举每个数字的取或不取，并标记相邻的数字，确保不违反规则。状压DP则是通过二进制状态表示每一行的选取情况，并通过状态转移方程来优化计算。

从题解质量来看，DFS的实现较为直观，但容易在回溯和状态标记上出错；状压DP的实现较为复杂，但效率更高，尤其是在处理较大数据时。整体上，DFS的题解较多，但部分题解在优化和代码可读性上表现不佳。状压DP的题解虽然较少，但思路清晰，优化到位。

### 所选高质量题解

#### 1. 作者：绿萧 (赞：199) - 4.5星
**关键亮点**：
- 使用DFS进行暴力枚举，思路清晰，代码结构简洁。
- 通过`mark`数组记录每个点的相邻状态，确保不选取相邻的数字。
- 回溯时正确处理了状态恢复，避免了重复计算。

**核心代码**：
```cpp
void dfs(int x,int y){
    if(y==m+1){ dfs(x+1,1); return; }
    if(x==n+1){ mx=max(ans,mx); return; }
    
    dfs(x,y+1); // 不取此数的情况
    
    if(mark[x][y]==0){ // 取此数的情况
        ans+=s[x][y];
        for(int fx=0;fx<8;++fx) ++mark[x+d[fx][0]][y+d[fx][1]];
        dfs(x,y+1);
        for(int fx=0;fx<8;++fx) --mark[x+d[fx][0]][y+d[fx][1]];
        ans-=s[x][y];
    }
}
```
**个人心得**：
- 作者提到贪心和动态规划不适用，最终选择了DFS，体现了对问题的深入思考。

#### 2. 作者：IntrepidStrayer (赞：23) - 4星
**关键亮点**：
- 使用状压DP，预处理合法状态，优化了状态转移。
- 通过`check1`和`check2`函数分别检查行内和行间的合法性，确保状态转移的正确性。
- 代码结构清晰，优化到位。

**核心代码**：
```cpp
bool check1(int x){
    for(;x;x>>=1) if((x&3)==3) return false;
    return true;
}
bool check2(int x,int y){
    return !(x&(y<<1))&&!(x&y)&&!(x&(y>>1));
}
```
**个人心得**：
- 作者提到状压DP的思路来源于对问题的深入分析，体现了对算法的深刻理解。

#### 3. 作者：回头是岸 (赞：11) - 4星
**关键亮点**：
- 使用状压DP，通过预处理每一行的合法状态，优化了状态转移。
- 通过`f[i][j]`表示前i行、最后一行状态为j时的最大值，状态转移方程清晰。
- 代码简洁，优化到位。

**核心代码**：
```cpp
void work(){
    for(int i=0;i<(1<<m);i++) if(!(i&(i>>1))&&!(i&(i<<1))) t.push_back(i);
}
```
**个人心得**：
- 作者提到状压DP的思路来源于对问题的深入分析，体现了对算法的深刻理解。

### 最优关键思路与技巧

1. **DFS回溯与状态标记**：在DFS中，通过`mark`数组记录每个点的相邻状态，确保不选取相邻的数字，并在回溯时正确恢复状态。
2. **状压DP与预处理**：通过二进制状态表示每一行的选取情况，预处理合法状态，优化状态转移，确保算法的效率。
3. **剪枝优化**：在DFS中，通过剪枝减少不必要的搜索，提高算法效率。

### 可拓展之处

- **类似问题**：类似的问题包括在棋盘上放置不相邻的棋子、选取不相邻的元素等，都可以使用DFS或状压DP来解决。
- **算法套路**：DFS回溯和状压DP是解决这类问题的常见套路，掌握这两种方法可以应对多种类似问题。

### 推荐题目

1. [P1896 互不侵犯](https://www.luogu.com.cn/problem/P1896) - 状压DP经典题目，考察在棋盘上放置不相邻的棋子。
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433) - 使用DFS或状压DP解决路径规划问题。
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 背包问题的变种，考察动态规划的应用。

---
处理用时：44.38秒
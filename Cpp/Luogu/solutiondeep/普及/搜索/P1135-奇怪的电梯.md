# 题目信息

# 奇怪的电梯

## 题目背景

感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。

## 样例 #1

### 输入

```
5 1 5
3 3 1 2 5
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心是求解从起点到终点的最短路径，电梯的移动规则类似于图中的边权为1的边。因此，题解大多采用了广度优先搜索（BFS）或最短路径算法（如Dijkstra、SPFA等）来解决。BFS因其天然的层次遍历特性，能够保证第一次到达终点时即为最短路径，因此是最为常见且高效的解法。部分题解还探讨了DFS的优化剪枝策略，但由于DFS在未优化的情况下容易超时，因此BFS更为推荐。

### 精选题解

#### 1. 作者：_H17_ (5星)
**关键亮点**：  
- 提供了多种算法实现（Dijkstra、SPFA、DFS、Floyd、BFS、Bellman-Ford），全面覆盖了可能的解法。
- 代码结构清晰，注释详细，适合初学者理解。
- 特别强调了BFS的正确性，并解释了其与Dijkstra的关系。

**个人心得**：  
作者提到BFS是“不记录dis还不排序的Dijkstra”，这一观点简洁明了地解释了BFS在边权相等时的优势。

**核心代码**：
```cpp
int bfs(){
    q.push(node{a,0});
    u[a]=1;
    while(!q.empty()){
        int x=q.front().x,y=q.front().y;
        q.pop();
        if(x==b) return y;
        int xn=x+k[x],yn=y+1;
        if(xn<=n&&xn>0&&!u[xn]) q.push(node{xn,yn}),u[xn]=1;
        xn-=2*k[x];
        if(xn<=n&&xn>0&&!u[xn]) q.push(node{xn,yn}),u[xn]=1;
    }
    return-1;
}
```
**实现思想**：使用队列进行BFS，每次从当前楼层向上或向下移动，并记录步数，直到到达终点。

#### 2. 作者：yummy (4星)
**关键亮点**：  
- 详细分析了DFS的优化剪枝策略，特别是如何通过记录每个节点的最小步数来避免重复搜索。
- 提供了正确剪枝的DFS实现，时间复杂度为O(n^2)，适合对DFS有深入理解的读者。

**核心代码**：
```cpp
void dfs(int s,int t){
    ans[s]=t;
    if(s+dis[s]<=n && t+1<ans[s+dis[s]]) dfs(s+dis[s],t+1);
    if(s-dis[s]>0  && t+1<ans[s-dis[s]]) dfs(s-dis[s],t+1);
}
```
**实现思想**：通过记录每个节点的最小步数，避免重复搜索，确保每次DFS调用都能有效减少步数。

#### 3. 作者：cff_0102 (4星)
**关键亮点**：  
- 提供了简洁的BFS实现，代码可读性高，适合初学者。
- 特别处理了起点和终点相同的情况，避免了不必要的搜索。

**核心代码**：
```cpp
int bfs(){
    queue<int>q;
    q.push(s);
    int t=0;vis[s]=1;
    while(++t){
        int x=q.size();
        if(x==0) return -1;
        for(int i=0;i<x;i++){
            int p=q.front();
            q.pop();
            if(p-a[p]>0 && !vis[p-a[p]]){
                if(p-a[p]==e) return t;
                vis[p-a[p]]=1;
                q.push(p-a[p]);
            }
            if(p+a[p]<=n && !vis[p+a[p]]){
                if(p+a[p]==e) return t;
                vis[p+a[p]]=1;
                q.push(p+a[p]);
            }
        }
    }
}
```
**实现思想**：使用队列进行BFS，每次扩展当前楼层的上下移动，并记录步数，直到到达终点。

### 最优关键思路与技巧

1. **BFS的优势**：在边权相等的情况下，BFS能够保证第一次到达终点时即为最短路径，且无需复杂的排序或优先队列，时间复杂度为O(n)。
2. **DFS的剪枝优化**：通过记录每个节点的最小步数，避免重复搜索，可以将DFS的时间复杂度优化到O(n^2)。
3. **代码简洁性与可读性**：清晰的代码结构和适当的注释能够帮助读者快速理解算法实现，特别是在处理边界条件（如起点和终点相同）时。

### 可拓展之处

- **类似题目**：类似的最短路径问题可以通过BFS或Dijkstra解决，如迷宫问题、图的连通性问题等。
- **算法套路**：BFS适用于边权相等的最短路径问题，而Dijkstra适用于边权不等的情况。DFS则适用于需要深度遍历的场景，但需注意剪枝以避免超时。

### 推荐题目

1. **P1141 01迷宫**：考察BFS在迷宫中的应用。
2. **P1443 马的遍历**：BFS在棋盘上的应用，求最短路径。
3. **P3371 【模板】单源最短路径（弱化版）**：Dijkstra算法的模板题，适合练习最短路径算法。

### 个人心得总结

- **BFS的正确性**：BFS在边权相等时能够保证第一次到达终点即为最短路径，这一特性使其成为解决此类问题的首选。
- **DFS的剪枝**：通过记录每个节点的最小步数，可以有效避免重复搜索，提升DFS的效率。
- **代码简洁性**：清晰的代码结构和适当的注释能够帮助读者快速理解算法实现，特别是在处理边界条件时。

---
处理用时：49.43秒
# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果

### 综合分析与结论

本题要求动态维护前奇数项的中位数，常见的解法包括对顶堆、平衡树、树状数组、线段树等。通过对多条题解的分析，发现对顶堆是最为简洁且高效的解法，适合在竞赛中使用。其他方法如平衡树、树状数组等虽然也能解决问题，但代码复杂度较高，适合对数据结构有深入理解的同学。

### 所选高星题解

#### 1. **题解作者：肖恩Sean (赞：525)**
- **星级：5星**
- **关键亮点**：使用对顶堆（大根堆和小根堆）维护中位数，思路清晰，代码简洁，时间复杂度为O(n log n)，适合竞赛使用。
- **核心思想**：维护两个堆，大根堆存储较小的数，小根堆存储较大的数，保证大根堆的堆顶始终为中位数。
- **代码片段**：
  ```cpp
  priority_queue<int,vector<int> > q1; // 大根堆
  priority_queue<int,vector<int>,greater<int> > q2; // 小根堆
  int main(){
      int n=read();q1.push(read());
      cout<<q1.top()<<endl; 
      for (int i=2;i<=n;i++){
          int input=read();
          if (input>q1.top()) q2.push(input);
          else q1.push(input);
          while (abs(q1.size()-q2.size())>1)
              if (q1.size()>q2.size()){q2.push(q1.top());q1.pop();}
              else{q1.push(q2.top());q2.pop();}
          if (i%2) cout<<(q1.size()>q2.size()?q1.top():q2.top())<<endl;
      }
      return 0;
  }
  ```

#### 2. **题解作者：IRipple (赞：364)**
- **星级：4星**
- **关键亮点**：使用对顶堆，并通过维护一个`mid`变量来简化中位数的获取，代码实现较为直观。
- **核心思想**：通过比较新插入的数与当前中位数，决定将其放入大根堆或小根堆，并动态调整堆的大小，保证中位数的正确性。
- **代码片段**：
  ```cpp
  priority_queue<int,vector<int>,less<int> >q1; // 大根堆
  priority_queue<int,vector<int>,greater<int> >q2; // 小根堆
  int main(){
      cin>>n;
      scanf("%d",&a[1]);
      mid=a[1];
      cout<<mid<<endl;
      for(int i=2;i<=n;i++){
          scanf("%d",&a[i]);
          if(a[i]>mid) q2.push(a[i]);
          else q1.push(a[i]);
          if(i%2==1){
              while(q1.size()!=q2.size()){
                  if(q1.size()>q2.size()){
                      q2.push(mid);
                      mid=q1.top();
                      q1.pop();
                  }
                  else{
                      q1.push(mid);
                      mid=q2.top();
                      q2.pop();
                  }
              }
              cout<<mid<<endl;
          }
      }
      return 0;
  }
  ```

#### 3. **题解作者：uniquantum (赞：2)**
- **星级：4星**
- **关键亮点**：使用对顶堆，并通过每次插入两个数来简化调整过程，代码简洁且易于理解。
- **核心思想**：每次插入两个数，较小的放入大根堆，较大的放入小根堆，并通过调整堆的大小来保证中位数的正确性。
- **代码片段**：
  ```cpp
  priority_queue<int> q1; // 大根堆
  priority_queue<int, vector<int>, greater<int>> q2; // 小根堆
  int main() {
      int n, x1, x2, mid;
      scanf("%d", &n);
      scanf("%d", &x1);
      q1.push(x1);
      printf("%d\n", mid = x1);
      for (int i = 1; i <= ((n - 1) >> 1); i++) {
          scanf("%d%d", &x1, &x2);
          if (x1 > mid) q2.push(x1); else q1.push(x1);
          if (x2 > mid) q2.push(x2); else q1.push(x2);
          while (q1.size() >= q2.size()) { q2.push(q1.top()); q1.pop(); }
          while (q1.size() < q2.size() - 1) { q1.push(q2.top()); q2.pop(); }
          printf("%d\n", mid = q1.top());
      }
      return 0;
  }
  ```

### 最优关键思路与技巧

1. **对顶堆**：通过维护一个大根堆和一个小根堆，动态调整堆的大小，保证中位数的正确性。这是解决动态中位数问题的经典方法，时间复杂度为O(n log n)，适合竞赛使用。
2. **动态调整**：每次插入新数后，通过调整堆的大小，保证两个堆的大小差不超过1，从而快速获取中位数。
3. **简化插入过程**：通过每次插入两个数，减少调整堆的次数，提高代码效率。

### 可拓展之处

1. **类似问题**：动态维护第k大数、滑动窗口的中位数等问题，都可以通过对顶堆或平衡树来解决。
2. **数据结构拓展**：除了对顶堆，平衡树、树状数组、线段树等数据结构也可以用于解决类似问题，适合对数据结构有深入理解的同学。

### 推荐题目

1. **P1801 黑匣子**：动态维护第k大数，与本题类似，适合练习对顶堆的使用。
2. **P3871 [TJOI2010]中位数**：动态维护中位数，与本题类似，适合进一步巩固对顶堆的应用。
3. **P3369 【模板】普通平衡树**：练习平衡树的使用，适合对数据结构有深入理解的同学。

### 个人心得摘录

- **调试经历**：在调整堆的大小时，容易出现堆的大小差超过1的情况，需要仔细检查调整逻辑。
- **顿悟感想**：对顶堆的维护过程虽然简单，但需要理解其背后的原理，才能灵活应用于不同的问题场景。

---
处理用时：67.72秒
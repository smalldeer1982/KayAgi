# 题目信息

# [USACO1.4] 母亲的牛奶 Mother's Milk

## 题目描述

农民约翰有三个容量分别是 $a,b,c$ 升的桶。  

最初，$a,b$ 桶都是空的，而 $c$ 桶是装满牛奶的。有时，农民把牛奶从一个桶倒到另一个桶中，直到被灌桶装满或原桶空了。  

当然每一次灌注都是完全的。由于节约，牛奶不会有丢失。

写一个程序去帮助农民找出当 $a$ 桶是空的时候，$c$ 桶中牛奶所剩量的所有可能性。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le a,b,c \le 20$。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
8 9 10
```

### 输出

```
1 2 8 9 10
```

## 样例 #2

### 输入

```
2 5 10```

### 输出

```
5 6 7 8 9 10```

# AI分析结果

### 综合分析与结论

本题的核心是通过搜索算法（DFS或BFS）枚举所有可能的倒牛奶状态，找到当A桶为空时C桶中牛奶量的所有可能性。题解中大多数采用了DFS或BFS的搜索策略，并通过三维数组记录状态以避免重复搜索。部分题解还使用了随机化或枚举的方法，但整体思路较为相似。

**关键思路与技巧：**
1. **状态表示与判重**：使用三维数组（如`vis[a][b][c]`）记录每个状态是否被访问过，避免重复搜索。
2. **倒牛奶的模拟**：通过判断两个桶的剩余容量和当前牛奶量，模拟倒牛奶的过程，确保不溢出或倒空。
3. **DFS/BFS的剪枝**：通过提前判断状态是否已经访问过，减少不必要的搜索。
4. **输出优化**：使用数组记录C桶的可能值，最后排序输出。

**扩展思路：**
- 类似的状态搜索问题可以通过DFS/BFS解决，关键在于如何表示状态和避免重复搜索。
- 可以通过位运算或哈希表优化状态存储，减少空间复杂度。

### 评分较高的题解

#### 1. 作者：远航之曲 (赞：86)
**星级：★★★★★**
**关键亮点：**
- 提供了多种解法，包括DFS、递归、枚举等，思路清晰。
- 代码简洁，使用了三维数组进行状态判重，避免了重复搜索。
- 通过数组记录C桶的可能值，最后输出时进行了排序。

**核心代码：**
```cpp
void dfs(int a[]) {
    if (vis[a[0]][a[1]][a[2]]) return;
    vis[a[0]][a[1]][a[2]] = true;
    if (a[0] == 0) milk[a[2]] = true;
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            if (j == i) continue;
            if (a[j] < bkt[j] && a[i] > 0) {
                int rec = std::min(bkt[j] - a[j], a[i]);
                int b[3];
                memcpy(b, a, sizeof(int)*3);
                b[i] -= rec, b[j] += rec;
                dfs(b);
            }
        }
    }
}
```
**个人心得：**
- 通过三维数组记录状态，避免了重复搜索，提高了效率。

#### 2. 作者：zhanghanbin (赞：74)
**星级：★★★★☆**
**关键亮点：**
- 详细解释了DFS的实现过程，代码结构清晰。
- 使用了三维数组进行状态判重，并通过数组记录C桶的可能值。
- 代码中加入了详细的注释，便于理解。

**核心代码：**
```cpp
void dfs(int a, int b, int c) {
    if (vis[a][b][c] == 1) return;
    else vis[a][b][c] = 1;
    if (a == 0) rec[c] = 1;
    if (c >= (A - a)) dfs(A, b, c - (A - a));
    else dfs(c + a, b, 0);
    // 其他倒法省略
}
```
**个人心得：**
- 通过DFS枚举所有可能的倒牛奶状态，确保不遗漏任何情况。

#### 3. 作者：xun薰 (赞：31)
**星级：★★★★☆**
**关键亮点：**
- 代码简洁，使用了DFS枚举所有可能的倒牛奶状态。
- 通过三维数组进行状态判重，避免了重复搜索。
- 最后对结果进行了排序输出。

**核心代码：**
```cpp
void dfs(int nowa, int nowb, int nowc) {
    if (vis[nowa][nowb][nowc]) return;
    if (nowa == 0) ans[++k] = nowc;
    vis[nowa][nowb][nowc] = 1;
    if (nowc) {
        if (nowa < ta) dfs(min(ta, nowa + nowc), nowb, nowc - (min(ta, nowa + nowc) - nowa));
        if (nowb < tb) dfs(nowa, min(nowb + nowc, tb), nowc - (min(tb, nowb + nowc) - nowb));
    }
    // 其他倒法省略
}
```
**个人心得：**
- 通过DFS枚举所有可能的倒牛奶状态，确保不遗漏任何情况。

### 推荐题目
1. **P1216 [USACO1.5]数字三角形 Number Triangles** - 考察DFS/BFS的状态搜索。
2. **P1433 吃奶酪** - 考察状态压缩和DFS/BFS的结合。
3. **P1077 摆花** - 考察DFS/BFS的状态枚举与优化。

---
处理用时：45.30秒
# 题目信息

# [USACO1.5] 八皇后 Checker Challenge

## 题目描述

一个如下的 $6 \times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。

![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)

上面的布局可以用序列 $2\ 4\ 6\ 1\ 3\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：

行号 $1\ 2\ 3\ 4\ 5\ 6$

列号 $2\ 4\ 6\ 1\ 3\ 5$

这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  
并把它们以上面的序列方法输出，解按字典顺序排列。  
请输出前 $3$ 个解。最后一行是解的总个数。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$6 \le n \le 13$。

题目翻译来自NOCOW。

USACO Training Section 1.5


## 样例 #1

### 输入

```
6
```

### 输出

```
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
```

# AI分析结果

### 综合分析与结论

八皇后问题是一个经典的回溯算法问题，核心在于如何在棋盘上放置皇后，使得它们互不攻击。通过分析多个题解，可以发现大多数解法都采用了深度优先搜索（DFS）结合回溯的策略，并通过标记数组来避免冲突。部分题解还引入了位运算优化，进一步提升了算法效率。

### 评分较高的题解

#### 1. **ybb756032937** (5星)
- **关键亮点**：清晰的标记数组使用，代码结构简洁，注释详细，易于理解。
- **核心实现思想**：通过四个数组分别标记行、列、两条对角线，确保每行、每列、每条对角线上至多有一个皇后。
- **个人心得**：作者强调了标记数组的重要性，并解释了如何通过坐标偏移避免数组越界问题。

```cpp
void queen(int i) {
    if(i > n) {
        print();
        return;
    }
    for(int j = 1; j <= n; j++) {
        if((!b[j]) && (!c[i+j]) && (!d[i-j+n])) {
            a[i] = j;
            b[j] = 1; c[i+j] = 1; d[i-j+n] = 1;
            queen(i+1);
            b[j] = 0; c[i+j] = 0; d[i-j+n] = 0;
        }
    }
}
```

#### 2. **XG_Zepto** (4.5星)
- **关键亮点**：使用了二维数组记录皇后位置，并通过位运算优化了对角线的判断。
- **核心实现思想**：通过位运算快速判断列和对角线是否被占用，减少了时间复杂度。
- **个人心得**：作者提到位运算的效率优势，并建议读者理解位运算的基本原理。

```cpp
void eq(int line) {
    if(line > n) {
        sum++;
        if(sum > 3) return;
        for(int i = 1; i <= n; i++) printf("%d ", ans[i]);
        printf("\n");
        return;
    }
    for(int i = 1; i <= n; i++) {
        if((!check[0][i]) && (!check[1][line+i]) && (!check[2][line-i+n])) {
            ans[line] = i;
            check[0][i] = 1; check[1][line+i] = 1; check[2][line-i+n] = 1;
            eq(line+1);
            check[0][i] = 0; check[1][line+i] = 0; check[2][line-i+n] = 0;
        }
    }
}
```

#### 3. **Lee02** (4星)
- **关键亮点**：通过对称性优化搜索，减少了搜索空间，提升了效率。
- **核心实现思想**：利用棋盘的对称性，只搜索一半的棋盘，最后通过对称性得到完整解。
- **个人心得**：作者提到对称性优化的思路，并建议在类似问题中考虑对称性以减少计算量。

```cpp
void dfs(int k) {
    if(k > n) {
        if(ans < 3) {
            for(int i = 1; i <= n; i++) cout << ans[i] << " ";
            cout << endl;
        }
        ans++;
        return;
    }
    for(int i = 1; i <= n; i++) {
        if(!vis[i] && !vis2[k + i] && !vis3[k - i + n]) {
            ans[k] = i;
            vis[i] = vis2[k + i] = vis3[k - i + n] = 1;
            dfs(k + 1);
            vis[i] = vis2[k + i] = vis3[k - i + n] = 0;
        }
    }
}
```

### 最优关键思路与技巧
1. **标记数组的使用**：通过数组标记行、列、对角线，确保每行、每列、每条对角线上至多有一个皇后。
2. **位运算优化**：利用位运算快速判断列和对角线是否被占用，减少时间复杂度。
3. **对称性优化**：利用棋盘的对称性，减少搜索空间，提升算法效率。

### 可拓展之处
- **类似问题**：N皇后问题、数独问题、图的着色问题等都可以使用类似的回溯算法解决。
- **算法套路**：回溯算法在组合优化问题中应用广泛，掌握其基本框架和优化技巧对解决类似问题非常有帮助。

### 推荐题目
1. **P1219 八皇后**（本题）
2. **P1074 靶形数独**（回溯算法应用）
3. **P1092 虫食算**（回溯算法与剪枝优化）

### 个人心得总结
- **调试经历**：多位作者提到在调试过程中遇到的数组越界问题，建议在编写代码时注意数组下标的范围。
- **踩坑教训**：部分作者提到在优化过程中忽略了对称性，导致算法效率不高，建议在类似问题中考虑对称性优化。
- **顿悟感想**：通过位运算优化对角线的判断，显著提升了算法效率，建议读者理解并掌握位运算的基本原理。

---
处理用时：57.29秒
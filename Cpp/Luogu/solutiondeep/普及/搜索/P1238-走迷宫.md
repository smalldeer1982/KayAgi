# 题目信息

# 走迷宫

## 题目描述

有一个 $m\times n$ 格的迷宫(表示有 $m$ 行、$n$ 列)，其中有可走的也有不可走的，如果用 $1$ 表示可以走，$0$ 表示不可以走，文件读入这 $m\times n$ 个数据和起始点、结束点（起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号）。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息（用 $-1$ 表示无路）。

优先顺序：左上右下。**数据保证随机生成。**


## 说明/提示

数据保证随机生成。事实上，如果 $n=m=14$ 且每个位置都是 $1$ 的话，有 $69450664761521361664274701548907358996488$ 种路径。

## 样例 #1

### 输入

```
5 6
1 0 0 1 0 1
1 1 1 1 1 1
0 0 1 1 1 0
1 1 1 1 1 0
1 1 1 0 1 1
1 1
5 6```

### 输出

```
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)```

# AI分析结果

### 综合分析与结论

本题是一个经典的迷宫路径搜索问题，要求找到从起点到终点的所有可行路径，并且路径中不能有重复的点。题解中主要采用了深度优先搜索（DFS）算法，部分题解还使用了栈、队列、vector等数据结构来优化路径的记录和输出。整体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，但也有部分题解存在冗余代码或不够优化的地方。

### 评分较高的题解

#### 1. 作者：2x6_81
- **星级**：4.5
- **关键亮点**：
  - 使用了队列（queue）来记录路径，代码简洁且易于理解。
  - 通过自定义的`queue_pop`函数实现了队列的尾部弹出，解决了标准库中只能弹出队头的问题。
  - 代码结构清晰，注释详细，适合初学者学习。
- **个人心得**：
  - 作者强调了审题的重要性，特别是“优先左上右下”的顺序，避免了因方向错误导致的WA。
  - 通过调试发现，起点必须标记为已访问，否则会导致重复访问起点的问题。

```cpp
void dfs(int x, int y) {
    if (x == ex && y == ey) { b = 1; print(); queue_pop(); return; }
    road.push(per(x, y));
    for (int k = 0; k < 4; ++k) {
        int tx = x + dir[k][0], ty = y + dir[k][1];
        if (!vis[tx][ty]) { vis[tx][ty] = 1; dfs(tx, ty); vis[tx][ty] = 0; }
    }
    queue_pop();
}
```

#### 2. 作者：QianhanOfficial
- **星级**：4.5
- **关键亮点**：
  - 使用了vector来记录路径，代码简洁且易于理解。
  - 通过`print`函数实现了路径的输出，逻辑清晰。
  - 代码结构清晰，注释详细，适合初学者学习。
- **个人心得**：
  - 作者强调了起点必须标记为已访问，否则会导致重复访问起点的问题。

```cpp
void dfs(int x, int y) {
    if (x == fx && y == fy) { print(); return; }
    for (int k = 0; k < 4; ++k) {
        int tx = x + dir[k][0], ty = y + dir[k][1];
        if (tx >= 1 && tx <= m && ty >= 1 && ty <= n && map[tx][ty] && !vis[tx][ty]) {
            v1.push_back(tx); v2.push_back(ty);
            vis[tx][ty] = true;
            dfs(tx, ty);
            vis[tx][ty] = false;
            v1.pop_back(); v2.pop_back();
        }
    }
}
```

#### 3. 作者：刘备
- **星级**：4
- **关键亮点**：
  - 使用了pair来记录路径，代码简洁且易于理解。
  - 通过`print`函数实现了路径的输出，逻辑清晰。
  - 代码结构清晰，注释详细，适合初学者学习。
- **个人心得**：
  - 作者强调了起点必须标记为已访问，否则会导致重复访问起点的问题。

```cpp
void dfs(pp k) {
    if (k == t) { print(); return; }
    for (int i = 0; i < 4; ++i) {
        int x1 = k.first + dx[i], y1 = k.second + dy[i];
        if (x1 >= 1 && x1 <= m && y1 >= 1 && y1 <= n && map[x1][y1] && !vis[x1][y1]) {
            way[++cnt] = make_pair(x1, y1);
            map[x1][y1] = 0;
            dfs(way[cnt]);
            map[x1][y1] = 1;
            cnt--;
        }
    }
}
```

### 关键思路与技巧总结

1. **DFS回溯**：DFS是解决迷宫问题的经典算法，通过递归和回溯可以找到所有可能的路径。
2. **路径记录**：使用栈、队列或vector等数据结构来记录路径，方便输出。
3. **方向优先**：根据题目要求，优先按照左上右下的顺序进行搜索。
4. **起点标记**：起点必须标记为已访问，否则会导致重复访问起点的问题。

### 拓展思路与类似题目

1. **类似题目**：
   - [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)：经典的迷宫问题，要求找到从起点到终点的路径。
   - [P1019 单词接龙](https://www.luogu.com.cn/problem/P1019)：通过DFS或BFS寻找单词接龙的最长路径。
   - [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)：通过回溯算法解决八皇后问题。

2. **拓展思路**：
   - **BFS**：广度优先搜索可以用于寻找最短路径，适合解决类似迷宫问题。
   - **A*算法**：在复杂迷宫中，A*算法可以更高效地找到最短路径。
   - **剪枝优化**：在DFS中，通过剪枝可以减少不必要的搜索，提高算法效率。

### 总结

以上题解中，2x6_81、QianhanOfficial和刘备的题解质量较高，代码简洁且思路清晰，适合初学者学习和参考。关键技巧包括DFS回溯、路径记录和方向优先搜索。通过这些题解，可以更好地理解迷宫问题的解决方法，并应用到类似的题目中。

---
处理用时：57.79秒
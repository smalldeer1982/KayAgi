# 题目信息

# 显示图像

## 题目描述

古老的显示屏是由 $N \times M$ 个像素（Pixel）点组成的。一个像素点的位置是根据所在行数和列数决定的。例如 $P(2,1)$ 表示第 $2$ 行第 $1$ 列的像素点。那时候，屏幕只能显示黑与白两种颜色，人们用二进制 $0$ 和 $1$ 来表示。$0$ 表示黑色，$1$ 表示白色。当计算机发出一个指令：$P(x,y)=1$，则屏幕上的第 $x$ 行第 $y$ 列的阴极射线管就开始工作，使该像素点显示白色，若 $P(x,y)=0$，则对应位置的阴极射线管不工作，像素点保持黑色。在某一单位时刻，计算机以 $N \times M$ 二维 $01$ 矩阵的方式发出显示整个屏幕图像的命令。

例如，屏幕是由 $3 \times 4$ 的像素点组成，在某单位时刻，计算机发出如下命令：

$$\begin{pmatrix}
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 1 \\
0 & 1 & 1 & 0 \\
\end{pmatrix}$$

对应屏幕显示应为：

![](https://cdn.luogu.com.cn/upload/image_hosting/cwg2di9s.png)

假设放大后，一个格子表示一个像素点。

由于未知的原因，显示黑色的像素点总是受显示白色的像素点的影响——可能是阴极射线管工作的作用。并且，距离越近，影响越大。这里的距离定义如下：

设有像素点 $P_1(x_1,y_1)$ 和像素点 $P_2(x_2,y_2)$，则它们之间的距离 $D(P_1,P_2)=|x_1-x_2|+|y_1-y_2|$。

在某一时刻，计算机发出显示命令后，科学家们期望知道，每个像素点和其最近的显示白色的像素点之间的最短距离是多少——科学家们保证屏幕上至少有一个显示白色的像素点。

上面的例子中，像素 $P(1,1)$ 与最近的白色像素点之间的距离为 $3$，而像素 $P(3,2)$ 本身显示白色，所以最短距离为 $0$。


## 说明/提示

- 对于 $30\%$ 的数据：$N\times M \le 10000$；
- 对于 $100\%$ 的数据：$N\times M \le 182^2$。

## 样例 #1

### 输入

```
3 4
0001
0011
0110
```

### 输出

```
3 2 1 0
2 1 0 0
1 0 0 1
```

# AI分析结果

### 综合分析与结论

本题的核心是计算每个黑色像素点到最近的白色像素点的曼哈顿距离。题解中主要采用了以下几种思路：

1. **暴力搜索**：通过双重循环计算每个黑色像素点到所有白色像素点的距离，取最小值。这种方法虽然直观，但时间复杂度较高，适用于小规模数据。
2. **广度优先搜索（BFS）**：从所有白色像素点出发，逐层扩展，计算每个黑色像素点的最短距离。BFS是解决此类最短路径问题的经典算法，时间复杂度较低，适合大规模数据。
3. **动态规划（DP）**：通过四个方向的递推，计算每个像素点到最近白色像素点的距离。这种方法减少了重复计算，效率较高。
4. **K-D Tree**：利用K-D树进行最近邻搜索，适用于高维空间的最短路径问题，但实现较为复杂。

综合来看，BFS和DP是较为高效且易于实现的解决方案，尤其适合本题的数据规模。

### 所选高星题解

#### 1. **作者：Hydra_ (赞：18)**
- **星级**：★★★★★
- **关键亮点**：使用BFS从所有白色像素点出发，逐层扩展，计算每个黑色像素点的最短距离。思路清晰，代码简洁，且时间复杂度较低。
- **个人心得**：强调了BFS的适用性，并指出DFS在此类问题中容易超时，提醒读者选择合适的算法。
- **核心代码**：
  ```cpp
  void bfs() {
      node net,now;
      while(!q.empty()) {
          now=q.front();  // 取队首元素
          q.pop();
          int x=now.x, y=now.y, d=now.d;
          a[x][y]=d;  // 找最小值，当前走到的一定是最小值
          for(int i=0;i<4;++i) {  // 取最小者
              int dx=x+xx[i],dy=y+yy[i];
              if(dx>=1 && dx<=n && dy>=1 && dy<=m && !v[dx][dy] && b[dx][dy]=='0') {
                  v[dx][dy]=1;  // 置1，已经访问过
                  net.x=dx;net.y=dy;net.d=d+1;  // 一步一步的+
                  q.push(net);  // 入队
              }
          }
      }
  }
  ```

#### 2. **作者：pantw (赞：20)**
- **星级**：★★★★☆
- **关键亮点**：采用动态规划的思路，通过四个方向的递推计算每个像素点到最近白色像素点的距离。减少了重复计算，效率较高。
- **核心代码**：
  ```cpp
  for(int i = 1; i <= n; i++) {
      for(int j = 1; j <= m; j++) {
          if(!f[0][i][j]) continue;
          f[0][i][j] = min(f[0][i-1][j], f[0][i][j-1]);
          if(f[0][i][j] != INF) f[0][i][j]++;
      }
  }
  ```

#### 3. **作者：Atmizz (赞：10)**
- **星级**：★★★★
- **关键亮点**：使用BFS结合STL队列，代码简洁易懂，适合初学者理解BFS的应用。
- **核心代码**：
  ```cpp
  void bfs() {
      node net,now;
      while(!q.empty()) {
          now=q.front();  // 取队首元素
          q.pop();
          int x=now.x, y=now.y, d=now.d;
          a[x][y]=d;  // 找最小值，当前走到的一定是最小值
          for(int i=0;i<4;++i) {  // 取最小者
              int dx=x+xx[i],dy=y+yy[i];
              if(dx>=1 && dx<=n && dy>=1 && dy<=m && !v[dx][dy] && b[dx][dy]=='0') {
                  v[dx][dy]=1;  // 置1，已经访问过
                  net.x=dx;net.y=dy;net.d=d+1;  // 一步一步的+
                  q.push(net);  // 入队
              }
          }
      }
  }
  ```

### 最优关键思路与技巧

- **BFS的应用**：从多个起点（白色像素点）同时进行BFS，逐层扩展，计算每个黑色像素点的最短距离。这种方法避免了重复计算，效率较高。
- **动态规划**：通过四个方向的递推，减少重复计算，适合大规模数据处理。
- **方向数组的使用**：在BFS中，使用方向数组简化了代码，提高了可读性。

### 可拓展之处

- **类似问题**：可以扩展到其他类型的最短路径问题，如网格图中的最短路径、迷宫问题等。
- **算法套路**：BFS和DP是解决最短路径问题的经典套路，掌握后可以应用于多种场景。

### 推荐题目

1. **P1443 马的遍历**：考察BFS在网格图中的应用。
2. **P1162 填涂颜色**：考察BFS在矩阵中的应用。
3. **P1141 01迷宫**：考察BFS在迷宫问题中的应用。

### 个人心得总结

- **调试经历**：多位作者提到输入格式的问题，提醒读者注意输入细节，避免因输入错误导致调试困难。
- **踩坑教训**：DFS在此类问题中容易超时，选择合适的算法（如BFS）是解决问题的关键。
- **顿悟感想**：BFS的逐层扩展思想非常适合解决最短路径问题，理解其核心思想后，可以灵活应用于多种场景。

---
处理用时：49.62秒
# 题目信息

# 封锁阳光大学

## 题目描述

曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。

阳光大学的校园是一张由 $n$ 个点构成的无向图，$n$ 个点之间由 $m$ 条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。

询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。


## 说明/提示

【数据规模】   
对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，保证没有重边。

## 样例 #1

### 输入

```
3 3
1 2
1 3
2 3
```

### 输出

```
Impossible
```

## 样例 #2

### 输入

```
3 2
1 2
2 3
```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心是通过图的遍历（DFS/BFS）进行二分图染色，确保每条边的两个端点颜色不同，且最终选择颜色较少的点作为封锁点。难点在于图的连通性处理、冲突检测以及最小封锁点的计算。大多数题解采用了DFS或BFS进行染色，部分题解使用了并查集或状态压缩优化。整体思路较为一致，但实现细节和优化程度有所不同。

### 所选高星题解

#### 1. **KesdiaelKen (★★★★★)**
- **关键亮点**：思路清晰，代码简洁，使用了链式前向星存储图，并通过DFS进行二分图染色。处理了图的连通性问题，且通过`sum`数组统计颜色数量，最终取较小值。
- **个人心得**：作者强调了图的连通性处理，提醒了图可能不连通的情况，并通过`used`数组避免重复遍历。
- **核心代码**：
```cpp
bool dfs(int node, int color) {
    if (used[node]) {
        if (col[node] == color) return true;
        return false;
    }
    used[node] = true;
    sum[col[node] = color]++;
    bool tf = true;
    for (int i = head[node]; i != 0 && tf; i = edge[i].nexty) {
        tf = tf && dfs(edge[i].t, 1 - color);
    }
    return tf;
}
```

#### 2. **dingcx (★★★★☆)**
- **关键亮点**：使用BFS进行染色，避免了递归深度过大的问题，且通过`used`数组记录颜色，处理了冲突检测。代码结构清晰，适合初学者理解。
- **个人心得**：作者提到BFS的优势在于无需递归，发现冲突时可以直接返回，适合大规模数据。
- **核心代码**：
```cpp
bool bfs(int start) {
    used[start] = 1;
    sum[1] = 1, sum[2] = 0;
    q.push(start);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int k = h[u]; k; k = e[k].next) {
            int v = e[k].v;
            if (used[v] == used[u]) return 1;
            if (used[v] == 0) {
                used[v] = used[u] % 2 + 1;
                sum[used[v]]++;
                q.push(v);
            }
        }
    }
    return 0;
}
```

#### 3. **wshz (★★★★☆)**
- **关键亮点**：使用并查集处理冲突检测，通过`h`数组记录敌对关系，避免了复杂的染色过程。代码简洁且高效，适合处理大规模数据。
- **个人心得**：作者提到并查集的优势在于处理对立关系，类似“敌人的敌人就是朋友”的思路。
- **核心代码**：
```cpp
void xx(int x, int y) {
    int qq = find(x);
    if (qq != y) {
        f[y] = qq;
        t[qq] += t[y];
    }
}
```

### 最优关键思路与技巧
1. **二分图染色**：通过DFS或BFS对图进行二分染色，确保每条边的两个端点颜色不同。
2. **连通性处理**：图可能不连通，需对每个连通块单独处理，避免遗漏。
3. **冲突检测**：在染色过程中，若发现相邻节点颜色相同，则直接返回“Impossible”。
4. **最小封锁点计算**：对每个连通块，统计两种颜色的节点数量，取较小值作为封锁点。

### 可拓展之处
- **并查集优化**：在处理对立关系时，并查集可以高效地检测冲突，适合大规模数据。
- **状态压缩**：对于大规模图，可以使用状态压缩减少空间复杂度。

### 推荐相似题目
1. **P3386 【模板】二分图匹配**：考察二分图的最大匹配问题。
2. **P1525 关押罪犯**：通过二分图染色解决冲突问题。
3. **P2024 [NOI2001] 食物链**：使用并查集处理复杂的对立关系。

### 个人心得总结
- **调试经历**：多次因图的连通性问题导致WA，提醒了在处理图论问题时务必考虑图的连通性。
- **踩坑教训**：未处理图的连通性导致部分测试点无法通过，需在代码中显式处理每个连通块。
- **顿悟感想**：二分图染色的核心在于确保相邻节点颜色不同，且通过统计颜色数量可以快速得出最小封锁点。

---
处理用时：44.70秒
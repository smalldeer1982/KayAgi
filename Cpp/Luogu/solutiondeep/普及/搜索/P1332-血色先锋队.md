# 题目信息

# 血色先锋队

## 题目背景

巫妖王的天灾军团终于卷土重来，血色十字军组织了一支先锋军前往诺森德大陆对抗天灾军团，以及一切沾有亡灵气息的生物。孤立于联盟和部落的血色先锋军很快就遭到了天灾军团的重重包围，现在他们将主力只好聚集了起来，以抵抗天灾军团的围剿。可怕的是，他们之中有人感染上了亡灵瘟疫，如果不设法阻止瘟疫的扩散，很快就会遭到灭顶之灾。大领主阿比迪斯已经开始调查瘟疫的源头。原来是血色先锋军的内部出现了叛徒，这个叛徒已经投靠了天灾军团，想要将整个血色先锋军全部转化为天灾军团！无需惊讶，你就是那个叛徒。在你的行踪败露之前，要尽快完成巫妖王交给你的任务。

## 题目描述

军团是一个 $n$ 行 $m$ 列的矩阵，每个单元是一个血色先锋军的成员。感染瘟疫的人，每过一个小时，就会向四周扩散瘟疫，直到所有人全部感染上瘟疫。你已经掌握了感染源的位置，任务是算出血色先锋军的领主们感染瘟疫的时间，并且将它报告给巫妖王，以便对血色先锋军进行一轮有针对性的围剿。

## 说明/提示

#### 输入输出样例 1 解释

如下图，标记出了所有人感染瘟疫的时间以及感染源和领主的位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/3j3g02cn.png)

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n,m\le500$，$1\le a,b\le10^5$。

## 样例 #1

### 输入

```
5 4 2 3
1 1
5 4
3 3
5 3
2 4
```

### 输出

```
3
1
3```

# AI分析结果

### 综合分析与结论

本题的核心是通过BFS或暴力枚举来计算每个领主被感染的最短时间。BFS是更优的解法，因为它能够高效地处理多个感染源的扩散问题，而暴力枚举虽然简单，但在数据规模较大时可能超时。题解中，BFS的实现通常通过队列来模拟感染扩散的过程，而暴力枚举则直接计算每个领主与所有感染源的曼哈顿距离。

### 所选高星题解

#### 1. 作者：llzzxx712 (赞：133) - 5星
**关键亮点**：
- 使用BFS处理多个感染源的扩散问题，思路清晰。
- 代码结构良好，注释详细，易于理解。
- 通过标记已感染的点来避免重复计算，优化了性能。

**个人心得**：
- 作者提到“一定要标记一个点是否被感染，否则就会造成被感染的人时间再次被更新”，强调了BFS中标记的重要性。

**核心代码**：
```cpp
void bfs(){
    while(head<tail){
        head++;
        for(int i=0;i<4;i++){
            int x1=x+fx[i][0], y1=y+fx[i][1];
            if(x1>=1 && x1<=n && y1>=1 && y1<=m && !vis[x1][y1]){
                vis[x1][y1] = 1;
                map[x1][y1] = map[x][y] + 1;
                q[++tail][0] = x1;
                q[tail][1] = y1;
            }
        }
    }
}
```

#### 2. 作者：sinsop90 (赞：81) - 4星
**关键亮点**：
- 使用STL队列简化了BFS的实现，代码简洁。
- 通过结构体存储感染源和领主的位置，增强了代码的可读性。

**核心代码**：
```cpp
void bfs(){
    while(!Q.empty()){
        node tmp = Q.front();
        Q.pop();
        for(int i=0;i<4;i++){
            int xx = tmp.x + fx[i][0], yy = tmp.y + fx[i][1];
            if(xx>=1 && xx<=n && yy>=1 && yy<=m && !vis[xx][yy]){
                vis[xx][yy] = true;
                maps[xx][yy] = tmp.steps + 1;
                Q.push({xx, yy, tmp.steps + 1});
            }
        }
    }
}
```

#### 3. 作者：开挂老司机 (赞：33) - 4星
**关键亮点**：
- 使用快读优化输入，提升了代码的效率。
- 通过方向数组简化了BFS的扩散过程，代码结构清晰。

**核心代码**：
```cpp
void bfs(){
    while(!q.empty()){
        note s = q.front();
        q.pop();
        for(int i=0;i<4;i++){
            note c;
            c.h = s.h + dx[i], c.l = s.l + dy[i];
            if(f[s.h][s.l] + 1 < f[c.h][c.l]){
                f[c.h][c.l] = f[s.h][s.l] + 1;
                q.push(c);
            }
        }
    }
}
```

### 最优关键思路与技巧

1. **BFS的队列实现**：通过队列模拟感染扩散的过程，确保每个点只被处理一次，避免重复计算。
2. **标记已感染的点**：在BFS中，标记已感染的点可以防止重复扩散，提升算法效率。
3. **方向数组的使用**：通过方向数组简化了BFS的扩散过程，减少了代码冗余。

### 可拓展之处

- **多源BFS**：本题是多源BFS的典型应用，类似的题目包括“多源最短路径”问题。
- **曼哈顿距离的应用**：在暴力枚举中，曼哈顿距离的计算可以用于快速求解两点之间的最短路径。

### 推荐题目

1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443) - 类似的多源BFS问题。
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - BFS在矩阵中的应用。
3. [P1131 最小生成树](https://www.luogu.com.cn/problem/P1131) - BFS在图论中的应用。

### 个人心得总结

- **调试经历**：多位作者提到在实现BFS时，忘记标记已感染的点导致重复计算，强调了标记的重要性。
- **顿悟感想**：通过方向数组简化BFS的实现，减少了代码冗余，提升了代码的可读性和效率。

---
处理用时：44.42秒
# 题目信息

# 医院设置

## 题目描述

设有一棵二叉树，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/kawht13x.png)

其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在 $1$ 处，则距离和 $=4+12+2\times20+2\times40=136$；若医院建在 $3$ 处，则距离和 $=4\times2+13+20+40=81$。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 100$，$0 \leq u, v \leq n$，$1 \leq w \leq 10^5$。

## 样例 #1

### 输入

```
5						
13 2 3
4 0 0
12 4 5
20 0 0
40 0 0
```

### 输出

```
81```

# AI分析结果

### 综合分析与结论

本题的核心是在一棵二叉树中找到最优的医院设置点，使得所有居民到该点的总路程最小。题解中主要采用了以下几种思路：

1. **暴力枚举 + BFS/DFS**：通过枚举每个节点作为医院设置点，使用BFS或DFS计算总路程，时间复杂度为O(n²)。这种方法思路简单，但效率较低，适合小规模数据。
2. **Floyd算法**：通过Floyd算法预处理所有节点对之间的最短路径，然后枚举每个节点作为医院设置点，计算总路程。时间复杂度为O(n³)，适合小规模数据。
3. **树的重心 + 树形DP**：利用树的重心性质，通过两次DFS计算每个节点的子树大小和总距离，最终找到最优解。时间复杂度为O(n)，适合大规模数据。

最优解是**树的重心 + 树形DP**，时间复杂度最低，适合大规模数据。其他方法虽然思路简单，但效率较低，适合小规模数据。

### 所选高星题解

#### 题解1：Huami360（★★★★★）
**关键亮点**：
- 使用树的重心性质，通过两次DFS计算每个节点的子树大小和总距离，时间复杂度为O(n)。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
void dfs(int u, int fa, int dep) {
    size[u] = w[u];
    for(int i = head[u]; i; i = e[i].next) {
        if(e[i].to != fa)
            dfs(e[i].to, u, dep + 1), size[u] += size[e[i].to];
    }
    f[1] += w[u] * dep;
}

void dp(int u, int fa) {
    for(int i = head[u]; i; i = e[i].next) {
        if(e[i].to != fa) {
            f[e[i].to] = f[u] + size[1] - size[e[i].to] * 2;
            dp(e[i].to, u);
        }
    }
    ans = min(ans, f[u]);
}
```
**个人心得**：
- 通过树的重心性质，可以快速找到最优解，避免了暴力枚举的低效。

#### 题解2：lizongru（★★★★☆）
**关键亮点**：
- 使用树形DP，通过两次DFS计算每个节点的子树大小和总距离，时间复杂度为O(n)。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
void dfs(int rt, int fa) {
    deep[rt] = deep[fa] + 1;
    for(register int i = head[rt]; i; i = e[i].next) {
        if(e[i].to == fa) continue;
        dfs(e[i].to, rt);
        pre[rt] += pre[e[i].to];
    }
}

void dp(int rt, int fa) {
    for(register int i = head[rt]; i; i = e[i].next) {
        if(e[i].to == fa) continue;
        dis[e[i].to] = dis[rt] + pre[1] - pre[e[i].to] - pre[e[i].to];
        if(dis[e[i].to] < ans) ans = dis[e[i].to];
        dp(e[i].to, rt);
    }
}
```
**个人心得**：
- 通过树形DP，可以快速计算每个节点的总距离，避免了暴力枚举的低效。

#### 题解3：ShineEternal（★★★★☆）
**关键亮点**：
- 使用Floyd算法预处理所有节点对之间的最短路径，然后枚举每个节点作为医院设置点，计算总路程。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
for(int k=1; k<=n; k++) {
    for(int i=1; i<=n; i++) {
        if(i!=k) {
            for(int j=1; j<=n; j++) {
                if(i!=j&&k!=j&&g[i][k]+g[k][j]<g[i][j])
                    g[i][j]=g[i][k]+g[k][j];
            }
        }
    }
}
```
**个人心得**：
- 通过Floyd算法预处理所有节点对之间的最短路径，可以快速计算每个节点的总距离，避免了暴力枚举的低效。

### 最优关键思路与技巧

1. **树的重心性质**：利用树的重心性质，通过两次DFS计算每个节点的子树大小和总距离，时间复杂度为O(n)。
2. **树形DP**：通过树形DP，快速计算每个节点的总距离，避免了暴力枚举的低效。
3. **Floyd算法**：通过Floyd算法预处理所有节点对之间的最短路径，适合小规模数据。

### 可拓展之处

- **树的中心点问题**：类似的问题可以通过树的重心或树形DP解决。
- **最短路径问题**：类似的问题可以通过Floyd算法或Dijkstra算法解决。

### 推荐题目

1. **P1352 没有上司的舞会**（树形DP）
2. **P3379 【模板】最近公共祖先（LCA）**（树的重心）
3. **P4779 【模板】单源最短路径（标准版）**（最短路径）

### 个人心得总结

- **树的重心性质**：通过树的重心性质，可以快速找到最优解，避免了暴力枚举的低效。
- **树形DP**：通过树形DP，可以快速计算每个节点的总距离，避免了暴力枚举的低效。
- **Floyd算法**：通过Floyd算法预处理所有节点对之间的最短路径，适合小规模数据。

---
处理用时：45.58秒
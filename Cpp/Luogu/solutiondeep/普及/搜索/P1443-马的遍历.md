# 题目信息

# 马的遍历

## 题目描述

有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。


## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。

## 样例 #1

### 输入

```
3 3 1 1
```

### 输出

```
0    3    2    
3    -1   1    
2    1    4    ```

# AI分析结果

### 综合分析与结论

本题是一个典型的广度优先搜索（BFS）问题，要求计算马从起点到棋盘上任意点的最短步数。大部分题解都采用了BFS算法，并通过队列实现。题解的主要区别在于队列的实现方式（STL队列 vs 手写队列）、方向数组的定义、以及输出格式的处理。整体来看，题解的质量参差不齐，部分题解代码简洁、思路清晰，而有些则存在冗余或不够优化的地方。

### 精选题解

#### 1. **题解作者：shajjl (赞：1599)**
   - **星级：5星**
   - **关键亮点**：
     - 使用STL的`queue`和`pair`，代码简洁且易读。
     - 通过`memset`初始化数组，避免了手动赋值的繁琐。
     - 输出格式处理得当，使用`printf`的`%-5d`实现左对齐。
   - **核心代码**：
     ```cpp
     queue<pair<int,int> > q;
     q.push(make_pair(x,y));
     while(!q.empty()) {
         int xx=q.front().first, yy=q.front().second; q.pop();
         for(int i=0;i<8;i++) {
             int u=xx+dx[i], v=yy+dy[i];
             if(u<1||u>n||v<1||v>m||vis[u][v]) continue;
             vis[u][v]=true; q.push(make_pair(u,v)); f[u][v]=f[xx][yy]+1;
         }
     }
     ```
   - **个人心得**：作者强调了STL的便捷性，尤其是`pair`的使用，简化了代码结构。

#### 2. **题解作者：永遠の愛 (赞：613)**
   - **星级：4星**
   - **关键亮点**：
     - 详细解释了BFS的基本思想和实现方式，适合初学者理解。
     - 使用两个队列分别存储行和列，避免了结构体的使用。
     - 输出格式处理得当，使用`printf`的`%-5d`实现左对齐。
   - **核心代码**：
     ```cpp
     queue<int> qx, qy;
     qx.push(x); qy.push(y);
     while(!qx.empty()) {
         int x=qx.front(), y=qy.front(); qx.pop(); qy.pop();
         for(int i=0;i<8;i++) {
             int nx=x+dx[i], ny=y+dy[i];
             if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&a[nx][ny]==0) {
                 a[nx][ny]=1; ans[nx][ny]=ans[x][y]+1;
                 qx.push(nx); qy.push(ny);
             }
         }
     }
     ```
   - **个人心得**：作者提到BFS的“先进先出”特性，并强调了队列在BFS中的核心作用。

#### 3. **题解作者：CXY07 (赞：286)**
   - **星级：4星**
   - **关键亮点**：
     - 使用结构体模拟队列，代码结构清晰。
     - 通过`memset`初始化数组，避免了手动赋值的繁琐。
     - 输出格式处理得当，使用`printf`的`%-5d`实现左对齐。
   - **核心代码**：
     ```cpp
     struct queue_ { int x,y; } que[160010];
     que[1].x=sx; que[1].y=sy; tail=1;
     while(head<tail) {
         head++; int s=ans[que[head].x][que[head].y]+1;
         for(int i=0;i<8;i++) {
             int nx=que[head].x+fx[i], ny=que[head].y+fy[i];
             if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&ans[nx][ny]==-1) {
                 tail++; que[tail].x=nx; que[tail].y=ny; ans[nx][ny]=s;
             }
         }
     }
     ```
   - **个人心得**：作者提到数组大小的重要性，并强调了BFS的“逐层扩展”特性。

### 最优关键思路与技巧

1. **BFS与队列**：BFS是解决最短路径问题的经典算法，通过队列实现逐层扩展，确保第一次到达某点时步数最小。
2. **方向数组**：使用方向数组简化了马走日的8个方向的遍历，避免了重复代码。
3. **输出格式**：使用`printf`的`%-5d`实现左对齐，确保输出格式符合题目要求。
4. **初始化与标记**：通过`memset`初始化数组，并使用`vis`数组标记已访问的点，避免重复访问。

### 可拓展之处

1. **类似算法套路**：BFS可以应用于其他最短路径问题，如迷宫问题、图的遍历等。
2. **优化方向**：可以考虑使用双向BFS或A*算法进一步优化搜索效率，尤其是在棋盘较大时。

### 推荐题目

1. **P1135 奇怪的电梯**：BFS应用，计算从起点到终点的最短步数。
2. **P1141 01迷宫**：BFS应用，计算连通区域的大小。
3. **P1162 填涂颜色**：BFS应用，填充封闭区域。

### 个人心得总结

- **调试经历**：部分作者提到在输出格式上花费了大量时间，尤其是左对齐和空格的处理，提醒我们在做题时要仔细阅读题目要求。
- **踩坑教训**：有些作者在初始化数组时忽略了`memset`的使用，导致代码冗长且易出错，建议熟练掌握常用函数。
- **顿悟感想**：BFS的核心思想是“逐层扩展”，理解这一点后，类似的题目都能迎刃而解。

---
处理用时：61.64秒
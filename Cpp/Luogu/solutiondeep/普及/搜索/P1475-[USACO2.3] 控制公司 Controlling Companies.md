# 题目信息

# [USACO2.3] 控制公司 Controlling Companies

## 题目描述

有些公司是其他公司的部分拥有者，因为他们获得了其他公司发行的股票的一部分。

据说，如果至少满足了以下三个条件之一，公司 $A$ 就可以控制公司 $B$ 了：

- 公司 $A$ = 公司 $B$。
- 公司 $A$ 拥有大于 $50\%$ 的公司 $B$ 的股票。
- 公司 $A$ 控制 $K$（$K \geq 1$）个公司，记为 $C_1, \ldots, C_K$，每个公司 $C_i$ 拥有 $x_i\%$ 的公司 $B$ 的股票，并且 $x_1+ \ldots + x_K \gt 50\%$。

给你一个表，每行包括三个数 $i,j,p$：表明公司 $i$ 享有公司 $j$ 的 $p\%$ 的股票。计算所有的数对 $(h,s)$，表明公司 $h$ 控制公司 $s$。至多有 $100$ 个公司。

## 说明/提示

翻译来自NOCOW

USACO 2.3


## 样例 #1

### 输入

```
3
1 2 80
2 3 80
3 1 20```

### 输出

```
1 2
1 3
2 3```

# AI分析结果

### 综合分析与结论

本题的核心在于通过深度优先搜索（DFS）或广度优先搜索（BFS）来模拟公司之间的控制关系。由于公司数量较少（最多100个），大部分题解采用了DFS或BFS来遍历公司之间的股权关系，并通过累加股权来判断控制关系。部分题解还引入了并查集或Floyd算法来优化搜索过程。

### 所选高星题解

#### 1. 题解作者：以墨 (赞：31)
- **星级**：★★★★★
- **关键亮点**：
  - 使用DFS进行递归搜索，思路清晰，代码简洁。
  - 通过`cnt`数组累加股权，判断控制关系，逻辑清晰。
  - 使用了`own`数组记录控制关系，避免重复计算。
- **个人心得**：作者通过DFS递归搜索，确保每个公司只被搜索一次，避免了重复计算和死循环。

```cpp
void EMILY(int x) {
    if(f[x]==true) return;
    f[x]=true;
    for(int i=m;i;i--) {
        cnt[i]+=a[x][i];
        if(cnt[i]>50) {
            own[i]=true;
            EMILY(i);
        }
    }
}
```

#### 2. 题解作者：Sarah (赞：2)
- **星级**：★★★★
- **关键亮点**：
  - 使用BFS进行搜索，避免了DFS的递归深度问题。
  - 通过`p_cnt`数组累加股权，判断控制关系，逻辑清晰。
  - 使用了`con`数组记录控制关系，避免重复计算。
- **个人心得**：作者通过BFS逐层搜索，确保每个公司只被搜索一次，避免了重复计算和死循环。

```cpp
void bfs(int s) {
    memset(p_cnt,0,sizeof(p_cnt));
    while(!q.empty()) q.pop();
    q.push(s);
    while(!q.empty()) {
        int x=pos[q.front()];
        q.pop();
        for(;x;x=edges[x].next) {
            p_cnt[edges[x].to]+=edges[x].val;
            if((p_cnt[edges[x].to]>50)&&(!con[s][edges[x].to])) {
                q.push(edges[x].to);
                con[s][edges[x].to]=true;
            }
        }
    }
}
```

#### 3. 题解作者：ws_fuweidong (赞：2)
- **星级**：★★★★
- **关键亮点**：
  - 使用Floyd算法进行递归搜索，思路新颖。
  - 通过`con`数组记录控制关系，避免重复计算。
  - 使用了递归形式的Floyd算法，确保每个公司只被搜索一次。
- **个人心得**：作者通过递归形式的Floyd算法，确保每个公司只被搜索一次，避免了重复计算和死循环。

```cpp
void dfs(int i,int j) {
    if (con[i][j]) return;    
    con[i][j]=true;
    for (int k=1;k<=m;k++) {
        a[i][k]+=a[j][k];
        if (a[i][k]>50) dfs(i,k); 
    }
}
```

### 最优关键思路与技巧

1. **DFS/BFS遍历**：通过DFS或BFS遍历公司之间的股权关系，累加股权判断控制关系。
2. **避免重复计算**：使用标记数组（如`own`、`con`）记录已经处理过的公司，避免重复计算和死循环。
3. **递归与迭代**：递归形式的DFS和迭代形式的BFS各有优劣，根据具体问题选择合适的搜索方式。

### 可拓展之处

1. **并查集优化**：可以引入并查集来优化公司之间的控制关系，减少搜索时间。
2. **Floyd算法**：对于更复杂的股权关系，可以使用Floyd算法进行全局优化。

### 推荐相似题目

1. **P3371 【模板】单源最短路径（弱化版）**：考察图的最短路径算法，与本题的搜索思路相似。
2. **P3388 【模板】割点（割顶）**：考察图的割点算法，与本题的搜索思路相似。
3. **P3385 【模板】负环**：考察图的负环检测算法，与本题的搜索思路相似。

### 个人心得总结

- **调试经历**：在DFS或BFS中，避免重复计算和死循环是关键，使用标记数组可以有效解决这个问题。
- **踩坑教训**：在累加股权时，注意判断条件（如`>50`），避免遗漏或错误判断。
- **顿悟感想**：通过递归或迭代的方式，可以有效地模拟公司之间的控制关系，确保每个公司只被搜索一次。

---
处理用时：40.67秒
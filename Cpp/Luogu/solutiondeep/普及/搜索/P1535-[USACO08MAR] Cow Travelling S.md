# 题目信息

# [USACO08MAR] Cow Travelling S

## 题目描述

奶牛们在被划分成 $N$ 行 $M$ 列（$2 \leq N,M \leq 100$）的草地上游走， 试图找到整块草地中最美味的牧草。

Farmer John 在某个时刻看见贝茜在位置 $(R_1, C_1)$，恰好 $T$（$0 \lt T \leq 15$）秒后，FJ 又在位置 $(R_2, C_2)$ 与贝茜撞了正着。FJ 并不知道在这 $T$ 秒内贝茜是否曾经到过 $(R_2, C_2)$，他能确定的只是，现在贝茜在那里。

设 $S$ 为奶牛在 $T$ 秒内从 $(R_1, C_1)$ 走到 $(R_2, C_2)$ 所能选择的路径总数，FJ 希望有一个程序来帮他计算这个值。每一秒内，奶牛会水平或垂直地移动 $1$ 单位距离（奶牛总是在移动，不会在某秒内停在它上一秒所在的点）。草地上的某些地方有树，自然，奶牛不能走到树所在的位置，也不会走出草地。

现在你拿到了一张整块草地的地形图，其中 `.` 表示平坦的草地，`*` 表示挡路的树。你的任务是计算出，一头在 $T$ 秒内从 $(R_1, C_1)$ 移动到 $(R_2, C_2)$ 的奶牛可能经过的路径有哪些。

## 说明/提示

奶牛在 $6$ 秒内从 $(1,3)$ 走到 $(1,5)$ 的方法只有一种，绕过她面前的树。

## 样例 #1

### 输入

```
4 5 6
...*.
...*.
.....
.....
1 3 1 5```

### 输出

```
1
```

# AI分析结果

### 综合分析与结论

本题的核心是在一个带有障碍物的网格中，计算从起点到终点在限定时间内所有可能的路径数。题解主要分为以下几类：

1. **记忆化搜索**：通过记录已经计算过的状态，避免重复计算，显著提升效率。
2. **动态规划（DP）**：通过状态转移方程，逐步计算每个时间步的路径数。
3. **BFS+剪枝**：通过广度优先搜索结合剪枝策略，减少不必要的状态扩展。

**最优思路**：记忆化搜索和动态规划是解决此类问题的经典方法，尤其是记忆化搜索，既能保持搜索的直观性，又能通过状态记录大幅优化性能。

### 所选高星题解

#### 1. 题解作者：JRzyh (5星)
**关键亮点**：
- 详细讲解了记忆化搜索的原理，并通过斐波那契数列的例子帮助理解。
- 提供了从朴素DFS到记忆化搜索的完整过渡，代码清晰易读。
- 复杂度分析清晰，解释了记忆化搜索的优势。

**核心代码**：
```cpp
int dfs(int x, int y, int time) {
    if (re[x][y][time] != -1) return re[x][y][time];
    if (abs(x - r2) + abs(y - c2) > t - time) return re[x][y][time] = 0;
    if (time > t) return re[x][y][time] = 0;
    if (time == t) {
        if (x == r2 && y == c2) return re[x][y][time] = 1;
        else return re[x][y][time] = 0;
    }
    int ans = 0;
    for (int i = 0; i < 4; i++) {
        if (b[x + dx[i]][y + dy[i]] || x + dx[i] < 1 || x + dx[i] > n || y + dy[i] < 1 || y + dy[i] > m) continue;
        ans += dfs(x + dx[i], y + dy[i], time + 1);
    }
    return re[x][y][time] = ans;
}
```
**核心思想**：通过记忆化数组 `re[x][y][time]` 记录每个状态的结果，避免重复计算。

#### 2. 题解作者：communist (4星)
**关键亮点**：
- 使用BFS结合记忆化，避免了重复状态的扩展。
- 通过 `dp[i][j][k]` 记录每个状态的路径数，思路清晰。
- 代码简洁，易于理解。

**核心代码**：
```cpp
while (!q.empty()) {
    node u = q.front(); q.pop();
    for (int i = 0; i < 4; i++) {
        node th = {u.x + dx[i], u.y + dy[i], u.s + 1};
        if (dp[th.x][th.y][th.s]) {
            dp[th.x][th.y][th.s] += dp[u.x][u.y][u.s];
            continue;
        }
        if (th.x < 1 || th.x > n || th.y < 1 || th.y > m || s[th.x][th.y - 1] == '*' || th.s > t) continue;
        dp[th.x][th.y][th.s] += dp[u.x][u.y][u.s];
        q.push(th);
    }
}
```
**核心思想**：通过BFS遍历所有可能的状态，并结合记忆化数组 `dp[i][j][k]` 记录路径数。

#### 3. 题解作者：天南地北 (4星)
**关键亮点**：
- 使用动态规划，通过状态转移方程逐步计算路径数。
- 代码实现简洁，逻辑清晰。
- 通过两个数组交替使用，避免了重复计算。

**核心代码**：
```cpp
for (int k = 1; k <= t; k++) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i][j] != -1) {
                b[i][j] = 0;
                if (a[i - 1][j] != -1) b[i][j] += a[i - 1][j];
                if (a[i + 1][j] != -1) b[i][j] += a[i + 1][j];
                if (a[i][j - 1] != -1) b[i][j] += a[i][j - 1];
                if (a[i][j + 1] != -1) b[i][j] += a[i][j + 1];
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            a[i][j] = b[i][j];
        }
    }
}
```
**核心思想**：通过两个数组 `a` 和 `b` 交替使用，逐步计算每个时间步的路径数。

### 最优关键思路总结

1. **记忆化搜索**：通过记录已经计算过的状态，避免重复计算，显著提升效率。
2. **动态规划**：通过状态转移方程，逐步计算每个时间步的路径数，适合大规模数据。
3. **BFS+剪枝**：通过广度优先搜索结合剪枝策略，减少不必要的状态扩展。

### 可拓展之处

- **类似题目**：类似的问题可以扩展到三维空间，或者增加更多的限制条件（如路径长度、障碍物类型等）。
- **算法套路**：记忆化搜索和动态规划是解决路径计数问题的经典方法，可以推广到其他类似问题。

### 推荐题目

1. **P1002 过河卒**：经典的路径计数问题，适合练习动态规划。
2. **P1433 吃奶酪**：带有障碍物的路径搜索问题，适合练习记忆化搜索。
3. **P1514 引水入城**：结合路径搜索和状态转移，适合练习BFS+剪枝。

### 个人心得摘录

- **JRzyh**：通过斐波那契数列的例子，帮助理解了记忆化搜索的原理，强调了记忆化搜索的优势。
- **communist**：通过BFS结合记忆化，避免了重复状态的扩展，强调了状态记录的重要性。
- **天南地北**：通过两个数组交替使用，避免了重复计算，强调了动态规划的简洁性。

---
处理用时：55.40秒
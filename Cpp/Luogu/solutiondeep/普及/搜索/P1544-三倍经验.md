# 题目信息

# 三倍经验

## 题目描述

数字金字塔由 $n$ 行整数组成，第 $i(1\le i\le n)$ 行有 $i$ 个数字，一个示例如下。  
```text
        7
      3   9
    8   1   0
  2   7   4   4 
4   5   2   6   5
```  
现在你在金字塔的顶部（第一行），你希望走到金字塔的底部（第 $n$ 行），每一步你只能走向当前所在位置的左下方的数字或者右下方的数字。同时作为一个强大的小朋友，你可以选择金字塔中的不多于 $k$ 个数字让他们成为原来的 $3$ 倍。  

你会收集你路上经过的所有位置上的数字，最后的得分即为收集的数字之和，求最大得分。

## 说明/提示

对于 $30\%$ 的数据，满足 $k\le n\le 6$，并且对于任意 $1\le i\le n$，$1\le j\le i$ 满足 $0\le a_{i,j}\le 100$；  
对于 $100\%$ 的数据，满足 $1\le n\le100$，$0\le k\le \dfrac{n(n+1)}{2}$，且对于任意 $1\le i\le n$，$1\le j\le i$ 满足 $|a_{i,j}|\le 10^9$。

## 样例 #1

### 输入

```
5 3
7
3 9
8 1 0
2 7 4 4
4 5 2 6 5```

### 输出

```
75```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在数字金字塔中找到一条路径，并选择不超过 \( k \) 个数字将其值变为原来的三倍，使得路径上的数字之和最大。题解中主要采用了动态规划（DP）的思路，部分题解还结合了记忆化搜索。以下是各题解的要点总结：

1. **动态规划**：大多数题解采用了三维DP，状态定义为 \( dp[i][j][k] \)，表示走到第 \( i \) 行第 \( j \) 列，使用了 \( k \) 次三倍操作的最大得分。状态转移方程主要考虑从左上和右上方转移过来，并分别考虑是否使用三倍操作。
2. **记忆化搜索**：部分题解使用了记忆化搜索，通过递归的方式遍历所有可能的路径，并在递归过程中记录已经使用的三倍操作次数。
3. **优化**：部分题解对DP进行了优化，如限制 \( k \) 的最大值为 \( n \)，避免不必要的计算。此外，部分题解还通过初始化DP数组为极小值来处理负数的情况。

### 所选高星题解

#### 1. **题解作者：sto_5k_orz (5星)**
- **关键亮点**：
  - 通过限制 \( k \) 的最大值为 \( n \)，显著减少了DP的空间和时间复杂度。
  - 代码简洁且高效，时间复杂度为 \( O(n^3) \)，空间复杂度为 \( O(n^3) \)。
  - 通过初始化DP数组为极小值，处理了负数的情况，避免了错误的最大值计算。
- **个人心得**：
  - 作者提到在优化前，空间和时间复杂度较高，通过限制 \( k \) 的最大值，显著提升了性能。
- **核心代码**：
  ```cpp
  for(int i = 2; i <= n; i++)
      for(int j = 1; j <= i; j++) {
          for(int l = 0; l <= min(k, i); l++)
              dp[i][j][l] = max(dp[i - 1][j][l], dp[i - 1][j - 1][l]) + a[i][j];
          for(int l = 1; l <= min(k, i); l++)
              dp[i][j][l] = max(dp[i][j][l], max(dp[i - 1][j][l - 1], dp[i - 1][j - 1][l - 1]) + a[i][j] * 3);
      }
  ```

#### 2. **题解作者：FQR_ (4星)**
- **关键亮点**：
  - 采用记忆化搜索的方式，通过递归遍历所有可能的路径，并结合DP进行优化。
  - 通过初始化DP数组为极小值，处理了负数的情况。
- **核心代码**：
  ```cpp
  long long dfs(int i, int j, int p) {
      if(i < 0 || i > n || j < 0 || j > n) return 0;
      if(v[i][j][p]) return f[i][j][p];
      else {
          if(p != k) {
              f[i][j][p] = max(f[i][j][p], dfs(i+1, j, p+1) + a[i][j] * 3);
              f[i][j][p] = max(f[i][j][p], dfs(i+1, j+1, p+1) + a[i][j] * 3);
          }
          f[i][j][p] = max(f[i][j][p], dfs(i+1, j, p) + a[i][j]);
          f[i][j][p] = max(f[i][j][p], dfs(i+1, j+1, p) + a[i][j]);
          v[i][j][p] = 1;
          return f[i][j][p];
      }
  }
  ```

#### 3. **题解作者：QianRan_GG (4星)**
- **关键亮点**：
  - 详细解释了状态转移方程的推导过程，便于理解。
  - 通过初始化DP数组为极小值，处理了负数的情况。
- **核心代码**：
  ```cpp
  for(int i = 1; i <= n; ++i)
      for(int j = 1; j <= i; ++j) {
          cin >> a[i][j];
          for(int l = 0; l <= k && l <= i; ++l) {
              if(l == 0)
                  dp[i][j][l] = max(dp[i - 1][j][l], dp[i - 1][j - 1][l]) + a[i][j];
              else {
                  dp[i][j][l] = max(dp[i - 1][j][l], dp[i - 1][j - 1][l]) + a[i][j];
                  dp[i][j][l] = max(dp[i][j][l], max(dp[i - 1][j][l - 1], dp[i - 1][j - 1][l - 1]) + a[i][j] * 3);
              }
          }
      }
  ```

### 最优关键思路与技巧

1. **限制 \( k \) 的最大值**：通过将 \( k \) 的最大值限制为 \( n \)，显著减少了DP的空间和时间复杂度。
2. **初始化DP数组为极小值**：处理了负数的情况，避免了错误的最大值计算。
3. **记忆化搜索与DP结合**：通过递归遍历所有可能的路径，并结合DP进行优化，提高了代码的可读性和效率。

### 可拓展之处

本题的DP思路可以拓展到其他类似的路径优化问题，如：
- **最小路径和**：在数字金字塔中找到一条路径，使得路径上的数字之和最小。
- **带权路径问题**：在路径上每个点有不同的权重，求最大或最小权重路径。

### 推荐洛谷题目

1. **P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles**  
   题目链接：https://www.luogu.com.cn/problem/P1216  
   考察知识点：基础动态规划，路径优化。

2. **P1544 [USACO1.5]数字三角形 Number Triangles II**  
   题目链接：https://www.luogu.com.cn/problem/P1544  
   考察知识点：动态规划，路径优化，三倍操作。

3. **P1508 [USACO1.5]数字三角形 Number Triangles III**  
   题目链接：https://www.luogu.com.cn/problem/P1508  
   考察知识点：动态规划，路径优化，带权路径问题。

---
处理用时：51.33秒
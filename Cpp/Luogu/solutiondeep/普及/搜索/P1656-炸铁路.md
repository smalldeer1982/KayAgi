# 题目信息

# 炸铁路

## 题目描述

A 国派出将军 uim，对 B 国进行战略性措施，以解救涂炭的生灵。

B 国有 $n$ 个城市，这些城市以铁路相连。任意两个城市都可以通过铁路直接或者间接到达。

uim 发现有些铁路被毁坏之后，某两个城市无法互相通过铁路到达。这样的铁路就被称为 key road。

uim 为了尽快使该国的物流系统瘫痪，希望炸毁铁路，以达到存在某两个城市无法互相通过铁路到达的效果。

然而，只有一发炮弹（A 国国会不给钱了）。所以，他能轰炸哪一条铁路呢？


## 样例 #1

### 输入

```
6 6
1 2
2 3
2 4
3 5
4 5
5 6```

### 输出

```
1 2
5 6```

# AI分析结果

### 综合分析与结论

本题的核心是寻找无向图中的“桥”（割边），即删除后会使图不连通的边。题解中主要采用了以下几种方法：

1. **Tarjan算法**：这是求桥的标准算法，时间复杂度为O(n+m)，效率较高，适合大规模数据。
2. **并查集+枚举**：通过枚举每条边，删除后使用并查集判断图的连通性，时间复杂度为O(m^2)，适合小规模数据。
3. **DFS/BFS+枚举**：通过枚举每条边，删除后使用DFS或BFS遍历图，判断是否连通，时间复杂度为O(mn^2)，适合小规模数据。

### 高星题解推荐

#### 1. 作者：abruce (赞：197) ⭐⭐⭐⭐⭐
- **关键亮点**：详细讲解了Tarjan算法的实现细节，代码清晰，注释详尽，适合初学者理解。
- **个人心得**：通过图示和详细的代码注释，帮助读者理解Tarjan算法的核心思想，特别是`dfn`和`low`数组的含义。
- **核心代码**：
  ```cpp
  void tarjan(int x) {
      int c=0,y;
      dfn[x]=low[x]=++id;
      for(register int i=1; i<=n; i++) {
          if(!maps[x][i])continue;
          y=i;
          if(dfn[y]&&y!=f[x])low[x]=min(low[x],dfn[y]);
          if(!dfn[y]) {
              f[y]=x;
              tarjan(y);
              low[x]=min(low[x],low[y]);
              if(low[y]>dfn[x])addEdge(x,y);
          }
      }
  }
  ```
  **实现思想**：通过DFS遍历图，维护`dfn`和`low`数组，判断每条边是否为桥。

#### 2. 作者：hsfzLZH1 (赞：65) ⭐⭐⭐⭐
- **关键亮点**：详细解释了Tarjan算法的原理，并提供了处理重边的优化方案。
- **个人心得**：通过引入`vis`数组处理重边问题，确保算法的正确性。
- **核心代码**：
  ```cpp
  void dfs(int cur,int fa) {
      int child;
      dfn[cur]=++index_;
      low[cur]=dfn[cur];
      bool vis=false; 
      for(int i=0;i<G[cur].size();i++) {
          child=G[cur][i];
          if(dfn[child]) {
              if(child==fa&&!vis)vis=true;
              else low[cur]=min(low[cur],dfn[child]);
          }
          if(!dfn[child]) {
              dfs(child,cur);
              if(dfn[cur]<low[child])add_edge(cur,child);
              low[cur]=min(low[cur],low[child]);
          }
      }
  }
  ```
  **实现思想**：通过DFS遍历图，处理重边问题，确保每条边只被处理一次。

#### 3. 作者：HRLYB (赞：16) ⭐⭐⭐⭐
- **关键亮点**：介绍了双连通分量的概念，并通过Tarjan算法求解，提供了详细的背景知识。
- **个人心得**：通过引入双向边标记，解决了无向图中Tarjan算法的实现问题。
- **核心代码**：
  ```cpp
  void tarjan(int u) {
      deep+=1;
      dfn[u]=deep;
      low[u]=deep;
      top++;
      vis[u]=true;
      stac[top]=u;
      for(int i=head[u];i;i=e[i].next )
          if(!sign[i]){
              sign[i]=true,sign[i^1]=true;
              int v=e[i].v ;
              if(!dfn[v]){
                  tarjan(v);
                  if(low[v]<low[u])low[u]=low[v];
              }
              else {
                  if(vis[v]){
                      if(low[v]<low[u])low[u]=low[v];
                  }
              }
      }
      if(low[u]==dfn[u]){
          num+=1;
          vis[u]=false;
          color[u]=num;
          while(stac[top]!=u){
              color[stac[top]]=num;
              vis[stac[top]]=false;
              top--;
          }
          top--;
      }
  }
  ```
  **实现思想**：通过DFS遍历图，标记双向边，确保每条边只被处理一次。

### 最优关键思路与技巧

1. **Tarjan算法**：通过维护`dfn`和`low`数组，判断每条边是否为桥，时间复杂度为O(n+m)，适合大规模数据。
2. **并查集+枚举**：通过枚举每条边，删除后使用并查集判断图的连通性，时间复杂度为O(m^2)，适合小规模数据。
3. **双向边标记**：在无向图中，通过标记双向边，确保每条边只被处理一次，避免重复计算。

### 可拓展之处

1. **双连通分量**：可以进一步学习双连通分量的概念及其应用，如求解无向图中的割点。
2. **图的连通性**：可以学习其他判断图连通性的算法，如Kruskal算法、Prim算法等。

### 推荐题目

1. **P3387 【模板】缩点**：考察Tarjan算法的应用，适合进一步练习。
2. **P3388 【模板】割点**：考察割点的求解，适合进一步练习。
3. **P2860 [USACO06JAN]冗余路径Redundant Paths**：考察双连通分量的应用，适合进一步练习。

### 个人心得总结

- **调试经历**：在处理重边时，引入`vis`数组标记双向边，确保每条边只被处理一次。
- **踩坑教训**：在枚举边时，注意边的顺序，确保输出符合题目要求。
- **顿悟感想**：通过图示和详细的代码注释，帮助理解算法的核心思想，特别是`dfn`和`low`数组的含义。

---
处理用时：50.45秒
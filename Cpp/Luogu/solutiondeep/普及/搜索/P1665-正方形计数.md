# 题目信息

# 正方形计数

## 题目描述

给定平面上 $N$ 个点，你需要计算以其中 $4$ 个点为顶点的正方形的个数。注意这里的正方形边不一定需要和坐标轴平行。


## 说明/提示

对于 $20\%$ 的数据，满足 $1\leq N\leq 20$。

对于 $100\%$ 的数据，满足 $1\leq N\leq 500$，$-50\leq X_i, Y_i\leq 50$，点不会重合。

## 样例 #1

### 输入

```
7

0 0

0 1

1 0

1 1

1 2

2 1

2 2```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心是通过给定平面上的点，计算以其中4个点为顶点的正方形的个数。大部分题解采用了枚举对角线或边的方式，通过几何公式计算另外两个点的坐标，并判断其是否存在。时间复杂度从O(n^4)到O(n^2)不等，其中O(n^2)的解法较为高效。

### 所选高星题解

#### 1. 作者：Huami360 (5星)
- **关键亮点**：通过枚举对角线，利用几何公式计算另外两个点的坐标，时间复杂度为O(n^2)，且代码简洁清晰。
- **个人心得**：作者提到通过辅助线理解公式的推导过程，帮助读者更好地理解几何原理。
- **核心代码**：
  ```cpp
  int midx = (x[i] + x[j]) / 2;
  int midy = (y[i] + y[j]) / 2;            
  int x1 = midx - (midy - y[i]), y1 = midy + (midx - x[i]);
  int x2 = midx + (midy - y[i]), y2 = midy - (midx - x[i]);
  if(vis[x1][y1] && vis[x2][y2]) ++ans;
  ```

#### 2. 作者：MZW_BG (4星)
- **关键亮点**：同样采用枚举对角线的方式，通过几何公式计算另外两个点的坐标，并使用了布尔数组来存储点的存在性，代码可读性较高。
- **核心代码**：
  ```cpp
  int xmid = (a[i].x + a[j].x) >> 1, ymid = (a[i].y + a[j].y) >> 1;
  int x1 = xmid - (a[i].y - ymid), y1 = ymid - (xmid - a[i].x);
  int x2 = xmid + (a[i].y - ymid), y2 = ymid + (xmid - a[i].x);
  if(v[x1][y1] && v[x2][y2]) ans++;
  ```

#### 3. 作者：xiaozeyu (4星)
- **关键亮点**：通过哈希表存储点的坐标，避免了二维数组的内存开销，适用于更大范围的数据。
- **核心代码**：
  ```cpp
  bool check(int x, int y) {
      int value = f(x, y), buckets = m_hash[value];
      while(buckets != -1) {
          if((s[buckets].x == x) && s[buckets].y == y) return true;
          buckets = nxt[buckets];
      }
      return false;
  }
  ```

### 最优关键思路或技巧

1. **枚举对角线**：通过枚举两个点作为正方形的对角线，利用几何公式计算另外两个点的坐标，时间复杂度为O(n^2)。
2. **哈希表优化**：使用哈希表存储点的坐标，避免二维数组的内存开销，适用于更大范围的数据。
3. **几何公式推导**：通过几何原理推导出另外两个点的坐标，确保计算的准确性。

### 可拓展之处

- **类似问题**：可以扩展到计算其他几何图形（如矩形、菱形等）的个数。
- **算法优化**：可以进一步优化哈希表的实现，减少哈希冲突，提高查找效率。

### 推荐题目

1. **洛谷 P1665**：正方形计数
2. **洛谷 P1666**：矩形计数
3. **洛谷 P1667**：菱形计数

### 个人心得总结

- **调试经历**：部分题解提到在处理负数和小数时遇到的困难，通过坐标平移和放大倍数解决了问题。
- **踩坑教训**：在枚举时要注意避免重复计算，最终答案需要除以相应的倍数。
- **顿悟感想**：通过几何公式推导出另外两个点的坐标，大大减少了计算量，提高了算法的效率。

---
处理用时：29.87秒
# 题目信息

# 好奇怪的游戏

## 题目背景

《爱与愁的故事第三弹·shopping》娱乐章。

调调口味来道水题。


## 题目描述

爱与愁大神坐在公交车上无聊，于是玩起了手机。一款奇怪的游戏进入了爱与愁大神的眼帘：\*\*\*（游戏名被打上了马赛克）。这个游戏类似象棋，但是只有黑白马各一匹，在点 $x_1,y_1$ 和 $x_2,y_2$ 上。它们得从点 $x_1,y_1$ 和 $x_2,y_2$ 走到 $(1,1)$。这个游戏与普通象棋不同的地方是：马可以走“日”，也可以像象走“田”。现在爱与愁大神想知道两匹马到 $(1,1)$ 的最少步数，你能帮他解决这个问题么？

注意不能走到 $x$ 或 $y$ 坐标 $\le 0$ 的位置。

## 说明/提示

### 数据范围及约定

对于 $100\%$ 数据，$1\le x_1,y_1,x_2,y_2 \le 20$。

## 样例 #1

### 输入

```
12 16
18 10```

### 输出

```
8 
9```

# AI分析结果

### 综合分析与结论

本题的核心是通过BFS（广度优先搜索）求解马从起点到终点的最短路径。马可以走“日”字和“田”字，因此有12种移动方向。大部分题解采用了BFS算法，部分题解尝试了DFS或记忆化搜索，但BFS是最优解，因为BFS能够保证首次到达终点时的路径是最短的。

#### 最优思路与技巧：
1. **BFS算法**：BFS是解决最短路径问题的经典算法，尤其适用于无权图或网格图。通过队列实现，能够逐层扩展搜索范围，确保首次到达终点时的路径是最短的。
2. **方向数组**：使用方向数组（如`dx`和`dy`）来简化代码，避免重复的移动判断。
3. **预处理与逆推**：部分题解从终点（1,1）开始逆推，预处理所有点到终点的最短路径，这样只需一次BFS即可回答多个查询。
4. **队列实现**：手动模拟队列或使用STL队列（如`queue`）均可，手动队列在性能上略有优势，但STL队列更简洁易用。

#### 可拓展之处：
- **多起点问题**：如果有多匹马或多个起点，可以通过预处理所有点到终点的最短路径，避免多次BFS。
- **复杂移动规则**：如果马的移动规则更加复杂（如可以跳过障碍物），BFS依然适用，只需调整方向数组即可。

### 精选题解

#### 1. 作者：做梦想Peach (赞：117)
- **星级**：★★★★★
- **关键亮点**：
  - 使用手动模拟队列，代码简洁且高效。
  - 方向数组清晰，移动规则一目了然。
  - 通过BFS逐层扩展，确保首次到达终点时的路径最短。
- **个人心得**：作者提到“看到许多大佬用的都是系统里的队列，没什么手动模拟队列的题解”，展示了手动队列的实现，适合初学者理解BFS的核心思想。

```cpp
void bfs(int X,int Y) {
    int head=0,tail=1,nx,ny;
    queue[1].x=X; queue[1].y=Y; queue[1].step=0;
    vis[X][Y]=true;
    while (head<tail) {
        head++;
        for (int i=0;i<12;i++) {
            nx=queue[head].x+dx[i]; ny=queue[head].y+dy[i];
            if ((nx>=1&&nx<101)&&(ny>=1&&ny<101)&&vis[nx][ny]==false) {
                tail++;
                queue[tail].x=nx; queue[tail].y=ny;
                queue[tail].step=queue[head].step+1;
                vis[nx][ny]=true;
                if (nx==1&&ny==1) {
                    printf ("%d\n",queue[tail].step);
                    return;
                }
            }
        }
    }
}
```

#### 2. 作者：_yjh (赞：21)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用STL队列，代码简洁易读。
  - 从终点（1,1）开始逆推，预处理所有点到终点的最短路径，适合多查询场景。
  - 方向数组清晰，移动规则一目了然。

```cpp
void bfs(int x,int y) {
    node a; a.x=x; a.y=y; a.s=0; 
    q.push(a);
    do {
        a=q.front(); q.pop();
        for(int i=0;i<12;i++) {
            node c; c.x=a.x+dx[i]; c.y=a.y+dy[i];
            if(c.x>=1 && c.y>=1 && b[c.x][c.y]==false) {
                if(c.x==1 && c.y==1) return c.s;
                b[c.x][c.y]=true; c.s=a.s+1;
                q.push(c);
            }
        }
    } while(!q.empty());
}
```

#### 3. 作者：Battereamer (赞：17)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用记忆化搜索，避免重复计算。
  - 方向数组清晰，移动规则一目了然。
  - 通过DFS实现，适合小规模数据。

```cpp
void dfs(int x, int y, int step) {
    if(dp[x][y] <= step) return;
    dp[x][y] = step;
    for(int i = 0; i < 12; i++) {
        int xx = x + zl[i][0], yy = y + zl[i][1];
        if(xx < 1 || xx > 20 || yy < 1 || yy > 20) continue;
        dfs(xx, yy, step + 1);
    }
}
```

### 推荐题目
1. **P1746 离开中山路**：BFS求解最短路径，适合练习BFS的基本应用。
2. **P1443 马的遍历**：BFS求解马在棋盘上的最短路径，与本题类似。
3. **P1162 填涂颜色**：BFS在网格图中的应用，适合练习BFS的扩展应用。

### 总结
BFS是解决最短路径问题的经典算法，尤其适用于无权图或网格图。通过方向数组和队列实现，能够高效求解马的最短路径问题。预处理和逆推是优化多查询场景的有效方法。

---
处理用时：45.66秒
# 题目信息

# 最长路

## 题目描述

设 $G$ 为有 $n$ 个顶点的带权有向无环图，$G$ 中各顶点的编号为 $1$ 到 $n$，请设计算法，计算图 $G$ 中 $1, n$ 间的最长路径。

## 说明/提示

**【数据规模与约定】**

- 对于 $20\%$的数据，$n \leq 100$，$m \leq 10^3$。
- 对于 $40\%$ 的数据，$n \leq 10^3$，$m \leq 10^{4}$。
- 对于 $100\%$ 的数据，$1 \leq n \leq 1500$，$0 \leq m \leq 5 \times 10^4$，$1 \leq u, v \leq n$，$-10^5 \leq w \leq 10^5$。

## 样例 #1

### 输入

```
2 1
1 2 1```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题解的核心问题是在有向无环图（DAG）中求解从节点1到节点n的最长路径。由于DAG的特性，拓扑排序和动态规划（DP）是解决该问题的自然选择。此外，部分题解通过将边权取反，将最长路径问题转化为最短路问题，利用SPFA或Bellman-Ford等算法求解。总体而言，拓扑排序+DP的思路更为直接，适合DAG的最长路径问题，而SPFA的变种则提供了另一种思路，适合对最短路算法熟悉的同学。

### 所选高星题解

#### 1. 作者：Mine_King (★★★★★)
- **关键亮点**：使用拓扑排序+DP，思路清晰，代码简洁，处理了入度为0的节点问题，避免了无效节点的干扰。
- **核心思想**：通过拓扑排序确定节点的处理顺序，利用DP更新每个节点的最长路径。
- **代码片段**：
```cpp
while(!q.empty())
{
    int x=q.front();
    q.pop();
    for(int i=0;i<g[x].size();i++)
    {
        if(v[g[x][i]]<v[x]+d[x][i]) v[g[x][i]]=v[x]+d[x][i];//松弛
        if(!--in[g[x][i]]) q.push(g[x][i]);//如果入度为0就加入队列
    }
}
```

#### 2. 作者：vectorxyz (★★★★)
- **关键亮点**：将边权取反，转化为最短路问题，利用SPFA求解，思路简单易懂。
- **核心思想**：通过将边权取反，将最长路径问题转化为最短路问题，最后输出结果的相反数。
- **代码片段**：
```cpp
void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}
int spfa() //最短路
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = ;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return dist[n];
}
```

#### 3. 作者：lijingyuanpp (★★★★)
- **关键亮点**：结合拓扑排序和DP，处理了以节点1为起点的路径问题，避免了无效路径的干扰。
- **核心思想**：通过拓扑排序确定节点的处理顺序，利用DP更新每个节点的最长路径，同时确保路径以节点1为起点。
- **代码片段**：
```cpp
for(int i = 1; i <= n; i ++){
    int u = px[i];
    if(str[u] == 0){//不在1路上，不用更新来自这条路的路径长度 
        continue;
    }
    //每一个点按照顺序，对其周围的点进行更新，排序目的是使得所有点更新别的点时不会再被更新
    for(int j = head[u]; j != 0; j = e[j].next){
        int v = e[j].v;
        dp[v] = max(dp[v], dp[u] + e[j].w);
    }
}
```

### 最优关键思路与技巧
1. **拓扑排序+DP**：适用于DAG的最长路径问题，通过拓扑排序确定节点的处理顺序，利用DP更新每个节点的最长路径。
2. **边权取反+最短路**：将最长路径问题转化为最短路问题，利用SPFA或Bellman-Ford等算法求解。
3. **处理无效节点**：在拓扑排序中，处理入度为0的节点，避免无效节点的干扰。

### 可拓展之处
- **类似算法套路**：在DAG中，拓扑排序+DP的思路可以应用于其他路径问题，如最短路径、关键路径等。
- **同类型题**：可以考虑在DAG中求解最短路径、关键路径等问题。

### 推荐洛谷题目
1. **P3371 【模板】单源最短路径（弱化版）**：练习最短路算法。
2. **P3388 【模板】拓扑排序**：练习拓扑排序算法。
3. **P4017 最大流**：练习网络流算法，理解路径问题。

### 个人心得摘录
- **Mine_King**：处理入度为0的节点时，直接将其加入队列会导致错误，需要先处理这些节点的出边，确保不会影响其他节点的入度。
- **lijingyuanpp**：通过拓扑排序和DP结合，确保路径以节点1为起点，避免了无效路径的干扰。

---
处理用时：44.51秒
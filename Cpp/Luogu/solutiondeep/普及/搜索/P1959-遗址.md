# 题目信息

# 遗址

## 题目描述

很久很久以前有一座寺庙，从上往下看寺庙的形状正好是一个正方形，由 $4$ 个角上竖立的圆柱搭建而成。现在圆柱都倒塌了，只在地上留下圆形的痕迹，可是现在地上有很多这样的痕迹，专家说一定是最大的那个。

写一个程序，给出圆柱的坐标，找出由 $4$ 个圆柱构成的最大的正方形，因为这就是寺庙的位置，要求计算出最大的面积。注意正方形的边不一定平行于坐标轴。

例如图有 $10$ 根柱子，其中 $(4,2),\allowbreak(5,2),\allowbreak(5,3),\allowbreak(4,3)$ 可以形成一个正方形，$(1,1),\allowbreak(4,0),\allowbreak(5,3),\allowbreak(2,4)$ 也可以，后者是其中最大的，面积为 $10$。

![](https://cdn.luogu.com.cn/upload/image_hosting/pjic0frl.png)


## 说明/提示


【数据范围】

$30\%$ 满足：$1\leq N \leq100$。

$60\%$ 满足：$1\leq N \leq500$。

$100\%$ 满足：$1\leq N \leq3000$。


## 样例 #1

### 输入

```
10
9 4
4 3
1 1
4 2
2 4
5 8
4 0
5 3
0 5
5 2
```

### 输出

```
10```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在给定的点集中找到四个点构成的最大正方形。由于数据规模较大（n ≤ 3000），直接枚举四个点的O(n^4)方法不可行。大多数题解都采用了O(n^2)的优化思路，即枚举两个点，通过几何关系推导出另外两个点的位置，并判断这些点是否存在。

### 最优关键思路与技巧

1. **几何推导**：通过两个点的坐标差，利用全等三角形或勾股定理推导出另外两个点的坐标。这是所有题解的核心思想。
2. **边界判断**：在推导出另外两个点的坐标后，必须判断这些点是否在合法范围内（如坐标不超过5000），否则会导致数组越界。
3. **面积计算**：正方形的面积可以通过勾股定理直接计算，即面积 = (x2 - x1)^2 + (y2 - y1)^2。

### 推荐题解

#### 1. 作者：沉石鱼惊旋 (★★★★★)
- **关键亮点**：通过几何推导，清晰地解释了如何通过两个点推导出另外两个点的坐标，并利用勾股定理计算面积。代码简洁且高效。
- **个人心得**：作者提到通过画图帮助理解几何关系，这是解决几何问题的有效方法。

```cpp
for(int i=1;i<=n;i++) {
    for(int j=1;j<=n;j++) {
        int a = x[i] - x[j];
        int b = y[i] - y[j];
        int Ax = x[i] - b;
        int Bx = x[j] - b;
        int Ay = y[i] + a;
        int By = y[j] + a;
        if (Ax >= 0 && Ax <= 5000 && Bx >= 0 && Bx <= 5000 && Ay >= 0 && Ay <= 5000 && By >= 0 && By <= 5000) {
            if (f[Ax][Ay] && f[Bx][By]) {
                ans = max(ans, a * a + b * b);
            }
        }
    }
}
```

#### 2. 作者：NobodyThere (★★★★☆)
- **关键亮点**：通过确定正方形的对角线，推导出另外两个点的坐标，并判断是否存在。思路清晰，代码实现简洁。
- **个人心得**：作者提到通过辅助正方形简化坐标计算，这是几何问题中常用的技巧。

```cpp
for(int i = 1; i < n; i++) {
    for(int j = i + 1; j <= n; j++) {
        int s = x[i] + y[i] + x[j] + y[j];
        if(s & 1) continue;
        else s >>= 1;
        int x1 = s - y[j], y1 = s - x[i], x2 = s - y[i], y2 = s - x[j];
        if(x1 >= 0 && y1 >= 0 && x2 >= 0 && y2 >= 0 && vis[x1][y1] && vis[x2][y2]) {
            ans = max(ans, (x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]) >> 1);
        }
    }
}
```

#### 3. 作者：_Luminous (★★★★☆)
- **关键亮点**：通过枚举两个点，利用全等三角形推导出另外两个点的坐标，并判断是否存在。代码实现简洁，思路清晰。
- **个人心得**：作者提到通过画图帮助理解几何关系，这是解决几何问题的有效方法。

```cpp
for(int i = 1; i < n; i++) {
    for(int j = i + 1; j <= n; j++) {
        int nx = a[i].x - a[j].x, ny = a[i].y - a[j].y;
        if(a[i].x + ny >= 0 && a[i].y - nx >= 0 && a[j].x + ny >= 0 && a[j].y - nx >= 0 && a[i].x + ny <= 5000 && a[j].x + ny <= 5000 && a[i].y - nx <= 5000 && a[j].y - nx <= 5000) {
            if(vis[a[i].x + ny][a[i].y - nx] && vis[a[j].x + ny][a[j].y - nx]) {
                ans = max(ans, nx * nx + ny * ny);
            }
        }
    }
}
```

### 拓展思路与类似题目

1. **拓展思路**：本题的几何推导方法可以推广到其他几何形状的查找问题，如矩形、菱形等。通过枚举关键点，利用几何关系推导其他点的位置，可以大幅减少时间复杂度。
2. **类似题目**：
   - [P2733 家的范围](https://www.luogu.com.cn/problem/P2733)：查找矩阵中的最大正方形。
   - [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：在01矩阵中查找最大全1正方形。
   - [P2701 巨大的牛棚](https://www.luogu.com.cn/problem/P2701)：在矩阵中查找最大正方形区域。

### 总结

通过几何推导和边界判断，可以在O(n^2)的时间复杂度内解决本题。画图和辅助几何图形是理解几何关系的有效方法，建议在解决类似问题时多加使用。

---
处理用时：46.36秒
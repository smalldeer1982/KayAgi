# 题目信息

# 火炬

## 题目描述

2008 北京奥运会，你想成为四川汶川的一名火炬手，经过层层选拔，终于到了最后一关。

这一关是一道很难的题：任意给定一个正整数 $N$，求一个最小的正整数 $M$，使得 $N \times M$ 的十进制表示形式里只含有 `1` 和 `0`。


## 说明/提示

$1\le N\le 10^5$

## 样例 #1

### 输入

```
12```

### 输出

```
925```

# AI分析结果

### 综合分析与结论

该题的核心目标是找到一个最小的正整数 \( M \)，使得 \( N \times M \) 的十进制表示只包含 `0` 和 `1`。题解中主要采用了以下几种思路：

1. **DFS/BFS搜索**：通过深度优先搜索（DFS）或广度优先搜索（BFS）生成所有由 `0` 和 `1` 组成的数，然后判断是否能被 \( N \) 整除。这种方法的优点是思路直观，但需要控制搜索的深度，避免超时。
  
2. **二进制枚举**：将问题转化为二进制枚举，生成由 `0` 和 `1` 组成的数，再判断是否能被 \( N \) 整除。这种方法利用了二进制的特性，减少了搜索空间。

3. **构造法**：通过构造只包含 `0` 和 `1` 的数，直接判断是否能被 \( N \) 整除。这种方法避免了暴力搜索，但需要对数的构造有较好的理解。

4. **数论优化**：通过数论知识优化搜索过程，减少不必要的计算。这种方法需要对数论有较深的理解，但能显著提高效率。

### 评分较高的题解

#### 1. 作者：Manjusaka丶梦寒 (4星)
- **关键亮点**：通过DFS生成所有由 `0` 和 `1` 组成的数，并进行排序，确保找到最小的 \( M \)。代码简洁，思路清晰。
- **核心代码**：
  ```cpp
  void dfs(long long x) {
      a[++tot] = x;
      if (x > 9e17) return;
      for (int i = 0; i <= 1; i++)
          dfs(x * 10 + i);
  }
  ```
- **个人心得**：作者提到“直接把0和1组成的数搜出来”，强调了DFS的直观性和简洁性。

#### 2. 作者：_cmh (4星)
- **关键亮点**：使用DFS进行搜索，并通过限制位数（bits）来控制搜索深度，避免超时。代码简洁，思路清晰。
- **核心代码**：
  ```cpp
  void dfs(long long now, int bits) {
      if (bits == 20) return;
      if (now % n == 0 && (now < minn || minn == 0)) minn = now;
      dfs(now * 10, bits + 1);
      dfs(now * 10 + 1, bits + 1);
  }
  ```
- **个人心得**：作者提到“直接爆搜，每次分两种情况”，强调了DFS的简单性和有效性。

#### 3. 作者：HoshiuZ (4星)
- **关键亮点**：使用BFS进行搜索，并通过记录余数来避免重复计算，提高效率。代码简洁，思路清晰。
- **核心代码**：
  ```cpp
  void bfs() {
      int head = 1, tail = 1;
      que[head] = 1;
      while (head <= tail) {
          long long q_1 = que[head] * 10, q_2 = que[head] * 10 + 1;
          if (!(q_1 % n)) {
              ans = q_1 / n;
              break;
          }
          if (!(q_2 % n)) {
              ans = q_2 / n;
              break;
          }
          if (!vh[q_1 % n]) que[++tail] = q_1;
          if (!vh[q_2 % n]) que[++tail] = q_2;
          head++;
      }
  }
  ```
- **个人心得**：作者提到“每次拓展两个点，若为解直接存为答案”，强调了BFS的效率和简洁性。

### 最优关键思路与技巧

1. **DFS/BFS搜索**：通过DFS或BFS生成所有由 `0` 和 `1` 组成的数，然后判断是否能被 \( N \) 整除。这种方法思路直观，但需要控制搜索深度，避免超时。
  
2. **二进制枚举**：将问题转化为二进制枚举，生成由 `0` 和 `1` 组成的数，再判断是否能被 \( N \) 整除。这种方法利用了二进制的特性，减少了搜索空间。

3. **构造法**：通过构造只包含 `0` 和 `1` 的数，直接判断是否能被 \( N \) 整除。这种方法避免了暴力搜索，但需要对数的构造有较好的理解。

### 可拓展之处

1. **同类型题**：类似的问题可以扩展到其他进制或特定的数字组合，如只包含 `1` 和 `2` 的数。
  
2. **算法套路**：DFS/BFS搜索、二进制枚举、构造法等思路可以应用于其他需要生成特定数字组合的问题。

### 推荐题目

1. **P2841 [USACO08DEC]Patting Heads S**：考察二进制枚举和数论知识。
2. **P1189 [USACO08OCT]Bovine Bones G**：考察DFS/BFS搜索和数论知识。
3. **P1988 [NOIP2013 提高组] 火柴棒等式**：考察构造法和数论知识。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中遇到超时问题，通过限制搜索深度或优化搜索策略解决了问题。
- **踩坑教训**：部分作者提到未开 `long long` 导致错误，强调了数据类型选择的重要性。
- **顿悟感想**：多位作者提到通过DFS/BFS搜索或二进制枚举的思路，解决了看似复杂的问题，强调了算法思路的重要性。

---
处理用时：47.94秒
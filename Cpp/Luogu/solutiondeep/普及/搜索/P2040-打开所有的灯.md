# 题目信息

# 打开所有的灯

## 题目背景

pmshz在玩一个益(ruo)智(zhi)的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了pmshz。。。


## 题目描述

这个灯很奇(fan)怪(ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉pmshz要全部打开这些灯。



例如
```
0  1  1
1  0  0
1  0  1
```

点一下最中间的灯【2,2】就变成了
```
0  0  1
0  1  1
1  1  1
```

再点一下左上角的灯【1,1】就变成了

```
1  1  1
1  1  1
1  1  1
```

达成目标。最少需要2步。

输出2即可。


## 说明/提示

这个题水不水，就看你怎么考虑了。。。。


## 样例 #1

### 输入

```
0 1 1
1 0 0
1 0 1```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是通过最少的操作次数将所有灯打开，操作一个灯会同时改变其周围灯的状态。题解中主要采用了以下几种思路：

1. **暴力枚举**：通过枚举所有可能的操作组合，检查是否满足条件。由于灯的数量较少（9盏），暴力枚举是可行的。
2. **深度优先搜索（DFS）**：通过递归尝试所有可能的操作路径，记录最小操作次数。
3. **广度优先搜索（BFS）**：通过队列逐层扩展状态，找到最短路径。
4. **状态压缩与位运算**：将灯的状态用二进制表示，通过位运算进行状态转移，优化空间和时间复杂度。
5. **线性代数与异或方程组**：将问题转化为线性方程组，通过解方程找到最优解。

### 精选题解

#### 题解1：作者：Bartholomew (赞：28)
- **星级**：★★★★★
- **关键亮点**：通过二进制枚举所有可能的操作组合，利用位运算高效计算每个灯的状态变化，最终找到最小操作次数。代码简洁且高效，思路清晰。
- **核心代码**：
  ```cpp
  for(int used=0;used<(1<<9);used++) {
      get(used); memset(how,0,sizeof how);
      for(int i=0;i<9;i++) 
          if(s[i]) {
              // 根据i的位置更新how数组
          }
      bool flag=true;
      for(int i=0;i<9;i++) 
          if(how[i]%2==1 && a[i]) flag=false;
          else if(how[i]%2==0 && !a[i]) flag=false;
      if(flag) {
          tot=0;
          for(int i=0;i<9;i++) if(s[i]) tot++;
          ans=getmin(tot,ans);
      } 
  }
  ```
- **个人心得**：作者提到“其实这道题目你会发现其实只需要关心是否会与这盏灯操作一次就够了”，强调了操作的奇偶性对结果的影响，简化了问题。

#### 题解2：作者：nothingness (赞：23)
- **星级**：★★★★☆
- **关键亮点**：使用状压DP，将灯的状态用二进制表示，通过异或操作进行状态转移，时间复杂度为O(512*9)，比大多数题解更快。
- **核心代码**：
  ```cpp
  int upd[10]={0,416,464,200,308,186,89,38,23,11};
  for(int i=1;i<=9;i++)
      if(f[x^upd[i]]==-1)
          q[++t]=x^upd[i],f[x^upd[i]]=f[x]+1;
  ```
- **个人心得**：作者提到“这种方法是O(512*9)的，比绝大多数题解要快”，强调了算法的效率。

#### 题解3：作者：ljc1301 (赞：18)
- **星级**：★★★★☆
- **关键亮点**：通过枚举第一行的操作状态，逐行确定后续操作，最终判断最后一行是否全亮。时间复杂度为O(2^3 * 3 * 3)，优化了暴力枚举。
- **核心代码**：
  ```cpp
  void dfs(int s) {
      if(s>=n) {
          num=min(num,pd());
          return;
      }
      for(ans[0][s]=0;ans[0][s]<2;ans[0][s]++) 
          dfs(s+1);
  }
  ```
- **个人心得**：作者提到“其实我们对于这九盏灯，我们只需要枚举其中某一行或者某一列的开关情况就能得解”，通过减少枚举量优化了算法。

### 最优关键思路与技巧

1. **二进制枚举与位运算**：通过二进制表示灯的状态和操作，利用位运算高效计算状态转移，适用于状态数较少的问题。
2. **状态压缩与DP**：将灯的状态压缩为二进制数，通过DP或BFS进行状态转移，适用于需要记录状态的问题。
3. **线性代数与异或方程组**：将问题转化为线性方程组，通过解方程找到最优解，适用于需要数学建模的问题。

### 拓展与举一反三

1. **类似题目**：
   - P2040 打开所有的灯
   - P1219 八皇后
   - P1074 靶形数独

2. **调试与顿悟**：在调试过程中，作者发现“一个灯最多开一次”，这简化了问题的复杂度，避免了重复操作。这种通过观察问题特性来优化算法的思路值得借鉴。

### 推荐题目

1. **P2040 打开所有的灯**：与本题完全相同，适合巩固练习。
2. **P1219 八皇后**：通过回溯法解决棋盘问题，与本题的DFS思路相似。
3. **P1074 靶形数独**：通过状态压缩和回溯法解决复杂数独问题，与本题的位运算和DP思路相似。

---
处理用时：47.11秒
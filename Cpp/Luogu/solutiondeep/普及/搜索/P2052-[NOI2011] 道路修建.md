# 题目信息

# [NOI2011] 道路修建

## 题目描述

在 W 星球上有 $n$ 个国家。为了各自国家的经济发展，他们决定在各个国家之间建设双向道路使得国家之间连通。但是每个国家的国王都很吝啬，他们只愿意修建恰好 $n - 1$ 条双向道路。

每条道路的修建都要付出一定的费用，这个费用等于道路长度乘以道路两端 的国家个数之差的绝对值。例如，在下图中，虚线所示道路两端分别有 $2$ 个、$4$ 个国家，如果该道路长度为 $1$，则费用为 $1×|2 - 4|=2$。图中圆圈里的数字表示国家的编号。
 
 ![](https://cdn.luogu.com.cn/upload/pic/2604.png) 

由于国家的数量十分庞大，道路的建造方案有很多种，同时每种方案的修建费用难以用人工计算，国王们决定找人设计一个软件，对于给定的建造方案，计算出所需要的费用。请你帮助国王们设计一个这样的软件。


## 说明/提示

对于 $100\%$ 的数据，$1\leq a_i, b_i\leq n$，$0\leq c_i\leq10^6$，$2\leq n\leq 10^6$。
|测试点编号|$n=$|
|:-:|:-:|
|$1$|$2$|
|$2$|$10$|
|$3$|$100$|
|$4$|$200$|
|$5$|$500$|
|$6$|$600$|
|$7$|$800$|
|$8$|$1000$|
|$9$|$10^4$|
|$10$|$2\times 10^4$|
|$11$|$5\times 10^4$|
|$12$|$6\times 10^4$|
|$13$|$8\times 10^4$|
|$14$|$10^5$|
|$15$|$6\times 10^5$|
|$16$|$7\times 10^5$|
|$17$|$8\times 10^5$|
|$18$|$9\times 10^5$|
|$19,20$|$10^6$|



## 样例 #1

### 输入

```
6
1 2 1
1 3 1
1 4 2
6 3 1
5 2 1```

### 输出

```
20```

# AI分析结果

### 综合分析与结论

本题的核心是通过树的遍历（DFS或BFS）来计算每条边的费用，费用公式为 `|n - 2 * size[v]| * w`，其中 `size[v]` 是以 `v` 为根的子树大小，`w` 是边的长度。所有题解基本都采用了这一思路，主要区别在于实现细节和优化程度。

大多数题解使用DFS遍历树，计算子树大小，并在遍历过程中累加每条边的费用。部分题解提到了BFS的实现，但由于DFS在本题中更为简洁且易于理解，DFS成为主流解法。部分题解还提到了使用邻接表或链式前向星来存储树结构，优化了空间和时间复杂度。

### 所选高星题解

#### 1. 作者：Melon_Musk (5星)
- **关键亮点**：思路清晰，代码简洁，使用了邻接表存储树结构，DFS遍历时直接计算费用，避免了冗余操作。
- **个人心得**：通过样例手推理解题意，强调了公式的推导过程，帮助读者更好地理解算法。

```cpp
void dfs(int x,int fa) {
    size[x]=1;
    for(int i=head[x];i;i=e[i].nt) {
        int to=e[i].to;
        if(fa==to) continue;
        dfs(to,x);
        size[x]+=size[to];
        ans+=e[i].w*abs(2*size[to]-n);
    }
}
```
- **核心思想**：DFS遍历树，计算子树大小，并在遍历过程中累加每条边的费用。

#### 2. 作者：Aw顿顿 (4星)
- **关键亮点**：详细解释了公式的推导过程，代码结构清晰，使用了链式前向星存储树结构，DFS遍历时直接计算费用。
- **个人心得**：强调了树的遍历顺序和递归的终止条件，帮助读者避免常见的递归错误。

```cpp
void dfs(int x,int fa) {
    s[x]=1;
    for(int i=h[x];i;i=e[i].nxt) {
        int v=e[i].v,w=e[i].w;
        if(v!=fa) {
            dfs(v,x);
            ans+=abs(n-2*s[v])*w;
            s[x]+=s[v];
        }
    }
}
```
- **核心思想**：DFS遍历树，计算子树大小，并在遍历过程中累加每条边的费用。

#### 3. 作者：kradcigam (4星)
- **关键亮点**：使用了vector存储树结构，代码简洁，DFS遍历时直接计算费用，避免了冗余操作。
- **个人心得**：强调了树的连通性，帮助读者理解公式的推导过程。

```cpp
void dfs(int x, int fa) {
    sz[x] = 1;
    for (auto i : v[x]) {
        if (i.first != fa) {
            dfs(i.first, x);
            sz[x] += sz[i.first];
            ans += 1ll * i.second * abs(sz[i.first] - (n - sz[i.first]));
        }
    }
}
```
- **核心思想**：DFS遍历树，计算子树大小，并在遍历过程中累加每条边的费用。

### 最优关键思路与技巧
1. **树的遍历**：DFS或BFS遍历树，计算子树大小。
2. **费用公式**：`|n - 2 * size[v]| * w`，其中 `size[v]` 是以 `v` 为根的子树大小，`w` 是边的长度。
3. **数据结构**：使用邻接表或链式前向星存储树结构，优化空间和时间复杂度。

### 可拓展之处
1. **树的直径**：类似题目可以通过DFS或BFS计算树的直径。
2. **最小生成树**：类似题目可以通过Kruskal或Prim算法计算最小生成树。
3. **树的重心**：类似题目可以通过DFS计算树的重心。

### 推荐题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P1395 会议](https://www.luogu.com.cn/problem/P1395)
3. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)

### 个人心得总结
- **调试经历**：部分题解提到了调试过程中遇到的坑，如 `scanf` 未加 `&` 导致的错误，提醒读者注意细节。
- **顿悟感想**：通过样例手推理解题意，帮助读者更好地理解算法。

---
处理用时：40.12秒
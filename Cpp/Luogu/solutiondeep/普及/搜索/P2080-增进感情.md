# 题目信息

# 增进感情

## 题目背景

小明和小红的感情，是慢慢发展起来的。


## 题目描述

他们对对方分别有一个好感值。定义两人的亲密程度为两人的好感值之和。

如果他们的亲密程度达到 $v$，则他们将走到一起。他们以后的生活将取决于两人的好感值之差的绝对值，这个值越小，他们的生活将越幸福。

现在，他们对对方的好感值都为 $0$，小明有 $n$ 件事可以干，每件事可以增加他对小红的好感 $a_i$ 点，并且增加小红对他的好感 $b_i$ 点。（可能为负数）

小明可以任选一些事做，请你帮小明求出怎样才能让他们的生活更加幸福（求出两人在一起的前提下，好感值之差的最小绝对值即可）。


## 说明/提示

#### 数据范围与约定

- 对于 $20\%$ 数据，保证 $n  \le 10$。
- 对于 $100\%$ 数据，保证 $1 \le n \le 30$，$1 \le \left\vert a_i\right\vert,\left\vert b_i\right\vert \le 100$。

## 样例 #1

### 输入

```
4 15
5 6
-1 8
7 2
1 0
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心是通过DFS（深度优先搜索）枚举所有可能的操作组合，找到在满足亲密程度达到$v$的前提下，好感值之差的最小绝对值。由于数据范围较小（$n \le 30$），DFS是可行的，但需要合理的剪枝来优化性能。

大多数题解都采用了DFS的基本框架，但在剪枝和优化上有不同的处理。常见的剪枝策略包括：
1. **提前终止**：当好感值之差为0时，直接返回，因为这是最优解。
2. **顺序优化**：从上次搜索的位置继续搜索，避免重复计算。
3. **状态记录**：通过数组记录是否做过某件事，避免重复选择。

### 所选高星题解

#### 1. **作者：defense (赞：29)**
- **星级**：★★★★★
- **关键亮点**：
  - 使用了顺序优化剪枝，从上次搜索的位置继续搜索，避免重复计算。
  - 提前终止剪枝，当好感值之差为0时直接返回。
  - 代码结构清晰，注释详细，易于理解。
- **个人心得**：
  - 强调了剪枝的重要性，尤其是当数据范围较大时，剪枝能显著提升性能。
- **核心代码**：
```cpp
void dfs(int deep){
    if(ga+gb>v){
        minn=min(abs(ga-gb),minn);
    }
    if(minn==0){
        return;
    }
    for(int i=deep;i<m;i++){
        if(used[i]==0){
            used[i]=1;
            ga+=a[i];
            gb+=b[i];
            dfs(i+1);
            ga-=a[i];
            gb-=b[i];
            used[i]=0;
        }
    }
}
```

#### 2. **作者：封禁用户 (赞：6)**
- **星级**：★★★★
- **关键亮点**：
  - 采用了类似01背包的思路，每件事有做或不做的选择。
  - 使用了提前终止剪枝，当好感值之差为0时直接返回。
  - 代码简洁，逻辑清晰。
- **核心代码**：
```cpp
void dfs(int x,int y,int k){
    if(minn==0) return;
    if(k>n){
        if(x+y>=v) minn=min(minn,abs(x-y));
        return;
    }
    dfs(x+a[k],y+b[k],k+1);
    dfs(x,y,k+1);
}
```

#### 3. **作者：Eraine (赞：4)**
- **星级**：★★★★
- **关键亮点**：
  - 详细分析了DFS的思路，并给出了分治的思想。
  - 使用了提前终止剪枝，当好感值之差为0时直接返回。
  - 代码结构清晰，注释详细。
- **核心代码**：
```cpp
void search_dfs(long long v,long long sum,long long cha){
    if(minx==0) return;
    if(sum>=w){
        minx=min(minx,abs(cha));
    }
    if(v>n) return;
    search_dfs(v+1,sum,cha);
    search_dfs(v+1,sum+a[v][0]+a[v][1],cha+a[v][0]-a[v][1]);
}
```

### 最优关键思路与技巧
1. **剪枝优化**：提前终止和顺序优化是DFS中常见的剪枝策略，能显著减少搜索空间。
2. **状态记录**：通过数组记录是否做过某件事，避免重复选择。
3. **分治思想**：将问题分解为每件事做或不做的选择，简化搜索逻辑。

### 可拓展之处
- **类似算法套路**：这类问题可以扩展到其他组合优化问题，如背包问题、子集和问题等。
- **同类型题目**：可以尝试解决类似的DFS+剪枝问题，如全排列、子集生成等。

### 推荐题目
1. **P1706 全排列问题**：考察DFS的基本应用。
2. **P1048 采药**：类似背包问题，考察DFS+剪枝。
3. **P1219 八皇后**：经典的DFS问题，考察剪枝和状态记录。

### 个人心得总结
- **调试经历**：多位作者提到在调试过程中发现剪枝的重要性，尤其是在数据范围较大时，剪枝能显著提升性能。
- **踩坑教训**：部分作者在未加剪枝的情况下TLE，强调了剪枝的必要性。
- **顿悟感想**：通过DFS+剪枝，能够有效解决组合优化问题，尤其是在数据范围较小的情况下。

---
处理用时：40.53秒
# 题目信息

# 找人

## 题目描述

小明要到他的同学家玩，可他只知道他住在某一单元，却不知住在哪个房间。那个单元有 $n$ 层（$1,2,\ldots,n$），每层有 $m$（$1,2,\ldots,m$）个房间。

小明会从第一层的某个房间开始找，他找的方式也很特别，每次到了一个房间，如果不是他的同学，他就会询问这个人，然后他就会去那人告诉他的房间号，如果还不是，他就会继续按这个方法找下去，直到找到。当然，他也有可能找不到同学。他的体力也是有限的，他每爬一层楼梯就会消耗 $v$ 体力值。你的任务就是求找到同学耗费的最少体力值，如果找不到，就输出 `impossible` 。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \leq n\le1000$，$1 \leq m\le100$，$1 \leq v\le50$。

## 样例 #1

### 输入

```
3 3 2 2 3
1 3 3 3 2 1
2 3 1 1 2 3
1 1 1 2 2 3
```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是通过搜索或图论算法找到从起点到目标点的最小体力消耗路径。题解中主要涉及DFS、BFS、优先队列BFS、并查集、最短路（SPFA）等算法。DFS和BFS是最直观的解法，但容易陷入死循环或效率低下；优先队列BFS和SPFA则通过优化状态转移和路径选择，提高了效率。并查集的解法较为独特，但实现复杂且不易理解。

### 所选高星题解

#### 1. 作者：Dog_Two (赞：14) - 5星
**关键亮点**：
- 使用优先队列BFS，确保每次扩展的状态都是当前最优的，避免了普通BFS的局限性。
- 详细解释了优先队列BFS的适用场景和优势，帮助读者理解算法的选择。
- 代码结构清晰，注释详细，易于理解。

**个人心得**：
- 通过多次提交和调试，逐步修正了“下楼不耗体力”和“状态优先度”等错误，强调了调试的重要性。

**核心代码**：
```cpp
int BFS() {
    for(int i=1;i<=m;++i) {
        q.push((rec){0,make_pair(1,i)}); // 从第一层每个房间开始
    }
    while(!q.empty()) {
        rec tmp=q.top(); q.pop();
        int x=tmp.p.first,y=tmp.p.second;
        if(vis[x][y]) continue;
        vis[x][y]=true;
        int C=tmp.cnt;
        pair<int,int> Next=get_Next(tmp.p);
        if(tmp.p==make_pair(_x,_y)) return C; 
        int del=abs(Next.first-x); 
        q.push((rec){del+C,Next});
    }
    return -1;
}
```
**核心思想**：使用优先队列存储状态，确保每次扩展的状态都是当前体力消耗最小的，最终找到最优解。

#### 2. 作者：白鲟 (赞：6) - 4星
**关键亮点**：
- 采用单源最短路（SPFA）算法，将目标点作为源点，反向建图，减少了搜索次数。
- 通过将二维坐标转换为一维索引，简化了图的存储和操作。
- 代码简洁，思路清晰，适合有一定图论基础的读者。

**核心代码**：
```cpp
void spfa() {
    queue<int>que;
    memset(dis,0x7f,sizeof(dis));
    que.push(s);
    exist[s]=true;
    dis[s]=0;
    while(!que.empty()) {
        int p=que.front();
        que.pop();
        exist[p]=false;
        for(int i=head[p];i;i=next[i]) {
            if(dis[to[i]]>dis[p]+len[i]) {
                dis[to[i]]=dis[p]+len[i];
                if(!exist[to[i]]) {
                    que.push(to[i]);
                    exist[to[i]]=true;
                }
            }
        }
    }
}
```
**核心思想**：将目标点作为源点，反向建图，通过SPFA算法计算从目标点到所有第一层房间的最短路径，取最小值。

#### 3. 作者：Chanter (赞：2) - 4星
**关键亮点**：
- 使用回溯法结合状态记录，避免了DFS中的死循环问题。
- 通过`check`数组记录访问状态，确保每个点只被访问一次，提高了效率。
- 代码简洁，思路清晰，适合初学者理解。

**核心代码**：
```cpp
void dfs(int sum,int l,int r) {
    if(l==x&&r==y) {
        ans=min(ans,sum);
        return ;
    }
    if(check[mapl[l][r]][mapr[l][r]]) return ;
    check[mapl[l][r]][mapr[l][r]]=true;
    dfs(sum+(mapl[l][r]>l?mapl[l][r]-l:l-mapl[l][r])*v,mapl[l][r],mapr[l][r]);
    check[mapl[l][r]][mapr[l][r]]=false;
}
```
**核心思想**：通过回溯法和状态记录，确保DFS不会陷入死循环，同时记录最小体力消耗。

### 最优关键思路与技巧

1. **优先队列BFS**：适用于状态转移代价不固定的场景，确保每次扩展的状态都是当前最优的。
2. **反向建图与单源最短路**：将目标点作为源点，反向建图，减少搜索次数，适用于需要从多个起点到单个终点的场景。
3. **回溯法与状态记录**：通过记录访问状态，避免DFS中的死循环问题，适用于需要回溯的场景。

### 拓展思路与同类型题

1. **同类型题**：
   - [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：考察最短路算法的应用。
   - [P1073 最优贸易](https://www.luogu.com.cn/problem/P1073)：涉及图论中的最短路和状态转移。
   - [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)：考察并查集的应用。

2. **类似算法套路**：
   - **优先队列BFS**：适用于状态转移代价不固定的场景，如Dijkstra算法。
   - **反向建图**：适用于需要从多个起点到单个终点的场景，如SPFA算法。
   - **回溯法与状态记录**：适用于需要回溯的场景，如DFS中的剪枝。

### 个人心得总结

- **调试与修正**：通过多次提交和调试，逐步修正错误，强调了调试的重要性。
- **算法选择**：根据问题的特点选择合适的算法，如优先队列BFS适用于状态转移代价不固定的场景。
- **代码优化**：通过状态记录和回溯法，避免DFS中的死循环问题，提高代码效率。

---
处理用时：48.77秒
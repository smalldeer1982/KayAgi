# 题目信息

# K皇后

## 题目描述

小 Z 最近捡到了一个 $n$ 行 $m$ 列的棋盘，棋盘上的格子的横纵坐标从 $1$ 开始编号，他想在棋盘上摆放 $K$ 个皇后。他想知道在他摆完这 $K$ 个皇后之后，棋盘上还有多少个格子是不会被攻击到的。

**注意：一个皇后会攻击到这个皇后所在的那一行，那一列，以及两条对角线。**

## 说明/提示

- 对于 $30\%$ 的数据，$1\le n,m\le 5\times10^3$，$1\le K\le 500$；
- 对于另外 $10\%$ 的数据，$K=1$；
- 对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^4$，$1\le K\le 500$。

## 样例 #1

### 输入

```
12 13 6
10 4
12 10
1 1
2 3
3 2
2 6```

### 输出

```
25```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在给定的棋盘上高效计算不被皇后攻击的格子数量。由于棋盘规模较大（n, m ≤ 2e4），直接暴力枚举每个格子的时间复杂度为O(n*m)，无法通过时间限制。因此，多数题解采用了逐行处理的方式，通过标记每行中被攻击的格子来减少时间复杂度。

### 所选高星题解

#### 1. 作者：gujialiang123 (5星)
- **关键亮点**：通过逐行处理，利用`flag`数组标记每行中被攻击的格子，避免了重复计算。时间复杂度为O(n*k)，空间复杂度为O(m)，非常高效。
- **代码实现**：
  ```cpp
  for(int i=1;i<=n;i++) {
      if(vis[i]) continue;
      sum = m;
      for(int j=1;j<=k;j++) {
          if(flag[y[j]]!=i) sum--;
          flag[y[j]] = i;
          if(x[j]<i) {
              if(y[j]+i-x[j]>=1 && y[j]+i-x[j]<=m) {
                  if(flag[y[j]+i-x[j]]!=i) sum--;
                  flag[y[j]+i-x[j]] = i;
              }
              if(y[j]-i+x[j]>=1 && y[j]-i+x[j]<=m) {
                  if(flag[y[j]-i+x[j]]!=i) sum--;
                  flag[y[j]-i+x[j]] = i;
              }
          } else {
              if(y[j]+(x[j]-i)>=1 && y[j]+(x[j]-i)<=m) {
                  if(flag[y[j]+(x[j]-i)]!=i) sum--;
                  flag[y[j]+(x[j]-i)] = i;
              }
              if(y[j]-(x[j]-i)>=1 && y[j]-(x[j]-i)<=m) {
                  if(flag[y[j]-(x[j]-i)]!=i) sum--;
                  flag[y[j]-(x[j]-i)] = i;
              }
          }
      }
      ans += sum;
  }
  ```

#### 2. 作者：彩虹猫 (4.5星)
- **关键亮点**：同样采用逐行处理，但使用了`memset`初始化标记数组，代码简洁易懂。时间复杂度为O(n*k)，空间复杂度为O(m)。
- **代码实现**：
  ```cpp
  for(int i=1;i<=n;i++) {
      if(r[i]==1) continue;
      memset(q,0,sizeof(q));
      sum = 0;
      for(int j=1;j<=k;j++) {
          q[y[j]] = 1;
          if(x[j]<i) {
              if(y[j]+(i-x[j])<=m) q[y[j]+(i-x[j])] = 1;
              if(y[j]-(i-x[j])>=1) q[y[j]-(i-x[j])] = 1;
          } else {
              if(y[j]+(x[j]-i)<=m) q[y[j]+(x[j]-i)] = 1;
              if(y[j]-(x[j]-i)>=1) q[y[j]-(x[j]-i)] = 1;
          }
      }
      for(int j=1;j<=m;j++) if(q[j]==0) sum++;
      ans += sum;
  }
  ```

#### 3. 作者：zqiceberg (4星)
- **关键亮点**：通过时间戳优化标记数组的初始化，避免了重复清空数组，时间复杂度为O(n*k)，空间复杂度为O(m)。
- **代码实现**：
  ```cpp
  for(int i=1;i<=n;i++) {
      if(row[i]) continue;
      int sum = m;
      for(int j=0;j<k;j++) {
          int a = q[j].first, b = q[j].second;
          if(flag[b] != i) sum--;
          flag[b] = i;
          if(a < i) {
              if(b - (i - a) >= 1) {
                  if(flag[b - (i - a)] != i) sum--;
                  flag[b - (i - a)] = i;
              }
              if(b + (i - a) <= m) {
                  if(flag[b + (i - a)] != i) sum--;
                  flag[b + (i - a)] = i;
              }
          }
          if(i < a) {
              if(b + (a - i) <= m) {
                  if(flag[b + (a - i)] != i) sum--;
                  flag[b + (a - i)] = i;
              }
              if(b - (a - i) >= 1) {
                  if(flag[b - (a - i)] != i) sum--;
                  flag[b - (a - i)] = i;
              }
          }
      }
      res += sum;
  }
  ```

### 最优关键思路与技巧
1. **逐行处理**：通过逐行处理，将问题复杂度从O(n*m)降低到O(n*k)。
2. **标记数组优化**：使用时间戳或逐行初始化标记数组，避免重复清空数组。
3. **对角线计算**：通过数学公式快速计算对角线上的格子，减少计算量。

### 可拓展之处
- **类似问题**：如“N皇后问题”、“棋盘覆盖问题”等，都可以采用类似的逐行或逐列处理方式。
- **优化技巧**：时间戳标记、空间压缩等技巧在其他大规模数据处理问题中也适用。

### 推荐洛谷题目
1. P1219 八皇后
2. P2106 棋盘覆盖
3. P2107 棋盘问题

### 个人心得摘录
- **gujialiang123**：通过逐行处理和时间戳优化，避免了重复计算，代码简洁高效。
- **彩虹猫**：逐行处理结合`memset`初始化，代码清晰易懂，适合初学者理解。
- **zqiceberg**：通过时间戳优化标记数组，避免了重复清空，提升了代码效率。

---
处理用时：53.05秒
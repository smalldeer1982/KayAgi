# 题目信息

# 公路通行税

## 题目描述

在 PALMIA 国家内，有 $N$ 个城市由公路相连（每条公路恰好双向连接两个城市）。经由一条公路或多条公路，从任一城市出发可以到达其余各个城市。直到今年，公路上才要征收公路通行税。在每条公路的中间，有一征税员，从每一辆经由此路的车收取 1 PALMIA COIN（1PC）。

政府官员决定减少收税员而推行公路印花。如果一辆车欲进入一条公路，就必须将这张印花贴在窗上。

政府官员决定：一年的公路印花的价值相当于在两个最远城市之间进行 $100$ 次旅行所需的费用。两个城市之间的距离是从一个城市到达第二个城市所需经过的最少数目的公路数。

你的任务是编写一个程序计算出公路印花的价值。

## 样例 #1

### 输入

```
4 4
1 2
2 3
4 2
3 4
0 0```

### 输出

```
200```

# AI分析结果

### 综合分析与结论

本题的核心是求无向连通图中任意两点间的最短路径的最大值（即图的直径），并将其乘以100作为答案。由于每条边的权值为1，因此可以使用BFS来高效求解最短路径。大部分题解都采用了BFS的思路，通过遍历每个点作为起点，计算其到其他点的最短路径，并取最大值。部分题解还提到了Dijkstra和SPFA等算法，但由于边权为1，BFS的时间复杂度更低，更适合本题。

### 精选题解

#### 1. 作者：Computer1828 (★★★★★)
- **关键亮点**：详细分析了BFS的正确性，并解释了为什么BFS在边权为1的情况下比Dijkstra更高效。代码结构清晰，使用了链式前向星存图，BFS实现简洁。
- **个人心得**：强调了BFS的正确性，并指出在边权为1的情况下，BFS的每个点第一次被访问时的距离就是最短路径。
- **核心代码**：
  ```cpp
  inline void bfs(int s){
      queue<node> q;
      q.push((node){s,0});
      vis[s] = true; 
      while(!q.empty()){
          node fr = q.front();
          q.pop();
          int u = fr.tp, dis = fr.dis;
          ans = max(ans,dis);
          for(int i = hed[u];i;i = e[i].nxt){
              int v = e[i].to;
              if(vis[v]) continue;
              q.push((node){v,dis+1});
              vis[v] = true;
          }
      }
  }
  ```

#### 2. 作者：Ambition_ (★★★★☆)
- **关键亮点**：提出了无向图直径的概念，并详细解释了BFS的正确性。代码使用了`vector`存图，BFS实现简洁，且对多组数据的处理较为完善。
- **个人心得**：提到了一些调试经历，如第四个测试点的数据问题，并给出了解决方案。
- **核心代码**：
  ```cpp
  void bfs(int st){
      queue<P>Q;
      memset(vis,1,sizeof vis);
      Q.push(P(0,st));
      vis[st]=0;
      while(!Q.empty()){
          P p=Q.front();
          Q.pop();
          int dis=p.fi;
          int now=p.se;
          d=max(d,dis);
          for(int i=0;i<(int)e[now].size();i++){
              int u=e[now][i];
              if(!vis[u])continue;
              vis[u]=0;
              Q.push(P(dis+1,u));
          }
      }
  }
  ```

#### 3. 作者：Lonely_NewYear (★★★★☆)
- **关键亮点**：强调了BFS的正确性，并指出在边权为1的情况下，BFS的每个点第一次被访问时的距离就是最短路径。代码简洁，使用了`vector`存图，BFS实现清晰。
- **个人心得**：提到了一些调试经历，如第四个测试点的数据问题，并给出了解决方案。
- **核心代码**：
  ```cpp
  void bfs(int s){
      memset(dis,0x3f,sizeof dis);
      memset(vis,0,sizeof vis);
      queue<int>q;
      q.push(s),dis[s]=0;
      while(!q.empty()){
          int u=q.front();q.pop();
          if(vis[u])continue;
          vis[u]=1;
          for(auto v:e[u]){
              if(dis[v]>dis[u]+1)
                  dis[v]=dis[u]+1,q.push(v);
          }
      }
  }
  ```

### 最优关键思路与技巧

1. **BFS的正确性**：在边权为1的情况下，BFS的每个点第一次被访问时的距离就是最短路径，因此可以直接使用BFS来求解最短路径。
2. **图的存储**：使用链式前向星或`vector`存图，能够高效地遍历图的邻接点。
3. **多组数据处理**：每次处理新的一组数据时，需要清空图的数据结构，避免数据污染。

### 可拓展之处

- **同类型题**：类似的问题可以扩展到边权不为1的情况，此时可以使用Dijkstra或SPFA等算法。
- **类似算法套路**：在需要求解最短路径的问题中，如果边权为1，优先考虑BFS；如果边权不为1，则考虑Dijkstra或SPFA。

### 推荐题目

1. **P3371 【模板】单源最短路径（弱化版）**：考察Dijkstra算法的实现。
2. **P4779 【模板】单源最短路径（标准版）**：考察Dijkstra算法的优化实现。
3. **P1144 最短路计数**：考察BFS在最短路径问题中的应用。

---
处理用时：40.28秒
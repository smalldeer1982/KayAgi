# 题目信息

# 最后的迷宫

## 题目背景

哈利•波特作为三强争霸赛的第四名选手，历尽艰险闯到了最后一关——迷宫。

现在，迷宫里只剩下哈利和塞德里克了，哈利只有在塞德里克前面拿到奖杯，才能赢得比赛。哈利只要能看到奖杯，就可以用飞来咒拿到它，所以，现在的问题是哈利如何能尽早地看到奖杯。


## 题目描述

哈利的视力非常好，他能从迷宫的一端沿直线看到迷宫的另一端（但他只能看八个方向——东北，东，东南，南，西南……），而且他跑得非常快，跑一步（向上、下、左、右移动一格）只需要 $1\text{s}$。但迷宫是不透光的，而且，要烧掉迷宫的墙也不容易，所以哈利决定绕到一个能够看到奖杯的地方。现在，哈利希望你能帮他确定最短需要多长时间才能拿到奖杯。


## 说明/提示

对于 $30\%$ 的数据，有 $N\times M\le100$；

对于 $60\%$ 的数据，有 $N\times M\le1600$；

对于 $100\%$ 的数据，有 $N\times M\le16384$。

询问数据对数不超过 $512$。


## 样例 #1

### 输入

```
3 4
OXXO
XXOO
XOOO
3 2 2 4
3 3 1 1
0 0 0 0
```

### 输出

```
1
Poor Harry
```

# AI分析结果

### 综合分析

题目要求通过BFS（广度优先搜索）找到哈利从起点到能看到奖杯的最短路径。难点在于如何高效地判断哈利是否能看到奖杯，以及如何处理大范围的数据（N×M ≤ 16384）。大部分题解都采用了BFS，但在数据存储和优化上有不同的处理方式。

### 题解评分与亮点

1. **Alanalan (5星)**
   - **亮点**：使用BFS进行搜索，同时通过预处理奖杯的可见区域来优化判断。代码结构清晰，使用了`vector`来动态管理内存，避免了MLE问题。
   - **核心代码**：
     ```cpp
     void bfs(int sx, int sy) {
         for(int i=0;i<n;++i)
             for(int j=0;j<m;++j)
                 dis[i][j]=INF;
         q.push(node{sx,sy});
         dis[sx][sy]=0;
         while(!q.empty()) {
             int x=q.front().x;
             int y=q.front().y;
             q.pop();
             for(int i=0;i<4;++i) {
                 int xx=x+dx[i];
                 int yy=y+dy[i];
                 if(ok(xx,yy) && dis[xx][yy]==INF) {
                     dis[xx][yy]=dis[x][y]+1;
                     q.push(node{xx,yy});
                 }
             }
         }
     }
     ```

2. **BigRooster (4星)**
   - **亮点**：通过宏定义将二维数组转化为一维数组，解决了内存问题。代码简洁，逻辑清晰，适合初学者理解。
   - **核心代码**：
     ```cpp
     #define a(x,y) aa[(x-1)*m+y]
     #define b(x,y) bb[(x-1)*m+y]
     #define used(x,y) use[(x-1)*m+y]
     ```

3. **LakeArcFox (4星)**
   - **亮点**：使用一维数组存储地图，并通过BFS进行搜索。代码结构清晰，适合理解BFS的基本应用。
   - **核心代码**：
     ```cpp
     int dtos(int x,int y) {
         if(x<1||x>n||y<1||y>m) return 0;
         int k=m*(x-1)+y;
         resu=k;
         if(k<1||k>m*n) return 0;
         return k;
     }
     ```

### 最优关键思路与技巧

1. **预处理奖杯的可见区域**：通过从奖杯位置向八个方向遍历，标记所有能看到奖杯的位置，从而在BFS中快速判断是否到达目标。
2. **一维数组存储**：通过将二维数组转化为一维数组，解决了内存限制问题，适用于大范围数据。
3. **BFS优化**：在BFS中，一旦找到目标即可立即返回，确保找到的是最短路径。

### 可拓展之处

1. **类似题目**：可以扩展到其他迷宫类问题，如寻找最短路径、避开障碍物等。
2. **算法套路**：BFS在解决最短路径问题时非常有效，尤其是在无权图中。

### 推荐题目

1. **P1443 马的遍历**（考察BFS在棋盘上的应用）
2. **P1162 填涂颜色**（考察BFS在矩阵中的应用）
3. **P1131 八数码**（考察BFS在状态空间搜索中的应用）

### 个人心得摘录

- **调试经历**：部分题解提到在调试过程中遇到的内存问题，通过使用一维数组或动态数组解决了MLE问题。
- **踩坑教训**：多组数据输入时，未清空队列或标记数组会导致错误，需特别注意。

### 结论

Alanalan的题解在代码清晰度和优化程度上表现最佳，适合学习和参考。其他题解也提供了不同的解决思路，值得借鉴。

---
处理用时：36.66秒
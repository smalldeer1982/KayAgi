# 题目信息

# [NOIP 2014 提高组] 寻找道路

## 题目背景

NOIP2014 提高组 D2T2

## 题目描述

在有向图 $G$ 中，每条边的长度均为 $1$，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件：

1. 路径上的所有点的出边所指向的点都直接或间接与终点连通。
2. 在满足条件 $1$ 的情况下使路径最短。

注意：图 $G$ 中可能存在重边和自环，题目保证终点没有出边。

请你输出符合条件的路径的长度。

## 说明/提示

**样例 1 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/2p3mke49.png) 

如上图所示，箭头表示有向道路，圆点表示城市。起点 $1$ 与终点 $3$ 不连通，所以满足题目描述的路径不存在，故输出 $-1$。

**样例 2 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/tm2e1lqq.png)
如上图所示，满足条件的路径为 $1\to 3\to 4\to 5$。注意点 $2$ 不能在答案路径中，因为点 $2$ 连了一条边到点 $6$，而点 $6$ 不与终点 $5$ 连通。

**数据范围及约定**

- 对于 $30\%$ 的数据，$0<n\le10$，$0<m\le 20$。
- 对于 $60\%$ 的数据，$0<n\le100$，$0<m\le 2000$。
- 对于 $100\%$ 的数据，$0<n\le 10^4$，$0<m\le 2\times 10^5$，$0<x,y,s,t\le n,x,s\ne t$。

## 样例 #1

### 输入

```
3 2
1 2
2 1
1 3```

### 输出

```
-1```

## 样例 #2

### 输入

```
6 6
1 2
1 3
2 6
2 5  
4 5
3 4
1 5```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心难点在于如何高效地筛选出满足条件的点，并在这些点上进行最短路径搜索。大多数题解都采用了以下思路：

1. **反图遍历**：通过构建反图，从终点出发进行DFS或BFS，标记所有能够到达终点的点。
2. **条件筛选**：遍历每个点，检查其所有出边所指向的点是否都被标记为能够到达终点。如果满足条件，则该点可以出现在路径中。
3. **最短路径搜索**：在筛选后的图上进行BFS，寻找从起点到终点的最短路径。

### 所选高质量题解

#### 1. 作者：WsW_ (4星)
- **关键亮点**：思路清晰，代码简洁，通过反图DFS标记可达点，并在筛选后的图上进行BFS，时间复杂度为O(n+m)。
- **个人心得**：通过删除不满足条件的点，将问题转化为简单的BFS单源最短路问题。
- **核心代码**：
  ```cpp
  void col(int p){
      if(vis[p])return;
      vis[p]=1;
      for(int i=0;i<fedg[p].size();i++){
          int to=fedg[p][i];
          out[to]--;
          if(!out[to])f[to]=1;
          col(to);
      }
  }
  ```

#### 2. 作者：ethanhyz (4星)
- **关键亮点**：通过反向BFS标记可达点，再通过正向BFS筛选满足条件的点，最后进行最短路径搜索，思路清晰且代码可读性强。
- **核心代码**：
  ```cpp
  void bfs1(int cur) {
      queue<int> Q;
      Q.push(cur);
      vis[cur] = 1;
      while (!Q.empty()) {
          int u = Q.front();
          Q.pop();
          for (int i = head2[u]; ~i; i = edge2[i].nxt) {
              int v = edge2[i].to;
              if (!vis[v]) {
                  vis[v] = 1;
                  Q.push(v);
              }
          }
      }
  }
  ```

#### 3. 作者：CaiZi (4星)
- **关键亮点**：通过反图DFS标记可达点，再筛选满足条件的点，最后构建新图进行BFS，思路清晰且代码实现简洁。
- **核心代码**：
  ```cpp
  void dfs(int i){
      for(int j:g[i]){
          if(!x[j]){
              x[j]=true;
              dfs(j);
          }
      }
  }
  ```

### 最优关键思路与技巧

1. **反图遍历**：通过反图从终点出发进行DFS或BFS，能够高效地标记所有能够到达终点的点。
2. **条件筛选**：遍历每个点，检查其所有出边所指向的点是否都被标记为能够到达终点，筛选出满足条件的点。
3. **最短路径搜索**：在筛选后的图上进行BFS，寻找从起点到终点的最短路径。

### 可拓展之处

- **类似问题**：类似的问题可以出现在需要筛选满足特定条件的点或边，再进行最短路径搜索的场景中。例如，某些路径规划问题中可能需要排除某些不符合条件的路径。
- **算法优化**：在筛选条件时，可以考虑使用更高效的数据结构（如并查集）来优化查询效率。

### 推荐题目

1. **P1144 最短路计数**：考察最短路径的计数问题，与本题的最短路径搜索类似。
2. **P1073 最优贸易**：考察在有向图中寻找最优路径的问题，涉及路径筛选与搜索。
3. **P1351 联合权值**：考察图论中的路径筛选与权值计算，与本题的筛选条件类似。

### 个人心得总结

- **调试经历**：在筛选条件时，需要注意边界条件的处理，确保所有点都被正确标记。
- **踩坑教训**：在构建反图时，确保边的方向正确，否则会导致标记错误。
- **顿悟感想**：通过反图遍历和条件筛选，能够将复杂的问题转化为简单的BFS问题，极大地简化了问题的解决过程。

---
处理用时：37.19秒
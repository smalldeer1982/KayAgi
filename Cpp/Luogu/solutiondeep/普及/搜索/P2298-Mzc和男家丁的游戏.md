# 题目信息

# Mzc和男家丁的游戏

## 题目背景

mzc 与 djn 的第二弹。

## 题目描述

mzc 家很有钱（开玩笑），他家有 $n$ 个男家丁（做过上一弹的都知道）。他把她们召集在了一起，他们决定玩捉迷藏。现在 mzc 要来寻找他的男家丁，大家一起来帮忙啊！

由于男家丁数目不多，再加上 mzc 大大的找人水平很好，所以一次只需要找一个男家丁。


## 说明/提示

$3 \leq m,n \leq 2000$。

由于 mzc 大大十分着急，所以他只能等待 $1s$。

## 样例 #1

### 输入

```
5 6
.#..#.
....#.
d.....
#####.
m.....
```

### 输出

```
12```

# AI分析结果

### 综合分析与结论

本题是一个典型的广度优先搜索（BFS）问题，要求在一个迷宫中找到从起点到终点的最短路径。所有题解都采用了BFS算法，但在实现细节、代码可读性、优化程度等方面存在差异。大部分题解使用了STL中的`queue`或手写队列来实现BFS，部分题解还加入了哈希表或标记数组来优化搜索过程。

### 所选题解

#### 1. 作者：_yjh (赞：28)
- **星级：5星**
- **关键亮点**：
  - 使用了STL的`queue`，代码简洁且易于理解。
  - 详细介绍了BFS的基本概念和实现步骤，适合初学者。
  - 提供了BFS的模板代码，方便读者举一反三。
- **个人心得**：
  - 作者强调了BFS的“先到先得”特性，即最早到达的状态一定是最优解，这一思路对理解BFS的核心思想非常有帮助。

```cpp
int bfs(int sx, int sy) {
    q.push((Pos){sx, sy});
    vis[sx][sy] = true;
    while (!q.empty()) {
        x = q.front().x;
        y = q.front().y;
        q.pop();
        if (mp[x][y] == 'm') return dis[x][y];
        for (int i = 0; i < 4; i++) {
            tx = x + dx[i];
            ty = y + dy[i];
            if (tx <= 0 || tx > n || ty <= 0 || ty > m) continue;
            if (mp[tx][ty] == '#' || vis[tx][ty]) continue;
            dis[tx][ty] = dis[x][y] + 1;
            vis[tx][ty] = true;
            q.push((Pos){tx, ty});
        }
    }
    return -1;
}
```

#### 2. 作者：MY（一名蒟蒻） (赞：15)
- **星级：4星**
- **关键亮点**：
  - 使用了手写队列，避免了STL的开销，适合对性能要求较高的场景。
  - 代码结构清晰，注释详细，适合初学者理解。
  - 提供了无解情况的处理，增强了代码的健壮性。

```cpp
void bfs(int x, int y) {
    int head = 1, tail = 1;
    que[tail].x = x; que[tail].y = y; que[tail].step = 0;
    tail++; book[x][y] = 1;
    while (head < tail) {
        for (int i = 0; i < 4; i++) {
            int nx = que[head].x + next[i][0];
            int ny = que[head].y + next[i][1];
            if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
            if (home[nx][ny] != '#' && !book[nx][ny]) {
                book[nx][ny] = 1;
                que[tail].x = nx; que[tail].y = ny;
                que[tail].step = que[head].step + 1;
                tail++;
            }
            if (home[nx][ny] == 'd') { f = true; break; }
        }
        if (f) break;
        head++;
    }
    if (f) printf("%d", que[tail - 1].step);
    else printf("No Way!");
}
```

#### 3. 作者：Sun_Qixuan (赞：6)
- **星级：4星**
- **关键亮点**：
  - 使用了STL的`queue`，代码简洁且易于理解。
  - 通过结构体封装了节点信息，提高了代码的可读性。
  - 提供了详细的注释，方便读者理解代码逻辑。

```cpp
int BFS() {
    queue<Node> v;
    Node temp_cci(sx, sy, 0);
    v.push(temp_cci);
    while (!v.empty()) {
        Node head = v.front(); v.pop();
        if (mp[head.x][head.y] == 'd') {
            cnt = head.s; flag = 1; break;
        }
        for (int i = 0; i < 4; i++) {
            int tx = head.x + next[i][0];
            int ty = head.y + next[i][1];
            if (tx < 0 || ty < 0 || tx >= n || ty >= m || vis[tx][ty] || mp[tx][ty] == '#') continue;
            Node temp(tx, ty, head.s + 1);
            v.push(temp); vis[tx][ty] = 1;
        }
    }
    if (flag) cout << cnt;
    else cout << "No Way!";
}
```

### 最优关键思路与技巧

1. **BFS的核心思想**：通过队列实现“先到先得”，确保最早到达的状态是最优解。
2. **标记数组**：使用`vis`数组标记已访问的节点，避免重复访问。
3. **方向数组**：使用`dx`和`dy`数组简化四个方向的遍历。
4. **无解处理**：在BFS结束后，若未找到终点，输出“No Way!”。

### 可拓展之处

1. **多目标点**：可以扩展为多个目标点的最短路径问题。
2. **权重图**：可以引入权重，使用Dijkstra算法或A*算法进行优化。

### 推荐题目

1. [P1443 马的遍历](https://www.luogu.org/problem/P1443)
2. [P1746 离开中山路](https://www.luogu.org/problem/P1746)
3. [P1747 好奇怪的游戏](https://www.luogu.org/problem/P1747)

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中忽略了无解情况的处理，导致程序无法通过所有测试用例。这提醒我们在编写代码时要考虑所有可能的边界情况。
- **顿悟感想**：通过BFS的“先到先得”特性，作者深刻理解了BFS的最优性，这一思路对其他搜索算法也有启发作用。

---
处理用时：54.53秒
# 题目信息

# 钦定

## 题目描述

小 S 拿到了复赛参赛表，表上的选手是由 $A$ 位神犇与 $B$ 位蒟蒻间隔、循环构成的。

比如 $A=2$，$B=3$ 时，选手 $1,2,6,7,11,12\dots$ 是神犇，选手 $3,4,5,8,9,10,13,14,15\dots$是蒟蒻。

现在小 S 钦定了一些选手是神犇，蒟蒻，但她不能构造出这样的 $A,B$，你能帮帮她吗？

## 说明/提示

对于 $10 \%$ 的数据，$1 \le N,M \le 10$。

对于 $30 \%$ 的数据，$1 \le N,M \le 100$。

对于 $100 \%$ 的数据，$1 \le N,M \le 1000$，$1 \le T \le 10$，$1 \le a_i,b_i \le 2 \times 10 ^ 5$。

## 样例 #1

### 输入

```
10 1
4 8 55 56 57 63 64 67 70 150
87```

### 输出

```
20 2```

# AI分析结果

### 综合分析与结论

本题的核心是通过模运算来枚举周期，并找到满足条件的 \(A\) 和 \(B\)。大多数题解都采用了类似的思路：枚举周期 \(k\)，计算神犇和蒟蒻在该周期内的最大和最小模数，判断是否满足 \(max(a_i \bmod k) < min(b_i \bmod k)\)，并更新答案。虽然思路相似，但不同题解在代码实现、优化程度和可读性上存在差异。

### 所选高分题解

#### 1. 作者：Warriorszx (赞：10)  
**星级：4.5**  
**关键亮点：**  
- 思路清晰，代码结构简洁，易于理解。
- 使用 `pair<int, int>` 来存储答案，便于排序和输出。
- 通过 `ans1` 和 `ans2` 分别记录神犇和蒟蒻的模数最大值和最小值，逻辑清晰。

**核心代码：**
```cpp
for(int i=2;i<=cnt;i++) {
    ans1=0; ans2=2010000000;
    for(int j=1;j<=n;j++) {
        c[j]=a[j]%i;
        if(c[j]==0) ans1=max(ans1,i);
        else ans1=max(c[j],ans1);
    }
    for(int j=1;j<=m;j++) {
        d[j]=b[j]%i;
        if(d[j]==0) ans2=min(ans2,i);
        else ans2=min(ans2,d[j]);
    }
    if(ans1<ans2) {
        q[++tail].x=ans1;
        q[tail].y=i-ans1;
    }
}
```
**个人心得：**  
作者提到“最大值与最小值之和一定等于周期”，这一观察简化了问题，避免了复杂的证明。

#### 2. 作者：wang6w6 (赞：6)  
**星级：4**  
**关键亮点：**  
- 代码结构清晰，注释详细，适合初学者学习。
- 使用 `struct` 存储答案，便于排序和输出。
- 通过 `A` 和 `B` 分别记录神犇和蒟蒻的模数最大值和最小值，逻辑清晰。

**核心代码：**
```cpp
for(ll i=2;i<=(n+m)*10+1;i++) {
    A=0; B=MA;
    for(ll j=1;j<=n;j++) {
        ra[j]=a[j]%i;
        if(ra[j]==0) A=max(A,i);
        else A=max(A,ra[j]);
    }
    for(ll j=1;j<=m;j++) {
        rb[j]=b[j]%i;
        if(rb[j]==0) B=min(B,i);
        else B=min(B,rb[j]);
    }
    if(A<B) {
        len++;
        ans[len].A=A;
        ans[len].B=i-A;
    }
}
```
**个人心得：**  
作者提到“模数为0时，答案应是当前周期”，这一细节处理得当，避免了边界问题。

#### 3. 作者：superLouis (赞：3)  
**星级：4**  
**关键亮点：**  
- 代码简洁，使用 `pair<int, int>` 存储答案，便于排序和输出。
- 通过 `xx` 和 `yy` 分别记录神犇和蒟蒻的模数最大值和最小值，逻辑清晰。
- 使用 `flg` 标记是否有解，避免不必要的输出。

**核心代码：**
```cpp
for(int i=1;i<=(n+m)*10;i++) {
    int xx=-inf, yy=inf;
    for(int j=1;j<=n;j++) xx=max(xx,a[j]%i?a[j]%i:i);
    for(int j=1;j<=m;j++) yy=min(yy,b[j]%i?b[j]%i:i);
    if(xx>=yy) continue;
    flg=true;
    yy=i-xx;
    ans=min(ans,{xx,yy});
}
```
**个人心得：**  
作者提到“提前祝大家新年快乐”，展现了良好的心态和分享精神。

### 最优关键思路与技巧

1. **模运算的应用**：通过模运算来确定神犇和蒟蒻在周期内的位置，简化了问题的复杂度。
2. **枚举周期的范围**：根据题目提示，枚举周期的范围从2到 \((n+m)*10+1\)，确保覆盖所有可能的解。
3. **最大值与最小值的判断**：通过比较神犇的最大模数和蒟蒻的最小模数，判断是否满足条件，避免了复杂的逻辑推导。

### 可拓展之处

- **类似题目**：可以拓展到其他需要枚举周期或模运算的题目，如循环队列、周期性序列等。
- **优化思路**：可以考虑使用更高效的算法或数据结构来优化枚举过程，如二分查找、哈希表等。

### 推荐题目

1. **P1082 同余方程**（考察模运算与扩展欧几里得算法）
2. **P1516 青蛙的约会**（考察模运算与线性同余方程）
3. **P2424 约数和**（考察模运算与数论）

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中遇到的边界问题，如模数为0时的处理，提醒我们在编写代码时要特别注意边界条件。
- **踩坑教训**：一些作者提到在枚举周期时范围设置不当导致超时或错误，提醒我们要仔细阅读题目提示，合理设置枚举范围。
- **顿悟感想**：通过模运算简化问题，发现最大值与最小值之和等于周期，这一观察大大简化了问题的复杂度，展现了数学思维在算法中的重要性。

---
处理用时：55.74秒
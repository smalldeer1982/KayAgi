# 题目信息

# 于是他错误的点名开始了

## 题目背景

XS中学化学竞赛组教练是一个酷爱炉石的人。

他会一边搓炉石一边点名以至于有一天他连续点到了某个同学两次，然后正好被路过的校长发现了然后就是一顿欧拉欧拉欧拉（详情请见已结束比赛 CON900）。

## 题目描述

这之后校长任命你为特派探员，每天记录他的点名。校长会提供化学竞赛学生的人数和名单，而你需要告诉校长他有没有点错名。（为什么不直接不让他玩炉石。）

## 说明/提示

- 对于 $40\%$ 的数据，$n\le 1000$，$m\le 2000$。
- 对于 $70\%$ 的数据，$n\le 10^4$，$m\le 2\times 10^4$。
- 对于 $100\%$ 的数据，$n\le 10^4$，$m≤10^5$。

---

$\text{upd 2022.7.30}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
5  
a
b
c
ad
acd
3
a
a
e
```

### 输出

```
OK
REPEAT
WRONG
```

# AI分析结果

### 综合分析与结论

本题的核心在于高效地存储和查询字符串，判断点名是否正确、重复或错误。题解中主要采用了以下几种思路：

1. **STL的`map`或`set`**：利用`map`或`set`的自动排序和快速查找特性，简化了代码实现，但可能在大数据量下效率不如Trie树。
2. **Trie树（字典树）**：通过树形结构存储字符串，查询效率高，尤其适合处理大量字符串的前缀匹配问题。
3. **二分查找**：先对字符串排序，再通过二分查找进行查询，适合字符串数量较少的情况。
4. **哈希表**：通过哈希函数快速定位字符串，但需要处理哈希冲突。

综合来看，Trie树和STL的`map`/`set`是较为常见且高效的解决方案。Trie树在处理大量字符串时具有明显的优势，而`map`/`set`则更适合代码简洁的场景。

### 所选高星题解

#### 1. 花千树的题解（5星）
- **关键亮点**：使用`map`实现，代码简洁明了，时间复杂度为O(n+m)，适合初学者理解STL的使用。
- **代码核心思想**：通过`map`存储学生名字，标记是否被点到，查询时根据`map`中的值输出相应结果。
```cpp
map<string,int>a;
string s;
int n,m;
int main(){
    cin>>n;
    while(n--){
        cin>>s;
        a[s]=1;
    }
    cin>>m;
    while(m--){
        cin>>s;
        if(a[s]==1){puts("OK");a[s]=2;}
        else if(a[s]==2)puts("REPEAT");
        else puts("WRONG");
    }
    return 0;
}
```

#### 2. ZJH365的题解（4.5星）
- **关键亮点**：详细介绍了Trie树的原理和实现，代码结构清晰，适合深入学习Trie树。
- **代码核心思想**：通过Trie树存储字符串，查询时根据节点状态输出结果。
```cpp
struct node{
    int cnt;
    int son[26];
    bool have;
    node(){
        cnt=0;
        memset(son,false,sizeof son);
        have=false;
    }
}trie[800000];
void insert(char *s){
    int v,len=strlen(s);
    int u=0;
    for(int i=0;i<len;i++){
        v=s[i]-'a';
        if(!trie[u].son[v])
            trie[u].son[v]=++num;
        u=trie[u].son[v];
    }
    trie[u].have=1;
}
```

#### 3. Ciyang的题解（4星）
- **关键亮点**：提出了Lumpy_Trie的优化思路，通过节点存储字符串的公共前缀，减少空间浪费。
- **代码核心思想**：通过节点存储字符串的公共前缀，优化了Trie树的空间利用率。
```cpp
struct Lumpy_Tnode {
    const char *pStr;
    int length, isEnd;
    Lumpy_Tnode *children[26];
    inline Lumpy_Tnode() {
        pStr= 0, length= isEnd= 0, clear(children);
    }
};
```

### 最优关键思路与技巧

1. **Trie树的优化**：通过节点存储字符串的公共前缀，减少空间浪费，提升查询效率。
2. **STL的灵活使用**：`map`和`set`可以简化代码实现，适合处理中小规模数据。
3. **哈希表的应用**：通过哈希函数快速定位字符串，适合处理大规模数据，但需注意哈希冲突。

### 可拓展之处

1. **Trie树的应用**：可以扩展到处理更复杂的字符串匹配问题，如AC自动机、后缀树等。
2. **STL的扩展**：可以结合`unordered_map`等容器，进一步提升查询效率。

### 推荐相似题目

1. **P3375 【模板】KMP字符串匹配**：考察字符串匹配算法。
2. **P3808 【模板】AC自动机（简单版）**：考察AC自动机的实现。
3. **P3879 [TJOI2010]阅读理解**：考察Trie树的应用。

### 个人心得摘录

- **调试经历**：部分题解提到在调试过程中发现`getline`导致WA，改用`cin`后AC，提醒我们在处理字符串输入时要注意细节。
- **踩坑教训**：使用哈希表时，哈希函数的设计和冲突处理是关键，需谨慎选择。
- **顿悟感想**：Trie树在处理大量字符串时具有明显的优势，尤其在需要频繁查询的场景下，值得深入学习。

---
处理用时：49.46秒
# 题目信息

# [USACO3.1] 邮票 Stamps

## 题目描述

给一组 $n$ 枚邮票的面值集合和一个上限 $k$ —— 表示信封上能够贴 $k$ 张邮票。请求出最大的正整数 $m$，满足 $1$ 到 $m$ 的面值都可以用不超过 $k$ 张邮票表示出来。



## 说明/提示

#### 样例输入输出 1 解释

有 $1$ 分和 $3$ 分的邮票；你最多可以贴 $5$ 张邮票。很容易贴出 $1$ 到 $5$ 分的邮资（用 $1$ 分邮票贴就行了），接下来的邮资也不难：


- $6 = 3 + 3$。
- $7 = 3 + 3 + 1$。
- $8 = 3 + 3 + 1 + 1 $。
- $9 = 3 + 3 + 3 $。
- $10 = 3 + 3 + 3 + 1 $。
- $11 = 3 + 3 + 3 + 1 + 1 $。
- $12 = 3 + 3 + 3 + 3 $。
- $13 = 3 + 3 + 3 + 3 + 1$。


然而，使用 $5$ 枚 $1$ 分或者 $3$ 分的邮票根本不可能贴出 $14$ 分的邮资。因此，答案为 $13$。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq k \leq 200$，$1 \leq n \leq 50$，$1 \leq a_i \leq 10^4$。

#### 说明

题目翻译来自 NOCOW。

## 样例 #1

### 输入

```
5 2
1 3```

### 输出

```
13```

# AI分析结果

### 综合分析与结论

本题的核心是求解在给定邮票面值和最多使用邮票数量的限制下，能够连续表示的最大邮资。大多数题解采用了动态规划（DP）的思路，类似于完全背包问题，通过维护一个数组 `dp[i]` 表示构成面值 `i` 所需的最少邮票数，并在不超过 `k` 张邮票的条件下，逐步更新 `dp` 数组，直到无法继续扩展。

#### 关键思路与技巧：
1. **动态规划（DP）**：大多数题解使用 DP 来解决问题，状态转移方程为 `dp[i] = min(dp[i], dp[i - a[j]] + 1)`，其中 `a[j]` 是邮票的面值。
2. **初始化与边界处理**：`dp[0] = 0` 表示构成面值 0 不需要邮票，其他 `dp[i]` 初始化为一个较大的值（如 `inf`），表示尚未找到解。
3. **优化与剪枝**：部分题解通过排序邮票面值、限制循环范围（如 `maxn * k`）来优化性能，避免不必要的计算。
4. **BFS 解法**：少数题解使用 BFS 来模拟邮票的组合，虽然思路新颖，但效率较低，不推荐在大数据量下使用。

#### 可拓展之处：
- **类似问题**：完全背包问题、硬币找零问题等都可以使用类似的 DP 思路解决。
- **优化技巧**：在实际应用中，可以通过预处理、剪枝、记忆化搜索等手段进一步优化 DP 算法的性能。

### 所选高星题解

#### 1. 作者：「QQ红包」 (5星)
**关键亮点**：
- 使用完全背包的思路，代码简洁清晰。
- 通过 `f[i] = min(f[i], f[i - a] + 1)` 的状态转移方程，高效地更新 DP 数组。
- 通过 `f[i] == 2333` 判断无法继续扩展，逻辑清晰。

**核心代码**：
```cpp
for (i = 1; i <= n; i++) {
    scanf("%d", &a);
    for (j = a; j <= 2000000; j++)
        if (f[j - a] + 1 <= k)
            f[j] = min(f[j], f[j - a] + 1);
}
```
**个人心得**：无。

#### 2. 作者：Priori_Incantatem (4星)
**关键亮点**：
- 使用 DP 解决，状态转移方程清晰。
- 通过 `f[i] = min(f[i], f[i - a[j]] + 1)` 更新 DP 数组，并在 `f[i] > k` 时停止扩展。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
for (int i = 1; i <= Maxm; ++i) {
    f[i] = inf;
    for (int j = 1; j <= n; ++j)
        if (i - a[j] >= 0) f[i] = min(f[i], f[i - a[j]] + 1);
    if (f[i] == inf || f[i] > m) break;
    ans++;
}
```
**个人心得**：无。

#### 3. 作者：Weierstras (4星)
**关键亮点**：
- 使用 DP 解决，状态转移方程清晰。
- 通过 `mx = c[i] * k` 限制循环范围，优化性能。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    mx = c[i] * k;
    for (int j = c[i]; j <= mx; j++)
        if (vis[j - c[i]] < min(k, vis[j] - 1))
            vis[j] = vis[j - c[i]] + 1;
}
```
**个人心得**：无。

### 推荐相似题目
1. **P1048 采药**：完全背包问题的经典题目，考察如何在一定容量下最大化价值。
2. **P1616 疯狂的采药**：完全背包问题的变种，考察无限物品下的最大价值。
3. **P1064 金明的预算方案**：背包问题的变种，考察如何在有限预算下选择最优组合。

### 总结
本题的核心在于动态规划的应用，通过维护一个 DP 数组来记录构成每个面值所需的最少邮票数，并在不超过 `k` 张邮票的条件下逐步扩展。大多数题解都采用了这一思路，代码简洁且高效。对于类似的问题，如完全背包、硬币找零等，都可以借鉴这一思路进行解决。

---
处理用时：41.05秒
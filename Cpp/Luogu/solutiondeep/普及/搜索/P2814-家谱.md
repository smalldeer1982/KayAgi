# 题目信息

# 家谱

## 题目背景

现代的人对于本家族血统越来越感兴趣。


## 题目描述

给出充足的父子关系，请你编写程序找到某个人的最早的祖先。


## 说明/提示

规定每个人的名字都有且只有 $6$ 个字符，而且首字母大写，且没有任意两个人的名字相同。最多可能有 $10^3$ 组父子关系，总人数最多可能达到 $5 \times 10^4$ 人，家谱中的记载不超过 $30$ 代。

## 样例 #1

### 输入

```
#George
+Rodney
#Arthur
+Gareth
+Walter
#Gareth
+Edward
?Edward
?Walter
?Rodney
?Arthur
$```

### 输出

```
Edward Arthur
Walter Arthur
Rodney George
Arthur Arthur```

# AI分析结果

### 综合分析与结论

由于目前没有提供具体的题解，我将基于题目要求和常见解法进行分析和总结。

#### 关键思路与技巧
1. **数据结构选择**：使用`unordered_map`或`map`来存储父子关系，键为子节点，值为父节点。这种结构便于快速查找某个人的祖先。
2. **算法设计**：通过递归或迭代的方式，从目标节点开始，沿着父节点链向上查找，直到找到最早的祖先（即没有父节点的节点）。
3. **优化点**：可以通过路径压缩或记忆化技术来优化查找过程，减少重复查找的开销。

#### 可拓展之处
1. **路径压缩**：类似于并查集中的路径压缩，可以在查找过程中将路径上的所有节点直接指向根节点，从而加快后续查找速度。
2. **多代关系处理**：如果需要处理更复杂的家族关系（如兄弟、堂兄弟等），可以考虑使用图结构来表示家族关系，并使用广度优先搜索（BFS）或深度优先搜索（DFS）来查找关系。

#### 推荐题目
1. **P1551 亲戚**：考察并查集的基本应用，适合练习家族关系的处理。
2. **P3379 【模板】最近公共祖先（LCA）**：考察树结构的最近公共祖先问题，适合练习树结构的处理。
3. **P3916 图的遍历**：考察图的遍历算法，适合练习复杂关系的处理。

### 通用建议与扩展思路

1. **数据结构选择**：在处理家族关系时，选择合适的数据结构是关键。`unordered_map`或`map`适合存储父子关系，而图结构适合处理更复杂的关系。
2. **算法优化**：在查找过程中，使用路径压缩或记忆化技术可以显著提高查找效率。
3. **代码可读性**：在编写代码时，注意命名规范和代码结构，确保代码易于理解和维护。

### 核心代码片段

```cpp
#include <iostream>
#include <unordered_map>
#include <string>

std::unordered_map<std::string, std::string> parent;

std::string findEarliestAncestor(const std::string& name) {
    std::string current = name;
    while (parent.find(current) != parent.end()) {
        current = parent[current];
    }
    return current;
}

int main() {
    // 读取输入并构建父子关系
    std::string line;
    while (std::getline(std::cin, line)) {
        if (line[0] == '#') {
            std::string father = line.substr(1);
            parent[father] = ""; // 根节点没有父节点
        } else if (line[0] == '+') {
            std::string child = line.substr(1);
            std::string father;
            std::getline(std::cin, father);
            parent[child] = father.substr(1);
        } else if (line[0] == '?') {
            std::string name = line.substr(1);
            std::cout << name << " " << findEarliestAncestor(name) << std::endl;
        } else if (line[0] == '$') {
            break;
        }
    }
    return 0;
}
```

#### 核心实现思想
1. **构建父子关系**：通过读取输入，将父子关系存储在`parent`映射中。
2. **查找最早祖先**：从目标节点开始，沿着父节点链向上查找，直到找到没有父节点的节点，即为最早的祖先。

通过以上分析和代码片段，可以有效地解决该问题，并且代码具有良好的可读性和扩展性。

---
处理用时：33.44秒
# 题目信息

# [USACO15OPEN] Bessie Goes Moo S

## 题目描述

Farmer John 和奶牛 Bessie 喜欢在空闲时间互相出数学谜题。

上一次 FJ 给 Bessie 出的谜题非常难，她没能解出来。

现在，她想通过给 FJ 出一个有挑战性的谜题来报复他。

Bessie 给 FJ 的表达式是 $(B+E+S+S+I+E)(G+O+E+S)(M+O+O)$，其中包含七个变量 $B,E,S,I,G,O,M$（"$O$" 是一个变量，不是零）。对于每个变量，她给 FJ 提供了一个最多包含 500 个整数值的列表，表示该变量可能取的值。

她要求 FJ 计算有多少种不同的方式可以为这些变量赋值，使得整个表达式的值是 7 的倍数。

注意，这个问题的答案可能太大，无法用 32 位整数表示，因此你可能需要使用 64 位整数（例如，C 或 C++ 中的 "long long"）。

## 说明/提示

两种可能的赋值方式是：

$(B,E,S,I,G,O,M) = (2, 5, 7, 9, 1, 16, 19)$ -> 51,765

$(B,E,S,I,G,O,B) = (2, 5, 7, 9, 1, 16, 2)$ -> 34,510

## 样例 #1

### 输入

```
10
B 2
E 5
S 7
I 10
O 16
M 19
B 3
G 1
I 9
M 2```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

该题的核心思路是利用模运算的性质，将每个变量的取值模7后，简化问题。由于模7后每个变量只有7种可能的取值，因此可以通过暴力枚举所有可能的组合，计算表达式的值是否为7的倍数，并统计满足条件的方案数。题解中大多采用了DFS或直接嵌套循环的方式枚举所有可能的组合，并通过乘法原理计算方案数。

### 所选高星题解

#### 1. 作者：Expecto (★★★★★)
**关键亮点**：
- 代码简洁，逻辑清晰，直接通过DFS枚举所有可能的组合。
- 使用`g`数组记录每个变量模7后的取值次数，减少了存储空间。
- 通过`dfs`函数递归枚举，并在递归结束时判断表达式是否为7的倍数，计算方案数。

**核心代码**：
```cpp
void dfs(int now){
    if (now==7){
        long long sum=1ll*(x[0]+x[1]+x[2]+x[2]+x[3]+x[1])*(x[4]+x[5]+x[1]+x[2])*(x[6]+x[5]*2);
        if (sum%7==0){
            long long tmp=1;
            for (int i=0;i<7;i++)
                tmp*=g[i][x[i]];
            ans+=tmp;
        }
        return ;
    }
    for (int i=0;i<7;i++){
        if (!g[now][i]) continue;
        x[now]=i;
        dfs(now+1);
    }
}
```

#### 2. 作者：Ofnoname (★★★★☆)
**关键亮点**：
- 使用`DFS`进行枚举，代码结构清晰。
- 通过`f`数组记录当前变量的取值，`a`数组记录每个变量模7后的取值次数。
- 在`DFS`结束时判断表达式是否为7的倍数，并累加方案数。

**核心代码**：
```cpp
void DFS(int x)
{
	if (x == 7)
	{
		long sum = (f[0]+(f[1]+f[2])*2+f[3]) * (f[1]+f[2]+f[4]+f[5]) * (f[6]+f[5]*2);
		if (!(sum % 7))
		{
			sum = 1;
			for (int i = 0; i < 7; i++)
				sum *= a[i][f[i]];
			ans += sum;
		}return;
	}
	for (int i = 0; i < 7; i++)
		if (a[x][i]) f[x] = i, DFS(x+1);
}
```

#### 3. 作者：Wangchenxin (★★★★☆)
**关键亮点**：
- 直接使用嵌套循环枚举所有可能的组合，代码简洁。
- 通过`hsh`数组记录每个变量模7后的取值次数。
- 在循环中判断表达式是否为7的倍数，并累加方案数。

**核心代码**：
```cpp
for(int B=0;B<7;B++)
for(int E=0;E<7;E++)
for(int S=0;S<7;S++)
for(int I=0;I<7;I++)
for(int G=0;G<7;G++)
for(int O=0;O<7;O++)
for(int M=0;M<7;M++) 
  if (((B+E+S+S+I+E)*(G+O+E+S)*(M+O+O))%7==0){
      ans+=hsh['B'][B]*hsh['E'][E]*hsh['S'][S]*hsh['I'][I]*hsh['G'][G]*hsh['O'][O]*hsh['M'][M];
  }
```

### 最优关键思路与技巧

1. **模运算简化问题**：通过将每个变量的取值模7，将问题转化为有限的状态，大大减少了计算量。
2. **DFS与嵌套循环枚举**：通过DFS或嵌套循环枚举所有可能的组合，结合乘法原理计算方案数。
3. **数组记录取值次数**：使用数组记录每个变量模7后的取值次数，方便后续计算方案数。

### 可拓展之处

该题的思路可以推广到类似的模运算问题，尤其是当变量的取值范围较大时，通过模运算可以将问题转化为有限的状态，从而简化计算。类似的问题可以考察多个变量的组合，要求满足某种模运算条件。

### 推荐题目

1. **P1008 三连击**：考察数字的组合与模运算。
2. **P1028 数的计算**：考察递归与组合问题。
3. **P1036 选数**：考察DFS与组合问题。

### 个人心得摘录

- **Expecto**：通过DFS枚举所有可能的组合，代码简洁且高效。
- **Ofnoname**：使用DFS进行枚举，代码结构清晰，易于理解。
- **Wangchenxin**：直接使用嵌套循环枚举，代码简洁，适合初学者理解。

---
处理用时：36.88秒
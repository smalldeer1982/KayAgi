# 题目信息

# [JLOI2012] 树

## 题目描述

在这个问题中，给定一个值 $s$ 和一棵树。在树的每个节点有一个权值，第 $i$ 个点的权值为 $a_i$，问有多少条路径的节点权值总和为 $s$。路径中节点的深度必须是升序的。假设节点 $1$ 是根节点，根的深度是 $0$，它的儿子节点的深度为 $1$。路径不必一定从根节点开始。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq a_i, s \leq 10^3$。

## 样例 #1

### 输入

```
3 3
1 2 3
1 2
1 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题要求统计树中权值和为 `s` 的路径数量，路径必须满足深度递增。题解中主要采用了以下几种思路：

1. **暴力DFS**：从每个节点出发，向下搜索路径，剪枝优化。虽然时间复杂度较高，但由于数据范围较小，能够通过。
2. **树上前缀和**：利用前缀和和 `set` 或 `lower_bound` 来快速查找符合条件的路径，时间复杂度较低。
3. **倍增法**：利用倍增的思想，预处理每个节点向上跳 `2^k` 步的路径和，时间复杂度为 `O(n log n)`。
4. **双端队列**：通过维护一个队列，动态调整路径的起点和终点，确保路径和不超过 `s`。

总体来看，**树上前缀和**和**倍增法**是最优的解法，时间复杂度较低且思路清晰。暴力DFS虽然简单，但在数据范围较大的情况下会超时。

### 所选高星题解

#### 1. **zht467 (树上前缀和)**
- **星级**: 5
- **关键亮点**: 使用 `set` 维护前缀和，通过 `lower_bound` 快速查找符合条件的路径，时间复杂度为 `O(n log n)`，思路清晰且代码简洁。
- **核心代码**:
  ```cpp
  void dfs(int u) {
      sum[u] = sum[f[u]] + a[u];
      S.insert(sum[u]);
      if (S.count(sum[u] - s)) ans++;
      for (int i = head[u]; i ^ -1; i = next[i]) dfs(to[i]);
      S.erase(sum[u]);
  }
  ```
- **个人心得**: 作者提到“因为每个点权都是正整数，所以 `set` 中没有重复元素”，这一点确保了算法的正确性。

#### 2. **Sky_crystal (倍增法)**
- **星级**: 5
- **关键亮点**: 利用倍增的思想，预处理每个节点向上跳 `2^k` 步的路径和，时间复杂度为 `O(n log n)`，思路清晰且代码简洁。
- **核心代码**:
  ```cpp
  for (int i = 1; i <= 17; i++) {
      for (int j = 1; j <= n; j++) {
          fa[j][i] = fa[fa[j][i - 1]][i - 1];
          len[j][i] = len[j][i - 1] + len[fa[j][i - 1]][i - 1];
      }
  }
  ```
- **个人心得**: 作者提到“相信写过倍增求LCA的人都能看懂这个代码”，说明该解法与倍增求LCA的思路类似，易于理解。

#### 3. **kkxhh (双端队列)**
- **星级**: 4
- **关键亮点**: 使用双端队列动态调整路径的起点和终点，确保路径和不超过 `s`，思路新颖且代码简洁。
- **核心代码**:
  ```cpp
  void dfs(int x) {
      q[++r] = v[x]; qsum += v[x];
      while (qsum > s) qsum -= q[l++];
      if (qsum == s) ans++;
      for (int j = 0; j < (int)son[x].size(); j++) dfs(son[x][j]);
      qsum -= q[r--];
      while (l && qsum + q[l - 1] <= s) qsum += q[--l];
  }
  ```
- **个人心得**: 作者提到“如果一条路径的大小超过了题目的 `s`，那么这条路径无论怎么延伸都不能为答案做出贡献”，这一点确保了算法的正确性。

### 最优关键思路与技巧

1. **树上前缀和**：通过维护前缀和，利用 `set` 或 `lower_bound` 快速查找符合条件的路径，时间复杂度较低。
2. **倍增法**：利用倍增的思想，预处理每个节点向上跳 `2^k` 步的路径和，时间复杂度为 `O(n log n)`，适用于路径查询问题。
3. **双端队列**：通过维护一个队列，动态调整路径的起点和终点，确保路径和不超过 `s`，思路新颖且代码简洁。

### 可拓展之处

1. **树上前缀和**：可以扩展到其他树上的路径查询问题，如路径和的最大值、最小值等。
2. **倍增法**：可以扩展到其他树上路径查询问题，如路径的LCA、路径的长度等。
3. **双端队列**：可以扩展到其他动态调整路径的问题，如滑动窗口、动态规划等。

### 推荐相似题目

1. **P3379 【模板】最近公共祖先（LCA）**: 考察倍增法的应用。
2. **P2634 [国家集训队]聪聪可可**: 考察树上前缀和的应用。
3. **P3178 [HAOI2015]树上操作**: 考察树上路径查询和修改的应用。

### 个人心得总结

- **调试经历**: 许多作者在调试过程中发现数组下标错误或剪枝不充分，导致代码无法通过，提醒我们在编写代码时要特别注意细节。
- **顿悟感想**: 一些作者在思考过程中发现“正难则反”的思路，即从下往上搜索路径，避免了复杂的DFS剪枝，这种思维方式值得借鉴。

---
处理用时：44.91秒
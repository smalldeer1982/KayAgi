# 题目信息

# 路障

## 题目描述

B 君站在一个 $n\times n$ 的棋盘上。最开始，B君站在 $(1,1)$ 这个点，他要走到 $(n,n)$ 这个点。

B 君每秒可以向上下左右的某个方向移动一格，但是很不妙，C 君打算阻止 B 君的计划。

**每秒结束的时刻**，C 君 会在 $(x,y)$ 上摆一个路障。B 君不能走在路障上。

B 君拿到了 C 君准备在哪些点放置路障。所以现在你需要判断，B 君能否成功走到 $(n,n)$。

**保证数据足够弱：也就是说，无需考虑“走到某处然后被一个路障砸死”的情况，因为答案不会出现此类情况。**

## 说明/提示

样例解释：

以下 0 表示能走，x 表示不能走，B 表示 B 君现在的位置。从左往右表示时间。

```
Case 1:
0 0    0 0    0 B  (已经走到了)
B 0    x B    x 0
```
```
Case 2:
0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0
0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0
0 0 0 0 0    0 0 x 0 0    0 0 x 0 0    0 0 x 0 0
0 0 0 0 0    0 0 0 0 0    0 0 x 0 0    0 0 x 0 0
B 0 0 0 0    0 B 0 0 0    0 0 B 0 0    0 0 x B 0 ......(B君可以走到终点)
```

数据规模：

防止骗分，数据保证全部手造。

对于 $20\%$ 的数据，有 $n\le3$。

对于 $60\%$ 的数据，有 $n\le500$。

对于 $100\%$ 的数据，有 $n\le1000$。

对于 $100\%$ 的数据，有 $T\le10$。

## 样例 #1

### 输入

```
2

2
1 1
2 2

5
3 3
3 2
3 1
1 2
1 3
1 4
1 5
2 2```

### 输出

```
Yes
Yes```

# AI分析结果

### 综合分析与结论

该题目要求判断在每秒放置路障的情况下，B君能否从起点到达终点。大多数题解采用了BFS（广度优先搜索）作为核心算法，结合时间管理和路障放置的处理。部分题解还引入了DP（动态规划）或曼哈顿距离优化，进一步提升了效率。

#### 关键思路与技巧：
1. **BFS+时间管理**：在BFS的基础上，通过记录时间来判断路障是否会影响路径选择。
2. **路障处理**：在每一秒结束后放置路障，确保B君不会走到被路障阻挡的位置。
3. **优化策略**：部分题解通过曼哈顿距离或DP优化，减少不必要的搜索。
4. **特判处理**：对特殊情况（如n=1）进行特判，避免不必要的计算。

#### 可拓展之处：
- **类似问题**：类似的问题包括在动态障碍物环境中寻找最短路径，如“迷宫中的机器人”或“动态障碍物避障”。
- **算法套路**：BFS+时间管理的组合可以应用于其他动态环境下的路径搜索问题。

### 推荐题目
1. **P1443 马的遍历**：考察BFS在棋盘上的应用。
2. **P1162 填涂颜色**：考察BFS在矩阵中的应用。
3. **P1141 01迷宫**：考察BFS在动态环境中的应用。

### 题解评分与亮点

#### 1. 作者：Invisible_Blade (5星)
- **关键亮点**：使用手写队列优化BFS性能，结合时间管理处理路障，代码清晰且高效。
- **核心代码**：
  ```cpp
  void bfs(){
      int t=1,head=1,tail=2;
      que[head].x=1,que[head].y=1,pd[1][1]=1;
      do{
          for(int i=0;i<4;i++){
              nx=que[head].x+dx[i];
              ny=que[head].y+dy[i];
              if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&pd[nx][ny]==0){
                  que[tail].x=nx;
                  que[tail].y=ny;
                  tail++;
                  pd[nx][ny]=1;
              }
          }
          pd[no[t].x][no[t].y]=1;
          t++;
          head++;
      }while(head<tail);
      for(int i=tail;i>=1;i--){
          if(que[i].x==n&&que[i].y==n){
              printf("Yes\n");
              return;
          }
      }
      printf("No\n");
      return;
  }
  ```
- **个人心得**：强调了手写队列的优势，避免了STL队列的性能开销。

#### 2. 作者：Starlight237 (4星)
- **关键亮点**：使用DP代替BFS，通过曼哈顿距离优化路径搜索，思路新颖且高效。
- **核心代码**：
  ```cpp
  for(reg int i=1;i<=n;++i)
      for(reg int j=1;j<=n;++j)
          dp[i][j]|=(dp[i-1][j]||dp[i][j-1])&&!dag[i][j];
  ```
- **个人心得**：通过曼哈顿距离简化了路径搜索，减少了不必要的计算。

#### 3. 作者：ZJH365 (4星)
- **关键亮点**：使用双队列优化BFS，确保每一层的搜索完整且高效。
- **核心代码**：
  ```cpp
  while(!q.empty()){
      mm++;
      while(!q.empty()){
          t now=q.front();
          q.pop();
          for(int i=1;i<=4;i++){
              int tx=now.x+fx[i],ty=now.y+fy[i];
              if(pd(tx,ty)&&vis[tx][ty]==0){
                  pus[++qq][0]=tx;pus[qq][1]=ty;
                  vis[tx][ty]=1;
                  if(tx==n&&ty==n)return 1;
              }
          }
      }
      for(int i=1;i<=qq;i++){
          q.push((t){pus[i][0],pus[i][1]});
      }
      qq=0;
      vis[a[mm][0]][a[mm][1]]=2;
  }
  ```
- **个人心得**：通过双队列确保每一层的搜索完整，避免了重复计算。

### 通用建议与扩展思路
如果所有题解均未达到4星，建议：
- **优化BFS**：考虑使用双队列或手写队列提升性能。
- **引入DP**：通过曼哈顿距离或DP优化路径搜索。
- **特判处理**：对特殊情况（如n=1）进行特判，避免不必要的计算。

通过这些优化，可以显著提升代码的效率和可读性。

---
处理用时：50.95秒
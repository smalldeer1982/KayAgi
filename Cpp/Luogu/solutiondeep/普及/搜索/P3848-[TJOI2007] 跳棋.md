# 题目信息

# [TJOI2007] 跳棋

## 题目背景

在一个n×n的棋盘上，布满了0和1，如图（a）所示（n=7），为叙述方便，将0用字母表示，如图（b）。

![](https://cdn.luogu.com.cn/upload/pic/6077.png)


## 题目描述

跳棋规则：

（1）从某个0格出发，可以向上，下，左，右4个方向连续越过若干个（至少1个）

1格而跳入下一个0格。如图（b）中从A出发，可跳到B，或者到E，但不能直接到K。在跳到B之后还可以继续跳到F;在跳到E之后可继续跳到F或K。直到不能再跳为止。

（2）每个0格只能到达一次，给出的起始点不能再到达，也不能越过。

跳过的距离为跳过1格个数加1，如从A到B，跳过距离为3，从B到F，跳过距离为2。

问   题： 当棋盘和起始点给出之后，问最远能跳的距离是多少？

如上图（b）中，从A出发，可跳过的路线不止一条，其中一条为：

A － B － F － L － K － E  （可能不唯一）

3    2    3    3     3

它的距离为14。


## 说明/提示

$\text{upd 2022.7.27}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
4  3  2
1  0  1  0 
1  1  1  1
0  0  1  0
1  1  0  1```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

该题目要求从给定的起点出发，按照跳棋规则在棋盘上跳跃，求最远能跳的距离。由于棋盘大小 $n \leq 100$，大多数题解采用了深度优先搜索（DFS）的算法，通过枚举四个方向并模拟跳跃过程来求解。题解的主要难点在于如何正确处理跳跃的边界条件、避免重复访问以及计算跳跃距离。

### 题解评分与关键亮点

1. **作者：犇犇犇犇 (★★★★☆)**
   - **关键亮点**：使用了DFS算法，通过`while`循环模拟跳跃过程，代码简洁且易于理解。特别处理了相邻两个0不能跳跃的情况，确保了算法的正确性。
   - **个人心得**：作者提到“这道题稍微难一点的地方就是$dfs$的时候从$0$开始不碰到下一个0或者边界**永不停止**”，强调了跳跃过程中边界条件的处理。
   - **核心代码**：
     ```cpp
     while(tx+dx[i]>0 && tx+dx[i]<=n && ty+dy[i]>0 && ty+dy[i]<=n) {
         tx+=dx[i];
         ty+=dy[i];
         s++;
         if(m[tx][ty]==0) break;
     }
     ```

2. **作者：JJA_ (★★★★☆)**
   - **关键亮点**：同样使用DFS，但通过`while`循环处理跳跃过程，并使用了`chkmax`宏来更新最大跳跃距离。代码结构清晰，逻辑严谨。
   - **个人心得**：作者提到“题解被 hack 了,于是修复了亿些问题，包括未回溯以及判断分支语句优先级”，强调了回溯和边界条件的重要性。
   - **核心代码**：
     ```cpp
     while(xx>0&&yy>0&&xx<=n&&yy<=n) {
         if(mapp[xx][yy]==1) {
             xx+=_x[i],yy+=_y[i],sum++;
         } else {
             if(sum!=1&&vis[xx][yy]!=1) {
                 dfs(xx,yy,t+sum);
             }
             break;
         }
     }
     ```

3. **作者：zilingheimei (★★★★☆)**
   - **关键亮点**：使用DFS算法，通过`while`循环模拟跳跃过程，并特别处理了相邻两个0不能跳跃的情况。代码简洁且易于理解。
   - **个人心得**：作者提到“因为这是跳棋，也就是从第一个0开始只要还是1就一直跳下去”，强调了跳跃过程的连续性。
   - **核心代码**：
     ```cpp
     while(nx>=1&&nx<=n&&ny>=1&&ny<=n&&a[nx][ny]==1) {
         nx+=dx[i];
         ny+=dy[i];
     }
     ```

### 最优关键思路与技巧

1. **跳跃模拟**：通过`while`循环模拟跳跃过程，直到遇到下一个0或边界，确保跳跃的连续性。
2. **边界条件处理**：在跳跃过程中，始终检查是否越界，确保算法的正确性。
3. **回溯机制**：使用`vis`数组记录访问过的点，并在DFS结束后回溯，避免重复访问。
4. **跳跃距离计算**：通过计算跳跃前后的坐标差，累加跳跃距离。

### 可拓展之处

该题解的核心思想可以应用于其他类似的搜索问题，如迷宫问题、路径规划等。通过DFS或BFS算法，结合边界条件和回溯机制，可以解决许多类似的搜索问题。

### 推荐题目

1. **P1560 [USACO5.2]蜗牛的旅行Snail Trails**：考察DFS在迷宫中的应用。
2. **P1433 吃奶酪**：考察DFS在路径规划中的应用。
3. **P1120 小书童的作业**：考察DFS在棋盘类问题中的应用。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中遇到边界条件处理不当的问题，强调了边界条件的重要性。
- **踩坑教训**：回溯机制和跳跃距离计算是常见的坑点，需要特别注意。
- **顿悟感想**：通过模拟跳跃过程，可以更直观地理解问题的本质，从而设计出更高效的算法。

---
处理用时：41.04秒
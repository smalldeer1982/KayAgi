# 题目信息

# [JLOI2009] 二叉树问题

## 题目描述

如下图所示的一棵二叉树的深度、宽度及结点间距离分别为：

- 深度：$4$
- 宽度：$4$
- 结点 8 和 6 之间的距离：$8$
- 结点 7 和 6 之间的距离：$3$

其中宽度表示二叉树上同一层最多的结点个数，节点 $u, v$ 之间的距离表示从 $u$ 到 $v$ 的最短有向路径上向根节点的边数的两倍加上向叶节点的边数。

![](https://cdn.luogu.com.cn/upload/pic/6843.png)

给定一颗以 1 号结点为根的二叉树，请求出其深度、宽度和两个指定节点 $x, y$ 之间的距离。


## 说明/提示

对于全部的测试点，保证 $1 \leq u, v, x, y \leq n \leq 100$，且给出的是一棵树。保证 $u$ 是 $v$ 的父结点。

## 样例 #1

### 输入

```
10                                
1 2                            
1 3                            
2 4
2 5
3 6
3 7
5 8
5 9
6 10
8 6
```

### 输出

```
4
4
8```

# AI分析结果

### 综合分析与结论

本题主要考察二叉树的深度、宽度以及节点间距离的计算。题解中涉及的算法包括LCA（最近公共祖先）、DFS、BFS、Floyd算法、树链剖分等。大多数题解通过DFS或BFS计算深度和宽度，而节点间距离则通过LCA或最短路径算法求解。部分题解使用了较为复杂的算法（如Floyd、树链剖分）来解决问题，虽然这些方法在理论上可行，但对于本题的规模（n ≤ 100）来说，简单的DFS或LCA已经足够高效。

### 所选高星题解

#### 1. 作者：dessert (赞：40)  
**星级：★★★★★**  
**关键亮点：**  
- 使用LCA（最近公共祖先）算法，思路清晰且代码简洁。
- 通过DFS预处理深度和父节点信息，LCA的实现简单易懂。
- 代码可读性高，适合初学者理解和学习。

**个人心得：**  
作者提到“自认为比题解的lca简单一点”，确实通过简单的DFS和LCA实现，代码更加简洁易懂。

**核心代码：**
```cpp
int lca(int x, int y) {
    a[x].data = 1;
    while (a[x].father != 0) {
        x = a[x].father;
        a[x].data = 1;
    }
    while (a[y].data != 1) {
        y = a[y].father;
    }
    return y;
}
```
**实现思想：**  
通过DFS预处理每个节点的父节点信息，然后通过LCA算法找到两个节点的最近公共祖先，进而计算节点间距离。

#### 2. 作者：starwolfy_rika (赞：19)  
**星级：★★★★☆**  
**关键亮点：**  
- 使用暴力LCA算法，代码简洁且易于理解。
- 通过DFS预处理深度信息，计算深度和宽度。
- 适合小规模数据，代码实现简单。

**核心代码：**
```cpp
int getlca(int x, int y) {
    while (x != y) {
        if (de[x] >= de[y]) x = fa[x];
        else y = fa[y];
    }
    return x;
}
```
**实现思想：**  
通过DFS预处理深度信息，然后通过暴力LCA算法找到最近公共祖先，计算节点间距离。

#### 3. 作者：TEoS (赞：7)  
**星级：★★★★☆**  
**关键亮点：**  
- 使用倍增LCA算法，适合大规模数据。
- 通过BFS预处理深度和父节点信息，代码结构清晰。
- 详细注释，适合进阶学习。

**核心代码：**
```cpp
int LCA(int x, int y) {
    if (d[x] > d[y]) swap(x, y);
    for (int i = t; i >= 0; i--)
        if (d[f[y][i]] >= d[x]) y = f[y][i];
    if (x == y) return x;
    for (int i = t; i >= 0; i--)
        if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
    return f[x][0];
}
```
**实现思想：**  
通过BFS预处理深度和父节点信息，使用倍增LCA算法找到最近公共祖先，计算节点间距离。

### 最优关键思路与技巧

1. **LCA算法**：无论是暴力LCA还是倍增LCA，都是解决节点间距离问题的核心。暴力LCA适合小规模数据，倍增LCA适合大规模数据。
2. **DFS/BFS预处理**：通过DFS或BFS预处理深度和父节点信息，是计算深度、宽度和LCA的基础。
3. **代码简洁与可读性**：对于初学者来说，简洁的代码和清晰的思路比复杂的优化更为重要。

### 可拓展之处

1. **树链剖分**：对于更大规模的数据，树链剖分可以进一步优化LCA的查询效率。
2. **Tarjan算法**：离线LCA查询可以通过Tarjan算法实现，适合需要多次查询的场景。

### 推荐相似题目

1. **P3379 【模板】最近公共祖先（LCA）**  
   题目链接：[https://www.luogu.com.cn/problem/P3379](https://www.luogu.com.cn/problem/P3379)
   
2. **P1395 树的直径**  
   题目链接：[https://www.luogu.com.cn/problem/P1395](https://www.luogu.com.cn/problem/P1395)
   
3. **P2633 Count on a tree**  
   题目链接：[https://www.luogu.com.cn/problem/P2633](https://www.luogu.com.cn/problem/P2633)

### 个人心得总结

- **调试经历**：部分题解提到在实现LCA时遇到了一些问题，如深度计算错误或父节点信息未正确更新，通过调试和逐步验证解决了这些问题。
- **踩坑教训**：在实现LCA时，需要注意深度信息的正确性，尤其是在使用倍增LCA时，预处理步骤不能遗漏。
- **顿悟感想**：通过多次练习，逐渐理解了LCA算法的核心思想，发现暴力LCA在小规模数据下已经足够高效，不必过度追求复杂算法。

---
处理用时：53.71秒
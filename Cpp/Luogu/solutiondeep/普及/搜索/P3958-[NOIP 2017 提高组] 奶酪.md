# 题目信息

# [NOIP 2017 提高组] 奶酪

## 题目背景

NOIP2017 提高组 D2T1

## 题目描述

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?

空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：


$$\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$


## 说明/提示

【输入输出样例 $1$ 说明】

 ![](https://cdn.luogu.com.cn/upload/pic/10860.png) 

第一组数据,由奶酪的剖面图可见：

第一个空洞在 $(0,0,0)$ 与下表面相切；

第二个空洞在 $(0,0,4)$ 与上表面相切；

两个空洞在 $(0,0,2)$ 相切。

输出 `Yes`。

 
第二组数据,由奶酪的剖面图可见：

两个空洞既不相交也不相切。

输出 `No`。

 
第三组数据,由奶酪的剖面图可见：

两个空洞相交，且与上下表面相切或相交。

输出 `Yes`。

【数据规模与约定】

对于 $20\%$ 的数据，$n = 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。

对于 $40\%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $80\%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $100\%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3 
2 4 1 
0 0 1 
0 0 3 
2 5 1 
0 0 1 
0 0 4 
2 5 2 
0 0 2 
2 0 4```

### 输出

```
Yes
No
Yes```

# AI分析结果

### 综合分析与结论

本题的核心问题是通过并查集或搜索算法（如DFS、BFS）来判断奶酪中的空洞是否连通，从而判断Jerry能否从下表面跑到上表面。大多数题解采用了并查集或DFS/BFS的思路，部分题解在实现细节上有所不同，如优化距离计算、避免精度问题等。整体来看，并查集的实现较为简洁且效率较高，而DFS/BFS的实现则更直观，但可能在某些情况下存在性能问题。

### 所选高星题解

#### 1. 作者：Fading (赞：323)
- **星级**: 5星
- **关键亮点**: 
  - 使用并查集实现，思路清晰，代码简洁。
  - 通过距离平方避免精度问题，优化了计算效率。
  - 详细解释了并查集的合并操作和路径压缩。
- **个人心得**: 
  - 作者提到本机样例通过，但在UOJ上因精度问题被卡，最终通过优化距离计算解决了问题。
- **核心代码**:
  ```cpp
  int find(int x){
      if (x!=f[x]) f[x]=find(f[x]);
      return f[x];
  }
  long long dis(long long x,long long y,long long z,long long x1,long long y1,long long z1){
      return (x-x1)*(x-x1)+(y-y1)*(y-y1)+(z-z1)*(z-z1);
  }
  ```

#### 2. 作者：ikunTLE (赞：11)
- **星级**: 4星
- **关键亮点**: 
  - 使用并查集实现，代码结构清晰。
  - 通过距离平方避免精度问题，优化了计算效率。
  - 详细解释了并查集的合并操作和路径压缩。
- **核心代码**:
  ```cpp
  int _find(int x){
      if(x==fa[x]) return x;
      fa[x]=_find(fa[x]);
      return fa[x];
  }
  void _merge(int x,int y){
      int fx=_find(x),fy=_find(y);
      if(fx!=fy) fa[fx]=fy;
  }
  ```

#### 3. 作者：liangbob (赞：5)
- **星级**: 4星
- **关键亮点**: 
  - 使用并查集实现，代码结构清晰。
  - 通过距离平方避免精度问题，优化了计算效率。
  - 详细解释了并查集的合并操作和路径压缩。
- **核心代码**:
  ```cpp
  int find(int x){
      return (fa[x] == x ? x : fa[x] = find(fa[x]));
  }
  void merge(int x, int y){
      fa[find(x)] = find(y);
  }
  ```

### 最优关键思路与技巧

1. **并查集的应用**: 通过并查集合并相交或相切的空洞，最后判断上下表面是否连通。
2. **距离平方优化**: 通过计算距离平方避免使用`sqrt`，减少精度问题并提高计算效率。
3. **路径压缩**: 在并查集中使用路径压缩优化查找效率。

### 可拓展之处

1. **图论问题**: 类似的问题可以转化为图论中的连通性问题，使用DFS/BFS或并查集解决。
2. **三维几何问题**: 类似的三维几何问题可以通过距离公式和几何性质解决。

### 推荐题目

1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
3. [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)

### 个人心得总结

- **精度问题**: 在计算距离时，使用距离平方避免`sqrt`可以减少精度问题。
- **并查集优化**: 路径压缩和按秩合并是并查集的常见优化手段，能显著提高效率。
- **多测清空**: 多组数据测试时，务必清空数组和变量，避免数据污染。

---
处理用时：33.17秒
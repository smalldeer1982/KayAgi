# 题目信息

# 最大食物链计数

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。


## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。


## 说明/提示

各测试点满足以下约定：

 ![](https://cdn.luogu.com.cn/upload/pic/12011.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心是计算有向无环图（DAG）中从生产者（入度为0的点）到最高级消费者（出度为0的点）的路径数量。题解中主要采用了拓扑排序和记忆化搜索两种思路，其中拓扑排序是更为主流的解法，而记忆化搜索则更适合于初学者理解。大部分题解都提到了如何通过入度和出度来识别生产者和消费者，并通过动态规划或记忆化来优化计算路径数量。

### 评分较高的题解

#### 1. 御·Dragon (5星)
**关键亮点**：
- 详细解释了拓扑排序的思路，并通过图示清晰展示了计算过程。
- 代码结构清晰，使用了邻接表存储图，并通过队列实现拓扑排序。
- 动态规划的思想贯穿始终，通过累加路径数量来求解最终答案。

**个人心得**：
- 作者多次更新题解，优化了排版和解释，使得题解更加易懂。
- 强调了拓扑排序的核心思想，即通过删除入度为0的点来逐步计算路径数量。

**核心代码**：
```cpp
while(!q.empty()) {
    int tot = q.front();
    q.pop();
    int len = nei[tot].size();
    for(int i = 0; i < len; ++i) {
        int next = nei[tot][i];
        --in[next];
        num[next] = (num[next] + num[tot]) % mod;
        if(in[next] == 0) q.push(next);
    }
}
```

#### 2. Watcher (4.5星)
**关键亮点**：
- 通过邻接表和邻接矩阵两种方式实现拓扑排序，对比了两种方法的时空复杂度。
- 详细解释了为什么拓扑排序适用于本题，并通过代码展示了如何实现。

**核心代码**：
```cpp
while(!q.empty()) {
    int a = q.front();
    q.pop();
    for(int k = h[a]; k; k = d[k].n) {
        int b = d[k].b;
        f[b] += f[a];
        f[b] %= mod;
        ru[b]--;
        if(ru[b] == 0) q.push(b);
    }
}
```

#### 3. Dog_Two (4星)
**关键亮点**：
- 使用了记忆化搜索的思路，适合初学者理解。
- 通过DFS实现路径数量的计算，并通过记忆化优化了时间复杂度。

**核心代码**：
```cpp
int dfs(int x) {
    if(dp[x] != 0) return dp[x];
    int ans = 0;
    if(ru[x] != 0 && chu[x] == 0) ans++;
    for(int i = head[x]; i != 0; i = e[i].nxt) {
        ans += dfs(e[i].to);
    }
    dp[x] = ans % mod;
    return ans % mod;
}
```

### 最优关键思路与技巧

1. **拓扑排序**：通过删除入度为0的点，逐步计算每个点的路径数量，最终累加出度为0的点的路径数量。
2. **动态规划**：利用`f[i]`表示从生产者到点`i`的路径数量，通过累加前驱节点的路径数量来更新当前节点的路径数量。
3. **记忆化搜索**：通过DFS遍历图，并使用记忆化技术避免重复计算，优化时间复杂度。

### 拓展思路

- **类似题目**：可以扩展到其他DAG上的路径计数问题，如计算最短路径、最长路径等。
- **优化技巧**：在拓扑排序中，可以使用优先队列来优化某些特定场景下的计算顺序。

### 推荐题目

1. **P3183 [HAOI2016]食物链**：与本题类似，考察DAG上的路径计数。
2. **P4017 最大食物链计数**：同样是DAG上的路径计数问题，但数据规模更大。
3. **P3387 【模板】拓扑排序**：拓扑排序的模板题，适合练习拓扑排序的基本实现。

### 个人心得总结

- **调试经历**：多位作者提到在实现拓扑排序时，需要注意入度和出度的更新顺序，避免重复计算或遗漏某些路径。
- **踩坑教训**：部分题解提到在记忆化搜索中，如果不加记忆化，容易导致超时，因此记忆化是优化DFS的关键。
- **顿悟感想**：通过拓扑排序和动态规划的结合，可以高效解决DAG上的路径计数问题，这种思路在类似题目中也非常适用。

---
处理用时：43.86秒
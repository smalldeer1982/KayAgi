# 题目信息

# 三去矩阵

## 题目背景

无

## 题目描述

现在小Y有个$l \times l$的正方形字母矩阵，现在他想进行$q$次询问，每次询问最长的以$(x_i,y_i)$为中心的在一条水平或竖直的直线上的回文串的长度。

## 说明/提示

对于$20\%$的数据，$1 \le l \le 2$

另有$20\%$的数据，$q = 1$

另有$20\%$的数据，字母矩阵中心对称，上下对称，左右对称且对角线对称。

对于$100\%$的数据，$1 \le l,q \le 2000$，字母只有小写字母。

## 样例 #1

### 输入

```
5 5
abcba
bcdcb
cdedc
bcdcb
abcba
1 1
1 2
1 3
2 3
3 3```

### 输出

```
1
1
5
5
5
```

# AI分析结果

### 综合分析与结论

本题的核心问题是以给定点为中心，找到矩阵中水平或垂直方向上的最长回文串。题解大多采用了暴力模拟的思路，通过从中心点向左右或上下扩展，判断字符是否相等来找到最长回文串。虽然题目数据范围较大（$l, q \le 2000$），但由于每个查询的处理是独立的，且每个查询的时间复杂度为 $O(l)$，因此暴力模拟的方法在时间上是可行的。

大部分题解的思路相似，主要区别在于代码的实现细节和优化程度。部分题解在边界处理、代码简洁性、时间复杂度优化等方面做得较好，而有些题解则存在冗余代码或边界处理不清晰的问题。

### 评分较高的题解

#### 1. **作者：CT_Res (赞：11)**
- **星级：4.5**
- **关键亮点**：
  - 预处理了所有可能的回文串长度，避免了重复计算，提升了查询效率。
  - 代码结构清晰，逻辑简洁，易于理解。
  - 通过两层循环枚举所有可能的回文串中心，预处理了每个点的最长回文串长度，查询时直接输出结果，时间复杂度为 $O(l^2 + q)$。
  
**核心代码片段**：
```cpp
for(int i=1;i<=l;i++)
    for(int j=1;j<=l;j++)
    {
        int a1=1,a2=1;
        for(int k=1;k<=l;k++)
            if(ch[i][j+k]==ch[i][j-k] && j+k<=l && j-k>=1) a1+=2;
            else break;
        for(int k=1;k<=l;k++)
            if(ch[i+k][j]==ch[i-k][j] && i+k<=l && i-k>=1) a2+=2;
            else break;
        f[i][j]=max(a1,a2);
    }
```

#### 2. **作者：Jasonggg15 (赞：4)**
- **星级：4**
- **关键亮点**：
  - 代码简洁明了，直接模拟了从中心点向左右和上下扩展的过程。
  - 通过 `sum1` 和 `sum2` 分别记录横向和纵向的回文串长度，最后取最大值输出，逻辑清晰。
  - 边界处理得当，避免了越界问题。

**核心代码片段**：
```cpp
for(int k=1;k<=l;k++) //横向
{
    if(sum1==l) break;
    if(map[x][y+k]==map[x][y-k]) sum1+=2;
    else break;
}
for(int k=1;k<=l;k++) //纵向
{
    if(sum2==l) break;
    if(map[x+k][y]==map[x-k][y]) sum2+=2;
    else break;
}
cout<<max(sum1,sum2)<<endl;
```

#### 3. **作者：封禁用户 (赞：2)**
- **星级：4**
- **关键亮点**：
  - 代码简洁，直接模拟了从中心点向左右和上下扩展的过程。
  - 通过 `l` 和 `r` 分别记录左右和上下的扩展边界，逻辑清晰。
  - 边界处理得当，避免了越界问题。

**核心代码片段**：
```cpp
int l=y-1,r=y+1,ans(1);
while(l>=1&&r<=n) {
    if(a[x][l]!=a[x][r]) break;
    --l,++r,ans+=2;
}
int ll=x-1,rr=x+1,anss(1);
while(ll>=1&&rr<=n) {
    if(a[ll][y]!=a[rr][y]) break;
    --ll,++rr,anss+=2;
}
ans>anss?printf("%d\n",ans):printf("%d\n",anss);
```

### 最优关键思路与技巧

1. **预处理优化**：通过预处理每个点的最长回文串长度，可以将查询时间复杂度降低到 $O(1)$，适合查询次数较多的情况。
2. **边界处理**：在扩展过程中，始终要检查是否越界，避免访问非法内存。
3. **代码简洁性**：通过合理的变量命名和逻辑结构，使代码更易读和维护。

### 可拓展之处

1. **回文串的扩展**：本题的思路可以扩展到二维矩阵中的其他回文串问题，如斜对角线上的回文串。
2. **Manacher算法**：对于一维字符串的最长回文串问题，可以使用 Manacher 算法将时间复杂度优化到 $O(n)$，但在二维矩阵中应用较为复杂。

### 推荐题目

1. **P3805 【模板】Manacher算法**：学习一维字符串中的最长回文串问题。
2. **P1435 回文字符串**：练习回文串的相关问题。
3. **P1217 [USACO1.5]回文质数**：结合回文串和质数的综合问题。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中遇到了边界处理不当的问题，导致程序出错。例如，`getchar()` 的使用可能导致换行符被误读，影响输入的正确性。
- **踩坑教训**：在扩展回文串时，必须注意边界条件，避免越界访问。同时，初始化变量时要确保其初始值合理，避免逻辑错误。
- **顿悟感想**：通过预处理可以显著提升查询效率，尤其是在查询次数较多的情况下，预处理是一种非常有效的优化手段。

---
处理用时：47.87秒
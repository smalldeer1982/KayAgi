# 题目信息

# A换B problem

## 题目背景

仙女与小奔约定，想要拿到仙药，必须在牌技上赢了她。

## 题目描述

他们要开始打牌了。但是，拥有强迫症的小奔看着手中的牌，很不愉快。原因是他理牌时按花色理（逗我），又希望一个花色的牌是连着的（$A-2-3-4-5-6-7-8-9-10-J-Q-K$）。

忍无可忍的小奔开始与参与打牌的其他人换牌（作弊？？？），他希望换最少的牌来满足他的需求（假设所有牌都可以换）

换牌规则：只能用点数相同的牌交换。

众人：还能不能好好打牌了？！我们限你1s内换完，要不然就告诉仙女！

## 说明/提示

样例1，可达成，将$2$ $3$换为$1$ $3$，$4$ $J$换为$3$ $J$

样例2，可达成，将$2$ $3$换成$1$ $3$，$3$ $Q$换成$4$ $Q$。
（以上答案仅供参考，不保证没有多解,但输出必然唯一，~~别问我为什么~~）


对于10%的数据：为样例$2.$

对于100%的数据： $ N \leq 52 $，即保证数据在一副牌内

## 样例 #1

### 输入

```
10
1 A
1 2
1 4
2 3
2 5
2 6
3 9
3 10
3 Q
4 J```

### 输出

```
Yes
2```

## 样例 #2

### 输入

```
10
1 A
1 2
1 4
2 3
2 5
2 6
3 9
3 10
3 Q
4 K```

### 输出

```
Yes
2```

# AI分析结果

### 综合分析与结论

本题的核心问题是通过交换牌使得每种花色的牌按顺序排列，且交换次数最少。题解主要集中在搜索算法（如DFS）的应用上，部分题解通过剪枝优化了搜索效率。整体来看，题解的思路较为相似，但在代码实现和优化细节上存在差异。部分题解通过剪枝和状态压缩提升了效率，但代码可读性和思路清晰度参差不齐。

### 所选高星题解

#### 1. **作者：FlashHu (4星)**
- **关键亮点**：通过枚举每个花色的连续区间，并动态维护选中次数，结合可行性剪枝和最优性剪枝，大幅提升了搜索效率。代码结构清晰，剪枝策略合理。
- **核心代码**：
  ```cpp
  void dfs(R h,R lef){
      if(h==5){
          R now=0;
          for(R i=1;i<=13;++i){
              if(cnt[i]>0)return;//不合法
              now|=cnt[i]<0;
          }
          if(now){ans1=now1;return;}//No状态
          for(R i=1;i<=n;++i)//Yes状态，统计答案
              if((l[a[i]]>b[i]||r[a[i]]<b[i])&&++now==ans)return;
          ans=now;ans1=1;return;//注意ans1=1的剪枝作用
      }
      for(R i=max(lef-(4-h)*13,0),j,rr;i<=13;++i){//枚举区间长度，可行性剪枝
          if(i==0){l[h]=r[h]=0;dfs(h+1,lef);continue;}
          for(rr=i;rr<=13;++rr){//枚举右端点
              for(j=rr-i+1;j<=rr;++j)now1+=--cnt[j]<0;//动态维护当前选多了的总数
              if(now1<ans1)l[h]=(r[h]=rr)-i+1,dfs(h+1,lef-i);//最优性剪枝
              for(j=rr-i+1;j<=rr;++j)now1-=++cnt[j]<=0;
          }
      }
  }
  ```
- **个人心得**：通过动态维护选中次数和剪枝策略，成功将时间复杂度控制在可接受范围内，体现了对搜索算法的深刻理解。

#### 2. **作者：HuangRuibo (4星)**
- **关键亮点**：使用DFS结合状态检查，通过记录每种花色的牌的状态，并在搜索过程中实时判断是否满足条件。代码结构清晰，剪枝策略合理。
- **核心代码**：
  ```cpp
  bool check(){
      ll missing = 0;
      bool valid = true;
      for (int i = 1; i <= 4; i++) {
          ll min_rank = 15, max_rank = 0;
          for (ll j = 1; j <= 13; j++) {
              if (f[i][j]) {
                  min_rank = j;
                  break;
              }
          }
          for (ll j = 13; j >= 1; j--) {
              if (f[i][j]) {
                  max_rank = j;
                  break;
              }
          }
          for (int j = min_rank; j <= max_rank; j++) {
              if (!f[i][j]) {
                  valid = false;
                  missing++;
              }
          }
      }
      min_missing = min(min_missing, missing);
      return valid;
  }
  ```
- **个人心得**：通过实时检查状态和剪枝，成功优化了搜索效率，体现了对DFS算法的熟练应用。

### 最优关键思路与技巧

1. **剪枝优化**：通过可行性剪枝和最优性剪枝，大幅减少了搜索空间，提升了算法效率。
2. **状态压缩**：使用二维数组记录每种花色的牌的状态，便于快速判断是否满足条件。
3. **动态维护**：在搜索过程中动态维护选中次数，实时判断是否满足条件，避免无效搜索。

### 可拓展之处

类似的问题可以通过搜索算法结合剪枝策略来解决，如数独、八皇后等问题。此外，状态压缩和动态维护的技巧也可以应用于其他需要高效搜索的场景。

### 推荐题目

1. **P1074 靶形数独**：考察搜索与剪枝技巧。
2. **P1219 八皇后**：经典搜索问题，适合练习剪枝与回溯。
3. **P1443 马的遍历**：考察广度优先搜索（BFS）与状态压缩。

---
处理用时：43.34秒
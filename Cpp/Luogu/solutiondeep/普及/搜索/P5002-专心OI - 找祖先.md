# 题目信息

# 专心OI - 找祖先

## 题目背景

Imakf 是一个小蒟蒻，他最近刚学了 LCA，他在手机 APPstore 里看到一个游戏也叫做 LCA 就下载了下来。

## 题目描述

这个游戏会给出你一棵树，这棵树有 $N$ 个节点，根结点是 $R$，系统会选中 $M$ 个点 $P_1,P_2 \cdots P_M$，要Imakf 回答有多少组点对 $(u_i,v_i)$ 的最近公共祖先是 $P_i$。Imakf 是个小蒟蒻，他就算学了 LCA 也做不出，于是只好求助您了。



## 说明/提示

样例 1 的树如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/37971.png)

 对于询问 1 $~(1,1)
(1,2)
(1,3)
(1,4)
(1,5)
(1,6)
(1,7)
(2,1)
(2,3)
(2,6)
(2,7)
(3,1)
(3,2)
(3,4)
(3,5)
(4,1)
(4,3)$

$
(4,6)
(4,7)
(5,1)
(5,3)
(5,6)
(5,7)
(6,1)
(6,2)
(6,4)
(6,5)
(7,1)
(7,2)
(7,4)
(7,5)$ 共 $31$ 组点对。

询问 2 $(2,2)
(2,4)
(2,5)
(4,2)
(4,5)
(5,2)
(5,4)$ 共 $7$ 组点对。

对于询问 3 $(4,4)$ 共 $1$ 组点对。

$1\le R\le N\leq10000$，$0\le M\leq50000$。

## 样例 #1

### 输入

```
7 1 3
1 2
1 3
2 4
2 5
3 6
3 7
1 2 4```

### 输出

```
31
7
1```

# AI分析结果

### 综合分析与结论

本题的核心在于计算以某个节点为最近公共祖先（LCA）的点对数量。虽然题目提到了LCA，但实际解法并不需要直接计算LCA，而是通过树的结构和子树大小来推导。大多数题解都采用了DFS遍历树，计算每个节点的子树大小，然后通过组合数学的方式计算符合条件的点对数量。主要的优化点在于避免重复计算和减少时间复杂度。

### 所选高星题解

#### 1. 题解作者：llzzxx712 (4星)
**关键亮点**：
- 通过DFS计算每个节点的子树大小，避免了直接计算LCA的复杂度。
- 使用邻接表存储树结构，代码简洁且高效。
- 通过预处理所有节点的答案，避免了重复计算，优化了查询效率。

**个人心得**：
- 作者提到由于M（查询次数）可能大于N（节点数），因此需要预处理所有节点的答案，避免重复计算。这一点在实际比赛中非常实用，能够有效减少时间复杂度。

**核心代码**：
```cpp
int getans(int p){
    int x,y=0,z=0;
    z=x=son[p];
    for(int i=head[p];i;i=ne[i]){
        if(de[to[i]]<de[p]) continue;
        y=son[to[i]];
        z+=(long long)((x-y)*y)%mo;
    }
    return z;
}
```
**实现思想**：通过遍历每个节点的子节点，计算符合条件的点对数量，并累加到结果中。

#### 2. 题解作者：ZAGER (4星)
**关键亮点**：
- 通过DFS预处理每个节点的子树大小，并利用组合数学公式计算答案。
- 使用完全平方公式优化了计算过程，避免了重复计算。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
int solve(long long now) {
    long long sigma=0,chengji=0;
    for(register long long i=head[now]; i; i=h[i].next) {
        long long d=h[i].node;
        if(d==fa[now]) continue;
        sigma+=son[d];
        sigma%=mod;
        chengji+=son[d]*son[d];
        chengji%=mod;
    }
    return (son[now]*2%mod-1+sigma*sigma%mod-chengji+mod)%mod;
}
```
**实现思想**：通过遍历每个节点的子节点，利用完全平方公式计算符合条件的点对数量。

#### 3. 题解作者：mulberror (4星)
**关键亮点**：
- 通过DFS计算每个节点的子树大小，并利用组合数学公式计算答案。
- 使用前缀和优化了计算过程，减少了时间复杂度。
- 代码简洁且高效，逻辑清晰。

**核心代码**：
```cpp
register LL ans = sz[p] * 2 - 1;
for (Ri i = head[p] ; i ; i = edge[i].next) {
    if ( edge[i].to == fa[p]) continue;
    sz_rest = sz[p] - sz[edge[i].to] - 1 ;
    ans = (ans + (sz_rest *  sz[edge[i].to]  ) ) % Mod;
}
```
**实现思想**：通过遍历每个节点的子节点，利用前缀和优化计算符合条件的点对数量。

### 最优关键思路与技巧

1. **DFS预处理子树大小**：通过DFS遍历树，计算每个节点的子树大小，这是后续计算的基础。
2. **组合数学公式**：利用组合数学公式计算符合条件的点对数量，避免了直接计算LCA的复杂度。
3. **预处理与记忆化**：由于查询次数可能大于节点数，预处理所有节点的答案并记忆化，避免重复计算，优化查询效率。

### 可拓展之处

- **类似题目**：类似的问题可以扩展到计算树中其他类型的点对数量，如距离为k的点对、路径长度为k的点对等。
- **优化思路**：在处理大规模数据时，可以考虑使用更高效的数据结构（如线段树、树状数组）来优化查询和更新操作。

### 推荐题目

1. **P3379 【模板】最近公共祖先（LCA）**：考察LCA的基本应用。
2. **P1351 联合权值**：考察树的结构和组合数学的应用。
3. **P2633 Count on a tree**：考察树上的路径查询和数据结构的使用。

### 个人心得总结

- **预处理与记忆化**：在处理大规模查询时，预处理和记忆化是优化时间复杂度的有效手段。
- **组合数学的应用**：在树形结构中，组合数学公式可以帮助简化复杂的计算过程，提高代码效率。
- **调试与优化**：在实际比赛中，调试和优化代码是必不可少的环节，尤其是在处理复杂数据结构时。

---
处理用时：47.25秒
# 题目信息

# [USACO18DEC] Back and Forth B

## 题目描述

Farmer John 有两个挤奶棚，每个挤奶棚里各有一个奶罐和一个装有 $10$ 个各种尺寸的桶的储物柜。他喜欢将在两个挤奶棚之间来回运送牛奶作为一种锻炼方式。

周一，Farmer John 量了恰好 $1000$ 加仑的牛奶放在第一个挤奶棚的奶罐里，又量了恰好 $1000$ 加仑的牛奶放在第二个挤奶棚的奶罐里。

周二，他从第一个挤奶棚里取出一个桶，并装满牛奶，然后将牛奶运到第二个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第二个挤奶棚。

周三，他从第二个挤奶棚里取出一个桶（可能是周二留在这里的），并装满牛奶，然后将牛奶运到第一个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第一个挤奶棚。

周四，他从第一个挤奶棚里取出一个桶（可能是周三留在这里的），并装满牛奶，然后将牛奶运到第二个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第二个挤奶棚。

周五，他从第二个挤奶棚里取出一个桶（可能是周二或周四留在这里的），并装满牛奶，然后将牛奶运到第一个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第一个挤奶棚。

此时 Farmer John 测量了第一个挤奶棚的奶罐里的牛奶。他总共可能得到多少种不同的读数？


## 说明/提示

在这个例子中，最后第一个挤奶棚的奶罐中的牛奶量总共有 $5$ 种可能的结果：

$1000$：FJ 可以在每次往返的时候都携带同一个桶，从而不会改变第一个挤奶棚的奶罐的牛奶量。

$1003$：FJ 可以在周二运送 $2$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $1$ 个单位。

$1004$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $1$ 个单位。

$1007$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $2$ 个单位，周五 $5$ 个单位。

$1008$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $5$ 个单位。

## 样例 #1

### 输入

```
1 1 1 1 1 1 1 1 1 2
5 5 5 5 5 5 5 5 5 5```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心在于模拟Farmer John在五天内的牛奶运输过程，并计算最终第一个挤奶棚中牛奶量的可能结果。由于操作次数较少（仅四次），且每个挤奶棚的桶数量有限（10个），因此可以通过暴力枚举或深度优先搜索（DFS）来遍历所有可能的运输组合。

各题解的主要思路包括：
1. **DFS + 模拟**：通过DFS枚举每天选择的桶，并模拟牛奶的运输过程，最后统计不同的牛奶量。
2. **暴力枚举**：直接枚举所有可能的桶组合，计算最终的牛奶量，并使用集合去重。
3. **分类讨论**：根据桶的选择情况，分类讨论不同的运输组合，减少重复计算。

### 所选高星题解

#### 1. 作者：Alex_Wei (★★★★★)
**关键亮点**：
- 使用DFS模拟每天的运输过程，代码结构清晰，易于理解。
- 通过回溯机制确保状态正确恢复，避免了复杂的状态管理。
- 使用`vector`存储结果，最后输出不同结果的数量。

**核心代码**：
```cpp
void dfs(int w, int m) {
    if (w / 6) {
        for (int x = 0; x < ans.size(); x++)
            if (m == ans[x]) return;
        ans.push_back(m);
        return;
    }
    for (int x = 1; x <= 20; x++) {
        if (w % 2 == 0 && pd[x] == 1) {
            pd[x] = 2;
            dfs(w + 1, m - t[x]);
            pd[x] = 1;
        }
        if (w % 2 == 1 && pd[x] == 2) {
            pd[x] = 1;
            dfs(w + 1, m + t[x]);
            pd[x] = 2;
        }
    }
}
```
**实现思想**：通过DFS枚举每天选择的桶，并根据运输方向更新牛奶量，最后统计不同的结果。

#### 2. 作者：Polarnova (★★★★)
**关键亮点**：
- 通过分类讨论减少重复计算，思路清晰。
- 使用`set`存储结果，自动去重，简化了代码逻辑。

**核心代码**：
```cpp
for (int i = 1; i <= 10; i++) {
    for (int j = 11; j <= 20; j++)
        for (int k = i + 1; k <= 10; k++)
            for (int l = 11; l <= 20; l++)
                if (l != j) s.insert(-a[i] + a[j] - a[k] + a[l]);
    for (int k = i; k <= 10; k++)
        for (int l = 11; l <= 20; l++) s.insert(-a[k] + a[l]);
    for (int j = 11; j <= 20; j++) s.insert(-a[i] + a[j]);
    s.insert(0);
}
```
**实现思想**：通过四重循环枚举所有可能的桶组合，计算最终的牛奶量，并使用`set`去重。

#### 3. 作者：lzqy_ (★★★★)
**关键亮点**：
- 通过DFS枚举桶的编号，简化了模拟过程。
- 直接模拟每天的运输过程，代码逻辑清晰。

**核心代码**：
```cpp
void moni() {
    int a[10], b[11];
    for (int i = 0; i < 10; i++) a[i] = aa[i], b[i] = bb[i];
    b[10] = a[s[1]]; a[s[1]] = 0;
    a[s[1]] = b[s[2]]; b[s[2]] = 0;
    b[s[2]] = a[s[3]]; a[s[3]] = 0;
    a[s[3]] = b[s[4]]; b[s[4]] = 0;
    if (!k[a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9]])
        ans++, k[a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9]] = 1;
}
```
**实现思想**：通过DFS枚举桶的编号，模拟每天的运输过程，并统计不同的牛奶量。

### 最优关键思路与技巧
1. **DFS + 回溯**：通过DFS枚举所有可能的桶选择，并使用回溯机制确保状态正确恢复，适用于操作次数较少的问题。
2. **暴力枚举 + 去重**：直接枚举所有可能的桶组合，并使用集合（如`set`）去重，适用于数据规模较小的问题。
3. **分类讨论**：根据桶的选择情况，分类讨论不同的运输组合，减少重复计算，适用于需要优化的情况。

### 可拓展之处
- **类似问题**：类似的操作模拟问题，如物品交换、资源分配等，都可以采用DFS或暴力枚举的思路。
- **优化思路**：对于更大规模的数据，可以考虑剪枝或动态规划来优化计算。

### 推荐题目
1. [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得摘录
- **调试经历**：在DFS中，确保状态正确恢复是关键，尤其是在回溯时，必须恢复所有修改过的状态。
- **踩坑教训**：在暴力枚举时，注意去重，避免重复计算导致结果错误。
- **顿悟感想**：通过分类讨论，可以减少不必要的计算，提高代码效率。

---
处理用时：48.97秒
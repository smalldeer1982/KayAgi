# 题目信息

# [USACO05DEC] Scales S

## 题目描述

约翰有一架用来称牛的体重的天平。与之配套的是 $ N \ ( 1 \leq N \leq 1000 ) $ 个已知质量的砝码（所有砝码质量的数值都在 $32$ 位带符号整数范围内）。

每次称牛时，他都把某头奶牛安置在天平的某一边，然后往天平另一边加砝码，直到天平平衡，于是此时砝码的总质量就是牛的质量（约翰不能把砝码放到奶牛的那边，因为奶牛不喜欢称体重，每当约翰把砝码放到她的蹄子底下，她就会尝试把砝码踢到约翰脸上）。

天平能承受的物体的质量不是无限的，当天平某一边物体的质量大于 $ C \ ( 1 \leq C \leq 2^{30} ) $ 时，天平就会被损坏。砝码按照它们质量的大小被排成一行。并且，这一行中从第 $3$ 个砝码开始，每个砝码的质量至少等于前面两个砝码（也就是质量比它小的砝码中质量最大的两个）的质量的和。

约翰想知道，用他所拥有的这些砝码以及这架天平，能称出的质量最大是多少。由于天平的最大承重能力为 $C$，他不能把所有砝码都放到天平上。

现在约翰告诉你每个砝码的质量，以及天平能承受的最大质量，你的任务是选出一些砝码，使它们的质量和在不压坏天平的前提下是所有组合中最大的。

## 样例 #1

### 输入

```
3 15
1
10
20
```

### 输出

```
11```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地选择砝码组合，使得其总质量不超过天平的最大承重 \( C \)，并且尽可能接近 \( C \)。由于砝码的质量满足斐波那契数列的性质，实际有效的砝码数量远小于题目给出的 \( N \leq 1000 \)，通常在 30 左右。因此，直接使用深度优先搜索（DFS）结合剪枝策略是解决该问题的有效方法。

各题解的主要思路和优化点包括：
1. **剪枝策略**：通过前缀和、从后往前搜索、提前终止等手段，减少不必要的递归调用。
2. **斐波那契性质**：利用砝码质量的斐波那契性质，缩小搜索范围。
3. **搜索顺序**：从大到小搜索，避免小砝码占用过多搜索空间。
4. **前缀和优化**：通过前缀和快速判断当前组合是否可能超过 \( C \)。

### 所选高星题解

#### 1. 作者：StudyingFather (5星)
- **关键亮点**：清晰的剪枝策略，代码简洁且高效。通过前缀和优化，提前终止无效搜索。
- **个人心得**：作者提到“虽然题目中说 \( n \leq 1000 \)，但考虑到砝码质量的性质，实际 \( n \leq 30 \)”，这一洞察大大简化了问题。
- **核心代码**：
  ```cpp
  void dfs(int cur, long long x) {
      if (x > c) return;
      if (sum[cur - 1] + x <= c) {
          ans = max(ans, sum[cur - 1] + x);
          return;
      }
      ans = max(ans, x);
      for (int i = 1; i < cur; i++)
          dfs(i, x + a[i]);
  }
  ```

#### 2. 作者：Plozia (4.5星)
- **关键亮点**：从后往前搜索，结合后缀和剪枝，进一步优化了搜索效率。
- **个人心得**：作者提到“改变搜索顺序，从大到小搜索，避免小砝码占用过多搜索空间”，这一策略显著提升了性能。
- **核心代码**：
  ```cpp
  void dfs(int k, int now) {
      if (k > n) {
          ans = Max((LL)now, ans);
          return;
      }
      if (now + sum[k] <= c) {
          ans = Max(now + sum[k], ans);
          return;
      }
      if (now + a[k] <= c) dfs(k + 1, now + a[k]);
      dfs(k + 1, now);
  }
  ```

#### 3. 作者：hylong (4星)
- **关键亮点**：通过前缀和剪枝，结合斐波那契性质，优化了搜索过程。
- **个人心得**：作者提到“斐波那契数列，很快就会超过 \( 2^{30} \)，所以 \( N < 40 \)”，这一观察帮助简化了问题。
- **核心代码**：
  ```cpp
  void dfs(long long xh, long long w) {
      ans = max(ans, w);
      if (xh == 0) return;
      if (sum[xh] + w <= c) {
          ans = max(ans, sum[xh] + w);
          return;
      }
      if (w + a[xh] <= c) dfs(xh - 1, w + a[xh]);
      dfs(xh - 1, w);
  }
  ```

### 最优关键思路与技巧
1. **剪枝策略**：通过前缀和或后缀和，提前判断当前组合是否可能超过 \( C \)，从而减少不必要的递归调用。
2. **搜索顺序**：从大到小搜索，避免小砝码占用过多搜索空间。
3. **斐波那契性质**：利用砝码质量的斐波那契性质，缩小搜索范围。

### 可拓展之处
- **类似问题**：背包问题、子集和问题等，都可以通过类似的剪枝策略进行优化。
- **算法套路**：DFS + 剪枝是解决组合优化问题的常用套路，适用于多种场景。

### 推荐题目
1. [P1049 装箱问题](https://www.luogu.com.cn/problem/P1049)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

### 个人心得总结
- **调试经历**：多位作者提到在调试过程中遇到的剪枝问题，如“千万要把这一句放到下面这个if的上面”，强调了剪枝顺序的重要性。
- **顿悟感想**：通过斐波那契性质简化问题，是解决本题的关键洞察之一。

---
处理用时：41.59秒
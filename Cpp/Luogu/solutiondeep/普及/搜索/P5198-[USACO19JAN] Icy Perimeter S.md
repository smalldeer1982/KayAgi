# 题目信息

# [USACO19JAN] Icy Perimeter S

## 题目背景

USACO 一月月赛银组第二题

## 题目描述

Farmer John 要开始他的冰激凌生意了！他制造了一台可以生产冰激凌球的机器，然而不幸的是形状不太规则，所以他现在希望优化一下这台机器，使其产出的冰激凌球的形状更加合理。
机器生产出的冰激凌的形状可以用一个 $N \times N$（$1 \leq N \leq 1000$）的矩形图案表示，例如：

```
##....
....#.
.#..#.
.#####
...###
....##
```

每个 `.` 字符表示空的区域，每个 `#` 字符表示一块 $1 \times 1$ 的正方形格子大小的冰激凌。

不幸的是，机器当前工作得并不是很正常，可能会生产出多个互不相连的冰激凌球（上图中有两个）。一个冰激凌球是连通的，如果其中每个冰激凌的正方形格子都可以从这个冰激凌球中其他所有的冰激凌格子出发重复地前往东、南、西、北四个方向上相邻的冰激凌格子所到达。

Farmer John 想要求出他的面积最大的冰激凌球的面积和周长。冰激凌球的面积就是这个冰激凌球中 `#` 的数量。如果有多个冰激凌球并列面积最大，他想要知道其中周长最小的冰激凌球的周长。在上图中，小的冰激凌球的面积为 $2$，周长为 $6$，大的冰激凌球的面积为 $13$，周长为 $22$。

注意一个冰激凌球可能在中间有“洞”（由冰激凌包围着的空的区域）。如果这样，洞的边界同样计入冰激凌球的周长。冰激凌球也可能出现在被其他冰激凌球包围的区域内，在这种情况下它们计为不同的冰激凌球。例如，以下这种情况包括一个面积为 $1$ 的冰激凌球，被包围在一个面积为 $16$ 的冰激凌球内：

```
#####
#...#
#.#.#
#...#
#####
```

同时求得冰激凌球的面积和周长十分重要，因为 Farmer John 最终想要最小化周长与面积的比值，他称这是他的冰激凌的“冰周率”。当这个比率较小的时候，冰激凌化得比较慢，因为此时冰激凌单位质量的表面积较小。


## 样例 #1

### 输入

```
6
##....
....#.
.#..#.
.#####
...###
....##```

### 输出

```
13 22```

# AI分析结果

### 综合分析与结论

本题的核心是通过搜索算法（DFS或BFS）找到冰激凌球的连通块，并计算其面积和周长。难点在于如何高效地计算周长，尤其是当冰激凌球内部有“洞”时。大部分题解都采用了DFS或BFS来遍历连通块，并在遍历过程中计算面积和周长。周长的计算通常通过判断当前点的四个方向是否为边界或空地来实现。

### 所选高星题解

#### 1. **作者：Swire (赞：25)**
- **星级：4.5**
- **关键亮点：**
  - 使用DFS遍历连通块，代码简洁易懂。
  - 在DFS过程中直接计算周长，通过判断当前点的四个方向是否为边界或空地。
  - 通过`#pragma GCC optimize("no-stack-protector")`防止DFS爆栈。
- **个人心得：**
  - 作者提到DFS可能会爆栈，因此进行了优化，提醒了DFS在大规模数据下的潜在问题。

**核心代码：**
```cpp
void dfs(int x,int y) {
	if(vis[x][y]) return ;
	vis[x][y]=true;
	S++;
	for(int d=0; d<4; d++) {
		int xx=x+dx[d],yy=y+dy[d];
		if(xx<1||xx>n||yy<1||yy>n||ice[xx][yy]=='.') C++;
		if(ice[xx][yy]=='#') dfs(xx,yy);
	}
}
```

#### 2. **作者：YyunSu (赞：24)**
- **星级：4.5**
- **关键亮点：**
  - 使用DFS遍历连通块，并在遍历过程中计算面积和周长。
  - 通过将边界设置为`.`，简化了周长的计算。
  - 代码结构清晰，逻辑简单明了。
- **个人心得：**
  - 作者提到通过将边界设置为`.`，避免了边界判断的复杂性，简化了代码实现。

**核心代码：**
```cpp
void dfs(int x,int y) {
	vis[x][y] = step;
	for(int i = 0; i < 4; i++) {
		int xx = x + dir[i][0];
		int yy = y + dir[i][1];
		if(xx >= 1 && xx <= n && yy >= 1 && yy <= n && !vis[xx][yy] && a[xx][yy] == '#') {
			step++;
			step1 += mmp (xx, yy);
			dfs(xx,yy);
		}
	}
}
```

#### 3. **作者：OnlyU (赞：7)**
- **星级：4**
- **关键亮点：**
  - 使用BFS遍历连通块，并在遍历过程中计算面积和周长。
  - 通过结构体存储面积和周长，代码结构清晰。
  - 在BFS过程中直接计算周长，逻辑简单。
- **个人心得：**
  - 作者提到BFS适用于向多个方向同时扩展，适合处理矩阵中的连通块问题。

**核心代码：**
```cpp
void bfs(int sx,int sy) {
	queue<bfc>que;
	a.x=sx;
	a.y=sy;
	int num1=1,num2=0;
	for(int i=0; i<4; i++) {
		c.x=a.x+dx[i];
		c.y=a.y+dy[i];
		if(maze[c.x][c.y]==-1) num2++;
	}
	v[sx][sy]=1;
	que.push(a);
	while(!que.empty()) {
		b=que.front();
		que.pop();
		for(int i=0; i<4; i++) {
			c.x=b.x+dx[i];
			c.y=b.y+dy[i];
			if(c.x>=1&&c.x<=n&&c.y>=1&&c.y<=n&&v[c.x][c.y]==0&&maze[c.x][c.y]==1) {
				num1++;
				v[c.x][c.y]=1;
				for(int j=0; j<4; j++) {
					d.x=c.x+dx[j];
					d.y=c.y+dy[j];
					if(maze[d.x][d.y]==-1) num2++;
				}
				que.push(c);
			}
		}
	}
}
```

### 最优关键思路与技巧

1. **DFS/BFS遍历连通块**：通过DFS或BFS遍历冰激凌球的连通块，计算面积和周长。
2. **周长计算**：在遍历过程中，通过判断当前点的四个方向是否为边界或空地来计算周长。
3. **边界处理**：将边界设置为`.`，简化周长的计算。
4. **优化DFS**：通过`#pragma GCC optimize("no-stack-protector")`防止DFS爆栈。

### 可拓展之处

- **类似题目**：可以扩展到其他连通块问题，如计算最大岛屿面积、最小周长等。
- **算法优化**：可以进一步优化DFS/BFS的遍历顺序，减少重复计算。

### 推荐题目

1. **P1451 求细胞数量**：考察连通块的DFS/BFS遍历。
2. **P1162 填涂颜色**：考察连通块的填充与边界处理。
3. **P1141 01迷宫**：考察连通块的遍历与路径计算。

### 个人心得总结

- **调试经历**：多位作者提到DFS可能会爆栈，提醒了在大规模数据下DFS的潜在问题。
- **踩坑教训**：通过将边界设置为`.`，简化了周长的计算，避免了边界判断的复杂性。
- **顿悟感想**：BFS适用于向多个方向同时扩展，适合处理矩阵中的连通块问题。

---
处理用时：49.09秒
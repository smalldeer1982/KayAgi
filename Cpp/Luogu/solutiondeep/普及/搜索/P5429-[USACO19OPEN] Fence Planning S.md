# 题目信息

# [USACO19OPEN] Fence Planning S

## 题目描述

Farmer John 的 $ N $ 头奶牛，编号为 $ 1 \ldots N $ （ $ 2 \leq N \leq 10^5 $ ），拥有一种围绕“哞网”，一些仅在组内互相交流却不与其他组进行交流的奶牛小组，组成的复杂的社交网络。

每头奶牛位于农场的二维地图上的不同位置 $ (x,y) $ ，并且我们知道有 $ M $ 对奶牛( $ 1 \leq M<10^5 $ )会相互哞叫。两头相互哞叫的奶牛属于同一哞网。

为了升级他的农场，Farmer John 想要建造一个四边与 $ x $ 轴和 $ y $ 轴平行的长方形围栏。Farmer John 想要使得至少一个哞网完全被围栏所包围（在长方形边界上的奶牛计为被包围的）。请帮助 Farmer John 求出满足他的要求的围栏的最小可能周长。有可能出现这一围栏宽为 $0$ 或高为 $0$ 的情况。

## 样例 #1

### 输入

```
7 5
0 5
10 5
5 0
5 10
6 7
8 6
8 4
1 2
2 3
3 4
5 6
7 6```

### 输出

```
10```

# AI分析结果

### 综合分析与结论

本题的核心是找到所有连通块，并计算每个连通块的最小包围矩形周长。题解中主要使用了两种方法：**DFS/BFS遍历**和**并查集**。DFS/BFS方法通过遍历图来找到连通块，并在遍历过程中维护矩形的边界；并查集方法则通过合并操作维护连通块，并在合并时更新矩形的边界。两种方法的时间复杂度均为$O(n)$，但并查集方法在代码实现上更为简洁，且更易于维护连通块的边界信息。

### 所选高星题解

#### 1. 作者：Mkarry (4星)
**关键亮点**：
- 使用DFS遍历图，代码清晰易懂。
- 详细解释了时间复杂度为$O(n)$的原因，避免了误解。
- 通过维护矩形的上下左右边界来计算周长，思路清晰。

**核心代码**：
```cpp
void DFS(int step){
    vis[step]=1;
    U=max(U,a[step].y),D=min(D,a[step].y);
    R=max(R,a[step].x),L=min(L,a[step].x);
    for(int j=lik[step];j;j=nxt[j]) if(!vis[son[j]]) DFS(son[j]);
}
```
**实现思想**：通过DFS遍历连通块，并在遍历过程中更新矩形的上下左右边界，最后计算周长。

#### 2. 作者：purinliang (4星)
**关键亮点**：
- 使用并查集维护连通块，代码简洁高效。
- 在合并操作时直接更新矩形的边界，避免了额外的遍历。
- 时间复杂度为$O(n)$，并查集优化了路径压缩。

**核心代码**：
```cpp
bool union_set(int x,int y) {
    int fx=find_par(x);
    int fy=find_par(y);
    if(fx==fy) return false;
    par[fy]=fx;
    u[fx]=max(u[fx],u[fy]);
    d[fx]=min(d[fx],d[fy]);
    l[fx]=min(l[fx],l[fy]);
    r[fx]=max(r[fx],r[fy]);
    return true;
}
```
**实现思想**：在并查集的合并操作中，直接更新矩形的上下左右边界，最后计算周长。

#### 3. 作者：微芒晨曦 (4星)
**关键亮点**：
- 使用两遍并查集，第一遍标记连通关系，第二遍更新连通块的边界。
- 通过维护连通块的根节点来更新边界，思路清晰。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
void check(int p) {
    int A=fa[p];
    maxx[A]=max(x[p],maxx[A]);
    minx[A]=min(x[p],minx[A]);
    miny[A]=min(y[p],miny[A]);
    maxy[A]=max(y[p],maxy[A]);
}
```
**实现思想**：通过两遍并查集，第一遍标记连通关系，第二遍更新连通块的边界，最后计算周长。

### 最优关键思路与技巧

- **并查集优化**：在合并操作时直接更新矩形的边界，避免了额外的遍历，代码简洁高效。
- **DFS/BFS遍历**：通过遍历图来找到连通块，并在遍历过程中维护矩形的边界，思路清晰。
- **时间复杂度优化**：两种方法的时间复杂度均为$O(n)$，并查集方法在代码实现上更为简洁。

### 可拓展之处

- **同类型题**：类似的问题可以扩展到三维空间，寻找最小包围立方体的表面积。
- **算法套路**：并查集和DFS/BFS遍历在连通块问题中非常常见，可以应用于其他图论问题中。

### 推荐题目

1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)
3. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

### 个人心得摘录

- **Mkarry**：解释了时间复杂度为$O(n)$的原因，避免了误解。
- **purinliang**：并查集优化了路径压缩，代码简洁高效。
- **微芒晨曦**：通过两遍并查集，第一遍标记连通关系，第二遍更新连通块的边界，思路清晰。

---
处理用时：38.13秒
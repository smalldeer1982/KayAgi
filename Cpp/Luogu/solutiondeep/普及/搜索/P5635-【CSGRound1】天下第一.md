# 题目信息

# 【CSGRound1】天下第一

## 题目背景

天下第一的 cbw 以主席的身份在 8102 年统治全宇宙后，开始了自己休闲的生活，并邀请自己的好友每天都来和他做游戏。由于 cbw 想要显出自己平易近人，所以 zhouwc 虽然是一个蒟蒻，也有能和 cbw 玩游戏的机会。

## 题目描述

游戏是这样的：

给定两个数 $x$，$y$，与一个模数 $p$。

cbw 拥有数 $x$，zhouwc 拥有数 $y$。

第一个回合：$x\leftarrow(x+y)\bmod p$。

第二个回合：$y\leftarrow(x+y)\bmod p$。

第三个回合：$x\leftarrow(x+y)\bmod p$。

第四个回合：$y\leftarrow(x+y)\bmod p$。

以此类推....

如果 $x$ 先到 $0$，则 cbw 胜利。如果 $y$ 先到 $0$，则 zhouwc 胜利。如果 $x,y$ 都不能到 $0$，则为平局。

cbw 为了捍卫自己主席的尊严，想要提前知道游戏的结果，并且可以趁机动点手脚，所以他希望你来告诉他结果。

## 说明/提示

$1 \leq T \leq 200$。

$1 \leq x,y,p \leq 10000$。

## 样例 #1

### 输入

```
1 10
1 3
```

### 输出

```
error```

## 样例 #2

### 输入

```
1 10
4 5
```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心在于模拟游戏过程，并判断最终结果。由于游戏规则涉及模运算，且$x$和$y$的值会不断更新，因此需要高效地处理循环和重复状态。大多数题解采用了**记忆化搜索**或**模拟**的方法，部分题解通过**斐波那契数列**的特性来优化循环判断。整体来看，题解的质量参差不齐，部分题解在空间优化和循环判断上处理得较好，但整体思路较为相似。

### 所选高星题解

#### 1. 作者：MY（一名蒟蒻） (4星)
- **关键亮点**：使用`short`类型优化空间，避免MLE；通过记忆化搜索减少重复计算，代码简洁且高效。
- **个人心得**：作者在发现`int`类型会导致内存溢出后，迅速改用`short`类型，展现了良好的调试意识。
- **核心代码**：
  ```cpp
  short book[10010][10010]; 
  int rem(int x,int y) {
      if(book[x][y] == -1) return -1;
      if(book[x][y]) return book[x][y];
      book[x][y]=-1;
      if(!x) return book[x][y]=1;
      if(!y) return book[x][y]=2;
      int num=(x+y)%mod;
      return book[x][y]=rem(num,(num%mod+y)%mod);
  }
  ```

#### 2. 作者：mot1ve (4星)
- **关键亮点**：同样使用`short`类型优化空间，通过标记循环状态来判断`error`，思路清晰。
- **核心代码**：
  ```cpp
  short f[10010][10010];
  int cal(int x,int y) {
      if(f[x][y]==-1) return 3;
      if(f[x][y]) return f[x][y];
      f[x][y]=-1;
      if(x==0) return f[x][y]=1;
      if(y==0) return f[x][y]=2;
      return f[x][y]=cal((x+y)%mod,((x+y)%mod+y)%mod);
  }
  ```

#### 3. 作者：xiaohuang (4星)
- **关键亮点**：通过`short`类型优化空间，结合记忆化搜索和循环次数判断，代码结构清晰。
- **核心代码**：
  ```cpp
  short dp[MAXN][MAXN];
  inline short solve(int x, int y, int cnt) {
      if (cnt >= 10000) return 0;
      if (dp[x][y]) return dp[x][y];
      if (x == 0) return 1;
      if (y == 0) return 2;
      return dp[x][y] = solve((x + y) % mod, ((x + y) % mod + y) % mod, cnt + 1);
  }
  ```

### 最优关键思路与技巧

1. **空间优化**：使用`short`类型代替`int`，避免内存溢出。
2. **记忆化搜索**：通过记录已访问状态，减少重复计算，提升效率。
3. **循环判断**：通过标记循环状态或设置最大循环次数，及时判断`error`。

### 可拓展之处

- **类似问题**：可以扩展到其他涉及状态转移和循环判断的问题，如斐波那契数列的模运算、状态机模拟等。
- **优化思路**：在类似问题中，可以考虑使用更高效的数据结构（如哈希表）来记录状态，或通过数学性质（如周期性）来优化循环判断。

### 推荐题目

1. **P1965 斐波那契数列**：考察斐波那契数列的模运算和循环节。
2. **P1044 栈**：涉及状态转移和记忆化搜索。
3. **P1028 数的计算**：通过记忆化搜索优化递归问题。

### 个人心得总结

- **调试意识**：在发现内存溢出问题时，及时调整数据类型，展现了良好的调试能力。
- **优化思维**：通过记忆化搜索和循环判断，有效减少了计算量，提升了代码效率。

---
处理用时：34.43秒
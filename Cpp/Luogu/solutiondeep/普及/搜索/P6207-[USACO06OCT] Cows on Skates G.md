# 题目信息

# [USACO06OCT] Cows on Skates G

## 题目描述

**本题使用 Special Judge。**

Farmer John 把农场划分为了一个 $r$ 行 $c$ 列的矩阵，并发现奶牛们无法通过其中一些区域。此刻，Bessie 位于坐标为 $(1,1)$ 的区域，并想到坐标为 $(r,c)$ 的牛棚享用晚餐。她知道，以她所在的区域为起点，每次移动至相邻的四个区域之一，总有一些路径可以到达牛棚。

这样的路径可能有无数种，请你输出任意一种，并保证所需移动次数不超过 $100000$。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le r\le 113$，$1\le c\le 77$。

------------

**【样例说明】* *

![](https://cdn.luogu.com.cn/upload/image_hosting/3gsutffb.png)

图为样例输出的示意图。答案不唯一。

## 样例 #1

### 输入

```
5 8
..*...**
*.*.*.**
*...*...
*.*.*.*.
....*.*.```

### 输出

```
1 1
1 2
2 2
3 2
3 3
3 4
2 4
1 4
1 5
1 6
2 6
3 6
3 7
3 8
4 8
5 8```

# AI分析结果

### 综合分析与结论

本题解主要围绕DFS和BFS两种搜索算法展开，核心目标是找到从起点到终点的任意一条路径。题解中大部分作者选择了DFS，部分作者选择了BFS。DFS的优势在于代码简洁，适合路径记录；BFS的优势在于能够保证找到最短路径，但路径记录稍显复杂。

#### 关键思路与技巧：
1. **DFS路径记录**：通过递归调用DFS时记录路径，找到终点后直接输出路径。注意避免回溯时取消标记，以提高效率。
2. **BFS路径记录**：通过记录每个节点的前驱节点，最后从终点回溯到起点输出路径。
3. **剪枝优化**：在DFS中，找到一条路径后立即终止搜索，避免不必要的递归调用。
4. **数据结构选择**：部分题解使用了栈来记录路径，简化了路径的输出逻辑。

#### 通用建议与扩展思路：
- **DFS与BFS的选择**：DFS适合路径记录，BFS适合最短路径问题。根据题目需求选择合适的算法。
- **路径记录技巧**：无论是DFS还是BFS，路径记录都可以通过数组或栈来实现，关键在于如何高效地存储和输出路径。
- **剪枝与优化**：在搜索过程中，尽早剪枝可以大幅提高效率，尤其是在路径不唯一的情况下。

### 推荐题解

#### 1. 作者：MY（一名蒟蒻） (赞：122)
- **星级**：★★★★☆
- **关键亮点**：使用DFS并巧妙避免了回溯时的取消标记，代码简洁且高效。
- **个人心得**：作者提到“book数组不需要取消标记”，这是DFS剪枝的关键，避免了不必要的递归调用。

```cpp
void dfs(int x,int y,int step)
{
	if(x < 1 || x > r || y < 1 || y > c) return ;//越界
	if(book[x][y]) return ;//来过
	if(farm[x][y] == '*') return ;//无法通行
	if(f) return ;//输出过路径
	if(x == r && y == c)//找到终点
	{
		for(int i=1;i<step;i++) printf("%d %d\n",ax[i],ay[i]);//输出，注意这里是i<step，因为窝们煤油把终点存进数组
		printf("%d %d",r,c);//所以需要单独输出
		f=true;//标记为以输出
		return ;
	}
	ax[step]=x;ay[step]=y;//将当前点坐标存入数组
	book[x][y]=1;//标记已走过
	for(int i=0;i<4;i++)
	{
		dfs(x+next[i][0],y+next[i][1],step+1);//继续搜索
		if(f) return ;//保险起见
	} 
	return ;
}
```

#### 2. 作者：☆木辛土申☆ (赞：16)
- **星级**：★★★★☆
- **关键亮点**：使用BFS并记录路径，通过递归输出路径，思路清晰。
- **个人心得**：作者提到“在普通的bfs上加上路径的存储即可”，这是BFS路径记录的经典做法。

```cpp
void WriteWay(int x,int y){
	if(!(dist[x][y][0]+dist[x][y][1])) return;
    //如果数组中为0，表示到头了，return
	WriteWay(dist[x][y][0],dist[x][y][1]);
	printf("%d %d\n",x,y);//递归输出路径
}
```

#### 3. 作者：Ryo_Yamada (赞：8)
- **星级**：★★★★☆
- **关键亮点**：使用DFS并强调路径记录数组需要回溯，但访问数组不需要回溯，避免了TLE。
- **个人心得**：作者提到“记录路径数组需要回溯，但记录访问数组不用回溯”，这是DFS剪枝的重要技巧。

```cpp
void dfs(int x, int y, int step) {
	if(x == r && y == c) {
		cout << "1 1\n"; //不要忘了第一步的1 1
		for(int i = 0; i < step; i++) {
			cout << a[i][0] << " " << a[i][1] << endl;
		}
		exit(0);
	}
	for(int i = 0; i < 4; i++) {
		int tx = x + dx[i], ty = y + dy[i];
		if(in(tx, ty) && !vis[tx][ty] && maze[tx][ty] == '.') {
			vis[tx][ty] = true;
			a[step][0] = tx, a[step][1] = ty;
			dfs(tx, ty, step + 1);
			//vis[tx][ty] = false;（vis数组不回溯）
			a[step][0] = a[step][1] = 0;//路径要回溯
		}
	}
}
```

### 推荐题目
1. [P1605 迷宫](https://www.luogu.com.cn/problem/P1605) - 经典的DFS/BFS迷宫问题，适合练习路径记录。
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443) - BFS的典型应用，适合练习最短路径问题。
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - 结合DFS/BFS的填充问题，适合练习搜索算法的应用。

---
处理用时：48.94秒
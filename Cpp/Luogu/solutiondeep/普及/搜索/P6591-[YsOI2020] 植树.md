# 题目信息

# [YsOI2020] 植树

## 题目背景


Ysuperman 响应号召，决定在幼儿园里植树。

## 题目描述

Ysuperman 有一棵 $n$ 个节点的无根树 $T$。如果你不知道树是什么，TA 很乐意告诉你，树是一个没有环的无向联通图。

既然树是无根的，那就没有办法种植。Ysuperman 研究了很久的园艺，发现一个节点如果可以成为根，它必须十分平衡，这意味着以它为根时，与它**直接相连的节点，他们的子树大小都相同**。

你作为幼儿园信息组一把手，Ysuperman 给你一棵树，你能在 $1s$ 内找到所有可能成为根的节点吗？

## 说明/提示

### 样例说明

#### 样例说明 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/gsiug69y.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1\}$，因为只有一个所以大小全部相同。

所以答案为 $1,2$。

#### 样例说明 $2$

![](https://cdn.luogu.com.cn/upload/image_hosting/p7fsretv.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1,3\}$，子树大小分别为 $\{1,2\}$，不相同。

以 $3$ 为根时，与 $3$ 直接相连的点有 $\{2,4\}$，子树大小分别为 $\{2,1\}$，不相同。

以 $4$ 为根时，与 $4$ 直接相连的点有 $\{3\}$，因为只有一个所以大小全部相同。

所以答案为 $1,4$。

----

### 数据范围

**本题采用捆绑测试。**

| $\rm{subtask}$ | $n$ |  分数|
| :-----------: | :-----------: | :----: |
| $1$ | $\le 5000$ | $40$ |
| $2$ | $\le 10^6$ | $60$ |

对于 $100\%$ 的数据，满足 $1 \le n\le 10^6$。

------

### 提示

由于输入输出量较大，你可能需要快速输入/输出。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
1 2 ```

## 样例 #2

### 输入

```
4
1 2
2 3
3 4
```

### 输出

```
1 4 
```

## 样例 #3

### 输入

```
9
1 2
1 3
4 1
5 1
1 6
1 9
8 1
1 7
```

### 输出

```
1 2 3 4 5 6 7 8 9 
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地判断每个节点是否可以作为根节点，使得其所有直接相连的子树的子树大小相同。由于数据规模较大（$n \leq 10^6$），直接暴力枚举每个节点作为根节点的时间复杂度为 $O(n^2)$，无法通过测试。因此，大多数题解都采用了以下思路：

1. **以某个节点为根进行DFS**：首先选择一个节点（通常是1号节点）作为根，进行一次DFS，计算每个节点的子树大小。
2. **判断每个节点是否可以作为根**：在DFS过程中或之后，通过比较每个节点的子树大小，判断其是否满足条件。通常需要比较其所有子树的子树大小是否相同，并且与整棵树的大小减去该节点子树大小的值进行比较。
3. **优化判断过程**：通过记录子树大小的比较值，避免重复计算，确保时间复杂度为 $O(n)$。

### 所选高分题解

#### 1. 作者：WanderingTrader (5星)
- **关键亮点**：
  - 详细解释了如何通过一次DFS计算子树大小，并在DFS过程中判断每个节点是否可以作为根。
  - 代码结构清晰，逻辑严谨，优化了判断过程，确保时间复杂度为 $O(n)$。
  - 提供了手算样例，帮助理解算法的正确性。
  
- **核心代码**：
  ```cpp
  int dfs(int x,int fa)
  {
      int size = es[x].size(),num = 0;
      root[x] = 1;
      _for(0,size - 1)
          if(es[x][i] != fa)
          {
              d[x] += dfs(es[x][i],x);
              if(!num)
                  num = d[es[x][i]];
              if(num != d[es[x][i]]) root[x] = 0;
          }
      ++ d[x]; 
      if(x != 1 && num && num != n - d[x]) root[x] = 0;
      return d[x];
  }
  ```
  - **实现思想**：在DFS过程中，计算每个节点的子树大小，并记录第一个子树的子树大小，后续子树与之比较。如果不相同，则该节点不能作为根。最后，还需要比较整棵树的大小减去该节点子树大小的值是否与子树的子树大小相同。

#### 2. 作者：____OccDreamer (4星)
- **关键亮点**：
  - 通过变换树根的方式，避免了多次DFS，减少了时间复杂度。
  - 详细解释了如何通过一次DFS计算子树大小，并在后续判断中通过变换树根的方式快速判断每个节点是否可以作为根。
  
- **核心代码**：
  ```cpp
  void dfs(int x)
  {
      f[x]=1;
      siz[x]=1;
      for (int i=head[x];i;i=net[i])
      {
          if (!f[to[i]])
          {
              dfs(to[i]);
              siz[x]+=siz[to[i]];fa[to[i]]=x;
          }
      }
      return ;
  }
  ```
  - **实现思想**：通过一次DFS计算每个节点的子树大小，并在后续判断中通过变换树根的方式快速判断每个节点是否可以作为根。

#### 3. 作者：Pretharp (4星)
- **关键亮点**：
  - 提出了叶子节点一定满足条件的结论，并通过重心判断进一步优化了算法。
  - 代码简洁，逻辑清晰，适合理解重心在树中的应用。
  
- **核心代码**：
  ```cpp
  void dfs(int x, int fa) {
    siz[x] = 1, w[x] = 0;
    for (int i : v[x]) {
      if (i == fa) continue;
      dfs(i, x);
      siz[x] += siz[i], w[x] = max(w[x], siz[i]);
    }
    w[x] = max(w[x], n - siz[x]);
    if (w[x] <= n / 2) {
      c[++tot] = x;
    }
  }
  ```
  - **实现思想**：通过DFS计算每个节点的子树大小，并判断其是否为重心。如果是重心，则进一步判断其是否满足条件。

### 最优关键思路与技巧

1. **一次DFS计算子树大小**：通过一次DFS计算每个节点的子树大小，避免了多次DFS带来的高时间复杂度。
2. **子树大小比较**：在DFS过程中或之后，通过比较每个节点的子树大小，判断其是否可以作为根节点。
3. **重心优化**：通过判断重心，进一步优化算法，减少不必要的计算。

### 可拓展之处

- **类似题目**：可以拓展到其他树形结构的问题，如求树的直径、树的重心等。
- **算法套路**：通过一次DFS计算子树大小，并在后续判断中通过变换树根的方式快速判断每个节点是否满足条件，这种思路可以应用到其他树形结构的问题中。

### 推荐题目

1. **P1352 没有上司的舞会**：考察树形DP，与本题的子树大小计算有相似之处。
2. **P2015 二叉苹果树**：考察树形DP，与本题的子树大小计算有相似之处。
3. **P3379 【模板】最近公共祖先（LCA）**：考察树的遍历与LCA算法，与本题的DFS遍历有相似之处。

### 个人心得摘录

- **WanderingTrader**：通过手算样例验证算法的正确性，帮助理解算法的实现过程。
- **Pretharp**：提出了叶子节点一定满足条件的结论，并通过重心判断进一步优化了算法，这种思路值得借鉴。

---
处理用时：51.44秒
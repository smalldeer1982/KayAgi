# 题目信息

# [Code+#7] 最小路径串

## 题目描述

$n$ 个点 $m$ 条边的无向图中，所有点用从 `0` 开始的 `6` 位数字串编号，即 `000000`、`000001`、`000002`、……直到 $n-1$ 对应的 $6$ 位数字串。保证 $n\le 10^6$，所以 $6$ 位的编号不会溢出。

对于除了 `000000` 以外的每个点，你需要找到一条从 `000000` 出发且不经过重复点的路径，使得路径上所有点的数字串顺次连接形成的串的字典序最小。比较两个不同的串的字典序的方法是：如果其中某个串是另一个的前缀，则较短的串字典序较小；否则，找出两个串从左往右扫描时遇到的首个不相等的位置，在这个位置上的数字较小的串字典序较小。

由于输出路径过于麻烦，你不需要完整地输出路径，只需要将路径上所有点的数字串视作一个整数，输出这个数对 $998244353$ 取模的结果。

## 说明/提示

### 样例解释

- 从 `000000` 到 `000001` 所求的路径对应的串为 `000000000002000001`。
- 从 `000000` 到 `000002` 所求的路径对应的串为 `000000000002`。
- 从 `000000` 到 `000003` 所求的路径对应的串为 `000000000002000001000003`，对 $998244353$ 取模后为 $517560944$。
- 从 `000000` 到 `000004` 不存在路径。

### 子任务

子任务 $1$（$11$ 分）
- $1\le n\le 10^6, m = 0$。

子任务 $2$（$55$ 分）
- $1\le n\le 10, 0\le m\le20$。

子任务 $3$（$34$ 分）
- $1\le n\le 10^6, 0\le m\le 10^6$。

## 样例 #1

### 输入

```
5 5
000000000003000001000003000001000002000002000000000002000003```

### 输出

```
2000001
2
517560944
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于找到从起点 `000000` 到其他所有点的字典序最小路径，并将路径上的节点编号拼接后对 `998244353` 取模。题解大多采用 **DFS** 或 **BFS** 结合贪心策略，通过优先访问编号较小的邻接节点来保证路径的字典序最小。大多数题解使用了邻接表存储图结构，并在遍历前对邻接表进行排序，以确保每次访问的都是当前最优的节点。

### 题解评分与亮点

#### 1. 作者：opzc35 (4星)
- **关键亮点**：思路清晰，代码简洁，使用了邻接表和 DFS，并在遍历前对邻接表进行排序，确保字典序最小。代码中使用了 `vector` 存储图结构，避免了内存浪费。
- **个人心得**：提醒处理重边和自环，强调了细节处理的重要性。
- **核心代码**：
  ```cpp
  void dfs(int u,ll now){
      ans[u]=now;
      for(auto v:g[u]){
          if(ans[v]!=-1)continue;
          dfs(v,(now*1000000+v)%mod);
      }
  }
  ```

#### 2. 作者：FZY_CZY (4星)
- **关键亮点**：详细解释了 DFS 的实现思路，强调了邻接表的优势，并提供了对重边和自环的处理方法。代码结构清晰，注释详细。
- **个人心得**：强调了 `long long` 的重要性，提醒了取模操作的细节。
- **核心代码**：
  ```cpp
  void dfs(int u,LL now){
      ans[u]=now;
      for (auto v:g[u]){
          if (ans[v]!=-1) continue;
          dfs(v,(now*1000000+v)%Mod);
      }
  }
  ```

#### 3. 作者：SUNCHAOYI (4星)
- **关键亮点**：通过排序邻接表确保字典序最小，代码逻辑清晰，注释详细，便于理解。强调了无向图和自环的处理。
- **个人心得**：解释了如何通过排序保证字典序最小，并提供了具体的例子。
- **核心代码**：
  ```cpp
  void dfs(int st,ll s){
      ans[st]=s;
      for(int i=0;i<e[st].size();i++)
          if(ans[e[st][i]]==-1)
              dfs(e[st][i],(s*1000000+e[st][i])%MOD);
  }
  ```

### 最优关键思路与技巧

1. **邻接表存储图**：使用 `vector` 存储邻接表，既节省内存又便于遍历。
2. **排序邻接表**：在 DFS 或 BFS 前对邻接表进行排序，确保每次访问的都是当前字典序最小的节点。
3. **DFS 遍历**：通过 DFS 遍历图，记录路径并计算拼接后的数字，最后取模。
4. **处理重边和自环**：在输入时过滤掉自环，避免重复访问。

### 可拓展之处

- **类似算法套路**：该题的思路可以推广到其他需要字典序最小或最大的路径问题，如最短路径、最小生成树等。
- **BFS 优化**：可以考虑使用优先队列（堆）来实现 BFS，进一步优化字典序的处理。

### 推荐题目

1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)

### 个人心得总结

- **调试经历**：多位作者提到在处理输入时需要注意字符转数字的细节，尤其是自环和重边的处理。
- **踩坑教训**：部分题解提醒了 `long long` 的使用，避免溢出问题。
- **顿悟感想**：通过排序邻接表来保证字典序最小，是解决此类问题的关键技巧。

---
处理用时：39.47秒
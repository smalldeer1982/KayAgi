# 题目信息

# 选择题

## 题目背景

小 L 喜欢逻辑推理。

一天，他在一本由英国哲士沃·协德编写的《我也不知道为什么要叫这个名字的一本有关逻辑学的书》中翻到了一道奇特的问题，但他并不会做。他知道你善于用程序解决问题，于是决定让你来帮助他完成这些问题。

## 题目描述

这是一道有 $n$ 个选项的选择题，每个选项的内容都很独特。第 $i$ 个选项的内容的形式如下：

+ 第 $a_i$ 个选项是正确/错误的

小 L 认为这种题目的答案不一定是唯一的，所以他想问题这道题有多少种合法的答案（可以全部正确或全部错误）。他还想问你这么多答案中，正确选项最多和最少的答案分别有多少个正确选项。

当然，如果这道题不存在合法的答案，你可以直接回答小 L `No answer`。

## 说明/提示

对于样例一，一共有下面 $2$ 种正确答案：

+ 第 $1,2,3$ 个选项是正确的。
+ 第 $4$ 个选项是正确的。

其中正确选项最多的答案有 $3$ 个选项正确，正确选项最少的答案有 $1$ 个选项正确。

### 数据范围
对于 $10\%$ 的数据，$n\leq 10$。  
对于 $30\%$ 的数据，$n\leq 100$。  
对于 $60\%$ 的数据，$n\leq 10^3$。  
对于 $100\%$ 的数据，$n\leq 10^6,1\leq a_i\leq n,i\neq a_i,opt_i\in\{0,1\}$。

## 样例 #1

### 输入

```
4
2 1
4 0
1 1
2 0```

### 输出

```
2
3
1```

## 样例 #2

### 输入

```
10
4 1
7 0
2 0
3 1
7 1
5 0
9 1
10 1
8 0
1 1```

### 输出

```
No answer```

# AI分析结果

### 综合分析与结论

本题的核心是通过给定的选项关系，判断是否存在合法的答案，并计算合法答案的数量、最多和最少正确选项的数量。题解中主要采用了以下几种思路：

1. **并查集（带权并查集）**：通过并查集维护选项之间的关系，判断是否存在矛盾，并计算合法答案的数量。
2. **图论（BFS/DFS）**：将选项关系转化为图，通过染色法判断图的合法性，并计算合法答案的数量。
3. **扩展域并查集**：将每个选项扩展为两个节点，分别表示其正确和错误的状态，通过并查集维护这些状态之间的关系。

### 所选高星题解

#### 1. 作者：lnwzy (赞：18)  
**星级：5星**  
**关键亮点：**
- 使用带权并查集维护选项之间的关系，路径压缩时更新关系数组，确保并查集的正确性。
- 通过并查集的合并操作判断是否存在矛盾，并计算合法答案的数量。
- 代码简洁清晰，逻辑严谨，适合理解并查集的应用。

**核心代码：**
```cpp
int fa(int x) {
    if(f[x]==x) return f[x];
    int t=f[x];
    f[x]=fa(f[x]);
    r[x]=(r[t]+r[x])%2; // 更新关系数组
    return f[x];
}
```

#### 2. 作者：littleKtian (赞：16)  
**星级：4星**  
**关键亮点：**
- 将选项关系转化为图，通过BFS染色判断图的合法性，并计算合法答案的数量。
- 通过连通块的染色方案计算最多和最少正确选项的数量。
- 思路清晰，代码结构良好，适合理解图论的应用。

**核心代码：**
```cpp
void BFS_color(int num, int Color) {
    color[num] = Color;
    queue<int> q;
    q.push(num);
    while (!q.empty()) {
        int top = q.front();
        q.pop();
        for (int i = head[top]; i; i = e[i].next) {
            int tv = e[i].v;
            if (color[tv] == color[top] && e[i].w == 0) {
                flag = 1; // 判断无解
                return;
            }
            if (color[tv] + color[top] == 3 && e[i].w == 1) {
                flag = 1; // 判断无解
                return;
            }
            if (!vis[tv]) {
                color[tv] = (e[i].w == 1) ? color[top] : 3 - color[top];
                q.push(tv);
            }
        }
    }
}
```

#### 3. 作者：lndjy (赞：4)  
**星级：4星**  
**关键亮点：**
- 通过DFS染色判断选项关系的合法性，并计算合法答案的数量。
- 通过连通块的染色方案计算最多和最少正确选项的数量。
- 代码简洁，逻辑清晰，适合理解DFS的应用。

**核心代码：**
```cpp
void dfs(int now, int co) {
    v[now] = co + 1;
    c[co]++;
    for (int i = head[now]; i; i = e[i].nxt) {
        if (v[e[i].to] == (co ^ e[i].w) + 1) {
            cout << "No answer";
            exit(0);
        }
        if (v[e[i].to]) continue;
        dfs(e[i].to, co ^ (!e[i].w));
    }
}
```

### 最优关键思路与技巧

1. **带权并查集**：通过并查集维护选项之间的关系，路径压缩时更新关系数组，确保并查集的正确性。这种方法在处理关系类问题时非常高效。
2. **图论染色法**：将选项关系转化为图，通过BFS或DFS染色判断图的合法性，并计算合法答案的数量。这种方法直观且易于理解。
3. **扩展域并查集**：将每个选项扩展为两个节点，分别表示其正确和错误的状态，通过并查集维护这些状态之间的关系。这种方法在处理复杂关系时非常有效。

### 拓展思路与推荐题目

1. **同类型题目**：
   - [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)：使用并查集维护罪犯之间的关系。
   - [P2024 食物链](https://www.luogu.com.cn/problem/P2024)：使用带权并查集维护动物之间的关系。
   - [P1892 团伙](https://www.luogu.com.cn/problem/P1892)：使用并查集维护团伙之间的关系。

2. **调试与顿悟**：
   - **调试经历**：在处理带权并查集时，路径压缩时更新关系数组是关键，调试时需确保关系数组的正确性。
   - **顿悟感想**：将选项关系转化为图，通过染色法判断合法性，这种方法在处理复杂关系时非常直观且有效。

### 总结

本题的题解中，带权并查集和图论染色法是两种主要的解题思路，各有优劣。带权并查集在处理关系类问题时非常高效，而图论染色法则更加直观且易于理解。推荐在实际解题中根据问题的特点选择合适的算法。

---
处理用时：45.44秒
# 题目信息

# 最大公约数

## 题目背景

&emsp;&emsp;“寻求最大公约数是人民民主的真谛。……”

&emsp;&emsp;初秋，从枝丫滴下的阳光，柔和，在教室的窗棱溅起，润湿晨读的少女的脸颊。

&emsp;&emsp;“阿绫，阿绫”，天依低俯身子，八字辫耷拉在竖起的课本沿，“我们的最大公约数是多少呢？”

&emsp;&emsp;“一定不小吧”，左手悄悄捏捏天依的小臂，“比如呀，有一个公因子，叫做‘你喜欢我，我也喜欢你’。”

## 题目描述

相反，人际圈形形色色，公约数小得可怜，似乎很难保持自己的个性因而变成无趣的人呢。

现在把人际抽象成一个 $n \times m$ 的矩形，每个人初始的个性为 $a_{i,j}$。从第二天开始，每个人会与上下左右四个人（如果存在）建立人际关系，其个性变为昨天自己和四周人个性的最大公约数。那么对于第 $x$ 行第 $y$ 列的人，在多少天后他的个性会变为 $1$ 呢？

----

#### 简化题意

有一个 $n \times m$ 的矩阵 $a$。对一个矩阵进行变换，定义为将这个矩阵内的所有元素变为其上下左右四个元素（不存在则忽略）及自身的最大公约数。询问 $a_{x,y}$ 在进行最少多少次变换之后会变成 $1$。如果可以使 $a_{x,y}$ 经过若干次变换变成 $1$，输出其中最小的次数；否则输出 $-1$。

## 说明/提示

#### 样例解释 3
第一天的个性矩阵（也就是最开始的矩阵）为
$$
\begin{pmatrix}
3&2&3\\
2&3&2\\
3&2&3
\end{pmatrix}
$$
第二天的个性矩阵为
$$
\begin{pmatrix}
1&1&1\\
1&1&1\\
1&1&1
\end{pmatrix}
$$
可见只需要经过一天，$a_{2,2}$ 就会变为 $1$，所以答案为 $1$。

#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^3$，$1\le a_{i,j}\le 10^{18}$，$1\le x\le n$，$1\le y\le m$。

| 子任务 | 分值 |        $n,m$        |              特殊限制              |
| :----: | :--: | :-----------------: | :--------------------------------: |
|   1    |  1   |          /          | 保证给出的位置个性永远不会变为 $1$ |
|   2    |  1   |          /          |          保证 $a_{x,y}=1$          |
|   3    |  3   |      $ \le 2$       |                 /                  |
|   4    |  10  |     $ \le 10^2$     |                 /                  |
|   5    |  30  | $ \le 5\times 10^2$ |           /            |
|   6    |  10  |          /          |   保证对于所有的 $a_{i,j} \le 2$   |
|   7    |  10  |          /          |     保证 $x$ 与 $y$ 都等于 $1$     |
|   8    |  35  |          /          |                 /                  |





------------




## 样例 #1

### 输入

```
2 2
2 2
1 2
2 1```

### 输出

```
0```

## 样例 #2

### 输入

```
2 2
2 2 
2 2
1 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
3 3
3 2 3
2 3 2
3 2 3
2 2```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心在于通过模拟矩阵变换过程，找到目标点变为1的最小天数。主要难点在于如何高效地计算每次变换后的矩阵，并判断目标点何时变为1。大多数题解采用了BFS或曼哈顿距离的策略，结合GCD计算来优化时间复杂度。

### 所选题解

#### 1. 作者：vectorwyx (赞：63)
- **星级**：★★★★★
- **关键亮点**：
  - 通过BFS从目标点出发，逐步扩展范围，计算GCD，直到目标点变为1。
  - 时间复杂度为O(nm log(k))，较为高效。
  - 代码清晰，逻辑严谨，易于理解。
- **核心代码**：
  ```cpp
  void bfs(){
      queue<int> qx,qy,qs;
      qx.push(sx),qy.push(sy),qs.push(0);
      vis[sx][sy]=1;
      ll sum=a[sx][sy];
      while(!qx.empty()){
          int x=qx.front(),y=qy.front(),s=qs.front();
          qx.pop(),qy.pop(),qs.pop();
          fo(i,0,3){
              int tx=x+dx[i],ty=y+dy[i];
              if(tx<1||tx>n||ty<1||ty>m||vis[tx][ty]) continue;
              vis[tx][ty]=1;
              qx.push(tx),qy.push(ty),qs.push(s+1);
              sum=__gcd(sum,a[tx][ty]);
              if(sum==1){
                  cout<<s+1;
                  return;
              }
          }
      }
      cout<<-1;
  }
  ```
  - **实现思想**：通过BFS从目标点出发，逐步扩展范围，计算GCD，直到目标点变为1。

#### 2. 作者：_zy_ (赞：21)
- **星级**：★★★★
- **关键亮点**：
  - 通过BFS从目标点出发，逐步扩展范围，计算GCD，直到目标点变为1。
  - 代码简洁，逻辑清晰，易于理解。
- **核心代码**：
  ```cpp
  void bfs(int x,int y)
  {
      int head,tail;
      head=tail=0;
      q[++tail][0]=x; q[tail][1]=y;
      v[x][y]=1;
      while(head<tail)
      {
          int X=q[++head][0];
          int Y=q[head][1];
          for(int i=1;i<=4;i++)
          {
              int xx=X+dx[i]; int yy=Y+dy[i];
              if(v[xx][yy]||xx<1||yy<1||xx>n||yy>m)	continue;
              q[++tail][0]=xx;
              q[tail][1]=yy;
              q[tail][2]=q[head][2]+1;
              v[xx][yy]=1;
              tot=gcd(tot,a[xx][yy]);
          }
          if(tot==1) {
              cout<<q[tail][2]<<endl;
              exit(0);
          }
      }
  }
  ```
  - **实现思想**：通过BFS从目标点出发，逐步扩展范围，计算GCD，直到目标点变为1。

#### 3. 作者：Just_A_King (赞：14)
- **星级**：★★★★
- **关键亮点**：
  - 通过曼哈顿距离计算，逐步扩展范围，计算GCD，直到目标点变为1。
  - 时间复杂度为O(nm log(n))，较为高效。
  - 代码清晰，逻辑严谨，易于理解。
- **核心代码**：
  ```cpp
  void bfs(int x,int y)
  {
      int head,tail;
      head=tail=0;
      q[++tail][0]=x; q[tail][1]=y;
      v[x][y]=1;
      while(head<tail)
      {
          int X=q[++head][0];
          int Y=q[head][1];
          for(int i=1;i<=4;i++)
          {
              int xx=X+dx[i]; int yy=Y+dy[i];
              if(v[xx][yy]||xx<1||yy<1||xx>n||yy>m)	continue;
              q[++tail][0]=xx;
              q[tail][1]=yy;
              q[tail][2]=q[head][2]+1;
              v[xx][yy]=1;
              tot=gcd(tot,a[xx][yy]);
          }
          if(tot==1) {
              cout<<q[tail][2]<<endl;
              exit(0);
          }
      }
  }
  ```
  - **实现思想**：通过曼哈顿距离计算，逐步扩展范围，计算GCD，直到目标点变为1。

### 最优关键思路或技巧
- **BFS扩展**：从目标点出发，逐步扩展范围，计算GCD，直到目标点变为1。
- **曼哈顿距离**：通过曼哈顿距离计算，逐步扩展范围，计算GCD，直到目标点变为1。

### 可拓展之处
- **类似算法套路**：可以应用于其他需要逐步扩展范围并计算某种属性的问题，如最短路径、最大流等。
- **同类型题**：可以尝试解决其他需要模拟变换过程的问题，如矩阵旋转、矩阵填充等。

### 推荐题目
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)

### 个人心得
- **调试经历**：在实现BFS时，需要注意边界条件的处理，避免数组越界。
- **踩坑教训**：在计算GCD时，需要确保输入的数为正整数，避免出现负数导致计算错误。
- **顿悟感想**：通过逐步扩展范围并计算GCD，可以高效地解决矩阵变换问题。

---
处理用时：49.57秒
# 题目信息

# [蓝桥杯 2018 国 C] 迷宫与陷阱

## 题目描述

小明在玩一款迷宫游戏，在游戏中他要控制自己的角色离开一间由 $N \times N$ 个格子组成的二维迷宫。

小明的起始位置在左上角，他需要到达右下角的格子才能离开迷宫。

每一步，他可以移动到上下左右相邻的格子中（前提是目标格子可以经过）。

迷宫中有些格子小明可以经过，我们用 `.` 表示；

有些格子是墙壁，小明不能经过，我们用 `#` 表示。

此外，有些格子上有陷阱，我们用 `X` 表示。除非小明处于无敌状态，否则不能经过。

有些格子上有无敌道具，我们用 `%` 表示。

当小明第一次到达该格子时，自动获得无敌状态，无敌状态会持续 $K$ 步。

之后如果再次到达该格子不会获得无敌状态了。

处于无敌状态时，可以经过有陷阱的格子，但是不会拆除 / 毁坏陷阱，即陷阱仍会阻止没有无敌状态的角色经过。

给定迷宫，请你计算小明最少经过几步可以离开迷宫。

## 说明/提示

时限 3 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
5 3
...XX
##%#.
...#.
.###.
.....```

### 输出

```
10```

## 样例 #2

### 输入

```
5 1
...XX
##%#.
...#.
.###.
.....```

### 输出

```
12```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在BFS的基础上处理无敌状态和陷阱的交互。所有题解都采用了BFS作为基础算法，但在处理无敌状态和陷阱时，各自有不同的优化和实现方式。以下是各题解的要点总结：

1. **Zaku的题解**：通过`vis`数组记录每个格子的无敌状态剩余步数，并在此基础上进行剪枝，避免重复访问。代码清晰，剪枝逻辑合理，优化效果显著。
2. **DreamLand_zcb的题解**：通过`st`和`ti`数组分别记录步数和无敌时间，优化了状态存储，避免了三维数组的使用，减少了空间复杂度。
3. **_cpp的题解**：在结构体中加入了无敌步数，并通过`book`数组进行剪枝，思路清晰，代码简洁。
4. **wuhan1234的题解**：通过`vis`数组记录最多无敌状态剩余步数，优化了状态访问，避免了重复访问，思路清晰。
5. **Lemonlwl的题解**：使用了三维`vis`数组记录不同无敌状态下的访问情况，逻辑清晰，但空间复杂度较高。

### 所选高星题解

#### 1. Zaku的题解（5星）
**关键亮点**：
- 通过`vis`数组记录无敌状态剩余步数，剪枝逻辑清晰，优化效果显著。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
int vis[N][N]; // 存储每个格子是否被访问过以及无敌状态剩余步数
struct node{
    int x, y, step, magic;
};

int main(){
    // 初始化
    memset(vis, -1, sizeof vis);
    queue<node> q;
    vis[1][1] = 0;
    q.push({1, 1, 0, 0});
    while (q.size()){
        node t = q.front();
        q.pop();
        if (t.x == n && t.y == n){
            cout << t.step;
            return 0;
        }
        for (int i = 0; i < 4; i ++ ){
            int tx = t.x + dx[i];
            int ty = t.y + dy[i];
            if (g[tx][ty] == 'X' && t.magic == 0) continue;
            int magic = max(0, t.magic - 1);
            if (g[tx][ty] == '%') magic = k;
            if (tx >= 1 && tx <= n && ty >= 1 && ty <= n && vis[tx][ty] < magic && g[tx][ty] != '#'){
                vis[tx][ty] = magic;
                q.push({tx, ty, t.step + 1, magic});
            }
        }
    }
    cout << -1;
    return 0;
}
```

#### 2. DreamLand_zcb的题解（4星）
**关键亮点**：
- 通过`st`和`ti`数组分别记录步数和无敌时间，优化了状态存储，避免了三维数组的使用。
- 剪枝逻辑合理，代码结构清晰。

**核心代码**：
```cpp
int st[1005][1005]; // 到(x, y)时的步数 
int ti[1005][1005]; // 到(x, y)时的无敌时间 

void bfs(){
    queue <node> q;
    q.push((node){1, 1, 0, 0});
    ti[1][1] = 0;
    st[1][1] = 0;
    while(!q.empty()){
        node t = q.front();
        q.pop();
        int x = t.x, y = t.y, step = t.step, inv = t.inv;
        if(x == n && y == n){
            f = 1;
            ans = step;
            break;
        }
        inv--;
        step++;
        for(int i=0;i<4;i++){
            int X = x + dx[i];
            int Y = y + dy[i];
            if(check(X, Y, step, inv)){
                if(c[X][Y] == '%' && st[X][Y] == INF) inv = k;
                st[X][Y] = step;
                ti[X][Y] = inv;
                q.push((node){X, Y, inv, step});
            }
        }
    }
}
```

#### 3. _cpp的题解（4星）
**关键亮点**：
- 在结构体中加入了无敌步数，并通过`book`数组进行剪枝，思路清晰，代码简洁。
- 剪枝逻辑合理，优化效果显著。

**核心代码**：
```cpp
struct edge{
    int x,y,invincible,sum;
};
int book[1001][1001];

int main(){
    cin >> n >> x;
    for(int i = 1;i <= n;i++)
        for(int j = 1;j <= n;j++) cin >> a[i][j],book[i][j] = -1;
    edge t;
    t.x = 1,t.y = 1,t.invincible = 0,t.sum = 0;
    q.push(t);
    book[1][1] = 0;
    while(!q.empty()){
        t = q.front();
        q.pop();
        if(t.x == n && t.y == n) return cout << t.sum,0;
        edge k;
        for(int i = 0;i < 4;i++){
            int dx = t.x + nx[i];
            int dy = t.y + ny[i];
            if(a[dx][dy] == 'X' && t.invincible == 0) continue;
            if(a[dx][dy] == '#') continue;
            k.invincible = max(0,t.invincible - 1);
            if(a[dx][dy] == '%') k.invincible = x;
            if(dx >= 1 && dx <= n && dy >= 1 && dy <= n && k.invincible > book[dx][dy]){
                k.x = dx;
                k.y = dy;
                book[dx][dy] = k.invincible;
                k.sum = t.sum + 1;
                q.push(k);
            }
        }
    }
    cout << "-1";
    return 0;
}
```

### 最优关键思路与技巧

1. **状态记录与剪枝**：通过`vis`数组记录每个格子的无敌状态剩余步数，避免重复访问，优化了BFS的效率。
2. **结构体设计**：在结构体中加入无敌步数，方便在BFS过程中维护状态。
3. **剪枝逻辑**：如果当前状态的无敌步数少于之前访问时的无敌步数，则不再访问该节点，避免不必要的计算。

### 可拓展之处

- **类似题目**：可以扩展到其他带有状态变化的BFS问题，如带有时间限制的迷宫、带有特殊道具的路径搜索等。
- **算法套路**：在处理带有状态变化的BFS问题时，可以通过记录状态信息进行剪枝，优化算法效率。

### 推荐题目

1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

### 个人心得总结

- **调试经历**：在处理无敌状态时，需要特别注意无敌步数的更新和剪枝逻辑，避免重复访问和无效计算。
- **踩坑教训**：在使用`vis`数组时，初始值应设置为一个不可能的值（如-1），以避免与有效状态冲突。
- **顿悟感想**：通过记录状态信息进行剪枝，可以显著优化BFS的效率，尤其是在处理复杂状态变化时。

---
处理用时：76.23秒
# 题目信息

# [传智杯 #3 决赛] 面试

## 题目背景

disangan233 和 disangan333 去面试了，面试官给了一个问题，热心的你能帮帮他们吗？

## 题目描述

现在有 $n$ 个服务器，服务器 $i$ 最多能处理 $a_i$ 大小的数据。

接下来会有 $k$ 条指令 $b_k$，指令 $i$ 表示发送 $b_i$ 的数据，需要你分配一个空闲的服务器。

请你算出一个序列 $p_k$ 表示指令 $i$ 的数据分配给服务器 $p_i$，且 $p_k$ 的字典序最小；如果无法分配，输出 "-1"。

对于所有数据，$n,k\leq 6$，$a_i,b_i \leq 10$。 

## 说明/提示

### 样例解释

第 1 条指令分给服务器 1；  
第 2 条指令分给服务器 3；  
第 3 条指令分给服务器 2；  
第 4 条指令分给服务器 4；  
第 5 条指令分给服务器 6；  
第 6 条指令分给服务器 5。

## 样例 #1

### 输入

```
6 6
1 9 1 9 8 1
1 1 4 5 1 4```

### 输出

```
1 3 2 4 6 5```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何在给定的服务器和指令之间进行匹配，并输出字典序最小的匹配序列。由于数据范围较小（$n, k \leq 6$），题解中主要采用了深度优先搜索（DFS）和排列枚举的方法。DFS的思路是通过递归尝试所有可能的匹配，找到第一个满足条件的序列即可；排列枚举则是利用全排列的性质，通过`next_permutation`函数枚举所有可能的排列，找到符合条件的排列。

#### 最优关键思路与技巧：
1. **DFS回溯法**：通过递归尝试所有可能的匹配，找到第一个满足条件的序列。这种方法在数据范围较小时非常适用，且能保证找到字典序最小的解。
2. **排列枚举**：利用全排列的性质，通过`next_permutation`函数枚举所有可能的排列，找到符合条件的排列。这种方法虽然简单，但在数据范围较小时也能有效解决问题。
3. **剪枝优化**：在DFS中，可以通过提前判断某些条件（如服务器是否足够处理数据）来减少不必要的递归调用，从而提高效率。

#### 可拓展之处：
- **更大数据范围**：如果数据范围增大，DFS可能会因为递归深度过大而超时，此时可以考虑使用动态规划或贪心算法来优化。
- **多目标优化**：如果问题不仅仅要求字典序最小，还要求其他条件（如负载均衡），则可以考虑使用更复杂的算法，如线性规划或启发式搜索。

### 所选高星题解

#### 1. 作者：_H17_ (★★★★★)
**关键亮点**：
- 使用DFS回溯法，思路清晰，代码简洁。
- 通过`f`变量标记是否找到第一个解，确保输出字典序最小的序列。
- 代码可读性强，注释详细。

**核心代码**：
```cpp
void dfs(int s){
    if(s==k+1){
        if(f)
            for(int i=1;i<=n;i++)
                printf("%d ",p[i]);
        f=0;
        return;
    }
    for(int i=1;i<=n;i++)
        if(a[i]-b[s]>=0&&!u[i]){
            p[s]=i,u[i]=1;
            dfs(s+1);
            u[i]=0;
        }
    return;
}
```

#### 2. 作者：fengziyi (★★★★)
**关键亮点**：
- 使用DFS回溯法，思路清晰。
- 通过`vis`数组标记服务器是否被使用，确保每个服务器只被分配一次。
- 代码简洁，注释详细。

**核心代码**：
```cpp
bool dfs(int i){
    if (i > k){
        for (reg int i = 1; i <= k; ++i)
            printf("%d ", ans[i]);
        printf("\n"); return true;
    }
    for (reg int j = 1; j <= n; ++j)
        if (a[j] >= b[i] && vis[j] == false){
            vis[j] = 1; ans[i] = j;
            if (dfs(i + 1)) return true;
            vis[j] = 0;
        }
    return false;
}
```

#### 3. 作者：zaochen (★★★★)
**关键亮点**：
- 使用排列枚举法，思路新颖。
- 通过`next_permutation`函数枚举所有可能的排列，找到符合条件的排列。
- 代码简洁，注释详细。

**核心代码**：
```cpp
bool check(){
    for (int i=1;i<=n;i++)
        if (a[ans[i]]<b[i])
            return false;
    return true;
}
```

### 推荐相似题目
1. **P1036 选数**（DFS回溯法）
2. **P1706 全排列问题**（排列枚举）
3. **P1219 八皇后**（DFS回溯法）

### 个人心得摘录
- **调试经历**：在DFS中，忘记回溯时重置`vis`数组，导致程序无法正确找到所有解。通过调试发现并修复了这个问题。
- **顿悟感想**：DFS虽然简单，但在小数据范围内非常有效，且能保证找到字典序最小的解。

### 通用建议与扩展思路
- **小数据范围**：优先考虑DFS或排列枚举，思路简单且易于实现。
- **大数据范围**：考虑使用动态规划或贪心算法，避免递归深度过大导致的超时问题。
- **多目标优化**：在复杂问题中，可以考虑使用线性规划或启发式搜索来优化解的质量。

---
处理用时：42.08秒
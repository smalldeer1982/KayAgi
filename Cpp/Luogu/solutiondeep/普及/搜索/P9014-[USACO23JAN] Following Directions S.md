# 题目信息

# [USACO23JAN] Following Directions S

## 题目描述

**注：本题时限为 8s，是默认时限的四倍。**

Farmer John 有一个正方形的草地，草地被划分为了 $(N + 1) \times (N + 1)(1 \leq N \leq 1500)$ 的格子。设 $(i, j)$ 为从上到下、从左到右第 $i$ 行，第 $j$ 列的格子。每个满足 $1 \leq i, j \leq n$ 的格子 $(i, j)$ 之中都住着一头牛，而且每个这样的格子上都有一个路标指向右或下。除此之外，所有满足 $i = N + 1$ 或 $j = N + 1$ 的格子，除了 $(N + 1, N + 1)$ 都会有一个饲料桶。牛在每个饲料桶进食需要的价格不同；位置 $(i, j)$ 上的桶喂饱一只牛需要价格 $c_{i, j}(1 \leq c_{i, j} \leq 500)$。

每天晚饭时间，Farmer John 摇响晚餐铃时，所有牛都沿着路标的指向前进，直到它们遇到了饲料桶，之后它们会在它们自己遇到的饲料桶那里进食。第二天，所有牛又会回到自己原来的位置。

为了维持预算，Farmer John 想要知道每天喂食需要的价钱。然而，每天晚饭之前，总会有一头牛 $(i, j)$ 翻转它那里的路标（原来向下则变成向右，反之亦然）。被翻转的路标指向将在后面的日子里保持不变，除非它又被进行了翻转。

给出每天被翻转的路标的坐标，请输出每天喂食需要的价格（总共有 $Q$ 天，$1 \leq Q \leq 1500$）。

## 说明/提示

### 样例 1 解释

在第一次翻转之前，喂养在位置 $(1, 1)$ 和 $(1, 2)$ 的牛需要的价格都为 $1$，喂养在 $(2, 1)$ 的牛需要的价格为 $100$，喂养在 $(2, 2)$ 的牛需要的价格为 $500$。总价格为 $602$。第一次翻转后，在 $(1, 1)$ 处的路标由 `R` 变为 `D`，此时在位置 $(1, 1)$ 的牛喂养的价格变为 $100$（其它牛的价格没有变化），所以总价为 $701$。第二次和第三次翻转都在来回翻转同一个路标。第四次翻转后，在位置 $(1, 1)$ 和位置 $(2, 1)$ 的牛喂养的价格变为 $500$，总价变为 $1501$。


- 测试点 $2 - 4$ 中：$1 \leq N, Q \leq 50$。

- 测试点 $5 - 7$ 中：$1 \leq N, Q \leq 250$。

- 测试点 $2 - 10$ 中：每个路标初始朝向以及被翻转的路标为随机生成。

- 测试点 $11 - 15$ 中：无特殊条件。

## 样例 #1

### 输入

```
2
RR 1
DD 10
100 500
4
1 1
1 1
1 1
2 1```

### 输出

```
602
701
602
701
1501```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效处理每次路标翻转后的路径更新和总成本计算。大多数题解采用了类似的处理思路：预处理初始路径和成本，然后通过DFS或递推的方式在每次翻转后更新路径和成本。优化点主要集中在减少重复计算和利用数据结构（如数组、树）来快速更新路径信息。

### 所选高星题解

#### 题解1：yujinning (5星)
**关键亮点**：
- 将问题抽象为森林结构，每个饲料桶作为树的根，通过DFS预处理每个节点的子树大小和根信息。
- 每次翻转操作通过DFS更新子树信息，时间复杂度为O(nQ)，整体复杂度为O(n² + nQ)。
- 代码结构清晰，逻辑严谨，处理翻转操作时通过DFS快速更新子树信息。

**核心代码**：
```cpp
void dfs(ll x,ll y,ll fa){
    ll ider=id(x,y),iderx=id(x-1,y),idery=id(x,y-1);
    sz[ider]=1;
    f[ider]=fa;
    if(a[x][y-1]=='R'){
        son[ider].push_back(idery);
        dfs(x,y-1,fa);
        sz[ider]+=sz[idery];
    }
    if(a[x-1][y]=='D'){
        son[ider].push_back(iderx);
        dfs(x-1,y,fa);
        sz[ider]+=sz[iderx];
    }
}
```
**实现思想**：通过DFS预处理每个节点的子树大小和根信息，翻转操作时通过DFS更新子树信息。

#### 题解2：Nuyoah_awa (4星)
**关键亮点**：
- 从饲料桶开始反向DFS，预处理每个节点的路径和成本。
- 每次翻转操作通过DFS更新路径信息，时间复杂度为O(nQ)。
- 代码简洁，逻辑清晰，处理翻转操作时通过DFS快速更新路径信息。

**核心代码**：
```cpp
void dfs(long long x, long long y, long long sum){
    if(x == 0 || y == 0) return ;
    a[x][y] = sum;
    ans += sum;
    if(c[x-1][y] == 'D') dfs(x-1, y, sum);
    if(c[x][y-1] == 'R') dfs(x, y-1, sum);
}
```
**实现思想**：通过反向DFS预处理每个节点的路径和成本，翻转操作时通过DFS更新路径信息。

#### 题解3：EricWan (4星)
**关键亮点**：
- 预处理每个节点的路径和成本，翻转操作时通过DFS更新路径信息。
- 时间复杂度为O(n² + nQ)，代码简洁，逻辑清晰。
- 处理翻转操作时通过DFS快速更新路径信息。

**核心代码**：
```cpp
void dfs(int x, int y, int cnt, bool ok){
    if(ok) a[x][y] += cnt;
    if(y == n && c[x][y] == 'R') a[x][y+1] += cnt;
    else if(x == n && c[x][y] == 'D') a[x+1][y] += cnt;
    else if(c[x][y] == 'R') dfs(x, y+1, cnt, 1);
    else if(c[x][y] == 'D') dfs(x+1, y, cnt, 1);
}
```
**实现思想**：通过DFS预处理每个节点的路径和成本，翻转操作时通过DFS更新路径信息。

### 最优关键思路与技巧
1. **森林结构抽象**：将问题抽象为森林结构，每个饲料桶作为树的根，通过DFS预处理每个节点的子树大小和根信息。
2. **反向DFS**：从饲料桶开始反向DFS，预处理每个节点的路径和成本，翻转操作时通过DFS快速更新路径信息。
3. **路径更新优化**：通过DFS或递推的方式在每次翻转后快速更新路径信息，减少重复计算。

### 可拓展之处
- **动态路径更新**：类似问题可以扩展到动态更新路径的场景，如动态图中的最短路径更新。
- **树结构优化**：利用树结构进行路径更新和查询的优化，可以应用于其他树形结构的问题。

### 推荐题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
3. [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)

---
处理用时：36.70秒
# 题目信息

# [PA 2020] Wycieczka górska

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 4 [Wycieczka górska](https://sio2.mimuw.edu.pl/c/pa-2020-1/wyc/)**

一群 $k$ 个旅行者朋友去了 Byte 山。在最后一天，他们决定组织一场登山比赛，从他们所住的旅店到 Byte 山顶。

每个旅行者都有一张区域地图，它是一个分为 $n$ 行 $m$ 列的矩形；因此地图一共包含 $n\cdot m$ 个区域。旅店位于地图左上角的区域，而山顶则位于地图右下角的区域。Byte 山以其非常均匀而闻名——对于地图上的任何区域，在地图上与之相邻的右面或下面的区域海拔较高，而相邻的左边或上面区域海拔较低。但是，这座山也因潜伏着许多危险地区而闻名。有些地区在地图上标明是非常危险的，因为那里有野生动物居住——所以最好不要到那里去……

你是 Byte 山山脚下的一个小屋的看守人。通过观察每一个旅行者，你已经为他们每个人分配了两个参数 $a_i$ 和 $b_i$，这些参数决定了他们在山坡上的运动速度。具体来说，如果第 $i$ 个旅行者向更高的区域移动，那么他需要 $a_i$ 分钟，如果旅行者向更低的区域移动，则需要 $b_i$ 分钟。你也知道，每个旅行者都会走对他们来说从小屋到山顶最快的路线，并且路线完全在地形图上，而且避开了所有的危险区域。

你想知道最快的人需要多长时间才能到达山顶，有多少人将与最快的人同时爬到山顶。你可以假设，从小屋到山顶至少有一条安全的路线。

## 说明/提示

#### 样例 2 解释

从旅店到山顶只有一条路径，这些旅行者的用时分别是 $13,14,13,13$。

------------

#### 数据范围

**本题采用捆绑测试**

对于一些子任务满足 $k=1$。

对于 $100\%$ 的数据，保证 $2\le n,m\le 2\times 10^3$，$1\le k\le 10^6$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
5 7 1
......X
X.X..X.
..X.X.X
.X.X...
.....X.
2 1```

### 输出

```
26 1```

## 样例 #2

### 输入

```
2 5 4
.X...
...X.
2 1
2 2
1 7
2 1```

### 输出

```
13 3```

# AI分析结果

### 综合分析与结论

本题的核心在于理解所有旅行者的路径是相同的，且路径的最短时间取决于路径中“上山”和“下山”的次数。通过BFS可以找到最短路径，并记录“上山”和“下山”的次数，最后根据每个旅行者的速度参数计算最短时间。所有题解都基于这一思路，但在实现细节、代码优化和解释清晰度上有所不同。

### 所选高质量题解

#### 1. 作者：_•́へ•́╬_ (5星)
- **关键亮点**：思路清晰，代码简洁，使用了双端队列优化BFS，减少了不必要的计算。通过记录“向回走”的次数，直接计算出最短路径的时间。
- **代码核心**：
  ```cpp
  deque<node>q;
  q.emplace_back(0,0,0);
  for(node i(0,0,0);q.size();)
  {
      i=q.front();q.pop_front();
      if(ans[i.x][i.y]^i.a)continue;
      if(i.x&&s[i.x-1][i.y]&&ans[i.x-1][i.y]>i.a+1)
          q.emplace_back(i.x-1,i.y,ans[i.x-1][i.y]=i.a+1);
      if(i.y&&s[i.x][i.y-1]&&ans[i.x][i.y-1]>i.a+1)
          q.emplace_back(i.x,i.y-1,ans[i.x][i.y-1]=i.a+1);
      if(i.x<n-1&&s[i.x+1][i.y]&&ans[i.x+1][i.y]>i.a)
          q.emplace_front(i.x+1,i.y,ans[i.x+1][i.y]=i.a);
      if(i.y<m-1&&s[i.x][i.y+1]&&ans[i.x][i.y+1]>i.a)
          q.emplace_front(i.x,i.y+1,ans[i.x][i.y+1]=i.a);
  }
  ```

#### 2. 作者：CSPAK_Zhangxiuqi0011 (4星)
- **关键亮点**：详细解释了路径选择的逻辑，特别是“向回走”的步数与路径长度的关系。代码结构清晰，注释详细。
- **代码核心**：
  ```cpp
  void bfs(){
      queue<node>q;
      q.push({1,1,0,0});
      while(!q.empty()){
          node h=q.front();
          q.pop();
          if(h.x==n&&h.y==m){
              int up=h.step-(n-1+m-1)/2;
              int down=(h.step-(n-1+m-1))/2;
              for(int i=1;i<=k;i++){
                  long long t=a[i].high*up+a[i].low*down;
                  if(t<minn)minn=t,num=1;
                  else if(t==minn)num++;
              }
              cout<<minn<<" "<<num<<"\n";
              return;
          }
          for(int i=0;i<4;i++){
              int nx=h.x+dx[i],ny=h.y+dy[i];
              if(nx>0&&nx<=n&&ny>0&&ny<=m&&!t[nx][ny]){
                  t[nx][ny]++;
                  q.push({nx,ny,h.step+1});
              }
          }
      }
  }
  ```

#### 3. 作者：donnieguo (4星)
- **关键亮点**：简洁明了地解释了路径选择的逻辑，代码实现高效，使用了队列进行BFS，并直接计算最短路径的时间。
- **代码核心**：
  ```cpp
  void bfs()
  {
      q.push({1,1,0,0});
      while (!q.empty())
      {
          int x = q.front().x, y = q.front().y;
          ll tul = q.front().tul, tdr = q.front().tdr;
          q.pop();
          if (x == n && y == m) {
              ul = tul;
              dr = tdr;
              return;
          }
          vis[x][y] = 1;
          q.push({x + 1, y, tul, tdr + 1});
          q.push({x - 1, y, tul + 1, tdr});
          q.push({x, y - 1, tul + 1, tdr});
          q.push({x, y + 1, tul, tdr + 1});
      }
  }
  ```

### 最优关键思路与技巧

1. **路径选择逻辑**：所有旅行者的路径相同，且最短路径的时间取决于“上山”和“下山”的次数。通过BFS找到最短路径，并记录“上山”和“下山”的次数。
2. **BFS优化**：使用双端队列（deque）优化BFS，减少不必要的计算。
3. **时间复杂度**：通过一次BFS即可计算出所有旅行者的最短时间，避免了多次搜索。

### 可拓展之处

- **类似算法套路**：类似的最短路径问题，如Dijkstra算法、A*算法等，可以应用于不同场景的最短路径计算。
- **同类型题目**：可以考虑扩展到多目标最短路径问题，或者在有更多限制条件（如时间窗口、资源限制）下的路径规划问题。

### 推荐题目

1. **P1144 最短路计数**：考察最短路径的计数问题。
2. **P3371 【模板】单源最短路径（弱化版）**：考察Dijkstra算法的实现。
3. **P4779 【模板】单源最短路径（标准版）**：考察Dijkstra算法的优化实现。

### 个人心得摘录

- **调试经历**：在实现BFS时，需要注意队列的初始化和边界条件的处理，避免重复访问和越界访问。
- **踩坑教训**：在计算“上山”和“下山”次数时，需要确保路径的合法性，避免出现负数或超出地图范围的情况。
- **顿悟感想**：通过理解路径选择的逻辑，可以简化问题的复杂度，避免不必要的计算和搜索。

---
处理用时：50.84秒
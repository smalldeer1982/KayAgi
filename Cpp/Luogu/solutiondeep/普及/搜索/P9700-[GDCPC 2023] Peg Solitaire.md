# 题目信息

# [GDCPC 2023] Peg Solitaire

## 题目描述

``独立钻石``是一种单人桌游。游戏在 $n$ 行 $m$ 列的棋盘上进行，棋盘上的每一格要么是空格，要么有一枚棋子。一开始，棋盘上共有 $k$ 枚棋子。

在游戏中，玩家可以选择一枚棋子，将它跳过相邻棋子到空格上，并移除被跳过的棋子。具体来说，令 $(i, j)$ 表示位于第 $i$ 行第 $j$ 列的格子，玩家可以执行以下四种操作。

![](https://cdn.luogu.com.cn/upload/image_hosting/pgosoztu.png)

给定一个初始的棋盘，求经过任意次操作（包括零次）之后，棋盘上最少能剩余几枚棋子。

## 样例 #1

### 输入

```
3
3 4 5
2 2
1 2
1 4
3 4
1 1
1 3 3
1 1
1 2
1 3
2 1 1
2 1```

### 输出

```
2
3
1```

# AI分析结果

### 综合分析与结论

题目要求通过跳跃操作减少棋盘上的棋子数量，最终求出最少能剩余的棋子数。由于棋盘规模较小（$n, m \leq 6$），大多数题解采用了深度优先搜索（DFS）或广度优先搜索（BFS）的暴力枚举方法。部分题解使用了状态压缩技术来优化存储和搜索效率。

#### 关键思路与技巧：
1. **DFS回溯**：大多数题解采用DFS进行搜索，并在每次跳跃后回溯，确保所有可能的跳跃路径都被探索。
2. **状态压缩**：部分题解使用二进制数表示棋盘状态，通过位运算进行状态转移，减少了存储和搜索的复杂度。
3. **剪枝优化**：在DFS过程中，通过提前判断是否可以进行跳跃操作，减少不必要的递归调用。
4. **边界处理**：在跳跃操作中，需要仔细处理棋子的边界条件，确保跳跃后的位置在棋盘内。

#### 可拓展之处：
- **状态压缩的应用**：状态压缩不仅适用于此类棋盘问题，还可以用于其他需要表示大量状态的搜索问题，如八数码问题、数独等。
- **剪枝策略的优化**：在搜索过程中，可以通过更复杂的剪枝策略（如启发式搜索）进一步优化搜索效率。

### 所选高星题解

#### 1. 作者：ran_qwq (★★★★★)
**关键亮点**：
- 使用状态压缩技术，将棋盘状态表示为二进制数，极大减少了存储和搜索的复杂度。
- 通过BFS进行搜索，确保找到最少剩余棋子数的全局最优解。
- 代码结构清晰，逻辑严谨，易于理解。

**核心代码**：
```cpp
void solve() {
    n=read(),m=read(),k=ans=read();ll stat=0;vis.clear();
    for(int i=1,x,y;i<=k;i++) x=read(),y=read(),stat|=1ll<<((x-1)*m+y-1);
    queue<pair<ll,int>>q;q.push({stat,k}),vis[stat]=1;
    while(!q.empty()) {
        ll u=q.front().fir;int cnt=q.front().sec;
        q.pop(),ans=min(ans,cnt);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++) {
                if(!(u&(1ll<<((i-1)*m+j-1)))) continue;
                for(int p=0;p<4;p++) {
                    int nx=i+dx[p],ny=j+dy[p],mx=nx+dx[p],my=ny+dy[p];
                    if(mx<1||mx>n||my<1||my>m||!(u&(1ll<<((nx-1)*m+ny-1)))||u&(1ll<<((mx-1)*m+my-1))) continue;
                    ll v=u^(1ll<<((i-1)*m+j-1))^(1ll<<((nx-1)*m+ny-1))^(1ll<<((mx-1)*m+my-1));
                    if(!vis[v]) vis[v]=1,q.push({v,cnt-1});
                }
            }
    }
    write(ans,"\n");
}
```

#### 2. 作者：lyh0217 (★★★★☆)
**关键亮点**：
- 采用DFS回溯，代码简洁明了，易于实现。
- 通过提前判断跳跃操作的合法性，减少了不必要的递归调用。
- 代码可读性强，适合初学者理解。

**核心代码**：
```cpp
void dfs(int p) {
    ans=min(ans,p);
    for(int i=1;i<=n;++i) {
        for(int j=1;j<=m;++j) {
            if(vis[i][j]) {
                if(j>=3&&vis[i][j-1]&&!vis[i][j-2]) {
                    vis[i][j-1]=0; vis[i][j]=0; vis[i][j-2]=1;
                    dfs(p-1);
                    vis[i][j-1]=1; vis[i][j]=1; vis[i][j-2]=0;
                }
                // 其他方向类似
            }
        }
    }
}
```

#### 3. 作者：Super_Builder (★★★★☆)
**关键亮点**：
- 采用DFS搜索，代码结构清晰，逻辑严谨。
- 通过枚举每个棋子的跳跃方向，确保所有可能的跳跃路径都被探索。
- 代码简洁，易于理解和实现。

**核心代码**：
```cpp
void dfs(int cnt){
    for(int x=1;x<=n;x++){
        for(int y=1;y<=m;y++){
            if(!a[x][y])continue;
            for(int i=0;i<4;i++){
                int nx=x+dx1[i], ny=y+dy1[i];
                if(nx<1||nx>n||ny<1||ny>m||!a[x+dx2[i]][y+dy2[i]]||a[nx][ny]) continue;
                a[x+dx2[i]][y+dy2[i]]=0; a[x][y]=0; a[nx][ny]=1;
                dfs(cnt-1);
                a[x+dx2[i]][y+dy2[i]]=1; a[x][y]=1; a[nx][ny]=0;
            }
        }
    }
    minn=min(minn,cnt);
}
```

### 推荐相似题目
1. [P1379 八数码问题](https://www.luogu.com.cn/problem/P1379)
2. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)
3. [P2324 [SCOI2005] 骑士精神](https://www.luogu.com.cn/problem/P2324)

### 个人心得总结
- **调试经历**：在实现跳跃操作时，容易忽略边界条件，导致程序崩溃或结果错误。建议在编写代码时，先进行边界条件的检查。
- **踩坑教训**：在DFS回溯时，忘记恢复棋盘状态，导致搜索结果错误。建议在每次递归调用后，及时恢复棋盘状态。
- **顿悟感想**：状态压缩技术可以极大地减少存储和搜索的复杂度，特别是在棋盘规模较小的情况下，效果尤为显著。

---
处理用时：59.03秒
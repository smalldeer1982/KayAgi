# 题目信息

# [NICA #2] 回来吧我的小波

## 题目背景

小波我错了，你快回来吧！

## 题目描述

给定一个仅包含数字 $1,2,3,4,5,6,7,8,9$ 的数字串 $s$，你要选择两个不交区间 $[l_1,r_1],[l_2,r_2](1\le l_1\le r_1<l_2\le r_2\le |s|)$，设 $[l_1,r_1]$ 区间串取出来的数字为 $x$，$[l_2,r_2]$ 区间串取出来的数字为 $y$，要求 $x|y$。如果存在这样两个不交区间，那么我们称数字串 $s$ 是好的。（这里的 $|$ 表示整除，你可以理解为 $x$ 为 $y$ 的一个因数）

现在给定一个仅包含数字 $1,2,3,4,5,6,7,8,9$ 的数字串 $S$，询问它有多少个子串是好的。（这里的子串**不要求**是本质不同的）

## 说明/提示

#### 样例1解释

只有一个好串 `327`，你可以选择两个不交区间 $[1,1],[2,3]$，取出来的数字分别是 $3$ 和 $27$，显然 $3$ 是 $27$ 的一个因数，所以这个串是好串。

其他子串 `3`，`2`，`7`，`32`，`27` 都不是好的，因为不存在这样的两个不交区间。

#### 样例2解释

共有 $12$ 个好串，分别为 `114514`、`11451`、`1145`、`114`、`11`、`14514`、`1451`、`145`、`14`、`4514`、`514`、`14`。（注意到里面有两个 `14`，但是由于它们位置不同，我们还是认为这是两个不同的子串）

#### 数据范围

对于所有数据，保证 $2\le |S|\le 10^6$。

## 样例 #1

### 输入

```
327```

### 输出

```
1```

## 样例 #2

### 输入

```
114514```

### 输出

```
12```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地判断一个子串是否为“好的”子串。大多数题解都利用了**抽屉原理**，即当子串长度大于等于10时，必然存在两个相同的数字，因此这些子串一定是“好的”。对于长度小于10的子串，题解普遍采用**暴力枚举**的方法，通过四重循环枚举所有可能的区间组合，判断是否存在满足条件的两个区间。

虽然暴力枚举的时间复杂度较高，但由于子串长度限制在9以内，实际运行时间仍然可以接受。整体思路清晰，代码实现也较为简洁，适合初学者理解。

### 所选高星题解

#### 题解1：作者：MTFlowCzq (赞：5)
- **星级**：5星
- **关键亮点**：
  - 详细解释了抽屉原理的应用，并明确指出了长度大于等于10的子串一定是“好的”。
  - 代码结构清晰，注释详细，易于理解。
  - 通过数学方法计算长度大于9的子串数量，减少了不必要的暴力枚举。
- **个人心得**：
  - 作者提到“考场上脑子一片空白，卡在暴力做不出来了，赛后才想到正解”，强调了在比赛中冷静思考的重要性。

```cpp
#include<iostream>
#include<string>
using namespace std;
string s;
long long ans,n,cnt; //记得开 long long
int val(int pos,int x,int y) { // 从 pos+x 到 pos+y 组成的数值
	int ans=0;
	for (int i=x;i<=y;i++)
		ans=ans*10+s[pos+i]-'0';
	return ans;
}
bool judge(int pos,int len) { // 判定 pos 开始长为 len 是否为好的
	for (int i=0;i<len;i++) // 暴力枚举
		for (int j=i;j<len;j++)
			for (int k=j+1;k<len;k++)
				for (int l=k;l<len;l++) {
					int a=val(pos,i,j);
					int b=val(pos,k,l);
					if (b%a==0)
						return true;
				}
	return false;
}
int main() {
	cin>>s;
	n=s.size();
	for (int d=2;d<=9;d++) // 只看长度不超过 9 的串
		for (int i=0;i<=n-d;i++)
			if (judge(i,d))
				cnt++;
	ans=n*(n+1)/2;
	for (int d=1;d<=9 && d<=n;d++)
		ans-=n-d+1; // 计算长度超过 9 的子串数
	ans+=cnt;
	cout<<ans<<endl;
	return 0;
}
```

#### 题解2：作者：Zheng_iii (赞：1)
- **星级**：4星
- **关键亮点**：
  - 简洁明了地应用了抽屉原理，直接计算长度大于9的子串数量。
  - 代码实现简洁，逻辑清晰，适合快速理解。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
string s;
ll ans;

int val(int l,int r){
	int res=0;
	for(int i=l;i<=r;i++)res = res * 10 + (s[i]-'0');
	return res;
}

bool query(int l,int r){
	for(int l1=l;l1<r;l1++){
		for(int r1=l1;r1<r;r1++){
			for(int l2=r1+1;l2<=r;l2++){
				for(int r2=l2;r2<=r;r2++){
					if(!(val(l2,r2)%val(l1,r1)))return true;
				}
			}
		}
	}
	return false;
}

int main(){
	cin>>s;
	int n=s.size();
	for(int i=0;i<=n;i++){
		ans+=max(n-9-i,0);//先把长度大于9的加进去
		int l = min(i+8,n-1);
		for(int j=i+1;j<=l;j++){
			ans+=query(i,j);
		}
	}
	cout<<ans;
	return 0;
}
```

#### 题解3：作者：菲斯斯夫斯基 (赞：1)
- **星级**：4星
- **关键亮点**：
  - 详细解释了抽屉原理的应用，并提供了清晰的代码实现。
  - 代码结构合理，注释详细，易于理解。

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
long long ans;
int num(int l,int r)
{
	int k=0;
	for(int i=l;i<=r;i++)
		k=k*10+(s[i]-'0');
	return k;
}//一段字符串代表的数
bool ask(int l,int r)
{
	int sum=0;
	for(int l1=l;l1<r;l1++)
	for(int r1=l1;r1<r;r1++)
	for(int l2=r1+1;l2<=r;l2++)
	for(int r2=l2;r2<=r;r2++)//暴力枚举l1,r1,l2,r2
		if(num(l2,r2)%num(l1,r1)==0)return true;
	return false;
}
int main()
{
	cin>>s;
	int n=s.size();
	for(int i=0;i<n;i++)
	{
		ans+=max(n-9-i,0);//以i为起点长度大于等于10的子串个数
		for(int j=i+1;j<=min(i+8,n-1);j++)
			ans+=ask(i,j);
	}
	cout<<ans;
	return 0;
}
```

### 最优关键思路与技巧
1. **抽屉原理**：当子串长度大于等于10时，必然存在两个相同的数字，因此这些子串一定是“好的”。
2. **暴力枚举**：对于长度小于10的子串，通过四重循环枚举所有可能的区间组合，判断是否存在满足条件的两个区间。
3. **数学计算**：通过数学方法计算长度大于9的子串数量，减少不必要的暴力枚举。

### 可拓展之处
- **类似题目**：可以考察其他基于抽屉原理或暴力枚举的题目，如判断字符串中是否存在重复字符、寻找特定模式的子串等。
- **优化思路**：对于更长的字符串，可以考虑进一步优化暴力枚举的方法，如利用哈希表存储已计算的子串结果，避免重复计算。

### 推荐题目
1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
3. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)

---
处理用时：43.80秒
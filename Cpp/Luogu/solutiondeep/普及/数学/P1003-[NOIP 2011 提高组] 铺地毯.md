# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何高效地找到覆盖某个点的最上面的地毯。由于地毯数量较多（最多10^4），直接使用二维数组存储每个点的地毯信息会导致内存溢出（MLE）。因此，大部分题解都采用了**枚举法**，通过遍历所有地毯，判断目标点是否在地毯的覆盖范围内，并更新最上面的地毯编号。

#### 关键思路与技巧：
1. **避免二维数组**：由于数据范围较大，直接开二维数组会超出内存限制，因此需要采用更高效的数据结构或算法。
2. **枚举法**：通过遍历所有地毯，判断目标点是否在地毯的覆盖范围内，时间复杂度为O(n)，在数据范围内可行。
3. **逆序遍历**：由于后铺的地毯覆盖前面的地毯，逆序遍历可以更快找到最上面的地毯，减少不必要的遍历。
4. **结构体存储**：使用结构体或数组存储地毯的四个参数（左上角坐标和长宽），便于后续判断。

#### 可拓展之处：
- **类似问题**：类似的问题可以出现在其他覆盖类题目中，如矩形覆盖、线段覆盖等。解决思路通常是枚举或使用更高效的数据结构（如线段树、扫描线等）。
- **优化思路**：如果地毯数量更大，可以考虑使用空间索引结构（如R树）来加速查询。

### 推荐题解

#### 1. 作者：智子 (5星)
**关键亮点**：
- 详细分析了二维数组的内存问题，并提出了使用四个数组存储地毯参数的解决方案。
- 代码简洁清晰，逻辑明确，易于理解。
- 提供了MLE的调试经历，帮助读者避免类似错误。

**核心代码**：
```cpp
int a[MAXN], b[MAXN], g[MAXN], k[MAXN];

int main() {
    int n, x, y;
    scanf("%d", &n);
    for(int i = 0; i < n; i++) {
        scanf("%d%d%d%d", &a[i], &b[i], &g[i], &k[i]);
    }
    scanf("%d%d", &x, &y);
    
    int ans = -1;
    for(int i = 0; i < n; i++) {
        if(x >= a[i] && y >= b[i] && x <= a[i] + g[i] && y <= b[i] + k[i]) {
            ans = i + 1;
        }
    }
    
    printf("%d\n", ans);
    return 0;
}
```

#### 2. 作者：FreedomKing (4星)
**关键亮点**：
- 代码简洁，直接使用数组存储地毯参数，并通过枚举法判断覆盖情况。
- 使用了`#define int long long`，确保数据范围足够大，避免溢出问题。

**核心代码**：
```cpp
int a[N], b[N], g[N], k[N], n, m, t, ans = -1;

signed main(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i] >> b[i] >> g[i] >> k[i];
    int x, y;
    cin >> x >> y;
    for(int i = 1; i <= n; i++) {
        if((x >= a[i] && x <= a[i] + g[i]) && (y >= b[i] && y <= b[i] + k[i]))
            ans = i;
    }
    cout << ans;
    return 0;
}
```

#### 3. 作者：谁懂谁伤心 (4星)
**关键亮点**：
- 采用了逆序遍历的方法，减少了不必要的遍历次数，提高了效率。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
int a[10001][2], b[10001][2], x, y, i, n, m;

int main() {
    scanf("%d", &i);
    for (int j = 1; j <= i; j++) {
        scanf("%d%d%d%d", &a[j][0], &a[j][1], &n, &m);
        b[j][0] = a[j][0] + n; b[j][1] = a[j][1] + m;
    }
    scanf("%d%d", &x, &y);
    for (int j = i; j >= 1; j--) {
        if (x >= a[j][0] && x <= b[j][0] && y >= a[j][1] && y <= b[j][1]) {
            printf("%d", j);
            return 0;
        }
    }
    cout << -1;
    return 0;
}
```

### 推荐题目
1. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880) - 考察区间DP，类似覆盖问题。
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908) - 考察枚举与分治思想。
3. [P1044 栈](https://www.luogu.com.cn/problem/P1044) - 考察栈的应用，类似后进先出的覆盖问题。

---
处理用时：33.86秒
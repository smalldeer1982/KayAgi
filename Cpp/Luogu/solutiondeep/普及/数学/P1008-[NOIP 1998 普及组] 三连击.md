# 题目信息

# [NOIP 1998 普及组] 三连击

## 题目背景

本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。

## 题目描述

将 $1, 2, \ldots , 9$ 共 $9$ 个数分成 $3$ 组，分别组成 $3$ 个三位数，且使这 $3$ 个三位数构成 $1 : 2 : 3$ 的比例，试求出所有满足条件的 $3$ 个三位数。

## 说明/提示

NOIP1998 普及组 第一题

## 样例 #1

### 输入

```
无```

### 输出

```
192 384 576
* * *
...

* * *
（剩余部分不予展示）```

# AI分析结果

### 综合分析与结论

本题的核心是找到三个三位数，满足1:2:3的比例，并且这三个数的每一位数字都是1到9且不重复。题解主要分为以下几种思路：

1. **枚举法**：通过枚举第一个数，计算第二个和第三个数，然后检查是否满足条件。这是最常见的解法，代码简洁且易于理解。
2. **全排列法**：生成1到9的全排列，然后将其分成三个三位数，检查是否满足比例关系。这种方法虽然直观，但效率较低，适合理解全排列的应用。
3. **数学优化法**：通过数学推导，减少枚举范围或优化判断条件，如利用数字和与积的唯一性来判断是否满足条件。

大部分题解都采用了枚举法，部分题解通过数学优化或使用STL库函数（如`next_permutation`）来简化代码或提高效率。

### 所选高星题解

#### 1. **Kelin (5星)**
- **关键亮点**：代码简洁，枚举范围优化，利用数组快速判断数字是否重复。
- **代码核心**：
  ```cpp
  for(i=192;i<=327;i++) {
      memset(a,0,sizeof(a));v=0;
      a[i%10]=a[i/10%10]=a[i/100]=a[i*2%10]=a[i*2/10%10]=a[i*2/100]=a[i*3%10]=a[i*3/10%10]=a[i*3/100]=1;
      for(j=1;j<=9;j++) v+=a[j];
      if(v==9) printf("%d %d %d\n",i,i*2,i*3);
  }
  ```
- **个人心得**：通过优化枚举范围（192到327）和利用数组快速判断数字是否重复，代码简洁且高效。

#### 2. **Drug__Lover (4星)**
- **关键亮点**：利用数字和与积的唯一性来判断是否满足条件，代码简洁且易于理解。
- **代码核心**：
  ```cpp
  if(a[1]*a[2]*a[3]*b[1]*b[2]*b[3]*c[1]*c[2]*c[3]==362880&&a[1]+a[2]+a[3]+b[1]+b[2]+b[3]+c[1]+c[2]+c[3]==45) {
      cout<<i<<" "<<i*2<<" "<<i*3<<endl;
  }
  ```
- **个人心得**：通过数学推导，减少了判断条件的复杂度，代码简洁且高效。

#### 3. **Tellack (4星)**
- **关键亮点**：利用STL的`set`数据结构，快速判断数字是否重复，代码简洁且易于理解。
- **代码核心**：
  ```cpp
  set<int> cache;
  INS(a)
  INS(b)
  INS(c)
  if (cache.count(0)) continue;
  if (cache.size()==9) printf("%d %d %d\n",a,b,c);
  ```
- **个人心得**：通过使用`set`数据结构，简化了判断数字是否重复的逻辑，代码简洁且高效。

### 最优关键思路与技巧

1. **枚举优化**：通过数学推导，减少枚举范围，如Kelin的192到327，避免不必要的计算。
2. **数学优化**：利用数字和与积的唯一性来判断是否满足条件，如Drug__Lover的解法。
3. **数据结构**：使用`set`或数组来快速判断数字是否重复，如Tellack和Kelin的解法。

### 可拓展之处

- **全排列应用**：类似题目可以使用全排列生成所有可能的组合，然后进行筛选，如静沐暖阳的解法。
- **数学优化**：在类似的比例问题中，可以通过数学推导减少枚举范围或优化判断条件。

### 推荐题目

1. **P1008 三连击**（本题）
2. **P1036 选数**（枚举与组合问题）
3. **P1706 全排列问题**（全排列生成与筛选）

### 个人心得总结

- **调试经历**：部分题解在调试过程中发现枚举范围过大或判断条件不完善，导致效率低下或错误输出。
- **踩坑教训**：在使用全排列时，注意生成的全排列是否符合题目要求，避免无效计算。
- **顿悟感想**：通过数学优化和数据结构的使用，可以显著提高代码的效率和可读性。

---
处理用时：31.47秒
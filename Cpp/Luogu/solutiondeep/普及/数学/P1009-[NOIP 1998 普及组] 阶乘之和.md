# 题目信息

# [NOIP 1998 普及组] 阶乘之和

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题

## 样例 #1

### 输入

```
3
```

### 输出

```
9```

# AI分析结果

### 综合分析与结论

本题的核心在于高精度计算，尤其是高精度乘法和加法的实现。由于阶乘的增长速度非常快，普通的数据类型无法存储50!这样的大数，因此必须使用高精度算法。大部分题解都采用了数组来存储大数，并通过模拟竖式计算的方式实现乘法和加法。部分题解还引入了重载运算符、记忆化搜索等技巧来优化代码结构和性能。

### 精选题解

#### 1. **题解作者：C_Z_C**
- **星级**：★★★★★
- **关键亮点**：
  - 使用了高精度乘法和加法的模板，代码结构清晰。
  - 通过数组存储大数，并模拟竖式计算，逻辑严谨。
  - 代码注释详细，适合初学者理解。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++){ //计算i的阶乘，已经算好了i-1的阶乘
      len_a=0; //i的长度
      int p=i;
      while(p>0){ //把i存进a数组
          a[len_a++]=p%10;
          p/=10;
      }
      for(int j=0;j<len_a;j++) //计算a*b（i*（i-1）的阶乘），即i的阶乘
          for(int k=0;k<=len_b;k++)
              c[j+k]+=a[j]*b[k];
      for(int j=0;j<len_c;j++) //需要进位的就进位
          if(c[j]>9) c[j+1]+=c[j]/10,c[j]%=10;
      if(c[len_c]) len_c++; //看最高位要不要进位
      len_ans=len_b,len_b=len_c,m=max(m,len_c); //把len_b赋值给len_ans，修改len_b的值
      for(int k=len_c-1;k>=0;k--) b[k]=c[k]; //把c存进b数组，即存进i的阶乘
      len_c=len_a+len_ans;
      memset(c,0,sizeof(c)); //清零c数组，准备计算下个阶乘
      for(int j=0;j<m;j++){ //高精加，直接套模板
          f[j]+=b[j];
          if(f[j]>9) f[j+1]+=f[j]/10,f[j]%=10; //进位
      }
  }
  ```

#### 2. **题解作者：wuhao1027**
- **星级**：★★★★☆
- **关键亮点**：
  - 代码简洁，直接使用高精度加法和乘法，逻辑清晰。
  - 通过数组存储大数，并模拟竖式计算，代码风格良好。
- **核心代码**：
  ```cpp
  for (i=2;i<=n;i++){
      for (j=0;j<100;j++)
          B[j]*=i;
      for (j=0;j<100;j++)
          if (B[j]>9){
              B[j+1] += B[j]/10;
              B[j]%=10;
          }
      for (j=0;j<100;j++){
          A[j]+=B[j];
          if (A[j]>9) {
              A[j+1] += A[j]/10;
              A[j]%=10;
          }
      }
  }
  ```

#### 3. **题解作者：Nortrom**
- **星级**：★★★★☆
- **关键亮点**：
  - 将高精度乘法和加法分别封装成函数，代码结构清晰。
  - 通过数组存储大数，并模拟竖式计算，逻辑严谨。
- **核心代码**：
  ```cpp
  void change(int x){ //高精求积
      int g=0;
      for(int i=100;i>=0;i--){
          a[i]=a[i]*x+g;
          g=a[i]/10;
          a[i]=a[i]%10;
      }
  }
  void qh(){ //高精求和
      int g=0;
      for(int i=100;i>=0;i--){
          s[i]=s[i]+a[i]+g;
          g=s[i]/10;
          s[i]=s[i]%10;
      }
  }
  ```

### 最优关键思路与技巧

1. **高精度计算**：使用数组存储大数，并通过模拟竖式计算实现乘法和加法。
2. **代码封装**：将高精度乘法和加法分别封装成函数，提高代码的可读性和复用性。
3. **重载运算符**：通过重载运算符简化高精度运算的代码，提升代码的简洁性和可读性。

### 可拓展之处

1. **高精度除法**：可以进一步实现高精度除法，扩展高精度算法的应用范围。
2. **记忆化搜索**：在计算阶乘时，可以使用记忆化搜索来避免重复计算，提升效率。

### 推荐题目

1. **P1009 [NOIP1998 普及组] 阶乘之和**（本题）
2. **P1045 [NOIP2003 普及组] 麦森数**（高精度乘法）
3. **P1255 数楼梯**（高精度加法）

### 个人心得摘录

- **C_Z_C**：在实现高精度加法时，注意进位操作，避免写成`f[j+1]++`，否则会WA一个点。
- **wuhao1027**：代码风格很重要，新手要养成好习惯，多用笔纸算一算。
- **Nortrom**：每次处理都基于上一次的操作，大大缩短了用时，类似于剪枝操作。

---
处理用时：41.79秒
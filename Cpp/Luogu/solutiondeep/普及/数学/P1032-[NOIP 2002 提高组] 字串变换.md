# 题目信息

# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

该题目要求通过字符串变换规则，将初始字符串转换为目标字符串，且变换步数不超过10步。由于题目涉及字符串的搜索与变换，常见的解法包括BFS、双向BFS、迭代加深搜索等。题解中，大部分作者采用了BFS或双向BFS，并结合字符串操作（如`find`、`replace`等）来实现变换。部分题解还引入了剪枝、判重等优化手段，以提高搜索效率。

从题解质量来看，大多数题解思路清晰，代码实现较为规范，但部分题解存在代码冗余或优化不足的问题。整体上，双向BFS和迭代加深搜索的题解表现较为出色，尤其是在处理大规模搜索时，能够有效减少搜索空间。

### 所选高星题解

#### 1. **作者：BrandonSoong (赞：279)**
- **星级**：★★★★★
- **关键亮点**：
  - 使用双向BFS，显著减少搜索空间，提升效率。
  - 通过`map`进行判重，避免重复搜索。
  - 代码结构清晰，注释详细，易于理解。
- **个人心得**：
  - 作者提到“双向BFS可以使得运行速度大大提升”，并通过图示解释了双向BFS的优势。
  - 强调了“map判重”的重要性，避免了不必要的重复计算。

**核心代码片段：**
```cpp
void bfs(){
    queue <node> q;
    q.push(node{a,0});
    while (!q.empty()){
        node now = q.front(); q.pop();
        if (now.step>10) continue;
        if (now.s == b) { cout << now.step; return; }
        for (int i=1;i<=n;i++){
            int pos = now.s.find(a[i]);
            while (pos != string::npos){
                string tmp = now.s;
                tmp.replace(pos, a[i].length(), b[i]);
                if (!vis[tmp]){
                    vis[tmp] = true;
                    q.push(node{tmp, now.step+1});
                }
                pos = now.s.find(a[i], pos+1);
            }
        }
    }
    cout << "NO ANSWER!";
}
```
**核心思想**：通过双向BFS从初始字符串和目标字符串同时进行搜索，利用`map`判重，确保每个状态只被搜索一次，从而减少搜索空间。

#### 2. **作者：Time_Rune (赞：156)**
- **星级**：★★★★☆
- **关键亮点**：
  - 采用迭代加深搜索，逐步增加搜索深度，避免一次性搜索过深。
  - 通过`map`记录搜索过的状态，避免重复搜索。
  - 代码简洁，逻辑清晰，适合初学者理解。
- **个人心得**：
  - 作者提到“迭代加深搜索可以避免在错误的路径上浪费大量时间”，并通过代码展示了如何逐步增加搜索深度。

**核心代码片段：**
```cpp
void dfs(string now, int step){
    if (step > k) return;
    if (now == b) { ans = min(ans, step); return; }
    if (vis[now]) return;
    vis[now] = true;
    for (int i=1;i<=n;i++){
        int pos = now.find(a[i]);
        while (pos != string::npos){
            string tmp = now;
            tmp.replace(pos, a[i].length(), b[i]);
            dfs(tmp, step+1);
            pos = now.find(a[i], pos+1);
        }
    }
}
```
**核心思想**：通过迭代加深搜索，逐步增加搜索深度，结合`map`判重，确保搜索路径的有效性。

#### 3. **作者：ShawnZhou (赞：578)**
- **星级**：★★★★☆
- **关键亮点**：
  - 使用KMP算法进行字符串匹配，提升匹配效率。
  - 通过`map`进行判重，避免重复搜索。
  - 代码结构清晰，注释详细，适合进阶学习。
- **个人心得**：
  - 作者提到“KMP算法可以避免在字符串匹配时重复计算”，并通过代码展示了KMP的实现细节。

**核心代码片段：**
```cpp
void KMP(string a, int x, int step){
    string z = a;
    a = " " + a;
    int j = 0;
    for (int i=1; i<a.length(); i++){
        while (j>0 && diff[x][j+1] != a[i]) j = nxt[x][j];
        if (diff[x][j+1] == a[i]) j++;
        if (j == diff[x].length()-1){
            int t = i - diff[x].length() + 1;
            string tmp = z.substr(0, t) + change[x] + z.substr(t + diff[x].length() - 1);
            q.push(Node(tmp, step+1));
            j = nxt[x][j];
        }
    }
}
```
**核心思想**：通过KMP算法进行字符串匹配，结合`map`判重，确保搜索路径的有效性。

### 最优关键思路与技巧

1. **双向BFS**：从初始状态和目标状态同时进行搜索，显著减少搜索空间，提升效率。
2. **迭代加深搜索**：逐步增加搜索深度，避免一次性搜索过深，适合步数限制的题目。
3. **KMP算法**：用于字符串匹配，提升匹配效率，减少重复计算。
4. **判重优化**：通过`map`或`set`记录已搜索的状态，避免重复搜索。

### 拓展思路与类似题目

1. **类似题目**：
   - **P1032 字串变换**：本题的变种，要求更复杂的字符串变换规则。
   - **P3375 KMP模板**：考察KMP算法的实现与应用。
   - **P3808 AC自动机**：考察字符串匹配与自动机的结合。

2. **拓展思路**：
   - 可以尝试将双向BFS与A*算法结合，进一步优化搜索路径。
   - 在字符串变换中引入动态规划，记录中间状态，减少重复计算。

### 推荐题目

1. **P1032 字串变换**：本题的变种，要求更复杂的字符串变换规则。
2. **P3375 KMP模板**：考察KMP算法的实现与应用。
3. **P3808 AC自动机**：考察字符串匹配与自动机的结合。

---
处理用时：55.09秒
# 题目信息

# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）求解中序遍历为 `(1,2,3,…,n)` 的二叉树的最大加分，并输出其前序遍历。所有题解均采用了区间DP的思路，通过枚举子树的根节点来计算最大加分，并记录每个区间的根节点以输出前序遍历。以下是各题解的要点总结：

1. **冒泡ioa**：通过区间DP设计状态转移方程，并记录根节点以输出前序遍历。代码简洁，思路清晰。
2. **winmt**：采用记忆化搜索的方式实现DP，代码结构清晰，但复杂度较高。
3. **噬月**：详细讨论了边界处理和等号的影响，代码实现较为严谨。
4. **Sooke**：使用字符串存储前序遍历，避免了递归输出，但空间复杂度较高。
5. **香风智乃**：采用三维数组存储DP状态，复杂度较高，代码实现较为复杂。
6. **_WA自动机**：通过特判左右子树为空的情况，代码简洁，但复杂度较高。
7. **xz001**：使用递归实现DP，代码结构清晰，但复杂度较高。

### 所选高星题解

#### 1. 冒泡ioa（5星）
- **关键亮点**：通过区间DP设计状态转移方程，并记录根节点以输出前序遍历。代码简洁，思路清晰。
- **代码核心思想**：
  ```cpp
  for (int len = 1; len < n; ++len) {
      for (int i = 1; i + len <= n; ++i) {
          int j = i + len;
          f[i][j] = f[i + 1][j] + f[i][i]; // 默认左子树为空
          root[i][j] = i; // 默认从起点选根
          for (int k = i + 1; k < j; ++k) {
              if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                  f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                  root[i][j] = k;
              }
          }
      }
  }
  ```

#### 2. 噬月（4星）
- **关键亮点**：详细讨论了边界处理和等号的影响，代码实现较为严谨。
- **代码核心思想**：
  ```cpp
  for (int range = 1; range <= n; ++range) {
      for (int i = 1; i + range <= n; ++i) {
          int j = i + range;
          for (int k = i; k <= j; ++k) {
              if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                  f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                  root[i][j] = k;
              }
          }
      }
  }
  ```

#### 3. _WA自动机（4星）
- **关键亮点**：通过特判左右子树为空的情况，代码简洁，但复杂度较高。
- **代码核心思想**：
  ```cpp
  for (int i = n; i; --i) {
      for (int j = i + 1; j <= n; ++j) {
          if (f[i][j] < f[i + 1][j] + w[i]) f[i][j] = f[i + 1][j] + w[i], g[i][j] = i;
          if (f[i][j - 1] + w[j] > f[i][j]) f[i][j] = f[i][j - 1] + w[j], g[i][j] = j;
          for (int k = i; k < j - 1; ++k) {
              if (f[i][k] * f[k + 2][j] + w[k + 1] > f[i][j]) f[i][j] = f[i][k] * f[k + 2][j] + w[k + 1], g[i][j] = k + 1;
          }
      }
  }
  ```

### 最优关键思路与技巧

1. **区间DP**：通过枚举子树的根节点，将问题分解为左子树和右子树的子问题，逐步求解最大加分。
2. **记录根节点**：在DP过程中记录每个区间的根节点，以便后续输出前序遍历。
3. **边界处理**：对于空子树的情况，默认其加分为1，避免数组越界。

### 可拓展之处

1. **类似问题**：可以扩展到其他树形结构的问题，如最优二叉搜索树、最小生成树等。
2. **优化思路**：可以考虑使用记忆化搜索或剪枝策略来优化DP的复杂度。

### 推荐题目

1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
2. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
3. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)

### 个人心得总结

- **调试经历**：在处理边界情况时，容易忽略空子树的情况，导致数组越界或计算结果错误。
- **踩坑教训**：在枚举根节点时，需要注意区间的边界，避免重复计算或遗漏某些情况。
- **顿悟感想**：通过逐步分解问题，理解DP的状态转移方程，能够更好地掌握区间DP的核心思想。

---
处理用时：34.51秒
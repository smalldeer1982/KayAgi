# 题目信息

# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# AI分析结果

### 综合分析与结论

本题的核心是通过给定的加密信息和原信息，构建一个字母到字母的映射（密码本），并利用该映射翻译新的加密信息。题解的难点主要在于如何高效地处理映射关系，并确保映射的合法性和完整性。大多数题解使用了 `map` 或数组来存储映射关系，并通过遍历和条件判断来验证映射的合法性。

### 所选高星题解

#### 题解1：作者：CYJian (5星)
**关键亮点**：
- 使用双向 `map` 记录加密信息和原信息的映射关系，确保映射的唯一性。
- 通过 `book` 变量记录已使用的字母数量，确保所有26个字母都被映射。
- 代码简洁，逻辑清晰，直接处理了所有可能的错误情况。

**核心代码**：
```cpp
map<char,char>mp,mq; // mp记录密文到原文，mq记录原文到密文
for(int i=0;i<la;i++)
    if(mp[a[i]]==0&&mq[b[i]]==0)
        mp[a[i]]=b[i], mq[b[i]]=a[i], book--; // 记录映射
    else if(mp[a[i]]!=b[i]||mq[b[i]]!=a[i]) // 检查映射合法性
        ERROR; // 判错
if(book>0) ERROR; // 检查是否所有字母都被映射
for(int i=0;i<lc;i++) printf("%c",mp[c[i]]); // 输出翻译结果
```

#### 题解2：作者：陈嘉逸2012 (4星)
**关键亮点**：
- 使用 `map` 记录密文到原文的映射，并用 `vis` 数组记录哪些字母已经被映射。
- 通过遍历 `A` 到 `Z` 检查是否所有字母都被映射，确保映射的完整性。
- 代码逻辑清晰，处理了映射冲突和缺失的情况。

**核心代码**：
```cpp
map<char,char>mp; map<char,bool>vis;
for(int i=0;i<a.size();i++){
    if(vis[b[i]]&&b[i]!=mp[a[i]]){cout<<"Failed\n";return 0;} // 检查映射冲突
    mp[a[i]]=b[i], vis[b[i]]=1; // 记录映射
}
for(char i='A';i<='Z';i++){
    if(!vis[i]){cout<<"Failed\n";return 0;} // 检查是否所有字母都被映射
}
for(int i=0;i<c.size();i++) cout<<mp[c[i]]; // 输出翻译结果
```

#### 题解3：作者：lianghuahua (4星)
**关键亮点**：
- 使用 `map` 记录密文到原文的映射，并用 `set` 记录已经被映射的原文，确保映射的唯一性。
- 通过 `mp.size()` 检查是否所有字母都被映射，确保映射的完整性。
- 代码逻辑清晰，处理了映射冲突和缺失的情况。

**核心代码**：
```cpp
map<char, char> mp; set<char> st;
for(int i = 0; i < s1.size(); i++){
    if(mp.count(s1[i])) { // 检查映射冲突
        if(mp[s1[i]] != s2[i]) {cout<<"Failed"; return 0;}
    }else{
        if(st.count(s2[i])) {cout<<"Failed"; return 0;} // 检查原文是否被重复映射
        mp[s1[i]] = s2[i]; st.insert(s2[i]); // 记录映射
    }
}
if(mp.size() < 26){cout<<"Failed"; return 0;} // 检查是否所有字母都被映射
for(int i = 0; i < s3.size(); i++) cout << mp[s3[i]]; // 输出翻译结果
```

### 最优关键思路与技巧
1. **双向映射检查**：使用双向 `map` 或 `set` 确保映射的唯一性，避免一个密文对应多个原文或一个原文对应多个密文。
2. **完整性检查**：通过遍历 `A` 到 `Z` 或记录已使用的字母数量，确保所有26个字母都被映射。
3. **错误处理**：在发现映射冲突或缺失时，立即输出 `Failed` 并结束程序，避免无效计算。

### 可拓展之处
- **类似题目**：可以扩展到其他需要构建映射关系的题目，如密码破解、字符替换等。
- **数据结构优化**：可以使用更高效的数据结构（如哈希表）来优化映射的存储和查找。

### 推荐题目
1. [P1072 Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072) - 考察数学与映射关系的题目。
2. [P1087 FBI 树](https://www.luogu.com.cn/problem/P1087) - 考察字符处理与树结构的题目。
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 考察贪心与优先队列的题目。

### 个人心得摘录
- **CYJian**：通过双向 `map` 处理映射关系，确保映射的唯一性，代码简洁高效。
- **陈嘉逸2012**：使用 `map` 和 `vis` 数组处理映射关系，逻辑清晰，处理了所有可能的错误情况。
- **lianghuahua**：通过 `map` 和 `set` 处理映射关系，确保映射的唯一性和完整性，代码逻辑清晰。

---
处理用时：34.12秒
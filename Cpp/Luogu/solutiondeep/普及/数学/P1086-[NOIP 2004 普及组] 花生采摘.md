# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在限定时间内，按照花生数量从大到小的顺序采摘花生，并确保能够返回路边。题解中主要采用了以下几种思路：

1. **曼哈顿距离计算**：几乎所有题解都使用了曼哈顿距离来计算移动时间，这是本题的关键优化点。
2. **排序与贪心**：大多数题解通过排序（从大到小）来模拟采摘顺序，结合贪心策略确保每次采摘的花生数量最大。
3. **数据结构优化**：部分题解使用了优先队列、稀疏矩阵等数据结构来优化存储和查询效率。

### 所选高星题解

#### 题解1：作者：jiangXxin (★★★★★)
- **关键亮点**：使用曼哈顿距离计算移动时间，结合排序和贪心策略，代码简洁且高效。
- **个人心得**：作者原本想用BFS，但发现曼哈顿距离更高效，体现了对问题本质的深刻理解。
- **核心代码**：
  ```cpp
  for(int i=1;i<=pn;i++) {
      tm = abs(fx-ex) + abs(fy-ey);
      k -= tm + 1;
      if(k >= ex) {
          ans += mp[ex][ey];
          fx = ex; fy = ey;
      } else {
          cout << ans << endl;
          return 0;
      }
  }
  ```
  **实现思想**：通过曼哈顿距离计算移动时间，判断是否能在限定时间内采摘并返回。

#### 题解2：作者：_Arahc_ (★★★★☆)
- **关键亮点**：使用优先队列和map来存储花生数量和坐标，避免了排序的复杂度，代码实现较为优雅。
- **个人心得**：作者强调了STL的使用，特别是priority_queue和map的结合，展示了C++ STL的强大功能。
- **核心代码**：
  ```cpp
  while(w + x <= k) {
      s += j;
      if(q.empty()) break;
      j = q.top(); q.pop();
      w += abs(c[j].first - x) + abs(c[j].second - y) + 1;
      x = c[j].first; y = c[j].second;
  }
  ```
  **实现思想**：通过优先队列动态获取最大花生数量，结合曼哈顿距离判断是否能在限定时间内采摘。

#### 题解3：作者：buickboy (★★★★☆)
- **关键亮点**：使用结构体进行降维排序，简化了二维数组的处理，代码简洁且高效。
- **个人心得**：作者强调了降维排序的思路，避免了复杂的二维数组操作，体现了对问题的高效处理。
- **核心代码**：
  ```cpp
  for(i=1; i<r; ++i) {
      t = abs(p[i].a - p[i+1].a) + abs(p[i].b - p[i+1].b);
      if(k >= t + 1 + p[i+1].a) {
          k -= t + 1; ans += p[i+1].s;
      } else break;
  }
  ```
  **实现思想**：通过结构体存储花生数量和坐标，结合曼哈顿距离判断是否能在限定时间内采摘。

### 最优关键思路与技巧

1. **曼哈顿距离**：本题的核心优化点，用于快速计算移动时间。
2. **排序与贪心**：通过排序确保每次采摘的花生数量最大，结合贪心策略优化采摘顺序。
3. **数据结构优化**：使用优先队列、稀疏矩阵等数据结构来优化存储和查询效率。

### 可拓展之处

- **类似算法套路**：类似的问题可以扩展到其他路径规划问题，如最短路径、最小时间等。
- **数据结构应用**：优先队列、map等数据结构在其他算法题中也有广泛应用，如Dijkstra算法、动态规划等。

### 推荐洛谷题目

1. **P1002 过河卒**：考察路径规划与动态规划。
2. **P1219 八皇后**：考察回溯与剪枝。
3. **P1048 采药**：考察背包问题与贪心策略。

### 个人心得总结

- **调试经历**：部分作者在调试过程中发现BFS不适用，转而使用曼哈顿距离，体现了对问题本质的深刻理解。
- **踩坑教训**：部分作者强调了采摘时间的计算，提醒了读者注意细节。
- **顿悟感想**：通过优先队列和map的结合，部分作者展示了C++ STL的强大功能，体现了对数据结构的高效应用。

---
处理用时：29.65秒
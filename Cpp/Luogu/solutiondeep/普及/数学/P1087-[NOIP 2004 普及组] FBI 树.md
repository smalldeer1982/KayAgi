# 题目信息

# [NOIP 2004 普及组] FBI 树

## 题目描述

我们可以把由 0 和 1 组成的字符串分为三类：全 0 串称为 B 串，全 1 串称为 I 串，既含 0 又含 1 的串则称为 F 串。

FBI 树是一种二叉树，它的结点类型也包括 F 结点，B 结点和 I 结点三种。由一个长度为 $2^N$ 的 01 串 $S$ 可以构造出一棵 FBI 树 $T$，递归的构造方法如下：

1. $T$ 的根结点为 $R$，其类型与串 $S$ 的类型相同；
2. 若串 $S$ 的长度大于 $1$，将串 $S$ 从中间分开，分为等长的左右子串 $S_1$ 和 $S_2$；由左子串 $S_1$ 构造 $R$ 的左子树 $T_1$，由右子串 $S_2$ 构造 $R$ 的右子树 $T_2$。

现在给定一个长度为 $2^N$ 的 01 串，请用上述构造方法构造出一棵 FBI 树，并输出它的后序遍历序列。


## 说明/提示

对于 $40\%$ 的数据，$N \le 2$；

对于全部的数据，$N \le 10$。


noip2004普及组第3题


## 样例 #1

### 输入

```
3
10001011
```

### 输出

```
IBFBBBFIBFIIIFF
```

# AI分析结果

### 综合分析与结论

本题的核心是通过递归或分治的方式构建FBI树，并进行后序遍历输出。大多数题解采用了递归的思路，部分题解通过模拟线段树或满二叉树的性质来优化空间和时间复杂度。递归的思路较为直观，适合初学者理解，而优化后的方法则更适合处理较大的数据规模。

### 所选高星题解

#### 1. 题解作者：ingu (赞：262)
- **星级**: 5星
- **关键亮点**: 
  - 思路清晰，详细解释了递归建树和后序遍历的过程。
  - 代码简洁，直接通过递归函数实现了后序遍历的输出。
  - 通过简单的条件判断来确定节点的类型，逻辑清晰。
- **个人心得**: 
  - 作者提到“输出过程可以和建树过程集成在一起”，这种边建树边输出的思路减少了代码的复杂度。
  
**核心代码**:
```cpp
void maketree(int x,int y){
    if(y>x){
        maketree(x,(x+y)/2);
        maketree((x+y+1)/2,y);
    }    
    int B=1,I=1;
    for(int i=0;i<=y-x;i++){
        if(s[x+i]=='1') B=0;
        else if(s[x+i]=='0') I=0;
    }
    if(B) cout<<'B';
    else if(I) cout<<'I';
    else cout<<'F';
}
```
**核心思想**: 通过递归分割字符串，判断每个子串的类型，并在递归过程中直接输出后序遍历结果。

#### 2. 题解作者：wuhao1027 (赞：148)
- **星级**: 4.5星
- **关键亮点**: 
  - 采用了二分查找的思想，递归处理字符串的左右子串。
  - 代码简洁，逻辑清晰，适合理解递归的基本应用。
- **个人心得**: 
  - 作者提到“很多树的题目事实上根本不用把树建立出来”，这种思路值得借鉴，尤其是在处理树形结构时，直接通过递归处理可以节省空间。

**核心代码**:
```cpp
void work(int low, int up){
    int mid = (low+up)/2;
    if (low!=up){
        work(low, mid);
        work(mid+1,up);
    }
    int i,a=0,b=0;
    for (i=low;i<=up;i++)
        if (A[i]=='0') a++;
        else b++;
    if (a&&b) printf("F");
    else if (a) printf("B");
    else printf("I");
}
```
**核心思想**: 通过递归分割字符串，统计子串中0和1的数量，判断类型并输出。

#### 3. 题解作者：传说饭 (赞：122)
- **星级**: 4星
- **关键亮点**: 
  - 通过字符串的子串操作，简化了递归的实现。
  - 代码简洁，逻辑清晰，适合理解递归的基本应用。
- **个人心得**: 
  - 作者提到“二叉树后序遍历可以说是基础问题”，强调了递归在树形结构中的重要性。

**核心代码**:
```cpp
char FBI(string s) {
    if (s.length() > 1){
        cout << FBI(s.substr(0, s.length()/2));
        cout << FBI(s.substr(s.length()/2, s.length()/2));
    }
    if (s == string(s.length(), '0')) return 'B';
    if (s == string(s.length(), '1')) return 'I';
    return 'F';
}
```
**核心思想**: 通过递归分割字符串，判断子串的类型，并在递归过程中直接输出后序遍历结果。

### 最优关键思路与技巧
1. **递归与分治**: 大多数题解通过递归或分治的方式处理字符串，适合处理树形结构问题。
2. **边建树边输出**: 通过递归过程中直接输出后序遍历结果，减少了代码的复杂度。
3. **满二叉树性质**: 部分题解利用满二叉树的性质，通过数组模拟树的结构，优化了空间和时间复杂度。

### 可拓展之处
- **类似问题**: 类似的问题包括二叉树的遍历、分治算法等，如线段树的构建与查询。
- **优化思路**: 在处理大规模数据时，可以考虑使用非递归的方法或利用满二叉树的性质进行优化。

### 推荐题目
1. **P1040 二叉树的遍历**：考察二叉树的遍历方式，适合练习递归与分治。
2. **P1081 线段树**：考察线段树的构建与查询，适合练习树形结构的优化。
3. **P1090 合并果子**：考察分治与贪心算法的结合，适合练习分治思想的应用。

---
处理用时：36.41秒
# 题目信息

# 波浪数

## 题目描述

波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。

类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $2\le l\le r\le 32$，$1\le L\le R\le 10^7$，$k\in \{2, 3, 4\}$。

## 样例 #1

### 输入

```
10 11 190000 960000 2```

### 输出

```
191919
383838
575757
767676
959595```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地生成并判断“波浪数”。大多数题解采用了“逆向思维”，即先构造波浪数，再判断其在不同进制下的波浪性质。这种思路避免了直接判断每个数在不同进制下是否为波浪数的高复杂度问题。以下是各题解的主要思路和优化点：

1. **逆向构造波浪数**：通过枚举不同进制下的波浪数，生成所有可能的波浪数，并记录其在指定范围内的出现次数。
2. **避免重复计算**：通过标记已生成的波浪数，避免重复计算，提升效率。
3. **优化进制转换**：通过直接构造波浪数的十进制表示，避免了频繁的进制转换操作。

### 所选高星题解

#### 题解1：作者 Crazily (5星)
**关键亮点**：
- 逆向思维，先构造波浪数，再判断其重数。
- 代码简洁，逻辑清晰，易于理解。
- 通过`v[x]`数组记录波浪数的重数，避免重复计算。

**个人心得**：
- “咋考试时就想不到呢。。。。。。” —— 作者在考场上未能想到逆向思维，考后顿悟，体现了思维转换的重要性。

**核心代码**：
```cpp
for(int k=a;k<=b;++k){
    for(int i=1;i<k;++i){
        for(int j=0;j<k;++j){
            if(i!=j){
                x=0; t=0;
                while(x<=r){
                    if(t%2==0) x=x*k+i;
                    else x=x*k+j;
                    ++t;
                    if(x>=l&&x<=r) ++v[x];
                }
            }
        }
    }
}
```

#### 题解2：作者 Star_Wind (4星)
**关键亮点**：
- 使用子函数`make`生成波浪数，代码结构清晰。
- 通过`b[t]`数组记录波浪数的重数，避免重复计算。

**核心代码**：
```cpp
void make(int x){
    for(int i=1;i<x;i++)
        for(int j=0;j<x;j++)
            if(i!=j){
                len=0; t=0;
                while(t<r){
                    len++;
                    if(len%2==0) a[len]=i;
                    else a[len]=j;
                    t=t*x+a[len];
                    if(t>r) break;
                    b[t]++;
                }
            }
}
```

#### 题解3：作者 Y_B_Y (4星)
**关键亮点**：
- 通过`yes[k]`数组记录波浪数的重数，思路清晰。
- 详细解释了波浪数的构造过程，代码可读性强。

**核心代码**：
```cpp
for(int p=j1;p<=j2;p++){
    memset(b,0,sizeof(b));
    for(int i=0;i<=p-1;i++){
        for(int j=0;j<=p-1;j++){
            if(i==j) continue;
            int tot=0;
            for(int l=1;l<=10;l++){
                if(tot+j*pow(p,2*l-2)<=ed && l>1){
                    if(!b[tot+(int)(j*pow(p,2*l-2))]) yes[tot+int(j*pow(p,2*l-2))]++;
                    b[tot+(int)(j*pow(p,2*l-2))]=1;
                }
                if(tot+i*pow(p,2*l-1)+j*pow(p,2*l-2)<=ed){
                    tot+=i*pow(p,2*l-1)+j*pow(p,2*l-2);
                    if(!b[tot]) yes[tot]++;
                    b[tot]=1;
                }
                else break;
            }
        }
    }
}
```

### 最优关键思路与技巧

1. **逆向构造波浪数**：通过枚举不同进制下的波浪数，生成所有可能的波浪数，再判断其重数，避免了直接判断每个数在不同进制下是否为波浪数的高复杂度问题。
2. **避免重复计算**：通过标记已生成的波浪数，避免重复计算，提升效率。
3. **优化进制转换**：通过直接构造波浪数的十进制表示，避免了频繁的进制转换操作。

### 可拓展之处

- **类似算法套路**：这种逆向构造的思路可以应用于其他需要判断数在多种进制下性质的题目，如“回文数”、“特殊进制数”等。
- **同类型题目**：
  1. [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)
  2. [P1062 数列](https://www.luogu.com.cn/problem/P1062)
  3. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)

### 个人心得总结

- **思维转换的重要性**：在考场上未能想到逆向思维，考后顿悟，体现了思维转换的重要性。
- **避免重复计算**：通过标记已生成的波浪数，避免重复计算，提升效率。
- **优化进制转换**：通过直接构造波浪数的十进制表示，避免了频繁的进制转换操作。

---
处理用时：33.43秒
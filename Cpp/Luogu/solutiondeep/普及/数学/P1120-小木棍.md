# 题目信息

# 小木棍

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。

现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。

给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。


## 说明/提示

对于全部测试点，$1 \leq n \leq 65$，$1 \leq a_i \leq 50$。

## 样例 #1

### 输入

```
9
5 2 1 5 2 1 5 2 1
```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

本题的核心是通过深度优先搜索（DFS）结合多种剪枝策略，找到原始木棍的最小可能长度。题解中普遍采用了以下优化思路：

1. **枚举原始长度**：从最大木棍长度到总长度的一半进行枚举，且原始长度必须能被总长度整除。
2. **排序与剪枝**：将木棍按长度从大到小排序，优先使用长木棍，减少搜索空间。
3. **避免重复搜索**：通过记录上一次使用的木棍位置，避免重复搜索相同长度的木棍。
4. **提前终止条件**：当剩余长度等于当前木棍长度或原始长度时，直接回溯，避免无效搜索。

尽管大多数题解思路相似，但在剪枝的细节处理和代码实现上存在差异。以下是对部分题解的评分与亮点总结。

---

### 精选题解

#### 1. 题解作者：Kaori (赞：1363)
- **星级**：★★★★★
- **关键亮点**：
  - 详细解释了每个剪枝策略的逻辑，尤其是“当前长棍剩余的未拼长度等于当前木棍的长度或原始长度”时的剪枝。
  - 代码结构清晰，注释详细，便于理解。
  - 提供了预处理优化（如`next`数组），进一步减少搜索时间。
- **个人心得**：作者提到“搜索题啊，每招优化都要学，学一招说不定竞赛的时候就能跑的快一点”，强调了优化的重要性。
- **核心代码**：
  ```cpp
  void dfs(int k, int last, int rest) {
      if (!rest) {
          if (k == m) { ok = 1; return; }
          for (int i = 1; i <= cnt; i++)
              if (!used[i]) break;
          used[i] = 1;
          dfs(k + 1, i, len - a[i]);
          used[i] = 0;
          if (ok) return;
      }
      int l = last + 1, r = cnt, mid;
      while (l < r) {
          mid = (l + r) >> 1;
          if (a[mid] <= rest) r = mid;
          else l = mid + 1;
      }
      for (int i = l; i <= cnt; i++) {
          if (!used[i]) {
              used[i] = 1;
              dfs(k, i, rest - a[i]);
              used[i] = 0;
              if (ok) return;
              if (rest == a[i] || rest == len) return;
              i = next[i];
              if (i == cnt) return;
          }
      }
  }
  ```

#### 2. 题解作者：林则徐 (赞：402)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用桶排序存储木棍长度，减少排序时间。
  - 通过`tm`数组记录木棍数量，简化搜索逻辑。
  - 剪枝策略简洁有效，尤其是“已拼接的长度为0或当前已拼接的长度与枚举的长度之和为最终答案”时的剪枝。
- **核心代码**：
  ```cpp
  void dfs(int res, int sum, int target, int p) {
      if (res == 0) { printf("%d", target); exit(0); }
      if (sum == target) { dfs(res - 1, 0, target, maxn); return; }
      for (int i = p; i >= minn; i--) {
          if (tm[i] && i + sum <= target) {
              tm[i]--;
              dfs(res, sum + i, target, i);
              tm[i]++;
              if (sum == 0 || sum + i == target) break;
          }
      }
  }
  ```

#### 3. 题解作者：NoyException (赞：351)
- **星级**：★★★★☆
- **关键亮点**：
  - 强调了“从大到小排序”和“避免重复搜索”的重要性。
  - 提供了详细的剪枝解释，尤其是“剩余长度等于当前木棍长度”时的剪枝。
  - 代码实现简洁，注释清晰。
- **核心代码**：
  ```cpp
  bool dfs(int now, int cab, int last) {
      if (now > s) return 1;
      if (cab == l) return dfs(now + 1, 0, 1);
      int f = 0;
      for (int i = last; i <= cnt; i++) {
          if (!k[i] && cab + a[i] <= l && f != a[i]) {
              k[i] = 1;
              if (dfs(now, cab + a[i], i + 1)) return 1;
              f = a[i];
              k[i] = 0;
              if (cab == 0 || cab + a[i] == l) return 0;
          }
      }
      return 0;
  }
  ```

---

### 最优关键思路与技巧

1. **排序与优先使用长木棍**：从大到小排序，优先使用长木棍，减少搜索空间。
2. **避免重复搜索**：通过记录上一次使用的木棍位置，跳过相同长度的木棍。
3. **提前终止条件**：当剩余长度等于当前木棍长度或原始长度时，直接回溯。
4. **预处理优化**：如`next`数组，减少搜索时间。

---

### 可拓展之处

1. **类似题目**：如[P1120 小木棍](https://www.luogu.com.cn/problem/P1120)、[P1092 虫食算](https://www.luogu.com.cn/problem/P1092)、[P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)，均需通过DFS结合剪枝策略解决。
2. **优化技巧**：在搜索题中，预处理、排序、记录状态等优化手段可以大幅提升效率。

---

### 推荐题目

1. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)（本题）
2. [P1092 虫食算](https://www.luogu.com.cn/problem/P1092)（DFS+剪枝）
3. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)（DFS+剪枝+状态记录）

---
处理用时：49.25秒
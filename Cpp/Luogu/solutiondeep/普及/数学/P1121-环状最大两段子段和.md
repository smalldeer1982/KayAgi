# 题目信息

# 环状最大两段子段和

## 题目描述

给出一段长度为 $n$ 的环状序列 $a$，即认为 $a_1$ 和 $a_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
9```

# AI分析结果

### 综合分析

本题的核心在于如何在环状序列中找到两段不重叠且和最大的子段。题解中常见的思路包括动态规划、前缀和、线段树等。大多数题解通过分类讨论将问题转化为链状序列的最大子段和问题，或者通过取反求最小子段和来间接求解。部分题解还引入了线段树等数据结构来优化时间复杂度。

### 最优思路总结

1. **分类讨论**：将问题分为两种情况，一种是两段子段不跨越环的端点，另一种是跨越环的端点。对于第一种情况，直接使用最大子段和的动态规划；对于第二种情况，通过求最小子段和来间接求解。
2. **正反两次DP**：通过正反两次动态规划，分别求出从左到右和从右到左的最大子段和，然后枚举分界点来求解。
3. **线段树优化**：部分题解使用线段树来维护区间信息，适用于需要频繁查询区间最大子段和的场景。

### 推荐题解

#### 1. 作者：I_AM_HelloWord (赞：75)
- **星级**：★★★★★
- **关键亮点**：通过正反两次DP求解最大子段和，分类讨论环状序列的两种情况，思路清晰，代码简洁。
- **个人心得**：作者提到特判只有一个正数的情况，避免了全负数或只有一个正数时的错误。

```cpp
int query(){
    int res=-INF;
    for (int i=1;i<=n;i++)f[i]=max(f[i-1],0)+a[i];
    for (int i=n;i>0;i--)g[i]=max(g[i+1],0)+a[i];
    for (int i=1;i<=n;i++)f[i]=max(f[i-1],f[i]);
    for (int i=n;i>0;i--)g[i]=max(g[i+1],g[i]);
    for (int i=1;i<n;i++)res=max(res,f[i]+g[i+1]);
    return res;
}
```

#### 2. 作者：zhy137036 (赞：48)
- **星级**：★★★★☆
- **关键亮点**：通过两次DP分别求解最大和最小子段和，结合分类讨论，思路清晰，代码实现较为简洁。
- **个人心得**：作者提到环状最大子段和的处理方式，通过两次DP分别求解，避免了复杂的环状处理。

```cpp
int getmax(int*arr,int l,int(*cmp)(int,int)){
	f[1]=arr[1];
	for(int i=2;i<=l;i++)f[i]=cmp(f[i-1],0)+arr[i];
	g[1]=f[1];
	for(int i=2;i<=l;i++)g[i]=cmp(g[i-1],f[i]);
	return g[l];
}
```

#### 3. 作者：ywy_c_asm (赞：28)
- **星级**：★★★★☆
- **关键亮点**：使用线段树维护区间信息，支持快速查询区间最大子段和，适用于更复杂的区间查询问题。
- **个人心得**：作者详细讨论了线段树的合并操作，提供了清晰的思路和代码实现。

```cpp
TreeNode operator +(_n a,_n b) {
	_n c;
	c.he=a.he+b.he;
	c.zd=max(a.zd,b.zd);
	c.zd=max(c.zd,a.hz+b.qz);
	c.qz=max(a.qz,a.he+b.qz);
	c.hz=max(b.hz,b.he+a.hz);
	c.qzhz=max(a.qz+b.hz,a.he+b.qzhz);
	c.qzhz=max(c.qzhz,b.he+a.qzhz);
	c.qzzj=max(a.qzzj,a.he+b.qzzj);
	c.qzzj=max(c.qzzj,a.qz+b.zd);
	c.qzzj=max(c.qzzj,a.qzhz+b.qz);
	c.hzzj=max(b.hzzj,b.he+a.hzzj);
	c.hzzj=max(c.hzzj,b.he+a.zd);
	c.hzzj=max(c.hzzj,b.qzhz+a.hz);
	c.zd2=max(a.zd2,b.zd2);
	c.zd2=max(c.zd2,a.zd+b.zd);
	c.zd2=max(c.zd2,a.hzzj+b.qz);
	c.zd2=max(c.zd2,a.hz+b.qzzj);
	return(c);
}
```

### 扩展思路与推荐题目

1. **扩展思路**：可以将问题扩展到多段子段和，或者扩展到二维矩阵中的最大子矩阵和问题。
2. **推荐题目**：
   - [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
   - [P2642 双子序列最大和](https://www.luogu.com.cn/problem/P2642)
   - [P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)

---
处理用时：34.46秒
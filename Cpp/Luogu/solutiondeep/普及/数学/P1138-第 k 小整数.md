# 题目信息

# 第 k 小整数

## 题目描述

现有 $n$ 个正整数，要求出这 $n$ 个正整数中的第 $k$ 个最小整数（相同大小的整数只计算一次）。


## 说明/提示

$n \leq 10000$，$k \leq 1000$，正整数均小于 $30000$。

## 样例 #1

### 输入

```
10 3
1 3 3 7 2 5 1 2 4 6
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心在于从一组整数中找出第k小的唯一整数。题解中主要采用了以下几种思路：

1. **排序+去重**：通过排序后去重，直接输出第k小的数。这是最直观的思路，时间复杂度为O(n log n)。
2. **桶排序**：利用数组下标记录数字是否出现，避免了排序和去重的步骤，时间复杂度为O(n)。
3. **平衡树/线段树/主席树**：使用高级数据结构来维护有序序列，适合处理更大规模的数据，但实现复杂度较高。
4. **STL函数**：利用C++的`sort`、`unique`等函数简化代码，提升可读性。

整体来看，**桶排序**和**排序+去重**是最简单且高效的解法，适合初学者。而高级数据结构如平衡树、线段树等虽然性能优越，但实现复杂，适合对算法有深入理解的学习者。

### 精选题解

#### 1. 桶排序（作者：Sinwind）
- **星级**：★★★★★
- **关键亮点**：利用桶排序的思想，通过数组下标记录数字是否出现，避免了排序和去重的步骤，时间复杂度为O(n)，代码简洁高效。
- **核心代码**：
  ```cpp
  int n,k,i,num,cnt,max;
  bool a[30010];
  int main() {
      cin >> n >> k;
      for(i = 0; i < n; i++) {
          int input;
          cin >> input;
          if(input > max) max = input;
          a[input] = true;
      }
      for(i = 1; i <= max; i++) {
          if(a[i]) cnt++;
          if(cnt == k) {
              cout << i;
              return 0;
          }
      }
      cout << "NO RESULT";
      return 0;
  }
  ```
- **个人心得**：通过记录最大值来减少遍历范围，进一步优化了性能。

#### 2. 排序+去重（作者：不会dp退役菜鸡）
- **星级**：★★★★
- **关键亮点**：利用C++的`sort`和`unique`函数，代码简洁且易于理解，适合初学者。
- **核心代码**：
  ```cpp
  int n,k,a[10000];
  int main() {
      cin >> n >> k;
      for(int i = 0; i < n; i++) cin >> a[i];
      sort(a, a + n);
      int ans = unique(a, a + n) - a;
      if(k < ans) cout << a[k - 1];
      else cout << "NO RESULT";
      return 0;
  }
  ```
- **个人心得**：通过`unique`函数去重，简化了代码逻辑。

#### 3. 平衡树（作者：Catalan1906）
- **星级**：★★★★
- **关键亮点**：使用平衡树（Treap）维护有序序列，适合处理更大规模的数据，性能优越。
- **核心代码**：
  ```cpp
  void insert(Node* &x, int val) {
      if(x->v == val) return;
      int d;
      if(x == &null) x = new Node(val), x->s = 1, x->c = 1, siz++;
      else {
          insert(x->ch[d = v < x->v ? 0 : 1], val);
          if(x->ch[d]->r > x->r) rotate(x, d ^ 1);
      }
      maintain(x);
  }
  ```
- **个人心得**：通过平衡树实现动态插入和查询，适合对数据结构有深入理解的学习者。

### 最优关键思路与技巧

1. **桶排序**：利用数组下标记录数字是否出现，避免了排序和去重的步骤，时间复杂度为O(n)，适合小范围数据。
2. **排序+去重**：通过`sort`和`unique`函数简化代码，适合初学者。
3. **平衡树/线段树**：适合处理更大规模的数据，性能优越，但实现复杂。

### 拓展思路与类似题目

1. **类似题目**：
   - **P1177 【模板】快速排序**：考察排序算法的实现。
   - **P3369 【模板】普通平衡树**：考察平衡树的实现与应用。
   - **P3834 【模板】可持久化线段树**：考察线段树的应用。

2. **调试与顿悟**：
   - **调试经历**：在实现平衡树时，旋转操作容易出错，建议通过画图理解旋转过程。
   - **顿悟感想**：桶排序虽然简单，但在特定场景下性能优越，值得掌握。

### 总结

对于本题，**桶排序**和**排序+去重**是最优解法，适合初学者。而**平衡树/线段树**等高级数据结构适合对算法有深入理解的学习者。建议根据自身水平选择合适的解法，并掌握其中的关键思路与技巧。

---
处理用时：35.55秒
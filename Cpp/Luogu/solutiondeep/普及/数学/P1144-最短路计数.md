# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论

本题的核心是求解无向无权图中从起点到其他所有点的最短路数量。题解中主要使用了以下几种算法：SPFA、Dijkstra、BFS。由于是无权图，BFS是最优的选择，因为它的时间复杂度为O(n)，且实现简单。SPFA和Dijkstra虽然也能解决问题，但在无权图中显得冗余，尤其是Dijkstra的堆优化版本，虽然时间复杂度为O(nlogn)，但在本题中并不比BFS更有优势。

### 精选题解

#### 1. **作者：岸芷汀兰 (5星)**
- **关键亮点**：使用BFS解决无权图的最短路计数问题，思路清晰，代码简洁，且避免了SPFA和Dijkstra的冗余操作。
- **个人心得**：作者明确指出，由于是无权图，BFS是最佳选择，避免了SPFA和Dijkstra的复杂实现。
- **核心代码**：
  ```cpp
  void bfs() {
      queue<int> q;
      q.push(1);
      vis[1] = 1;
      ans[1] = 1;
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          for (int v : linker[u]) {
              if (!vis[v]) {
                  vis[v] = 1;
                  d[v] = d[u] + 1;
                  ans[v] = ans[u];
                  q.push(v);
              } else if (d[v] == d[u] + 1) {
                  ans[v] = (ans[v] + ans[u]) % 100003;
              }
          }
      }
  }
  ```
  **核心思想**：通过BFS遍历图，记录每个点的最短路长度和路径数量，遇到相同长度的路径时累加路径数。

#### 2. **作者：XZYQvQ (4星)**
- **关键亮点**：使用SPFA进行最短路计数，并指出SPFA在无权图中的局限性，提供了更通用的解决方案。
- **个人心得**：作者提到SPFA在无权图中可能会重复计数，建议使用记忆化搜索来避免这一问题。
- **核心代码**：
  ```cpp
  int dfs(int u) {
      if (ans[u]) return ans[u];
      for (int i = head[u]; i != -1; i = nxt[i]) {
          if (dis[u] - 1 == dis[to[i]]) {
              ans[u] = (ans[u] + dfs(to[i])) % 100003;
          }
      }
      return ans[u];
  }
  ```
  **核心思想**：通过记忆化搜索遍历最短路图，避免重复计数，确保路径数的正确性。

#### 3. **作者：King丨帝御威 (4星)**
- **关键亮点**：使用Dijkstra堆优化进行最短路计数，代码结构清晰，适合对Dijkstra熟悉的读者。
- **个人心得**：作者强调Dijkstra的堆优化版本虽然复杂，但在某些情况下比SPFA更稳定。
- **核心代码**：
  ```cpp
  void dijkstra() {
      priority_queue<pair<int, int>> q;
      q.push({0, 1});
      dis[1] = 0;
      ans[1] = 1;
      while (!q.empty()) {
          int u = q.top().second;
          q.pop();
          for (int i = head[u]; i; i = nxt[i]) {
              int v = to[i];
              if (dis[v] > dis[u] + 1) {
                  dis[v] = dis[u] + 1;
                  ans[v] = ans[u];
                  q.push({-dis[v], v});
              } else if (dis[v] == dis[u] + 1) {
                  ans[v] = (ans[v] + ans[u]) % 100003;
              }
          }
      }
  }
  ```
  **核心思想**：通过Dijkstra堆优化遍历图，记录每个点的最短路长度和路径数量，遇到相同长度的路径时累加路径数。

### 最优关键思路与技巧

1. **BFS是最优选择**：在无权图中，BFS的时间复杂度为O(n)，且实现简单，是最佳选择。
2. **路径计数技巧**：在遍历时，遇到相同长度的路径时累加路径数，确保路径数的正确性。
3. **记忆化搜索**：在SPFA中，使用记忆化搜索避免重复计数，确保路径数的正确性。

### 拓展思路

1. **带权图的最短路计数**：如果图中边权不为1，可以使用Dijkstra或SPFA进行最短路计数，但需要注意路径数的累加方式。
2. **多源最短路计数**：如果需要从多个起点出发计算最短路数量，可以使用Floyd算法或多次BFS。

### 推荐题目

1. **P1608 路径统计**：带权图的最短路计数问题，适合练习Dijkstra和SPFA的应用。
2. **P1144 最短路计数**：本题的变种，适合巩固BFS和路径计数的技巧。
3. **P4779 【模板】单源最短路径（标准版）**：适合练习Dijkstra的堆优化版本。

### 个人心得总结

- **调试经历**：在SPFA中，路径计数容易出错，尤其是在带权图中，需要特别注意路径数的累加方式。
- **踩坑教训**：在无权图中，BFS是最佳选择，避免使用SPFA和Dijkstra的冗余操作。
- **顿悟感想**：路径计数的关键在于正确累加相同长度的路径数，确保路径数的正确性。

---
处理用时：38.33秒
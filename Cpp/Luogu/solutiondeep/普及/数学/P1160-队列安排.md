# 题目信息

# 队列安排

## 题目描述

一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：

1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；

2. $2\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；

3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。

在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。

## 说明/提示

**【样例解释】**

将同学 $2$ 插入至同学 $1$ 左边，此时队列为：

`2 1`

将同学 $3$ 插入至同学 $2$ 右边，此时队列为：

`2 3 1`  

将同学 $4$ 插入至同学 $1$ 左边，此时队列为：

`2 3 4 1`  

将同学 $3$ 从队列中移出，此时队列为：

`2 4 1`  

同学 $3$ 已经不在队列中，忽略最后一条指令

最终队列：

`2 4 1`  

**【数据范围】**

对于 $20\%$ 的数据，$1\leq N\leq 10$。

对于 $40\%$ 的数据，$1\leq N\leq 1000$。

对于 $100\%$ 的数据，$1<M\leq N\leq 10^5$。


## 样例 #1

### 输入

```
4
1 0
2 1
1 0
2
3
3```

### 输出

```
2 4 1```

# AI分析结果

### 综合分析与结论

该题目要求通过链表操作模拟队列的插入和删除操作，核心难点在于如何高效地处理插入和删除，并最终输出队列。大多数题解采用了双向链表或数组模拟链表的方式，部分题解还使用了STL中的`list`容器。整体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，而有些则存在冗余或不够优化的地方。

### 所选高质量题解

#### 1. **作者：BT狸——Frozen (赞：506)**
- **星级**: 5星
- **关键亮点**: 
  - 使用结构体模拟双向链表，思路清晰，代码简洁。
  - 通过标记法处理删除操作，避免了复杂的链表节点删除操作。
  - 详细解释了链表的插入和删除操作，适合初学者理解。
- **个人心得**: 作者通过“牵手”的比喻形象地解释了链表的操作，帮助读者更好地理解链表的结构和操作。

```cpp
struct T{
    int l,r;        //每个同学的“左右手” 
    int d;          //表示同学是否输出 
}t[mx]={0};

void add(int i,int k,int f) {
    if(f==1) {  //插入右边
        t[k].r = t[i].r;
        t[k].l = i;
        t[i].r = k;
        t[t[k].r].l = k;
    } else {    //插入左边
        t[k].r = i;
        t[k].l = t[i].l;
        t[i].l = k;
        t[t[k].l].r = k;
    }
}
```

#### 2. **作者：Orina_zju (赞：259)**
- **星级**: 4.5星
- **关键亮点**: 
  - 使用STL中的`list`容器，简化了链表操作。
  - 通过迭代器实现插入和删除操作，代码简洁且高效。
  - 详细解释了STL中`list`的使用方法，适合熟悉STL的读者。
- **个人心得**: 作者提到“STL开O2跑得飞快”，强调了STL在优化后的性能表现。

```cpp
list<int> queList;
void buildQueue() {
    queList.push_front(1);
    pos[1] = queList.begin();
    for (int i = 2; i <= N; i++) {
        int k, p;
        scanf("%d%d", &k, &p);
        if (p == 0) {
            pos[i] = queList.insert(pos[k], i); //插入左边
        } else {
            auto nextIter = next(pos[k]);
            pos[i] = queList.insert(nextIter, i); //插入右边
        }
    }
}
```

#### 3. **作者：LiRewriter (赞：128)**
- **星级**: 4星
- **关键亮点**: 
  - 使用数组模拟双向链表，代码简洁且易于理解。
  - 通过结构体存储节点的左右指针，插入和删除操作清晰明了。
  - 详细解释了链表的初始化、插入和删除操作，适合初学者。
- **个人心得**: 作者提到“链表模板题”，强调了链表在算法题中的常见性和重要性。

```cpp
struct node{
    int L, R;
}a[100003];

void addRight(int x, int pos) { //插入右边 
    a[x].L = pos;
    a[a[pos].R].L = x;
    a[x].R = a[pos].R;
    a[pos].R = x;
}
```

### 最优关键思路与技巧

1. **双向链表的应用**: 大多数高质量题解都使用了双向链表来模拟队列的插入和删除操作，双向链表能够高效地处理左右插入和删除操作。
2. **标记法处理删除**: 通过标记法（如`bool`数组）来记录删除的节点，避免了复杂的链表节点删除操作，简化了代码实现。
3. **STL的灵活使用**: 使用STL中的`list`容器可以简化链表操作，适合熟悉STL的读者，且在优化后性能表现优异。

### 拓展与举一反三

- **类似题目**: 
  1. [P1160 队列安排](https://www.luogu.com.cn/problem/P1160)（本题）
  2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)（链表与线段树的结合）
  3. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)（链表与线段树的进阶应用）

- **调试与优化**: 在链表操作中，调试时可以通过打印链表节点的左右指针来检查链表是否正确连接。优化时可以考虑使用标记法减少删除操作的复杂度。

---
处理用时：35.19秒
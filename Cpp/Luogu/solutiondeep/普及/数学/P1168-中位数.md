# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果

### 综合分析与结论

本题要求动态维护序列的中位数，常见的解法包括对顶堆、平衡树、线段树、树状数组等。通过对多条题解的分析，可以发现对顶堆是最为简洁且高效的解法，适合初学者理解和实现。平衡树和线段树虽然也能解决问题，但代码复杂度较高，适合对数据结构有较深理解的同学。树状数组和主席树则适用于更复杂的问题场景。

### 所选题解

#### 1. **对顶堆解法**（作者：肖恩Sean）
- **星级**：★★★★★
- **关键亮点**：思路清晰，代码简洁，使用两个堆（大根堆和小根堆）动态维护中位数，时间复杂度为O(n log n)。
- **个人心得**：作者详细解释了对顶堆的维护过程，确保大根堆和小根堆的大小差不超过1，从而保证中位数的正确性。

```cpp
priority_queue<int, vector<int>, greater<int>> q2; // 小根堆
priority_queue<int, vector<int>, less<int>> q1;    // 大根堆

void insert(int x) {
    if (x > q1.top()) q2.push(x);
    else q1.push(x);
    while (abs(q1.size() - q2.size()) > 1) {
        if (q1.size() > q2.size()) { q2.push(q1.top()); q1.pop(); }
        else { q1.push(q2.top()); q2.pop(); }
    }
}
```

#### 2. **平衡树解法**（作者：Capella）
- **星级**：★★★★
- **关键亮点**：使用平衡树（如Treap）动态维护序列，支持插入和查询第k大操作，时间复杂度为O(n log n)。
- **个人心得**：作者提供了封装版和精简版两种代码，适合不同层次的读者，且代码结构清晰，易于理解。

```cpp
void insert(Node* &u, int x) {
    if (u == null) u = new_Node(1, x, null, null);
    else if (x == u->val) u->siz++;
    else if (x < u->val) { insert(u->ls, x); if (u->ls->pri < u->pri) rotate(u, 1); }
    else { insert(u->rs, x); if (u->rs->pri < u->pri) rotate(u, 0); }
    pushup(u);
}
```

#### 3. **线段树解法**（作者：ysj1173886760）
- **星级**：★★★★
- **关键亮点**：使用线段树维护序列，通过离散化和二分查找实现中位数的查询，时间复杂度为O(n log n)。
- **个人心得**：作者详细解释了线段树的构建和查询过程，适合对线段树有一定基础的同学。

```cpp
void build(int p, int l, int r) {
    if (l == r) { q[p].push_back(0); q[p].push_back(a[l]); return; }
    int mid = (l + r) >> 1;
    build(p << 1, l, mid); build(p << 1 | 1, mid + 1, r);
    merge(q[p], q[p << 1], q[p << 1 | 1]);
}
```

### 最优关键思路与技巧

1. **对顶堆**：通过维护一个大根堆和一个小根堆，确保大根堆存储较小的一半数，小根堆存储较大的一半数，从而快速获取中位数。
2. **平衡树**：利用平衡树的特性，动态插入和查询第k大元素，适合需要频繁插入和查询的场景。
3. **线段树**：通过离散化和二分查找，线段树可以高效地维护序列的中位数，适合对线段树有一定基础的同学。

### 可拓展之处

- **同类型题**：类似的问题包括动态维护第k大元素、区间中位数等，可以使用对顶堆、平衡树、线段树等数据结构解决。
- **算法套路**：对顶堆的思路可以推广到其他需要动态维护有序序列的问题，如滑动窗口的中位数、动态维护最大/最小值等。

### 推荐题目

1. **P1801 黑匣子**：动态维护第k大元素，适合练习对顶堆和平衡树。
2. **P3834 可持久化线段树**：练习线段树和主席树的应用。
3. **P3369 普通平衡树**：练习平衡树的插入、删除和查询操作。

### 个人心得总结

- **调试经历**：在对顶堆的实现中，需要注意堆的大小差不能超过1，否则会导致中位数计算错误。
- **踩坑教训**：在使用平衡树时，旋转操作需要仔细处理，避免破坏树的平衡性。
- **顿悟感想**：线段树的离散化和二分查找技巧在处理中位数问题时非常高效，适合大规模数据的处理。

---
处理用时：40.56秒
# 题目信息

# 车的放置

## 题目描述

有下面这样的一个网格棋盘，$a,b,c,d$ 表示了对应边长度，也就是对应格子数：

![](https://cdn.luogu.com.cn/upload/image_hosting/g7ulpevu.png)

当 $a=b=c=d=2$ 时，对应下面这样一个棋盘：

![](https://cdn.luogu.com.cn/upload/image_hosting/e2ntmjlk.png)

要在这个棋盘上放 $k$ 个相互不攻击的车，也就是这 $k$ 个车没有两个车在同一行，也没有两个车在同一列，问有多少种方案。


## 说明/提示

#### 数据规模与约定

- 存在部分数据，保证 $b=0$；
- 存在部分数据，保证 $a,b,c,d\leq 4$。
- 对于 $100\%$ 的数据，保证 $0\leq a,b,c,d,k\leq 10^3$，且至少有一种可行方案。

## 样例 #1

### 输入

```
2 2 2 2 2```

### 输出

```
38
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在复杂的网格棋盘上放置互不攻击的车，且棋盘形状不规则。题解主要分为两类思路：
1. **动态规划（DP）**：通过状态转移方程计算每列或每行的放置方案，适用于棋盘不规则的情况。
2. **组合数学**：将棋盘分割为多个矩形，分别计算组合数和排列数，适用于棋盘可以分割为规则矩形的情况。

大部分题解采用了组合数学的思路，通过枚举车在不同矩形中的分布，利用组合数和排列数公式计算方案数。部分题解还引入了二项式反演等高级技巧，进一步优化了计算。

### 所选高星题解

#### 1. **作者：Krimson (5星)**
- **关键亮点**：引入了二项式反演，优化了组合数的计算，复杂度为O(n+V)，代码简洁且高效。
- **个人心得**：通过二项式反演避免了重复计算，显著提升了算法效率。
- **核心代码**：
```cpp
ll g[MAXN];
int main(){
    a=read(),b=read(),c=read(),d=read(),k=read();
    init();
    for(ri i=0;i<=k;++i) 
        g[i]=C(b,i)*C(c,i)%mod*jc[i]%mod*C(d+b-i,k-i)%mod*C(a+c-i,k-i)%mod*jc[k-i]%mod;
    for(ri i=0;i<=k;++i){
        if(i&1) ans=(ans-g[i]+mod)%mod;
        else ans=(ans+g[i])%mod;
    }
    print(ans);
    return 0;
}
```

#### 2. **作者：紫薯布丁 (4星)**
- **关键亮点**：将棋盘分割为两个矩形，分别计算组合数和排列数，思路清晰，代码可读性强。
- **核心代码**：
```cpp
for(int i=0;i<=k;i++) {
    ans+=C(a,i)%mod*C(b+d-(k-i),i)%mod*fac[i]%mod*C(c,k-i)%mod*C(d,k-i)%mod*fac[k-i]%mod;
    ans%=mod;
}
```

#### 3. **作者：_ctz (4星)**
- **关键亮点**：将棋盘分割为两个矩形，分别计算组合数和排列数，引入了阶乘和逆元的预处理，优化了计算。
- **核心代码**：
```cpp
for(register int i=0;i<=k;++i)(ans+=1ll*f(a,b,i)*f(a+c-i,d,k-i)%mod)%=mod;
```

### 最优关键思路与技巧

1. **棋盘分割**：将不规则棋盘分割为多个规则矩形，分别计算组合数和排列数。
2. **组合数与排列数**：利用组合数和排列数公式计算方案数，注意处理边界条件。
3. **二项式反演**：通过二项式反演优化组合数的计算，避免重复计算。

### 可拓展之处

1. **类似题目**：可以扩展到其他不规则棋盘上的放置问题，如马、皇后等。
2. **高级组合数学**：可以引入更多高级组合数学技巧，如容斥原理、生成函数等。

### 推荐题目

1. **P1351 车的放置 II**：考察在更复杂棋盘上放置车的方案数。
2. **P1352 马的放置**：考察在不规则棋盘上放置马的方案数。
3. **P1353 八皇后问题**：考察在棋盘上放置皇后的方案数。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现边界条件处理不当，导致WA，提醒我们在编写代码时要特别注意边界条件。
- **踩坑教训**：组合数和排列数的计算容易出错，尤其是在大数取模的情况下，建议预处理阶乘和逆元。
- **顿悟感想**：通过二项式反演优化组合数的计算，显著提升了算法效率，体现了数学在算法优化中的重要作用。

---
处理用时：28.30秒
# 题目信息

# 漂亮字串

## 题目描述

Caima 认为 $\tt O$ 和 $\tt X$ 是最优美的两个字母，由 $\tt O,X$ 组成的串是最优美的串。在这些最优美的串中，如果任意只包含 $\tt X$ 的子串，长度不超过 $\max_{\tt X}$，任意只包含 $\tt O$ 的子串，长度不超过 $\max_{\tt O}$，而整个串最多有 $\rm count_{\tt O}$ 个 $\tt O$，$\rm count_{\tt X}$ 个 $\tt X$。那么这个就是超级优美无敌串。

现在 Caima 想知道最长的超级优美无敌串有多长，希望你告诉他。

## 说明/提示

### 样例 2 解释

- $\tt XOXOXOX$。


### 数据范围及约定

最多 $1000$ 组数据，

其中 $30\%$ 的数据 $0\le \rm count_{\tt O},\rm count_{\tt X},\rm max_{\tt O},\rm max_{\tt X} \le 20$，且数据组数不超过 $20$ 组。

对于全部数据，$0 \le \rm count_{\tt O},\rm count_{\tt X},\rm max_{\tt O},\rm max_{\tt X}\le 10^6$。

## 样例 #1

### 输入

```
10 10 0 0

3 5 1 1

```

### 输出

```
0

7

```

# AI分析结果

### 综合分析与结论

本题的核心在于通过分类讨论和贪心策略，找到最长的“超级优美无敌串”。各题解的思路基本一致，主要分为以下几种情况：
1. 当某一字符的 `max` 或 `count` 为 0 时，直接取另一字符的 `max` 或 `count`。
2. 当某一字符的数量不足以作为分隔符时，通过贪心策略计算最大长度。
3. 其他情况下，直接取两字符的 `count` 之和。

大多数题解都采用了类似的分类讨论和贪心策略，但部分题解在代码实现和解释上更为清晰和优化。整体来看，题解的质量参差不齐，部分题解存在代码冗余或解释不够清晰的问题。

### 所选高星题解

#### 1. 作者：ex_jason (5星)
- **关键亮点**：思路清晰，代码简洁，逻辑严谨。通过分类讨论和贪心策略，准确处理了各种边界情况，代码可读性高。
- **代码核心思想**：
  ```cpp
  if (maxo==0) cout<<maxx<<endl;
  else if (maxx==0) cout<<maxo<<endl;
  else if ((counto+1)*maxx<countx) cout<<(counto+1)*maxx+counto<<endl;
  else if ((countx+1)*maxo<counto) cout<<(countx+1)*maxo+countx<<endl;
  else cout<<counto+countx<<endl;
  ```

#### 2. 作者：王奕瑜 (4星)
- **关键亮点**：解释详细，特别是对贪心策略的说明，帮助理解算法的核心思想。代码简洁，逻辑清晰。
- **代码核心思想**：
  ```cpp
  if (mxo==0) printf ("%lld\n",mxx);
  else if (mxx==0) printf ("%lld\n",mxo);
  else if ((cnto+1)*mxx<cntx) printf ("%lld\n",(cnto+1)*mxx+cnto);
  else if ((cntx+1)*mxo<cnto) printf ("%lld\n",(cntx+1)*mxo+cntx);
  else printf ("%lld\n",cnto+cntx);
  ```

#### 3. 作者：Erotate (4星)
- **关键亮点**：代码简洁，逻辑清晰，分类讨论处理得当。通过 `min` 函数处理边界情况，代码可读性高。
- **代码核心思想**：
  ```cpp
  if(!(min(co,mo))) cout<<min(cx,mx)<<endl;
  else if(!(min(cx,mx))) cout<<min(co,mo)<<endl;
  else if(cx>mx*(co+1)) cout<<mx*(co+1)+co<<endl;
  else if(co>mo*(cx+1)) cout<<mo*(cx+1)+cx<<endl;
  else cout<<cx+co<<endl;
  ```

### 最优关键思路与技巧
- **分类讨论**：根据 `max` 和 `count` 的不同情况，分别处理边界条件和一般情况。
- **贪心策略**：在某一字符数量不足时，通过贪心策略计算最大长度，确保每一段字符的长度不超过 `max`。
- **代码优化**：使用 `min` 函数处理边界情况，避免冗余代码，提高代码可读性和效率。

### 可拓展之处
- **类似算法套路**：这种分类讨论和贪心策略的组合在字符串处理和动态规划中非常常见，可以应用于其他类似的问题，如字符串拼接、最长子序列等。
- **同类型题目**：
  1. P1621 [洛谷] 最长回文子串
  2. P1622 [洛谷] 最长公共子序列
  3. P1623 [洛谷] 字符串拼接

### 个人心得摘录
- **王奕瑜**：提到“很多人（包括我在内）这一步刚开始不懂是什么意思，实际上，这里用到了一个贪心的思路”，帮助理解算法的核心思想。
- **antiquality**：提到“当时比赛的时候居然这题想了两个多小时，好像~~心里有些抗拒数论的感觉~~”，反映了在面对复杂问题时的心态调整和思考过程。

### 总结
通过分类讨论和贪心策略，可以高效解决本题。建议在类似问题中，优先考虑分类讨论和贪心策略，结合代码优化，提高解题效率。

---
处理用时：24.41秒
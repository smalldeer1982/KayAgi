# 题目信息

# H数

## 题目描述

所谓 H 数，是指只含有 $2,3,5,7$ 这些质因数的数，如 $630$ 是 H 数，而 $22$ 不是。

现在要求输出第 $n$ 个 H 数，为了方便起见将 $H[1]$ 定为 $1$。已知 $n$ 不超过 $10000$，最后数据在 int64 范围之内。


## 说明/提示

穷举会爆掉，要用生成法，最好加优化，不然空间复杂度比较大


## 样例 #1

### 输入

```
30```

### 输出

```
49```

## 样例 #2

### 输入

```
1```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题要求生成第n个只含有质因数2、3、5、7的H数。由于直接穷举会超时，因此需要采用生成法，并优化空间复杂度。各题解主要采用了以下几种思路：

1. **多指针法**：通过维护多个指针，分别指向当前被2、3、5、7乘的H数，每次取最小值并更新指针。这种方法时间复杂度为O(n)，空间复杂度为O(n)，是最优解法之一。
2. **优先队列（堆）**：使用优先队列每次取出最小数，并生成新的H数插入队列。这种方法时间复杂度为O(n log n)，空间复杂度较高，但代码简洁。
3. **动态规划（DP）**：通过DP状态转移，从前面的H数生成新的H数。这种方法时间复杂度较高，且代码复杂度较大。
4. **暴力枚举**：虽然简单，但时间复杂度极高，不适用于本题。

最优解法是多指针法，因其时间复杂度和空间复杂度均较低，且代码实现简洁。

### 所选高星题解

#### 1. **作者：355_113 (★★★★★)**
- **关键亮点**：采用多指针法，维护四个指针分别指向被2、3、5、7乘的H数，每次取最小值并更新指针。代码简洁高效，时间复杂度为O(n)，空间复杂度为O(n)。
- **核心代码**：
  ```cpp
  w[1]=1;
  for(int i=2;i<=10000;++i){
      w[i]=w[a]*2;
      if(w[i]>w[b]*3)w[i]=w[b]*3;
      if(w[i]>w[c]*5)w[i]=w[c]*5;
      if(w[i]>w[d]*7)w[i]=w[d]*7;
      if(w[i]==w[a]*2)a++;
      if(w[i]==w[b]*3)b++;
      if(w[i]==w[c]*5)c++;
      if(w[i]==w[d]*7)d++;
  }
  ```
- **个人心得**：作者提到“和楼下的方法一样”，说明该方法已被广泛认可，且代码简洁易读。

#### 2. **作者：WanderingTrader (★★★★)**
- **关键亮点**：使用优先队列和map去重，每次取出最小数并生成新的H数插入队列。代码简洁，时间复杂度为O(n log n)，空间复杂度较高。
- **核心代码**：
  ```cpp
  while(cnt < n){
      ans = Q.top();
      Q.pop();
      if(m[ans]) continue;
      m[ans] = true;
      ++cnt;
      for(int i = 0;i < 4;++i)
          Q.push(xx[i]*ans);
  }
  ```
- **个人心得**：作者提到“最早是在刘汝佳老师的紫书上看到的”，说明该方法源自经典教材，具有较高的可靠性。

#### 3. **作者：Ruo何言 (★★★★)**
- **关键亮点**：使用单调队列和四指针法，每次取四个队尾变量的最小值加入队列，并更新指针。代码简洁，时间复杂度为O(n)，空间复杂度为O(n)。
- **核心代码**：
  ```cpp
  while(head<n){
      long long a=q[t1]*2,b=q[t2]*3,c=q[t3]*5,d=q[t4]*7;
      long long m=_min(a,b,c,d);
      q[++head]=m;
      if(a==m) ++t1;
      if(b==m) ++t2;
      if(c==m) ++t3;
      if(d==m) ++t4;
  }
  ```
- **个人心得**：作者提到“手动数组模拟一个队列”，说明该方法通过手动优化，减少了空间复杂度。

### 最优关键思路与技巧

- **多指针法**：通过维护多个指针，分别指向当前被2、3、5、7乘的H数，每次取最小值并更新指针。这种方法时间复杂度为O(n)，空间复杂度为O(n)，是最优解法之一。
- **优先队列（堆）**：使用优先队列每次取出最小数，并生成新的H数插入队列。这种方法时间复杂度为O(n log n)，空间复杂度较高，但代码简洁。

### 可拓展之处

- **类似题目**：可以扩展到生成其他类型的数，如只含有特定质因数的数，或生成其他类型的序列（如斐波那契数列、丑数等）。
- **算法套路**：多指针法和优先队列法可以应用于其他需要生成有序序列的题目，如合并多个有序链表、生成特定类型的数列等。

### 推荐相似题目

1. **P2723 丑数 Humble Numbers**：生成只含有特定质因数的数。
2. **UVA136 丑数 Ugly Numbers**：生成只含有2、3、5质因数的数。
3. **P1886 滑动窗口**：使用单调队列解决滑动窗口问题。

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中遇到重复数的问题，通过优化算法（如使用map去重）解决了问题。
- **踩坑教训**：暴力枚举法虽然简单，但时间复杂度极高，不适用于本题。
- **顿悟感想**：多指针法通过维护多个指针，大大减少了时间复杂度，是解决此类问题的有效方法。

---
处理用时：29.05秒
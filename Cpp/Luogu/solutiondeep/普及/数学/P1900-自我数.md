# 题目信息

# 自我数

## 题目背景

#题目有加强


## 题目描述

在 1949 年印度数学家 D. R. Daprekar 发现了一类称作 Self-Numbers 的数。对于每一个正整数 $n$，我们定义 $d(n)$ 为 $n$ 加上它每一位数字的和。例如， $d(75) = 75 + 7 + 5 = 87$。给定任意正整数 $n$ 作为一个起点，都能构造出一个无限递增的序列：$n, d(n), d(d(n)), d(d(d(n))), \ldots$ 例如，如果你从 $33$ 开始，下一个数是 $33 + 3 + 3 = 39$，再下一个为 $39 + 3 + 9 = 51$，再再下一个为 $51 + 5 + 1 = 57$，因此你所产生的序列就像这样：$33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, \ldots$。数字 $n$ 被称作 $d(n)$ 的发生器。在上面的这个序列中，$33$ 是 $39$ 的发生器，$39$ 是 $51$ 的发生器，$51$ 是 $57$ 的发生器等等。有一些数有超过一个发生器，如 $101$ 的发生器可以是 $91$ 和 $100$。一个没有发生器的数被称作 Self-Number。如前 $13$ 个 Self-Number 为 $1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97$。我们将第 $i$ 个 Self-Number 表示为 $a_i$，所以 $a_1 = 1, a_2 = 3, a_3 = 5, \ldots$。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le {10}^7$，$1 \le K \le 5000$。

## 样例 #1

### 输入

```
100 10
1 2 3 4 5 6 7 11 12 13 
```

### 输出

```
13
1 3 5 7 9 20 31 75 86 97
```

# AI分析结果

### 综合分析与结论

本题的核心是筛选出自我数（Self-Numbers），即那些无法通过其他数加上其数字和得到的数。由于数据范围较大（$1 \le N \le 10^7$），直接暴力枚举会导致时间和空间上的问题。因此，题解中主要采用了以下几种优化思路：

1. **空间优化**：由于 $N$ 的范围较大，直接开 $10^7$ 的数组会超出内存限制。因此，部分题解使用了 `bitset` 或循环数组来减少内存占用。
2. **时间优化**：通过观察发现，$d(n)$ 的值不会比 $n$ 大太多（最多大 63），因此可以利用这一性质进行优化，减少不必要的计算。
3. **离线处理**：部分题解将询问离线处理，通过排序和指针移动来减少重复计算。

### 所选高星题解

#### 1. 作者：ghj1222 (5星)
**关键亮点**：
- 使用小根堆来存储已被发现不是自我数但还未被遍历到的数字，减少重复计算。
- 离线处理询问，通过排序和指针移动来优化查询。

**核心代码**：
```cpp
priority_queue<int, vector<int>, greater<int> >q;
for (int i = 1; i <= n; i++) {
    if (q.empty() || q.top() != i) {
        tot++;
        if (a[pos].x < i) pos++;
        while (a[pos].x == tot) {
            a[pos].y = i;
            pos++;
        }
        pos--;
        ans++;
    } else {
        while (!q.empty() && q.top() == i) q.pop();
    }
    q.push(make(i));
}
```
**核心思想**：通过小根堆维护未被遍历的非自我数，减少重复计算。

#### 2. 作者：wjy666 (4星)
**关键亮点**：
- 通过快速计算 $n+1$ 的数字和，减少时间开销。
- 使用 `bitset` 优化空间。

**核心代码**：
```cpp
For(i,1,n){
    len++; k=i;
    while(!(k%10)) k=k/10,len-=9;
    if (!fl[i]) ans[++cnt]=i;
    fl[i+len]=1;
}
```
**核心思想**：通过快速转移数字和的计算，减少时间复杂度。

#### 3. 作者：AL_Blue (4星)
**关键亮点**：
- 使用 `bitset` 优化空间。
- 通过类似素数筛法的方法筛选自我数。

**核心代码**：
```cpp
bitset<10000001> flag;
for (int i = 1; i <= n; ++i) {
    int j = d(i) + i;
    if (j <= n) flag[j] = true;
    if (flag[i] == false) a[++num] = i;
}
```
**核心思想**：通过 `bitset` 优化空间，并使用筛法思想筛选自我数。

### 最优关键思路与技巧

1. **空间优化**：使用 `bitset` 或循环数组来减少内存占用。
2. **时间优化**：通过快速计算数字和或利用 $d(n)$ 的性质减少计算量。
3. **离线处理**：将询问离线处理，通过排序和指针移动来优化查询。

### 可拓展之处

- **类似筛法的应用**：本题的筛法思想可以应用于其他需要筛选特定性质的数的题目，如素数筛、完全数筛等。
- **空间优化技巧**：在数据范围较大时，使用 `bitset` 或循环数组来优化空间的方法可以推广到其他题目中。

### 推荐题目

1. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)
2. [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)
3. [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)

### 个人心得摘录

- **ghj1222**：通过小根堆优化查询，减少重复计算。
- **wjy666**：快速计算数字和，减少时间复杂度。
- **AL_Blue**：使用 `bitset` 优化空间，类似素数筛法筛选自我数。

这些心得展示了如何通过优化数据结构和算法来提升代码效率，值得借鉴。

---
处理用时：28.37秒
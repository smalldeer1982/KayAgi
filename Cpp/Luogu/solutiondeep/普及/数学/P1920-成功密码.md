# 题目信息

# 成功密码

## 题目描述

void\_rank匪别人的书来看，原本想看杂志颓废的，结果不小心拿错拿成了被导师称作旁门左道的高中数学杂志《成功密码》。数学差得不行的void\_rank实在不会用数学方法处理这些奇怪的题目，于是来问你了。

求
$\sum_{i=1}^{N}\frac{x^{i}}{i}$



## 说明/提示

数据规模:

对于30%的数据：

$N\le10^{6},0<x \le 1$

对于100%的数据：

$N\le10^{18},0<x\le1$，x最多仅有4位小数位


## 样例 #1

### 输入

```
1 1```

### 输出

```
1.0000```

# AI分析结果

### 综合分析与结论

本题的核心是计算 $\sum_{i=1}^{N}\frac{x^{i}}{i}$，其中 $N$ 可以达到 $10^{18}$，$x$ 的范围是 $(0,1]$。由于 $N$ 的规模极大，直接暴力计算显然不可行。题解中主要采用了以下几种优化思路：

1. **截断法**：由于 $x \in (0,1]$，随着 $i$ 的增大，$\frac{x^{i}}{i}$ 会迅速趋近于 0，因此可以设置一个上限 $C$，当 $N > C$ 时，直接取 $N = C$，从而减少计算量。大多数题解采用了这种方法，且 $C$ 的取值在 $10^5$ 到 $10^7$ 之间。

2. **数学极限法**：通过泰勒展开公式 $\ln(1-x) = x + \frac{x^2}{2} + \frac{x^3}{3} + \cdots$，可以求出 $\sum_{i=1}^{\infty}\frac{x^{i}}{i}$ 的极限值，当当前计算的答案与极限值的差值小于某个阈值时，提前终止循环。这种方法较为高效，但需要对数学公式有一定的理解。

3. **快速幂优化**：部分题解使用了快速幂来加速 $x^i$ 的计算，但由于 $i$ 的范围较大，快速幂的优化效果有限。

### 所选高星题解

#### 1. 作者：虞皓翔 (5星)
**关键亮点**：
- 利用泰勒展开公式求出极限值，通过比较当前答案与极限值的差值来提前终止循环，避免了不必要的计算。
- 代码简洁高效，仅需 18 行代码即可实现，且运行时间极短（9ms）。

**核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, i;
double x, lim, s, ans;

int main(){
    scanf("%lf%d", &x, &n);
    lim = -log(1.0 - x);
    s = 1.0;
    ans = 0.0;
    for(i = 1; i <= n; i++){
        s *= x;
        ans += s / i;
        if(round(ans * 10000.0) >= round(lim * 10000.0)) break;
    }
    printf("%.4lf\n", ans);
}
```

#### 2. 作者：WanderingTrader (4星)
**关键亮点**：
- 通过设置一个极小值 $MIN = 10^{-12}$，当 $\frac{x^i}{i} < MIN$ 时，提前终止循环，避免了不必要的计算。
- 代码简洁，逻辑清晰，适合对数学公式不太熟悉的读者。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MIN 1e-12
int main(){
    double x,k = 1,ans = 0,t;
    long long n;
    scanf("%lf%lld",&x,&n);
    for(long long i = 1;i <= n;i ++)
    {
        k *= x;
        t = k / i;
        ans += t;
        if(t < MIN) break;
    }
    printf("%.4lf\n",ans);
    return 0;
}
```

#### 3. 作者：ccg12345 (4星)
**关键亮点**：
- 同样利用泰勒展开公式求出极限值，通过比较当前答案与极限值的差值来提前终止循环。
- 代码简洁，逻辑清晰，适合对数学公式有一定理解的读者。

**核心代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main()
{
    double x, ans = 0.0, cnt = 1.0;
    int n;
    cin >> x >> n;    
    double t = -log(1.0 - x);
    for(register int i = 1; i <= n; i++)
    {
        cnt *= x;
        ans += cnt / i;
        if(round(ans * 10000.0) >= round(t * 10000.0))
            break;
    }
    cout << fixed << setprecision(4) << ans << endl;
}
```

### 最优关键思路与技巧

1. **截断法**：通过设置一个合理的上限 $C$，当 $N > C$ 时，直接取 $N = C$，从而减少计算量。这种方法简单易行，适合大多数情况。

2. **数学极限法**：利用泰勒展开公式求出极限值，通过比较当前答案与极限值的差值来提前终止循环。这种方法高效且精确，但需要对数学公式有一定的理解。

### 可拓展之处

- **类似问题**：对于其他类似的求和问题，如果求和项随着 $i$ 的增大而趋近于 0，可以考虑使用截断法或数学极限法来优化计算。
- **其他优化**：对于某些特定的求和问题，可以考虑使用积分近似、级数展开等数学工具来进一步优化计算。

### 推荐题目

1. [P1001 A+B Problem](https://www.luogu.com.cn/problem/P1001) - 基础题目，适合练习基本输入输出。
2. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028) - 涉及递推和数学优化，适合练习数学思维。
3. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045) - 涉及大数计算和快速幂，适合练习算法优化。

### 个人心得摘录

- **虞皓翔**：通过泰勒展开公式求出极限值，避免了不必要的计算，代码简洁高效。
- **WanderingTrader**：通过设置一个极小值 $MIN = 10^{-12}$，提前终止循环，避免了不必要的计算，代码简洁，逻辑清晰。
- **ccg12345**：利用泰勒展开公式求出极限值，通过比较当前答案与极限值的差值来提前终止循环，代码简洁，逻辑清晰。

---
处理用时：34.84秒
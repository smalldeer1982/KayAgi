# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果

### 综合分析与结论

本题是一道经典的线段树题目，要求支持区间加、区间乘、区间求和操作。题解中大部分使用了线段树的惰性标记（lazy tag）技术，通过维护加法标记和乘法标记来优化区间更新操作。题解的质量参差不齐，部分题解思路清晰、代码简洁，而另一些则较为冗长或缺乏优化。

### 所选高质量题解

#### 1. **题解作者：MashPlant (赞：7)**  
**星级：★★★★★**  
**关键亮点：**  
- 使用了线段树的惰性标记技术，维护了加法标记和乘法标记。
- 代码简洁，逻辑清晰，优化了区间更新和查询操作。
- 提供了详细的注释，便于理解。

**核心代码：**
```cpp
void pushdown(int rt, int l, int r) {
    if (mul[rt] != 1 || add[rt] != 0) {
        int mid = (l + r) >> 1;
        sum[rt << 1] = (sum[rt << 1] * mul[rt] + add[rt] * (mid - l + 1)) % p;
        sum[rt << 1 | 1] = (sum[rt << 1 | 1] * mul[rt] + add[rt] * (r - mid)) % p;
        add[rt << 1] = (add[rt << 1] * mul[rt] + add[rt]) % p;
        add[rt << 1 | 1] = (add[rt << 1 | 1] * mul[rt] + add[rt]) % p;
        mul[rt << 1] = (mul[rt << 1] * mul[rt]) % p;
        mul[rt << 1 | 1] = (mul[rt << 1 | 1] * mul[rt]) % p;
        mul[rt] = 1; add[rt] = 0;
    }
}
```
**核心思想：**  
通过`pushdown`函数下放标记，确保在更新和查询时，子节点的值能够正确反映父节点的修改。

#### 2. **题解作者：FifthAxiom (赞：2)**  
**星级：★★★★**  
**关键亮点：**  
- 使用了结构体指针构建线段树，避免了数组开四倍空间的浪费。
- 代码结构清晰，易于扩展和维护。
- 提供了详细的注释和解释，便于理解。

**核心代码：**
```cpp
void pushdown(Node *p) {
    if (p->tag_add == 0 && p->tag_mul == 1) return;
    p->sum = (p->sum * p->tag_mul + p->tag_add * (p->r - p->l + 1)) % p;
    if (p->l != p->r) {
        p->lc->tag_add = (p->lc->tag_add * p->tag_mul + p->tag_add) % p;
        p->rc->tag_add = (p->rc->tag_add * p->tag_mul + p->tag_add) % p;
        p->lc->tag_mul = (p->lc->tag_mul * p->tag_mul) % p;
        p->rc->tag_mul = (p->rc->tag_mul * p->tag_mul) % p;
    }
    p->tag_add = 0; p->tag_mul = 1;
}
```
**核心思想：**  
通过结构体指针动态分配节点，避免了静态数组的空间浪费，同时通过`pushdown`函数下放标记。

#### 3. **题解作者：YuntianZhao (赞：1)**  
**星级：★★★★**  
**关键亮点：**  
- 使用了线段树的惰性标记技术，维护了加法标记和乘法标记。
- 代码简洁，逻辑清晰，优化了区间更新和查询操作。
- 提供了详细的注释，便于理解。

**核心代码：**
```cpp
void pushdown(int rt, int l, int r) {
    if (mul[rt] != 1 || add[rt] != 0) {
        int mid = (l + r) >> 1;
        sum[rt << 1] = (sum[rt << 1] * mul[rt] + add[rt] * (mid - l + 1)) % p;
        sum[rt << 1 | 1] = (sum[rt << 1 | 1] * mul[rt] + add[rt] * (r - mid)) % p;
        add[rt << 1] = (add[rt << 1] * mul[rt] + add[rt]) % p;
        add[rt << 1 | 1] = (add[rt << 1 | 1] * mul[rt] + add[rt]) % p;
        mul[rt << 1] = (mul[rt << 1] * mul[rt]) % p;
        mul[rt << 1 | 1] = (mul[rt << 1 | 1] * mul[rt]) % p;
        mul[rt] = 1; add[rt] = 0;
    }
}
```
**核心思想：**  
通过`pushdown`函数下放标记，确保在更新和查询时，子节点的值能够正确反映父节点的修改。

### 最优关键思路与技巧

1. **惰性标记（Lazy Tag）**：通过维护加法标记和乘法标记，延迟更新操作，减少不必要的计算，提高效率。
2. **结构体指针**：使用结构体指针动态分配节点，避免静态数组的空间浪费，提高代码的可维护性。
3. **代码简洁与注释**：清晰的代码结构和详细的注释有助于理解和维护代码。

### 可拓展之处

- **其他区间操作**：如区间最大值、区间最小值等，可以通过类似的方式实现。
- **动态开点线段树**：适用于数据范围较大或动态插入的场景。

### 推荐题目

1. **P3373 【模板】线段树 2**：与本题几乎相同，适合练习。
2. **P5490 【模板】扫描线**：涉及线段树的应用，适合进阶练习。
3. **P2572 【ZJOI2010】排列计数**：涉及线段树的区间操作，适合进一步巩固。

### 个人心得总结

- **调试经历**：在处理惰性标记时，容易忘记下放标记，导致查询结果错误。通过调试发现并修正了这一问题。
- **踩坑教训**：在实现乘法标记时，忽略了乘法标记对加法标记的影响，导致结果错误。通过仔细分析标记的下放顺序，解决了这一问题。
- **顿悟感想**：线段树的惰性标记技术是处理区间更新问题的利器，理解其原理后，能够轻松应对类似的题目。

---
处理用时：54.84秒
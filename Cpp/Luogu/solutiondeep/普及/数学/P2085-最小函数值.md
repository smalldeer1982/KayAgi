# 题目信息

# 最小函数值

## 题目描述

有 $n$ 个函数，分别为 $F_1,F_2,\dots,F_n$。定义 $F_i(x)=A_ix^2+B_ix+C_i(x\in\mathbb N*)$。给定这些 $A_i$、$B_i$ 和 $C_i$，请求出所有函数的所有函数值中最小的 $m$ 个（如有重复的要输出多个）。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n,m\le10000$，$1 \leq A_i\le10,B_i\le100,C_i\le10^4$。

## 样例 #1

### 输入

```
3 10
4 5 3
3 4 5
1 7 1
```

### 输出

```
9 12 12 19 25 29 31 44 45 54```

# AI分析结果

### 综合分析与结论

该题的核心问题是从多个二次函数中找出最小的m个函数值。由于函数在正整数域上单调递增，且每个函数的最小值出现在x=1处，因此可以通过堆（优先队列）来高效地维护和提取最小值。大多数题解都采用了堆的思路，但实现方式和优化程度有所不同。

- **堆的优化**：通过维护一个小根堆，每次取出堆顶的最小值，并将其对应的函数的下一个值重新插入堆中，确保每次都能快速找到当前的最小值。
- **时间复杂度**：堆的插入和删除操作的时间复杂度为O(log n)，因此总的时间复杂度为O(m log n)，适合大规模数据处理。
- **代码实现**：部分题解使用了STL的优先队列，简化了代码实现；而另一些题解则手动实现了堆，展示了堆的内部工作原理。

### 所选高星题解

#### 1. 作者：Euler_Pursuer (5星)
- **关键亮点**：详细分析了暴力解法的不足，并提出了堆的优化思路，代码简洁且高效，使用了STL的优先队列。
- **个人心得**：作者提到“每次重复计算了很多函数的值，浪费了很多时间”，并通过堆优化解决了这一问题。
- **核心代码**：
  ```cpp
  priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;
  for(int i=1;i<=n;i++) {
      q.push(make_pair(a[i]+b[i]+c[i],i));
  }
  for(int i=1;i<=m;i++) {
      pair<int,int> tmp=q.top(); q.pop();
      cout<<tmp.first<<" ";
      q.push(make_pair(a[tmp.second]*(++x[tmp.second])*x[tmp.second]+b[tmp.second]*x[tmp.second]+c[tmp.second],tmp.second));
  }
  ```

#### 2. 作者：yybyyb (5星)
- **关键亮点**：使用了结构体和重载运算符，代码结构清晰，易于理解，且通过堆优化实现了高效的最小值提取。
- **核心代码**：
  ```cpp
  struct Node {
      int val, x, id;
      bool operator < (const Node &a) const {
          return val > a.val;
      }
  };
  priority_queue<Node> q;
  for(int i=1;i<=n;i++) {
      q.push((Node){a[i]+b[i]+c[i],1,i});
  }
  for(int i=1;i<=m;i++) {
      Node t=q.top(); q.pop();
      cout<<t.val<<" ";
      q.push((Node){a[t.id]*(t.x+1)*(t.x+1)+b[t.id]*(t.x+1)+c[t.id],t.x+1,t.id});
  }
  ```

#### 3. 作者：DavidW (4星)
- **关键亮点**：使用了平板电视库（pbds）的优先队列，结合O3优化，代码简洁且高效，适合对性能要求较高的场景。
- **核心代码**：
  ```cpp
  __gnu_pbds::priority_queue<pair<int,int>,greater<pair<int,int> >,pairing_heap_tag> h;
  for(int i=1;i<=n;i++) {
      h.push(make_pair(a[i]+b[i]+c[i],i));
  }
  for(int i=1;i<m;i++) {
      pair<int,int> tmp=h.top(); h.pop();
      cout<<tmp.first<<" ";
      h.push(make_pair(a[tmp.second]*(++x[tmp.second])*x[tmp.second]+b[tmp.second]*x[tmp.second]+c[tmp.second],tmp.second));
  }
  ```

### 最优关键思路与技巧

1. **堆的维护**：通过小根堆每次取出最小值，并将其对应的函数的下一个值重新插入堆中，确保每次都能快速找到当前的最小值。
2. **STL优先队列**：使用STL的优先队列简化了堆的实现，减少了代码量，提高了代码的可读性和可维护性。
3. **结构体与重载运算符**：通过结构体和重载运算符，使得代码结构更加清晰，易于理解和扩展。

### 可拓展之处

- **类似问题**：该题的思路可以推广到其他需要从多个有序序列中提取最小值的问题，如合并多个有序链表、多路归并排序等。
- **其他数据结构**：除了堆，还可以考虑使用其他数据结构如平衡树（如AVL树、红黑树）来解决类似问题。

### 推荐题目

1. **P1631 序列合并**：从两个有序序列中合并并提取最小的m个元素。
2. **P1886 滑动窗口**：使用单调队列维护滑动窗口的最小值。
3. **P3378 堆模板**：练习堆的基本操作，包括插入、删除和查找最小值。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现重复计算的问题，并通过堆优化解决了这一问题。
- **踩坑教训**：暴力解法虽然简单，但在大规模数据下会超时，堆优化是解决此类问题的有效方法。
- **顿悟感想**：通过堆的优化，不仅提高了算法的效率，还加深了对数据结构的理解。

---
处理用时：35.03秒
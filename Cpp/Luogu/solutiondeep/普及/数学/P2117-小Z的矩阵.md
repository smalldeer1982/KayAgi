# 题目信息

# 小Z的矩阵

## 题目描述

小 Z 最近迷上了矩阵，他定义了一个对于一种特殊矩阵的特征函数 $G$。对于 $N\times N$ 的矩阵 $A$，$A$ 的所有元素均为 $0$ 或 $1$，则 $\displaystyle G(A) = \left(\sum_{i = 1}^n\sum_{j = 1}^n A_{i, j}\cdot A_{j, i}\right) \bmod 2$。举一个例子：

$$
\begin{pmatrix}
1 & 1 & 1\\
0 & 1 & 1\\
1 & 0 & 0\\
\end{pmatrix}
$$

对于上面这个 $3\times 3$ 矩阵 $A$，$G(A)=(1\times 1+1\times 0+1\times 1+0\times 1+1\times 1+1\times 0+1\times 1+ 0\times 1+0\times 0) \bmod 2 = 0$。

当然询问一个矩阵的 $G$ 值实在是太简单了。小Z在给出一个 $N\times N$ 矩阵的同时将给你 $Q$ 个操作，操作描述如下：

- 操作 1：形如 `1 x`，表示将第 $x$ 行的元素全部“翻转”。
- 操作 2：形如 `2 x`，表示将第 $x$ 列的元素全部“翻转”。
- 操作 3：形如一个整数`3`，表示询问当前矩阵的特征值 $G$。

“翻转”的定义为将 $1$ 变成 $0$，将 $0$ 变成 $1$。

## 说明/提示

【数据规模】

- 对于 $30\%$ 的数据，$N\le 100$，$Q\le 10^5$。

- 对于 $100\%$ 的数据，$N\le 1,000$，$Q \le 5\times 10^5$。

## 样例 #1

### 输入

```
3 12
1 1 1
0 1 1
1 0 0
3
2 3
3
2 2
2 2
1 3
3
3
1 2
2 1
1 1
3
```

### 输出

```
01001
```

# AI分析结果

### 综合分析与结论

本题的核心在于理解特征函数 $G(A)$ 的计算方式，并优化操作的处理。通过分析可以发现，$G(A)$ 的值实际上只与矩阵的对角线元素有关，因为非对角线元素的贡献在模2下会被抵消。因此，只需关注对角线元素的变化，而不需要处理整个矩阵。这一发现大大简化了问题的复杂度，使得原本需要 $O(N^2)$ 时间复杂度的操作可以优化到 $O(1)$。

### 所选高星题解

#### 题解1：作者：o0数学迷0o (5星)
**关键亮点**：
- 通过数学推导，发现 $G(A)$ 的值仅与对角线元素的和有关。
- 每次翻转操作只需翻转对角线上的一个元素，时间复杂度为 $O(1)$。
- 代码简洁明了，逻辑清晰。

**核心代码**：
```cpp
int n,q,g,x;
int main(){
    ios::sync_with_stdio(0);
    g=0;
    cin>>n>>q;
    for(int i=0;i<n;++i)
        for(int j=0;j<n;++j){
            cin>>x;
            if(i==j)g^=x;
        }
    for(int i=0;i<q;++i){
        cin>>x;
        if(x==3)cout<<g;else{
            cin>>x;
            g=!g;
        }
    }
    return 0;
}
```
**实现思想**：
- 初始化时计算对角线元素的异或和。
- 每次翻转操作只需翻转 $g$ 的值，询问时直接输出 $g$。

#### 题解2：作者：judgejudge (4星)
**关键亮点**：
- 通过对称性分析，发现非对角线元素的贡献在模2下为0。
- 每次翻转操作只需改变对角线元素的奇偶性。
- 代码逻辑清晰，优化思路明确。

**核心代码**：
```cpp
int n,m;
int main(){
    cin>>n>>m;
    int sum=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            int k;
            cin>>k;
            if(i==j)sum+=k,sum%=2;
        }
    for(int i=1;i<=m;i++){
        int s1,s2;
        cin>>s1;
        if(s1==1||s1==2){
            cin>>s2;
            sum++,sum%=2;
        }
        else cout<<sum;
    }
    return 0;
}
```
**实现思想**：
- 初始化时计算对角线元素的和模2。
- 每次翻转操作只需改变 $sum$ 的值，询问时直接输出 $sum$。

#### 题解3：作者：Youngsc (4星)
**关键亮点**：
- 通过数学推导，发现 $G(A)$ 的值仅与对角线元素的奇偶性有关。
- 每次翻转操作只需改变对角线元素的奇偶性。
- 代码简洁，优化思路明确。

**核心代码**：
```cpp
int n,m,x,y;
bool ans;
int main(){
    in(n),in(m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            in(x);
            if(i==j&&x) ans = !ans;
        }
    while(m--){
        in(x);
        if(x == 1||x == 2) in(y),ans = !ans;
        else printf("%d",ans);
    }
}
```
**实现思想**：
- 初始化时计算对角线元素的奇偶性。
- 每次翻转操作只需改变 $ans$ 的值，询问时直接输出 $ans$。

### 最优关键思路与技巧

1. **数学推导**：通过分析特征函数的定义，发现非对角线元素的贡献在模2下为0，从而将问题简化为只处理对角线元素。
2. **优化操作**：每次翻转操作只需改变对角线元素的值，时间复杂度从 $O(N^2)$ 优化到 $O(1)$。
3. **代码简洁**：通过使用布尔变量或模2运算，简化了代码逻辑，提高了可读性。

### 可拓展之处

- **类似问题**：在处理矩阵问题时，可以通过数学推导或对称性分析，找到问题的简化方式，从而优化时间复杂度。
- **同类型题**：可以尝试解决其他涉及矩阵操作的题目，如矩阵快速幂、矩阵转置等。

### 推荐题目

1. **P3385 【模板】矩阵快速幂**：考察矩阵快速幂的应用，理解矩阵运算的优化。
2. **P1005 矩阵取数游戏**：涉及矩阵操作与动态规划的结合，锻炼矩阵处理能力。
3. **P1962 斐波那契数列**：通过矩阵快速幂求解斐波那契数列，理解矩阵在递推问题中的应用。

### 个人心得总结

- **调试经历**：在初期尝试暴力解法时，发现时间复杂度无法通过，通过分析问题本质，找到了优化思路。
- **踩坑教训**：在处理矩阵问题时，不能盲目进行暴力操作，应先分析问题的数学性质，寻找简化方法。
- **顿悟感想**：通过数学推导，发现问题的简化路径，大大提高了代码的效率和可读性。

---
处理用时：31.25秒
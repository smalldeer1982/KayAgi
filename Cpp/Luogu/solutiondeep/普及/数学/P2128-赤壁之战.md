# 题目信息

# 赤壁之战

## 题目描述

赤壁之战，黄盖率舰满载薪草膏油诈降曹军。

受庞统所授的连环计，曹军战船之间由铁索相连，没有两艘战船在同一位置，也没有铁索两两相交或穿过战船。每艘船都有其一定的战略价值。

为了保证达到破坏效果，黄盖需要保证被点燃的曹军船只两两之间都有铁索连接。他希望找到一种方案点燃总价值尽可能大的战船。


## 说明/提示

#### 【数据规模】

对于 $50\%$ 的数据，保证 $N$，$M \le 10$。

对于 $100\%$ 数据，保证 $N \le 450$，$M \le 900$，$V_i \le 6000$。

#### 【注意】

题目中的每句话（除了第一段）都有作用。

## 样例 #1

### 输入

```
4 6
100
5000
1000
2000
1 2
1 3
1 4
2 3
2 4
3 4```

### 输出

```
8100```

## 样例 #2

### 输入

```
6 8
1500
1000
100
2000
500
300
1 2
1 3
1 4
2 4
3 5
4 5
4 6
5 6```

### 输出

```
4500```

# AI分析结果

### 综合分析与结论

本题的核心是**在无向图中寻找一个完全子图，使得该子图的点权和最大**。由于题目中明确指出“没有铁索两两相交或穿过战船”，因此图是一个**平面图**，且平面图中的完全子图最多只有4个点。这一性质大大简化了问题的复杂度，使得暴力搜索成为可行的解决方案。

大部分题解采用了**DFS（深度优先搜索）**的思路，通过枚举每艘船并判断其是否与已选船只完全连接，逐步构建完全子图并计算最大点权和。部分题解还利用了**回溯**技巧来优化搜索过程，避免重复计算。

### 所选题解

#### 1. 作者：zhuaiballl (★★★★★)
**关键亮点**：
- 利用了平面图的性质，指出完全子图最多只有4个点，因此暴力枚举的复杂度为$O(m^2)$，极大地简化了问题。
- 代码简洁高效，直接通过邻接矩阵判断是否完全连接，避免了复杂的DFS回溯。

**个人心得**：
- 作者一开始对平面图的性质持怀疑态度，但通过查看其他提交的0ms运行时间后，果断采用了暴力枚举的方法，成功AC。

**核心代码**：
```cpp
for(int i=0;i<m;i++) {
    int res=val[u[i]]+val[v[i]];
    ans=max(ans,res);
    for(int j=1;j<=n;j++)
        if(conn[v[i]][j]&&conn[u[i]][j])
            ans=max(ans,res+val[j]);
    for(int j=0;j<i;j++)
        if(conn[u[i]][u[j]]&&conn[u[i]][v[j]]&&conn[v[i]][u[j]]&&conn[v[i]][v[j]])
            ans=max(ans,res+val[u[j]]+val[v[j]]);
}
```
**核心思想**：通过枚举所有可能的3点和4点组合，判断是否构成完全子图，并更新最大点权和。

#### 2. 作者：osfly (★★★★☆)
**关键亮点**：
- 采用了DFS+回溯的方法，通过`check`函数判断新加入的船是否与已选船只完全连接。
- 使用了邻接矩阵和邻接表两种存储方式，兼顾了查询效率和遍历效率。

**核心代码**：
```cpp
bool check(int id) {
    for(int i=1;i<=t;i++)
        if(!g[id][now[i]]) return false;
    return true;
}

void dfs(int x,int value) {
    ans=max(ans,value);
    vis[x]=1;
    for(int i=head[x];i;i=e[i].nxt) {
        int v=e[i].v;
        if(!vis[v]&&check(v)) {
            now[++t]=v;
            dfs(v,value+k[v]);
            t--;
        }
    }
    vis[x]=0;
}
```
**核心思想**：通过DFS遍历所有可能的完全子图，利用`check`函数确保新加入的船与已选船只完全连接，并通过回溯优化搜索过程。

#### 3. 作者：Gadfly (★★★★☆)
**关键亮点**：
- 通过DFS枚举每艘船，判断其是否与已选船只完全连接，逐步构建完全子图。
- 使用了`vis`数组和`b`数组来记录已选船只，确保搜索过程不重复。

**核心代码**：
```cpp
void dfs(int sum,int z) {
    ans=std::max(sum,ans);
    if(z>=n) return; 
    for(int i=1;i<=n;i++) if(!vis[i]) {
        int js=0;
        for(int j=1;j<=z;j++) if(!v[b[j]][i]) {js=1; break;}
        if(!js) {b[z+1]=i; vis[i]=1; dfs(sum+w[i],z+1); b[z+1]=0; vis[i]=0; }
    }
}
```
**核心思想**：通过DFS枚举每艘船，判断其是否与已选船只完全连接，逐步构建完全子图，并通过回溯优化搜索过程。

### 最优关键思路与技巧

1. **平面图性质**：利用平面图中完全子图最多只有4个点的性质，将问题复杂度从指数级降低到多项式级。
2. **DFS+回溯**：通过DFS枚举所有可能的完全子图，利用回溯避免重复计算，确保搜索效率。
3. **邻接矩阵**：通过邻接矩阵快速判断两艘船是否相连，优化了查询效率。

### 可拓展之处

- **完全子图问题**：类似的问题可以扩展到其他类型的图，如二分图、树等，寻找最大点权和的完全子图。
- **回溯优化**：在其他搜索问题中，回溯技巧可以用于避免重复计算，提高搜索效率。

### 推荐题目

1. **P1351 联合权值**：考察无向图中的最大点权和问题。
2. **P3388 割点**：考察无向图中的关键节点问题。
3. **P2661 信息传递**：考察有向图中的环问题。

### 个人心得总结

- **审题的重要性**：部分作者一开始没有注意到平面图的性质，导致思路复杂化，后来通过审题和查看其他提交的0ms运行时间，果断采用了暴力枚举的方法，成功AC。
- **回溯的优化作用**：通过回溯技巧，避免了重复计算，提高了搜索效率，这在其他搜索问题中同样适用。

---
处理用时：32.10秒
# 题目信息

# 摆石子

## 题目背景

我们伟大的KK突然想到了一个很高（Shā）明（bī）的问题。


## 题目描述

我们伟大的KK在N条水平线与M条竖直线构成的网格中（KK的自创坐标系），放K枚石子，每个石子都只能放在网格的交叉点上。现在KK想知道在最优的摆放方式下，最多可以找到多少四边平行于坐标轴的长方形，而且KK要求它的四个角上都恰好放着一枚石子。


## 说明/提示

50%的数据    0<N，M≤30；

100%的数据   0<N，M≤30000  K≤N\*M。


## 样例 #1

### 输入

```
3 3 8```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

该题的核心在于如何在给定的网格中摆放石子，使得形成的矩形数量最大化。题解中主要采用了数学推导和贪心策略，通过枚举可能的行数和列数，计算每种情况下的矩形数量，并取最大值。大部分题解都基于以下关键思路：

1. **数学推导**：通过组合数学公式计算矩形数量，推导出矩形数量的公式为 \(\frac{n(n+1) \times m(m+1)}{4}\)。
2. **贪心策略**：尽量将石子摆成一个接近矩形的形状，只有一行或一列不摆满时，矩形数量可能最大。
3. **枚举优化**：通过枚举行数或列数，计算每种情况下的矩形数量，避免暴力枚举带来的高时间复杂度。

### 所选高星题解

#### 1. 作者：彭天宇 (赞：12)
- **星级**：★★★★★
- **关键亮点**：
  - 详细推导了矩形数量的数学公式，并进行了化简。
  - 通过枚举不完全矩阵的长度，分别计算矩形数量，优化了时间复杂度。
  - 代码清晰，逻辑严谨，易于理解。
- **个人心得**：作者通过分析石子摆放的最优情况，得出了接近矩形的摆放方式，并通过数学公式进行了验证。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int main(){
	int maxn=0;
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		if(k/i>=m)continue;
		int len=k/i;
		int mod=k%i;
		maxn=max(maxn,(i*(i-1)/2*len*(len-1)/2+(len+1)*len/2*mod*(mod-1)/2-(len*(len-1)/2*mod*(mod-1)/2)));
	}
	for(int i=1;i<=m;i++){
		if(k/i>=n)continue;
		int len=k/i;
		int mod=k%i;
		maxn=max(maxn,(i*(i-1)/2*len*(len-1)/2+(len+1)*len/2*mod*(mod-1)/2-(len*(len-1)/2*mod*(mod-1)/2))); 
	}
	cout<<maxn<<endl;
	return 0;
}
```

#### 2. 作者：Alarm5854 (赞：4)
- **星级**：★★★★
- **关键亮点**：
  - 通过枚举行数，计算每种情况下的矩形数量，并取最大值。
  - 代码简洁，逻辑清晰，易于实现。
  - 强调了 \(n > m\) 时交换 \(n\) 和 \(m\) 的重要性，避免遗漏最优解。
- **个人心得**：作者通过枚举行数，简化了问题，并通过数学公式计算矩形数量，避免了复杂的枚举过程。

```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;
FILE *fin, *fout;
inline int read(ll &x) {
	char c = 0; int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
template<class T, class... Args> inline int read(T &x, Args&... args) {
	return read(x) + read(args...);
}
inline int write(ll x) {
	if (x < 0) return fputc(45, fout), write(-x);
	if (x > 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
ll n, m, k, ans;
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen("P2180.in", "rb");
	fout = fopen("P2180.out", "wb");
	#endif
	read(n, m, k); if (n > m) swap(n, m);//就是这个地方，非常坑！
	for (ll i = 1; i <= min(n, k); ++i) {
		ll x = k / i, y = k % i;
		if (!y && x > m) continue;
		if (y && x >= m) continue;
		ans = max(ans, i * x * (i - 1) * (x - 1) / 4 + x * y * (y - 1) / 2);
	}
	write(ans);
	return 0;
}
```

#### 3. 作者：bluewindde (赞：0)
- **星级**：★★★★
- **关键亮点**：
  - 通过组合计数推导出矩形数量的公式，并进行了详细解释。
  - 通过枚举行数，计算每种情况下的矩形数量，并取最大值。
  - 代码简洁，逻辑清晰，易于实现。
- **个人心得**：作者通过组合计数的方法，推导出矩形数量的公式，并通过枚举行数，简化了问题。

```cpp
#include <iostream>

#define int long long

using namespace std;

int n, m, k;

static inline int calc(int w, int h) {
    return w * h * (w - 1) * (h - 1) / 4;
}

signed main() {
#ifndef ONLINE_JUDGE
    freopen("D:/wangyile/P2180.in", "r", stdin);
#endif
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m >> k;
    if (n > m) {
        swap(n, m);
    }
    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        int x = k / i;
        int las = k % i;
        if (!las && x > m) {
            continue;
        }
        if (las && x >= m) {
            continue;
        }
        ans = max(ans, calc(i, x) + calc(las, x + 1) - calc(las, x));
    }
    cout << ans << endl;
    return 0;
}
```

### 最优关键思路与技巧

1. **数学推导**：通过组合数学公式计算矩形数量，推导出矩形数量的公式为 \(\frac{n(n+1) \times m(m+1)}{4}\)。
2. **贪心策略**：尽量将石子摆成一个接近矩形的形状，只有一行或一列不摆满时，矩形数量可能最大。
3. **枚举优化**：通过枚举行数或列数，计算每种情况下的矩形数量，避免暴力枚举带来的高时间复杂度。

### 可拓展之处

- **类似问题**：可以拓展到三维空间中的立方体数量计算，或者更复杂的几何形状。
- **算法套路**：类似的组合数学问题，如计算网格中的路径数量、矩形覆盖问题等。

### 推荐题目

1. [P2181 摆石子 II](https://www.luogu.com.cn/problem/P2181)
2. [P2182 摆石子 III](https://www.luogu.com.cn/problem/P2182)
3. [P2183 摆石子 IV](https://www.luogu.com.cn/problem/P2183)

### 个人心得总结

- **调试经历**：在枚举行数或列数时，需要注意边界条件，避免遗漏最优解。
- **踩坑教训**：在计算矩形数量时，需要注意公式的正确性，避免因公式错误导致计算结果不准确。
- **顿悟感想**：通过数学推导和贪心策略，可以大大简化问题，避免复杂的枚举过程。

---
处理用时：45.46秒
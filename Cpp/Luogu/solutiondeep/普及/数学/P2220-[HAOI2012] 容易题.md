# 题目信息

# [HAOI2012] 容易题

## 题目描述

有一个长度为 $m$ 的正整数数列 $A$，满足 $\forall i \in A, i \in [1, n]$。

现在给定一些限制（$A_x$ 不能为 $y$）。设数列 $A$ 的积为 $\prod A$，求所有可能数列的积相加起来的和。

换言之，令 $S$ 为所有可能的数列情况 $\{A, A', \ldots\}$，求

$$ \sum_{T \in S} \prod T $$

答案对 $10 ^ 9 + 7$ 取模。

## 说明/提示

### 样例解释 #1

$A_1$ 不能取 $1$，$A_2$ 不能取 $2, 3$，$A_4$ 不能取 $3$，所以可能的数列有以下 $12$ 种：

| 数列 | 积 |
| :-: | :-: |
| $\{2,   1,   1,   1\}$           | $2$ |
| $\{2,   1,   1,   2\}$           | $4$ |
| $\{2,   1,   2,   1\}$           | $4$ |
| $\{2,   1,   2,   2\}$           | $8$ |
| $\{2,   1,   3,   1\}$           | $6$ |
| $\{2,   1,   3,   2\}$           | $12$ |
| $\{3,   1,   1,   1\}$           | $3$ |
| $\{3,   1,   1,   2\}$           | $6$ |
| $\{3,   1,   2,   1\}$           | $6$ |
| $\{3,   1,   2,   2\}$           | $12$ |
| $\{3,   1,   3,   1\}$           | $9$ |
| $\{3,   1,   3,   2\}$           | $18$ |


### 数据范围

对于 $30\%$ 的数据，$n \leq 4$，$m \leq 10$，$k \leq 10$。

对于另外 $20\%$ 的数据，$k = 0$。

对于 $70\%$ 的数据，$n, m, k \leq 1000$。

对于 $100\%$ 的数据，$1\leq n, m \leq 10^9$，$0\leq k \leq 10^5$，$1 \leq x \leq m$，$1 \leq y \leq n$。

## 样例 #1

### 输入

```
3 4 5

1 1

1 1

2 2

2 3

4 3

```

### 输出

```
90```

# AI分析结果

### 综合分析与结论

该题目要求计算所有可能的数列的积之和，且数列中的某些位置有取值限制。大多数题解的核心思路是通过乘法分配律，将问题转化为每个位置的可能值之和的乘积。对于没有限制的位置，使用快速幂计算；对于有限制的位置，单独处理并减去限制的值。优化点在于通过离散化或去重处理限制条件，避免重复计算。

### 所选高质量题解

#### 1. **作者：Edwina (赞：15)**
- **星级**：★★★★★
- **关键亮点**：思路清晰，代码简洁，优化到位。通过排序和去重处理限制条件，使用快速幂优化无限制位置的计算。
- **个人心得**：作者提到“判重”和“防止多次减同一个限制条件”，强调了去重的重要性。
- **核心代码**：
  ```cpp
  sort(a+1,a+k+1,cmp);
  int cnt=0;
  for(int i=1;i<=k;i++){
      if(a[i].x!=a[i-1].x)
          sum[++cnt]=sgm;
      else if(a[i].y==a[i-1].y) continue;
      sum[cnt]=(sum[cnt]-a[i].y+mod)%mod;
  }
  ans+=poww(sgm,m-cnt,mod);
  for(int i=1;i<=cnt;i++)
      ans=(ans*sum[i]+mod)%mod;
  ```

#### 2. **作者：hzoi_liuchang (赞：12)**
- **星级**：★★★★☆
- **关键亮点**：详细解释了乘法分配律的应用，使用`map`去重，代码结构清晰。
- **核心代码**：
  ```cpp
  for(int i=1;i<=k;i++){
      if(!ma2[a[i].x]) num[++cnt]=a[i].x;
      if(ma1[make_pair(a[i].x,a[i].y)]) continue;
      ma1[make_pair(a[i].x,a[i].y)]=1;
      ma2[a[i].x]+=a[i].y;
  }
  ans=1;
  for(int i=1;i<=cnt;i++)
      ans=(ans*(cj-ma2[num[i]])%mod)%mod;
  ans=ans*cf(cj,m-cnt)%mod;
  ```

#### 3. **作者：DarthVictor (赞：5)**
- **星级**：★★★★☆
- **关键亮点**：通过`map`去重，快速幂优化无限制位置的计算，代码简洁。
- **核心代码**：
  ```cpp
  for(int i=1;i<=k;i++){
      if(!sum[a[i].x]) num[++cnt]=a[i].x;
      if(vis[make_pair(a[i].x,a[i].y)]) continue;
      vis[make_pair(a[i].x,a[i].y)]=1;
      sum[a[i].x]+=a[i].y;
  }
  ans=1;
  for(int i=1;i<=cnt;i++)
      ans=ans*(Max-sum[num[i]])%mod;
  ans=ans*power(Max,m-cnt)%mod;
  ```

### 最优关键思路与技巧
1. **乘法分配律**：将问题转化为每个位置的可能值之和的乘积。
2. **去重处理**：通过排序或`map`去重，避免重复计算。
3. **快速幂优化**：对无限制的位置使用快速幂计算，减少时间复杂度。
4. **离散化**：将限制条件离散化，减少空间复杂度。

### 可拓展之处
- **类似题目**：可以考虑类似的组合数学问题，如计算所有可能的排列或组合的某种属性之和。
- **算法套路**：乘法分配律、快速幂、离散化等技巧在组合数学和数论问题中广泛应用。

### 推荐题目
1. [P2221 [HAOI2012]高速公路](https://www.luogu.com.cn/problem/P2221)
2. [P2222 [HAOI2012]容易题](https://www.luogu.com.cn/problem/P2222)
3. [P2223 [HAOI2012]高速公路](https://www.luogu.com.cn/problem/P2223)

### 个人心得总结
- **去重的重要性**：多位作者提到去重的重要性，避免重复计算限制条件。
- **快速幂优化**：多位作者使用快速幂优化无限制位置的计算，显著提高效率。
- **减法取模**：有作者提到减法取模的注意事项，避免负数结果。

---
处理用时：30.99秒
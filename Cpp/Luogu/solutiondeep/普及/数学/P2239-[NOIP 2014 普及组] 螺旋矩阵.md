# 题目信息

# [NOIP 2014 普及组] 螺旋矩阵

## 题目背景

NOIP2014 普及组 T3

## 题目描述

一个 $n$ 行 $ n$ 列的螺旋矩阵可由如下方法生成：


从矩阵的左上角（第 $1$ 行第 $1$ 列）出发，初始时向右移动；如果前方是未曾经过的格子，则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中依次填入 $1, 2, 3, \dots, n^2$，便构成了一个螺旋矩阵。


下图是一个 $n = 4$ 时的螺旋矩阵。

$$\begin{pmatrix}
 1 &    2  &   3   &  4 \\
12 &   13  &  14   &  5 \\
11 &   16  &  15   &  6 \\
10 &    9  &   8   &  7 \\
\end{pmatrix}$$

现给出矩阵大小 $n$ 以及 $i$ 和 $j$，请你求出该矩阵中第 $i$ 行第 $j$ 列的数是多少。


## 说明/提示

【数据说明】

对于 $50\%$ 的数据，$1 \leqslant n \leqslant 100$;

对于 $100\%$ 的数据，$1 \leqslant n \leqslant 30,000,1 \leqslant i \leqslant n,1 \leqslant j \leqslant n$。


## 样例 #1

### 输入

```
4 2 3```

### 输出

```
14```

# AI分析结果

### 综合分析与结论

本题解的核心在于如何高效地计算螺旋矩阵中指定位置的值。题解主要分为暴力模拟、递归求解和数学公式推导三种思路。暴力模拟虽然直观，但时间和空间复杂度较高，不适用于大规模数据。递归求解通过逐层剥开矩阵，利用规律公式快速定位，时间复杂度为O(n)，较为高效。数学公式推导则进一步优化，通过直接计算目标位置所在的圈数和位置，时间复杂度为O(1)，是最优解。

### 所选高星题解

#### 1. 作者：Anguei (赞：413)  
**星级：5星**  
**关键亮点：**  
- 通过观察螺旋矩阵的规律，推导出数学公式，直接计算目标位置的值，避免了递归和模拟的高时间复杂度。
- 代码简洁，逻辑清晰，易于理解和实现。

**核心代码：**
```cpp
int work(int n, int i, int j) {
    if (i == 1) return j;
    if (j == n) return n + i - 1;
    if (i == n) return 3 * n - 2 - j + 1;
    if (j == 1) return 4 * n - 4 - i + 2;
    return work(n - 2, i - 1, j - 1) + 4 * (n - 1);
}
```
**实现思想：**  
通过递归逐层剥开矩阵，利用每一层的规律公式快速计算目标位置的值。

#### 2. 作者：CaiZi (赞：3)  
**星级：4星**  
**关键亮点：**  
- 通过数学推导，直接计算目标位置所在的圈数和位置，避免了递归和模拟的高时间复杂度。
- 代码简洁，逻辑清晰，易于理解和实现。

**核心代码：**
```cpp
int x = min({i-1, j-1, n-i, n-j});
if (i == x+1 || j == n-x) {
    cout << 4 * x * n - 4 * x * x - 2 * x + i + j - 1;
} else {
    cout << 4 * x * n - 4 * x * x - 6 * x + 4 * n - i - j - 1;
}
```
**实现思想：**  
通过数学公式直接计算目标位置的值，时间复杂度为O(1)。

#### 3. 作者：qhr2023 (赞：2)  
**星级：4星**  
**关键亮点：**  
- 通过模拟螺旋矩阵的生成过程，忽略外层矩阵，只模拟目标位置所在的层，时间复杂度为O(n)。
- 代码简洁，逻辑清晰，易于理解和实现。

**核心代码：**
```cpp
int k = min({x-1, n-x, y-1, n-y}) * 2, ans = n * n - (n - k) * (n - k);
for (int i = 1, j = 1, t = 0, ti, tj; x - k / 2 != i || y - k / 2 != j; ) {
    ti = i + dx[t], tj = j + dy[t];
    (ti > n - k || tj > n - k || ti < 1 || tj < 1) ? ++t : (++ans, i = ti, j = tj);
}
cout << ans + 1;
```
**实现思想：**  
通过模拟螺旋矩阵的生成过程，忽略外层矩阵，只模拟目标位置所在的层，时间复杂度为O(n)。

### 最优关键思路与技巧

1. **数学公式推导**：通过观察螺旋矩阵的规律，推导出数学公式，直接计算目标位置的值，避免了递归和模拟的高时间复杂度。
2. **递归求解**：通过逐层剥开矩阵，利用每一层的规律公式快速计算目标位置的值，时间复杂度为O(n)。
3. **模拟优化**：通过模拟螺旋矩阵的生成过程，忽略外层矩阵，只模拟目标位置所在的层，时间复杂度为O(n)。

### 可拓展之处

- **类似问题**：类似的问题包括蛇形矩阵、Z字形矩阵等，可以通过类似的规律推导和递归求解方法解决。
- **算法套路**：对于矩阵类问题，可以通过观察规律、数学推导和递归求解等方法进行优化。

### 推荐题目

1. **P2239 [NOIP2014 普及组] 螺旋矩阵**  
2. **P1219 [USACO1.5]八皇后 Checker Challenge**  
3. **P1090 [NOIP2004 提高组] 合并果子**  
4. **P1048 [NOIP2005 普及组] 采药**

---
处理用时：25.82秒
# 题目信息

# 质量检测

## 题目描述

为了检测生产流水线上总共 $N$ 件产品的质量，我们首先给每一件产品打一个分数 $A$ 表示其品质，然后统计前 $M$ 件产品中质量最差的产品的分值 $Q[m] = min\{A_1, A_2, ... A_m\}$，以及第 2 至第 $M + 1$ 件的 $Q[m + 1], Q[m + 2] $... 最后统计第 $N - M + 1$ 至第 $N$ 件的 $Q[n]$。根据 $Q$ 再做进一步评估。

请你尽快求出 $Q$ 序列。


## 说明/提示

[数据范围]

30%的数据，$N \le 1000$

100%的数据，$N \le 100000$

100%的数据，$M \le N, A \le 1 000 000$


## 样例 #1

### 输入

```
10 4
16 5 6 9 5 13 14 20 8 12
```

### 输出

```
5
5
5
5
5
8
8
```

# AI分析结果

### 综合分析与结论

本题的核心是求解滑动窗口的最小值，常见的解法包括单调队列、ST表、线段树等。通过对多条题解的分析，可以得出以下结论：

1. **单调队列**是最优的解法，时间复杂度为O(N)，适合处理滑动窗口问题。它通过维护一个单调递增的队列，能够在O(1)时间内获取当前窗口的最小值。
2. **ST表**也是一种高效的解法，时间复杂度为O(NlogN)，适合处理静态区间最值查询问题。虽然预处理时间稍长，但查询速度极快。
3. **线段树**虽然也能解决该问题，但代码量较大，且时间复杂度为O(NlogN)，不如单调队列简洁高效。

### 所选高星题解

#### 1. **My_666 - 单调队列（5星）**
- **关键亮点**：思路清晰，代码简洁，详细解释了单调队列的实现过程，适合初学者理解。
- **个人心得**：作者通过模拟样例，详细说明了单调队列的维护过程，帮助读者理解其工作原理。
- **核心代码**：
  ```cpp
  int min_deque() {
      int h = 1, t = 0;
      for (int i = 1; i <= n; i++) {
          while (h <= t && q1[h] + m <= i) h++; // 弹出不在窗口内的元素
          while (h <= t && a[i] < a[q1[t]]) t--; // 维护单调性
          q1[++t] = i; // 新元素入队
          if(i >= m) printf("%d\n", a[q1[h]]); // 输出当前窗口的最小值
      }
  }
  ```

#### 2. **Youngsc - 单调队列（4星）**
- **关键亮点**：代码简洁，使用数组模拟队列，避免了STL容器的性能开销，适合竞赛场景。
- **核心代码**：
  ```cpp
  inline int yg(){
      in(n),in(m);
      for(R int i=1; i<m; ++i) {
          in(d);
          while(head <= tail&&q[tail] >= d) tail--;
          q[++tail] = d,p[tail] = i;
      }
      for(R int i=m; i<=n; ++i) {
          in(d);
          while(p[head]<i-m+1) head++;
          while(head <= tail&&q[tail] >= d) tail--;
          q[++tail] = d,p[tail] = i;
          printf("%d\n",q[head]);
      }
  }
  ```

#### 3. **Ofnoname - 单调队列（4星）**
- **关键亮点**：使用STL的`deque`实现单调队列，代码简洁易懂，适合初学者快速上手。
- **核心代码**：
  ```cpp
  int main() {
      read(N); read(M);
      Fors (i, 1, N) {
          read(a[i]);
          while (Q.size() && i-Q.front()>=M) Q.pop_front();
          while (Q.size() && a[Q.back()]>=a[i]) Q.pop_back();
          Q.push_back(i);
          if (i >= M) printf("%d\n", a[Q.front()]);
      }
  }
  ```

### 最优关键思路与技巧

1. **单调队列**：通过维护一个单调递增的队列，能够在O(1)时间内获取当前窗口的最小值。核心思想是每次新元素入队时，弹出队尾比它大的元素，确保队列的单调性。
2. **ST表**：通过预处理，构建一个二维数组`f[i][j]`，表示从`i`开始长度为`2^j`的区间的最小值。查询时通过两个重叠的区间快速得到结果。

### 拓展思路与同类型题

1. **滑动窗口最大值**：与本题类似，可以使用单调队列求解。
2. **区间最值查询**：可以使用ST表或线段树解决。
3. **动态区间最值**：如果区间需要动态更新，可以使用线段树或树状数组。

### 推荐题目

1. **P1886 滑动窗口**：与本题几乎相同，适合练习单调队列。
2. **P3865 ST表模板题**：适合练习ST表的实现与应用。
3. **P1816 忠诚**：区间最值查询，可以使用ST表或线段树解决。

### 个人心得总结

- **调试经历**：多位作者提到使用STL的`deque`会导致性能问题，建议使用数组模拟队列。
- **踩坑教训**：ST表的预处理时间复杂度较高，需注意数据范围，避免超时。
- **顿悟感想**：单调队列在处理滑动窗口问题时非常高效，代码简洁且易于理解。

---
处理用时：29.20秒
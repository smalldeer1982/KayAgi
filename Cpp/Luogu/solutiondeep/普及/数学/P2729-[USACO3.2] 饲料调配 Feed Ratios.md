# 题目信息

# [USACO3.2] 饲料调配 Feed Ratios

## 题目背景

农夫约翰从来只用调配得最好的饲料来喂他的奶牛。饲料用三种原料调配成：大麦，燕麦和小麦。他知道自己的饲料精确的配比，在市场上是买不到这样的饲料的。他只好购买其他三种混合饲料（同样都由三种麦子组成），然后将它们混合，来调配他的完美饲料。


## 题目描述

给出三组整数，表示 大麦：燕麦：小麦 的比例，找出用这三种饲料调配 x：y：z 的饲料的方法。

例如，给出目标饲料 3：4：5 和三种饲料的比例：

1:2:3
3:7:1
2:1:2
你必须编程找出使这三种饲料用量最少的方案，要是不能用这三种饲料调配目标饲料，输出“NONE”。“用量最少”意味着三种饲料的用量（整数）的和必须最小。


对于上面的例子，你可以用8份饲料1，1份饲料2，和5份饲料3，来得到7份目标饲料：

8\*(1:2:3) + 1\*(3:7:1) + 5\*(2:1:2) = (21:28:35) = 7\*(3:4:5)

表示饲料比例的整数以及目标饲料的都是小于100的非负整数。表示各种饲料的份数的整数，都小于100。一种混合物的比例不会由其他混合物的比例直接相加得到。


## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 3.2


## 样例 #1

### 输入

```
3 4 5
1 2 3
3 7 1
2 1 2 ```

### 输出

```
8 1 5 7```

# AI分析结果

### 综合分析与结论

本题的核心是通过给定的三种饲料比例，找到一种混合方式，使得混合后的饲料比例与目标比例一致，并且使用的饲料总量最小。题解中主要采用了以下几种思路：

1. **枚举法**：通过枚举每种饲料的份数，计算混合后的比例，判断是否与目标比例一致。这种方法简单直接，但时间复杂度较高，尤其是当饲料份数上限较大时。
2. **高斯消元法**：将问题转化为线性方程组，通过高斯消元法求解。这种方法在理论上更为严谨，但实现复杂，且可能存在精度问题。
3. **数论方法**：利用柯西不等式或行列式等数学工具，避免对0的特殊处理，简化问题。这种方法需要对数学有较深的理解，但一旦掌握，代码实现较为简洁。
4. **DFS剪枝**：通过深度优先搜索结合剪枝策略，减少不必要的枚举，提高效率。这种方法在搜索空间较大时表现较好，但需要合理的剪枝策略。

### 所选高星题解

#### 1. 作者：Flokirie (5星)
- **关键亮点**：利用柯西不等式，避免了繁琐的0值判断，简化了问题。通过数学工具，将问题转化为比例判断，代码简洁且高效。
- **个人心得**：通过数学工具简化问题，避免了复杂的条件判断，体现了数竞生的思维方式。

```cpp
#define squ(x) ((x)*(x))
if ((squ(a)+squ(b)+squ(c))*(squ(x)+squ(y)+squ(z))==squ(a*x+b*y+c*z)){
    //do something...
}
```

#### 2. 作者：Youngsc (4星)
- **关键亮点**：通过枚举饲料总量，再枚举前两种饲料的份数，避免了直接枚举三种饲料的高复杂度。利用比例相等的条件，避免了0值的特殊处理。
- **个人心得**：通过合理的枚举顺序和比例判断，简化了问题，代码实现较为清晰。

```cpp
for(R int tot=1; tot<=300; ++tot)
    for(R int i=0; i<=tot; ++i)
        for(R int j=0; j<=tot-i; ++j)
        {
            R int k = tot-i-j;
            for(R int d = 1; d<=3; ++d)
                no[d] = i*a[1][d]+j*a[2][d]+k*a[3][d];
            if(no[1]>=to[1]&&no[2]>=to[2]&&no[3]>=to[3]&&
               no[1]*to[2]==to[1]*no[2]&&no[3]*to[2]==to[3]*no[2])
                printf("%d %d %d %d",i,j,k,no[1]/to[1]),exit(0);
        }
```

#### 3. 作者：QianhanOfficial (4星)
- **关键亮点**：通过DFS结合剪枝策略，减少了不必要的枚举，提高了搜索效率。通过部分剪枝，避免了重复搜索，代码实现较为高效。
- **个人心得**：通过合理的剪枝策略，减少了搜索空间，体现了对DFS的深入理解。

```cpp
void dfs(re int a, re int b, re int c, re int last)
{
    if(!a && !b && !c)
    {
        printf("%d %d %d %d", c1, c2, c3, num);
        exit(0);
    }
    for(re int i = last; i <= 3; ++i)
    {
        if(a - x[i] >= 0 && b - y[i] >= 0 && c - z[i] >= 0)
        {
            if(i == 1) ++c1, dfs(a - x[i], b - y[i], c - z[i], 1), --c1;
            if(i == 2) ++c2, dfs(a - x[i], b - y[i], c - z[i], 2), --c2;
            if(i == 3) ++c3, dfs(a - x[i], b - y[i], c - z[i], 3), --c3;
        }
    }
}
```

### 最优关键思路与技巧

1. **数学工具的应用**：如柯西不等式、行列式等，可以简化问题，避免繁琐的条件判断。
2. **合理的枚举顺序**：通过枚举总量再枚举部分变量，减少枚举次数，提高效率。
3. **DFS剪枝**：通过合理的剪枝策略，减少搜索空间，提高搜索效率。

### 可拓展之处

- **类似问题**：如混合液体比例、化学反应配平等，都可以通过类似的数学工具或枚举方法解决。
- **算法套路**：枚举法、DFS剪枝、高斯消元法等，都是解决组合优化问题的常用方法。

### 推荐题目

1. **P1008 三连击**：考察枚举和比例判断。
2. **P1029 最大公约数和最小公倍数问题**：考察数论和比例关系。
3. **P1036 选数**：考察DFS剪枝和组合优化。

### 个人心得总结

- **数学工具简化问题**：通过数学工具如柯西不等式，可以避免繁琐的条件判断，简化代码实现。
- **合理剪枝提高效率**：在DFS中，通过合理的剪枝策略，可以显著减少搜索空间，提高算法效率。
- **枚举顺序优化**：通过合理的枚举顺序，可以减少枚举次数，提高算法效率。

---
处理用时：33.54秒
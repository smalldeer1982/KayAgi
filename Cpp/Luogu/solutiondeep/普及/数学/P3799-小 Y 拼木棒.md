# 题目信息

# 小 Y 拼木棒

## 题目背景

上道题中，小 Y 斩了一地的木棒，现在她想要将木棒拼起来。

## 题目描述

有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？

答案对 $10^9+7$ 取模。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 5 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，$1 \le a_i \le 5 \times 10^3$。

关于标题：因为一些不可抗力的原因，名称进行了更改。深表歉意。

## 样例 #1

### 输入

```
4 
1
1
2
2```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心在于通过组合数学和暴力枚举的方式，从给定的木棒中选出4根组成正三角形。所有题解都采用了桶计数的方法来统计每种长度木棒的数量，并通过枚举可能的长度组合来计算方案数。主要难点在于如何高效地枚举并计算组合数，同时避免重复计算。

### 所选高星题解

#### 1. 灵乌路空（5星）
**关键亮点**：
- 详细分析了组合数学的原理，清晰解释了如何通过枚举长度来计算方案数。
- 代码结构清晰，组合数计算部分单独封装，提高了代码的可读性和复用性。
- 通过内层循环的优化（枚举到i/2），避免了重复计算，提升了效率。

**核心代码**：
```cpp
ll C(ll x, ll k) { 
  return (k == 1ll ? x : x * (x - 1ll) / 2ll) % kMod;
}

for (int i = 2; i <= maxa; ++ i) { 
  if (num[i] >= 2ll) {
    ll times = C(num[i], 2ll) % kMod; 
    for (int j = 1; j <= i / 2; ++ j) { 
      if (j != i - j && num[j] >= 1 && num[i - j] >= 1) 
        ans += times * C(num[j], 1) * C(num[i - j], 1) % kMod;
      if (j == i - j && num[j] >= 2) 
        ans += times * C(num[j], 2) % kMod;
      ans %= kMod;
    }
  }
}
```

#### 2. dbxxx（4星）
**关键亮点**：
- 通过预处理数组`p`来记录两根木棒长度和为`i`的方案数，简化了后续计算。
- 代码简洁，逻辑清晰，通过组合数公式直接计算结果。

**核心代码**：
```cpp
REP(i,1,2500) {
  p[i*2]+=1ll*(sum[i]*(sum[i]-1)/2);
  p[i*2]%=mod;
  REP(j,i+1,5000-i) {
    p[i+j]+=1ll*sum[i]*sum[j];
    p[i+j]%=mod;
  }
}
long long answer=0;
REP(i,1,5000) {
  answer+=(1ll*sum[i]*(sum[i]-1)/2)%mod*p[i]%mod;
  answer%=mod;
}
```

#### 3. RemiliaScar1et（4星）
**关键亮点**：
- 通过定义宏简化组合数计算，代码简洁高效。
- 详细解释了枚举时的优化策略，避免重复计算。

**核心代码**：
```cpp
#define C1(x) (x)
#define C2(x) ((x)*((x)-1)/2)

for (int a = 2; a <= 5000; a++){
  for (int c = 1; c <= a/2; c++){ 
    int d = a - c; 
    if (d != c){ 
      if (arr[a] >= 2 && arr[c] >= 1 && arr[d] >= 1)
        sum += ((C2(arr[a]) % MOD)*(C1(arr[c]) % MOD)) % MOD*(C1(arr[d]) % MOD) % MOD;
    }
    else{
      if (arr[a] >= 2 && arr[c] >= 2)
        sum += (C2(arr[a]) % MOD)*(C2(arr[c]) % MOD) % MOD;
    }
    sum %= MOD;
  }
}
```

### 最优关键思路与技巧

1. **桶计数**：通过桶数组统计每种长度木棒的数量，便于后续快速查询和计算。
2. **组合数计算**：通过组合数公式`C(n, k)`快速计算从n个元素中选取k个的方案数。
3. **枚举优化**：在内层循环中，枚举到`i/2`以避免重复计算，提升效率。

### 可拓展之处

- **类似问题**：可以扩展到其他形状的拼合问题，如矩形、正方形等，同样可以通过组合数学和枚举的方式解决。
- **算法优化**：可以进一步优化枚举的顺序和范围，减少不必要的计算。

### 推荐题目

1. **P3799 妖梦拼木棒**：与本题几乎相同，考察组合数学和枚举。
2. **P3817 小A的糖果**：考察组合数学和贪心算法。
3. **P3811 【模板】乘法逆元**：考察组合数学中的逆元计算，常用于大数取模问题。

### 个人心得摘录

- **灵乌路空**：通过优化内层循环的枚举范围，避免了重复计算，提升了代码效率。
- **RemiliaScar1et**：通过定义宏简化组合数计算，代码更加简洁高效，减少了冗余代码。

---
处理用时：30.13秒
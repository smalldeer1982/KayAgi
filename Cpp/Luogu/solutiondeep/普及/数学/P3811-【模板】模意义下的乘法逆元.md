# 题目信息

# 【模板】模意义下的乘法逆元

## 题目背景

这是一道模板题


## 题目描述

给定 $n,p$ 求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。

这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\equiv1\pmod p$ 的解。

## 说明/提示

$ 1 \leq n \leq 3 \times 10 ^ 6$，$n < p < 20000528 $。

输入保证 $ p $ 为质数。


## 样例 #1

### 输入

```
10 13```

### 输出

```
1
7
9
10
8
11
2
5
3
4```

# AI分析结果

### 综合分析与结论

本题要求求解1到n的所有整数在模p意义下的乘法逆元，且p为质数。题解中主要涉及以下几种方法：

1. **扩展欧几里得算法（exgcd）**：适用于单个数的逆元求解，时间复杂度为O(log p)，但在本题中由于n较大，直接使用会超时。
2. **费马小定理+快速幂**：适用于p为质数的情况，时间复杂度为O(n log p)，同样在本题中会超时。
3. **线性递推法**：通过递推公式在O(n)时间内求解所有逆元，是本题的最优解法。
4. **阶乘逆元法**：通过预处理阶乘和阶乘的逆元，再递推求解每个数的逆元，时间复杂度为O(n)，但实现较为复杂。

综合来看，**线性递推法**是最优的解法，代码简洁且时间复杂度低，适合本题的大规模数据。

### 所选高星题解

#### 题解1：线性递推法（5星）
- **作者**：zjp_shadow
- **关键亮点**：递推公式简洁，时间复杂度为O(n)，代码实现清晰。
- **代码核心思想**：通过递推公式 `inv[i] = (p - p / i) * inv[p % i] % p` 求解每个数的逆元。

```cpp
inv[1] = 1;
for(int i = 2; i < p; ++i)
    inv[i] = (p - p / i) * inv[p % i] % p;
```

#### 题解2：阶乘逆元法（4星）
- **作者**：redegg
- **关键亮点**：通过预处理阶乘和阶乘的逆元，再递推求解每个数的逆元，时间复杂度为O(n)。
- **代码核心思想**：先预处理阶乘，再通过费马小定理求阶乘的逆元，最后递推求解每个数的逆元。

```cpp
c[0] = 1;
for(int i = 1; i <= n; i++) c[i] = (c[i-1] * i) % p;
ll last = fast_pow(c[n], p-2);
for(int i = n; i >= 1; i--) {
    inv[i] = (last * c[i-1]) % p;
    last = (last * i) % p;
}
```

#### 题解3：线性递推法（4星）
- **作者**：zcysky
- **关键亮点**：递推公式清晰，代码简洁，时间复杂度为O(n)。
- **代码核心思想**：通过递推公式 `inv[i] = (p - p / i) * inv[p % i] % p` 求解每个数的逆元。

```cpp
inv[1] = 1;
for(int i = 2; i <= n; i++)
    inv[i] = (ll)(p - p / i) * inv[p % i] % p;
```

### 最优关键思路与技巧

1. **线性递推公式**：`inv[i] = (p - p / i) * inv[p % i] % p` 是本题的最优解法，时间复杂度为O(n)，适合大规模数据。
2. **预处理阶乘与逆元**：通过预处理阶乘和阶乘的逆元，再递推求解每个数的逆元，时间复杂度为O(n)，但实现较为复杂。

### 可拓展之处

1. **同类型题**：可以扩展到求解模数不为质数的情况，此时需要使用扩展欧几里得算法。
2. **类似算法套路**：线性递推法可以应用于其他需要快速求解逆元的问题，如组合数计算、多项式求逆等。

### 推荐题目

1. **P1082 同余方程**：考察扩展欧几里得算法的应用。
2. **P3807 卢卡斯定理**：考察组合数取模与逆元的应用。
3. **P4720 扩展卢卡斯**：考察扩展卢卡斯定理与逆元的应用。

### 个人心得摘录

- **调试经历**：部分题解中提到，使用cout输出会超时，改用printf后通过，说明输出方式对性能有显著影响。
- **踩坑教训**：线性递推法在实现时需要注意递推公式的正确性，避免出现负数或溢出问题。
- **顿悟感想**：通过递推公式求解逆元，不仅代码简洁，而且时间复杂度低，是解决大规模逆元问题的有效方法。

---
处理用时：31.93秒
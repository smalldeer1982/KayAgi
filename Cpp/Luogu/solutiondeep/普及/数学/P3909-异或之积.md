# 题目信息

# 异或之积

## 题目描述

对于$A_1,A_2,A_3,\cdots,A_N$，求

$$(6\times \sum_{i=1}^N\sum_{j=i+1}^N\sum_{k=j+1}^N A_i\times A_j\times A_k) \bmod (10^9+7)$$


## 说明/提示

- 对于 $30\%$ 的数据，$N \le 500$；
- 对于 $60\%$ 的数据，$N \le 5000$；
- 对于 $100\%$ 的数据，$3 \le N \le 10^6$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
36```

# AI分析结果

### 综合分析与结论

本题要求计算三元组乘积的和，并乘以6后取模。直接暴力枚举的时间复杂度为O(n³)，无法通过全部测试用例。因此，需要优化算法，常见的优化思路包括前缀和、后缀和、动态维护累加和等。以下是对各题解的总结与对比：

1. **hhoppitree**的题解通过动态维护三个累加和（sum1、sum2、sum3），实现了O(n)的时间复杂度，且空间复杂度为O(1)。代码简洁，思路清晰，是最优解之一。
2. **sky_chen**的题解通过数学推导，将问题转化为求和的三次方减去重复计算的部分，虽然思路正确，但实现较为复杂，且容易出错。
3. **B_1168**的题解通过前缀和和后缀和的结合，逐步优化算法，最终实现了O(n)的时间复杂度，思路清晰，代码可读性较好。
4. **Limerick**的题解通过引入三个前缀和数组（sum1、sum2、sum3），逐步推导出公式，最终实现了O(n)的时间复杂度，思路清晰，代码简洁。

### 所选高星题解

#### 1. hhoppitree（5星）
- **关键亮点**：通过动态维护三个累加和（sum1、sum2、sum3），实现了O(n)的时间复杂度，且空间复杂度为O(1)。代码简洁，思路清晰。
- **核心代码**：
```cpp
int n=read(),sum1=0,sum2=0,sum3=0;
for(register int i=1;i<=n;++i){
    int t=read();
    sum3=(sum3+sum2*t)%mod;
    sum2=(sum2+sum1*t)%mod;
    sum1=(sum1+t)%mod;
}
printf("%d\n",sum3*6%mod);
```
- **实现思想**：通过一次遍历，动态维护三个累加和，分别表示当前元素、两两乘积和三元组乘积的累加和，最终输出结果。

#### 2. B_1168（4星）
- **关键亮点**：通过前缀和和后缀和的结合，逐步优化算法，最终实现了O(n)的时间复杂度，思路清晰，代码可读性较好。
- **核心代码**：
```cpp
for(int i=n;i>=1;i--){
    sum[i]=a[i]+sum[i+1];
    sum[i]%=1000000007;
}
for(int i=n;i>=1;i--){
    pr[i]+=pr[i+1]+(a[i]*sum[i+1]);
    pr[i]%=1000000007;
}
for(int i=1;i<=n;i++) ans+=(a[i]*pr[i+1]),ans%=1000000007;
printf("%lld\n",6*ans%1000000007);
```
- **实现思想**：通过后缀和数组sum和累加和数组pr，逐步计算三元组乘积的和，最终输出结果。

#### 3. Limerick（4星）
- **关键亮点**：通过引入三个前缀和数组（sum1、sum2、sum3），逐步推导出公式，最终实现了O(n)的时间复杂度，思路清晰，代码简洁。
- **核心代码**：
```cpp
for(i=1;i<=n;i++){
    sum1[i]=(sum1[i-1]+x)%mod;
    sum2[i]=(sum2[i-1]+sum1[i-1]*x)%mod;
    sum3[i]=(sum3[i-1]+sum2[i-1]*x)%mod;
}
printf("%lld",(6*sum3[n])%mod);
```
- **实现思想**：通过一次遍历，动态维护三个前缀和数组，分别表示当前元素、两两乘积和三元组乘积的累加和，最终输出结果。

### 最优关键思路与技巧

1. **动态维护累加和**：通过一次遍历，动态维护多个累加和，避免重复计算，是优化时间复杂度的关键。
2. **前缀和与后缀和**：通过前缀和和后缀和的结合，逐步推导出公式，减少计算量。
3. **数学推导**：通过数学公式的推导，将问题转化为更易计算的形式，减少时间复杂度。

### 可拓展之处

1. **类似问题**：类似的问题可以扩展到四元组、五元组等，通过动态维护更多的累加和，逐步推导出公式。
2. **其他优化技巧**：在计算过程中，可以结合其他优化技巧，如快速幂、矩阵快速幂等，进一步优化算法。

### 推荐题目

1. **P3909 异或之积**：本题的变种，考察类似的三元组乘积和的计算。
2. **P3911 异或之和**：考察二元组异或和的计算，类似的前缀和优化思路。
3. **P3912 异或之积2**：考察四元组乘积和的计算，进一步拓展动态维护累加和的思路。

### 个人心得摘录

- **hhoppitree**：通过动态维护累加和，避免了复杂的数学推导，代码简洁且高效。
- **B_1168**：通过前缀和和后缀和的结合，逐步优化算法，思路清晰，代码可读性较好。
- **Limerick**：通过引入多个前缀和数组，逐步推导出公式，最终实现了O(n)的时间复杂度，思路清晰，代码简洁。

---
处理用时：29.10秒
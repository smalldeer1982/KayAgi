# 题目信息

# 纪念邮票

## 题目描述

邮局最近推出了一套纪念邮票，这套邮票共有 $N$ 张，邮票面值各不相同，按编号顺序为 $1$ 分，$2$ 分，……，$N$ 分。

小明是个集邮爱好者，他很喜欢这套邮票，可惜现在他身上只有 $M$ 分，并不够把全套都买下，但是他希望刚好花光所有的钱。作为一个集邮爱好者，小明也不想买的邮票编号断断续续，所以小明打算买面值 $a$ 分至 $b$ 分的 $b-a+1$ 张连续的邮票，且总价值刚好为 $M$ 分。

你的任务是求出所有符合要求的方案，以 $\left[a,b\right]$ 的形式输出。

## 样例 #1

### 输入

```
20 15```

### 输出

```
[1,5]
[4,6]
[7,8]
[15,15]```

# AI分析结果

### 综合分析与结论

本题的核心在于找到满足条件的连续区间，使得区间内的数字和等于给定的值 \( M \)。由于 \( N \) 和 \( M \) 的范围较大（\( 10^9 \)），直接暴力枚举会超时，因此需要借助数学公式和优化策略来减少计算量。

大多数题解都基于等差数列求和公式，通过枚举区间长度 \( len \) 来求解首项 \( a \)，并验证其合法性。优化点在于将枚举范围限制在 \( \sqrt{2M} \) 以内，从而将时间复杂度从 \( O(N) \) 降低到 \( O(\sqrt{M}) \)。

### 所选题解

#### 1. 作者：佑月之星 (5星)
- **关键亮点**：通过数学推导将问题转化为枚举区间长度 \( len \)，并利用等差数列求和公式求解首项 \( a \)。优化了枚举范围，避免了超时问题。
- **个人心得**：作者在调试过程中经历了从三重循环到双重循环再到最终优化的过程，最终通过数学推导找到了高效的解决方案。

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n;
int main()
{
	cin>>n>>m;
	for(int i=sqrt(2*m);i>=1;i--)
	{
		if((2*m)%i!=0)continue;
		if(((2*m/i)-i+1)%2!=0)continue;
		int a=((2*m/i)-i+1)/2;
		if(a<1)continue;
		if(a+i-1>n)continue;
		cout<<"["<<a<<","<<a+i-1<<"]"<<endl;
	}	
	return 0;	
}
```

#### 2. 作者：SqrtSecond (4星)
- **关键亮点**：同样基于等差数列求和公式，通过枚举区间长度 \( t \) 来求解首项和末项。代码简洁，逻辑清晰。
- **个人心得**：作者强调了 \( t \) 的枚举顺序（从大到小），确保输出结果按从小到大的顺序排列。

```cpp
#include<bits/stdc++.h>
int n,m,sum;
int main()
{
	scanf("%d%d",&n,&m);
	m*=2;
	for(int i=sqrt(m);i;--i)
	{
		if(m%i)continue;
		sum=m/i;
		if((sum-i+1)&1||(sum+i-1)/2>n)continue;
		printf("[%d,%d]\n",(sum-i+1)/2,(sum+i-1)/2);
	}
	return 0;
}
```

#### 3. 作者：Yujinhe469 (4星)
- **关键亮点**：通过枚举区间长度 \( y \) 来求解首项 \( a \) 和末项 \( b \)，并验证其合法性。代码简洁，逻辑清晰。
- **个人心得**：作者强调了枚举范围的重要性，避免超时。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m;
int main(){
	cin>>n>>m;
	m*=2;
	for(ll y=sqrt(m);y>=1;y--){
		if(m%y!=0) continue;
		ll x=m/y;
		if((x-y+1)%2==1) continue;
		ll a=(x-y+1)/2,b=(x+y-1)/2;
		if(a<1||a>n||b<1||b>n) continue;
		cout<<"["<<a<<","<<b<<"]"<<endl;
	}
	return 0;
}
```

### 最优关键思路与技巧

1. **数学公式推导**：利用等差数列求和公式 \( S = \frac{(a + b) \times len}{2} \)，将问题转化为枚举区间长度 \( len \) 并求解首项 \( a \)。
2. **优化枚举范围**：将枚举范围限制在 \( \sqrt{2M} \) 以内，避免超时。
3. **合法性验证**：在求解首项 \( a \) 和末项 \( b \) 后，验证其是否在合法范围内。

### 可拓展之处

- **类似问题**：可以扩展到其他类型的数列求和问题，如等差数列、等比数列等。
- **算法套路**：类似的数学推导和优化策略可以应用于其他需要枚举区间或子序列的问题。

### 推荐题目

1. [P3910 纪念邮票](https://www.luogu.com.cn/problem/P3910)
2. [P1217 回文质数](https://www.luogu.com.cn/problem/P1217)
3. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)

### 个人心得总结

- **调试经历**：从暴力枚举到逐步优化，最终通过数学推导找到高效解决方案。
- **踩坑教训**：初始的暴力解法在数据范围较大时会超时，必须进行优化。
- **顿悟感想**：数学公式的推导和优化策略是解决此类问题的关键。

---
处理用时：26.77秒
# 题目信息

# [yLOI2019] 青原樱

## 题目背景

> 星川之下皆萤火尘埃，  
> 我独行在人潮你天真而待。  
> 相遇若是借丹青着色，  
> 青原上 绯樱如海。

——银临《青原樱》(Cover 人衣大人)

## 题目描述

扶苏是一个非常喜欢边听古风鸽边写数学题的人，因此这道题其实是个五三原题。

扶苏希望重现青原上樱花盛开的景色，于是他准备了很多**互不相同**樱花树幼苗，准备种成一行。

这一行中，一共有 $n$ 个位置可以种下樱花，而扶苏准备了 $m$ 支幼苗。由于樱花盛放时对左右空间需求非常大，所以樱花不能紧挨着种植，也就是任意两支幼苗之间必须至少存在一个不种花的空位置。

按照这种方式种花并不难，但是令扶苏感到好奇的是一共有多少合法的方案让他把这 $m$ 支幼苗都种下去。一个方案是合法的当且仅当他满足上一段中叙述的要求。如果我们将花按照 $1,2,3,\dots,m$ 编号，两种方案不同当且仅当被选择种花的位置不同或从左向右数花的编号序列不同。

为了避免输出过大，答案对一个参数 $p$ 取模。

## 说明/提示

#### 样例输入输出 1 解释
一共有 $2$ 个樱花幼苗， $3$ 个种花的位置，如果给幼苗编号为 $1,~2$，位置编号为 $1,~2,~3$，那么两种方案分别如下：

| 位置 | $1$ | $2$ | $3$ |
| :---: | :---: | :---: | :---: |
| 方案 1 | 幼苗 $1$ | 空 | 幼苗 $2$ |
| 方案 2 | 幼苗 $2$ | 空 | 幼苗 $1$ |

---

#### 数据规模与约定

**本题采用多测试点捆绑测试，共有 6 个子任务**。

| 子任务编号 | $n \leq$ | $m \leq$ | $type=$ | 特殊性质 | 子任务分值 |
| :----------: | :--------: | :----------: | :-------: | :--------: | :-----------: |
| 1 | $1$ | $1$ | $0$ | 特殊性质 1 | $5$ |
| 2 | $20$ | $20$ | $1$ | 特殊性质 1 | $15$ |
| 3 | $400$ | $200$ | $2$ | 无 | $20$ |
| 4 | $2000$ | $2000$ | $3$ | 无 | $20$ |
| 5 | $2000000$ | $1000000$ | $4$| 特殊性质 2 | $20$ | 
| 6 | $2000000$ | $1000000$ | $5$| 无 | $20$ | 

特殊性质 1：保证对应测试点的**实际**方案数(在取模前)不超过 $10^6$

特殊性质 2：保证 $p$ 是一个质数。

对于 $100\%$ 的数据，保证：
- $1 \leq n \leq 2 \times 10^6$。
- $1 \leq m \leq 10^6 $。
- $1 \leq p \leq 10^9$。
- $1 \leq m \leq \lceil\frac{n}{2} \rceil$。

---

#### 提示

- 请使用合适的数据类型来进行运算，避免溢出。
- 参数 $type$ 可以帮助你快速的判断子任务编号。


## 样例 #1

### 输入

```
1 3 2 19260718```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心在于解决“在n个位置中放置m个互不相同的樱花树，且任意两棵树之间至少有一个空位”的问题。题解主要集中在排列组合和动态规划两种思路上，其中排列组合的思路更为简洁高效，尤其是通过插空法将问题转化为排列数计算，时间复杂度为O(n)，适合大规模数据。

### 所选高星题解

#### 1. 作者：yyh_1102 (赞：256)
- **星级**：5星
- **关键亮点**：详细解释了排列组合中的插空法，并通过多个例题帮助理解排列与组合的区别。代码简洁，直接计算排列数，避免了复杂的动态规划。
- **个人心得**：通过多个例题的讲解，帮助读者深入理解排列组合的应用场景，尤其是插空法的使用。
- **核心代码**：
  ```cpp
  int main() {
    int I, love, yin, lin;
    scanf("%d%d%d%d", &I, &love, &yin, &lin);
    love = love - yin + 1; 
    int ans = 1;
    for (int i = love - yin + 1; i <= love; ++i) {
      ans = 1ll * ans * i % lin;
    }
    printf("%d\n", ans);
    return 0;
  }
  ```
  **实现思想**：通过循环计算排列数，利用模运算避免溢出。

#### 2. 作者：一扶苏一 (赞：91)
- **星级**：4星
- **关键亮点**：通过动态规划和组合数学的结合，详细分析了问题的两种分类情况，并给出了组合数的计算公式。代码实现清晰，适合理解动态规划与组合数学的结合。
- **核心代码**：
  ```cpp
  #include <stdio.h>
  int main() {
    int t;
    long long i, n, m, p, ans = 1;
    scanf("%d %lld %lld %lld", &t, &n, &m, &p);
    for (i = n + 1 - m; i > n + 1 - 2 * m; i--) {
      ans *= i;
      ans %= p;
    }
    printf("%lld", ans);
    return 0;
  }
  ```
  **实现思想**：通过循环计算组合数，利用模运算避免溢出。

#### 3. 作者：ez_lcw (赞：68)
- **星级**：4星
- **关键亮点**：直接通过插空法将问题转化为排列数计算，代码简洁明了，适合快速理解问题本质。
- **核心代码**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  ll ans=1,type,n,m,p;
  int main() {
    scanf("%lld%lld%lld%lld",&type,&n,&m,&p);
    for(int i=n-m+1;i>=n-2*m+2;i--)
      ans=(ans*i)%p;
    printf("%lld\n",ans);
    return 0;
  }
  ```
  **实现思想**：通过循环计算排列数，利用模运算避免溢出。

### 最优关键思路或技巧

1. **插空法**：将问题转化为排列数计算，通过预先留出m-1个空位，确保任意两棵树之间至少有一个空位，从而简化问题。
2. **组合数学与动态规划结合**：通过分类讨论，将问题分为两种情况，分别计算组合数，最后合并结果。
3. **模运算优化**：在计算过程中使用模运算避免溢出，确保结果在合理范围内。

### 可拓展之处

- **类似问题**：可以拓展到其他不相邻排列问题，如不相邻的座位安排、不相邻的球放置等。
- **算法套路**：插空法和组合数学的结合可以应用于多种排列组合问题，尤其是需要满足特定条件的情况。

### 推荐题目

1. [P2386 放苹果](https://www.luogu.org/problem/P2386)
2. [P2822 组合数问题](https://www.luogu.org/problem/P2822)
3. [P3197 [HNOI2008]越狱](https://www.luogu.org/problem/P3197)

### 个人心得总结

- **调试经历**：在计算排列数时，模运算的使用是关键，避免了大数溢出的问题。
- **顿悟感想**：通过插空法将复杂问题转化为简单的排列数计算，大大简化了问题的解决过程。

---
处理用时：29.23秒
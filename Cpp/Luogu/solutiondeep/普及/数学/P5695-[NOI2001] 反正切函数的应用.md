# 题目信息

# [NOI2001] 反正切函数的应用

## 题目背景

反正切函数可展开成无穷级数，有如下公式

$$ \arctan(x) = \sum_{n = 0}^\infty \frac{(-1) ^ n x ^ {2n + 1}}{2n + 1} ( 0 \le x \le 1 ) \tag{1} $$

使用反正切函数计算 是一种常用的方法。例如，最简单的计算 的方法：

$$
\begin{aligned}
\pi & = 4 \arctan(1) \\
    & = 4(1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \frac{1}{9} - \frac{1}{11} + \dots)
\end{aligned}
\tag{2}
$$

然而，这种方法的效率很低，但我们可以根据角度和的正切函数公式：

$$ \tan(\alpha + \beta) = \frac{\tan(\alpha) + \tan(\beta)}{1 - \tan(\alpha) \tan(\beta)} \tag{3} $$

通过简单的变换得到：

$$ \arctan(p) + \arctan(q) = \arctan(\frac{p + q}{1 - p q}) \tag{4} $$

利用这个公式，令 $ p = \frac{1}{2}, q = \frac{1}{3} $，则 $ \frac{p + q}{1 - p q} = 1 $，有

$$ \arctan(\frac{1}{2}) + \arctan(\frac{1}{3}) = \arctan(\frac{\frac{1}{2} + \frac{1}{3}}{1 - \frac{1}{2} \cdot \frac{1}{3}}) = \arctan(1) $$

## 题目描述

我们将公式 $ 4 $ 写成如下形式

$$ \arctan(\frac{1}{a}) = \arctan(\frac{1}{b}) + \arctan(\frac{1}{c}) $$

其中 $ a, b, c \in \mathbb{N^+} $。

我们的问题是：对于每一个给定的 $a$，求 $ b + c $ 的值。我们保证对于任意的 $ a $ 都存在整数解。如果有多个解，要求你给出 $ b + c $ 最小的解。


## 说明/提示

$1 \le a \le 6\times 10^4 $。

## 样例 #1

### 输入

```
1```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心在于利用反正切函数的性质，通过数学推导找到满足条件的最小 \( b + c \)。大多数题解都基于公式 \(\arctan(\frac{1}{a}) = \arctan(\frac{1}{b}) + \arctan(\frac{1}{c})\)，并通过代数变换得到 \( b \) 和 \( c \) 的关系式。最终，问题转化为寻找 \( b \) 和 \( c \) 使得 \( b + c \) 最小，且满足 \( b > a \) 和 \( c > a \)。

### 所选高星题解

#### 1. 作者：registerGen (5星)
- **关键亮点**：通过数学推导将问题转化为寻找 \( b - a \) 的最优值，利用对勾函数的性质，找到 \( b - a \) 的最接近 \(\sqrt{a^2 + 1}\) 的约数，从而最小化 \( b + c \)。代码简洁高效，时间复杂度为 \( O(a) \)。
- **核心代码**：
```cpp
int s = a * a + 1;
for (int i = a; i >= 1; i--)
    if (s % i == 0) {
        b = i + s / a;
        break;
    }
c = (a * b + 1) / (b - a);
printf("%lld\n", b + c);
```
- **个人心得**：通过数学推导简化问题，避免暴力枚举，极大提高了效率。

#### 2. 作者：Siegerkranz_2735 (4星)
- **关键亮点**：通过导数和函数极值的分析，找到 \( c \) 的最优值，进一步推导出 \( b \) 的表达式。代码实现中通过递减枚举 \( c \) 来找到最小 \( b + c \)。
- **核心代码**：
```cpp
long long i = a + sqrt(a * a + 1);
for (; __gcd(a * i + 1, i - a) != i - a; i--);
cout << (i * i + 1) / (i - a);
```
- **个人心得**：通过数学分析找到 \( c \) 的最优值，避免了不必要的枚举，提高了代码效率。

#### 3. 作者：Rocherio (4星)
- **关键亮点**：通过代数变换将问题转化为寻找 \( b - a \) 和 \( c - a \) 的最优值，利用基本不等式找到最小 \( b + c \)。代码实现中通过枚举 \( b - a \) 来找到最优解。
- **核心代码**：
```cpp
for (long long i = sqrt(a * a + 1); i <= a * a + 1; i++)
    if ((a * a + 1) % i == 0) {
        cout << (a * a + 1) / i + 2 * a + i;
        return 0;
    }
```
- **个人心得**：通过代数变换和基本不等式简化问题，避免了复杂的枚举过程。

### 最优关键思路与技巧

1. **数学推导**：通过反正切函数的性质和代数变换，将问题转化为寻找 \( b \) 和 \( c \) 的最优值。
2. **对勾函数性质**：利用对勾函数的性质，找到 \( b - a \) 的最接近 \(\sqrt{a^2 + 1}\) 的约数，从而最小化 \( b + c \)。
3. **枚举优化**：通过递减枚举或利用约数性质，避免暴力枚举，提高代码效率。

### 可拓展之处

- **类似问题**：类似的问题可以通过数学推导和函数极值分析来优化枚举过程，例如在数论中寻找满足特定条件的整数解。
- **算法套路**：在解决数学问题时，通过代数变换和函数性质分析，可以简化问题并提高算法效率。

### 推荐题目

1. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)
2. [P1072 Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)
3. [P1447 能量采集](https://www.luogu.com.cn/problem/P1447)

这些题目都涉及到数学推导和优化枚举过程，与本题的解题思路相似。

---
处理用时：26.33秒
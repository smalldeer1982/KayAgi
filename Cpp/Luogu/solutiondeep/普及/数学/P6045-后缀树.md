# 题目信息

# 后缀树

## 题目背景

Eztsu 是一个可爱的女孩子，最近她学习了[后缀树](https://www.luogu.com.cn/blog/EternalAlexander/xuan-ku-hou-zhui-shu-mo-shu)，并打算用它来解决如下问题。

## 题目描述

对于一个字符串 $S$，我们定义 $|S|$ 表示 $S$ 的长度。

接着，我们定义 $S_i$ 表示 $S$ 中第 $i$ 个字符，$S_{L...R}$ 表示由 $S$ 中从左往右数，第 $L$ 个字符到第 $R$ 个字符依次连接形成的字符串。

给定 $n$，求有多少种不同的满足下列要求的串 $S$：

- $|S|=n$。
- $S$ 中仅包含小写字母。
- 不存在整数 $i \in [1,n)$ 使得 $S_{1...i}$ 是 $S_{i+1...n}$ 的子串。

对于第三个限制，用通俗一点的说法解释的话，就是不存在一种将这个串分成两段的方式，使得前面一段是后面一段的子串。

两个串 $S$ 和 $T$ 不同当且仅当 $|S|\neq|T|$ 或 $\exists i \in [1,|S|] S_i \neq T_i$。如果你不知道这是什么意思，你可以理解为它们看起来不同。

可怜的 Eztsu 不会做，所以你要帮她做这道题。

答案可能很大，你只需要输出答案对 $998244353$ 取模的值。

题面补充：

$S$ 是 $T$ 的子串当且仅当存在 $L,R \in [1,|T|]$ 使得 $T_{L...R}=S$.

## 说明/提示

#### 样例解释

对于第一组样例，不难发现，这个串符合题意当且仅当两个字符不同，因此答案为 $26 \times 26 - 26$，可以理解为两个字符任意的方案数减去两个字符相同的方案数。

---

#### 数据范围

**「本题采用捆绑测试」**

对于所有测试点，保证 $1 \leq n \leq 10^9$。

$\text{Subtask 1 (17 pts)}$ $n \leq 4$。

$\text{Subtask 2 (78 pts)}$ $n \leq 2\times 10^3$。

$\text{Subtask 3 (5 pts)}$ 没有特殊限制。

---

#### 提示

小写字母一共有 $26$ 个。

## 样例 #1

### 输入

```
2```

### 输出

```
650```

## 样例 #2

### 输入

```
105383595```

### 输出

```
114514```

# AI分析结果

### 综合分析与结论

本题的核心在于理解题目条件，即字符串的前缀不能是后缀的子串。通过分析，可以发现只要字符串的第一个字符与后面的所有字符都不相同，就能满足条件。因此，问题转化为：第一个字符有26种选择，后面的每个字符有25种选择（不能与第一个字符相同）。最终答案为 \(26 \times 25^{n-1}\)，使用快速幂计算即可。

所有题解都抓住了这一关键点，且大部分题解都提供了快速幂的实现代码。题解的质量主要差异在于思路的清晰度、代码的可读性以及对问题的深入分析。

### 所选高星题解

#### 1. **作者：StudyingFather (5星)**
   - **关键亮点**：思路清晰，直接点出问题的核心，即第一个字符可以任意选择，后面的字符不能与第一个字符相同。简洁明了地给出了公式 \(26 \times 25^{n-1}\)，并建议使用快速幂计算。
   - **代码实现**：
     ```cpp
     int ans = 26 * fpow(25, n - 1) % mod;
     ```
     - **核心思想**：使用快速幂计算 \(25^{n-1}\)，然后与26相乘并取模。

#### 2. **作者：Hexarhy (5星)**
   - **关键亮点**：详细解释了问题的解题思路，从简单情况（\(n=2,3\)）推广到一般情况，强调了最极端的情况（第一个字符与后面字符的关系）。提供了完整的快速幂实现，代码可读性强。
   - **代码实现**：
     ```cpp
     ll fpow(ll n, ll k) {
         ll base = n, res = 1;
         while (k) {
             if (k & 1) res = res * base % MOD;
             base = base * base % MOD;
             k >>= 1;
         }
         return res;
     }
     ```
     - **核心思想**：快速幂的实现，通过不断平方和取模来高效计算幂次。

#### 3. **作者：霍士弘 (4星)**
   - **关键亮点**：详细介绍了乘法原理和快速幂的前置知识，适合初学者理解。虽然代码实现较为基础，但解释清晰，适合新手学习。
   - **代码实现**：
     ```cpp
     ll qpow(int a, int p) {
         if (p == 0) return 1;
         if (p == 1) return a % mod;
         ll ans = 1;
         if (p % 2 == 0) {
             ans = qpow(a, p / 2) % mod;
             ans = ans % mod * ans % mod;
             return ans;
         } else {
             ans = qpow(a, (p - 1) / 2) % mod;
             ans = a % mod * ans % mod * ans % mod;
             return ans;
         }
     }
     ```
     - **核心思想**：递归实现快速幂，通过折半计算来减少时间复杂度。

### 最优关键思路与技巧

- **关键思路**：通过分析题目条件，发现只要第一个字符与后面的所有字符都不相同，就能满足条件。问题转化为简单的排列组合问题。
- **技巧**：使用快速幂高效计算 \(25^{n-1}\)，避免直接计算导致的时间复杂度问题。

### 可拓展之处

- **同类型题**：类似的问题可以通过分析字符串的前缀和后缀关系来解决，常见的题目包括字符串匹配、子串查找等。
- **算法套路**：快速幂是解决大指数幂运算的常用技巧，适用于需要高效计算幂次的场景。

### 推荐题目

1. **P1226 【模板】快速幂**：快速幂的模板题，适合练习快速幂的实现。
2. **P3375 【模板】KMP字符串匹配**：考察字符串匹配的经典题目，适合理解字符串的前缀和后缀关系。
3. **P3805 【模板】Manacher算法**：用于求解最长回文子串的算法，涉及字符串的前缀和后缀分析。

### 个人心得摘录

- **StudyingFather**：直接点出问题的核心，简洁明了，适合快速理解题目。
- **Hexarhy**：从简单情况推广到一般情况，强调了最极端的情况，适合深入理解问题。
- **霍士弘**：详细介绍了前置知识，适合初学者学习，但代码实现较为基础。

### 通用建议与扩展思路

- **通用建议**：对于类似的字符串问题，可以先从简单情况入手，逐步推广到一般情况，找到问题的核心条件。
- **扩展思路**：快速幂是解决大指数幂运算的常用技巧，掌握其实现可以帮助解决更多类似的问题。

---
处理用时：25.01秒
# 题目信息

# [传智杯 #2 决赛] 补刀

## 题目描述

UIM 在写程序的空闲玩一款 MOBA 游戏。

![](https://cdn.luogu.com.cn/upload/image_hosting/j6t4jmrd.png)

当敌方的小兵进入到我方防御塔的范围内，就会持续受到防御塔造成的伤害；当然我方英雄也可以对它造成伤害。当小兵的血量降到了 0 或者更低，就会被击杀。为了获得经验，UIM 希望在防御塔将这个小兵杀死之前，亲自补刀将其击杀。

为了简化问题，我们假设这个小兵有 $h$ 点的生命值。每次防御塔的攻击可以给小兵造成 $x$ 点伤害，而你的英雄每次攻击可以给小兵造成 $y$ 点伤害。你的攻击速度和防御塔攻击速度相同，所以你可以在防御塔第一次攻击小兵之前，或者每次防御塔攻击之后，选择是否对小兵进行一次攻击，当然你也可以选择不攻击。

现在想知道，给出这些信息，判断英雄是否有办法将这个小兵击杀？

## 说明/提示

数据的组数不多于 50，$1\le h \le 10^{18}$，$0\le x,y \le 10^{18}$。

## 样例 #1

### 输入

```
5
100 100 1
100 97 1
100 98 1
100 99 1
100 100 0```

### 输出

```
No
No
Yes
Yes
No```

# AI分析结果

### 综合分析与结论

本题的核心在于判断英雄是否能在防御塔击杀小兵之前完成补刀。题解主要集中在如何计算防御塔和英雄的攻击次数，并通过数学公式或模拟来判断英雄是否能够在小兵被防御塔击杀前完成补刀。大部分题解都采用了类似的思路，即通过计算防御塔的最大攻击次数，然后判断英雄在这些攻击间隔中是否能造成足够的伤害。

### 所选高星题解

#### 1. **作者：d446101 (5星)**
- **关键亮点**：思路清晰，直接通过数学公式计算防御塔的最大攻击次数，并判断英雄的攻击是否足够。代码简洁，逻辑明确。
- **个人心得**：作者提到“为了皮尔特沃夫！”，体现了对MOBA游戏的理解，增加了题解的趣味性。

```ruby
n = gets.to_i
for i in 1..n
    h, x, y = gets.split.map(&:to_i) 
    if y == 0
        puts "No"
        next
    elsif x == 0
        puts "Yes"
        next
    end
    tower = h / x
    if h % x == 0 then tower -= 1 end
    if (tower + 1) * y + tower * x >= h
        puts "Yes"
    else
        puts "No"        
    end
end
```

#### 2. **作者：cyrxdzj (4星)**
- **关键亮点**：通过特判处理特殊情况，代码结构清晰，逻辑严谨。使用`ceil`函数计算防御塔的最大攻击次数，增强了代码的可读性。
- **个人心得**：作者提到“记得开long long！”，提醒了数据范围的重要性，避免了潜在的溢出问题。

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
long long h,x,y;
int t;
int main()
{
	scanf("%d",&t);
	for(int i=1;i<=t;i++)
	{
		scanf("%lld%lld%lld",&h,&x,&y);
		if(y==0)
		{
			printf("No\n");
			continue;
		}
		else if(x==0)
		{
			printf("Yes\n");
			continue;
		}
		long long tower_attack_times=ceil(double(h)/x)-1;
		h-=tower_attack_times*x;
		long long hero_attack_times=ceil(double(h)/y);
		if(hero_attack_times<=tower_attack_times+1)
		{
			printf("Yes\n");
		}
		else
		{
			printf("No\n");
		}
	}
	return 0;
}
```

#### 3. **作者：gcwixsxr (4星)**
- **关键亮点**：通过多个特判处理各种边界情况，逻辑严密。使用数学公式直接判断英雄是否能补刀，代码简洁高效。
- **个人心得**：作者提到“本蒟蒻靠代码短活到现在”，体现了对代码简洁性的追求。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool judge (long long a,long long b,long long c){
	if(a<=c)return true;
	if(c==0)return false;
	if(b==0)return true;
	if(b>=a&&a>c)return false;
	if(a%b==0)
		if((a/b)*c>=b)return true;
		else return false;
	else if(((a/b)+1)*c>=a-(a/b)*b)return true;
		else return false;
}
signed main(){
	int n;
	long long d,e,f;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){	
		scanf("%lld%lld%lld",&d,&e,&f);
		if(judge(d,e,f))cout<<"Yes"<<endl;
		else cout<<"No"<<endl; 
	}
	return 0;
}
```

### 最优关键思路与技巧

1. **数学公式计算**：通过计算防御塔的最大攻击次数，判断英雄在这些攻击间隔中是否能造成足够的伤害。
2. **特判处理**：对特殊情况（如英雄或防御塔攻击力为0）进行特判，避免不必要的计算。
3. **边界条件处理**：注意数据范围，使用`long long`避免溢出。

### 可拓展之处

- **类似问题**：可以扩展到其他需要计算攻击次数或伤害的题目，如计算多个攻击者的攻击顺序和伤害。
- **算法优化**：可以通过更复杂的数学公式或动态规划来优化计算过程。

### 推荐题目

1. **P1003 铺地毯**：考察边界条件处理和模拟。
2. **P1045 麦森数**：考察大数处理和数学公式应用。
3. **P1068 分数线划定**：考察排序和边界条件处理。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中遇到的数据溢出问题，提醒了数据范围的重要性。
- **踩坑教训**：特判处理是避免错误的关键，尤其是在边界条件复杂的情况下。
- **顿悟感想**：通过数学公式直接计算攻击次数，比模拟更高效，体现了数学在算法中的重要性。

---
处理用时：28.30秒
# 题目信息

# 「EZEC-2」异或

## 题目描述

有 $T$ 组询问，每次给定两个正整数 $n,l$，   

你需要构造一个长度为 $l$ 的正整数序列 $a$（编号从 $1$ 至 $l$），   

且满足 $\forall i\in[1,l]$，都有 $a_i\in[1,n]$。

求：

$$\sum_{i=1}^l\sum_{j=1}^{i-1}a_i\oplus a_j$$

的最大值。

为了避免答案过大，对于每组询问，只需要输出这个最大值对 $10^9+7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**   
当 $n=2,l=3$，$a$ 取 $\{1,2,1\}$ 的任一排列时可以得到最大值，为 $(1\oplus2)+(1\oplus1)+(2\oplus1)=6$，易证明此时原式有最大值。

---
**【数据规模与约定】**
| 测试点编号 | $T\le$ | $n\le$ | $l\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim5$ | $1$ | $10$ | $5$ |
| $6$ | $5\times 10^5$ | $10^{12}$ | $2$ |
| $7$ | $5\times 10^5$ | $10^{12}$ | $3$ |
| $8\sim10$ | $5\times 10^5$ | $10^{12}$ | $10^5$ |

对于 $100\%$ 的数据，满足 $1\le T\le 5\times10^5$，$1\le n\le 10^{12}$，$2\le l \le 10^5$。


---
**【提示】**

1. 「$\oplus$」是按位异或符号。如果您不知道什么是按位异或，可以参考[这里](https://oi-wiki.org/math/bit/#_1)。
2. 取模是一种运算，$a$ 对 $b$ 取模代表将 $a$ 赋值为 $a$ 除以 $b$ 所得到的余数。  
在 C++ / Python 中的取模符号为 `%`，在 Pascal 中的取模符号为 `mod`。
3. $\sum$ 是求和符号。如果您不知道什么是 $\sum$ 符号，可以参考[这里](https://baike.baidu.com/item/∑/1233796?fr=aladdin)。
4. 请注意数据的读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
1
2 3
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
114 514
1919 180
```

### 输出

```
8388223
16580700```

# AI分析结果

### 综合分析与结论

本题的核心在于通过构造一个长度为 \( l \) 的序列，使得序列中任意两个元素的异或和最大。由于异或运算的位独立性，大多数题解都采用了按位分析的思路，即逐位计算每一位对最终答案的贡献，并通过数学推导找到最优的构造方式。具体来说，对于每一位，最优的构造方式是让该位为 \( 1 \) 的个数尽可能接近 \( \frac{l}{2} \)，从而最大化该位的贡献。

### 最优关键思路与技巧

1. **按位分析**：由于异或运算的位独立性，可以逐位计算每一位的贡献，最终将所有位的贡献相加得到答案。
2. **最大化贡献**：对于每一位，设该位为 \( 1 \) 的个数为 \( x \)，则贡献为 \( x \times (l - x) \times 2^k \)。通过数学推导可知，当 \( x = \frac{l}{2} \) 时，贡献最大。
3. **构造序列**：通过构造一半的数为 \( 2^{p-1} \)，另一半为 \( 2^{p-1} - 1 \)，可以确保每一位的 \( 1 \) 的个数接近 \( \frac{l}{2} \)，从而最大化异或和。

### 推荐题解

#### 1. 作者：dead_X (赞：18)
- **星级**：★★★★★
- **关键亮点**：详细推导了按位分析的思路，并通过构造序列证明了最优解的正确性。代码简洁高效，处理了 \( n = 1 \) 的特例。
- **个人心得**：作者提到通过构造 \( p \) 和 \( p-1 \) 的序列来确保每一位的 \( 1 \) 的个数接近 \( \frac{l}{2} \)，并通过特判 \( n = 1 \) 的情况避免了错误。

```cpp
int main() {
    int T=read();
    while(--T) {
        long long x=readll(),y=readll(),t=y>>1;
        if(x==1) { puts("0"); continue; }
        long long now=1LL<<40,res=0;
        while(now) {
            now>>=1;
            if(x<now) continue;
            res+=now*t*(y-t);
        }
        printf("%lld\n",res%1000000007LL);
    }
    return 0;
}
```

#### 2. 作者：李白莘莘学子 (赞：11)
- **星级**：★★★★☆
- **关键亮点**：清晰解释了按位分析的思路，并通过二次函数求极值的方法推导出最优解。代码实现简洁，处理了 \( n = 1 \) 的特例。
- **个人心得**：作者通过二次函数求极值的方法，推导出当 \( x = \frac{l}{2} \) 时，贡献最大，并通过构造序列实现了这一目标。

```cpp
int main() {
    t=read();
    while(t--) {
        ans=0;
        scanf("%lld%lld",&n,&l);
        long long mid=l>>1;
        if(n==1) { printf("0\n"); continue; }
        long long big=1ll<<40;
        while(big) {
            big>>=1;
            if(n<big)continue;
            ans+=big*mid*(l-mid);
            ans%=modd;
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

#### 3. 作者：do_while_true (赞：4)
- **星级**：★★★★☆
- **关键亮点**：通过反证法和二次函数求极值的方法，详细推导了每一位的最优构造方式，并给出了构造序列的证明。代码实现简洁，处理了 \( n = 1 \) 的特例。
- **个人心得**：作者通过反证法证明了当 \( x = \frac{l}{2} \) 时，贡献最大，并通过构造序列实现了这一目标。

```cpp
int main() {
    scanf("%d",&T);
    while(T--) {
        scanf("%lld%lld",&n,&l);
        printf("%lld\n",( l / 2 ) * ( l - l / 2 ) % mod * ( qpow( 2, log(n) / log(2) + 1 ) - 1 ) % mod );
    }
}
```

### 可拓展之处

1. **类似题目**：本题的按位分析思路可以应用于其他位运算相关的题目，如按位与、按位或等。
2. **构造序列**：通过构造特定的序列来最大化某种运算结果，是一种常见的解题思路，可以应用于其他类似的构造题。

### 推荐题目

1. **P2114 [NOI2014] 起床困难综合症**：考察按位分析的思路，通过选择操作序列来最大化最终结果。
2. **P6102 [EER2] 子集**：考察子集构造和位运算的结合，通过构造子集来满足特定条件。
3. **P2115 [USACO14MAR] 牛的基因组**：考察位运算和构造序列的结合，通过构造序列来满足特定条件。

---
处理用时：33.05秒
# 题目信息

# [USACO20DEC] Cowntagion S

## 题目描述

Farmer John 和他的农民团队为了控制牛传染病 COWVID-19 在他们农场间的传播而夜以继日地工作。

他们共同监控着 $N$ 个农场（$1≤N≤10^5$），编号为 $1…N$。农场间由 $N−1$ 条道路连接，使得每个农场都可以从农场 $1$ 出发经过一些道路到达。

很不幸，农场 $1$ 中的一头奶牛的 COWVID-19 检测呈阳性。暂时这个农场的其他奶牛以及其他农场的所有奶牛都还没有染上疾病。然而，根据这个疾病通过接触传播的特性，Farmer John 推测每一天都会有以下不利的事件之一发生：

(1) 在一个农场内，「超级传播者」导致该农场感染 COWVID-19 的奶牛数量翻倍；或者

(2) 一头感染 COWVID-19 的奶牛从一个农场沿道路去往了一个相邻的农场。

Farmer John 担心疫情会很快爆发。请帮助 Farmer John 求出每个农场内均有至少一头奶牛感染疾病所需经过的最小天数。 

## 说明/提示

该样例对应的一个可能的事件序列如下：农场 $1$ 内染病的奶牛数量翻倍再翻倍，使得两天后农场 $1$ 内有 $4$ 头染病的奶牛。在此后 $3$ 天，分别有一头染病的奶牛从农场 $1$ 去往农场 $2$、$3$ 和 $4$。$5$ 天过后每个农场均有至少 $1$ 头染病的奶牛。


 - 测试点 1-4 中，每个农场均直接与农场 $1$ 相连（除农场 $1$ 外）。
 - 测试点 5-7 中，农场 $2…N$ 均至多与两条道路相连。
 - 测试点 8-15 没有额外限制。

供题：Dhruv Rohatgi 

## 样例 #1

### 输入

```
4
1 2
1 3
1 4```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

该题目要求通过两种操作（翻倍和传播）使得所有农场至少有一头感染的奶牛，且要求最小化操作天数。题解中大部分思路都基于贪心策略，即优先在某个节点进行翻倍操作，直到其感染奶牛数量足够传播给所有子节点，然后再进行传播操作。这种策略的合理性在于翻倍操作能够快速增加感染奶牛数量，而传播操作则确保感染能够扩散到所有节点。

### 题解评分与亮点

#### 1. 作者：wsyhb (5星)
- **关键亮点**：思路清晰，详细分析了贪心策略的合理性，并通过举例说明了最优策略的正确性。代码实现简洁，使用了DFS遍历树并统计每个节点的儿子个数，预处理Log表以快速计算翻倍次数。
- **个人心得**：通过举例说明了贪心策略的最优性，避免了复杂的证明过程，使得思路更加直观。
- **核心代码**：
```cpp
void dfs(int x, int fa) {
    for (int i = head[x]; i; i = edge[i].next) {
        int y = edge[i].to;
        if (y != fa) {
            dfs(y, x);
            ++son[x];
        }
    }
    int tmp = 1;
    while (tmp <= son[x]) {
        ans++;
        tmp *= 2;
    }
    ans += son[x];
}
```

#### 2. 作者：Skies (4星)
- **关键亮点**：通过贪心策略和树的遍历结合，详细说明了每个节点的处理方式，代码实现较为简洁，使用了链式前向星存图。
- **个人心得**：强调了翻倍操作的效率高于传播操作，并通过举例说明了贪心策略的最优性。
- **核心代码**：
```cpp
void dfs(int x, int fa) {
    int lo = -1;
    if (x == 1) lo++;
    lo += son[x];
    ans += lo;
    int u = 0;
    while (1) {
        if ((1 << u) > lo) break;
        u++;
    }
    ans += u;
    for (int i = head[x]; i; i = edge[i].next) {
        int y = edge[i].to;
        if (y != fa) dfs(y, x);
    }
}
```

#### 3. 作者：jingkongwanglimiaoa (4星)
- **关键亮点**：通过BFS遍历树，详细说明了每个节点的处理方式，代码实现简洁，使用了邻接链表存图。
- **个人心得**：强调了每个节点只能由一个父节点传播感染，避免了复杂的证明过程。
- **核心代码**：
```cpp
void bfs() {
    while (!q.empty()) {
        int user = q.front(), in = 0;
        q.pop();
        for (int i = lk[user]; i; i = a[i].wei) if (!vis[a[i].pow]) in++;
        int sum = 1;
        while (sum <= in) sum *= 2, ans++;
        ans += in;
        for (int i = lk[user]; i; i = a[i].wei) {
            if (!vis[a[i].pow]) q.push(a[i].pow);
            vis[a[i].pow] = 1;
        }
    }
}
```

### 最优关键思路与技巧

1. **贪心策略**：优先在某个节点进行翻倍操作，直到其感染奶牛数量足够传播给所有子节点，然后再进行传播操作。
2. **树的遍历**：通过DFS或BFS遍历树，统计每个节点的儿子个数，并计算翻倍次数。
3. **预处理Log表**：通过预处理Log表，快速计算翻倍次数，优化时间复杂度。

### 可拓展之处

1. **类似题目**：可以考虑类似的问题，如最小化操作次数使得所有节点满足某种条件，或者最大化某种收益。
2. **算法套路**：贪心策略与树的遍历结合，适用于许多树形结构的问题，如最小生成树、最短路径等。

### 推荐题目

1. **P1352 没有上司的舞会**：考察树形DP与贪心策略。
2. **P2015 二叉苹果树**：考察树形DP与贪心策略。
3. **P2014 选课**：考察树形DP与贪心策略。

### 个人心得总结

通过举例说明贪心策略的最优性，避免了复杂的证明过程，使得思路更加直观。在实际编码中，预处理Log表可以显著提高计算效率，减少时间复杂度。

---
处理用时：26.28秒
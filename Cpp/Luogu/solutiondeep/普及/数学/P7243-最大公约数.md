# 题目信息

# 最大公约数

## 题目背景

&emsp;&emsp;“寻求最大公约数是人民民主的真谛。……”

&emsp;&emsp;初秋，从枝丫滴下的阳光，柔和，在教室的窗棱溅起，润湿晨读的少女的脸颊。

&emsp;&emsp;“阿绫，阿绫”，天依低俯身子，八字辫耷拉在竖起的课本沿，“我们的最大公约数是多少呢？”

&emsp;&emsp;“一定不小吧”，左手悄悄捏捏天依的小臂，“比如呀，有一个公因子，叫做‘你喜欢我，我也喜欢你’。”

## 题目描述

相反，人际圈形形色色，公约数小得可怜，似乎很难保持自己的个性因而变成无趣的人呢。

现在把人际抽象成一个 $n \times m$ 的矩形，每个人初始的个性为 $a_{i,j}$。从第二天开始，每个人会与上下左右四个人（如果存在）建立人际关系，其个性变为昨天自己和四周人个性的最大公约数。那么对于第 $x$ 行第 $y$ 列的人，在多少天后他的个性会变为 $1$ 呢？

----

#### 简化题意

有一个 $n \times m$ 的矩阵 $a$。对一个矩阵进行变换，定义为将这个矩阵内的所有元素变为其上下左右四个元素（不存在则忽略）及自身的最大公约数。询问 $a_{x,y}$ 在进行最少多少次变换之后会变成 $1$。如果可以使 $a_{x,y}$ 经过若干次变换变成 $1$，输出其中最小的次数；否则输出 $-1$。

## 说明/提示

#### 样例解释 3
第一天的个性矩阵（也就是最开始的矩阵）为
$$
\begin{pmatrix}
3&2&3\\
2&3&2\\
3&2&3
\end{pmatrix}
$$
第二天的个性矩阵为
$$
\begin{pmatrix}
1&1&1\\
1&1&1\\
1&1&1
\end{pmatrix}
$$
可见只需要经过一天，$a_{2,2}$ 就会变为 $1$，所以答案为 $1$。

#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^3$，$1\le a_{i,j}\le 10^{18}$，$1\le x\le n$，$1\le y\le m$。

| 子任务 | 分值 |        $n,m$        |              特殊限制              |
| :----: | :--: | :-----------------: | :--------------------------------: |
|   1    |  1   |          /          | 保证给出的位置个性永远不会变为 $1$ |
|   2    |  1   |          /          |          保证 $a_{x,y}=1$          |
|   3    |  3   |      $ \le 2$       |                 /                  |
|   4    |  10  |     $ \le 10^2$     |                 /                  |
|   5    |  30  | $ \le 5\times 10^2$ |           /            |
|   6    |  10  |          /          |   保证对于所有的 $a_{i,j} \le 2$   |
|   7    |  10  |          /          |     保证 $x$ 与 $y$ 都等于 $1$     |
|   8    |  35  |          /          |                 /                  |





------------




## 样例 #1

### 输入

```
2 2
2 2
1 2
2 1```

### 输出

```
0```

## 样例 #2

### 输入

```
2 2
2 2 
2 2
1 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
3 3
3 2 3
2 3 2
3 2 3
2 2```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心是通过广度优先搜索（BFS）结合最大公约数（GCD）的计算，逐步扩展矩阵中的元素，直到目标位置的元素变为1。难点在于如何高效地计算每次变换后的GCD，并避免重复计算。大多数题解采用了BFS的思路，结合曼哈顿距离来优化搜索过程。部分题解还通过预处理或优化GCD计算来提升效率。

### 所选高星题解

#### 1. **作者：vectorwyx (赞：63)**  
**星级：5星**  
**关键亮点：**
- **清晰的理论基础**：通过GCD的嵌套性质，解释了为什么BFS可以有效解决问题。
- **高效的BFS实现**：使用队列进行BFS，边扩展边计算GCD，避免了重复计算。
- **时间复杂度分析**：明确指出了算法的时间复杂度为 \(O(nm \log k)\)，适合大规模数据。

**核心代码：**
```cpp
void bfs(){
    queue<int> qx,qy,qs;
    qx.push(sx),qy.push(sy),qs.push(0);
    vis[sx][sy]=1;
    ll sum=a[sx][sy];
    while(!qx.empty()){
        int x=qx.front(),y=qy.front(),s=qs.front();
        qx.pop(),qy.pop(),qs.pop();
        fo(i,0,3){
            int tx=x+dx[i],ty=y+dy[i];
            if(tx<1||tx>n||ty<1||ty>m||vis[tx][ty]) continue;
            vis[tx][ty]=1;
            qx.push(tx),qy.push(ty),qs.push(s+1);
            sum=__gcd(sum,a[tx][ty]);
            if(sum==1){
                cout<<s+1;
                return;
            }
        }
    }
    cout<<-1;
}
```
**实现思想：** 通过BFS从目标点出发，逐步扩展并计算GCD，直到找到目标值为1的位置。

#### 2. **作者：_zy_ (赞：21)**  
**星级：4星**  
**关键亮点：**
- **简洁的BFS实现**：通过队列实现BFS，逐步扩展并计算GCD。
- **无解判断**：在BFS结束后判断是否找到解，避免了不必要的计算。

**核心代码：**
```cpp
void bfs(int x,int y){
    int head,tail;
    head=tail=0;
    q[++tail][0]=x; q[tail][1]=y;
    v[x][y]=1;
    while(head<tail){
        int X=q[++head][0];
        int Y=q[head][1];
        for(int i=1;i<=4;i++){
            int xx=X+dx[i]; int yy=Y+dy[i];
            if(v[xx][yy]||xx<1||yy<1||xx>n||yy>m) continue;
            q[++tail][0]=xx;
            q[tail][1]=yy;
            q[tail][2]=q[head][2]+1;
            v[xx][yy]=1;
            tot=gcd(tot,a[xx][yy]);
        }
        if(tot==1) {
            cout<<q[tail][2]<<endl;
            exit(0);
        }
    }
}
```
**实现思想：** 通过BFS从目标点出发，逐步扩展并计算GCD，直到找到目标值为1的位置。

#### 3. **作者：Just_A_King (赞：14)**  
**星级：4星**  
**关键亮点：**
- **曼哈顿距离的应用**：通过曼哈顿距离来优化BFS的扩展过程，减少了不必要的计算。
- **时间复杂度分析**：详细分析了算法的时间复杂度，适合大规模数据。

**核心代码：**
```cpp
while(ans!=1 && !q.empty()){
    ++day;
    while(!q.empty() && dis(q.front())<day){
        for(ll i=1;i<=4;++i){
            node mid=(node){q.front().x+way1[i],q.front().y+way2[i]};
            if(mid.x>=1&&mid.x<=n && mid.y>=1&&mid.y<=m && a[mid.x][mid.y]){
                ans=gcd(ans,a[mid.x][mid.y]);
                q.push(mid);a[mid.x][mid.y]=0;
            }
        }
        q.pop();
    }
}
```
**实现思想：** 通过BFS结合曼哈顿距离，逐步扩展并计算GCD，直到找到目标值为1的位置。

### 最优关键思路与技巧

1. **BFS与GCD结合**：通过BFS逐步扩展矩阵中的元素，并计算GCD，直到目标位置的元素变为1。
2. **曼哈顿距离优化**：利用曼哈顿距离来减少BFS的扩展范围，避免不必要的计算。
3. **时间复杂度优化**：通过预处理或优化GCD计算，提升算法的整体效率。

### 可拓展之处

- **类似问题**：可以扩展到其他基于矩阵变换的问题，如最小公倍数、矩阵乘法等。
- **算法优化**：可以进一步优化GCD的计算，如使用更高效的算法或预处理。

### 推荐题目

1. **P1443 马的遍历**：考察BFS在矩阵中的应用。
2. **P1219 八皇后**：考察DFS在矩阵中的应用。
3. **P1141 01迷宫**：考察BFS在矩阵中的应用，结合路径搜索。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现BFS的扩展范围过大，导致效率低下，通过曼哈顿距离优化后显著提升。
- **踩坑教训**：部分题解提到在无解判断时容易忽略全局GCD的计算，导致错误输出。
- **顿悟感想**：通过BFS与GCD的结合，能够高效解决矩阵变换问题，体现了算法设计的巧妙性。

---
处理用时：35.48秒
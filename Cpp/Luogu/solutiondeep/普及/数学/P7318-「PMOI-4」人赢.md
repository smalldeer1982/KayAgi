# 题目信息

# 「PMOI-4」人赢

## 题目背景

众所周知，ducati 是人 win。

现在 lhm 也想成为人 win，于是 ducati 扔给了 lhm 下面这道题，并且 ducati 承诺在 lhm 完成此题后教他如何成为人 win。

## 题目描述

现在 lhm 手中有一个无穷长的衔尾数列 $a$，它满足：

- 对于数列中的每一个 $a_i(i>2)$，它总为 $a_{i-2} \times a_{i-1}$ 的**个位数**。

ducati 将给 lhm 衔尾数列的前两位 $a_1=n,a_2=m$ 与位置 $k$，它的任务是算出 $a_k$。

由于 lhm 太菜了并不会这道题，但他仍然想成为人 win，所以他只好请聪明的你来帮他完成这个问题。

## 说明/提示

【样例解释 $1$】

数列 $1$ 至 $10$ 位依次为：$1,6,6,6,6,6,6,6,6,\color{red}{6}$。所以答案为 $6$。

【样例解释 $2$】

数列 $1$ 至 $7$ 位依次为：$7,2,4,8,2,6,\color{red}{2}$。所以答案为 $2$。


【数据范围】

**本题采用捆绑测试**。

- Subtask 1（30pts）：$1 \leq k \leq 10^6$。
- Subtask 2（70pts）：无特殊限制。

对于 $100\%$ 的数据，$0 \leq n,m \leq 9$，$1 \leq k \leq 10^{12}$。

## 样例 #1

### 输入

```
1 6 10```

### 输出

```
6```

## 样例 #2

### 输入

```
7 2 7```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心在于处理一个递推数列，且数列的每一项仅与前两项的个位数有关。由于数列的每一项都是0到9之间的整数，且数列的长度可能非常大（k ≤ 10^12），因此直接暴力递推无法通过。题解中主要采用了以下几种思路：

1. **循环节法**：通过观察数列的周期性，找到循环节后利用模运算快速求解。这是大多数题解采用的方法，适用于数列的周期性较为明显的情况。
2. **矩阵快速幂**：通过斐波那契数列的性质，结合矩阵快速幂和欧拉定理，快速计算数列的第k项。这种方法适用于数列的递推关系与斐波那契数列类似的情况。
3. **暴力找循环节**：通过暴力枚举数列的前若干项，找到循环节后利用模运算求解。这种方法适用于数列的循环节较短且容易找到的情况。

### 所选高星题解

#### 1. 题解作者：Thomas_Cat (★★★★★)
- **关键亮点**：通过观察数列的周期性，发现数列的循环节长度为6，并利用模运算快速求解。代码简洁且思路清晰，适用于所有情况。
- **核心代码**：
  ```cpp
  int a[10], b[7];
  a[1] = n, a[2] = m;
  for (int i = 3; i <= 9; i++)
      a[i] = (a[i - 1] % 10 * a[i - 2] % 10) % 10;
  cout << a[(k - 3) % 6 + 3];
  ```
- **实现思想**：通过计算数列的前9项，发现数列的循环节长度为6，然后利用模运算快速求解第k项。

#### 2. 题解作者：Exber (★★★★☆)
- **关键亮点**：通过矩阵快速幂和斐波那契数列的性质，结合欧拉定理，快速计算数列的第k项。这种方法适用于数列的递推关系与斐波那契数列类似的情况。
- **核心代码**：
  ```cpp
  long long fbnq(long long q, long long mod) {
      if (q <= 2) return 1;
      node ans, tmp;
      ans.mod = mod;
      tmp.mod = mod;
      for (int i = 1; i <= 2; i++) ans.a[1][i] = 1;
      tmp.a[1][1] = 1; tmp.a[1][2] = 1; tmp.a[2][1] = 1;
      q -= 2;
      while (q) {
          if (q & 1) ans *= tmp;
          tmp *= tmp;
          q >>= 1;
      }
      return ans.a[1][1] % mod;
  }
  ```
- **实现思想**：通过矩阵快速幂计算斐波那契数列的第k项，然后利用欧拉定理快速计算数列的第k项。

#### 3. 题解作者：Remake_ (★★★★☆)
- **关键亮点**：通过矩阵快速幂和拓展欧拉定理，结合斐波那契数列的性质，快速计算数列的第k项。这种方法适用于数列的递推关系与斐波那契数列类似的情况。
- **核心代码**：
  ```cpp
  node qpp(node b, ll p) {
      node ans, base = b;
      ans.dw();
      while (p) {
          if (p & 1) ans = mul(ans, base);
          base = mul(base, base);
          p >>= 1;
      }
      return ans;
  }
  ```
- **实现思想**：通过矩阵快速幂计算斐波那契数列的第k项，然后利用拓展欧拉定理快速计算数列的第k项。

### 最优关键思路与技巧

1. **循环节法**：通过观察数列的周期性，找到循环节后利用模运算快速求解。这种方法适用于数列的周期性较为明显的情况。
2. **矩阵快速幂**：通过斐波那契数列的性质，结合矩阵快速幂和欧拉定理，快速计算数列的第k项。这种方法适用于数列的递推关系与斐波那契数列类似的情况。

### 可拓展之处

1. **类似递推数列**：对于类似的递推数列，可以通过观察数列的周期性或利用矩阵快速幂和欧拉定理快速求解。
2. **循环节的应用**：在处理周期性数列时，可以通过找到循环节后利用模运算快速求解。

### 推荐题目

1. **洛谷 P1962 斐波那契数列**：考察斐波那契数列的快速计算。
2. **洛谷 P3390 矩阵快速幂**：考察矩阵快速幂的应用。
3. **洛谷 P3811 乘法逆元**：考察模运算和快速幂的应用。

### 个人心得总结

- **调试经历**：在处理大数问题时，需要注意数据类型的溢出问题，尤其是在计算斐波那契数列时。
- **踩坑教训**：在寻找循环节时，需要注意数列的起始位置和循环节的长度，避免计算错误。
- **顿悟感想**：通过观察数列的周期性，可以大大简化问题的求解过程，尤其是在处理大数问题时。

---
处理用时：30.02秒
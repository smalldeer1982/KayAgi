# 题目信息

# 「EZEC-6」加减

## 题目描述

给你两个数 $n,m$，你要将 $m$ 分为 $n$ 个**互不相同的正整数**（即这 $n$ 个数之和为 $m$），使得在区间 $[1,m]$ 中至少有一个正整数无法通过这 $n$ 个数加减取得（加减时每个数最多用 $1$ 次）。

即，设 $n$ 个正整数中第 $i$ 个数为 $a_i$，你要使在区间 $[1,m]$ 中至少有一个正整数无法被表示为 $\sum\limits^{n}_{i=1}k_i\times a_i\ (k_i\in\{-1,0,1\})$ 的形式。

若无解，输出 `-1`。

若有解，则输出任意一组满足要求的 $n$ 个正整数，并输出在区间 $[1,m]$ 中无法被表示出的任意一个数。

## 说明/提示

**本题采用捆绑测试**。

- Subtask 1（10 points）：$n\le2$。
- Subtask 2（20 points）：$2n^2\le m$。
- Subtask 3（20 points）：$\lceil1.5n^2\rceil\le m$。
- Subtask 4（20 points）：$n\le5$。
- Subtask 5（30 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le100$，$1\le n,m\le10^4$。

## 样例 #1

### 输入

```
4
2 6
3 18
1 1
2 4```

### 输出

```
1 5
3
5 6 7
3
-1
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于将 $m$ 分为 $n$ 个互不相同的正整数，并确保在区间 $[1,m]$ 中至少有一个数无法通过这 $n$ 个数的加减运算得到。大多数题解都围绕如何构造这 $n$ 个数展开，且普遍认为当 $m \geq \frac{n \times (n+3)}{2}$ 时，可以通过构造一个不含 $1$ 的序列来确保 $m-1$ 无法被表示。若 $m < \frac{n \times (n+1)}{2}$，则无解。

### 最优关键思路与技巧

1. **构造不含1的序列**：通过从 $2$ 开始构造递增序列，确保 $m-1$ 无法被表示。这是大多数题解的核心思路。
2. **数学公式的应用**：利用 $\sum_{i=2}^{n+1} i = \frac{n \times (n+3)}{2}$ 来判断是否有解，简化了问题。
3. **边界条件的处理**：通过判断 $m$ 是否满足特定条件，快速判断无解情况，避免不必要的计算。

### 可拓展之处

1. **类似问题**：类似的问题可以考察如何将某个数分为若干个数，并满足特定的条件（如互不相同、和为某个值等）。
2. **算法优化**：可以进一步优化构造序列的算法，确保在更复杂的情况下也能快速找到解。

### 推荐题目

1. [P1045 数字拆分](https://www.luogu.com.cn/problem/P1045)
2. [P1064 数字游戏](https://www.luogu.com.cn/problem/P1064)
3. [P1072 数字三角形](https://www.luogu.com.cn/problem/P1072)

### 题解精选

#### 题解1：作者：Falashiro (赞：16)
- **星级**：5星
- **关键亮点**：详细证明了当 $m \geq \frac{n \times (n+3)}{2}$ 时如何构造解，并给出了无解的条件。代码简洁且高效。
- **个人心得**：通过数学公式的推导，明确了无解和有解的条件，避免了复杂的枚举。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int w=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')w=w*10+c-48,c=getchar();
	return w;
}
int T,n,m;
signed main(){
	T=read();
	while(T--){
		n=read(),m=read();
		if(n*(n+3)/2>m){
			puts("-1");
			continue;
		}
		for(int i=2;i<=n;i++)
			printf("%d ",i);
		printf("%d\n%d\n",m-(n-1)*(n+2)/2,m-1);
	}
	return 0;
}
```

#### 题解2：作者：Rolling_L (赞：6)
- **星级**：4星
- **关键亮点**：通过构造从 $2$ 开始的序列，确保 $m-1$ 无法被表示。代码简单易懂。
- **个人心得**：通过构造不含 $1$ 的序列，确保 $m-1$ 无法被表示，思路清晰。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;int k=m;
		bool is=1;
		for(int i=2;i<=n;i++){
			m-=i;
			if(m<=i){
				is=0;
				break;
			}
		}
		if(is&&m>1){
			for(int i=2;i<=n;i++){
				printf("%d ",i);
			}
			cout<<m<<'\n'<<k-1<<'\n';
		}else{
			cout<<-1<<'\n';
		}
	}
	return 0;
}
```

#### 题解3：作者：JYX0924 (赞：0)
- **星级**：4星
- **关键亮点**：通过构造从 $2$ 开始的序列，确保 $m-1$ 无法被表示。代码简洁且高效。
- **个人心得**：通过构造不含 $1$ 的序列，确保 $m-1$ 无法被表示，思路清晰。

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m;
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>n>>m; int tt=2;
		if(m<(n+3)*n/2) {cout<<-1<<"\n"; continue;}
		for(int i=1;i<=n-1;i++)
		{
			cout<<tt<<" "; tt++;
		}
		cout<<m-(n+2)*(n-1)/2<<"\n"<<m-1<<"\n";
	}
	return 0;
}
```

### 总结

以上题解均通过构造不含 $1$ 的序列来确保 $m-1$ 无法被表示，思路清晰且代码简洁。推荐优先参考这些题解。

---
处理用时：26.02秒
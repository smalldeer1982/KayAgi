# 题目信息

# 双重素数（2021 CoE-II A）

## 题目描述

素数（质数）是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。定义**双重素数**为这样的素数：它的各位数字之和也是一个素数。给定一个闭区间，试确定在该区间内双重素数的个数。

## 说明/提示

**样例说明**

从 $1$ 到 $15$ 共有 $6$ 个素数：$2$，$3$，$5$，$7$，$11$，$13$。前五个素数各自的数字之和也是素数，因此都是双重素数。素数 $13$ 的各位数字之和为 $4$，不是素数，故 $13$ 不是双重素数。

------------


**数据范围**

- Subtask $1$ ：$1 \le L \le R \le 10^2$，$10$ 分。
- Subtask $2$ ：$1 \le L \le R \le 10^4$，$20$ 分。
- Subtask $3$ ：$1 \le L \le R \le 10^6$，$60$ 分。
- Subtask $4$ ：$1 \le L \le R \le 10^8$，$10$ 分。

对于 $100\%$ 的数据，$1 \le T \le 100$。


------------

**提示（数据已经加强）**

最后一个子任务要求你的程序必须具有较高的空间使用效率和时间效率，否则容易超出内存限制或时间限制。

## 样例 #1

### 输入

```
4
3 3
4 4
1 5
1 15```

### 输出

```
1
0
3
5```

# AI分析结果

### 综合分析与结论

本题的核心难点在于如何在给定的较大数据范围（$1 \le L \le R \le 10^8$）内高效地筛选出双重素数，并快速回答多组查询。题解中普遍采用了**线性筛法**（欧拉筛）来筛选素数，并结合**位标记**（如`bitset`或手写位数组）来优化空间使用。此外，**二分查找**被广泛用于快速确定区间内双重素数的个数。

大多数题解的思路较为相似，主要分为以下几步：
1. **筛素数**：使用欧拉筛法筛选出所有素数。
2. **筛双重素数**：对每个素数，计算其数字和，判断是否为素数。
3. **回答查询**：利用二分查找快速确定区间内双重素数的个数。

### 评分较高的题解

#### 1. 作者：王熙文 (5星)
- **关键亮点**：
  - 使用`bitset`优化空间，解决了`bool`数组空间不足的问题。
  - 详细解释了`lower_bound`和`upper_bound`的使用，帮助读者理解二分查找的实现。
  - 提供了两种实现方式，一种是使用`bitset`，另一种是手写位标记，展示了不同的优化思路。
- **个人心得**：
  - 作者提到自己发明了一种存储`bool`数组值的方式，时间和空间都与`bitset`差不多，展示了其对底层优化的深入理解。

**核心代码片段**：
```cpp
void work() { // 欧拉筛 + 筛出双重素数 
    const int n=100000000;
    b[1]=1;
    for(int i=2; i<=n; ++i) {
        if(!b[i]) {
            dp[++k]=i;
        }
        for(int j=1; j<=k && i*dp[j]<=n; ++j) {
            b[dp[j]*i]=1;
            if(!(i%dp[j])) {
                break;
            }
        }
    }
    int k1=k;
    k=0;
    for(int i=1; i<=k1; ++i) {
        int sum=0,t=dp[i];
        while(t) {
            sum+=t%10;
            t/=10;
        }
        if(sushu(sum)) {
            ans[++k]=dp[i];
        }
    }
}
```

#### 2. 作者：_lfxxx_ (4.5星)
- **关键亮点**：
  - 使用`bitset`优化空间，并详细解释了欧拉筛法的实现。
  - 通过前缀和和二分查找的结合，快速回答查询，展示了高效的处理多组查询的方法。
- **个人心得**：
  - 作者提到`bitset`的内存是`bool`数组的$\frac{1}{8}$，时间也比`bool`快一些，帮助读者理解`bitset`的优势。

**核心代码片段**：
```cpp
void Getprime(){
    for(int i=2;i<=n;i++){
        if(!numlist[i])
            prime[++cnt]=i;
        for(int j=1;i*prime[j]<=n;j++){
            numlist[i*prime[j]]=1;
            if(!(i%prime[j]))
                break;
        }
    }
}
```

#### 3. 作者：metaphysis (4星)
- **关键亮点**：
  - 使用位标记优化空间，并详细解释了欧拉筛法的实现。
  - 通过二分查找快速确定区间内双重素数的个数，展示了高效的处理多组查询的方法。
- **个人心得**：
  - 作者提到最后一个子任务主要考察位标记在素数筛中的应用，帮助读者理解位标记的优势。

**核心代码片段**：
```cpp
inline bool isDoublePrime(int n) {
    int ds = 0;
    while (n) ds += (n % 10), n /= 10;
    for (int i = 0; i < 25; i++)
        if (ds == magic[i])
            return true;
    return false;
}
```

### 最优关键思路与技巧
1. **线性筛法（欧拉筛）**：高效筛选素数，时间复杂度为$O(n)$。
2. **位标记优化**：使用`bitset`或手写位数组，大幅减少空间占用。
3. **二分查找**：快速确定区间内双重素数的个数，时间复杂度为$O(\log n)$。

### 可拓展之处
- **类似算法套路**：在处理大范围数据筛选时，线性筛法和位标记优化是常见的组合。类似的题目可以考察其他类型的素数筛选或数字属性筛选。
- **同类型题**：可以扩展到其他数字属性筛选问题，如“三重素数”（数字和、数字积均为素数）等。

### 推荐题目
1. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)
2. [P3912 素数个数](https://www.luogu.com.cn/problem/P3912)
3. [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)

### 个人心得总结
- **调试经历**：多位作者提到在本地调试时遇到时间或空间问题，但在洛谷评测机上通过，展示了评测机性能的重要性。
- **踩坑教训**：部分作者提到直接使用`bool`数组会导致MLE，提醒读者在处理大数据时要注意空间优化。
- **顿悟感想**：通过位标记和`bitset`的优化，作者们展示了底层优化的重要性，帮助读者理解如何在实际问题中应用这些技巧。

---
处理用时：31.70秒
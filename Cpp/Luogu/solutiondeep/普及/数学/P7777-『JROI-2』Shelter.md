# 题目信息

# 『JROI-2』Shelter

## 题目背景

And it's a long way forward        
So trust in me       
I'll give them shelter like you've done for me       
And I know, I'm not alone         
You'll be watching over us       
Until ...        

一个小女孩斜躺在一个驾驶舱的椅子上，长发从肩膀上飘落到地上。     
她的嘴角绽放出微笑，身旁的显示屏写着 “返回 第三行星”。       
她怀里的泰迪熊身上写着她的名字，Rin。

—— [Shelter](https://www.bilibili.com/video/BV1ys41147Gv)

---



## 题目描述

Rin 和爸爸还在地球上时，他们经常玩一个石子游戏。

爸爸摆出了 $n$ 堆石子，这 $n$ 堆石子编号为 $1$ 到 $n$。

游戏规则是这样的，每次 Rin 可以抓取石子，有两种抓取方式：

- 选择一个数 $i$，把第 $i$ 堆石子抓取走，代价为 $i \times p$。
- 选择两个数 $i,j$，把第 $i$ 堆和第 $j$ 堆石子抓走，代价为 $|i-j| \times q$。

其中 $p,q$ 为爸爸提前定好的常数。

Rin 想知道，抓取完所有石子至少需要多少代价。

还剩 1919810114514 秒第三行星的灾难就要降临了，爸爸还需要 1919810114513.7 秒的时间把 Rin 安放到驾驶舱里，并启动机器让 Rin 进入 “Shelter” 里，因此，你只有 0.3 秒的时间帮助 Rin 算出这个结果哦！

## 说明/提示

#### 样例 1 解释

第一组数据：

1. 利用第一个操作，拿走第 $1$ 堆石子，代价为 $1 \times 2=2$。
2. 利用第二个操作，拿走第 $2,3$ 堆石子，代价为 $|2-3| \times 3=3$。
3. 利用第二个操作，拿走第 $4,5$ 堆石子，代价为 $|4-5| \times 3=3$。

最小代价为 $2+3+3=8$。

第二组数据：

1. 利用第一个操作，拿走第 $1$ 堆石子，代价为 $1 \times 1=1$。
2. 利用第一个操作，拿走第 $2$ 堆石子，代价为 $2 \times 1=2$。
3. 利用第二个操作，拿走第 $3,4$ 堆石子，代价为 $|3-4| \times 5=5$。

最小代价为 $1+2+5=8$。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（1 pts）：$p,q =0$。
- Subtask 2（1 pts）：$n=1$。
- Subtask 3（30 pts）：$T \le 5 \times 10^4$，$n \le 5 \times 10^5$。
- Subtask 4（33 pts）：$T \le 10^6$，$n \le 5 \times 10^5$。
- Subtask 5（35 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10^9$，$0 \le p,q \le 100$，$1 \le T \le 10^6$。

附件中的 Extra Example 满足 $T=10^4$，可供调试使用。


-----
Source：[JROI-2 Summer Fun Round](https://www.luogu.com.cn/contest/30241) - T1

Idea&Sol：[一只书虫仔](/user/114914)

Std&Data：[Tony2](/user/171288)

Retest：[Cocoly1990](/user/183026)

## 样例 #1

### 输入

```
2
5 2 3
4 1 5```

### 输出

```
8
8```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地计算抓取所有石子的最小代价，涉及贪心策略和数学推导。大部分题解都采用了类似的思路：通过比较两种抓取方式的代价，找到一个分界点，使得在该点之前使用第一种方式，之后使用第二种方式。不同题解的区别主要在于实现细节和优化程度。

### 所选高星题解

#### 1. 作者：CSP_Sept (5星)
**关键亮点**：
- 思路清晰，直接通过数学推导找到分界点。
- 代码简洁，逻辑明确，易于理解。
- 通过等差数列求和公式优化计算，时间复杂度为 $O(1)$。

**核心代码**：
```cpp
ll x = q / p;
x = (x - 1) / 2;
ll res = n - x;
ll ans = 0;
if(res % 2) x++, res--;
ans = x * p;
ans += (x - 1) * x * p / 2;
ans += (res / 2) * q;
printf("%lld\n", ans);
```
**实现思想**：通过计算分界点 `x`，确保在 `x` 之前使用第一种方式，之后使用第二种方式，并利用等差数列求和公式快速计算总代价。

#### 2. 作者：ricky0916 (4星)
**关键亮点**：
- 通过不等式推导出分界点的范围，进一步优化计算。
- 代码结构清晰，逻辑严谨。
- 通过特判处理边界情况，确保代码的鲁棒性。

**核心代码**：
```cpp
int d,lf=(1ll*(2*n-1)*p-q)/(4*p),rf=(1ll*(2*n+3)*p-q)/(4*p);
if(rf<=0) d=0;
else if(lf>=n/2) d=n/2;
else d=rf;
we(1ll*d*q+1ll*(n-2*d)*(n-2*d+1)/2*p);
```
**实现思想**：通过不等式确定分界点 `d`，确保在 `d` 之前使用第一种方式，之后使用第二种方式，并利用等差数列求和公式快速计算总代价。

#### 3. 作者：int_R (4星)
**关键亮点**：
- 通过二分查找分界点，确保在分界点之前使用第一种方式，之后使用第二种方式。
- 代码简洁，逻辑清晰，易于理解。
- 通过二分查找优化计算，时间复杂度为 $O(\log n)$。

**核心代码**：
```cpp
while(l<r)
{
    mid=(l+r)>>1;
    if(mid-1>=0&&f(mid-1)<f(mid)) r=mid-1;
    else if(mid+1<=n/2&&f(mid+1)<f(mid)) l=mid+1;
    else l=r=mid;
}
printf("%lld\n",f(l));
```
**实现思想**：通过二分查找确定分界点 `mid`，确保在 `mid` 之前使用第一种方式，之后使用第二种方式，并利用等差数列求和公式快速计算总代价。

### 最优关键思路与技巧

1. **数学推导**：通过比较两种抓取方式的代价，找到一个分界点，使得在该点之前使用第一种方式，之后使用第二种方式。
2. **等差数列求和**：利用等差数列求和公式快速计算总代价，优化时间复杂度。
3. **二分查找**：通过二分查找确定分界点，进一步优化计算。

### 可拓展之处

- **类似题目**：可以考虑其他类似的贪心策略题目，如区间覆盖、任务调度等。
- **算法套路**：掌握贪心策略和数学推导的结合，能够解决更多类似的优化问题。

### 推荐题目

1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1966 [NOIP2013 提高组] 火柴排队](https://www.luogu.com.cn/problem/P1966)

### 个人心得总结

- **调试经历**：在处理边界情况时，需要特别注意分界点的奇偶性，确保代码的鲁棒性。
- **踩坑教训**：在计算分界点时，需要注意分母为零的情况，避免程序崩溃。
- **顿悟感想**：通过数学推导和贪心策略的结合，能够高效地解决复杂的优化问题。

---
处理用时：24.70秒
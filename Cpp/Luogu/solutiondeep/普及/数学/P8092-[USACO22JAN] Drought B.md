# 题目信息

# [USACO22JAN] Drought B

## 题目描述

Farmer John 的草地里的草在一场大旱中都干死了。经过数小时的绝望和沉思，Farmer John 想到了一个绝妙的主意，购买玉米来喂养他宝贵的奶牛。

FJ 的 $N$ 头奶牛（$1 \leq N \leq 10^5$）排成一行，队伍中的第 $i$ 头奶牛的饥饿度为 $h_i$（$0 \leq h_i \leq 10^9$）。由于奶牛是社会性动物，她们坚持一起进食，FJ 降低奶牛饥饿度的唯一方法是选择两头相邻的奶牛 $i$ 和 $i+1$ 并分别喂她们一袋玉米，令她们的饥饿度各减少 1。

FJ 想将他的奶牛喂至所有的奶牛都具有相同的非负饥饿度。请帮助 FJ 求出他喂奶牛达到上述状态所需的最少玉米袋数，或者如果不可能达到，输出 $-1$。

## 说明/提示

【样例解释】

对于第一个子测试用例，给奶牛 $2$ 和 $3$ 各两袋玉米，然后给奶牛 $1$ 和 $2$ 各五袋玉米，可以使得所有奶牛的饥饿度均为 $3$。

对于第二个子测试用例，给奶牛 $1$ 和 $2$ 各两袋玉米，奶牛 $2$ 和 $3$ 各两袋玉米，奶牛 $4$ 和 $5$ 各两袋玉米，奶牛 $5$ 和 $6$ 各两袋玉米，可以使得所有奶牛的饥饿度均为 $2$。

对于余下的子测试用例，均不可能使得奶牛们的饥饿度相等。

【数据范围】

- 测试点 2 的所有子测试用例满足 $N \leq 3$ 以及 $h_i\le 100$。

- 测试点 3-8 的所有子测试用例满足 $N\le 100$ 以及 $h_i\le 100$。

- 测试点 9-14 的所有子测试用例满足 $N\le 100$。

- 测试点 15 没有额外限制。

- 此外，测试点 3-5 和 9-11 中的 $N$ 均为偶数，测试点 6-8 和 12-14 中的 $N$ 均为奇数。

## 样例 #1

### 输入

```
5
3
8 10 5
6
4 6 4 4 6 4
3
0 1 0
2
1 2
3
10 9 9```

### 输出

```
14
16
-1
-1
-1```

# AI分析结果

### 综合分析与结论

该题的核心在于通过相邻奶牛的饥饿度调整，使得所有奶牛的饥饿度相等，且调整次数最少。题解中主要涉及以下几种思路：

1. **贪心策略**：通过正序和倒序扫描数组，逐步调整相邻奶牛的饥饿度，确保最终所有奶牛的饥饿度相等。这种策略的优势在于简单直观，但需要注意边界条件和调整次数的计算。
  
2. **差分数组**：通过差分数组来记录相邻奶牛的饥饿度差异，并通过调整差分数组来达到目标。这种方法的优势在于能够更清晰地分析问题，但实现起来较为复杂。

3. **二分搜索**：通过二分搜索来确定最终的饥饿度，然后检查是否能够通过调整达到该值。这种方法的优势在于能够处理较大数据范围，但需要额外的检查逻辑。

4. **数学公式推导**：通过数学公式推导出最终的饥饿度，并检查是否满足条件。这种方法的优势在于能够直接计算出结果，但推导过程较为复杂。

### 所选高星题解

#### 1. 作者：lsj2009 (5星)
- **关键亮点**：通过数学公式推导出最终的饥饿度，并检查是否满足条件。该方法思路清晰，代码简洁，且能够处理较大数据范围。
- **个人心得**：作者提到“十年 OI 一场空，不开 `long long` 见祖宗”，强调了数据类型选择的重要性。

```cpp
if(n&1) {
    int x=0,ans=0;
    for(int i=1;i<=n;i++) //根据公式计算 x
        x+=(i&1? 1:-1)*h[i];
    if(x<0) return -1; //x 为负
    for(int i=1;i<n;i++) {
        f[i]=h[i]-f[i]-x; ans+=f[i]; if(f[i]<0) return -1; //计算 f[i] 并累加，同时 f[i] 必须大于等于 0，否则无解
    }
    return ans<<1; //由于 f[i] 为“第 i 头和 i+1 头的进食量”，所以需*2
} 
```

#### 2. 作者：ztlh (4星)
- **关键亮点**：通过正反扫描数组，逐步调整相邻奶牛的饥饿度，确保最终所有奶牛的饥饿度相等。该方法实现简单，且能够处理较大数据范围。
- **个人心得**：作者提到“一定要开 `long long`，不然会 `WA`”，强调了数据类型选择的重要性。

```cpp
while(flag==1){
    flag=0;
    for(int i=2;i<n;i++) //正扫
        if(h[i]>h[i-1]){
            flag=1;
            int d=h[i]-h[i-1];
            h[i]-=d;
            h[i+1]-=d;
            if(h[i]<0||h[i+1]<0) {flag=-1;break;} //这个不加就会卡在12~14点
        }
    if(flag!=1) break; //同上
    for(int i=n-1;i>1;i--) //反扫
        if(h[i]>h[i+1]){
            flag=1;
            int d=h[i]-h[i+1];
            h[i]-=d;
            h[i-1]-=d;
            if(h[i]<0||h[i-1]<0) {flag=-1;break;} //同上
        }
}
```

#### 3. 作者：CANTORSORT (4星)
- **关键亮点**：通过正序和倒序扫描数组，逐步调整相邻奶牛的饥饿度，确保最终所有奶牛的饥饿度相等。该方法实现简单，且能够处理较大数据范围。
- **个人心得**：作者提到“FJ（和他的奶牛）可真惨……”，强调了问题背景的趣味性。

```cpp
for(int j=1;j<3;j++) //正序变化与倒序变化
{
    for(int i=2;i<n;i++)
    {
        if(h[i]>h[i-1])
        {
            int differ=h[i]-h[i-1];
            ans+=differ<<1; //每次喂两袋
            h[i+1]-=differ;
            h[i]=h[i-1]; //同时变化
        }
    }
    if(h[n]>h[n-1])
        return -1; //无解
    reverse(h+1,h+1+n); //反转
}
```

### 最优关键思路或技巧

1. **贪心策略**：通过正序和倒序扫描数组，逐步调整相邻奶牛的饥饿度，确保最终所有奶牛的饥饿度相等。这种策略的优势在于简单直观，但需要注意边界条件和调整次数的计算。

2. **数学公式推导**：通过数学公式推导出最终的饥饿度，并检查是否满足条件。这种方法的优势在于能够直接计算出结果，但推导过程较为复杂。

### 可拓展之处

1. **类似问题**：可以拓展到其他需要通过调整相邻元素来达到某种目标的问题，如数组排序、数组平衡等。
  
2. **算法优化**：可以通过差分数组或二分搜索来进一步优化算法，提高处理大数据范围的效率。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得总结

- **数据类型选择**：在处理大数据范围时，务必选择合适的数据类型，如 `long long`，以避免溢出问题。
  
- **边界条件**：在实现算法时，务必注意边界条件的处理，如数组的首尾元素，以避免出现错误。

- **优化策略**：在实现算法时，可以通过正反扫描、差分数组等策略来优化算法，提高处理效率。

---
处理用时：34.47秒
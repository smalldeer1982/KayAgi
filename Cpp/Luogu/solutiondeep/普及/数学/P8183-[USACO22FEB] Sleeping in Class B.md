# 题目信息

# [USACO22FEB] Sleeping in Class B

## 题目描述

奶牛 Bessie 最近很高兴能够重返线下课堂！不幸的是，她的老师 Farmer John 讲课非常无聊，因此她经常在课堂上睡着。  
Farmer John 注意到 Bessie 在课堂上没有专心听讲。他让班上的另一位学生 Elsie 记录 Bessie 在每节课上睡着的次数。总共有 $N$ 节课（$1 \leq N \leq 10^5$），Elsie 记录到 Bessie 在第 $i$ 节课上睡着了 $a_i$ 次（$0 \leq a_i \leq 10^6$）。所有课程中 Bessie 睡着的总次数不超过 $10^6$。

Elsie 对 Bessie 感到非常竞争，她希望让 Farmer John 觉得 Bessie 在每节课上睡着的次数是一致的——让问题看起来完全是 Bessie 的错，而与 Farmer John 有时无聊的讲课无关。Elsie 修改记录的唯一方式是将两节相邻的课合并。例如，如果 $a = [1,2,3,4,5]$，那么如果 Elsie 合并第二和第三节课，记录将变为 $[1,5,4,5]$。

请帮助 Elsie 计算她需要对记录进行的最少修改次数，以使记录中的所有数字相等。

## 说明/提示

对于第一个测试用例，Elsie 可以通过 3 次修改将记录改为全为 $3$：
```
   1 2 3 1 1 1
-> 3 3 1 1 1
-> 3 3 2 1
-> 3 3 3
```

对于第二个测试用例，Elsie 可以通过 2 次修改将记录改为全为 $7$：
```
   2 2 3
-> 2 5
-> 7
```

对于最后一个测试用例，Elsie 不需要进行任何操作，因为记录已经由相同的数字组成。

## 样例 #1

### 输入

```
3
6
1 2 3 1 1 1
3
2 2 3
5
0 0 0 0 0```

### 输出

```
3
2
0```

# AI分析结果

### 综合分析与结论

本题的核心在于通过合并相邻元素，使得最终数组中的所有元素相等，且合并次数最少。所有题解都基于一个关键观察：**数组的总和不变**，因此最终每个元素的值必须是总和的约数。题解的主要思路是枚举总和的约数，并检查是否可以通过合并操作将数组分割成若干段，每段的和等于该约数。

大部分题解的时间复杂度为 $O(T \cdot n \cdot m)$，其中 $m$ 是总和的约数个数。虽然约数个数在 $10^6$ 范围内可能较大，但由于总和限制在 $10^6$，实际运行时间是可接受的。

### 所选高星题解

#### 1. 作者：Zirnc (5星)
**关键亮点**：
- 思路清晰，直接从总和的约数入手，逐步验证是否可以通过合并操作得到目标数组。
- 代码简洁，逻辑明确，易于理解。
- 时间复杂度分析准确，且代码实现高效。

**核心代码**：
```cpp
for (int i = n; i >= 1; i--) { // r
    if (sum % i != 0) continue;
    int cur = 0;
    bool flag = 1;
    for (int j = 0; j < n; j++) {
        cur += a[j];
        if (cur > sum / i) {
            flag = 0;
            break;
        } else if (cur == sum / i) {
            cur = 0;
        }
    }
    if (flag) {
        ans = n - i;
        break;
    }
}
```
**核心思想**：从大到小枚举可能的合并后数组长度 $i$，检查是否可以将数组分割成 $i$ 段，每段的和等于 $\frac{sum}{i}$。

#### 2. 作者：lnwhl (4星)
**关键亮点**：
- 思路与Zirnc类似，但代码实现略有不同，同样高效。
- 代码结构清晰，变量命名合理，易于理解。
- 提供了详细的时间复杂度分析。

**核心代码**：
```cpp
for (int j = n; j >= 1; j--) { // 穷举合并后的数列长度
    if (sum % j == 0) {
        sumT = sum / j; // 每个数的值
        int pre = 0; bool ok = 1;
        for (int k = 1; k <= n; k++) { // 判断是否可行
            pre += a[k];
            if (pre > sumT) { ok = 0; break; }
            else if (pre == sumT) pre = 0;
        }
        if (ok == 1) { cout << n - j << endl; break; }
    }
}
```
**核心思想**：从大到小枚举合并后的数组长度 $j$，检查是否可以将数组分割成 $j$ 段，每段的和等于 $\frac{sum}{j}$。

#### 3. 作者：江户川コナン (4星)
**关键亮点**：
- 提供了详细的思路分析，特别是对贪心策略的解释。
- 代码结构清晰，逻辑明确，易于理解。
- 提供了特判数组本身已经相等的情况，优化了代码效率。

**核心代码**：
```cpp
int find(int k) {
    int ans = 0, sum = 0, flag = true;
    for (int i = 1; i <= n; i++) {
        if (!flag) ans += 1;
        sum += a[i];
        if (sum == k) {
            sum = 0;
            flag = true;
            continue;
        }
        if (sum > k) return 0;
        flag = false;
    }
    return ans;
}
```
**核心思想**：通过贪心策略，从左到右累加数组元素，检查是否可以将数组分割成若干段，每段的和等于 $k$。

### 最优关键思路与技巧

1. **总和不变**：无论怎么合并，数组的总和不变，因此最终每个元素的值必须是总和的约数。
2. **枚举约数**：通过枚举总和的约数，检查是否可以通过合并操作将数组分割成若干段，每段的和等于该约数。
3. **贪心策略**：从左到右累加数组元素，检查是否可以将数组分割成若干段，每段的和等于目标值。

### 可拓展之处

- **类似问题**：类似的问题包括分割数组使得每段满足特定条件，如每段和相等、每段最大值最小等。
- **算法套路**：枚举总和的约数，并通过贪心策略检查是否可行，这种思路可以应用于其他需要分割数组的问题。

### 推荐题目

1. [P1462D - Add to Neighbour and Remove](https://www.luogu.com.cn/problem/CF1462D)
2. [P1045 - 合并果子](https://www.luogu.com.cn/problem/P1045)
3. [P1090 - 合并果子（加强版）](https://www.luogu.com.cn/problem/P1090)

### 个人心得总结

- **调试经历**：在实现过程中，需要注意边界条件，如数组本身已经相等的情况，或者总和为0的情况。
- **踩坑教训**：在枚举约数时，从大到小枚举可以减少不必要的计算，提高效率。
- **顿悟感想**：通过枚举总和的约数，可以将问题转化为一个简单的贪心问题，大大简化了问题的复杂度。

---
处理用时：31.39秒
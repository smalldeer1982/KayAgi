# 题目信息

# 「WHOI-1」数列计数

## 题目背景

> 不再拥有，数列陪伴我。



## 题目描述

这种数列满足下面这一条神奇的性质：

- $a_0=0$。
- $\forall i\in[1,n]$ 均有 $a_i=a_{i-1}+x$ 或者 $a_i=a_{i-1}+y$。
- $\forall i\in[1,n],p \nmid a_i$。

求这样的 $\{a\}_0^{n}$ 的数量。答案对 $10^9+7$ 取模。

两个数列不同，当且仅当他们有一个下标存储的元素不同。

## 说明/提示

样例 #1：

这样的 $a$ 有 $[0,1,2,4],[0,2,4,5]$。

样例 #2、#3：

本来可爱的 Otm 已经写好了上万页的样例解释了，但是更可爱的 miku 把它删掉了所以 Otm 不想再写一遍了。

---

**本题采用 $\texttt{Subtask}$ 计分方式，只有通过该 $\texttt{Subtask}$ 的所有测试点才能得到该点的分数。**

| $\texttt{Subtask}$ 编号 | 特殊限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | $\sum n\leq20$ | 10 |
| 2 | $p\leq10^3$ | 30 |
| 3 | $xy,p$ 互质 | 10 |
| 4 | 无 | 50 |

对于所有测试数据，$1\leq T\leq10^3,1\leq\sum n\leq10^4, 1\leq x,y,p\leq10^9$，输入均为正整数。

## 样例 #1

### 输入

```
3
3 3 1 2
11 45 14 19
9876 10 114514 191981```

### 输出

```
2
1688
426554662
```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）来计算满足特定条件的数列数量。大多数题解都采用了类似的DP思路，即定义状态 `dp[i][j]` 表示进行了 `i` 次 `+x` 和 `j` 次 `+y` 操作后的方案数，并通过状态转移方程 `dp[i][j] = dp[i-1][j] + dp[i][j-1]` 来计算。难点在于如何优化空间复杂度，避免MLE（内存超限）。多数题解通过滚动数组优化，将空间复杂度从 `O(n^2)` 降低到 `O(n)`。

### 所选高星题解

#### 1. **作者：幸存者 (赞：20)**  
**星级：★★★★★**  
**关键亮点：**  
- 清晰地定义了DP状态和转移方程，并详细解释了滚动数组的优化思路。
- 代码简洁且易于理解，处理了 `x == y` 的特殊情况。
- 通过 `i & 1` 实现滚动数组，减少了空间复杂度。

**核心代码：**
```cpp
dp[0][0] = 1;
for (int i = 0; i <= n; i++) for (int j = 0; i + j <= n; j++) {
    if (i == 0 && j == 0) continue;
    if ((1ll * i * x + 1ll * j * y) % p != 0) {
        if (i == 0) dp[i & 1][j] = dp[i & 1][j - 1];
        else if (j == 0) dp[i & 1][j] = dp[i & 1 ^ 1][j];
        else dp[i & 1][j] = (dp[i & 1 ^ 1][j] + dp[i & 1][j - 1]) % mod;
    }
    else dp[i & 1][j] = 0;
    if (i + j == n) ans = (ans + dp[i & 1][j]) % mod;
}
```

#### 2. **作者：Otomachi_Una_ (赞：10)**  
**星级：★★★★**  
**关键亮点：**  
- 官方题解，思路清晰，分Subtask给出了不同的解法。
- 对于 `x == y` 的情况进行了特殊处理，直接判断数列是否合法。
- 使用了滚动数组优化，代码简洁。

**核心代码：**
```cpp
if (x == y) {
    bool flag = false;
    for (int i = 1; i <= n; i++) if (1ll * i * x % p == 0) {
        flag = true;
        break;
    }
    cout << (flag ? 0 : 1) << endl;
    continue;
}
```

#### 3. **作者：TempestJueMu (赞：3)**  
**星级：★★★★**  
**关键亮点：**  
- 详细解释了DP状态转移方程的推导过程，适合初学者理解。
- 处理了 `x == y` 的特殊情况，并提供了滚动数组的实现。
- 代码简洁，注释清晰。

**核心代码：**
```cpp
if (x == y) {
    fo(i,1,n) if (i * x % p == 0) { printf("0\n"); return; }
    printf("1\n"); return;
}
```

### 最优关键思路与技巧

1. **滚动数组优化**：通过 `i & 1` 实现滚动数组，将空间复杂度从 `O(n^2)` 降低到 `O(n)`，避免了MLE。
2. **特殊情况处理**：当 `x == y` 时，直接判断数列是否合法，避免不必要的计算。
3. **状态转移方程**：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`，确保每次操作只与前一个状态相关。

### 可拓展之处

- **类似题目**：可以扩展到其他类似的计数问题，如路径计数、组合数计算等。
- **优化技巧**：滚动数组的优化思路可以应用于其他需要降低空间复杂度的DP问题。

### 推荐相似题目

1. **P1002 过河卒**（路径计数问题，使用DP）
2. **P1048 采药**（背包问题，使用DP）
3. **P1057 传球游戏**（状态转移DP，滚动数组优化）

### 个人心得总结

- **调试经历**：在处理 `x == y` 的特殊情况时，容易忽略某些边界条件，导致错误。建议在编写代码时，先处理特殊情况，再进行通用逻辑。
- **踩坑教训**：滚动数组的实现需要注意状态的更新顺序，避免覆盖未使用的状态。

---
处理用时：26.54秒
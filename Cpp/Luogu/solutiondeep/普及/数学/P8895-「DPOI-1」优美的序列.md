# 题目信息

# 「DPOI-1」优美的序列

## 题目背景

#### Update on 2022.12.18：新增一组针对 @[zhuoxingmu](https://www.luogu.com.cn/user/421155) 的 Hack 数据，放置于 #21，分值为 $5$ 分。
#### Update on 2022.12.18：新增一组针对 @[大眼仔Happy](https://www.luogu.com.cn/user/537046) 的 Hack 数据，放置于 #22，分值为 $5$ 分。
------------
不可以，总司令。

## 题目描述

总司令给你一个长为 $n$ 的序列 $a$。

他认为这个 $a$ 现在也许不够优美，他希望将其重排为一个 $a'$，使之变得优美。

我们称一个长为 $n$ 的序列 $a$ 优美，当且仅当 $\exists i \in [1,n]$，满足：

- $\forall j \in [1, i)$，$a_j > a_{j + 1}$。
- $\forall j \in (i, n]$，$a_j > a_{j - 1}$。

他命令你求出 $a$ 经过重排可以得到多少个不同的 $a'$。由于结果可能很大，你只需要求出结果对 $p$ 取模的值。

由于一个固定的 $a$ 太无趣了，于是他给你 $m$ 次修改，每次修改形如 `x k`，表示令 $a_x \leftarrow k$。你需要在每次修改后求出当前的答案。

## 说明/提示

#### 样例 #1 解释
对于初始状态，满足条件的 $a'$ 有 $[2, 1, 2, 3], [3, 2, 1, 2]$，共 $2$ 个。

对于第一次修改后的 $a = [1, 2, 4, 3]$，满足条件的 $a'$ 有 $[1, 2, 3, 4], [2, 1, 3, 4], [3, 1, 2, 4], [4, 1, 2, 3], [3, 2, 1, 4], [4, 2, 1, 3], [4, 3, 1, 2], [4, 3, 2, 1]$，共 $8$ 个。
#### 样例 #2 解释
该样例满足测试点 $15 \sim 20$ 的限制。
#### 数据范围
| 测试点编号 | $n \leq$ | $m \leq$ | 特殊条件 |
| :------: | :------: | :------: | :------: |
| $1 \sim 2$ | $10$ | $10$ | 无 |
| $3 \sim 4$ | $100$ | $100$ | 无 |
| $5 \sim 6$ | $10^3$ | $10^3$ | 无 |
| $7 \sim 10$ | $10^5$ | $10^5$ | 无 |
| $11 \sim 12$ | $5 \times 10^5$ | $0$ | $a$ 为一个**排列** |
| $13 \sim 14$ | $5 \times 10^5$ | $0$ | 无 |
| $15 \sim 20$ | $5 \times 10^5$ | $5\times 10^5$ | 无 |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$0 \leq m \leq 5 \times 10^5$，$2 \leq p \leq 10^9$，$1 \leq a_i, k, x \leq n$。

## 样例 #1

### 输入

```
4 1 998244353
1 2 2 3
3 4```

### 输出

```
2
8```

## 样例 #2

### 输入

```
见下发文件 sequence2.in```

### 输出

```
见下发文件 sequence2.out```

# AI分析结果

### 综合分析与结论

本题的核心在于通过重排序列，使其满足“优美”条件，即存在一个波谷，使得序列从波谷向两边严格单调递增。所有题解都围绕如何判断序列是否满足条件以及如何计算满足条件的排列数展开。主要思路包括：

1. **条件判断**：
   - 最小值必须唯一，否则无解。
   - 任何数的出现次数不能超过2次，否则无解。

2. **排列数计算**：
   - 对于出现次数为1的数，可以选择放在波谷的左侧或右侧，贡献为2。
   - 对于出现次数为2的数，必须分别放在波谷的两侧，贡献为1。
   - 最终答案为2^(出现次数为1的数的个数 - 1)。

3. **数据结构**：
   - 使用`multiset`或线段树来维护序列的最小值和出现次数。
   - 通过桶或哈希表记录每个数的出现次数。

### 所选高星题解

#### 1. 作者：Leasier (5星)
- **关键亮点**：
  - 思路清晰，详细解释了如何通过构造满足条件的序列来计算排列数。
  - 使用`multiset`动态维护最小值和出现次数，时间复杂度为O((n + m) log n)。
  - 代码简洁，可读性强。

- **核心代码**：
  ```cpp
  inline void add(int x){
      cnt[x]++;
      s.insert(x);
      if (cnt[x] == 1){
          cnt1++;
      } else if (cnt[x] == 2){
          cnt1--;
      } else if (cnt[x] == 3){
          cnt2++;
      }
  }

  inline void output(){
      if (cnt2 > 0 || cnt[*s.begin()] > 1){
          printf("0\n");
      } else {
          printf("%d\n", power[cnt1 - 1]);
      }
  }
  ```

#### 2. 作者：Micnation_AFO (4星)
- **关键亮点**：
  - 使用权值线段树维护序列的最小值和出现次数，适合大规模数据处理。
  - 详细解释了无解条件及排列数计算方式。
  - 代码实现较为复杂，但思路清晰。

- **核心代码**：
  ```cpp
  void change(int p, int x, int v) {
      if (t[p].l == t[p].r) {
          t[p].sum += v, t[p].dat += v;
          if (t[p].sum == 1) t[p].num = 1;
          else t[p].num = 0;
          return;
      }
      int mid = (t[p].l + t[p].r) >> 1;
      if (x <= mid) change(p << 1, x, v);
      if (x > mid) change((p << 1) | 1, x, v);
      t[p].sum = t[p << 1].sum + t[(p << 1) | 1].sum;
      t[p].num = t[p << 1].num + t[(p << 1) | 1].num;
      t[p].dat = max(t[p << 1].dat, t[(p << 1) | 1].dat);
  }
  ```

#### 3. 作者：大眼仔Happy (4星)
- **关键亮点**：
  - 通过桶记录每个数的出现次数，判断无解条件。
  - 使用线段树维护最小值，优化了求最小值的效率。
  - 代码实现较为简洁，思路清晰。

- **核心代码**：
  ```cpp
  ll calc() {
      if (s3) return 0;
      ll Min = LONG_LONG_MAX;
      for (int i = 1; i <= n; i++) Min = min(Min, a[i]);
      if (tong[Min] != 1) return 0;
      return QuickPow(2, s1 - 1);
  }
  ```

### 最优关键思路与技巧

1. **数据结构选择**：使用`multiset`或线段树来动态维护序列的最小值和出现次数，能够高效处理大规模数据。
2. **条件判断与排列数计算**：通过判断最小值的唯一性和数的出现次数，快速确定无解条件，并通过2^(出现次数为1的数的个数 - 1)计算排列数。
3. **预处理幂次**：预处理2的幂次，避免重复计算，提高效率。

### 可拓展之处

- **类似题目**：可以扩展到其他需要动态维护序列最小值或出现次数的题目，如求序列的中位数、众数等。
- **算法套路**：类似的多重集合维护和动态更新技巧可以应用于其他需要频繁修改和查询的序列问题。

### 推荐题目

1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

### 个人心得摘录

- **调试经历**：大眼仔Happy提到在计算`s3`时犯了一个错误，导致代码被Hack，提醒我们在实现时要注意细节。
- **顿悟感想**：Leasier通过构造满足条件的序列，清晰地解释了排列数的计算方式，体现了从问题本质出发的思维方式。

---
处理用时：32.81秒
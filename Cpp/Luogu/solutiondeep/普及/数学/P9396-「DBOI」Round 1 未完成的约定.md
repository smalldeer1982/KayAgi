# 题目信息

# 「DBOI」Round 1 未完成的约定

## 题目背景

>  _生活快得停不下来_\
_璀璨的也最终衰败_\
_他感到负荷已过载_\
_车窗外_\
_天上大朵云彩_\
_追随他的速度跑得飞快_\
_不由自主比赛_\
——《笨小孩的道歉信》

不管多少个日夜，为你一直唱。

## 题目描述

$m^3$ 可以表示为 $m$ 个连续奇数的和 $(m \geqslant 1)$：  
$$
1^3 = 1\\
2^3 = 3 + 5\\
3^3 = 7 + 9 + 11\\
4^3 = 13 + 15 + 17 + 19\\
5^3 = 21 + 23 + 25 + 27 + 29\\
\cdots\cdots
$$

在左昂对奇数的狂热崇拜的影响下，苏信好写出来的歌只会是奇数长度。显然歌曲的长度不能是负数。

对于一首长度为 $x$ 的歌，它的悦耳值 $f(x)$ 满足将 $f(x)^3$ 按照上面的规律表示出来后，$x$ 是其中的一个加数。例如 $f(21) = 5, f(11) = 3,f(3) = 2$。

第二天，左昂前来参观，发现苏信好只写出来了一首歌，鄙夷不已。苏信好怒从心起，写出了以 $1\sim k$ 内所有长度为奇数的歌。

现在左昂想要知道苏信好所有歌的悦耳值之和，以预估他的狂热崇拜的效果。即：给定一个正奇数 $k(1\leqslant k< 2^{64})$，求 $s = \sum\limits_{i = 1}^{\frac{k + 1}{2}} f(2\times i - 1)$，即 $f(1) + f(3) + f(5) + \cdots +f(k)$。  

由于苏信好实在太生气，写出来的歌的悦耳值可能十分之大，你只需要输出 $s\bmod{10^9 + 7}$ 的结果。

**本题有多组数据。**

## 说明/提示


|  Subtask |  数据范围  | 分值 |
|:----:|:----:|:----:|
| Subtask 1 | $T=1$，$k< 2^{25}$ | $20$ |
| Subtask 2 | $T\leq 5$，$k< 2^{48}$ | $30$ |
| Subtask 3 | $T\leq 10^6$，$k < 2^{48}$ | $40$ |
| Subtask 4 | $T\leq 3\times 10^6$，$k < 2^{64}$ | $10$ |

**请注意常数因子对程序效率的影响。**

## 样例 #1

### 输入

```
1 114514 1919810 19950501 5```

### 输出

```
35```

## 样例 #2

### 输入

```
5 231421 523434 31243 5```

### 输出

```
50
30
40
55
35```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效计算给定奇数 \( k \) 的悦耳值之和 \( s \)。题解中主要采用了数学推导和优化算法来解决问题。以下是对各题解的要点总结与对比：

1. **数学推导**：所有题解都基于 \( m^3 \) 可以表示为 \( m \) 个连续奇数的和这一性质，推导出 \( f(x) \) 的表达式，并通过数学公式简化计算。
2. **优化策略**：不同题解在优化策略上有所差异，有的通过预处理前缀和、二分查找、以及利用逆元等方式来减少计算复杂度。
3. **实现细节**：在处理大数时，题解中提到了使用 `__int128`、`long double` 等数据类型，以及如何避免溢出和精度问题。

### 所选高星题解

#### 1. 作者：liuliucy (★★★★☆)
- **关键亮点**：
  - 通过数学推导直接求解 \( p = \left \lfloor \frac{\sqrt{4k-3} +1}{2} \right \rfloor \)，避免了复杂的循环计算。
  - 使用 `__int128` 处理大数，并通过优化取模运算减少常数复杂度。
  - 详细解释了如何处理数据范围和取模问题，具有较强的实用性。
- **代码核心思想**：
  - 计算 \( p \) 并通过公式 \( \frac{(p-1)p(2p-1)}{6} + \frac{k-(p^2-p+1)+2}{2} p \) 直接求解答案。

```cpp
ull p=(sqrt((long double)4*k-3)+1)/2;
__int128 ans;
ull a=p-1,b=p,c=2*p-1;		
if(a%3==0)a/=3;
else if(b%3==0)b/=3;
else c/=3;
if(a%2==0)a/=2;
else if(b%2==0)b/=2;
else c/=2;
ans=(__int128)a*b%md*c%md;
p%=md;
ull len=(k%md*ppp%md-(((p*p%md-p%md)+md)%md+1)%md*ppp%md+md+1)%md;
p%=md;
(ans+=len*p%md)%=md;
```

#### 2. 作者：StayAlone (★★★★☆)
- **关键亮点**：
  - 通过二分查找优化了 \( l \) 的计算，时间复杂度为 \( O(\log k) \)。
  - 使用预处理前缀和和逆元来进一步优化平方和的计算。
  - 详细证明了 \( l = \operatorname{round}(\sqrt{k + 1}) \)，并提供了严格的数学推导。
- **代码核心思想**：
  - 通过二分查找确定 \( l \)，并使用公式 \( \frac{l(l - 1)(2l - 1)}{6} + l \times (\frac{k - 1}{2} + 1 - \frac{l(l - 1)}{2}) \) 计算答案。

```cpp
ull l = round(sqrtl(k + 1));
ull ans = (l * (l - 1) / 2 % mod) * ((2 * l - 1) / 3 % mod) % mod;
ans = (ans + l * ((k - 1) / 2 + 1 - l * (l - 1) / 2) % mod) % mod;
```

#### 3. 作者：y_kx_b (★★★★☆)
- **关键亮点**：
  - 将问题转化为求 \( x \) 所在的层数，并通过公式 \( \frac{t(t+1)(2t+1)}{6} \) 计算前 \( t \) 层的和。
  - 使用 `sqrtl` 提高精度，避免 `sqrt` 的精度问题。
  - 代码简洁，逻辑清晰，易于理解。
- **代码核心思想**：
  - 通过公式 \( t = \frac{-1 \pm \sqrt{1+8x}}{2} \) 计算层数，并使用公式 \( \frac{t(t+1)(2t+1)}{6} \) 计算前 \( t \) 层的和。

```cpp
ull t = (sqrtl((long double)k * 8 + 1) - 1) / 2;
ull r = sum(t);
ll ans = sum2(t);
if(r != k) (ans += (t + 1) * ((k - r) % mod)) %= mod;
```

### 最优关键思路与技巧

1. **数学公式推导**：通过数学推导直接求解 \( p \) 或 \( l \)，避免复杂的循环计算。
2. **优化算法**：使用二分查找、预处理前缀和、逆元等优化策略，减少计算复杂度。
3. **大数处理**：使用 `__int128`、`long double` 等数据类型，以及优化取模运算，避免溢出和精度问题。

### 可拓展之处

1. **类似算法套路**：在处理大数时，可以考虑使用高精度计算或分治策略。
2. **同类型题目**：可以尝试解决其他涉及数学推导和优化算法的题目，如计算斐波那契数列、组合数等。

### 推荐题目

1. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)
3. [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)

### 个人心得总结

- **调试经历**：在处理大数时，需要注意数据类型的选取和溢出问题，使用 `__int128` 或 `long double` 可以提高精度。
- **踩坑教训**：在优化算法时，需要仔细考虑每一步的计算复杂度，避免不必要的计算。
- **顿悟感想**：通过数学推导和优化算法，可以显著提高程序的效率，减少运行时间。

---
处理用时：32.62秒
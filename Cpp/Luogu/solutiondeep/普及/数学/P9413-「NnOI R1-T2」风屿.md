# 题目信息

# 「NnOI R1-T2」风屿

## 题目背景

「与风为名，屿之齐鸣。」——风屿

## 题目描述

风屿是一块 $ n $ 行，$ m $ 列的群岛，第 $ i $ 行第 $  j $ 列记为 $ (i,j) $。

风屿的重力系统很奇怪，$ (i,j) $ 的重力系数 $ g_{i,j}=a_i+b_j $。$ a,b $ 是两个已知的长度分别为 $ n,m $ 的数组。

我们定义岛 $ (x,y) $ 和 $ (z,w) $ **相邻**当且仅当 $ |x-z|+|y-w|=1 $，定义 $ (x,y) $ 和 $ (z,w) $ **连通**当且仅当两种情况至少有一种满足：

* $ (x,y),(z,w) $ 相邻，且 $ g_{x,y}=g_{z,w} $。

* 存在另一个岛 $ (u,v) $ 使得 $ (x,y) $ 和 $ (u,v) $ 连通且 $ (u,v) $ 和 $ (z,w) $ 连通，也就是说，连通关系**具有传递性**。

我们定义无序互异的岛集 $ \{(x_i,y_i)\} $ 为**同色连通块**，当且仅当岛集中任意两岛连通。

找到最大的同色连通块，并求出大小和这样的块的个数。

## 说明/提示

### 样例解释

对于样例 $ 1 $：

对于第 $ 1 $ 组测试数据，重力系数依次如下：

```
2 3 4 5
3 4 5 6
3 4 5 6
```

```
2 3 4 5
* # ? .
* # ? .
```

标记符号的为最大的同色连通块，大小为 $ 2 $，共 $ 4 $ 个。

### 数据范围

对于 $ 20\% $ 的数据，$ n,m \le 10^3 $。

对于另 $ 20\% $ 的数据，所有 $ b_i $ 相等。

对于另 $ 20\% $ 的数据，第二问答案一定为 $ 1 $。

对于另 $ 20\% $ 的数据，$ T=1 $，这四档部分分表示的测试点集合互不包含。

对于 $ 100\% $ 的数据，$ 1 \le T \le 5 $，$ 1 \le n,m \le 10^5 $，$ 1 \le a_i,b_i \le 10^9 $。

### 题目来源

| 项目 | 人员 |
|:-:|:-:|
| idea | Kevin0501 |
| std | Kevin0501
| data | EstasTonne |
| check | EstasTonne |
| solution | Kevin0501 |

## 样例 #1

### 输入

```
3
3 4
1 2 2
1 2 3 4
4 5
1 2 2 3
2 3 3 3 4
6 7
1 1 2 2 3 4
1 2 2 2 3 3 3```

### 输出

```
2 4
6 1
6 4```

# AI分析结果

### 综合分析与结论

本题的核心在于通过分析矩阵的构造方式，发现最大连通块的性质，进而将问题转化为求两个数组的最长连续相同子段的长度及其个数。所有题解都基于这一思路，通过遍历数组来统计最长连续相同子段的长度和个数，最终通过乘法原理得到最大连通块的大小和个数。

### 所选高星题解

#### 1. 作者：___w (5星)
**关键亮点**：
- 思路清晰，直接指出最大连通块为矩形，并通过分析矩阵的构造方式，将问题转化为求两个数组的最长连续相同子段的长度和个数。
- 代码简洁，逻辑清晰，使用了`long long`避免溢出问题。
- 通过遍历数组统计最长连续相同子段的长度和个数，时间复杂度为$O(T(n+m))$，非常高效。

**核心代码**：
```cpp
for (int i = 1; i <= n; ++i) {
    cin >> a[i];
    if (i == 1) continue;
    if (a[i] == a[i-1]) ++len;
    else len = 1;
    if (len > l) l = len, c = 1;
    else if (len == l) ++c;
}
```
**实现思想**：通过遍历数组，统计最长连续相同子段的长度和个数。

#### 2. 作者：船酱魔王 (4.5星)
**关键亮点**：
- 详细分析了连通块的性质，证明了最大连通块一定是矩形。
- 代码结构清晰，使用了`long long`避免溢出问题。
- 通过遍历数组统计最长连续相同子段的长度和个数，时间复杂度为$O(T(n+m))$。

**核心代码**：
```cpp
for(int i = 1; i <= x + 1; i++) {
    if(a[i] == a[i - 1]) {
        nowl++;
    } else {
        if(nowl == lent) {
            cnt++;
        } else if(nowl > lent) {
            lent = nowl;
            cnt = 1;
        }
        nowl = 1;
    }
}
```
**实现思想**：通过遍历数组，统计最长连续相同子段的长度和个数。

#### 3. 作者：wdgm4 (4星)
**关键亮点**：
- 通过反证法证明了最大连通块一定是矩形，思路严谨。
- 代码结构清晰，使用了`long long`避免溢出问题。
- 通过遍历数组统计最长连续相同子段的长度和个数，时间复杂度为$O(T(n+m))$。

**核心代码**：
```cpp
for(int i = 1; i <= n; i++) {
    a[i] = read();
    if(aa[len1] != a[i]) {
        if(max1 < num1[len1]) {
            max1 = num1[len1];
            sum1 = 1;
        } else if(max1 == num1[len1]) {
            sum1++;
        }
        aa[++len1] = a[i];
        num1[len1] = 1;
    } else num1[len1]++;
}
```
**实现思想**：通过遍历数组，统计最长连续相同子段的长度和个数。

### 最优关键思路与技巧

1. **问题转化**：通过分析矩阵的构造方式，将最大连通块问题转化为求两个数组的最长连续相同子段的长度和个数。
2. **遍历统计**：通过遍历数组，统计最长连续相同子段的长度和个数，时间复杂度为$O(T(n+m))$。
3. **乘法原理**：利用乘法原理，将两个数组的最长连续相同子段的长度和个数相乘，得到最大连通块的大小和个数。

### 可拓展之处

- **类似问题**：类似的问题可以考察其他矩阵构造方式下的连通块性质，如矩阵元素为$a_i \times b_j$等。
- **算法套路**：类似的统计最长连续相同子段的思路可以应用于其他问题，如最长连续递增子序列等。

### 推荐题目

1. **P1115 最大子段和**：考察连续子段的最大和问题。
2. **P1886 滑动窗口**：考察滑动窗口中的最大值问题。
3. **P1020 导弹拦截**：考察最长不上升子序列问题。

### 个人心得总结

- **调试经历**：多位作者提到需要开`long long`避免溢出问题，提醒我们在处理大范围数据时要注意数据类型的选择。
- **踩坑教训**：部分题解提到多组数据时需要初始化变量，提醒我们在编写多组数据代码时要注意变量的初始化。

---
处理用时：24.74秒
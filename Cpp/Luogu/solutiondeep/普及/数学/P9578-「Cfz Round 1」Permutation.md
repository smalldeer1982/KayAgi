# 题目信息

# 「Cfz Round 1」Permutation

## 题目背景

$1+2+3+\cdots+n=\dfrac {n\times (n+1)} 2$。

## 题目描述

给定一个正整数 $n$。

我们定义，对于一个 $1$ 到 $n$ 的排列 $\{x_n\}$， $f(\{x_n\})=\max\limits_{i=1}^{n}(x_i+x_{(i \bmod n)+1})-\min\limits_{i=1}^{n}(x_i+x_{(i \bmod n)+1})$。

你需要构造一个 $1$ 到 $n$ 的排列 $\{p_n\}$，使得对于任意一个 $1$ 到 $n$ 的排列 $\{q_n\}$，都有 $f(\{p_n\})\le f(\{q_n\})$，并输出你构造的排列 $\{p_n\}$。

## 说明/提示

#### 【样例解释 #1】

$f(\{1,4,2,3\})=2$，可以证明对于任意一个 $1$ 到 $n$ 的排列 $\{q_n\}$，都有 $f(\{1,4,2,3\})\le f(\{q_n\})$。

当然，$\{1,3,2,4\},\{3,1,4,2\},\{4,1,3,2\}$ 等也为合法的排列 $\{p_n\}$。

#### 【数据范围】

对于所有数据，$3 \le n \le 10^6$。

**本题采用捆绑测试。**

|子任务编号|分值|$n \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1$|$20$|$8$|无|
|$2$|$25$|$10^6$|保证 $n \equiv 0 \pmod 2$|
|$3$|$25$|$10^6$|保证 $n \equiv 1 \pmod 2$|
|$4$|$30$|$10^6$|无|

## 样例 #1

### 输入

```
4```

### 输出

```
1 4 2 3```

# AI分析结果

### 综合分析与结论

本题的核心目标是构造一个排列，使得相邻两数之和的极差最小。通过分析多个题解，可以发现大部分题解都采用了类似的思路：通过将大数和小数交叉排列，使得相邻两数的和尽可能接近平均值 \(n+1\)，从而最小化极差。具体实现上，奇数和偶数的处理方式略有不同，但核心思想一致。

### 所选高质量题解

#### 1. 作者：Defy_HeavenS (5星)
- **关键亮点**：通过观察奇偶数的规律，分别构造了奇数和偶数情况下的排列，思路清晰且代码简洁。
- **个人心得**：通过暴力构造小数据，发现了奇偶数的排列规律，进一步推广到一般情况。
- **核心代码**：
  ```cpp
  if(n%2==0){
      for(int i=2,j=n-1;i<=n/2;i+=2,j-=2){
          a[i]=j;
          a[n-i+1]=n+1-j;
      }
      for(int i=1;i<=n;i++){
          if(!a[i]) cout<<i<<" ";
          else cout<<a[i]<<" ";
      }
  }else{
      a[1]=1;
      for(int i=3,j=2;i<=n;i+=2,j+=2){
          a[i]=j;
      }
      for(int i=2,j=n;i<=n;i+=2,j-=2){
          a[i]=j;
      }
      for(int i=1;i<=n;i++){
          cout<<a[i]<<" ";
      }
  }
  ```
  **核心思想**：奇数和偶数分别处理，奇数下标递增，偶数下标递减，确保相邻两数之和接近 \(n+1\)。

#### 2. 作者：maomao233 (4星)
- **关键亮点**：通过分析相邻两数之和的平均值，提出了将和控制在 \(n, n+1, n+2\) 之间的策略，并给出了具体的构造方法。
- **个人心得**：通过减少贪心成分，将和控制在 \(n, n+1, n+2\) 之间，避免了重复和冲突。
- **核心代码**：
  ```cpp
  for(int i=2;i<=n;i++){
      int flag=0;
      if(!a[n-ans[i-1]] && (i==2 || (i>=3 && ans[i-1]+ans[i-2]==(n+2)))){
          int x=n-ans[i-1];
          a[x]=1,ans[i]=x,flag=1;
      }
      else if(!a[(n+1)-ans[i-1]] && (i==2 || (i>=3 && ans[i-1]+ans[i-2]==(n+1)))){
          int x=(n+1)-ans[i-1];
          a[x]=1,ans[i]=x,flag=1;
      }
      else if(!a[(n+2)-ans[i-1]] && (i==2 || (i>=3 && ans[i-1]+ans[i-2]==n))){
          int x=(n+2)-ans[i-1];
          a[x]=1,ans[i]=x,flag=1;
      }
      else{
          if(!flag){
              if(!a[n-ans[i-1]]){
                  int x=n-ans[i-1];
                  a[x]=1,ans[i]=x,flag=1;
              }
              else if(!a[(n+1)-ans[i-1]]){
                  int x=(n+1)-ans[i-1];
                  a[x]=1,ans[i]=x,flag=1;
              }
              else if(!a[(n+2)-ans[i-1]]){
                  int x=(n+2)-ans[i-1];
                  a[x]=1,ans[i]=x,flag=1;
              }
          }
      }
  }
  ```
  **核心思想**：通过控制相邻两数之和在 \(n, n+1, n+2\) 之间，确保极差最小。

#### 3. 作者：Eason_cyx (4星)
- **关键亮点**：通过暴力枚举小数据，发现了排列的规律，并给出了简洁的构造方法。
- **个人心得**：通过暴力枚举，发现了排列的规律，进一步推广到一般情况。
- **核心代码**：
  ```cpp
  if(n % 2 == 0) {
      bool flag = false;
      for(int i = 1; i <= n/2; i++) {
          int now1 = i, now2 = n + 1 - i;
          if(flag) {
              a[i] = now2;
              a[n-i+1] = now1;
          } else {
              a[i] = now1;
              a[n-i+1] = now2;
          }
          flag = !flag;
      }
      for(int i = 1; i <= n; i++) cout << a[i] << " \n"[i == n];
  } else {
      bool flag = false;
      for(int i = 1; i <= n/2; i++) {
          int now1 = i, now2 = n + 1 - i;
          if(flag) {
              a[i] = now2;
              a[n-i+1] = now1;
          } else {
              a[i] = now1;
              a[n-i+1] = now2;
          }
          flag = !flag;
      }
      a[n/2+1] = (n+1)/2;
      for(int i = 1; i <= n; i++) cout << a[i] << " \n"[i == n];
  }
  ```
  **核心思想**：通过交叉排列大数和小数，确保相邻两数之和接近 \(n+1\)。

### 最优关键思路与技巧

1. **交叉排列大数和小数**：通过将大数和小数交叉排列，确保相邻两数之和接近平均值 \(n+1\)，从而最小化极差。
2. **控制相邻两数之和**：将相邻两数之和控制在 \(n, n+1, n+2\) 之间，避免重复和冲突，确保极差最小。
3. **奇偶分类处理**：根据 \(n\) 的奇偶性，分别处理排列的构造，确保排列的合理性。

### 可拓展之处

- **类似问题**：类似的问题可以扩展到其他类型的排列构造，如最小化相邻两数之积的极差等。
- **算法套路**：通过暴力枚举小数据，发现规律，进一步推广到一般情况，是一种常见的构造题解题思路。

### 推荐题目

1. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
2. [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)
3. [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)

---
处理用时：39.35秒
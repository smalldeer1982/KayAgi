# 题目信息

# 「QFOI R1」摸摸

## 题目描述

小 R 是一个可爱的女孩子，她喜欢被摸头。

但是摸头之前，必须答对她提出的一个问题。

她有一个长度为 $n$ 的数列 $a$，初始时所有元素均为 $0$。另有两个长度为 $n$ 的数列 $t,b$。

她可以进行两种操作：

1. 将 $t$ 与 $t$ 的倒序对应元素相加，得到新的 $t$。
    - 例如，$t=[1,4,2]$ 变为 $t'=[1+2,4+4,2+1]=[3,8,3]$。
2. 将 $a$ 与 $t$ 对应元素相加，得到新的 $a$。
    - 例如，$a=[1,2,3],t=[1,4,2]$ 变为 $a'=[1+1,2+4,3+2]=[2,6,5]$。

是否可能通过若干次以上操作将 $a$ 变为 $b$？

你希望摸她的头 $T$ 次，因此有 $T$ 组数据。

## 说明/提示

**样例解释**

对于第一组数据：

- 初始时：$a=[0,0,0]$，$t=[1,2,2]$，$b=[5,8,7]$。
- 执行操作二：$a=[1,2,2]$，$t=[1,2,2]$，$b=[5,8,7]$。
- 执行操作二：$a=[2,4,4]$，$t=[1,2,2]$，$b=[5,8,7]$。
- 执行操作一：$a=[2,4,4]$，$t=[3,4,3]$，$b=[5,8,7]$。
- 执行操作二：$a=[5,8,7]$，$t=[3,4,3]$，$b=[5,8,7]$。

此时 $a=b$，符合要求。

对于第二组数据，可以证明不存在合法方案。

---

**数据范围**

本题共 $20$ 个测试点，每个测试点 $5$ 分。

记 $\sum n$ 表示每组数据的 $n$ 之和。

对于全部数据，保证 $1\le\sum n\le 2\times 10^3$，$n\ge 1$，$1\le t_i,b_i\le 2\times 10^3$。

- 对于测试点 $1\sim 4$：保证 $n\le 2$。
- 对于测试点 $5\sim 8$：保证所有 $t_i$ 都相等。
- 对于测试点 $9\sim 12$：保证 $b_i=b_{n-i+1}$。
- 对于测试点 $13\sim 16$：保证 $\sum n,t_i,b_i\le 200$。
- 对于测试点 $17\sim 20$：无特殊限制。

---

**Hack 数据**

本题在赛后添加了 Hack 数据，从 $21$ 开始编号。

原有测试点依然计 $5$ 分，Hack 数据计 $0$ 分，但只有通过所有数据才会被判为 Accepted。

为区分原有测试点和 Hack 数据，本题添加了子任务，但子任务的计分方式为“加和”，不会影响正常评测。

## 样例 #1

### 输入

```
2
3
1 2 2
5 8 7
3
1 2 2
2 4 3```

### 输出

```
Yes
No```

# AI分析结果

### 综合分析与结论

本题的核心在于通过两种操作将初始为全0的数列 $a$ 转化为目标数列 $b$。关键点在于操作一（将 $t$ 与 $t$ 的倒序相加）最多只需执行一次，因为执行一次后 $t$ 变为回文序列，后续操作一相当于对 $t$ 进行翻倍，可以通过多次操作二替代。因此，问题转化为如何通过操作二和最多一次操作一，将 $a$ 转化为 $b$。

大多数题解的思路是枚举操作一之前和之后执行操作二的次数，然后验证是否能够通过这些操作得到 $b$。部分题解通过数学推导，直接求解方程 $b_i = x \cdot t_i + y \cdot t'_i$，其中 $t'_i$ 是操作一后的 $t$。这种方法的时间复杂度较低，且代码实现较为简洁。

### 所选高星题解

#### 1. 作者：rui_er (5星)
**关键亮点**：
- 思路清晰，直接证明了操作一最多只需执行一次，简化了问题。
- 通过枚举操作一之前和之后的操作二次数，验证是否能够得到 $b$。
- 代码简洁，时间复杂度为 $O(nw)$，其中 $w$ 为值域。

**核心代码**：
```cpp
bool ans = false;
while(true) {
    bool valid = true;
    rep(i, 1, n) if(a[i] > b[i]) valid = false;
    if(!valid) break;
    if((b[1] - a[1]) % s[1] == 0) {
        int steps = (b[1] - a[1]) / s[1];
        bool ok = true;
        rep(i, 1, n) if(b[i] != a[i] + steps * s[i]) ok = false;
        if(ok == true) {ans = true; break;}
    }
    rep(i, 1, n) a[i] += t[i];
}
puts(ans ? "Yes" : "No");
```
**核心思想**：通过枚举操作二的次数，验证是否能够通过操作一和操作二得到 $b$。

#### 2. 作者：Jorisy (4星)
**关键亮点**：
- 通过数学推导，直接求解方程 $b_i = x \cdot t_i + y \cdot t'_i$，其中 $t'_i$ 是操作一后的 $t$。
- 代码实现简洁，时间复杂度为 $O(nw)$。

**核心代码**：
```cpp
for(int i=1;i*t[1]<=b[1];i++) {
    int x = b[1] - i * t[1];
    if(x % t[n]) continue;
    for(int j=2;j<=n;j++) {
        int p = b[j] - i * t[j];
        if(p % t[n-j+1] || p / t[n-j+1] != x / t[n] || i < x / t[n]) goto pp;
    }
    puts("Yes");
    return;
    pp:;
}
puts("No");
```
**核心思想**：通过枚举 $x$，求解 $y$，并验证是否满足所有 $b_i = x \cdot t_i + y \cdot t'_i$。

#### 3. 作者：WaterSun (4星)
**关键亮点**：
- 通过枚举 $x$ 和 $y$，验证是否能够通过操作一和操作二得到 $b$。
- 代码实现简洁，时间复杂度为 $O(nw^2)$。

**核心代码**：
```cpp
for (re int x = 0; x * t[1] <= b[1]; x++) {
    for (re int y = 0; x * t[1] + y * tt[1] <= b[1]; y++) {
        bool ok = true;
        for (re int i = 1; i <= n; i++) {
            if (b[i] != x * t[i] + y * tt[i]) {
                ok = false;
                break;
            }
        }
        if (ok) {
            falg = true;
            break;
        }
    }
}
if (falg) puts("Yes");
else puts("No");
```
**核心思想**：通过枚举 $x$ 和 $y$，验证是否能够通过操作一和操作二得到 $b$。

### 最优关键思路与技巧

1. **操作一最多只需执行一次**：这是问题的核心简化点，通过证明操作一执行一次后，后续操作一可以通过操作二替代，大大减少了问题的复杂度。
2. **枚举操作次数**：通过枚举操作一之前和之后的操作二次数，验证是否能够得到 $b$，这是一种直观且有效的解题思路。
3. **数学推导求解方程**：通过数学推导，直接求解方程 $b_i = x \cdot t_i + y \cdot t'_i$，这种方法的时间复杂度较低，且代码实现较为简洁。

### 可拓展之处

- **类似操作问题**：类似的操作问题可以通过枚举操作次数或数学推导来简化问题，例如某些动态规划问题或线性代数问题。
- **回文序列的性质**：回文序列的性质在本题中起到了关键作用，类似的序列操作问题可以借鉴这一思路。

### 推荐题目

1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

这些题目都涉及到通过枚举或数学推导来简化问题，适合进一步练习类似的解题思路。

---
处理用时：28.89秒
# 题目信息

# [USACO20JAN] Race B

## 题目描述

Bessie 正在参加一场 $K$（$1\le K\le 10^9$）米的跑步比赛。她从 $0$ 米每秒的速度开始比赛。在每一秒中，她可以选择将她的速度增加 $1$ 米每秒，保持速度不变，或者将她的速度减少 $1$ 米每秒。例如，在第一秒中，她可以将她的速度增加到 $1$ 米每秒，跑 $1$ 米，或者保持她的速度 $0$ 米每秒不变，跑 $0$ 米。Bessie 的速度不会降低到小于零。

Bessie 始终朝着终点线的方向跑，她想要花费整数秒的时间完成比赛。此外，她不想在终点时跑得太快：在 Bessie 跑完 $K$ 米的时刻，她希望她的速度不超过 $X$（$1\le X\le 10^5$）米每秒。Bessie 想要对于 $N$（$1\le N\le 1000$）个不同的 $X$ 值知道她多快可以完成比赛。 

## 说明/提示

### 样例解释 1

当 $X=1$ 时，一种最优方案为：

1. 将速度增加到 $1$ 米/秒，跑 $1$ 米
2. 将速度增加到 $2$ 米/秒，跑 $2$ 米，总计跑 $3$ 米
3. 将速度保持在 $2$ 米/秒，总计跑 $5$ 米
4. 将速度保持在 $2$ 米/秒，总计跑 $7$ 米
5. 将速度保持在 $2$ 米/秒，总计跑 $9$ 米
6. 将速度降低到 $1$ 米/秒，总计跑 $10$ 米

当 $X=3$ 时，一种最优方案为：

1. 将速度增加到 $1$ 米/秒，跑 $1$ 米
2. 将速度增加到 $2$ 米/秒，总计跑 $3$ 米
3. 将速度增加到 $3$ 米/秒，总计跑 $6$ 米
4. 将速度保持在 $3$ 米/秒，总计跑 $9$ 米
5. 将速度保持在 $3$ 米/秒，总计跑 $12$ 米

注意当 $X=3$ 时，以下方案是不合法的：

1. 将速度增加到 $1$ 米/秒，跑 $1$ 米
2. 将速度增加到 $2$ 米/秒，总计跑 $3$ 米
3. 将速度增加到 $3$ 米/秒，总计跑 $6$ 米
4. 将速度增加到 $4$ 米/秒，总计跑 $10$ 米

这是因为在 Bessie 跑完 $10$ 米的时刻，她的速度是 $4$ 米/秒。 

## 样例 #1

### 输入

```
10 5
1
2
3
4
5```

### 输出

```
6
5
5
4
4```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在满足终点速度限制的条件下，找到完成比赛的最短时间。题解中主要出现了以下几种思路：

1. **模拟法**：通过模拟加速和减速的过程，逐步累加距离，直到满足条件。这种方法直观但可能效率较低。
2. **数学公式法**：利用等差数列求和公式，计算在不同时间下的最大距离，结合二分查找优化时间复杂度。
3. **二分查找法**：通过二分查找确定最短时间，结合数学公式计算最大距离，效率较高。

### 所选高星题解

#### 1. 作者：Treap_Kongzs (4.5星)
- **关键亮点**：通过将减速过程视为反向加速，简化了问题的处理。利用模拟法逐步累加距离，代码简洁且易于理解。
- **个人心得**：作者通过图像化分析，将复杂的运动过程简化为加速和减速两个阶段，避免了复杂的数学推导。
- **核心代码**：
```cpp
int solve(int dis,int maxv) {
    int ans=0;
    int updis=0,downdis=0;
    int v=0;
    while(1) {
        v++;
        updis+=v;
        ans++;
        if(updis+downdis>=dis)return ans;
        if(v>=maxv) {
            downdis+=v;
            ans++;
            if(updis+downdis>=dis)return ans;
        }
    }
}
```
- **实现思想**：通过模拟加速和减速过程，逐步累加距离，直到满足条件。

#### 2. 作者：superLouis (4星)
- **关键亮点**：使用二分查找优化时间复杂度，结合数学公式计算最大距离，效率较高。
- **个人心得**：作者通过二分查找确定最短时间，避免了复杂的模拟过程，代码结构清晰。
- **核心代码**：
```cpp
int maxlen(int t, int x) {
    if (t <= x) return sum(1, t);
    int speed = (t + x) >> 1;
    if ((t + x) & 1) return sum(1, speed) + sum(speed, x);
    return sum(1, speed) + sum(speed - 1, x); 
}
bool check(int t, int x) {
    return maxlen(t, x) >= k;
}
```
- **实现思想**：通过二分查找确定最短时间，结合数学公式计算最大距离。

#### 3. 作者：continueOI (4星)
- **关键亮点**：通过预处理一直加速到达终点所需的时间，结合分类讨论，简化了问题的处理。
- **个人心得**：作者通过预处理和分类讨论，避免了复杂的模拟过程，代码结构清晰。
- **核心代码**：
```cpp
void solve(int lim){
    if(lim>=minn){
        cout<<minn<<'\n';
        return;
    }
    const int sum1=(lim-1)*lim/2;
    int sum2=0;
    for(t=lim;;t++){
        sum2+=t;
        if(sum1+(sum2-t)*2+t>=k){
            cout<<lim-1+(t-lim)*2+1<<'\n';
            return;
        }
        if(sum1+sum2*2>=k){
            cout<<lim-1+(t-lim+1)*2<<'\n';
            return;
        }
    }
}
```
- **实现思想**：通过预处理和分类讨论，逐步累加距离，直到满足条件。

### 最优关键思路与技巧

1. **将减速过程视为反向加速**：通过将减速过程视为反向加速，简化了问题的处理，避免了复杂的数学推导。
2. **二分查找优化时间复杂度**：通过二分查找确定最短时间，结合数学公式计算最大距离，效率较高。
3. **预处理与分类讨论**：通过预处理一直加速到达终点所需的时间，结合分类讨论，简化了问题的处理。

### 可拓展之处

- **类似算法套路**：在处理涉及时间、距离和速度的问题时，可以考虑将减速过程视为反向加速，简化问题的处理。
- **二分查找的应用**：在需要确定最短时间或最小值的场景中，二分查找是一种高效的优化手段。

### 推荐题目

1. **洛谷P1020 导弹拦截**：考察二分查找与动态规划的结合。
2. **洛谷P1048 采药**：考察动态规划与时间优化的结合。
3. **洛谷P1091 合唱队形**：考察动态规划与序列处理的结合。

### 个人心得总结

- **调试经历**：作者在调试过程中发现不开`long long`会导致部分测试点无法通过，提醒了数据类型选择的重要性。
- **顿悟感想**：通过图像化分析，将复杂的运动过程简化为加速和减速两个阶段，避免了复杂的数学推导，提高了代码的可读性和效率。

---
处理用时：27.38秒
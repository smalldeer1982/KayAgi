# 题目信息

# [USACO23DEC] Farmer John Actually Farms B

## 题目描述

Farmer John 在他的农场上种植了 $N$（$1 \leq N \leq 2\cdot 10^5$） 株芦笋！然而，其中有一些植物存在基因差异，长得比其他植物快。第 $i$ 株植物的初始高度为 $h_i$ 英寸，之后每天，第 $i$ 株植物长高 $a_i$ 英寸。

FJ 更加钟爱其中的一些植物。他将给你一组由不同整数组成的数组 $t_1,\dots,t_N$，这个数组包含 $0$ 到 $N-1$ 的全部整数。他希望恰好有 $t_i$ 株植物比第 $i$ 株植物高。找到最少要经过多少天，才能满足 FJ 的要求，或者报告这个要求是不可能满足的。

## 说明/提示

### 样例解释 1

在第一组样例中，有 $6$ 组测试数据。

在第一组测试数据中，只有一株植物，所以要求在第 $0$ 天就已经满足。

在第二组测试数据中，需要让第一株植物比第二株植物矮。第   $1$ 天后，它们的高度为 $15,13$；第 $2$ 天后，它们的高度均为 $23$；第 $3$ 天后，它们的高度为 $31,33$，这是满足要求的第一天。

第三组和第四组测试数据与第二组类似。

在第五组测试数据中，两株植物的初始高度均为 $7$ 英寸，且每天均增长 $8$ 英寸，所以它们的高度永远相同。因此，条件永远无法满足。

在第六组测试数据中，初始高度不满足要求且增长速度均相同，所以条件永远无法满足。

### 样例解释 2

在第二组样例中，有 $2$ 组测试数据。

在第一组测试数据中，第 $4$ 天后的最终高度为 $19, 20, 21, 18, 16$。

在第二组测试数据中，第 $7$ 天后的最终高度为 $25, 17, 19, 35, 36$。

### 测试点性质

- 测试点 $3$ 满足 $N \le 2$。
- 测试点 $4-5$ 满足 $N \le 50$，$a_i, h_i \le 10^3$。
- 测试点 $6-8$ 满足 $N \le 10^3$。
- 测试点 $9-13$ 没有额外限制。

## 样例 #1

### 输入

```
6
1
10
1
0
2
7 3
8 10
1 0
2
3 6
10 8
0 1
2
7 3
8 9
1 0
2
7 7
8 8
0 1
2
7 3
8 8
1 0```

### 输出

```
0
3
2
5
-1
-1```

## 样例 #2

### 输入

```
2
5
7 4 1 10 12
3 4 5 2 1
2 1 0 3 4
5
4 10 12 7 1
3 1 1 4 5
2 4 3 1 0```

### 输出

```
4
7```

# AI分析结果

### 综合分析与结论

本题的核心在于通过不等式求解，找到满足所有植物高度关系的最小天数。各题解的主要思路都是通过比较相邻植物的高度和生长速度，列出不等式并求解。难点在于处理不同情况下的不等式方向，以及如何高效地求解这些不等式的交集。

### 所选高星题解

#### 1. 题解作者：tder (5星)
**关键亮点**：
- 思路清晰，通过不等式分类讨论，详细解释了不同情况下的解法。
- 代码简洁，逻辑严密，直接通过不等式求解，避免了复杂的模拟过程。
- 时间复杂度为 $O(T \cdot n)$，效率较高。

**核心代码**：
```cpp
int work() {
    cin>>n;
    for(int i = 1; i <= n; i++) cin>>h[i];
    for(int i = 1; i <= n; i++) cin>>a[i];
    for(int i = 1; i <= n; i++) {
        cin>>t[i];
        p[t[i] + 1] = i;
    }
    if(n == 1) return 0;
    q1 = -1, q2 = M;
    for(int i = 1; i < n; i++) {
    	int x = p[i], y = p[i + 1];
		if(a[x] > a[y]) q1 = max(q1, 1.0 * (h[y] - h[x]) / (a[x] - a[y]));
		else if(a[x] < a[y]) q2 = min(q2, 1.0 * (h[y] - h[x]) / (a[x] - a[y]));
		else if(h[x] <= h[y]) return -1; 	
	}
    if(q1 < q2) {
		double r = floor(q1) + 1; 
		if(r < q2) return r;
		else return -1;
	} else return -1;
}
```

#### 2. 题解作者：Macw07 (4星)
**关键亮点**：
- 通过排序和不等式求解，详细讨论了不同情况下的解法。
- 代码结构清晰，逻辑严密，处理了各种边界情况。
- 时间复杂度为 $O(T \cdot n)$，效率较高。

**核心代码**：
```cpp
for (int i=1; i<n; i++){
    if (arr[i].change == arr[i+1].change){
        if (arr[i].height >= arr[i+1].height){
            cout << -1 << endl;
            goto end;
        }
        continue;
    } 
    if (arr[i].change - arr[i+1].change < 0){
        if (arr[i+1].height - arr[i].height < 0){
            double limit = ((arr[i+1].height - arr[i].height)*1.0)/(arr[i].change - arr[i+1].change);
            if ((int)floor(limit) == (int)ceil(limit)) limit = ceil(limit) + 1;
            else limit = ceil(limit);
            lowerLimit = max(lowerLimit, (int)limit);
        } else continue;
    } 
    else{
        if (arr[i+1].height - arr[i].height < 0){
            cout << -1 << endl;
            goto end;
        } else{
            double limit = ((arr[i+1].height - arr[i].height)*1.0)/(arr[i].change - arr[i+1].change);
            if ((int)floor(limit) == (int)ceil(limit)) limit = ceil(limit) - 1;
            else limit = floor(limit);
            upperLimit = min(upperLimit, (int)limit);
        }
    }
    if (lowerLimit > upperLimit){
        cout << -1 << endl;
        goto end;
    }
}
```

### 最优关键思路与技巧

1. **不等式求解**：通过比较相邻植物的高度和生长速度，列出不等式并求解，找到满足所有条件的最小天数。
2. **分类讨论**：根据不同情况（如生长速度相同或不同）进行分类讨论，确保所有情况都被正确处理。
3. **区间交集**：通过求解多个不等式的交集，找到满足所有条件的最小天数。

### 可拓展之处

- **类似问题**：可以扩展到其他需要满足多个条件的最优化问题，如资源分配、任务调度等。
- **算法优化**：可以进一步优化不等式的求解过程，减少不必要的计算。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1045 最大子段和](https://www.luogu.com.cn/problem/P1045)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得总结

- **调试经历**：在处理不等式时，容易忽略某些边界情况，导致程序出错。通过多次调试和验证，确保所有情况都被正确处理。
- **踩坑教训**：在处理生长速度相同的情况时，容易忽略高度比较，导致程序无法正确判断无解情况。
- **顿悟感想**：通过分类讨论和不等式求解，可以高效地解决复杂的最优化问题，关键在于理清思路，确保所有情况都被覆盖。

---
处理用时：27.60秒
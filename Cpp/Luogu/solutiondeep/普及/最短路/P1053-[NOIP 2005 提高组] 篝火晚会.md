# 题目信息

# [NOIP 2005 提高组] 篝火晚会

## 题目描述

佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有 $n$ 个同学，编号从 $1$ 到 $n$。一开始，同学们按照 $1,2,\cdots ,n$ 的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。


佳佳可向同学们下达命令，每一个命令的形式如下：

$$(b_1, b_2,... b_{m-1}, b_m)$$

这里 $m$ 的值是由佳佳决定的，每次命令 $m$ 的值都可以不同。这个命令的作用是移动编号是 $b_1,b_2,\cdots, b_m$ 的这 $m$ 个同学的位置。要求 $b_1$ 换到 $b_2$ 的位置上，$b_2$ 换到 $b_3$ 的位置上，……，要求 $b_m$ 换到 $b_1$ 的位置上。执行每个命令都需要一些代价。我们假定如果一个命令要移动 $m$ 个人的位置，那么这个命令的代价就是 $m$。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗？


## 说明/提示

- 对于 $30\%$ 的数据，满足 $n \le 1000$；
- 对于 $100\%$ 的数据，满足 $3\le n  \le  50000$。

**【题目来源】**

NOIP 2005 提高组第三题

## 样例 #1

### 输入

```
4
3 4
4 3
1 2
1 2
```

### 输出

```
2```

# AI分析结果

### 综合分析

本题的核心是通过最少的操作次数将初始的环形排列调整为满足每个同学相邻意愿的目标排列。题解中主要思路是通过构建目标链和初始链，计算两者之间的差值，找出差值中出现次数最多的值，从而确定最优的旋转方式，最终计算需要调整的人数。

### 题解评分与亮点

#### 题解1：Actinoi (5星)
- **关键亮点**：详细解释了如何通过差值统计来优化算法，避免了O(N^2)的复杂度，提出了顺时针和逆时针两种情况的处理方式，代码清晰且高效。
- **个人心得**：强调了移动的人不需要连续这一坑点，并通过图示直观地展示了如何通过一次操作完成多个位置的调整。
- **核心代码**：
  ```cpp
  for(int i = 1; i <= n; i++){
      pluss[(target[i] - initial[i] + n) % n]++; // 顺时针统计
      minuss[(target[i]- initial[n - initial[i] + 1] + n) % n]++; // 逆时针统计
  }
  for (int i = 0; i <= n - 1; i++)
      ans = max(ans, max(pluss[i], minuss[i])); // 找差值人数最多的
  cout << n - ans; // 总人数 - 不用移动的人数 = 需要移动的人数
  ```

#### 题解2：Drinkkk (4星)
- **关键亮点**：详细描述了如何通过构建目标链和初始链来计算差值，并提出了通过统计差值出现次数来优化算法，代码实现较为简洁。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++){
      dis1[(i-a[i]+n)%n]++; // 顺时针统计
      dis2[(a[i]+i+n)%n]++; // 逆时针统计
  }
  int ans=0;
  for(int i=0;i<=n*2;i++)
      ans=max(ans,max(dis1[i],dis2[i])); // 找差值人数最多的
  printf("%d",n-ans); // 输出结果
  ```

#### 题解3：LXcjh4998 (4星)
- **关键亮点**：通过构造目标链和初始链，计算差值并统计出现次数最多的差值，提出了顺时针和逆时针两种情况的处理方式，代码实现较为清晰。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;++i)
      ++plus_order[(target_list[i]-initial_list[i]+n)%n],      // 顺时针统计
      ++minus_order[(target_list[i]-initial_list[n-i+1]+n)%n]; // 逆时针统计
  for(int i=0;i<n;++i)
      ans=max(ans,max(plus_order[i],minus_order[i])); // 统计答案
  printf("%d",n-ans); // 输出
  ```

### 最优关键思路与技巧

1. **差值统计法**：通过计算目标链与初始链的差值，统计差值出现的次数，找出出现次数最多的差值，从而确定最优的旋转方式。
2. **顺时针与逆时针处理**：由于环可以旋转，因此需要分别考虑顺时针和逆时针两种情况，确保找到最优解。
3. **O(N)复杂度优化**：通过差值统计，避免了O(N^2)的复杂度，使得算法在较大数据规模下依然高效。

### 可拓展之处

- **类似问题**：类似的问题包括环形排列的调整、最小交换次数等问题，可以通过差值统计法进行优化。
- **算法套路**：差值统计法可以应用于其他需要调整排列顺序的问题，尤其是在环形排列的场景下。

### 推荐题目

1. [P1053 篝火晚会](https://www.luogu.com.cn/problem/P1053)
2. [P1054 环形排列](https://www.luogu.com.cn/problem/P1054)
3. [P1055 最小交换次数](https://www.luogu.com.cn/problem/P1055)

### 个人心得总结

- **调试经历**：在调试过程中，发现移动的人不需要连续这一坑点，通过图示直观地展示了如何通过一次操作完成多个位置的调整。
- **顿悟感想**：通过差值统计法，成功将复杂度从O(N^2)优化到O(N)，极大地提高了算法的效率。

---
处理用时：33.88秒
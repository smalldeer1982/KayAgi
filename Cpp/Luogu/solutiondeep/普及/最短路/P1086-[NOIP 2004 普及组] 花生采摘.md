# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在有限时间内按照花生数量从大到小的顺序采摘花生，并确保能够返回路边。所有题解都采用了类似的思路：首先记录所有有花生的植株位置和花生数量，然后按照花生数量从大到小排序，依次计算采摘所需的时间，判断是否能在限定时间内完成采摘并返回。

不同题解的主要区别在于数据结构的选用和代码实现的优化程度。**jiangXxin**的题解使用了结构体存储花生植株信息，并通过曼哈顿距离计算时间，代码清晰且易于理解。**MC_long_live**的题解则使用了稀松矩阵来存储花生植株信息，减少了无效数据的存储，代码较为简洁。**_Arahc_**的题解使用了`priority_queue`和`map`来优化排序和查询，代码实现较为高效。

### 所选高星题解

#### 1. 作者：jiangXxin (★★★★★)
- **关键亮点**：代码结构清晰，使用结构体存储花生植株信息，通过曼哈顿距离计算时间，逻辑简单易懂。
- **个人心得**：作者原本想用BFS，但发现花生田没有障碍物后改用曼哈顿距离，体现了对问题的灵活应对。
- **核心代码**：
  ```cpp
  struct dire {
      int x, y, sum;
  } stu[N * N];
  bool comp(struct dire a, struct dire b) {
      return a.sum > b.sum;
  }
  int main() {
      // 输入处理
      sort(stu + 1, stu + pn + 1, comp);
      for (int i = 1; i <= pn; i++) {
          tm = abs(fx - ex) + abs(fy - ey);
          k -= tm + 1;
          if (k >= ex) {
              ans += mp[ex][ey];
              fx = ex;
              fy = ey;
          } else {
              cout << ans << endl;
              return 0;
          }
      }
      cout << ans << endl;
      return 0;
  }
  ```

#### 2. 作者：_Arahc_ (★★★★☆)
- **关键亮点**：使用`priority_queue`和`map`优化排序和查询，代码实现高效，适合大规模数据处理。
- **个人心得**：作者强调了使用STL的优势，尤其是`priority_queue`的O(logn)插入效率。
- **核心代码**：
  ```cpp
  map<int, pair<int, int>> c;
  priority_queue<int> q;
  int main() {
      // 输入处理
      int j = q.top(); q.pop();
      int x = c[j].first;
      int y = c[j].second;
      w += x + 1;
      while (w + x <= k) {
          s += j;
          if (q.empty()) break;
          j = q.top(); q.pop();
          w += abs(c[j].first - x) + abs(c[j].second - y) + 1;
          x = c[j].first; y = c[j].second;
      }
      cout << s << endl;
      return 0;
  }
  ```

#### 3. 作者：MC_long_live (★★★★☆)
- **关键亮点**：使用稀松矩阵存储花生植株信息，减少了无效数据的存储，代码简洁。
- **个人心得**：作者通过稀松矩阵优化了存储和排序，体现了对数据结构的灵活运用。
- **核心代码**：
  ```cpp
  int a[25][25];
  int b[405][5];
  int main() {
      // 输入处理
      for (int i = 1; i <= q; i++)
          for (int j = i + 1; j <= q; j++) {
              if (b[i][3] < b[j][3]) {
                  swap(b[i][3], b[j][3]);
                  swap(b[i][1], b[j][1]);
                  swap(b[i][2], b[j][2]);
              }
          }
      if (k >= (b[1][1] * 2 + 1)) ans = b[1][3];
      else { cout << 0 << endl; return 0; }
      k -= b[1][1] + 1;
      for (int i = 2; i <= q; i++) {
          if (abs(b[i - 1][1] - b[i][1]) + abs(b[i - 1][2] - b[i][2]) + 1 + b[i][1] > k) break;
          else {
              ans += b[i][3];
              k -= (abs(b[i - 1][1] - b[i][1]) + abs(b[i - 1][2] - b[i][2]) + 1);
          }
      }
      cout << ans << endl;
      return 0;
  }
  ```

### 最优关键思路与技巧
1. **曼哈顿距离计算**：使用曼哈顿距离计算移动时间，简化了路径规划。
2. **数据结构优化**：使用`priority_queue`和`map`优化排序和查询，适合大规模数据处理。
3. **稀松矩阵**：通过稀松矩阵减少无效数据的存储，优化了内存使用。

### 可拓展之处
- **类似问题**：其他需要在有限时间内按优先级完成任务的问题，如任务调度、资源分配等。
- **算法套路**：贪心算法、优先队列、曼哈顿距离计算等。

### 推荐题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)

---
处理用时：45.81秒
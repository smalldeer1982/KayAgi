# 题目信息

# 请柬

## 题目背景

在电视时代，没有多少人观看戏剧表演。 Malidinesia 古董喜剧演员意识到这一事实，他们想宣传剧院,尤其是古色古香的喜剧片。

## 题目描述

他们已经打印了请帖和所有必要的信息和计划。许多学生被雇来分发这些请柬。每个学生志愿者被指定一个确切的公共汽车站，他或她将留在那里一整天,邀请人们参与。

这里的公交系统是非常特殊的：共有 $n$ 个站点和 $m$ 个线路，所有的线路都是单向的，连接两个站点。公共汽车离开起始点，到达目的地之后又空车返回起始点。

学生每天早上从总部所在的 $1$ 号站点出发，乘公交车到一个预定的站点邀请乘客。每个站点都被安排了一名学生。在一天结束的时候，所有的学生都回到总部。现在需要知道的是，学生所需的公交费用的总和最小是多少。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq n, m \leq 10^6$。
- $1 \leq u, v \leq n$，$1 \leq w \leq 10^9$。
- 从 $1$ 出发可以到达所有的站点。

## 样例 #1

### 输入

```
4 6
1 2 10
2 1 60
1 3 20
3 4 10
2 4 5
4 1 50```

### 输出

```
210 ```

# AI分析结果

### 综合分析与结论

该题目要求计算从起点到所有点的最短路，以及所有点到起点的最短路之和。题解中主要使用了**Dijkstra**和**SPFA**两种算法，且大多数题解都采用了**反向建图**的技巧来简化问题。反向建图的核心思想是将“所有点到起点的最短路”转化为“起点到所有点的最短路”，从而避免了对每个点单独进行最短路径计算的复杂度。

大多数题解的思路较为清晰，但在代码实现和优化上存在差异。部分题解使用了堆优化的Dijkstra，而另一些则使用了SPFA，且部分题解在代码结构和可读性上表现较好。整体来看，题解的质量参差不齐，部分题解在优化和代码简洁性上表现突出。

### 所选高星题解

#### 1. **题解作者：笃行 (5星)**
- **关键亮点**：使用了**SPFA**算法，并通过**优先队列**进行优化，代码结构清晰，且使用了**双向队列**来进一步优化SPFA的性能。
- **个人心得**：作者提到“看到还没有用stl优先队列优化的spfa，那就来一发吧”，体现了对算法优化的敏锐洞察。

```cpp
void spfa1() {
    deque <int> q;
    q.push_front(sx);
    fill(dis+2,dis+n+1,inf);
    while(!q.empty()) {
        int x=q.front();
        q.pop_front();
        inq[x]=0;
        for(int k=head1[x];k;k=d[k].from) {
            int v=d[k].to,w=d[k].dis;
            if(w+dis[x]<dis[v]) {
                dis[v]=w+dis[x];
                if(!inq[v]) {
                    if(q.empty()||dis[v]<dis[q.front()]) q.push_front(v);
                    else q.push_back(v);
                    inq[v]=1;
                }
            }
        }
    }
}
```

#### 2. **题解作者：shadowice1984 (4.5星)**
- **关键亮点**：使用了**Dijkstra**算法，并通过**堆优化**来提高效率，代码简洁且易于理解。
- **个人心得**：作者提到“记得在遍历出边时打标记即可”，强调了算法实现中的细节处理。

```cpp
void dijkstra() {
    priority_queue<node> q;
    q.push(node(1, 0));
    memset(dis, 0x3f, sizeof(dis));
    dis[1] = 0;
    while (!q.empty()) {
        node now = q.top(); q.pop();
        if (vis[now.id]) continue;
        vis[now.id] = true;
        for (int i = head[now.id]; i; i = edge[i].next) {
            int v = edge[i].to;
            if (dis[v] > dis[now.id] + edge[i].val) {
                dis[v] = dis[now.id] + edge[i].val;
                q.push(node(v, dis[v]));
            }
        }
    }
}
```

#### 3. **题解作者：PrincessYR✨～ (4星)**
- **关键亮点**：使用了**Dijkstra**算法，并通过**vector**存储图结构，代码结构清晰且易于扩展。
- **个人心得**：作者提到“反着存图，求出来的也是1到每个点的最短路”，强调了反向建图的巧妙之处。

```cpp
void dij(int x) {
    fill(d,d+1+n,INF);
    d[x]=0;
    q.push(P(0,x));
    while(!q.empty()) {
        P p=q.top();q.pop();
        int v=p.second;
        if(d[v]<p.first) continue;
        for(int i=0;i<g[v].size();i++) {
            edge e=g[v][i];
            if(d[e.to]>d[v]+e.cost) {
                d[e.to]=d[v]+e.cost;
                q.push(P(d[e.to],e.to));
            }
        }
    }
}
```

### 最优关键思路与技巧

1. **反向建图**：将“所有点到起点的最短路”转化为“起点到所有点的最短路”，极大地简化了问题。
2. **堆优化Dijkstra**：通过优先队列优化Dijkstra算法，提高了算法的效率。
3. **SPFA优化**：使用双向队列优化SPFA，减少了不必要的节点访问，提升了性能。

### 可拓展之处

- **同类型题**：类似的问题可以通过反向建图来简化，如计算多个起点到多个终点的最短路。
- **算法套路**：Dijkstra和SPFA的优化技巧可以应用于其他最短路径问题，如带负权边的图或动态图的最短路径计算。

### 推荐题目

1. **P1629 邮递员送信**：考察从起点到所有点的最短路及返回的最短路之和。
2. **P4779 【模板】单源最短路径（标准版）**：Dijkstra算法的模板题。
3. **P3371 【模板】单源最短路径（弱化版）**：SPFA算法的模板题。

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中遇到TLE问题，通过优化算法或数据结构解决了问题。
- **踩坑教训**：部分作者强调了开**long long**的重要性，避免数据溢出。
- **顿悟感想**：反向建图的思路让许多作者感到“豁然开朗”，体现了算法思维的重要性。

---
处理用时：43.37秒
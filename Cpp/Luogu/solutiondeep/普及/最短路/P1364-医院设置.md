# 题目信息

# 医院设置

## 题目描述

设有一棵二叉树，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/kawht13x.png)

其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在 $1$ 处，则距离和 $=4+12+2\times20+2\times40=136$；若医院建在 $3$ 处，则距离和 $=4\times2+13+20+40=81$。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 100$，$0 \leq u, v \leq n$，$1 \leq w \leq 10^5$。

## 样例 #1

### 输入

```
5						
13 2 3
4 0 0
12 4 5
20 0 0
40 0 0
```

### 输出

```
81```

# AI分析结果

### 综合分析与结论

本题的核心问题是在一棵二叉树中找到最优的医院设置点，使得所有居民到该点的总距离最小。题解中主要采用了以下几种思路：

1. **暴力枚举 + DFS/BFS**：通过枚举每个节点作为医院设置点，计算总距离，时间复杂度为O(n^2)。这种方法思路简单，但效率较低，适合小规模数据。
2. **Floyd算法**：通过Floyd算法预处理所有节点对的最短路径，再枚举每个节点计算总距离，时间复杂度为O(n^3)。虽然Floyd算法在本题中能通过，但效率不高。
3. **树的重心 + 树形DP**：利用树的重心性质，通过两次DFS计算每个节点的总距离，时间复杂度为O(n)。这是最优解法，适合大规模数据。

### 所选高星题解

#### 题解1：Huami360 (5星)
**关键亮点**：
- 提出了树的重心性质，并利用树形DP在O(n)时间内解决问题。
- 详细解释了树的重心的定义和性质，帮助读者理解算法的核心思想。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
void dfs(int u, int fa, int dep) {
    size[u] = w[u];
    for(int i = head[u]; i; i = e[i].next) {
        if(e[i].to != fa)
            dfs(e[i].to, u, dep + 1), size[u] += size[e[i].to];
    }
    f[1] += w[u] * dep;
}

void dp(int u, int fa) {
    for(int i = head[u]; i; i = e[i].next)
        if(e[i].to != fa)
            f[e[i].to] = f[u] + size[1] - size[e[i].to] * 2, dp(e[i].to, u);
    ans = min(ans, f[u]);
}
```
**个人心得**：
- 作者提到“别人摸瓜她寻藤，别人摘叶他问根”，强调了深入理解问题本质的重要性。

#### 题解2：ShineEternal (4星)
**关键亮点**：
- 使用了Floyd算法预处理所有节点对的最短路径，思路清晰。
- 代码简洁，适合初学者理解Floyd算法的应用。

**核心代码**：
```cpp
for(int k=1; k<=n; k++)
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++)
            if(i!=k && j!=k && i!=j)
                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
```
**个人心得**：
- 作者提到“这是一道简单的二叉树应用问题”，强调了问题的本质是二叉树的最短路径问题。

#### 题解3：雪风舞者 (4星)
**关键亮点**：
- 使用BFS遍历每个节点，计算总距离，思路简单易懂。
- 代码结构清晰，适合初学者理解BFS的应用。

**核心代码**：
```cpp
int bfs(int x) {
    memset(v, 0, sizeof(v));
    queue<node> q;
    v[x] = 1;
    q.push((node){x, 0});
    int sum = 0;
    while(!q.empty()) {
        node now = q.front();
        q.pop();
        for(int i = 1; i <= n; i++)
            if(g[now.u][i] && !v[i]) {
                node next = {i, now.step + 1};
                sum += num[i] * next.step;
                v[i] = 1;
                q.push(next);
            }
    }
    return sum;
}
```
**个人心得**：
- 作者提到“第一次写题解好激动”，表达了对分享知识的热情。

### 最优关键思路与技巧

1. **树的重心性质**：树的重心是使得最大子树最小的节点，且所有点到重心的距离之和最小。利用这一性质，可以通过两次DFS在O(n)时间内找到最优解。
2. **树形DP**：通过一次DFS预处理子树大小和总距离，再通过一次DFS进行状态转移，计算每个节点的总距离。
3. **Floyd算法**：虽然时间复杂度较高，但在小规模数据中仍能有效解决问题，适合初学者理解最短路径算法。

### 可拓展之处

1. **类似问题**：类似的问题包括在树中找到最优的服务中心、仓库等，使得总距离最小。
2. **算法优化**：对于大规模数据，树的重心 + 树形DP是最优解法，而小规模数据可以使用Floyd或BFS等简单算法。

### 推荐题目

1. **P1395 会议**：在树中找到最优的会议地点，使得所有参会者的总距离最小。
2. **P2015 二叉苹果树**：在二叉树中选择边，使得保留的边的权值最大。
3. **P2014 选课**：在树中选择课程，使得总学分最大。

### 个人心得总结

- **深入理解问题本质**：如Huami360所强调的，理解树的重心性质是解决本题的关键。
- **代码简洁与清晰**：如ShineEternal和雪风舞者的代码，简洁清晰的代码更易于理解和调试。
- **分享与交流**：如雪风舞者所表达的，分享题解不仅能帮助他人，也能加深自己对问题的理解。

---
处理用时：42.82秒
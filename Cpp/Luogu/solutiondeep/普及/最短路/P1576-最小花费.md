# 题目信息

# 最小花费

## 题目描述

在 $n$ 个人中，某些人的银行账号之间可以互相转账。这些人之间转账的手续费各不相同。给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 $A$ 最少需要多少钱使得转账后 $B$ 收到 $100$ 元。

## 说明/提示

$1\le n \le 2000,m\le 100000$。

## 样例 #1

### 输入

```
3 3                                     
1 2 1
2 3 2
1 3 3
1 3
```

### 输出

```
103.07153164```

# AI分析结果

### 综合分析与结论

本题的核心是求从A到B的最小花费，本质上是求一条路径，使得转账后的手续费最小，即路径上的边权乘积最大。因此，问题可以转化为求最长路径问题。由于边权是乘法关系，且没有负权，Dijkstra算法和SPFA算法都可以用于解决该问题。题解中大部分使用了Dijkstra算法或SPFA算法，部分题解还进行了堆优化或优先队列优化。

### 题解评分与亮点

#### 1. 作者：_LanFeng_ (赞：62)
- **星级：4.5**
- **关键亮点**：使用了Dijkstra+堆优化，代码清晰，思路明确。通过优先队列实现堆优化，确保了算法的高效性。题解中还特别提醒了SPFA的潜在风险，推荐使用Dijkstra。
- **个人心得**：作者强调了SPFA的潜在危险，并推荐使用Dijkstra算法，体现了对算法选择的深刻理解。

```cpp
void Dij() {
    priority_queue<Node> q;
    Node temp;
    temp.Num = A;
    temp.dis = 1;
    q.push(temp);
    while (!q.empty()) {
        int u = q.top().Num;
        q.pop();
        if (mark[u]) continue;
        mark[u] = 1;
        for (int i = 0; i < G[u].size(); i++) {
            int v = G[u][i].Num;
            double l = G[u][i].dis;
            if (!mark[v] && dis[v] < dis[u] * l) {
                dis[v] = dis[u] * l;
                temp.Num = v;
                temp.dis = dis[v];
                q.push(temp);
            }
        }
    }
}
```

#### 2. 作者：The_Key (赞：48)
- **星级：4.0**
- **关键亮点**：使用了SPFA算法，思路清晰，代码简洁。通过将边权转化为1-z%，并利用SPFA的松弛操作求解最长路径。
- **个人心得**：作者提到SPFA虽然简单，但在某些情况下可能不稳定，体现了对算法选择的谨慎。

```cpp
void spfa() {
    queue<int> q;
    q.push(A);
    dis[A] = 1;
    vis[A] = true;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            if (dis[v] < dis[u] * edge[i].val) {
                dis[v] = dis[u] * edge[i].val;
                if (!vis[v]) {
                    q.push(v);
                    vis[v] = true;
                }
            }
        }
    }
}
```

#### 3. 作者：zjy111 (赞：44)
- **星级：4.0**
- **关键亮点**：使用了Dijkstra算法，并进行了堆优化。题解中详细解释了如何将问题转化为最长路径问题，并提供了代码实现。
- **个人心得**：作者在题解中强调了双向边的处理，提醒了代码实现中的常见错误。

```cpp
void dijkstra() {
    dis[a] = 1.0;
    q.push((node){1.0, a});
    while (!q.empty()) {
        node tmp = q.top();
        q.pop();
        int x = tmp.pos;
        if (vis[x]) continue;
        vis[x] = 1;
        for (int i = head[x]; i; i = e[i].nxt) {
            int y = e[i].to;
            if (dis[y] < dis[x] * e[i].dis) {
                dis[y] = dis[x] * e[i].dis;
                q.push((node){dis[y], y});
            }
        }
    }
}
```

### 最优关键思路与技巧

1. **问题转化**：将最小花费问题转化为最长路径问题，通过求路径上的边权乘积最大值来求解。
2. **算法选择**：Dijkstra算法和SPFA算法都可以用于求解该问题，Dijkstra算法更适合无负权图，SPFA算法在稀疏图中表现较好。
3. **堆优化**：使用优先队列或堆优化Dijkstra算法，提高算法效率。
4. **双向边处理**：在无向图中，双向边的处理是常见问题，需确保每条边都被正确处理。

### 可拓展之处

- **类似问题**：类似的问题可以出现在网络流、最短路径、最大流等场景中，核心思想是通过图论算法求解最优路径。
- **算法拓展**：可以尝试使用Floyd算法或Bellman-Ford算法解决类似问题，尤其是在边权为负数的情况下。

### 推荐题目

1. **P3371 【模板】单源最短路径（弱化版）**：考察Dijkstra算法的基本应用。
2. **P4779 【模板】单源最短路径（标准版）**：考察Dijkstra算法的堆优化实现。
3. **P3385 【模板】负环**：考察SPFA算法在负权图中的应用。

### 个人心得总结

- **调试经历**：部分题解中提到了调试过程中遇到的常见错误，如双向边的处理、精度问题等，提醒了在实现时需注意细节。
- **踩坑教训**：SPFA算法在某些情况下可能不稳定，推荐使用Dijkstra算法，尤其是在无负权图中。
- **顿悟感想**：通过将问题转化为最长路径问题，可以更直观地理解并解决该问题，体现了问题转化的巧妙性。

---
处理用时：41.98秒
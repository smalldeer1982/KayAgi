# 题目信息

# 炸铁路

## 题目描述

A 国派出将军 uim，对 B 国进行战略性措施，以解救涂炭的生灵。

B 国有 $n$ 个城市，这些城市以铁路相连。任意两个城市都可以通过铁路直接或者间接到达。

uim 发现有些铁路被毁坏之后，某两个城市无法互相通过铁路到达。这样的铁路就被称为 key road。

uim 为了尽快使该国的物流系统瘫痪，希望炸毁铁路，以达到存在某两个城市无法互相通过铁路到达的效果。

然而，只有一发炮弹（A 国国会不给钱了）。所以，他能轰炸哪一条铁路呢？


## 样例 #1

### 输入

```
6 6
1 2
2 3
2 4
3 5
4 5
5 6```

### 输出

```
1 2
5 6```

# AI分析结果

### 综合分析与结论

本题的核心是找到无向图中的“桥”（即割边），即删除后会导致图不连通的边。题解中主要采用了以下几种方法：

1. **Tarjan算法**：这是最经典且高效的方法，时间复杂度为O(n+m)，适用于大规模数据。通过DFS遍历图，记录每个节点的dfn和low值，判断是否为桥。
2. **并查集**：通过枚举每条边，删除后使用并查集判断图是否连通，时间复杂度为O(m^2)，适用于小规模数据。
3. **暴力DFS/BFS**：枚举每条边，删除后通过DFS或BFS判断图是否连通，时间复杂度较高，适用于数据范围较小的情况。

### 评分较高的题解

#### 1. 作者：abruce (赞：197) ⭐⭐⭐⭐⭐
**关键亮点**：
- 详细讲解了Tarjan算法的实现细节，尤其是dfn和low值的含义及其在判断桥中的应用。
- 代码结构清晰，注释详细，便于理解。
- 提供了图示帮助理解算法的执行过程。

**个人心得**：
- 通过图示和详细的解释，帮助读者理解Tarjan算法的核心思想，尤其是low值的更新过程。

**核心代码**：
```cpp
void tarjan(int x) {
    int c=0,y;
    dfn[x]=low[x]=++id;
    for(register int i=1; i<=n; i++) {
        if(!maps[x][i])continue;
        y=i;
        if(dfn[y]&&y!=f[x])low[x]=min(low[x],dfn[y]);
        if(!dfn[y]) {
            f[y]=x;
            tarjan(y);
            low[x]=min(low[x],low[y]);
            if(low[y]>dfn[x])addEdge(x,y);
        }
    }
}
```

#### 2. 作者：hsfzLZH1 (赞：65) ⭐⭐⭐⭐
**关键亮点**：
- 详细解释了Tarjan算法的原理，尤其是low值的更新规则。
- 代码简洁，使用了邻接表存储图，适合大规模数据。
- 提供了处理重边的方法，增强了代码的鲁棒性。

**核心代码**：
```cpp
void dfs(int cur,int fa) {
    int child;
    dfn[cur]=++index_;
    low[cur]=dfn[cur];
    for(int i=0;i<G[cur].size();i++) {
        child=G[cur][i];
        if(dfn[child]&&child!=fa)low[cur]=min(low[cur],dfn[child]);
        if(!dfn[child]) {
            dfs(child,cur);
            if(dfn[cur]<low[child])add_edge(cur,child);
            low[cur]=min(low[cur],low[child]);
        }
    }
}
```

#### 3. 作者：HRLYB (赞：16) ⭐⭐⭐⭐
**关键亮点**：
- 介绍了双连通分量的概念，并通过Tarjan算法求解。
- 提供了处理双向边标记的方法，避免了重复遍历。
- 代码结构清晰，注释详细，便于理解。

**核心代码**：
```cpp
void tarjan(int u) {
    deep+=1;
    dfn[u]=deep;
    low[u]=deep;
    top++;
    vis[u]=true;
    stac[top]=u;
    for(int i=head[u];i;i=e[i].next )
        if(!sign[i]){
            sign[i]=true,sign[i^1]=true;
            int v=e[i].v ;
            if(!dfn[v]){
                tarjan(v);
                if(low[v]<low[u])low[u]=low[v];
            }
            else {
                if(vis[v]){
                    if(low[v]<low[u])low[u]=low[v];
                }
            }
    }
    if(low[u]==dfn[u]){
        num+=1;
        vis[u]=false;
        color[u]=num;
        while(stac[top]!=u){
            color[stac[top]]=num;
            vis[stac[top]]=false;
            top--;
        }
        top--;
    }
}
```

### 最优关键思路与技巧

- **Tarjan算法**：通过DFS遍历图，记录每个节点的dfn和low值，判断是否为桥。这是解决此类问题的最优方法，时间复杂度低，适用于大规模数据。
- **并查集**：通过枚举每条边，删除后使用并查集判断图是否连通，适用于小规模数据。
- **双向边标记**：在处理无向图时，通过标记双向边，避免重复遍历，提高算法效率。

### 可拓展之处

- **双连通分量**：可以进一步学习双连通分量的概念及其应用，如求解无向图中的割点。
- **其他图论算法**：如Dijkstra、Floyd等最短路径算法，以及网络流等高级图论算法。

### 推荐题目

1. **P3388 【模板】割点**：考察割点的求解，与本题类似。
2. **P2860 [USACO06JAN]冗余路径Redundant Paths**：考察双连通分量的应用。
3. **P3387 【模板】缩点**：考察强连通分量的求解，与Tarjan算法相关。

### 个人心得总结

- **调试经历**：在处理无向图时，双向边的标记和更新是容易出错的地方，需要特别注意。
- **踩坑教训**：在枚举边时，要注意边的顺序和重复遍历的问题，避免不必要的计算。
- **顿悟感想**：通过图示和详细的解释，能够更好地理解算法的核心思想，尤其是low值的更新过程。

---
处理用时：43.84秒
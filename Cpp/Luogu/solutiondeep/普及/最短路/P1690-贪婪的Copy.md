# 题目信息

# 贪婪的Copy

## 题目描述

Copy 从卢牛那里听说在一片叫 yz 的神的领域埋藏着不少宝藏，于是 Copy 来到了这个被划分为 $n$ 个区域的神地。卢牛告诉了Copy这里共有 $n$ 个宝藏，分别放在第 $P_i$ 个 $(1\le P_i\le N)$ 区域。Copy还得知了每个区域之间的距离。现在 Copy 从 $1$ 号区域出发，要获得所有的宝藏并到 $n$ 号区域离开。Copy 很懒，只好来找你为他寻找一条合适的线路，使得他走过的距离最短。


## 说明/提示

- 对 $30\%$ 的数据，$1\le n\le 15$，其余如题所述。
- 对 $100\%$ 的数据，全部数据范围如题所述。


## 样例 #1

### 输入

```
2
0 4
5 0
2
1 2
```

### 输出

```
4
```

## 样例 #2

### 输入

```
3
0 2 6
1 0 4
7 10 0
1
2
```

### 输出

```
6
```

# AI分析结果

### 综合分析与结论

本题的核心是求解从起点出发，经过所有宝藏点，最终到达终点的最短路径。由于数据范围较小（n ≤ 100，p ≤ 10），大多数题解采用了Floyd算法预处理所有点对之间的最短路径，然后通过全排列枚举或DFS搜索所有可能的路径组合，最终求得最短路径。

#### 关键思路与技巧：
1. **Floyd算法**：用于预处理所有点对之间的最短路径，时间复杂度为O(n^3)，适合小规模数据。
2. **全排列枚举**：使用`next_permutation`或DFS枚举所有宝藏点的访问顺序，计算路径长度并更新最小值。
3. **DFS回溯**：通过DFS搜索所有可能的路径组合，结合回溯法避免重复计算。
4. **状压DP**：部分题解提到可以使用状压DP优化路径搜索，适用于p较小的情况。

#### 扩展思路：
- **TSP问题**：本题可以看作是旅行商问题（TSP）的变形，适合使用动态规划或启发式算法优化。
- **剪枝优化**：在DFS或枚举过程中，可以通过剪枝减少不必要的计算，提升效率。

### 所选高星题解

#### 1. 作者：The_Key (★★★★☆)
- **关键亮点**：使用Floyd算法预处理最短路径，结合`next_permutation`枚举所有路径组合，代码简洁且高效。
- **代码核心**：
  ```cpp
  for(int k=1;k<=n;k++)
      for(int i=1;i<=n;i++)
          for(int j=1;j<=n;j++)
              mp[i][j]=min(mp[i][j],mp[i][k]+mp[k][j]); // Floyd预处理
  sort(po+1,po+m+1);
  do {
      sum = mp[1][po[1]] + mp[po[m]][n];
      for(int i=1;i<m;i++) sum += mp[po[i]][po[i+1]];
      ans = min(ans, sum);
  } while(next_permutation(po+1,po+m+1)); // 全排列枚举
  ```

#### 2. 作者：αnonymous (★★★★☆)
- **关键亮点**：使用Floyd算法预处理，结合DFS回溯搜索所有路径组合，代码清晰且易于理解。
- **代码核心**：
  ```cpp
  void dfs(int now, int m, long long sum) {
      if(m == 0) ans = min(ans, sum + a[now][n]);
      else {
          for(int i=1; i<=p; i++) {
              if(!f[i]) {
                  f[i] = 1;
                  dfs(b[i], m-1, sum + a[now][b[i]]);
                  f[i] = 0; // 回溯
              }
          }
      }
  }
  ```

#### 3. 作者：DDOSvoid (★★★★☆)
- **关键亮点**：将问题转化为TSP问题，使用状压DP优化路径搜索，适合p较小的情况。
- **代码核心**：
  ```cpp
  for(int i=1; i<=M; i++)
      for(int j=1; j<=m; j++)
          if(i & (1<<(j-1)))
              for(int k=1; k<=m; k++)
                  if(!(i & (1<<(k-1))))
                      f[i|(1<<(k-1))][a[k]] = min(f[i|(1<<(k-1))][a[k]], f[i][a[j]] + map[a[j]][a[k]]); // 状压DP转移
  ```

### 推荐相似题目
1. **P1171 售货员的难题**（TSP问题，考察动态规划）
2. **P1433 吃奶酪**（最短路径+状态压缩，考察DFS与剪枝）
3. **P1040 加分二叉树**（树形DP，考察动态规划与回溯）

### 个人心得摘录
- **The_Key**：提到使用`next_permutation`简化了全排列的枚举过程，代码更易写且高效。
- **αnonymous**：强调DFS回溯的重要性，避免重复计算，提升搜索效率。
- **DDOSvoid**：将问题转化为TSP问题，使用状压DP优化路径搜索，适合p较小的情况。

### 总结
本题解展示了多种解决最短路径问题的思路，适合不同数据范围和优化需求。Floyd算法与全排列枚举的组合适合小规模数据，而DFS回溯和状压DP则提供了更高效的解决方案。

---
处理用时：34.84秒
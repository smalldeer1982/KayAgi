# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果

### 综合分析与结论

本题解主要围绕线段树的实现与优化展开，涉及区间加法、区间乘法、区间查询等操作。题解中大部分采用了线段树的模板，并针对乘法与加法的优先级问题进行了优化。整体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，但也有一些题解存在代码冗长、优化不足的问题。

### 所选高星题解

#### 题解1：作者：MashPlant (赞：7)
- **星级：★★★★★**
- **关键亮点**：
  - 通过位运算优化代码，提升效率。
  - 使用指针进行输入，进一步加速。
  - 代码结构清晰，注释详细，便于理解。
  - 通过宏定义简化代码，提高可读性。
- **个人心得**：
  - 作者提到通过指针和快读函数进行输入，显著提升了输入效率，这一点在实际应用中非常实用。
  - 通过宏定义简化代码，减少了代码冗余，提高了代码的可读性和可维护性。

#### 题解2：作者：FifthAxiom (赞：2)
- **星级：★★★★**
- **关键亮点**：
  - 使用结构体指针构建线段树，避免四倍内存问题。
  - 通过先乘后加的顺序处理标记，确保优先级正确。
  - 代码简洁，逻辑清晰，易于理解。
- **个人心得**：
  - 作者提到使用结构体指针构建线段树，避免了传统线段树四倍内存的问题，这一点在处理大规模数据时非常有用。

#### 题解3：作者：YuntianZhao (赞：1)
- **星级：★★★★**
- **关键亮点**：
  - 使用指针版线段树，动态分配节点，节省内存。
  - 通过先乘后加的顺序处理标记，确保优先级正确。
  - 代码简洁，逻辑清晰，易于理解。
- **个人心得**：
  - 作者提到使用指针版线段树，动态分配节点，节省内存，这一点在处理大规模数据时非常有用。

### 最优关键思路与技巧

1. **先乘后加的顺序处理标记**：在处理区间乘法和区间加法时，确保乘法优先级高于加法，避免标记混乱。
2. **使用指针和快读函数进行输入**：通过指针和快读函数进行输入，显著提升输入效率，特别适用于大规模数据。
3. **动态分配节点**：使用指针版线段树，动态分配节点，避免传统线段树四倍内存的问题，节省内存空间。

### 可拓展之处

1. **同类型题**：类似题目包括区间更新、区间查询等问题，如P3373【模板】线段树2、P5490【模板】扫描线等。
2. **类似算法套路**：线段树的优化技巧可以应用于其他树形数据结构，如树状数组、平衡树等。

### 推荐题目

1. **P3373【模板】线段树2**：考察线段树的区间更新与查询操作。
2. **P5490【模板】扫描线**：考察线段树在扫描线算法中的应用。
3. **P2572【SCOI2010】序列操作**：考察线段树在复杂区间操作中的应用。

### 核心代码片段

```cpp
void SegmentTree::pushdown(LL l, LL r, LL rt) {
  if (add[rt] || mul[rt] != 1) {
    LL mid = (l + r) >> 1;
    sum[lson] = mod(sum[lson] * mul[rt] + add[rt] * (mid - l + 1));
    sum[rson] = mod(sum[rson] * mul[rt] + add[rt] * (r - mid));
    add[lson] = mod(add[lson] * mul[rt] + add[rt]);
    add[rson] = mod(add[rson] * mul[rt] + add[rt]);
    mul[lson] = mod(mul[lson] * mul[rt]);
    mul[rson] = mod(mul[rson] * mul[rt]);
    mul[rt] = 1; add[rt] = 0;
  }
}
```

这段代码实现了线段树的下放操作，确保在更新和查询时，标记能够正确传递，并且处理了乘法与加法的优先级问题。

---
处理用时：51.43秒
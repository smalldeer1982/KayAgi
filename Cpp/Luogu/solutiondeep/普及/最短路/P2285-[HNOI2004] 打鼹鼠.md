# 题目信息

# [HNOI2004] 打鼹鼠

## 题目描述

鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。根据这个特点阿牛编写了一个打鼹鼠的游戏：在一个 $n \times n$ 的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果 $i$ 时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为 $(i, j)$ 的网格移向 $(i-1, j), (i+1, j), (i, j-1), (i, j+1)$ 四个网格，机器人不能走出整个 $n \times n$ 的网格。游戏开始时，你可以自由选定机器人的初始位置。

现在知道在一段时间内，鼹鼠出现的时间和地点，请编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。


## 样例 #1

### 输入

```
2 2	         

1 1 1		

2 2 2

```

### 输出

```
1
```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）求解机器人在给定时间内能够打到的最大鼹鼠数量。大多数题解都采用了类似最长上升子序列（LIS）的思路，通过计算曼哈顿距离和时间差来判断是否能够从一个鼹鼠位置转移到另一个位置，并进行状态转移。虽然部分题解尝试了优化（如倒序遍历、使用链表等），但整体上由于时间复杂度的限制，优化效果并不显著。

### 所选高星题解

#### 1. 作者：SIXIANG32 (5星)
- **关键亮点**：思路清晰，状态定义简洁，代码可读性强。通过一维DP状态转移，避免了三维状态的空间复杂度问题。
- **个人心得**：作者提到最初想到的是三维状态，但通过题解学习后意识到可以简化为一维状态，体现了对问题的深入理解。
- **核心代码**：
```cpp
for(int p = 1; p <= m; p++) {
    f[p] = 1;
    for(int i = 1; i < p; i++)
        if(dist(in[p].x, in[p].y, in[i].x, in[i].y) <= in[p].val - in[i].val)
            f[p] = max(f[p], f[i] + 1);
}
```
- **实现思想**：通过枚举每个鼹鼠作为起点，计算曼哈顿距离和时间差，进行状态转移。

#### 2. 作者：Konnyaku_ljc (4星)
- **关键亮点**：通过倒序遍历和降维优化，减少了时间复杂度，代码结构清晰。
- **核心代码**：
```cpp
for(int i = m; i > 1; i--)
    for(int j = i-1; j >= 1; j--)
        if(a[i].t - a[j].t >= abs(a[i].x - a[j].x) + abs(a[i].y - a[j].y))
            dp[j] = max(dp[i] + 1, dp[j]);
```
- **实现思想**：通过倒序遍历，减少重复计算，优化了状态转移的效率。

#### 3. 作者：Exber (4星)
- **关键亮点**：思路简洁，直接类比最长不下降子序列，代码实现简单明了。
- **核心代码**：
```cpp
for(int i = 1; i <= m; i++) {
    dp[i] = 1;
    for(int j = 1; j < i; j++)
        if(abs(mou[i].x - mou[j].x) + abs(mou[i].y - mou[j].y) <= mou[i].t - mou[j].t)
            dp[i] = max(dp[i], dp[j] + 1);
}
```
- **实现思想**：通过枚举每个鼹鼠，计算曼哈顿距离和时间差，进行状态转移。

### 最优关键思路与技巧

1. **状态定义**：使用一维DP状态 `f[i]` 表示以第 `i` 只鼹鼠结尾的序列能够打到的最大鼹鼠数量。
2. **状态转移**：通过计算曼哈顿距离和时间差，判断是否能够从一个鼹鼠位置转移到另一个位置，进行状态转移。
3. **优化技巧**：倒序遍历可以减少重复计算，提高效率。

### 可拓展之处

- **类似算法套路**：本题的DP思路与最长上升子序列（LIS）类似，可以应用于其他需要判断“是否可达”的DP问题。
- **同类型题目**：
  - P1020 导弹拦截（LIS问题）
  - P1091 合唱队形（双向LIS）
  - P1439 【模板】最长公共子序列（LCS问题）

### 个人心得总结

- **调试经历**：部分题解提到最初想到的是三维状态，但通过优化简化为一维状态，体现了对问题的深入理解。
- **踩坑教训**：部分题解尝试了优化（如倒序遍历、使用链表等），但整体上由于时间复杂度的限制，优化效果并不显著。
- **顿悟感想**：通过类比最长上升子序列，简化了问题的复杂度，体现了对问题的灵活处理能力。

---
处理用时：31.03秒
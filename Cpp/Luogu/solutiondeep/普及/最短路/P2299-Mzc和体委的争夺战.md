# 题目信息

# Mzc和体委的争夺战

## 题目背景

mzc 与 djn 第四弹。


## 题目描述

mzc 家很有钱（开玩笑），他家有 $n$ 个男家丁（做过前三弹的都知道）。但如此之多的男家丁吸引来了我们的体委（矮胖小伙），他要来与 mzc 争夺男家丁。

mzc 很生气，决定与其决斗，但 cat 的体力确实有些不稳定，所以他需要你来帮他计算一下最短需要的时间。


## 说明/提示

$1\le n \leq 2500$，$1\le m \leq 2\times10^5$，$1\le c_i\le 10^6$。

由于 mzc 大大十分着急，所以他只能等待 1s。


## 样例 #1

### 输入

```
5 8
1 2 3
2 3 4
3 4 5
4 5 6
1 3 4
2 4 7
2 5 8
1 5 100
```

### 输出

```
11```

# AI分析结果

### 综合分析与结论

本题是一个典型的单源最短路径问题，适合使用Dijkstra、SPFA、Bellman-Ford等算法解决。题解中主要使用了Dijkstra（包括堆优化）、SPFA、Bellman-Ford等算法，部分题解还涉及了邻接矩阵、邻接表、链式前向星等数据结构。整体来看，题解的质量参差不齐，部分题解代码可读性较差，优化不足，但也有一些题解思路清晰，代码简洁，具有一定的参考价值。

### 所选高质量题解

#### 1. **作者：利刃随人 (赞：7)**  
**星级：★★★★☆**  
**关键亮点：**  
- 使用了Dijkstra+堆优化，结合邻接表存储图结构，代码简洁且高效。
- 使用了STL中的优先队列，避免了手动实现堆的复杂性。
- 代码结构清晰，注释详细，适合初学者学习。

**核心代码：**
```cpp
void dijkstra() {
    priority_queue<node> q;
    for(int i=1; i<=n; i++) dis[i] = inf;
    dis[1] = 0;
    q.push((node){0, 1});
    while(!q.empty()) {
        node now = q.top(); q.pop();
        if(vis[now.jd]) continue;
        vis[now.jd] = true;
        for(int i=head[now.jd]; i; i=e[i].next) {
            if(dis[e[i].to] > dis[now.jd] + e[i].worth) {
                dis[e[i].to] = dis[now.jd] + e[i].worth;
                q.push((node){dis[e[i].to], e[i].to});
            }
        }
    }
}
```
**核心思想：**  
通过优先队列实现Dijkstra的堆优化，每次从队列中取出当前距离最小的节点进行松弛操作，确保每次更新都是当前最优解。

#### 2. **作者：Shikita (赞：1)**  
**星级：★★★★☆**  
**关键亮点：**  
- 使用了Dijkstra+堆优化，代码简洁且高效。
- 强调了无向图的双向边处理，避免了常见的错误。
- 代码结构清晰，注释详细，适合初学者学习。

**核心代码：**
```cpp
void dijkstra() {
    priority_queue<pair<int, int>> q;
    memset(d, 0x3f, sizeof(d));
    d[1] = 0;
    q.push({0, 1});
    while(!q.empty()) {
        int x = q.top().second; q.pop();
        if(vis[x]) continue;
        vis[x] = 1;
        for(int i=head[x]; i; i=Next[i]) {
            int y = ver[i], z = edge[i];
            if(d[y] > d[x] + z) {
                d[y] = d[x] + z;
                q.push({-d[y], y});
            }
        }
    }
}
```
**核心思想：**  
通过优先队列实现Dijkstra的堆优化，每次从队列中取出当前距离最小的节点进行松弛操作，确保每次更新都是当前最优解。

#### 3. **作者：Drug__Lover (赞：1)**  
**星级：★★★★☆**  
**关键亮点：**  
- 使用了Dijkstra算法，结合邻接矩阵存储图结构，代码简洁且高效。
- 强调了无向图的双向边处理，避免了常见的错误。
- 代码结构清晰，注释详细，适合初学者学习。

**核心代码：**
```cpp
for(int i=1; i<=n; i++) {
    int k=0, minn=0x7fffff;
    for(int j=1; j<=n; j++) {
        if(!vis[j] && dis[j] < minn) {
            minn = dis[j];
            k = j;
        }
    }
    if(k == 0) break;
    vis[k] = 1;
    for(int j=1; j<=n; j++) {
        dis[j] = min(dis[j], dis[k] + f[k][j]);
    }
}
```
**核心思想：**  
通过遍历所有节点找到当前距离最小的节点进行松弛操作，确保每次更新都是当前最优解。

### 最优关键思路与技巧总结

1. **堆优化Dijkstra**：使用优先队列（堆）优化Dijkstra算法，能够显著提高算法的效率，尤其是在稀疏图中。
2. **双向边处理**：在无向图中，边的存储需要双向处理，避免遗漏或错误。
3. **邻接表与邻接矩阵的选择**：根据图的稀疏程度选择合适的存储结构，稀疏图适合邻接表，稠密图适合邻接矩阵。

### 可拓展之处

1. **负权边处理**：如果图中存在负权边，Dijkstra算法不再适用，可以考虑使用SPFA或Bellman-Ford算法。
2. **多源最短路径**：如果需要求解多源最短路径，可以考虑使用Floyd-Warshall算法。

### 推荐题目

1. **P4779 【模板】单源最短路径（标准版）**  
   - 考察Dijkstra算法的实现与优化。
2. **P3371 【模板】单源最短路径（弱化版）**  
   - 考察SPFA算法的实现与应用。
3. **P5905 【模板】Johnson 全源最短路径**  
   - 考察全源最短路径的求解方法，适合进阶学习。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现双向边处理不当导致WA，强调了无向图中双向边的重要性。
- **踩坑教训**：部分题解提到在邻接矩阵存储时未处理重边，导致结果错误，强调了在存储图时需要注意重边处理。
- **顿悟感想**：通过堆优化Dijkstra算法，能够显著提高算法的效率，尤其是在稀疏图中，优先队列的使用简化了代码实现。

---
处理用时：41.20秒
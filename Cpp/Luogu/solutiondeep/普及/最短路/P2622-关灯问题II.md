# 题目信息

# 关灯问题II

## 题目描述

现有 $n$ 盏灯，以及 $m$ 个按钮。每个按钮可以同时控制这 $n$ 盏灯——按下了第 $i$ 个按钮，对于所有的灯都有一个效果。按下 $i$ 按钮对于第 $j$ 盏灯，是下面 $3$ 中效果之一：如果 $a_{i,j}$ 为 $1$，那么当这盏灯开了的时候，把它关上，否则不管；如果为 $-1$ 的话，如果这盏灯是关的，那么把它打开，否则也不管；如果是 $0$，无论这灯是否开，都不管。

现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。

## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 数据，输出无解可以得分。
- 对于 $20\%$ 数据，$n \le 5$。
- 对于 $20\%$ 数据，$m \le 20$。

上面的数据点可能会重叠。

对于 $100\%$ 数据 $n \le 10,m \le 100$。

## 样例 #1

### 输入

```
3
2
1 0 1
-1 1 0```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是通过状态压缩和广度优先搜索（BFS）来求解最少操作次数。所有灯的状态可以用一个二进制数表示，每个按钮的操作可以看作是对状态的转换。通过BFS，可以从初始状态（所有灯都亮）逐步探索所有可能的状态，直到找到目标状态（所有灯都灭）。由于状态数最多为 \(2^{10} = 1024\)，BFS的复杂度是可接受的。

### 题解评分与亮点

#### 题解1：作者：niiick (赞：53)
- **评分：5星**
- **亮点**：
  - 思路清晰，详细解释了状态压缩和BFS的结合。
  - 代码结构清晰，位运算的使用非常到位。
  - 通过位运算实现了状态的快速转换，效率高。
- **核心代码**：
  ```cpp
  for(int i=1;i<=m;i++) {
      ss=(1<<n)-1;
      for(int j=1;j<=n;j++) {
          if( a[i][j]==1 && (ss&(1<<j-1)) ) ss^=(1<<j-1);
          else if( a[i][j]==-1 && !(ss&(1<<j-1)) ) ss|=(1<<j-1);
      }      
  }
  ```
  **实现思想**：通过位运算快速计算每个按钮操作后的新状态。

#### 题解2：作者：pzc2004 (赞：23)
- **评分：4星**
- **亮点**：
  - 使用了记忆化BFS，避免了重复状态的计算。
  - 代码简洁，逻辑清晰。
  - 通过状态压缩和BFS的结合，实现了高效的搜索。
- **核心代码**：
  ```cpp
  for(int i=1;i<=m;i++) {
      int x=b;
      for(int j=1;j<=n;j++) {
          if(a[i][j]==0)continue;
          if(a[i][j]==1)x&=(1<<n)-1-(1<<(j-1));
          if(a[i][j]==-1)x|=1<<(j-1);
      }
      if(x==0){printf("%d",f[b]+1);return 0;}
      if(f[b]+1<f[x]) {
          f[x]=f[b]+1;
          q.push(x);
      }
  }
  ```
  **实现思想**：通过位运算和记忆化BFS，快速找到最短路径。

#### 题解3：作者：浅色调 (赞：23)
- **评分：4星**
- **亮点**：
  - 使用了状压DP的思路，虽然BFS更合适，但思路新颖。
  - 代码结构清晰，位运算的使用得当。
  - 通过位运算实现了状态的快速转换。
- **核心代码**：
  ```cpp
  for(int i=1;i<=m;i++) {
      int sta=(u|a[i])&(~b[i]);
      if(f[sta]>f[u]+1) {
          f[sta]=f[u]+1;
          if(!vis[sta]) vis[sta]=1,q.push(sta);
      }
  }
  ```
  **实现思想**：通过位运算和状态转移，实现了状态的快速更新。

### 最优关键思路与技巧

1. **状态压缩**：将灯的状态用二进制数表示，方便进行位运算。
2. **BFS**：通过广度优先搜索，从初始状态逐步探索所有可能的状态，直到找到目标状态。
3. **位运算**：通过位运算快速计算每个按钮操作后的新状态，提高效率。

### 可拓展之处

- **同类型题**：类似的状态压缩和BFS结合的题目，如“八数码问题”、“拼图游戏”等。
- **类似算法套路**：状态压缩+搜索（BFS/DFS）是解决状态空间较小的问题的常用套路。

### 推荐题目

1. **P1379 八数码难题**：考察状态压缩和BFS的结合。
2. **P2324 [SCOI2005] 骑士精神**：状态压缩+IDA*的经典题目。
3. **P2831 愤怒的小鸟**：状态压缩+动态规划的题目。

### 个人心得摘录

- **调试经历**：在实现位运算时，注意位数的顺序，避免出错。
- **踩坑教训**：在BFS中，记得标记已访问的状态，避免重复计算。
- **顿悟感想**：状态压缩和BFS的结合是解决这类问题的利器，理解其原理后，代码实现并不复杂。

---
处理用时：38.30秒
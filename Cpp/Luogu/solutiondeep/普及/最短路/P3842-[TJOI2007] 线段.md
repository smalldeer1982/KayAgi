# 题目信息

# [TJOI2007] 线段

## 题目描述

在一个 $n \times n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是$(i, L_{i})$，右端点是$(i, R_{i})$。

你从 $(1,1)$ 点出发，要求沿途走过所有的线段，最终到达 $(n,n)$ 点，且所走的路程长度要尽量短。

更具体一些说，你在任何时候只能选择向下走一步（行数增加 $1$）、向左走一步（列数减少 $1$）或是向右走一步（列数增加 $1$）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。

## 说明/提示

我们选择的路线是

```
 (1, 1) (1, 6)
 (2, 6) (2, 3)
 (3, 3) (3, 1)
 (4, 1) (4, 2)
 (5, 2) (5, 6)
 (6, 6) (6, 4) (6, 6)
```
不难计算得到，路程的总长度是 $24$。 

对于 $100\%$ 的数据中，$n \le 2 \times 10^4$，$1 \le L_i \le R_i \le n$。

## 样例 #1

### 输入

```
6
2 6
3 4
1 3
1 2
3 6
4 5```

### 输出

```
24```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）来计算从起点到终点的最短路径，要求遍历每一行的线段。大多数题解采用了相似的DP思路，定义 `f[i][0]` 和 `f[i][1]` 分别表示在第 `i` 行结束时位于左端点或右端点的最短路径。转移方程主要考虑从上一行的左端点或右端点转移到当前行的左端点或右端点，并加上当前线段的长度和移动步数。

尽管大多数题解思路相似，但在代码实现、优化程度和解释清晰度上存在差异。部分题解通过滚动数组优化空间复杂度，或通过预处理减少计算量，提升了代码的效率。此外，部分题解在解释转移方程时更加详细，有助于理解DP的核心思想。

### 所选高星题解

#### 1. 作者：Huami360 (★★★★★)
**关键亮点**：
- 思路清晰，直接定义了 `f[i][0]` 和 `f[i][1]`，并详细解释了转移方程。
- 代码简洁，使用了 `min` 函数简化了转移方程的书写，易于理解。
- 通过预处理 `len[i]` 减少重复计算，提升了代码效率。

**核心代码**：
```cpp
f[i][0] = min(f[i-1][0] + abs(l[i-1] - r[i]) + r[i] - l[i] + 1, 
              f[i-1][1] + abs(r[i-1] - r[i]) + r[i] - l[i] + 1);
f[i][1] = min(f[i-1][0] + abs(l[i-1] - l[i]) + r[i] - l[i] + 1, 
              f[i-1][1] + abs(r[i-1] - l[i]) + r[i] - l[i] + 1);
```

#### 2. 作者：pzc2004 (★★★★☆)
**关键亮点**：
- 详细解释了DP的初始化过程，特别是第一行的处理。
- 使用了 `dis` 函数来计算距离，代码可读性较高。
- 通过 `min` 函数简化了转移方程的书写，逻辑清晰。

**核心代码**：
```cpp
f[i][0] = min(f[i-1][0] + abs(l[i-1] - r[i]) + r[i] - l[i] + 1, 
              f[i-1][1] + abs(r[i-1] - r[i]) + r[i] - l[i] + 1);
f[i][1] = min(f[i-1][0] + abs(l[i-1] - l[i]) + r[i] - l[i] + 1, 
              f[i-1][1] + abs(r[i-1] - l[i]) + r[i] - l[i] + 1);
```

#### 3. 作者：Tarsal (★★★★☆)
**关键亮点**：
- 使用了滚动数组优化空间复杂度，适合大规模数据。
- 代码结构清晰，通过 `i % 2` 实现了滚动数组的切换。
- 详细解释了滚动数组的实现原理，有助于理解空间优化技巧。

**核心代码**：
```cpp
f[i % 2][0] = min(f[(i % 2) ^ 1][0] + abs(l[i % 2] - r[(i % 2) ^ 1]), 
                  f[(i % 2) ^ 1][1] + abs(r[(i % 2) ^ 1] - r[i % 2])) + 1 + r[i % 2] - l[i % 2];
f[i % 2][1] = min(f[(i % 2) ^ 1][0] + abs(l[i % 2] - l[(i % 2) ^ 1]), 
                  f[(i % 2) ^ 1][1] + abs(r[(i % 2) ^ 1] - l[i % 2])) + 1 + r[i % 2] - l[i % 2];
```

### 最优关键思路与技巧

1. **DP状态定义**：定义 `f[i][0]` 和 `f[i][1]` 分别表示在第 `i` 行结束时位于左端点或右端点的最短路径。
2. **转移方程**：通过上一行的左端点或右端点转移到当前行的左端点或右端点，并加上当前线段的长度和移动步数。
3. **空间优化**：使用滚动数组减少空间复杂度，适合大规模数据。
4. **预处理**：通过预处理 `len[i]` 减少重复计算，提升代码效率。

### 拓展与举一反三

1. **类似题目**：
   - [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)：同样涉及DP和路径规划。
   - [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的背包问题，与DP思想相关。
   - [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)：涉及状态转移和DP优化。

2. **调试与顿悟**：
   - 在调试过程中，部分题解提到通过画图理解转移方程，尤其是从上一行的左端点或右端点转移到当前行的左端点或右端点的路径。这种直观的方法有助于理解复杂的DP转移。

### 推荐题目
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)

---
处理用时：43.21秒
# 题目信息

# 道路重建

## 题目描述

从前，在一个王国中，在 $n$ 个城市间有 $m$ 条道路连接，而且任意两个城市之间至多有一条道路直接相连。在经过一次严重的战争之后，有 $d$ 条道路被破坏了。国王想要修复国家的道路系统，现在有两个重要城市 $A$ 和 $B$ 之间的交通中断，国王希望尽快的恢复两个城市之间的连接。你的任务就是修复一些道路使 $A$ 与 $B$ 之间的连接恢复，并要求修复的道路长度最小。

## 样例 #1

### 输入

```
3
2
1 2 1
2 3 2
1
1 2
1 3```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在修复被破坏的道路后，找到从城市A到城市B的最小修复代价。大多数题解都采用了将未破坏的道路权值设为0，破坏的道路权值保持不变，然后通过最短路径算法（如Floyd、Dijkstra、SPFA等）求解最小修复代价。这种思路简洁有效，且易于实现。

### 所选高星题解

#### 1. 作者：xiaolou (5星)
**关键亮点**：
- 使用了Floyd算法，代码简洁清晰，适合小规模数据。
- 通过将未破坏的道路权值设为0，直接求解最小修复代价。
- 代码注释详细，易于理解。

**核心代码**：
```cpp
void floyd(int n) {
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                h[i][j]=min(h[i][j],h[i][k]+h[k][j]);
}
```
**实现思想**：通过Floyd算法计算所有城市对之间的最短路径，未破坏的道路权值为0，破坏的道路权值保持不变。

#### 2. 作者：EarthGiao (4星)
**关键亮点**：
- 提供了三种方法（Floyd、SPFA、Dijkstra），适合不同场景。
- 详细解释了每种方法的思路，代码可读性高。
- 通过标记未破坏的道路，简化了问题。

**核心代码**：
```cpp
void SPFA() {
    queue<int> q;
    q.push(A);
    for(register int i = 1;i <= n;++i) dis[i] = 999;
    dis[A] = 0;
    while(!q.empty()) {
        int qwq = q.front(); q.pop(); use[qwq] = false;
        for(register int i = head[qwq];i != 0;i = a[i].ne) {
            int awa = a[i].y;
            if(dis[awa] > dis[qwq] + a[i].z) {
                dis[awa] = dis[qwq] + a[i].z;
                if(!use[awa]) { use[awa] = true; q.push(awa); }
            }
        }
    }
}
```
**实现思想**：通过SPFA算法求解最短路径，未破坏的道路权值为0，破坏的道路权值保持不变。

#### 3. 作者：BILL666 (4星)
**关键亮点**：
- 使用了Dijkstra算法，适合稀疏图。
- 通过优先队列优化了Dijkstra算法，提高了效率。
- 代码结构清晰，注释详细。

**核心代码**：
```cpp
void DIJ() {
    priority_queue<pair<int,int> > q;
    q.push(make_pair(0,A));
    dis[A] = 0;
    while(!q.empty()) {
        int u = q.top().second; q.pop();
        if(use[u]) continue; use[u] = true;
        for(int i = head[u];i;i = edge[i].next) {
            int v = edge[i].to;
            if(dis[v] > dis[u] + edge[i].w) {
                dis[v] = dis[u] + edge[i].w;
                q.push(make_pair(dis[v],v));
            }
        }
    }
}
```
**实现思想**：通过Dijkstra算法求解最短路径，未破坏的道路权值为0，破坏的道路权值保持不变。

### 最优关键思路与技巧

1. **权值设置**：将未破坏的道路权值设为0，破坏的道路权值保持不变，简化了问题。
2. **最短路径算法**：根据数据规模选择合适的算法（Floyd适合小规模，Dijkstra和SPFA适合大规模）。
3. **优先队列优化**：在Dijkstra算法中使用优先队列，提高效率。

### 可拓展之处

- **同类型题**：类似的问题可以扩展到其他网络优化问题，如最小生成树、最大流等。
- **算法套路**：最短路径算法的优化思路（如优先队列、松弛操作）可以应用于其他图论问题。

### 推荐题目

1. **P3371 【模板】单源最短路径（弱化版）** - 练习Dijkstra和SPFA算法。
2. **P4779 【模板】单源最短路径（标准版）** - 进一步练习最短路径算法。
3. **P3385 【模板】负环** - 学习如何处理负权边和负环。

### 个人心得总结

- **调试经历**：多位作者提到在处理无向图时忘记双向建边，导致WA。提醒我们在处理无向图时要注意双向边的处理。
- **顿悟感想**：通过将未破坏的道路权值设为0，问题简化为标准的最短路径问题，这种思路非常巧妙且实用。

---
处理用时：42.02秒
# 题目信息

# Geodetic集合

## 题目描述

图 $\text G$ 是一个无向连通图，没有自环，并且两点之间至多只有一条边。我们定义顶点 $v,u$ 的最短路径就是从 $v$ 到 $u$ 经过边最少的路径。所有包含在 $v-u$ 的最短路径上的顶点被称为 $v-u$ 的 Geodetic 顶点，这些顶点的集合记作 $I(v,u)$。

我们称集合 $I(v,u)$ 为一个 Geodetic 集合。

例如下图中，$I(2,5)=\{2,3,4,5\}$，$I(1,5)=\{1,3,5\}$，$I(2,4)=\{2,4\}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/26c7a19d.png)

给定一个图 $\text G$ 和若干点对 $v,u$，请你分别求出 $I(v,u)$。

## 说明/提示

对于所有数据，满足 $1\leqslant n\leqslant 40$，$1\leqslant m\leqslant \frac{n(n-1)}2$。

## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 5
4 5
3
2 5
5 1
2 4```

### 输出

```
2 3 4 5
1 3 5
2 4```

# AI分析结果

### 综合分析与结论

本题的核心是求解无向连通图中任意两点间的最短路径上的所有顶点集合。题解中主要采用了以下几种算法：

1. **SPFA/BFS/Dijkstra**：通过单源最短路径算法（如SPFA、BFS或Dijkstra）分别计算起点和终点的最短路径，然后遍历所有点，判断是否满足最短路径的条件。
2. **Floyd**：利用Floyd算法预处理所有点对之间的最短路径，然后对于每个查询，遍历所有点，判断是否在最短路径上。

大部分题解的思路较为相似，核心都是通过最短路径算法找到满足条件的点。SPFA/BFS/Dijkstra适用于单源最短路径，而Floyd适用于多源最短路径。由于题目中n≤40，Floyd的O(n³)复杂度完全可以接受，且代码实现较为简洁。

### 所选高星题解

#### 1. 作者：06ray (4星)
- **关键亮点**：使用SPFA算法计算单源最短路径，思路清晰，代码结构合理，且通过两次SPFA分别计算起点和终点的最短路径，最后遍历所有点判断是否在最短路径上。
- **代码核心**：
  ```cpp
  void spfa(int s) {
      queue<int>q;
      fill(d+1,d+n+1,100000000);
      fill(used+1,used+n+1,false);
      d[s]=0;
      used[s]=true;
      q.push(s);
      while(!q.empty()) {
          int v=q.front();
          q.pop();
          used[v]=false;
          for(int i=0; i<G[v].size(); i++) {
              node e=G[v][i];
              if(d[v]+e.cost<d[e.to]) {
                  d[e.to]=d[v]+e.cost;
                  if(!used[e.to]) {
                      q.push(e.to);
                      used[e.to]=true;
                  }
              }
          }
      }
  }
  ```
  **核心思想**：通过SPFA计算单源最短路径，遍历所有点判断是否在最短路径上。

#### 2. 作者：かなで (4星)
- **关键亮点**：使用BFS算法，记录每个点的前驱节点，最后从终点倒推得到最短路径上的所有点。思路新颖，代码简洁。
- **代码核心**：
  ```cpp
  void bfs(int s,int t) {
      memset(num,0,sizeof num),memset(dis,63,sizeof dis);
      dis[s]=0,q.push(s);
      while(!q.empty()) {
          s=q.front(),q.pop();
          for(int i=1;i<=n;i++) if(a[s][i])
              if(dis[i]>dis[s]+1)
                  dis[i]=dis[s]+1,pre[i][++num[i]]=s,q.push(i);
              else if(dis[i]==dis[s]+1) pre[i][++num[i]]=s;
      }
      memset(ans,0,sizeof ans),q.push(t),ans[t]=1;
      while(!q.empty()) {
          s=q.front(),q.pop();
          for(int i=num[s];i;i--) if(!ans[pre[s][i]])
              ans[pre[s][i]]=1,q.push(pre[s][i]);
      }
      for(int i=1;i<=n;i++) if(ans[i]) printf("%d ",i);
  }
  ```
  **核心思想**：通过BFS记录前驱节点，从终点倒推得到最短路径上的所有点。

#### 3. 作者：_Blue_ (4星)
- **关键亮点**：使用Floyd算法预处理所有点对之间的最短路径，然后对于每个查询，遍历所有点判断是否在最短路径上。代码简洁，思路清晰。
- **代码核心**：
  ```cpp
  for(int k=1;k<=n;k++) {
      for(int i=1;i<=n;i++) {
          for(int j=1;j<=n;j++) {
              if(i==j||i==k||j==k) continue;
              f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
              f[j][i]=min(f[j][i],f[j][k]+f[k][i]);
          }
      }
  }
  ```
  **核心思想**：通过Floyd算法预处理所有点对之间的最短路径，遍历所有点判断是否在最短路径上。

### 最优关键思路与技巧

1. **Floyd算法的优势**：由于题目中n≤40，Floyd的O(n³)复杂度完全可以接受，且代码实现简洁，适合多源最短路径问题。
2. **SPFA/BFS/Dijkstra的适用性**：对于单源最短路径问题，SPFA、BFS或Dijkstra都是不错的选择，尤其是BFS在无权图中效率较高。
3. **前驱节点的记录**：通过记录每个点的前驱节点，可以从终点倒推得到最短路径上的所有点，这种方法在BFS中尤为有效。

### 可拓展之处

1. **多源最短路径问题**：Floyd算法在处理多源最短路径问题时非常有效，尤其是在n较小的情况下。
2. **单源最短路径问题**：SPFA、BFS或Dijkstra适用于单源最短路径问题，BFS在无权图中效率更高。
3. **路径记录与回溯**：通过记录前驱节点，可以从终点倒推得到最短路径上的所有点，这种方法在BFS中尤为有效。

### 推荐题目

1. **P3371 【模板】单源最短路径（弱化版）**：练习单源最短路径算法。
2. **P4779 【模板】单源最短路径（标准版）**：进一步练习单源最短路径算法。
3. **P1144 最短路计数**：结合最短路和路径计数，拓展思维。

### 个人心得摘录

- **06ray**：通过两次SPFA分别计算起点和终点的最短路径，最后遍历所有点判断是否在最短路径上，思路清晰，代码结构合理。
- **かなで**：使用BFS记录前驱节点，从终点倒推得到最短路径上的所有点，思路新颖，代码简洁。
- **_Blue_**：使用Floyd算法预处理所有点对之间的最短路径，然后对于每个查询，遍历所有点判断是否在最短路径上，代码简洁，思路清晰。

---
处理用时：49.22秒
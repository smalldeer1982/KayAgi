# 题目信息

# 【模板】单源最短路径（标准版）

## 题目背景

2018 年 7 月 19 日，某位同学在 [NOI Day 1 T1 归程](https://www.luogu.org/problemnew/show/P4768) 一题里非常熟练地使用了一个广为人知的算法求最短路。

然后呢？

$100 \rightarrow 60$；

$\text{Ag} \rightarrow \text{Cu}$；

最终，他因此没能与理想的大学达成契约。

小 F 衷心祝愿大家不再重蹈覆辙。

## 题目描述

给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。

数据保证你能从 $s$ 出发到任意点。

## 说明/提示

样例解释请参考 [数据随机的模板题](https://www.luogu.org/problemnew/show/P3371)。

$1 \leq n \leq 10^5$；

$1 \leq m \leq 2\times 10^5$；

$s = 1$；

$1 \leq u_i, v_i\leq n$；

$0 \leq w_i \leq 10 ^ 9$,

$0 \leq \sum w_i \leq 10 ^ 9$。

本题数据可能会持续更新，但不会重测，望周知。

2018.09.04 数据更新 from @zzq

## 样例 #1

### 输入

```
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4```

### 输出

```
0 2 4 3```

# AI分析结果

### 综合分析与结论

这些题解大多围绕Dijkstra算法的优化展开，尤其是堆优化（优先队列）的实现。部分题解还涉及链式前向星、STL的优先队列、以及一些优化技巧（如剪枝、堆的维护等）。整体来看，题解质量参差不齐，部分题解思路清晰、代码规范，而有些则较为简略或存在冗余。以下是对部分高质量题解的总结与推荐。

### 精选题解

#### 1. **作者：little_sun (赞：1077)**
   - **星级：5星**
   - **关键亮点**：详细解释了Dijkstra算法的原理、堆优化的实现，并提供了图解和代码实现。代码结构清晰，注释详细，适合初学者理解。
   - **个人心得**：作者强调了Dijkstra算法在处理正权图时的稳定性，并对比了SPFA的局限性。
   - **核心代码**：
     ```cpp
     void dijkstra() {
         dis[s] = 0;
         q.push((node){0, s});
         while (!q.empty()) {
             node tmp = q.top();
             q.pop();
             int x = tmp.pos;
             if (vis[x]) continue;
             vis[x] = 1;
             for (int i = head[x]; i; i = e[i].next) {
                 int y = e[i].to;
                 if (dis[y] > dis[x] + e[i].dis) {
                     dis[y] = dis[x] + e[i].dis;
                     if (!vis[y]) q.push((node){dis[y], y});
                 }
             }
         }
     }
     ```
   - **实现思想**：使用优先队列维护当前最小距离的点，确保每次取出的点是最优的。

#### 2. **作者：installb (赞：65)**
   - **星级：4.5星**
   - **关键亮点**：介绍了Dijkstra算法的堆优化，并详细解释了优先队列的使用。代码简洁，适合有一定基础的读者。
   - **核心代码**：
     ```cpp
     void dijkstra(int s) {
         dis[s] = 0;
         q.push((node){0, s});
         while (!q.empty()) {
             node now = q.top();
             q.pop();
             int u = now.id;
             if (vis[u]) continue;
             vis[u] = 1;
             for (int i = head[u]; i; i = e[i].next) {
                 int v = e[i].to;
                 if (dis[v] > dis[u] + e[i].w) {
                     dis[v] = dis[u] + e[i].w;
                     q.push((node){dis[v], v});
                 }
             }
         }
     }
     ```
   - **实现思想**：通过优先队列优化Dijkstra，确保每次取出的点是最优的。

#### 3. **作者：GKxx (赞：93)**
   - **星级：4星**
   - **关键亮点**：使用线段树优化Dijkstra，提供了详细的代码实现和解释，适合对线段树有一定了解的读者。
   - **核心代码**：
     ```cpp
     void dijkstra(int s) {
         dis

---
处理用时：43.57秒
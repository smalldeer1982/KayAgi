# 题目信息

# [USACO05MAR] Checking an Alibi 不在场的证明

## 题目描述

农场有 $F$ 个点，已知 $P$ 条边以及每条边的起点终点和通过时间，给出 $C$ 个有牛的点，求在规定时间 $M$ 内能从起点到达牛当前位置的牛的数量，并按升序输出牛的编号。

谷仓里发现谷物被盗！FJ 正试图从 $C$ 只奶牛里找出那个偷谷物的罪犯。幸运的是，一个恰好路过的卫星拍下谷物被盗前 $M$ 秒的农场的图片。这样约翰就能通过牛们的位置来判断谁有足够的时间来盗窃谷物。

约翰农场有 $F$ 草地，标号 $1$ 到 $F$，还有 $P$ 条双向路连接着它们。通过这些路需要的时间在 $1$ 到 $70000$ 秒的范围内。田地 $1$ 上建有那个被盗的谷仓。给出农场地图，以及卫星照片里每只牛所在的位置，请判断哪些牛有可能犯罪。

请注意：数据里可能存在重边（起点和终点相同的边）。

## 说明/提示

#### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/ik4552lc.png)

#### 数据约定

对于 $100\%$ 的数据：$1 \le M \le 70000$，$1 \le C \le 100$，$1 \le P \le 1000$，$1 \le F \le 500$。

## 样例 #1

### 输入

```
7 6 5 8
1 4 2
1 2 1
2 3 6
3 5 5
5 4 6
1 7 9
1
4
5
3
7```

### 输出

```
4
1
2
3
4```

# AI分析结果

### 综合分析与结论

本题的核心是求解单源最短路径，判断每个奶牛所在位置到起点1的最短路径是否在规定时间M内。题解中主要使用了Dijkstra、SPFA等最短路算法，部分题解还提到了BFS和Floyd算法。整体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，而有些则显得冗长或不够优化。

### 所选高星题解

#### 1. 作者：WanderingTrader (赞：5)
- **星级**: 5星
- **关键亮点**: 使用Dijkstra算法，代码简洁且提供了堆优化版本，思路清晰，注释详细。
- **核心代码**:
  ```cpp
  void dijkstra(int n, int s) {
      fill(ok, ok+1+n, false);
      fill(d, d+1+n, inf);
      d[s] = 0;
      for (int i = 1; i <= n; ++i) {
          int u = 0;
          for (int j = 1; j <= n; ++j) if (!ok[j] && d[j] < d[u]) u = j;
          ok[u] = true;
          for (int j = h[u]; j; j = e[j].next) {
              int v = e[j].v;
              d[v] = min(d[u] + e[j].w, d[v]);
          }
      }
  }
  ```
- **总结**: 该题解不仅提供了朴素Dijkstra的实现，还提到了堆优化版本，适合不同数据规模的需求，代码可读性强。

#### 2. 作者：爱晚亭哦 (赞：1)
- **星级**: 4星
- **关键亮点**: 使用SPFA算法，代码简洁，适合初学者理解。
- **核心代码**:
  ```cpp
  void spfa() {
      for (int i = 1; i <= F; i++) {
          dis[i] = MAXN;
          vis[i] = 0;
      }
      queue<int> t;
      t.push(1);
      dis[1] = 0;
      vis[1] = 1;
      while (!t.empty()) {
          int u = t.front();
          t.pop();
          vis[u] = 0;
          for (int i = head[u]; i; i = nx[i]) {
              int v = to[i];
              if (dis[v] > dis[u] + w[i]) {
                  dis[v] = dis[u] + w[i];
                  if (!vis[v]) {
                      vis[v] = 1;
                      t.push(v);
                  }
              }
          }
      }
  }
  ```
- **总结**: 该题解使用SPFA算法，代码简洁易懂，适合对SPFA算法不熟悉的读者。

#### 3. 作者：FutureThx (赞：1)
- **星级**: 4星
- **关键亮点**: 使用Dijkstra算法，代码注释详细，适合初学者理解。
- **核心代码**:
  ```cpp
  void dijkstra(int n, int s) {
      fill(ok, ok+1+n, false);
      fill(d, d+1+n, inf);
      d[s] = 0;
      for (int i = 1; i <= n; ++i) {
          int u = 0;
          for (int j = 1; j <= n; ++j) if (!ok[j] && d[j] < d[u]) u = j;
          ok[u] = true;
          for (int j = h[u]; j; j = e[j].next) {
              int v = e[j].v;
              d[v] = min(d[u] + e[j].w, d[v]);
          }
      }
  }
  ```
- **总结**: 该题解提供了Dijkstra算法的详细实现，注释清晰，适合初学者学习。

### 最优关键思路与技巧

1. **单源最短路算法选择**: 对于本题，Dijkstra和SPFA都是不错的选择，Dijkstra适合边权为正的图，而SPFA则适合边权可能为负的图。
2. **堆优化**: 在数据规模较大时，使用堆优化的Dijkstra算法可以显著提高效率。
3. **反向思维**: 将起点设为1，计算所有点到1的最短路径，而不是从每个奶牛的位置出发，这样可以减少计算量。

### 可拓展之处

- **类似算法套路**: 单源最短路问题在竞赛中非常常见，类似的题目如网络延迟时间、最短路径计数等。
- **BFS的应用**: 在边权相同的情况下，BFS也可以用于求解最短路问题。

### 推荐题目

1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1629 邮递员送信](https://www.luogu.com.cn/problem/P1629)

### 个人心得摘录

- **WanderingTrader**: "此题的数据范围很小，所以朴素版和堆优化版的都可以。" 提醒我们在不同数据规模下选择合适的算法。
- **爱晚亭哦**: "不卡SPFA的出题人都是好人qwq" 反映了SPFA在某些情况下可能被卡，但在本题中表现良好。

### 总结

本题解中，Dijkstra和SPFA是主要使用的算法，堆优化和反向思维是提升效率的关键。对于初学者，建议从朴素Dijkstra或SPFA入手，逐步掌握堆优化等高级技巧。

---
处理用时：41.31秒
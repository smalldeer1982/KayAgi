# 题目信息

# [Cnoi2020] 雷雨

## 题目背景

> 令人不安的云开始笼罩天空。  
巨大的建筑在强风中轧轧作响。  
幻想乡中响彻着不和协音。  
——「东方辉针城 ～ Double Dealing Character」

一个雷雨交加的夜晚，一束闪电击中了雾之湖畔的红魔馆和迷途竹林。

似乎有什么大事要发生，Cirno 在小屋静静地中思考着。

## 题目描述

幻想乡的纵切面可以抽象成一个 $n\times m$ 的矩形。

其中每一个 $1\times 1$ 的单元格 $(i,j)$ 都有一个**电阻计量值**(虚构的概念) $R_{i,j}$。

闪电从**雷雨云**上的 $\texttt{O}(n,a)$ 发出，击中了**地面**上的*红魔馆* $\texttt{A}(1,b)$ 与*迷途竹林* $\texttt{B}(1,c)$。

雷电是自然的造物，所以覆盖的位置电阻计量值总和最小，即从 $\texttt{O}$ 到 $\texttt{A}$ 与 $\texttt{B}$ 的**两条路径的并集**的电阻计量值的和最小。

所以在所有位置电阻计量已知的情况下，Cirno 想知道雷电的经过的路径的最小电阻计量值的和。

## 说明/提示

## 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/7ozs40i3.png)

如图黄色线为闪电的路径。

## 数据范围与约定

对于 $100\%$ 的数据保证：$0<n,m \le 1000$，$0 \le R_{i,j}\le 10^9$，$0< a,b,c \le m$。

#### 子任务「本题采用捆绑测试」

 - Subtask1（$10\%$）: $R_{i,j}\in\{1\}$。
 - Subtask2（$10\%$）: $R_{i,j}\in\{0,1\}$。
 - Subtask3（$10\%$）: $a=b=c$。
 - Subtask4（$10\%$）: $n,m \le 5$。
 - Subtask5（$60\%$）: 无特殊限制。
 

## 样例 #1

### 输入

```
5 5 1 2 4
1 8 1 6 6
1 1 1 2 4
8 3 1 2 2
1 2 1 9 1
1 0 9 1 1```

### 输出

```
15```

# AI分析结果

### 综合分析与结论

本题的核心在于寻找从起点到两个终点的路径并集的最小电阻值。多数题解采用了**枚举分叉点**的策略，并通过**三次最短路**（Dijkstra或BFS）预处理每个点到起点和两个终点的最短路径，最终通过枚举所有可能的交叉点来求解最小值。这种方法的时间复杂度为 \(O(nm \log(nm))\)，能够有效处理题目中的最大数据范围。

### 评分较高的题解

#### 1. 作者：Lonely_NewYear (5星)
**关键亮点**：
- **思路清晰**：明确提出了枚举分叉点的策略，并通过三次Dijkstra预处理最短路径，最后通过枚举交叉点求解最小值。
- **代码简洁**：代码结构清晰，使用了优先队列优化Dijkstra，避免了复杂的实现细节。
- **优化提示**：强调了不开`long long`会导致错误，提醒了常见陷阱。

**核心代码**：
```cpp
void dijkstra(int k, int sx, int sy) {
    priority_queue<node> q;
    q.push((node){sx, sy, num[sx][sy]});
    bool vis[1001][1001] = {0};
    for(int i=1; i<=1000; i++) {
        for(int j=1; j<=1000; j++) {
            dis[k][i][j] = 1e18;
        }
    }
    dis[k][sx][sy] = num[sx][sy];
    while(!q.empty()) {
        int x = q.top().x, y = q.top().y;
        q.pop();
        if(vis[x][y]) continue;
        vis[x][y] = 1;
        for(int i=0; i<4; i++) {
            int tx = x + dx[i], ty = y + dy[i];
            if(tx<1 || tx>n || ty<1 || ty>m) continue;
            if(dis[k][tx][ty] > dis[k][x][y] + num[tx][ty]) {
                dis[k][tx][ty] = dis[k][x][y] + num[tx][ty];
                q.push((node){tx, ty, dis[k][tx][ty]});
            }
        }
    }
}
```
**实现思想**：通过优先队列实现Dijkstra算法，计算从起点到每个点的最短路径。

#### 2. 作者：InformationEntropy (4星)
**关键亮点**：
- **思路明确**：提出了分叉点的概念，并通过三次Dijkstra预处理最短路径，最后枚举交叉点求解最小值。
- **代码优化**：使用了方向数组代替前向星，减少了代码复杂度。
- **调试提示**：强调了SPFA已死，提醒使用Dijkstra+堆优化。

**核心代码**：
```cpp
void dijkstra(int sx, int sy, int p) {
    priority_queue<node> q;
    q.push((node){sx, sy, ma[sx][sy]});
    memset(vis, 0, sizeof(vis));
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=m; j++) {
            dis[p][i][j] = inf;
        }
    }
    dis[p][sx][sy] = ma[sx][sy];
    while(!q.empty()) {
        node now = q.top(); q.pop();
        int x = now.x, y = now.y;
        if(vis[x][y]) continue;
        vis[x][y] = 1;
        for(int i=0; i<4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if(nx<1 || nx>n || ny<1 || ny>m || vis[nx][ny]) continue;
            dis[p][nx][ny] = min(dis[p][nx][ny], dis[p][x][y] + ma[nx][ny]);
            q.push((node){nx, ny, dis[p][nx][ny]});
        }
    }
}
```
**实现思想**：通过优先队列实现Dijkstra算法，计算从起点到每个点的最短路径。

#### 3. 作者：Rubidium_Chloride (4星)
**关键亮点**：
- **思路清晰**：提出了分叉点的概念，并通过三次BFS预处理最短路径，最后枚举交叉点求解最小值。
- **代码优化**：使用了优先队列BFS，减少了代码复杂度。
- **调试提示**：强调了SPFA已死，提醒使用Dijkstra+堆优化。

**核心代码**：
```cpp
void bfs(ll t, ll tx, ll ty) {
    fill(vst[0], vst[0] + N*N, 0);
    priority_queue<NODE> q;
    q.push((NODE){tx, ty, dst[t][tx][ty]});
    while(!q.empty()) {
        NODE x = q.top(); q.pop();
        if(vst[x.x][x.y]) continue;
        vst[x.x][x.y] = 1;
        for(int i=0; i<4; i++) {
            ll nx = x.x + dx[i], ny = x.y + dy[i];
            if(nx<1 || nx>n || ny<1 || ny>m || vst[nx][ny]) continue;
            dst[t][nx][ny] = min(dst[t][nx][ny], dst[t][x.x][x.y] + r[nx][ny]);
            q.push((NODE){nx, ny, dst[t][nx][ny]});
        }
    }
}
```
**实现思想**：通过优先队列实现BFS，计算从起点到每个点的最短路径。

### 最优关键思路或技巧

1. **枚举分叉点**：通过枚举所有可能的交叉点，将问题转化为三次最短路的预处理和一次枚举计算。
2. **Dijkstra+堆优化**：使用优先队列优化Dijkstra算法，确保在网格图中高效求解最短路径。
3. **方向数组**：使用方向数组代替前向星，简化了代码实现。

### 可拓展之处

类似的问题可以推广到多个起点或多个终点的路径优化问题，或者在有障碍物的网格图中寻找最短路径。这类问题通常可以通过多次最短路预处理和枚举交叉点来解决。

### 推荐题目

1. [P5683 [CSPJX2019] 道路拆除](https://www.luogu.com.cn/problem/P5683)
2. [P4779 [模板] 单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P3371 [模板] 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)

### 个人心得摘录

- **Lonely_NewYear**：强调了不开`long long`会导致错误，提醒了常见陷阱。
- **InformationEntropy**：强调了SPFA已死，提醒使用Dijkstra+堆优化。
- **Rubidium_Chloride**：强调了SPFA已死，提醒使用Dijkstra+堆优化。

---
处理用时：53.06秒
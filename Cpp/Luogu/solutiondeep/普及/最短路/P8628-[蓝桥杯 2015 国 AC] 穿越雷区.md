# 题目信息

# [蓝桥杯 2015 国 AC] 穿越雷区

## 题目描述

$X$ 星的坦克战车很奇怪，它必须交替地穿越正能量辐射区和负能量辐射区才能保持正常运转，否则将报废。

某坦克需要从 $A$ 区到 $B$ 区去（$A$，$B$ 区本身是安全区，没有正能量或负能量特征），怎样走才能路径最短？

已知的地图是一个方阵，上面用字母标出了 $A$，$B$ 区，其它区都标了正号或负号分别表示正负能量辐射区。

例如：

```
A + - + -
- + - - +
- + + + -
+ - + - +
B + - + -
```

坦克车只能水平或垂直方向上移动到相邻的区。


## 说明/提示

时限 1 秒, 512M。蓝桥杯 2015 年第六届国赛

## 样例 #1

### 输入

```
5
A + - + -
- + - - +
- + + + -
+ - + - +
B + - + -```

### 输出

```
10```

# AI分析结果

### 综合分析与结论

本题的核心是通过 BFS 或 DFS 寻找从起点 A 到终点 B 的最短路径，且路径上的每一步必须交替经过正负能量辐射区。题解中主要采用了 BFS 和 DFS 两种算法，部分题解还提到了 Dijkstra 算法。BFS 由于天然适合求解最短路径问题，因此在本题中表现更为高效。DFS 虽然也能求解，但在最坏情况下可能会遍历所有路径，效率较低。

### 所选高星题解

#### 1. 作者：fish_love_cat (★★★★★)
**关键亮点：**
- 使用 BFS 算法，直接求解最短路径，代码简洁高效。
- 通过 `f` 数组存储辐射区能量正负极，`b` 数组标记已访问点，避免重复访问。
- 代码逻辑清晰，易于理解。

**核心代码：**
```cpp
int bfs() {
    wz a;
    a.x = sx; a.y = sy; a.ans = 0;
    q.push(a);
    b[sx][sy] = false;
    while (!q.empty()) {
        a = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            wz xin;
            xin.x = a.x + gx[i];
            xin.y = a.y + gy[i];
            xin.ans = a.ans + 1;
            if (xin.x == ex && xin.y == ey) return xin.ans;
            if (b[xin.x][xin.y] && f[xin.x][xin.y] != f[a.x][a.y]) {
                q.push(xin);
                b[xin.x][xin.y] = false;
            }
        }
    }
    return -1;
}
```
**实现思想：** 使用 BFS 从起点开始，每次向四个方向扩展，确保下一步的辐射区与当前不同，直到找到终点。

#### 2. 作者：Dreamer_Boy (★★★★)
**关键亮点：**
- 同样使用 BFS，结构清晰，代码可读性强。
- 通过 `st` 结构体存储坐标和步数，便于队列操作。
- 在扩展时判断是否到达终点，直接输出步数。

**核心代码：**
```cpp
void bfs(int x, int y) {
    queue<st> q;
    q.push(st(x, y, 0));
    v[x][y] = true;
    while (!q.empty()) {
        st k = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            int nx = k.x + dxy[i][0], ny = k.y + dxy[i][1];
            if (check(nx, ny) && !v[nx][ny] && a[k.x][k.y] != a[nx][ny]) {
                if (a[nx][ny] == 'B') {
                    cout << k.step + 1;
                    return;
                }
                v[nx][ny] = true;
                q.push(st(nx, ny, k.step + 1));
            }
        }
    }
    cout << -1 << endl;
}
```
**实现思想：** 使用 BFS 从起点开始，每次扩展时判断下一步是否合法且与当前辐射区不同，直到找到终点。

#### 3. 作者：Iniaugoty (★★★★)
**关键亮点：**
- 使用 Dijkstra 算法，虽然本题 BFS 更合适，但该解法展示了如何将问题转化为图论问题。
- 通过链式前向星存图，优化了图的存储和访问。
- 代码结构清晰，适合学习图论算法的同学。

**核心代码：**
```cpp
void dijkstra(int x) {
    memset(vis, 0, sizeof vis);
    memset(dis, inf, sizeof dis);
    priority_queue<node> pq;
    pq.push(node{x, 0});
    dis[x] = 0;
    while (!pq.empty()) {
        int t = pq.top().u, d = dis[t] + 1;
        pq.pop();
        if (vis[t]) continue;
        vis[t] = 1;
        for (int i = head[t]; i; i = e[i].next) {
            int y = e[i].to;
            if (dis[y] > d) {
                dis[y] = d;
                pq.push(node{y, d});
            }
        }
    }
}
```
**实现思想：** 将问题转化为图论问题，使用 Dijkstra 算法求解最短路径。

### 最优关键思路与技巧
- **BFS 是最优选择**：由于 BFS 天然适合求解最短路径问题，且本题的路径限制（交替经过正负能量辐射区）可以通过简单的条件判断实现，因此 BFS 是最优算法。
- **状态标记**：通过 `vis` 数组标记已访问的点，避免重复访问，提高效率。
- **方向数组**：使用方向数组简化代码，便于向四个方向扩展。

### 拓展与举一反三
- **类似题目**：可以尝试解决其他迷宫类问题，如 [P1141 01 迷宫](https://www.luogu.com.cn/problem/P1141)、[P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)、[P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)。

### 个人心得摘录
- **fish_love_cat**：提到本题是“01 迷宫”的弱化版，BFS 直接套用即可，无需复杂优化。
- **Dreamer_Boy**：强调了在扩展时判断下一步是否合法且与当前辐射区不同，避免无效搜索。

### 推荐题目
1. [P1141 01 迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

---
处理用时：39.83秒
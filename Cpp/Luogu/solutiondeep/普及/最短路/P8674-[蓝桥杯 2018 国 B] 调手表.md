# 题目信息

# [蓝桥杯 2018 国 B] 调手表

## 题目描述

小明买了块高端大气上档次的电子手表，他正准备调时间呢。

在 M78 星云，时间的计量单位和地球上不同，M78 星云的一个小时有 $n$ 分钟。

大家都知道，手表只有一个按钮可以把当前的数加一。在调分钟的时候，如果当前显示的数是 $0$，那么按一下按钮就会变成 $1$，再按一次变成 $2$。如果当前的数是 $n-1$，按一次后会变成 $0$。

作为强迫症患者，小明一定要把手表的时间调对。如果手表上的时间比当前时间多 $1$，则要按 $n-1$ 次加一按钮才能调回正确时间。

小明想，如果手表可以再添加一个按钮，表示把当前的数加 $k$ 该多好啊……

他想知道，如果有了这个 $+k$ 按钮，按照最优策略按键，从任意一个分钟数调到另外任意一个分钟数最多要按多少次。

注意，按 $+k$ 按钮时，如果加 $k$ 后数字超过 $n-1,$ 则会对 $n$ 取模。

比如，$n=10,k=6$ 的时候，假设当前时间是 $0$，连按 $2$ 次 $+k$ 按钮，则调为 $2$。


## 说明/提示

**【样例解释】**

如果时间正确则按 $0$ 次。否则要按的次数和操作系列之间的关系如下：
1. +1
2. +1, +1
3. +3
4. +3, +1

**【数据约定】**

对于 $30\%$ 的数据 $0<k<n \le 5$。

对于 $60\%$ 的数据 $0<k<n \le 100$。

对于 $100\%$ 的数据 $0<k<n \le 10^5$。

时限 3 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
5 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是求从任意时间调到另一个时间的最少按键次数，且每次操作可以是加1或加k，并对n取模。大多数题解都采用了广度优先搜索（BFS）来求解，因为BFS适合在无权图中寻找最短路径，且时间复杂度为O(n)，能够满足题目要求。部分题解还提到了最短路算法（如Dijkstra），但由于边的权值相同，BFS更为高效。

### 所选高分题解

#### 1. 作者：Nuyoah_awa (5星)
- **关键亮点**：思路清晰，直接将问题转化为图论中的最短路径问题，使用BFS求解，代码简洁且易于理解。
- **个人心得**：通过将问题转化为从0到任意时间的最短路径，简化了问题的复杂度。
- **核心代码**：
```cpp
while(!q.empty()) {
    x = q.front();
    q.pop();
    ans = max(ans, t[x]);
    y1 = (x + k) % n, y2 = (x + 1) % n;
    if(!cnt[y1]) {
        t[y1] = t[x] + 1, cnt[y1] = true;
        q.push(y1);
    }
    if(!cnt[y2]) {
        t[y2] = t[x] + 1, cnt[y2] = true;
        q.push(y2);
    }
}
```
- **核心思想**：通过BFS遍历所有可能的时间点，记录从0到每个时间点的最短按键次数，最终取最大值。

#### 2. 作者：Maysoul (4星)
- **关键亮点**：提供了多种解法（BFS、Dijkstra、DFS），并详细分析了每种解法的适用场景，代码实现较为完整。
- **核心代码**：
```cpp
void bfs() {
    while(!que.empty()) {
        int now = que.front();
        que.pop();
        ans = max(ans, num[now]);
        if(!vis[(now + 1) % n]) {
            que.push((now + 1) % n);
            num[(now + 1) % n] = num[now] + 1;
            vis[(now + 1) % n] = 1;
        }
        if(!vis[(now + k) % n]) {
            que.push((now + k) % n);
            num[(now + k) % n] = num[now] + 1;
            vis[(now + k) % n] = 1;
        }
    }
}
```
- **核心思想**：通过BFS遍历所有时间点，记录从0到每个时间点的最短按键次数，最终取最大值。

#### 3. 作者：carp_oier (4星)
- **关键亮点**：代码简洁，直接使用BFS求解，且对取模操作进行了优化，避免了重复计算。
- **核心代码**：
```cpp
while(!q.empty()) {
    ll u = q.front();
    q.pop();
    ll v1 = mod(u + k), v2 = mod(u + 1);
    if(!dis[v1]) dis[v1] = dis[u] + 1, q.push(v1);
    if(!dis[v2]) dis[v2] = dis[u] + 1, q.push(v2);
}
```
- **核心思想**：通过BFS遍历所有时间点，记录从0到每个时间点的最短按键次数，最终取最大值。

### 最优关键思路与技巧
1. **问题转化**：将问题转化为从0到任意时间的最短路径问题，简化了问题的复杂度。
2. **BFS的应用**：由于边的权值相同，BFS是最优的选择，时间复杂度为O(n)。
3. **取模优化**：通过取模操作避免了重复计算，提高了代码的效率。

### 可拓展之处
- **类似算法套路**：类似的问题可以转化为图论中的最短路径问题，使用BFS或Dijkstra求解。
- **同类型题目**：可以尝试解决其他涉及最短路径或状态转移的问题，如迷宫问题、状态机问题等。

### 推荐题目
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
2. [P1608 路径统计](https://www.luogu.com.cn/problem/P1608)
3. [P1359 租用游艇](https://www.luogu.com.cn/problem/P1359)

### 个人心得总结
- **调试经历**：在BFS中，确保每个节点只被访问一次，避免重复计算。
- **踩坑教训**：在取模操作时，注意边界条件，避免数组越界。
- **顿悟感想**：将问题转化为图论中的最短路径问题，能够大大简化问题的复杂度。

---
处理用时：34.43秒
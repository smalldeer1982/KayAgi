# 题目信息

# [蓝桥杯 2022 国 B] 出差

## 题目描述

$\mathrm{A}$ 国有 $N$ 个城市，编号为 $1 \ldots N$ 小明是编号为 $1$ 的城市中一家公司的员工，今天突然接到了上级通知需要去编号为 $N$ 的城市出差。

由于疫情原因，很多直达的交通方式暂时关闭，小明无法乘坐飞机直接从城市 $1$ 到达城市 $N$，需要通过其他城市进行陆路交通中转。小明通过交通信息网，查询到了 $M$ 条城市之间仍然还开通的路线信息以及每一条路线需要花费的时间。

同样由于疫情原因，小明到达一个城市后需要隔离观察一段时间才能离开该城市前往其他城市。通过网络，小明也查询到了各个城市的隔离信息。（由于小明之前在城市 $1$，因此可以直接离开城市 $1$，不需要隔离）

由于上级要求，小明希望能够尽快赶到城市 $\mathrm{N}$, 因此他求助于你，希望你能帮他规划一条路线，能够在最短时间内到达城市 $N$ 。


## 说明/提示

**【样例说明】**

![](https://cdn.mathpix.com/cropped/2022_09_29_8ee8d95d6d0319bca20dg-09.jpg?height=464&width=478&top_left_y=1249&top_left_x=309)

**【评测用例规模与约定】**

对于 $100 \%$ 的数据, $1 \leq N \leq 1000,1 \leq M \leq 10000,1 \leq C_{i} \leq 200,1 \leq u, v \leq$ $N, 1 \leq c \leq 1000$ 


蓝桥杯 2022 国赛 B 组 E 题。

## 样例 #1

### 输入

```
4 4
5 7 3 4
1 2 4
1 3 5
2 4 3
3 4 5```

### 输出

```
13```

# AI分析结果

### 综合分析与结论

本题的核心是求解带点权的单源最短路径问题。所有题解均采用了Dijkstra算法，且都通过将点权（隔离时间）附加到边权上来处理隔离问题。最终输出时需要减去终点城市的隔离时间，因为终点不需要隔离。

### 所选高星题解

#### 1. **Strelizia_Qy (5星)**
- **关键亮点**：
  - 使用`vector`存图，代码简洁易读。
  - 详细解释了将隔离时间附加到边权的思路，逻辑清晰。
  - 使用了堆优化的Dijkstra算法，时间复杂度为$O(m \log m)$，适合本题数据范围。
- **个人心得**：
  - 提到“因为目的地不需要隔离，所以输出时减去城市N的隔离时间”，强调了这一关键点。

**核心代码**：
```cpp
void dijkstra() {
    for(int i=1;i<=n;i++) dis[i]=inf,vis[i]=0;
    dis[1]=0;
    priority_queue<pii,vector<pii>,greater<pii>> p;
    p.push({0,1});
    while(!p.empty()) {
        int u=p.top().second; p.pop();
        if(vis[u]) continue;
        vis[u]=1;
        for(int i=0;i<G[u].size();i++) {
            int cost=G[u][i].second, v=G[u][i].first;
            if(dis[v]>dis[u]+cost) {
                dis[v]=dis[u]+cost;
                p.push({dis[v],v});
            }
        }
    }
}
```

#### 2. **Zvelig1205 (4星)**
- **关键亮点**：
  - 使用了链式前向星存图，适合对内存敏感的场景。
  - 详细解释了Dijkstra算法的实现，并提供了SPFA作为备选方案。
  - 代码结构清晰，注释详细。
- **个人心得**：
  - 提到“SPFA也是可做的，跑得比dij还要快一点”，提供了额外的优化思路。

**核心代码**：
```cpp
void ins(int x,int y,int z) {
    nex[++cnt]=fir[x];
    poi[cnt]=y;
    val[cnt]=z;
    fir[x]=cnt;
}
```

#### 3. **__Cartesian__Tree__ (4星)**
- **关键亮点**：
  - 使用了链式前向星存图，并强调了双向边需要开两倍空间。
  - 详细解释了Dijkstra算法的实现，代码结构清晰。
  - 强调了“到达$n$点是无需隔离，减去$c[n]$”这一关键点。
- **个人心得**：
  - 提到“双向边，链式前向星开两倍空间”，提醒了常见的编码陷阱。

**核心代码**：
```cpp
void add(int u, int v, int w) {
    e[ecnt].v = v;
    e[ecnt].w = w;
    e[ecnt].nxt = head[u];
    head[u] = ecnt++;
}
```

### 最优关键思路与技巧

1. **点权处理**：将隔离时间附加到边权上，统一处理点权和边权，简化了问题的复杂度。
2. **堆优化Dijkstra**：使用优先队列优化Dijkstra算法，时间复杂度为$O(m \log m)$，适合本题数据范围。
3. **终点处理**：最终输出时减去终点城市的隔离时间，因为终点不需要隔离。

### 可拓展之处

1. **负边权处理**：如果题目中存在负边权，可以考虑使用SPFA算法。
2. **多源最短路**：如果题目要求多源最短路，可以使用Floyd算法。

### 推荐题目

1. **P3371 【模板】单源最短路径（弱化版）** - 考察Dijkstra算法的基本实现。
2. **P4779 【模板】单源最短路径（标准版）** - 考察堆优化Dijkstra算法。
3. **P3385 【模板】负环** - 考察SPFA算法及其在负权图中的应用。

### 个人心得总结

- **调试经历**：多位作者强调了双向边需要开两倍空间，提醒了常见的编码陷阱。
- **踩坑教训**：多位作者提到终点不需要隔离，强调了这一关键点，避免输出错误。
- **顿悟感想**：通过将点权附加到边权上，简化了问题的复杂度，这一思路值得借鉴。

---
处理用时：31.17秒
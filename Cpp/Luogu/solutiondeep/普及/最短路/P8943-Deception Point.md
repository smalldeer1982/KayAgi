# 题目信息

# Deception Point

## 题目背景

“防空火网已启用。”三角洲二号喊道，他坐在“基奥瓦”武装直升机舱门边的武器控制椅里，竖起了大拇指，“火力网
、调制噪声、掩护脉冲全都激活并锁定。”

三角洲一号心领神会，驾驶着飞机猛地向右一个侧弯飞机又驶上了一条前往“戈雅”的直线路径。这一招能躲过“戈雅”的雷达监控。

“锡箔包确定！”三角洲二号喊道。

> 绝对的孤立，

三角洲一号想。

> 他们毫无抵抗力。

他们的目标幸运且狡猾地从米尔恩冰架上逃脱了，但这回他们不会再得逞了。雷切尔 · 塞克斯顿和迈克尔 · 托兰选择弃岸上船，真是糟糕的选择。不过，这将是他们所做的最后一个坏决定了。

## 题目描述

雷切尔与迈克尔被困在了“戈雅”号上，而三角洲二号正在顺着雷达追杀二人。幸运的是，雷切尔也有一副雷达，因此双方都能知道对方的位置。

船舱内部共有 $n$ 个舱室，其中有 $n$ 条走廊连接这些舱室。$n$ 个舱室是互相连通的。由于船上空间拥挤，船舱内不会出现小于等于四条走廊组成的环。每过一分钟，雷切尔与三角洲二号都会同时从一个舱室跑到另一个舱室。

如果雷切尔在舱室内或者过道上碰到了三角洲，那么就意味着大限将至。雷切尔总共有 $q$ 个问题：当她在舱室 $x$，且三角洲二号在舱室 $y$ 时，她是否可以存活下来？

---

#### **【形式化题意】**

给定一张 $n$ 个点 $n$ 条边的无向连通图，图内不存在四元（及以下）环。$q$ 次询问 $x,y$，分别在图上 $x,y$ 点上放上棋子 $\rm A, B$。

每次两人同时操作棋子沿图边移动一步，若两棋子同时走到了同一个点上或者同时走过了相同的边，则 $\rm B$ 胜利。如果在 $10^{10^{9961}}$ 次操作后 $\rm B$ 还未胜利，则 $\rm A$ 胜利。

$\rm A,B$ 都是绝顶聪明的，他们不会做出对自己不利的决策。请你求出每次游戏的游戏结果。若 $\rm A$ 获胜，输出 `Survive`；否则输出 `Deception`。

**若对题意有疑问，请移步样例解释与数据范围部分。**

## 说明/提示

#### 【样例解释】

船舱结构图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/tlsqnsia.png)

在第二组询问中，三角洲可以先走一步到达结点 $2$，此时雷切尔到达结点 $4$。随后可以证明，不存在一种方案使得雷切尔不碰到三角洲。

#### 【数据范围】

**本题开启捆绑测试。**

| $\text{Subtask}$ | 分值 | $n\le$ | $q\le$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $5$ | $2\times10^5$ | $1$ | 无 |
| $1$ | $5$ | $10$ | $2\times10^5$ | 无 |
| $2$ | $5$ | $2\times 10^5$ | $2\times10^5$ | $\forall 1\le i\le n, u_i=i,v_i=(i\bmod n) + 1$ |
| $3$ | $15$ | $200$ | $2\times 10^5$ | 无 |
| $4$ | $20$ | $2\times 10^3$ | $2\times 10^5$ | 无 |
| $5$ | $50$ | $2\times 10^5$ | $2\times 10^5$ | 无 |

对于 $100\%$ 的数据，$3\le n\le 2\times10^5$，$1\le q\le2\times10^5$，$u_i\neq v_i$，$x_i\neq y_i$。不存在四（及以下）元环。

## 样例 #1

### 输入

```
8 3
2 1
3 1 
4 2 
5 3
6 2
7 5
8 4
5 6
7 8
8 6
3 6```

### 输出

```
Survive
Deception
Survive
```

# AI分析结果

### 综合分析与结论

本题的核心是处理基环树（基环树是指一个连通图，包含一个环，其余部分为树结构）。题解的主要思路是通过预处理，找到环上的点，并计算每个点到环的距离及进入环的入口点。通过比较A和B到环的距离，判断A是否能逃脱。大多数题解采用了DFS或拓扑排序来找到环，并通过BFS或DFS计算距离。部分题解还优化了环上点之间的距离计算，使用标号或相对距离来减少时间复杂度。

### 题解评分与亮点

#### 1. 作者：HYdroKomide (赞：14)
- **星级**: 4.5
- **关键亮点**: 
  - 通过DFS找到环，并标记环上的点。
  - 使用DFS预处理每个点到环的距离及进入环的入口点。
  - 通过环上点的标号计算环上两点之间的距离，优化了时间复杂度。
- **个人心得**: 作者提到“充分发挥人类智慧”，强调了基环树的性质，并详细解释了如何通过预处理来简化问题。
- **核心代码**:
  ```cpp
  void dfs1(int x, int fa) {
      if (vis[x]) {
          fd = x;
          cir[x] = true;
          sw[x] = ++cnt;
          return;
      }
      vis[x] = true;
      for (int i = 0; i < g[x].size(); i++) {
          int v = g[x][i];
          if (v != fa) dfs1(v, x);
          if (fd != 0) {
              if (fd == x) fd = 0;
              if (!cir[x]) {
                  cir[x] = true;
                  sw[x] = ++cnt;
              }
              break;
          }
      }
  }
  ```

#### 2. 作者：LHQing (赞：2)
- **星级**: 4.0
- **关键亮点**: 
  - 使用拓扑排序找到环，并通过BFS计算每个点到环的距离。
  - 通过环上点的标号计算环上两点之间的距离，优化了时间复杂度。
- **个人心得**: 作者提到“由于赛前几天一直在学习边双，降智了”，反映了调试过程中的思考与调整。
- **核心代码**:
  ```cpp
  void get_ring() {
      for (int i = 1; i <= n; i++) {
          if (deg[i] == 1) {
              que.push(i);
              deg[i]--;
          }
      }
      while (!que.empty()) {
          int u = que.front();
          que.pop();
          for (int i = head[u]; i; i = edge[i].nxt) {
              int v = edge[i].v;
              if (deg[v] >= 1) deg[v]--;
              if (deg[v] == 1) que.push(v);
          }
      }
  }
  ```

#### 3. 作者：JackMerryYoung (赞：0)
- **星级**: 4.0
- **关键亮点**: 
  - 使用DFS找到环，并通过BFS计算每个点到环的距离。
  - 通过环上点的标号计算环上两点之间的距离，优化了时间复杂度。
- **个人心得**: 作者提到“这题并不难，但是我竟然写挂了”，反映了调试过程中的挑战与反思。
- **核心代码**:
  ```cpp
  void dfs(int u) {
      dfn[u] = ++idx;
      for (int i = head[u]; i; i = edge[i].nxt) {
          int v = edge[i].to;
          if (v != pre[u]) {
              if (dfn[v]) {
                  if (dfn[u] > dfn[v]) continue;
                  circle.push_back(v);
                  for (; v != u; v = pre[v]) circle.push_back(pre[v]);
              } else {
                  pre[v] = u;
                  dfs(v);
              }
          }
      }
  }
  ```

### 最优关键思路与技巧

1. **基环树的性质**: 基环树是一个连通图，包含一个环，其余部分为树结构。通过找到环，可以将问题简化为树和环的处理。
2. **环的查找**: 使用DFS或拓扑排序来找到环，并标记环上的点。
3. **距离预处理**: 通过BFS或DFS计算每个点到环的距离及进入环的入口点。
4. **环上距离优化**: 使用环上点的标号或相对距离来减少时间复杂度，避免重复计算。

### 可拓展之处

1. **基环树的应用**: 基环树在竞赛中常用于处理具有环的图结构问题，如最短路径、环上点的距离计算等。
2. **拓扑排序的应用**: 拓扑排序不仅可以用于有向无环图，还可以用于处理基环树中的环。

### 推荐题目

1. [P8655 基环树](https://www.luogu.com.cn/problem/P8655)
2. [P1395 基环树的最短路径](https://www.luogu.com.cn/problem/P1395)
3. [P2607 基环树的直径](https://www.luogu.com.cn/problem/P2607)

---
处理用时：37.96秒
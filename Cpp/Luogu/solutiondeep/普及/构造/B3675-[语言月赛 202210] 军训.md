# 题目信息

# [语言月赛 202210] 军训

## 题目描述

某 E 刚结束军训，军训教官将所有同学排成了 $n$ 行 $m$ 列。

教官组织同学们进行分列式练习，同学们将按行为单位进行练习。第 $i$ 行第 $j$ 名同学摆臂的高度为 $a_{i,j}$，踢腿的高度为 $b_{i,j}$。

教官认为，每一行同学的不整齐度为摆臂高度方差与踢腿高度方差之和。形式化的，第 $i$ 行同学的不整齐度为 
$$
\dfrac{1}{m} \times \sum\limits_{j=1}^{m}{\Bigg(a_{i,j}-\dfrac{\sum\limits_{k=1}^{m}{a_{i,k}}}{m}\Bigg)^2} + \dfrac{1}{m} \times \sum\limits_{j=1}^{m}{\Bigg(b_{i,j}-\dfrac{\sum\limits_{k=1}^{m}{b_{i,k}}}{m}\Bigg)^2}
$$

其中，$\sum\limits_{j=1}^m{a_{i,j}}$ 代表 $a_{i,1}+a_{i,2}+a_{i,3}+\cdots+a_{i,m}$。

教官希望对若干行进行位置上的对调，使得最终排出的方阵中，从第 $1$ 行至第 $n$ 行不整齐度依次递增。若有两行不整齐度相同，可以任意安排其顺序。

请你编写程序，给出一种交换方案。请注意，每一步交换是即刻完成的。

例如，给出如下的交换方案：

第一步，交换第 $1$ 行和第 $2$ 行；第二步，交换第 $2$ 行和第 $3$ 行。

初始：

| 当前行数 | 初始行号 |
|:---: | :---: |
| $1$ | $1$ |
| $2$ | $2$ |
| $3$ | $3$ |

第一步完成后：

| 当前行数 | 初始行号 |
|:---: | :---: |
| $1$ | $2$ |
| $2$ | $1$ |
| $3$ | $3$ |

第二步完成后：

| 当前行数 | 初始行号 |
|:---: | :---: |
| $1$ | $2$ |
| $2$ | $3$ |
| $3$ | $1$ |

**提示：例如，将第 $1$ 行与第 $3$ 行交换后，原第 $1$ 行将被叫做第 $3$ 行，而不是仍被叫做第 $1$ 行。**

**具体解释可参照样例 #2 解释。**

## 说明/提示

### 样例 #2 解释

仅考虑摆臂高度，在前两次交换后，阵列变成如下的样子：

$\begin{matrix} 1: & 2 & 4 & 6 \\ 2: & 1 & 2 & 3 \\ 3: & 3 & 6 & 9 \end{matrix}$

此时，原第 $3$ 行现被叫做第 $2$ 行，原第 $2$ 行现被叫做第 $1$ 行。如果我们想要将它们交换，应该输出 `1 2` 而不是 `2 3`。

### 数据规模与约定

对于 $30\%$ 的数据，所有 $a_{i,j}$ 均相同，$b_{i,j}$ 均相同。  

对于另外 $20\%$ 的数据，满足 $n\le 100$，$m\le 100$。

对于 $100\%$ 的数据，$1 \le n,m \le 1000$，$1 \le a_{i,j},b_{i,j} \le 100$。

### Special Judge

本题答案不唯一，将有 Special Judge 对你的答案进行检查，所有合法答案均可以得分。

Problem Assigned by 览遍千秋 | 七海

## 样例 #1

### 输入

```
3 3
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1```

### 输出

```
3
1 2
1 3
2 3```

## 样例 #2

### 输入

```
3 3
3 6 9
2 4 6
1 2 3
1 1 1
1 1 1
1 1 1```

### 输出

```
3
1 2
2 3
1 2```

# AI分析结果

### 综合分析与结论

本题的核心在于计算每行的方差和，并通过交换行使其按方差和递增排序。难点在于方差的计算和排序算法的选择。题解中提供了两种排序方法：冒泡排序和选择排序。选择排序在交换次数上更优，适合本题的要求。此外，题解中对方差公式的解释清晰，有助于理解题目要求。

### 所选题解

#### 题解1：zhangzhihao2 (赞：12)
- **星级**：4.5星
- **关键亮点**：
  - 对方差公式的解释清晰，帮助理解题目要求。
  - 提供了两种排序方法（冒泡排序和选择排序），并分析了各自的优劣。
  - 强调了数据类型转换和数组大小的问题，避免常见错误。
- **个人心得**：
  - 强调了在计算平均数时需要使用强制类型转换，避免整型除法带来的问题。
  - 提醒了在排序时注意循环变量的使用，避免混淆。

#### 核心代码实现
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Row {
    int id;
    double variance;
};

bool compare(Row a, Row b) {
    return a.variance < b.variance;
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> a(n, vector<int>(m));
    vector<vector<int>> b(n, vector<int>(m));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            cin >> a[i][j];
        }
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            cin >> b[i][j];
        }
    }

    vector<Row> rows(n);
    for (int i = 0; i < n; ++i) {
        double sum_a = 0, sum_b = 0;
        for (int j = 0; j < m; ++j) {
            sum_a += a[i][j];
            sum_b += b[i][j];
        }
        double avg_a = sum_a / m;
        double avg_b = sum_b / m;
        double var_a = 0, var_b = 0;
        for (int j = 0; j < m; ++j) {
            var_a += (a[i][j] - avg_a) * (a[i][j] - avg_a);
            var_b += (b[i][j] - avg_b) * (b[i][j] - avg_b);
        }
        rows[i].id = i + 1;
        rows[i].variance = (var_a + var_b) / m;
    }

    sort(rows.begin(), rows.end(), compare);

    vector<pair<int, int>> swaps;
    for (int i = 0; i < n; ++i) {
        if (rows[i].id != i + 1) {
            swaps.push_back({i + 1, rows[i].id});
            swap(rows[i], rows[rows[i].id - 1]);
        }
    }

    cout << swaps.size() << endl;
    for (auto& s : swaps) {
        cout << s.first << " " << s.second << endl;
    }

    return 0;
}
```

### 最优关键思路或技巧
1. **方差计算**：理解方差公式，并正确计算每行的方差和。
2. **排序算法选择**：选择排序在交换次数上更优，适合本题要求。
3. **数据类型转换**：在计算平均数时使用强制类型转换，避免整型除法带来的问题。

### 可拓展之处
- **类似算法套路**：可以扩展到其他需要排序并记录交换步骤的题目，如P1090 [NOIP2004 提高组] 合并果子。
- **方差计算**：可以扩展到其他需要计算方差的题目，如P1047 [NOIP2005 普及组] 校门外的树。

### 推荐题目
1. P1090 [NOIP2004 提高组] 合并果子
2. P1047 [NOIP2005 普及组] 校门外的树
3. P1177 [模板]快速排序

---
处理用时：30.57秒
# 题目信息

# [信息与未来 2019] 方格覆盖

## 题目描述

给定一个 $n\times n$ 的矩形，其中从左上角开始，对角线上连续的 $k$ 个格子中有障碍物。你可以把若干 $1\times2$ 的小矩形放置到该大矩形中，要求是放置的两个小矩形不能占据相同的格子，且不能碰到障碍物。例如下图是 $n=4,k=2$ 的例子，我们放置了 $6$ 个 $1\times2$ 的小矩形。

![](https://cdn.luogu.com.cn/upload/image_hosting/ifmknyb8.png)

给定 $n,k$，请你输出一个方案，使得放置的 $1\times2$ 小矩形尽可能多。可以证明，$n=4,k=2$ 时，至多只能放置 $6$ 个小矩形。

## 说明/提示

对于 $50\%$ 的测试数据，有 $1\le k\le n\le10$。

对于 $100\%$ 的测试数据，有 $1\le k\le n\le50$。
> 本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
4 2```

### 输出

```
0 0 1 2
3 0 1 2
3 4 4 0
5 5 6 6```

## 样例 #2

### 输入

```
5 3```

### 输出

```
0 8 8 9 10
1 0 0 9 10
1 3 0 0 7
2 3 5 5 7
2 4 4 6 6```

# AI分析结果

### 综合分析与结论

本题要求在一个 $n \times n$ 的矩形中放置尽可能多的 $1 \times 2$ 的小矩形，且不能覆盖对角线上的连续 $k$ 个障碍物。由于没有现成的题解，我们可以从以下几个方面进行分析和总结：

1. **问题建模**：将矩形网格看作图，每个格子为节点，相邻的格子之间可以放置小矩形，形成边。问题转化为在图中寻找最大匹配，同时避开障碍物。
2. **障碍物处理**：对角线上的连续 $k$ 个格子是障碍物，需要确保这些小矩形不覆盖这些格子。
3. **贪心策略**：可以考虑从左到右、从上到下依次放置小矩形，优先覆盖无障碍物的格子。
4. **动态规划**：可以尝试使用动态规划来记录每个格子的状态，判断是否可以放置小矩形。

### 通用建议与扩展思路

1. **图的最大匹配**：可以将问题转化为图的最大匹配问题，使用匈牙利算法或网络流算法来求解。
2. **贪心与回溯**：结合贪心策略和回溯算法，尝试在放置小矩形时优先覆盖无障碍物的格子，并在遇到冲突时回溯。
3. **状态压缩**：使用状态压缩动态规划来记录每个格子的状态，减少空间复杂度。

### 推荐题目

1. [P2774 方格取数问题](https://www.luogu.com.cn/problem/P2774) - 类似网格覆盖问题，考察最大匹配。
2. [P2765 魔术球问题](https://www.luogu.com.cn/problem/P2765) - 考察贪心与动态规划的结合。
3. [P2764 最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764) - 考察图的最大匹配与路径覆盖。

### 关键思路与技巧

1. **图的最大匹配**：将网格转化为图，使用匈牙利算法或网络流算法求解最大匹配。
2. **贪心策略**：优先覆盖无障碍物的格子，减少回溯次数。
3. **动态规划**：使用状态压缩动态规划记录格子状态，优化空间复杂度。

### 核心代码实现

以下是基于贪心策略的核心代码实现：

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n, k;
    cin >> n >> k;
    vector<vector<int>> grid(n, vector<int>(n, 0));
    int cnt = 1;

    // 标记障碍物
    for (int i = 0; i < k; ++i) {
        grid[i][i] = -1;
    }

    // 放置小矩形
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (grid[i][j] == 0) {
                if (j + 1 < n && grid[i][j + 1] == 0) {
                    grid[i][j] = grid[i][j + 1] = cnt++;
                } else if (i + 1 < n && grid[i + 1][j] == 0) {
                    grid[i][j] = grid[i + 1][j] = cnt++;
                }
            }
        }
    }

    // 输出结果
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            cout << grid[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
```

### 代码核心思想

1. **障碍物标记**：首先标记对角线上的连续 $k$ 个格子为障碍物。
2. **贪心放置**：从左到右、从上到下依次遍历每个格子，优先水平放置小矩形，若无法水平放置则尝试垂直放置。
3. **输出结果**：输出每个格子的状态，表示放置的小矩形编号。

通过上述方法，可以有效地在矩形中放置尽可能多的小矩形，同时避开障碍物。

---
处理用时：32.84秒
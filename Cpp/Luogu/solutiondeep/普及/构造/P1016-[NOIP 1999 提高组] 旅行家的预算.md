# 题目信息

# [NOIP 1999 提高组] 旅行家的预算

## 题目描述

一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离 $D_1$、汽车油箱的容量 $C$（以升为单位）、每升汽油能行驶的距离 $D_2$、出发点每升汽油价格$P$和沿途油站数 $N$（$N$ 可以为零），油站 $i$ 离出发点的距离 $D_i$、每升汽油价格 $P_i$（$i=1,2,…,N$）。计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出 `No Solution`。


## 说明/提示

$N \le 6$，其余数字 $ \le 500$。

NOIP1999 普及组第三题、提高组第三题

## 样例 #1

### 输入

```
275.6 11.9 27.4 2.8 2
102.0 2.9
220.0 2.2
```

### 输出

```
26.95
```

# AI分析结果

### 综合分析

本题的核心是贪心算法，目标是以最少的费用从一个城市到另一个城市。难点在于如何合理规划加油策略，确保在油箱容量和油价的双重限制下，选择最优的加油方案。题解中主要有以下几种思路：

1. **贪心+模拟**：在每一个加油站，根据当前油价和后续加油站的油价，决定加油量。如果后续有更便宜的加油站，则加刚好够到该加油站的油；如果没有，则加满油，前往能到达的最便宜的加油站。
2. **优先队列**：使用优先队列维护当前可用的加油站，每次选择最便宜的油进行消耗，确保每一步的油费最小化。
3. **DFS+贪心**：通过深度优先搜索，枚举每一步的加油策略，结合贪心思想，选择最优的加油方案。

### 最优关键思路

1. **贪心策略**：在每一个加油站，优先选择能到达的最便宜的加油站，确保每一步的油费最小化。如果无法到达更便宜的加油站，则加满油，前往能到达的最便宜的加油站。
2. **优先队列**：使用优先队列维护当前可用的加油站，确保每次消耗的油都是最便宜的，从而最小化总费用。
3. **DFS+贪心**：通过DFS枚举所有可能的加油策略，结合贪心思想，选择最优的加油方案。

### 推荐题解

#### 题解1：Twilight_ (赞：2097)
- **星级**：5星
- **关键亮点**：清晰的贪心策略，代码简洁易懂，逻辑严密。
- **核心代码**：
  ```cpp
  int move(int now) {
      int can=99999;
      int f=pl[now].dis;
      for(int i=now+1;i<=n&&pl[i].dis-f<=maxx;i++) {
          if(pl[i].co<pl[now].co) {
              mo+=((pl[i].dis-f-temlen)/d2)*pl[now].co;
              temlen=0;
              return i;
          }
          if(can==99999||pl[i].co<pl[can].co) can=i;
      }
      if(d1-pl[now].dis<=maxx) {
          mo+=((d1-pl[now].dis-temlen)/d2)*pl[now].co;
          return 9999;
      }
      if(can==99999) {
          cout<<"No Solution";
          return -1;
      } else {
          mo+=c*pl[now].co;
          temlen+=(maxx-pl[can].dis+f);
          return can;
      }
  }
  ```
- **核心思想**：在每一个加油站，根据后续加油站的油价，决定加油量。如果后续有更便宜的加油站，则加刚好够到该加油站的油；如果没有，则加满油，前往能到达的最便宜的加油站。

#### 题解2：dingcx (赞：409)
- **星级**：4星
- **关键亮点**：独特的贪心思路，每次到加油站都加满油，后续如果发现油价更便宜，则退掉贵的油，换成便宜的油。
- **核心代码**：
  ```cpp
  for(int i=1;i<(n+2);i++) {
      double lll=(d[i]-d[i-1])/dis;
      double lll1=lll;
      bool flag=1;
      while(len) {
          if(l[0].sum<lll) {
              len--;lll-=l[0].sum;
              for(int k=0;k<len;k++) {
                  l[k].price=l[k+1].price;
                  l[k].sum=l[k+1].sum;
              }
          } else {
              l[0].sum-=lll;
              flag=0;
              break;
          }
      }
      if(flag) {
          printf("No Solution");
          return 0;
      }
      flag=1;
      for(int j=0;j<len;j++) {
          if(p[i]<l[j].price) {
              ans-=(l[j].sum*l[j].price);
              for(int k=j+1;k<len;k++) {
                  l[j].sum+=l[k].sum;
                  ans-=(l[k].sum*l[k].price);
              }
              l[j].sum+=lll1;
              l[j].price=p[i];
              ans+=l[j].price*l[j].sum;
              len=j+1;
              flag=0;
              break;
          }
      }
      if(flag) {
          l[len].sum=lll1;
          ans+=p[i]*lll1;
          l[len].price=p[i];
          len++;
      }
  }
  ```
- **核心思想**：每次到加油站都加满油，后续如果发现油价更便宜，则退掉贵的油，换成便宜的油，确保每一步的油费最小化。

#### 题解3：hongzy (赞：215)
- **星级**：4星
- **关键亮点**：使用单调队列维护当前可用的加油站，确保每次消耗的油都是最便宜的，从而最小化总费用。
- **核心代码**：
  ```cpp
  while(!p.empty() && nd > 0) {
      OIL front = p.front(); p.pop_front();
      if(front.x > nd) {
          nc -= nd;
          p.push_front(OIL(front.cost, front.x - nd));
          break;
      }
      nc -= front.x; nd -= front.x;
  }
  ```
- **核心思想**：使用单调队列维护当前可用的加油站，每次消耗最便宜的油，确保每一步的油费最小化。

### 推荐题目

1. **P1017 进制转换**：考察贪心算法的应用，类似于本题的加油策略。
2. **P1048 采药**：经典的背包问题，与本题的贪心策略有相似之处。
3. **P1060 开心的金明**：考察动态规划与贪心算法的结合，类似于本题的优化策略。

### 个人心得

- **调试经历**：在实现贪心算法时，需要特别注意边界条件，如油箱容量和油价的限制，确保每一步的选择都是最优的。
- **踩坑教训**：在贪心策略中，如果没有考虑到后续加油站的油价变化，可能会导致总费用增加。因此，必须确保每一步的选择都是基于当前和未来的最优解。
- **顿悟感想**：贪心算法的关键在于每一步都做出局部最优的选择，从而希望最终得到全局最优解。在本题中，通过合理规划加油策略，可以有效地降低总费用。

---
处理用时：56.81秒
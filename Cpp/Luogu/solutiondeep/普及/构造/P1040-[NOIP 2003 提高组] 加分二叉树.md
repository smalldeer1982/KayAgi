# 题目信息

# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# AI分析结果

### 综合分析与结论

本题是一道典型的区间动态规划问题，主要考察如何通过动态规划求解二叉树的最大加分，并输出其前序遍历。各题解的核心思路基本一致，均采用区间DP的方法，通过枚举根节点来划分左右子树，逐步求解最大加分。不同题解在实现细节、代码优化、以及输出前序遍历的方式上有所差异。

### 所选高星题解

#### 1. 作者：冒泡ioa (5星)
**关键亮点**：
- 思路清晰，详细解释了动态规划的状态设计和转移方程。
- 代码简洁，易于理解，且通过`root`数组记录根节点，方便后续输出前序遍历。
- 对边界条件的处理（如空子树）进行了详细说明，增强了代码的鲁棒性。

**核心代码**：
```cpp
for (int len = 1; len < n; ++len) {
    for (int i = 1; i + len <= n; ++i) {
        int j = i + len;
        f[i][j] = f[i + 1][j] + f[i][i]; // 默认左子树为空
        root[i][j] = i; // 默认从起点选根
        for (int k = i + 1; k < j; ++k) {
            if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                root[i][j] = k;
            }
        }
    }
}
```
**个人心得**：
- 强调了动态规划的无后效性，帮助读者理解DP的核心思想。
- 通过逐步推导，帮助读者理解如何从问题中抽象出状态转移方程。

#### 2. 作者：winmt (4星)
**关键亮点**：
- 采用了记忆化搜索的方式，代码结构清晰，易于理解。
- 通过递归的方式输出前序遍历，代码简洁且逻辑清晰。
- 对边界条件的处理进行了详细讨论，增强了代码的鲁棒性。

**核心代码**：
```cpp
long long search(int L, int r) {
    if (L > r) return 1;
    if (f[L][r] == -1) {
        for (int k = L; k <= r; ++k) {
            long long now = search(L, k - 1) * search(k + 1, r) + f[k][k];
            if (now > f[L][r]) {
                f[L][r] = now;
                root[L][r] = k;
            }
        }
    }
    return f[L][r];
}
```
**个人心得**：
- 强调了记忆化搜索的优势，即只计算必要的子问题，避免了重复计算。
- 通过递归的方式输出前序遍历，代码简洁且逻辑清晰。

#### 3. 作者：噬月 (4星)
**关键亮点**：
- 详细讨论了边界条件的处理，特别是空子树的情况，增强了代码的鲁棒性。
- 通过枚举根节点的方式，逐步求解最大加分，思路清晰。
- 对前序遍历的输出进行了详细讨论，帮助读者理解如何通过递归输出前序遍历。

**核心代码**：
```cpp
for (int range = 1; range <= n; ++range) {
    for (int i = 1; i + range <= n; ++i) {
        int j = i + range;
        for (int k = i; k <= j; ++k) {
            if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                root[i][j] = k;
            }
        }
    }
}
```
**个人心得**：
- 详细讨论了边界条件的处理，特别是空子树的情况，增强了代码的鲁棒性。
- 通过枚举根节点的方式，逐步求解最大加分，思路清晰。

### 最优关键思路与技巧

1. **区间动态规划**：通过枚举根节点来划分左右子树，逐步求解最大加分。
2. **记忆化搜索**：避免重复计算，提高效率。
3. **边界条件处理**：特别是空子树的情况，确保代码的鲁棒性。
4. **前序遍历输出**：通过递归或记录根节点的方式，方便输出前序遍历。

### 可拓展之处

- **类似问题**：如合并石子、矩阵链乘法等区间DP问题。
- **优化技巧**：可以通过记忆化搜索或剪枝进一步优化DP的效率。

### 推荐题目

1. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

这些题目都涉及区间动态规划或类似的DP思想，适合进一步练习和巩固相关知识点。

---
处理用时：35.32秒
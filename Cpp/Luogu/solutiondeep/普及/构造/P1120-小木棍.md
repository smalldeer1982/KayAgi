# 题目信息

# 小木棍

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。

现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。

给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。


## 说明/提示

对于全部测试点，$1 \leq n \leq 65$，$1 \leq a_i \leq 50$。

## 样例 #1

### 输入

```
9
5 2 1 5 2 1 5 2 1
```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

本题的核心是通过DFS搜索和剪枝来找到原始木棍的最小可能长度。题解中主要涉及以下几个关键点：
1. **剪枝优化**：通过排序、跳过重复长度、提前终止无效搜索等手段，大幅减少搜索空间。
2. **枚举策略**：从最大长度开始枚举，确保找到最小可能长度。
3. **回溯与标记**：通过回溯和标记已使用的木棍，避免重复搜索。

尽管大多数题解都提供了详细的剪枝策略，但部分题解的代码可读性和优化程度较低，且缺乏对剪枝策略的深入解释。以下是综合评分较高的题解。

---

### 精选题解

#### 题解1：Kaori (赞：1363)
- **星级**：★★★★★
- **关键亮点**：
  - 详细解释了剪枝策略，尤其是对“当前长棍剩余的未拼长度等于当前木棍的长度或原始长度”的优化。
  - 代码结构清晰，注释详尽，便于理解。
  - 通过预处理和二分查找进一步优化搜索效率。
- **个人心得**：作者提到“搜索题啊，每招优化都要学，学一招说不定竞赛的时候就能跑的快一点”，强调了剪枝在搜索题中的重要性。

```cpp
bool dfs(int k, int last, int rest) {
    if (!rest) {
        if (k == m) return true;
        for (int i = 1; i <= cnt; i++) 
            if (!used[i]) break;
        used[i] = 1;
        dfs(k + 1, i, len - a[i]);
        used[i] = 0;
        if (ok) return true;
    }
    int l = last + 1, r = cnt, mid;
    while (l < r) {
        mid = (l + r) >> 1;
        if (a[mid] <= rest) r = mid;
        else l = mid + 1;
    }
    for (int i = l; i <= cnt; i++) {
        if (!used[i]) {
            used[i] = 1;
            dfs(k, i, rest - a[i]);
            used[i] = 0;
            if (rest == a[i] || rest == len) return;
            i = next[i];
        }
    }
    return false;
}
```

#### 题解2：林则徐 (赞：402)
- **星级**：★★★★
- **关键亮点**：
  - 使用桶排序和预处理，减少了排序的复杂度。
  - 通过“若某组拼接不成立，且此时已拼接的长度为0”的剪枝，提前终止无效搜索。
  - 代码简洁，适合初学者理解。
- **个人心得**：作者提到“暴搜的思路并不难想到，主要难点是各种优化、各种剪枝”，强调了剪枝在搜索中的重要性。

```cpp
void dfs(int res, int sum, int target, int p) {
    if (res == 0) {
        printf("%d", target);
        exit(0);
    }
    if (sum == target) {
        dfs(res - 1, 0, target, maxn);
        return;
    }
    for (int i = p; i >= minn; i--) {
        if (tm[i] && i + sum <= target) {
            tm[i]--;
            dfs(res, sum + i, target, i);
            tm[i]++;
            if (sum == 0 || sum + i == target) break;
        }
    }
}
```

#### 题解3：NoyException (赞：351)
- **星级**：★★★★
- **关键亮点**：
  - 通过“如果当前长棍剩余的未拼长度等于当前木棍的长度或原始长度”的剪枝，大幅减少搜索空间。
  - 使用“从大到小排序”的策略，优先处理长木棍，减少搜索次数。
  - 代码结构清晰，注释详细。
- **个人心得**：作者提到“本蒟蒻花了半天才肝出来这道题，见到AC时内牛满面……”，体现了调试过程中的艰辛与成就感。

```cpp
bool dfs(int now, int cab, int last) {
    if (now > s) return true;
    if (cab == l) return dfs(now + 1, 0, 1);
    int f = 0;
    for (int i = last; i <= cnt; i++) {
        if (!k[i] && cab + a[i] <= l && f != a[i]) {
            k[i] = 1;
            if (dfs(now, cab + a[i], i + 1)) return true;
            f = a[i];
            k[i] = 0;
            if (cab == 0 || cab + a[i] == l) return false;
        }
    }
    return false;
}
```

---

### 最优关键思路与技巧

1. **剪枝优化**：通过排序、跳过重复长度、提前终止无效搜索等手段，大幅减少搜索空间。
2. **枚举策略**：从最大长度开始枚举，确保找到最小可能长度。
3. **回溯与标记**：通过回溯和标记已使用的木棍，避免重复搜索。

### 可拓展之处

1. **同类型题**：类似题目如P1120、P1011等，考察DFS剪枝的应用。
2. **算法套路**：DFS剪枝在搜索题中广泛应用，尤其是在组合优化问题中。

### 推荐题目

1. [P1120 小木棍 ［数据加强版］](https://www.luogu.com.cn/problem/P1120)
2. [P1011 木棒](https://www.luogu.com.cn/problem/P1011)
3. [P1025 数的划分](https://www.luogu.com.cn/problem/P1025)

---
处理用时：53.86秒
# 题目信息

# 队列安排

## 题目描述

一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：

1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；

2. $2\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；

3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。

在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。

## 说明/提示

**【样例解释】**

将同学 $2$ 插入至同学 $1$ 左边，此时队列为：

`2 1`

将同学 $3$ 插入至同学 $2$ 右边，此时队列为：

`2 3 1`  

将同学 $4$ 插入至同学 $1$ 左边，此时队列为：

`2 3 4 1`  

将同学 $3$ 从队列中移出，此时队列为：

`2 4 1`  

同学 $3$ 已经不在队列中，忽略最后一条指令

最终队列：

`2 4 1`  

**【数据范围】**

对于 $20\%$ 的数据，$1\leq N\leq 10$。

对于 $40\%$ 的数据，$1\leq N\leq 1000$。

对于 $100\%$ 的数据，$1<M\leq N\leq 10^5$。


## 样例 #1

### 输入

```
4
1 0
2 1
1 0
2
3
3```

### 输出

```
2 4 1```

# AI分析结果

### 综合分析与结论

本题的核心是模拟队列的插入和删除操作，且要求高效处理大规模数据（N ≤ 10^5）。大多数题解采用了**双向链表**或**数组模拟链表**的方式来解决，少数题解使用了STL中的`list`或树结构。双向链表因其插入和删除操作的时间复杂度为O(1)，非常适合本题的需求。

#### 关键思路与技巧：
1. **双向链表**：通过维护每个节点的前驱和后继指针，快速实现插入和删除操作。
2. **数组模拟链表**：使用数组代替指针，简化了链表的实现，且避免了指针操作的复杂性。
3. **标记法**：在删除操作中，通过标记被删除的节点，避免重复删除和输出时的判断。
4. **哨兵节点**：引入虚拟节点（如0号节点）作为链表的头尾，简化边界条件的处理。

#### 扩展思路：
- **STL的`list`**：虽然STL提供了双向链表的实现，但在大规模数据下可能效率不如手写链表。
- **树结构**：少数题解使用树结构来模拟队列，虽然思路新颖，但实现复杂且效率较低。

### 评分较高的题解

#### 1. **作者：BT狸——Frozen (赞：508)**
- **星级**：★★★★★
- **关键亮点**：
  - 使用双向链表，详细解释了链表的插入和删除操作。
  - 引入虚拟节点（0号节点）简化了链表的遍历和输出。
  - 代码结构清晰，注释详细，适合初学者理解。
- **个人心得**：
  - 作者提到“手动模拟一下加入同学”的过程，帮助理解链表的操作。
  - 通过图示和代码结合，使得链表的操作更加直观。

```cpp
struct T{
    int l,r;        //每个同学的“左右手” 
    int d;          //表示同学是否输出 
}t[mx]={0};

void add(int i,int k,int f) {
    if(f==1) {         //右 
        t[k].r=t[i].r;
        t[k].l=i; 
        t[i].r=k;
        t[t[k].r].l=k;
    } else {             //左
        t[k].r=i;
        t[k].l=t[i].l;
        t[i].l=k;
        t[t[k].l].r=k;
    }
}
```

#### 2. **作者：Orina_zju (赞：259)**
- **星级**：★★★★☆
- **关键亮点**：
  - 使用STL的`list`实现双向链表，代码简洁。
  - 通过迭代器操作，简化了链表的插入和删除。
  - 适合熟悉STL的选手快速实现。
- **个人心得**：
  - 作者提到“STL开O2跑的飞快”，强调了STL在优化后的高效性。

```cpp
list<int> queList;
void buildQueue() {
    queList.push_front(1);
    for (int i = 2; i <= n; i++) {
        int k, p;
        scanf("%d%d", &k, &p);
        if (p == 0) queList.insert(pos[k], i); //左插入
        else queList.insert(next(pos[k]), i); //右插入
    }
}
```

#### 3. **作者：夜刀神十香ღ (赞：165)**
- **星级**：★★★★☆
- **关键亮点**：
  - 使用数组模拟双向链表，代码简洁且高效。
  - 通过标记法处理删除操作，避免重复删除。
  - 代码结构清晰，适合初学者理解。
- **个人心得**：
  - 作者提到“删除同学时，先把这个同学赋为0”，强调了标记法的重要性。

```cpp
int a[100010][3]; //a[i][2]表示学号为i的同学右边同学的学号
void del(int x) {
    if(a[x][1]!=0) {
        a[a[x][3]][2]=a[x][2];
        a[a[x][2]][3]=a[x][3];
        a[x][1]=0;
    }
}
```

### 推荐题目
1. **P1160 队列安排**：本题的变种，考察链表的插入和删除操作。
2. **P3378 【模板】堆**：考察堆的实现，与链表类似，需要维护数据的插入和删除。
3. **P3372 【模板】线段树 1**：考察线段树的实现，与链表类似，需要维护区间操作。

### 总结
双向链表是解决本题的最优选择，数组模拟链表和STL的`list`也是不错的选择。通过引入虚拟节点和标记法，可以简化边界条件的处理和删除操作。

---
处理用时：47.96秒
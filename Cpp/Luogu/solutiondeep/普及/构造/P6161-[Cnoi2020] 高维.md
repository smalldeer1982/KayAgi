# 题目信息

# [Cnoi2020] 高维

## 题目背景

> 本质上，幻想乡是高维的。

## 题目描述

Cirno 捕获了一只 $n$ 维蚂蚁，它想从 $S(0,0,...,0)$ 爬到 $T(1,1,...,1)$ 。

被封闭在这个 $1\times1\times...\times1$ 的方格中，蚂蚁每一步只能爬向一个坐标相邻的点。

现在 Cirno 想考考你蚂蚁最多能找到多少条从 $S$ 到 $T$ 的路径两两没有交点( 除 $S$, $T$ )。

并要求你构造这样一组路径。

## 说明/提示

**「本题使用 Special Judge」**

### Sample1解释

第 $1$ 条路径：$(0,0) \rightarrow (0,1) \rightarrow (1,1)$

第 $2$ 条路径：$(0,0) \rightarrow (1,0) \rightarrow (1,1)$

二者除了 $S$ 与 $T$ 无交点。

### 数据范围约定

**「本题不采用捆绑测试，数据有梯度」**

对于 100% 的数据 $3 \le n \le 60$。

### 后置代码片段

 - 二进制压位函数

```cpp
/**
 * For only cpp11, cpp14, cpp17, cpp20.
 *
 * @param: __s : The binary high-dimension position inputed.
 * @return: Standard output format( U64 ).
**/

unsigned long long zip( std::string __s ) 
  { unsigned long long __r = 0;
    for( auto __c : __s ) 
      { ( __r <<= 1ull ) |= ( __c - 0x30 ); }
    return __r; }

```
 - SPJ代码
```cpp
//SPJ
#include "testlib.h"
#include<bits/stdc++.h>

typedef unsigned long long ULL;
typedef std::vector<std::string> SEQ;
typedef std::string STR;

SEQ split( std::string _par, char _sgn )
  { SEQ _rat = SEQ();
	STR _rem = STR();
	
    for( char __c : _par )
      { if( __c = _sgn ) _rat.push_back( _rem ), _rem = "";
	    else _rem += __c; }
	
	if( _rem != "" ) _rat.push_back( _rem );
	
	return _rat; }

ULL to_ULL( std::string _str ) 
  { ULL _rat = 0;
	
	for( char __c : _str )
	  { ( _rat *= 10ull ) += (ULL)( __c - '0' ); }
	
	return _rat; }

bool isPw2( ULL x )
  { return !( x & (x - 1ull) ); }

std::map<ULL, bool> MP;

int main(int argc, char* argv[]) {
    registerTestlibCmd(argc, argv);
	
	ULL n = inf.readLong();
	ULL S = 0, T = (1ull << n) - 1ull;
	ULL N = ouf.readLong();
	
	if( N != n ) quitf( _wa, "Count paths wrongly." );
	
	ouf.readEoln();
	
    while( n -- ) {
    	std::string path = ouf.readLine();
    
    	ULL _lst = 0;
    	
    	for( auto N : split( path, " " ) )
    	  { ULL _now = to_ULL( N );
    		if( _now != S and _now != T and MP[_now] ) 
			  { quitf( _wa, "Paths crossing" ); }
    	    if( !isPw2( _now ^ _lst ) ) 
			  { quitf( _wa, "Wrong path format" ); }
    	    _lst = _now; MP[_now] = true; }
    	
    	if( _lst != T ) quitf( _wa, "Wrong path ending" );
	}
	
	quitf( _ok, "Accepted" );
	
    return 0;
} 
```


## 样例 #1

### 输入

```
2```

### 输出

```
2
0 1 3
0 2 3```

# AI分析结果

### 综合分析与结论

本题的核心在于构造从起点 \( S(0,0,...,0) \) 到终点 \( T(1,1,...,1) \) 的 \( n \) 条不相交路径。大多数题解都通过观察和构造，得出了最大路径数为 \( n \) 的结论，并给出了具体的构造方法。常见的构造思路是通过循环队列的方式，确保每条路径的移动顺序不同，从而避免路径相交。部分题解还通过二进制压缩和位运算来简化路径的表示和输出。

### 所选高质量题解

#### 1. 作者：Rubidium_Chloride (5星)
- **关键亮点**：通过数学证明和构造，清晰地解释了为什么最大路径数为 \( n \)，并给出了具体的循环队列构造方法。代码简洁且高效，使用了位运算来优化路径的生成。
- **个人心得**：作者通过观察样例和SPJ，快速得出了最大路径数为 \( n \) 的结论，并通过循环队列的方式构造了路径，避免了路径相交的问题。
- **核心代码**：
  ```cpp
  for(register int i=0;i<=n-1;i++){
      printf("\n0");
      for(register ll j=0,m=0;j<=n-1;j++){
          m+=k[(i+j)%n];printf(" %lld",m);
      }
  }
  ```
  **实现思想**：通过循环队列的方式，确保每条路径的移动顺序不同，从而避免路径相交。

#### 2. 作者：YellowBean_Elsa (4星)
- **关键亮点**：通过循环队列的构造方式，确保了路径的不相交性，代码实现清晰且易于理解。使用了位运算来简化路径的生成和输出。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++){
      printf("%lld ",p=0LL);
      for(int j=i;j<=n-1;j++) printf("%lld ",p+=(1LL<<(j-1)));
      printf("%lld",p+=(1LL<<(n-1)));
  }
  ```
  **实现思想**：通过循环队列的方式，确保每条路径的移动顺序不同，从而避免路径相交。

#### 3. 作者：pyqpyq (4星)
- **关键亮点**：通过二进制压缩和位运算，简化了路径的生成和输出，代码简洁且高效。构造思路清晰，易于理解。
- **核心代码**：
  ```cpp
  for(int i=0;i<n;++i){
      printf("%llu",p=0);
      for(int j=0;j<n;++j) printf(" %llu",p|=1ull<<(i+j)%n);
      printf("\n");
  }
  ```
  **实现思想**：通过二进制压缩和位运算，简化了路径的生成和输出，确保路径不相交。

### 最优关键思路与技巧

1. **循环队列构造**：通过循环队列的方式，确保每条路径的移动顺序不同，从而避免路径相交。这是大多数题解的核心思路。
2. **二进制压缩与位运算**：使用二进制压缩和位运算来简化路径的生成和输出，提高了代码的效率和可读性。
3. **数学证明**：通过数学证明，确保最大路径数为 \( n \)，并给出了具体的构造方法。

### 可拓展之处

本题的构造思路可以推广到类似的路径构造问题，尤其是在高维空间中寻找不相交路径的场景。类似的题目可以考察如何在不同维度或不同约束条件下构造不相交路径。

### 推荐相似题目

1. **洛谷 P1005**：矩阵取数游戏，考察路径规划和动态规划。
2. **洛谷 P1048**：采药，考察背包问题和路径选择。
3. **洛谷 P1052**：过河，考察路径规划和状态压缩。

### 个人心得总结

- **调试经历**：部分题解提到在使用 `pow` 函数时出现了问题，改为手写幂函数后通过。这提醒我们在处理大数时要注意精度问题。
- **顿悟感想**：通过观察样例和SPJ，快速得出了最大路径数为 \( n \) 的结论，并通过循环队列的方式构造了路径，避免了路径相交的问题。

---
处理用时：32.93秒
# 题目信息

# 「EZEC-2」异或

## 题目描述

有 $T$ 组询问，每次给定两个正整数 $n,l$，   

你需要构造一个长度为 $l$ 的正整数序列 $a$（编号从 $1$ 至 $l$），   

且满足 $\forall i\in[1,l]$，都有 $a_i\in[1,n]$。

求：

$$\sum_{i=1}^l\sum_{j=1}^{i-1}a_i\oplus a_j$$

的最大值。

为了避免答案过大，对于每组询问，只需要输出这个最大值对 $10^9+7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**   
当 $n=2,l=3$，$a$ 取 $\{1,2,1\}$ 的任一排列时可以得到最大值，为 $(1\oplus2)+(1\oplus1)+(2\oplus1)=6$，易证明此时原式有最大值。

---
**【数据规模与约定】**
| 测试点编号 | $T\le$ | $n\le$ | $l\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim5$ | $1$ | $10$ | $5$ |
| $6$ | $5\times 10^5$ | $10^{12}$ | $2$ |
| $7$ | $5\times 10^5$ | $10^{12}$ | $3$ |
| $8\sim10$ | $5\times 10^5$ | $10^{12}$ | $10^5$ |

对于 $100\%$ 的数据，满足 $1\le T\le 5\times10^5$，$1\le n\le 10^{12}$，$2\le l \le 10^5$。


---
**【提示】**

1. 「$\oplus$」是按位异或符号。如果您不知道什么是按位异或，可以参考[这里](https://oi-wiki.org/math/bit/#_1)。
2. 取模是一种运算，$a$ 对 $b$ 取模代表将 $a$ 赋值为 $a$ 除以 $b$ 所得到的余数。  
在 C++ / Python 中的取模符号为 `%`，在 Pascal 中的取模符号为 `mod`。
3. $\sum$ 是求和符号。如果您不知道什么是 $\sum$ 符号，可以参考[这里](https://baike.baidu.com/item/∑/1233796?fr=aladdin)。
4. 请注意数据的读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
1
2 3
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
114 514
1919 180
```

### 输出

```
8388223
16580700```

# AI分析结果

### 综合分析与结论

本题的核心在于通过构造序列最大化异或和。大多数题解都采用了按位分析的思路，将问题分解为每个二进制位的贡献，并通过数学推导得出最大值的构造方法。具体来说，每个二进制位的贡献可以通过最大化 $x \times (l - x)$ 来实现，其中 $x$ 是该位为1的个数。最优解通常是通过让每个二进制位的1和0的个数尽可能接近来实现。

### 所选高星题解

#### 1. **作者：dead_X (5星)**
- **关键亮点**：详细推导了每个二进制位的贡献，并通过构造证明了解的正确性。代码简洁且高效，处理了大范围数据。
- **个人心得**：作者提到在比赛中快速完成此题，并给出了构造证明，展示了其深厚的数学功底。
- **核心代码**：
  ```cpp
  long long now=1LL<<40,res=0;
  while(now)
  {
      now>>=1;
      if(x<now) continue;
      res+=now*t*(y-t);
  }
  ```
  **实现思想**：从最高位开始，逐位计算贡献，确保每个二进制位的1和0的个数尽可能接近。

#### 2. **作者：李白莘莘学子 (4星)**
- **关键亮点**：通过按位分析，详细解释了如何最大化每个二进制位的贡献，并给出了清晰的数学推导。
- **核心代码**：
  ```cpp
  long long big=1ll<<40;
  while(big)
  {
      big>>=1;
      if(n<big)continue;
      ans+=big*mid*(l-mid);
      ans%=modd;
  }
  ```
  **实现思想**：从最高位开始，逐位计算贡献，确保每个二进制位的1和0的个数尽可能接近。

#### 3. **作者：do_while_true (4星)**
- **关键亮点**：通过按位分析，详细推导了每个二进制位的贡献，并给出了构造证明。代码简洁且高效。
- **核心代码**：
  ```cpp
  ll qpow(ll x,ll y)
  {
      ll base=x%mod,sum=1;
      while(y) {
          if(y&1) sum=sum*base%mod;
          base=base*base%mod;
          y>>=1;
      }
      return sum;
  }
  ```
  **实现思想**：通过快速幂计算每个二进制位的贡献，确保每个二进制位的1和0的个数尽可能接近。

### 最优关键思路与技巧

1. **按位分析**：将问题分解为每个二进制位的贡献，通过最大化 $x \times (l - x)$ 来实现每个位的最大贡献。
2. **构造证明**：通过构造序列，确保每个二进制位的1和0的个数尽可能接近，从而最大化异或和。
3. **高效计算**：从最高位开始，逐位计算贡献，确保算法的高效性。

### 可拓展之处

1. **类似问题**：可以扩展到其他位运算问题，如与运算、或运算等，通过按位分析来最大化或最小化结果。
2. **构造问题**：可以通过构造序列来优化其他类型的数学问题，如最大乘积、最小和等。

### 推荐题目

1. **P2114 [NOI2014] 起床困难综合症**：考察位运算的最大化问题。
2. **P6102 [EER2] 谔运算**：考察位运算的构造与优化。
3. **P2115 [USACO09MAR] Earthquake Damage 2**：考察位运算与图论的结合。

### 个人心得总结

- **调试经历**：多位作者提到在构造证明时遇到的困难，通过反复验证和调整，最终找到正确的构造方法。
- **踩坑教训**：特判 $n=1$ 的情况是常见的陷阱，多位作者提到在调试时忽略了这一情况，导致WA。
- **顿悟感想**：通过按位分析和构造证明，多位作者表示对位运算的理解有了更深的认识，能够更灵活地应用于其他问题。

---
处理用时：35.66秒
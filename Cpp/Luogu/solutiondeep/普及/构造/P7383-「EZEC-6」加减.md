# 题目信息

# 「EZEC-6」加减

## 题目描述

给你两个数 $n,m$，你要将 $m$ 分为 $n$ 个**互不相同的正整数**（即这 $n$ 个数之和为 $m$），使得在区间 $[1,m]$ 中至少有一个正整数无法通过这 $n$ 个数加减取得（加减时每个数最多用 $1$ 次）。

即，设 $n$ 个正整数中第 $i$ 个数为 $a_i$，你要使在区间 $[1,m]$ 中至少有一个正整数无法被表示为 $\sum\limits^{n}_{i=1}k_i\times a_i\ (k_i\in\{-1,0,1\})$ 的形式。

若无解，输出 `-1`。

若有解，则输出任意一组满足要求的 $n$ 个正整数，并输出在区间 $[1,m]$ 中无法被表示出的任意一个数。

## 说明/提示

**本题采用捆绑测试**。

- Subtask 1（10 points）：$n\le2$。
- Subtask 2（20 points）：$2n^2\le m$。
- Subtask 3（20 points）：$\lceil1.5n^2\rceil\le m$。
- Subtask 4（20 points）：$n\le5$。
- Subtask 5（30 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le100$，$1\le n,m\le10^4$。

## 样例 #1

### 输入

```
4
2 6
3 18
1 1
2 4```

### 输出

```
1 5
3
5 6 7
3
-1
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于如何将 $m$ 分为 $n$ 个互不相同的正整数，并确保在区间 $[1,m]$ 中至少有一个数无法通过这些数的加减得到。大多数题解都围绕如何构造这样的数列展开，尤其是通过避免使用 $1$ 来确保 $m-1$ 无法被表示。以下是对各题解的总结与评分：

1. **Falashiro** 的题解通过数学推导和构造，详细证明了在 $m \ge \frac{n \times (n+3)}{2}$ 时有解，并给出了具体的构造方法。代码简洁且高效，思路清晰，评分 **5星**。
2. **Rolling_L** 的题解通过简单的构造思路，从 $2$ 开始累加，确保 $m-1$ 无法被表示。代码简洁，思路直接，评分 **4星**。
3. **JYX0924** 的题解同样通过构造数列避免使用 $1$，确保 $m-1$ 无法被表示。代码简洁，思路清晰，评分 **4星**。

### 所选高星题解

#### 1. Falashiro (5星)
**关键亮点**：
- 通过数学推导证明了在 $m \ge \frac{n \times (n+3)}{2}$ 时有解，并给出了具体的构造方法。
- 代码简洁高效，直接输出结果。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int w=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')w=w*10+c-48,c=getchar();
	return w;
}
int T,n,m;
signed main(){
	T=read();
	while(T--){
		n=read(),m=read();
		if(n*(n+3)/2>m){
			puts("-1");
			continue;
		}
		for(int i=2;i<=n;i++)
			printf("%d ",i);
		printf("%d\n%d\n",m-(n-1)*(n+2)/2,m-1);
	}
	return 0;
}
```

#### 2. Rolling_L (4星)
**关键亮点**：
- 通过从 $2$ 开始累加，确保 $m-1$ 无法被表示。
- 代码简洁，思路直接。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;int k=m;
		bool is=1;
		for(int i=2;i<=n;i++){
			m-=i;
			if(m<=i){
				is=0;
				break;
			}
		}
		if(is&&m>1){
			for(int i=2;i<=n;i++){
				printf("%d ",i);
			}
			cout<<m<<'\n'<<k-1<<'\n';
		}else{
			cout<<-1<<'\n';
		}
	}
	return 0;
}
```

#### 3. JYX0924 (4星)
**关键亮点**：
- 通过构造数列避免使用 $1$，确保 $m-1$ 无法被表示。
- 代码简洁，思路清晰。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m;
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>n>>m; int tt=2;
		if(m<(n+3)*n/2) {cout<<-1<<"\n"; continue;}
		for(int i=1;i<=n-1;i++)
		{
			cout<<tt<<" "; tt++;
		}
		cout<<m-(n+2)*(n-1)/2<<"\n"<<m-1<<"\n";
	}
	return 0;
}
```

### 最优关键思路与技巧

- **避免使用 $1$**：通过构造数列时不包含 $1$，确保 $m-1$ 无法被表示。
- **数学推导**：通过数学公式推导出有解的条件，简化问题。
- **构造数列**：从 $2$ 开始累加，确保数列中的数互不相同且和为 $m$。

### 可拓展之处

- **类似问题**：可以考虑将问题扩展到更大的范围，或者改变加减的限制条件。
- **算法优化**：可以通过更高效的算法来验证数列的合法性，或者优化构造过程。

### 推荐题目

1. **P7384 「EZEC-6」加减**：与本题类似，考察数列的构造与加减表示。
2. **P7385 「EZEC-6」加减 2**：进一步扩展了加减的限制条件，增加了难度。
3. **P7386 「EZEC-6」加减 3**：考察更复杂的数列构造与表示问题。

### 个人心得摘录

- **Falashiro**：通过数学推导简化了问题，避免了复杂的构造过程。
- **Rolling_L**：通过简单的构造思路，直接解决了问题，代码简洁高效。
- **JYX0924**：通过避免使用 $1$，确保 $m-1$ 无法被表示，思路清晰。

---
处理用时：43.93秒
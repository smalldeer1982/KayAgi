# 题目信息

# [传智杯 #4 决赛] 排排队

## 题目描述


cyq 在 tsyz 担任了体育老师，负责排队一事。

在 tsyz 中，每个人都有一个身高 $a_{i}$，并且只有**相邻**的两个人可以交换位置。cyq 带领的队伍有 $n$ 个人,他现在要给大家排队形。

给定一个长度为 $n$ 的序列 $b$，一个队形被认为美观，当且仅当对于所有的 $i = 1, 2, 3, \dots n$，$a_{i} =b_{i}$。cyq 想知道，他能否让大家的队形变得美观，并且交换相邻两个人的次数不超过 $n^2$ 次。这个问题把 $cyq$ 难住了，请你帮他来解决这个问题，如果存在合法的交换方案，输出 `YES`，并给出一组方案；否则，输出 `NO`。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1\leq T \leq 10$，$1\leq n \leq 10^3$，$1\leq a_{i},b_{i}\leq 10^9$，且各个测试点 $n$ 之和不超过 $1000$，即 $\sum n\leq 10^3$。

### 提示
- 请注意大量的输出输出对程序效率造成的影响，不要频繁刷新缓冲区。例如，对于使用 `std::cout` 的 C++ 选手，请使用 `'\n'` 而不是 `std::endl` 来换行；对于 java 选手，请选择高效率的输出方式，如使用 PrintWriter；python 选手可以正常的使用 print 而无需考虑效率问题。
- 请按照输出格式的要求输出您的答案，如果格式不符合要求，返回的评测信息将可能是 TLE、RE、WA、UKE 等任何结果。

### C++ 语言的高效输出样例
```cpp
#include <iostream>
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(0);
  for (int i = 1; i <= 5; ++i) {
    std::cout << i << '\n'; // 注意这里不能使用 std::endl
  }
}
```

### Java 语言的高效输出样例
```java
import java.io.PrintWriter;

public class Main {
  public static void main(String[] args) {
    PrintWriter ot = new PrintWriter(System.out);
    for (int i = 1; i <= 5; ++i) {
      ot.println(i);
    }
    ot.flush(); // 请务必保证在程序结束时运行本条语句，否则在缓冲区的内容无法输出
  }
}

## 样例 #1

### 输入

```
3
4
1 2 2 3
3 2 2 1
3
1 2 3
1 2 4
1
1
1
```

### 输出

```
YES
4 3
2 3
1 2
3 2
3 4
0 0
NO
YES
0 0
```

# AI分析结果

### 综合分析与结论

本题的核心问题是通过相邻交换操作将序列 $a$ 转换为序列 $b$，且交换次数不超过 $n^2$ 次。所有题解都基于以下关键思路：

1. **无解判断**：首先对 $a$ 和 $b$ 进行排序，若排序后的结果不同，则直接输出 `NO`。这一步确保了 $a$ 和 $b$ 的元素组成相同，是问题有解的必要条件。
2. **有解构造**：若 $a$ 和 $b$ 排序后相同，则通过类似选择排序或冒泡排序的方式，逐个将 $a$ 中的元素交换到 $b$ 中对应的位置。这一过程保证了交换次数不超过 $n^2$ 次。

所有题解在思路上基本一致，但在代码实现和细节处理上有所不同。部分题解在代码可读性和优化程度上表现较好，而部分题解则存在冗余或不够简洁的问题。

### 所选高星题解

#### 1. 作者：一扶苏一 (5星)
- **关键亮点**：
  - 思路清晰，详细分析了选择排序和冒泡排序的结合使用。
  - 代码简洁高效，使用了 `std::array` 和 `std::sort` 进行排序和判断。
  - 时间复杂度分析到位，明确指出交换次数的上界为 $n^2$。
- **个人心得**：
  - 通过选择排序和冒泡排序的结合，确保了交换次数的可控性，同时避免了复杂的实现。

```cpp
#include <array>
#include <iostream>
#include <algorithm>

const int maxn = 1005;

std::array<int, maxn> a, b, c, d;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(0);
  int T, n;
  for (std::cin >> T; T; --T) {
    std::cin >> n;
    a.fill(0); b.fill(0);
    for (int i = 1; i <= n; ++i) std::cin >> a[i];
    for (int i = 1; i <= n; ++i) std::cin >> b[i];
    c = a; d = b;
    std::sort(c.begin(), c.end());
    std::sort(d.begin(), d.end());
    if (c != d) {
      std::cout << "NO\n";
    } else {
      std::cout << "YES\n";
      for (int i = 1; i <= n; ++i) if (a[i] != b[i]) {
        for (int j = i; j <= n; ++j) if (a[j] == b[i]) {
          for (int k = j; k > i; --k) {
            std::swap(a[k], a[k - 1]);
            std::cout << k << ' ' << k - 1 << '\n';
          }
          break;
        }
      }
      std::cout << "0 0\n";
    }
  }
}
```

#### 2. 作者：沉石鱼惊旋 (4星)
- **关键亮点**：
  - 思路清晰，通过冒泡排序的类比，简化了问题的理解。
  - 代码实现简洁，直接通过双重循环进行交换操作。
  - 强调了交换次数的上限，确保不会超过 $n^2$ 次。
- **个人心得**：
  - 通过冒泡排序的思路，简化了问题的复杂度，同时保证了交换次数的可控性。

```cpp
puts("YES");
for(int i=1;i<=n;i++)//循环b的元素
{
	int x;
	for(int j=1;j<=n;j++)
	{
		if(a[j]==b[i])
		{
			x=j;//找位置
			break;
		}
	}
	for(int j=x;j>i;j--)//交换
	{
		swap(a[j],a[j-1]);
		cout<<j<<" "<<j-1<<'\n';
	}
}
cout<<0<<" "<<0<<'\n';
```

#### 3. 作者：little_cindy (4星)
- **关键亮点**：
  - 代码结构清晰，通过 `bool` 变量标记无解情况，逻辑清晰。
  - 使用了 `sort` 进行排序判断，简化了无解判断的逻辑。
  - 交换操作部分代码简洁，易于理解。
- **个人心得**：
  - 通过 `bool` 变量标记无解情况，避免了复杂的逻辑判断，代码更加简洁。

```cpp
puts("YES");
for(int i=1;i<=n;i++){
    if(a[i]==b[i]){
        continue;
    }
    int pos=0;
    for(int j=i;j<=n;j++){
        if(a[j]==b[i]){
            pos=j;
            break;
        }
    }
    for(int j=pos;j>i;j--){
        cout<<j<<' '<<j-1<<endl;
        swap(a[j],a[j-1]);
    }
}
cout<<"0 0";
```

### 最优关键思路与技巧

1. **无解判断**：通过排序后比较 $a$ 和 $b$ 是否相同，确保问题有解的必要条件。
2. **有解构造**：使用类似选择排序或冒泡排序的方式，逐个将 $a$ 中的元素交换到 $b$ 中对应的位置，确保交换次数不超过 $n^2$ 次。
3. **代码优化**：使用 `std::sort` 进行排序判断，简化了无解判断的逻辑；通过双重循环进行交换操作，代码简洁高效。

### 可拓展之处

- **类似问题**：可以扩展到其他需要通过交换操作将序列转换为目标序列的问题，如逆序对问题、最小交换次数问题等。
- **算法套路**：选择排序和冒泡排序的结合使用，可以应用于其他需要通过交换操作进行排序或构造的问题。

### 推荐相似题目

1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P1966 火柴排队](https://www.luogu.com.cn/problem/P1966)
3. [P1774 最接近神的人](https://www.luogu.com.cn/problem/P1774)

---
处理用时：52.34秒
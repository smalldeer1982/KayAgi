# 题目信息

# [Aya Round 1 F] 琪露诺的选择题

## 题目背景

**Problem Number:** [$\textit{24}$](https://www.luogu.com.cn/training/1392)

在经过射命丸文的一番调教之后，琪露诺的智商总算增长了⑨点。

现在寺子屋又要开始考试了，琪露诺通过一些手段知道了答案中的一些信息，而且因为她冰雪聪明，她不希望自己的成绩进步太明显，从而被老师上白泽慧音特别关照。因此她找到了你寻求一些帮助。

（注意：考试作弊是不对的！）

## 题目描述

有 $2\cdot n$ 道选择题，每题有 $\text{A}$ 和 $\text{B}$ 两个选项。正确答案可以表示为一个长度为 $2\cdot n$ 的字符串。

现在你要构造出一份作答（长度同样为 $2\cdot n$ 的字符串），其中**恰好**有 $a$ 个 $\text{A}$，同时与正确答案相比，你的作答恰好有 $e$ 个错误。如果不存在这样的构造方案，报告无解。

**注意：为了方便处理，本题保证 $e\le n$。**

**形式化地**，给定 $n,a,e$ 和一个长度为 $2\cdot n$ 的 01 串 $s$，你需要构造出一个恰好有 $a$ 个字符是 $\texttt 0$ 的长度为 $2\cdot n$ 的 01 串 $p$，使得

$$
\left(\sum_{i=1}^{2\cdot n}[s_i\ne p_i]\right)=e,
$$

其中 $[]$ 是 Iverson Bracket，详见「**说明/提示**」中的「提示」。

## 说明/提示

### 样例解释

对于数据 $1$，你构造出的作答串 $\text{BB{\color{e74c3c}AA}BB}$ 中恰好有 $2$ 个 $\text A$，与答案串相比刚好有 $3$ 处不同（即，有 $3$ 处错误）：

$$
\text{{\color{e74c3c}A}BA{\color{e74c3c}B}B{\color{e74c3c}A}}\\
\text{{\color{52c41a}B}BA{\color{52c41a}A}B{\color{52c41a}B}}
$$

故符合要求。

对于数据 $2$，不存在合法构造方案。

### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le T\le 100$，$1\le n\le 10^5$，$0\le e\le n$，$0\le a\le 2\cdot n$。

单组测试点内保证 $\sum(2\cdot n)\le 10^6$。

### 提示

$\textbf{A. Iverson Bracket}$

Iverson Bracket，是一种用方括号记号，如果方括号内的条件满足则为 $1$，不满足则为 $0$。更确切地讲，

$$
[P]=\begin{cases}1, & \text{If }P\text{ is true,}\\0,&\text{Otherwise.}\end{cases}
$$

## 样例 #1

### 输入

```
2
3 2 3
ABABBA
3 3 1
AAABBB```

### 输出

```
BBAABB
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个满足特定条件的字符串，要求其与给定字符串的差异数为 `e`，并且包含 `a` 个 `A`。题解中主要分为两类思路：

1. **数学建模与方程求解**：通过建立方程，求解需要将多少个 `A` 改为 `B`，以及将多少个 `B` 改为 `A`，从而满足条件。这种思路简洁高效，适用于大多数情况。
2. **贪心与模拟**：通过遍历字符串，逐步修改字符以满足条件。这种思路较为直观，但实现复杂度较高，容易出错。

### 所选高星题解

#### 1. **作者：DesignDigits (5星)**
- **关键亮点**：通过数学建模，建立方程组求解需要修改的 `A` 和 `B` 的数量，思路清晰，代码简洁高效。
- **核心实现思想**：通过 `count` 函数统计原串中 `A` 的数量，建立方程求解 `x` 和 `y`，然后遍历字符串进行修改。
- **代码片段**：
  ```cpp
  int a_ = count(s.begin(), s.end(), 'A'), b_ = count(s.begin(), s.end(), 'B');
  if((a-a_+e)&1) {cout<<"-1\n"; continue; }
  int x=-a+a_+e>>1, y=a-a_+e>>1;
  if(x<0 || x>a_ || y<0 || y>b_) cout<<"-1\n";
  else{
      int A_edited=0, B_edited=0;
      for(int i=0; i<2*n; i++){
          if(s[i]=='A' && A_edited<x){
              s[i]='B';
              A_edited++;
          }
          else if(s[i]=='B' && B_edited<y){
              s[i]='A';
              B_edited++;
          }
      }
      cout<<s<<"\n";
  }
  ```

#### 2. **作者：sixrc (4星)**
- **关键亮点**：通过小学和差问题的思路，列出方程求解 `p` 和 `q`，思路清晰，代码实现较为简洁。
- **核心实现思想**：通过方程求解需要保留的 `A` 和需要修改的 `B` 的数量，然后遍历字符串进行修改。
- **代码片段**：
  ```cpp
  int sum = e - sa + na;
  if (sum & 1){
      puts ("-1");
      continue;
  }
  q = sum / 2, p = (na - e + sa) / 2;
  if (p < 0 || q < 0 || p > min(na, sa) || q > min(na, sb)){
      puts ("-1");
      continue;
  }
  for (int i=1; i<=len; i++){
      if (s[i] == 'A'){
          if (p) printf ("A"), p --;
          else printf ("B");
      }
      else{
          if (q) printf ("A"), q --;
          else printf ("B");
      }
  }
  ```

#### 3. **作者：CSP_Sept (4星)**
- **关键亮点**：通过固定 `A` 的数量，然后通过交换操作调整错误数量，思路清晰，代码实现较为复杂但逻辑严密。
- **核心实现思想**：先固定 `A` 的数量，然后通过交换操作调整错误数量，最后输出结果。
- **代码片段**：
  ```cpp
  for(int i = 1 ; i <= m ; i++){
      if(p[i] + 'A' == s[i]){
          if(p[i] == 0){
              if(opa){printf("B"); opa--;}
              else printf("A");
          }
          else if(p[i] == 1){
              if(opb){printf("A"); opb--;}
              else printf("B");
          }
      }
      else printf("%c", p[i] + 'A');
  }
  ```

### 最优关键思路与技巧

1. **数学建模**：通过建立方程求解需要修改的 `A` 和 `B` 的数量，是最优的思路，简洁高效。
2. **贪心与模拟**：通过遍历字符串逐步修改字符，虽然直观，但实现复杂度较高，容易出错。

### 可拓展之处

1. **类似题目**：可以扩展到其他需要构造满足特定条件的字符串的题目，如构造回文串、构造特定模式的字符串等。
2. **算法套路**：数学建模与方程求解的思路可以应用于其他需要满足多个条件的构造问题。

### 推荐题目

1. **P1003 铺地毯**：考察构造与模拟，要求根据给定条件构造地毯的铺设方案。
2. **P1047 校门外的树**：考察区间覆盖与构造，要求根据给定条件构造树的种植方案。
3. **P1056 排座椅**：考察贪心与构造，要求根据给定条件构造座椅的排列方案。

### 个人心得摘录

- **DesignDigits**：通过数学建模，建立方程组求解需要修改的 `A` 和 `B` 的数量，思路清晰，代码简洁高效。
- **sixrc**：通过小学和差问题的思路，列出方程求解 `p` 和 `q`，思路清晰，代码实现较为简洁。
- **CSP_Sept**：通过固定 `A` 的数量，然后通过交换操作调整错误数量，思路清晰，代码实现较为复杂但逻辑严密。

---
处理用时：49.56秒
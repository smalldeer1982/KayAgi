# 题目信息

# 「DTOI-5」进行一个排的重 (Minimum Version)

## 题目背景

**本题与 Maximum Version 的区别是所求最值和数据范围不同。**

小 L 热衷于重排数列使之规整。

## 题目描述

小 L 有一个长为 $n$ 的序列 $a$，其中每一项 $a_i$ 都是一个 pair $(p_i, q_i)$。

为了让 $a$ 看起来规整一些，他钦定 $p, q$ 分别均为长为 $n$ 的排列。

为了对 $a$ 的规整程度进行量化计算，他给出了一个权值函数 $f(a) = \displaystyle\sum_{i = 1}^n ([p_i > \max_{j = 1}^{i - 1} p_j] + [q_i > \max_{j = 1}^{i - 1} q_j])$。**注意 $i = 1$ 时两个方括号都能取到值，因为我们认为 $\displaystyle\max_{j = 1}^0 p_j = \displaystyle\max_{j = 1}^0 q_j = -\infty$。**

为了让 $a$ 看起来更加规整，他决定分别以某种方式重排 $a$ 得到 $a'$ 使得 $f(a')$ 最小。**注意重排时必须将 $a'_i = (p'_i, q'_i)$ 视为整体。**

他希望你求出 $f(a')_{\min}$ 的值，以及分别有多少个 $a'$ 可以取到 $f(a')_{\min}$。

由于方案数可能很大，你只需要求出结果对 $998244353$ 取模的值。

## 说明/提示

**【数据范围】**

$$
\def\or{\operatorname{or}}
%\def\arrayscretch{1.5}
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Subtask}&n\le &\textbf{Points}\cr\hline
\sf1&10&10 \operatorname{pts}\cr\hline
\sf2&500&20 \operatorname{pts}\cr\hline
\sf3&5\times10^3&20 \operatorname{pts}\cr\hline
\sf4&10^5&20 \operatorname{pts}\cr\hline
\sf5&5\times10^5&30 \operatorname{pts}\cr\hline
\end{array}
$$

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$1 \leq p_i, q_i \leq n$，保证 $p, q$ 均为**排列**。

## 样例 #1

### 输入

```
5
1 5 2 4 3
1 4 2 5 3```

### 输出

```
3 48```

# AI分析结果

### 综合分析与结论

本题的核心在于通过重排序列使得权值函数 \( f(a) \) 最小化。所有题解都采用了分类讨论的思路，主要分为两种情况：

1. **存在 \( p_i = q_i = n \)**：将 \((n, n)\) 放在序列开头，权值为 2，方案数为 \((n-1)!\)。
2. **不存在 \( p_i = q_i = n \)**：将 \( p_i = n \) 或 \( q_i = n \) 放在开头，权值为 3，方案数为 \(\frac{(n-1)!}{n-q_i} + \frac{(n-1)!}{n-p_j}\)。

各题解在实现细节上有所不同，但整体思路一致。以下是对各题解的评分与亮点总结：

---

### 所选高星题解

#### 1. **作者：FFTotoro (★★★★★)**

**关键亮点：**
- 思路清晰，分类讨论简洁明了。
- 代码实现简洁，使用了快速幂和逆元计算，优化了方案数的计算。
- 代码可读性高，变量命名合理，逻辑清晰。

**核心代码：**
```cpp
int f(int n){
  int s=1;
  for(int i=2;i<=n;i++)
    (s*=i)%=mod;
  return s;
}
int qpow(int a,int b){
  int r=1;
  while(b){
    if(b&1)r=r%mod*a%mod;
    a=a%mod*a%mod; b>>=1;
  }
  return r;
}
int inv(int x){return qpow(x,mod-2);}
```
**核心思想：** 通过快速幂计算逆元，优化方案数的计算。

---

#### 2. **作者：DengDuck (★★★★☆)**

**关键亮点：**
- 分类讨论清晰，方案数的计算通过组合数学推导，逻辑严谨。
- 代码实现简洁，使用了快速幂和逆元计算。
- 代码可读性较好，但变量命名稍显随意。

**核心代码：**
```cpp
LL ksm(LL x,LL y){
	LL ans=1;
	while(y){
		if(y&1)ans=ans*x%mod;
		x=x*x%mod,y>>=1;
	}
	return ans;
}
```
**核心思想：** 通过组合数学推导方案数，使用快速幂计算逆元。

---

#### 3. **作者：Leasier (★★★★☆)**

**关键亮点：**
- 分类讨论详细，方案数的计算通过排列组合推导，逻辑严谨。
- 代码实现较为复杂，但优化了方案数的计算，使用了预处理阶乘和逆元。
- 代码可读性较好，但部分逻辑稍显冗余。

**核心代码：**
```cpp
inline ll arrange(int n, int m){
	if (n < 0 || m < 0 || n < m) return 0;
	return fac[n] * inv_fac[n - m] % mod;
}
```
**核心思想：** 通过预处理阶乘和逆元，优化方案数的计算。

---

### 最优关键思路与技巧

1. **分类讨论**：将问题分为两种情况处理，简化了问题的复杂度。
2. **快速幂与逆元**：通过快速幂计算逆元，优化了方案数的计算。
3. **组合数学**：通过排列组合推导方案数，确保计算的准确性。

---

### 可拓展之处

- **类似题目**：可以拓展到多维序列的重排问题，或者权值函数更为复杂的情况。
- **算法套路**：分类讨论 + 组合数学 + 快速幂计算逆元，是解决类似问题的常见套路。

---

### 推荐题目

1. **P1494 [国家集训队]小Z的袜子**（题号：P1494）
   - 考察组合数学与概率计算。
   
2. **P3811 【模板】乘法逆元**（题号：P3811）
   - 考察快速幂与逆元的计算。

3. **P3383 【模板】线性筛素数**（题号：P3383）
   - 考察数论中的筛法与预处理。

---

### 个人心得摘录

- **FFTotoro**：通过快速幂计算逆元，避免了直接除法的精度问题，提高了代码的鲁棒性。
- **DengDuck**：组合数学的推导过程较为复杂，但通过化简最终得到了简洁的方案数公式。
- **Leasier**：预处理阶乘和逆元，虽然增加了代码复杂度，但显著提高了计算效率。

**总结：** 通过分类讨论和组合数学推导，结合快速幂与逆元计算，能够高效解决此类问题。

---
处理用时：39.00秒
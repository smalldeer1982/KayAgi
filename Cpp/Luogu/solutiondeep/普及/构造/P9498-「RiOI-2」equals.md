# 题目信息

# 「RiOI-2」equals

## 题目背景

在小树上坐落着一个幻想的城堡。这里是 E 国的领地，而小 E，则是 E 国之王。

为了打造一个完美的 E 国，他需要明辨是非，走向正义。

但是，他似乎有些太理想了。有时并没有一个完美的准则。是黑是白，谁能分辨？

## 题目描述

给定一棵 $n$ 个结点，以 $1$ 为根的树，定义一个结点的深度 $d_i$ 表示它到根结点的简单路径上的结点个数。

你需要给每个结点黑白染色，满足黑色结点的深度和等于白色结点的深度和。设 $c_i = \{0, 1\}$ 分别代表编号为 $i$ 的结点为黑色或白色，那么这即 $\displaystyle\sum_{c_i=0}d_i=\sum_{c_i=1}d_i$。

若无解，仅输出一行一个整数 $-1$。

## 说明/提示

### 样例解释

对于第一组数据，每个结点的深度分别是 $d=[1,2,2,3,3,3]$。黑色结点的深度和为 $d_1+d_5+d_6=1+3+3=7$，白色结点的深度和为 $d_2+d_3+d_4=2+2+3=7$。它们相等，所以样例输出是正确的。可能的正确输出包括但不限于样例输出、`0 1 1 0 0 1`，`1 0 0 1 0 1` 等。

### 数据规模与约定

**本题采用捆绑测试。**

| $\rm Subtask$ | 分值 | $n\le $ | 特殊性质 |
| :-----------: | :--: | :-----: | :------: |
| $0$ | $5$ | $20$ | / |
| $1$ | $15$ | $500$ | / |
| $2$ | $20$ | $5\times 10^3$ | / |
| $3$ | $10$ | / | $n$ 为偶数 |
| $4$ | $5$ | / | 树为菊花图（不保证根为菊花中心） |
| $5$ | $5$ | / | 树为一条链（不保证根为链的端点） |
| $6$ | $40$ | / | / |

斜杠表示这一栏无特殊限制。

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le u_i,v_i\le n$，输入数据构成一棵树。

## 样例 #1

### 输入

```
6
1 2
1 3
2 4
2 5
2 6```

### 输出

```
0 1 1 1 0 0```

## 样例 #2

### 输入

```
5
1 2
1 3
2 4
2 5```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于如何将树的节点染色，使得黑色和白色节点的深度和相等。大多数题解都采用了以下思路：
1. **深度计算**：通过DFS或BFS计算每个节点的深度。
2. **深度和判断**：若深度和为奇数，则无解；否则，深度和为偶数时一定有解。
3. **贪心策略**：从大到小或从小到大排序深度，贪心地选择节点，确保深度和达到总深度和的一半。

### 题解评分与亮点

#### 1. 作者：TernaryTree (赞：18)
- **星级**：5星
- **关键亮点**：
  - 详细分析了不同子任务的解法，特别是对菊花图和链的特殊情况进行了深入讨论。
  - 提供了DFS和BFS两种实现方式，代码清晰且优化到位。
  - 通过排序和贪心策略，确保了算法的正确性和高效性。
- **个人心得**：作者通过分组处理深度序列，证明了贪心策略的正确性，展示了较强的数学思维。

```cpp
void dfs(int u, int fa) {
    dep[u] = make_pair(dep[fa].fs + 1, u);
    for (int i = 0; i < g[u].size(); i++) {
        int v = g[u][i];
        if (v != fa) dfs(v, u);
    }
}
```

#### 2. 作者：ys_kylin__ (赞：9)
- **星级**：4星
- **关键亮点**：
  - 通过排序和贪心策略，从大到小选择节点，确保深度和达到总深度和的一半。
  - 代码简洁，逻辑清晰，适合初学者理解。
- **个人心得**：作者强调了深度序列的连续性，利用这一性质简化了问题。

```cpp
for(int i=n;i;i--) {
    if(sum2+d[i].num<sum/2) {
        sum2+=d[i].num;
        ans[d[i].id]=1;
    }
}
```

#### 3. 作者：GaCGe (赞：5)
- **星级**：4星
- **关键亮点**：
  - 通过排序和贪心策略，从大到小选择节点，确保深度和达到总深度和的一半。
  - 代码实现简洁，逻辑清晰。
- **个人心得**：作者通过降序排序，优先处理深度较大的节点，确保了贪心策略的正确性。

```cpp
for(int i=1;i<=n;i++) {
    if(cnt1>cnt2) {
        flag[e[i].num]=1;
        cnt2+=e[i].dd;
    }
    else cnt1+=e[i].dd;
}
```

### 最优关键思路与技巧

1. **深度序列的连续性**：利用树的深度序列是连续的，简化了问题的复杂度。
2. **贪心策略**：从大到小或从小到大排序深度，贪心地选择节点，确保深度和达到总深度和的一半。
3. **DFS/BFS计算深度**：通过DFS或BFS计算每个节点的深度，是解决树相关问题的基础。

### 可拓展之处

1. **类似问题**：类似的问题可以扩展到其他树的性质，如节点度数、子树大小等。
2. **算法套路**：贪心策略在树的问题中应用广泛，特别是在需要满足某种平衡条件时。

### 推荐题目

1. **P1351 联合权值**：考察树的遍历和权值计算。
2. **P3379 【模板】最近公共祖先（LCA）**：考察树的深度和最近公共祖先。
3. **P1040 加分二叉树**：考察树的构造和最优解问题。

### 个人心得总结

- **调试经历**：多位作者提到在实现过程中需要注意深度和的计算，避免溢出或错误。
- **踩坑教训**：不开long long会导致错误，强调了数据类型选择的重要性。
- **顿悟感想**：通过深度序列的连续性，简化了问题的复杂度，展示了数学思维在算法设计中的重要性。

---
处理用时：32.33秒
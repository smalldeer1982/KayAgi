# 题目信息

# 「TAOI-2」核心共振

## 题目背景

⚡超越一切震慑凡人⚡

⚡带来终结机械降神⚡

⚡风暴之力充满全身⚡

⚡最后一击核心共振⚡

## 题目描述

给定正整数 $p$ 和 $n$。对于一个排列，我们称其中相邻两项产生「共振」当且仅当这两个数的和为 $p$ 的倍数。

请你构造一个 $1 \sim n$ 的排列，最大化其中产生「共振」的次数。如果有多种方案，输出任意一种即可。

## 说明/提示

**本题采用捆绑测试。**

+ Subtask 0（15 pts）：$n \leq 9$，$T \le 10$。
+ Subtask 1（10 pts）：$p = 2$。
+ Subtask 2（30 pts）：$p = 3$。
+ Subtask 3（45 pts）：无特殊限制。

对于所有数据，$1 \leq n \leq 10^5$，$1 \leq p \leq 10^8$，$1 \leq T \leq 10^4$，$1 \leq \sum n \leq 3\times 10^5$。

## 样例 #1

### 输入

```
3
9 1
5 2
1 12345
```

### 输出

```
3 8 7 1 4 5 6 9 2
1 5 3 2 4
1
```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个排列，使得相邻两项的和为 \( p \) 的倍数的次数最大化。多数题解都采用了将数按模 \( p \) 的余数分类，并通过交替输出余数互补的数对来最大化共振次数。此外，许多题解还注意到了当 \( p \) 较大时（如 \( p > 2n \)），共振不可能发生，因此直接输出顺序排列即可。

### 所选高星题解

#### 1. 作者：include13_fAKe (赞：11) - 4星
**关键亮点**：
- 详细分析了不同子任务的处理方法，特别是 \( p=2 \) 和 \( p=3 \) 的特殊情况。
- 提出了当 \( p \) 为偶数时，需要特处理余数为 \( \frac{p}{2} \) 的数。
- 代码简洁，逻辑清晰，且包含了优化处理 \( p > 2n \) 的情况。

**个人心得**：
- 作者提到在调试时发现 TLE 问题，最终通过优化特判 \( p > 2n \) 的情况解决了问题。

**核心代码**：
```cpp
if(n*2<p){
    for(int i=1;i<=n;i++) printf("%d ",i);
    return ;
}
for(int i=1;i*2<p;i++){
    for(int j=0;j<=n;j+=p){
        if(i+j<=n) printf("%d ",i+j);
        if(j+p-i<=n) printf("%d ",j+p-i);
    }
}
for(int i=p;i<=n;i+=p) printf("%d ",i);
if(p%2==0){
    for(int i=p/2;i<=n;i+=p) printf("%d ",i);
}
```

#### 2. 作者：I_will_AKIOI (赞：7) - 4星
**关键亮点**：
- 使用队列和集合来优化选择非空队列的过程，避免了双重循环的 TLE 问题。
- 详细解释了如何通过模 \( p \) 的余数来配对互补的数对。

**核心代码**：
```cpp
for(int i=2;i<=n;i++) q[i%p].push(i);
for(int i=0;i<p;i++) if(!q[i].empty()) s.insert(i);
now=1;
cout<<now<<" ";
for(int i=2;i<=n;i++){
    int f=(p-now%p)%p;
    if(q[f].empty()) s.erase(f),f=*s.begin();
    now=q[f].front();
    q[f].pop();
    if(q[f].empty()) s.erase(f);
    cout<<now<<" ";
}
```

#### 3. 作者：Eason_cyx (赞：4) - 4星
**关键亮点**：
- 提供了详细的数学推导和构造思路，特别是对于 \( p \) 为偶数和奇数时的不同处理。
- 代码中包含了多个特判，确保了在各种情况下的正确性。

**核心代码**：
```cpp
if(p == 1 || (p > (2 * n - 1))) {
    for(int i = 1;i <= n;i++) cout << i << ' ';
    cout << "\n";
}
else {
    for(int i = p;i <= n;i += p) cout << i << ' ';
    for(int m1 = 1,m2 = p - 1;m1 <= p / 2;m1++,m2--){
        if(m1 != m2){
            for(int i = 0;i + m2 <= n;i += p) cout << i + m1 << ' ' << i + m2 << ' ';
            if((int)(n / p) * p + m1 <= n && (int)(n / p) * p + m2 > n) cout << (int)(n / p) * p + m1 << ' ';
        }
        else for(int i = 0;i + m1 <= n;i += p) cout << i + m1 << ' ';
    }
}
```

### 最优关键思路与技巧
1. **按模 \( p \) 分类**：将数按模 \( p \) 的余数分类，便于找到互补的数对。
2. **交替输出互补数对**：通过交替输出余数互补的数对，最大化共振次数。
3. **特判 \( p > 2n \)**：当 \( p \) 较大时，直接输出顺序排列，避免不必要的计算。

### 可拓展之处
- 类似的问题可以推广到其他模数或更复杂的条件，如要求相邻三项的和为某数的倍数。
- 可以进一步优化数据结构，如使用更高效的集合或优先队列来处理大规模数据。

### 推荐题目
1. [P1008 三连击](https://www.luogu.com.cn/problem/P1008)
2. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)
3. [P1036 选数](https://www.luogu.com.cn/problem/P1036)

---
处理用时：36.73秒
# 题目信息

# [信息与未来 2016] 方格取数

## 题目描述

在 $n$ 行 $m$ 列的方格矩阵中，每个方格都包含一个数字。小明可以从任意方格出发开始移动。每次移动可以移到与当前方格有一条边相邻的方格（即向上、下、左或右方向移动 $1$ 格，且不能移出边界）。除此之外，你移动到的方格中的数字必须比当前方格中的数字更大。

请你帮助小明编程规划移动路径，使路径上经过的所有数字之和最大。

## 说明/提示

### 样例 $\textbf 1$ 解释
样例数据 1 对应的矩阵如下。图中路径数字之和 $4+5+7+8=24$。
$$
\begin{array}{|c|c|c|c|c|}\hline 
9 & 7 & 10 & 10 & 8\\\hline
2 & 9 & 2 & 5 &3\\\hline
2 & 5 & \red5 & \red7 & 7\\\hline
5 & 8 & \red4 & \red8 & 5\\\hline
\end{array}
$$
### 数据范围
$1\le n,m\le 100,1\le s\le 19997$。
> 本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
4 5 97```

### 输出

```
24```

## 样例 #2

### 输入

```
40 50 1```

### 输出

```
47```

# AI分析结果

• 综合分析与结论：三道题解均围绕在方格矩阵中按特定规则移动求最大数字和这一问题。思路上，都先按给定规则构造方格矩阵，再通过搜索寻找最大和路径。算法要点为利用搜索算法，其中前两道题解采用记忆化搜索，第三道采用普通的广度优先搜索（BFS）。难点在于如何高效搜索以避免超时，记忆化搜索通过记录已搜索过的点的结果，避免重复计算，优化了搜索效率；而第三道题解的BFS未进行记忆化，在数据量较大时效率较低。从质量上看，Max_robot和lizhixun的题解思路清晰，代码可读性较好，且使用记忆化搜索优化，相对更优。

所选的题解：
  - **作者：Max_robot (5星)**
    - **关键亮点**：思路清晰，代码注释详细，对每个步骤如方格构造、搜索过程及答案寻找都有清晰解释，采用记忆化搜索优化算法。
    - **核心代码**：
```cpp
long long f(int x, int y) {
    if(dp[x][y]) return dp[x][y];
    dp[x][y]=a[x][y];
    for(int i=0;i<4;i++){
        int nx=x+dx[i], ny=y+dy[i];
        if (nx>=1 && nx<=n && ny>=1 && ny<=m && a[nx][ny]>a[x][y]){
            dp[x][y]=max(dp[x][y], f(nx, ny)+a[x][y]);
        }
    }
    return dp[x][y];
}
```
    - **核心实现思想**：记忆化搜索函数f，若当前点(x, y)的结果已计算过则直接返回；否则初始化为该点的值，枚举四个方向，若新点在矩阵内且值比当前点大，则更新当前点的最大和。
  - **作者：lizhixun (5星)**
    - **关键亮点**：逻辑清晰，对问题描述、解题思路、状态转移方程及初始化都有明确阐述，同样采用记忆化搜索，代码简洁规范。
    - **核心代码**：
```cpp
int dfs(int x, int y) {
	if (dp[x][y]!= -1) return dp[x][y];
	dp[x][y] = a[x][y];
	for (int i = 1; i <= 4; i++) {
		int tx = x + fx[i];
		int ty = y + fy[i];
		if (tx <= 0 || tx > n || ty <= 0 || ty > m) continue;
		if (a[tx][ty] <= a[x][y]) continue;
		dp[x][y] = max(dp[x][y], dfs(tx, ty) + a[x][y]);
	}
	return dp[x][y];
}
```
    - **核心实现思想**：dfs函数为记忆化搜索，若dp[x][y]已计算过则返回，否则初始化为a[x][y]，遍历四个方向，满足条件时更新dp[x][y]为当前值与从新点出发的最大和加上当前点值的较大值。

最优关键思路或技巧：采用记忆化搜索，通过记录已访问点的最大路径和，避免重复计算，从而提高算法效率。

可拓展之处：同类型题可涉及不同的矩阵移动规则，如斜向移动、跳跃移动等，或对路径有其他限制条件。类似算法套路是在搜索问题中，若存在重复子问题，可考虑使用记忆化搜索优化。

推荐洛谷题目：
  - P1120 小木棍［数据加强版］，考察搜索及剪枝优化。
  - P1434 [SHOI2002]滑雪，类似方格移动求最长路径问题。
  - P1312 玛雅游戏，涉及搜索与状态记录。 

---
处理用时：16.89秒
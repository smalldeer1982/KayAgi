# 题目信息

# [信息与未来 2016] 素数分解

## 题目描述

素数，又称质数，是指除 $1$ 和其自身之外，没有其他约数的正整数。例如，$2,3,5,7,13$ 都是质数，而 $4,9,12,18$ 则不是。

虽然素数不能分解成除 $1$ 和其自身之外整数的乘积，但却可以分解成更多素数的和。你需要编程求出一个正整数最多能分解成多少个互不相同的素数的和。

## 说明/提示

### 样例 $\textbf 1$ 解释
$21=2+3+5+11$。
### 数据范围
$10\le n\le 200$。

**保证有解。**
> 本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
21```

### 输出

```
4```

## 样例 #2

### 输入

```
128```

### 输出

```
9```

# AI分析结果

• 综合分析与结论：两道题解思路相近，均利用数据范围小的特点，先筛出200以内素数，再通过深度优先搜索（DFS）枚举每个素数选或不选来求解。算法要点在于素数筛选和DFS实现。解决难点主要是避免无效搜索，两题解都采用了剪枝优化。yedalong题解额外提到优先选大质数的技巧以加快剪枝，lizhixun题解代码较常规。

所选的题解：
  - yedalong题解：★★★★
    - 关键亮点：提出优先选大质数的优化技巧，加快剪枝过程，提高搜索效率。
    - 核心代码片段（DFS部分）：
```cpp
void dfs(int now,int sum,int k){
	if(now==prime.size()){
		if(sum==n) ans=max(ans,k);
		return;
	}
	if(sum>n) return;
	dfs(now+1,sum,k);
	dfs(now+1,sum+prime[now],k+1);
} 
```
核心实现思想：通过递归，`now`表示当前考虑的质数下标，`sum`为当前已选质数和，`k`为已选质数个数。递归时分别考虑不选当前质数（`dfs(now + 1, sum, k)`）和选当前质数（`dfs(now + 1, sum + prime[now], k + 1)`）两种情况，同时进行剪枝判断。

最优关键思路或技巧：优先选大质数可使不合法情况更快被排除，减少无效搜索，优化搜索过程。

可拓展思路：同类型题常涉及在有限数据范围内通过枚举、搜索解决组合问题，类似套路如利用状态压缩优化搜索空间等。

推荐洛谷题目：
1. P1036 [NOIP2002 普及组] 选数：同样是从一些数中选数组合满足特定条件（和为质数）。
2. P1157 组合的输出：通过枚举组合解决问题，与本题搜索思路类似。
3. P1219 [USACO1.5]八皇后 Checker Challenge：经典搜索问题，可锻炼搜索算法运用能力。 

---
处理用时：9.95秒
# 题目信息

# [GXPC-S 2024] 扫雷

## 题目背景

小林最近迷上了扫雷游戏。

## 题目描述

一个扫雷游戏可以被抽象成一个 $n$ 行 $m$ 列的字符矩阵，不妨记第 $i$ 行第 $j$ 列的字符为 $S_{i,j}$。

若 $S_{i,j}=\texttt{*}$，表示格子 $(i,j)$ 上有一个地雷；

若 $S_{i,j}=\texttt{?}$，表示格子 $(i,j)$ 情况未知；

若 $S_{i,j}\in [0,8]$，表示格子 $(i,j)$ 周围的 $8$ 个格子中有 $S_{i,j}$ 个地雷（这个格子本身没有地雷）。
形式化地说，记

$$
f(i,j)=\begin{cases}
1, & (i,j)\text{ 上有地雷} \\
0, & \text{其他情况} \\
\end{cases}
$$

特别地，对于超出棋盘边界的情况，规定 $f(i,j)=0$。
则 $\displaystyle S_{i,j}=\sum_{p=-1}^1\sum_{q=-1}^1 f(i+p,j+q)$。

给定一个棋盘，你可以任意决定每个 $\texttt{?}$ 格子上是否有炸弹。你想要知道是否存在方案使得这个棋盘是合法的。
我们定义一个棋盘**合法**，当且仅当填有数字 $x$ 的格子周围的八个格子上恰好有 $x$ 个炸弹。

你需要解决 $T$ 组数据。

## 说明/提示

对于第一组数据：问号处选择不填是一种合法方案。可以证明这是唯一的合法方案。

**本题采用捆绑测试。**

- Subtask 1（20pts）：至多存在 $1$ 组 $(i,j)$，使得 $S_{i,j}=\texttt{?}$；
- Subtask 2（80pts）：无额外约束。

对于 $100\%$ 的数据，保证：

- $1\le T,n,m\le 10$；
- 至多存在 $10$ 组 $(i,j)$，使得 $S_{i,j}=\texttt{?}$；
- $\forall 1\le i\le n,1\le j\le m$，保证 $S_{i,j}\in\{0,1,2,3,4,5,6,7,8,\texttt{?},\texttt{*}\}$。


## 样例 #1

### 输入

```
3
2 2
**
2?
2 2
*1
3?
2 2
**
21```

### 输出

```
YES
NO
NO```

# AI分析结果

### 综合分析与结论
题目的核心是判断在给定的扫雷棋盘上，通过对未知格子（`?`）填充地雷，能否使棋盘合法。所有题解都基于数据范围较小这一特点，采用暴力枚举的方法。通过枚举`?`格子是否为地雷的所有可能状态，再对每种状态检查棋盘是否合法。

### 所选的题解
 - **作者：Sliarae (赞：0) - 4星**
    - **关键亮点**：思路清晰，直接利用数据范围限制，通过枚举所有`?`格子的状态（不超过$2^{10}$种），再对每种状态下的棋盘进行合法性检查。代码结构简洁，可读性较好。
    - **核心代码片段**：
```cpp
void Solve () {
    cin >> n >> m;
    vector<pair<int, int>> vec;
    for (int i = 1; i <= n; ++i) 
        for (int j = 1; j <= m; ++j) { 
            cin >> s[i][j];
            if (s[i][j] == '?') vec.push_back({i, j});
        }
    bool ans = 0; 
    for (int st = 0; st < (1 << vec.size()); ++st) {
        for (int i = 0; i < vec.size(); ++i) {
            int x = vec[i].first, y = vec[i].second;
            s[x][y] = ((st >> i) & 1? '*' : '.');
        }
        bool valid = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (s[i][j] >= '0' && s[i][j] <= '8') {
                    int cnt = s[i][j] - '0';
                    const int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};
                    const int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};
                    for (int k = 0; k < 8; ++k) {
                        int x = i + dx[k];
                        int y = j + dy[k];
                        if (x >= 1 && x <= n && y >= 1 && y <= m && s[x][y] == '*')
                            --cnt;
                    } 
                    valid &=!cnt;
                }
            }
        }
        ans |= valid;
    }
    cout << (ans? "YES" : "NO") << '\n';
}
```
    - **核心实现思想**：首先收集所有`?`格子的坐标。然后通过循环枚举所有`?`格子状态的二进制表示`st`，将`st`的每一位对应`?`格子是否为地雷，更新棋盘。接着遍历棋盘上所有数字格子，检查其周围地雷数量是否与数字相符，若所有数字格子都满足条件，则该状态合法，更新答案。

### 最优关键思路或技巧
利用数据范围小的特点，采用暴力枚举所有可能的地雷分布状态，再对每种状态进行合法性检查。这种暴力枚举结合条件判断的方法，在数据范围允许的情况下，是解决此类问题的有效手段。

### 可拓展之处
同类型题可拓展到更大数据范围下的扫雷问题，此时暴力枚举可能不再适用，可考虑使用更高效的算法，如回溯法、动态规划等。类似算法套路是在数据范围较小时，可尝试暴力枚举所有可能情况；当数据范围增大时，需寻找能减少枚举量或更高效的状态转移方法。

### 洛谷相似题目推荐
 - [P1118 数字三角形](https://www.luogu.com.cn/problem/P1118)：通过动态规划解决数字三角形路径和问题，与本题类似，需考虑不同状态下的最优解或可行性。
 - [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：同样涉及状态转移和条件判断，利用动态规划解决过河卒的路径数量问题。
 - [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)：考察动态规划思想，通过分析不同状态下的子问题求解最长公共子序列，与本题解决问题的思路类似，都是在不同状态下进行条件判断和计算。 

---
处理用时：28.59秒
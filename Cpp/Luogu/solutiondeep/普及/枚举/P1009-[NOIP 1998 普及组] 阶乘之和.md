# 题目信息

# [NOIP 1998 普及组] 阶乘之和

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题

## 样例 #1

### 输入

```
3
```

### 输出

```
9```

# AI分析结果

这道题要求计算\(S = 1! + 2! + 3! + \cdots + n!\)（\(n \le 50\)），由于结果数值较大，常规数据类型无法存储，需使用高精度算法。众多题解主要围绕高精度加法和乘法展开，部分题解还涉及运算符重载、记忆化搜索等技巧。

### 题解综合分析
1. **思路与算法要点**
    - **直接高精计算**：多数题解采用先计算每个数的阶乘（通过高精乘法），再累加阶乘结果（通过高精加法）。例如，作者C_Z_C的题解，先利用高精乘法计算\(i\)的阶乘，再用高精加法累加到总和中。
    - **公式变形优化**：部分题解对公式进行变形，如\(S=1*(1+2*(1+3*(1+4*(......1+(n - 1)*(1+n))))\)，避免了频繁的高精加法，仅需高精乘和加1进位操作，如作者zhangboju的题解。
    - **特殊技巧**：有的题解使用了运算符重载，使代码更简洁直观，像作者二元长天笑重载了“+”“*”等运算符，模拟竖式计算；还有使用记忆化搜索，减少重复计算，如作者HohleFeuerwerke通过记忆化搜索维护已经得到的阶乘结果。
2. **解决难点**：高精度算法实现是主要难点，包括高精度乘法和加法的具体实现，如处理进位、数组操作等。同时，如何优化计算过程，减少时间和空间复杂度也是需要考虑的，例如利用阶乘的递推关系避免重复计算。

### 题解评分
1. **作者：二元长天笑（4星）**
    - **关键亮点**：通过重载运算符模拟竖式计算，使主程序简洁明了，有助于理解高精度运算原理。
    - **个人心得**：无
    - **核心代码**：
```cpp
struct fantastic {
    int len,s[9999];
    fantastic() {
        memset(s,0,sizeof(s));
        len=1;
    }
    fantastic operator=(const char*num) {
        len=strlen(num);
        for(int i=0;i<len;++i)
            s[i]=num[len - i - 1]-'0';
        return *this;
    }
    fantastic operator+(const fantastic &a) {
        fantastic c;
        c.len=max(len,a.len)+1;
        for(int i=0,x=0;i<c.len;++i) {
            c.s[i]=s[i]+a.s[i]+x;
            x=c.s[i]/10;
            c.s[i]=c.s[i]%10;
        }
        if(c.s[c.len - 1]==0)
            --c.len;
        return c;
    }
    fantastic operator * (const fantastic &x) {
        fantastic c;
        c.len=len+x.len;
        for(int i=0;i<len;++i)
            for(int j=0;j<x.len;++j) {
                c.s[i+j]+=s[i]*x.s[j];
                c.s[i+j+1]+=c.s[i+j]/10;
                c.s[i+j]%=10;
            }
        if(c.s[c.len - 1]==0)
            --c.len;
        return c;
    }
};
```
    - **核心思想**：定义`fantastic`结构体，重载赋值、加法和乘法运算符，在运算符重载函数中模拟竖式计算的过程，实现高精度数的运算。
2. **作者：HohleFeuerwerke（4星）**
    - **关键亮点**：采用记忆化搜索，利用已经计算出的阶乘结果，减少重复计算，提高效率，适合刚接触高精度的同学理解。
    - **个人心得**：无
    - **核心代码**：
```cpp
string add(string a,string b) {
    string ret;
    ll lenga=a.length(),lengb=b.length();
    if(lenga>lengb) {
        string zeros;
        for(ll i=1;i<=lenga - lengb;i++) zeros+="0";
        b=zeros+b;
    } else if(lenga<lengb) {
        string zeros;
        for(ll i=1;i<=lengb - lenga;i++) zeros+="0";
        a=zeros+a;
    }
    bool flag=false;
    for(ll i=max(lenga,lengb)-1;i>=0;i--) {
        int x=a[i]+b[i]-'0'*2;
        if(flag) flag=false,x++;
        if(x>=10) flag=true,x-=10;
        char c=x+'0';
        ret=c+ret;
    }
    if(flag) ret="1"+ret;
    return ret;
}
string mul(string str,ll m) {
    string ret;
    ll lengstr=str.length();
    if(m<10) {
        ll x=0;
        ll flag=0;
        for(ll i=lengstr-1;i>=0;i--) {
            x=(str[i]-'0')*m;
            x+=flag;flag=x/10;x%=10;
            char c=x+'0';
            ret=c+ret;
        }
        if(flag!=0) {
            char c=flag+'0';
            ret=c+ret;
        }
        return ret;
    } else if(m==10) return str+"0";
    else {
        ll u=m/10,v=m%10;
        return add(mul(mul(str,u),10),mul(str,v));
    }
}
string f(ll x) {
    if(visit[x]) return frac[x];
    if(x==1) return "1";
    if(x==2) return "3";
    string ret="1";
    visit[x]=true;
    for(int i=1;i<=x;i++) ret=mul(ret,i);
    ret=add(ret,f(x - 1));
    frac[x]=ret;
    return ret;
}
```
    - **核心思想**：`add`函数实现高精度加法，模拟竖式计算过程，处理进位；`mul`函数实现半高精度乘法，根据乘数大小不同采用不同计算方式；`f`函数通过记忆化搜索，若已计算过则直接返回结果，否则计算阶乘并累加，同时记录结果。
3. **作者：Bean233（4星）**
    - **关键亮点**：使用大整数类并采用压位操作，将每8位作为一个单位存储，提高了运算速度。
    - **个人心得**：无
    - **核心代码**：
```cpp
struct BigInteger {
    typedef unsigned long long LL;
    static const int BASE = 100000000;
    static const int WIDTH = 8;
    vector<int> s;
    BigInteger& clean() {while(!s.back()&&s.size()>1)s.pop_back(); return *this;}
    BigInteger(LL num = 0) {*this = num;}
    BigInteger(string s) {*this = s;}
    BigInteger& operator = (long long num) {
        s.clear();
        do {
            s.push_back(num % BASE);
            num /= BASE;
        } while (num > 0);
        return *this;
    }
    BigInteger& operator = (const string& str) {
        s.clear();
        int x, len = (str.length() - 1) / WIDTH + 1;
        for (int i = 0; i < len; i++) {
            int end = str.length() - i*WIDTH;
            int start = max(0, end - WIDTH);
            sscanf(str.substr(start,end - start).c_str(), "%d", &x);
            s.push_back(x);
        }
        return (*this).clean();
    }
    BigInteger operator + (const BigInteger& b) const {
        BigInteger c; c.s.clear();
        for (int i = 0, g = 0; ; i++) {
            if (g == 0 && i >= s.size() && i >= b.s.size()) break;
            int x = g;
            if (i < s.size()) x += s[i];
            if (i < b.s.size()) x += b.s[i];
            c.s.push_back(x % BASE);
            g = x / BASE;
        }
        return c;
    }
    BigInteger operator * (const BigInteger& b) const {
        int i, j; LL g;
        vector<LL> v(s.size()+b.s.size(), 0);
        BigInteger c; c.s.clear();
        for(i=0;i<s.size();i++) for(j=0;j<b.s.size();j++) v[i+j]+=LL(s[i])*b.s[j];
        for (i = 0, g = 0; ; i++) {
            if (g ==0 && i >= v.size()) break;
            LL x = v[i] + g;
            c.s.push_back(x % BASE);
            g = x / BASE;
        }
        return c.clean();
    }
};
```
    - **核心思想**：定义`BigInteger`结构体表示大整数，通过`vector<int>`存储每8位数据，重载赋值、加法和乘法运算符，在运算符重载函数中按8位单位进行运算，实现高精度数的快速运算。

### 最优关键思路或技巧
1. **利用递推关系**：在计算阶乘时，利用\(n!=n\times(n - 1)!\)的递推关系，避免重复计算，减少时间复杂度。
2. **压位操作**：如Bean233的题解，将多位数字压缩存储为一个单位，减少数组长度，提高运算效率。
3. **记忆化搜索**：HohleFeuerwerke的题解采用记忆化搜索，记录已经计算出的阶乘结果，避免重复计算，优化计算过程。

### 可拓展之处
同类型题通常围绕高精度运算展开，例如计算大整数的幂、大整数的四则运算等。类似算法套路包括熟练掌握高精度加法、乘法的实现，以及根据具体题目特点优化算法，如利用数学公式变形减少运算次数。

### 相似知识点洛谷题目
1. **P1601 A+B Problem（高精版）**：考察高精度加法的基本实现。
2. **P2142 高精度减法**：专注于高精度减法运算的练习。
3. **P1067 多项式输出**：除了高精度运算，还涉及多项式的表示和输出，综合性较强。

### 个人心得摘录与总结
1. **作者：C_Z_C**：强调了代码细节的重要性，如高精加时进位的正确处理，因一处进位写法错误导致WA了一个点，提醒在高精度运算中对细节的把控至关重要。
2. **作者：永遠の愛**：分享了调试高精度代码的痛苦过程，由于数据较大，运算中出现符号等异常情况，通过将符号转成数字解决问题，表明在处理高精度问题时要充分考虑各种可能出现的异常情况。 

---
处理用时：77.28秒
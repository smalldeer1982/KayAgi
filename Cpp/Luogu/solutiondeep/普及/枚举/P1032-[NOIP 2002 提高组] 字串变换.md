# 题目信息

# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# AI分析结果

这道题要求利用给定的字符串变换规则，判断能否在10步内将字符串A变换为字符串B，并输出最少变换步数。众多题解主要围绕广度优先搜索（BFS）、迭代加深搜索（IDS）展开，部分使用双向BFS优化。以下是对各题解的综合分析：
1. **思路与算法要点**：
    - **BFS**：以初始字符串A为起点，利用给定规则生成新字符串并放入队列，同时记录步数，直至找到目标字符串B或步数超过10步。过程中需判重以避免重复搜索。
    - **双向BFS**：从初始字符串A和目标字符串B同时进行BFS，当两边搜索相遇时，说明找到了变换路径，可减少搜索空间和时间。
    - **迭代加深搜索（IDS）**：设定搜索深度限制，逐步增加深度进行DFS，结合剪枝策略避免无效搜索。
2. **解决难点**：
    - **判重**：由于字符串数量庞大，使用map、set或哈希表记录已搜索过的字符串，防止重复搜索导致超时。
    - **字符串匹配与替换**：采用string的find、replace等函数，或手动实现字符串匹配和替换逻辑，找到可变换的子串并进行替换。
    - **输入处理**：部分题解需处理不确定数量的变换规则输入，可通过while循环结合文件输入或特定结束标志实现。
3. **题解评分**：
    - **coyangjr**：思路清晰，结合BFS和KMP算法，详细介绍了KMP实现及string函数用法。代码注释详尽，对新手友好。**5星**
    - **ShawnZhou**：简洁阐述BFS思路，代码结构清晰，利用map判重。但优化和细节讲解略少。**4星**
    - **BrandonSoong**：详细解释双向BFS原理，通过图文并茂的方式说明优势，代码实现规范。**4星**
4. **最优关键思路与技巧**：
    - **数据结构**：使用map、set等数据结构判重，有效减少搜索空间；用queue实现BFS，维护搜索状态。
    - **算法优化**：双向BFS从两端同时搜索，降低时间复杂度；迭代加深搜索结合剪枝策略，避免无效搜索。
    - **代码实现技巧**：熟练运用string的各种函数进行字符串操作，如find、replace、substr等，简化代码实现。
5. **拓展思路**：此类题目属于字符串变换与搜索问题，相似套路包括在搜索过程中合理使用数据结构判重、根据题目特点选择合适搜索算法（BFS、DFS、双向BFS等）。类似题目有求最短路径、状态转移等。
6. **相似知识点题目**：
    - **P1379 八数码难题**：通过BFS搜索八数码的状态空间，找到从初始状态到目标状态的最短路径。
    - **P1135 奇怪的电梯**：利用BFS解决在电梯移动规则下，到达目标楼层的最少步数问题。
    - **P1443 马的遍历**：运用BFS计算马在棋盘上从起点到各点的最短步数。
7. **个人心得摘录**：
    - **coyangjr**：考试时忘记find和replace函数，使用KMP算法解决字符串匹配问题，强调了对算法和函数的灵活运用。
    - **ShawnZhou**：注意到ans等于0时也应视为无解，避免因判断条件不当导致错误。
    - **Time_Rune**：普通DFS会超时，通过迭代加深搜索并结合剪枝策略成功AC，体会到不同搜索算法的特点和适用场景。

### 5星题解
- **作者**：coyangjr
- **星级**：5星
- **关键亮点**：结合BFS与KMP算法，详细介绍KMP实现细节与string函数用法，代码注释详尽。
- **个人心得**：考试时遗忘find和replace函数，选择KMP算法解决问题，凸显灵活运用知识的重要性。
```cpp
// 计算KMP算法的next数组
il void get_next(int x) {
    re int i, j = 0;
    for (i = 2; i < diff[x].length(); i++) {
        while (j && diff[x][i]!= diff[x][j + 1]) j = nxt[x][j];
        if (diff[x][j + 1] == diff[x][i]) j++;
        nxt[x][i] = j;
    }
}
// KMP字符串匹配并修改字符串
il void KMP(string a, int x, int step) {
    string z = a;
    a = " " + a;
    re int i, j = 0;
    for (i = 1; i < a.length(); i++) {
        while (j > 0 && diff[x][j + 1]!= a[i]) j = nxt[x][j];
        if (diff[x][j + 1] == a[i]) j++;
        if (j == diff[x].length() - 1) {
            re int t = i - diff[x].length() + 1;
            string tmp = z.substr(0, t) + change[x] + z.substr(t + diff[x].length() - 1);
            q.push(Node(tmp, step + 1));
            j = nxt[x][j];
        }
    }
    return;
}
int main() {
    cin >> a >> b;
    string t1, t2;
    while (cin >> t1 >> t2) {
        change[++cn] = t2;
        diff[cn] = " " + t1;
        get_next(cn);
    }
    q.push(Node(a, 0));
    while (!q.empty()) {
        Node now = q.front();
        q.pop();
        string x = now.data;
        if (mp[x]) continue;
        mp[x] = 1;
        if (now.step > 10) {
            puts("NO ANSWER!");
            exit(0);
        }
        if (x == b) {
            cout << now.step << endl;
            exit(0);
        }
        for (re int i = 1; i <= cn; i++) {
            KMP(x, i, now.step);
        }
    }
    puts("NO ANSWER!");
    exit(0);
}
```
核心实现思想：通过KMP算法在字符串中高效查找可替换子串，利用BFS遍历所有可能的字符串变换，使用map判重，最终找到从初始字符串到目标字符串的最少变换步数。

### 4星题解
- **作者**：ShawnZhou
- **星级**：4星
- **关键亮点**：简洁阐述BFS思路，代码结构清晰，利用map判重。
```cpp
string trans(const string &str, int i, int j) {
    string ans = "";
    if (i + orginal[j].length() > str.length())
        return ans;
    for (int k = 0; k < orginal[j].length(); k++)
        if (str[i + k]!= orginal[j][k])
            return ans;
    ans = str.substr(0, i);
    ans += translated[j];
    ans += str.substr(i + orginal[j].length());
    return ans;
}
void bfs() {
    queue <node> q;
    node s;
    s.str = a;
    s.step = 0;
    q.push(s);
    while (!q.empty()) {
        node u = q.front();
        q.pop();
        string temp;
        if (ma.count(u.str) == 1)
            continue;
        if (u.str == b) {
            ans = u.step;
            break;
        }
        ma[u.str] = 1;
        for (int i = 0; i < u.str.length(); i++)
            for (int j = 0; j < n; j++) {
                temp = trans(u.str, i, j);
                if (temp!= "") {
                    node v;
                    v.str = temp;
                    v.step = u.step + 1;
                    q.push(v);
                }
            }
    }
    if (ans > 10 || ans == 0)
        cout << "NO ANSWER!" << endl;
    else
        cout << ans << endl;
}
```
核心实现思想：定义trans函数实现字符串替换，BFS过程中对当前字符串的每个位置尝试所有变换规则，用map判重，找到最短变换步数或判断无解。

- **作者**：BrandonSoong
- **星级**：4星
- **关键亮点**：详细解释双向BFS原理，图文并茂说明优势，代码实现规范。
```cpp
inline int bfs() {
    int step = 0;
    A_.push(s);
    A[s] = 0;
    B_.push(t);
    B[t] = 0;
    string s, s2;
    while (++step <= 5) {
        while (A[A_.front()] == step - 1) {
            s = A_.front();
            A_.pop();
            for (int i = 1; i <= n; i++) {
                unsigned int pos = 0;
                while (pos < s.length()) {
                    if (s.find(a[i], pos) == s.npos) break;
                    s2 = s;
                    s2.replace(s2.find(a[i], pos), a[i].length(), b[i]);
                    if (A.find(s2)!= A.end()) {
                        pos++;
                        continue;
                    }
                    if (B.find(s2)!= B.end()) return step * 2 - 1;
                    A_.push(s2);
                    A[s2] = step;
                    pos++;
                }
            }
        }
        while (B[B_.front()] == step - 1) {
            s = B_.front();
            B_.pop();
            for (int i = 1; i <= n; i++) {
                unsigned int pos = 0;
                while (pos < s.length()) {
                    if (s.find(b[i], pos) == s.npos) break;
                    s2 = s;
                    s2.replace(s2.find(b[i], pos), b[i].length(), a[i]);
                    if (B.find(s2)!= B.end()) {
                        pos++;
                        continue;
                    }
                    if (A.find(s2)!= A.end()) return step * 2;
                    B_.push(s2);
                    B[s2] = step;
                    pos++;
                }
            }
        }
    }
    return -1;
}
```
核心实现思想：从初始字符串和目标字符串同时进行BFS，通过map记录搜索过的字符串及层数，当两边搜索到相同字符串时，根据搜索方向计算并返回最少变换步数。 

---
处理用时：78.23秒
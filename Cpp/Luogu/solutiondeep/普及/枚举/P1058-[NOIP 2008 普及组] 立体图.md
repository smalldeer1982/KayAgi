# 题目信息

# [NOIP 2008 普及组] 立体图

## 题目描述

小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解立体图，请你帮他画出立体图。

小渊有一块面积为 $m \times n$ 的矩形区域，上面有 $m \times n$ 个边长为 $1$ 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$），小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放：

$$
\def\arraystretch{1e-10}
\begin{aligned}
&\verb!  +---+!\\
&\verb! /   /|!\\
&\verb!+---+ |!\quad\textsf{高}\\
&\verb!|   | +!\\
&\verb!|   |/ !\quad\textsf{宽}\\
&\verb!+---+  !\\
& \quad\textsf{长}
\end{aligned}$$


每个顶点用 $1$ 个加号 `+` 表示，长用 $3$ 个 `-` 表示，宽用 $1$ 个 `/`，高用两个 `|` 表示。字符 `+`，`-`，`/`，`|` 的 ASCII 码分别为 $43$，$45$，$47$，$124$。字符 `.`（ASCII 码 $46$）需要作为背景输出，即立体图里的空白部分需要用 `.` 来代替。立体图的画法如下面的规则：

若两块积木左右相邻，图示为：


$$
\def\arraystretch{1e-10}
\begin{aligned}
\verb!..+---+---+!\\
\verb!./   /   /|!\\
\verb!+---+---+ |!\\
\verb!|   |   | +!\\
\verb!|   |   |/.!\\
\verb!+---+---+..!\\
\end{aligned}
$$

若两块积木上下相邻，图示为：


$$
\def\arraystretch{1e-10}
\begin{aligned}
\verb!..+---+!\\
\verb!./   /|!\\
\verb!+---+ |!\\
\verb!|   | +!\\
\verb!|   |/|!\\
\verb!+---+ |!\\
\verb!|   | +!\\
\verb!|   |/.!\\
\verb!+---+..!\\
\end{aligned}
$$

若两块积木前后相邻，图示为：

$$
\def\arraystretch{1e-10}
\begin{aligned}
\verb!....+---+!\\
\verb!.../   /|!\\
\verb!..+---+ |!\\
\verb!./   /| +!\\
\verb!+---+ |/.!\\
\verb!|   | +..!\\
\verb!|   |/...!\\
\verb!+---+....!\\
\end{aligned}
$$

立体图中，定义位于第 $(m,1)$ 的格子（即第 $m$ 行第 $1$ 列的格子）上面自底向上的第一块积木（即最下面的一块积木）的左下角顶点为整张图最左下角的点。


## 说明/提示

NOIP2008普及组第四题


## 样例 #1

### 输入

```
3 4
2 2 1 2
2 2 1 1
3 2 1 2
```

### 输出

```
......+---+---+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......```

# AI分析结果

• 综合分析：这些题解的核心思路均是通过模拟积木的摆放来生成立体图。算法要点在于确定积木在二维数组中的放置顺序和位置坐标，以及如何将单个积木的图形绘制到整体图形中。解决难点主要集中在坐标计算和图形覆盖逻辑上，不同题解在处理这些问题时各有差异。

  - **思路**：多数题解选择从后往前、从左往右、从下往上的顺序放置积木，这样能自然处理积木间的覆盖关系。如作者ZUTTER_、HasNoName等都采用此思路。
  - **算法要点**：利用二维数组存储立体图，通过计算每个积木的左下角或左上角坐标，将积木图形填充到对应位置。部分题解通过打表存储单个积木图形，如作者ZUTTER_、skx_515等；部分题解直接在代码中绘制积木图形，如作者Sino_E。
  - **解决难点**：坐标计算是关键，不同题解推导公式不同。如作者cwxcplh通过分析相邻积木位置变化得出坐标公式，但需多次调整；作者Sino_E通过建立平面直角坐标系，根据坐标规律确定积木位置。

  综合质量来看，以下为评分较高的题解：
  - **作者ZUTTER_（5星）**
    - **关键亮点**：思路清晰，先明确将图形存于数组，再按特定顺序覆盖的总体思路。通过打表存储单个积木图形，方便调用。代码简洁明了，变量命名有一定意义，可读性强。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
void fg(int x,int y)
{
    int i,j;
    for(i=5;i>=0;i--)//立方体需要倒过来存入数组
        for(j=z[i];j<=s[i];j++)//分别是这一行的宽度
        {
            c[5-i+x][j+y]=c1[i][j];
            if(5-i+x>maxx) maxx=5-i+x;
            if(j+y>maxy) maxy=j+y;//分别记录最大长宽
        }
}

int main()
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
        for(j=0;j<m;j++)
            scanf("%d",&a[i][j]);
    for(o=1;o<=n;o++)//层数
        for(k=0;k<m;k++)//列循环
            for(l=0;l<a[o][k];l++)//高度
                fg((n-o)*2+1+3*l,(n-o)*2+1+4*k);//表示立方体左下角位置

    for(i=maxx;i>=1;i--)
    {    
        for(j=1;j<=maxy;j++)
            if(c[i][j]=='\000') printf(".");
            else printf("%c",c[i][j]);
        printf("\n");
    }
}
```
核心实现思想：`fg`函数负责将单个积木图形填充到二维数组`c`中，通过循环控制积木图形的每一行每一列。`main`函数中，三层循环遍历每个积木的位置和高度，调用`fg`函数填充。最后按行输出二维数组`c`，空白处输出`.`。
  - **作者Sino_E（4星）**
    - **关键亮点**：通过建立平面直角坐标系理解和处理坐标转换，思路直观。详细分析每个积木的坐标规律，给出明确的坐标计算公式。代码结构清晰，不同功能封装成函数。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
void mdraw(int x,int y){
    /*正面矩阵绘制*/
    mz[x][y+3]=mz[x][y]=mz[x+4][y]=mz[x+4][y+3]='+';
    for(int i=x+1;i<x+4;i++)
        mz[i][y]=mz[i][y+3]='-';
    for(int i=y+1;i<y+3;i++)
        mz[x][i]=mz[x+4][i]='|';
    for(int i=x+1;i<x+4;i++)
        for(int j=y+1;j<y+3;j++)
            mz[i][j]=' ';
    /*顶面矩阵绘制*/
    mz[x+1][y+4]=mz[x+5][y+4]='/';
    mz[x+2][y+5]=mz[x+6][y+5]='+';
    for(int i=x+2;i<=x+4;i++)
        mz[i][y+4]=' ';
    for(int i=x+3;i<=x+5;i++)
        mz[i][y+5]='-';
    /*侧面矩阵绘制*/
    mz[x+5][y+1]='/';
    mz[x+6][y+2]='+';
    mz[x+5][y+2]=mz[x+5][y+3]=' ';
    mz[x+6][y+3]=mz[x+6][y+4]='|';
}

void putout(int x,int y){
    for(int j=y;j>=0;j--){
        for(int i=0;i<=x;i++)
            if(!mz[i][j])putchar('.');
            else putchar(mz[i][j]);
        putchar('\n');
    }//按照平面直角坐标系顺序进行输出 
}

int main(){
    int mx=0,my=0;
    int m,n;
    scanf("%d%d",&m,&n);
    for(int y=m-1;y>=0;y--)
        for(int x=0;x<n;x++)
            scanf("%d",&Z[x][y]); //注意输入 
    for(int y=m-1;y>=0;y--)
        for(int x=0;x<n;x++)
            for(int z=0;z<=Z[x][y]-1;z++){
                mx=max(mx,2*y+4*x+6);
                my=max(my,2*y+3*z+5);
                mdraw(2*y+4*x,2*y+3*z);
            } //注意绘制顺序 
    putout(mx,my); //输出 
    return 0;
}
```
核心实现思想：`mdraw`函数负责绘制单个积木的三个面，通过坐标计算确定每个字符的位置。`main`函数中，通过三层循环遍历每个积木的位置和高度，调用`mdraw`函数绘制，并更新立体图的最大坐标。最后`putout`函数按平面直角坐标系顺序输出立体图，空白处输出`.`。
  - **作者HasNoName（4星）**
    - **关键亮点**：从后往前建方块的思路清晰，通过画图软件辅助理解，形象直观。代码中对数组存储位置的处理巧妙，先在数组中间预留足够空间，再在作图过程中更新打印时图的大小。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
void print(int x,int y,int h)//每个二维中同样位置从下往上堆方块
{
	x-=5;
	for(int k=1;k<=h;k++)
	{
		for(int i=0;i<6;i++)
			for(int j=0;j<7;j++)
				if(cube[i][j]!='.')
					a[x+i][y+j]=cube[i][j];
		x-=3;//打印方块起始位置移动
	}
	u=min(u,x+3);//更新上界
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>num[i][j];
	int x=3000,y=1000;
	for(int i=1;i<=n;i++)
	{
		int y_=y;
		for(int j=1;j<=m;j++)//从左到右打印
		{
			print(x,y_,num[i][j]);
			y_+=4;
		}
		r=max(r,y_+2);//右界
		x+=2;
		y-=2;
	}
	d=x-2;//下界
	l=y+2;//左界
	for(int i=u;i<=d;i++)
	{
		for(int j=l;j<=r;j++)
		{
			if(!a[i][j])cout<<".";
			else cout<<a[i][j];
		}
		cout<<'\n';
	}
	return 0;
}
```
核心实现思想：`print`函数负责在指定位置从下往上堆叠积木，通过循环将单个积木图形`cube`填充到二维数组`a`中，并更新上界。`main`函数中，通过两层循环遍历每个积木的位置，调用`print`函数堆叠积木，并更新立体图的上下左右边界。最后按边界输出二维数组`a`，空白处输出`.`。

• 最优关键思路或技巧：从后往前、从左往右、从下往上放置积木的顺序，能有效处理积木间的覆盖关系，简化逻辑。利用打表存储单个积木图形，或直接按规律绘制积木图形，结合合理的坐标计算，是实现的关键技巧。

• 可拓展思路：此类题目属于图形模拟范畴，类似套路可用于其他立体图形或复杂二维图形的绘制，关键在于分析图形元素间的位置关系和覆盖规则，合理设计数据结构与算法。

• 相似知识点洛谷题目：
  - P1064 [NOIP2006 普及组] 金明的预算方案，涉及二维数组存储数据及按条件模拟计算。
  - P1090 [NOIP2004 提高组] 合并果子，通过模拟操作实现最优解，与本题模拟思路类似。
  - P1162 填涂颜色，通过二维数组模拟图形填充，与本题处理二维图形有相似之处。

• 个人心得摘录与总结：作者cwxcplh详细记录了调试过程，从最初坐标公式错误导致图形部分字符被遮挡、方块悬空，到添加“重力常数”修正坐标，再到去除图形上方多余空白部分，逐步完善代码。总结得出在处理复杂坐标计算时，不仅要考虑单个元素自身位置，还需兼顾与其他元素的关系，全面测试各种情况以确保正确性。 

---
处理用时：51.11秒
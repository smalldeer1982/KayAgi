# 题目信息

# 环状最大两段子段和

## 题目描述

给出一段长度为 $n$ 的环状序列 $a$，即认为 $a_1$ 和 $a_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
9```

# AI分析结果

### 综合分析与结论
这些题解主要围绕环状最大两段子段和问题展开，思路核心是分类讨论和动态规划。多数题解将情况分为两段都不跨过端点与有一段跨过端点两种。算法要点在于利用动态规划计算最大子段和、最小子段和，通过预处理前后缀最大/最小子段和来优化计算。解决难点在于处理跨过端点的情况，部分题解通过取反数组转化为求最小子段和问题，同时要注意处理特殊情况，如全负数或只有一个正数的情况。

### 所选的题解
- **作者：Develop（5星）**
  - **关键亮点**：全面梳理了最大子段和及其多种变式的解法，从暴力到优化，思路清晰，对各问题的分析透彻，为理解该类问题提供了系统的知识体系。
  - **个人心得**：无
  - **重点代码**：无特定代码，主要是对各种算法思路的文字阐述。
- **作者：zhy137036（4星）**
  - **关键亮点**：先从最大子段和、环状最大子段和、最大双子段和逐步引入到环状最大双子段和，逻辑连贯。对每个子问题都给出详细的状态转移方程和代码实现，易于理解。
  - **个人心得**：无
  - **重点代码**：环状最大双子段和代码核心实现：
```cpp
int getmin(int*arr, int l){
    mf[1]=arr[1];
    for(int i=2;i<=l;i++)mf[i]=min(mf[i-1]+arr[i], min(arr[i], 0));
    for(int i=2;i<=l;i++)mf[i]=min(mf[i-1], mf[i]);
    mb[l]=arr[l];
    for(int i=l-1;i>0;i--)mb[i]=min(mb[i+1]+arr[i], min(arr[i], 0));
    for(int i=l-1;i>0;i--)mb[i]=min(mb[i+1], mb[i]);
    int ans=(1ll<<31ll)-1ll;
    for(int i=2;i<l;i++)ans=min(ans,mf[i-1]+mb[i+1]);
    return ans;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",a+i);
        sum+=a[i];
    }
    af[1]=a[1];
    for(int i=2;i<=n;i++)af[i]=max(af[i-1],0)+a[i];
    for(int i=2;i<=n;i++)af[i]=max(af[i-1],af[i]);
    ab[n]=a[n];
    for(int i=n-1;i>0;i--)ab[i]=max(ab[i+1],0)+a[i];
    for(int i=n-1;i>0;i--)ab[i]=max(ab[i+1],ab[i]);
    int ans=1ll<<31ll;
    for(int i=1;i<n;i++)ans=max(ans,af[i]+ab[i+1]);
    ans=max(ans,sum-getmin(a,n-1));
    ans=max(ans,sum-getmin(a+1,n-1));
    printf("%d\n",ans);
    return 0;
}
```
核心思想：通过`getmin`函数计算最小子段和，在`main`函数中分别计算不跨过端点和跨过端点两种情况下的最大两段子段和，取最大值为最终答案。
- **作者：Morning_Glory（4星）**
  - **关键亮点**：采用贪心思路，结合单调队列优化。通过分析最大子段和与所求两段最大子段和的关系，将问题转化为求长度小于等于\(n\)的最大子段和以及相关的子问题，思路新颖且高效。
  - **个人心得**：无
  - **重点代码**：
```cpp
ll _find (ll l, ll r, int &lt, int &rt)
{
    deque< pair<ll, ll> > q;
    ll sum = 0, mx = -97865432112345678, res;
    q.push_front(mp(l - 1, 0));
    for (int i = l; i <= r; ++i){
        sum += a[i];
        while (!q.empty() && i - q.front().first > n)	q.pop_front();
        if (!q.empty()){
            res = sum - q.front().second;
            if (res > mx){	lt = q.front().first + 1, rt = i, mx = res;}
        }
        while (!q.empty() && sum <= q.back().second)	q.pop_back();
        q.push_back(mp(i, sum));
    }
    return mx;
}
int main()
{
    cin>>n;
    for (int i = 1; i <= n; ++i)	cin>>a[i], a[i + n] = a[i];
    ans = _find(1, 2 * n, l1, r1);
    if (ans < 0){
        sort(a + 1, a + n + 1);
        printf("%lld\n", a[n] + a[n - 1]);
        return 0;
    }
    t1 = _find(r1 + 1, l1 + n - 1, l2, r2);
    for (int i = l1; i <= r1; ++i)	a[i] = -a[i];
    t2 = _find(l1, r1, t, tt);
    ans = max(0ll, max(t1, t2)) + ans;
    printf("%lld\n", ans);
    return 0;
}
```
核心思想：`_find`函数利用单调队列求区间最大子段和，在`main`函数中先求全局最大子段和，再根据贪心思路分别求右边最大子段和与中间最小子段和，综合得出答案。

### 最优关键思路或技巧
- **分类讨论**：将环状最大两段子段和问题分为两段都不跨过端点和有一段跨过端点两种情况，分别求解再取最大值。
- **动态规划**：通过动态规划计算以每个位置结尾的最大/最小子段和，再通过预处理得到前后缀最大/最小子段和，从而优化计算。
- **转化思想**：将求跨过端点的最大两段子段和转化为求最小两段子段和，通过取反数组，利用已有的最大子段和计算方法求解。

### 可拓展思路
同类型题可考虑增加子段数量限制、子段长度限制等条件。类似算法套路可应用于其他环状序列问题，如环状最大子段和、环状最小子段和等，通过分类讨论和动态规划解决。

### 相似知识点题目
- **P1115 最大子段和**：基础的最大子段和问题，为解决环状最大两段子段和提供基础思路。
- **P2642 最大双子段和**：非环状的最大双子段和问题，与环状问题有相似的处理方法。
- **P4513 小白逛公园**：涉及序列带修改操作的最大子段和问题，可拓展线段树等数据结构的应用。

### 个人心得摘录与总结
无明显个人心得相关内容。 

---
处理用时：41.17秒
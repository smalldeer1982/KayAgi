# 题目信息

# 取数游戏

## 题目描述

一个 $N\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。

## 说明/提示

### 样例解释

对于第一组数据，取数方式如下：

$$\begin{matrix}
[67] & 75 & 63 & 10 \\
29 & 29 & [92] & 14 \\
[21] & 68 & 71 & 56 \\
8 & 67 & [91] & 25 \\
\end{matrix}$$


### 数据范围及约定

- 对于$20\%$的数据，$1\le N, M \le 3$；
- 对于$40\%$的数据，$1\le N, M\le 4$；
- 对于$60\%$的数据，$1\le N, M\le 5$；
- 对于$100\%$的数据，$1\le N, M\le 6$，$1\le T\le 20$。


## 样例 #1

### 输入

```
3
4 4
67 75 63 10
29 29 92 14
21 68 71 56
8 67 91 25
2 3
87 70 85
10 3 17
3 3
1 1 1
1 99 1
1 1 1

```

### 输出

```
271
172
99
```

# AI分析结果

### 综合分析与结论
这些题解主要使用深度优先搜索（DFS）和状态压缩动态规划（状压DP）两种算法。DFS思路直观，通过递归枚举每个数字取或不取，同时标记周围数字避免相邻选取，难点在于如何合理剪枝优化。状压DP则利用二进制表示每行状态，通过预处理合法状态简化判断，状态转移方程计算最大和，难点在于状态设计与转移方程推导。

### 所选的题解
- **作者：绿萧 (赞：199)  星级：4星**
    - **关键亮点**：思路清晰，先排除贪心和普通动态规划，根据数据范围确定DFS算法，详细阐述每个数的状态及标记方式，代码简洁明了。
    - **核心代码片段**：
```cpp
void dfs(int x,int y){//搜索函数，表示搜索点(x,y) 
    if(y==m+1){//当y到边界时，搜索下一行 
        dfs(x+1,1);
        return;
    }
    if(x==n+1){//当x到边界时，搜索结束，刷新最大值 
        mx=max(ans,mx);
        return;
    }
    
    dfs(x,y+1);// 不取此数的情况 
    
    if(mark[x][y]==0){ //取此数的情况（需保证此数周围没有取其他数，即mark[i][j]==0）
        ans+=s[x][y];
        for(int fx=0;fx<8;++fx){ //标记周围的数 
            ++mark[x+d[fx][0]][y+d[fx][1]];
        }
        dfs(x,y+1);
        for(int fx=0;fx<8;++fx){ //回溯 
            --mark[x+d[fx][0]][y+d[fx][1]];
        }
        ans-=s[x][y];
    }
    
}
```
    - **核心实现思想**：`dfs`函数递归搜索每个点，`y`到边界则搜索下一行，`x`到边界则更新最大值。对于当前点，先考虑不取的情况，若该点周围无已取数（`mark[x][y]==0`），则取该数并标记周围数，递归搜索后回溯。
- **作者：zhi_zhang (赞：37)  星级：4星**
    - **关键亮点**：详细展示了DFS剪枝优化过程，从最初暴力搜索逐步分析并实现剪枝，每次优化都有说明及代码展示，便于理解剪枝思路。
    - **核心代码片段（最终优化后）**：
```cpp
void Dfs(int X,int x,int y)
{
    bool poi_rem=false;
    for(int i=y+1;i<=M;i++)//先搜完当前行
    {
        if(!vis[i][j])
        {
            poi_rem=true;
            Vis(x,i);
            Dfs(X+sq[x][i],x,i);
            D_vis(x,i);
        }
    }
    for(int i=x+1;i<=N;i++)
    {
        for(int j=1;j<=M;j++)
        {
            if(!vis[i][j])
            {
                poi_rem=true;
                Vis(i,j);
                Dfs(X+sq[i][j],i,j);
                D_vis(i,j);
            }
        }
    }
    if(!poi_rem&&ans<X)
    {
        ans=X;
    }
}
```
    - **核心实现思想**：从当前点所在行的下一列开始搜索本行，再搜索后续行。若找到未访问点，标记并递归搜索，回溯后继续找下一个可访问点。搜索完所有点后，若当前和大于记录的答案则更新。
- **作者：IntrepidStrayer (赞：23)  星级：4星**
    - **关键亮点**：采用状压DP，思路独特。详细阐述状态设计、预处理合法状态及状态转移方程，逻辑严谨，时间复杂度分析清晰。
    - **核心代码片段**：
```cpp
bool check1(int x){
    for(;x;x>>=1)if((x&3)==3)return false;
    return true;
}
bool check2(int x,int y){
    return!(x&(y<<1))&&!(x&y)&&!(x&(y>>1));
}
int calc(int i,int x){
    int res=0;
    for(rei j=m;j>=1&&x;--j,x>>=1)if(x&1)res+=a[i][j];
    return res;
}
//...
for(rei i=1;i<=n;++i)
    for(rei j=1;j<=cnt;++j){
        v=0;
        for(rei k=1;k<=cnt;++k)
            if(check2(c[j],c[k]))
                v=max(v,f[i-1][k]);
        f[i][j]=calc(i,c[j])+v;
    }
```
    - **核心实现思想**：`check1`检查单个状态是否合法（无横向相邻1），`check2`检查相邻两行状态是否合法。`calc`计算当前行按某状态取数的和。通过两重循环遍历行和合法状态，根据状态转移方程更新`f`数组。

### 最优关键思路或技巧
- **DFS剪枝**：如zhi_zhang的题解，通过减少不必要的搜索范围，如只搜索当前点所在行及以下的点，标记时减少对已确定不会再搜索区域的操作，从而优化搜索效率。
- **状压DP预处理**：IntrepidStrayer等题解中，预处理出所有符合条件的决策状态，减少每次判断状态合法性的时间开销，简化状态转移过程。

### 可拓展思路
此类问题属于网格上的选择优化问题，类似套路有：
 - 对于小数据范围，DFS是直观方法，可通过剪枝优化。
 - 当问题具有明显阶段和状态依赖，且状态能用二进制有效表示时，状压DP是有效手段，可通过预处理合法状态优化。

### 相似知识点洛谷题目
 - [P1896 互不侵犯](https://www.luogu.com.cn/problem/P1896)：在棋盘上放置国王，使其互不攻击，与本题类似需考虑相邻位置限制，可使用状压DP。
 - [P3146 [USACO16OPEN]248 G](https://www.luogu.com.cn/problem/P3146)：合并数字问题，通过状态压缩记录数字状态，用DP求解，与本题状压DP思路类似。
 - [P2704 [NOI2001] 炮兵阵地](https://www.luogu.com.cn/problem/P2704)：在地图上放置炮兵，考虑不相邻限制，同样可采用状压DP解决。

### 个人心得摘录与总结
 - **zhi_zhang**：详细记录了DFS优化过程，每次剪枝后对代码修改及效果有清晰说明，总结出通过减少搜索范围和标记范围来优化DFS的经验。
 - **lytqwq**：发现`endl`刷新输入导致运行慢，应使用`'\n'`代替。同时通过新增剪枝判断当前值与之前最大值关系，避免不必要搜索。 

---
处理用时：40.49秒
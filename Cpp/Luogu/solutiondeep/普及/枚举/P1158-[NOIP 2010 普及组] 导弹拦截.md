# 题目信息

# [NOIP 2010 普及组] 导弹拦截

## 题目描述

经过 $11$ 年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 $0$ 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。

某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。

## 说明/提示

两个点 $(x_1,y_1),(x_2,y_2)$ 之间距离的平方是 $(x_1-x_2)^2+(y_1-y_2)^2$。

两套系统工作半径 $r_1,r_2$ 的平方和，是指 $r_1,r_2$ 分别取平方后再求和，即 $r_1^2+r_2^2$。

### 样例 1 说明

样例 $1$ 中要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $18$ 和 $0$。

### 样例 2 说明

样例 $2$ 中的导弹拦截系统和导弹所在的位置如下图所示。要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $20$ 和 $10$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cvgomt03.png)

【数据范围】。

- 对于 $10\%$ 的数据，$N=1$。
- 对于 $20\%$ 的数据，$1\le N\le 2$。
- 对于 $40\%$ 的数据，$1\le N\le 100$。
- 对于 $70\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 10^5$，且所有坐标分量的绝对值都不超过 $1000$。

NOIP2010 普及组 第三题

## 样例 #1

### 输入

```
0 0 10 0
2
-3 3
10 0```

### 输出

```
18```

## 样例 #2

### 输入

```
0 0 6 0
5
-4 -2
-2 3
4 0
6 -2
9 1```

### 输出

```
30```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是基于贪心策略，通过对导弹到两个拦截系统的距离进行排序，枚举不同的拦截分配方案，从而找到最小的半径平方和。主要算法要点为计算导弹到两系统的距离并排序，难点在于如何合理地划分导弹被两个系统拦截的情况以得到最优解。

### 所选的题解
1. **作者：TEoS (5星)**
    - **关键亮点**：思路清晰，以蒟蒻角度详细阐述，代码简单易懂，直接按距离平方排序并预处理，枚举答案。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int x11,y11,x22,y22,n,minn=4000010;
struct DI
{
    int d1,d2,i;
}di[1000010];
bool cmp(DI a,DI b)
{
    return a.d1<b.d1;
}
int main()
{
    cin>>x11>>y11>>x22>>y22>>n;
    int x[n+5],y[n+5];
    memset(di,0,sizeof(di));
    for(int i=1;i<=n;i++)
    {
        cin>>x[i]>>y[i];
        di[i].d1=pow(x[i]-x11,2)+pow(y[i]-y11,2);
        di[i].i=i;
    }
    sort(di+1,di+n+1,cmp);
    for(int i=n;i>0;i--)
    {
        int a;
        a=pow(x[di[i].i]-x22,2)+pow(y[di[i].i]-y22,2);
        di[i].d2=max(a,di[i+1].d2);
    }
    for(int i=0;i<=n;i++)
    {
        int a;
        a=di[i].d1+di[i+1].d2;
        minn=min(a,minn);
    }
    cout<<minn;
    return 0;
}
```
    - **核心实现思想**：先计算每个导弹到1号系统的距离平方并排序，再预处理出每个导弹作为1号系统拦截最远导弹时，2号系统需拦截的导弹中距离2号系统最远的距离平方，最后枚举1号系统拦截的最远导弹，计算并取最小的半径平方和。
2. **作者：暗ざ之殇 (4星)**
    - **关键亮点**：思路讲解详细，结合图示，代码通过预处理和枚举，逻辑清晰。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int read()
{
    char ch=getchar();
    int a=0,x=1;
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') x=-x;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        a=(a<<3)+(a<<1)+(ch-'0');
        ch=getchar();
    }
    return a*x;
}
int x1,y11,x2,y2,n,x,y,minx;
int dis2[100001],nxt[100001];
struct dis
{
    int dis1;
    int id;
}a[100001];
int cmp1(dis x,dis y)
{
    return x.dis1<y.dis1;
}
int main()
{
    x1=read();y11=read();
    x2=read();y2=read();
    n=read();
    for(int i=1;i<=n;i++)
    {
        x=read();y=read();
        a[i].dis1=(x-x1)*(x-x1)+(y-y11)*(y-y11);
        a[i].id=i;
        dis2[i]=(x-x2)*(x-x2)+(y-y2)*(y-y2);
    }
    sort(a+1,a+1+n,cmp1);
    minx=a[n].dis1;
    nxt[n]=dis2[a[n].id];
    for(int i=n-1;i>=1;i--)
        if(dis2[a[i].id]>nxt[i+1]) nxt[i]=dis2[a[i].id];
        else nxt[i]=nxt[i+1];
    for(int i=n-1;i>=1;i--)
        minx=min(minx,a[i].dis1+nxt[i+1]);
    printf("%d",min(minx,nxt[1]));
    return 0;
}
```
    - **核心实现思想**：先按导弹到第一个拦截系统的距离平方从小到大排序，预处理出每个位置往后导弹到第二个拦截系统的最大距离平方（即第二个拦截系统半径），枚举第一个拦截系统拦截的导弹数量，计算并取最小的半径平方和。
3. **作者：YCW13983841648 (4星)**
    - **关键亮点**：结合解析几何概念，阐述清晰，代码简洁，考虑到精度问题直接用距离平方计算。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int num1_x,num2_x,num1_y,num2_y,r,ans=0x3f3f3f3f3f3f3f3f,n;
const int N=1e5+10;
struct Node{
    int num1,num2;
}a[N];
bool cmp(Node f,Node g){
    return f.num1>g.num1;
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>num1_x>>num1_y>>num2_x>>num2_y>>n;
    for(int i=1;i<=n;i++){
        int num1,num2;
        cin>>num1>>num2;
        a[i].num1=(num1_x-num1)*(num1_x-num1)+(num1_y-num2)*(num1_y-num2);
        a[i].num2=(num2_x-num1)*(num2_x-num1)+(num2_y-num2)*(num2_y-num2);
    }
    sort(a+1,a+n+1,cmp);
    ans=a[1].num1;
    for(int i=1;i<=n;i++){
        r=max(r,a[i].num2);
        ans=min(a[i+1].num1+r,ans);
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：将导弹抽象为点，拦截系统抽象为圆，按点到指定圆（圆一）圆心的距离平方从大到小排序，遍历过程中，让圆一处理后面的点，圆二处理前面的点，记录并更新最小的半径平方和。

### 最优关键思路或技巧
1. **排序优化枚举**：对导弹到某一系统的距离进行排序，能有效减少枚举的复杂度，使得在枚举不同拦截分配方案时更高效。
2. **预处理**：通过预处理导弹到另一系统的距离相关信息（如最大距离），在枚举过程中可以快速计算出另一系统的半径，从而快速得到不同分配方案下的总代价。
3. **避免精度问题**：由于最终答案是距离平方和，计算过程直接使用距离平方，避免开根号带来的精度问题。

### 可拓展思路
此类题目属于贪心策略在平面几何距离问题上的应用。类似套路可应用于其他资源分配且与距离相关的场景，例如多个基站覆盖区域问题，多个仓库配送范围问题等。在这些问题中，往往可以通过对距离等关键因素排序，结合贪心思想来解决。

### 相似知识点洛谷题目
1. **P1080 [NOIP2012 提高组] 国王游戏**：涉及贪心策略，通过对数据排序找到最优分配方案。
2. **P1937 [USACO10MAR]Barn Allocation G**：同样是资源分配问题，运用贪心算法解决区间分配问题。
3. **P2123 皇后游戏**：需要对数据进行合理排序，利用贪心策略得到最优解，与本题在排序结合贪心的思路上相似。

### 个人心得摘录与总结
 - **作者：NewSjf**：起初想到的贪心策略只得了60分，后通过随机打乱点的顺序重复跑贪心取最优值神奇AC。这表明有些贪心策略看似合理但可能存在漏洞，随机化算法有时可作为一种补充手段来应对复杂情况，但这并非通用的严谨解法，只是一种特殊技巧。 

---
处理用时：50.00秒
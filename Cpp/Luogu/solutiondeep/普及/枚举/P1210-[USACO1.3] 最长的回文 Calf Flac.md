# 题目信息

# [USACO1.3] 最长的回文 Calf Flac

## 题目描述

据说如果你给无限只母牛和无限台巨型便携式电脑（有非常大的键盘 ), 那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观（最棒的回文）。

在寻找回文时不用理睬那些标点符号、空格（但应该保留下来以便做为答案输出）, 只用考虑字母 ${\tt A}\sim {\tt Z}$ 和 ${\tt a}\sim {\tt z}$。要你寻找的最长的回文的文章是一个不超过 $20{,}000$ 个字符的字符串。我们将保证最长的回文不会超过 $2{,}000$ 个字符（在除去标点符号、空格之前）。

## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 1.3


## 样例 #1

### 输入

```
Confucius say: Madam, I'm Adam. ```

### 输出

```
11
Madam, I'm Adam```

# AI分析结果

这道题要求在包含标点符号和空格的字符串中，找出最长的回文子串，且输出时需保留原字符串格式。各题解思路、算法要点及难点解决如下：
1. **暴力枚举类**：以每个字符为中心向两边扩展，分奇数长度和偶数长度讨论。如作者“zqy1018”、“童年如作业”、“ShineEternal”、“_gjm2005_”、“汇文客”的题解。这类方法时间复杂度为O(n^2)，思路简单直接，但效率相对较低。
2. **二分答案类**：作者“Godのfather”通过将答案分为奇偶两种情况，利用回文子串长度的单调性进行二分答案，降低了时间复杂度，优化了枚举过程。
3. **Manacher算法类**：作者“顾z”、“ghj1222”、“hovny”、“q1293274675”采用Manacher算法，该算法能在线性时间内解决回文串问题。先对原字符串进行处理，只保留字母并转换为统一大小写，再通过特殊方式构建新字符串后应用算法。难点在于如何根据算法结果准确还原原字符串中的回文子串。
4. **后缀数组类**：作者“逆时针的记忆”和“OItby”利用后缀数组的Lcp（最长公共前缀）求出Height数组来解决问题。先将原串处理为统一大小写的字母串，再通过特殊拼接和后缀数组模板求出Height数组，从而找到最长回文子串。实现相对复杂，但效率较高。

综合来看，暴力枚举类题解思路简单但效率有限；二分答案类优化了枚举方式；Manacher算法和后缀数组类能更高效解决问题，但实现难度较大。

### 题解评分
1. **作者“Godのfather”（4星）**：
    - **关键亮点**：巧妙利用二分答案优化枚举，通过分析回文子串长度奇偶性的单调性，降低时间复杂度，代码实现清晰。
    - **核心代码**：
```cpp
bool ok(int x,int y)
{
    int rt=x,lt=y;
    while(rt<=lt)
    {
        if(st[rt].S!=st[lt].S) return false;
        rt++,lt--; 
    }
    return true;
}
bool add(int x)
{
    int head=1,tail=x;
    while(tail<=len1)
    {
        if(ok(head,tail))
        {
           begin=st[head].start;
           end=st[tail].start;
           return true;
        }
        head++,tail++;
    }
    return false;
}
// 二分奇数
while(lt+2<rt) 
{
    int mid=(lt+rt)/2;
    if(mid%2==0) mid++;
    if(add(mid)) lt=mid;
    else rt=mid;
}
// 二分偶数
while(lt+2<rt) 
{
    int mid=(lt+rt)/2;
    if(mid%2==1) mid++;
    if(add(mid)) lt=mid;
    else rt=mid;
}
```
    - **核心思想**：`ok`函数用于判断指定区间内的字符是否构成回文；`add`函数遍历字符串，检查是否存在长度为x的回文子串。通过二分法分别查找奇数长度和偶数长度的最长回文子串。
2. **作者“顾z”（4星）**：
    - **关键亮点**：使用Manacher算法解决问题，详细阐述了算法应用过程及处理原串输出的方法，通过记录字符位置成功还原原串中的回文子串。
    - **核心代码**：
```cpp
for(RI i=0;i<l;i++)
{
    if((s[i]>='a' and s[i]<='z') or (s[i]>='A' and s[i]<='Z'))
    str[len]=s[i],pos[len]=i,len++;
}
for(RI i=0;i<len;i++)
{
    if(str[i]>='a' and str[i]<='z')
        str[i]-=32;
}
for(RI i=0;i<len;i++)ss[2*i+1]=str[i],poss[2*i+1]=pos[i];
ll=2*len+1;
for(RI i=1;i<ll;i++)
{
    if(i<=MaxRight)
        RL[i]=std::min(RL[2*center-i],MaxRight-i);
    else RL[i]=1;
    while(i-RL[i]>=0 and i+RL[i]<ll and ss[i+RL[i]]==ss[i-RL[i]])
        RL[i]++;
    if(i+RL[i]-1>MaxRight)MaxRight=i+RL[i]-1,center=i;
    if(RL[i]-1>ans)
    {
        ans=RL[i]-1;
        le=i-RL[i]+2;
        ri=i+RL[i]-2;
    }
}
```
    - **核心思想**：先处理原串，提取字母并记录位置，转换为统一大小写。构建用于Manacher算法的数组并记录对应位置。通过Manacher算法求出每个位置的回文半径，找到最长回文子串并记录其位置，最后根据记录的位置输出原串中的回文子串。
3. **作者“OItby”（4星）**：
    - **关键亮点**：运用后缀数组的Lcp来解决问题，通过对原串进行特殊处理和拼接，利用后缀数组模板求出Height数组，从而找到最长回文子串，代码简洁明了。
    - **核心代码**：
```cpp
void Read()
{
    string str;
    for(getline(cin,ss);getline(cin,str);ss+='\n'+str);
    int len=ss.length();
    n=0;
    for(int i=0;i<len;++i)
    {
        if(ss[i]>='a'&&ss[i]<='z')
            s[n]=ss[i],id[n]=i,++n;
        if(ss[i]>='A'&&ss[i]<='Z')
            s[n]=ss[i]+'a'-'A',id[n]=i,++n;
    }
    for(int i=0;i<n;++i) s[n+n-i]=s[i];
    s[n]=2,s[n+n+1]=1;
    ln=n,n=n+n+2;
}
void Make_Sa()
{
    // 后缀数组求sa[]与rank[]的模板代码
}
void Lcp()
{
    // 后缀数组求Height[]的模板代码
}
void PutAns()
{
    int ID=0,Ans=0;
    for(int i=1;i<n;++i)
    {
        if(sa[i]<ln&&sa[i-1]>ln||sa[i]>ln&&sa[i-1]<ln)
        {
            if(height[i]>Ans||(height[i]==Ans&&sa[i]<ID))
                Ans=height[i],ID=sa[i];
        }
    }
    printf("%d\n",Ans);
    for(int i=id[ID];i<=id[ID+Ans-1];++i)
        printf("%c",ss[i]);
}
```
    - **核心思想**：`Read`函数读入并处理原串，将其转换为统一大小写字母串并反转拼接。`Make_Sa`和`Lcp`分别是后缀数组求`sa[]`、`rank[]`和`Height[]`的模板函数。`PutAns`函数通过遍历`Height`数组，找到满足条件的最长公共前缀，即最长回文子串，并根据记录的位置输出原串中的回文子串。

### 最优关键思路或技巧
1. **利用回文串性质优化枚举**：如二分答案利用回文子串长度奇偶性的单调性优化枚举过程，降低时间复杂度。
2. **Manacher算法**：能在线性时间内解决回文串问题，关键在于对原串的处理及算法实现过程中对回文半径的计算和更新。
3. **后缀数组结合Lcp**：通过对原串特殊处理和拼接，利用后缀数组模板求出Height数组，进而找到最长回文子串，实现高效求解。

### 可拓展之处
同类型题或类似算法套路：
1. **回文串相关**：如求字符串中所有回文子串的数量、长度等，可运用Manacher算法或暴力枚举结合优化技巧解决。
2. **字符串匹配问题**：如KMP算法、后缀数组等可用于解决字符串匹配、最长公共子串等问题，与本题利用字符串特性解决问题的思路类似。

### 推荐题目
1. **P3805 【模板】manacher算法**：裸的Manacher算法模板题，用于熟悉该算法的实现。
2. **P5410 【模板】扩展KMP**：考察扩展KMP算法，与本题同属字符串处理范畴，可加深对字符串算法的理解。
3. **P2408 不同子串个数**：利用后缀数组求字符串不同子串个数，与本题利用后缀数组解决问题的思路相关，可拓展后缀数组的应用能力。

### 个人心得摘录与总结
1. **作者“顾z”**：尝试通过判断最长回文半径中间位置字符两侧字符扩展匹配来输出原串，但被卡。最终通过记录字符在原数组中的位置解决问题。总结为在处理复杂字符串问题时，记录字符位置等关键信息可能是解决问题的关键。
2. **作者“逆时针的记忆”**：寻找非暴力题解无果后提供暴力和后缀数组两种解法，强调了对不同算法的掌握和应用，遇到问题多种思路尝试的重要性。 

---
处理用时：56.24秒
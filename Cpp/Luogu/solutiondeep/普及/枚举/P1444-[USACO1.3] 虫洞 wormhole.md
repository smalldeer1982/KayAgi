# 题目信息

# [USACO1.3] 虫洞 wormhole

## 题目描述

Farmer John 周末进行高能物理实验的结果却适得其反，导致 $n$ 个虫洞出现在农场上，农场是一个二维平面，没有两个虫洞处于同一位置。

根据他的计算，FJ 知道他的虫洞两两配对，形成 $\dfrac{n}{2}$ 对配对。例如，如果 $A$ 和 $B$ 的虫洞连接成一对，进入虫洞 $A$ 的任何物体将从虫洞 $B$ 出去，方向不变；反之亦然。  

然而这可能发生相当令人不快的后果。例如，假设有两个成对的虫洞 $A(1,1)$ 和 $B(3,1)$，Bessie 从 $(2,1)$ 开始朝着 $x$ 正方向移动。Bessie 将进入虫洞 $B(3,1)$，从 $A(1,1)$ 出去，然后再次进入 $B$，困在一个无限循环中！

FJ 知道他的农场里每个虫洞的确切位置。他知道 Bessie 总是向 $x$ 正方向走进来，虽然他不记得贝茜的当前位置。  

请帮助 FJ 计算有多少种虫洞配对方案，使得存在一个位置，使得 Bessie 从该位置出发，会被困在一个无限循环中。

## 说明/提示

### 数据范围
对于 $100\%$ 的数据，$2\le n \le 12$，$0 \le x,y \le 10^9$。  
保证 $n$ 为偶数。

### 样例解释

将虫洞编号为 $1 \sim 4$，然后通过将 $1,2$ 和 $3,4$ 匹配，如果 Bessie 从 $(0,0)$ 到 $(1,0)$ 之间的任意位置出发，她会陷入无限循环中。

相似的，在相同的起始点，如果配对是 $1,3$ 和 $2,4$，贝茜也会陷入循环。（如果贝西从 $3$ 进去，$1$ 出来，她会走向 $2$ ，然后被传送到 $4$，最后又回到 $3$）

仅有 $1,4$ 和 $2,3$ 的配对允许贝茜从任何二维平面上的点向 $x$ 正方向走，而不出现无限循环。

题面翻译摘自 NOCOW

## 样例 #1

### 输入

```
4
0 0
1 0
1 1
0 1```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先通过深度优先搜索（DFS）枚举虫洞的所有配对方案，再对每种方案判断是否存在能使Bessie陷入无限循环的情况。主要难点在于如何不重不漏地枚举配对方案以及高效地判断循环。

### 所选的题解
1. **作者：「QQ红包」 (5星)**
    - **关键亮点**：思路清晰，代码简洁明了。先排序方便查找同行虫洞，通过DFS枚举配对，再用另一个DFS函数检查是否存在循环，逻辑清晰易懂。
    - **个人心得**：无
    ```cpp
    int f(int num,int d,int begin,int p1) { 
        if (num!=1&&d==begin&&p1==1) return 1; 
        if (p1==0) {
            if (a[d].y==a[d+1].y) return f(num+1,d+1,begin,1);
            else return 0;
        }
        if (p1==1) return f(num+1,b[d],begin,0);
    }
    bool check() {
        for (int j=1;j<=n;j++)
            if (f(1,j,j,1)==1) return 1;
        return 0;
    }
    void dfs(int x) {
        if (x==n+1)    {if (check()==1) ans++;return;}
        if (b[x]==0) {
            for (int i=x+1;i<=n;i++)
                if (b[i]==0) {
                    b[i]=x;b[x]=i;
                    dfs(x+1);
                    b[i]=0;b[x]=0;
                }
        }
        if (b[x]!=0) dfs(x+1);
        return;
    }
    ```
2. **作者：Sino_E (4星)**
    - **关键亮点**：将虫洞问题转化为图的问题，按坐标排序后对同行虫洞连有向边，在DFS枚举配对时，标记点到下一个点之间经过的线段来判断循环，思路新颖且代码实现巧妙。
    - **个人心得**：无
    ```cpp
    bool cycle(int x) {
        while(to[x]) {
            if(tag[x]) return 1;
            tag[x]=1;
            x=con[to[x]];
        }
        return 0;
    }
    int ans=0;
    void dfs1(int k) {
        if(k>n) {
            bool ok=0;
            for(int i=1;i<=n &&!ok;i++)
                memset(tag,0,sizeof(tag)), ok|=cycle(i);
            ans+=ok;
            return;
        }
        if(con[k]) dfs1(k+1);
        else {
            for(int i=k+1;i<=n;i++)
                if(!con[i]) {
                    con[i]=k, con[k]=i;
                    dfs1(k+1);
                    con[i]=con[k]=0;
                }
        }
    }
    ```
3. **作者：王轩逸 (4星)**
    - **关键亮点**：算法步骤清晰，在DFS枚举配对时，通过特定条件避免重复配对，判断循环时利用抽屉原理，模拟Bessie从每个虫洞出发走n步来判断是否出现循环，思路巧妙。
    - **个人心得**：无
    ```cpp
    bool is_cycle() {
        for(int start=1;start<=n;start++) {
            int pos=start;
            for(int cnt=1;cnt<=n;cnt++)
                pos=to[part[pos]];
            if(pos)
                return true;
        }
        return false;
    }
    void dfs(int cur,int pre) {
        if(cur>n/2) {
            if(is_cycle())
                ans++;
            return;
        }
        for(int i=pre+1;i<=n;i++) 
        if(!part[i])
            for(int j=i+1;j<=n;j++)
                if(!part[j]) {
                    part[i]=j,part[j]=i;
                    dfs(cur+1,i);
                    part[i]=part[j]=0;
                } 
    }
    ```

### 最优的关键思路或技巧
1. **排序预处理**：将虫洞按y坐标升序，y相同按x坐标升序排序，方便查找每个虫洞右边的虫洞，简化判断循环的过程。
2. **DFS枚举配对**：利用DFS实现虫洞配对的枚举，通过合理设置条件（如保证每对中的第2个元素 > 第1个元素，第i对的第1个元素 > 第i - 1对的第1个元素）避免重复枚举。
3. **判环方法**：在判断是否存在循环时，模拟Bessie的行走路径，结合标记或步数限制（如利用抽屉原理走n步判断是否仍在虫洞中）来判断是否陷入循环。

### 可拓展之处
同类型题通常涉及组合枚举和状态判断，类似算法套路是先通过某种搜索算法（如DFS、BFS）枚举所有可能状态，再针对每种状态进行特定条件的判断。例如在一些路径搜索、状态组合的问题中都可应用。

### 推荐题目
1. **P1706 全排列问题**：通过DFS生成全排列，与本题DFS枚举配对方案类似，考察对搜索算法的理解与应用。
2. **P1157 组合的输出**：同样需要利用搜索算法生成组合，加深对组合枚举的理解，与本题枚举虫洞配对思路相似。
3. **P2392 kkksc03考前临时抱佛脚**：需要通过搜索枚举不同的分配方案，并判断方案是否满足条件，与本题整体思路类似，锻炼搜索与判断结合的能力。

### 个人心得摘录与总结
1. **作者：xsap**
    - **心得**：“黄题居然对拍了1天QwQ。坑点：如果遇到虫洞，必须传送过去。可能两点之间既可以用虫洞，又可以用走路。”
    - **总结**：强调了题目中的关键细节，这些细节容易在解题过程中被忽视，导致结果错误，提醒在解题时要仔细分析题目条件。
2. **作者：Thaumaturge**
    - **心得**：“蒟蒻的我只会用搜索，然而我的脑子并不太好使。。。所以有几个地方，卡了半天。1.去重。枚举时，首先要让对应关系不重复，其次顺序重复的话，通过大小顺序判断就行了。2.经过一个点并不意味着下一次来到它时就陷入了死循环。。有可能左进右出。因此，经过时要有两个方向，一个判左，一个判右。然后。。dfs就行了。”
    - **总结**：分享了自己在解题过程中遇到的困难及解决方法，特别是去重和判环的细节处理，对理解题目和优化算法有一定帮助。 

---
处理用时：33.88秒
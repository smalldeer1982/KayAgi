# 题目信息

# 积木城堡

## 题目描述

XC 的儿子小 XC 最喜欢玩的游戏用积木垒漂亮的城堡。城堡是用一些立方体的积木垒成的，城堡的每一层是一块积木。  

小 XC 是一个比他爸爸 XC 还聪明的孩子，他发现垒城堡的时候，如果下面的积木比上面的积木大，那么城堡便不容易倒。所以他在垒城堡的时候总是遵循这样的规则。

小 XC 想把自己垒的城堡送给幼儿园里漂亮的女孩子们，这样可以增加他的好感度。为了公平起见，他决定送给每个女孩子一样高的城堡，这样可以避免女孩子们为了获得更漂亮的城堡而引起争执。  

可是他发现自己在垒城堡的时候并没有预先考虑到这一点。所以他现在要改造城堡。由于他没有多余的积木了，他灵机一动，想出了一个巧妙的改造方案。他决定从每一个城堡中挪去一些积木，使得最终每座城堡都一样高。为了使他的城堡更雄伟，他觉得应该使最后的城堡都尽可能的高。

任务：

请你帮助小 XC 编一个程序，根据他垒的所有城堡的信息，决定应该移去哪些积木才能获得最佳的效果。

注意：一座城堡的高度，是组成它的所有积木的棱长之和。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1 \le n \le 100$，一座城堡中的积木不超过 $100$ 块，每块积木的棱长不超过 $100$。

## 样例 #1

### 输入

```
2
2 1 -1
3 2 1 -1
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论
这些题解均围绕如何通过01背包算法解决积木城堡高度统一且最大化的问题。思路上，都是对每个城堡的积木进行01背包处理，记录每个城堡能达到的高度，再从所有可能高度中找出所有城堡都能达到的最大高度。算法要点在于01背包的状态转移方程应用，难点主要是如何准确记录每个高度能被多少城堡达到，并高效找出满足条件的最大高度。

从质量上看，多数题解思路清晰，但部分代码可读性欠佳，优化程度也有所差异。

### 所选的题解
- **作者：Dispwnl（5星）**
  - **关键亮点**：思路清晰简洁，代码实现直接明了。先求出所有城堡的最大高度，从最大高度到1枚举，利用01背包记录每个高度能被多少城堡达到，找到满足条件的高度即输出。
  - **重点代码**：
```cpp
for(int k=1;k<=n;k++)
{
    memset(f,0,sizeof(f));
    int g=0,sum=0;
    while(1)
    {
        cin>>x;
        if(x<0) break;
        a[++g]=x;
        sum+=x;
    }
    f[0]=1;
    a[0]=g;
    if(sum>maxn) maxn=sum;
    for(int i=1;i<=g;i++)
    {
        for(int j=sum;j>=a[i];j--)
        if(f[j-a[i]]&&!f[j])
        f[j]=1,ans[j]++;
    }
}
for(int i=maxn;i>=0;i--)
{
    if(ans[i]==n)
    {
        cout<<i;
        return 0;
    }
}
```
  - **核心思想**：对每个城堡的积木进行01背包，标记每个高度能否达到，若能达到则对应`ans`数组位置加1，最后从大到小枚举`ans`数组找到满足条件的高度。
- **作者：Dw_hans（4星）**
  - **关键亮点**：详细阐述了动态规划的三个步骤，即状态表示、动态转移和初始状态，代码注释详细，利于理解。
  - **重点代码**：
```cpp
for(int k=1;k<=n;k++)
{
    memset(dp,0,sizeof(dp));
    int cnt = 0,high = 0;
    while(1)
    {
        cin >> len;
        if(len == -1) break;
        w[++cnt] = len;
        high += len;
    }
    dp[0] = 1;
    for(int i=1;i<=cnt;i++)
        for(int j=high;j>=w[i];j--)
            dp[j] |= dp[j-w[i]];
    min_high = min(min_high,high);
    for(int i = high;i>=1;i--)
        if(dp[i] == 1) ans[i]++;// 加到ans数组~
}
for(int i = min_high;i>=1;i--)// 看看那个高度可以所有达到！
    if(ans[i] == n)
    {
        cout << i;
        return 0;
    }
```
  - **核心思想**：对每个城堡进行01背包，标记能达到的高度，统计每个高度出现次数，从最小高度开始倒序查找满足条件的高度。
- **作者：早右昕（4星）**
  - **关键亮点**：代码简洁，在01背包实现过程中注意细节，如数组初始化、边界处理等。
  - **重点代码**：
```cpp
for(register int p=1; p<=n; p++) {
    memset(a,0,sizeof a);
    memset(dp,0,sizeof dp);
    num=sum=0;
    dp[0]=1;
    while(scanf("%d",&a[++num]) && a[num]!=-1) {
        sum+=a[num];
    }
    maxn=max(maxn,sum),num--;
    for(int i=1; i<=num; i++) {
        for(int j=sum; j>=a[i]; j--) {
            if(!dp[j]&&dp[j-a[i]]) {
                dp[j]=1;
                tot[j]++;
            }
        }
    }
}
maxn++;//细节需注意 
while(--maxn) if(tot[maxn]==n) break;
printf("%d\n",maxn);
```
  - **核心思想**：对每个城堡的积木进行01背包，统计每个高度能被多少城堡达到，从大到小查找满足条件的高度。

### 最优关键思路或技巧
- **01背包应用**：将每个城堡的积木看作01背包中的物品，积木棱长为物品重量和价值，城堡高度为背包容量，通过01背包记录每个城堡能达到的高度。
- **高度统计**：使用数组记录每个高度能被多少城堡达到，方便后续查找满足条件的高度。
- **倒序枚举**：从大到小枚举可能的高度，能更快找到满足所有城堡都能达到的最大高度，提高效率。

### 可拓展思路
此类题目属于背包问题的变形，常见的拓展方向有改变背包限制条件（如多重背包、分组背包），或者改变物品的属性和限制。类似算法套路是先确定状态表示，再推导动态转移方程，最后处理初始状态和边界条件。

### 相似知识点洛谷题目
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)
- [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)
- [P2690 [USACO04NOV]Apple Catching G](https://www.luogu.com.cn/problem/P2690)

### 个人心得摘录与总结
- **作者：伟大的王夫子**：调试一小时发现是数组越界问题，数组开小会导致错误，要注意根据数据范围合理设置数组大小。总结为在编程中需仔细考虑数据范围，避免因数组越界等低级错误浪费调试时间。 

---
处理用时：34.48秒
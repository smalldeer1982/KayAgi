# 题目信息

# 倒水

## 题目描述

一天，CC 买了 $N$ 个容量可以认为是无限大的瓶子，开始时每个瓶子里有 $1$ 升水。接着 CC 发现瓶子实在太多了，于是他决定保留不超过 $K$ 个瓶子。每次他选择两个当前含水量相同的瓶子，把一个瓶子的水全部倒进另一个里，然后把空瓶丢弃。（不能丢弃有水的瓶子）

显然在某些情况下 CC 无法达到目标，比如 $N = 3$、$K = 1$。此时 CC 会重新买一些新的瓶子（新瓶子容量无限，开始时有 $1$ 升水），以达到目标。

现在 CC 想知道，最少需要买多少新瓶子才能达到目标呢？


## 样例 #1

### 输入

```
3 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
13 2```

### 输出

```
3```

## 样例 #3

### 输入

```
1000000 5```

### 输出

```
15808```

# AI分析结果

### 综合分析与结论
这些题解主要围绕将问题转化为二进制相关操作来解决。核心思路是利用每个瓶子水量为\(2\)的幂次方这一特点，将瓶子总数转化为二进制后，通过操作使二进制中\(1\)的个数满足不超过\(K\)个的条件。各题解在具体实现方式和优化程度上有所不同，部分题解使用了内置函数或特定技巧来简化代码和提高效率。

### 所选的题解
- **作者：pantw (赞：222)  5星**
    - **关键亮点**：思路清晰简洁，直接点明纯二进制题目，利用`__builtin_popcount()`计算二进制中\(1\)的数量，使用`n & -n`（即`lowbit(n)`）进行贪心操作，代码极度精简。
    - **重点代码**：
```cpp
#include <cstdio>
int n, k, ans;
int main() {
    scanf("%d%d", &n, &k);
    while(__builtin_popcount(n) > k) ans += n & -n, n += n & -n;
    printf("%d", ans);
}
```
    - **核心实现思想**：通过`__builtin_popcount(n)`判断当前瓶子数\(n\)的二进制中\(1\)的个数是否大于\(K\)，若大于则每次加上`n & -n`（即二进制中最后一个\(1\)代表的值），同时更新\(n\)，直到\(n\)的二进制中\(1\)的个数不超过\(K\)，累加的值即为需要购买的瓶子数。

- **作者：jingyangzhi (赞：17)  4星**
    - **关键亮点**：对基础概念解释详细，适合初学者理解，先介绍`__builtin_popcount(n)`和`n & -n`的含义，再阐述解题思路，逻辑连贯。
    - **重点代码**：
```cpp
#include <iostream>
using namespace std;
int n, k, ans;
int main() {
    cin>>n>>k;
    while(__builtin_popcount(n) > k) {ans += n & -n;n+=n&-n;}
    cout<<ans<<endl;
}
```
    - **核心实现思想**：与pantw思路一致，利用`__builtin_popcount(n)`判断\(n\)二进制中\(1\)的个数与\(K\)的关系，通过`n & -n`操作使\(n\)的二进制中\(1\)的个数减少，统计增加的量得到购买瓶子数。

- **作者：_蒟蒻__ (赞：1)  4星**
    - **关键亮点**：考虑到`__builtin_popcount()`在NOIP中不能使用的情况，使用`bitset`的`count`函数统计二进制中\(1\)的个数，提供了另一种实用思路。
    - **重点代码**：
```cpp
#include<iostream>
#include<bitset>
#define int long long  
#define lowbit(x) x&(-x)
using namespace std;

signed main()
{
    int n,k;
    cin>>n>>k;
    bitset<50>a(n); 
    int ans=0;
    while(a.count()>k)
    {
        ans+=lowbit(n);
        n+=lowbit(n);
        a=n; 
    }
    cout<<ans;
    return ~~ (0 - 0);
}
```
    - **核心实现思想**：用`bitset`将\(n\)转化为二进制表示，通过`a.count()`获取\(1\)的个数，当\(1\)的个数大于\(K\)时，利用`lowbit(n)`操作更新\(n\)并累加，直到满足条件输出结果。

### 最优关键思路或技巧
1. **二进制转化**：将瓶子合并问题转化为二进制表示，利用二进制中\(1\)的个数表示可合并的瓶子数，这是解决问题的核心思想。
2. **贪心策略**：每次通过`n & -n`（`lowbit(n)`）操作，找到二进制中最后一个\(1\)，并加上这个值，使二进制中\(1\)的个数尽可能减少，以达到最少购买瓶子数的目的。
3. **内置函数与数据结构**：使用`__builtin_popcount()`快速统计二进制中\(1\)的个数，或利用`bitset`的数据结构及其`count`函数实现相同功能，简化代码实现。

### 可拓展之处
此类题目属于数学与算法结合的问题，类似套路可应用于涉及数字组合、合并，且组合规则与\(2\)的幂相关的场景。例如，一些资源分配、数据压缩等问题，可能通过转化为二进制操作来解决。

### 相似知识点洛谷题目
1. **P1010 幂次方**：将正整数表示为幂次方形式，涉及对数字的二进制理解和操作。
2. **P1601 A+B Problem（高精）**：虽然是高精度加法，但可以通过二进制模拟加法过程，加深对二进制运算的理解。
3. **P2142 高精度减法**：同样是高精度运算，在实现过程中可借鉴二进制减法的思想，对理解二进制操作有帮助。

### 个人心得摘录与总结
暂无典型的个人心得（调试经历、踩坑教训、顿悟感想等）在题解中出现。 

---
处理用时：28.90秒
# 题目信息

# 打开所有的灯

## 题目背景

pmshz在玩一个益(ruo)智(zhi)的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了pmshz。。。


## 题目描述

这个灯很奇(fan)怪(ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉pmshz要全部打开这些灯。



例如
```
0  1  1
1  0  0
1  0  1
```

点一下最中间的灯【2,2】就变成了
```
0  0  1
0  1  1
1  1  1
```

再点一下左上角的灯【1,1】就变成了

```
1  1  1
1  1  1
1  1  1
```

达成目标。最少需要2步。

输出2即可。


## 说明/提示

这个题水不水，就看你怎么考虑了。。。。


## 样例 #1

### 输入

```
0 1 1
1 0 0
1 0 1```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕“打开所有灯”问题，采用搜索、状态压缩、异或方程组等多种方法求解。多数题解利用每个灯操作次数的奇偶性简化问题，即操作偶数次等效于未操作，操作奇数次等效于操作一次。
1. **暴力枚举**：通过枚举所有灯的开关状态，判断是否能打开所有灯并记录最小步数。如作者“liuzitong”的九层循环枚举和递归枚举，时间复杂度为$O(2^9)$，虽简单但效率低。
2. **深度优先搜索（DFS）**：遍历所有可能的操作序列，找到打开所有灯的最小步数。部分题解利用剪枝优化，如避免重复操作同一灯。像作者“Uranus”、“Wyxrg”等采用此方法，写起来相对简单，但数据范围大时易超时。
3. **广度优先搜索（BFS）**：从初始状态开始，逐层扩展状态空间，找到达到目标状态的最短路径。部分题解结合状态压缩，用二进制数表示灯的状态，减少空间复杂度。如作者“nothingness”、“木木！”等，效率较高。
4. **状态压缩优化**：利用二进制数表示灯的状态和操作，通过异或运算模拟操作效果。如作者“ZigZagKmp”将操作法则转化为二进制数进行异或操作，代码简洁高效。
5. **异或方程组**：将灯的状态变化转化为异或方程组求解。如作者“2016jzy”的方法，需一定线性代数知识，理解和实现有一定难度。

### 所选4星及以上题解
1. **作者：nothingness（5星）**
    - **关键亮点**：状压DP思路清晰，利用$2^9 = 512$个数字对应灯的状态，根据异或变换规律进行状态转移，时间复杂度为$O(512×9)$，效率高且代码简洁。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：通过`upd`数组记录每个灯操作对应的状态变化，利用队列和`f`数组记录状态和步数，在循环中通过异或操作更新状态并记录最小步数。
```cpp
#include "bits/stdc++.h"
using namespace std;

int a,x,f[512];
int h,t,q[513];
int upd[10]={0,416,464,200,308,186,89,38,23,11};

int main()
{
    for(int i=8;i>=0;i--)
        scanf("%d",&a),x+=a*(1<<i);
    memset(f,-1,sizeof(f));
    f[x]=0;
    q[++t]=x;
    while(h<t)
    {
        x=q[++h];
        for(int i=1;i<=9;i++)
            if(f[x^upd[i]]==-1)
                q[++t]=x^upd[i],f[x^upd[i]]=f[x]+1;
    }
    printf("%d",f[511]);
    return 0;
}
```
2. **作者：木木！（4星）**
    - **关键亮点**：不仅给出AC代码，还详细证明了题目必有解。利用状压和异或运算，结合线性基知识，通过BFS搜索状态空间，代码简洁高效。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：`trans`数组记录每个灯操作对应的八进制数，通过`bfs`函数利用队列进行BFS搜索，在循环中通过异或操作更新状态并记录步数，找到目标状态时返回步数。
```cpp
#include <queue>
#include <cstdio>
using namespace std;

int trans[] = {0640,0720,0310,0464,0272,0131,0046,0027,0013};

int walked[1005]; 

int bfs(int x)
{
    queue<int> q;
    q.push(x);
    walked[x] = 1;
    while(!q.empty())
    {
        register int th = q.front();
        q.pop();
        
        if(th == 511)
        {
            return walked[th];
        }
        
        for(register int i=0; i<9; ++i)
        {
            th ^= trans[i];
            if(!walked[th])
            {
                walked[th] = walked[th^trans[i]]+1; 
                q.push(th);
            }
            th ^= trans[i];
        }
    }
}

int main()
{
    int beg = 0;
    for(register int i=1; i<=3; ++i)
    {
        for(register int j=1; j<=3; ++j)
        {
            int tmp;
            scanf("%d",&tmp);
            beg<<=1;
            beg += tmp;
        }
    }
    
    printf("%d",bfs(beg)-1);
}
```
3. **作者：ZigZagKmp（4星）**
    - **关键亮点**：将题意转化为用二进制存储状态，通过异或运算实现操作法则，思路新颖独特，代码实现简洁明了，利用BFS搜索最优解。
    - **个人心得**：无
    - **重点代码 - 核心实现思想**：`in`函数读取初始状态并将其转化为二进制存储，`Do`函数利用队列进行BFS，在循环中通过异或`d`数组中的操作数更新状态，找到目标状态时输出步数。
```cpp
inline void in()
{
    int a;
    for(register int i=1;i<=9;i++)
    {
        cin>>a;
        if(a)
            st^=(1<<(9-i));
    }
    q.push(st);
    q.push(0);
    ed=(1<<9)-1;
    vis[st]=1;
}
inline void Do()
{
    int a,s,na,ns;
    while(!q.empty())
    {
        a=q.front();q.pop();
        s=q.front();q.pop();
        ns=s+1;na=a;
        for(register int i=0;i<9;i++)
        {
            na=a^d[i];
            if(!vis[na])
            {
                q.push(na);
                q.push(ns);
                if(na==ed)
                {
                    printf("%d\n",ns);
                    return;
                }
            }
        }
    }
}
```

### 最优关键思路或技巧
1. **状态压缩**：利用二进制数表示灯的状态和操作，将复杂的状态变化转化为简单的位运算，减少空间复杂度，提高算法效率。如上述4星及以上题解均采用此技巧。
2. **剪枝优化**：在DFS中，利用每个灯最多操作一次的特性，避免重复搜索，减少不必要的计算。
3. **BFS结合状态判重**：通过BFS遍历状态空间，利用数组或哈希表记录已访问状态，避免重复访问，快速找到最优解。

### 可拓展之处
此类题目属于状态空间搜索问题，常见拓展方向为增加灯的数量或改变操作规则。类似算法套路包括利用状态压缩优化搜索、通过剪枝减少搜索空间、使用BFS或DFS遍历状态空间等。

### 相似知识点洛谷题目
1. **P1162 填涂颜色**：通过搜索确定封闭区域，与本题搜索状态空间思路类似。
2. **P1314 聪明的质监员**：可通过二分答案结合状态统计求解，涉及状态处理和优化思想。
3. **P1433 吃奶酪**：利用状态压缩DP解决旅行商问题的简化版，与本题状压思路相关。

### 个人心得摘录与总结
1. **作者：Uranus**：在DFS实现中，最初用`string`储存状态且变换函数使用三目运算符时因运算符优先级问题出错，后修正。总结出使用三目运算符要注意括号及判断符号的使用。
2. **作者：封禁用户**：使用BFS+状态压缩时，因队列忘了`pop()`导致调试两小时，强调了BFS实现中细节的重要性。 

---
处理用时：43.04秒
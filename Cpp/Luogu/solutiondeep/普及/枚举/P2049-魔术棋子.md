# 题目信息

# 魔术棋子

## 题目描述

在一个 $M \times N$ 的魔术棋盘中，每个格子中均有一个整数，当棋子走进这个格子中，则此棋子上的数会被乘以此格子中的数。一个棋子从左上角走到右下角，只能向右或向下行动，请问此棋子走到右下角后，模（mod）$K$ 可以为几？

如以下 $2 \times 3$ 棋盘：

```
3    4    4
5    6    6
```
棋子初始数为 $1$，开始从左上角进入棋盘，走到右下角，上图中，最后棋子上的数可能为 $288,432$ 或 $540$。所以当 $K = 5$ 时，可求得最后的结果为：$0,2,3$。


## 样例 #1

### 输入

```
2 3 5
3 4 4
5 6 6
```

### 输出

```
3
0 2 3
```

# AI分析结果

• 综合分析与结论：这些题解主要采用动态规划（DP）、广度优先搜索（BFS）、深度优先搜索（DFS）三种算法思路来解决问题。
    - **动态规划**：通过三维数组`dp[i][j][l]`记录在位置`(i, j)`能否得到模`k`后值为`l`的结果，状态转移方程为`dp[i][j][l*num[i][j]%k] = dp[i - 1][j][l] || dp[i][j - 1][l]`，利用已知状态递推后续状态。
    - **广度优先搜索**：使用队列存储节点，节点包含位置和当前值信息，通过不断扩展相邻节点来遍历所有可能路径，利用`used`数组防止重复入队。
    - **深度优先搜索**：通过递归函数不断探索向下和向右的路径，利用`vis`数组标记已访问状态防止重复搜索。
    - **难点**：主要在于如何有效记录和更新棋子在不同位置可能得到的模`k`后的所有值，避免重复计算和遗漏情况。动态规划通过状态转移方程解决；BFS和DFS通过标记数组防止重复访问来优化。
    - **结论**：各算法思路都能解决问题，但动态规划在时间复杂度上相对更优，为O(MNK)，BFS和DFS在加了标记数组优化后也能通过，但时间复杂度相对较高。

以下为题解评分：
  - **Drifterming**：思路清晰，代码规范，详细注释，利用动态规划解决问题，在初始化和状态转移时处理得当。 5星
  - **SIGSEGV**：用BFS实现，代码简洁，通过`used`数组优化避免重复入队，但相比DP没有深入分析时间复杂度。4星
  - **一ZCH一**：动态规划思路，代码逻辑清晰，对状态转移方程解释详细，但初始化部分与其他动态规划题解略有不同，可读性稍逊。4星
  - **JeffWang2019**：DFS实现，代码结构清晰，详细注释，但DFS本身时间复杂度较高，依赖标记数组优化。3星
  - **斯德哥尔摩**：动态规划，状态转移方程正确，但代码注释较少，可读性一般。3星
  - **ych153**：Go语言实现动态规划，思路与C++动态规划题解一致，但语言小众，对大部分学习C++的人参考性稍弱。3星
  - **小柯**：DFS实现，代码有一定优化，但整体思路和实现与JeffWang2019类似。3星
  - **lych**：详细分析动态规划思路及优化过程，有一定启发性，但代码为Delphi语言，对C++学习者参考性有限。3星
  - **微香玉烛暗**：DFS实现并简单优化，思路和代码较常规，没有特别突出亮点。3星
  - **Mychael**：使用`set`存储可能情况，但未优化导致TLE，思路有一定创新性但未成功解决问题。2星
  - **l1360300734**：动态规划思路，但代码逻辑稍乱，初始化部分较为繁琐，可读性欠佳。2星

所选4星及以上题解：
  - **Drifterming（5星）**
    - **关键亮点**：思路清晰，代码注释详细，动态规划状态转移方程实现简洁明了。
    - **核心代码**：
```cpp
// 状态转移
for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)
        for(int l=0;l<k;l++)
            if(!dp[i][j][l*num[i][j]%k])
                dp[i][j][l*num[i][j]%k]=dp[i-1][j][l]||dp[i][j-1][l];
// 统计结果
for(int i=0;i<k;i++) {
    if(dp[m][n][i]) ans++;
}
printf("%d\n",ans);
for(int i=0;i<k;i++) {
    if(dp[m][n][i]) printf("%d ",i);
}
```
  - **SIGSEGV（4星）**
    - **关键亮点**：采用BFS实现，代码简洁，利用`used`数组优化防止重复入队。
    - **核心代码**：
```cpp
while (!q.empty()) {
    Node nd = q.front();q.pop();
    if (nd.x == n - 1 && nd.y == m - 1) {
        vis[nd.val] = 1;continue;
    }
    for (int i = 0;i < 2;i++) {
        int nx = dx[i] + nd.x,ny = nd.y + dy[i],nval = a[nx][ny] * nd.val % k;
        if (nx < 0 || nx >= n || ny < 0 || ny >= m || used[nx][ny][nval])
            continue;
        q.push({nx,ny,nval});
        used[nx][ny][nval] = 1;
    }
}
```
  - **一ZCH一（4星）**
    - **关键亮点**：动态规划思路清晰，对状态转移方程解释详细。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++) 
        for(int w=0;w<k;w++) {
            if(dp[i-1][j][w]==1)
                dp[i][j][(w*a[i][j])%k]=1;
            if(dp[i][j-1][w]==1)
                dp[i][j][(w*a[i][j])%k]=1;
        } 
for(int i=0;i<k;i++)
    if(dp[n][m][i]==1) cnt++;
cout<<cnt<<endl;
for(int i=0;i<k;i++)
    if(dp[n][m][i]==1) cout<<i<<" ";
```

**最优关键思路或技巧**：使用三维数组记录状态是解决本题的关键，无论是动态规划还是搜索算法都利用这一数据结构记录棋子在不同位置可能得到的模`k`后的结果。动态规划通过状态转移方程利用已知状态递推后续状态，在时间复杂度上相对更优；搜索算法则通过标记数组避免重复访问，优化搜索效率。

**可拓展思路**：同类型题常涉及路径上的数值计算与状态记录，类似套路为根据题目限制条件确定状态表示，如二维或三维数组，再通过状态转移方程（动态规划）或搜索策略（BFS、DFS）更新状态。

**洛谷相似题目推荐**：
  - P1002 [NOIP2002 普及组] 过河卒：涉及路径上的走法统计，与本题确定路径上的结果有相似性。
  - P1006 [NOIP2008 提高组] 传纸条：同样是在矩阵中按特定规则移动并计算最优值，可类比状态表示和转移。
  - P1216 [USACO1.5] 数字三角形 Number Triangles：通过动态规划在三角形数组中寻找最优路径和，与本题思路类似。

**个人心得摘录与总结**：
  - **lych**：强调关注数据范围对解题思路的启发，如本题`K`较小联想到背包问题剩余容量可能性；同时指出动态规划可能需要优化，否则易超时。总结为解题时要善于根据数据特点选择合适算法并优化。 

---
处理用时：33.31秒
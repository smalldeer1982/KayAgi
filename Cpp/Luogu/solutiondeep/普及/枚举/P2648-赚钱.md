# 题目信息

# 赚钱

## 题目背景

改编自某题


## 题目描述

zzy现在决定环游中国，顺便赚点钱。zzy在一个城市最多只能赚D元，然后他可以选择退休也就是停止赚钱，或者去其它城市工作。当然，他可以在别处工作一阵子后又回到原来的城市再赚D元。这样的往返次数是没有任何限制的。

城市间有P条单向路径连接，共有C座城市，编号从1到C。路径i从城市Ai到城市Bi，在路径行走上不用任何花费。

zzy还可以乘飞机从某个城市飞到另一个城市。共有F条单向的航线，第i条航线是从城市Ji飞到另一座城市Ki，费用是Ti元。假如zzy身上没有现钱，他可以用以后赚的钱来付机票钱。

zzy可以从任何一个城市出发开始赚钱，并且选择在任何时候、任何城市退休。现在zzy想要知道，如果在工作时间上不做限制，那么zzy共可以赚多少钱呢？如果赚的钱也不会出现限制，那么就输出orz。


## 说明/提示

对于100%的数据，1<=D<=1000，1<=P<=200，2<=C<=300，1<=F<=400。


## 样例 #1

### 输入

```
100 3 5 2
1 5
2 3
1 4
5 2 150
2 5 120```

### 输出

```
250```

# AI分析结果

• 综合分析与结论：
    - 思路方面：各题解均围绕在给定的城市连接（包括免费路径和收费航线）图中，求解zzy能赚取的最大金额，若存在环则输出“orz”。多数题解采用求最长路的思路，通过设置合适边权和源点，利用SPFA算法实现，部分题解还提到了暴力从每个点出发跑SPFA或使用Floyed算法。
    - 算法要点：关键在于合理设置边权，免费边权设为 -d 或 0，收费边权设为 w - d 或 w，通过超级源点或从每个点出发跑SPFA算法。同时利用SPFA算法过程中统计入队次数来判断是否存在环。
    - 解决难点：难点在于将实际问题转化为图论中的最长路问题，并正确设置边权和源点，处理好环的判断。
    - 评分情况：绝顶我为峰、Created_equal1、JohnJoeZhu 的题解在思路清晰度、代码可读性方面表现较好，相对质量较高。

所选的题解：
  - **作者：绝顶我为峰 (5星)**
    - **关键亮点**：思路清晰，直接点明将边权取相反数存边，跑最短路再取相反数得最长路的巧妙方法，代码简洁明了，完整实现了超级源点构建、边权设置及SPFA判环与求解。
    - **重点代码**：
```cpp
inline bool SPFA()//板子
{
    memset(dis,127/3,sizeof(dis));
    queue<int> q;
    q.push(0);
    dis[0]=0;
    vis[0]=1;
    while(!q.empty())
    {
        int k=q.front();
        q.pop();
        vis[k]=0;
        ++r[k];
        if(r[k]>c)
            return 1;
        for(vector<edge>::iterator it=v[k].begin();it!=v[k].end();++it)
            if(dis[it->node]>dis[k]+it->weight)
            {
                dis[it->node]=dis[k]+it->weight;
                if(!vis[it->node])
                {
                    vis[it->node]=1;
                    q.push(it->node);
                }
            }
    }
    return 0;
}
int main()
{
    cin>>d>>p>>c>>f;
    while(p--)
    {
        int x,y;
        cin>>x>>y;
        v[x].push_back(edge(y,-d));//免费边
    }
    while(f--)
    {
        int x,y,w;
        cin>>x>>y>>w;
        v[x].push_back(edge(y,w-d));//收费边
    }
    for(int i=1;i<=c;++i)
        v[0].push_back(edge(i,-d));//和源点连边
    if(SPFA())
        cout<<"orz\n";//有负环
    else
    {
        int ans=0;
        for(int i=1;i<=c;++i)
            ans=min(ans,dis[i]);//统计
        cout<<-ans<<endl;//再用相反数输出
    }
    return 0;
}
```
    - **核心实现思想**：通过SPFA算法判断是否存在负环（实际对应原问题中的正环），若不存在则统计各点到超级源点的最短路（边权取反后），最后取相反数得到最长路即最大收益。
  - **作者：Created_equal1 (4星)**
    - **关键亮点**：简洁指出添加超级源点跑SPFA求最长路并判正权环的思路，同时提到数据水，暴力从每个点跑SPFA也能过的特点。
  - **作者：JohnJoeZhu (4星)**
    - **关键亮点**：详细分析了判环情况及边权、源点设置的两种方法，并给出两种方法对应的代码，对理解题目解法有很大帮助。
    - **重点代码（超级源点 + 负边权）**：
```cpp
bool SPFA()//板子
{
    memset(dis,127/3,sizeof(dis));
    queue<int>q;
    q.push(0);
    dis[0]=0;
    vis[0]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        vis[u]=0;
        in[u]++;
        if(in[u]>c+1) return 1;//判环
        for(int i=head[u];i;i=edge[i].nex)
        {
            int v=edge[i].v;
            if(dis[v]>dis[u]+edge[i].w)
            {
                dis[v]=dis[u]+edge[i].w;
                if(!vis[v])
                {
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
    }
    return 0;
}
int main()
{
    scanf("%d%d%d%d",&d,&p,&c,&f);
    int u,v,w;
    for(int i=1;i<=p;i++)
    {
        scanf("%d%d",&u,&v);
        add(u,v,-d);
    }
    for(int i=1;i<=f;i++)
    {
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w-d);
    }
    for(int i=1;i<=c;i++) add(0,i,-d);
    if(SPFA()) printf("orz");
    else 
    {
        int ans=0;
        for(int i=1;i<=c;i++) ans=min(ans,dis[i]);
        printf("%d",-ans);
    }
    return 0;
}
```
    - **核心实现思想**：与绝顶我为峰类似，通过超级源点构建图，利用SPFA判环，统计最短路（边权取反后）再取相反数得最长路。

最优关键思路或技巧：
    - **边权设置技巧**：将免费边权设为 -d，收费边权设为 w - d，通过取相反数将最长路问题转化为最短路问题求解。
    - **超级源点构建**：构建一个超级源点与所有点相连，权值为 -d，这样只需跑一次SPFA算法即可求解。

可拓展之处：
    - 同类型题可拓展到其他涉及有向图最长路、环判断并结合实际收益问题，如运输成本与收益在图结构中的最优解问题。
    - 类似算法套路可应用在通过边权设置转化问题类型，利用图论算法解决实际场景中的最值问题。

推荐洛谷题目：
    - P3371 【模板】单源最短路径（弱化版）：基础的单源最短路径问题，可巩固SPFA算法基础。
    - P1339 热浪：单源最短路的应用问题，与本题类似，通过图论解决实际场景问题。
    - P1119 灾后重建：涉及到动态图的最短路问题，对图论算法应用能力有进一步提升。

个人心得摘录与总结：
    - JohnJoeZhu提到数据水但自己还T了一个点，得出两种设置源点方法，反映出在做题时需要对不同数据情况进行尝试和优化，同时对不同解法有更深入的思考。 

---
处理用时：33.32秒
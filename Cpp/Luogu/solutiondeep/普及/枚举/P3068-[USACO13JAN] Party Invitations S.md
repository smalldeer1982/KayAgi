# 题目信息

# [USACO13JAN] Party Invitations S

## 题目描述

农夫约翰要举办一个聚会，他要邀请一些奶牛来参加。在约翰的奶牛朋友圈中，有一些奶牛是好基友，对于每一个奶牛朋友圈，没有一个完全与之相同的，假设这个奶牛朋友圈有 $k$ 头奶牛，如果约翰已经邀请了 $k-1$ 头，那么剩下的那头牛也得邀请。约翰想让你告诉他，他最少需要邀请多少头奶牛？我们假设 $1$ 号奶牛已经被邀请了。

## 说明/提示

$1 \leq  N\leq1000000$。

设所有的奶牛朋友圈的大小之和为 $M$，则 $1 \leq  M\leq250000$。

## 样例 #1

### 输入

```
10 4 
2 1 3 
2 3 4 
6 1 2 3 4 6 7 
4 4 3 2 1 
```

### 输出

```
4 
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效解决奶牛邀请问题展开。思路上，有的采用线性存储结合暴力模拟，有的运用拓扑排序，还有的借助多种容器来优化处理。解决难点在于避免超内存及提高算法效率，如直接按组存奶牛易超内存，需优化存储方式。整体来看，各题解质量参差不齐，部分代码可读性欠佳或优化不足。

### 所选题解
1. **作者：EarringYYR (5星)**
    - **关键亮点**：采用线性存储优化内存使用，通过数组记录奶牛及每组的头尾标记，暴力模拟邀请过程，思路清晰，代码简洁易读。
    - **核心代码**：
```cpp
for(int i=1;i<=g;i++)
{
    cin>>size[i];
    for(int j=1;j<=size[i];j++)
        cin>>kid[++sum];
    zu[i][1]=zu[i-1][2]+1;
    zu[i][2]=zu[i-1][2]+size[i];//记录头尾标记
} 
ans=0; 
invite[1]=1;//初始化（奶牛1首先被邀请）
int pan;
do
{
    pan=0;
    for(int k=1;k<=g;k++)
    {
        if(use[k]==0)//如果这个组还没有被邀请就检查现在是否需要邀请
        {
            int len=0;
            for(int j=zu[k][1];j<=zu[k][2];j++)
                if(invite[kid[j]]==1)
                    len++;//寻找当前组已经有多少头牛被邀请
            if(len==size[k]-1)//如果被邀请的奶牛数为当前奶牛数-1就邀请当前组
            {
                use[k]=1;
                pan=1;
                for(int j=zu[k][1];j<=zu[k][2];j++)
                    invite[kid[j]]=1;
            }
            if(len==size[k])
                use[k]=1;//排除一个组的奶牛已经全部被邀请却没有被标记的，节省时间
        }
    }
}while(pan==1);//只有有新的奶牛被邀请时才需要再此寻找新的组
for(int i=1;i<=n;i++)//找哪些奶牛被邀请了
if(invite[i]==1)
    ans++;
```
    - **核心思想**：先线性存储所有奶牛及每组标记，初始化1号奶牛被邀请，通过循环检查每组奶牛邀请情况，若满足邀请$k - 1$头则邀请剩下那头，直到无新奶牛需邀请，最后统计被邀请奶牛数。
2. **作者：不便透露 (4星)**
    - **关键亮点**：利用拓扑排序思想，通过数组和向量记录奶牛与组的关系，逻辑清晰，算法效率较高。
    - **核心代码**：
```cpp
void Push(int a){
    int i,u;
    for(i=0;i<g[a].size();i++){
        u=g[a][i];
        if(!vis[u]){
            vis[u]=1;
            p.push(u);
            num++;
        }
    }
}
int main(){
    cin>>n>>m;
    int i,k,j,u;
    for(i=1;i<=m;i++){
        scanf("%d",&j);
        in[i]=j;
        for(;j;j--){
            scanf("%d",&k);
            G[k].push_back(i);
            g[i].push_back(k);
        }
    }
    q.push(1);
    vis[1]=1;
    while(!q.empty()){
        while(!q.empty()){
            k=q.front();
            q.pop();
            for(i=0;i<G[k].size();i++){
                u=G[k][i];
                in[u]--;
                if(in[u]==1){
                    Push(u);
                }
            }
        }
        q=p;
        while(!p.empty())
            p.pop();
    }
    printf("%d",num+1);
    return 0;
}
```
    - **核心思想**：读入数据时记录每组牛数及奶牛所属组，1号奶牛入队，每次取出队首奶牛，更新其所在组的剩余未邀请牛数，若某组剩余1头未邀请奶牛，则将该组所有未邀请奶牛入队，重复操作直到队列为空，最后输出邀请奶牛总数。
3. **作者：曹老师 (4星)**
    - **关键亮点**：使用多种容器（vector、set、queue），逻辑清晰，利用set的特性优化判断，代码实现较为简洁。
    - **核心代码**：
```cpp
int main() {
    scanf("%d%d",&n,&m);
    for(int i=1; i<=m; i++) {
        int t;
        scanf("%d",&t);
        for(int j=1; j<=t; j++) {
            int x;
            scanf("%d",&x);
            about[x].push_back(i);
            s[i].insert(x);
        }
    }
    q.push(1);
    vis[1] = 1;
    while(!q.empty()) {
        int now = q.front();
        q.pop();
        ans++;
        for(int i=0; i<about[now].size(); i++) {
            s[about[now][i]].erase(now);
            if(s[about[now][i]].size() == 1 &&!vis[*s[about[now][i]].begin()]) {
                int t = *s[about[now][i]].begin();
                q.push(t);
                vis[t] = 1;
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```
    - **核心思想**：用vector记录与奶牛有关的集合，set存储每个集合，queue存储被邀请奶牛。1号奶牛入队，每次取出队首奶牛，从其相关集合中删除该奶牛，若集合大小变为1且集合中剩余奶牛未被邀请，则将其入队，直到队列为空，输出邀请奶牛总数。

### 最优关键思路或技巧
1. **存储优化**：采用线性存储，避免直接按组存储奶牛导致超内存，如EarringYYR的方法。
2. **数据结构运用**：利用拓扑排序（不便透露）、set的特性（曹老师）优化判断过程，提高算法效率。

### 可拓展思路
此类题目属于依赖关系类问题，类似算法套路可应用于有依赖关系的任务调度等场景。例如，在任务安排中，某些任务需在其他任务完成后才能执行，可借鉴上述思路解决。

### 相似知识点洛谷题目
1. **P1983 车站分级**：通过分析列车停靠站点关系确定车站等级，与本题判断奶牛邀请关系类似。
2. **P3387 缩点**：处理有向图中强连通分量问题，可类比本题奶牛朋友圈关系处理。
3. **P2341 受欢迎的牛**：通过分析牛之间的崇拜关系找出受欢迎的牛，与本题依赖关系判断思路相似。

### 个人心得摘录与总结
1. **king_xbz**：最初考虑暴力开数组存关系会TLE/MLE，受他人启发用前缀和后分块解决。总结为做题时要注意优化，避免简单暴力解法，多参考他人思路。 

---
处理用时：35.72秒
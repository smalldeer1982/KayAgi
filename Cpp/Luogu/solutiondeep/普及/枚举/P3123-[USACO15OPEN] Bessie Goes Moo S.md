# 题目信息

# [USACO15OPEN] Bessie Goes Moo S

## 题目描述

Farmer John 和奶牛 Bessie 喜欢在空闲时间互相出数学谜题。

上一次 FJ 给 Bessie 出的谜题非常难，她没能解出来。

现在，她想通过给 FJ 出一个有挑战性的谜题来报复他。

Bessie 给 FJ 的表达式是 $(B+E+S+S+I+E)(G+O+E+S)(M+O+O)$，其中包含七个变量 $B,E,S,I,G,O,M$（"$O$" 是一个变量，不是零）。对于每个变量，她给 FJ 提供了一个最多包含 500 个整数值的列表，表示该变量可能取的值。

她要求 FJ 计算有多少种不同的方式可以为这些变量赋值，使得整个表达式的值是 7 的倍数。

注意，这个问题的答案可能太大，无法用 32 位整数表示，因此你可能需要使用 64 位整数（例如，C 或 C++ 中的 "long long"）。

## 说明/提示

两种可能的赋值方式是：

$(B,E,S,I,G,O,M) = (2, 5, 7, 9, 1, 16, 19)$ -> 51,765

$(B,E,S,I,G,O,B) = (2, 5, 7, 9, 1, 16, 2)$ -> 34,510

## 样例 #1

### 输入

```
10
B 2
E 5
S 7
I 10
O 16
M 19
B 3
G 1
I 9
M 2```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：这些题解思路基本一致，都利用取模运算性质，将每个变量取值对7取模后存储，通过暴力枚举7个变量模7后的所有7^7种取值组合，判断表达式值是否为7的倍数，利用乘法原理计算满足条件的方案数。算法要点在于取模存储和暴力枚举。解决难点主要是理解取模对结果无影响以及乘法原理的应用。各题解质量差异主要体现在思路清晰度、代码可读性和优化程度上。

所选的题解：
  - 作者：Expecto (5星)
    - 关键亮点：思路清晰，代码简洁，利用dfs进行枚举，在输入时对数值取模并记录每个数出现次数，结构清晰。
    - 重点代码及核心思想：
```cpp
void dfs(int now){
    if (now==7){
        long long sum=1ll*(x[0]+x[1]+x[2]+x[2]+x[3]+x[1])*(x[4]+x[5]+x[1]+x[2])*(x[6]+x[5]*2);
        if (sum%7==0){
            long long tmp=1;
            for (int i=0;i<7;i++)
                tmp*=g[i][x[i]];
            ans+=tmp;
        }
        return ;
    }
    for (int i=0;i<7;i++){
        if (!g[now][i]) continue;
        x[now]=i;
        dfs(now+1);
    }
}
int main(){
    int n;
    cin>>n;
    for (int i=1;i<=n;i++){
        char c;int l;
        cin>>c>>l;
        l=(l%7+7)%7;
        if (c=='B') g[0][l]++;
        if (c=='E') g[1][l]++;
        if (c=='S') g[2][l]++;
        if (c=='I') g[3][l]++;
        if (c=='G') g[4][l]++;
        if (c=='O') g[5][l]++;
        if (c=='M') g[6][l]++;        
    }
    dfs(0);
    cout<<ans;
    return 0;
}
```
核心思想是通过dfs枚举7个变量取值，在dfs过程中计算表达式值，若为7的倍数则根据乘法原理累加方案数，主函数负责读入数据并初始化。
  - 作者：Ofnoname (4星)
    - 关键亮点：代码逻辑清晰，注释详细，解释了为何对变量取值取模及乘法原理的应用，使用map离散化字母，便于处理。
    - 重点代码及核心思想：
```cpp
void DFS(int x)
{
	if (x == 7)
	{
		long sum = (f[0]+(f[1]+f[2])*2+f[3]) * (f[1]+f[2]+f[4]+f[5]) * (f[6]+f[5]*2);
		if (!(sum % 7))
		{
			sum = 1;
			for (int i = 0; i < 7; i++)
				sum *= a[i][f[i]];
			ans += sum;
		}return;
	}
	for (int i = 0; i < 7; i++)
		if (a[x][i]) f[x] = i, DFS(x+1);
}
int main()
{
	scanf("%d", &N);
	for (int i = 0; i < 7; i++)
		M[c[i]] = i;
	while (N--)
	{
		scanf("%s%d", t, &x);
		a[M[t[0]]][(x%7+7)%7]++;
	}
	DFS(0);
	printf("%lld\n", ans);
}
```
核心思想是通过DFS枚举变量取值，在DFS结束条件中判断表达式值是否为7的倍数，若是则用乘法原理计算方案数，主函数读入数据并利用map离散化字母。
  - 作者：Wangchenxin (4星)
    - 关键亮点：使用简单易懂的多层循环枚举，代码简洁明了，通过快读优化输入，适合初学者理解。
    - 重点代码及核心思想：
```cpp
int main(){
    N=read();
    for (int i=0;i<N;i++){
        ch=getchar(),x=read();
        hsh[ch][(x%7+7)%7]++;//因为是7的倍数,所以分成7类（分别是%7=0,1,2,3,4,5,6）,其实只需要判断他们除以7的余数相加是否为7的倍数
    }
    for(int B=0;B<7;B++)
    for(int E=0;E<7;E++)
    for(int S=0;S<7;S++)
    for(int I=0;I<7;I++)
    for(int G=0;G<7;G++)
    for(int O=0;O<7;O++)
    for(int M=0;M<7;M++) 
      if (((B+E+S+S+I+E)*(G+O+E+S)*(M+O+O))%7==0){
          ans+=hsh['B'][B]*hsh['E'][E]*hsh['S'][S]*hsh['I'][I]*hsh['G'][G]*hsh['O'][O]*hsh['M'][M];//判断%7后的余数是否为7的倍数，如果是ans++;
      }
    printf("%lld\n",ans);
    return 0;
}
```
核心思想是通过多层循环枚举7个变量取值，判断表达式值是否为7的倍数，若是则根据乘法原理累加方案数，主函数负责读入数据并存储。

最优关键思路或技巧：利用取模运算性质，将取值范围缩小到0 - 6，减少枚举量，同时利用乘法原理计算方案数。

可拓展之处：同类型题可考察不同的表达式和模数，类似算法套路是在涉及整除判断时，利用取模运算简化问题，再通过暴力枚举或其他搜索算法求解。

推荐洛谷题目：
  - P1164 小A点菜
  - P1036 选数
  - P1219 八皇后

无个人心得摘录。 

---
处理用时：29.27秒
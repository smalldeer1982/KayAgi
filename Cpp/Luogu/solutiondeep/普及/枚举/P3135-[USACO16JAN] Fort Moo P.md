# 题目信息

# [USACO16JAN] Fort Moo P

## 题目描述

Bessie 正在和她的朋友 Elsie 一起建造一个堡垒。像任何好的堡垒一样，这个堡垒需要一个坚固的框架。Bessie 想要建造一个一米宽的矩形轮廓框架，然后在这个框架上建造堡垒。

Bessie 已经选择了一个建造堡垒的地点——一块 $N$ 米乘 $M$ 米的土地（$1 \leq N, M \leq 200$）。不幸的是，这块地有一些沼泽区域，不能用来支撑框架。请帮助 Bessie 确定她可以用堡垒覆盖的最大面积（由框架支撑的矩形的面积），使得框架不会坐落在任何沼泽区域上。

## 说明/提示

在示例中，最优框架的位置由下面的 `f` 表示：

```
.ffff.
.fX.fX
Xf.Xf.
.ffff.
..X...
```

## 样例 #1

### 输入

```
5 6
......
..X..X
X..X..
......
..X...```

### 输出

```
16```

# AI分析结果

### 综合分析与结论
这些题解主要围绕在给定的含沼泽区域的矩形土地上，寻找最大面积的矩形框架这一问题展开，思路和方法多样。
 - **暴力枚举类**：如$O(n^5)$枚举左上角、长、宽并验证，通过前缀和优化到$O(n^4)$，部分题解还通过循环顺序调整、提前剪裁等优化进一步提升效率，但本质仍基于暴力枚举。这类方法思路直接，但复杂度较高，优化空间有限。
 - **DP或类似思路类**：大多利用$O(n^2)$枚举起始行和终止行，再通过预处理列的连通性等信息，以$O(m)$的复杂度处理列，从而将整体复杂度优化到$O(n^3)$。不同题解在预处理方式和具体实现细节上有所差异。

综合来看，基于$O(n^3)$的解法在效率和通用性上更具优势，通过合理预处理和巧妙的状态转移或条件判断，能更高效地解决问题。

### 所选的题解
 - **作者：潜翎 (赞：16)  星级：5星**
    - **关键亮点**：思路清晰，从经典的最大子矩阵问题引入，详细阐述如何将其思路迁移到本题。通过预处理纵向连通性，巧妙利用列的连通状态更新答案，代码实现简洁明了，对关键代码段有详细解释。
    - **个人心得**：作者表示第一次独立完成蓝题dp，做题时受“200引导我们思考$O(n^3)$”这句话启发，完成后因看到题解第一句同样是该话而决定写题解，体现了对解题思路的深刻印象和成就感。
```cpp
// 预处理纵向连通性
for(int i=1;i<=m;i++)
{
    int x=0;
    for(int j=0;j<=n;j++)
        if(str[j][i]=='X'||!str[j][i]) x++;
        else a[j][i]=x;
}
// 枚举起始行中止行并更新答案
for(int i=1;i<n;i++)
    for(int j=i+1;j<=n;j++)
    {
        int len=0,l=0,r=0;
        memset(f,0,sizeof(f));
        for(int k=1;k<=m;k++)
        {
            if(str[i][k]!='.'||str[j][k]!='.') l=0;
            if(a[i][k]==a[j][k]&&a[i][k])
            {
                if(!l) l=k;
                else r=k,len=max(r-l+1,len);
            }
        }
        ans=max(ans,(j-i+1)*len);
    }
```
 - **作者：kczno1 (赞：10)  星级：4星**
    - **关键亮点**：同样采用$O(n^3)$的思路，先枚举矩形的两列确定一边长，再通过从上到下枚举行并利用dp确定另一边长的最大值。代码简洁，利用预先dp出每个点能联通的最左点和最上点来判断连通性，逻辑清晰。
```cpp
// 预处理每个点能联通的最左点和最上点
for(i=1;i<=n;++i)
for(j=1;j<=m;++j)
if(ch[i][j]=='.') { left[i][j]=(j==1)?1:left[i][j-1];up[i][j]=(i==1)?1:up[i-1][j]; }
else {left[i][j]=j+1;up[i][j]=i+1;}

// 枚举行并更新答案
for(i=1;i<=n;++i)
for(j=i;j<=n;++j)
{
    int mxlen=0,last=0;
    for(k=1;k<=m;++k) 
    if(up[j][k]<=i)
    {
        if(left[i][k]<=last&&left[j][k]<=last) chmax(mxlen,k-last+1);
        else last=k;
    }
    chmax(ans,(j-i+1)*mxlen);
}
```
 - **作者：_Blue_ (赞：1)  星级：4星**
    - **关键亮点**：先介绍最大子段和优化的原理，类比到本题。通过确定子矩形的上下边，利用查询上下点地图情况和每个点向上延伸最大距离判断能否构成矩形边框，代码实现中对各种情况处理细致，注释详细。
```cpp
// 预处理向上延伸的平地数量和标记沼泽
for(int i=1;i<=n;i++){
    char s[205];scanf("%s",s+1);
    for(int j=1;j<=m;j++){
        if(s[j]=='.')
            d[i][j]=d[i-1][j]+1; 
        else 
            a[i][j]=1;
    }
}
// 枚举上下边并更新答案
for(int i=1;i<n;i++)
    for(int j=i+1;j<=n;j++){
        int res=0;
        int h=j-i+1;
        for(int k=1;k<=m;k++){
            if(a[i][k]||a[j][k]) {
                res=0; 
                continue;
            }
            res++;
            if(res==1){
                if(d[j][k]>=h)  
                    continue;
                else 
                    res=0;
            }
            else{
                if(d[j][k]>=h)
                    ans=max(ans,res*h); 
                else
                    continue;
            }
        }
    }
```

### 最优关键思路或技巧
 - **$O(n^3)$ 枚举优化**：通过$O(n^2)$枚举起始行和终止行，将问题转化为在这两行之间寻找满足条件的列构成矩形，再以$O(m)$的复杂度处理列，从而将整体时间复杂度控制在$O(n^3)$。
 - **预处理优化**：预处理列的连通性（如潜翎题解）、每个点能联通的最左点和最上点（如kczno1题解）等信息，使得在枚举过程中能够快速判断能否构成矩形框架，减少不必要的计算。

### 可拓展之处
同类型题或类似算法套路常出现在寻找满足特定条件的最大子矩阵、子矩形等问题中。通常可利用枚举部分边界，结合预处理信息来优化复杂度。例如，对于一些限制条件在行列上的问题，都可尝试先固定行或列，再处理另一维度。

### 推荐题目
 - **P1719 最大子矩阵**：经典的最大子矩阵问题，与本题思路有一定关联，可锻炼对最大子矩阵类问题的处理能力。
 - **P4147 玉蟾宫**：涉及悬线法求最大子矩形，与本题部分题解中预处理的思路类似，有助于加深对这类问题的理解。
 - **P3941 入阵曲**：同样是在矩阵中寻找满足条件的子矩阵，可进一步巩固通过枚举行并优化列处理的算法技巧。 

---
处理用时：37.37秒
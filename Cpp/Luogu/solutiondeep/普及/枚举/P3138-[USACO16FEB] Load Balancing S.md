# 题目信息

# [USACO16FEB] Load Balancing S

## 题目背景

*本题与 [白金组同名题目](/problem/P6172) 在题意上一致，唯一的差别是数据范围。*

## 题目描述

Farmer John 的 $N$ 头奶牛（$1 \leq N \leq 1000$）散布在整个农场上。整个农场是一个无限大的二维平面，第 $i$ 头奶牛的坐标是 $(x_i,y_i)$（保证 $x_i,y_i$ 均为正奇数，且 $x_i,y_i \leq 10^6$），且没有任意两头奶牛在同一位置上。

FJ 希望修建一条竖直方向的栅栏，它的方程是 $x=a$，他还希望修建一条水平方向的栅栏，它的方程是 $y=b$。为了防止栅栏经过奶牛，$a,b$ 均要求是偶数。容易发现，这两个栅栏会在 $(a,b)$ 处相交，将整个农场分割为四个区域。

FJ 希望这四个区域内的奶牛数量较为均衡，尽量避免一个区域奶牛多而另一个区域奶牛少的情况。令 $M$ 为四个区域里奶牛最多区域的奶牛数量，请帮 FJ 求出 $M$ 的最小值。

## 样例 #1

### 输入

```
7
7 3
5 5
7 13
3 1
11 7
5 3
9 1```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：
    - 多数题解采用离散化结合二维前缀和的方法。由于奶牛坐标值大但点数有限，离散化将大坐标映射到小范围，再用二维前缀和快速计算各区域奶牛数量，通过枚举分割线位置求最大区域奶牛数的最小值。
    - 部分题解在离散化和二维前缀和基础上，采用不同数据结构或优化方式。如用线段树优化枚举过程，降低时间复杂度。
    - 整体看，离散化和二维前缀和是解决本题的核心思路，不同优化方向影响算法效率和代码复杂度。

所选的题解：
  - 作者：曹老师 (5星)
    - 关键亮点：思路清晰，先明确离散化处理坐标，再详细阐述二维前缀和预处理过程，最后给出计算四个象限奶牛数的表达式，代码简洁明了。
    - 重点代码及核心思想：
```cpp
//离散化 
for(int i=1;i<=n;i++)
{
    x[zx[i].num]=i;
    y[zy[i].num]=i;
}
//预处理部分 
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
        sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
//四个象限 
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
        ans=min(ans,max(max(sum[i][j],sum[i][n]-sum[i][j]),max(sum[n][j]-sum[i][j],sum[n][n]-sum[n][j]-sum[i][n]+sum[i][j])));
```
核心思想是先离散化坐标，然后利用二维前缀和公式计算每个位置左上方的奶牛总数，最后枚举分割线位置，通过特定公式计算四个象限奶牛数，取最大值中的最小值。

  - 作者：kczno1 (5星)
    - 关键亮点：提出更优的 \(nlogn\) 做法，从左到右枚举 \(x\) 的线，二分 \(y\) 的线，并通过维护线段树实现高效的二分查找，代码实现巧妙。
    - 重点代码及核心思想：
```cpp
void init(int *a)
{
    for(i=1;i<=n;++i)++a[d+py[i]];
    for(i=u+d>>1;i;--i) a[i]=a[cl]+a[cr];
}
void add(int *a,int i,int w)
{
    for(i+=d;i;i>>=1) a[i]+=w;
}
int erfen()
{
    i=1;
    int all=0,alr=0,arl=0,arr=0;
    while(i<=d)
    {
        int mxl=max(all+al[cl],arl+ar[cl]),mxr=max(alr+al[cr],arr+ar[cr]);
        if(mxl<=mxr) { all+=al[cl];arl+=ar[cl];i=cr; }
        else { alr+=al[cr];arr+=ar[cr];i=cl; }
    }
    int mxl=max(max(all+al[i],arl+ar[i]),max(all,arr)),
        mxr=max(max(alr+al[i],arr+al[i]),max(all,arl));
    return min(mxl,mxr); 
}
```
init函数初始化线段树，add函数在线段树上更新节点值，erfen函数实现线段树上的二分查找，通过比较左右区域的最大值来决定二分方向，最终返回最小的最大区域奶牛数。

  - 作者：xixike (4星)
    - 关键亮点：在阐述离散化和二维前缀和思路过程中，对离散化概念进行通俗解释，便于理解，代码结构清晰。
    - 重点代码及核心思想：
```cpp
//离散化
sort(pos+1,pos+n+1,cmp1);
for(int i=1;i<=n;i++)
    x[pos[i].id]=i;
sort(pos+1,pos+n+1,cmp2);
for(int i=1;i<=n;i++)
    y[pos[i].id]=i;
//二维前缀和
for(int i=1;i<=n;i++)//有奶牛的位置加1
    sum[x[i]][y[i]]++;
for(int i=1;i<=n;i++)//二维前缀和
    for(int j=1;j<=n;j++)
        sum[i][j]=sum[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
//枚举每一条竖线和横线，取最小值
int ans=1e9;
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
        ans=min(ans,calc(i,j));
```
先通过两次排序对坐标离散化，将原坐标映射为序号。接着初始化二维前缀和数组，记录每个位置左上方奶牛数。最后枚举所有可能的分割线位置，计算并更新最大区域奶牛数的最小值。

• 最优关键思路或技巧：
    - **离散化**：针对坐标值大但点数少的特点，将大坐标映射为小序号，降低数据规模，减少时间和空间复杂度。
    - **二维前缀和**：通过预处理，能在 \(O(1)\) 时间内计算特定区域的奶牛数量，提高枚举分割线位置时的计算效率。
    - **线段树优化**：如kczno1的题解，利用线段树维护数据结构，结合二分查找，优化枚举过程，降低时间复杂度到 \(nlogn\)。

• 可拓展之处：
同类型题常考察离散化、前缀和以及优化枚举过程。类似算法套路包括在处理大数据范围但数据量有限问题时使用离散化；对于区域求和问题，考虑前缀和（一维或多维）优化计算；在枚举过程中，通过数据结构（如线段树、树状数组）优化查找和更新操作。

• 相似知识点洛谷题目：
    - [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：涉及二维前缀和思想，通过预处理快速计算子矩阵元素和。
    - [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)：考察树状数组这一数据结构，与本题部分题解中利用线段树优化思路类似，用于高效的单点修改和区间查询。
    - [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)：需要用到离散化处理数据，结合树状数组或线段树解决区间不同元素个数问题。

• 个人心得：无 

---
处理用时：35.17秒
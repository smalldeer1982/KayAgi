# 题目信息

# [USACO17FEB] Why Did the Cow Cross the Road II S

## 题目描述

穿过 Farmer John 农场的长路上有 $N$ 个人行横道，方便地用编号 $1 \ldots N$ 标识（$1 \leq N \leq 100,000$）。为了让奶牛能够通过这些横道过马路，FJ 安装了电子过马路信号灯，当奶牛可以安全过马路时，信号灯会显示绿色的奶牛图标，否则显示红色。不幸的是，一场大雷暴损坏了他的一些信号灯。给定损坏信号灯的列表，请计算 FJ 需要修复的最少信号灯数量，以便存在至少 $K$ 个连续的信号灯正常工作。

## 样例 #1

### 输入

```
10 6 5
2
10
1
5
9```

### 输出

```
1```

# AI分析结果

• 综合分析与结论：
    - 思路：多数题解通过枚举长度为K的区间，计算每个区间内损坏信号灯数量，取最小值作为答案。
    - 算法要点：主要运用前缀和、队列模拟滑动窗口两种方法。前缀和方法通过预处理，在枚举区间时快速计算区间内损坏信号灯数量；队列模拟滑动窗口则通过在入队和出队操作时更新区间内损坏信号灯数量。
    - 解决难点：核心在于如何高效地计算每个长度为K的区间内损坏信号灯数量，避免暴力枚举导致的时间复杂度过高（O(NK)）。前缀和将时间复杂度优化到O(N)，队列模拟滑动窗口优化后同样为O(N)。

    - 评分：
        - Anguei：5星。思路清晰，代码简洁，利用前缀和优化，时间复杂度为O(N)，且使用快读快写，代码实现高效。
        - Drug__Lover：4星。同样采用前缀和方法，思路表述清晰，代码逻辑易懂，但相比Anguei少了快读快写优化。
        - 船医：4星。用队列模拟滑动窗口思路清晰，代码简洁，对队列操作解释详细，时间复杂度为O(N)。

  - Anguei（5星）：
    - 关键亮点：利用前缀和优化，将读入损坏信号灯数据预处理前缀和，在枚举区间时O(1)查询，时间复杂度O(N)，还使用快读快写优化输入输出。
    - 核心代码：
```cpp
// 代码里的 rep(i, a, b) 相当于 for (int i = a; i <= b; ++i)
// read() 和 println() 就是快读/快写
const int N = 100000 + 5;
int n, k, b, a[N], s[N], ans = -1u / 2; // -1u / 2 就是 int 最大值
int main() {
    n = read(), k = read(), b = read();
    rep(i, 1, b) a[read()] = 1;
    rep(i, 1, n) s[i] = s[i - 1] + a[i];
    rep(i, k, n) ans = std::min(ans, s[i] - s[i - k]);
    println(ans);
}
```
核心实现思想：将损坏信号灯位置设为1，未损坏设为0，读入数据时构建前缀和数组s，通过s[i] - s[i - k]快速得到长度为K区间内损坏信号灯数量，枚举所有长度为K区间取最小值。

  - Drug__Lover（4星）：
    - 关键亮点：清晰阐述前缀和思路，通过枚举区间左端点确定区间，利用前缀和计算区间内损坏信号灯数量，代码可读性强。
    - 核心代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#define maxn 100201
using namespace std;
int n,k,b;
int vis[maxn];
int sum[maxn];
int ans=0x7fffffff;
int main()
{
    cin>>n>>k>>b;
    for(int i=1;i<=b;i++)    
    {
        int x;
        scanf("%d",&x);
        vis[x]=1;
    }
    for(int i=1;i<=n;i++) sum[i]+=sum[i-1]+vis[i];
    for(int i=1;i<=n-k+1;i++) ans=min(ans,sum[i+k-1]-sum[i-1]);
    cout<<ans<<endl;
    return 0;
}
```
核心实现思想：与Anguei类似，读入损坏信号灯位置标记在vis数组，构建前缀和数组sum，通过sum[i + k - 1] - sum[i - 1]计算长度为K区间内损坏信号灯数量，枚举取最小值。

  - 船医（4星）：
    - 关键亮点：用队列模拟滑动窗口，在入队和出队时根据信号灯是否损坏更新当前区间内损坏信号灯数量，时间复杂度O(N)，思路独特且清晰。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
queue <int> q;//STL大法好
int n,k,b,ans=0,t;
bool d[100005];//是否损坏
int main (){
    cin>>n>>k>>b;
    for(int i=1;i<=b;i++)
    {
    	cin>>t;
    	d[t]=1;
	}
	for(int i=1;i<=k;i++)
	{
		q.push(i);
		if(d[i]==1)
		{
			ans++;
		}
	}//先进行初始化
	int sum=ans;//初始化sum
	for(int i=k+1;i<=n;i++)
	{
		
		q.push(i);
		if(d[i]==1)//如果损坏
		{
			sum++;
		}
		if(d[q.front()])//如果队头损坏，那么pop时sum就要减少
		sum--;
		q.pop();
		ans=min(ans,sum);
	}
	cout<<ans;
    return 0;
}
```
核心实现思想：先将前K个信号灯入队并统计损坏数量初始化ans和sum，之后每次将新信号灯入队，若损坏则sum++，同时检查队头信号灯，若损坏则sum--，每次更新ans为ans和sum的最小值。

• 最优关键思路或技巧：
    - 利用前缀和优化区间查询，通过预处理将区间内损坏信号灯数量查询时间复杂度降为O(1)。
    - 用队列模拟滑动窗口，在入队和出队时动态更新区间内损坏信号灯数量，避免重复计算，时间复杂度优化到O(N)。

• 可拓展思路：
此类题目属于固定长度区间最值问题，相似算法套路可应用于其他涉及固定区间统计、最值求解的场景。例如，在数组中求固定长度子数组的最大和、最小和等问题。

• 洛谷相似题目：
    - P1440 求m区间内的最小值
    - P1886 滑动窗口 /【模板】单调队列
    - P2216 [HAOI2007]理想的正方形

• 个人心得摘录与总结：
    - Countjoyyauldly：最初写的队列代码因全部进队、判断、出队导致时间复杂度高而TLE，后优化为只弹出队首、进队尾，不清空队列，成功AC。总结出不能盲目全部进队出队，要优化操作减少时间复杂度。 

---
处理用时：30.29秒
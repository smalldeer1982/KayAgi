# 题目信息

# 小 Y 拼木棒

## 题目背景

上道题中，小 Y 斩了一地的木棒，现在她想要将木棒拼起来。

## 题目描述

有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？

答案对 $10^9+7$ 取模。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 5 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，$1 \le a_i \le 5 \times 10^3$。

关于标题：因为一些不可抗力的原因，名称进行了更改。深表歉意。

## 样例 #1

### 输入

```
4 
1
1
2
2```

### 输出

```
1```

# AI分析结果

• 综合分析与结论：这些题解思路大致相同，均基于组合数学和暴力枚举。核心思路是利用数组计数（桶排序思想）记录各长度木棒数量，通过两层循环枚举，外层循环确定两根相等木棒长度，内层循环找出另外两根长度和与之相等的木棒，分两种情况（另两根木棒长度相等或不等）计算组合数并累加。解决难点在于优化暴力枚举，利用木棒长度范围限制时间复杂度在可接受范围。在代码实现上，有些题解对组合数计算进行了优化，有些在循环边界处理上更清晰。
- 作者：灵乌路空 (赞：298)  星级：5星
  - 关键亮点：思路阐述极为清晰，从分析题意到感性理解，逐步深入讲解算法原理，对内外层循环及两种情况讨论细致入微，代码注释详细，可读性强。
  - 个人心得：无
  - 核心代码：
```cpp
ll C(ll x, ll k) { 
  return (k == 1ll? x : x * (x - 1ll) / 2ll) % kMod;
}
int main() {
  scanf("%lld\n", &n);
  for (int i = 1; i <= n; ++ i) { 
    scanf("%lld", &a[i]); 
    maxa = max(a[i], maxa);
    num[a[i]] ++;
  }

  for (int i = 2; i <= maxa; ++ i) { 
    if (num[i] >= 2ll) {
      ll times = C(num[i], 2ll) % kMod; 
      for (int j = 1; j <= i / 2; ++ j) { 
        if (j!= i - j && num[j] >= 1 && num[i - j] >= 1) 
          ans += times * C(num[j], 1) * C(num[i - j], 1) % kMod;
        if (j == i - j && num[j] >= 2) 
          ans += times * C(num[j], 2) % kMod;
        ans %= kMod;
      }
    }
  }
  printf("%lld", ans);
  return 0;
}
```
  - 核心实现思想：先通过`C`函数计算组合数，读入数据时用`num`数组统计各长度木棒数量。外层循环枚举两根相等木棒长度`i`，若该长度木棒数量不少于2则计算其组合数`times`。内层循环枚举另一根木棒长度`j`到`i/2`，分`j!=i - j`和`j == i - j`两种情况更新答案`ans`，并随时取模。
- 作者：zhangziyi_xshsnoi (赞：67)  星级：4星
  - 关键亮点：先介绍组合数学相关知识，对组合数公式推导详细，代码简洁明了，核心代码部分对两种情况计算组合数的逻辑清晰。
  - 个人心得：无
  - 核心代码：
```cpp
for(int i=Min+1;i<=Max;i++)
	{
		if(num[i]>=2)
		{
			for(int j=Min;j<=i/2;j++)
			{
				if(j!=i-j)
					ans+=num[i]*(num[i]-1)*num[j]*num[i-j]/2%mod;
				else if(num[j]>=2&&j*2==i)
					ans+=num[i]*(num[i]-1)*num[i/2]*(num[i/2]-1)/4%mod;
			}
			ans%=mod;
		}
	}
```
  - 核心实现思想：外层循环从`Min + 1`到`Max`枚举两根相等木棒长度`i`，若该长度木棒数量不少于2，内层循环从`Min`到`i/2`枚举另一根木棒长度`j`，根据`j`与`i - j`是否相等分别计算组合数更新答案`ans`，并随时取模。
- 作者：RemiliaScar1et (赞：13)  星级：4星
  - 关键亮点：思路表述清晰，通过设变量明确木棒长度关系，代码使用带参宏定义简化组合数计算，且对`io`流解绑提高输入输出效率。
  - 个人心得：无
  - 核心代码：
```cpp
#define c1(a) (a) 
#define c2(a) ((a)*((a)-1)/2)
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int k;
		cin>>k;
		aaa[k]++;//往桶里扔
	}
	int ans=0;
	for(int a=2;a<=5000;a++)
   {
			for(int c=1;c<=a/2;c++)
			{
				int d=a-c;
				if(d!=c&&aaa[a]>=2&&aaa[c]>=1&&aaa[d]>=1)
				{
					ans+=((c2(aaa[a])%mode)*(c1(aaa[c])%mode)*(c1(aaa[d])%mode))%mode;
				}
				else if(d==c&&aaa[a]>=2&&aaa[c]>=2)
				{
					ans+=((c2(aaa[a])%mode)*(c2(aaa[c])%mode))%mode;
				}
				ans%=mode;
			}
	}
	cout<<ans%mode;
	return 0;
}
```
  - 核心实现思想：通过宏定义`c1`和`c2`分别表示从`n`个数选1个和选2个的组合数。读入数据时用`aaa`数组统计各长度木棒数量。外层循环从2到5000枚举两根相等木棒长度`a`，内层循环从1到`a/2`枚举另一根木棒长度`c`，计算`d = a - c`，根据`d`与`c`是否相等分别计算组合数更新答案`ans`，并随时取模。

• 最优关键思路或技巧：利用桶排序思想记录各长度木棒数量，通过合理的双层循环枚举并分情况计算组合数，同时在计算组合数时针对本题需求对公式进行化简，避免复杂运算，还可通过对`io`流解绑等方式优化代码效率。
• 同类型题或类似算法套路拓展：此类题目通常涉及在一定条件下从给定数据中选取特定组合，关键在于利用数据范围进行合理枚举和组合数计算。类似套路可应用于其他组合计数问题，如在满足特定条件下从多个集合中选取元素的方案数计算等。
• 推荐洛谷题目：
  - P1313 计算系数：考察组合数计算和多项式相关知识。
  - P2822 [NOIP2016 提高组] 组合数问题：结合组合数性质与取模运算。
  - P3197 [HNOI2008]越狱：利用组合数学思想解决排列组合问题。
• 个人心得摘录与总结：无。 

---
处理用时：39.36秒
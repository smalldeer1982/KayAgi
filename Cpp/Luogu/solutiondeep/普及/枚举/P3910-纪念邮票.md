# 题目信息

# 纪念邮票

## 题目描述

邮局最近推出了一套纪念邮票，这套邮票共有 $N$ 张，邮票面值各不相同，按编号顺序为 $1$ 分，$2$ 分，……，$N$ 分。

小明是个集邮爱好者，他很喜欢这套邮票，可惜现在他身上只有 $M$ 分，并不够把全套都买下，但是他希望刚好花光所有的钱。作为一个集邮爱好者，小明也不想买的邮票编号断断续续，所以小明打算买面值 $a$ 分至 $b$ 分的 $b-a+1$ 张连续的邮票，且总价值刚好为 $M$ 分。

你的任务是求出所有符合要求的方案，以 $\left[a,b\right]$ 的形式输出。

## 样例 #1

### 输入

```
20 15```

### 输出

```
[1,5]
[4,6]
[7,8]
[15,15]```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是基于等差数列求和公式来求解满足条件的区间。题目难点在于数据范围较大，$O(n)$或$O(m)$的暴力算法会超时，需要优化算法。多数题解通过数学推导，将问题转化为枚举$2m$的因数，且只需枚举不超过$\sqrt{2m}$的数，从而将时间复杂度优化到$O(\sqrt{m})$。

### 所选的题解
1. **作者：佑月之星 (4星)**
    - **关键亮点**：详细阐述了从暴力到优化的思考过程，通过数学推导将双变量问题转化为单变量枚举问题，代码实现清晰。
    - **个人心得**：一开始使用三重循环、双重循环均超时，后通过纸笔推导公式优化算法，但仍有部分测试点TLE，最终得知需将查找范围缩小至$\sqrt{2m}$。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n;
int main()
{
    cin>>n>>m;
    for(int i=sqrt(2*m);i>=1;i--)
    {
        if((2*m)%i!=0)continue;
        if(((2*m/i)-i+1)%2!=0)continue;
        int a=((2*m/i)-i+1)/2;
        if(a<1)continue;
        if(a+i-1>n)continue;
        cout<<"["<<a<<","<<a+i-1<<"]"<<endl;
    }   
    return 0;    
}
```
    - **核心思想**：枚举长度$i$（$i$为$2m$的因数且$i\leq\sqrt{2m}$），通过公式计算出首项$a$，判断$a$是否合法以及区间是否在$[1,n]$内，若合法则输出区间。
2. **作者：SqrtSecond (4星)**
    - **关键亮点**：简洁明了地阐述思路，从等差数列求和公式出发，快速推导出优化后的枚举方式，代码简洁高效。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
int n,m,sum;
int main()
{
    scanf("%d%d",&n,&m);
    m*=2;
    for(int i=sqrt(m);i;--i)
    {
        if(m%i)continue;
        sum=m/i;
        if((sum-i+1)&1||(sum+i-1)/2>n)continue; 
        printf("[%d,%d]\n",(sum-i+1)/2,(sum+i-1)/2);
    }
    return 0;
}
```
    - **核心思想**：提前将$m$乘$2$，枚举不超过$\sqrt{m}$的数$i$作为项数，若$m$能被$i$整除则计算首项末项之和$sum$，判断首项末项是否符合规范后输出区间。
3. **作者：Yujinhe469 (4星)**
    - **关键亮点**：清晰地阐述题意和推导过程，对数据范围的分析到位，代码简洁且有注释提醒数据类型。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m;
int main(){
    cin>>n>>m;
    m*=2;
    for(ll y=sqrt(m);y>=1;y--){
        if(m%y!=0) continue;
        ll x=m/y;
        if((x-y+1)%2==1) continue;
        ll a=(x-y+1)/2,b=(x+y-1)/2;
        if(a<1||a>n||b<1||b>n) continue;
        cout<<"["<<a<<","<<b<<"]"<<endl;
    }
    return 0;
}
```
    - **核心思想**：令$x = a + b$，$y = b - a + 1$，枚举不超过$\sqrt{2m}$的$y$，若$2m$能被$y$整除则计算$x$，进而得到$a$和$b$，判断$a$和$b$是否合法后输出区间。

### 最优关键思路或技巧
利用等差数列求和公式$m = \frac{(a + b)(b - a + 1)}{2}$，将其变形为$2m = (a + b)(b - a + 1)$，通过数学推导发现只需枚举不超过$\sqrt{2m}$的数作为其中一个因数，进而计算出另一个因数，再根据因数计算出区间的首项和末项，判断区间是否合法。这种通过数学优化算法，将原本可能的高时间复杂度暴力枚举转化为低时间复杂度的因数枚举的方法是解题关键。

### 可拓展之处
此类题目属于数学推导优化暴力枚举类型。类似套路如在一些求连续子序列满足特定和或积等问题中，可尝试通过数学公式建立变量关系，分析因数、倍数等特性，优化枚举范围。例如，给定一个数组，求连续子数组的和等于特定值，可类比此方法，先建立和与子数组首末位置的关系，再通过数学分析优化查找过程。

### 推荐洛谷题目
1. **P1147 连续自然数和**：同样是求连续自然数相加和为给定值的问题，与本题类似，考察对连续序列求和公式的运用和算法优化。
2. **P2669 金币**：涉及到按一定规律递增的数列求和问题，可通过类似的数学分析和枚举优化来解决。
3. **P1306 斐波那契公约数**：虽然是关于斐波那契数列的公约数问题，但在解决过程中也需要利用数列的性质进行数学推导和优化，与本题通过数学优化算法的思路类似。 

---
处理用时：30.79秒
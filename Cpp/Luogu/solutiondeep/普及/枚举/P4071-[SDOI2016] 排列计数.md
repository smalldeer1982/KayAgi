# 题目信息

# [SDOI2016] 排列计数

## 题目描述

求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。

答案对 $10^9 + 7$ 取模。

## 说明/提示

#### 数据规模与约定

本题共 20 个测试点，各测试点等分，其数据规模如下表。

| 测试点编号 | $T =$  | $n, m \leq$ |  测试点编号  |      $T =$      | $n, m \leq$ |
| :--------: | :----: | :---------: | :----------: | :-------------: | :---------: |
| $1\sim 3$  | $10^3$ |     $8$     | $10 \sim 12$ |     $10^3$      |   $10^3$    |
| $4 \sim 6$ | $10^3$ |    $12$     | $13 \sim 14$ | $5 \times 10^5$ |   $10^3$    |
| $7 \sim 9$ | $10^3$ |    $100$    | $15 \sim 20$ | $5 \times 10^5$ |   $10^6$    |

对于全部的测试点，保证 $1 \leq T \leq 5 \times 10^5$，$1 \leq n \leq 10^6$，$0 \leq m \leq 10^6$。

## 样例 #1

### 输入

```
5
1 0
1 1
5 2
100 50
10000 5000```

### 输出

```
0
1
20
578028887
60695423```

# AI分析结果

• 综合分析与结论：
    - 思路：这些题解均将问题拆分为两部分，先从\(n\)个数中选\(m\)个数放在其对应位置，组合数为\(C_n^m\)，再求剩下\(n - m\)个数的错排数，最后将两者相乘得到答案。
    - 算法要点：需掌握组合数与错排数的计算。组合数通过预处理阶乘和逆元来计算，错排数利用递推公式\(D_n=(n - 1)(D_{n - 1}+D_{n - 2})\)（\(D_1 = 0\)，\(D_2 = 1\)）递推得出。
    - 解决难点：由于\(n\)、\(m\)数据范围大且有取模运算，计算组合数时除法取模需用逆元解决，同时为避免重复计算，需预处理阶乘、逆元及错排数。
    - 整体来看，各题解思路相似，主要差异在于代码实现细节、思路阐述清晰度及代码可读性。

所选的题解：
  - 作者：冒泡ioa (赞：90)  星级：4星
    - 关键亮点：思路阐述详细，从找规律入手引导读者理解组合数与错排数概念，代码简洁明了，对关键步骤有注释。
    - 个人心得：无
    - 重点代码及核心实现思想：
```cpp
// 快速幂求a的b次方
ll qpow(ll a,ll b){
    ll ans=1;
    while(b){
        if(b&1)ans=a*ans%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ans;
}
// 预处理阶乘、逆元、错排数
void prework(){
    f[0]=1;
    for(int i=1;i<MAXN;i++){
        f[i]=f[i-1]*i%mod;
        inv[i]=qpow(f[i],mod-2);
    }
    d[1]=0,d[2]=1,d[3]=2;
    for(int i=4;i<MAXN;i++){
        d[i]=(i-1)*(d[i-1]+d[i-2])%mod;
    }
}
int main(){
    cin>>t;
    prework();
    for(int i=1;i<=t;i++){
        ll n,m;
        scanf("%lld%lld",&n,&m);
        if (n - m == 1) printf("0\n");
        else if (m == n) printf("1\n");
        else if (m == 0) printf("%lld\n",d[n]);
        else {
            printf("%lld\n",f[n] * inv[m] % mod * inv[n-m] % mod * d[n-m] % mod);
        }
    }
    return 0;
}
```
核心实现思想：通过`qpow`函数实现快速幂求逆元，`prework`函数预处理阶乘、逆元及错排数，`main`函数根据不同条件计算并输出结果。

  - 作者：K2sen (赞：26)  星级：4星
    - 关键亮点：对题意、思路及涉及的错排、Lucas定理、逆元等知识点解释全面，代码规范且有详细注释，对各部分功能说明清晰。
    - 个人心得：无
    - 重点代码及核心实现思想：
```cpp
// 快速幂求a的b次方
ll q_pow(ll a,ll b) {
    ll ans = 1;
    while (b) {
        if (b & 1) ans = (ans * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return ans;
}
// 计算组合数
ll c(ll a,ll b) {
    return (jc[a] % mod * q_pow(jc[b] * jc[a - b] % mod, mod - 2) % mod) % mod;
}
// Lucas定理求组合数
ll lucas(ll a,ll b) {
    if (!b) return 1;
    else return (lucas(a / mod, b / mod) * c(a % mod, b % mod)) % mod;
}
int main() {
    t = read();
    f[1] = 0, f[2] = 1, jc[1] = 1, jc[2] = 2;
    for (ll i = 3; i <= 1000000; i++)
        f[i] = ((i - 1) * (f[i - 1] + f[i - 2]) % mod) % mod, jc[i] = (jc[i - 1] * i) % mod;
    while (t--) {
        n = read(), m = read();
        if (n == m) puts("1");
        else if (n - m == 1) printf("0\n");
        else if (m == 0) printf("%lld\n",f[n]);
        else {
            ll ans = (f[n - m] % mod * lucas(n, m)) % mod;
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```
核心实现思想：通过`q_pow`函数实现快速幂，`c`函数计算组合数，`lucas`函数利用Lucas定理求组合数，`main`函数预处理错排数和阶乘，根据不同条件计算并输出结果。

  - 作者：lemir3 (赞：15)  星级：4星
    - 关键亮点：对涉及的错排问题定义及公式来源有清晰说明，代码实现中函数命名规范，逻辑清晰，对特殊情况有特判处理。
    - 个人心得：无
    - 重点代码及核心实现思想：
```cpp
// 快速幂求a的b次方对mod取模
inline lxl FastPow(lxl a,lxl b,lxl mod){
    lxl sum=1;
    for(;b;b>>=1,a=a*a%mod)(b&1)&&(sum=sum*a%mod);
    return sum;
}
// 求a在模p下的逆元
inline lxl inv(lxl a,lxl p){
    return FastPow(a,p-2,p); 
}
// 计算组合数
inline lxl C(lxl n,lxl m,lxl p){
    return (cm[n]*inv(cm[m]*cm[n-m]%p,p)%p);
}
// Lucas定理求组合数
lxl Lucas(lxl n,lxl m,lxl p){
    if(m==0)return 1;
    return C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;
}
// 预处理错排数和阶乘
inline void prework()
{
    d[1]=0,d[2]=1,cm[1]=1,cm[2]=2;
    for(R int i(3);i<maxn;++i)d[i]=(i-1)*(d[i-1]+d[i-2])%p,cm[i]=cm[i-1]*i%p;
}
int main(void)
{
    prework();
    T=read();
    while(T--)
    {   
        n=read(),m=read();
        if(m==n)
        {
            printf("1\n");
            continue;
        }
        printf("%lld\n",Lucas(n,m,p)*d[n-m]%p);
    }
    return 0;
}
```
核心实现思想：通过`FastPow`函数实现快速幂，`inv`函数求逆元，`C`函数计算组合数，`Lucas`函数利用Lucas定理求组合数，`prework`函数预处理错排数和阶乘，`main`函数根据不同条件计算并输出结果。

最优的关键思路或技巧：
 - 思维方式：将原问题拆分为组合数计算和错排数计算两部分，简化问题求解过程。
 - 算法优化：通过预处理阶乘、逆元及错排数，将每次查询时间复杂度降为\(O(1)\)，提高效率。
 - 代码实现技巧：利用快速幂求逆元，简洁高效，同时对特殊情况（如\(n = m\)，\(n - m = 1\)，\(m = 0\)）进行特判，减少不必要计算。

可拓展之处：同类型题常考察对组合数学中各种排列组合概念及公式的运用，类似算法套路为将复杂排列问题分解为基本的组合、错排等子问题，再结合取模运算、逆元等知识求解。

推荐题目：
 - P1595 [信封问题](https://www.luogu.com.cn/problem/P1595)：经典错排问题，可作为本题错排部分的基础练习。
 - P3807 【模板】卢卡斯定理：考察Lucas定理在组合数计算中的应用，与本题组合数计算知识点相关。
 - P3811 【模板】乘法逆元：专注于逆元计算，有助于深入理解本题中逆元的应用。

个人心得摘录及总结：无。 

---
处理用时：49.49秒
# 题目信息

# [USACO17DEC] My Cow Ate My Homework S

## 题目描述

在你的牛历史课上，你被布置了一份相当长的作业，包含 $N$ 个问题（$3 \leq N \leq 100,000$），每个问题的得分是一个在 0 到 10,000 之间的整数。按照惯例，你的老师计划通过去掉你得分最低的一个问题，然后对剩余问题的得分取平均来给出最终成绩。不幸的是，你的宠物奶牛 Bessie 刚刚吃掉了你前 $K$ 个问题的答案！（$K$ 可能小到 1，也可能大到 $N-2$）。

经过多次解释，你的老师终于相信了你的说法，并同意按照之前的方式对剩余的未被吃掉的部分作业进行评分——即去掉得分最低的问题（或在得分相同的情况下去掉其中一个），然后对剩余问题取平均。

请输出所有能够使你获得最高可能成绩的 $K$ 值，并按升序排列。

## 说明/提示

如果 Bessie 吃掉了前两个问题，那么剩余的得分是 9、2 和 7。去掉最低分并取平均后，最终成绩为 8，这是可能的最高成绩。

## 样例 #1

### 输入

```
5
3 1 9 2 7```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何高效求解在去掉前\(k\)个问题及剩余问题中最小值后，能使平均成绩最大的\(k\)值。思路上，多数题解采用枚举\(k\)值，结合前缀和或后缀和求区间和，以及用不同方式求区间最小值的方法。算法要点包括前缀和计算、区间最小值维护、平均值计算与比较。解决难点在于优化时间复杂度，避免暴力解法的\(O(n^2)\)甚至\(O(n^3)\)复杂度。部分题解使用线段树、单调栈等数据结构优化，部分通过预处理区间和与最小值来优化。

  依据质量，以下为各题解评分：
  - _jimmywang_：5星，思路清晰，详细阐述每个步骤优化过程，代码简洁明了，通过预处理区间最小值和区间和，将时间复杂度优化到\(O(n)\)。
  - Siyuan：4星，利用前缀和思想递推求解，代码注释详细，逻辑清晰，但优化程度略逊于_jimmywang_。
  - TRZ_2007：4星，同样利用前缀和与后缀最小值，代码简洁，考虑了精度问题，时间复杂度为\(O(n)\)。
  - SuperJvRuo：3星，思路常规，代码实现中规中矩，虽注意实数运算精度，但整体优化和阐述不如前三者。
  - Diamiko：3星，使用线段树维护区间和与最小值，思路较清晰，但代码相对复杂，未突出线段树在此题中的独特优势。
  - philosopherchang：3星，暴力结合前缀和与预处理最小值，部分细节处理不当（如数据类型使用），导致WA点。
  - AveMarina：3星，结合线段树与前缀和，代码较冗长，对线段树的使用未充分优化。
  - 大头冲锋车丶：3星，线段树应用思路正确，但代码实现细节较多，整体质量一般。
  - B_1168：2星，采用分块算法，复杂度较高，代码冗长且未充分发挥分块优势。
  - Mkarry：2星，使用集合操作，思路独特但效率不高，代码实现未充分优化。
  - Na2PtCl6：3星，线段树做法较常规，代码结构清晰，但对精度处理的阐述不够深入。
  - 封禁用户：3星，尝试用单调栈优化，但代码逻辑较复杂，对单调栈的使用未充分体现优势。
  - 曹老师：3星，线段树做法，代码实现较常规，对时间复杂度分析不准确。

  所选的题解：
  - 题解1（_jimmywang_，5星）
    - 关键亮点：详细分析每个步骤的优化过程，通过一行代码巧妙预处理区间最小值和区间和，将求最小值和平均值的时间复杂度降为\(O(1)\)，整体时间复杂度\(O(n)\)。
    - 个人心得：无
    - 重点代码（核心实现思想：预处理区间最小值、区间和，计算平均值并找出最大值对应的\(k\)值）：
```cpp
for(int i=n;i>=2;i--)mn[i]=min(mn[i+1],a[i]),sum[i]=sum[i+1]+a[i];
for(int i=n;i>=2;i--){
    if(i!=n)avr[i]=(sum[i]-mn[i])/(double)(n-i);
}
f(i,2,n-1)mx=max(mx,avr[i]);
f(i,2,n-1)if(mx==avr[i])printf("%lld\n",i-1);
```
  - 题解2（Siyuan，4星）
    - 关键亮点：利用前缀和思想，在枚举区间时递推求出最优解，代码注释详细，逻辑清晰。
    - 个人心得：无
    - 重点代码（核心实现思想：枚举区间左界，更新区间最小值和总和，比较平均成绩并记录\(k\)值）：
```cpp
mins=s[n];  sum=s[n];
rep2(i,n-1,2) {
    mins=min(mins,s[i]);
    sum+=s[i];
    if((sum-mins)/(double)(n-i)>aver) {
        cnr=1;
        k[cnr]=i-1;
        aver=(sum-mins)/(double)(n-i);
    }else  if((sum-mins)/(double)(n-i)==aver)
        k[++cnr]=i-1;
}
rep2(i,cnr,1)  printf("%d\n",k[i]);
```
  - 题解3（TRZ_2007，4星）
    - 关键亮点：利用前缀和与后缀最小值，代码简洁，考虑精度问题，时间复杂度为\(O(n)\)。
    - 个人心得：无
    - 重点代码（核心实现思想：计算前缀和与后缀最小值，枚举\(k\)值计算平均成绩并找出最大值及对应\(k\)值）：
```cpp
for(int i = 1;i <= n;i++) {
    read(a[i]);
    sum[i] = sum[i - 1] + a[i];
}
for(int i = n;i >= 1;i--) {
    Min[i] = min(Min[i + 1],a[i]);
}
for(int i = 1;i <= n - 2;i++) {
    Score = (sum[n] - sum[i] - Min[i]) * 1.0 / (n - i - 1);
    if(Score - Max >= eps) {
        Max = Score;
    }
}
for(int i = 1;i <= n - 2;i++) {
    Score = (sum[n] - sum[i] - Min[i]) * 1.0 / (n - i - 1);
    if(fabs(Score - Max) < eps) printf("%d\n",i);
}
```
• 最优的关键思路或技巧：预处理区间和与最小值是优化的关键，可将时间复杂度从暴力的\(O(n^2)\)或\(O(n^3)\)降至\(O(n)\)。如_jimmywang_通过倒序遍历一次完成区间最小值和区间和的预处理，后续计算平均值时直接使用，大大提高效率。

• 可拓展之处：同类型题常考察对区间和、区间最值的维护与计算，类似算法套路包括利用前缀和、后缀和、单调栈、线段树、ST表等数据结构优化时间复杂度。例如，当数据有动态修改时，线段树会更具优势；若仅为静态数据，前缀和与预处理最值的方法更简洁高效。

• 推荐题目：
  - P3372 【模板】线段树 1：基础线段树题目，考察线段树的基本操作，如建树、查询、修改。
  - P1880 [NOI1995] 石子合并：可使用区间DP结合前缀和优化，与本题在区间处理上有相似思路。
  - P2882 [USACO07MAR]Face The Right Way G：可通过前缀和思想优化暴力枚举，类似本题对区间信息的预处理与利用。

• 个人心得摘录与总结：
  - 封禁用户：调试时发现计算平均值时\(n - k - 1\)的含义容易出错，需注意元素个数的准确计算。总结为在处理涉及数据范围和元素个数的计算时要格外小心，避免因理解偏差导致错误。 

---
处理用时：46.90秒
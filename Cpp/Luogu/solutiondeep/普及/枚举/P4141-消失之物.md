# 题目信息

# 消失之物

## 题目描述

ftiasch 有 $n$ 个物品, 体积分别是 $w_1,w_2,\dots,w_n$。由于她的疏忽，第 $i$ 个物品丢失了。   

“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。  

她把答案记为 $\text{cnt}(i,x)$ ，想要得到所有$i \in [1,n]$, $x \in [1,m]$ 的 $\text{cnt}(i,x)$ 表格。

![](https://cdn.luogu.com.cn/upload/pic/13426.png)


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n,m \le 2000$，且 $1\le v_i\le m$。

【样例解释】  
如果物品 3 丢失的话，只有一种方法装满容量是 2 的背包，即选择物品 1 和物品 2。

---

$\text{upd 2023.8.11}$：新增加五组 Hack 数据。


## 样例 #1

### 输入

```
3 2
1 1 2```

### 输出

```
11
11
21```

# AI分析结果

• 综合分析与结论：这些题解的核心思路均是先通过一次01背包求出所有物品都在时装满不同容积背包的方案数，再通过逆向思维，减去当前物品对方案数的贡献，得到缺少该物品时的方案数。算法要点在于01背包的实现以及对去掉某物品后方案数调整的理解。解决难点在于理解去掉物品后如何准确地从总方案数中减去该物品的贡献，且要注意防止计算过程中出现负数取模的情况。各题解思路相近，质量差异主要体现在思路清晰度、代码可读性及对关键步骤的解释上。

所选的题解：
  - **作者：Kelin (赞：132)  星级：5星**
    - **关键亮点**：思路清晰简洁，直接点明少了某个物品就是在原来01背包转移基础上减去一次转移，代码实现精炼。
    - **重点代码及核心思想**：
```cpp
// 先进行01背包
for(int j=m;j>=w[i];--j)
    f[j]+=f[j-w[i]];
// 减去第i个物品的贡献
memcpy(g,f,sizeof f);
for(int j=w[i];j<=m;++j)
    g[j]-=g[j-w[i]];
```
核心思想是先通过01背包求出所有物品都在时的方案数f数组，再通过顺推从f数组得到去掉第i个物品后的方案数g数组。
  - **作者：King丨帝御威 (赞：61)  星级：4星**
    - **关键亮点**：代码实现完整，对01背包和去掉物品后的方案数计算分别用不同数组表示，逻辑清晰，对转移方程有详细注释。
    - **重点代码及核心思想**：
```cpp
// 初始化
f[0][0]=f[0][1]=1;
// 01背包转移
for(int i=1;i<=n;++i)
{
    for(int j=m;j>=v[i];--j)
    {
        f[j][0]+=f[j-v[i]][0];
        f[j][0]%=10;
    }
}
// 去掉物品后的方案数计算
for(int i=1;i<=n;++i)
{
    for(int j=1;j<=m;j++)
    {
        if(j-v[i]>=0) f[j][1]=(f[j][0]-f[j-v[i]][1]+10)%10;
        else f[j][1]=f[j][0]%10;
        cout<<f[j][1];
    }
    cout<<'\n';
}
```
核心思想是用f[][0]表示所有物品都在时的方案数，通过01背包转移得到，再通过f[][0]和f[][1]的关系，计算去掉物品后的方案数f[][1]。
  - **作者：Gary818 (赞：35)  星级：4星**
    - **关键亮点**：对数组定义清晰，对思路“总的方案数 - 选当前物品的方案数 = 不选当前物品的方案数”阐述明确，代码简洁易懂。
    - **重点代码及核心思想**：
```cpp
// 01背包
f[0]=1;
for(int i=1;i<=n;i++)
    for(int j=m;j>=w[i];j--)
        f[j]=(f[j]+f[j-w[i]])%10;
// 计算不选第i个物品的方案数
for(int i=1;i<=n;i++){
    g[0]=1;
    for(int x=1;x<=m;x++){
        if(w[i]>x) g[x]=f[x]%10;
        else g[x]=(f[x]-g[x-w[i]]+10)%10;
        cout<<g[x];
    }
    cout<<endl;
}
```
核心思想是先通过01背包得到总方案数f数组，再通过循环计算去掉第i个物品后的方案数g数组。

**最优关键思路或技巧**：先利用01背包计算所有物品都在时的方案数，再通过逆向思维，从总方案数中减去当前物品的贡献，得到缺少该物品时的方案数。在计算过程中，要注意防止出现负数取模的情况。

**可拓展之处**：同类型题可拓展到其他背包计数问题，类似算法套路是先计算总体情况，再根据条件调整方案数。

**推荐题目**：
  - P1048 [NOIP2005 普及组] 采药
  - P1616 疯狂的采药
  - P2602 [ZJOI2010] 数字计数

**个人心得摘录与总结**：部分题解提到在计算去掉物品后的方案数时，要注意防止出现负数取模的情况，否则会导致结果错误，如“这里一定要+10,防止负数，我亲测不+10会只有10分……” ，总结为在涉及取模运算的背包问题中，要特别注意边界情况，尤其是可能出现负数的情况，需进行特殊处理以保证结果正确。 

---
处理用时：24.89秒
# 题目信息

# [Code+#4] 喵呜

## 题目描述

在马路边有一排整齐的 $n$ 棵樱花树，每棵树的高度都恰好为 $h$。某天，一只可爱的小猫偶然跑到树上来玩，但是这只小猫有些对樱花过敏，所以她现在想赶快离开这些樱花树。

具体来说，现在小猫位于第 $x$ 棵樱花树上高度为 $y$ 的位置，她可以通过两种跳跃来离开樱花树：

轻轻跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度下降 $b$，即一次轻轻跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y-b$ 的位置，注意当小猫所在高度不大于 $b$ 时不可以使用轻轻跳。

使劲跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度上升 $b$，即一次使劲跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y+b$ 的位置，注意当小猫所在高度大于 $h-b$ 时不可以使用使劲跳。

为了离开这片樱花树，小猫需要移动到第 $1$ 或第 $n$ 棵树上，高度为 $h$ 或 $1$ 的位置（这样她可以呼吸新鲜空气或者直接走开樱花树）。现在小猫想知道，自己最少需要多少次跳跃才能达成目标。由于她是一只可爱的小猫，所以希望由你来告诉她。


## 说明/提示

| 测试点编号 | $n,h$ 的范围 | 特殊约定 |
| :----------: | :----------: | :----------: |
|$1,2$  | $\le10$ | $b=1$ |
|$3,4$  |  $\le10$| $a=b=1$ |
|$5,6,7,8$  |$\le10$  | 无 |
|$9,10$  | $\le500$ | $b=1$ |
|  $11,12$| $\le500$ | $a=b=1$ |
|$13,14,15$  | $\le500$ | 无 |
|$16,17$  | $\le10^5$ | $h\le10$ |
|$18,19,20$  | $\le10^5$ | 无 |
| $21,22$ | $\le10^{15}$ | $h\le10$ |
| $23,24,25$ | $\le10^{15}$ | 无 |

对于所有数据，保证 $n \geq 2$，$a < n$，$b \leq h$。

Credit: https://www.luogu.org/discuss/show/38908

## 样例 #1

### 输入

```
3
5 5 3 3 2 2
5 7 3 5 2 2
5 7 4 6 1 1```

### 输出

```
1
1
1```

## 样例 #2

### 输入

```
3
5 5 3 3 3 2
5 7 1 4 2 2
5 7 1 2 1 2```

### 输出

```
-1
-1
-1```

## 样例 #3

### 输入

```
4
999999999999 999999999999 454545454545 454545454545 1 1
777777777777 777777777777 343434343434 343434343434 1 1
777777777777 999999999999 343434343434 454545454545 1 1
999999999999 777777777777 454545454545 343434343434 1 1```

### 输出

```
454545454544
343434343433
-1
-1```

# AI分析结果

• 综合分析与结论：这些题解思路相近，均意识到该题需结合数学分析求解。核心思路为判断从起始点到四个目标点（四角）能否到达及所需最少步数。判断能否到达需满足两个条件：一是初始坐标与目标坐标横、纵坐标之差分别为a、b的整数倍；二是到达目标横、纵坐标所需步数差为偶数。计算步数时，对每个方向取横、纵坐标步数的最大值，再取四个方向的最小值。各题解在思路阐述清晰度、代码可读性及优化程度上有差异。
• 所选的题解：
  - **作者：liangledong（4星）**
    - **关键亮点**：思路清晰，先介绍暴力、宽搜等部分得分思路，再着重讲解正解。对正解中满足到达目标坐标的条件分析细致，代码实现简洁明了。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,n,h,x,y,a,b,ans;
int main(){
    cin>>T;
    while(T--){
        cin>>n>>h>>x>>y>>a>>b;
        if((x==1&&y==h)||(x==1&&y==1)||(x==n&&y==h)||(x==n&&y==1)){
            cout<<"0\n";
            continue;
        }
        if(x-a<1&&x+a>n){
            cout<<"-1\n";
            continue;
        }
        ans=1e18;
        if((x-1)%a==0&&(h-y)%b==0){
            if(((x-1)/a-(h-y)/b)%2==0)ans=min(ans,max((x-1)/a,(h-y)/b));
        }
        if((x-1)%a==0&&(y-1)%b==0){
            if(((x-1)/a-(y-1)/b)%2==0)ans=min(ans,max((x-1)/a,(y-1)/b));
        }
        if((n-x)%a==0&&(h-y)%b==0){
            if(((n-x)/a-(h-y)/b)%2==0)ans=min(ans,max((n-x)/a,(h-y)/b));
        }
        if((n-x)%a==0&&(y-1)%b==0){
            if(((n-x)/a-(y-1)/b)%2==0)ans=min(ans,max((n-x)/a,(y-1)/b));
        }
        if(ans==1e18)cout<<"-1\n";
        else cout<<ans<<"\n";
    }
    return 0;
}
```
    - **核心实现思想**：先判断初始位置是否为目标位置，若不能移动则输出 -1 。初始化最小步数为极大值，对四个目标角分别判断是否满足到达条件一（横纵坐标差为a、b整数倍）和条件二（步数差为偶数），若满足则更新最小步数，最后根据最小步数是否更新输出结果。
  - **作者：wunaidedanjuan（4星）**
    - **关键亮点**：对题意简化清晰，思路分析详细，先分别考虑横纵坐标移动判断能否到达边界及计算步数，再综合考虑横纵坐标一起移动时到达顶点的条件，逻辑连贯，代码注释详细。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<ctime>
#include<queue>
#include<map>
#include<queue>
#include<stack>
#include<vector>
#include<string>
#include<bitset>
#include<cctype>
#include<cstdlib>
#include<functional>
#include<istream>
#include<sstream>
#define int long long 
using namespace std;
const int N=1000010,inf=0x3f3f3f3ff3f3f3f,mod=pow(2,31);
signed main()
{
    int t,n,h,x,y,a,b;
    scanf("%lld",&t);
    while(t--)
    {
        int l=-1,r=-1,u=-1,d=-1,ans=inf;
        scanf("%lld%lld%lld%lld%lld%lld",&n,&h,&x,&y,&a,&b);
        if((x-1)%a==0)
            l=(x-1)/a;
        if((n-x)%a==0)
            r=(n-x)/a;
        if((h-y)%b==0)
            u=(h-y)/b;
        if((y-1)%b==0)
            d=(y-1)/b;
        if((l==-1&&r==-1)||(u==-1&&d==-1))
        {
            printf("-1\n");
            continue;
        }
        if(u!=-1&&l!=-1&&abs(u-l)%2==0)
            ans=min(ans,max(l,u));
        if(u!=-1&&r!=-1&&abs(u-r)%2==0)
            ans=min(ans,max(r,u)); 
        if(d!=-1&&r!=-1&&abs(d-r)%2==0)
            ans=min(ans,max(r,d)); 
        if(d!=-1&&l!=-1&&abs(d-l)%2==0)
            ans=min(ans,max(l,d));
        if(ans==inf)
            printf("-1\n");
        else
            printf("%lld\n",ans);
    }
    return 0;
}
```
    - **核心实现思想**：记录到达左右上下边界所需最小移动次数，若无法到达设为 -1 。先根据能否到达边界初步判断是否有解，再对四个角分别判断相邻方向所需移动次数差值是否为偶数，若为偶数则更新最小步数，最后输出结果。
  - **作者：Moon_Traveller（4星）**
    - **关键亮点**：将问题分解为能否走和需要走几步两个小问题，针对四个行进方向分别考虑，思路明确，代码简洁且注释详细。
    - **核心代码**：
```cpp
#include <iostream>
using namespace std;
#define int long long

int T;
int n, h, x, y, a, b;
int u, d, l, r; 
int minn = 1e14;
bool flag;

signed main()
{
    cin >> T;
    while(T--)
    {
        cin >> n >> h >> x >> y >> a >> b;
        minn = 1e14; 
        flag = false; 

        if((h - y) % b == 0) 
            u = (h - y) / b; 
        else
            u = -1; 
        if((y - 1) % b == 0) 
            d = (y - 1) / b; 
        else
            d = -1;
        if((n - x) % a == 0) 
        {
            r = (n - x) / a; 
            if(u!= -1 && abs(u - r) % 2 == 0) 
            {
                minn = min(minn, max(u, r)); 
                flag = true; 
            }
            if(d!= -1 && abs(d - r) % 2 == 0) 
            {
                minn = min(minn, max(d, r));
                flag = true;
            }
        }
        if((x - 1) % a == 0) 
        {
            l = (x - 1) / a;
            if(u!= -1 && abs(u - l) % 2 == 0) 
            {
                minn = min(minn, max(u, l));
                flag = true;
            }
            if(d!= -1 && abs(d - l) % 2 == 0) 
            {
                minn = min(minn, max(d, l));
                flag = true;
            }
        }
        
        if(flag)
        {
            cout << minn << endl;
        }
        else
        {
            cout << -1 << endl;
        }
    }
    return 0;
}
```
    - **核心实现思想**：初始化能否走及所需步数的变量，对上下左右四个方向判断能否走并记录步数。对四个角判断两个方向能否同时到达终点（步数差为偶数），若能则更新最小步数并标记可走，最后根据标记输出结果。
• 最优关键思路或技巧：通过数学分析得出到达目标点需满足横纵坐标差分别为a、b整数倍且步数差为偶数的条件，避免暴力搜索，大大优化时间复杂度。实现时利用数组或多个变量记录横纵方向移动步数，简洁高效地完成条件判断与步数计算。
• 可拓展思路：此类题目属于坐标移动求最短路径问题，类似套路为分析移动规则，找出移动的限制条件和规律，将问题转化为数学判断。例如在其他网格移动问题中，可能移动规则更复杂，但同样可通过分析横纵方向移动关系及限制条件求解。
• 相似知识点洛谷题目：
  - P1115 最大子段和，涉及对数据规律分析及最优解求解。
  - P1080 国王游戏，需通过数学分析优化算法求最优解。
  - P2678 [NOIP2015 提高组] 跳石头，同样是分析条件求最优解类型题目。
• 个人心得摘录与总结：部分作者提到做题时先思考骗分思路（如暴力、输出 -1 等），在无法直接得出正解时可先获取部分分数。还有作者在调试时遇到数据范围问题，如初始最小值设置过小导致结果错误，强调了注意数据范围的重要性。 

---
处理用时：47.73秒
# 题目信息

# kls与flag

## 题目背景

kls毒奶非常厉害。

## 题目描述

有$n$个OI选手，每个人插了一个flag。有一天因为某种原因，flag都被触发了，所以地上有一排$n$根竹竿，竹竿的间距均为一个单位长度，高度在$1\sim m$之间。

kls看到这些竹竿，感觉不好看，于是准备把它们全部放倒。

在这之前，kls想到了一个数学问题。每根竹竿可以往左倒或者往右倒。如果两根竹竿在选择方向放倒之后，它们的顶端可以重合，那么称它们是优秀的。现在kls想要知道，有多少对竹竿是优秀的。

## 说明/提示

### 样例解释

![法法](https://cdn.luogu.com.cn/upload/pic/25795.png)

- 1号和2号向左倒可以顶端重合
- 4号和5号向右倒可以顶端重合
- 1号向右，5号向左可以顶端重合

### 数据范围

对于30%的数据，满足$n\le 2000$，$m\le 5000$；

对于60%的数据，满足$n\le 200000$，$m\le 500000$；

对于100%的数据，满足$n \le 200000$，$m \le 10^9$。

## 样例 #1

### 输入

```
5 5
2 3 3 3 2```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效统计竹竿倒下后顶端重合的对数展开。思路上，大多先确定每根竹竿向左或向右倒下后顶端的位置，再统计相同位置的数量来计算重合对数。算法要点包括使用合适的数据结构存储位置信息，如数组、map、multiset等，并通过排序、遍历等操作完成计数。难点在于处理较大的数据范围，避免空间和时间复杂度过高。

### 所选的题解
1. **作者：Viston (赞：47)**
    - **星级**：4星
    - **关键亮点**：不用map，将每个杆子可能落到的位置存进数组，通过sort排序后O(N)扫描统计，思路清晰，代码简洁高效。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c[200002],d[400002],e=0,i,j,k,l;
int main(){
    ios::sync_with_stdio(false);
    cin>>a>>b;
    for(i=1;i<=a;i++){
        cin>>c[i];e+=2;
        d[e-1]=i-c[i];d[e]=i+c[i];
    }
    sort(d+1,d+e+1);
    for(i=1;i<=2*a;i++){
        if(d[i]!=d[i-1])
            k=0;
        else k++,l+=k;
    }
    cout<<l;
}
```
    - **核心思想**：先将每根竹竿左右倒下的位置存入数组d，排序后遍历数组，若当前位置与前一个相同则计数k增加，同时将k累加到结果l中，最终得到重合对数。

2. **作者：醉梦未苏 (赞：27)**
    - **星级**：4星
    - **关键亮点**：使用STL的map统计每个位置被竹竿覆盖的次数，利用等差数列公式计算重合对数，思路直观，代码易懂。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
map<long long,long long> mmp;
long long val(long long x)
{
    if(x<2) return 0;
    return x*(x-1)/2;
}
int main()
{
    cin>>n>>m;
    for(long long i=1;i<=n;i++)
    {
        long long k;
        scanf("%lld",&k);
        mmp[k+i]++;
        mmp[i-k]++;
    }
    long long ans=0;
    for(map<long long,long long>::iterator  i=mmp.begin();i!=mmp.end();i++)
    {
        ans+=val(i->second);
    }
    cout<<ans;
    return 0;
}
```
    - **核心思想**：输入竹竿高度时，用map记录每个竹竿倒下位置出现的次数，遍历map，对每个位置出现的次数使用等差数列公式计算其对重合对数的贡献并累加。

3. **作者：Fuyuki (赞：9)**
    - **星级**：4星
    - **关键亮点**：简洁地使用map解决问题，通过判断map的键值是否存在来更新答案，代码简洁明了。
    - **重点代码**：
```cpp
#include<iostream>
#include<map>
using namespace std;
int i,n,m;
long long ans;
map<int,int>a;
int main()
{
    cin>>n>>m;
    for(i=1;i<=n;i++){
        cin>>m;
        if(a.count(i-m)==0)a[i-m]=0;
        if(a.count(i+m)==0)a[i+m]=0;
        ans+=a[i-m]+a[i+m],a[i-m]++,a[i+m]++;
    }
    cout<<ans;
    return 0;
}
```
    - **核心思想**：每次输入竹竿高度，判断该竹竿左右倒下位置在map中是否存在，不存在则初始化计数为0，然后将当前竹竿与已有的同位置竹竿配对，更新答案并增加对应位置的计数。

### 最优关键思路或技巧
1. **数据结构选择**：使用map可方便地处理较大值域的数据，避免数组空间浪费，同时能快速查找和统计。若不用map，可通过排序数组并遍历的方式，同样能高效统计相同位置的数量。
2. **数学计算优化**：利用等差数列公式\(n*(n - 1)/2\)快速计算相同位置竹竿的重合对数，避免了暴力枚举的高时间复杂度。

### 可拓展思路
此类题目属于计数类问题，通常涉及对大量数据的统计和处理。类似算法套路包括利用合适的数据结构优化存储和查找，以及运用数学知识简化计算。同类型题可涉及不同物体在一定规则下的重叠、匹配计数等场景。

### 相似知识点洛谷题目
1. **P1083 借教室**：涉及线段树或差分等数据结构，通过对区间的操作和统计解决问题，与本题处理大量数据并统计的思路类似。
2. **P3374 【模板】树状数组 1**：树状数组的基础应用，通过树状数组实现高效的区间查询和单点修改，与本题在数据处理和统计方面有相似之处。
3. **P1972 [SDOI2009]HH的项链**：需要利用数据结构优化对区间内不同元素的统计，与本题统计相同位置竹竿对数的思路类似，都涉及对数据的去重和计数。

### 个人心得摘录
1. **作者：贞白铁战逸**：提到月赛爆惨，回头重新做更有感觉，意识到朴素算法会TLE，从而思考优化方法。这表明在竞赛中遇到问题时，重新审视题目、优化算法的重要性。
2. **作者：糖hhhh？**：分享了从30分暴力到60分数组记录再到100分优化的过程，强调了空间优化和数据结构选择的重要性，以及在处理大数据范围时遇到的困难和解决办法。 

---
处理用时：34.58秒
# 题目信息

# 血小板与凝血因子

## 题目背景

为了尽快修复伤口，血小板们正在搬运凝血因子。它们（没毛病）正在讨论怎么分配，因为它们太可爱了，所以就让你来解决这个问题。

![](https://i.loli.net/2018/10/05/5bb7372e781b1.jpg)

## 题目描述

血小板们有两种不同的容器，第一种容器每个容器中只能装同一种凝血因子，第二种容器每个容器中每种凝血因子最多出现一次。为了方便，血小板们想用**同一种**容器装下所有的凝血因子。

换句话说，把 $n$ 个正整数 $a_1$ ~ $a_n$ 分成一些不相交的集合 $S_1$ ~ $S_m$，满足以下两个条件**之一**： 
1. $\forall a_i,\ a_j\in S_k,\ k\in [1,\ m]$ 有 $a_i=a_j$
2. $\forall a_i,\ a_j\in S_k,\ k\in [1,\ m],\ i\neq j$ 有 $a_i\neq a_j$

因为血小板的数量比较少，所以你要把所有的凝血因子装到尽量少的容器里。它们想知道，如何划分能使容器的总数最小。

## 说明/提示

$1\le n\le 1000,\ \ 1\le a_i\le 10^9$。

## 样例解释

### 样例一：

选用第二种容器，分别放入 $\{4\}$，$\{3,1,2,4,5\}$，$\{4\}$，这是一组可行的最优解，更改三个容器的顺序、容器 $2$ 中 $5$ 个凝血因子的顺序可以得到另外的最优解。

### 样例二/三：

这两组样例输入相同，既可以选用第一种容器，也可以选用第二种容器。

两组样例的输出分别为一组可行的最优解，改变顺序可以得到另外的几组最优解。

### 样例四：

选用第一种容器，分别放入 $\{3,3,3\}$，$\{2,2\}$，这是一组可行的最优解，更改两个容器的顺序可以得到另一组最优解。

## 样例 #1

### 输入

```
7
1 2 3 5 4 4 4```

### 输出

```
3 2
1 4
5 3 1 2 4 5
1 4```

## 样例 #2

### 输入

```
3
20181110 20181111 20181111```

### 输出

```
2 1
1 20181110
2 20181111 20181111```

## 样例 #3

### 输入

```
3
20181110 20181111 20181111```

### 输出

```
2 2
2 20181110 20181111
1 20181111```

## 样例 #4

### 输入

```
5
3 2 3 2 3```

### 输出

```
2 1
3 3 3 3
2 2 2```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解均先明确两种容器装凝血因子的方案，即第一种容器数量为凝血因子种类数，第二种容器数量为同种凝血因子出现次数的最大值，然后比较两者取较小值作为答案。
    - 算法要点：需统计不同凝血因子的种类及每种凝血因子出现的次数。实现方式多样，如排序后遍历数组、使用map等。
    - 解决难点：数据范围大，直接开桶空间存不下。部分题解通过离散化、map等方式解决。
    - 整体质量：多数题解思路清晰，但在代码可读性和优化程度上有差异。

所选的题解：
  - 作者：南城忆潇湘 (5星)
    - 关键亮点：详细介绍map数据结构及iterator迭代器的使用，代码实现简洁清晰，对map操作讲解细致。
    - 重点代码及核心实现思想：
```cpp
#include<bits/stdc++.h>
#define MAXN 1001
using namespace std;
int a[MAXN];
map<int,int> b;
int main(){
    int n,ans1=0,ans2=0;
    cin>>n;
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]),b[a[i]]++,ans1=max(ans1,b[a[i]]); // 统计每种凝血因子出现次数并记录最大值
    sort(a+1,a+1+n);
    ans2=unique(a+1,a+1+n)-a-1; // 计算凝血因子种类数
    if(ans2<ans1){
        cout<<ans2<<" "<<1<<endl;
        map<int,int>::iterator it=b.begin();
        for(int i=1;i<=ans2;i++){
            cout<<it->second<<" ";
            for(int j=1;j<=it->second;j++)
                printf("%d ",it->first);
            it++;   
            cout<<endl;
        }
    }
    else {
        cout<<ans1<<" "<<2<<endl;
        for(int i=1;i<=ans1;i++){
            map<int,int>::iterator it=b.begin();
            cout<<b.size()<<" ";
            while(it!=b.end()){
                if(b[(*it).first]>0)    cout<<it->first<<" ",b[(*it).first]--; 
                map<int,int>::iterator now=it; it++;
                if(now->second==0)    b.erase(now);    
            }       
            cout<<endl;      
        }
    }
    return 0;
}
```
核心实现思想：利用map统计每种凝血因子出现次数，通过排序和unique函数计算凝血因子种类数，根据两种容器所需数量的比较结果，使用map的iterator迭代器按要求输出方案。

  - 作者：MarchKid_Joe (4星)
    - 关键亮点：思路清晰，详细阐述统计不同凝血因子个数及出现次数最多的个数的实现过程，代码注释详尽。
    - 重点代码及核心实现思想：
```cpp
sort (a + 1, a + n + 1);
//ans1-->不同种类的凝血因子的种数（容器1）
//ans2-->凝血因子出现次数最多的一种的个数（容器2） 
//t-->存储个数 
//d[?].sum-->不同种类的凝血因子的个数
//d[?].r-->存储凝血因子（用于输出）
for (int i = 2; i <= n + 1; i++)
{
    if (a[i]!= a[i - 1])
    {
        ++ans1;
        d[ans1].sum = t;
        d[ans1].r = a[i - 1];
        ans2 = max(ans2, d[ans1].sum);
        t = 1;
    }
    else t++;
}
```
核心实现思想：先对数组排序，遍历数组统计不同凝血因子的个数并存入结构体，同时记录出现次数最多的凝血因子个数，最后根据比较结果按要求输出方案。

  - 作者：wjyyy (4星)
    - 关键亮点：简洁明了地阐述思路，指出可使用map和sort简化代码复杂度，代码实现简洁高效。
    - 重点代码及核心实现思想：
```cpp
#include<cstdio>
#include<map>
using std::map;
map<int,int> m;
int a[1010];
int ans[1010][1010];
int main()
{
    int n,u;
    scanf("%d",&n);
    int mx=0;
    for(int i=1;i<=n;++i)
    {
        scanf("%d",&u);
        m[u]++;
        mx=mx>m[u]?mx:m[u];
    }
    ans[0][0]=mx<m.size()?mx:m.size();
    printf("%d ",ans[0][0]);
    if(mx<m.size())
    {
        printf("%d\n",2);
        for(map<int,int>::iterator it=m.begin();it!=m.end();++it)
        {
            int num=it->second;
            for(int i=1;i<=num;++i)
                ans[i][++ans[i][0]]=it->first;
        }
        for(int i=1;i<=ans[0][0];++i)
        {
            for(int j=0;j<=ans[i][0];++j)
                printf("%d ",ans[i][j]);
            puts("");
        }
    }
    else
    {
        printf("%d\n",1);
        for(map<int,int>::iterator it=m.begin();it!=m.end();++it)
        {
            int num=it->second;
            printf("%d ",num);
            for(int i=1;i<=num;++i)
                printf("%d ",it->first);
            puts("");
        }
    }
    return 0;
}
```
核心实现思想：利用map统计每种凝血因子出现次数并记录最大值，比较map大小（即凝血因子种类数）和最大值，根据结果使用map的iterator迭代器按要求输出方案。

最优关键思路或技巧：
    - 数据结构：使用map统计凝血因子出现次数，利用其特性方便地解决数据范围大无法直接开桶的问题。
    - 算法优化：排序后遍历数组统计相关信息，或结合map等数据结构简化操作，提高代码效率和可读性。

可拓展之处：同类型题可考察不同条件下的数据分组问题，类似算法套路为先明确不同分组方案的计算方式，再根据条件选择最优方案，常涉及数据统计、排序等操作。

推荐题目：
    - P1083 [NOIP2012 提高组] 借教室：涉及数据统计与区间操作，与本题统计数据并根据条件决策类似。
    - P1131 [ZJOI2007] 时态同步：需要对树结构进行操作和数据统计，可锻炼数据处理和决策能力。
    - P2671 [NOIP2015 提高组] 求和：涉及对数列的统计和计算，与本题统计凝血因子相关信息思路类似。

个人心得：无。 

---
处理用时：40.20秒
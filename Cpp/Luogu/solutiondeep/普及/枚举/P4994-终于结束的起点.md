# 题目信息

# 终于结束的起点

## 题目背景

> 终于结束的起点  
> 终于写下句点  
> 终于我们告别  
> 终于我们又回到原点  
> ……

一个个 OIer 的竞赛生涯总是从一场 NOIp 开始，大多也在一场 NOIp 中结束，好似一次次轮回在不断上演。  
如果这次 NOIp 是你的起点，那么祝你的 OI 生涯如同夏花般绚烂。  
如果这次 NOIp 是你的终点，那么祝你的 OI 回忆宛若繁星般璀璨。  
也许这是你最后一次在洛谷上打比赛，也许不是。  
不过，无论如何，祝你在一周后的比赛里，好运。

当然，这道题也和轮回有关系。

## 题目描述

广为人知的斐波拉契数列 $\mathrm{fib}(n)$ 是这么计算的

$$
\mathrm{fib}(n)=\begin{cases}
0,& n=0 \\
1,& n=1 \\
\mathrm{fib}(n-1) + \mathrm{fib}(n-2),& n>1
\end{cases}
$$

也就是 $0, 1, 1, 2, 3, 5, 8, 13 \cdots$，每一项都是前两项之和。

小 F 发现，如果把斐波拉契数列的每一项对任意大于 $1$ 的正整数 $M$ 取模的时候，数列都会产生循环。

当然，小 F 很快就明白了，因为 ($\mathrm{fib}(n - 1) \bmod M$) 和 ($\mathrm{fib}(n - 2) \bmod M)$ 最多只有 $M ^ 2$ 种取值，所以在 $M  ^ 2$ 次计算后一定出现过循环。

甚至更一般地，我们可以证明，无论取什么模数 $M$，最终模 $M$ 下的斐波拉契数列都会是 $0, 1, \cdots, 0, 1, \cdots$。

现在，给你一个模数 $M$，请你求出最小的 $n > 0$，使得 $\mathrm{fib}(n) \bmod M = 0, \mathrm{fib}(n + 1) \bmod M = 1$。

## 说明/提示

#### 样例 1 解释

斐波拉契数列为 $0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \cdots$，在对 $2$ 取模后结果为 $0, 1, 1, 0, 1, 1, 0, 1, 1, 0, \cdots$。

我们可以发现，当 $n = 3$ 时，$f(n) \bmod 2= 0, f(n + 1) \bmod 2 = 1$，也就是我们要求的 $n$ 的最小值。

#### 数据范围

对于 $30\%$ 的数据，$M \leq 18$；

对于 $70\%$ 的数据，$M \leq 2018$；

对于 $100\%$ 的数据，$2 \leq M \leq 706150=\verb!0xAC666!$。

#### 提示

如果你还不知道什么是取模 $(\bmod)$，那我也很乐意告诉你，模运算是求整数除法得到的余数，也就是竖式除法最终「除不尽」的部分，也即
$$a \bmod M =k \iff a = bM + k\ (M > 0, 0 \leq k < M)$$
其中 $a, b, k$ 都是非负整数。

如果你使用 `C` / `C++`，你可以使用 `%` 来进行模运算。

如果你使用 `Pascal`，你可以使用 `mod` 来进行模运算。

## 样例 #1

### 输入

```
2```

### 输出

```
3```

## 样例 #2

### 输入

```
6```

### 输出

```
24```

# AI分析结果

### 综合分析与结论
本题要求找出最小的正整数 \(n\)，使得斐波那契数列模 \(M\) 后，\(\mathrm{fib}(n) \bmod M = 0\) 且 \(\mathrm{fib}(n + 1) \bmod M = 1\)。题解主要分为暴力解法和基于数论性质的解法。暴力解法利用斐波那契数列的递归式直接计算并取模，通过记忆化搜索或扩大数组范围避免超时；数论解法通过对模数 \(M\) 进行质因数分解，利用斐波那契数列模素数及素数幂的循环节性质来求解。

### 所选的题解
1. **作者：万弘 (赞：29) - 4星**
    - **关键亮点**：采用记忆化搜索优化暴力递归，思路清晰，代码简洁，易于理解。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<cstdio>
typedef long long ll;
using namespace std;
const ll INF=0x7fffffff;
ll fp[10000002];//记忆数组，虽然m不大但是不知道n多大，尽量开大，不过1千万差不多极限
ll m;
ll f(ll i)
{
    if(fp[i])return fp[i];//调取记忆
    if(i==1||i==2)return fp[i]=1%m;
    else return fp[i]=(f(i-1)+f(i-2))%m;//这时就顺带%m可以使主程序更简单
}
int main()
{
    scanf("%lld",&m);
    ll i=1;//枚举
    while(f(i)!=0||f(i+1)!=1)//题目要求
    {
        i++;
    }
    printf("%lld",i);
    return 0;
}
```
    - **核心实现思想**：定义 `f` 函数计算斐波那契数列模 \(m\) 的值，使用 `fp` 数组记录已计算的值，避免重复计算。在 `main` 函数中枚举 \(i\)，直到找到满足条件的 \(i\)。

2. **作者：a13518354766 (赞：22) - 4星**
    - **关键亮点**：通过打表找出斐波那契数列模 \(M\) 的一些规律，利用质因数分解和规律计算结果，优化了暴力计算过程，效率较高。
    - **个人心得**：打表找规律花费近半小时，发现规律后优化了暴力算法。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10000000;
int M;
bool is_not_prime[N];
int f[N],zhi[N],e;
inline void sai(int maxe){
    for(int i=2;i<=maxe;++i){
        if(!is_not_prime[i]){
            zhi[++e]=i;
            for(int j=i;j<=maxe/i;++j){
                is_not_prime[i*j]=1;
            }
        }
    }
}
inline int gcd(int x,int y){
    return x%y==0?y:gcd(y,x%y);
}
inline int lcm(int x,int y){//lcm
    return x/gcd(x,y)*y;
}
inline int bl(int x){//暴力计算
    f[1]=1;
    for(int i=2;i;++i){
        f[i]=f[i-1]+f[i-2];
        f[i]%=x;
        if(f[i]==1&&f[i-1]==0){
            return i-1;
        }
    }
}
inline int ksm(int x,int y){
    int ans=1;
    while(y){
        if(y&1){
            ans*=x;
        }
        x*=x;
        y>>=1;
    }
    return ans;
}
inline int div(int x){
    int ans=1;
    for(int i=1;i<=e;++i){
        if(zhi[i]>x){
            break;
        }
        if(x%zhi[i]==0){//分解质因数
            int tim=0;
            while(x%zhi[i]==0){//求幂
                tim++;
                x/=zhi[i];
            }
            int ti=bl(zhi[i]);
            ti*=ksm(zhi[i],tim-1);
            ans=lcm(ans,ti);
        }
    }
    return ans;
} 
int main(){
    //2^n=3*2^(n-1)
    //3^n=8*3^(n-1)
    //5^n=20*5^(n-1)
    sai(706150);//筛法筛质数
    int x;
    scanf("%d",&x);
    printf("%d\n",div(x));
    return 0;
}
```
    - **核心实现思想**：先用筛法筛出质数，对输入的 \(M\) 进行质因数分解，通过 `bl` 函数暴力计算每个质因数的结果，利用规律和 `lcm` 函数计算最终结果。

3. **作者：Cheng_yf (赞：11) - 4星**
    - **关键亮点**：利用数论中斐波那契数列模 \(n\) 的循环节性质，通过质因数分解、计算模素数及素数幂的循环节长度，最后求最小公倍数得到结果，算法复杂度较低。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define pb push_back
#define sd second
#define ft first 
typedef long long ll;
using namespace std;
int T,n;
const ll INF=1e18;
map<ll,ll>S;
inline ll power(ll a,ll b,ll mod){
    int rs=1;a=a%mod;
    for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)rs=1ll*rs*a%mod;
    return rs;  
}
inline ll gcd(ll x,ll y){return y?(gcd(y,x%y)):x;}
typedef pair<int,int> pii;
namespace SP1{
    vector<pii>fac;
    ll nowlen,M;
    inline void mul(ll *a,ll *b,ll mod){
        unsigned long long bd=a[0]*b[0],bc=a[0]*b[1],ad=a[1]*b[0],ac=a[1]*b[1];
        a[1]=(bc+ad+ac)%mod,a[0]=(bd+ac)%mod;
    }
    inline void power_p(ll *a,ll b,ll mod){
        ll c[2]={1,0};
        for(;b;b>>=1,mul(a,a,mod))
            if(b&1)mul(c,a,mod);
        a[0]=c[0];a[1]=c[1];
    }
    inline bool check(ll sum){
        ll b[2]={0,1};
        power_p(b,sum,M);
        return b[1]==0&&b[0]==1;
    } 
    inline void dfs(int pos,ll sum){
        if(pos==fac.size()){
            (sum!=1&&check(sum))?(nowlen=min(nowlen,sum)):0;
            return;
        }
        ll rs=1;
        for(int i=0;i<=fac[pos].sd;++i){
            dfs(pos+1,sum*rs);
            rs*=fac[pos].ft;
        }
    }
    inline ll getlen(ll x){
        if(x==2)return 3;
        if(x==3)return 8;
        if(x==5)return 20;
        if(S.find(x)!=S.end())return S[x];
        ll base=(power(5,(x-1)/2,x)==1)?(x-1):(2*x+2);
        fac.clear();nowlen=INF;M=x;
        for(int i=2;i*i<=base;++i){
            if(!(base%i)){
                pii t=mp(i,0);
                while(!(base%i))base/=i,++t.sd;
                fac.pb(t);
            }
        }
        if(base!=1)fac.pb(mp(base,1));
        dfs(0,1);return S[x]=nowlen;
    }
}
vector<pii>fac;
ll ans;
inline void solve(int n){
    if(n==1){puts("1");return;}
    fac.clear();
    for(int i=2;i*i<=n;i++){
        if(!(n%i)){
            pii t=mp(i,0);
            while(!(n%i))n/=i,++t.sd;
            fac.pb(t);
        }
    }
    if(n!=1)fac.pb(mp(n,1)); 
    ans=1;
    for(int i=0;i<fac.size();++i){
        ll l=SP1::getlen(fac[i].ft);
        l=l*power(fac[i].first,fac[i].second-1,INF);
        ans=(ans*l)/gcd(ans,l);
    }
    printf("%llu",ans);
}
int main(){
    scanf("%d",&n);
    solve(n);
    return 0;
}
```
    - **核心实现思想**：先对 \(n\) 质因数分解，通过 `getlen` 函数利用数论定理计算模每个素数的循环节长度，再根据规律计算模素数幂的循环节长度，最后求所有循环节长度的最小公倍数得到答案。

### 最优关键思路或技巧
1. **记忆化搜索优化暴力递归**：在暴力计算斐波那契数列时，使用数组记录已计算的值，避免重复计算，提高效率。
2. **利用数论性质优化算法**：对模数 \(M\) 质因数分解，利用斐波那契数列模素数及素数幂的循环节性质，通过计算每个质因数相关的循环节长度并求最小公倍数得到结果，降低算法复杂度。

### 可拓展之处
同类型题或类似算法套路：对于涉及数列循环节、取模运算及数论相关的题目，可考虑质因数分解、利用数论定理和性质优化算法。例如计算其他数列模某个数的循环节，或求解满足特定取模条件的数列项。

### 相似知识点洛谷题目
1. **P1306 斐波那契公约数**：涉及斐波那契数列性质及最大公约数计算。
2. **P5091 【模板】扩展中国剩余定理（EXCRT）**：考察数论中的同余方程和中国剩余定理相关知识，与本题利用数论性质解题思路类似。
3. **P2152 [SDOI2009]SuperGCD**：关于大整数运算和最大公约数计算，对数论知识和代码实现有一定要求。

### 个人心得摘录与总结
1. **a13518354766**：打表找规律花费近半小时，发现规律后优化了暴力算法，说明打表在寻找数列规律时是一种有效的手段，但需要耐心和细心。 

---
处理用时：60.54秒
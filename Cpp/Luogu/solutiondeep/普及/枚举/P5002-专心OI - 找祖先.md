# 题目信息

# 专心OI - 找祖先

## 题目背景

Imakf 是一个小蒟蒻，他最近刚学了 LCA，他在手机 APPstore 里看到一个游戏也叫做 LCA 就下载了下来。

## 题目描述

这个游戏会给出你一棵树，这棵树有 $N$ 个节点，根结点是 $R$，系统会选中 $M$ 个点 $P_1,P_2 \cdots P_M$，要Imakf 回答有多少组点对 $(u_i,v_i)$ 的最近公共祖先是 $P_i$。Imakf 是个小蒟蒻，他就算学了 LCA 也做不出，于是只好求助您了。



## 说明/提示

样例 1 的树如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/37971.png)

 对于询问 1 $~(1,1)
(1,2)
(1,3)
(1,4)
(1,5)
(1,6)
(1,7)
(2,1)
(2,3)
(2,6)
(2,7)
(3,1)
(3,2)
(3,4)
(3,5)
(4,1)
(4,3)$

$
(4,6)
(4,7)
(5,1)
(5,3)
(5,6)
(5,7)
(6,1)
(6,2)
(6,4)
(6,5)
(7,1)
(7,2)
(7,4)
(7,5)$ 共 $31$ 组点对。

询问 2 $(2,2)
(2,4)
(2,5)
(4,2)
(4,5)
(5,2)
(5,4)$ 共 $7$ 组点对。

对于询问 3 $(4,4)$ 共 $1$ 组点对。

$1\le R\le N\leq10000$，$0\le M\leq50000$。

## 样例 #1

### 输入

```
7 1 3
1 2
1 3
2 4
2 5
3 6
3 7
1 2 4```

### 输出

```
31
7
1```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何高效计算给定树中以特定点为最近公共祖先（LCA）的点对数量展开。思路上，均通过分析树的结构和LCA的性质，利用排列组合知识，从子树大小关系入手。算法要点在于先通过深度优先搜索（DFS）计算每个节点的子树大小，再根据不同情况计算以每个节点为LCA的点对数量。难点在于如何优化计算过程，避免重复计算，提高效率。部分题解采用记忆化、数学公式化简等方法优化。
• 所选的题解：
  - **作者：ZAGER (赞：31)，星级：4星**
    - **关键亮点**：在DFS时就预处理出每个点的答案，时间复杂度为\(O(max(n,m))\)。通过清晰地将答案分为跨过\(x\)和未跨过\(x\)两部分，利用数学推导得出简洁的计算公式，代码实现简洁明了。
    - **重点代码**：
```cpp
inline void dfs(R int x,R int f){
    siz[x]=1;
    for(R int i=h[x];i;i=edge[i].nex){
        R int xx=edge[i].to;
        if(xx==f)continue;
        dfs(xx,x);
        siz[x]+=siz[xx];
        sum[x]+=siz[xx]*siz[xx];
    }
    ans[x]=siz[x]*siz[x]-sum[x];
}
```
    - **核心实现思想**：在DFS过程中，计算每个节点\(x\)的子树大小\(siz[x]\)，并累加其子节点子树大小的平方和\(sum[x]\)，最后根据推导公式\(ans[x]=siz[x]*siz[x]-sum[x]\)得出以\(x\)为LCA的点对数量。
  - **作者：llzzxx712 (赞：88)，星级：4星**
    - **关键亮点**：思路清晰，详细阐述了算法的每一步。先通过DFS求出所有子树大小，再分析出计算以某点为LCA的点对数量的两种情况，并给出具体实现。针对询问次数多的特点，提前处理每个点的答案，避免重复计算。
    - **个人心得**：提到虽然标签有LCA，但实际未用到求LCA，以及最初代码TLE一个点后发现是询问次数多导致，从而进行优化。
    - **重点代码**：
```cpp
void dfs(int x,int fa){
	son[x]=1;
	de[x]=de[fa]+1;
	for(int i=head[x];i;i=ne[i]){
		if(to[i]!=fa){
			dfs(to[i],x);
			son[x]+=son[to[i]]%mo;
		}
	}
}
int getans(int p){
	int x,y=0,z=0;
	z=x=son[p];
	for(int i=head[p];i;i=ne[i]){
		if(de[to[i]]<de[p]) continue;
		y=son[to[i]];
		z+=(long long)((x-y)*y)%mo;
	}
	return z;
}
```
    - **核心实现思想**：`dfs`函数计算每个节点\(x\)的子树大小\(son[x]\)。`getans`函数根据节点\(p\)的子树大小及子节点子树大小，计算以\(p\)为LCA的点对数量。
  - **作者：0x3F (赞：22)，星级：4星**
    - **关键亮点**：简洁地分析出\(x,y\)的LCA是\(k\)的两种情况，并针对每种情况给出具体计算方法。代码实现简洁，利用前缀和优化计算过程。
    - **重点代码**：
```cpp
void dfs(int x, int f) {
	for (int i = 0; i < G[x].size(); i++) {
		if (G[x][i]!= f) {
			dfs(G[x][i], x);
			cnt[x] = (cnt[x] + 1ll * siz[x] * siz[G[x][i]]) % mod;
			siz[x] += siz[G[x][i]];
		}
	}
	cnt[x] = (cnt[x] + siz[x]) % mod;
	cnt[x] = cnt[x] * 2 % mod;
	siz[x]++;
	cnt[x]++;
}
```
    - **核心实现思想**：`dfs`函数在遍历过程中，通过累加\(cnt[x]\)来计算以\(x\)为LCA的点对数量，其中考虑了两种情况的计算，并结合取模操作保证结果正确性。
• **最优关键思路或技巧**：通过DFS遍历树结构，记录每个节点的子树大小，利用排列组合原理分析以某节点为LCA的点对构成情况，推导出计算公式。对于可能重复询问的情况，采用预处理所有节点答案的方式，避免重复计算，降低时间复杂度。
• **同类型题或类似算法套路**：此类题目通常围绕树结构展开，给定一些与节点关系相关的条件，求满足特定条件的节点对数量或其他统计量。一般先通过DFS或其他树遍历方式获取树的相关信息（如子树大小、深度等），再结合数学原理（如排列组合、乘法原理等）分析并计算答案。有时需注意数据范围，对算法进行优化，如记忆化、公式化简等。
• **推荐题目**：
  - [P1351 联合权值](https://www.luogu.org/problemnew/show/P1351)：同样是在树上进行与节点关系相关的统计计算，通过分析节点间的联合权值来求解问题，与本题类似，需利用树的遍历和数学原理。
  - [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.org/problemnew/show/P3379)：经典的LCA模板题，掌握LCA的基本求解方法有助于理解本题中对LCA性质的运用，可作为基础巩固。
  - [P2680 运输计划](https://www.luogu.org/problemnew/show/P2680)：结合了树的路径和LCA知识，通过对树中路径的分析和LCA的计算来解决问题，与本题在树结构分析和利用LCA性质方面有相似之处。 

---
处理用时：41.35秒
# 题目信息

# [MtOI2019] 膜Siyuan

## 题目背景

你强归你强，$\mathsf S\mathsf{\color{red} iyuan}$ 比你强。——$\mathsf S \mathsf{\color{red} iyuan}$

disangan233 最近发现了一款 OIer 们的游戏：[膜 $\color{black} \mathsf S \mathsf{\color{red} iyuan}$](https://lmoliver.github.io/mosiyuan/index.html)。

他被里面的「真理 IV」所困惑，于是他找到了你寻求帮助。


## 题目描述

给你 $1$ 个正整数 $M$，$n(n\leq 5)$ 个正整数 $3$ 元组 $\{a_i,b_i,c_i\}(a_i,b_i,c_i\leq M\leq 2000)$，请你求出所有满足

$$
\forall i\leq n ,s.t.~|a_i-x|\oplus |b_i-y|\oplus |c_i-z| = 9
$$

的**有序**正整数 $3$ 元组 $\{x,y,z\}(x,y,z \leq M)$的个数。

其中，$\forall$ 表示 "对于所有"，$s.t.$ 表示 "使得"，$A \oplus B \oplus C$ 表示 $A,B,C$ 的异或和。

对于 C++，`A^B^C` 或 `A xor B xor C` 即为 $A \oplus B \oplus C$ 的答案 。

这里提供一份模板：

```cpp
if ((a ^ b ^ c) == 9) 
{
	Your code here...
}
```

对于 $2$ 个有序 $3$ 元组 $A,B$，如果 $x_A \not =x_B$ 或 $y_A \not =y_B$ 或 $z_A \not =z_B$，$A,B$ 即被视为是不同的。


## 说明/提示

#### 样例解释 $1$

所有满足条件的 $\{x,y,z\}$ 有： 

$\{88,88,120\}$，$\{88,104,104\}$，$\{120,120,120\}$ 和 $\{120,136,104\}$。

共 $4$ 个。

### 子任务

对于 $10\%$ 的数据，保证与样例完全一致。

对于 $60\%$ 的数据，保证 $M\leq 200$。

对于所有数据，保证 $a_i,b_i,c_i\leq M\leq 2000$，$n\leq 5$。


### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22614) T2

出题人：disangan233

验题人：Studying Father


## 样例 #1

### 输入

```
5 200
21 84 198
38 47 102
44 47 132 
63 150 166
76 79 132```

### 输出

```
4```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解先提到暴力枚举$x,y,z$的方法，时间复杂度为$O(M^3n)$，期望得分60%。优化思路是利用异或运算性质，通过枚举$x,y$，根据异或交换律和自反性推出$|c_i - z| = 9 \oplus |a_i - x| \oplus |b_i - y|$，再解绝对值方程得到$z$的两个可能值$z_1 = c_i + t$和$z_2 = c_i - t$（$t = 9 \oplus |a_i - x| \oplus |b_i - y|$），并判断这两个值是否满足所有给定的三元组条件以及取值范围在$[1,M]$内，此优化后时间复杂度为$O(M^2n)$，可拿满分。
    - 算法要点在于对异或运算性质的运用以及绝对值方程的求解和范围判断。解决难点在于理解异或运算性质来简化枚举过程，同时处理绝对值方程可能出现的相同解、无解以及解的范围判断等情况。
    - 整体来看，各题解思路相近，主要差异体现在代码实现细节、思路阐述清晰度和代码可读性上。

• 所选的题解：
  - 作者：Hexarhy (赞：2)  星级：4星
    - 关键亮点：对异或运算性质进行了详细复习和证明，思路清晰，从暴力算法逐步优化到高效算法，代码实现细节处理得当，如去重、利用第一组数据计算$z$并验证等，且代码结构清晰，有输入和求解函数的划分。
    - 重点代码：
```cpp
void solve(void)
{
    for(int x = 1; x <= m; x++)
        for(int y = 1; y <= m; y++)
        {
            const int t = abs(x - a[1]) ^ abs(y - b[1]) ^ 9;
            const int z1 = c[1] + t;
            const int z2 = c[1] - t;
            bool f1 = (0 < z1 && z1 <= m), f2 = (0 < z2 && z2 <= m);
            for(int i = 2; i <= n; i++)
            {
                if((abs(x - a[i]) ^ abs(y - b[i]) ^ abs(z1 - c[i]))!= 9)
                    f1 = false;
                if((abs(x - a[i]) ^ abs(y - b[i]) ^ abs(z2 - c[i]))!= 9)
                    f2 = false;
            }
            ans = ans + f1 + f2;
            if(z1 == z2)
                ans--;
        }
}
```
    - 核心实现思想：枚举$x,y$，利用第一组数据计算出$z$的两个可能值$z1,z2$，判断其是否在合法区间内，再代入其余数据验证，若都满足则答案增加，同时处理$z1 = z2$的去重情况。
  - 作者：StudyingFather (赞：6)  星级：4星
    - 关键亮点：作为验题人，对算法讲解简洁明了，先介绍暴力算法，再阐述优化思路，代码简洁，对绝对值方程相同解的情况处理清晰。
    - 重点代码：
```cpp
for(int i = 1; i <= m; i++)
    for(int j = 1; j <= m; j++)
    {
        int tmp = abs(i - p[1].a) ^ abs(j - p[1].b) ^ 9;
        int res1 = p[1].c + tmp, res2 = p[1].c - tmp;
        int flag1 = (res1 > 0 && res1 <= m), flag2 = (res2 > 0 && res2 <= m);
        for(int k = 2; k <= n; k++)
        {
            if((abs(i - p[k].a) ^ abs(j - p[k].b) ^ abs(res1 - p[k].c))!= 9) flag1 = false;
            if((abs(i - p[k].a) ^ abs(j - p[k].b) ^ abs(res2 - p[k].c))!= 9) flag2 = false;
        }
        if(res1 == res2) flag2 = false;
        ans += flag1 + flag2;
    }
```
    - 核心实现思想：与Hexarhy类似，枚举$x,y$，根据第一组数据得出$z$的两个解$res1,res2$，判断解的范围，再代入其余组数据验证，最后处理相同解情况并统计答案。
  - 作者：zjy111 (赞：10)  星级：4星
    - 关键亮点：结合游戏背景阐述题意，形象生动，对异或运算性质解释清晰，代码中对各种情况判断细致，如对$z$解的范围判断以及相同解的去重处理。
    - 重点代码：
```cpp
for(r int x = 1; x <= m; ++x)
{
    for(r int y = 1; y <= m; ++y)
    {
        int t = 0, tmp = (abs(a[1] - x) ^ abs(b[1] - y)), qwq = tmp ^ 9, z1 = c[1] - qwq, z2 = c[1] + qwq, flg1 = 1, flg2 = 1;
        if(z1 <= 0 || z1 > m) flg1 = 0;
        if(z2 <= 0 || z2 > m) flg2 = 0;
        if(flg1)
            for(r int i = 2; i <= n; ++i)
                if((abs(a[i] - x) ^ abs(b[i] - y) ^ abs(c[i] - z1))!= 9) { flg1 = 0; break; }
        if(flg2)
            for(r int i = 2; i <= n; ++i)
                if((abs(a[i] - x) ^ abs(b[i] - y) ^ abs(c[i] - z2))!= 9) { flg2 = 0; break; }
        orzsiyuan += flg1 + flg2;
        if(!qwq && flg1 && flg2) --orzsiyuan;
    }
}
```
    - 核心实现思想：同样是枚举$x,y$，根据第一组数据算出$z$的两个解$z1,z2$，判断解是否在范围内，再用其余组数据验证，最后统计答案并处理相同解情况。

• 最优关键思路或技巧：
    - 利用异或运算的交换律、结合律、自反性等性质，将三元枚举简化为二元枚举，从而降低时间复杂度。
    - 在解绝对值方程得到$z$的可能值后，仔细处理解的范围判断以及相同解的去重问题。

• 可拓展之处：
此类题目属于基于特定运算规则的方程求解与计数问题。类似算法套路是遇到复杂方程或条件时，深入挖掘运算性质来简化枚举过程，同时注意边界条件和特殊情况处理。同类型题可能会改变方程形式、运算规则或数据范围等。

• 相似知识点洛谷题目：
    - P1031 [NOIP2002 提高组] 均分纸牌：涉及数据移动和平衡问题，可通过分析数据间关系简化操作过程，与本题利用运算性质简化枚举类似。
    - P1147 连续自然数和：通过数学推导找到满足条件的连续自然数序列，考察对数学性质的运用和枚举优化，类似本题挖掘异或性质优化枚举。
    - P1464 Function （函数）：根据给定函数规则和条件，通过合理的枚举和判断来求解，与本题依据特定规则进行枚举判断计数类似。

• 个人心得摘录与总结：
    - 作者hwx12233提到交了27遍才过，主要是对$Z$为正整数的条件判断有误，修改多次才通过。总结为做题时对题目条件的细节把握至关重要，尤其是边界条件和特殊要求，稍不注意就会导致错误。
    - 作者Crab_Dave提到暴力因Xor优先级问题挂了一次，强调了对运算符优先级的重视，写代码时要严谨，避免因运算符优先级问题导致逻辑错误。 

---
处理用时：45.03秒
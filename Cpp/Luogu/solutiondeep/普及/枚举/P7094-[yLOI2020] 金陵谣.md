# 题目信息

# [yLOI2020] 金陵谣

## 题目背景

> 水几绕，山几重，何处金陵城。   
> 访名都，寻形胜，龙虎倚江东。   
> 书留翰墨，曲落潮声。   
> 草木几度枯荣。

——银临《金陵谣》

## 题目描述

江苏南京，亦称金陵，是一座历史文化名城。有了古城的衬托，江苏省的高考模拟题都显地那么棘手，难以解决。切切在一轮复习过程中便碰到一道江苏省模拟题，在七瑾的帮助下，切切很快秒杀了该题，但切切觉得不够，想用这道题来刁难你。解决本题就能吃到切切和七瑾撒的糖。

给定四个正整数 $a, b, c, d$，求有多少对正整数 $(x, y)$ 满足

$$\frac a x + \frac b c = \frac d y$$

## 说明/提示

### 样例 1 解释

求 $\frac 1 x + \frac 1 3 = \frac 2 y$ 的正整数解对数，分别是 $(x = 3, y = 3)$，$(x = 6, y = 4)$，$(x = 15, y = 5)$。

### 数据规模与约定

本题共有 20 个测试点，每个测试点 $5$ 分。

- 对于测试点 $1$，保证 $T = 0$。
- 对于测试点 $2 \sim 16$，共 $15$ 个测试点，对于 $a, b, c, d$ 四个数中至少存在一个数为 $1$ 共有 $15$ 种情况，每个测试点对应一种情况。
- 对于测试点 $17 \sim 20$，没有特殊约定。

对于全部的测试点，保证 $0 \leq T \leq 20$，$1 \leq a, b, c, d \leq 10^6$，$d \times c \leq 10^6$。

### 提示

+ 众所周知，高考不考数论。
+ 本题共有两个样例文件，见附加中的 song.zip。

## 样例 #1

### 输入

```
1
1 1 3 2```

### 输出

```
3```

# AI分析结果

• 综合分析与结论：
    - 思路方面，所有题解均通过对给定等式\(\frac{a}{x}+\frac{b}{c}=\frac{d}{y}\)进行变形推导，利用正整数条件确定枚举范围来求解。
    - 算法要点在于将等式变形为\(x=\frac{acy}{dc - by}\)，然后枚举\(y\)，判断\(\frac{acy}{dc - by}\)是否为正整数，从而统计满足条件的正整数对\((x, y)\)的个数。
    - 解决难点主要是确定\(y\)的枚举范围，通过分析正整数条件得出\(y < \frac{dc}{b}\)。各题解在表述清晰度、代码可读性和优化程度上存在差异。

• 所选的题解：
  - 作者：一扶苏一 (4星)
    - 关键亮点：思路清晰，不仅阐述了式子推导过程，还提及部分特殊情况（如\(b \gt c\)且\(d = 1\)时式子无解），代码简洁且注释详细。
    - 个人心得：无
    - 核心代码：
```cpp
#include <iostream>

typedef long long int ll;

ll a, b, c, d, T;

int main() {
  for (std::cin >> T; T; --T) {
    std::cin >> a >> b >> c >> d;
    int ans = 0;
    for (ll lim = c * d / b, y = 1; y <= lim; ++y) {
      ll u = a * c * y, v = c * d - b * y;
      if (v <= 0) continue;
      if ((u % v) == 0) ++ans;
    }
    std::cout << ans << std::endl;
  }
  return 0;
}
```
    - 核心实现思想：通过循环枚举\(y\)，从\(1\)到\(\frac{c * d}{b}\)，对于每个\(y\)，计算\(u = a * c * y\)和\(v = c * d - b * y\)，若\(v\)为正且\(u\)能被\(v\)整除，则找到一组满足条件的解，统计解的个数。

  - 作者：Scintilla (4星)
    - 关键亮点：给出两种算法，算法一便于观察和实现，算法二效率较高且不受\(cd\)约束，对不同算法的时间复杂度有清晰分析。
    - 个人心得：无
    - 算法一核心代码：
```cpp
ll a, b, c, d;
int main() {
    int T = read();
    while (T--) {
        a = read(), b = read(), c = read(), d = read(); int cnt = 0;
        for (ll i = 1; b * i < c * d; ++i) {
            if (!((i * a * c) % (c * d - b * i))) ++cnt;
        }
        printf("%d\n", cnt);
    }
    return 0;
}
```
    - 核心实现思想：与上述类似，循环枚举\(y\)（这里用\(i\)表示），判断\((i * a * c)\)能否被\((c * d - b * i)\)整除，能整除则找到一组解，统计解的个数。
    - 算法二核心代码：
```cpp
ll a, b, c, d;
ll tot, pri[100010], cs[100010]; // 质因数个数、质因数、质因数次数

il void calc(ll x) { // 分解质因数
    for (ll i = 2; i * i <= x; ++i) {
        if (x % i) continue;
        pri[++tot] = i, cs[tot] = 0;
        while (!(x % i)) ++cs[tot], x /= i;
    }
    if (x > 1) pri[++tot] = x, cs[tot] = 1;
}

ll S; int cnt;
void dfs(int now, ll tp) {
    if (now == tot + 1) {
        ll p = tp, q = S / tp; q = -q;
        if (p <= a * c || q + c * d <= 0) return; // 保证结果为正
        if ((p - a * c) % b || (q + c * d) % b) return; // 保证结果为整
        ++cnt; return;
    }
    ll temp = 1;
    Rep(i, 0, cs[now]) {
        dfs(now + 1, tp * temp);
        temp *= pri[now];
    }
}

int main() {
    int T = read();
    while (T--) {
        a = read(), b = read(), c = read(), d = read(); cnt = 0, tot = 0;
        S = a * c * c * d, calc(S), dfs(1, 1);
        printf("%d\n", cnt);
    }
    return 0;
}
```
    - 核心实现思想：先将等式变形为\((bx + ac)(by - cd) + ac^2d = 0\)，然后对\(ac^2d\)分解质因数，通过深度优先搜索（dfs）枚举\(ac^2d\)的约数，根据条件判断是否有解，统计解的个数。

• 最优关键思路或技巧：
    - 核心思路是对给定等式进行代数变形，利用正整数条件确定枚举范围，通过枚举一个变量来判断另一个变量是否为正整数，从而统计解的个数。
    - 部分题解中提到的优化，如先将\(\frac{b}{c}\)约分再代入求值，可提高运行速度。

• 可拓展之处：
同类型题通常围绕数论等式求解正整数解个数展开，类似算法套路是对给定等式进行合理变形，结合题目给定的正整数、数据范围等条件，确定枚举变量及范围，通过枚举判断来求解。

• 洛谷相似题目：
    - P1072 [NOIP2009 普及组] Hankson 的趣味题，涉及数论中最大公约数和最小公倍数相关等式的正整数解问题。
    - P2152 [SDOI2009] 超级钢琴，虽不完全是数论等式求解，但同样需要根据给定条件确定枚举范围来优化算法，与本题思路有相通之处。
    - P1572 [NOI2016] 循环之美，涉及分数的循环节相关问题，需通过数论知识和合理的枚举判断来解决。

• 个人心得摘录与总结：
无。 

---
处理用时：38.04秒
# 题目信息

# 「PMOI-4」人赢

## 题目背景

众所周知，ducati 是人 win。

现在 lhm 也想成为人 win，于是 ducati 扔给了 lhm 下面这道题，并且 ducati 承诺在 lhm 完成此题后教他如何成为人 win。

## 题目描述

现在 lhm 手中有一个无穷长的衔尾数列 $a$，它满足：

- 对于数列中的每一个 $a_i(i>2)$，它总为 $a_{i-2} \times a_{i-1}$ 的**个位数**。

ducati 将给 lhm 衔尾数列的前两位 $a_1=n,a_2=m$ 与位置 $k$，它的任务是算出 $a_k$。

由于 lhm 太菜了并不会这道题，但他仍然想成为人 win，所以他只好请聪明的你来帮他完成这个问题。

## 说明/提示

【样例解释 $1$】

数列 $1$ 至 $10$ 位依次为：$1,6,6,6,6,6,6,6,6,\color{red}{6}$。所以答案为 $6$。

【样例解释 $2$】

数列 $1$ 至 $7$ 位依次为：$7,2,4,8,2,6,\color{red}{2}$。所以答案为 $2$。


【数据范围】

**本题采用捆绑测试**。

- Subtask 1（30pts）：$1 \leq k \leq 10^6$。
- Subtask 2（70pts）：无特殊限制。

对于 $100\%$ 的数据，$0 \leq n,m \leq 9$，$1 \leq k \leq 10^{12}$。

## 样例 #1

### 输入

```
1 6 10```

### 输出

```
6```

## 样例 #2

### 输入

```
7 2 7```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解利用数列循环节特性解题。部分通过暴力枚举找循环节（如ycw123、Cripple_Abyss等）；部分观察到数列项可表示为\(n^{e_1}m^{e_2}\)形式，\(e_1\)、\(e_2\)满足斐波那契数列规律，借助矩阵快速幂求斐波那契数，再结合快速幂求解（如Exber、Remake_等）。还有通过找规律猜测循环节固定为6次（如Thomas_Cat）。
    - 算法要点：暴力枚举时注意计算个位数防止溢出；找循环节可通过记录数对出现位置实现；利用矩阵快速幂优化求斐波那契数从而计算指数。
    - 解决难点：关键在于处理大数据规模下的计算效率问题。通过找循环节或利用斐波那契数列规律结合矩阵快速幂优化时间复杂度。
    - 整体看，找循环节和利用斐波那契数列规律结合矩阵快速幂是主流思路，各有优劣。找循环节实现相对简单直观，矩阵快速幂理论性更强，时间复杂度更低。

所选的题解：
  - 作者：Exber (赞：14)  星级：4星
    - 关键亮点：思路清晰，将数列项表示为\(n^{Fib(x - 2)}\cdot m^{Fib(x - 1)}\mod 10\)形式，利用矩阵快速幂求斐波那契数，再套快速幂求解，时间复杂度\(O(\log k)\)，代码实现简洁明了。
    - 重点代码：
```cpp
struct node // 矩阵 
{
    long long a[5][5],mod;
    node()
    {
        memset(a,0,sizeof(a));
    }
    void operator*=(node b) // 矩阵乘法 
    {
        node tmp;
        for(int i=1;i<=2;++i)
        {
            for(int j=1;j<=2;++j)
            {
                for(int k=1;k<=2;++k)
                {
                    tmp.a[i][j]+=a[i][k]*b.a[k][j]%mod;
                    tmp.a[i][j]%=mod;
                }
            }
        }
        for(int i=1;i<=2;++i)
        {
            for(int j=1;j<=2;++j)
            {
                a[i][j]=tmp.a[i][j]%mod;
            }
        }
    }
};

int n,m;
long long k;

inline long long fbnq(long long q,long long mod) // 矩阵快速幂求斐波那契数列第 q 项 
{
    if(q<=2)
    {
        return 1;
    }
    else
    {
        node ans,tmp;
        ans.mod=mod;
        tmp.mod=mod;
        for(int i=1;i<=2;i++)
        {
            ans.a[1][i]=1;
        }
        tmp.a[1][1]=1;
        tmp.a[1][2]=1;
        tmp.a[2][1]=1;
        q-=2;
        while(q)
        {
            if(q&1)
            {
                ans*=tmp;
            }
            tmp*=tmp;
            q>>=1;
        }
        return ans.a[1][1]%mod;
    }
}

inline long long qpow(long long a,long long b,long long mod) // 快速幂 
{
    long long res=1,x=a;
    while(b)
    {
        if(b&1)
        {
            res*=x;
            res%=mod;
        }
        x*=x;
        x%=mod;
        b>>=1;
    }
    return res;
}
```
核心实现思想：定义矩阵结构体及矩阵乘法运算符重载，通过矩阵快速幂函数`fbnq`求斐波那契数列第`q`项，快速幂函数`qpow`求\(a^b\mod mod\)。
  - 作者：Remake_ (赞：8)  星级：4星
    - 关键亮点：同样利用数列项\(n^{e_1}m^{e_2}\)形式，指出\(e_1\)、\(e_2\)满足的递推关系并使用矩乘优化，同时考虑到拓展欧拉定理使用条件，对\(k\)大小进行分类讨论，解法全面。
    - 重点代码：
```cpp
ll qp(ll b,ll p){
    ll ans=1,base=b;
    while(p){
        if(p&1) ans=ans*base%10;
        base=base*base%10;
        p>>=1;
    }
    return ans;
}
struct node{
    ll a[5][5];
    void clear(){rep(i,1,2) rep(j,1,2) a[i][j]=0;}
    void dw(){clear();rep(i,1,2) a[i][i]=1;}
    void init(){clear();a[1][2]=a[2][1]=a[1][1]=1;}
}B;
node mul(node x,node y){
    node z;
    z.clear();
    rep(i,1,2) rep(j,1,2) rep(k,1,2) z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j])%mod;
    return z;
}
node qpp(node b,ll p){
    node ans,base=b;
    ans.dw();
    while(p){
        if(p&1) ans=mul(ans,base);
        base=mul(base,base);
        p>>=1;
    }
    return ans;
}
```
核心实现思想：定义快速幂函数`qp`，矩阵结构体`node`并实现矩阵清零`clear`、单位矩阵`dw`、初始化`init`操作，以及矩阵乘法`mul`和矩阵快速幂`qpp`函数。
  - 作者：Thomas_Cat (赞：26)  星级：4星
    - 关键亮点：对不同数据范围采用不同策略，先暴力解决小数据，再通过枚举部分情况找规律，猜测循环节为6次，思路具有启发性，代码简洁易懂。
    - 重点代码：
```cpp
int main(){
    long long n,m,k;
    cin>>n>>m>>k;
    int a[10],b[7];
    a[1]=n,a[2]=m;
    for(int i=3;i<=9;i++)
        a[i]=(a[i-1]%10*a[i-2]%10)%10;
    cout<<a[(k-3)%6+3];
    return 0;
}
```
核心实现思想：先初始化数列前两项，通过循环计算出一个可能的循环节内的值，最后根据猜测的循环节公式计算并输出结果。

最优关键思路或技巧：
    - 思维方式上，观察数列规律，将其转化为可利用数学工具（如斐波那契数列、循环节）解决的问题。
    - 算法优化上，对于大数据规模，使用矩阵快速幂优化求斐波那契数，降低时间复杂度；或通过找循环节减少计算量。
    - 代码实现技巧，注意计算个位数时防止溢出，如计算\(a_i=(a_{i - 1}\bmod 10) \times (a_{i - 2}\bmod 10) \bmod 10\)。

可拓展之处：同类型题常涉及找数列规律、循环节或利用矩阵快速幂优化递推关系。类似算法套路如处理周期性数列问题，先找循环节，再利用取模运算求解指定项；对于形如\(a_n = f(a_{n - 1}, a_{n - 2})\)的递推数列，若规模大，考虑矩阵快速幂优化。

推荐洛谷题目：
    - P1962 斐波那契数列：经典斐波那契数列问题，可练习矩阵快速幂优化。
    - P3390 【模板】矩阵快速幂：模板题，加深对矩阵快速幂的理解和运用。
    - P1349 广义斐波那契数列：拓展斐波那契数列问题，锻炼利用矩阵快速幂解决变形问题的能力。

个人心得：
    - Remake_提到考场循环节打挂所以采用矩乘+拓展欧拉定理方法，说明在考试或做题时，若一种思路受阻，应及时转换思维，尝试其他方法。 

---
处理用时：47.38秒
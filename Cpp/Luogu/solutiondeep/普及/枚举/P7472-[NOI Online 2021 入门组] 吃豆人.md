# 题目信息

# [NOI Online 2021 入门组] 吃豆人

## 题目描述

有一个 $n$ 行 $n$ 列的正方形点阵，左上角点坐标为 $(1, 1)$，右下角点坐标为 $(n, n)$。

点阵中每个整点上都有数量不一的豆子，坐标为 $(i, j)$ 的点上有 $a_{i,j}$ 个豆子。

你可以放置吃豆人，可以将点阵中任意的整点作为吃豆人的初始位置，再给定左上、左下、右上、右下之一作为吃豆人的初始方向。

吃豆人会不断沿初始方向行进，吃光遇到的所有豆子，直到碰到点阵的边界，此时：

1. 如果吃豆人处于正方形点阵四个角之一的位置，那么就会停止行动；

2. 否则，吃豆人的行进路线将以这条边界为镜面发生反射，下图展示了一个路径某两次发生反射的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/6tji95nq.png)

现在，你需要放置两个吃豆人，求两个吃豆人最多共能吃到多少个豆子？注意同一个豆子只能被吃一次。


## 说明/提示

### 样例 1 解释

在 $(1, 1)$ 和 $(1, 3)$ 位置放置吃豆人，初始方向分别为右下和左下，即可吃到位于
$(1, 1)$，$(1, 3)$，$(2, 2)$，$(2, 4)$，$(3, 1)$，$(3, 3)$，$(4, 2)$，$(4, 4)$ 位置上的豆子，总个数为 $132$，
达到最大，路径分别如下图绿线和红线所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/1axaad1b.png)

### 数据范围

对于 $30\%$ 的数据，$n\leq 3$。

对于 $60\%$ 的数据：$n\leq 100$。

对于 $100\%$ 的数据：$2\leq n\leq 1000$，$0\leq a_{i,j}\leq 1000$。

数据由 [SSerxhs](https://www.luogu.com.cn/user/29826) 和 [Karry5307](https://www.luogu.com.cn/user/60990) 共同提供。

感谢 [Silence_water](https://www.luogu.com.cn/user/338630) 提供一组 hack 数据。

## 样例 #1

### 输入

```
4
20 1 19 2
3 18 4 17
16 5 15 6
7 14 8 13```

### 输出

```
132```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解发现吃豆人的路径可由第一行的点出发确定，形成矩形或对角线，通过预处理这些路径上豆子数，再枚举两条路径并处理重叠部分来求解。部分题解还提到暴力解法，适用于小数据规模。
    - 算法要点：利用第一行点确定路径，$O(n^2)$ 预处理路径豆子和，$O(n^2)$ 枚举两条路径，结合分类讨论处理重叠豆子数，总体时间复杂度 $O(n^2)$。
    - 解决难点：主要难点是确定路径重叠部分豆子数。各题解通过找规律、利用对称性、结合平面直角坐标系等方法，根据路径编号差值的奇偶性及路径类型（对角线或回路）进行分类讨论求解。

    - 评分情况：
        - Mine_King：思路清晰，通过画图找规律得出路径性质，代码简洁明了，对重叠部分分类讨论详细，得5星。
        - Hanx16Kira：介绍多种解法，对每种解法分析较详细，代码实现完整，但整体表述稍显繁琐，得4星。
        - Terac：思路明确，利用边上点确定矩阵，对重叠部分分类讨论合理，代码逻辑清晰，得4星。

  - 所选题解：
    - Mine_King（5星）
      - 关键亮点：通过画图观察得出路径的多条性质，如路径数量、类型、编号与交点关系等，基于这些性质对重叠部分分类讨论，代码实现简洁高效。
      - 核心代码片段：
```cpp
int repeat(int x,int y)//这里判共同经过的点的豆子数量
{
    if((y - x) % 2) return 0;//无共同经过的点
    if(x == 1 && y == n) return a[(n + 1) / 2][(n + 1) / 2];//两条对角线
    if(x == 1) return a[(y + 1) / 2][(y + 1) / 2]+a[(2 * n - y + 1) / 2][(2 * n - y + 1) / 2];//第一条对角线和回路
    if(y == n) return a[(n - x) / 2 + 1][(n + x) / 2]+a[(n + x) / 2][(n - x) / 2 + 1];//第二条对角线和回路
    return a[(x + y) / 2][(y - x) / 2 + 1]+a[(y - x) / 2 + 1][(x + y) / 2]+a[n - (y - x) / 2][n - (x + y) / 2 + 1]+a[n - (x + y) / 2 + 1][n - (y - x) / 2];//两条回路
}
```
      - 核心实现思想：根据路径编号差值的奇偶性判断是否有重叠点，若有则按路径类型（对角线或回路）分别计算重叠点的豆子数。

    - Hanx16Kira（4星）
      - 关键亮点：详细介绍从暴力到优化的多种解法，对正解中利用平面直角坐标系求交点坐标的方法阐述清晰，代码实现完整。
      - 核心代码片段：
```cpp
for (int i = 1;i <= n;i++)
{
    for (int j = 1;j <= n;j++)
    {
        scanf("%d",&a[i][j]);
        sum1[i][j]=sum1[i - 1][j - 1]+a[i][j];//计算斜线的权值和，计算方法类似前缀和
        sum2[i][j]=sum2[i - 1][j + 1]+a[i][j];
    }
}
//输入
for (int i = 1;i <= n;i++)
{
    if (i == 1 || i == n)//判断为对角线的情况
    {
        if (i == 1)
            sum3[i]=sum1[n][n];
        else
            sum3[i]=sum2[n][1];
    }
    else
        sum3[i]=sum1[n][n - i + 1]+sum1[n - i + 1][n]+sum2[i][1]+sum2[n][n - i + 1]-a[1][i]-a[i][1]-a[n - i + 1][n]-a[n][n - i + 1];//找到矩阵四条边的权值和加起来减去重叠部分计算矩阵边上的权值和
}
//计算矩阵
int ans = -1;//准备寻找答案，因为答案一定为正整数所以将ans初值赋为-1
for (int i = 1;i <= n;i++)//枚举第一个吃豆人的起点
{
    for (int j = i + 1;j <= n;j++)//枚举第二个吃豆人的起点，避免重复所以从i+1开始枚举
    {
        int t;//暂时存放计算结果
        if ((j - i) % 2 == 0)//当顶点横坐标差为偶数的时候
        {
            int x1 = 1+(j - i)/2,y1 = (i + j)/2;//第一个交点
            int x2 = y1,y2 = x1;//第二个交点（利用对称性）
            int x3 = n - y1 + 1,y3 = n - x1 + 1;//第三个交点
            int x4 = y3,y4 = x3;//第四个
            if (x1 == x2 && x2 == x3 && x3 == x4)
                //当两个都是对角线的情况，也就是四个交点都重合的时候
                t = sum3[i]+sum3[j]-a[x1][y1];//只需减去唯一一个交点
            else if (x1 == x2 && x3 == x4 && x1!= x3)
                //当有两个交点时，分别判断是x1与x2相同还是x1与x3相同
                t = sum3[i]+sum3[j]-a[x1][y1]-a[x3][y3];//减去两个交点
            else if (x1 == x3 && x2 == x4 && x1!= x2)
                //x1与x3相同
                t = sum3[i]+sum3[j]-a[x1][y1]-a[x2][y2];//减去两个交点
            else
                //四个交点都不重合的时候
                t = sum3[i]+sum3[j]-a[x1][y1]-a[x2][y2]-a[x3][y3]-a[x4][y4];//减去四个交点
        }
        else
        {
            //当顶点横坐标差为奇数时，两个矩形没有交点，这点可以通过画图得出
            t = sum3[i]+sum3[j];//直接加和，不需要去除重叠部分
        }
        ans = max(ans,t);//与已有的最大值比较，找出最大值
    }
}
```
      - 核心实现思想：先通过类似前缀和方式预处理斜线权值和，进而得到每个矩阵边上权值和。枚举两个路径起点，根据起点横坐标差的奇偶性及交点情况计算最终豆子总数。

    - Terac（4星）
      - 关键亮点：利用边上点确定矩阵，通过分析矩阵重叠情况，结合中点坐标等知识对重叠部分分类讨论，代码简洁高效。
      - 核心代码片段：
```cpp
for(int i = 1; i <= n; i++)
    c[1] += a[i][i], c[n] += a[i][n - i + 1];
for(int i = 2; i < n; i++) {
    int x = 1, y = i, op = 0, sum = 0;
    bool flag = false;
    for(;;) {
        if(x == 1 && y == i && flag) {
            c[i] = sum;
            break;
        }
        sum += a[x][y];
        flag = true;
        if(x + kx[op] <= 0 || x + kx[op] > n || y + ky[op] <= 0 || y + ky[op] > n)
            op++;
        x += kx[op], y += ky[op];
    }
}
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= n; j++) {
        if(i == j)
            continue;
        int mx = max(i, j), mn = min(i, j);
        if((mx - mn) & 1) {
            ans = max(ans, c[i] + c[j]);
        }
        else if(mn == 1 && mx == n) {
            int t = c[i] + c[j] - a[(i + j) / 2][(i + j) / 2];
            ans = max(ans, t);
        }
        else {
            int t = c[i] + c[j];
            t -= a[1+(mx - mn)/2][(i + j)/2];
            t -= a[n-(mx - mn)/2][n-(i + j)/2 + 1]; 
            if(mn == 1 || mx == n)
                ans = max(ans, t);
            else {
                t -= a[(i + j)/2][1+(mx - mn)/2];
                t -= a[n-(i + j)/2 + 1][n-(mx - mn)/2];
                ans = max(ans, t);
            }
        }
    }
```
      - 核心实现思想：先预处理出每个矩阵的点权之和，枚举两个矩阵，根据矩阵编号差值的奇偶性及是否为对角线情况，计算重叠部分并得出最终结果。

• 最优关键思路或技巧：
    - 利用第一行点确定吃豆人路径，简化问题规模。
    - 通过画图找规律，发现路径性质及重叠部分规律，利用对称性、中点坐标等知识对重叠部分分类讨论。

• 可拓展之处：
此类题目属于路径规划与重叠处理问题，类似套路为通过观察路径特点，利用对称性、周期性等简化问题，结合分类讨论处理重叠情况。同类型题可考虑路径方向更多变、地图形状更复杂等情况。

• 相似知识点洛谷题目：
    - P1339 热浪：涉及图的遍历与路径权值计算。
    - P1162 填涂颜色：与区域划分和边界处理相关。
    - P1443 马的遍历：同样是路径搜索与标记问题。

• 个人心得摘录与总结：
    - Unordered_OIer提到考场上因小 bug 导致分数大幅下降，强调了细节处理在算法竞赛中的重要性。
    - Hanx16Kira首次写题解，希望大家包容，体现写题解分享思路的不易与勇气。 

---
处理用时：57.90秒
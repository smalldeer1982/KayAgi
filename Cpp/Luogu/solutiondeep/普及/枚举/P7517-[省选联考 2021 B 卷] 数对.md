# 题目信息

# [省选联考 2021 B 卷] 数对

## 题目描述

给定 $n$ 个正整数 $a_i$，请你求出有多少个数对 $(i, j)$ 满足 $1 \le i \le n$，$1 \le j \le n$，$i \ne j$ 且 $a_i$ 是 $a_j$ 的倍数。

## 说明/提示

对于 $40 \%$ 的数据，$n \le 1000$。  
对于 $70 \%$ 的数据，$1 \le a_i \le 5 \times {10}^3$。  
对于 $100 \%$ 的数据，$2 \le n \le 2 \times {10}^5$，$1 \le a_i \le 5 \times {10}^5$。

## 样例 #1

### 输入

```
6
16 11 6 1 9 11
```

### 输出

```
7
```

## 样例 #2

### 输入

```
见附件中的 pair/pair2.in。```

### 输出

```
见附件中的 pair/pair2.ans。```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效统计满足条件数对展开，核心思路有枚举因数、枚举倍数以及分块处理。
1. **枚举因数思路**：对每个数$a_i$，用$\sqrt{a_i}$时间枚举其因数，用桶记录因数出现次数，最后累加答案。如作者LZH_LOVE_ZRG的Solution 1，时间复杂度$O(\sum\limits_{i=1}^{i<=n} \sqrt{a_i}+n)$。
2. **枚举倍数思路**：对每个数$a_i$，枚举其倍数并累加贡献，桶记录数出现次数。像作者LZH_LOVE_ZRG的Solution 2、清烛、huayucaiji、MSqwq、phigy、Hexarhy、HSY666，时间复杂度为调和级数$O(\max{a_i} \times \log{\max{a_i}})$ ，其中HSY666对$i = 1$情况做了优化。
3. **分块处理思路**：作者y0y68将数按与$K$大小关系分组，第一组内暴力计算，第二组开桶枚举倍数统计，还考虑两组间关系，时间复杂度$O(n \log n +K^2+nK+\frac{5n \times 10^5}{K+1})$，$K$取$10^3$较优。

综合质量来看，多数题解思路清晰，但部分代码可读性欠佳，优化程度有差异。整体没有特别突出达到5星的题解，部分题解接近4星。

### 推荐题解
1. **作者LZH_LOVE_ZRG的题解**：★★★★
    - **关键亮点**：提供两种思路，枚举因数和枚举倍数，思路清晰，代码简洁且注释详细，能帮助理解。
    - **核心代码（Solution 2）**：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define il inline
using namespace std;
const int N=5e5+10;
int read(){
    int f=1,s=0;
    char x=getchar();
    while(x<'0'||x>'9'){
        if(x=='-') f=-1;
        x=getchar();
    }
    while(x>='0'&&x<='9'){
        s=s*10+x-'0';
        x=getchar();
    }
    return f*s;
}
int a[N],b[N];
int main(){
    int n=read();
    for(int i=1;i<=n;i++)
        b[read()]++;
    ll ans=0;
    for(int i=1;i<=N;i++){
        for(int j=2;i*j<=N;j++)
            ans+=b[i]*b[i*j];
        ans+=b[i]*(b[i]-1);
    }
    cout<<ans;
    return 0;
}
```
    - **核心思想**：先读入数据并用桶b记录每个数出现次数，然后遍历所有可能数i，对每个i枚举其倍数i*j，累加b[i]*b[i*j]，同时加上i自身作为倍数的贡献b[i]*(b[i] - 1)。

2. **作者y0y68的题解**：★★★★
    - **关键亮点**：提出分块独特思路，通过合理分组和处理，在不同组采用不同策略，有效优化时间复杂度。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=2e5+5;
const int M=5e5+5;
int n,a[N],st[M],ed[M],cnt[M],tmp[N];
inline void in(int &x){
    char c;
    for(c=getchar();c<'0'||c>'9';c=getchar());
    for(;c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+(c^48);
}
int main(){
    freopen("pair.in","r",stdin);
    freopen("pair.ans","w",stdout);
    in(n);
    for(int i=1;i<=n;i++)in(a[i]);
    sort(a+1,a+n+1);
    for(int i=n;i>=1;i--)st[a[i]]=i;
    for(int i=1;i<=n;i++)ed[a[i]]=i;
    int pos=1;
    for(;pos<=n&&a[pos]<=1000;cnt[a[pos]]++,pos++);
    long long ans=0;
    for(register int i=1;i<pos;i++)tmp[i]=a[i];
    int tot=unique(tmp+1,tmp+pos)-tmp-1;
    for(register int i=1;i<=tot;i++)
        for(register int j=pos;j<=n;j++)
            if(a[j]%tmp[i]==0)ans+=cnt[tmp[i]];
    for(register int i=1;i<tot;i++)
        for(register int j=i+1;j<=tot;j++)
            if(tmp[j]%tmp[i]==0)ans+=1ll*cnt[tmp[j]]*cnt[tmp[i]];
    for(int i=1;i<=1000;i++)
        if(cnt[i])ans+=1ll*cnt[i]*(cnt[i]-1);
    if(pos>n){
        printf("%lld\n",ans);
        return 0;
    }
    for(register int i=pos;i<=n;i++)
        for(register int j=(a[i]<<1);j<M;j+=a[i])cnt[j]++;
    for(register int i=pos;i<=n;i++)
        ans+=cnt[a[i]];
    for(register int i=1001;i<=500000;i++)
        if(st[i])ans+=1ll*(ed[i]-st[i]+1)*(ed[i]-st[i]);
    printf("%lld\n",ans);
    return 0;
}
```
    - **核心思想**：先排序并记录每个数首次和最后出现位置，按数与1000大小分组。第一组去重后暴力计算组内及与第二组间倍数关系；第二组开桶枚举倍数统计，最后处理第二组内重复情况。

3. **作者清烛的题解**：★★★★
    - **关键亮点**：思路简洁明了，直接开桶记录每个数出现次数，枚举每个数的倍数计算贡献，代码逻辑清晰。
    - **核心代码**：
```cpp
#include <cstdio>
#include <cctype>
#define rint register int
#define il inline
#define FOR(i, a, b) for (rint i = a; i <= b; ++i)
#define DEC(i, a, b) for (rint i = a; i >= b; --i)

typedef long long ll;

const int maxn = 2e5 + 5, maxk = 5e5 + 5;

il int mymax(int a, int b) {return a > b? a : b;}

int n, a[maxn], cnt[maxk], maxa;
ll ans[maxk];

int main()
{
    freopen("pair.in", "r", stdin);
    freopen("pair.out", "w", stdout);
    n = read();
    FOR(i, 1, n) cnt[a[i] = read()]++, maxa = mymax(a[i], maxa);
    FOR(i, 1, n)
    {
        if (ans[a[i]]) continue;
        for (int k = 1; a[i] && a[i] * k <= maxa; ++k)
            ans[a[i]] += cnt[a[i] * k] - (k == 1);
    }
    ll Ans = 0;
    FOR(i, 1, n)
        Ans += ans[a[i]];
    printf("%lld\n", Ans);
    return 0;
}
```
    - **核心思想**：读入数据同时用桶cnt记录每个数出现次数并记录最大值maxa，遍历每个数a[i]，若ans[a[i]]已计算过则跳过，否则枚举其倍数a[i]*k，累加cnt[a[i]*k]并减去自身重复情况(k == 1)，最后累加所有ans[a[i]]得到答案。

### 最优关键思路或技巧
枚举倍数结合桶统计是较优思路，利用调和级数特性控制时间复杂度。如遇到统计倍数关系且值域有限问题，可考虑此方法。同时，y0y68的分块思想在处理大规模数据时能有效优化复杂度，对于不同规模数据采用不同策略值得借鉴。

### 同类型题或类似算法套路
同类型题通常围绕数论中倍数、因数关系，结合数据范围选择合适枚举策略。常见套路有根据值域开桶统计，枚举因数或倍数时利用数学性质优化，如sqrt优化枚举因数，调和级数优化枚举倍数。

### 推荐洛谷题目
1. **P1306 斐波那契公约数**：涉及数论知识，需利用斐波那契数列性质和最大公约数关系求解，锻炼数论分析和代码实现能力。
2. **P2398 GCD SUM**：要求计算一系列数对最大公约数之和，需运用数论知识和枚举优化技巧，与本题枚举倍数思想类似。
3. **P1890 [USACO03NOV] 猜数游戏Haybale Guessing**：结合二分查找和区间统计，可类比本题对数据的处理和统计方式，提升综合解题能力。

### 个人心得摘录与总结
暂无明显个人心得（调试经历、踩坑教训、顿悟感想等）在题解中体现。 

---
处理用时：59.59秒
# 题目信息

# [CSP-J 2021] 插入排序

## 题目描述

插入排序是一种非常常见且简单的排序算法。小 Z 是一名大一的新生，今天 H 老师刚刚在上课的时候讲了插入排序算法。

假设比较两个元素的时间为 $\mathcal O(1)$，则插入排序可以以 $\mathcal O(n^2)$ 的时间复杂度完成长度为 $n$ 的数组的排序。不妨假设这 $n$ 个数字分别存储在 $a_1, a_2, \ldots, a_n$ 之中，则如下伪代码给出了插入排序算法的一种最简单的实现方式：

这下面是 C/C++ 的示范代码：

```cpp
for (int i = 1; i <= n; i++)
	for (int j = i; j >= 2; j--)
		if (a[j] < a[j-1]) {
			int t = a[j-1];
			a[j-1] = a[j];
			a[j] = t;
		}
```

这下面是 Pascal 的示范代码：

```pascal
for i:=1 to n do
	for j:=i downto 2 do
		if a[j]<a[j-1] then
			begin
				t:=a[i];
				a[i]:=a[j];
				a[j]:=t;
			end;
```

为了帮助小 Z 更好的理解插入排序，小 Z 的老师 H 老师留下了这么一道家庭作业：

H 老师给了一个长度为 $n$ 的数组 $a$，数组下标从 $1$ 开始，并且数组中的所有元素均为非负整数。小 Z 需要支持在数组 $a$ 上的 $Q$ 次操作，操作共两种，参数分别如下：

$1~x~v$：这是第一种操作，会将 $a$ 的第 $x$ 个元素，也就是 $a_x$ 的值，修改为 $v$。保证 $1 \le x \le n$，$1 \le v \le 10^9$。**注意这种操作会改变数组的元素，修改得到的数组会被保留，也会影响后续的操作**。

$2~x$：这是第二种操作，假设 H 老师按照**上面的伪代码**对 $a$ 数组进行排序，你需要告诉 H 老师原来 $a$ 的第 $x$ 个元素，也就是 $a_x$，在排序后的新数组所处的位置。保证 $1 \le x \le n$。**注意这种操作不会改变数组的元素，排序后的数组不会被保留，也不会影响后续的操作**。

H 老师不喜欢过多的修改，所以他保证类型 $1$ 的操作次数不超过 $5000$。

小 Z 没有学过计算机竞赛，因此小 Z 并不会做这道题。他找到了你来帮助他解决这个问题。

## 说明/提示

**【样例解释 #1】**

在修改操作之前，假设 H 老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是 $3, 2, 1$。

在修改操作之后，假设 H 老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是 $3, 1, 2$。

注意虽然此时 $a_2 = a_3$，但是我们**不能将其视为相同的元素**。

**【样例 #2】**

见附件中的 `sort/sort2.in` 与 `sort/sort2.ans`。

该测试点数据范围同测试点 $1 \sim 2$。

**【样例 #3】**

见附件中的 `sort/sort3.in` 与 `sort/sort3.ans`。

该测试点数据范围同测试点 $3 \sim 7$。

**【样例 #4】**

见附件中的 `sort/sort4.in` 与 `sort/sort4.ans`。

该测试点数据范围同测试点 $12 \sim 14$。

**【数据范围】**

对于所有测试数据，满足 $1 \le n \le 8000$，$1 \le Q \le 2 \times {10}^5$，$1 \le x \le n$，$1 \le v,a_i \le 10^9$。

对于所有测试数据，保证在所有 $Q$ 次操作中，至多有 $5000$ 次操作属于类型一。

各测试点的附加限制及分值如下表所示。

| 测试点 | $n \le$ | $Q \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $10$ | $10$ | 无 |
| $5 \sim 9$ | $300$ | $300$ | 无 |
| $10 \sim 13$ | $1500$ | $1500$ | 无 |
| $14 \sim 16$ | $8000$ | $8000$| 保证所有输入的 $a_i,v$ 互不相同 |
| $17 \sim 19$ | $8000$ | $8000$ | 无 |
| $20 \sim 22$ | $8000$ | $2 \times 10^5$ | 保证所有输入的 $a_i,v$ 互不相同 |
| $23 \sim 25$ | $8000$ | $2 \times 10^5$ | 无 |

## 样例 #1

### 输入

```
3 4
3 2 1
2 3
1 3 2
2 2
2 3
```

### 输出

```
1
1
2
```

# AI分析结果

• 综合分析与结论：
    - 这些题解主要围绕如何高效处理插入排序中的单点修改和查询原元素在排序后位置的操作。由于修改操作次数不超过5000次，多数题解思路是在修改操作上做文章，尽量降低其时间复杂度，同时保证查询操作高效。
    - 算法要点包括维护原下标与排序后下标的关系、利用排序的稳定性、借助数据结构（如平衡树、树状数组、线段树等）或模拟插入排序的局部操作来优化。
    - 解决难点在于如何在满足题目操作要求（修改影响后续，查询不保留排序结果）的前提下，设计出高效的算法，避免每次查询都进行完整排序导致的超时问题。
    - 综合质量来看，以下3篇题解相对优秀：
  - 作者：Otomachi_Una_ 星级：5星
    - 关键亮点：思路清晰，通过维护有序数列及原下标与新下标的关系数组，利用前后各冒泡一次的方式，保证每次修改操作后数列仍有序，使得修改操作时间复杂度为O(n)，查询操作时间复杂度为O(1)。
    - 个人心得：无
    - 重点代码及核心实现思想：
```cpp
// 结构体定义，用于存储元素值及原下标
struct node{
    int pre,id;
}a[MAXN];
// 比较函数，定义元素优先级
bool cmp(node x,node y){
    if(x.pre!=y.pre) return x.pre<y.pre;
    return x.id<y.id;
}
// 排序及初始化关系数组
sort(a+1,a+n+1,cmp);
for(int i=1;i<=n;i++)
    t[a[i].id]=i;
// 修改操作，更新元素值后前后冒泡调整顺序并更新关系数组
if(opt==1){
    scanf("%d%d",&x,&v);
    a[t[x]].pre=v;
    for(int j=n;j>=2;j--)
        if(cmp(a[j],a[j-1])){
            node kkksc03=a[j];
            a[j]=a[j-1];
            a[j-1]=kkksc03;
        }
    for(int j=2;j<=n;j++)
        if(cmp(a[j],a[j-1])){
            node kkksc03=a[j];
            a[j]=a[j-1];
            a[j-1]=kkksc03;
        }
    for(int i=1;i<=n;i++)
        t[a[i].id]=i;
}
// 查询操作，直接输出关系数组对应值
else{
    scanf("%d",&x);
    printf("%d\n",t[x]);
}
```
  - 作者：chenpengda 星级：4星
    - 关键亮点：通过维护数组b储存各数在数组a中的相对排名，利用插入排序后数的位置判定条件，在每次修改操作时，通过O(n)遍历数组更新相对排名，查询操作直接输出对应排名，时间复杂度为O(1)。
    - 个人心得：无
    - 重点代码及核心实现思想：
```cpp
// 输入时统计各数相对排名
for(int i=1;i<=n;i++){
    for(int j=1;j<=i;j++){
        if(i==j||a[j]<a[i]||a[j]==a[i])b[i]++;
        else b[j]++;
    }
}
// 修改操作，根据判定条件更新相对排名
if(num==1){
    scanf("%d%d",&x,&v);
    for(int i=1;i<=n;i++){
        if(i==x)continue;
        if((a[i]<a[x]||a[i]==a[x]&&i<x)&&(a[i]>v||a[i]==v&&i>x)){
            b[i]++;b[x]--;
        }
        else if((a[i]>a[x]||a[i]==a[x]&&i>x)&&(a[i]<v||a[i]==v&&i<x)){
            b[i]--;b[x]++;
        }
    }
    a[x]=v;
}
// 查询操作，输出相对排名
if(num==2){
    scanf("%d",&x);
    printf("%d\n",b[x]);
}
```
  - 作者：Astatinear 星级：4星
    - 关键亮点：先对原数组排序并维护tot数组记录原数组元素在排序后数组的位置。每次修改操作时，运用冒泡思想将修改的数往前或往后挤，同时更新tot数组，使得查询操作可O(1)输出结果。
    - 个人心得：无
    - 重点代码及核心实现思想：
```cpp
// 结构体定义及排序方式
struct node{
    int a,id;
    bool operator <(const node &n)const{
        return a<n.a||(a==n.a&&id<n.id);
    }
}arr[100005];
// 排序后初始化tot数组
sort(arr+1,arr+n+1);
for(int i=1;i<=n;++i){
    tot[arr[i].id]=i;
}
// 修改操作，先更新值，再前后挤并更新tot数组
if(op==1){
    scanf("%d",&y);
    s=tot[x];
    arr[tot[x]].a=y;
    for(int i=s-1;i>=1;--i){
        if(arr[i].a>y||(arr[i].a==y&&x<arr[i].id)){
            swap(tot[x],tot[arr[i].id]);
            swap(arr[s],arr[i]);
            s=tot[x];
        }
        else
        break;
    }
    for(int i=s+1;i<=n;++i){
        if(arr[i].a<y||(arr[i].a==y&&x>arr[i].id)){
            swap(tot[x],tot[arr[i].id]);
            swap(arr[s],arr[i]);
            s=tot[x];
        }
        else
        break;
    }
}
// 查询操作，直接输出tot数组对应值
else{
    printf("%d\n",tot[x]);
}
```
• 最优关键思路或技巧：利用题目中修改操作次数有限的条件，在修改操作时通过局部调整（如冒泡思想）维持数组的相对有序性，并维护原下标与排序后下标的关系，使得查询操作能够高效进行。
• 可拓展思路：此类题目可拓展到其他排序算法下的类似操作，或者增加操作类型，如区间修改等。类似算法套路是在操作次数有限制的情况下，尽量在有限操作上优化时间复杂度，同时通过数据结构或数组维护关键信息以加速查询。
• 相似知识点洛谷题目：
    - P1908 逆序对
    - P3810 【模板】三维偏序（陌上花开）
    - P2617 Dynamic Rankings

---
处理用时：39.85秒
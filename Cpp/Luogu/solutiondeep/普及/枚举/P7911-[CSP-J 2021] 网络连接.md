# 题目信息

# [CSP-J 2021] 网络连接

## 题目描述

TCP/IP 协议是网络通信领域的一项重要协议。今天你的任务，就是尝试利用这个协议，还原一个简化后的网络连接场景。

在本问题中，计算机分为两大类：服务机（`Server`）和客户机（`Client`）。服务机负责建立连接，客户机负责加入连接。

需要进行网络连接的计算机共有 $n$ 台，编号为 $1 \sim n$，这些机器将按编号递增的顺序，依次发起一条建立连接或加入连接的操作。

每台机器在尝试建立或加入连接时需要提供一个地址串。服务机提供的地址串表示它尝试建立连接的地址，客户机提供的地址串表示它尝试加入连接的地址。

一个符合规范的地址串应当具有以下特征：

1. 必须形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为非负整数；
2. $0 \le a, b, c, d \le 255$，$0 \le e \le 65535$；
3. $a, b, c, d, e$ 均不能含有多余的前导 $0$。

相应地，不符合规范的地址串可能具有以下特征：

1. 不是形如 `a.b.c.d:e` 格式的字符串，例如含有多于 $3$ 个字符 `.` 或多于 $1$ 个字符 `:` 等情况；
2. 整数 $a, b, c, d, e$ 中某一个或多个超出上述范围；
3. 整数 $a, b, c, d, e$ 中某一个或多个含有多余的前导 $0$。

例如，地址串 `192.168.0.255:80` 是符合规范的，但 `192.168.0.999:80`、`192.168.00.1:10`、`192.168.0.1:088`、`192:168:0:1.233` 均是不符合规范的。

如果服务机或客户机在发起操作时提供的地址串不符合规范，这条操作将被直接忽略。

在本问题中，我们假定凡是符合上述规范的地址串均可参与正常的连接，你无需考虑每个地址串的实际意义。

由于网络阻塞等原因，不允许两台服务机使用相同的地址串，如果此类现象发生，后一台尝试建立连接的服务机将会无法成功建立连接；除此之外，凡是提供符合规范的地址串的服务机均可成功建立连接。

如果某台提供符合规范的地址的客户机在尝试加入连接时，与先前某台已经成功建立连接的服务机提供的地址串相同，这台客户机就可以成功加入连接，并称其连接到这台服务机；如果找不到这样的服务机，则认为这台客户机无法成功加入连接。

请注意，尽管不允许两台不同的服务机使用相同的地址串，但多台客户机使用同样的地址串，以及同一台服务机同时被多台客户机连接的情况是被允许的。

你的任务很简单：在给出每台计算机的类型以及地址串之后，判断这台计算机的连接情况。

## 说明/提示

**【样例解释 #1】**

计算机 $1$ 为服务机，提供符合规范的地址串 `192.168.1.1:8080`，成功建立连接；

计算机 $2$ 为服务机，提供与计算机 $1$ 相同的地址串，未能成功建立连接；

计算机 $3$ 为客户机，提供符合规范的地址串 `192.168.1.1:8080`，成功加入连接，并连接到服务机 $1$；

计算机 $4$ 为客户机，提供符合规范的地址串 `192.168.1.1:80`，找不到服务机与其连接；

计算机 $5$ 为客户机，提供的地址串 `192.168.1.1:99999` 不符合规范。

**【数据范围】**

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1$ | $10$ | 性质 1 2 3 |
| $2 \sim 3$ | $100$ | 性质 1 2 3 |
| $4 \sim 5$ | $1000$ | 性质 1 2 3 |
| $6 \sim 8$ | $1000$ | 性质 1 2 |
| $9 \sim 11$ | $1000$ | 性质 1 |
| $12 \sim 13$ | $1000$ | 性质 2 |
| $14 \sim 15$ | $1000$ | 性质 4 |
| $16 \sim 17$ | $1000$ | 性质 5 |
| $18 \sim 20$ | $1000$ | 无特殊性质 |

“性质 1”为：保证所有的地址串均符合规范；  
“性质 2”为：保证对于任意两台不同的计算机，如果它们同为服务机或者同为客户机，则它们提供的地址串一定不同；  
“性质 3”为：保证任意一台服务机的编号都小于所有的客户机；  
“性质 4”为：保证所有的地址串均形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为不超过 ${10}^9$ 且不含有多余前导 $0$ 的非负整数；  
“性质 5”为：保证所有的地址串均形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为只含有数字的非空字符串。

对于 $100 \%$ 的数据，保证 $1 \le n \le 1000$。

**【提供 hack 数据感谢】**  

- [xyf007](/user/68273)。

## 样例 #1

### 输入

```
5
Server 192.168.1.1:8080
Server 192.168.1.1:8080
Client 192.168.1.1:8080
Client 192.168.1.1:80
Client 192.168.1.1:99999
```

### 输出

```
OK
FAIL
1
FAIL
ERR
```

## 样例 #2

### 输入

```
10
Server 192.168.1.1:80
Client 192.168.1.1:80
Client 192.168.1.1:8080
Server 192.168.1.1:80
Server 192.168.1.1:8080
Server 192.168.1.999:0
Client 192.168.1.1.8080
Client 192.168.1.1:8080
Client 192.168.1.1:80
Client 192.168.1.999:0
```

### 输出

```
OK
1
FAIL
FAIL
OK
ERR
ERR
5
1
ERR
```

## 样例 #3

### 输入

```
见附件中的 network/network3.in。```

### 输出

```
见附件中的 network/network3.ans。```

## 样例 #4

### 输入

```
见附件中的 network/network4.in。```

### 输出

```
见附件中的 network/network4.ans。```

# AI分析结果

• 综合分析与结论：该题主要考查对网络连接规则的模拟以及地址串合法性判断。多数题解思路是先判断地址串是否合法，再根据计算机类型（服务机或客户机）进行相应处理，常用数据结构为map来记录服务机地址及编号。各题解在判断地址串合法性上方法多样，是解题关键与难点。
  - xyf007题解（5星）
    - 关键亮点：提供两种简洁做法。方法一利用sscanf读取地址串各部分，再用stringstream拼接并与原串对比判断合法性，思路巧妙且代码简洁；方法二使用C++11的regex库，通过正则表达式快速判断合法性，代码量少且高效。
    - 重点代码（方法一判断合法性部分）：
```cpp
bool Check(string s) {
  long long a, b, c, d, port;
  if (sscanf(s.c_str(), "%lld.%lld.%lld.%lld:%lld", &a, &b, &c, &d, &port)!= 5)  return false;
  if (a < 0 || a > 255 || b < 0 || b > 255 || c < 0 || c > 255 || d < 0 || d > 255 || port < 0 || port > 65535)  return false;
  stringstream ss;
  ss << a << '.' << b << '.' << c << '.' << d << ':' << port;
  return ss.str() == s;
}
```
核心实现思想：通过sscanf按特定格式读取地址串各部分，判断读取元素个数及各部分取值范围，再用stringstream拼接成标准地址串与原串对比，相同则地址串合法。
    - 重点代码（方法二判断合法性部分）：
```cpp
regex r("(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5]):(\\d|[1-9]\\d{1,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])");
//...
if (!regex_match(a, r)) { cout << "ERR\n"; continue; }
```
核心实现思想：定义符合地址串格式的正则表达式，使用regex_match函数判断输入地址串是否匹配该正则表达式，匹配则地址串合法。
  - XYY1411题解（4星）
    - 关键亮点：详细讲解正则表达式在本题中的应用，包括正则表达式的原理、具体模式串的构建以及在C++中的使用方法，对理解和学习正则表达式有很大帮助。
    - 重点代码（判断合法性部分）：
```cpp
inline bool check(const string &ip) {
    static const regex ippt("(((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\\:((6553[0-5])|(655[0-2][0-9])|(65[0-4][0-9][0-9])|(6[0-4][0-9][0-9][0-9])|([1-5][0-9][0-9][0-9][0-9])|([1-9][0-9][0-9][0-9])|([1-9][0-9][0-9])|([1-9][0-9])|[0-9])");
    return regex_match(ip, ippt);
}
```
核心实现思想：构建精确匹配地址串格式的正则表达式，通过regex_match函数判断输入地址串与该正则表达式是否匹配，匹配则地址串合法。
  - StayAlone题解（4星）
    - 关键亮点：通过自定义函数分别判断地址串各段的合法性，对每个部分的判断细致，能有效避免因数据范围开大可能出现的问题，且在代码实现上对细节处理较好。
    - 重点代码（判断合法性部分）：
```cpp
il int nlen(int k)
{
	if (!k) return 1;
	int cnt = 0;
	while (k) cnt++, k /= 10;
	return cnt;
}

il bool gnoc(const string s, int &a, int lst, int &idx, const char op)
{
	int len = s.size();
	while (isdigit(s[idx]))
	{
		if (idx >= len) return false;
		a = (a << 1) + (a << 3) + (s[idx++] & 15);
		if (a > 255) return false;
	}
	if (idx + 1 >= len || s[idx]!= op) return false;
	if (nlen(a)^(idx - 1 - lst + 1)) return false;
	return true;
}

il bool cper(const string s, int &a, int &b, int &c, int &d, int &e)
{
	int idx = 0, len = s.size();
	if (!isdigit(s[0]) || len < 9) return false;
	int lst = 0;
	if (!gnoc(s, a, lst, idx, '.')) return false;
	lst = ++idx;
	if (!gnoc(s, b, lst, idx, '.')) return false;
	lst = ++idx;
	if (!gnoc(s, c, lst, idx, '.')) return false;
	lst = ++idx;
	if (!gnoc(s, d, lst, idx, ':')) return false;
	lst = ++idx;
	rep1(p, lst, len - 1)
	{
		if (!isdigit(s[p])) return false;
		e = (e << 1) + (e << 3) + (s[p] & 15);
		if (e > 65535) return false;
	}
	if (nlen(e)^(len - 1 - lst + 1)) return false;
	if (!ins(a, 255) ||!ins(b, 255) ||!ins(c, 255) ||!ins(d, 255) ||!ins(e, 65535)) return false;
	return true;
}
```
核心实现思想：nlen函数获取数字位数，gnoc函数判断从lst到idx这一段数字是否符合要求及后续符号是否正确，cper函数依次调用gnoc函数判断地址串各段合法性，最后整体判断地址串是否合法。

• 最优关键思路或技巧：判断地址串合法性时，使用正则表达式可简洁高效地解决问题；或者通过sscanf读取各部分再拼接对比的方式，思路清晰且代码易实现。利用map数据结构记录服务机地址与编号，方便快速判断服务机重复及客户机连接情况。
• 可拓展之处：同类型题常考查对特定格式字符串的处理与模拟，类似算法套路为首先明确字符串格式规则，然后选择合适方法判断合法性（如正则表达式、按规则分段判断等），最后根据题目要求进行相应操作。
• 相似知识点洛谷题目：
  - P1055 [NOIP2008 普及组] ISBN 号码：考查对特定格式字符串的校验。
  - P1308 [NOIP2011 普及组] 统计单词数：涉及字符串的处理与查找。
  - P1593 因子和阶乘：结合数论知识对数字格式进行处理判断。
• 个人心得摘录与总结：
  - Shunpower：考场上因少写一句`return true;`导致RE，从一等奖变三等奖，强调细心的重要性，提醒在编写代码时要仔细检查关键逻辑语句。 

---
处理用时：53.29秒
# 题目信息

# [蓝桥杯 2013 省 B] 带分数

## 题目描述

$100$ 可以表示为带分数的形式：$100 = 3 + \frac{69258}{714}$。

还可以表示为：$100 = 82 + \frac{3546}{197}$。

注意特征：带分数中，数字 $1$ ~ $9$ 分别出现且只出现一次（不包含 $0$）。

类似这样的带分数，$100$ 有 $11$ 种表示法。






## 说明/提示

原题时限 3 秒, 64M。蓝桥杯 2013 年第四届省赛

## 样例 #1

### 输入

```
100```

### 输出

```
11```

## 样例 #2

### 输入

```
105```

### 输出

```
6```

# AI分析结果

• 综合分析与结论：
    - 思路：多数题解都采用通过枚举1 - 9数字的全排列，将全排列按不同断点拆分成三个数a、b、c，分别作为带分数的整数部分、分子、分母，再判断是否满足a + b / c等于给定整数n的条件，从而得出表示方法的种数。huangruiheng0217采用递归搜索方式，在还未使用过的数中选择并确定其在带分数中的位置，同时进行剪枝优化。
    - 算法要点：利用全排列（如next_permutation函数或递归实现）生成所有可能的数字组合，通过嵌套循环枚举断点拆分全排列为三个数，判断b是否为c的倍数且a + b / c是否等于n。
    - 解决难点：避免重复和遗漏数字组合，高效判断带分数的等式成立。部分题解通过剪枝优化递归搜索减少无效计算。
    - 总体来看，pxb0801、tianzijun、Rain_chr、bigsmart21、zhangyuanxiao、sw2022思路和实现较为相似，huangruiheng0217采用递归搜索并剪枝，虽超时但有独特优化思路。
    - 评分：
        - pxb0801：思路清晰，代码实现完整，对next_permutation函数使用有说明，4星。
        - tianzijun：思路表述清晰，代码简洁，推荐使用next_permutation函数，4星。
        - Rain_chr：思路和代码简单明了，4星。
        - bigsmart21：思路和代码实现常规，对next_permutation函数有简单说明，3星。
        - zhangyuanxiao：思路清晰，代码实现常规，对全排列函数使用有说明，3星。
        - sw2022：代码使用字符串操作和自定义宏，思路表述较简略，3星。
        - huangruiheng0217：采用递归搜索并剪枝，虽超时但有独特优化思路，3星。
    - 最优关键思路或技巧：利用next_permutation函数生成1 - 9数字的全排列，通过嵌套循环枚举断点拆分全排列为三个数进行判断，高效且简洁。递归搜索时合理剪枝可减少无效计算。
    - 拓展：同类型题可涉及数字组合、等式成立判断等，类似算法套路如通过全排列或递归枚举所有可能组合再进行条件判断。
    - 洛谷题目推荐：
        - P1706 全排列问题，考察全排列相关知识。
        - P1157 组合的输出，涉及组合生成相关内容。
        - P1219 八皇后，递归搜索相关题目。
    - 个人心得：huangruiheng0217提到递归搜索超时问题，思考剪枝优化，如按顺序枚举各部分数字，避免出现分母为0等无效情况，虽最终仍超时但提供了优化思路。

所选题解：
  - pxb0801（4星）
    - 关键亮点：思路清晰，详细阐述通过枚举1 - 9全排列解决问题的思路，对next_permutation函数使用有说明。
    - 核心代码片段：
```cpp
while(1){
    int x=0;
    for(int i=1;i<=7;i++){
        x=x*10+a[i];
        int y=0;
        for(int j=i+1;j<=8;j++){//枚举断点 
            y=y*10+a[j];
            int z=0;
            for(int k=j+1;k<=9;k++){
                z=z*10+a[k];
            } 
            if(y%z==0&&x+y/z==n){//判断是否满足条件 
                ans++;//满足则答案+1 
            }
        }
    }
    next_permutation(a+1,a+9+1);
    //检查，如果此时的全排列又回到第一次的，则跳出循环 
    bool ok=0;
    for(int i=1;i<=9;i++){
        if(a[i]!=i){
            ok=1;
            break;
        }
    }
    if(!ok) break;
}
```
核心实现思想：通过while循环不断获取1 - 9全排列，利用嵌套循环枚举两个断点拆分全排列为三个数x、y、z，判断y是否能被z整除且x + y / z是否等于n，满足则答案加1，直到全排列回到初始状态跳出循环。
  - tianzijun（4星）
    - 关键亮点：思路清晰，代码简洁，推荐使用next_permutation函数，定义work函数简化数字拼接过程。
    - 核心代码片段：
```cpp
int work(int l, int r){
    int sum=0;
    for (int i=l; i<=r; i++)
        sum=sum*10+a[i];
    return sum;
}//验证
do {
    for (int i=0; i<7; i++){
        int x=work(0, i);
        if (x>n) break;
        for (int j=i+1; j<8; j++){
            int y=work(i+1, j), z=work(j+1, 8);
            if (y%z==0 && x+y/z==n) {
                ans++;//满足条件则答案+1
            }                
        }    
    }
} while (next_permutation(a, a+9));//全排列 
```
核心实现思想：通过do - while循环利用next_permutation函数获取全排列，在循环内通过嵌套循环枚举断点，利用work函数获取拆分后的三个数x、y、z，判断y是否能被z整除且x + y / z是否等于n，满足则答案加1。
  - Rain_chr（4星）
    - 关键亮点：思路和代码简单明了，通过自定义to_num函数将数组中的数字转换为整数。
    - 核心代码片段：
```cpp
int to_num(int l,int r) //使数组中的数字变成数 
{
    int ans=0;
    for(int i=l;i<=r;i++)
        ans=ans*10+book[i];
    return ans;
}
do
{
    for(int i=0;i<10;i++)
    {
        int num=0;
        num=to_num(0,i);
        for(int j=i+1;j<8;j++)
            if(num+to_num(i+1,j)/to_num(j+1,8)==n&&to_num(i+1,j)%to_num(j+1,8)==0)//约束条件判断
                ans++;
    }
}
while(next_permutation(book,book+9)); //全排列函数 
```
核心实现思想：通过do - while循环利用next_permutation函数获取全排列，在循环内通过嵌套循环枚举断点，利用to_num函数获取拆分后的三个数，判断是否满足条件，满足则答案加1。 

---
处理用时：35.01秒
# 题目信息

# [蓝桥杯 2018 省 A] 倍数问题

## 题目描述

众所周知，小葱同学擅长计算，尤其擅长计算一个数是否是另外一个数的倍数。但小葱只擅长两个数的情况，当有很多个数之后就会比较苦恼。现在小葱给了你 $n$ 个数，希望你从这 $n$ 个数中找到三个数，使得这三个数的和是 $K$ 的倍数，且这个和最大。数据保证一定有解。

## 说明/提示

**【样例解释】**

选择 $2$、$3$、$4$。

**【数据约定】**

对于 $30\%$ 的数据，$n \le 100$。

对于 $60\%$ 的数据，$n \le 1000$。

对于另外 $20\%$ 的数据，$K \le 10$。

对于 $100\%$ 的数据，$1 \le n \le 10^5$，$1 \le K \le 10^3$，给定的 $n$ 个数均不超过 $10^8$。

时限 1 秒，256M。蓝桥杯 2018 年第九届省赛。

## 样例 #1

### 输入

```
4 3
1 2 3 4```

### 输出

```
9```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均基于余数分析。已知要使三个数 $a,b,c$ 的和是 $K$ 的倍数，即 $(a + b + c)\bmod K = 0$，等价于 $(a\bmod K + b\bmod K + c\bmod K)\bmod K = 0$，又因为 $a\bmod K + b\bmod K + c\bmod K < 3K$，所以 $a\bmod K + b\bmod K + c\bmod K$ 的值只能是 $0$，$K$ 或 $2K$。

算法要点在于以余数为标准，存储余数相同情况下最大的三个数。通过枚举 $a\bmod K$ 和 $b\bmod K$，根据上述等式确定 $c\bmod K$，进而从存储的同余类最大数中取值求和，最终得到满足条件的最大和。

解决难点主要在于去重处理，当 $a\bmod K$，$b\bmod K$，$c\bmod K$ 中有相同值时，要正确选取最大值、次大值和次次大值进行计算。

综合质量来看，以下三位作者的题解相对较好：
1. **作者：5k_sync_closer（5星）**
    - **关键亮点**：思路清晰简洁，代码实现精炼，对每种余数和的情况进行了统一的枚举处理，通过巧妙的数组下标操作来处理可能的重复情况，时间复杂度分析准确。
    - **重点代码**：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n, k, q, f[1050][3];
int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 0; i < k; ++i)
        f[i][0] = f[i][1] = f[i][2] = -6e8;
    for (int i = 1, x, y; i <= n; ++i)
    {
        scanf("%d", &x);
        if (f[y = x % k][0] < x)
            f[y][2] = f[y][1], f[y][1] = f[y][0], f[y][0] = x;
        else if (f[y][1] < x)
            f[y][2] = f[y][1], f[y][1] = x;
        else if (f[y][2] < x)
            f[y][2] = x;
    }
    for (int z = 0; z <= k << 1; z += k)
        for (int i = 0; i < k; ++i)
            for (int j = 0, p; j < k; ++j)
                if ((p = z - i - j) >= 0 && p < k)
                    q = max(q, f[i][0] + f[j][i == j] + f[z - i - j][(i == p) + (j == p)]);
    return!printf("%d", q);
}
```
    - **核心实现思想**：首先初始化数组 `f` 存储每种余数对应的最大三个数。读入数据时更新 `f` 数组。然后通过三层循环枚举余数和的三种情况（$0$，$K$，$2K$）以及 $a\bmod K$ 和 $b\bmod K$ 的所有可能，计算出对应的 $c\bmod K$，并根据是否重复选取合适的同余类中的数求和，更新最大值。

2. **作者：gpfgpf（4星）**
    - **关键亮点**：对情况分类详细，从三个数本身相同情况和余数和情况分别进行讨论，代码逻辑较为清晰，在每种情况下去重处理明确。
    - **重点代码**：
```c
#include<stdio.h>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
int arr[1005][4];//arr[i][j]为余数是i的最大的三个数，降序排列，arr[i][3]存储当前余数为i的数有多少
void swap(int* a,int* b)
{
    int tmp=*a;
    *a=*b;
    *b=tmp;
    return ;
}
int main()
{
	int n,k,sum=0;
	int m,mod;
	scanf("%d%d",&n,&k);
	while(n--)
	{
		scanf("%d",&m);
		mod=m%k;
        if(arr[mod][3]<3)
        arr[mod][arr[mod][3]++]=m;
        else//更新最大的三个数
        {
            int j=arr[mod][1]<arr[mod][0]?1:0;
            j=arr[mod][j]<arr[mod][2]?j:2;
            if(m>arr[mod][j])
            arr[mod][j]=m;
        }
	}

    for(int i=0;i<k;i++)//对同余的数降序排列
    {
        if(arr[i][3]==2&&arr[i][0]<arr[i][1])
        swap(&arr[i][0],&arr[i][1]);
        else if(arr[i][3]>=3)
        {
            if(arr[i][0]<arr[i][1])
            swap(&arr[i][0],&arr[i][1]);
            if(arr[i][1]<arr[i][2])
            swap(&arr[i][2],&arr[i][1]);
            if(arr[i][0]<arr[i][1])
            swap(&arr[i][0],&arr[i][1]);
        }
    }

    if(arr[0][3]>=3)//模k之和为0
    sum=arr[0][0]+arr[0][1]+arr[0][2];
	if(k%3==0)//3个数均相同
    {
        if(arr[k/3][3]>=3)//模k之和为k
        sum=max(sum,arr[k/3][0]+arr[k/3][1]+arr[k/3][2]);
        if(arr[k/3*2][3]>=3)//模k之和为2*k
        sum=max(sum,arr[k/3*2][0]+arr[k/3*2][1]+arr[k/3*2][2]);
    }

	for(int i=0;i<k;i++)//有2个数相同
	{
		if(((k-i)&1)==0&&(k-i)/2!=i&&arr[(k-i)/2][3]>=2)//模k之和为k,去重
		sum=max(sum,arr[i][0]+arr[(k-i)/2][1]+arr[(k-i)/2][0]);
		if(((2*k-i)&1)==0&&(2*k-i)/2!=i&&arr[(2*k-i)/2][3]>=2)//模k之和为2k,去重
		sum=max(sum,arr[i][0]+arr[(2*k-i)/2][1]+arr[(2*k-i)/2][0]);
	}

	for(int i=0;i<k;i++)//3个数均不相同
	{
		for(int j=i+1;k-i-j>j;j++)
		{
			if(arr[i][0]&&arr[j][0]&&arr[k-i-j][0])//模k之和为k,去重
            sum=max(sum,arr[i][0]+arr[j][0]+arr[k-i-j][0]);
		}
	}
	for(int i=0;i<k;i++)
	{
		for(int j=max(i+1,k-i-1);2*k-i-j>j;j++)
		{
			if(arr[i][0]&&arr[j][0]&&arr[2*k-i-j][0])//模k之和为2k,去重
            sum=max(sum,arr[i][0]+arr[j][0]+arr[2*k-i-j][0]);
		}
	}
	printf("%d",sum);
	return 0;
}
```
    - **核心实现思想**：先读入数据并存储每种余数对应的最大三个数，同时记录每种余数的数的个数。对同余的数进行降序排列。然后按余数和为 $0$，$K$，$2K$ 以及三个数相同、两个数相同、三个数不同等情况分别计算并更新最大值。

3. **作者：liangbob（4星）**
    - **关键亮点**：思路分析详细，对问题转化过程阐述清晰，代码注释详细，使用三维数组 `f` 处理同余类中不同大小的数，逻辑清晰。
    - **重点代码**：
```cpp
#include <iostream>
#include <iomanip>
#include <cmath>
#include <string>
#include <algorithm>
#include <cstdio>
#include <cstring>
#define endl '\n'
#define int long long
#define IL inline
using namespace std;
const int N = 1e5 + 10;
const int INF = 0x3f3f3f3f;

IL int read()
{
    int x = 0,f = 1;
    char c = getchar();
    while(c <'0'|| c >'9'){if(c == '-') f = -1;c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0',c = getchar();
    return x * f;
}

void write(int x)
{
    if(x < 0) putchar('-'),x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

int f[N][3];
int a[N];
int res = -1e14;

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n, k;
	cin >> n >> k;
	for(int i = 0;i < k;i++) f[i][0] = f[i][1] = f[i][2] = -6e8; //初始化
	for(int i = 1;i <= n;i++)
	{
		cin >> a[i];
		int t = a[i];
		int u = a[i] % k;
		if(f[u][0] < t) //统计最大、次大、次次大
		{
			f[u][2] = f[u][1];
			f[u][1] = f[u][0];
			f[u][0] = t;
		}
		else if(f[u][1] < t)
		{
			f[u][2] = f[u][1];
			f[u][1] = t;
		}
		else if(f[u][2] < t)
		{
			f[u][2] = t;
		}
	}
	for(int i = 0;i < k;i++)
	{
		for(int j = 0;j < k;j++)
		{
			for(int z = 0;z <= 2 * k;z += k) //枚举每个余数
			{
				int g = z - i - j;
				if(g < 0 || g >= k) continue; //越界跳过
				res = max(res, f[i][0] + f[j][(i == j)] + f[g][(i == g) + (j == g)]); //统计答案
			}
		}
	}
	cout << res << endl;
    return 0;
}
```
    - **核心实现思想**：初始化三维数组 `f` 用于存储每种余数对应的最大、次大、次次大的数。读入数据时更新 `f` 数组。通过三层循环枚举余数和的三种情况以及 $a\bmod K$ 和 $b\bmod K$ 的所有可能，计算出对应的 $c\bmod K$，并根据是否重复选取合适的同余类中的数求和，更新最大值。

### 最优关键思路或技巧
1. **余数分析**：将原问题转化为分析三个数对 $K$ 的余数之和，利用余数和的有限取值（$0$，$K$，$2K$）来简化问题。
2. **同余类最值存储**：通过数组存储每个余数同余类中的最大几个数，方便后续计算满足条件的最大和，同时要注意处理同余类中数选取的重复情况。

### 可拓展思路
此类题目可拓展到求满足和是某数倍数的多个数的最大和问题，同样可以基于余数分析，通过存储同余类中的最值来解决。类似算法套路适用于很多涉及余数关系的组合求和问题，例如给定一些数，求满足特定余数条件的数的组合问题。

### 相似知识点洛谷题目
1. **P1306 斐波那契公约数**：涉及数论中余数性质以及斐波那契数列性质，通过余数关系求解最大公约数。
2. **P2613 【模板】有理数取余**：考查对取余运算规则的理解以及在有理数运算中的应用。
3. **P1082 同余方程**：求解同余方程，核心知识点为扩展欧几里得算法以及同余的概念。 

---
处理用时：63.77秒
# 题目信息

# [蓝桥杯 2018 省 B] 递增三元组

## 题目描述

给定三个整数数组 $A = [A_1, A_2,\cdots, A_N]$，$B = [B_1, B_2,\cdots, B_N]$，$C = [C_1, C_2,\cdots,C_N]$。

请你统计有多少个三元组 $(i, j, k)$ 满足：
1. $1 \le i, j, k \le N$  
2. $A_i < B_j < C_k$

## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 100$。

对于 $60\%$ 的数据，$1 \le N \le 1000$。

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$0 \le A_i, B_i, C_i \le 10^5$。

## 样例 #1

### 输入

```
3
1 1 1
2 2 2
3 3 3```

### 输出

```
27```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解先考虑暴力枚举，即通过三层循环枚举 $i,j,k$，时间复杂度为 $O(n^3)$，只能得到部分分数。为优化算法，利用数组可排序且 $b_j$ 在不等式中间的特性，通过排序数组后使用二分查找或双指针法来减少枚举次数。还有题解利用桶排序和前缀和思想，记录小于或大于某数的元素个数来求解。
    - 算法要点：排序是基础操作，为二分查找或双指针法创造条件。二分查找用于快速定位满足条件的元素位置，从而统计数量；双指针法通过移动指针统计满足条件的元素个数；桶排序结合前缀和则通过记录元素出现次数及前后缀和来计算满足条件的组合数。
    - 解决难点：核心是如何降低时间复杂度，从暴力的 $O(n^3)$ 优化到可通过全部数据的复杂度。关键在于利用数组有序性及合理的枚举方式，减少不必要的枚举。

  所选的题解：
  - 作者：liruixiong0101 (5星)
    - 关键亮点：思路清晰，逐步优化，从暴力到 $O(n^2\log n)$ 再到 $O(n\log n)$ 的解法，详细阐述每种解法的思路、时间复杂度及得分情况，并给出对应代码。
    - 重点代码（$O(n\log n)$ 解法）：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 5;
int n, a[N], b[N], c[N], ans;
signed main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    for (int i = 1; i <= n; i++) cin >> c[i];
    sort(a + 1, a + 1 + n);
    sort(c + 1, c + 1 + n);
    for (int j = 1; j <= n; j++) {
        int cnta = lower_bound(a + 1, a + 1 + n, b[j]) - a - 1;
        int cntc = upper_bound(c + 1, c + 1 + n, b[j]) - c;
        cntc = n - cntc + 1;
        ans += cnta * cntc;
    }
    cout << ans;
    return 0;
}
```
核心实现思想：先对 $a$ 和 $c$ 数组排序，枚举 $b_j$，通过二分查找分别得到小于 $b_j$ 的 $a$ 数组元素个数 $cnta$ 和大于 $b_j$ 的 $c$ 数组元素个数 $cntc$，根据乘法原理累加 $cnta \times cntc$ 到答案。
  - 作者：technopolis_2085 (4星)
    - 关键亮点：利用数据范围特性，采用桶排序结合前缀和思想，时间复杂度趋近于 $O(n)$，解法新颖。
    - 重点代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int maxn = 1e5 + 10;
int sum1[maxn], sum2[maxn];
int a[maxn], b[maxn], c[maxn];

signed main() {
    int n;
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    for (int i = 1; i <= n; i++) scanf("%lld", &b[i]);
    for (int i = 1; i <= n; i++) scanf("%lld", &c[i]);

    for (int i = 1; i <= n; i++) {
        sum1[a[i]]++;
        sum2[c[i]]++;
    }

    for (int i = 1; i <= (int)1e5; i++) {
        sum1[i] += sum1[i - 1];
    }

    for (int i = (int)1e5; i >= 0; i--) {
        sum2[i] += sum2[i + 1];
    }

    int ans = 0;

    for (int i = 1; i <= n; i++) {
        ans += sum1[b[i] - 1] * sum2[b[i] + 1];
    }

    printf("%lld", ans);
    return 0;
}
```
核心实现思想：用桶记录 $a$ 和 $c$ 数组中每个数的出现次数，分别计算小于某数的前缀和 $sum1$ 与大于某数的前缀和 $sum2$，枚举 $b_i$，计算 $sum1_{b_i - 1} \times sum2_{b_i + 1}$ 累加至答案。
  - 作者：Zaku (4星)
    - 关键亮点：采用双指针法优化查找，避免二分查找，代码简洁优雅，时间复杂度为 $O(n)$。
    - 重点代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
typedef long long LL;
int a[N], b[N], c[N];
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
    for (int i = 1; i <= n; i++) scanf("%d", &c[i]);
    sort(a + 1, a + n + 1);
    sort(b + 1, b + n + 1);
    sort(c + 1, c + n + 1);
    LL ans = 0;
    int cnt = 1, cnt_ = 1;
    for (int i = 1; i <= n; i++) {
        while (cnt <= n && a[cnt] < b[i]) cnt++;
        while (cnt_ <= n && c[cnt_] <= b[i]) cnt_++;
        ans += (LL)(cnt - 1) * (n - cnt_ + 1);
    }
    cout << ans;
    return 0;
}
```
核心实现思想：先排序数组，枚举 $b_i$，通过双指针分别记录小于 $b_i$ 的 $a$ 数组元素个数和大于 $b_i$ 的 $c$ 数组元素个数，根据乘法原理累加乘积到答案。

• 最优关键思路或技巧：利用数组有序性，通过排序结合二分查找、双指针法或桶排序与前缀和，优化暴力枚举的时间复杂度。如固定 $b_j$，通过二分查找或双指针法快速统计满足 $a_i < b_j < c_k$ 的 $i$ 和 $k$ 的组合数。

• 可拓展之处：此类题目可拓展到类似的多数组元素关系统计问题，例如给定多个数组，统计满足特定大小关系的多元组数量。类似算法套路是先分析暴力解法，再利用数组特性（如可排序），选择合适的优化方法（二分、双指针、桶排序等）。

• 相似知识点洛谷题目：
    - [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：涉及二分查找的应用，通过二分答案解决最优解问题。
    - [P1873 砍树](https://www.luogu.com.cn/problem/P1873)：同样运用二分查找思想，在给定数组中寻找满足条件的临界值。
    - [P3853 [TJOI2007]路标设置](https://www.luogu.com.cn/problem/P3853)：需通过排序和二分查找确定满足条件的最优解，与本题利用排序和二分优化思路类似。

• 个人心得：部分作者提到暴力枚举是思考算法的起点，先实现暴力解法再考虑优化；还有作者强调注意数据范围和类型，如本题需开 `long long` 避免溢出。 

---
处理用时：45.37秒
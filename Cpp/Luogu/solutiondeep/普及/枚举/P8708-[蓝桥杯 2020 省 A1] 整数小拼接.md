# 题目信息

# [蓝桥杯 2020 省 A1] 整数小拼接

## 题目描述

给定一个长度为 $n$ 的数组 $A_1,A_2,\cdots,A_n$。你可以从中选出两个数 $A_i$ 和 $A_j$($i\neq j$)，然后将 $A_i$ 和 $A_j$ 一前一后拼成一个新的整数。例如 `12` 和 `345` 可以拼成 `12345` 或 `34512`。注意交换 $A_i$ 和 $A_j$ 的顺序总是被视为 $2$ 种拼法，即便是 $A_i=A_j$ 时。

请你计算有多少种拼法满足拼出的整数小于等于 $K$。


## 说明/提示

对于 $30\%$ 的评测用例 $1\le n\le1000$，$1\le k\le10^8$，$1\le A_i\le10^4$。

对于所有评测用例，$1\le n\le10^5$，$1\le k\le10^{10}$，$1\le A_i\le10^9$。

蓝桥杯 2020 第一轮省赛 A 组 H 题。

## 样例 #1

### 输入

```
4 33
1 2 3 4```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解主要思路为避免暴力枚举带来的 $O(n^2)$ 时间复杂度，利用数组排序后的单调性，通过双指针或二分查找来优化计算满足拼接整数小于等于 $K$ 的拼法数量。
 - **算法要点**：先对数组排序，双指针法通过移动左右指针并比较拼接数与 $K$ 的大小来统计结果；二分查找则是对每个数，二分找到能与之拼接满足条件的最大数的位置来统计。
 - **解决难点**：关键在于利用排序后的单调性优化算法，同时处理好拼接数字的操作，如通过计算位数实现数字拼接，或借助字符串转换来拼接。

### 所选的题解
- **作者：Zaku (5星)**
    - **关键亮点**：思路清晰，详细阐述双指针算法过程及拼接操作实现，代码注释详尽，使用字符串拼接并手写比较函数，易于理解。
    - **重点代码**：
```cpp
int cmp(string s1, string s2) {
    if (s1.size() == s2.size()) { 
        if (s1 == s2) return 0;
        else if (s1 < s2) return 1;
        else return -1;
    }
    if (s1.size() < s2.size()) return 1;
    else return -1;
}
void init() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i];
    sort(a + 1, a + 1 + n);
    for (int i = 1; i <= n; i++) s[i] = to_string(a[i]);
    str = to_string(k);
}
int main() {
    init();
    ll res = 0;
    int l = 1, r = n;
    while(l <= r) {
        int t = cmp(s[l] + s[r], str);
        if(t == 1) {
            res += r - l;
            l++;
        } else if(t == 0) {
            res += r - l;
            l++, r--;
        } else r--;
    }
    l = 1, r = n;
    while(l <= r) {
        int t = cmp(s[r] + s[l], str);
        if(t == 1) {
            res += r - l;
            l++;
        } else if(t == 0) {
            res += r - l;
            l++, r--;
        } else r--;  
    }
    cout << res;
    return 0;
}
```
    - **核心实现思想**：`cmp` 函数用于比较两个字符串大小。`init` 函数初始化数据并将数组元素转为字符串。主函数中两次双指针循环，根据拼接字符串与 `k` 转换的字符串比较结果，统计满足条件的拼法数量。
- **作者：AndyPomeloMars (4星)**
    - **关键亮点**：分析清晰，指出暴力解法超时原因，提出排序后用双指针思想解题，使用 `to_string` 和 `stoll` 函数简化拼接操作。
    - **重点代码**：
```cpp
inline long long connect(long long a, long long b){
    return stoll(to_string(a) + to_string(b));
}
int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> N >> K;
    for (int i = 1; i <= N; ++i) cin >> A[i];
    sort(A + 1, A + N + 1);
    P = N;
    for (int i = 1; i <= N; ++i) {
        while (P > 0 && connect(A[P], A[i]) > K) --P;
        ANS += P, ANS -= (P >= i);
    }
    cout << ANS << endl;
    return 0;
}
```
    - **核心实现思想**：`connect` 函数将两个数字转为字符串拼接后再转回 `long long` 类型。主函数中先排序，然后通过 `for` 循环和 `while` 循环确定最大可行范围 `P`，统计满足条件的拼法数量，同时处理不能自己拼自己的情况。
- **作者：A_Bit_Cold (4星)**
    - **关键亮点**：详细说明双指针移动的三种情况及原因，采用数字拼接法，代码实现完整，注释清晰。
    - **重点代码**：
```cpp
int w(long long x) {
    int s = 0;
    while(x) x/=10, s++;
    return s;
}
long long power(long long x, long long y) {
    if(!y) return 1;
    long long k = power(x, y>>1);
    if(y&1) return k*k*x;
    else return k*k;
}
int main() {
    long long n, k, ans = 0;
    cin>>n>>k;
    for(long long i = 1; i <= n; i++) cin>>a[i];
    sort(a + 1, a + n + 1);
    long long l = 1, r = n;
    while(l <= r) {
        if(a[l]*power(10, w(a[r])) + a[r] > k) r--;
        else if(a[l]*power(10, w(a[r])) + a[r] < k) ans += r - l, l++;
        else ans += r - l, l++, r--;
    }
    l = 1, r = n;
    while(l <= r) {
        if(a[r]*power(10, w(a[l])) + a[l] > k) r--;
        else if(a[r]*power(10, w(a[l])) + a[l] < k) ans += r - l, l++;
        else ans += r - l, l++, r--;
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：`w` 函数计算数字位数，`power` 函数实现快速幂。主函数中两次双指针循环，根据拼接数字与 `k` 的大小关系移动指针并统计满足条件的拼法数量。

### 最优关键思路或技巧
利用数组排序后的单调性，通过双指针或二分查找优化暴力枚举，减少时间复杂度。在处理拼接操作时，可选择数字拼接（计算位数后通过乘法和加法实现）或字符串拼接（借助 `to_string` 等函数）的方式，根据具体情况选择更简洁高效的实现。

### 可拓展思路
此类题目可拓展到其他需要利用单调性优化枚举的场景，例如在一些组合问题中，通过排序和双指针或二分查找来快速统计满足特定条件的组合数量。类似算法套路还可应用于一些具有区间特性的问题，通过双指针移动来动态调整区间以满足条件。

### 相似知识点洛谷题目
 - [P1873 砍树](https://www.luogu.com.cn/problem/P1873)：考查二分查找，通过二分找到合适的砍树高度。
 - [P2678 [NOIP2015 普及组] 跳石头](https://www.luogu.com.cn/problem/P2678)：利用二分查找优化枚举，找到满足条件的最小跳跃距离。
 - [P3853 [TJOI2007] 路标设置](https://www.luogu.com.cn/problem/P3853)：同样是二分查找的应用，二分确定路标的合适间距。

### 个人心得摘录
未发现题解中有个人心得相关内容。 

---
处理用时：38.12秒
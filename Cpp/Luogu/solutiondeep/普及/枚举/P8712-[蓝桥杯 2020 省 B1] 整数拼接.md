# 题目信息

# [蓝桥杯 2020 省 B1] 整数拼接

## 题目描述

给定一个长度为 $n$ 的数组 $A_1,A_2,\cdots,A_n$。你可以从中选出两个数 $A_i$ 和 $A_j$（$i\neq j$），然后将 $A_i$ 和 $A_j$ 一前一后拼成一个新的整数。例如 `12` 和 `345` 可以拼成 `12345` 或 `34512`。注意交换 $A_i$ 和 $A_j$ 的顺序总是被视为 $2$ 种拼法，即便是 $A_i=A_j$ 时。

请你计算有多少种拼法满足拼出的整数是 $K$ 的倍数。


## 说明/提示

对于所有评测用例，$1\le n\le10^5$，$1\le k\le10^5$，$1\le A_i\le10^9$。

蓝桥杯 2020 第一轮省赛 B 组 I 题。

## 样例 #1

### 输入

```
4 2
1 2 3 4```

### 输出

```
6```

# AI分析结果

• 综合分析与结论：
    - 这些题解思路大致相同，均通过预处理存储数乘不同次幂10后模k的余数出现次数，利用哈希表（或数组模拟哈希表）来优化时间复杂度，将暴力枚举的O(n^2)优化到接近O(n)。难点在于如何想到这种预处理方式以及处理自身拼接重复计算的情况。
    - 各题解在实现细节上有差异，如计算数字位数方式、循环写法、数据结构使用等。

• 所选的题解：
  - 作者：qiuqiuyaq (5星)
    - 关键亮点：思路清晰，详细阐述了时间复杂度分析、公式推导、实现思路以及细节处理，代码注释详细，可读性高。
    ```cpp
    // 预处理哈希表
    for (int i = 0; i < n; i ++ )
    {
        LL t = a[i] % m;
        for (int j = 0; j < 11; j ++ )
        {
            s[j][t] ++ ;
            t = t * 10 % m;
        }
    }
    LL res = 0;
    for (int i = 0; i < n; i ++ )
    {
        LL t = a[i] % m;
        int len = to_string(a[i]).size();
        res += s[len][(m - t) % m];
        LL r = t;
        while (len -- ) r = r * 10 % m;
        if (r == (m - t) % m) res -- ;
    }
    ```
    - 核心实现思想：先枚举每个数预处理哈希表，记录不同数乘不同次幂10模m的余数出现次数。再枚举每个数，根据其位数和模m的余数，在哈希表中查找能与之拼接成k倍数的数的个数，并处理自身重复情况。

  - 作者：superLouis (4星)
    - 关键亮点：挑战较低时间复杂度O(n log₁₀ max aᵢ)，代码简洁，通过定义数组P存储10的幂次，利用log10函数计算数字位数，逻辑清晰。
    ```cpp
    void work() {
        for (int i = 1; i <= n; i++) {
            ans += f[digits(a[i])][(k - a[i] % k) % k];
            for (int j = 1; j <= 9; j++)
                f[j][(a[i] * P[j]) % k]++;
        }
    }
    ```
    - 核心实现思想：在work函数中，每次遍历数组a，累加满足条件的方案数，并更新每个数乘10的不同次幂模k的方案数。

  - 作者：zyxjeek (4星)
    - 关键亮点：使用unordered_map作为哈希表，对题目条件的数学推导清晰，代码中对细节处理（如long long使用、计算数字位数）有详细注释。
    ```cpp
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        for (int j = 1; j <= 10; j++)
            mp[j][a[i] * pw[j] % k]++;
    }
    long long ans = 0;
    for (int i = 1; i <= n; i++) {
        int len = log10(a[i]) + 1, mod = (k - a[i] % k) % k;
        ans += mp[len][mod];
        if (a[i] * pw[len] % k == mod)
            ans--;
    }
    ```
    - 核心实现思想：先遍历输入数组，将每个数乘10的不同次幂模k的结果存入哈希表mp。再遍历数组，根据每个数的位数和模k的补数，从哈希表中获取满足拼接条件的数的个数，并处理自身拼接重复情况。

• 最优关键思路或技巧：
    - 利用哈希表（或数组模拟哈希表）预处理存储数乘不同次幂10模k的余数出现次数，将枚举两个数的O(n^2)复杂度优化到接近O(n)。
    - 处理自身拼接重复计算问题，通过判断自身拼接是否满足条件，在结果中减去重复计数。

• 可拓展之处：
    - 同类型题：给定一些数，通过某种组合（拼接、四则运算等）得到满足特定条件（如被某数整除、特定余数等）的方案数。类似算法套路是通过预处理某些中间结果，利用哈希表存储，降低枚举复杂度。

• 洛谷相似题目：
    - P1303 A*B Problem升级版
    - P2671 求和
    - P1147 连续自然数和

• 个人心得摘录与总结：
    - 作者Ericzc：开始以为是高难度数论，仔细看题后发现通过预处理可降低复杂度解决，提醒做题需认真分析题目条件。 

---
处理用时：29.39秒
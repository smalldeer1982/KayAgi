# 题目信息

# [蓝桥杯 2020 省 AB2] 子串分值

## 题目描述

对于一个字符串 $S$, 我们定义 $S$ 的分值 $f(S)$ 为 $S$ 中恰好出现一次的字符个数。例如 $f\left({ }^{\prime \prime} \mathrm{aba}{ }^{\prime \prime}\right)=1$，$f\left({ }^{\prime \prime} \mathrm{abc}{ }^{\prime \prime}\right)=3$，$f\left({ }^{\prime \prime} \mathrm{aaa} \mathrm{a}^{\prime \prime}\right)=0$ 。

现在给定一个字符串 $S[0 . . n-1]$（长度为 $n$），请你计算对于所有 $S$ 的非空 子串 $S[i . . j](0 \leq i \leq j<n)$，$f(S[i . . j])$ 的和是多少。


## 说明/提示

对于 $20 \%$ 的评测用例, $1 \leq n \leq 10$;

对于 $40 \%$ 的评测用例, $1 \leq n \leq 100$;

对于 $50 \%$ 的评测用例, $1 \leq n \leq 1000$;

对于 $60 \%$ 的评测用例, $1 \leq n \leq 10000$;

对于所有评测用例, $1 \leq n \leq 100000$。

蓝桥杯 2020 第二轮省赛 A 组 H 题（B 组 H 题）。

## 样例 #1

### 输入

```
ababc```

### 输出

```
21```

# AI分析结果

• 综合分析与结论：所有题解均围绕如何计算字符串所有非空子串的分值和展开。暴力思路是枚举子串的左右端点并遍历子串统计仅出现一次的字符个数，但时间复杂度为$O(n^3)$会超时。优化后的暴力思路时间复杂度为$O(n^2)$仍会超时。正解思路是利用乘法原理，通过记录每个字符上一次和下一次出现的位置，计算每个字符在只出现一次的情况下能被多少子串包含，时间复杂度优化到$O(n)$。各题解思路本质相同，主要差异在于代码实现细节。
• 所选的题解：
  - 作者：BEST_CAT (5星)
    - 关键亮点：思路清晰，不仅给出暴力和优化后的暴力思路及时间复杂度分析，还给出正解思路及详细步骤，代码简洁明了。
    - 重点代码核心实现思想：通过两次遍历分别记录每个字符上一次和下一次出现的位置，最后根据乘法原理计算每个字符对答案的贡献并累加。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100010,M=150;
string s;
ll pre[N],nx[N],idx[M];
int main(){
    cin>>s;
    ll n=s.size();
    s=' '+s;
    for(int i=1;i<=n;i++){
        pre[i]=idx[s[i]];
        idx[s[i]]=i;
    }
    for(int i=97;i<=122;i++){
        idx[i]=n+1;
    }
    for(int i=n;i>=1;i--){
        nx[i]=idx[s[i]];
        idx[s[i]]=i;
    }
    ll ans=0;
    for(int i=1;i<=n;i++){
        ans+=(i-pre[i])*(nx[i]-i);
    }
    cout<<ans;
    return 0;
}
```
  - 作者：Luckies (4星)
    - 关键亮点：题目大意总结清晰，正解思路阐述详细，从分析每个字符的贡献入手，逐步引导得出计算方法，代码注释详细。
    - 重点代码核心实现思想：与BEST_CAT类似，通过两次遍历分别求每个字符上一次和下一次出现的位置，进而计算每个字符对答案的贡献并累加。
```cpp
#include<bits/stdc++.h>
#define int long long//记得开long long
using namespace std;
const int N = 1e5 + 5, S = 27;
int last[N], nxt[N], a[S];
int ans;
string s;
signed main()
{
	cin >> s;
	int len = s.size();
	s = '#' + s;//使字符串下标从1开始
	for(int i = 1; i <= len; i++)//求last
	{
		last[i] = a[s[i] - 'a'];
		a[s[i] - 'a'] = i;
	}
	for(int i = 0; i < 26; i++)//初始化a
		a[i] = len + 1;
	for(int i = len; i >= 1; i--)//求nxt
	{
		nxt[i] = a[s[i] - 'a'];
		a[s[i] - 'a'] = i;
	}
	for(int i = 1; i <= len; i++)//求答案
		ans += (i - last[i]) * (nxt[i] - i);
	cout << ans;
	return 0;
}
```
  - 作者：DreamLand_zcb (4星)
    - 关键亮点：通过举例详细说明每个字符对分值之和的贡献计算方法，思路易于理解，代码有一定注释。
    - 重点代码核心实现思想：通过两层循环分别找每个字符上一次和下一次出现的位置，再根据乘法原理计算贡献并累加。
```cpp
#include <bits/stdc++.h>
#define ll long long
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;
string s;
ll ans;
int main()
{
	ios::sync_with_stdio(false);
	cin >> s;
	int l=s.size();//比较习惯用l，没用题目中所给的n
	for(int i=0;i<l;i++)
	{
		int lastpos=-1, nextpos=-1;
		for(int j=i-1;j>=0;j--)
		{
			if(s[j] == s[i])
			{
				lastpos=j+1;
				break;
			}
		}
		if(lastpos == -1)	lastpos=0;
		for(int j=i+1;j<l;j++)
		{
			if(s[j] == s[i])
			{
				nextpos=j-1;
				break;
			}
		}
		if(nextpos == -1)	nextpos=l-1;
		//cout << s[i] << ": " << lastpos << " " << nextpos << endl;
		ans+=(i-lastpos+1)*(nextpos-i+1);//左侧个数是(i-lastpos+1)个，右侧是(nextpos-i+1)个
	}
	cout << ans;
	return 0;
}
```
• 最优关键思路或技巧：利用乘法原理，通过记录每个字符上一次和下一次出现的位置来计算每个字符对所有子串分值和的贡献，从而将时间复杂度从暴力的$O(n^3)$或$O(n^2)$优化到$O(n)$。
• 可拓展之处：同类型题通常围绕字符串子串的某些特性计数展开，类似算法套路是分析每个字符或元素对整体结果的贡献，利用乘法原理等方式优化计算。
• 洛谷相似题目：
  - P1303 A*B Problem升级版
  - P1972 [SDOI2009]HH的项链
  - P2118 比例简化 

---
处理用时：30.44秒
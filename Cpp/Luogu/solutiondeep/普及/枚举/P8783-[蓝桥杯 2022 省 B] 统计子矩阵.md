# 题目信息

# [蓝桥杯 2022 省 B] 统计子矩阵

## 题目描述

给定一个 $N \times M$ 的矩阵 $A$，请你统计有多少个子矩阵 (最小 $1 \times 1$, 最大 $N \times M)$ 满足子矩阵中所有数的和不超过给定的整数 $K$。


## 说明/提示

**【样例说明】**

满足条件的子矩阵一共有 $19$，包含:

大小为 $1 \times 1$ 的有 $10$ 个。

大小为 $1 \times 2$ 的有 $3$ 个。 大小为 $1 \times 3$ 的有 $2$ 个。

大小为 $1 \times 4$ 的有 $1$ 个。

大小为 $2 \times 1$ 的有 $3$ 个。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据, $N, M \leq 20$.

对于 $70 \%$ 的数据, $N, M \leq 100$.

对于 $100 \%$ 的数据, $1 \leq N, M \leq 500,0 \leq A_{i j} \leq 1000,1 \leq K \leq 2.5\times10^8$. 

蓝桥杯 2022 省赛 B 组 F 题。

## 样例 #1

### 输入

```
3 4 10
1 2 3 4
5 6 7 8
9 10 11 12```

### 输出

```
19```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解先提出暴力解法，即枚举左上角和右下角点确定子矩阵并求和判断，时间复杂度为 \(O(n^3m^3)\) 或 \(O(n^2m^2)\)，因复杂度高无法通过所有测试点。接着引入前缀和优化，通过二维前缀和数组 \(sum\) 实现 \(O(1)\) 时间求子矩阵和，将时间复杂度降为 \(O(n^2m^2)\)，但仍不满足全部数据要求。最终，利用“降维打击”思想，把二维矩阵问题转化为一维序列问题，再结合双指针法，将时间复杂度优化到 \(O(n^2m)\) 或 \(O(m^2n)\)，成功解决问题。
    - 算法要点：利用前缀和优化子矩阵和的计算，通过枚举两条横线将二维问题降维为一维，再用双指针法在一维序列中统计满足条件的子序列。
    - 解决难点：核心是如何降低时间复杂度，通过降维与双指针法实现从高复杂度到低复杂度的转变。

    - 综合质量（思路清晰度、代码可读性、优化程度等），以下3篇题解质量较高：
  - 作者：sgl654321 (5星)
    - 关键亮点：思路阐述详细，从30分做法逐步优化到满分做法，逻辑清晰；代码简洁明了，对关键步骤有注释说明，便于理解。
    - 个人心得：无
    - 重点代码及核心思想：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,a[510][510],sum[510][510],b[510];
long long l,r,now,ans;
int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
    for(int j=1;j<=m;j++)
        for(int i=1;i<=n;i++)
            sum[i][j]=sum[i-1][j]+a[i][j];// 计算列前缀和
    for(int x=1;x<=n;x++)
        for(int y=x;y<=n;y++){
            for(int j=1;j<=m;j++)
                b[j]=sum[y][j]-sum[x-1][j];// 将x到y行的矩阵压成一维序列
            l=1;r=1;now=0;
            for(r=1;r<=m;r++){
                now+=b[r];
                if(now<=k){
                    ans+=r-l+1;
                }
                else{
                    while(now>k){
                        now-=b[l];
                        l++;
                    }
                    ans+=r-l+1;
                }
            }
        }
    cout<<ans<<endl;
    return 0;
}
```
核心思想：先计算列前缀和，然后枚举两条横线，将中间部分压成一维序列，用双指针法在一维序列中统计满足和不超过 \(k\) 的子序列个数。

  - 作者：fengben123 (4星)
    - 关键亮点：对双指针的原理及应用讲解细致，代码注释详细，有助于理解双指针在本题中的具体运用。
    - 个人心得：调了好长时间才发现问题，强调了调试的重要性。
    - 重点代码及核心思想：
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int a[505][505],s[505][505];
int b[505];
signed main(){
    int n,m,k,ans=0;
    cin >> n >> m >> k;
    for(int i = 1 ; i <= n ; ++i )
        for(int j = 1 ; j <= m ; ++j )
            cin >> a[i][j];
    for(int j = 1 ; j <= m ; ++j )
        for(int i = 1 ; i <= n ; ++i )
            s[i][j]=s[i-1][j]+a[i][j];// 按列前缀和
    for(int ii = 1 ; ii <= n ; ++ii ){  
        for(int i = ii ; i <= n ; i++){  
            for(int j = 1 ; j <= m ; ++ j ) b[j]=s[i][j]-s[ii-1][j];// 压成一维
            int L=1,R=0,sum=0;
            while(R<m){
                R++;
                sum+=b[R];
                if(sum <= k) ans+=(R-L+1);
                else {
                    while(sum > k ){
                        sum-=b[L];
                        L++;
                    }
                    ans+=R-L+1;
                }
            }
        }
    }
    cout << ans;
    return 0;
}
```
核心思想：先按列计算前缀和，枚举两条横线，将中间部分转化为一维数组，利用双指针法在一维数组中统计满足条件的子序列个数。

  - 作者：DreamLand_zcb (4星)
    - 关键亮点：通过图形辅助说明二维前缀和及指针移动原理，思路清晰；代码对关键步骤有注释，便于理解。
    - 个人心得：无
    - 重点代码及核心思想：
```cpp
#include <bits/stdc++.h>
#define ll long long
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;
ll n, m, k, ans=0;
int a[505][505];
int s[505][505];
int get_sum(int rx, int ry, int lx, int ly)
{
    return s[rx][ry]-s[rx][ly-1]-s[lx-1][ry]+s[lx-1][ly-1];
}
int main()
{
    ios::sync_with_stdio(false);
    mem(s, 0);
    cin >> n >> m >> k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin >> a[i][j];
            s[i][j]=s[i-1][j]+s[i][j-1]+a[i][j]-s[i-1][j-1];
        }
    }
    int up, dn;
    int le, ri;
    for(up=1;up<=n;up++)
    {
        for(dn=up;dn<=n;dn++)
        {
            for(le=1, ri=1;ri<=m;ri++)
            {
                while(le <= ri && get_sum(dn, ri, up, le) > k) le++;// 枚举直到子矩阵符合题意
                if(le <= ri) ans+=ri-le+1;
            }
        }
    }
    cout << ans;
    return 0;
}
```
核心思想：先计算二维前缀和，通过枚举上下指针确定子矩阵的上下边界，利用双指针法移动左右指针，统计满足和不超过 \(k\) 的子矩阵个数。

• 最优关键思路或技巧：
    - **降维思想**：将二维矩阵问题转化为一维序列问题，降低问题复杂度。
    - **双指针法**：利用序列单调性，通过双指针移动，在 \(O(n)\) 时间内统计满足条件的子序列，优化时间复杂度。
    - **前缀和优化**：通过预处理前缀和数组，实现 \(O(1)\) 时间内获取子矩阵的和，提高计算效率。

• 可拓展之处：
    - 同类型题：给定一个多维数组，求满足特定条件（如元素和、乘积等）的子数组个数。
    - 类似算法套路：在处理多维数据问题时，可尝试通过降维将其转化为低维问题，再结合双指针、前缀和等方法优化求解。

• 推荐题目：
    - [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)：经典双指针题目，通过双指针维护区间满足特定条件。
    - [P3957 [NOIP2017 普及组] 跳房子](https://www.luogu.com.cn/problem/P3957)：可使用前缀和优化计算，结合二分查找解决问题。
    - [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：虽然是一维数组，但与本题思路类似，通过前缀和与双指针（或动态规划）求满足条件的最大子段和。 

---
处理用时：42.88秒
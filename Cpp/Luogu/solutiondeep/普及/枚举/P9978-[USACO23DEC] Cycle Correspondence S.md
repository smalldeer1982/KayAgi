# 题目信息

# [USACO23DEC] Cycle Correspondence S

## 题目描述

Farmer John 有 $N$（$3 \le N \le 5\cdot 10^5$）座谷仓，其中 $K$ 对不同的谷仓连接在一起。

一开始，Annabelle 为每座谷仓分配了一个 $[1,N]$ 范围内的整数编号，并发现编号为 $a_1,\dots,a_K$ 的谷仓按照顺序形成了一个环形连接。换句话说，对于所有的 $1 \le i < K$，谷仓 $a_i$ 和 $a_{i+1}$ 相连，谷仓 $a_K$ 与 $a_1$ 亦相连。所有的 $a_i$ 不相同。

然后，Bessie 也为每个谷仓分配了一个 $[1,N]$ 范围内的整数编号，并发现编号为 $b_1,\dots,b_K$ 也按照顺序形成了一个环形链接。所有的 $b_i$ 不相同。

一些（可能没有或全部）谷仓被 Annabelle 和 Bessie 分配了相同的编号。计算最多有多少个这样的谷仓。

## 说明/提示

### 样例解释 1

Annabelle 和 Bessie 可以为每个谷仓分配相同的编号。

### 样例解释 2

Annabelle 和 Bessie 无法为任何谷仓分配相同的编号。

### 样例解释 3

Annabelle 和 Bessie 可以分配编号 $2,3,4,6$ 给相同的谷仓。

### 测试点性质

- 测试点 $4-5$ 满足 $N \le 8$。
- 测试点 $6-8$ 满足 $N \le 5000$。
- 测试点 $9-15$ 没有额外限制。

## 样例 #1

### 输入

```
6 3
1 2 3
2 3 1```

### 输出

```
6```

## 样例 #2

### 输入

```
6 3
1 2 3
4 5 6```

### 输出

```
0```

## 样例 #3

### 输入

```
6 4
1 2 3 4
4 3 2 5```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先处理环外未出现的编号，将其数量直接累加到答案中，然后重点处理环上编号，通过考虑一个环相对另一个环的旋转和翻转，找出对应位置相同编号的最大数量。

算法要点在于：
1. **统计环外编号**：利用数组或哈希表等方式统计在两个环编号序列中均未出现的编号数量。
2. **处理环上编号**：通过记录每个编号在环中的位置，分析一个环中的编号对应到另一个环相同编号时所需的循环移位次数，取出现次数最多的移位次数作为环上编号的贡献。

解决难点主要在于如何优化对环上编号匹配的计算，避免 $O(n^2)$ 的暴力枚举。

### 所选的题解
- **作者：strcmp（5星）**
  - **关键亮点**：思路清晰，代码简洁高效。利用桶数组统计编号出现情况，通过巧妙的循环移位计算和两次处理（包括对第二个环序列的翻转）来准确求解。
  - **重点代码**：
```cpp
for (int i = 1; i <= k; i++) scanf("%lld", &a[i]), ++cnt[a[i]], d[a[i]] = i;
for (int i = 1; i <= k; i++) scanf("%lld", &b[i]), ++cnt[b[i]];
for (int i = 1; i <= k; i++) {
    int u = d[b[i]];
    if (!u) continue;
    if (u >= i) ++sum[u - i];
    else ++sum[k - i + u];
}
for (int i = 0; i <= k; i++) ans = max(ans, sum[i]);
reverse(a + 1, a + k + 1); memset(d, 0, sizeof(d)); memset(sum, 0, sizeof(sum));
for (int i = 1; i <= k; i++) d[a[i]] = i;
for (int i = 1; i <= k; i++) {
    int u = d[b[i]];
    if (!u) continue;
    if (u >= i) ++sum[u - i];
    else ++sum[k - i + u];
}
for (int i = 0; i <= k; i++) ans = max(ans, sum[i]);
for (int i = 1; i <= n; i++) ans +=!cnt[i];
```
  - **核心实现思想**：先读入两个环的编号序列，用 `cnt` 数组统计每个编号是否出现，`d` 数组记录 `a` 序列中每个编号的位置。通过遍历 `b` 序列，根据 `b` 中编号在 `a` 序列中的位置计算循环移位次数并累加到 `sum` 数组，取 `sum` 数组中的最大值作为一种情况的结果。然后翻转 `a` 序列，重复上述过程，最后加上环外未出现编号的数量得到最终答案。
- **作者：tanghg（4星）**
  - **关键亮点**：思路表述清晰，代码结构合理，通过函数封装部分逻辑，增强了代码可读性。同样考虑了环的旋转和翻转。
  - **重点代码**：
```cpp
void Do() {
    memset(d, 0, sizeof(d));
    for(int i = 1; i <= k; ++i) {
        loc[b[i]] = i;
    }
    for(int i = 1; i <= k; ++i) {
        ll nxt = loc[a[i]];
        if(nxt == 0) {
            continue;
        }
        if(nxt > i) {
            d[nxt - i]++;
        } else {
            d[nxt - i + k]++;
        }
    }
    for(int i = 1; i <= k; ++i) {
        ans = max(ans, d[i]);
    }
}
```
  - **核心实现思想**：`Do` 函数先记录 `b` 序列中每个编号的位置，然后遍历 `a` 序列，根据 `a` 中编号在 `b` 序列中的位置计算循环移位次数并累加到 `d` 数组，取 `d` 数组中的最大值。主函数中两次调用 `Do` 函数，一次正常，一次在翻转 `a` 序列后，最后加上环外未出现编号的数量。
- **作者：听取MLE声一片（4星）**
  - **关键亮点**：代码简洁，通过 `map` 统计循环移位次数，在优化暴力枚举方面有较好体现，同时也考虑了环的翻转。
  - **重点代码**：
```cpp
int solve() {
    int res = 0;
    map<int, int> mp;
    for(int i = 1; i <= m; i++)
        if(pos[b[i]]) {
            int x = i - pos[b[i]];
            if(x < 0) x += m;
            mp[x]++;
        }
    for(int i = -n; i <= m; i++)
        res = max(res, mp[i]);
    return res;
}
```
  - **核心实现思想**：`solve` 函数通过遍历 `b` 序列，根据 `b` 中编号在 `a` 序列中的位置计算循环移位次数并记录到 `map` 中，遍历 `map` 取出现次数最大值作为结果，主函数中两次调用 `solve` 函数（一次翻转 `b` 序列后），并加上环外未出现编号的数量。

### 最优关键思路或技巧
1. **利用数组或哈希表统计编号出现情况**：可以快速判断哪些编号在环外，直接累加到答案。
2. **记录编号位置并计算循环移位次数**：避免对环的旋转进行暴力枚举，优化时间复杂度。通过记录每个编号在环中的位置，分析一个环中的编号对应到另一个环相同编号时所需的循环移位次数，统计每种移位次数下相同编号的数量，取最大值。

### 可拓展之处
同类型题可涉及不同类型的环结构匹配问题，如带权环的匹配等。类似算法套路包括处理环形数据结构时，通过记录元素位置、考虑旋转和翻转等操作来优化计算匹配数量。

### 洛谷相似题目推荐
1. [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)：考察字符串匹配相关知识，与本题匹配思路有一定相似性。
2. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)：涉及序列匹配，可类比本题对两个序列（环）的处理方式。
3. [P3958 [NOIP2017 提高组] 奶酪](https://www.luogu.com.cn/problem/P3958)：在处理连通性等问题上与本题处理环内和环外元素有相似的思维方式。

### 个人心得摘录与总结
作者 strcmp 提到题目描述较模糊，需要手动模拟才能得出关键结论，这提示在解题时遇到题意不明的情况，可通过具体例子模拟来深入理解题目。 

---
处理用时：29.65秒
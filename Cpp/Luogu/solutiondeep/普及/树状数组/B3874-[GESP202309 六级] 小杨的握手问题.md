# 题目信息

# [GESP202309 六级] 小杨的握手问题

## 题目描述

小杨的班级里共有 $N$ 名同学，学号从 $0$ 至 $N-1$。

某节课上，老师安排全班同学进行一次握手游戏，具体规则如下：老师安排了一个顺序，让全班 $N$ 名同学依次进入教室。每位同学进入教室时，需要和 **已经在教室内** 且 **学号小于自己** 的同学握手。

现在，小杨想知道，整个班级总共会进行多少次握手。

**提示：可以考虑使用归并排序进行降序排序，并在此过程中求解。**

## 说明/提示

**样例解释 1**:

$2$ 号同学进入教室，此时教室里没有其他同学。

$1$ 号同学进入教室，此时教室里有 $2$ 号同学。$1$ 号同学的学号小于 $2$ 号同学，因此他们之间不需要握手。

$3$ 号同学进入教室，此时教室里有 $1,2$ 号同学。$3$ 号同学的学号比他们都大，因此 $3$ 号同学需要分别和另外两位同学握手。

$0$ 号同学进入教室，此时教室里有 $1,2,3$ 号同学。$0$ 号同学的学号比他们都小，因此 $0$ 号同学不需要与其他同学握手。

**样例解释2：**

全班所有同学之间都会进行握手，因为每位同学来到教室时，都会发现他的学号是当前教室里最大的，所以他需要和教室里的每位其他同学进行握手。

对于 $30\%$ 的测试点，保证 $N\le100$。

对于所有测试点，保证 $2\le N\le3\times10^5$。


## 样例 #1

### 输入

```
4
2 1 3 0```

### 输出

```
2```

## 样例 #2

### 输入

```
6
0 1 2 3 4 5```

### 输出

```
15```

# AI分析结果

### 综合分析与结论

本题的核心是计算满足条件的握手次数，即求逆序对的数量。多位作者提供了不同的解法，主要包括归并排序和树状数组两种经典方法。归并排序通过分治策略在排序过程中统计逆序对，而树状数组则通过动态维护前缀和来高效计算逆序对。两种方法的时间复杂度均为 \(O(N \log N)\)，适合处理大规模数据。

### 所选高星题解

#### 1. 作者：wsx248 (赞：11)  
**星级：5星**  
**关键亮点：**  
- 提供了归并排序和树状数组两种解法，代码简洁且高效。  
- 归并排序解法通过递归分治，在合并过程中统计逆序对。  
- 树状数组解法通过动态维护前缀和，适合处理大规模数据。  
**核心代码：**

```cpp
// 归并排序解法
void merge(int l, int r) {
    int mid = l + r >> 1;
    if(l >= r) return;
    merge(l, mid);
    merge(mid+1, r);
    int i = l, j = mid + 1, k = 0;
    while(i <= mid && j <= r) {
        if(a[i] > a[j]) {
            ans += mid - i + 1;
            b[++k] = a[j++];
        } else b[++k] = a[i++];
    }
    while(i <= mid) b[++k] = a[i++];
    while(j <= r) b[++k] = a[j++];
    for(int i = l; i <= r; i++) a[i] = b[i - l + 1];
}

// 树状数组解法
void add(int x, int y) {
    for(int i = x; i <= n; i += lowbit(i)) c[i] += y;
}

int ask(int x) {
    int res = 0;
    for(int i = x; i; i -= lowbit(i)) res += c[i];
    return res;
}
```

#### 2. 作者：CQ_Bob (赞：4)  
**星级：4星**  
**关键亮点：**  
- 使用树状数组高效计算逆序对，代码简洁且易于理解。  
- 通过动态维护前缀和，适合处理大规模数据。  
**核心代码：**

```cpp
void add(int x) {
    while(x <= n) ++tr[x], x += x & (-x);
}

long long query(int x) {
    long long ans = 0;
    while(x) ans += tr[x], x -= x & (-x);
    return ans;
}
```

#### 3. 作者：technopolis_2085 (赞：1)  
**星级：4星**  
**关键亮点：**  
- 通过归并排序统计逆序对，代码简洁且高效。  
- 通过翻转序列，将问题转化为经典的逆序对问题。  
**核心代码：**

```cpp
void solve(int l, int r) {
    if(l == r) return;
    int mid = (l + r) / 2;
    solve(l, mid); solve(mid + 1, r);
    int tot = l, i = l, j = mid + 1;
    while(i <= mid && j <= r) {
        if(a[i] <= a[j]) b[tot++] = a[i++];
        else { ans += (mid - i + 1); b[tot++] = a[j++]; }
    }
    while(i <= mid) b[tot++] = a[i++];
    while(j <= r) b[tot++] = a[j++];
    for(int t = l; t <= r; t++) a[t] = b[t];
}
```

### 最优关键思路与技巧

1. **归并排序**：通过分治策略在排序过程中统计逆序对，时间复杂度为 \(O(N \log N)\)，适合处理大规模数据。
2. **树状数组**：通过动态维护前缀和，高效计算逆序对，时间复杂度为 \(O(N \log N)\)，适合处理大规模数据。

### 可拓展之处

- **逆序对问题**：本题是经典的逆序对问题，可以通过归并排序或树状数组解决。类似问题包括求序列中满足某种条件的对数。
- **分治与动态维护**：归并排序和树状数组是解决逆序对问题的经典方法，可以推广到其他需要分治或动态维护的问题。

### 推荐题目

1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P3374 树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3380 树状数组 2](https://www.luogu.com.cn/problem/P3380)

### 个人心得

- **调试经历**：多位作者提到在实现过程中需要注意边界条件和数据范围，特别是树状数组的实现中，需要将数据整体右移一位以避免 lowbit(0) 的问题。
- **顿悟感想**：通过翻转序列，将问题转化为经典的逆序对问题，简化了问题的解决思路。

---
处理用时：37.28秒
# 题目信息

# 递增

## 题目描述

现有数 $A_1,A_2,\cdots,A_n$，修改最少的数字为**实数**，使得数列严格单调递增。

注：原题误表述为修改为整数，现已纠正为实数。本题数据确保按照修改为整数的做法也可以 AC（只是不能过样例）

## 说明/提示

• 对于50% 的数据，$N \le 10^3$

• 对于100% 的数据，$1 \le N \le 10^5 , 1 \le A_i \le 10^9$


## 样例 #1

### 输入

```
3
1 3 2```

### 输出

```
1```

## 样例 #2

### 输入

```
8
1 2 3 4 4 5 6 7```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心是求最长上升子序列（LIS），通过计算 `n - LIS` 来得到需要修改的最小数字数量。题解中主要涉及以下几种思路：

1. **暴力DP**：时间复杂度为 \(O(n^2)\)，适用于小规模数据，但无法通过大规模数据测试。
2. **二分优化**：利用 `lower_bound` 或自定义二分查找来优化 LIS 的求解，时间复杂度为 \(O(n \log n)\)，适用于大规模数据。
3. **树状数组**：通过树状数组维护前缀最大值，时间复杂度为 \(O(n \log n)\)，代码实现较为复杂。
4. **STL优化**：利用 `lower_bound` 函数简化代码，时间复杂度为 \(O(n \log n)`，代码简洁且高效。

总体来看，二分优化和 STL 优化是本题的主流解法，代码简洁且效率高。树状数组虽然也能达到相同的时间复杂度，但实现较为复杂，适合对树状数组熟悉的选手。

### 所选高星题解

#### 1. 作者：The_Key (赞：71)  
**星级：4.5**  
**关键亮点**：  
- 使用 `lower_bound` 函数简化了 LIS 的求解过程，代码简洁且高效。
- 通过边输入边处理的方式，减少了额外的存储空间。

**核心代码**：
```cpp
for(long long i=1;i<=n;i++) {
    cin>>num;
    if(num>f[now]) f[++now]=num;
    else {
        *lower_bound(f+1,f+now+1,num)=num;
        sum++;
    }
}
```
**核心思想**：  
- 使用 `lower_bound` 找到第一个不小于 `num` 的位置，并将其替换为 `num`，从而维护 LIS 的最小末尾值。

#### 2. 作者：一扶苏一 (赞：27)  
**星级：4.0**  
**关键亮点**：  
- 使用树状数组维护前缀最大值，时间复杂度为 \(O(n \log n)\)。
- 代码实现较为复杂，但展示了树状数组在 LIS 问题中的应用。

**核心代码**：
```cpp
for(rg int i=1;i<=n;++i) {
    frog[MU[i]]=ask(MU[i]-1)+1;
    change(MU[i],frog[MU[i]]);
}
```
**核心思想**：  
- 通过树状数组维护每个位置的前缀最大值，更新 LIS 的长度。

#### 3. 作者：fls233666 (赞：24)  
**星级：4.0**  
**关键亮点**：  
- 详细解释了 LIS 的求解过程，并提供了暴力解法和二分优化解法。
- 通过二分查找优化了 LIS 的求解，时间复杂度为 \(O(n \log n)\)。

**核心代码**：
```cpp
for(int i=1;i<=n;i++) {
    if(a[i]>dp[ans]) dp[++ans]=a[i];
    else {
        int tz=lower_bound(dp,dp+ans,a[i])-dp;
        dp[tz]=a[i];
    }
}
```
**核心思想**：  
- 使用 `lower_bound` 找到第一个不小于 `a[i]` 的位置，并将其替换为 `a[i]`，从而维护 LIS 的最小末尾值。

### 最优关键思路与技巧

- **二分查找优化**：通过 `lower_bound` 或自定义二分查找，将 LIS 的求解时间复杂度从 \(O(n^2)\) 优化到 \(O(n \log n)\)。
- **STL简化代码**：利用 `lower_bound` 函数，代码简洁且易于理解。
- **树状数组应用**：虽然实现复杂，但展示了树状数组在维护前缀最大值中的应用。

### 可拓展之处

- **类似问题**：可以拓展到求解最长不下降子序列（LNDS）或最长下降子序列（LDS）等问题。
- **其他优化**：可以考虑使用线段树或其他数据结构来维护 LIS 的最小末尾值。

### 推荐题目

1. **P1020 导弹拦截**：考察最长不上升子序列和最长上升子序列。
2. **P1091 合唱队形**：考察双向 LIS 的应用。
3. **P1439 最长公共子序列**：考察 LCS 与 LIS 的转化。

### 个人心得摘录

- **The_Key**：通过 `lower_bound` 函数简化了代码，减少了不必要的存储空间，提升了代码的可读性和效率。
- **一扶苏一**：虽然树状数组实现复杂，但展示了其在维护前缀最大值中的应用，适合对树状数组熟悉的选手。
- **fls233666**：详细解释了 LIS 的求解过程，并提供了暴力解法和二分优化解法，适合初学者理解。

---
处理用时：37.78秒
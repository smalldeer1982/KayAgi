# 题目信息

# 数据结构

## 题目背景

**引言**

数据结构学的好，未来工作没烦恼。

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999\_10000&sec=1508946101936&di=0c08b703e466d2a3b2d20dd8008821fc&imgtype=0&src=http%3A%2F%2Fjoymepic.joyme.com%2Farticle%2Fuploads%2Fallimg%2F201511%2F1446516425349678.gif)


Edgration 是一个喜欢乱搞数据结构的蒟蒻（以下简称edt），有一天，他作死想去刁难一下dalao：

edt想求一种数据结构，使得可以实现区间加，求出某一区间大于k的元素的个数

dalao1：sb线段树

dalao2：sb分块

dalao3：sb平衡树

edt: 不行，那就加上取模，求区间取膜mod后大于MIN小于MAX的元素个数

dalao1：线段树&……￥#&……%……&\*&%￥

dalao2：sb分块 &%￥……%#￥#&……&\*

dalao3：\*&……%&￥LCT维护SBT水题 &……%&……%

edt：那不仅取模，每个数乘上数组下标再取模

dalao：￥%￥￥&\*（#￥% 叽里呱啦叽里呱啦

edt：不行，在把取模的值丢到一棵树上，维护一棵仙人掌乘积方差的最小极差

dalao：替罪羊树上用sb块状链表维护Toptree上的最小费用最大流和可持久化仙人掌，算出来在基尔霍夫矩阵中反演后跑一遍fft维护的插头DP就好了，给我三分钟轻松水过。。

edt：mmp


## 题目描述

蒟蒻Edt把这个问题交给了你 ———— 一个精通数据结构的大犇，由于是第一题，这个题没那么难。。


edt 现在对于题目进行了如下的简化：


最开始的数组每个元素都是0


给出$n$，$opt$，$mod$，$min$，$max$，$mod$在int范围内


操作$A$，$Q$


$A$: $L$,$R$,$X$ 表示把$[l,R]$这个区间加上$X$

**（数组的从L到R的每个元素都加上X）**


$Q$: $L$,$R$ 表示询问$[L,R]$这个区间中元素T满足  $min<=(T*i$%$ mod)<=max$  的 T这样的数的个数（i是数组下标）

**（元素的值\*数组下标%mod在min到max范围内）**


由于 edt 请来了一位非三次元的仓鼠，他帮你用延后了部分问题，将这些询问打入了混乱时空，你的询问操作不会超过1000次，不幸的是，对于延后的询问操作可能有很多次（小于1e7次），但是保证这些延后的询问操作之后不会再次有修改操作

（就是在最后会有很多次询问，但不会进行修改）


## 说明/提示

## 样例说明

给出样例1的解释：

样例1中，$a$数组修改为$5$，$5$，$5$

每个$a[i]*i$%$4$ 的值为$1$,$2$,$3$

对于Final的询问

询问$[1$，$3]$中大于等于0小于等于2的个数为2个

剩下的询问类似

## 题目说明

**注意**：

### 1.关于负数取模问题，请以 c++ 的向0取整为标准，即如：

[ $ -7 $%$ 3 = -1 $ ]  [ $ 7 $%$ 3 = 1 $ ]

### 2.一共会有50个测试点，每个点分值为2分。

因为测试点数较多，请oier们自觉地不要故意多次提交来卡评测机，出题人 edt 在这里表示由衷的感谢

## 数据范围

如果你不能作对所有点，请尝试获得部分分，所有数据都是随机生成

![](https://cdn.luogu.com.cn/upload/image_hosting/whf39g4d.png)

## 样例 #1

### 输入

```
3 2 4 0 2
A 1 3 5
Q 2 3 
5
1 3
2 3
1 1 
2 2 
3 3
```

### 输出

```
1
2
1
1
1
0
```

## 样例 #2

### 输入

```
17 25 4098 310 2622
A 10 16 657212040
A 4 15 229489140
A 1 2 -433239891
A 3 12 532385784
A 10 17 56266644
A 8 10 10038874
A 6 9 13084764
A 4 5 -9206340
Q 2 8
A 2 4 -43223955
A 6 9 31478706
A 2 4 189818310
A 2 8 179421180
A 2 8 40354938
Q 8 14
A 3 6 57229575
A 6 13 132795740
A 2 17 14558022
A 14 15 -552674185
A 5 11 -1104138
Q 2 12
Q 1 14
A 3 9 524902182
A 8 12 114291440
A 3 7 107531442
1
11 12
```

### 输出

```
3
6
7
8
2
```

## 样例 #3

### 输入

```
20 3 4317 1020 2232
A 8 15 -434078222
A 1 2 54988154
A 13 19 81757858
15
7 11
3 5
3 9
6 9
9 13
6 19
1 20
3 5
3 10
1 7
2 14
6 10
2 3
2 3
10 12
```

### 输出

```
0
0
0
0
0
2
2
0
0
0
0
0
0
0
0
```

# AI分析结果

### 综合分析与结论

本题的核心需求是实现区间加和区间查询，且查询的条件较为复杂（涉及取模和数组下标）。大部分题解都采用了差分数组来优化区间加操作，并通过前缀和来优化查询操作。差分数组的使用使得区间加操作的时间复杂度降低到O(1)，而前缀和的使用使得查询操作的时间复杂度降低到O(1)。这些优化技巧在处理大规模数据时非常有效。

### 所选高星题解

#### 1. 作者：我太强了 (赞：18) - 5星
**关键亮点**：
- 使用了差分数组优化区间加操作，时间复杂度为O(1)。
- 使用前缀和优化查询操作，时间复杂度为O(1)。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
void ask(ll l,ll r) 
{ 
	now=ans=0;
	for(ll i=1;i<=r;i++) 
	{ 
		now+=delta[i];
		if(i>=l&&(now*i)%mod>=minn&&(now*i)%mod<=maxx) ans++;
	} 
	printf("%lld\n",ans);
} 
```

#### 2. 作者：孑思 (赞：10) - 4星
**关键亮点**：
- 同样使用差分数组优化区间加操作。
- 使用前缀和优化查询操作，代码简洁明了。

**核心代码**：
```cpp
for(long long i=1;i<=n;i++){
	a[i]=a[i-1]+b[i];
	if((a[i]*i)%mod>=minn&&(a[i]*i)%mod<=maxx)sum[i]=sum[i-1]+1;
	else sum[i]=sum[i-1];
}
```

#### 3. 作者：清远学会 (赞：4) - 4星
**关键亮点**：
- 使用差分数组优化区间加操作。
- 使用前缀和优化查询操作，代码结构清晰。

**核心代码**：
```cpp
for(int i = 1;i <= n;i ++) b[i] = b[i - 1] + a[i];
for(int i = 1;i <= n;i ++) b[i] = (b[i] % mod * (long long)i) % mod;
for(int i = 1;i <= n;i ++) 
	if(b[i] >= Min && b[i] <= Max)
		b[i] = 1;
	else b[i] = 0;
for(int i = 1;i <= n;i ++) b[i] += b[i - 1];
```

### 最优关键思路或技巧

1. **差分数组**：用于优化区间加操作，将时间复杂度从O(n)降低到O(1)。
2. **前缀和**：用于优化区间查询操作，将时间复杂度从O(n)降低到O(1)。
3. **离线处理**：对于大量查询操作，可以通过预处理前缀和来减少每次查询的时间复杂度。

### 可拓展之处

- **类似题目**：可以扩展到其他需要频繁进行区间修改和查询的题目，如区间求和、区间最大值等。
- **数据结构**：可以结合线段树、树状数组等数据结构来进一步优化复杂查询。

### 推荐题目

1. **P3372 【模板】线段树 1** - 考察线段树的区间加和区间查询。
2. **P3368 【模板】树状数组 2** - 考察树状数组的区间加和单点查询。
3. **P3373 【模板】线段树 2** - 考察线段树的区间加、区间乘和区间查询。

### 个人心得

- **差分数组的使用**：通过差分数组，可以大大简化区间加操作的实现，减少时间复杂度。
- **前缀和的优化**：前缀和的使用使得查询操作的时间复杂度大大降低，特别是在处理大量查询时非常有效。
- **离线处理的重要性**：对于大量查询操作，离线处理可以显著提高程序的运行效率。

---
处理用时：29.50秒
# 题目信息

# [USACO18OPEN] Out of Sorts S

## 题目描述

留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。

她到目前为止最喜欢的算法是“冒泡排序”。这是 Bessie 的对长度为 $N$ 的数组 $A$ 进行排序的奶牛码实现。

```
sorted = false
while (not sorted):
   sorted = true
   moo
   for i = 0 to N-2:
      if A[i+1] < A[i]:
         swap A[i], A[i+1]
         sorted = false
```
显然，奶牛码中的“moo”指令的作用只是输出“moo”。奇怪的是，Bessie 看上去执着于在她的代码中的不同位置使用这个语句。

给定一个输入数组，请预测 Bessie 的代码会输出多少次“moo”。

## 说明/提示

供题：Brian Dean

## 样例 #1

### 输入

```
5
1
5
3
8
2```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论

这道题的核心在于理解冒泡排序的趟数计算，而不是直接模拟冒泡排序的过程。大多数题解都通过分析冒泡排序的特性，得出了“moo”的次数等于数组中元素向左移动的最大距离加1的结论。这一思路避免了直接模拟排序的低效性，转而通过计算逆序对或元素位置的变化来求解。

### 所选高星题解

#### 1. 作者：t14Zack (赞：36)  
**星级：5星**  
**关键亮点：**  
- 通过分析样例，得出了“moo”次数等于元素向左移动的最大距离加1的结论。
- 使用结构体存储元素的值和原始位置，通过排序后计算最大移动距离。
- 代码简洁，思路清晰，易于理解。

**核心代码：**
```cpp
struct node {
    int in;
    int zhi;
} a[100000];
bool cmp (const node &a, const node &b) {
    return a.zhi < b.zhi || (a.zhi == b.zhi && a.in < b.in);
}
int main() {
    int n, ans = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        scanf("%d", &a[i].zhi), a[i].in = i;
    std::sort(a, a+n, cmp);
    for (int j = 0; j < n; j++)
        ans = max(ans, a[j].in-j);
    printf("%d\n", ans+1);
}
```

#### 2. 作者：ljc20020730 (赞：32)  
**星级：4.5星**  
**关键亮点：**  
- 通过树状数组计算逆序对，得出了冒泡排序的趟数。
- 详细解释了为什么需要加1，即最后一次迭代用于检查数组是否有序。
- 代码实现较为复杂，但思路清晰，适合对树状数组熟悉的读者。

**核心代码：**
```cpp
void update(int x){for (;x<=n;x+=x&-x)c[x]++;}
int query(int x){int ret=0;for (;x;x-=x&-x) ret+=c[x];return ret;}
int main() {
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&a[i]),tmp[i]=a[i];
    sort(tmp+1,tmp+tmp[0]+1);
    T=unique(tmp+1,tmp+1+tmp[0])-tmp-1;
    int ans=0;
    for (int i=1;i<=n;i++) {
        int w=lower_bound(tmp+1,tmp+1+T,a[i])-tmp;
        update(w);
        ans=max(i-query(w),ans);
    }
    printf("%d\n",ans+1);
}
```

#### 3. 作者：hs_black (赞：14)  
**星级：4星**  
**关键亮点：**  
- 通过离散化和树状数组计算逆序对，得出了冒泡排序的趟数。
- 详细解释了冒泡排序的趟数与逆序对的关系，适合对离散化和树状数组有一定基础的读者。
- 代码实现较为复杂，但思路清晰，适合进阶学习。

**核心代码：**
```cpp
void add(int x) {
    for (;x <= n; x += low(x)) d[x]++;
}
int get(int x) {
    int tmp = 0;
    for (;x;x -= low(x)) tmp += d[x];
    return tmp;
}
int main() {
    n = read();
    for (int i = 1;i <= n; i++) p[i] = (node){read(),i};
    sort(p + 1,p + n + 1);
    for (int i = 1;i <= n; i++) p[i].val = i;
    sort(p + 1,p + n + 1, cmp);
    int ans = 0;
    for (int i = 1;i <= n; i++) {
        add(p[i].val);
        ans = max(ans, i - get(p[i].val));
    }
    printf ("%d\n", ans+1);
}
```

### 最优关键思路与技巧

1. **冒泡排序趟数的计算**：通过分析冒泡排序的特性，得出“moo”次数等于元素向左移动的最大距离加1的结论。
2. **逆序对与树状数组**：利用树状数组计算逆序对，从而得出冒泡排序的趟数。
3. **离散化处理**：对于大值域的数据，通过离散化处理，减少树状数组的空间复杂度。

### 可拓展之处

- **逆序对问题**：逆序对的计算在排序、统计问题中经常出现，掌握树状数组或归并排序计算逆序对的方法非常有用。
- **离散化技巧**：对于大值域的数据，离散化是常见的处理手段，适用于需要统计频率或排序的问题。

### 推荐题目

1. **P1908 逆序对**：经典的逆序对计算问题，适合练习树状数组或归并排序。
2. **P3374 树状数组 1**：树状数组的基础应用，适合初学者掌握树状数组的基本操作。
3. **P3368 树状数组 2**：树状数组的进阶应用，适合进一步理解树状数组的区间更新和查询操作。

### 个人心得摘录

- **t14Zack**：通过样例分析，发现“moo”次数等于元素向左移动的最大距离加1，避免了直接模拟排序的低效性。
- **ljc20020730**：解释了为什么需要加1，即最后一次迭代用于检查数组是否有序，这一细节容易被忽略。
- **hs_black**：详细解释了冒泡排序的趟数与逆序对的关系，适合进阶学习。

---
处理用时：46.59秒
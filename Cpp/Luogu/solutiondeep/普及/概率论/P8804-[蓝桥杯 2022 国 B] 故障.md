# 题目信息

# [蓝桥杯 2022 国 B] 故障

## 题目描述

在软件或系统开发中，我们会遇到各种各样的故障。为了从故障现象反推故障原因，工程师们会总结一种叫做相关性矩阵的二维表格，来表示故障原因与故障现象之间的关系。比如:

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/P8804.png)

其中每行表示一种故障原因，每一列表示一种故障现象。该矩阵表示故障原因 $A$ 可能产生故障现象 $2$、$3$、$4$，故障原因 $B$ 可能产生故障现象 $1$、$3$。

在实际开发过程中，如果出现了故障原因，工程师就可以根据故障现象，去计算每种故障原因产生的概率，并按照概率大小对故障原因进行排查，以达到快速定位故障原因的目的。

现在，我们假设系统开发中同一时间只会出现一种故障原因, 并且故障原 因引起各故障现象是独立事件。举个例子来说:

假设系统现在发生了故障原因 $A$, 有 $\frac{1}{3}$ 的概率出现故障现象 $2$，有 $\frac{1}{4}$ 的概率出现故障现象 $3$，有 $\frac{1}{2}$ 的概率出现故障现象 $4$。由于 $3$ 种现象是独立发生的，因此有 $\frac{1}{2 \times 3 \times 4}$ 的概率同时出现故障 $2$、$3$、$4$。

约定若相关性矩阵中没有 `x` 记号, 则表示该故障原因一定不会产生某故障现象，比如故障原因 $A$，一定不会产生故障现象 $1$。根据历史经验数据，我们统计得到了每一种故障原因出现的概率以及每一种故障原因对应的故障现象产生概率。

现在已知系统出现的故障现象，求问各个故障原因发生的概率。

## 说明/提示

对于所有测试用例，$1 \leq N \leq 40,1 \leq M \leq 20,0 \leq P_{i} \leq 100, \sum\left(P_{i}\right)=100$, $0 \leq P_{i j} \leq 100$。

蓝桥杯 2022 国赛 B 组 G 题。

## 样例 #1

### 输入

```
3 5
30 20 50
0 50 33 25 0
30 0 35 0 0
0 0 0 25 60
1
3```

### 输出

```
2 56.89
1 43.11
3 0.00```

# AI分析结果

### 综合分析与结论
这两道题解思路基本一致，均利用贝叶斯公式求解故障原因概率。算法要点在于将输入的百分比转换为小数，通过循环计算每个故障原因发生且产生当前现象的概率，再利用贝叶斯公式得出最终概率并排序输出。解决难点在于理解贝叶斯公式并正确应用到题目场景中。

从质量上看，两篇题解思路清晰，代码可读性尚可，但在优化程度上没有特别突出之处。“FS_qwq”的题解对贝叶斯公式的解释和代码注释更详细，“行吟啸九州”的题解代码使用了`long double`类型，在精度上稍作考虑，但整体代码风格相对简洁。综合评定，两篇题解均为4星。

### 所选的题解
#### 作者：FS_qwq（4星）
- **关键亮点**：对贝叶斯公式的解释详细，代码注释丰富，便于理解。
- **核心代码片段**：
```cpp
for(i=1;i<=N;i++){//i故障发生并且导致出现当前现象的概率 
    dp[i]=a[i];
    for(j=1;j<=M;j++){
        if(c[j])dp[i]=dp[i]*b[i][j];
        else dp[i]=dp[i]*(1-b[i][j]);
    } 
} 
for(i=1;i<=N;i++)sum+=dp[i];//发生当前现象的总概率 
for(i=1;i<=N;i++){
    d[i].id=i;//记录故障编号 
    d[i].p=dp[i]*100.0/sum;//计算故障概率 
}
sort(d+1,d+N+1,cmp);
for(i=1;i<=N;i++)printf("%d %.2lf\n",d[i].id,d[i].p); 
```
核心实现思想：先通过两层循环计算每个故障原因发生且产生当前现象的概率`dp[i]`，再累加所有`dp[i]`得到发生当前现象的总概率`sum`，最后根据贝叶斯公式计算每个故障原因的概率并排序输出。

#### 作者：行吟啸九州（4星）
- **关键亮点**：代码使用`long double`类型，在一定程度上提高了精度，整体代码风格简洁。
- **核心代码片段**：
```cpp
For(i, 1, n){
    a[i].x = i, a[i].w = P[i];
    For(j, 1, m){
        if(vis[j]) a[i].w *= p[i][j];
        else a[i].w *= (100 - p[i][j]);
    }
    sum += a[i].w;
}
sort(a + 1, a + n + 1, cmp);
For(i, 1, n) printf("%lld %.2Lf\n", a[i].x, a[i].w / sum * 100);
```
核心实现思想：与上一题解类似，通过循环计算每个故障原因发生且产生当前现象的概率`a[i].w`，累加得到总概率`sum`，根据贝叶斯公式计算概率并排序输出。

### 最优关键思路或技巧
关键思路是正确理解并应用贝叶斯公式，将题目中的故障原因和现象对应到公式中的事件。代码实现技巧在于利用循环准确计算每个故障原因发生且产生当前现象的概率，同时注意处理概率为百分比的输入，需转换为小数进行计算。

### 可拓展之处
此类题目属于概率统计与算法结合的类型，类似套路可应用于其他根据条件概率反推原因概率的场景，如医疗诊断中根据症状推断疾病发生概率等。

### 相似知识点洛谷题目
1. [P2044 开心的金明](https://www.luogu.com.cn/problem/P2044)：虽主要考察背包问题，但也涉及到对物品价值和概率的计算，与本题对数据的处理有相似之处。
2. [P1281 书的复制](https://www.luogu.com.cn/problem/P1281)：二分答案类问题，在计算过程中需要根据条件判断，与本题在逻辑判断和循环计算上有相似的思维方式。
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：贪心算法题目，在计算最优值过程中需要对数据进行处理和分析，与本题对概率数据的处理和分析有相似之处。

### 个人心得
两篇题解均未提及个人心得。 

---
处理用时：24.21秒
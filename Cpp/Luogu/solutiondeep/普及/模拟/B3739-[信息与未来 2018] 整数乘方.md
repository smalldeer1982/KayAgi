# 题目信息

# [信息与未来 2018] 整数乘方

## 题目描述

定义 $a$ 的 $n$ 次幂 $a^n = a × a × \cdots × a$（共 $n$ 个 $a$ 相乘）。记 $a^n$ 的十进制表示转换为字符串后奇数字符（阿拉伯数字 $1, 3, 5, 7, 9$）的个数为 $A$，偶数字符（阿拉伯数字 $0, 2, 4, 6, 8$）的个数为 $B$，求 $A-B$ 的数值。

例如，$a = 3, n = 12, a^n = 3^{12} = (531441)_{10}$。

奇数数位用方框标出：$\boxed{5}\boxed{3}\boxed{1}44\boxed{1}$，故 $A = 4$；

偶数数位用方框标出：$531\boxed{4}\boxed{4}1$, 故 $B = 2, A-B = 2$。

## 说明/提示

### 样例 $2$ 解释
$5^{18} = 3814697265625，A - B = −1$。
### 数据规模
$30\%$ 的数据满足 $a^n < 2^{32}$；

所有数据满足 $2 ≤ a ≤ 9, 1 ≤ n ≤ 100$。
> 本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
3 12```

### 输出

```
2```

## 样例 #2

### 输入

```
5 18```

### 输出

```
-1```

# AI分析结果

• 综合分析与结论：
    - 本题解提供了两种解法，部分分基于数据规模中部分数据 $a^n < 2^{32}$ 的特点，使用 `unsigned long long` 存储结果，通过快速幂计算并转化为字符串统计奇偶字符个数。正解则针对所有数据，采用高精度乘法解决大数运算问题，因为 $2 ≤ a ≤ 9, 1 ≤ n ≤ 100$ 时，$a^n$ 可能超出常规数据类型范围。整体思路清晰，代码注释详细。
    - 思路清晰度方面，两种解法思路都较明确，先阐述部分分再给出正解。代码可读性上，注释详细，变量命名合理。优化程度上，部分分利用数据范围特点简化计算，正解采用高精度乘法标准做法。综合评定，该题解可得4星。
    - 最优关键思路或技巧：对于部分分，巧妙利用数据范围，采用常规数据类型和快速幂简化计算；对于正解，掌握高精度乘法的实现，这是解决大数运算问题的重要技巧。
    - 可拓展之处：此类题目属于大数运算与数字统计结合类型，类似套路是先解决大数运算（如高精度乘、加、减、除等），再对结果按要求统计。
    - 推荐洛谷题目：P1601 A+B Problem（高精度加法基础题）、P1303 A*B Problem（高精度乘法，与本题正解知识点相同）、P1603 斯诺登的密码（涉及大数运算与数字处理）。
    - 本题解无个人心得。

所选的题解：
  - 星级：4星
  - 关键亮点：提供两种解法，部分分利用数据范围简化计算，正解采用高精度乘法解决大数问题，代码注释详细。
  - 部分分核心代码：
```cpp
lint qpow(lint a, int b) { // 快速幂模板
    lint ans = 1;
    while (b) {
        if (b & 1) ans *= a;
        a *= a, b /= 2;
    }
    return ans;
}

int main() {
    lint a; int b;
    std::cin >> a >> b;
    std::string s = std::to_string(qpow(a, b)); // 将结果变为字符串方便统计
    int cnt1 = 0, cnt2 = 0;
    for (auto ch : s) { // 遍历每一个字符
        if ((ch - '0') & 1) cnt1++; // 如果是奇数字符
        else cnt2++;
    }
    std::cout << cnt1 - cnt2;
    return 0;
}
```
核心实现思想：通过快速幂计算 $a^n$，再将结果转为字符串，遍历字符串统计奇偶字符个数并输出差值。
  - 正解核心代码：
```cpp
std::string prod(std::string sa, std::string sb) {
    size_t la = sa.size(), lb = sb.size(); // 获得长度
    size_t lm = la + lb + 1;
    std::vector<int> a(la), b(lb), c(lm); 
    for (size_t i = 0; i < la; ++i) a[i] = sa[la - i - 1] - '0';
    for (size_t i = 0; i < lb; ++i) b[i] = sb[lb - i - 1] - '0';
    for (size_t i = 0; i < la; ++i)
        for (size_t j = 0; j < lb; ++j)
            c[i + j] += a[i] * b[j]; 
    for (size_t i = 0; i < lm - 1; ++i)
        c[i + 1] += c[i] / 10, c[i] %= 10; 
    while (c.size() > 1 && c.back() == 0) c.pop_back(); 
    std::string ans; 
    for (int i = c.size() - 1; i >= 0; --i) ans += c[i] + '0';
    return ans;
}

std::string pow(int a, int n) { 
    std::string ans = "1";
    std::string a1 = std::to_string(a);
    while (n--)
        ans = prod(ans, a1);
    return ans;
}

int main() {
    int a, n, cnt1 = 0, cnt2 = 0;
    std::cin >> a >> n;
    auto s = pow(a, n);
    for (auto ch : s) {
        if ((ch - '0') & 1) ++cnt1;
        else ++cnt2;
    }
    std::cout << cnt1 - cnt2;
    return 0;
}
```
核心实现思想：通过 `prod` 函数实现高精度乘法，`pow` 函数利用 `prod` 计算 $a^n$，最后对结果字符串统计奇偶字符个数输出差值。 

---
处理用时：53.78秒
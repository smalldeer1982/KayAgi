# 题目信息

# [信息与未来 2023] 程序分析

## 题目描述

程序分析技术是一种用于理解和改进计算机程序的方法。它可以帮助我们找出程序中的错误、提高程序的性能、优化代码结构等。其中，静态分析技术在不运行程序的情况下对程序代码进行分析。它可以检查代码的语法、风格、潜在错误等。例如，静态分析可以帮助我们找出程序中未使用的变量、可能的数组越界等问题。

小小设计了一个自己的编程语言，并命名为 X 语言。你能为它设计一个静态分析器吗？

X 语言程序中只有两个整型变量 $x$ 和 $y$，且无需定义，可以直接使用。变量 $x$ 的值从程序外输入（输入值可以是任何 C++ int 范围内的值），$y$ 的初始值是 $0$。一个 X 语言程序由若干行组成，每行恰好包含一条命令，是以下三种命令之一：
1. 条件分支：`if (条件) {`；
2. 对 $y$ 赋值：`y = 数字;`；
3. 条件结束：`}`。

其中，“条件”要么是 `x > 数字`，要么是 `x < 数字`。赋值语句和条件中的“数字”都是 $1$ 到 $10^9$ 之间的常数。`if` 和赋值的含义同 C++ 语言中的条件和赋值语句。

请你编写一个静态分析器，分析一个 X 语言程序执行结束时，所有可能的 $y$ 的值。

## 说明/提示

对于 $100\%$ 的数据，满足 $1\le n \le 10^3$。输入数据的每行都不超过 $10^3$ 个字符。

>本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
10
if (x > 1) {
  y = 2;
  if (x > 10) {
    y = 1;
    y = 4;
    if (x < 5) {
      y = 3;
    }
  }
}```

### 输出

```
0 2 4```

## 样例 #2

### 输入

```
(见 p4.zip 中的 2-in.txt)```

### 输出

```
(见 p4.zip 中的 2-out.txt)```

## 样例 #3

### 输入

```
(见 p4.zip 中的 3-in.txt)```

### 输出

```
(见 p4.zip 中的 3-out.txt)```

# AI分析结果

### 综合分析与结论
这两道题解的核心思路都是通过模拟程序执行来找出所有可能的 $y$ 值。主要差异在于数据结构的使用和模拟方式。
- **Greenzhe题解**：
    - **思路**：先定义结构体表示程序每行语句，通过扫描程序记录语句类型、条件及匹配括号位置。利用贪心和几何角度分析，得出每个条件语句对应一个关键 $x$ 值（`x<val` 对应 `val - 1`，`x>val` 对应 `val + 1`），将这些值存入 `listx`，对每个值调用 `simulate` 函数模拟程序执行得到 $y$ 值，最后存入 `set` 去重输出。
    - **算法要点**：结构体存储语句信息，利用栈匹配括号，通过模拟函数 `simulate` 执行程序逻辑。
    - **解决难点**：优化暴力枚举 $x$ 的方法，提出关键 $x$ 值的概念，降低时间复杂度。
- **andyli题解**：
    - **思路**：定义递归结构体 `Statement` 表示程序，通过递归读取输入行构建程序结构。循环让 $x$ 为每个条件语句中的“数字”加减 $1$，调用 `dfs` 函数递归模拟程序执行，将得到的 $y$ 值存入数组，最后去重输出。
    - **算法要点**：递归结构体构建程序，深度优先搜索 `dfs` 模拟执行。
    - **解决难点**：通过递归结构和 `dfs` 实现程序逻辑模拟。

**评分**：
- **Greenzhe题解**：4星。思路清晰，代码可读性较好，对暴力解法有优化。
- **andyli题解**：4星。采用递归结构构建程序，思路独特，但代码可读性稍逊于Greenzhe题解。

### 所选的题解
#### Greenzhe题解（4星）
- **关键亮点**：对暴力枚举优化，提出关键 $x$ 值，降低时间复杂度；代码结构清晰，变量命名易懂。
```cpp
struct sentence{ // 每一行
	bool type; // if 语句为 1，赋值语句为 0
	char op; // x>val 还是 x<val
	int val; // 判断的值
	int ed; // 与之匹配的右括号所在的行数
}se[1005];
int simulate(int x){
	int y=0;
	for(int i=1;i<=n;++i){
		if(se[i].type){ // 判断语句
			if(se[i].op=='>')
				if(x<=se[i].val) i=se[i].ed; // 不满足要求就跳
			if(se[i].op=='<')
				if(x>=se[i].val) i=se[i].ed; // 不满足要求就跳
		}
		else y=se[i].val; // 赋值语句
	}
	return y;
}
```
核心实现思想：`simulate` 函数通过遍历语句数组 `se`，根据语句类型和条件判断是否执行赋值语句，从而模拟程序执行得到 $y$ 值。

#### andyli题解（4星）
- **关键亮点**：使用递归结构体表示程序，通过递归构建和 `dfs` 模拟执行，思路新颖。
```cpp
struct Statement: std::vector<Statement> {
    // y!= -1 表示一个赋值语句，IF!= 0 表示一个条件语句，此时 vector 中存放分支语句。
    // IF > 0 表示 >，IF < 0 表示 <
    int y = -1, IF = 0;
};
auto construct = [&](auto&& construct) -> Statement {
    Statement r;
    loop {
        std::string s;
        if (!io.readline(s))
            break;
        if (s.find("if")!= s.npos) {
            Statement t;
            if (s.find('>')!= s.npos) {
                int x = std::stoi(s.substr(s.find('>') + 2));
                t.IF = x;
                a.push_back(x + 1);
                a.push_back(x - 1);
            }
            else {
                int x = std::stoi(s.substr(s.find('<') + 2));
                t.IF = -x;
                a.push_back(x + 1);
                a.push_back(x - 1);
            }
            t.push_back(construct(construct));
            r.push_back(t);
        }
        else if (s.find('}')!= s.npos) {
            break;
        }
        else {
            Statement t;
            t.y = std::stoi(s.substr(s.find('=') + 2));
            r.push_back(t);
        }
    }
    return r;
};
auto statements = construct(construct);
```
核心实现思想：`construct` 函数通过循环读取输入行，根据行内容构建递归结构体 `Statement`，将条件语句和赋值语句分别处理并构建成树形结构。

### 最优关键思路或技巧
1. **关键 $x$ 值选取**：通过分析条件语句，选取最靠近条件的值（`x<val` 对应 `val - 1`，`x>val` 对应 `val + 1`）作为关键 $x$ 值，减少模拟次数，优化暴力枚举。
2. **递归结构构建程序**：如andyli题解，利用递归结构体表示程序，方便通过递归和深度优先搜索模拟程序执行。

### 可拓展之处
此类题目属于程序模拟与分析类型，类似套路可应用于其他简单编程语言的语义分析、代码执行结果预测等题目。可以拓展到更复杂的条件语句（如逻辑与、或）、更多变量及不同类型变量的情况。

### 洛谷相似题目
1. P1036 [NOIP2002 普及组] 选数：考察递归和枚举思想，与本题模拟过程中的递归和对关键值的处理类似。
2. P1161 开灯：涉及逻辑判断和模拟，与本题对条件语句的判断和模拟程序执行有相似之处。
3. P1469 [USACO2.1] 数字三角形 Number Triangles：通过递归或动态规划求解，与本题构建递归结构和模拟执行思路有一定关联。 

---
处理用时：50.35秒
# 题目信息

# [信息与未来 2024] 数据排序

## 题目描述

在计算机世界中，“表格”是一种简单、基础而且十分通用的数据结构，在数据库、人工智能等领域中都有广泛的应用。表格由若干行、若干列的单元格组成：

| Name     | p1   | p2   | p3   | Score |
| :------- | :--- | ---- | ---- | ----- |
| ZhangSan | 40   | 30   | 28   | 98    |
| LiSi     | 40   | 28   | 30   | 98    |
| WangWu   | 40   | 25   | 20   | 85    |

CSV (Comma-Separated Values) 是一种常用的表格格式。Dr. X 需要你编程处理简化的 CSV 文
件，格式规定如下：

- CSV 文件包含 $n$ 行数据，其中第一行是标题行。
- CSV 文件每行一个字符串，对应了表格的一行。行中的单元格由**半角逗号**分隔。
- 每个单元格至少包含一个字符。单元格有两种类型：
  - **数值单元格**：由至少一个数字字符 $(0\sim 9)$ 组成。
  - **字符串单元格**：由数字字符 $(0\sim 9)$ 和大小写字母 $(\tt{a\sim z},\tt{A\sim Z})$ 组成,且至少包含一个字母。

- 标题行的所有单元格都是字符串单元格，且互不相同。标题行中包含了列的名称。

以下是一个 CSV 文件的示例：

```
Name,p1,p2,p3,Score
ZhangSan,40,30,28,98
LiSi,40,28,30,98
WangWu,40,25,20,85
```

你的任务是**根据指定的列为表格中的行排序**。例如根据 `Score- , Name+ , p3-` 排序意味着：

- 优先按 Score 列从大到小排序。Score 列都是数值单元格，因此按数值排序。

- 如果 Score 列相同，按 Name 列从小到大排序。Name 列都是字符串单元格，因此按照字典排序。

- 如果 Score 和 Name 列都相同，按 p3 列从大到小排序。p3 列都是数值单元格，因此按数
  值排序。

我们保证 CSV 文件每一行的单元格数量相同，且除标题行外，**每一列要么全是数值单元格，要么全是字符串单元格**。

## 说明/提示

对于 $100\%$ 的数据，满足 $1 \leq n \leq 100$，表格不超过 $10$ 列，字符串单元格不超过 $16$ 个字符，且数值单元格中的数值是 $0$ 到 $10^4$ 之间的整数。

>本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
4
Name,p1,p2,p3,Score
ZhangSan,40,30,28,98
LiSi,40,28,30,98
WangWu,40,25,20,85
3
Score-
Name+
p3-```

### 输出

```
Name,p1,p2,p3,Score
LiSi,40,28,30,98
ZhangSan,40,30,28,98
WangWu,40,25,20,85```

# AI分析结果

### 综合分析与结论
这些题解主要围绕从CSV格式数据中提取信息、存储数据、按特定规则排序并输出结果展开。思路上，都先处理表头和表格数据的读入，判断单元格类型（数字或字符串），再根据给定排序规则进行排序。算法要点在于字符串处理（以逗号分隔提取信息）和自定义排序函数。难点主要是处理不同类型单元格的排序以及保证排序的稳定性。

多数题解采用结构体或`vector`存储数据，自定义`cmp`函数实现排序规则。部分题解使用`map`来建立表头与列下标的映射，方便根据表头确定排序依据的列。在代码实现上，各题解在细节处理和代码风格上有所不同。

### 所选的题解
- **作者：FFTotoro (5星)**
    - **关键亮点**：使用`std::variant<int, std::string>`存储单元格数据，简洁处理不同类型数据存储问题。利用`stable_sort`保证排序稳定性，代码逻辑清晰，整体实现简洁高效。
    - **重点代码**：
```cpp
inline vector<variant<int,string> > f(string s){
    vector<variant<int,string> > a;
    for(int i=0,j;i<s.length();i=j+1){
        string t;
        for(j=i;j<s.length()&&s[j]!=',';j++)t+=s[j];
        bool D=true; 
        for(char i:t)D&=isdigit(i);
        if(D)a.emplace_back(stoi(t));
        else a.emplace_back(t);
    }
    return a;
} 
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int n; string h; cin>>n>>h;
    auto H=f(h);
    vector<string> t(n-1);
    for(auto &i:t)cin>>i;
    vector<vector<variant<int,string> > > T(n-1);
    for(int i=0;i<n-1;i++)T[i]=f(t[i]);
    vector<pair<int,int> > C;
    int m; cin>>m;
    for(int i=0;i<m;i++){
        string s; cin>>s;
        for(int j=0;j<H.size();j++)
            if(s.substr(0,s.length()-1)==get<string>(H[j])){
                C.emplace_back(j,s.back()=='+'); break;
            } 
    }
    stable_sort(T.begin(),T.end(),[&](auto x,auto y){
        for(auto [a,s]:C)
            if(x[a]!=y[a])return s?x[a]<y[a]:x[a]>y[a];
        return false;
    }); 
    cout<<h<<endl;
    for(auto x:T)
        for(int j=0;j<x.size();j++){
            if(get_if<int>(&x[j]))x[j]=to_string(get<int>(x[j]));
            cout<<get<string>(x[j])<<",\n"[j==x.size()-1];
        }
    return 0;
}
```
    - **核心实现思想**：`f`函数按逗号分隔字符串并判断单元格类型存储到`variant`。主函数中，先处理表头和表格数据，再读取排序规则存入`C`。最后用`stable_sort`结合`lambda`表达式按规则排序并输出。

- **作者：沉石鱼惊旋 (4星)**
    - **关键亮点**：思路清晰，通过结构体存储单元格信息（类型、值），并离线存储排序方式，在比较函数中按顺序遍历排序方式进行比较，同时利用`id`保证相同条件下原顺序。
    - **重点代码**：
```cpp
struct node
{
    bool op; 
    int x;
    string y;
};
vector<node> a[120];
bool isstr(string s)
{
    int cnt = 0;
    for (char c : s)
        if (isdigit(c))
            cnt++;
    return cnt < s.size();
}
bool ccmp(vector<node> a, vector<node> b)
{
    for (int i = 1; i <= c; i++)
    {
        int op = cmp[i].back();
        string t = cmp[i].substr(0, cmp[i].size() - 1);
        int j = title[t];
        if (op == '+')
        {
            if (!a[j].op)
            {
                if (a[j].x == b[j].x)
                    continue;
                return a[j].x < b[j].x;
            }
            else
            {
                if (a[j].y == b[j].y)
                    continue;
                return a[j].y < b[j].y;
            }
        }
        else
        {
            if (!a[j].op)
            {
                if (a[j].x == b[j].x)
                    continue;
                return a[j].x > b[j].x;
            }
            else
            {
                if (a[j].y == b[j].y)
                    continue;
                return a[j].y > b[j].y;
            }
        }
    }
    return a[0].x < b[0].x;
}
```
    - **核心实现思想**：`node`结构体存储单元格信息，`isstr`判断字符串类型。`ccmp`函数中遍历排序方式，根据类型和升降序规则比较两个`vector<node>`。

### 最优关键思路或技巧
- **数据结构选择**：使用`std::variant<int, std::string>`（C++17）可简洁处理不同类型数据存储。若不支持C++17，也可像部分题解用结构体存储类型和对应值。
- **排序稳定性**：因题目要求相同条件保持原顺序，使用`stable_sort`保证稳定性。
- **字符串处理**：利用字符串流（`stringstream`）或手动遍历以逗号分隔字符串，提取表头和单元格信息，提高代码简洁性和可读性。

### 可拓展之处
此类题目拓展方向主要是增加数据规模、复杂排序规则或数据类型。类似算法套路为处理混合类型数据时合理选择数据结构存储，自定义排序函数实现复杂排序规则，同时注意排序稳定性。

### 相似知识点洛谷题目
- [P1080 [NOIP2012 提高组] 国王游戏](https://www.luogu.com.cn/problem/P1080)：涉及结构体排序和高精度计算，需自定义排序规则。
- [P1933 [USACO10MAR]仓配置Barn Allocation](https://www.luogu.com.cn/problem/P1933)：通过结构体存储数据并按特定规则排序，考查排序应用。
- [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)：同样是结构体排序问题，需推导并实现复杂排序条件。

### 个人心得摘录与总结
- **作者：GLr137**：强调`sort`是不稳定排序，在所有排序方式都相同的情况下，必须在`cmp`函数最后返回比较两个参数读入时建立的下标数值，否则可能WA或RE。总结了处理输入字符串以逗号分隔提取信息的方法，以及如何通过函数判断字符串是否为数字、将字符串转换为数字等细节。 

---
处理用时：51.38秒
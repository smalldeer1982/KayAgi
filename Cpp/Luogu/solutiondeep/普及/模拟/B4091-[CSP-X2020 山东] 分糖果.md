# 题目信息

# [CSP-X2020 山东] 分糖果

## 题目背景

老师组织一群孩子围成一个圈进行游戏，游戏结束后老师会根据每个孩子的表现进行评分并给予糖果奖励。

## 题目描述

每个孩子只能看见与自己相邻的 $2$ 个孩子（左边的和右边的）的情况，只会关心相邻的且比自己评分低的同学的糖果数（如果相邻 $2$ 个孩子的评分相等，则不关心）。为保证公平，相邻的孩子中，评分高的孩子必须获得更多的糖果(如果左右相邻 $2$ 个孩子的评分相等，则不关心，即分最少的糖果 $1$ 个）。同时，为鼓励孩子的积极性，每个孩子至少都能拿到 $1$ 个糖果。现在需要你帮助老师来分发糖果，问怎么分配才能使要准备的糖果数最少？计算出需要的最少糖果数。

## 说明/提示

【数据范围】

对于 $40\%$ 的数据，$1\leq n\leq 100$；

对于 $100\%$ 的数据，$1\leq n\leq 10^5$;

所有评分都是 $0$ 到 $100$ 之间的一个整数。

【样例解释】

样例一，分别分配 $2,3,1$ 的糖果，所以最少需要 $6$ 个糖果。

样例二，分别分配 $1,2,1,2$ 的糖果，所以最少需要 $6$ 个糖果。

## 样例 #1

### 输入

```
3
1 2 0```

### 输出

```
6```

## 样例 #2

### 输入

```
4
2 3 3 3```

### 输出

```
6```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解思路基本一致，均先给每个孩子初始化为1颗糖果，然后通过循环不断调整相邻孩子糖果数量，直至满足相邻孩子中评分高的孩子糖果数更多的条件。
    - 算法要点：每次循环遍历所有孩子，比较相邻孩子评分与糖果数，按规则调整糖果数。
    - 解决难点：需证明调整过程不会无限循环，各题解均指出不会出现类似$a_1 < a_2 < \cdots < a_n < a_1$的情况。
    - 整体质量：多数题解思路清晰，但代码实现细节和优化程度有所差异。

所选的题解：
  - SkyLines（5星）
    - 关键亮点：思路阐述清晰，明确指出两种不公平情况及调整方式，代码简洁规范，利用宏定义简化类型声明，逻辑严谨。
    - 重点代码核心思想：通过while循环不断调整糖果分配，每次循环遍历孩子，判断相邻孩子评分与糖果数关系并调整，直至无调整发生。
```cpp
while(1){
    flg = 0;
    for(int i = 1; i <= n; i++){
        j = ((i == n)? 1 : (i + 1));
        if(a[i] < a[j] && cnt[i] >= cnt[j]){
            cnt[j] = cnt[i] + 1;
            flg = 1;
        }else if(a[i] > a[j] && cnt[j] >= cnt[i]){
            cnt[i] = cnt[j] + 1;
            flg = 1;
        }
    }
    if(!flg) break;
}
```
  - CASCwty（4星）
    - 关键亮点：思路分析简洁明了，直接指出孩子不满足条件的两种情况及处理方式，代码结构清晰，注释详细。
    - 重点代码核心思想：与SkyLines类似，通过while循环和for循环遍历孩子，依据相邻孩子评分与糖果数关系调整糖果数，直至满足条件。
```cpp
while(flag)
{
    flag=false;
    for(int i=1;i<=n;i++)
    {
        nxt=(i==n)?1:i+1;
        if(a[i]<a[nxt]&&candy[i]>=candy[nxt])
        {
            candy[nxt]=candy[i]+1;
            flag=true;
        }
        else if(a[i]>a[nxt]&&candy[i]<=candy[nxt])
        {
            candy[i]=candy[nxt]+1;
            flag=true;
        }
    }
}
```
  - yyycj（4星）
    - 关键亮点：对思路的描述详细，结合彭罗斯阶梯形象说明不会无限循环的情况，代码规范，有自定义的输入输出函数。
    - 重点代码核心思想：利用while循环和for循环，每次循环检查相邻孩子评分与糖果数，按规则调整糖果数，记录不满足要求的次数，直至所有孩子满足要求。
```cpp
while (cnt) {
    cnt = 0;
    for (int i=1;i<=n;i++) {
        int r = i % n + 1;
        if (score[i]>score[r] && candy[i]<=candy[r]) {
            candy[i] = candy[r] + 1;
            cnt++;
        }
        else if (score[i]<score[r] && candy[i]>=candy[r]) {
            candy[r] = candy[i] + 1;
            cnt++;
        }
    }
}
```

最优关键思路或技巧：采用贪心策略，每次仅在最低条件下满足相邻孩子糖果分配规则，通过不断循环调整直至整体满足条件，同时利用环形结构特点处理首尾相邻关系。

可拓展思路：此类题属于贪心策略应用，类似题目常围绕如何在满足一系列条件下求最优解。常见套路为分析局部最优与全局最优的关系，通过局部最优策略逐步达到全局最优。

推荐题目：
  - P1080 [NOIP2012 提高组] 国王游戏
  - P1094 [NOIP2007 普及组] 纪念品分组
  - P1199 [NOIP2010 普及组] 三国游戏 

---
处理用时：24.24秒
# 题目信息

# 独木桥

## 题目背景

战争已经进入到紧要时间。你是运输小队长，正在率领运输部队向前线运送物资。运输任务像做题一样的无聊。你希望找些刺激，于是命令你的士兵们到前方的一座独木桥上欣赏风景，而你留在桥下欣赏士兵们。士兵们十分愤怒，因为这座独木桥十分狭窄，只能容纳 $1$ 个人通过。假如有 $2$ 个人相向而行在桥上相遇，那么他们 $2$ 个人将无法绕过对方，只能有 $1$ 个人回头下桥，让另一个人先通过。但是，可以有多个人同时呆在同一个位置。

## 题目描述

突然，你收到从指挥部发来的信息，敌军的轰炸机正朝着你所在的独木桥飞来！为了安全，你的部队必须撤下独木桥。独木桥的长度为 $L$，士兵们只能呆在坐标为整数的地方。所有士兵的速度都为 $1$，但一个士兵某一时刻来到了坐标为 $0$ 或 $L+1$ 的位置，他就离开了独木桥。

每个士兵都有一个初始面对的方向，他们会以匀速朝着这个方向行走，中途不会自己改变方向。但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。

由于先前的愤怒，你已不能控制你的士兵。甚至，你连每个士兵初始面对的方向都不知道。因此，你想要知道你的部队最少需要多少时间就可能全部撤离独木桥。另外，总部也在安排阻拦敌人的进攻，因此你还需要知道你的部队最多需要多少时间才能全部撤离独木桥。

## 说明/提示

对于 $100\%$ 的数据，满足初始时，没有两个士兵同在一个坐标，$1\le  L\le5\times 10^3$，$0\le N\le5\times10^3$，且数据保证 $N\le L$。

## 样例 #1

### 输入

```
4
2
1 3
```

### 输出

```
2 4```

# AI分析结果

• 综合分析与结论：
    - 思路：多数题解抓住两人相遇转身等同于交换灵魂（或擦肩而过）继续走这一关键，将问题简化为计算士兵分别向两端行走的时间。求最小时间即所有人中走完桥最小值中的最大值；求最大时间即所有人中走完桥最大值中的最大值。少数题解采用暴力模拟，通过模拟士兵移动来求解。
    - 算法要点：利用上述关键思路，对每个士兵位置计算向两端走的时间，通过比较找出最大和最小时间。排序、循环遍历、取最值操作是常见实现方式。
    - 解决难点：关键在于理解并接受相遇转身等同于继续走这一逆向思维，突破常规模拟中对相遇掉头的复杂处理。
    - 整体来看，多数题解思路相近，质量差异主要体现在思路阐述清晰度、代码可读性及是否考虑边界情况等方面。

以下是评分较高的题解：
  - 作者：GXuLuogu (赞：348)  星级：5星
    - 关键亮点：思路清晰，先点明核心思想“两人相遇转身相当于交换灵魂后继续走”，再阐述最大最小值的计算逻辑，代码简洁明了，还考虑了N == 0的特判情况。
    - 个人心得：无
    - 重点代码及核心思想：
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
const int size = 5005;
int a[size];
int main()
{
    int L,N;
    cin>>L>>N;
    if (!N) {
        cout<<"0 0"<<endl;
        return 0;
    }
    for (int i=1;i<=N;i++) cin>>a[i]; 
    sort(a+1,a+N+1); 
    int max_time,min_time;
    for (int i=1;i<=N;i++)
        min_time=max(min(a[i],L+1-a[i]),min_time); 
    max_time=max(L+1-a[1],a[N]); 
    cout<<min_time<<' '<<max_time<<endl;
    return 0;
}
```
核心思想：先输入数据并排序，通过循环计算每个士兵到两端距离的最小值，取这些最小值中的最大值作为最小时间；通过比较最左端和最右端士兵到另一端的距离，取较大值作为最大时间。
  - 作者：Adis_FireDevil (赞：22)  星级：4星
    - 关键亮点：表述简洁，直接指出第i个士兵撤离的两种时间计算方式，进而得出最大最小时间的计算方法，代码简短清晰。
    - 个人心得：无
    - 重点代码及核心思想：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5011],l,n,maxn=0,minn=0;
int main() {
	cin>>l>>n;
	for(int i=1; i<=n; i++) {
		cin>>a[i];
		maxn=max(maxn,max(l+1-a[i],a[i]));	
		minn=max(minn,min(l+1-a[i],a[i]));	
	}
	cout<<minn<<" "<<maxn;
}
```
核心思想：循环读入每个士兵位置，每次更新最大时间（每个士兵到两端距离的较大值中的最大值）和最小时间（每个士兵到两端距离的较小值中的最大值）。
  - 作者：ciyou (赞：3)  星级：4星
    - 关键亮点：思路阐述简洁明了，先点明最短和最长时间的计算思路，代码逻辑清晰，直接在循环中计算并更新最大最小值。
    - 个人心得：无
    - 重点代码及核心思想：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int L,N;
int location[100001];
int minn,maxn;
int main() {
    minn=0;
    scanf("%d\n%d\n",&L,&N);
    for(int i=1;i<=N;i++){
        scanf("%d",&location[i]);
        minn=max(min(L-location[i]+1,location[i]),minn);
        maxn=max(max(L-location[i]+1,location[i]),maxn);
    }
    printf("%d %d\n",minn,maxn);
    return 0;
}
```
核心思想：循环读入士兵位置，每次通过比较当前士兵到两端的距离，更新最小时间（较小距离的最大值）和最大时间（较大距离的最大值）。

• 最优关键思路或技巧：利用逆向思维，将相遇转身等效为继续走，避免复杂的相遇掉头模拟，简化问题求解过程。

• 可拓展之处：同类型题常考察对复杂场景下运动过程的简化与抽象，类似算法套路为通过对运动规则的深入理解，找到等效的简单模型来求解。

• 推荐洛谷题目：
    - P1085 [NOIP2005 普及组] 不高兴的津津
    - P1164 小A点菜
    - P1004 [NOIP2000 提高组] 方格取数

• 个人心得摘录与总结：
    - 作者“芝麻糊糊”：刚开始毫无头绪，在纸上画后答案浮现，发现和大多数人思路一样。总结为遇到难题可通过画图辅助思考，寻找解题思路。
    - 作者“my_load”：看着题愣了半个小时才领悟，发现题目玄机在于利用士兵的对称性简化问题。强调面对复杂题目要深入思考，挖掘题目隐藏信息，突破常规思维。 

---
处理用时：59.27秒
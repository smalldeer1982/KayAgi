# 题目信息

# [NOIP 2000 普及组] 计算器的改良

## 题目背景

NCL 是一家专门从事计算器改良与升级的实验室，最近该实验室收到了某公司所委托的一个任务：需要在该公司某型号的计算器上加上解一元一次方程的功能。实验室将这个任务交给了一个刚进入的新手 ZL 先生。


## 题目描述

为了很好的完成这个任务，ZL 先生首先研究了一些一元一次方程的实例：

- $4+3x=8$。
- $6a-5+1=2-2a$。
- $-5+12y=0$。

ZL 先生被主管告之，在计算器上键入的一个一元一次方程中，只包含整数、小写字母及 `+`、`-`、`=` 这三个数学符号（当然，符号“`-`”既可作减号，也可作负号）。方程中并没有括号，也没有除号，方程中的字母表示未知数。

你可假设对键入的方程的正确性的判断是由另一个程序员在做，或者说可认为键入的一元一次方程均为合法的，且有唯一实数解。


## 样例 #1

### 输入

```
6a-5+1=2-2a
```

### 输出

```
a=0.750```

# AI分析结果

• 综合分析与结论：这些题解的核心思路都是将输入的一元一次方程整理成标准形式，进而求解。算法要点在于处理方程中的符号、数字、未知数，分别统计常数项和未知数系数。难点主要是处理特殊情况，如系数为1或0的特殊写法、 -0.0的输出等。多数题解通过设置变量标记符号、位置等，按字符逐一处理方程。部分题解利用了一些C++特性或技巧，如cin.peek()、ASCII码运算等。

所选的题解：
 - **作者：吴名玄 (5星)**
    - **关键亮点**：思路清晰，详细阐述每一步处理过程，代码注释丰富，对特殊情况处理讲解细致。
    - **个人心得**：提到因 -0.0输出问题在第五个测试点出错，强调需特判。
    - **核心代码片段**：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
char c,a;
int f=1,now=1,k,b,x;
bool r;
int main()
{
    while(cin>>c)
    {
        if(c=='-') {b+=now*f*x;x=0;f=-1;r=0;}
        if(c=='+') {b+=now*f*x;x=0;f=1;r=0;}
        if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;r=0;}
        if(c>='a'&&c<='z')
        {
            if(r)
            {
                k+=now*f*x;x=0;
            }
            else k+=now*f;
            a=c;r=0;
        }
        if(c>='0'&&c<='9') {x=x*10+c-'0';r=1;}
    }
    b+=now*f*x;
    double ans=double(-b*1.0/k);
    if(ans==-0.0) ans=0;
    printf("%c=%.3lf",a,ans);
    return 0;
}
```
    - **核心实现思想**：用多个变量记录状态，如f记录符号，now记录相对等号位置。按字符读入方程，根据字符类型分别处理，最后计算并输出结果，同时处理特殊情况。

 - **作者：Jy_Amoy (4星)**
    - **关键亮点**：结合小学解方程步骤阐述思路，代码逻辑清晰，通过数组存储数字，分别处理等号两边内容。
    - **个人心得**：提到通过询问老师和大佬了解到浮点数负零的问题，强调需特判。
    - **核心代码片段**：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
double num=0,x=0;
char c,p;
int a[100],l=1,mid,pd;
int main()
{
    memset(a,0,sizeof(a));
    pd=1;
    while(c!='=')
    {
        c=getchar();
        if(c=='-')
            ++l,pd=-1;
        if(c=='+')
            ++l,pd=1;
        if(c>='0'&&c<='9')
        {
            if(!a[l])
                a[l]=(c-'0')*pd;
            else
                a[l]=a[l]*10+(c-'0')*pd;
        }
        if(c>='a'&&c<='z')
        {
            p=c;
            if(a[l]!=0)
                x+=a[l],a[l]=0;
            else
                x+=pd;
            --l;
        }
    }
    mid=l,++l,pd=1;
    while(c!='\n')
    {
        c=getchar();
        if(c=='-')
            ++l,pd=-1;
        if(c=='+')
            ++l,pd=1;
        if(c>='0'&&c<='9')
        {
            if(!a[l])
                a[l]=(c-'0')*pd;
            else
                a[l]=a[l]*10+(c-'0')*pd;
        }
        if(c>='a'&&c<='z')
        {
            p=c;
            if(a[l]!=0)
                x-=a[l],a[l]=0;
            else
                x-=pd;
            --l;
        }
    }
    for(int i=1;i<=l;++i)
    {
        if(i<=mid)
            num-=a[i];
        else
            num+=a[i];
    }
    if(!(num/x))
        printf("%c=0.000",p);
    else
        printf("%c=%.3lf",p,num/x);
    return 0; 
}
```
    - **核心实现思想**：利用数组a存储数字，pd标记正负，分别读入等号两边内容，统计常数和与系数和，最后相除求解并处理特殊情况。

 - **作者：teafrogsf (4星)**
    - **关键亮点**：利用ASCII码值简化符号判断，通过一个if处理加减操作，代码简洁高效。
    - **个人心得**：无
    - **核心代码片段**：
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#define f(i,a,b) for(register int i=a;i<=b;++i)
bool flag,havenum;
char s[100010],ansx;
int son,mother,pre,lor=1,equal;
int main()
{
    int len;
    scanf("%s",s+1);
    s[pre]='+';len=strlen(s+1);s[len+1]='+';
    f(i,1,len+1)
    {
        if(s[i]>='a'&&s[i]<='z')ansx=s[i];
        if(s[i]=='='||s[i]=='-'||s[i]=='+')
        {
            havenum=0;
            if(i==1||i-1==equal){pre=i;continue;}
            int j,x=0;
            if(isdigit(s[i-1]))flag=0;
            else flag=1;
            for(j=pre+1;j<=i-1-flag;++j)
            {x=(x<<1)+(x<<3)+(s[j]^'0');havenum=1;}
            if(havenum==0)x=1;
            if(flag==0)son+=x*lor*-1*(s[pre]-44)*-1;
            else mother+=x*lor*(s[pre]-44)*-1;
            pre=i;
            if(s[i]=='=')lor=-1,s[i]='+',equal=i;
        }
    }double ansy=double(son)/double(mother);if(fabs(ansy)-0.0<0.000001)ansy=0.0;
    printf("%c=%.3lf",ansx,ansy);return 0;
}
```
    - **核心实现思想**：通过ASCII码值运算判断符号，用son和mother分别记录整数和与未知数系数和，按字符处理方程，最后相除求解并处理特殊情况。

**最优关键思路或技巧**：利用变量记录状态（如符号、位置等），按字符逐位处理方程，同时注意特殊情况的处理，如系数为1或0的特殊写法、 -0.0的输出等。部分题解利用ASCII码值简化符号判断，或使用cin.peek()提前窥视字符等技巧，使代码更简洁高效。

**可拓展之处**：同类型题可拓展到多元一次方程求解，或带括号、除号等更复杂的方程处理。类似算法套路是通过设置状态变量，按字符或词法分析输入内容，结合数学规则进行处理。

**推荐题目**：
 - [P1085 [NOIP2004 普及组] 不高兴的津津](https://www.luogu.com.cn/problem/P1085)
 - [P1909 [NOIP2016 普及组] 买铅笔](https://www.luogu.com.cn/problem/P1909)
 - [P1149 火柴棒等式](https://www.luogu.com.cn/problem/P1149)

---
处理用时：54.37秒
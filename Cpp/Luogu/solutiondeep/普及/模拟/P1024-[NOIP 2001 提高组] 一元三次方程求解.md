# 题目信息

# [NOIP 2001 提高组] 一元三次方程求解

## 题目描述

有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。

提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。

## 说明/提示

**【题目来源】**

NOIP 2001 提高组第一题

## 样例 #1

### 输入

```
1 -5 -4 20
```

### 输出

```
-2.00 2.00 5.00
```

# AI分析结果

### 综合分析与结论
这些题解主要采用了暴力枚举、二分法、牛顿迭代法、割线法以及公式法（盛金公式、卡尔丹公式）来求解一元三次方程。
 - **暴力枚举**：直接在[-100, 100]范围内，以较小步长（如0.001）枚举可能的根，判断函数值是否接近0或区间两端函数值异号来确定根，优点是思路简单，缺点是效率较低。
 - **二分法**：利用根与根之差绝对值≥1的条件，以长度为1的区间为单位，判断区间两端函数值异号则在此区间二分查找根，相比暴力枚举效率有所提升。
 - **牛顿迭代法**：通过构造函数在某点的切线，使其切线与x轴交点作为下次迭代猜测值，不断逼近函数的解，收敛速度较快，但需计算函数导数。
 - **割线法**：基于牛顿法改进，用割线斜率代替导数，将非线性方程化为线性方程迭代求解，收敛速度比牛顿法略慢。
 - **公式法**：盛金公式和卡尔丹公式直接根据方程系数计算根，盛金公式计算可能涉及三角函数导致精度问题，卡尔丹公式相对复杂但精度较好。

综合来看，二分法在思路清晰、实现难度和效率上较为平衡；牛顿迭代法理论上速度快但实现稍复杂；暴力枚举简单直接但效率低。公式法依赖记忆公式且盛金公式精度有缺陷。

### 所选的题解
 - **北街的九命貓 - 二分法 - 5星**
    - **关键亮点**：思路清晰，先利用题目条件确定二分区间，再在每个小区间内二分查找根，代码简洁明了，对二分的控制和边界处理得当。
    - **重点代码**：
```cpp
double fc(double x)
{
    return a*x*x*x+b*x*x+c*x+d;
}
int main()
{
    double l,r,m,x1,x2;
    int s=0,i;
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);  
    for (i=-100;i<100;i++)
    {
        l=i; 
        r=i+1;
        x1=fc(l); 
        x2=fc(r);
        if(!x1) 
        {
            printf("%.2lf ",l); 
            s++;
        }      
        if(x1*x2<0)                             
        {
            while(r-l>=0.001)                     
            {
                m=(l+r)/2; 
                if(fc(m)*fc(r)<=0) 
                   l=m; 
                else 
                   r=m;  
            }
            printf("%.2lf ",r);  
            s++;
        }
        if (s==3) 
            break;             
    }
    return 0;
}
```
    - **核心思想**：定义函数fc计算方程值，外层循环枚举长度为1的区间，判断区间端点函数值，若左端点为0直接输出；若区间内有根（两端点函数值异号），则在区间内二分查找，控制精度直到找到根并输出，找到三个根后退出。
 - **GGN_2015 - 牛顿迭代法 - 4星**
    - **关键亮点**：采用牛顿迭代法，给出详细原理说明，代码实现中通过类封装函数及导数计算，利用集合去重保证根的唯一性。
    - **重点代码**：
```cpp
struct func3
{
    double a,b,c,d;
    func3(double A=0,double B=0,double C=0,double D=0){a=A;b=B;c=C;d=D;}
    double operator()(double x){return ((a*x+b)*x+c)*x+d;}
    double dvt(double x){return (3.0*a*x+2.0*b)*x+c;}
};

void func3solve(func3 f,double st,double& val,double& sol)
{
    for(int i=1;!(abs(f(st))<1e-6) && i<=100;i++)
    {
        st=st-f(st)/f.dvt(st);
    }
    val=f(st);sol=st;
}

int main()
{
    double a,b,c,d;
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
    func3 f(a,b,c,d);
    for(double i=-100.0;i<=100.0;i+=0.5)
    {
        double val,sol;
        func3solve(f,i,val,sol);
        sol=fix2(sol);
        if(abs(val)<1e-6 && solutions.find(sol)==solutions.end())
            solutions.insert(sol);
    }
    for(set<double>::iterator it=solutions.begin();it!=solutions.end();it++)
    {
        double x=(*it);
        printf("%.2lf ",x);
    }
    return 0;
}
```
    - **核心思想**：定义func3类，重载()运算符计算函数值，dvt函数计算导数。func3solve函数通过牛顿迭代法不断更新猜测值，主函数中在[-100, 100]以0.5步长枚举初始值，利用func3solve求解并通过集合去重输出根。
 - **高木木 - 暴力枚举 - 4星**
    - **关键亮点**：暴力枚举思路简单直接，代码简洁，利用题目条件直接在范围内枚举并判断根，符合初学者思维。
    - **重点代码**：
```cpp
int main()
{
	scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
	for(double i=-100.00;i<=100.00;i+=0.001)
	{
		double l=i,r=i+0.001;
		if((a*l*l*l+b*l*l+c*l+d)*(a*r*r*r+b*r*r+c*r+d)<0)
		printf("%.2f ",l),num++;
		if(num==3) break;
	}
	return 0;
}
```
    - **核心思想**：输入方程系数后，在[-100, 100]以0.001步长枚举，判断相邻两个值对应的函数值乘积是否小于0，若是则输出左端点值，找到三个根后退出。

### 最优关键思路或技巧
二分法是较为平衡的方法，利用根的分布特性缩小查找范围，相比暴力枚举大大提高效率。关键在于合理划分初始区间（利用根间距条件），并在小区间内通过二分查找精确根的位置，控制好精度。

### 可拓展之处
此类题目属于数值计算中方程求解问题，相似套路有利用函数特性（单调性、连续性）确定根所在区间，再用迭代法或分治思想逼近根。类似题目可考虑更高次方程求解，或方程根有其他约束条件的情况。

### 相似知识点洛谷题目
 - **P1305 新二叉树**：涉及树的遍历与数值计算，需结合数据结构和数值处理知识。
 - **P2141 珠心算测验**：通过枚举和判断实现，考查基本的算法实现和逻辑判断。
 - **P1012 [NOIP1998 提高组] 拼数**：需要对数字组合进行枚举和比较，锻炼枚举和逻辑思维能力。 

---
处理用时：58.69秒
# 题目信息

# [NOIP 2001 提高组] Car 的旅行路线

## 题目描述

又到暑假了，住在城市 A 的 Car 想和朋友一起去城市旅游。  
她知道每个城市都有 $4$ 个飞机场，分别位于一个矩形的 $4$ 个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第 $i$ 个城市中高速铁路的单位里程价格为 $T_i$，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为 $t$。


![](https://cdn.luogu.com.cn/upload/image_hosting/odqxn9sz.png)

**注意**：图中并没有标出所有的铁路与航线。


那么 Car 应如何安排到城市 B 的路线才能尽可能的节省花费呢？她发现这并不是一个简单的问题，于是她来向你请教。


找出一条从城市 A 到 B 的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10$，$1\le S \le 100$，$1\le A,B \le S$。

**【题目来源】**

NOIP 2001 提高组第四题

## 样例 #1

### 输入

```
1
3 10 1 3
1 1 1 3 3 1 30
2 5 7 4 5 2 1
8 6 8 8 11 6 3```

### 输出

```
47.5```

# AI分析结果

### 综合分析与结论
这道题主要是在给定城市机场分布及不同交通方式价格的情况下，求从城市A到城市B的最小花费路线。各题解思路和算法要点相似，主要难点在于根据矩形三个点求第四个点以及构建图来计算最短路。
1. **思路**：均先通过几何方法求出每个城市矩形机场缺失的第四个点坐标，之后构建图，图中边权根据机场是否在同一城市分别设置为铁路或航线费用，最后用最短路算法求解。
2. **算法要点**：利用几何知识求点坐标，根据机场所属城市设置边权，运用最短路算法（Floyd、Dijkstra、SPFA）计算最小花费。
3. **解决难点**：通过矩形对角线互相平分等几何性质求缺失点坐标；通过编号对应等方式判断机场是否在同一城市以设置边权。

### 所选的题解
1. **作者：_jimmywang_（5星）**
    - **关键亮点**：思路清晰，先详细分析建图和最短路两部分。建图时，利用中点公式求出矩形第四个点坐标，并通过编号巧妙判断机场所属城市。最短路选择Floyd算法，代码简洁明了，符合数据范围。
    - **个人心得**：提到题目代码长、相近变量多，需仔细分析。
    - **核心代码**：
```cpp
// 求两点距离
double diss(double x1, double y1, double x2, double y2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }
// 求两点距离的平方
double ds(double x1, double y1, double x2, double y2) { return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2); }

int main() {
    scanf("%lld", &TTT);
    while (TTT--) {
        memset(dis, 0, sizeof(dis)), ans = inf;
        scanf("%lld%lf%lld%lld", &s, &t, &A, &B);
        // 输入每个城市的三个点并求第四个点
        for (int i = 1; i <= s; i++) {
            scanf("%lf%lf%lf%lf%lf%lf%lf", &x[(i - 1) * 4 + 1], &y[(i - 1) * 4 + 1], &x[(i - 1) * 4 + 2], &y[(i - 1) * 4 + 2], &x[(i - 1) * 4 + 3], &y[(i - 1) * 4 + 3], &T[i]);
            double dab = ds(x[(i - 1) * 4 + 1], y[(i - 1) * 4 + 1], x[(i - 1) * 4 + 2], y[(i - 1) * 4 + 2]);
            double dac = ds(x[(i - 1) * 4 + 1], y[(i - 1) * 4 + 1], x[(i - 1) * 4 + 3], y[(i - 1) * 4 + 3]);
            double dbc = ds(x[(i - 1) * 4 + 2], y[(i - 1) * 4 + 2], x[(i - 1) * 4 + 3], y[(i - 1) * 4 + 3]);
            if (dab + dac == dbc)x[i * 4] = x[(i - 1) * 4 + 2] + x[(i - 1) * 4 + 3] - x[(i - 1) * 4 + 1], y[i * 4] = y[(i - 1) * 4 + 2] + y[(i - 1) * 4 + 3] - y[(i - 1) * 4 + 1];
            else if (dab + dbc == dac)x[i * 4] = x[(i - 1) * 4 + 1] + x[(i - 1) * 4 + 3] - x[(i - 1) * 4 + 2], y[i * 4] = y[(i - 1) * 4 + 1] + y[(i - 1) * 4 + 3] - y[(i - 1) * 4 + 2];
            else if (dbc + dac == dab)x[i * 4] = x[(i - 1) * 4 + 2] + x[(i - 1) * 4 + 1] - x[(i - 1) * 4 + 3], y[i * 4] = y[(i - 1) * 4 + 2] + y[(i - 1) * 4 + 1] - y[(i - 1) * 4 + 3];
        }
        // 建图
        for (int i = 1; i <= s * 4; i++)
            for (int j = 1; j <= s * 4; j++)
                if (i!= j) {
                    if ((i - 1) / 4!= (j - 1) / 4)dis[i][j] = t * diss(x[i], y[i], x[j], y[j]);
                    else dis[i][j] = T[(i - 1) / 4 + 1] * diss(x[i], y[i], x[j], y[j]);
                }
        // Floyd算法求最短路
        for (int k = 1; k <= s * 4; k++)
            for (int i = 1; i <= s * 4; i++)
                for (int j = 1; j <= s * 4; j++)
                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
        // 求A到B的最小花费
        for (int i = 1; i <= 4; i++)
            for (int j = 1; j <= 4; j++)
                ans = min(ans, dis[(A - 1) * 4 + i][(B - 1) * 4 + j]);
        printf("%.1lf\n", ans);
    }
    return 0;
}
```
2. **作者：LiJunze0501（4星）**
    - **关键亮点**：详细阐述求直角点从而得出第四个点坐标的方法，逻辑清晰。同样采用Floyd算法，代码结构完整，注释详细。
    - **核心代码**：
```cpp
int pf(int x) { return x * x; }
double dis(int xx, int yy) { return sqrt(pf(air[xx].x - air[yy].x) + pf(air[xx].y - air[yy].y)); }
// 求第四个机场的坐标
void getair4(int id) {
    double d12 = pf(air[4 * (id - 1) + 1].x - air[4 * (id - 1) + 2].x) + pf(air[4 * (id - 1) + 1].y - air[4 * (id - 1) + 2].y);
    double d23 = pf(air[4 * (id - 1) + 2].x - air[4 * (id - 1) + 3].x) + pf(air[4 * (id - 1) + 2].y - air[4 * (id - 1) + 3].y);
    double d13 = pf(air[4 * (id - 1) + 1].x - air[4 * (id - 1) + 3].x) + pf(air[4 * (id - 1) + 1].y - air[4 * (id - 1) + 3].y);
    if (d12 + d13 == d23) {
        air[4 * id].x = air[4 * (id - 1) + 2].x + air[4 * (id - 1) + 3].x - air[4 * (id - 1) + 1].x;
        air[4 * id].y = air[4 * (id - 1) + 2].y + air[4 * (id - 1) + 3].y - air[4 * (id - 1) + 1].y;
    }
    if (d12 + d23 == d13) {
        air[4 * id].x = air[4 * (id - 1) + 1].x + air[4 * (id - 1) + 3].x - air[4 * (id - 1) + 2].x;
        air[4 * id].y = air[4 * (id - 1) + 1].y + air[4 * (id - 1) + 3].y - air[4 * (id - 1) + 2].y;
    }
    if (d23 + d13 == d12) {
        air[4 * id].x = air[4 * (id - 1) + 1].x + air[4 * (id - 1) + 2].x - air[4 * (id - 1) + 3].x;
        air[4 * id].y = air[4 * (id - 1) + 1].y + air[4 * (id - 1) + 2].y - air[4 * (id - 1) + 3].y;
    }
}

int main() {
    cin >> n;
    while (n--) {
        cin >> s >> t >> a >> b;
        for (int i = 1; i <= 4 * s; i++)
            for (int j = 1; j <= 4 * s; j++)
                if (i!= j) cost[i][j] = INT_MAX;
        for (int i = 1; i <= s; i++) {
            cin >> air[4 * (i - 1) + 1].x >> air[4 * (i - 1) + 1].y;
            cin >> air[4 * (i - 1) + 2].x >> air[4 * (i - 1) + 2].y;
            cin >> air[4 * (i - 1) + 3].x >> air[4 * (i - 1) + 3].y;
            cin >> Tp[i - 1];
            getair4(i);
        }
        for (int i = 1; i <= 4 * s; i++)
            for (int j = 1; j <= 4 * s; j++)
                if (i!= j) cost[i][j] = cost[j][i] = ((i - 1) / 4 == (j - 1) / 4)? dis(i, j) * Tp[(i - 1) / 4] : dis(i, j) * t;
        for (int k = 1; k <= 4 * s; k++)
            for (int i = 1; i <= 4 * s; i++)
                for (int j = 1; j <= 4 * s; j++)
                    if (i!= j && j!= k && i!= k) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);
        double ans = INT_MAX;
        for (int i = 1; i <= 4; i++)
            for (int j = 1; j <= 4; j++) ans = min(ans, cost[4 * (a - 1) + i][4 * (b - 1) + j]);
        printf("%.1lf\n", ans);
    }
}
```
3. **作者：rediserver（4星）**
    - **关键亮点**：采用Dijkstra算法求解最短路，通过宏定义清晰表示机场编号与城市编号的关系，代码结构清晰，对Dijkstra算法的应用针对本题做了适当调整，如起点设为起点城市的4个机场。
    - **核心代码**：
```cpp
float CarRoute::getAirportDist(Airport & a, Airport & b) {
    return sqrt(square(a.x - b.x) + square(a.y - b.y));
}

float CarRoute::dijkstra(int src_city, int des_city) {
    float *cost = new float[nAirports_];
    bool *collected = new bool[nAirports_];
    fill(cost, cost + nAirports_, NO_VALUE);
    fill(collected, collected + nAirports_, false);
    for (int i = 0; i < 4; i++)
        cost[GET_AIRPORT_INDEX(src_city, i)] = 0;
    while (true) {
        int minV = NO_VALUE;
        float minCost = NO_VALUE;
        for (int i = 0; i < nAirports_; i++)
            if (!collected[i] && cost[i]!= NO_VALUE && (cost[i] < minCost || minCost == NO_VALUE)) {
                minV = i;
                minCost = cost[i];
            }
        int minCity = GET_CITY_INDEX(minV);
        if (minCity == des_city) {
            free(cost);
            free(collected);
            return minCost;
        }
        if (minV == NO_VALUE) break;
        collected[minV] = true;
        for (int i = 0; i < nAirports_; i++)
            if (!collected[i]) {
                float dist = getAirportDist(airports_[minV], airports_[i]);
                float cost_tmp = GET_CITY_INDEX(i) == minCity? dist * cost_train_[minCity] : dist * cost_air_;
                if (minCost + cost_tmp < cost[i] || cost[i] == NO_VALUE) {
                    cost[i] = minCost + cost_tmp;
                }
            }
    }
    free(cost);
    free(collected);
    return NO_VALUE;
}
```

### 最优关键思路或技巧
1. **利用几何性质求点坐标**：通过矩形对角线互相平分、直角三角形三边关系等几何知识，根据已知的三个点求出矩形第四个点坐标。
2. **编号对应判断城市**：通过合理的编号方式，如按顺序给机场编号，使机场编号与城市编号存在简单的数学关系（如(i - 1) / 4），方便判断机场是否在同一城市，进而设置边权。
3. **根据数据范围选算法**：由于数据范围$s \leqslant 100$，最多400个点，Floyd算法$O(n^3)$可通过，其代码简洁，实现方便；若担心$O(n^3)$超时，可采用堆优化的Dijkstra算法，时间复杂度$O(n^2log_n)$。

### 拓展思路
同类型题可涉及不同的地理布局（如三角形、多边形等）下的路径规划，或增加更多交通方式及限制条件。类似算法套路是先根据几何条件确定各点位置，构建图并合理设置边权，再选择合适的最短路算法求解。

### 相似知识点洛谷题目
1. **P3371 【模板】单源最短路径（弱化版）**：基础的单源最短路问题，可用于练习Dijkstra等最短路算法。
2. **P1339 热浪**：同样是求最短路，可加深对最短路算法应用的理解。
3. **P4779 【模板】单源最短路径（标准版）**：更标准的单源最短路问题，可进一步巩固相关算法。 

---
处理用时：92.74秒
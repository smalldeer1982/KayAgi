# 题目信息

# [NOIP 2001 普及组] 求先序排列

## 题目描述

给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \le 8$）。


## 说明/提示

**【题目来源】**

NOIP 2001 普及组第三题

## 样例 #1

### 输入

```
BADC
BDCA
```

### 输出

```
ABCD
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕通过二叉树的中序和后序排列求先序排列展开。多数题解思路基于后序遍历最后一个节点是根节点这一特性，结合中序遍历确定左右子树，进而递归求解。算法要点在于如何准确划分中序和后序遍历的左右子树部分。难点在于理解递归过程中各子树的划分及对应关系。

所选的题解：
  - 作者：sunyufei (5星)
    - 关键亮点：思路清晰，简洁明了地阐述了通过后序找根，中序分左右子树递归的方法，并给出简洁的代码实现。
    - 重点代码：
```cpp
void beford(string in,string after){
    if (in.size()>0){
        char ch=after[after.size()-1];
        cout<<ch;
        int k=in.find(ch);
        beford(in.substr(0,k),after.substr(0,k));
        beford(in.substr(k+1),after.substr(k,in.size()-k-1));
    }
}
```
    - 核心实现思想：函数接收中序和后序字符串，每次取后序最后字符为根输出，通过中序找到根位置划分左右子树，递归处理左右子树。
  - 作者：NeosKnight (4星)
    - 关键亮点：详细分析了通过中序和后序遍历找出两段子树后序遍历序列的方法，对难点剖析到位。
    - 重点代码：
```cpp
void dfs(int l1,int r1,int l2,int r2)
{
    int m=find(s2[r2]);
    cout<<s2[r2];
    if(m>l1) dfs(l1,m-1,l2,r2-r1+m-1);
    if(m<r1) dfs(m+1,r1,l2+m-l1,r2-1);
}
```
    - 核心实现思想：通过递归函数，利用中序找根位置，根据左右子树节点数确定后序遍历中左右子树范围，递归输出先序遍历。
  - 作者：UNDERTALE_RS (4星)
    - 关键亮点：不仅给出递归求解思路与代码，还详细介绍了二叉树遍历的前置知识，适合初学者理解。
    - 重点代码：
```cpp
int buildTree(string InOd,string PostOd){
    int len = InOd.size();
    if(len == 0) return 0;
    
    char c = PostOd[len-1];
    int root = ++pos;
    tree[root].val = c;
    
    int k = InOd.find(c); 
    
    tree[root].l = buildTree(InOd.substr(0,k),PostOd.substr(0,k));
    tree[root].r = buildTree(InOd.substr(k+1),PostOd.substr(k,len-k-1)); 
    return root;
}

void printPreOd(int root){
    cout << tree[root].val; 
    if(tree[root].l) printPreOd(tree[root].l); 
    if(tree[root].r) printPreOd(tree[root].r); 
}
```
    - 核心实现思想：先通过递归建树函数，利用后序找根，中序分左右子树递归建树，再通过先序遍历函数输出先序序列。

最优关键思路或技巧：利用后序遍历确定根节点，结合中序遍历划分左右子树，通过递归方式处理子树，这是解决此类问题的核心思路。

可拓展之处：同类型题可拓展到已知其他两种遍历求第三种遍历，或在二叉树相关操作中结合此方法进行树结构还原与处理。类似算法套路常用于树结构的重建与遍历相关问题。

推荐题目：
  - P1030 [NOIP2001 普及组] 求先序排列（本题）
  - P1827 [USACO3.4] 美国血统 American Heritage
  - P2077 [NOI2007] 树网的核

个人心得摘录与总结：
  - 作者：Ybw0731提到本题坑点在于中序和后序遍历时要去掉根节点，在分裂字符串时需注意位置。总结为处理字符串划分时要关注根节点位置对左右子树划分的影响，避免边界错误。 

---
处理用时：33.62秒
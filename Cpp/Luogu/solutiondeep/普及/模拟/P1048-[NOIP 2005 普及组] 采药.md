# 题目信息

# [NOIP 2005 普及组] 采药

## 题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”


如果你是辰辰，你能完成这个任务吗？


## 说明/提示

**【数据范围】**

- 对于 $30\%$ 的数据，$M \le 10$；
- 对于全部的数据，$M \le 100$。

**【题目来源】**

NOIP 2005 普及组第三题

## 样例 #1

### 输入

```
70 3
71 100
69 1
1 2
```

### 输出

```
3```

# AI分析结果

• 综合分析与结论：这些题解均指出本题是01背包问题。思路上，都通过定义状态和状态转移方程求解，即定义dp数组，dp[i][j] 表示前i个物品在背包容量为j时的最大价值，转移方程为 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]) （当j >= w[i]时，否则dp[i][j] = dp[i - 1][j] ），其中w[i] 是物品重量（本题为采药时间），v[i] 是物品价值（本题为草药价值）。部分题解还提到一维dp优化，即将dp数组简化为一维，内层循环需逆序以避免物品重复放入。算法要点在于准确理解背包模型，难点在于状态转移方程的推导及一维dp优化时循环顺序的理解。
  - 作者decoqwq（5星）：关键亮点是对二维和一维dp都进行了详细的举例分析，通过具体数据展示dp数组的变化过程，帮助理解动态规划过程，代码简洁清晰。
    ```cpp
    // 二维dp代码
    #include "iostream"
    #include "stdio.h"
    using namespace std;
    int w[105],val[105];
    int dp[105][1005];
    int main()
    {
        int t,m,res=-1;
        scanf("%d%d",&t,&m);
        for(int i=1;i<=m;i++)
        {
            scanf("%d%d",&w[i],&val[i]);
        }
        for(int i=1;i<=m;i++) 
            for(int j=t;j>=0;j--)  
            {
                if(j>=w[i])
                {
                    dp[i][j]=max(dp[i-1][j-w[i]]+val[i],dp[i-1][j]);
                }  
                else
                {
                    dp[i][j]=dp[i-1][j];
                }              
            }
        printf("%d",dp[m][t]);
        return 0;
    }
    // 一维dp代码
    #include "stdio.h"
    #include "iostream"
    using namespace std;
    int w[105], val[105];
    int dp[1005];
    int main()
    {
        int t,m,res=-1;    
        scanf("%d%d",&t,&m);
        for(int i=1;i<=m;i++)
        {
            scanf("%d%d",&w[i],&val[i]);
        }
        for(int i=1;i<=m;i++) 
        {
            for(int j=t;j>=0;j--) 
            {
                if(j>=w[i])
                {
                    dp[j]=max(dp[j-w[i]]+val[i], dp[j]);
                }
            }
        }    
        printf("%d",dp[t]);
        return 0;
    }
    ```
  - 作者ljh0727（4星）：关键亮点是不仅给出常规二维01背包代码，还提到空间优化的滚动数组做法，并给出两种做法的完整代码，思路清晰。
    ```cpp
    // 正常的01背包
    #include<iostream>
    #include<cstdio>
    #include<cmath>
    using namespace std;
    const int M=105;
    int dp[M][M],w[M],v[M];
    int main(){
        int n,m;
        scanf("%d%d",&n,&m);
        for(int i=1;i<=m;i++){
            scanf("%d%d",&w[i],&v[i]);
        }
        for(int i=1;i<=m;i++){
            for(int j=n;j>=0;j--){
                if(j>=w[i]){
                    dp[i][j]=max(dp[i-1][j-w[i]]+v[i],dp[i-1][j]);
                }else{
                    dp[i][j]=dp[i-1][j];
                }
            }
        }
        printf("%d",dp[m][n]);
        return 0;
    } 
    // 滚动数组优化后的01背包
    #include<iostream>
    #include<cstdio>
    #include<cmath>
    using namespace std;
    const int M=105;
    int w[M],v[M];
    int dp[M*10];
    int main(){
        int n,m,res=-1;
        scanf("%d%d",&n,&m);
        for(int i=1;i<=m;i++){
            scanf("%d%d",&w[i],&v[i]);
        }
        for(int i=1;i<=m;i++){
            for(int j=n;j>=0;j--){
                if(j>=w[i]){
                    dp[j]=max(dp[j-w[i]]+v[i],dp[j]);
                }
            }
        }
        printf("%d",dp[n]);
        return 0;
    }
    ```
  - 作者4041nofoundGeoge（4星）：关键亮点是先通过反例否定贪心算法，再详细推导动态规划的状态转移方程，对状态转移方程的最优性进行解释，还提到滚动数组优化思路。
    ```cpp
    // 二维dp代码
    #include <bits/stdc++.h>
    using namespace std;
    int t[105],v[105];
    int dp[105][1005];
    int main()
    {
        int T,M;
        cin>>T>>M;
        for(int i=1;i<=M;i++)
        {
            cin>>t[i]>>v[i];
        }
        for(int i=1;i<=M;i++)
        {
            for(int j=1;j<=T;j++)
            {
                if(j<t[i])dp[i][j]=dp[i-1][j];
                else
                {
                    dp[i][j]=max(dp[i-1][j],dp[i-1][j-t[i]]+v[i]);
                }
            }
        }
        cout<<dp[M][T];
        return 0;
    }
    // 滚动数组优化核心代码
    for (int i = 1; i <= M; i++)
        for (int l = T; l >= t[i]; l--)
            f[l] = max(f[l], f[l - t[i]] + v[i]);
    ```
• 最优关键思路或技巧：
  - 动态规划思想：将问题分解为子问题，通过求解子问题的最优解得到原问题的最优解。
  - 状态定义与转移：准确地定义状态（如dp[i][j]）和状态转移方程，这是解决背包问题的核心。
  - 空间优化：利用滚动数组将二维dp优化为一维dp，降低空间复杂度，同时要注意内层循环需逆序遍历。
• 可拓展之处：此类题属于背包问题类型，类似的还有完全背包（每个物品可无限次选取）、多重背包（每个物品有一定数量限制）等。解决思路都是基于动态规划，关键在于状态定义和转移方程的调整。
• 推荐题目：
  - P1060 [NOIP2006 普及组] 开心的金明：01背包问题的变形，同样是在一定限制内求最大价值。
  - P1616 疯狂的采药：完全背包问题，与本题类似但草药可重复采，考察对不同背包类型的理解。
  - P2602 [ZJOI2010] 数字计数：结合数位dp和背包思想，拓展对动态规划应用场景的理解。
• 个人心得：无。 

---
处理用时：54.21秒
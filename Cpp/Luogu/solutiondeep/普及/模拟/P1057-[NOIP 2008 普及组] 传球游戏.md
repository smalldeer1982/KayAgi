# 题目信息

# [NOIP 2008 普及组] 传球游戏

## 题目描述

上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。

游戏规则是这样的：$n$ 个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。

聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了 $m$ 次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学 $1$ 号、$2$ 号、$3$ 号，并假设小蛮为 $1$ 号，球传了 $3$ 次回到小蛮手里的方式有 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$ 和 $1 \rightarrow 3 \rightarrow 2 \rightarrow 1$，共 $2$ 种。


## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据，满足：$3 \le n \le 30,1 \le m \le 20$；
- 对于 $100\%$ 的数据，满足：$3 \le n \le 30,1 \le m \le 30$。

2008普及组第三题


## 样例 #1

### 输入

```
3 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕传球游戏问题，给出了搜索和动态规划（DP）等解法。
 - **搜索解法**：以BFS为例，通过结构体记录球的位置和传球次数，将每种传球可能压入队列，不断扩展状态。但暴力BFS会超时，加剪枝优化效果仍不佳，如判断当前位置能否到达目标位置进行剪枝。
 - **动态规划解法**：定义状态`dp[i][j]`表示球传到`i`号同学且传球次数为`j`次的方案数，状态转移方程为`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]`，同时需特判`i = 1`和`i = n`的边界情况。部分题解还提到可通过滚动数组优化空间。

综合来看，DP解法是解决本题的有效方法，搜索解法虽直观但效率低。

### 所选的题解
 - **作者：HighPerformanceRobot（5星）**
    - **关键亮点**：思路清晰，不仅给出暴力BFS和剪枝优化的过程，还详细讲解DP解法，从找规律入手引导得出状态转移方程，并配有手模拟过程辅助理解，对初学者友好。
    - **个人心得**：强调DP对新手痛苦，可先打暴力，再慢慢思考正解；还提到打表也是一种解题思路。
    - **重点代码（DP部分）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[31][31],i,j,m,n;
int main()
{
    cin>>n>>m;
    f[0][1]=1;
    for(int i=1; i<=m; i++)
        for(int j=1; j<=n; j++)
            if(j==1)
                f[i][j]=f[i-1][n]+f[i-1][2];
            else if(j==n)
                f[i][j]=f[i-1][1]+f[i-1][n-1];
            else
                f[i][j]=f[i-1][j-1]+f[i-1][j+1];
    cout<<f[m][1]<<endl;
    return 0;
}
```
核心实现思想：先初始化`f[0][1] = 1`表示初始状态球在小蛮手中。通过两层循环，外层循环传球次数`i`，内层循环同学编号`j`，根据状态转移方程和边界条件更新`f[i][j]`的值，最后输出`f[m][1]`即传`m`次球后回到小蛮手中的方案数。
 - **作者：Idoyt（4星）**
    - **关键亮点**：从维度角度深入分析问题，解释状态和状态转移方程的推导过程，逻辑严谨，对理解DP本质有帮助。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int f[30][30];
int main()
{
    scanf("%d%d",&n,&m);
    f[1][0]=f[0][1]=1;
    for(int i=1;i<=m;i++)
    {
        f[1][i]=f[n][i-1]+f[2][i-1];
        for(int j=2;j<n;j++)
            f[j][i]=f[j-1][i-1]+f[j+1][i-1];
        f[n][i]=f[n-1][i-1]+f[1][i-1];
    }
    printf("%d",f[1][m]);
    return 0;
}
```
核心实现思想：初始化`f[1][0] = f[0][1] = 1`，通过两层循环，外层控制传球次数，内层控制同学编号，按照状态转移方程和边界条件更新`f`数组，最后输出`f[1][m]`。
 - **作者：Vct14（4星）**
    - **关键亮点**：除常规DP解法，还提到用滚动数组优化空间，降低空间复杂度，对空间优化有较好示范。
    - **重点代码（滚动数组优化部分）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[2][32];
int main()
{
    int n,m;cin>>n>>m;dp[0][1]=1;
    for(int i=1; i<=m; i++)
        for(int j=0; j<n; j++)
            dp[i%2][j]=dp[(i+1)%2][(j-1+n)%n]+dp[(i+1)%2][(j+1)%n];
    cout<<dp[m%2][1];
    return 0;
}
```
核心实现思想：利用滚动数组`dp[2][32]`，通过`i % 2`和`(i + 1) % 2`来表示当前层和上一层，每次只保存上一层状态，从而优化空间。按状态转移方程更新数组，最后输出`dp[m % 2][1]`。

### 最优关键思路或技巧
 - **动态规划思路**：通过定义合适的状态`dp[i][j]`，找到状态转移方程，利用问题的无后效性，逐步求解子问题，从而解决整个问题。
 - **滚动数组优化**：当状态转移只依赖上一层状态时，可利用滚动数组减少空间使用，降低空间复杂度。

### 可拓展之处
此类问题属于线性动态规划，类似的题目常涉及状态定义和状态转移方程的推导，通常可通过分析问题的前后状态关系来确定。例如在环形结构或线性结构上，根据元素间的相互影响关系确定状态转移。

### 推荐题目
 - **P1216 [USACO1.5]数字三角形 Number Triangles**：通过动态规划求解数字三角形从顶到底的最大路径和。
 - **P1434 [SHOI2002]滑雪**：在矩阵上进行动态规划，求最长滑雪路径长度。
 - **P1006 [NOIP2008 提高组] 传纸条**：类似传球游戏，在矩阵上通过动态规划求解从左上角到右下角传递纸条的最大得分。 

---
处理用时：39.57秒
# 题目信息

# [NOIP 2008 普及组] 立体图

## 题目描述

小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解立体图，请你帮他画出立体图。

小渊有一块面积为 $m \times n$ 的矩形区域，上面有 $m \times n$ 个边长为 $1$ 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$），小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放：

$$
\def\arraystretch{1e-10}
\begin{aligned}
&\verb!  +---+!\\
&\verb! /   /|!\\
&\verb!+---+ |!\quad\textsf{高}\\
&\verb!|   | +!\\
&\verb!|   |/ !\quad\textsf{宽}\\
&\verb!+---+  !\\
& \quad\textsf{长}
\end{aligned}$$


每个顶点用 $1$ 个加号 `+` 表示，长用 $3$ 个 `-` 表示，宽用 $1$ 个 `/`，高用两个 `|` 表示。字符 `+`，`-`，`/`，`|` 的 ASCII 码分别为 $43$，$45$，$47$，$124$。字符 `.`（ASCII 码 $46$）需要作为背景输出，即立体图里的空白部分需要用 `.` 来代替。立体图的画法如下面的规则：

若两块积木左右相邻，图示为：


$$
\def\arraystretch{1e-10}
\begin{aligned}
\verb!..+---+---+!\\
\verb!./   /   /|!\\
\verb!+---+---+ |!\\
\verb!|   |   | +!\\
\verb!|   |   |/.!\\
\verb!+---+---+..!\\
\end{aligned}
$$

若两块积木上下相邻，图示为：


$$
\def\arraystretch{1e-10}
\begin{aligned}
\verb!..+---+!\\
\verb!./   /|!\\
\verb!+---+ |!\\
\verb!|   | +!\\
\verb!|   |/|!\\
\verb!+---+ |!\\
\verb!|   | +!\\
\verb!|   |/.!\\
\verb!+---+..!\\
\end{aligned}
$$

若两块积木前后相邻，图示为：

$$
\def\arraystretch{1e-10}
\begin{aligned}
\verb!....+---+!\\
\verb!.../   /|!\\
\verb!..+---+ |!\\
\verb!./   /| +!\\
\verb!+---+ |/.!\\
\verb!|   | +..!\\
\verb!|   |/...!\\
\verb!+---+....!\\
\end{aligned}
$$

立体图中，定义位于第 $(m,1)$ 的格子（即第 $m$ 行第 $1$ 列的格子）上面自底向上的第一块积木（即最下面的一块积木）的左下角顶点为整张图最左下角的点。


## 说明/提示

NOIP2008普及组第四题


## 样例 #1

### 输入

```
3 4
2 2 1 2
2 2 1 1
3 2 1 2
```

### 输出

```
......+---+---+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均是通过模拟立方体的绘制来生成立体图。主要差异在于坐标计算、绘制顺序以及代码实现方式。
 - **思路方面**：多数题解采用从后往前、从左往右、从下往上的绘制顺序，利用这种顺序可自然解决立方体间的覆盖问题。
 - **算法要点**：需确定每个立方体在二维平面的绘制位置，部分题解通过打表存储单个立方体图形，部分则直接在代码中绘制单个立方体。
 - **解决难点**：难点在于准确计算每个立方体的坐标位置以及处理立方体之间的覆盖关系。部分题解通过不断调整坐标公式来适应不同情况，部分则通过合理的绘制顺序和数组覆盖实现。

### 所选的题解
#### 作者：ZUTTER_ (5星)
 - **关键亮点**：思路清晰，先将图形存于数组，通过从后往前、从下往上、从左往右的顺序依次覆盖，利用打表存储单个立方体图形，代码简洁明了，可读性高。
 - **重点代码**：
```cpp
// 打表存储单个立方体图形
char c1[10][10]={
"  +---+",
" /   /|",
"+---+ |",
"|   | +",
"|   |/",
"+---+",
};
void fg(int x,int y)
{
    int i,j;
    for(i=5;i>=0;i--)//立方体需要倒过来存入数组
        for(j=z[i];j<=s[i];j++)//分别是这一行的宽度
        {
            c[5-i+x][j+y]=c1[i][j];
            if(5-i+x>maxx) maxx=5-i+x;
            if(j+y>maxy) maxy=j+y;//分别记录最大长宽
        }
}
```
核心实现思想：通过 `fg` 函数将打表的单个立方体图形按特定顺序存入二维数组，同时记录最大长宽以确定最终图形范围。

#### 作者：Sino_E (4星)
 - **关键亮点**：采用平面直角坐标系思路，详细分析立方体坐标规律，给出明确的左下角坐标计算公式，代码结构清晰，注释详细。
 - **重点代码**：
```cpp
void mdraw(int x,int y){
    /*正面矩阵绘制*/
    mz[x][y+3]=mz[x][y]=mz[x+4][y]=mz[x+4][y+3]='+';
    for(int i=x+1;i<x+4;i++)
        mz[i][y]=mz[i][y+3]='-';
    for(int i=y+1;i<y+3;i++)
        mz[x][i]=mz[x+4][i]='|';
    for(int i=x+1;i<x+4;i++)
        for(int j=y+1;j<y+3;j++)
            mz[i][j]=' ';
    /*顶面矩阵绘制*/
    mz[x+1][y+4]=mz[x+5][y+4]='/';
    mz[x+2][y+5]=mz[x+6][y+5]='+';
    for(int i=x+2;i<=x+4;i++)
        mz[i][y+4]=' ';
    for(int i=x+3;i<=x+5;i++)
        mz[i][y+5]='-';
    /*侧面矩阵绘制*/
    mz[x+5][y+1]='/';
    mz[x+6][y+2]='+';
    mz[x+5][y+2]=mz[x+5][y+3]=' ';
    mz[x+6][y+3]=mz[x+6][y+4]='|';
}
```
核心实现思想：`mdraw` 函数根据坐标分别绘制立方体的正面、顶面和侧面矩阵，从而完成单个立方体的绘制。

#### 作者：HasNoName (4星)
 - **关键亮点**：从后往前建方块，利用前面方块可覆盖后面方块的特点，将作图起始位置放于数组中间，避免坐标计算复杂问题，代码简洁高效。
 - **重点代码**：
```cpp
char cube[10][10]={"..+---+",
				   "./   /|",
				   "+---+ |",
				   "|   | +",
				   "|   |/.",
				   "+---+.."};//单个方块
void print(int x,int y,int h)//每个二维中同样位置从下往上堆方块
{
	x-=5;
	for(int k=1;k<=h;k++)
	{
		for(int i=0;i<6;i++)
			for(int j=0;j<7;j++)
				if(cube[i][j]!='.')
					a[x+i][y+j]=cube[i][j];
		x-=3;//打印方块起始位置移动
	}
	u=min(u,x+3);//更新上界
}
```
核心实现思想：`print` 函数从下往上在指定位置堆叠方块，通过更新上下界确定图形范围。

### 最优关键思路或技巧
 - **绘制顺序**：采用从后往前、从左往右、从下往上的绘制顺序，可自然处理立方体间的覆盖关系，简化逻辑。
 - **坐标处理**：将作图起始位置放于数组中间，通过不断更新上下左右边界来确定最终图形范围，避免复杂的坐标计算。
 - **打表技巧**：使用打表存储单个立方体图形，减少重复代码，提高代码可读性与可维护性。

### 可拓展之处
此类题目属于图形模拟类，相似套路为分析图形规律，确定绘制顺序与坐标计算方式。类似题目如三维图形模拟，需考虑更多维度的坐标变换与图形覆盖关系。

### 推荐题目
 - [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：涉及线段覆盖问题，与本题处理图形覆盖有相似思维方式。
 - [P1990 覆盖墙壁](https://www.luogu.com.cn/problem/P1990)：通过分析不同放置方式的规律解决覆盖问题，锻炼逻辑思维。
 - [P2190 仪仗队](https://www.luogu.com.cn/problem/P2190)：虽非图形覆盖，但需分析坐标规律，与本题在找规律方面类似。

### 个人心得摘录与总结
 - **作者：cwxcplh**：在不断调试中发现坐标公式存在的问题，如 `.` 符号遮挡、方块悬空、图形上方留白等，通过逐步调整坐标公式和增加判断条件解决问题。总结出解决此类复杂模拟题需全面考虑各种情况，不断调试优化代码。 

---
处理用时：81.93秒
# 题目信息

# [NOIP 2006 提高组] 作业调度方案

## 题目描述

我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。

每个工件的每个工序称为一个操作，我们用记号 `j-k` 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 `2-4` 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。

例如，当 $n=3,m=2$ 时，`1-1,1-2,2-1,3-1,3-2,2-2` 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。

一方面，每个操作的安排都要满足以下的两个约束条件。

1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；

2. 同一时刻每一台机器至多只能加工一个工件。

另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。

由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 `1 1 2 3 3 2`。

还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。

例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：


工件号 |工序 1 | 工序 2
-|-|-
$1$  |  $1/3$  |  $2/2$
$2$  |  $1/2$  |  $2/5$
$3$  |  $2/2$  |  $1/4$

则对于安排顺序 `1 1 2 3 3 2`，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。

方案 1，用时 $10$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | `3-1` | `3-1` |  无   | `1-2` | `1-2` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

方案 2，用时 $12$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12  |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` |   无   |  无   | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | 无 | 无 |  无   | `1-2` | `1-2` | `3-1` | `3-1` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件 $(1.)(2.)$ 的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件 $(1.)(2.)$ 的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。

显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。


## 说明/提示

NOIP 2006 提高组 第三题


## 样例 #1

### 输入

```
2 3
1 1 2 3 3 2
1 2 
1 2 
2 1
3 2 
2 5 
2 4
```

### 输出

```
10```

# AI分析结果

• 综合分析与结论：这些题解思路基本一致，均为按照题目给定的工序安排顺序，结合工件工序先后约束和机器同一时刻只能加工一个工件的约束，通过模拟的方式来确定每个操作在机器上的加工时间，最终找出完成所有任务所需的总时间。算法要点在于合理使用数组来记录各种状态信息，如工件当前工序、机器使用情况、工件上一工序完成时间等。解决难点在于理解复杂的题目约束条件，并准确实现模拟过程。

所选的题解：
  - 作者：brealid (5星)
    - 关键亮点：思路清晰，代码简洁明了，详细注释辅助理解，还提供了福利数据及解释。
    - 重点代码核心实现思想：通过多个数组记录工件、机器等状态信息，按给定工序顺序遍历，在机器时间线上寻找合适空档插入操作，更新相关状态并记录总时间。
```cpp
// 核心代码片段
for (int i = 1; i <= m * n; i++) {
    int now = list[i];
    step[now]++;
    int id = a[now][step[now]].id, cost = a[now][step[now]].cost;
    int s = 0;
    for (int j = las_time[now] + 1; ; j++) {
        if (mac[id][j] == 0) {
            s++;
        } else {
            s = 0;
        }
        if (s == cost) {
            for (int k = j - cost + 1; k <= j; k++) {
                mac[id][k] = 1;
            }
            if (j > ans) ans = j;
            las_time[now] = j;
            break;
        }
    }
}
```
  - 作者：ShawnZhou (4星)
    - 关键亮点：对题意分析详细，博客分享习惯较好，代码可读性高，通过辅助数组清晰实现模拟过程。
    - 个人心得：强调理解题意重要性，建议画图研究样例，且使用长变量名增强可读性。
    - 重点代码核心实现思想：利用三个辅助数组记录工序数、工件最晚出现时间、机器工作状态，按工序顺序扫描时间线，寻找机器空闲时段插入操作，更新相关信息。
```cpp
// 核心代码片段
for (int i=1;i<=n*m;i++){
    int nowitem = worklist[i];
    cnt_now_work_step[nowitem]++;
    int nownumber = worknumber[nowitem][cnt_now_work_step[nowitem]];
    int costtime = worktime[nowitem][cnt_now_work_step[nowitem]];

    for (int time = lasttime[nowitem]+1;;time++)
        if (check_in_line(time,time+costtime-1,nownumber)){
            for (int marktime = time;marktime <= time+costtime-1;marktime++)
                timeline[nownumber][marktime] = true;
            lasttime[nowitem] = time + costtime - 1;
            break;
        }
}
```
  - 作者：翠竹叶飞 (4星)
    - 关键亮点：对题意提炼准确，代码简洁，变量命名直观，较好体现模拟过程。
    - 重点代码核心实现思想：用数组记录安排顺序、机器工序、时间等信息，按顺序处理工序，在机器时间线上找空档插入，更新工件最晚时间和总时间。
```cpp
// 核心代码片段
for (i=1; i<=m*n; i++) {
    cnt[a[i]]++;
    int tmp1=a[i],tmp2=cnt[tmp1];
    int tmpm=mord[tmp1][tmp2];
    for (j=last_[tmp1];;j++) {
        bool flag = 1;
        for (k=j+1; k<=j+t[tmp1][tmp2]; k++)
            if (rec[tmpm][k]) { 
                flag = 0;
                break;
            }
        if (flag) {
            for (k=j+1; k<=j+t[tmp1][tmp2]; k++)
                rec[tmpm][k] = 1;
            last_[tmp1] = max(last_[tmp1],j+t[tmp1][tmp2]);
            ans = max(ans,last_[tmp1]);
            break;
        }
    }
}
```

最优关键思路或技巧：使用数组记录各种状态信息，如用二维数组记录工件各工序的机器号和加工时间，用一维数组记录每个工件当前工序、上一工序完成时间，用二维布尔数组记录机器每个时间点的使用状态。在模拟过程中，按给定工序顺序，从工件上一工序完成时间后开始扫描机器时间线，寻找连续空闲时段插入当前工序，同时更新各种状态信息。

可拓展之处：此类题目属于复杂模拟类型，类似套路是仔细分析题目给定的各种约束条件，用合适的数据结构记录状态，按特定顺序模拟操作过程。例如在任务调度、资源分配等场景下的问题都可能用到类似方法。

推荐题目：
  - P1036 [NOIP2002 普及组] 选数
  - P1162 填涂颜色
  - P1469 [USACO2.1] 数字三角形 Number Triangles 

---
处理用时：36.25秒
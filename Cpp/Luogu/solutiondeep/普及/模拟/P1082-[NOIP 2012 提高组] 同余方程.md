# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果

• 综合分析与结论：该题要求求解同余方程 \(ax \equiv 1 \pmod {b}\) 的最小正整数解。多数题解使用扩展欧几里得算法（exgcd），将方程转化为 \(ax + by = 1\) 的形式求解，利用裴蜀定理证明有解条件为 \(a,b\) 互质，通过递归方式求解并处理得到最小正整数解。少数题解利用欧拉定理，通过求 \(\varphi(b)\) 结合快速幂计算 \(a^{\varphi(b)-1} \pmod b\) 得出答案。
- **思路**：exgcd 法通过不断递归替换系数求解 \(ax + by = \gcd(a,b)\) 的解；欧拉定理法根据 \(a^{\varphi(b)} \equiv 1 \pmod b\) 推出 \(x \equiv a^{\varphi(b)-1} \pmod b\)。
- **算法要点**：exgcd 法核心在于系数的递归替换和边界条件处理；欧拉定理法关键是求欧拉函数 \(\varphi(b)\) 和快速幂计算。
- **解决难点**：exgcd 法需理解递归过程和答案处理方式；欧拉定理法难点在于准确计算欧拉函数。

综合质量来看，以下题解质量较高：
  - **作者：学委 (赞：1481)  星级：5星**
    - **关键亮点**：思路清晰，从问题转化开始，详细证明了方程有解条件，对扩展欧几里得算法的原理、递归过程及答案处理都进行了细致讲解，并给出代码注释，同时介绍了逆元用途。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

long long x, y;//目前方程真正的解 

void exgcd(long long a, long long b)
{
	//当前目的：求解 ax + by = gcd(a, b) 这么一个方程
	
	if(b == 0) //a, b不断改变的过程中，b最终必然会成为0
	{
		//在 b = 0 时方程还要成立？ 使 x = 1, y = 0 ，必然成立 
		x = 1;
		y = 7; //建议返回0。不过y = 7能AC，证明了最后一个等式不受最后一个y影响
		return;
	} 
	
	exgcd(b, a % b);//把下一层系数传进去（先求下一个方程的解 ）
	
	//现在我们已经拿到了下一个方程的解x, y
	long long tx = x;//暂时存一下x，别丢了
	x = y;
	y = tx - a / b * y; 
}

int main()
{
	long long a, b;
	cin >> a >> b;
	exgcd(a, b);
    
	x = (x % b + b) % b;//我们求出来的x必然满足方程，但不一定是最小正整数解，所以要进行答案处理
	printf("%lld\n", x);
	return 0;
}
```
核心实现思想：通过递归调用 exgcd 函数，在递归边界 \(b = 0\) 时确定 \(x = 1, y = 0\)，回溯时根据下层解更新当前层的 \(x\) 和 \(y\)，最后对求出的 \(x\) 进行取模处理得到最小正整数解。
  - **作者：_Nova (赞：12)  星级：4星**
    - **关键亮点**：先介绍裴蜀定理及扩展欧几里得算法求 \(ax + by = \gcd(a,b)\) 解的原理，包括通解的推导，对算法原理阐述较为全面，代码简洁且有注释。
    - **个人心得**：无
    - **核心代码**：
```cpp 
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll s=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}
	return s*w;
} 
ll a,b;
ll x,y;
ll exgcd(ll a,ll b,ll &x,ll &y){
	if(b==0){
		x=1,y=0;
		return a;
	}
	int k=exgcd(b,a%b,x,y);
	int tmp=x;
	x=y;
	y=tmp-(a/b)*y;
	return k;
}
int main(){
	a=read(),b=read();
	ll d=exgcd(a,b,x,y);
	while(x<0) x+=b/d;
	printf("%lld\n",x/d);
	
	return 0;
}
```
核心实现思想：递归实现扩展欧几里得算法，在边界 \(b = 0\) 时确定 \(x = 1, y = 0\)，回溯时更新 \(x\) 和 \(y\)，最后处理 \(x\) 得到最小正整数解。
  - **作者：sjh0626 (赞：1)  星级：4星**
    - **关键亮点**：先介绍同余、逆元、扩展欧几里得定理等前置知识，思路分析清晰，逐步引导从题目到扩展欧几里得定理的应用，代码简洁明了。
    - **个人心得**：无
    - **核心代码**：
```cpp
int exgcd(int a,int b,int &x,int &y){
	if(!b){
		x=1,y=0; //即 ax+by=a 
		return a;
	}
	int res=exgcd(b,a%b,x,y); 
	int temp=x; 
	x=y;
	y=temp-a/b*y;
	return res; 
} 
int main(){
	cin>>a>>b;
	exgcd(a,b,x,y);
	cout<<(x+b)%b;
	return 0;
}
```
核心实现思想：递归实现扩展欧几里得算法，在 \(b = 0\) 时确定 \(x = 1, y = 0\)，通过递归返回更新 \(x\) 和 \(y\)，最后对 \(x\) 取模得到最小正整数解。

**最优关键思路或技巧**：使用扩展欧几里得算法解决此类同余方程问题，关键在于理解其递归过程和边界条件设定，以及对解的处理方式，将原同余方程转化为不定方程求解。利用欧拉定理的方法则需熟练掌握欧拉函数计算和快速幂算法。

**可拓展思路**：此类题目属于数论中同余方程求解问题，类似套路可用于求解一般线性同余方程 \(ax \equiv c \pmod {b}\)，同样可利用扩展欧几里得算法，先判断 \(c\) 是否为 \(\gcd(a,b)\) 的倍数以确定是否有解，再进行求解。

**相似知识点洛谷题目**：
  - P5656 二元一次不定方程，求解二元一次不定方程的整数解，考察扩展欧几里得算法。
  - P2613 有理数取余，可通过费马小定理求逆元，与本题部分思路相关。
  - P3811 模意义下的乘法逆元，要求一次求出多个逆元，可使用线性求逆元等方法，涉及数论逆元知识点。 

---
处理用时：56.68秒
# 题目信息

# 杂务

## 题目描述

John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。

当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。

John 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。

写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。


## 样例 #1

### 输入

```
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
```

### 输出

```
23
```

# AI分析结果

这道题主要围绕如何计算完成所有杂务的最短时间，杂务间存在先后依赖关系。众多题解主要采用拓扑排序、动态规划（记忆化搜索可视为广义拓扑排序实现方式）等方法。

1. **思路与算法要点**：
    - **拓扑排序**：构建有向无环图（DAG），通过记录每个杂务的前驱（入度），将入度为0的杂务先加入队列。从队列取出杂务，更新其后续杂务的完成时间，并减少后续杂务的入度，当入度为0时加入队列，重复此过程直到队列为空，最后统计所有杂务完成时间的最大值。
    - **动态规划**：利用杂务k的准备工作在杂务1至k - 1中的特性，在输入时从杂务的前驱中找出完成时间最大的，加上当前杂务所需时间得到当前杂务的完成时间，同时更新最终答案。
2. **解决难点**：确保在计算一个杂务的完成时间时，其所有前驱杂务的完成时间已确定，避免计算错误。拓扑排序通过按特定顺序处理节点解决此问题；动态规划利用输入顺序保证能获取前驱杂务的完成时间。
3. **题解评分**：
    - **Nishikino_Curtis**：5星。思路清晰简洁，代码短小精悍，直接利用输入顺序在输入时完成关键计算，优化程度高。
    - **Keith_2006**：4星。详细介绍拓扑排序概念、实现方法及相关证明，包括记忆化搜索和bfs式拓扑排序两种实现方式，思路非常清晰，但代码相对复杂，包含较多模板。
    - **Silicon**：4星。提出动态规划解法，思路明确，代码简洁，通过dp数组记录每个杂务最早完成时间，转移方程清晰。

### 所选题解
- **Nishikino_Curtis（5星）**
    - **关键亮点**：代码简洁高效，利用输入顺序直接在循环中完成杂务完成时间的计算与答案更新。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,l,t,ans[10005],maxans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&i);
        scanf("%d",&l);
        int tmp=0;
        while(scanf("%d",&t)&&t)
            tmp=max(ans[t],tmp);
        ans[i]=tmp+l;
        maxans=max(ans[i],maxans);
    } 
    printf("%d\n",maxans);
    return 0;
 } 
```
    - **核心思想**：每次读入一个杂务的信息，通过循环读取其前驱杂务，找到前驱杂务完成时间的最大值tmp，将其与当前杂务时间l相加得到当前杂务完成时间ans[i]，并更新全局最大完成时间maxans。

- **Keith_2006（4星）**
    - **关键亮点**：详细阐述拓扑排序的概念、实现方式及相关证明，提供记忆化搜索和bfs式拓扑排序两种代码实现，知识讲解全面。
    - **bfs式拓扑排序核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cctype>
#include <vector>
#include <queue>

#define ll long long

using namespace std;

inline int read() {
    int x=0,f=1;
    char ch=getchar();
    while (!isdigit(ch)) {if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();
    return x*f;
}

const int N=500005;

int ind[N],f[N],a[N];
vector <int> edge[N];
queue <int> q;

int main() {
    int n=read();
    for (int i=1;i<=n;i++) {
        int x=read();
        a[i]=read();
        while (int y=read()) {
            if (!y) break;
            edge[y].push_back(x);
            ind[x]++;
        }
    }
    for (int i=1;i<=n;i++) {
        if (ind[i]==0) {
            q.push(i);
            f[i]=a[i];
        }
    };
    while (!q.empty()) {
        int rhs=q.front();
        q.pop();
        for (int i=0;i<edge[rhs].size();i++) {
            int u=edge[rhs][i];
            ind[u]--;
            if (ind[u]==0) q.push(u);
            f[u]=max(f[u],f[rhs]+a[u]);
        }
    }
    int ans=0;
    for (int i=1;i<=n;i++) {
        ans=max(ans,f[i]);
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心思想**：先读入杂务信息构建图并记录入度，将入度为0的杂务加入队列。从队列取出杂务rhs，遍历其后续杂务u，减少u的入度，若u入度为0则加入队列，并更新u的完成时间f[u]为f[u]与f[rhs] + a[u]中的较大值，最后统计所有杂务完成时间的最大值ans。

- **Silicon（4星）**
    - **关键亮点**：提出简洁的动态规划解法，直接利用杂务间的依赖关系和输入顺序进行状态转移。
    - **核心代码**：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=10100;
int n,value,number,max,to,f[maxn],num;
int main()
{
    scanf("%d",&n);
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&num);
        scanf("%d",&value);
        max=0;
        scanf("%d",&to);
        while(to)
        {
            if(f[to]>max) max=f[to];
            scanf("%d",&to);
        }
        f[i]=max+value;
    }
    max=0;
    for(int i=1;i<=n;i++)
        if(f[i]>max)
            max=f[i];
    printf("%d\n",max);
    return 0;
}
```
    - **核心思想**：读入每个杂务信息，在循环读取其前驱杂务时找到前驱杂务完成时间的最大值max，将其与当前杂务时间value相加得到当前杂务完成时间f[i]，最后统计所有杂务完成时间的最大值max。

### 最优关键思路与技巧
- **利用输入顺序**：由于杂务k的准备工作只在杂务1至k - 1中，许多题解利用这一特性，在输入时直接处理杂务的完成时间计算，简化计算过程。
- **拓扑排序思想**：通过构建DAG，利用入度判断杂务的执行顺序，确保在计算一个杂务完成时间时其前驱杂务已完成，是解决此类有依赖关系任务调度问题的常用方法。

### 可拓展之处
同类型题常涉及有依赖关系的任务调度、事件先后顺序安排等场景。类似算法套路包括在DAG上进行动态规划，根据节点间的依赖关系进行状态转移。

### 相似知识点洛谷题目
- **P4017 最大食物链计数**：通过拓扑排序统计DAG中从起点到终点的路径数量，与本题类似之处在于都需处理DAG结构，运用拓扑排序思想。
- **P1983 车站分级**：根据列车停靠站点关系构建DAG，通过拓扑排序确定车站等级，同样涉及DAG的构建与拓扑排序应用。
- **P3387 【模板】缩点**：先对有向图进行强连通分量缩点得到DAG，再在DAG上进行拓扑排序与动态规划，综合了多种与本题相关的知识点。

### 个人心得摘录与总结
- **Keith_2006**：在学习拓扑排序时重新审视自己四年前的博客，发现并修改笔误和代码初始化小错误。总结拓扑排序实现方法及相关证明，强调对拓扑排序概念和实现细节的深入理解有助于正确解题。 

---
处理用时：62.35秒
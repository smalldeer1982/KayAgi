# 题目信息

# 奇怪的电梯

## 题目背景

感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。

## 样例 #1

### 输入

```
5 1 5
3 3 1 2 5
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何从A楼到B楼按最少次数按钮的问题，提出了多种解法，包括深度优先搜索（DFS）、广度优先搜索（BFS）以及多种最短路算法（如Dijkstra、SPFA、Floyd、Bellman - Ford），还有费用流、动态规划等思路。
- **思路方面**：多数题解将楼层抽象为图的节点，楼层间的移动关系抽象为边，从而转化为图论问题求解。
- **算法要点**：
    - **DFS**：从起点开始，递归搜索每一条可能路径，找到目标楼层时更新答案。需注意剪枝，否则易超时。
    - **BFS**：利用队列维护节点和步数，从起点开始，将合法的上下楼层入队，直到找到目标楼层，由于边权为1，能保证第一次找到的路径即为最短路径。
    - **最短路算法**：如Dijkstra适用于单源非负权最短路，SPFA理论上可处理带负权但本题边权为1，Floyd用于求全源最短路，Bellman - Ford可处理带负权且能判断负环。
- **解决难点**：主要难点在于如何避免无效搜索和选择合适算法优化时间复杂度。例如DFS剪枝策略的选择，不同最短路算法适用场景的判断等。

综合来看，BFS和Dijkstra算法相对简单高效，更适合本题。根据质量（思路清晰度、代码可读性、优化程度等）对题解评分，以下是评分较高的题解：

### 所选的题解
- **作者：_H17_ （5星）**
    - **关键亮点**：全面介绍了多种解法，包括Dijkstra、SPFA、DFS、Floyd、BFS、Bellman - Ford等，并给出了各算法的时间复杂度分析和详细代码实现，对每个算法的原理和模板应用清晰阐述。
    - **个人心得**：无
    - **Dijkstra核心代码**：
```cpp
void add(int u,int v,int d){
    w[++tot]=d,tar[tot]=v,nxt[tot]=head[u],head[u]=tot;
    return;
}
void dijkstra(int s){
    q.push({0,s});
    dis[s]=0;
    while(!q.empty()){
        Pair p=q.top();
        q.pop();
        if(dis[p.nd]!=p.st)
            continue;
        for(int i=head[p.nd];i;i=nxt[i]){
            if(dis[tar[i]]>dis[p.nd]+w[i]){
                dis[tar[i]]=dis[p.nd]+w[i];
                q.push({dis[tar[i]],tar[i]});
            }
        }
    }
    return;
}
```
核心思想：通过优先队列不断取出当前距离源点最近的节点，更新其邻接节点的距离。
    - **BFS核心代码**：
```cpp
int bfs(){
    q.push(node{a,0});
    u[a]=1;
    while(!q.empty()){
        int x=q.front().x,y=q.front().y;
        q.pop();
        if(x==b)
            return y;
        int xn=x+k[x],yn=y+1;
        if(xn<=n&&xn>0&&!u[xn])
            q.push(node{xn,yn}),u[xn]=1;
        xn-=2*k[x];
        if(xn<=n&&xn>0&&!u[xn])
            q.push(node{xn,yn}),u[xn]=1;
    }
    return -1;
}
```
核心思想：从起点开始，将合法的上下楼层状态入队，每次取出队首元素，判断是否为目标楼层，若是则返回步数，否则拓展新的合法楼层状态入队。

- **作者：yummy （4星）**
    - **关键亮点**：详细分析了DFS剪枝策略的复杂度，指出常见错误优化的问题，并给出正确剪枝思路及代码，对理解DFS在本题中的应用有很大帮助。
    - **个人心得**：制造测试点卡掉常见错误做法，强调学习正确做法而非特判过题。
    - **DFS核心代码**：
```cpp
void dfs(int s,int t)
{
    ans[s]=t;
    if(s+dis[s]<=n && t+1<ans[s+dis[s]])
        dfs(s+dis[s],t+1);
    if(s-dis[s]>0  && t+1<ans[s-dis[s]])
        dfs(s-dis[s],t+1);
}
```
核心思想：记录从起点到每个节点的最少按键数，每次进入DFS函数，若当前步数更优则更新并继续搜索，否则剪枝。

- **作者：cff_0102 （4星）**
    - **关键亮点**：用简洁清晰的代码实现BFS，详细描述了BFS的实现过程，包括状态的推进、重复状态的判断和处理，以及最终结果的输出，对初学者理解BFS解决本题很友好。
    - **个人心得**：无
    - **BFS核心代码**：
```cpp
int main(){
    ios::sync_with_stdio(false);
    int n,s,e;cin>>n>>s>>e;
    if(s==e){
        cout<<0;
        return 0;
    } 
    for(int i=1;i<=n;i++)cin>>a[i];
    queue<int>q;
    q.push(s);
    int t=0;vis[s]=1;
    while(++t){
        int x=q.size();
        if(x==0){
            cout<<-1;
            return 0;
        }
        for(int i=0;i<x;i++){
            int p=q.front();
            q.pop();
            if(p-a[p]>0){
                if(!vis[p-a[p]]){
                    if(p-a[p]==e){
                        cout<<t;
                        return 0;
                    } 
                    vis[p-a[p]]=1;
                    q.push(p-a[p]);
                }
            }
            if(p+a[p]<=n){
                if(!vis[p+a[p]]){
                    if(p+a[p]==e){
                        cout<<t;
                        return 0;
                    } 
                    vis[p+a[p]]=1;
                    q.push(p+a[p]);
                }
            }
        }
    }
    return 0;
}
```
核心思想：从起点入队，每次循环将队列中所有状态向前推一步，判断新状态是否合法、是否到达目标楼层或已访问过，进行相应处理。

### 最优关键思路或技巧
- **图论建模**：将楼层与楼层间的移动关系抽象为图的节点与边，把问题转化为图论中的最短路径问题，这是解决本题的关键思路。
- **BFS的应用**：由于边权均为1，BFS能保证第一次到达目标楼层的路径就是最短路径，且实现相对简单，代码可读性高。同时，利用标记数组避免重复访问节点，优化搜索效率。
- **DFS的剪枝优化**：记录从起点到每个节点的最少步数，在搜索过程中进行剪枝，避免无效搜索，降低时间复杂度。

### 可拓展之处
同类型题通常围绕图的遍历与最短路径求解，类似算法套路有：
- 对于无权图或边权相同的图，优先考虑BFS求最短路径。
- 对于带权图，根据边权情况选择合适的最短路算法，如非负权用Dijkstra，带负权且需判断负环用Bellman - Ford或SPFA（但SPFA不稳定）。
- 对于数据范围小的全源最短路问题，可使用Floyd算法。

### 相似知识点洛谷题目
- **P3371 【模板】单源最短路径（弱化版）**：经典的单源最短路径问题，可使用Dijkstra等算法解决，加深对最短路算法的理解。
- **P1330 封锁阳光大学**：通过图的遍历和简单剪枝策略解决问题，与本题DFS剪枝思路有相似之处。
- **P1141 01迷宫**：利用BFS求解迷宫中从每个点出发能到达的01区域大小，锻炼BFS在类似场景的应用。 

---
处理用时：67.53秒
# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕有向无环图（DAG）的处理，核心思路是通过拓扑排序来满足动态规划（DP）的无后效性要求，从而解决从任一城市出发到其他城市的最长路径问题。部分题解采用记忆化搜索替代拓扑排序 + DP 的方式，同样能解决问题。

### 所选的题解
- **作者：星星之火 (赞：103)  5星**
    - **关键亮点**：思路清晰，先阐述拓扑排序性质，再结合DP讲解，详细说明了为何在拓扑序中进行DP能满足无后效性，代码规范且注释详细。
    - **个人心得**：无
    ```cpp
    void topsort()
    {
        queue <int> q;
        for (int i=1;i<=n;i++)
            if (ru[i]==0) {
                q.push(i);
                ts[++tot]=i;
            }
        while (!q.empty())
        {
            int u=q.front();q.pop();
            for (int i=head[u];i;i=edge[i].next)
            {
                int v=edge[i].to;
                ru[v]--;
                if (ru[v]==0) {
                    q.push(v);ts[++tot]=v;
                }
            }
        }
    }
    int main()
    {
        scanf("%d%d",&n,&m);
        for (int i=1;i<=m;i++)
        {
            int u,v;
            scanf("%d%d",&u,&v);
            add(u,v);
            ru[v]++;
        }
        topsort();
        for (int i=1;i<=n;i++) dp[i]=1;
        for (int i=1;i<=n;i++)
        {
            int u=ts[i];
            for (int j=head[u];j;j=edge[j].next)
            {
                int v=edge[j].to;
                dp[v]=max(dp[v],dp[u]+1);
            }
        }
        for (int i=1;i<=n;i++)
            printf("%d\n",dp[i]);
        return 0;
    }
    ```
    - **核心实现思想**：`topsort`函数实现拓扑排序，将入度为0的点入队，更新拓扑序数组`ts`。主函数中，读入图后进行拓扑排序，初始化DP数组，再依据拓扑序更新DP值，得出每个城市为终点的最长路径。
- **作者：_ZZH (赞：66)  4星**
    - **关键亮点**：简洁明了，直接指出每个点的答案是其所有前驱节点答案加1，在拓扑排序过程中同时进行DP，代码简洁高效。
    - **个人心得**：无
    ```cpp
    int main()
    {
        scanf("%d%d",&n,&m);
        for(int i=1;i<=m;i++)
        {
            int x,y;
            scanf("%d%d",&x,&y);
            e[++total].to=y;
            e[total].next=lin[x];
            lin[x]=total;
            in[y]++;
        }
        for(int i=1;i<=n;i++)
            if(in[i]==0)
            {
                f[i]=1;
                q.push(i);
            }
        while(!q.empty())
        {
            int cnt=q.front();q.pop();
            for(int i=lin[cnt];i;i=e[i].next)
            {
                f[e[i].to]=max(f[e[i].to],f[cnt]+1);
                if(--in[e[i].to]==0)q.push(e[i].to);
            }
        }
        for(int i=1;i<=n;i++)printf("%d\n",f[i]);
    }
    ```
    - **核心实现思想**：读入图并统计入度，将入度为0的点初始化答案为1并入队。在拓扑排序循环中，更新当前点所连节点的答案，若节点入度为0则入队，最终输出每个点的答案。
- **作者：nao_nao (赞：7)  4星**
    - **关键亮点**：对拓扑排序与题目关系理解深刻，详细解释了拓扑排序在本题中的作用，即处理点的答案受前驱影响的情况，代码逻辑清晰，注释详细。
    - **个人心得**：无
    ```cpp
    void add(int u,int v)
    {
        go[++cnt] = v;
        nxt[cnt] = head[u];
        head[u] = cnt;
        du[v] ++;
    }
    int main()
    {
        n = read();m = read();
        for(int i = 1 ;i <= m;i ++)
        {
            int u = read(),v = read();
            add(u,v);
        }
        for(int i = 1;i <= n;i ++)
        {
            if(!du[i]) q.push(i);
        }
        while(!q.empty())
        {
            int u = q.front();
            q.pop();
            for(int e = head[u];e;e = nxt[e])
            {
                int v = go[e];
                du[v]--;
                f[v] = max(f[v], f[u]+1);
                if(!du[v])
                {
                    q.push(v);
                }
            }
        }
        for(int i = 1;i <= n;i ++)
        {
            printf("%d\n",f[i]+1);
        }
        return 0;
    }
    ```
    - **核心实现思想**：`add`函数用于链式前向星存图并统计入度。主函数读入图后，将入度为0的点入队，在拓扑排序循环中，更新当前点后驱节点的答案，若后驱节点入度为0则入队，最后输出答案。

### 最优关键思路或技巧
1. **拓扑排序结合DP**：利用拓扑排序将有向无环图的节点排成线性序列，保证在进行DP时，每个节点的前驱节点已处理完毕，满足无后效性。状态转移方程为 `dp[v]=max(dp[v],dp[u]+1)`，其中`(u, v)`是图中的边。
2. **记忆化搜索**：通过反向存图，从终点反向搜索，记忆每个点的最长路径结果，避免重复计算，同样能解决问题。

### 可拓展思路
此类题目属于DAG上的最长路径问题，拓展方向可考虑带权图的最长路径、有环图（需结合其他算法处理环）的最长路径，或在DAG上添加限制条件的路径问题。类似算法套路是遇到有向无环且满足无后效性的问题，优先考虑拓扑排序结合DP。

### 推荐题目
1. **P1983 车站分级**：通过拓扑排序确定车站等级，与本题类似，需根据给定的有向关系进行拓扑处理。
2. **P3387 【模板】缩点**：先对有向图缩点得到DAG，再在DAG上进行DP等操作，综合了图的处理和DAG上的算法应用。
3. **P4017 最大食物链计数**：利用拓扑排序解决食物链计数问题，同样是在DAG上进行统计，与本题思路类似。

### 个人心得摘录与总结
1. **作者：zyx10**：做本题前受 [P4017最大食物链计数](https://www.luogu.org/problem/P4017) 启发，采用记忆化搜索解决本题，强调了做题经验对解决类似问题的帮助。
2. **作者：Space_Gold_Trash**：做题时先按从城市1出发思路写代码，提交全WA后发现出度为0的城市不止一座，修正代码后AC，提醒注意题目条件的全面性，不能想当然。 

---
处理用时：64.03秒
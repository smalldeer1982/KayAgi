# 题目信息

# 刷题

## 题目描述

NOIP 临近了，小 A 却发现他已经不会写题了。好在现在离竞赛还有一段时间，小 A 决定从现在开始夜以继日地刷题。也就是说小 A 废寝忘食，一天二十四小时地刷题。

今天的日期（时间）是 yyyy 年 mm 月 dd 日 hh 时 MM 分，考试的时间是 yyyy2 年 mm2 月 dd2 日 hh2 时 MM2 分。这之间的所有时间小 A 都用来刷题了，那么考试之前他最多能刷多少题呢？注意哦，考虑闰年。

时间紧张小 A 只管数量不管质量。当然有的题目容易一些，有的题目难一些。根据小 A 的经验，他能一眼看出写出某一个题目需要的时间，以分钟记。

现在给出洛谷 Online Judge 的题目列表，请你挑出最多的题目使小A能在竞赛前写出来。

我们假设从远古到未来，历法的表示与现在一样。


## 样例 #1

### 输入

```
2
1
1
2007-06-23-11:59
2007-06-23-12:00```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先计算出小A刷题可用的总时间，再对题目所需时间进行排序，利用贪心算法，优先选择耗时短的题目，以求出最多能刷的题目数量。主要难点在于时间的计算，需考虑闰年、月份天数不同等情况。各题解在思路清晰度、代码可读性和优化程度上有所差异。

### 所选的题解
- **作者：kkksc03 (5星)**
    - **关键亮点**：思路清晰简洁，先点明整体解题框架为计算总时间、排序题目、贪心求解，再详细阐述时间计算方法，包括读入时间、判断闰年及不同年份时间差计算，易于理解。
    - **个人心得**：无
    - **重点代码核心思想**：通过特定函数判断闰年，根据开始和结束时间与年初的关系计算分钟数，进而得出总刷题时间。
    ```cpp
    function runnian(y){
    if(y mod 400==0)return 1;
    if(y mod 100==0)return 0;
    if(y mod 4==0)return 1;
    return 0;
    }
    ```
- **作者：傅思维666 (4星)**
    - **关键亮点**：详细介绍日期处理技巧，如简化读入方式，提出两种将时间段处理成分钟数的方法，并着重讲解第二种 “多退少补” 的模拟方法，对贪心部分也有提及，内容全面。
    - **个人心得**：WA了两个大数据点，原因是输出位置不当，在极大数据时进不去else导致输出为空，引以为戒。
    - **重点代码核心思想**：先读入数据并排序，通过函数判断闰年，利用 “多退少补” 思想逐次处理年月日，最后计算总时间并贪心求解。
    ```cpp
    bool check(int x)
    {
        if((x%4==0 && x%400!=0) || x%400==0)
            return 1;
        return 0;
    }
    for(int i=start[1];i<endd[1];i++)
    {
        if(check(i))
            time+=366;
        else
            time+=365;
    }
    if(check(start[1]))
        for(int i=1;i<start[2];i++)
            time-=m2[i];
    else
        for(int i=1;i<start[2];i++)
            time-=m1[i];
    if(check(endd[1]))
        for(int i=1;i<endd[2];i++)
            time+=m2[i];
    else
        for(int i=1;i<endd[2];i++)
            time+=m1[i];
    for(int i=1;i<start[3];i++)
        time--;
    for(int i=1;i<endd[3];i++)
        time++;
    time=time*24*60;
    time-=60*start[4]+start[5];
    time+=60*endd[4]+endd[5];
    for(int i=1;i<=n;i++)
    {
        if(time>=a[i])
        {
            time-=a[i];
            ans++;
        }
        else
            break;
    }
    ```
- **作者：wangzeyu (4星)**
    - **关键亮点**：提出以0000年01月01日00时00分00秒作为标准时间，通过自定义Calender类来处理日历相关问题，代码结构清晰，面向对象编程思想体现明显。
    - **个人心得**：无
    - **重点代码核心思想**：定义Calender类，包含判断闰年、获取每月天数、获取标准时间等成员函数。通过类对象获取开始和结束时间的标准时间（以秒为单位），相减并换算成分钟后贪心求解。
```cpp
class Calender {
    private :
        unsigned year,month,day,hour,minute,second;
    public :
        static const unsigned long long a_minute=60ull,a_hour=a_minute*60ull,a_day=a_hour*24ull;
        void CalenderWrite(unsigned ye=0u,unsigned mo=1u,unsigned da=1u,unsigned ho=0u,unsigned mi=0u,unsigned se=0u) {
            this->year=ye;
            this->month=mo;
            this->day=da;
            this->hour=ho;
            this->minute=mi;
            this->second=se;
            return; 
        }
        bool is_runnian(unsigned y=0) {
            if(y==0) y=this->year;
            if(y%400==0) {
                return true;
            }
            else {
                if(y%100==0) {
                    return false;
                }
                else if(y%4==0) {
                    return true;
                }
                else return false;
            }
        }
        unsigned getDaysInMonth(unsigned y,unsigned m=0) {
            if(m==0)
            if(this->month!=2u) {
                return daysNum[this->month];
            }
            else {
                if(this->is_runnian()) return 29u;
                else return 28u;
            }
            else {
                if(m!=2u) {
                    return daysNum[m];
                }
                else {
                    if(is_runnian(y)) {
                        return 29;
                    }
                    else {
                        return 28;
                    }
                }
            }
        }
        unsigned long long getStandardTime(void) {
            unsigned long long res=0ull;
            for(unsigned y=0;y<this->year;y++) {
                if(is_runnian(y)) {
                    res+=a_day*366ull;
                } 
                else {
                    res+=a_day*365ull;
                }
            }
            for(unsigned m=1;m<this->month;m++) {
                res+=getDaysInMonth(this->year,m)*a_day;
            }
            for(unsigned d=1;d<this->day;d++) {
                res+=a_day;
            }
            for(unsigned h=0;h<this->hour;h++) {
                res+=a_hour;
            }
            for(unsigned m=0;m<this->minute;m++) {
                res+=a_minute;
            }
            res+=this->second;
            return res;
        }
}; 
```

### 最优关键思路或技巧
- **时间计算**：以某一固定时间点（如0000年1月1日00:00）为基准，计算开始时间和结束时间与基准点的时间差，相减得到刷题总时间，此方法逻辑清晰，易于实现。
- **数据读入**：利用scanf按照固定格式直接读入日期和时间数据，避免复杂的字符串处理，简单高效。
- **贪心策略**：将题目按所需时间从小到大排序，优先选择耗时短的题目，确保在总时间内完成最多题目，该策略贪心性质明显且易于证明。

### 可拓展之处
此类题目属于时间处理与贪心结合的问题。类似套路包括处理不同时间格式、不同时间单位换算，以及在其他资源分配场景下，结合特定条件进行贪心选择。例如，在任务调度中，根据任务耗时和截止时间，选择能完成的最大任务数量。

### 相似知识点洛谷题目
- **P1094 [NOIP2007 普及组] 纪念品分组**：涉及贪心算法，根据给定的重量限制，对物品进行分组，使分组数量最少。
- **P1199 [NOIP2010 普及组] 三国游戏**：结合贪心和博弈思想，通过合理选择武将武力值，使玩家获得最大优势。
- **P1223 排队接水**：典型的贪心问题，根据每个人接水所需时间，安排排队顺序，使所有人等待时间总和最小。

### 个人心得摘录与总结
作者傅思维666提到在输出时因位置不当导致WA，在极大数据下进不去else语句致使输出为空。这提醒我们在编写代码时，要全面考虑边界情况和数据范围，注意输出逻辑的正确性，避免因细节问题导致错误。 

---
处理用时：62.48秒
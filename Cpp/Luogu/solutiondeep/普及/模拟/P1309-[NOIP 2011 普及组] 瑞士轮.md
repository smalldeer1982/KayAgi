# 题目信息

# [NOIP 2011 普及组] 瑞士轮

## 题目背景

在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。

本题中介绍的瑞士轮赛制，因最早使用于$1895$年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。


## 题目描述

$2 \times N$ 名编号为 $1\sim 2N$ 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。

每轮比赛的对阵安排与该轮比赛开始前的排名有关：第$1$ 名和第$2$ 名、第 $3$ 名和第 $4$名、……、第$2K - 1 $名和第$ 2K$名、……  、第$2N - 1 $名和第$2N$名，各进行一场比赛。每场比赛胜者得$1 $分，负者得 $0 $分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。

现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第$ Q$ 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。


## 说明/提示

【样例解释】

 ![](https://cdn.luogu.com.cn/upload/pic/98.png) 

【数据范围】

对于$30\% $的数据，$1 ≤ N ≤ 100$；

对于$50\% $的数据，$1 ≤ N ≤ 10,000 $；

对于$100\%$的数据，$1 ≤ N ≤ 100,000,1 ≤ R ≤ 50,1 ≤ Q ≤ 2N,0 ≤ s_1, s_2, …, s_{2N}≤10^8,1 ≤w_1, w_2 , …, w_{2N}≤ 10^8$。

noip2011普及组第3题。


## 样例 #1

### 输入

```
2 4 2 
7 6 6 7 
10 5 20 15 
```

### 输出

```
1
```

# AI分析结果

• 综合分析与结论：这些题解都围绕瑞士轮比赛的模拟展开，核心难点在于如何高效处理每轮比赛后的排序。多数题解指出直接使用 `sort` 会超时，因为每次只需更新相邻两人变化后的分数，快排全部修改会造成浪费。优化思路是利用比赛后胜者和败者数组分别有序的特点，采用归并排序来合并数组，降低时间复杂度。
• 所选的题解：
  - 作者：皎月半洒花 (5星)
    - 关键亮点：详细分析了 `sort` 浪费的原因，引入归并排序并深入讲解其原理，代码实现清晰，注释详细。
    - 个人心得：无
    - 核心代码片段（归并排序）：
```cpp
void merge(int l,int r){
    if(l==r)return 0;
    int mid=(l+r)/2;
    merge(l,mid);
    merge(mid+1,r);
    int i=l,j=mid+1,p=l;
    while(i<=mid&&j<=r){
        if(a[i]>a[j])temp[++p]=a[++i];
        else temp[++p]=a[++j];
    } 
    while(i<=mid)temp[++p]=a[++i];
    while(j<=r)temp[++p]=a[++j];
    for(int i=l;i<=r;i++)a[i]=temp[i];
} 
```
核心实现思想：通过递归将数组二分，然后合并两个有序子数组，最终使整个数组有序。
  - 作者：List (4星)
    - 关键亮点：简洁明了地阐述了利用胜者和败者数组有序的特性，直接进行合并操作，代码逻辑清晰。
    - 个人心得：无
    - 核心代码片段（合并函数）：
```cpp
void MergeSort()///把AB归并到a中
{
    int i=1,j=1,k=1;///分别用来在AB以及a中移动的指针
    while(i<=n && j<=n)
    {
        if(A[i].grade > B[j].grade || (A[i].grade == B[j].grade && A[i].num < B[j].num))
        {
            a[k].grade = A[i].grade;
            a[k++].num = A[i++].num;
        }
        else{
            a[k].grade = B[j].grade;
            a[k++].num = B[j++].num;
        }
    }
    while(i<=n)
    {
        a[k].grade = A[i].grade;
        a[k++].num = A[i++].num;
    }
    while(j<=n)
    {
         a[k].grade = B[j].grade;
        a[k++].num = B[j++].num;
    }
}
```
核心实现思想：使用三个指针，遍历胜者数组 `A` 和败者数组 `B`，按规则将元素合并到数组 `a` 中。
  - 作者：songyuchen (4星)
    - 关键亮点：代码简洁，通过重载小于运算符简化排序操作，归并排序部分代码简单易懂。
    - 个人心得：无
    - 核心代码片段（归并排序部分）：
```cpp
for (int i=1;i<=R;i++)
{
    for (int j=1;j<=2*n;j=j+2)
    {
        if (A[j].w>A[j+1].w)
        {
            K1[j/2+1]=A[j];//分别放入两个数组
            K2[j/2+1]=A[j+1];
            K1[j/2+1].point++;
        }
        else
        {
            K1[j/2+1]=A[j+1];
            K2[j/2+1]=A[j];
            K1[j/2+1].point++;
        }
    }
    int j1=1,j2=1;
    for (int j=1;j<=2*n;j++)//归并排序
        if ((j2>n)|| ((j1<=n)&&((K1[j1].point>K2[j2].point)||((K1[j1].point==K2[j2].point)&&(K1[j1].num<K2[j2].num))) )     )
        {
            A[j]=K1[j1];
            j1++;
        }
        else
        {
            A[j]=K2[j2];
            j2++;
        }
}
```
核心实现思想：每轮比赛后将胜者和败者分别存入 `K1` 和 `K2` 数组，然后通过双指针将 `K1` 和 `K2` 数组按规则合并回 `A` 数组。
• 最优关键思路或技巧：利用比赛后胜者和败者数组分别有序的特性，采用归并排序进行数组合并，避免每次对所有数据重新排序带来的时间浪费。
• 可拓展之处：此类题目属于模拟与排序结合的问题，类似套路可应用于其他有特定排序规则且数据更新有规律的模拟场景。例如，一些比赛排名更新、资源分配等场景，在每次操作后部分数据顺序不变，可利用这一特性优化排序过程。
• 相似知识点洛谷题目：
  - [P2827 [NOIP2016 提高组] 蚯蚓](https://www.luogu.com.cn/problem/P2827)
  - [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
  - [P3377 【模板】左偏树（可并堆）](https://www.luogu.com.cn/problem/P3377)
• 个人心得摘录与总结：
  - 作者：zsq9：尝试使用 `sort` 超时，后改用 `stable_sort` 归并排序，因 `cmp` 顺序写错导致错误，修改后 AC。总结出要注意排序函数的选择及比较函数的正确性。 

---
处理用时：45.60秒
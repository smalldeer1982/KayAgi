# 题目信息

# 蚂蚁

## 题目描述

有许多蚂蚁在一根无限长的木棍上，每一只蚂蚁都有一个初始位置和初始朝向（任意两只蚂蚁的初始位置不同）。蚂蚁们以每秒一个单位的速度向前移动，当两只蚂蚁相遇时，它们会掉头（掉头时间忽略不计）。现给出每只蚂蚁的初始位置和初始朝向，请你计算出它们在 $t$ 秒后的位置和朝向。


## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据，$1\le n\le 100$；
- 对于 $80\%$ 的数据，$1\le n\le 10^4$，$0\le t\le 1000$；
- 对于 $100\%$ 的数据，$n\le 10^5$，$0\le t\le 10^5$，$|a_i|\le 10^6$。


## 样例 #1

### 输入

```
4 1
1 1
5 1
3 -1 
10 1
```

### 输出

```
2 0
6 1
2 0
11 1
```

# AI分析结果

• 综合分析与结论：这些题解的核心思路均基于蚂蚁相遇掉头可等效为相互穿过这一关键特性，避免直接模拟蚂蚁相遇掉头的复杂过程，从而简化问题。算法要点在于记录蚂蚁初始位置、方向和序号，通过排序确定相对位置关系，计算t秒后位置并按初始序号输出。解决难点主要是处理蚂蚁相遇时方向的确定，通过判断相邻蚂蚁t秒后位置是否相等来确定是否正在转弯（方向为0）。

从质量上看，翼德天尊的题解思路清晰，代码注释详细，对原理阐述全面；lili_flyingcutter的题解简洁明了，逻辑连贯，但代码注释稍欠；jerry99的题解简洁高效，思路表述清晰，但代码注释较少。

• 所选的题解：
  - 翼德天尊（5星）
    - 关键亮点：思路讲解详细，通过形象比喻阐述等效原理，代码注释丰富，对每个步骤都有清晰说明。
    - 个人心得：无
    ```cpp
    int n,t,w[100001][2];
    struct node{
        int w,f,h,d;
    }ant[100001];
    int cmp(node x,node y){
        return x.w<y.w;
    }
    int cmp1(node x,node y){
        return x.h<y.h;
    }
    int main(){
        scanf("%d%d",&n,&t);
        for (int i=1;i<=n;i++){
            scanf("%d%d",&ant[i].w,&ant[i].f);
            ant[i].h=i;
        }
        sort(ant+1,ant+1+n,cmp);
        for (int i=1;i<=n;i++){
            ant[i].d=i;
            ant[i].w+=ant[i].f*t;
        }
        sort(ant+1,ant+1+n,cmp);
        for (int i=2;i<=n;i++){
            if (ant[i].w==ant[i-1].w){
                ant[i].f=0;ant[i-1].f=0;
            }
        }
        for (int i=1;i<=n;i++){
            w[i][0]=ant[i].w;
            w[i][1]=ant[i].f;
        }
        sort(ant+1,ant+1+n,cmp1);
        for (int i=1;i<=n;i++){
            printf("%d %d\n",w[ant[i].d][0],w[ant[i].d][1]);
        }
        return 0;
    }
    ```
    - 核心实现思想：先按初始位置排序记录永久排名，计算t秒后位置，再按t秒后位置排序判断是否转弯，填充结果数组，最后按输入序号排序输出结果。
  - lili_flyingcutter（4星）
    - 关键亮点：逻辑简洁，直接阐述等效原理及实现步骤，代码简洁明了。
    - 个人心得：无
    ```cpp
    int f[10001];
    struct ff{
        int a,id,k;
        char c;
    }a[10001],b[10001];
    bool cmp(ff x,ff y){
        return x.a<y.a;
    }
    bool cmp2(ff x,ff y){
        return x.id<y.id;
    }
    int main(){
        int n,t;
        scanf("%d%d\n",&n,&t);
        for(int i=0;i<n;i++)scanf("%d%d",&a[i].a,&a[i].c),b[i]=a[i],b[i].id=i;
        for(int i=0;i<n;i++)
            a[i].a+=t*a[i].c;
        sort(a,a+n,cmp);
        sort(b,b+n,cmp);
        for(int i=0;i<n;i++)a[i].id=b[i].id;
        for(int i=0;i<n-1;i++){
            if(a[i].a==a[i+1].a)
                a[i].k=1,a[i+1].k=1;
        }
        sort(a,a+n,cmp2);
        for(int i=0;i<n;i++)
            if(a[i].k)
                printf("%d 0\n",a[i].a);
            else printf("%d %d\n",a[i].a,a[i].c);
        return 0;
    }
    ```
    - 核心实现思想：读入数据并保存原方向，计算t秒后位置，两次按起始位置排序确定序号对应关系，判断是否相撞，最后按输入序号排序输出。
  - jerry99（4星）
    - 关键亮点：代码简洁高效，思路清晰，直接抓住核心要点实现。
    - 个人心得：无
    ```cpp
    #include <cstdio>
    #include <algorithm>
    using namespace std;
    const int Tmax=100005;
    struct node{
        int x,d,num;
    };
    node ant[Tmax];
    int n,m,position[Tmax];
    bool cmp1(const node &a,const node &b)
    {
        return a.x<b.x;
    }
    int main()
    {
        int i;
        scanf("%d %d",&n,&m);
        for(i=1;i<=n;i++)
        {
            scanf("%d %d",&ant[i].x,&ant[i].d);
            ant[i].num=i;
        }
        sort(ant+1,ant+1+n,cmp1);
        for(i=1;i<=n;i++){
            position[ant[i].num]=i;
            ant[i].x+=ant[i].d*m;
        }
        sort(ant+1,ant+1+n,cmp1);
        for(i=1;i<=n;i++)
            if(ant[i].x==ant[i+1].x) ant[i+1].d=ant[i].d=0;
        for(i=1;i<=n;i++)
            printf("%d %d\n",ant[position[i]].x,ant[position[i]].d);
        return 0;
    }
    ```
    - 核心实现思想：读入数据并编号，按初始位置排序记录位置对应关系，计算t秒后位置，再次按位置排序判断是否转弯，最后按初始序号对应位置输出。

• 最优关键思路或技巧：将蚂蚁相遇掉头等效为相互穿过，利用排序确定蚂蚁相对位置关系，避免复杂的模拟过程，同时通过记录蚂蚁序号保证按输入顺序输出结果。

• 可拓展之处：同类型题常出现在模拟与排序结合的场景，类似算法套路为找到复杂过程的等效简单过程，利用数据结构（如结构体）记录多维度信息，通过排序简化问题求解。

• 洛谷相似题目：
  - P1002 [NOIP2002 普及组] 过河卒
  - P1161 开灯
  - P1080 [NOIP2012 提高组] 国王游戏

• 个人心得摘录与总结：无

---
处理用时：50.26秒
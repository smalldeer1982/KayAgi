# 题目信息

# 精卫填海

## 题目描述

本题为改编题。

> 发鸠之山，其上多柘木。有鸟焉，其状如乌，文首，白喙，赤足，名曰精卫，其名自詨。是炎帝之少女，名曰女娃。女娃游于东海，溺而不返，故为精卫。常衔西山之木石，以堙于东海。——《山海经》

精卫终于快把东海填平了！只剩下了最后的一小片区域了。同时，西山上的木石也已经不多了。精卫能把东海填平吗？

事实上，东海未填平的区域还需要至少体积为 $v$ 的木石才可以填平，而西山上的木石还剩下 $n$ 块，每块的体积和把它衔到东海需要的体力分别为 $k$ 和 $m$。精卫已经填海填了这么长时间了，她也很累了，她还剩下的体力为 $c$。

## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，$0<n \le 50$；
- 对于 $50\%$ 的数据，$0<n \le 1000$；
- 对于 $100\%$ 的数据，$0<n \le 10^4$，所有读入的数均属于 $[0,10^4]$，最后答案不大于 $c$。


## 样例 #1

### 输入

```
100 2 10
50 5
50 5```

### 输出

```
0```

## 样例 #2

### 输入

```
10 2 1
50 5
10 2```

### 输出

```
Impossible```

# AI分析结果

• 综合分析与结论：这些题解均识别出本题为01背包的变形问题，核心思路是将体力视为背包容量，石头体积视为价值，通过01背包算法求解。算法要点在于构建正确的状态转移方程，难点是如何在01背包基础上，满足题目求能填平海时消耗最小体力（即剩余最大体力）的要求。各题解在状态定义、初始化、状态转移方程细节及代码实现上略有不同。

所选的题解：
 - 作者Jason_Lee (4星)
   - 关键亮点：思路清晰，详细阐述从识别题目为01背包问题到构建状态转移方程的过程，代码注释丰富，还考虑到数据范围使用快读优化。
   - 个人心得：“身为蒟蒻的我 看到这道题就笑了 这不就是个01背包吗 哈哈哈  又可以水题了。十分钟后。。。算了 先玩会吧 这题不简单”，体现出对题目难度预估不足，实际思考后发现暗藏玄机。
   - 重点代码核心实现思想：定义数组存储相关数据，通过快读输入。在主函数中先特判石子总体积是否小于所需填平体积，再进行01背包动态规划，最后遍历查找刚好能填平海时消耗的最小体力。
   ```cpp
   inline int read(){
       int x=0,f=1;char ch=getchar();
       while (ch<'0'||ch>'9') {if(ch=='-')f=-1; ch=getchar();}
       while (ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0'; ch=getchar();}
       return x*f;
   }

   int vn,n,c,sum;
   int v[MAXN],w[MAXN],f[MAXN];  

   signed main()
   {
       vn=read(),n=read(),c=read();
       for(int i=1;i<=n;i++){
           v[i]=read(),w[i]=read();
           sum+=v[i];
       }
       if(sum<vn){
           cout<<"Impossible"<<endl;
           return 0;
       }
       for(int i=1;i<=n;i++){
           for(int j=c;j>=w[i];j--){
               f[j]=max(f[j],f[j-w[i]]+v[i]);
           }
       }
       for(int i=0;i<=vn;i++){
           if(f[i]>=vn){
               cout<<c-i<<endl;
               return 0;
           }
       }
       cout<<"Impossible"<<endl;
       return 0;
   }
   ```
 - 作者llzzxx712 (4星)
   - 关键亮点：简洁明了地阐述思路，将体力与搬运石子体积的关系通过数组f清晰定义，代码简洁且逻辑连贯。
   - 重点代码核心实现思想：定义数组存储相关数据，输入后进行01背包动态规划更新数组f，最后根据f数组判断能否填平海，并找到刚好填平海时消耗的最小体力。
   ```cpp
   int v,n,c,tj[10002],tl[10002];
   int f[10002];  

   int main()
   {
       cin>>v>>n>>c;
       for(int i=1;i<=n;i++) cin>>tj[i]>>tl[i];
       for(int i=1;i<=n;i++)
           for(int j=c;j>=tl[i];j--)
               f[j]=max(f[j],f[j-tl[i]]+tj[i]);
       if(f[c]<v) cout<<"Impossible";
       else{
           int i=c;
           while(f[i]>=v) i--;
           cout<<c-(i+1);
       }
       return 0;
   }
   ```
 - 作者__gcd (4星)
   - 关键亮点：状态定义独特，从求填满最少用的体力角度出发，详细讲解状态转移方程的两种情况，代码简洁高效。
   - 重点代码核心实现思想：初始化数组dp为极大值，输入数据后通过双重循环进行状态转移，根据状态转移方程更新dp数组，最后判断能否填平海并输出结果。
   ```cpp
   const int N = 10010;
   const int INF = 0x7ffffff;
   int k[N], m[N], dp[N];

   int main()
   {
       int v, n, c;
       cin >> v >> n >> c;
       for(int i = 1; i <= n; i++)
           cin >> k[i] >> m[i];
       for(int i = 1; i <= v; i++)
           dp[i] = INF;
       for(int i = 1; i <= n; i++)
           for(int j = v; j >= 0; j--)
           {
               if(j >= k[i]) 
                   dp[j] = min(dp[j], dp[j-k[i]] + m[i]);
               else dp[j] = min(dp[j], m[i]);
           }
       if(c < dp[v])cout << "Impossible";
       else cout << c - dp[v];
       return 0;
   }
   ```

最优关键思路或技巧：
 - **状态定义与转移**：巧妙地将体力作为背包容量，石头体积作为价值来构建01背包模型。部分题解如__gcd通过定义“填满i的体积最少要多少体力”这种独特的状态，简化了问题求解。
 - **边界处理与特判**：部分题解在开始动态规划前，先特判石子总体积是否小于所需填平体积，提前判断无解情况，减少不必要计算。

可拓展之处：此类题目属于背包问题的变形，常见的还有完全背包（每个物品可无限次选取）、多重背包（每个物品有固定次数限制）等问题。解题时关键在于准确识别背包类型，合理定义状态与状态转移方程。

推荐题目：
 - [P2918 [USACO08NOV]买干草Buying Hay](https://www.luogu.org/problemnew/show/P2918) ：以开销的美元为物品的体积，以购买的干草的磅数为物品可创造的价值做完全背包，与本题思路类似。
 - [P1048 采药](https://www.luogu.org/problemnew/show/P1048) ：经典01背包问题，通过采药时间和价值构建01背包模型，可巩固基础。
 - [P1616 疯狂的采药](https://www.luogu.org/problemnew/show/P1616) ：完全背包问题，在经典01背包基础上，每个物品可无限次选取，可加深对背包问题变形的理解。 

---
处理用时：103.11秒
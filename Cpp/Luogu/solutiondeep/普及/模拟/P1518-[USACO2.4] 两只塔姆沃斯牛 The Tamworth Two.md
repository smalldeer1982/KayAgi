# 题目信息

# [USACO2.4] 两只塔姆沃斯牛 The Tamworth Two

## 题目描述

两只牛逃跑到了森林里。Farmer John 开始用他的专家技术追捕这两头牛。你的任务是模拟他们的行为（牛和 John）。

追击在 $10 \times 10$ 的平面网格内进行。一个格子可以是：一个障碍物，两头牛（它们总在一起），或者 Farmer John。两头牛和 Farmer John 可以在同一个格子内（当他们相遇时），但是他们都不能进入有障碍的格子。

一个格子可以是：
- `.` 空地；
- `*` 障碍物；
- `C` 两头牛；
- `F` Farmer John。

这里有一个地图的例子：

```plain
*...*.....
......*...
...*...*..
..........
...*.F....
*.....*...
...*......
..C......*
...*.*....
.*.*......
```

牛在地图里以固定的方式游荡。每分钟，它们可以向前移动或是转弯。如果前方无障碍（地图边沿也是障碍），它们会按照原来的方向前进一步。否则它们会用这一分钟顺时针转 90 度。 同时，它们不会离开地图。

Farmer John 深知牛的移动方法，他也这么移动。

每次（每分钟）Farmer John 和两头牛的移动是同时的。如果他们在移动的时候穿过对方，但是没有在同一格相遇，我们不认为他们相遇了。当他们在某分钟末在某格子相遇，那么追捕结束。

读入十行表示地图。每行都只包含 10 个字符，表示的含义和上面所说的相同。保证地图中只有一个 `F` 和一个 `C`。`F` 和 `C` 一开始不会处于同一个格子中。

计算 Farmer John 需要多少分钟来抓住他的牛，假设牛和 Farmer John 一开始的行动方向都是正北（即上）。 如果 John 和牛永远不会相遇，输出 0。

## 说明/提示

翻译来自NOCOW

USACO 2.4


## 样例 #1

### 输入

```
*...*.....
......*...
...*...*..
..........
...*.F....
*.....*...
...*......
..C......*
...*.*....
.*.*......```

### 输出

```
49```

# AI分析结果

这道题主要是模拟农夫和牛在地图中的移动，并判断两者是否能相遇。各题解思路基本都是模拟移动过程，难点在于判断农夫和牛是否会陷入死循环导致无法相遇。

1. **思路**：
    - **模拟移动**：多数题解通过循环模拟每一分钟农夫和牛的移动，根据当前方向和前方是否有障碍物决定是前进还是转弯。
    - **方向表示**：使用数组存储方向，如`dx[]`和`dy[]`，或者用数字代表不同方向（如0 - 北，1 - 东，2 - 南，3 - 西）。
    - **地图处理**：部分题解将地图边界设为障碍物，方便判断是否越界。
2. **算法要点**：
    - **记录位置和方向**：用变量或结构体记录农夫和牛的坐标及方向，每次移动后更新。
    - **移动函数**：根据当前方向和地图情况，实现移动和转弯逻辑。
3. **解决难点（判断是否相遇）**：
    - **状态压缩**：通过生成唯一值（如将坐标和方向组合成一个数），利用数组标记该值是否出现过，若重复出现则说明陷入死循环，输出0。
    - **固定步数判断**：设定一个较大步数（如100000），若超过该步数仍未相遇则输出0。
    - **多次经过判断**：用数组记录每个位置每个方向经过的次数，若某个位置某个方向经过次数过多（如5次），则说明陷入死循环，输出0。

### 题解评分
1. **翼德天尊**：思路清晰，详细阐述了初始化、移动、判断相遇的过程，代码注释详细。使用状态压缩判断死循环，代码实现完整。 5星
2. **早右昕**：通过`struct`维护状态，代码简洁，利用`vis[i][j][k][l]`判断无解情况，思路巧妙。 5星
3. **beacon_cwk**：清晰阐述了判断相遇的思路，即通过状态压缩生成特征值并用`bool`数组判重，代码简洁明了。 5星
4. **Thaumaturge**：直接模拟移动过程，通过设定循环次数上限判断无解，但代码稍显冗长，逻辑不够清晰。 3星
5. **Diamiko**：用Python实现模拟，思路简单易懂，但使用固定步数判断无解稍显粗糙，且未对代码进行优化。 3星
6. **Siemens_Thai**：代码逻辑简单直接，采用固定步数判断无解，有骗分嫌疑，代码可读性一般。 2星
7. **Celebrate**：使用DFS模拟，但代码逻辑较复杂，且在判断无解时使用了与其他题解类似的状态标记方法，整体不够简洁。 3星
8. **edjzy**：利用六维数组判断是否出现重复状态，思路正确，但代码中变量命名不够清晰，整体可读性一般。 3星
9. **AnicoderAndy**：暴力枚举移动过程，通过设定步数上限判断无解，代码实现较为常规，没有特别的优化和亮点。 3星
10. **Ricardo_Ni**：通过找环并枚举相遇点和方向来计算时间，思路复杂，代码实现难度较大，对于本题数据规模略显繁琐。 3星
11. **Manjusaka丶梦寒**：简单模拟，通过循环枚举移动情况，用固定步数判断无解，代码逻辑较清晰，但方法不够优化。 3星
12. **能神带你飞**：模拟过程简单直接，通过设定较大常数判断无解，代码简洁但方法不够严谨和优化。 3星
13. **「QQ红包」**：按照题意模拟，使用六维数组标记状态判断无解，代码逻辑较清晰，但整体稍显繁琐。 3星
14. **sxyzhml**：通过记录每个格子的经过次数判断无解，思路独特，但代码使用Pascal语言，对不熟悉该语言的读者不太友好。 3星
15. **xfydemx**：代码逻辑较混乱，可读性差，通过设定较大步数判断无解，方法常规且未进行优化。 2星
16. **转身、已陌路**：提出两种判断抓不到的方法，代码实现基本功能，但整体逻辑不够清晰，代码风格欠佳。 3星
17. **judgejudge**：朴素模拟，注意到了奶牛和农民方向改变的独立性，但代码中对方向改变的处理稍显繁琐，判断无解使用固定步数。 3星
18. **珅肐**：代码简洁，采用边界处理技巧和六维数组判重，逻辑清晰，但六维数组寻址较慢。 4星
19. **Victorique_De_Blois**：使用广搜模拟，思路独特，但对广搜边界条件的设定（如步数限制）稍显随意，代码未完整给出。 3星
20. **爱喝敌敌畏**：暴力模拟并判重，判重方法较为复杂且代码逻辑不够清晰，整体实现不够优化。 2星
21. **happybob**：通过`dfs`模拟，注意到了农夫和牛同时移动可能出现的问题，但代码量较大，逻辑较复杂，判断无解使用固定步数。 3星
22. **Drinkwater**：使用六维数组存状态去重，代码逻辑较清晰，但整体实现较为暴力，未进行优化。 3星
23. **1124828077ccj**：通过六维数组判断状态重复，代码简洁，但对移动和判断过程的实现较为常规，没有特别亮点。 3星
24. **桜Sakura**：按照模拟思路实现，通过加墙防止越界，使用固定步数判断无解，代码逻辑较清晰但方法常规。 3星
25. **用户已注销**：介绍了多种判重方法并给出状态压缩的代码实现，思路清晰，代码简洁。 4星
26. **YczSS**：通过记录每个状态是否出现过判断无解，思路正确，但使用Pascal语言，对部分读者不友好。 3星
27. **March**：使用结构体模拟移动，通过哈希判断环，代码逻辑较清晰，但整体实现较为常规。 3星
28. **wick**：通过模拟移动并根据同一地方经过次数判断无解，代码逻辑较清晰，但经过次数的设定缺乏依据。 3星
29. **SIGSEGV**：使用BFS并通过哈希判重，代码实现较清晰，但BFS的使用对于本题不是最简洁的方法。 3星

### 高星题解
1. **翼德天尊**：
    - **星级**：5星
    - **关键亮点**：思路清晰，步骤详细，从初始化、移动到判断相遇都有细致讲解。通过状态压缩生成专属值判断是否陷入死循环，代码注释丰富，可读性强。
    - **核心代码**：
```cpp
void move(int x,int y,int mi,int h){//x,y为x,y坐标，mi为方向，h为类型：农夫为0，奶牛为1
    if (mi==0){
        if (m[x-1][y]=='*') if (h==0) f[0]=1; else c[0]=1;
        else if (h==0) f[1]--; else c[1]--;
    }else if (mi==1){
        if (m[x][y+1]=='*') if (h==0) f[0]=2; else c[0]=2;
        else if (h==0) f[2]++; else c[2]++;
    }else if (mi==2){
        if (m[x+1][y]=='*') if (h==0) f[0]=3; else c[0]=3;
        else if (h==0) f[1]++; else c[1]++;
    }else{
        if (m[x][y-1]=='*') if (h==0) f[0]=0; else c[0]=0;
        else if (h==0) f[2]--; else c[2]--;
    }
}
// 主循环中判断相遇和死循环
while (pd()){//模拟每秒
    tdz=f[1]+f[2]*10+c[1]*100+c[2]*1000+f[0]*10000+c[0]*40000;
    if (zt[tdz]){//死循环了就输出0并结束程序
        cout<<0<<endl;
        return 0;
    }
    zt[tdz]=1;//标记
    move(f[1],f[2],f[0],0);
    move(c[1],c[2],c[0],1);//依次移动农夫和奶牛
    ans++;//记录秒数
}
```
    - **核心思想**：`move`函数根据当前方向`mi`和位置`(x, y)`判断是否遇到障碍物，若遇到则改变方向，否则按原方向移动。主循环中通过计算专属值`tdz`判断是否出现过相同状态（死循环），若未出现则移动农夫和牛并记录步数。

2. **早右昕**：
    - **星级**：5星
    - **关键亮点**：利用`struct`维护状态，代码简洁。通过`vis[i][j][k][l]`记录状态出现次数，若大于4则说明陷入死循环，思路巧妙。
    - **核心代码**：
```cpp
struct one { int x,y,face; };
char map[12][12];
int vis[11][11][11][11];
void operator++(one& a) {
    int nx=a.x+dx[a.face];
    int ny=a.y+dy[a.face];
    if(map[nx][ny]!='*') a.x=nx,a.y=ny;
    else a.face++,a.face%=4;
}
bool operator!=(const one&a,const one&b) {
    return a.x!=b.x||a.y!=b.y;
}
// 主循环
int main(){
    one jhon,cow;
    fill(map[0],map[0]+12,'*');
    fill(map[11],map[11]+12,'*');
    // 初始化地图和位置
    while(jhon!=cow) {
        if(vis[jhon.x][jhon.y][cow.x][cow.y]++==4) {
            printf("0");
            return 0;
        }
        ans++,++jhon,++cow;
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心思想**：定义`struct one`表示农夫或牛的状态，重载`++`运算符实现移动逻辑，若前方无障碍则移动，否则改变方向。主循环中通过`vis`数组记录状态出现次数，若同一状态出现5次（初始为0，加4次后等于4）则判定为死循环输出0，否则继续移动并记录步数。

3. **beacon_cwk**：
    - **星级**：5星
    - **关键亮点**：清晰阐述状态压缩思路，将农夫和牛的坐标、方向组合成特征值，利用`bool`数组判重，代码简洁明了。
    - **核心代码**：
```cpp
bool zt[160005];
char mp[11][11];
int cx,cy,cf,fx,fy,ff,xx[4]={-1,0,1,0},yy[4]={0,1,0,-1},nt,stp;
int main()
{
    // 读入地图和初始化位置
    while(1)
    {
        if(fx==cx&&fy==cy)
        {
            printf("%d",stp);
            return 0;
        }
        nt=fx+fy*10+cx*100+cy*1000+ff*10000+cf*40000;
        if(zt[nt])
        {
            printf("0");
            return 0;
        }
        zt[nt]=1;
        if(fx+xx[ff]<0||fx+xx[ff]>=10||fy+yy[ff]<0||fy+yy[ff]>=10||mp[fx+xx[ff]][fy+yy[ff]]=='*')
            ff=(ff+1)%4;
        else fx=fx+xx[ff],fy=fy+yy[ff];
        if(cx+xx[cf]<0||cx+xx[cf]>=10||cy+yy[cf]<0||cy+yy[cf]>=10||mp[cx+xx[cf]][cy+yy[cf]]=='*')
            cf=(cf+1)%4;
        else cx=cx+xx[cf],cy=cy+yy[cf];
        stp++;
    }
    return 0;
}
```
    - **核心思想**：在循环中，每次移动前计算特征值`nt`，若该特征值已在`zt`数组中标记为出现过，则判定为死循环输出0，否则标记该特征值并根据当前方向和地图情况移动农夫和牛，记录步数。

### 最优关键思路或技巧
1. **状态压缩**：将农夫和牛的位置和方向信息压缩成一个值，利用数组快速判断该状态是否重复出现，以此判断是否陷入死循环。这种方法空间占用小且判断效率高。
2. **边界处理**：将地图边界设为障碍物，简化了越界判断逻辑，使代码更简洁。
3. **结构体封装**：使用结构体维护农夫和牛的状态（坐标和方向），使代码结构更清晰，便于管理和操作。

### 拓展思路
此类题目属于模拟与状态判断结合的问题，类似的题目还可能涉及不同角色在不同规则下的移动，以及更复杂的状态判断条件。对于这类题目，可以考虑以下拓展思路：
1. **更复杂的地图结构**：如地图不再是规则的矩形，或者增加不同类型的障碍物和特殊区域。
2. **不同的移动规则**：例如角色移动速度不同，或者移动方向的改变规则更复杂。
3. **多角色问题**：增加更多的角色，每个角色有不同的移动策略和目标，判断它们之间的相遇情况或完成特定任务的条件。

### 相似知识点洛谷题目
1. **P1036 [NOIP2002 普及组] 选数**：涉及到组合数的计算和条件判断，与本题类似之处在于都需要根据一定的规则进行模拟和判断。
2. **P1162 填涂颜色**：需要根据给定的规则对图形进行填充和判断，与本题在模拟过程和条件判断上有相似点。
3. **P1443 马的遍历**：马在棋盘上按照特定规则移动并标记可达位置，和本题中角色按规则移动并判断状态有相似的思路。

### 个人心得摘录与总结
1. **happybob**：在使用`swap`互换位置模拟移动时，没有考虑到农夫或牛要走的位置就是对方的情况，导致WA了一个点。后来在每次走之前不光判断是不是障碍物，还要判断要走的位置是否是对方，若走的位置是对方，先让对方走。总结：在模拟过程中，要充分考虑各种特殊情况，尤其是涉及多个角色同时移动时，避免因忽略特殊情况导致错误。
2. **xfydemx**：在使用`scanf %c`输入地图字符时会挂，原因不明。总结：在选择输入方式时，要注意不同输入方式的适用场景和可能出现的问题，若遇到问题可以尝试更换输入方式。 

---
处理用时：118.80秒
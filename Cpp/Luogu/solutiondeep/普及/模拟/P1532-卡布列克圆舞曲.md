# 题目信息

# 卡布列克圆舞曲

## 题目描述

卡布列克是一位数学家，他在研究数字时发现：任意一个不是用完全相同数字组成的四位数，如果对它们的每位数字重新排序，组成一个较大的数和一个较小的数，然后用较大数减去较小数，差不够四位数时补零，类推下去，最后将变成一个固定的数：$6174$，这就是卡布列克常数，例如：

$4321-1234=3087$。

$8730-378=8352$。

$8532-2358=6174$。

$7641-1467=6174$。

如果 $K$ 位数也照此办理，它们不是变成一个数，而是在几个数字之间形成循环，称作卡布列克圆舞曲。例如对于五位数 $54321$：

$54321-12345=41976$。

$97641-14679=82962$。

$98622-22689=75933$。

$97533-33579=63954$。

$96543-34569=61974$。

$97641-14679=82962$。

我们把 $82962,75933,63954,61974$ 称作循环节，即卡布列克圆舞曲。

## 样例 #1

### 输入

```
4321
54321
```

### 输出

```
6174
82962 75933 63954 61974
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均为模拟卡布列克圆舞曲的生成过程，即将输入数字拆分、排序得到最大最小值并求差，不断重复此过程直至出现循环节。主要难点在于数字的拆分与重组、循环节的判断以及数据类型的选择。多数题解使用数组或`vector`存储生成的数字序列，通过遍历判断是否出现重复来确定循环节。在数据类型上，均强调需使用`long long`以避免溢出。

### 所选的题解
- **作者：x_faraway_x (5星)**
    - **关键亮点**：思路清晰，代码简洁，详细注释，直接模拟过程，明确指出需用`long long`且读入数可能是循环一部分。
    - **个人心得**：强调使用`long long`以及读入数在循环中的重要性。
    - **核心代码片段**：
```cpp
while(cin >> n) { 
    ind = 0;
    a[++ind] = n; 
    bool flag = true;
    while(flag) {
        LL b[20]={0}, n1 = 0, n2 = 0;
        int in = 0;
        while(n) { 
            b[++in] = n % 10;
            n /= 10;
        }
        sort(b+1, b+1+in); 
        for(int i = 1; i <= in; i++) n1 = n1*10+b[i]; 
        for(int i = in; i >= 1; i--) n2 = n2*10+b[i];  
        n = n2-n1;
        for(int i = 1; flag && i <= ind; i++) 
            if(a[i] == n) { 
                flag = false; 
                for(int j = i; j <= ind; j++) 
                    cout << a[j] << " ";
            }
        a[++ind] = n; 
    }
    puts("");
}
```
    - **核心思想**：通过`while(cin >> n)`处理多组输入，将读入数存入数组，循环中拆分数字、排序得到最大最小值并求差，再判断差是否已在数组中，若存在则输出循环节，否则继续循环。
- **作者：RiverHamster (4星)**
    - **关键亮点**：运用多种STL库，如`<vector>`存储数据，`<algorithm>`和`<functional>`排序，`<sstream>`进行数据转换，简化数字分离操作。
    - **个人心得**：指出使用`long long`及`vector`没有`find()`函数的问题。
    - **核心代码片段**：
```cpp
ll mxsort(ll n){   
    io.clear();     
    buffer.clear(); 
    io<<n;   
    io>>buffer; 
    sort(buffer.begin(),buffer.end(),greater<char>()); 
    io.clear();  
    io<<buffer;  
    io>>n;  
    return n; 
}

ll mnsort(ll n){
    io.clear();
    buffer.clear();
    io<<n;
    io>>n;
    sort(buffer.begin(),buffer.end(),less<char>()); 
    io.clear();
    io<<buffer;
    io>>n;
    return n;
}

void work(ll n){
    vector<ll>a;
    a.push_back(n); 
    int i=0;
    while(1){  
        a.push_back(mxsort(a[i])-mnsort(a[i])); 
        for(int t=0;t<=i;t++) if(a[i+1]==a[t]) {for(int k=t;k<=i;k++) cout<<a[k]<<' '; cout<<endl; return;} 
        i++;  
    }
}
```
    - **核心思想**：定义`mxsort`和`mnsort`函数分别获取最大最小值，`work`函数中使用`vector`存储数据，循环求差并判断是否出现重复，若重复则输出循环节。
- **作者：Warriors_Cat (4星)**
    - **关键亮点**：详细介绍`vector`容器的使用，代码结构清晰，各功能模块化，如数位分离、求极值差、寻找循环位置等功能分别封装在不同函数中。
    - **个人心得**：强调STL的强大，鼓励使用`vector`解决不定长数组问题。
    - **核心代码片段**：
```cpp
void work(long long n){
    len = 0;
    while(n!= 0){
        a[++len] = n % 10;
        n /= 10;
    }
    sort(a + 1, a + len + 1); 
    x = 0; y = 0;
    for(int i = 1; i <= len; ++i){
        x = x * 10 + a[i];
    }
    for(int i = len; i >= 1; --i){
        y = y * 10 + a[i];
    }
    t = y - x; 
    return; 
}

long long find(long long t){
    for(int i = 1; i <= (int)v.size() - 1; ++i){
        if(v[i] == t) return i; 
    }
    return 0; 
}
```
    - **核心思想**：`work`函数实现数位分离、排序及求极值差，`find`函数用于寻找循环位置，主函数中不断调用这些函数，将结果存入`vector`并判断循环节。

### 最优关键思路或技巧
- **数据结构选择**：使用`vector`作为动态数组存储生成的数字序列，无需预先确定长度，方便数据的添加与遍历。
- **模块化编程**：将数字拆分、排序、求差、判断循环等操作封装成函数，提高代码的可读性与维护性。
- **STL运用**：利用`<algorithm>`中的`sort`函数对数字进行排序，`<sstream>`实现数字与字符串的转换，简化代码实现。

### 同类型题或类似算法套路
此类题目属于模拟与循环检测类型，常见套路为按照给定规则进行模拟操作，并通过数组或其他数据结构记录中间结果，检测是否出现重复以确定循环节。类似题目通常涉及数字处理、字符串操作等，需注意数据范围及边界条件。

### 洛谷相似题目推荐
- **P1004 方格取数**：涉及数字处理与路径规划，需模拟取数过程并寻找最优路径。
- **P1013 进制位**：结合进制转换与数字操作，模拟不同进制下的运算过程。
- **P1046 陶陶摘苹果（升级版）**：模拟摘苹果的过程，通过对条件的判断与处理来完成任务，同样涉及数据的记录与分析。 

---
处理用时：49.04秒
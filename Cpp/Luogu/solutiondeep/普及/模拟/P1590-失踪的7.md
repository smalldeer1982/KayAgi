# 题目信息

# 失踪的7

## 题目描述

远古的 Pascal 人也使用阿拉伯数字来进行计数，但是他们又不喜欢使用 $7$ ，因为他们认为 $7$ 是一个不吉祥的数字，所以 Pascal 数字 $8$ 其实表示的是自然数中的 $7$，$18$ 表示的是自然数中的 $16$ 。请计算，在正整数 $n$ 范围以内包含有多少个 Pascal 数字。


## 说明/提示

对于所有数据，$1 \leq t \leq 10000$，$1 \leq n \leq 2^{32}-1$。

## 样例 #1

### 输入

```
2
10
20```

### 输出

```
9
18```

# AI分析结果

### 综合分析与结论
这些题解主要围绕计算正整数n范围内不含数字7的Pascal数字个数展开，思路可归为以下几类：
1. **贡献值法**：将数字按位拆分，定义每一位的贡献值，通过乘法原理计算对应区间内Pascal数数量，再求和。遇到数字7时进行特殊处理。
2. **数位dp**：通过记忆化搜索，逐位搜索满足条件的数，记录结果。
3. **进制转换法**：把Pascal数字近似看成九进制数，进行进制转换，但要处理含7数字及8、9导致的偏差。
4. **排列组合法**：按位数讨论，根据乘法原理计算不同位数Pascal数数量，最高位需特殊考虑。

各题解在思路清晰度、代码可读性、优化程度上有所差异，大部分题解都能针对数据范围避免暴力解法，采用较为高效的算法。

### 所选的题解
- **作者：dbxxx (赞：116)  星级：5星**
    - **关键亮点**：思路清晰，自创“贡献值”概念并详细阐述，对含7数字的特判说明透彻，代码简洁且注释丰富，可读性强。
    - **个人心得**：原解题叙述和代码存在可读性问题，重写题解以更清晰表述思路和实现。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
int T;
std :: string s;
int main() {
    std :: scanf("%d", &T);
    while (T--) { 
        std :: cin >> s;
        for (int i = 0; i < s.length(); ++i) {
            if (s[i] == '7') {
                s[i] = '6';
                for (int j = i + 1; j < s.length(); ++j)
                    s[j] = '9';
                break; 
            }
        }
        int ans = 0; 
        for (int i = s.length() - 1, atr = 1; i >= 0; --i, atr *= 9)
            ans += atr * (s[i] - '0') - (s[i] - '0' > 7? atr : 0);
        std :: printf("%d\n", ans); 
    }
    return 0;
}
```
    - **核心思想**：先对输入数字字符串进行特判，若有7则按规则修改。然后从低位到高位遍历字符串，根据贡献值公式计算每一位贡献值并累加得到结果。

- **作者：amstar (赞：55)  星级：4星**
    - **关键亮点**：采用数位dp方法，通过记忆化搜索减少重复计算，代码结构清晰，逻辑严谨。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<iostream>
using namespace std;
int a[1100],p;
int dp[1010];
int dfs(int pos,bool limit) {
    if (pos==-1) return 1;
    if (!limit && dp[pos]!=-1) return dp[pos];
    int u = limit?a[pos]:9;
    int ret = 0;
    for (int i=0; i<=u; ++i) {
        if (i==7) continue;
        ret += dfs(pos-1,limit && i==a[pos]);
    }
    if (!limit) dp[pos] = ret;
    return ret;
}
int work(int x) {
    p = 0;
    while (x) {
        a[p++] = x%10;
        x /= 10;
    }
    return dfs(p-1,true);
}
int main() {
    memset(dp,-1,sizeof(dp));
    int n;
    scanf("%d",&n);
    while (n--) {
        int a,b = 0;
        scanf("%d",&a);
        printf("%d\n",work(a)-1);
    }
    return 0;
}
```
    - **核心思想**：通过dfs函数进行数位搜索，pos表示当前处理数位，limit表示是否受原数限制。利用dp数组记忆化搜索结果，减少重复计算，最后通过work函数调用dfs得到结果。

- **作者：Ellen7ions (赞：15)  星级：4星**
    - **关键亮点**：利用排列组合思想，按位数逐步分析计算Pascal数数量，思路直观，代码实现简洁明了。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
int T,n,mi[110];
int getlen(int n){
    int cnt=0;
    while(n)	cnt++,n/=10;
    return cnt;
}
void init(){
    mi[0]=1;
    for(int i=1;i<=100;i++)
        mi[i]=mi[i-1]*9;
}
int main(){
    init();
    cin>>T;
    while(T){
        T--;
        int len,temp=0,ans=0;
        cin>>temp;
        len = getlen(temp);
        for(int i=1;i<len;i++)
            ans = ans + 8*mi[i-1];
        for(int j=1;j<=len;j++){
            int cur = temp%10;
            if(cur>=7)	cur-=1;
            if(j==len)	ans = ans + (cur-1)*mi[j-1];
            else ans = ans + (cur)*mi[j-1];
            temp/=10;
        }
        cout<<ans+1<<endl;
    }
    return 0;
} 
```
    - **核心思想**：先初始化9的幂次，通过getlen获取数字位数。然后分别计算小于最高位的各数位Pascal数数量，再对每一位按规则计算并累加，最后得到结果。

### 最优关键思路或技巧
贡献值法和数位dp是较为巧妙的方法。贡献值法通过定义每一位对结果的贡献，利用乘法原理和位值原理快速计算；数位dp则通过记忆化搜索避免重复计算，提高效率。在处理含7数字时，将含7数字转换为不含7且等效的数字这一技巧较为通用。

### 可拓展思路
此类题目属于数位统计类问题，常见拓展方向为改变限制条件，如限制多个数字不能出现，或改变进制等。类似算法套路是按位分析，利用乘法原理、排列组合等知识，结合记忆化搜索或动态规划优化。

### 相似知识点洛谷题目
1. **P2602 [ZJOI2010]数字计数**：统计给定区间内每个数字出现的次数。
2. **P1067 [NOIP2009 普及组] 多项式输出**：涉及数字的按位处理与格式化输出。
3. **P1618 三连击（升级版）**：通过对数字的拆分、组合与判断解决问题，考察数字处理能力。 

---
处理用时：47.75秒
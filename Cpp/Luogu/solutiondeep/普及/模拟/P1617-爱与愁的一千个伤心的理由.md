# 题目信息

# 爱与愁的一千个伤心的理由

## 题目背景

（本道题目隐藏了两首歌名，找找看哪~~~）

《爱与愁的故事第一弹·heartache》第二章。

经历了心痛后，爱与愁大神不行了。


## 题目描述

月落乌啼问爱与愁大神为什么，爱与愁大神写了一个数字 $n$（$n \le 9999$），说翻译成英语就知道为什么了。月落乌啼接过这个数字后，本想翻译成英语，但是班主任叫他去帮个忙。他想尽快知道答案，于是这个艰巨的任务就拜托你了。

标准美式英语，仅在末两位 $ \le 10$ 时加 `and` 且没有连字符。

## 说明/提示

输出行初不大写。按标准美式英语输出，即两个非零的数中间没零则不加 `and`，行末无句号。

## 样例 #1

### 输入

```
5208
```

### 输出

```
five thousand two hundred and eight
```

## 样例 #2

### 输入

```
5280```

### 输出

```
five thousand two hundred eighty```

## 样例 #3

### 输入

```
5000```

### 输出

```
five thousand```

## 样例 #4

### 输入

```
5028```

### 输出

```
five thousand and twenty eight
```

# AI分析结果

### 综合分析与结论
这些题解主要思路都是根据数字的位数进行分情况讨论，将数字逐位转换为英文表述。算法要点在于熟悉英文数字表达规则，如不同数位的单词、“and”的使用规则等。难点主要是“and”的正确使用、数字0的处理以及10 - 19特殊数字的表达。

各题解质量参差不齐，部分题解代码冗长、可读性差，部分题解虽思路清晰但代码实现有优化空间。整体没有特别突出达到5星的题解，部分题解在思路清晰度、代码可读性和优化程度上表现较好，可给到4星。

### 所选4星题解
1. **作者：TomTheCat（4星）**
    - **关键亮点**：思路清晰，先将0到99的英文单词存入数组，再按数字位数分情况处理，每种情况逻辑明确。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
string number[102]={"zero","one","two","three","four","five","six","seven","eight","nine",
"ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen",
"nineteen","twenty","twenty one","twenty two","twenty three","twenty four","twenty five",
"twenty six","twenty seven","twenty eight","twenty nine","thirty","thirty one","thirty two",
"thirty three","thirty four","thirty five","thirty six","thirty seven","thirty eight",
"thirty nine","forty","forty one","forty two","forty three","forty four","forty five",
"forty six","forty seven","forty eight","forty nine","fifty","fifty one","fifty two",
"fifty three","fifty four","fifty five","fifty six","fifty seven","fifty eight",
"fifty nine","sixty","sixty one","sixty two","sixty three","sixty four","sixty five",
"sixty six","sixty seven","sixty eight","sixty nine","seventy","seventy one","seventy two",
"seventy three","seventy four","seventy five","seventy six","seventy seven","seventy eight",
"seventy nine","eighty","eighty one","eighty two","eighty three","eighty four",
"eighty five","eighty six","eighty seven","eighty eight","eighty nine","ninety",
"ninety one","ninety two","ninety three","ninety four","ninety five","ninety six",
"ninety seven","ninety eight","ninety nine"};
int main() {
    string a;
    cin>>a;
    if(a.size()==1) cout<<number[a[0]-48];
    if(a.size()==2) cout<<number[(a[0]-48)*10+a[1]-48];
    if(a.size()==3) {
        cout<<number[a[0]-48]<<" hundred ";
        if(a[1]=='0'&&a[2]=='0') return 0;
        if(a[1]=='0') cout<<"and "<<number[a[2]-48];
        else cout<<number[(a[1]-48)*10+a[2]-48];
    }
    if(a.size()==4) {
        bool flg=true;
        cout<<number[a[0]-48]<<" thousand ";
        if(a[1]=='0'&&a[2]=='0'&&a[3]=='0') return 0;
        if(a[1]=='0') cout<<"and "<<number[(a[2]-48)*10+a[3]-48],flg=false;
        else {
            cout<<number[a[1]-48]<<" hundred ";
            if(a[2]=='0') cout<<(flg&&a[3]!='0'?"and ":"")<<number[a[3]-48];
            else cout<<number[(a[2]-48)*10+a[3]-48];
        }
    }
    return 0;
}
```
    - **核心思想**：通过数组存储英文单词，根据输入数字的位数，直接从数组中获取对应英文表述，按规则输出。

2. **作者：s_h_y（4星）**
    - **关键亮点**：代码简洁，利用数组存储英文单词，通过取余和除法运算获取每一位数字，按照规则拼接输出。
    - **个人心得**：无
    - **核心代码**：
```delphi
const
 num0:array[0..9]of string=('zero','one','two','three','four','five','six','seven','eight','nine');
 num1:array[0..9]of string=('ten','eleven','twelve','thirteen','fourteen','fifteen','sixteen','seventeen','eighteen','nineteen');
 num2:array[2..9]of string=('twenty','thirty','forty','fifty','sixty','seventy','eighty','ninety');
var
 n:longint;
 a:array[1..4]of longint;
begin
 read(n);
 if n=0 then begin write(num0[0]); halt end;
 a[1]:=n div 1000; n:=n mod 1000;
 a[2]:=n div 100 ; n:=n mod 100 ;
 a[3]:=n div 10  ; n:=n mod 10  ;
 a[4]:=n         ;
 if a[1]>0 then write(num0[a[1]],' thousand');
 if a[2]>0 then
 begin
  if a[1]>0 then write(' ');
  write(num0[a[2]],' hundred')
 end;
 if a[3]>0 then
 begin
  if (a[2]>0)or(a[1]>0) then write(' ');
  if (a[1]>0)and(a[2]=0) then write('and ');
  if (a[3]>1)or(a[3]=1)and(a[4]=0) then write(num2[a[3]])
 end;
 if a[4]>0 then
 begin
  if (a[3]<>1)and((a[3]>0)or(a[2]>0)or(a[1]>0)) then write(' ');
  if (a[3]=0)and((a[2]>0)or(a[1]>0)) then write('and ');
  if a[3]=1 then write(num1[a[4]])
            else write(num0[a[4]])
 end
end.
```
    - **核心思想**：将数字按位拆分，根据每一位数字结合对应数组输出英文单词，注意“and”和特殊数字的处理。

3. **作者：恋上朋友的车（4星）**
    - **关键亮点**：将不同位数数字的处理封装成函数，代码结构清晰，逻辑明确。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <map>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
string E[] = {"zero","one","two","three","four","five","six","seven","eight","nine"};
string N[] = {"zero","ten","twenty","thirty","forty","fifty","sixty","seventy","eighty","ninety"};
string G[] = {"ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen"};
string num;
int len;
void work1(){
    cout << E[num[0] - '0']<<endl;
    return;
}
void work2(){
    if (num[1] == '0'){
        cout << N[num[0] - '0'] <<endl;
    }
    else if (num[0] == '1'){
        cout << G[num[1] - '0'] <<endl;
    }
    else {
        cout << N[num[0] - '0'] << " " << E[num[1] - '0'] <<endl;
    }
    return;
}
void work3(){
    cout << E[num[0] - '0'] << " hundred";
    if (num[1] == num[2] && num[1] == '0')return;
        if (num[1] == '0'){
            cout << " and "<<E[num[2] - '0'] <<endl;
            return;
        }
    cout << " ";
    for (int i = 1;i < len;i ++)
    num[i - 1] = num[i];
    work2();
}
void work4(){
    cout << E[num[0] - '0'] << " thousand";
    if (num[1] == num[2] && num[2] == num[3] && num[1] == '0')return;
    if (num[1] == num[2]&&num[1] == '0'){
        cout <<" and ";
        len = 1;
        num[0] = num[3];
        work1();
        return; 
    }
    if (num[1] == '0'){
        cout <<" and ";
        len = 2;
        num[0] = num[2];
        num[1] = num[3];
        work2();
        return;
    }
    else
    for (int i = 1;i < len;i ++)
    num[i - 1] = num[i];
    cout << " ";
    work3();
    return;
}
int main()
{
    cin >> num;
    len = num.length();
    while (num[0] == '0'&&len > 1){
        for (int i = 1;i < len;i ++)
        num[i - 1] = num[i];
        len --;
    }
    switch (len){
        case 4:{
            work4();
            break;
        }
        case 3:{
            work3();
            break;
        }
        case 2:{
            work2();
            break;
        }
        case 1:{
            work1();
            break;
        }
    }
}
```
    - **核心思想**：针对不同位数的数字分别编写处理函数，在函数中根据数字规则输出英文表述，主函数根据输入数字位数调用相应函数。

### 最优关键思路或技巧
将数字按位数分情况讨论，利用数组存储英文单词，这样可以简化代码逻辑，提高可读性。同时，对于复杂的规则（如“and”的使用），通过条件判断来准确处理。

### 可拓展思路
同类型题可涉及不同进制数字转换为英文，或增加更多复杂规则，如大数字（超过万位）的英文表达。类似算法套路是对于有明确规则的转换问题，先梳理规则，再分情况实现。

### 洛谷相似题目
1. P1035 [NOIP2002 普及组] 级数求和
2. P1046 [NOIP2005 普及组] 陶陶摘苹果
3. P1055 [NOIP2008 普及组] ISBN 号码

### 个人心得摘录与总结
1. **作者：Sktain**
    - **心得**：提交多次才通过，难点在于“and”的使用、0的处理、最后两位数字的特殊表达以及读入数字的方式。
    - **总结**：该题解作者在解题过程中遇到多个易错点，提示在处理这类涉及多种规则的题目时，要全面考虑各种情况，不能遗漏特殊情况。 

---
处理用时：77.46秒
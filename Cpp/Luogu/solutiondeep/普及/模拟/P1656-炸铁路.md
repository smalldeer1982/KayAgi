# 题目信息

# 炸铁路

## 题目描述

A 国派出将军 uim，对 B 国进行战略性措施，以解救涂炭的生灵。

B 国有 $n$ 个城市，这些城市以铁路相连。任意两个城市都可以通过铁路直接或者间接到达。

uim 发现有些铁路被毁坏之后，某两个城市无法互相通过铁路到达。这样的铁路就被称为 key road。

uim 为了尽快使该国的物流系统瘫痪，希望炸毁铁路，以达到存在某两个城市无法互相通过铁路到达的效果。

然而，只有一发炮弹（A 国国会不给钱了）。所以，他能轰炸哪一条铁路呢？


## 样例 #1

### 输入

```
6 6
1 2
2 3
2 4
3 5
4 5
5 6```

### 输出

```
1 2
5 6```

# AI分析结果

### 综合分析与结论
本题要求找出无向图中的割边（桥），即删除该边后图不再连通的边。题解主要分为暴力枚举和Tarjan算法两类思路。
 - **暴力枚举**：枚举每一条边，删除该边后通过DFS、BFS、SPFA或并查集等方法判断图是否连通，若不连通则该边为割边。此方法思路简单，但时间复杂度较高，为O(m^2)，适用于数据范围小的情况。
 - **Tarjan算法**：通过深度优先搜索，利用dfn（时间戳）和low（能访问到的最小时间戳）数组来判断边是否为割边，时间复杂度为O(n + m)，效率更高，适用于数据范围较大的情况。

综合来看，暴力枚举类题解思路直接，但代码实现可能较繁琐，且时间复杂度高；Tarjan算法类题解思路清晰，效率高，但理解和实现难度相对较大。

### 所选的题解
 - **作者：kkksc03 (赞：598)  星级：4星**
    - **关键亮点**：思路清晰简洁，指出本题即求图中的桥（割边），提出因本题范围小，可枚举边，删除边后用FloodFill（DFS或BFS）判断连通性，易于理解。
    - **重点代码核心思想**：枚举每条边，将其从图中删除，然后从某个点开始进行DFS或BFS遍历，若无法遍历到所有点，则该边为割边。
```cpp
// 伪代码示意
for (每条边e) {
    删除边e;
    if (!DFS(起点)) {
        该边e为割边，记录;
    }
    恢复边e;
}
```
 - **作者：abruce (赞：197)  星级：4星**
    - **关键亮点**：对Tarjan算法讲解详细，结合代码和图示，从数组含义、算法过程到割边证明，逐步阐述，便于读者理解Tarjan算法原理。
    - **重点代码核心思想**：通过tarjan函数进行深度优先搜索，在搜索过程中更新dfn和low数组，当low[y] > dfn[x]时，说明边(x, y)为割边。
```cpp
void tarjan(int x) {
    int c = 0, y;
    dfn[x] = low[x] = ++id;
    for (register int i = 1; i <= n; i++) {
        if (!maps[x][i]) continue;
        y = i;
        if (dfn[y] && y!= f[x]) low[x] = min(low[x], dfn[y]);
        if (!dfn[y]) {
            f[y] = x;
            tarjan(y);
            low[x] = min(low[x], low[y]);
            if (low[y] > dfn[x]) addEdge(x, y);
        }
    }
}
```
 - **作者：hsfzLZH1 (赞：65)  星级：4星**
    - **关键亮点**：对Tarjan算法求割边的原理阐述清晰，通过定义时间戳dfn和low数组，说明判断割边的条件。还指出代码在有重边时的问题及处理方法。
    - **重点代码核心思想**：在dfs函数中，通过深度优先搜索更新dfn和low数组，当dfn[cur] < low[child]时，说明边(cur, child)为割边。
```cpp
void dfs(int cur, int fa) {
    int child;
    dfn[cur] = ++index_;
    low[cur] = dfn[cur];
    for (int i = 0; i < G[cur].size(); i++) {
        child = G[cur][i];
        if (dfn[child] && child!= fa) low[cur] = min(low[cur], dfn[child]);
        if (!dfn[child]) {
            dfs(child, cur);
            if (dfn[cur] < low[child]) add_edge(cur, child);
            low[cur] = min(low[cur], low[child]);
        }
    }
}
```

### 最优关键思路或技巧
Tarjan算法是解决此类问题的高效方法，其核心技巧在于利用深度优先搜索过程中记录的时间戳dfn和能访问到的最小时间戳low来判断割边。这种方法避免了暴力枚举边后的重复搜索，大大提高了效率。在代码实现上，合理使用数组和条件判断来准确更新dfn和low值是关键。

### 可拓展之处
此类题目属于图论中割边（桥）问题，相似算法套路还可用于求割点、强连通分量等。同类型题通常围绕图的连通性展开，比如给定一个网络，要求找出关键节点或线路，使删除它们后网络不再连通。

### 推荐题目
 - [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)：通过Tarjan算法求有向图的强连通分量，并进行缩点操作。
 - [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)：利用Tarjan算法求无向图中的割点。
 - [P2860 [USACO06JAN]冗余路径Redundant Paths](https://www.luogu.org/problemnew/show/P2860)：同样是关于无向图连通性问题，通过添加边使图中不存在桥，与本题思路相关。

### 个人心得摘录与总结
 - **作者：HRLYB**：在实现无向图的Tarjan算法时，遇到双向建边导致普通Tarjan陷入死循环的问题，通过双向边标记（利用^1操作）解决，强调了细节在算法实现中的重要性。
 - **作者：浅色调**：开始误将题目理解为统计入度为0的点，提交后发现错误，改用类似Kruskal算法解决，提醒做题时要仔细读题，明确题意。 

---
处理用时：46.32秒
# 题目信息

# 突击考试

## 题目描述

一日，老师决定进行一次突击考试。已知每个学生都有一个考试能力等级，教室里一共有 $N$ 个课桌，按照顺序排成一列，每张课桌可以坐两个人，第 $i$ 张课桌坐的两个人的能力等级为$A_i,B_i$。现在老师决定对能力等级为 $K$ 的人进行测验。他会从这 $N$ 排中选择连续的 $L$ 排进行测验，要求这 $L$ 排中的每一排至少有一个人考试能力等级为 $K$。现在我们想知道 $L$ 的最大值以及对应的等级 $K$。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 100,000$，$1 \le A[i],B[i] \le 5$。

## 样例 #1

### 输入

```
3
3 5
4 5
1 3
```

### 输出

```
2 5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效找出满足条件的最大连续排数 \( L \) 及其对应的最小等级 \( K \)。由于题目限定能力等级范围为 \( 1 \) 到 \( 5 \)，多数题解采用对每个等级进行模拟的方式。
1. **思路与算法要点**：
    - **直接模拟**：多数题解从等级 \( 1 \) 到 \( 5 \) 遍历，对每排课桌检查是否有该等级的学生，统计连续排数并更新最大值。如lgxt、Rachel_Gardner等题解。
    - **递推**：_ZZH题解利用递推关系，记录从第一排到当前排每个等级的连续次数，实时更新答案。
    - **二分答案**：Bruteforces和xuan__xuan题解利用二分法求 \( L \) 的最大值，结合前缀和或队列优化时间复杂度。
2. **解决难点**：
    - **高效统计连续排数**：避免暴力枚举所有可能的连续区间，通过边读入边统计（如lgxt、听取MLE声一片等题解），或利用递推关系（_ZZH题解），以及二分答案结合前缀和/队列（Bruteforces、xuan__xuan题解）来优化。
    - **满足 \( L \) 最大时 \( K \) 最小**：多数题解通过从等级 \( 1 \) 到 \( 5 \) 顺序遍历，自然满足该条件。

综合来看，lgxt和_ZZH题解思路清晰、代码简洁，在解决问题的同时兼顾了代码的可读性和优化程度，可评为4星；Bruteforces题解采用二分答案结合前缀和的方法，虽然代码语言是Pascal，但思路独特，优化较好，也可评为4星。

### 所选的题解
- **lgxt题解**：
    - **星级**：4星
    - **关键亮点**：思路清晰直接，利用简单数组模拟，代码简洁易懂。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
using namespace std;
int s[100001][2],t[6];
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>s[i][0]>>s[i][1];
    }
    for(int i=1;i<=5;i++)
    {
        int ans=0,x=0;
        for(int o=0;o<n;o++)
        {
            if(s[o][0]==i||s[o][1]==i)
            {
                x++;
            }
            if(s[o][0]!=i&&s[o][1]!=i||o==n-1)
            {
                ans=max(ans,x);
                x=0;
            }
        }
        t[i]=ans;
    }
    int max=0,maxs=0;
    for(int i=1;i<=5;i++)
    {
        if(t[i]>max)
        {
            maxs=i;
            max=t[i];
        }
    }
    cout<<max<<" "<<maxs;
    return 0;
}
```
    - **核心思想**：外层循环遍历等级 \( i \)，内层循环遍历每排课桌，若该排有等级为 \( i \) 的学生则 \( x \) 加 \( 1 \)，否则更新该等级最大连续排数 \( ans \) 并重置 \( x \)。最后找出最大排数及其对应的等级。
- **_ZZH题解**：
    - **星级**：4星
    - **关键亮点**：利用递推关系记录每个等级的连续次数，实时更新答案，代码简洁高效。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,f[100010][6],maxx,max_k;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        f[i][x]=f[i-1][x]+1;
        f[i][y]=f[i-1][y]+1;
        int now,now_k;
        if(f[i][x]>f[i][y])
        {
            now=f[i][x];
            now_k=x; 
        }
        if(f[i][x]<f[i][y])
        {
            now=f[i][y];
            now_k=y;
        }
        if(f[i][x]==f[i][y])
        {
            now=f[i][x];
            now_k=min(x,y);
        }
        if(now>maxx)
        {
            maxx=now;
            max_k=now_k;
            continue;
        }
        if(now==maxx)
        {
            max_k=min(max_k,now_k);
            continue;
        }
    }
    printf("%d %d",maxx,max_k);
} 
```
    - **核心思想**：通过递推式 \( f[i][x]=f[i - 1][x]+1 \) 和 \( f[i][y]=f[i - 1][y]+1 \) 记录每个等级到当前排的连续次数，每次比较 \( f[i][x] \) 和 \( f[i][y] \) 取较优值更新答案。
- **Bruteforces题解**：
    - **星级**：4星
    - **关键亮点**：采用二分答案结合前缀和优化时间复杂度，能有效处理较大数据规模。
    - **个人心得**：无
    - **核心代码**：
```cpp
var
  a:array[1..100000,1..2]of integer;
  c:array[0..100000,1..5]of longint;
  n,i,j,k,x,y,z,left,right,mid,ans:longint;
function check(mid:longint):longint;
var
  i,j,x,y:longint;
begin
  check:=0;
  for j:=1 to 5 do
    for i:=mid to n do
    if c[i,j]-c[i-mid,j]=mid then
      exit(j);
end;
begin
  readln(n);
  for i:=1 to 5 do c[0,i]:=0;
  for i:=1 to n do
    begin
      readln(a[i,1],a[i,2]);
      for j:=1 to 5 do
      {
        c[i,j]:=c[i-1,j];
        if(a[i,1]=j)or(a[i,2]=j)then inc(c[i,j]);
      }
    end;
  left:=1;right:=n;
  while left<=right do
  {
    mid:=(left+right)div 2;
    if check(mid)=0 then right:=mid-1 else
    begin
      ans:=mid;left:=mid+1;
      k:=check(mid);
    end;
  end;
  writeln(ans,' ',k);
end.
```
    - **核心思想**：利用前缀和数组 \( c \) 记录前 \( i \) 张课桌中等级为 \( j \) 的人数，二分答案 \( mid \)，通过 \( c[i,j]-c[i - mid,j]=mid \) 判断是否存在长度为 \( mid \) 的连续区间满足条件，进而求出最大的 \( L \) 和对应的 \( K \)。

### 最优关键思路或技巧
1. **利用等级范围有限进行模拟**：由于能力等级范围为 \( 1 \) 到 \( 5 \)，对每个等级分别模拟统计连续排数，可简化问题求解。
2. **递推优化**：通过记录前序状态，利用递推关系实时更新当前状态，减少重复计算，如_ZZH题解的递推式记录每个等级连续次数。
3. **二分答案结合前缀和/队列**：当数据规模较大时，利用二分答案缩小搜索范围，结合前缀和或队列优化时间复杂度，高效求解问题。

### 可拓展之处
此类题目属于区间统计问题，相似套路为利用数据范围特点简化模拟过程，或通过递推、二分等方法优化时间复杂度。类似题目如给定一段序列，在满足一定条件下求最长连续子序列等。

### 洛谷相似题目
1. **P1990 覆盖墙壁**：涉及递推思想，与本题_ZZH题解利用递推关系更新状态类似。
2. **P2678 [NOIP2015 普及组] 跳石头**：可采用二分答案的方法，与本题Bruteforces和xuan__xuan题解思路相似。
3. **P1182 数列分段 Section II**：同样可通过二分答案求解，锻炼二分答案的应用能力。

### 个人心得摘录与总结
1. **听取MLE声一片**：强调时间复杂度的重要性，通过对比70分暴力算法和AC算法，指出优化时间复杂度的关键在于边跑边记录，避免重复搜索。总结了在做题时要注重时间复杂度优化，不能仅满足于暴力解法。 

---
处理用时：67.39秒
# 题目信息

# 好奇怪的游戏

## 题目背景

《爱与愁的故事第三弹·shopping》娱乐章。

调调口味来道水题。


## 题目描述

爱与愁大神坐在公交车上无聊，于是玩起了手机。一款奇怪的游戏进入了爱与愁大神的眼帘：\*\*\*（游戏名被打上了马赛克）。这个游戏类似象棋，但是只有黑白马各一匹，在点 $x_1,y_1$ 和 $x_2,y_2$ 上。它们得从点 $x_1,y_1$ 和 $x_2,y_2$ 走到 $(1,1)$。这个游戏与普通象棋不同的地方是：马可以走“日”，也可以像象走“田”。现在爱与愁大神想知道两匹马到 $(1,1)$ 的最少步数，你能帮他解决这个问题么？

注意不能走到 $x$ 或 $y$ 坐标 $\le 0$ 的位置。

## 说明/提示

### 数据范围及约定

对于 $100\%$ 数据，$1\le x_1,y_1,x_2,y_2 \le 20$。

## 样例 #1

### 输入

```
12 16
18 10```

### 输出

```
8 
9```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何求解两匹马从给定位置到(1, 1)的最少步数问题，多数采用广度优先搜索（BFS）算法，少数使用记忆化搜索、数学公式推导等方法。BFS算法的核心思路是从起点开始，按层逐步扩展搜索空间，确保找到的路径是最短的。解决难点在于处理马的12种移动方向以及避免重复搜索。

### 所选的题解
- **作者：snaptrap (赞：253)  星级：5星**
    - **关键亮点**：通过数学推导得出通用公式，能高效解决问题，对特殊情况有详细特判。
    - **个人心得**：作者提到书上认为该题无法用数学方法，自己偏不信，花一小时推出公式，体现了勇于探索的精神。
    ```cpp
    int sum(int x,int y)
    {
        int t,i,j,s1,s2,s3,s4;
        if(x<y)
        {
            t=x; 
            x=y;
            y=t;
        }
        if(x==2&&y==1) return 2;
        else if(x==2&&y==2) return 3;
        s1=x-y;
        s2=s1%4;
        s3=s1/4;
        s4=s3+s2+(x+y-s2*3)/4;
        return s4;
    } 
    ```
    - **核心思想**：根据坐标差值、余数等计算出到达目标点的最少步数，对特殊点(2, 1)和(2, 2)单独处理。
- **作者：做梦想Peach (赞：117)  星级：4星**
    - **关键亮点**：采用手动模拟队列实现BFS，对BFS过程及手动模拟队列讲解详细，适合初学者理解。
    - **个人心得**：作者发现手动模拟队列的题解较少，所以发布此篇，为其他学习者提供不同思路。
    ```cpp
    void bfs(int X,int Y) {
        int head=0,tail=1,nx,ny;
        queue[1].x=X;
        queue[1].y=Y;
        queue[1].step=0;
        vis[X][Y]=true;
        while (head<tail) {
            head++;
            for (int i=0;i<12;i++) {
                nx=queue[head].x+dx[i];
                ny=queue[head].y+dy[i];
                if ((nx>=1&&nx<101)&&(ny>=1&&ny<101)&&vis[nx][ny]==false) {
                    tail++;
                    queue[tail].x=nx;
                    queue[tail].y=ny;
                    queue[tail].step=queue[head].step+1;
                    vis[nx][ny]=true;
                    if (nx==1&&ny==1) {
                        printf ("%d\n",queue[tail].step);
                        return;
                    }
                }
            }
        }
        return;
    }
    ```
    - **核心思想**：从起始点开始，利用手动模拟队列，按12个方向扩展搜索，记录每个点的步数，找到(1, 1)时输出步数。
- **作者：Billy●Herrington (赞：73)  星级：4星**
    - **关键亮点**：使用STL队列实现BFS，对BFS原理及方向数组的设置讲解清晰，代码简洁明了。
    - **个人心得**：作者作为第一次发布题解的蒟蒻，详细阐述了自己对题目的理解和解题思路，态度认真。
    ```cpp
    int  bfs (int x,int y)
    {
        q.push(Node(x,y,0));
        VIS[x][y]=true;
        while(!q.empty())
        {
            Node cur=q.front();
            q.pop ();
            for (int k=0;k<12;k++) 
            {
                int ex=cur.x+dx[k],ey=cur.y+dy[k];
                if(ex>=1&&ey>=1&&ex<=50&&ey<=50&&!VIS[ex][ey])
                {
                    q.push(Node(ex,ey,cur.step+1));
                    VIS[ex][ey]=true;
                }
                if(ex==nx&&ey==ny)return cur.step+1;
            } 
        }
    }
    ```
    - **核心思想**：借助STL队列，从起始点出发，按12个方向拓展搜索，标记已访问点，找到目标点时返回步数。

### 最优关键思路或技巧
- **数学推导**：如snaptrap通过分析马的移动特点，结合坐标关系，推导出通用公式，能直接计算出结果，效率极高，但推导过程需要较强的数学分析能力。
- **BFS算法**：多数题解采用BFS，利用其按层搜索的特性确保找到最短路径。在实现时，合理设置方向数组来表示马的12种移动方向，同时使用标记数组避免重复搜索。使用STL队列可简化代码实现，手动模拟队列则有助于理解队列的底层原理。

### 可拓展之处
此类题目属于求最短路径问题，类似的算法套路有：
 - **Dijkstra算法**：适用于带权图的单源最短路径问题。
 - **A*算法**：在BFS基础上加入启发式函数，可更快找到目标节点，常用于游戏地图寻路等场景。

同类型题可考虑在不同规则的棋盘上，求棋子到目标点的最短路径，或在有障碍物的地图中求最短路径等。

### 相似知识点洛谷题目
 - **P1135 奇怪的电梯**：通过按下电梯按钮在楼层间移动，求从起点到终点的最少按钮次数，考察BFS应用。
 - **P1379 八数码难题**：在3x3的棋盘上移动数字块，使其达到目标状态，求最少步数，可使用BFS结合状态压缩解决。
 - **P1443 马的遍历**：在棋盘上，马从起点出发，求到达每个点的最少步数，同样是BFS的典型应用。 

---
处理用时：49.82秒
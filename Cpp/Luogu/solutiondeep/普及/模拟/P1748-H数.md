# 题目信息

# H数

## 题目描述

所谓 H 数，是指只含有 $2,3,5,7$ 这些质因数的数，如 $630$ 是 H 数，而 $22$ 不是。

现在要求输出第 $n$ 个 H 数，为了方便起见将 $H[1]$ 定为 $1$。已知 $n$ 不超过 $10000$，最后数据在 int64 范围之内。


## 说明/提示

穷举会爆掉，要用生成法，最好加优化，不然空间复杂度比较大


## 样例 #1

### 输入

```
30```

### 输出

```
49```

## 样例 #2

### 输入

```
1```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效生成H数展开，解决的关键在于避免重复计算和优化空间复杂度。思路主要有以下几类：
1. **生成法结合指针**：通过维护多个指针，记录上一个被特定质因数乘所得到的H数的序号，每次从指针指向的H数乘对应质因数的结果中取最小值作为下一个H数，并更新指针。这种方法空间和时间复杂度较优。
2. **动态规划**：用数组表示第i个H数，从前面的数分别乘2、3、5、7中取比前一个H数大的最小数作为当前H数。
3. **集合或优先队列**：利用集合自带去重功能，每次从集合中取出最小数，再将其乘2、3、5、7的结果放入集合；优先队列则需额外处理去重问题。
4. **暴力穷举**：在一定区间内逐个判断数是否为H数，效率低，不适合大数据。

### 所选的题解
1. **作者：355_113 (5星)**
    - **关键亮点**：思路清晰，代码简洁高效。利用4个指针分别记录上一个被2、3、5、7乘得到H数的序号，通过一重循环生成H数，并提前预处理所有可能用到的H数，方便多组数据查询。
    - **个人心得**：前选手表示即使曾经有水平，现在做这种题也会犯错。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a=1,b=1,c=1,d=1;
long long w[10090];
int main(){
    w[1]=1;
    for(int i=2;i<=10000;++i){
        w[i]=w[a]*2;
        if(w[i]>w[b]*3)w[i]=w[b]*3;
        if(w[i]>w[c]*5)w[i]=w[c]*5;
        if(w[i]>w[d]*7)w[i]=w[d]*7;
        if(w[i]==w[a]*2)a++;
        if(w[i]==w[b]*3)b++;
        if(w[i]==w[c]*5)c++;
        if(w[i]==w[d]*7)d++;
    }
    while(scanf("%d",&n)!=EOF)
        cout<<w[n]<<"\n";
    return 0;
}
```
    - **核心思想**：通过4个指针a、b、c、d分别对应2、3、5、7，每次从w[a]*2、w[b]*3、w[c]*5、w[d]*7中取最小值作为下一个H数w[i]，并更新对应指针。

2. **作者：hensier (4星)**
    - **关键亮点**：提供多种思路对比，其中生成法单队列思路详细且代码实现清晰。通过4个指针和1个队列，每次从指针指向的队列元素乘对应质因数的结果中取最小值作为下一个H数，并移动对应指针。
    - **核心代码**：
```cpp
#include<cstdio>
int n,i,j,f[4]={1,1,1,1},m[]={2,3,5,7};
long long h[100001],M;
int main()
{
    scanf("%d",&n);
    h[1]=1;
    for(i=2;i<=n;i++)
    {
        M=h[f[0]]*m[0];
        for(j=1;j<4;j++)if(h[f[j]]*m[j]<M)M=h[f[j]]*m[j];
        h[i]=M;
        for(j=0;j<4;j++)if(M==h[f[j]]*m[j])f[j]++;
    }
    printf("%lld",h[n]);
    return 0;
}
```
    - **核心思想**：用数组f作为4个指针，m数组存放质因数2、3、5、7，每次循环先取h[f[0]]*m[0]为默认最小值M，再从其他指针指向元素乘对应质因数结果中找更小值更新M，将M赋值给h[i]并移动对应指针。

3. **作者：WanderingTrader (4星)**
    - **关键亮点**：指出与UVA136丑数解法相同，利用优先队列和map实现类似BFS的构造法。优先队列保证取出的数从小到大，map用于去重。
    - **核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <map>
using namespace std;
#define ll long long
priority_queue <ll,vector <ll>,greater <ll> > Q;
map <ll,bool> m;
ll xx[4] = {2,3,5,7};
int main()
{
    int n,cnt = 0;
    ll ans=1;
    scanf("%d",&n);
    if(n < 1) {printf("0\n");return 0;}
    Q.push(1);
    while(cnt < n)
    {
        ans = Q.top();
        Q.pop();
        if(m[ans])
            continue;
        m[ans] = true;
        ++cnt;
        for(int i = 0;i < 4;++i)
            Q.push(xx[i]*ans);
    }
    printf("%lld\n",ans);
    return 0;
}
```
    - **核心思想**：将1放入优先队列，每次取出队头元素ans，若未访问过（m[ans]为false），则标记为已访问，cnt加1，并将ans乘2、3、5、7的结果放入优先队列，直到取出第n个未重复的数。

### 最优关键思路或技巧
生成法结合指针的方法较为高效，通过维护指针记录每个质因数上次生成H数的位置，避免重复计算，降低时间和空间复杂度。在处理这类按特定规则生成序列的问题时，这种利用指针追踪位置、贪心选择最小值的方法值得借鉴。

### 同类型题或类似算法套路
此类题目通常是按特定质因数生成序列并求特定位置的数。类似套路是通过维护指针或使用优先队列等数据结构，结合贪心策略生成序列，同时注意去重和优化。

### 推荐题目
1. **P1748 逃离洞穴**：同样涉及按特定规则生成数字序列并求解相关问题。
2. **P2723 丑数 Humble Numbers**：与本题类似，求特定质因数组成的丑数序列中某位置的数。
3. **UVA136 丑数 Ugly Numbers**：与本题思路高度相似，可进一步巩固此类问题的解法。

### 个人心得摘录与总结
1. **355_113**：前选手也会在看似简单的题目上犯错，提醒即使有经验也不能掉以轻心。
2. **Leap_Frog**：开始没考虑重复问题，暴力删重复也能得较高分，但不是正确解法。强调解决此类问题要注意去重优化。 

---
处理用时：57.57秒
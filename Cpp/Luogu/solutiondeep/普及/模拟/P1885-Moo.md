# 题目信息

# Moo

## 题目描述

奶牛 Bessie 最近在学习字符串操作，它用如下的规则逐一的构造出新的字符串：

$S(0) =$ `moo`

$S(1) = S(0) +$ `m` $+$ `ooo` $+ S(0) =$ `moo` $+$ `m` $+$ `ooo` $+$ `moo` $=$ `moomooomoo`

$S(2) = S(1) +$ `m` $+$ `oooo` $+ S(1) =$ `moomooomoo` $+$ `m` $+$ `oooo` $+$  `moomooomoo` $=$ `moomooomoomoooomoomooomoo`

$\dots$

Bessie 就这样产生字符串，直到最后产生的那个字符串长度不小于读入的整数 $N$ 才停止。

通过上面观察，可以发现第 $k$ 个字符串是由：第 $k-1$ 个字符串 $+$ `m` $+$  $(k+2$ 个 $o) +$ 第 $k-1$ 个字符串连接起来的。

现在的问题是：给出一个整数 $N (1 \leq N \leq 10^9)$，问第 $N$ 个字符是字母 `m` 还是 `o`？


## 说明/提示

样例解释：

由题目所知：字符串 $S(0)$ 是 `moo`, 现在要求第 $11$ 个字符，显然字符串 $S(0)$ 不够长；

同样 $S(1)$ 的长度是 $10$，也不够长；$S(2)$ 的长度是 $25$，够长了，$S(2)$ 的第 $11$ 个字符是 `m`，所以答案就输出 `m`。


## 样例 #1

### 输入

```
11```

### 输出

```
m```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效确定给定位置字符是 `m` 还是 `o`。暴力模拟会超时或内存超限，因此多数题解采用分治策略。
 - **思路**：先通过递推公式计算出每个 `S(k)` 字符串的长度，找到第一个长度不小于 `N` 的字符串 `S(ans)`。然后将 `S(ans)` 分为三部分：开头的 `S(ans - 1)`、中间的 `m` 和若干个 `o`、结尾的 `S(ans - 1)`，根据 `N` 在这三部分中的位置递归确定字符。
 - **算法要点**：计算字符串长度的递推公式 `len[i]=2*len[i - 1]+i + 2` 是关键，利用该公式预处理长度数组。之后根据 `N` 与各部分边界的关系进行分情况讨论。
 - **解决难点**：难点在于准确分析 `N` 在不同部分时如何递归处理，以及边界条件的判断，确保递归正确终止。

### 所选题解
1. **作者：FC是女孩子 (4星)**
    - **关键亮点**：思路清晰，代码简洁。先通过模拟长度找到合适的字符串，再通过迭代处理确定字符位置。
    - **核心代码**：
```cpp
#include<cstdio>

int n,t = 0,k = 3;

int main()
{
    scanf("%d",&n);int m = n;
    while(t <= n) t = t * 2 + k,k++;
    k--;
    while(t > 0)
    {
        t = (t - k)/2;
        if(m > t)
        {
            if(m <= t + k)
            {
                if(m == t + 1) return printf("m"),0;
                else printf("o"),0;
            }
            else m = m - (t + k);
        }
        k--;
    }
    return 0;
}
```
    - **核心思想**：先通过循环找到长度首次超过 `n` 的字符串，记录此时的 `t` 和 `k`。然后通过内层循环，不断将 `t` 减半并根据 `m`（即 `n`）与 `t` 和 `k` 的关系判断字符。
2. **作者：Starlight237 (4星)**
    - **关键亮点**：代码结构清晰，采用分治递归的标准写法，通过预处理长度数组，然后在递归函数中清晰地分三种情况讨论。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define reg register
static int n,len[100001];
string str;
inline int pre(){
    int ans;
    for(reg int i = 1;len[i - 1]<n||(ans = i,0);++i)len[i]=(len[i - 1]<<1)+i + 2;
    return ans;
}
void dg(int m,int N){
    while(len[m - 1]>N)--m;
    if(N == len[m - 1]+1){putchar('m');return;}
    else if(N <= len[m - 1]+m + 2){putchar('o');return;}
    dg(m - 1,N - len[m - 1]-m - 2);
}
int main(){
    scanf("%d",&n),dg(pre(),n);
    return 0;
}
```
    - **核心思想**：`pre` 函数预处理长度数组并返回满足条件的最小 `ans`。`dg` 递归函数根据 `N` 与 `len[m - 1]` 及中间部分边界的关系，确定字符或继续递归。
3. **作者：Deny_小田 (4星)**
    - **关键亮点**：提供多种思路对比，其中分治算法代码简洁明了，递归函数参数设置合理，逻辑清晰。
    - **核心代码**：
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define Size 100005
using namespace std;
typedef long long type;
type n;
string str;
int t[Size];
int start(int p){
    int now,i = 1;
    t[0] = 0;
    while(1){
        t[i] = 2*t[i - 1]+(i + 2);
        if(t[i] >= p){ now = i; break; }
        i++;
    }
    return now;
}
void solve(int q,int n){  
    while(t[q - 1] > n) q--;  
    if(n == t[q - 1]+1){  
        printf("m\n"); 
        return ;  
    }else if(n <= t[q - 1]+q + 2){  
        printf("o\n");
        return ;  
    }  
    solve(q - 1,n-(t[q - 1]+q + 2));  
}
int main(){
    int cnt = 0;
    cin >> n;
    cnt = start(n);
    solve(cnt,n);
    return 0;
} 
```
    - **核心思想**：`start` 函数通过循环计算长度数组并返回满足条件的 `q`。`solve` 递归函数根据 `n` 与 `t[q - 1]` 及中间部分边界的关系，确定字符或继续递归。

### 最优关键思路或技巧
 - **分治策略**：将长字符串构建问题分解为多个短字符串的组合问题，通过递归处理不同部分，有效降低时间复杂度。
 - **预处理长度数组**：利用递推公式预先计算每个字符串长度，避免重复计算，提高查找效率。

### 可拓展思路
此类题目属于字符串构造与查询问题，相似套路是寻找字符串构造规律，利用规律预处理信息（如长度、特定位置等），再通过分治或递归处理查询。同类型题可能会改变字符串构造规则或查询方式，但核心思路不变。

### 相似知识点洛谷题目
 - [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：通过递归或递推寻找数字生成规律。
 - [P1044 栈](https://www.luogu.com.cn/problem/P1044)：利用卡特兰数规律解决栈操作序列计数问题，涉及递推思想。
 - [P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)：通过递推关系计算不同走法数量，考查对规律的发现与应用。

### 个人心得摘录与总结
无明显个人心得相关内容。 

---
处理用时：49.90秒
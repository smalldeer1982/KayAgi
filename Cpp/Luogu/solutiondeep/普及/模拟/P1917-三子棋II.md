# 题目信息

# 三子棋II

## 题目描述

小 a 和 uim 喜欢互相切磋三子棋。三子棋大家都玩过是吗？就是在九宫格里面 $\verb!OOXX!$（别想歪了），谁连成 $3$ 个就赢了。

虽然小 a 很努力地记录棋谱，可还是下不过 uim。

由于小 a 比较愚蠢，uim 总是让他先。小 a 下的第一个子一定是在中心。

这回小 a 希望使用计策。目前棋局刚开始，棋盘上不到 $3$ 颗棋子，小 a 想知道，根据目前的局势，他有没有必胜策略（也就是自己以最佳方案下棋，无论对手怎么下，自己必胜）。


## 样例 #1

### 输入

```
---
-O-
---```

### 输出

```
Dont know.
1
```

## 样例 #2

### 输入

```
---
-O-
-XO```

### 输出

```
xiaoa will win.
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕三子棋游戏中小a是否有必胜策略展开。思路上，有的通过分类讨论uim落子位置来判断，有的使用Minimax算法构建搜索树评估局面。算法要点包括利用题目给定的小a先下中心且棋子数不超三颗的条件，通过不同方式判断局面。难点在于全面考虑各种情况，避免遗漏。

### 所选的题解
- **作者：stone_juice石汁 (5星)**
    - **关键亮点**：思路清晰，利用题目关键信息简化问题，仅通过判断uim是否下邻边得出结论，代码简洁高效，可读性强。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

int ans;
char x;
bool pd; 

int main()
{
    for(int i = 1; i <= 9; i ++)
    {
        scanf("%c", &x);
        if(x == 'X' &&!(i % 2))pd = true; 
        if(x == '-') ans ++;
    }
        
    if(pd == true)
        cout << "xiaoa will win．" << endl << 9 - ans;
    else 
        cout << "Dont know．" << endl << 9 - ans;
    return 0;
}
```
    - **核心实现思想**：遍历输入的9个字符，若遇到'X'且其位置序号为偶数（对应uim下邻边情况），则判定小a必胜，同时记录空格数来计算棋子总数并输出。

- **作者：LJC00118 (4星)**
    - **关键亮点**：在他人解法基础上，发现特殊情况并进行特判，使解法更全面。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
char ma[4][4];
int mx[4]={1,2,2,3};
int my[4]={2,1,3,2};
int ans=0;
int main()
{
    for(int i=1;i<=3;i++)
    {
        for(int j=1;j<=3;j++)
        {
            cin>>ma[i][j];
            if(ma[i][j]!='-') ans++;
        }
    }
    if(ma[1][2]!='-'&&ma[3][2]!='-')
    {
        cout<<"Dont know."<<endl<<3;
        return 0;
    }
    if(ma[2][1]!='-'&&ma[2][3]!='-')
    {
        cout<<"Dont know."<<endl<<3;
        return 0;
    }
    bool pd=0;
    for(int i=0;i<4;i++)
    {
        if(ma[mx[i]][my[i]]=='X') pd=1;
    }
    if(pd==1)
    {
        cout<<"xiaoa will win.";
    }
    else
    {
        cout<<"Dont know.";
    }
    cout<<endl<<ans;
    return 0;
}
```
    - **核心实现思想**：先读取棋盘状态并统计棋子数，对特殊情况（同一行或列两端有棋子）进行特判，然后判断uim是否下在特定邻边位置，从而确定小a是否必胜。

- **作者：Ky1ine (4星)**
    - **关键亮点**：先分析得出uim无必胜策略，再对小a是否有必胜策略进行分类讨论，逻辑清晰。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
using namespace std;
int i, j, sum=0;
bool winner=false;
char a[3][3];
int main() {
    for(i=1; i<=3; i++) {
        for(j=1; j<=3; j++) {
            cin>>a[i][j];
            if(a[i][j]!= '-') {
                sum++;
            }
        }
    }
    if(sum!= 0) { 
        if(a[1][1] == 'X') winner = false;
        else if(a[1][3] == 'X') winner = false;
        else if(a[3][1] == 'X') winner = false;
        else if(a[3][3] == 'X') winner = false;
        else { 
            if(a[1][2]!= 'O') {
                if(a[2][1]!= 'O') {
                    if(a[2][3]!= 'O') {
                        if(a[3][2]!= 'O') winner = true;
                    }
                }
            }
        }
    }
    else winner = false;
    if(winner) cout << "xiaoa will win." << endl << sum; 
    else cout << "Dont know." << endl << sum; 
    return 0;
}
```
    - **核心实现思想**：读取棋盘状态并统计棋子数，若中间有棋子，根据uim在斜边或横排中间下子的不同情况判断小a是否有必胜策略，同时考虑特殊的“智障”下棋情况。

### 最优关键思路或技巧
利用题目给定的小a先下中心且棋子数不超三颗的条件，通过分类讨论uim的落子位置来简化问题求解。如stone_juice石汁的题解，仅通过判断uim是否下邻边就得出结论，极大简化了代码实现。

### 可拓展思路
此类题目可拓展到更复杂的博弈游戏分析，如五子棋等。通用算法套路可考虑Minimax算法及其优化版本Alpha - Beta剪枝，通过构建搜索树评估局面。

### 洛谷相似题目推荐
- P1288 取数游戏II
- P1199 [NOIP2010 普及组] 三国游戏
- P2679 子串分值和

---
处理用时：48.67秒
# 题目信息

# [NOIP 2013 提高组] 积木大赛

## 题目背景

NOIP2013 提高组 D2T1

## 题目描述

春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为 $n$ 的大厦，大厦可以看成由 $n$ 块宽度为 $1$ 的积木组成，第 $i$ 块积木的最终高度需要是 $h_i$。

在搭建开始之前，没有任何积木（可以看成 $n$ 块高度为 $0$ 的积木）。接下来每次操作，小朋友们可以选择一段连续区间 $[l, r]$，然后将第 $L$ 块到第 $R$ 块之间（含第 $L$ 块和第 $R$ 块）所有积木的高度分别增加 $1$。

小 M 是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。


## 说明/提示

**样例解释**

其中一种可行的最佳方案，依次选择：$[1,5]$，$ [1,3]$，$[2,3]$，$[3,3]$，$ [5,5]$。

**数据范围**

- 对于 $30\%$ 的数据，有 $1 \leq n \leq 10$；
- 对于 $70\%$ 的数据，有 $1 \leq n \leq 1000$；
- 对于 $100\%$ 的数据，有 $1 \leq n \leq 100000$，$0 \leq h_i \leq 10000$。


## 样例 #1

### 输入

```
5
2 3 4 1 2```

### 输出

```
5```

# AI分析结果

• 综合分析与结论：
    - 多数题解思路为贪心策略，通过比较相邻积木高度差来计算最少操作次数。当当前积木高度大于前一块积木高度时，操作次数增加两者高度差；否则，无需额外增加操作次数。这是因为每次操作可对连续区间操作，矮的积木可在增高相邻高积木时顺带达到目标高度。
    - 部分题解提到差分思想，本质与贪心思路一致，通过计算相邻元素差值，统计非负差值之和得到结果。
    - 有一题解使用线性规划结合对偶转化解题，思路复杂，不适合普及组难度。
    - 整体题解质量参差不齐，部分题解思路清晰、代码简洁，部分题解在思路阐述或代码规范上有所欠缺。

所选的题解：
  - 作者：缄默Mutism (赞：43)  星级：4星
    - 关键亮点：思路简洁明了，直接阐述通过计算相邻两堆积木高度差来确定操作次数的方法，代码简短精炼。
    - 重点代码：
```pascal
readln(n); 
for i:=1 to n do
  begin
      read(p);
      if q<p then s:=s+p-q;
      q:=p;
  end;
writeln(s);
```
核心实现思想：依次读取每块积木高度，与前一块积木高度比较，若当前积木高，则增加两者高度差到总操作次数，同时更新前一块积木高度。
  - 作者：niuniudundun (赞：5)  星级：4星
    - 关键亮点：清晰阐述题目大意与解法，使用艾弗森括号表示答案公式，代码简洁规范，注释详细。
    - 重点代码：
```cpp
//多倍经验：P5019 P3078
#include<iostream>
using namespace std;
long long n,d[100001],ans=0;//d 就是 h
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>d[i];
	}
	for(int i=1;i<=n;i++){
		if(d[i]>d[i-1]) ans+=d[i]-d[i-1];
	}
	cout<<ans<<endl;
	return 0;
}
```
核心实现思想：读入每块积木高度，遍历比较相邻积木高度，若当前积木高则累加高度差到答案。
  - 作者：ZMYJOE (赞：1)  星级：4星
    - 关键亮点：详细说明贪心策略的建造方案并给出证明，代码结构清晰，有完整的输入读取函数。
    - 重点代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=100000+10;
int n;
int h[maxn],p[maxn];

int read(int &x) {
    int f=1;
    x=0;
    char c=getchar();
    while(c>'9' || c<'0') {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0' && c<='9') {
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
}

int main() {
    read(n);
    for(int i=1; i<=n; ++i) read(h[i]);
    h[0]=0;
    int ans=0;
    for(int i=1; i<=n; ++i) {
        if(h[i]>h[i-1]) ans+=h[i]-h[i-1];
    }
    printf("%d",ans);
    return 0;
}
```
核心实现思想：先读取积木数量与每块积木高度，初始化前一块积木高度为0，遍历比较相邻积木高度，若当前积木高则累加高度差到答案。

最优的关键思路或技巧：利用贪心思想，通过比较相邻积木高度差来计算最少操作次数，避免复杂的搜索或动态规划。

可拓展之处：此类题目属于区间操作求最优解类型，类似套路有利用差分优化区间操作、通过分析相邻元素关系简化问题。

推荐题目：
  - P5019 [NOIP2018 普及组] 龙虎斗：同样涉及数组元素关系分析与操作优化。
  - P3078 [USACO13FEB]Taxi G ：需要考虑区间覆盖与最优策略选择。
  - P1248 加工生产调度：通过贪心策略解决任务调度的最优解问题。

个人心得：无。 

---
处理用时：59.87秒
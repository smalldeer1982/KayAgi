# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕线段树和分块两种算法来解决区间乘法、加法及求和问题。线段树算法是主流，各题解在实现细节上有差异，但核心思路均为利用线段树的结构特点，通过懒标记优化区间操作。分块算法虽能解题，但相比线段树在效率和代码复杂度上不占优势。

所选的题解：
  - **作者：zjy111 (赞：35)  4星**
    - **关键亮点**：思路清晰，详细阐述线段树各操作原理，如建树、区间修改（含懒标记及运算顺序）、区间查询，对线段树基础知识讲解细致，代码可读性好。
    - **个人心得**：无
    - **核心代码 - 建树**：
```cpp
void build(ll p,ll l,ll r){//当前建立节点p, 建树区间l到r
	lll[p]=l,rrr[p]=r; //两个数组分别记录当前节点左右代表的区间
	if(l==r){ 
		sum[p]=a[l]%md; //左右端点相等, 到达递归边界
		return;
	}
	ll mid=(l+r)>>1;
	build(ls(p),l,mid);  //递归到它的左子
	build(rs(p),mid+1,r);  //递归到它的右子
	sum[p]=sum[ls(p)]+sum[rs(p)]%md;  //计算出当前节点的求和
}
```
**核心思想**：递归构建线段树，记录每个节点代表区间，叶子节点存储数组对应值并取模，非叶子节点通过合并左右子节点信息得到区间和。
    - **核心代码 - 懒标记下传**：
```cpp
void pushdown(ll p){ //从p节点开始下传
	sum[ls(p)]=(mu[p]*sum[ls(p)]+(rrr[ls(p)]-lll[ls(p)]+1)*add[p]%md)%md; 
   //将区间和从p传递到其左子, 下同
	sum[rs(p)]=(mu[p]*sum[rs(p)]+(rrr[rs(p)]-lll[rs(p)]+1)*add[p]%md)%md; 
   //将区间和从p传递到其右子, 下同
	mu[ls(p)]=(mu[p]*mu[ls(p)])%md;
	mu[rs(p)]=(mu[p]*mu[rs(p)])%md;
   //乘法运算懒标记下传
	add[ls(p)]=(mu[p]*add[ls(p)]+add[p])%md;
	add[rs(p)]=(mu[p]*add[rs(p)]+add[p])%md; 
   //加法运算懒标记下传
	mu[p]=1,add[p]=0; 
   //清空懒标记(注意:由于0乘任何数都得0,所以乘法标记传为1,加法标记传为0)
}
```
**核心思想**：将父节点的乘法和加法懒标记下传给子节点，更新子节点的区间和、乘法标记及加法标记，同时清空父节点标记。
  - **作者：GaryZhong (赞：17)  4星**
    - **关键亮点**：从数学角度分析区间和形式为$ax + b$，清晰阐述区间修改和标记下传原理，代码结构清晰，有读入加速和O2优化。
    - **个人心得**：无
    - **核心代码 - 标记下传**：
```cpp
void down(int rt, int l, int r)
{
    if (mtp[rt] == 1 && inc[rt] == 0) return; //都为初始状态时无需下传
    if (l!= r)
        mtp[lson] = mtp[lson] * mtp[rt] % P, //儿子的mtp乘以当前节点mtp
        mtp[rson] = mtp[rson] * mtp[rt] % P, 
        inc[lson] = (inc[lson] * mtp[rt] % P + inc[rt]) % P; //儿子的inc乘以当前节点mtp再加当前节点inc
        inc[rson] = (inc[rson] * mtp[rt] % P + inc[rt]) % P;
    sum[rt] = (sum[rt] * mtp[rt] % P + inc[rt] * (r - l + 1) % P) % P; //更新节点信息
    mtp[rt] = 1, inc[rt] = 0; //清空标记
}
```
**核心思想**：当下传节点的乘法和加法标记非初始状态时，更新子节点的乘法和加法标记，并根据标记更新当前节点区间和，最后清空当前节点标记。
    - **核心代码 - 区间乘法**：
```cpp
void rangemtp(int rt, int l, int r)
{
    down(rt, l, r); //先下传标记
    if (L <= l && r <= R) { mtp[rt] = mtp[rt] * k % P, inc[rt] = inc[rt] * k % P; return; } //区间更新，mtp和inc都乘以一个k
    int mid = l + r >> 1;
    if (L <= mid) rangemtp(lson, l, mid);
    if (mid + 1 <= R) rangemtp(rson, mid + 1, r);
    down(lson, l, mid), down(rson, mid + 1, r); //下传儿子的标记
    sum[rt] = (sum[lson] + sum[rson]) % P;
}
```
**核心思想**：先下传标记，若当前区间在目标区间内，更新当前节点的乘法和加法标记；否则递归处理子区间，并下传子节点标记，最后更新当前节点区间和。
  - **作者：MashPlant (赞：7)  4星**
    - **关键亮点**：提出针对模数后输入的卡常数技巧，通过对64位除法优化取模操作，代码实现高效，当前排名rk1。
    - **个人心得**：无
    - **核心代码 - 取模优化**：
```cpp
// 有返回值的宏，这是g++的一个拓展，可以用来当函数用
#define Mod(x)                            \
    ({                                    \
        auto __x = x;                     \
        __x - P *((__x * M) >> (64 + K)); \
    })
...
u128 M;
u32 P, K;
...
for (K = 0; P >= 1 << (K + 1); ++K)
        ;
M = ((u128)1 << (K + 64)) / P;
if (((P * M) >> (64 + K))!= 1)
    ++M;
```
**核心思想**：通过计算合适的$M$和$K$值，利用位运算实现对64位整数$x$模$P$的优化计算，提高取模效率。

• 最优关键思路或技巧：线段树结合懒标记是解决本题的核心思路。在实现中，合理处理乘法和加法标记的关系，先乘后加保证运算顺序正确；利用位运算、快读等优化技巧提高代码效率；针对模数后输入情况，通过数学推导优化取模操作。

• 可拓展之处：此类题目拓展方向为增加区间操作类型，如区间求最值、区间异或等，算法套路仍是基于线段树或分块，通过维护不同信息和设计相应懒标记更新规则解决。

• 相似知识点洛谷题目：
  - **P3373 【模板】线段树2**：与本题类似，涉及区间乘法、加法及求和操作，可作为巩固练习。
  - **P1828 [USACO3.4] 香甜的黄油 Sweet Butter**：运用线段树解决区间统计问题，锻炼对线段树的应用能力。
  - **P2824 [HEOI2016/TJOI2016]排序**：通过线段树维护区间信息，解决复杂的区间排序和查询问题，提升对线段树综合运用能力。

• 个人心得摘录与总结：
  - **作者：Mingoal**：强调乘运算级别高于加，做加法不用管乘法，做乘法时要考虑加法，这是理解程序逻辑的关键。通过多次练习线段树加深对其理解。 

---
处理用时：107.07秒
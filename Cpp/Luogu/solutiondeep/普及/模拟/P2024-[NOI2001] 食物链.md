# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果

这些题解主要围绕如何利用并查集解决动物食物链关系判断假话数量的问题，可分为种类并查集（开3倍并查集）和带权并查集两种思路：
- **种类并查集**：开3倍大小的并查集，将每个动物的同类、猎物、天敌分别放在不同部分。如1 - n表示动物本身，n + 1 - 2n表示猎物，2n + 1 - 3n表示天敌。根据输入关系合并相应集合，并判断是否与已有关系冲突。
- **带权并查集**：每个节点增加权值表示与父节点关系，0为同类，1为被父节点吃，2为吃父节点。查找和合并时更新权值以维护关系，通过权值判断输入关系真假。

难点在于如何根据动物间复杂的食物链关系，准确地在并查集中维护和判断各种关系。种类并查集需处理好3倍并查集不同部分的合并与冲突判断；带权并查集则要精确推导和运用权值更新公式。

综合质量来看，以下3篇题解相对突出：
- **作者：Sooke（5星）**
    - **关键亮点**：思路阐述极为清晰，从引入种类并查集概念开始，逐步深入解释本题如何运用种类并查集。结合图片对数据处理过程详细说明，代码简洁且注释完备，对初学者友好。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <cstdio>

inline int read() {
    char c = getchar(); int n = 0;
    while (c < '0' || c > '9') { c = getchar(); }
    while (c >= '0' && c <= '9') { n = (n << 1) + (n << 3) + (c & 15); c = getchar(); }
    return n;
}

const int maxN = 100005;

int n, m, ans, fa[maxN * 3];

int find(int u) { return fa[u] == u? u : fa[u] = find(fa[u]); }

int main() {
    n = read(), m = read();
    for (int i = 1; i <= n * 3; i++) { fa[i] = i; }
    for (; m; m--) {
        int opt = read(), u = read(), v = read();
        if (u > n || v > n) { ans++; continue; }
        if (opt == 1) {
            if (find(u + n) == find(v) || find(u) == find(v + n)) { ans++; }
            else {
                fa[find(u)] = find(v);
                fa[find(u + n)] = find(v + n);
                fa[find(u + n + n)] = find(v + n + n);
            }
        } else {
            if (find(u) == find(v) || find(u) == find(v + n)) { ans++; }
            else {
                fa[find(u + n)] = find(v);
                fa[find(u + n + n)] = find(v + n);
                fa[find(u)] = find(v + n + n);
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
```
    - **核心思想**：通过`read`函数读入数据，利用`find`函数查找根节点。在`main`函数中，根据输入的操作类型`opt`，判断`u`和`v`关系是否与已有关系冲突，若不冲突则按规则合并相应并查集。
- **作者：檀黎斗·神（4星）**
    - **关键亮点**：代码简短精炼，同样采用种类并查集思路，通过清晰的注释对关键逻辑进行说明，在保证思路清晰的同时实现高效编码。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<cstdio>
int fa[300005];
int n,k,ans;
inline int read()
{
    int sum=0;
    char ch=getchar();
    while(ch>'9'||ch<'0') ch=getchar();
    while(ch>='0'&&ch<='9') sum=sum*10+ch-48,ch=getchar();
    return sum;
}//读入优化
int find(int x)
{
    if(x!=fa[x]) fa[x]=find(fa[x]);
    return fa[x];
}//查询
int unity(int x,int y)
{
    int r1=find(fa[x]),r2=find(fa[y]);
    fa[r1]=r2;
}//合并
int main()
{
    int x,y,z;
    n=read(),k=read();
    for(int i=1;i<=3*n;++i) fa[i]=i; //对于每种生物：设 x 为本身，x+n 为猎物，x+2*n 为天敌
    for(int i=1;i<=k;++i) 
    {
        z=read(),x=read(),y=read();
        if(x>n||y>n) {ans++; continue;} // 不属于该食物链显然为假
        if(z==1)
        {
            if(find(x+n)==find(y)||find(x+2*n)==find(y)) {ans++; continue;}
            //如果1是2的天敌或猎物，显然为谎言
            unity(x,y); unity(x+n,y+n); unity(x+2*n,y+2*n);
            //如果为真，那么1的同类和2的同类，1的猎物是2的猎物，1的天敌是2的天敌
        }
        else if(z==2)
        {
            if(x==y) {ans++; continue;} //其实是废话但是可以稍微省点时间
            if(find(x)==find(y)||find(x+2*n)==find(y)) {ans++; continue;}
            //如果1是2的同类或猎物，显然为谎言
            unity(x,y+2*n); unity(x+n,y); unity(x+2*n,y+n);
            //如果为真，那么1的同类是2的天敌，1的猎物是2的同类，1的天敌是2的猎物
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心思想**：利用`read`函数优化读入，`find`函数查找集合，`unity`函数合并集合。在`main`函数中，根据输入的`z`判断操作类型，同样先判断关系是否冲突，再进行相应合并。
- **作者：天泽龟（4星）**
    - **关键亮点**：采用带权并查集解法，详细讲解带权并查集概念及本题中权值设定和转移方法，通过数学推导和图片辅助说明，思路清晰，代码注释详细。
    - **个人心得**：提到打表辅助理解和验证公式，之后再进行数学证明。
    - **核心代码**：
```cpp
#include <iostream>  //带权并查集 题解 

using namespace std;

int f[100000],re[100000];  //0-->同种动物，1-->捕食关系，2-->被捕食关系。

int n,m,a,b,p,ans=0;

int find(int a)
{
    int fa=f[a];
    if (a!=fa) {
        f[a]=find(fa);
        re[a]=(re[a]+re[fa])%3;   
        return f[a];
    }
    else return fa;
}
int main()
{
    cin>>n>>m;
    for (int i=1;i<=n;i++) f[i]=i,re[i]=0;
    for (int i=1;i<=m;i++)
    {
        cin>>p>>a>>b;
        if ((a>n||b>n)||(p==2&&a==b)) {   //两种特殊情况 
            ans++; continue;
        }
        if (p==1)  //对关系1讨论 
        {
            int f1=find(a),f2=find(b);
            if (f1==f2&&re[a]!=re[b])  //判断是否在同一棵树及两者是否为同种动物。 
            {
                ans++; continue;
            }
            else if(f1!=f2)
            {
                f[f1]=f2; re[f1]=(3-re[a]+re[b])%3;   //合并 
            }
        }
        if (p==2)  //对关系2讨论 
        {
            int f1=find(a),f2=find(b);
            if (f1==f2) 
            {
                int rela=(re[a]-re[b]+3)%3;  //用两个节点与父亲的关系推出两者关系 

                if (rela!=1) {
//                    cout<<"HERE?"<<endl;
                    ans++; continue;
                }
            }
            else {
                int f1=find(a),f2=find(b);
                f[f1]=f2; re[f1]=(3-re[a]+re[b]+1)%3;   //合并 
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
    - **核心思想**：`find`函数查找根节点同时更新权值`re`。在`main`函数中，根据输入`p`判断操作类型，先处理特殊情况，再针对不同操作判断节点是否在同一树及权值关系，若不在同一树则按规则合并并更新权值。

**最优关键思路技巧**：无论是种类并查集还是带权并查集，核心都是利用并查集的特性维护动物间复杂关系。种类并查集通过巧妙拓展并查集规模，直观地表示不同关系；带权并查集则通过给节点赋予权值，以更紧凑的方式维护关系。两种方法都需准确判断关系冲突和正确合并集合。

**可拓展之处**：此类题目属于并查集应用的拓展，相似类型题常涉及维护多种元素关系，可通过扩展并查集规模或增加权值维度解决。类似算法套路是分析元素间关系，确定并查集维护方式，处理好合并和冲突判断。

**相似知识点洛谷题目**：
- **P1525 [NOI2010] 关押罪犯**：利用种类并查集维护罪犯之间的对立关系。
- **P1196 [NOI2002] 银河英雄传说**：通过并查集维护舰队之间的关系，涉及到路径压缩和集合合并操作。
- **P2257 YY的GCD**：结合莫比乌斯反演和并查集优化算法，解决数论与并查集结合的问题。 

---
处理用时：118.58秒
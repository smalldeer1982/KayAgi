# 题目信息

# 电话号码

## 题目描述

一串由长长的数字组成的电话号码通常很难记忆。为了方便记忆，有种方法是用单词来方便记忆。例如用 `Three Tens` 来记忆电话 `3-10-10-10`。

电话号码的标准形式是七位数字，中间用连字号分成前三个和后四个数字（例如：`888-1200`）。电话号码可以用字母来表示。以下是字母与数字的对应：

 - `A`，`B` 和 `C` 对应 `2`；
 - `D`，`E` 和 `F` 对应 `3`；
 - `G`，`H` 和 `I` 对应 `4`；
 - `J`，`K` 和 `L` 对应 `5`；
 - `M`，`N` 和 `O` 对应 `6`；
 - `P`，`R` 和 `S` 对应 `7`；
 - `T`，`U` 和 `V` 对应 `8`；
 - `W`，`X` 和 `Y` 对应 `9`。

你会发现其中没有字母 `Q` 和 `Z`。电话中的连字号是可以忽略。例如 `TUT-GLOP` 的标准形式是 `888-4567`，`310-GINO` 的标准形式是 `310-4466`，`3-10-10-10` 的标准形式是 `310-1010`。

如果两个电话号码的标准形式是一样的，那么这两个电话号码就是一样的。

现在有一本电话簿，请从中找出哪些电话号码是重复的。


## 说明/提示

【数据范围】

对于 $30\%$ 的数据，$N\le20$。

对于 $50\%$ 的数据，$N\le10000$。

对于 $100\%$ 的数据，$N\le10^5$。


## 样例 #1

### 输入

```
3

TUT-GLOP

3-10-10-10

310-1010

```

### 输出

```
310-1010 2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕将电话号码字符串处理为标准形式并统计重复项展开。思路上，多数题解采用先将输入字符串中的字母按规则转换为数字，去除连字符，得到标准的7位数字形式，之后使用不同数据结构统计重复情况。

算法要点包括：
1. **字符映射**：通过数组或map建立字母与数字的对应关系。
2. **字符串处理**：遍历输入字符串，进行字符转换与连字符处理。
3. **重复统计**：使用数组、map、排序等方式统计并输出重复的电话号码。

解决难点在于：
1. **字符映射的准确性**：需确保所有字母准确映射，注意0和1虽无对应字母但仍要处理。
2. **输出格式**：按标准格式输出电话号码，包括连字符及可能的前导零处理。
3. **效率问题**：面对较大数据规模，需选择合适数据结构与算法保证效率。

### 所选的题解
1. **作者：tututu (赞：20)  星级：5星**
    - **关键亮点**：思路清晰简洁，代码可读性高。利用数组存储字母与数字对应关系，读入字符串处理后存入数组，通过排序和线性枚举找出重复项，整体实现高效简洁。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int f[25]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9};
int n,t;
string s[100002],cnt;
bool fa;
int main(){
  cin>>n;
  for(int i=1;i<=n;i++){
    cin>>cnt;
    for(int j=0;j<cnt.length();j++)
      if(cnt[j]<='9'&&cnt[j]>='0') s[i]+=cnt[j];
      else if(cnt[j]>='A'&&cnt[j]<='Z') s[i]+='0'+f[cnt[j]-'A'];
  }
  sort(s+1,s+n+1);
  for(int i=1;i<=n+1;i++)
    if(s[i]!=s[i-1]){
      if(t>1) cout<<s[i-1].substr(0,3)<<'-'<<s[i-1].substr(3,4)<<' '<<t<<endl,fa=true;
      t=1;
    } else t++;
  if(!fa) cout<<"No duplicates.";
  return 0;
}
```
    - **核心思想**：读入电话号码字符串，将数字直接保留，字母按f数组映射转换后存入s数组。对s数组排序，遍历数组统计并输出重复项。

2. **作者：Drifterming (赞：5)  星级：4星**
    - **关键亮点**：使用map统计电话号码出现次数，利用结构体和自定义比较函数按字典序输出结果，逻辑清晰，代码结构完整。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
#include<string>
using namespace std;
int n,cnt,now,pos,sum[100005];
string s,temp,tot[100005];
char excel[100];
map<string,int> a;
struct Ans
{
    int cs;
    string chuan;
}ans[100005];
void init()        //初始化函数 
{
    excel['0']='0';excel['1']='1';
    excel['A']=excel['B']=excel['C']=excel['2']='2';
    excel['D']=excel['E']=excel['F']=excel['3']='3';
    excel['G']=excel['H']=excel['I']=excel['4']='4';
    excel['J']=excel['K']=excel['L']=excel['5']='5';
    excel['M']=excel['N']=excel['O']=excel['6']='6';
    excel['P']=excel['R']=excel['S']=excel['7']='7';
    excel['T']=excel['U']=excel['V']=excel['8']='8';
    excel['W']=excel['X']=excel['Y']=excel['9']='9';
}
bool cmp(Ans a,Ans b)
{
    return a.chuan+b.chuan<b.chuan+a.chuan;
}
int main()
{
    init();        //千万千万别忘记调用 
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        temp.clear();pos=0;        //将temp清空，pos归零 
        for(int j=0;j<s.length();j++)
        {
            if(s[j]!='-')    //转化为数字 
            {
                temp+=excel[s[j]];
                pos++;
            }
            if(pos==3) temp+='-',pos=-999999999;    //到了该加'-'的地方，加上'-',同时将pos设为负值，防止重复添加 
        }
        if(!a[temp]) tot[++cnt]=temp;    //如果这个字符串没出现过，将这个字符串加入到已有的字符串中 
        a[temp]++;    //该字符串出现的次数++ 
    }
    for(int i=1;i<=cnt;i++)        //找哪个字符串是重复的 
    {
        if(a[tot[i]]>1)
        {
            ans[++now].chuan=tot[i];    //存答案 
            ans[now].cs=a[tot[i]];
        }
    }
    if(!now)    //没有重复的 
    {
        printf("No duplicates.");
        return 0;
    }
    sort(ans+1,ans+now+1,cmp);        //按字典序排列 
    for(int i=1;i<=now;i++)
    {
        cout<<ans[i].chuan<<' ';
        printf("%d\n",ans[i].cs);
    }
    return 0;
}
```
    - **核心思想**：init函数初始化字符映射关系。读入电话号码，处理为标准形式存入temp，用map a统计出现次数，将不重复的标准形式存入tot数组。遍历tot数组，将重复的存入ans结构体数组，最后按字典序排序输出。

3. **作者：EuphoricStar (赞：1)  星级：4星**
    - **关键亮点**：利用map统计电话号码出现次数，代码简洁明了，通过建立字符映射数组和标准形式转换函数，逻辑连贯。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
char cmap[128];
map<string, int> phone;
bool flag;

void print(string s)
{
    for (int i = 0; i < s.size(); ++i)
    {
        if (i == 3) cout << '-';
        cout << s[i];
    }
}

int main()
{
    ios::sync_with_stdio(0);
    for (char c = '0'; c <= '9'; ++c) cmap[c] = c;
    cmap['A'] = cmap['B'] = cmap['C'] = '2';
    cmap['D'] = cmap['E'] = cmap['F'] = '3';
    cmap['G'] = cmap['H'] = cmap['I'] = '4';
    cmap['J'] = cmap['K'] = cmap['L'] = '5';
    cmap['M'] = cmap['N'] = cmap['O'] = '6';
    cmap['P'] = cmap['R'] = cmap['S'] = '7';
    cmap['T'] = cmap['U'] = cmap['V'] = '8';
    cmap['W'] = cmap['X'] = cmap['Y'] = '9';
    cin >> n;
    for (int i = 0; i < n; ++i)
    {
        string num, newnum = "";
        cin >> num;
        for (int i = 0; i < num.size(); ++i)
            if (num[i]!= '-') newnum += cmap[num[i]];
        ++phone[newnum];
    }
    for (map<string, int>::iterator it = phone.begin(); it!= phone.end(); ++it)
    {
        if (it->second > 1)
        {
            print(it->first);
            cout << ' ' << it->second << '\n';
            flag = 1;
        }
    }
    if (!flag) cout << "No duplicates.\n";
    return 0;
}
```
    - **核心思想**：初始化cmap数组建立字符映射关系。读入电话号码，去除连字符并按cmap映射转换为标准形式存入newnum，用map phone统计出现次数。遍历map，输出出现次数大于1的电话号码。

### 最优关键思路或技巧
1. **使用合适数据结构**：如map可方便统计字符串出现次数并自动排序，在处理电话号码重复统计时简洁高效。
2. **字符映射数组**：通过数组存储字母与数字对应关系，快速实现字符转换。
3. **排序与线性扫描**：对处理后的电话号码数组排序，再线性扫描可高效找出重复项。

### 可拓展之处
此类题目属于字符串处理与统计问题，类似套路可应用于其他字符转换、统计重复元素等场景。例如给定一些单词，将其中特定字母组合替换为数字，统计不同数字组合出现次数等。

### 相似知识点洛谷题目
1. [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)：涉及字符串处理和校验码计算。
2. [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)：字符串查找与统计。
3. [P1593 因子和阶乘](https://www.luogu.com.cn/problem/P1593)：涉及数字处理与统计，与本题处理字符并统计有相似思路。

### 个人心得摘录与总结
1. **作者：Loser_King**
    - **心得**：遇到4个细节问题，包括未判0,1；ASCII码和数字搞混；输出格式（用printf的%03d补足位数）；特判无解情况。
    - **总结**：强调处理边界条件和细节的重要性，在字符串处理和输出格式上需谨慎。
2. **作者：Deny_小田**
    - **心得**：做POJ1002原题时花费一周AC，在洛谷上开始得分低，后通过剪枝优化。思路简单但实现困难，遇到读入、字符转换、效率等问题。
    - **总结**：字符串处理题目看似简单，实际实现过程中在输入输出、字符转换逻辑及效率优化上都可能遇到困难，需仔细考虑。 

---
处理用时：98.81秒
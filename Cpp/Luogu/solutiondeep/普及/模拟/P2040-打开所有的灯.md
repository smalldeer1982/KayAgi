# 题目信息

# 打开所有的灯

## 题目背景

pmshz在玩一个益(ruo)智(zhi)的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了pmshz。。。


## 题目描述

这个灯很奇(fan)怪(ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉pmshz要全部打开这些灯。



例如
```
0  1  1
1  0  0
1  0  1
```

点一下最中间的灯【2,2】就变成了
```
0  0  1
0  1  1
1  1  1
```

再点一下左上角的灯【1,1】就变成了

```
1  1  1
1  1  1
1  1  1
```

达成目标。最少需要2步。

输出2即可。


## 说明/提示

这个题水不水，就看你怎么考虑了。。。。


## 样例 #1

### 输入

```
0 1 1
1 0 0
1 0 1```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕打开3x3灯阵所有灯的最少步数问题，采用了暴力枚举、搜索（DFS、BFS）、状态压缩DP、异或方程组等方法。核心思路基于每个灯操作次数的奇偶性等效，即操作偶数次等同于未操作，操作奇数次等同于操作一次。
1. **暴力枚举**：枚举所有灯的开关状态组合，判断是否能打开所有灯并记录最少步数，如作者liuzitong的九层循环枚举和部分作者的二进制枚举。此方法简单直接，但时间复杂度高，为$O(2^9)$。
2. **搜索算法**：
    - **DFS**：通过递归搜索所有可能的操作序列，利用剪枝优化，如判断当前步数是否超过已找到的最优解。像作者Uranus、Wyxrg、小穹等采用此方法，代码相对简单，但数据范围大时易超时。
    - **BFS**：使用队列按层次搜索，可避免DFS可能的深度陷阱，如作者nothingness、「　」等。结合状态压缩可优化空间，如用二进制数表示灯的状态。
3. **状态压缩DP**：将灯的状态压缩为二进制数，利用异或运算更新状态，如作者nothingness的$O(512*9)$算法，效率较高。
4. **异或方程组**：将灯的状态变化转化为异或方程组求解，如作者2016jzy的题解，需一定线性代数知识。

### 所选4星及以上题解
1. **作者：nothingness (4星)**
    - **关键亮点**：采用状态压缩DP，思路清晰，代码简洁高效。通过将9个灯的状态用$2^9 = 512$个数字对应，利用异或变换规律进行状态转移，时间复杂度为$O(512*9)$，相比多数题解更快。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include "bits/stdc++.h"
using namespace std;

int a,x,f[512];
int h,t,q[513];
int upd[10]={0,416,464,200,308,186,89,38,23,11};

int main()
{
    for(int i=8;i>=0;i--)
        scanf("%d",&a),x+=a*(1<<i);
    memset(f,-1,sizeof(f));
    f[x]=0;
    q[++t]=x;
    while(h<t)
    {
        x=q[++h];
        for(int i=1;i<=9;i++)
            if(f[x^upd[i]]==-1)
                q[++t]=x^upd[i],f[x^upd[i]]=f[x]+1;
    }
    printf("%d",f[511]);
    return 0;
}
```
    - **核心思想**：将输入的灯状态转化为二进制数x，用数组f记录每个状态到初始状态的最少步数，通过队列q进行BFS，每次从队列取出一个状态x，尝试与upd数组中的9个值异或得到新状态，若新状态未访问过，则更新其步数并加入队列，直到找到目标状态511。
2. **作者：ljc1301 (4星)**
    - **关键亮点**：通过优化搜索策略，将时间复杂度降低到$O(2^行·行·列)$。先枚举第一行哪些点需要改变，根据上一行灯的状态确定下一行灯是否需要点击，最后判断最后一行灯是否全亮来确定方案是否可行。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int nex[5][2]={{0,0},{1,0},{0,1},{-1,0},{0,-1}}; 
int n=3,num=0x7fffffff,ma[3][3],temp[3][3],ans[3][3];
void reverse(int x,int y) 
{
    int i;
    for(i=0;i<5;i++)
    {
        int tx=x+nex[i][0],ty=y+nex[i][1];
        if(tx<0 || tx>=n || ty<0 || ty>=n) continue;
        temp[tx][ty]^=1; 
    }
}
int pd() 
{
    int i,j,t=0;
    memcpy(temp,ma,sizeof(ma));
    for(i=0;i<n;i++)
        if(ans[0][i])
        {
            reverse(0,i);
            t++;
        }
    for(i=1;i<n;i++)
        for(j=0;j<n;j++)
        {
            ans[i][j]=(temp[i-1][j]==0); 
            if(ans[i][j]) { reverse(i,j); t++; }
        }
    for(i=0;i<n;i++)
        if(temp[n-1][i]==0) 
            return 0x7fffffff;
    return t;
}
void dfs(int s) 
{
    if(s>=n) 
    {
        num=min(num,pd());
        return;
    }
    for(ans[0][s]=0;ans[0][s]<2;ans[0][s]++) 
        dfs(s+1);
}
int main()
{
    int i,j;
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
            scanf("%d",&ma[i][j]);
    dfs(0);
    printf("%d\n",num);
    return 0;
}
```
    - **核心思想**：定义reverse函数模拟点击灯的操作，pd函数用于判断在第一行确定的情况下，后续行能否全部点亮并返回所需点击次数。dfs函数通过递归枚举第一行每个灯的点击状态，调用pd函数更新最少步数。
3. **作者：木木！ (4星)**
    - **关键亮点**：利用状压加速，通过构造线性基证明任意局面间可通过异或相互转化，从而保证必有解。采用BFS搜索，结合状态压缩，代码简洁，运行效率高。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <queue>
#include <cstdio>
using namespace std;

int trans[] = {0640,0720,0310,0464,0272,0131,0046,0027,0013};

int walked[1005]; 

int bfs(int x)
{
    queue<int> q;
    q.push(x);
    walked[x] = 1;
    while(!q.empty())
    {
        register int th = q.front();
        q.pop();
        
        if(th == 511)
        {
            return walked[th];
        }
        
        for(register int i=0; i<9; ++i)
        {
            th ^= trans[i];
            if(!walked[th])
            {
                walked[th] = walked[th^trans[i]]+1; 
                q.push(th);
            }
            th ^= trans[i];
        }
    }
}
int main()
{
    int beg = 0;
    for(register int i=1; i<=3; ++i)
    {
        for(register int j=1; j<=3; j++)
        {
            int tmp;
            scanf("%d",&tmp);
            beg<<=1;
            beg += tmp;
        }
    }
    
    printf("%d",bfs(beg)-1);
}
```
    - **核心思想**：将灯的状态用二进制数表示，通过trans数组存储每个灯操作对应的八进制数（转换为二进制后用于异或操作）。bfs函数中，从初始状态beg开始，通过队列进行BFS，每次取出一个状态th，尝试与trans数组中的值异或得到新状态，若新状态未访问过，则更新步数并加入队列，直到找到目标状态511。

### 最优关键思路或技巧
1. **状态压缩**：利用二进制数表示灯的状态，将复杂的状态表示简化，减少空间复杂度，同时方便进行异或等位运算操作，如在状态转移和判重时。
2. **剪枝优化**：在搜索过程中，通过判断当前步数是否超过已找到的最优解，提前终止不必要的搜索分支，如DFS中的最优剪枝。
3. **利用问题特性**：根据每个灯操作次数的奇偶性等效，确定搜索空间和范围，避免重复无效操作，减少搜索量。

### 可拓展思路
此类问题可拓展到更大规模的灯阵或类似的状态转换问题，如NxN的灯阵，可继续使用状态压缩、搜索优化等方法。类似算法套路包括用位运算优化状态表示和转移、利用问题特性减少搜索空间、通过剪枝提高搜索效率等。

### 洛谷相似题目
1. **P1879 [USACO06NOV]Corn Fields G**：涉及状态压缩DP，与本题用二进制表示状态并进行状态转移的思路类似。
2. **P1171 售货员的难题**：可通过搜索算法解决，需要对搜索过程进行优化，与本题搜索算法及优化思路相似。
3. **P3146 [USACO16OPEN]248 G**：同样是状态合并问题，可采用类似状态压缩和搜索的方法求解。

### 个人心得摘录与总结
1. **作者Uranus**：在使用DFS时，最初用string储存状态，变换函数中三目运算符使用错误导致部分测试点错误，后发现应使用==判断而非=。总结出使用三目运算符时要注意运算符优先级和判断逻辑。
2. **作者封禁用户**：在BFS中因忘记对队列pop()而花费两小时调试，强调了BFS实现中细节的重要性。 

---
处理用时：87.00秒
# 题目信息

# 二进制

## 题目描述

小 Z 最近学会了二进制数，他觉得太小的二进制数太没意思，于是他想对一个巨大二进制数做以下 $4$ 种基础运算：

运算 $1$：将整个二进制数加 $1$。

运算 $2$：将整个二进制数减 $1$。

运算 $3$：将整个二进制数乘 $2$。

运算 $4$：将整个二进制数整除 $2$。

小 Z 很想知道运算后的结果，他只好向你求助。

（Ps：为了简化问题，数据保证 `+`，`-` 操作不会导致最高位的进位与退位）

## 说明/提示


对于 $30\%$ 的数据，$1 \leq n,m \leq 1000$。

对于 $60\%$ 的数据，$1 \leq n,m \leq 10^5$。

对于 $100\%$ 的数据，$1 \leq n,m \leq 5 \times 10^6$。

## 样例 #1

### 输入

```
4 10
1101
*/-*-*-/*/```

### 输出

```
10110```

# AI分析结果

• 综合分析与结论：这些题解主要围绕对巨大二进制数进行加、减、乘、除运算展开。思路上，大多通过数组、字符串、栈、双端队列等数据结构存储二进制数，对于乘除操作，普遍利用二进制特性，乘2在末尾添0，除2去掉末尾位；加减法难点在于进位和借位处理，部分题解采用延迟处理进位借位的方式优化。从质量看，多数题解思路较清晰，但在代码可读性和优化程度上参差不齐。
• 所选的题解：
  - Stay_Hungry（5星）
    - 关键亮点：提出$O(m)$做法，通过在最后一位打延迟标记，利用操作主要针对最后一位的特点，乘时向后推一位0，除时把延迟标记向前推，加减时直接在最后一位操作，最后统一处理延迟标记，优化了时间复杂度。
    - 重点代码核心思想：用数组$f$存储二进制数，通过对最后一位的操作及延迟标记处理，实现高效运算。
    - 核心代码片段：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e6 + 5;
int f[N * 2], n, m, r; char c;
signed main() {
	ios :: sync_with_stdio(false);
	cin >> n >> m; r = n;
	for(int i = 1; i <= n; ++i) cin >> c, f[i] = c - '0';
	while(m --) {
		cin >> c;
		if(c == '*') f[++ r] = 0;  
		else if(c == '+') ++ f[r];  
		else if(c == '-') -- f[r];
		else f[r - 1] += f[r] >> 1, --r;  
	}
	for(int i = r; i > 1; --i) {
		f[i - 1] += f[i] >> 1;
		f[i] = f[i] & 1;
	}  
	for(int i = 1; i <= r; ++i) cout << f[i]; cout << "\n";
	return 0;
}
```
  - redegg（4星）
    - 关键亮点：采用类似线段树懒操作的思想，延迟更新答案。通过两个数组，一个存二进制数，一个存每一位的“懒操作”标记（表示以该位为最低位的串一共加了多少个1），在进行加减乘除操作时，依据规则更新“懒操作”标记，最后统一计算真正的二进制串，优化了运算过程。
    - 重点代码核心思想：利用两个数组分别存储二进制数和懒操作标记，按规则更新标记并最终计算结果。
    - 核心代码片段：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;

int p0,p1;

int a[10000005];
int b[10000005];
char in[6000005];

int main()
{
    scanf("%d%d",&n,&m);
    scanf("%s",in+1);
    int op=0;
    for(int i=1;i<=n;i++)
        a[i]=in[i]-'0';
    scanf("%s",in+1);
    for(int i=1;i<=m;i++)
    {
        if(in[i]=='+')
        {
            b[n]+=1;
        }
        if(in[i]=='-')
        {
            b[n]-=1;
        }
        if(in[i]=='*')
        {
            n++;
            a[n]=0;
            b[n]=0;
        }
        if(in[i]=='/')
        {
            int an=a[n]+b[n];
            if(an<0)
                an-=1;
            b[n-1]+=(an)/2;
            n--;
        }
    }

    for(int i=n;i>=1;i--)
    {
        int an=a[i]+b[i];
        a[i]=((a[i]+b[i])%2+2)%2;
        if(an<0)
            an-=1;
        b[i-1]+=an/2;
    }

    for(int i=1;i<=n;i++)
        printf("%d",a[i]);
    printf("\n");
    return 0;
}
```
  - MZMH（4星）
    - 关键亮点：同样采用延迟处理进退位的方式，在进行加减乘除操作时，先对相应位进行操作，不立即处理进位借位，最后统一从高位到低位处理进位借位情况，简化了操作流程。
    - 重点代码核心思想：用数组存储二进制数，操作时延迟处理进位借位，最后统一计算。
    - 核心代码片段：
```cpp
#include <bits/stdc++.h>
#define File(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout);
using namespace std;
const int MAXN=5e6+10;
int n,m;
int lenc,c[MAXN*2];
char a[MAXN],b[MAXN];
inline int abs(int x) { return x>0?x:-x; }
signed main() {
    // File("two");
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m>>(a+1)>>(b+1);
    lenc=n;
    for(register int i=1;i<=n;i++)
        c[i]=a[i]-'0';
    for(register int i=1;i<=m;i++) {
        if(b[i]=='+')
            c[lenc]++;
        if(b[i]=='-')
            c[lenc]--;
        if(b[i]=='*')
            c[++lenc]=0;
        if(b[i]=='/') {
            if(c[lenc]<0)
                c[lenc-1]-=((abs(c[lenc])+1)>>1);
            else if(c[lenc]>1)
                c[lenc-1]+=(c[lenc]>>1);
            c[lenc]=0,lenc--;
        }
    }
    for(register int i=lenc;i>0;i--)
        if(c[i]<0)
            c[i-1]-=((abs(c[i])+1)>>1),c[i]=(abs(c[i])&1);
        else if(c[i]>1)
            c[i-1]+=(c[i]>>1),c[i]&=1;
    bool flag=0;
    for(register int i=1;i<=lenc;i++)
        if(c[i]!=0||flag)
            putchar(c[i]+'0'),flag=1;
    if(!flag)
        putchar('0');
    return 0;
}
```
• 最优关键思路或技巧：延迟处理进位借位是优化本题算法的关键技巧，通过将进位借位操作推迟到最后统一处理，减少了每次操作时的复杂判断，提高了运算效率。同时，利用二进制数乘除操作的特性，简化乘2和除2的实现。
• 可拓展之处：同类型题可涉及其他进制数的运算，类似算法套路是利用对应进制的运算特性，结合延迟处理思想优化运算过程。
• 洛谷相似题目：
  - P1017 [NOIP1998 提高组] 进制转换，考察不同进制间的转换与运算。
  - P2604 [ZJOI2010] 数字计数，涉及对数字在不同进制下的统计分析。
  - P1601 A+B Problem（高精），高精度加法运算，与本题处理大数运算有相似之处。
• 个人心得摘录与总结：Stay_Hungry提到$O(nm)$暴力做法在面对大数据时会因进位问题导致效率低下，即使优化部分操作也得分不高，从而促使思考$O(m)$的优化做法，这体现了从暴力到优化的思考过程，提醒在解题时要关注数据规模对算法的影响，及时优化算法。 

---
处理用时：62.12秒
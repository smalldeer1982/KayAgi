# 题目信息

# 小Z的矩阵

## 题目描述

小 Z 最近迷上了矩阵，他定义了一个对于一种特殊矩阵的特征函数 $G$。对于 $N\times N$ 的矩阵 $A$，$A$ 的所有元素均为 $0$ 或 $1$，则 $\displaystyle G(A) = \left(\sum_{i = 1}^n\sum_{j = 1}^n A_{i, j}\cdot A_{j, i}\right) \bmod 2$。举一个例子：

$$
\begin{pmatrix}
1 & 1 & 1\\
0 & 1 & 1\\
1 & 0 & 0\\
\end{pmatrix}
$$

对于上面这个 $3\times 3$ 矩阵 $A$，$G(A)=(1\times 1+1\times 0+1\times 1+0\times 1+1\times 1+1\times 0+1\times 1+ 0\times 1+0\times 0) \bmod 2 = 0$。

当然询问一个矩阵的 $G$ 值实在是太简单了。小Z在给出一个 $N\times N$ 矩阵的同时将给你 $Q$ 个操作，操作描述如下：

- 操作 1：形如 `1 x`，表示将第 $x$ 行的元素全部“翻转”。
- 操作 2：形如 `2 x`，表示将第 $x$ 列的元素全部“翻转”。
- 操作 3：形如一个整数`3`，表示询问当前矩阵的特征值 $G$。

“翻转”的定义为将 $1$ 变成 $0$，将 $0$ 变成 $1$。

## 说明/提示

【数据规模】

- 对于 $30\%$ 的数据，$N\le 100$，$Q\le 10^5$。

- 对于 $100\%$ 的数据，$N\le 1,000$，$Q \le 5\times 10^5$。

## 样例 #1

### 输入

```
3 12
1 1 1
0 1 1
1 0 0
3
2 3
3
2 2
2 2
1 3
3
3
1 2
2 1
1 1
3
```

### 输出

```
01001
```

# AI分析结果

• 综合分析与结论：这些题解的核心思路都是发现除矩阵对角线元素外，其他元素对 \( G(A) \) 的计算在模2意义下无影响，每次行或列的翻转操作仅改变对角线上一个元素，从而改变 \( G(A) \) 的值。各题解在思路阐述、代码实现和优化程度上有所不同。
• 所选的题解：
  - **作者：o0数学迷0o (5星)**
    - **关键亮点**：思路清晰简洁，直接点明在mod 2下非对角线元素乘积和为0，仅需关注对角线元素，代码实现高效简洁。
    - **核心代码**：
```cpp
#include <iostream>  
#include <cstdio>  
#include <cmath>  
using namespace std;  
int n,q,g,x;  
int main(){  
    ios::sync_with_stdio(0);  
    g=0;  
    cin>>n>>q;  
    for(int i=0;i<n;++i)  
        for(int j=0;j<n;++j){  
            cin>>x;  
            if(i==j)g^=x;  
        }  
    for(int i=0;i<q;++i){  
        cin>>x;  
        if(x==3)cout<<g;else{  
            cin>>x;  
            g=!g;  
        }  
    }  
    return 0;  
}
```
    - **核心思想**：读入矩阵时，将对角线上元素异或到变量 \( g \) 中，每次操作1或2时，直接翻转 \( g \) 的值，操作3时输出 \( g \) 。利用异或运算处理0和1的翻转，提高效率。
  - **作者：judgejudge (4星)**
    - **关键亮点**：详细证明了仅需关注对角线元素的原因，从数论角度分析奇偶性变化，思路清晰。
    - **核心代码**：
```cpp
#include <iostream>
using namespace std;
typedef long long ll;
ll sum=0;
ll n,m;
int main(){
	register int i,j;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++){
		ll k;
		cin>>k;
	    if(i==j)sum+=k,sum%=2;
	}
	for(i=1;i<=m;i++){
		ll s1,s2;
		cin>>s1;
		if(s1==1||s1==2){
			cin>>s2;
		    sum++,sum%=2;
		}
		else cout<<sum;
	}
	cout<<endl;
	return 0;
}
```
    - **核心思想**：读入矩阵时统计对角线元素和并对2取模存于 \( sum \) ，每次遇到操作1或2， \( sum \) 加1并对2取模，操作3时输出 \( sum \) 。
  - **作者：whc2020 (4星)**
    - **关键亮点**：先给出暴力解法及得分情况，再通过模拟样例推导得出仅需关注对角线元素的结论，过程详细。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n, q, x, a[1001];

int main() {
	scanf ("%d%d", &n, &q);
	for (int i = 1 ; i <= n ; i++) {
		for (int j = 1 ; j <= n ; j++) {
			scanf ("%d", &x);
			if (i == j) {
				a[i] = x;
			}
		}
	}
	for (int i = 1 ; i <= q ; i++) {
		scanf ("%d", &x);
		if (x == 3) {
			int ans = 0;
			for (int j = 1 ; j <= n ; j++) {
				ans += a[j];
			}
			printf ("%d", ans % 2);
		}
		else {
			scanf ("%d", &x);
			a[x] =!a[x];
		}
	}
	return 0;
}
```
    - **核心思想**：读入矩阵时仅记录对角线元素到数组 \( a \) ，操作3时计算数组 \( a \) 元素和并对2取模输出，操作1或2时翻转对应下标的数组元素。
• **最优关键思路或技巧**：通过分析 \( G(A) \) 的计算式在模2意义下的特点，发现非对角线元素乘积和为0，从而将问题简化为仅关注对角线元素及其变化。利用这一特性，避免了对矩阵大规模的操作和重复计算，极大优化了时间复杂度。
• **可拓展之处**：此类题目属于矩阵操作与性质分析类型，类似套路是深入分析给定运算在特定条件下（如模运算）的规律，简化复杂计算。例如对于其他矩阵运算规则，可通过找规律、数学证明等方式简化操作。
• **相似知识点洛谷题目**：
  - P1116 车厢重组，涉及序列操作与逆序对计算，需分析操作对逆序对的影响。
  - P1996 约瑟夫问题，通过模拟或找规律优化对序列元素删除操作的实现。
  - P1089 津津的储蓄计划，根据给定规则对序列数据进行操作和统计，与本题分析操作对结果影响类似。
• **个人心得摘录与总结**：
  - **作者：loi_hjh**：一开始按常规枚举变化只能得30分，TLE，后发现仅主对角线元素对结果有影响，修改时只需关注对角线上元素，不能每次操作3都重新算结果。总结为需深入分析题目规律，避免盲目暴力枚举，关注关键元素对结果的影响。 

---
处理用时：50.51秒
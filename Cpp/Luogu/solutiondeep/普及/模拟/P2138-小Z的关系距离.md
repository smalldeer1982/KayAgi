# 题目信息

# 小Z的关系距离

## 题目描述

小 Z 学习了辩证唯物主义，知道了联系具有普遍性。他看着草稿纸上的字符串，就想挖掘它们之间的关系。

小 Z 认为，对于两个字符串 $a,b$，如果它们各自删除不超过其自身长度一半的字符能够相等，则称 $a,b$ 有距离为 $1$ 的关系。而如果存在另一个字符串 $c$，它和 $a$ 有距离为 $1$ 的关系，和 $b$ 有距离为 $n$ 的关系，则称 $a,b$ 有距离为 $n + 1$ 的关系。

现在小 Z 随机挑选出了两个小写字母字符串 $a,b$，想知道它们之间关系的最小距离，希望你帮帮他。

## 说明/提示

对于 $30\%$ 的数据，$a,b$ 由同一字母构成。

对于 $100\%$ 的数据，$1 \leq |a|,|b| \leq 100$。

## 样例 #1

### 输入

```
abcdef
axcyd```

### 输出

```
1```

## 样例 #2

### 输入

```
a
b```

### 输出

```
2```

## 样例 #3

### 输入

```
abb
baa```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：这些题解思路基本一致，都基于最长公共子序列（LCS）求解。要点是先求两字符串的LCS，若LCS长度大于等于较长字符串长度的一半，关系距离为1；否则，通过不断将较短字符串长度翻倍并增加LCS长度，直至满足条件，操作次数加1即为关系距离。难点在于理解通过翻倍较短字符串来调整LCS长度以满足关系距离条件的逻辑。

所选的题解：
  - 作者：Math_rad_round (5星)
    - 关键亮点：思路清晰，对距离为1的条件等价转换阐述详细，代码简洁明了且注释丰富。
    ```cpp
    // 核心代码实现LCS及计算距离
    int main(){
        cin>>a>>b;
        int n=a.length(),m=b.length();
        if(n<m){
            swap(n,m);swap(a,b);
        }
        if(a==b){//特判相等 
            cout<<"1";return 0;
        }
        int ans=0;
        for(int i=1;i<=n;i++){//求最长公共子序列
            for(int j=1;j<=m;j++){
                f[i][j]=max(f[i-1][j],f[i][j-1]);
                if(a[i-1]==b[j-1])f[i][j]=max(f[i][j],f[i-1][j-1]+1);
                ans=max(f[i][j],ans);
            }
        }
        int cnt=0;
        while(ans*2<n){
            cnt++;ans+=m;m+=m;
        }cnt++;
        cout<<cnt;
        return 0;
    }
    ```
  - 作者：__JiCanDuck__ (4星)
    - 关键亮点：思路整合清晰，代码逻辑明确，对LCS计算和距离调整过程展示完整。
    ```cpp
    int main()
    {
        cin>>aa>>bb;
        n=aa.size(),m=bb.size();//求出两个字符串的长度。
        aa=" "+aa; //在前面加上空格，方便一点。
        bb=" "+bb;
        if(m>n) //如果bb的长度>aa的长度 交换两个。
        {
            swap(aa,bb);
            swap(n,m);//长度交换不要忘记。
        }
        for(int i=1;i<=n;i++) //求LCS，dp[i][j]表示将a的前i个和b的前j个的LCS有多少。
            for(int j=1;j<=m;j++)
            {
                if(aa[i]==bb[j])//这两个相等，lcs++。
                    dp[i][j]=dp[i-1][j-1]+1;  
                else
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);//不是，从两个中选大的。
            }
        lcs=dp[n][m]; //dp[n][m]就是lcs了。
        while(lcs*2<n)
        {
            cnt++;//记录加了一次。
            lcs+=m;//只要加和A相等的b个字符，LCS+=B。
            m+=m;//b长度++。
        }
        cnt++;//距离=n+1。
        cout<<cnt;
        return 0;
    }
    ```
  - 作者：Atserckcn (4星)
    - 关键亮点：对题目简述清晰，思路和代码注释详细，逻辑严谨。
    ```cpp
    int main(){
        ios::sync_with_stdio(false);
        cin.tie(0),cout.tie(0);
        cin>>s1>>s2;
        s1_size=s1.size();
        s2_size=s2.size();
        if(s1==s2)//特判
        {
            printf("1\n");
            return 0;
        }
        if(s1_size<s2_size)//大的匹配小的 
        {
            swap(s1,s2);
            swap(s1_size,s2_size);
        }
        for(int i=1;i<=s1_size;i++)//基础dp，求LCS(s1,s2)
        {
            for(int j=1;j<=s2_size;j++)
            {
                f[i][j]=max(f[i-1][j],f[i][j-1]);
                if(s1[i-1]==s2[j-1])
                    f[i][j]=max(f[i][j],f[i-1][j-1]+1);
                ans=max(ans,f[i][j]);
            }
        }
        while(ans*2<s1_size)
        {
            sum++;
            ans+=s2_size;//目前插了多少进去？
            s2_size=s2_size<<1;//相当于 s2_size-s2_size*2
        }
        sum++;//最后一次不能忘
        printf("%d\n",sum);
        return 0;
    }
    ```

最优关键思路或技巧：将关系距离问题转化为LCS问题，通过对较短字符串翻倍增长来调整LCS长度，巧妙利用LCS性质简化问题求解。

可拓展之处：同类型题可涉及不同字符串操作下的关系判定，类似算法套路是将复杂关系通过子序列等方式转化为可量化计算的指标，再通过动态规划求解。

推荐洛谷题目：
  - P1439【模板】最长公共子序列
  - P1140 相似基因
  - P3942 将军令 

---
处理用时：51.91秒
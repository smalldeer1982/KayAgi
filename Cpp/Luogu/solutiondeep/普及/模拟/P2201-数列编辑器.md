# 题目信息

# 数列编辑器

## 题目描述

小 Z 是一个爱好数学的小学生。最近，他在研究一些关于整数数列的性质。

为了方便他的研究，小Z希望实现一个叫做“Open Continuous Lines Processor”的数列编辑器。

一开始，数列编辑器里没有数字，只有一个光标。这个数列编辑器需要支持五种操作。

- `I x` 在当前光标前插入数字 $x$。
- `D` 删除当前光标前的数字。
- `L` 光标向前移动一个数字。
- `R` 光标向后移动一个数字。
- `Q k` 设光标之前的数列是 $\{a_1,a_2,\cdots,a_n\}$，输出第 $k$ 位及之前最大的前缀和，保证 $k\leqslant n$。

## 说明/提示

### 数据范围

对于 $50\%$ 的数据，$N\leqslant1000$；

对于 $80\%$ 的数据，$N\leqslant10^5$；

对于 $100\%$ 的数据，$N\leqslant10^6$，插入的数字绝对值大小不会超过 $1000$。

题目保证不会在数列编辑器为空时进行 `D` 操作。

## 样例 #1

### 输入

```
8
I 2
I -1
I 1
Q 3
L
D
R
Q 2```

### 输出

```
2
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何实现数列编辑器的五种操作展开，核心在于处理光标移动及前缀和查询。多数题解采用对顶栈（两个栈）的数据结构，将光标前和后的数字分别用栈维护，在常数时间内完成操作。少数题解使用链表，但链表操作相对繁琐。

### 题解分析
1. **MloVtry**：
    - **星级**：4星
    - **关键亮点**：思路清晰，使用栈实现操作，代码简洁明了，详细注释便于理解。
    - **心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#define N 1000010
#include<cstdio>
using namespace std;
int s1[N],s2[N];
int ans[N],S[N];
int top1,top2,n;
int main()
{
    scanf("%d",&n);
    ans[0]=-(1<<30);
    for(int i=1;i<=n;i++)
    {
        char fl;cin>>fl;
        if(fl=='I')
        {
            int x;scanf("%d",&x);
            s1[++top1]=x;
            S[top1]=S[top1-1]+x;
            ans[top1]=max(ans[top1-1],S[top1]);
        }
        if(fl=='D') top1--;
        if(fl=='L') s2[++top2]=s1[top1--];
        if(fl=='R')
        {
            int x=s2[top2--];
            s1[++top1]=x;
            S[top1]=S[top1-1]+x;
            ans[top1]=max(ans[top1-1],S[top1]);
        }
        if(fl=='Q')
        {
            int x;scanf("%d",&x);
            printf("%d\n",ans[x]);
        }
    }
    return 0;
}
```
    - **核心思想**：用s1栈存光标前数字，s2栈存光标后数字。I操作将数字压入s1并更新前缀和S及最大前缀和ans；D操作弹出s1栈顶；L操作将s1栈顶移到s2；R操作将s2栈顶移到s1并更新S和ans；Q操作输出ans中对应值。
2. **tobie**：
    - **星级**：4星
    - **关键亮点**：详细阐述栈的使用思路，对前缀和及最大前缀和维护讲解清晰，代码注释详细。
    - **心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=1000009;
int stack1[N][3],top1;
int stack2[N],top2;
char ch[3];
int x;
int n;
void ins(int qwq)
{
    top1++;
    if(top1==1)
    {
        stack1[top1][0]=stack1[top1][1]=stack1[top1][2]=qwq;
    }
    else
    {
        stack1[top1][0]=qwq;
        stack1[top1][1]=qwq+stack1[top1-1][1];
        stack1[top1][2]=max(stack1[top1][1],stack1[top1-1][2]);
    }
}
int main()
{
    scanf("%d",&n);
    while(n--)
    {
        scanf("%s",ch);
        if(ch[0]=='I')
        {
            scanf("%d",&x);
            ins(x);
        }
        if(ch[0]=='D') top1--;
        if(ch[0]=='L')
        {
            int p=stack1[top1][0];
            top1--;
            stack2[++top2]=p;
        }
        if(ch[0]=='R')
        {
            int p=stack2[top2];
            top2--;
            ins(p);
        }
        if(ch[0]=='Q')
        {
            scanf("%d",&x);
            printf("%d\n",stack1[x][2]);
        }
    }
    return 0;
}
```
    - **核心思想**：stack1存光标前数字及相关信息，stack2存光标后数字。ins函数插入数字并维护前缀和及最大前缀和；I操作调用ins；D操作弹出stack1栈顶；L操作将stack1栈顶移到stack2；R操作将stack2栈顶移到stack1并调用ins；Q操作输出stack1中对应最大前缀和。
3. **cyhyyds**：
    - **星级**：4星
    - **关键亮点**：思路表述清晰，对每个操作分类讨论，代码模块化，可读性好，且考虑栈空情况。
    - **心得**：无
    - **核心代码**：
```cpp
const int N = 1500007;
const int inf = 0x3f3f3f3f;

int st1[N], st2[N], top1 = 0, top2 = 0, n;

int pre[N], mxpre[N];

inline void add (int k) {
    st1[++ top1] = k;
    pre[top1] = pre[top1 - 1] + k;
    mxpre[top1] = max (pre[top1], mxpre[top1 - 1]);
}

inline void del () {
    if (!top1) {
        return ;
    } 
    else {
        top1 --;
    }
}

inline void move_L () {
    if (!top1) {
        return ;
    }
    else {
        st2[++ top2] = st1[top1];
        top1 --;
    }
}

inline void move_R () {
    if (!top2) {
        return ;
    }
    else {
        add (st2[top2]);
        top2 --;
    }
}

inline int query_mx (int k) {
    return mxpre[k];
}

int main() {
    cin >> n;
    mxpre[0] = -inf;
    for (int i = 1, k; i <= n; i ++) {
        char c;
        cin >> c;
        if (c == 'I') {
            cin >> k;
            add (k);
        }
        else if (c == 'L') {
            move_L (); 
        }
        else if (c == 'R') {
            move_R ();
        }
        else if (c == 'D') {
            del ();
        }
        else if (c == 'Q') {
            cin >> k;
            cout << query_mx (k) << endl;
        }
    }
    return 0;
} 
```
    - **核心思想**：st1栈存光标前数字，st2栈存光标后数字。add函数插入数字并维护前缀和pre及最大前缀和mxpre；del函数删除st1栈顶；move_L和move_R函数实现光标移动；query_mx函数查询最大前缀和。

### 最优关键思路或技巧
使用对顶栈数据结构，将光标前后数字分别存储，利用栈的性质高效实现插入、删除和光标移动操作。同时，在插入数字时实时维护前缀和及最大前缀和，使查询操作能在常数时间内完成。

### 可拓展思路
此类题目可拓展到其他涉及序列操作且需要维护特定信息（如前缀和、最值等）的场景，类似算法套路是根据操作特点选择合适的数据结构（如栈、链表、树状数组等），并在操作过程中实时维护所需信息。

### 相似知识点洛谷题目
1. [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)：考察对数据结构的运用，类似本题通过特定数据结构实现序列操作。
2. [P1160 队列安排](https://www.luogu.com.cn/problem/P1160)：需要对队列进行插入、删除等操作，与本题操作序列类似。
3. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)：涉及区间操作和维护信息，与本题维护前缀和思想有相通之处。

### 个人心得摘录与总结
无。 

---
处理用时：58.78秒
# 题目信息

# Blink

## 题目描述

Farmer John 对于农场里昏暗的灯光很不满，于是他刚刚装上一个装饰精美的新吊灯。

这个吊灯由 $N(3 \le N \le 16)$ 个灯组成，并排成一个**圆圈**。

奶牛们对于这个新的发光装置很有兴趣。他们喜欢玩这样的一个游戏：

在在时刻 $T$ 时，对于每一盏灯 $i$，如果在时刻 $T-1$ 时，$i$ 左边的灯 $(1<i\le n$ 时为 $i-1$，$i=1$ 时，为 $n)$ 是开的，那么**改变第 $i$ 盏灯的状态**，否则不做操作。

他们会在 $B(1 \le B \le 10^{15})$ 个单位的时间里一直进行这样的操作。

**请注意，$B$ 可能会超过一般的 $32$ 位整数的范围。**

现在已知每一个灯的初始状态，请计算出在经过 $B$ 个单位的时间后，每一个灯的状态。

## 说明/提示

样例输出解释：

下面是样例输出的模拟

```cpp
Time T=0: 1 0 0 0 0
Time T=1: 1 1 0 0 0
Time T=2: 1 0 1 0 0
Time T=3: 1 1 1 1 0
Time T=4: 1 0 0 0 1
Time T=5: 0 1 0 0 1
Time T=6: 1 1 1 0 1

## 样例 #1

### 输入

```
5 6

1

0

0

0

0```

### 输出

```
1

1

1

0

1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕解决因 $B$ 数据范围大导致直接模拟会超时的问题，提出了不同的解法：
- **状态压缩 + 倍增法**：将灯的状态压缩成数，利用倍增思想，通过预处理不同时间步长下状态的变化，快速得到最终状态。时间复杂度 $O(2^Nlog B)$。
- **矩阵快速幂**：根据灯状态变化规律构造递推矩阵，通过矩阵快速幂加速递推过程，得到最终状态。
- **寻找循环节**：由于灯的状态组合有限（最多 $2^{16}$ 种），在模拟过程中寻找循环节，对超出循环节的时间部分取余，得到最终状态。

综合质量（思路清晰度、代码可读性、优化程度等）来看，“状态压缩 + 倍增法”和“矩阵快速幂”相对更优，在处理大数据时理论上效率更高且代码结构较清晰；而找循环节的方法虽然思路直接，但部分代码实现相对繁琐，且时间复杂度在最坏情况下可能较高。

### 所选的题解
#### 作者：Mr_Li (赞：14)
 - **星级**：5 星
 - **关键亮点**：巧妙利用状态压缩和倍增算法，大大降低时间复杂度，代码简洁高效。
 - **核心代码**：
```cpp
for (i=0;i<1<<n;i++)
    for (j=0;j<n;j++)
        f[0][i]+=((i&1<<(j+1)%n)>0^(i&1<<j)>0)*(1<<j);
for (i=1;i<=50;i++)
    for (j=0;j<1<<n;j++)
        f[i][j]=f[i-1][f[i-1][j]];
for (i=1;i<=n;i++)
{
    cin>>light;
    compress=compress<<1|light;
}
for (i=50;i>=0;i--)
    if (1LL<<i<=b)
    {
        b-=1LL<<i;
        compress=f[i][compress];
    }
for (i=n-1;i>=0;i--)
    cout<<((compress&1<<i)>0)<<endl;
```
 - **核心实现思想**：首先预处理 $f[0][i]$，即经过 1 个单位时间，状态 $i$ 会变成的状态。然后通过倍增的状态转移方程 $f[i][j]=f[i - 1][f[i - 1][j]]$ 计算不同时间步长下状态的变化。读入初始状态并压缩后，利用倍增思想快速得到最终状态并输出。

#### 作者：Mo默Sh笙 (赞：4)
 - **星级**：4 星
 - **关键亮点**：利用矩阵快速幂解决问题，思路新颖，代码结构清晰，注释详细。
 - **核心代码**：
```cpp
MS operator *(const MS &a,const MS &b)
{
    MS c;
    c.n=a.n;
    c.m=b.m;
    for(int i=1;i<=a.n;i++)
        for(int j=1;j<=b.m;j++)
            c.c[i][j]=0;
    for(int i=1;i<=a.n;i++)
        for(int j=1;j<=b.m;j++)
            for(int k=1;k<=a.m;k++)
                c.c[i][j]=(c.c[i][j]+a.c[i][k]*b.c[k][j]%p)%p;
    return c;
}
MS fpow(MS a,int k)
{
    MS e;
    e.n=n;
    e.m=m;
    for(int i=1;i<=n;i++) e.c[i][1]=s[n-i+1];
    while(k>0)
    {
        if(k&1) e=a*e;
        a=a*a;
        k>>=1;
    }
    return e;
}
MS init()
{
    MS a;
    a.n=n;
    a.m=n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            a.c[i][j]=0;
    for(int i=1;i<=n;i++)
    {
        a.c[i][i]=1;
        a.c[i][i+1]=1;
    }
    a.c[n][1]=1;
    return a;
}
```
 - **核心实现思想**：根据灯状态变化规律构造 $N\times N$ 的递推矩阵，通过矩阵乘法和矩阵快速幂的函数实现矩阵快速幂算法，从而快速得到经过 $B$ 个单位时间后的灯的状态。

### 最优关键思路或技巧
1. **状态压缩**：利用二进制思想将灯的状态压缩成一个数，减少空间复杂度，同时便于在倍增算法中进行状态转移。
2. **倍增思想**：通过预处理不同时间步长下状态的变化，避免了逐个时间单位模拟，大大提高了效率。
3. **矩阵快速幂**：将灯状态变化抽象为矩阵乘法，利用矩阵快速幂加速递推过程，适用于具有线性递推关系的问题。

### 可拓展之处
同类型题或类似算法套路：
 - 对于具有周期性或递推关系的问题，可考虑寻找循环节或利用矩阵快速幂加速递推。例如一些涉及状态转移且数据规模较大的题目。
 - 当状态数量有限且时间步长较大时，状态压缩和倍增的方法也可能适用。

### 相似知识点洛谷题目
1. **P1962 斐波那契数列**：考察矩阵快速幂求斐波那契数列第 $n$ 项，与本题矩阵快速幂思路类似。
2. **P1306 斐波那契公约数**：同样可通过矩阵快速幂结合斐波那契数列性质求解，涉及到状态转移和矩阵运算。
3. **P3390 【模板】矩阵快速幂**：纯模板题，用于熟悉矩阵快速幂的实现，与本题中矩阵快速幂的应用直接相关。

### 个人心得摘录与总结
 - **作者：jiang_cheng**：提到本题 $b$ 数据大，肯定有循环节，通过压缩表示并找循环节解题。总结出面对大数据范围且状态有限的题目，可尝试寻找循环节优化算法。
 - **作者：66666a**：强调循环节并不是从初始状态开始的，在找循环节时要注意这个陷阱。提醒在处理循环节相关问题时，不能默认循环节从起始状态开始，需全面考虑各种情况。 

---
处理用时：45.96秒
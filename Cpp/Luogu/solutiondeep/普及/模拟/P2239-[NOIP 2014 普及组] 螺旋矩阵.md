# 题目信息

# [NOIP 2014 普及组] 螺旋矩阵

## 题目背景

NOIP2014 普及组 T3

## 题目描述

一个 $n$ 行 $ n$ 列的螺旋矩阵可由如下方法生成：


从矩阵的左上角（第 $1$ 行第 $1$ 列）出发，初始时向右移动；如果前方是未曾经过的格子，则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中依次填入 $1, 2, 3, \dots, n^2$，便构成了一个螺旋矩阵。


下图是一个 $n = 4$ 时的螺旋矩阵。

$$\begin{pmatrix}
 1 &    2  &   3   &  4 \\
12 &   13  &  14   &  5 \\
11 &   16  &  15   &  6 \\
10 &    9  &   8   &  7 \\
\end{pmatrix}$$

现给出矩阵大小 $n$ 以及 $i$ 和 $j$，请你求出该矩阵中第 $i$ 行第 $j$ 列的数是多少。


## 说明/提示

【数据说明】

对于 $50\%$ 的数据，$1 \leqslant n \leqslant 100$;

对于 $100\%$ 的数据，$1 \leqslant n \leqslant 30,000,1 \leqslant i \leqslant n,1 \leqslant j \leqslant n$。


## 样例 #1

### 输入

```
4 2 3```

### 输出

```
14```

# AI分析结果

• **综合分析与结论**：这些题解主要围绕螺旋矩阵规律推导来求解指定位置的值。多数题解通过找规律，利用递归或公式计算，部分采用模拟结合优化的方式。思路上，有的从矩阵各边规律入手，有的按圈分析。算法要点包括确定位置所在圈或层，计算前序圈/层数字数量并结合当前位置规律求解。难点在于发现并总结出通用规律。
 - **暴力构建矩阵**：通过循环按螺旋顺序填充矩阵，再获取指定位置值，但仅能通过部分数据，时间复杂度高，如作者Anguei最初尝试的方法。
 - **找规律递归**：分析矩阵各边数字规律，将矩阵分层，通过递归确定目标位置所在层并计算值，代表作者有Anguei、Actinoi、GSQ0829、YWT130508、hjz_0821_、chrispang。
 - **按圈分析**：确定位置所在圈，计算前序圈数字总数，再在当前圈找值，如作者WsW_、qhr2023、HHC883。
 - **推导公式**：根据位置与圈数关系推导公式直接计算，如作者CaiZi。
 - **小学问题类比**：作者Yusani_huh将螺旋矩阵与小学数字排列问题类比，通过找规律差值计算，但过程复杂。
• **所选的题解**
  - **作者Anguei（5星）**
    - **关键亮点**：思路清晰，先尝试暴力后通过观察矩阵各边规律推导公式，再利用递归实现，代码简洁明了，可读性高。
    - **个人心得**：暴力法只能得部分分，通过画图观察规律成功解决问题。
    - **核心代码**：
```cpp
int work(int n, int i, int j) {
    if (i == 1)
    	return j;
    if (j == n)
    	return n + i - 1;
    if (i == n)
    	return 3 * n - 2 - j + 1;
    if (j == 1)
    	return 4 * n - 4 - i + 2;
    return work(n - 2, i - 1, j - 1) + 4 * (n - 1);
}
```
实现思想：根据矩阵各边规律直接返回值，若位置不在边界则递归到内层矩阵并加上当前层左上角数字。
  - **作者Actinoi（4星）**
    - **关键亮点**：通过将大矩阵分层，研究小矩阵内坐标查找规律，利用递归实现，思路较清晰，代码简洁。
    - **核心代码**：
```cpp
int find(int n, int i, int j) {
    if (i == 1)
        return j;
    if (i == n)
        return (n - 1) * 3 - j + 2;
    if (j == 1)
        return (n - 1) * 4 - i + 2;
    if (j == n)
        return n + i - 1;
    return find(n - 2, i - 1, j - 1) + (n - 1) * 4;
}
```
实现思想：与Anguei类似，根据小矩阵内不同位置规律返回值，不在边界则递归并累加当前层左上角数字。
  - **作者CaiZi（4星）**
    - **关键亮点**：通过曼哈顿距离确定圈数，根据圈数和位置推导公式直接计算答案，时间复杂度为O(1)，优化程度高。
    - **核心代码**：
```cpp
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>i>>j;
	x=min({i-1,j-1,n-i,n-j});
	if(i==x+1||j==n-x){
		cout<<4*x*n-4*x*x-2*x+i+j-1;
	}
	else{
		cout<<4*x*n-4*x*x-6*x+4*n-i-j-1;
	}
	return 0;
}
```
实现思想：先计算位置所在圈数，根据位置在圈上的不同情况代入对应公式计算答案。
• **最优关键思路或技巧**：找规律是解决本题关键，通过观察螺旋矩阵各边、各圈数字规律，利用递归或推导公式来优化计算，避免暴力模拟的高时间复杂度。如按圈分析时，计算前序圈数字总数结合当前圈位置规律；推导公式时，利用位置与圈数关系直接得出结果。
• **可拓展之处**：同类型题可涉及不同形状矩阵（如三角形矩阵）按特定顺序填充数字后求指定位置值，或给定数字求其在矩阵中的位置。类似算法套路是对复杂矩阵规律进行观察、归纳和总结，利用分层、分块等方式简化问题。
• **推荐题目**
  - **P1990 覆盖墙壁**：涉及递推规律，与螺旋矩阵找规律思路类似。
  - **P1028 数的计算**：通过找规律确定递推关系求解，锻炼找规律能力。
  - **P1255 数楼梯**：同样是通过找规律解决递推问题，与螺旋矩阵通过规律优化求解思想相符。 

---
处理用时：51.38秒
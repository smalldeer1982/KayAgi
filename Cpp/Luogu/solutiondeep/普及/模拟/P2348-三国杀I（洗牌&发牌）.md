# 题目信息

# 三国杀I（洗牌&发牌）

## 题目描述

一场三国杀一共有 $n$ 个玩家，每人需要 $4$ 张牌。牌库共 $k$ 张牌，需洗牌后再发。每张牌有以下 $3$ 个属性：

一、牌的类型:

1. 基础：杀（$\texttt{K}$）、闪（$\texttt{M}$）、桃（$\texttt{P}$）、酒（$\texttt{W}$）。

2. 非延时锦囊：决斗（$\texttt{B}$）、万箭（$\texttt{A}$）、南蛮（$\texttt{S}$）、五谷（$\texttt{C}$）、桃园（$\texttt{G}$）、拆（$\texttt{D}$）、顺（$\texttt{U}$）、铁索（$\texttt{T}$）、无懈（$\texttt{N}$）、火攻（$\texttt{F}$）、无中（$\texttt{E}$）。

3. 延时锦囊：兵（$\texttt{I}$）、乐（$\texttt{K}$）、闪电（$\texttt{L}$）。

4. 马（$\texttt{+,-}$）

5. 武器：连弩（$\texttt{LN}$）、青釭（$\texttt{QG}$）、古锭（$\texttt{GD}$）、寒冰（$\texttt{HB}$）、雌雄（$\texttt{CX}$）、吴六（$\texttt{WL}$）、青龙（$\texttt{QL}$）、丈八（$\texttt{ZB}$）、贯石（$\texttt{GS}$）、方天（$\texttt{FT}$）、羽扇（$\texttt{YS}$）、麒麟（$\texttt{LG}$）。

6. 防具：仁王（$\texttt{RW}$）、八阵（$\texttt{BZ}$）、藤甲（$\texttt{TJ}$）、狮子（$\texttt{SZ}$）

二、花色：只有可能是 $\texttt{C,H,S,D}$ 中的一个。

三、点数：只有可能是 $\texttt{A,2,3,4,5,6,7,8,9,T,J,Q,K}$（T代表10，从小到大）中的一个。

洗牌方式的介绍：一次洗牌过后，从上到下依次是：$\left\lfloor\dfrac{k}{2}\right\rfloor+1,1,\left\lfloor\dfrac{k}{2}\right\rfloor+2,2,\left\lfloor\dfrac{k}{2}\right\rfloor+3,3, ... ,k,\left\lfloor\dfrac{k}{2}\right\rfloor$（可以有奇数张牌，最后一张牌直接忽略掉）。

发牌方式的介绍：从第 $1$ 张牌开始，从上到下依次将第 $i$ 张牌给第 $[(i-1)\mod n+1]$ 号玩家。

已知一共洗了 $m$ 次牌，现在问你第 $p$ 位玩家发到的 $4$ 张牌有哪些。





## 说明/提示


对于 $100\%$ 的数据，满足 $1\leqslant p\leqslant n\leqslant 1000,1\leqslant k\leqslant 100000,1\leqslant m\leqslant 80$。

## 样例 #1

### 输入

```
2 10 1 1

C2 K

H5 B

DT K

SA M

HQ P

D4 K

C6 P

H9 M

ST B

SK C

```

### 输出

```
D4 K

C6 P

H9 M

ST B

```

## 样例 #2

### 输入

```
2 7 1 1

C2 K

H5 B

DT K

SA M

HQ P

SK C

C6 P

```

### 输出

```
Error:cards not enough

```

# AI分析结果

• 综合分析与结论：这些题解均采用模拟的思路解决问题，先判断牌数是否足够，再按照题目给定的洗牌和发牌方式进行模拟操作。算法要点在于准确实现洗牌和发牌逻辑，难点主要是理解并正确实现洗牌方式。各题解在代码实现细节上有所不同，如使用的数据结构、循环控制方式等，部分题解还考虑了输入输出格式处理及优化。

所选的题解：
 - 作者：DrunkXT (赞：18)  星级：4星
    - 关键亮点：思路清晰，代码注释详细，用string类型存储牌的属性，避免了空格回车的麻烦，对洗牌和发牌过程的模拟步骤明确。
    - 个人心得：无
    - 核心代码片段：
```cpp
while(m--)
{//洗牌方式：k/2+1,1,k/2+2,2,k/2+3,3,...,k,k/2 
    int j=1;
    for(int i=1;i<=k-1;i+=2,j++)
    {
        b[i]=a[k/2+j];
        b[i+1]=a[j];
    }
    for(int i=1;i<=k;i++)
        a[i]=b[i];
}
int j=1;
//发牌方式：从第1张牌开始，第i张牌给第(i-1)%n+1个人 
for(int i=1;i<=k&&j<5;i++)
    if((i-1)%n+1==p)
    {
        ans[j]=a[i];
        j++;
    }
```
核心实现思想：通过双重循环实现洗牌过程，将原数组a按照洗牌规则存入数组b，再将b覆盖回a；通过遍历洗好的牌数组a，根据发牌规则将牌存入对应玩家的数组ans中。

 - 作者：拂修梦晓 (赞：4)  星级：4星
    - 关键亮点：对洗牌方式理解准确，代码简洁明了，在代码注释中强调了容易误解的洗牌方式，避免踩坑。
    - 个人心得：开始没看懂洗牌方式，按错误理解只得了20分，强调正确理解洗牌方式的重要性。
    - 核心代码片段：
```cpp
while(m--)
{
    for(int x=1;x<=k;x+=2)
    {
        gd[x]=pai[k/2+x/2+1];
        gd[x+1]=pai[x/2+1];
    }
    for(int x=1;x<=k;x++) pai[x]=gd[x];
}
int y=1;
for(int x=1;y<=4;x++)
{
    if(x%n==p)
    {
        cout<<pai[x].a<<" "<<pai[x].b<<endl;
        y++;
    }
}
```
核心实现思想：利用循环按洗牌规则将牌从pai数组洗到gd数组，再将gd数组覆盖回pai数组；通过遍历pai数组，依据发牌规则输出对应玩家的牌。

 - 作者：BaCO3 (赞：2)  星级：4星
    - 关键亮点：对洗牌和发牌方式的理解独特且清晰，将洗牌理解为两堆牌交替拿取，发牌直接根据规律确定第p个人拿到的牌的位置，代码简洁高效。
    - 个人心得：无
    - 核心代码片段：
```cpp
for(int i=1;i<=m;i++){ 
    for(int j=1;j<k;j+=2){
        b[j]=a[k/2+j/2+1];
        b[j+1]=a[j/2+1];
    }
    for(int j=1;j<=k;j++){
        a[j]=b[j];
    }
}
//输出
cout<<a[p].cn<<" "<<a[p].t<<endl;
cout<<a[p+n].cn<<" "<<a[p+n].t<<endl;
cout<<a[p+2*n].cn<<" "<<a[p+2*n].t<<endl;
cout<<a[p+3*n].cn<<" "<<a[p+3*n].t<<endl;
```
核心实现思想：通过循环实现洗牌过程，将原数组a按规则洗入数组b再覆盖回a；直接按发牌规律输出第p个人的四张牌。

最优关键思路或技巧：在实现洗牌和发牌逻辑时，通过合理的循环控制和数组操作准确模拟过程。如在洗牌时，利用循环变量的步长控制和数组下标的计算，清晰地实现牌的重新排列；发牌时，依据给定公式或规律直接确定目标玩家牌的位置，简化操作。

可拓展之处：同类型题可涉及不同的洗牌和发牌规则，或增加牌的属性及相关操作的模拟。类似算法套路是对于给定明确操作规则的场景，通过模拟步骤来解决问题，关键是准确理解规则并转化为代码实现。

推荐题目：
 - [P1032 字串变换](https://www.luogu.com.cn/problem/P1032)：涉及字符串变换规则的模拟。
 - [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：通过模拟填充规则解决图形填色问题。
 - [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)：模拟马在棋盘上的移动遍历。

个人心得摘录与总结：拂修梦晓提到开始因误解洗牌方式只得了20分，强调了准确理解题意尤其是复杂规则描述的重要性，做题时需仔细研读题目给定的操作方式，避免因理解偏差导致错误。 

---
处理用时：43.57秒
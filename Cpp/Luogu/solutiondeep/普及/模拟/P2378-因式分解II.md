# 题目信息

# 因式分解II

## 题目描述

小玉上了初中，开始学因式分解。可是她怎么都解不出来。所以她求你帮忙。

她给你看了她的作业，就是因式分解。由于刚开始学，就降低了难度。

我们假设作业里面的代数只有一个x。最高指数是2，且最高指数的系数是1。当x前的系数是1时，1省去……（反正作业题目符合我们的日常写法）

我们帮她解决下这个“简单”的问题吧！虽然听起来挺容易，但是编程需要考虑很多情况呢！

保证作业答案的数字都是整数。


// 这跟神器有什么关系么？神说，帮助他人，积累善行，神器自然出现。哈哈哈哈好牵强的解释~

//为了帮助在5月月赛ac这道题目，kkksc03偷偷地进行以下的温馨提示：

//数据可能会比较刁钻，请考虑到各种情况，包括只有输入一项的情况、中间过程会不会超maxlongint的情况等。

//lzn：喂！你这是透题行为，是要上法庭的！

//absi2011:样例输出里的"//"及以后字符只是注解,并不要你输出

/\*
absi2011:输入规范好不和谐啊...

我只是来补充一下...

如果x或者常数项的系数是0 整个省略掉

哦,x的系数是-1的话 也会把1省去...

保证输入的那玩意儿可以分解....而且分解出来都是整数...

\*/

// 原作: 2022.7.24 没想到初中时候贡的题已经~~坑害了~~这么多人ac了.  现在已经大二，时过境迁，已经完全不会了哈哈哈

## 说明/提示

x次数不高于2次，项数不高于3项，降幂排列。


## 样例 #1

### 输入

```
x^2-4```

### 输出

```
(x+2)(x-2)

//而不能写成(x-2)(x+2)或者(x+2)(x+-2)```

## 样例 #2

### 输入

```
x^2+5x+4```

### 输出

```
(x+4)(x+1)

//不能写成(x+1)(x+4)```

## 样例 #3

### 输入

```
x^2-2x+1```

### 输出

```
(x-1)^2```

## 样例 #4

### 输入

```
x^2+x```

### 输出

```
(x+1)x

//反过来是不可以的。```

# AI分析结果

• 综合分析与结论：这些题解主要围绕对形如$x^2 + bx + c$的多项式进行因式分解展开。思路上，多数题解采用求根公式法，通过从输入字符串中提取系数$b$和$c$，代入求根公式算出根，再按要求格式输出因式分解结果；也有题解采用暴力搜索法，分多种情况讨论。算法要点在于系数提取和结果输出格式处理。难点主要是输入字符串处理，需考虑多种特殊情况，如系数为0、±1等，以及输出格式的严格要求。
- **作者：伟大的王夫子 (5星)**
  - **关键亮点**：思路清晰，代码简洁。先读入多项式，利用字符串操作提取系数，再套求根公式算出根，最后按格式输出。
  - **个人心得**：调试花费了一定时间。
  - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
string a, c;
double b[10], x1, x2;
void work(double x) {
    if (x == 0) cout << "x";
    else {
        cout << "(x";
        if (x > 0) cout << "+" << x << ")";
        else cout << "-" << -x << ")";
    }
}
int main() {
    cin >> a;
    b[1] = 1;
    a.erase(0, 3);
    int pos = a.find('x');
    if (pos == -1) b[2] = 0;
    else {
        c = a.substr(0, pos + 1);
        c.erase(--c.end());
        if (c == "+") b[2] = 1;
        else if (c == "-") b[2] = -1;
        else b[2] = atof(c.c_str());
    }
    if (pos == -1) b[3] = atof(a.c_str());
    else if (pos == a.size()) b[3] = 0;
    else c = a.substr(pos + 1), b[3] = atof(c.c_str());
    x2 = (-b[2] + sqrt(b[2] * b[2] - 4 * b[1] * b[3])) / b[1] / 2;
    x1 = (-b[2] - sqrt(b[2] * b[2] - 4 * b[1] * b[3])) / b[1] / 2;
    if (x1 == x2) work(-x1), cout << "^2";
    else work(-x1), work(-x2);
}
```
  - **核心思想**：从字符串提取二次项、一次项、常数项系数，代入求根公式得到两根，按要求格式输出因式。
- **作者：jacky567 (3星)**
  - **关键亮点**：采用暴力搜索法，分七种情况分别处理，思路直接。
  - **核心代码**：（代码略，篇幅较长）
  - **核心思想**：根据一次项和常数项系数的正负分情况，暴力枚举所有可能的因式组合。
- **作者：TsReaper (4星)**
  - **关键亮点**：简洁概括解题要点，指出若没有二次项直接输出原式，有则算系数用求根公式求解并注意输出相反数。
  - **核心代码**：（无具体代码，思路描述清晰）
  - **核心思想**：判断有无二次项，有则提取系数，用求根公式计算并按规则输出。

最优关键思路或技巧：在处理字符串提取系数时，可利用字符串查找函数（如`find`）和字符串截取函数（如`substr`），结合条件判断处理系数为特殊值的情况。输出时按根的情况（相等或不等）以及根的正负严格按格式输出。

可拓展之处：同类型题可涉及更高次多项式因式分解，类似算法套路是利用数学定理（如求根公式、因式定理等）结合字符串处理技巧。

推荐洛谷题目：
- P1028 [NOIP2001 普及组] 数的计算
- P1036 [NOIP2002 普及组] 选数
- P1164 小A点菜

个人心得摘录与总结：伟大的王夫子提到调试花费时间，说明该题细节多，字符串处理和公式计算容易出错，需细心调试。 

---
处理用时：60.47秒
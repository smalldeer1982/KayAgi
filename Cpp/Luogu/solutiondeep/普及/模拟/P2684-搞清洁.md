# 题目信息

# 搞清洁

## 题目描述

FJ准备分配它的N只奶牛(1 <= N <= 25,000) 做清洁工作，他把一天分成T(1 <= T <= 1,000,000)个时间段，他希望每一个时间段都有奶牛在清洁，但搞清洁的奶牛数越少越好。


## 说明/提示

样例解释：

有3头奶牛，第1头能工作的时间段是1至7，即从时间1开始工作，时间7结束（时间7也在工作的），第2头是3-6，第3头是8-10，则只需要第1头和第3头奶牛就能使每一个时间都有奶牛工作。


## 样例 #1

### 输入

```
3 10
1 7
3 6
8 10
```

### 输出

```
2

```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何用最少的奶牛工作时间段覆盖一整天的清洁工作展开，涉及贪心算法和线段树两种主要思路。贪心算法通过对奶牛工作时间段排序，选择能覆盖更多时间段的奶牛，时间复杂度多为 $O(n \log n)$；线段树思路则利用线段树维护区间最小值进行动态规划，复杂度为 $O(n \log T)$。

### 所选题解
- **作者：PTC06（4星）**
    - **关键亮点**：思路清晰，从样例出发逐步解释，代码简洁易懂，适合初学者理解。
    - **个人心得**：初次提交时因数组定义过小导致RE，提醒注意数组范围要根据题目数据范围设定。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
int n,m,i,t,t1,a[1000000],temp,start,end,sum;
int main()
{
    cin>>n>>m;
    for (i=1;i<=n;i++)
    {
        cin>>t>>t1;
        if (a[t]<t1) a[t]=t1;
    }
    while (temp<m)
    {
        for (i=start+1;i<=end+1;i++)
        {
            if (temp<a[i]) temp=a[i];
        }
        if (temp<end+1)
        {
            cout<<-1;
            return 0;
        }
        start=end;
        end=temp;
        sum++;
    }
    cout<<sum;
    return 0;
}
```
    - **核心实现思想**：用数组 `a` 标记每头牛的工作时间段，通过循环寻找结束时间最晚的牛，不断更新 `start` 和 `end`，直到覆盖所有时间段。

- **作者：木木！（4星）**
    - **关键亮点**：贪心思路明确，对简单贪心可能出现的问题进行分析并给出解决方案，复杂度合理。
    - **核心代码**：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

struct seg
{
    int l;
    int r;
};

seg si[25005];

bool cmp(seg a,seg b)
{
    return a.l<b.l;
}

int main()
{
    int n,t;
    scanf("%d%d",&n,&t);
    for(int i=1; i<=n; ++i)
    {
        scanf("%d%d",&si[i].l,&si[i].r);
    }
    sort(si+1,si+1+n,cmp);
    si[n+1].l = t+1;
    int ans = 0;
    int lr = 1;
    int mnlr = 0;
    for(int i=1; i<=n+1; ++i)
    {
        if(si[i].l > lr)
        {
            lr = mnlr+1;
            if(si[i].l > lr)
            {
                ans = -1;
                break;
            }
            mnlr = si[i].r;
            ++ans;
        }
        else
        {
            if(si[i].r > mnlr)
            {
                mnlr = si[i].r;
            }
        }
    }
    printf("%d\n",ans);
}
```
    - **核心实现思想**：对时间段按左端点排序，扫描过程中更新最晚结束时间 `mnlr`，当必须更新时选择新的时间段，同时判断是否无法覆盖。

- **作者：一扶苏一（4星）**
    - **关键亮点**：提出线段树结合动态规划的思路，对复杂度进行详细分析和优化，适合有一定基础的选手拓展思路。
    - **核心代码**：
```cpp
// 部分核心代码
std::sort(MU+1,MU+1+n,cmp);
for(rg int i=1;i<=n;++i)
{
    change(0,t,1,ask(0,t,1,MU[i].l-1,MU[i].r)+1,MU[i].r);
}
int ans=ask(0,t,1,t,t);
```
    - **核心实现思想**：用线段树维护到时间 `T` 的最少奶牛个数，按右端点升序排序，对每个区间右断点求左端点 -1 到右端点的最小值并 +1 作为该时刻的值。

### 最优关键思路或技巧
- 贪心算法中，对奶牛工作时间段按左端点排序，在满足覆盖条件下选择右端点最大的时间段，可有效减少选择的奶牛数量。
- 线段树结合动态规划，通过维护区间最小值优化转移过程，降低时间复杂度。

### 可拓展之处
同类型题如区间覆盖问题、活动安排问题等，都可使用贪心算法或动态规划解决。类似算法套路包括按区间端点排序、维护最值等。

### 洛谷相似题目推荐
- P1803 凌乱的yyy / 线段覆盖
- P2082 区间覆盖
- P1233 木棍加工

### 个人心得总结
PTC06 提到初次提交因数组定义过小导致 RE，提醒我们在编程时要根据题目数据范围合理定义数组大小，避免因小错误浪费调试时间。 

---
处理用时：35.27秒
# 题目信息

# 【数学1】小浩的幂次运算

## 题目描述

幂次运算让小浩觉得有些烦，最近他碰到了一些问题。  
他需要求出所有 $w^i$ 使得 $l \le w^i \le r$ ，于是他找到了你。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据：$1\le l\le r \le 1 \times 10^{18}$ , $1\le w \le10^9$。


## 样例 #1

### 输入

```
1 10 2```

### 输出

```
1 2 4 8```

## 样例 #2

### 输入

```
2 4 5```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是找出满足 $l \le w^i \le r$ 的所有 $w^i$，但在处理方式和应对难点上各有不同。主要难点在于处理 $w = 1$ 的特判情况以及避免幂运算时爆 `long long`。题解们采用了不同方法解决这些问题，如特判、转换判断条件、使用更大的数据类型、对数运算等。

### 所选题解
- **作者：易颖杰（5星）**
    - **关键亮点**：思路清晰，代码完整且注释详细，对边界情况处理得当，有效避免了死循环和爆 `long long` 的问题。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
ll l,r,w,t=1;
int main()
{
    cin>>l>>r>>w;
    bool found=0;
    if (l==1)
    {
        found=true;
        printf("1 ");
    }
    if(w>1)
    {
        while(t<l/w||(t==l/w&&(l%w)))
            t=t*w;
        while (t<=r/w)
        {
            t*=w;
            found=true;
            printf("%lld ",t);
        }
    }
    if(!found) cout<<-1;
    cout<<endl;
    return 0;
}
```
    - **核心实现思想**：先特判 $l = 1$ 的情况，若 $w > 1$，通过循环将 $t$ 乘到左边界 $l$，再在 $l$ 到 $r$ 间找符合条件的数，判断时使用 $t <= r / w$ 避免爆 `long long`。

- **作者：pantw（4星）**
    - **关键亮点**：代码简洁，通过巧妙的条件判断 `tmp = ((r / w >= tmp)? tmp * w : r + 1)` 避免了因溢出导致的死循环，同时对 $w = 1$ 进行了特判。
    - **核心代码**：
```cpp
#include <cstdio>
#define Lovelive long long
int main() {
    Lovelive l, r, w;
    scanf("%lld%lld%lld", &l, &r, &w);
    bool flag = true;
    if(w == 1) return puts((l == 1 && r >= 1)? "1" : "-1"), 0;
    for(Lovelive tmp = 1; tmp <= r && tmp > 0; tmp = ((r / w >= tmp)? tmp * w : r + 1)) {
        if(tmp >= l && tmp <= r) {
            printf("%lld ", tmp);
            flag = false;
        }
    }
    if(flag) puts("-1");
    return 0;
}
```
    - **核心实现思想**：先特判 $w = 1$ 的情况，然后使用循环枚举 $w^i$，通过 `r / w >= tmp` 判断是否会溢出，避免死循环。

- **作者：Dog_Two（4星）**
    - **关键亮点**：使用 `__int128` 避免了爆 `long long` 的问题，同时提供了 `__int128` 的输入输出函数，代码逻辑清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
__int128 l,r,w;

__int128 inp(){
    register __int128 x=0;
    char c;
    while(!isdigit(c=getchar()));
    do x=(x<<1)+(x<<3)+(c^'0'); while(isdigit(c=getchar()));
    return x;
}

bool print(const __int128 &x){
    return x>9?print(x/10),putchar(x%10+'0'):putchar(x+'0');
}

int main(){
    l=inp(),r=inp(),w=inp();
    if(w==1){
        if(l<=1 and r>=1) cout<<1;
        else cout<<-1;
        return 0;
    }
    bool ans=false;
    __int128 val=1;
    for(;val<l;val*=w);
    for(;val>=l and val<=r;val*=w){
        ans|=print(val);
        putchar(' ');
    }
    if(!ans) cout<<-1;
    return 0;
}
```
    - **核心实现思想**：先特判 $w = 1$ 的情况，使用 `__int128` 进行幂运算，避免溢出，通过循环找出符合条件的数并输出。

### 最优关键思路或技巧
- **避免爆 `long long`**：将乘法判断转换为除法判断，如判断 `tmp * w <= r` 改为 `tmp <= r / w`。
- **特判处理**：对 $w = 1$ 和 $l = 1$ 的情况进行特判，避免死循环和漏解。
- **使用更大的数据类型**：如 `__int128` 可以有效避免溢出问题。

### 可拓展之处
同类型题可能会增加更多限制条件，如要求输出结果取模，或者在多维空间中进行幂次运算。类似算法套路可用于处理其他指数级增长的问题，如斐波那契数列的快速幂求解。

### 推荐题目
- [P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226)
- [P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)
- [P5349 【XR-1】分块](https://www.luogu.com.cn/problem/P5349)

### 个人心得摘录与总结
- **Chiaro**：一开始以为用 `unsigned long long` 能解决问题，结果多次 `WA` 后才发现会爆，改用 `__int128` 才通过，浪费了很多时间。总结：在处理大数据范围时，要充分考虑数据溢出问题，选择合适的数据类型。
- **Jelly_Goat**：和大佬调了 1h 才发现 $i$ 可以为 $0$，同时意识到快速幂可能会爆 `long long`，可以用 `double` 存 $r / w$ 的值来判断是否会溢出。总结：做题时要仔细审题，考虑全面，同时掌握避免数据溢出的技巧。
- **xkcdjerry**：用对数方法解题时，一开始没处理好 $w = 1$、$l = 1$、`llog >= rlog` 的情况，多次提交才发现问题，加上特判后才 `AC`。总结：使用特殊算法时，要充分考虑边界情况和特殊情况，进行必要的特判。 

---
处理用时：37.74秒
# 题目信息

# [USACO3.1] 邮票 Stamps

## 题目描述

给一组 $n$ 枚邮票的面值集合和一个上限 $k$ —— 表示信封上能够贴 $k$ 张邮票。请求出最大的正整数 $m$，满足 $1$ 到 $m$ 的面值都可以用不超过 $k$ 张邮票表示出来。



## 说明/提示

#### 样例输入输出 1 解释

有 $1$ 分和 $3$ 分的邮票；你最多可以贴 $5$ 张邮票。很容易贴出 $1$ 到 $5$ 分的邮资（用 $1$ 分邮票贴就行了），接下来的邮资也不难：


- $6 = 3 + 3$。
- $7 = 3 + 3 + 1$。
- $8 = 3 + 3 + 1 + 1 $。
- $9 = 3 + 3 + 3 $。
- $10 = 3 + 3 + 3 + 1 $。
- $11 = 3 + 3 + 3 + 1 + 1 $。
- $12 = 3 + 3 + 3 + 3 $。
- $13 = 3 + 3 + 3 + 3 + 1$。


然而，使用 $5$ 枚 $1$ 分或者 $3$ 分的邮票根本不可能贴出 $14$ 分的邮资。因此，答案为 $13$。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq k \leq 200$，$1 \leq n \leq 50$，$1 \leq a_i \leq 10^4$。

#### 说明

题目翻译来自 NOCOW。

## 样例 #1

### 输入

```
5 2
1 3```

### 输出

```
13```

# AI分析结果

### 综合分析与结论
这些题解主要围绕动态规划和广度优先搜索（BFS）来解决邮票组合问题。多数题解采用动态规划，将其转化为完全背包问题，定义状态表示凑出面值所需最少邮票数，通过状态转移方程更新状态，最后找出连续可凑出面值的最大值。少数题解使用BFS，通过队列记录能组成的面额和所需邮票数进行搜索。

### 评分较高的题解
- **作者：「QQ红包」（5星）**
    - **关键亮点**：思路清晰，代码简洁易懂，将问题转化为完全背包模型，详细注释便于理解。
    - **核心代码**：
```cpp
int f[2000000];
int main() 
{
    scanf("%d%d",&k,&n);
    for (i=1;i<=2000000;i++) f[i]=2333;
    f[0]=0;
    for (i=1;i<=n;i++)
    {
        scanf("%d",&a);
        for (j=a;j<=2000000;j++)
        if (f[j-a]+1<=k)
            f[j]=min(f[j],f[j-a]+1);
    } 
    s=0;
    for (i=1;i<=2000000;i++)
        if (f[i]==2333)
        {
            s=i-1;
            break;
        }
    printf("%d\n",s);
    return 0;
}
```
    - **核心思想**：`f[i]` 表示构成面值为 `i` 至少需要的邮票数，通过两层循环更新 `f` 数组，外层循环遍历邮票种类，内层循环更新每个面值所需最少邮票数，最后找出连续可凑出面值的最大值。

- **作者：ysner（4星）**
    - **关键亮点**：详细分析了动态规划的阶段、状态和决策，逐步推导状态转移方程，代码实现规范。
    - **核心代码**：
```cpp
int a[51]={},dp[2000001]={};
int main()
{
    while(scanf("%d%d",&k,&n)!=EOF)
    {
        for(i=0;i<n;i++)
            scanf("%d",&a[i]);
        sort(a,a+n);
        dp[0]=0;
        i=0;
        while(dp[i]<=k)
        {
            i++;
            dp[i]=999999;
            for(j=0;j<n&&a[j]<=i;j++)
              if(dp[i-a[j]]+1<dp[i])
                dp[i]=dp[i-a[j]]+1;
        }
        printf("%d\n",i-1);
    }
    return 0;
}
```
    - **核心思想**：`dp[i]` 表示构成面值 `i` 所需要的最少邮票数，通过循环不断更新 `dp` 数组，直到找到无法用不超过 `k` 张邮票凑出的面值，输出前一个面值。

- **作者：Priori_Incantatem（4星）**
    - **关键亮点**：明确指出是完全背包问题，转移方程清晰，代码简洁，对边界条件有特判。
    - **核心代码**：
```cpp
const int Maxn=60,inf=0x3f3f3f3f,Maxm=200*10000+10;
int f[Maxm+100],a[Maxn];
int main()
{
    m=read(),n=read();
    for(int i=1;i<=n;++i)
    a[i]=read();
    for(int i=1;i<=Maxm;++i)
    {
        f[i]=inf;
        for(int j=1;j<=n;++j)
        if(i-a[j]>=0)f[i]=min(f[i],f[i-a[j]]+1);
        if(f[i]==inf || f[i]>m)break;
        ans++;
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心思想**：`f[i]` 表示用给出的邮票凑出面值为 `i` 的钱最少需要多少枚邮票，通过两层循环更新 `f` 数组，若 `f[i]` 为无穷大或超过 `k` 则停止循环，输出连续可凑出面值的数量。

### 最优关键思路或技巧
- **动态规划转化为完全背包问题**：将邮票组合问题转化为完全背包问题，用一维数组记录凑出面值所需最少邮票数，通过状态转移方程更新状态。
- **状态转移方程**：`f[i]=min(f[i],f[i-a[j]]+1)`，其中 `f[i]` 表示凑出面值 `i` 所需最少邮票数，`a[j]` 表示第 `j` 种邮票的面值。
- **边界条件处理**：初始化 `f[0]=0`，其他值初始化为无穷大，避免状态转移时出现错误。

### 可拓展之处
- **同类型题**：硬币组合问题、物品选取问题等，可通过动态规划解决。
- **类似算法套路**：完全背包问题的变种，如多重背包问题、分组背包问题等，可通过调整状态转移方程和循环顺序解决。

### 推荐题目
- [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)：完全背包问题的经典应用。
- [P1832 A+B Problem（再升级）](https://www.luogu.com.cn/problem/P1832)：与本题类似，需要找出连续可表示的数。
- [P2918 [USACO08NOV]Buying Hay S](https://www.luogu.com.cn/problem/P2918)：同样是背包问题，需要满足一定的条件。

### 个人心得摘录与总结
- **作者：光明正大**：表示一翻题解发现大佬用的都是动规，自己不会动规所以写了一篇BFS，体现了不同的解题思路。
- **作者：Weierstras**：指出求背包的上界可以大大缩短时间，体现了对算法优化的思考。
- **作者：Vin_1999**：提到要把面值快排一遍，然后加个判断，不然第11个点会wa掉，强调了边界条件和排序的重要性。

---
处理用时：44.45秒
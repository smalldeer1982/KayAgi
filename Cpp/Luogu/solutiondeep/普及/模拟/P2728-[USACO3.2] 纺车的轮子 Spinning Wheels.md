# 题目信息

# [USACO3.2] 纺车的轮子 Spinning Wheels

## 题目背景

一架纺车有五个纺轮（也就是五个同心圆），这五个不透明的轮子边缘上都有一些缺口。这些缺口必须被迅速而准确地排列好。每个轮子都有一个起始标记（在0度），这样所有的轮子都可以在统一的已知位置开始转动。轮子按照角度变大的方向旋转（即0经过旋转到达1的位置），所以从起始位置开始，在一定的时间内，它们依次转过1度，2度等等（虽然这些轮子很可能不会同时转过这些角度）。


## 题目描述

这是一个整数问题。轮子不会转过1.5度或23.51234123度这样的角度。例如，轮子可能在一秒钟内转过20到25度甚至30到40度（如果转得快的话）。

这个问题中的所有角度都限制在 0 <= 角度 <= 359 这个范围内。轮子转过 359 度后接下来就是 0 度。每个轮子都有一个确定的旋转速度，以秒作为单位。1 <= 速度 <= 180。

轮子上的缺口的起始角度和缺口大小（或宽度）各由一个整数表示，都以度为单位。在一个轮子上，两个缺口之间至少有一度的间隔。宽度也包含缺口起始的角度，**即0 179包括0..179共计180个角度**

在起始位置，设时间为 0，所有的轮子的起始标记排列成一条直线。你的程序必须计算，最早出现每个的轮子上的缺口同其他轮子上的缺口对准（也就是一束光可以通过五个轮子上的五个缺口）情况的时间。这些缺口在任意一个角度对准。


## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 3.2


## 样例 #1

### 输入

```
30 1 0 120
50 1 150 90
60 1 60 90
70 1 180 180
90 1 180 60```

### 输出

```
9```

# AI分析结果

### 综合分析与结论
这些题解均采用模拟的方法解决纺车缺口对齐问题。核心思路是枚举每一秒，标记每个轮子缺口覆盖的角度，统计每个角度的缺口数量，若某一角度的缺口数为 5，则找到解。

算法要点：
1. 读取每个轮子的速度、缺口数量、起始位置和宽度。
2. 枚举时间，从 0 到 360 秒。
3. 每秒重置角度标记数组，更新每个轮子缺口位置并标记覆盖角度。
4. 检查是否有角度的缺口数为 5，有则输出时间，无则继续。

解决难点：
1. 处理角度循环，通过对 360 取模避免越界。
2. 每秒重置标记数组，确保统计准确。

### 所选题解
- 作者：「QQ红包」，5 星。关键亮点：思路清晰，代码结构简洁，注释详细，便于理解。
```cpp
for (t=0;t<=360;t++) {
    memset(a,0,sizeof(a));
    for (i=1;i<=5;i++) {
        for (j=1;j<=s[i];j++) {
            for (k=x[i][j];k<=x[i][j]+y[i][j];k++)
                a[k%360]++;
            x[i][j]=(x[i][j]+v[i])%360;
        }
    }
    for (i=0;i<=359;i++)
        if (a[i]==5) {
            printf("%d\n",t);
            return 0;
        }
}
printf("none\n");
```
核心实现思想：外层循环枚举时间，内层循环遍历每个轮子的每个缺口，标记缺口覆盖的角度，最后检查是否有角度的缺口数为 5。

- 作者：王轩逸，4 星。关键亮点：代码规范，注释解释思路，结构体封装轮子信息，提高可读性。
```cpp
for(int t=0;t<360;t++) {
    memset(gap,0,sizeof(gap));
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=w[i].num;j++) {
            for(int k=0;k<=w[i].len[j];k++)
                gap[(w[i].st[j]+k)%360]++;
            w[i].st[j]=(w[i].st[j]+w[i].sp)%360;
        }
    }
    for(int i=0;i<360;i++)
        if(gap[i]==5) {
            cout<<t;
            return 0;
        }
}
cout<<"none";
```
核心实现思想：与上一题解类似，使用结构体存储轮子信息，枚举时间，标记角度，检查结果。

- 作者：傅思维666，4 星。关键亮点：详细解释圆轮题处理方法，代码简洁，注释清晰。
```cpp
for(int t=0;t<=360;t++) {
    memset(v,0,sizeof(v));
    for(int i=1;i<=5;i++)
        for(int j=1;j<=s[i];j++) {
            for(int k=p[i][j];k<=p[i][j]+width[i][j];k++)
                v[k%360]++;
            p[i][j]=(p[i][j]+speed[i])%360;
        }
    for(int i=0;i<=359;i++)
        if (v[i]==5) {
            printf("%d",t);
            return 0;
        }
}
printf("none");
```
核心实现思想：同样是模拟时间，标记角度，检查是否有解。

### 最优关键思路或技巧
- 使用数组标记每个角度的缺口数量，方便统计。
- 对角度取模处理，解决圆轮循环问题。
- 每秒重置标记数组，保证统计准确性。

### 可拓展之处
同类型题如环形轨道上的物体相遇问题、时钟指针重合问题等。类似算法套路为模拟时间，记录状态，检查条件。

### 推荐题目
1. P1006 传纸条
2. P1141 01迷宫
3. P1219 八皇后

### 个人心得摘录与总结
- 傅思维666：处理圆轮题时，可对枚举数取模，避免开三倍数组的麻烦。
- 此后无良辰：每次枚举时间要记得清空标记数组，否则会出错。
- yangyujia18：每次枚举时间要清空标记数组，否则后果自负。

---
处理用时：29.02秒
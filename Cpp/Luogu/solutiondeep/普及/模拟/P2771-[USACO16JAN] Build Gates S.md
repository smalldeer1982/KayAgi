# 题目信息

# [USACO16JAN] Build Gates S

## 题目描述

FarmerJohn 打算在他农场的一部分，建设一个围栏。但是因为没有认真做事，建造完成后，围栏变成一个很奇怪的形状。

具体来说，FJ 从 $(0,0)$ 出发，走了 $N$ 步，每步移动一单位（向东、向南、向西或向北）。

他走过的每一步，都会留下一段单位长度的围栏。例如，如果他的第一步向北，他建造一单位从 $(0,0)$ 到 $(0,1)$ 的围栏。

FJ 可能重复到达点多次，他也可能重复建造一段围栏多次。如果他的路径穿过一段已经建成的围栏，他的围栏也有可能会有交叉。

不用说，FJ 看到完成的围栏时，一定很沮丧。特别的，他发现一些区域被围栏封闭起来，从而无法到达。FJ 想在围栏上，安装一些门来解决这个问题。

门可以安装在任意一段单位长度（注：必须是之前走过的某一步）的围栏上，从而可以穿越这段围栏的两侧。

请计算 FJ 最少需要安装多少个门，才能保证农场上任意区域到任意区域都可到达。

## 说明/提示

注意，如果农场初始连通，答案就是 $0$。

### 数据范围

$1\le n\le 1000$。


## 样例 #1

### 输入

```
14
NNNESWWWSSEEEE```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算最少需要安装的门的数量展开，核心在于找出封闭区域的数量。题解思路大致可分为两类：一是通过判断环的数量来确定答案，二是通过搜索算法（如DFS）统计封闭区域数量。各题解在处理坐标负数、小封闭区域识别、交点判断等难点上采用了不同方法。

### 所选题解
- **作者：LPhang（5星）**
    - **关键亮点**：思路清晰，提供了两种不同的解题方法，且对每种方法都有详细的原理分析和示例说明，代码注释详细。
    - **核心代码及思想**：
        - **方法一**：
```cpp
for(int i = 1; i <= n; ++i) {
    char c; scanf("%c", &c);
    for(int j = 0; j < 4; ++j) {
        if(c == s[j]) {x += dx[j], y += dy[j]; break;}
    } 
    if(!bol[x][y]) a[x][y] = ++num;
    int last = a[xt][yt], now = a[x][y];
    if(!f[last][now] && bol[x][y]) ++ans;
    f[last][now] = f[now][last] = 1;
    xt = x, yt = y; bol[x][y] = 1;
}
```
思想：记录每个点的编号和点之间的路径，当一个点不是第一次到达且当前路径之前不存在时，答案加1。
        - **方法二**：
```cpp
for(int i = 1; i <= n; ++i) {
    char c; scanf("%c", &c);
    for(int i = 0; i < 4; ++i) {
        if(c == s[i]) {x += dx[i], y += dy[i]; break;}
    } 
    if(!bol[x][y]) a[x][y] = ++num, bol[x][y] = 1;
    int last = a[xt][yt], now = a[x][y];
    if(!f[last][now]) {
        f[last][now] = f[now][last] = 1;
        ++num1;
    }
    xt = x, yt = y;
}
printf("%d\n", num1 - num + 1);
```
思想：统计点数和边数，根据树的性质（边数 = 点数 - 1）计算需要删除的边数。
- **作者：lxzy_（4星）**
    - **关键亮点**：详细阐述了标记围栏、确定搜索边界和统计封闭区域数量的步骤，对可能出现的问题有清晰的分析和解决方法，代码注释丰富。
    - **核心代码及思想**：
```cpp
for(register int i=0;i<=n-1;i++)
{
    if(s[i]=='N')
    {
        map[--x][y]=true;
        map[--x][y]=true;
        Minx=min(Minx,x);
    }
    // 其他方向类似
}
int ans=solve();
if(ans==0)
    cout<<0;
else
    cout<<ans-1;
```
思想：将一步当两步走标记围栏，确定搜索边界，使用DFS统计封闭区域数量，最后减去外围的假封闭区域。
- **作者：Minclxc（4星）**
    - **关键亮点**：思路简洁，通过记录每个点每个方向是否访问过来判断交点，从而确定联通块数量，代码简洁高效。
    - **核心代码及思想**：
```cpp
fo(i,1,n){
    int opt=num[getchar()];
    a[x][y][opt]=1;
    x+=f[opt][0],y+=f[opt][1];
    ans+=(b[x][y]&!a[x][y][3-opt]);
    a[x][y][3-opt]=b[x][y]=1;
}
```
思想：记录每个点每个方向的访问情况，当访问过的点且该方向没有访问过时，答案加1。

### 最优关键思路或技巧
- **坐标平移**：为避免出现负数坐标，将起点设置在一个较大的正数位置，如(1000, 1000)或(2001, 2001)。
- **一步当两步走**：解决小封闭区域难以识别的问题，使封闭区域能完整显现。
- **判断交点**：通过记录点和边的访问情况，判断是否形成新的封闭区域。

### 拓展思路
同类型题可考虑更复杂的地图形状、更多的移动规则或更高的数据范围。类似算法套路可用于解决连通性问题、图的环检测问题等。

### 推荐题目
- [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)：涉及连通块的判断和搜索算法。
- [P1451 求细胞数量](https://www.luogu.com.cn/problem/P1451)：使用搜索算法统计连通区域数量。
- [P2002 消息扩散](https://www.luogu.com.cn/problem/P2002)：考察图的连通性和深度优先搜索。

### 个人心得摘录与总结
- **作者：lxzy_**：考试时唯一AC的题，强调了处理坐标负数和小封闭区域的重要性，以及确定搜索边界时要注意避免假封闭区域。
- **作者：w_x_c_q**：WA了很多次，注意到一个点在不同方向意义上可能算作不同交点，需要记录走到每个点的方向。
- **作者：wangzikang**：指出代码中存在的多个问题，如小封闭区域统计、假封闭区域识别和输入换行符处理，调试过程较为曲折。 

---
处理用时：34.45秒
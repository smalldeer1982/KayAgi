# 题目信息

# IPv6地址压缩

## 题目背景

（友情提示：IPv6 基础知识曾多次出现在 NOIP 初赛中）Internet Protocol，互联网协议，即为我们常说的 IP。我们目前常说的 IP 主要指它的第四版，即 IPv4，它由 IETF 于 1981 年发布。它的地址长度是 $32$ 个二进制位，因此也就有 $2^{32}$ 个 IP 地址可供使用，约为 $43$ 亿，在当时，谁也没有料想到 IPv4 如此庞大的地址长度会有用完的一天。

在 21 世纪的今天，互联网的蓬勃发展早就了我们如今便利的生活。当下，世界人口已超过 70 亿，计算机和各种联网设备已经走入千家万户，而不再仅是上个世纪 80 年代科学家们的工具。此时便出现了人们日益增长的联网设备需要同落后 IPv4 地址长度之间的矛盾。尽管可以通过网络地址翻译能技术来共享 IP 地址，临时解决枯竭的问题，但显然不是长久之计。

IETF 也有先见之明，早早地于 1998 年发布了 IPv6 协议，从微软 2006 年发布的 Windows Vista 开始成为默认安装的网络协议。作为 IPv4 的继任者，它的地址长度为 $128$ 个二进制位，也就是 $2^{128}$ 个IP地址可供使用。然而面对这冗长的地址，一位记忆力不好的网络工程师小明在配置路由表时遇到了许许多多多的困难，现在他找到了你，希望你帮忙编写一个程序来按照 IPv6 地址标准的格式压缩规则来压缩 IPv6 地址。

## 题目描述

**【IPv6 格式】**

IPv6 二进位制下为 $128$ 位长度，以 $16$ 位为一组，每组以冒号“`:`”隔开，可以分为 $8$ 组，每组以 $4$ 位十六进制方式表示。

比如 `2001:0db8:0000:0000:0123:4567:89ab:cdef` 是一个合法的 IPv6 地址。

同时 IPv6 地址在某些条件下可以压缩：

1. 每组数字代表的独立十六进制数可以省略前位的 `0`。

比如上面的 IPv6 地址可被压缩为 `2001:db8:0:0:123:4567:89ab:cdef`。

2. 可以用双冒号 `::` 表示一组 `0` 或多组连续的 `0`，但只能出现一次。

比如上面的 IPv6 地址可被压缩为 `2001:db8::123:4567:89ab:cdef`。

请你帮助记忆力不好的网络工程师小明解决他遇到的问题。

**【规则补充】**

1. 输入数据为完全展开的 IPv6 地址，确保输入的 IPv6 地址不含双冒号，每组地址省略的 `0` 都会被补充上去。

2. 双冒号只能使用一次，因此我们压缩最长的全 `0` 组。

比如 `2001:0db8:0000:0000:1:0000:0000:0000`，压缩为 `2001:db8:0:0:1::`，而非 `2001:db8::1:0:0:0`。

3. 双冒号只能使用一次，因此我们在我们遇到地址中多个连续全 `0` 组长度相同时，我们压缩最前面的一个。

比如 `2001:0db8:0000:0000:ffff:0000:0000:1`，压缩为 `2001:db8::ffff:0:0:1`，而非 `2001:db8:0:0:ffff::1`。

4. 输入的 IPv6 地址可能无法被压缩，此时请照原样输出。

提示：本题所示的压缩规则与 macOS (Darwin) 默认的 IPv6 地址显示方式相同，而 Windows 和 Linux 只遇到一组全 `0` 时不会使用 `::` 进行压缩。但用此方法压缩过的 IPv6 地址一样可以被 Windows 和 Linux 正确识别。

比如 `2001:0db8:ffff:0000:0123:4567:89ab:cdef`，Darwin 压缩为 `2001:db8:ffff::123:4567:89ab:cdef`，而 Linux 和 Windows 压缩为 `2001:db8:ffff:0:123:4567:89ab:cdef`。

## 样例 #1

### 输入

```
2406:0840:f990:0000:0000:0000:0000:0001```

### 输出

```
2406:840:f990::1```

## 样例 #2

### 输入

```
2a13:1801:018a:00cf:0100:0000:0000:0000```

### 输出

```
2a13:1801:18a:cf:100::```

## 样例 #3

### 输入

```
2001:4860:4860:0000:0000:0000:0000:8888```

### 输出

```
2001:4860:4860::8888```

## 样例 #4

### 输入

```
2001:0db8:0000:0000:0000:0000:0000:0001```

### 输出

```
2001:db8::1```

## 样例 #5

### 输入

```
0000:0000:0000:0000:0000:0000:0000:0000```

### 输出

```
::```

## 样例 #6

### 输入

```
0000:0000:0000:0000:0000:0000:0000:0001```

### 输出

```
::1```

## 样例 #7

### 输入

```
2001:0db8:ffff:0000:0123:4567:89ab:cdef```

### 输出

```
2001:db8:ffff::123:4567:89ab:cdef```

## 样例 #8

### 输入

```
1234:5678:9abc:def0:1234:5678:9abc:def0```

### 输出

```
1234:5678:9abc:def0:1234:5678:9abc:def0```

## 样例 #9

### 输入

```
0001:0000:0000:0000:0000:0000:0000:0001```

### 输出

```
1::1```

## 样例 #10

### 输入

```
0000:0000:0000:0000:0000:0000:0001:0002```

### 输出

```
::1:2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕 IPv6 地址压缩展开，核心思路都是先去除每组的前导零，再找出最长连续的全零组并用双冒号替换。各题解在实现细节和数据处理方式上有所不同，有的使用字符数组，有的使用字符串，还有的用十六进制输入。难点在于处理连续全零组的判断、前导零的去除以及双冒号的正确插入，同时要注意不同压缩规则和边界情况。

### 所选题解
- **作者：RocksonLee（5星）**
    - **关键亮点**：思路清晰，代码结构合理，将寻找最长全零字段和处理前导零的逻辑分开，便于理解和维护。
    - **个人心得**：提到题目坑点多，处理时需注意 Windows 和 macOS 规则不同，当全零字段只有一个时，用“::”无法通过，应像处理其他前导零一样处理。
    - **核心代码**：
```cpp
void find () {
    int i1,i2,t;
    bool ok;
    for (i1=0,t=0;i1<8;i1++) {
        ok=true;
        for (i2=0;i2<4;i2++) {
            if (a[i1*5+i2]!='0') {
                ok=false;
                break;
            }
        }
        if (ok) {
            t++;
            if (t>maxn) {
                maxn=t;
                maxi=i1;
            }
        } else t=0;
    }
    if (maxn==1) maxi=-1;
    maxi=maxi-maxn+1;
} 
```
此函数用于寻找最长的全零字段，通过两层循环遍历每组地址，统计连续全零组的长度和起始位置。

- **作者：_Ayanami_（4星）**
    - **关键亮点**：使用字符串处理，代码简洁，逻辑清晰，将地址按组处理，先去除前导零，再找出最长连续零组并替换。
    - **个人心得**：表示交了十遍才过，强调题中存在各种神奇的细节。
    - **核心代码**：
```cpp
for(int i=0;i<8;i++) {
    int j=0;
    while(ss[i*5+j]=='0') {
        j++;
    }
    if(j==4) {
        s[i]="0";
    } else {
        for(j;j<4;j++) {
            s[i]+=ss[i*5+j];
        }
    }
}
```
这段代码用于去除每组地址的前导零，将处理后的每组地址存入字符串数组 `s` 中。

- **作者：0AND1STORY（4星）**
    - **关键亮点**：通过在字符串前加冒号的方式便于去除前导零，利用连续冒号数判断连续零的个数，思路独特。
    - **个人心得**：提到用字符串处理也能达到和用十六进制输入一样的效果，还附上了调试用的对拍程序。
    - **核心代码**：
```cpp
s = ":" + s;
for (int i = 1; i < s.size(); i ++) {
    if (s[i - 1] == ':' && s[i] == '0')
        s.erase(s.begin() + i, s.begin() + i + 1),
        i --;
}
s.erase(s.begin(), s.begin() + 1);
```
此代码通过在字符串前加冒号，方便判断和删除前导零，最后再删除添加的冒号。

### 最优关键思路或技巧
- 使用十六进制输入（如 `scanf("%x:%x:%x:%x:%x:%x:%x:%x",...)`）可自动过滤前导零，简化处理过程。
- 在字符串前添加冒号便于判断和删除前导零。
- 用变量记录最长连续全零组的起始位置和长度，方便后续替换。

### 拓展思路
同类型题可能涉及其他网络地址格式的处理，如 IPv4 地址的子网掩码计算、MAC 地址的格式化等。类似算法套路为模拟处理，先按规则拆分数据，再进行相应的转换和替换操作。

### 推荐题目
- P1055 [ISBN 号码](https://www.luogu.com.cn/problem/P1055)：字符串处理，根据规则判断 ISBN 号码是否正确。
- P1598 [垂直柱状图](https://www.luogu.com.cn/problem/P1598)：字符串处理和图形输出，按要求输出字符的垂直柱状图。
- P1200 [你的飞碟在这儿](https://www.luogu.com.cn/problem/P1200)：字符串处理和简单数学计算，根据字符串计算得分并比较。

---
处理用时：28.81秒
# 题目信息

# 路障

## 题目描述

B 君站在一个 $n\times n$ 的棋盘上。最开始，B君站在 $(1,1)$ 这个点，他要走到 $(n,n)$ 这个点。

B 君每秒可以向上下左右的某个方向移动一格，但是很不妙，C 君打算阻止 B 君的计划。

**每秒结束的时刻**，C 君 会在 $(x,y)$ 上摆一个路障。B 君不能走在路障上。

B 君拿到了 C 君准备在哪些点放置路障。所以现在你需要判断，B 君能否成功走到 $(n,n)$。

**保证数据足够弱：也就是说，无需考虑“走到某处然后被一个路障砸死”的情况，因为答案不会出现此类情况。**

## 说明/提示

样例解释：

以下 0 表示能走，x 表示不能走，B 表示 B 君现在的位置。从左往右表示时间。

```
Case 1:
0 0    0 0    0 B  (已经走到了)
B 0    x B    x 0
```
```
Case 2:
0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0
0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0
0 0 0 0 0    0 0 x 0 0    0 0 x 0 0    0 0 x 0 0
0 0 0 0 0    0 0 0 0 0    0 0 x 0 0    0 0 x 0 0
B 0 0 0 0    0 B 0 0 0    0 0 B 0 0    0 0 x B 0 ......(B君可以走到终点)
```

数据规模：

防止骗分，数据保证全部手造。

对于 $20\%$ 的数据，有 $n\le3$。

对于 $60\%$ 的数据，有 $n\le500$。

对于 $100\%$ 的数据，有 $n\le1000$。

对于 $100\%$ 的数据，有 $T\le10$。

## 样例 #1

### 输入

```
2

2
1 1
2 2

5
3 3
3 2
3 1
1 2
1 3
1 4
1 5
2 2```

### 输出

```
Yes
Yes```

# AI分析结果

### 综合分析与结论
这些题解主要围绕广度优先搜索（BFS）展开，部分使用了动态规划（DP）。核心在于处理每秒放置的路障对B君从起点到终点路径的影响。各题解在数据结构使用、路障处理方式、代码实现细节上有所不同，但整体思路一致。

### 高评分题解
- **作者：Invisible_Blade（5星）**
    - **关键亮点**：思路清晰，详细解释了代码各部分的作用，使用结构体手写队列进行BFS，代码可读性高。
    - **核心代码**：
```cpp
void bfs(){
    int t=1,head=1,tail=2;
    que[head].x=1,que[head].y=1,pd[1][1]=1;
    do{
        for(int i=0;i<4;i++){
            nx=que[head].x+dx[i];
            ny=que[head].y+dy[i];
            if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&pd[nx][ny]==0){
                que[tail].x=nx;
                que[tail].y=ny;
                tail++;
                pd[nx][ny]=1;
            }
        }
        pd[no[t].x][no[t].y]=1;
        t++;
        head++;
    }while(head<tail);
    for(int i=tail;i>=1;i--){
        if(que[i].x==n&&que[i].y==n){
            printf("Yes\n");
            return;
        }
    }
    printf("No\n");
    return;
}
```
    - **核心思想**：使用手写队列进行BFS，每次搜索完当前层的所有点后，放置路障，最后检查队列中是否有到达终点的点。

- **作者：Atmizz（4星）**
    - **关键亮点**：使用STL的队列进行BFS，代码简洁，对路障的处理和BFS过程解释清晰。
    - **核心代码**：
```cpp
void bfs(int x,int y,int t)
{
    queue<node>q;
    node now,net;
    now.x=x;now.y=y;now.t=t;
    q.push(now);
    while(!q.empty()) {
        now=q.front();
        q.pop();
        int a=now.x;int b=now.y;int c=now.t;
        if(a==n && b==n) {
            flag=1;
            break;
        }
        map[zx[now.t-1]][zy[now.t-1]]=1;
        for(int i=0;i<4;i++) {
            int dx=a+xx[i];int dy=b+yy[i];
            if(dx>=1 && dx<=n && dy>=1 && dy<=n && map[dx][dy]==0 && vis[dx][dy]==0) {
                net.x=dx;net.y=dy;net.t=c+1;
                vis[dx][dy]=1;
                q.push(net);
            }
        }
    }
}
```
    - **核心思想**：使用STL队列进行BFS，在每一层搜索结束后放置路障，通过标记数组判断点是否可走。

- **作者：Starlight237（4星）**
    - **关键亮点**：使用二维DP解决问题，思路独特，通过判断障碍物的有效性，将问题转化为求联通块问题。
    - **核心代码**：
```cpp
for(reg int i=1;i<=2*n-2;++i){
    scanf("%d%d",&x,&y);
    if(x==n&&y==n&&x+y-2<i){
        puts("No");
        break;
    }
    if(x+y-2>i)dag[x][y]=1;
}
dp[1][1]=1;
for(reg int i=1;i<=n;++i)
    for(reg int j=1;j<=n;++j)
        dp[i][j]|=(dp[i-1][j]||dp[i][j-1])&&!dag[i][j];
if(dp[n][n])puts("Yes");
else puts("No");
```
    - **核心思想**：标记有效障碍物，使用DP方程 `dp[i][j]|=(dp[i-1][j]||dp[i][j-1])&&!dag[i][j]` 判断点是否可达。

### 最优关键思路或技巧
- **路障处理**：记录路障放置的时间和位置，在BFS或DP过程中判断当前时间该位置是否有障碍。
- **剪枝优化**：对于一些无效的路障（如落在已经走过的点上）可以忽略。
- **数据结构选择**：使用队列进行BFS，使用二维数组记录地图和访问状态。

### 可拓展之处
同类型题可能会增加地图的复杂度（如增加障碍物类型、移动规则等），或改变时间规则（如路障放置时间不固定）。类似算法套路可用于解决迷宫问题、寻路问题等。

### 推荐题目
- P1141 01迷宫：同样是在矩阵中进行搜索，判断是否可达。
- P1443 马的遍历：在矩阵中按照特定规则移动，使用BFS求解最短路径。
- P1605 迷宫：经典的迷宫寻路问题，可使用BFS或DFS解决。

### 个人心得摘录与总结
- **OceanLiu**：强调广搜基本模板的重要性，指出数组要开得足够大，尽量少用数组，分清局部变量和全局变量，避免RE和WA。
- **ZJH365**：提醒数组要开大，存路障的数组要2000不是1000，特判 `n==1` 的情况，改造BFS一次拓展一层点。

---
处理用时：40.96秒
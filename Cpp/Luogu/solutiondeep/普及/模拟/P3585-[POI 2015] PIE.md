# 题目信息

# [POI 2015] PIE

## 题目描述

一张 $n\times m$ 的方格纸，有些格子需要印成黑色，剩下的格子需要保留白色。

你有一个 $a\times b$ 的印章，有些格子是凸起（会沾上墨水）的。你需要判断能否用这个印章印出纸上的图案。印的过程中需要满足以下要求： 

1. 印章不可以旋转。 
2. 不能把墨水印到纸外面。 
3. 纸上的同一个格子不可以印多次。 

## 样例 #1

### 输入

```
2
3 4 4 2
xx..
.xx.
xx..
x.
.x
x.
..
2 2 2 2
xx
xx
.x
x.
```

### 输出

```
TAK
NIE
```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致，均为模拟印章盖章过程。先找出印章中墨水点相对第一个墨水点的位置，再遍历纸张，以纸上需染色点为参考，判断能否用印章覆盖。不同题解在代码实现、优化程度和数据结构使用上有差异。部分题解使用结构体存储坐标，部分使用数组；部分题解用队列或链表优化遍历，减少时间复杂度。

### 所选题解
- **作者：Link_Space（5星）**
    - **关键亮点**：思路清晰，代码注释详细，便于理解，虽代码略显繁琐但逻辑完整。
    - **核心代码**：
```cpp
// 存储相对坐标
for (int i = 1; i <= a;i++) {
    for (int j = 1; j <= b;j++) {
        cin >> Stamp[i][j];
        if(Stamp[i][j]=='x') {
            if(!flag)
                stax = i, stay = j;
            else
                relative[++cnt].x = i - stax, relative[cnt].y = j - stay;
            flag = true;
        }
    }
}
// 判断能否覆盖
for (int i = 1; i <= n;i++) {
    for (int j = 1; j <= m;j++) {
        if (Map[i][j] == 'x') {
            for (int k = 1; k <= cnt;k++) {
                int xx = i + relative[k].x;
                int yy = j + relative[k].y;
                if(xx<1||xx>n||yy<1||yy>m) {
                    can = false;
                    break;
                }
                if(Map[xx][yy]!='x') {
                    can = false;
                    break;
                }
            }
            if(can) {
                for (int k = 1; k <= cnt;k++) {
                    int xx = i + relative[k].x;
                    int yy = j + relative[k].y;
                    Map[xx][yy] = '.';
                }
            }
        }
        if(!can)
            break;
    }
    if(!can)
        break;
}
```
核心思想：先记录印章中墨水点相对第一个墨水点的坐标，再遍历纸张，遇到需染色点时，检查能否用印章覆盖，若能则将覆盖的点标记为已染色。

- **作者：Bring（4星）**
    - **关键亮点**：使用宏定义简化代码，通过存储印章点相对左上角点的位置加快查找速度。
    - **核心代码**：
```cpp
// 存储相对位置
Frn(i,0,a)Frn(j,0,b) {
    cin>>c;
    if(c=='x')z[zn++]={i,j};
}
Frn(k,1,zn)z[k]={X-(z->x),Y-(z->y)};
*z={0,0};
// 判断能否覆盖
Frn(i,0,n)Frn(j,0,m)if(g[i][j]) {
    Frn(k,0,zn) {
        tx=i+X,ty=j+Y;
        if(R(tx,n)&&R(ty,m)&&g[tx][ty])g[tx][ty]=0;
        else{cout<<"NIE"<<endl;return;}
    }
}
```
核心思想：先记录印章中墨水点坐标，再计算其相对左上角点的位置，然后遍历纸张，遇到需染色点时，检查能否用印章覆盖，若不能则输出`NIE`，若能则将覆盖的点标记为已染色。

- **作者：xun薰（4星）**
    - **关键亮点**：对代码进行优化，将需染色点和能染色点抽离到结构体中，减少遍历次数，提高效率。
    - **核心代码**：
```cpp
// 存储需染色点和能染色点
for(int i=1;i<=n;i++) {
    scanf("%s",s+1);
    for(int j=1;j<=m;j++)
        if(s[j]=='x') {
            gz[++cnt_black].x=i;gz[cnt_black].y=j;
            map[i][j]=true;
        }
}
for(int i=1;i<=a;i++) {
    scanf("%s",s+1);
    for(int j=1;j<=b;j++)
        if(s[j]=='x')yz[++yz_black].x=i,yz[yz_black].y=j;
}
// 判断能否覆盖
for(int i=1;i<=cnt_black;i++) {
    if(map[gz[i].x][gz[i].y])
        if(check(gz[i].x,gz[i].y)==0) {
            flag=true;
            printf("NIE\n");break;
        }
}
```
核心思想：先将需染色点和能染色点分别存储到结构体中，再遍历需染色点，调用`check`函数判断能否用印章覆盖，若不能则输出`NIE`。

### 最优关键思路或技巧
- 用结构体存储印章中墨水点相对第一个墨水点的坐标，方便后续判断印章能否覆盖纸张上的点。
- 将需染色点和能染色点抽离到结构体或数组中，减少遍历次数，优化时间复杂度。

### 拓展思路
同类型题可拓展到二维平面上的图形匹配问题，如判断一个小图形能否在大图形中通过平移、旋转等操作完全匹配。类似算法套路为记录图形特征点的相对位置，通过遍历大图形，以特征点为参考进行匹配。

### 推荐题目
- [P1540 机器翻译](https://www.luogu.com.cn/problem/P1540)：模拟内存替换过程，考察模拟和队列的使用。
- [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)：模拟乒乓球比赛计分过程，考察模拟和条件判断。
- [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)：模拟多项式输出过程，考察模拟和字符串处理。

### 个人心得
- **作者：_Ayanami_**：提到`goto`语句在多重循环中跳出的便利性，可从同一函数任意位置跳到标记位置，解决`break`只能跳出一重循环的问题。
- **作者：xun薰**：最初纯模拟代码未优化超时，后借鉴靶型数独题，将需染色点和能染色点抽离到结构体中，减少遍历次数，优化到 188ms。 

---
处理用时：36.99秒
# 题目信息

# 三去矩阵

## 题目背景

无

## 题目描述

现在小Y有个$l \times l$的正方形字母矩阵，现在他想进行$q$次询问，每次询问最长的以$(x_i,y_i)$为中心的在一条水平或竖直的直线上的回文串的长度。

## 说明/提示

对于$20\%$的数据，$1 \le l \le 2$

另有$20\%$的数据，$q = 1$

另有$20\%$的数据，字母矩阵中心对称，上下对称，左右对称且对角线对称。

对于$100\%$的数据，$1 \le l,q \le 2000$，字母只有小写字母。

## 样例 #1

### 输入

```
5 5
abcba
bcdcb
cdedc
bcdcb
abcba
1 1
1 2
1 3
2 3
3 3```

### 输出

```
1
1
5
5
5
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕计算以给定坐标为中心的水平或竖直方向上最长回文串长度展开，多数采用暴力模拟的方法，少数使用Manacher算法。暴力模拟的思路是针对每次询问，分别向左右和上下扩展，判断字符是否相等来确定回文串长度；Manacher算法则先进行预处理，将复杂度集中在预处理阶段，使每次询问的复杂度降为$O(1)$。

### 高评分题解
- **冬瓜皮（5星）**
    - **关键亮点**：思路清晰，代码结构明确，将横向和纵向计算分别封装成函数，提高了代码的可读性和可维护性。同时，作者分享了调试经历，提醒读者避免使用`getchar()`输入字符矩阵。
    - **个人心得**：第一次提交时使用`getchar()`输入字符矩阵导致错误，后经大佬指出问题。
    - **核心代码**
```cpp
int cross(int x,int y){ //计算横向
    int length=1;
    if(x==1||x==l)  return 1;   //在边界退出
    for(int i=1;;i++){
        if(x-i==0||x+i==l+1)    return length;  //到边界退出
        else if(a[x-i][y]!=a[x+i][y])   return length;  //不相等退出
        else length+=2; //相等继续
    }
}
int down(int x,int y){  //计算纵向，同理
    int length=1;
    if(y==1||y==l)  return 1;
    for(int i=1;;i++){
        if(y-i==0||y+i==l+1)    return length;
        else if(a[x][y-i]!=a[x][y+i])   return length;
        else length+=2;
    }
}
```
- **散华礼弥（4星）**
    - **关键亮点**：使用Manacher算法，将复杂度集中在预处理阶段，使每次询问的复杂度降为$O(1)$，适合多次询问的情况。
    - **核心代码**
```cpp
void Init(int x)
{
    str[0] = str[1] = '#';
    for (int i = 0; i < n; ++i)
    {
        str[(i << 1) + 2] = s[x][i];
        str[(i << 1) + 3] = '#';
    }
}

void Manacher(int x)
{
    Init(x);
    int right = 0, cur;
    for (int i = 1; i < len; ++i)
    {
        if (i < right)
            p[x][i] = std::min(p[x][(cur << 1) - i], p[x][cur] + cur - i);
        else
            p[x][i] = 1;
        while (str[i + p[x][i]] == str[i - p[x][i]])
            ++p[x][i];
        if (p[x][i] + i > right)
        {
            cur = i;
            right = p[x][i] + i;
        }
    }
}
```
- **CT_Res（4星）**
    - **关键亮点**：思路清晰，对代码步骤进行了详细说明，通过预处理将每个坐标的最长回文串长度存储在数组中，方便后续查询。
    - **核心代码**
```cpp
for(int i=1;i<=l;i++)
    for(int j=1;j<=l;j++)
    {
        int a1=1,a2=1;
        for(int k=1;k<=l;k++)
            if(ch[i][j+k]==ch[i][j-k] and j+k<=l and j-k>=1) a1+=2;
            else break;
        for(int k=1;k<=l;k++)
            if(ch[i+k][j]==ch[i-k][j] and i+k<=l and i-k>=1) a2+=2;
            else break;
        f[i][j]=max(a1,a2);
    }
```

### 最优关键思路或技巧
- **封装函数**：如冬瓜皮的题解，将横向和纵向计算分别封装成函数，使代码结构更清晰，易于理解和维护。
- **Manacher算法**：散华礼弥的题解使用Manacher算法，将复杂度集中在预处理阶段，使每次询问的复杂度降为$O(1)$，适合多次询问的情况。
- **预处理**：CT_Res的题解通过预处理将每个坐标的最长回文串长度存储在数组中，避免了重复计算，提高了效率。

### 拓展思路
同类型题可以是在二维矩阵中寻找其他类型的特殊子串，如最长公共子串、最长递增子串等。类似算法套路可以是先进行预处理，将复杂度集中在预处理阶段，然后在查询时直接使用预处理的结果，以降低查询的复杂度。

### 推荐题目
- [P1957 口算练习题](https://www.luogu.com.cn/problem/P1957)：考察字符串处理和模拟能力。
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：考察区间处理和模拟能力。
- [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)：考察排序和去重的能力。

### 个人心得总结
- 冬瓜皮：第一次提交时使用`getchar()`输入字符矩阵导致错误，提醒读者在输入字符矩阵时要注意换行符的处理。
- Chiaro：在找回文时下标写反导致多次提交只有80分，提醒读者在编写代码时要仔细检查下标。

---
处理用时：34.68秒
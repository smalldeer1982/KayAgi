# 题目信息

# Hillwer编码

## 题目背景

在Z国的高科技研究中心，科研人员使用的都是最“先进”的Hillwer编码（毕竟这里可是国家机密库，储存着最重要的机密资料~~QwQ）。

## 题目描述

Z国的科技十分发达，一直是各国觊觎的目标，Y国就是其中之一。经过Y国黑客夜以继日的奋斗，终于获得了Z国**Hillwer**编码的转换方式，并且截获了n条原码。 BUT（总是有那么多但是~），Y国的黑客们呕心沥血研究**Hillwer**，都累得趴下了……所以，转换**Hillwer**编码的任务他们就无法完成。

Y国元首听说在遥远的东方国度，有一群才华横溢的少年——就是坐在电脑前的你们！元首希望你能够帮助Y国转换编码，他将赠予你**NOIP_AK荣耀桂冠**！

**Hillwer**编码的转换规则如下： 对于每一条原码$ S $，保证仅由26个大写字母组成。将每个字母后移R位，得到中转码$ S1 $（当$ S $=‘XYZ’,R=2时，$ S1 $=‘ZAB’。即变成当前字母后$ R $个字母，超过 ‘Z’则从‘A’开始）。接着，将中转码进行“符转数”操作，将$ S1 $每一位的ACS码（即ASCLL码）相乘，得到数串$ Q $。转换后的编码即为$ Q $。

元首为了检查你是不是偷懒，还要求你把中转码$ S1 $也输出。

## 说明/提示

对于 $ 30\% $ 的数据，$ 1 \leq n \leq 10 ,1 \leq R \leq 10 $；

对于 $ 50\% $ 的数据，$ 1 \leq n \leq 500 ,1 \leq R \leq 10^3 $；

对于 $ 100\% $ 的数据，$ 1 \leq n \leq 500 ,1 \leq R \leq 10^5 $。

另外保证 原码长度小于600

## 样例 #1

### 输入

```
2 6
HELLOWORLD
LETUSGO```

### 输出

```
NKRRUCUXRJ
10167740864629920000
RKZAYMU
20957073637500
```

# AI分析结果

### 综合分析与结论
这些题解均围绕Hillwer编码的转换规则展开，先对原码字符串进行字母后移操作得到中转码，再将中转码各位ASCII码相乘得到数串作为转换后的编码。核心难点在于处理字母循环和高精度乘法。不同题解使用了不同语言（C++、Python、Pascal）和方法（如普通高精、压位高精、结构体封装高精等）来解决问题。

### 所选题解
- **作者：Kevin_Wa（赞：11）** - 5星
    - **关键亮点**：思路清晰，代码简洁，使用简单的高精度乘法函数实现核心功能，且有详细的注释。
    - **重点代码**：
```cpp
void times(int p){  // 简单的高精
    int x=0;
    for (int i=1;i<=f[0];++i){
        f[i]=f[i]*p+x;
        x=f[i]/10;
        f[i]=f[i]%10;	
    }
    while (x>0){
        f[0]++;
        f[f[0]]=x%10;
        x=x/10;
    }
}
```
    - **核心思想**：该函数实现了高精度乘法，将当前高精度数 `f` 乘以低精度数 `p`，并处理进位。

- **作者：JMercury（赞：6）** - 4星
    - **关键亮点**：代码简洁，逻辑清晰，先对 `R` 取模避免多余计算，高精度乘法部分实现直接。
    - **重点代码**：
```cpp
for(int j=0;j<s.size();j++) s[j]=((s[j]-'A')+r)%mod+'A';
for(int j=0;j<s.size();j++)
{
    for(int k=0;k<=1210;k++) ans[k]*=s[j];
    for(int k=0;k<=1210;k++) ans[k+1]+=ans[k]/10,ans[k]%=10;
}
```
    - **核心思想**：先对字符串进行字母后移操作，再进行高精度乘法并处理进位。

- **作者：Alarm5854（赞：3）** - 4星
    - **关键亮点**：使用结构体封装高精度数，代码结构清晰，对 `R` 取模和字符串处理部分简洁明了。
    - **重点代码**：
```cpp
struct ll{
    int a[1222];
    void start()
    {
        memset(a,0,4888);
        a[0]=a[1]=1;
    }
    ll& operator *=(int x)
    {
        for(int i=1;i<=a[0];i++)
            a[i]*=x;
        for(int i=1;i<=a[0];i++)
            a[i+1]+=a[i]/10,a[i]%=10,a[0]+=(i==a[0]&&a[i+1]);
        return *this;
    }
    void out()
    {
        for(int i=a[0];i>0;i--)
            printf("%d",a[i]);
        puts("");
    }
};
```
    - **核心思想**：通过结构体封装高精度数，重载乘法运算符实现高精度乘低精度，方便操作和代码复用。

### 最优关键思路或技巧
- 对 `R` 先取模 `26`，避免多余计算，防止字母后移时超出范围。
- 使用高精度乘法处理ASCII码相乘结果，避免数据溢出。可以使用简单的数组模拟，也可以封装成结构体或类，提高代码的可读性和可维护性。
- 压位高精可以减少计算次数，提高效率，如将4位压到一个 `int` 里面。

### 可拓展之处
同类型题或类似算法套路：
- 其他字符串编码转换问题，可能涉及不同的转换规则和处理方式。
- 高精度计算问题，如高精度加法、减法、除法等，可通过类似的数组模拟或结构体封装方法解决。
- 字符串处理与数学计算结合的问题，需要综合运用字符串操作和数学算法。

### 推荐题目
- P1009 [阶乘之和](https://www.luogu.com.cn/problem/P1009)：考察高精度加法和乘法。
- P1303 [A*B Problem](https://www.luogu.com.cn/problem/P1303)：单纯的高精度乘法问题。
- P2142 [高精度减法](https://www.luogu.com.cn/problem/P2142)：高精度减法的练习。

### 个人心得摘录与总结
- **作者：zombie462**：提到自己比赛前作为验题人，高精度半个小时没调出来，说明高精度问题在实际调试中可能存在一定难度。
- **作者：Alarm5854**：指出有人没看清 `R` 的最大值高达 `10^5` 而开 `long long` 导致 `WA`，提醒我们在做题时要仔细审题，注意数据范围。

---
处理用时：30.59秒
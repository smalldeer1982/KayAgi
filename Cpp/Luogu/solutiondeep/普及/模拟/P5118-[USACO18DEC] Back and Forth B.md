# 题目信息

# [USACO18DEC] Back and Forth B

## 题目描述

Farmer John 有两个挤奶棚，每个挤奶棚里各有一个奶罐和一个装有 $10$ 个各种尺寸的桶的储物柜。他喜欢将在两个挤奶棚之间来回运送牛奶作为一种锻炼方式。

周一，Farmer John 量了恰好 $1000$ 加仑的牛奶放在第一个挤奶棚的奶罐里，又量了恰好 $1000$ 加仑的牛奶放在第二个挤奶棚的奶罐里。

周二，他从第一个挤奶棚里取出一个桶，并装满牛奶，然后将牛奶运到第二个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第二个挤奶棚。

周三，他从第二个挤奶棚里取出一个桶（可能是周二留在这里的），并装满牛奶，然后将牛奶运到第一个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第一个挤奶棚。

周四，他从第一个挤奶棚里取出一个桶（可能是周三留在这里的），并装满牛奶，然后将牛奶运到第二个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第二个挤奶棚。

周五，他从第二个挤奶棚里取出一个桶（可能是周二或周四留在这里的），并装满牛奶，然后将牛奶运到第一个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第一个挤奶棚。

此时 Farmer John 测量了第一个挤奶棚的奶罐里的牛奶。他总共可能得到多少种不同的读数？


## 说明/提示

在这个例子中，最后第一个挤奶棚的奶罐中的牛奶量总共有 $5$ 种可能的结果：

$1000$：FJ 可以在每次往返的时候都携带同一个桶，从而不会改变第一个挤奶棚的奶罐的牛奶量。

$1003$：FJ 可以在周二运送 $2$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $1$ 个单位。

$1004$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $1$ 个单位。

$1007$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $2$ 个单位，周五 $5$ 个单位。

$1008$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $5$ 个单位。

## 样例 #1

### 输入

```
1 1 1 1 1 1 1 1 1 2
5 5 5 5 5 5 5 5 5 5```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕模拟四天内两个挤奶棚间牛奶桶的运输过程，以计算第一个挤奶棚最终奶量的不同可能性。整体可分为 DFS 模拟和暴力枚举两种思路。
- **DFS 模拟**：通过深度优先搜索模拟每天的运输情况，回溯时恢复状态。需记录桶的位置和奶量，避免重复结果。
- **暴力枚举**：直接枚举所有可能的桶的选择组合，用集合或映射去重。

### 高评分题解
- **作者：Alex_Wei（5 星）**
    - **关键亮点**：思路清晰，代码简洁，通过 DFS 模拟每天的运输情况，使用数组记录桶的位置，用 `vector` 存储结果，回溯操作明确。
    - **核心代码**：
```cpp
vector <int> ans;
int pd[22],t[22];
void dfs(int w,int m) {
    if(w/6) {
        for(int x=0;x<ans.size();x++)
            if(m==ans[x])return;
        ans.push_back(m);
        return;
    }
    for(int x=1;x<=20;x++) {
        if(w%2==0&&pd[x]==1) {
            pd[x]=2;
            dfs(w+1,m-t[x]);
            pd[x]=1;
        }
        if(w%2==1&&pd[x]==2) {
            pd[x]=1;
            dfs(w+1,m+t[x]);
            pd[x]=2;
        }
    }
}
```
- **作者：Polarnova（4 星）**
    - **关键亮点**：思路独特，通过分类讨论不同的桶选择情况进行暴力枚举，使用 `set` 自动去重，代码简洁高效。
    - **核心代码**：
```cpp
std::set<int> s;
int a[25];
int main() {
    for(int i=1;i<=20;i++)scanf("%d",&a[i]);
    for(int i=1;i<=10;i++) {
        for(int j=11;j<=20;j++)
            for(int k=i+1;k<=10;k++)
                for(int l=11;l<=20;l++)if(l!=j)s.insert(-a[i]+a[j]-a[k]+a[l]);
        for(int k=i;k<=10;k++)
                for(int l=11;l<=20;l++)s.insert(-a[k]+a[l]);
        for(int j=11;j<=20;j++)s.insert(-a[i]+a[j]);
        s.insert(0);
    }
    printf("%d",s.size());
    return 0;
}
```
- **作者：lzqy_（4 星）**
    - **关键亮点**：详细解释了 DFS 的思路，通过枚举桶的编号进行搜索，模拟过程虽繁琐但清晰，使用数组标记避免重复结果。
    - **核心代码**：
```cpp
int aa[10],bb[11],s[6],ans;
bool k[10000];
void moni() {
    int a[10],b[11];
    for(int i=0; i<10; i++)
        a[i]=aa[i],b[i]=bb[i];
    b[10]=a[s[1]];
    a[s[1]]=0;
    a[s[1]]=b[s[2]];
    b[s[2]]=0;
    b[s[2]]=a[s[3]];
    a[s[3]]=0;
    a[s[3]]=b[s[4]];
    b[s[4]]=0;
    if(!k[a[0]+a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]+a[8]+a[9]])
        ans++,k[a[0]+a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]+a[8]+a[9]]=1;
}
void dfs(int n) {
    if(n==5)
        moni();
    else
        for(int i=0; i<11; i++) {
            if(n%2==1&&i==10)
                break;
            s[n]=i;
            dfs(n+1);
        }
}
```

### 最优关键思路与技巧
- **使用集合或映射去重**：如 `set`、`map` 或数组标记，避免结果重复。
- **DFS 回溯**：在搜索过程中，改变状态后及时恢复，确保不影响后续搜索。
- **枚举编号而非奶量**：简化 DFS 过程，降低复杂度。

### 拓展思路
同类型题可拓展到更多操作次数或更多集合间的元素移动，可使用类似的 DFS 或暴力枚举思路。类似算法套路可用于解决状态转移类问题，如棋盘移动、物品分配等。

### 洛谷相似题目推荐
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：枚举组合，判断质数。
- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：DFS 搜索连通区域。
- [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)：回溯法解决棋盘放置问题。

### 个人心得摘录与总结
- **lzqy_**：建议对于 DFS 不熟练的人，枚举尽量简单，因为 DFS 难调试。总结：在使用复杂算法时，应简化枚举过程，降低调试难度。

---
处理用时：31.87秒
# 题目信息

# [YNOI2019] 骑单车

## 题目描述

小明每天早晨上课都需要骑着单车经过 $n$ 段路，第i段路的长度为$w_i (m)$，限速为 $s_i (m/s)$（在路上骑行的速度不能超过限速），加速度的绝对值最大为 $a_i (m/s^{2})$（可以加速也可以减速）。初始速度为 $0(m/s)$，你的任务是计算小明通过这 $n$ 段路的最短时间。

## 说明/提示

对于 $60\%$ 的数据：$0 < n \le60;$

对于 $80\%$ 的数据：$0 < n \le 80;$

对于 $100\%$ 的数据：$0 < n \le10^{2},w_i,s_i,a_i ≤ 10$。

## 样例 #1

### 输入

```
1
2
5 3 1
1 1 1
```

### 输出

```
4.6904157598```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致，都是利用物理运动学公式，通过贪心策略使速度尽可能大、加速度取最大绝对值来计算最短时间。题解先分析运动情况，确定每段路的速度限制，再分情况计算每段路的用时并累加。不同题解在思路阐述、公式推导、代码实现细节上存在差异。

### 所选题解
- **qjyzLfy（5星）**
    - **关键亮点**：思路清晰，对运动情况和速度限制分析透彻，结合 v - t 图像证明加速度取最大的合理性，详细推导公式，代码注释丰富，可读性强。
    - **核心代码**：
```cpp
// 缩小 vl 和 vr
do{
    flag=0;
    for(int i=1;i<=n;++i){
        if(vl[i]>vr[i-1]) vl[i]=vr[i-1],flag=1;
        if(vr[i]>vl[i+1]) vr[i]=vl[i+1],flag=1;
        if(vl[i]<vr[i]){
            tv=sqrt(vl[i]*vl[i]+2.0*a[i]*len[i]);
            if(vr[i]>tv) vr[i]=tv,flag=1;
        }
        else{
            tv=sqrt(vr[i]*vr[i]+2.0*a[i]*len[i]);
            if(vl[i]>tv) vl[i]=tv,flag=1;
        }
    }
}while(flag);

// 计算每段路用时
for(int i=1;i<=n;++i){
    tx1=(lim[i]*lim[i]-vl[i]*vl[i])/(2.0*a[i]);
    tx2=(lim[i]*lim[i]-vr[i]*vr[i])/(2.0*a[i]);
    if(tx1+tx2>len[i]){
        tv=sqrt(a[i]*len[i]+(vl[i]*vl[i]+vr[i]*vr[i])*0.5);
        ans+=(tv+tv-vl[i]-vr[i])/a[i];
    }
    else{
        ans+=(lim[i]+lim[i]-vl[i]-vr[i])/a[i]+(len[i]-tx1-tx2)/lim[i];
    }
}
```
- **Felis（4星）**
    - **关键亮点**：思路清晰，详细推导公式，分情况讨论全面，代码实现简洁，对数据类型使用有说明。
    - **核心代码**：
```cpp
for(int i=n-2; ~i; i--)
    r[i].v=min(r[i].v,sqrt((2.0*r[i].a*r[i].s+r[i+1].v*r[i+1].v)));
r[n].v=r[n-1].v;
for(int i=0; i<n; i++) {
    r[i].v=min(sqrt(pre*pre+2.0*r[i].a*r[i].s),r[i].v);
    double nxt=min(r[i].v,r[i+1].v);
    add.v=r[i].v-pre,add.s=(r[i].v+pre)*5.0/10.0*add.v/r[i].a;
    minus.v=r[i].v-nxt,minus.s=(r[i].v+nxt)*5.0/10.0*minus.v/r[i].a;
    if(r[i].s>=add.s+minus.s) {
        ans+=add.v/r[i].a+minus.v/r[i].a+(r[i].s-add.s-minus.s)/r[i].v;
        pre=min(r[i].v,r[i+1].v);
    } else {
        double v;
        v=sqrt((2.0*r[i].a*r[i].s+pre*pre+nxt*nxt)*5.0/10.0);
        ans+=(v-pre)/r[i].a+(v-nxt)/r[i].a;
        pre=min(v,r[i+1].v);
    }
}
```
- **DGFLSzfd（4星）**
    - **关键亮点**：知识前置部分详细推导物理公式，思路推理清晰，对影响速度峰值的因素分析全面，代码注释详细。
    - **核心代码**：
```cpp
for(int i=n-2;i>=0;i--) 
    r[i].v=min(r[i].v,sqrt(2.0*r[i].a*r[i].w+r[i+1].v*r[i+1].v));
r[n].v=r[n-1].v;
for(int i=0;i<n;i++){
    r[i].v=min(r[i].v,sqrt(2.0*r[i].a*r[i].w+speed*speed));
    long double v_next=min(r[i].v,r[i+1].v);
    long double speed_up  =(speed+r[i].v) *(r[i].v-speed) *0.5/r[i].a;
    long double speed_down=(v_next+r[i].v)*(r[i].v-v_next)*0.5/r[i].a;
    if(r[i].w>=speed_up+speed_down){
        ans+=(r[i].v-speed)/r[i].a+(r[i].v-v_next)/r[i].a+(r[i].w-speed_up-speed_down)/r[i].v;
        speed=v_next;
    }
    else{
        long double v_max=sqrt( (2.0*r[i].a*r[i].w+pow(speed,2)+pow(v_next,2) ) /2 );
        ans+=((v_max-speed)/r[i].a+(v_max-v_next)/r[i].a);
        speed=min(v_max,r[i+1].v);
    }
}
```

### 最优关键思路或技巧
- **贪心策略**：为使时间最短，加速和减速时都用最大加速度。
- **速度限制分析**：确定每段路开头和结尾的最大允许速度，通过约束条件不断缩小速度范围。
- **分情况讨论**：根据加速和减速路程与总路程的关系，分能加速到限速和不能加速到限速两种情况计算时间。

### 可拓展之处
同类型题可能会改变路况（如弯道、上下坡）、增加约束条件（如体力限制），类似算法套路是结合物理知识建立数学模型，通过贪心、动态规划等算法求解最优解。

### 推荐题目
1. P1429 平面最近点对（加强版）：结合计算几何和分治算法，与本题结合多学科知识求解的思路类似。
2. P1880 [NOI1995] 石子合并：运用动态规划思想，与本题分阶段处理问题的思路有相通之处。
3. P2014 [CTSC1997] 选课：树形动态规划问题，可锻炼分析问题和建立模型的能力。

### 个人心得摘录与总结
- **DGFLSzfd**：认为此题是优秀的跨学科题目，运用信息技术贪心、数学分类讨论和物理公式，修改多次才做对，强调物理知识对解题的重要性。
- **Felis**：觉得题目不难但很恶心，用 printf 输出会有精度错误。 

---
处理用时：39.31秒
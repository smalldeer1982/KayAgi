# 题目信息

# [USACO19OPEN] Fence Planning S

## 题目描述

Farmer John 的 $ N $ 头奶牛，编号为 $ 1 \ldots N $ （ $ 2 \leq N \leq 10^5 $ ），拥有一种围绕“哞网”，一些仅在组内互相交流却不与其他组进行交流的奶牛小组，组成的复杂的社交网络。

每头奶牛位于农场的二维地图上的不同位置 $ (x,y) $ ，并且我们知道有 $ M $ 对奶牛( $ 1 \leq M<10^5 $ )会相互哞叫。两头相互哞叫的奶牛属于同一哞网。

为了升级他的农场，Farmer John 想要建造一个四边与 $ x $ 轴和 $ y $ 轴平行的长方形围栏。Farmer John 想要使得至少一个哞网完全被围栏所包围（在长方形边界上的奶牛计为被包围的）。请帮助 Farmer John 求出满足他的要求的围栏的最小可能周长。有可能出现这一围栏宽为 $0$ 或高为 $0$ 的情况。

## 样例 #1

### 输入

```
7 5
0 5
10 5
5 0
5 10
6 7
8 6
8 4
1 2
2 3
3 4
5 6
7 6```

### 输出

```
10```

# AI分析结果

### 综合分析与结论
本题核心是找出无向图中各连通块，并计算能完全包围某一连通块的最小矩形周长。各题解主要采用 DFS 和并查集两种方法：
- **DFS 方法**：通过深度优先搜索遍历图，标记已访问节点，找出所有连通块，同时更新每个连通块对应的矩形边界，最终得到最小周长。
- **并查集方法**：利用并查集维护连通关系，将同一连通块的节点合并，在合并过程中更新连通块的矩形边界，最后计算各连通块的矩形周长并找出最小值。

### 所选题解
- **作者：Mkarry（5 星）**
    - **关键亮点**：思路清晰，详细解释了 DFS 方法的原理，代码注释丰富，还对时间复杂度进行了分析。
    - **核心代码**：
```cpp
void DFS(int step){
    vis[step]=1;
    U=max(U,a[step].y),D=min(D,a[step].y);
    R=max(R,a[step].x),L=min(L,a[step].x);
    for(int j=lik[step];j;j=nxt[j]) if(!vis[son[j]]) DFS(son[j]);
}
```
    - **核心思想**：从一个未访问节点开始，标记该节点为已访问，更新矩形的上下左右边界，然后递归访问其未访问的邻接节点。
- **作者：Zed_（4 星）**
    - **关键亮点**：思路明确，代码结构清晰，使用 `vector` 存储每个连通块的节点，便于后续处理。
    - **核心代码**：
```cpp
void dfs(int u, int col) {
    co[u] = col;
    size[col]++;
    vec[col].push_back(u);
    vis[u] = true;
    for (int i = head[u]; i; i = edge[i].next) {
        int v = edge[i].to;
        if (vis[v]) continue;
        dfs(v, col);
    }
}
```
    - **核心思想**：使用 DFS 遍历图，为每个连通块分配一个唯一的编号，将节点加入对应的连通块 `vector` 中。
- **作者：purinliang（4 星）**
    - **关键亮点**：采用并查集方法，在合并集合时直接更新连通块的矩形边界，时间复杂度接近 $O(n)$。
    - **核心代码**：
```cpp
bool union_set(int x,int y) {
    int fx=find_par(x);
    int fy=find_par(y);
    if(fx==fy) {
        return false;
    } else {
        par[fy]=fx;
        u[fx]=max(u[fx],u[fy]);
        d[fx]=min(d[fx],d[fy]);
        l[fx]=min(l[fx],l[fy]);
        r[fx]=max(r[fx],r[fy]);
        return true;
    }
}
```
    - **核心思想**：合并两个集合时，更新根节点对应的矩形上下左右边界。

### 最优关键思路或技巧
- **DFS 方法**：使用 `vis` 数组标记已访问节点，避免重复访问，确保每个节点只被访问一次，时间复杂度为 $O(n)$。
- **并查集方法**：路径压缩优化查找操作，在合并集合时直接更新连通块的矩形边界，减少额外的遍历操作。

### 可拓展之处
同类型题或类似算法套路：
- 计算无向图中连通块的其他属性，如面积、直径等。
- 处理有向图的连通性问题，可使用 Kosaraju 算法或 Tarjan 算法。

### 推荐题目
- [P1111 修复公路](https://www.luogu.com.cn/problem/P1111)：考察并查集的基本应用，用于维护连通性。
- [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)：经典的并查集题目，判断两个元素是否属于同一集合。
- [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)：并查集模板题，帮助巩固并查集的实现。

### 个人心得摘录与总结
- **作者：Qquun**：贡献了一组卡自己的数据 `2 1 100000000 100000000 0 0 1 2`，提醒我们在调试代码时要考虑边界情况和特殊数据。 

---
处理用时：28.47秒
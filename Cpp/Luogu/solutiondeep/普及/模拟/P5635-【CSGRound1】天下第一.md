# 题目信息

# 【CSGRound1】天下第一

## 题目背景

天下第一的 cbw 以主席的身份在 8102 年统治全宇宙后，开始了自己休闲的生活，并邀请自己的好友每天都来和他做游戏。由于 cbw 想要显出自己平易近人，所以 zhouwc 虽然是一个蒟蒻，也有能和 cbw 玩游戏的机会。

## 题目描述

游戏是这样的：

给定两个数 $x$，$y$，与一个模数 $p$。

cbw 拥有数 $x$，zhouwc 拥有数 $y$。

第一个回合：$x\leftarrow(x+y)\bmod p$。

第二个回合：$y\leftarrow(x+y)\bmod p$。

第三个回合：$x\leftarrow(x+y)\bmod p$。

第四个回合：$y\leftarrow(x+y)\bmod p$。

以此类推....

如果 $x$ 先到 $0$，则 cbw 胜利。如果 $y$ 先到 $0$，则 zhouwc 胜利。如果 $x,y$ 都不能到 $0$，则为平局。

cbw 为了捍卫自己主席的尊严，想要提前知道游戏的结果，并且可以趁机动点手脚，所以他希望你来告诉他结果。

## 说明/提示

$1 \leq T \leq 200$。

$1 \leq x,y,p \leq 10000$。

## 样例 #1

### 输入

```
1 10
1 3
```

### 输出

```
error```

## 样例 #2

### 输入

```
1 10
4 5
```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕游戏结果的判断展开，核心是模拟游戏过程并处理循环情况。主要思路有记忆化搜索、斐波那契数列规律应用和直接模拟三种。

记忆化搜索通过记录已访问状态避免重复计算，如使用`short`数组存储结果防止MLE；斐波那契数列规律则利用游戏中`x`和`y`的变化与斐波那契数列的关联判断循环；直接模拟就是按游戏规则依次更新`x`和`y`，并判断是否出现循环或为0。

### 所选题解
1. **作者：MY（一名蒟蒻）**
    - **星级**：5星
    - **关键亮点**：思路清晰，详细阐述了记忆化搜索的思路和遇到的问题及解决方法，代码注释丰富，可读性强。
    - **个人心得**：一开始代码本地编译不过，发现数据范围导致`int`数组会炸，通过使用`short`类型解决了内存问题。
    - **核心代码**：
```cpp
short book[10010][10010]; 
int rem(int x,int y)
{
    if(book[x][y] == -1) return -1;
    if(book[x][y]) return book[x][y];
    book[x][y]=-1;
    if(!x) return book[x][y]=1;
    if(!y) return book[x][y]=2;
    int num=(x+y)%mod;
    return book[x][y]=rem(num,(num%mod+y)%mod); 
}
```
核心思想是使用记忆化搜索，通过`book`数组记录已访问状态，避免重复计算。若`x`或`y`为0则返回相应结果，否则更新`x`和`y`继续递归。

2. **作者：mot1ve**
    - **星级**：4星
    - **关键亮点**：简洁明了地说明了使用`short`类型和记忆化搜索的思路，代码结构清晰。
    - **核心代码**：
```cpp
short f[10010][10010];
int cal(int x,int y)
{
    if(f[x][y]==-1)
        return 3;
    if(f[x][y])
        return f[x][y];
    f[x][y]=-1;
    if(x==0) return f[x][y]=1;
    if(y==0) return f[x][y]=2;
    return f[x][y]=cal((x+y)%mod,((x+y)%mod+y)%mod);
}
```
核心思想与上一题解类似，使用`f`数组记录状态，通过递归模拟游戏过程，若出现循环则返回3表示平局。

3. **作者：xiaohuang**
    - **星级**：4星
    - **关键亮点**：明确指出使用`short`类型的原因，通过循环次数判断平局情况，思路清晰。
    - **核心代码**：
```cpp
const int MAXN = 10005;
short dp[MAXN][MAXN];
inline short solve(int x, int y, int cnt) {
    if (cnt >= 10000) return 0;
    if (dp[x][y]) return dp[x][y];
    if (x == 0) return 1;
    if (y == 0) return 2;
    return dp[x][y] = solve((x + y) % mod, ((x + y) % mod + y) % mod, cnt + 1);
}
```
核心思想是记忆化搜索，使用`dp`数组记录结果，通过`cnt`判断是否出现平局，若`x`或`y`为0则返回相应结果，否则继续递归。

### 最优关键思路或技巧
- **使用`short`类型**：当数据范围不大且需要存储大量数据时，使用`short`类型可以有效减少内存占用，避免MLE。
- **记忆化搜索**：通过记录已访问状态，避免重复计算，提高算法效率。

### 可拓展之处
同类型题或类似算法套路：
- 涉及状态循环的模拟题，可使用记忆化搜索或判断循环节的方法。
- 与斐波那契数列相关的题目，可尝试寻找数列规律来优化算法。

### 推荐题目
- P1255 数楼梯：斐波那契数列的简单应用。
- P1028 数的计算：可使用记忆化搜索解决。
- P1464 Function：需要使用记忆化搜索避免重复计算。

---
处理用时：23.11秒
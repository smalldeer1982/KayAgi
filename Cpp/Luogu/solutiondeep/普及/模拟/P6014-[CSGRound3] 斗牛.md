# 题目信息

# [CSGRound3] 斗牛

## 题目背景

又是一年过去了。小 Z 在春节期间可以好好的放松放松，于是小 Z 和小伙伴们玩起了牛哄哄（斗牛）。

游戏规则是这样的：

给定 $5$ 张牌，分别从 $1 \sim 10$。你需要挑选其中的三张牌加起来是 $10$ 的倍数，另外两张牌的和的个位数则为你最后获得的点数，特别的，如果这两张牌的和是 $10$ 的倍数，则点数为 $10$，也叫做牛哄哄。如果不能构成 $10$ 的倍数，则点数为 $0$，也叫做牛不拢。

如 $5$ $3$ $2$ $3$ $4$ 的点数是 $7$，又叫做牛七。

小 Z 觉得玩的不过瘾，于是对上述规则进行了一些改变。

## 题目描述

给定 $n$ 张牌，牌的大小为 $1 \sim 10$。你需要挑选其中的 $n-2$ 张牌加起来是 $10$ 的倍数，另外两张牌和的个位数即为你所获得的点数。特别地，如果这两张牌的和是 $10$ 的倍数，则点数为 $10$，也叫做牛哄哄。如果任意 $n-2$ 张牌不能构成 $10$ 的倍数，则点数为 $0$，也叫做牛不拢。

由于小 Z 想要更开心的玩耍，所以需要你来完成这个程序来帮助小 Z 在 $1$ 秒内知道点数。

## 说明/提示

**【样例 1 解释】**

$10$ $10$ $10$ 三张牌凑成 $10$ 的倍数，$2+3=5$。

**【样例 2 解释】**

任意三张牌都不能凑成 $10$ 的倍数。

---

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（50 points）：$n = 5$。
- Subtask 2（30 points）：$n \le 5 \times 10^3$。
- Subtask 3（20 points）：无特殊限制。

对于 $100\%$ 的数据，$5 \le n \le 10^6$。



## 样例 #1

### 输入

```
5
10 10 10 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
5
3 4 5 6 7```

### 输出

```
0```

# AI分析结果

### 综合分析与结论
本题核心是从 $n$ 张 $1 - 10$ 的牌中选 $n - 2$ 张使其和为 $10$ 的倍数，剩余两张牌和的个位数为点数，若和为 $10$ 的倍数则点数为 $10$，否则为 $0$。各题解主要围绕如何高效选出这两张牌展开，多数采用枚举两张牌或利用总和与余数关系的思路。

### 高评分题解
- **wpy233（5星）**
    - **关键亮点**：思路清晰，详细阐述了从枚举 $n - 2$ 个数到枚举两个数再到不枚举的优化过程，代码简洁，注释详细。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[15];
long long ans=0;
int main()
{
    cin>>n;
    int x;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x);
        if(x==10) a[0]++;
        else a[x]++;
        ans+=x%10;
    }
    int t=ans%10;
    if(t==0) if(a[0]>=2||a[1]&&a[9]||a[2]&&a[8]||a[3]&&a[7]||a[4]&&a[6]||a[5]>=2) cout<<10<<endl; else cout<<0<<endl;
    // 其他 t 值判断类似
    return 0;
}
```
    - **核心思想**：先统计 $0 - 9$ 出现次数，计算所有数之和并取模，判断能否用两个数字组成和的模或模加 $10$。
- **StudyingFather（4星）**
    - **关键亮点**：结论推导清晰，通过分析得出选牌方式与最终点数无关，只需判断是否存在两张牌和的个位数等于所有牌点数和的个位数，代码简洁易懂。
    - **核心代码**：
```cpp
#include <iostream>
using namespace std;
int t[15];
int main()
{
    int n,ans=0;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        t[x%10]++;
        ans=(ans+x)%10;
    }
    for(int i=0;i<=9;i++)
        for(int j=i+1;j<=9;j++)
            if(t[i]&&t[j]&&(i+j)%10==ans)
            {
                cout<<(!ans?10:ans)<<endl;
                return 0;
            }
    for(int i=0;i<=9;i++)
        if(t[i]>=2&&(i+i)%10==ans)
        {
            cout<<(!ans?10:ans)<<endl;
            return 0;
        }
    cout<<0<<endl;
    return 0;
}
```
    - **核心思想**：记录每种牌出现次数，枚举两张不同牌和相同牌，判断其和的个位数是否等于所有牌点数和的个位数。
- **fls233666（4星）**
    - **关键亮点**：利用桶排序优化枚举，将复杂度降为常数级，代码中使用快速读入和输出提高效率。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring> 
#define rgt register int
#define ll long long
using namespace std;

int pks[11],n,s,p;

int main()
{
    bool fdans=false;
    n=rd();
    for(rgt i=1,x;i<=n;i++)
    {
        x=rd();
        pks[x]++;
        s+=x;
    }
    for(rgt i=0;i<=10;i++)
    {
        for(rgt j=0;j<=10;j++)
        {
            p=i+j;
            if((s-p)%10==0)
            {
                if(i==j)
                    fdans=pks[i]>=2?true:false;
                else
                    fdans=pks[i]&&pks[j]?true:false;
                if(fdans)
                {
                    print(!(p%10)?10:p%10);
                    return 0;
                }
            }
        }
    }
    print(0);
    return 0;
}
```
    - **核心思想**：用桶存储各种牌的数量，枚举两张牌的点数，扣除其点数后判断剩余牌点数和是否为 $10$ 的倍数，同时检查桶中是否有对应牌。

### 最优关键思路与技巧
- **逆向思维**：从枚举 $n - 2$ 张牌转变为枚举 $2$ 张牌，降低复杂度。
- **桶排序**：利用桶记录每种牌的出现次数，方便后续判断和枚举。
- **余数利用**：通过计算所有牌点数和的余数，快速确定目标点数，减少不必要的计算。

### 拓展思路
同类型题可拓展为从 $n$ 个数中选 $n - k$ 个数使其和为 $m$ 的倍数，剩余 $k$ 个数满足特定条件。类似算法套路为利用余数特性和逆向思维，将问题转化为更易处理的形式。

### 推荐题目
- P1047 [NOIP2005 普及组] 校门外的树：考察区间处理和模拟思想。
- P1094 [NOIP2007 普及组] 纪念品分组：涉及贪心算法和区间划分。
- P1217 [USACO1.5] 回文质数 Prime Palindromes：结合质数判断和回文数判断。

### 个人心得摘录与总结
- **时间重洗**：最初代码只找到第一种情况就退出，导致部分数据错误，如 `5 3 7 2 4 2` 会误判，改良后增加了判断相同数出现次数的逻辑。总结：在处理枚举情况时，要考虑全面，避免遗漏特殊情况。
- **peterwuyihong**：最初代码未考虑两个相同数需出现两次的情况，导致只有 $20$ 分，修改后通过。总结：处理枚举数对时，要注意特殊情况的判断，避免因逻辑不严谨导致错误。 

---
处理用时：41.70秒
# 题目信息

# [USACO20OPEN] Cereal S

## 题目描述

Farmer John 的奶牛们的早餐最爱当然是麦片了！事实上，奶牛们的胃口是如此之大，每头奶牛一顿饭可以吃掉整整一箱麦片。

最近农场收到了一份快递，内有 $M$ 种不同种类的麦片（$1\le M\le 10^5$）。不幸的是，每种麦片只有一箱！$N$ 头奶牛（$1\le N\le 10^5$）中的每头都有她最爱的麦片和第二喜爱的麦片。给定一些可选的麦片，奶牛会执行如下的过程：

- 如果她最爱的麦片还在，取走并离开。
- 否则，如果她第二喜爱的麦片还在，取走并离开。
- 否则，她会失望地哞叫一声然后不带走一片麦片地离开。

奶牛们排队领取麦片。对于每一个 $0\le i\le N-1$，求如果 Farmer John 从队伍中移除前 $i$ 头奶牛，有多少奶牛会取走一箱麦片。

## 说明/提示

### 样例解释
如果至少两头奶牛留下，那么恰有两头奶牛取走了一箱麦片。

### 子任务
- 测试点 $2$-$3$ 满足 $N,M\le 10^3$。
- 测试点 $4$-$10$ 没有额外限制。

## 样例 #1

### 输入

```
4 2
1 2
1 2
1 2
1 2```

### 输出

```
2
2
2
1```

# AI分析结果

### 综合分析与结论
本题主要求解移除前 $i$ 头奶牛后能取到麦片的奶牛数量。大部分题解采用倒序处理的思路，避免了正向删除奶牛带来的复杂连锁反应。通过倒序添加奶牛，利用新奶牛优先级高的特性，处理麦片冲突，将时间复杂度从暴力的 $O(N^2)$ 优化到 $O(N)$。

### 所选题解
- **PersistentLife（5星）**
    - **关键亮点**：思路清晰，详细阐述了从暴力枚举到优化的过程，代码注释丰富，易于理解。
    - **核心代码**：
```cpp
struct cow {
    int f, s;
} c[N];
int h[N], res[N], n, m, cur;
void solve(int x, int y) {
    if (h[y] == 0) {
        h[y] = x;
        cur++;
    } else if (h[y] > x) {
        int z = h[y];
        h[y] = x;
        if (y == c[z].f) solve(z, c[z].s);
    } 
}
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> c[i].f >> c[i].s;
    for (int i = n - 1; i >= 0; i--) solve(i + 1, c[i + 1].f), res[i + 1] = cur;
    for (int i = 1; i <= n; i++) cout << res[i] << endl;
    return 0;
}
```
    - **核心实现思想**：`solve` 函数用于处理当前奶牛选麦片的情况，若麦片未被选则直接拿走，若被选且当前奶牛优先级高则抢走，让原拥有者重新选择。倒序遍历奶牛，不断更新答案。

- **super蒟蒻（4星）**
    - **关键亮点**：提供了顺着推的独特思路，利用差分和前缀和处理答案，代码简洁。
    - **核心代码**：
```cpp
const int maxn = 1000005;
int n, m;
int p[maxn], s[maxn];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        int a, b;
        scanf("%d%d", &a, &b);
        ++s[min(p[a], p[b]) + 1];
        --s[i + 1];
        p[b] = max(p[b], p[a]);
        p[a] = i;
    }
    for (int i = 1; i <= n; i++) printf("%d\n", s[i] += s[i - 1]);
    return 0;
}
```
    - **核心实现思想**：维护 $p$ 数组记录每种麦片最后被拿的牛的编号，通过差分处理每头奶牛能拿到麦片的时间点，最后前缀和得到答案。

- **Na2PtCl6（4星）**
    - **关键亮点**：思路明确，代码结构清晰，详细解释了倒序处理的逻辑。
    - **核心代码**：
```cpp
const int maxn = 100004;
int n, m, cnt, vis[maxn], res[maxn], f[maxn], s[maxn];
void solve(int cow) {
    int fir = f[cow], sec = s[cow];
    if (!vis[fir]) {
        ++cnt;
        vis[fir] = cow;
        return;
    }
    if (vis[fir] > cow) {
        int t = vis[fir];
        vis[fir] = cow;
        solve(t);
        return;
    }
    if (!vis[sec]) {
        ++cnt;
        vis[sec] = cow;
        return;
    }
    if (vis[sec] > cow) {
        int t = vis[sec];
        vis[sec] = cow;
        solve(t);
    }
}
int main() {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d %d", &f[i], &s[i]);
    for (int i = n; i > 0; i--) {
        solve(i);
        res[i] = cnt;
    }
    for (int i = 1; i <= n; i++) printf("%d\n", res[i]);
    return 0;
}
```
    - **核心实现思想**：`solve` 函数处理当前奶牛选麦片，若最喜欢的未被选则拿走，若被选且优先级高则抢走，让原拥有者重新选，倒序遍历更新答案。

### 最优关键思路或技巧
- **倒序处理**：将删除奶牛转化为添加奶牛，利用新奶牛优先级高的特点，简化了麦片冲突的处理，降低了时间复杂度。
- **递归解决冲突**：当新奶牛抢走其他奶牛的麦片时，递归让被抢的奶牛重新选择，保证了处理的完整性。

### 可拓展之处
同类型题可能会增加奶牛的喜好数量、麦片种类或添加其他限制条件。类似算法套路可用于解决资源分配、排队选择等问题，关键在于处理资源冲突和优先级。

### 推荐题目
- P1199 [NOIP2010 普及组] 三国游戏
- P1223 排队接水
- P1090 [NOIP2004 提高组] 合并果子

### 个人心得摘录与总结
- **_edge_**：做本题花了1h才AC，最初使用 $O(n^2)$ 暴力解法只能得30分。正向思考第一个答案和第二个答案的联系难以维护，后来尝试反向处理，发现虽然看似还是 $O(n^2)$，但实际上由于连锁反应中前一步会被替代，整体复杂度变为 $O(n)$。总结为遇到正向难以处理的问题时可尝试反向思考。 

---
处理用时：34.27秒
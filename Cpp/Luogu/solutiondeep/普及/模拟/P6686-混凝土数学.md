# 题目信息

# 混凝土数学

## 题目描述

你正在看混凝土数学，这时旁边的工地开工了，你觉得看他们施工更有意思，于是你向窗外望去，注意到了一些长度不同的木棍。具体而言，你看到了 $n$ 条木棍编号为 $1,2,3,\ldots,n$，长度为 $a_1,a_2,a_3,\ldots,a_n$。你突发奇想：有多少拿出其中 $3$ 条木棍的方案满足它们能构成等腰三角形呢？你不想要输出的数太大，所以最后的方案要对 $998244353$ 取模。

给出等腰三角形的要求：任意两边之和大于第三边且至少有两条边边长相等。

例如，如果木棍长度分别为 $\{3,3,2,2,4,5\}$，你就有 $6$ 种方法，选取的木棍编号分别为：$\{1,2,3\}$，$\{1,2,4\}$，$\{1,2,5\}$，$\{1,2,6\}$，$\{1,3,4\}$，$\{2,3,4\}$。

## 说明/提示

- Subtask1 （$30$ pts）：$1\leq n \leq 200$。
- Subtask2 （$30$ pts）：$1\leq n \leq 2000$。
- Subtask3 （$20$ pts）：木棍长度全部相等。
- Subtask4 （$20$ pts）：无特殊限制。

对于 $100\%$ 的数据满足：$1\leq n \leq 2\times 10^5$，$1\leq a_i \leq 2\times 10^5$。

## 样例 #1

### 输入

```
6
3 3 2 2 4 5```

### 输出

```
6```

## 样例 #2

### 输入

```
6
1 1 4 5 1 4
```

### 输出

```
5```

## 样例 #3

### 输入

```
6
2 2 2 2 2 2```

### 输出

```
20```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何从给定的木棍中找出能构成等腰三角形的组合数展开。思路大多是先统计每种长度木棍的数量，再根据等腰三角形的性质（两边之和大于第三边且至少两边相等）进行分类讨论，计算出等边三角形和非等边等腰三角形的组合数并求和。

在算法实现上，不同题解采用了不同的方法和优化策略。部分题解使用了暴力枚举，适用于数据规模较小的情况；而对于大规模数据，多数题解采用了桶计数、前缀和优化、二分查找等方法，以降低时间复杂度。

### 所选题解
- **wuyonghuming（5星）**
    - **关键亮点**：思路清晰，代码简洁，通过枚举腰长并结合前缀和优化，有效降低了时间复杂度。同时详细说明了乘法原理的分类讨论过程，对等边三角形和等腰三角形的组合数计算进行了清晰的推导。
    - **核心代码**：
```c
#include <stdio.h>
long long f[200001],ans;
int main()
{	
	int n,m=0,k=0,l=1,a;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a);
		f[a]++;
		m=m<a?a:m;
	}
	for(int i=1;i<=m;i++)
	{
		for(;l<i*2&&l<=m;l++)
			k+=f[l];
		ans+=(f[i]-1)*f[i]*(k-f[i])/2+(f[i]-2)*(f[i]-1)*f[i]/6;
	}
	printf("%lld",ans%998244353);
	return 0;
}
```
    - **核心实现思想**：首先使用数组 `f` 记录每种长度木棍的数量，并找出最长木棍的长度 `m`。然后枚举每一个可能的腰长 `i`，通过内层循环计算能与该腰长构成三角形的木棍总数 `k`。最后根据乘法原理，计算出以该腰长构成的等边三角形和等腰三角形的组合数，并累加到答案 `ans` 中。

- **monstersqwq（4星）**
    - **关键亮点**：利用桶计数和前缀和优化，思路简洁明了。代码实现清晰，对可能出现的爆 `int` 问题进行了提醒，具有一定的健壮性。
    - **核心代码**：
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
using namespace std;
long long n,a[200005],c[400005],sum[400005];
long long ans=0;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		c[a[i]]++;
	}
	for(int i=1;i<=4e5;i++)
	{
		sum[i]=sum[i-1]+c[i];
	}
	for(int i=1;i<=2e5;i++)
	{
		if(c[i]>=2)
		{
			ans=(ans+c[i]*(c[i]-1)*(sum[i*2-1]-c[i])/2+c[i]*(c[i]-1)*(c[i]-2)/6)%998244353;
		}
	}
	cout<<ans<<endl;
    return 0;
}
```
    - **核心实现思想**：使用数组 `c` 记录每种长度木棍的数量，通过前缀和数组 `sum` 快速计算出长度小于等于某个值的木棍总数。然后枚举腰长 `i`，当该腰长的木棍数量不少于 2 时，计算以该腰长构成的等边三角形和等腰三角形的组合数，并累加到答案 `ans` 中。

- **lcy09（4星）**
    - **关键亮点**：思路清晰，对问题进行了详细的分析，推导出了计算答案的公式。代码实现简洁，通过桶和前缀和优化，有效降低了时间复杂度。
    - **核心代码**：
```cpp
#define int long long
using namespace std;
const int MAXN=200005;
const int mod=998244353;
int n;
int bin[MAXN],Max;
int sum[MAXN];
int ans;
signed main()
{
    cin>>n;
    for(int i=1;i<=n;i++) 
    {
        int l;
        scanf("%lld",&l);
        bin[l]++;
        Max=max(Max,l);
    }
    for(int i=1;i<=Max;i++) sum[i]=sum[i-1]+bin[i];
    for(int i=1;i<=Max;i++)
    {
        if(bin[i]>=2)
        {
            int temp=sum[min(2*i-1,Max)]-bin[i];
            temp=temp*bin[i]*(bin[i]-1)/2%mod;
            ans=(ans+temp)%mod;
            if(bin[i]>2)
            {
                ans+=(bin[i]*(bin[i]-1)*(bin[i]-2)/6)%mod;
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
    - **核心实现思想**：使用数组 `bin` 记录每种长度木棍的数量，并找出出现过的最大长度 `Max`。通过前缀和数组 `sum` 快速计算出长度小于等于某个值的木棍总数。然后枚举腰长 `i`，当该腰长的木棍数量不少于 2 时，计算以该腰长构成的等边三角形和等腰三角形的组合数，并累加到答案 `ans` 中。

### 最优关键思路或技巧
- **桶计数**：使用数组记录每种长度木棍的数量，方便后续统计和计算。
- **前缀和优化**：通过预处理前缀和数组，能够在 $O(1)$ 时间内计算出长度小于等于某个值的木棍总数，从而降低时间复杂度。
- **分类讨论**：将等腰三角形分为等边三角形和非等边等腰三角形进行分类讨论，分别计算组合数，最后求和。

### 可拓展之处
同类型题可能会改变木棍的条件，如增加木棍的属性（颜色、重量等），或者改变三角形的构成条件（如直角等腰三角形）。类似算法套路可以应用于其他组合计数问题，如从多个集合中选取元素组成满足特定条件的组合。

### 推荐题目
- [P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)：考察组合数的生成和输出。
- [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)：考察全排列的生成和输出。
- [P2036 [COCI2008-2009#2] PERKET](https://www.luogu.com.cn/problem/P2036)：考察组合枚举和条件判断。

### 个人心得摘录与总结
- **sfmmdm**：在月赛时沉迷于第三题，这题搜索只过了 50 分。总结是要合理分配时间，遇到难题不要死磕，先解决有把握的题目。
- **J与M等于Y**：通过这道题掌握了桶、前缀和和排列组合在实际问题中的应用，体会到了算法优化的重要性。

---
处理用时：47.81秒
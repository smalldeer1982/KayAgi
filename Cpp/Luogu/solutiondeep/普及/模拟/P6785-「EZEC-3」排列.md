# 题目信息

# 「EZEC-3」排列

## 题目描述

pigstd 有一堆数，他想在这么多数中选出若干个数排成一列，记为 $x_{1},x_{2},\cdots,x_{p}$（$p$ 为数的个数）。

这一列数合法**当且仅当**满足以下条件：

- $p \ge 2$。
- 令 $y_{i} = x_{i + 1} - x_{i}$（特别的，$y_{p}=x_{1}-x_{p}$），如果把 $y_{1}$ 到 $y_{p}$ 按 $y_1,y_2,\cdots,y_p$ 的顺序排成**一圈**，那么每两个相邻的数互为相反数且绝对值都为 $k$。

pigstd 想知道，在所有合法的数列中，所有在这个数列中的数之和**最大**是多少。

## 说明/提示

**【样例 1 说明】**

当 pigstd 的排列为：$0,3,0,3$ 或 $3,0,3,0$ 时，总和最大，为 $6$。

**【数据规模与约定】**

对于 $100\%$ 的数据，$1 \le n \le 10^6$，$0 \le k,a_{i} \le 10^6$，$1 \le b_{i} \le 10^6$。

**本题采用捆绑测试。**

- Subtask 1（5 points）：保证无合法的数列；
- Subtask 2（15 points）：$k = 0$；
- Subtask 3（5 points）：$n = 1$；
- Subtask 4（5 points）：$n = 2$；
- Subtask 5（30 points）：$n,k,a_i,b_i \le 10^3$；
- Subtask 6（40 points）：无特殊限制。

## 样例 #1

### 输入

```
4 3 
1 5
2 4
3 3
0 2```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
这些题解的核心思路一致，均是根据题目条件推出合法序列只能由一个数（$k = 0$ 时）或两个差值为 $k$ 的数交替组成，然后通过枚举数并结合每个数的出现次数来计算最大序列和，同时对 $k = 0$ 的情况进行特判。

算法要点在于使用桶排序的思想，用数组记录每个数的出现次数，枚举数时计算序列和并更新最大值。

难点主要是 $k = 0$ 的特判，需保证序列长度至少为 2，以及处理无解的情况。

### 高评分题解
- **作者：pigstd（5星）**
    - 关键亮点：思路清晰，代码简洁，对 $k = 0$ 和正常情况的处理逻辑明确，注释详细。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int M=1e6+10;
int sum[M*2],n,k,maxn,ans=-1;

signed main()
{
    cin>>n>>k;
    for (int i=1;i<=n;i++)
    {
        int a,b;
        cin>>a>>b;
        sum[a]+=b,maxn=max(maxn,a);
    }
    if (k==0)
    {
        for (int i=0;i<=maxn;i++)
            if (sum[i]!=1&&sum[i])
                ans=max(ans,i*sum[i]);
        if (ans==-1)cout<<"NO";
        else cout<<ans;
        return 0;
    }
    for (int i=0;i<=maxn;i++)
    {
        int j=i+k;
        if (sum[i]&&sum[j])
            ans=max(ans,min(sum[i],sum[j])*(i+j));
    }
    if (ans==-1)cout<<"NO";
    else cout<<ans;
    return 0;
}
```
核心实现思想：先读取输入，统计每个数的出现次数并记录最大数。对于 $k = 0$ 的情况，枚举每个数，若其出现次数大于 1 则更新最大和；对于 $k \neq 0$ 的情况，枚举每个数，若该数和该数加 $k$ 都存在，则计算序列和并更新最大和。最后根据最大和是否为 -1 输出结果。

- **作者：JRzyh（4星）**
    - 关键亮点：代码简洁，思路清晰，对差分的分析有助于理解题意。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,a[1000008],ans=-1;
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        int x,b;
        cin>>x>>b;
        a[x]+=b;
    }
    for(long long i=0;i<=1000000-k;i++)
    {
        if(a[i]!=0&&a[i+k]!=0)
        {
            int res=0;
            if(k==0)res=i;
            else res=(i+i+k);
            if(min(a[i],a[i+k])!=1)ans=max(ans,res*min(a[i],a[i+k]));
        }
    }
    if(ans==-1)cout<<"NO"<<endl;
    else cout<<ans<<endl;
    return 0;
}
```
核心实现思想：读取输入，统计每个数的出现次数。枚举每个数，若该数和该数加 $k$ 都存在，根据 $k$ 的值计算序列和，更新最大和。最后根据最大和是否为 -1 输出结果。

- **作者：_0x46EDC（4星）**
    - 关键亮点：推导过程详细，对细节处理的说明清晰，代码简洁。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
#define N 1000001
using namespace std;
typedef long long ll;
ll n,k,x[N],ans=-1;
bool flag;
int main(){
    cin>>n>>k;
    for(ll i=1,a,b;i<=n;i++){
        cin>>a>>b;
        x[a]+=b;
    }
    for(ll i=0;i<N-k;i++){
        if(!(x[i]&&x[i+k])||(k==0&&x[i]<2))continue;
        if(k==0)ans=max(ans,x[i]*i);
        else ans=max(ans,min(x[i+k],x[i])*(2*i+k));
    }
    if(ans==-1)cout<<"NO"<<endl;
    else cout<<ans<<endl;
    return 0;
}
```
核心实现思想：读取输入，统计每个数的出现次数。枚举每个数，若该数和该数加 $k$ 都存在且满足 $k = 0$ 时该数出现次数大于 1 的条件，根据 $k$ 的值计算序列和，更新最大和。最后根据最大和是否为 -1 输出结果。

### 最优关键思路或技巧
- **桶排序思想**：使用数组记录每个数的出现次数，方便后续枚举和计算。
- **特判处理**：对 $k = 0$ 的情况进行特判，保证序列长度至少为 2。
- **边界处理**：将最大和初始化为 -1，方便判断无解的情况。

### 拓展思路
同类型题或类似算法套路：
- 此类题目可拓展到更复杂的序列构造问题，如序列的差值规律更复杂，可通过类似的分析方法找出序列的组成规律，再进行枚举和计算。
- 可结合动态规划思想，处理更复杂的条件限制，如序列长度有范围限制等。

### 推荐题目
- P1164 小A点菜：考察枚举和动态规划思想，与本题的枚举思路有一定相似性。
- P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles：涉及动态规划的状态转移，可锻炼分析序列规律和计算最优解的能力。
- P1048 采药：经典的 0 - 1 背包问题，需要枚举物品并计算最优解，与本题的枚举和求最大值的思路类似。

### 个人心得摘录与总结
- **作者：zyk7**：提到完全暴力枚举时间复杂度高，只能得 70 分，可使用类似桶排序的数组优化，总结出在处理有固定差值关系的数据时，可使用桶排序思想优化枚举过程。
- **作者：wuyonghuming**：提醒注意 $k = 0$ 且 $b_i = 1$ 无法构成序列、全 0 序列也是合法方案、答案可能达到 $10^{18}$ 需选择合适变量类型以及 $a_i$ 可能相同需累加个数等细节，强调了处理此类问题时要仔细考虑各种边界情况和特殊条件。 

---
处理用时：45.57秒
# 题目信息

# 最大公约数

## 题目背景

&emsp;&emsp;“寻求最大公约数是人民民主的真谛。……”

&emsp;&emsp;初秋，从枝丫滴下的阳光，柔和，在教室的窗棱溅起，润湿晨读的少女的脸颊。

&emsp;&emsp;“阿绫，阿绫”，天依低俯身子，八字辫耷拉在竖起的课本沿，“我们的最大公约数是多少呢？”

&emsp;&emsp;“一定不小吧”，左手悄悄捏捏天依的小臂，“比如呀，有一个公因子，叫做‘你喜欢我，我也喜欢你’。”

## 题目描述

相反，人际圈形形色色，公约数小得可怜，似乎很难保持自己的个性因而变成无趣的人呢。

现在把人际抽象成一个 $n \times m$ 的矩形，每个人初始的个性为 $a_{i,j}$。从第二天开始，每个人会与上下左右四个人（如果存在）建立人际关系，其个性变为昨天自己和四周人个性的最大公约数。那么对于第 $x$ 行第 $y$ 列的人，在多少天后他的个性会变为 $1$ 呢？

----

#### 简化题意

有一个 $n \times m$ 的矩阵 $a$。对一个矩阵进行变换，定义为将这个矩阵内的所有元素变为其上下左右四个元素（不存在则忽略）及自身的最大公约数。询问 $a_{x,y}$ 在进行最少多少次变换之后会变成 $1$。如果可以使 $a_{x,y}$ 经过若干次变换变成 $1$，输出其中最小的次数；否则输出 $-1$。

## 说明/提示

#### 样例解释 3
第一天的个性矩阵（也就是最开始的矩阵）为
$$
\begin{pmatrix}
3&2&3\\
2&3&2\\
3&2&3
\end{pmatrix}
$$
第二天的个性矩阵为
$$
\begin{pmatrix}
1&1&1\\
1&1&1\\
1&1&1
\end{pmatrix}
$$
可见只需要经过一天，$a_{2,2}$ 就会变为 $1$，所以答案为 $1$。

#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^3$，$1\le a_{i,j}\le 10^{18}$，$1\le x\le n$，$1\le y\le m$。

| 子任务 | 分值 |        $n,m$        |              特殊限制              |
| :----: | :--: | :-----------------: | :--------------------------------: |
|   1    |  1   |          /          | 保证给出的位置个性永远不会变为 $1$ |
|   2    |  1   |          /          |          保证 $a_{x,y}=1$          |
|   3    |  3   |      $ \le 2$       |                 /                  |
|   4    |  10  |     $ \le 10^2$     |                 /                  |
|   5    |  30  | $ \le 5\times 10^2$ |           /            |
|   6    |  10  |          /          |   保证对于所有的 $a_{i,j} \le 2$   |
|   7    |  10  |          /          |     保证 $x$ 与 $y$ 都等于 $1$     |
|   8    |  35  |          /          |                 /                  |





------------




## 样例 #1

### 输入

```
2 2
2 2
1 2
2 1```

### 输出

```
0```

## 样例 #2

### 输入

```
2 2
2 2 
2 2
1 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
3 3
3 2 3
2 3 2
3 2 3
2 2```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕矩阵元素变换求最大公约数，使指定位置元素变为 1 的最少变换次数展开。核心思路是利用最大公约数性质和曼哈顿距离，通过广度优先搜索（BFS）或枚举曼哈顿距离的方式求解。

### 所选题解
- **作者：vectorwyx（5星）**
    - **关键亮点**：思路清晰，先阐述嵌套 gcd 的结论，将问题转化为 BFS 过程，代码简洁易读。
    - **核心代码**：
```cpp
void bfs(){
    queue<int> qx,qy,qs;
    qx.push(sx),qy.push(sy),qs.push(0);
    vis[sx][sy]=1;
    ll sum=a[sx][sy];
    while(!qx.empty()){
        int x=qx.front(),y=qy.front(),s=qs.front();
        qx.pop(),qy.pop(),qs.pop();
        fo(i,0,3){
            int tx=x+dx[i],ty=y+dy[i];
            if(tx<1||tx>n||ty<1||ty>m||vis[tx][ty]) continue;
            vis[tx][ty]=1;
            qx.push(tx),qy.push(ty),qs.push(s+1);
            sum=__gcd(sum,a[tx][ty]);
            if(sum==1){
                cout<<s+1;
                return;
            }
        }
    }
    cout<<-1;
}
```
    - **核心实现思想**：以指定位置为起点进行 BFS，每次扩展相邻节点，更新当前的 gcd 值，若 gcd 为 1 则输出步数，否则继续扩展，若队列为空仍未得到 1 则输出 -1。

- **作者：Just_A_King（4星）**
    - **关键亮点**：详细分析题意，引入曼哈顿距离概念，对时间复杂度进行了分析。
    - **核心代码**：
```cpp
while(ans!=1 &&!q.empty()){
    ++day;
    while(!q.empty() && dis(q.front())<day){
        for(ll i=1;i<=4;++i){//入队
            node mid=(node){q.front().x+way1[i],q.front().y+way2[i]};
            if(mid.x>=1&&mid.x<=n && mid.y>=1&&mid.y<=m && a[mid.x][mid.y]){
                ans=gcd(ans,a[mid.x][mid.y]);
                q.push(mid);a[mid.x][mid.y]=0;
            }
        }
        q.pop();//出队
    }
}
```
    - **核心实现思想**：以指定位置为中心进行 BFS 扩展，用 day 记录扩展的天数，每次扩展将相邻节点入队并更新 gcd 值，直到 gcd 为 1 或队列为空。

- **作者：TianLuen（4星）**
    - **关键亮点**：先分析错误解法，再给出正确解法，思路循序渐进，代码简洁。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        if(i!=x||j!=y)	//注意需要排除自身
        {
            int dis=abs(x-i)+abs(y-j);
            d[dis]=GCD(a[i][j],d[dis]);
        }
for(int i=1;i<=n+m;i++)
{
    d[i]=GCD(d[i-1],d[i]);
    if(d[i]==1)
    {
        cout<<i;
        return 0;	//提前结束程序
    }
}
```
    - **核心实现思想**：枚举矩阵中每个点，计算其与指定位置的曼哈顿距离，更新对应距离的 gcd 值，最后从前往后更新 gcd 值，若为 1 则输出距离。

### 最优关键思路或技巧
- **嵌套 gcd 性质**：嵌套形式的 gcd 的值等于原式中出现的数的 gcd，简化计算。
- **BFS 扩展**：将问题转化为 BFS 过程，从指定位置开始向外扩展，更新 gcd 值。
- **曼哈顿距离**：利用曼哈顿距离确定每个点对指定位置的影响步数。

### 拓展思路
同类型题可考虑在不同图形（如三角形、六边形）上进行元素变换求最大公约数，或改变变换规则（如变为相邻元素的和等）。类似算法套路可用于解决涉及矩阵元素更新和状态转移的问题。

### 推荐题目
- P1024 [一元三次方程求解](https://www.luogu.com.cn/problem/P1024)：涉及数学计算和枚举。
- P1047 [校门外的树](https://www.luogu.com.cn/problem/P1047)：矩阵操作和区间更新问题。
- P1060 [开心的金明](https://www.luogu.com.cn/problem/P1060)：动态规划和状态转移问题。

### 个人心得摘录与总结
- **WinterRain208**：手写辗转相除会比`__gcd`快一点，判断互质时若曼哈顿距离大于当前最优解就不用求公因数了。总结：在代码实现中要注意函数调用的效率，合理利用剪枝优化算法。 

---
处理用时：30.44秒
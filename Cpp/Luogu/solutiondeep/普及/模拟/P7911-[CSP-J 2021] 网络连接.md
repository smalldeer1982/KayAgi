# 题目信息

# [CSP-J 2021] 网络连接

## 题目描述

TCP/IP 协议是网络通信领域的一项重要协议。今天你的任务，就是尝试利用这个协议，还原一个简化后的网络连接场景。

在本问题中，计算机分为两大类：服务机（`Server`）和客户机（`Client`）。服务机负责建立连接，客户机负责加入连接。

需要进行网络连接的计算机共有 $n$ 台，编号为 $1 \sim n$，这些机器将按编号递增的顺序，依次发起一条建立连接或加入连接的操作。

每台机器在尝试建立或加入连接时需要提供一个地址串。服务机提供的地址串表示它尝试建立连接的地址，客户机提供的地址串表示它尝试加入连接的地址。

一个符合规范的地址串应当具有以下特征：

1. 必须形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为非负整数；
2. $0 \le a, b, c, d \le 255$，$0 \le e \le 65535$；
3. $a, b, c, d, e$ 均不能含有多余的前导 $0$。

相应地，不符合规范的地址串可能具有以下特征：

1. 不是形如 `a.b.c.d:e` 格式的字符串，例如含有多于 $3$ 个字符 `.` 或多于 $1$ 个字符 `:` 等情况；
2. 整数 $a, b, c, d, e$ 中某一个或多个超出上述范围；
3. 整数 $a, b, c, d, e$ 中某一个或多个含有多余的前导 $0$。

例如，地址串 `192.168.0.255:80` 是符合规范的，但 `192.168.0.999:80`、`192.168.00.1:10`、`192.168.0.1:088`、`192:168:0:1.233` 均是不符合规范的。

如果服务机或客户机在发起操作时提供的地址串不符合规范，这条操作将被直接忽略。

在本问题中，我们假定凡是符合上述规范的地址串均可参与正常的连接，你无需考虑每个地址串的实际意义。

由于网络阻塞等原因，不允许两台服务机使用相同的地址串，如果此类现象发生，后一台尝试建立连接的服务机将会无法成功建立连接；除此之外，凡是提供符合规范的地址串的服务机均可成功建立连接。

如果某台提供符合规范的地址的客户机在尝试加入连接时，与先前某台已经成功建立连接的服务机提供的地址串相同，这台客户机就可以成功加入连接，并称其连接到这台服务机；如果找不到这样的服务机，则认为这台客户机无法成功加入连接。

请注意，尽管不允许两台不同的服务机使用相同的地址串，但多台客户机使用同样的地址串，以及同一台服务机同时被多台客户机连接的情况是被允许的。

你的任务很简单：在给出每台计算机的类型以及地址串之后，判断这台计算机的连接情况。

## 说明/提示

**【样例解释 #1】**

计算机 $1$ 为服务机，提供符合规范的地址串 `192.168.1.1:8080`，成功建立连接；

计算机 $2$ 为服务机，提供与计算机 $1$ 相同的地址串，未能成功建立连接；

计算机 $3$ 为客户机，提供符合规范的地址串 `192.168.1.1:8080`，成功加入连接，并连接到服务机 $1$；

计算机 $4$ 为客户机，提供符合规范的地址串 `192.168.1.1:80`，找不到服务机与其连接；

计算机 $5$ 为客户机，提供的地址串 `192.168.1.1:99999` 不符合规范。

**【数据范围】**

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1$ | $10$ | 性质 1 2 3 |
| $2 \sim 3$ | $100$ | 性质 1 2 3 |
| $4 \sim 5$ | $1000$ | 性质 1 2 3 |
| $6 \sim 8$ | $1000$ | 性质 1 2 |
| $9 \sim 11$ | $1000$ | 性质 1 |
| $12 \sim 13$ | $1000$ | 性质 2 |
| $14 \sim 15$ | $1000$ | 性质 4 |
| $16 \sim 17$ | $1000$ | 性质 5 |
| $18 \sim 20$ | $1000$ | 无特殊性质 |

“性质 1”为：保证所有的地址串均符合规范；  
“性质 2”为：保证对于任意两台不同的计算机，如果它们同为服务机或者同为客户机，则它们提供的地址串一定不同；  
“性质 3”为：保证任意一台服务机的编号都小于所有的客户机；  
“性质 4”为：保证所有的地址串均形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为不超过 ${10}^9$ 且不含有多余前导 $0$ 的非负整数；  
“性质 5”为：保证所有的地址串均形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为只含有数字的非空字符串。

对于 $100 \%$ 的数据，保证 $1 \le n \le 1000$。

**【提供 hack 数据感谢】**  

- [xyf007](/user/68273)。

## 样例 #1

### 输入

```
5
Server 192.168.1.1:8080
Server 192.168.1.1:8080
Client 192.168.1.1:8080
Client 192.168.1.1:80
Client 192.168.1.1:99999
```

### 输出

```
OK
FAIL
1
FAIL
ERR
```

## 样例 #2

### 输入

```
10
Server 192.168.1.1:80
Client 192.168.1.1:80
Client 192.168.1.1:8080
Server 192.168.1.1:80
Server 192.168.1.1:8080
Server 192.168.1.999:0
Client 192.168.1.1.8080
Client 192.168.1.1:8080
Client 192.168.1.1:80
Client 192.168.1.999:0
```

### 输出

```
OK
1
FAIL
FAIL
OK
ERR
ERR
5
1
ERR
```

## 样例 #3

### 输入

```
见附件中的 network/network3.in。```

### 输出

```
见附件中的 network/network3.ans。```

## 样例 #4

### 输入

```
见附件中的 network/network4.in。```

### 输出

```
见附件中的 network/network4.ans。```

# AI分析结果

### 综合分析与结论
本题核心在于判断地址串合法性，并根据计算机类型（服务机或客户机）处理连接情况。各题解整体思路相近，先判断地址合法性，再用 `map` 或 `unordered_map` 处理服务机重复地址及客户机连接问题。主要差异在于地址合法性判断方法。

### 高评分题解
- **xyf007（5星）**
    - **关键亮点**：提供两种简洁做法。方法一用 `std::sscanf` 读取地址串，结合 `std::stringstream` 拼接地址判断合法性，代码简洁；方法二使用 C++11 的 `regex` 库，通过正则表达式判断地址合法性，思路清晰。
    - **核心代码**
```cpp
// 方法一
bool Check(string s) {
  long long a, b, c, d, port;
  if (sscanf(s.c_str(), "%lld.%lld.%lld.%lld:%lld", &a, &b, &c, &d, &port)!= 5)  return false;
  if (a < 0 || a > 255 || b < 0 || b > 255 || c < 0 || c > 255 || d < 0 || d > 255 || port < 0 || port > 65535)  return false;
  stringstream ss;
  ss << a << '.' << b << '.' << c << '.' << d << ':' << port;
  return ss.str() == s;
}

// 方法二
regex r("(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5]):(\\d|[1-9]\\d{1,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])");
bool isValid = regex_match(a, r);
```
- **XYY1411（4星）**
    - **关键亮点**：详细讲解正则表达式判断 IP 合法性的方法，给出 C++ 和 Python 两种代码实现，适合学习正则表达式在字符串匹配中的应用。
    - **核心代码**
```cpp
inline bool check(const string &ip) {
    static const regex ippt("(((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\\:((6553[0-5])|(655[0-2][0-9])|(65[0-4][0-9][0-9])|(6[0-4][0-9][0-9][0-9])|([1-5][0-9][0-9][0-9][0-9])|([1-9][0-9][0-9][0-9])|([1-9][0-9][0-9])|([1-9][0-9])|[0-9])");
    return regex_match(ip, ippt);
}
```
- **我和鱼过不去（4星）**
    - **关键亮点**：详细列出地址串不规范的所有可能形式，并给出针对性解决方案，思路严谨，代码实现清晰。
    - **核心代码**
```cpp
bool check(string s)
{
    int len = s.length();
    long long tmp = 0;
    int cnt1=0,cnt2=0,cnt3=0;
    for(int i=0;i<len;i++)
    {
        if((i==0||(s[i-1]=='.'||s[i-1]==':'))&&s[i]>='0'&&s[i]<='9') cnt3++;
        if(s[i]=='.'||s[i]==':')
        {
            if(s[i]=='.') cnt1++;
            else if(s[i]==':') cnt2++;
            if(cnt1<3&&cnt2) return false;
            if(!cnt3) return false;
            if(0<=tmp&&tmp<=255) 
            {
                tmp = 0;
                continue;
            }
            else return false;
        }
        else if(s[i]<'0'||s[i]>'9') return false;
        if(i&&!tmp&&s[i-1]=='0') return false;
        tmp = tmp*10+s[i]-'0';
    }
    if(cnt1!=3||cnt2!=1||cnt3!=5) return false;
    if(0<=tmp&&tmp<=65535) return true;
    else return false;
}
```

### 最优关键思路或技巧
- **使用 `map` 或 `unordered_map`**：以地址串为键，服务机编号为值，快速判断服务机地址是否重复，以及客户机能否连接到服务机。
- **正则表达式**：利用正则表达式简洁判断地址串是否符合格式要求，减少手动判断的复杂度。
- **反向拼接判断**：用 `std::sscanf` 读取地址串中的数字，再用 `std::stringstream` 或 `sprintf` 拼接成地址串，与原串比较，可有效处理前导 0 问题。

### 可拓展之处
同类型题可能涉及更复杂的字符串格式判断，如 IP 地址段匹配、URL 合法性判断等。类似算法套路包括使用正则表达式、字符串模拟、状态机等进行字符串处理。

### 推荐题目
- P1169 [ZJOI2007] 棋盘制作：涉及字符串处理和动态规划，需判断棋盘状态并计算最大矩形。
- P1057 传球游戏：字符串模拟与递推结合，根据传球规则计算传球方案数。
- P1598 垂直柱状图：字符串处理和图形输出，需对输入字符串进行统计和图形绘制。

### 个人心得摘录与总结
- **Shunpower**：考场上因少写一句 `return true;` 导致 RE，从一等奖变三等奖，提醒大家编码时要仔细检查边界条件和返回值。
- **Astatinear**：考场上 `wrong answer 65`，错因是判断 `err` 时未处理好前导零、符号顺序和无数字输入的情况，强调判断错误条件时要细心，可自己构造测试数据。
- **mcDinic**：考场上因不会 fc 只拿 75 分，重打后 AC，说明要掌握基本工具和调试方法，遇到问题及时总结改进。 

---
处理用时：48.26秒
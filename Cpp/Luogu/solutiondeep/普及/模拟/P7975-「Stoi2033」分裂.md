# 题目信息

# 「Stoi2033」分裂

## 题目背景

> 趁时间没发觉 让我带着你离开  
> 没有了证明 没有了空虚  
> 基于两种立场我会罩着你  
> 趁时间没发觉 让我带着你离开  
> 这不是顽固 这不是逃避  
> 没人绑着你走才快乐  
> ——《分裂》

## 题目描述

有一个 $n \times m \times 2$ 的棋盒（四周为棋盒壁）与黑、红各 $nm$ 颗棋。棋子有若干种类，红色的一种棋子个数和黑色的该种棋子个数相等。棋子种类用特征值 $v_{i,j}$ 标记。特征值相同的棋子种类相同，特征值不同的棋子种类不同。红色棋子摆放在棋盒的下层，已经摆好。现在 Vinsta 要将黑棋按照规定顺序摆放在棋盒上层。设棋盒内坐标以左上角为 $(1,1)$，右下角为 $(n,m)$，依此第 $i$ 行第 $j$ 列为 $(i,j)$，则每颗摆进去的黑棋必须摆在满足以下要求的位置：

1. 其摆放位置没有黑棋子且下方为与其种类相同的红棋；

2. 在 1. 的要求下，若有多个，令一个位置的 **紧密度** 为其四边有黑棋子相邻或为棋盒壁的个数，则选择 **紧密度** 最大的一个；

3. 在 2. 的要求下，若还有多个，则设此位置的坐标为 $(i,j)$，要求 $i+j$ 最小；

4. 在 3. 的要求下，若还有多个，要求 $i$ 最小。

给出红棋的摆放情况和黑棋放入的顺序，她想请你帮忙求出每个位置的黑棋子被放入的顺序。

## 说明/提示

对于 $30\%$ 的数据，$1 \le n,m \le 70$；

对于另外 $30\%$ 的数据，$v_{i,j}=1$；

对于 $100\%$ 的数据，$1 \le n,m \le 10^3, 1 \le v_{i,j} \le 10$，保证每种棋子黑色与红色数量相等。

## 样例 #1

### 输入

```
3 3
1 1 1
1 1 1
1 1 1
1 1 1 1 1 1 1 1 1
```

### 输出

```
1 2 3
4 6 7
5 8 9
```

## 样例 #2

### 输入

```
3 3
1 2 3
2 2 1
3 1 3
1 3 3 2 1 2 2 3 1
```

### 输出

```
1 4 2
6 7 5
3 9 8
```

## 样例 #3

### 输入

```
10 10
4 9 3 9 3 6 4 8 7 7 
7 5 3 8 7 10 10 8 7 10 
10 9 3 10 3 3 3 2 3 8 
9 6 3 1 10 10 3 4 2 6 
10 5 9 9 5 7 7 6 2 7 
1 1 6 3 2 10 10 7 6 7 
1 7 10 7 3 10 3 9 10 9 
1 5 1 2 2 4 4 9 10 8 
6 3 7 1 5 8 10 4 10 7 
5 4 8 3 3 9 2 6 8 2 
6 6 6 1 10 8 5 5 4 2 1 5 5 9 4 3 4 6 3 5 9 7 4 8 9 3 5 9 1 7 4 1 1 2 2 6 7 10 6 2 6 6 1 8 4 7 7 10 3 1 9 8 10 9 4 7 9 10 2 3 3 3 2 7 2 9 7 7 3 8 8 9 3 2 10 9 10 7 8 10 8 3 7 7 3 3 7 3 7 3 3 10 3 10 10 10 10 10 10 10 
```

### 输出

```
9 14 16 28 49 1 15 24 37 46
22 12 26 79 84 94 92 70 56 53
5 21 61 80 85 93 91 63 62 6
25 18 60 50 58 95 90 23 34 3
38 13 51 54 20 87 89 39 59 64
29 32 36 69 74 97 96 78 42 67
11 30 48 68 86 98 88 76 77 72
4 8 33 40 35 31 45 57 99 81
2 19 47 43 27 71 75 55 100 83
7 17 52 73 82 66 65 41 44 10
```

# AI分析结果

### 综合分析与结论
本题主要是模拟黑棋在棋盒上层的摆放过程，关键在于如何高效地根据规则选择摆放位置。各题解均围绕优化模拟过程展开，主要思路是利用数据结构（如`set`、优先队列）来维护可摆放位置，避免直接模拟的高复杂度。

### 所选题解
- **VinstaG173（5星）**
    - 关键亮点：思路清晰，利用`set`维护每种棋子的可摆放位置，通过自定义结构体和比较函数实现排序，代码简洁高效，时间复杂度为$O(n^2\log{n})$。
    - 核心代码：
```cpp
struct bd
{
    int x,y;
    bool operator <(const bd &t)const
    {
        if(bs[x][y]==bs[t.x][t.y])
        {
            if(x+y==t.x+t.y)return x<t.x;
            return (x+y)<(t.x+t.y);
        }
        return bs[x][y]>bs[t.x][t.y];
    }
};
set<bd>S[13];
```
    - 核心思想：定义结构体`bd`表示位置，重载`<`运算符实现排序规则。使用`set`数组`S`维护每种棋子的可摆放位置，插入和删除操作的时间复杂度为$O(\log{n})$。

- **Lynkcat（4星）**
    - 关键亮点：使用优先队列优化，通过`priority_queue`维护不同格子种类和紧密度的位置，常数更小，时间复杂度为$O(5\times n^2 \log n)$。
    - 核心代码：
```c++
priority_queue<pa>G[15][15];
for (int i=1;i<=n*m;i++)
{
    int x=read();
    bool bl=0;
    for (int j=4;j>=0;j--)
    {
        if (G[x][j].empty()) continue;
        while (!G[x][j].empty())
        {
            pa now=(G[x][j].top());
            //...
        }
    }
}
```
    - 核心思想：定义二维优先队列数组`G`，第一维表示格子种类，第二维表示紧密度。遍历优先队列，找到符合条件的位置。

### 最优关键思路或技巧
- **数据结构优化**：利用`set`或优先队列维护可摆放位置，避免每次都遍历整个棋盘，将时间复杂度从$O(n^4)$优化到$O(n^2\log{n})$。
- **自定义排序**：通过自定义结构体和比较函数，实现多关键字排序，确保每次选择的位置符合题目要求。

### 可拓展之处
同类型题或类似算法套路：在其他模拟题中，若需要频繁查找和选择符合条件的元素，可考虑使用`set`、优先队列等数据结构进行优化。例如，在棋盘上放置棋子、安排任务等问题。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察优先队列的使用，通过不断合并最小的元素来求解最优解。
- [P1168 中位数](https://www.luogu.com.cn/problem/P1168)：使用两个优先队列维护中位数，需要对优先队列的操作和性质有深入理解。
- [P2085 最小函数值](https://www.luogu.com.cn/problem/P2085)：通过优先队列维护函数值，每次取出最小值并更新，可类比本题中选择最优摆放位置的过程。

### 个人心得摘录与总结
- **scc36**：因认为 $n$ 和 $m$ 相等而苦恼了一下午，提醒我们在解题时要仔细审题，避免因误解题意而浪费时间。

---
处理用时：24.01秒
# 题目信息

# 「Wdoi-5」樱点收集

## 题目背景

119 季 5 月，明明本应是樱花盛开的春天，幻想乡却依然下着大雪。异变的主谋**西行寺幽幽子**在古书上看到，只要使妖樱西行妖满开便会有什么人复活，便出于兴趣命令妖梦收集幻想乡中的春度，一手策划成了这场异变。在收集春度的过程中散落的能量在西行妖的影响下化为**樱点**，散落在幻想乡各处。

出发解决**春雪异变**的灵梦将前往冥界旅途划分为了若干段，每一段都可以收集到一定的樱点。收集齐一定程度的樱点，就会立即开出樱之结界。开出樱之结界后可以短暂地屏蔽一切攻击，并且获得相应的增益。

但是樱之结界何时开放仅由樱点的收集情况所决定，她不得不对樱点进行「规划」。通过某些途径规避某一段路上樱点的收集，借此使得在将来的某几段路程里，灵梦得以恰好在该段的末尾开放樱之结界。  

但是现实往往不尽人意。也就是说，可能有某些要求无法达成。灵梦希望找出一个方案，使得她可以达成的要求最多。灵梦委托八云紫帮忙决策，于是这个重任就被一条懒紫交给了式神八云蓝。尽管八云蓝擅长计算，但是八云紫睡觉去了没有给她编程，因而现在这个任务就落到了你的手上。

## 题目描述

灵梦当前拥有的樱点可以使用一个**变量** $c$ 存储，初始时为 $0$。当樱点在某个瞬间**恰好**变为了 $k$，灵梦就会展开樱之结界，同时 $c$ 变为 $0$。

现在她把路程**依次**划分为了 $n$ 个关卡，其中第 $i$ 关上，灵梦一共可以获得 $a_i$ 点樱点。这些樱点是均匀分布在这关的路程上的。也就是说，随着这段路程的进行，灵梦的樱点个数会依次增加，每次增加 $1$ 个单位（$c\gets c+1$），恰好在这段路程结束的瞬间会收集到这关中第 $a_i$ 点樱点。

![](https://cdn.luogu.com.cn/upload/image_hosting/3yuiywt0.png)

**【需要注意的是，这只是图示参考，不满足实际的数据限制。】**

在这个例子里，灵梦将路径划分为了四个关卡。这四个关卡的樱点个数分别为 $2,0,3,1$。

灵梦提出了 $m$ 个要求。第 $i$ 个要求 $b_i$ 表示灵梦希望在第 $b_i$ 段路程结束的瞬间，**恰好**展开樱之结界（如果在这段路程的中途展开但是结束的瞬间没有展开，那就不算达成了要求）。

灵梦可以选择在某个关卡开头放 bomb，**跳过**整个关卡的樱点收集。这样的机会**有且仅有**一次（当然，灵梦可以选择不使用 bomb）。

现在需要求出，在最优的选择下，灵梦**最多**可以达成多少个要求。

## 说明/提示

样例 $2$ 见下发的附件 $\textbf{\textit{sukura2.in/sakura2.ans}}$。该样例约束与测试点 $1\sim 8$ 一致。  
样例 $3$ 见下发的附件 $\textbf{\textit{sukura3.in/sakura3.ans}}$。该样例约束与测试点 $9\sim 14$ 一致。  
样例 $4$ 见下发的附件 $\textbf{\textit{sukura4.in/sakura4.ans}}$。该样例约束与测试点 $15\sim 20$ 一致。

#### 样例 1 解释

- 在不使用 bomb 时，灵梦会在第 $2$、$3$ 关开出樱之结界，其中第 $3$ 关在统计序列中，满足要求数为 $1$。
- 在第 $1$ 关使用 bomb，灵梦会在第 $4$ 关开出樱之结界，且第 $4$ 关在统计序列中，满足要求数为 $1$。
- 在第 $2$ 关使用 bomb，灵梦会在第 $4$ 关开出樱之结界，且第 $4$ 关在统计序列中，满足要求数为 $1$。
- 在第 $3$ 关使用 bomb，灵梦会在第 $2$ 关开出樱之结界，且第 $2$ 关不在统计序列中，满足要求数为 $0$。
- 在第 $4$ 关使用 bomb，灵梦会在第 $2$、$3$ 关开出樱之结界，其中第 $3$ 关在序列中，满足要求数为 $1$。

#### 数据范围及约定

本题共有 $20$ 个测试点，每个测试点 $5$ 分。最终分数为所有测试点分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \bm{n\le } & \bm{k\le} \cr\hline
1\sim 8 & 200 & 10^3 \cr\hline
9\sim 14 & 2\times 10^3 & 10^5 \cr\hline
15\sim 20 & 3\times 10^5 & 10^6 \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，保证 $1\le m\le n\le 3\times 10^5$，$1\le k\le 10^6$，$1\le a_i\le 10^9$，$1 \le b_i \le n$，$b$ 序列递增。

## 样例 #1

### 输入

```
4 3 2
1 3 4
1 1 2 1```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解核心思路都是围绕前缀和与取模运算展开，通过枚举使用 bomb 的位置，计算不同情况下满足要求的数量，进而找出最大值。

算法要点主要包括：
1. 计算前缀和数组并对 $k$ 取模。
2. 用桶记录前缀和取模后的余数出现次数。
3. 枚举使用 bomb 的位置，根据前缀和与取模的性质计算满足要求的数量。

解决的难点在于如何高效计算使用 bomb 后满足要求的数量，避免重复计算，将时间复杂度从暴力的 $O(n^2)$ 优化到 $O(n)$。

### 所选题解
1. **作者：WardLee (赞：18) - 5星**
    - 关键亮点：思路清晰，代码简洁，通过两个数组 $l$ 和 $r$ 分别存储某一段前后前缀和模 $k$ 为 $i$ 的位置数，边枚举边更新，时间复杂度为 $O(n)$。
    - 核心代码：
```cpp
const int N = 300010, M = 1000010;
int n, m;
LL a[N], s[N], res, K;
int nl[M], nr[M];
bool st[N];

int main(){
    scanf("%d%d%lld", &n, &m, &K);
    for(int i = 1; i <= m; i ++){
        int t;
        scanf("%d", &t);
        st[t] = true;
    }

    for(int i = 1; i <= n; i ++){
        scanf("%lld", &a[i]);
        s[i] = a[i] + s[i - 1];
        if(a[i] && st[i]) nl[s[i] % K] ++;
    }

    int res = nl[0];
    for(int i = n; i >= 1; i --){
        if(a[i] && st[i]) nl[s[i] % K] --;
        res = max(res, nl[0] + nr[a[i] % K]);
        if(a[i] && st[i]) nr[s[i] % K] ++;
    }
    printf("%d\n", res);
    return 0;
}
```
2. **作者：minstdfx (赞：18) - 5星**
    - 关键亮点：详细解释了不使用和使用 bomb 时的情况，通过数组 $x$ 记录后缀中模 $k$ 余 $i$ 的数的个数，思路清晰易懂。
    - 核心思路：先统计不使用 bomb 时满足条件的个数，再枚举放 bomb 的位置，更新答案。
3. **作者：lyhqwq (赞：8) - 4星**
    - 关键亮点：代码简洁，通过维护前缀和数组和桶数组，枚举删除的元素，计算答案，时间复杂度为 $O(n)$。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,ans;
int b[300005],sum[300005],a[300005],t[300005];
int main(){
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++){
        int x;
        scanf("%d",&x);
        b[x]=1;
    }
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        sum[i]=(sum[i-1]+a[i])%k;
        if(b[i]) t[sum[i]]++;
    }
    int tmp=0;
    for(int i=1;i<=n+1;i++){
        if(b[i]) t[sum[i]]--;
        ans=max(ans,tmp+t[a[i]%k]);
        if(!sum[i]&&b[i]) tmp++;
    }
    printf("%d",ans);
    return 0;
}
```

### 最优关键思路或技巧
1. **前缀和与取模**：通过计算前缀和并对 $k$ 取模，将问题转化为判断前缀和模 $k$ 是否为 0 或与某个值同余。
2. **桶计数**：利用桶数组记录前缀和取模后的余数出现次数，方便快速统计满足条件的数量。
3. **枚举优化**：枚举使用 bomb 的位置，根据前缀和的性质，避免重复计算，将时间复杂度优化到 $O(n)$。

### 可拓展之处
同类型题或类似算法套路：
1. 区间修改与查询问题，可使用前缀和、差分等思想。
2. 取模运算相关问题，通过取模将问题简化。
3. 枚举优化问题，通过合理枚举减少不必要的计算。

### 推荐题目
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：考察前缀和与动态规划思想。
2. [P2671 [NOIP2015 普及组] 求和](https://www.luogu.com.cn/problem/P2671)：涉及前缀和与取模运算。
3. [P3156 [CQOI2011] 放棋子](https://www.luogu.com.cn/problem/P3156)：需要枚举和优化计算。

### 个人心得摘录与总结
- **作者：苏联小渣**：提到认识的人都用 $O(n)$ 过了，自己是 $O(n \log m)$ 的，提供了一种从暴力优化的思路，认为比较好想。总结：不同复杂度的解法都可尝试，从暴力解法出发逐步优化是一种有效的解题思路。
- **作者：happybob**：表示赛时对 `pb_ds` 有掌握就 $200$ 分了，用内置红黑树解决问题。总结：掌握更多的数据结构和工具库有助于解决问题。 

---
处理用时：33.55秒
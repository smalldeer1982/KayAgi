# 题目信息

# [蓝桥杯 2016 省 A] 密码脱落

## 题目描述

X 星球的考古学家发现了一批古代留下来的密码。

这些密码是由 A、B、C、D 四种植物的种子串成的序列。

仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的回文串）。

由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。

你的任务是：

给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。

## 说明/提示

蓝桥杯 2016 年省赛 A 组 I 题。

## 样例 #1

### 输入

```
ABCBA```

### 输出

```
0```

## 样例 #2

### 输入

```
ABDCDCBABC```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算使给定字符串成为回文串所需脱落的最少种子数展开。多数题解采用将原字符串反转，然后求原串与反转串的最长公共子序列（LCS），用原串长度减去 LCS 长度得到结果；也有题解使用动态规划直接计算将子串变成回文串需删除的最少字符数。

### 所选题解
- **作者：SilverLi（5星）**
    - **关键亮点**：思路清晰，详细阐述了从正向思考遇到的问题，进而引出反向思考的过程，代码简洁易懂。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1005;
int f[N][N];
string s1,s2;
int main() {
    cin>>s1; s2=s1;
    int l=s1.size();
    reverse(s2.begin(),s2.end());
    for(int i=1;i<=l;++i)
        for(int j=1;j<=l;++j)
            if(s1[i-1]==s2[j-1]) f[i][j]=f[i-1][j-1]+1;
            else f[i][j]=max(f[i][j-1],f[i-1][j]);
    cout<<l-f[l][l];
    return 0;
}
```
    - **核心实现思想**：定义 `f[i][j]` 表示 `s1` 中前 `i` 个种子与 `s2` 中前 `j` 个种子相同种子数，通过状态转移方程更新 `f` 数组，最后用原串长度减去 `f[l][l]` 得到结果。

- **作者：sherry_lover（4星）**
    - **关键亮点**：明确指出考点为最长公共子序列，代码规范，注释清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s1[1010],s2[1010];
int f[1010][1010];
int main () {
    scanf("%s",1+s1);
    int lens=strlen(1+s1);
    for(int i=1;i<=lens;i++) s2[lens-i+1]=s1[i];
    for(int i=1;i<=lens;i++) f[i][1]=f[1][i]=0;
    for(int i=1;i<=lens;i++)
        for(int j=1;j<=lens;j++)
            if(s1[i]!=s2[j]) f[i][j]=max(f[i-1][j],f[i][j-1]);
            else f[i][j]=f[i-1][j-1]+1;
    cout << lens-f[lens][lens];
    return 0;
}
```
    - **核心实现思想**：先将原串反转得到新串，初始化 `f` 数组，通过状态转移方程计算最长公共子序列长度，最后用原串长度减去该长度得到答案。

- **作者：RP_INT_MAX（4星）**
    - **关键亮点**：给出双倍经验题目，代码简洁，使用内联函数优化 `max` 函数。
    - **核心代码**：
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
inline int max(int a,int b) {return a>b?a:b;} 
char s1[1010],s2[1010];
int f[1010][1010];
int main () {
    scanf("%s",1+s1);
    int n=strlen(1+s1);
    for(int i=1;i<=n;++i) s2[n-i+1]=s1[i];
    for(int i=1;i<=n;++i) f[i][1]=f[1][i]=0;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            if(s1[i]!=s2[j]) f[i][j]=max(f[i-1][j],f[i][j-1]);
            else f[i][j]=f[i-1][j-1]+1;
    printf("%d\n",n-f[n][n]);
    return 0;
}
```
    - **核心实现思想**：同样是求原串与反转串的最长公共子序列，用原串长度减去该长度得到结果，使用内联函数提高效率。

### 最优关键思路与技巧
- **思维方式**：正向思考难以确定脱落种子的数量和位置时，反向思考寻找未脱落的种子，即求原串与反转串的最长公共子序列。
- **算法优化**：部分题解提到可以使用滚动数组优化空间复杂度。
- **代码实现技巧**：使用 `reverse` 函数反转字符串，使用状态转移方程计算最长公共子序列。

### 拓展思路
同类型题或类似算法套路：
- 求字符串的最长回文子序列长度。
- 计算将字符串变成回文串所需的最少插入或删除操作次数。

### 推荐题目
- [P1435 [IOI2000] 回文字串](https://www.luogu.com.cn/problem/P1435)
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)（动态规划基础题，可加深对状态转移的理解）
- [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)（区间动态规划，与本题动态规划思想有一定关联）

### 个人心得
题解中未包含个人心得（调试经历、踩坑教训、顿悟感想等）。 

---
处理用时：33.86秒
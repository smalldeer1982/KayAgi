# 题目信息

# [蓝桥杯 2018 国 A] 自描述序列

## 题目描述

小明在研究一个序列，叫 Golomb 自描述序列，不妨将其记作 ${G(n)}$。这个序列有 $2$ 个很有趣的性质：

1. 对于任意正整数 $n$，$n$ 在整个序列中恰好出现 $G(n)$ 次。

2. 这个序列是不下降的。

以下是 $G(n)$ 的前几项：

$n$|1|2|3|4|5|6|7|8|9|10|11|12|13
-|-|-|-|-|-|-|-|-|-|-|-|-|-
$G(n)$|1|2|2|3|3|4|4|4|5|5|5|6|6

给定一个整数 $n$，你能帮小明算出 $G(n)$ 的值吗？

## 说明/提示

对于 $30\%$ 的数据，$1 \le n \le 10^6$。

对于 $70\%$ 的数据，$1 \le n \le 10^9$。

对于 $100\%$ 的数据，$1 \le n \le 2\times 10^{15}$。

时限 1 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
13```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
这些题解主要围绕Golomb自描述序列展开，根据数据规模不同给出了不同的解法。暴力枚举可解决小数据范围问题，但对于大数据范围效率低。优化方法通过范围表示位置、二分查找、利用序列衍生性质等，提高了求解效率。

### 所选题解
- **作者：Flanksy (赞：7)，5星**
    - **关键亮点**：思路清晰，分三个数据范围详细讨论，逐步扩展可求解范围，代码实现简洁高效。
    - **核心实现思想**：先计算小范围数据，再利用已有信息扩展范围，最后根据序列性质确定大数据范围的答案。
    - **核心代码片段**：
```cpp
constexpr long long uim=3793540542ll;
constexpr int sta=6138,lim=1000147;
int pos,dp[2000005];
long long n,ans;
int main(){
    scanf("%lld",&n);
    pos=3,dp[1]=1ll,dp[2]=2ll,dp[3]=2ll;
    for(int i=3;pos+1<=lim;i++)
        for(int j=1;j<=dp[i]&&pos+1<=lim;j++){
            dp[++pos]=i;
            if(pos==n) return printf("%d\n",i),0;
        }
    long long l=lim,r=lim,ls=uim,rs=uim;
    for(int i=sta;i<=lim;i++){
        l=r+1,r+=dp[i];
        ls=rs+1,rs+=(r-l+1)*i;
        if(n>=l&&n<=r) ans=i;
        if(n>=ls&&n<=rs) ans=l+(n-ls)/i;
        if(ans!=0ll) break;
    }
    printf("%lld\n",ans);
    return 0;
}
```
- **作者：zhanghao233 (赞：6)，4星**
    - **关键亮点**：提供了暴力、优化和正解三种思路，逐步引导优化，思路有一定创新性，通过衍生关系求解。
    - **核心实现思想**：先暴力求解小范围，再用范围表示位置和二分查找优化，最后利用序列衍生性质求解大数据范围。
    - **核心代码片段（正解部分）**：
```cpp
g[0]=2,g[1]=1,g[2]=2;
for(int i=2;i<=N;i++)
    for(int j=1;j<=g[i];j++){
        g[g[0]++]=i;
        if(g[0]>=N-1)
            goto end;
    }
end: cin>>n;
int t=0,q=0;
for(int i=1;;i++){
    t+=g[i]*i;
    if(t>=n){
        t-=g[i]*i;
        cout<<q+(n-t+i-1)/i<<"\n";
        break;
    }
    q+=g[i];
}
```
- **作者：U•ェ•*U (赞：2)，4星**
    - **关键亮点**：思路清晰，从暴力到优化再到正解逐步分析，代码简洁，通过区间求解大数据范围。
    - **核心实现思想**：先预处理小范围数据，再根据序列区间性质求解大数据范围。
    - **核心代码片段**：
```cpp
#define int long long
using namespace std;
int n, res, cnt, g[1000010];
int main() {
    ios :: sync_with_stdio(false);
    cin >> n;
    g[1] = 1, g[2] = 2;
    for (int i = 2, j = 2; i < 1000010; i++)
        for (int k = 0; k < g[i] && j < 1000010; k++) g[j++] = i;
    int i = 1;
    while (true) {
        res += i * g[i];
        if (res >= n)
            return res -= i * g[i], cout << cnt + (n - res + i - 1) / i << endl, 0;
        cnt += g[i++];
    }
    return 0;
}
```

### 最优关键思路或技巧
- 分范围求解：根据数据规模不同，采用不同的求解方法，逐步扩展可求解范围。
- 利用序列性质：利用自描述序列中数字出现次数和区间连续性的性质，通过计算区间范围和位置来确定答案。

### 可拓展之处
同类型题可能涉及其他特殊序列的求解，可根据序列的特定性质进行分析。类似算法套路包括分情况讨论、利用区间性质和二分查找等。

### 洛谷题目推荐
1. P1002 过河卒
2. P1048 采药
3. P1216 [USACO1.5]数字三角形 Number Triangles

### 个人心得
题解中未包含个人心得。 

---
处理用时：26.94秒
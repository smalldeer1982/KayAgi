# 题目信息

# [蓝桥杯 2019 省 A] 外卖店优先级

## 题目描述

“饱了么”外卖系统中维护着 $N$ 家外卖店，编号 $1$ ∼ $N$。每家外卖店都有一个优先级，初始时 $(0$ 时刻）优先级都为 $0$。

每经过 $1$ 个时间单位，如果外卖店没有订单，则优先级会减少 $1$，最低减到 $0$；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 $2$。

如果某家外卖店某时刻优先级大于 $5$，则会被系统加入优先缓存中；如果优先级小于等于 $3$，则会被清除出优先缓存。

给定 $T$ 时刻以内的 $M$ 条订单信息，请你计算 $T$ 时刻时有多少外卖店在优先缓存中。

## 说明/提示

**样例解释**

$6$ 时刻时，$1$ 号店优先级降到 $3$，被移除出优先缓存；$2$ 号店优先级升到 $6$，

加入优先缓存。所以是有 $1$ 家店 $(2$ 号）在优先缓存中。

**评测用例规模与约定**

对于 $80\%$ 的评测用例，$1 \le N,M,T \le 10000$。

对于所有评测用例，$1 \le N,M,T \le 10^5$，$1 \le ts \le T$，$1 \le id \le N$。

蓝桥杯 2019 年省赛 A 组 G 题。

## 样例 #1

### 输入

```
2 6 6
1 1
5 2
3 1
6 2
2 1
6 2```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解核心思路都是模拟外卖店优先级的变化过程，但实现方式和优化程度有所不同。多数题解使用了排序来处理订单时间顺序，部分题解借助优先队列、结构体等数据结构优化处理。主要难点在于处理同一时刻多订单、优先级非负限制以及正确判断优先缓存的加入和移除。

### 所选题解
- **作者：wjx38223（5星）**
    - **关键亮点**：思路清晰，详细阐述了优化过程，使用优先队列存储每个店的订单时间点，避免遍历无订单的时间，代码注释丰富，逻辑严谨。
    - **个人心得**：无
    - **核心代码**：
```cpp
priority_queue<int,vector<int>,greater<int>> h[100010]; 
//...
while(!h[i].empty()){
    int x = h[i].top(); 
    h[i].pop();
    if(lastget!=x) pri-=(x-lastget-1);
    if(pri<0) pri = 0; 
    if(in&&pri<=3) in = false; 
    pri+=2; 
    lastget = x; 
    if(pri>5) in = true; 
}
```
核心思想：为每个店维护一个优先队列存储订单时间，按时间顺序处理订单，计算优先级变化并判断是否在优先缓存中。

- **作者：梅子酒（5星）**
    - **关键亮点**：时间复杂度优化至 $O(M\cdot \log_{2}{M} + N)$，通过排序订单和记录商店更新时间，避免无效遍历，代码注释详细，还给出了特殊样例。
    - **个人心得**：指出暴力模拟时间复杂度高，无法通过最大数据，提醒注意先判断移除缓存再更新优先级。
    - **核心代码**：
```cpp
sort(o + 1, o + 1 + m); 
for(int i = 1; i <= m; i ++){
    auto [ti, id] = o[i];
    int time = max(0, ti - s[id].last - 1); 
    s[id].val = max(0, s[id].val - time); 
    if(vis[id] == 1 && s[id].val <= 3){ 
        vis[id] = 0;
        ans --;
    }
    s[id].val += 2;
    if(vis[id] == 0 && s[id].val > 5){ 
        vis[id] = 1;
        ans ++;
    }
    s[id].last = ti; 
}
```
核心思想：先对订单按时间排序，遍历订单更新商店优先级和缓存状态，最后按最终时间更新所有商店。

- **作者：fish_gugu（4星）**
    - **关键亮点**：提出优化思路，使用 `pair` 存储订单信息，用双指针处理同一时间同一店铺的多个订单，避免重复计算。
    - **个人心得**：指出暴力模拟时间复杂度高，需优化，提醒不能仅在 $T$ 时刻检测。
    - **核心代码**：
```c
sort(a,a + m);
for(int i = 0;i < m;)
{
    int j = i;
    while(j < m && a[i] == a[j]) j++; 
    int cnt = j - i,tt = a[i].first,id = a[i].second;
    val[id] -= (tt - post[id] - 1); 
    if(val[id] < 0) val[id] = 0;
    if(val[id] <= 3) st[id] = false; 
    val[id] += cnt * 2;
    if(val[id] > 5) st[id] = true; 
    post[id] = tt;
    i = j;
}
```
核心思想：对订单排序后，用双指针统计同一时间同一店铺的订单数，更新优先级和缓存状态。

### 最优关键思路或技巧
- **数据结构**：使用优先队列、结构体、`pair` 等存储订单信息，方便排序和处理。
- **算法优化**：避免遍历无订单的时间，只处理有订单的时刻，降低时间复杂度。
- **思维方式**：先对订单按时间排序，按顺序更新店铺信息，最后统一处理最终时间的状态。
- **代码实现技巧**：用函数封装更新操作，提高代码复用性；使用标记数组记录店铺是否在优先缓存中。

### 可拓展之处
同类型题如模拟游戏角色状态变化、资源管理系统等，可使用类似的模拟思路，根据不同规则更新状态。类似算法套路包括排序后按顺序处理、用数据结构存储关键信息、避免无效计算等。

### 洛谷题目推荐
1. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)：模拟乒乓球比赛过程，根据得分规则更新比赛状态。
2. [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)：模拟多项式的输出过程，根据系数和次数的不同情况进行处理。
3. [P1540 机器翻译](https://www.luogu.com.cn/problem/P1540)：模拟机器翻译的过程，使用队列存储已翻译的单词，根据规则更新队列。

### 个人心得摘录与总结
- **梅子酒**：指出暴力模拟时间复杂度高，无法通过最大数据，提醒注意先判断移除缓存再更新优先级，避免错误加入缓存。
- **fish_gugu**：强调暴力模拟不可行，需优化，提醒不能仅在 $T$ 时刻检测，避免遗漏不符合加入缓存条件的店铺。
- **SakurajiamaMai**：调了一个小时发现更新最小值时不能为负数，提醒注意边界条件。
- **ny_Dacong**：强调优先级不能小于 0，同一时刻多订单处理，处理最后订单与 $T$ 时刻的优先级变化，以及判断缓存状态的顺序。 

---
处理用时：34.57秒
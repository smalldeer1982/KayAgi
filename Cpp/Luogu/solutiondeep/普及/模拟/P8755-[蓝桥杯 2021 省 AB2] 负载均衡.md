# 题目信息

# [蓝桥杯 2021 省 AB2] 负载均衡

## 题目描述

有 $n$ 台计算机，第 $i$ 台计算机的运算能力为 $v_{i}$ 。

有一系列的任务被指派到各个计算机上，第 $i$ 个任务在 $a_{i}$ 时刻分配，指定计算机编号为 $b_{i}$, 耗时为 $c_{i}$ 且算力消耗为 $d_{i}$。如果此任务成功分配，将立刻开始运行, 期间持续占用 $b_{i}$ 号计算机 $d_{i}$ 的算力, 持续 $c_{i}$ 秒。

对于每次任务分配，如果计算机剩余的运算能力不足则输出 $-1$，并取消这次分配，否则输出分配完这个任务后这台计算机的剩余运算能力。

## 说明/提示

**【样例说明】**

时刻 $1$，第 $1$ 个任务被分配到第 $1$ 台计算机，耗时为 $5$，这个任务时刻 $6$ 会结束, 占用计算机 $1$ 的算力 $3$。

时刻 $2$，第 $2$ 个任务需要的算力不足，所以分配失败了。

时刻 $3$，第 $1$ 个计算机仍然正在计算第 $1$ 个任务，剩余算力不足 $3$，所以失败。

时刻 $4$，第 $1$ 个计算机仍然正在计算第 $1$ 个任务，但剩余算力足够，分配后剩余算力 $1$。

时刻 $5$，第 $1$ 个计算机仍然正在计算第 $1$，$4$ 个任务，剩余算力不足 $4$，失败。

时刻 $6$，第 $1$ 个计算机仍然正在计算第 $4$ 个任务，剩余算力足够，且恰好用完。

**【评测用例规模与约定】**

对于 $20 \%$ 的评测用例, $n, m \leq 200$。

对于 $40 \%$ 的评测用例, $n, m \leq 2000$。

对于所有评测用例, $1 \leq n, m \leq 2\times 10^5,1 \leq a_{i}, c_{i}, d_{i}, v_{i} \leq 10^{9}, 1 \leq b_{i} \leq n$。 

蓝桥杯 2021 第二轮省赛 A 组 H 题（B 组 I 题）。

## 样例 #1

### 输入

```
2 6
5 5
1 1 5 3
2 2 2 6
3 1 2 3
4 1 6 1
5 1 3 3
6 1 3 4```

### 输出

```
2
-1
-1
1
-1
0```

# AI分析结果

### 综合分析与结论
这些题解主要围绕两种思路展开：暴力模拟和使用堆优化。暴力模拟虽易想但会超时，而堆优化是正解。堆优化的核心是为每台计算机维护一个小根堆，存储任务结束时间和占用算力。每次分配任务时，先弹出已完成任务，恢复算力，再判断能否分配新任务。这种方法时间复杂度为 $O(m \log n)$，能有效解决问题。

### 所选题解
- **作者：xwh_hh（5星）**
    - **关键亮点**：思路清晰，代码简洁，详细解释了使用小根堆的原因和时间复杂度。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> P;
int n,m,h[200005];
priority_queue<P,vector<P>,greater<P> > pq[200005];
int main() {
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>h[i];
    while(m--){
        int a,b,c,d;
        cin>>a>>b>>c>>d;
        while(!pq[b].empty() && pq[b].top().first<=a){
            h[b]+=pq[b].top().second;
            pq[b].pop();
        }
        if(h[b]<d) cout<<-1<<endl;
        else{
            h[b]-=d;
            pq[b].push(P(a+c,d));
            cout<<h[b]<<endl;
        }
    } 
    return 0;
}
```
    - **核心实现思想**：用 `pair` 类型的小根堆维护每台计算机的任务，`first` 为结束时间，`second` 为占用算力。每次分配任务时，先弹出已完成任务，恢复算力，再判断能否分配新任务。

- **作者：gengchenghao（4星）**
    - **关键亮点**：代码规范，结构清晰，对思路的解释简洁明了。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
struct node{
    int ti,v;
    bool operator<(const node& a) const {
        return ti>a.ti;
    }
};
priority_queue<node>q[N];
int v[N];
int n,m;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>v[i];
    }
    while(m--){
        int a,b,c,d;
        cin>>a>>b>>c>>d;
        while(q[b].size()&&q[b].top().ti<=a){
            v[b]+=q[b].top().v;
            q[b].pop();
        }
        if(v[b]<d)puts("-1");
        else{
            v[b]-=d;
            q[b].push({a+c,d});
            cout<<v[b]<<'\n';
        }
    }
    return 0;
}
```
    - **核心实现思想**：定义结构体 `node` 存储任务结束时间和占用算力，重载 `<` 运算符实现小根堆。每次分配任务时，先弹出已完成任务，恢复算力，再判断能否分配新任务。

- **作者：封禁用户（4星）**
    - **关键亮点**：详细阐述了思路和时间复杂度，代码注释清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=200010;
struct computer
{
    ll times,capacity,idx;
    bool operator<(const computer &x)const
    {
        return times>x.times;
    }
};
ll n,m,v[N],a[N],b[N],c[N],d[N];
priority_queue<computer> heap;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i];
    }
    for(int i=1;i<=m;i++)
    {
        cin>>a[i]>>b[i]>>c[i]>>d[i];
        while(heap.size()&&a[i]>=heap.top().times)
        {
            v[heap.top().idx]+=heap.top().capacity;
            heap.pop();
        }
        if(v[b[i]]<d[i])
        {
            cout<<"-1\n";
            continue;
        }
        heap.push({a[i]+c[i],d[i],b[i]});
        v[b[i]]-=d[i];
        cout<<v[b[i]]<<"\n";
    }
    return 0;
}
```
    - **核心实现思想**：定义结构体 `computer` 存储任务结束时间、占用算力和计算机编号，重载 `<` 运算符实现小根堆。每次分配任务时，先弹出已完成任务，恢复算力，再判断能否分配新任务。

### 最优关键思路或技巧
使用小根堆维护每台计算机的任务，每次分配任务时先处理已完成任务，能避免不必要的计算，将时间复杂度从暴力模拟的 $O(mn)$ 优化到 $O(m \log n)$。

### 拓展思路
同类型题可考察多资源分配，如多台服务器分配不同类型任务，每种任务消耗不同资源；或在任务分配基础上加入任务优先级等。类似算法套路可用于处理需要动态维护最小值或最大值的场景，如调度问题、资源分配问题等。

### 推荐题目
1. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)：涉及动态维护第 $k$ 小值，可使用堆解决。
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：每次合并最小的两堆果子，可使用小根堆优化。
3. [P2085 最小函数值](https://www.luogu.com.cn/problem/P2085)：动态维护最小函数值，可使用堆优化。

### 个人心得
题解中未包含个人心得相关内容。

---
处理用时：36.30秒
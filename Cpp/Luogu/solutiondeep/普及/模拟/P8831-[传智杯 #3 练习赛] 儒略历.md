# 题目信息

# [传智杯 #3 练习赛] 儒略历

## 题目描述

在 1582 年之前，以 4 为倍数的年份为闰年。正常情况下，一年中一月到十二月的天数分别是 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 天。如果这年是闰年，那么二月则有 29 天。

但某位教皇发现这么做其实不够准确，会造成误差，因此规定从 1582 年开始，以 4 为倍数的年份，除了以 100 为倍数且不为 400 的倍数年份，才是闰年。同时为了消除误差，规定 1582 年 10 月 4 日的下一天是 1582 年 10 月 15 日，中间的日期就当作不存在了。

![](https://cdn.luogu.com.cn/upload/image_hosting/hcelsg2k.png)

现在给出日期，计算这个日期到公元 1 年 1 月 1 日经过的天数。

## 样例 #1

### 输入

```
1JAN1```

### 输出

```
0```

## 样例 #2

### 输入

```
4OCT1582```

### 输出

```
577736```

## 样例 #3

### 输入

```
15OCT1582```

### 输出

```
577737```

## 样例 #4

### 输入

```
21NOV2020```

### 输出

```
737751```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何计算给定日期到公元 1 年 1 月 1 日经过的天数展开，核心在于处理输入格式和闰年规则变化，尤其是 1582 年的特殊情况。

思路上，可分为两类：一是逐年、逐月累加天数，考虑闰年和 1582 年 10 月的特殊情况；二是暴力枚举每一天，直到达到给定日期。

算法要点包括：打表存储月份和天数，编写判断闰年的函数，处理输入字符串以提取年月日信息。

难点在于：输入格式的处理，不同年份闰年规则的判断，以及 1582 年 10 月 5 - 14 日缺失的处理。

### 所选题解
- **LegendaryGrandmaster（5星）**
    - **关键亮点**：思路清晰，代码注释详细，将解题过程分为读入和计算天数两部分，易于理解。
    - **核心代码**：
```cpp
string month[13]={"","JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"};
int a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
// 读入部分
for(int i=0;i<st.size();i++){
    if(st[i]>='0'&&st[i]<='9'){
        if(!ok)d*=10,d+=int(st[i]-48ll);
        else y*=10,y+=int(st[i]-48ll);
    }
    else mon+=st[i],ok=1;
}
for(int i=1;i<=12;i++)
    if(mon==month[i]){
        m=i;
        break;
    }
// 计算天数部分
if(y<1582)a[2]=(y%4==0?29:28);
else if(y==1582)a[2]=28;
else a[2]=(y%4==0&&y%100!=0||y%400==0?29:28);
if(y==1582&&m>=10&&d>=15)d-=10;
while(m--)d+=a[m];
while(y--&&y){
    if(y<1582)d+=(y%4==0?366:365);
    else if(y==1582)d+=355;
    else d+=(y%4==0&&y%100!=0||y%400==0?366:365);
}
cout<<d-1;
```
- **yanhao40340（4星）**
    - **关键亮点**：采用暴力枚举每一天的方法，代码结构清晰，对闰年判断和月份处理有详细的逻辑说明。
    - **核心代码**：
```cpp
const char ms[13][4]={"   ","JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"};
int main(){
    int d,m,y;char s[4];
    scanf("%d%3s%d",&d,s,&y);
    for (int i=1;i<=12;++i)
        if (s[0]==ms[i][0]&&s[1]==ms[i][1]&&s[2]==ms[i][2]){m=i;break;}
    int ans=0;
    for (int i=1;i<=9999;++i)
        for (int j=1;j<=12;++j)
            for (int k=1;k<=31;++k,++ans){
                if (i==y&&j==m&&k==d) return printf("%d\n",ans),0;
                if ((j==4||j==6||j==9||j==11)&&k==31) break;
                if (j==2&&((i%4==0)&&(i<1582||(i%400==0)||(i%100!=0))?k==30:k==29)) break;
                if (i==1582&&j==10&&k==4) k=14;
            }
    return 0;
}
```
- **RyanLi（4星）**
    - **关键亮点**：将解题过程封装成多个函数，代码模块化程度高，思路清晰。
    - **核心代码**：
```cpp
const int day[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int d, m, y, ans;
inline void init() {
    char c = getchar();
    string month;
    // 读入 d
    while (c >= '0' && c <= '9') {
        d = d * 10 + c - '0';
        c = getchar();
    }
    // 读入 month
    for (int i = 0; c >= 'A' && c <= 'Z'; ++i) {
        month += c;
        c = getchar();
    }
    // 读入 y
    while (c >= '0' && c <= '9') {
        y = y * 10 + c - '0';
        c = getchar();
    }
    // 将字符串 month 转化为整形 m
    if (month == "JAN") m = 1;
    else if (month == "FEB") m = 2;
    else if (month == "MAR") m = 3;
    else if (month == "APR") m = 4;
    else if (month == "MAY") m = 5;
    else if (month == "JUN") m = 6;
    else if (month == "JUL") m = 7;
    else if (month == "AUG") m = 8;
    else if (month == "SEP") m = 9;
    else if (month == "OCT") m = 10;
    else if (month == "NOV") m = 11;
    else m = 12;
    return;
}
inline int leapyear(int y) {
    int res = (y - 1) / 4 - (y - 1) / 100 + (y - 1) / 400;
    if (y >= 1582) res += 12;
    else res += (y - 1) / 100 - (y - 1) / 400;
    return res;
}
inline void solve() {
    for (int i = 1; i < m; ++i)
        ans += day[i];
    ans += d - 1;
    if ((y % 4 == 0 && y % 100!= 0) || y % 400 == 0)
        if (m > 2) ++ans;
    ans += (y - 1) * 365 + leapyear(y);
    if ((y == 1582 && m == 10 && d >= 15) || (y == 1582 && m > 10) || y > 1582)
        ans -= 10;
    return;
}
int main() {
    init();
    solve();
    printf("%d\n", ans);
    return 0;
}
```

### 最优关键思路或技巧
- **打表**：使用数组或 `map` 存储月份和天数，方便查询和处理。
- **函数封装**：将输入处理、闰年判断、天数计算等功能封装成函数，提高代码的可读性和可维护性。
- **分类讨论**：根据年份和月份的不同情况进行分类讨论，分别处理闰年和 1582 年的特殊情况。

### 可拓展之处
同类型题可能会涉及不同历法的日期计算，如农历、伊斯兰历等，解题思路类似，需要了解相应历法的规则，进行分类讨论和模拟计算。

### 推荐题目
- P7075 [CSP-S2020] 儒略日
- P1106 删数问题
- P1042 乒乓球

### 个人心得摘录与总结
- **LegendaryGrandmaster**：调了半天终于对了，代码可能有漏洞，欢迎指出。总结：调试是解决问题的重要环节，要保持开放的态度接受他人的建议。
- **Wangjunhao2011**：这道题卡样例卡了一个月，1582 年前后闰年判断不同是个坑。总结：要注意题目中的特殊情况，仔细分析，避免因细节问题导致错误。

---
处理用时：54.73秒
# 题目信息

# [DMOI-R1] 柯基棋

## 题目背景

小 A 和小 B 都是爱狗人士，且绝顶聪明，尤其喜爱柯基，于是他们发明了“柯基棋”。

## 题目描述

小 A 和小 B 在一个 $n \times n$ 的棋盘内轮流下棋。小 A 先手，小 B 后手。设当前有一只“柯基”被下在了棋盘的 $(x,y)$ 处，那么棋盘内的 $(x-1,y-1)$，$(x-1,y+1)$，$(x+1,y-1)$，$(x+1,y+1)$ 处都会变为这只“柯基”的地盘，也就不能再放一只“柯基”。当一个人不能再放下一只“柯基”时，他就输了。

可惜，小 C 却不怎么喜欢柯基，所以他很反对小 A 和小 B 玩“柯基”棋，于是他非常喜欢捣乱棋局。当小 A 和小 B 一共下了 $x_i$ 只“柯基”时，小 C 就会以当前 $w \times w$ 棋盘的中心为中心，扩大棋盘为 $(w+2) \times (w+2)$，他一共会捣乱 $q$ 次。

而你的任务是要判断这局棋是小 A 赢还是小 B 赢，如果小 A  赢，输出 `A won`，否则输出 `B won`。

由于他们两个人比较贪玩，所以他们一共会玩 $T$ 局。

**注意**：

1. 当小 A 和小 B 已经将原来的棋盘下到不能再下时，他们会直接跳转到小 C 下一次的捣乱（如果有）。

2. 小 A 和小 B 知道小 C 会捣乱，且会按照自己的最优策略走。

由于数据过大，$x_i$ 由数据随机生成器给出。

## 说明/提示

### 随机数据生成器

每一轮游戏的 $x_i$ 由下方的生成器给出：

```cpp
unsigned long long x[10000005];
unsigned long long xor_shift(unsigned long long &seed){
  return seed^=seed>>12, seed^=seed<<25, seed^=seed>>27, seed*0x2545F4914F6CDD1D;
}
int main(){
  //your code here
  int n,q;
  unsigned long long seed;
  cin>>n>>q>>seed;
  for(int i=1;i<=q;i++){
	x[i]=x[i-1]+((xor_shift(seed)%(unsigned long long)(2*2)+1))*2;
  }
  //your code here
  return 0;
}
```

### 样例解释

对于第一局游戏，$x_i$ 数组如下：`6 8 16 18 22`。

对于第二局游戏，$x_i$ 数组如下：`8 14 16 24 32 36 38 40`。

对于第三局游戏，$x_i$ 数组如下：`4 8 10 16`。

### 数据范围

对于 $20\%$ 的数据，$n,q\leq100$。

对于 $50\%$ 的数据，$n,q\leq10000$。

对于 $100\%$ 的数据，$1 \le T \le 10,2\leq n,q,\sum q \leq 10^7$，$x_i \equiv 0 \pmod 2\ (i\in[1,q]),0 \le seed \le 10^7$。


## 样例 #1

### 输入

```
3
2 5 493
3 8 3219
8 4 1294```

### 输出

```
B won
A won
B won```

# AI分析结果

### 综合分析与结论
这些题解思路一致，均通过分类讨论棋盘边长奇偶性来确定胜负，且指出小 C 捣乱不影响结果。算法要点为依据棋盘边长奇偶性制定不同下棋策略，难点在于发现对称策略及判断小 C 捣乱的影响。

### 所选题解
- **Vct14（5 星）**
    - **关键亮点**：思路清晰，配有图片辅助理解，代码简洁易懂。
    - **重点代码**：
```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    int T;
    cin>>T;
    while(T--){
        int n,q,seed;
        cin>>n>>q>>seed;
        if(n%2) cout<<"A won";
        else cout<<"B won";
        cout<<"\n";
    }	
    return 0;
}
```
    - **核心实现思想**：多组输入，判断棋盘边长 `n` 的奇偶性，奇数则小 A 胜，偶数则小 B 胜。

- **yitian_（4 星）**
    - **关键亮点**：思路清晰，代码简洁，逻辑明确。
    - **重点代码**：
```c
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        int n,p,s;
        cin >> n >> p >> s;
        if(n%2==0) 
        {
            cout << "B won" << endl;
        } 
        else cout << "A won" << endl;
    }
    return 0;
}
```
    - **核心实现思想**：多组输入，根据 `n` 的奇偶性输出胜负结果。

- **GoodLuckCat（4 星）**
    - **关键亮点**：通过类比经典圆桌放硬币问题引出思路，详细分析奇偶情况，解释清晰。
    - **重点代码**：
```cpp
#include<iostream>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n,q,s;
        cin>>n>>q>>s;
        if(n%2)cout<<'A';
        else cout<<'B';
        cout<<" won\n";
    }
}
```
    - **核心实现思想**：多组输入，依据 `n` 奇偶性输出获胜者。

### 最优关键思路或技巧
- 思维方式：运用对称策略解决博弈问题，通过分类讨论棋盘边长奇偶性制定不同策略。
- 代码实现技巧：直接判断棋盘边长奇偶性输出结果，避免复杂模拟。

### 可拓展之处
同类型题可考虑不同棋盘形状（如矩形、三角形）、不同棋子规则（如占领范围不同）的博弈问题，类似算法套路为寻找对称关系制定策略。

### 推荐题目
- P1247 取火柴游戏
- P2197 【模板】nim 游戏
- P2252 [SHOI2002]取石子游戏

### 个人心得
- **GoodLuckCat**：通过联想经典圆桌放硬币问题，找到解决本题的思路，提醒我们在解题时可通过类比相似问题寻找灵感。 

---
处理用时：18.65秒
# 题目信息

# [USACO22DEC] Reverse Engineering B

## 题目描述

Elsie 有一个程序，接受一个 $N(1 \le N \le 100)$ 个变量的数组 $b[0], \cdots ,b[N−1]$ 作为输入，其中每个变量等于 $0$ 或 $1$，并且返回对输入数组应用一系列 `if / else if / else` 语句的结果。每个语句检查至多一个输入变量的值，并返回 $0$ 或 $1$。这类程序的一个例子是：

```cpp
if (b[1] == 1) return 1;
else if (b[0] == 0) return 0;
else return 1;
```

例如，如果上方程序的输入是 "10"（即 $b[0]=1$ 及 $b[1]=0$），那么输出应当为 $1$。 

Elsie 告诉了 Bessie 对于 $M(1 \le M \le 100)$ 个不同输入的正确输出。Bessie 现在正试图对 Elsie 的程序进行逆向工程。不幸的是，Elsie 可能说了谎；可能不存在上述形式的程序行为与 Elsie 所说的均一致。 

对于 $T(1 \le T \le 10)$ 个子测试用例中的每一个，判断 Elsie 是否一定在说谎。

## 说明/提示

### 样例 1 解释

以下是第一个子测试用例的一个合法的程序：

```cpp
if (b[0] == 0) return 0;
else return 1;
```

以下是第一个子测试用例的另一个合法的程序：

```cpp
if (b[0] == 1) return 1;
else return 0;
```

以下是第二个子测试用例的一个合法的程序：

```cpp
if (b[1] == 1) return 1;
else if (b[0] == 0) return 0;
else return 1;
```

显然，对于第三个子测试用例不存在对应的合法的程序，因为 Elsie 的程序一定始终对相同的输入产生相同的输出。

可以证明对于最后一个子测试用例不存在对应的合法的程序。 

### 测试点性质

- 测试点 $2-3$ 满足 $N=2$。
- 测试点 $4-5$ 满足 $M=2$。
- 测试点 $6-12$ 没有额外限制。 

## 样例 #1

### 输入

```
4

1 3
0 0
0 0
1 1

2 4
00 0
01 1
10 1
11 1

1 2
0 1
0 0

2 4
00 0
01 1
10 1
11 0```

### 输出

```
OK
OK
LIE
LIE```

# AI分析结果

### 综合分析与结论
这些题解的核心思路一致，均是通过枚举每一位，将该位为 0 和 1 的输入分别考虑。若某一位上为 0 或 1 的输入对应的答案都相同，就可以通过一个 `if` 语句处理这些输入，进而将它们从待处理列表中删除。不断重复此过程，若最后所有输入都被删光或者剩余输入的答案相同，说明存在符合要求的程序，输出 `OK`；否则，输出 `LIE`。

### 所选题解
- **作者：ztntonny（5 星）**
    - **关键亮点**：思路讲解详细，通过画图和严谨的逻辑证明，帮助读者理解算法原理，代码注释丰富。
    - **个人心得**：作者花费 1 个小时调程序、2 个小时写题解，旨在讲透本题，聚焦重难点。
    - **核心代码**：
```cpp
for ( int j = 1; j <= m; j++ )
    for ( int l = 0; l < m; l++ )
    {
        int k[2] = { 0, 0 }, buck[2] = { 2, 2 };
        for ( int i = 1; i <= n; i++ )
        {
            y[i][l] = ( s[i][l] == '1' );
            if ( flag[i] ) continue;
            if ( buck[y[i][l]] == 2 ) buck[y[i][l]] = p[i];
            else if ( buck[y[i][l]]!= p[i] ) k[y[i][l]] = 1;
        }
        for ( int i = 1; i <= n; i++ ) if (!k[y[i][l]] ) flag[i] = 1;
    }
```
    - **核心实现思想**：双重循环枚举每一位和每个输入，统计该位为 0 和 1 时的答案情况。若答案都相同，则标记该输入可被删除。

- **作者：joyslog（4 星）**
    - **关键亮点**：思路清晰，时间复杂度分析明确，代码简洁。
    - **核心代码**：
```cpp
for(int k = 1; k <= n; k++) {
    for(int j = 1; j <= n; j++) {
        bl[0] = bl[1] = -1; flag[0] = flag[1] = 0;
        for(int i = 1; i <= m; i++) {
            if(vis[i]) continue;
            if(bl[a[i][j]] == -1) bl[a[i][j]] = res[i];
            else if(bl[a[i][j]]!= res[i]) flag[a[i][j]] = 1;
        }
        for(int i = 1; i <= m; i++)
            if(!flag[a[i][j]]) vis[i] = 1;
    }
}
```
    - **核心实现思想**：通过三重循环，枚举轮数、每一位和每个输入，判断该位为 0 和 1 时答案是否冲突，若不冲突则标记该输入已处理。

- **作者：chlchl（4 星）**
    - **关键亮点**：详细解释了题意转化和解题步骤，代码逻辑清晰。
    - **核心代码**：
```cpp
while(cnt < m){
    for(int i=0;i<n;i++){
        int now = -1;
        bool ok = 1;
        for(int j=1;j<=m;j++){
            if(tag[j] && ss[j][i] == '0'){
                if(now == -1) now = res[j];
                if(res[j]!= now) ok = 0;
            }
        }
        if(ok)
            for(int j=1;j<=m;j++)
                if(ss[j][i] == '0') tag[j] = 0;
        now = -1, ok = 1;
        for(int j=1;j<=m;j++){
            if(tag[j] && ss[j][i] == '1'){
                if(now == -1) now = res[j];
                if(res[j]!= now) ok = 0;
            }
        }
        if(ok)
            for(int j=1;j<=m;j++)
                if(ss[j][i] == '1') tag[j] = 0;
    }
    int now = 0;
    for(int i=1;i<=m;i++)
        now += (tag[i] == 0);
    if(now == cnt) break;
    cnt = now;
}
```
    - **核心实现思想**：使用 `while` 循环不断处理，在每一轮中枚举每一位和每个输入，判断该位为 0 和 1 时答案是否相同，若相同则标记该输入已处理。若一轮中没有新的输入被处理，则退出循环。

### 最优关键思路或技巧
- **枚举与删除策略**：通过枚举每一位，将该位相同且答案相同的输入删除，逐步缩小待处理范围。
- **标记法**：使用标记数组记录输入是否已被处理，避免重复处理。

### 可拓展之处
同类型题可能会增加输入的维度或条件，例如输入不再是 01 串，而是多进制数；或者 `if` 语句的判断条件不再局限于单个变量，而是多个变量的组合。类似算法套路是通过不断筛选和排除，逐步找到符合条件的解。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法和优先队列的应用。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：涉及贪心策略的选择和排序。
- [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)：需要运用贪心思想解决区间覆盖问题。

---
处理用时：30.48秒
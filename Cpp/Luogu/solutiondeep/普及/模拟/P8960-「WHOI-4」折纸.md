# 题目信息

# 「WHOI-4」折纸

## 题目背景

吉尼斯记录：一张纸（如果接近 $4$ 公里的卫生纸可以算作一张纸）最多可以对折 $13$ 次。小 X 吹牛说打破了这个记录，但是吹太大了。

## 题目描述

小 X 向吉尼斯世界纪录组织申请了这个记录，但是他正好隔离在家，无法证明。他只好允许他们问 $t$ 个问题，确认他确实打破了记录。

他们每个问题可以要求小 X 把一张纸按照一个给定 $01$ 串 $s$ 的规则对折 $n$ 次后展开。对于第 $i$ 次折叠，如果 $s_i=0$，将纸从左到右对折，使左边对齐右边；如果 $s_i=1$，将纸从右到左对折，使右边对齐左边。对折全部是从上方翻。**接下来将会展开，展开后纸片在原位，只是保留了折痕。看看自己是否实现了这一点。**

他们想要知道，从左往右数第 $k$ 个折痕是峰折（向上突起的折痕）还是谷折（向下凹陷的折痕）。如果该询问的答案是峰折，输出 `Up`；否则输出 `Down`。请你帮帮可怜的小 X。

峰折，谷折的图示见样例解释。

## 说明/提示

**样例解释**

样例 #1 解释：

动态地址：[here](https://img-blog.csdnimg.cn/c68f2ba917504417b109eb1606f4a3a5.gif)。不知道为什么洛谷显示不了了。

![](https://cdn.luogu.com.cn/upload/image_hosting/wguzrqz6.png)

由于技术原因，动图帧数略低。

样例 #2 请手动模拟。

**数据范围**

**本题采用捆绑测试。**

- Subtask 1（$20$ pts）：$t=10$，$1\le n\le5$；
- Subtask 2（$80$ pts）：$t=10^5$。

对于 $100\%$ 的数据，有 $1\le t\le 10^5$，$1\le n\le60$，$1\le k<2^n$。

## 样例 #1

### 输入

```
7
3 1
010
3 2
010
3 3
010
3 4
010
3 5
010
3 6
010
3 7
010```

### 输出

```
Down
Up
Up
Down
Down
Down
Up```

## 样例 #2

### 输入

```
7
3 1
011
3 2
011
3 3
011
3 4
011
3 5
011
3 6
011
3 7
011```

### 输出

```
Down
Up
Up
Down
Down
Down
Up
```

## 样例 #3

### 输入

```
2
13 114
1101101111010
13 514
1101101111010```

### 输出

```
Up
Up```

# AI分析结果

### 综合分析与结论
这些题解主要围绕折纸问题展开，通过不同的方法解决求第 $k$ 个折痕是峰折还是谷折的问题。思路大致可分为找规律和模拟折叠过程两类。找规律的题解通过分析折痕数量、位置和方向的规律来解题；模拟折叠过程的题解则通过二分、递归等方式模拟每次折叠，根据折叠规则判断折痕方向。

### 所选题解
- **JuRuoOIer 的题解（5星）**
    - **关键亮点**：思路清晰，通过多次手动折纸探索折痕规律，包括折痕数量、位置关系和方向变化规律，并将折痕编号转化为二进制找规律，代码注释详细。
    - **核心代码**：
```cpp
ll f(ll x){//求二进制位最后一个 1 的位置，据此可得这个折痕是第几次对折而来的 
    for(ll i=61;i>=0;i--){
        if(x>=(1ll<<i)){
            x-=(1ll<<i);
        } 
        if(x==0){
            return i;
        }
    }
}
ll g(ll x,ll fx){//求是这一次里产生的第奇数个还是第偶数个折痕 
    ll tmp=0;
    for(ll i=61;i>=0;i--){
        if(x>=(1ll<<i)){
            x-=(1ll<<i);
            tmp+=(1ll<<(i-fx));
        } 
    }
    return (tmp/2+1)%2;
}
```
    - **核心实现思想**：`f` 函数通过不断减去 $2$ 的幂，找到折痕编号二进制中最后一个 $1$ 的位置，从而确定该折痕是第几次对折产生的；`g` 函数根据折痕编号和对折次数，判断该折痕是此次对折产生的第奇数个还是第偶数个折痕。

- **Moon_Traveller 的题解（4星）**
    - **关键亮点**：通过手动模拟得出折痕数和折痕与 $s$ 的关系，利用二分法模拟折叠过程，代码逻辑清晰。
    - **核心代码**：
```cpp
while(l <= r) // 从第二次折开始遍历
{
    i++; // 第i-1次折叠
    long long mid = (l + r) >> 1;
    if(k < mid) // 处理左半部分
    {
        r = mid - 1;
        flag =!b[i - 1];
    }
    else if(k > mid) // 处理右半部分
    {
        l = mid + 1;
        flag = b[i - 1];
    }
    else // 如果 (k == mid) 说明到达了目标位置，可以输出了
    {
        cout << (flag? "Up" : "Down");
        cout << endl; // 别忘了换行
        break;
    }
} 
```
    - **核心实现思想**：使用二分法，不断更新左右边界，根据 $k$ 与中间位置的大小关系，结合 $s$ 中对应位置的值，更新折痕方向标志 `flag`，当 $k$ 等于中间位置时输出结果。

- **escapist404 的题解（4星）**
    - **关键亮点**：通过样例模拟找到决定折痕突起方向的因素，用异或运算简化分类讨论，代码简洁高效。
    - **核心代码**：
```cpp
for(int i = 0; i < n; i++)
{
    mid = (l + r) >> 1;
    if(k == mid)
    {
        if(f)
            cout << "Up" << endl;
        else
            cout << "Down" << endl;
        break;
    }
    if(f ^ (k < mid) ^ (s[i] == '1'))
        f ^= 1;
    if(k > mid)
        l = mid;
    else
        r = mid;
}
```
    - **核心实现思想**：使用二分法，在每次折叠时，根据 $k$ 与中间位置的大小关系、$s$ 中对应位置的值和纸面朝向标志 `f`，通过异或运算判断是否改变纸面朝向，当 $k$ 等于中间位置时输出结果。

### 最优关键思路或技巧
- **手动模拟找规律**：通过多次手动折纸，观察折痕的数量、位置和方向变化，总结出规律，如折痕数为 $2^n - 1$，第 $i$ 次折叠产生的折痕与 $s_{i - 1}$ 有关等。
- **二进制转换**：将折痕编号转换为二进制，通过分析二进制中最后一个 $1$ 的位置，确定折痕是第几次对折产生的，简化问题。
- **二分法模拟**：利用二分法模拟折叠过程，每次折叠后舍弃一半的区间，减少计算量。
- **异或运算简化分类讨论**：使用异或运算代替复杂的分类讨论，使代码更简洁高效。

### 可拓展之处
同类型题可能涉及更复杂的折叠规则，如多次不同方向的折叠、折叠角度变化等。类似算法套路包括通过手动模拟找规律、利用数据结构（如二叉树）辅助分析、使用二分法或递归模拟过程等。

### 推荐题目
- P1002 [过河卒](https://www.luogu.com.cn/problem/P1002)：通过找规律和动态规划解决路径问题。
- P1044 [栈](https://www.luogu.com.cn/problem/P1044)：利用卡特兰数规律解决栈的进出问题。
- P1192 [台阶问题](https://www.luogu.com.cn/problem/P1192)：通过递推找规律解决台阶走法问题。

### 个人心得摘录与总结
- **qfpjm**：强烈建议用手模拟过程，赛时想了半天，写的时候还出了问题，感觉是一道不错的思维题。总结：手动模拟有助于理解问题，思维题需要多思考和尝试。

---
处理用时：36.06秒
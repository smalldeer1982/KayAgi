# 题目信息

# [USACO23JAN] Following Directions S

## 题目描述

**注：本题时限为 8s，是默认时限的四倍。**

Farmer John 有一个正方形的草地，草地被划分为了 $(N + 1) \times (N + 1)(1 \leq N \leq 1500)$ 的格子。设 $(i, j)$ 为从上到下、从左到右第 $i$ 行，第 $j$ 列的格子。每个满足 $1 \leq i, j \leq n$ 的格子 $(i, j)$ 之中都住着一头牛，而且每个这样的格子上都有一个路标指向右或下。除此之外，所有满足 $i = N + 1$ 或 $j = N + 1$ 的格子，除了 $(N + 1, N + 1)$ 都会有一个饲料桶。牛在每个饲料桶进食需要的价格不同；位置 $(i, j)$ 上的桶喂饱一只牛需要价格 $c_{i, j}(1 \leq c_{i, j} \leq 500)$。

每天晚饭时间，Farmer John 摇响晚餐铃时，所有牛都沿着路标的指向前进，直到它们遇到了饲料桶，之后它们会在它们自己遇到的饲料桶那里进食。第二天，所有牛又会回到自己原来的位置。

为了维持预算，Farmer John 想要知道每天喂食需要的价钱。然而，每天晚饭之前，总会有一头牛 $(i, j)$ 翻转它那里的路标（原来向下则变成向右，反之亦然）。被翻转的路标指向将在后面的日子里保持不变，除非它又被进行了翻转。

给出每天被翻转的路标的坐标，请输出每天喂食需要的价格（总共有 $Q$ 天，$1 \leq Q \leq 1500$）。

## 说明/提示

### 样例 1 解释

在第一次翻转之前，喂养在位置 $(1, 1)$ 和 $(1, 2)$ 的牛需要的价格都为 $1$，喂养在 $(2, 1)$ 的牛需要的价格为 $100$，喂养在 $(2, 2)$ 的牛需要的价格为 $500$。总价格为 $602$。第一次翻转后，在 $(1, 1)$ 处的路标由 `R` 变为 `D`，此时在位置 $(1, 1)$ 的牛喂养的价格变为 $100$（其它牛的价格没有变化），所以总价为 $701$。第二次和第三次翻转都在来回翻转同一个路标。第四次翻转后，在位置 $(1, 1)$ 和位置 $(2, 1)$ 的牛喂养的价格变为 $500$，总价变为 $1501$。


- 测试点 $2 - 4$ 中：$1 \leq N, Q \leq 50$。

- 测试点 $5 - 7$ 中：$1 \leq N, Q \leq 250$。

- 测试点 $2 - 10$ 中：每个路标初始朝向以及被翻转的路标为随机生成。

- 测试点 $11 - 15$ 中：无特殊条件。

## 样例 #1

### 输入

```
2
RR 1
DD 10
100 500
4
1 1
1 1
1 1
2 1```

### 输出

```
602
701
602
701
1501```

# AI分析结果

### 综合分析与结论
本题主要解决在正方形草地中，奶牛按路标走向饲料桶进食，每次翻转一个路标后计算总喂食价格的问题。各题解的核心思路大多围绕预处理和每次操作后的更新展开，通过不同的数据结构和算法优化来降低时间复杂度。

### 所选题解
- **作者：yujinning（5星）**
    - **关键亮点**：思路清晰，将图看作森林，利用树的子树转移来更新答案，时间复杂度为 $O(n^2 + nQ)$，代码注释详细，还给出了调试数据。
    - **核心代码**：
```cpp
inline void dfs(ll x,ll y,ll fa){
    ll ider=id(x,y),iderx=id(x-1,y),idery=id(x,y-1);
    sz[ider]=1;
    f[ider]=fa;
    if(a[x][y-1]=='R'){
        son[ider].push_back(idery);
        dfs(x,y-1,fa);
        sz[ider]+=sz[idery];
    }
    if(a[x-1][y]=='D'){
        son[ider].push_back(iderx);
        dfs(x-1,y,fa);
        sz[ider]+=sz[iderx];
    }
}
inline void dfs_bao(ll x,ll y,ll fa,ll cha){
    ans+=cha;
    f[id(x,y)]=fa;
    if(a[x][y-1]=='R')
        dfs_bao(x,y-1,fa,cha);
    if(a[x-1][y]=='D')
        dfs_bao(x-1,y,fa,cha);
}
```
    - **核心思想**：`dfs` 函数用于初始化每个点的根和子树大小，`dfs_bao` 函数用于更新子树的根和答案。

- **作者：Nuyoah_awa（4星）**
    - **关键亮点**：详细分析了多种解法，从暴力到优化，最后采用从饲料桶向左上 dfs 的方法，时间复杂度为 $O(n^2 + nQ)$，代码结构清晰。
    - **核心代码**：
```cpp
void dfs(long long x, long long y, long long sum)
{
    if(x == 0 || y == 0)
        return ;
    a[x][y] = sum;
    ans += sum;
    if(c[x-1][y] == 'D')
        dfs(x-1, y, sum);
    if(c[x][y-1] == 'R')
        dfs(x, y-1, sum);
    return ;
}
void dfs1(long long x, long long y, long long sum)
{
    if(x == 0 || y == 0)
        return ;
    ans -= a[x][y];
    a[x][y] = sum;
    ans += a[x][y];
    if(c[x-1][y] == 'D')
        dfs1(x-1, y, sum);
    if(c[x][y-1] == 'R')
        dfs1(x, y-1, sum);
    return ;
}
```
    - **核心思想**：`dfs` 函数用于初始化每个点的最终代价和总答案，`dfs1` 函数用于更新修改点左上部分点的最终代价和总答案。

- **作者：FFTotoro（4星）**
    - **关键亮点**：定义多个数组维护状态，通过 dfs 实现数组更新，思路明确，代码简洁。
    - **核心代码**：
```cpp
void dfs(int x,int y,int u){
    f[x][y]=u; r[x][y]=1;
    if(x&&a[x-1][y]==-1)dfs(x-1,y,u),r[x][y]+=r[x-1][y];
    if(y&&a[x][y-1]==-2)dfs(x,y-1,u),r[x][y]+=r[x][y-1];
}
void update1(int x,int y,int u){
    f[x][y]=u;
    if(a[x-1][y]==-1)update1(x-1,y,u);
    if(a[x][y-1]==-2)update1(x,y-1,u);
}
void update2(int x,int y,int u){
    r[x][y]+=u;
    if(a[x][y]==-1)update2(x+1,y,u);
    if(a[x][y]==-2)update2(x,y+1,u);
}
```
    - **核心思想**：`dfs` 函数用于初始化 $f$ 和 $r$ 数组，`update1` 函数用于更新 $f$ 数组，`update2` 函数用于更新 $r$ 数组。

### 最优关键思路或技巧
- **逆向思维**：从饲料桶向左上 dfs，避免重复遍历，降低时间复杂度。
- **数据结构优化**：将图看作森林，利用树的子树转移来更新答案。
- **状态维护**：定义多个数组记录每个点的状态，如经过的奶牛数、最终代价等，方便更新和计算。

### 可拓展之处
同类型题可考虑增加地图的复杂度，如增加方向、障碍物等，算法套路可继续使用预处理和更新的思想，通过维护状态数组来降低时间复杂度。

### 推荐题目
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：涉及图的遍历和状态维护。
- [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：需要预处理和动态规划，与本题的预处理和更新思想类似。
- [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：涉及路径规划和状态转移，可锻炼相关思维。

### 个人心得摘录与总结
- **SolIII**：在计算终点的过程中要顺便更改途经点的牛数和出发点的路牌方向，否则会出现问题。
- **总结**：在处理这类问题时，要注意细节，特别是状态的更新要同步进行，避免出现逻辑错误。 

---
处理用时：34.14秒
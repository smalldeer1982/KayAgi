# 题目信息

# [ROI 2018] Viruses

## 题目背景

译自 [ROI 2018 Day1](https://neerc.ifmo.ru/school/archive/2017-2018.html) T2. [Вирусы](https://neerc.ifmo.ru/school/archive/2017-2018/ru-olymp-roi-2018-day1.pdf) ([Viruses](https://codeforces.com/gym/102147/problem/D))。

## 题目描述

现在有 $n$ 只细胞与 $n$ 个病毒，$i$ 号细胞的初始病毒的序号也为 $i$，每个细胞心中对每位病毒都有一定的易感染度。

细胞之间可以互相攻击，如果细胞甲攻击了细胞乙，且乙「对甲现在的病毒的易感染度」比「对自家病毒的易感染度」高，那么乙就会被甲的病毒感染（成为甲的病毒的细胞）。

细胞们可以任意安排攻击顺序。当且仅当没有细胞可以被任意一名病毒感染时，游戏宣告结束。

如果存在一种攻击顺序，使得病毒 $i$ 最终拥有一只或以上的细胞，那么我们则称病毒 $i$ 为「可行的病毒」。
如果对于任意一种攻击顺序，都使得病毒 $i$ 最终拥有一只或以上的细胞，那么我们则称病毒 $i$ 为「稳定的病毒」。

现在病毒们想知道，有多少个可行的病毒与稳定的病毒。

## 说明/提示

对于所有的数据，$1 \leq n \leq 500$。

| 子任务编号 | $n$ | $p$ |
| :-----------: | :-----------: | :-----------: |
| $1$ | $1 \leq n \leq 5$ | $p = 1$ |
| $2$ | $1 \leq n \leq 500$ | $p = 1$ |
| $3$ | $1 \leq n \leq 5$ | $p = 1,2$ |
| $4$ | $1 \leq n \leq 50$ | $p = 1,2$ |
| $5$ | $1 \leq n \leq 500$ | $p = 1,2$ |

## 样例 #1

### 输入

```
2
1 2
2 1
1```

### 输出

```
2
1 2```

## 样例 #2

### 输入

```
4
3 2 4 1
1 4 2 3
3 1 2 4
1 4 2 3
1```

### 输出

```
1
3```

## 样例 #3

### 输入

```
4
3 2 4 1
1 4 2 3
3 1 2 4
1 4 2 3
2```

### 输出

```
3
1 3 4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕判断稳定病毒和可行病毒展开。对于稳定病毒，各题解思路一致，即当细胞 $i$ 认为病毒 $i$ 最强（$a_{i, 1} = i$）时，病毒 $i$ 是稳定的。对于可行病毒，不同题解有不同的实现方式，但核心思路都是枚举病毒和细胞，判断是否存在一种攻击顺序使病毒存活。部分题解使用了优化技巧，如桶操作、`bitset` 等。

### 所选题解
- **作者：2huk（5星）**
    - **关键亮点**：思路清晰，详细解释了稳定病毒和可行病毒的判断方法，代码注释丰富，可读性强。
    - **核心代码**：
```cpp
// 判断稳定病毒
if (p == 1) {
    for (int i = 1; i <= n; ++ i )
        if (a[i][1] == i) res.push_back(i);
} 
// 判断可行病毒
else {
    for (int i = 1; i <= n; ++ i ) {
        bool Alive = false;
        for (int j = 1; j <= n &&!Alive; ++ j )
            if (b[j][i] <= b[j][j]) {
                memset(st, 0, sizeof st);
                for (int k = 1; k < b[j][i]; ++ k ) {
                    st[a[j][k]] = true;
                }
                bool all_destroyed = true;
                for (int k = 1; k < b[j][i] && all_destroyed; ++ k ) {
                    int x = a[j][k];
                    bool ok = false;
                    for (int l = 1; l < b[x][x] &&!ok; ++ l )
                        if (!st[a[x][l]]) ok = true;
                    if (!ok) all_destroyed = false;
                }
                if (all_destroyed) Alive = true;
            }
        if (Alive) res.push_back(i);
    }
}
```
    - **核心实现思想**：对于稳定病毒，直接判断 $a_{i, 1} = i$。对于可行病毒，枚举病毒 $i$ 和细胞 $j$，标记在细胞 $j$ 心目中比病毒 $i$ 强的病毒，然后判断这些病毒是否都能被灭绝。

- **作者：liuhl_weifang（4星）**
    - **关键亮点**：提供了两种复杂度的代码，先给出 $O(n^4)$ 的暴力解法，再用 `bitset` 优化到 $O(\frac{n^3}{w})$，适合不同水平的学习者。
    - **核心代码（优化后）**：
```cpp
for (int i=1;i<=n;i++){
    for (int j=1;j<=n;j++){
        if(r[j][i]<=r[j][j]) b[i][j] = 1;
    }
}
if(p==1){
    for (int i=1;i<=n;i++) if(c[i][1]==i) ok[i] = true;
}
else{
    for (int j=1;j<=n;j++){
        bitset<510> qwq;
        for (int i=n;i>=1;i--){
            qwq |= b[c[j][i]];
            if(qwq.count()==n) ok[c[j][i]] = true;
        }
    }
}
```
    - **核心实现思想**：使用 `bitset` 记录每个病毒能击败的细胞，然后枚举细胞 $j$，从后往前枚举病毒，更新 `qwq` 集合，若集合大小为 $n$，则该病毒是可行的。

- **作者：Drifty（4星）**
    - **关键亮点**：指出了可以通过桶操作优化复杂度，将复杂度从 $O(n^4)$ 优化到 $O(n^3)$，并给出了详细的代码实现。
    - **核心代码**：
```cpp
if(p==1)
{
    for(int i=0;i^n;i++)
        if(s[i][0]==i)ans[tot++]=i+1;
}
else
{
    for(int i=0;i^n;i++)
    {
        t[i]=n;
        for(int j=0;j^n;j++)
        {
            int cur=0;
            for(int k=0;k^n;k++)
                if(g[j][k]<=g[j][j]&&g[i][k]>cur)cur=g[i][k];
            if(cur<t[i])t[i]=cur;
        }
    }
    for(int i=0;i^n;i++)
        for(int j=0;j^n;j++)
            if(g[j][i]<=g[j][j]&&t[j]>=g[j][i]){ans[tot++]=i+1;break;}
}
```
    - **核心实现思想**：对于稳定病毒，直接判断 $s_{i, 0} = i$。对于可行病毒，通过桶操作记录每个病毒的相关信息，然后枚举病毒和细胞，判断是否满足条件。

### 最优关键思路或技巧
- **稳定病毒判断**：利用细胞对病毒的易感染度排名，当细胞 $i$ 认为病毒 $i$ 最强时，病毒 $i$ 是稳定的。
- **可行病毒判断**：枚举病毒和细胞，判断在细胞心目中比该病毒强的病毒是否都能被灭绝。
- **优化技巧**：使用桶操作、`bitset` 等优化算法复杂度。

### 可拓展之处
同类型题可能会改变细胞和病毒的数量、易感染度的计算方式等，但核心思路仍然是判断病毒的存活情况。类似算法套路包括枚举、模拟、集合运算等。

### 推荐题目
- [P1113 杂务](https://www.luogu.com.cn/problem/P1113)：涉及任务安排和依赖关系，需要枚举和模拟。
- [P1807 最长路](https://www.luogu.com.cn/problem/P1807)：可以使用枚举和图论算法解决。
- [P2014 选课](https://www.luogu.com.cn/problem/P2014)：需要枚举和动态规划来解决选课问题。

### 个人心得
- **Drifty**：提到题面描述模糊，看了很久才理解题意，提醒我们在做题时要仔细阅读题目。同时指出可以考虑每个细胞最多被攻击一次的情况来优化复杂度，并表示懒得写证明，鼓励我们自己思考。

---
处理用时：34.93秒
# 题目信息

# 「MXOI Round 1」涂色

## 题目描述

小 C 正在用彩铅给一张 $n$ 行 $m$ 列的方格纸涂色。初始时，所有方格都是空白的。

他一共要进行 $q$ 次涂色，每次涂色会选取一行或一列，给这一行或这一列的所有方格都添加 $1$ 层颜色。

小 C 喜欢浅色，所以他会在每次涂色结束后，把所有被涂上 $k$ 层颜色的方格的颜色都擦掉，让这些方格都变成空白的。

小 C 想知道，在最终共有多少方格被涂上了颜色。

## 说明/提示

#### 【样例解释 #1】

第 $1$ 行第 $1$ 列的方格没有被涂上颜色，第 $1$ 行第 $2$ 列的方格被涂上了 $1$ 层颜色，第 $1$ 行第 $3$ 列的方格没有被涂上颜色，第 $1$ 行第 $4$ 列的方格被涂上了 $1$ 层颜色；

第 $2$ 行第 $1$ 列的方格被涂上了 $1$ 层颜色，第 $2$ 行第 $2$ 列的方格被涂上了 $2$ 层颜色，第 $2$ 行第 $3$ 列的方格被涂上了 $1$ 层颜色，第 $2$ 行第 $4$ 列的方格被涂上了 $2$ 层颜色；

第 $3$ 行第 $1$ 列的方格被涂上了 $2$ 层颜色，第 $3$ 行第 $2$ 列的方格的颜色被擦掉了，第 $3$ 行第 $3$ 列的方格被涂上了 $2$ 层颜色，第 $3$ 行第 $4$ 列的方格的颜色也被擦掉了；

最终，共有 $8$ 个方格被涂上了颜色。

#### 【样例 #2】

见附加文件中的 `paint/paint2.in` 与 `paint/paint2.ans`。

该样例满足测试点 $1$ 的限制。

#### 【样例 #3】

见附加文件中的 `paint/paint3.in` 与 `paint/paint3.ans`。

该样例满足测试点 $5$ 的限制。

#### 【样例 #4】

见附加文件中的 `paint/paint4.in` 与 `paint/paint4.ans`。

该样例满足测试点 $20$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le n,m \le 2\times 10^5$，$1 \le k \le q \le 5 \times 10^5$，$op \in \{1,2\}$，保证当 $op=1$ 时 $1 \le x \le n$，当 $op=2$ 时 $1 \le x \le m$。

|测试点编号|$n,m \le$|$q \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim4$|$3000$|$3000$|无|
|$5\sim9$|$3000$|$5\times10^5$|无|
|$10\sim12$|$2\times10^5$|$5\times10^5$|A|
|$13\sim16$|$2\times10^5$|$5\times10^5$|B|
|$17\sim20$|$2\times10^5$|$5\times10^5$|无|

特殊性质 A：保证 $op=1$。

特殊性质 B：保证 $k=2$。

## 样例 #1

### 输入

```
3 4 5 3
1 3
2 4
1 2
1 3
2 2```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解大多采用了类似的核心思路，即通过记录每行和每列的涂色次数，利用取模和桶计数的方法来避免直接模拟二维数组，从而降低时间复杂度。不同题解在具体实现和优化细节上有所差异，部分题解针对不同数据范围给出了不同的解法。

### 高评分题解
- **作者：BL_zhanggezi（5星）**
    - **关键亮点**：思路清晰，详细阐述了从二维差分的初步想法到使用一维数组、二分查找，再到最终使用数组计数优化的整个思考过程，代码注释详细。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,nm,k,as,x,h[200010],s[200010],ans=0,c,ss[500010];
int main()
{
    cin>>n>>m>>nm>>k;
    ss[0]=n; 
    for(int i=1;i<=nm;i++)
    {
        cin>>as>>x;
        if(as==1) 
        {
            h[x]++;
            ss[h[x]-1]--;
            ss[h[x]]++;
        } 
        else s[x]++;
    }
    sort(h+1,h+n+1);
    ans=n*m;
    for(int i=1;i<=m;i++)
    {
        c=s[i]%k;
        for(int j=(k-c)%k;j<=h[n];j+=k)
        {
            ans=ans-ss[j];
        }
    }
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：用两个一维数组 `h` 和 `s` 分别记录行和列的涂色次数，使用 `ss` 数组计数优化求符合要求的数量，最后用总方格数减去空白方格数得到答案。

- **作者：wpy233（4星）**
    - **关键亮点**：提出了涂色操作顺序无关和计算涂色方格数量的引理，思路严谨，代码注释详细。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll a[200005];
ll b[200005];
ll c[500005];
ll d[500005];
inline ll read()
{
    char ch;
    ll x=0,f=1;
    for(;!isdigit(ch);ch=getchar())
        if(ch=='-')
            f=-1;
    for(; isdigit(ch);ch=getchar())
        x*=10,x+=(ch-'0');
    return x*f;	
}
int main()
{
    int n,m,q,k;
    n=read(),m=read();
    q=read(),k=read();
    int op,x;
    for(int i=1;i<=q;i++)
    {
        op=read();
        x=read();
        if(op==1) 
        {
            a[x]++;
            if(a[x]==k) 
                a[x]=0; 
        }
        else 
        {
            b[x]++;
            if(b[x]==k) 
                b[x]=0;
        }
    }
    ll ans1=0,ans2=0,ans;
    for(int i=1;i<=n;i++)
        if(a[i]>0)
        {
            ans1++;
            c[a[i]]++;
        }
    for(int i=1;i<=m;i++)
        if(b[i]>0)
        {
            ans2++;
            d[b[i]]++;
        }
    ans=ans1*m+ans2*n-ans1*ans2;
    for(int i=1,j=k-1;i<=k-1,j>=1;i++,j--)
        ans-=c[i]*d[j];
    cout<<ans<<endl;
    return 0;
}
```
    - **核心实现思想**：记录每行和每列的涂色次数并对 $k$ 取模，统计涂色的行和列的数量，利用公式计算涂色方格数，再减去涂色次数加和为 $k$ 的交叉格。

- **作者：Coffee_zzz（4星）**
    - **关键亮点**：针对不同的数据范围给出了不同的解法，具有很强的针对性和实用性。
    - **核心代码**：
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+5,K=5e5+5;
int c[N],r[N],w[K];
int main(){
    ios::sync_with_stdio(0);
    int n,m,q,k,op,x;
    ll cnt=0;
    cin>>n>>m>>q>>k;
    for(int tmp=1;tmp<=q;tmp++){
        cin>>op>>x;
        if(op==1) r[x]++;
        else c[x]++;
    }
    for(int i=1;i<=n;i++) w[r[i]%k]++;
    for(int j=1;j<=m;j++){
        c[j]%=k;
        if(c[j]==0) cnt=cnt+n-w[0];
        else cnt=cnt+n-w[k-c[j]];
    }
    cout<<cnt;
    return 0;
}
```
    - **核心实现思想**：用 `r` 和 `c` 数组记录每行和每列的涂色次数，用 `w` 数组统计 `r` 中每个元素对 $k$ 取模后的出现次数，最后计算每个 `c[j]` 对答案的贡献。

### 最优关键思路或技巧
- **使用一维数组替代二维数组**：由于 $n$ 和 $m$ 范围较大，开二维数组会爆内存，使用两个一维数组分别记录行和列的涂色次数，避免了内存问题。
- **取模和桶计数**：对涂色次数进行取模操作，利用桶计数统计每行或每列取模后的值的出现次数，从而可以快速计算出满足条件的方格数量，将时间复杂度从 $O(nm)$ 降低到 $O(n + m)$。
- **正难则反**：直接计算涂色方格数量较困难时，考虑计算空白方格数量，用总方格数减去空白方格数得到答案。

### 拓展思路
同类型题可能会有更多的操作类型，如对矩形区域进行涂色，或者有不同的擦除规则。类似算法套路可以用于处理矩阵操作类问题，通过记录行和列的操作信息，利用取模和计数的方法来降低复杂度。

### 推荐题目
- P1428 小鱼比可爱：考察数组的基本操作和计数思想。
- P1047 校门外的树：涉及区间操作和计数问题。
- P2089 烤鸡：需要使用枚举和计数的方法解决问题。

### 个人心得摘录与总结
- **作者：sbno333**：该作者卡在 60 分，赛后发现加了两个字符（取模操作）就 AC 了，提醒我们在处理数据时要注意取模，避免数据溢出或逻辑错误。
- **作者：liangjindong0504**：作者从暴力思路逐步推导到正解，强调了使用大样例和正难则反的思维方式，对于初学者有很大的帮助，告诉我们在解题时要善于从不同角度思考问题。 

---
处理用时：48.06秒
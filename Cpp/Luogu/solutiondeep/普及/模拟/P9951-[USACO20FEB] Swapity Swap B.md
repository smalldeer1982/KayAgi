# 题目信息

# [USACO20FEB] Swapity Swap B

## 题目描述

Farmer John 的 $N$ 头奶牛（$1\le N\le 100$）站成一排。对于每一个 $1\le i\le N$，从左往右数第 $i$ 头奶牛的编号为 $i$。

Farmer John 想到了一个新的奶牛晨练方案。他让她们重复以下包含两个步骤的过程 $K$（$1\le K\le 10^9$）次：

1. 当前从左往右数在位置 $A_1\ldots A_2$ 的奶牛序列反转她们的顺序（$1\le A1<A2\le N$）。
2. 然后，在当前从左往右数在位置 $B_1\ldots B_2$的奶牛序列反转她们的顺序（$1\le B_1<B_2\le N$）。

当奶牛们重复这一过程 $K$ 次后，请对每一个 $1\le i\le N$ 输出从左往右数第 $i$ 头奶牛的编号。 

## 说明/提示

### 样例解释 1

初始时，奶牛们的顺序从左往右为 $[1,2,3,4,5,6,7]$。在这一过程的第一步过后，顺序变为 $[1,5,4,3,2,6,7]$。在这一过程的第二步过后，顺序变为 $[1,5,7,6,2,3,4]$。再重复这两个步骤各一次可以得到样例的输出。 

### 测试点性质

- 测试点 $2-3$ 满足 $K\le 100$。
- 测试点 $4-13$ 没有额外限制。

## 样例 #1

### 输入

```
7 2
2 5
3 7```

### 输出

```
1
2
4
3
5
7
6```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是利用序列翻转操作的周期性来优化暴力模拟。由于 $k$ 最大可达 $10^9$，直接暴力模拟会超时，因此需要找出序列经过多少次操作后会回到初始状态，即找到循环节，然后用 $k$ 对循环节长度取模，减少不必要的操作。

### 所选题解
- **作者：Distorted_Fate_（4星）**
    - **关键亮点**：思路清晰，先给出暴力超时代码，再逐步引导优化，通过观察结果找出循环节，并用 $k \bmod ok$ 优化。
    - **核心代码**：
```cpp
while(f!=1) {
    f=1;
    for(int i=a1,j=a2; i<=j; i++,j--) {
        swap(a[i],a[j]);
    }
    for(int i=b1,j=b2; i<=j; i++,j--) {
        swap(a[i],a[j]);
    }
    for(int i=1; i<=n; i++) {
        if(a[i]!=b[i])f=0;
    }
    ok++;
}
k%=ok;
```
    - **核心实现思想**：不断进行两次翻转操作，每次操作后检查序列是否回到初始状态，若回到初始状态则记录循环节长度 $ok$，最后用 $k$ 对 $ok$ 取模。

- **作者：I_am_Tangser（4星）**
    - **关键亮点**：不仅给出代码，还对方法的正确性进行了证明，通过分析每个数字的周期，说明一定存在一个公倍数使得序列回到初始状态。
    - **核心代码**：
```cpp
while(f){
    c++;
    f=0;
    for(int i=a1,j=a2;i<j;i++,j--)swap(a[i],a[j]);
    for(int i=b1,j=b2;i<j;i++,j--)swap(a[i],a[j]);
    for(int i=1;i<=n;i++)if(b[i]!=a[i])f=1;
}
k%=c;
while(k--){
    for(int i=a1,j=a2;i<j;i++,j--)swap(b[i],b[j]);
    for(int i=b1,j=b2;i<j;i++,j--)swap(b[i],b[j]);
}
```
    - **核心实现思想**：不断进行两次翻转操作，每次操作后检查序列是否回到初始状态，若回到初始状态则记录循环节长度 $c$，最后用 $k$ 对 $c$ 取模，再进行剩余次数的操作。

- **作者：Awatesolo（4星）**
    - **关键亮点**：使用了 `reverse` 函数简化代码，同时实现了快速读入，提高代码效率。
    - **核心代码**：
```cpp
for(int qw=1;qw<=m;qw++){
    reverse(a + a1, a + a2 + 1);
    reverse(a + b1, a + b2 + 1);
    f=1;
    for(int i=1;i<=n;i++){
        if(a[i]!=b[i]) f=0;
    }
    op++;
    if(f==1)
    {
        break;
    }
}
m=m%op;
for(int qw=1;qw<=m;qw++){
    reverse(a + a1, a + a2 + 1);
    reverse(a + b1, a + b2 + 1);	
}
```
    - **核心实现思想**：不断进行两次翻转操作，每次操作后检查序列是否回到初始状态，若回到初始状态则记录循环节长度 $op$，最后用 $m$ 对 $op$ 取模，再进行剩余次数的操作。

### 最优关键思路或技巧
- **找循环节**：通过不断模拟操作，检查序列是否回到初始状态，找出循环节长度，用总操作次数对循环节长度取模，减少不必要的操作。
- **使用 `reverse` 函数**：简化区间翻转操作的代码实现。

### 可拓展之处
同类型题或类似算法套路：
- 涉及大量重复操作且存在周期性的问题，都可以考虑找出循环节进行优化。
- 对于序列的变换问题，可以通过模拟操作找出规律，进而优化算法。

### 推荐题目
- P1149 [NOIP2008 提高组] 火柴棒等式
- P1045 [NOIP2003 普及组] 麦森数
- P1060 [NOIP2006 普及组] 开心的金明

### 个人心得摘录与总结
- **Distorted_Fate_**：先写出暴力代码发现超时，然后通过多输出结果观察规律，找到循环节进行优化。总结为遇到超时问题可通过观察结果找规律优化。
- **wwxxbb**：一开始用 `reverse` 函数暴力模拟超时，后来想到序列翻转存在周期，通过求周期的最小公倍数优化。总结为暴力超时后可考虑问题的周期性进行优化。
- **ymyctsz**：先尝试分类讨论不同区间情况找规律，但部分情况结论不具有普遍性，最后通过求所有数回到原位置的最小次数的最小公倍数解决问题。总结为分类讨论可能存在局限性，可从更本质的角度（如每个元素的周期）解决问题。 

---
处理用时：33.90秒
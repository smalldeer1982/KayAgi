# 题目信息

# [USACO23DEC] Candy Cane Feast B

## 题目描述

Farmer John 的奶牛对甜食情有独钟，它们尤其喜欢吃糖果棒。FJ 共有 $N$ 头奶牛，每头奶牛都有一个特定的初始高度。他想要喂它们 $M$ 根糖果棒，每根糖果棒的高度也各不相同（$1 \le N,M \le 2\cdot 10^5$）。

FJ 计划按照输入给出的顺序，逐一喂给奶牛们糖果棒。然后，奶牛们会按照输入给出的顺序一个接一个地排队，走向糖果棒，每头奶牛最多吃到与它高度相同的部分（因为它们够不到更高的地方）。即使奶牛吃掉了糖果棒的底部，糖果棒也在最初悬挂的地方保持不动，并不会被降低到地面。如果糖果棒的底部已经高于某头奶牛的高度，那么这头奶牛在它的回合中可能什么也吃不到。每头奶牛轮流吃过后，它们的身高会增加它们吃掉的糖果棒的单位数量，然后农夫约翰挂上下一根糖果棒，奶牛们再次重复这个过程（第一头奶牛再次成为第一个开始吃下一根糖果棒的）。

## 说明/提示

### 样例解释 1

第一根糖果棒高度为 $6$ 单位。

- 第一头奶牛吃掉了第一根糖果棒直至高度 $3$ 的部分，之后第一根糖果棒剩余高度 $[3,6]$ 的部分。
- 第二头奶牛不够高，无法吃掉第一根糖果棒的任何剩余部分。
- 第三头奶牛额外吃掉了第一根糖果棒的两个单位。第一根糖果棒的剩余高度 $[5,6]$ 的部分未被吃掉。

接下来，每头奶牛根据它吃掉的数量增长，所以奶牛的高度变为 $[3+3, 2+0, 5+2]=[6, 2, 7]$。

第二根糖果棒高度为 $1$ 单位，被第一头奶牛全部吃掉。

### 测试点性质

- 测试点 $2-10$ 满足 $N,M \le 10^3$。
- 测试点 $11-14$ 没有额外限制。


## 样例 #1

### 输入

```
3 2
3 2 5
6 1```

### 输出

```
7
2
7```

# AI分析结果

### 综合分析与结论
这些题解核心思路都是模拟奶牛吃糖果棒的过程，主要差异在于优化策略。大家都发现第一头牛的状态对复杂度影响大，若第一头牛没吃光糖果棒，其高度翻倍，此情况最多出现 $\log 10^9$ 次，之后第一头牛能一口吃光糖果棒，复杂度降为 $O(1)$。部分题解通过提前 `break` 避免无效计算。

### 所选题解
- **Expert_Dream（5星）**
    - **关键亮点**：思路清晰，直接点明第一头牛的两种情况，代码简洁易读，复杂度分析明确。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
#define int long long
int n,m;
int a[N],b[N];
void solve(){
    cin >> n >> m;
    for(int i = 1;i <= n;i++)
        cin >> a[i];
    for(int i = 1;i <= m;i++)
        cin >> b[i];

    for(int i = 1;i <= m;i++){
        if(b[i] <= a[1]){
            a[1]+=b[i];
            continue;
        } 
        int tmp = 1;
        for(int j = 1;j <= n;j++)
            if(a[j] >= tmp && tmp <= b[i]){
                int t=a[j]+1;
                a[j] += min(a[j]-tmp+1,b[i]-tmp+1);
                tmp = t;
            }
    }

    for(int i = 1;i <= n;i++)
        cout<<a[i]<<endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    solve();
    return 0;
}
```
    - **核心实现思想**：先特判糖果棒能否被第一头牛全吃掉，若不能则遍历每头牛，更新其高度和糖果剩余部分。
- **xiaoshumiao（4星）**
    - **关键亮点**：详细分析模拟过程，给出未优化和优化后的代码，对复杂度证明清晰。
    - **核心代码**：
```cpp
#include<cstdio>
using namespace std;
const int MAXN=200005,MAXM=200005;
long long a[MAXN];
struct Candy {
  int s,e;
}b[MAXM];
int main() {
  int n,m;
  scanf("%d %d",&n,&m);
  for(int i=1;i<=n;i++)
    scanf("%lld",&a[i]);
  for(int i=1;i<=m;i++) {
  	scanf("%d",&b[i].e);
  	b[i].s=0;
  }
  for(int i=1;i<=m;i++) {
  	for(int j=1;j<=n;j++) {
  	  if(b[i].s==b[i].e)
  	    break;
  	  if(a[j]>b[i].s) {
  	  	int t=b[i].s;
  	  	if(a[j]>b[i].e) {
  	  	  b[i].s=b[i].e;
  	  	  a[j]+=b[i].e-t;
  	  	}
  	  	else {
  	  	  b[i].s=a[j];
		  a[j]+=a[j]-t;
  	  	}
  	  }
  	}
  }
  for(int i=1;i<=n;i++)
    printf("%lld\n",a[i]);
  return 0;
}
```
    - **核心实现思想**：用结构体记录糖果棒上下端位置，模拟每头牛吃糖果棒过程，若糖果棒吃完则提前 `break`。
- **Night_sea_64（4星）**
    - **关键亮点**：先给出暴力代码，再分析优化点，优化思路清晰，代码改动小。
    - **核心代码**：
```cpp
#include<iostream>
using namespace std;
int n,m;
long long a[200010];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=m;i++)
    {
        int x,down=0;
        cin>>x;
        for(int j=1;j<=n;j++)
        {
            int k=max(0ll,min(a[j],(long long)x)-down);
            down+=k,a[j]+=k;
            if(down==x)break;
        }
    }
    for(int i=1;i<=n;i++)cout<<a[i]<<endl;
    return 0;
}
```
    - **核心实现思想**：模拟过程中记录糖果棒被吃的最低高度，若糖果棒吃完则提前 `break`。

### 最优关键思路或技巧
- 抓住第一头牛的状态，分析其高度变化规律，利用高度指数级增长特性优化复杂度。
- 模拟过程中，当糖果棒被吃完时及时 `break`，避免无效计算。

### 可拓展之处
同类型题可能涉及更多元素或规则变化，如增加糖果棒类型、奶牛属性等。类似算法套路是分析关键元素状态变化，利用特殊性质优化暴力模拟。

### 洛谷相似题目推荐
- P1003 铺地毯
- P1047 校门外的树
- P1098 字符串的展开

### 个人心得摘录与总结
- **xiaoshumiao**：第一次打 USACO，发题解纪念，还推荐看官方题解。总结为新手参赛分享经历并推荐学习资源。
- **_sh1kong_**：赛时 5 分钟过题，看不懂大家做法，分享自己思路。体现赛时快速解题并分享独特思路。 

---
处理用时：32.18秒
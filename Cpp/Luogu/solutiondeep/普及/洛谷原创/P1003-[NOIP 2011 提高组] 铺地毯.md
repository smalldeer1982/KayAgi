# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果

• 综合分析与结论：这些题解都围绕如何避免开二维数组导致内存超限，采用直接判断点是否在地毯内的方法解决问题。思路上大多是枚举每张地毯，判断给定点是否在地毯范围内，若在则更新答案。算法要点在于掌握矩形范围判断条件，即 \(x\) 坐标在 \(a\) 到 \(a + g\) 之间且 \(y\) 坐标在 \(b\) 到 \(b + k\) 之间。解决难点主要是避免使用过大的二维数组，通过直接对每个地毯进行判断来优化空间复杂度。整体题解质量差异不大，多数题解思路清晰但代码实现上创新性不足。

所选的题解：
  - 作者：智子 (赞：260)  星级：4星
    - 关键亮点：先指出开二维数组会MLE的问题，并给出两种思路，一种是错误示范，另一种是AC思路，讲解详细。
    - 个人心得：指出开二维数组会导致MLE，分析了数组大小超出内存限制的原因。
    - 重点代码及核心思想：
```cpp
#include<stdio.h>

const int MAXN = 10000 + 5;

int a[MAXN], b[MAXN], g[MAXN], k[MAXN];

int main() {
    int n, x, y;
    
    scanf("%d", &n);
    for(int i = 0; i < n; i++) {
        scanf("%d%d%d%d", &a[i], &b[i], &g[i], &k[i]);//输入地毯信息
    }
    scanf("%d%d", &x, &y);
    
    int ans = -1;
    for(int i = 0; i < n; i++) {
        if(x >= a[i] && y >= b[i] && x <= a[i] + g[i] && y <= b[i] + k[i]) {
            ans = i + 1;//判断点是否在地毯内，更新答案
        }
    }
    
    printf("%d\n", ans);//输出结果
    
    return 0;
}
```
核心思想是用四个数组分别存储每张地毯的参数，遍历所有地毯，判断给定点是否在地毯范围内，若在则更新为该地毯编号。

  - 作者：谁懂谁伤心 (赞：47)  星级：4星
    - 关键亮点：提出从后向前遍历地毯的方法，相比正向遍历在找到目标地毯时效率更高。
    - 重点代码及核心思想：
```cpp
#include <iostream>  
using namespace std;  
int a[10001][2],b[10001][2],x,y,i,n,m;  
int main()  
{  
scanf ("%d",&i);   
for (int j=1;j<=i;j++) {scanf("%d%d%d%d",&a[j][0],&a[j][1],&n,&m); b[j][0]=a[j][0]+n; b[j][1]=a[j][1]+m;}//存储地毯信息
scanf ("%d%d",&x,&y);  
for (int j=i;j>=1;j--)  
if (x>=a[j][0]&&x<=b[j][0]&&y>=a[j][1]&&y<=b[j][1]) {printf("%d",j);  return 0;}//从后向前遍历判断
cout <<-1;  return 0;  
}  
```
核心思想是用两个二维数组分别存储每张地毯的左下角和右上角坐标，从后向前遍历地毯，判断点是否在地毯内，若在则输出该地毯编号并结束程序。

  - 作者：Jayfeather2012 (赞：0)  星级：4星
    - 关键亮点：思路清晰，明确阐述从后往前遍历地毯找覆盖点的原因及做法。
    - 重点代码及核心思想：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10003],b[10003],g[10003],k[10003],n,x,y;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i]>>b[i]>>g[i]>>k[i];//输入地毯信息
	cin>>x>>y;
	for(int i=n;i>=1;i--)
	{
		if(a[i]<=x&&a[i]+g[i]>=x&&b[i]<=y&&b[i]+k[i]>=y)
		//判断所求位置是否被地毯覆盖
		{
			cout<<i;
			return 0;//输出并结束
		}
	}
	cout<<-1;//没有找到输出-1
	return 0;
}
```
核心思想是用数组存储地毯信息，从后往前遍历地毯，判断给定点是否在地毯范围内，若在则输出该地毯编号，否则输出 -1。

最优关键思路或技巧：避免使用大的二维数组，采用直接判断点是否在地毯内的方法。从后向前遍历地毯能在找到目标地毯时更快结束循环，一定程度上优化时间复杂度。

可拓展之处：同类型题通常围绕图形覆盖、区域判断等场景，类似算法套路是避免不必要的空间浪费，直接对目标对象进行判断。例如在处理一些几何图形相交、包含关系等问题时，可采用类似直接判断的方式。

推荐题目：
  - P1244 青蛙过河：涉及位置判断和路径规划，与本题判断点是否在区域内思路类似。
  - P1085 不高兴的津津：根据条件判断时间区间，和本题判断点在矩形区间内思路有相似性。
  - P1427 小鱼的数字游戏：同样是对输入数据进行遍历判断，与本题遍历地毯判断点的过程类似。 

---
处理用时：36.96秒
# 题目信息

# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# AI分析结果

### 综合分析与结论
这些题解均基于区间动态规划求解本题，思路核心为利用每行取数互不影响的特性，对每行分别进行区间DP。
1. **思路**：将矩阵每行独立处理，对每行构建区间DP模型，通过状态转移方程计算取数最大得分，最后累加每行得分得到总得分。
2. **算法要点**：
    - **状态定义**：多数题解用$f_{i,j}$表示取区间$[i,j]$的最大得分，但部分题解的区间定义和含义略有不同，如表示区间变为$[i,j]$时的最大分数。
    - **转移方程**：从$[i - 1,j]$或$[i,j + 1]$等相邻区间转移，结合取数规则构建方程，因考虑取数顺序和$2^i$的系数，不同题解转移方程形式有差异，但本质相同。
    - **最终答案**：因空区间无法DP，需手动处理长度为1的区间来确定最终答案。
3. **解决难点**：
    - **高精度计算**：因数据范围大，计算过程易溢出，部分题解采用高精度算法（如高精加、高精乘等），部分使用`__int128`类型。
    - **DP顺序**：需注意区间DP的顺序，从大区间向小区间转移或小区间向大区间转移时，要保证状态转移时所需状态已计算。

### 所选的题解
- **作者：Jack_Homes_Huang（5星）**
    - **关键亮点**：思路阐述清晰，详细说明了最优子结构和区间DP的应用，对DP流程（状态、转移、终值）讲解细致，代码实现采用高精度且注释详细，利于理解。
    - **个人心得**：提到高精度处理较繁琐，需使用多种高精度运算，如高精加、高精乘和比较大小。
    - **重点代码（核心实现思想：通过重载运算符实现高精度运算，按DP流程计算每行最大得分并累加）**：
```cpp
HP operator + (const HP &a, const HP &b) {
    HP c; c.len = max(a.len, b.len); int x = 0;
    for (int i = 1; i <= c.len; i++) {
        c.p[i] = a.p[i] + b.p[i] + x;
        x = c.p[i] / Mod;
        c.p[i] %= Mod;
    }
    if (x > 0)
        c.p[++c.len] = x;
    return c;
} 
HP operator * (const HP &a, const int &b) {
    HP c; c.len = a.len; int x = 0;
    for (int i = 1; i <= c.len; i++) {
        c.p[i] = a.p[i] * b + x;
        x = c.p[i] / Mod;
        c.p[i] %= Mod;
    }
    while (x > 0)
        c.p[++c.len] = x % Mod, x /= Mod;
    return c;
} 
HP max(const HP &a, const HP &b) {
    if (a.len > b.len)
        return a;
    else if (a.len < b.len)
        return b;
    for (int i = a.len; i > 0; i--)
        if (a.p[i] > b.p[i])
            return a;
        else if (a.p[i] < b.p[i])
            return b;
    return a;
} 
void BaseTwo() {
    base[0].p[1] = 1, base[0].len = 1;
    for (int i = 1; i <= m + 2; i++){ 
        base[i] = base[i - 1] * 2;
    }
} 
int main(void) {
    scanf("%d%d", &n, &m);
    BaseTwo();
    while (n--) {
        memset(f, 0, sizeof f);
        for (int i = 1; i <= m; i++)
            scanf("%d", &ar[i]);
        for (int i = 1; i <= m; i++)
            for (int j = m; j >= i; j--) { 
                f[i][j] = max(f[i][j], f[i - 1][j] + base[m - j + i - 1] * ar[i - 1]); 
                f[i][j] = max(f[i][j], f[i][j + 1] + base[m - j + i - 1] * ar[j + 1]);
            } 
        HP Max;
        for (int i = 1; i <= m; i++)
            Max = max(Max, f[i][i] + base[m] * ar[i]);
        ans = ans + Max; 
    }
    ans.print(); 
    return 0;
}
```
- **作者：zhylj（4星）**
    - **关键亮点**：思路简洁明了，直接给出转移方程并解释其含义，代码使用`__int128`简化高精度处理，且有自定义输入输出函数，程序整体简洁高效。
    - **重点代码（核心实现思想：通过`__int128`类型进行计算，按转移方程计算每行最大得分并累加）**：
```cpp
__int128 f[MAXN][MAXN];
__int128 solve(__int128 a[])
{
    memset(f,0,sizeof(f));
    for(int len=0;len<=m;++len)
    	for(int i=1;i+len<=m;++i)
            f[i][i+len]=max(2*f[i+1][i+len]+2*a[i],2*f[i][i+len-1]+2*a[i+len]);
    return f[1][m];
}
__int128 ans=0;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            input(game[i][j]);
    for(int i=1;i<=n;i++)
        ans+=solve(game[i]);
    output(ans);
    return 0;
}
```
- **作者：qhr2023（4星）**
    - **关键亮点**：对区间DP思路讲解清晰，特别是对从小区间向大区间转移时如何处理$2^i$系数的分析独特且易懂，代码简洁，逻辑清晰。
    - **重点代码（核心实现思想：通过`__int128`类型进行计算，按从小区间向大区间转移的方式计算每行最大得分并累加）**：
```cpp
int main () {
	cin >> n >> m;
	for (int i=1; i<=n; ++i)
		for (int j=1; j<=m; ++j)
			cin >> a[i][j];
	for (int i=1; i<=n; ans+=f[1][m], memset(f, 0, sizeof f), ++i) 
		for (int len=1; len<=m; ++len) 
			for (int l=1, r=l+len-1; r<=m; ++l, ++r)
				f[l][r]=max(f[l+1][r]+a[i][l], f[l][r-1]+a[i][r])*2;
	out(ans);
	return 0;
}
```

### 最优关键思路或技巧
1. **独立分析**：利用每行取数相互独立的特点，将二维矩阵问题转化为多个一维数组的区间DP问题，简化问题规模。
2. **区间DP**：准确构建区间DP模型，合理定义状态和转移方程，注意DP顺序以确保状态转移的正确性。
3. **数据处理**：针对大数据范围，可采用高精度算法或`__int128`类型处理数据，防止溢出。

### 可拓展思路
此类题目属于区间DP与最优解结合的问题，类似套路是分析问题的独立性，将大问题拆分为子问题，构建合适的区间DP模型。同类型题常涉及在一定规则下对区间元素操作求最值，如石子合并等问题。

### 相似知识点洛谷题目
1. **P1880 [NOI1995] 石子合并**：经典区间DP题目，通过合并相邻石子堆求最小或最大得分。
2. **P4170 [CQOI2007] 涂色**：对线段按规则涂色，求最少涂色次数，考察区间DP应用。
3. **P3146 [USACO16OPEN]248 G**：在一维数组上按规则合并元素，求最大合并值，也是区间DP的应用。 

---
处理用时：69.57秒
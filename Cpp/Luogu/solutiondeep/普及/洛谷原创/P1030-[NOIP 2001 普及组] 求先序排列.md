# 题目信息

# [NOIP 2001 普及组] 求先序排列

## 题目描述

给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \le 8$）。


## 说明/提示

**【题目来源】**

NOIP 2001 普及组第三题

## 样例 #1

### 输入

```
BADC
BDCA
```

### 输出

```
ABCD
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕根据二叉树的中序和后序排列求先序排列展开。大部分题解思路基于利用后序遍历最后一个节点是根节点，在中序遍历中找到该根节点以划分左右子树，进而递归求解。算法要点集中在递归实现和字符串处理上。难点在于准确划分左右子树的中序和后序序列。多数题解思路和代码较为常规，少数题解提供新思路如利用二叉搜索树还原树结构。

所选的题解：
 - 作者：sunyufei (赞：1290)  星级：5星
关键亮点：思路清晰，直接阐述核心思路并以示例辅助理解，代码简洁明了，用`string`类型及相关函数实现递归求解，可读性高。
重点代码：
```cpp
void beford(string in,string after){
    if (in.size()>0){
        char ch=after[after.size()-1];
        cout<<ch;
        int k=in.find(ch);
        beford(in.substr(0,k),after.substr(0,k));
        beford(in.substr(k+1),after.substr(k,in.size()-k-1));
    }
}
```
核心实现思想：在`beford`函数中，先获取后序遍历的最后一个字符作为根节点输出，通过`in.find(ch)`在中序遍历中找到根节点位置`k`，再递归处理左右子树对应的中序和后序子串。

 - 作者：NeosKnight (赞：337)  星级：4星
关键亮点：详细分析了如何通过中序和后序遍历找出两段子树的后序遍历序列这一难点，代码使用字符数组和自定义函数实现递归，逻辑清晰。
重点代码：
```cpp
inline int find(char ch)
{
    for(int i=0;i<len;i++)
    {
        if(s1[i]==ch) return i;
    }
}
void dfs(int l1,int r1,int l2,int r2)
{
    int m=find(s2[r2]);
    cout<<s2[r2];
    if(m>l1) dfs(l1,m-1,l2,r2-r1+m-1);
    if(m<r1) dfs(m+1,r1,l2+m-l1,r2-1);
}
```
核心实现思想：`find`函数用于在中序遍历字符串`s1`中查找字符`ch`的位置。`dfs`函数通过`find`找到根节点位置`m`，输出根节点后，根据`m`与左右边界关系递归处理左右子树。

 - 作者：sshwy (赞：158)  星级：4星
关键亮点：提供新颖思路，利用二叉搜索树特性，通过后序遍历颠倒顺序插入元素还原树结构，再前序遍历输出，拓展了解题视角。
重点代码：
```cpp
bNode tree_insert(bNode tree_root,int nkey)
{
    bNode z=new node,y=NULL,x=tree_root;
    z->key=nkey;
    while(x!=NULL)
    {
        y=x;
        if(nkey<x->key)x=x->left;
        else x=x->right;
    }
    z->p=y;
    if(y==NULL)tree_root=z;
    else if(nkey<y->key)y->left=z;
    else y->right=z;
    
    return tree_root;
}

void tree_preorder(bNode k)
{
    if(k==NULL)return;
    cout<<let[k->key];
    tree_preorder(k->left);
    tree_preorder(k->right);
}
```
核心实现思想：`tree_insert`函数实现二叉搜索树节点插入，根据节点键值比较确定插入位置。`tree_preorder`函数实现二叉搜索树前序遍历，输出节点对应字母。

最优关键思路或技巧：利用后序遍历根节点在最后的特性确定根，结合中序遍历划分左右子树，递归构建树结构并输出先序遍历，这是常规且高效的方法。部分题解在字符串处理和递归实现上的简洁代码值得学习，如`string`的`find`和`substr`函数运用。而利用二叉搜索树还原树结构的思路则提供了不同的思考方向。

可拓展之处：同类型题可涉及根据不同遍历序列组合求其他遍历序列，类似算法套路围绕二叉树遍历特性和递归构建树结构展开。

推荐题目：
 - P1305 新二叉树：已知先序和中序遍历，求后序遍历。
 - P2022 消息扩散：通过二叉树遍历解决消息传播问题，涉及对树结构和遍历的理解。
 - P1070 道路游戏：结合动态规划与二叉树遍历，考察对树结构及算法综合运用。

个人心得摘录及总结：作者Ybw0731提到本题坑点在于中序和后序遍历时要去掉根节点（在找到根节点后利用查找子串函数分裂），强调了细节处理对解题的重要性。 

---
处理用时：33.51秒
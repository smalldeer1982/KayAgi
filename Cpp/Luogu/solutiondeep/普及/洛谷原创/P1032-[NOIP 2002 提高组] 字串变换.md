# 题目信息

# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# AI分析结果

这道题要求利用给定的最多6条字符串变换规则，将字符串A变换为字符串B，并求出最少变换步数，若10步内无法完成则输出"NO ANSWER!"。众多题解主要围绕搜索算法展开，以广度优先搜索（BFS）及其优化为主流思路，部分题解采用迭代加深搜索（IDS）。

### 综合分析与结论
1. **思路**：多数题解采用BFS，因其能保证找到的第一个解即为最优解，符合题目求最少变换步数的要求。部分题解使用IDS，通过限制搜索深度逐步增加深度来搜索，兼具DFS递归形式与BFS避免过深搜索的优点。还有题解提出双向BFS，从初始字符串和目标字符串同时搜索，相遇时得到最优解，能大幅减少搜索空间和时间。
2. **算法要点**：需存储字符串变换规则，常用数组或容器（如`vector`、`map`、`multimap`等）。搜索过程中，对当前字符串按规则进行变换，生成新字符串并判断是否符合目标。为避免重复搜索，利用`map`、`set`或哈希表进行判重。
3. **解决难点**：输入处理上，需处理不定数量的变换规则输入。字符串处理方面，要考虑一个字符串中可能有多个相同子串可变换，以及同一子串可能对应多种变换规则。效率优化上，通过判重减少无效搜索，双向BFS、迭代加深搜索等优化策略提高搜索效率。

### 高星题解
1. **作者：coyangjr (赞：579)  5星**
    - **关键亮点**：思路清晰，详细阐述BFS框架及KMP算法在字符串匹配中的应用，代码注释详尽，并总结了`string`函数用法。
    - **个人心得**：考试时遗忘`find`和`replace`函数，故而采用KMP算法，体现灵活运用知识的能力。
    - **核心代码**：
```cpp
//寻找匹配的串，顺便修改并添加到queue中
il void KMP(string a, int x, int step) {
    string z = a;
    a = " " + a;
    re int i, j = 0;
    for (i = 1; i < a.length(); i++) {
        while (j > 0 && diff[x][j + 1]!= a[i])
            j = nxt[x][j];
        if (diff[x][j + 1] == a[i])
            j++;
        if (j == diff[x].length() - 1) {
            re int t = i - diff[x].length() + 1;
            string tmp = z.substr(0, t) + change[x] + z.substr(t + diff[x].length() - 1);
            q.push(Node(tmp, step + 1));
            j = nxt[x][j];
        }
    }
    return;
}
```
    - **核心思想**：利用KMP算法在字符串`a`中查找`diff[x]`子串，找到后进行替换并将新字符串加入队列。
2. **作者：ShawnZhou (赞：279)  4星**
    - **关键亮点**：代码简洁明了，清晰阐述BFS思路，利用`map`判重，详细解释拼接函数的实现。
    - **核心代码**：
```cpp
string trans(const string &str, int i, int j) {
    string ans = "";
    if (i + orginal[j].length() > str.length())
        return ans;
    for (int k = 0; k < orginal[j].length(); k++)
        if (str[i + k]!= orginal[j][k])
            return ans;
    ans = str.substr(0, i);
    ans += translated[j];
    ans += str.substr(i + orginal[j].length());
    return ans;
}
void bfs() {
    queue <node> q;
    node s;
    s.str = a;
    s.step = 0;
    q.push(s);
    while (!q.empty()) {
        node u = q.front();
        q.pop();
        string temp;
        if (ma.count(u.str) == 1)
            continue;
        if (u.str == b) {
            ans = u.step;
            break;
        }
        ma[u.str] = 1;
        for (int i = 0; i < u.str.length(); i++)
            for (int j = 0; j < n; j++) {
                temp = trans(u.str, i, j);
                if (temp!= "") {
                    node v;
                    v.str = temp;
                    v.step = u.step + 1;
                    q.push(v);
                }
            }
    }
    if (ans > 10 || ans == 0)
        cout << "NO ANSWER!" << endl;
    else
        cout << ans << endl;
}
```
    - **核心思想**：`trans`函数负责判断并执行字符串替换，`bfs`函数通过队列进行广度优先搜索，对每个字符串按规则变换，判重后将新字符串入队。
3. **作者：BrandonSoong (赞：127)  4星**
    - **关键亮点**：提出双向BFS算法，通过图文并茂的方式详细解释双向BFS原理及优势，代码实现清晰。
    - **核心代码**：
```cpp
inline int bfs() {
    int step = 0;
    A_.push(s);
    A[s] = 0;
    B_.push(t);
    B[t] = 0;
    string s, s2;
    while (++step <= 5) {
        while (A[A_.front()] == step - 1) {
            s = A_.front();
            A_.pop();
            for (int i = 1; i <= n; i++) {
                unsigned int pos = 0;
                while (pos < s.length()) {
                    if (s.find(a[i], pos) == s.npos) break;
                    s2 = s;
                    s2.replace(s2.find(a[i], pos), a[i].length(), b[i]);
                    if (A.find(s2)!= A.end()) {
                        pos++;
                        continue;
                    }
                    if (B.find(s2)!= B.end()) return step * 2 - 1;
                    A_.push(s2);
                    A[s2] = step;
                    pos++;
                }
            }
        }
        while (B[B_.front()] == step - 1) {
            s = B_.front();
            B_.pop();
            for (int i = 1; i <= n; i++) {
                unsigned int pos = 0;
                while (pos < s.length()) {
                    if (s.find(b[i], pos) == s.npos) break;
                    s2 = s;
                    s2.replace(s2.find(b[i], pos), b[i].length(), a[i]);
                    if (B.find(s2)!= B.end()) {
                        pos++;
                        continue;
                    }
                    if (A.find(s2)!= A.end()) return step * 2;
                    B_.push(s2);
                    B[s2] = step;
                    pos++;
                }
            }
        }
    }
    return -1;
}
```
    - **核心思想**：从初始字符串和目标字符串同时进行BFS，通过`map`判重，当两边搜索到相同字符串时返回总步数。

### 最优关键思路或技巧
1. **搜索算法选择**：BFS适合求最优解，双向BFS在已知初始和目标状态时能大幅优化搜索效率，IDS则在限制搜索深度的场景下有效。
2. **数据结构运用**：使用`map`、`set`进行判重，`vector`、`multimap`存储变换规则，`queue`实现BFS的状态队列。
3. **字符串处理技巧**：熟练运用`string`的`find`、`replace`、`substr`等函数进行字符串查找、替换和截取。

### 同类型题或类似算法套路拓展
1. **同类型题**：给定初始和目标状态，通过一系列操作求最少步数的问题，如八数码问题、倒水问题等。
2. **类似算法套路**：对于此类搜索问题，关键在于确定搜索状态、搜索空间、搜索策略（BFS、DFS、IDS等）以及判重方法，以优化搜索效率。

### 洛谷相似知识点题目推荐
1. **P1135 奇怪的电梯**：通过按钮操作在楼层间移动，求到达目标楼层的最少操作次数，考查BFS。
2. **P1379 八数码难题**：经典八数码问题，利用BFS搜索最优解，涉及状态表示和判重。
3. **P2347 [USACO03FALL]Beauty Contest G**：可通过双向BFS优化暴力搜索，考查搜索算法优化。 

---
处理用时：88.90秒
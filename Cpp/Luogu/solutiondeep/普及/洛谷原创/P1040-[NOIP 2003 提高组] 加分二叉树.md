# 题目信息

# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# AI分析结果

### 综合分析与结论
这些题解均围绕“加分二叉树”问题，采用动态规划方法求解。思路上，通过设计状态表示子树最大加分，枚举根节点来构建状态转移方程；算法要点在于状态设计、状态转移方程推导及前序遍历输出；难点主要是处理边界情况（如空子树）以及理解无后效性和最优子结构性质。

### 所选的题解
- **作者：冒泡ioa (5星)**
    - **关键亮点**：思路清晰，从动态规划的基本概念出发，逐步推导状态设计和转移方程，对动态规划的特点、无后效性等解释详细，代码简洁明了且有注释。
    - **重点代码 - 核心实现思想**：通过三层循环，先枚举区间长度，再枚举区间起点，最后在区间内枚举根节点，根据加分规则更新最大加分和根节点记录。
```c++
for (int len = 1; len < n; ++len) {
    for (int i = 1; i + len <= n; ++i) {
        int j = i + len;
        f[i][j] = f[i + 1][j] + f[i][i];//默认它的左子树为空，如果有的话，这肯定不是最优解
        root[i][j] = i;//默认从起点选根
        for (int k = i + 1; k < j; ++k) {
            if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                root[i][j] = k;
            }
        }
    }
}
```
- **作者：winmt (4星)**
    - **关键亮点**：将问题拆解为三个任务，采用树形DP结合记忆化搜索，对每个任务的算法描述清晰，给出了C++和Pascal两种代码实现，有助于理解。
    - **重点代码 - 核心实现思想**：递归计算子树最高分值，在递归函数中穷举每个可能的子根，计算并比较以该子根为根的子树分值，更新状态转移方程和根节点记录。
```c++
long long search(int L, int r)    // 递归计算f[L][r]
{
    int  k;
    long long  now, ans;    // 当前分值
    if (L > r) return 1;
    if (f[L][r]== -1)     // 若尚未计算出顶点L..顶点r对应子树的最高分值
        for(k=L; k<=r; k++) {     // 穷举每一个可能的子根k
            now = search(L, k-1) * search(k+1, r) + f[k][k];  
// 计算以k为根的子树的分值
            if(now > f[L][r])  {
//若该分值为目前最高，则记入状态转移方程，并记下子根}
                f[L][r] = now; 
                root[L][r] = k;
            }
        }
    return  f[L][r];   {返回顶点L..顶点r对应子树的最高分值}
}
```
- **作者：噬月 (4星)**
    - **关键亮点**：先猜想用DP求解，通过分析最优子结构和无后效性验证猜想，对状态转移方程的设计和边界情况讨论详细，还探讨了等号对结果的影响。
    - **重点代码 - 核心实现思想**：与冒泡ioa类似，通过三层循环枚举区间长度、起点和根节点，根据状态转移方程更新最大加分和根节点记录，同时处理好边界情况。
```c++
for (int range = 1; range <= n; ++ range ) {
    for (int i = 1; i + range <= n; ++ i ) {
        int j = i  + range;
        for (int k = i ; k <= j; ++ k ) {
            if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                root[i][j] = k;
            }
        }
    }
}
```

### 最优关键思路或技巧
1. **状态设计**：利用二维数组$f[i][j]$表示节点$i$到节点$j$成树的最大加分，能有效满足无后效性，方便状态转移。
2. **枚举根节点**：在区间内枚举根节点$k$，根据左子树加分$f[i][k - 1]$、右子树加分$f[k + 1][j]$和根节点分数$f[k][k]$计算子树最大加分，从而构建状态转移方程。
3. **记录根节点**：使用二维数组$root[i][j]$记录节点$i$到节点$j$成树的最大加分所选的根节点，便于输出前序遍历。

### 可拓展之处
同类型题常涉及区间DP、树形DP，类似套路是根据问题的最优子结构性质设计状态和状态转移方程，注意处理边界情况。例如石子合并问题，通过合并相邻石子堆求最小或最大得分，同样是利用区间DP，枚举合并点来更新状态。

### 相似知识点洛谷题目
1. **P1880 [NOI1995] 石子合并**：经典区间DP题目，通过合并石子堆求最小或最大得分。
2. **P2858 [USACO06DEC] Milk Patterns G**：利用后缀数组和RMQ解决重复子串问题，与本题在状态设计和区间处理思路上有相似之处。
3. **P3146 [USACO16OPEN] 248 G**：通过合并数字得到目标值，同样需要合理设计状态和状态转移方程，属于区间DP类型。 

---
处理用时：48.78秒
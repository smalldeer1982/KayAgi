# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果

这道题要求在给定的树形传播途径中，通过每次切断一条传播途径，使得最终被感染的人数最少。由于题目数据范围小，大部分题解采用搜索算法。以下是对各题解的综合分析：
1. **思路**：多数题解先对树进行分层处理，然后通过搜索枚举每层切断的节点，从而找出使感染人数最少的方案。部分题解尝试过贪心算法，但都构造出反例证明贪心不可行，还有一些题解采用随机化策略来逼近最优解。
2. **算法要点**：首先要存储树的结构，常见方式有邻接表、结构体数组等。接着通过深度优先搜索（DFS）或广度优先搜索（BFS）来预处理树的相关信息，如节点深度、子树大小等。最后再次利用搜索，枚举每层切断的节点，并标记该节点子树，统计感染人数，找到最小值。
3. **解决难点**：如何高效地搜索并剪枝是主要难点。由于搜索空间较大，需要合理设计搜索顺序和剪枝条件。例如，判断节点的祖先是否已被切断，若已切断则该节点无需再考虑；或者在搜索过程中，如果当前感染人数已超过当前最优解，则可提前回溯。

以下是对各题解的简要评分：
1. **作者RikoHere**：思路清晰，详细阐述了从分析题目到确定搜索算法的过程，分模块处理代码，便于理解和调试。代码注释详细，但整体实现相对复杂。评分：4星。
2. **作者基础不牢**：思路明确，对树的存储、标记深度、切断问题及搜索过程都有详细讲解，并针对搜索代码的缺陷进行了优化。代码简洁，可读性较好。评分：4星。
3. **作者欧鹰**：详细介绍了建图和搜索的过程，代码简单易懂，但在思路阐述上相对前两位作者不够深入。评分：3星。
4. **作者流逝丶**：思路清晰，代码简洁明了，通过DFS预处理信息，再进行搜索求解答案，但在文字描述上不够丰富。评分：3星。
5. **作者majt**：对贪心策略的分析和搜索框架的构建清晰，代码实现较为简洁，有一定优化剪枝，但整体题解内容稍显简略。评分：3星。
6. **作者Ciyang**：不仅给出了搜索的正解，还详细分析了错误的DP思路及原因，对理解题目和算法有很大帮助。评分：4星。
7. **作者Makasukaka**：采用随机化策略，思路新颖，但这种方法依赖数据较弱，不具有通用性。评分：3星。
8. **作者山水一程_**：从贪心和DP思路入手，分析其不可行性后给出搜索思路，代码实现有一定创新性，但整体表述稍显凌乱。评分：3星。
9. **作者onglu**：直接采用暴力模拟的方法，思路简单直接，但代码中变量命名不够清晰，注释较少。评分：2星。
10. **作者薄荷凉了夏**：思路清晰，详细描述了按层搜索的过程及记录内容和更新答案条件，但代码实现中部分变量命名较随意。评分：3星。
11. **作者早右昕**：思路明确，通过DFS预处理和搜索实现题目要求，但代码注释较少，可读性一般。评分：3星。
12. **作者windows250**：采用邻接表存边，深搜加剪枝的方法，代码结构清晰，注释详细，但在剪枝策略上没有特别突出之处。评分：3星。
13. **作者blackzebra**：思路清晰，利用vector存图，通过搜索找到被保护人数最多的情况，但代码中部分函数逻辑稍显复杂。评分：3星。
14. **作者1124828077ccj**：通过搜索枚举每层删除的节点，代码实现较为简单，但没有进行优化剪枝，且代码注释较少。评分：2星。
15. **作者顾z**：贪心算法虽然错误，但对贪心思路及被卡原因分析清晰，代码实现完整。评分：3星。
16. **作者zi小眼聚光**：采用A*搜索和剪枝，思路较为独特，但对A*估价函数的解释不够详细，代码实现相对复杂。评分：3星。
17. **作者万弘**：分层进行DFS搜索，代码实现较为清晰，但在思路阐述上不够详细，没有提及剪枝等优化策略。评分：3星。
18. **作者sun123zxy**：采用贪心加随机化的方法，代码实现完整，但随机化部分的解释不够清晰，且这种方法不具有通用性。评分：3星。
19. **作者翠竹叶飞**：DFS加剪枝的方法，代码实现有一定优化，但整体思路阐述不够清晰，部分变量命名较难理解。评分：2星。
20. **作者Expecto**：采用随机化方法，代码实现简单，但随机化策略的描述不够详细，且这种方法依赖数据较弱。评分：2星。
21. **作者lian_sama**：采用链表存图和随机化方法，代码实现完整，但随机化部分的解释和分析较少，不具有通用性。评分：2星。
22. **作者henry_y**：贪心加随机化的方法，对贪心被卡原因和随机化策略分析详细，但代码中部分变量命名不够直观。评分：3星。
23. **作者清尘**：直接暴力DFS枚举方案，代码实现清晰，但没有特别的优化策略，在大数据情况下效率较低。评分：3星。
24. **作者灼眼的夏娜**：详细分析了贪心错误的原因，给出搜索思路和实现过程，代码结构清晰，有一定优化，但整体题解稍显冗长。评分：3星。
25. **作者吴国铨**：采用搜索方法，详细描述了构建有向树和递归计算被感染最少人数的过程，但代码采用Pascal语言，且变量命名不够清晰。评分：2星。
26. **作者封禁用户**：通过搜索一层一层处理，代码实现完整，但整体思路阐述较少，变量命名较随意。评分：2星。
27. **作者ljcljc**：算法分析清晰，代码实现简洁明了，通过DFS预处理和搜索，并维护已删除节点总数进行优化，但整体题解内容相对简略。评分：3星。

综合以上评分，选取以下3条评分较高的题解：
1. **作者RikoHere**
    - **星级**：4星
    - **关键亮点**：详细阐述从分析题目到确定搜索算法的过程，分模块处理代码，便于理解和调试。
    - **个人心得**：强调分模块处理代码方便调试，以及理解题意并找到合适的DFS传入参数的重要性。
    - **核心代码**：
```cpp
int clean(int i){
    bol[i] = true;
    int num = 1;
    int p = f[i].size();
    for (int j = 0; j < p; ++j){
        num += clean(f[i][j]);
    }
    return num;
}
void reclean(int i){
    bol[i] = false;
    int p = f[i].size();
    for (int j = 0; j < p; ++j){
        reclean(f[i][j]);
    }
}
void dfs(int cen, int tot){
    maxx = max(maxx, tot);
    for (int i = 0; i < cnt[cen]; ++i){
        if (!bol[b[cen][i]]){
            int num = clean(b[cen][i]);
            tot += num;
            dfs(cen+1, tot);
            reclean(b[cen][i]);
            tot -= num;
        }
    }
}
void resolve(int i, int cen){
    b[cen][cnt[cen]] = i;
    ++cnt[cen];
    int p = k[i].size();
    for (int j = 0; j < p; ++j){
        if (dis[k[i][j]] == dis[i]+1){
            resolve(k[i][j], cen+1);
            f[i].push_back(k[i][j]);
        }
    }
}
void solve(){
    priority_queue <node> que;
    for (int i = 0; i <= n; ++i) dis[i] = 999;
    dis[1] = 0;
    que.push(node(1, 0));
    while (!que.empty()){
        node temp = que.top();
        que.pop();
        int x = temp.x;
        int p = k[x].size();
        for (int j = 0; j < p; ++j){
            if (dis[k[x][j]] > dis[x]+1){
                dis[k[x][j]] = dis[x]+1;
                que.push(node(k[x][j], dis[k[x][j]]));
            }
        }
    }
    resolve(1, 0);
}
```
核心实现思想：`clean`函数标记子树节点并统计数量，`reclean`函数回溯取消标记。`dfs`函数为搜索核心，枚举每层未标记节点，标记其所在子树并递归搜索下一层。`resolve`函数用于预处理，将合法边加入`f`数组。`solve`函数通过最短路算法预处理节点到根节点的距离。
2. **作者基础不牢**
    - **星级**：4星
    - **关键亮点**：对树的存储、标记深度、切断问题及搜索过程都有详细讲解，并针对搜索代码的缺陷进行了优化。
    - **核心代码**：
```cpp
void dfs(int now,int cnt) 
{
    if(now==maxx)
    {
        ans=min(ans,cnt);
        return ;
    }
    int f=0;
    for(int i=1;i<=deep[now][0];i++)
    {
        if(vis[deep[now][i]]>0)
        {
            f++;
            continue;
        }
        vis[deep[now][i]]=1;
        work(deep[now][i],1);
        dfs(now+1,cnt-count[deep[now][i]]);
        vis[deep[now][i]]=0;
        work(deep[now][i],0);
    }
    if(f==deep[now][0]) ans=min(ans,cnt);
}
```
核心实现思想：`dfs`函数为搜索核心，`now`表示当前层数，`cnt`表示当前感染人数。遍历当前层节点，若节点未被标记，则标记该节点及其子树，递归搜索下一层，回溯时取消标记。若当前层所有节点都已被标记，则更新答案。
3. **作者Ciyang**
    - **星级**：4星
    - **关键亮点**：不仅给出搜索正解，还详细分析错误的DP思路及原因，帮助理解题目和算法。
    - **核心代码**：
```cpp
void dfs2(int deep, int cost) {
    if(cost >= ans) return;
    int notsolve= 0;
    for(int i= 0; i < (int)node[deep].size(); i++)
        if(!cutd[node[deep][i]]) ++notsolve;
    if(!notsolve) {
        ans= cost;
        return;
    }
    for(int i= 0; i < (int)node[deep].size(); i++) {
        if(cutd[node[deep][i]]) continue;
        cut(node[deep][i], 1);
        dfs2(deep + 1, cost + notsolve - 1);
        cut(node[deep][i], 0);
    }
    return;
}
```
核心实现思想：`dfs2`函数为搜索核心，`deep`表示当前深度，`cost`表示当前感染人数。首先进行最优性剪枝，若当前感染人数已大于等于当前最优解则返回。统计当前层未被切断的节点数`notsolve`，若为0则更新答案。遍历当前层未被切断的节点，切断该节点及其子树，递归搜索下一层，回溯时恢复节点状态。

**最优关键思路或技巧**：
1. **树的分层处理**：通过DFS或BFS对树进行分层，便于按层搜索切断节点，缩小搜索空间。
2. **预处理信息**：提前计算节点深度、子树大小等信息，在搜索过程中可快速获取，提高效率。
3. **剪枝策略**：如判断节点祖先是否已切断、当前感染人数是否超过最优解等，及时回溯，减少不必要的搜索。

**可拓展之处**：
同类型题目通常围绕树形结构展开，例如给定树形结构，要求通过某种操作（如选择节点、切断边等）使得某个目标函数最优。类似算法套路主要是对树进行合理的预处理，利用搜索算法（如DFS、BFS）枚举所有可能情况，并结合剪枝策略优化搜索过程。

**相似知识点的洛谷题目**：
1. **P1330 封锁阳光大学**：同样是在树形结构上进行操作，通过选择节点使得满足一定条件下的节点数量最少，考察树的遍历和搜索。
2. **P2015 二叉苹果树**：在二叉树上进行边的删除操作，使得保留的边的权值和最大，涉及树的遍历和动态规划或搜索。
3. **P1352 没有上司的舞会**：在树形结构中，每个节点有权值，通过选择节点使得权值和最大，且父子节点不能同时选择，考察树的遍历和动态规划。 

---
处理用时：97.51秒
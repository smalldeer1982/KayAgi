# 题目信息

# [NOIP 2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# AI分析结果

这道题主要求解由操作数序列\(1,2,\ldots,n\)经过特定栈操作可能得到的输出序列的总数，众多题解主要围绕递归/记忆化搜索、递推/DP以及卡特兰数等方法展开。
1. **递归/记忆化搜索**：定义二维数组记录状态，递归实现时依据栈和队列状态转移，记忆化避免重复计算。此方法直观但复杂度较高。
2. **递推/DP**：顺着递归思路，通过找规律得出递推式，利用循环实现，相比递归更高效。
3. **卡特兰数**：这是本题核心解法，有多个递推式。不同递推式在时空复杂度、取模运算等方面各有优劣，其中\(h(n)=C(2n,n)-C(2n,n - 1)\)在处理取模时更具优势。

综合来看，卡特兰数的方法最为高效和通用，特别是公式\(h(n)=C(2n,n)-C(2n,n - 1)\)，在处理大数据及取模运算时表现出色。

以下是评分较高的题解：
- **作者：xiejinhao (赞：6012)  5星**
    - **关键亮点**：思路清晰全面，详细阐述了递归/记忆化搜索、递推/DP以及卡特兰数的四种公式等多种解法，并对各解法进行对比分析，代码完整且注释详细。
    - **个人心得**：提到对卡特兰数不同公式在取模运算时的差异进行分析，指出公式\(h(n)=C(2n,n)-C(2n,n - 1)\)在取模时的优势。
    - **重点代码 - 卡特兰数公式4**：
```cpp
#include<cstdio>
#define MAX_N 20
#define ll long long
using namespace std;
int n;
ll c[MAX_N*2][MAX_N];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=2*n;i++){
        c[i][0]=c[i][i]=1;
        for(int j=1;j<i;j++){
            c[i][j]=c[i-1][j]+c[i-1][j-1];
        }
    }
    printf("%lld",c[2*n][n]-c[2*n][n-1]);
    return 0;
}
```
    - **核心思想**：先通过杨辉三角的方式计算组合数\(C(2n,n)\)和\(C(2n,n - 1)\)，然后利用卡特兰数公式\(h(n)=C(2n,n)-C(2n,n - 1)\)得出结果。
- **作者：inexistent (赞：1144)  4星**
    - **关键亮点**：简洁明了地解释了卡特兰数与本题的关系，通过分析出栈序列的组成得出卡特兰数的递推公式，并给出简洁的递推实现代码。
    - **重点代码**：
```cpp
#include <cstdio>
int n, f[30];
int main()
{
    scanf("%d", &n);
    f[0] = 1, f[1] = 1;
    for(int i=2; i<=n; i++)              
        for(int j=0; j<i; j++) 
            f[i] += f[j] * f[i-j-1];     
    printf("%d", f[n]);
    return 0;
}
```
    - **核心思想**：以卡特兰数递推公式\(f[n]=f[0]*f[n - 1]+f[1]*f[n - 2]+\cdots +f[n - 1]*f[0]\)为基础，通过两层循环实现递推计算。
- **作者：Nepenthe (赞：119)  4星**
    - **关键亮点**：对卡特兰数的四个公式进行详细分析，对比各公式在处理大数据及取模运算时的优劣，突出公式\(h(n)=C(2n,n)-C(2n,n - 1)\)的优势，并给出相应代码。
    - **重点代码**：
```cpp
#include<cstdio>
#define siz 20
using namespace std;
int n;
int c[siz*2][siz];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=2*n;i++) c[i][1]=c[i][i]=1;
    for(int i=3;i<=2*n;i++)
        for(int j=2;j<i;j++)
            c[i][j]=c[i-1][j]+c[i-1][j-1];
    printf("%d",c[2*n][n]-c[2*n][n-1]);
    return 0;
}
```
    - **核心思想**：同样先利用杨辉三角计算组合数，再根据公式\(h(n)=C(2n,n)-C(2n,n - 1)\)得到最终答案。

**最优关键思路或技巧**：理解卡特兰数与本题的联系，选用合适的卡特兰数公式。在本题中，公式\(h(n)=C(2n,n)-C(2n,n - 1)\)在处理可能出现的大数据取模情况时更为合适。同时，对于递归方法结合记忆化搜索，以及递推方法的合理运用，都是解决此类问题的重要技巧。

**可拓展之处**：此类问题属于组合计数范畴，常见于栈的操作、二叉树的形态计数、凸多边形的三角划分等场景。类似算法套路是找到问题中的递归结构或组合关系，转化为已知的数列（如卡特兰数）进行求解。

**推荐题目**：
- [P1722 矩阵II](https://www.luogu.com.cn/problem/P1722)：同样涉及到组合计数问题，通过分析路径的限制条件，利用递推或卡特兰数相关思想求解。
- [P2532 [AHOI2012]树屋阶梯](https://www.luogu.com.cn/problem/P2532)：本质也是卡特兰数的应用，通过对阶梯划分的分析，建立与卡特兰数的联系。
- [P4071 [SDOI2016]排列计数](https://www.luogu.com.cn/problem/P4071)：在排列组合的基础上，结合卡特兰数的思路，解决具有特定限制条件的排列计数问题。 

---
处理用时：45.18秒
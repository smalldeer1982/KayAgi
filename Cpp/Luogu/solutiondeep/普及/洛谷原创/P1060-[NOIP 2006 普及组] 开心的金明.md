# 题目信息

# [NOIP 2006 普及组] 开心的金明

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $N$ 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $N$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1-5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过 $N$ 元（可以等于 $N$ 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第$j$件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,…,j_k$，则所求的总和为：

$$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2} …+v_{j_k} \times w_{j_k}$$

请你帮助金明设计一个满足要求的购物单。

## 说明/提示

NOIP 2006 普及组 第二题


## 样例 #1

### 输入

```
1000 5
800 2
400 5
300 5
400 3
200 2
```

### 输出

```
3900```

# AI分析结果

这道题是典型的01背包问题，目标是在预算限制内使物品价格与重要度乘积的总和最大。多数题解采用01背包的动态规划思路，少数使用深度优先搜索（DFS）或二进制枚举。

1. **思路与算法要点**
    - **动态规划（01背包）**：多数题解将该问题建模为01背包问题，把总钱数当作背包容量，物品价格与重要度乘积当作价值。状态转移方程为 \( f[i][j]=\max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]) \)，其中 \( f[i][j] \) 表示前 \( i \) 个物品在背包容量为 \( j \) 时的最大价值， \( w[i] \) 为物品重量（本题为价格）， \( v[i] \) 为物品价值（本题为价格与重要度乘积）。部分题解使用滚动数组优化空间，将二维数组降为一维。
    - **深度优先搜索（DFS）**：由于物品数量 \( m \) 较小（ \( m < 25 \) ），可以通过DFS枚举所有物品选取情况，对每种情况计算总价值并更新最大值。
    - **二进制枚举**：对每种物品的选取状态用二进制表示（0表示不选，1表示选），通过二进制枚举每种可能的组合，并计算其总价值和总花费，找到满足预算的最大价值。
2. **解决难点**
    - **动态规划**：难点在于理解状态转移方程，以及如何根据问题特点确定状态和转移关系。滚动数组优化时，要注意内层循环的方向（从大到小）以避免同一物品多次放入背包。
    - **深度优先搜索**：难点在于递归函数的设计，包括边界条件判断、状态更新与回溯，以确保所有情况都被正确枚举。
    - **二进制枚举**：难点在于如何高效地实现二进制枚举，并在枚举过程中快速计算总价值和总花费，避免不必要的重复计算。
3. **题解评分**
    - **oier1459078309**：4星。思路清晰，不仅给出本题代码，还列举了多种背包问题模板，便于学习对比。代码采用一维数组优化的01背包，简洁明了。
    - **phigy**：4星。给出01背包和DFS两种解法，对01背包的关键位置（倒序搜索）有明确说明，DFS代码也有详细注释。
    - **Lynkcat**：3星。介绍二进制枚举方法，思路新颖，但代码使用Pascal语言，对不熟悉该语言的读者不太友好，且未对代码进行详细解释。
4. **最优关键思路或技巧**
    - **动态规划**：使用滚动数组优化空间复杂度，将二维数组降为一维，减少内存使用，同时提高运行效率。在实现时，内层循环从大到小遍历背包容量，确保每个物品只被考虑一次。
    - **深度优先搜索**：通过递归实现对所有物品选取情况的枚举，利用回溯机制恢复状态，保证每种情况都能被正确处理。
5. **拓展**
同类型题通常围绕背包问题的各种变体，如完全背包（每种物品有无限个）、多重背包（每种物品有有限个）、分组背包（物品分组，每组只能选一个）等。解题套路一般是根据问题特点确定状态和转移方程，可能需要使用滚动数组等优化技巧。
6. **推荐题目**
    - [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)
    - [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)
    - [P2690 [USACO04NOV]Apple Catching G](https://www.luogu.com.cn/problem/P2690)
7. **个人心得**：无

### 所选题解
#### oier1459078309（4星）
- **关键亮点**：全面列举多种背包模板，对本题采用一维数组优化的01背包解法，代码简洁清晰。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int w[30],v[30],f[50000];//w数组为重要度，v数组为money，f是用来dp的数组
int n,m;//n是总物品个数，m是总钱数
int main()
{
    cin>>m>>n;//输入
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
        w[i]*=v[i];//w数组在这里意义变为总收获（重要度*money）
    }
       //01背包（参照第二类模板“一维数组优化”）
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=v[i];j--)//注意从m开始
        {
            if(j>=v[i])
            {
                f[j]=max(f[j],f[j-v[i]]+w[i]);//dp
            }
        }
    }
    cout<<f[m]<<endl;//背包大小为m时最大值
    return 0;
} 
```
核心实现思想：先输入物品价格和重要度并计算其乘积，然后利用一维数组优化的01背包动态规划，从后往前遍历背包容量，不断更新在不同容量下的最大价值。

#### phigy（4星）
- **关键亮点**：提供01背包和DFS两种解法，对01背包关键步骤注释详细，DFS代码也有清晰解释。
```cpp
// 01背包代码
#include <iostream>
using namespace std;
int f[30][100000];
int w[10000];
int v[10000];
int main()
{
    int n,m;
    int i,j,k;
    cin>>m>>n;
    //提前相乘
    for(i=1;i<=n;i++)
    {
        cin>>w[i]>>v[i];
        v[i]*=w[i];
    }
    for(int i=1;i<=n;i++)
    {
        //01背包最关键的位置,为防止反复加同一物品，需要倒着搜，这也是01背包与完全背包的不同之处
        for(int c=0;c<=m;c++)
        {
            f[i][c]=f[i-1][c];
            if(c>=w[i])
            f[i][c]=max(f[i][c],f[i-1][c-w[i]]+v[i]);
        }
    }
    cout<<f[n][m];
    return 0;
}
```
核心实现思想：先输入物品价格和重要度并计算乘积，通过二维数组实现01背包动态规划，外层循环遍历物品，内层循环遍历背包容量，根据状态转移方程更新最大价值。
```cpp
// DFS代码
#include <iostream>
using namespace std;
int a[30],w[30],v[30],ans,s,N,m;
void dfs(int i,int s)
{
    if (i>=m+1)///选择数量到达
    {
        int t=0;
        for (int i=1;i<=m;i++)///计算体积和 
        {
            t=t+v[i]*a[i];
        }
        if (t<=N) ///体积是否小于背包体积
        {   
            if (s>=ans) ///价值和是否大于当前最大价值和
            {
                ans=s;///答案更新 
            }
        }
    }
    else
    {
        a[i]=0;
        dfs(i+1,s); ///不选
        a[i]=1;
        dfs(i+1,s+v[i]*w[i]);///选
    }
}
int main()
{
    cin>>N>>m;
    for (int i=1; i<=m; i++)
    {
        cin>>v[i]>>w[i];
    }
    dfs(1,0);
    cout<<ans;
    return 0;
}
```
核心实现思想：通过递归函数dfs枚举每个物品选与不选的情况，当选择完所有物品后，计算所选物品的总价值和总体积，若总体积不超过背包容量且总价值大于当前最大值，则更新最大值。 

---
处理用时：47.97秒
# 题目信息

# [BJWC2008] 雷涛的小猫

## 题目背景

原最大整数参见 P1012

## 题目描述

雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫（当然，这样的行为是违反学生宿舍管理条例的）。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。

可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆…

在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有 $N$ 棵。并且这 $N$ 棵柿子树每棵的高度都是 $H$。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。

小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳 $1$ 单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降 `Delta` 单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。

雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。

图为 $N=3, H=10, Delta=2$ 的一个例子。小猫按照图示路线进行跳跃，可以吃到最多的 $8$ 个柿子。

![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \leq N, H ≤ 2000$，$0 \leq N_i ≤ 5000$，$1 ≤ Delta ≤ N,1 ≤ T_{i,j} ≤ H$。

输入文件大小不大于 40MB。注意输入输出效率。

来源 Excalibur, 2008。

## 样例 #1

### 输入

```
3 10 2
3 1 4 10
6 3 5 9 7 8 9
5 4 5 3 6 9```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解主要围绕动态规划（DP）算法来解决小猫吃柿子的最大数量问题。多数题解先给出朴素的$O(n^3)$或$O(n^2h)$的DP解法，其核心思路是定义状态$dp[i][j]$表示在第$i$棵树高度为$j$时的最大吃柿子数，通过考虑从同一棵树上一层落下或从其他树跳过来两种情况进行状态转移。由于朴素算法时间复杂度较高，难以通过所有测试数据，于是各题解通过维护每个高度的最大收益值来优化，将时间复杂度降至$O(n^2)$或$O(nh)$。

### 所选的题解
- **作者：issue_is_fw（5星）**
    - **关键亮点**：思路清晰，先给出朴素的$O(n^3)$做法，再详细阐述优化到$O(n^2)$的过程，代码简洁且注释丰富，易于理解。
    - **个人心得**：强调排版对题解审核的重要性。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,h,de;
int a[5009][2009],dp[5009][2009],pre[5009];
int main()
{
    cin>>n>>h>>de;
    for(int i=1;i<=n;i++)
    {
        int t,zz;
        scanf("%d",&t);
        while(t--){
            scanf("%d",&zz);
            a[i][zz]++;
        }
    }
    int maxn=0;
    for(int j=h;j>=0;j--)
    {
        for(int i=1;i<=n;i++)
        {
            dp[i][j]=a[i][j]+dp[i][j+1];//先继承上一次 
            dp[i][j]=max(dp[i][j],pre[j+de]+a[i][j]);//转移 
            pre[j]=max(pre[j],dp[i][j]);//尝试更新当前的pre 
            maxn=max(maxn,dp[i][j]);
        }
    }
    cout<<maxn;
}
```
    - **核心实现思想**：先读入数据初始化柿子分布数组$a$。通过从高到低枚举高度$j$，对于每一个高度，枚举树$i$，从同一棵树上一层转移$dp[i][j]=a[i][j]+dp[i][j + 1]$，并从之前维护的对应高度最大收益$pre[j + de]$转移更新$dp[i][j]$，同时更新$pre[j]$。最后得到全局最大吃柿子数$maxn$。
- **作者：良辰何需美景（4星）**
    - **关键亮点**：详细展示了从朴素$O(n^2h)$转移方程推导到$O(nh)$优化的过程，通过分析代码中重复计算的部分，提出用数组保存每个高度的最优解进行优化，代码有详细注释且能清晰看到优化前后的变化。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,h,d,num,k;
int f[2018][2018],a[2018][2018],ret[2018];
int main(){
    std::ios::sync_with_stdio(false);
    cin>>n>>h>>d;
    for(int i=1;i<=n;i++){
        cin>>num;
        for(int j=1;j<=num;j++){
            cin>>k;
            a[i][k]++;
        }
    }
    for(int j=1;j<=h;j++)
        for(int i=1;i<=n;i++){
            if(j>d)f[i][j]=max(f[i][j-1],ret[j-d])+a[i][j];
            else f[i][j]=f[i][j-1]+a[i][j];
            ret[j]=max(ret[j],f[i][j]);
        }
    cout<<ret[h];
    return 0;
}
```
    - **核心实现思想**：读入数据初始化柿子分布数组$a$。按高度从低到高枚举$j$，对于每一个高度枚举树$i$，当高度$j > d$时，从同一棵树上一层或从之前维护的$ret[j - d]$转移更新$f[i][j]$，否则只能从同一棵树上一层转移。同时更新$ret[j]$。最后输出$ret[h]$即最大吃柿子数。
- **作者：邓布利多6（4星）**
    - **关键亮点**：分别给出$50$分的$O(n^3)$方法和$100$分的$O(n^2)$方法，思路明确，对状态转移方程的解释清晰，代码简洁明了。
    - **核心代码（$O(n^2)$解法）**：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=2001;
int n,h,d,ans[N],f[N][N],x,y,a[N][N];
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
int main()
{
    n=read();h=read();d=read();
    for(int i=1;i<=n;i++)
    {
        x=read();
        for(int j=1;j<=x;j++)
        {
            y=read();
            a[i][y]++;
        }
    }
    for(int j=1;j<=h;j++)
        for(int i=1;i<=n;i++)
        {
            f[i][j]=f[i][j-1];
            if(j>=d)f[i][j]=max(f[i][j],ans[j-d]);
            f[i][j]+=a[i][j];
            ans[j]=max(ans[j],f[i][j]);
        }
    cout<<ans[h];
    return 0;
}
```
    - **核心实现思想**：读入数据初始化柿子分布数组$a$。按高度从低到高枚举$j$，对于每一个高度枚举树$i$，先从同一棵树上一层转移$f[i][j] = f[i][j - 1]$，当高度$j \geq d$时，从之前维护的$ans[j - d]$转移更新$f[i][j]$，加上当前位置柿子数$a[i][j]$。同时更新$ans[j]$。最后输出$ans[h]$即最大吃柿子数。

### 最优关键思路或技巧
优化的关键思路是利用一个数组（如$pre$、$ret$、$ans$等）来保存每个高度能获得的最大收益值，避免每次在状态转移时重复枚举其他树来寻找最大值，从而将时间复杂度从$O(n^3)$或$O(n^2h)$降低到$O(n^2)$或$O(nh)$。

### 可拓展之处
此类题属于动态规划在多状态决策问题上的应用，类似套路可用于解决具有多个决策路径且状态间存在依赖关系的问题，如背包问题变种、路径规划问题等。

### 相似知识点洛谷题目
- **P1048 [NOIP2005 普及组] 采药**：经典的背包问题，通过动态规划求解在时间限制下采药的最大价值，与本题类似在于都是在不同选择下求最优值。
- **P1280尼克的任务**：根据任务开始时间和持续时间，利用动态规划求解尼克的最大空闲时间，同样涉及状态转移和决策选择。
- **P1833 樱花**：通过动态规划解决多重背包问题，需要考虑物品数量限制和价值最大化，与本题在动态规划应用上有相似之处。 

---
处理用时：49.41秒
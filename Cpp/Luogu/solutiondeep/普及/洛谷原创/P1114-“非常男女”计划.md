# 题目信息

# “非常男女”计划

## 题目描述

近来，初一年的 `XXX` 小朋友致力于研究班上同学的配对问题（别想太多，仅是舞伴），通过各种推理和实验，他掌握了大量的实战经验。例如，据他观察，身高相近的人似乎比较合得来。

万圣节来临之际，`XXX` 准备在学校策划一次大型的 “非常男女” 配对活动。对于这次活动的参与者，`XXX` 有自己独特的选择方式。他希望能选择男女人数相等且身高都很接近的一些人。这种选择方式实现起来很简单。他让学校的所有人按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。为了使活动更热闹，`XXX` 当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。


## 样例 #1

### 输入

```
9
0 1 0 0 0 1 1 0 0
```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效找出男女人数相等的最长连续子序列展开。多数题解采用前缀和思想，将男生设为1，女生设为 - 1，使得男女人数相等时前缀和为0 。难点在于如何优化查找相同前缀和位置的过程，避免O(n²)的暴力枚举。部分题解使用哈希表（如map）、桶数组记录前缀和首次及末次出现位置，或利用二分、剪枝等方法降低时间复杂度。

### 所选的题解
- **作者：AKB48 (赞：163)  5星**
    - **关键亮点**：思路清晰简洁，引入相对差概念，指出差值相等的两个位置之间的人数满足男女相等，为后续优化提供核心思路。
    - **心得**：无
    - **核心代码思路**：通过数组记录差值相等位置的左右端点，从而找到满足条件的最长子序列。
    - **核心代码**：无
- **作者：小小二逼兽 (赞：136)  5星**
    - **关键亮点**：代码简洁高效，直接计算男女生数量差值并记录其最左和最右位置，通过一次遍历完成任务，时间复杂度为O(n)。
    - **心得**：无
    - **核心代码思路**：遍历输入，计算差值并更新其左右位置记录数组，最后遍历差值数组求最大距离。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int l[200010],r[200010],sum1,sum0,ans,n;
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++){
        int x; cin>>x;
        sum1+=(x==1), sum0+=(x==0);
        int t=sum0-sum1+n;
        if (!l[t]&&t!=n) l[t]=i; else r[t]=i;
    }
    for (int i=0;i<=2*n;i++) ans=max(ans,r[i]-l[i]);
    cout<<ans<<endl;
    return 0;
}
```
- **作者：Bring (赞：3)  4星**
    - **关键亮点**：对前缀和思想阐述清晰，优化掉了$s_{1..n}$数组，用$p_i$表示每一个$s_j = i$的最小$j$，代码简洁且优化程度较高。
    - **心得**：无
    - **核心代码思路**：遍历过程中更新前缀和，若该前缀和已记录则更新答案，否则记录其位置。
    - **核心代码**：
```cpp
//This program is written by Brian Peng.
#pragma GCC optimize("Ofast","inline","-ffast-math")
#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<bits/stdc++.h>
using namespace std;
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
inline int read(){
	register int x;register char c(getchar());register bool k;
	while(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);
	if(c^'-')k=1,x=c&15;else k=x=0;
	while(isdigit(Gc(c)))x=(x<<1)+(x<<3)+(c&15);
	return k?x:-x;
}
void wr(register int a){
	if(a<0)Pc('-'),a=-a;
	if(a<=9)Pc(a|'0');
	else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i<(b);++i)
#define Frn1(i,a,b) for(register int i(a);i<=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i>=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
#define N (200010)
#define P(a) (p[a+n])
int n,p[N],s,ans;
signed main(){
	Rd(n),Mst(p,-1),P(0)=0;
	Frn1(i,1,n)s+=read()?1:-1,~P(s)?ans=max(ans,i-P(s)):P(s)=i;
	wr(ans),exit(0);
}
```

### 最优关键思路或技巧
使用哈希表（如map）或桶数组记录前缀和出现的位置，通过一次遍历数组，在遇到相同前缀和时，直接计算当前位置与首次出现位置的距离，从而在O(n)时间复杂度内解决问题，避免了暴力O(n²)枚举。

### 可拓展思路
此类题目属于序列统计与优化查找问题，常见套路是将实际问题转化为数学模型（如本题转化为前缀和问题），再利用数据结构优化查找过程。同类型题可涉及子数组和、子序列匹配等，例如在给定序列中找和为特定值的最长/最短子数组等。

### 相似知识点洛谷题目
- [P1990 覆盖墙壁](https://www.luogu.com.cn/problem/P1990)：涉及递推和动态规划，与本题一样需要分析子问题间关系。
- [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：利用递推解决路径计数问题，与本题在分析问题构建解法上有相似思考方式。
- [P1140 相似基因](https://www.luogu.com.cn/problem/P1140)：字符串动态规划问题，同样是在序列上进行分析和优化。

### 个人心得摘录与总结
- **作者：KellyFrog**：调试过程花费近40分钟，主要问题在于处理前缀和数组可能出现负数下标，通过加上一个较大数解决。总结出处理数组下标可能为负的情况要谨慎，初始化和边界处理很重要。 

---
处理用时：52.60秒
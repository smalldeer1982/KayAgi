# 题目信息

# 小木棍

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。

现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。

给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。


## 说明/提示

对于全部测试点，$1 \leq n \leq 65$，$1 \leq a_i \leq 50$。

## 样例 #1

### 输入

```
9
5 2 1 5 2 1 5 2 1
```

### 输出

```
6```

# AI分析结果

这道题是搜索剪枝类型题目，核心是找出原始木棍的最小可能长度。各题解思路相近，都采用深度优先搜索（DFS）结合剪枝优化来避免超时。

### 思路与要点
1. **范围确定**：原始木棍长度范围在最长小木棍长度与所有小木棍长度总和之间，且总和需能被原始木棍长度整除。很多题解提到可枚举到总和的一半，因为大于一半时只能所有木棍拼成一根。
2. **排序优化**：将小木棍按长度从大到小排序，先使用长木棍可使短木棍在后续拼接中更灵活，减少回溯次数。
3. **剪枝策略**：
    - **相同长度剪枝**：若某长度木棍拼接失败，相同长度木棍也会失败，可跳过。
    - **剩余长度剪枝**：若当前长棍剩余未拼长度等于当前木棍长度或原始长度，继续拼失败则回溯。因为当前木棍在最优情况都无法成功，说明之前拼接有误。
    - **顺序剪枝**：拼新长棍时选最大未用木棍，拼一根长棍时从比上一根拼入木棍长度小的开始尝试。
4. **状态记录**：用数组标记木棍是否使用，回溯时恢复标记。

### 难点分析
各题解难点主要在剪枝策略的理解与实现。如剩余长度剪枝，理解其原理需要对搜索过程和最优性有深入认识。部分题解还涉及预处理数组（如记录相同长度木棍位置）来优化搜索。

### 题解评分
1. **作者Kaori**：★★★★☆
    - **关键亮点**：思路阐述详细，对每个优化点解释清晰，代码注释丰富，可读性高。例如对 “当前长棍剩余的未拼长度等于当前木棍的长度或原始长度，继续拼下去时却失败了就回溯” 的优化点，给出了详细易懂的解释。
    - **个人心得**：首次写博客分享题解，态度认真。
    - **重点代码**：
```cpp
void dfs(int k,int last,int rest){ 
    int i;
    if(!rest){ 
        if(k==m){ok=1; return;} 
        for(i=1;i<=cnt;i++) 
            if(!used[i]) break;
        used[i]=1; 
        dfs(k+1,i,len-a[i]);
        used[i]=0;
        if(ok) return; 
    }
    int l=last+1, r=cnt, mid;
    while(l<r){
        mid=(l+r)>>1;
        if(a[mid]<=rest) r=mid;
        else l=mid+1;
    }
    for(i=l;i<=cnt;i++){
        if(!used[i]){ 
            used[i]=1;
            dfs(k,i,rest-a[i]);
            used[i]=0;
            if(ok) return; 
            if(rest==a[i] || rest==len) return; 
            i=next[i]; 
            if(i==cnt) return;
        }
    }
}
```
核心思想：通过`dfs`函数递归搜索，`k`表示正在拼第几根原始长棍，`last`表示上一根使用木棍编号，`rest`表示当前长棍剩余未拼长度。若`rest`为0，检查是否完成所有长棍拼接；否则二分查找合适木棍继续拼接，过程中应用多种剪枝策略。
2. **作者NoyException**：★★★★
    - **关键亮点**：对剪枝的阐述详细，从基础剪枝到普通剪枝再到进阶剪枝，层次分明。每个剪枝点结合实际场景说明，易于理解。
    - **个人心得**：花费半天完成题目，分享时详细记录思路，态度认真。
    - **重点代码**：
```cpp
bool perm(int pre,int fromp)
{
    int i;
    if(pre%len==0)
    {
        if(sum-pre==len) return true;
        for(i=2;i<=end && vis[i];i++) ;
        vis[i]=true;
        if(perm(pre+line[i],2)) return true;
        vis[i]=false;
    }
    else for(;fromp<=end;fromp++)
    {
        if(!vis[fromp])
        {
            if(pre%len+line[fromp]<=len)
            {
                vis[fromp]=true;
                if(perm(pre+line[fromp],fromp)) return true;
                vis[fromp]=false;
                if(pre%len+line[fromp]==len) return false;
            }
            fromp=nxt[line[fromp]];
        }
    }
    return false;
}
```
核心思想：`perm`函数进行递归搜索，`pre`表示已拼接长度，`fromp`表示当前搜索起始位置。若`pre`是`len`的倍数，处理新长棍拼接；否则从`fromp`开始找合适木棍拼接，实现多种剪枝策略。
3. **作者DLYJ**：★★★★
    - **关键亮点**：代码给出两种实现方式，对剪枝点的描述清晰准确，结合代码注释便于理解。如对 “若当前搜索时已经使用了长度为x的木棍，则下次直接从长度为x从大到小枚举” 这一剪枝点在代码中有明确体现。
    - **重点代码（第一个代码实现）**：
```cpp
bool dfs(int len,int sta,int now) 
{
    if(now==res) return 1; 
    if(len==0) if(dfs(ans,1,now+1)) return 1; 
    for(int i=sta;i<=cnt;++i)
    {
        if(!vis[i]&&a[i]<=len) 
        {
            vis[i]=1;
            if(dfs(len-a[i],i+1,now)) return 1;
            vis[i]=0;
            if(len==ans||len==a[i]) break; 
            while(a[i]==a[i+1]) ++i; 
        }
    }
    return 0;
}
```
核心思想：`dfs`函数中，`len`为剩余长度，`sta`为当前枚举起始位置，`now`为已完成的组数。若已完成所有组则成功；若剩余长度为0则开始新一组拼接；否则从`sta`开始找合适木棍，实现剪枝策略。

### 最优思路技巧
1. **排序与剪枝结合**：小木棍按长度从大到小排序，为多种剪枝策略提供基础，有效减少搜索空间。
2. **可行性与最优性剪枝**：利用剩余长度剪枝和相同长度剪枝等策略，在搜索过程中及时排除不可能的情况，提高搜索效率。
3. **状态记录与回溯**：准确记录木棍使用状态，回溯时恢复状态，保证搜索完整性。

### 拓展思路
此类题目属于搜索剪枝类型，相似套路是确定搜索范围，对数据进行预处理（如排序），设计有效的剪枝策略。同类型题可考虑一些拼图、组合问题，通过合理剪枝优化搜索过程。

### 相似题目推荐
1. **P1433 吃奶酪**：需要搜索所有可能路径，结合剪枝优化找到最短路径，与本题搜索并优化的思路类似。
2. **P1118 数字三角形**：通过搜索不同路径求最大和，可运用剪枝策略优化，和本题搜索与优化结合的方法相似。
3. **P2324 骑士精神**：同样是搜索问题，需设计合适剪枝条件来减少搜索量，与本题在搜索剪枝运用上有共通之处。 

---
处理用时：66.15秒
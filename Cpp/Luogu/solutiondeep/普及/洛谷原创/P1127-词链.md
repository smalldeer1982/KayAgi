# 题目信息

# 词链

## 题目描述

如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。

另外还有一些例子：
- `dog.gopher`
- `gopher.rat`
- `rat.tiger`
- `aloha.aloha`
- `arachnid.dog`

连接成的词可以与其他单词相连，组成更长的词链，例如：

`aloha.arachnid.dog.gopher.rat.tiger`

注意到，`.` 两边的字母一定是相同的。

现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。

## 说明/提示

- 对于 $40\%$ 的数据，有 $n \leq 10$；
- 对于 $100\%$ 的数据，有 $n \leq 1000$。


## 样例 #1

### 输入

```
6
aloha
arachnid
dog
gopher
rat
tiger```

### 输出

```
aloha.arachnid.dog.gopher.rat.tiger```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效找到字典序最小且每个单词仅出现一次的词链展开。多数题解将问题转化为图论中的欧拉路（包括欧拉通路和欧拉回路）问题。
1. **思路方面**：
    - 多数题解通过将单词的首末字母作为顶点，单词作为有向边来建图，把寻找词链问题转化为在有向图中找欧拉路问题。
    - 部分题解先尝试直接搜索，遍历每个单词作为起点，但因效率低会超时，进而优化寻找起点的方式。
2. **算法要点**：
    - 建图后需判断图是否连通，常用并查集实现。
    - 统计每个顶点的入度和出度，依据有向图中欧拉通路和回路的存在条件判断是否有解。欧拉通路存在条件为有且仅有一个点出度比入度大1（起点），有且仅有一个点入度比出度大1（终点），其余点入度等于出度；欧拉回路存在条件为所有点入度等于出度。
    - 按字典序对单词排序，以保证找到的欧拉路字典序最小。
3. **解决难点**：
    - 确定合适的起点，避免盲目遍历每个单词作为起点导致的低效。
    - 准确判断图是否存在欧拉路，防止误判无解情况。

### 所选的题解
- **作者：loc_equinox (赞：86)  星级：5星**
    - **关键亮点**：思路清晰，详细阐述从简单DFS到利用欧拉路求解的转变原因。代码结构清晰，分读入建图、寻找欧拉路起始点、DFS求欧拉路三部分，每部分功能明确。对欧拉路存在条件的判断严谨，结合并查集判断图的连通性。
    - **个人心得**：提到写题解时因数据问题，过审题解多可被Hack，强调本题数据正确性对解题的影响。
    - **核心代码**：
```cpp
// 读入，建图
int n,i,letter[27],in[27],out[27],fa[27],set_count;
string s[1002];
int ch_start,ch_end,stf,edf;
vector<vector<node> >E;
bool cmp(string a,string b)
{
    return a<b;
}
int find(int x)
{
    if(fa[x]!=x)return fa[x]=find(fa[x]);
    return fa[x];
}
void unionn(int x,int y)
{
    fa[y]=x;
    return;
}
struct node
{
    int to,ord;
    string word;
};
int main()
{
    cin>>n;
    E.resize(27);
    for(i=1;i<=n;i++)cin>>s[i];
    sort(s+1,s+n+1,cmp);
    for(i=1;i<=n;i++)
    {
        ch_start=s[i][0]-'a'+1;
        ch_end=s[i][s[i].length()-1]-'a'+1;
        out[ch_start]++;
        in[ch_end]++;
        if(!letter[ch_start])
        {
            set_count++;
            letter[ch_start]=1;
            fa[ch_start]=ch_start;
        }
        if(!letter[ch_end])
        {
            set_count++;
            letter[ch_end]=1;
            fa[ch_end]=ch_end;
        }
        if(ch_start!=ch_end)
        {
            stf=find(ch_start);
            edf=find(ch_end);
            if(stf!=edf)
            {
                set_count--;
                unionn(stf,edf);
            }
        }
        node tmp;
        tmp.to=ch_end;
        tmp.ord=i;
        tmp.word=s[i];
        E[ch_start].push_back(tmp);
    }
    if(set_count!=1)
    {
        cout<<"***";
        return 0;
    }
    // 寻找欧拉路起始点
    int Eular_start,Eular_end;
    for(i=1;i<=26;i++)
    {
        if(!letter[i])continue;
        if(out[i]==in[i]+1)
        {
            if(Eular_start)
            {
                cout<<"***";
                return 0;
            }
            Eular_start=i;
        }
        else if(in[i]==out[i]+1)
        {
            if(Eular_end)
            {
                cout<<"***";
                return 0;
            }
            Eular_end=i;
        }
        else if(in[i]==out[i])continue;
        else
        {
            cout<<"***";
            return 0;
        }
    }
    if((Eular_start&&!Eular_end)||(!Eular_start&&Eular_end))
    {
        cout<<"***";
        return 0;
    }
    if(!Eular_start)Eular_start=s[1][0]-'a'+1;
    // DFS求欧拉路
    int vis[1002];
    string res[1002];
    void dfs(int st,int now,int pre_edge)
    {
        if(st==n)
        {
            for(i=1;i<=n;i++)
            {
                cout<<res[i];
                if(i<n)cout<<".";
            }
            exit(0);
        }
        for(int k=0;k<E[now].size();k++)
        {
            if(!vis[E[now][k].ord])
            {
                vis[E[now][k].ord]=1;
                res[st+1]=E[now][k].word;
                dfs(st+1,E[now][k].to,E[now][k].ord);
            }
        }
        vis[pre_edge]=0;
        return;
    }
    dfs(0,Eular_start,0);
}
```
    - **核心代码思想**：读入单词并排序，建图时记录顶点信息和边关系，用并查集判断图连通性。通过入度出度判断欧拉路类型及起始点，最后从起始点DFS寻找字典序最小的欧拉路，记录路径并输出。
- **作者：zzr8178541919 (赞：83)  星级：4星**
    - **关键亮点**：从字符串相连的性质出发，推导出判断起点的条件，思路独特。代码实现中对搜索过程的细节处理较好，如设置flag标记防止答案被替换，使用多个数组分别记录不同信息。
    - **个人心得**：提到更新题解是因为之前有明显错误，强调自身学艺不精，侧面反映思考的深入和对题解严谨性的追求。
    - **核心代码**：
```cpp
#include<cmath>
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<map>
using namespace std;
const int maxn=1e5+5;
string a[maxn];
string ans[maxn];
string now[maxn];
int sum=0;
int len[maxn];
int book[maxn];
map<char,int> s1,s2;
int n;
int flag=0;
void dfs(int last,int step)
{
	if(flag==1)
	return;
	if(step==n)
	{
		flag=1;
		for(int i=1;i<=sum;i++)
		{
			ans[i]=now[i];
		}
		return;
	}
	for(int i=1;i<=n;i++)
	{
		if(book[i]==1)
		continue;
		if(a[last][a[last].length()-1]==a[i][0])
		{
			now[++sum]=a[i];
			book[i]=1;
			dfs(i,step+1);
			sum--;
			book[i]=0;
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		len[i]=a[i].length();
		s1[a[i][0]]++;
		s2[a[i][len[i]-1]]++;
	}	
	int start=1;
	sort(a+1,a+1+n);
	char s,t;
	for(char c='a';c<='z';c++)
	{
		if(abs(s1[c]-s2[c])==1)
		{
			if(s1[c]-s2[c]==1)
			s=c;
			else
			if(s2[c]-s1[c]==1)
			t=c;
		}
	}
	int cnt=s2[t];
	for(int i=1;i<=n;i++)
	{
		if(a[i][0]==s && (a[i][len[i]-1]!=t || cnt!=1))
		{
			start=i;
			break;
		}
	}
	book[start]=1;
	now[++sum]=a[start];
	dfs(start,1);
	if(flag==0)
	{
		printf("***\n");
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		if(i!=n)
		cout<<ans[i]<<".";
		else
		cout<<ans[i];
	}
	printf("\n");
	return 0;
}
```
    - **核心代码思想**：读入单词，统计每个字母在首位和末尾出现的次数，据此确定起点。从起点开始DFS，搜索过程中记录路径，找到答案后标记并记录，防止重复更新答案，最后输出答案或无解标识。
- **作者：fls233666 (赞：10)  星级：4星**
    - **关键亮点**：详细阐述从暴力搜索到将问题转化为欧拉路径问题的过程，对欧拉路径起点判断和无解情况判断清晰。代码实现中对边的存储和搜索过程处理巧妙，通过倒序连边保证字典序最小。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
#define ll long long
#define rgt register int
using namespace std;
const int mxn = 1010;
string str[mxn],outans[mxn];
int tot,lst[30],nxt[mxn],to[mxn],bh[mxn],d[mxn],lans;
bool use[mxn];

inline void add(int x,int y,int b){
	tot++;
	to[tot]=y;
	bh[tot]=b;
	d[x]++;
	d[y]--;
	nxt[tot]=lst[x];
	lst[x]=tot;
}

void dfs(int g){
	for(rgt i=lst[g];i;i=nxt[i]){
		if(!use[bh[i]]){
			use[bh[i]]=true;
			dfs(to[i]);
			lans++;
			outans[lans]=str[bh[i]];
		}
	}
}

int main(){
	ios::sync_with_stdio(false);
	int n,st;
	cin>>n;
	for(rgt i=1;i<=n;i++)
		cin>>str[i];

	sort(str+1,str+1+n);
	st=str[1][0]-'a'+1;

	for(rgt hd,tl,i=n;i>=1;i--){
		hd=str[i][0]-'a'+1;
		tl=str[i][str[i].size()-1]-'a'+1;
		add(hd,tl,i);
	}

	for(rgt i=1;i<=26;i++)
		if(d[i]==1){
			st=i;
			break;
		}

	dfs(st);

	for(rgt i=1;i<=n;i++)
		if(!use[i]){
			cout<<"***";
			return 0; 
		}

	for(rgt i=lans;i>1;i--)
		cout<<outans[i]<<".";
	cout<<outans[1];

	return 0;
}
```
    - **核心代码思想**：读入单词排序，按单词首末字母连边并记录边对应单词编号，计算各点度确定起点。从起点DFS搜索欧拉路径，标记已使用边，最后判断是否所有边都被使用，若未全使用则无解，否则输出路径。

### 最优关键思路或技巧
将单词首尾字母作为顶点、单词作为有向边建图，转化为欧拉路问题求解。利用并查集判断图连通性，通过统计顶点入度和出度判断欧拉路类型及起点。对单词排序保证字典序最小，在DFS搜索欧拉路时注意标记已访问边防止重复。

### 拓展思路
此类题目属于字符串拼接与图论结合的问题，类似套路可用于解决字符串匹配、序列构建等问题。例如，给定一组有依赖关系的任务，每个任务可视为节点，依赖关系视为边，判断是否能按顺序完成所有任务，可转化为有向图的拓扑排序问题；又如，给定一些城市及城市间道路，判断能否不重复地经过所有道路回到起点，可转化为无向图的欧拉回路问题。

### 相似知识点洛谷题目
1. **P2731 [USACO3.3]骑马修栅栏 Riding the Fences**：经典的无向图欧拉回路问题，要求找到字典序最小的欧拉回路，与本题思路类似，需判断图的连通性和欧拉回路存在条件，通过DFS寻找路径。
2. **P1341 无序字母对**：同样是关于图的连通性和欧拉路问题，给定一些字母对，需构建无向图并判断是否存在欧拉通路或回路，进而输出路径，考察对欧拉路概念的理解和应用。
3. **P7771 [CSP-J2021] 分糖果**：虽表面为糖果分配问题，但可通过建图转化为图论问题，判断是否存在合法分配方案，涉及到图的连通性和节点度数分析，与本题在图论应用上有相似之处。 

---
处理用时：95.81秒
# 题目信息

# [HNOI2001] 求正整数

## 题目描述

对于任意输入的正整数 $n$，请求出具有 $n$ 个不同因子的最小正整数 $m$。

例如：$n=4$，则 $m=6$，因为 $6$ 有 $4$ 个不同整数因子 $1,2,3,6$；而且是最小的有 $4$ 个因子的整数。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 5 \times 10^4$。

## 样例 #1

### 输入

```
 4
```

### 输出

```
6
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何求出具有指定数量不同因子的最小正整数展开，思路和方法各有特点。多数题解采用搜索（DFS）结合数论知识的方式，利用约数个数公式：若\(m = \prod_{i = 1}^{k}p_{i}^{a_{i}}\)（\(p_i\)为质数，\(a_i\)为指数），则\(m\)的约数个数为\(\prod_{i = 1}^{k}(a_{i}+1)\) 。解决难点在于处理大数值运算以及优化搜索过程。有的题解采用贪心策略但不完全正确，部分题解通过取对数优化大数值比较，还有题解通过剪枝优化搜索。

### 所选的题解
- **作者：_rqy （5星）**
    - **关键亮点**：思路清晰，采用动态规划（DP）方法，定义状态\(f_{i, j}\)表示只包含前\(j\)个质因数且因数个数为\(i\)的最小数，通过因数个数公式转移，为避免高精DP，对数值取对数进行优化，最后通过高精乘单精得出结果。
    - **核心代码片段**：
```cpp
// 状态转移部分
for (int i = 1; i < m; ++i) {
    for (int k = 0; k < 20; ++k)
        f[i][k] = 1e9;
    for (int j = 0; j < i; ++j) if (!(d[i] % d[j])) {
        int t = d[i] / d[j];
        for (int k = 1; k < 20; ++k)
            f[i][k] = std::min(f[i][k], f[j][k - 1] + logp[k - 1] * (t - 1));
    }
}
// 还原结果部分
A[0] = len = 1;
int j = 0;
for (int i = 0; i < 20; ++i) if (f[m - 1][i] < f[m - 1][j]) j = i;
for (int i = m - 1, nxt; i; i = nxt, --j) {
    for (nxt = 0; d[i] % d[nxt] || f[i][j] < f[nxt][j - 1]
        + logp[j - 1] * (d[i] / d[nxt] - 1) - 1e-5; ++nxt);
    for (int k = 1; k < d[i] / d[nxt]; ++k)
        mul(p[j - 1]);
}
```
    - **核心实现思想**：通过双重循环枚举因数和质因数，根据状态转移方程更新\(f\)数组，最后根据\(f\)数组找到最小的结果并通过高精乘单精还原。
- **作者：throusea （4星）**
    - **关键亮点**：对DFS做法补充详细，指出最多用到16个质因数，通过约数个数公式明确DFS过程是求每个质因数指数的过程。采用对数优化大数值比较，给出可行性和最优性剪枝策略，代码实现清晰。
    - **核心代码片段**：
```cpp
void dfs(int tol,double d,int g){ //d为当前的答案（用log缩小）
    if(ansx<d||g==16) return; //剪枝1
    if(tol==1){
        if(ansx>d){
            memcpy(ans,f,sizeof(f));
            ansx=d;
        }
        return;
    }
    for(int i=0;(i+1)*(i+1)<=tol;i++)
    if(tol%(i+1)==0){  //剪枝2
        f[g]=i;
        dfs(tol/(i+1),d+f[g]*lg[a[g]],g+1);
        f[g]=tol/(i+1)-1;
        dfs(i+1,d+f[g]*lg[a[g]],g+1);
        f[g]=0;
    }
}
```
    - **核心实现思想**：在DFS函数中，通过参数tol表示剩余要分解的因数，d表示当前答案的对数，g表示当前质因数序号。通过剪枝条件避免无效搜索，找到符合条件的最小结果。
- **作者：BzhH （4星）**
    - **关键亮点**：利用唯一分解定理和约数个数公式，明确搜索范围为前16个质数幂次方。通过取对数解决大数值问题，给出可行性和最优性剪枝，并且在枚举幂次方时利用单调性优化，代码实现完整。
    - **核心代码片段**：
```cpp
void dfs(int poi, int now, int last, double temp)
{
    if (poi == 16 || temp > recv || n % now)
        return;
    if (now == n)
    {
        if (temp < recv)
        {
            recv = temp;
            memcpy(a, rec, sizeof(rec));
        }
        return;
    }
    double t = val[poi];
    int k = n / now;
    for (int i = min(k - 1, last); i >= 0; --i)
    {
        rec[poi] = i;
        dfs(poi + 1, now * (i + 1), i, temp + i * t);
    }
    rec[poi] = 0;
}
```
    - **核心实现思想**：通过参数poi表示当前枚举质数序号，now表示当前质因子个数，last表示之前枚举的幂次方，temp表示当前答案对数。在DFS过程中根据剪枝条件和单调性枚举幂次方找到最小结果。

### 最优关键思路或技巧
1. **对数优化**：由于结果数值过大，直接处理困难，通过取对数将乘法运算转化为加法运算，方便比较大小，有效解决大数值处理问题。
2. **剪枝优化**：利用可行性剪枝（如当前搜到的数不能被剩余因数整除则舍弃）和最优性剪枝（如当前结果已大于之前最优结果则舍弃），减少无效搜索，提高算法效率。
3. **状态定义与转移**：如_rqy题解中通过合理定义DP状态，利用因数个数公式进行状态转移，有效解决问题。

### 可拓展思路
此类题目属于数论与搜索结合的问题，类似套路可用于求解与约数、质因数分解相关的最值问题。例如给定一些限制条件，求满足条件的最小或最大数。同类型题可关注洛谷上数论与搜索结合的题目。

### 相似知识点洛谷题目
1. **P1221 [USACO1.5] 最多因子数问题**：同样是关于求具有特定约数个数相关的问题，可通过类似数论知识和搜索方法求解。
2. **P2303 [SDOI2012] Longge的问题**：涉及数论中求\(\sum_{i = 1}^{n}gcd(i, n)\)，需要掌握数论相关知识如欧拉函数等求解。
3. **P3383 【模板】线性筛素数**：考察素数筛法，是数论基础，在本题解中部分涉及到素数相关内容，掌握该模板有助于理解此类数论问题。

### 个人心得摘录与总结
 - **作者：天下第一剑客**：发现贪心策略虽然大部分情况正确，但不完全正确，如对于\(n = 128\)的情况，贪心算法未得到最优解。意识到贪心策略在某些复杂情况下可能失效，思考优化贪心策略但未成功。总结出贪心策略有时看似合理但不一定完全正确，在竞赛中即使发现算法有瑕疵，尝试实现也可能得到部分分数。 

---
处理用时：55.49秒
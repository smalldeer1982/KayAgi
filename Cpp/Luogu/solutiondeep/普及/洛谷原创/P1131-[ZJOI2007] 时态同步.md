# 题目信息

# [ZJOI2007] 时态同步

## 题目描述

小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。

在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。

激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？

## 说明/提示

- 对于 $40\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 5\times 10^5$。

对于所有的数据，$1\le t_e\le 10^6$。

## 样例 #1

### 输入

```
3
1
1 2 1
1 3 3
```

### 输出

```
2
```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解都基于树的结构进行分析。多数题解采用自下而上的方式，通过调整边权使叶子节点到根节点的距离相等。部分题解从贪心角度出发，认为调整越靠近根节点的树枝代价越小；部分题解使用树形DP，通过状态转移方程计算最小代价。
    - 算法要点：主要通过深度优先搜索（DFS）遍历树结构，在遍历过程中计算节点到叶子节点的最大距离、调整边权的代价等。建图时需注意是无向图，要双向加边。
    - 解决难点：如何确定最优的边权调整方式以达到最小代价。通过证明得出最终根到所有叶子节点的距离为原树中根到最远叶子节点的距离，且对于任意节点，其所有子树到该节点的距离需相等，否则无法满足时态同步。
    - 总体来看，各题解思路和方法相近，差异主要体现在代码实现细节、思路阐述清晰度及优化程度上。

• 所选的题解：
  - 作者：Mathison (赞：187)  星级：5星
    - 关键亮点：思路清晰，先点明调整越靠根节点的树枝代价越少这一关键贪心策略，并用节点深度类比距离辅助理解。代码简洁明了，DFS实现直接计算调整代价，逻辑清晰。
    - 重点代码核心实现思想：通过DFS遍历树，先更新每个节点到叶子节点的最大距离`dis[x]`，再累加调整当前节点到子节点边权的代价`ans += dis[x] - (dis[y] + z)`。
```cpp
void dfs(int x,int fa)
{
    for(int i=head[x];i;i=next[i])
    {
        int y=ver[i],z=edge[i];
        if(y==fa) continue;
        dfs(y,x);
        dis[x]=max(dis[x],dis[y]+z);
    }
    for(int i=head[x];i;i=next[i])
    {
        int y=ver[i],z=edge[i];
        if(y==fa) continue;
        ans+=dis[x]-(dis[y]+z);
    }
}
```
  - 作者：crazydave (赞：127)  星级：4星
    - 关键亮点：从反向思考，将问题转化为叶子节点同时发出信号并同时到达根节点，使思路更直观。代码注释详细，对维护过程中的细节如双向加边、避免计算父节点边权、维护顺序等都有清晰说明。
    - 重点代码核心实现思想：DFS回溯时，先维护节点到子节点的最大边权`maxn[x]`，再计算答案`ans += (maxn[x] - edge[i].dis)`，最后更新父节点到该节点的边权`edge[i].dis += maxn[x]`。
```cpp
void dfs(int x, int fa) 
{
    for(int i=head[x]; i; i=edge[i].next)
        if(edge[i].to!=fa) dfs(edge[i].to, x);
    for(int i=head[x]; i; i=edge[i].next)
        if(edge[i].to!=fa) maxn[x]=max(maxn[x], edge[i].dis);
    for(int i=head[x]; i; i=edge[i].next)
        if(edge[i].to!=fa) ans+=(maxn[x]-edge[i].dis);
    for(int i=head[fa]; i; i=edge[i].next)
        if(edge[i].to==x) edge[i].dis+=maxn[x];
}
```
  - 作者：ZORO (赞：5)  星级：4星
    - 关键亮点：对树形DP的思路阐述详细，通过举例和图形直观地解释了状态转移的原理，即确保每个节点到其子树内叶子节点距离相等，且在尽可能向上的边修改以保证代价最小。
    - 重点代码核心实现思想：先通过`dfs1`预处理每个节点到子树中叶子节点的最大距离`maxx[u]`，再在`dfs2`中通过状态转移方程`dp[u] += (maxx[u] - (maxx[ev] + e[i].w)) + dp[ev]`计算答案。
```cpp
void dfs1(int u,int fa)
{
    for(int i=head[u];i;i=e[i].nxt)
    {
        int ev=e[i].v;
        if(ev==fa) continue;
        dfs1(ev,u);
        maxx[u]=max(maxx[ev]+e[i].w,maxx[u]);
    }
}
void dfs2(int u,int fa)
{
    for(int i=head[u];i;i=e[i].nxt)
    {
        int ev=e[i].v;
        if(ev==fa) continue;
        dfs2(ev,u);
        dp[u]+=(maxx[u]-(maxx[ev]+e[i].w));
        dp[u]+=dp[ev];
    }
}
```

• 最优的关键思路或技巧：
    - 贪心策略：调整靠近根节点的边权，能使更多叶子节点受益，从而减少总的调整代价。
    - 树形DP：通过状态转移方程，自下而上地计算每个节点的子树时态同步所需的最小代价，充分利用树结构的性质。
    - 反向思考：将从根到叶子的激励电流传播问题，转化为从叶子到根的信号传播问题，使问题更易理解和处理。

• 可拓展之处：
此类题目属于树形结构上的优化问题，类似算法套路可应用于其他涉及树的权值调整、路径优化等问题。例如，给定树的节点权值，通过一定操作使树满足某种性质（如所有路径和相等、子树和相等）并求最小操作次数或代价。

• 推荐题目：
    - [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)：涉及树的节点选择与权值计算，通过树形DP求解最优解。
    - [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)：典型的树形DP题目，在树结构上进行状态转移以解决最大权独立集问题。
    - [P2014 选课](https://www.luogu.com.cn/problem/P2014)：结合树形结构与背包问题，通过树形DP实现资源分配的最优决策。

• 个人心得摘录与总结：
多数题解未提及个人心得。部分作者提到在理解题意和设计算法时，通过画图、举例等方式辅助思考，从而更清晰地理解问题本质和找到解题思路，如ZORO通过图形解释树形DP的状态转移原理。同时，部分作者强调了处理无向图时双向加边、避免重复计算等细节的重要性。 

---
处理用时：64.73秒
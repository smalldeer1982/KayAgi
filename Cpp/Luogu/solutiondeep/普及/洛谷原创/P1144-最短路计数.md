# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕无向无权图中从顶点1到其他各点的最短路计数问题，采用了BFS、SPFA、Dijkstra等算法。思路上，大多在传统算法基础上，通过维护一个数组记录到各点的最短路数量，并依据更新最短路的情况来更新计数。算法要点在于正确处理最短路更新时计数的变化，如遇到更短路径则覆盖计数，遇到等长路径则累加计数。难点在于确保计数的准确性，避免重复计数，部分题解还需考虑算法在不同边权情况下的通用性。

### 所选的题解
 - **作者：ZiDing_ByronFinlso（5星）**
    - **关键亮点**：思路清晰，同时给出了SPFA和Dijkstra堆优化两种解法，并配有相应图示辅助理解。代码规范，有详细的读入优化。
    - **个人心得**：无
    - **SPFA核心代码**：
```cpp
while(q.size())
{
    x=q.front();q.pop();
    p[x]=0;
    for(int i=head[x];i;i=nxt[i])
    {
        y=to[i];
        if(d[y]>d[x]+1)
        {
            d[y]=d[x]+1;
            ans[y]=ans[x];
            if(!p[y])
            {
                q.push(y);
                p[y]=1;
            }
        }
        else if(d[y]==d[x]+1)
        {
            ans[y]+=ans[x];
            ans[y]%=mod;
        }
    }
}
```
核心思想：在SPFA的松弛操作中，若发现更短路径，更新距离并将该点的最短路计数设为前驱点的计数；若发现等长路径，则累加前驱点的计数。
    - **Dijkstra堆优化核心代码**：
```cpp
while(q.size())
{
    x=q.top().second;
    q.pop();
    if(p[x])    continue;
    p[x]=1;
    for(int i=head[x];i;i=nxt[i])
    {
        y=to[i];
        if(d[y]>d[x]+1)
        {
            d[y]=d[x]+1;
            ans[y]=ans[x];
            q.push(make_pair(-d[y],y));
        }
        else if(d[y]==d[x]+1)
        {
            ans[y]+=ans[x];
            ans[y]%=mod;
        }
    }
}
```
核心思想：在Dijkstra堆优化算法中，每次取出堆顶元素进行松弛操作，类似SPFA，根据路径长短情况更新距离和最短路计数。
 - **作者：岸芷汀兰（4星）**
    - **关键亮点**：明确指出本题可使用广搜（BFS）解决，并详细分析了题目中自环、重边等特殊情况对解题的影响。代码结构清晰，有读入和输出优化。
    - **个人心得**：无
    - **BFS核心代码**：
```cpp
queue<Node>q; q.push(make(1, 0));
memset(d, 0x3f, sizeof(d)); d[1] = 0;
vis[1] = true;
ans[1] = 1;
while (q.size()) {
    int u = q.front().node, dis = q.front().dis; 
    q.pop();
    for (register int i = 0; i<int(linker[u].size()); i++) {
        if (!vis[cur]) {
            q.push(make(cur, dis + 1)); vis[cur] = true; d[cur] = dis + 1; 
            ans[cur] += ans[u]; /*重点*/ans[cur] %= mod;
        }
        else {
            if (dis + 1 == d[cur]) { ans[cur] += ans[u]; /*重点*/ans[cur] %= mod; }
        }
    }
}
```
核心思想：利用BFS分层遍历图，对于首次访问的点，更新距离和最短路计数；对于已访问且当前路径为最短路的点，累加最短路计数。
 - **作者：King丨帝御威（4星）**
    - **关键亮点**：详细解释了使用堆优化Dijkstra算法的原因，并对代码进行了详细注释，便于理解。
    - **个人心得**：无
    - **Dijkstra核心代码**：
```cpp
void dijkstra()
{
    memset(dis,0x3f,sizeof(dis));
    dis[1]=0;
    priority_queue<node>q;
    js[1]=1;
    q.push((node){1,0});
    node a;
    while(!q.empty())
    {
        a=q.top();
        int u=a.x,d=a.y;
        q.pop();
        if(d!=dis[u]) continue;
        for(int i=head[u];i;i=edge[i].nxt)
        {
            int v=edge[i].v;
            if(d+edge[i].w==dis[v])
                js[v]=(js[u]+js[v])%mod;
            if((dis[v]>dis[u]+edge[i].w))
            {
                dis[v]=dis[u]+edge[i].w;
                js[v]=js[u];
                q.push((node){v,dis[v]});
            }
        }
    }
}
```
核心思想：通过堆优化的Dijkstra算法，每次从优先队列中取出距离源点最近的点进行松弛操作，根据路径长度更新距离和最短路计数。

### 最优关键思路或技巧
1. **算法选择与结合**：根据题目无向无权的特点，选择BFS、SPFA或Dijkstra算法，并在算法执行过程中结合最短路计数的逻辑。
2. **计数更新策略**：在更新最短路时，通过判断新路径与原路径的长度关系，准确更新最短路的计数。遇到更短路径，直接覆盖计数；遇到等长路径，累加计数。

### 可拓展之处
此类问题可拓展到带权图的最短路计数，需要注意边权对最短路更新和计数的影响，在更新距离和计数时要考虑边权大小。类似算法套路还包括在图的遍历过程中维护其他信息，如最长路计数、满足特定条件的路径计数等。

### 相似知识点洛谷题目
1. **P1608 路径统计**：同样是关于最短路计数问题，不过本题数据规模更大，更考验算法的优化。
2. **P3371 【模板】单源最短路径（弱化版）**：基础的单源最短路问题，可作为理解和练习Dijkstra、SPFA等算法的基础题目。
3. **P4779 【模板】单源最短路径（标准版）**：与上一题类似，但对算法的实现和优化要求更高，有助于提升对最短路算法的掌握程度。

### 个人心得摘录与总结
无

---
处理用时：49.28秒
# 题目信息

# 解一元二次方程的烦恼

## 题目背景

JosephZheng 在写数学作业的预习。他往往使用 Casio 来帮忙解一元二次方程。但是 Casio 有一个问题，就是当 $\Delta=b^2-4ac$ 为一个大素数或大合数时，其开平方的结果会以小数显示，而不是老师要求的二次根式形式。JosephZheng 很是苦恼，一遇到这种情况就要手动解方程。一天他再也忍不住了，于是打开了电脑，编了一个 prime 程序……于是悲剧的 OIer 们就要跟着疯狂的 JosephZheng 一起编这个程序，呵呵……


## 题目描述

废话少说，给你一个大数 $N$（不一定在 int64 范围内），让你进行素性判断，然后分解质因数。当然，初中数学题不可能有大于 int64 的数让你判断素性，因此超过范围的数可以忽略不计。为了让程序更加贴心，JosephZheng 多了一些要求，会在输入输出中给出具体情况。


## 说明/提示

编这道题的 JosephZheng 有些无聊，但是很考验基本功哦！仔细审题！

水题一道。。。


## 样例 #1

### 输入

```
4
eed
```

### 输出

```
Enter the number=
Prime? No!
4=2^2

Enter the number=
```

## 样例 #2

### 输入

```
2
end
```

### 输出

```
Enter the number=
Prime? Yes!

Enter the number=
```

## 样例 #3

### 输入

```
-1
adfs
```

### 输出

```
Enter the number=
Prime? No!

Enter the number=
```

## 样例 #4

### 输入

```
1234###24#@13#@￥！1
hehe
```

### 输出

```
Enter the number=
Prime? No!
The number is too large!

Enter the number=
```

## 样例 #5

### 输入

```
1.5
1
1234324123512343123
@~@~@~@
```

### 输出

```
Enter the number=
Prime? No!
15=3^1*5^1

Enter the number=
Prime? No!

Enter the number=
Prime? No!
The number is too large!

Enter the number=
```

## 样例 #6

### 输入

```
12
halt@@
```

### 输出

```
Enter the number=
Prime? No!
12=2^2*3^1

Enter the number=
```

# AI分析结果

• 综合分析与结论：这些题解整体思路较为一致，均围绕从输入字符串提取数字、判断素数、判断数字大小及分解质因数这几个步骤展开。算法要点在于素数判断常用sqrt(n)的遍历方式，分解质因数也是基于sqrt(n)的范围查找质因数。难点主要集中在输出格式的严格要求以及处理输入字符串中的干扰字符。部分题解通过线性筛素数进行优化，但由于题目数据范围有限，该优化效果不显著。

所选的题解：
 - 作者：_neddy (5星)
   - 关键亮点：思路清晰，详细分析时间复杂度，代码结构合理，对每个功能封装成独立函数，且对边界条件处理细致。
   - 个人心得：提到做题过程中多次提交才通过，每次能发现新Bug，认识到自身能力有限。
  ```cpp
  inline int str_to_int64(string ss)
  {
      int num = 0, flag = 0;
      for (register int i = 0; i < ss.size() && num <= 40000000; ++i) 
          if (ss[i] >= '0' && ss[i] <= '9') num = num * 10 + (ss[i] - '0'), flag = 1;
      if (flag == 0) exit(0); 
      return num;
  }
  inline void act(int n){
      int num = 0, sum = 0, flag = 0, Isprime = isprime(n); 
      n <= 40000000 && Isprime? cout << "Prime? Yes!\n\n" : cout << "Prime? No!\n"; 
      if (Isprime || n < 2 || n > 40000000) {
          if (n > 40000000) cout << "The number is too large!\n\n"; 
          if (n < 2) cout << '\n'; 
          return ;
      }
      cout << n << '='; 
      for (register int i = 2; i * i <= n; ++i){
          while(n % i == 0) n /= i, ++sum;
          if (sum)
              if (flag) cout << '*' << i << '^' << sum, sum = 0; 
              else cout << i << '^' << sum, flag = true, sum = 0; 
      }
      Isprime? cout << '*' << n << "^1\n\n" : cout << "\n\n"; 
  }
  ```
 - 作者：0nullptr (4星)
   - 关键亮点：详细阐述每一步模拟过程，代码简洁明了，对输入输出格式处理得当。
  ```cpp
  bool judge(int n){
      int m = (int) sqrt(n + 0.5);
      for (int i = 2; i <= m; i++)
          if (n % i == 0) return false;
      return true;
  }
  signed main(){
      int n;
      while (true){
          puts("Enter the number=");
          n = 0;
          string a;
          getline(cin, a);
          for (int i = 0; i < a.size(); i++){
              if(a[i] >= '0' && a[i] <= '9'){
                  n *= 10;
                  n += a[i] - '0';
              }
          }
          if (n == 0) return 0;
          cout<<"Prime? ";
          if (n < 2) puts("No!");
          else if (!judge(n) ){
              puts("No!");
              if (n > 40000000){
                  puts("The number is too large!\n");
                  continue;
              }
              cout<<n<<'=';
              bool first = true;
              for (int i = 2; i <= n; i++){
                  int k = 0;
                  while (!(n % i) ){
                      k++;
                      n /= i;
                  }
                  if (k){
                      if (first){
                          cout<<i<<'^'<<k;
                          first = false;
                      }
                      else cout<<'*'<<i<<'^'<<k;
                  }
              }
              cout<<endl;
          }
          else puts("Yes!");
          cout<<endl;
      }
  }
  ```
 - 作者：Lylighte (4星)
   - 关键亮点：将复杂的模拟过程拆分为多个清晰的小模块，如输入输出与分离数字、判断素数、分解质因数，每个模块功能明确，代码逻辑清晰。
  ```cpp
  int worknum(string st){
      int num=0;
      bool getans=false;
      int len=st.size();
      for(int i=0; i<len; i++){
          if(st[i]>='0'&&st[i]<='9'){
              num = num*10+st[i]-'0';
              getans = true;
              if(num>40000000){
                  return TOOBIG; 
              }
          }
      }
      if(!getans){
          return EMPTY; 
      }
      return num;
  }
  void workprime(){ 
      memset(isprime, true, sizeof(isprime));
      isprime[0]=isprime[1]=false;
      for(int i=2; i<=40000000; i++){
          if(isprime[i]){
              primelist[++pcnt] = i;
          }
          for(int j=1; j<=pcnt&&primelist[j]*i<=40000000; j++){
              isprime[primelist[j]*i] = false;
              if(i%primelist[j]==0){
                  break;
              }
          }
      }
      return;
  }
  void divi(int n){
      bool appeared=false;
      cout <<  n << '=';
      for(int i=1; i<=pcnt; i++){
          int p=0;
          while(n%primelist[i]==0&&n>0){ 
              p++; 
              n /= primelist[i];
          }
          if(p>0){ 
              if(appeared)
                  cout << '*'; 
              cout << primelist[i] << '^' << p; 
              appeared = true;
          }
      }
      cout << '\n';
  }
  ```

最优的关键思路或技巧：在处理输入字符串提取数字时，采用遍历字符串，遇到数字字符则通过乘10累加的方式转化为数字，并同时判断是否超出范围。判断素数采用sqrt(n)的遍历方式，分解质因数同样基于sqrt(n)范围查找质因数，并注意处理输出格式，对第一个质因数特殊处理避免多输出乘号。

可拓展之处：同类型题可涉及更复杂的数论问题，如大整数的素性判断与质因数分解，可能需要使用更高效的算法如Miller - Rabin素性测试、Pollard's rho算法等。类似算法套路是先明确问题的各个子问题，如本题中的提取数字、素数判断、质因数分解，再逐个击破，同时注重边界条件和输出格式。

推荐题目：
 - P3383 【模板】线性筛素数，考察线性筛素数算法。
 - P1835 素数密度，涉及素数判断及区间内素数个数统计。
 - P2689 质数口袋，需要综合运用素数判断和背包问题思路。

个人心得摘录与总结：多位作者提到本题输出格式是大坑，稍不注意就会WA，如_neddy多次提交才发现并修正输出格式问题；Lylighte在DEBUG过程中，遇到线性筛素数写爆、输入输出函数使用不当、未特判n<2等问题，经过多次修改才AC，这些都表明在解决此类模拟题时，要注重细节，对边界条件和输出格式严格把控。 

---
处理用时：53.94秒
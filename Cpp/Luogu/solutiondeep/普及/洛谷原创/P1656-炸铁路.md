# 题目信息

# 炸铁路

## 题目描述

A 国派出将军 uim，对 B 国进行战略性措施，以解救涂炭的生灵。

B 国有 $n$ 个城市，这些城市以铁路相连。任意两个城市都可以通过铁路直接或者间接到达。

uim 发现有些铁路被毁坏之后，某两个城市无法互相通过铁路到达。这样的铁路就被称为 key road。

uim 为了尽快使该国的物流系统瘫痪，希望炸毁铁路，以达到存在某两个城市无法互相通过铁路到达的效果。

然而，只有一发炮弹（A 国国会不给钱了）。所以，他能轰炸哪一条铁路呢？


## 样例 #1

### 输入

```
6 6
1 2
2 3
2 4
3 5
4 5
5 6```

### 输出

```
1 2
5 6```

# AI分析结果

### 综合分析与结论
本题要求找出图中的割边（桥），即删除该边后图不再连通的边。题解主要分为暴力枚举和Tarjan算法两类思路：
 - **暴力枚举**：枚举每一条边，删除该边后通过DFS、BFS、SPFA或并查集判断图是否仍然连通。若不连通，则该边为割边。此方法思路简单，但时间复杂度较高，通常为O(m²)，其中m为边的数量。
 - **Tarjan算法**：通过深度优先搜索，利用dfn（时间戳）和low（能追溯到的最早时间戳）数组来判断边是否为割边。若low[child] > dfn[father]，则边<child, father>为割边。该算法时间复杂度为O(n + m)，效率较高。

综合质量来看，部分题解思路清晰、代码注释详细，部分题解虽能解决问题，但在代码可读性和优化程度上有所欠缺。

### 所选4星及以上题解
 - **作者：kkksc03 (赞：598)  4星**
    - **关键亮点**：思路清晰简洁，指出本题即求图中的桥，提出由于数据范围小，可采用枚举边的方法，去掉边后用FloodFill（DFS或BFS）遍历判断图是否连通，容易理解。
    - **重点代码核心思想**：枚举每条边，删除该边后从某一点开始进行DFS或BFS遍历，若无法遍历到所有点，则该边为割边。
 - **作者：abruce (赞：197)  4星**
    - **关键亮点**：对Tarjan算法讲解详细，结合代码和图示，清晰阐述了dfn、low数组的含义及Tarjan算法判断割边的原理，便于初学者理解。
    - **重点代码核心思想**：
```cpp
void tarjan(int x) {
    int c = 0, y;
    dfn[x] = low[x] = ++id;
    for(register int i = 1; i <= n; i++) {
        if(!maps[x][i]) continue;
        y = i;
        if(dfn[y] && y!= f[x]) low[x] = min(low[x], dfn[y]);
        if(!dfn[y]) {
            f[y] = x;
            tarjan(y);
            low[x] = min(low[x], low[y]);
            if(low[y] > dfn[x]) addEdge(x, y);
        }
    }
}
```
通过深度优先搜索，在遍历过程中更新dfn和low数组，根据low[y] > dfn[x]判断边(x, y)是否为割边。
 - **作者：hsfzLZH1 (赞：65)  4星**
    - **关键亮点**：对Tarjan算法求割边的原理阐述清晰，代码实现简洁明了，并指出代码在处理重边时的问题及解决方法，考虑全面。
    - **重点代码核心思想**：
```cpp
void dfs(int cur, int fa) {
    int child;
    dfn[cur] = ++index_;
    low[cur] = dfn[cur];
    for(int i = 0; i < G[cur].size(); i++) {
        child = G[cur][i];
        if(dfn[child] && child!= fa) low[cur] = min(low[cur], dfn[child]);
        if(!dfn[child]) {
            dfs(child, cur);
            if(dfn[cur] < low[child]) add_edge(cur, child);
            low[cur] = min(low[cur], low[child]);
        }
    }
}
```
同样是利用Tarjan算法，在DFS过程中更新dfn和low数组，依据dfn[cur] < low[child]判断割边并记录。

### 最优关键思路或技巧
Tarjan算法是解决此类求割边问题的高效方法，通过深度优先搜索过程中维护时间戳dfn和能追溯到的最早时间戳low，巧妙判断割边。其核心在于理解dfn和low数组的含义及更新方式，以及如何利用它们之间的关系判断割边。

### 可拓展之处
 - **同类型题或类似算法套路**：此类题目属于图论中连通性相关问题，类似的还有求割点、强连通分量等。求割点时，判断条件通常为low[child] >= dfn[father]（与求割边略有不同）；求强连通分量可使用Tarjan算法在有向图上进行缩点操作。
 - **相似知识点洛谷题目**：
    - **P3387 【模板】缩点**：要求对有向图进行缩点操作，将强连通分量缩成一个点，涉及Tarjan算法在有向图中的应用。
    - **P3388 【模板】割点（割顶）**：明确要求找出无向图中的割点，可直接运用Tarjan算法求割点的思路解决。
    - **P2860 [USACO06JAN]冗余路径Redundant Paths**：与本题类似，也是关于无向图连通性问题，通过添加边使图中不存在割边，可进一步加深对割边概念及相关算法的理解。

### 个人心得摘录与总结
 - **作者：HRLYB**：在使用Tarjan算法处理无向图双连通分量时，提到双向边标记的方法（通过^1操作），以避免陷入死循环，强调了细节在算法实现中的重要性。
 - **作者：浅色调**：分享了自己做题时的思考过程，开始误解题意，后来发现正解是Tarjan算法，但因数据小选择类似Kruskal的算法，同时提到调试并查集花费较多时间，提醒注意算法实现细节和对题意的准确理解。 

---
处理用时：41.26秒
# 题目信息

# 部落卫队

## 题目描述

原始部落 byteland 中的居民们为了争夺有限的资源，经常发生冲突。几乎每个居民都有他的仇敌。部落酋长为了组织一支保卫部落的队伍，希望从部落的居民中选出最多的居民入伍，并保证队伍中任何 $2$ 个人都不是仇敌。

给定 byteland 部落中居民间的仇敌关系，编程计算组成部落卫队的最佳方案。若有多种方案可行，输出字典序最大的方案。

## 说明/提示

对于 $60\%$ 数据：$n \le 20$，$m \le 100$。

对于所有数据：$n \le 100,m \le 3000$。数据从所有合法数据从随机均匀取样。

## 样例 #1

### 输入

```
7  10
1  2
1  4
2  4
2  3
2  5
2  6
3  5
3  6
4  5
5  6```

### 输出

```
3
1 0 1 0 0 0 1
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕深度优先搜索（DFS）算法解决部落卫队人员选择问题，即从居民中选出最多且无仇敌关系的人员。多数题解思路相似，通过DFS遍历每个居民的选与不选情况，并做剪枝优化避免不必要搜索。少数题解尝试随机化算法或用集合优化仇敌关系存储。
### 所选的题解
- **作者：jojoxie (赞：42)  星级：4星**
    - **关键亮点**：思路清晰，代码简洁，采用最普通的深搜实现，虽未详细剪枝但仍AC。
    - **重点代码**：
```cpp
void dfs(int k) {
    if(k > n) {
        if(s <= tot) {
            return;
        }
        tot = s;
        for(int j = 1; j <= n; j++) {
            a[j] = x[j];
        }
        return;
    }

    int check = 1;

    for(int t = 1; t < k; t++) {
        if(ch[t][k] && x[t]) {
            check = 0;
            break;
        }
    }

    if(check) {
        x[k] = 1;
        s++;
        dfs(k + 1);
        s--;
        x[k] = 0;
    }

    dfs(k + 1);

    return;
}
```
    - **核心思想**：`dfs`函数递归处理每个居民`k`，先判断`k`是否与已选居民有仇，若否，则尝试选与不选两种情况，更新最优结果。
- **作者：litble (赞：30)  星级：4星**
    - **关键亮点**：在DFS基础上增加最优性剪枝，即若剩余可选人数加上当前已选人数小于当前最优解则剪枝。还探讨了位运算优化思路（虽因数据范围未成功应用）。
    - **重点代码**：
```cpp
void dfs(int x,int num){
    if(x==n+1){
        if(num>ans){
            ans=num;
            for(int i=1;i<=n;i++)c[i]=b[i];
        }
        return;
    }
    if(num+n-x+1<ans)return;
    int bj=0;
    for(int i=1;i<=x-1;i++)
        if(b[i]&&lu[x][i]){bj=1;break;}
    if(!bj){b[x]=1;dfs(x+1,num+1);b[x]=0;}
    dfs(x+1,num);
}
```
    - **核心思想**：`dfs`函数中，每次递归先判断是否到达居民末尾更新最优解，再进行剪枝判断，接着判断当前居民能否加入队伍，分别处理选与不选的情况。
- **作者：百里狂生 (赞：9)  星级：4星**
    - **关键亮点**：详细阐述图的储存（邻接矩阵）和搜索过程，对DFS的约束条件和限界条件进行深入分析，代码结构清晰。
    - **重点代码**：
```cpp
bool place(int t)  {
    bool ok=true;
    for(int j=1;j<t;j++)  {
        if(x[j] && a[t][j]==1)  {
            ok=false;
            break;
        } 
    } 
    return ok;
} 

void dfs(int deep) {
    if(deep>n) {
        for(int i=1;i<=n;i++)
            bestx[i]=x[i];
        bestn=cn;
        return;
    }
    if(place(deep))  {
        x[deep]=1;
        cn++;
        dfs(deep+1);
        cn--;  
    } 
    if(cn+n-deep>bestn)  {
        x[deep]=0;
        dfs(deep+1);
    } 
}
```
    - **核心思想**：`place`函数判断当前节点能否加入团中，`dfs`函数在递归时，先判断是否到达叶子节点更新最优解，然后根据约束条件和限界条件分别处理当前节点选与不选的情况。
### 最优的关键思路或技巧
- **剪枝优化**：通过判断剩余可选人数与当前已选人数之和是否小于当前最优解，提前终止不可能产生更优解的搜索分支，有效减少搜索空间，如`if(num + n - x + 1 < ans) return;`。
- **邻接矩阵存储图**：利用二维数组直观地表示居民间的仇敌关系，方便在搜索过程中快速判断两人是否为仇敌，如`a[u][v] = a[v][u] = 1;`标记`u`和`v`为仇敌。
### 可拓展之处
此类问题属于图的最大独立集问题，类似套路是在图结构上进行状态搜索，并通过剪枝等技巧优化。同类型题可考虑有权图的最大独立集，或在满足特定条件下的独立集问题。
### 推荐题目
- [P1127 词链](https://www.luogu.com.cn/problem/P1127)：通过构建图结构，利用深度优先搜索解决单词连接成链的问题，考察图的遍历和搜索策略。
- [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)：涉及图的染色和搜索，判断能否对图进行合理染色以满足特定条件，与本题在图的处理和搜索逻辑上有相似之处。
- [P1312 玛雅游戏](https://www.luogu.com.cn/problem/P1312)：通过深度优先搜索尝试不同的消除方案，以达到目标状态，锻炼搜索过程中的状态处理和剪枝优化能力。
### 个人心得摘录与总结
 - **litble**：提到想用位运算优化但因数据范围存不下。心得为在优化算法时需充分考虑数据范围对优化手段的限制。
 - **逆时针的记忆**：分享了从入门搜索到逐步优化的过程，包括剪枝优化以及向大佬请教后的优化思路。心得为算法优化可从简单版本入手，逐步分析问题，借鉴他人思路来改进。 

---
处理用时：42.42秒
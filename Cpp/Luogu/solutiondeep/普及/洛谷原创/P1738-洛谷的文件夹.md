# 题目信息

# 洛谷的文件夹

## 题目描述

kkksc03 是个非凡的空想家！在短时间内他设想了大量网页，然后总是交给可怜的 lzn 去实现。

洛谷的网页端，有很多文件夹，文件夹还套着文件夹。

例如：$\verb!/luogu/application/controller!$ 表示根目录下有一个名称为 $\verb!luogu!$ 的文件夹，这个文件夹下有一个名称 $\verb!application!$ 的文件夹，其中还有名为 $\verb!controller!$ 的文件夹。

每个路径的第 $1$ 个字符总是 $\verb!/!$，且没有两个连续的 $\verb!/!$，最后的字符不是 $\verb!/!$。所有名称仅包含数字和小写字母。

目前根目录是空的。kkksc03 想好了很多应该有的文件夹路径名。问题是，需要是使这些文件夹都存在，需要新建几个文件夹呢？


## 说明/提示

### 数据范围及约定


- 对于 $20\%$ 数据，有 $N \le 20$；
- 对于 $50\%$ 数据，有 $N \le 200$；
- 另有 $30\%$ 数据，有对于所有路径最多存在两个 $\verb!/!$（包含第 $1$ 个字符）；
- 对于所有数据，$N \le 1000$。

## 样例 #1

### 输入

```
2
/luogu/application/controller
/luogu/application/view
```

### 输出

```
3
4
```

## 样例 #2

### 输入

```
3
/chicken
/chicken/egg
/chicken```

### 输出

```
1
2
2```

## 样例 #3

### 输入

```
4
/a
/a/b
/a/c
/b/b```

### 输出

```
1
2
3
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何统计创建给定文件夹路径所需新建文件夹数量这一核心问题展开，思路可归为以下几类：
1. **集合去重法**：利用`std::set`容器自动去重特性，将每个路径中的文件夹及路径存入集合，最后输出集合大小并适当调整（如减去根路径“/”）。此方法思路简洁，代码实现相对简单。
2. **模拟Trie树法**：把文件夹路径结构类比Trie树，通过映射（如`map`）将字符串类型的文件夹名作为数组下标构建Trie树，统计树中节点数量得到新建文件夹数。该方法能清晰体现文件夹的层级关系，但实现相对复杂。
3. **链表法**：以链表结构模拟文件夹关系，类似二叉树孩子兄弟表示法，从根节点查找和新建文件夹，每新建一个文件夹计数器加1。此方法在处理文件夹关系上较为直观，但代码实现有一定难度。

各题解质量参差不齐，部分题解思路清晰、代码简洁且有注释辅助理解，部分题解代码复杂或思路阐述不够清晰。综合考虑思路清晰度、代码可读性和优化程度，以下是对各题解的评分：
1. **Anguei**：5星。思路清晰，简洁明了地阐述利用`std::set`解决问题的思路及具体实现步骤，代码简洁且注释详细。
2. **FutureThx**：4星。以样例解释思路，易于理解，同样使用`std::set`解决问题，但代码注释略少，整体思路和实现较清晰。
3. **Haishu**：4星。提出链表解法，代码简洁高效，运行时间短，但对链表结构及操作的解释相对较少，理解成本稍高。
4. **rickyxrc**：3星。思路阐述较详细，但代码实现中使用`map`判断文件夹是否出现，相比`set`去重稍显复杂，且代码注释较少。
5. **doby**：3星。代码模拟过程较繁琐，通过数组存储文件夹名并进行比较去重，思路和实现都不够简洁清晰。
6. **HanPi**：4星。通过自定义`folder`类实现，代码结构清晰，对类的成员函数和操作解释较详细，能较好体现面向对象编程思想。
7. **windows250**：4星。利用类似字典树结构存储文件夹，结合`map`映射，思路清晰，代码有注释辅助理解，但整体实现稍显复杂。
8. **SIXIANG32**：3星。提出用集合解决问题，但在处理文件夹重名问题上方法稍显复杂，代码注释较详细但整体实现不够简洁。
9. **盖矣斌峥**：4星。采用Trie树思路，结合`map`和`substr`函数实现，代码有一定注释，但整体实现相对复杂，对Trie树构建过程解释可更详细。
10. **_Clown_**：4星。详细解释使用`std::set`解决问题的思路和代码实现，从目录概览到代码剖析逐步展开，思路清晰，但代码注释可更丰富。
11. **cxh125011501**：3星。使用`set`保存目录，但代码实现过程较复杂，逻辑不够清晰，注释较少。
12. **离散小波变换°**：3星。介绍哈希方法解决问题，但涉及较多哈希实现细节，对初学者较难理解，且代码因哈希碰撞问题未完全AC。
13. **happybob**：4星。简洁阐述利用`std::set`去重特性解决问题的思路，代码简洁明了，有一定注释说明关键步骤。
14. **fls233666**：4星。详细分析构建Trie树解决问题的思路，从一般Trie树构建函数改造入手，结合`map`解决字符串作为数组下标的问题，代码有注释辅助理解。
15. **intel_core**：1星。提供的代码与本题无关，未解决题目要求的问题。
16. **chengni**：3星。使用`map`存储文件夹路径判断是否存在，思路较清晰，但代码实现过程稍显繁琐，处理空行问题方式较简单。
17. **hibiki**：4星。提出建立Trie树存储目录的方法，通过函数转换解决字符作为下标的问题，给出两种处理根节点计数的代码实现，思路较清晰。
18. **学霸壹号**：3星。简述利用`std::set`解决问题的思路和分离路径的方法，但代码未完整给出，思路阐述不够详细。

### 所选题解
1. **Anguei（5星）**
    - **关键亮点**：思路阐述清晰，代码简洁高效，对每个步骤都有详细注释。
    - **核心代码**：
```cpp
//【P1738】洛谷的文件夹 - 洛谷 - 100
#include <set>
#include <string>
#include <iostream> 

int main() {
    int n;
    std::cin >> n;
    std::set<std::string> set;
    
    for (int i = 1; i <= n; ++i) {
        std::string s;
        std::cin >> s;
        std::string dir = "";
        for (auto j : s) {
            if (j == '/')
                set.insert(dir);
            dir += j;
        }
        set.insert(dir);
        
        std::cout << set.size() - 1 << std::endl;
    }
}
```
    - **核心实现思想**：遍历读入的每个文件夹路径字符串，遇到“/”时将当前已遍历的路径插入`set`，遍历结束后再插入完整路径，最后输出`set`大小减1（减去根路径“/”）。
2. **FutureThx（4星）**
    - **关键亮点**：以样例详细解释思路，易于理解，使用`std::set`解决问题，代码简洁。
    - **核心代码**：
```cpp
#include <iostream>
#include <set>
using namespace std;
int main(){
    set<string> s;
    int n,j = 1;
    cin >> n;
    for(int i = 1;i <= n;i++){
        string a,x = "/",father = "";j = 1;
        cin >> a;
        while(j!= a.size() + 1){
            if(j == a.size())
                s.insert(father + x);
            else if(a[j] == '/'){
                s.insert(father + x);
                father = x  + father;
                x = "/";
            }
            else
                x += a[j];
            j++;
        }
        cout << s.size() << endl;
    }
    return 0;
}
```
    - **核心实现思想**：读入每个路径，通过循环遍历路径字符串，根据“/”分割出每个文件夹路径并插入`set`，最后输出`set`大小。
3. **Haishu（4星）**
    - **关键亮点**：提出链表解法，运行效率高，代码简洁。
    - **核心代码**：
```cpp
#include <cstdio>
#include <cstring>
const int S=101;
int n,res=0,l,i,j;
char o[S],r[S];
struct info
{
	struct info *c,*b;
	char a[S];
}*root;
void dfs(int i,struct info *&p,bool fg,char r[])
{
	if (!o[i] && fg) return;
	int j=i;
	if (fg)
	{
		for (j=i+1;o[j] && o[j]!='/';j++) r[j-i-1]=o[j];
		l=j-i-1;r[l]=0;
	}
	if (p && strcmp(p->a,r)) dfs(j,p->b,false,r);
	else
	{
		if (!p)
		{
			p=new struct info;
			strcpy(p->a,r);res++;
			p->b=p->c=NULL;
		}
		dfs(j,p->c,true,r);
	}
}
int main()
{
	scanf("%d",&n);
	while (n--)
	{
		scanf("%s",&o);
		dfs(0,root,true,r);
		printf("%d\n",res);
	}
	return 0;
}
```
    - **核心实现思想**：通过自定义链表结构`info`，使用深度优先搜索（`dfs`）从根节点开始查找和新建文件夹，每次新建文件夹时计数器`res`加1。

### 最优关键思路或技巧
1. **数据结构选择**：利用`std::set`的自动去重特性可以简洁地解决文件夹路径的统计问题，避免手动去重的繁琐操作。
2. **字符串处理**：遍历字符串时，根据“/”字符分割出每个文件夹路径，这种简单直接的字符串处理方式是解决本题的关键步骤。

### 同类型题或类似算法套路拓展
1. **同类型题**：此类题目通常围绕树形结构的统计或操作展开，如给定文件系统路径，进行文件或文件夹的查找、计数等操作。
2. **类似算法套路**：除了使用`set`去重和模拟Trie树结构外，还可以考虑使用并查集来处理具有层级关系的数据，但本题中由于不需要合并操作，所以并查集不太适用。在其他类似题目中，如果涉及到路径合并等操作，可考虑使用并查集优化。

### 推荐题目
1. **P3370 【模板】字符串哈希**：通过字符串哈希解决字符串匹配等问题，与本题部分题解中涉及的哈希思路相关。
2. **P2580 [ZJOI2006] 书架**：涉及到对多层书架结构的操作，类似于本题对文件夹层级结构的处理。
3. **P1075 [NOIP2012 普及组] 质因数分解**：虽然表面上是数论问题，但在实现过程中需要对输入数据进行适当处理和分解，与本题处理文件夹路径字符串有一定相似性，锻炼字符串处理和逻辑分析能力。

### 个人心得摘录与总结
1. **离散小波变换°**：在使用哈希方法时遇到哈希碰撞问题导致WA，发现手写链式哈希可以避免该问题。同时提到由于操作系统差异，输入数据可能存在换行符不一致的问题，建议手写读入函数处理。总结为在使用哈希算法时要考虑哈希碰撞，同时注意输入数据在不同环境下的差异。
2. **SIXIANG32**：在使用`set`解决问题时发现样例3无法通过，意识到需要处理文件夹重名问题，通过给文件夹名添加父亲文件夹作为后缀解决。心得为在做题时要全面考虑各种情况，遇到测试点不通过时要仔细分析原因并寻找解决办法。 

---
处理用时：72.38秒
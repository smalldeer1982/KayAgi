# 题目信息

# L 国的战斗之排兵布阵

## 题目背景

L 国即将与 I 国发动战争！！

## 题目描述

L 国的指挥官想让他的每一个军营都呈现出国徽形——L 形（方向无所谓）。当然，他的指挥营除外（这叫做个性），他想不出该怎么排，就这样，这任务又变成了你的······

## 说明/提示

$1\le n\le10$，$1\le x,y\le2^n$。

## 样例 #1

### 输入

```
4 1 3```

### 输出

```
1 1 0 2 3 3 4 4 5 5 6 6 7 7 8 8
1 9 2 2 3 10 10 4 5 11 11 6 7 12 12 8
13 9 9 14 15 15 10 16 17 11 18 18 19 19 12 20
13 13 14 14 21 15 16 16 17 17 18 22 22 19 20 20
23 23 24 21 21 25 26 26 27 27 28 28 22 29 30 30
23 31 24 24 25 25 32 26 27 33 33 28 29 29 34 30
35 31 31 36 37 32 32 38 39 39 33 40 41 34 34 42
35 35 36 36 37 37 38 38 43 39 40 40 41 41 42 42
44 44 45 45 46 46 47 43 43 48 49 49 50 50 51 51
44 52 52 45 46 53 47 47 48 48 54 49 50 55 55 51
56 52 57 57 58 53 53 59 60 54 54 61 62 62 55 63
56 56 57 64 58 58 59 59 60 60 61 61 65 62 63 63
66 66 67 64 64 68 69 69 70 70 71 65 65 72 73 73
66 74 67 67 68 68 75 69 70 76 71 71 72 72 77 73
78 74 74 79 80 75 75 81 82 76 76 83 84 77 77 85
78 78 79 79 80 80 81 81 82 82 83 83 84 84 85 85
```

# AI分析结果

### 综合分析与结论
这些题解均采用分治算法解决问题，思路上都是将大的 $2^n \times 2^n$ 方格分割成四个小方格进行处理，对于没有指挥营的小方格，通过设置“伪指挥营”（用L形覆盖一个角）使其可递归处理。算法要点在于确定指挥营位置、合理划分方格及递归填充。难点主要是处理好各部分的衔接及重新编号。

不同题解在实现细节和代码风格上有所差异。部分题解通过标记指挥营位置，在递归时根据其所在象限设置“伪指挥营”，并递归处理子方格；重新编号部分，有的采用暴力搜索相连区域，有的通过数组映射。

### 所选的题解
#### 作者：loverintime (5星)
- **关键亮点**：代码简洁，通过减少重复代码提高可读性与调试便利性。利用方向数组简化对四个部分的处理，重新编码采用数组映射而非再次搜索。
```cpp
#include<bits/stdc++.h>
const int N=(1<<10)+5;
int n,x,y;
int A[N][N],cnt,p[N*N],tot;
const int dx[4]={0,1,0,1},dy[4]={0,0,1,1},cox[4]={1,0,1,0},coy[4]={1,1,0,0};
void dfs(int x,int y,int c,int a,int b){
    if(c==0) return;c--;int t=++cnt;
    for(int i=0; i<4; i++){
        int nx=x+(dx[i]<<c),ny=y+(dy[i]<<c),f=nx+(cox[i]<<c)-cox[i],g=ny+(coy[i]<<c)-coy[i];
        if(a>=nx&&a<nx+(1<<c)&&b>=ny&&b<ny+(1<<c)) dfs(nx,ny,c,a,b);
        else dfs(nx,ny,c,f,g),A[f][g]=t;
    }
}
int main(){
    scanf("%d%d%d",&n,&x,&y);
    dfs(1,1,n,x,y);
    for(int i=1; i<=1<<n; i++) for(int j=1; j<=1<<n; j++){
        if(i!=x||j!=y){
            if(!p[A[i][j]]) p[A[i][j]]=++tot;
            printf("%d ",p[A[i][j]]);
        }
        else printf("0 ");
        if(j==(1<<n)) puts("");
    } 
    return 0;
}
```
核心实现思想：`dfs`函数递归处理每个方格，根据指挥营位置决定是否设置“伪指挥营”，`main`函数调用`dfs`并完成重新编码输出。

#### 作者：NewJeanss (4星)
- **关键亮点**：思路清晰，详细阐述分治思路及递归实现过程，代码结构清晰，对每个步骤有注释说明。
```cpp
inline void dfs(int x1,int y1,int x2,int y2,int targx,int targy){
    //(x1,y1)是左上角，(x2,y2)是右下角，(targx,targy)是指挥营
    int midx,midy,f1,f2,f3,f4;
    midx=(x1+x2)>>1; midy=(y1+y2)>>1;//中心点
    f1=f2=f3=f4=false;
    //判断中心点在哪一个方向
    if(targx<=midx&&targy<=midy){//左上
        f1=true;//最后不用再次递归左上，因为这里递归了
        g[midx+1][midy+1]=++cnt;//标记三个点
        g[midx][midy+1]=g[midx+1][midy]=cnt;
        if(abs(x1-x2)==1&&abs(y1-y2)==1) return;//如果已经是2*2了，结束递归
        dfs(x1,y1,midx,midy,targx,targy);
    }
    else if(targx<=midx&&targy>midy){//右上
        f2=true;
        g[midx+1][midy]=++cnt;
        g[midx][midy]=g[midx+1][midy+1]=cnt;
        if(abs(x1-x2)==1&&abs(y1-y2)==1) return;
        dfs(x1,midy+1,midx,y2,targx,targy);
    }
    else if(targx>midx&&targy<=midy){//左下
        f3=true;
        g[midx][midy+1]=++cnt;
        g[midx][midy]=g[midx+1][midy+1]=cnt;
        if(abs(x1-x2)==1&&abs(y1-y2)==1) return;
        dfs(midx+1,y1,x2,midy,targx,targy);
    }
    else if(targx>midx&&targy>midy){//右下
        f4=true;
        g[midx][midy]=++cnt;
        g[midx+1][midy]=g[midx][midy+1]=cnt;
        if(abs(x1-x2)==1&&abs(y1-y2)==1) return;
        dfs(midx+1,midy+1,x2,y2,targx,targy);
    }
    if(abs(x1-x2)==1&&abs(y1-y2)==1) return;
    //如果之前没有递归，最后再递归四个小正方形
    if(!f1) dfs(x1,y1,midx,midy,midx,midy);
    if(!f2) dfs(x1,midy+1,midx,y2,midx,midy+1);
    if(!f3) dfs(midx+1,y1,x2,midy,midx+1,midy);
    if(!f4) dfs(midx+1,midy+1,x2,y2,midx+1,midy+1);
}
```
核心实现思想：`dfs`函数根据指挥营位置在不同象限设置“伪指挥营”，递归处理子方格，直到方格大小为2x2。

#### 作者：zjc5 (4星)
- **关键亮点**：简洁明了地阐述思路，代码结构清晰，通过计算指挥营位置决定“伪指挥营”设置，递归实现分治。
```cpp
#include<stdio.h>
int n,x,y,l,tot,ans[1050][1050],prt,k[1100000];
void dfs(int a,int b,int c,int d,int x,int y){
//正方形左上角是a行b列，右下角是c行d列,军营在x行y列
    int h=(a+c)/2,l=(b+d)/2;
    int p=(x>h)*2+(y>l);
//p记录军营在正方形的哪个位置
//0表示左上，1表示右上，2表示左下，3表示右下
    if(p==0) ans[h][l+1]=ans[h+1][l]=ans[h+1][l+1]=++tot;
    else if(p==1) ans[h][l]=ans[h+1][l]=ans[h+1][l+1]=++tot;
    else if(p==2) ans[h][l]=ans[h][l+1]=ans[h+1][l+1]=++tot;
    else ans[h][l]=ans[h+1][l]=ans[h][l+1]=++tot;
    if(c-a>=3){
        if(p==0) dfs(a,b,h,l,x,y);
        else dfs(a,b,h,l,h,l);
        if(p==1) dfs(a,l+1,h,d,x,y);
        else dfs(a,l+1,h,d,h,l+1);
        if(p==2) dfs(h+1,b,c,l,x,y);
        else dfs(h+1,b,c,l,h+1,l);
        if(p==3) dfs(h+1,l+1,c,d,x,y);
        else dfs(h+1,l+1,c,d,h+1,l+1);
    }
}
int main(){
    scanf("%d%d%d",&n,&x,&y);
    l=1<<n;
    dfs(1,1,l,l,x,y);
    for(int i=1;i<=l;i++){
        for(int j=1;j<=l;j++)
        if(ans[i][j]){
            if(!k[ans[i][j]])
                k[ans[i][j]]=++prt;
            printf("%d ",k[ans[i][j]]);
        }else printf("0 ");
        puts("");
    }
    return 0;
}
```
核心实现思想：`dfs`函数通过计算指挥营所在象限设置“伪指挥营”，递归处理子方格，`main`函数调用`dfs`并完成重新编码输出。

### 最优关键思路或技巧
1. **减少重复代码**：如loverintime的题解，利用方向数组统一处理四个部分，减少重复代码，提高代码简洁性与可读性。
2. **合理利用递归**：各题解均通过递归实现分治，在递归中根据指挥营位置合理设置“伪指挥营”，逐步解决问题。
3. **重新编码优化**：loverintime采用数组映射重新编码，避免再次搜索，提高效率。

### 可拓展之处
同类型题常涉及分治算法，如棋盘覆盖问题、归并排序等。类似算法套路是将大问题分解为小问题，小问题解法与大问题类似，通过递归解决小问题并合并结果。

### 相似知识点洛谷题目
1. **P1228 地毯填补问题**：同样是棋盘覆盖问题，用L形骨牌覆盖棋盘特定位置。
2. **P1996 约瑟夫问题**：经典的递归与分治问题，通过不断缩小问题规模求解。
3. **P2167 [SDOI2009]Bill的挑战**：涉及分治思想，通过分治优化暴力搜索。

### 个人心得摘录与总结
作者loverintime提到，尽量少写重复部分可缩短代码长度，在处理复杂问题时，代码短更易调试。这强调了优化代码结构对提高编程效率和代码质量的重要性。 

---
处理用时：65.82秒
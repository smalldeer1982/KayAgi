# 题目信息

# 不想兜圈的老爷爷

## 题目描述

一位年过古稀的老爷爷在乡间行走

而他不想兜圈子 因为那会使他昏沉

偶然路过小A发扬助人为乐优良传统 带上地图 想知道路况是否一定使他清醒

usqwedf补充：为了让欢乐赛充满欢乐 小A还想问你一些数学作业……


## 说明/提示

[数据范围]

对于70%的数据 1<=n<=100 1<=m<=1000 1<=k<=30

对于100%的数据 1<=n<=1000 1<=m<=10000 1<=k<=10^9

另外，基于欢乐赛性质，我们保证数据当中至少有 20% 答案为 No


## 样例 #1

### 输入

```
3 3 3

1 2

2 3

3 1```

### 输出

```
No

9

```

# AI分析结果

### 综合分析与结论
这些题解主要围绕判断有向图是否存在环展开，大部分题解都正确识别出本题核心是判环问题，并使用了不同算法解决，最后通过快速幂计算相应结果。各题解的算法思路、要点及难点如下：
1. **拓扑排序**：通过不断删除入度为0的点及其出边，判断最终处理的点数是否等于总点数，若小于则有环。该方法时间复杂度较低，能高效解决大规模数据，是解决本题的主流且高效方法。
2. **深度优先搜索（DFS）**：标记已访问和正在访问的点，若在搜索路径上再次访问到正在访问的点则存在环。需注意避免重复搜索，否则易超时。
3. **Tarjan算法**：用于求有向图强连通分量，通过比较强连通分量个数与节点数判断是否有环。实现相对复杂，但能有效处理有向图环相关问题。
4. **Dijkstra及SPFA算法的变形应用**：利用Dijkstra不能走负环及SPFA可判负环的特性，将边权设为负来判断是否存在环。但需注意图的连通性及算法本身特性带来的问题。

从质量上看，部分题解思路清晰、代码规范且有优化，部分题解存在代码可读性差、算法使用不常规等问题。

### 所选的题解
1. **作者：kkksc03（5星）**
    - **关键亮点**：思路清晰，明确指出模型为判断有向图是否有环，提出搜索可得70分，拓扑排序可得100分的策略，并给出详细标程，还提及可使用tarjan缩点作为补充。
    - **重点代码（拓扑排序核心部分）**：
```cpp
while True do begin
    h := 0;
    for i := 1 to n do begin 
        if in_to[i] = 0 then begin
            in_to[i] := -1;
            h := h + 1; p[h] := i; 
        end;
    end;
    find := find + h;
    if h = 0 then break;
    if find = n then break;
    for i := 1 to h do
        for k := 1 to g[p[i]] do in_to[map[p[i],k]] := in_to[map[p[i],k]] - 1;
end;
```
核心思想：每次找到入度为0的点，标记并记录，然后更新这些点相连点的入度，重复此过程，直到没有入度为0的点或处理完所有点，通过判断处理的点数是否等于总点数来确定是否有环。
2. **作者：CaiXY06（4星）**
    - **关键亮点**：不仅给出暴力搜索判环和拓扑判环两种方法及对应代码，还指出$k^{2}$不用取模的坑点，对读者有较好的指导作用。
    - **重点代码（拓扑判环核心部分）**：
```cpp
inline void toposort() {
    queue<int>q;
    for(int i = 1; i <= n; i++) if(!in[i]) flag++, q.push(i);
    while(!q.empty()) {
        int u = q.front();
        q.pop();
        for(int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
            in[v]--;
            if(!in[v]) flag++, q.push(v);
        }
    }
}
```
核心思想：先将入度为0的点入队，然后不断从队列取出点，更新其相连点的入度，若有点入度变为0则入队，最后通过比较处理的点数与总点数判断是否有环。
3. **作者：WanderingTrader（4星）**
    - **关键亮点**：采用DFS判环，代码简洁，逻辑清晰，详细解释了每个部分的代码作用，并且给出幂取模的模板及详细说明，对读者理解和学习有帮助。
    - **重点代码（DFS核心部分）**：
```cpp
void dfs(int x) {
    if(sch[x]) { f[x] = true; return; }
    if(vis[x]) return;
    sch[x]=vis[x]=1;
    int size = es[x].size();
    for(int i = 0; i < size; ++ i) dfs(es[x][i]);
    sch[x] = 0;
}
```
核心思想：如果当前点正在被访问（sch[x]为真），说明存在环；如果已访问过（vis[x]为真）则跳过。标记当前点正在访问和已访问，然后递归搜索其邻接点，搜索完后取消正在访问的标记。

### 最优关键思路或技巧
拓扑排序是解决本题大规模数据的高效方法，其核心在于利用入度为0的点逐步消除图中的边和点，通过最终剩余点的情况判断是否有环。这种方法时间复杂度相对较低，适用于本题的数据范围。同时，快速幂算法用于计算$2^k \% 9997$，能有效避免直接计算带来的溢出问题，是处理此类幂运算取模的常用技巧。

### 可拓展之处
同类型题通常围绕图的环相关判断展开，比如判断无向图是否存在环、在带权图中判断特定条件下的环等。类似算法套路包括利用各种图的遍历算法（BFS、DFS）、专门的判环算法（如Tarjan）以及利用一些算法特性（如Dijkstra、SPFA与环的关系）来解决问题。

### 推荐题目
1. **P3387 【模板】缩点**：通过Tarjan算法求强连通分量并缩点，与本题Tarjan判环思路相关。
2. **P1112 [ZJOI2008] 迷宫**：涉及无向图的连通性及环的判断，可拓展图相关判环思路。
3. **P2812 校园网络**：需要利用拓扑排序解决有向图中节点关系及环相关问题，与本题拓扑判环类似。

### 个人心得摘录及总结
1. **作者：a1a2a3a4a5**：在使用Dijkstra算法解决本题时，因习惯从1号点出发导致部分测试点未通过，经思考发现应选取输入的点作为起始点。总结为在使用算法模板时，需根据题目实际情况灵活调整，不能盲目套用。 

---
处理用时：40.91秒
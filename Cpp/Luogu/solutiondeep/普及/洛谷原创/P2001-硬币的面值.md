# 题目信息

# 硬币的面值

## 题目描述

小 A 有 $n$ 种硬币，现在要买一样不超过 $m$ 元的商品，他不想得到找钱（多脏啊），同时又不想带太多的硬币，且硬币可以重复，现在已知这 $n$ 种硬币的价值，请问最少需要多少硬币就能组合成所有可能的价格？


## 说明/提示

【数据范围】

只有 9、10 会卡人，放心贪

对于 $20\%$ 的数据，$1 \le n \le 10$，$1 \le m \le 100$。  
对于 $60\%$ 的数据，$1 \le n \le 1000$，$1 \le m \le 10000$。  
对于 $80\%$ 的数据，$1 \le n \le 30000$，$1 \le m \le 2 \times {10}^9$。  
对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$1 \le m \le 2^{63}$。


## 样例 #1

### 输入

```
5 31

1 2 8 4 16

```

### 输出

```
5

```

# AI分析结果

### 综合分析与结论
这些题解都采用贪心算法解决问题，核心思路是先对硬币面值排序，若无面值为1的硬币则无解。在有解情况下，通过不断选取合适硬币，使能组合出的价格范围逐步扩大至m。各题解的不同主要体现在具体实现和优化方式上。

### 所选的题解
 - **作者：kkksc03 (4星)**
    - **关键亮点**：清晰阐述两种算法思路，先介绍O(M)算法，再指出其冗余并提出O(NlogN)优化算法，对理解算法演进有帮助。
 - **作者：pikabi (4星)**
    - **关键亮点**：先证明构成价格范围的条件，思路清晰。代码中通过计算需要累加的硬币个数优化，避免数据范围大时被卡。
```cpp
#include <cstdio>
#include <algorithm>
#define ll long long
#define inf 1023456789

using namespace std;

ll n, m, a[2000005], ans, tot;

int main(){
    scanf("%lld%lld",&n,&m);
    for(int i = 1; i <= n; i++)
        scanf("%d",&a[i]);
    sort(a + 1, a + n + 1);
    if(a[1]!= 1) {
        printf("No answer!!!\n");
        return 0;
    }
    a[n + 1] = m;
    for(int i = 1; i <= n; i++){
        if(tot < a[i + 1] - 1){
            ll k = (a[i + 1] - 2 - tot) / a[i] + 1;
            tot += a[i] * k;
            ans += k;
            if(tot >= m){
                printf("%lld\n",ans);
                return 0;
            }
        }
    }
    printf("%lld\n",ans + 1);
    return 0;
} 
```
核心实现思想：排序后先判断有无1，将m设为a[n + 1]辅助判停。遍历硬币，当当前能组合出的最大价格tot小于下一枚硬币面值减1时，计算需要累加的硬币个数k，更新tot和ans，最后处理tot刚好为m - 1的特殊情况。
 - **作者：nanzjz1 (4星)**
    - **关键亮点**：详细转化题意，分析算法思路，从普通贪心到乘法优化累加，过程清晰，还考虑硬币面值超过价格的情况并给出处理方法。
```cpp
// 第二版优化后的核心代码
for(register int i=1;i<=n;++i)
{
    if(maxm+1<value[i+1])
    {
        long long gjr=(value[i+1]-2-maxm)/value[i]+1;
        maxm+=value[i]*gjr,num+=gjr;
        if(maxm>=m)
        {
            printf("%lld",num);
            return 0;
        }
    }
}
```
核心实现思想：排序后判断最小值是否为1。遍历硬币，当当前能组合出的最大价格maxm小于下一枚硬币面值减1时，计算需要累加的硬币个数gjr，更新maxm和num，若maxm达到m则输出num。

### 最优关键思路或技巧
排序后先判断是否有面值为1的硬币确定有无解。在贪心过程中，通过计算每次需要累加的硬币数量，而不是逐个累加，优化时间复杂度，避免大数据范围下超时。

### 可拓展思路
此类问题属于贪心策略在组合问题中的应用。类似套路如在一些资源分配、任务调度问题中，通过合理定义贪心策略，每次选择局部最优解，最终得到全局最优。

### 相似知识点洛谷题目
 - **P1094 [NOIP2007 普及组] 纪念品分组**：通过贪心策略对物品分组以满足条件。
 - **P1199 [NOIP2010 普及组] 三国游戏**：运用贪心思想进行游戏策略选择。
 - **P1080 [NOIP2012 提高组] 国王游戏**：利用贪心算法解决分配问题。

### 个人心得摘录与总结
 - **flyfree**：分享自己错误思路及如何发现错误，强调局部最优不能保证全局最优，最终理解正解贪心策略的正确性。总结出凑值时应尽量利用已凑出的值避免答案增加。 

---
处理用时：28.82秒
# 题目信息

# 龙兄摘苹果

## 题目描述

龙兄在淘淘摘苹果的那个果园里摘了 $n$ 个完全互不相同的苹果，好客的园主为他提供了 $k$ 个篮子，他想把苹果装在篮子里拎回家（由于龙兄的手是无限大的，所以你不必考虑他能不能同时拎这么多篮子）。

同时，他不希望有任何一个篮子里是空的，因为这样就做不到物尽其用。因此他想知道一共有多少种放苹果的方法，由于他的大脑运算过慢，所以找到了聪明机智的你，他在摘苹果上已经花了很长时间，所以他只能等 $1$ 秒。

由于方法很可能非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常多，龙兄的大脑无法存储，所以他会给你一个数 $p$，输出方法数除以 $p$ 的余数就可以了。

## 说明/提示

### 样例解释

一共有 $4$ 个苹果，$2$ 个篮子。

有以下 $7$ 种方法。

- $\{1\},\{2,3,4\}$；
- $\{2\},\{1,3,4\}$；
- $\{3\},\{1,2,4\}$；
- $\{4\},\{1,2,3\}$；
- $\{1,2\},\{3,4\}$；
- $\{1,3\},\{2,4\}$；
- $\{1,4\},\{2,3\}$。

$7$ 除以 $3$ 余 $1$。

### 数据范围及约定

- 对于 $20\%$ 的数据，$n \le 8$，$k \le 8$。
- 对于 $60\%$ 的数据，$n \le 100$，$k \le 100$。
- 对于 $100\%$ 的数据，$n \le 10000$，$k \le 1000$。

保证所有数据 $n \ge k$，且答案在 $64$ 位整型范围内。

## 样例 #1

### 输入

```
4 2 3```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解都指出本题是运用动态规划解决将\(n\)个不同苹果放入\(k\)个非空篮子并取余的问题，核心状态转移方程为\(ans[i][j]=ans[i - 1][j - 1]+ans[i - 1][j]*j\) ，表示新增苹果单独放一篮或放入已有篮子的方案数之和。部分题解还进行了空间复杂度优化。

### 所选的题解
1. **翼德天尊**：★★★★
    - **关键亮点**：思路清晰，先明确用动规解题，详细解释状态转移方程含义，代码简洁且注释详细。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long ans[10001][1001];
long long n,k,p;
int main(){
    cin>>n>>k>>p;
    ans[1][1]=1;
    for (int i=1;i<=n;i++){
        ans[i][1]=1;
        for (int j=2;j<=k;j++)
            ans[i][j]=((j%p)*(ans[i-1][j]%p)%p+(ans[i-1][j-1])%p)%p;
    }
    printf("%lld\n",ans[n][k]);
    return 0;
}
```
    - **核心实现思想**：通过两层循环遍历苹果数和篮子数，依据状态转移方程计算方案数并随时取余，最后输出结果。
2. **小柯**：★★★★
    - **关键亮点**：在解释状态转移方程基础上，对空间复杂度进行优化，给出滚动数组优化到\(O(2k)\) 、\(O(k)\) 、\(O(2)\)的思路及代码，虽第三个代码有问题，但优化思路有学习价值。
    - **重点代码（优化到\(O(2k)\)）**：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,k;
__int128 p,s,f[2][1005];
char x;
__int128 r(){
    s=0;
    x=getchar();
    while(x<'0'||x>'9')x=getchar();
    while(x>='0'&&x<='9')s=(s<<1)+(s<<3)+x-'0',x=getchar();
    return s;
}
void w(__int128 a){
    if(a<0){
        w(-a);
        return;
    }
    if(a==0)return;
    w(a/10);
    putchar(a%10+'0');
}
int main(){
    f[1][1]=1;
    cin>>n>>k;
    p=r();
    for(int i=1;i<=n;i++){
        for(int j=min(i,k);j>=(i==1?2:1);j--){
            f[i&1][j]=((f[(i+1)&1][j]*j)%p+f[(i+1)&1][j-1]%p)%p;
        }
    }
    if(f[n&1][k]==0)cout<<0<<endl;
    else w(f[n&1][k]);
    return 0;
}
```
    - **核心实现思想**：利用滚动数组，通过`i&1`来交替使用数组的两行，减少空间占用，同时在循环中依据状态转移方程计算并取余。
3. **我和鱼过不去**：★★★★
    - **关键亮点**：先简述题意为求把\(n\)个元素分成\(k\)个非空集合的方案数，清晰推导递推式，代码简洁且注释清晰说明递推式及取模要点。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long f[10005][1005];
long long n,k,p;
int main()
{
    cin>>n>>k>>p;
    f[1][1] = 1;
    for(int i=1;i<=n;i++)  {
        f[i][1] = 1;
        for(int j=1;j<=k;j++){
            f[i][j] = (f[i-1][j-1]%p + (f[i-1][j]%p)*(j%p))%p;
            f[1][1] = 1;
        }
    }
    cout<<f[n][k];
    return 0;
}
```
    - **核心实现思想**：通过两层循环遍历苹果数和篮子数，按照推导的递推式计算方案数，并在每次计算时进行取模操作。

### 最优关键思路或技巧
1. **状态转移方程推导**：从新增苹果的放置方式出发，得到简洁有效的状态转移方程，是解决问题的核心。
2. **滚动数组优化空间**：利用滚动数组减少空间复杂度，如小柯题解中从\(O(nk)\)优化到\(O(2k)\) 、\(O(k)\)甚至\(O(2)\) ，在处理大数据时能有效节省内存。

### 可拓展之处
此类题目属于组合数学中的分配问题，相似套路是通过分析元素的分配方式得到状态转移方程。同类型题如将相同元素分配到不同容器且容器不能为空等，解决思路类似但状态转移方程会有不同。

### 洛谷相似题目推荐
1. [P1282 多米诺骨牌](https://www.luogu.com.cn/problem/P1282)：通过动态规划解决骨牌覆盖方案数问题。
2. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：利用动态规划求过河卒的行走方案数。
3. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)：经典的动态规划题目，通过状态转移方程求数字三角形路径最大和。

### 个人心得摘录与总结
无明显个人心得。 

---
处理用时：37.01秒
# 题目信息

# 跳舞

## 题目描述

小明今天得到一个跳舞毯游戏程序 Dance。游戏每次连续出 $N$ 个移动的“箭头”，箭头依次标号为 $1$ 到 $N$，并且得到相应的分数 $S _ 1, S _ 2, \ldots, S _ n$。如果你能“踏中”第 $i$ 号箭头，你将获得相应的分数 $S_i$；否则将被扣除相应的分数。

另外，游戏还有一个累计奖励机制：如果踏准次数累计达到 $T$，并且是在踏中第 $i$ 个箭头达到的，则将得到 $B_i$ 的奖励分数,累计也将清零，重新开始。

例如：$N=6,T=3$，相应的序列 $S$ 和 $B$ 分别为 $\{1,2,3,4,5,6\}$、$\{0,0,4,7,9,10\}$，如果小明踏中所有箭头，则得分为：$(1+2+3+4)+(4+5+6+10)=35$。

小明是个 Dance 高手，可以踏中他想踏中的任意一个箭头。但他发现，根据给定的 $N,T,S,B$，踏中所有的箭头不一定能得最高分，小明很想知道最高能得多少分，你能帮助小明计算一下最多可得多少分吗？


## 说明/提示


【样例解释】

跳过第一个，扣 $1$ 分，连踩 $3$ 个，得 $9$ 分，并获得附加分 $20$ 分，之后再连踩 $2$ 个，共 $39$ 分。

【数据范围】

对于 $20\%$ 的数据 $0\le N,T\le100$；

对于 $100\%$ 的数据 $0\le N,T\le 5000$；

序列 $S$ 和 $B$ 各有 $N$ 个数，所有分数为 $[0,10000]$ 之间的整数。

## 样例 #1

### 输入

```
6 3
1 2 3 4 5 6
1 1 1 20 1 1```

### 输出

```
39```

# AI分析结果

### 综合分析与结论
这些题解主要围绕动态规划（DP）算法来解决跳舞毯游戏得分最大化问题。多数题解思路相似，难点在于准确推导状态转移方程以及处理空间优化。

思路上，普遍使用二维数组 `dp[i][j]` 表示前 `i` 个箭头中踏中 `j` 次的最大得分，通过考虑当前箭头踩与不踩的情况来推导状态转移方程。对于奖励机制，当 `j` 是 `t` 的倍数时，状态转移方程需额外加上奖励分数 `b[i]`。

算法要点：初始化 `dp` 数组，通常 `dp[i][0]` 初始化为 `dp[i - 1][0] - s[i]` 表示一直不跳的情况；通过两层循环遍历箭头数和踏中次数，根据是否达到奖励条件更新 `dp` 数组；最后从 `dp[n][i]`（`1 <= i <= n`）中取最大值作为结果。

解决难点方面，部分题解提到状态定义若不合理可能无法转移，如定义 `dp[i][j]` 为前 `i` 个格子总共跳了 `j` 次的最大得分，因不知新轮操作起点而无法转移。优化方向主要是空间优化，利用滚动数组将二维数组压缩为一维，减少空间复杂度。

### 所选的题解
1. **作者：Dispwnl (赞：21)  星级：5星**
    - **关键亮点**：思路清晰，代码简洁明了，直接给出状态转移方程和完整代码实现，详细说明了 `dp` 数组各维度含义及状态转移的具体情况。
    - **重点代码**：
```cpp
for(int i=1;i<=n;i++)
    f[i][0]=f[i-1][0]-s[i];
for(int i=1;i<=n;i++)
    for(int j=1;j<=i;j++)
    {
        f[i][j]=max(f[i-1][j]-s[i],f[i-1][j-1]+s[i]);
        if(j%t==0) f[i][j]=max(f[i-1][j]-s[i],f[i-1][j-1]+s[i]+b[i]);
    }
int ans=0;
for(int i=1;i<=n;i++)
    ans=max(ans,f[n][i]);
```
    - **核心实现思想**：先初始化 `dp` 数组 `f`，表示一直不跳的情况。然后通过两层循环，外层遍历箭头数，内层遍历踏中次数。每次根据当前箭头踩与不踩更新 `f[i][j]`，当踏中次数是 `t` 的倍数时，考虑奖励分数。最后遍历 `f[n][i]` 找到最大得分。
2. **作者：Tyyyyyy (赞：13)  星级：5星**
    - **关键亮点**：不仅给出了正解DP的详细思路，包括状态定义、状态转移方程推导，还给出了暴力搜索的代码及分析，帮助理解问题本质。
    - **个人心得**：提到暴力搜索只能得10分，因从第二个点开始出极限数据。
    - **重点代码**：
```cpp
for(int i=1;i<=n;i++)dp[i][0]=dp[i-1][0]-s[i];
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=i;j++)
    {
        dp[i][j]=max(dp[i-1][j]-s[i],dp[i-1][j-1]+s[i]);
        if(j%t==0)dp[i][j]=max(dp[i-1][j]-s[i],dp[i-1][j-1]+s[i]+b[i]);
    }
}
for(int i=1;i<=n;i++)ans=max(ans,dp[n][i]);
```
    - **核心实现思想**：与Dispwnl的实现类似，先初始化 `dp` 数组，通过两层循环遍历更新 `dp` 数组，根据是否达到奖励条件分别处理，最后找到最大得分。
3. **作者：grass8cow (赞：6)  星级：4星**
    - **关键亮点**：简洁地给出状态转移方程，同时提供了滚动数组优化空间的代码，展示了优化思路。
    - **重点代码（滚动数组优化后）**：
```cpp
for(i=1;i<=n;i++)for(j=i;j>=0;j--)f[j]=max(f[j]-a[i],j?(f[j-1]+a[i]+(j%t?0:b[i])):-210000000);
for(j=0;j<=n;j++)ans=max(ans,f[j]);
```
    - **核心实现思想**：利用滚动数组，每次只保留当前状态与前一次状态，通过倒序遍历更新数组，减少空间使用，最后找到最大得分。

### 最优关键思路或技巧
1. **状态定义**：合理定义 `dp` 数组状态，以当前箭头位置和累计踏中次数作为维度，能有效进行状态转移。
2. **状态转移方程**：根据当前箭头踩与不踩、是否达到奖励条件，分别推导状态转移方程，全面考虑各种情况。
3. **滚动数组优化**：利用滚动数组将二维 `dp` 数组压缩为一维，降低空间复杂度，提高算法效率。

### 可拓展之处
同类型题通常围绕动态规划展开，特点是问题可分解为多个子问题，且子问题存在重叠性与最优子结构性质。类似算法套路是先确定状态表示，再推导状态转移方程，最后考虑是否需要优化空间或时间复杂度。

### 洛谷相似题目推荐
1. **P1048 [NOIP2005 普及组] 采药**：通过选择不同价值和重量的草药，在背包容量限制下获取最大价值，与本题选择踩或不踩箭头获取最大得分思路相似。
2. **P1280 尼克的任务**：根据任务开始时间、持续时间和价值，合理安排任务以获得最大价值，同样涉及状态转移和最优解问题。
3. **P1880 [NOI1995] 石子合并**：将多个石子堆合并，每次合并有一定代价，求最小或最大合并代价，也是典型的动态规划问题，与本题在思路和方法上有相似之处。

### 个人心得摘录与总结
1. **Tyyyyyy**：尝试暴力搜索发现只能得10分，因数据规模问题，体现了暴力解法在面对较大数据时的局限性，强调了寻找更优算法（如DP）的重要性。 

---
处理用时：40.97秒
# 题目信息

# 找人

## 题目描述

小明要到他的同学家玩，可他只知道他住在某一单元，却不知住在哪个房间。那个单元有 $n$ 层（$1,2,\ldots,n$），每层有 $m$（$1,2,\ldots,m$）个房间。

小明会从第一层的某个房间开始找，他找的方式也很特别，每次到了一个房间，如果不是他的同学，他就会询问这个人，然后他就会去那人告诉他的房间号，如果还不是，他就会继续按这个方法找下去，直到找到。当然，他也有可能找不到同学。他的体力也是有限的，他每爬一层楼梯就会消耗 $v$ 体力值。你的任务就是求找到同学耗费的最少体力值，如果找不到，就输出 `impossible` 。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \leq n\le1000$，$1 \leq m\le100$，$1 \leq v\le50$。

## 样例 #1

### 输入

```
3 3 2 2 3
1 3 3 3 2 1
2 3 1 1 2 3
1 1 1 2 2 3
```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何找到小明找同学耗费最少体力值的问题，采用了深度优先搜索（DFS）、广度优先搜索（BFS）、并查集、最短路算法（SPFA）等多种算法。各算法要点及难点如下：
 - **DFS**：从第一层每个房间开始搜索，记录最小体力值。难点在于判环，若不处理会导致程序陷入死循环。
 - **优先队列BFS**：利用优先队列保证当前最优花费优先，解决状态转移代价不止0/1的问题。需注意优先队列默认大根堆，要调整优先级。
 - **并查集**：将房间关系通过并查集合并，最后判断同学家是否为根节点，过程中不能使用路径压缩。难点在于并查集的构建和对死循环的判定。
 - **最短路算法（SPFA）**：反向存边，把目标位置当源点跑单源最短路，再找第一层房间到源点最短距离的最小值。需理解反向建图和单源最短路的应用。

综合质量来看，Dog_Two的题解思路清晰，对BFS变形解释详细，代码规范，可读性高；白鲟的题解提出独特的单源最短路思路，表述清晰，代码注释详细；AFOier的DFS题解简洁明了，对判环处理得当，代码易理解。这三篇题解在思路清晰度、代码可读性和优化程度上表现较好。

### 所选的题解
 - **作者：Dog_Two（5星）**
    - **关键亮点**：对BFS的不同应用场景进行了详细分析，针对本题状态转移代价特点，采用优先队列BFS，代码结构清晰，注释详细。
    - **个人心得**：分享了调试过程中多次因细节错误导致得分低的经历，如对下楼体力消耗的误解、状态优先度定义错误、判定终点条件错误等，强调了细节在算法实现中的重要性。
```cpp
bool operator < (const rec &a,const rec &b){
    return a.cnt>b.cnt;
}
int BFS(){
    for(int i=1;i<=m;++i){
        q.push((rec){0,make_pair(1,i)});
    }
    while(!q.empty()){
        rec tmp=q.top(); q.pop();
        int x=tmp.p.first,y=tmp.p.second;
        if(vis[x][y]) continue;
        vis[x][y]=true;
        int C=tmp.cnt;
        pair<int,int> Next=get_Next(tmp.p);
        if(tmp.p==make_pair(_x,_y)) return C; 
        int del=abs(Next.first-x); 
        q.push((rec){del+C,Next});
    }
    return -1;
}
```
核心实现思想：重载小于运算符，使优先队列按总爬楼数从小到大排序。BFS函数中，从一楼每个房间开始入队，每次取出优先队列顶端元素，若未访问过则标记，判断是否到达目标，否则计算到下一个房间的体力消耗并将下一个房间入队。

 - **作者：白鲟（4星）**
    - **关键亮点**：提出将目标位置作为源点，反向存边，只跑一遍单源最短路的优化思路，减少计算量，代码注释详细。
```cpp
void add(int u,int v,int w)
{
    from[++total]=u;
    to[total]=v;
    len[total]=w;
    next[total]=head[u];
    head[u]=total;
    return;
}
void spfa(void)
{
    int minn=0x7fffffff;
    queue<int>que;
    memset(dis,0x7f,sizeof(dis));
    que.push(s);
    exist[s]=true;
    dis[s]=0;
    while(!que.empty())
    {
        int p=que.front();
        que.pop();
        exist[p]=false;
        for(int i=head[p];i;i=next[i])
        {
            if(dis[to[i]]>dis[p]+len[i])
            {
                dis[to[i]]=dis[p]+len[i];
                if(!exist[to[i]])
                {
                    que.push(to[i]);
                    exist[to[i]]=true;
                }
            }
        }
    }
    for(int i=1;i<=m;++i)
        minn=min(dis[i],minn);
    if(minn<0x7f7f7f7f)
        printf("%d",minn);
    else
        printf("impossible");
    return;
}
```
核心实现思想：add函数用于反向建边。spfa函数中，初始化距离数组，将源点入队，每次取出队首元素，更新邻接节点距离，若邻接节点未在队列中则入队，最后遍历第一层房间找到到源点的最小距离并输出。

 - **作者：AFOier（4星）**
    - **关键亮点**：采用DFS算法，代码简洁，逻辑清晰，通过记录走过房间数判断是否存在环，有效避免死循环。
```cpp
int dfs(int c,int f,int s,int zs)
{
    if(c==zx&&f==zy)return s; 
    if(zs>n*m)return 10000000;
    dfs(a[c][f].x,a[c][f].y,s+v*(abs(a[c][f].x-c)),zs+1);
}
```
核心实现思想：dfs函数中，若到达目标房间则返回当前体力值；若走过房间数大于总房间数则返回极大值表示不可能；否则递归搜索下一个房间，更新体力值和走过房间数。

### 最优关键思路或技巧
 - **优先队列BFS**：适用于边权不只有0/1的状态空间，通过优先队列保证第一次取出目标状态时花费为最优。
 - **反向建图与单源最短路**：将目标位置作为源点反向存边，只跑一遍单源最短路，减少计算量。
 - **DFS判环**：在DFS过程中记录走过的步数，若步数超过总房间数则判定存在环，及时返回避免死循环。

### 可拓展思路
此类题目属于图论或搜索类问题，可拓展到其他路径搜索、状态转移问题。类似算法套路如在不同边权情况下选择合适的搜索方式（BFS、DFS变形），根据问题特点优化建图方式（正向、反向建图）等。

### 相似知识点洛谷题目
 - [P1339 热浪](https://www.luogu.com.cn/problem/P1339)：最短路问题，考察对最短路算法的应用。
 - [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)：搜索问题，可使用DFS或BFS解决，涉及到对不同状态的处理。
 - [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：单源最短路模板题，加深对单源最短路算法的理解和应用。

---
处理用时：45.28秒
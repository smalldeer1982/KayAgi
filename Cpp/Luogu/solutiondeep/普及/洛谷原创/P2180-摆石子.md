# 题目信息

# 摆石子

## 题目背景

我们伟大的KK突然想到了一个很高（Shā）明（bī）的问题。


## 题目描述

我们伟大的KK在N条水平线与M条竖直线构成的网格中（KK的自创坐标系），放K枚石子，每个石子都只能放在网格的交叉点上。现在KK想知道在最优的摆放方式下，最多可以找到多少四边平行于坐标轴的长方形，而且KK要求它的四个角上都恰好放着一枚石子。


## 说明/提示

50%的数据    0<N，M≤30；

100%的数据   0<N，M≤30000  K≤N\*M。


## 样例 #1

### 输入

```
3 3 8```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均基于数学推导与贪心策略。首先明确要使满足条件的长方形最多，石子应摆成接近矩形且仅有一行不满的形状。通过数学推导得出在\(n×m\)矩形石子阵中不同矩形数量的计算公式，再枚举行数或列数，结合余数计算出最终答案。

各题解的主要区别在于代码实现细节、推导过程的详细程度以及对边界条件的处理。从质量上看，多数题解思路清晰，但在代码可读性和优化程度上有所差异。

### 所选的题解
- **作者：彭天宇（5星）**
    - **关键亮点**：思路清晰，先分析出最优摆放形状，详细推导矩形数量公式，并通过类似二维前缀和方法计算非矩形石子阵，代码实现简洁明了。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int main(){
    int maxn=0;
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++){
        if(k/i>=m)continue;
        int len=k/i;
        int mod=k%i;
        maxn=max(maxn,(i*(i-1)/2*len*(len-1)/2+(len+1)*len/2*mod*(mod-1)/2-(len*(len-1)/2*mod*(mod-1)/2)));
    }
    for(int i=1;i<=m;i++){
        if(k/i>=n)continue;
        int len=k/i;
        int mod=k%i;
        maxn=max(maxn,(i*(i-1)/2*len*(len-1)/2+(len+1)*len/2*mod*(mod-1)/2-(len*(len-1)/2*mod*(mod-1)/2))); 
    }
    cout<<maxn<<endl;
    return 0;
}
```
    - **核心实现思想**：通过两层循环分别枚举行数和列数，计算不同情况下能组成的矩形数量，取最大值。其中通过除法和取余运算得到每行石子数及剩余石子数，利用组合数学公式计算矩形数量。

- **作者：Alarm5854（4星）**
    - **关键亮点**：详细解释了最优摆放形状，给出计算\(a×b\)网格中矩形数量的公式，代码中对边界条件处理得当，并指出\(n\)和\(m\)大小关系对结果的影响。
    - **重点代码**：
```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;
FILE *fin, *fout;
inline int read(ll &x) {
    char c = 0; int f = x = 0;
    while (c < 48 || c > 57) {
        if (c == -1) return 0;
        if (c == '-') f = 1; c = fgetc(fin);
    }
    while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
    if (f) x = -x; return 1;
}
template<class T, class... Args> inline int read(T &x, Args&... args) {
    return read(x) + read(args...);
}
inline int write(ll x) {
    if (x < 0) return fputc(45, fout), write(-x);
    if (x > 9) write(x / 10);
    return fputc((x % 10) | 48, fout), 1;
}
ll n, m, k, ans;
int main() {
    #ifdef ONLINE_JUDGE
    fin = stdin;
    fout = stdout;
    #else
    fin = fopen("P2180.in", "rb");
    fout = fopen("P2180.out", "wb");
    #endif
    read(n, m, k); if (n > m) swap(n, m);
    for (ll i = 1; i <= min(n, k); ++i) {
        ll x = k / i, y = k % i;
        if (!y && x > m) continue;
        if (y && x >= m) continue;
        ans = max(ans, i * x * (i - 1) * (x - 1) / 4 + x * y * (y - 1) / 2);
    }
    write(ans);
    return 0;
}
```
    - **核心实现思想**：先交换\(n\)和\(m\)保证\(n \leq m\)，通过循环枚举行数\(i\)，计算每行石子数\(x\)和剩余石子数\(y\)，根据公式计算能组成的矩形数量并取最大值。

- **作者：phigy（4星）**
    - **关键亮点**：代码简洁，直接通过循环枚举并计算不同情况下的矩形数量，同时注意到数据范围需使用`long long`类型避免溢出。
    - **重点代码**：
```cpp
#include <iostream>
using namespace std;
int n,m,k;
int main()
{
    long long ans=0;
    int x,y;
    int i,j;
    cin>>n>>m>>k;
    if(n>m)swap(n,m);
    for(i=1;i<=k&&i<=n;i++)
    {
        if(k%i==0&&k/i>m)
        {
            continue;
        }
        if(k%i!=0&&k/i>m-1) 
        { 
            continue; 
        }
        x=k/i; 
        y=k%i; 
        ans=max(ans,(long long)x*(x-1)/2*i*(i-1)/2+y*(y-1)/2*x);
    }
    cout<<ans;
    return ^.^;
}
```
    - **核心实现思想**：先交换\(n\)和\(m\)，通过循环枚举可能的行数\(i\)，根据条件过滤不合法情况，计算每行石子数\(x\)和剩余石子数\(y\)，利用公式计算矩形数量并更新最大值。

### 最优关键思路或技巧
- **贪心策略**：确定石子摆成接近矩形且仅有一行不满的形状能使满足条件的长方形最多。
- **数学推导**：通过数学方法推导出\(n×m\)矩形石子阵中不同矩形数量的计算公式，简化计算过程。
- **边界条件处理**：在枚举过程中，仔细处理诸如每行石子数超过网格列数等边界情况，确保结果正确。

### 可拓展之处
同类型题通常涉及在网格中放置元素并计算满足特定几何形状（如矩形、三角形等）的数量。类似算法套路是先通过分析得出最优布局，再利用数学知识推导计算公式，最后结合枚举和边界处理得出答案。

### 相似知识点洛谷题目
- **P1313 计算系数**：涉及二项式定理等数学知识，通过推导公式解决问题。
- **P2671 求和**：需要运用数学推导和前缀和优化来计算满足条件的和。
- **P3951 小凯的疑惑**：通过数论知识和数学推导求解问题。 

---
处理用时：50.41秒
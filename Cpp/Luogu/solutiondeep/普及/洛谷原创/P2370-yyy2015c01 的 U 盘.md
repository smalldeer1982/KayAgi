# 题目信息

# yyy2015c01 的 U 盘

## 题目背景

在 2020 年的某一天，我们的 yyy2015c01 买了个高端 U 盘。


## 题目描述

你找 yyy2015c01 借到了这个高端的 U 盘，拷贝一些重要资料，但是你发现这个 U 盘有一些问题：

1. 这个 U 盘的传输接口很小，只能传输大小不超过 $L$ 的文件。
2. 这个 U 盘容量很小，一共只能装不超过 $S$ 的文件。

但是你要备份的资料却有很多，你只能备份其中的一部分。

为了选择要备份哪些文件，你给所有文件设置了一个价值 $V_i$，你希望备份的文件总价值不小于 $p$。

但是很快你发现这是不可能的，因为 yyy2015c01 的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）。

注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,

你放在 U 盘中文件的总大小不能超过 U 盘容量。

现在问题来了：你想知道，在满足 U 盘中文件价值之和**不小于** $p$ 时，最小需要多大的接口。

## 说明/提示

$1 \le n, W_i, S \le 10^3$，$1 \leq V_i \leq 10^6$，$1 \leq p \leq 10^9$。

数据较小，请勿乱搞。

样例解释 $1$：买一个大小为 $2$ 接口，把物品 $1$ 、$2$ 放进$\text{U}$盘。

样例解释 $2$：买一个大小为 $500$ 的接口。

样例解释 $3$：本来可以买大小为 $2$ 的接口，可是 U 盘容量放不下足够的文件。

如果数据出现疏漏，请联系出题人 [a710128](https://www.luogu.com.cn/user/2573)

向本题主人公 yyy2015c01 同学致敬！

## 样例 #1

### 输入

```
3 3 5
2 2
1 2
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 505
1 2
500 1```

### 输出

```
500```

## 样例 #3

### 输入

```
3 3 2
2 2
1 2
3 2```

### 输出

```
No Solution!```

## 样例 #4

### 输入

```
4 5 6
5 1
5 2
5 3
1 1```

### 输出

```
No Solution!```

# AI分析结果

### 综合分析与结论
该题目要求在满足 U 盘中文件价值之和不小于 p 的情况下，求出最小需要多大的 U 盘传输接口。题解主要分为两类思路：
1. **二分 + 背包**：大部分题解采用此方法。先确定二分的范围，即文件大小的最小值到最大值。通过二分枚举接口大小 L，每次使用 01 背包算法验证在此接口大小下，能否在 U 盘容量限制内得到不小于 p 的文件总价值。若能，则尝试减小接口大小；否则，增大接口大小。
2. **贪心 + 背包**：少数题解利用贪心思想，将文件按大小从小到大排序，在进行 01 背包计算时，一旦发现装入某个文件后总价值不小于 p，就直接输出该文件大小，认为此时的文件大小就是满足条件的最小接口大小。但此方法正确性存疑，因为贪心策略不一定能保证全局最优。

解决本题的难点在于如何将二分查找与 01 背包算法有效结合，以及处理边界条件和无解情况。

### 所选的题解
1. **作者：MuelsyseU (5 星)**
    - **关键亮点**：思路阐述极为清晰，对 01 背包和二分答案的原理分别进行了详细的解释，包括状态转移方程的推导、数组压缩的原理、二分答案的适用条件等，代码注释丰富，易于理解。
    - **个人心得**：作者立志写超长题解，通过本题复习二分与 01 背包算法，感觉题目是将二者结合的好题。
    - **核心代码**：
```cpp
int dp(int k) {
    for(int j=1;j<=s;j++)
        f[j]=0;
    for(int i=1;i<=n;i++){
        if(k!=-1&&a[i]>k) continue;
        for(int j=s;j>=a[i];j--){
            f[j]=max(f[j],f[j-a[i]]+b[i]);
        }
    }
    return f[s];
} 

bool check(int s) {
    return dp(s)>=m;
}

int find(int low,int high) {
    int mid;
    while(low+1<high){
        mid=low+(high-low)/2;
        if(check(mid))
            high=mid;
        else
            low=mid;
    } 
    return high;
}
```
核心思想：`dp`函数实现带接口大小限制的 01 背包，计算最大价值；`check`函数通过调用`dp`判断当前接口大小是否可行；`find`函数利用二分查找找到最小可行的接口大小。
2. **作者：cs18 (4 星)**
    - **关键亮点**：提出直接用 01 背包 + 排序的方法解题，代码简洁明了，在一定程度上优化了算法，避免了二分查找的复杂过程。
    - **核心代码**：
```cpp
int main()
{
    scanf("%d%d%d",&n,&p,&s);
    for(int i=1;i<=n;i++)
    scanf("%d%d",&a[i].v,&a[i].w);
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
        for(int j=s;j>=a[i].v;j--){
            dp[j]=max(dp[j],dp[j-a[i].v]+a[i].w);
            if(dp[s]>=p){
                printf("%d",a[i].v);
                return 0;
            }
        }
    printf("No Solution!");    
}
```
核心思想：先按文件大小对文件结构体数组排序，再进行 01 背包计算，一旦装满 U 盘时价值超过 p，就输出当前文件大小。
3. **作者：lzpclxf (4 星)**
    - **关键亮点**：在二分 + 背包的基础上，对二分的范围进行了优化，通过在输入时记录文件大小的最大值和最小值来确定二分的初始范围，同时提到位运算比除法快的小技巧，对代码有一定优化。
    - **核心代码**：
```cpp
int main() {
    scanf("%d%d%d", &n, &p, &s);
    for(int i = 1; i <= n; i++) {
        scanf("%d%d", &w[i], &v[i]);
        if(w[i] > r) r = w[i];
        if(w[i] < l) l = w[i];
    }
    while(l < r) {
        mid = (l + r) >> 1;
        if(check(mid)) {
            ans = mid;
            r = mid;
        }
        else l = mid + 1;
    }
    if(ans!= -1) 
        printf("%d\n", ans);
    else printf ("No Solution!\n");
    return 0;
}
```
核心思想：先确定二分范围`l`和`r`，然后在循环中二分查找最小可行接口大小，`check`函数内部实现 01 背包验证可行性。

### 最优的关键思路或技巧
1. **二分查找与 01 背包结合**：利用二分查找的特性，快速缩小满足条件的接口大小范围，每次通过 01 背包算法验证当前接口大小是否可行，大大减少了枚举的时间复杂度。
2. **范围优化**：在二分查找中，通过记录文件大小的最值来精确确定二分的初始范围，减少不必要的计算，如`lzpclxf`题解中的做法。

### 可拓展之处
同类型题通常围绕背包问题与其他算法的结合，如二分查找、贪心算法等。类似算法套路包括：
1. **背包问题与二分答案**：当问题要求在满足一定条件下求某个最值时，可考虑二分答案，再结合背包算法验证可行性。
2. **背包问题与贪心策略**：在某些情况下，贪心策略能简化背包问题的求解，但需谨慎验证贪心的正确性。

### 推荐题目
1. **P2440 木材加工**：通过二分答案确定木材长度，结合贪心思想进行验证，与本题二分 + 验证的思路类似。
2. **P1048 采药**：经典的 01 背包问题，可作为基础练习，加深对 01 背包的理解。
3. **P1281 书的复制**：二分答案与动态规划结合的题目，与本题结合二分与背包的思路有相似之处。 

---
处理用时：40.76秒
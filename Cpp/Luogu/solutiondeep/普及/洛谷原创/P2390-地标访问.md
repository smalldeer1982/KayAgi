# 题目信息

# 地标访问

## 题目背景

改编自 USACO2007Nov 铜组 Exploration


## 题目描述

贝西在一条道路上旅行，道路上有许多地标，贝西想要在日落之前访问尽可能多的路标。将道路视为一条数轴，贝西从原点出发，道路上有 $n(1 \le n \le 5\times 10^4)$ 个地标，每个地标有一个坐标 $x_i(|x_i| \le 10^5)$ 且地标的坐标各不相同，$t(1 \le T \le 10^9)$ 分钟之后将会日落。

## 说明/提示

1、贝西日落时不用回到原点。

2、与原模拟水题不同。

3、数据较原题有所修改


## 样例 #1

### 输入

```
25 14
16
8
-7
3
10
-15
-17
6
-12
14
-13
2
9
-5
```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何在给定时间内让贝西访问最多地标展开，大部分采用二分答案的方法，少数使用前缀和等方式。二分答案的思路是利用访问路标数量的单调性质，二分能访问到的路标个数，通过判断函数确定该数量是否可行。各题解在细节处理和实现方式上有所不同，如判断函数中对不同走向情况的处理、坐标的分组与排序等。

### 所选的题解
- **作者：Egg_eating_master（5星）**
  - **关键亮点**：思路清晰，详细阐述了二分答案的原因及具体实现过程，对判断函数中不同情况的分析准确，代码简洁明了，注释详尽。
  - **个人心得**：无
  ```cpp
  bool check(int x){//判断函数，表示的是能否访问到x个路标
      for(int r=x;r<=n;r++){//枚举右端点
          int l=r-x+1;
          if(a[r]<=0)//如果右端点在原点左边，就要一直向左走
              if(-a[l]<=t)return 1;//根据题意判断即可，可以就直接返回true
          if(a[l]>=0)//如果左端点在原点右边，就要一直向右走
              if(a[r]<=t)return 1;//同上
          if(a[l]<=0&&a[r]>=0)//如果这段区间横跨了原点
              if(min(a[r],-a[l])+a[r]-a[l]<=t)return 1;//那么我一定是先去距离原点短的那一边，再走到另一边
      }
      return 0;//如果整个循环执行完，没有找到可行解，那就返回false
  }
  int main(){
      cin>>t>>n;
      for(int i=1;i<=n;i++)
          cin>>a[i];
      sort(a+1,a+1+n);//给所有路标位置排序
      int l=-1,r=n+1;//由于能访问的路标数量可能为0~n，所以把左边界设为1，右边界设为n+1，就可以保证二分到所有解
      while(l+1<r){//这里写l+1<r是为了防止最后l,r出现交叉的情况，即l>r
          int mid=(l+r)>>1;
          if(check(mid))l=mid;
          else r=mid;
          //更新l,r的值时写mid而不是mid+1或mid-1，也是为了防止最后l>r
      }
      cout<<l<<endl;最后输出l
      return 0;//Happy ending~
  } 
  ```
- **作者：hmya（4星）**
  - **关键亮点**：通过形象的图示和简单例子，清晰地解释了为什么贝西一定是访问一段区间内的所有地标，进而引出二分答案的思路，代码实现简洁，注释较为详细。
  - **个人心得**：无
  ```cpp
  bool check(int x){
      for(int i=x;i<=n;i++){//枚举右点
          int l=i-x+1;//推出左点
          if(a[i]<=0){//一条道走到黑的判断
              if(-a[l]<=t)return true;
          }
          if(a[l]>=0){//不撞南墙不回头的判断
              if(a[i]<=t)return true;
          }
          if(a[l]<=0&&a[i]>=0){//这里把另外两种情况和在了一起
              if(min(-a[l],a[i])+(a[i]-a[l])<=t)return true;
          }
      }
      return false;
  }
  int main(){
      scanf("%d%d",&t,&n);
      for(int i=1;i<=n;i++){
          scanf("%d",&a[i]);
      }
      sort(a+1,a+1+n);
      int lt=-1,rt=n+1;//记住，l一定要设置为-1，万一一个也访问不了捏？
      while(lt+1<rt){
          int mid=lt+(rt-lt)/2;//等价于（lt+rt）/2，但是这样一定爆不掉int
          if(check(mid)){
              lt=mid;//如果可行，就让l（ef）t过去，因为我们想让他越来越大
          }
          else{
              rt=mid;
          }
      }
      printf("%d",lt);//因为最后可行的mid被l（ef）t存起来了，so输出l（ef）t
      return 0;
  }
  ```
- **作者：幽灵特工（4星）**
  - **关键亮点**：提出理论复杂度最低的前缀和算法，详细解释了四种走法的思路及实现方式，代码通过前缀和数组优化，避免了二分带来的log复杂度。
  - **个人心得**：无
  ```cpp
  int main() {
      ios::sync_with_stdio(0);
      cin >> t >> n;
      int x;
      for (int i = 0; i < n; i++) {
          cin >> x;
          if (x < 0) {
              minn = min(minn, x);
              b[-x] = 1;//注意对负半轴的处理，数组下标应该非负。
          }
          else if (x >= 0) {
              maxn = max(maxn, x);
              a[x] = 1;
              if (x == 0)my_right[0] = 1;
          }
      }
      maxn = min(maxn, t);
      minn = max(minn, -t);
      for (int i = 1; i <= maxn; i++) {
          my_right[i] = my_right[i - 1] + a[i];
      }
      for (int i = -1; i >= minn; i--) {
          my_left[-i] = my_left[-(i + 1)] + b[-i];
      }
      for (int i = 1; i <= maxn; i++) {
          int other = t - 2 * i;//other是留给反方向剩余的时间
          other = other > 0? other : 0;
          other = other > -minn? -minn : other;
          ans = max(ans, my_right[i] + my_left[other]);
      }
      for (int i = -1; i >= minn; i--) {
          int other = t + 2 * i;
          other = other > 0? other : 0;
          other = other > maxn? maxn : other;
          ans = max(ans, my_left[-i] + my_right[other]);
      }
      cout << ans;
  }
  ```

### 最优关键思路或技巧
- **二分答案**：利用访问路标数量的单调性质，二分能访问到的路标个数，通过判断函数确定可行性，减少时间复杂度。
- **前缀和优化**：如幽灵特工的题解，通过前缀和数组记录正负半轴地标数量，在$O(n)$时间内计算四种走法可访问的地标数，达到理论最低复杂度。

### 可拓展之处
此类题目属于在一定限制条件下求最优解的问题，类似套路包括对具有单调性的答案进行二分，或利用前缀和等方式优化计算。同类型题可考虑在不同场景下，如二维平面等，求满足特定条件的最大数量或最值。

### 相似知识点洛谷题目
- [P1873 砍树](https://www.luogu.com.cn/problem/P1873)：二分答案，在给定木材需求下求合适的砍树高度。
- [P2678 [NOIP2015 提高组] 跳石头](https://www.luogu.com.cn/problem/P2678)：二分答案，确定满足最小跳跃距离限制下移除的最少石头数。
- [P3853 [TJOI2007] 路标设置](https://www.luogu.com.cn/problem/P3853)：二分答案，在公路上设置路标满足相邻路标距离限制下的最少路标数。 

---
处理用时：52.70秒
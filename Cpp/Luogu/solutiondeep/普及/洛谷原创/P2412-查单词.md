# 题目信息

# 查单词

## 题目背景

滚粗了的 HansBug 在收拾旧英语书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本英语书里面找到了一个单词表，包含 $N$ 个单词（每个单词内包含大小写字母）。现在他想要找出某一段连续的单词内字典序最大的单词。


## 说明/提示

### 样例说明

第一次操作：在{absi,hansbug,lzn,kkk,yyy}中找出字典序最大的，故为yyy

第二次操作：在{absi}中找出字典序最大的，故为absi

第三次操作：在{absi,hansbug}中找出字典序最大的，故为hansbug

第四次操作：在{hansbug,lzn}中找出字典序最大的，故为lzn

第五次操作：在{kkk}中找出字典序最大的，故为kkk

### 数据规模

 ![](https://cdn.luogu.com.cn/upload/pic/2274.png) 


## 样例 #1

### 输入

```
5 5
absi
hansbug
lzn
kkk
yyy
1 5
1 1
1 2
2 3
4 4```

### 输出

```
yyy
absi
hansbug
lzn
kkk
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效找出给定区间内字典序最大的单词展开。主要思路可分为以下几类：
1. **排序 + 模拟**：将单词排序并记录原始位置，查询时遍历排序后的数组，找到首个在查询区间内的单词。优点是思路简单，缺点是查询效率较低，时间复杂度在最坏情况下为O(n)。
2. **线段树**：用线段树维护区间内字典序最大的单词。建树时间复杂度为O(n)，查询时间复杂度为O(logn)。但由于字符串比较和常数问题，可能需要一些优化才能通过所有测试点。
3. **ST算法（ST表）**：通过预处理构建ST表，可在O(1)时间内查询区间最值。同样，字符串比较部分需处理好大小写问题。
4. **Trie树 + RMQ**：先将单词插入Trie树，通过DFS确定字典序，再用RMQ解决区间查询问题。

解决难点主要在于处理单词大小写不敏感的字典序比较，以及优化算法以避免超时。综合来看，使用线段树和ST算法在效率上更具优势，但需要注意常数优化；排序模拟法简单但效率有限。

### 所选的题解
- **作者：LightningUZ (赞：11)  星级：4星**
    - **关键亮点**：清晰讲解ST表原理及实现，代码简洁明了，对字符串大小写处理细致，在代码注释中强调容易犯错的点。
    - **重点代码**：
```cpp
void upr(char &x) {
    if ('a' <= x and x <= 'z') x -= 32;
}
string mx(string a, string b) {
    string x = a, y = b;
    for (int i = 0; i < a.size(); i++) upr(x[i]);
    for (int i = 0; i < b.size(); i++) upr(y[i]);
    return x > y? a : b;
}
string st[50100][30];
string ask(int l, int r) {
    int lc = log2(r - l + 1);
    return mx(st[l][lc], st[r - (1 << lc) + 1][lc]);
} 
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        char x[20];
        scanf("%s", x);
        st[i][0] = x;
    }
    for (int j = 1; (1 << j) <= n; j++) {
        for (int i = 1; i + (1 << (j - 1)) <= n; i++) {
            st[i][j] = mx(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
        }
    } 
    while (m--) {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%s\n", ask(l, r).c_str());
    }
    return 0;
} 
```
    - **核心实现思想**：通过`upr`函数将字符转为大写，`mx`函数比较两个字符串字典序（不区分大小写）。`st`数组构建ST表，`ask`函数利用ST表查询区间内字典序最大的单词。
- **作者：zhengrunzhe (赞：10)  星级：4星**
    - **关键亮点**：采用线段树解决问题，对线段树的结构定义、建树、查询过程详细，同时使用了多种优化手段，如字符数组代替`string`，`inline`、`register`关键字及读入优化。
    - **重点代码**：
```cpp
struct tree {
    int l, r;
    char s[15], ss[15]; 
}t[4 * N]; 
inline void read(reg int &x) {
    reg int out = 0; reg char ch = getchar();
    while (ch < 48 || ch > 57)ch = getchar();
    while (ch > 47 && ch < 58)
        out = out * 10 + ch - 48, ch = getchar();
    x = out;
}
inline void build(reg int l, reg int r, reg int k) {
    t[k].l = l; t[k].r = r;
    if (l == r) {
        scanf("%s", t[k].s);
        strcpy(t[k].ss, t[k].s);
        reg int len = strlen(t[k].s);
        for (i = 0; i < len; i++)
            t[k].s[i] = tolower(t[k].s[i]);
        return;
    }
    reg int mid = (l + r) >> 1;
    build(l, mid, lson);
    build(mid + 1, r, rson);
    if (strcmp(t[lson].s, t[rson].s) > 0) 
        strcpy(t[k].s, t[lson].s), strcpy(t[k].ss, t[lson].ss);
    else strcpy(t[k].s, t[rson].s), strcpy(t[k].ss, t[rson].ss);
}
inline int query(reg int l, reg int r, reg int k) {
    if (t[k].l > r || t[k].r < l)return 0;
    if (t[k].l >= l && t[k].r <= r)return k;
    reg int a = query(l, r, lson), b = query(l, r, rson);
    return strcmp(t[a].s, t[b].s) > 0? a : b;
}
```
    - **核心实现思想**：`tree`结构体定义线段树节点，包含区间信息以及原字符串和转换为小写后的字符串。`build`函数建树，将读入字符串转小写用于比较，同时保存原串。`query`函数查询区间内字典序最大单词对应的节点。
- **作者：YZL11111 (赞：0)  星级：4星**
    - **关键亮点**：使用线段树解决问题，对字符串比较函数进行重载优化，同时在查询时返回节点下标而非字符串，避免直接返回字符串带来的超时问题，还使用了读入优化。
    - **重点代码**：
```cpp
struct Tree {
    int l, r;
    string s;
}tree[2000010];
inline bool operator > (register const string& a, register const string& b) {
    register int la = a.length();
    register int lb = b.length();
    register int l = min(la, lb);
    for (register int i = 0; i < l; ++i) {
        register char c = tolower(a[i]);
        register char d = tolower(b[i]);
        if (c == d) continue;
        return c > d;
    }
    return la > lb;
}
inline void build(register int root, register int l, register int r) {
    tree[root].l = l;
    tree[root].r = r;
    if (l == r) {
        cin >> tree[root].s;
        return;
    }
    register int mid = (l + r) >> 1;
    build(root << 1, l, mid);
    build(root << 1 | 1, mid + 1, r);
    if (tree[root << 1].s > tree[root << 1 | 1].s) tree[root].s = tree[root << 1].s;
    else tree[root].s = tree[root << 1 | 1].s;
}
inline int query(register int root, register int l, register int r) {
    if (l <= tree[root].l && tree[root].r <= r) return root;
    register int mid = (tree[root].l + tree[root].r) >> 1;
    if (mid >= r) return query(root << 1, l, r);
    else if(mid < l) return query(root << 1 | 1, l, r);
    else {
        register int a = 0, b = 0;
        a = query(root << 1, l, mid);
        b = query(root << 1 | 1, mid + 1, r);
        return tree[a].s > tree[b].s? a : b;
    }
}
```
    - **核心实现思想**：`Tree`结构体定义线段树节点，包含区间和字符串信息。重载`>`运算符用于不区分大小写的字符串比较。`build`函数建树，`query`函数查询区间内字典序最大单词对应的节点下标。

### 最优关键思路或技巧
1. **数据结构选择**：对于区间最值查询问题，线段树和ST表是高效的数据结构。线段树灵活性高，可处理动态修改；ST表适合静态查询，查询效率极高（O(1)）。
2. **字符串处理**：为处理大小写不敏感的字典序比较，可在输入时将字符串统一转换为大写或小写，避免每次比较时临时转换带来的时间开销。
3. **常数优化**：在使用线段树时，避免直接存储`string`，可通过存储下标等方式减少空间和时间开销；使用`register`、`inline`关键字，以及快读快写等优化手段。

### 可拓展之处
此类题目属于区间最值查询的范畴，类似算法套路可应用于其他需要查询区间内最值（或满足某种比较关系）的问题，如区间内最大/最小数字、最长/最短子串等。同时，在处理字符串相关问题时，Trie树也是常用的数据结构，可用于前缀匹配、字典序相关问题等。

### 相似知识点洛谷题目
1. **P3865 【模板】ST表**：经典的ST表模板题，用于练习ST表的基本实现和应用。
2. **P3372 【模板】线段树 1**：基础线段树模板题，帮助理解线段树的基本结构和操作。
3. **P2824 [HEOI2016/TJOI2016]排序**：涉及到对序列的操作和查询，可通过线段树等数据结构优化解决，锻炼对数据结构的综合运用能力。

### 个人心得摘录与总结
- **作者：有素质的2B铅笔**：一开始未注意题目中大小写不敏感但需输出原单词的要求，导致提交爆零，强调了仔细读题的重要性。
- **作者：Lates**：因理解错字典序（未考虑忽略大小写），多次提交才通过，同样突出读题准确性的关键。 

---
处理用时：69.75秒
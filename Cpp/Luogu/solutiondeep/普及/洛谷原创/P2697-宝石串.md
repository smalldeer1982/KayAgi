# 题目信息

# 宝石串

## 题目描述

有一种宝石串，由绿宝石和红宝石串成，仅当绿宝石和红宝石数目相同的时候，宝石串才最为稳定，不易断裂。安安想知道从给定的宝石串中，可以截取一段最长的稳定的宝石串，有多少颗宝石组成。请你帮助他。

绿宝石用 $\texttt G$ 表示，红宝石用 $\texttt R$ 表示。


## 说明/提示

$\texttt {RGGR}$ 为答案。

宝石数小于等于 $10^6$。


## 样例 #1

### 输入

```
GRGGRG```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找宝石串中最长稳定子串展开，思路和方法多样，包括暴力枚举、前缀和、二分查找等。暴力枚举法直接遍历所有子串判断是否稳定，实现简单但时间复杂度高，如“2311241987j”“prefer”“白鹰”“Miri”“bie淖_kkk”“无名ZWH”的题解；前缀和法将宝石用数字表示，通过前缀和数组判断子串稳定性，部分题解还利用哈希表优化，时间复杂度为O(n)，是较优解法，如“在想Peach”“MloVtry”“altar”“Henry_he”“daniel14311531”“无名ZWH”“Eric_hoo”“Victorique”“LGNN”“Meatherm”的题解；二分查找法通过二分答案长度并验证可行性来求解，时间复杂度为O(|S|log|S|)，如“peterwuyihong”“_•́へ•́╬_”的题解；还有“Terrible”采用栈和贪心合并的独特方法，实现复杂但有一定创新性。

综合质量来看，以下3个题解在思路清晰度、代码可读性和优化程度上表现较好：
1. **作者：在想Peach（60赞）**
    - **星级**：5星
    - **关键亮点**：思路清晰，利用前缀和思想，将宝石串转化为差的数列，通过记录差的最早出现位置来求解最长稳定子串，代码简洁高效。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
using namespace std;
string s;
int ans,p[2000005],last=1000000;
int main()
{
    cin>>s;
    for(int i=1;i<=s.length();i++){
        if(s[i - 1]=='R')last++;
        else last--;
        if(!p[last])p[last]=i;
        else ans=max(ans,i - p[last]);
        if(last==1000000)ans=i;
    }
    cout<<ans<<endl;
}
```
    - **核心思想**：将绿宝石视为 -1，红宝石视为1，计算前缀和的差，用数组`p`记录差的最早出现位置，每次更新`ans`为当前位置与最早位置的差值的最大值。
2. **作者：MloVtry（39赞）**
    - **星级**：5星
    - **关键亮点**：同样基于前缀和思想，清晰阐述将G设为 -1、R设为1，通过维护前缀和数组及记录每个值首次出现位置来求解，代码逻辑清晰。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1000010
#define inf 1<<30
using namespace std;
int f[N],n,ans;
int num[2*N];
char a[N];
int main()
{
    scanf("%s",a + 1);
    n=strlen(a + 1);
    for(int i=1;i<=n;++i)
    {
        if(a[i]=='G') f[i]-=1;
        if(a[i]=='R') f[i]+=1;
    }
    for(int i=1;i<=2*n+2;++i) num[i]=inf;
    num[0+n+1]=0;
    for(int i=1;i<=n;++i)
    {
        f[i]+=f[i - 1];
        num[f[i]+n+1]=min(i,num[f[i]+n+1]);
        ans=max(ans,i - num[f[i]+n+1]);
    }
    printf("%d",ans);
    return 0;
}
```
    - **核心思想**：先给宝石赋值，计算前缀和`f`，用`num`数组记录每个前缀和值最早出现位置，通过当前位置与最早位置差值更新`ans`。
3. **作者：altar（16赞）**
    - **星级**：4星
    - **关键亮点**：详细解释前缀和数组的构建及利用其判断稳定子串的过程，对数组下溢问题处理清晰。
    - **个人心得**：提到注意数组越界问题。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

char a[3000001] ;
int ans, l, sum [3000001],bo[3000001] ;

int main()
{
    scanf ("%s",a + 1 );
    l = strlen(a + 1) ;
    for (int i = 1 ; i <= l ; i ++ ){
        sum[i] = sum[i - 1] + ( a[i] == 'R'? 1 : -1);
        if (!bo[sum[i] + 1000001] && sum[i]) bo[sum[i]+1000001] = i ;
        else ans = max (ans, i - bo[sum[i]+1000001]) ;
    }
    printf ("%d",ans) ;
    return 0 ;
}
```
    - **核心思想**：构建前缀和数组`sum`，用`bo`数组记录`sum`值首次出现位置，通过当前位置与`bo`中位置差值更新`ans`，注意加常数防止数组下溢。

### 最优关键思路或技巧
前缀和法是较优思路，将宝石赋予数值转化为前缀和问题，通过记录相同前缀和的最早位置，快速找到最长稳定子串。利用哈希表或数组记录前缀和值及其位置，能优化查找过程，降低时间复杂度。

### 可拓展思路
此类题目属于字符串子串统计问题，类似套路是将字符转化为数值，通过前缀和、哈希等方法优化查找。同类型题可考虑子串和、子串匹配等问题，如在字符串中找和为特定值的子串。

### 洛谷相似题目
1. **P1115 最大子段和**：与本题类似，通过前缀和思想解决最大子段和问题。
2. **P3957 [NOIP2017 普及组] 跳房子**：涉及前缀和优化动态规划问题，与本题前缀和思路相关。
3. **P1990 覆盖墙壁**：虽形式不同，但同样是通过一定的状态记录和转移来求解，可类比本题思路。

### 个人心得摘录与总结
1. **altar**：提到注意数组越界问题，在处理前缀和数组及辅助数组时，要合理设置数组大小，防止下溢或上溢。
2. **Meatherm**：指出暴力枚举时的剪枝技巧，如从`i + maxx + 1`开始循环、步长设为2，同时注意循环中避免多次调用耗时函数。这些技巧可在暴力算法基础上优化时间复杂度。 

---
处理用时：43.33秒
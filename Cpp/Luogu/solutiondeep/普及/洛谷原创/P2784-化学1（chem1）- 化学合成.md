# 题目信息

# 化学1（chem1）- 化学合成

## 题目背景

蒟蒻 HansBug 在化学考场上，挠了无数次的头，可脑子里还是一片空白。

## 题目描述

眼下出现在蒟蒻 HansBug 面前的是一个化学合成题，据他所知，一般答案如下面这样的格式：

![](https://cdn.luogu.com.cn/upload/pic/2223.png) （接下一行）

![](https://cdn.luogu.com.cn/upload/pic/2221.png) 

简单解释下：每种化合物可以通过一步反应生成另一个化合物（将这称作一步反应，设为 $A\rightarrow B$），现在假设每个 $A\rightarrow B$ 中，理论上 $1$ 个单位的 $A$ 都仅可以生成 $1$ 个单位的 $B$。然而实际实验表明，并不存在绝对完全的化学转化，设转化率为 $C$（即 $1$ 个单位 $A$ 实际可以生成 $C$ 个单位的 $B$，$0<C<1$）。

现在蒟蒻 HansBug 的知识体系中有 $N$ 个这样 $A\rightarrow B$ 的转化。然而题目中蒟蒻 HansBug 要由 $1$ 个单位的化合物 $S$ 生成化合物 $T$，可是他脑细胞和 RP 已经消耗殆尽，所以找到最终产量最高的合成路线的艰巨任务就交给你啦！

## 说明/提示

样例 1 和样例 2 中，两条合成路线分别为 $1\rightarrow3$、$1\rightarrow2$、$2\rightarrow3$，产率分别为 $0.8$、$0.9$、$0.9$。

在样例 1 中，有两种可行的路线 $1\rightarrow3$ 和 $1\rightarrow2\rightarrow3$ ，最终产量分别为 $0.8$、$0.9\times0.9=0.81$，故第二条路线更优，产量为 $0.8100$。

样例 2 中，$2$ 只能生成 $3$，$3$ 无法生成别的化合物，故无法生成，蒟蒻 HansBug 只好选择 `orz`。

**【数据范围】**

![](https://cdn.luogu.com.cn/upload/pic/2220.png)


## 样例 #1

### 输入

```
3 3 1 3
1 3 0.8
1 2 0.9
2 3 0.9
```

### 输出

```
0.8100```

## 样例 #2

### 输入

```
3 3 2 1
1 3 0.8
1 2 0.9
2 3 0.9
```

### 输出

```
orz```

# AI分析结果

• 综合分析与结论：
  本题要求在给定的化学合成反应关系（有向图）中，从化合物S生成化合物T，找到产量最高的合成路线，实质是求有向图的最长路问题。各题解主要使用了Dijkstra、SPFA算法，部分提到Bellman - Ford算法，也有使用BFS搜索。
  - **思路**：将化合物视为图的节点，反应视为有向边，转化率作为边权，通过特定算法找出从起点S到终点T的最长路径。
  - **算法要点**：
    - **Dijkstra**：把点分为已确定和未确定最短路（本题为最长路）的集合，每次从后者中选距离最小（本题为最大）的点加入前者，并对其出边松弛。可使用优先队列优化。
    - **SPFA**：用队列维护可能引起松弛操作的点，仅访问必要的边，通过不断松弛更新距离。
    - **Bellman - Ford**：基于松弛操作，循环n - 1次对所有边松弛，可处理负权边。
  - **解决难点**：需将常规最短路算法中的比较操作（如min改max）和距离更新方式（如加改乘）进行调整以适应最长路及题目要求；注意数据范围，避免使用邻接矩阵导致内存溢出。

  综合质量来看，XiaoX、Diamiko、幽灵特工的题解相对较好。

• 所选的题解：
  - **XiaoX（5星）**：
    - **关键亮点**：采用堆优化的Dijkstra算法，思路清晰，代码简洁且有详细注释，对坑点有提示。
    - **个人心得**：提到第2个点960ms，暗示算法在某些数据下效率问题。
    ```cpp
    void dij(int st){
        for(int i=1;i<=n;i++) d[i]=-1;
        priority_queue<kk>q;
        d[st]=1;q.push(make_pair(1,st));
        while(q.size()){
            int x=q.top().second;q.pop();
            if(v[x]) continue;v[x]=1;
            for(int i=head[x];i;i=e[i].nxt){
                int y=e[i].ver;
                if(d[x]*e[i].w>d[y]){
                    d[y]=d[x]*e[i].w;
                    q.push(make_pair(d[y],y));
                }
            }
        }
    }
    ```
  - **Diamiko（4星）**：
    - **关键亮点**：使用SPFA算法求最长路，清晰阐述对SPFA模板的修改要点，代码结构清晰。
    ```cpp
    void SPFA()
    {
        queue<int>q;
        for(int i=1;i<=n;i++)
        {
            node[i].dis=-0x3f3f3f3f;
            node[i].vis=0;
        }
        node[s].dis=1;
        node[s].vis=1;
        q.push(s);
        while(q.size())
        {
            int u=q.front();
            q.pop();
            node[u].vis=0;
            for(int e=node[u].head;e;e=edge[e].next)
            {
                int v=edge[e].to;
                if(node[v].dis<node[u].dis*edge[e].len)
                {
                    node[v].dis=node[u].dis*edge[e].len;
                    if(!node[v].vis)
                    {
                        q.push(v);
                        node[v].vis=1;
                    }
                }
            }
        }
    }
    ```
  - **幽灵特工（4星）**：
    - **关键亮点**：详细讲解多种图算法，包括边集数组存图、Bellman - Ford、SPFA、Dijkstra，对各算法原理和实现有清晰描述，提供SPFA代码。
    ```cpp
    void SPFA() {
        for (int i = 1; i <= n; i++)dist[i] = -1;
        dist[s] = 1.00;
        q.push(s);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            in_queue[u] = 0;
            for (int i = 0; i < G[u].size(); i++) {
                int v = e[G[u][i]].to;
                if (dist[v] < dist[u] * e[G[u][i]].w) {
                    dist[v] = dist[u] * e[G[u][i]].w;
                    if (!in_queue[v]) { q.push(v); in_queue[v] = 1; }
                }
            }
        }
    }
    ```

• 最优关键思路或技巧：
  - **算法选择**：根据题目数据范围和性质，选择合适的图算法。如本题无负权，可使用Dijkstra或SPFA，数据范围大避免邻接矩阵。
  - **算法调整**：将最短路算法中的距离更新方式（加改乘）和比较操作（min改max）调整以适应最长路问题。

• 可拓展之处：
  - **同类型题**：涉及图的最长路、最短路问题，如物流运输路线规划、网络延迟优化等场景。
  - **类似算法套路**：掌握图的不同存储方式（邻接表、边集数组等）及常见图算法（Dijkstra、SPFA、Bellman - Ford）的适用场景和优化方法。

• 推荐题目：
  - P3371 【模板】单源最短路径（弱化版）：单源最短路模板题，可熟悉Dijkstra等算法。
  - P4779 【模板】单源最短路径（标准版）：更复杂的单源最短路问题，需考虑更多情况。
  - P1339 热浪：求最短路问题，可锻炼对图算法的应用能力。

• 个人心得摘录与总结：
  - **XiaoX**：提到算法在第2个点960ms，暗示Dijkstra算法在某些数据下效率可能不佳，反映出实际做题中需关注算法效率。 

---
处理用时：39.02秒
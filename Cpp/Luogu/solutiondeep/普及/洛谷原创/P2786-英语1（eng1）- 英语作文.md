# 题目信息

# 英语1（eng1）- 英语作文

## 题目背景

蒟蒻 HansBug 在英语考场上，挠了无数次的头，可脑子里还是一片空白。

## 题目描述

眼下出现在 HansBug 蒟蒻面前的是一篇英语作文，然而智商捉急的 HansBug 已经草草写完了，此时他发现离考试结束还有 $40$ 分钟，于是他打算估计一下这篇共有 $M$ 个单词的英语作文的含金量如何。众所周知的是，在中高考英语作文中使用高级词汇可以有效提高文章的含金量，从而获得更好的分数。已知蒟蒻HansBug知道 $N$ 个高级词汇，该词汇为 $A_i$（词汇长度为 $L_i$ ，包含数字、大小写字母），该高级词汇的含金量为 $B_i$，则该高级词汇每出现一次便可增加 $B_i$ 的含金量。可是他脑细胞和 RP 已经消耗殆尽，所以这个伟大的任务就交给你啦！

## 说明/提示

样例 $1$ 中，共计出现了 $2$ 次`hansbug`、 $2$ 次`absi2011` 、 $1$ 次 `yyy` 、 $1$ 次`kkksc03`、 $1$ 次  `lzn` ，所以总含金量为 $1\times2+2\times4+3\times1+4\times1+100\times1=115$，对 $99$ 取模就是 $16$ 。

样例 $2$ 中，和样例 $1$ 基本一样，值得注意的是整体的 `yyyy` 不可以被认为是 `yyy` 出现 $2$ 次，请注意这是一篇英语作文，一切以单词为最小单位。

此题目中大小写敏感。

数据范围（设所有单词的最大长度为 $Lmax$ ）：

![](https://cdn.luogu.com.cn/upload/pic/2228.png)


## 样例 #1

### 输入

```
5 99
hansbug 1
kkksc03 2
yyy 3
absi2011 4
lzn 100
hansbug is a juruo!but absi2011 not.!?!
one day absi2011 laughed at yyy and hansbug.
then kkksc03 and lzn blamed him for that.
```

### 输出

```
16```

## 样例 #2

### 输入

```
5 99
yyyy 1
kkksc03 2
yyy 3
absi2011 4
lzn 100
yyyy is a juruo!but absi2011 not.!?!
one day absi2011 laughed at yyy and yyyy.
then kkksc03 and lzn blamed him for that.
```

### 输出

```
16```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效统计英语作文中高级词汇的含金量展开。多数题解使用了`map`、哈希表等数据结构，少数采用替罪羊树、Trie树等。主要思路是将高级词汇及其含金量存储在特定数据结构中，然后遍历作文中的单词，在数据结构中查找并累加对应含金量。

难点在于如何处理输入的单词分隔符以及优化查找效率以避免超时。使用`map`可简化代码实现，哈希表虽能提高查找效率，但需解决哈希冲突问题。Trie树理论上适用，但容易内存超限。替罪羊树相对小众，实现稍复杂。

### 所选题解
1. **作者：Diamiko（5星）**
    - **关键亮点**：思路清晰，代码简洁。使用`std::map`存储高级词汇及其含金量，遍历输入字符，通过判断字符是否为字母或数字来确定单词边界，进而统计单词的含金量。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<iostream>
#include<map>
#include<string>
#include<cstring>
#include<cstdio>
using namespace std;
typedef long long ll;
ll n,p;
map<string,ll>a;
ll ans;
int main()
{
    scanf("%lld%lld",&n,&p);
    for(int i=1;i<=n;i++)
    {
        string word;
        ll value;
        cin>>word>>value;
        a[word]=value;
    }
    string t="";
    char c;
    while(scanf("%c",&c)!=EOF)
    {
        if(!(isdigit(c)||isalpha(c)))
        {
            ans=((ans%p)+(a[t]%p))%p;
            t="";
        }
        else t+=c;
    }
    printf("%lld\n",ans);
    return 0;
}
```
    - **核心思想**：先读入高级词汇及其含金量存入`map`，再逐字符读入作文内容，非字母和数字字符作为单词结束标志，更新答案并重置单词存储变量。

2. **作者：BackSlashDelta（4星）**
    - **关键亮点**：采用哈希 + 二分查找的方法。对每个高级词汇取哈希值并排序，通过二分查找文本中单词的哈希值，同时解决了哈希冲突问题。
    - **个人心得**：原本使用哈希 + 暴力查找导致TLE，意识到暴力方法效率低。
    - **核心代码**：
```cpp
ulint base = 8394824858985499411; 
ulint seed_1 = 5005454853518058551; 
ulint seed_2 = 3602030550927995261;
inline ulint hashit(string s)
{
    int l = s.size();
    ulint val = 0;
    for (int i = 0; i < l; i++)
    {
        val = s[i] * base + (val ^ seed_1);
        val ^= seed_2;
    }
    return val;
}
inline int bnrysrch(int l, int r, ulint key)
{
    int ret = -1;
    int mid;
    while (l <= r)
    {
        mid = l + ((r - l) >> 1);
        if (word[mid].hsh < key)
        {
            l = mid + 1;
        }
        else if (word[mid].hsh > key)
        {
            r = mid - 1;
        }
        else
        {
            ret = mid;
            ans += word[ret].val;
            ans %= MOD;
            break;
        }
    }
    return ret;
}
```
    - **核心思想**：定义哈希函数对单词进行哈希计算，二分查找函数根据哈希值在已排序的结构体数组中查找单词并更新答案。

3. **作者：little_gift（4星）**
    - **关键亮点**：使用`fread` + `pbds`实现高效输入与查找。利用`__gnu_pbds::tree`将高级词汇映射到含金量，通过`fread`快速读取输入，按单词处理并查找计算含金量。
    - **个人心得**：无
    - **核心代码**：
```cpp
__gnu_pbds::tree < string, int > mm; 
__gnu_pbds::tree < string, int > :: iterator it; 
int main()
{
    fread(ri, 1, ri_top, stdin); 
    read_int(n);
    read_int(p);
    for (register int i = n + 1; --i; )
    {
        read_st(st);
        read_int(x);
        mm[st] = x; 
    }
    while (*rich)
    {
        while (*rich && (ch = *(rich++),!isalpha(ch) &&!isdigit(ch)));
        if (!*rich) break;
        st1 = st;
        for (*st1 = ch; ch = *(rich++), isalpha(ch) || isdigit(ch); *(++st1) += ch);
        *(++st1) = '\0'; 
        it = mm.find(st); 
        if (it!= mm.end()) 
            s = (s + it -> second % p) % p; 
    }
    printf("%d\n", s);
}
```
    - **核心思想**：先通过`fread`读入数据，将高级词汇和含金量存入`__gnu_pbds::tree`，再按单词读取后续输入，查找并累加对应含金量。

### 最优关键思路或技巧
- **数据结构选择**：`map`简单易用，自带红黑树结构保证查找效率，适用于数据量不大的情况；哈希表理论上查找效率更高，但需解决哈希冲突问题，如采用多次异或运算等方法。
- **输入处理**：逐字符读取输入，通过判断字符类型确定单词边界，避免复杂的字符串分割操作。

### 可拓展思路
同类型题常考察字符串处理与高效查找，类似算法套路是选择合适的数据结构存储数据，优化查找过程。如处理大量字符串匹配问题，可考虑Trie树优化，但要注意空间消耗；也可使用哈希表结合开放地址法或链地址法解决冲突。

### 相似知识点洛谷题目
- **P3370 【模板】字符串哈希**：通过字符串哈希解决字符串匹配问题。
- **P2580 [ZJOI2006] 书架**：涉及字符串处理和数据结构操作。
- **P1308 [NOIP2011 普及组] 统计单词数**：统计单词出现次数，考察字符串查找与处理。

### 个人心得摘录与总结
- **BackSlashDelta**：从哈希 + 暴力查找TLE的经历中，认识到暴力方法在面对大数据时效率低下，进而改进为哈希 + 二分查找，体现了优化算法对解决问题的重要性。 

---
处理用时：42.00秒
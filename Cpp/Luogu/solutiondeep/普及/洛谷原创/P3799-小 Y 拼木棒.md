# 题目信息

# 小 Y 拼木棒

## 题目背景

上道题中，小 Y 斩了一地的木棒，现在她想要将木棒拼起来。

## 题目描述

有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？

答案对 $10^9+7$ 取模。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 5 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，$1 \le a_i \le 5 \times 10^3$。

关于标题：因为一些不可抗力的原因，名称进行了更改。深表歉意。

## 样例 #1

### 输入

```
4 
1
1
2
2```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均基于组合数学，利用桶计数记录各长度木棒的数量，通过两层循环枚举来计算组成正三角形的方案数。外层循环枚举两根相等木棒的长度，内层循环枚举另外两根木棒的长度组合。解决难点在于如何避免重复计算以及正确运用组合数公式。
各题解在思路清晰度、代码可读性和优化程度上存在差异。部分题解详细阐述了思路和算法，代码注释丰富；部分题解则较为简略。

### 所选的题解
- **作者：灵乌路空 (赞：298)**  星级：5星
    - **关键亮点**：思路阐述极为清晰，从分析题意、感性理解到算法分析，逐步深入讲解。代码注释详细，对组合数计算采用特判写法简化运算。
    - **个人心得**：无
    - **核心代码**：
```cpp
ll C(ll x, ll k) { 
  return (k == 1ll? x : x * (x - 1ll) / 2ll) % kMod;
}
int main() {
  scanf("%lld\n", &n);
  for (int i = 1; i <= n; ++ i) { 
    scanf("%lld", &a[i]); 
    maxa = max(a[i], maxa);
    num[a[i]] ++;
  }

  for (int i = 2; i <= maxa; ++ i) { 
    if (num[i] >= 2ll) {
      ll times = C(num[i], 2ll) % kMod; 
      for (int j = 1; j <= i / 2; ++ j) { 
        if (j!= i - j && num[j] >= 1 && num[i - j] >= 1) 
          ans += times * C(num[j], 1) * C(num[i - j], 1) % kMod;
        if (j == i - j && num[j] >= 2) 
          ans += times * C(num[j], 2) % kMod;
        ans %= kMod;
      }
    }
  }
  printf("%lld", ans);
  return 0;
}
```
    - **核心实现思想**：`C`函数计算组合数。主函数中先读入数据并统计各长度木棒数量，然后两层循环枚举，根据另外两根木棒长度是否相等，分别计算方案数并累加，过程中注意取模。
- **作者：zhangziyi_xshsnoi (赞：67)** 星级：4星
    - **关键亮点**：先介绍组合数学知识，对$C_n^2$公式进行推导。代码简洁明了，核心代码部分逻辑清晰。
    - **个人心得**：无
    - **核心代码**：
```cpp
for(int i=Min+1;i<=Max;i++)
	{
		if(num[i]>=2)
		{
			for(int j=Min;j<=i/2;j++)
			{
				if(j!=i-j)
					ans+=num[i]*(num[i]-1)*num[j]*num[i-j]/2%mod;
				else if(num[j]>=2&&j*2==i)
					ans+=num[i]*(num[i]-1)*num[i/2]*(num[i/2]-1)/4%mod;
			}
			ans%=mod;
		}
	}
```
    - **核心实现思想**：外层循环从大于最小长度处开始枚举两根相等木棒的长度，若该长度木棒数量不少于2，则内层循环枚举另外两根木棒长度，根据其是否相等计算方案数并累加，同时取模。
- **作者：RemiliaScar1et (赞：13)** 星级：4星
    - **关键亮点**：思路表述清晰，通过设木棒长度关系得出枚举条件。使用带参宏定义简化组合数计算，代码整体简洁。
    - **个人心得**：无
    - **核心代码**：
```cpp
#define c1(a) (a) 
#define c2(a) ((a)*((a)-1)/2)
int main()
{
    int ans=0;
    for(int a=2;a<=5000;a++)
   {
        for(int c=1;c<=a/2;c++)
        {
            int d=a-c;
            if(d!=c&&aaa[a]>=2&&aaa[c]>=1&&aaa[d]>=1)
            {
                ans+=((c2(aaa[a])%mode)*(c1(aaa[c])%mode)*(c1(aaa[d])%mode))%mode;
            }
            else if(d==c&&aaa[a]>=2&&aaa[c]>=2)
            {
                ans+=((c2(aaa[a])%mode)*(c2(aaa[c])%mode))%mode;
            }
            ans%=mode;
        }
    }
    cout<<ans%mode;
    return 0;
}
```
    - **核心实现思想**：利用宏定义`c1`和`c2`分别表示$C_n^1$和$C_n^2$。两层循环枚举，根据另外两根木棒长度关系计算方案数并累加，每次计算后取模。

### 最优关键思路或技巧
- **桶计数优化枚举**：利用桶数组记录各长度木棒数量，将对木棒的枚举转化为对长度的枚举，降低时间复杂度。
- **组合数简化计算**：针对本题只涉及$C_n^1$和$C_n^2$的情况，通过简单数学推导直接在代码中以乘法形式计算，避免复杂的组合数函数调用。
- **内层循环范围控制**：在内层循环枚举另外两根木棒长度时，将范围控制在$j\leq i/2$，有效避免重复计算。

### 可拓展思路
此类题目属于组合计数类型，常见拓展方向为改变图形形状（如拼成矩形、等腰三角形等）或改变选取元素数量。通用思路是分析图形构成条件，转化为数学关系，利用合适的数据结构（如桶）辅助枚举和计数。

### 相似知识点洛谷题目
- [P1313 计算系数](https://www.luogu.com.cn/problem/P1313)：考察组合数学和快速幂。
- [P2822 [NOIP2016 提高组] 组合数问题](https://www.luogu.com.cn/problem/P2822)：涉及组合数取模和前缀和优化。
- [P3197 [HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197)：通过组合数学计算方案数。 

---
处理用时：39.77秒
# 题目信息

# [MtOI2019] 膜Siyuan

## 题目背景

你强归你强，$\mathsf S\mathsf{\color{red} iyuan}$ 比你强。——$\mathsf S \mathsf{\color{red} iyuan}$

disangan233 最近发现了一款 OIer 们的游戏：[膜 $\color{black} \mathsf S \mathsf{\color{red} iyuan}$](https://lmoliver.github.io/mosiyuan/index.html)。

他被里面的「真理 IV」所困惑，于是他找到了你寻求帮助。


## 题目描述

给你 $1$ 个正整数 $M$，$n(n\leq 5)$ 个正整数 $3$ 元组 $\{a_i,b_i,c_i\}(a_i,b_i,c_i\leq M\leq 2000)$，请你求出所有满足

$$
\forall i\leq n ,s.t.~|a_i-x|\oplus |b_i-y|\oplus |c_i-z| = 9
$$

的**有序**正整数 $3$ 元组 $\{x,y,z\}(x,y,z \leq M)$的个数。

其中，$\forall$ 表示 "对于所有"，$s.t.$ 表示 "使得"，$A \oplus B \oplus C$ 表示 $A,B,C$ 的异或和。

对于 C++，`A^B^C` 或 `A xor B xor C` 即为 $A \oplus B \oplus C$ 的答案 。

这里提供一份模板：

```cpp
if ((a ^ b ^ c) == 9) 
{
	Your code here...
}
```

对于 $2$ 个有序 $3$ 元组 $A,B$，如果 $x_A \not =x_B$ 或 $y_A \not =y_B$ 或 $z_A \not =z_B$，$A,B$ 即被视为是不同的。


## 说明/提示

#### 样例解释 $1$

所有满足条件的 $\{x,y,z\}$ 有： 

$\{88,88,120\}$，$\{88,104,104\}$，$\{120,120,120\}$ 和 $\{120,136,104\}$。

共 $4$ 个。

### 子任务

对于 $10\%$ 的数据，保证与样例完全一致。

对于 $60\%$ 的数据，保证 $M\leq 200$。

对于所有数据，保证 $a_i,b_i,c_i\leq M\leq 2000$，$n\leq 5$。


### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22614) T2

出题人：disangan233

验题人：Studying Father


## 样例 #1

### 输入

```
5 200
21 84 198
38 47 102
44 47 132 
63 150 166
76 79 132```

### 输出

```
4```

# AI分析结果

• 综合分析与结论：
    - 思路方面：所有题解都提到了暴力枚举思路，即枚举\(x,y,z\)判断是否满足条件，时间复杂度\(O(M^3n)\)，期望得分\(60\)分。优化思路是利用异或运算性质，通过枚举\(x,y\)，根据\(\vert a_i - x\vert \oplus \vert b_i - y\vert \oplus 9 = \vert c_i - z\vert\)计算\(z\)可能的值（\(z = c_i \pm (\vert a_i - x\vert \oplus \vert b_i - y\vert \oplus 9)\)），再代入其他组数据判断是否满足条件，将时间复杂度降为\(O(M^2n)\)从而得到满分。
    - 算法要点：需掌握异或运算的交换律、结合律、自反性等性质，利用这些性质推导方程求解\(z\)。同时要注意对\(z\)值范围（\(1\leq z\leq M\)）的判断以及可能出现的\(z\)的两个解相同的去重情况。
    - 解决难点：主要难点在于想到利用异或运算性质优化枚举，将三重循环降为两重循环。同时在实现过程中要正确处理绝对值方程求解\(z\)以及\(z\)值的合法性判断和去重。

• 所选的题解：
  - 作者：Hexarhy (4星)
    - 关键亮点：思路清晰，先详细阐述异或运算性质并证明，再基于此说明优化算法过程，对实现细节也有清晰描述。
    - 个人心得：无
    - 核心代码：
```cpp
void solve(void)
{
    for(int x=1;x<=m;x++)
        for(int y=1;y<=m;y++)
        {
            const int t=abs(x-a[1])^abs(y-b[1])^9;
            const int z1=c[1]+t;
            const int z2=c[1]-t;
            bool f1=(0<z1 && z1<=m),f2=(0<z2 && z2<=m);
            for(int i=2;i<=n;i++)
            {
                if((abs(x-a[i])^abs(y-b[i])^abs(z1-c[i]))!=9)
                    f1=false;
                if((abs(x-a[i])^abs(y-b[i])^abs(z2-c[i]))!=9)
                    f2=false;
            }
            ans=ans+f1+f2;
            if(z1==z2)
                ans--;
        }
}
```
核心实现思想：先枚举\(x,y\)，根据第一组数据计算\(z1,z2\)，判断其是否在合法区间，再代入其他组数据验证，统计满足条件的解的数量，同时处理\(z1 = z2\)的去重情况。
  - 作者：StudyingFather (4星)
    - 关键亮点：作为验题人，对题目难度定位清晰，算法讲解简洁明了，代码简洁且注释清晰。
    - 个人心得：无
    - 核心代码：
```cpp
for(int i=1;i<=m;i++)
    for(int j=1;j<=m;j++)
    {
        int tmp=abs(i-p[1].a)^abs(j-p[1].b)^9;
        int res1=p[1].c+tmp,res2=p[1].c-tmp;
        int flag1=(res1>0&&res1<=m),flag2=(res2>0&&res2<=m);
        for(int k=2;k<=n;k++)
        {
            if((abs(i-p[k].a)^abs(j-p[k].b)^abs(res1-p[k].c))!=9)flag1=false;
            if((abs(i-p[k].a)^abs(j-p[k].b)^abs(res2-p[k].c))!=9)flag2=false;
        }
        if(res1==res2)flag2=false;
        ans+=flag1+flag2;
    }
```
核心实现思想：同样是枚举\(x,y\)，根据第一组数据得出\(z\)的两个可能值\(res1,res2\)，判断其范围，再代入其余组数据验证，统计满足条件的解，处理相同解的情况。
  - 作者：zjy111 (4星)
    - 关键亮点：结合游戏背景阐述题意，形象生动，对异或运算性质结合题目分析到位，代码虽风格奇特但关键步骤注释清晰。
    - 个人心得：无
    - 核心代码：
```cpp
for(r int x=1;x<=m;++x){
    for(r int y=1;y<=m;++y){
        int t=0,tmp=(abs(a[1]-x)^abs(b[1]-y)),qwq=tmp^9,z1=c[1]-qwq,z2=c[1]+qwq,flg1=1,flg2=1;
        if(z1<=0 || z1>m)flg1=0;
        if(z2<=0 || z2>m)flg2=0;
        if(flg1)
            for(r int i=2;i<=n;++i)
                if((abs(a[i]-x)^abs(b[i]-y)^abs(c[i]-z1))!=9){flg1=0;break;}
        if(flg2)
            for(r int i=2;i<=n;++i)
                if((abs(a[i]-x)^abs(b[i]-y)^abs(c[i]-z2))!=9){flg2=0;break;}
        orzsiyuan+=flg1+flg2;
        if(!qwq && flg1 && flg2)--orzsiyuan;
    }
}
```
核心实现思想：枚举\(x,y\)，通过第一组数据计算\(z1,z2\)，判断其合法性，再代入其他组验证，统计满足条件的解，对\(z1 = z2\)的情况进行去重。

• 最优的关键思路或技巧：利用异或运算的性质（交换律、结合律、自反性等），将原方程变形，通过枚举两个变量，计算出第三个变量的可能值，从而优化枚举过程，降低时间复杂度。同时在代码实现中，要细致处理计算结果的范围判断和去重问题。

• 可拓展之处：同类型题通常围绕位运算与方程求解结合，类似算法套路是分析给定方程中运算符的性质，通过变形方程减少枚举维度。例如对于其他含有位运算（如与、或等）的方程求解问题，也可尝试利用其运算性质优化枚举。

• 推荐题目：
  - P1514 引水入城：涉及位运算与逻辑判断，可锻炼对复杂条件下利用位运算优化算法的能力。
  - P1876 开灯：通过位运算解决开关灯状态变化问题，加深对异或运算性质在实际问题中的应用理解。
  - P2141 珠心算测验：利用位运算统计满足特定条件的组合数量，与本题利用位运算优化枚举判断的思路类似。

• 个人心得摘录与总结：
  - **作者：hwx12233**：提交27遍才通过，强调要注意Z是正整数的条件判断，这个条件修改多次。总结为在实现过程中要对题目条件细致处理，避免因边界条件疏忽导致错误。
  - **作者：Crab_Dave**：提到暴力因Xor优先级问题挂了一次，强调要注意运算符优先级，在使用时需正确添加括号避免逻辑错误。
  - **作者：nth_element**：比赛时90分，#7死卡不过，最后发现是没有判断\(z1\)和\(z2\)的范围，说明在代码实现中对计算结果范围的判断很关键，不能遗漏。 

---
处理用时：47.73秒
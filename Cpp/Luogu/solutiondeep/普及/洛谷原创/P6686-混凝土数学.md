# 题目信息

# 混凝土数学

## 题目描述

你正在看混凝土数学，这时旁边的工地开工了，你觉得看他们施工更有意思，于是你向窗外望去，注意到了一些长度不同的木棍。具体而言，你看到了 $n$ 条木棍编号为 $1,2,3,\ldots,n$，长度为 $a_1,a_2,a_3,\ldots,a_n$。你突发奇想：有多少拿出其中 $3$ 条木棍的方案满足它们能构成等腰三角形呢？你不想要输出的数太大，所以最后的方案要对 $998244353$ 取模。

给出等腰三角形的要求：任意两边之和大于第三边且至少有两条边边长相等。

例如，如果木棍长度分别为 $\{3,3,2,2,4,5\}$，你就有 $6$ 种方法，选取的木棍编号分别为：$\{1,2,3\}$，$\{1,2,4\}$，$\{1,2,5\}$，$\{1,2,6\}$，$\{1,3,4\}$，$\{2,3,4\}$。

## 说明/提示

- Subtask1 （$30$ pts）：$1\leq n \leq 200$。
- Subtask2 （$30$ pts）：$1\leq n \leq 2000$。
- Subtask3 （$20$ pts）：木棍长度全部相等。
- Subtask4 （$20$ pts）：无特殊限制。

对于 $100\%$ 的数据满足：$1\leq n \leq 2\times 10^5$，$1\leq a_i \leq 2\times 10^5$。

## 样例 #1

### 输入

```
6
3 3 2 2 4 5```

### 输出

```
6```

## 样例 #2

### 输入

```
6
1 1 4 5 1 4
```

### 输出

```
5```

## 样例 #3

### 输入

```
6
2 2 2 2 2 2```

### 输出

```
20```

# AI分析结果

• **综合分析与结论**：这些题解针对从给定长度的木棍中选取三根构成等腰三角形的方案数问题，提出了多种解法。思路主要围绕暴力枚举、分类讨论等腰与等边三角形情况，并通过排序、桶计数、前缀和、二分查找等方法优化。算法要点在于如何高效统计每种长度木棍的数量及满足三角形条件的组合数。解决难点在于优化暴力枚举的时间复杂度，避免超时。整体来看，各题解质量参差不齐，部分题解思路清晰、优化到位，部分则存在表述模糊或代码可读性差的问题。

• **所选的题解**
  - **作者：wuyonghuming (5星)**
    - **关键亮点**：思路清晰，详细阐述了从暴力枚举到优化的过程，包括记录木棍长度个数、枚举腰长及计算能构成三角形的个数，通过两种方法避免复杂度过高，并对乘法原理进行详细推导，代码简洁且有注释。
    - **个人心得**：无
    - **核心代码**：
```c
#include <stdio.h>
long long f[200001],ans;
int main()
{    
    int n,m=0,k=0,l=1,a;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        f[a]++;
        m=m<a?a:m;
    }
    for(int i=1;i<=m;i++)
    {
        for(;l<i*2&&l<=m;l++)
            k+=f[l];
        ans+=(f[i]-1)*f[i]*(k-f[i])/2+(f[i]-2)*(f[i]-1)*f[i]/6;
    }
    printf("%lld",ans%998244353);
    return 0;
}
```
    - **核心思想**：先通过数组`f`记录每个长度木棍的个数，找到最长木棍长度`m`。然后枚举腰长`i`，通过内层循环找到符合条件的木棍长度并累计其个数`k`，最后根据乘法原理计算等腰和等边三角形的方案数并累加至`ans`，最后输出取模后的答案。
  - **作者：SUNCHAOYI (4星)**
    - **关键亮点**：按得分点逐步分析，从暴力枚举到特殊情况特判，再到利用组合数分类讨论等腰与等边三角形，最后通过前缀和优化算法，思路连贯，代码有注释且对组合数计算有详细过程。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define mod 998244353
#define ll long long
using namespace std;
const int MAX = 200005;
ll vis[MAX << 1],a[MAX],b[MAX],c[MAX][5],s[MAX << 1],ans,n,k;
int main ()
{
    c[0][0] = c[1][0] = c[1][1] = 1;
    for (int i = 2;i <= 200000;++i)
    {
        c[i][0] = 1;
        for (int j = 1;j <= min (i,3);++j) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;    
    }
    scanf ("%lld",&n);
    for (int i = 1;i <= n;++i)
    {
        scanf ("%lld",&a[i]);
        if (!vis[a[i]]) b[++k] = a[i];
        vis[a[i]]++;
    } 
    sort (b + 1,b + 1 + k);
    for (int i = 1;i < MAX << 1;++i) s[i] = s[i - 1] + vis[i];
    for (int i = 1;i <= k;++i)
    {
        if(vis[b[i]] >= 3) ans += c[vis[b[i]]][3],ans %= mod;
        ans += c[vis[b[i]]][2] * (s[b[i] * 2 - 1] - vis[b[i]]),ans %= mod;
    }
    printf ("%lld\n",ans);
    return 0;
}
```
    - **核心思想**：先用杨辉三角计算组合数，读入数据时记录每个长度木棍的数量并去重排序。通过前缀和数组`s`预处理，然后枚举不同长度，分别计算等边三角形和等腰三角形的方案数并累加到`ans`。
  - **作者：monstersqwq (4星)**
    - **关键亮点**：利用桶和前缀和优化的思路清晰，代码简洁明了，对每种情况的计算式有清晰展示，同时对数组开两倍及数据类型选择有提醒。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
using namespace std;
long long n,a[200005],c[400005],sum[400005];
long long ans=0;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        c[a[i]]++;
    }
    for(int i=1;i<=4e5;i++)
    {
        sum[i]=sum[i-1]+c[i];
    }
    for(int i=1;i<=2e5;i++)
    {
        if(c[i]>=2)
        {
            ans=(ans+c[i]*(c[i]-1)*(sum[i*2-1]-c[i])/2+c[i]*(c[i]-1)*(c[i]-2)/6)%998244353;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
    - **核心思想**：用数组`c`记录每种长度木棍的数量，通过前缀和数组`sum`快速获取长度小于等于某值的木棍总数。枚举腰长`i`，当`c[i]>=2`时，分别计算等腰（非等边）和等边三角形的方案数并累加至`ans`。

• **最优关键思路或技巧**：利用桶计数记录每种长度木棍的数量，通过前缀和优化快速获取满足三角形条件的木棍数量，分类讨论等腰（非等边）和等边三角形的情况，运用组合数计算方案数。

• **可拓展之处**：同类型题可涉及不同几何图形的组合计数问题，类似算法套路为根据题目条件进行合理分类，利用数据结构（如桶、前缀和）优化枚举过程，通过组合数学知识计算方案数。

• **推荐题目**
  - [P1313 计算系数](https://www.luogu.com.cn/problem/P1313)：考察组合数计算及二项式定理。
  - [P2822 组合数问题](https://www.luogu.com.cn/problem/P2822)：结合组合数性质与前缀和优化。
  - [P3197 [HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197)：通过正难则反的思维，利用组合数计算方案数。

• **个人心得摘录与总结**：无

---
处理用时：52.99秒
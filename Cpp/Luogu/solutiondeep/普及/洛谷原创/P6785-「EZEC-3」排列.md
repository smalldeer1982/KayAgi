# 题目信息

# 「EZEC-3」排列

## 题目描述

pigstd 有一堆数，他想在这么多数中选出若干个数排成一列，记为 $x_{1},x_{2},\cdots,x_{p}$（$p$ 为数的个数）。

这一列数合法**当且仅当**满足以下条件：

- $p \ge 2$。
- 令 $y_{i} = x_{i + 1} - x_{i}$（特别的，$y_{p}=x_{1}-x_{p}$），如果把 $y_{1}$ 到 $y_{p}$ 按 $y_1,y_2,\cdots,y_p$ 的顺序排成**一圈**，那么每两个相邻的数互为相反数且绝对值都为 $k$。

pigstd 想知道，在所有合法的数列中，所有在这个数列中的数之和**最大**是多少。

## 说明/提示

**【样例 1 说明】**

当 pigstd 的排列为：$0,3,0,3$ 或 $3,0,3,0$ 时，总和最大，为 $6$。

**【数据规模与约定】**

对于 $100\%$ 的数据，$1 \le n \le 10^6$，$0 \le k,a_{i} \le 10^6$，$1 \le b_{i} \le 10^6$。

**本题采用捆绑测试。**

- Subtask 1（5 points）：保证无合法的数列；
- Subtask 2（15 points）：$k = 0$；
- Subtask 3（5 points）：$n = 1$；
- Subtask 4（5 points）：$n = 2$；
- Subtask 5（30 points）：$n,k,a_i,b_i \le 10^3$；
- Subtask 6（40 points）：无特殊限制。

## 样例 #1

### 输入

```
4 3 
1 5
2 4
3 3
0 2```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
这些题解思路大致相同，均通过分析题目条件得出合法序列的特征，再根据不同情况计算最大和。
1. **思路**：根据条件推出合法序列要么全是同一个数（$k = 0$ 时），要么由两个相差为 $k$ 的数交替组成（$k \neq 0$ 时）。
2. **算法要点**：使用桶数组记录每个数出现的次数，然后根据 $k$ 的值分情况讨论。$k = 0$ 时，枚举每个数，若其出现次数大于等于2，则更新最大和为该数乘以其出现次数；$k \neq 0$ 时，枚举每个数 $i$，若 $i$ 和 $i + k$ 都存在，则更新最大和为 $\min(cnt_i, cnt_{i + k}) \times (2i + k)$。
3. **解决难点**：主要难点在于对 $k = 0$ 和 $k \neq 0$ 情况的正确分类讨论，以及处理边界条件，如判断无解情况和确保序列长度符合要求。

整体来看，各题解思路清晰，但在代码实现的简洁性、可读性和优化程度上有所差异。

### 所选的题解
- **作者：pigstd (5星)**
    - **关键亮点**：思路清晰，代码简洁明了，对题意的分析直接到位，先得出满足条件的队列只能有两个数且差值为 $k$ 的结论，再通过枚举计算最大和，对 $k = 0$ 的特判也处理得很清晰。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int M=1e6+10;
int sum[M*2],n,k,maxn,ans=-1;

signed main()
{
    cin>>n>>k;
    for (int i=1;i<=n;i++)
    {
        int a,b;
        cin>>a>>b;
        sum[a]+=b,maxn=max(maxn,a);
    }
    if (k==0)
    {
        for (int i=0;i<=maxn;i++)
            if (sum[i]!=1&&sum[i])//注意因为p>=2,所以k=0时sum[i]>=2
                ans=max(ans,i*sum[i]);
        if (ans==-1)cout<<"NO";
        else cout<<ans;
        return 0;
    }
    for (int i=0;i<=maxn;i++)
    {
        int j=i+k;
        if (sum[i]&&sum[j])
            ans=max(ans,min(sum[i],sum[j])*(i+j));
    }
    if (ans==-1)cout<<"NO";
    else cout<<ans;
    return 0;
}
```
    - **核心实现思想**：用 `sum` 数组记录每个数出现的次数，先处理 $k = 0$ 的情况，枚举所有数，若出现次数不为1且存在，则更新最大和。再处理 $k \neq 0$ 的情况，枚举所有数，若该数与该数加 $k$ 都存在，则更新最大和为两者出现次数的最小值乘以两数之和。最后根据是否找到合法解输出结果。
- **作者：JRzyh (4星)**
    - **关键亮点**：代码简短，对差分概念运用自然，快速得出序列形式，直接定义数组记录每个数的个数，通过枚举计算最大和，对 $k = 0$ 的特判融入循环中，代码较为紧凑。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,a[1000008],ans=-1;
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        int x,b;
        cin>>x>>b;
        a[x]+=b;
    }
    for(long long i=0;i<=1000000-k;i++)
    {
        if(a[i]!=0&&a[i+k]!=0)
        {
            int res=0;
            if(k==0)res=i;
            else res=(i+i+k);
            if(min(a[i],a[i+k])!=1)ans=max(ans,res*min(a[i],a[i+k]));
        }
    }
    if(ans==-1)cout<<"NO"<<endl;
    else cout<<ans<<endl;
    return 0;
}
```
    - **核心实现思想**：通过 `a` 数组记录每个数出现的次数，循环枚举所有可能的数，当该数与该数加 $k$ 都存在时，根据 $k$ 是否为0计算不同的结果，更新最大和，最后根据最大和是否为初始值判断并输出结果。
- **作者：InformationEntropy (4星)**
    - **关键亮点**：对合法序列的性质推导详细，分情况讨论序列长度奇偶性得出序列特征，代码中对输入的处理有单独的 `read` 函数，虽然增加了代码量，但在一定程度上提高了代码的可扩展性和复用性。
    - **重点代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
inline void read(int &x){
    x=0;
    int f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
         }
         ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    x*=f;
}
ll f[1000001];
int main(){
    int n, k;
    read(n);
    read(k);
    int a, b;
    int cnt=0;
    int maxx=0;
    for(int i=1; i<=n; i++){
        read(a);
        read(b);
        f[a]+=b;
        maxx=max(maxx, a);
    }
    ll ans=0;
    if(k==0){
        bool flag=0;//记录是否存在合法序列
        for(int i=0; i<=maxx; i++){//要从0开始，因为ai可能为0
            if(f[i]>=2){
                ans=max(ans, i*f[i]);
                flag=1;
            }
        }
        if(!flag){
            cout << "NO";
            return 0;
        }
        cout << ans;
    }else{
        bool flag=0;
        for(int i=0; i<=maxx-k; i++){
            if(f[i]&&f[i+k]){
                flag=1;
                ll w=min(f[i], f[i+k]);
                ans=max(ans, w*i+w*(i+k));
            }
            if(!flag) cout << "NO";
            else cout << ans;
        }
    }
    return 0;
}
```
    - **核心实现思想**：通过 `f` 数组记录每个数出现的次数，先处理 $k = 0$ 的情况，枚举所有数，若出现次数大于等于2则更新最大和，并标记存在合法序列。再处理 $k \neq 0$ 的情况，枚举所有数，若该数与该数加 $k$ 都存在，则更新最大和，根据是否存在合法序列输出结果。

### 最优关键思路或技巧
1. **数学推导**：通过对题目条件的数学推导，得出合法序列的特征，简化问题求解。例如通过分析相邻数差值关系，得出序列只能由一个数（$k = 0$ 时）或两个相差为 $k$ 的数（$k \neq 0$ 时）组成。
2. **桶排序思想**：利用桶数组记录每个数出现的次数，方便统计和后续计算，优化了暴力枚举的时间复杂度，从 $O(n^2)$ 降低到 $O(n)$ 或 $O(max(a_i))$。

### 可拓展之处
同类型题或类似算法套路：此类题目通常涉及对序列性质的推导，然后根据推导结果进行分类讨论和统计计算。类似套路如处理具有特定规律的序列构造、最大最小值求解等问题。例如，给定一些数，要求构造满足特定差值关系的序列并求其某种统计量（和、积等）的最值。

### 相似知识点洛谷题目推荐
1. **P1088 [NOIP2004 普及组] 火星人**：涉及对序列的操作和规律分析，通过模拟和数学推导解决问题，与本题分析序列特征的思路类似。
2. **P1161 开灯**：需要根据题目条件分析出数字的规律，利用数学方法解决问题，锻炼对问题的分析和推导能力，与本题推导合法序列特征有相似之处。
3. **P1439 [NOI2010] 引用**：通过对数据的统计和分析，结合一定的算法思想解决问题，与本题利用桶数组统计数据并进行计算的方式有相似点。 

---
处理用时：76.42秒
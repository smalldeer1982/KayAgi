# 题目信息

# [✗✓OI R1] 前方之风

## 题目背景

>「不错的恶意。」  
> 女性呵呵笑道。  
>「但是，如果向我发出恶意，你可是会死哦？」

你不知道什么动作会被算作发出恶意，所以你决定做一道题来分散自己的注意力。

## 题目描述

给出一个长度为 $n$ 的序列 $a$ 和 $q$ 个询问，第 $i$ 个询问给出 $k_i$。对于每次询问，你需要进行以下操作：
1. 求出剩下的数的平均数 $\mathit{avg}$。
2. 将剩下的数中 $<\mathit{avg}-k_i$ 的数删去。
3. 重复以上两个步骤直到所有数都不会被删去。
4. 输出最后会剩下几个数。

**注意：询问之间是独立的，也就是说，不会真的删去那些数。**

## 说明/提示

**【样例解释】**

对于第一组样例，当 $k=0$ 时，显然只会留下 $99$。  
当 $k=6$ 时，删除数的步骤如下：
- 平均数为 $60\dfrac{1}{9}$，留下 $99,63,72,97,68$。
- 平均数为 $79.8$，留下 $99,97$。
- 平均数为 $98$，停止删除。

**【数据范围】**

对于 $100\%$ 的数据，满足 $1\leq n,q \le 10^5$，$1\le T \le 10$，$0 \le a_i,k_i \le 10^9$。

| subtask | 特殊数据范围 | 分数 |  时间限制
| :----------: | :----------: | :----------: |  :----------: |
| 1 | $n,q \le 200$ | 20 |   300ms 
| 2 | $n,q \le 2000$ | 30  | 300ms
| 3 |  | 50 | 800ms|

>「不错的恶意。」  
> 女性呵呵笑道。  
>「而且你运气很不错，如果放在以前，你早就死了。」

![](https://cdn.luogu.com.cn/upload/image_hosting/6icoj36r.png)

## 样例 #1

### 输入

```
5
9 9
19 99 63 39 72 46 97 38 68 
0 6 4 0 7 1 0 3 6 
6 8
88 62 48 50 8 47 
0 6 1 5 2 2 6 1 
6 5
33 3 54 17 26 64 
87 89 92 70 59 
18 19
71 52 77 38 12 34 82 14 57 39 91 7 56 86 35 68 38 14 
9 9 1 5 1 3 4 5 6 1 6 0 3 0 2 1 3 5 8 
10 15
4 77 78 76 5 19 98 94 77 81 
17 43 4 86 2 91 85 4 81 74 44 16 21 69 32 
```

### 输出

```
1 2 2 1 2 2 1 2 2
1 1 1 1 1 1 1 1
6 6 6 6 6
4 4 1 3 1 2 2 3 3 1 3 1 2 1 1 1 2 3 4
7 7 2 10 2 10 10 2 10 10 7 7 7 10 7
```

## 样例 #2

### 输入

```
1
5 1
20 0 0 0 0
5```

### 输出

```
5```

# AI分析结果

• 综合分析与结论：
    - 思路方面，多数题解都意识到对原数组排序可优化操作，因每次删数是从小到大。部分题解利用后缀和或前缀和快速计算平均数。还有题解发现答案随 \( k \) 变化的单调性，借此优化多次查询。
    - 算法要点：排序数组、维护和（前缀和或后缀和）计算平均数、利用单调性优化查询。
    - 解决难点：如何高效处理多次询问，避免每次询问 \( O(n^2) \) 的暴力模拟。不同题解从不同角度优化，如排序后用指针维护、利用 \( k \) 的单调性离线处理等。
    - 综合质量来看，xzyg、AsunderSquall、漠寒的题解在思路清晰度、代码可读性和优化程度上表现较好。

所选的题解：
  - **xzyg（5星）**：
    - **关键亮点**：思路清晰，提供多种解法并逐步优化。从暴力模拟 + 二分（虽被hack）到排序 + 后缀和，再到利用 \( k \) 的单调性优化为 \( O(n\log n + q\log q) \) 复杂度的解法，代码实现简洁明了。
    - **个人心得**：在解题过程中遇到代码错误和证明修正等情况，不断完善题解。
    - **核心代码片段**：
```cpp
struct xmh{
    ll val,num,ans;
}k[100010];

ll n,q;
ll a[100010];
ll add[100010];
double avg[100010];

inline bool cmp1(xmh a,xmh b){
    return a.val > b.val;
}
inline bool cmp2(xmh a,xmh b){
    return a.num < b.num;
}

void init(){
    // 初始化数组和变量
    scanf("%lld%lld",&n,&q);
    for(ll i = 1; i <= n; ++i)
        scanf("%lld",&a[i]);
    for(ll i = 1; i <= q; ++i){
        scanf("%lld",&k[i].val);
        k[i].num = i;
    }

    sort(a+1,a+1+n);
    sort(k+1,k+1+q,cmp1);

    add[n] = a[n];
    for(ll i = n-1; i >= 1; --i){
        add[i] += add[i+1] + a[i];
    }
    for(ll i = 1; i <= n; ++i){
        avg[i] = 1.0 * add[i] / (n-i+1);
    }
    return;
}

void process(){
    ll p = 1,sum = n;
    for(ll i = 1; i <= n && p <= q;){
        while(a[i] < avg[i] - k[p].val)++i;
        k[p].ans = n-i+1;
        p++;
    }
}
```
核心实现思想：先初始化数组和变量，对原数组和询问数组排序，计算后缀和及平均数。在处理过程中，通过比较 \( a[i] \) 与 \( avg[i] - k[p] \) 的关系确定答案，利用 \( k \) 的单调性优化查询。

  - **AsunderSquall（5星）**：
    - **关键亮点**：详细分析题意，对每种算法的讲解细致，包括假算（二分被hack的情况）、算法一（暴力模拟）、算法二（排序和后缀和优化）、算法三（离线和观察性质）。证明了关键性质，逻辑严谨。
    - **个人心得**：思考如何构造数据让开除学生的轮数为 \( O(n) \) 级别，从不同角度分析问题。
    - **核心代码片段**：无（题解未提供完整代码）
核心实现思想：在算法三中，利用排序后的数组，定义序列 \( A_p \)，证明两个关键性质，基于性质对 \( k \) 排序后用双指针维护判断答案，利用性质优化查询。

  - **漠寒（4星）**：
    - **关键亮点**：简洁地分析出 \( k \) 变化对答案的影响，即 \( k \) 变小时删的数更多，答案单调递减。基于此对 \( k \) 从大到小排序处理，每个数只用删一次，代码简洁高效。
    - **个人心得**：受二分误导调了很久，强调要考虑 \( k \) 变化对答案的影响。
    - **核心代码片段**：
```cpp
struct node{
    int k,id;
}c[N];
bool cmp(node aa,node bb){
    return aa.k>bb.k;
}

signed main(){
    read(T);
    while(T--){
        clean();
        read(n), read(q); 
        for(int i = 1; i <= n; i++)
            read(a[i]);
        for(int i = 1; i <= q; i++)
            read(c[i].k),c[i].id=i;
        sort(a + 1, a + n + 1); 
        for(int i = 1; i <= n; i++)
            b[i] = (double)a[i]; 
        for(int i = 1; i <= n; i++)
            sum[i] = sum[i - 1] + a[i]; 
        for(int i = 1; i <= n; i++)
            avg[i] = (double)(sum[n] - sum[i - 1]) / (double)(n - i + 1); 
        sort(c+1,c+q+1,cmp);
        int pos=1;
        for(int i = 1; i <= q; i++){
            ans[c[i].id]=0;
            while(pos<=n&&b[pos]<avg[pos]-c[i].k)pos++;
            ans[c[i].id]=n-pos+1;
        }
        for(int i = 1; i <= q; i++)
            printf("%lld ", ans[i]);
        printf("\n"); 
    }
    return 0;
}
```
核心实现思想：读入数据后，对原数组和询问结构体数组排序，计算前缀和与平均数。利用 \( k \) 的单调性，从大到小处理询问，通过移动指针判断每个询问下应删除的数，得出答案。

最优关键思路或技巧：利用数组排序确定删数顺序，通过维护前缀和或后缀和快速计算平均数。同时，发现并利用答案随 \( k \) 变化的单调性，对询问离线排序处理，用指针优化多次查询，将时间复杂度从 \( O(qn^2) \) 优化到 \( O(n\log n + q\log q) \)。

可拓展之处：同类型题可考察对数据性质的挖掘与利用，类似算法套路是对输入数据排序，分析操作对结果的影响，利用单调性等性质优化算法。例如在一些涉及多次查询且数据有一定规律的题目中，可借鉴此思路。

推荐题目：
  - [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：涉及排序与利用数据顺序关系计算结果，与本题对数组排序优化操作思路类似。
  - [P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)：通过对数据不同维度排序，利用单调性等性质优化算法，与本题利用 \( k \) 单调性优化查询思路有相似处。
  - [P2671 求和](https://www.luogu.com.cn/problem/P2671)：需对数据排序并结合前缀和等操作解决问题，与本题处理方式有相通点。 

---
处理用时：51.67秒
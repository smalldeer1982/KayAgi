# 题目信息

# 「Wdoi-5」樱点收集

## 题目背景

119 季 5 月，明明本应是樱花盛开的春天，幻想乡却依然下着大雪。异变的主谋**西行寺幽幽子**在古书上看到，只要使妖樱西行妖满开便会有什么人复活，便出于兴趣命令妖梦收集幻想乡中的春度，一手策划成了这场异变。在收集春度的过程中散落的能量在西行妖的影响下化为**樱点**，散落在幻想乡各处。

出发解决**春雪异变**的灵梦将前往冥界旅途划分为了若干段，每一段都可以收集到一定的樱点。收集齐一定程度的樱点，就会立即开出樱之结界。开出樱之结界后可以短暂地屏蔽一切攻击，并且获得相应的增益。

但是樱之结界何时开放仅由樱点的收集情况所决定，她不得不对樱点进行「规划」。通过某些途径规避某一段路上樱点的收集，借此使得在将来的某几段路程里，灵梦得以恰好在该段的末尾开放樱之结界。  

但是现实往往不尽人意。也就是说，可能有某些要求无法达成。灵梦希望找出一个方案，使得她可以达成的要求最多。灵梦委托八云紫帮忙决策，于是这个重任就被一条懒紫交给了式神八云蓝。尽管八云蓝擅长计算，但是八云紫睡觉去了没有给她编程，因而现在这个任务就落到了你的手上。

## 题目描述

灵梦当前拥有的樱点可以使用一个**变量** $c$ 存储，初始时为 $0$。当樱点在某个瞬间**恰好**变为了 $k$，灵梦就会展开樱之结界，同时 $c$ 变为 $0$。

现在她把路程**依次**划分为了 $n$ 个关卡，其中第 $i$ 关上，灵梦一共可以获得 $a_i$ 点樱点。这些樱点是均匀分布在这关的路程上的。也就是说，随着这段路程的进行，灵梦的樱点个数会依次增加，每次增加 $1$ 个单位（$c\gets c+1$），恰好在这段路程结束的瞬间会收集到这关中第 $a_i$ 点樱点。

![](https://cdn.luogu.com.cn/upload/image_hosting/3yuiywt0.png)

**【需要注意的是，这只是图示参考，不满足实际的数据限制。】**

在这个例子里，灵梦将路径划分为了四个关卡。这四个关卡的樱点个数分别为 $2,0,3,1$。

灵梦提出了 $m$ 个要求。第 $i$ 个要求 $b_i$ 表示灵梦希望在第 $b_i$ 段路程结束的瞬间，**恰好**展开樱之结界（如果在这段路程的中途展开但是结束的瞬间没有展开，那就不算达成了要求）。

灵梦可以选择在某个关卡开头放 bomb，**跳过**整个关卡的樱点收集。这样的机会**有且仅有**一次（当然，灵梦可以选择不使用 bomb）。

现在需要求出，在最优的选择下，灵梦**最多**可以达成多少个要求。

## 说明/提示

样例 $2$ 见下发的附件 $\textbf{\textit{sukura2.in/sakura2.ans}}$。该样例约束与测试点 $1\sim 8$ 一致。  
样例 $3$ 见下发的附件 $\textbf{\textit{sukura3.in/sakura3.ans}}$。该样例约束与测试点 $9\sim 14$ 一致。  
样例 $4$ 见下发的附件 $\textbf{\textit{sukura4.in/sakura4.ans}}$。该样例约束与测试点 $15\sim 20$ 一致。

#### 样例 1 解释

- 在不使用 bomb 时，灵梦会在第 $2$、$3$ 关开出樱之结界，其中第 $3$ 关在统计序列中，满足要求数为 $1$。
- 在第 $1$ 关使用 bomb，灵梦会在第 $4$ 关开出樱之结界，且第 $4$ 关在统计序列中，满足要求数为 $1$。
- 在第 $2$ 关使用 bomb，灵梦会在第 $4$ 关开出樱之结界，且第 $4$ 关在统计序列中，满足要求数为 $1$。
- 在第 $3$ 关使用 bomb，灵梦会在第 $2$ 关开出樱之结界，且第 $2$ 关不在统计序列中，满足要求数为 $0$。
- 在第 $4$ 关使用 bomb，灵梦会在第 $2$、$3$ 关开出樱之结界，其中第 $3$ 关在序列中，满足要求数为 $1$。

#### 数据范围及约定

本题共有 $20$ 个测试点，每个测试点 $5$ 分。最终分数为所有测试点分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \bm{n\le } & \bm{k\le} \cr\hline
1\sim 8 & 200 & 10^3 \cr\hline
9\sim 14 & 2\times 10^3 & 10^5 \cr\hline
15\sim 20 & 3\times 10^5 & 10^6 \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，保证 $1\le m\le n\le 3\times 10^5$，$1\le k\le 10^6$，$1\le a_i\le 10^9$，$1 \le b_i \le n$，$b$ 序列递增。

## 样例 #1

### 输入

```
4 3 2
1 3 4
1 1 2 1```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是围绕前缀和与取模运算来解决问题。先考虑不使用bomb的情况，通过计算前缀和模k为0且在指定位置（b数组）的数量来统计满足要求数。对于使用bomb的情况，由于bomb只影响其之后的前缀和，所以枚举bomb的位置，分别统计bomb之前满足前缀和模k为0的数量以及bomb之后满足前缀和减去bomb位置数值后模k为0（即前缀和模k等于bomb位置数值模k）的数量。

各题解在具体实现上，大多通过开桶记录前缀和模k的余数出现次数来优化计算，时间复杂度从暴力的$O(n^2)$优化到$O(n)$。部分题解还涉及平衡树、莫队等方法，但本质思路仍是基于前缀和与取模的统计。

### 所选的题解
1. **作者：WardLee (5星)**
    - **关键亮点**：思路清晰简洁，代码实现高效。通过两个数组$l$和$r$分别存储某一段前面和后面有垃圾桶（对应题目中的要求位置）且前缀和模$k$为$i$的位置数，在枚举跳过的一段时，能快速更新答案。
    - **重点代码**：
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

typedef long long LL;

const int N = 300010, M = 1000010;
int n, m;
LL a[N], s[N], res, K;
int nl[M], nr[M];
bool st[N];

int main(){
    scanf("%d%d%lld", &n, &m, &K);
    for(int i = 1; i <= m; i ++){
        int t;
        scanf("%d", &t);
        st[t] = true;
    }

    for(int i = 1; i <= n; i ++){
        scanf("%lld", &a[i]);
        s[i] = a[i] + s[i - 1];
        if(a[i] && st[i]) nl[s[i] % K] ++;
    }

    int res = nl[0];
    for(int i = n; i >= 1; i --){
        if(a[i] && st[i]) nl[s[i] % K] --;
        res = max(res, nl[0] + nr[a[i] % K]);
        if(a[i] && st[i]) nr[s[i] % K] ++;
    }
    printf("%d\n", res);
    return 0;
}
```
    - **核心实现思想**：先预处理出前缀和数组$s$，并统计有要求位置（$st$数组标记）且前缀和模$K$为$i$的数量到$nl$数组。然后从后往前枚举跳过的一段，更新$nl$数组并利用$nr$数组统计答案。
2. **作者：minstdfx (4星)**
    - **关键亮点**：对问题的分析细致，逐步推导使用bomb和不使用bomb时达成事件的条件。通过记录前缀和模$k$的余数情况，利用数组$x$记录特定余数的数量，在枚举bomb位置时更新答案。
    - **重点代码**：
```cpp
// 整体代码结构与WardLee类似，核心部分如下
for(int i = n; i >= 1; i --){
    if(S[i] % k == 0 && find(b + 1, b + m + 1, i)!= b + m + 1) t --;
    ans = max(ans, t + x[S[i] % k]);
    if(find(b + 1, b + m + 1, i)!= b + m + 1) x[S[i] % k] ++;
}
```
    - **核心实现思想**：从后往前枚举bomb位置$i$，若$S[i]$是$k$的倍数且$i$在$b$数组中，则$t$减1（$t$表示$S_1$到$S_{i}$中$k$的倍数且在$b$中的个数）。然后更新答案为$t$与$x[S[i] \% k]$（$x$数组记录$S_{i + 1}$到$S_n$中模$k$余$i$的数的个数）之和。最后若$i$在$b$数组中，更新$x$数组。
3. **作者：lyhqwq (4星)**
    - **关键亮点**：简化题意准确，思路直接。通过维护前缀和数组$sum$，枚举删除每一个$a_i$，分别统计$a_i$之前满足前缀和模$k$为0的数量以及$a_i$之后满足前缀和模$k$等于$a_i$模$k$的数量来计算答案。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,ans;
int b[300005],sum[300005],a[300005],t[300005];
int main(){
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++){
        int x;
        scanf("%d",&x);
        b[x]=1;
    }
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        sum[i]=(sum[i-1]+a[i])%k;
        if(b[i]) t[sum[i]]++;
    }
    int tmp=0;
    for(int i=1;i<=n+1;i++){
        if(b[i]) t[sum[i]]--;
        ans=max(ans,tmp+t[a[i]%k]);
        if(!sum[i]&&b[i]) tmp++;
    }
    printf("%d",ans);
    return 0;
}
```
    - **核心实现思想**：先预处理前缀和数组$sum$，并利用数组$t$记录有要求位置（$b$数组标记）且前缀和模$k$为$i$的数量。然后枚举位置$i$，更新$t$数组，计算并更新答案为$tmp$（$i$之前满足前缀和模$k$为0且在$b$中的数量）与$t[a[i] \% k]$之和。

### 最优关键思路或技巧
1. **前缀和与取模结合**：通过计算前缀和模$k$的值，快速判断在某位置是否能展开樱之结界，是解决本题的基础思路。
2. **桶计数优化**：利用桶记录前缀和模$k$的不同余数出现的次数，在枚举bomb位置时，能以$O(1)$的时间复杂度获取所需统计信息，将时间复杂度从暴力的$O(n^2)$优化到$O(n)$。

### 可拓展之处
同类型题或类似算法套路：此类题目通常围绕数组的区间和以及特定条件的统计，可拓展到更多限制条件下的区间统计问题，如在不同操作（如修改、删除等）影响下，统计满足特定取模条件的区间数量。类似算法套路包括利用前缀和、差分、桶计数等优化统计过程。

### 相似知识点洛谷题目推荐
1. **P1115 最大子段和**：通过前缀和思想解决连续子段和的最值问题。
2. **P3397 地毯**：利用二维前缀和处理二维区域的统计问题。
3. **P1445 樱花**：结合前缀和与取模运算，解决类似的条件统计问题。

### 个人心得摘录与总结
暂未发现题解中有个人心得相关内容。 

---
处理用时：52.93秒
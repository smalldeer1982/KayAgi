# 题目信息

# 『JROI-4』分数

## 题目背景

万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(1/10000) $\to$ 万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(2/10000)(1/5000) $\to$ 万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(2/5000)(1/2500) $\to$ 万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(2/2500)(1/1250) $\to$ 万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(2/1250)(1/625) $\cdots$ 以此类推，在可以约分的情况下，“万人血书”很快就能完成。[](KH粉丝群群号：808706015)

## 题目描述

“$x$ 人血书”的过程可以看成一个函数 $f(x)$：

有一个 $\frac{0}{x}$ 的分数。重复以下步骤直到这个分数为 $1$：

1. 分子 $+1$。
2. 如果这个分数可以约分，约分到最简形式。

现在小 D 给了你 $T$ 组数据，每组数据都是给定 $n$，求在 $1\le x\le n$ 的情况下 $f(x)$ 的最大操作次数。

但是他太菜了，不会，你能帮帮他吗？

## 说明/提示

### 样例解释

$f(1)=1,f(2)=2,f(3)=3,f(4)=3,f(5)=5$。

我也想把更大的 $f(x)$ 列出来，但是地方不够了。

### 数据范围


对于全部数据，$1\le T\le 5\times 10^5$，$1\le n\le 2\times 10^6$。

Subtask 中没填的部分表示和全部数据的范围一样。

| 子任务编号 | $T$ 的范围 | $n$ 的范围 | 特殊性质 |分值|
| -----------: | -----------: | -----------: | -----------: |-----------: |
| Subtask $1$ | $T\le 3$ | $n\le 10$ |  |$10$|
| Subtask $2$ | $T\le 5$ | $n\le 10^3$ |  |$30$|
| Subtask $3$ |  |  | $n$ 为质数|$10$|
| Subtask $4$  |  | $n\le 5\times 10^5$ |  |$20$|
| Subtask $5$  |  |  |  |$30$|


## 样例 #1

### 输入

```
5
1
2
5
8
114514```

### 输出

```
1
2
5
7
114493
```

# AI分析结果

• 综合分析与结论：这些题解思路基本一致，都发现约分次数越少，操作次数越大，得出答案是小于等于n的最大质数这一结论。算法要点在于通过素数筛法找出最大质数。解决难点在于优化时间复杂度，避免直接模拟导致超时。
- **作者：CarroT1212 (赞：16)  星级：4星**
  - **关键亮点**：思路清晰，通过具体例子展示操作过程，引导得出结论，代码简洁明了。
  - **个人心得**：比赛时因提交时间问题导致分数和排名变化。
  - **核心代码实现思想**：用埃氏筛预处理，再循环查找最大质数。
```cpp
void init() { //埃氏筛初始化
	for (int a=2;a<=2000000;a++) {
		if (flag[a]) continue;
		for (int b=a+a;b<=2000000;b+=a) flag[b]=1;
	}
}
int main() {
	cin>>t;
	init();
	while (t--) {
		cin>>n;
		for (int a=n;a;a--) { //循环找最大质数
			if (!flag[a]) {
				cout<<a<<endl;
				break;
			}
		}
	}
	return 0;
}
```
- **作者：Dream_weavers (赞：5)  星级：4星**
  - **关键亮点**：通过分解质因数角度分析操作次数，得出结论，采用欧拉筛预处理并区间赋值，查询复杂度为O(1)。
  - **核心代码实现思想**：先用欧拉筛筛出素数，再对区间赋值，最后O(1)查询。
```cpp
void shai(){
    book[1]=1;
    for(int i=2;i<=N-50;i++){//欧拉筛
        if(!book[i]) prime[++ind]=i;
        for(int j=1;j<=ind&&i*prime[j]<=N-50;j++){
            book[i*prime[j]]=1;
            if(!i%prime[j]) break;
        }
    }
    mp[1]=1;//把1赋值为1
    for(int i=1;i<=ind;i++){//赋值为最大素数
    	int l=prime[i],r=prime[i+1]-1;
    	for(int j=l;j<=r;j++)mp[j]=prime[i];
    }
}
signed main(){
    shai();
    t=read();
    while(t--){//查询
    	n=read();
    	write(mp[n]);//直接输出n以内最大素数
    	puts("");
    }
    return 0;
}
```
- **作者：RE_Prince (赞：5)  星级：4星**
  - **关键亮点**：在查找最大质数时使用upper_bound()函数优化查找过程，提高效率。
  - **核心代码实现思想**：先埃氏筛预处理，利用upper_bound()函数快速找到最大质数。
```cpp
inline void prime(int x)
{
	for (i = 1; i <= x; i++) a[i] = 1;
	a[1] = 0;
	for (i = 2; i <= x; i++)
	{
		if (a[i]) p[++k] = i;
		for (j = 1; j <= k && i * p[j] <= x; j++)
		{
			a[i * p[j]] = 0;
			if (i % p[j] == 0) break;
		}
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	int T;
	prime(2 * 1e6);
	cin >> T;
	while (T--)
	{
		cin >> n;
		cout << p[upper_bound(p + 1, p + k + 1, n) - p - 1] << endl;
	}
	return 0;
}
```
• **最优关键思路或技巧**：通过分析约分对操作次数的影响，得出答案是小于等于n的最大质数这一结论，利用素数筛法（如埃氏筛、欧拉筛）预处理，再通过合适方法（如循环查找、upper_bound()函数、区间赋值）找到最大质数。
• **可拓展之处**：同类型题可涉及数论中关于质数、约数、互质等知识点结合的模拟操作题，类似算法套路为分析操作过程中关键因素（如本题约分）对结果的影响，转化为熟悉的数论问题，再用相应筛法解决。
• **推荐题目**：
  - P3383 【模板】线性筛素数
  - P1835 素数密度
  - P5736 【深基7.习8】质数筛法 

---
处理用时：34.87秒
# 题目信息

# 伟大的神

## 题目背景

伟大的神 $\text{T}\color{red}\text{nyieldingUrilobite}$ （以下简称 TU）喜欢字符串，在 AK 了 IOI 后的第 $998244353$ 天后，伟大的神 TU 勒令小 s 找出他喜欢的字符串。

否则，小 s 就要被吊打 $10^{998244353}$ 年。（虽然找出来了也要被吊打）

## 题目描述

伟大的神 TU 认为 ，一个所有出现的字符的数量相等的字符串是属于神的，他称之为神之字符串。

对于一个字符串 $S$，如果它的一个子串为神之字符串，即称这个子串为神之子串。

神 TU 认为，他喜欢的字符串只能由 `l` 和 `r` 构成，并且还要满足以下条件：

   - 字符串的长度为 $n$。
   - 字符串中最长神之子串长度为 $m$。
   - 字符串中连续的相同的字符的数量不能超过 $k$。

弱小的神小 s 找不出神 TU 喜欢的字符串，现在他找到了你，你能帮帮他吗？

## 说明/提示

**本题采用捆绑测试。**

对于 $100\%$ 的数据，保证 $1\le k\le10^5$，$4\le m\le n \le 10^5$。

数据保证可以找出神 TU 喜欢的字符串。

Subtask 1：对于 $5\%$ 的数据，保证 $k=1$。

Subtask 2：对于另外 $10\%$ 的数据，保证 $n=m$。

Subtask 3：对于另外 $30\%$ 的数据，保证 $k \ge 3$。

Subtask 4：无特殊性质。



## 样例 #1

### 输入

```
10 6 3```

### 输出

```
lllrrlrlll```

# AI分析结果

这道题是构造类型的题目，需构造出满足特定条件的由 `l` 和 `r` 组成的字符串。各题解思路大致是先分析各子任务特点，再根据不同 `k` 值和 `n`、`m` 关系进行构造。
1. **思路与算法要点**
    - **Subtask 1**：因为 $k = 1$，所以字符串只能是 `l` 和 `r` 交替出现，如 `lrlrlr...`。
    - **Subtask 2**：$n = m$，同样构造 `l` 和 `r` 交替的字符串就能满足条件。
    - **Subtask 3**：$k \geq 3$ 时，先构造长度为 $m$ 的神之子串（如 `lrlr...`），然后通过在后面添加字符（如按 `llr` 循环）来避免出现更长的神之子串。
    - **Subtask 4**：重点处理 $k = 2$ 的情况。多数题解发现按之前方法构造会使神之子串长度比 $m$ 大 2，于是采取不同处理方式，如调整神之子串构造形式或调整 `m` 的值再按原方式构造。
2. **解决难点**：难点在于处理 $k = 2$ 时保证最长神之子串长度为 $m$。不同题解通过不同构造策略来解决，例如改变神之子串的结尾形式，或减少神之子串的长度等。
3. **题解评分**
    - **作者chen_zhe（5星）**：思路清晰，从数据特点切入，详细分析每个子任务，对 $k = 2$ 时的问题分析透彻并给出正确构造方法，代码简洁明了。
    - **作者Jeremiahy（4星）**：从子任务入手逐步理清思路，对每个子任务的分析和构造方法阐述清晰，代码实现完整且有注释说明。
    - **作者sgl654321（4星）**：详细分析每个子任务，对构造方法进行了严谨证明，代码结构清晰，对不同情况分类处理。

### 所选高质量题解
- **作者chen_zhe（5星）**
    - **关键亮点**：对每个子任务分析深入，从数据保证有解和 $m$ 为偶数等条件出发，快速找到构造思路，尤其对 $k = 2$ 时的特殊情况处理巧妙。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include <iostream>
using namespace std;
int main()
{
    int n,m,k;
    cin >> n >> m >> k;
    if (k==1)
    {
        for (int i=1;i<=n;i++)
            cout << (i&1?'l':'r');
        return 0;
    }
    for (int i=1;i<=m-2;i++)
        cout << (i&1?'l':'r');
    int cnt=1;
    cout << "rl";
    for (int i=m+1;i<=n;i++)
    {
        if (cnt==0)
            cout << 'l';
        else
            cout << 'r';
        cnt++;
        cnt%=3;
    }
    return 0;
}
```
    - **核心实现思想**：$k = 1$ 时直接交替输出 `l` 和 `r`。其他情况先构造长度为 $m - 2$ 的交替字符串，再输出 `rl`，最后按特定规律（`llr` 的变体）输出剩余字符以满足条件。
- **作者Jeremiahy（4星）**
    - **关键亮点**：从子任务骗分思路出发，逐步深入得到完整解题思路，对每个子任务的构造方法解释详细，代码可读性较好。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k;
signed main() {
    cin >> n >> m >> k;
    if (k == 1 || n == m) //subtask 1 & 2
        for (int i = 1; i <= n; i++)
            if (i % 2)//循环输出 l, r 
                cout << 'l';
            else
                cout << 'r';
    else if (k == 2) {
        int num = (m - 4) / 2; //计算输出多少个 rl，因为 rl 占两个字符，所以要除以 2 
        for (int i = 1; i <= num; i++)
            cout << "rl"; 
        for (int i = 1; i <= n - num * 2; i++)
            if (i % 3 == 1) //输出 rll 
                cout << 'r';
            else
                cout << 'l';
    }
    else {
        for (int i = 1; i <= m; i++)
            if (i % 2)//输出 l ，r直到到达 m 
                cout << 'l';
            else
                cout << 'r';
        for (int i = m + 1; i <= n; i++) {//输出 k 个 l，1 个 r，循环。 
            for (int j = 1; j <= k; j++) {
                if (i > n)
                    break;
                cout << 'l', i++;
            }
            if (i <= n)
                cout << 'r';
        }
    }
    return 0;
}
```
    - **核心实现思想**：$k = 1$ 或 $n = m$ 时，交替输出 `l` 和 `r`。$k = 2$ 时，先输出若干个 `rl`，再按 `rll` 规律输出剩余字符。$k \geq 3$ 时，先输出长度为 $m$ 的交替字符串，再按 `k` 个 `l`、1 个 `r` 的规律输出剩余字符。
- **作者sgl654321（4星）**
    - **关键亮点**：对每个子任务的构造方法不仅给出思路，还进行了严谨证明，代码结构清晰，对不同情况分类明确。
    - **个人心得**：赛时写挂，打表找规律花了一小时没找出。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,now,tot;
char a[100010];
bool p; 
int main(){
    cin>>n>>m>>k;
    if(k==1){
        for(int i=1;i<=n;i++)
            if(i%2==1)cout<<"l";
            else cout<<"r";
        return 0; 
    }
    if(n==m){
        for(int i=1;i<=n;i++)
            if(i%2==1)cout<<"l";
            else cout<<"r";
        return 0; 
    }
    if(k>=3){
        for(int i=1;i<=m;i++)
        if(i%2==1)cout<<"l";
        else cout<<"r";
        tot=m+1;
        now=1;
        while(tot<=n){
            if(now==1||now==2||now==3){
                cout<<"l";
                now++; 
            }else{
                cout<<"r";
                now=1;
            }
            tot++;
        }    
        return 0;
    }
    cout<<"rl";
    for(int i=3;i<=m;i++){
        if(i%2==1)cout<<"l";
        else cout<<"r";
    }
    for(int i=1;i<=n-m;i++)
        if(i%3==1||i%3==2)cout<<"l";
        else cout<<"r";
    cout<<endl;
    return 0;
}
```
    - **核心实现思想**：$k = 1$ 或 $n = m$ 时，交替输出 `l` 和 `r`。$k \geq 3$ 时，先输出长度为 $m$ 的交替字符串，再按 `lllr` 规律输出剩余字符。$k = 2$ 时，先输出 `rl`，再输出长度为 $m - 2$ 的交替字符串，最后按 `llr` 规律输出剩余字符。

### 最优关键思路或技巧
处理 $k = 2$ 时的情况是关键。通过分析构造字符串中神之子串变长的原因，采用改变神之子串构造（如将最后两个字符调整为 `rl`）或调整神之子串长度（$m$ 减 2 后按原方式构造）的方法，确保最长神之子串长度符合要求。这种对特殊情况细致分析并针对性调整构造的思维方式是解题关键。

### 可拓展思路
此类题目属于构造类问题，常见套路是从特殊条件或子任务入手，分析规律后推广到一般情况。类似题目通常会给定一些限制条件，要求构造出满足条件的数据结构或序列。可通过多做此类构造题，总结不同条件下的构造方法和技巧，提高解题能力。

### 相似知识点洛谷题目
 - **P1080 [NOIP2012 提高组] 国王游戏**：涉及构造最优排列顺序的问题，通过分析不同排列对结果的影响来构造最优解。
 - **P2678 [NOIP2015 提高组] 跳石头**：需要构造满足特定条件的跳跃方案，通过二分答案和贪心策略来确定石头的保留与移除。
 - **P1106 删数问题**：要求构造删除数字的方案，使得剩下数字组成的数最小，考查贪心构造思路。 

---
处理用时：57.10秒
# 题目信息

# 「GLR-R3」立春

## 题目背景

&emsp;&emsp;「从此雪消风自软，梅花合让柳条新」

---

&emsp;&emsp;“明天就要返校了呢。”

&emsp;&emsp;灰色的长发被身后的人儿慢慢地顺着，顺着，于假期最后一个慵懒的清晨醒来，与春日的第一抹阳光迷迷糊糊地耳语，她的目光随着点过窗外的鸟雀，停留在那丛褐色的光秃枝丫。

&emsp;&emsp;“天依？”

&emsp;&emsp;赤红色的眸子随之望去，片刻，静默。

&emsp;&emsp;“如果我能告诉它，今天是立春，是春天的……”

&emsp;&emsp;“那么它会抽芽，繁盛，会成为我们窗外或红或绿的美妙。”

&emsp;&emsp;“——因为它本该如此，希望如此吧。”

---

&emsp;&emsp;**立春**&emsp;「雏鸟站在悬崖上　展开了翅膀　地平线上的梦想　照进一缕光」


## 题目描述

由于天依刚睡醒，害怕第一题的题面就迷糊了大家，所以本题只有简要题意。~~（其实是实在编不下去了。）~~

设 $\sigma$ 为任意一个长度为 $n$ 的排列，$\tau(\sigma)$ 表示其中的逆序对个数，请求出

$$
\sum_\sigma 2^{\tau(\sigma)}
$$

对 $(10^9+7)$ 取模的结果。

## 说明/提示

#### 题意解释

本节为部分选手介绍**逆序对的定义**，对此熟悉的选手可以跳过本节。

对于长度为 $n$ 的排列 $\sigma$，假设下标从 $1$ 开始，那么我们称 $(i,j)$ 构成逆序对，当且仅当 $1\le i<j\le n$，并且 $\sigma_i>\sigma_j$；$\tau(\sigma)$ 则表示总共有多少对不同的 $(i,j)$ 满足上述条件。

举个例子，对于排列 $\sigma=\lang 2,4,1,3\rang$，有逆序对 $(1,3),(2,3),(2,4)$，所以 $\tau(\sigma)=3$。可见只要 $\sigma$ 中元素的大小关系确定，$\tau(\sigma)$ 就是确定的。

#### 样例 #1 解释

$$
\begin{aligned}
\sum_{\sigma}2^{\tau(\sigma)} &= 2^{\tau(\lang 1,2,3\rang)}+2^{\tau(\lang 1,3,2\rang)}+2^{\tau(\lang 2,1,3\rang)}+2^{\tau(\lang 2,3,1\rang)}+2^{\tau(\lang 3,1,2\rang)}+2^{\tau(\lang 3,2,1\rang)}\\
&= 2^0+2^1+2^1+2^2+2^2+2^3\\
&= 21.
\end{aligned}
$$

### 数据规模与约定

**本题采用 Subtask 的计分方式。**

| 子任务编号 |    $n$    | 分值 |
| :--------: | :-------: | :--: |
|    $1$     |  $\le4$   | $5$  |
|    $2$     |  $\le10$  | $20$ |
|    $3$     | $\le100$  | $20$ |
|    $4$     | $\le10^3$ | $25$ |
|    $5$     | $\le10^7$ | $30$ |



## 样例 #1

### 输入

```
3```

### 输出

```
21```

# AI分析结果

### 综合分析与结论
这些题解主要围绕通过找规律或动态规划（DP）来解决问题。多数题解发现了答案的递推规律，即 \( f(i)=(2^i - 1)f(i - 1) \)，进而得出 \( f(n)=\prod_{i = 1}^n(2^i - 1) \)，并通过 \( O(n) \) 的递推实现。少数题解如NaCly_Fish的通过分块优化和Chirp Z - Transform将时间复杂度优化到 \( O(\sqrt{n}\log n) \)。

### 所选的题解
- **作者：Rainybunny（5星）**
    - **关键亮点**：思路清晰，先介绍各子任务考察点，再通过DP推导出递推公式 \( f(i)=(2^i - 1)f(i - 1) \)，并给出简洁代码实现。
    - **个人心得**：无
    - **重点代码**：
```cpp
const int MOD = 1e9 + 7;
int main() {
    int n, ans = 1, pwr = 1;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        (pwr <<= 1) >= MOD && (pwr -= MOD);
        ans = ans * (pwr - 1ll) % MOD;
    }
    printf("%d\n", ans);
    return 0;
}
```
    - **核心实现思想**：通过循环计算 \( 2^i \) 并取模，同时累乘 \( 2^i - 1 \) 的结果并取模得到最终答案。

- **作者：NaCly_Fish（5星）**
    - **关键亮点**：不仅给出常规 \( O(n) \) 做法，还通过分块优化和Chirp Z - Transform将时间复杂度优化至 \( O(\sqrt{n}\log n) \)，方法较为新颖。
    - **个人心得**：无
    - **重点代码**：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define N 262147
#define ll long long
#define p 998244353
using namespace std;
// 快速幂函数
inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}
// 省略部分初始化和变换函数
int f[N],g[N];
int n,B,z,pw,res = 1;
int main(){
    scanf("%d",&n);
    B = sqrt(n);
    init(B<<1|1);
    getpoly(2,B,f);
    czt(f,B,power(2,B));
    for(int i=0;i!=B;++i) res = (ll)res*f[i]%p;
    pw = power(2,B*B+1);
    for(int i=B*B+1;i<=n;++i){
        res = (ll)res*(pw-1)%p;
        pw = (pw<<1)>=p?(pw<<1)-p:pw<<1;
    }
    printf("%d\n",res);
    return 0;   
}
```
    - **核心实现思想**：先分块计算 \( g_B(x) \) 的系数，再用Chirp Z - Transform计算 \( g(c^i) \) 的值，最后结合剩余部分计算出最终结果。

- **作者：Joker_1212（4星）**
    - **关键亮点**：详细证明了递推结论 \( \sum\limits_\sigma 2^{\tau(\sigma)} = \prod\limits_{i = 1}^n (2^i -1) \)，逻辑连贯，代码简洁明了。
    - **个人心得**：无
    - **重点代码**：
```cpp
const int mod = 1e9 + 7;
int main()
{
#ifdef LOCAL
    freopen("./in.in", "rb", stdin);
    freopen("./out.out", "wb", stdout);
#endif
    int n;
    cin >> n;
    ll ans = 1, power = 1;
    while (n--)
    {
        power <<= 1;
        power %= mod;
        ans *= power - 1;
        ans %= mod;
    }
    cout << ans << endl;
    return 0;
}
```
    - **核心实现思想**：利用循环，每次更新 \( power \) 为 \( 2^i \) 并取模，同时累乘 \( power - 1 \) 并取模得到最终答案。

### 最优关键思路或技巧
通过分析排列中第一个元素对逆序对数量的影响，建立递推关系。如固定第一个元素后，后面元素构成的子问题与 \( n - 1 \) 时的情况相关，通过枚举第一个元素的值计算逆序对数，得出递推公式 \( f(i)=(2^i - 1)f(i - 1) \)，从而简化计算。

### 可拓展思路
此类题目属于计数类问题，可拓展到其他与排列、逆序对相关的计数问题。类似算法套路为从简单情况入手，分析子问题与原问题的关系，建立递推式求解。

### 推荐题目
- [P1338 末日的传说](https://www.luogu.com.cn/problem/P1338)：与排列和逆序对相关，考察对排列逆序对性质的理解。
- [P5367 [SDOI2019] 排列计数](https://www.luogu.com.cn/problem/P5367)：同样是关于排列的计数问题，涉及到组合数学和递推的知识。
- [P2517 [HAOI2010] 计数](https://www.luogu.com.cn/problem/P2517)：通过分析排列的性质来解决计数问题，锻炼对排列相关问题的解题能力。

### 个人心得摘录与总结
- **作者：cmk666**：在机房和同学竞争最优解，通过分段打表优化时间复杂度，但受代码长度限制。总结为在追求更优解法时，要注意实际的限制条件，权衡不同优化方法的利弊。 

---
处理用时：38.70秒
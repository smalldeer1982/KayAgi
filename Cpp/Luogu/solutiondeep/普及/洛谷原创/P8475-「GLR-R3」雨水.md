# 题目信息

# 「GLR-R3」雨水

## 题目背景

&emsp;&emsp;「天将化雨舒清景，萌动生机待绿田」

---

&emsp;&emsp;在天依面前口口声声说着习惯了，才开学没几天，文化课和乐队训练的压力可是又让阿绫头疼呢。

&emsp;&emsp;浓缩为一个晚上的周末。站在阳台上，摸索朦胧于雨声的城市轮廓。雨水之日的雨，对于眼前的高楼大厦——们，恐怕也难有一些别样的意境吧。

&emsp;&emsp;“雨水节令的雨、白露节令的露、霜降节令的霜、小雪节令的雪各十二钱……”

&emsp;&emsp;胡乱想着，阿绫噗嗤一声笑了出来，“但是不管在哪里，雨中的空气，雨后的初阳，总是清新得叫人欢喜。”向着雨幕笑笑，拨弄这手里的旧吉他，不知不觉哼起那首歌来。

---

&emsp;&emsp;**雨水**&emsp;「等凉雨　的温度　将不安燥热中和　寻觅着　风的波折」

## 题目描述



身后的门被敲响，接过天依包回来的一大盒多肉，放下东西贴贴一会儿之后，她们决定把多肉们在阳台上排成一排。

多肉们的高度不尽相同，天依先将一共 $n$ 盆多肉随意排成一排，从左到右第 $i$ 盆的高度为 $a_i$。为了美观，她希望交换某些多肉的位置，使得由高度组成的序列 $A$ 的**字典序**尽可能小，不过，为了照顾多肉们的感受（？）她要求阿绫只能选取 $A$ 的一个**长度为偶数的子序列**（长度可以为 $0$），交换序列里第 $1$ 盆和第 $2$ 盆，第 $3$ 盆和第 $4$ 盆……的位置，然后放回它们原来的位置中。

苦活交给了阿绫，思考的工作自然交给你啦！请告诉阿绫，仅使用**一次**选取子序列的操作，她能够得到的字典序最小的新高度序列 $A'$。

#### 形式化题意

给定一个长为 $n$ 的整数序列 $A$，下标从 $1$ 开始。你可以**任取一个**自然数 $k$ 以及一个序列 $\lang 1,2,\dots,n\rang$ 的，长度为 $2k~(k\in\mathbb N)$ 的**子序列** $P$，并对于所有 $i=1,2,\dots,k$，交换 $A_{P_{2i-1}}$ 与 $A_{P_{2i}}$ 的值。求在所有可能得到的新序列 $A'$ 中，**字典序** 最小的序列。

**字典序**：对于长度为 $n$ 的序列 $A$ 和 $B$，定义 $A$ 的字典序小于 $B$，当且仅当：

$$
\exists i\in[1,n], (\forall j\in[1,i), A_j=B_j)\land A_i<B_i.
$$

**注意**：本题输入输出方式具有特殊性。详见「输入格式」与「输出格式」。


## 说明/提示

#### 样例 #1 解释

生成的序列为 $A=\lang 1,1,3,0,0,1,3\rang$，选取 $k=1,P=\lang 1,5\rang$, 得到答案序列为 $A'=\lang 0,1,3,0,1,1,3\rang$，按照要求计算知答案为 $43$。

#### 样例 #2 解释

生成的序列为 $A=\lang 2,8,0,6,2,2,1,7,8,3\rang$，选取 $k=3,P=\lang 1,3,4,7,8,10\rang$, 得到答案序列为 $A'=\lang 0,8,2,1,2,2,6,3,8,7\rang$，按照要求计算知答案为 $256$。

### 数据规模与约定

**本题采用 Subtask 的计分方式。**

对于 $100\%$ 的测试数据，$1\le n\le10^7$，$2\le \textit{thres}\le10^9$，$0\le k_1,k_2<2^{64}$。

对于不同的子任务，作如下约定：

 | 子任务编号 |    $n$    |     $\textit{thres}$     | 特殊性质 | 分值 |
| :--------: | :-------: | :---------: | :------: | :--: |
|    $1$     | $\le10^5$ |  $\le10^9$   |  **有**  | $10$ |
|    $2$     |   $\le20$    | $\le10$ |    无    | $15$ |
|    $3$     | $\le10^7$ | $=2$  |    无    | $20$ |
|    $4$     | $\le10^7$ | $\le10^7$ |    无    | $25$ |
|    $5$     | $\le10^7$ | $\le10^9$ |    无    | $30$ |

- **特殊性质**：保证程序正确生成的序列 $A$ 中不存在相等元素。

- **注意**：本题时限为 $0.5\text s$。

- ~~热知识：《世末歌者》演唱于夏日，显然不在雨水节气。~~


## 样例 #1

### 输入

```
7 20120712 21702102 4```

### 输出

```
43```

## 样例 #2

### 输入

```
10 114514 19198 10```

### 输出

```
256```

# AI分析结果

### 综合分析与结论
所有题解均采用贪心策略解决该问题，核心思路是为使字典序最小，每次都将当前位置的数与它后面的最小值交换（若当前数大于后面的最小值），且当有多个最小值时选择最靠后的那个。部分题解通过预处理后缀最小值及其位置来优化时间复杂度至\(O(n)\)，部分未优化的时间复杂度为\(O(n^2)\)。在思路清晰度、代码可读性和优化程度上，各题解存在差异。

### 所选的题解
1. **作者：TernaryTree（5星）**
    - **关键亮点**：思路阐述极为清晰，从对交换对数的区间性质分析入手，逐步深入讲解贪心策略，详细讨论了各种情况下的处理方式，并且对时间复杂度的优化和取模细节都有清晰说明，代码规范且注释详细。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e7 + 1; 
long long int n, a[MAXN + 1];
int suf[MAXN + 1];
namespace Generator {
    unsigned long long k1, k2;
    int thres;
    inline unsigned long long xorShift128Plus() {
        unsigned long long k3 = k1, k4 = k2;
        k1 = k4, k3 ^= (k3 << 23), k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
        return k2 + k4;
    }
    inline void generate() {
        for (register int i = 1; i <= n; ++i) {
            a[i] = xorShift128Plus() % thres;
        }
    }
} 
void init() {
    suf[n] = n;
    for (int i = n - 1; i >= 1; i--) {
        suf[i] = (a[i] < a[suf[i + 1]]? i : suf[i + 1]);
    }
}
unsigned long long solve() {
    int s = 1;
    while (s <= n - 1) {
        int m = suf[s + 1];
        if (a[s] > a[m]) {
            swap(a[s], a[m]);
            s = m + 1;
        } else s++;
    } 
    unsigned long long ans = 0;
    for (register int i = 1; i <= n; ++i) {
        ans += (unsigned long long) a[i] * (unsigned long long) i;
    }
    return ans;
}
int main() {
    scanf("%d", &n);
    scanf("%llu %llu %d", &Generator::k1, &Generator::k2, &Generator::thres);
    Generator::generate();
    init();
    cout << solve();
    return 0;
}
```
    - **核心实现思想**：`init`函数预处理后缀最小值位置`suf`数组。`solve`函数通过`while`循环，每次判断当前位置`s`的数与后缀最小值`suf[s + 1]`的大小，若当前数大则交换并更新位置，否则移动到下一个位置，最后计算答案。
2. **作者：pomelo_nene（4星）**
    - **关键亮点**：先从简单子任务入手分析，逐步引导出通用的贪心策略，思路连贯，代码简洁明了，直接给出核心代码且对关键步骤有注释说明。
    - **个人心得**：无
    - **核心代码**：
```cpp
int main(){
    scanf("%d", &n);
    scanf("%llu %llu %d", &Generator::k1, &Generator::k2, &Generator::thres);
    Generator::generate();
    a[0]=2147483647;
    for(int i=n;i;--i) pos[i]=(a[i]<a[pos[i+1]]?i:pos[i+1]);
    for(int i=1;i<=n;++i) {
        if(a[i]==a[pos[i]]) continue;
        swap(a[i],a[pos[i]]),i=pos[i];
    }
    unsigned long long ans=0;
    for(int i=1;i<=n;++i) ans+=(unsigned long long)i*(unsigned long long)a[i];
    printf("%llu",ans);
    return 0;
}
```
    - **核心实现思想**：先初始化`a[0]`为极大值，通过循环从后往前确定每个位置后面的最远最小值位置`pos`数组。再通过循环，若当前位置数与对应`pos`位置数不同则交换并更新位置，最后计算答案。
3. **作者：iiiiiyang（4星）**
    - **关键亮点**：对题意简化清晰，快速抓住贪心本质，代码实现简洁，对关键步骤有注释，且提到了题目中一些细节问题如数组下标设置和数据不卡\(O(n^2)\)做法。
    - **个人心得**：吐槽题目英文表述和数据不卡\(O(n^2)\)做法。
    - **核心代码**：
```cpp
inline void work()
{
    key[n+1]=INF;
    for(int i=n;i>=2;i--)
    {
        key[i]=key[i+1],pos[i]=pos[i+1];
        if(a[i]<key[i]) key[i]=a[i],pos[i]=i;
    }
    int mink,minp;
    for(int i=1;i<n;i++)
    {
        mink=key[i+1],minp=pos[i+1];
        if(mink<a[i]) swap(a[i],a[minp]),i=minp;
    }
    return;
}
```
    - **核心实现思想**：先初始化`key[n + 1]`为极大值，通过循环从后往前确定每个位置后面的最小值`key`及其位置`pos`。再通过循环，若当前位置数大于后面的最小值则交换并更新位置。

### 最优关键思路或技巧
1. **贪心策略**：为使字典序最小，每次将当前位置数与它后面的最小值交换（当当前数大于后面最小值时），并且选择多个最小值中最靠后的那个，以保证字典序最小且为后续交换留下更多优化空间。
2. **预处理优化**：通过从后往前遍历数组，预处理出每个位置后面的最小值及其位置，这样在每次判断是否交换时，查询最小值位置的时间复杂度降为\(O(1)\)，从而将整体时间复杂度从\(O(n^2)\)优化到\(O(n)\)。

### 可拓展之处
此类题目属于贪心策略在序列交换问题上的应用，相似类型题通常围绕如何通过有限操作使序列满足某种顺序要求（如字典序、递增/递减序等）。常见套路是分析操作对序列顺序的影响，确定贪心选择标准，比如本题中每次选择后面最小且最靠后的数交换。

### 相似知识点洛谷题目
1. **P1090 [NOIP2004 提高组] 合并果子**：通过贪心策略解决合并操作次数最小化问题，与本题类似之处在于都需确定一个贪心选择标准来优化结果。
2. **P1199 [NOIP2010 普及组] 三国游戏**：涉及对游戏策略的贪心分析，判断如何选择能使结果最优，与本题思路都是基于某种目标进行贪心决策。
3. **P2123 皇后游戏**：同样是通过分析操作对序列的影响，利用贪心策略解决问题，在思考方式上与本题有相似性。 

---
处理用时：42.05秒
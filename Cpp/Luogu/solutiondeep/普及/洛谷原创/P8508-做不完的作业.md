# 题目信息

# 做不完的作业

## 题目背景

高中的任务是非常艰巨的，要学习十门功课（浙江要学技术）。导致作业超级加倍，这一点在暑假就已经体现出来了。

作业的总量是一定的，但不同作业下发的时间是不一定的，导致每天都要花不同的时间应付作业。此时，如何保证睡眠是一个需要仔细考虑的问题。

## 题目描述

**提示：如果你对题目内容有疑问，可以配合样例更好地阅读。**

有 $n$ 个任务，第 $i$ 个任务需要 $t_i$ 的时间。Eric 要在若干天内**依次**完成这些任务。Eric 是一个专注的人，所以完成每个任务的时间**必须连续**。

一天有 $x$ 的时间。由于 Eric 需要睡觉，所以 Eric 不能利用所有的时间。具体地：

- Eric 每天**必须睡觉**；
- Eric 每天的睡觉的时间是连续的，且睡觉时间结束后，第二天恰好开始；
- Eric **前 $\boldsymbol i$ 天**的睡觉时间**总和**不能少于 $r\cdot x\cdot i$ 的时间。$r$ 是一个给定的实数，$i$ 是一个正整数。

Eric 想问你，至少需要多少天才能完成任务。

## 说明/提示

#### 样例 1 解释

下面是一种可能的方案：

Eric 先在第一天做任务 1，总共消耗 $1$ 的时间，用 $4$ 时间睡觉，满足至少要 $5\times \dfrac 1 3=\dfrac 5 3$ 的时间睡觉的要求。

Eric 再在第二天加班加点，完成剩下的任务，有 $1$ 的时间睡觉。两天睡觉总量为 $5\ge 10\times \dfrac 1 3=\dfrac {10} 3$，也是满足要求的。

#### 样例 2 解释

Eric 试图在第一天完成任务 1，但假如要做就会熬夜，觉就不够睡。所以 Eric 第一天只能睡大觉。Eric 在第二天完成任务 1 就没有问题。

同时请注意，即使睡觉时间满足了要求，Eric 也不能在第二天就完成任务 2，因为 Eric 必须睡觉。所以 Eric 先睡到第三天，然后完成任务 2。可以证明不存在方案小于三天。

同时注意数据**不保证** $\gcd(p,q)=1$。

#### 样例 3 解释

显然一天只能干一件活，所以要 $10$ 天。

#### 样例 4 解释

该样例满足子任务 3 的限制条件。

#### 样例 5 解释

该样例满足子任务 5 的限制条件。

### 数据规模与约定

**本题捆绑测试**。对于所有数据，保证 $1\le n\le 10^5$，$1\le t_i<x\le 10^6$，$1\le p<q\le 10^6$。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline

\bf 子任务 & \bf 分值 & n\le & \bf特殊性质
\\
\hline
1 & 10 & 3 & /\\\hline
2 & 20 & 10^3 & \bf A \\\hline
3 & 20 & / & \bf A\\\hline
4 & 20 & / & \bf B\\\hline
5 & 30 & / & /\\\hline
\end{array}
$$

特殊性质 $\bf A$：$\forall i,\ \dfrac{t_i}{x}+\dfrac{p}{q}\le 1$。

特殊性质 $\bf B$：$n\times q\le 10^6$。

为了减少评测量，本题开启子任务依赖。具体地，当且仅当前四个子任务全部通过时，子任务 5 才计分，否则子任务 5 计 $0$ 分。

## 样例 #1

### 输入

```
3 5 1 3
1 2 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 10 4 10
9 1```

### 输出

```
3```

## 样例 #3

### 输入

```
10 2 1 2
1 1 1 1 1 1 1 1 1 1```

### 输出

```
10```

## 样例 #4

### 输入

```
见下发文件 task/task4.in```

### 输出

```
见下发文件 task/task4.ans```

## 样例 #5

### 输入

```
见下发文件 task/task5.in```

### 输出

```
见下发文件 task/task5.ans```

# AI分析结果

• 综合分析与结论：这些题解都采用贪心策略解决该问题。先按顺序考虑任务，若当天能完成且满足睡觉时间要求就做，否则睡觉。对于直接模拟会TLE的情况，通过计算连续睡觉天数优化，避免每天模拟。部分题解还给出倒序插入任务的贪心思路。
• 所选的题解：
  - 作者：5ab_juruo (5星)
    - 关键亮点：思路清晰，给出两种贪心实现方法，代码简洁且有注释。
    - 个人心得：无
    - 重点代码：
```cpp
// 第一种做法
signed main()
{
    n = read(), m = read(), p = read();
    ll q = read();
    for (int j = 1; j <= n; j++) a[j] = read();
    int ans1 = 0, ans2 = 0;
    int tot = 1, sl = 0;
    for (int j = 1;; j++)
    {
        if (0 < m * p * j - (m - a[tot] + sl) * q)
        {
            int i = (m * p * j - (m - a[tot] + sl) * q + (m * (q - p)) - 1) / (m * (q - p));
            j += i, sl += i * m;
        }
        int x = m;
        while (1)
        {
            if (tot == n + 1) break;
            if (x <= a[tot]) break;
            if ((x - a[tot] + sl) * q < m * p * j) break;
            x -= a[tot], tot++;
        }
        sl += x;
        if (tot == n + 1)
        {
            ans1 = j;
            break;
        }
    }
    cout << ans1;
    return 0;
}
```
核心实现思想：按顺序处理任务，当当天无法完成任务时，计算需要连续睡几天才能继续完成任务。
```cpp
// 第二种做法
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, x, p, q;
    ll sm = 0;

    cin >> n >> x >> p >> q;
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
        sm += a[i];
    }

    ll ans = 0, cnt = 0, csm;
    for (int i = n - 1; i >= 0;)
    {
        chmax(ans, cnt + cdiv(sm * q, 1ll * x * (q - p)));

        csm = 0;
        while (i >= 0 && a[i] + csm < x)
            csm += a[i--];
        sm -= csm, cnt++;
    }

    cout << ans << endl;

    return 0;
}
```
核心实现思想：倒序插入任务，每次更新完成任务所需天数。
  - 作者：ArcherHavetoLearnWhk (4星)
    - 关键亮点：思路阐述详细，代码注释详尽，对计算连续睡觉天数的公式推导有说明。
    - 个人心得：比赛时要会分析复杂度，避免浮点数运算，否则会丢精度。
    - 重点代码：
```cpp
int main()
{
    n = read(), x = read(), p = read(), q = read();
    long long i = 1;
    long long sum = 0;
    long long t = 0;
    while (n--)
    {
        long long w;
        w = read();
        if ((x - t - w + sum) * q >= i * p * x && x - t > w)
            t += w;
        else
        {
            sum += x - t;
            i++;
            long long l = ceil((q * (sum + x - w) - p * i * x) * 1.0 / (x * p - x * q));
            if (l > 0)
            {
                sum += x * l;
                i += l;
            }
            t = w;
        }
    }
    write(i);
    return 0;
}
```
核心实现思想：按顺序处理任务，判断当天能否完成，不能则计算连续睡觉天数。
  - 作者：heaksicn (4星)
    - 关键亮点：先分析暴力做法及得分情况，再给出优化思路，逻辑清晰。
    - 个人心得：无
    - 重点代码：
```cpp
signed main()
{
    n = read(), x = read(), p = read(), q = read();
    int sum = 0;
    for (int i = 1; i <= n; i++) a[i] = read(), sum += a[i];
    int ans = 0;
    int nw = 0;
    int i = n;
    while (i)
    {
        ans = max(ans, nw + (sum * q + x * (q - p) - 1) / (x * (q - p)));
        int cnt = 0;
        while (i && cnt < x - a[i]) cnt += a[i], i--;
        sum -= cnt;
        nw++;
    }
    write(ans);
    return 0;
}
```
核心实现思想：倒序处理任务，每次计算完成当前任务及剩余任务所需天数。
• 最优关键思路或技巧：采用贪心策略，按顺序或倒序处理任务，当遇到当天无法完成任务的情况时，通过推导公式计算出需要连续睡觉的天数，避免对每天进行模拟，从而优化时间复杂度。
• 可拓展思路：此类题目属于任务分配与时间规划的贪心类型，类似套路是分析任务执行条件和限制，通过数学推导优化时间复杂度。例如在资源分配、行程规划等场景中，可根据具体限制条件采用类似贪心策略。
• 相似知识点洛谷题目：
  - P1080 [NOIP2012 提高组] 国王游戏：涉及贪心策略和高精度计算。
  - P1199 [NOIP2010 普及组] 三国游戏：考察贪心和博弈策略。
  - P1248 加工生产调度：利用贪心算法解决生产调度问题。
• 个人心得摘录与总结：ArcherHavetoLearnWhk提到比赛时要注重复杂度分析，避免使用浮点数运算，否则会因精度问题导致错误，这是在解决此类问题时需要特别注意的地方。 

---
处理用时：38.35秒
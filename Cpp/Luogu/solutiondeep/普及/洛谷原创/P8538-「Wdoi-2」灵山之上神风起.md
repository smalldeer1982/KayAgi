# 题目信息

# 「Wdoi-2」灵山之上神风起

## 题目背景

在天狗记者射命丸文的指（放）引（水）之下，灵梦一行人找到了山中的神社。

“在妖怪之山上还真的存在其他的神社啊。”灵梦感慨道。她们看到了由树木建造的神社正殿，以及正殿前的参拜道上的一排御柱，而更远处则是一片湖——风神之湖。湖面非常开阔，波光粼粼，一碧万顷，远处似乎有群山环抱，让人心旷神怡。

到达神社之时已经是傍晚了。正当灵梦和魔理沙感慨之时，见到在她们面前有一位白衣蓝裙的少女，东风谷早苗，拥有着引发奇迹程度的能力。为了找到守矢神社中的两位神灵，灵梦与魔理沙，向东风谷早苗产生了激烈的交战。

“那就在现人神的力量洗礼中思索吧！这召唤奇迹的神明之力！”

## 题目描述

### 简要题意

给定一个长度为 $n$ 的正整数序列 $a$ 满足对于所有 $i\in [1,n]$ 有 $a_i \in \{1,2,3\}$。

现在通过该序列构造一张含 $n$ 个节点，节点编号为 $1$ 到 $n$ 的图：对于数 $i$，如果 $a_i=1$，那么什么都不做；如果 $a_i=2$，那么向所有比 $i$ 小的数的节点连无向边；如果 $a_i=3$，那么向所有比 $i$ 大的数的节点连无向边。求出该图的最大独立集的大小。

最大独立集，指的是原图中一个点数尽量多的点集，这些点在原图中两两之间没有边**直接**相连。

### 原始题意

然而，东风谷早苗（后称早苗）的弹幕密度相当之高，使人应接不暇，灵梦只得想个方法去减少她需要关注的弹幕数量。

数个回合过后，她发现，早苗每次释放弹幕只会释放出 $n$ 个弹幕，分别编号为 $1,2,\dots,n$，而她每释放一个弹幕，都会对应着产生一次神力波动。因而她的神力波动可以抽象为一个长度为 $n$ 的正整数数列 $\{a_n\}$。由于她的资历尚浅，只会使用三种神力，分别用 $1,2,3$ 表示，即 $\forall i \in [1,n]$，$a_i \in \{1,2,3\}$。

她发现，早苗的三种神力作用各不相同，具体而言如下：

- 当 $a_i=1$ 时，她不会做任何事情。
- 当 $a_i=2$ 时，早苗会让第 $i$ 个弹幕向所有弹幕编号**小于** $i$ 的弹幕建立神力输送通道。
- 当 $a_i=3$ 时，早苗会让第 $i$ 个弹幕向所有弹幕编号**大于** $i$ 的弹幕建立神力输送通道。

接着，在各种神力的交互配合之下，密集的弹幕将展开于灵梦的眼前。而一旁的魔理沙发现，若是从这些弹幕中挑选出**尽可能多的**一群弹幕，使得每个弹幕之间不存在直接相连的神力输送通道，那么这群弹幕会产生【引发奇迹程度的能力】，是不必关注的。

由于【引发奇迹程度的能力】只能被触发**一次**，灵梦和魔理沙想要知道，**最多**有多少个弹幕是不必关注的。她们找到了你，希望你能帮她解答。

## 说明/提示

### 样例解释

根据题意显然可以构造出如下的图。其中 $a_i=2$ 的用蓝色边表示，$a_i=3$ 的用红色边表示。

显然选取第 $2,3$ 个弹幕（已用绿色填图）是最多的情况。实际上对于这个样例，选取弹幕的方案不止一种，但是不存在更多的情况了。

![](https://cdn.luogu.com.cn/upload/image_hosting/99a854cu.png)

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值}\\\hline
1 & 10 & - & 20\\\hline
2 & 10^5 & \text{A} & 10\\\hline
3 & 10^5 & \text{B} & 30 \\\hline
4 & 10^5 & - & 40 \\\hline
\end{array}$$

- 特殊性质 $\text{A}$：所有的 $a_i=1$；
- 特殊性质 $\text{B}$：所有的 $a_i$ 不是 $1$ 就是 $2$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$a_i \in \{1,2,3\}$。

## 样例 #1

### 输入

```
6
3 1 3 2 1 2```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕构造图的最大独立集展开，核心思路均基于对不同类型节点（$a_i = 1, 2, 3$）性质的分析。
 - **思路**：多数题解发现选取的$a_i \neq 1$的节点个数不会大于等于3，且$a_i = 1$的节点两两不连边，$a_i = 2$的节点会与编号小的节点连边，$a_i = 3$的节点会与编号大的节点连边，基于此讨论不同情况计算最大独立集。
 - **算法要点**：通过遍历序列，统计$a_i = 1$的节点数量，同时记录$a_i = 2$和$a_i = 3$节点的特殊位置（如最左、最右），根据不同组合情况计算最大独立集大小。
 - **解决难点**：难点在于证明并理解$a_i \neq 1$的节点选取个数限制及不同类型节点组合方式对独立集大小的影响，部分题解还需注意特殊情况（如无$a_i = 1$的节点）的处理。

综合来看，各题解思路相近，主要差异在代码实现细节和对特殊情况处理的清晰程度上。

### 所选的题解
- **作者：chen_zhe（5星）**
    - **关键亮点**：思路清晰，先证明$a_i \neq 1$的节点选取个数性质，再分四种情况详细讨论并给出代码实现，对第四种情况的特判讲解清晰。
    - **核心代码**：
```cpp
#include <iostream>
using namespace std;
int n,a[100050],l,r;
int main()
{
    cin >> n;
    for (int i=1;i<=n;i++)
        cin >> a[i];
    for (int i=1;i<=n;i++)
    {
        if (a[i]==2)
        {
            l=i;
            break;
        }
    }
    for (int i=n;i>=1;i--)
    {
        if (a[i]==3)
        {
            r=i;
            break;
        }
    }
    int ans=0;
    if (l)
    {
        int ret=1;
        for (int i=l+1;i<=n;i++)
            ret+=(a[i]==1);
        ans=max(ans,ret);
    }
    if (r)
    {
        int ret=1;
        for (int i=1;i<=r-1;i++)
            ret+=(a[i]==1);
        ans=max(ans,ret);
    }
    if (l && r && r>l)
    {
        int ret=2;
        for (int i=l+1;i<=r-1;i++)
            ret+=(a[i]==1);
        ans=max(ans,ret);
    }
    int ret=0;
    for (int i=1;i<=n;i++)
        ret+=(a[i]==1);
    ans=max(ans,ret);
    cout << ans << endl;
    return 0;
}
```
    - **核心实现思想**：先找到最左的$a_i = 2$的位置$l$和最右的$a_i = 3$的位置$r$，然后分四种情况计算独立集大小：全选$a_i = 1$的节点；选最左$a_i = 2$及右边$a_i = 1$的节点；选最右$a_i = 3$及左边$a_i = 1$的节点；选最左$a_i = 2$和最右$a_i = 3$及中间$a_i = 1$的节点，取四种情况的最大值。
 - **作者：Keids（4星）**
    - **关键亮点**：表述简洁，通过对样例分析得出关键性质，即$a_i = 1$的节点两两不连边，$2$和$3$操作的点各最多取一个，代码实现简洁明了。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,l=0,r=0,sum=0;
int a[500010];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        if(a[i]==1){
            sum++;
            if(!l)l=i;
            if(i>r)r=i;
        }
    }
    for(int i=1;i<=l;i++){
        if(a[i]==2){
            sum++;break;
        }
    }
    for(int i=r;i<=n;i++){
        if(a[i]==3){
            sum++;break;
        }
    }
    printf("%d",sum);
    return 0;
} 
```
    - **核心实现思想**：遍历序列统计$a_i = 1$的节点个数$sum$，记录第一个和最后一个$a_i = 1$的节点位置$l$和$r$，然后在$l$之前找$a_i = 2$的节点，$r$之后找$a_i = 3$的节点，若找到则$sum$加1，最后输出$sum$。
 - **作者：Gaode_Sean（4星）**
    - **关键亮点**：利用前缀和思想统计$a_i = 1$的个数，清晰列出答案的四种情况，代码简洁高效。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,a[N],s[N],l,r;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){scanf("%d",&a[i]);s[i]=s[i-1]+(a[i]==1);}
    for(int i=1;i<=n;i++) if(a[i]==3) r=i;
    for(int i=n;i>=1;i--) if(a[i]==2) l=i;
    int ans=s[n];
    if(l) ans=max(ans,s[n]-s[l-1]+1);
    if(r) ans=max(ans,s[r]+1);
    if(l&&r&&r>l) ans=max(ans,s[r]-s[l-1]+2);
    printf("%d",max(ans,1));
    return 0;
}
```
    - **核心实现思想**：用数组$s$记录前缀和表示前$i$个元素中$a_i = 1$的个数，找到最左的$a_i = 2$位置$l$和最右的$a_i = 3$位置$r$，按四种情况计算答案并取最大值，最后特判答案至少为1。

### 最优关键思路或技巧
 - **思维方式**：通过对不同类型节点连边性质的深入分析，得出$a_i \neq 1$的节点选取个数限制，从而简化问题为几种可枚举的情况。
 - **代码实现技巧**：利用遍历序列记录特殊节点位置（如最左$a_i = 2$、最右$a_i = 3$），结合统计$a_i = 1$的节点数量，分情况计算最大独立集大小，部分题解使用前缀和优化计算过程。

### 可拓展之处
此类题目属于图论中基于特定规则构造图并求解相关图性质（如最大独立集）的问题。相似套路是深入分析题目给定的节点连接规则，挖掘节点组合的限制条件，进而简化求解过程。同类型题可能会改变节点连接规则或所求图性质，如求最大团、最小支配集等。

### 相似知识点洛谷题目
 - [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)：涉及图的染色和最大独立集相关知识。
 - [P1129 驾车旅行](https://www.luogu.com.cn/problem/P1129)：结合图论和模拟，需分析节点间关系。
 - [P2746 星际转移问题](https://www.luogu.com.cn/problem/P2746)：图论中的网络流问题，同样需要分析节点和边的特性。

### 个人心得摘录与总结
无。 

---
处理用时：40.72秒
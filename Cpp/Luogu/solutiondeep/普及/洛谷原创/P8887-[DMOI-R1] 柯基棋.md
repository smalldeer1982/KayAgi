# 题目信息

# [DMOI-R1] 柯基棋

## 题目背景

小 A 和小 B 都是爱狗人士，且绝顶聪明，尤其喜爱柯基，于是他们发明了“柯基棋”。

## 题目描述

小 A 和小 B 在一个 $n \times n$ 的棋盘内轮流下棋。小 A 先手，小 B 后手。设当前有一只“柯基”被下在了棋盘的 $(x,y)$ 处，那么棋盘内的 $(x-1,y-1)$，$(x-1,y+1)$，$(x+1,y-1)$，$(x+1,y+1)$ 处都会变为这只“柯基”的地盘，也就不能再放一只“柯基”。当一个人不能再放下一只“柯基”时，他就输了。

可惜，小 C 却不怎么喜欢柯基，所以他很反对小 A 和小 B 玩“柯基”棋，于是他非常喜欢捣乱棋局。当小 A 和小 B 一共下了 $x_i$ 只“柯基”时，小 C 就会以当前 $w \times w$ 棋盘的中心为中心，扩大棋盘为 $(w+2) \times (w+2)$，他一共会捣乱 $q$ 次。

而你的任务是要判断这局棋是小 A 赢还是小 B 赢，如果小 A  赢，输出 `A won`，否则输出 `B won`。

由于他们两个人比较贪玩，所以他们一共会玩 $T$ 局。

**注意**：

1. 当小 A 和小 B 已经将原来的棋盘下到不能再下时，他们会直接跳转到小 C 下一次的捣乱（如果有）。

2. 小 A 和小 B 知道小 C 会捣乱，且会按照自己的最优策略走。

由于数据过大，$x_i$ 由数据随机生成器给出。

## 说明/提示

### 随机数据生成器

每一轮游戏的 $x_i$ 由下方的生成器给出：

```cpp
unsigned long long x[10000005];
unsigned long long xor_shift(unsigned long long &seed){
  return seed^=seed>>12, seed^=seed<<25, seed^=seed>>27, seed*0x2545F4914F6CDD1D;
}
int main(){
  //your code here
  int n,q;
  unsigned long long seed;
  cin>>n>>q>>seed;
  for(int i=1;i<=q;i++){
	x[i]=x[i-1]+((xor_shift(seed)%(unsigned long long)(2*2)+1))*2;
  }
  //your code here
  return 0;
}
```

### 样例解释

对于第一局游戏，$x_i$ 数组如下：`6 8 16 18 22`。

对于第二局游戏，$x_i$ 数组如下：`8 14 16 24 32 36 38 40`。

对于第三局游戏，$x_i$ 数组如下：`4 8 10 16`。

### 数据范围

对于 $20\%$ 的数据，$n,q\leq100$。

对于 $50\%$ 的数据，$n,q\leq10000$。

对于 $100\%$ 的数据，$1 \le T \le 10,2\leq n,q,\sum q \leq 10^7$，$x_i \equiv 0 \pmod 2\ (i\in[1,q]),0 \le seed \le 10^7$。


## 样例 #1

### 输入

```
3
2 5 493
3 8 3219
8 4 1294```

### 输出

```
B won
A won
B won```

# AI分析结果

• 综合分析与结论：这些题解思路相近，均先考虑静态棋盘下的博弈策略，发现棋盘边长奇偶性决定胜负，奇数时先手小A胜，偶数时后手小B胜。再分析动态棋盘，因棋盘边长每次增加2且小C捣乱时改变的步数为偶数，所以棋盘边长奇偶性与先后手顺序不变，原结论适用。算法要点在于判断棋盘边长奇偶性，难点是发现并证明棋盘边长奇偶性与博弈胜负的关系及动态棋盘下该关系的稳定性。
• 所选的题解：
  - 作者：Vct14 (5星)
    - 关键亮点：思路清晰，先探索出静态棋盘下基于棋盘中心或中心线对称的下棋策略决定胜负，再说明动态棋盘下因中心、中心线、边长奇偶性和先后手顺序不变，所以原结论适用，代码简洁明了。
    - 重点代码：
```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    int T;
    cin>>T;
    while(T--){
        int n,q,seed;
        cin>>n>>q>>seed;
        if(n%2) cout<<"A won";
        else cout<<"B won";
        cout<<"\n";
    }
    return 0;
}
```
核心实现思想：通过输入多组测试数据，每组数据中判断棋盘边长n的奇偶性，若为奇数输出“A won”，偶数输出“B won”。
  - 作者：GoodLuckCat (4星)
    - 关键亮点：先类比类似博弈题目，阐述奇数边长棋盘先手中心对称放置的策略，再详细分析偶数边长棋盘利用轴对称后手必胜的策略，对动态棋盘的分析结合数据生成器和题面条件，逻辑较严谨。
    - 重点代码：
```cpp
#include<iostream>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n,q,s;
        cin>>n>>q>>s;
        if(n%2)cout<<'A';
        else cout<<'B';
        cout<<" won\n";
    }
}
```
核心实现思想：输入多组测试数据，在每组数据中根据棋盘边长n的奇偶性输出对应的赢家。
  - 作者：yitian_ (4星)
    - 关键亮点：简洁清晰地阐述思路，直接点明n每次变化为加2所以奇偶性不变，进而分别说明奇数、偶数边长时的获胜策略，代码简洁易懂。
    - 重点代码：
```c
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        int n,p,s;
        cin >> n >> p >> s;
        if(n%2==0) 
        {
            cout << "B won" << endl;
        } 
        else cout << "A won" << endl;
    }
    return 0;
}
```
核心实现思想：输入多组测试数据，每组数据根据n的奇偶性判断并输出谁获胜。
• 最优关键思路或技巧：通过对静态棋盘的分析，利用棋盘的对称性（中心对称或轴对称）得出基于棋盘边长奇偶性的博弈策略，同时在动态棋盘下，抓住棋盘边长变化规律和步数变化特点，证明原策略的有效性。
• 可拓展之处：此类题目属于博弈论结合动态变化场景的类型，类似套路是先分析静态场景下的最优策略，再研究动态变化对策略的影响，关键在于找到变化中的不变量。
• 相似知识点洛谷题目：
  - P1288 取数游戏II，涉及博弈策略与奇偶性分析。
  - P2197 模板 - Nim游戏，典型的博弈论题目。
  - P1199 [NOIP2010 普及组] 三国游戏，同样考察博弈策略。
• 个人心得：无。 

---
处理用时：22.56秒
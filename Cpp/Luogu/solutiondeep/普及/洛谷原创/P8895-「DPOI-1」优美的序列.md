# 题目信息

# 「DPOI-1」优美的序列

## 题目背景

#### Update on 2022.12.18：新增一组针对 @[zhuoxingmu](https://www.luogu.com.cn/user/421155) 的 Hack 数据，放置于 #21，分值为 $5$ 分。
#### Update on 2022.12.18：新增一组针对 @[大眼仔Happy](https://www.luogu.com.cn/user/537046) 的 Hack 数据，放置于 #22，分值为 $5$ 分。
------------
不可以，总司令。

## 题目描述

总司令给你一个长为 $n$ 的序列 $a$。

他认为这个 $a$ 现在也许不够优美，他希望将其重排为一个 $a'$，使之变得优美。

我们称一个长为 $n$ 的序列 $a$ 优美，当且仅当 $\exists i \in [1,n]$，满足：

- $\forall j \in [1, i)$，$a_j > a_{j + 1}$。
- $\forall j \in (i, n]$，$a_j > a_{j - 1}$。

他命令你求出 $a$ 经过重排可以得到多少个不同的 $a'$。由于结果可能很大，你只需要求出结果对 $p$ 取模的值。

由于一个固定的 $a$ 太无趣了，于是他给你 $m$ 次修改，每次修改形如 `x k`，表示令 $a_x \leftarrow k$。你需要在每次修改后求出当前的答案。

## 说明/提示

#### 样例 #1 解释
对于初始状态，满足条件的 $a'$ 有 $[2, 1, 2, 3], [3, 2, 1, 2]$，共 $2$ 个。

对于第一次修改后的 $a = [1, 2, 4, 3]$，满足条件的 $a'$ 有 $[1, 2, 3, 4], [2, 1, 3, 4], [3, 1, 2, 4], [4, 1, 2, 3], [3, 2, 1, 4], [4, 2, 1, 3], [4, 3, 1, 2], [4, 3, 2, 1]$，共 $8$ 个。
#### 样例 #2 解释
该样例满足测试点 $15 \sim 20$ 的限制。
#### 数据范围
| 测试点编号 | $n \leq$ | $m \leq$ | 特殊条件 |
| :------: | :------: | :------: | :------: |
| $1 \sim 2$ | $10$ | $10$ | 无 |
| $3 \sim 4$ | $100$ | $100$ | 无 |
| $5 \sim 6$ | $10^3$ | $10^3$ | 无 |
| $7 \sim 10$ | $10^5$ | $10^5$ | 无 |
| $11 \sim 12$ | $5 \times 10^5$ | $0$ | $a$ 为一个**排列** |
| $13 \sim 14$ | $5 \times 10^5$ | $0$ | 无 |
| $15 \sim 20$ | $5 \times 10^5$ | $5\times 10^5$ | 无 |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$0 \leq m \leq 5 \times 10^5$，$2 \leq p \leq 10^9$，$1 \leq a_i, k, x \leq n$。

## 样例 #1

### 输入

```
4 1 998244353
1 2 2 3
3 4```

### 输出

```
2
8```

## 样例 #2

### 输入

```
见下发文件 sequence2.in```

### 输出

```
见下发文件 sequence2.out```

# AI分析结果

### 综合分析与结论
所有题解思路核心相似，均先分析无解情况（最小值个数大于1或存在出现次数大于2的数时无解），再针对有解情况，利用出现一次且非最小值的数的个数计算方案数为\(2^{cnt}\) 。
1. **思路**：均围绕找出序列中的最小值及统计各数出现次数判断是否有解，有解时根据出现一次的数的个数计算方案数。
2. **算法要点**：
    - 预处理2的幂，方便快速计算方案数。
    - 使用数据结构维护数的出现次数及最小值。如用桶（数组）、multiset、权值线段树等。
3. **解决难点**：关键在于准确判断无解情况，以及动态维护数的出现次数和最小值，以应对多次修改操作。

### 题解分析
1. **Leasier**：
    - **星级**：5星
    - **关键亮点**：思路清晰，对“优美”条件转化准确，详细阐述构造合法序列方式及答案推导过程。代码简洁明了，使用multiset维护最小值，桶维护数的出现次数，时间复杂度\(O((n + m) \log n)\) 。
    - **核心代码**：
```cpp
inline void add(int x){
    cnt[x]++;
    s.insert(x);
    if (cnt[x] == 1){
        cnt1++;
    } else if (cnt[x] == 2){
        cnt1--;
    } else if (cnt[x] == 3){
        cnt2++;
    }
}
inline void output(){
    if (cnt2 > 0 || cnt[*s.begin()] > 1){
        printf("0\n");
    } else {
        printf("%d\n", power[cnt1 - 1]);
    }
}
inline void del(int x){
    cnt[x]--;
    s.erase(s.lower_bound(x));
    if (cnt[x] == 0){
        cnt1--;
    } else if (cnt[x] == 1){
        cnt1++;
    } else if (cnt[x] == 2){
        cnt2--;
    }
}
```
    - **核心实现思想**：`add`函数增加数的计数并更新`cnt1`（出现一次的数的个数）和`cnt2`（出现次数大于2的数的个数），`output`函数判断无解情况并输出答案，`del`函数减少数的计数并更新相应统计量。
2. **Micnation_AFO**：
    - **星级**：4星
    - **关键亮点**：采用计数 + 权值线段树方法，用权值线段树维护数的出现次数相关信息，判断无解情况并计算方案数。代码结构清晰，利用线段树实现对数据的高效维护。
    - **核心代码**：
```cpp
void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r;
    if (l == r) { t[p].num = t[p].dat = t[p].sum = 0; return; }
    int mid = (l + r) >> 1;
    build(p << 1, l, mid), build((p << 1) | 1, mid + 1, r);
    t[p].num = t[p].dat = t[p].sum = 0;
}
void change(int p, int x, int v) {
    if (t[p].l == t[p].r) {
        t[p].sum += v, t[p].dat += v;
        if (t[p].sum == 1) t[p].num = 1;
        else t[p].num = 0;
        return;
    }
    int mid = (t[p].l + t[p].r) >> 1;
    if (x <= mid) change(p << 1, x, v);
    if (x > mid) change((p << 1) | 1, x, v);
    t[p].sum = t[p << 1].sum + t[(p << 1) | 1].sum;
    t[p].num = t[p << 1].num + t[(p << 1) | 1].num;
    t[p].dat = max(t[p << 1].dat, t[(p << 1) | 1].dat);
}
int ask(int p) {
    if (t[p].l == t[p].r) return t[p].sum;
    int val = t[p << 1].sum;
    if (val) return ask(p << 1);
    return ask((p << 1) | 1);
}
```
    - **核心实现思想**：`build`函数初始化线段树节点，`change`函数实现单点修改并更新线段树节点的统计信息，`ask`函数用于查询最小值的出现次数。
3. **大眼仔Happy**：
    - **星级**：4星
    - **关键亮点**：先简化题意，通过具体例子引导思路，清晰阐述分析过程。虽初始代码时间复杂度高，但指出优化方向即使用线段树维护最小值，可将时间复杂度优化到\(O((n + m) \log n)\) 。
    - **个人心得**：分享自己在计算\(s3\)时犯错但代码仍通过部分测试点，后被出题人用数据Hack的经历，强调代码细节的重要性。
    - **核心代码（优化前）**：
```cpp
ll QuickPow(ll a,ll b)
{
    ll res=1;
    while(b>0)
    {
        if(b&1)res=(res*a)%p;
        a=(a*a)%p;b>>=1;
    }
    return res;
}
ll calc()
{
    if(s3)return 0;
    ll Min=LONG_LONG_MAX;
    for(int i=1;i<=n;i++)Min=min(Min,a[i]);
    if(tong[Min]!=1)return 0;
    return QuickPow(2,s1-1);
}
```
    - **核心实现思想**：`QuickPow`函数实现快速幂计算，`calc`函数判断无解情况并计算答案，每次计算最小值时遍历数组。

### 最优关键思路或技巧
1. **数据结构选择**：利用multiset或权值线段树动态维护最小值和数的出现次数，高效处理多次修改操作。
2. **数学推导**：准确分析出无解条件，通过合理构造合法序列得出方案数为\(2^{cnt}\)的结论，简化计算过程。

### 可拓展思路
同类型题常考察对序列性质的分析及利用数据结构维护动态信息。类似算法套路是先确定关键元素（如本题最小值），分析元素出现次数对结果的影响，再选择合适数据结构维护信息以应对动态操作。

### 相似知识点洛谷题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：基础线段树模板题，用于巩固线段树单点修改和区间查询的操作。
2. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)：涉及利用数据结构维护序列中数的出现次数相关问题，可类比本题对出现次数的维护。
3. [P2672 [NOIP2015 提高组] 推销员](https://www.luogu.com.cn/problem/P2672)：需要分析序列性质并结合数据结构优化算法，与本题思路有相似之处。 

---
处理用时：43.38秒
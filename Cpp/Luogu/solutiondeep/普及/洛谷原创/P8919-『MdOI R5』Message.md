# 题目信息

# 『MdOI R5』Message

## 题目描述

小 A 有一个群。这个群正在玩一个小游戏：给出一个函数 $f$，从某一个时间点起，发送第 $x$ 条消息，而 $f(x)=1$ 的群友会受到一个小惩罚。当群内消息总数达到 $m$ 时游戏结束。

但小 A 是个话痨，这段时间他在这个群发了 $n$ 条消息，他发的第 $i$ 条消息在整个消息记录里是第 $a_i$ 条消息。

但是小 A 不想受到惩罚，而小 A 恰好是管理员，他可以撤回**任何时刻、任何群成员发的任何消息**，注意这会导致这条消息之后的消息排名改变。

但是撤回消息太多容易被当成暴政，因此他要尽可能减少撤回信息次数，不管是自己的还是别人的。

接下来你也猜到你要干什么了：假如其他群成员不操作，给出 $n$、函数 $f$ 和 $a_i$，求出他至少要撤回几条消息。

## 说明/提示

【样例解释】

下面给出一种可能的方式：
- 小 A 先撤回第 $1$ 条消息（群友发的），他的四条消息在消息记录里现在是第 $1,5,7,10$ 条。
- 然后撤回第 $5$ 条消息（他自己发的），剩下三条消息在消息记录里现在是第 $1,6,9$ 条。

此时三条消息满足 $f(1)=f(6)=f(9)=0$，符合题意。

可以证明无法仅撤回一条消息达成要求。

【数据范围】

|Subtask|$n\le$|$m\le$|特殊性质|分值|
|:-:|:-:|:-:|:-:|:-:|
|1|$17$|$17$||$15$|
|2|$17$|$100$||$15$|
|3|$10^3$|$10^4$||$20$|
|4||$10^5$|$n=m$|$8$|
|5|$10^5$|$10^6$|A|$12$|
|6|$10^5$|$10^6$||$30$|

- 特殊性质 A：小 A 没有连发两条消息。

对于全部数据，$1\le n\le 10^5$，$1\le a_i\le m\le 10^6$，$a_i$ 严格递增，$f(i)\in \{0,1\}$。

## 样例 #1

### 输入

```
4 11
01101010001
2 6 8 11
```

### 输出

```
2
```

# AI分析结果

• 综合分析与结论：
    - 多数题解思路围绕贪心策略展开，即撤回自己的消息总是优于撤回别人的消息。原因在于撤回别人消息可能使自己后续消息仍受惩罚，而撤回自己消息可确保该消息不受罚，且对后续消息排名影响相同。
    - 不同题解针对不同数据范围采用不同算法。对于小数据量（Subtasks 1和2），采用枚举法；对于大数据量，从暴力更新消息排名（时间复杂度 \(O(n^2 + m)\)）优化到利用变量维护撤回消息数，从而避免实时更新排名，将时间复杂度优化至 \(O(n + m)\)。
    - 部分题解还提到了如树状数组差分优化等方法进一步优化时间复杂度。

• 所选的题解：
  - 作者：yummy (5星)
    - 关键亮点：对每个子任务分别给出详细解法，从简单枚举到逐步优化，思路清晰，代码简洁高效，对贪心策略的阐述和各子任务的分析透彻。
    - 重点代码及核心思想：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005];
char f[1000005];
int main()
{
    int withdrawn=0; 
    scanf("%d%d%s",&n,&m,f+1);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        if(f[a[i]-withdrawn]=='1')
            withdrawn++;
    }
    printf("%d",withdrawn);
    return 0;
}
```
核心思想是从前往后遍历小A发的消息，通过 `withdrawn` 变量记录撤回消息数，每次判断当前消息位置减去已撤回消息数后的位置对应的 `f` 值，若为 `1` 则撤回该消息并更新 `withdrawn`。

  - 作者：igAC (4星)
    - 关键亮点：用贪心思路解题，先感性证明撤回自己消息更优，再给出代码实现，思路较清晰，代码简洁。
    - 重点代码及核心思想：
```cpp
#include<cstdio>
#include<iostream>
#define N 1000005
using namespace std;
bool vis[N];
int n,m;
int a[N];
int cnt=0;
int main(){
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;++i){
        char c;
        cin>>c;
        vis[i]=(c=='1');
    }
    for(int i=1;i<=m;++i) scanf("%d",&a[i]);
    for(int i=1;i<=m;++i){
        int p=a[i]-cnt;
        if(vis[p]) ++cnt;
    }
    printf("%d",cnt);
    return 0;
}
```
核心思想与 `yummy` 的类似，通过 `cnt` 记录撤回消息数，计算当前消息实际位置，判断该位置是否受罚，若受罚则更新 `cnt`。

  - 作者：Infinite_Eternity (4星)
    - 关键亮点：从暴力解法出发，逐步优化，先发现暴力解法时间复杂度高的原因，再通过使用计数器优化，思路连贯，易于理解。
    - 重点代码及核心思想：
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    register char c = getchar();
    register int x = 0, f = 1;
    while (c < '0' || c > '9') {if (c == '-') f = -1;c = getchar();}
    while (c >= '0' && c <= '9') {x = (x << 3) + (x << 1) + c - 48;c = getchar();}
    return x * f;
}
int main()
{
    int n,m,ans=0,cnt=1;
    n=read(),m=read();
    int num[m],text[m];
    char in[m];
    for (register int i=0; i<m; ++i)
    {
        in[i]=getchar();
        num[i]=in[i]-48;
    }
    for (register int i=0; i<n; ++i)
        text[i]=read();
    for (register int i=0; i<n; ++i)
    {
        if (num[text[i]-cnt]==1)
        {
            cnt++,ans++;
        }
    }
    printf("%d",ans);
    return 0;
}
```
核心思想是先暴力模拟撤回消息过程，发现每次撤回消息后更新所有消息位置导致时间复杂度高，于是用 `cnt` 记录撤回消息数，判断当前消息是否受罚时减去 `cnt` 得到实际位置。

• 最优关键思路或技巧：利用贪心策略，优先撤回自己的消息。同时，通过维护一个变量记录撤回消息数，避免每次撤回消息后对后续所有消息排名进行实时更新，从而优化时间复杂度。

• 可拓展之处：此类题目属于贪心策略结合数组操作的类型，类似套路可应用于其他涉及元素位置调整且需满足一定条件的优化问题。例如，在一些资源分配问题中，根据不同策略选择分配资源，同时考虑资源调整对后续元素的影响。

• 推荐洛谷题目：
  - [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)：涉及贪心策略，通过对数据的排序和分析，确定最优分配方案。
  - [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：典型的贪心问题，根据接水时间对任务进行排序以得到最优解。
  - [P1199 三国游戏](https://www.luogu.com.cn/problem/P1199)：需要运用贪心策略并结合一定的逻辑分析来解决问题。

• 个人心得：无。 

---
处理用时：33.54秒
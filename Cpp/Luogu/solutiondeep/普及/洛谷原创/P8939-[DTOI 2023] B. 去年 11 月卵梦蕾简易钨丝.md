# 题目信息

# [DTOI 2023] B. 去年 11 月卵梦蕾简易钨丝

## 题目背景

# 大样例已修复

![](https://cdn.luogu.com.cn/upload/image_hosting/4il8fn7w.png)

## 题目描述

给定序列 $\{a_n\}$，支持两种形如 `opt x` 操作：

1. `1 x`：删除一个数 $x$，若序列中没有 $x$，则输出 $-1$ 并跳过本次操作，**若有多个 $x$，则仅删除一个**。

2. `2 x`：向序列中插入一个数 $x$。

**对于每个未被跳过的操作**，试求出 $a$ 的一个排列 $p$，最小化 $\sum \limits_{i=1}^{n} \lvert p_{i+1}-p_i\rvert$ 的值，即最小化 $\lvert p_2-p_1\rvert+\lvert p_3-p_2\rvert+\dots+\lvert p_{n+1}-p_n\rvert$ 的值，其中 $p_{n+1}=p_1$。

**保证任意时刻序列内至少有 $1$ 个数。**

---
$p$ 是 $a$ 的排列当且仅当对于 $\forall x$，$\sum [p_i=x]=\sum [a_i=x]$。

简而言之，$p$ 是 $a$ 经过某种方式重排后的结果。 

例如 $\{1,1,4,5,1,4\}$ 是 $\{1,5,4,1,4,1\}$ 的一个排列，但是 $\{1,5,4,1,4,7\}$ 不是。

## 说明/提示

#### 【样例 1 解释】
对于第一个询问，删除了序列中的数 $4$，则当前序列为$ 1, 2, 3, 10 $， 可以证明 $18$ 为当前序列的最小答案。
	
对于第二个询问，删除了序列中的数 $10$，则当前序列为$ 1, 2, 3 $， 可以证明 $4$ 为当前序列的最小答案。
	
对于第三个询问，向序列中添加了一个数 $9$，则当前序列为$ 1, 2, 3, 9 $， 可以证明 $16$ 为当前序列的最小答案。

#### 【样例 2】

见附加文件中的 `abs/abs2.in` 与 `abs/abs2.out`。

该样例满足测试点 $1\sim 4$ 的限制。

#### 【样例 3】

见附加文件中的 `abs/abs3.in` 与 `abs/abs3.out`。

该样例满足测试点 $7\sim 10$ 的限制。

#### 【数据范围与提示】
记 $w$ 为值域大小，对于所有测试数据，保证 $n,q\leq 10^6$，$0\leq w\leq 10^6$。
	
每个测试点的具体限制见下表：

| 测试点编号 | $n,q\leq$ | $w$ |
| :----------: | :----------: | :----------: |
| $1\sim 4$ | $100$ | $10$ |
| $5\sim 6$ | $10^3$ | $10^3$ |
| $7\sim 10$ | $10^6$ | $10^6$ |


## 样例 #1

### 输入

```
5 3
1 2 3 4 10
1 4
1 10
2 9```

### 输出

```
18
4
16```

# AI分析结果

• 综合分析与结论：
    - 思路：多数题解发现当序列 \(p\) 单调不降时，\(\sum \limits_{i = 1}^{n}|p_{i + 1} - p_i|\) 可取得最小值，此时答案为 \(2 \cdot (\max{p} - \min{p})\)。因此核心问题转化为动态维护序列的最大值和最小值。
    - 算法要点：主要使用 `multiset` 或优先队列（`priority_queue`）来维护序列的最值。`multiset` 能有序存储元素，方便获取最大最小值；优先队列可快速插入和删除堆顶元素，但需配合桶来处理元素存在性问题。
    - 解决难点：难点在于如何高效地支持插入和删除操作，并准确维护最大值和最小值。例如在删除操作中，若删除的是最值，需更新最值；同时要处理元素不存在的情况。

    综合来看，各题解思路相似，主要差异在于实现方式和代码细节。

    最优关键思路或技巧：利用序列单调时目标式子取最小值这一性质，将问题简化为维护最值问题，使用 `multiset` 或优先队列配合桶的方式高效实现。

    可拓展之处：此类题目属于动态维护数据结构并求特定值的类型，类似套路可应用于其他需要动态维护最值、区间和等问题，例如在序列上进行插入、删除操作并实时求最值或区间和。

    推荐洛谷题目：
        - P1886 滑动窗口 /【模板】单调队列：考察单调队列维护区间最值。
        - P3378 【模板】堆：练习堆的基本操作，如插入、删除、查询最值。
        - P4767 [IOI2000]邮局：结合动态规划与维护区间最值相关知识。

    个人心得：无。

    所选题解：
  - 作者：mc123456 (5星)
    - 关键亮点：思路清晰，简洁明了地阐述性质和实现方式，代码简洁且规范。
    ```cpp
    int n, q;
    multiset<int> s;
    signed main()
    {
        cin.tie(0), cout.tie(0), ios::sync_with_stdio(0);
        cin >> n >> q;
        for (int i = 1, a; i <= n; i++)
            cin >> a, s.emplace(a);
        while (q--)
        {
            int op, x;
            cin >> op >> x;
            if (op == 1)
            {
                auto it = s.find(x);
                if (it == s.end())
                {
                    cout << -1 << endl;
                    continue;
                }
                s.erase(it);
            }
            else
                s.emplace(x);
            cout << (*(--s.end()) - *s.begin()) * 2 << endl;
        }
    }
    ```
    核心实现思想：使用 `multiset` 存储序列元素，利用 `find` 查找元素，`erase` 删除元素，通过 `--s.end()` 和 `s.begin()` 获取最大最小值并计算答案。

  - 作者：InoueTakina (4星)
    - 关键亮点：先给出暴力枚举思路及复杂度分析，再提出优化思路，逻辑连贯，对结论的证明和分析较为详细。
    - 算法1代码略，综合时间复杂度 $\mathcal{O}(q\times w!)$。
    - 算法2代码：
    ```cpp
    int n,q;
    int a;
    int opt;
    multiset<int>s;
    multiset<int>::iterator it;
    int main(){
        ios::sync_with_stdio(0);
        cin.tie(0);cout.tie(0);
        cin>>n>>q;
        while(n--){
            cin>>a;
            s.insert(a);
        }
        while(q--){
            cin>>opt>>a;
            if(opt==1){
                it=s.lower_bound(a);
                if(*it!=a){
                    cout<<-1<<'\n';
                    continue;
                }
                s.erase(it);
            }
            else s.insert(a);
            int ans=*(--s.end())-*s.begin();
            cout<<2*ans<<'\n';
        }
        return 0;
    }
    ```
    核心实现思想：与上一代码类似，使用 `multiset` 维护序列，利用 `lower_bound` 查找元素，若找到则删除，否则输出 `-1`，每次操作后计算并输出最大最小值差值的两倍。

  - 作者：WsW_ (4星)
    - 关键亮点：对使用 `multiset` 维护的操作细节描述清晰，如插入、删除的具体方式，便于理解。
    ```cpp
    int n,q;
    int a;
    int opt;
    multiset<int>s;
    multiset<int>::iterator it;
    int main(){
        ios::sync_with_stdio(0);
        cin.tie(0);cout.tie(0);
        cin>>n>>q;
        while(n--){
            cin>>a;
            s.insert(a);
        }
        while(q--){
            cin>>opt>>a;
            if(opt==1){
                it=s.lower_bound(a);
                if(*it!=a){
                    cout<<-1<<'\n';
                    continue;
                }
                s.erase(it);
            }
            else s.insert(a);
            int ans=*(--s.end())-*s.begin();
            cout<<2*ans<<'\n';
        }
        return 0;
    }
    ```
    核心实现思想：通过 `multiset` 实现对序列的维护，`lower_bound` 用于查找元素位置，判断是否为要删除的元素，是则删除，否则跳过；插入操作直接使用 `insert`，最后输出最大最小值差值的两倍。 

---
处理用时：33.91秒
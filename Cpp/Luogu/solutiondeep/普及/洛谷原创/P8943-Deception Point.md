# 题目信息

# Deception Point

## 题目背景

“防空火网已启用。”三角洲二号喊道，他坐在“基奥瓦”武装直升机舱门边的武器控制椅里，竖起了大拇指，“火力网
、调制噪声、掩护脉冲全都激活并锁定。”

三角洲一号心领神会，驾驶着飞机猛地向右一个侧弯飞机又驶上了一条前往“戈雅”的直线路径。这一招能躲过“戈雅”的雷达监控。

“锡箔包确定！”三角洲二号喊道。

> 绝对的孤立，

三角洲一号想。

> 他们毫无抵抗力。

他们的目标幸运且狡猾地从米尔恩冰架上逃脱了，但这回他们不会再得逞了。雷切尔 · 塞克斯顿和迈克尔 · 托兰选择弃岸上船，真是糟糕的选择。不过，这将是他们所做的最后一个坏决定了。

## 题目描述

雷切尔与迈克尔被困在了“戈雅”号上，而三角洲二号正在顺着雷达追杀二人。幸运的是，雷切尔也有一副雷达，因此双方都能知道对方的位置。

船舱内部共有 $n$ 个舱室，其中有 $n$ 条走廊连接这些舱室。$n$ 个舱室是互相连通的。由于船上空间拥挤，船舱内不会出现小于等于四条走廊组成的环。每过一分钟，雷切尔与三角洲二号都会同时从一个舱室跑到另一个舱室。

如果雷切尔在舱室内或者过道上碰到了三角洲，那么就意味着大限将至。雷切尔总共有 $q$ 个问题：当她在舱室 $x$，且三角洲二号在舱室 $y$ 时，她是否可以存活下来？

---

#### **【形式化题意】**

给定一张 $n$ 个点 $n$ 条边的无向连通图，图内不存在四元（及以下）环。$q$ 次询问 $x,y$，分别在图上 $x,y$ 点上放上棋子 $\rm A, B$。

每次两人同时操作棋子沿图边移动一步，若两棋子同时走到了同一个点上或者同时走过了相同的边，则 $\rm B$ 胜利。如果在 $10^{10^{9961}}$ 次操作后 $\rm B$ 还未胜利，则 $\rm A$ 胜利。

$\rm A,B$ 都是绝顶聪明的，他们不会做出对自己不利的决策。请你求出每次游戏的游戏结果。若 $\rm A$ 获胜，输出 `Survive`；否则输出 `Deception`。

**若对题意有疑问，请移步样例解释与数据范围部分。**

## 说明/提示

#### 【样例解释】

船舱结构图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/tlsqnsia.png)

在第二组询问中，三角洲可以先走一步到达结点 $2$，此时雷切尔到达结点 $4$。随后可以证明，不存在一种方案使得雷切尔不碰到三角洲。

#### 【数据范围】

**本题开启捆绑测试。**

| $\text{Subtask}$ | 分值 | $n\le$ | $q\le$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $5$ | $2\times10^5$ | $1$ | 无 |
| $1$ | $5$ | $10$ | $2\times10^5$ | 无 |
| $2$ | $5$ | $2\times 10^5$ | $2\times10^5$ | $\forall 1\le i\le n, u_i=i,v_i=(i\bmod n) + 1$ |
| $3$ | $15$ | $200$ | $2\times 10^5$ | 无 |
| $4$ | $20$ | $2\times 10^3$ | $2\times 10^5$ | 无 |
| $5$ | $50$ | $2\times 10^5$ | $2\times 10^5$ | 无 |

对于 $100\%$ 的数据，$3\le n\le 2\times10^5$，$1\le q\le2\times10^5$，$u_i\neq v_i$，$x_i\neq y_i$。不存在四（及以下）元环。

## 样例 #1

### 输入

```
8 3
2 1
3 1 
4 2 
5 3
6 2
7 5
8 4
5 6
7 8
8 6
3 6```

### 输出

```
Survive
Deception
Survive
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路均基于图为基环树的特性，即 $n$ 个点 $n$ 条边且仅有一个环，且环大小大于4。核心在于判断雷切尔（A）能否在三角洲二号（B）堵住其入环点之前到达环上，为此需预处理环上点信息及各点到环的距离。
1. **思路**：找到图中的环，计算每个点到环的距离以及环上点之间的距离，通过比较A、B到A入环点的距离来判断A是否能存活。
2. **算法要点**：
    - **找环**：多种方法，如dfs标记法、拓扑排序、边双缩点、tarjan求割边等。
    - **计算距离**：对环上点和非环上点分别处理，非环点通过dfs或bfs计算到环的距离及入环点；环上点通过特定dfs或断边后bfs等方式计算点间距离。
    - **判断结果**：比较A到环的距离与B到A入环点的距离（B到环的距离 + A、B入环点在环上的距离）。
3. **解决难点**：
    - **找环**：需高效准确找出环，不同方法各有优劣，如dfs标记法相对简洁，边双缩点等较复杂但适用于更复杂图结构。
    - **计算环上点距离**：要在 $O(n)$ 时间内完成，利用环的特性，如记录点顺序、断边转化为链等方式实现。

整体来看，各题解思路相近，主要差异在找环和计算距离的具体实现，部分题解代码冗长或复杂，部分题解在思路和代码上更清晰简洁。

### 所选的题解
1. **作者：HYdroKomide (5星)**
    - **关键亮点**：思路清晰，步骤明确，代码注释详细。先通过dfs找到环上的点并标记，再处理非环上点与环的距离，最后根据A、B到环的距离及环上点距离判断结果。
    - **重点代码**：
```cpp
void dfs1(int x,int fa){//第一个 dfs，找到所有环上的点并标记
    if(vis[x]==true){//如果回到老地方，说明有环了
        fd=x;
        cir[x]=true;
        sw[x]=++cnt;//给环上的点依次打上标记，方便后面查询环上两点的距离
        return;
    }
    vis[x]=true;
    int u=g[x].size();
    for(int i=0;i<u;i++){
        int v=g[x][i];
        if(v!=fa)dfs1(v,x);
        if(fd!=0){
            if(fd==x)fd=0;
            if(!cir[x]){
                cir[x]=true;//回溯的时候就可以继续打标记
                sw[x]=++cnt;
            }
            break;
        }
    }
    return;
}
void dfs2(int old,int x,int fa){//处理所有非环上点与环的距离（深度）
    f[x]=old;//存踏上环的地点
    dep[x]=dep[fa]+1;
    int u=g[x].size();
    for(int i=0;i<u;i++){
        int v=g[x][i];
        if(!cir[v]&&g[x][i]!=fa)dfs2(old,v,x);
    }
}
```
核心实现思想：`dfs1`通过深度优先搜索，利用`vis`数组标记已访问点，当再次访问已访问点时确定环的起点，回溯时标记环上所有点并给环上点编号；`dfs2`从环上点出发，对非环上点进行深度优先搜索，记录每个非环上点踏上环的地点及到环的距离。
2. **作者：LHQing (4星)**
    - **关键亮点**：思路分析全面，对A、B不同位置情况进行分类讨论，采用拓扑排序找环，代码结构清晰。
    - **重点代码**：
```cpp
void get_ring()
{
    for (int i = 1; i <= n; i++)
    {
        if (deg[i] == 1)
        {
            que.push(i);
            deg[i]--;
        }
    }
    while (!que.empty())
    {
        int u = que.front();
        que.pop();
        for (int i = head[u]; i; i = e[i].nxt)
        {
            int v = e[i].v;
            if (deg[v] >= 1)
                deg[v]--;
            if (deg[v] == 1)
                que.push(v);
        }
    }
    for (int i = 1; i <= n; i++)
    {
        if (deg[i] >= 2)
            bk[i] = true, seq[++idx] = i;
    }
}
```
核心实现思想：`get_ring`通过拓扑排序，先将度数为1的点入队，不断从队列取出点并减少其邻接点度数，若邻接点度数变为1则入队，最后剩下度数大于等于2的点即为环上的点。
3. **作者：Register_int (4星)**
    - **关键亮点**：代码简洁，利用dfs找环并处理环上和非环上点信息，通过记录环上点位置实现 $O(1)$ 查询环上点距离。
    - **重点代码**：
```cpp
void dfs(int u, int f) {
    if (col[u]) {
        if (cnt) return ;
        for (int p = f; p!= u; p = fa[p]) a[pos[p] = ++cnt] = p;
        return a[pos[u] = ++cnt] = u, void();
    }
    fa[u] = f, col[u] = vis[u] = 1;
    for (int i = head[u]; i; i = e[i].nxt) {
        if (e[i].v!= f) dfs(e[i].v, u);
    }
    col[u] = 0;
}
```
核心实现思想：`dfs`在深度优先搜索过程中，若再次访问已标记点（`col[u]`为真），则从当前路径上的点开始记录环上的点，并给环上点编号。

### 最优关键思路或技巧
1. **利用基环树特性**：快速明确图结构，确定解题方向为判断A能否提前到达环。
2. **找环方法**：dfs标记法简单直接，适用于本题；拓扑排序从图的度数关系出发找环，思路清晰；这些方法可根据具体题目场景选择。
3. **环上距离计算**：通过给环上点编号，利用编号差及环长计算两点最短距离，实现 $O(1)$ 查询，提高效率。

### 可拓展之处
同类型题常围绕特殊图结构（如基环树、仙人掌图等）的路径、距离、博弈问题展开。类似算法套路是先分析图结构特性，确定关键要素（如环、特殊点等），再针对性预处理信息（如距离、连通性等），最后根据题目要求（如博弈结果、路径规划等）进行判断或计算。

### 相似知识点题目推荐
1. **P8655 基环树的直径**：同样涉及基环树结构，要求计算基环树的直径，考察对基环树结构的理解和距离计算。
2. **P2661 信息传递**：通过找环和计算环上距离解决问题，与本题在找环和利用环信息解题思路上相似。
3. **P3201 [HNOI2009] 梦幻布丁**：虽图结构不明显，但在处理相邻关系及优化查询上与本题有相似的思维方式，可锻炼图论相关思维。

### 个人心得摘录与总结
部分作者提到在找环时采用复杂方法导致代码冗长或出错，如使用边双缩点找环，虽理论可行但实现复杂易出错。启示是在解题时应优先考虑简单直接的方法，如本题dfs标记法找环既简洁又高效。同时，在处理复杂图论问题时，要深入理解图结构特性，选择合适算法，避免过度复杂的实现。 

---
处理用时：59.41秒
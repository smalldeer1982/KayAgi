# 题目信息

# 「CGOI-3」招魂术

## 题目背景

墓园的骷髅海！

要塞的禁魔球！

塔楼的三后排！

据点的破甲比蒙！

地下城的满魔抗黑龙！

![](https://cdn.luogu.com.cn/upload/image_hosting/j0kff14j.png)

###### 塔楼↑

-----
燊队来打英雄无敌 3 了。

## 题目描述

招魂术是墓园阵营的核心法术。

拥有招魂术的英雄，在每场战争结束后，能根据消灭的敌军数目来获得一定数量的骷髅。我们可以用整数 $A,B$ 来描述招魂术。设 $F_{A,B}(i)$ 表示消灭 $i$ 个敌人所能获得的骷髅数量，有：

$$F_{A,B}(1)=A,F_{A,B}(2)=B,F_{A,B}(x)=\lfloor \sqrt{F_{A,B}(x-2)F_{A,B}(x-1)}\rfloor+1\;(x \ge 3)$$

现在燊队要在酒馆招募一个英雄，英雄甲招魂术的属性为 $A,B$，英雄乙招魂术的属性为 $X,Y$。为了比较两个英雄招魂术的强弱，请你计算以下式子的值：

$$\prod_{i=1}^nF_{X,Y}(i)-F_{A,B}(i)$$

燊队当然知道怎么做，但他想考考你。

## 说明/提示

#### 样例说明

在样例说明中，设 $F_{A,B}$ 为 $f$，$F_{X,Y}$ 为 $g$。

对于第一组询问：

- $f$ 的前 $n$ 位为 $f=\{2,10,5,8,7\}$。

- $g$ 的前 $n$ 位为 $g=\{1,8,3,5,4\}$。

所以最终的答案为 $(1-2)\times(8-10)\times(3-5)\times(5-8)\times(4-7)=-36$，对 $998244353$ 取模后的结果是 $998244317$。

---

#### 数据范围

对于 $40\%$ 的数据，$n \le 100$。

对于另外 $10\%$ 的数据，每组询问满足 $A=B,X=Y$。

对于另外 $10\%$ 的数据，$T=1$。

对于 $100\%$ 的数据，$1 \le A,B,X,Y,n \le 10^9$，$1 \le T \le 5\times 10^4$。

## 样例 #1

### 输入

```
4
5 2 10 1 8
11 4 5 1 4
19 1 9 8 10
114 51 4 1919 810```

### 输出

```
998244317
998242817
939523984
604148977```

# AI分析结果

### 综合分析与结论
这三道题解都基于数列 \(F_{A,B}(x)\) 的性质进行优化求解。思路上，都利用均值不等式分析出数列 \(F_{A,B}(x)\) 会出现相邻两项相等的情况，且后续呈现一定规律，从而避免对 \(n\) 较大时的暴力计算。算法要点在于通过分析数列规律，结合快速幂优化计算。解决难点主要是发现数列规律以及处理不同情况下的乘积计算。

Register_int 题解直接在循环中判断数列是否进入稳定状态并利用快速幂优化；ztntonny 题解详细推导了不同情况下 \(n\) 较大时乘积的具体形式再用快速幂；JackMerryYoung 题解通过手模数据发现规律，分奇偶性讨论并用快速幂。

从质量上看，Register_int 题解思路和代码较简洁，ztntonny 题解推导详细但代码稍复杂，JackMerryYoung 题解代码为 Python 且未完整给出 C++ 代码，综合考虑，Register_int 和 ztntonny 的题解相对质量较高。

### 所选的题解
1. **Register_int 题解**
    - **星级**：4星
    - **关键亮点**：代码简洁，直接在循环中通过判断相邻两项关系，快速判断数列进入稳定状态，利用快速幂优化计算，减少计算量。
    - **重点代码**：
```cpp
for (int i = 3; i <= n; i++) {
    a = (ll)sqrtl(a * b) + 1, x = (ll)sqrtl(x * y) + 1;
    ans = ans * (x - a) % mod, swap(a, b), swap(x, y);
    if (a == b && x == y) { ans = ans * qpow(x - a, n - i) % mod; break; }
    if (a == b - 1 && x == y) { ans = ans * qpow(x - a, n - i + 1 >> 1) % mod * qpow(x - b, n - i >> 1) % mod; break; }
    if (a == b && x == y - 1) { ans = ans * qpow(x - a, n - i + 1 >> 1) % mod * qpow(y - a, n - i >> 1) % mod; break; }
}
```
    - **核心实现思想**：在循环中更新 \(F_{A,B}(x)\) 和 \(F_{X,Y}(x)\) 的值，同时计算差值乘积，当发现数列进入特定稳定状态时，利用快速幂计算剩余部分的乘积。
2. **ztntonny 题解**
    - **星级**：4星
    - **关键亮点**：对数列规律推导详细，分情况讨论 \(x_{F_{A,B}}\) 和 \(x_{F_{X,Y}}\) 取模 2 的不同情况，得出不同的乘积形式，并用快速幂实现，逻辑严谨。
    - **重点代码**：
```cpp
while ( f[++cmp1 - 1]!= f[cmp1 - 2] && cmp1 <= n + 3 )	f[cmp1] = ( (ll)( sqrt( f[cmp1 - 1] * f[cmp1 - 2] ) ) + 1 ) % MOD;
while ( g[++cmp2 - 1]!= g[cmp2 - 2] && cmp2 <= n + 3 )	g[cmp2] = ( (ll)( sqrt( g[cmp2 - 1] * g[cmp2 - 2] ) ) + 1 ) % MOD;
cmp1 -= 2, cmp2 -= 2, cmp = max( cmp1, cmp2 );
for ( ll i = 1; i <= min( n, cmp - 1 ); i++ )	ans *= ( gg( i ) - ff( i ) ) % MOD, ans %= MOD;
if ( cmp <= n )
{
    if ( cmp1 % 2 == cmp2 % 2 )	ans *= fpow( ( gg( cmp ) - ff( cmp ) ) % MOD, n - cmp + 1 ), ans %= MOD;
    else
    {
        ans *= fpow( ( ( gg( cmp ) - ff( cmp ) ) % MOD * ( gg( cmp + 1 ) - ff( cmp + 1 ) ) % MOD ) % MOD, ( n - cmp + 1 ) / 2 ), ans %= MOD;
        if ( ( n - cmp + 1 ) % 2 )	ans *= ( gg( cmp ) - ff( cmp ) ) % MOD, ans %= MOD;
    }
}
```
    - **核心实现思想**：先分别计算出 \(F_{A,B}(x)\) 和 \(F_{X,Y}(x)\) 中相邻两项相等的位置 \(cmp1\) 和 \(cmp2\)，然后先暴力计算前面部分的差值乘积，再根据 \(cmp1\) 和 \(cmp2\) 取模 2 的情况，用快速幂计算剩余部分的乘积。

### 最优关键思路或技巧
利用均值不等式分析数列 \(F_{A,B}(x)\) 的性质，发现其相邻两项相等的规律以及后续数列增长规律，通过分情况讨论，结合快速幂优化计算，避免对 \(n\) 较大时的暴力求解。

### 可拓展思路
此类题目可拓展到其他具有递推关系且存在规律的数列计算问题，通过分析数列性质优化计算。类似算法套路是先分析递推式特点，利用数学知识（如不等式、数列性质等）找出数列规律，再结合快速幂等优化算法进行计算。

### 相似知识点洛谷题目
1. **P1226 【模板】快速幂||取余运算**：基础的快速幂应用题目，帮助理解快速幂原理。
2. **P3390 【模板】矩阵快速幂**：将快速幂应用到矩阵乘法中，拓展快速幂的使用场景。
3. **P1962 斐波那契数列**：通过矩阵快速幂优化斐波那契数列的计算，与本题类似，都是利用数列规律优化计算。 

---
处理用时：33.95秒
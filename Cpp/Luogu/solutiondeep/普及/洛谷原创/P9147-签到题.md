# 题目信息

# 签到题

## 题目背景

著名的【数据删除】是一个热爱旅游的人！这一天他来到了神秘的 ZYL 国度。

入海关的时候他被问到了一个题目，如果答对他就可以顺利到达 ZYL 的首都 ZY 了！身为堂堂【数据删除】，他居然还花了 $10^{-233}$ 秒才想出来做法，实在是有点难的！于是他决定拿来考考你。

## 题目描述

给定长度为 $n$ 的序列 $a$，保证 $a_i$ 是**正整数**。你需要选择一个位置 $i$ 并将 $a_i$ 修改为一个**任意的整数**。最大化最长**严格**上升子串的长度。

所谓严格上升子串，就是从序列中选出位置**连续**的若干个数字，满足后一个数字比前一个大（而不能相等或小于）。

如序列 $[1,4,2,3,5]$ 中，子序列 $[2,3,5]$ 就是严格上升子串，而 $[4,2,3]$（不上升）和 $[1,2,3]$（不连续）则不是。

## 说明/提示

**【样例解释 \#1】**

对于样例 \#1，我们可以将序列 $[1,4,2,2,3]$ 中的第三个位置修改为 $5$，得到新序列 $[1,4,5,2,3]$。这个序列的最长严格上升子串是 $[1,4,5]$，长度为 $3$。

容易证明，不存在一种修改方案使得修改后的序列的最长严格上升子串的长度大于 $3$。

---

**【样例解释 \#4】**

对于样例 \#4，我们可以将序列 $[8,2,3,1,4,5]$ 中的第三个位置修改为 $0$，得到新序列 $[8,2,0,1,4,5]$。这个序列的最长严格上升子串是 $[0,1,4,5]$，长度为 $4$。

容易证明，不存在一种修改方案使得修改后的序列的最长严格上升子串的长度大于 $4$。

---

**【数据范围】**

对于前 $20\%$ 的数据，满足 $n \le 5$，$a_i \le 5$。  
对于前 $40\%$ 的数据，满足 $n \le 10$，$a_i \le 10$。  
对于前 $70\%$ 的数据，满足 $n \le 300$。  
对于 $100 \%$ 的数据，满足 $1 \le n \le {10}^6$，$1 \le a_i \le {10}^9$。

## 样例 #1

### 输入

```
5
1 4 2 2 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5
1 2 3 2 1
```

### 输出

```
4
```

## 样例 #3

### 输入

```
5
1 2 3 1 5
```

### 输出

```
5
```

## 样例 #4

### 输入

```
6
8 2 3 1 4 5
```

### 输出

```
4
```

## 样例 #5

### 输入

```
6
7 2 9 4 5 6
```

### 输出

```
5
```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解先想到暴力枚举修改位置的$O(n^2)$做法，然后考虑优化。优化思路主要是通过预处理以每个位置开头或结尾的最长严格上升子串长度，再枚举修改位置，根据相邻元素关系判断能否合并子串来计算答案，时间复杂度优化到$O(n)$。
    - 算法要点：预处理数组记录以每个位置开头或结尾的最长严格上升子串长度，利用递推公式计算；枚举修改位置，根据$a_{i + 1} - a_{i - 1}$与2的大小关系，判断能否合并前后子串并计算答案。
    - 解决难点：关键在于找到能合并前后严格上升子串的条件，以及如何高效预处理相关信息。

    各题解质量参差不齐，部分题解思路清晰、代码简洁，部分题解表述较混乱或代码冗余。

• 所选的题解：
  - 作者：syzf2222 (赞：26)  星级：5星
    - 关键亮点：思路清晰简洁，先指出最优修改方案，通过预处理出每个元素作为连续上升子序列开头与结尾时的最长长度，利用两者关系快速计算答案，时间复杂度$O(n)$。
    - 重点代码核心思想：通过两个循环递推预处理$f_i$和$g_i$数组，再遍历判断$a_{i + 1} - 1$与$a_{i - 1} + 1$关系来计算答案。
```cpp
// 预处理出未进行修改时，每个元素作为连续上升子序列的开头与结尾时的最长长度
for (int i = 1; i <= n; i++) {
    if (a[i] > a[i - 1]) f[i] = f[i - 1] + 1;
    else f[i] = 1;
}
for (int i = n; i >= 1; i--) {
    if (a[i] < a[i + 1]) g[i] = g[i + 1] + 1;
    else g[i] = 1;
}
int ans = 0;
for (int i = 1; i <= n; i++) {
    if (a[i + 1] - 1 >= a[i - 1] + 1) {
        ans = max(ans, g[i - 1] + 1 + f[i + 1]);
    } else {
        ans = max(ans, max(g[i - 1] + 1, f[i + 1] + 1));
    }
}
```
  - 作者：Iniaugoty (赞：11)  星级：4星
    - 关键亮点：详细阐述思路，从预处理数组定义选择，到递推公式给出，再到枚举修改位置的判断，逻辑连贯，代码可读性强。
    - 重点代码核心思想：同样通过两个循环递推计算$e_i$和$b_i$数组，然后遍历根据$a_{i - 1}$与$a_{i + 1} - 1$关系等三种情况计算答案。
```cpp
for (int i = 1; i <= n; i++)
    e[i] = a[i] > a[i - 1]? e[i - 1] + 1 : 1;
for (int i = n; i >= 1; i--)
    b[i] = a[i] < a[i + 1]? b[i + 1] + 1 : 1;
for (int i = 1; i <= n; i++) {
    if (a[i - 1] < a[i + 1] - 1)
        ans = max(ans, e[i - 1] + b[i + 1] + 1);
    if (a[i - 1] >= a[i])
        ans = max(ans, e[i - 1] + 1);
    if (a[i] >= a[i + 1])
        ans = max(ans, b[i + 1] + 1);
}
```
  - 作者：ttq012 (赞：8)  星级：4星
    - 关键亮点：清晰分析不同情况，对修改位置分边界和中间情况讨论，给出详细的条件判断和贡献计算方式，代码简洁明了。
    - 重点代码核心思想：先递推计算$f_i$和$g_i$数组，再遍历根据$a_{i + 1} - a_{i - 1}$与2的关系计算答案。
```cpp
for (int i = 1; i <= n; i++)
    if (a[i] > a[i - 1])
        f[i] = f[i - 1] + 1;
    else
        f[i] = 1;
for (int i = n; i; i--)
    if (a[i] < a[i + 1])
        g[i] = g[i + 1] + 1;
    else
        g[i] = 1;
int mx = 0;
for (int i = 1; i <= n; i++)
    if (a[i + 1] - a[i - 1] >= 2)
        mx = std::max(mx, f[i - 1] + g[i + 1] + 1);
    else
        mx = std::max(mx, std::max(f[i - 1], g[i + 1]) + 1);
```

• 最优关键思路或技巧：
    - 利用递推方式高效预处理以每个位置开头和结尾的最长严格上升子串长度。
    - 抓住修改一个数对其前后子串的影响，通过判断相邻元素差值确定能否合并子串。

• 可拓展之处：
此类题属于序列修改求最长子串问题，类似套路是预处理子串相关信息，根据修改条件判断能否合并子串。同类型题可改变子串性质（如改为最长非降子串）或修改条件（如限制修改为特定值）。

• 相似知识点洛谷题目：
    - P1090 [NOIP2004 提高组] 合并果子，涉及序列合并操作。
    - P1106 删数问题，与修改序列求最值有关。
    - P1439 【模板】最长公共子序列，同样是序列相关的子序列问题。

• 个人心得摘录与总结：
无明显个人心得相关内容。 

---
处理用时：34.55秒
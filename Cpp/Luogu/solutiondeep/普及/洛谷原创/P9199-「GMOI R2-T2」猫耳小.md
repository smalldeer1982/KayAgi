# 题目信息

# 「GMOI R2-T2」猫耳小

## 题目背景

**本题与 [加强版](https://www.luogu.com.cn/problem/P9202) 的区别在于数据范围和输出格式。在这一版本中，$n\le 5\times 10^3$，值域为 $5\times 10^3$，你不需要给出构造。**

![](https://cdn.luogu.com.cn/upload/image_hosting/r8a6ylx3.png)

## 题目描述

小 R 是一个可爱的猫耳女孩子，她喜欢研究数列的 $\operatorname{mex}\text{*}$。

现在她有一个长度为 $n$ 的数列 $a$。她讨厌整数 $k$，因此她希望修改数列 $a$ 的若干个元素为任意**自然数**，使得 $a$ 的任意**连续非空子串**的 $\operatorname{mex}$ 都不等于 $k$。

请你求出最少需要修改多少个元素。

$\text{*}$ 本题中，数列的 $\operatorname{mex}$ 被定义为数列中最小未出现的**自然数**，例如：

- $\operatorname{mex}\{1,2,3\}=0$，因为 $0$ 是自然数。
- $\operatorname{mex}\{0,1,3\}=2$。
- $\operatorname{mex}\{0,1,2\}=3$。

## 说明/提示

**样例解释**

一种方案是将 $\{1,0,1,3,0\}$ 改为 $\{1,1,1,3,2\}$，共改动两个元素。

可以证明不存在更优的方案。

---

**本题使用 Subtask 捆绑测试。**

| Subtask | $n\le$ | $k\le$ | $a_i\le$ | 特殊性质 | 对应测试点 | 总分 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $6$ | $6$ | $6$ | $-$ | $1\sim 2$ | $10$ |
| $1$ | $100$ | $5\times 10^3$ | $5\times 10^3$ | $-$ | $3\sim 5$ | $20$ |
| $2$ | $5\times 10^3$ | $1$ | $5\times 10^3$ | $-$ | $6\sim 10$ | $20$ |
| $3$ | $5\times 10^3$ | $5\times 10^3$ | $5\times 10^3$ | $\bf A$ | $11\sim 15$ | $20$ |
| $4$ | $5\times 10^3$ | $5\times 10^3$ | $5\times 10^3$ | $-$ | $16\sim 20$ | $30$ |

特殊性质 $\bf A$：保证 $a_i < k$。

对于 $100\%$ 的数据，$1\le n\le 5\times 10^3$，$0\le k,a_i\le 5\times 10^3$。

## 样例 #1

### 输入

```
5 2
1 0 1 3 0```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是基于贪心策略来解决问题。首先对特殊情况进行特判，如 \(k = 0\) 时答案为非 \(0\) 数的个数， \(k\) 较大（如 \(k > n + 1\)）时答案为 \(0\) 。对于一般情况，遍历数组，通过维护当前区间内小于 \(k\) 的数的出现情况来判断是否需要修改元素。当发现当前区间包含 \(0\) 到 \(k - 1\) 的所有数且不含 \(k\) 时，就需要将当前位置的数改为 \(k\) ，以保证该区间及其后续区间的 \(\text{mex}\) 不为 \(k\) 。如果遇到 \(a_i = k\) ，则清空之前维护的区间信息。

在算法要点上，不同题解主要区别在于实现细节，如使用不同的数据结构来记录数的出现情况（数组、 \(\text{bitset}\) 、 \(\text{set}\) 等），以及清空区间信息的方式。

解决难点在于证明贪心策略的正确性，即证明存在一种最优方案，使得所有修改的位置都被改为 \(k\) 且所有被修改的位置都是上述区间的右端点。

### 所选的题解
1. **作者：rui_er（5星）**
    - **关键亮点**：思路清晰，不仅给出了算法实现，还详细证明了贪心算法的正确性。代码注释详细，对特殊情况的处理完整。
    - **个人心得**：无
    - **核心代码**：
```cpp
for(int l = 0, r = 1; r <= n; r++) {
    if(a[r] > k) continue;
    if(a[r] == k) {
        while(++l < r) if(a[l] < k) --cnt[a[l]];
        mex = 0;
    }
    else {
        ++cnt[a[r]];
        while(cnt[mex]) ++mex;
        if(mex == k) {
            ++ans;
            while(++l < r) if(a[l] < k) --cnt[a[l]];
            --cnt[a[r]];
            b[r] = k;
            mex = 0;
        }
    }
}
```
    - **核心实现思想**：通过双指针 \(l\) 和 \(r\) 遍历数组， \(r\) 指针右移过程中，维护当前区间内数的出现次数数组 \(cnt\) ，进而得到当前区间的 \(\text{mex}\) 。当 \(\text{mex}\) 等于 \(k\) 时，将当前位置 \(r\) 的数改为 \(k\) ，并更新区间信息。若遇到 \(a[r]=k\) ，则重置区间。
2. **作者：wwxxbb（4星）**
    - **关键亮点**：提出了优化清空操作的方法，通过记录小于 \(k\) 的数来优化清空桶的过程，降低了时间复杂度，同时给出了本题及加强版的代码。
    - **个人心得**：无
    - **核心代码**：
```cpp
inline void clear() {
    while (top) st[b[top --]] = 0;
    cnt = 0;
}
//...
for (int i = 1, x; i <= n; i ++) {
    cin >> x;
    if (x == k) { clear(); continue; }
    if (x < k &&!st[x]) {
        st[x] = 1;
        b[++ top] = x;
        ++ cnt;
    }
    if (cnt == k) {
        ++ ans;
        clear();
    }
}
```
    - **核心实现思想**：使用 \(\text{bitset}\) 记录数的出现情况，当遇到 \(x = k\) 或 \(cnt = k\) 时，调用 `clear` 函数清空之前记录的小于 \(k\) 的数的出现信息， `clear` 函数通过栈 \(b\) 只清空小于 \(k\) 且出现过的数，优化了清空操作。
3. **作者：qzhwlzy（4星）**
    - **关键亮点**：从将原序列按 \(k\) 划分成段的角度来考虑问题，思路独特，代码简洁明了，对 \(\text{mex}\) 的维护通过桶实现。
    - **个人心得**：无
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    if(a[i]==k){mex=0; for(int j=i-1;a[j]!=k&&j>0;j--) if(a[j]<=k) b[a[j]]--; continue;}
    if(a[i]>k||a[i]>n) continue;
    b[a[i]]++; while(b[mex]) mex++;
    if(mex==k){
        for(int j=i;a[j]!=k&&j>0;j--) if(a[j]<=k) b[a[j]]--;
        mex=0; cnt++; a[i]=k;
    }
}
```
    - **核心实现思想**：遍历数组，遇到 \(a[i]=k\) 时，重置 \(\text{mex}\) 并清空之前一段的桶信息。对于其他数，更新桶信息并计算 \(\text{mex}\) ，当 \(\text{mex}=k\) 时，将当前数改为 \(k\) ，并重置桶和 \(\text{mex}\) 。

### 最优关键思路或技巧
1. **贪心策略**：优先将出现 \(\text{mex}=k\) 的区间的右端点改为 \(k\) ，这样能最大程度减少对后续子串的影响，保证全局最优。
2. **优化清空操作**：如 wwxxbb 的题解，通过记录小于 \(k\) 的数，只清空这些数的相关记录，避免了不必要的全部清空操作，优化了时间复杂度。

### 可拓展思路
此类题目属于序列修改与 \(\text{mex}\) 相关的问题，类似套路是先分析特殊情况，再通过遍历序列并维护相关信息（如数的出现情况）来决定如何修改序列以满足条件。同类型题可考虑改变限制条件，如改变 \(\text{mex}\) 的定义，或者对修改的方式进行更多限制等。

### 相似知识点洛谷题目
1. [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)：涉及栈的应用以及表达式计算，与本题在数据结构应用和逻辑处理上有相似之处。
2. [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)：通过模拟或优化算法解决序列中的位置调整问题，与本题处理序列元素的思路类似。
3. [P2672 推销员](https://www.luogu.com.cn/problem/P2672)：运用贪心策略解决实际场景中的最优选择问题，和本题贪心选择修改位置的思路相似。 

---
处理用时：42.82秒
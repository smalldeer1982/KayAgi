# 题目信息

# 去年天气旧亭台

## 题目背景

依旧是过往的天气，过往的楼台烟雨。时间悄悄流逝着，山河仍在，人却已不是过去的人……

## 题目描述

登上楼台，旧时满面沉灰的地板映入眼帘。

共有 $n$ 块地板，地板分为两类，第 $i$ 块地板的类别用 $c_i$ 表示，积灰程度用 $a_i$ 表示。**注意 $c_i$ 为 $0$ 或 $1$。**

现在要清理这些地板上的灰尘。每次操作中，你可以：

+ 选择两个下标 $i,j$，满足 $1\leq i\leq j\leq n$， $c_i=c_j$，**且第 $i$ 块和第 $j$ 块地板上的灰尘均未被清理过**；
+ 花费 $a_i+a_j$ 的能量清理**第 $i$ 块到第 $j$ 块所有地板**上的灰尘。

求清理完所有地板上的灰尘至少要多少能量。

## 说明/提示

**【样例 1 解释】**

- 对于第一组数据，直接花费 $a_1+a_6=5$ 的能量清理所有灰尘。
- 对于第二组数据，先花费 $a_1+a_1=6$ 的能量清理第一个地板上的灰尘，再花费 $a_2+a_8=7$ 的能量清理剩余灰尘。

**【数据规模与约定】**

对于 $10\%$ 的数据，保证 $T\le 10$，$n\le 10$；

对于 $40\%$ 的数据，保证 $T\le 20$，$n\le 10^3$；

另有 $10\%$ 的数据，保证 $c_i=1$；

对于 $100\%$ 的数据，保证 $1 \le T \le 10^5$，$1 \le n,\sum n\le 2 \times 10^6$，$c_i \in \{0,1\}$，$1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
2
6
1 1 4 5 1 4
1 0 0 1 0 1
8
3 1 4 1 5 9 2 6
1 0 1 0 1 0 1 0```

### 输出

```
5
13```

# AI分析结果

### 综合分析与结论
这些题解主要分为贪心和动态规划两种思路。
 - **贪心思路**：核心是根据首末地板类型 $c_1$ 和 $c_n$ 的关系进行分类讨论。若 $c_1 = c_n$，直接清理 $[1, n]$ 区间为最优解，代价为 $a_1 + a_n$；若 $c_1 \neq c_n$，必然存在 $i$ 使得 $c_1 = c_i$ 且 $c_{i + 1} = c_n$，此时取 $[1, i]$ 和 $[i + 1, n]$ 两个区间清理，枚举 $i$ 找到 $a_i + a_{i + 1}$ 最小时的方案为最优，时间复杂度 $O(Tn)$。
 - **动态规划思路**：定义 $dp_i$ 表示清理前 $i$ 块地板的最小能量。状态转移方程为 $dp_i = \min\{a_i + a_j + dp_{j - 1}\}(1 < j \leq i, c_i = c_j)$，直接暴力转移时间复杂度为 $O(Tn^2)$。通过将与 $i$ 无关的项提出，利用前缀最小值优化，使得时间复杂度降为 $O(Tn)$。

贪心算法思路简洁，实现方便；动态规划相对复杂，但具有更强的通用性和扩展性。整体来看，贪心算法在本题中更为直接高效。

### 所选的题解
 - **作者：_JF_ (赞：32) - 5星**
    - **关键亮点**：思路清晰，先介绍暴力和 $O(n^2)$ 的 $dp$ 做法，再给出正解。正解通过分类讨论，利用反证法严谨证明了贪心策略的正确性，代码简洁明了。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =5e6+10;
#define int long long
int a[N],c[N];
signed main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        for(int i=1;i<=n;i++)
            cin>>c[i];
        if(c[1]==c[n])
        {
            cout<<a[1]+a[n]<<endl;
            continue;
        }
        int ans=LONG_LONG_MAX;
        for(int i=1;i<n;i++)
            if(c[i]==c[1]&&c[i+1]==c[n])
                ans=min(ans,a[i]+a[1]+a[n]+a[i+1]);
        cout<<ans<<endl;
    }
    return 0;
}
```
    - **核心实现思想**：先读入数据，若 $c_1 = c_n$，直接输出 $a_1 + a_n$；否则遍历寻找满足 $c_i = c_1$ 且 $c_{i + 1} = c_n$ 的 $i$，更新最小花费。
 - **作者：zhlzt (赞：11) - 4星**
    - **关键亮点**：给出与官方题解不同的线性 $dp$ 思路，通过定义辅助变量 $ans1$ 和 $ans2$ 简化状态转移方程，代码实现简洁清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2000010],c[2000010];long long dp[2000010]; 
int main(){
    int T;scanf("%d",&T);
    while(T--){
        int n;scanf("%d",&n);
        for(int i=1;i<=n;i++) scanf("%d",&a[i]);
        for(int i=1;i<=n;i++) scanf("%d",&c[i]);
        long long ans1=1e15,ans2=1e15;
        for(int i=1;i<=n;i++){
            if(c[i]==0) ans1=min(ans1,dp[i-1]+a[i]),dp[i]=ans1+a[i];
            else ans2=min(ans2,dp[i-1]+a[i]),dp[i]=ans2+a[i];
        }
        printf("%lld\n",dp[n]);
    } 
    return 0;
}
```
    - **核心实现思想**：利用 $ans1$ 和 $ans2$ 分别记录不同类型地板作为区间开头时的最小能量，根据当前地板类型更新 $ans1$ 或 $ans2$ 以及 $dp[i]$。
 - **作者：GeorgeAAAADHD (赞：5) - 4星**
    - **关键亮点**：采用贪心算法，对每种情况给出详细证明，逻辑严谨，代码实现符合思路，对边界情况处理得当。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,a[2000001]={0};
bool c[2000001]={0};
signed main() {
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=1;i<=n;i++)cin>>a[i];
        for(int i=1;i<=n;i++)cin>>c[i];
        if(c[1]==c[n])cout<<a[1]+a[n]<<endl;
        else if(c[1]){
            int ans=1e15;
            for(int i=1;i<n;i++){
                if(c[i]&&!c[i+1])ans=min(ans,a[1]+a[i]+a[i+1]+a[n]);
            }
            cout<<ans<<endl;
        }
        else{
            int ans=1e15;
            for(int i=1;i<n;i++){
                if(!c[i]&&c[i+1])ans=min(ans,a[1]+a[i]+a[i+1]+a[n]);
            }
            cout<<ans<<endl;
        }
    }
    return 0;
}
```
    - **核心实现思想**：读入数据后，根据 $c_1$ 和 $c_n$ 的关系分类讨论，若 $c_1 = c_n$ 直接输出 $a_1 + a_n$；否则根据 $c_1$ 的值遍历寻找满足条件的 $i$，计算并输出最小花费。

### 最优关键思路或技巧
贪心算法的关键在于通过分析问题性质，利用首末地板类型关系确定最优清理区间。证明过程采用反证法，简洁有力地说明了贪心策略的正确性。动态规划的优化技巧在于从状态转移方程中提取与 $i$ 无关项，利用前缀最小值降低时间复杂度。

### 可拓展之处
同类型题可考虑增加地板类型数量、改变操作限制或花费计算方式。类似算法套路如在具有区间选择和代价计算的问题中，可尝试通过分析边界条件和问题特性，确定贪心策略；对于复杂情况，动态规划是一种通用方法，注意状态定义和转移方程的优化。

### 相似知识点洛谷题目
 - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：通过贪心策略解决合并物品的最小代价问题。
 - [P1199 [NOIP2010 普及组] 三国游戏](https://www.luogu.com.cn/problem/P1199)：考察对博弈过程的分析和贪心策略运用。
 - [P2048 游戏](https://www.luogu.com.cn/problem/P2048)：结合动态规划和贪心思想，解决游戏得分最大化问题。

### 个人心得摘录与总结
暂未发现题解中有个人心得相关内容。 

---
处理用时：43.87秒
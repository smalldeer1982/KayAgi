# 题目信息

# 红草莓

## 题目描述

有一个由 $n$ 颗珍珠串成的项链，项链是一个环，首尾相连。其中有一颗珍珠上有特殊的记号，我们称它为**起始珍珠**。

有个外星人很会发射宇宙射线，他依次发射了 $m$ 轮宇宙射线，第 $i$ 轮有一个参数 $a_i$，表示：

- 外星人从起始珍珠开始数，起始珍珠是 $0$ 号，起始珍珠的下一个珍珠是 $1$ 号，以此类推（数完一圈后还会继续，例如 $n$ 号珍珠仍然是起始珍珠，$n+1$ 号珍珠是起始珍珠的下一个珍珠）。外星人会对编号为 $0,a_i,2a_i,\dots$ 这些 $a_i$ 倍数位置上的珍珠都发射一次宇宙射线。

一开始所有珍珠都是红色的，而当一个珍珠被发射宇宙射线后就会被从红色染成蓝色。

你需要输出：对于每轮操作，有多少个操作前为红色的珍珠被这轮操作变成了蓝色。

## 说明/提示

**【样例解释】**

如图是初始时以及每次操作后各珍珠的颜色，起始珍珠编号为 $0$，可以看到，每次操作新染蓝的珍珠数量分别为 $1,1,2,0,2,0$：

![](https://cdn.luogu.com.cn/upload/image_hosting/mt4dg5ap.png)

---

**【数据范围】**

对于全部数据：$1\leq n,m\leq 5\times 10^5$，$1\leq a_i\leq n$。

|     子任务编号     |    $n\leq$     |    $m\leq$     |  特殊限制   | 分值 |
| :----------------: | :------------: | :------------: | :---------: | :--: |
| $\text{Subtask 1}$ |     $100$      |     $100$      |     无      | $15$ |
| $\text{Subtask 2}$ |     $1000$     |     $1000$     |     无      | $15$ |
| $\text{Subtask 3}$ |     $10^5$     |     $10^5$     | $a_i\mid n$ | $20$ |
| $\text{Subtask 4}$ |     $10^5$     |      $10$      |     无      | $20$ |
| $\text{Subtask 5}$ | $5\times 10^5$ | $5\times 10^5$ |     无      | $30$ |

---

![](https://cdn.luogu.com.cn/upload/image_hosting/nzd79suj.png)

## 样例 #1

### 输入

```
6 6
6 3 4 2 5 1
```

### 输出

```
1 1 2 0 2 0
```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解都围绕模拟染色过程并进行优化。部分通过剪枝，如判断是否所有珍珠已染蓝、当前操作是否与之前本质相同；部分利用数论知识，如求最大公约数gcd，发现每次操作实际染色的是gcd(n, a_i)倍数的珍珠，避免重复计算。
    - 算法要点：暴力模拟每次操作染色过程为基础，优化点在于减少不必要的计算。如记录已出现的gcd值，若再次出现则直接输出0；或判断当前操作能否使珍珠变色，避免无效枚举。
    - 解决难点：主要是优化暴力解法的时间复杂度，通过不同的剪枝策略和数论性质应用来实现。

    - 综合质量来看，以下题解相对较好：
  - 作者：Hughpig (赞：3)
    - 星级：4星
    - 关键亮点：利用数论知识，指出每次操作染色的是gcd(n, a_i)倍数的珍珠，通过记录已出现的gcd值避免重复操作，时间复杂度为O(nln n)，思路清晰，代码简洁高效。
    - 核心代码片段：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,x;

bool vis[500007],vis_[500007];

int gcd(int x,int y){return y==0?x:gcd(y,x%y);}

int main()
{
    cin>>n>>m;
    while(m--)
    {
        cin>>x;
        int qwq=gcd(x,n);
        if(vis_[qwq]){
            cout<<0<<' ';
            continue;
        }
        vis_[qwq]=1;
        int cnt=0;
        for(int i=0;i<n;i+=qwq)
        {
            if(!vis[i])cnt++,vis[i]=1;
        }
        cout<<cnt<<' '; 
    }
}
```
    - 核心实现思想：每次读入a_i，计算其与n的gcd，若该gcd已出现过，说明此次操作不会染新珍珠，直接输出0；否则，遍历gcd倍数的珍珠位置，统计并标记新染色的珍珠。

  - 作者：RNTBW (赞：1)
    - 星级：4星
    - 关键亮点：详细证明了每次操作染色的是gcd(x, n)倍数的珍珠这一结论，并利用该结论优化暴力算法，通过记录已计算的gcd避免重复操作，时间复杂度分析清晰。
    - 核心代码片段：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,k,s,now;
bool vis[500001],f;
int main()
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++)
    {
        scanf("%d",&k);s=0;
        now=__gcd(k,n);
        if(vis[now]||f)
        {putchar('0');putchar(' ');continue;
        }
        for(j=now;j<=n;j+=now)
            if(!vis[j])vis[j]=1,s++;
        printf("%d ",s);
        if(now==1)f=1;
    }
    return 0;
}
```
    - 核心实现思想：读入a_i后计算gcd，若该gcd已被处理过或之前已出现gcd为1的情况（意味着所有珍珠已染蓝），直接输出0；否则，遍历gcd倍数的位置，统计新染色珍珠。

  - 作者：ncwzdlsd (赞：0)
    - 星级：4星
    - 关键亮点：利用裴蜀定理得出每次染色编号为gcd(a_i, n)倍数的珍珠这一结论，通过记录已出现的gcd值优化暴力算法，代码简洁明了。
    - 核心代码片段：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxm=5e5+5;
bool vis[maxm],col[maxm];

int main()
{
    int n,m;cin>>n>>m;
    while(m--)
    {
        int a;cin>>a;
        int cnt=0;
        if(vis[__gcd(a,n)]){cout<<"0 ";continue;}
        vis[__gcd(a,n)]=1;
        for(int i=0;i<n;i+=__gcd(a,n))
            if(!col[i]) col[i]=1,cnt++;
        cout<<cnt<<' ';
    }
    return 0;
}
```
    - 核心实现思想：每次读入a，计算gcd，若该gcd已处理过则输出0，否则遍历gcd倍数的位置，标记并统计新染色的珍珠。

• 最优关键思路或技巧：利用数论知识，特别是最大公约数gcd的性质，确定每次操作实际染色的珍珠规律，通过记录已出现的gcd值，避免重复计算，从而优化暴力模拟的时间复杂度。

• 可拓展之处：同类型题可涉及更多环上操作或基于数论的模拟优化问题。类似算法套路是在模拟题中善于挖掘数据规律，利用数论知识（如gcd、lcm、裴蜀定理等）优化暴力解法，减少不必要的计算。

• 相似知识点洛谷题目：
    - P1029 最大公约数和最小公倍数问题
    - P1572 计算分数
    - P2669 [NOIP2015 普及组] 金币

• 个人心得：多数题解未提及个人心得。 

---
处理用时：32.01秒
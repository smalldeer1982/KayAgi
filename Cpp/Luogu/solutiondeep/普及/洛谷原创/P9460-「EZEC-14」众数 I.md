# 题目信息

# 「EZEC-14」众数 I

## 题目背景

pigstd 是一个可爱的男孩子。他在 NOI2022 中的众数一题定义了 $10^6$ 个 ``std::deque`` 并没有 MLE。

## 题目描述

给定一个长度为 $n$ 的序列 $a$，我们通过以下方式构造序列 $b$：

- 初始时 $b=a$。
- 依次对 $b$ 进行 $k$ 次操作，每次操作选择任意一个元素并将其**修改**为任意整数。

dXqwq 定义一个序列的**众数**为所有出现次数最大的数。例如 $[1,1,4,5,1,4]$ 的众数为 $1$，而 $[1,14,5,14,19,19,8,10]$ 的众数为 $14,19$。

你需要求出有多少整数可能成为 $b$ 的**众数**。

## 说明/提示

**【样例解释】**

对于第一组数据，最终 $1,2,3,4,5$ 可能为区间众数。

对于第二组数据，将第一个数换成 $6,7,8,9,\cdots$ 后它们均会成为区间众数，因此答案为正无穷。

对于第三组数据，$1,2,3$ 可能成为区间众数。

**【提示】**

开 $10^6$ 个 ``std::deque`` 在空间限制为 1024MB 时不一定会 MLE。

**【数据范围】**

**本题采用捆绑测试。**

* Subtask 1（20 pts）：$n\leq 5$。
* Subtask 2（20 pts）：$n\leq 10^3$。
* Subtask 3（20 pts）：$k=0$。
* Subtask 4（20 pts）：$k=1$。
* Subtask 5（20 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$0\leq k\leq n $，$1\leq a_i\leq n$。

## 样例 #1

### 输入

```
5 0
1 2 3 4 5```

### 输出

```
5```

## 样例 #2

### 输入

```
5 1
1 2 3 4 5```

### 输出

```
pigstd```

## 样例 #3

### 输入

```
5 1
1 1 2 2 3```

### 输出

```
3```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何确定经过k次修改后序列中可能成为众数的数的数量。思路上，有的采用二分法寻找众数出现次数的临界值，有的通过贪心策略模拟修改过程，还有利用前缀和等优化计算。算法要点包括对数据的统计（如用桶、map等），以及不同的数据结构和算法优化。解决难点在于如何高效地判断每个数能否成为众数，以及处理可能出现的无限解情况。整体上，各题解在思路清晰度、代码可读性和优化程度上存在差异。

所选的题解：
  - 作者：ys_kylin__ (5星)
    - 关键亮点：思路清晰，采用二分法确定众数出现次数的下限，通过check函数判断每个数能否成为众数，逻辑严谨，代码简洁明了。
    - 重点代码核心实现思想：二分“众数线”mid，在check函数中，先将mid加上k，遍历计数数组，统计出现次数大于mid + k的数超出部分的总和，与k比较判断是否满足条件。
```cpp
int check(int x) {
    memset(vis,0,sizeof vis);
    x+=k;
    long long m=0;
    for(int i=1;i<=n;i++) {
        if(mp[a[i]]>x && vis[a[i]]==0) {
            vis[a[i]]=1;
            m+=mp[a[i]]-x;
        }
    }
    if(m>k) return 0;
    else return 1;
}
```
  - 作者：dead_X (5星)
    - 关键亮点：利用前缀和优化计算，时间复杂度为O(n)，算法高效。通过分析让某数成为众数所需的操作次数，得出判断条件，思路巧妙。
    - 重点代码核心实现思想：先统计每个数的出现次数，构建前缀和数组，通过遍历从大到小的出现次数，结合前缀和计算使当前数成为众数所需的操作次数，判断是否满足条件。
```cpp
for(int i=1; i<=n; ++i) ++a[c[i]];
for(int i=n+k,c=0,s=0; i>=k; --i)
{
    s+=c,c+=a[i];
    if(s>k) printf("%d\n",ans),exit(0);
    ans+=a[i-k];
}
```
  - 作者：Light_az (4星)
    - 关键亮点：通过生动的故事引入贪心思路，易于理解。使用堆维护最大值，模拟修改过程，能较好地解决问题。
    - 重点代码核心实现思想：将每个数的初始出现次数存入堆中，进行k次操作，每次取出堆顶元素减1后再放回堆中。最后通过比较每个数出现次数加上k与堆顶元素的大小，判断能否成为众数。
```cpp
F(i,1,k){
    ll p=q.top();
    q.pop();
    p--;
    q.push(p);
}
if(k>=q.top()){
    cout<<"pigstd";
    return 0;
}
F(i,1,n) if(!b[a[i]]&&sum[a[i]]+k>=q.top()) b[a[i]]=1,ans++;
```

最优关键思路或技巧：利用二分查找众数出现次数的下限，结合贪心思想和前缀和优化计算，能高效解决问题。同时，使用堆等数据结构维护最大值，便于模拟修改过程。

可拓展之处：同类型题可涉及更多关于序列操作和统计的问题，类似算法套路包括利用二分、贪心和前缀和优化计算，以及使用合适的数据结构维护数据。

推荐洛谷题目：
  - P1131 绝对值排序
  - P1909 买铅笔
  - P1088 火星人

个人心得摘录与总结：
  - 作者fish_love_cat提到赛时调试三小时，原因是将“修改k个数”误解为“增加k个数”，忽视了不仅能利己还会损其他数数量的情况，且在缩小最大数时可能误判其不再是最大数。这提醒在解题时要仔细审题，注意细节，避免因理解偏差导致错误。 

---
处理用时：26.91秒
# 题目信息

# queue

## 题目背景

你说的对，但是舞萌 DX 是一款后面忘了。

## 题目描述

**补充说明：这里的排队和传统的排队有出入。正在游玩的人为队列的前两位，所以正在游玩视为正在排队。**

机厅里有一台游戏机，每次可供最多两人同时游玩。但是来玩的人显然不止两个！这个时候他们就需要排队了，而你需要写一个程序维护这个队列，并在他人游玩结束后通知接下来上场的人。在整个过程中，有以下几种事件可能发生：

- `start`：一局游戏开始。若这不是第一局游戏，则上一局的参与者**在这一局游戏开始前一瞬间**按照原本的顺序回到队尾。此时你应该按在队列中的顺序输出这一局上场的人的名字（正常来讲是队列前两位或者唯一一个人），若有两个则以空格分割。若这一局无人上场，则输出 `Error` 并忽略这条事件。

- `arrive x`：$x$ 到达机厅并且将自己加入队尾，此时 $x$ 不应该在排队，否则输出 `Error` 并忽略这条事件。若该事件成功执行则输出 `OK`。

- `leave x`：$x$ 离开机厅并离开队列。此时 $x$ 应该在排队但不应该在游玩，否则输出 `Error` 并忽略这条事件。若该事件成功执行则输出 `OK`。

你需要维护队列信息，并输出上述事件中要求的输出。

## 说明/提示

**【样例说明】**

样例 $1$ 中发生了如下的事件：

- 第一次 `start` 时队列并没有任何人，输出 `Error`。
- `A` 随即加入队列。
- 第二次 `start` 时仅有 `A` 一个人，所以输出 `A`。
- `B, C, D` 随即依次加入队列。
- 第三次 `start` 时 `B, C` 上场。
- `C` 试图离开，但是他在游玩。所以输出 `Error`。
- `D` 成功离开。
- 第四次 `start` 时 `A, B` 上场。
- `A` 试图加入队列，但是他已经在队列中。输出 `Error`。
- `D` 重新加入队列。
- `E` 试图离开，但是他根本不在排队，输出 `Error`。
- 第五次 `start` 时 `C, D` 上场。

样例 $2$ 中，`A, B, C` 依次入队，操作合法，输出三个 `OK`。

**【数据范围】**

对于 $20\%$ 的数据，保证 $n=1$。

对于 $40\%$ 的数据，保证 $n\le 2000$。

对于另外 $20\%$ 的数据，保证没有 `leave` 操作。

对于另外 $20\%$ 的数据，人名只有可能是单个大写字母。

对于 $100\%$ 的数据，保证 $1 \le n\le 10^5$，人名仅含有大小写字母且长度不超过 $10$。

**本题输入输出量较大，请注意使用合理的输入输出方式。**

## 样例 #1

### 输入

```
14
start
arrive A
start
arrive B
arrive C
arrive D
start
leave C
leave D
start
arrive A
arrive D
leave E
start```

### 输出

```
Error
OK
A
OK
OK
OK
B C
Error
OK
A B
Error
OK
Error
C D```

## 样例 #2

### 输入

```
3
arrive A
arrive B
arrive C```

### 输出

```
OK
OK
OK```

# AI分析结果

这道题要求维护一个排队队列，并处理 `start`、`arrive`、`leave` 三种操作。多数题解使用STL容器结合辅助数据结构来实现，主要差异在于选择的容器和处理细节。

### 各题解分析
1. **Register_int**：
    - **思路**：用 `set` 维护排队的人，通过编号保证顺序，`map` 记录每个人是否在队和是否在玩。
    - **算法要点**：为每个人定义编号，利用 `set` 的有序性和 `map` 的快速查找特性。
    - **解决难点**：通过合理设计数据结构，实现 $O(\log n)$ 的插入和删除。
    - **评分**：4星。思路清晰，代码实现简洁，利用STL容器的特性解决问题，但未详细说明选择 `set` 而非其他容器的优势。
2. **CleverRaccoon**：
    - **思路**：使用 `list` 表示队列，`unordered_set` 记录正在排队的人，`unordered_map` 记录每个人在链表中的地址。
    - **算法要点**：利用 `list` 方便的插入删除操作和 `unordered_*` 系列容器的高效查找。
    - **解决难点**：通过记录地址实现 $O(1)$ 的删除操作，提高效率。
    - **评分**：4星。详细阐述了选择各容器的原因及操作实现，代码可读性好，但部分代码逻辑稍显繁琐。
3. **icypenguin**：
    - **思路**：用队列模拟操作，`map` 标记每个人是否是最后一次出现。
    - **算法要点**：在操作中通过 `map` 判断元素是否为最新出现，决定其是否参与游戏。
    - **解决难点**：处理人员多次进出队列时的顺序问题。
    - **评分**：3星。思路较清晰，但代码实现稍复杂，部分变量命名不够直观。
4. **ManGo_Mouse**：
    - **思路**：使用 `deque` 维护队列，`map` 记录每个人的排队状态。
    - **算法要点**：利用 `deque` 的双端操作特性和 `map` 的快速查找。
    - **解决难点**：通过 `map` 优化查找效率，避免 `find()` 函数的 $O(n)$ 复杂度。
    - **评分**：3星。思路常规，代码简洁，但在处理复杂情况时可能不够灵活。
5. **stripe_python**：
    - **思路**：面向对象设计，用平衡树（`tree`）实现对数级别的增删改查，`map` 记录入队时间。
    - **算法要点**：利用平衡树的特性满足题目对操作复杂度的要求。
    - **解决难点**：平衡树的实现和调优。
    - **评分**：4星。采用独特的平衡树实现，思路新颖，代码结构清晰，但平衡树的常数较大，且对读者数据结构知识要求较高。
6. **Flanksy**：
    - **思路**：使用 `list` 模拟队列，`unordered_map` 记录元素是否存在和在 `list` 中的迭代器。
    - **算法要点**：利用链表的插入删除特性和哈希表的快速查找。
    - **解决难点**：处理游玩状态标记和元素位置更新。
    - **评分**：3星。思路常规，但代码中部分变量命名不够清晰，影响可读性。
7. **_HyperV_**：
    - **思路**：用数组模拟队列并惰性删除，`map` 映射名字到队列中的位置。
    - **算法要点**：通过惰性删除减少删除操作的时间复杂度。
    - **解决难点**：处理队列中元素位置的有效性判断。
    - **评分**：3星。思路较简单，但代码实现中处理细节较多，整体不够简洁。
8. **Code_Fish_GoodBye**：
    - **思路**：使用 `list` 实现队列，`Map` 映射每个人的标号。
    - **算法要点**：结合 `list` 和 `map` 的特性进行操作。
    - **解决难点**：未详细说明如何解决难点，代码实现较简略。
    - **评分**：3星。只阐述了基本思路，未深入分析和优化，代码示例也较简单。
9. **eoinlee**：
    - **思路**：用结构体模拟队列，`map` 记录玩家状态，通过标记位置解决同一人多次进出队列的问题。
    - **算法要点**：对队列元素进行状态标记和位置记录。
    - **解决难点**：处理同一人多次进出队列时的位置有效性判断。
    - **评分**：3星。详细分析了题目细节，但代码实现稍复杂，部分逻辑较绕。
10. **Crazyouth**：
    - **思路**：使用 `set` 维护队列，给每个入队的人打上时间戳，重载结构体的小于号。
    - **算法要点**：利用 `set` 的有序性和时间戳标记。
    - **解决难点**：通过时间戳解决元素顺序和重复判断问题。
    - **评分**：3星。思路较清晰，但代码实现中部分逻辑稍显混乱，变量命名不够规范。
11. **Fire_flame**：
    - **思路**：给每个字符串编号，用队列和 `map` 维护操作次数，判断操作合法性。
    - **算法要点**：通过记录入队和出队次数判断元素是否在队列中。
    - **解决难点**：利用操作次数标记解决元素状态判断问题。
    - **评分**：3星。思路独特，但代码实现较复杂，可读性一般。
12. **信息向阳花木**：
    - **思路**：用队列维护排队的人，两个 `map` 维护是否排队和是否在玩游戏，暴力遍历队列处理离开操作。
    - **算法要点**：简单直接的模拟实现。
    - **解决难点**：未有效解决暴力遍历的效率问题，仅针对数据较水的情况。
    - **评分**：2星。思路简单，代码实现未优化，仅适用于部分数据。
13. **jr_linys**：
    - **思路**：定义数据结构实现队列操作，使用队列和哈希表假删，达到 $O(n)$ 时间复杂度。
    - **算法要点**：通过记录操作时间标记元素状态。
    - **解决难点**：利用假删和时间标记解决元素状态和位置判断问题。
    - **评分**：3星。思路较清晰，但代码实现较复杂，部分变量命名不直观。
14. **qinsishi**：
    - **思路**：用 `queue<pair<string, int> >` 维护排队顺序，`set` 表示队列里的人，`map` 记录入队次数。
    - **算法要点**：利用懒标记和有效编号处理队列操作。
    - **解决难点**：通过懒标记和有效编号解决元素删除和位置更新问题。
    - **评分**：3星。思路较清晰，但代码实现中部分逻辑较复杂，可读性一般。
15. **Aegleseeker_**：
    - **思路**：使用 `list` 结合 `set` 实现，`list` 处理队列操作，`set` 判断元素是否存在。
    - **算法要点**：结合 `list` 和 `set` 的特性。
    - **解决难点**：未详细说明如何解决难点，代码实现较简略。
    - **评分**：3星。只阐述了基本思路，未深入分析和优化，代码示例也较简单。
16. **fish_love_cat**：
    - **思路**：用 `queue` 模拟队列，`map` 记录状态，通过优化减少删除操作的时间复杂度。
    - **算法要点**：记录离开次数，在 `start` 操作中优化队列。
    - **解决难点**：通过延迟删除和优化操作解决效率问题。
    - **评分**：3星。思路较清晰，但代码实现中部分逻辑较绕，变量命名不够规范。
17. **_Wind_Leaves_ShaDow_**：
    - **思路**：给队列加时间维度，记录每个人最新进队时间，用 `map` 和 `queue` 维护。
    - **算法要点**：通过时间维度解决同一人多次进出队列的顺序问题。
    - **解决难点**：利用时间标记解决元素顺序和状态判断问题。
    - **评分**：3星。思路较清晰，但代码实现较复杂，部分逻辑较绕。
18. **joyslog**：
    - **思路**：将人名转为编号，用 `queue<int>` 模拟队列，`unordered_map` 处理编号和判断元素是否在队列中。
    - **算法要点**：编号映射和队列模拟。
    - **解决难点**：通过编号映射简化操作和提高效率。
    - **评分**：3星。思路较清晰，但代码实现中部分逻辑较复杂，可读性一般。
19. **Binary_Lee**：
    - **思路**：用链表维护队列，`map` 处理字符串下标，模拟操作。
    - **算法要点**：链表的插入删除操作和 `map` 的快速查找。
    - **解决难点**：利用链表结构解决队列操作问题。
    - **评分**：3星。思路较清晰，但代码实现中部分逻辑较复杂，可读性一般。
20. **AndyPomeloMars**：
    - **思路**：用 `deque` 模拟队列，`map` 记录状态，按操作模拟。
    - **算法要点**：利用 `deque` 的双端操作和 `map` 的状态记录。
    - **解决难点**：未详细说明如何解决难点，代码实现较简略。
    - **评分**：3星。只阐述了基本思路，未深入分析和优化，代码示例也较简单。
21. **渡鸦2007**：
    - **思路**：将字符串转为数字，用 `queue<int>` 维护队列，`bool` 数组记录是否在队，记录离开次数处理离队操作。
    - **算法要点**：编号映射和记录离开次数优化。
    - **解决难点**：通过记录离开次数解决离队操作的效率问题。
    - **评分**：3星。思路较清晰，但代码实现中部分逻辑较复杂，可读性一般。
22. **Peter2020**：
    - **思路**：用双向队列 `deque` 和 `set` 维护队列，`set` 判断元素是否在队列中。
    - **算法要点**：结合 `deque` 和 `set` 的特性。
    - **解决难点**：利用 `set` 优化查找效率。
    - **评分**：3星。思路较清晰，但代码实现中部分逻辑较复杂，可读性一般。
23. **赛克尔だよ**：
    - **思路**：用链表维护队列，`map` 映射名字到链表编号，模拟操作。
    - **算法要点**：链表的操作和 `map` 的映射。
    - **解决难点**：利用链表和 `map` 解决队列操作和元素查找问题。
    - **评分**：3星。思路较清晰，但代码实现较复杂，部分逻辑较绕。
24. **COsm0s**：
    - **思路**：用 `set` 和 `map` 结合维护排队的人，`map` 维护是否在队，`vector` 维护游玩的人。
    - **算法要点**：利用各数据结构的特性实现操作。
    - **解决难点**：通过合理选择数据结构解决问题。
    - **评分**：3星。思路较清晰，但代码实现中部分逻辑较复杂，可读性一般。
25. **rainygame**：
    - **思路**：用 `set` 和 `map` 维护队列和状态，处理 `leave` 操作时通过 `map` 记录数量解决顺序问题。
    - **算法要点**：利用 `set` 的查找和 `map` 的数量记录。
    - **解决难点**：通过记录数量解决同一人多次进出队列的顺序问题。
    - **评分**：3星。思路较清晰，但代码实现较复杂，部分逻辑较绕。
26. **RyanLi**：
    - **思路**：用 `list` 维护排队队列，`queue` 维护游玩的人，`unordered_map` 记录是否在队。
    - **算法要点**：结合不同容器的特性。
    - **解决难点**：利用容器特性高效实现操作。
    - **评分**：3星。思路较清晰，但代码实现中部分逻辑较复杂，可读性一般。
27. **Kedit2007**：
    - **思路**：用 `set<pair<int, string> >` 存储队列，`map<string, int>` 记录时间戳。
    - **算法要点**：利用 `set` 的有序性和 `map` 的时间戳记录。
    - **解决难点**：通过时间戳解决元素顺序和查找问题。
    - **评分**：3星。思路较清晰，但代码实现中部分逻辑较复杂，可读性一般。
28. **Night_sea_64**：
    - **思路**：手写链表结合 `map`，链表处理队列操作，`map` 快速查找位置。
    - **算法要点**：链表和 `map` 的结合使用。
    - **解决难点**：利用链表和 `map` 解决队列操作和元素查找问题。
    - **评分**：3星。思路较清晰，但代码实现较复杂，部分逻辑较绕。
29. **Argvchs**：
    - **思路**：用 `list` 模拟队列，`unordered_map` 记录元素位置。
    - **算法要点**：利用 `list` 的插入删除和 `unordered_map` 的位置记录。
    - **解决难点**：通过记录位置高效实现操作。
    - **评分**：3星。思路较清晰，但代码实现中部分逻辑较复杂，可读性一般。

### 综合结论
所有题解均围绕如何高效实现题目要求的队列操作展开，部分题解通过选择合适的STL容器和辅助数据结构，如 `list` 结合 `unordered_map`，或 `set` 结合 `map`，实现了较好的时间复杂度和代码可读性。但整体上，没有题解在各方面都表现得极为出色，均存在一定的提升空间。

### 通用建议与扩展思路
- **数据结构选择**：根据题目操作特点选择合适的数据结构，如需要频繁插入删除可选 `list`，需要有序性可选 `set`，需要快速查找可选 `unordered_map` 等。
- **优化技巧**：处理复杂操作时，可通过记录额外信息（如时间戳、操作次数等）优化，避免暴力遍历。
- **代码实现**：注重代码的可读性和模块化，将不同操作封装成函数，便于理解和调试。

### 相似知识点题目推荐
- **P1996 约瑟夫问题**：经典的队列模拟问题，考察对队列操作的理解和实现。
- **P3373 【模板】线段树 2**：涉及数据结构的综合应用，与本题类似，需要选择合适的数据结构优化操作。
- **P1086 [NOIP2009 普及组] 花生采摘**：通过模拟和简单的贪心策略解决问题，与本题一样需要处理多种操作和条件判断。 

---
处理用时：104.63秒
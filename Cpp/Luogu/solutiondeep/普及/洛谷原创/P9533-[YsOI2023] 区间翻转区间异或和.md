# 题目信息

# [YsOI2023] 区间翻转区间异或和

## 题目背景

Ysuperman 模板测试的数据结构题。

符卡可以是人名也可以是队名。

## 题目描述

符卡有一个长度为 $n$ 的整数数组 $a$，符卡认为一个区间 $[l,r]$ 是灵异区间当且仅当 $\bigoplus_{i=l}^ra_i=0$，或者说这个区间内所有数字异或起来刚好等于 $0$。

符卡有特殊的魔法，可以把**任意**一个灵异区间翻转。具体来说，如果 $[l,r]$ 区间是灵异区间，那么符卡就可以对这个区间使用魔法，整个数组就会变成 $a_1,a_2,\dots,a_{l-1},a_r,a_{r-1},\dots,a_l,a_{r+1},a_{r+2}\dots,a_n$。

现在符卡可以使用任意次数的魔法，符卡希望最后得到的数组的灵异区间数量能够尽可能多，你能告诉她最后最多有多少个灵异区间吗？

## 说明/提示

#### 样例 1 解释

无论符卡发动多少次魔法，数组都是 $1,1,1$，所以发不发动魔法都没有任何关系。灵异区间永远都是 $[1,2],[2,3]$ 两个。

#### 样例 2 解释

这里给出可能的一种魔法发动方法。

选择灵异区间 $[1,3]$ 发动魔法，得到的新数组是 $2,1,3,3$，这个数组共有两个灵异区间，分别是 $[1,3]$ 和 $[3,4]$。

可以证明答案无法超过 $2$。

#### 数据范围

对于前 $20\%$ 的数据，保证 $n\le 10$。

对于前 $40\%$ 的数据，保证 $n\le 2000$。

另有 $10\%$ 的数据，保证 $a_i$ 全部相等。

另有 $10\%$ 的数据，保证 $a_i$ 只有两种可能的取值。

另有 $10\%$ 的数据，保证 $0\le a_i<2^{10}$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$0\le a_i< 2^{20}$。

#### 彩蛋

灵异区间的名字其实是“零异（或）区间”的谐音。

## 样例 #1

### 输入

```
3
1 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4
3 1 2 3```

### 输出

```
2```

# AI分析结果

• 综合分析与结论：这些题解的核心思路均是证明翻转灵异区间对灵异区间的数量无影响，进而通过前缀异或和统计灵异区间个数。证明过程主要围绕分析两个灵异区间的位置关系（包含、相交、不相交）展开，利用异或运算的交换律和结合律，得出翻转操作不改变灵异区间个数的结论。算法要点在于利用前缀异或和数组记录异或结果，并通过数组、map 或 unordered_map 统计每个异或结果出现的次数，依据出现次数计算灵异区间数量。解决难点主要在于证明翻转操作的无效性。

所选的题解：
  - **作者：_•́へ•́╬_ (5星)**
    - **关键亮点**：思路清晰，简洁地阐述了翻转不改变灵异区间个数的原因，代码使用快读优化输入，简洁高效。
    - **个人心得**：无
    ```cpp
    inline char nc()
    {
        static char buf[99999],*l,*r;
        return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
    }
    inline void read(int&x)
    {
        char c=nc();for(;c<'0'||'9'<c;c=nc());
        for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
    }
    int n,a[100009],cnt[1<<20];long long ans;
    main()
    {
        read(n);cnt[0]=1;
        for(int i=1;i<=n;++i)
        {
            read(a[i]);a[i]^=a[i-1];
            ans+=cnt[a[i]]++;
        }
        printf("%lld",ans);
    }
    ```
  - **作者：_mi_ka_ (4星)**
    - **关键亮点**：解题思路阐述详细，通过反证法严谨证明翻转不影响灵异区间个数，代码简洁明了。
    - **个人心得**：赛时未考虑翻转操作只求灵异区间个数却 AC，赛后证明了灵异区间翻转对个数无影响这一结论。
    ```cpp
    #include<bits/stdc++.h>
    #define int long long
    using namespace std;
    int n,ans,s,a,vis[1<<21];
    signed main()
    {
        scanf("%lld",&n),vis[0]=1;
        for(int i=1;i<=n;i++)
            scanf("%lld",&a),s^=a,ans+=vis[s],vis[s]++;
        cout<<ans;
        return 0;
    }
    ```
  - **作者：Shizaki_Crazy_Three (4星)**
    - **关键亮点**：先点明题意和难点，证明过程简洁，代码实现完整且注释详细。
    - **个人心得**：自己被翻转操作难住，证明翻转无意义后才顺利解题。
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    long long cnt[1500000]={};
    int main(){
        int n;
        cin>>n;
        int a;
        int sum[100005]={};
        int maxx=-1;
        for(int i=1;i<=n;i++){
            scanf("%d",&a);
            sum[i]=sum[i-1]^a;
            cnt[sum[i]]++;
            maxx=max(maxx,sum[i]);
        }
        long long ans=0;
        cnt[0]++;//自己想想，如果有零的话它不用匹配它自己也是一种情况 
        for(int i=0;i<=maxx;i++){
            ans+=(cnt[i]*(cnt[i]-1))/2;
        }
        cout<<ans;
        return 0;
    }
    ```

最优关键思路或技巧：利用异或运算性质证明翻转操作不影响灵异区间个数，将问题转化为简单的前缀异或和统计问题。通过记录前缀异或和出现的次数，利用组合数学知识计算灵异区间数量。

可拓展之处：此类题目可拓展到其他位运算相关的区间操作问题，以及更多基于区间性质的操作不变性证明问题。类似算法套路是遇到复杂区间操作时，先分析操作对关键区间性质的影响，尝试证明操作是否改变核心统计量，从而简化问题。

推荐题目：
  - [P3397 地毯轰炸](https://www.luogu.com.cn/problem/P3397)：涉及二维前缀和的应用，与本题前缀和思想类似。
  - [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：通过动态规划结合前缀和思想解决问题，可锻炼对区间性质的运用。
  - [P2004 领地选择](https://www.luogu.com.cn/problem/P2004)：需要利用前缀和优化暴力枚举，与本题优化思路有相似之处。 

---
处理用时：34.82秒
# 题目信息

# 「TAOI-2」核心共振

## 题目背景

⚡超越一切震慑凡人⚡

⚡带来终结机械降神⚡

⚡风暴之力充满全身⚡

⚡最后一击核心共振⚡

## 题目描述

给定正整数 $p$ 和 $n$。对于一个排列，我们称其中相邻两项产生「共振」当且仅当这两个数的和为 $p$ 的倍数。

请你构造一个 $1 \sim n$ 的排列，最大化其中产生「共振」的次数。如果有多种方案，输出任意一种即可。

## 说明/提示

**本题采用捆绑测试。**

+ Subtask 0（15 pts）：$n \leq 9$，$T \le 10$。
+ Subtask 1（10 pts）：$p = 2$。
+ Subtask 2（30 pts）：$p = 3$。
+ Subtask 3（45 pts）：无特殊限制。

对于所有数据，$1 \leq n \leq 10^5$，$1 \leq p \leq 10^8$，$1 \leq T \leq 10^4$，$1 \leq \sum n \leq 3\times 10^5$。

## 样例 #1

### 输入

```
3
9 1
5 2
1 12345
```

### 输出

```
3 8 7 1 4 5 6 9 2
1 5 3 2 4
1
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是基于数对 \(p\) 取模的余数来构造排列，以最大化共振次数。
 - **思路**：将 \(1\) 到 \(n\) 的数按模 \(p\) 的余数分类，让余数相加为 \(p\) 或 \(0\) 的数相邻放置。同时注意到当 \(2n \leq p\) 时，任意两个数的和都不可能是 \(p\) 的倍数，此时直接输出 \(1\) 到 \(n\) 的顺序排列。
 - **算法要点**：不同题解在实现上有所差异，有的通过暴力枚举全排列（仅适用于小数据），有的利用队列、集合优化存取，有的直接按规律构造输出。
 - **解决难点**：主要难点在于处理 \(p\) 为偶数时，模 \(p\) 余 \(\frac{p}{2}\) 的数的放置，以及如何优化代码避免超时，特别是当 \(p\) 较大时。

### 所选的题解
 - **作者：include13_fAKe (赞：11)  5星**
    - **关键亮点**：思路清晰，从简单子任务逐步推导到通用解法，详细分析了每个子任务的特点和构造方法，并给出了完整且简洁的代码实现。
    - **个人心得**：作者提到在处理较大 \(p\) 时因时间复杂度问题 TLE，尝试快读快写未解决，最终发现当 \(2n \leq p\) 时的特殊情况优化代码。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,p;
inline void solve(){
    scanf("%d%d",&n,&p);
    if(n*2<p){
        for(int i=1;i<=n;i++){
            printf("%d ",i);
        }
        return ;
    }
    for(int i=1;i*2<p;i++){
        for(int j=0;j<=n;j+=p){
            if(i+j<=n)    printf("%d ",i+j);
            if(j+p-i<=n)  printf("%d ",j+p-i);
        }
    }
    for(int i=p;i<=n;i+=p){
        printf("%d ",i);
    }
    if(p%2==0){
        for(int i=p/2;i<=n;i+=p){
            printf("%d ",i);
        }
    }
    printf("\n");
    return;
}
int T;
int main(){
    scanf("%d",&T);
    while(T--)    solve();
    return 0;
} 
```
    - **核心实现思想**：先判断 \(2n < p\) 的情况直接输出顺序排列。否则，枚举 \(1\) 到 \(\frac{p}{2}-1\) 的 \(i\)，将模 \(p\) 余 \(i\) 和模 \(p\) 余 \(p - i\) 的数交替输出，再输出 \(p\) 的倍数，最后单独处理 \(p\) 为偶数时模 \(p\) 余 \(\frac{p}{2}\) 的数。

 - **作者：I_will_AKIOI (赞：7)  4星**
    - **关键亮点**：使用队列和集合优化数据存取，通过哈希表思想将对 \(p\) 取模相同的数放在一起，利用队列存储，集合优化访问非空队列的操作，有效提高了代码效率。
    - **个人心得**：作者表示作为蒟蒻调试两小时，意识到使用双重循环选择非空队列易 TLE，从而用 set 优化。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,p,now;
queue<int>q[200001];
set<int>s;
int main()
{
    ios::sync_with_stdio(false);
    cin>>t;
    while(t--)
    {
        cin>>n>>p;
        if(p>=2*n)
        {
            for(int i=1;i<=n;i++) cout<<i<<" ";
            cout<<"\n";
            continue;
        }
        for(int i=2;i<=n;i++) q[i%p].push(i);
        for(int i=0;i<p;i++) if(!q[i].empty()) s.insert(i);
        now=1;
        cout<<now<<" ";
        for(int i=2;i<=n;i++)
        {
            int f=(p-now%p)%p;
            if(q[f].empty()) s.erase(f),f=*s.begin();
            now=q[f].front();
            q[f].pop();
            if(q[f].empty()) s.erase(f);
            cout<<now<<" ";
        }
        cout<<"\n";
    }
    return 0;
}
```
    - **核心实现思想**：先判断 \(p \geq 2n\) 情况直接输出顺序排列。否则，将 \(2\) 到 \(n\) 的数按模 \(p\) 放入队列，将非空队列下标插入集合。从 \(1\) 开始，每次根据当前数计算应取队列的下标，若队列为空则从集合中取一个非空队列下标，取出数并更新队列和集合状态。

 - **作者：Eason_cyx (赞：4)  4星**
    - **关键亮点**：从部分分入手，逐步分析 \(p = 2\)、\(p = 3\) 等特殊情况找规律，进而推广到一般情况，最后通过观察数据范围发现 \(p > 2n - 1\) 时的特殊情况优化代码，思路循序渐进。
    - **个人心得**：赛时被卡常，没想到特判 \(p > 2n - 1\) 的情况。
    - **核心代码**：
```cpp
if(p == 1 || (p > (2 * n - 1))) {
    for(int i = 1;i <= n;i++) cout << i << ' ';
    cout << "\n";
}
else if(p % 2 == 0) {
    int zu = n / p,mo = n % p;
    for(int i = 1;i * 2 < p-1;i++) {
        int first = i,second = p-i;
        for(int j = 1;j <= zu;j++) {
            cout << (j-1)*p+first << ' ' << (j-1)*p+second << ' ';
        }
        if(mo >= second) {
            cout << zu*p + first << ' ' << zu*p+second << ' ';
        }
        else if(mo < second && mo >= first) {
            cout << zu*p + first << ' ';
        }
    }
    for(int i = 1;i <= zu;i++) {
        cout << (i-1)*p + p / 2 << ' ';
    }
    if(mo >= p / 2) {
        cout << zu*p+p/2 << ' ';
    }
    for(int i = 1;i <= zu;i++) {
        cout << i*p << ' ';
    }
    cout << "\n";
}
else {
    int zu = n / p,mo = n % p;
    for(int i = 1;i * 2 <= p-1;i++) {
        int first = i,second = p-i;
        for(int j = 1;j <= zu;j++) {
            cout << (j-1)*p+first << ' ' << (j-1)*p+second << ' ';
        }
        if(mo >= second) {
            cout << zu*p + first << ' ' << zu*p+second << ' ';
        }
        else if(mo < second && mo >= first) {
            cout << zu*p + first << ' ';
        }
    }
    for(int i = 1;i <= zu;i++) {
        cout << i*p << ' ';
    }
    cout << "\n";
}
```
    - **核心实现思想**：先判断 \(p = 1\) 或 \(p > 2n - 1\) 情况直接输出顺序排列。对于 \(p\) 为偶数和奇数分别处理，通过计算 \(n\) 除以 \(p\) 的商和余数，枚举模 \(p\) 的余数 \(i\)，按规律交替输出模 \(p\) 余 \(i\) 和模 \(p\) 余 \(p - i\) 的数，再分别处理模 \(p\) 余 \(\frac{p}{2}\)（仅 \(p\) 为偶数时）和 \(p\) 的倍数的数。

### 最优关键思路或技巧
 - **利用取模余数分类**：将数字按模 \(p\) 的余数分类，根据余数和为 \(p\) 或 \(0\) 来构造排列，这是解决问题的核心思路。
 - **特殊情况判断优化**：敏锐观察到 \(2n \leq p\) 时的特殊情况，直接输出顺序排列，大大减少不必要计算，优化时间复杂度。
 - **数据结构优化存取**：如使用队列存储同类余数的数，集合优化对非空队列的访问，提高代码执行效率。

### 可拓展思路
此类题目属于构造类算法题，常需根据给定条件，通过数学分析找到规律来构造满足要求的解。类似套路包括：
 - **基于余数分析**：许多涉及数字和整除关系的问题，都可通过对数字取模的余数进行分类讨论，找到数字间的组合规律。
 - **特殊情况优先处理**：先找出数据范围中的特殊情况，单独处理，简化整体问题。

### 相似知识点洛谷题目
 - **P1116 车厢重组**：通过交换相邻车厢位置，使车厢编号从小到大排序，考察对相邻元素关系处理及简单排序算法思想，与本题对相邻元素和的处理思路类似。
 - **P1036 [NOIP2002 普及组] 选数**：从给定 \(n\) 个整数中选 \(k\) 个数，使它们的和为质数，涉及数的组合及质数判断，需对数字关系进行分析构造，与本题分析数字和的倍数关系有相似处。
 - **P1469 [USACO2.1] 数字三角形 Number Triangles**：按规则从三角形顶走到底，求经过数字和最大，需根据相邻层数字关系构造最优路径，与本题构造最优排列思路类似。

### 个人心得摘录与总结
 - **include13_fAKe**：在处理较大 \(p\) 时遇到 TLE，最初以为是输入输出问题，尝试快读快写未解决，最终发现 \(2n \leq p\) 时的特殊情况优化代码。总结为在解决问题时不能仅关注常规优化，要全面分析数据范围找到隐藏特殊情况。
 - **I_will_AKIOI**：作为蒟蒻调试两小时，意识到双重循环选择非空队列会导致 TLE，进而用 set 优化。说明在代码实现中要关注算法复杂度，及时发现并优化可能导致超时的操作。
 - **Eason_cyx**：赛时被卡常，没意识到 \(p > 2n - 1\) 时的特殊情况。强调了对数据范围细致分析的重要性，不能忽略能大幅优化代码的关键条件。 

---
处理用时：58.62秒
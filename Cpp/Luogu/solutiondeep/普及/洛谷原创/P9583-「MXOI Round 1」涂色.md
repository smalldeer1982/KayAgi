# 题目信息

# 「MXOI Round 1」涂色

## 题目描述

小 C 正在用彩铅给一张 $n$ 行 $m$ 列的方格纸涂色。初始时，所有方格都是空白的。

他一共要进行 $q$ 次涂色，每次涂色会选取一行或一列，给这一行或这一列的所有方格都添加 $1$ 层颜色。

小 C 喜欢浅色，所以他会在每次涂色结束后，把所有被涂上 $k$ 层颜色的方格的颜色都擦掉，让这些方格都变成空白的。

小 C 想知道，在最终共有多少方格被涂上了颜色。

## 说明/提示

#### 【样例解释 #1】

第 $1$ 行第 $1$ 列的方格没有被涂上颜色，第 $1$ 行第 $2$ 列的方格被涂上了 $1$ 层颜色，第 $1$ 行第 $3$ 列的方格没有被涂上颜色，第 $1$ 行第 $4$ 列的方格被涂上了 $1$ 层颜色；

第 $2$ 行第 $1$ 列的方格被涂上了 $1$ 层颜色，第 $2$ 行第 $2$ 列的方格被涂上了 $2$ 层颜色，第 $2$ 行第 $3$ 列的方格被涂上了 $1$ 层颜色，第 $2$ 行第 $4$ 列的方格被涂上了 $2$ 层颜色；

第 $3$ 行第 $1$ 列的方格被涂上了 $2$ 层颜色，第 $3$ 行第 $2$ 列的方格的颜色被擦掉了，第 $3$ 行第 $3$ 列的方格被涂上了 $2$ 层颜色，第 $3$ 行第 $4$ 列的方格的颜色也被擦掉了；

最终，共有 $8$ 个方格被涂上了颜色。

#### 【样例 #2】

见附加文件中的 `paint/paint2.in` 与 `paint/paint2.ans`。

该样例满足测试点 $1$ 的限制。

#### 【样例 #3】

见附加文件中的 `paint/paint3.in` 与 `paint/paint3.ans`。

该样例满足测试点 $5$ 的限制。

#### 【样例 #4】

见附加文件中的 `paint/paint4.in` 与 `paint/paint4.ans`。

该样例满足测试点 $20$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le n,m \le 2\times 10^5$，$1 \le k \le q \le 5 \times 10^5$，$op \in \{1,2\}$，保证当 $op=1$ 时 $1 \le x \le n$，当 $op=2$ 时 $1 \le x \le m$。

|测试点编号|$n,m \le$|$q \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim4$|$3000$|$3000$|无|
|$5\sim9$|$3000$|$5\times10^5$|无|
|$10\sim12$|$2\times10^5$|$5\times10^5$|A|
|$13\sim16$|$2\times10^5$|$5\times10^5$|B|
|$17\sim20$|$2\times10^5$|$5\times10^5$|无|

特殊性质 A：保证 $op=1$。

特殊性质 B：保证 $k=2$。

## 样例 #1

### 输入

```
3 4 5 3
1 3
2 4
1 2
1 3
2 2```

### 输出

```
8```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何高效统计最终涂色方格数量展开。由于直接暴力模拟会超时，多数题解采用了优化策略。思路上，大多通过记录每行和每列的涂色次数，利用取模运算和桶计数来统计最终涂色方格。算法要点在于对行和列操作的记录、取模处理以及桶的运用。难点在于如何避免暴力枚举方格，降低时间复杂度。部分题解还针对不同测试点给出了不同策略。
- **作者：wpy233 (赞：23)  5星**
  - **关键亮点**：通过引理证明最终涂色状态与操作顺序无关，利用三个引理简化问题，采用公式计算涂色方格数，思路清晰，代码简洁高效。
  - **个人心得**：强调“十年OI一场空，不开`ll`见祖宗”，提醒注意数据类型选择。
  - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long 
ll a[200005]; 
ll b[200005]; 
ll c[500005]; 
ll d[500005]; 
inline ll read()
{
    char ch;
    ll x=0,f=1;
    for(;!isdigit(ch);ch=getchar())
        if(ch=='-')
            f=-1;
    for(; isdigit(ch);ch=getchar())
        x*=10,x+=(ch-'0');
    return x*f;    
}
int main()
{
    int n,m,q,k;
    n=read(),m=read();
    q=read(),k=read();
    int op,x;
    for(int i=1;i<=q;i++)
    {
        op=read();
        x=read();
        if(op==1) 
        {
            a[x]++;
            if(a[x]==k) 
                a[x]=0; 
        } 
        else 
        {
            b[x]++;
            if(b[x]==k) 
                b[x]=0;
        } 
    }
    ll ans1=0,ans2=0,ans;
    for(int i=1;i<=n;i++)
        if(a[i]>0)
        {
            ans1++; 
            c[a[i]]++; 
        }
    for(int i=1;i<=m;i++)
        if(b[i]>0)
        {
            ans2++; 
            d[b[i]]++; 
        }
    ans=ans1*m+ans2*n-ans1*ans2; 
    for(int i=1,j=k-1;i<=k-1,j>=1;i++,j--)
        ans-=c[i]*d[j]; 
    cout<<ans<<endl;
    return 0;
}
```
  - **核心实现思想**：读入数据并对每行每列操作次数取模，统计非零操作次数的行和列数量，用桶记录每行每列不同操作次数的数量，通过公式计算涂色方格数，并减去交叉格数量。
- **作者：Coffee_zzz (赞：22)  5星**
  - **关键亮点**：针对不同测试点，逐步优化算法，从暴力模拟到利用数组记录操作，再到根据特殊性质优化，思路清晰，对不同情况分析全面。
  - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+5,K=5e5+5;
int c[N],r[N],w[K];
int main(){
    ios::sync_with_stdio(0);
    int n,m,q,k,op,x;
    ll cnt=0;
    cin>>n>>m>>q>>k;
    for(int tmp=1;tmp<=q;tmp++){
        cin>>op>>x;
        if(op==1) r[x]++;
        else c[x]++;
    }
    for(int i=1;i<=n;i++) w[r[i]%k]++;
    for(int j=1;j<=m;j++){
        c[j]%=k;
        if(c[j]==0) cnt=cnt+n-w[0];
        else cnt=cnt+n-w[k-c[j]];
    }
    cout<<cnt;
    return 0;
}
```
  - **核心实现思想**：记录每行每列操作次数，对操作次数取模后用桶统计每行操作次数取模后的分布，通过遍历列计算每列对答案的贡献。
- **作者：卷王 (赞：9)  4星**
  - **关键亮点**：思路简洁明了，通过两个数组记录行和列的涂色次数，利用桶统计行涂色次数取模后的数量，快速计算最终答案。
  - **核心代码**：
```cpp
#include <stdio.h>
typedef long long ll;
inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
    return x * f;
}
int n, m, q, k;
ll ans = 0;
int row[200007], col[200007];
int cnt[500007];
int main() {
    n = read(), m = read(), q = read(), k = read();
    while(q--) {
        int opt = read(), x = read();
        if(opt == 1) row[x] = (row[x] + 1) % k;
        else col[x] = (col[x] + 1) % k;
    }
    for(int i = 1; i <= n; i++) cnt[row[i]]++;
    for(int i = 1; i <= m; i++) ans += n - cnt[(k - col[i]) % k];
    printf("%lld", ans);
    return 0;
}
```
  - **核心实现思想**：读入操作并对行和列的涂色次数取模，用桶统计行涂色次数取模后的数量，通过遍历列计算每列对答案的贡献。

• **最优关键思路或技巧**：利用行和列的独立操作特性，通过数组记录每行每列的涂色次数，对 $k$ 取模后，借助桶数据结构统计不同余数的出现次数，从而避免对每个方格的暴力枚举，高效计算最终涂色方格数量。

• **同类型题或类似算法套路拓展**：此类题目通常涉及对大规模数据的行列操作及统计，常见套路是利用数组记录行列操作次数，结合取模运算简化状态，再通过桶或其他数据结构统计关键信息。

• **推荐洛谷题目**：
  - [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)：涉及区间元素统计，可通过类似桶计数思想优化。
  - [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)：字符串相关统计，需利用数据结构优化。
  - [P2392 kkksc03考前临时抱佛脚](https://www.luogu.com.cn/problem/P2392)：通过合理记录状态，运用动态规划或贪心思想解决问题，与本题记录行列状态有相似之处。

• **个人心得摘录与总结**：多数题解强调了开 `long long` 的重要性，避免数据溢出问题。在解决此类问题时，要善于观察数据范围，从暴力解法出发逐步优化，利用数学性质和合适的数据结构简化计算。 

---
处理用时：42.93秒
# 题目信息

# 「Daily OI Round 1」Tree

## 题目描述

给定三个正整数参数 $n,d,k$，你需要构造出一棵根节点为 $1$ 的树，满足这棵树有 $n$ 个节点，每个节点到根节点的距离和为 $d$，除了叶节点以外每个节点的**直接**儿子数量**至少** $k$ 个，且所有节点的最大深度最小。

**注意事项：**

- 距离：两个点之间的简单路径上的边的条数。
- 叶子节点：没有儿子的非根节点。
- 根节点深度为 $0$。

## 说明/提示

### **样例解释**

对于第二组样例的第二组询问，$n=5,d=6,k=2$，即需要构造出含有 $5$ 个节点，各个节点到节点 $1$ 的距离和为 $6$ 且除叶节点外的节点至少有 $k$ 个儿子节点。

下面是样例构造的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/wgir5yt5.png)

其中编号为 $1,2,3,4,5$ 的点到根节点 $1$ 的距离分别为 $0,1,1,2,2$，和为 $6$，满足条件。而且非叶子节点 $1,3$ 都含有至少 $2$ 个儿子节点，可以证明这是所有合法构造中节点的最大深度最小的解法，在此处为 $2$。

### **数据范围**
  
**本题开启捆绑测试。**

|$\text{Subtask}$|分值|$n \le$|特殊性质|
| :-----------: | :-------------:|:-----------: |:-----------: |
|$0$|$5$|$10$|无|
|$1$|$5$|$20$|无|
|$2$|$5$|$10^5$|$k= n-1$|
|$3$|$5$|$10^5$|$k= n-1$ 或 $n-2$|
|$4$|$10$|$10^5$|$T=1$|
|$5$|$70$|$10^5$|无|

对于全部数据，保证：$1 \le n \le 10^5$，$1 \le T \le 10^5$，$1 \le k \le 10^5$，$\sum n \le 10^6$，$1 \le d \le 10^{10}$。

## 样例 #1

### 输入

```
3
5 4 1
5 6 1
5 7 1```

### 输出

```
YES
1 1 1 1
YES
1 1 3 3
YES
1 2 2 2```

## 样例 #2

### 输入

```
3
5 4 2
5 6 2
5 7 2```

### 输出

```
YES
1 1 1 1
YES
1 1 3 3
NO```

# AI分析结果

• 综合分析与结论：这些题解主要围绕如何构造满足条件的树展开。思路上，大多先将问题转化为所有节点深度和为d，再通过不同方式确定树的最大深度及节点分布。算法要点包括枚举、贪心、二分查找等。解决难点在于平衡节点数量、深度和与儿子数量的限制关系。

所选的题解：
  - **作者：Acoipp (5星)**
    - **关键亮点**：思路清晰，对每个子任务分别阐述解法，针对最后一个子任务，通过枚举最大深度，根据每层至少k个节点的条件，结合剩余节点数和深度和的关系判断是否有解，代码实现简洁明了。
    - **核心代码片段**：
```cpp
for(i=1;i<=n;i++){
    if(i*(i+1)/2*k>d||i*k+1>n) break;
    j = d-i*(i+1)/2*k;
    l = (n-i*k-1);
    if(l*i>=j&&l<=j){
        j=i*l-j;
        temp=1;
        cout<<"YES\n";
        for(p=1;p<=i;p++){
            for(o=1;o<=k;o++) dep[++tot]=p;
        }
        for(p=1;p<=l;p++) dep[++tot]=i;
        for(p=tot-l+1;p<=tot;p++){
            if(dep[p]-1>=j){
                dep[p]-=j;
                break;
            }
            else j-=(dep[p]-1),dep[p]=1;
        }
        sort(dep+1,dep+tot+1);
        ans[0] = 1;
        for(p=1;p<=tot;p++) cout<<ans[dep[p]-1]<<" ",ans[dep[p]]=p+1;
        cout<<endl;
        break;
    }
}
```
    - **核心实现思想**：枚举最大深度i，计算该深度下每层k个节点的深度和，与d比较，并结合剩余节点数判断是否满足条件，若满足则确定各节点深度并构造树。

  - **作者：Nwayy (4星)**
    - **关键亮点**：发现问题可转化为经典的深度和构造问题，通过模拟每层节点的分配过程来构造树，代码简洁且逻辑清晰。
    - **核心代码片段**：
```cpp
while(1){
    int nxt=f;
    if(d==0) break;
    for(i=1;i<=k;i++){
        if(f>n){flg=1;break;}
        a[f++]=l[dep];   
    }    
    d-=k*dep;
    if((n-f+1)*dep>=d) break;
    else l[++dep]=nxt;
}
if(flg==1 || d<n-f+1) printf("NO\n");
else{
    printf("YES\n");
    for(i=f;i<=n;i++){
        while(1){
            if(d<dep || d-dep<n-i) dep--;
            else break;
        }
        a[i]=l[dep],d-=dep;
    }
    for(i=2;i<=n;i++) printf("%lld ",a[i]);
    printf("\n");
}
```
    - **核心实现思想**：通过循环依次为每层分配k个节点，根据剩余深度和节点数调整后续节点的深度，从而构造出满足条件的树。

  - **作者：ayun (4星)**
    - **关键亮点**：采用贪心策略，从树的深度角度出发，逐步增加层数，根据每层节点数与深度和的关系进行调整，思路直观，容易理解。
    - **个人心得**：作者提到当k == 1时，数组需开得较大才能AC所有点，这是在实际编程中对边界情况的处理经验。
    - **核心代码片段**：
```cpp
while(sum<d&&flag)
{
    if(cnt[now]<k)
    {
        flag=0;
        break;
    }
    cnt[now+1]=cnt[now]-k;
    cnt[now]=k;
    sum+=cnt[now+1];
    now++;
}
int x=sum-d,temp=1;
while(x&&flag&&temp<now)
{
    if(now-temp<=x)
    {
        cnt[temp]++;
        cnt[now]--;
        x-=now-temp;
    }
    else temp++;
}
if((cnt[now]<k||x)&&flag) flag=0;
if(!flag) {cout<<"NO"<<endl;continue;}
else
{
    cout<<"YES"<<endl;
    prv[0]=1;
    for(int i=1;i<=now;i++) prv[i]=prv[i-1]+cnt[i];
    fa[1]=1;
    for(int i=2;i<=now;i++) fa[i]=prv[i-2]+1;
    for(int i=1;i<=now;i++)
    {
        for(int j=1;j<=cnt[i];j++) cout<<fa[i]<<' ';
    }
    cout<<endl;
}
```
    - **核心实现思想**：先尽量增加层数使深度和接近d，若深度和大于d则将多余节点向上层移动，同时保证每层节点数满足要求，最后根据每层节点数确定节点间的父子关系。

• 最优关键思路或技巧：通过将问题转化为节点深度和的构造问题，利用枚举、二分或贪心策略，结合每层最少k个节点以及深度和的限制条件，确定树的最大深度和节点分布。如先构造基础树结构，再根据剩余节点和深度和的差值进行调整。

• 可拓展之处：同类型题可涉及不同的树结构构造要求，类似算法套路包括先确定关键参数（如最大深度），再根据限制条件进行节点分配和调整。

• 相似知识点洛谷题目：
  - [P1339 热浪](https://www.luogu.com.cn/problem/P1339)：涉及图论中最短路问题，与本题类似，需根据一定条件（距离限制等）构造路径，可加深对图结构和条件限制的理解。
  - [P2036 [COCI2008-2009#2] PERKET](https://www.luogu.com.cn/problem/P2036)：通过枚举组合来满足特定条件，与本题通过枚举最大深度确定树结构有相似的思维方式。
  - [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)：运用贪心策略解决问题，与本题ayun题解中的贪心思路类似，有助于掌握贪心算法在不同场景的应用。 

---
处理用时：41.53秒
# 题目信息

# 『GROI-R2』 不空白的画布

## 题目描述

我们都知道爱丽丝躲起来之后，坦尼尔坐在了空白画布面前，拿起炭笔开始作画。

但是现在画布已经不再空白，因为画布上已经有了当下的风景。我们设画布的长度是 $n$，每一单位长度上的颜色可以用一个在 $[1,k]$ 范围内的正整数表示。

坦尼尔还要画他已经翻了的茶杯。每一次作画，他可以选定画布上的任意一个位置，然后将这个位置上的颜色涂改成 $[1,k]$ 范围内的任意正整数。

最后，我们都知道这幅画是有记忆的。定义画上留下的记忆碎片数量为画上的**相同颜色连续块个数**。现在坦尼尔想知道，如果给定他作画的次数**上限**，那么画上的记忆碎片个数**最多**有多少。

**形式化题面**

你有连续的 $n$ 个方格，每个方格上有一个初始颜色 $c_i$，且保证 $1\le c_i \le k$。

你可以操作**至多** $m$ 次，每个操作为改变某个方格颜色，要求改变后的颜色范围仍在 $[1,k]$ 内。

我们称一个**极长相同颜色连续段**为一块，要求求出经过至多 $m$ 次操作后的**最多**块数。


## 说明/提示

**样例解释**

对于第一组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，得到 $\{c_n\}=\{2,1,2\}$，块数为 $3$。


对于第二组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，将从左到右的第三个位置涂成颜色 $3$，得到 $\{c_n\}=\{2,1,3,2,3\}$，块数为 $5$。

**数据范围**

**本题采用捆绑测试**。

| $\text{Subtask}$ | $\sum n\le$ | $m\le$ | $k\le$ | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------:  |
| $1$ | $10$ | $10$ | $3$ | $10$ |
| $2$ | $5\times 10^5$ | $1$ | $5\times 10^5$ | $10$ |
| $3$ | $10^3$ | $10^3$ | $10^3$ | $15$ |
| $4$ | $5\times 10^5$ | $5\times 10^5$ | $3$ | $25$ |
| $5$ | $5\times 10^5$ | $5\times 10^5$ | $5\times 10^5$ | $40$ |

对于 $100\%$ 的数据满足 $1\le  n\le 5\times 10^5$，$1\le \sum n\le 5\times 10^5$，$1\le m\le n$，$3\le  k \le 5\times 10^5$，$1\le c_i\le k$。


## 样例 #1

### 输入

```
2
3 1 3
2 2 2
5 2 4
2 2 2 2 3```

### 输出

```
3
5```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解均采用贪心策略。核心思路是利用 \(k \geq 3\) 的条件，优先处理长度大于等于3的相同颜色连续段，通过改变中间元素颜色，使相同颜色连续块个数增加2；之后若还有操作次数，再处理长度为2的相同颜色连续段，每次操作使块数增加1 。
    - 算法要点：先统计初始相同颜色连续块个数，然后按上述贪心策略遍历数组进行操作，最后输出最终的相同颜色连续块个数。
    - 解决难点：证明贪心策略的正确性，即优先处理长度大于等于3的连续段能使最终块数最多。通过分析可知，这样做能避免产生长度为2的连续段，从而使块数增加量最大。

    - 综合来看，各题解思路相似，主要区别在于代码实现的细节和可读性。

• 所选的题解：
  - 作者：fish_love_cat (5星)
    - 关键亮点：思路清晰简洁，代码简洁高效，通过自定义一些术语便于理解，且在代码中巧妙利用特殊值避免判断修改后的颜色是否与两边相同。
    - 重点代码及核心实现思想：
```cpp
int jsq=-1;
int main(){
    int t;cin>>t;
    while(t--){
        int n,m,k;cin>>n>>m>>k;
        int c[500005]={},ans=0;
        for(int i=1,flag=(--jsq);i<=n;i++){
            cin>>c[i];
            if(flag!=c[i]) ans++,flag=c[i];//初始统计答案
        }
        for(int i=2;m&&i<n;i++) if(c[i-1]==c[i]&&c[i]==c[i+1]) m--,c[i]=(--jsq),ans+=2;//枚举连三判断三连
        for(int i=1;m&&i<n;i++) if(c[i]==c[i+1]) m--,c[i]=(--jsq),ans++;//枚举连双判断双连
        cout<<ans<<endl;
    }
    return 0;
}
```
核心实现思想是先统计初始答案，然后按顺序优先处理三连（连三且颜色相同），再处理双连（连双且颜色相同），每次处理更新答案和操作次数。

  - 作者：kanzaki (4星)
    - 关键亮点：对题目分析详细，思路阐述清晰，代码结构完整，变量命名有一定意义，便于理解。
    - 重点代码及核心实现思想：
```cpp
#define maxn 500005
int t,m,n,k;
int tmp,flag=-10,ans;
int c[maxn];
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		ans=0,tmp=-10;
		cin>>n>>m>>k;
		for(int j=1;j<=n;j++){
			cin>>c[j];
			if(tmp!=c[j]){
				ans++;
				tmp=c[j];
			}
		}
		for(int j=2;j<n;j++){
			if(m<=0) break;
			if(c[j]==c[j-1]&&c[j]==c[j+1]){
				c[j]=flag;
				ans+=2;
				m--;
			}
		}
		for(int j=1;j<n;j++){
			if(m<=0) break;
			if(c[j]==c[j+1]){
				c[j]=flag;
				ans++;
				m--;
			}
		}
		cout<<ans<<endl;
		for(int j=1;j<=n;j++){
			c[j]=0;
		}
	}
	return 0;
} 
```
核心实现思想是先统计初始段数，然后优先处理长度为3的相同颜色连续段，再处理长度为2的相同颜色连续段，每次操作更新段数和剩余操作次数，最后输出结果并重置数组。

  - 作者：Wi_Fi (4星)
    - 关键亮点：采用优先队列维护相等连续段长度，思路新颖，代码简洁明了，利用优先队列的特性简化了贪心过程。
    - 重点代码及核心实现思想：
```cpp
const int INF=0x3f3f3f3f,N=5e5+5;
int i,T,n,m,k,c[N];
int main()
{
	cin>>T;
	while(T--)
	{
		int cnt=0,ans=0,sum=1;
		priority_queue<int>q;
		cin>>n>>m>>k;
		for(i=1;i<=n;i++)cin>>c[i];
		for(i=2;i<=n;i++)
		{
			if(c[i]==c[i-1])sum++;
			else q.push(sum),ans++,sum=1;
		}
		q.push(sum),ans++;
		for(i=1;i<=m;i++)
		{
			int fr=q.top(),l1,l2;
			if(fr==2)ans++;
			if(fr>=3)ans+=2;
			fr--,l1=1,l2=fr-1;
			q.pop(),q.push(l1),q.push(l2);
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
核心实现思想是先统计初始相同颜色连续段长度并放入优先队列，然后按操作次数从优先队列取出最长的连续段进行拆分，根据连续段长度更新答案，每次拆分后将新的连续段长度重新放入优先队列。

• 最优关键思路或技巧：利用贪心策略，优先处理长度大于等于3的相同颜色连续段，再处理长度为2的连续段，同时利用 \(k \geq 3\) 的条件简化颜色选择判断过程。在代码实现上，可巧妙利用特殊值避免复杂的颜色判断，或使用优先队列维护连续段长度以简化贪心操作。

• 可拓展之处：同类型题可考虑改变条件，如 \(k\) 的取值范围变化，或者操作次数限制方式改变等。类似算法套路是在一些具有局部最优子结构的问题中，通过分析不同局部情况的收益，采用贪心策略求解全局最优解。

• 相似知识点洛谷题目推荐：
  - P1090 [NOIP2004 提高组] 合并果子：通过贪心选择每次合并最小的两堆果子，与本题贪心选择收益最大的操作类似。
  - P1199 [NOIP2010 普及组] 三国游戏：需要通过合理的贪心策略选择武将，考察贪心思想。
  - P1248 加工生产调度：通过贪心算法安排生产顺序，使总时间最小，与本题思路有相似之处。

• 个人心得摘录及总结：无。 

---
处理用时：37.63秒
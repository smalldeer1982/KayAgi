# 题目信息

# Colo.

## 题目描述

小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 $n$，宽度为 $1$ 的网格图上画画，从左往右第 $i$ 个方格被涂成了一种颜色 $a_i$。

你觉得他的随意涂鸦太难看了，想要保留恰好 $k$ 种颜色（**你不能保留没在网格图上出现的颜色**），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。

此外，小 Y 使用的第 $i$ 种颜色有一个价值 $b_i$，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。

你需要求出你能够获得的最大的价值是多少。

## 说明/提示

#### 【样例解释 #1】

对于第一组样例，我们可以选择 $1$ 号和 $3$ 号颜色保留，剩下的网格图即为 $[1,1,3]$，满足单调不下降这一个限制，获得的价值即为 $b_1+b_3=5+1=6$，可以证明这是最优的办法。

#### 【数据范围】

对于所有测试数据，满足 $1 \le n \le 500$，$1 \le k \le 500$，$1 \le a_i \le n$，$1 \le b_i \le 10^9$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n,k \le $ | 特殊性质 |
| :-----------: | :-----------: | :-----------: |
| $1 \sim 3$ | $10$ | 无 |
| $4 \sim 5$ | $100$ | 无 |
| $6 \sim 10$ | $500$ | 不同的颜色不超过 $10$ 种 |
| $11 \sim 15$ | $500$ | 每种颜色出现的次数不超过 $2$ 次 |
| $16 \sim 20$ | $500$ | 无 |


## 样例 #1

### 输入

```
5 2
1 2 1 3 2
5 3 1 100 100```

### 输出

```
6```

## 样例 #2

### 输入

```
10 3
1 3 4 2 9 3 4 2 5 1
1 5 2 3 9 8 1 2 3 10```

### 输出

```
-1```

# AI分析结果

• 综合分析与结论：
  - 这些题解都围绕动态规划（DP）算法展开，思路核心在于通过定义合适的状态和状态转移方程来解决问题。算法要点包括预处理颜色出现的位置信息（如首次和末次出现位置），以判断颜色间的先后顺序关系，满足最终颜色序列单调不下降的要求。解决难点在于如何准确地定义状态，使得状态转移方程能够正确反映问题的逻辑，同时要考虑各种边界条件和限制。
  - 大部分题解的思路清晰度和代码可读性尚可，但在优化程度上普遍不足，多数直接采用$O(n^2k)$的时间复杂度实现，未做进一步优化。

所选的题解：
  - **作者：卷王 (赞：27)  星级：4星**
    - **关键亮点**：思路清晰，采用经典的“问啥设啥”方式定义状态$dp_{i,j}$，表示考虑前$i$种颜色并选用第$i$种颜色，一共选择了$j$种颜色的方案数，转移方程明确，代码简洁明了。
    - **重点代码**：
```cpp
int main() {
    n = read(), k = read();
    for(int i = 1; i <= n; i++) {
        a[i] = read();
        if(l[a[i]] == 0) l[a[i]] = i;
        r[a[i]] = i;
    }
    for(int i = 1; i <= n; i++) b[i] = read();
    memset(dp, -0x3f, sizeof(dp)); dp[0][0] = 0;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= k; j++)
            for(int m = 0; m < i; m++)
                if(a[i] > a[m] && l[a[i]] > r[a[m]]) 
                    if(dp[m][j - 1] >= 0)
                        dp[i][j] = max(dp[i][j], dp[m][j - 1] + b[a[i]]);
    for(int i = 1; i <= n; i++)
        ans = max(ans, dp[i][k]);
    printf("%lld", ans);
    return 0;
}
```
    - **核心实现思想**：先读入数据并预处理每种颜色首次和末次出现位置。初始化$dp$数组，通过三层循环进行状态转移，最外层遍历颜色，中间层遍历选择颜色的数量，内层寻找满足条件（颜色编号递增且位置符合顺序）的前序颜色进行转移，最后统计答案。

  - **作者：zaochen (赞：14)  星级：4星**
    - **关键亮点**：提供了一种类似最长上升子序列的线性DP思路，状态定义较为巧妙，且通过分析逐步简化状态，优化空间复杂度，代码注释详细。
    - **重点代码（简化后）**：
```cpp
signed main()
{
    ios::sync_with_stdio(false);
    cin >> n >> k;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        r[a[i]] = i;
        if (l[a[i]] == 0)
            l[a[i]] = i;
    }
    for (int i = 1; i <= n; i++)
        cin >> b[i];
    memset(dp, -1, sizeof dp);
    for (int i = 1; i <= n; i++)
        dp[i][1] = b[i];
    for (int j = 2; j <= k; j++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int c = 1; c < i; c++)
            {
                if (l[c] && r[c] < l[i] && dp[c][j - 1]!= -1)
                {
                    dp[i][j] = max(dp[i][j], dp[c][j - 1] + b[i]);
                }
            }
        }
    }
    int ans = -1;
    for (int i = 1; i <= n; i++)
        if (l[i])
        {
            ans = max(ans, dp[i][k]);
        }
    cout << ans << endl;
    return 0;
}
```
    - **核心实现思想**：读入数据并记录颜色位置信息，初始化$dp$数组。通过三层循环，外层控制选择颜色数量，中间层遍历颜色，内层寻找符合条件（颜色编号递增且位置顺序正确）的前序颜色进行状态转移，最后统计答案。

  - **作者：TridentDeer (赞：12)  星级：4星**
    - **关键亮点**：先观察到最终留下颜色序列相同颜色一定连续的性质，基于此处理出每个颜色前面可能接着的颜色，再进行DP，思路独特，代码实现简洁高效。
    - **重点代码**：
```cpp
signed main(){
    n=read();k=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        if(!l[a[i]])l[a[i]]=i;
        r[a[i]]=i;
    }
    for(int i=1;i<=n;i++)w[i]=read();
    for(int i=0;i<=n;i++){
        for(int j=1;j<=k;j++)dp[i][j]=-1e18;
    }
    for(int i=1;i<=n;i++){e[a[i]].push_back(0);
        for(int j=1;j<=n;j++){
            if(i==j)continue;
            if(r[a[j]]<l[a[i]]&&a[i]>a[j])e[a[i]].push_back(a[j]);
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<e[a[i]].size();j++){
            int v=e[a[i]][j];
            for(int p=1;p<=k;p++){
                dp[a[i]][p]=max(dp[a[i]][p],dp[v][p-1]+w[a[i]]);
            }
        }
    }
    int mx=-1;
    for(int i=1;i<=n;i++)mx=max(mx,dp[i][k]);
    cout<<mx;
    return 0;
}
```
    - **核心实现思想**：读入数据并记录颜色位置信息，初始化$dp$数组。先通过循环处理出每个颜色可连接的前序颜色，再通过三层循环进行状态转移，外层遍历颜色，中层遍历可连接颜色，内层遍历选择颜色数量进行转移，最后统计答案。

**最优关键思路或技巧**：
  - 预处理颜色的首次和末次出现位置，利用这些信息判断颜色间的顺序关系，以满足最终颜色序列单调不下降的要求。
  - 合理定义DP状态，通常以考虑的颜色数量、当前颜色以及已选颜色数量等维度来定义，使得状态转移方程能够简洁准确地反映问题的递推关系。

**可拓展思路**：
  - 此类问题属于序列上的DP优化问题，可拓展到其他具有顺序要求和选择限制的序列问题，如在满足一定条件下选择子序列求最值。类似算法套路是先分析题目条件确定状态维度，通过预处理简化状态转移时的判断条件，从而构建高效的状态转移方程。

**推荐题目**：
  - [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)：经典的最长不上升子序列问题，与本题类似，需通过DP求解满足特定顺序要求的子序列相关问题。
  - [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)：通过DP求两个序列的最长公共子序列，同样涉及状态定义和转移，与本题在DP思路上有相似之处。
  - [P1103 书本整理](https://www.luogu.com.cn/problem/P1103)：在一定限制条件下对序列进行操作求最值，锻炼DP状态设计和转移方程构建能力，与本题思路相近。

**个人心得摘录**：
  - **作者：Pengzt**：赛时在连边时没判颜色编号调了很久。总结为在实现过程中，细节条件的判断很重要，容易因小失大导致代码出错。
  - **作者：哈哈人生**：提到处理数组$dp$和$w$之间的取舍是难点，采用了一种赌的成分的处理方式，先设定参数，根据长度情况分别处理长度和权值的更新。这反映出在面对复杂的DP问题时，若常规思路难以直接解决，可以尝试一些特殊的处理方法，但这种方法可能不够严谨，有一定局限性。 

---
处理用时：52.94秒
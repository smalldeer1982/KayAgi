# 题目信息

# 「QFOI R1」摸摸

## 题目描述

小 R 是一个可爱的女孩子，她喜欢被摸头。

但是摸头之前，必须答对她提出的一个问题。

她有一个长度为 $n$ 的数列 $a$，初始时所有元素均为 $0$。另有两个长度为 $n$ 的数列 $t,b$。

她可以进行两种操作：

1. 将 $t$ 与 $t$ 的倒序对应元素相加，得到新的 $t$。
    - 例如，$t=[1,4,2]$ 变为 $t'=[1+2,4+4,2+1]=[3,8,3]$。
2. 将 $a$ 与 $t$ 对应元素相加，得到新的 $a$。
    - 例如，$a=[1,2,3],t=[1,4,2]$ 变为 $a'=[1+1,2+4,3+2]=[2,6,5]$。

是否可能通过若干次以上操作将 $a$ 变为 $b$？

你希望摸她的头 $T$ 次，因此有 $T$ 组数据。

## 说明/提示

**样例解释**

对于第一组数据：

- 初始时：$a=[0,0,0]$，$t=[1,2,2]$，$b=[5,8,7]$。
- 执行操作二：$a=[1,2,2]$，$t=[1,2,2]$，$b=[5,8,7]$。
- 执行操作二：$a=[2,4,4]$，$t=[1,2,2]$，$b=[5,8,7]$。
- 执行操作一：$a=[2,4,4]$，$t=[3,4,3]$，$b=[5,8,7]$。
- 执行操作二：$a=[5,8,7]$，$t=[3,4,3]$，$b=[5,8,7]$。

此时 $a=b$，符合要求。

对于第二组数据，可以证明不存在合法方案。

---

**数据范围**

本题共 $20$ 个测试点，每个测试点 $5$ 分。

记 $\sum n$ 表示每组数据的 $n$ 之和。

对于全部数据，保证 $1\le\sum n\le 2\times 10^3$，$n\ge 1$，$1\le t_i,b_i\le 2\times 10^3$。

- 对于测试点 $1\sim 4$：保证 $n\le 2$。
- 对于测试点 $5\sim 8$：保证所有 $t_i$ 都相等。
- 对于测试点 $9\sim 12$：保证 $b_i=b_{n-i+1}$。
- 对于测试点 $13\sim 16$：保证 $\sum n,t_i,b_i\le 200$。
- 对于测试点 $17\sim 20$：无特殊限制。

---

**Hack 数据**

本题在赛后添加了 Hack 数据，从 $21$ 开始编号。

原有测试点依然计 $5$ 分，Hack 数据计 $0$ 分，但只有通过所有数据才会被判为 Accepted。

为区分原有测试点和 Hack 数据，本题添加了子任务，但子任务的计分方式为“加和”，不会影响正常评测。

## 样例 #1

### 输入

```
2
3
1 2 2
5 8 7
3
1 2 2
2 4 3```

### 输出

```
Yes
No```

# AI分析结果

### 综合分析与结论
这些题解的核心思路大多基于证明操作一最多进行一次，之后将问题转化为判断是否能用原始的 \( t \) 序列和操作一次后的回文 \( t \) 序列，通过不同次数的累加得到目标序列 \( b \)。各题解在具体实现上有所差异，有的采用暴力枚举，有的通过解方程来判断。

### 所选的题解
1. **作者：rui_er (赞：22)**
    - **星级**：5星
    - **关键亮点**：思路清晰，证明了操作一最多进行一次，并基于此枚举操作一之前的操作二次数，检查是否能通过后续操作二使 \( a = b \)。代码简洁明了，逻辑严谨。
    - **重点代码**：
```cpp
while(true) {
    bool valid = true;
    rep(i, 1, n) if(a[i] > b[i]) valid = false;
    if(!valid) break;
    if((b[1] - a[1]) % s[1] == 0) {
        int steps = (b[1] - a[1]) / s[1];
        bool ok = true;
        rep(i, 1, n) if(b[i]!= a[i] + steps * s[i]) ok = false;
        if(ok == true) {ans = true; break;}
    }
    rep(i, 1, n) a[i] += t[i];
}
```
    - **核心实现思想**：不断尝试在当前 \( a \) 基础上增加 \( t \)，若 \( a \) 中某元素超过 \( b \) 对应元素则停止。若 \( b[1] - a[1] \) 能被操作一后 \( t \) 的第一个元素整除，计算操作次数并检查是否所有元素都满足 \( b[i] = a[i] + \) 操作次数 \( \times s[i] \)，满足则找到答案。
2. **作者：MrPython (赞：1)**
    - **星级**：4星
    - **关键亮点**：通过数学方法列出方程求解，利用操作一最多进行一次的性质，对 \( a \) 数组变化过程中的两个关键状态进行分析，列出方程组求解 \( x \) 和 \( y \)，并考虑了分母为 0 等特殊情况。
    - **重点代码**：
```cpp
for (size_t i = 0, j = n - 1; i < pr.size(); ++i, --j) { 
    if (t[i] == t[j]) 
        pr[i] = {-1, -1}; 
    else {
        if ((b[i] - b[j]) % (t[i] - t[j])) NO 
        pr[i].first = (b[i] - b[j]) / (t[i] - t[j]); 
        if ((b[i] - pr[i].first * t[i]) % (t[i] + t[j])) NO 
        pr[i].second = (b[i] - pr[i].first * t[i]) / (t[i] + t[j]); 
        if (pr[i].first < 0 || pr[i].second < 0) NO;  
    }
}
```
    - **核心实现思想**：遍历数组，对于 \( t[i] \neq t[n - i - 1] \) 的情况，根据方程计算 \( x \) 和 \( y \)，检查是否能整除且解为非负。对于 \( t[i] = t[n - i - 1] \) 的特殊情况单独处理。
3. **作者：WaterSun (赞：1)**
    - **星级**：4星
    - **关键亮点**：思路直接，通过枚举使用原始 \( t \) 序列和操作一次后 \( t \) 序列的次数，判断能否得到目标序列 \( b \)，并通过添加条件限制枚举范围来保障时间复杂度。
    - **重点代码**：
```cpp
for (re int x = 0; x * t[1] <= b[1]; x++) {
    for (re int y = 0; x * t[1] + y * tt[1] <= b[1]; y++) {
        bool ok = true;
        for (re int i = 1; i <= n; i++) {
            if (b[i]!= x * t[i] + y * tt[i]) {
                ok = false;
                break;
            }
        }
        if (ok) {
            falg = true;
            break;
        }
    }
}
```
    - **核心实现思想**：双重循环枚举 \( x \) 和 \( y \)，分别表示使用原始 \( t \) 序列和操作一次后 \( t \) 序列的次数，对于每对 \( x \) 和 \( y \)，检查是否所有 \( b[i] = x \times t[i] + y \times tt[i] \)，满足则找到答案。

### 最优关键思路或技巧
- **操作一的性质分析**：证明操作一最多进行一次是解题的关键，这大大简化了问题，将多种可能的操作序列转化为只需要考虑原始 \( t \) 序列和操作一次后的回文 \( t \) 序列的组合。
- **枚举与条件判断**：通过枚举操作次数并结合整除性、非负性等条件判断是否能得到目标序列，是一种直接有效的解题方式。在枚举时合理设置边界条件可以优化时间复杂度。

### 可拓展之处
同类型题目通常会给出一些初始状态和操作规则，要求判断能否通过一系列操作达到目标状态。解题套路一般是先分析操作对数据的影响，找出操作的关键性质（如本题中操作一最多执行一次），然后基于这些性质转化问题，通过枚举、解方程或其他数学方法求解。

### 相似知识点洛谷题目
- **P1028 [NOIP2001 普及组] 数的计算**：通过给定的规则对数字进行操作，判断符合条件的数字个数，考察对操作规则的理解和简单的枚举计算。
- **P1164 小A点菜**：给定金额和菜品价格，判断能否通过选择菜品达到指定金额，类似本题通过不同元素组合得到目标值的思路。
- **P1219 [USACO1.5] 八皇后 Checker Challenge**：在给定规则下放置棋子，判断是否存在可行方案，同样需要分析规则并通过枚举等方式求解。

### 个人心得摘录与总结
暂无。 

---
处理用时：34.39秒
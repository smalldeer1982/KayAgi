# 题目信息

# 「RiOI-03」匀速相遇

## 题目背景

当大家都在加速时，我与你，在人生中的十字路口，匀速地相遇了。

确是惊动我心的一瞥，却是无法逗留的遗憾，我们再次，朝着自己的方向匀速奔跑。下次再见，又会是什么时候呢……

## 题目描述

平面直角坐标系上有 $n + m$ 个点，其中：

- 有 $n$ 个 $\rm A$ 类点，它们在初始时依次位于位置 $(1, 0), (2, 0), (3, 0), \dots, (n, 0)$。
- 有 $m$ 个 $\rm B$ 类点，它们在初始时依次位于位置 $(0, 1), (0, 2), (0, 3), \dots, (0, m)$。

在某一个时刻，$\rm A, B$ 类点同时开始运动。具体地：

- 对于第 $i$ 个 $\rm A$ 类点，其以 $a_i$ 个单位长度每秒的速度向上（即 $y$ 轴正方向）匀速运动。特别地，若 $a_i = 0$，则该点始终保持静止。
- 对于第 $i$ 个 $\rm B$ 类点，其以 $b_i$ 个单位长度每秒的速度向右（即 $x$ 轴正方向）匀速运动。特别地，若 $b_i = 0$，则该点始终保持静止。

相遇与分离实在是再平凡不过的了。作为匆匆时光里的一名过客，在这个你暂留的驿站里，你能否帮小 T 解决这个简单的问题：求出有多少点对会在某个时刻相遇，即它们在某一刻共点。

由于你无法使时间静止，所以所有点无论相遇与否，都会永无止境地运动下去。祝愿在这道路上奔跑的你，能有一天与理想匀速相遇，永不停息。

## 说明/提示

### 样例解释 1

当 $t = 1$ 时，第 $2$ 个 $\rm A$ 类点和第 $2$ 个 $\rm B$ 类点同时到达点 $(2, 2)$。这也是在本组样例中的唯一一次相遇，故输出 $1$。

### 数据规模与约定

**本题开启捆绑测试。**

+ Subtask 0（10 pts）：$n \leq 10$，$m \leq 10$。
+ Subtask 1（20 pts）：$n \leq 5\times 10^3$，$m \leq 5\times 10^3$。
+ Subtask 2（30 pts）：保证 $\forall a_i \geq 1$，$\forall b_i \geq 1$。
+ Subtask 3（40 pts）：无特殊限制。

对于所有数据，$1 \leq n, m \leq 10^6$，$0 \leq a_i, b_i \leq 10^9$。

## 样例 #1

### 输入

```
3 3
1 2 3
3 2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3
2 5 1
83 101 98```

### 输出

```
0```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是通过推导得出两个点相遇的条件为 \(a_i \times i = b_j \times j\)，然后基于此进行算法设计。
- **暴力思路**：直接枚举所有的 \(A\) 类点和 \(B\) 类点，判断是否满足相遇条件，时间复杂度为 \(\mathcal{O}(n \times m)\)，仅适用于数据规模小的情况。
- **优化思路**：利用哈希表（如 `unordered_map`）来记录 \(a_i \times i\) 的出现次数，遍历 \(b\) 数组时，统计满足 \(a_i \times i = b_j \times j\) 的对数，时间复杂度降为 \(\mathcal{O}(n + m)\) 。部分题解还提到用排序加双指针或二分查找的方法来统计相同值的个数，时间复杂度为 \(\mathcal{O}(n \log n + m \log m)\)，但这种方法相对复杂且常数较大。

综合来看，使用 `unordered_map` 来优化统计过程是较为通用且高效的做法，大部分题解都采用了这种思路。

### 所选的题解
1. **作者：cff_0102 (赞：13)  星级：5星**
    - **关键亮点**：思路清晰，先推导相遇条件公式，然后详细阐述利用 `unordered_map` 实现的过程，代码简洁明了，注释详细。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1145141],b[1145141];
unordered_map<long long,int> ai;
int main(){
    ios::sync_with_stdio(false);
    int n,m;cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]!=0){
            long long temp=1ll*i*a[i];
            ai[temp]++;//ai[temp] 存的是满足 i*a_i=temp 的 i 的个数
        }
    }
    long long s=0;
    for(int j=1;j<=m;j++){
        cin>>b[j];
        if(b[j]!=0){
            long long temp=1ll*j*b[j];
            if(ai.count(temp)){//如果有 i 满足 i*a_i=j*b_j
                s+=ai[temp];//则将满足等式的 i 的个数加到答案中
            }
        }
    }
    cout<<s;
    return 0;
}
```
    - **核心实现思想**：先遍历 \(A\) 类点，将 \(a_i \neq 0\) 时的 \(i \times a_i\) 存入 `unordered_map` 并计数。再遍历 \(B\) 类点，对于 \(b_j \neq 0\) 的情况，检查 `unordered_map` 中是否存在相同的 \(j \times b_j\)，若存在则将对应计数加到答案中。
2. **作者：20111019Yu (赞：3)  星级：4星**
    - **关键亮点**：先给出暴力解法，再逐步优化到用 `unordered_map` 的高效解法，对思路的讲解有层次感，且提到了 `map` 常数大的问题。
    - **重点代码**：
```cpp
#include <iostream>
#include <unordered_map>
#define int long long
using namespace std;
int n, m, a, b, ans;
unordered_map<int, int> mp;

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for( int i = 1; i <= n; i++ ){
		cin >> a;
		mp[a * i]++;
	}
	for( int i = 1; i <= m; i++ ){
		cin >> b;
		ans +=!b? 0 : mp[b * i]; 
	}
	cout << ans;
	return 0;
}
```
    - **核心实现思想**：与 cff_0102 的思路类似，先遍历 \(A\) 类点存入 `unordered_map`，再遍历 \(B\) 类点，根据 \(b_j\) 是否为 \(0\) 来决定是否从 `unordered_map` 中获取对应值加到答案。
3. **作者：minVan (赞：3)  星级：4星**
    - **关键亮点**：同样先给出暴力思路及代码，再给出优化后的正解，逻辑连贯，清晰地阐述了用 `unordered_map` 优化的原因及过程。
    - **重点代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 5;
int n, m, a[N], b[N];
unordered_map<int, int> mp;
signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> n >> m;
  for(int i = 1; i <= n; i++) {
    cin >> a[i];
    ++mp[a[i] * i];
  }
  int ans = 0;
  for(int i = 1; i <= m; i++) {
    cin >> b[i];
    ans += (!b[i]? 0 : mp[b[i] * i]);
  }
  cout << ans;
  return 0;
}
```
    - **核心实现思想**：先处理 \(A\) 类点，将 \(a_i \times i\) 存入 `unordered_map` 计数，处理 \(B\) 类点时，根据 \(b_i\) 是否为 \(0\) 决定是否累加 `unordered_map` 中对应的值到答案。

### 最优关键思路或技巧
利用数学推导得出相遇条件 \(a_i \times i = b_j \times j\)，并借助哈希表 `unordered_map` 来高效统计满足该条件的点对数量。这种方法将原本 \(\mathcal{O}(n \times m)\) 的暴力枚举优化到了 \(\mathcal{O}(n + m)\) 的线性时间复杂度，极大提高了算法效率。

### 可拓展思路
此类题目属于平面上点的运动相遇问题，相似套路是通过分析运动关系得出关键等式，再利用合适的数据结构（如哈希表、排序数组结合双指针或二分等）优化统计过程。类似题目可能会改变点的初始位置、运动方向或速度变化规律，但核心思路仍是通过数学分析建立等式关系，再进行算法优化。

### 相似知识点洛谷题目
1. [P1833 樱花](https://www.luogu.com.cn/problem/P1833)：通过数学推导转化问题，利用数论知识和数据结构优化求解。
2. [P2671 求和](https://www.luogu.com.cn/problem/P2671)：需要推导公式，然后借助数据结构优化统计满足条件的数对数量。
3. [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)：通过数学性质推导，利用数据结构优化计算过程。

### 个人心得摘录与总结
部分作者提到在使用 `map` 时由于常数过大导致超时，而改用 `unordered_map` 解决问题。这表明在算法竞赛中，数据结构的常数对程序的运行效率有重要影响，需要根据题目数据范围和时间限制选择合适的数据结构。同时，推导数学公式是解决此类问题的关键，清晰的思路和简洁的代码实现有助于快速解题。 

---
处理用时：35.32秒
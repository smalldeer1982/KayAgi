# 题目信息

# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# AI分析结果

### 综合分析与结论

本题的核心是区间动态规划（DP），每行的取数操作相互独立，因此可以对每行单独进行DP处理。大多数题解都采用了区间DP的思路，状态转移方程也基本一致，主要区别在于实现细节和优化程度。部分题解使用了高精度或`__int128`来处理大数运算，避免了溢出问题。整体来看，区间DP是解决该问题的标准方法，关键在于如何高效地处理大数运算和优化DP的实现。

### 所选高星题解

#### 1. 作者：zhylj (5星)
- **关键亮点**：思路清晰，代码简洁，使用了`__int128`处理大数运算，避免了高精度的复杂性。状态转移方程简洁明了，且通过预处理2的幂次优化了计算。
- **核心代码**：
  ```cpp
  __int128 solve(__int128 a[]) {
      memset(f, 0, sizeof(f));
      for(int len=0;len<=m;++len)
          for(int i=1;i+len<=m;++i)
              f[i][i+len]=max(2*f[i+1][i+len]+2*a[i],2*f[i][i+len-1]+2*a[i+len]);
      return f[1][m];
  }
  ```
- **个人心得**：作者提到“转移方程似乎和楼下的都不太一样”，表明其独特的思考方式，通过将每次取数的得分乘以2来简化计算，避免了复杂的幂次运算。

#### 2. 作者：qhr2023 (4星)
- **关键亮点**：代码简洁，使用了`__int128`，状态转移方程清晰，且通过预处理2的幂次优化了计算。整体实现较为高效。
- **核心代码**：
  ```cpp
  for (int len=1; len<=m; ++len) 
      for (int l=1, r=l+len-1; r<=m; ++l, ++r)
          f[l][r]=max(f[l+1][r]+a[i][l], f[l][r-1]+a[i][r])*2;
  ```
- **个人心得**：作者提到“从小区间向大区间转移”，表明其对DP转移顺序的深入理解，确保了DP的正确性。

#### 3. 作者：lihongru (4星)
- **关键亮点**：详细解释了DP的状态转移过程，特别是如何处理取数的顺序和得分计算。使用了`__int128`，代码结构清晰。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= m; i++) {
      for (int j = m; j >= i; j--) {
          dp[k][i][j] = max(dp[k][i][j], dp[k][i][j+1] + a[k][j+1] * (k1 << m - len));
          dp[k][i][j] = max(dp[k][i][j], dp[k][i-1][j] + a[k][i-1] * (k1 << m - len));
      }
  }
  ```
- **个人心得**：作者提到“分数的倍率取决于取了多少个数，而不是目前转移区间的长度”，表明其对问题本质的深刻理解。

### 最优关键思路与技巧

1. **区间DP**：每行的取数操作可以看作是一个区间DP问题，状态转移方程通常为`f[l][r] = max(f[l+1][r] + a[l] * 2^k, f[l][r-1] + a[r] * 2^k)`，其中`k`为取数的次数。
2. **大数处理**：使用`__int128`或高精度处理大数运算，避免溢出问题。
3. **预处理幂次**：预处理2的幂次，优化计算效率。

### 可拓展之处

1. **类似题目**：可以考虑其他区间DP问题，如石子合并、最长回文子序列等。
2. **优化技巧**：进一步优化DP的实现，如使用滚动数组减少空间复杂度。

### 推荐题目

1. **P1880 [NOI1995] 石子合并**：区间DP经典题目，考察如何合并石子以获得最大或最小得分。
2. **P1040 加分二叉树**：区间DP与树形结构的结合，考察如何构建二叉树以获得最大加分。
3. **P1063 能量项链**：区间DP的变种，考察如何合并能量项链以获得最大能量。

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中遇到的困难，如高精度的实现和DP转移顺序的调整，表明调试是解决问题的关键步骤。
- **踩坑教训**：一些作者提到在处理大数运算时容易忽略溢出问题，提醒我们在处理大数时要特别注意数据类型的选择。
- **顿悟感想**：部分作者通过深入理解问题的本质，提出了独特的解决方案，表明深入思考是优化算法的重要途径。

---
处理用时：32.64秒
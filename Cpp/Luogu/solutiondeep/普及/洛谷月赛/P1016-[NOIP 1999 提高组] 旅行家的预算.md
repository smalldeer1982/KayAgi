# 题目信息

# [NOIP 1999 提高组] 旅行家的预算

## 题目描述

一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离 $D_1$、汽车油箱的容量 $C$（以升为单位）、每升汽油能行驶的距离 $D_2$、出发点每升汽油价格$P$和沿途油站数 $N$（$N$ 可以为零），油站 $i$ 离出发点的距离 $D_i$、每升汽油价格 $P_i$（$i=1,2,…,N$）。计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出 `No Solution`。


## 说明/提示

$N \le 6$，其余数字 $ \le 500$。

NOIP1999 普及组第三题、提高组第三题

## 样例 #1

### 输入

```
275.6 11.9 27.4 2.8 2
102.0 2.9
220.0 2.2
```

### 输出

```
26.95
```

# AI分析结果

### 综合分析与结论

本题的核心是通过贪心算法模拟旅行家在加油站之间的决策，目标是找到最小花费的加油策略。大部分题解采用了贪心+模拟的思路，主要分为以下几种策略：

1. **贪心策略**：在每个加油站，优先选择能到达的下一个油价更低的加油站，尽量少加油；如果没有更便宜的加油站，则加满油，前往能到达的最便宜的加油站。
2. **单调队列优化**：通过维护一个单调队列，确保每次加油时使用的油是最便宜的，减少不必要的开销。
3. **DFS+剪枝**：通过深度优先搜索遍历所有可能的加油方案，结合剪枝优化，减少不必要的计算。

### 所选高星题解

#### 1. 题解作者：Twilight_ (赞：2097)
- **星级**：★★★★★
- **关键亮点**：思路清晰，代码简洁，通过贪心策略和模拟过程，详细解释了每一步的决策逻辑。代码可读性强，优化程度高。
- **核心实现思想**：在每个加油站，计算能到达的下一个油价更低的加油站，并决定加油量。如果没有更便宜的加油站，则加满油，前往能到达的最便宜的加油站。
- **核心代码**：
  ```cpp
  int move(int now) {
      int can = 99999;
      for (int i = now + 1; i <= n && pl[i].dis - pl[now].dis <= maxx; i++) {
          if (pl[i].co < pl[now].co) {
              mo += ((pl[i].dis - pl[now].dis - temlen) / d2) * pl[now].co;
              temlen = 0;
              return i;
          }
          if (can == 99999 || pl[i].co < pl[can].co) can = i;
      }
      if (d1 - pl[now].dis <= maxx) {
          mo += ((d1 - pl[now].dis - temlen) / d2) * pl[now].co;
          return 9999;
      }
      if (can == 99999) {
          cout << "No Solution";
          return -1;
      } else {
          mo += c * pl[now].co;
          temlen += (maxx - (pl[can].dis - pl[now].dis));
          return can;
      }
  }
  ```

#### 2. 题解作者：dingcx (赞：409)
- **星级**：★★★★
- **关键亮点**：通过单调队列优化，确保每次加油时使用的油是最便宜的，减少不必要的开销。思路新颖，代码实现较为复杂但效率高。
- **核心实现思想**：在每个加油站，将油箱中价格高于当前加油站的油退掉，换成当前加油站的油，确保每次加油时使用的油是最便宜的。
- **核心代码**：
  ```cpp
  for (int i = 1; i < (n + 2); i++) {
      double lll = (d[i] - d[i - 1]) / dis;
      double lll1 = lll;
      while (len) {
          if (l[0].sum < lll) {
              len--; lll -= l[0].sum;
              for (int k = 0; k < len; k++) {
                  l[k].price = l[k + 1].price;
                  l[k].sum = l[k + 1].sum;
              }
          } else {
              l[0].sum -= lll;
              flag = 0;
              break;
          }
      }
      if (flag) {
          printf("No Solution");
          return 0;
      }
      flag = 1;
      for (int j = 0; j < len; j++) {
          if (p[i] < l[j].price) {
              ans -= (l[j].sum * l[j].price);
              for (int k = j + 1; k < len; k++) {
                  l[j].sum += l[k].sum;
                  ans -= (l[k].sum * l[k].price);
              }
              l[j].sum += lll1;
              l[j].price = p[i];
              ans += l[j].price * l[j].sum;
              len = j + 1;
              flag = 0;
              break;
          }
      }
      if (flag) {
          l[len].sum = lll1;
          ans += p[i] * lll1;
          l[len].price = p[i];
          len++;
      }
  }
  ```

#### 3. 题解作者：hongzy (赞：215)
- **星级**：★★★★
- **关键亮点**：通过单调队列优化，确保每次加油时使用的油是最便宜的，减少不必要的开销。思路新颖，代码实现较为复杂但效率高。
- **核心实现思想**：在每个加油站，将油箱中价格高于当前加油站的油退掉，换成当前加油站的油，确保每次加油时使用的油是最便宜的。
- **核心代码**：
  ```cpp
  while (!p.empty() && p.back().cost > P[i]) {
      ans -= p.back().cost * p.back().x;
      nc -= p.back().x;
      p.pop_back();
  }
  ans += (c - nc) * P[i];
  p.push_back(OIL(P[i], c - nc));
  nc = c;
  ```

### 最优关键思路与技巧

1. **贪心策略**：优先选择能到达的下一个油价更低的加油站，尽量少加油；如果没有更便宜的加油站，则加满油，前往能到达的最便宜的加油站。
2. **单调队列优化**：通过维护一个单调队列，确保每次加油时使用的油是最便宜的，减少不必要的开销。
3. **DFS+剪枝**：通过深度优先搜索遍历所有可能的加油方案，结合剪枝优化，减少不必要的计算。

### 可拓展之处

- **同类型题**：类似的问题包括最短路径问题、背包问题等，都可以通过贪心算法或动态规划来解决。
- **算法套路**：贪心算法在解决最优化问题时非常有效，尤其是在问题具有“最优子结构”性质时。

### 推荐题目

1. **P1048 采药**：通过动态规划解决背包问题，与本题的贪心策略有相似之处。
2. **P1060 开心的金明**：通过动态规划解决背包问题，与本题的贪心策略有相似之处。
3. **P1091 合唱队形**：通过动态规划解决最长上升子序列问题，与本题的贪心策略有相似之处。

### 个人心得总结

- **调试经历**：在实现贪心算法时，容易忽略边界条件，如油箱容量不足或无法到达下一个加油站的情况，需仔细检查。
- **踩坑教训**：在单调队列的实现中，容易忽略队列的维护顺序，导致算法效率下降或出错。
- **顿悟感想**：贪心算法的核心在于每一步都做出局部最优的选择，最终得到全局最优解。

---
处理用时：59.93秒
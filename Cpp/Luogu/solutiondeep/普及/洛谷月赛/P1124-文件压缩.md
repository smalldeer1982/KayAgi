# 题目信息

# 文件压缩

## 题目背景

提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。


## 题目描述

该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。

举例：$S$ 是 `example`

1. 构造 $n$ 个字符串。

```plain
example
xamplee
ampleex
mpleexa
pleexam
leexamp
eexampl
```

2. 将字符串排序。

```plain
ampleex
example
eexampl
leexamp
mpleexa
pleexam
xamplee
```
3. 压缩结果。

$S' = \texttt{xelpame}$，$p = 7$

由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。

请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。

保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。

## 样例 #1

### 输入

```
7
xelpame
7
```

### 输出

```
example
```

# AI分析结果

### 综合分析与结论

该题目要求从给定的压缩字符串 $S'$ 和位置 $p$ 还原出原始字符串 $S$。核心思路是通过排序后的字符串和原始字符串的首尾字符对应关系，逐步还原出原始字符串。难点在于如何正确处理字符的对应关系，尤其是当字符重复时，如何避免错位。

大多数题解都采用了倒推的方法，即从给定的位置 $p$ 出发，逐步找到前一个字符，最终还原出整个字符串。这种方法避免了正推时可能出现的字符错位问题，尤其是在字符重复的情况下。

### 所选高星题解

#### 1. **作者：MC_Launcher (5星)**
- **关键亮点**：思路清晰，代码简洁，注释详细，且通过图示帮助理解倒推的过程。题解中明确指出了正推的潜在问题，并提供了倒推的解决方案。
- **个人心得**：作者提到第一次正推时只得了10分，通过调试和输出中间变量，最终理解了倒推的必要性。
- **核心代码**：
  ```cpp
  for(int i=1;i<n;i++) {
      for(int j=n-1;j>=0;j--) {
          if(b[j]==a[now]) {
              now=j;
              ans[i]=a[now];
              b[j]=')';
              break;
          }
      }	
  }
  ```
  **实现思想**：从后往前搜索，找到与当前字符匹配的字符，并逐步还原出原始字符串。

#### 2. **作者：liuzhaoxu (4星)**
- **关键亮点**：详细解释了为什么不能正推，并通过示例数据说明了正推的问题。代码结构清晰，注释详细。
- **核心代码**：
  ```cpp
  while(cnt>1) {
      ans[--cnt]=s[p];
      ss[p]='#';
      for(int i=n;i>=1;--i) if(ss[i]==s[p]) {p=i;break;}
  }
  ```
  **实现思想**：通过倒推的方式，从给定的位置 $p$ 出发，逐步找到前一个字符，最终还原出整个字符串。

#### 3. **作者：Elgo87 (4星)**
- **关键亮点**：通过图示详细解释了倒推的过程，代码结构清晰，注释详细。
- **核心代码**：
  ```cpp
  for(int i=1; i<len; i++) {
      for(int j=len-1; j>=0; j--) {
          if(b[j] == a[x]) {
              x = j;
              c[i] = a[x];
              b[j] = '!';
              break;
          }
      }
  }
  ```
  **实现思想**：通过倒推的方式，从给定的位置 $p$ 出发，逐步找到前一个字符，最终还原出整个字符串。

### 最优关键思路与技巧

1. **倒推法**：从给定的位置 $p$ 出发，逐步找到前一个字符，最终还原出整个字符串。这种方法避免了正推时可能出现的字符错位问题。
2. **标记已使用字符**：在倒推过程中，通过标记已使用的字符，避免重复使用同一个字符。
3. **排序与对应关系**：通过排序后的字符串和原始字符串的首尾字符对应关系，逐步还原出原始字符串。

### 可拓展之处

1. **类似算法套路**：这种倒推法可以应用于其他需要从部分信息还原完整信息的场景，如解码、解压缩等。
2. **字符重复处理**：在处理字符重复的情况下，倒推法可以有效避免错位问题，适用于类似的字符串处理问题。

### 推荐题目

1. **P1124 文件压缩**：本题的扩展练习，考察字符串的压缩与解压缩。
2. **P1090 合并果子**：考察贪心算法和优先队列的使用，与字符串处理有相似之处。
3. **P1042 乒乓球**：考察字符串的处理和模拟，与本题的模拟思路相似。

### 个人心得总结

- **调试与输出中间变量**：通过调试和输出中间变量，可以帮助理解算法的执行过程，尤其是在遇到问题时，能够快速定位问题所在。
- **倒推法的优势**：在处理字符重复的情况下，倒推法可以有效避免错位问题，是一种值得掌握的技巧。

---
处理用时：38.44秒
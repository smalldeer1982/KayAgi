# 题目信息

# 词链

## 题目描述

如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。

另外还有一些例子：
- `dog.gopher`
- `gopher.rat`
- `rat.tiger`
- `aloha.aloha`
- `arachnid.dog`

连接成的词可以与其他单词相连，组成更长的词链，例如：

`aloha.arachnid.dog.gopher.rat.tiger`

注意到，`.` 两边的字母一定是相同的。

现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。

## 说明/提示

- 对于 $40\%$ 的数据，有 $n \leq 10$；
- 对于 $100\%$ 的数据，有 $n \leq 1000$。


## 样例 #1

### 输入

```
6
aloha
arachnid
dog
gopher
rat
tiger```

### 输出

```
aloha.arachnid.dog.gopher.rat.tiger```

# AI分析结果

### 综合分析与结论

该题目要求找到字典序最小的词链，且每个单词在词链中出现且仅出现一次。多数题解的核心思路是将单词的首字母和尾字母作为图的节点，单词作为有向边，转化为寻找欧拉路径或欧拉回路的问题。欧拉路径的判定条件是有且仅有一个节点的出度比入度大1（起点），有且仅有一个节点的入度比出度大1（终点），其余节点入度等于出度。欧拉回路则是所有节点的入度等于出度。

多数题解通过并查集判断图的连通性，再通过DFS寻找欧拉路径。部分题解还优化了DFS的起点选择，确保字典序最小。整体思路较为一致，但实现细节和代码质量有所不同。

### 所选高星题解

#### 1. 作者：loc_equinox (赞：86)  
**星级：5星**  
**关键亮点：**  
- 详细解释了欧拉路径的判定条件，并巧妙地将单词转化为有向边，字母作为节点。
- 通过并查集判断图的连通性，确保欧拉路径的存在。
- 代码结构清晰，注释详细，易于理解。
- 优化了DFS的起点选择，确保字典序最小。

**个人心得：**  
作者提到在调试过程中发现数据“太水”，导致许多题解被Hack，因此特别强调了欧拉路径的判定条件，确保代码的鲁棒性。

**核心代码：**
```cpp
void dfs(int st, int now, int pre_edge) {
    if (st == n) {
        for (int i = 1; i <= n; i++) {
            cout << res[i];
            if (i < n) cout << ".";
        }
        exit(0);
    }
    for (int k = 0; k < E[now].size(); k++) {
        if (!vis[E[now][k].ord]) {
            vis[E[now][k].ord] = 1;
            res[st + 1] = E[now][k].word;
            dfs(st + 1, E[now][k].to, E[now][k].ord);
        }
    }
    vis[pre_edge] = 0; // 回溯
}
```

#### 2. 作者：zzr8178541919 (赞：83)  
**星级：4星**  
**关键亮点：**  
- 通过分析词链的性质，推导出起点选择的规则，确保字典序最小。
- 详细解释了搜索过程中的注意事项，如回溯标记、字典序优先等。
- 代码实现较为简洁，逻辑清晰。

**核心代码：**
```cpp
void dfs(int last, int step) {
    if (flag == 1) return;
    if (step == n) {
        flag = 1;
        for (int i = 1; i <= sum; i++) {
            ans[i] = now[i];
        }
        return;
    }
    for (int i = 1; i <= n; i++) {
        if (book[i] == 1) continue;
        if (a[last][a[last].length() - 1] == a[i][0]) {
            now[++sum] = a[i];
            book[i] = 1;
            dfs(i, step + 1);
            sum--;
            book[i] = 0;
        }
    }
}
```

#### 3. 作者：CGDGAD (赞：61)  
**星级：4星**  
**关键亮点：**  
- 通过排序优化了DFS的起点选择，确保字典序最小。
- 详细解释了欧拉路径的判定条件，并提供了无解情况的判断。
- 代码实现简洁，逻辑清晰。

**核心代码：**
```cpp
void dfs(int s, std::string curr, int count) {
    if (count == n) {
        curr[curr.length() - 1] = ' ';
        std::cout << curr;
        exit(0);
    }
    for (auto i : e[s])
        if (!used[i]) {
            used[i] = true;
            dfs(i, curr + a[i] + '.', count + 1);
            used[i] = false;
        }
}
```

### 最优关键思路与技巧

1. **欧拉路径判定**：通过统计每个节点的入度和出度，判断是否存在欧拉路径或欧拉回路。
2. **并查集判断连通性**：确保所有节点在同一个连通块中，避免无解情况。
3. **DFS优化**：通过排序和优先选择字典序小的起点，确保最终词链的字典序最小。
4. **回溯与标记**：在DFS过程中使用标记数组避免重复访问，并通过回溯确保所有可能的路径都被探索。

### 可拓展之处

该题的核心思想可以拓展到其他图论问题，如寻找哈密尔顿路径、拓扑排序等。类似的问题可以通过将问题转化为图论问题，利用DFS或BFS进行求解。

### 推荐题目

1. **P1127 词链**（本题）
2. **P1341 无序字母对**（考察欧拉路径）
3. **P2731 骑马修栅栏**（考察欧拉路径的应用）

### 个人心得总结

多位作者在调试过程中发现数据“太水”，导致许多题解被Hack，因此特别强调了欧拉路径的判定条件，确保代码的鲁棒性。此外，部分作者提到在DFS过程中需要特别注意回溯和标记，避免重复访问或遗漏路径。

---
处理用时：41.83秒
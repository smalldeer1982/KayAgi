# 题目信息

# [ZJOI2007] 时态同步

## 题目描述

小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。

在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。

激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？

## 说明/提示

- 对于 $40\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 5\times 10^5$。

对于所有的数据，$1\le t_e\le 10^6$。

## 样例 #1

### 输入

```
3
1
1 2 1
1 3 3
```

### 输出

```
2
```

# AI分析结果

### 综合分析与结论

本题的核心是通过调整树中某些边的权值，使得所有叶子节点到根节点的距离相同。大多数题解采用了**树形DP**或**贪心**的思路，核心思想是从叶子节点向上回溯，逐步调整每个节点的子树，使得子树内的叶子节点到该节点的距离相同。具体实现上，通常通过两次DFS：第一次计算每个节点到叶子节点的最大距离，第二次根据最大距离计算需要调整的边权。

### 评分较高的题解

#### 1. 作者：Mathison (赞：187)  
**星级：5星**  
**关键亮点：**  
- 思路清晰，通过两次DFS分别计算最大距离和调整边权。
- 代码简洁，逻辑明确，易于理解。
- 通过`dis[x] = max(dis[x], dis[y] + z)`计算最大距离，再通过`ans += dis[x] - (dis[y] + z)`累加调整次数。

**核心代码：**
```cpp
void dfs(int x, int fa) {
    for(int i = head[x]; i; i = next[i]) {
        int y = ver[i], z = edge[i];
        if(y == fa) continue;
        dfs(y, x);
        dis[x] = max(dis[x], dis[y] + z);
    }
    for(int i = head[x]; i; i = next[i]) {
        int y = ver[i], z = edge[i];
        if(y == fa) continue;
        ans += dis[x] - (dis[y] + z);
    }
}
```
**个人心得：**  
作者通过两次DFS，第一次计算最大距离，第二次累加调整次数，思路清晰且代码简洁，适合初学者理解。

#### 2. 作者：crazydave (赞：127)  
**星级：4.5星**  
**关键亮点：**  
- 从根节点向下搜索，回溯时维护每个节点的最大边权。
- 通过`maxn[x] = max(maxn[x], edge[i].dis)`维护最大边权，再通过`ans += (maxn[x] - edge[i].dis)`累加调整次数。

**核心代码：**
```cpp
void dfs(int x, int fa) {
    for(int i = head[x]; i; i = edge[i].next) {
        int v = edge[i].to;
        if(v == fa) continue;
        dfs(v, x);
        maxn[x] = max(maxn[x], edge[i].dis);
    }
    for(int i = head[x]; i; i = edge[i].next) {
        int v = edge[i].to;
        if(v == fa) continue;
        ans += (maxn[x] - edge[i].dis);
    }
}
```
**个人心得：**  
作者通过维护最大边权，逐步调整每个节点的子树，思路清晰，代码实现较为简洁。

#### 3. 作者：xyz32768 (赞：57)  
**星级：4星**  
**关键亮点：**  
- 使用树形DP，状态转移方程为`num[i] = max{num[j] + time[i,j]}`和`dp[i] = sigma{dp[j]} + sigma{num[i] - (num[j] + time[i,j])}`。
- 通过两次DFS分别计算最大距离和调整边权。

**核心代码：**
```cpp
void dfs(int u, int fa) {
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa) continue;
        dfs(v, u);
        num[u] = max(num[u], num[v] + e[i].w);
    }
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa) continue;
        dp[u] += dp[v] + num[u] - (num[v] + e[i].w);
    }
}
```
**个人心得：**  
作者通过树形DP的思路，状态转移方程清晰，适合有一定DP基础的读者。

### 最优关键思路与技巧

1. **两次DFS**：第一次计算每个节点到叶子节点的最大距离，第二次根据最大距离计算需要调整的边权。
2. **贪心思想**：尽量在靠近根节点的边上进行调整，以减少调整次数。
3. **树形DP**：通过状态转移方程逐步计算每个节点的子树调整次数。

### 可拓展之处

- **类似问题**：如树的直径、树的重心等问题，都可以通过类似的DFS或DP思路解决。
- **优化技巧**：可以通过记忆化搜索或剪枝优化DFS的效率。

### 推荐题目

1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352) - 树形DP经典问题。
2. [P2014 选课](https://www.luogu.com.cn/problem/P2014) - 树形DP与背包问题的结合。
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040) - 树形DP与区间DP的结合。

### 个人心得总结

- **调试经历**：在实现DFS时，注意避免重复访问父节点，否则会导致无限递归。
- **踩坑教训**：在计算最大距离时，确保每个节点的初始值正确，避免漏算。
- **顿悟感想**：树形DP的核心在于状态转移方程的设计，合理的状态定义可以大大简化问题。

---
处理用时：44.36秒
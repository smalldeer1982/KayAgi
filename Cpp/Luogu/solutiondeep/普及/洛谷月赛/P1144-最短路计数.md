# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论

本题的核心是求解无向无权图中从起点到其他各点的最短路数量。题解中主要采用了以下几种算法：BFS、Dijkstra、SPFA，并结合了最短路计数的思想。大多数题解都遵循了以下关键思路：

1. **最短路计数**：在遍历图的过程中，记录从起点到每个点的最短路数量。当发现更短的路径时，更新路径数量；当路径长度相等时，累加路径数量。
2. **算法选择**：由于是无权图，BFS是最自然的选择，时间复杂度为O(N+M)。Dijkstra和SPFA虽然也能解决，但在无权图中效率不如BFS。
3. **优化与实现**：部分题解通过优化队列、减少重复计算等方式提高了效率，尤其是在处理大规模数据时。

### 精选题解

#### 1. **作者：岸芷汀兰**（★★★★☆）
- **关键亮点**：使用BFS进行最短路计数，思路清晰，代码简洁。通过分层遍历，确保每个点的最短路数量正确累加。
- **个人心得**：作者强调了BFS在无权图中的优势，并指出自环和重边的处理方式。
- **核心代码**：
```cpp
void bfs() {
    queue<int> q;
    q.push(1);
    dis[1] = 0;
    ans[1] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : linker[u]) {
            if (dis[v] == INF) {
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                q.push(v);
            } else if (dis[v] == dis[u] + 1) {
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
}
```

#### 2. **作者：XZYQvQ**（★★★★☆）
- **关键亮点**：通过两遍SPFA，先求最短路，再通过记忆化搜索计数，避免了重复计算，思路新颖。
- **个人心得**：作者提到SPFA在某些情况下可能存在问题，并通过记忆化搜索解决了这一问题。
- **核心代码**：
```cpp
int dfs(int u) {
    if (ans[u]) return ans[u];
    for (int i = head[u]; i != -1; i = nxt[i]) {
        if (dis[u] - 1 == dis[to[i]]) {
            ans[u] = (ans[u] + dfs(to[i])) % MOD;
        }
    }
    return ans[u];
}
```

#### 3. **作者：King丨帝御威**（★★★★☆）
- **关键亮点**：使用Dijkstra堆优化，结合最短路计数，代码结构清晰，适合理解Dijkstra的应用。
- **个人心得**：作者强调了Dijkstra的稳定性，并提供了详细的代码注释。
- **核心代码**：
```cpp
void dijkstra() {
    priority_queue<pair<int, int>> q;
    q.push({0, 1});
    dis[1] = 0;
    ans[1] = 1;
    while (!q.empty()) {
        int u = q.top().second; q.pop();
        for (int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            if (dis[v] > dis[u] + 1) {
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                q.push({-dis[v], v});
            } else if (dis[v] == dis[u] + 1) {
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
}
```

### 最优关键思路与技巧

1. **BFS分层遍历**：在无权图中，BFS天然分层，每层的节点距离起点相同，适合最短路计数。
2. **记忆化搜索**：通过记忆化搜索避免重复计算，提高效率，尤其适用于大规模数据。
3. **Dijkstra堆优化**：在有权图中，Dijkstra堆优化是经典的最短路算法，结合计数思想可以解决类似问题。

### 拓展与举一反三

1. **类似题目**：
   - [P1608 路径统计](https://www.luogu.org/problem/P1608)：有权图的最短路计数。
   - [P1144 最短路计数](https://www.luogu.org/problem/P1144)：无权图的最短路计数。
   - [P4779 【模板】单源最短路径（标准版）](https://www.luogu.org/problem/P4779)：Dijkstra的模板题。

2. **调试与顿悟**：部分作者提到在调试过程中发现SPFA的重复计数问题，通过记忆化搜索解决。这提醒我们在解决类似问题时，要注意算法的适用性和潜在问题。

### 推荐题目

1. **P1608 路径统计**：考察有权图的最短路计数。
2. **P1144 最短路计数**：本题的无权图版本。
3. **P4779 【模板】单源最短路径（标准版）**：Dijkstra的模板题，适合练习最短路算法。

---
处理用时：43.50秒
# 题目信息

# 不成熟的梦想家 (未熟 DREAMER)

## 题目背景

**どんな未来かは 誰もまだ知らない**

**那是个任谁也不会知晓的未来**

**でも楽しくなるはずだよ**

**但应该会充满乐趣吧**

**みんなとなら乗りこえられる**

**只要大伙儿同在 就能跨越难关**

**これからなんだねお互いがんばろうよ**

**现在才正要开始 彼此互相加油吧**

**どんな未来かは 誰もまだ知らない**

**那是个任谁也不会知晓的未来**

**でも楽しくしたホントに**

**不过真心期望能够充满着乐趣**

**みんなとなら無理したくなる**

**只要大伙儿同在 就会想将顾虑抛诸脑后**

**成長したいなまだまだ未熟DREAMER**

**愿能有所成长 如今还只是尚未成熟的梦想家**

 ![](https://cdn.luogu.com.cn/upload/pic/4493.png) 

Aqours的成员终于到齐了。


今天，是我们全员在一起的第一场演唱会。


大家都好好练习过了，相信一定会表现得很出色的。


不过，每个人的唱功也要尽量地接近才可以呢，如果太突出或者太落后，也是会影响表现的样子。


所以我们从隔壁的学园都市借来了一个发明，可以改变我们成员的唱功呢。


## 题目描述

我们Aqours的成员共有N+1人，他们会列成一队。

他们的唱功以A[0]到A[N]表示，A[i]$(0\le i \le N)$均给出。

学园都市的机器可以改变队列中连续多个成员的唱功值，并将其加上一个数Z，当然当Z是负数的时候就变成减去了。

我打算一共使用这个机器Q次，每次把第X到第Y号（$1\le X,Y\le10^6$）的成员都加上Z点唱功值。

而我们队伍的魅力值B，是这么算的：

一开始B=0，然后从第1号到第N号成员，

- 当$A_{i-1}<A_i$：$B = B-S\cdot|A_{i-1} - A_i|$
- 当$A_{i-1}>A_i$：$B = B+T\cdot|A_{i-1} - A_i|$
其中S和T是LoveLive组委会给我们的常数。

果然，我是バカチカ（笨蛋千歌）呢，所以作为领导我永远排在队伍的开头，唱功永远是0，机器也不会改到我头上呢。

你能帮我们算算，我**每次**使用完这个机器之后，成员的魅力B是多少吗？


## 说明/提示

30% 的数据 $N,Q\le 2000$,

另外20% 的数据 $S=T$

100%的数据 $N,Q\le 200000$；$1\le S,T,A_i\le10^6$；$|Z|\le 10^6$
请注意可能需要使用int64，cin/cout可能超时。

样例解释：

第一次变化后，

A 0 6 3 4 6

B -12 -3 -5 -9


#### 以下是彩蛋

没有。

哪来的那么多彩蛋？


## 样例 #1

### 输入

```
4 3 2 3
0
5
2
4
6
1 2 1
3 4 -3
1 4 2
```

### 输出

```
-9
-1
-5
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效处理区间修改并快速计算魅力值的变化。大多数题解都采用了差分的思想，通过维护相邻元素的差值来简化区间修改操作，并利用这些差值快速更新魅力值。差分法的优势在于它能够将区间修改操作转化为单点修改，从而将时间复杂度从O(N)降低到O(1)。此外，部分题解还提到了树状数组的应用，虽然也能解决问题，但在本题中差分法更为简洁高效。

### 所选高星题解

#### 1. 作者：顾z (赞：18) - 4星
**关键亮点**：
- 清晰地解释了差分法的应用，并通过代码展示了如何利用差分数组快速更新魅力值。
- 代码简洁且可读性强，使用了快读优化输入，避免了cin/cout的潜在性能问题。
- 特别强调了当修改区间右端点为n时的特殊情况处理，避免了不必要的计算。

**个人心得**：
- 强调了差分法的适用场景，特别是在区间修改和单点查询问题中的优势。

**核心代码**：
```cpp
inline int calc(int x) {
    return x>0 ? -S*x:-T*x;
}

signed main() {
    in(N),in(Q),in(S),in(T);
    for(R int i=0,x;i<=N;i++) {
        in(x);
        A[i]=x-last;
        ans+=calc(A[i]);
        last=x;
    }
    for(R int i=1,x,y,z;i<=Q;i++) {
        in(x),in(y),in(z);
        ans-=calc(A[x]);A[x]+=z;ans+=calc(A[x]);
        if(y!=N)ans-=calc(A[y+1]),A[y+1]-=z,ans+=calc(A[y+1]);
        printf("%lld\n",ans);
    }
}
```

#### 2. 作者：ILLENIUM_DOOR (赞：14) - 4星
**关键亮点**：
- 详细解释了差分法的原理，并通过代码展示了如何利用差分数组快速更新魅力值。
- 代码结构清晰，注释详细，便于理解。
- 特别强调了开long long的重要性，避免了潜在的溢出问题。

**核心代码**：
```cpp
long long js(long long n){
    return n>0?-s*n:-t*n;
}

int main(){
    long long last=0;
    long long ans=0;
    cin>>n>>q>>s>>t;
    for(int i=0;i<=n;i++){
        long long now; 
        cin>>now;
        d[i]=now-last;
        last=now;
        ans+=js(d[i]);
    }
    while(q--){
        long long x,y,z;
        cin>>x>>y>>z;
        ans-=js(d[x]);d[x]+=z;ans+=js(d[x]);
        if(y!=n) {
            ans-=js(d[y+1]);d[y+1]-=z;ans+=js(d[y+1]);
        }
        cout<<ans<<endl;
    }
    return 0;     
}
```

#### 3. 作者：RedreamMer (赞：3) - 4星
**关键亮点**：
- 通过预处理差分数组，快速计算初始魅力值，并在每次修改时仅更新两个点的差值，从而高效计算魅力值的变化。
- 代码简洁且逻辑清晰，特别强调了当修改区间右端点为n时的特殊情况处理。

**核心代码**：
```cpp
inline int f(int n) {
    return n>0?-X*n:-Y*n;
}

signed main() {
    scanf("%lld%lld%lld%lld",&a,&b,&X,&Y);
    for(int i=0;i<=a;i++) {
        scanf("%lld",&x);
        s[i]=x-last;
        sum+=f(s[i]);
        last=x;
    }
    for(int i=1;i<=b;i++) {
        scanf("%lld%lld%lld",&x,&y,&z);
        sum-=f(s[x]);s[x]+=z;sum+=f(s[x]);
        if(y!=a) {
            sum-=f(s[y+1]);s[y+1]-=z;sum+=f(s[y+1]);
        }
        printf("%lld\n",sum);
    }
    return 0;
}
```

### 最优关键思路与技巧
- **差分法**：通过维护相邻元素的差值，将区间修改转化为单点修改，从而高效处理区间操作。
- **特殊情况处理**：当修改区间右端点为n时，无需更新右端点的下一个差值，避免不必要的计算。
- **快读优化**：使用快读函数优化输入，避免cin/cout的潜在性能问题。

### 可拓展之处
- **类似算法套路**：差分法在区间修改和单点查询问题中广泛应用，如区间加、区间减等操作。
- **同类型题目**：可以考虑使用差分法解决类似问题，如区间求和、区间最大值等。

### 推荐题目
1. [P3368 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3368)
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P3374 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3374)

### 个人心得总结
- **调试经历**：部分题解提到了开long long的重要性，提醒我们在处理大范围数据时要注意数据类型的选取，避免溢出问题。
- **踩坑教训**：在处理区间修改时，特别要注意边界条件的处理，如修改区间右端点为n时，无需更新下一个差值。
- **顿悟感想**：差分法在处理区间修改问题时非常高效，理解其原理后可以大大简化代码实现。

---
处理用时：43.01秒
# 题目信息

# 三去矩阵

## 题目背景

无

## 题目描述

现在小Y有个$l \times l$的正方形字母矩阵，现在他想进行$q$次询问，每次询问最长的以$(x_i,y_i)$为中心的在一条水平或竖直的直线上的回文串的长度。

## 说明/提示

对于$20\%$的数据，$1 \le l \le 2$

另有$20\%$的数据，$q = 1$

另有$20\%$的数据，字母矩阵中心对称，上下对称，左右对称且对角线对称。

对于$100\%$的数据，$1 \le l,q \le 2000$，字母只有小写字母。

## 样例 #1

### 输入

```
5 5
abcba
bcdcb
cdedc
bcdcb
abcba
1 1
1 2
1 3
2 3
3 3```

### 输出

```
1
1
5
5
5
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地找到以给定点为中心的最长回文串。大多数题解采用了暴力模拟的方法，通过分别从水平和垂直两个方向向外扩展，判断字符是否相等，直到不满足回文条件或超出矩阵边界为止。这种方法的时间复杂度为 \(O(q \times l)\)，在给定的数据范围内是可行的。

部分题解在实现细节上有所优化，如使用 `getchar()` 或 `scanf()` 来提高输入效率，或者通过预处理来减少重复计算。整体来看，题解的思路较为一致，代码实现也相对简单，但部分题解在代码可读性和优化程度上表现较好。

### 所选高星题解

#### 1. **题解作者：CT_Res**  
**星级：4.5**  
**关键亮点：**  
- 通过预处理所有可能的回文串长度，将每次查询的时间复杂度降低到 \(O(1)\)。
- 代码结构清晰，逻辑简洁，易于理解。
- 使用了 `getchar()` 来提高输入效率。

**核心代码：**
```cpp
for(int i=1;i<=l;i++)
    for(int j=1;j<=l;j++)
    {
        int a1=1,a2=1;
        for(int k=1;k<=l;k++)
            if(ch[i][j+k]==ch[i][j-k] && j+k<=l && j-k>=1) a1+=2;
            else break;
        for(int k=1;k<=l;k++)
            if(ch[i+k][j]==ch[i-k][j] && i+k<=l && i-k>=1) a2+=2;
            else break;
        f[i][j]=max(a1,a2);
    }
```
**个人心得：**  
作者提到第一次提交时使用了 `getchar()`，但后来发现有问题，经过调试后修正。这种调试经历对于初学者非常有参考价值。

#### 2. **题解作者：Clear_yu**  
**星级：4.0**  
**关键亮点：**  
- 采用了暴力模拟的方法，代码简洁明了。
- 通过 `while` 循环实现向外扩展，逻辑清晰。
- 使用了 `dfs` 函数来封装回文串的计算，提高了代码的可读性。

**核心代码：**
```cpp
int dfs(int a,int b)
{
    int sum1=1,sum2=1;
    int x1=a-1,x2=a+1,y1=b-1,y2=b+1;
    while(x1>=1&&x2<=l)
    {
        if(map[x1][b]==map[x2][b]) {sum1+=2;x1--;x2++;}
        else break;
    }
    while(y1>=1&&y2<=l)
    {
        if(map[a][y1]==map[a][y2]) {sum2+=2;y1--;y2++;}
        else break;
    }
    return max(sum1,sum2);
}
```
**个人心得：**  
作者提到开始想写 `dfs`，但写着写着就变成了暴力模拟，这种思路转变的过程对于理解问题本质非常有帮助。

#### 3. **题解作者：Jasonggg15**  
**星级：4.0**  
**关键亮点：**  
- 代码简洁，逻辑清晰，直接模拟了回文串的查找过程。
- 使用了 `max` 函数来比较水平和垂直方向的结果，代码简洁高效。
- 通过 `if(sum1==l) break;` 来防止越界，提高了代码的鲁棒性。

**核心代码：**
```cpp
for(int k=1;k<=l;k++)
{
    if(sum1==l) break;
    if(map[x][y+k]==map[x][y-k]) sum1+=2;
    else break;
}
for(int k=1;k<=l;k++)
{
    if(sum2==l) break;
    if(map[x+k][y]==map[x-k][y]) sum2+=2;
    else break;
}
cout<<max(sum1,sum2)<<endl;
```
**个人心得：**  
作者强调了 `sum1` 和 `sum2` 的初值为 1，并解释了为什么需要 `if(sum1==l) break;`，这种细节处理对于避免错误非常有帮助。

### 最优关键思路与技巧

1. **预处理优化：** 通过预处理所有可能的回文串长度，将每次查询的时间复杂度降低到 \(O(1)\)，适用于查询次数较多的情况。
2. **暴力模拟：** 通过分别从水平和垂直两个方向向外扩展，判断字符是否相等，直到不满足回文条件或超出矩阵边界为止。这种方法简单直观，适用于数据范围较小的情况。
3. **输入优化：** 使用 `getchar()` 或 `scanf()` 来提高输入效率，尤其是在数据量较大时，这种优化可以有效减少运行时间。

### 可拓展之处

1. **回文串的扩展：** 可以扩展到二维矩阵中的其他形状的回文串，如对角线方向。
2. **动态规划：** 对于更复杂的回文串问题，可以考虑使用动态规划来优化时间复杂度。

### 推荐题目

1. **P1217 [USACO1.5]回文质数**（题号：1217）  
   考察回文串的判断与质数的结合，适合练习回文串的基本操作。
   
2. **P1435 回文字串**（题号：1435）  
   考察如何通过插入字符使字符串变为回文串，适合练习回文串的构造与优化。
   
3. **P1659 [国家集训队]拉拉队排练**（题号：1659）  
   考察回文串的长度统计与排序，适合练习回文串的统计与处理。

### 个人心得总结

- **调试经验：** 许多作者在调试过程中发现了一些细节问题，如输入方式的选择、边界条件的处理等。这些经验对于初学者非常有帮助，提醒我们在编写代码时要特别注意细节。
- **思路转变：** 一些作者在解题过程中经历了思路的转变，如从 `dfs` 到暴力模拟，这种思路的灵活性对于解决复杂问题非常重要。

---
处理用时：52.52秒
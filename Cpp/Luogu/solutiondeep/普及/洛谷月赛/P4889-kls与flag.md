# 题目信息

# kls与flag

## 题目背景

kls毒奶非常厉害。

## 题目描述

有$n$个OI选手，每个人插了一个flag。有一天因为某种原因，flag都被触发了，所以地上有一排$n$根竹竿，竹竿的间距均为一个单位长度，高度在$1\sim m$之间。

kls看到这些竹竿，感觉不好看，于是准备把它们全部放倒。

在这之前，kls想到了一个数学问题。每根竹竿可以往左倒或者往右倒。如果两根竹竿在选择方向放倒之后，它们的顶端可以重合，那么称它们是优秀的。现在kls想要知道，有多少对竹竿是优秀的。

## 说明/提示

### 样例解释

![法法](https://cdn.luogu.com.cn/upload/pic/25795.png)

- 1号和2号向左倒可以顶端重合
- 4号和5号向右倒可以顶端重合
- 1号向右，5号向左可以顶端重合

### 数据范围

对于30%的数据，满足$n\le 2000$，$m\le 5000$；

对于60%的数据，满足$n\le 200000$，$m\le 500000$；

对于100%的数据，满足$n \le 200000$，$m \le 10^9$。

## 样例 #1

### 输入

```
5 5
2 3 3 3 2```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心在于统计竹竿倒下后顶端重合的对数。题解中主要采用了以下几种思路：
1. **排序与统计**：将竹竿倒下后的位置存入数组，排序后统计相同位置的个数，利用组合数公式计算对数。
2. **哈希表（map）**：使用`map`记录每个位置被覆盖的次数，最后遍历`map`计算对数。
3. **平衡树**：使用平衡树（如Treap）来统计每个位置的覆盖次数。

大部分题解都采用了排序或`map`的思路，其中排序的思路较为简洁且效率较高，适合大规模数据处理。而`map`虽然实现简单，但在数据量较大时可能会因常数较大而影响性能。

### 所选高质量题解

#### 1. **作者：Viston (赞：47)**  
**星级：★★★★★**  
**关键亮点**：  
- 使用数组存储竹竿倒下后的位置，通过排序和线性扫描统计相同位置的个数，避免了`map`的常数开销。
- 代码简洁，时间复杂度为`O(NlogN)`，适合大规模数据。

**核心代码**：
```cpp
sort(d+1,d+e+1);         //排序
for(i=1;i<=2*a;i++){  
    if(d[i]!=d[i-1])       //如果不在这个点了
        k=0;
    else k++,l+=k;         //如果在，就加一下
}
```
**核心思想**：通过排序和线性扫描统计相同位置的个数，利用组合数公式计算对数。

#### 2. **作者：醉梦未苏 (赞：27)**  
**星级：★★★★☆**  
**关键亮点**：  
- 使用`map`记录每个位置被覆盖的次数，最后遍历`map`计算对数。
- 思路清晰，代码易读，适合初学者理解。

**核心代码**：
```cpp
for(map<long long,long long>::iterator i=mmp.begin();i!=mmp.end();i++) 
{
    ans+=val(i->second);//统计
}
```
**核心思想**：通过`map`记录每个位置的覆盖次数，最后遍历`map`计算对数。

#### 3. **作者：空の軌跡 (赞：4)**  
**星级：★★★★☆**  
**关键亮点**：  
- 使用`vector`存储竹竿倒下后的位置，排序后统计相同位置的个数，利用组合数公式计算对数。
- 代码简洁，思路清晰，适合大规模数据处理。

**核心代码**：
```cpp
sort(eve.begin(),eve.end());
b=eve.size();
for(int i=1;i<b;i++)
{
    if(eve[i]==eve[i-1]) sum++;
    else ans+=(sum*(sum-1)/2), sum=1;
}
ans+=(sum*(sum-1)/2);
```
**核心思想**：通过`vector`存储位置，排序后统计相同位置的个数，利用组合数公式计算对数。

### 最优关键思路与技巧

1. **排序与统计**：将竹竿倒下后的位置存入数组，排序后统计相同位置的个数，利用组合数公式计算对数。这种方法时间复杂度为`O(NlogN)`，适合大规模数据处理。
2. **哈希表（map）**：使用`map`记录每个位置被覆盖的次数，最后遍历`map`计算对数。虽然实现简单，但在数据量较大时可能会因常数较大而影响性能。

### 可拓展之处

1. **类似问题**：可以扩展到其他需要统计相同元素对数的问题，如统计数组中相同元素的对数。
2. **数据结构**：可以尝试使用其他数据结构（如平衡树）来优化统计过程。

### 推荐题目

1. **P1908 逆序对**：考察排序与统计的思想。
2. **P3374 【模板】树状数组 1**：考察数据结构在统计中的应用。
3. **P3368 【模板】树状数组 2**：进一步考察树状数组的应用。

### 个人心得摘录

- **作者：Viston**：通过排序和线性扫描统计相同位置的个数，避免了`map`的常数开销，适合大规模数据处理。
- **作者：醉梦未苏**：使用`map`记录每个位置的覆盖次数，最后遍历`map`计算对数，思路清晰，适合初学者理解。
- **作者：空の軌跡**：通过`vector`存储位置，排序后统计相同位置的个数，利用组合数公式计算对数，代码简洁，适合大规模数据处理。

---
处理用时：32.51秒
# 题目信息

# 终于结束的起点

## 题目背景

> 终于结束的起点  
> 终于写下句点  
> 终于我们告别  
> 终于我们又回到原点  
> ……

一个个 OIer 的竞赛生涯总是从一场 NOIp 开始，大多也在一场 NOIp 中结束，好似一次次轮回在不断上演。  
如果这次 NOIp 是你的起点，那么祝你的 OI 生涯如同夏花般绚烂。  
如果这次 NOIp 是你的终点，那么祝你的 OI 回忆宛若繁星般璀璨。  
也许这是你最后一次在洛谷上打比赛，也许不是。  
不过，无论如何，祝你在一周后的比赛里，好运。

当然，这道题也和轮回有关系。

## 题目描述

广为人知的斐波拉契数列 $\mathrm{fib}(n)$ 是这么计算的

$$
\mathrm{fib}(n)=\begin{cases}
0,& n=0 \\
1,& n=1 \\
\mathrm{fib}(n-1) + \mathrm{fib}(n-2),& n>1
\end{cases}
$$

也就是 $0, 1, 1, 2, 3, 5, 8, 13 \cdots$，每一项都是前两项之和。

小 F 发现，如果把斐波拉契数列的每一项对任意大于 $1$ 的正整数 $M$ 取模的时候，数列都会产生循环。

当然，小 F 很快就明白了，因为 ($\mathrm{fib}(n - 1) \bmod M$) 和 ($\mathrm{fib}(n - 2) \bmod M)$ 最多只有 $M ^ 2$ 种取值，所以在 $M  ^ 2$ 次计算后一定出现过循环。

甚至更一般地，我们可以证明，无论取什么模数 $M$，最终模 $M$ 下的斐波拉契数列都会是 $0, 1, \cdots, 0, 1, \cdots$。

现在，给你一个模数 $M$，请你求出最小的 $n > 0$，使得 $\mathrm{fib}(n) \bmod M = 0, \mathrm{fib}(n + 1) \bmod M = 1$。

## 说明/提示

#### 样例 1 解释

斐波拉契数列为 $0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \cdots$，在对 $2$ 取模后结果为 $0, 1, 1, 0, 1, 1, 0, 1, 1, 0, \cdots$。

我们可以发现，当 $n = 3$ 时，$f(n) \bmod 2= 0, f(n + 1) \bmod 2 = 1$，也就是我们要求的 $n$ 的最小值。

#### 数据范围

对于 $30\%$ 的数据，$M \leq 18$；

对于 $70\%$ 的数据，$M \leq 2018$；

对于 $100\%$ 的数据，$2 \leq M \leq 706150=\verb!0xAC666!$。

#### 提示

如果你还不知道什么是取模 $(\bmod)$，那我也很乐意告诉你，模运算是求整数除法得到的余数，也就是竖式除法最终「除不尽」的部分，也即
$$a \bmod M =k \iff a = bM + k\ (M > 0, 0 \leq k < M)$$
其中 $a, b, k$ 都是非负整数。

如果你使用 `C` / `C++`，你可以使用 `%` 来进行模运算。

如果你使用 `Pascal`，你可以使用 `mod` 来进行模运算。

## 样例 #1

### 输入

```
2```

### 输出

```
3```

## 样例 #2

### 输入

```
6```

### 输出

```
24```

# AI分析结果

### 综合分析与结论

本题的核心是求斐波那契数列在模 \( M \) 下的最小循环节长度，即找到最小的 \( n > 0 \) 使得 \( \mathrm{fib}(n) \bmod M = 0 \) 且 \( \mathrm{fib}(n + 1) \bmod M = 1 \)。题解中主要分为两类思路：暴力求解和基于数论的优化解法。

1. **暴力求解**：大多数题解采用了暴力求解的方法，直接模拟斐波那契数列的生成过程，直到满足条件为止。这种方法虽然简单，但由于题目中 \( M \) 的范围较大（\( M \leq 706150 \)），暴力解法在时间复杂度上存在一定的风险。不过，由于斐波那契数列在模 \( M \) 下的循环节长度通常较小，暴力解法在实际应用中仍然可行。

2. **数论优化**：部分题解引入了数论中的皮萨诺周期（Pisano Period）和质因数分解等概念，通过数学推导和优化算法来减少计算量。这类方法虽然复杂度较低，但实现起来较为复杂，且需要对数论有一定的理解。

总体来看，暴力解法虽然简单粗暴，但在本题的数据范围内是可行的，且代码实现较为容易。数论优化解法虽然更为高效，但实现难度较大，适合对数论有深入理解的选手。

### 所选题解

#### 1. 作者：万弘 (赞：29)
- **星级**：4星
- **关键亮点**：采用了暴力求解的思路，但通过记忆化优化避免了重复计算，提升了效率。代码结构清晰，易于理解。
- **个人心得**：作者提到“暴力出奇迹”，并指出虽然暴力解法看似简单，但在本题中通过记忆化优化后，能够有效减少计算量，最终通过测试。

```cpp
#include<cstdio>
typedef long long ll;
using namespace std;
const ll INF=0x7fffffff;
ll fp[10000002]; // 记忆数组
ll m;
ll f(ll i) {
    if(fp[i]) return fp[i]; // 调取记忆
    if(i==1||i==2) return fp[i]=1%m;
    else return fp[i]=(f(i-1)+f(i-2))%m; // 顺带%m
}
int main() {
    scanf("%lld",&m);
    ll i=1; // 枚举
    while(f(i)!=0||f(i+1)!=1) { // 题目要求
        i++;
    }
    printf("%lld",i);
    return 0;
}
```

#### 2. 作者：a13518354766 (赞：22)
- **星级**：4星
- **关键亮点**：通过质因数分解和数论优化，减少了暴力求解的计算量。虽然实现较为复杂，但思路清晰，适合对数论有一定了解的选手。
- **个人心得**：作者提到“发现暴力能过时，喷了3k的血”，并分享了自己通过打表找规律的经历，最终通过数论优化解决了问题。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10000000;
int M;
bool is_not_prime[N];
int f[N],zhi[N],e;
inline void sai(int maxe) {
    for(int i=2;i<=maxe;++i) {
        if(!is_not_prime[i]) {
            zhi[++e]=i;
            for(int j=i;j<=maxe/i;++j) {
                is_not_prime[i*j]=1;
            }
        }
    }
}
inline int gcd(int x,int y) {
    return x%y==0?y:gcd(y,x%y);
}
inline int lcm(int x,int y) {
    return x/gcd(x,y)*y;
}
inline int bl(int x) {
    f[1]=1;
    for(int i=2;i;++i) {
        f[i]=f[i-1]+f[i-2];
        f[i]%=x;
        if(f[i]==1&&f[i-1]==0) {
            return i-1;
        }
    }
}
inline int ksm(int x,int y) {
    int ans=1;
    while(y) {
        if(y&1) ans*=x;
        x*=x;
        y>>=1;
    }
    return ans;
}
inline int div(int x) {
    int ans=1;
    for(int i=1;i<=e;++i) {
        if(zhi[i]>x) break;
        if(x%zhi[i]==0) {
            int tim=0;
            while(x%zhi[i]==0) {
                tim++;
                x/=zhi[i];
            }
            int ti=bl(zhi[i]);
            ti*=ksm(zhi[i],tim-1);
            ans=lcm(ans,ti);
        }
    }
    return ans;
}
int main() {
    sai(706150); // 筛法筛质数
    int x;
    scanf("%d",&x);
    printf("%d\n",div(x));
    return 0;
}
```

#### 3. 作者：Cheng_yf (赞：11)
- **星级**：4星
- **关键亮点**：结合了数论中的矩阵快速幂和皮萨诺周期，通过数学推导和优化算法来减少计算量。虽然实现较为复杂，但思路清晰，适合对数论有深入理解的选手。
- **个人心得**：作者提到“数论大法好”，并分享了自己通过矩阵快速幂和数论优化解决问题的经历。

```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define pb push_back
#define sd second
#define ft first
typedef long long ll;
using namespace std;
int T,n;
const ll INF=1e18;
map<ll,ll>S;
inline ll power(ll a,ll b,ll mod) {
    int rs=1;a=a%mod;
    for(;b;b>>=1,a=1ll*a*a%mod) if(b&1) rs=1ll*rs*a%mod;
    return rs;
}
inline ll gcd(ll x,ll y) {return y?(gcd(y,x%y)):x;}
typedef pair<int,int> pii;
namespace SP1 {
    vector<pii>fac;
    ll nowlen,M;
    inline void mul(ll *a,ll *b,ll mod) {
        unsigned long long bd=a[0]*b[0],bc=a[0]*b[1],ad=a[1]*b[0],ac=a[1]*b[1];
        a[1]=(bc+ad+ac)%mod,a[0]=(bd+ac)%mod;
    }
    inline void power_p(ll *a,ll b,ll mod) {
        ll c[2]={1,0};
        for(;b;b>>=1,mul(a,a,mod))
            if(b&1) mul(c,a,mod);
        a[0]=c[0];a[1]=c[1];
    }
    inline bool check(ll sum) {
        ll b[2]={0,1};
        power_p(b,sum,M);
        return b[1]==0&&b[0]==1;
    }
    inline void dfs(int pos,ll sum) {
        if(pos==fac.size()) {
            (sum!=1&&check(sum))?(nowlen=min(nowlen,sum)):0;
            return;
        }
        ll rs=1;
        for(int i=0;i<=fac[pos].sd;++i) {
            dfs(pos+1,sum*rs);
            rs*=fac[pos].ft;
        }
    }
    inline ll getlen(ll x) {
        if(x==2) return 3;
        if(x==3) return 8;
        if(x==5) return 20;
        if(S.find(x)!=S.end()) return S[x];
        ll base=(power(5,(x-1)/2,x)==1)?(x-1):(2*x+2);
        fac.clear();nowlen=INF;M=x;
        for(int i=2;i*i<=base;++i) {
            if(!(base%i)) {
                pii t=mp(i,0);
                while(!(base%i)) base/=i,++t.sd;
                fac.pb(t);
            }
        }
        if(base!=1) fac.pb(mp(base,1));
        dfs(0,1);return S[x]=nowlen;
    }
}
vector<pii>fac;
ll ans;
inline void solve(int n) {
    if(n==1) {puts("1");return;}
    fac.clear();
    for(int i=2;i*i<=n;i++) {
        if(!(n%i)) {
            pii t=mp(i,0);
            while(!(n%i)) n/=i,++t.sd;
            fac.pb(t);
        }
    }
    if(n!=1) fac.pb(mp(n,1));
    ans=1;
    for(int i=0;i<fac.size();++i) {
        ll l=SP1::getlen(fac[i].ft);
        l=l*power(fac[i].first,fac[i].second-1,INF);
        ans=(ans*l)/gcd(ans,l);
    }
    printf("%llu",ans);
}
int main() {
    scanf("%d",&n);
    solve(n);
    return 0;
}
```

### 最优关键思路与技巧

1. **记忆化优化**：在暴力求解中，通过记忆化存储已经计算过的斐波那契数列值，避免重复计算，显著提升了效率。
2. **数论优化**：通过质因数分解和皮萨诺周期等数论知识，减少计算量，适用于对数学有深入理解的选手。
3. **矩阵快速幂**：利用矩阵快速幂计算斐波那契数列的模数循环节，适合处理更大范围的数据。

### 可拓展之处

1. **同类型题**：类似的问题可以扩展到其他线性递推数列的模数循环节计算，如卢卡斯数列、佩尔数列等。
2. **算法套路**：记忆化优化和数论优化是解决递推数列问题的常见套路，掌握这些技巧可以应用于更广泛的题目。

### 推荐题目

1. **P1306 斐波那契公约数**：考察斐波那契数列的性质和最大公约数的计算。
2. **P1962 斐波那契数列**：利用矩阵快速幂求解斐波那契数列的第 \( n \) 项。
3. **P3390 矩阵快速幂**：练习矩阵快速幂的实现，适用于处理线性递推问题。

### 个人心得总结

- **暴力出奇迹**：在本题中，暴力解法通过简单的优化（如记忆化）即可通过测试，体现了“暴力出奇迹”的思想。
- **数论优化**：通过数论知识优化算法，虽然实现复杂，但能显著减少计算量，适合对数学有深入理解的选手。
- **调试经历**：部分作者分享了自己在调试过程中遇到的困难和解决方法，如数组开小导致的错误，提醒我们在编程中要注意细节。

---
处理用时：77.28秒
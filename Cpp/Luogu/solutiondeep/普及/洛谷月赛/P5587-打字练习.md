# 题目信息

# 打字练习

## 题目描述

R 君在练习打字。

有这样一个打字练习网站，给定一个范文和输入框，会根据你的输入计算准确率和打字速度。可以输入的字符有小写字母、空格和 `.`（英文句号），输入字符后，光标也会跟着移动。

输入的文本有多行，R 君可以通过换行键来换行，换行后光标移动到下一行的开头。

R 君也可以按退格键（为了方便，退格键用 `<` 表示），以删除上一个打的字符，并将光标回移一格。特殊的，如果此时光标已经在一行的开头，则不能继续退格（即忽略此时输入的退格键）。

网站的比较方式遵循以下两个原则：

- 逐行比较，即对于范文和输入的每一行依次比较，不同行之间不会产生影响，多余的行会被忽略。
- 逐位比较，即对于两行的每一个字符依次比较，当且仅当字符相同时才会被算作一次正确，否则会被算作错误。计算答案时，只统计相同的字符个数。

需要注意的是，回车键不会被计入正确的字符个数。

R 君看到网站上显示他花了 $T$ 秒完成了这次的打字游戏，请你计算出他的 KPM（Keys per minutes，每分钟输入的字符个数），答案四舍五入保留整数部分。


## 说明/提示

#### 样例解释

第一行的正确字符数为 11。  
第二行的正确字符数为 6，错误的字符 `c` 仍会占据一个位置。  
第三行的正确字符数为 1，R 君使用退格键删除了被打错的字符 `y`

#### 数据范围

对于 $20\%$ 的数据，不存在换行键。  
对于 $40\%$ 的数据，不存在退格键。  
对于 $100\%$ 的数据，$T \leq 10^3$，保证每个文本段的总字符数（包括换行）不超过 $10^5$ 个且总行数不超过 $10^4$。


## 样例 #1

### 输入

```
hello world.
aaabbbb
x
EOF
heelo world.
aaacbbbb
y<x
EOF
60```

### 输出

```
18```

# AI分析结果

### 综合分析与结论

本题的核心是模拟打字练习中的退格操作，并逐行逐字符比较范文与输入文本的匹配情况。难点在于处理退格键的逻辑，尤其是范文中也存在退格键的情况。大多数题解通过栈或字符串处理的方式解决了这一问题，部分题解还考虑了优化和边界情况。

从题解的质量来看，大部分题解思路清晰，代码实现较为简洁，但部分题解在细节处理上存在不足，如未充分考虑范文中的退格键或未处理连续退格的情况。以下是评分较高的题解及其亮点。

---

### 精选题解

#### 1. **题解作者：引领天下 (赞：72)**  
**星级：★★★★★**  
**关键亮点：**  
- 使用 `string` 的 `pop_back()` 和 `push_back()` 函数简化了退格操作的处理。  
- 代码简洁，逻辑清晰，直接模拟了退格键的效果。  
- 通过逐行逐字符比较，避免了复杂的栈操作。  

**个人心得：**  
作者提到“范文也有退格键”是本题的坑点，提醒读者注意题目的细节。  

**核心代码：**
```cpp
for(char i:s1)if(i=='<'){if(!s[n].empty())s[n].pop_back();}
else s[n].push_back(i);
```
**实现思想：**  
通过遍历字符串，遇到退格键时删除最后一个字符，否则将字符加入字符串。

---

#### 2. **题解作者：地铁dixiatielu (赞：20)**  
**星级：★★★★**  
**关键亮点：**  
- 使用 `getchar()` 逐字符读取，避免了 `cin` 和 `scanf` 的空格问题。  
- 通过数组模拟栈，处理退格键的逻辑清晰。  
- 考虑了范文和输入文本中的退格键，处理了连续退格的情况。  

**核心代码：**
```cpp
if(ch == '<') {
    if(s1[cnt1] != 10) cnt1--;
}
else s1[++cnt1] = ch;
```
**实现思想：**  
通过数组模拟栈，遇到退格键时回退指针，否则将字符存入数组。

---

#### 3. **题解作者：HsKr (赞：14)**  
**星级：★★★★**  
**关键亮点：**  
- 使用 `vector` 和 `string` 结合，简化了退格操作的处理。  
- 通过 `push_back` 和 `pop_back` 实现了栈的功能，代码可读性高。  
- 处理了范文和输入文本中的退格键，并优化了比较逻辑。  

**核心代码：**
```cpp
if(word[i][j]!='<') Word[i].push_back(word[i][j]);
else if(j!=0&&Word[i].size()!=0) Word[i].pop_back();
```
**实现思想：**  
通过 `vector` 存储字符，遇到退格键时删除最后一个字符，否则将字符加入 `vector`。

---

### 最优关键思路与技巧

1. **栈的应用**：大多数题解通过栈（或模拟栈）处理退格键，利用栈的“后进先出”特性，简化了退格操作。
2. **字符串处理**：使用 `string` 的 `pop_back()` 和 `push_back()` 函数，直接模拟退格效果，代码简洁高效。
3. **逐行逐字符比较**：通过逐行逐字符比较范文与输入文本，避免了复杂的逻辑处理。
4. **边界处理**：部分题解特别强调了范文中的退格键和连续退格的处理，提醒读者注意细节。

---

### 可拓展之处

1. **类似问题**：类似的问题可以扩展到其他需要处理“撤销”操作的场景，如文本编辑器、命令行输入等。
2. **算法套路**：栈在处理“撤销”或“回退”操作时非常高效，类似的问题可以优先考虑栈的应用。

---

### 推荐题目

1. **P1449 后缀表达式**：考察栈的应用，与本题的退格操作有相似之处。
2. **P1739 表达式括号匹配**：通过栈处理括号匹配问题，与本题的栈应用类似。
3. **P1981 表达式求值**：利用栈处理表达式求值，进一步巩固栈的应用。

---

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中发现范文中的退格键是本题的坑点，提醒读者仔细审题。
- **踩坑教训**：连续退格的处理容易被忽略，需要特别注意边界情况。
- **顿悟感想**：栈在处理“撤销”操作时非常高效，类似问题可以优先考虑栈的应用。

---
处理用时：41.36秒
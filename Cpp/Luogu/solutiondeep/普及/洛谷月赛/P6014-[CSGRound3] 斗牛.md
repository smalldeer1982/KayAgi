# 题目信息

# [CSGRound3] 斗牛

## 题目背景

又是一年过去了。小 Z 在春节期间可以好好的放松放松，于是小 Z 和小伙伴们玩起了牛哄哄（斗牛）。

游戏规则是这样的：

给定 $5$ 张牌，分别从 $1 \sim 10$。你需要挑选其中的三张牌加起来是 $10$ 的倍数，另外两张牌的和的个位数则为你最后获得的点数，特别的，如果这两张牌的和是 $10$ 的倍数，则点数为 $10$，也叫做牛哄哄。如果不能构成 $10$ 的倍数，则点数为 $0$，也叫做牛不拢。

如 $5$ $3$ $2$ $3$ $4$ 的点数是 $7$，又叫做牛七。

小 Z 觉得玩的不过瘾，于是对上述规则进行了一些改变。

## 题目描述

给定 $n$ 张牌，牌的大小为 $1 \sim 10$。你需要挑选其中的 $n-2$ 张牌加起来是 $10$ 的倍数，另外两张牌和的个位数即为你所获得的点数。特别地，如果这两张牌的和是 $10$ 的倍数，则点数为 $10$，也叫做牛哄哄。如果任意 $n-2$ 张牌不能构成 $10$ 的倍数，则点数为 $0$，也叫做牛不拢。

由于小 Z 想要更开心的玩耍，所以需要你来完成这个程序来帮助小 Z 在 $1$ 秒内知道点数。

## 说明/提示

**【样例 1 解释】**

$10$ $10$ $10$ 三张牌凑成 $10$ 的倍数，$2+3=5$。

**【样例 2 解释】**

任意三张牌都不能凑成 $10$ 的倍数。

---

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（50 points）：$n = 5$。
- Subtask 2（30 points）：$n \le 5 \times 10^3$。
- Subtask 3（20 points）：无特殊限制。

对于 $100\%$ 的数据，$5 \le n \le 10^6$。



## 样例 #1

### 输入

```
5
10 10 10 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
5
3 4 5 6 7```

### 输出

```
0```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地判断是否存在两张牌，使得剩下的牌的和是10的倍数。大多数题解都采用了类似的思路：通过枚举两张牌，判断剩下的牌和是否为10的倍数。然而，不同的题解在优化和实现细节上有所差异。

#### 关键思路与技巧：
1. **枚举两张牌**：由于牌的范围是1到10，枚举两张牌的复杂度是O(100)，非常高效。
2. **桶计数**：使用桶来记录每个数字出现的次数，方便快速判断是否存在两张牌满足条件。
3. **总和取模**：通过计算所有牌的总和取模10，可以快速确定需要两张牌的和的个位数。
4. **特殊情况处理**：当两张牌相同时，需要确保该牌的数量至少为2。

#### 最优题解：
以下是评分较高的题解，主要基于思路清晰、代码简洁和优化程度。

---

### 所选题解

#### 1. **作者：StudyingFather (★★★★★)**
**关键亮点**：
- 思路清晰，直接通过总和取模10确定需要两张牌的和的个位数。
- 使用桶计数，避免重复枚举，代码简洁高效。
- 特殊情况处理得当，确保两张牌相同时数量足够。

**个人心得**：
- 通过总和取模10的思路，避免了复杂的枚举，大大简化了问题。

**核心代码**：
```cpp
int main()
{
 int n,ans=0;
 cin>>n;
 for(int i=1;i<=n;i++)
 {
  int x;
  cin>>x;
  t[x%10]++;
  ans=(ans+x)%10;
 }
 for(int i=0;i<=9;i++)//枚举两种不同的牌
  for(int j=i+1;j<=9;j++)
   if(t[i]&&t[j]&&(i+j)%10==ans)
   {
    cout<<(!ans?10:ans)<<endl;
    return 0;
   }
 for(int i=0;i<=9;i++)//枚举两种相同的牌
  if(t[i]>=2&&(i+i)%10==ans)
  {
   cout<<(!ans?10:ans)<<endl;
   return 0;
  }
 cout<<0<<endl;
 return 0;
}
```

#### 2. **作者：wpy233 (★★★★☆)**
**关键亮点**：
- 通过总和取模10的思路，快速确定需要两张牌的和的个位数。
- 使用桶计数，避免重复枚举，代码简洁高效。
- 特殊情况处理得当，确保两张牌相同时数量足够。

**个人心得**：
- 通过总和取模10的思路，避免了复杂的枚举，大大简化了问题。

**核心代码**：
```cpp
int main()
{
	cin>>n;
	int x;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		if(x==10) a[0]++;
		else a[x]++;
		ans+=x%10;
	}
	int t=ans%10;
	if(t==0) if(a[0]>=2||a[1]&&a[9]||a[2]&&a[8]||a[3]&&a[7]||a[4]&&a[6]||a[5]>=2) cout<<10<<endl; else cout<<0<<endl;
	if(t==1) if(a[0]&&a[1]||a[2]&&a[9]||a[3]&&a[8]||a[4]&&a[7]||a[5]&&a[6]) cout<<1<<endl; else cout<<0<<endl;
    // 其他情况类似
	return 0;
}
```

#### 3. **作者：kevin_y (★★★★☆)**
**关键亮点**：
- 通过总和取模10的思路，快速确定需要两张牌的和的个位数。
- 使用桶计数，避免重复枚举，代码简洁高效。
- 特殊情况处理得当，确保两张牌相同时数量足够。

**个人心得**：
- 通过总和取模10的思路，避免了复杂的枚举，大大简化了问题。

**核心代码**：
```cpp
int main()
{
n=read();
for(re int i=1;i<=n;++i){
	x=read();
	++a[x];
	sum+=x;
}
if(tr(sum%10)||tr(sum%10+10))printf("%d",sum%10?sum%10:10);
else puts("0");
    return 0;
}
```

---

### 扩展思路与建议

1. **类似题目**：
   - [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)：考察枚举和判断条件。
   - [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：考察区间处理和枚举。
   - [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)：考察桶计数和去重。

2. **调试与优化**：
   - 在枚举时，注意避免重复计算，尤其是当两张牌相同时。
   - 使用桶计数可以大大减少时间复杂度，适用于数据范围较小的情况。

3. **思维拓展**：
   - 类似的问题可以扩展到更多张牌的组合，或者更复杂的条件判断，如多组牌的组合和。

---

### 总结

通过本题的题解分析，我们可以学习到如何通过总和取模和桶计数来高效解决问题。这种思路在处理类似枚举和条件判断的问题时非常有效，尤其是在数据范围较小的情况下。

---
处理用时：47.75秒
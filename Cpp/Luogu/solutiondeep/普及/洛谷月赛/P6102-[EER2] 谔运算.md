# 题目信息

# [EER2] 谔运算

## 题目背景

在某个谔谔的一天中，CYJian 做到一道谔运算的谔谔题，CYJian 发现他不会做，于是决心从头开始研究令人谔谔的谔运算。

## 题目描述

首先，CYJian 写出了一个长度为 $n$ 的数列 $a$。

然后他灵光一动，写出了下面这个谔谔的式子：

$$\sum_{i=1}^{n}\sum_{j=1}^{n}\sum_{k=1}^{n}\sum_{l=1}^{n} (a_i\ {\rm or}\ a_j)\ {\rm xor}\ (a_k\ {\rm and}\ a_l)$$

CYJian 觉得这个是一个谔运算的简单式子，摁计算器花了 $114514{\rm s}$ 就算出来了答案。

为了证明你吊打 $114514$ 个 CYJian，请你在 $1{\rm s}$ 内算出来这个式子的值吧。你只需要给出答案对 $2^{32}$ 取模的值即可。

## 说明/提示

样例一解释：

$(1\ {\rm or}\ 1)\ {\rm xor}\ (1\ {\rm and}\ 1) = 0$

$(1\ {\rm or}\ 1)\ {\rm xor}\ (1\ {\rm and}\ 2) = 1$

$(1\ {\rm or}\ 1)\ {\rm xor}\ (2\ {\rm and}\ 1) = 1$

$(1\ {\rm or}\ 1)\ {\rm xor}\ (2\ {\rm and}\ 2) = 3$

$(1\ {\rm or}\ 2)\ {\rm xor}\ (1\ {\rm and}\ 1) = 2$

$(1\ {\rm or}\ 2)\ {\rm xor}\ (1\ {\rm and}\ 2) = 3$

$(1\ {\rm or}\ 2)\ {\rm xor}\ (2\ {\rm and}\ 1) = 3$

$(1\ {\rm or}\ 2)\ {\rm xor}\ (2\ {\rm and}\ 2) = 1$

$(2\ {\rm or}\ 1)\ {\rm xor}\ (1\ {\rm and}\ 1) = 2$

$(2\ {\rm or}\ 1)\ {\rm xor}\ (1\ {\rm and}\ 2) = 3$

$(2\ {\rm or}\ 1)\ {\rm xor}\ (2\ {\rm and}\ 1) = 3$

$(2\ {\rm or}\ 1)\ {\rm xor}\ (2\ {\rm and}\ 2) = 1$

$(2\ {\rm or}\ 2)\ {\rm xor}\ (1\ {\rm and}\ 1) = 3$

$(2\ {\rm or}\ 2)\ {\rm xor}\ (1\ {\rm and}\ 2) = 2$

$(2\ {\rm or}\ 2)\ {\rm xor}\ (2\ {\rm and}\ 1) = 2$

$(2\ {\rm or}\ 2)\ {\rm xor}\ (2\ {\rm and}\ 2) = 0$

对所有结果求和，即可得到答案为 $30$。

---

**本题采用捆绑测试。**

对于 $100\%$ 的测试点：$1 \leq n \leq 5 \times 10^5$，$0 \leq a_i \leq 2^{32}-1$。

本题共 $6$ 个子任务，各子任务的分值及约定如下：

子任务 $1$（$1$ 分）：为样例一。

子任务 $2$（$14$ 分）：$1 \leq n \leq 80$。

子任务 $3$（$25$ 分）：$0 \leq a_i \leq 80$。

子任务 $4$（$30$ 分）：$0 \leq a_i \leq 5000$。

子任务 $5$（$25$ 分）：$1 \leq n \leq 1000$。

子任务 $6$（$5$ 分）：无特殊限制。

---

#### 友情提示

请注意数据范围。

**如果您不知道上面的谔运算是什么，请参考[这里](https://www.luogu.com.cn/paste/oe4a9czd)**。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
30
```

## 样例 #2

### 输入

```
6
1 1 4 5 1 4
```

### 输出

```
3944
```

## 样例 #3

### 输入

```
7
1 9 1 9 8 1 0
```

### 输出

```
12892
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效计算四重循环的位运算表达式。直接暴力计算的复杂度为 \(O(n^4)\)，显然无法通过。所有题解都采用了**按位分解**的思路，将问题转化为对每一位的独立计算，从而将复杂度降低到 \(O(n \log a_i)\) 或更低。具体来说，题解中常见的优化思路包括：

1. **按位独立计算**：将问题分解为每一位的独立贡献，利用位运算的性质（如异或、与、或）简化计算。
2. **统计0和1的个数**：通过预处理统计每一位上0和1的个数，避免重复计算。
3. **数学公式推导**：通过数学推导，将复杂的四重循环转化为简单的乘法或加法运算。
4. **自然溢出取模**：利用 `unsigned int` 的自然溢出特性，避免显式的取模操作。

### 精选题解

#### 1. 作者：StudyingFather (5星)
- **关键亮点**：思路清晰，代码简洁，通过按位独立计算和统计0/1的个数，将问题转化为简单的乘法运算。代码可读性高，优化程度较好。
- **核心代码**：
  ```cpp
  for(int i=0;i<=31;i++) {
      unsigned andn=t[i]*t[i],orn=(n-t[i])*(n-t[i]);
      ans+=(andn*orn+(tot-andn)*(tot-orn))<<i;
  }
  ```
- **实现思想**：统计每一位上1的个数，计算 `and` 和 `or` 操作的结果，最终累加每一位的贡献。

#### 2. 作者：chen_03 (4.5星)
- **关键亮点**：详细推导了每一位的贡献公式，通过分类讨论和容斥原理，将问题转化为简单的数学表达式。代码实现较为清晰，优化程度较好。
- **核心代码**：
  ```cpp
  for(re int i=0;i<32;++i) {
      xs=ys=x=y=0;
      for(re int j=1;j<=n;++j) (a[j]>>i)&1?++xs:0;
      ys=n-xs;
      for(re int j=1;j<=n;++j) (a[j]>>i)&1?(x+=n,y+=ys):(y+=n,x+=xs);
      ans+=(x*y+(sum-x)*(sum-y))<<i;
  }
  ```
- **实现思想**：统计每一位上1的个数，计算 `or` 和 `and` 操作的结果，最终累加每一位的贡献。

#### 3. 作者：pomelo_nene (4星)
- **关键亮点**：通过按位分解和统计0/1的个数，将问题转化为简单的乘法运算。代码实现较为简洁，优化程度较好。
- **核心代码**：
  ```cpp
  for(int i=0;i<=31;++i) {
      ul bita1=bit[i]*bit[i],bita0=n*n-bita1,bito1=bit[i]*n+(n-bit[i])*bit[i],bito0=n*n-bito1;
      ans+=(bita0*bito1+bita1*bito0)*(1<<i);
  }
  ```
- **实现思想**：统计每一位上1的个数，计算 `or` 和 `and` 操作的结果，最终累加每一位的贡献。

### 最优关键思路与技巧

1. **按位独立计算**：将问题分解为每一位的独立贡献，利用位运算的性质简化计算。
2. **统计0和1的个数**：通过预处理统计每一位上0和1的个数，避免重复计算。
3. **数学公式推导**：通过数学推导，将复杂的四重循环转化为简单的乘法或加法运算。
4. **自然溢出取模**：利用 `unsigned int` 的自然溢出特性，避免显式的取模操作。

### 可拓展之处

本题的按位分解思路可以推广到其他涉及位运算的问题，如异或和、与和、或和等。类似的题目可以通过统计每一位的贡献来简化计算。

### 推荐题目

1. [P3919 【模板】可持久化线段树 1（主席树）](https://www.luogu.com.cn/problem/P3919)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

### 个人心得摘录

- **StudyingFather**：通过按位独立计算，将问题转化为简单的乘法运算，代码实现简洁高效。
- **chen_03**：详细推导了每一位的贡献公式，通过分类讨论和容斥原理，将问题转化为简单的数学表达式。
- **pomelo_nene**：通过按位分解和统计0/1的个数，将问题转化为简单的乘法运算，代码实现较为简洁。

---
处理用时：36.48秒
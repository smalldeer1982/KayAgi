# 题目信息

# 『MdOI R2』Mayuri

## 题目背景

「万由里……怎么会？为什么你要……」

『我是灵力的结晶体，实施了封印，我当然会消失，不是吗？』

「封印？但是你和我……」

『第一次见面不能封印吗？笨蛋，我可是从大家的灵力里出生的，怎么可能讨厌你？从一出生，我就爱着你。』

「万由里……」

『虽然我竭力不让自己去想，但我一定是很羡慕大家……』

「等一下，万由里，不要消失……」

『但是我还是有一件能向大家炫耀的事，只有我和士道一样……』

「一样？」

『我已经不再是只为了消失而出生的生命。因为我遇见了你……已经足够了。』

「万由里……」

『谢谢你，士道。 』

![](https://cdn.luogu.com.cn/upload/image_hosting/9w6a0deg.png)

## 题目描述

在离开这个世界前，万由里想要寻找属于她的 Lucky Number。

万由里会给出一个数 $a$，以及一个长度为 $b$ 的 01 串 $S$。

简单的说，她的 Lucky Number 是满足以下条件的**正整数** $n$：

 - $n$ 的位数为 $b$ 且不含前导 $0$。

 - 若 $S$ 的第 $i$ 位为 $1$，则 $n$ 的前 $i$ 位组成的数是 $a$ 的倍数，否则 $n$ 的前 $i$ 位组成的数不是 $a$ 的倍数。

对于一个数，前 $i$ 位组成的数是指这个数前 $i$ 个数码依次拼接形成的数。例如 $312311$ 前 $3$ 位组成的数为 $312$，前 $5$ 位组成的数为 $31231$。


现在，请你帮助万由里计算一下，她的 Lucky Number 是多少。

由于满足条件的数可能会有多个，你需要输出**最小**的一个。若不存在，则请输出 `-1`。

## 说明/提示

【帮助与提示】

为方便选手测试代码，本题额外提供一组附加样例供选手使用。

[样例输入](https://www.luogu.com.cn/paste/5gnn8mg0) [样例输出](https://www.luogu.com.cn/paste/sgxjkbjd)

------
【样例解释】

对于样例一，$10$ 是 $2$ 位数，且 $10$ 的前 $1$ 位组成的数 $1$ 不是 $2$ 的倍数，而前 $2$ 位组成的数 $10$ 是 $2$ 的倍数。由于 $10$ 已经是最小的两位数，故不存在比 $10$ 更小的满足条件的数。

对于样例二，我们需要构造一个 $1$ 位数，满足这个 $1$ 位数整除 $10$。显然，这样的数不存在。

---

【数据范围】

**本题采用捆绑测试**


| 子任务编号 | $a \leq$ | $b\le$  | 分值   |
| ---------- | -------- | :------ | ------ |
| Subtask 1  | $10$     | $ 1$    | $20$   |
| Subtask 2  | $10 $    | $2$     | $20$  |
| Subtask 3  | $10 $    | $ 6$    | $20$  |
| Subtask 4  | $ 2$     | $ 18$   | $20$ |
| Subtask 5  | $ 10$    | $ 10^5$ | $20$ |


对于全部数据，保证 $2\le a\le 10$，$1\le b\le 10^5$，$S$ 中只包含 `0` 和 `1`。

## 样例 #1

### 输入

```
2 2
01```

### 输出

```
10```

## 样例 #2

### 输入

```
10 1 
1```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 6
110100```

### 输出

```
601210```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个满足特定条件的数，且该数的每一位都需根据给定的01串进行约束。题解主要集中在如何高效地构造这个数，并确保其满足条件。大多数题解采用了贪心算法，通过逐位构造并利用模运算来避免高精度计算。部分题解还针对不同子任务进行了优化，如特判无解情况、利用整除性质等。

### 所选高星题解

#### 1. **作者：grass8cow (5星)**
- **关键亮点**：该题解通过贪心算法，逐位构造数，并利用模运算避免高精度计算。代码简洁且高效，特别处理了无解情况，且没有使用额外数组，直接输出结果。
- **个人心得**：作者提到“$now$ 明显不需要数组，$ans$ 可一边计算，一边输出”，体现了对空间复杂度的优化意识。
- **核心代码**：
  ```cpp
  int main() {
      cin>>a>>b>>c;
      if(a==10&&c=='1'){cout<<-1;return 0;}
      if(c=='1')cout<<a;
      else cout<<1,now=1;
      for(i=1;i<b;i++) {
          cin>>c; 
          now=now*10%a;
          if(c=='0'){if(now)cout<<0;else cout<<1,now=1;}
          else cout<<(a-now)%a,now=0;
      }
      return 0;
  }
  ```

#### 2. **作者：BFqwq (4.5星)**
- **关键亮点**：官方题解，思路清晰，详细证明了无解情况，并给出了贪心算法的正确性证明。代码实现简洁，适合初学者理解。
- **核心代码**：
  ```cpp
  int main() {
      cin>>a>>b>>c;
      if(c[0]=='0')n[0]='1',now=1;
      else {
          if(a==10){puts("-1");return 0;}
          else n[0]=a+'0';
      };
      for(int i=1;i<b;i++) {
          now*=10;
          for(int j=0;j<=9;j++)
          if((now+j)%a==0&&c[i]=='1'||(now+j)%a!=0&&c[i]=='0'){
              now+=j;
              now%=a;
              n[i]=j+'0';
              break;
          }
      }
      cout<<n;
      return 0;
  }
  ```

#### 3. **作者：monstersqwq (4星)**
- **关键亮点**：该题解针对不同子任务进行了优化，特别是对 $a=10$ 和 $a=2$ 的情况进行了特判，减少了不必要的计算。代码结构清晰，易于理解。
- **核心代码**：
  ```cpp
  int main() {
      cin>>a>>b>>s;
      if(a==2) {
          for(int i=0;i<b;i++) {
              if(s[i]=='1') {
                  if(i!=0) cout<<"0";
                  else cout<<"2";
              } else cout<<"1";
          }
          return 0;
      }
      if(a==10) {
          for(int i=0;i<b;i++) {
              if(s[i]=='1') {
                  if(i==0) {cout<<"-1";return 0;}
                  else cout<<"0";
              } else cout<<"1";
          }
          return 0;
      }
      // 其他情况处理
  }
  ```

### 最优关键思路与技巧
1. **贪心算法**：逐位构造数，确保每一步都满足条件，且尽量选择最小的数字。
2. **模运算优化**：通过模运算避免高精度计算，减少时间复杂度。
3. **特判无解情况**：如 $a=10$ 且 $S[0]='1'$ 时直接输出 `-1`。

### 可拓展之处
- **类似题目**：可以扩展到更复杂的数位构造问题，如要求数的某些位满足特定数学性质（如素数、回文等）。
- **算法套路**：贪心算法结合模运算，适用于类似的数位构造问题。

### 推荐题目
1. **P1003 铺地毯**：考察贪心算法的应用。
2. **P1045 数的划分**：涉及数位构造与条件约束。
3. **P1056 排座椅**：贪心算法的实际应用场景。

### 个人心得总结
- **调试经历**：部分作者提到在调试过程中发现高精度计算会导致超时，转而使用模运算优化。
- **踩坑教训**：特判无解情况容易被忽略，需特别注意。
- **顿悟感想**：通过模运算避免高精度计算，是解决大数问题的常用技巧。

---
处理用时：36.04秒
# 题目信息

# 混凝土数学

## 题目描述

你正在看混凝土数学，这时旁边的工地开工了，你觉得看他们施工更有意思，于是你向窗外望去，注意到了一些长度不同的木棍。具体而言，你看到了 $n$ 条木棍编号为 $1,2,3,\ldots,n$，长度为 $a_1,a_2,a_3,\ldots,a_n$。你突发奇想：有多少拿出其中 $3$ 条木棍的方案满足它们能构成等腰三角形呢？你不想要输出的数太大，所以最后的方案要对 $998244353$ 取模。

给出等腰三角形的要求：任意两边之和大于第三边且至少有两条边边长相等。

例如，如果木棍长度分别为 $\{3,3,2,2,4,5\}$，你就有 $6$ 种方法，选取的木棍编号分别为：$\{1,2,3\}$，$\{1,2,4\}$，$\{1,2,5\}$，$\{1,2,6\}$，$\{1,3,4\}$，$\{2,3,4\}$。

## 说明/提示

- Subtask1 （$30$ pts）：$1\leq n \leq 200$。
- Subtask2 （$30$ pts）：$1\leq n \leq 2000$。
- Subtask3 （$20$ pts）：木棍长度全部相等。
- Subtask4 （$20$ pts）：无特殊限制。

对于 $100\%$ 的数据满足：$1\leq n \leq 2\times 10^5$，$1\leq a_i \leq 2\times 10^5$。

## 样例 #1

### 输入

```
6
3 3 2 2 4 5```

### 输出

```
6```

## 样例 #2

### 输入

```
6
1 1 4 5 1 4
```

### 输出

```
5```

## 样例 #3

### 输入

```
6
2 2 2 2 2 2```

### 输出

```
20```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地统计能够构成等腰三角形的木棍组合。题解中主要涉及以下几种思路：

1. **桶计数与前缀和优化**：通过桶记录每种长度的木棍数量，并结合前缀和快速计算符合条件的木棍数量。这种方法的时间复杂度为O(n)，是最优解。
2. **二分查找与组合数学**：通过二分查找快速确定符合条件的木棍范围，并结合组合数学公式计算方案数。这种方法的时间复杂度为O(n log n)，适用于中等规模的数据。
3. **暴力枚举与特判**：对于小规模数据，直接暴力枚举所有可能的组合，并通过特判优化等边三角形的情况。这种方法的时间复杂度为O(n^3)，仅适用于小规模数据。

最优解的关键在于**桶计数与前缀和优化**，通过预处理和组合数学公式，能够高效地计算出符合条件的等腰三角形数量。

### 所选高质量题解

#### 1. 作者：wuyonghuming (★★★★★)
- **关键亮点**：通过桶计数和前缀和优化，结合组合数学公式，高效计算等腰三角形数量。代码简洁，思路清晰，时间复杂度为O(n)。
- **个人心得**：作者强调了使用long long的重要性，避免了大数计算时的溢出问题。

```cpp
long long f[200001],ans;
int main() {
    int n,m=0,k=0,l=1,a;
    scanf("%d",&n);
    for(int i=1;i<=n;i++) {
        scanf("%d",&a);
        f[a]++;
        m=m<a?a:m;
    }
    for(int i=1;i<=m;i++) {
        for(;l<i*2&&l<=m;l++) k+=f[l];
        ans+=(f[i]-1)*f[i]*(k-f[i])/2+(f[i]-2)*(f[i]-1)*f[i]/6;
    }
    printf("%lld",ans%998244353);
    return 0;
}
```

#### 2. 作者：monstersqwq (★★★★☆)
- **关键亮点**：通过桶计数和前缀和优化，结合组合数学公式，高效计算等腰三角形数量。代码简洁，思路清晰，时间复杂度为O(n)。
- **个人心得**：作者提醒了数组开两倍的重要性，避免在计算时出现越界问题。

```cpp
long long n,a[200005],c[400005],sum[400005];
long long ans=0;
int main() {
    cin>>n;
    for(int i=1;i<=n;i++) {
        cin>>a[i];
        c[a[i]]++;
    }
    for(int i=1;i<=4e5;i++) sum[i]=sum[i-1]+c[i];
    for(int i=1;i<=2e5;i++) {
        if(c[i]>=2) {
            ans=(ans+c[i]*(c[i]-1)*(sum[i*2-1]-c[i])/2+c[i]*(c[i]-1)*(c[i]-2)/6)%998244353;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

#### 3. 作者：lcy09 (★★★★☆)
- **关键亮点**：通过桶计数和前缀和优化，结合组合数学公式，高效计算等腰三角形数量。代码简洁，思路清晰，时间复杂度为O(n)。
- **个人心得**：作者强调了使用long long的重要性，避免了大数计算时的溢出问题。

```cpp
int bin[MAXN],Max;
int sum[MAXN];
int ans;
signed main() {
    cin>>n;
    for(int i=1;i<=n;i++) {
        int l;
        scanf("%lld",&l);
        bin[l]++;
        Max=max(Max,l);
    }
    for(int i=1;i<=Max;i++) sum[i]=sum[i-1]+bin[i];
    for(int i=1;i<=Max;i++) {
        if(bin[i]>=2) {
            int temp=sum[min(2*i-1,Max)]-bin[i];
            temp=temp*bin[i]*(bin[i]-1)/2%mod;
            ans=(ans+temp)%mod;
            if(bin[i]>2) {
                ans+=(bin[i]*(bin[i]-1)*(bin[i]-2)/6)%mod;
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

### 最优关键思路与技巧

1. **桶计数与前缀和优化**：通过桶记录每种长度的木棍数量，并结合前缀和快速计算符合条件的木棍数量。
2. **组合数学公式**：利用组合数学公式计算等腰三角形和等边三角形的数量，避免重复计算。
3. **数组开两倍**：在计算时，数组开两倍以避免越界问题。

### 可拓展之处

- **类似题目**：可以拓展到其他需要统计组合数的题目，如统计能够构成特定形状的几何图形的组合数。
- **算法套路**：桶计数与前缀和优化的方法可以应用于其他需要快速统计符合条件的元素数量的题目。

### 推荐题目

1. [P2181 对角线](https://www.luogu.com.cn/problem/P2181)
2. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)
3. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)

---
处理用时：43.27秒
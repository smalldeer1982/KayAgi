# 题目信息

# 「EZEC-3」排列

## 题目描述

pigstd 有一堆数，他想在这么多数中选出若干个数排成一列，记为 $x_{1},x_{2},\cdots,x_{p}$（$p$ 为数的个数）。

这一列数合法**当且仅当**满足以下条件：

- $p \ge 2$。
- 令 $y_{i} = x_{i + 1} - x_{i}$（特别的，$y_{p}=x_{1}-x_{p}$），如果把 $y_{1}$ 到 $y_{p}$ 按 $y_1,y_2,\cdots,y_p$ 的顺序排成**一圈**，那么每两个相邻的数互为相反数且绝对值都为 $k$。

pigstd 想知道，在所有合法的数列中，所有在这个数列中的数之和**最大**是多少。

## 说明/提示

**【样例 1 说明】**

当 pigstd 的排列为：$0,3,0,3$ 或 $3,0,3,0$ 时，总和最大，为 $6$。

**【数据规模与约定】**

对于 $100\%$ 的数据，$1 \le n \le 10^6$，$0 \le k,a_{i} \le 10^6$，$1 \le b_{i} \le 10^6$。

**本题采用捆绑测试。**

- Subtask 1（5 points）：保证无合法的数列；
- Subtask 2（15 points）：$k = 0$；
- Subtask 3（5 points）：$n = 1$；
- Subtask 4（5 points）：$n = 2$；
- Subtask 5（30 points）：$n,k,a_i,b_i \le 10^3$；
- Subtask 6（40 points）：无特殊限制。

## 样例 #1

### 输入

```
4 3 
1 5
2 4
3 3
0 2```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个满足特定条件的数列，且该数列中的数之和最大。通过分析，可以发现合法的数列只能由两个数交替组成，且这两个数的差为给定的 $k$。因此，解题思路主要集中在如何高效地找到这两个数，并计算它们的最大和。

大多数题解都采用了类似的方法：使用桶（数组）记录每个数的出现次数，然后枚举每个数 $x$，检查 $x+k$ 是否存在，并计算它们的最大和。对于 $k=0$ 的情况，需要特判，因为此时数列中的所有数必须相同。

### 所选高星题解

#### 1. 作者：pigstd (赞：11)
- **星级**：★★★★★
- **关键亮点**：
  - 思路清晰，直接指出数列只能由两个数交替组成，且差为 $k$。
  - 代码简洁，使用桶记录数的出现次数，并高效枚举计算最大和。
  - 对 $k=0$ 的情况进行了特判，处理得当。
- **核心代码**：
  ```cpp
  for (int i=0;i<=maxn;i++)
  {
      int j=i+k;
      if (sum[i]&&sum[j])
          ans=max(ans,min(sum[i],sum[j])*(i+j));
  }
  ```
- **个人心得**：出题人直接给出了简洁高效的解法，避免了复杂的推导，直接抓住了问题的本质。

#### 2. 作者：JRzyh (赞：5)
- **星级**：★★★★
- **关键亮点**：
  - 通过差分分析，直接得出数列的构造方式。
  - 代码简洁，使用桶记录数的出现次数，并高效计算最大和。
  - 对 $k=0$ 的情况进行了特判，处理得当。
- **核心代码**：
  ```cpp
  for(long long i=0;i<=1000000-k;i++)
  {
      if(a[i]!=0&&a[i+k]!=0)
      {
          int res=0;
          if(k==0)res=i;
          else res=(i+i+k);
          if(min(a[i],a[i+k])!=1)ans=max(ans,res*min(a[i],a[i+k]));
      }
  }
  ```
- **个人心得**：通过差分分析，快速得出数列的构造方式，代码简洁高效。

#### 3. 作者：InformationEntropy (赞：5)
- **星级**：★★★★
- **关键亮点**：
  - 通过数学推导，详细分析了数列的构造方式。
  - 代码清晰，使用桶记录数的出现次数，并高效计算最大和。
  - 对 $k=0$ 的情况进行了特判，处理得当。
- **核心代码**：
  ```cpp
  for(int i=0; i<=maxx-k; i++)
  {
      if(f[i]&&f[i+k])
      {
          flag=1;
          ll w=min(f[i], f[i+k]);
          ans=max(ans, w*i + w*(i+k));
      }
  }
  ```
- **个人心得**：通过数学推导，详细分析了数列的构造方式，代码清晰高效。

### 最优关键思路与技巧

1. **桶的使用**：通过数组（桶）记录每个数的出现次数，能够高效地枚举和计算最大和。
2. **特判 $k=0$**：当 $k=0$ 时，数列中的所有数必须相同，需要单独处理。
3. **枚举与优化**：通过枚举每个数 $x$，检查 $x+k$ 是否存在，并计算它们的最大和，避免了复杂的推导和计算。

### 可拓展之处

- **类似问题**：类似的问题可以考察如何构造满足特定条件的数列，或者如何在给定的条件下找到最大/最小的数列和。
- **算法套路**：桶的使用、枚举与优化、特判处理等技巧在其他问题中也有广泛应用。

### 推荐题目

1. **P1045 数列分段**：考察如何将数列分成若干段，满足特定条件。
2. **P1090 合并果子**：考察如何通过合并操作得到最小的代价，类似构造数列的问题。
3. **P1106 删数问题**：考察如何通过删除操作得到最小的数，类似构造数列的问题。

### 通用建议与扩展思路

- **理解题意**：在解题时，首先要理解题意，明确问题的核心要求。
- **简化问题**：通过分析，将复杂的问题简化为易于处理的形式，如本题中通过分析得出数列只能由两个数交替组成。
- **特判处理**：对于特殊情况（如 $k=0$），需要进行特判处理，避免遗漏。
- **优化枚举**：通过桶等数据结构，优化枚举过程，提高代码效率。

---
处理用时：34.96秒
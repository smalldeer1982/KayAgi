# 题目信息

# [Cnoi2020] 雷雨

## 题目背景

> 令人不安的云开始笼罩天空。  
巨大的建筑在强风中轧轧作响。  
幻想乡中响彻着不和协音。  
——「东方辉针城 ～ Double Dealing Character」

一个雷雨交加的夜晚，一束闪电击中了雾之湖畔的红魔馆和迷途竹林。

似乎有什么大事要发生，Cirno 在小屋静静地中思考着。

## 题目描述

幻想乡的纵切面可以抽象成一个 $n\times m$ 的矩形。

其中每一个 $1\times 1$ 的单元格 $(i,j)$ 都有一个**电阻计量值**(虚构的概念) $R_{i,j}$。

闪电从**雷雨云**上的 $\texttt{O}(n,a)$ 发出，击中了**地面**上的*红魔馆* $\texttt{A}(1,b)$ 与*迷途竹林* $\texttt{B}(1,c)$。

雷电是自然的造物，所以覆盖的位置电阻计量值总和最小，即从 $\texttt{O}$ 到 $\texttt{A}$ 与 $\texttt{B}$ 的**两条路径的并集**的电阻计量值的和最小。

所以在所有位置电阻计量已知的情况下，Cirno 想知道雷电的经过的路径的最小电阻计量值的和。

## 说明/提示

## 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/7ozs40i3.png)

如图黄色线为闪电的路径。

## 数据范围与约定

对于 $100\%$ 的数据保证：$0<n,m \le 1000$，$0 \le R_{i,j}\le 10^9$，$0< a,b,c \le m$。

#### 子任务「本题采用捆绑测试」

 - Subtask1（$10\%$）: $R_{i,j}\in\{1\}$。
 - Subtask2（$10\%$）: $R_{i,j}\in\{0,1\}$。
 - Subtask3（$10\%$）: $a=b=c$。
 - Subtask4（$10\%$）: $n,m \le 5$。
 - Subtask5（$60\%$）: 无特殊限制。
 

## 样例 #1

### 输入

```
5 5 1 2 4
1 8 1 6 6
1 1 1 2 4
8 3 1 2 2
1 2 1 9 1
1 0 9 1 1```

### 输出

```
15```

# AI分析结果

### 综合分析与结论

本题的核心是求从起点到两个终点的路径并集的最小电阻值。大多数题解都采用了类似的最短路算法，通过枚举分叉点，分别计算从起点和两个终点到该点的最短路，然后求和并减去重复计算的分叉点电阻值。以下是各题解的要点总结：

1. **算法选择**：大多数题解使用了Dijkstra算法，部分题解提到SPFA不适用于网格图。
2. **优化思路**：通过从三个点分别跑最短路，预处理所有点到这三个点的最短距离，然后枚举分叉点，避免了重复计算。
3. **难点处理**：分叉点的电阻值被多次计算，需要在求和时减去多余的部分。
4. **代码实现**：部分题解使用了优先队列优化Dijkstra，代码结构清晰，易于理解。

### 所选高星题解

#### 1. **作者：Lonely_NewYear (赞：31)**  
**星级：★★★★★**  
**关键亮点**：
- 思路清晰，详细解释了如何通过枚举分叉点来求解最小电阻值。
- 代码结构简洁，使用了Dijkstra算法，并通过优先队列优化。
- 强调了分叉点的电阻值需要减去两次，避免重复计算。

**核心代码**：
```cpp
void dijkstra(int k, int sx, int sy) {
    priority_queue<node> q;
    q.push((node){sx, sy, num[sx][sy]});
    bool vis[1001][1001] = {0};
    for (int i = 1; i <= 1000; i++) {
        for (int j = 1; j <= 1000; j++) {
            dis[k][i][j] = 1e18;
        }
    }
    dis[k][sx][sy] = num[sx][sy];
    while (!q.empty()) {
        int x = q.top().x, y = q.top().y;
        q.pop();
        if (vis[x][y]) continue;
        vis[x][y] = 1;
        for (int i = 0; i < 4; i++) {
            int tx = x + dx[i], ty = y + dy[i];
            if (tx < 1 || tx > n || ty < 1 || ty > m) continue;
            if (dis[k][tx][ty] > dis[k][x][y] + num[tx][ty]) {
                dis[k][tx][ty] = dis[k][x][y] + num[tx][ty];
                q.push((node){tx, ty, dis[k][tx][ty]});
            }
        }
    }
}
```
**个人心得**：强调了“不开long long见祖宗”，提醒了数据类型的重要性。

#### 2. **作者：InformationEntropy (赞：7)**  
**星级：★★★★☆**  
**关键亮点**：
- 详细解释了分叉点的概念，并通过数学公式清晰地表达了最小电阻值的计算方法。
- 使用了Dijkstra算法，并通过方向数组简化了网格图的遍历。

**核心代码**：
```cpp
void dijkstra(int sx, int sy, int p) {
    priority_queue<node> q;
    q.push((node){sx, sy, ma[sx][sy]});
    memset(vis, 0, sizeof(vis));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            dis[p][i][j] = inf;
        }
    }
    dis[p][sx][sy] = ma[sx][sy];
    while (!q.empty()) {
        node now = q.top(); q.pop();
        int x = now.x, y = now.y;
        if (vis[x][y]) continue;
        vis[x][y] = 1;
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 1 || nx > n || ny < 1 || ny > m || vis[nx][ny]) continue;
            if (dis[p][nx][ny] > dis[p][x][y] + ma[nx][ny]) {
                dis[p][nx][ny] = dis[p][x][y] + ma[nx][ny];
                q.push((node){nx, ny, dis[p][nx][ny]});
            }
        }
    }
}
```
**个人心得**：强调了SPFA不适用于网格图，提醒了算法选择的重要性。

#### 3. **作者：Rubidium_Chloride (赞：5)**  
**星级：★★★★☆**  
**关键亮点**：
- 详细分析了最优路径的结构，并通过枚举分叉点来求解最小电阻值。
- 使用了优先队列优化的Dijkstra算法，代码结构清晰。

**核心代码**：
```cpp
void bfs(ll t, ll tx, ll ty) {
    fill(vst[0], vst[0] + N * N, 0);
    priority_queue<NODE> q;
    q.push((NODE){tx, ty, dst[t][tx][ty]});
    while (!q.empty()) {
        NODE x = q.top(); q.pop();
        if (vst[x.x][x.y]) continue;
        vst[x.x][x.y] = 1;
        for (int i = 0; i < 4; i++) {
            ll nx = x.x + dx[i], ny = x.y + dy[i];
            if (nx < 1 || nx > n || ny < 1 || ny > m || vst[nx][ny]) continue;
            dst[t][nx][ny] = min(dst[t][nx][ny], dst[t][x.x][x.y] + r[nx][ny]);
            q.push((NODE){nx, ny, dst[t][nx][ny]});
        }
    }
}
```
**个人心得**：强调了“类·最短路问题”，提醒了问题的本质。

### 最优关键思路与技巧

1. **分叉点枚举**：通过枚举分叉点，将问题转化为从三个点到该点的最短路问题，避免了路径并集的复杂计算。
2. **Dijkstra优化**：使用优先队列优化Dijkstra算法，适用于网格图的最短路计算。
3. **重复计算处理**：分叉点的电阻值被多次计算，需要在求和时减去多余的部分。

### 可拓展之处

1. **类似问题**：可以扩展到多个起点或多个终点的最短路问题，依然可以通过枚举分叉点来解决。
2. **算法优化**：在网格图中，Dijkstra算法可以通过优先队列进一步优化，减少时间复杂度。

### 推荐题目

1. **P4779 【模板】单源最短路径（标准版）**：练习Dijkstra算法的经典题目。
2. **P3371 【模板】单源最短路径（弱化版）**：适合初学者练习最短路算法。
3. **P1144 最短路计数**：在求最短路的同时，统计最短路的数量，适合进一步理解最短路算法。

### 个人心得总结

- **数据类型**：在处理大范围数据时，务必使用`long long`，避免溢出。
- **算法选择**：在网格图中，Dijkstra算法优于SPFA，选择合适的算法可以提高效率。
- **调试经验**：在调试时，优先检查边界条件和数据类型的正确性，避免不必要的错误。

---
处理用时：58.07秒
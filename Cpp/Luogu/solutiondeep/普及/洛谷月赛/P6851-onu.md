# 题目信息

# onu

## 题目背景

小 C 和小 D 是好朋友。他们正在尝试一种全新的牌类游戏——onu！

## 题目描述

为了增加一点趣味性，小 C 和小 D 每人买了 $v$ 颗糖用来当作筹码。

onu 的规则是这样的：

游戏共 $m$ 轮，由两人进行，一位先手，一位后手。在这里，我们默认先手的玩家是小 C，而后手的玩家是小 D。

在最开始时，小 C 会得到 $m$ 张牌，每张牌有其对应的花色、点数。而小 D 会得到 $n$ 张牌。

每一轮开始时，小 C 会打出一张牌，放在桌面上展示给小 D 看。

在此之后，小 D 需要跟牌，即打出他手上的一张牌，且该张牌必须满足其花色与小 C 打出的牌相同。若小 D 没有满足条件的牌或者是他**选择弃权（也就是说，可以选择当前回合是否打出牌）**，弃掉小 C 打出的牌后跳过该轮，视为小 D 败。

在小 D 打出满足要求的牌后，进行一次拼点，也即比较小 C 和小 D 打出的牌的点数：如果小 D 出的牌的点数**大于等于**小 C 的牌的点数，则小 D 胜，否则小 D 败。容易知道，这样不会出现平局的情况。

最后，胜的一方会从败的一方拿走 $c$ 颗糖，且双方均需弃掉打出的牌，并会**再从商店买等于自己打出的牌的点数颗糖**。例如小 C 和小 D 打的点数分别是 $3$ 和 $5$，那么小 C 会去购买 $3$ 颗糖，小 D 购买 $5$ 颗。

为了不破坏两人间的友好关系，不出现一方被另一方完全赢光的情况，他们在最开始买糖时，已经约定好了 $v \ge c \times m$。

现在，小 D 通过一些神秘手段，知道了小 C 在这 $m$ 轮中打出的所有牌，他希望在 $m$ 轮游戏进行之后，让自己的糖数尽量多。你可以帮他找到最优的方案吗？

## 说明/提示

#### 「样例 1 解释」

以 $(a, b)$ 来表示一张花色为 $a$，点数为 $b$ 的牌。

一开始，小 D 有 $4$ 颗糖。小 C 会依次打出 $(1, 6), (3, 5), (1, 4)$ 三张牌。

一种最优的方案是：

第一轮，小 C 打出第一张牌 $(1, 6)$，小 D 打出第二张牌 $(1, 2)$，小 D 负，被拿走 $1$ 颗糖，购买 $2$ 颗糖。此时其有 $5$ 颗糖。

第二轮，小 C 打出 $(3, 5)$，小 D 打出 $(3, 5)$，由于点数**大于等于**小 C 的牌，所以小 D 胜，拿到 $1$ 颗糖，购买 $5$ 颗糖。此时其有 $11$ 颗糖。

第三轮，小 C 打出 $(1, 4)$。由于小 D 在第一轮已经打出过第二张牌 $(1, 2)$ 了，所以没有牌能打，输出 $-1$ 并判小 D 负，被拿走 $1$ 颗糖，此时其有 $10$ 颗糖。

#### 「样例 2 解释」

最开始有 $5$ 颗糖。

第一轮时小 C 打出 $(1, 8)$，小 D 选择弃权，败，于是剩下了 $5 - 1 = 4$ 颗糖；

第二轮时小 C 打出 $(1, 4)$，小 D 打出 $(1, 5)$，胜，得到 $5 + 1$ 颗糖，故最终小 D 有 $10$ 颗糖。

----

#### 「Special Judge 说明」

**请认真阅读输出格式**。

每个测试点仅有 $0$ 分和满分的区别。如果你的输出出现了以下情况，将会被判为 $0$ 分：

- 输出格式不符，如没有正确换行，输出了一些奇奇怪怪的字符等。
- 输出的最优糖果数与标准答案不同。
- 打牌的方案不合法，即不能打出已经弃掉的牌，也不能打出花色与小 C 打出的牌不相同的牌。
- 按照你所输出的方案打完牌后，小 D 的剩余糖果数与你第一行所输出的数字不同。

---

#### 「数据范围」

**本题采用捆绑测试**。

- Subtask 1(10 points)：$n, m \le 5$；
- Subtask 2(30 points)：$n, m \le 1000$；
- Subtask 3(20 points)：$c = 0$；
- Subtask 4(20 points)：$a _i = 1$；
- Subtask 5(20 points)：无特殊限制。

所有数据保证 $1 \le n, m, a _i, b _i\le 10 ^5$，$0 \le c \le 10 ^5$，$c \times m \le v \le 10 ^{12}$。

## 样例 #1

### 输入

```
3 3 1 4
3 5
1 2
2 6
1 6
3 5
1 4```

### 输出

```
10
2
1
-1```

## 样例 #2

### 输入

```
1 2 1 5
1 5
1 8
1 4```

### 输出

```
10
-1
1```

# AI分析结果

### 综合分析与结论

这些题解大多基于贪心算法，核心思路是通过合理匹配小C和小D的牌，使得小D的糖果数最大化。题解的主要难点在于如何高效地处理不同花色的牌，并确保在每一轮中做出最优决策。大多数题解通过排序和双指针技术来实现这一目标，部分题解还引入了优先队列等数据结构来优化匹配过程。

### 所选高质量题解

#### 1. **作者：vectorwyx (赞：7)**  
**星级：5星**  
**关键亮点：**  
- 将问题分解为多个独立的子问题，每个子问题仅处理同花色的牌，简化了问题复杂度。
- 通过排序和双指针技术，确保每次匹配都是最优的。
- 代码结构清晰，逻辑严谨，易于理解。

**个人心得：**  
作者提到“弃权 < 打出并落败 < 打出并获胜”，这一观察帮助他明确了贪心策略的方向，确保每次决策都是最优的。

**核心代码：**
```cpp
for(int i = 1; i <= colortot; i++) {
    int color = colors[i];
    Line al = aline[color], bl = bline[color];
    int lena = al.r - al.l + 1, lenb = bl.r - bl.l + 1;
    if(bl.l == 0 && bl.r == 0) lenb = 0;
    priority_queue<Pai> heap, other;
    if(lena >= lenb) {
        for(int i = 1; i <= lenb; i++) {
            ans += b[bl.l + i - 1].number;
            heap.push(b[bl.l + i - 1]);
        }
        for(int i = al.l; i <= al.r; i++) {
            if(heap.empty()) break;
            while(!heap.empty()) {
                Pai crt = heap.top(); heap.pop();
                if(crt.number >= a[i].number) {
                    ans += c;
                    sol[a[i].bianhao] = crt.bianhao;
                    break;
                } else {
                    other.push(crt);
                }
            }
        }
    }
}
```

#### 2. **作者：hensier (赞：6)**  
**星级：4.5星**  
**关键亮点：**  
- 详细分析了不同情况下的最优策略，特别是如何处理小D的牌比小C多或少的情况。
- 通过优先队列和堆结构，确保每次匹配都是最优的。
- 代码实现较为复杂，但逻辑清晰，优化程度高。

**个人心得：**  
作者提到“大牌所选择的拼点对象也得考虑”，这一观察帮助他避免了不必要的匹配，确保每次匹配都是最优的。

**核心代码：**
```cpp
for(int i = 1; i <= m; i++) {
    if(heap.empty()) break;
    while(!heap.empty()) {
        Pai crt = heap.top(); heap.pop();
        if(crt.number >= a[i].number) {
            ans += c;
            sol[a[i].bianhao] = crt.bianhao;
            break;
        } else {
            other.push(crt);
        }
    }
}
```

#### 3. **作者：pikabi (赞：5)**  
**星级：4星**  
**关键亮点：**  
- 通过排序和双指针技术，确保每次匹配都是最优的。
- 代码结构清晰，逻辑严谨，易于理解。
- 通过优先队列和堆结构，确保每次匹配都是最优的。

**个人心得：**  
作者提到“优先赢得小 C 打出的牌中点数较小的那些”，这一观察帮助他确保了每次匹配都是最优的。

**核心代码：**
```cpp
for(int i = 1; i <= m; i++) {
    if(heap.empty()) break;
    while(!heap.empty()) {
        Pai crt = heap.top(); heap.pop();
        if(crt.number >= a[i].number) {
            ans += c;
            sol[a[i].bianhao] = crt.bianhao;
            break;
        } else {
            other.push(crt);
        }
    }
}
```

### 最优关键思路与技巧

1. **分治思想**：将问题分解为多个独立的子问题，每个子问题仅处理同花色的牌，简化了问题复杂度。
2. **贪心策略**：通过排序和双指针技术，确保每次匹配都是最优的。
3. **数据结构优化**：使用优先队列和堆结构，确保每次匹配都是最优的。

### 可拓展之处

- **类似题目**：可以尝试解决其他基于贪心算法的匹配问题，如田忌赛马、任务调度等。
- **算法优化**：可以进一步优化数据结构，如使用更高效的堆结构或平衡树来加速匹配过程。

### 推荐题目

1. **P1650 田忌赛马**：考察贪心算法在匹配问题中的应用。
2. **P1090 合并果子**：考察优先队列在贪心算法中的应用。
3. **P1223 排队接水**：考察贪心算法在任务调度中的应用。

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中发现了一些边界情况，如小D的牌比小C多或少的情况，这些经验帮助他们更好地优化了代码。
- **踩坑教训**：部分作者提到在处理不同花色的牌时，忽略了某些特殊情况，导致代码出错，这些教训帮助他们更好地理解了问题的复杂性。
- **顿悟感想**：部分作者提到在处理匹配问题时，突然意识到可以通过排序和双指针技术来优化匹配过程，这一顿悟帮助他们更好地解决了问题。

---
处理用时：50.92秒
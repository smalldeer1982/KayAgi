# 题目信息

# 「MCOI-03」村国

## 题目背景

$\texttt{What did this player dream?}$

他梦见了什么？

$\texttt{This player dreamed of sunlight and trees.Of fire and water.}$

他梦见了阳光与树木。梦见了火与水。

$\texttt{It dreamed it created. And it dreamed it destroyed. It dreamed it hunted,}$ 
$\texttt{and was hunted. It dreamed of shelter.}$

他梦见他的创造，亦梦见他毁灭。它梦见他在狩猎，亦梦见被猎捕。他梦见温馨的居所。

$\texttt{Hah, the original interface. A million years old, and it still works.But}$ 
$\texttt{ what true structure did this player create, in the reality behind the screen?}$

哎，那原始的界面。经历百万年的岁月，它依然在工作。只是他在屏幕后的真实里，到底创造了什么真实的世界呢？

## 题目描述

C 国一共有 $N$ 个村庄，$N-1$ 条道路。这些道路都可以双向通行。保证小 S 可以从一座村庄到其他任何一座村庄。这 $N$ 个村庄编号为 $1$ 到 $N$。

刚开始小 S 对第 $i$ 个村庄的好感值为 $A_i$。小 S 的假期一共有 $M$ 天，他会在 C 国旅行一共 $M$ 天。每一天他会选择来到当前好感值最高的村庄。如果有好感值相同的村庄，他会选择编号最小的村庄。假设这一天他来到村庄 $X$，那么这一天结束后，与村庄 $X$ 直接相邻所有村庄的好感值都会增加 $1$。即能从 $X$ 出发仅经过一条道路到达的村庄好感值会增加 $1$。因为小 S 已经在村庄 $X$ 待过一天了，所以这一天结束后村庄 $X$ 的好感值并不会增加。

现在小 S 想要知道经过 $M$ 天的旅行后好感值最高的村庄。

如果有多个好感值最高的村庄，输出编号最小的。

## 说明/提示

#### 样例说明

对于第一组数据，小 S 在 $2$ 号村庄旅行了 $3$ 天，结束时村庄 $1,2$ 的好感值分别为 $5,6$。所以答案输出 $2$。

对于第二组数据，结束时三个村庄的好感值分别为 $3,7,8$，所以答案输出 $3$。

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \le N\le 2\times10^6$，$1 \le M\le10^{18}$，$1 \le A_i\le2^{31}-1$，$1 \le T\le10$。

| 测试点编号 | $A_i\le$ | $\sum N \le$ | $M \le $ | 测试点分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $\rm 1$ | $10$ | $20$ | $10$ | $5$ |
| $\rm 2$ | $10^2$ | $2 \times 10^2$ | $10^2$ | $10$ |
| $\rm 3$ | $10^3$ | $2 \times 10^3$ | $10^3$ | $15$ |
| $\rm 4$ | $10^5$ | $2 \times 10^5$ | $10^5$ | $25$ |
| $\rm 5$ |  | $2 \times 10^6$ |  | $45$ |

#### 提示

**本题输入量较大，请使用较快的读入方式。**

## 样例 #1

### 输入

```
2
2 3
2 6
1 2
3 5
2 6 4
1 3
2 3```

### 输出

```
2
3```

# AI分析结果

### 综合分析与结论

本题的核心在于通过观察和模拟发现规律，避免直接暴力模拟带来的高时间复杂度。大多数题解都基于以下关键思路：

1. **规律发现**：通过模拟发现，最终好感度最高的村庄只会在初始好感度最高的村庄（记为 `A`）和与 `A` 直接相连的好感度最高的村庄（记为 `B`）之间交替变化。
2. **数学优化**：通过计算 `A` 和 `B` 的好感度差值，结合剩余天数 `m` 的奇偶性，直接得出最终结果，避免了复杂的模拟过程。
3. **特判处理**：特别处理 `n=1` 的情况，避免程序出错。

### 所选高星题解

#### 题解1：作者：_zy_ (赞：22)
- **星级**：5星
- **关键亮点**：
  - 思路清晰，详细解释了规律发现的逻辑。
  - 代码简洁，逻辑严密，处理了多种边界情况。
  - 提供了完整的代码实现，易于理解。
- **个人心得**：作者通过手玩样例发现了规律，并强调了特判的重要性，避免了调试时的常见错误。

```cpp
int main() {
    t = read();
    while (t--) {
        Clear();
        n = read(); m = read();
        int maxx = 0, now = 0;
        for (int i = 1; i <= n; i++) {
            a[i] = read();
            if (a[i] > maxx) {
                maxx = a[i];
                now = i;
            }
        }
        int maxn = 0, k = 0;
        for (int i = fir[now]; i; i = nex[i]) {
            int p = poi[i];
            if (a[p] > maxn || (a[p] == maxn && p < k)) {
                maxn = a[p];
                k = p;
            }
        }
        if (k == 0) {
            printf("%lld\n", now);
            continue;
        }
        int dat = maxx - maxn;
        if (dat > m) {
            printf("%lld\n", now);
            continue;
        }
        if (dat == m) {
            printf("%lld\n", min(now, k));
            continue;
        }
        if ((m - dat) & 1) {
            printf("%lld\n", max(now, k));
        } else {
            printf("%lld\n", min(now, k));
        }
    }
    return 0;
}
```

#### 题解2：作者：Eason_AC (赞：16)
- **星级**：4.5星
- **关键亮点**：
  - 通过详细的样例模拟，帮助读者理解规律。
  - 代码结构清晰，逻辑严谨，处理了多种情况。
  - 提供了对 `n=1` 的特判处理。
- **个人心得**：作者通过模拟样例发现了规律，并强调了特判的重要性，避免了调试时的常见错误。

```cpp
int main() {
    scanf("%d", &t);
    while (t--) {
        memset(num, 0, sizeof(num));
        int ans = 0;
        scanf("%d%lld", &n, &m);
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &a[i]);
            if ((a[i] > a[ans]) || (a[i] == a[ans] && ans > i)) ans = i;
        }
        for (int i = 1; i < n; ++i) {
            int x, y;
            scanf("%d%d", &x, &y);
            if (x == ans) num[++num[0]] = y;
            else if (y == ans) num[++num[0]] = x;
        }
        if (!num[0]) { printf("%d\n", ans); continue; }
        int kk = 1;
        for (int i = 1; i <= num[0]; ++i)
            if (a[num[i]] > a[num[kk]]) kk = i;
        if (a[ans] - a[num[kk]] > m) printf("%d\n", ans);
        else if ((m - (a[ans] - a[num[kk]])) % 2) printf("%d\n", max(num[kk], ans));
        else printf("%d\n", min(num[kk], ans));
    }
    return 0;
}
```

#### 题解3：作者：hellhell (赞：5)
- **星级**：4星
- **关键亮点**：
  - 通过观察数据范围，提出了规律发现的思路。
  - 代码简洁，逻辑清晰，处理了多种边界情况。
  - 提供了对 `n=1` 的特判处理。
- **个人心得**：作者通过观察数据范围发现了规律，并强调了特判的重要性，避免了调试时的常见错误。

```cpp
int main() {
    cin >> t;
    while (t--) {
        Max = -1; mmax = -1; id = 0; iid = 0; cnt = 0;
        memset(val, 0, sizeof(val)); memset(head, 0, sizeof(head));
        n = read(); m = read();
        for (int i = 1; i <= n; i++) {
            val[i] = read();
            if (val[i] > Max) { Max = val[i]; id = i; }
        }
        if (n == 1) { cout << 1 << endl; continue; }
        for (int i = head[id]; i; i = edge[i].next) {
            int v = edge[i].to;
            if (val[v] > mmax || (val[v] == mmax && v < iid)) { mmax = val[v]; iid = v; }
        }
        int dis = Max - mmax;
        if (dis > m) { cout << id << endl; continue; }
        else {
            int diss = m - dis;
            if (diss % 2 == 0) {
                if (id < iid) { cout << id << endl; continue; }
                if (iid < id) { cout << iid << endl; continue; }
            }
            if (diss % 2 != 0) {
                if (iid < id) { cout << id << endl; continue; }
                else { cout << iid << endl; continue; }
            }
        }
    }
    return 0;
}
```

### 最优关键思路与技巧

1. **规律发现**：通过模拟发现，最终好感度最高的村庄只会在初始好感度最高的村庄和与其直接相连的好感度最高的村庄之间交替变化。
2. **数学优化**：通过计算两个村庄的好感度差值，结合剩余天数的奇偶性，直接得出最终结果，避免了复杂的模拟过程。
3. **特判处理**：特别处理 `n=1` 的情况，避免程序出错。

### 可拓展之处

- **类似题目**：这类题目通常需要通过观察和模拟发现规律，避免直接暴力模拟。类似的题目包括：
  - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
  - [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
  - [P3378 堆](https://www.luogu.com.cn/problem/P3378)

### 推荐题目

1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3378 堆](https://www.luogu.com.cn/problem/P3378)

### 个人心得总结

- **调试经历**：特判 `n=1` 的情况是调试时的常见错误，需要特别注意。
- **顿悟感想**：通过模拟样例发现规律，可以大大简化问题，避免复杂的模拟过程。

---
处理用时：62.43秒
# 题目信息

# 「EZEC-5」人赢

## 题目背景

> “我们在 小 Z 面前秀个恩爱吧。”\
>“好的。”

小 Z 发现他身边都是人赢，这使他非常自闭。

小 Z 又看着身边的潇，不禁陷入了沉思……

![](https://cdn.luogu.com.cn/upload/image_hosting/b1ij58kc.png)

## 题目描述

潇有一个数组 $k$，下标为 $1$ 到 $n$ 。

潇定义 $f(x,y)=\begin{cases} \min(k_x,k_y) \times (x + y) &x \ne y \\ k_x\times x&x=y \end{cases}$ 。

潇想知道对于任意的 $1 \le x,y \le n$，$f(x,y)$ 的最大值是多少。但是她不会做，于是就问了善良的 小 Z，然而非常想在妹子面前表现的 小 Z 发现他也不会做，就只能够求助善良的你了。

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

- Subtask 1（20 points）：$1 \le n \le 5000$。

- Subtask 2（10 points）：保证所有 $k_{i}$ 都相等。

- Subtask 3（20 points）：$k_i \le 10^3$。

- Subtask 4（50 points）：无特殊性质。

对于 $100\%$ 的数据，$1 \le n \le 10^6$，$1 \le k_{i} \le 10^9$。

------------

本题加强版：[link](https://www.luogu.com.cn/problem/P7291)。

## 样例 #1

### 输入

```
3
3 2 1```

### 输出

```
6```

## 样例 #2

### 输入

```
5
3 4 5 4 3```

### 输出

```
28```

# AI分析结果

### 综合分析与结论

本题的核心在于高效计算 $f(x,y)$ 的最大值，涉及到的难点主要是如何在 $O(n)$ 或 $O(n \log n)$ 的时间复杂度内处理大规模的输入数据。大多数题解都采用了排序+贪心的策略，通过排序后维护前缀最大值或使用单调栈来优化计算过程。其中，单调栈的解法在时间复杂度和代码实现上表现尤为出色，适合处理大规模数据。

### 所选高星题解

#### 1. 作者：灵乌路空 (5星)
**关键亮点：**
- 使用了单调栈来维护可能的 $x$ 值，确保每次计算都能找到最优的 $y$。
- 代码简洁高效，时间复杂度为 $O(n)$，适合处理大规模数据。
- 详细解释了单调栈的使用场景和优势，思路清晰。

**个人心得：**
- 通过单调栈的维护，避免了复杂的排序和遍历，大大减少了计算量。

**核心代码：**
```cpp
int main() {
  n = read();
  for (int i = 1; i <= n; ++ i) {
    a[i] = read();
    Chkmax(ans, 1ll * i * a[i]);
    while (top && a[st[top]] <= a[i]) {
      Chkmax(ans, 1ll * a[st[top]] * (st[top] + i));
      -- top;
    }
    if (top) Chkmax(ans, 1ll * a[i] * (st[top] + i));
    st[++ top] = i;
  }
  printf("%lld\n", ans);
  return 0;
}
```
**核心思想：**
- 使用单调栈维护可能的 $x$ 值，确保每次计算都能找到最优的 $y$。

#### 2. 作者：wsyhb (4星)
**关键亮点：**
- 通过排序后维护前缀最大值，简化了计算过程。
- 代码实现清晰，时间复杂度为 $O(n \log n)$，适合一般规模的数据。

**核心代码：**
```cpp
for(int i=1;i<=n;++i)
{
    ans=max(ans,1ll*k[id[i]]*(id[i]+Max));
    Max=max(Max,id[i]);
}
```
**核心思想：**
- 按 $k$ 值从大到小排序后，维护前缀最大值，确保每次计算都能找到最优的 $y$。

#### 3. 作者：囧仙 (4星)
**关键亮点：**
- 提供了多种解法，包括排序和单调栈，适合不同场景的需求。
- 详细解释了每种解法的优缺点，思路清晰。

**核心代码：**
```cpp
up(1,n,i){
    while(s&&S[s][1]<=A[i]){
        ans=max(ans,1ll*(S[s][0]+i)*S[s][1]),--s;
    }
    if(s) ans=max(ans,1ll*(S[s][0]+i)*A[i]);
    S[++s][0]=i,S[s][1]=A[i];
}
```
**核心思想：**
- 使用单调栈维护可能的 $x$ 值，确保每次计算都能找到最优的 $y$。

### 最优关键思路与技巧

- **单调栈的使用**：通过维护一个单调栈，可以高效地找到满足条件的最优 $y$，避免了复杂的排序和遍历。
- **排序+贪心**：通过排序后维护前缀最大值，简化了计算过程，适合一般规模的数据。

### 可拓展之处

- **类似算法套路**：单调栈在处理类似问题时非常有用，如寻找下一个更大元素、最大矩形面积等问题。
- **同类型题**：可以尝试解决其他需要高效查找最优解的问题，如最大子数组和、最长递增子序列等。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
3. [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)

### 个人心得总结

- **调试经历**：在处理大规模数据时，单调栈的使用可以大大减少计算量，避免超时。
- **踩坑教训**：在排序后维护前缀最大值时，需要注意更新顺序，避免错误。
- **顿悟感想**：通过单调栈的维护，可以高效地找到最优解，减少不必要的计算。

---
处理用时：34.00秒
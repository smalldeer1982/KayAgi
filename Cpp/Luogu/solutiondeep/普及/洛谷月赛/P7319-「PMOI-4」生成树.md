# 题目信息

# 「PMOI-4」生成树

## 题目背景

> 题目正解不会很难，反正很难的也必不会做，所以宁愿相信题目都是善良的。

——command_block 《考前小贴士》

djy 出了一道生成树的题，然后发现做法假了，就把这个题改了一下，作为这场比赛的 B。

## 题目描述

给定 $n$ 个数，第 $i$ 个数的原始权值是 $w_i$，你要按照某种顺序将这些数依次选择。

若当前是第 $i$ 次选数，选择的**原始权值**为 $k$，则其他所有**未被选过**的数的权值均加上 $(-1)^{i+k+1} \times k$。

你需要求出一种选数方案，使得选出的 $n$ 个数**最终**的**权值**和**最大**。

## 说明/提示

【样例解释】

依次选择**编号**为 $\{7,6,5,3,4,1,2\}$ 的数即可。

【数据范围】

**本题采用捆绑测试**。

- Subtask 1（20pts）：$n \le 7$。
- Subtask 2（30pts）：$n \le  10^3$。
- Subtask 3（30pts）：保证所有的 $w_i \ge 0$ 或所有的 $w_i \le 0$。
- Subtask 4（20pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1 \le n \le 10^5,-10^9 \le w \le 10^9$。

## 样例 #1

### 输入

```
7
1 -1 -2 2 -3 3 4```

### 输出

```
66```

# AI分析结果

### 综合分析与结论

本题的核心在于通过贪心策略和排序不等式来最大化选数的最终权值和。大多数题解都围绕如何将数的贡献最大化展开，通过分类讨论、排序、以及动态调整选择顺序来实现目标。其中，**排序不等式**的应用是一个关键点，它帮助简化了问题的复杂度，使得问题可以通过简单的排序和匹配来解决。

### 所选高星题解

#### 1. **作者：lgswdn_SA (5星)**
- **关键亮点**：思路简洁，代码清晰，直接应用排序不等式，避免了复杂的分类讨论。
- **核心实现思想**：将问题转化为两个数组的匹配问题，通过排序不等式直接求解最大值。
- **代码片段**：
  ```cpp
  int n,ans;
  vector<int>f,g;
  signed main() {
      n=read(); f.resize(n), g.resize(n);
      rep(i,1,n) {
          int w=read(); ans+=w;
          w=w*(w%2?-1:1); f[i-1]=w;
          if((i+1)%2) g[i-1]=-(n-i);
          else g[i-1]=n-i;
      }
      sort(f.begin(),f.end()), sort(g.begin(),g.end());
      rep(i,0,n-1) ans+=f[i]*g[i];
      printf("%lld\n",ans);
      return 0;
  }
  ```

#### 2. **作者：Acc_Robin (4.5星)**
- **关键亮点**：思路清晰，代码简洁，直接应用排序不等式，避免了复杂的分类讨论。
- **核心实现思想**：将问题转化为两个序列的匹配问题，通过排序不等式直接求解最大值。
- **代码片段**：
  ```cpp
  namespace Acc{
      using ll=long long;
      const int N=1e5+9;
      int a[N],b[N];
      ll r;
      void work(){
          int n,i,sav=1;
          for(cin>>n,i=1;i<=n;++i)cin>>a[i],r+=a[i],a[i]=a[i]*(abs(a[i]%2)==1?1:-1);
          for(sav=-1,i=1;i<=n;++i,sav=-sav)b[i]=(n-i)*sav;
          sort(a+1,a+n+1),sort(b+1,b+n+1);
          for(i=1;i<=n;++i)r+=1ll*a[i]*b[i];
          cout<<r<<'\n';
      }
  }
  ```

#### 3. **作者：张晟轩 (4星)**
- **关键亮点**：思路清晰，直接应用排序不等式，代码简洁。
- **核心实现思想**：将问题转化为两个序列的匹配问题，通过排序不等式直接求解最大值。
- **代码片段**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int n,a[100005],b[100005];
  long long ans;
  int main(){
      scanf("%d",&n);
      for(int i=1;i<=n;++i){
          scanf("%lld",&a[i]);ans+=a[i];
          a[i]*=(a[i]%2==0)?1:-1;
          b[i]=(n-i)*((i+1)%2==0?1:-1);
      }
      sort(a+1,a+n+1);
      sort(b+1,b+1+n);
      for(int i=1;i<=n;++i) ans+=1ll*a[i]*b[i];
      printf("%lld\n",ans);
      return 0;
  }
  ```

### 最优关键思路与技巧
1. **排序不等式的应用**：将问题转化为两个序列的匹配问题，通过排序不等式直接求解最大值。
2. **贪心策略**：通过分类讨论和排序，确保每次选择的数对最终结果的贡献最大。
3. **代码简洁性**：通过合理的变量命名和结构设计，使得代码易于理解和维护。

### 可拓展之处
- **类似算法套路**：在需要最大化或最小化某种组合结果的问题中，排序不等式和贪心策略是常用的工具。
- **同类型题目**：可以考虑类似的贪心问题，如任务调度、资源分配等。

### 推荐题目
1. **P1090 [NOIP2004 提高组] 合并果子**：考察贪心策略和优先队列的应用。
2. **P1223 排队接水**：考察贪心策略和排序的应用。
3. **P1803 凌乱的yyy / 线段覆盖**：考察贪心策略和区间排序的应用。

### 个人心得摘录
- **调试经历**：在实现过程中，确保排序的顺序和匹配的正确性是关键，调试时可以通过打印中间结果来验证。
- **踩坑教训**：在处理奇偶性时，容易忽略边界情况，如所有数都是奇数或偶数时，需要特殊处理。
- **顿悟感想**：通过将问题转化为数学上的排序不等式，可以大大简化问题的复杂度，提高解题效率。

---
处理用时：45.96秒
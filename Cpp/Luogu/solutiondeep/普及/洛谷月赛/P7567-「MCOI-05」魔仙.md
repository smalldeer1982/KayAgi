# 题目信息

# 「MCOI-05」魔仙

## 题目背景

你是魔仙堡里的占星魔仙。

## 题目描述

魔仙女王的宝石被古娜拉黑暗之神偷走了！古娜拉黑暗之神藏在魔仙堡的 $n$ 个穹顶中的任意一个里面，这 $n$ 个穹顶编号为 $1 \sim n$，第 $i$ 个穹顶可以将其赋予 $a_i$ 的魔力，$a_i$ 必须是整数。

如果所有穹顶的魔力之和为 $0$，之积为 $n$，那么我们称这种情况是可以轻易搜索出古娜拉黑暗之神的。

魔仙女王让占星魔仙求一种赋予魔力的情况使得是可以轻易搜索出古娜拉黑暗之神的。

## 说明/提示

#### 样例 1 解释

$1 +(-1)+2+(-2)=0$，$1 \times (-1) \times 2 \times (-2)=4$。

#### 数据规模与约定

**本题采用捆绑测试。**

 - Subtask 1（5 pts）：$n\le 1$
 - Subtask 2（20 pts）：$n,\sum n\le 100$
 - Subtask 3（75 pts）：没有特殊限制。

对于 $100\%$ 的数据，$1 \le n\le10^6$，$\sum n\le 5\times10^6$，$1\le T\le10^5$。

**本题采用 Special Judge**，你只需要输出其中一种序列。

## 样例 #1

### 输入

```
2
4
114513```

### 输出

```
1 -1 2 -2
w33zAKIOI```

## 样例 #2

### 输入

```
1
1```

### 输出

```
w33zAKIOI```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个长度为 \( n \) 的整数序列，使得序列的和为 0，积为 \( n \)。通过分析，可以发现只有当 \( n \) 是 4 的倍数时，才存在满足条件的序列。大多数题解都围绕这一结论展开，并通过分类讨论（如 \( n \) 是否为 8 的倍数）来构造具体的序列。

### 所选高星题解

#### 1. **题解作者：FuriousC (5星)**
   - **关键亮点**：
     - 通过严格的数学证明，详细推导了 \( n \) 必须是 4 的倍数的条件。
     - 提供了清晰的构造方案，分别针对 \( k \) 为奇数和偶数的情况进行了讨论。
     - 代码简洁且高效，直接根据 \( n \) 的值进行输出，避免了不必要的计算。
   - **个人心得**：
     - 作者提到在比赛中推导了 30 分钟才发现是原题，强调了比赛中的经验积累和快速反应的重要性。
   - **核心代码**：
     ```cpp
     if (n % 4 == 0) {
         int k = n / 4;
         if (k % 2 == 1) {
             printf("2 -%d ", k * 2);
             for (int i = 1; i <= 3 * k - 2; i++) printf("1 ");
             for (int i = 1; i <= k; i++) printf("-1 ");
         } else {
             printf("-2 -%d ", k * 2);
             for (int i = 1; i <= 3 * k; i++) printf("1 ");
             for (int i = 1; i <= k - 2; i++) printf("-1 ");
         }
         printf("\n");
     } else {
         printf("w33zAKIOI\n");
     }
     ```

#### 2. **题解作者：Legitimity (4.5星)**
   - **关键亮点**：
     - 通过简单的数学推导，快速得出了 \( n \) 必须是 4 的倍数的结论。
     - 构造方案简洁明了，直接根据 \( k \) 的奇偶性进行分类处理。
     - 代码实现清晰，逻辑严谨，适合初学者理解。
   - **核心代码**：
     ```cpp
     if (n % 4) puts("w33zAKIOI");
     else {
         int p = n / 4;
         if (p & 1) {
             printf("%d %d ", 2, -2 * p);
             for (int i = 1; i <= 3 * p - 2; i++) putchar('1'), putchar(' ');
             for (int i = 1; i <= p; i++) putchar('-'), putchar('1'), putchar(' ');
         } else {
             printf("%d %d ", -2, -2 * p);
             for (int i = 1; i <= 3 * p; i++) putchar('1'), putchar(' ');
             for (int i = 1; i <= p - 2; i++) putchar('-'), putchar('1'), putchar(' ');
         }
         putchar('\n');
     }
     ```

#### 3. **题解作者：Sparkle_ZH (4星)**
   - **关键亮点**：
     - 通过简单的数学推导，得出了 \( n \) 必须是 4 的倍数的结论。
     - 构造方案清晰，分别针对 \( q \) 为奇数和偶数的情况进行了讨论。
     - 代码实现简洁，逻辑清晰，适合快速理解。
   - **核心代码**：
     ```cpp
     if (n % 4 != 0) {
         printf("w33zAKIOI\n");
     } else {
         k = n / 4;
         if (k & 1) {
             printf("2 -%d ", k * 2);
             for (int i = 1; i <= 3 * k - 2; i++) printf("1 ");
             for (int i = 1; i <= k; i++) printf("-1 ");
         } else {
             printf("-2 -%d ", k * 2);
             for (int i = 1; i <= 3 * k; i++) printf("1 ");
             for (int i = 1; i <= k - 2; i++) printf("-1 ");
         }
         printf("\n");
     }
     ```

### 最优关键思路或技巧

1. **数学推导**：通过奇偶性分析，得出 \( n \) 必须是 4 的倍数的结论，这是解题的关键。
2. **分类讨论**：根据 \( n \) 是否为 8 的倍数，进一步细化了构造方案，确保了序列的正确性。
3. **构造技巧**：利用 1 和 -1 来调整序列的和，同时保证积不变，这是一种常见的构造技巧。

### 可拓展之处

- **类似问题**：类似的问题可以通过数学推导和分类讨论来解决，尤其是在构造序列时，利用 1 和 -1 来调整和与积。
- **算法套路**：在构造类问题中，数学推导和分类讨论是常见的解题思路，尤其是在涉及和与积的约束时。

### 推荐相似题目

1. **P1734 最大约数和**：考察如何通过构造序列来满足特定条件。
2. **P1062 数列**：涉及数列的构造与数学推导。
3. **P1029 最大公约数和最小公倍数问题**：考察数学推导与构造技巧。

### 个人心得总结

- **调试经历**：多位作者提到在比赛中推导了较长时间才发现是原题，强调了比赛中的经验积累和快速反应的重要性。
- **踩坑教训**：在构造序列时，需要注意和与积的约束条件，避免遗漏某些特殊情况。
- **顿悟感想**：通过数学推导和分类讨论，可以快速找到问题的解决方案，尤其是在构造类问题中。

---
处理用时：47.65秒
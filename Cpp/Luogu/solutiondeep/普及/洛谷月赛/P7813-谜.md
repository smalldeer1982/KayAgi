# 题目信息

# 谜

## 题目背景

$\text{我需要你给我方向}$

$\text{哪怕要我独自穿过人海茫茫}$

$\text{为了你尝风霜}$

$\text{我流浪远方}$

$\text{需要你给我力量}$

$\text{无论如何我会坚强}$

$\text{只要你给我希望}$

[Source](https://www.kugou.com/song-36/1y5t3b.html)

## 题目描述

在一个大小为 $N$ 的数字三角形中：

- 第 $1$ 行为 $1$；
- 第 $2$ 行为 $2\sim3$；
- 第 $3$ 行为 $4\sim6$；
- 第 $4$ 行为 $7\sim10$；
- $\cdots~\cdots$
- 第 $N$ 行包含 $N$ 个数字，为 $\frac{N(N-1)}{2}+1\sim\frac{N(N+1)}{2}$。

下图展示了一个 $N=5$ 的数字三角形。

![](https://cdn.luogu.com.cn/upload/image_hosting/fpx5rw7l.png)

---

记 $(i,j)$ 表示第 $i$ 行第 $j$ 个数字。

已知 $(i,j)$ 能直接到达 $(i+1,j)$ 或 $(i+1,j+1)$，反之，$(i+1,j)$ 或 $(i+1,j+1)$ 也能直接到达 $(i,j)$。

现在任选一个数字作为起点，求 **连续** 地经过 $K$ 个 **不同** 的数字时，这 $K$ 个数的和的最大值，对 $10^9+7$ 取模。

## 说明/提示

#### 样例说明

对于样例 #1，如题面中的图所示，一种可行的方案是：以 $13$ 为起点，$13\rightarrow9\rightarrow14\rightarrow10\rightarrow15$，和为 $13+9+14+10+15=61$。

### 数据范围

**本题采用捆绑测试。**

| Subtask | 分值 | $N\le$ | $K\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $30$ | $10^3$  |  |
| $2$ | $30$ | $10^6$ |  |
| $3$ | $30$ | $10^9$ | $1$ |
| $4$ | $10$ | $10^9$ |  |

对于 $100\%$ 的数据：$1\le T\le 10^5$，$1\le\color{red}\dfrac{K+1}{2}\le N\color{black}\le10^9$。

## 样例 #1

### 输入

```
1
5 5```

### 输出

```
61```

## 样例 #2

### 输入

```
5
2676 1930
5148 3667
5453 4764
16734806 16332913
26943973 33293903 ```

### 输出

```
909411538
587883333
823595806
727601062
965648555```

# AI分析结果

### 综合分析与结论

本题的核心在于通过贪心策略，从数字三角形的右下角开始，交替向上和向下遍历，以最大化连续K个不同数字的和。由于数据范围较大（N≤10^9），直接模拟遍历不可行，因此需要利用数学公式进行优化。大多数题解都采用了等差数列求和公式，并结合K的奇偶性进行分类讨论。部分题解还引入了逆元来处理模运算中的除法问题。

### 所选高星题解

#### 1. **作者：int32 (5星)**
- **关键亮点**：思路清晰，详细推导了K为奇数和偶数时的求和公式，并给出了优化后的数学表达式。代码简洁，直接应用公式计算结果。
- **个人心得**：通过数据范围提示，快速锁定解题方向，避免了复杂的模拟过程。
- **核心代码**：
  ```cpp
  int n, k;
  cin >> n >> k;
  ll a = n * (n + 1) / 2, b = a - n;
  if (k % 2 == 0) {
      ll v = k * (2 * a + 2 * b - k + 2) / 4;
      cout << v % MOD << endl;
  } else {
      ll v = k * (2 * a + 2 * b - k + 2) / 4;
      cout << (v + n - k / 2) % MOD << endl;
  }
  ```

#### 2. **作者：言琢დ (4星)**
- **关键亮点**：提供了详细的证明，解释了为什么从右下角开始遍历是最优的。代码实现中使用了分步取模，避免了溢出问题。
- **个人心得**：通过反证法证明了贪心策略的正确性，增强了题解的可信度。
- **核心代码**：
  ```cpp
  ll ans = 0;
  if (k % 2 == 0) {
      ans = ((n * (n + 1) - k / 2 + 1) * (k / 2) / 2) % MOD;
      ans += ((n * (n - 1) - k / 2 + 1) * (k / 2) / 2) % MOD;
  } else {
      ans = ((n * (n + 1) - (k + 1) / 2 + 1) * ((k + 1) / 2) / 2) % MOD;
      ans += ((n * (n - 1) - k / 2 + 1) * (k / 2) / 2) % MOD;
  }
  cout << ans % MOD << endl;
  ```

#### 3. **作者：Eason_AC (4星)**
- **关键亮点**：代码简洁，直接应用等差数列求和公式，并处理了K的奇偶性。使用了逆元来处理模运算中的除法问题。
- **个人心得**：通过样例说明，快速锁定解题思路，避免了复杂的推导过程。
- **核心代码**：
  ```cpp
  ll ans1 = (start - k / 2 + 1 + start + MOD) % MOD * (k / 2) % MOD * ksm(2) % MOD;
  ll ans2 = (start2 - k / 2 + 1 + start2 + MOD) % MOD * (k / 2) % MOD * ksm(2) % MOD;
  cout << (ans1 + ans2) % MOD << endl;
  ```

### 最优关键思路与技巧
1. **贪心策略**：从右下角开始，交替向上和向下遍历，确保每次选择的数字尽可能大。
2. **数学优化**：利用等差数列求和公式，避免直接模拟遍历，提高计算效率。
3. **模运算处理**：使用逆元处理模运算中的除法问题，确保计算结果正确。

### 拓展思路与类似题目
1. **类似题目**：
   - [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)
   - [P1434 滑雪](https://www.luogu.com.cn/problem/P1434)
   - [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)

2. **拓展思路**：在处理大规模数据时，优先考虑数学公式优化，避免直接模拟。同时，掌握模运算中的逆元应用，可以有效解决除法取模问题。

---
处理用时：35.36秒
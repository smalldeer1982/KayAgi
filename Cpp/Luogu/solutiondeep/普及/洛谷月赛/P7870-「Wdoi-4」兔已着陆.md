# 题目信息

# 「Wdoi-4」兔已着陆

## 题目背景

铃瑚和清兰是从月之都到达幻想乡的两只月兔。正因为降落到了幻想乡进行调查，因此她们通过开团子屋制作团子出售的方式，在幻想乡生活。

为了应对越发繁荣的市场，她们向河城荷取购置了一台团子机器，可以高效地生产出五颜六色的团子。不同颜色的团子的售价不尽相同。由于每天顾客数量很多，购买的团子数量也不少，所以清兰总是搞不清楚一大堆团子的售价如何。

清兰找到了你，希望你能告诉她每次售出团子时，这些团子的总价格。

## 题目描述

清兰使用河童的机器可以生产出各种各样颜色的团子。她发现，**对于颜色为** $\bm c$ **的团子，它的售价为** $\bm c$。同时，团子机器有个特性，那就是生产出来的团子的颜色必然是一段连续的整数。

为了储存已经生产出来的团子，清兰使用了一种类似于「栈」的结构。在一天的开始，这个栈为空栈。现在有 $n$ 次操作，分为两种：

1. $\colorbox{f0f0f0}{\verb!1 l r!}$ ：团子机器生产出来了颜色为 $l,l+1,\cdots r-1,r$ 的团子。清兰将这些团子**依次**入栈。也就是在栈顶依次加入 $l,l+1,l+2,\cdots r-1,r$ 。
2. $\colorbox{f0f0f0}{\verb!2 k!}$ ：有一位客人想要购买 $k$ 个团子。此时清兰会**依次**从栈顶取出 $k$ 个团子并售出。保证 $k$ 不大于当前栈内的团子个数。

你要做的，就是对于每个操作 $2$ 输出这些团子的总价格。

## 说明/提示

样例 $2$ 见下发的附件 $\textbf{\textit{stack2.in}/\textit{stack2.out}}$。

---

### 数据范围

- 对于前 $30\%$ 的数据，$n,l,r\le100$。
- 对于另外 $20\%$ 的数据，$l=r$。
- 对于另外 $20\%$ 的数据，$k\le 10$。
- 对于 $100\%$ 的数据，$1\le n\le 5\times 10^5$，$0\le l\le r \le 10^6$，$1\le k \le 10^{12}$。

## 样例 #1

### 输入

```
6
1 1 14
2 5
1 14 19
1 1 9
2 8
2 10```

### 输出

```
60
44
124
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效处理栈操作，尤其是当栈中存储的是连续整数区间时。直接模拟每个元素的入栈和出栈操作会导致时间复杂度过高，无法通过大数据量的测试。因此，优化思路主要集中在如何利用区间特性，减少不必要的操作。

大多数题解都采用了将连续区间打包存储的思路，利用等差数列求和公式快速计算区间和，从而避免了逐个元素的处理。这种思路显著降低了时间复杂度，能够高效处理大规模数据。

### 所选高星题解

#### 1. 作者：囧仙 (5星)
- **关键亮点**：使用二元组表示连续区间，直接利用等差数列求和公式计算区间和，简洁高效。
- **代码实现**：
  ```cpp
  while(k){
      int l=P[p].first,r=P[p].second,t=r-l+1;
      if(t<=k) ans+=1ll*t*(l+r)/2,k-=t,--p;
      else {
          ans+=1ll*k*(r-k+1+r)/2;
          P[p]=make_pair(l,r-k),k=0;
      }
  }
  ```
  **核心思想**：通过判断区间长度与k的关系，决定是否弹出整个区间或部分区间，并利用等差数列求和公式快速计算。

#### 2. 作者：Gokix (4星)
- **关键亮点**：将连续区间打包存储，利用等差数列求和公式快速计算，思路清晰，代码简洁。
- **代码实现**：
  ```cpp
  while(u>=gx.r-gx.l+1){
      u-=(gx.r-gx.l+1);
      ans+=(gx.l+gx.r)*(gx.r-gx.l+1)/2;
      s.pop();
  }
  ```
  **核心思想**：通过不断弹出完整的区间，直到剩余的k不足以弹出整个区间，再处理部分区间。

#### 3. 作者：bmatrix (4星)
- **关键亮点**：使用结构体存储区间，并封装了区间的求和操作，代码结构清晰，易于理解。
- **代码实现**：
  ```cpp
  ll get(ll k){
      ll res=0;
      while(k>=_top->len()){
          res+=_top->getall();
          k-=_top->len();
          _top--;
      }
      res+=_top->get(k);
      return res;
  }
  ```
  **核心思想**：通过封装区间的求和操作，简化了代码逻辑，提高了代码的可读性。

### 最优关键思路与技巧

1. **区间打包存储**：将连续的整数区间打包存储，避免逐个元素处理，显著降低时间复杂度。
2. **等差数列求和公式**：利用等差数列求和公式快速计算区间和，避免逐个累加。
3. **栈操作优化**：通过判断区间长度与k的关系，决定是否弹出整个区间或部分区间，减少不必要的操作。

### 可拓展之处

- **类似问题**：在处理栈或队列时，如果元素具有某种规律性（如连续整数、等差数列等），可以考虑将元素打包存储，利用数学公式快速计算，从而优化时间复杂度。
- **算法套路**：在处理大规模数据时，尽量利用数据的规律性，减少不必要的操作，是常见的优化思路。

### 推荐题目

1. **P1886 滑动窗口**：考察滑动窗口的维护，与本题的区间处理有相似之处。
2. **P3372 线段树 1**：考察线段树的区间操作，与本题的区间求和有相似之处。
3. **P1047 校门外的树**：考察区间的合并与处理，与本题的区间打包存储有相似之处。

### 个人心得摘录

- **调试经历**：在处理部分区间时，容易忽略区间长度的更新，导致计算结果错误。需要仔细检查区间的更新逻辑。
- **踩坑教训**：在处理大规模数据时，直接模拟逐个元素的操作会导致时间复杂度过高，必须寻找优化思路。
- **顿悟感想**：利用数据的规律性，将连续区间打包存储，可以显著提高算法的效率。

---
处理用时：36.35秒
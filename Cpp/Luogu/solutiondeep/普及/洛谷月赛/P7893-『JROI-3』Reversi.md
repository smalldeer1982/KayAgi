# 题目信息

# 『JROI-3』Reversi

## 题目背景

**赛时提醒：如果您始终是 30pts，且使用了题目给的快速读入，请重新拷贝修改后的快速读入。**

**赛时提醒：本题如果解法正确，快读可能无法起到优化作用。**

	这个恐怕是将存在乃至于记忆切割成三十二颗的争夺黑白棋。

    双方剩下的棋子数字都很小——也就是重要性很高吧。

				......
            
    ——哥哥为什么会让自己落单呢？她原本对此感到疑惑。

    不过，在得知答案之后，那可以说是理所当然的做法。

    首先，第一个理由极为单纯。

    故意将记忆托付给对方，暂时屈居败势的目的是——

    「……那种事……白……做不到啊……」

    想像了一下，白露出悲伤的笑容，做出这个结论。

    哥哥做的这些事，如果由白执行……白不觉得自己的精神能够保持正常。

    自己仅仅因为哥哥从身旁消失，就甚至一度怀疑哥哥的存在。

    ——被忘掉的话还好。

    ——忘掉哥哥的话——白确信自己的精神会无法保持正常。
    
				......
                
    （……这里……哥哥在……这里……）

    即使是空无一物的空间，但是白确信，她感觉得到哥哥的位置。

    白顿时眼眶一热，不过她强行忍住，继续思考。

    （……然后这就是……第二个……同时也是……最大的……理由。）

    白将写着【参】的棋子白色面朝上，用手指夹住。

    哥哥是『白色还是黑色』，这个问题也不需要犹豫。

    因为既然他将最后的棋局托付给『白』——那他当然是持白棋。

    这个现在看不见，甚至无法认知的棋局。

    既没有开始的记忆，也不知道盘面的经过如何。

    不过哥哥故意下输，并且为了让白能获胜所可能下的棋步……

    而对方看到之后，完全中了哥哥的计谋，被诱导而下的棋步……

    然后，为了逆转，哥哥可能选择的所有位置分布。

    将这些全部推测分析——仅用三步棋反败为胜。

				......
            
    然后——原先失去一天半的记忆——逆流了回来——


## 题目描述

**白**在和森精种玩黑白棋，但黑白棋的规则有所改变。

有 $n$ 个黑白棋子，第 $i$ 个棋子编号为 $i$。棋子初始全为黑，游戏中，仅由**白**一人操作，**白**希望尽可能多的把棋子变成白色。

**白**要求第 $k$ 个棋子和第 $k \times p$ 个不能同时变成白色。

**白**共玩了 $T$ 次，每次**白**想知道最多能把多少棋子变成白色。**每次游戏独立。**

为避免混淆，加粗的**白**是人名。

## 说明/提示

#### 样例 1 解释

可以选择第 $2,3$ 个棋子变色。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（5 pts）：$T \le 5$，$n \le 2$；
- Subtask 2（5 pts）：$T \le 5$，$n \le 10$；
- Subtask 3（20 pts）：$T \le 5$，$n \le 10^6$；
- Subtask 4（70 pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1 \le T \le 10^6$，$0 \le n \le 10^{18}$，$1 \le p \le 10^{9}$。

```
//快读模板
//赛时提醒：快读没有太大必要使用
inline long long read(){
   long long s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
   return s*w;
}
```

## 样例 #1

### 输入

```
1
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
1
100 5```

### 输出

```
84```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在给定的约束条件下（即第 $k$ 个棋子和第 $k \times p$ 个棋子不能同时被选中）最大化选中的棋子数量。多数题解采用了贪心策略，通过从大到小选择棋子，并利用容斥原理来避免冲突。以下是对各题解的要点总结与对比：

1. **贪心策略**：大多数题解都采用了从大到小选择棋子的策略，确保每次选择的棋子不会影响后续的选择。这种策略的核心思想是优先选择较大的数，因为较大的数对后续选择的影响较小。
  
2. **容斥原理**：部分题解通过容斥原理来计算可以选择的棋子数量，即通过交替加减 $n/p^i$ 来得到最终的结果。这种方法能够有效地避免重复计算和冲突。

3. **时间复杂度**：所有题解的时间复杂度均为 $O(\log_p n)$，这是通过每次将 $n$ 除以 $p$ 来实现的，确保了算法的高效性。

4. **特判处理**：所有题解都注意到了当 $p=1$ 时的特殊情况，此时无法选择任何棋子，直接输出 0。

### 所选高星题解

#### 1. 作者：NightTide (★★★★★)
- **关键亮点**：思路清晰，代码简洁，通过分段选择并利用容斥原理实现高效计算。
- **核心代码**：
  ```cpp
  long long ans = 0;
  for(long long i = 1; n > 0; i = -i, n /= p){
      ans += i * n;
  }
  printf("%lld\n",ans);
  ```
- **个人心得**：作者通过分段选择并交替加减的方式，巧妙地解决了问题，代码简洁且高效。

#### 2. 作者：ycw123 (★★★★☆)
- **关键亮点**：详细解释了贪心策略的正确性，并通过交替加减的方式实现了容斥原理。
- **核心代码**：
  ```cpp
  for(long long i = n, j = 1; i > 0; i /= p, j = -j){
      cnt += j * i;
  }
  ```
- **个人心得**：作者通过从大到小选择棋子，并交替加减的方式，确保了选择的棋子数量最大化。

#### 3. 作者：Keids (★★★★☆)
- **关键亮点**：通过容斥原理直接计算可以选择的棋子数量，代码简洁且高效。
- **核心代码**：
  ```cpp
  for(int i = 1; k <= n; n = n / k, i++){
      if(i & 1) ans -= n / k;
      else ans += n / k;
  }
  ```
- **个人心得**：作者通过容斥原理直接计算可以选择的棋子数量，避免了复杂的逻辑判断。

### 最优关键思路或技巧

- **贪心策略**：从大到小选择棋子，确保每次选择的棋子不会影响后续的选择。
- **容斥原理**：通过交替加减 $n/p^i$ 来避免冲突，确保选择的棋子数量最大化。
- **特判处理**：当 $p=1$ 时直接输出 0，避免不必要的计算。

### 可拓展之处

- **类似问题**：可以扩展到其他类似的约束条件问题，如选择某些数时不能选择其倍数或因数等。
- **算法套路**：贪心策略和容斥原理的结合可以应用于其他需要最大化选择数量的问题。

### 推荐题目

1. **P1896 [SCOI2005]互不侵犯**：考察如何在棋盘上放置国王，使得它们互不攻击。
2. **P1352 没有上司的舞会**：考察如何在树形结构中选择节点，使得选择的节点不相邻。
3. **P1048 采药**：考察如何在有限的时间内选择药材，使得总价值最大化。

### 个人心得总结

- **调试经历**：在处理 $p=1$ 时的特殊情况时，容易忽略直接输出 0 的处理，导致程序陷入死循环。
- **顿悟感想**：通过从大到小选择棋子，并利用容斥原理，可以有效地避免冲突，确保选择的棋子数量最大化。

---
处理用时：30.62秒
# 题目信息

# [✗✓OI R1] 前方之风

## 题目背景

>「不错的恶意。」  
> 女性呵呵笑道。  
>「但是，如果向我发出恶意，你可是会死哦？」

你不知道什么动作会被算作发出恶意，所以你决定做一道题来分散自己的注意力。

## 题目描述

给出一个长度为 $n$ 的序列 $a$ 和 $q$ 个询问，第 $i$ 个询问给出 $k_i$。对于每次询问，你需要进行以下操作：
1. 求出剩下的数的平均数 $\mathit{avg}$。
2. 将剩下的数中 $<\mathit{avg}-k_i$ 的数删去。
3. 重复以上两个步骤直到所有数都不会被删去。
4. 输出最后会剩下几个数。

**注意：询问之间是独立的，也就是说，不会真的删去那些数。**

## 说明/提示

**【样例解释】**

对于第一组样例，当 $k=0$ 时，显然只会留下 $99$。  
当 $k=6$ 时，删除数的步骤如下：
- 平均数为 $60\dfrac{1}{9}$，留下 $99,63,72,97,68$。
- 平均数为 $79.8$，留下 $99,97$。
- 平均数为 $98$，停止删除。

**【数据范围】**

对于 $100\%$ 的数据，满足 $1\leq n,q \le 10^5$，$1\le T \le 10$，$0 \le a_i,k_i \le 10^9$。

| subtask | 特殊数据范围 | 分数 |  时间限制
| :----------: | :----------: | :----------: |  :----------: |
| 1 | $n,q \le 200$ | 20 |   300ms 
| 2 | $n,q \le 2000$ | 30  | 300ms
| 3 |  | 50 | 800ms|

>「不错的恶意。」  
> 女性呵呵笑道。  
>「而且你运气很不错，如果放在以前，你早就死了。」

![](https://cdn.luogu.com.cn/upload/image_hosting/6icoj36r.png)

## 样例 #1

### 输入

```
5
9 9
19 99 63 39 72 46 97 38 68 
0 6 4 0 7 1 0 3 6 
6 8
88 62 48 50 8 47 
0 6 1 5 2 2 6 1 
6 5
33 3 54 17 26 64 
87 89 92 70 59 
18 19
71 52 77 38 12 34 82 14 57 39 91 7 56 86 35 68 38 14 
9 9 1 5 1 3 4 5 6 1 6 0 3 0 2 1 3 5 8 
10 15
4 77 78 76 5 19 98 94 77 81 
17 43 4 86 2 91 85 4 81 74 44 16 21 69 32 
```

### 输出

```
1 2 2 1 2 2 1 2 2
1 1 1 1 1 1 1 1
6 6 6 6 6
4 4 1 3 1 2 2 3 3 1 3 1 2 1 1 1 2 3 4
7 7 2 10 2 10 10 2 10 10 7 7 7 10 7
```

## 样例 #2

### 输入

```
1
5 1
20 0 0 0 0
5```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效处理多个独立询问，每个询问要求根据给定的 $k_i$ 进行多次删除操作，直到序列稳定。由于数据范围较大（$n, q \leq 10^5$），直接模拟的暴力解法无法通过。因此，优化思路主要集中在以下几点：

1. **排序与单调性**：由于删除操作是从小到大进行的，排序后可以利用单调性优化删除过程。
2. **后缀和与平均数计算**：通过后缀和快速计算剩余数的平均数，避免重复计算。
3. **离线处理与双指针**：将询问按 $k_i$ 从大到小排序，利用双指针维护删除过程，减少时间复杂度。
4. **二分查找**：部分题解尝试通过二分查找优化，但由于删除过程的复杂性，二分查找的正确性难以保证。

### 所选高星题解

#### 1. 作者：AsunderSquall (赞：10) - 5星
**关键亮点**：
- **离线处理与双指针**：将询问按 $k_i$ 从大到小排序，利用双指针维护删除过程，时间复杂度优化到 $O(q \log q + n \log n)$。
- **性质证明**：详细证明了答案随 $k$ 的增加而单调不降的性质，确保了算法的正确性。
- **代码清晰**：代码结构清晰，变量命名合理，易于理解。

**核心代码**：
```cpp
sort(c+1,c+q+1,cmp);
int pos=1;
for(int i = 1; i <= q; i++){
    while(pos<=n&&b[pos]<avg[pos]-c[i].k)pos++;
    ans[c[i].id]=n-pos+1;
}
```
**个人心得**：
- 通过观察删除过程的单调性，避免了复杂的二分查找，简化了实现。

#### 2. 作者：青鸟_Blue_Bird (赞：1) - 4星
**关键亮点**：
- **双指针优化**：利用双指针维护删除过程，时间复杂度优化到 $O(n + q)$。
- **单调性利用**：通过观察 $k_i$ 与答案的单调关系，避免了重复计算。
- **代码简洁**：代码实现简洁，逻辑清晰。

**核心代码**：
```cpp
int id = 1;
int l = 1; 
while(id <= q && l <= n){
    if(b[l] < (double)(sum[n] - sum[l - 1]) / (double)(n - l + 1) - k[s[id]]) l++; 
    else ans[s[id++]] = n - l + 1; 
}
```
**个人心得**：
- 通过将 $k_i$ 从大到小排序，简化了删除过程的维护。

#### 3. 作者：BaCO3 (赞：0) - 4星
**关键亮点**：
- **离线处理与双指针**：将询问按 $k_i$ 从大到小排序，利用双指针维护删除过程，时间复杂度优化到 $O(q \log q + n \log n)$。
- **代码结构清晰**：代码结构合理，变量命名规范，易于理解。

**核心代码**：
```cpp
sort(k+1,k+q+1,cmp);
int cnt1=1,cnt2=1;
while(cnt1<=n&&cnt2<=q){
    if(a[cnt1]<(double)(sum[n]-sum[cnt1-1])/(n-cnt1+1)-k[cnt2].num) cnt1++;
    else k[cnt2++].ans=n-cnt1+1;
}
```
**个人心得**：
- 通过双指针优化，避免了重复计算，提高了算法效率。

### 最优关键思路与技巧

1. **排序与单调性**：排序后利用单调性优化删除过程，减少时间复杂度。
2. **离线处理与双指针**：将询问按 $k_i$ 从大到小排序，利用双指针维护删除过程，避免重复计算。
3. **后缀和与平均数计算**：通过后缀和快速计算剩余数的平均数，避免重复计算。

### 可拓展之处

- **类似问题**：处理多个独立询问时，可以考虑离线处理与双指针优化，减少时间复杂度。
- **单调性利用**：在涉及删除或添加操作的问题中，可以利用单调性优化过程。

### 推荐题目

1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374) - 考察树状数组的基本操作，适合练习离线处理与双指针优化。
2. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383) - 考察线性筛法的应用，适合练习单调性优化。
3. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368) - 考察树状数组的区间修改与单点查询，适合练习后缀和与平均数计算。

---
处理用时：43.00秒
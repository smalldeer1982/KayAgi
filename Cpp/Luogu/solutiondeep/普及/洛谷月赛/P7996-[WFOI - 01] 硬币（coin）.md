# 题目信息

# [WFOI - 01] 硬币（coin）

## 题目描述

你面前有一排 $n$ **堆**硬币排成一线，**同一堆硬币**的面值相同，记第 $i$ 堆硬币的面值为 $a_i$。而**每堆硬币**的数量都相同，记为 $x$。

现在你知道每第 $i$ 堆硬币的面值 $a_i$，你需要确定一个**正整数** $x$，使得**每堆硬币的总金额的**方差最接近于一个**正整数** $k$。

两数 **“最接近”** 的定义：两数之差的绝对值最小。

方差定义：方差 $s ^ 2 = \cfrac{(a_1 - \bar x)^2 + (a_2 - \bar x) ^ 2 + \cdots + (a_n - \bar x) ^ 2}{n}$，其中 $\bar x$ 代表 $x$ 的平均值。

## 说明/提示


**【样例 $\#1$ 解释】**

  当 $x=3$ 时，第 $i$ 个堆的硬币金额为 $3\times a_i$，这些硬币堆的金额分别为 $21,6,12,18,9,21,30$，可以计算得这些硬币金额的方差约为 $58.78$，可以证明当 $x=3$ 时方差最接近 $47$。

**【样例 $\#2$ 解释】**

  可以发现，无论 $x$ 的取值，方差都会为 $0$，所以输出 `No answer!`。







**【数据规模】**

**本题采用 Subtask 捆绑测试。**

Subtask 编号 | $n,\forall a_i\le$ | $k\le$ | $\footnotesize\texttt{测试点数目}$ |
:-: | :-: | :-: | :-:
**Subtask #0 $(20\texttt{pts})$** | $10^3$ | $10^9$| $6$ |
**Subtask #1 $(25\texttt{pts})$** | $10^5$ | $10^{12}$| $6$ |
**Subtask #2 $(25\texttt{pts})$** | $10^5$ | $10^{18}$| $6$ |
**Subtask #3 $(30\texttt{pts})$** | $7\times10^6$ | $3\times 10^{18}$| $6$ |

对于 $100\%$ 的数据，$1\le n,\forall a_i\le7\times10^6$，$1\le k\le3\times10^{18}$。记原来 $a$ 数组的方差为 $p$，则数据满足 $p=0$ 或 $p\in[0.25,\ 2^{63}-1]$ 。





**【提示】**

  本题读入量较大，请使用合适的读入方式。此处推荐[快速读入模板](https://www.luogu.com.cn/paste/bcfvgxr7)，对于 $\texttt{C/C++}$ 语言，你也可以使用 `scanf` 语句完成读入。
  
  为避免卡精度，建议 `C/C++` 选手使用 $\texttt{double}$ 类型，并不建议使用 `eps`。

## 样例 #1

### 输入

```
7 47
7 2 4 6 3 7 10```

### 输出

```
3```

## 样例 #2

### 输入

```
4 4
4 4 4 4```

### 输出

```
No answer!```

# AI分析结果

### 综合分析与结论

本题的核心在于通过数学推导，找到使方差最接近给定值 \( k \) 的正整数 \( x \)。大多数题解都基于以下关键思路：

1. **方差的性质**：当数列中的每个数乘以 \( x \) 时，方差变为原来的 \( x^2 \) 倍。这一性质是解题的核心，简化了问题的复杂度。
2. **数学推导**：通过推导得出 \( x = \sqrt{\frac{k}{s^2}} \)，其中 \( s^2 \) 是原数列的方差。然后通过比较 \( \lfloor x \rfloor \) 和 \( \lceil x \rceil \) 的方差，选择最接近 \( k \) 的 \( x \)。
3. **特殊情况处理**：当原数列的方差为 0 时，直接输出 `No answer!`；当 \( x \) 为 0 时，输出 1，因为 \( x \) 必须为正整数。

大多数题解的思路相似，但在代码实现和细节处理上有所不同。部分题解在优化和代码可读性上表现较好，而有些题解则存在冗余或不必要的复杂度。

### 所选高星题解

#### 1. 题解作者：Elgo87 (5星)
**关键亮点**：
- **思路清晰**：详细推导了方差的性质，并给出了明确的数学公式。
- **代码简洁**：代码结构清晰，逻辑严谨，处理了所有特殊情况。
- **优化程度高**：使用了快速读入优化，避免了不必要的计算。

**核心代码**：
```cpp
ll x = floor(sqrt(k / sum)), y = ceil(sqrt(k / sum));
if (!x) {
    printf("%lld\n", y);
    return 0;
}
if (fabs(x * x * 1.0 * sum - k) <= fabs(y * y * 1.0 * sum - k))
    printf("%lld\n", x);
else
    printf("%lld\n", y);
```
**个人心得**：
- 强调了开 `long long` 的重要性，避免因数据类型导致的错误。

#### 2. 题解作者：柳下惠 (4.5星)
**关键亮点**：
- **思路清晰**：通过数学推导，得出了 \( x = \sqrt{\frac{k}{s^2}} \) 的结论。
- **代码简洁**：代码逻辑清晰，处理了所有特殊情况。
- **优化程度高**：使用了快速读入优化，避免了不必要的计算。

**核心代码**：
```cpp
ll ans = sqrt(k / s);
for (double i = max(1.0, ans - 6.0); i <= ans + 6.0; i += 1.0) {
    if (abs(s * i * i - k) < minn) {
        minn = abs(s * i * i - k);
        ans = i;
    }
}
printf("%lld", ans);
```
**个人心得**：
- 强调了在最优值附近进行波动判断，确保找到最接近的 \( x \)。

#### 3. 题解作者：Iam1789 (4星)
**关键亮点**：
- **思路清晰**：通过数学推导，得出了 \( x = \sqrt{\frac{k}{s^2}} \) 的结论。
- **代码简洁**：代码逻辑清晰，处理了所有特殊情况。
- **优化程度高**：使用了快速读入优化，避免了不必要的计算。

**核心代码**：
```cpp
int l = sqrt(k / ss), af;
double an = 9e18;
for (int i = max(l - 1, 1LL); i <= l + 1; i++) {
    double ll = (i * i) * ss;
    if (abs(k + 0.0 - ll) < an) {
        an = abs(k + 0.0 - ll);
        af = i;
    }
}
cout << af << '\n';
```
**个人心得**：
- 强调了在最优值附近进行波动判断，确保找到最接近的 \( x \)。

### 最优关键思路与技巧

1. **方差的性质**：理解方差在数列缩放时的变化规律，是解题的核心。
2. **数学推导**：通过数学公式推导，简化问题复杂度，找到 \( x \) 的表达式。
3. **特殊情况处理**：处理方差为 0 和 \( x \) 为 0 的情况，确保代码的鲁棒性。
4. **优化技巧**：使用快速读入和避免不必要的计算，提高代码效率。

### 可拓展之处

- **类似问题**：类似的问题可以考察其他统计量的变化规律，如均值、中位数等。
- **算法套路**：通过数学推导简化问题复杂度，是解决类似问题的通用套路。

### 推荐题目

1. [P1001 A+B Problem](https://www.luogu.com.cn/problem/P1001)
2. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
3. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)

### 个人心得总结

- **调试经历**：部分题解强调了开 `long long` 的重要性，避免因数据类型导致的错误。
- **踩坑教训**：在处理 \( x \) 为 0 的情况时，部分题解忽略了题目要求 \( x \) 为正整数，导致错误。
- **顿悟感想**：通过数学推导，理解方差的性质，是解决本题的关键。

---
处理用时：41.68秒
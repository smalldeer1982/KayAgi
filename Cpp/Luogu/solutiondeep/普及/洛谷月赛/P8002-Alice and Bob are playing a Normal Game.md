# 题目信息

# Alice and Bob are playing a Normal Game

## 题目描述

给定一个长度为 $n$ 的序列，Alice 和 Bob 交替操作一共 $k$ 次，第 $i$ 次当前操作的人必须选一个 $-x_i \sim x_i$ 的整数把它插在序列开头或结尾，Alice 先手（也就是说 $i$ 为奇数时由 Alice 来插入一个 $-x_i\sim x_i$ 的整数，$i$ 为偶数时由 Bob 来插入一个 $-x_i\sim x_i$ 的整数）。

记最终的序列为 $a_1,a_2,\dots,a_{n+k}$，则得分为 $\sum_{i=1}^{n+k} (-1)^{i-1}a_i$。Alice 希望得分最大，Bob 希望得分最小。在两人都采取最优策略的情况下，求最终得分。

## 说明/提示

**本题采用捆绑测试**

| 子任务编号 | 分值 | 特殊限制 |
| :----------: | :----------: | :----------: |
| $0$ | $25$ | $n,k,x_i\le 5$ |
| $1$ | $25$ | $n,k\le 10$ |
| $2$ | $25$ | $n,k\le 100$ |
| $3$ | $25$ | 无特殊限制 |

对于所有数据，保证 $1\le n,k\le 2\times 10^5$，$0\le |a_i|,x_i\le 10^9$。

本题测试点较多，为了保证评测速度，本题时限 500ms，保证时限在 std 所用最大时间的 5 倍以上。

## 样例 #1

### 输入

```
2 2
1 3
2 2```

### 输出

```
-2```

# AI分析结果

### 综合分析与结论

本题的核心在于理解Alice和Bob在交替操作中的最优策略，以及如何通过模拟操作来得到最终得分。所有题解都抓住了“最后一个操作的人可以决定最终得分的正负性”这一关键点，并在此基础上进行了策略分析。大多数题解通过模拟操作过程，逐步更新得分的绝对值，最终根据操作次数的奇偶性决定得分的正负。

### 题解评分与亮点

#### 1. 作者：VinstaG173 (★★★★★)
- **关键亮点**：思路清晰，代码简洁，直接模拟了Alice和Bob的最优策略，时间复杂度为O(n)，效率高。
- **代码核心思想**：通过判断当前操作者的身份（Alice或Bob），更新得分的绝对值，最后根据操作次数的奇偶性决定得分的正负。
```cpp
while(k--){
    x=read(),r=(k&1)?((r>x)?(r-x):0):(r+x);
}
return 0&printf("%lld\n",(t&1)?r:-r);
```

#### 2. 作者：stntn (★★★★☆)
- **关键亮点**：详细分析了操作对得分的影响，提出了“最后一轮的玩家可以通过操作二将优势转为己方”的结论，代码实现较为清晰。
- **代码核心思想**：通过判断当前操作者的身份，更新得分的绝对值，最后根据操作次数的奇偶性决定得分的正负。
```cpp
if(k&1) flag=1;//A win
else flag=0;//B win
for(re int i=1;i<=k;i++){
    read(x);x=abs(x);
    if(i&1)
        if(flag) work_winner(1);
        else work_loser(1); 
    else
        if(flag) work_loser(0);
        else work_winner(0); 
    len++;
}
```

#### 3. 作者：Level_Down (★★★★☆)
- **关键亮点**：通过分析每次操作对得分的影响，提出了“最后一个操作的人可以让原得分的绝对值最大”的策略，代码实现简洁。
- **代码核心思想**：通过判断当前操作者的身份，更新得分的绝对值，最后根据操作次数的奇偶性决定得分的正负。
```cpp
for(int i=1;i<k;i++){
    if((i+f)&1) ans+=x;
    else ans=max(p,ans-x);
}
scanf("%d",&x);
if(!f) printf("%lld",ans+x);
else printf("%lld",-ans-x);
```

### 最优关键思路与技巧

1. **最后一个操作的人决定得分的正负性**：这是所有题解的核心思路，最后一个操作的人可以通过选择插入的数来调整得分的正负。
2. **模拟操作过程**：通过模拟Alice和Bob的每次操作，逐步更新得分的绝对值，最终根据操作次数的奇偶性决定得分的正负。
3. **时间复杂度优化**：所有题解的时间复杂度均为O(n)，通过直接模拟操作过程，避免了复杂的博弈论分析。

### 可拓展之处

1. **类似博弈问题**：可以拓展到其他类似的博弈问题，如Nim游戏、取石子游戏等，理解双方的最优策略。
2. **动态规划**：可以将问题转化为动态规划问题，通过状态转移来求解最终得分。

### 推荐题目

1. [P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)
2. [P1048 取石子游戏](https://www.luogu.com.cn/problem/P1048)
3. [P1052 过河](https://www.luogu.com.cn/problem/P1052)

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现不开`long long`会导致错误，提醒我们在处理大数时要注意数据类型的选择。
- **顿悟感想**：通过分析最后一个操作的人的优势，理解双方的最优策略，是解决本题的关键。

---
处理用时：35.36秒
# 题目信息

# 「Wdoi-5」樱点收集

## 题目背景

119 季 5 月，明明本应是樱花盛开的春天，幻想乡却依然下着大雪。异变的主谋**西行寺幽幽子**在古书上看到，只要使妖樱西行妖满开便会有什么人复活，便出于兴趣命令妖梦收集幻想乡中的春度，一手策划成了这场异变。在收集春度的过程中散落的能量在西行妖的影响下化为**樱点**，散落在幻想乡各处。

出发解决**春雪异变**的灵梦将前往冥界旅途划分为了若干段，每一段都可以收集到一定的樱点。收集齐一定程度的樱点，就会立即开出樱之结界。开出樱之结界后可以短暂地屏蔽一切攻击，并且获得相应的增益。

但是樱之结界何时开放仅由樱点的收集情况所决定，她不得不对樱点进行「规划」。通过某些途径规避某一段路上樱点的收集，借此使得在将来的某几段路程里，灵梦得以恰好在该段的末尾开放樱之结界。  

但是现实往往不尽人意。也就是说，可能有某些要求无法达成。灵梦希望找出一个方案，使得她可以达成的要求最多。灵梦委托八云紫帮忙决策，于是这个重任就被一条懒紫交给了式神八云蓝。尽管八云蓝擅长计算，但是八云紫睡觉去了没有给她编程，因而现在这个任务就落到了你的手上。

## 题目描述

灵梦当前拥有的樱点可以使用一个**变量** $c$ 存储，初始时为 $0$。当樱点在某个瞬间**恰好**变为了 $k$，灵梦就会展开樱之结界，同时 $c$ 变为 $0$。

现在她把路程**依次**划分为了 $n$ 个关卡，其中第 $i$ 关上，灵梦一共可以获得 $a_i$ 点樱点。这些樱点是均匀分布在这关的路程上的。也就是说，随着这段路程的进行，灵梦的樱点个数会依次增加，每次增加 $1$ 个单位（$c\gets c+1$），恰好在这段路程结束的瞬间会收集到这关中第 $a_i$ 点樱点。

![](https://cdn.luogu.com.cn/upload/image_hosting/3yuiywt0.png)

**【需要注意的是，这只是图示参考，不满足实际的数据限制。】**

在这个例子里，灵梦将路径划分为了四个关卡。这四个关卡的樱点个数分别为 $2,0,3,1$。

灵梦提出了 $m$ 个要求。第 $i$ 个要求 $b_i$ 表示灵梦希望在第 $b_i$ 段路程结束的瞬间，**恰好**展开樱之结界（如果在这段路程的中途展开但是结束的瞬间没有展开，那就不算达成了要求）。

灵梦可以选择在某个关卡开头放 bomb，**跳过**整个关卡的樱点收集。这样的机会**有且仅有**一次（当然，灵梦可以选择不使用 bomb）。

现在需要求出，在最优的选择下，灵梦**最多**可以达成多少个要求。

## 说明/提示

样例 $2$ 见下发的附件 $\textbf{\textit{sukura2.in/sakura2.ans}}$。该样例约束与测试点 $1\sim 8$ 一致。  
样例 $3$ 见下发的附件 $\textbf{\textit{sukura3.in/sakura3.ans}}$。该样例约束与测试点 $9\sim 14$ 一致。  
样例 $4$ 见下发的附件 $\textbf{\textit{sukura4.in/sakura4.ans}}$。该样例约束与测试点 $15\sim 20$ 一致。

#### 样例 1 解释

- 在不使用 bomb 时，灵梦会在第 $2$、$3$ 关开出樱之结界，其中第 $3$ 关在统计序列中，满足要求数为 $1$。
- 在第 $1$ 关使用 bomb，灵梦会在第 $4$ 关开出樱之结界，且第 $4$ 关在统计序列中，满足要求数为 $1$。
- 在第 $2$ 关使用 bomb，灵梦会在第 $4$ 关开出樱之结界，且第 $4$ 关在统计序列中，满足要求数为 $1$。
- 在第 $3$ 关使用 bomb，灵梦会在第 $2$ 关开出樱之结界，且第 $2$ 关不在统计序列中，满足要求数为 $0$。
- 在第 $4$ 关使用 bomb，灵梦会在第 $2$、$3$ 关开出樱之结界，其中第 $3$ 关在序列中，满足要求数为 $1$。

#### 数据范围及约定

本题共有 $20$ 个测试点，每个测试点 $5$ 分。最终分数为所有测试点分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \bm{n\le } & \bm{k\le} \cr\hline
1\sim 8 & 200 & 10^3 \cr\hline
9\sim 14 & 2\times 10^3 & 10^5 \cr\hline
15\sim 20 & 3\times 10^5 & 10^6 \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，保证 $1\le m\le n\le 3\times 10^5$，$1\le k\le 10^6$，$1\le a_i\le 10^9$，$1 \le b_i \le n$，$b$ 序列递增。

## 样例 #1

### 输入

```
4 3 2
1 3 4
1 1 2 1```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效处理前缀和，并通过枚举 bomb 的位置来动态调整满足条件的关卡数。大多数题解都采用了前缀和与模运算结合的方式，通过桶或数组来记录模数的出现次数，从而在 O(n) 时间内完成计算。优化点在于如何减少重复计算，以及如何高效地处理 bomb 对后续关卡的影响。

### 所选高星题解

#### 1. 作者：WardLee (5星)
**关键亮点**：
- 使用两个数组 `nl` 和 `nr` 分别记录前缀和模数的出现次数，通过从后向前枚举 bomb 位置，动态更新满足条件的关卡数。
- 代码简洁，逻辑清晰，时间复杂度为 O(n)，空间复杂度为 O(k)。

**核心代码**：
```cpp
for(int i = n; i >= 1; i --){
    if(a[i] && st[i]) nl[s[i] % K] --;
    res = max(res, nl[0] + nr[a[i] % K]);
    if(a[i] && st[i]) nr[s[i] % K] ++;
}
```
**实现思想**：通过从后向前枚举 bomb 位置，动态更新 `nl` 和 `nr` 数组，计算当前 bomb 位置下的最大满足条件数。

#### 2. 作者：minstdfx (5星)
**关键亮点**：
- 使用前缀和数组 `S` 和桶数组 `x` 来记录模数的出现次数，通过从后向前枚举 bomb 位置，动态更新满足条件的关卡数。
- 详细解释了 bomb 对前后关卡的影响，逻辑清晰，代码可读性强。

**核心代码**：
```cpp
for(int i = n; i >= 1; i--){
    if(S[i] % k == 0 && IsRequired[i]) t--;
    ans = max(ans, t + x[a[i] % k]);
    if(IsRequired[i]) x[S[i] % k]++;
}
```
**实现思想**：通过从后向前枚举 bomb 位置，动态更新 `t` 和 `x` 数组，计算当前 bomb 位置下的最大满足条件数。

#### 3. 作者：lyhqwq (4星)
**关键亮点**：
- 使用前缀和数组 `sum` 和桶数组 `t` 来记录模数的出现次数，通过从后向前枚举 bomb 位置，动态更新满足条件的关卡数。
- 代码简洁，逻辑清晰，时间复杂度为 O(n)，空间复杂度为 O(k)。

**核心代码**：
```cpp
for(int i = n; i >= 1; i--){
    if(b[i]) t[sum[i]]--;
    ans = max(ans, tmp + t[a[i] % k]);
    if(!sum[i] && b[i]) tmp++;
}
```
**实现思想**：通过从后向前枚举 bomb 位置，动态更新 `t` 和 `tmp` 数组，计算当前 bomb 位置下的最大满足条件数。

### 最优关键思路与技巧

1. **前缀和与模运算结合**：通过计算前缀和并对 `k` 取模，可以快速判断某个关卡是否满足条件。
2. **桶或数组记录模数**：使用桶或数组记录模数的出现次数，可以在 O(1) 时间内查询某个模数的出现次数。
3. **从后向前枚举 bomb 位置**：通过从后向前枚举 bomb 位置，可以动态更新满足条件的关卡数，减少重复计算。

### 可拓展之处

- **类似问题**：可以拓展到其他需要动态调整前缀和的问题，如区间修改、区间查询等。
- **算法套路**：前缀和与模运算结合的方式可以应用于其他需要快速判断某个条件是否满足的问题。

### 推荐题目

1. **P3372 【模板】线段树 1** - 考察区间修改与查询，适合练习前缀和与动态调整。
2. **P3384 【模板】树链剖分** - 考察树上的区间操作，适合练习动态调整与查询。
3. **P3368 【模板】树状数组 1** - 考察单点修改与区间查询，适合练习前缀和与动态调整。

### 个人心得摘录

- **调试经历**：部分题解提到在调试过程中发现 bomb 对前后关卡的影响，需要仔细处理边界条件。
- **踩坑教训**：在处理模运算时，需要注意负数取模的情况，避免出现错误。
- **顿悟感想**：通过从后向前枚举 bomb 位置，可以大大简化问题的复杂度，提高代码效率。

---
处理用时：41.24秒
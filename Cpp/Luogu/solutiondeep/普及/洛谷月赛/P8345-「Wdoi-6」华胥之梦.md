# 题目信息

# 「Wdoi-6」华胥之梦

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/lkvzvoj9.png)](https://thwiki.cc/%E4%B8%9C%E6%96%B9%E6%B1%82%E9%97%BB%E5%8F%B2%E7%BA%AA/%E4%BE%BF%E7%AC%BA)

## 题目描述

### 简要题意

给定长度为 $n$ 的序列 $a$ 和常数 $c$。构造点数为 $n$ 的有向完全图 $G$ 使得边 $i\to j$（$i\neq j$）的长度为 $a_i-2a_j+c$，保证所有边权**非负**。

接下来给出 $q$ 次询问，每次给出一个点集，试找出图 $G$ 的一条最短的简单路径，满足其经过点集中所有点，并输出它的长度。

---
### 原始题意

梅莉做了一个梦，梦到自己穿越到了幻想乡的迷途竹林之中。醒来之后，她希望能够和莲子一起再次穿越境界，进入幻想乡。

但是，这一次，她看到了 $n$ 个世界，其中，第 $i$ 个世界的结界强度为 $a_i$。而世界之间**两两都有**通道相连，莲子和梅莉便是通过这些通道来进行世界之间的穿梭的。

为了避免错过幻想乡所在的世界，因此她们每到达一个世界，都会穿越结界。莲子和梅莉从第 $i$ 个世界中，通过一条通道，再穿越结界进入第 $j$ 个世界，需要使用的灵能为 $a_i-2a_j+c$（保证所需消耗的灵能非负），其中 $c$ 是一个常数，是梅莉每次穿越结界需要的额外灵能消耗。注意，这也意味着，从第 $i$ 个世界到第 $j$ 个世界，与第 $j$ 个世界穿越到第 $i$ 个世界所消耗的灵能，**可能是不同的**。

为了能够高效地找到幻想乡，她们会对你进行 $q$ 次询问，每次询问的时候会给出一个**集合**，表示她们想要进入的世界。由于世界众多，她们希望能够节省灵能，因此她希望你能求出所有包含这些世界的简单路径（即：同一条世界间的通道不会被走多次）中，消耗灵能值之和最少的路径。你只需告诉她们消耗灵能值之和最少为多少。

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/x3r2ucsl.png)

每两个点之间的边权如图所示。为了便于选手观察，边权的颜色与它所对应的边的颜色相同。

对于第一个询问，可以找到路径 $4\to 1$
；对于第二个询问，可以找到路径 $3\to 2\to 1$；对于第三个询问，可以找到路径 $2\to 4 \to 1\to 5$。可以证明，这三个方案分别是对应询问的最优方案。
#### 样例 \#2

该样例符合 $\textbf{Subtask 1}$ 的限制。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \bm{q\le} & \bm{\sum |S|\le} & \textbf{\textsf{特殊性质}}&\textbf{Subtask \textsf{依赖}}\cr\hline
1 & 30 & 10 & 10 & 10 & - &-\cr\hline
2 & 20 & 10^5 & 10^5 & 10^5 & \mathbf{A}&- \cr\hline
3 & 20 & 10^5 & 10^5 & 10^5 & \mathbf{B}&-  \cr\hline
4 & 30 & 10^6 & 10^6 &  10^6& -&1,2,3 \cr\hline
\end{array}
$$

- 特殊性质 $\bf A$：$a_i$ 单调递增。
- 特殊性质 $\bf B$：$a_i$ 全部相等。

对于 $100\%$ 的数据，保证 $1 \leq S_i \leq n \leq 10^6, 1\leq \sum |S|,q \leq 10^6, 1 \le a_i,c \le 10^9$。

## 样例 #1

### 输入

```
5 20 3
7 4 2 5 9
2 1 4
3 1 2 3
4 1 4 2 5```

### 输出

```
11
24
34```

## 样例 #2

### 输入

```
10 928698067 3
331485039 15480787 61584781 252174726 472089427 95998831 252561792 118119945 315548522 24453837
4 9 1 10 2
5 10 6 1 5 8
1 5
```

### 输出

```
1798602551
2249463436
0
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过数学推导和贪心策略，找到最短路径的构造方法。大多数题解都基于以下关键思路：
1. **路径经过的点必须为点集中的点**：由于边权非负，多走任意一条边都会使结果不优，因此最短路径只能经过点集中的点。
2. **路径的构造顺序**：通过数学推导，发现路径的总长度只与点集中的最小值和最大值有关，因此只需找到点集中的最小值和最大值，即可快速计算最短路径。

### 所选高分题解

#### 1. **Dr_Gilbert (5星)**
- **关键亮点**：通过详细的数学推导，证明了路径的最优构造方式，并给出了时间复杂度为 \(O(\sum|S|)\) 的优化方案。代码清晰，逻辑严谨。
- **个人心得**：作者在推导过程中发现，路径的总长度只与点集中的最小值和最大值有关，因此无需对整个点集进行排序，只需找到最小值和最大值即可。

```cpp
int main(){
    int n,c,q;
    cin>>n>>c>>q;
    for (int i=1;i<=n;i++) cin>>a[i];
    while (q--){
        int s=0, t=1e9, w=0, x;
        int m=read();
        for (ll i=1;i<=m;i++){
            x=read();
            s=max(s,a[x]);
            t=min(t,a[x]);
            w-=a[x];
        }
        printf("%lld\n",c*(m-1)+w+t*2-s);
    }
    return 0;
}
```

#### 2. **Ginger_he (5星)**
- **关键亮点**：通过数学公式的化简，直接得出路径长度的表达式，并指出只需找到点集中的最小值和最大值即可。代码简洁高效。
- **个人心得**：作者通过公式推导，发现路径长度可以简化为 \(c \times (s-1) + (2r_1 - r_s) - \sum_{i=1}^s r_i\)，从而避免了排序操作。

```cpp
int main(){
    n=read(),c=read(),q=read();
    for(int i=1;i<=n;i++) a[i]=read();
    while(q--){
        s=w=0,t=1e9;
        m=read();
        for(ll i=1;i<=m;i++){
            x=read();
            s=max(s,a[x]);
            t=min(t,a[x]);
            w-=a[x];
        }
        printf("%lld\n",c*(m-1)+w+t*2-s);
    }
    return 0;
}
```

#### 3. **Ask_sum (4星)**
- **关键亮点**：通过分析路径长度的公式，提出只需找到点集中的最小值和最大值，并计算总和即可。代码实现简洁明了。
- **个人心得**：作者通过公式推导，发现路径长度可以简化为 \(c \times (s-1) + (2r_1 - r_s) - \sum_{i=1}^s r_i\)，从而避免了排序操作。

```cpp
int main(){
    cin>>n>>c>>q;
    for(int i=1;i<=n;i++) cin>>a[i];
    while(q--){
        int s,sum=0,maxa=-1,mina=1000000000000000000;
        cin>>s;
        for(int i=1;i<=s;i++){
            int x; cin>>x;
            if(mina>a[x]) mina=a[x];
            if(maxa<a[x]) maxa=a[x];
            sum+=a[x];
        }
        cout<<c*(s-1)-sum-maxa+2*mina<<endl;
    }
    return 0;
}
```

### 最优关键思路与技巧
1. **数学推导**：通过数学公式的化简，发现路径长度只与点集中的最小值和最大值有关，从而避免了排序操作，优化了时间复杂度。
2. **贪心策略**：通过贪心策略，选择最小值和最大值来构造最短路径，确保路径长度最小。

### 可拓展之处
- **类似问题**：类似的问题可以出现在最短路径、贪心算法、数学推导等场景中，如最小生成树、最短路径问题等。
- **举一反三**：在遇到类似的问题时，可以通过数学推导和贪心策略来优化算法，减少不必要的计算。

### 推荐题目
1. **P3371 【模板】单源最短路径（弱化版）**：考察最短路径算法的基本应用。
2. **P3366 【模板】最小生成树**：考察最小生成树的构造方法。
3. **P1090 合并果子**：考察贪心算法的应用。

### 总结
本题的关键在于通过数学推导和贪心策略，找到最短路径的构造方法。通过分析路径长度的公式，发现只需找到点集中的最小值和最大值即可，从而避免了排序操作，优化了时间复杂度。

---
处理用时：37.71秒
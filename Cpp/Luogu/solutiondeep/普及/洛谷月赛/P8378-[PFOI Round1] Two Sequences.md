# 题目信息

# [PFOI Round1] Two Sequences

## 题目背景

syzf2222 喜欢并查集！特别是路径压缩的并查集。

## 题目描述



```cpp
inline int find(int x){
	if(x==fa[x])return x;
	return fa[x]=find(fa[x]);
}
inline void merge(int x,int y){
	fx=find(x),fy=find(y);
	if(fx==fy)return;fa[fx]=fy;
}
```

这是他惯用的并查集代码，初始时对于每个 $x$ 有 `fa[x]=x`。

接下来的 $T$ 天中，每天小 h 都给了他一个 $n$，表示并查集的大小（每天的 $n$ 可能是不同的）。

调皮的小 x 见他不在机房，每天都在并查集上不断 `merge`。
注意到小 x 不喜欢 `==`，他觉得这特别像他的眼睛，于是他不会使 `merge` 函数在第二行的条件语句中被 `return`，否则他会十分气愤。

现在的已知信息就只有最终的 $fa$ 数组了。
而 syzf2222 希望还原小 x 的操作序列（即若干次按顺序进行的 `merge` 操作）。由于他名字里有很多个 2 而且本人也非常 2 ，他希望知道对于每一天，有多少个 $fa$ 数组**恰好**能被还原成**两种**操作序列，答案对 $998244353$ 取余数。

两个操作序列不同，当且仅当某次 `merge` 时的变量 `fx,fy` 至少有一个不同。



## 说明/提示

【样例解释】

对于第一天，$n=3$，共有 $fa=[1,1,1],[2,2,2],[3,3,3]$ 这三种 $fa$ 数组使得恰有两种操作序列。

以 $fa=[1,1,1]$ 为例，两种操作序列分别为 `merge(2,1),merge(3,1)` 和 `merge(3,1),merge(2,1)`，其他 `merge` 参数不同的方案与上述两种的其中一种是本质相同的（每次的 `fx,fy` 都一样）。

---

【数据范围】

**「本题采用捆绑测试」**

- $\texttt{Subtask 1(10 pts)：}T=1,\ n\le 10$；
- $\texttt{Subtask 2(30 pts)：}T=10^2,\ n\le 10^3$；
- $\texttt{Subtask 3(60 pts)：}$无特殊限制。

对于 $100\%$ 的数据，满足 $1\le T\le 10^5,\ 1\le n\le 10^9$。

## 样例 #1

### 输入

```
4
3
20
8492
114514```

### 输出

```
3
61560
822256526
988192964
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过并查集的合并操作，推导出满足特定条件的操作序列数量。题解中，大部分作者通过分析并查集的结构，推导出最终的公式 `n(n-1)(n-2)^2 / 2`，并给出了相应的代码实现。部分题解还通过详细的推导过程，解释了为什么只有特定的并查集结构才能满足条件。

### 所选高星题解

#### 1. 作者：Abeeel51 (5星)
- **关键亮点**：详细推导了并查集的结构，解释了为什么只有特定的树结构才能满足条件。通过组合数学的推导，得出了最终的公式，并提供了简洁的代码实现。
- **个人心得**：作者通过详细的推导过程，帮助读者理解为什么只有特定的并查集结构才能满足条件，这对于理解题目的本质非常有帮助。

```cpp
printf("%lld\n",1ll*(n-1)*n/2%mod*(n-2)%mod*(n-2)%mod%mod);
```

#### 2. 作者：Thunder_Lake (4星)
- **关键亮点**：通过将问题转化为“修改两个元素的值”的问题，简化了问题的复杂度。通过分类讨论，得出了最终的公式，并提供了代码实现。
- **个人心得**：作者通过将问题转化为更简单的形式，帮助读者更容易理解题目的本质，并提供了清晰的推导过程。

```cpp
ull work(ull n){
    ull res = 0;
    res += n;
    res *= (n - 1);
    res /= 2;
    res %= mod;
    res *= (n - 2);
    res %= mod;
    res *= (n - 2);
    res %= mod;
    return res;
}
```

#### 3. 作者：gyc18 (4星)
- **关键亮点**：通过观察并查集的结构，得出了只有特定的树结构才能满足条件的结论。通过组合数学的推导，得出了最终的公式，并提供了代码实现。
- **个人心得**：作者通过详细的推导过程，帮助读者理解为什么只有特定的并查集结构才能满足条件，这对于理解题目的本质非常有帮助。

```cpp
cout << n * (n - 1) / 2 % mod * (n - 2) % mod * (n - 2) % mod << endl;
```

### 最优关键思路或技巧

1. **并查集结构分析**：通过分析并查集的结构，得出只有特定的树结构才能满足条件，这是解决问题的关键。
2. **组合数学推导**：通过组合数学的推导，得出了最终的公式，这是解决问题的核心步骤。
3. **代码优化**：在代码实现中，通过边计算边取模的方式，避免了数据溢出的问题，这是代码实现中的关键技巧。

### 可拓展之处

1. **类似问题**：类似的问题可以考察其他数据结构（如树、图）的合并操作，推导出满足特定条件的操作序列数量。
2. **算法套路**：类似的算法套路可以应用于其他需要推导操作序列数量的问题，如排列组合问题、图论问题等。

### 推荐题目

1. [P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972) - 考察并查集的应用。
2. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367) - 并查集的基本操作。
3. [P1197 [JSOI2008] 星球大战](https://www.luogu.com.cn/problem/P1197) - 并查集在动态图中的应用。

---
处理用时：30.30秒
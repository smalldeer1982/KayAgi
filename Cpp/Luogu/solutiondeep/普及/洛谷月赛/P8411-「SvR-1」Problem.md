# 题目信息

# 「SvR-1」Problem

## 题目背景

小 L 打颓被 nodgd 发现，于是他开始做题了。

## 题目描述

他的 DS 非常菜，于是他把一共 $n$ 道 DS 题加到了自己的计划题单里，其中第 $i$ 道题的有趣程度为 $a_i$。

由于他并不精通 DS，他发现他在做一些题目之前需要先做另一些题目。这样的关系共有 $n - 1$ 组，他还发现每道题都出现在了这些关系中且没有重复。

他发现 $\forall 2 \leq i \leq n$，第 $i$ 题和第 $fa_i$ 题间存在上文所述的关系，且 $1 \leq fa_i < i$。**他必须先做第 $fa_i$ 题后才能做第 $i$ 题**。

他发现，如果他在做一道题之前高兴程度为 $k$，则他做完第 $i$ 题后，他的高兴程度便会变为 $\min(k, a_i)$。**他做题前的高兴程度为无穷大**。

他想问你**在必须先做第 $1$ 题且不能重复做某一道题**的情况下，他在做题的全过程中每做完一道题后**高兴程度之和的最大值**。

## 说明/提示

#### 样例 #1 解释
在该组样例中 $a = [3398922311, 3077554952, 2933028207, 4018360144, 1263042788, 835814542]$，$fa_2 = fa_3 = fa_4 = 1$，$fa_5 = fa_6 = 2$。

最优方案之一：依次做第 $1, 4, 2, 3, 5, 6$ 题，最大值为 $3398922311 + 3398922311 + 3077554952 + 2933028207 + 1263042788 + 835814542 = 14907285111$。
#### 伪代码参考
$$
\def{\b}#1{ \textbf{ #1 } }\def{\t}#1{\text{ #1 }}\def{\s}{\quad}\def{\f}#1{\textsf{ #1 }}
\def{\l}{\underline{\kern{300pt}}\\[-10pt]} 
\def{\r}{\overline{\underline{\kern{300pt}}}}
\begin{aligned}
&\r\\&\b{Algorithm:}\t{Get }a_i,fa_i\\[-13pt]&\l\\
&\begin{aligned}
    \f{1.}&\b{function} \b{\color{red}unsigned int} \t{getnext}(\b{\color{red}unsigned int}\&seed): \\
    \f{2.}&\s seed=seed\oplus\t{left}(seed,13)\\
    \f{3.}&\s seed=seed\oplus\t{right}(seed,17)\\
    \f{4.}&\s seed=seed\oplus\t{left}(seed,5) \\
    \f{5.}&\s \b{return} seed\\
    \f{6.}&\b{function} \t{main}(n):\\
    \f{7.}&\s \b{for} i \b{from} 1 \b{to} n \b{step}1\\
    \f{8.}&\s\s a_i=\t{getnext}(seed)\\
    \f{9.}&\s \b{end for} \\
    \f{10.}&\s \b{for} i \b{from} 2 \b{to} n \b{step}1\\
    \f{11.}&\s\s fa_i=\t{getnext}(seed)\bmod(i-1)+1\\
    \f{12.}&\s \b{end for} \\
    \end{aligned}\\[-12pt]
&\r
\end{aligned}
$$

其中 $\text{left}(x,d)$ 和 $\text{right}(x,d)$ 分别表示将 $x$ 左移或右移 $d$ 位。
#### 数据规模与约定
**本题自动开启捆绑测试和 O2 优化。**
$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c}\hline\hline
\textbf{Subtask} & \bm{n \leq} & \textbf{分值} \\\hline
\textsf{1} & 10 & 10 \\\hline
\textsf{2} & 10^4 & 20 \\\hline
\textsf{3} & 10^6 & 20 \\\hline
\textsf{4} & \text{无特殊限制} & 50 \\\hline\hline
\end{array}
$$

对于 $100\%$ 的数据，$1 \leq n \leq 10^7$，$0 \leq seed < 2^{32}$。

## 样例 #1

### 输入

```
6 114514```

### 输出

```
14907285111```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效计算每道题的高兴程度，并确保在满足题目依赖关系的情况下，最大化高兴程度的总和。题解中主要有以下几种思路：

1. **暴力搜索（DFS）**：适用于小规模数据，时间复杂度高，无法通过大规模测试。
2. **拓扑排序+优先队列**：通过优先队列选择当前最大值的节点，时间复杂度为O(n log n)，适用于中等规模数据。
3. **线性递推**：利用题目中`fa_i < i`的性质，直接按顺序递推计算高兴程度，时间复杂度为O(n)，适用于大规模数据。

最优解是**线性递推**，利用题目中`fa_i < i`的性质，避免了复杂的图遍历和优先队列操作，直接按顺序计算每个节点的高兴程度，极大地优化了时间和空间复杂度。

### 精选题解

#### 题解1：liangbowen (5星)
**关键亮点**：
- 详细解释了从暴力搜索到线性递推的优化过程，思路清晰。
- 提供了完整的代码实现，代码可读性强。
- 通过逐步优化，最终达到O(n)的时间复杂度，适合大规模数据。

**核心代码**：
```cpp
ULL sum = a[1]; //注意这里需要 long long 来储存。
for (int i = 2; i <= n; i++) a[i] = min(a[i], a[ fa[i] ]), sum += a[i];
printf("%llu", sum);
```
**核心思想**：利用`fa_i < i`的性质，直接按顺序递推计算每个节点的高兴程度，时间复杂度为O(n)。

#### 题解2：Hisaishi_Kanade (4星)
**关键亮点**：
- 强调了树的特殊性质，指出每个节点的高兴程度仅与其父节点有关。
- 代码简洁，直接利用递推公式计算高兴程度。

**核心代码**：
```cpp
ans=a[1];//显然，a[1]必定会原封不动的被选
for(i=2;i<=n;++i)
    ans+=a[i]=min(a[i],a[fa[i]]);
```
**核心思想**：利用树的特殊性质，直接按顺序计算每个节点的高兴程度，时间复杂度为O(n)。

#### 题解3：stntn (4星)
**关键亮点**：
- 通过优先队列的思路逐步优化到线性递推，思路清晰。
- 提供了详细的代码实现，代码可读性强。

**核心代码**：
```cpp
for (register int i = 2; i <= n; i++)
    a[i] = min(a[i], a[get_next(seed) % (i - 1) + 1]), ans += a[i];
```
**核心思想**：利用`fa_i < i`的性质，直接按顺序递推计算每个节点的高兴程度，时间复杂度为O(n)。

### 最优关键思路与技巧

1. **利用`fa_i < i`的性质**：通过这个性质，可以直接按顺序递推计算每个节点的高兴程度，避免了复杂的图遍历和优先队列操作。
2. **线性递推**：时间复杂度为O(n)，适合大规模数据，代码简洁且高效。
3. **避免建图**：直接利用数组存储依赖关系，减少了空间复杂度。

### 可拓展之处

- **类似问题**：在处理树形结构或依赖关系的问题时，可以优先考虑是否可以利用顺序递推来优化时间复杂度。
- **算法套路**：在处理大规模数据时，优先考虑线性时间复杂度的方法，避免使用复杂的数据结构。

### 推荐题目

1. **P3379 【模板】最近公共祖先（LCA）**：考察树的遍历与递推。
2. **P3388 【模板】割点（割顶）**：考察图的遍历与递推。
3. **P3387 【模板】缩点**：考察图的遍历与递推。

### 个人心得摘录

- **调试经历**：在优先队列的实现中，由于堆的排序操作，导致时间复杂度较高，最终通过线性递推优化。
- **顿悟感想**：在处理树形结构的问题时，利用顺序递推可以极大地简化问题，减少时间复杂度。

### 通用建议与扩展思路

- **优先考虑线性时间复杂度**：在处理大规模数据时，优先考虑线性时间复杂度的方法，避免使用复杂的数据结构。
- **利用题目中的特殊性质**：在解题时，仔细分析题目中的特殊性质，往往可以找到更高效的解法。

---
处理用时：38.44秒
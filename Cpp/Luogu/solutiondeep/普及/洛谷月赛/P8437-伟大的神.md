# 题目信息

# 伟大的神

## 题目背景

伟大的神 $\text{T}\color{red}\text{nyieldingUrilobite}$ （以下简称 TU）喜欢字符串，在 AK 了 IOI 后的第 $998244353$ 天后，伟大的神 TU 勒令小 s 找出他喜欢的字符串。

否则，小 s 就要被吊打 $10^{998244353}$ 年。（虽然找出来了也要被吊打）

## 题目描述

伟大的神 TU 认为 ，一个所有出现的字符的数量相等的字符串是属于神的，他称之为神之字符串。

对于一个字符串 $S$，如果它的一个子串为神之字符串，即称这个子串为神之子串。

神 TU 认为，他喜欢的字符串只能由 `l` 和 `r` 构成，并且还要满足以下条件：

   - 字符串的长度为 $n$。
   - 字符串中最长神之子串长度为 $m$。
   - 字符串中连续的相同的字符的数量不能超过 $k$。

弱小的神小 s 找不出神 TU 喜欢的字符串，现在他找到了你，你能帮帮他吗？

## 说明/提示

**本题采用捆绑测试。**

对于 $100\%$ 的数据，保证 $1\le k\le10^5$，$4\le m\le n \le 10^5$。

数据保证可以找出神 TU 喜欢的字符串。

Subtask 1：对于 $5\%$ 的数据，保证 $k=1$。

Subtask 2：对于另外 $10\%$ 的数据，保证 $n=m$。

Subtask 3：对于另外 $30\%$ 的数据，保证 $k \ge 3$。

Subtask 4：无特殊性质。



## 样例 #1

### 输入

```
10 6 3```

### 输出

```
lllrrlrlll```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个满足特定条件的字符串，主要难点在于如何在保证最长神之子串长度为 `m` 的同时，避免出现更长的神之子串，并且控制连续相同字符的数量不超过 `k`。题解中，大多数作者都采用了分类讨论的方法，针对不同的 `k` 值进行构造，尤其是 `k=2` 时的特殊情况。以下是对题解的整理与对比：

1. **分类讨论**：大多数题解都根据 `k` 的不同值进行分类讨论，尤其是 `k=1`、`k=2` 和 `k≥3` 的情况。这种分类讨论的思路清晰，能够有效解决不同条件下的构造问题。
2. **构造技巧**：在 `k=2` 时，许多题解通过调整构造方式（如减少 `m` 的值或改变构造顺序）来避免出现更长的神之子串。这种技巧在处理特殊条件时非常有效。
3. **代码实现**：部分题解的代码实现较为简洁，尤其是通过循环和条件判断来生成字符串，代码可读性较高。

### 所选高星题解

#### 1. **作者：chen_zhe (赞：33)**  
**星级：4.5**  
**关键亮点**：
- 详细分类讨论了 `k=1`、`k=2` 和 `k≥3` 的情况，思路清晰。
- 针对 `k=2` 时的特殊情况，提出了调整构造顺序的方法，避免了更长的神之子串的出现。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for (int i=1;i<=m-2;i++) cout << (i&1?'l':'r');
cout << "rl";
for (int i=m+1;i<=n;i++) {
    if (cnt==0) cout << 'l';
    else cout << 'r';
    cnt++; cnt%=3;
}
```
**实现思想**：通过调整构造顺序，确保在 `k=2` 时不会出现更长的神之子串。

#### 2. **作者：Jeremiahy (赞：7)**  
**星级：4**  
**关键亮点**：
- 通过贪心算法构造字符串，确保在 `k≥3` 时不会出现更长的神之子串。
- 针对 `k=2` 时的特殊情况，提出了减少 `m` 值的方法，有效解决了问题。
- 代码实现简洁，逻辑清晰。

**核心代码**：
```cpp
for (int i=1;i<=m;i++) cout << (i%2?'l':'r');
for (int i=m+1;i<=n;i++) {
    for (int j=1;j<=k;j++) cout << 'l';
    if (i<=n) cout << 'r';
}
```
**实现思想**：通过贪心算法，确保在 `k≥3` 时不会出现更长的神之子串。

#### 3. **作者：sycqwq (赞：6)**  
**星级：4**  
**关键亮点**：
- 详细讨论了 `k=1`、`k=2` 和 `k≥3` 的情况，思路清晰。
- 针对 `k=2` 时的特殊情况，提出了调整构造顺序的方法，避免了更长的神之子串的出现。
- 代码实现简洁，逻辑清晰。

**核心代码**：
```cpp
for (int i=1;i<=m/2;i++) cout << "lr";
for (int i=m+1;i<=n;i++) {
    if (i%3==1) cout << 'r';
    else cout << 'l';
}
```
**实现思想**：通过调整构造顺序，确保在 `k=2` 时不会出现更长的神之子串。

### 最优关键思路与技巧

1. **分类讨论**：根据 `k` 的不同值进行分类讨论，尤其是 `k=2` 时的特殊情况。
2. **调整构造顺序**：在 `k=2` 时，通过减少 `m` 的值或改变构造顺序，避免出现更长的神之子串。
3. **贪心算法**：在 `k≥3` 时，通过贪心算法确保不会出现更长的神之子串。

### 可拓展之处

本题的构造思路可以推广到其他类似的字符串构造问题，尤其是需要在特定条件下构造满足某种性质的字符串。类似的题目可以考察如何在保证某些条件的同时，避免出现不期望的结果。

### 推荐题目

1. **P1003 铺地毯**：考察如何在特定条件下构造满足某种性质的字符串。
2. **P1047 校门外的树**：考察如何在特定条件下构造满足某种性质的字符串。
3. **P1056 排座椅**：考察如何在特定条件下构造满足某种性质的字符串。

### 个人心得摘录

- **chen_zhe**：在 `k=2` 时，通过调整构造顺序，避免了更长的神之子串的出现，这种思路在处理特殊条件时非常有效。
- **Jeremiahy**：通过贪心算法，确保在 `k≥3` 时不会出现更长的神之子串，这种思路简洁且有效。
- **sycqwq**：在 `k=2` 时，通过减少 `m` 的值，避免了更长的神之子串的出现，这种思路在处理特殊条件时非常有效。

---
处理用时：45.93秒
# 题目信息

# 极寒之地

## 题目背景

238 神教 #1

在古老的传说中，南极企鹅是全知全能的真神，它们能轻易做到任何我们做不到的事情。在南极洲的广袤大陆上，没有任何生物能对它们构成威胁。

所幸，神并不是高高在上，对尘世不屑一顾的。经常有果敢的人类来到这里，运气好的话，能和神结为挚友——这是幸运的，因为神不需要从你这里得到什么，而它的力量却会一直庇佑你，直到永远。

而你是一位探险家，对传说的内容十分向往。在经历了不知多久的苦索之后，你终于找到了些许神迹，并成功地找到了传说中的“神”。

——并且是两位，但是……

## 题目描述

神正在辅导孩子做数学题。在神批评孩子的心算结果从低到高第
```plain
17409488245517115276142322168576189279543123341138742779319865028602486509006138934460661849637882913598407636154209737260165754120014607177773359981826603801250947835120164061898414398808778383710734965109968348499255333743808806819897228289078158612425862653924618211976295200391819532525867722941969825549125083939679976935766582544161633553282536186214629150364929344059634288758125744444293077873038252037297534321132535122264070340053106750045495648216831484920706070567384926577457983022367155402606111730048301290388577089307478371008345014562035666767719162727651399592653244427923731578583241159510645308913474636528103155221748236303528072259108507905341048592541395827961771903417533241290874568077431363019042931482055932874814355268929594505880132227031337095583783793918280184860930087635658394839764586155196454253268266394562535661446268255101517600243362823434368473980088051436392198234023198989135142538928701481935979801475550928245044051159083872693810338480154137358569089360697894156
```
位就错了并且居然花了 
```plain
0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000215055865
```
秒才算完的时候，神的孩子发现了你，并要求你来验算一遍。

你当然做不到，于是你请求缩小数据范围，而神同意了。神说，你是个勇敢的探险者，在把这道题算完之后，会与你成为朋友。

现在，你只需要解决的是这么一个问题了：

给定一个正整数 $n$ 和自然数序列 $a_1,a_2,\cdots,a_n$。你需要对每一个 $0\le S\le 2^n-1$，求出数 $S$ 的“权值”。

一个数 $S$ 的权值 $v(S)$ 的计算方式是：把它写成二进制，如果它从低到高第 $x$ 位为 $1$，就把答案异或（xor）上 $a_x$。

神不想刻意刁难你，他只希望你把所有 $v(S)$ 求出来之后，把答案分别乘上对应的 $S$，然后异或起来，取模 $2^{64}$ 再交给他就好了。

你心知这个问题是很好算的。但是你还是希望尽量快地把结果求出，以成为神的朋友。

那么，加油吧！

## 说明/提示

**本题采用捆绑测试。**

|数据点编号|$n$|分值|空间限制|子任务编号|
|----|----|----|----|----|
|$1\sim3$|$=20$|$10$|$\texttt{256MB}$|0|
|$4\sim6$|$=25$|$40$|$\texttt{256MB}$|1|
|$7\sim10$|$\le30$|$50$|$\texttt{8MB}$|2|

对于 $100\%$ 的数据，$1\le n\le 30,0\le a_i\le 2^{64}-1$。

---

### 样例解释

用 $\bigoplus$ 表示 异或。

对于第一个样例，$\text{Ans}=(0\times 0)\bigoplus(1\times 1)\bigoplus(2\times 2)\bigoplus(3\times 3)\bigoplus(4\times 3)\bigoplus(5\times 2)\bigoplus(6\times 1)\bigoplus(7\times 0)\bigoplus(8\times 4)\bigoplus(9\times 5)\bigoplus(10\times 6)\bigoplus(11\times 7)\bigoplus(12\times 7)\bigoplus(13\times 6)\bigoplus(14\times 5)\bigoplus(15\times 4)=16$。

---

本题不需要刻意卡常，$\texttt{1.4s}$ 已经是出题人最大的善良了，如果还跑不过那基本就一定是算法不优了。

## 样例 #1

### 输入

```
4
1 2 3 4```

### 输出

```
16```

## 样例 #2

### 输入

```
30
15942549000714163495 14973783748924019241 11750608274629447103 3841514779926491634 1491087352666302822 3926467265136890882 2165405652723005667 16850040541486744638 9389207531715430944 2453094189961991688 17306424574086088540 4253088488420240522 6711268779219669357 7357305029308027009 10742286389669332463 16939477641403891687 14194800553999397870 17414698597200046696 18113730556943709454 3735103125227126629 16235879363688955717 14861602169195639258 903677597641043180 12364536150445169736 14881735759803865853 14781978421412291657 872796319752083876 11301016179769629644 14385296580178382407 3946726419982234649 ```

### 输出

```
13929368580789239808
```

# AI分析结果

### 综合分析与结论

本题的核心在于高效计算所有 $S$ 的权值 $v(S)$，并将其与 $S$ 相乘后异或起来。由于 $n$ 的最大值为 30，直接暴力计算的复杂度为 $O(n \cdot 2^n)$，无法在规定时间内完成。因此，各题解主要通过以下两种思路进行优化：

1. **利用位运算优化**：通过 `__builtin_ffs` 或 `__builtin_ctz` 等内建函数快速定位二进制位，减少计算复杂度。
2. **格雷码优化**：利用格雷码的性质，每次只改变一个二进制位，从而减少计算量。

整体来看，**chen_zhe** 和 **N2MENT** 的题解在优化思路和代码实现上较为优秀，尤其是 **chen_zhe** 的题解通过循环展开和位运算优化，显著降低了常数，达到了较好的性能。

### 所选高星题解

#### 1. **chen_zhe** (5星)
- **关键亮点**：
  - 使用 `__builtin_ffs` 快速定位二进制位，减少计算复杂度。
  - 通过循环展开和位运算优化，显著降低了常数。
  - 详细解释了优化思路，代码可读性高。
- **核心代码**：
  ```cpp
  for (i=1;i+4<(1<<n);)
  {
      ret^=a[1];
      ans^=ret*(i++);
      ret^=a[1]^a[2];
      ans^=ret*(i++);
      ret^=a[1];
      ans^=ret*(i++);
      for (int j=__builtin_ffs(i);j;j--)
          ret^=a[j];
      ans^=ret*(i++);
  }
  ```
  **实现思想**：通过循环展开和位运算优化，减少 `__builtin_ffs` 的调用次数，提升性能。

#### 2. **N2MENT** (4星)
- **关键亮点**：
  - 利用异或的自反性，通过 $v(S+1) = v(S) \oplus v(S \oplus (S+1))$ 快速计算 $v(S+1)$。
  - 使用 `__builtin_ffs` 快速定位二进制位，减少计算复杂度。
- **核心代码**：
  ```cpp
  for(ll s = 1; s <= ms; s++){
      val ^= xsum[__builtin_ffs(s)];
      ans ^= val * s;
  }
  ```
  **实现思想**：通过异或的自反性和 `__builtin_ffs`，快速计算 $v(S+1)$，减少计算量。

### 最优关键思路与技巧

1. **位运算优化**：利用 `__builtin_ffs` 或 `__builtin_ctz` 快速定位二进制位，减少计算复杂度。
2. **循环展开**：通过循环展开减少函数调用次数，提升性能。
3. **异或自反性**：利用异或的自反性，快速计算相邻 $S$ 的权值。

### 可拓展之处

- **格雷码的应用**：格雷码在子集枚举和状态转移中有广泛应用，可以进一步研究其在高维动态规划中的应用。
- **位运算优化**：在涉及二进制位操作的问题中，位运算优化是常见的技巧，可以应用于其他类似问题。

### 推荐相似题目

1. **P2962 [USACO09NOV]Lights G**：利用位运算和状态压缩解决开关灯问题。
2. **P4799 [CEOI2015 Day2] 世界冰球锦标赛**：利用位运算和状态压缩解决背包问题。
3. **P3067 [USACO12OPEN]Balanced Cow Subsets G**：利用位运算和状态压缩解决子集和问题。

### 个人心得总结

- **chen_zhe**：通过循环展开和位运算优化，显著降低了常数，达到了较好的性能。调试过程中发现 `__builtin_ffs` 的调用次数对性能影响较大，因此通过循环展开减少了调用次数。
- **N2MENT**：利用异或的自反性，快速计算相邻 $S$ 的权值，减少了计算量。调试过程中发现 `__builtin_ffs` 的性能优于手动拆解二进制位。

---
处理用时：33.57秒
# 题目信息

# [Aya Round 1 F] 琪露诺的选择题

## 题目背景

**Problem Number:** [$\textit{24}$](https://www.luogu.com.cn/training/1392)

在经过射命丸文的一番调教之后，琪露诺的智商总算增长了⑨点。

现在寺子屋又要开始考试了，琪露诺通过一些手段知道了答案中的一些信息，而且因为她冰雪聪明，她不希望自己的成绩进步太明显，从而被老师上白泽慧音特别关照。因此她找到了你寻求一些帮助。

（注意：考试作弊是不对的！）

## 题目描述

有 $2\cdot n$ 道选择题，每题有 $\text{A}$ 和 $\text{B}$ 两个选项。正确答案可以表示为一个长度为 $2\cdot n$ 的字符串。

现在你要构造出一份作答（长度同样为 $2\cdot n$ 的字符串），其中**恰好**有 $a$ 个 $\text{A}$，同时与正确答案相比，你的作答恰好有 $e$ 个错误。如果不存在这样的构造方案，报告无解。

**注意：为了方便处理，本题保证 $e\le n$。**

**形式化地**，给定 $n,a,e$ 和一个长度为 $2\cdot n$ 的 01 串 $s$，你需要构造出一个恰好有 $a$ 个字符是 $\texttt 0$ 的长度为 $2\cdot n$ 的 01 串 $p$，使得

$$
\left(\sum_{i=1}^{2\cdot n}[s_i\ne p_i]\right)=e,
$$

其中 $[]$ 是 Iverson Bracket，详见「**说明/提示**」中的「提示」。

## 说明/提示

### 样例解释

对于数据 $1$，你构造出的作答串 $\text{BB{\color{e74c3c}AA}BB}$ 中恰好有 $2$ 个 $\text A$，与答案串相比刚好有 $3$ 处不同（即，有 $3$ 处错误）：

$$
\text{{\color{e74c3c}A}BA{\color{e74c3c}B}B{\color{e74c3c}A}}\\
\text{{\color{52c41a}B}BA{\color{52c41a}A}B{\color{52c41a}B}}
$$

故符合要求。

对于数据 $2$，不存在合法构造方案。

### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le T\le 100$，$1\le n\le 10^5$，$0\le e\le n$，$0\le a\le 2\cdot n$。

单组测试点内保证 $\sum(2\cdot n)\le 10^6$。

### 提示

$\textbf{A. Iverson Bracket}$

Iverson Bracket，是一种用方括号记号，如果方括号内的条件满足则为 $1$，不满足则为 $0$。更确切地讲，

$$
[P]=\begin{cases}1, & \text{If }P\text{ is true,}\\0,&\text{Otherwise.}\end{cases}
$$

## 样例 #1

### 输入

```
2
3 2 3
ABABBA
3 3 1
AAABBB```

### 输出

```
BBAABB
-1```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个满足特定条件的字符串，要求该字符串与给定字符串在特定位置上有恰好 `e` 个不同，并且该字符串中恰好包含 `a` 个字符 `A`。多个题解通过不同的思路解决了这个问题，主要分为以下几类：

1. **数学建模与方程求解**：通过建立方程求解需要修改的 `A` 和 `B` 的数量，直接构造目标字符串。
2. **贪心策略**：通过贪心策略逐步修改字符串，确保满足条件。
3. **分类讨论**：根据 `A` 的数量与目标 `a` 的关系，分类讨论并处理不同的情况。

### 所选高星题解

#### 1. **作者：DesignDigits (5星)**
- **关键亮点**：通过建立方程直接求解需要修改的 `A` 和 `B` 的数量，思路清晰且代码简洁。通过 `count` 函数快速统计 `A` 的数量，进一步简化了问题。
- **核心实现思想**：通过解方程 `x = (e - (a - a_)) / 2` 和 `y = (e + (a - a_)) / 2` 来得到需要修改的 `A` 和 `B` 的数量，然后直接构造目标字符串。
- **代码片段**：
  ```cpp
  int a_ = count(s.begin(), s.end(), 'A'), b_ = count(s.begin(), s.end(), 'B');
  if((a-a_+e)&1) {cout<<"-1\n"; continue; }
  int x=-a+a_+e>>1, y=a-a_+e>>1;
  if(x<0 || x>a_ || y<0 || y>b_) cout<<"-1\n";
  else{
      int A_edited=0, B_edited=0;
      for(int i=0; i<2*n; i++){
          if(s[i]=='A' && A_edited<x){
              s[i]='B';
              A_edited++;
          }
          else if(s[i]=='B' && B_edited<y){
              s[i]='A';
              B_edited++;
          }
      }
      cout<<s<<"\n";
  }
  ```

#### 2. **作者：sixrc (4星)**
- **关键亮点**：通过列方程求解需要修改的 `A` 和 `B` 的数量，思路清晰，代码实现较为简洁。
- **核心实现思想**：通过方程 `p + q = a` 和 `q - p = e - sa` 求解 `p` 和 `q`，然后根据 `p` 和 `q` 的值构造目标字符串。
- **代码片段**：
  ```cpp
  int sum = e - sa + na;
  if (sum & 1){
      puts ("-1");
      continue;
  }
  q = sum / 2, p = (na - e + sa) / 2;
  if (p < 0 || q < 0 || p > min(na, sa) || q > min(na, sb)){
      puts ("-1");
      continue;
  }
  ```

#### 3. **作者：CSP_Sept (4星)**
- **关键亮点**：通过贪心策略逐步修改字符串，确保满足条件，思路清晰且代码实现较为简洁。
- **核心实现思想**：先尽量使得固定状态下的错误数量最小，然后通过交换操作增加错误数量，确保满足条件。
- **代码片段**：
  ```cpp
  for(int i = 1 ; i <= m ; i++){
      if(p[i] + 'A' == s[i]){
          if(p[i] == 0){
              if(opa){printf("B"); opa--;}
              else printf("A");
          }
          else if(p[i] == 1){
              if(opb){printf("A"); opb--;}
              else printf("B");
          }
      }
      else printf("%c", p[i] + 'A');
  }
  ```

### 最优关键思路或技巧

1. **数学建模与方程求解**：通过建立方程直接求解需要修改的 `A` 和 `B` 的数量，是最简洁且高效的方法。
2. **贪心策略**：通过贪心策略逐步修改字符串，确保满足条件，适用于需要逐步调整的情况。
3. **分类讨论**：根据 `A` 的数量与目标 `a` 的关系，分类讨论并处理不同的情况，适用于复杂条件的问题。

### 可拓展之处

- **类似问题**：可以扩展到其他字符替换问题，如替换多个字符或替换不同字符。
- **算法套路**：数学建模与方程求解的思路可以应用于其他需要构造特定条件的字符串问题。

### 推荐题目

1. **P1003 铺地毯**：考察构造与数学建模。
2. **P1047 校门外的树**：考察贪心策略与分类讨论。
3. **P1056 排座椅**：考察构造与贪心策略。

### 个人心得总结

- **调试经历**：部分题解在调试过程中遇到了变量类型未正确设置的问题，导致结果错误，强调了变量类型选择的重要性。
- **踩坑教训**：在贪心策略中，未正确处理交换操作的顺序，导致错误数量不符合要求，提醒了在实现贪心策略时需要注意操作的顺序与条件。
- **顿悟感想**：通过数学建模与方程求解，可以简化复杂问题的解决过程，提高代码的简洁性与效率。

---
处理用时：39.29秒
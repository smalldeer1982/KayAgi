# 题目信息

# 「GLR-R3」立春

## 题目背景

&emsp;&emsp;「从此雪消风自软，梅花合让柳条新」

---

&emsp;&emsp;“明天就要返校了呢。”

&emsp;&emsp;灰色的长发被身后的人儿慢慢地顺着，顺着，于假期最后一个慵懒的清晨醒来，与春日的第一抹阳光迷迷糊糊地耳语，她的目光随着点过窗外的鸟雀，停留在那丛褐色的光秃枝丫。

&emsp;&emsp;“天依？”

&emsp;&emsp;赤红色的眸子随之望去，片刻，静默。

&emsp;&emsp;“如果我能告诉它，今天是立春，是春天的……”

&emsp;&emsp;“那么它会抽芽，繁盛，会成为我们窗外或红或绿的美妙。”

&emsp;&emsp;“——因为它本该如此，希望如此吧。”

---

&emsp;&emsp;**立春**&emsp;「雏鸟站在悬崖上　展开了翅膀　地平线上的梦想　照进一缕光」


## 题目描述

由于天依刚睡醒，害怕第一题的题面就迷糊了大家，所以本题只有简要题意。~~（其实是实在编不下去了。）~~

设 $\sigma$ 为任意一个长度为 $n$ 的排列，$\tau(\sigma)$ 表示其中的逆序对个数，请求出

$$
\sum_\sigma 2^{\tau(\sigma)}
$$

对 $(10^9+7)$ 取模的结果。

## 说明/提示

#### 题意解释

本节为部分选手介绍**逆序对的定义**，对此熟悉的选手可以跳过本节。

对于长度为 $n$ 的排列 $\sigma$，假设下标从 $1$ 开始，那么我们称 $(i,j)$ 构成逆序对，当且仅当 $1\le i<j\le n$，并且 $\sigma_i>\sigma_j$；$\tau(\sigma)$ 则表示总共有多少对不同的 $(i,j)$ 满足上述条件。

举个例子，对于排列 $\sigma=\lang 2,4,1,3\rang$，有逆序对 $(1,3),(2,3),(2,4)$，所以 $\tau(\sigma)=3$。可见只要 $\sigma$ 中元素的大小关系确定，$\tau(\sigma)$ 就是确定的。

#### 样例 #1 解释

$$
\begin{aligned}
\sum_{\sigma}2^{\tau(\sigma)} &= 2^{\tau(\lang 1,2,3\rang)}+2^{\tau(\lang 1,3,2\rang)}+2^{\tau(\lang 2,1,3\rang)}+2^{\tau(\lang 2,3,1\rang)}+2^{\tau(\lang 3,1,2\rang)}+2^{\tau(\lang 3,2,1\rang)}\\
&= 2^0+2^1+2^1+2^2+2^2+2^3\\
&= 21.
\end{aligned}
$$

### 数据规模与约定

**本题采用 Subtask 的计分方式。**

| 子任务编号 |    $n$    | 分值 |
| :--------: | :-------: | :--: |
|    $1$     |  $\le4$   | $5$  |
|    $2$     |  $\le10$  | $20$ |
|    $3$     | $\le100$  | $20$ |
|    $4$     | $\le10^3$ | $25$ |
|    $5$     | $\le10^7$ | $30$ |



## 样例 #1

### 输入

```
3```

### 输出

```
21```

# AI分析结果

### 综合分析与结论

本题的核心是计算所有长度为 \( n \) 的排列中 \( 2^{\tau(\sigma)} \) 的和，其中 \( \tau(\sigma) \) 是排列 \( \sigma \) 的逆序对数。通过分析，可以发现该问题可以通过递推公式 \( f(i) = (2^i - 1) \times f(i-1) \) 来解决，其中 \( f(i) \) 表示 \( n = i \) 时的答案。这一递推公式的推导基于排列的逆序对性质，尤其是通过固定排列的第一个元素，将问题转化为子问题的求解。

大多数题解都采用了这一递推公式，并通过不同的方式实现了 \( O(n) \) 的时间复杂度。部分题解还通过打表、等比数列求和等方式进一步优化了代码的可读性和效率。

### 所选高星题解

#### 1. **Rainybunny 的题解（5星）**
- **关键亮点**：  
  - 通过递推公式 \( f(i) = (2^i - 1) \times f(i-1) \) 简洁地解决了问题。
  - 代码实现清晰，使用了位运算和模运算优化，确保了高效的计算。
  - 提供了详细的递推公式推导过程，帮助读者理解问题的本质。
- **个人心得**：  
  - 作者提到“简化一个巨难的 idea”，表明其通过简化复杂问题找到简洁的解决方案。
- **核心代码**：
  ```cpp
  int main() {
      int n, ans = 1, pwr = 1;
      scanf("%d", &n);
      for (int i = 1; i <= n; ++i) {
          (pwr <<= 1) >= MOD && (pwr -= MOD);
          ans = ans * (pwr - 1ll) % MOD;
      }
      printf("%d\n", ans);
      return 0;
  }
  ```

#### 2. **Joker_1212 的题解（4星）**
- **关键亮点**：  
  - 通过递推公式 \( f(i) = (2^i - 1) \times f(i-1) \) 解决了问题。
  - 代码简洁，使用了位运算和模运算优化，确保了高效的计算。
  - 提供了递推公式的详细推导过程，帮助读者理解问题的本质。
- **核心代码**：
  ```cpp
  int main() {
      int n;
      cin >> n;
      ll ans = 1, power = 1;
      while (n--) {
          power <<= 1;
          power %= mod;
          ans *= power - 1;
          ans %= mod;
      }
      cout << ans << endl;
      return 0;
  }
  ```

#### 3. **xiaohaoaibiancheng66 的题解（4星）**
- **关键亮点**：  
  - 通过递推公式 \( f(i) = (2^i - 1) \times f(i-1) \) 解决了问题。
  - 代码简洁，使用了位运算和模运算优化，确保了高效的计算。
  - 提供了递推公式的详细推导过程，帮助读者理解问题的本质。
- **核心代码**：
  ```cpp
  int main() {
      int n;
      long long ans = 1, _2 = 2;
      cin >> n;
      for (int i = 2; i <= n; i++) {
          _2 *= 2;
          _2 %= 1000000007;
          ans = (ans * (_2 - 1)) % 1000000007;
      }
      cout << ans;
      return 0;
  }
  ```

### 最优关键思路与技巧

1. **递推公式**：通过固定排列的第一个元素，将问题转化为子问题的求解，得到递推公式 \( f(i) = (2^i - 1) \times f(i-1) \)。
2. **位运算优化**：使用位运算（如 `<<`）快速计算 \( 2^i \)，并通过模运算避免溢出。
3. **等比数列求和**：利用等比数列求和公式简化计算，进一步优化代码。

### 可拓展之处

1. **类似问题**：类似的问题可以通过固定某个元素，将问题转化为子问题的求解，适用于排列、组合等计数问题。
2. **递推公式的应用**：递推公式在动态规划和组合数学中广泛应用，掌握其推导过程有助于解决更多类似问题。

### 推荐题目

1. **P1338 末日的传说**：考察逆序对的性质，适合进一步理解逆序对的应用。
2. **P1226 快速幂模板**：快速幂的计算技巧在本题中得到了应用，适合进一步练习。
3. **P1494 小Z的袜子**：考察组合数学和递推公式的应用，适合进一步练习。

### 个人心得总结

- **调试经历**：部分作者提到通过打表找规律，帮助理解问题的本质。
- **踩坑教训**：部分作者提到快速幂的使用，避免了超时问题。
- **顿悟感想**：通过简化复杂问题，找到简洁的解决方案，是解决此类问题的关键。

---
处理用时：43.43秒
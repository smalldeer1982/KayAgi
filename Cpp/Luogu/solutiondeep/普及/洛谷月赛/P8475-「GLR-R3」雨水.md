# 题目信息

# 「GLR-R3」雨水

## 题目背景

&emsp;&emsp;「天将化雨舒清景，萌动生机待绿田」

---

&emsp;&emsp;在天依面前口口声声说着习惯了，才开学没几天，文化课和乐队训练的压力可是又让阿绫头疼呢。

&emsp;&emsp;浓缩为一个晚上的周末。站在阳台上，摸索朦胧于雨声的城市轮廓。雨水之日的雨，对于眼前的高楼大厦——们，恐怕也难有一些别样的意境吧。

&emsp;&emsp;“雨水节令的雨、白露节令的露、霜降节令的霜、小雪节令的雪各十二钱……”

&emsp;&emsp;胡乱想着，阿绫噗嗤一声笑了出来，“但是不管在哪里，雨中的空气，雨后的初阳，总是清新得叫人欢喜。”向着雨幕笑笑，拨弄这手里的旧吉他，不知不觉哼起那首歌来。

---

&emsp;&emsp;**雨水**&emsp;「等凉雨　的温度　将不安燥热中和　寻觅着　风的波折」

## 题目描述



身后的门被敲响，接过天依包回来的一大盒多肉，放下东西贴贴一会儿之后，她们决定把多肉们在阳台上排成一排。

多肉们的高度不尽相同，天依先将一共 $n$ 盆多肉随意排成一排，从左到右第 $i$ 盆的高度为 $a_i$。为了美观，她希望交换某些多肉的位置，使得由高度组成的序列 $A$ 的**字典序**尽可能小，不过，为了照顾多肉们的感受（？）她要求阿绫只能选取 $A$ 的一个**长度为偶数的子序列**（长度可以为 $0$），交换序列里第 $1$ 盆和第 $2$ 盆，第 $3$ 盆和第 $4$ 盆……的位置，然后放回它们原来的位置中。

苦活交给了阿绫，思考的工作自然交给你啦！请告诉阿绫，仅使用**一次**选取子序列的操作，她能够得到的字典序最小的新高度序列 $A'$。

#### 形式化题意

给定一个长为 $n$ 的整数序列 $A$，下标从 $1$ 开始。你可以**任取一个**自然数 $k$ 以及一个序列 $\lang 1,2,\dots,n\rang$ 的，长度为 $2k~(k\in\mathbb N)$ 的**子序列** $P$，并对于所有 $i=1,2,\dots,k$，交换 $A_{P_{2i-1}}$ 与 $A_{P_{2i}}$ 的值。求在所有可能得到的新序列 $A'$ 中，**字典序** 最小的序列。

**字典序**：对于长度为 $n$ 的序列 $A$ 和 $B$，定义 $A$ 的字典序小于 $B$，当且仅当：

$$
\exists i\in[1,n], (\forall j\in[1,i), A_j=B_j)\land A_i<B_i.
$$

**注意**：本题输入输出方式具有特殊性。详见「输入格式」与「输出格式」。


## 说明/提示

#### 样例 #1 解释

生成的序列为 $A=\lang 1,1,3,0,0,1,3\rang$，选取 $k=1,P=\lang 1,5\rang$, 得到答案序列为 $A'=\lang 0,1,3,0,1,1,3\rang$，按照要求计算知答案为 $43$。

#### 样例 #2 解释

生成的序列为 $A=\lang 2,8,0,6,2,2,1,7,8,3\rang$，选取 $k=3,P=\lang 1,3,4,7,8,10\rang$, 得到答案序列为 $A'=\lang 0,8,2,1,2,2,6,3,8,7\rang$，按照要求计算知答案为 $256$。

### 数据规模与约定

**本题采用 Subtask 的计分方式。**

对于 $100\%$ 的测试数据，$1\le n\le10^7$，$2\le \textit{thres}\le10^9$，$0\le k_1,k_2<2^{64}$。

对于不同的子任务，作如下约定：

 | 子任务编号 |    $n$    |     $\textit{thres}$     | 特殊性质 | 分值 |
| :--------: | :-------: | :---------: | :------: | :--: |
|    $1$     | $\le10^5$ |  $\le10^9$   |  **有**  | $10$ |
|    $2$     |   $\le20$    | $\le10$ |    无    | $15$ |
|    $3$     | $\le10^7$ | $=2$  |    无    | $20$ |
|    $4$     | $\le10^7$ | $\le10^7$ |    无    | $25$ |
|    $5$     | $\le10^7$ | $\le10^9$ |    无    | $30$ |

- **特殊性质**：保证程序正确生成的序列 $A$ 中不存在相等元素。

- **注意**：本题时限为 $0.5\text s$。

- ~~热知识：《世末歌者》演唱于夏日，显然不在雨水节气。~~


## 样例 #1

### 输入

```
7 20120712 21702102 4```

### 输出

```
43```

## 样例 #2

### 输入

```
10 114514 19198 10```

### 输出

```
256```

# AI分析结果

### 综合分析与结论

本题的核心目标是通过一次交换操作，使得序列的字典序最小。题解主要集中在贪心算法的应用上，通过预处理后缀最小值的位置，优化了时间复杂度。大多数题解的思路相似，但在实现细节和优化程度上有所不同。

### 所选高星题解

#### 1. 作者：TernaryTree (5星)
**关键亮点**：
- 思路清晰，详细解释了贪心策略的选择依据。
- 通过预处理后缀最小值的位置，将时间复杂度优化到O(n)。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
void init() {
    suf[n] = n;
    for (int i = n - 1; i >= 1; i--) {
        suf[i] = (a[i] < a[suf[i + 1]] ? i : suf[i + 1]);
    }
}

unsigned long long solve() {
    int s = 1;
    while (s <= n - 1) {
        int m = suf[s + 1];
        if (a[s] > a[m]) {
            swap(a[s], a[m]);
            s = m + 1;
        } else s++;
    } 

    unsigned long long ans = 0;
    for (register int i = 1; i <= n; ++i) {
        ans += (unsigned long long) a[i] * (unsigned long long) i;
    }
    return ans;
}
```

#### 2. 作者：NightTide (4星)
**关键亮点**：
- 详细解释了贪心策略的实现过程，并通过样例进行了模拟。
- 代码简洁，逻辑清晰，适合初学者理解。

**核心代码**：
```cpp
nxt[n] = n;
for(int i = n - 1; i >= 1; i--){
    if(a[i] < a[nxt[i + 1]]) nxt[i] = i;
    else nxt[i] = nxt[i + 1];
}
for(int i = 1; i < n; i++){
    if(a[nxt[i + 1]] < a[i]){
        swap(a[i], a[nxt[i + 1]]);
        i = nxt[i + 1];
    }
}
```

#### 3. 作者：Cure_Wing (4星)
**关键亮点**：
- 通过分割序列的方式，解释了交换操作的合理性。
- 代码简洁，逻辑清晰，适合快速实现。

**核心代码**：
```cpp
inline void work(){
    for(int i=1;i<=n;++i){
        int cnt=i;
        for(int j=i+1;j<=n;++j){
            if(a[j]<=a[cnt])
                cnt=j;
        }
        if(a[i]!=a[cnt]) std::swap(a[i],a[cnt]),i=cnt;
    }
}
```

### 最优关键思路与技巧

1. **贪心策略**：通过将当前元素与后续最小元素交换，确保字典序最小。
2. **预处理后缀最小值**：通过从后向前遍历，记录每个位置的最小值及其位置，优化查找过程。
3. **交换后跳过已处理区间**：在交换后，直接跳到最小元素的下一个位置，避免重复处理。

### 可拓展之处

- **类似问题**：可以考虑其他需要最小化或最大化序列字典序的问题，如通过多次交换或删除操作。
- **数据结构优化**：在更复杂的问题中，可以使用更高级的数据结构（如线段树）来优化查找最小值的过程。

### 推荐题目

1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心算法的经典应用。
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886) - 使用单调队列优化查找最小值。
3. [P3372 线段树 1](https://www.luogu.com.cn/problem/P3372) - 学习线段树的基本操作，适用于更复杂的区间查询问题。

### 个人心得摘录

- **调试经历**：在实现过程中，需要注意交换后位置的跳转，避免重复处理或遗漏某些区间。
- **踩坑教训**：在处理多个相同最小值时，选择最靠后的位置进行交换，确保字典序最小。
- **顿悟感想**：贪心策略的直观性和高效性在本问题中得到了充分体现，通过预处理可以大幅优化时间复杂度。

---
处理用时：35.96秒
# 题目信息

# Bassline

## 题目背景

fuwa↑ fuwa↑ fuwa↑ fuwa↑

赫尔德开始使用当下热潮的聊天软件 BassLine，那么第一步自然是加好友了！加好友既需要确认自己和对方有共同兴趣，又需要能加到足够多的好友。赫尔德将其抽象成了下面这个问题，让你来帮她解决。

## 题目描述

本题中，区间 $[l,r]$ 指所有大于等于 $l$ 且小于等于 $r$ 的整数组成的集合，如 $[3,3]$ 代表 $\{3\}$，$[3,7]$ 代表 $\{3,4,5,6,7\}$。

给定 $n$ 个区间，第 $i$ 个区间是 $[l_i,r_i]$。

你需要选择两个整数 $x\le y$，满足：

- 对于所有区间 $[l_i,r_i]$（$1\le i \le n$），以下两个条件之一满足：
	1. $[x,y]$ 被 $[l_i,r_i]$ 包含，换言之， $[x,y]\cap[l_i,r_i]=[x,y]$。
    2.  $[x,y]$ 与 $[l_i,r_i]$ 无交集，换言之，$[x,y]\cap[l_i,r_i]=\varnothing$。

若有 $k$ 个区间满足条件 1，则你的得分是 $k(y-x)$。输出你最大的可能的得分。

## 说明/提示

**【样例解释】**

对于样例，$[5,6]$ 是最优的区间之一，其含于 $[4,7],[5,9]$，且与 $[1,3],[7,10]$ 没有交集。此时 $k=2$，因此答案为 $2\times(6-5)=2$。$[1,3]$ 也是一个最优的区间。

$[5,7]$ 并非合法的区间，因为它与 $[7,10]$ 有交集，也并不含于 $[7,10]$。

---

**【数据范围】**

对于所有数据保证 $1 \le n \le 3 \times {10}^5$，$1 \le l_i \le r_i \le 3 \times {10}^5$。

- 子任务 1（20 分）：$n,l_i,r_i \le 10$；
- 子任务 2（20 分）：$n \le {10}^3$；
- 子任务 3（20 分）：$l_i, r_i \le {10}^3$；
- 子任务 4（40 分）：无特殊限制。

## 样例 #1

### 输入

```
4
1 3
4 7
5 9
7 10
```

### 输出

```
2
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地选择一个区间 $[x, y]$，使得它要么完全被某些给定区间包含，要么与所有给定区间无交集，并且最大化得分 $k(y - x)$。通过分析，我们可以得出以下关键思路：

1. **断点思想**：合法的区间 $[x, y]$ 必须位于某些“断点”之间，这些断点通常是给定区间的端点。通过标记这些断点，可以快速判断哪些区间是合法的。
2. **差分与前缀和**：为了快速计算某个区间被多少个给定区间覆盖，可以使用差分数组和前缀和来优化计算。
3. **贪心策略**：为了最大化得分，通常选择尽可能长的合法区间，因此可以通过贪心策略来选择 $x$ 和 $y$。

### 所选高星题解

#### 题解1：作者：dottle (★★★★★)
- **关键亮点**：
  - 清晰地提出了合法区间的条件，并通过标记端点来快速判断合法性。
  - 使用差分数组和前缀和来高效计算区间覆盖次数。
  - 代码简洁且高效，时间复杂度为 $O(n)$。
- **个人心得**：
  - 通过将左端点左移一个位置，简化了条件的判断，使得代码实现更加简洁。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++){
      scanf("%lld%lld",&x,&y);
      v[x-1]=1,v[y]=1;
      f[x]++,f[y+1]--;
      mx=max(mx,y);
  }
  for(int i=1;i<=mx;i++){
      sum+=f[i];
      if(v[i])ans=max(ans,sum*(i-pre)),pre=i+1;
  }
  ```
  - **实现思想**：通过差分数组 `f` 记录区间覆盖次数，前缀和 `sum` 计算当前点的覆盖次数，`v` 数组标记端点，最终通过遍历计算最大得分。

#### 题解2：作者：if_OF (★★★★☆)
- **关键亮点**：
  - 通过图形化分析，直观地展示了合法区间的选择方式。
  - 使用结构体记录每个点的区间起点和终点数量，简化了条件判断。
  - 代码逻辑清晰，易于理解。
- **核心代码**：
  ```cpp
  for(int i=left;i<=right;i++){
      ++cnt;
      if(x[i].beg || x[i-1].end) cnt=0;
      k+=x[i].beg;
      ans=max(ans,cnt*k);
      k-=x[i].end;
  }
  ```
  - **实现思想**：通过 `cnt` 记录当前合法区间的长度，`k` 记录当前区间的覆盖次数，最终通过遍历计算最大得分。

#### 题解3：作者：Lyccrius (★★★★☆)
- **关键亮点**：
  - 详细解释了合法区间的条件，并通过标记端点来快速判断合法性。
  - 使用差分数组和前缀和来高效计算区间覆盖次数。
  - 代码实现简洁且高效。
- **个人心得**：
  - 强调了 $k$ 的含义，并详细解释了如何通过差分数组和前缀和来计算覆盖次数。
- **核心代码**：
  ```cpp
  for(int i=1;i<=last;i++){
      cnt += cover[i];
      if(point[i]) {
          ans = std::max(ans, (long long)cnt * (i - pre));
          pre = i + 1;
      }
  }
  ```
  - **实现思想**：通过 `cnt` 记录当前点的覆盖次数，`point` 数组标记端点，最终通过遍历计算最大得分。

### 最优关键思路与技巧

1. **断点思想**：通过标记给定区间的端点，可以快速判断哪些区间是合法的。
2. **差分与前缀和**：通过差分数组和前缀和，可以高效地计算某个区间被多少个给定区间覆盖。
3. **贪心策略**：为了最大化得分，通常选择尽可能长的合法区间，因此可以通过贪心策略来选择 $x$ 和 $y$。

### 可拓展之处

- **类似问题**：类似的问题可以扩展到多维空间，例如在二维平面上选择矩形区域，满足某些条件并最大化得分。
- **算法套路**：差分与前缀和的思想可以广泛应用于区间覆盖、区间查询等问题。

### 推荐题目

1. **P1886 滑动窗口**：考察滑动窗口与区间最值问题。
2. **P3372 线段树 1**：考察区间修改与查询，适合练习差分与前缀和的应用。
3. **P5490 扫描线**：考察扫描线算法，适合练习区间覆盖与统计问题。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中遇到了数组越界或未开 `long long` 导致的问题，提醒我们在处理大数据时要注意数据类型的范围。
- **顿悟感想**：通过将左端点左移一个位置，简化了条件的判断，使得代码实现更加简洁，这种优化思路值得借鉴。

---
处理用时：38.07秒
# 题目信息

# 『MdOI R5』Message

## 题目描述

小 A 有一个群。这个群正在玩一个小游戏：给出一个函数 $f$，从某一个时间点起，发送第 $x$ 条消息，而 $f(x)=1$ 的群友会受到一个小惩罚。当群内消息总数达到 $m$ 时游戏结束。

但小 A 是个话痨，这段时间他在这个群发了 $n$ 条消息，他发的第 $i$ 条消息在整个消息记录里是第 $a_i$ 条消息。

但是小 A 不想受到惩罚，而小 A 恰好是管理员，他可以撤回**任何时刻、任何群成员发的任何消息**，注意这会导致这条消息之后的消息排名改变。

但是撤回消息太多容易被当成暴政，因此他要尽可能减少撤回信息次数，不管是自己的还是别人的。

接下来你也猜到你要干什么了：假如其他群成员不操作，给出 $n$、函数 $f$ 和 $a_i$，求出他至少要撤回几条消息。

## 说明/提示

【样例解释】

下面给出一种可能的方式：
- 小 A 先撤回第 $1$ 条消息（群友发的），他的四条消息在消息记录里现在是第 $1,5,7,10$ 条。
- 然后撤回第 $5$ 条消息（他自己发的），剩下三条消息在消息记录里现在是第 $1,6,9$ 条。

此时三条消息满足 $f(1)=f(6)=f(9)=0$，符合题意。

可以证明无法仅撤回一条消息达成要求。

【数据范围】

|Subtask|$n\le$|$m\le$|特殊性质|分值|
|:-:|:-:|:-:|:-:|:-:|
|1|$17$|$17$||$15$|
|2|$17$|$100$||$15$|
|3|$10^3$|$10^4$||$20$|
|4||$10^5$|$n=m$|$8$|
|5|$10^5$|$10^6$|A|$12$|
|6|$10^5$|$10^6$||$30$|

- 特殊性质 A：小 A 没有连发两条消息。

对于全部数据，$1\le n\le 10^5$，$1\le a_i\le m\le 10^6$，$a_i$ 严格递增，$f(i)\in \{0,1\}$。

## 样例 #1

### 输入

```
4 11
01101010001
2 6 8 11
```

### 输出

```
2
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何通过最少的撤回操作，使得小A的消息不受到惩罚。各题解的主要思路集中在贪心策略和动态规划上，大部分题解通过维护一个“撤回次数”变量来动态调整消息的排名，从而避免惩罚。以下是各题解的要点总结：

1. **贪心策略**：大多数题解采用贪心策略，即从前往后遍历小A的消息，若某条消息会导致惩罚，则撤回该消息，并更新后续消息的排名。这种策略的时间复杂度为O(n)，能够高效解决问题。
2. **动态规划**：部分题解尝试使用动态规划，但由于状态转移复杂，最终选择了贪心策略。动态规划的思路虽然理论上可行，但实现复杂且效率较低。
3. **优化技巧**：部分题解通过引入“撤回次数”变量，避免了每次撤回后对后续消息的重新计算，从而将时间复杂度从O(n^2)优化到O(n)。

### 所选高星题解

#### 题解1：作者：yummy (赞：7)
- **星级**：5星
- **关键亮点**：思路清晰，代码简洁，优化到位。通过维护一个“撤回次数”变量，避免了每次撤回后对后续消息的重新计算，时间复杂度为O(n)。
- **个人心得**：作者通过分析撤回别人消息和撤回自己消息的优劣，得出了撤回自己消息更优的结论，并在此基础上实现了高效的贪心算法。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005];
char f[1000005];
int main()
{
	int withdrawn=0; 
	scanf("%d%d%s",&n,&m,f+1);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(f[a[i]-withdrawn]=='1')
			withdrawn++;
	}
	printf("%d",withdrawn);
	return 0;
}
```

#### 题解2：作者：igAC (赞：5)
- **星级**：4星
- **关键亮点**：通过感性证明撤回自己消息比撤回别人消息更优，并在此基础上实现了贪心算法。代码简洁，思路清晰。
- **个人心得**：作者通过举例说明了撤回别人消息的劣势，进一步验证了贪心策略的正确性。

```cpp
#include<cstdio>
#include<iostream>
#define N 1000005
using namespace std;
bool vis[N];
int n,m;
int a[N];
int cnt=0;
int main(){
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;++i){
        char c;
        cin>>c;
        vis[i]=(c=='1');
    }
    for(int i=1;i<=m;++i) scanf("%d",&a[i]);
    for(int i=1;i<=m;++i){
        int p=a[i]-cnt;
        if(vis[p]) ++cnt;
    }
    printf("%d",cnt);
    return 0;
}
```

#### 题解3：作者：Nygglatho (赞：2)
- **星级**：4星
- **关键亮点**：通过图示和详细分析，说明了撤回自己消息的最优性，并在此基础上实现了贪心算法。代码简洁，思路清晰。
- **个人心得**：作者通过图示和详细分析，进一步验证了贪心策略的正确性。

```cpp
#include "bits/stdc++.h"
using namespace std;
int x[1919810];
int delt = 1;
int cnt;
string st;
int main() {
    int n, m;
    scanf ("%d%d", &n, &m);
    cin >> st;
    for (int i = 1; i <= n; ++i) scanf ("%d", &x[i]);
    for (int i = 1; i <= n; ++i) {
        if (st[x[i] - delt] == '1') {
            ++delt;
            ++cnt;
        }
    }
    printf ("%d", cnt);
}
```

### 最优关键思路与技巧

1. **贪心策略**：从前往后遍历小A的消息，若某条消息会导致惩罚，则撤回该消息，并更新后续消息的排名。这种策略的时间复杂度为O(n)，能够高效解决问题。
2. **撤回次数变量**：通过维护一个“撤回次数”变量，避免了每次撤回后对后续消息的重新计算，从而将时间复杂度从O(n^2)优化到O(n)。

### 可拓展之处

类似的问题可以出现在其他需要动态调整顺序的场景中，如任务调度、资源分配等。贪心策略和动态维护变量的技巧在这些问题中同样适用。

### 推荐题目

1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 个人心得总结

- **调试经历**：部分题解在实现过程中遇到了时间复杂度较高的问题，通过引入“撤回次数”变量，成功优化了算法。
- **踩坑教训**：动态规划的思路虽然理论上可行，但实现复杂且效率较低，最终选择了贪心策略。
- **顿悟感想**：通过分析撤回别人消息和撤回自己消息的优劣，得出了撤回自己消息更优的结论，并在此基础上实现了高效的贪心算法。

---
处理用时：40.37秒
# 题目信息

# [DTOI 2023] B. 去年 11 月卵梦蕾简易钨丝

## 题目背景

# 大样例已修复

![](https://cdn.luogu.com.cn/upload/image_hosting/4il8fn7w.png)

## 题目描述

给定序列 $\{a_n\}$，支持两种形如 `opt x` 操作：

1. `1 x`：删除一个数 $x$，若序列中没有 $x$，则输出 $-1$ 并跳过本次操作，**若有多个 $x$，则仅删除一个**。

2. `2 x`：向序列中插入一个数 $x$。

**对于每个未被跳过的操作**，试求出 $a$ 的一个排列 $p$，最小化 $\sum \limits_{i=1}^{n} \lvert p_{i+1}-p_i\rvert$ 的值，即最小化 $\lvert p_2-p_1\rvert+\lvert p_3-p_2\rvert+\dots+\lvert p_{n+1}-p_n\rvert$ 的值，其中 $p_{n+1}=p_1$。

**保证任意时刻序列内至少有 $1$ 个数。**

---
$p$ 是 $a$ 的排列当且仅当对于 $\forall x$，$\sum [p_i=x]=\sum [a_i=x]$。

简而言之，$p$ 是 $a$ 经过某种方式重排后的结果。 

例如 $\{1,1,4,5,1,4\}$ 是 $\{1,5,4,1,4,1\}$ 的一个排列，但是 $\{1,5,4,1,4,7\}$ 不是。

## 说明/提示

#### 【样例 1 解释】
对于第一个询问，删除了序列中的数 $4$，则当前序列为$ 1, 2, 3, 10 $， 可以证明 $18$ 为当前序列的最小答案。
	
对于第二个询问，删除了序列中的数 $10$，则当前序列为$ 1, 2, 3 $， 可以证明 $4$ 为当前序列的最小答案。
	
对于第三个询问，向序列中添加了一个数 $9$，则当前序列为$ 1, 2, 3, 9 $， 可以证明 $16$ 为当前序列的最小答案。

#### 【样例 2】

见附加文件中的 `abs/abs2.in` 与 `abs/abs2.out`。

该样例满足测试点 $1\sim 4$ 的限制。

#### 【样例 3】

见附加文件中的 `abs/abs3.in` 与 `abs/abs3.out`。

该样例满足测试点 $7\sim 10$ 的限制。

#### 【数据范围与提示】
记 $w$ 为值域大小，对于所有测试数据，保证 $n,q\leq 10^6$，$0\leq w\leq 10^6$。
	
每个测试点的具体限制见下表：

| 测试点编号 | $n,q\leq$ | $w$ |
| :----------: | :----------: | :----------: |
| $1\sim 4$ | $100$ | $10$ |
| $5\sim 6$ | $10^3$ | $10^3$ |
| $7\sim 10$ | $10^6$ | $10^6$ |


## 样例 #1

### 输入

```
5 3
1 2 3 4 10
1 4
1 10
2 9```

### 输出

```
18
4
16```

# AI分析结果

### 综合分析与结论

本题的核心在于维护序列的极值（最大值和最小值），并快速计算每次操作后的最小排列代价。所有题解都基于一个关键观察：当序列单调递增时，排列的代价最小，且最小代价为 `2 * (max - min)`。因此，题解的难点主要集中在如何高效维护序列的极值。

大多数题解使用了 `multiset` 或 `priority_queue` 来维护极值，时间复杂度为 `O((n + q) log n)`，能够通过题目要求。部分题解还提供了对算法的优化思路，如使用桶和堆的结合来进一步优化删除操作。

### 所选高星题解

#### 题解1：mc123456 (5星)
**关键亮点**：
- 思路清晰，直接指出当序列单调递增时，排列代价最小。
- 使用 `multiset` 维护序列，代码简洁且高效。
- 时间复杂度分析明确，代码可读性强。

**核心代码**：
```cpp
multiset<int> s;
while (q--) {
    int op, x;
    cin >> op >> x;
    if (op == 1) {
        auto it = s.find(x);
        if (it == s.end()) {
            cout << -1 << endl;
            continue;
        }
        s.erase(it);
    } else {
        s.emplace(x);
    }
    cout << (*(--s.end()) - *s.begin()) * 2 << endl;
}
```
**实现思想**：通过 `multiset` 维护序列，插入和删除操作均通过 `multiset` 的 `find` 和 `erase` 方法实现，查询极值时直接取 `begin` 和 `rbegin`。

#### 题解2：WsW_ (4星)
**关键亮点**：
- 详细解释了为什么单调递增时排列代价最小，并通过数轴直观说明。
- 使用 `multiset` 维护序列，并特别指出删除操作时不能直接 `erase(x)`，而是要通过迭代器删除。
- 代码结构清晰，注释详细。

**核心代码**：
```cpp
multiset<int> s;
while (q--) {
    cin >> opt >> a;
    if (opt == 1) {
        it = s.lower_bound(a);
        if (*it != a) {
            cout << -1 << '\n';
            continue;
        }
        s.erase(it);
    } else {
        s.insert(a);
    }
    int ans = *(--s.end()) - *s.begin();
    cout << 2 * ans << '\n';
}
```
**实现思想**：通过 `multiset` 维护序列，删除操作时使用 `lower_bound` 找到迭代器后再删除，确保只删除一个元素。

#### 题解3：Cure_Wing (4星)
**关键亮点**：
- 使用优先队列维护极值，结合桶来优化删除操作。
- 提供了对算法的优化思路，避免在删除极值时遍历整个桶。
- 代码结构清晰，时间复杂度分析明确。

**核心代码**：
```cpp
priority_queue<int> b;
priority_queue<int, vector<int>, greater<int>> c;
while (q--) {
    cin >> opt >> a;
    if (opt == 1) {
        if (in[a] == 0) {
            cout << -1 << '\n';
            continue;
        } else {
            --in[a];
            ++out[a];
            ++out2[a];
        }
    } else {
        b.push(a);
        c.push(a);
        ++in[a];
    }
    while (!b.empty() && out[b.top()]) {
        --out[b.top()];
        b.pop();
    }
    while (!c.empty() && out2[c.top()]) {
        --out2[c.top()];
        c.pop();
    }
    cout << (b.top() - c.top()) * 2 << '\n';
}
```
**实现思想**：通过两个优先队列分别维护最大值和最小值，结合桶来标记删除的元素，确保在删除极值时能够快速更新。

### 最优关键思路与技巧

1. **单调性优化**：通过观察发现，当序列单调递增时，排列的代价最小，且最小代价为 `2 * (max - min)`。这一结论大大简化了问题。
2. **数据结构选择**：使用 `multiset` 或 `priority_queue` 来维护序列的极值，能够高效地支持插入、删除和查询操作。
3. **删除操作优化**：在删除元素时，特别是删除极值时，通过标记或迭代器的方式避免遍历整个数据结构，进一步优化时间复杂度。

### 可拓展之处

- **类似问题**：类似的问题可以通过维护极值或利用单调性来优化，如滑动窗口的最大值、最小值问题。
- **数据结构应用**：掌握 `multiset` 和 `priority_queue` 的使用场景，能够在许多动态维护极值的问题中快速找到解决方案。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886) - 动态维护窗口内的最大值和最小值。
2. [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378) - 练习优先队列的基本操作。
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 使用优先队列解决贪心问题。

### 个人心得总结

- **调试经历**：部分题解提到在删除操作时，直接 `erase(x)` 会删除所有相同的元素，因此需要通过迭代器删除单个元素。这一点在实际编码中容易忽略，导致错误。
- **顿悟感想**：通过数轴直观理解单调性与排列代价的关系，能够快速抓住问题的核心，避免复杂的推导。

---
处理用时：47.26秒
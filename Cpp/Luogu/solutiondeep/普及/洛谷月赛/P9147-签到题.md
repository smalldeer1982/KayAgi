# 题目信息

# 签到题

## 题目背景

著名的【数据删除】是一个热爱旅游的人！这一天他来到了神秘的 ZYL 国度。

入海关的时候他被问到了一个题目，如果答对他就可以顺利到达 ZYL 的首都 ZY 了！身为堂堂【数据删除】，他居然还花了 $10^{-233}$ 秒才想出来做法，实在是有点难的！于是他决定拿来考考你。

## 题目描述

给定长度为 $n$ 的序列 $a$，保证 $a_i$ 是**正整数**。你需要选择一个位置 $i$ 并将 $a_i$ 修改为一个**任意的整数**。最大化最长**严格**上升子串的长度。

所谓严格上升子串，就是从序列中选出位置**连续**的若干个数字，满足后一个数字比前一个大（而不能相等或小于）。

如序列 $[1,4,2,3,5]$ 中，子序列 $[2,3,5]$ 就是严格上升子串，而 $[4,2,3]$（不上升）和 $[1,2,3]$（不连续）则不是。

## 说明/提示

**【样例解释 \#1】**

对于样例 \#1，我们可以将序列 $[1,4,2,2,3]$ 中的第三个位置修改为 $5$，得到新序列 $[1,4,5,2,3]$。这个序列的最长严格上升子串是 $[1,4,5]$，长度为 $3$。

容易证明，不存在一种修改方案使得修改后的序列的最长严格上升子串的长度大于 $3$。

---

**【样例解释 \#4】**

对于样例 \#4，我们可以将序列 $[8,2,3,1,4,5]$ 中的第三个位置修改为 $0$，得到新序列 $[8,2,0,1,4,5]$。这个序列的最长严格上升子串是 $[0,1,4,5]$，长度为 $4$。

容易证明，不存在一种修改方案使得修改后的序列的最长严格上升子串的长度大于 $4$。

---

**【数据范围】**

对于前 $20\%$ 的数据，满足 $n \le 5$，$a_i \le 5$。  
对于前 $40\%$ 的数据，满足 $n \le 10$，$a_i \le 10$。  
对于前 $70\%$ 的数据，满足 $n \le 300$。  
对于 $100 \%$ 的数据，满足 $1 \le n \le {10}^6$，$1 \le a_i \le {10}^9$。

## 样例 #1

### 输入

```
5
1 4 2 2 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5
1 2 3 2 1
```

### 输出

```
4
```

## 样例 #3

### 输入

```
5
1 2 3 1 5
```

### 输出

```
5
```

## 样例 #4

### 输入

```
6
8 2 3 1 4 5
```

### 输出

```
4
```

## 样例 #5

### 输入

```
6
7 2 9 4 5 6
```

### 输出

```
5
```

# AI分析结果

### 综合分析与结论

本题的核心目标是通过修改序列中的一个元素，使得序列中的最长严格上升子串的长度最大化。大多数题解都采用了预处理的方法，计算每个位置作为严格上升子串的开头或结尾的长度，然后通过枚举修改的位置来更新答案。整体思路较为一致，但在细节处理和优化上有所不同。

### 所选高星题解

#### 1. **题解作者：Iniaugoty (5星)**
   - **关键亮点**：思路清晰，预处理和枚举修改位置的逻辑非常简洁。通过计算每个位置作为严格上升子串的开头和结尾的长度，然后通过枚举修改位置来更新答案，时间复杂度为O(n)。
   - **个人心得**：作者提到不需要特判边界情况，通过全局变量初始化为0的特性简化了代码实现。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++)
         e[i]=a[i]>a[i-1]?e[i-1]+1:1;
     for(int i=n;i>=1;i--)
         b[i]=a[i]<a[i+1]?b[i+1]+1:1;
     for(int i=1;i<=n;i++){
         if(a[i-1]<a[i+1]-1)
             ans=max(ans,e[i-1]+b[i+1]+1);
         if(a[i-1]>=a[i])
             ans=max(ans,e[i-1]+1);
         if(a[i]>=a[i+1])
             ans=max(ans,b[i+1]+1);
     }
     ```

#### 2. **题解作者：ttq012 (4.5星)**
   - **关键亮点**：详细解释了修改位置的三种情况，并且通过预处理f和g数组来快速计算修改后的最长严格上升子串长度。代码实现简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++)
         if(a[i]>a[i-1]) f[i]=f[i-1]+1;
         else f[i]=1;
     for(int i=n;i;i--)
         if(a[i]<a[i+1]) g[i]=g[i+1]+1;
         else g[i]=1;
     for(int i=1;i<=n;i++)
         if(a[i+1]-a[i-1]>=2) mx=max(mx,f[i-1]+g[i+1]+1);
         else mx=max(mx,max(f[i-1]+1,g[i+1]+1));
     ```

#### 3. **题解作者：ncwzdlsd (4星)**
   - **关键亮点**：通过双指针预处理每个位置的严格上升子串长度，然后枚举修改位置来更新答案。思路清晰，代码实现简洁。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++) g[i]=a[i]>a[i-1]?g[i-1]+1:1;
     for(int i=n;i;i--) f[i]=a[i]<a[i+1]?f[i+1]+1:1;
     for(int i=1;i<=n;i++){
         if(a[i+1]-a[i-1]>1) ans=max(ans,g[i-1]+f[i+1]+1);
         else ans=max(ans,max(g[i-1]+1,f[i+1]+1));
     }
     ```

### 最优关键思路与技巧

1. **预处理**：通过预处理每个位置作为严格上升子串的开头和结尾的长度，可以快速计算修改后的最长严格上升子串长度。
2. **枚举修改位置**：枚举每个位置，考虑将其修改为前后元素之间的值，或者延长前或后的严格上升子串。
3. **边界处理**：通过全局变量初始化为0的特性，简化了边界条件的处理。

### 可拓展之处

1. **类似题目**：可以扩展到修改多个位置的情况，或者修改为任意值（不限于整数）。
2. **算法套路**：类似的预处理和枚举修改位置的思路可以应用于其他序列优化问题，如最长不下降子串、最长回文子串等。

### 推荐题目

1. **P1020 导弹拦截**：考察最长不上升子序列和最长上升子序列。
2. **P1091 合唱队形**：考察双向最长上升子序列。
3. **P1439 【模板】最长公共子序列**：考察最长公共子序列的优化解法。

### 个人心得总结

- **调试经历**：部分题解提到在处理边界条件时容易出错，通过全局变量初始化为0的特性可以简化代码。
- **顿悟感想**：通过预处理和枚举修改位置的思路，可以高效解决序列优化问题，避免暴力枚举带来的高时间复杂度。

---
处理用时：39.11秒
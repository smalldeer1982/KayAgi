# 题目信息

# 「GMOI R2-T2」猫耳小

## 题目背景

**本题与 [加强版](https://www.luogu.com.cn/problem/P9202) 的区别在于数据范围和输出格式。在这一版本中，$n\le 5\times 10^3$，值域为 $5\times 10^3$，你不需要给出构造。**

![](https://cdn.luogu.com.cn/upload/image_hosting/r8a6ylx3.png)

## 题目描述

小 R 是一个可爱的猫耳女孩子，她喜欢研究数列的 $\operatorname{mex}\text{*}$。

现在她有一个长度为 $n$ 的数列 $a$。她讨厌整数 $k$，因此她希望修改数列 $a$ 的若干个元素为任意**自然数**，使得 $a$ 的任意**连续非空子串**的 $\operatorname{mex}$ 都不等于 $k$。

请你求出最少需要修改多少个元素。

$\text{*}$ 本题中，数列的 $\operatorname{mex}$ 被定义为数列中最小未出现的**自然数**，例如：

- $\operatorname{mex}\{1,2,3\}=0$，因为 $0$ 是自然数。
- $\operatorname{mex}\{0,1,3\}=2$。
- $\operatorname{mex}\{0,1,2\}=3$。

## 说明/提示

**样例解释**

一种方案是将 $\{1,0,1,3,0\}$ 改为 $\{1,1,1,3,2\}$，共改动两个元素。

可以证明不存在更优的方案。

---

**本题使用 Subtask 捆绑测试。**

| Subtask | $n\le$ | $k\le$ | $a_i\le$ | 特殊性质 | 对应测试点 | 总分 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $6$ | $6$ | $6$ | $-$ | $1\sim 2$ | $10$ |
| $1$ | $100$ | $5\times 10^3$ | $5\times 10^3$ | $-$ | $3\sim 5$ | $20$ |
| $2$ | $5\times 10^3$ | $1$ | $5\times 10^3$ | $-$ | $6\sim 10$ | $20$ |
| $3$ | $5\times 10^3$ | $5\times 10^3$ | $5\times 10^3$ | $\bf A$ | $11\sim 15$ | $20$ |
| $4$ | $5\times 10^3$ | $5\times 10^3$ | $5\times 10^3$ | $-$ | $16\sim 20$ | $30$ |

特殊性质 $\bf A$：保证 $a_i < k$。

对于 $100\%$ 的数据，$1\le n\le 5\times 10^3$，$0\le k,a_i\le 5\times 10^3$。

## 样例 #1

### 输入

```
5 2
1 0 1 3 0```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心在于如何通过最少的修改次数，使得数列的任意连续子串的 $\operatorname{mex}$ 都不等于 $k$。大多数题解都采用了贪心策略，通过遍历数组并维护当前区间的 $\operatorname{mex}$ 值，当 $\operatorname{mex}$ 等于 $k$ 时，修改当前元素为 $k$，从而避免后续子串的 $\operatorname{mex}$ 等于 $k$。部分题解还通过特判 $k=0$ 和 $k$ 较大的情况来优化算法。

### 所选高星题解

#### 1. 作者：rui_er (★★★★★)
**关键亮点**：
- 详细证明了贪心算法的正确性，特别是引理一和引理二的引入，增强了算法的可信度。
- 代码清晰，逻辑严谨，通过维护当前区间的 $\operatorname{mex}$ 值来动态调整修改策略。
- 特判了 $k=0$ 和 $k$ 较大的情况，优化了算法的执行效率。

**核心代码**：
```cpp
for(int l = 0, r = 1; r <= n; r++) {
    if(a[r] > k) continue;
    if(a[r] == k) {
        while(++l < r) if(a[l] < k) --cnt[a[l]];
        mex = 0;
    }
    else {
        ++cnt[a[r]];
        while(cnt[mex]) ++mex;
        if(mex == k) {
            ++ans;
            while(++l < r) if(a[l] < k) --cnt[a[l]];
            --cnt[a[r]];
            b[r] = k;
            mex = 0;
        }
    }
}
```
**实现思想**：通过维护当前区间的 $\operatorname{mex}$ 值，当 $\operatorname{mex}$ 等于 $k$ 时，修改当前元素为 $k$，并清空当前区间的统计信息。

#### 2. 作者：wwxxbb (★★★★)
**关键亮点**：
- 通过使用 `bitset` 来记录小于 $k$ 的元素是否出现过，优化了空间和时间复杂度。
- 特判了 $k=0$ 和 $k$ 较大的情况，简化了问题。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for (int i = 1, x; i <= n; i ++) {
    cin >> x;
    if (x == k) { clear(); continue; }
    if (x < k && !st[x]) {
        st[x] = 1;
        b[++ top] = x;
        ++ cnt;
    }
    if (cnt == k) {
        ++ ans;
        clear();
    }
}
```
**实现思想**：通过 `bitset` 记录小于 $k$ 的元素是否出现过，当所有小于 $k$ 的元素都出现过时，修改当前元素为 $k$，并清空记录。

#### 3. 作者：ny_jerry2 (★★★★)
**关键亮点**：
- 通过分类讨论当前元素与 $k$ 的关系，简化了问题的处理逻辑。
- 代码简洁，逻辑清晰，易于理解。
- 特判了 $k=0$ 的情况，优化了算法的执行效率。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    if(a[i]>m) continue;
    if(a[i]==m) { cnt=0; memset(v,0,sizeof v); continue; }
    if(a[i]<m && !v[a[i]]) { v[a[i]]=1; cnt++; }
    if(cnt==m) { cnt=0; ans++; memset(v,0,sizeof v); }
}
```
**实现思想**：通过分类讨论当前元素与 $k$ 的关系，当所有小于 $k$ 的元素都出现过时，修改当前元素为 $k$，并清空记录。

### 最优关键思路与技巧

1. **贪心策略**：通过遍历数组并维护当前区间的 $\operatorname{mex}$ 值，当 $\operatorname{mex}$ 等于 $k$ 时，修改当前元素为 $k$，从而避免后续子串的 $\operatorname{mex}$ 等于 $k$。
2. **特判优化**：特判 $k=0$ 和 $k$ 较大的情况，简化问题并优化算法执行效率。
3. **数据结构优化**：使用 `bitset` 或数组来记录小于 $k$ 的元素是否出现过，优化空间和时间复杂度。

### 可拓展之处

- **类似问题**：可以拓展到其他与 $\operatorname{mex}$ 相关的问题，如求所有子串的 $\operatorname{mex}$ 值的最小值或最大值。
- **算法套路**：贪心算法在解决类似问题时非常有效，特别是在需要最小化修改次数或最大化某种性质的情况下。

### 推荐题目

1. [P9202 - 猫耳小（加强版）](https://www.luogu.com.cn/problem/P9202)
2. [P5495 - Mex Sequence](https://www.luogu.com.cn/problem/P5495)
3. [P5496 - Mex Sequence II](https://www.luogu.com.cn/problem/P5496)

### 个人心得

- **调试经历**：在实现贪心算法时，维护当前区间的 $\operatorname{mex}$ 值需要特别注意边界条件和清空统计信息的时机，否则容易导致错误。
- **顿悟感想**：通过特判 $k=0$ 和 $k$ 较大的情况，可以大大简化问题的处理逻辑，提高算法的执行效率。

---
处理用时：47.66秒
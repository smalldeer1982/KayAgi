# 题目信息

# 去年天气旧亭台

## 题目背景

依旧是过往的天气，过往的楼台烟雨。时间悄悄流逝着，山河仍在，人却已不是过去的人……

## 题目描述

登上楼台，旧时满面沉灰的地板映入眼帘。

共有 $n$ 块地板，地板分为两类，第 $i$ 块地板的类别用 $c_i$ 表示，积灰程度用 $a_i$ 表示。**注意 $c_i$ 为 $0$ 或 $1$。**

现在要清理这些地板上的灰尘。每次操作中，你可以：

+ 选择两个下标 $i,j$，满足 $1\leq i\leq j\leq n$， $c_i=c_j$，**且第 $i$ 块和第 $j$ 块地板上的灰尘均未被清理过**；
+ 花费 $a_i+a_j$ 的能量清理**第 $i$ 块到第 $j$ 块所有地板**上的灰尘。

求清理完所有地板上的灰尘至少要多少能量。

## 说明/提示

**【样例 1 解释】**

- 对于第一组数据，直接花费 $a_1+a_6=5$ 的能量清理所有灰尘。
- 对于第二组数据，先花费 $a_1+a_1=6$ 的能量清理第一个地板上的灰尘，再花费 $a_2+a_8=7$ 的能量清理剩余灰尘。

**【数据规模与约定】**

对于 $10\%$ 的数据，保证 $T\le 10$，$n\le 10$；

对于 $40\%$ 的数据，保证 $T\le 20$，$n\le 10^3$；

另有 $10\%$ 的数据，保证 $c_i=1$；

对于 $100\%$ 的数据，保证 $1 \le T \le 10^5$，$1 \le n,\sum n\le 2 \times 10^6$，$c_i \in \{0,1\}$，$1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
2
6
1 1 4 5 1 4
1 0 0 1 0 1
8
3 1 4 1 5 9 2 6
1 0 1 0 1 0 1 0```

### 输出

```
5
13```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地清理地板上的灰尘，要求最小化能量消耗。题解主要分为两类思路：贪心算法和动态规划（DP）。贪心算法通过分类讨论直接得出最优解，而动态规划则通过状态转移方程逐步求解。贪心算法的时间复杂度较低（O(n)），适合大规模数据；动态规划虽然思路清晰，但部分实现存在优化空间。

### 所选高星题解

#### 1. 作者：_JF_ (赞：32)  
**星级：5星**  
**关键亮点：**  
- 通过分类讨论（首尾地板类型相同或不同）直接得出最优解，思路清晰且简洁。
- 使用反证法证明了贪心策略的正确性，增强了算法的可信度。
- 代码实现简洁，时间复杂度为O(n)，适合大规模数据。

**核心代码：**
```cpp
if(c[1]==c[n]) {
    cout<<a[1]+a[n]<<endl;
    continue;
}
int ans=LONG_LONG_MAX;
for(int i=1;i<n;i++) {
    if(c[i]==c[1]&&c[i+1]==c[n])
        ans=min(ans,a[i]+a[1]+a[n]+a[i+1]);
}
cout<<ans<<endl;
```
**实现思想：**  
- 如果首尾地板类型相同，直接清理整个区间。
- 否则，寻找一个分割点，使得前半段和后半段分别满足首尾类型相同，并计算最小能量消耗。

#### 2. 作者：zhlzt (赞：11)  
**星级：4星**  
**关键亮点：**  
- 使用线性DP，状态转移方程清晰，优化了时间复杂度。
- 通过维护两个变量（ans1和ans2）分别记录不同地板类型的最小能量消耗，避免了重复计算。
- 代码可读性强，适合理解DP的初学者。

**核心代码：**
```cpp
long long ans1=1e15,ans2=1e15;
for(int i=1;i<=n;i++) {
    if(c[i]==0) ans1=min(ans1,dp[i-1]+a[i]),dp[i]=ans1+a[i];
    else ans2=min(ans2,dp[i-1]+a[i]),dp[i]=ans2+a[i];
}
printf("%lld\n",dp[n]);
```
**实现思想：**  
- 使用DP数组记录清理前i块地板的最小能量消耗。
- 通过ans1和ans2分别维护当前地板类型为0和1的最小能量消耗，避免重复计算。

#### 3. 作者：Iniaugoty (赞：3)  
**星级：4星**  
**关键亮点：**  
- 动态规划优化思路清晰，通过前缀最小值优化了时间复杂度。
- 使用两个变量（f[0]和f[1]）分别记录不同地板类型的最小能量消耗，减少了状态转移的复杂度。
- 代码实现简洁，适合大规模数据。

**核心代码：**
```cpp
for(int i=2;i<=n;i++) {
    f[c[i]]=min(f[c[i]],dp[i-1]+a[i]);
    dp[i]=f[c[i]]+a[i];
}
return dp[n];
```
**实现思想：**  
- 使用DP数组记录清理前i块地板的最小能量消耗。
- 通过f[0]和f[1]分别维护当前地板类型为0和1的最小能量消耗，减少状态转移的复杂度。

### 最优关键思路与技巧

1. **贪心算法**：通过分类讨论直接得出最优解，时间复杂度低，适合大规模数据。
2. **动态规划优化**：通过前缀最小值或维护变量减少状态转移的复杂度，提升算法效率。
3. **反证法**：用于证明贪心策略的正确性，增强算法的可信度。

### 可拓展之处

- **类似算法套路**：贪心算法和动态规划在区间划分问题中应用广泛，如区间覆盖、区间调度等。
- **数据结构优化**：可以使用线段树或堆进一步优化动态规划的实现。

### 推荐题目

1. **P1880 [NOI1995]石子合并**：考察区间DP，与本题的区间划分思路相似。
2. **P1040 加分二叉树**：考察树形DP，与本题的DP优化思路相似。
3. **P1090 [NOIP2004 提高组] 合并果子**：考察贪心算法，与本题的贪心策略相似。

### 个人心得摘录

- **_JF_：** 通过反证法证明了贪心策略的正确性，增强了算法的可信度。
- **zhlzt：** 使用线性DP，状态转移方程清晰，优化了时间复杂度。
- **Iniaugoty：** 动态规划优化思路清晰，通过前缀最小值优化了时间复杂度。

---
处理用时：38.46秒
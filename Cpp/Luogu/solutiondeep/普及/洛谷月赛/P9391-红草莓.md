# 题目信息

# 红草莓

## 题目描述

有一个由 $n$ 颗珍珠串成的项链，项链是一个环，首尾相连。其中有一颗珍珠上有特殊的记号，我们称它为**起始珍珠**。

有个外星人很会发射宇宙射线，他依次发射了 $m$ 轮宇宙射线，第 $i$ 轮有一个参数 $a_i$，表示：

- 外星人从起始珍珠开始数，起始珍珠是 $0$ 号，起始珍珠的下一个珍珠是 $1$ 号，以此类推（数完一圈后还会继续，例如 $n$ 号珍珠仍然是起始珍珠，$n+1$ 号珍珠是起始珍珠的下一个珍珠）。外星人会对编号为 $0,a_i,2a_i,\dots$ 这些 $a_i$ 倍数位置上的珍珠都发射一次宇宙射线。

一开始所有珍珠都是红色的，而当一个珍珠被发射宇宙射线后就会被从红色染成蓝色。

你需要输出：对于每轮操作，有多少个操作前为红色的珍珠被这轮操作变成了蓝色。

## 说明/提示

**【样例解释】**

如图是初始时以及每次操作后各珍珠的颜色，起始珍珠编号为 $0$，可以看到，每次操作新染蓝的珍珠数量分别为 $1,1,2,0,2,0$：

![](https://cdn.luogu.com.cn/upload/image_hosting/mt4dg5ap.png)

---

**【数据范围】**

对于全部数据：$1\leq n,m\leq 5\times 10^5$，$1\leq a_i\leq n$。

|     子任务编号     |    $n\leq$     |    $m\leq$     |  特殊限制   | 分值 |
| :----------------: | :------------: | :------------: | :---------: | :--: |
| $\text{Subtask 1}$ |     $100$      |     $100$      |     无      | $15$ |
| $\text{Subtask 2}$ |     $1000$     |     $1000$     |     无      | $15$ |
| $\text{Subtask 3}$ |     $10^5$     |     $10^5$     | $a_i\mid n$ | $20$ |
| $\text{Subtask 4}$ |     $10^5$     |      $10$      |     无      | $20$ |
| $\text{Subtask 5}$ | $5\times 10^5$ | $5\times 10^5$ |     无      | $30$ |

---

![](https://cdn.luogu.com.cn/upload/image_hosting/nzd79suj.png)

## 样例 #1

### 输入

```
6 6
6 3 4 2 5 1
```

### 输出

```
1 1 2 0 2 0
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地模拟环状结构中的染色操作，并统计每次操作中新染色的珍珠数量。多个题解提供了不同的思路，主要分为以下几类：

1. **暴力模拟+剪枝**：通过直接模拟染色过程，结合剪枝优化（如提前终止、跳过已处理的操作）来减少时间复杂度。
2. **数学优化**：利用数学性质（如最大公约数、最小公倍数）来减少不必要的计算，优化时间复杂度。
3. **调和级数优化**：通过调和级数的性质，优化时间复杂度，确保在较大数据范围内仍能高效运行。

综合来看，**数学优化**和**调和级数优化**的题解表现较好，能够在保证时间效率的同时，提供清晰的思路和简洁的代码实现。

### 所选高星题解

#### 1. 作者：RNTBW (5星)
**关键亮点**：
- 利用最大公约数（GCD）的性质，将问题转化为对GCD倍数的处理，避免了重复计算。
- 通过调和级数的性质，优化时间复杂度，确保在大数据范围内仍能高效运行。
- 代码简洁，逻辑清晰，易于理解。

**个人心得**：
- 通过数学推导，发现问题的本质是GCD的倍数问题，从而简化了处理逻辑。
- 调和级数的应用使得时间复杂度得到了显著优化。

**核心代码**：
```cpp
int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++) {
        scanf("%d", &k); s = 0;
        now = __gcd(k, n);
        if(vis[now] || f) { putchar('0'); putchar(' '); continue; }
        for(int j = now; j <= n; j += now)
            if(!vis[j]) vis[j] = 1, s++;
        printf("%d ", s);
        if(now == 1) f = 1;
    }
    return 0;
}
```

#### 2. 作者：Link_Cut_Y (4星)
**关键亮点**：
- 通过GCD的性质，将问题转化为对GCD倍数的处理，避免了重复计算。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++) {
        int s; scanf("%d", &s);
        if(st[gcd(n, s)]) { printf("%d ", 0); continue; }
        st[gcd(n, s)] = true;
        int cnt = 0, now = 0; s = gcd(n, s);
        for(int i = 0; i < n / s; i++) {
            if(!col[i * s]) cnt++;
            col[i * s] = true;
        }
        printf("%d ", cnt);
    }
}
```

#### 3. 作者：船酱魔王 (4星)
**关键亮点**：
- 通过GCD的性质，将问题转化为对GCD倍数的处理，避免了重复计算。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
int main() {
    scanf("%d%d", &n, &m);
    int x; int now;
    for(int i = 1; i <= m; i++) {
        scanf("%d", &x);
        x = gcd(n, x);
        if(sgn[x] == 1) { printf("0 "); continue; }
        sgn[x] = 1; now = 0;
        for(int j = 0; j <= n - 1; j += x) {
            if(vis[j] == 0) { vis[j] = 1; now++; }
        }
        printf("%d ", now);
    }
    printf("\n");
    return 0;
}
```

### 最优关键思路与技巧

1. **利用GCD性质**：通过计算GCD，将问题转化为对GCD倍数的处理，避免了重复计算，显著优化了时间复杂度。
2. **调和级数优化**：通过调和级数的性质，确保在大数据范围内仍能高效运行。
3. **剪枝优化**：通过提前终止和跳过已处理的操作，减少不必要的计算，提高效率。

### 可拓展之处

- **同类型题**：类似的问题可以考察环状结构中的其他操作，如染色、标记等，利用GCD或调和级数进行优化。
- **类似算法套路**：在处理环状结构或周期性问题时，可以考虑利用数学性质（如GCD、LCM）来简化问题，优化时间复杂度。

### 推荐题目

1. **P1896 [SCOI2005]互不侵犯**：考察状态压缩DP，与本题的优化思路有相似之处。
2. **P1063 能量项链**：考察环状DP，与本题的环状结构处理思路相似。
3. **P1880 [NOI1995]石子合并**：考察区间DP，与本题的优化思路有相似之处。

### 个人心得总结

- **调试经历**：在调试过程中，发现直接暴力模拟会超时，通过数学推导和优化，显著提高了代码效率。
- **踩坑教训**：在处理环状结构时，容易忽略周期性，导致重复计算，通过GCD和调和级数的应用，避免了这一问题。
- **顿悟感想**：通过数学推导，发现问题的本质是GCD的倍数问题，从而简化了处理逻辑，提高了代码的可读性和效率。

---
处理用时：44.29秒
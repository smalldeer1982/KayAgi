# 题目信息

# 「EZEC-14」众数 I

## 题目背景

pigstd 是一个可爱的男孩子。他在 NOI2022 中的众数一题定义了 $10^6$ 个 ``std::deque`` 并没有 MLE。

## 题目描述

给定一个长度为 $n$ 的序列 $a$，我们通过以下方式构造序列 $b$：

- 初始时 $b=a$。
- 依次对 $b$ 进行 $k$ 次操作，每次操作选择任意一个元素并将其**修改**为任意整数。

dXqwq 定义一个序列的**众数**为所有出现次数最大的数。例如 $[1,1,4,5,1,4]$ 的众数为 $1$，而 $[1,14,5,14,19,19,8,10]$ 的众数为 $14,19$。

你需要求出有多少整数可能成为 $b$ 的**众数**。

## 说明/提示

**【样例解释】**

对于第一组数据，最终 $1,2,3,4,5$ 可能为区间众数。

对于第二组数据，将第一个数换成 $6,7,8,9,\cdots$ 后它们均会成为区间众数，因此答案为正无穷。

对于第三组数据，$1,2,3$ 可能成为区间众数。

**【提示】**

开 $10^6$ 个 ``std::deque`` 在空间限制为 1024MB 时不一定会 MLE。

**【数据范围】**

**本题采用捆绑测试。**

* Subtask 1（20 pts）：$n\leq 5$。
* Subtask 2（20 pts）：$n\leq 10^3$。
* Subtask 3（20 pts）：$k=0$。
* Subtask 4（20 pts）：$k=1$。
* Subtask 5（20 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$0\leq k\leq n $，$1\leq a_i\leq n$。

## 样例 #1

### 输入

```
5 0
1 2 3 4 5```

### 输出

```
5```

## 样例 #2

### 输入

```
5 1
1 2 3 4 5```

### 输出

```
pigstd```

## 样例 #3

### 输入

```
5 1
1 1 2 2 3```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心问题是通过修改序列中的元素，使得某些数成为众数。题解中主要采用了以下几种思路：

1. **二分查找**：通过二分查找确定某个数是否能成为众数，结合前缀和优化计算。
2. **贪心策略**：通过优先队列维护最大出现次数，模拟修改操作。
3. **前缀和与排序**：通过排序和前缀和快速计算修改后的众数条件。

大多数题解的时间复杂度为 \(O(n \log n)\)，能够通过 \(10^6\) 的数据范围。其中，二分查找和贪心策略的结合是较为常见的优化手段。

### 所选高星题解

#### 1. 作者：ys_kylin__ (5星)
**关键亮点**：
- 使用二分查找结合前缀和优化，时间复杂度为 \(O(n \log n)\)。
- 通过 `check` 函数快速判断某个数是否能成为众数。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
int check(int x) {
    memset(vis, 0, sizeof vis);
    x += k;
    long long m = 0;
    for (int i = 1; i <= n; i++) {
        if (mp[a[i]] > x && vis[a[i]] == 0) {
            vis[a[i]] = 1;
            m += mp[a[i]] - x;
        }
    }
    if (m > k) return 0;
    else return 1;
}
```
**实现思想**：通过二分查找确定众数的出现次数，结合前缀和快速计算修改后的条件。

#### 2. 作者：dead_X (4.5星)
**关键亮点**：
- 使用前缀和快速计算修改后的众数条件，时间复杂度为 \(O(n)\)。
- 通过排序和前缀和优化，避免了复杂的二分查找。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for (int i = n + k, c = 0, s = 0; i >= k; --i) {
    s += c, c += a[i];
    if (s > k) printf("%d\n", ans), exit(0);
    ans += a[i - k];
}
```
**实现思想**：通过前缀和快速计算修改后的众数条件，结合排序优化计算。

#### 3. 作者：Light_az (4星)
**关键亮点**：
- 使用优先队列模拟修改操作，时间复杂度为 \(O(n \log n)\)。
- 通过贪心策略优化修改操作，确保众数的出现次数最大化。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
F(i, 1, k) {
    ll p = q.top();
    q.pop();
    p--;
    q.push(p);
}
```
**实现思想**：通过优先队列维护最大出现次数，模拟修改操作，确保众数的出现次数最大化。

### 最优关键思路与技巧

1. **二分查找结合前缀和**：通过二分查找确定众数的出现次数，结合前缀和快速计算修改后的条件，适用于需要快速判断某个数是否能成为众数的场景。
2. **贪心策略与优先队列**：通过优先队列维护最大出现次数，模拟修改操作，确保众数的出现次数最大化，适用于需要动态维护最大值的场景。
3. **前缀和与排序优化**：通过排序和前缀和快速计算修改后的众数条件，适用于需要快速计算修改后的条件的场景。

### 可拓展之处

1. **同类型题**：类似的问题可以通过二分查找、贪心策略、前缀和等优化手段解决。
2. **类似算法套路**：在处理需要动态维护最大值或快速计算条件的场景时，优先队列和前缀和是常见的优化手段。

### 推荐题目

1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P3384 【模板】线段树 1](https://www.luogu.com.cn/problem/P3384)

### 个人心得摘录

- **调试经历**：在调试过程中，发现优先队列的维护需要特别注意，确保每次操作后最大值正确更新。
- **踩坑教训**：在计算前缀和时，需要注意边界条件，避免数组越界。
- **顿悟感想**：通过二分查找和前缀和的结合，能够快速判断某个数是否能成为众数，大大提高了算法的效率。

---
处理用时：34.47秒
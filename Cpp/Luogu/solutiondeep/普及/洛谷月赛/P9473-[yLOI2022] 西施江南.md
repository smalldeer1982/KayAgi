# 题目信息

# [yLOI2022] 西施江南

## 题目背景

> 我晤江南面 如逢西施颜  
> 清芬宜送岸 菡萏新雨前  
> 皓腕分珠帘 珠露扬波珠玉敛  
> 天然一段聚散 嫣然曾与言  
> 平芜辙尚浅 无韵化湖田  
> 林园虽工典 芳姿不可嵌  
> 何人冠诗篇 重街杳杳重门掩  
> 似有柔荑遮目 空谷足尖

银临《西施江南》

## 题目描述

给定 $n$ 个正整数 $a_1, a_2, a_3, \dots a_n$，记 $g$ 是这些数的**最大公约数**，$l$ 是这些数的**最小公倍数**。请你判断 $l \times g$ 是否等于 $a_1 \times a_2 \times \dots \times a_n$。

## 说明/提示

### 数据规模与约定

以下用 $N$ 表示单个测试点内 $n$ 的和，即 $N = \sum n$。

- 对 $12\%$ 的数据，保证 $n = 2$。
- 对 $36\%$ 的数据，保证 $n \leq 5$。
- 对 $52\%$ 的数据，保证 $N \leq 1000$。
- 对 $76\%$ 的数据，保证 $N,a_i \leq 10^5$。
- 对 $100\%$ 的数据，保证 $2 \leq n,N \leq 5 \times 10^5$，$2 \leq a_i \leq 10^8$，$1 \leq T \leq 20$。

### 提示

**数据千万条，清空第一条**。  
**多测不清空，爆零两行泪**。  
**清空不规范，超时总相伴**。

## 样例 #1

### 输入

```
3
2
2 3
3
2 3 4
3
3 8 35```

### 输出

```
Yes
No
Yes```

## 样例 #2

### 输入

```
见附加文件中的 C2.in```

### 输出

```
见附加文件中的 C2.ans```

# AI分析结果

### 综合分析与结论

该题目要求判断给定数列的最大公约数（gcd）与最小公倍数（lcm）的乘积是否等于数列的乘积。通过分析，可以得出以下结论：
1. 当 \( n = 2 \) 时，必然成立。
2. 当 \( n > 2 \) 时，只有当数列中的数两两互质时，等式才成立。

大多数题解都基于这一结论，通过分解质因数或枚举因数来判断数列是否两两互质。优化方法包括预处理质数、使用桶或哈希表记录质因数出现情况等。整体思路较为一致，但实现细节和优化程度有所不同。

### 所选高星题解

#### 1. 作者：cff_0102 (5星)
**关键亮点**：
- 详细证明了 \( n = 2 \) 和 \( n > 2 \) 时的条件，逻辑清晰。
- 使用线性筛预处理质数，优化了质因数分解的复杂度。
- 代码结构清晰，注释详细，易于理解。

**个人心得**：
- 作者提到比赛时差点在输出大小写上踩坑，提醒了细节的重要性。

**核心代码**：
```cpp
void s(){ //筛质数 
    p[1]=2;
    x[1]=0; //1 不是质数 
    int cnt=1; //筛出的质数个数
    for(int i=2;i<100000000;i++){
        if(!x[i]){ //是质数 
            p[++cnt]=i;
        }
        for(int j=1;j<=cnt&&(long long)(i)*p[j]<=100000000;j++){
            x[i*p[j]]=1; //x[i*p[j]] 不是质数 
            if(i%p[j]==0) break;
        }
    }
}
```

#### 2. 作者：信息向阳花木 (4星)
**关键亮点**：
- 通过桶记录质因数的出现次数，判断是否两两互质。
- 预处理了 \( 10^4 \) 以内的质数，优化了质因数分解的效率。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
void prime(){
    for (int i = 2; i < 10010; i ++ ){
        if(!f[i]){
            p[++ cnt] = i; 
            for (int j = i * 2; j < 10010; j += i) f[j] = 1;
        }
    }
}
```

#### 3. 作者：一扶苏一 (4星)
**关键亮点**：
- 使用唯一分解定理，详细分析了质因数的分布情况。
- 通过线性筛预处理最小质因子，优化了质因数分解的复杂度。
- 代码结构清晰，注释详细。

**核心代码**：
```cpp
void getPrime(const int N = 100000000) {
    pre.resize(N + 1);
    for (int i = 2; i <= N; ++i) {
        if (!np[i]) {
            prm.push_back(i); pre[i] = i;
        }
        for (auto p : prm) if (i * p <= N) {
            int k = i * p;
            np[k] = true;
            pre[k] = p;
            if (i % p == 0) break;
        } else break;
    }
}
```

### 最优关键思路与技巧

1. **质因数分解优化**：通过预处理质数或最小质因子，将质因数分解的复杂度从 \( O(\sqrt{n}) \) 降低到 \( O(\log n) \)。
2. **桶或哈希表记录质因数**：通过记录质因数的出现情况，快速判断数列是否两两互质。
3. **线性筛法**：预处理质数或最小质因子，优化质因数分解的效率。

### 可拓展之处

该题的思路可以拓展到其他涉及质因数分解和互质判断的题目，如：
- 判断多个数的最大公约数或最小公倍数。
- 判断数列中是否存在两个数不互质。
- 统计数列中不同质因数的分布情况。

### 推荐相似题目

1. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)
2. [P2568 GCD](https://www.luogu.com.cn/problem/P2568)
3. [CF1771C Hossam and Trainees](https://www.luogu.com.cn/problem/CF1771C)

### 个人心得总结

- **细节决定成败**：如输出大小写、多测清空等细节容易忽略，但往往影响最终结果。
- **预处理优化**：通过预处理质数或最小质因子，可以显著提升质因数分解的效率。
- **逻辑清晰**：在证明和实现过程中，保持逻辑清晰有助于减少错误和提高代码可读性。

---
处理用时：37.16秒
# 题目信息

# 「RiOI-2」equals

## 题目背景

在小树上坐落着一个幻想的城堡。这里是 E 国的领地，而小 E，则是 E 国之王。

为了打造一个完美的 E 国，他需要明辨是非，走向正义。

但是，他似乎有些太理想了。有时并没有一个完美的准则。是黑是白，谁能分辨？

## 题目描述

给定一棵 $n$ 个结点，以 $1$ 为根的树，定义一个结点的深度 $d_i$ 表示它到根结点的简单路径上的结点个数。

你需要给每个结点黑白染色，满足黑色结点的深度和等于白色结点的深度和。设 $c_i = \{0, 1\}$ 分别代表编号为 $i$ 的结点为黑色或白色，那么这即 $\displaystyle\sum_{c_i=0}d_i=\sum_{c_i=1}d_i$。

若无解，仅输出一行一个整数 $-1$。

## 说明/提示

### 样例解释

对于第一组数据，每个结点的深度分别是 $d=[1,2,2,3,3,3]$。黑色结点的深度和为 $d_1+d_5+d_6=1+3+3=7$，白色结点的深度和为 $d_2+d_3+d_4=2+2+3=7$。它们相等，所以样例输出是正确的。可能的正确输出包括但不限于样例输出、`0 1 1 0 0 1`，`1 0 0 1 0 1` 等。

### 数据规模与约定

**本题采用捆绑测试。**

| $\rm Subtask$ | 分值 | $n\le $ | 特殊性质 |
| :-----------: | :--: | :-----: | :------: |
| $0$ | $5$ | $20$ | / |
| $1$ | $15$ | $500$ | / |
| $2$ | $20$ | $5\times 10^3$ | / |
| $3$ | $10$ | / | $n$ 为偶数 |
| $4$ | $5$ | / | 树为菊花图（不保证根为菊花中心） |
| $5$ | $5$ | / | 树为一条链（不保证根为链的端点） |
| $6$ | $40$ | / | / |

斜杠表示这一栏无特殊限制。

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le u_i,v_i\le n$，输入数据构成一棵树。

## 样例 #1

### 输入

```
6
1 2
1 3
2 4
2 5
2 6```

### 输出

```
0 1 1 1 0 0```

## 样例 #2

### 输入

```
5
1 2
1 3
2 4
2 5```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论

本题的核心问题在于如何将树的节点染色，使得黑色和白色节点的深度和相等。题解中常见的思路包括：

1. **深度计算与排序**：首先通过DFS或BFS计算每个节点的深度，然后对深度进行排序。
2. **贪心策略**：从大到小或从小到大贪心地选择节点，确保深度和不超过总和的一半。
3. **背包问题**：将问题转化为背包问题，但由于数据规模较大，通常需要优化。
4. **数学性质**：利用树的深度序列的连续性，确保有解时能够通过贪心或分组策略找到解。

大多数题解都采用了贪心策略，结合深度序列的连续性，确保在深度和为偶数时一定有解。部分题解还提供了详细的正确性证明，增强了思路的可信度。

### 所选高星题解

#### 1. 作者：TernaryTree (★★★★★)
- **关键亮点**：详细分析了不同子任务的处理方法，尤其是对树的深度序列进行了深入分析，提出了分组策略，并给出了正确性证明。代码实现清晰，使用了DFS和BFS两种方式。
- **核心实现思想**：通过DFS或BFS计算深度，排序后分组处理，确保深度和相等。
- **代码片段**：
  ```cpp
  void dfs(int u, int fa) {
      dep[u] = make_pair(dep[fa].fs + 1, u);
      for (int i = 0; i < g[u].size(); i++) {
          int v = g[u][i];
          if (v != fa) dfs(v, u);
      }
  }
  ```

#### 2. 作者：ys_kylin__ (★★★★☆)
- **关键亮点**：通过深度排序后，从大到小贪心地选择节点，确保深度和不超过总和的一半。思路清晰，代码简洁。
- **核心实现思想**：从大到小选择节点，确保深度和不超过总和的一半。
- **代码片段**：
  ```cpp
  for(int i=n;i;i--) {
      if(sum2+d[i].num<sum/2) {
          sum2+=d[i].num;
          ans[d[i].id]=1;
      }
  }
  ```

#### 3. 作者：GaCGe (★★★★☆)
- **关键亮点**：通过降序排序深度序列，贪心地选择节点，确保深度和不超过总和的一半。提供了详细的正确性证明。
- **核心实现思想**：降序排序后贪心选择节点，确保深度和不超过总和的一半。
- **代码片段**：
  ```cpp
  for(int i=1;i<=n;i++) {
      if(cnt1>cnt2) {
          flag[e[i].num]=1;
          cnt2+=e[i].dd;
      }
      else cnt1+=e[i].dd;
  }
  ```

### 最优关键思路与技巧

1. **深度序列的连续性**：利用树的深度序列的连续性，确保在深度和为偶数时一定有解。
2. **贪心策略**：从大到小或从小到大贪心地选择节点，确保深度和不超过总和的一半。
3. **分组策略**：将深度序列分组处理，确保每组内的深度和相等。

### 可拓展之处

- **类似问题**：类似的问题可以出现在其他需要平衡分配的题目中，如背包问题、资源分配问题等。
- **算法优化**：可以通过进一步优化贪心策略，减少不必要的计算，提高算法效率。

### 推荐题目

1. **P1040 加分二叉树**：考察树的遍历与动态规划。
2. **P1352 没有上司的舞会**：考察树的动态规划与状态转移。
3. **P2014 选课**：考察树形背包问题，与本题的背包思路类似。

### 个人心得摘录

- **调试经历**：部分题解中提到在实现过程中遇到的数据类型问题（如未开long long导致溢出），提醒我们在处理大数时要注意数据类型的选择。
- **顿悟感想**：通过分析树的深度序列的连续性，意识到贪心策略的可行性，增强了算法的信心。

### 总结

本题的解题思路主要集中在深度计算、排序和贪心策略上。通过利用树的深度序列的连续性，确保在深度和为偶数时一定有解。贪心策略的实现简单且高效，适合大规模数据处理。

---
处理用时：33.12秒
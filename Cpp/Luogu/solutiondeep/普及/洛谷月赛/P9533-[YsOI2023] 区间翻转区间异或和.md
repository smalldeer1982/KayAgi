# 题目信息

# [YsOI2023] 区间翻转区间异或和

## 题目背景

Ysuperman 模板测试的数据结构题。

符卡可以是人名也可以是队名。

## 题目描述

符卡有一个长度为 $n$ 的整数数组 $a$，符卡认为一个区间 $[l,r]$ 是灵异区间当且仅当 $\bigoplus_{i=l}^ra_i=0$，或者说这个区间内所有数字异或起来刚好等于 $0$。

符卡有特殊的魔法，可以把**任意**一个灵异区间翻转。具体来说，如果 $[l,r]$ 区间是灵异区间，那么符卡就可以对这个区间使用魔法，整个数组就会变成 $a_1,a_2,\dots,a_{l-1},a_r,a_{r-1},\dots,a_l,a_{r+1},a_{r+2}\dots,a_n$。

现在符卡可以使用任意次数的魔法，符卡希望最后得到的数组的灵异区间数量能够尽可能多，你能告诉她最后最多有多少个灵异区间吗？

## 说明/提示

#### 样例 1 解释

无论符卡发动多少次魔法，数组都是 $1,1,1$，所以发不发动魔法都没有任何关系。灵异区间永远都是 $[1,2],[2,3]$ 两个。

#### 样例 2 解释

这里给出可能的一种魔法发动方法。

选择灵异区间 $[1,3]$ 发动魔法，得到的新数组是 $2,1,3,3$，这个数组共有两个灵异区间，分别是 $[1,3]$ 和 $[3,4]$。

可以证明答案无法超过 $2$。

#### 数据范围

对于前 $20\%$ 的数据，保证 $n\le 10$。

对于前 $40\%$ 的数据，保证 $n\le 2000$。

另有 $10\%$ 的数据，保证 $a_i$ 全部相等。

另有 $10\%$ 的数据，保证 $a_i$ 只有两种可能的取值。

另有 $10\%$ 的数据，保证 $0\le a_i<2^{10}$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$0\le a_i< 2^{20}$。

#### 彩蛋

灵异区间的名字其实是“零异（或）区间”的谐音。

## 样例 #1

### 输入

```
3
1 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4
3 1 2 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心在于理解“灵异区间”的定义以及翻转操作对灵异区间数量的影响。通过分析，可以得出翻转操作不会改变灵异区间的数量，因此问题转化为统计原数组中灵异区间的个数。大多数题解都采用了前缀异或和的方法来统计灵异区间的数量，并通过哈希表或数组记录前缀异或和的出现次数，最终通过组合公式计算灵异区间的总数。

### 所选题解

#### 1. 作者：_•́へ•́╬_ (赞：28)
- **星级**: 5星
- **关键亮点**: 思路清晰，直接通过前缀异或和统计灵异区间数量，代码简洁高效。
- **代码核心思想**: 使用数组记录前缀异或和的出现次数，遍历时累加相同前缀异或和的次数，最终输出结果。
```cpp
int n,a[100009],cnt[1<<20];long long ans;
main()
{
    read(n);cnt[0]=1;
    for(int i=1;i<=n;++i)
    {
        read(a[i]);a[i]^=a[i-1];
        ans+=cnt[a[i]]++;
    }
    printf("%lld",ans);
}
```

#### 2. 作者：Shizaki_Crazy_Three (赞：12)
- **星级**: 4星
- **关键亮点**: 详细证明了翻转操作的无意义性，并通过等差数列公式计算灵异区间数量。
- **代码核心思想**: 使用数组记录前缀异或和的出现次数，遍历时根据等差数列公式计算灵异区间的数量。
```cpp
long long ans=0;
cnt[0]++;//自己想想，如果有零的话它不用匹配它自己也是一种情况 
for(int i=0;i<=maxx;i++){
    ans+=(cnt[i]*(cnt[i]-1))/2;
}
cout<<ans;
```

#### 3. 作者：_mi_ka_ (赞：12)
- **星级**: 4星
- **关键亮点**: 通过反证法证明了翻转操作对灵异区间数量的无影响，并详细解释了前缀异或和的使用。
- **代码核心思想**: 使用数组记录前缀异或和的出现次数，遍历时累加相同前缀异或和的次数，最终输出结果。
```cpp
int n,ans,s,a,vis[1<<21];//a[i]和s[i]都是一次性用品，可以不记 
signed main()
{
    scanf("%lld",&n),vis[0]=1;
    for(int i=1;i<=n;i++)
        scanf("%lld",&a),s^=a,ans+=vis[s],vis[s]++;//此时的s为s[i] 
    cout<<ans;
    return 0;
}
```

### 最优关键思路或技巧

1. **前缀异或和**: 通过维护前缀异或和，可以快速计算任意区间的异或和。
2. **哈希表/数组记录**: 使用哈希表或数组记录前缀异或和的出现次数，便于统计灵异区间的数量。
3. **组合公式**: 通过组合公式计算相同前缀异或和的出现次数，得到灵异区间的总数。

### 可拓展之处

- **类似问题**: 类似的问题包括统计区间和为零的区间数量，或者统计满足某种条件的区间数量。可以使用前缀和或前缀异或和的方法来解决。
- **算法套路**: 前缀和/前缀异或和 + 哈希表/数组记录是解决区间统计问题的常见套路。

### 推荐题目

1. [P3402 可持久化并查集](https://www.luogu.com.cn/problem/P3402)
2. [P3919 【模板】可持久化数组](https://www.luogu.com.cn/problem/P3919)
3. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

### 个人心得摘录

- **作者：Shizaki_Crazy_Three**: “翻转操作难住了一大部分人（~~包括我~~）。接下来证明它是无意义的。” —— 通过详细证明翻转操作的无意义性，帮助理解问题的本质。
- **作者：_mi_ka_**: “这道题我赛时没有考虑灵异区间的翻转，只求了灵异区间的个数，目的是骗一点分，但是就非常‘灵异’的 AC 了。” —— 通过实际比赛经验，验证了问题的简化思路。

### 通用建议与扩展思路

- **理解问题本质**: 在解决类似问题时，首先要理解问题的本质，避免被复杂的操作迷惑。
- **简化问题**: 通过简化问题，找到问题的核心，可以大大降低问题的复杂度。
- **常用算法套路**: 掌握常用的算法套路，如前缀和/前缀异或和 + 哈希表/数组记录，可以快速解决类似问题。

---
处理用时：38.75秒
# 题目信息

# 「TAOI-2」核心共振

## 题目背景

⚡超越一切震慑凡人⚡

⚡带来终结机械降神⚡

⚡风暴之力充满全身⚡

⚡最后一击核心共振⚡

## 题目描述

给定正整数 $p$ 和 $n$。对于一个排列，我们称其中相邻两项产生「共振」当且仅当这两个数的和为 $p$ 的倍数。

请你构造一个 $1 \sim n$ 的排列，最大化其中产生「共振」的次数。如果有多种方案，输出任意一种即可。

## 说明/提示

**本题采用捆绑测试。**

+ Subtask 0（15 pts）：$n \leq 9$，$T \le 10$。
+ Subtask 1（10 pts）：$p = 2$。
+ Subtask 2（30 pts）：$p = 3$。
+ Subtask 3（45 pts）：无特殊限制。

对于所有数据，$1 \leq n \leq 10^5$，$1 \leq p \leq 10^8$，$1 \leq T \leq 10^4$，$1 \leq \sum n \leq 3\times 10^5$。

## 样例 #1

### 输入

```
3
9 1
5 2
1 12345
```

### 输出

```
3 8 7 1 4 5 6 9 2
1 5 3 2 4
1
```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个排列，使得相邻两项的和为 \( p \) 的倍数的次数最大化。各题解的思路大多围绕如何将模 \( p \) 余数互补的数对相邻排列，以最大化共振次数。部分题解还考虑了特殊情况（如 \( p \) 过大时无法共振）和优化策略（如使用队列或集合来管理余数类）。

总体来看，大部分题解的思路较为相似，但实现细节和优化程度有所不同。部分题解在代码实现上较为简洁，且考虑了边界情况，值得参考。

### 精选题解

#### 1. **作者：include13_fAKe (赞：11)**
- **星级**：4.5
- **关键亮点**：
  - 详细分析了不同子任务的处理方法，特别是对 \( p=2 \) 和 \( p=3 \) 的特殊情况进行了深入讨论。
  - 提出了当 \( 2n \leq p \) 时直接输出任意排列的优化策略，避免了不必要的计算。
  - 代码实现清晰，且考虑了 \( p \) 为偶数时的特殊情况。
- **个人心得**：
  - 作者提到在调试过程中发现 TLE 问题，最终通过特判 \( 2n \leq p \) 的情况解决了问题，强调了边界情况的重要性。

**核心代码片段：**
```cpp
if(n*2<p){
    for(int i=1;i<=n;i++) printf("%d ",i);
    return ;
}
for(int i=1;i*2<p;i++){
    for(int j=0;j<=n;j+=p){
        if(i+j<=n) printf("%d ",i+j);
        if(j+p-i<=n) printf("%d ",j+p-i);
    }
}
for(int i=p;i<=n;i+=p) printf("%d ",i);
if(p%2==0){
    for(int i=p/2;i<=n;i+=p) printf("%d ",i);
}
```

#### 2. **作者：Convergent_Series (赞：2)**
- **星级**：4
- **关键亮点**：
  - 提出了先输出 \( p \) 的倍数，再交替输出模 \( p \) 余数互补的数对的策略，思路清晰。
  - 代码简洁，且通过特判 \( p \geq 2n \) 的情况优化了性能。
- **个人心得**：
  - 作者通过观察排列中相邻两项和的最大值，得出了 \( p \geq 2n \) 时无法共振的结论，体现了对问题的深入理解。

**核心代码片段：**
```cpp
if(p==1||p>=2*n){
    for(int i=1;i<=n;i++) write(i),pcs;
    return;
}
for(int i=p;i<=n;i+=p) write(i),pcs;
for(int m1=1,m2=p-1;m1<=p/2;m1++,m2--){
    if(m1!=m2){
        for(int i=0;i+m2<=n;i+=p) write(i+m1),pcs,write(i+m2),pcs;
    }
}
```

#### 3. **作者：_mi_ka_ (赞：2)**
- **星级**：4
- **关键亮点**：
  - 通过枚举模 \( p \) 的余数，交替输出互补的数对，思路清晰且易于理解。
  - 代码实现简洁，且通过特判 \( p > 2n \) 的情况优化了性能。
- **个人心得**：
  - 作者提到在构造排列时，优先输出 \( p \) 的倍数，避免了重复输出的问题，体现了对细节的把握。

**核心代码片段：**
```cpp
if(p>2*n){
    for(int i=1;i<=n;i++) wr(i),putchar(' ');
    putchar('\n');
    continue;
}
for(int i=1;i*p<=n;i++) wr(i*p),putchar(' ');
for(int r=1;r<=p/2;r++){
    wr(r),putchar(' ');
    for(int i=1;i*p-r<=n;i++){
        wr(i*p-r),putchar(' ');
        if(i*p+r>n) break;
        wr(i*p+r),putchar(' ');
    }
}
```

### 最优关键思路与技巧

1. **模 \( p \) 余数分类**：将数按模 \( p \) 的余数分类，优先将余数互补的数对相邻排列，以最大化共振次数。
2. **特判 \( p \geq 2n \)**：当 \( p \) 过大时，直接输出任意排列，避免不必要的计算。
3. **优先输出 \( p \) 的倍数**：将 \( p \) 的倍数放在一起，确保它们之间的共振次数最大化。

### 拓展思路与类似题目

1. **类似题目**：
   - [P1494 [国家集训队]小Z的袜子](https://www.luogu.com.cn/problem/P1494)：考察模数分类与组合优化。
   - [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)：涉及排列与模数相关的优化。
   - [P3810 【模板】三维偏序](https://www.luogu.com.cn/problem/P3810)：考察排列与模数分类的结合应用。

2. **拓展思路**：
   - 在处理模数相关问题时，优先考虑将数按模数分类，再通过互补或交替排列的方式优化结果。
   - 对于边界情况（如 \( p \) 过大），应提前特判，避免不必要的计算。

---
处理用时：39.07秒
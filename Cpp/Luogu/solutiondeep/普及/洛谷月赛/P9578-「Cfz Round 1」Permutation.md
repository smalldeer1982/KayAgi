# 题目信息

# 「Cfz Round 1」Permutation

## 题目背景

$1+2+3+\cdots+n=\dfrac {n\times (n+1)} 2$。

## 题目描述

给定一个正整数 $n$。

我们定义，对于一个 $1$ 到 $n$ 的排列 $\{x_n\}$， $f(\{x_n\})=\max\limits_{i=1}^{n}(x_i+x_{(i \bmod n)+1})-\min\limits_{i=1}^{n}(x_i+x_{(i \bmod n)+1})$。

你需要构造一个 $1$ 到 $n$ 的排列 $\{p_n\}$，使得对于任意一个 $1$ 到 $n$ 的排列 $\{q_n\}$，都有 $f(\{p_n\})\le f(\{q_n\})$，并输出你构造的排列 $\{p_n\}$。

## 说明/提示

#### 【样例解释 #1】

$f(\{1,4,2,3\})=2$，可以证明对于任意一个 $1$ 到 $n$ 的排列 $\{q_n\}$，都有 $f(\{1,4,2,3\})\le f(\{q_n\})$。

当然，$\{1,3,2,4\},\{3,1,4,2\},\{4,1,3,2\}$ 等也为合法的排列 $\{p_n\}$。

#### 【数据范围】

对于所有数据，$3 \le n \le 10^6$。

**本题采用捆绑测试。**

|子任务编号|分值|$n \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1$|$20$|$8$|无|
|$2$|$25$|$10^6$|保证 $n \equiv 0 \pmod 2$|
|$3$|$25$|$10^6$|保证 $n \equiv 1 \pmod 2$|
|$4$|$30$|$10^6$|无|

## 样例 #1

### 输入

```
4```

### 输出

```
1 4 2 3```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个排列，使得相邻两数之和的极差最小。通过对多个题解的分析，发现大多数题解都采用了类似的思路：通过奇偶性分类讨论，构造一个排列使得相邻两数之和尽可能接近平均值 \(n+1\)，从而将极差控制在2以内。部分题解通过打表找规律，进一步优化了构造方法。

### 所选高星题解

#### 1. **作者：Defy_HeavenS** (5星)
- **关键亮点**：通过奇偶性分类讨论，详细列出了小规模数据的构造规律，并给出了清晰的构造方法。代码简洁且易于理解。
- **代码核心思想**：
  - 对于偶数 \(n\)，通过交替放置大数和小数，使得相邻两数之和接近 \(n+1\)。
  - 对于奇数 \(n\)，通过奇偶下标分别递增和递减的方式构造排列。

```cpp
if(n%2==0){
    for(int i=2,j=n-1;i<=n/2;i+=2,j-=2){
        a[i]=j;
        a[n-i+1]=n+1-j;
    }
    for(int i=1;i<=n;i++){
        if(!a[i]) cout<<i<<" ";
        else cout<<a[i]<<" ";
    }
}else{
    a[1]=1;
    for(int i=3,j=2;i<=n;i+=2,j+=2){
        a[i]=j;
    }
    for(int i=2,j=n;i<=n;i+=2,j-=2){
        a[i]=j;
    }
    for(int i=1;i<=n;i++){
        cout<<a[i]<<" ";
    }
}
```

#### 2. **作者：maomao233** (4星)
- **关键亮点**：通过数学推导，证明了极差最小为2，并给出了详细的构造流程。代码实现较为清晰，且考虑了特殊情况。
- **代码核心思想**：
  - 通过交替选择 \(n, n+2, n+1\) 作为相邻两数之和，确保极差为2。

```cpp
for(int i=2; i<=n; i++) {
    p=n-p;
    if(vis[p]) {
        p+=2;
        if(vis[p]||p>n)p--;
    }
    vis[p]=1;
    P(p);
    SPACE
}
```

#### 3. **作者：_determination_** (4星)
- **关键亮点**：通过打表找规律，总结了奇偶情况下的构造方法，代码简洁且易于实现。
- **代码核心思想**：
  - 对于偶数 \(n\)，前半段奇数递增，后半段偶数递减。
  - 对于奇数 \(n\)，奇偶下标分别递增和递减。

```cpp
if(n%2==0){
    for(int i=1;i<=n/2;i++){
        if(i%2) cout<<i<<" "<<n-i+1<<" ";
        else cout<<n-i+1<<" "<<i<<" ";
    }
}else{
    for(int i=1;i<=n;i++){
        if(i%2) cout<<i<<" ";
        else cout<<n-i+1<<" ";
    }
}
```

### 最优关键思路与技巧

1. **奇偶性分类讨论**：根据 \(n\) 的奇偶性，分别构造排列，确保相邻两数之和接近 \(n+1\)。
2. **打表找规律**：通过小规模数据的构造，总结出通用的构造方法，适用于大规模数据。
3. **交替放置大数和小数**：通过交替放置大数和小数，确保相邻两数之和的极差最小。

### 可拓展之处

- **类似构造题**：可以通过类似的思路解决其他构造题，如构造一个排列使得相邻两数的乘积极差最小。
- **数学推导**：通过数学推导，确定极差的最小值，并构造满足条件的排列。

### 推荐题目

1. **P1008 三连击**：考察构造排列，使得三个三位数满足特定条件。
2. **P1012 拼数**：构造一个排列，使得拼接后的数最大。
3. **P1028 数的计算**：通过构造排列，计算满足条件的数的个数。

### 个人心得摘录

- **Defy_HeavenS**：通过小规模数据的构造，总结出通用的构造方法，适用于大规模数据。
- **maomao233**：通过数学推导，证明了极差最小为2，并给出了详细的构造流程。
- **_determination_**：通过打表找规律，总结了奇偶情况下的构造方法，代码简洁且易于实现。

---
处理用时：37.47秒
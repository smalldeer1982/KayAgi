# 题目信息

# 「MXOI Round 1」涂色

## 题目描述

小 C 正在用彩铅给一张 $n$ 行 $m$ 列的方格纸涂色。初始时，所有方格都是空白的。

他一共要进行 $q$ 次涂色，每次涂色会选取一行或一列，给这一行或这一列的所有方格都添加 $1$ 层颜色。

小 C 喜欢浅色，所以他会在每次涂色结束后，把所有被涂上 $k$ 层颜色的方格的颜色都擦掉，让这些方格都变成空白的。

小 C 想知道，在最终共有多少方格被涂上了颜色。

## 说明/提示

#### 【样例解释 #1】

第 $1$ 行第 $1$ 列的方格没有被涂上颜色，第 $1$ 行第 $2$ 列的方格被涂上了 $1$ 层颜色，第 $1$ 行第 $3$ 列的方格没有被涂上颜色，第 $1$ 行第 $4$ 列的方格被涂上了 $1$ 层颜色；

第 $2$ 行第 $1$ 列的方格被涂上了 $1$ 层颜色，第 $2$ 行第 $2$ 列的方格被涂上了 $2$ 层颜色，第 $2$ 行第 $3$ 列的方格被涂上了 $1$ 层颜色，第 $2$ 行第 $4$ 列的方格被涂上了 $2$ 层颜色；

第 $3$ 行第 $1$ 列的方格被涂上了 $2$ 层颜色，第 $3$ 行第 $2$ 列的方格的颜色被擦掉了，第 $3$ 行第 $3$ 列的方格被涂上了 $2$ 层颜色，第 $3$ 行第 $4$ 列的方格的颜色也被擦掉了；

最终，共有 $8$ 个方格被涂上了颜色。

#### 【样例 #2】

见附加文件中的 `paint/paint2.in` 与 `paint/paint2.ans`。

该样例满足测试点 $1$ 的限制。

#### 【样例 #3】

见附加文件中的 `paint/paint3.in` 与 `paint/paint3.ans`。

该样例满足测试点 $5$ 的限制。

#### 【样例 #4】

见附加文件中的 `paint/paint4.in` 与 `paint/paint4.ans`。

该样例满足测试点 $20$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le n,m \le 2\times 10^5$，$1 \le k \le q \le 5 \times 10^5$，$op \in \{1,2\}$，保证当 $op=1$ 时 $1 \le x \le n$，当 $op=2$ 时 $1 \le x \le m$。

|测试点编号|$n,m \le$|$q \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim4$|$3000$|$3000$|无|
|$5\sim9$|$3000$|$5\times10^5$|无|
|$10\sim12$|$2\times10^5$|$5\times10^5$|A|
|$13\sim16$|$2\times10^5$|$5\times10^5$|B|
|$17\sim20$|$2\times10^5$|$5\times10^5$|无|

特殊性质 A：保证 $op=1$。

特殊性质 B：保证 $k=2$。

## 样例 #1

### 输入

```
3 4 5 3
1 3
2 4
1 2
1 3
2 2```

### 输出

```
8```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效处理大规模的行列涂色操作，并统计最终涂色方格的数量。由于直接模拟涂色过程的时间复杂度较高，多数题解通过记录每行和每列的涂色次数，并结合模运算和桶计数来优化计算。以下是各题解的思路对比与评分：

1. **优化思路**：大多数题解通过记录每行和每列的涂色次数，并利用模运算和桶计数来避免直接枚举每个方格，从而将时间复杂度从 \(O(nm)\) 降低到 \(O(n + m)\)。
2. **数据结构**：使用桶（数组）来统计每行和每列的涂色次数模 \(k\) 的结果，是本题的关键优化点。
3. **思维方式**：多数题解采用“正难则反”的思路，先计算未涂色的方格数量，再用总数减去未涂色的方格数量，简化了问题。

### 所选高星题解

#### 1. 作者：BL_zhanggezi (5星)
**关键亮点**：
- 通过记录每行和每列的涂色次数，并利用模运算和桶计数来优化计算。
- 使用二分查找和桶计数进一步优化，避免了直接枚举每个方格。
- 代码清晰，逻辑严谨，优化思路明确。

**核心代码**：
```cpp
for(int i=1;i<=m;i++)
{
    c=s[i]%k;
    for(int j=(k-c)%k;j<=h[n];j+=k)
    {
        ans=ans-ss[j];//ss[j]是符合要求的数量
    }
}
```
**实现思想**：通过桶计数统计每行的涂色次数模 \(k\) 的结果，然后根据列的涂色次数模 \(k\) 的结果，快速计算未涂色的方格数量。

#### 2. 作者：wpy233 (4.5星)
**关键亮点**：
- 通过引理证明涂色顺序不影响最终结果，简化了问题。
- 使用桶计数统计每行和每列的涂色次数模 \(k\) 的结果，优化了计算。
- 代码简洁，逻辑清晰，优化思路明确。

**核心代码**：
```cpp
for(int i=1,j=k-1;i<=k-1,j>=1;i++,j--)
    ans-=c[i]*d[j]; //去除涂色次数加和为k的交叉格
```
**实现思想**：通过桶计数统计每行和每列的涂色次数模 \(k\) 的结果，然后根据涂色次数加和为 \(k\) 的交叉格，快速计算未涂色的方格数量。

#### 3. 作者：Coffee_zzz (4星)
**关键亮点**：
- 通过记录每行和每列的涂色次数，并利用模运算和桶计数来优化计算。
- 使用桶计数统计每行和每列的涂色次数模 \(k\) 的结果，优化了计算。
- 代码简洁，逻辑清晰，优化思路明确。

**核心代码**：
```cpp
for(int i=1;i<=m;i++) w[l[i]%k]++;
for(int i=1;i<=n;i++) ans+=m-w[(k-h[i]%k)%k];
```
**实现思想**：通过桶计数统计每列的涂色次数模 \(k\) 的结果，然后根据每行的涂色次数模 \(k\) 的结果，快速计算未涂色的方格数量。

### 最优关键思路与技巧

1. **桶计数**：通过桶（数组）统计每行和每列的涂色次数模 \(k\) 的结果，避免了直接枚举每个方格，大幅降低了时间复杂度。
2. **模运算**：利用模运算将涂色次数限制在 \(0\) 到 \(k-1\) 之间，简化了计算。
3. **正难则反**：通过计算未涂色的方格数量，再用总数减去未涂色的方格数量，简化了问题。

### 可拓展之处

1. **类似问题**：可以扩展到其他需要对大规模数据进行统计和优化的问题，如矩阵操作、图论中的路径统计等。
2. **算法套路**：桶计数和模运算的结合可以应用于其他需要高效统计和优化的问题，如计数问题、哈希表优化等。

### 推荐题目

1. **P3374 【模板】树状数组 1**：考察树状数组的基本操作，与本题的桶计数有相似之处。
2. **P3368 【模板】线段树 1**：考察线段树的基本操作，与本题的优化思路有相似之处。
3. **P1908 逆序对**：考察归并排序和分治思想，与本题的优化思路有相似之处。

### 个人心得摘录

- **BL_zhanggezi**：通过二分查找和桶计数进一步优化，避免了直接枚举每个方格，大幅降低了时间复杂度。
- **wpy233**：通过引理证明涂色顺序不影响最终结果，简化了问题，使代码更加简洁高效。
- **Coffee_zzz**：通过桶计数统计每行和每列的涂色次数模 \(k\) 的结果，优化了计算，使代码更加简洁高效。

---
处理用时：43.94秒
# 题目信息

# 『GROI-R2』 不空白的画布

## 题目描述

我们都知道爱丽丝躲起来之后，坦尼尔坐在了空白画布面前，拿起炭笔开始作画。

但是现在画布已经不再空白，因为画布上已经有了当下的风景。我们设画布的长度是 $n$，每一单位长度上的颜色可以用一个在 $[1,k]$ 范围内的正整数表示。

坦尼尔还要画他已经翻了的茶杯。每一次作画，他可以选定画布上的任意一个位置，然后将这个位置上的颜色涂改成 $[1,k]$ 范围内的任意正整数。

最后，我们都知道这幅画是有记忆的。定义画上留下的记忆碎片数量为画上的**相同颜色连续块个数**。现在坦尼尔想知道，如果给定他作画的次数**上限**，那么画上的记忆碎片个数**最多**有多少。

**形式化题面**

你有连续的 $n$ 个方格，每个方格上有一个初始颜色 $c_i$，且保证 $1\le c_i \le k$。

你可以操作**至多** $m$ 次，每个操作为改变某个方格颜色，要求改变后的颜色范围仍在 $[1,k]$ 内。

我们称一个**极长相同颜色连续段**为一块，要求求出经过至多 $m$ 次操作后的**最多**块数。


## 说明/提示

**样例解释**

对于第一组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，得到 $\{c_n\}=\{2,1,2\}$，块数为 $3$。


对于第二组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，将从左到右的第三个位置涂成颜色 $3$，得到 $\{c_n\}=\{2,1,3,2,3\}$，块数为 $5$。

**数据范围**

**本题采用捆绑测试**。

| $\text{Subtask}$ | $\sum n\le$ | $m\le$ | $k\le$ | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------:  |
| $1$ | $10$ | $10$ | $3$ | $10$ |
| $2$ | $5\times 10^5$ | $1$ | $5\times 10^5$ | $10$ |
| $3$ | $10^3$ | $10^3$ | $10^3$ | $15$ |
| $4$ | $5\times 10^5$ | $5\times 10^5$ | $3$ | $25$ |
| $5$ | $5\times 10^5$ | $5\times 10^5$ | $5\times 10^5$ | $40$ |

对于 $100\%$ 的数据满足 $1\le  n\le 5\times 10^5$，$1\le \sum n\le 5\times 10^5$，$1\le m\le n$，$3\le  k \le 5\times 10^5$，$1\le c_i\le k$。


## 样例 #1

### 输入

```
2
3 1 3
2 2 2
5 2 4
2 2 2 2 3```

### 输出

```
3
5```

# AI分析结果

### 综合分析与结论

本题的核心目标是通过最多 $m$ 次操作，最大化画布上相同颜色连续块的个数。题解中主要采用了贪心策略，优先处理能带来最大收益的操作（如将连续三个相同颜色的块拆分成三个不同的块），然后再处理次优的操作（如将连续两个相同颜色的块拆分成两个不同的块）。大多数题解都遵循了这一思路，但在代码实现和细节处理上有所不同。

### 所选高星题解

#### 1. 作者：fish_love_cat (★★★★★)
**关键亮点**：
- **思路清晰**：明确区分了“双连”和“三连”的情况，并优先处理“三连”以获得最大收益。
- **代码简洁**：通过简单的遍历和条件判断实现了贪心策略，代码可读性强。
- **优化程度高**：通过一次遍历处理“三连”，再处理“双连”，减少了不必要的操作。

**核心代码**：
```cpp
for(int i=2;m&&i<n;i++) 
    if(c[i-1]==c[i]&&c[i]==c[i+1]) 
        m--,c[i]=(--jsq),ans+=2; // 处理三连
for(int i=1;m&&i<n;i++) 
    if(c[i]==c[i+1]) 
        m--,c[i]=(--jsq),ans++; // 处理双连
```

#### 2. 作者：kanzaki (★★★★☆)
**关键亮点**：
- **思路清晰**：详细分析了不同连续块的处理方式，并给出了具体的操作示例。
- **代码结构良好**：通过两次遍历分别处理“三连”和“双连”，逻辑清晰。
- **优化程度较高**：在遍历时及时判断操作次数是否用完，避免了不必要的操作。

**核心代码**：
```cpp
for(int j=2;j<n;j++) {
    if(m<=0) break;
    if(c[j]==c[j-1]&&c[j]==c[j+1]) {
        c[j]=flag;
        ans+=2;
        m--;
    }
} // 处理三连
for(int j=1;j<n;j++) {
    if(m<=0) break;
    if(c[j]==c[j+1]) {
        c[j]=flag;
        ans++;
        m--;
    }
} // 处理双连
```

#### 3. 作者：Wi_Fi (★★★★☆)
**关键亮点**：
- **思路新颖**：使用优先队列维护连续块的长度，优先处理最长的连续块。
- **代码实现巧妙**：通过优先队列动态调整连续块的长度，确保每次操作都能带来最大收益。
- **优化程度较高**：通过优先队列的处理方式，减少了遍历次数，提高了效率。

**核心代码**：
```cpp
priority_queue<int>q;
for(int i=2;i<=n;i++) {
    if(c[i]==c[i-1]) sum++;
    else q.push(sum),ans++,sum=1;
}
q.push(sum),ans++;
for(int i=1;i<=m;i++) {
    int fr=q.top(),l1,l2;
    if(fr==2) ans++;
    if(fr>=3) ans+=2;
    fr--,l1=1,l2=fr-1;
    q.pop(),q.push(l1),q.push(l2);
}
```

### 最优关键思路与技巧

1. **贪心策略**：优先处理能带来最大收益的操作（如将连续三个相同颜色的块拆分成三个不同的块），然后再处理次优的操作（如将连续两个相同颜色的块拆分成两个不同的块）。
2. **优化遍历**：通过一次或两次遍历处理所有可能的操作，减少不必要的遍历次数。
3. **数据结构**：使用优先队列动态维护连续块的长度，确保每次操作都能带来最大收益。

### 可拓展之处

- **类似算法套路**：在处理最大化或最小化问题时，贪心策略是一种常见且有效的算法套路。类似的题目包括区间调度问题、背包问题等。
- **同类型题目**：可以考虑处理其他类型的连续块问题，如最大化不同字符的连续块数等。

### 推荐题目

1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1966 [NOIP2013 提高组] 火柴排队](https://www.luogu.com.cn/problem/P1966)

### 个人心得摘录

- **fish_love_cat**：通过优先处理“三连”块，能够最大化每次操作的收益，这一思路在调试过程中得到了验证。
- **Wi_Fi**：使用优先队列维护连续块的长度，虽然在实现上有些复杂，但在处理大规模数据时表现出了较高的效率。

这些心得表明，优先处理高收益操作和使用合适的数据结构是解决类似问题的关键。

---
处理用时：41.69秒
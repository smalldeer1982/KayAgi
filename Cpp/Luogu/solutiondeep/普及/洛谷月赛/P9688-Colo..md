# 题目信息

# Colo.

## 题目描述

小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 $n$，宽度为 $1$ 的网格图上画画，从左往右第 $i$ 个方格被涂成了一种颜色 $a_i$。

你觉得他的随意涂鸦太难看了，想要保留恰好 $k$ 种颜色（**你不能保留没在网格图上出现的颜色**），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。

此外，小 Y 使用的第 $i$ 种颜色有一个价值 $b_i$，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。

你需要求出你能够获得的最大的价值是多少。

## 说明/提示

#### 【样例解释 #1】

对于第一组样例，我们可以选择 $1$ 号和 $3$ 号颜色保留，剩下的网格图即为 $[1,1,3]$，满足单调不下降这一个限制，获得的价值即为 $b_1+b_3=5+1=6$，可以证明这是最优的办法。

#### 【数据范围】

对于所有测试数据，满足 $1 \le n \le 500$，$1 \le k \le 500$，$1 \le a_i \le n$，$1 \le b_i \le 10^9$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n,k \le $ | 特殊性质 |
| :-----------: | :-----------: | :-----------: |
| $1 \sim 3$ | $10$ | 无 |
| $4 \sim 5$ | $100$ | 无 |
| $6 \sim 10$ | $500$ | 不同的颜色不超过 $10$ 种 |
| $11 \sim 15$ | $500$ | 每种颜色出现的次数不超过 $2$ 次 |
| $16 \sim 20$ | $500$ | 无 |


## 样例 #1

### 输入

```
5 2
1 2 1 3 2
5 3 1 100 100```

### 输出

```
6```

## 样例 #2

### 输入

```
10 3
1 3 4 2 9 3 4 2 5 1
1 5 2 3 9 8 1 2 3 10```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）来解决颜色选择问题，要求保留恰好 $k$ 种颜色，且保留的颜色序列单调不下降，同时最大化所选颜色的价值总和。大多数题解都采用了类似的DP思路，但在状态定义、转移方程和优化细节上有所不同。以下是对各题解的总结与对比：

1. **状态定义**：大多数题解采用 `dp[i][j]` 表示前 $i$ 种颜色中选择了 $j$ 种颜色的最大价值。部分题解进一步优化了状态定义，如 `dp[i][j]` 表示以第 $i$ 种颜色结尾、选择了 $j$ 种颜色的最大价值。
  
2. **转移方程**：转移方程的核心是判断颜色之间的单调性和区间不重叠条件。大多数题解通过预处理每种颜色的首次和最后一次出现位置，来判断颜色之间是否可以转移。

3. **优化**：部分题解通过排序、剪枝、记忆化搜索等方式优化了DP的复杂度，尤其是在处理颜色区间不重叠的条件时。

4. **代码实现**：大多数题解的代码实现较为清晰，但部分题解在初始化、边界条件和无解处理上存在不足，导致代码可读性和鲁棒性较差。

### 所选高星题解

#### 1. 题解作者：卷王 (5星)
**关键亮点**：
- **状态定义清晰**：`dp[i][j]` 表示前 $i$ 种颜色中选择了 $j$ 种颜色的最大价值，且选择了第 $i$ 种颜色。
- **转移方程简洁**：通过预处理每种颜色的首次和最后一次出现位置，简化了转移条件的判断。
- **代码可读性强**：代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= k; j++)
        for(int m = 0; m < i; m++)
            if(a[i] > a[m] && l[a[i]] > r[a[m]])
                if(dp[m][j - 1] >= 0)
                    dp[i][j] = max(dp[i][j], dp[m][j - 1] + b[a[i]]);
```

**个人心得**：
- 作者提到“问啥设啥”，即直接根据问题定义状态，这种思维方式在DP问题中非常实用。

#### 2. 题解作者：zaochen (4.5星)
**关键亮点**：
- **状态定义灵活**：`dp[i][0/1][j]` 表示前 $i$ 种颜色中选择了 $j$ 种颜色，且第 $i$ 种颜色选或不选的最大价值。
- **转移条件优化**：通过判断颜色的首次和最后一次出现位置，确保转移时颜色序列单调不下降。
- **代码优化**：通过减少不必要的状态维度，优化了空间复杂度。

**核心代码**：
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 2; j <= k; j++)
        for(int c = 1; c < i; c++)
            if(l[c] && r[c] < l[i] && dp[c][1][j - 1] != -1)
                dp[i][1][j] = max(dp[i][1][j], dp[c][1][j - 1] + b[i]);
```

**个人心得**：
- 作者提到“可以一开始就思考这种状态定义方式”，强调了在DP问题中灵活定义状态的重要性。

#### 3. 题解作者：TridentDeer (4星)
**关键亮点**：
- **状态定义直观**：`dp[i][j]` 表示以第 $i$ 种颜色结尾、选择了 $j$ 种颜色的最大价值。
- **转移条件明确**：通过预处理颜色区间，确保转移时颜色序列单调不下降且区间不重叠。
- **代码简洁**：代码实现简洁，易于理解。

**核心代码**：
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= k; j++)
        for(int m = 1; m < i; m++)
            if(a[i] > a[m] && r[a[m]] < l[a[i]])
                dp[i][j] = max(dp[i][j], dp[m][j - 1] + b[a[i]]);
```

**个人心得**：
- 作者提到“相同颜色一定连续”，这种观察帮助简化了问题的复杂度。

### 最优关键思路与技巧

1. **状态定义**：在DP问题中，状态定义应直接反映问题的需求，如“选择了多少种颜色”或“以某种颜色结尾”。
2. **预处理**：通过预处理每种颜色的首次和最后一次出现位置，可以简化转移条件的判断。
3. **转移优化**：在转移时，确保颜色序列单调不下降且区间不重叠，可以通过排序或剪枝来优化。
4. **代码简洁**：保持代码结构清晰，注释详细，便于理解和调试。

### 可拓展之处

- **类似问题**：类似的问题包括最长上升子序列（LIS）、区间选择问题等，都可以通过类似的DP思路解决。
- **优化技巧**：在处理区间不重叠的条件时，可以考虑使用线段树或树状数组等数据结构来优化查询效率。

### 推荐题目

1. **P1020 导弹拦截**：考察最长不上升子序列和最长上升子序列的DP问题。
2. **P1091 合唱队形**：考察双向DP，类似于本题的单调序列问题。
3. **P1880 石子合并**：考察区间DP，类似于本题的区间选择问题。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中遇到的困难，如转移条件的判断和边界条件的处理，强调了在DP问题中细致调试的重要性。
- **顿悟感想**：部分作者提到在思考状态定义时的顿悟，如“问啥设啥”和“灵活定义状态”，这些思维方式在解决DP问题时非常实用。

---
处理用时：59.82秒
# 题目信息

# 「RiOI-03」匀速相遇

## 题目背景

当大家都在加速时，我与你，在人生中的十字路口，匀速地相遇了。

确是惊动我心的一瞥，却是无法逗留的遗憾，我们再次，朝着自己的方向匀速奔跑。下次再见，又会是什么时候呢……

## 题目描述

平面直角坐标系上有 $n + m$ 个点，其中：

- 有 $n$ 个 $\rm A$ 类点，它们在初始时依次位于位置 $(1, 0), (2, 0), (3, 0), \dots, (n, 0)$。
- 有 $m$ 个 $\rm B$ 类点，它们在初始时依次位于位置 $(0, 1), (0, 2), (0, 3), \dots, (0, m)$。

在某一个时刻，$\rm A, B$ 类点同时开始运动。具体地：

- 对于第 $i$ 个 $\rm A$ 类点，其以 $a_i$ 个单位长度每秒的速度向上（即 $y$ 轴正方向）匀速运动。特别地，若 $a_i = 0$，则该点始终保持静止。
- 对于第 $i$ 个 $\rm B$ 类点，其以 $b_i$ 个单位长度每秒的速度向右（即 $x$ 轴正方向）匀速运动。特别地，若 $b_i = 0$，则该点始终保持静止。

相遇与分离实在是再平凡不过的了。作为匆匆时光里的一名过客，在这个你暂留的驿站里，你能否帮小 T 解决这个简单的问题：求出有多少点对会在某个时刻相遇，即它们在某一刻共点。

由于你无法使时间静止，所以所有点无论相遇与否，都会永无止境地运动下去。祝愿在这道路上奔跑的你，能有一天与理想匀速相遇，永不停息。

## 说明/提示

### 样例解释 1

当 $t = 1$ 时，第 $2$ 个 $\rm A$ 类点和第 $2$ 个 $\rm B$ 类点同时到达点 $(2, 2)$。这也是在本组样例中的唯一一次相遇，故输出 $1$。

### 数据规模与约定

**本题开启捆绑测试。**

+ Subtask 0（10 pts）：$n \leq 10$，$m \leq 10$。
+ Subtask 1（20 pts）：$n \leq 5\times 10^3$，$m \leq 5\times 10^3$。
+ Subtask 2（30 pts）：保证 $\forall a_i \geq 1$，$\forall b_i \geq 1$。
+ Subtask 3（40 pts）：无特殊限制。

对于所有数据，$1 \leq n, m \leq 10^6$，$0 \leq a_i, b_i \leq 10^9$。

## 样例 #1

### 输入

```
3 3
1 2 3
3 2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3
2 5 1
83 101 98```

### 输出

```
0```

# AI分析结果

### 综合分析与结论

本题的核心在于通过数学推导，将相遇条件转化为 \(a_i \times i = b_j \times j\)，从而避免直接计算浮点数带来的精度问题。大多数题解都采用了这一思路，并通过哈希表（如 `unordered_map`）来优化查询效率，避免暴力枚举带来的高时间复杂度。

#### 关键思路与技巧：
1. **数学推导**：通过相遇时间的等式推导出 \(a_i \times i = b_j \times j\)，避免了浮点数运算。
2. **哈希表优化**：使用 `unordered_map` 来存储 \(a_i \times i\) 的值，并在遍历 \(b_j \times j\) 时快速查询匹配项，将时间复杂度从 \(O(n^2)\) 降低到 \(O(n)\)。
3. **特判处理**：对于 \(a_i = 0\) 或 \(b_j = 0\) 的情况，直接跳过，因为这些点无法与其他点相遇。

#### 可拓展之处：
- **类似问题**：类似的时间-速度-距离问题，可以通过数学推导转化为简单的等式，进而使用哈希表或排序+双指针等优化手段。
- **数据结构**：在处理大量数据时，哈希表是一种高效的查询工具，适用于需要快速查找的场景。

#### 推荐题目：
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374) - 考察树状数组的基本操作。
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908) - 考察归并排序或树状数组的应用。
3. [P1496 火烧赤壁](https://www.luogu.com.cn/problem/P1496) - 考察区间合并与贪心算法。

### 所选题解

#### 题解1：作者：cff_0102 (赞：13)
- **星级**：★★★★★
- **关键亮点**：思路清晰，代码简洁，使用了 `unordered_map` 优化查询效率，并正确处理了 \(a_i = 0\) 和 \(b_j = 0\) 的情况。
- **代码核心**：
  ```cpp
  unordered_map<long long, int> ai;
  for(int i=1;i<=n;i++){
      cin>>a[i];
      if(a[i]!=0){
          long long temp=1ll*i*a[i];
          ai[temp]++;
      }
  }
  long long s=0;
  for(int j=1;j<=m;j++){
      cin>>b[j];
      if(b[j]!=0){
          long long temp=1ll*j*b[j];
          if(ai.count(temp)){
              s+=ai[temp];
          }
      }
  }
  ```
- **个人心得**：作者强调了特判的重要性，并指出 `unordered_map` 的常数较小，适合本题。

#### 题解2：作者：20111019Yu (赞：3)
- **星级**：★★★★
- **关键亮点**：从暴力解法出发，逐步优化到使用 `unordered_map`，思路清晰，代码可读性强。
- **代码核心**：
  ```cpp
  unordered_map<int, int> mp;
  for(int i=1;i<=n;i++){
      cin>>a;
      mp[a * i]++;
  }
  int ans=0;
  for(int i=1;i<=m;i++){
      cin>>b;
      ans += !b ? 0 : mp[b * i];
  }
  ```
- **个人心得**：作者从暴力解法入手，逐步优化，强调了 `unordered_map` 的优势。

#### 题解3：作者：WZWZWZWY (赞：2)
- **星级**：★★★★
- **关键亮点**：代码简洁，直接使用 `unordered_map` 进行查询，处理了 \(b_j = 0\) 的情况。
- **代码核心**：
  ```cpp
  unordered_map <long long, int> a;
  for (int i = 1; i <= n; i++) {
      cin >> x;
      a[x * i]++;
  }
  for (int i = 1; i <= m; i++) {
      cin >> x;
      if (x) ans += a[x * i];
  }
  ```
- **个人心得**：作者强调了 `unordered_map` 的高效性，并指出 \(b_j = 0\) 的情况需要特判。

### 通用建议与扩展思路
如果所有题解均未达到4星，建议从以下方面进行改进：
1. **代码优化**：进一步优化代码结构，减少冗余操作，提高运行效率。
2. **详细解释**：在题解中加入更多关于算法选择的解释，帮助读者理解优化思路。
3. **复杂度分析**：提供更详细的时间复杂度分析，帮助读者理解算法的效率。

通过以上改进，题解的质量将得到显著提升。

---
处理用时：38.95秒
# 题目信息

# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# AI分析结果

### 综合分析与结论

本题的核心是通过区间动态规划（DP）来求解矩阵取数游戏的最大得分。所有题解都基于以下关键点：
1. **独立性**：每行的取数操作互不影响，因此可以逐行处理。
2. **区间DP**：每行的取数过程可以转化为区间DP问题，状态转移方程通常为从区间两端取数并乘以相应的权重。
3. **高精度处理**：由于数据范围较大，多数题解使用 `__int128` 或高精度算法来避免溢出。

各题解的主要区别在于状态转移方程的具体形式、初始化方式、以及高精度处理的实现细节。部分题解在代码可读性和优化程度上表现较好，而另一些则在思路清晰度和实现细节上有所欠缺。

### 所选高星题解

#### 1. 作者：zhylj (★★★★★)
- **关键亮点**：
  - 使用 `__int128` 简化了高精度处理，代码简洁且高效。
  - 状态转移方程清晰，直接从小区间向大区间转移，避免了复杂的初始化。
  - 代码结构清晰，易于理解和扩展。
- **核心代码**：
  ```cpp
  __int128 solve(__int128 a[]) {
      memset(f, 0, sizeof(f));
      for(int len=0; len<=m; ++len)
          for(int i=1; i+len<=m; ++i)
              f[i][i+len] = max(2*f[i+1][i+len] + 2*a[i], 2*f[i][i+len-1] + 2*a[i+len]);
      return f[1][m];
  }
  ```
  **实现思想**：通过 `len` 控制区间长度，从小区间逐步向大区间转移，每次转移时乘以2来模拟取数时的权重。

#### 2. 作者：qhr2023 (★★★★☆)
- **关键亮点**：
  - 使用 `__int128` 处理大数，避免了高精度算法的复杂性。
  - 状态转移方程直接从大区间向小区间转移，思路清晰。
  - 代码结构合理，易于理解。
- **核心代码**：
  ```cpp
  for (int len=1; len<=m; ++len) 
      for (int l=1, r=l+len-1; r<=m; ++l, ++r)
          f[l][r] = max(f[l+1][r] + a[i][l], f[l][r-1] + a[i][r]) * 2;
  ```
  **实现思想**：通过 `len` 控制区间长度，从大区间逐步向小区间转移，每次转移时乘以2来模拟取数时的权重。

#### 3. 作者：Tomwsc (★★★★☆)
- **关键亮点**：
  - 使用 `__int128` 处理大数，代码简洁。
  - 状态转移方程清晰，直接从大区间向小区间转移。
  - 代码结构合理，易于理解。
- **核心代码**：
  ```cpp
  for(register int i=1; i<=m; i++)
      for(register int j=m; j>=i; j--)
          dp[i][j] = max(dp[i-1][j] + a[i-1] * poww[m-j+i-1], dp[i][j+1] + a[j+1] * poww[m-j+i-1]);
  ```
  **实现思想**：通过 `i` 和 `j` 控制区间，从大区间逐步向小区间转移，每次转移时乘以相应的权重。

### 最优关键思路与技巧
1. **区间DP**：将每行的取数过程转化为区间DP问题，状态转移方程通常为从区间两端取数并乘以相应的权重。
2. **高精度处理**：使用 `__int128` 或高精度算法来避免溢出，简化代码实现。
3. **转移顺序**：从小区间向大区间转移或从大区间向小区间转移，具体选择取决于初始化方式和状态转移方程的设计。

### 拓展思路与类似题目
- **类似题目**：
  1. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880) - 区间DP经典问题，与本题的区间DP思路类似。
  2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040) - 区间DP与树形DP的结合，适合进一步练习区间DP。
  3. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063) - 区间DP问题，适合巩固区间DP的应用。

### 个人心得摘录
- **调试经历**：部分题解提到在调试过程中发现 `__int128` 的初始化问题，提醒了在写代码时要注意数据类型的正确使用。
- **踩坑教训**：有题解提到在预处理2的幂时，误将 `n` 写成 `m`，导致调试时间过长，提醒了在写代码时要细心检查变量名。

### 通用建议与扩展思路
- **建议**：对于区间DP问题，建议先从简单的区间DP题目入手，逐步掌握状态转移方程的设计和优化技巧。
- **扩展思路**：可以尝试将区间DP与其他算法（如贪心、记忆化搜索等）结合，解决更复杂的动态规划问题。

---
处理用时：30.11秒
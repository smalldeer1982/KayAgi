# 题目信息

# 取数游戏

## 题目描述

一个 $N\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。

## 说明/提示

### 样例解释

对于第一组数据，取数方式如下：

$$\begin{matrix}
[67] & 75 & 63 & 10 \\
29 & 29 & [92] & 14 \\
[21] & 68 & 71 & 56 \\
8 & 67 & [91] & 25 \\
\end{matrix}$$


### 数据范围及约定

- 对于$20\%$的数据，$1\le N, M \le 3$；
- 对于$40\%$的数据，$1\le N, M\le 4$；
- 对于$60\%$的数据，$1\le N, M\le 5$；
- 对于$100\%$的数据，$1\le N, M\le 6$，$1\le T\le 20$。


## 样例 #1

### 输入

```
3
4 4
67 75 63 10
29 29 92 14
21 68 71 56
8 67 91 25
2 3
87 70 85
10 3 17
3 3
1 1 1
1 99 1
1 1 1

```

### 输出

```
271
172
99
```

# AI分析结果

### 综合分析与结论

本题的核心问题是在一个矩阵中选取不相邻的数字，使得它们的和最大。由于数据范围较小（N, M ≤ 6），大多数题解采用了深度优先搜索（DFS）或动态规划（DP）的解法。DFS解法通过回溯和标记来避免选取相邻的数字，而DP解法则通过状态压缩来优化空间和时间复杂度。

### 所选高星题解

#### 1. **绿萧 (5星)**
- **关键亮点**：使用DFS进行暴力枚举，通过`mark`数组记录每个点的状态，确保选取的数字不相邻。代码结构清晰，注释详细，适合初学者理解。
- **核心代码**：
  ```cpp
  void dfs(int x, int y) {
      if (y == m + 1) { dfs(x + 1, 1); return; }
      if (x == n + 1) { mx = max(ans, mx); return; }
      dfs(x, y + 1); // 不取此数
      if (mark[x][y] == 0) {
          ans += s[x][y];
          for (int fx = 0; fx < 8; ++fx) ++mark[x + d[fx][0]][y + d[fx][1]];
          dfs(x, y + 1);
          for (int fx = 0; fx < 8; ++fx) --mark[x + d[fx][0]][y + d[fx][1]];
          ans -= s[x][y];
      }
  }
  ```
- **个人心得**：作者提到贪心和动态规划不适合此题，转而选择DFS，强调了数据范围较小的情况下DFS的适用性。

#### 2. **IntrepidStrayer (4星)**
- **关键亮点**：使用状压DP，通过预处理合法状态，优化了时间复杂度。思路清晰，代码简洁，适合有一定DP基础的读者。
- **核心代码**：
  ```cpp
  int calc(int i, int x) {
      int res = 0;
      for (int j = m; j >= 1 && x; --j, x >>= 1) if (x & 1) res += a[i][j];
      return res;
  }
  void solve() {
      for (int i = 1; i <= n; ++i)
          for (int j = 1; j <= cnt; ++j) {
              int v = 0;
              for (int k = 1; k <= cnt; ++k)
                  if (check2(c[j], c[k])) v = max(v, f[i - 1][k]);
              f[i][j] = calc(i, c[j]) + v;
          }
  }
  ```
- **个人心得**：作者提到状压DP的适用性，并推荐了类似的题目（P1896互不侵犯），帮助读者举一反三。

#### 3. **回头是岸 (4星)**
- **关键亮点**：使用状压DP，通过预处理每一行的合法状态，优化了时间复杂度。代码结构清晰，适合有一定DP基础的读者。
- **核心代码**：
  ```cpp
  void work() {
      for (int i = 0; i < (1 << m); i++)
          if (!(i & (i >> 1)) && !(i & (i << 1))) t.push_back(i);
  }
  void solve() {
      for (int i = 1; i <= n; i++)
          for (int j = 0; j < t.size(); j++)
              for (int k = 0; k < t.size(); k++) {
                  int u = t[j], v = t[k];
                  if ((u & v) || (u & (v >> 1)) || (u & (v << 1))) continue;
                  int num1 = 0;
                  for (int l = 0; l < m; l++) if ((u & (1 << l))) num1 += a[i][m - l];
                  f[i][u] = max(f[i][u], f[i - 1][v] + num1);
              }
  }
  ```
- **个人心得**：作者提到状压DP的思路，并通过预处理合法状态优化了时间复杂度。

### 最优关键思路与技巧

1. **DFS回溯法**：通过标记和回溯，确保选取的数字不相邻，适合数据范围较小的情况。
2. **状压DP**：通过二进制状态压缩，预处理合法状态，优化了时间复杂度，适合数据范围较大的情况。

### 可拓展之处

- **类似题目**：P1896互不侵犯、P1879玉米田、P2704炮兵阵地，这些题目都涉及到状态压缩和DP的应用。

### 推荐题目

1. **P1896 互不侵犯**：考察状态压缩DP，与本题类似。
2. **P1879 玉米田**：考察状态压缩DP，与本题类似。
3. **P2704 炮兵阵地**：考察状态压缩DP，与本题类似。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中发现DFS的剪枝和回溯是关键，尤其是标记和回溯的实现细节。
- **踩坑教训**：一些作者提到贪心和动态规划不适合此题，转而选择DFS或状压DP，强调了算法选择的重要性。
- **顿悟感想**：通过预处理合法状态，状压DP的复杂度大大降低，适合数据范围较大的情况。

---
处理用时：28.98秒
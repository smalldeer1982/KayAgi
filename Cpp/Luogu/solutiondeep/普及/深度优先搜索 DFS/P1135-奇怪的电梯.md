# 题目信息

# 奇怪的电梯

## 题目背景

感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。

## 样例 #1

### 输入

```
5 1 5
3 3 1 2 5
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心是通过搜索算法（如BFS、DFS）或最短路算法（如Dijkstra、Floyd）找到从起点到终点的最短路径。题解中主要采用了BFS、DFS、Dijkstra、SPFA、Floyd等算法，其中BFS和DFS是最常见的解法。BFS由于能够保证第一次到达终点时路径最短，因此更适合本题。DFS虽然也能解决问题，但需要合理的剪枝来避免超时。

大多数题解思路清晰，代码实现较为规范，但部分题解在优化和剪枝方面做得不够，导致时间复杂度较高。整体来看，BFS的题解质量较高，尤其是结合了剪枝和状态记录的DFS题解也表现不错。

### 所选高星题解

#### 1. 作者：yummy (赞：102) - 5星
**关键亮点**：  
- 详细分析了DFS的剪枝策略，提出了正确的剪枝方法，避免了不必要的重复搜索。
- 通过记录每个节点的最小步数，确保每次搜索都是有效的，时间复杂度优化到O(n^2)。
- 代码简洁，逻辑清晰，适合初学者理解DFS的剪枝技巧。

**个人心得**：  
- 作者提到通过记录每个节点的最小步数，避免重复搜索，这是DFS剪枝的关键。  
- 强调了剪枝的重要性，避免了DFS的指数级时间复杂度。

**核心代码**：
```cpp
void dfs(int s,int t) {
    ans[s]=t;
    if(s+dis[s]<=n && t+1<ans[s+dis[s]]) dfs(s+dis[s],t+1);
    if(s-dis[s]>0  && t+1<ans[s-dis[s]]) dfs(s-dis[s],t+1);
}
```

#### 2. 作者：cff_0102 (赞：46) - 4星
**关键亮点**：  
- 使用BFS实现，通过队列维护状态，确保第一次到达终点时路径最短。
- 代码结构清晰，逻辑简单，适合初学者理解BFS的基本应用。
- 通过标记已访问的节点，避免了重复访问，时间复杂度为O(n)。

**核心代码**：
```cpp
int bfs(int st, int ed, int n) {
    queue<int> q;
    q.push(st);
    vis[st] = true;
    step[st] = 0;
    while(!q.empty()) {
        int cnt = q.front(); q.pop();
        int up = cnt + a[cnt], down = cnt - a[cnt];
        if(up <= n && !vis[up]) {
            vis[up] = true; step[up] = step[cnt] + 1; q.push(up);
            if(up == ed) return step[up];
        }
        if(down >= 1 && !vis[down]) {
            vis[down] = true; step[down] = step[cnt] + 1; q.push(down);
            if(down == ed) return step[down];
        }
    }
    return -1;
}
```

#### 3. 作者：_H17_ (赞：292) - 4星
**关键亮点**：  
- 提供了多种算法的实现（Dijkstra、SPFA、DFS、Floyd等），适合不同层次的学习者。
- 详细解释了每种算法的适用场景和复杂度，帮助读者理解不同算法的优劣。
- 代码实现规范，注释清晰，适合深入学习。

**核心代码**：
```cpp
void dijkstra(int s) {
    q.push({0,s});
    dis[s]=0;
    while(!q.empty()) {
        Pair p=q.top(); q.pop();
        if(dis[p.nd]!=p.st) continue;
        for(int i=head[p.nd];i;i=nxt[i]) {
            if(dis[tar[i]]>dis[p.nd]+w[i]) {
                dis[tar[i]]=dis[p.nd]+w[i];
                q.push({dis[tar[i]],tar[i]});
            }
        }
    }
}
```

### 最优关键思路与技巧

1. **BFS的队列管理**：通过队列维护当前层的所有状态，确保第一次到达终点时路径最短。
2. **DFS的剪枝**：通过记录每个节点的最小步数，避免重复搜索，优化时间复杂度。
3. **状态标记**：无论是BFS还是DFS，都需要标记已访问的节点，避免重复访问。

### 可拓展之处

- **类似题目**：  
  1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443) - BFS的应用。
  2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - BFS的扩展应用。
  3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - BFS与连通性问题。

### 个人心得总结

- **调试经历**：部分题解提到在DFS中如果不进行剪枝，容易超时，强调了剪枝的重要性。
- **踩坑教训**：在BFS中，忘记标记已访问节点会导致重复访问，增加时间复杂度。
- **顿悟感想**：BFS和DFS的选择取决于问题的性质，BFS适合求最短路径，DFS适合深度遍历。

---
处理用时：29.29秒
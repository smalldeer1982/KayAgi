# 题目信息

# [USACO1.5] 八皇后 Checker Challenge

## 题目描述

一个如下的 $6 \times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。

![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)

上面的布局可以用序列 $2\ 4\ 6\ 1\ 3\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：

行号 $1\ 2\ 3\ 4\ 5\ 6$

列号 $2\ 4\ 6\ 1\ 3\ 5$

这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  
并把它们以上面的序列方法输出，解按字典顺序排列。  
请输出前 $3$ 个解。最后一行是解的总个数。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$6 \le n \le 13$。

题目翻译来自NOCOW。

USACO Training Section 1.5


## 样例 #1

### 输入

```
6
```

### 输出

```
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
```

# AI分析结果

### 综合分析与结论

八皇后问题是一个经典的回溯算法问题，要求在一个N×N的棋盘上放置N个皇后，使得它们互不攻击。题解中主要采用了深度优先搜索（DFS）结合回溯的方法，通过标记列、对角线等位置来避免冲突。大部分题解通过优化标记方式（如使用数组或位运算）来提高效率，部分题解还引入了打表或对称性优化来进一步减少计算量。

### 所选高星题解

#### 1. **题解作者：ybb756032937**  
**星级：★★★★★**  
**关键亮点：**  
- 使用四个数组分别标记行、列、两条对角线，思路清晰且易于理解。
- 通过回溯法逐步放置皇后，并在每次放置后更新标记，确保不冲突。
- 代码结构简洁，注释详细，适合初学者学习。

**核心代码：**
```cpp
void queen(int i) {
    if (i > n) {
        print();
        return;
    }
    for (int j = 1; j <= n; j++) {
        if ((!b[j]) && (!c[i + j]) && (!d[i - j + n])) {
            a[i] = j;
            b[j] = 1; c[i + j] = 1; d[i - j + n] = 1;
            queen(i + 1);
            b[j] = 0; c[i + j] = 0; d[i - j + n] = 0;
        }
    }
}
```

#### 2. **题解作者：XG_Zepto**  
**星级：★★★★☆**  
**关键亮点：**  
- 使用二维数组`check`来标记列和两条对角线，减少空间复杂度。
- 通过`line + j`和`line - j + n`来标记对角线，避免负数问题。
- 代码简洁，逻辑清晰，适合进阶学习。

**核心代码：**
```cpp
void eq(int line) {
    if (line > n) {
        sum++;
        if (sum > 3) return;
        for (int i = 1; i <= n; i++) printf("%d ", ans[i]);
        printf("\n");
        return;
    }
    for (int i = 1; i <= n; i++) {
        if ((!check[0][i]) && (!check[1][line + i]) && (!check[2][line - i + n])) {
            ans[line] = i;
            check[0][i] = 1; check[1][line + i] = 1; check[2][line - i + n] = 1;
            eq(line + 1);
            check[0][i] = 0; check[1][line + i] = 0; check[2][line - i + n] = 0;
        }
    }
}
```

#### 3. **题解作者：钱逸凡**  
**星级：★★★★☆**  
**关键亮点：**  
- 引入`dancing links`算法，虽然代码较长，但提供了另一种解决思路。
- 通过精确覆盖问题来求解八皇后问题，适合对算法有深入理解的学习者。
- 代码结构复杂，但思路新颖，适合拓展思维。

**核心代码：**
```cpp
void dfs(int x, int a, int b, int c) {
    if (x > n) {
        sum++;
        if (sum > 3) return;
        for (int i = 1; i <= n; i++) printf("%d ", ans[i]);
        printf("\n");
        return;
    }
    int pos = (a | b | c) ^ p;
    while (pos) {
        int i = pos & (-pos);
        pos -= i;
        ans[x] = _log(i);
        dfs(x + 1, a | i, (b | i) << 1, (c | i) >> 1);
    }
}
```

### 最优关键思路与技巧

1. **回溯法**：通过递归逐步放置皇后，并在每次放置后更新标记，确保不冲突。
2. **标记优化**：使用数组或位运算来标记列、对角线，避免重复计算。
3. **对称性优化**：利用棋盘的对称性减少计算量，如只计算一半的解再对称扩展。
4. **打表**：对于较大的N，预先计算部分结果，减少运行时计算量。

### 推荐题目

1. **P1219 八皇后**（本题）
2. **P1074 靶形数独**（类似回溯问题）
3. **P1433 吃奶酪**（回溯与状态压缩结合）

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中遇到数组越界问题，通过调整数组大小或偏移量解决。
- **踩坑教训**：使用位运算时需要注意负数的处理，部分题解通过加偏移量避免负数问题。
- **顿悟感想**：通过回溯法逐步放置皇后，并在每次放置后更新标记，确保不冲突，这种思路非常适用于类似的排列组合问题。

---
处理用时：37.49秒
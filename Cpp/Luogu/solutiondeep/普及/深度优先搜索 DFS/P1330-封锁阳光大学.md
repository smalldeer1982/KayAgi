# 题目信息

# 封锁阳光大学

## 题目描述

曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。

阳光大学的校园是一张由 $n$ 个点构成的无向图，$n$ 个点之间由 $m$ 条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。

询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。


## 说明/提示

【数据规模】   
对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，保证没有重边。

## 样例 #1

### 输入

```
3 3
1 2
1 3
2 3
```

### 输出

```
Impossible
```

## 样例 #2

### 输入

```
3 2
1 2
2 3
```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心是**二分图染色**，要求每条边的两个端点必须染成不同的颜色，且最终选择颜色较少的方案。难点在于处理图的连通性，以及如何在染色过程中判断是否存在冲突。大多数题解采用了DFS或BFS进行染色，部分题解使用了并查集来优化连通性判断。

### 所选高质量题解

#### 1. 作者：KesdiaelKen (赞：438)
- **星级**: 5星
- **关键亮点**: 
  - 思路清晰，详细解释了二分图染色的原理。
  - 代码结构简洁，使用了链式前向星存储图，优化了空间复杂度。
  - 通过`used`数组避免重复遍历，提高了效率。
- **个人心得**: 
  - 作者提到“如果知道思路了，便会非常简单”，强调了理解题意和算法思路的重要性。
- **核心代码**:
  ```cpp
  bool dfs(int node, int color) {
      if (used[node]) {
          if (col[node] == color) return true;
          return false;
      }
      used[node] = true;
      sum[col[node] = color]++;
      bool tf = true;
      for (int i = head[node]; i != 0 && tf; i = edge[i].nexty) {
          tf = tf && dfs(edge[i].t, 1 - color);
      }
      return tf;
  }
  ```

#### 2. 作者：dingcx (赞：176)
- **星级**: 4星
- **关键亮点**: 
  - 使用了BFS进行染色，避免了递归深度过大的问题。
  - 通过`used`数组记录颜色，简化了冲突判断。
  - 代码注释详细，适合初学者理解。
- **核心代码**:
  ```cpp
  bool bfs(int start) {
      used[start] = 1;
      sum[1] = 1, sum[2] = 0;
      q.push(start);
      while (!q.empty()) {
          int u = q.front(); q.pop();
          for (int k = h[u]; k; k = e[k].next) {
              int v = e[k].v;
              if (used[v] == used[u]) return 1;
              if (used[v] == 0) {
                  used[v] = used[u] % 2 + 1;
                  sum[used[v]]++;
                  q.push(v);
              }
          }
      }
      return 0;
  }
  ```

#### 3. 作者：wshz (赞：158)
- **星级**: 4星
- **关键亮点**: 
  - 使用了并查集来优化连通性判断，减少了重复遍历。
  - 通过`h`数组记录异色点，简化了冲突判断。
  - 代码结构清晰，适合有一定基础的读者。
- **核心代码**:
  ```cpp
  void xx(int x, int y) {
      int qq = find(x);
      if (qq != y) {
          f[y] = qq;
          t[qq] += t[y];
      }
  }
  ```

### 最优关键思路与技巧

1. **二分图染色**: 通过DFS或BFS对图进行染色，确保相邻节点颜色不同。
2. **连通性处理**: 使用并查集或遍历时记录已访问节点，避免重复处理。
3. **冲突判断**: 在染色过程中，若发现相邻节点颜色相同，则直接输出“Impossible”。
4. **优化存储**: 使用链式前向星或邻接表存储图，减少空间复杂度。

### 可拓展之处

- **同类型题**: 类似题目包括判断图是否为二分图、求最大匹配等。
- **算法套路**: 二分图染色、并查集、DFS/BFS遍历等算法可以应用于多种图论问题。

### 推荐题目

1. **P3386 【模板】二分图最大匹配**: 考察二分图匹配的基本算法。
2. **P1337 [JSOI2008]星球大战**: 考察图的连通性与并查集的应用。
3. **P1525 关押罪犯**: 考察二分图染色与冲突判断。

### 个人心得总结

- **调试经历**: 部分题解提到在处理图的连通性时容易出错，建议在遍历时记录已访问节点，避免重复处理。
- **踩坑教训**: 部分题解在染色时未考虑图的连通性，导致错误，建议在处理多个连通块时分别处理。
- **顿悟感想**: 理解题意和算法思路是解决问题的关键，代码实现只是工具。

---
处理用时：28.82秒
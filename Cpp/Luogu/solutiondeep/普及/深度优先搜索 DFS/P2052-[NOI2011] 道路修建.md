# 题目信息

# [NOI2011] 道路修建

## 题目描述

在 W 星球上有 $n$ 个国家。为了各自国家的经济发展，他们决定在各个国家之间建设双向道路使得国家之间连通。但是每个国家的国王都很吝啬，他们只愿意修建恰好 $n - 1$ 条双向道路。

每条道路的修建都要付出一定的费用，这个费用等于道路长度乘以道路两端 的国家个数之差的绝对值。例如，在下图中，虚线所示道路两端分别有 $2$ 个、$4$ 个国家，如果该道路长度为 $1$，则费用为 $1×|2 - 4|=2$。图中圆圈里的数字表示国家的编号。
 
 ![](https://cdn.luogu.com.cn/upload/pic/2604.png) 

由于国家的数量十分庞大，道路的建造方案有很多种，同时每种方案的修建费用难以用人工计算，国王们决定找人设计一个软件，对于给定的建造方案，计算出所需要的费用。请你帮助国王们设计一个这样的软件。


## 说明/提示

对于 $100\%$ 的数据，$1\leq a_i, b_i\leq n$，$0\leq c_i\leq10^6$，$2\leq n\leq 10^6$。
|测试点编号|$n=$|
|:-:|:-:|
|$1$|$2$|
|$2$|$10$|
|$3$|$100$|
|$4$|$200$|
|$5$|$500$|
|$6$|$600$|
|$7$|$800$|
|$8$|$1000$|
|$9$|$10^4$|
|$10$|$2\times 10^4$|
|$11$|$5\times 10^4$|
|$12$|$6\times 10^4$|
|$13$|$8\times 10^4$|
|$14$|$10^5$|
|$15$|$6\times 10^5$|
|$16$|$7\times 10^5$|
|$17$|$8\times 10^5$|
|$18$|$9\times 10^5$|
|$19,20$|$10^6$|



## 样例 #1

### 输入

```
6
1 2 1
1 3 1
1 4 2
6 3 1
5 2 1```

### 输出

```
20```

# AI分析结果

### 综合分析与结论

本题的核心是通过DFS遍历树，计算每条边的贡献。贡献的计算公式为：`|n - 2 * size[v]| * w`，其中`size[v]`是以`v`为根的子树的节点数，`w`是边的权重。大多数题解都采用了DFS遍历树的思路，通过递归计算子树大小，并在遍历过程中累加每条边的贡献。

### 最优关键思路与技巧

1. **DFS遍历树**：通过DFS遍历树，计算每个节点的子树大小，并在遍历过程中计算每条边的贡献。
2. **贡献公式**：利用公式`|n - 2 * size[v]| * w`计算每条边的贡献，避免了复杂的数学推导。
3. **无向图的处理**：由于树是无向图，建边时需要双向建边，确保DFS能够正确遍历整棵树。

### 可拓展之处

1. **类似问题**：类似的问题可以通过DFS或BFS遍历树，计算每条边的贡献或路径的权重。例如，计算树的直径、树的重心等。
2. **优化技巧**：在处理大规模数据时，可以考虑使用非递归的DFS或BFS，避免栈溢出问题。

### 推荐题目

1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
2. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)
3. [P2016 战略游戏](https://www.luogu.com.cn/problem/P2016)

### 所选高星题解

#### 1. 作者：Melon_Musk (5星)
**关键亮点**：
- 思路清晰，详细解释了贡献公式的推导过程。
- 代码简洁，易于理解，使用了邻接表存储树结构。
- 通过DFS递归计算子树大小，并在遍历过程中累加贡献。

**核心代码**：
```cpp
void dfs(int x,int fa)
{
    size[x]=1;
    for(int i=head[x];i;i=e[i].nt)
    {
        int to=e[i].to;
        if(fa==to) continue;
        dfs(to,x);
        size[x]+=size[to];
        ans+=e[i].w*abs(2*size[to]-n);
    }
}
```

#### 2. 作者：Aw顿顿 (4星)
**关键亮点**：
- 详细解释了题意和贡献公式的推导过程。
- 代码实现清晰，使用了结构体存储边信息，便于扩展。
- 通过DFS递归计算子树大小，并在遍历过程中累加贡献。

**核心代码**：
```cpp
void dfs(int x,int fa){
    s[x]=1;
    for(int i=h[x];i;i=e[i].nxt){
        int v=e[i].v,w=e[i].w;
        if(v!=fa){
            dfs(v,x);
            ans+=abs(n-2*s[v])*w;
            s[x]+=s[v];
        }
    }
}
```

#### 3. 作者：kradcigam (4星)
**关键亮点**：
- 思路清晰，详细解释了贡献公式的推导过程。
- 代码简洁，使用了vector存储邻接表，便于理解。
- 通过DFS递归计算子树大小，并在遍历过程中累加贡献。

**核心代码**：
```cpp
void dfs(int x, int fa) {
    sz[x] = 1;
    for (auto i : v[x]) {
        if (i.first != fa) {
            dfs(i.first, x);
            sz[x] += sz[i.first];
            ans += 1ll * i.second * abs(sz[i.first] - (n - sz[i.first]));
        }
    }
}
```

### 个人心得摘录

- **Melon_Musk**：通过DFS遍历树，计算每条边的贡献，思路清晰，代码简洁。
- **Aw顿顿**：详细解释了题意和贡献公式的推导过程，代码实现清晰，便于扩展。
- **kradcigam**：使用了vector存储邻接表，代码简洁，易于理解。

### 通用建议与扩展思路

1. **DFS/BFS遍历**：在处理树结构问题时，DFS和BFS是常用的遍历方法，能够有效解决问题。
2. **贡献公式**：通过数学推导，简化问题，减少计算复杂度。
3. **无向图的处理**：在处理无向图时，建边时需要双向建边，确保遍历的完整性。

---
处理用时：22.82秒
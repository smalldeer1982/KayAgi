# 题目信息

# [NOIP 1996 提高组] 挖地雷

## 题目描述

在一个地图上有 $N\ (N \le 20)$ 个地窖，每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。当地窖及其连接的数据给出之后，某人可以从任一处开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。


## 说明/提示

**【题目来源】**

NOIP 1996 提高组第三题

## 样例 #1

### 输入

```
5
10 8 4 7 6
1 1 1 0
0 0 0
1 1
1
```

### 输出

```
1 3 4 5
27```

# AI分析结果

### 综合分析与结论

本题的核心是寻找一条路径，使得路径上的地雷数总和最大。由于地窖之间的连接是单向的，且路径只能向下挖，因此问题可以转化为在有向无环图（DAG）中寻找最长路径。题解中主要采用了以下几种思路：

1. **DFS暴力搜索**：通过枚举每个地窖作为起点，进行深度优先搜索，记录路径和地雷数，最后比较得出最大值。这种方法虽然简单，但由于数据范围较小（N≤20），能够通过。
2. **动态规划（DP）**：通过定义状态 `f[i]` 表示以第 `i` 个地窖为终点的最大地雷数，利用状态转移方程 `f[i] = max(f[j]) + a[i]` 进行递推。这种方法时间复杂度较低，适合较大数据范围。
3. **记忆化搜索**：结合DFS和DP，通过记录已经计算过的状态，避免重复计算，提高效率。
4. **图论算法**：将问题转化为图的最长路径问题，使用SPFA或Floyd等算法求解。

### 所选高星题解

#### 1. **作者：Drawing_Yang (4星)**
- **关键亮点**：使用顺推的动态规划思路，定义 `f[i]` 为以第 `i` 个节点结束的最大值，状态转移方程清晰易懂。通过 `pre[i]` 数组记录前驱节点，递归输出路径，代码简洁且易于理解。
- **个人心得**：作者提到“看各位大佬用的基本上都是逆推的思想，本蒟蒻就发一个顺推的把”，表明了对不同思路的尝试和总结。

```cpp
void print(int x) {
    if (pre[x]==0) {
        printf("%d",x);
        return;
    }
    print(pre[x]);
    printf(" %d",x); 
}
```

#### 2. **作者：vectorwyx (4星)**
- **关键亮点**：详细解释了DP的三要素（数组、方程、初始化），并通过最长上升子序列的类比，帮助读者理解状态转移方程。代码结构清晰，注释详细，适合初学者学习。
- **个人心得**：作者提到“尽管数据很水可以搜索”，表明了对不同算法的权衡。

```cpp
for(int i=2;i<=n;++i){
    dp[i]=a[i];
    for(int j=i-1;j>0;--j){
        if(rd[j][i]&&dp[i]<dp[j]+a[i]){
            dp[i]=dp[j]+a[i];
            p[i]=j;
        }
    }
    if(ans<dp[i]) ans=dp[i], pos=i;
}
```

#### 3. **作者：sshwy (4星)**
- **关键亮点**：使用记忆化搜索，定义 `d[i]` 为从 `i` 出发能获得的最多地雷数量，通过 `count(u)` 函数进行递归计算，避免了重复计算，提高了效率。思路清晰，代码结构合理。
- **个人心得**：作者提到“本尊也不多说，记忆化搜索（）思维简单”，表明了对记忆化搜索的偏爱。

```cpp
int count(int u) {
    if(d[u]) return d[u];
    int v=0, k=-1;
    for(int i=1; i<=n; i++)
        if(linker[u][i]) {
            if(d[i]==0) d[i]=count(i);
            if(d[i]>v) v=d[i], k=i;
        }
    next[u]=k;
    return v+w[u];
}
```

### 最优关键思路与技巧

1. **动态规划**：通过定义状态 `f[i]` 表示以第 `i` 个地窖为终点的最大地雷数，利用状态转移方程 `f[i] = max(f[j]) + a[i]` 进行递推。这种方法时间复杂度较低，适合较大数据范围。
2. **记忆化搜索**：结合DFS和DP，通过记录已经计算过的状态，避免重复计算，提高效率。
3. **路径记录**：通过 `pre[i]` 数组记录前驱节点，递归输出路径，代码简洁且易于理解。

### 拓展思路与同类型题

1. **同类型题**：
   - [P1048 采药](https://www.luogu.com.cn/problem/P1048)：背包问题，与DP思路类似。
   - [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)：最长上升子序列的变种。
   - [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)：经典的动态规划问题。

2. **拓展思路**：对于更大的数据范围，可以考虑使用图论算法（如SPFA或Floyd）求解最长路径问题，或者进一步优化DP的空间复杂度。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)

---
处理用时：31.28秒
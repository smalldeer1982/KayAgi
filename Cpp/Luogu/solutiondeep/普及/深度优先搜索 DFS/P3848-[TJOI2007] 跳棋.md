# 题目信息

# [TJOI2007] 跳棋

## 题目背景

在一个n×n的棋盘上，布满了0和1，如图（a）所示（n=7），为叙述方便，将0用字母表示，如图（b）。

![](https://cdn.luogu.com.cn/upload/pic/6077.png)


## 题目描述

跳棋规则：

（1）从某个0格出发，可以向上，下，左，右4个方向连续越过若干个（至少1个）

1格而跳入下一个0格。如图（b）中从A出发，可跳到B，或者到E，但不能直接到K。在跳到B之后还可以继续跳到F;在跳到E之后可继续跳到F或K。直到不能再跳为止。

（2）每个0格只能到达一次，给出的起始点不能再到达，也不能越过。

跳过的距离为跳过1格个数加1，如从A到B，跳过距离为3，从B到F，跳过距离为2。

问   题： 当棋盘和起始点给出之后，问最远能跳的距离是多少？

如上图（b）中，从A出发，可跳过的路线不止一条，其中一条为：

A － B － F － L － K － E  （可能不唯一）

3    2    3    3     3

它的距离为14。


## 说明/提示

$\text{upd 2022.7.27}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
4  3  2
1  0  1  0 
1  1  1  1
0  0  1  0
1  1  0  1```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

本题的核心是通过DFS搜索在棋盘上找到从起点出发的最远跳跃距离。难点在于如何正确处理跳跃规则（必须跳过至少一个1，且不能重复访问0点），以及如何高效地计算跳跃距离。大部分题解都采用了DFS+回溯的思路，但在细节处理和优化上有所不同。

### 所选高星题解

#### 1. 作者：犇犇犇犇 (★★★★☆)
**关键亮点**：
- 使用`while`循环处理连续跳跃，直到遇到0或边界。
- 通过`f`数组记录访问过的点，避免重复访问。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
void dfs(int x, int y, int step) {
    ans = max(ans, step);
    for (int i = 0; i < 4; i++) {
        int tx = x, ty = y, s = 0;
        while (tx + dx[i] > 0 && tx + dx[i] <= n && ty + dy[i] > 0 && ty + dy[i] <= n) {
            tx += dx[i]; ty += dy[i]; s++;
            if (m[tx][ty] == 0) break;
        }
        if (tx > 0 && tx <= n && ty > 0 && ty <= n && f[tx][ty] == 0 && m[tx][ty] == 0 && s != 1) {
            f[tx][ty] = 1;
            dfs(tx, ty, step + s);
            f[tx][ty] = 0;
        }
    }
}
```
**核心思想**：通过`while`循环处理连续跳跃，直到遇到0或边界，然后递归处理下一个跳跃点。

#### 2. 作者：JJA_ (★★★★☆)
**关键亮点**：
- 使用`while`循环处理连续跳跃，直到遇到0或边界。
- 通过`vis`数组记录访问过的点，避免重复访问。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
void dfs(int x, int y, int t) {
    chkmax(ans, t);
    vis[x][y] = 1;
    for (int i = 1; i <= 4; i++) {
        int xx = x + _x[i], yy = y + _y[i], sum = 1;
        while (xx > 0 && yy > 0 && xx <= n && yy <= n) {
            if (mapp[xx][yy] == 1) {
                xx += _x[i]; yy += _y[i]; sum++;
            } else {
                if (sum != 1 && vis[xx][yy] != 1) dfs(xx, yy, t + sum);
                break;
            }
        }
    }
    vis[x][y] = 0;
}
```
**核心思想**：通过`while`循环处理连续跳跃，直到遇到0或边界，然后递归处理下一个跳跃点。

#### 3. 作者：zilingheimei (★★★★☆)
**关键亮点**：
- 使用`while`循环处理连续跳跃，直到遇到0或边界。
- 通过`used`数组记录访问过的点，避免重复访问。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
void dfs(int x, int y, int step) {
    if (step > ans) ans = step;
    int nx, ny;
    for (int i = 0; i < 4; i++) {
        nx = x + dx[i]; ny = y + dy[i];
        while (nx >= 1 && nx <= n && ny >= 1 && ny <= n && a[nx][ny] == 1) {
            nx += dx[i]; ny += dy[i];
        }
        if (nx < 1 || nx > n || ny < 1 || ny > n) continue;
        if (used[nx][ny] == 1) continue;
        if (abs(nx - x) + abs(ny - y) == 1) continue;
        used[nx][ny] = 1;
        dfs(nx, ny, step + abs(nx - x) + abs(ny - y));
        used[nx][ny] = 0;
    }
}
```
**核心思想**：通过`while`循环处理连续跳跃，直到遇到0或边界，然后递归处理下一个跳跃点。

### 最优关键思路或技巧
- **连续跳跃处理**：使用`while`循环处理连续跳跃，直到遇到0或边界。
- **回溯与标记**：通过数组记录访问过的点，避免重复访问，并在递归结束后回溯。
- **边界与相邻判断**：在跳跃时判断是否越界或相邻，确保跳跃合法。

### 可拓展之处
- **BFS应用**：可以尝试使用BFS来解决类似问题，特别是在需要找到最短路径时。
- **状态压缩**：对于更大规模的棋盘，可以考虑使用状态压缩来优化空间复杂度。

### 推荐相似题目
1. [P1560 [USACO5.2]蜗牛的旅行](https://www.luogu.com.cn/problem/P1560)
2. [P1120 小书童的旅行](https://www.luogu.com.cn/problem/P1120)
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)

### 个人心得摘录
- **调试经历**：多位作者提到在处理连续跳跃时遇到了边界判断和相邻点处理的困难，通过逐步调试和优化解决了问题。
- **踩坑教训**：部分作者在初始实现时忽略了相邻点不能跳跃的规则，导致错误，通过增加特判解决了问题。
- **顿悟感想**：通过`while`循环处理连续跳跃，使得代码更加简洁高效，避免了复杂的条件判断。

---
处理用时：29.47秒
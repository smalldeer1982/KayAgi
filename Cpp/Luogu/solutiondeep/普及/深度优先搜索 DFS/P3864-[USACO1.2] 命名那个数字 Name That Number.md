# 题目信息

# [USACO1.2] 命名那个数字 Name That Number

## 题目描述

在威斯康辛州牛守志大农场经营者之中，都习惯于请会计部门用连续数字给母牛打上烙印。但是,母牛本身并没感到这个系统的便利,它们更喜欢用它们喜欢的名字来呼叫它们的同伴，而不是用像这个的语句"C'mon, #4364, get along."。请写一个程序来帮助可怜的牧牛工将一只母牛的烙印编号翻译成一个可能的名字。因为母牛们现在都有手机了，使用标准的按键的排布来把将数目翻译为文字:( 除了 "Q" 和 "Z")

```
2: A,B,C     5: J,K,L    8: T,U,V
3: D,E,F     6: M,N,O    9: W,X,Y
4: G,H,I     7: P,R,S
```
可接受的名字都被放在这样一个叫作"dict.txt" 的文件中，它包含一连串的少于 5,000个（准确地说是4617个）可被接受的牛的名字。 (所有的名字都是大写的且已按字典序排列) 请读入母牛的编号并返回那些能从编号翻译出来并且在字典中的名字。举例来说,编号 4734 能产生的下列各项名字: GPDG GPDH GPDI GPEG GPEH GPEI GPFG GPFH GPFI GRDG GRDH GRDI GREG GREH GREI GRFG GRFH GRFI GSDG GSDH GSDI GSEG GSEH GSEI GSFG GSFH GSFI HPDG HPDH HPDI HPEG HPEH HPEI HPFG HPFH HPFI HRDG HRDH HRDI HREG HREH HREI HRFG HRFH HRFI HSDG HSDH HSDI HSEG HSEH HSEI HSFG HSFH HSFI IPDG IPDH IPDI IPEG IPEH IPEI IPFG IPFH IPFI IRDG IRDH IRDI IREG IREH IREI IRFG IRFH IRFI ISDG ISDH ISDI ISEG ISEH ISEI ISFG ISFH ISFI 碰巧，81个中只有一个"GREG"是有效的(在字典中)。

写一个程序来对给出的编号打印出所有的有效名字，如果没有则输出NONE。编号可能有12位数字。


## 样例 #1

### 输入

```
4734
NMSL
GREG
LSDC
....(太多了不写了)```

### 输出

```
GREG
```

# AI分析结果

### 综合分析与结论

该题目要求将给定的数字编号转换为可能的字母组合，并在字典中查找有效的名字。题解中主要有以下几种思路：

1. **直接转换与匹配**：将字典中的每个名字转换为对应的数字，与输入的数字进行匹配。这种方法简单直接，但需要遍历整个字典，时间复杂度较高。
2. **DFS/BFS生成所有可能的字母组合**：通过深度优先搜索（DFS）或广度优先搜索（BFS）生成所有可能的字母组合，然后在字典中查找匹配的名字。这种方法可以避免生成无效的组合，但实现较为复杂。
3. **哈希表或映射优化**：使用哈希表或映射来存储字典中的名字及其对应的数字编码，通过哈希查找来快速匹配。这种方法在查找时效率较高，但需要额外的空间来存储哈希表。

大多数题解都采用了第一种思路，即直接转换与匹配，部分题解通过剪枝或优化减少了不必要的计算。整体来看，题解的质量参差不齐，部分题解代码可读性较差，优化不足。

### 所选高星题解

#### 题解1：作者：bjrjk (赞：24)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用`str_trans`数组将字母映射到对应的数字，避免了复杂的条件判断。
  - 通过剪枝（长度不匹配时直接跳过）减少了不必要的比较。
  - 代码结构清晰，注释详细，便于理解。
- **个人心得**：作者提到“过了一个高三，把OI全都忘光了，写写这道题练练手”，体现了对算法学习的持续热情。

```cpp
const char * str_trans = "2223334445556667 77888999";
for (int i = 0; i < Dict.size(); i++) {
    if (len != Dict[i].length()) continue;
    bool flag = true;
    for (int j = 0; j < len; j++) {
        if (str_trans[Dict[i][j] - 'A'] != str[j]) {
            flag = false;
            break;
        }
    }
    if (flag) {
        cout << Dict[i] << endl;
        global_flag = true;
    }
}
```

#### 题解2：作者：cellur925 (赞：9)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用`map`将字母映射到对应的数字，简化了转换过程。
  - 通过`check`函数判断名字是否与输入的数字匹配，逻辑清晰。
  - 代码简洁，易于理解。
- **个人心得**：作者提到“这题感觉并不需要任何算法（二分也不用），直接枚举判断就好”，体现了对问题本质的深刻理解。

```cpp
map<char,int> m;
void init() {
    m['A']=2; m['B']=2; m['C']=2;
    // 其他字母映射...
}
bool check() {
    int lenw = strlen(word);
    if (lenw != len) return 0;
    for (int i = 0; i < len; i++)
        if (m[word[i]] != (int)(num[i] - '0')) return 0;
    return 1;
}
```

#### 题解3：作者：zzqDeco (赞：4)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用预处理数组`X`将字母转换为对应的数字，避免了复杂的条件判断。
  - 通过`v`标记是否有匹配的名字，逻辑清晰。
  - 代码简洁，易于理解。
- **个人心得**：作者提到“正着不行反着来”，体现了对问题解决思路的灵活运用。

```cpp
char X[] = {'0','2','2','2','3','3','3','4','4','4','5','5','5','6','6','6','7','0','7','7','8','8','8','9','9','9','0'};
for (int i = 0; i <= 4616; i++) {
    d[i] = s[i];
    for (int j = 0; j <= s[i].size() - 1; j++) {
        s[i][j] = X[s[i][j] - 'A' + 1];
    }
}
```

### 最优关键思路与技巧

1. **字母到数字的映射**：通过数组或映射（如`map`）将字母快速转换为对应的数字，避免了复杂的条件判断。
2. **剪枝优化**：在遍历字典时，先判断名字长度是否与输入数字长度一致，不一致则直接跳过，减少不必要的比较。
3. **哈希表或映射优化**：使用哈希表或映射来存储字典中的名字及其对应的数字编码，通过哈希查找来快速匹配。

### 可拓展之处

- **类似题目**：可以拓展到其他需要将字符串转换为特定编码的题目，如电话号码的字母组合、密码破解等。
- **算法套路**：DFS/BFS生成所有可能的组合，结合剪枝优化，适用于类似的组合生成问题。

### 推荐题目

1. **P1706 全排列问题**：考察DFS生成所有可能的排列。
2. **P1036 选数**：考察DFS生成所有可能的组合。
3. **P1219 八皇后**：考察DFS生成所有可能的棋盘布局。

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中遇到的坑，如输入格式问题、哈希冲突等，提醒我们在编写代码时要注意细节。
- **顿悟感想**：部分作者通过灵活的思路转换（如“正着不行反着来”）解决了问题，体现了对问题本质的深刻理解。

---
处理用时：28.59秒
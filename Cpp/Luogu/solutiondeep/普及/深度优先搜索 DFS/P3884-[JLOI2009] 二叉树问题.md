# 题目信息

# [JLOI2009] 二叉树问题

## 题目描述

如下图所示的一棵二叉树的深度、宽度及结点间距离分别为：

- 深度：$4$
- 宽度：$4$
- 结点 8 和 6 之间的距离：$8$
- 结点 7 和 6 之间的距离：$3$

其中宽度表示二叉树上同一层最多的结点个数，节点 $u, v$ 之间的距离表示从 $u$ 到 $v$ 的最短有向路径上向根节点的边数的两倍加上向叶节点的边数。

![](https://cdn.luogu.com.cn/upload/pic/6843.png)

给定一颗以 1 号结点为根的二叉树，请求出其深度、宽度和两个指定节点 $x, y$ 之间的距离。


## 说明/提示

对于全部的测试点，保证 $1 \leq u, v, x, y \leq n \leq 100$，且给出的是一棵树。保证 $u$ 是 $v$ 的父结点。

## 样例 #1

### 输入

```
10                                
1 2                            
1 3                            
2 4
2 5
3 6
3 7
5 8
5 9
6 10
8 6
```

### 输出

```
4
4
8```

# AI分析结果

### 综合分析与结论

本题解主要围绕二叉树的深度、宽度以及节点间距离的计算展开。多数题解采用了DFS/BFS遍历、LCA（最近公共祖先）算法、Floyd算法等经典算法。其中，LCA算法是解决节点间距离的核心，而DFS/BFS则用于计算深度和宽度。部分题解还引入了树链剖分、倍增等优化技术，提升了算法的效率。

### 所选高星题解

#### 1. **题解作者：dessert (赞：40)**
- **星级：4.5**
- **关键亮点：**
  - 使用LCA算法计算节点间距离，思路清晰且代码简洁。
  - 通过DFS遍历同时计算深度和宽度，避免了多次遍历。
  - 代码结构清晰，注释详细，适合初学者理解。
- **个人心得：**
  - 作者提到“自认为比题解的LCA简单一点”，表明其对LCA算法的理解较为深入，且代码实现简洁高效。

**核心代码片段：**
```cpp
int lca(int x, int y) {
    a[x].data = 1;
    while (a[x].father != 0) {
        x = a[x].father;
        a[x].data = 1;
    }
    while (a[y].data != 1) {
        y = a[y].father;
    }
    return y;
}
```
**实现思想：** 通过标记路径上的节点，找到两个节点的最近公共祖先。

#### 2. **题解作者：常青藤 (赞：29)**
- **星级：4.0**
- **关键亮点：**
  - 使用最短路径算法（SPFA）计算节点间距离，思路新颖。
  - 通过双向边权值分配，巧妙解决了上行和下行距离的计算问题。
  - 代码实现较为优化，适合对图论有一定基础的读者。
- **个人心得：**
  - 作者提到“主要还是因为不想写LCA”，表明其对LCA算法的替代方案有独到见解。

**核心代码片段：**
```cpp
void SPFA(int s) {
    queue<int> q; q.push(s);
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    vis[s] = 1; dis[s] = 0;
    while (!q.empty()) {
        int x = q.front(); q.pop(); vis[x] = 0;
        for (int i = head[x]; i; i = edge[i].next)
            if (dis[edge[i].to] > dis[x] + edge[i].value) {
                dis[edge[i].to] = dis[x] + edge[i].value;
                if (!vis[edge[i].to]) {
                    vis[edge[i].to] = 1;
                    q.push(edge[i].to);
                }
            }
    }
}
```
**实现思想：** 通过SPFA算法计算从根节点到各节点的最短路径，进而计算节点间距离。

#### 3. **题解作者：starwolfy_rika (赞：19)**
- **星级：4.0**
- **关键亮点：**
  - 使用暴力LCA算法，代码简洁且易于理解。
  - 通过DFS遍历同时计算深度和宽度，减少了时间复杂度。
  - 代码结构清晰，适合初学者快速上手。
- **个人心得：**
  - 作者提到“不愧是黄题（LCA大家都会吧）”，表明其对LCA算法的熟练应用。

**核心代码片段：**
```cpp
int getlca(int x, int y) {
    while (x != y) {
        if (de[x] >= de[y]) x = fa[x];
        else y = fa[y];
    }
    return x;
}
```
**实现思想：** 通过暴力向上爬的方式，找到两个节点的最近公共祖先。

### 最优关键思路与技巧

1. **LCA算法的应用：** 通过LCA算法计算节点间距离，是解决此类问题的核心思路。无论是暴力LCA还是倍增LCA，都能有效解决问题。
2. **DFS/BFS遍历：** 通过一次DFS或BFS遍历，可以同时计算树的深度和宽度，避免了多次遍历的时间开销。
3. **双向边权值分配：** 在计算节点间距离时，通过给上行和下行边分配不同的权值，可以简化距离的计算。

### 可拓展之处

- **树链剖分：** 对于更大规模的数据，树链剖分可以进一步优化LCA的查询效率。
- **倍增LCA：** 倍增LCA在处理大规模数据时，效率更高，适合对时间复杂度要求较高的场景。

### 推荐题目

1. **P3379 【模板】最近公共祖先（LCA）** - 练习LCA算法的模板题。
2. **P1395 树的直径** - 考察树的深度和宽度计算的变种题。
3. **P2634 [国家集训队]聪聪可可** - 涉及树的最短路径和LCA的综合应用。

### 个人心得总结

- **调试经历：** 部分作者提到在实现过程中遇到的调试问题，如双向边权值分配的调试，表明在实现过程中需要仔细处理细节。
- **踩坑教训：** 一些作者提到在计算节点间距离时，容易忽略上行和下行距离的不同，导致计算结果错误。
- **顿悟感想：** 通过LCA算法的应用，部分作者对树的结构和路径计算有了更深的理解，表明算法学习中的顿悟对提升解题能力至关重要。

---
处理用时：35.13秒
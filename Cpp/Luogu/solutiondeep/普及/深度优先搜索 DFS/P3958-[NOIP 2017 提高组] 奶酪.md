# 题目信息

# [NOIP 2017 提高组] 奶酪

## 题目背景

NOIP2017 提高组 D2T1

## 题目描述

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?

空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：


$$\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$


## 说明/提示

【输入输出样例 $1$ 说明】

 ![](https://cdn.luogu.com.cn/upload/pic/10860.png) 

第一组数据,由奶酪的剖面图可见：

第一个空洞在 $(0,0,0)$ 与下表面相切；

第二个空洞在 $(0,0,4)$ 与上表面相切；

两个空洞在 $(0,0,2)$ 相切。

输出 `Yes`。

 
第二组数据,由奶酪的剖面图可见：

两个空洞既不相交也不相切。

输出 `No`。

 
第三组数据,由奶酪的剖面图可见：

两个空洞相交，且与上下表面相切或相交。

输出 `Yes`。

【数据规模与约定】

对于 $20\%$ 的数据，$n = 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。

对于 $40\%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $80\%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $100\%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3 
2 4 1 
0 0 1 
0 0 3 
2 5 1 
0 0 1 
0 0 4 
2 5 2 
0 0 2 
2 0 4```

### 输出

```
Yes
No
Yes```

# AI分析结果

### 综合分析与结论

本题的核心是通过判断奶酪中的空洞是否连通，从而确定Jerry是否能从下表面跑到上表面。题解中主要采用了以下几种思路：

1. **并查集**：大多数题解使用了并查集来管理空洞的连通性，通过判断两个空洞是否相交或相切来合并集合，最后检查上下表面是否在同一个集合中。
2. **DFS/BFS**：部分题解使用了深度优先搜索（DFS）或广度优先搜索（BFS）来遍历空洞的连通性，判断是否存在从下表面到上表面的路径。
3. **优化与剪枝**：一些题解通过优化距离计算（如使用平方距离避免浮点精度问题）或剪枝（如按空洞高度排序）来提高效率。

总体而言，并查集的解法较为简洁且高效，适合本题的数据规模。DFS/BFS的解法虽然直观，但在某些情况下可能会因为递归深度或队列大小而影响性能。

### 所选高星题解

#### 1. 作者：Fading (5星)
- **关键亮点**：使用并查集管理空洞的连通性，代码简洁且高效，避免了浮点精度问题。
- **个人心得**：作者提到曾因double精度问题导致样例无法通过，最终通过优化距离计算解决了问题。

```cpp
int find(int x){
    if (x!=f[x]) f[x]=find(f[x]);
    return f[x];
}

long long dis(long long x,long long y,long long z,long long x1,long long y1,long long z1){
    return (x-x1)*(x-x1)+(y-y1)*(y-y1)+(z-z1)*(z-z1);
}
```

#### 2. 作者：ikunTLE (4星)
- **关键亮点**：同样使用并查集，代码结构清晰，注释详细，易于理解。
- **个人心得**：强调了“不开long long见祖宗”的重要性，提醒注意数据范围。

```cpp
int _find(int x){
    if(x==fa[x]) return x;
    fa[x]=_find(fa[x]);
    return fa[x];
}

void _merge(int x,int y){
    int fx=_find(x),fy=_find(y);
    if(fx!=fy) fa[fx]=fy;
}
```

#### 3. 作者：Malkin_Moonlight (4星)
- **关键亮点**：使用DFS进行搜索，代码简洁，通过剪枝优化了搜索效率。
- **个人心得**：作者提到在DFS中不需要回溯标记，因为每个点只需访问一次。

```cpp
void dfs(int k){
    if(ok)return;
    if(z[k]+r>=h){
        ok=1;
        return;
    }
    v[k]=1;
    for(int i=1;i<=n;i++)
    if(!v[i]&&e(i,k))
    dfs(i);
}
```

### 最优关键思路与技巧

1. **并查集的应用**：通过并查集管理空洞的连通性，避免了复杂的图遍历，适合本题的数据规模。
2. **距离计算的优化**：使用平方距离代替浮点距离计算，避免了精度问题，提高了计算效率。
3. **剪枝与优化**：在DFS/BFS中通过剪枝（如按高度排序）减少不必要的搜索，提高算法效率。

### 可拓展之处

本题的解法可以推广到其他连通性问题，如判断图中是否存在从起点到终点的路径。类似的题目可以考察图的连通性、最短路径等。

### 推荐题目

1. **P3367 【模板】并查集**：练习并查集的基本操作。
2. **P3371 【模板】单源最短路径（弱化版）**：练习图的遍历与最短路径算法。
3. **P3388 【模板】割点（割顶）**：练习图的连通性与割点算法。

### 个人心得总结

- **调试经历**：多位作者提到因浮点精度问题或数据范围未开long long导致错误，提醒我们在编写代码时要注意数据类型的选取和精度问题。
- **顿悟感想**：通过优化距离计算和剪枝，可以有效提高算法效率，减少不必要的计算。

---
处理用时：23.72秒
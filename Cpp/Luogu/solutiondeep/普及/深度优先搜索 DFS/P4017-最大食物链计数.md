# 题目信息

# 最大食物链计数

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。


## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。


## 说明/提示

各测试点满足以下约定：

 ![](https://cdn.luogu.com.cn/upload/pic/12011.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心是计算有向无环图（DAG）中从所有入度为0的点（生产者）到所有出度为0的点（最高级消费者）的路径数量。大多数题解采用了拓扑排序结合动态规划（DP）的思路，部分题解使用了记忆化搜索。拓扑排序的优势在于其时间复杂度为O(N+M)，能够高效处理大规模数据。DP的思路是通过记录每个节点的路径数，逐步累加得到最终结果。记忆化搜索则通过避免重复计算来优化搜索过程。

### 所选高分题解

#### 1. 作者：御·Dragon (5星)
**关键亮点**：
- 详细讲解了拓扑排序的应用，结合DP思路，清晰解释了如何通过拓扑排序逐步累加路径数。
- 提供了完整的代码实现，代码结构清晰，注释详细，易于理解。
- 通过图示和样例详细说明了算法的执行过程，帮助读者更好地理解思路。

**核心代码**：
```cpp
while(!q.empty()) {
    int tot = q.front();
    q.pop();
    int len = nei[tot].size();
    for(rg int i = 0; i < len; ++i) {
        int next = nei[tot][i];
        --in[next];
        num[next] = (num[next] + num[tot]) % mod;
        if(in[next] == 0) q.push(nei[tot][i]);
    }
}
```
**核心思想**：通过拓扑排序逐步累加每个节点的路径数，最终累加所有出度为0的节点的路径数。

#### 2. 作者：Watcher (4.5星)
**关键亮点**：
- 使用了邻接表存储图结构，节省了空间，适合大规模数据。
- 通过拓扑排序和DP结合，代码简洁高效，时间复杂度为O(N+M)。
- 提供了两种实现方式（邻接矩阵和邻接表），并对比了它们的性能。

**核心代码**：
```cpp
while(!q.empty()) {
    int a = q.front();
    q.pop();
    for(int k = h[a]; k; k = d[k].n) {
        int b = d[k].b;
        f[b] += f[a];
        f[b] %= mod;
        ru[b]--;
        if(ru[b] == 0) {
            if(chu[b] == 0) ans += f[b];
            else q.push(b);
        }
    }
}
```
**核心思想**：通过拓扑排序逐步更新每个节点的路径数，最终累加所有出度为0的节点的路径数。

#### 3. 作者：一把丶抱住鑫 (4星)
**关键亮点**：
- 代码简洁，适合初学者理解，使用了链式前向星存储图结构。
- 通过拓扑排序和DP结合，思路清晰，代码实现简单。
- 提供了详细的注释，帮助读者理解代码逻辑。

**核心代码**：
```cpp
while(!q.empty()) {
    int p = q.front();
    q.pop();
    for(int i = head[p]; i; i = e[i].nxt) {
        int go = e[i].to;
        d[go] = (d[go] + d[p]) % mod;
        in[go]--;
        if(in[go] == 0) q.push(go);
    }
}
```
**核心思想**：通过拓扑排序逐步累加每个节点的路径数，最终累加所有出度为0的节点的路径数。

### 最优关键思路与技巧
1. **拓扑排序结合DP**：通过拓扑排序逐步更新每个节点的路径数，最终累加所有出度为0的节点的路径数。
2. **记忆化搜索**：通过记录每个节点的路径数，避免重复计算，优化搜索过程。
3. **邻接表存储图结构**：节省空间，适合大规模数据。

### 可拓展之处
- **类似算法套路**：拓扑排序结合DP的思路可以应用于其他DAG上的路径计数问题，如最长路径、最短路径等。
- **其他图算法**：如Dijkstra、Floyd等算法也可以用于解决类似的图论问题。

### 推荐题目
1. P3183 [HAOI2016]食物链
2. P4017 最大食物链计数
3. P1137 旅行计划

### 个人心得总结
- **调试经历**：部分题解提到了在调试过程中遇到的重复计算问题，通过记忆化搜索或拓扑排序优化了算法。
- **踩坑教训**：一些题解提醒了在处理大规模数据时，邻接矩阵可能会超内存，建议使用邻接表。
- **顿悟感想**：通过拓扑排序和DP的结合，能够高效解决DAG上的路径计数问题，这种思路在类似问题中具有通用性。

---
处理用时：26.37秒
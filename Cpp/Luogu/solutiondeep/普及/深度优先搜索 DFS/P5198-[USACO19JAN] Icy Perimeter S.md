# 题目信息

# [USACO19JAN] Icy Perimeter S

## 题目背景

USACO 一月月赛银组第二题

## 题目描述

Farmer John 要开始他的冰激凌生意了！他制造了一台可以生产冰激凌球的机器，然而不幸的是形状不太规则，所以他现在希望优化一下这台机器，使其产出的冰激凌球的形状更加合理。
机器生产出的冰激凌的形状可以用一个 $N \times N$（$1 \leq N \leq 1000$）的矩形图案表示，例如：

```
##....
....#.
.#..#.
.#####
...###
....##
```

每个 `.` 字符表示空的区域，每个 `#` 字符表示一块 $1 \times 1$ 的正方形格子大小的冰激凌。

不幸的是，机器当前工作得并不是很正常，可能会生产出多个互不相连的冰激凌球（上图中有两个）。一个冰激凌球是连通的，如果其中每个冰激凌的正方形格子都可以从这个冰激凌球中其他所有的冰激凌格子出发重复地前往东、南、西、北四个方向上相邻的冰激凌格子所到达。

Farmer John 想要求出他的面积最大的冰激凌球的面积和周长。冰激凌球的面积就是这个冰激凌球中 `#` 的数量。如果有多个冰激凌球并列面积最大，他想要知道其中周长最小的冰激凌球的周长。在上图中，小的冰激凌球的面积为 $2$，周长为 $6$，大的冰激凌球的面积为 $13$，周长为 $22$。

注意一个冰激凌球可能在中间有“洞”（由冰激凌包围着的空的区域）。如果这样，洞的边界同样计入冰激凌球的周长。冰激凌球也可能出现在被其他冰激凌球包围的区域内，在这种情况下它们计为不同的冰激凌球。例如，以下这种情况包括一个面积为 $1$ 的冰激凌球，被包围在一个面积为 $16$ 的冰激凌球内：

```
#####
#...#
#.#.#
#...#
#####
```

同时求得冰激凌球的面积和周长十分重要，因为 Farmer John 最终想要最小化周长与面积的比值，他称这是他的冰激凌的“冰周率”。当这个比率较小的时候，冰激凌化得比较慢，因为此时冰激凌单位质量的表面积较小。


## 样例 #1

### 输入

```
6
##....
....#.
.#..#.
.#####
...###
....##```

### 输出

```
13 22```

# AI分析结果

### 综合分析与结论

本题的核心是通过搜索算法（DFS或BFS）找到冰激凌球的连通块，并计算其面积和周长。大多数题解采用了DFS或BFS，部分题解还提到了并查集的使用。DFS和BFS的实现思路基本一致，都是通过遍历每个点，找到连通块并计算面积和周长。周长的计算通常是通过判断每个冰激凌块的四周是否为边界或空地来实现的。

### 所选高星题解

#### 1. 作者：Swire (赞：25) - 4星
**关键亮点**：
- 使用DFS实现，代码简洁易懂。
- 通过判断边界和空地来计算周长，思路清晰。
- 提供了防止爆栈的优化建议。

**个人心得**：
- 提到DFS可能爆栈，建议使用优化手段防止栈溢出。

**核心代码**：
```cpp
void dfs(int x,int y) {
	if(vis[x][y]) return ;
	vis[x][y]=true;
	S++;
	for(int d=0; d<4; d++) {
		int xx=x+dx[d],yy=y+dy[d];
		if(xx<1||xx>n||yy<1||yy>n||ice[xx][yy]=='.') C++;
		if(ice[xx][yy]=='#') dfs(xx,yy);
	}
}
```

#### 2. 作者：YyunSu (赞：24) - 4星
**关键亮点**：
- 使用DFS实现，代码结构清晰。
- 通过函数`mmp`计算每个冰激凌块的周长，逻辑清晰。
- 通过边界处理防止越界，代码健壮。

**个人心得**：
- 提到DFS的实现细节，如边界处理和周长计算。

**核心代码**：
```cpp
int mmp (int r1, int r2) {
	int k = 0;
	for (int w = 0; w < 4; w++){
		int xx = r1 + dir[w][0];
		int yy = r2 + dir[w][1];
		if (a[xx][yy] == '.') k++;
	}
	return k; 
}
```

#### 3. 作者：OnlyU (赞：7) - 4星
**关键亮点**：
- 使用BFS实现，代码结构清晰。
- 通过判断四周是否为边界或空地来计算周长，思路清晰。
- 代码中使用了结构体来存储冰激凌块的信息，便于维护。

**核心代码**：
```cpp
void bfs(int sx,int sy) {
	queue<bfc>que;
	a.x=sx;
	a.y=sy;
	int num1=1,num2=0; 
	for(int i=0; i<4; i++) {
		c.x=a.x+dx[i];
		c.y=a.y+dy[i];
		if(maze[c.x][c.y]==-1) num2++;
	}
	v[sx][sy]=1;
	que.push(a);
	while(!que.empty()) {
		b=que.front();
		que.pop();
		for(int i=0; i<4; i++) {
			c.x=b.x+dx[i];
			c.y=b.y+dy[i];
			if(c.x>=1&&c.x<=n&&c.y>=1&&c.y<=n&&v[c.x][c.y]==0&&maze[c.x][c.y]==1) {
				num1++;
				v[c.x][c.y]=1;
				for(int j=0; j<4; j++) {
					d.x=c.x+dx[j];
					d.y=c.y+dy[j];
					if(maze[d.x][d.y]==-1) num2++;
				}
				que.push(c);
			}
		}
	}
}
```

### 最优关键思路与技巧

1. **DFS/BFS遍历**：通过DFS或BFS遍历每个冰激凌块，计算其面积和周长。
2. **周长计算**：通过判断每个冰激凌块的四周是否为边界或空地来计算周长。
3. **防止爆栈**：对于DFS，可以通过优化手段（如`#pragma GCC optimize("no-stack-protector")`）防止栈溢出。

### 可拓展之处

- **并查集**：可以使用并查集来维护冰激凌块的连通性，进一步优化算法。
- **多关键字排序**：在多个冰激凌块面积相同的情况下，可以通过多关键字排序选择周长最小的块。

### 推荐相似题目

1. [P1451 求细胞数量](https://www.luogu.org/problem/P1451)
2. [P1162 填涂颜色](https://www.luogu.org/problem/P1162)
3. [P1141 01迷宫](https://www.luogu.org/problem/P1141)

---
处理用时：25.81秒
# 题目信息

# [USACO18JAN] MooTube S

## 题目背景

*本题与 [金组同名题目](/problem/P4185) 在题意上一致，唯一的差别是数据范围。*

## 题目描述

在业余时间，Farmer John 创建了一个新的视频共享服务，他将其命名为 MooTube。在 MooTube 上，Farmer John 的奶牛可以录制，分享和发现许多有趣的视频。他的奶牛已经发布了 $N$ 个视频（$1 \leq N \leq 5000$），为了方便将其编号为  $1 \ldots N$ 。然而，FJ 无法弄清楚如何帮助他的奶牛找到他们可能喜欢的新视频。

FJ 希望为每个 MooTube 视频创建一个“推荐视频”列表。这样，奶牛将被推荐与他们已经观看过的视频最相关的视频。

FJ 设计了一个“相关性”度量标准，顾名思义，它确定了两个视频相互之间的相关性。他选择 $N-1$ 对视频并手动计算其之间的相关性。然后，FJ 将他的视频建成一棵树，其中每个视频是节点，并且他手动将 $N-1$ 对视频连接。为了方便，FJ 选择了 $N-1$ 对，这样任意视频都可以通过一条连通路径到达任意其他视频。 FJ 决定将任意一对视频的相关性定义为沿此路径的任何连接的最小相关性。

Farmer John 想要选择一个 $K$ 值，以便在任何给定的 MooTube 视频旁边，推荐所有其他与该视频至少有 $K$ 相关的视频。然而，FJ 担心会向他的奶牛推荐太多的视频，这可能会分散他们对产奶的注意力！因此，他想设定适当的 $K$ 值。 Farmer John希望得到您的帮助，回答有关 $K$ 值的推荐视频的一些问题。

## 样例 #1

### 输入

```
4 3
1 2 3
2 3 2
2 4 4
1 2
4 1
3 1```

### 输出

```
3
0
2```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在树结构中高效地查询与某个节点相关性大于等于给定值 \( k \) 的节点数量。题解中主要出现了两种思路：

1. **暴力DFS/BFS**：直接从查询节点出发，遍历所有边权大于等于 \( k \) 的路径，统计可达节点数。该方法简单直观，但由于每次查询都需要遍历整个树，时间复杂度较高，适合小规模数据。
2. **离线并查集**：将边和查询按 \( k \) 从大到小排序，逐步合并边权大于等于当前 \( k \) 的节点，利用并查集维护连通块大小。该方法通过离线处理和并查集的优化，显著降低了时间复杂度，适合大规模数据。

### 所选高星题解

#### 1. **作者：HsKr (★★★★★)**
- **关键亮点**：使用离线并查集，将边和查询按 \( k \) 从大到小排序，逐步合并边权大于等于当前 \( k \) 的节点，利用并查集维护连通块大小。思路清晰，代码结构良好，时间复杂度优化明显。
- **核心代码**：
  ```cpp
  while(j<n&&E[j].w>=Q[i].k){
      uni(E[j].u,E[j].v);
      j++;
  }
  ans[Q[i].id]=size[find(Q[i].v)]-1;
  ```
- **实现思想**：通过排序和并查集的合并操作，逐步处理每个查询，确保每次查询时只处理边权大于等于 \( k \) 的边，从而高效地计算连通块大小。

#### 2. **作者：Little09 (★★★★★)**
- **关键亮点**：同样采用离线并查集，代码简洁明了，注释详细，易于理解。通过排序和并查集的合并操作，逐步处理每个查询，确保每次查询时只处理边权大于等于 \( k \) 的边。
- **核心代码**：
  ```cpp
  for(;num<n;num++){
      if (t[num+1].z>=q[i].k) {
          int x1=find(t[num+1].x),y1=find(t[num+1].y);
          fa[x1]=y1;
          res[x1]+=res[y1];
          res[y1]=res[x1];
      }
      else break;
  }
  int p=find(q[i].x);
  ans[q[i].id]=res[q[i].x]-1;
  ```
- **实现思想**：通过排序和并查集的合并操作，逐步处理每个查询，确保每次查询时只处理边权大于等于 \( k \) 的边，从而高效地计算连通块大小。

#### 3. **作者：jichi (★★★★★)**
- **关键亮点**：详细解释了为什么按 \( k \) 从大到小排序是正确的，并提供了清晰的代码实现。通过排序和并查集的合并操作，逐步处理每个查询，确保每次查询时只处理边权大于等于 \( k \) 的边。
- **核心代码**：
  ```cpp
  while(cur<=n&&e[cur].w>=a[i].k){
      merge(find(e[cur].u),find(e[cur].v));cur++;
  }
  ans[a[i].id]=siz[find(a[i].v)]-1;
  ```
- **实现思想**：通过排序和并查集的合并操作，逐步处理每个查询，确保每次查询时只处理边权大于等于 \( k \) 的边，从而高效地计算连通块大小。

### 最优关键思路与技巧

1. **离线处理**：将查询按 \( k \) 从大到小排序，逐步处理，避免重复计算。
2. **并查集优化**：利用并查集维护连通块大小，通过路径压缩和按秩合并优化查询和合并操作。
3. **排序策略**：将边和查询按 \( k \) 从大到小排序，确保每次查询时只处理边权大于等于 \( k \) 的边。

### 可拓展之处

- **类似问题**：可以应用于其他需要在树或图中查询满足某些条件的节点数量的问题，如最小生成树、最大流等。
- **算法套路**：离线处理+并查集的组合可以应用于其他需要高效处理多个查询的问题，如区间查询、连通性问题等。

### 推荐题目

1. **P4185 [USACO18JAN]MooTube G**：本题的加强版，数据范围更大，适合练习并查集优化。
2. **P3367 【模板】并查集**：并查集的基础模板题，适合初学者练习。
3. **P1196 [NOI2002] 银河英雄传说**：并查集的应用题，适合进一步理解并查集的使用场景。

### 个人心得摘录

- **HsKr**：通过排序和并查集的合并操作，逐步处理每个查询，确保每次查询时只处理边权大于等于 \( k \) 的边，从而高效地计算连通块大小。
- **Little09**：通过排序和并查集的合并操作，逐步处理每个查询，确保每次查询时只处理边权大于等于 \( k \) 的边，从而高效地计算连通块大小。
- **jichi**：详细解释了为什么按 \( k \) 从大到小排序是正确的，并提供了清晰的代码实现。

---
处理用时：31.20秒
# 题目信息

# [YsOI2020] 植树

## 题目背景


Ysuperman 响应号召，决定在幼儿园里植树。

## 题目描述

Ysuperman 有一棵 $n$ 个节点的无根树 $T$。如果你不知道树是什么，TA 很乐意告诉你，树是一个没有环的无向联通图。

既然树是无根的，那就没有办法种植。Ysuperman 研究了很久的园艺，发现一个节点如果可以成为根，它必须十分平衡，这意味着以它为根时，与它**直接相连的节点，他们的子树大小都相同**。

你作为幼儿园信息组一把手，Ysuperman 给你一棵树，你能在 $1s$ 内找到所有可能成为根的节点吗？

## 说明/提示

### 样例说明

#### 样例说明 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/gsiug69y.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1\}$，因为只有一个所以大小全部相同。

所以答案为 $1,2$。

#### 样例说明 $2$

![](https://cdn.luogu.com.cn/upload/image_hosting/p7fsretv.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1,3\}$，子树大小分别为 $\{1,2\}$，不相同。

以 $3$ 为根时，与 $3$ 直接相连的点有 $\{2,4\}$，子树大小分别为 $\{2,1\}$，不相同。

以 $4$ 为根时，与 $4$ 直接相连的点有 $\{3\}$，因为只有一个所以大小全部相同。

所以答案为 $1,4$。

----

### 数据范围

**本题采用捆绑测试。**

| $\rm{subtask}$ | $n$ |  分数|
| :-----------: | :-----------: | :----: |
| $1$ | $\le 5000$ | $40$ |
| $2$ | $\le 10^6$ | $60$ |

对于 $100\%$ 的数据，满足 $1 \le n\le 10^6$。

------

### 提示

由于输入输出量较大，你可能需要快速输入/输出。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
1 2 ```

## 样例 #2

### 输入

```
4
1 2
2 3
3 4
```

### 输出

```
1 4 
```

## 样例 #3

### 输入

```
9
1 2
1 3
4 1
5 1
1 6
1 9
8 1
1 7
```

### 输出

```
1 2 3 4 5 6 7 8 9 
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在O(n)的时间复杂度内找到所有满足条件的根节点。大多数题解都采用了以某个节点（通常为1号节点）为根，进行一次DFS遍历，计算每个节点的子树大小，然后通过比较各子树大小来判断是否满足条件。部分题解还引入了树的重心或叶子节点的特性来进一步优化。

### 所选高星题解

#### 1. 作者：WanderingTrader (5星)
**关键亮点**：
- 详细分析了题目需求，并通过手动构造样例验证思路。
- 代码结构清晰，逻辑严谨，注释详细，易于理解。
- 使用了邻接表存储树结构，并通过DFS计算子树大小，最后通过比较子树大小来判断是否满足条件。

**个人心得**：
- 通过手动构造样例验证思路，确保代码的正确性。
- 强调了多叉树的操作相对简单，主要在于DFS的正确实现。

**核心代码**：
```cpp
int dfs(int x,int fa)
{
	int size = es[x].size(),num = 0;
	root[x] = 1;
	_for(0,size - 1)
		if(es[x][i] != fa)
		{
			d[x] += dfs(es[x][i],x);
			if(!num)
				num = d[es[x][i]];
			if(num != d[es[x][i]]) root[x] = 0;
		}
	++ d[x]; 
	if(x != 1 && num && num != n - d[x]) root[x] = 0;
	return d[x];
}
```

#### 2. 作者：Pretharp (4星)
**关键亮点**：
- 引入了树的重心概念，通过判断重心是否满足条件来优化算法。
- 代码简洁，逻辑清晰，使用了vector和map等STL容器，提高了代码的可读性。

**核心代码**：
```cpp
void dfs(int x, int fa) {
  siz[x] = 1, w[x] = 0;
  for (int i : v[x]) {
    if (i == fa) continue;
    dfs(i, x);
    siz[x] += siz[i], w[x] = max(w[x], siz[i]);
  }
  w[x] = max(w[x], n - siz[x]);
  if (w[x] <= n / 2) {
    c[++tot] = x;
  }
}
```

#### 3. 作者：云雷心柠檬听 (4星)
**关键亮点**：
- 详细分析了树的结构变化，通过图示帮助理解子树大小的变化。
- 代码结构清晰，逻辑严谨，注释详细，易于理解。

**核心代码**：
```cpp
void dfs(int u,int fa){
	int t=-1,ys=1;
	for(int i=hd[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u);
		sz[u]+=sz[v];
		if(t==-1) t=sz[v];
		else if(t!=sz[v]) ys=0;
	}
	sz[u]++;
	if(t!=-1&&n-sz[u]!=t&&n-sz[u]!=0) ys=0;
	if(ys) ans[++nA]=u;
}
```

### 最优关键思路与技巧

1. **DFS遍历**：通过一次DFS遍历计算每个节点的子树大小，避免重复计算。
2. **子树大小比较**：通过比较各子树大小来判断是否满足条件，特别注意根节点的特殊情况。
3. **树的重心**：引入树的重心概念，进一步优化算法。

### 可拓展之处

- **树的重心应用**：在树的相关问题中，树的重心常用于优化算法，如树的直径、树的分治等。
- **子树大小计算**：子树大小的计算在树的相关问题中非常常见，如树的直径、树的分治等。

### 推荐题目

1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
2. [P2014 选课](https://www.luogu.com.cn/problem/P2014)
3. [P3178 [HAOI2015]树上操作](https://www.luogu.com.cn/problem/P3178)

### 个人心得总结

- **手动构造样例**：通过手动构造样例验证思路，确保代码的正确性。
- **DFS的正确实现**：多叉树的操作相对简单，主要在于DFS的正确实现。
- **树的重心**：引入树的重心概念，进一步优化算法。

---
处理用时：24.38秒
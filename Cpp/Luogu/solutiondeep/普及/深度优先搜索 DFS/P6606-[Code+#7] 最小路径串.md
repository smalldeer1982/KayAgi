# 题目信息

# [Code+#7] 最小路径串

## 题目描述

$n$ 个点 $m$ 条边的无向图中，所有点用从 `0` 开始的 `6` 位数字串编号，即 `000000`、`000001`、`000002`、……直到 $n-1$ 对应的 $6$ 位数字串。保证 $n\le 10^6$，所以 $6$ 位的编号不会溢出。

对于除了 `000000` 以外的每个点，你需要找到一条从 `000000` 出发且不经过重复点的路径，使得路径上所有点的数字串顺次连接形成的串的字典序最小。比较两个不同的串的字典序的方法是：如果其中某个串是另一个的前缀，则较短的串字典序较小；否则，找出两个串从左往右扫描时遇到的首个不相等的位置，在这个位置上的数字较小的串字典序较小。

由于输出路径过于麻烦，你不需要完整地输出路径，只需要将路径上所有点的数字串视作一个整数，输出这个数对 $998244353$ 取模的结果。

## 说明/提示

### 样例解释

- 从 `000000` 到 `000001` 所求的路径对应的串为 `000000000002000001`。
- 从 `000000` 到 `000002` 所求的路径对应的串为 `000000000002`。
- 从 `000000` 到 `000003` 所求的路径对应的串为 `000000000002000001000003`，对 $998244353$ 取模后为 $517560944$。
- 从 `000000` 到 `000004` 不存在路径。

### 子任务

子任务 $1$（$11$ 分）
- $1\le n\le 10^6, m = 0$。

子任务 $2$（$55$ 分）
- $1\le n\le 10, 0\le m\le20$。

子任务 $3$（$34$ 分）
- $1\le n\le 10^6, 0\le m\le 10^6$。

## 样例 #1

### 输入

```
5 5
000000000003000001000003000001000002000002000000000002000003```

### 输出

```
2000001
2
517560944
-1```

# AI分析结果

### 综合分析与结论

本题的核心问题是在无向图中找到从起点 `000000` 到其他所有点的字典序最小的路径，并将路径上的节点编号拼接成一个整数后取模。题解主要集中在使用 **DFS** 或 **BFS** 遍历图，并通过 **贪心策略** 保证路径的字典序最小。大多数题解都采用了 **邻接表** 存储图结构，并对邻接表中的节点进行排序，以确保每次遍历时优先访问编号较小的节点，从而保证路径的字典序最小。

### 最优关键思路与技巧

1. **贪心策略**：每次优先访问编号较小的节点，确保路径的字典序最小。
2. **邻接表排序**：对每个节点的邻接表进行排序，确保遍历时按字典序从小到大访问。
3. **DFS/BFS遍历**：通过深度优先搜索（DFS）或广度优先搜索（BFS）遍历图，记录路径并计算最终结果。
4. **取模运算**：在计算路径拼接的整数时，及时取模，避免溢出。

### 可拓展之处

- **类似问题**：可以扩展到其他需要最小字典序路径的问题，如最小生成树、最短路径等。
- **优化**：可以考虑使用优先队列（堆）来进一步优化遍历顺序，确保每次选择最小的节点。

### 推荐题目

1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)

### 个人心得摘录

- **blankslpl**：提醒了不开 `long long` 的风险，强调了数据类型的重要性。
- **opzc35**：强调了处理重边和自环的细节，避免重复访问。
- **FZY_CZY**：提到使用 `vector` 存储图结构，优化内存使用。

### 所选高分题解

#### 1. 作者：blankslpl (4星)
**关键亮点**：
- 使用链式前向星存储图结构，代码简洁高效。
- 通过 `set` 对邻接节点进行排序，确保字典序最小。
- 提醒了 `long long` 的重要性，避免溢出。

**核心代码**：
```cpp
void dfs(int son, int dis) {
    len[son] = dis;
    set<int> se;
    for (int i = head[son]; i; i = e[i].next) {
        se.insert(e[i].to);
    }
    for (set<int>::iterator ite = se.begin(); ite != se.end(); ite++) {
        if (!vis[*ite]) {
            vis[*ite] = 1;
            dfs(*ite, (dis * 1000000 + *ite) % mod);
        }
    }
}
```

#### 2. 作者：opzc35 (4星)
**关键亮点**：
- 使用 `vector` 存储图结构，代码简洁易读。
- 对邻接表进行排序，确保字典序最小。
- 强调了处理重边和自环的细节。

**核心代码**：
```cpp
void dfs(int u, ll now) {
    ans[u] = now;
    for (auto v : g[u]) {
        if (ans[v] != -1) continue;
        dfs(v, (now * 1000000 + v) % mod);
    }
}
```

#### 3. 作者：FZY_CZY (4星)
**关键亮点**：
- 使用 `vector` 存储图结构，优化内存使用。
- 对邻接表进行排序，确保字典序最小。
- 强调了取模运算的重要性，避免溢出。

**核心代码**：
```cpp
void dfs(int u, LL now) {
    ans[u] = now;
    for (auto v : g[u]) {
        if (ans[v] != -1) continue;
        dfs(v, (now * 1000000 + v) % Mod);
    }
}
```

### 通用建议与扩展思路

- **数据类型**：在处理大数时，务必使用 `long long` 或更高精度的数据类型，避免溢出。
- **图结构**：根据问题规模选择合适的图结构存储方式，如邻接表或链式前向星。
- **遍历顺序**：在需要最小字典序路径的问题中，优先访问编号较小的节点是关键。
- **取模运算**：在计算过程中及时取模，避免结果过大导致溢出或错误。

---
处理用时：24.26秒
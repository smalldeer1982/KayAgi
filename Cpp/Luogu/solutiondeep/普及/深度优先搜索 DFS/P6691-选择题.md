# 题目信息

# 选择题

## 题目背景

小 L 喜欢逻辑推理。

一天，他在一本由英国哲士沃·协德编写的《我也不知道为什么要叫这个名字的一本有关逻辑学的书》中翻到了一道奇特的问题，但他并不会做。他知道你善于用程序解决问题，于是决定让你来帮助他完成这些问题。

## 题目描述

这是一道有 $n$ 个选项的选择题，每个选项的内容都很独特。第 $i$ 个选项的内容的形式如下：

+ 第 $a_i$ 个选项是正确/错误的

小 L 认为这种题目的答案不一定是唯一的，所以他想问题这道题有多少种合法的答案（可以全部正确或全部错误）。他还想问你这么多答案中，正确选项最多和最少的答案分别有多少个正确选项。

当然，如果这道题不存在合法的答案，你可以直接回答小 L `No answer`。

## 说明/提示

对于样例一，一共有下面 $2$ 种正确答案：

+ 第 $1,2,3$ 个选项是正确的。
+ 第 $4$ 个选项是正确的。

其中正确选项最多的答案有 $3$ 个选项正确，正确选项最少的答案有 $1$ 个选项正确。

### 数据范围
对于 $10\%$ 的数据，$n\leq 10$。  
对于 $30\%$ 的数据，$n\leq 100$。  
对于 $60\%$ 的数据，$n\leq 10^3$。  
对于 $100\%$ 的数据，$n\leq 10^6,1\leq a_i\leq n,i\neq a_i,opt_i\in\{0,1\}$。

## 样例 #1

### 输入

```
4
2 1
4 0
1 1
2 0```

### 输出

```
2
3
1```

## 样例 #2

### 输入

```
10
4 1
7 0
2 0
3 1
7 1
5 0
9 1
10 1
8 0
1 1```

### 输出

```
No answer```

# AI分析结果

### 综合分析与结论

本题的核心在于处理选项之间的依赖关系，判断是否存在合法解，并计算合法解的数量、最多和最少正确选项的数量。题解中主要采用了以下几种思路：

1. **并查集**：通过带权并查集处理选项之间的依赖关系，判断是否存在矛盾，并计算合法解的数量。
2. **图论（BFS/DFS）**：将选项之间的依赖关系转化为图，通过染色法判断是否存在合法解，并统计正确选项的数量。
3. **扩展域并查集**：将每个选项的两种状态（正确/错误）分别处理，通过并查集判断是否存在矛盾。

这些方法的核心思想都是通过处理选项之间的依赖关系，判断是否存在合法解，并通过连通块的数量和状态来计算合法解的数量。

### 所选高星题解

#### 1. **作者：lnwzy (赞：18)**  
**星级：5星**  
**关键亮点**：  
- 使用带权并查集处理选项之间的依赖关系，思路清晰，代码简洁。
- 通过路径压缩和关系数组 `r` 来维护选项之间的正确性关系，高效判断是否存在矛盾。
- 通过并查集的数量和状态计算合法解的数量、最多和最少正确选项的数量。

**核心代码片段**：
```cpp
int fa(int x)
{
	if(f[x]==x)
	{
		return f[x];
	}
	int t=f[x];
	f[x]=fa(f[x]);
	r[x]=(r[t]+r[x])%2;
	return f[x];
}
```

#### 2. **作者：littleKtian (赞：16)**  
**星级：4星**  
**关键亮点**：  
- 将选项之间的依赖关系转化为图，通过染色法判断是否存在合法解。
- 通过连通块的数量和状态计算合法解的数量、最多和最少正确选项的数量。
- 思路清晰，代码结构合理。

**核心代码片段**：
```cpp
void bfs(int x){
	hed=tail=0;
	now=0;
	q[++tail]=x;
	while(hed<tail){
		hed++;
		x=q[hed];
		v[x]=1;
		for(int i=head[x];i;i=ne[i]){
			int y=to[i];
			if(v[y]){
				if(d[x]^sz[i]!=d[y]){
					flag=1;return ;
				}
				continue;
			}
			d[y]=d[x]^sz[i];
			q[++tail]=y;
			v[y]=1;
			now+=d[y];
		}
	}
}
```

#### 3. **作者：lndjy (赞：4)**  
**星级：4星**  
**关键亮点**：  
- 通过DFS染色法处理选项之间的依赖关系，判断是否存在合法解。
- 通过连通块的数量和状态计算合法解的数量、最多和最少正确选项的数量。
- 代码简洁，思路清晰。

**核心代码片段**：
```cpp
void dfs(int now,int co)
{
	v[now]=co+1;
	c[co]++;
	for(int i=head[now];i;i=e[i].nxt)
	{
		if(v[e[i].to]==(co^e[i].w)+1) 
		{
			cout<<"No answer";
			exit(0);
		}
		if(v[e[i].to]) continue;
		dfs(e[i].to,co^(!e[i].w));
	}
}
```

### 最优关键思路与技巧

1. **带权并查集**：通过维护选项之间的正确性关系，高效判断是否存在矛盾，并计算合法解的数量。
2. **图论染色法**：将选项之间的依赖关系转化为图，通过染色法判断是否存在合法解，并统计正确选项的数量。
3. **连通块处理**：通过连通块的数量和状态计算合法解的数量、最多和最少正确选项的数量。

### 可拓展之处

1. **类似题目**：处理依赖关系、判断合法解、统计解的数量等问题，可以使用类似的并查集或图论方法。
2. **扩展应用**：类似思路可以应用于其他需要处理依赖关系、判断合法解的问题，如逻辑推理、约束满足问题等。

### 推荐题目

1. **P1525 关押罪犯**：使用并查集处理罪犯之间的冲突关系。
2. **P2024 食物链**：通过带权并查集处理生物之间的食物链关系。
3. **P1892 团伙**：使用并查集处理团伙之间的关系，判断是否存在矛盾。

### 个人心得总结

- **调试经历**：在处理依赖关系时，需要注意选项之间的正确性关系，避免出现矛盾。
- **踩坑教训**：在处理连通块时，需要确保每个连通块的状态一致性，避免出现错误。
- **顿悟感想**：通过带权并查集或图论染色法，可以高效处理选项之间的依赖关系，判断合法解并统计解的数量。

---
处理用时：24.46秒
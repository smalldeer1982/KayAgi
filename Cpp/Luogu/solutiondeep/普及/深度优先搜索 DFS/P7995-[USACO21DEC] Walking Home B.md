# 题目信息

# [USACO21DEC] Walking Home B

## 题目描述

奶牛 Bessie 正准备从她最喜爱的草地回到她的牛棚。

农场位于一个 $N \times N$ 的方阵上（$2 \leq N \leq 50$），其中她的草地在左上角，牛棚在右下角。Bessie 想要尽快回家，所以她只会向下或向右走。有些地方有草堆（haybale），Bessie 无法穿过；她必须绕过它们。

Bessie 今天感到有些疲倦，所以她希望改变她的行走方向至多 $K$ 次（$1 \leq K \leq 3$）。

Bessie 有多少条不同的从她最爱的草地回到牛棚的路线？如果一条路线中 Bessie 经过了某个方格而另一条路线中没有，则认为这两条路线不同。

## 说明/提示

【样例解释】

我们将使用一个由字符 D 和 R 组成的字符串来表示 Bessie 的路线，其中 D 和 R 分别表示 Bessie 向下（down）或向右（right）移动。

第一个子测试用例中，Bessie 的两条可能的路线为 DDRR 和 RRDD。

第二个子测试用例中，Bessie 的四条可能的路线为 DDRR，DRRD，RDDR 和 RRDD。

第三个子测试用例中，Bessie 的六条可能的路线为 DDRR，DRDR，DRRD，RDDR，RDRD 和 RRDD。

第四个子测试用例中，Bessie 的两条可能的路线为 DDRR 和 RRDD。

第五和第六个子测试用例中，Bessie 不可能回到牛棚。

第七个子测试用例中，Bessie 的六条可能的路线为 DDRDRR，DDRRDR，DDRRRD，RRDDDR，RRDDRD 和 RRDRDD。

【数据范围】

- 测试点 2 满足 $K = 1$。
- 测试点 3-5 满足 $K = 2$。
- 测试点 6-10 满足 $K = 3$。

## 样例 #1

### 输入

```
7
3 1
...
...
...
3 2
...
...
...
3 3
...
...
...
3 3
...
.H.
...
3 2
.HH
HHH
HH.
3 3
.H.
H..
...
4 3
...H
.H..
....
H...```

### 输出

```
2
4
6
2
0
0
6```

# AI分析结果

### 综合分析与结论

本题的核心是从起点到终点的路径计数问题，且路径只能向下或向右移动，且转弯次数有限制。题解中主要采用了**DFS**和**DP**两种思路，其中DP更为高效，尤其是通过状态转移方程和记忆化优化来避免重复计算。DFS虽然直观，但在未优化的情况下容易超时，因此大多数题解通过剪枝或记忆化来提升效率。

#### 关键思路与技巧：
1. **状态定义**：DP中通常使用四维状态 `dp[i][j][k][l]`，表示在 `(i,j)` 位置，已经转弯 `k` 次，且当前方向为 `l`（0表示向右，1表示向下）。
2. **状态转移**：根据当前方向是否改变，分别累加来自左方或上方的路径数，并更新转弯次数。
3. **剪枝优化**：在DFS中，若当前转弯次数已达上限且未到达终点，则直接剪枝。
4. **初始化**：特别注意起点和相邻点的初始化，避免重复计算。

#### 推荐题目：
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002) - 类似路径计数问题，但无转弯限制。
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433) - 状态压缩DP，涉及路径规划。
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 背包问题，类似状态转移思想。

### 精选题解

#### 1. 作者：BetaCutS（★★★★★）
**关键亮点**：
- 使用记忆化搜索优化DFS，避免了重复计算。
- 通过四维数组记录状态，清晰且高效。

**核心代码**：
```cpp
int dfs(int x, int y, int t, int way) {
    if (t > k || a[x][y]) return 0;
    if (g[x][y][t][way] != -1) return g[x][y][t][way];
    if (x == n && y == n) return 1;
    int sum = 0;
    if (x < n && !a[x + 1][y]) sum += dfs(x + 1, y, way ? t : t + 1, 1);
    if (y < n && !a[x][y + 1]) sum += dfs(x, y + 1, way ? t + 1 : t, 0);
    g[x][y][t][way] = sum;
    return sum;
}
```
**个人心得**：
- 记忆化搜索能有效减少重复计算，提升效率。

#### 2. 作者：Reseamus（★★★★☆）
**关键亮点**：
- 针对不同 `K` 值进行枚举，简化了问题。
- 通过模拟路径，直观且易于理解。

**核心代码**：
```cpp
if (k == 1) {
    bool flag_1 = false, flag_2 = false;
    for (int i = 1; i <= n; i++) if (a[1][i] == 'H') flag_1 = true;
    for (int i = 1; i <= n; i++) if (a[i][1] == 'H') flag_2 = true;
    ans = !flag_1 + !flag_2;
}
```
**个人心得**：
- 通过枚举路径，简化了复杂的状态转移。

#### 3. 作者：uid_310801（★★★★☆）
**关键亮点**：
- 使用DP，状态转移方程清晰。
- 初始化处理得当，避免了边界问题。

**核心代码**：
```cpp
dp[i][j][l][0] += dp[i][j - 1][l][0];
dp[i][j][l][1] += dp[i - 1][j][l][1];
if (l != 0) {
    dp[i][j][l][0] += dp[i][j - 1][l - 1][1];
    dp[i][j][l][1] += dp[i - 1][j][l - 1][0];
}
```
**个人心得**：
- DP的状态转移方程设计是关键，初始化要特别注意。

### 通用建议与扩展思路
- **DP优化**：对于路径计数问题，DP通常比DFS更高效，尤其是在状态转移清晰的情况下。
- **剪枝技巧**：在DFS中，合理剪枝可以大幅提升效率，尤其是在转弯次数有限的情况下。
- **状态压缩**：对于类似问题，可以考虑状态压缩DP，进一步优化空间复杂度。

通过以上分析和题解，可以更好地理解路径计数问题的解决思路，并掌握相关优化技巧。

---
处理用时：28.62秒
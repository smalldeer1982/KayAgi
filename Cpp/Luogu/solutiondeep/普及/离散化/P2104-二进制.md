# 题目信息

# 二进制

## 题目描述

小 Z 最近学会了二进制数，他觉得太小的二进制数太没意思，于是他想对一个巨大二进制数做以下 $4$ 种基础运算：

运算 $1$：将整个二进制数加 $1$。

运算 $2$：将整个二进制数减 $1$。

运算 $3$：将整个二进制数乘 $2$。

运算 $4$：将整个二进制数整除 $2$。

小 Z 很想知道运算后的结果，他只好向你求助。

（Ps：为了简化问题，数据保证 `+`，`-` 操作不会导致最高位的进位与退位）

## 说明/提示


对于 $30\%$ 的数据，$1 \leq n,m \leq 1000$。

对于 $60\%$ 的数据，$1 \leq n,m \leq 10^5$。

对于 $100\%$ 的数据，$1 \leq n,m \leq 5 \times 10^6$。

## 样例 #1

### 输入

```
4 10
1101
*/-*-*-/*/```

### 输出

```
10110```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是模拟二进制数的加减乘除运算。不同题解在数据存储和处理进位借位的方式上有所不同。数据存储方面，有的使用数组，有的使用字符串，还有的使用`vector`、栈、双端队列等数据结构；处理进位借位时，有的采用即时处理，有的采用延迟处理。

### 所选题解
- **作者：Stay_Hungry（5星）**
    - **关键亮点**：提出延迟标记的思路，将进位借位操作延迟到最后统一处理，时间复杂度优化到$O(m)$，思路清晰，代码简洁。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e6 + 5;
int f[N * 2], n, m, r; char c;
signed main() {
    ios :: sync_with_stdio(false);
    cin >> n >> m; r = n;
    for(int i = 1; i <= n; ++i) cin >> c, f[i] = c - '0';
    while(m --) {
        cin >> c;
        if(c == '*') f[++ r] = 0;
        else if(c == '+') ++ f[r];
        else if(c == '-') -- f[r];
        else f[r - 1] += f[r] >> 1, --r;
    }
    for(int i = r; i > 1; --i) {
        f[i - 1] += f[i] >> 1;
        f[i] = f[i] & 1;
    }
    for(int i = 1; i <= r; ++i) cout << f[i]; cout << "\n";
    return 0;
}
```
    - **核心思想**：每次操作只在最后一位打延迟标记，乘法时向后拓展一位，除法时将延迟标记向前推，最后统一处理延迟标记。

- **作者：jx2014wzd（4星）**
    - **关键亮点**：提供了两种实现方式，一种是常规的循环实现，另一种是使用`main`函数递归实现，对逻辑运算符的短路特性运用巧妙。
    - **核心代码（常规循环实现）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[100000000] = {0}, oper[6000000] = {0};
int main()
{
    int n, m;
    scanf("%d%d%s%s", &n, &m, s, oper);
    for(int i = 0; i < m; i++)
        switch(oper[i])
        {
            case '*': s[n++] = '0';  break;
            case '/': s[--n] = '\0'; break;
            case '+': for(int k = n; s[--k]!= '0' && (s[k] = '0') ||!(s[k] = '1'); ); break;
            case '-': for(int k = n; s[--k]!= '1' && (s[k] = '1') ||!(s[k] = '0'); ); break;
        }
    puts(s);
}
```
    - **核心思想**：根据不同的运算符对字符串进行相应操作，乘法在末尾加`0`，除法去掉末尾字符，加法和减法从后往前遍历处理进位借位。

- **作者：luckydrawbox（4星）**
    - **关键亮点**：将加减运算封装成函数，代码结构清晰，递归处理进位借位，思路直观。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+10;
int n,m,a[N];
string s;
void jia_jian(int x,int f)
{
    a[x]+=f;
    if(a[x]>1||a[x]<0)
    {
        a[x]-=2*f;
        jia_jian(x-1,f);
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        scanf("%1d",&a[i]);
    }
    cin>>s;
    for(int i=0;i<m;i++)
    {
        if(s[i]=='*')a[++n]=0;
        if(s[i]=='/')n--;
        if(s[i]=='+')jia_jian(n,1);
        if(s[i]=='-')jia_jian(n,-1);
    }
    for(int i=1;i<=n;i++)printf("%d",a[i]);
    return 0;
}
```
    - **核心思想**：乘法和除法直接操作数组长度，加法和减法调用`jia_jian`函数递归处理进位借位。

### 最优关键思路或技巧
- **延迟标记**：如Stay_Hungry的题解，将进位借位操作延迟到最后统一处理，避免了每次操作都进行进位借位的复杂处理，优化了时间复杂度。
- **递归处理**：如luckydrawbox的题解，将加减运算封装成递归函数，使代码结构清晰，逻辑直观。

### 可拓展之处
同类型题可能会涉及更大规模的数据、更多种类的二进制运算或更复杂的进位借位规则。类似算法套路可应用于高精度计算、位运算相关的模拟题。

### 推荐题目
- P1601  A+B Problem（高精）
- P2142  高精度减法
- P1303  A*B Problem

### 个人心得摘录与总结
- Stay_Hungry：提到做了相似题目来拿双倍经验，指出暴力做法的瓶颈在于加减操作的进位，即使优化部分操作也难以通过极端数据，从而提出延迟标记的优化思路。
- jx2014wzd：提到正常AC代码的必要性，还介绍了`main`函数递归的实现方式，指出此题卡常，不开O2会有五个点TLE，开O2可能会有更多点TLE。
- Terrific_Year：表示代码实现看似简单，但自己调试了半个小时，说明在实际实现中可能会遇到一些细节问题。

---
处理用时：35.38秒
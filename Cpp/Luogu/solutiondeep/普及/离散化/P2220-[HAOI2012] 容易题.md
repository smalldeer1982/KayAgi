# 题目信息

# [HAOI2012] 容易题

## 题目描述

有一个长度为 $m$ 的正整数数列 $A$，满足 $\forall i \in A, i \in [1, n]$。

现在给定一些限制（$A_x$ 不能为 $y$）。设数列 $A$ 的积为 $\prod A$，求所有可能数列的积相加起来的和。

换言之，令 $S$ 为所有可能的数列情况 $\{A, A', \ldots\}$，求

$$ \sum_{T \in S} \prod T $$

答案对 $10 ^ 9 + 7$ 取模。

## 说明/提示

### 样例解释 #1

$A_1$ 不能取 $1$，$A_2$ 不能取 $2, 3$，$A_4$ 不能取 $3$，所以可能的数列有以下 $12$ 种：

| 数列 | 积 |
| :-: | :-: |
| $\{2,   1,   1,   1\}$           | $2$ |
| $\{2,   1,   1,   2\}$           | $4$ |
| $\{2,   1,   2,   1\}$           | $4$ |
| $\{2,   1,   2,   2\}$           | $8$ |
| $\{2,   1,   3,   1\}$           | $6$ |
| $\{2,   1,   3,   2\}$           | $12$ |
| $\{3,   1,   1,   1\}$           | $3$ |
| $\{3,   1,   1,   2\}$           | $6$ |
| $\{3,   1,   2,   1\}$           | $6$ |
| $\{3,   1,   2,   2\}$           | $12$ |
| $\{3,   1,   3,   1\}$           | $9$ |
| $\{3,   1,   3,   2\}$           | $18$ |


### 数据范围

对于 $30\%$ 的数据，$n \leq 4$，$m \leq 10$，$k \leq 10$。

对于另外 $20\%$ 的数据，$k = 0$。

对于 $70\%$ 的数据，$n, m, k \leq 1000$。

对于 $100\%$ 的数据，$1\leq n, m \leq 10^9$，$0\leq k \leq 10^5$，$1 \leq x \leq m$，$1 \leq y \leq n$。

## 样例 #1

### 输入

```
3 4 5

1 1

1 1

2 2

2 3

4 3

```

### 输出

```
90```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致：先算出无限制时答案为 $(\frac{n(n + 1)}{2})^m$，再处理限制条件，减去对应值，最后用快速幂计算无限制部分。

算法要点：
1. 等差数列求和公式计算无限制时每位可选值的和。
2. 快速幂优化无限制部分的计算。
3. 处理限制条件时，需判重避免重复计算。

解决难点：
1. 数据范围大，用快速幂降低时间复杂度。
2. 限制条件可能重复，用排序、`map`、`set` 等判重。

### 所选题解
- **Edwina（5星）**
    - 关键亮点：思路清晰，代码简洁易懂，详细阐述了无限制和有限制情况的处理方法。
    - 核心代码：
```cpp
ll sgm=(1ll*n*(n+1)>>1)%mod;
sort(a+1,a+k+1,cmp);
int cnt=0;
for(int i=1;i<=k;i++)
{
    if(a[i].x!=a[i-1].x)
        sum[++cnt]=sgm;
    else
    {
        if(a[i].y==a[i-1].y)
            continue;
    }
    sum[cnt]=(sum[cnt]-a[i].y+mod)%mod;
}
ans+=poww(sgm,m-cnt,mod);
for(int i=1;i<=cnt;i++)
{
    ans=(ans*sum[i]+mod)%mod;
}
```
    - 核心实现思想：先计算无限制时每位可选值的和 `sgm`，对限制条件排序判重，计算有限制位置的可选值和，用快速幂计算无限制部分，最后将两部分结果相乘。

- **hzoi_liuchang（4星）**
    - 关键亮点：分析详细，解释了无限制情况答案的由来，代码规范。
    - 核心代码：
```cpp
for(ll i=1;i<=k;i++){
    ll aa,bb;
    scanf("%lld%lld",&aa,&bb);
    if(!ma2[aa]) jl[++js]=aa;
    if(ma1[make_pair(aa,bb)]) continue;
    ma1[make_pair(aa,bb)]=1;
    ma2[aa]+=bb;
}
ll ans=1,cj=(n+1)*n/2;
for(ll i=1;i<=js;i++){
    ans*=(cj-ma2[jl[i]])%mod;
    ans%=mod;
}
printf("%lld\n",ans%mod*cf(cj,m-js)%mod%mod);
```
    - 核心实现思想：用 `map` 记录有限制位置及对应限制值的和，判重后计算有限制位置的可选值和，用快速幂计算无限制部分，最后将两部分结果相乘。

### 最优关键思路或技巧
1. 利用乘法分配律将问题转化为每位可选值和的乘积，简化计算。
2. 用快速幂优化无限制部分的计算，降低时间复杂度。
3. 用排序、`map`、`set` 等数据结构判重，避免重复计算。

### 可拓展之处
同类型题或类似算法套路：
1. 其他涉及排列组合、乘法原理的计数问题，可考虑先计算无限制情况，再处理限制条件。
2. 数据范围大的问题，可采用快速幂、离散化等优化方法。

### 推荐题目
1. [P1226 【模板】快速幂取余运算](https://www.luogu.com.cn/problem/P1226)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

### 个人心得摘录与总结
- **J_Kobe**：最开始只有 90 分，因为没考虑到最后答案可能为负数，输出时要加上模数再模模数。总结：处理取模问题时要注意结果可能为负，需额外处理。
- **Midoria7**：考场上因减法未取模爆 90 pts，意识到减法中大数模后可能变小，减小数会爆负数。总结：涉及减法取模时要格外注意，避免结果为负。 

---
处理用时：33.99秒
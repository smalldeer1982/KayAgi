# 题目信息

# [NICA #3] 星空（Easy Version）

## 题目背景

**Easy Version 和 Hard Version 差别在于数据范围。**

## 题目描述

小 R 有一个长度为 $n$ 的序列 $a$，保证序列中的每个数都是 $2$ 的整数次幂。

小 M 有一个数 $x$，她希望重新排列序列 $a$，使得不存在一个 $i\in[1,n)$ 满足 $a_i+a_{i+1}>x$。重排的方式为：选择一个 $1\sim n$ 的排列 $p$，然后令新序列 $a'$ 满足 $a'_i=a_{p_i}$。$a'$ 即为重排后的序列。

现在你想要知道有多少种重排的方式能满足小 M 的要求。两种重排方式不同当且仅当选择的排列 $p$ 不同。答案对 $10^9+7$ 取模。

## 说明/提示

数据保证，$2 \leq n \leq 61$，$1 \leq a_i \leq 2^{60}$，$1\le x< 2^{63}$。**每一个 $a_i$ 都不重复**。

## 样例 #1

### 输入

```
4 20
2 4 8 16```

### 输出

```
12```

# AI分析结果

• 综合分析与结论：
    - 思路方面：多数题解利用“序列中每个数都是2的整数次幂且互不相同，所以两个非最大值相加一定不大于最大值”这一特性，将问题简化为只需考虑最大值与相邻元素之和是否满足条件。通过分类讨论最大值在序列中的位置（开头或结尾、中间），结合排列组合知识计算满足条件的重排方式数量。
    - 算法要点：找到序列中的最大值，统计与最大值相加不大于x的元素个数，根据最大值位置分类计算排列组合数，最后将各类情况的结果相加得到答案。同时部分题解提到预处理阶乘以优化计算。
    - 解决难点：核心在于理解问题可简化为仅关注最大值及其相邻元素，并正确运用排列组合知识计算不同位置下的方案数。

    - 评分情况：
        - wyf1202：思路清晰，代码简洁明了，通过注释对代码关键部分进行说明，整体质量较高，可评4星。
        - 起名字重要吗：思路阐述简洁清晰，代码实现注意到细节（如阶乘初始化、数据类型），可评4星。
        - DFM_O：解题思路有对无解情况的特判，但代码相对复杂，排列数计算方式较繁琐，可评3星。
        - a_little_carrot：对思路有详细证明和优化说明，代码有一定优化，但代码风格稍显复杂，可评3星。
        - Melo_DDD：思路阐述较清晰，但没有代码实现，可评3星。
        - Ren_Hx：使用DP方法，但分析过程不够清晰，代码实现逻辑较难理解，可评2星。
        - chengjindong：思路正确，但代码变量命名较随意，可评3星。

    - 最优关键思路或技巧：利用序列元素为2的整数次幂且互不相同这一特性，简化问题为仅考虑最大值与相邻元素的关系，通过分类讨论和排列组合求解，同时预处理阶乘优化计算。

    - 可拓展之处：同类型题可考虑拓展到其他具有特殊性质的序列，类似算法套路是先分析序列特性简化问题，再利用排列组合或其他计数原理求解。

    - 推荐题目：
        - P1036 [NOIP2002 普及组] 选数：涉及组合数计算与条件判断。
        - P1147 连续自然数和：通过数学分析简化问题，结合枚举求解。
        - P1313 计算系数：运用二项式定理和快速幂等知识求解组合系数。

• 所选的题解：
  - wyf1202（4星）
    - 关键亮点：思路清晰，代码简洁，通过注释对关键变量和代码段进行说明，便于理解。
    ```cpp
    //j[i]表示i的阶乘
    //a[i]表示数组里的数
    const int mod=1e9+7;
    long long n,x,mx,sum,ans,a[100005],j[100005];
    int main(){
        cin>>n>>x;
        for(int i=1;i<=n;++i)cin>>a[i];
        for(int i=1;i<=n;++i)if(a[i]>mx)mx=a[i];
        for(int i=1;i<=n;++i)
            if(a[i]!=mx&&a[i]+mx<=x)sum++;
        j[1]=1;
        for(int i=2;i<=n;++i)j[i]=(j[i-1]*i)%mod;
        for(int i=1;i<=n;++i){
            if(i==1||i==n)ans=(ans+sum*j[n-2])%mod;
            else ans=(ans+sum*(sum-1)*j[n-3])%mod;
        } 
        cout<<ans;	return 0;
    }
    ```
    - 核心实现思想：先读入数据并找到最大值mx，统计与mx相加不大于x的元素个数sum。预处理阶乘数组j，通过遍历最大值位置i，分情况（i在开头或结尾、i在中间）计算方案数并累加到ans。
  - 起名字重要吗（4星）
    - 关键亮点：思路阐述简洁，代码实现注意到细节，如阶乘初始化、及时取模等。
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    long long n,x,a[70],maxa,fac[70]= {1},cnt,mod=1e9+7;
    int main() {
        scanf("%lld%lld",&n,&x);
        for(int i=1; i<=n; i++) scanf("%lld",&a[i]),maxa=max(maxa,a[i]);
        for(int i=1; i<=n; fac[i]=(fac[i-1]*i)%mod,i++) if(a[i]!=maxa&&a[i]+maxa<=x) cnt++;
        printf("%lld",(2*cnt*fac[n-2]%mod+(n-2)*cnt*(cnt-1)*fac[n-3]%mod)%mod);
        return 0;
    }
    ```
    - 核心实现思想：读入数据并找到最大值maxa，在预处理阶乘的同时统计满足条件的元素个数cnt，最后根据公式计算并输出结果。 

---
处理用时：42.50秒
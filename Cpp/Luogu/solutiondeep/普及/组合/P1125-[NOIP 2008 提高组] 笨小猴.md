# 题目信息

# [NOIP 2008 提高组] 笨小猴

## 题目描述

笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！

这种方法的具体描述如下：假设 $\text{maxn}$ 是单词中出现次数最多的字母的出现次数，$\text{minn}$ 是单词中出现次数最少的字母的出现次数，如果 $\text{maxn}-\text{minn}$ 是一个质数，那么笨小猴就认为这是个 Lucky Word，这样的单词很可能就是正确的答案。


## 说明/提示

【输入输出样例 1 解释】

单词 `error` 中出现最多的字母 $\texttt r$ 出现了 $3$ 次，出现次数最少的字母出现了 $1$ 次，$3-1=2$，$2$ 是质数。

【输入输出样例 2 解释】

单词 `olympic` 中出现最多的字母 $\texttt i$ 出现了 $1$ 次，出现次数最少的字母出现了 $1$ 次，$1-1=0$，$0$ 不是质数。

（本处原题面错误已经修正）

noip2008 提高第一题


## 样例 #1

### 输入

```
error```

### 输出

```
Lucky Word
2```

## 样例 #2

### 输入

```
olympic```

### 输出

```
No Answer
0```

# AI分析结果

### 综合分析与结论
这些题解思路大致相同，均先统计字符串中各字母出现次数，再找出出现次数的最大值与最小值并求差，最后判断差值是否为质数并按要求输出。算法要点在于字符统计和质数判断。解决难点主要是准确找出出现次数最少且出现过的字母，避免统计未出现字母。

多数题解直接用数组统计字母出现次数，利用字符转ASCII码作为数组下标。判断质数方式类似，从2到sqrt(x)遍历判断是否有因子。部分题解使用质数表，部分采用常规判断函数。代码实现上，部分注重细节处理，如初始化最大最小值、避免统计未出现字母；部分代码结构更清晰，有函数封装判断质数等操作。

### 所选的题解
- **作者：lizhixun (赞：3)  4星**
    - **关键亮点**：思路清晰，先描述题目要求，再分点阐述解法，代码结构清晰，将质数判断封装成函数，提高代码可读性。
    - **核心代码**：
```cpp
bool prime(int x) {
	if (x < 2) return false;
	for (int i = 2; i <= sqrt(x); i++) {
		if (x % i == 0) {
			return false;
		}
	}
	return true;
}
string s;
int ma = INT_MIN, mi = INT_MAX;
int sum[1005];
int main() {
	cin >> s;
	for (int i = 0; i < s.size(); i++) {
		sum[s[i]]++;
	}
	for (int i = 0; i < s.size(); i++) {
		ma = max(ma, sum[s[i]]);
		mi = min(mi, sum[s[i]]);
	}
	if (prime(ma - mi)) {
		cout << "Lucky Word" << endl << ma - mi;
	} else {
		cout << "No Answer" << endl << 0;
	}
	return 0;
}
```
    - **核心思想**：prime函数判断一个数是否为质数。主函数中，用sum数组统计字符出现次数，遍历字符串更新最大最小值，最后根据差值是否为质数输出结果。
- **作者：Frank_G (赞：2)  4星**
    - **关键亮点**：先解释质数概念，对基础薄弱读者友好，思路阐述详细，代码注释丰富，逻辑清晰。
    - **核心代码**：
```cpp
bool isprime(int n){
	if(n==0) return false;
	if(n==1) return false;
	for(int i=2;i*i<=n;i++){
		if(n%i==0) return false;
	}
	return true;
}
string s;
int a[40],maxx,minn=300;
int main(){
	cin >> s;
	for(int i=0;i<s.size();i++){
		a[(int)(s[i]-'a'+1)]++;
		maxx=max(maxx,a[(int)(s[i]-'a'+1)]);
	}
	for(int i=1;i<=26;i++){
		if(a[i]!=0) minn=min(minn,a[i]);
	}
	if(isprime(maxx-minn)==true){
		cout << "Lucky" << " " << "Word" << endl << maxx-minn;
	}
	else{
		cout << "No" << " " << "Answer" << endl << "0";
	}
	return 0;
}
```
    - **核心思想**：isprime函数判断质数。主函数通过数组a统计字符出现次数，遍历更新最大最小值，判断差值是否为质数并输出。
- **作者：lihanchen_profys (赞：2)  4星**
    - **关键亮点**：表述亲切，思路简洁明了，代码结构清晰，将质数判断封装成函数，变量命名有意义。
    - **核心代码**：
```cpp
bool ch(ll x)//判断质数
{
	if(x<=1) return 0;
	for(int i=2;i<=sqrt(x);i++) if(x%i==0) return 0;
	return 1;
}
string ss;
ll f[26],zd=INT_MIN,zx=INT_MAX;
int main()
{
	cin >> ss;
	for(int i=0;i<ss.size();i++) f[int(ss[i]-'a')]++;//统计各个字母的个数个数
	for(int i=0;i<=25;i++)//求maxn与minn
	{
		if(f[i]!=0)
		{
			zd=max(zd,f[i]);
			zx=min(zx,f[i]);
		}
	}
	if(ch(zd-zx)) cout <<"Lucky Word\n"<< zd-zx;
	else cout <<"No Answer\n0";
	return 0;
}
```
    - **核心思想**：ch函数判断质数。主函数用数组f统计字母出现次数，遍历数组更新最大最小值，依据差值是否为质数输出。

### 最优关键思路或技巧
- **字符统计**：利用字符自动转换为ASCII码值作为数组下标，简洁高效统计各字母出现次数。
- **质数判断优化**：只需从2遍历到sqrt(x)判断是否有因子，减少循环次数，提高效率。

### 可拓展思路
同类型题常涉及字符处理与简单数论知识结合。类似算法套路是先统计字符相关信息（如出现次数、位置等），再进行数值计算（如求和、求差等），最后根据数论性质（如质数、整除等）得出结果。

### 推荐题目
- [P1035 级数求和](https://www.luogu.com.cn/problem/P1035)：涉及简单数论与循环计算。
- [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)：专注于数论中质因数分解。
- [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)：结合回文数与质数判断。

### 个人心得摘录
无明显个人心得相关内容。 

---
处理用时：39.38秒
# 题目信息

# 第 k 小整数

## 题目描述

现有 $n$ 个正整数，要求出这 $n$ 个正整数中的第 $k$ 个最小整数（相同大小的整数只计算一次）。


## 说明/提示

$n \leq 10000$，$k \leq 1000$，正整数均小于 $30000$。

## 样例 #1

### 输入

```
10 3
1 3 3 7 2 5 1 2 4 6
```

### 输出

```
3
```

# AI分析结果

这些题解主要围绕从\(n\)个正整数中找出第\(k\)小整数（相同大小整数只计一次）这一问题，采用了多种算法，包括排序去重类（如sort排序结合unique去重、选择排序、快排等）、桶排类、基于树的数据结构类（如主席树、线段树、Treap、SBT等）以及其他方法（如利用优先队列、快速次序选择算法等）。

1. **思路与算法要点**：
    - **排序去重类**：先对输入数据排序，再通过不同方式去重，最后根据\(k\)取值输出结果。如使用`sort`结合`unique`函数，或手动去重。
    - **桶排类**：利用数组下标记数，遍历桶找到第\(k\)个出现的数。数据范围较小时适用。
    - **基于树的数据结构类**：如主席树，是可持久化线段树，通过前缀建树解决区间第\(k\)小问题；线段树对数值范围建树，通过节点值判断第\(k\)小所在区间；Treap结合二叉查找树和堆性质，实现插入、查询等操作。
2. **解决难点**：主要难点是去重和高效查找第\(k\)小整数。排序去重类通过排序后判断相邻元素或使用`unique`函数去重；桶排类利用数组标记去重；基于树的数据结构类在树的构建和操作中处理去重和查找。
3. **评分**：
    - **作者：kraylas (赞：184)**：使用主席树解题，思路清晰，详细阐述主席树原理、建树及查询过程，代码完整规范。但主席树相对复杂，对初学者有难度。**4星**
    - **作者：不会dp退役菜鸡 (赞：161)**：利用`unique`函数去重，代码简洁明了，思路直接，很好利用C++ STL特性。**4星**
    - **作者：潜翎 (赞：70)**：借鉴快速排序思想，提出平均时间复杂度\(O(n)\)算法，不受数字大小限制，对特殊数据范围限制情况有应对优势。**4星**

### 所选的题解
- **作者：kraylas**
    - **星级**：4星
    - **关键亮点**：详细讲解主席树原理及实现，适用于深入学习高级数据结构。
    ```cpp
    struct pt{
        int sum;
        pt* ch[2];
    };
    typedef pt* ptr;
    ptr root[maxn];
    int n,k;
    void add(ptr last,ptr& th,int v,int l=1,int r=n){
        th=new pt;
        *th=*last;
        th->sum=last->sum+1;
        if(l==r)return ;
        int mid=l+r>>1;
        if(v<=mid)add(last->ch[0],th->ch[0],v,l,mid);
        else add(last->ch[1],th->ch[1],v,mid+1,r);
    }
    int getid(ptr le,ptr re,int k,int l=1,int r=n){
        if(l==r)return l;
        int tmp=re->ch[0]->sum-le->ch[0]->sum;
        int mid=l+r>>1;
        if(k<=tmp)return getid(le->ch[0],re->ch[0],k,l,mid);
        else return getid(le->ch[1],re->ch[1],k-tmp,mid+1,r);
    }
    ```
    核心实现思想：`add`函数用于建树，利用当前树和前一棵树的公共区间，每次增加一个数最多改变\(O(logn)\)个节点，总空间\(O(nlogn)\)。`getid`函数用于查询，通过比较左右子树节点数确定第\(k\)小所在区间。
 - **作者：不会dp退役菜鸡**
    - **星级**：4星
    - **关键亮点**：简洁运用STL的`unique`函数解决去重问题，代码简洁高效。
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int n,k,a[10000];
    int main()
    {
        cin>>n>>k;
        for(int i=0;i<n;i++)
        cin>>a[i];
        sort(a,a+n);
        int ans=unique(a,a+n)-a;
        if(k<ans)
        cout<<a[k-1];
        else cout<<"NO RESULT";
        return 0;
    }
    ```
    核心实现思想：先对数组`a`进行排序，然后使用`unique`函数去重，`unique`函数返回去重后数组的尾指针，通过与起始指针差值得到去重后元素个数，再根据\(k\)与该个数比较输出结果。
 - **作者：潜翎**
    - **星级**：4星
    - **关键亮点**：提出平均\(O(n)\)时间复杂度算法，不受数字大小限制，在特定数据条件下有优势。
    ```cpp
    int search_k(int l,int r)
    {
        if(l==r&&l==k) return a[k];
        if(l<r)
        {
            int i=l,j=r,p=a[l];
            while(i<j)
            {
                while(i<j&&a[j]>p) j--;
                if(i<j) swap(a[i],a[j]);
                while(i<j&&a[i]<=p) i++;
                if(i<j) swap(a[i],a[j]);
            }
            a[i]=p;
            if(i==k) return a[k];
            else if(i>k) return search_k(l,i-1);
            else return search_k(i+1,r);
        }
    }
    ```
    核心实现思想：类似快速排序，选取基准数，通过双指针移动将数组分为两部分，根据基准数位置与\(k\)的关系，递归在左或右区间查找第\(k\)小整数。

### 最优的关键思路或技巧
- **利用STL工具**：如`unique`函数可简洁实现去重，提高代码效率和简洁性。
- **选择合适数据结构**：数据范围小时，桶排简单高效；需处理区间问题时，主席树等数据结构有独特优势。
- **优化算法**：如借鉴快排思想，提出平均\(O(n)\)时间复杂度算法，优化查找过程。

### 可拓展之处
同类型题常涉及查找特定顺序的元素、去重等操作。类似算法套路包括使用各种排序算法结合去重操作，或针对不同数据范围和查询需求选择合适的数据结构，如平衡树用于动态插入删除并查询第\(k\)小。

### 推荐题目
- **P3369 【模板】普通平衡树**：涉及平衡树的插入、删除、查询排名等操作，与本题基于树结构解题思路相关。
- **P1970 花匠**：可通过排序和简单逻辑判断解决，类似本题排序后处理数据的思路。
- **P2392 kkksc03考前临时抱佛脚**：需对数据进行排序和组合处理，锻炼排序及数据处理能力。

### 个人心得摘录与总结
无明显个人心得相关内容。 

---
处理用时：65.96秒
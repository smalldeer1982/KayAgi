# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果

这道题要求对给定非负整数序列的前奇数项求中位数。题解中涉及多种方法，主要思路、算法要点及难点对比如下：
1. **基于vector**：利用`vector`存储数据，通过`lower_bound`或`upper_bound`二分查找插入位置以保证有序，每次插入后输出中间位置元素。优点是代码简单，缺点是时间复杂度较高，理论为$O(n^2\log n)$。
2. **对顶堆**：维护一个大根堆和一个小根堆，大根堆存较小值，小根堆存较大值。插入时与堆顶比较决定放入哪个堆，然后调整两堆元素个数差值不超过1，奇数项时输出元素个数较多的堆顶元素。时间复杂度$O(n\log n)$，难点在于理解两堆的维护逻辑。
3. **树状数组**：先离散化数据，用树状数组维护权值出现次数，通过二分查找找到第k小的数，即中位数。时间复杂度$O(n\log n)$，难点在于树状数组的理解与实现。
4. **平衡树**：如Treap、Splay等，利用平衡树插入和查询第k大元素的功能，边插入边查询奇数项的中位数。时间复杂度$O(n\log n)$，难点在于平衡树的实现。
5. **线段树（值域/主席树）**：先离散化，值域线段树通过在树上二分找中位数；主席树针对每个区间建线段树，用前缀和求区间出现个数来确定中位数。时间复杂度$O(n\log n)$，难点在于线段树的构建与查询逻辑。

综合来看，对顶堆方法相对容易理解且实现难度适中；平衡树和线段树方法实现较复杂，但在其他场景有广泛应用。

以下是评分较高的题解：
- **作者：decoqwq (赞：719)  5星**
    - **关键亮点**：思路清晰，简洁介绍`vector`相关操作及利用`upper_bound`实现有序插入的方法，代码简洁明了。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
vector<int>a;
int main()
{
    cin>>n;
    for(int i=1,x;i<=n;i++)
    {
        scanf("%d",&x);
        a.insert(upper_bound(a.begin(),a.end(),x),x);
        if(i%2==1)
        {
        	printf("%d\n",a[(i-1)/2]);
        }
    }
    return 0;
}
```
    - **核心思想**：每次读入数字`x`，使用`upper_bound`找到插入位置并插入，在奇数项时输出`vector`中间位置的元素。

- **作者：肖恩Sean (赞：525)  5星**
    - **关键亮点**：详细阐述对顶堆思路，包括大小根堆的维护逻辑及元素调整方式，使用STL的优先队列实现，代码简洁高效。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    int x=0;bool f=0;char c=getchar();
    while (c<'0'||c>'9'){if (c=='-')f=1;c=getchar();}
    while (c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return f?-x:x;
}
priority_queue<int,vector<int> > q1;
priority_queue<int,vector<int>,greater<int> > q2;
int main(){
    int n=read();q1.push(read());
    cout<<q1.top()<<endl; 
    for (int i=2;i<=n;i++){
        int input=read();
        if (input>q1.top()) q2.push(input);
            else q1.push(input);
        while (abs(q1.size()-q2.size())>1)
            if (q1.size()>q2.size()){q2.push(q1.top());q1.pop();}
                else{q1.push(q2.top());q2.pop();}
        if (i%2) cout<<(q1.size()>q2.size()?q1.top():q2.top())<<endl;
    }
    return 0;
}
```
    - **核心思想**：读入数据，根据与大根堆堆顶比较结果放入对应堆，通过调整两堆元素个数，奇数项时输出元素多的堆顶元素。

- **作者：IRipple (赞：365)  4星**
    - **关键亮点**：以较易懂的方式解释对顶堆思路，结合图示说明大小根堆维护及中位数调整过程，代码逻辑清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#include<queue>
using namespace std;
int n;
int a[100100];
int mid;
priority_queue<int,vector<int>,less<int> >q1;
priority_queue<int,vector<int>,greater<int> >q2;
int main(){
    cin>>n;
    scanf("%d",&a[1]);
    mid=a[1];
    cout<<mid<<endl;
    for(int i=2;i<=n;i++){
        scanf("%d",&a[i]);
        if(a[i]>mid) q2.push(a[i]);
        else q1.push(a[i]);
        if(i%2==1){
            while(q1.size()!=q2.size()){
                if(q1.size()>q2.size()){
                    q2.push(mid);
                    mid=q1.top();
                    q1.pop();
                }
                else{
                    q1.push(mid);
                    mid=q2.top();
                    q2.pop();
                }
            }
            cout<<mid<<endl;
        }
    }
    return 0;
}
```
    - **核心思想**：先确定第一个数为中位数`mid`，后续数字根据与`mid`比较放入对应堆，奇数项时调整两堆使元素个数相等，输出`mid`。

**最优关键思路或技巧**：对顶堆方法巧妙利用大小根堆特性，动态维护中位数，实现简单且高效。这种利用两个堆来维护数据分布的思想在很多需要动态求中位数或第k大/小值的场景都很实用。

**拓展思路**：此类题属于动态中位数问题，类似算法套路可用于数据流中位数问题、动态维护第k大/小值等场景。

**推荐题目**：
1. **P1801 黑匣子**：同样是动态维护第k小值问题，可使用对顶堆解决。
2. **P3369 【模板】普通平衡树**：平衡树的模板题，可巩固平衡树操作。
3. **P3834 【模板】可持久化线段树 2（主席树）**：用于练习主席树的使用，加深对其理解。

**个人心得摘录与总结**：部分作者提到在使用`abs`函数时，因`size()`返回无符号整数导致在洛谷出现CE情况，需将其转换为`int`类型。这提醒在使用涉及容器大小等无符号类型的操作时，要注意类型兼容性，避免类似错误。 

---
处理用时：76.71秒
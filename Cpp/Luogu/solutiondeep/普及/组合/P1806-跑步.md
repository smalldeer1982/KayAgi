# 题目信息

# 跑步

## 题目描述

路人甲准备跑 $n$ 圈来锻炼自己的身体，他准备分多次（$\gt1$）跑完，每次都跑正整数圈，然后休息下再继续跑。

为了有效地提高自己的体能，他决定每次跑的圈数都必须比上次跑的多。

可以假设他刚开始跑了 $0$ 圈，那么请问他可以有多少种跑完这 $n$ 圈的方案？

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $5\le n\le 500$。

## 样例 #1

### 输入

```
212```

### 输出

```
995645335```

# AI分析结果

• 综合分析与结论：这些题解主要围绕动态规划（DP）展开，部分还提及暴力DFS的思路及局限性。各题解思路相近，均通过状态转移方程求解方案数。难点在于如何准确设计状态和状态转移方程，同时要注意不能一次跑完的限制条件。在实现上，部分题解进行了空间优化，将二维状态压缩为一维。

所选的题解：
  - **作者：翼德天尊 (5星)**
    - **关键亮点**：思路清晰，先排除不适用算法，明确选择DP。对DP概念简单解释，代码简洁明了，直接给出AC代码，注释详细。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans[501]; 
int main(){
    scanf("%d",&n);
    ans[0]=1;
    for (int i=1;i<=n;i++){
    	for (int j=n;j>=i;j--){
    		ans[j]+=ans[j-i];
		}
	}
    cout<<ans[n]-1<<endl;
    return 0;
}
```
    - **核心思想**：用`ans[i]`表示前`i`圈的方案总数，通过两层循环，外层循环`i`从1到`n`，表示当前考虑的圈数；内层循环`j`从`n`到`i`，通过状态转移方程`ans[j] += ans[j - i]`更新方案数，最后输出`ans[n] - 1`，减去一次跑完的情况。

  - **作者：Anoxiacxy (4星)**
    - **关键亮点**：状态定义清晰，用`dp[i][j]`表示一共跑了`i`圈且最后一次跑了`j`圈的方案数，据此给出状态转移方程，代码结构完整，注释适当。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <cstring>
#include <cstdio> 
#include <queue>
#include <stack>
#include <vector>
#include <bitset>
#include <set> 
#include <cmath>
#define inf 2e9
#define LL long long
#define nl NULL
#define mod (1000)
using namespace std;
LL dp[520][520], ans;
int main(){
    int n; scanf("%d", &n);
    for(int i = 1; i <= n; i++) dp[i][i] = 1;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j < i; j++)
            for(int k = 1; k < j && j + k <= i; k++)
                dp[i][j] += dp[i-j][k];
    }
    for(int i = 1; i < n; i++) ans += dp[n][i];
    printf("%lld\n", ans);
}
```
    - **核心思想**：先初始化`dp[i][i] = 1`，通过三层循环实现状态转移。最外层循环`i`遍历总圈数，中间层循环`j`遍历最后一次跑的圈数，内层循环`k`遍历上一次跑的圈数，根据状态转移方程`dp[i][j] += dp[i - j][k]`更新方案数，最后累加`dp[n][i]`（`i`从1到`n - 1`）得到总方案数。

  - **作者：品小呈 (4星)**
    - **关键亮点**：提供了暴力DFS和DP两种做法，对DFS的复杂度和剪枝进行分析，对DP的状态转移方程及初始化的坑点有详细说明。
    - **个人心得**：提到比赛中拿部分分的技巧，以及在本题中DFS和DP的应用体会。
    - **核心代码（DP部分）**：
```cpp
dp[0]=1;
for(int i=1;i<=n;i++)
{
	for(int j=n;j>=i;j--)
	{
		dp[j]+=dp[j-i];
	}
}
cout << dp[n]-1;
```
    - **核心思想**：与翼德天尊的DP思路类似，初始化`dp[0] = 1`，通过两层循环，外层`i`从1到`n`，内层`j`从`n`到`i`，利用状态转移方程`dp[j] += dp[j - i]`更新方案数，最后输出`dp[n] - 1`。

**最优关键思路或技巧**：采用动态规划思想，通过合理设计状态和状态转移方程求解。在空间优化上，可将二维状态数组压缩为一维，降低空间复杂度。同时，注意初始化值的设置要保证状态转移方程有意义，最后结果需减去一次跑完的情况。

**拓展思路**：此类题目属于计数类DP问题，通常可通过分析问题特点，设计合适的状态和状态转移方程求解。类似算法套路还包括背包计数问题，可根据物品选取条件（如01背包、完全背包等）确定状态转移方式。

**相似知识点洛谷题目**：
  - P1048 [NOIP2005 普及组] 采药，典型的01背包问题。
  - P1616 疯狂的采药，完全背包问题。
  - P2679 子串，涉及字符串的动态规划问题。 

---
处理用时：44.23秒
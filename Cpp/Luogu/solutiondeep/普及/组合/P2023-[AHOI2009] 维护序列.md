# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果

这道题要求对给定数列进行区间乘法、区间加法和区间求和操作。多数题解采用线段树算法，少数使用分块算法。下面从思路、算法要点和难点方面进行分析：
1. **线段树思路**：将数列构建成线段树结构，每个节点存储区间和等信息。通过懒标记优化区间操作，标记下传时依据乘法优先级高于加法的原则更新子节点信息。
2. **分块思路**：把数列分成若干块，对每个块维护乘法和加法标记。操作时，对整块进行统一处理，边角块则暴力更新。
3. **算法要点**：无论是线段树还是分块，都要处理好乘法和加法操作的顺序，确保先乘后加，同时注意标记的传递和更新。
4. **解决难点**：关键在于理解和实现标记的下传与更新，特别是乘法标记对加法标记的影响。同时，要合理处理取模运算，避免溢出。

### 题解评分
1. **作者Mingoal**：4星。思路清晰，结合代码注释详细解释了线段树的实现，包括建树、维护、区间操作等关键函数。
```cpp
// 建树函数
void build(int t, int l, int r) {
    tr[t].mu = 1;
    if (l == r) {
        tr[t].su = a[l];
        return;
    }
    int mid = l + r >> 1;
    build(t << 1, l, mid);
    build(t << 1 | 1, mid + 1, r);
    update;
}
// 维护函数
void maintain(int t, int k) { 
    tr[t<<1].su=(tr[t<<1].su*tr[t].mu+tr[t].ad*(k+1>>1))%M;
    tr[t<<1|1].su=(tr[t<<1|1].su*tr[t].mu+tr[t].ad*(k>>1))%M;
    tr[t<<1].mu=tr[t<<1].mu*tr[t].mu%M;
    tr[t<<1|1].mu=tr[t<<1|1].mu*tr[t].mu%M;
    tr[t<<1].ad=(tr[t<<1].ad*tr[t].mu+tr[t].ad)%M;
    tr[t<<1|1].ad=(tr[t<<1|1].ad*tr[t].mu+tr[t].ad)%M;
    tr[t].mu=1;tr[t].ad=0;
}
```
2. **作者zjy111**：4星。详细阐述了线段树各部分的实现原理，包括建树、懒标记下传、区间修改和查询，并配有形象的例子解释懒标记。
```cpp
// 懒标记下传函数
void pushdown(ll p) { 
    sum[ls(p)]=(mu[p]*sum[ls(p)]+(rrr[ls(p)]-lll[ls(p)]+1)*add[p]%md)%md; 
    sum[rs(p)]=(mu[p]*sum[rs(p)]+(rrr[rs(p)]-lll[rs(p)]+1)*add[p]%md)%md; 
    mu[ls(p)]=(mu[p]*mu[ls(p)])%md;
    mu[rs(p)]=(mu[p]*mu[rs(p)])%md;
    add[ls(p)]=(mu[p]*add[ls(p)]+add[p])%md;
    add[rs(p)]=(mu[p]*add[rs(p)]+add[p])%md; 
    mu[p]=1,add[p]=0; 
}
// 区间乘法函数
void mul(ll p, ll l, ll r, ll k) {  
    if(lll[p]>=l && rrr[p]<=r) { 
        add[p]*=k,add[p]%=md;
        mu[p]*=k,mu[p]%=md;
        sum[p]*=k,sum[p]%=md;
        return;  
    }
    pushdown(p); 
    sum[p]=(sum[ls(p)]+sum[rs(p)])%md; 
    ll mid=(lll[p]+rrr[p])>>1;
    if(l<=mid)mul(ls(p),l,r,k);  
    if(mid<r)mul(rs(p),l,r,k);  
    sum[p]=(sum[ls(p)]+sum[rs(p)])%md;  
}
```
3. **作者吃的**：4星。代码通过类和宏定义实现线段树，利用指针、位运算等方式优化输入和操作过程，注释详细。
```cpp
// 建树函数
void SegmentTree::build(LL l, LL r, LL rt) {
    add[rt] = 0; mul[rt] = 1;
    if (l == r) {
        sum[rt] = mod(a[l]);
        return ;
    }
    LL mid = (l + r) >> 1;
    build(ltree);
    build(rtree);
    pushup(rt);
}
// 区间乘法函数
void SegmentTree::update1(LL L, LL R, LL C, LL l, LL r, LL rt) {
    if (L <= l && r <= R) {
        sum[rt] = mod(sum[rt] * C);
        add[rt] = mod(add[rt] * C);
        mul[rt] = mod(mul[rt] * C);
        return ;
    }
    pushdown(l, r, rt);
    LL mid = (l + r) >> 1;
    if (L <= mid) {
        update1(L, R, C, ltree);
    }
    if (R > mid) {
        update1(L, R, C, rtree);
    }
    pushup(rt);
}
```

### 最优思路与技巧
1. **数据结构**：线段树是解决此类区间操作问题的有效数据结构，通过合理维护节点信息和懒标记，可以高效地实现区间修改和查询。
2. **算法优化**：采用懒标记减少不必要的节点更新，提高算法效率。同时，利用位运算、指针操作等方式优化代码，减少运行时间。
3. **代码实现技巧**：将一些常用操作定义为宏，提高代码可读性和编写效率。在处理乘法和加法标记时，遵循先乘后加的原则，确保结果的正确性。

### 可拓展之处
同类型题或类似算法套路：此类题目通常涉及区间的多种操作，如区间加减、区间乘除、区间最值查询等，都可以考虑使用线段树或分块算法解决。关键在于根据具体操作特点，合理设计节点信息和懒标记的更新方式。

### 相似知识点题目推荐
1. **P3373 【模板】线段树2**：与本题类似，涉及区间乘法、加法和求和操作，是线段树的经典练习题。
2. **P1835 素数密度**：可通过线段树优化区间查询操作，判断区间内素数的数量。
3. **P2824 [HEOI2016/TJOI2016]排序**：利用线段树维护区间信息，实现对数列的排序操作。

### 个人心得摘录与总结
1. **作者Mingoal**：强调线段树不熟时多练习，理解乘加运算级别不同对程序的影响。总结为多实践加深对线段树的理解，明确操作优先级。
2. **作者zjy111**：通过形象的故事解释懒标记，提到线段树空间要开四倍，可利用位运算优化。总结为用形象方式理解概念，注意空间和运算优化。
3. **作者Owen_codeisking**：表示通过做本题对线段树理解更深刻，推荐使用位运算和大写字符使代码清晰易懂。总结为通过练习提升对算法的理解，注重代码风格。 

---
处理用时：92.94秒
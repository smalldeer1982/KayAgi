# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何运用并查集解决动物食物链关系判断问题。整体可分为两类思路：
1. **种类并查集**：通过开3倍大小的并查集，将每个动物对应三个元素，分别表示同类、猎物和天敌关系。根据输入的关系描述，合并相应元素，并通过判断元素是否已在冲突关系集合中，来确定当前描述的真假。
2. **带权并查集**：在并查集基础上，为每个节点增加权值表示与父节点的关系，0代表同类，1代表被父节点吃，2代表吃父节点。在查找和合并操作时，通过特定公式更新权值，以此判断动物间关系的真假。

各题解在思路清晰度、代码可读性和优化程度上存在差异。部分题解详细阐述了原理和推导过程，代码注释丰富；部分则相对简洁，侧重于代码实现。

### 所选的题解
1. **作者：Sooke (赞：2066)  星级：5星**
    - **关键亮点**：思路阐述极为清晰，从引入种类并查集的概念，到具体如何应用于本题，结合图片和示例数据详细解释，对初学者友好。代码简洁明了，注释完整。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <cstdio>

inline int read() {
    char c = getchar(); int n = 0;
    while (c < '0' || c > '9') { c = getchar(); }
    while (c >= '0' && c <= '9') { n = (n << 1) + (n << 3) + (c & 15); c = getchar(); }
    return n;
}

const int maxN = 100005;

int n, m, ans, fa[maxN * 3];

int find(int u) { return fa[u] == u? u : fa[u] = find(fa[u]); }

int main() {
    n = read(), m = read();
    for (int i = 1; i <= n * 3; i++) { fa[i] = i; }
    for (; m; m--) {
        int opt = read(), u = read(), v = read();
        if (u > n || v > n) { ans++; continue; }
        if (opt == 1) {
            if (find(u + n) == find(v) || find(u) == find(v + n)) { ans++; }
            else {
                fa[find(u)] = find(v);
                fa[find(u + n)] = find(v + n);
                fa[find(u + n + n)] = find(v + n + n);
            }
        } else {
            if (find(u) == find(v) || find(u) == find(v + n)) { ans++; }
            else {
                fa[find(u + n)] = find(v);
                fa[find(u + n + n)] = find(v + n);
                fa[find(u)] = find(v + n + n);
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
```
    - **核心实现思想**：利用`fa`数组构建3倍大小的并查集，`read`函数优化输入。在`main`函数中，根据输入的操作类型`opt`，判断动物`u`和`v`的关系是否符合已有的食物链关系，不符合则假话数`ans`加1，符合则合并相应的并查集元素。
2. **作者：檀黎斗·神 (赞：599)  星级：4星**
    - **关键亮点**：代码简洁，同样采用3倍并查集维护关系，通过清晰的注释解释每一步操作，逻辑清晰。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<cstdio>
int fa[300005];
int n,k,ans;
inline int read()
{
    int sum=0;
    char ch=getchar();
    while(ch>'9'||ch<'0') ch=getchar();
    while(ch>='0'&&ch<='9') sum=sum*10+ch-48,ch=getchar();
    return sum;
}//读入优化
int find(int x)
{
    if(x!=fa[x]) fa[x]=find(fa[x]);
    return fa[x];
}//查询
int unity(int x,int y)
{
    int r1=find(fa[x]),r2=find(fa[y]);
    fa[r1]=r2;
}//合并
int main()
{
    int x,y,z;
    n=read(),k=read();
    for(int i=1;i<=3*n;++i) fa[i]=i; //对于每种生物：设 x 为本身，x+n 为猎物，x+2*n 为天敌
    for(int i=1;i<=k;++i) 
    {
        z=read(),x=read(),y=read();
        if(x>n||y>n) {ans++; continue;} // 不属于该食物链显然为假
        if(z==1)
        {
            if(find(x+n)==find(y)||find(x+2*n)==find(y)) {ans++; continue;}
            //如果1是2的天敌或猎物，显然为谎言
            unity(x,y); unity(x+n,y+n); unity(x+2*n,y+2*n);
            //如果为真，那么1的同类和2的同类，1的猎物是2的猎物，1的天敌是2的天敌
        }
        else if(z==2)
        {
            if(x==y) {ans++; continue;} //其实是废话但是可以稍微省点时间
            if(find(x)==find(y)||find(x+2*n)==find(y)) {ans++; continue;}
            //如果1是2的同类或猎物，显然为谎言
            unity(x,y+2*n); unity(x+n,y); unity(x+2*n,y+n);
            //如果为真，那么1的同类是2的天敌，1的猎物是2的同类，1的天敌是2的猎物
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
    - **核心实现思想**：通过`read`函数优化输入，`find`函数查找元素所在集合，`unity`函数合并集合。在`main`函数中，根据输入的`z`值判断操作类型，同样依据动物关系的逻辑判断真假并进行相应的并查集合并操作。
3. **作者：天泽龟 (赞：230)  星级：4星**
    - **关键亮点**：详细介绍带权并查集的概念及如何应用于本题，对权值的定义、转移公式的推导讲解细致，帮助理解带权并查集的原理。
    - **个人心得**：通过打表辅助理解和推导公式。
    - **核心代码**：
```cpp
#include <iostream>  //带权并查集 题解 

using namespace std;

int f[100000],re[100000];  //0-->同种动物，1-->捕食关系，2-->被捕食关系。
int n,m,a,b,p,ans=0;

int find(int a)
{
    int fa=f[a];
    if (a!=fa) {
        f[a]=find(fa);
        re[a]=(re[a]+re[fa])%3;   
        return f[a];
    }
    else return fa;
}
int main()
{
    cin>>n>>m;
    for (int i=1;i<=n;i++) f[i]=i,re[i]=0;
    for (int i=1;i<=m;i++)
    {
        cin>>p>>a>>b;
        if ((a>n||b>n)||(p==2&&a==b)) {   //两种特殊情况 
            ans++; continue;
        }
        if (p==1)  //对关系1讨论 
        {
            int f1=find(a),f2=find(b);
            if (f1==f2&&re[a]!=re[b])  //判断是否在同一棵树及两者是否为同种动物。 
            {
                ans++; continue;
            }
            else if(f1!=f2)
            {
                f[f1]=f2; re[f1]=(3-re[a]+re[b])%3;   //合并 
            }
        }
        if (p==2)  //对关系2讨论 
        {
            int f1=find(a),f2=find(b);
            if (f1==f2) 
            {
                int rela=(re[a]-re[b]+3)%3;  //用两个节点与父亲的关系推出两者关系 

                if (rela!=1) {
//                    cout<<"HERE?"<<endl;
                    ans++; continue;
                }
            }
            else {
                int f1=find(a),f2=find(b);
                f[f1]=f2; re[f1]=(3-re[a]+re[b]+1)%3;   //合并 
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
    - **核心实现思想**：`find`函数在查找根节点的同时更新节点与根节点的权值关系。在`main`函数中，根据输入的`p`值判断关系类型，通过比较权值判断关系真假，若为真则按特定公式合并并查集，更新权值。

### 最优关键思路或技巧
1. **数据结构选择**：选用并查集处理具有传递关系的问题，种类并查集通过扩展空间维护复杂关系，带权并查集则通过权值表示节点间具体关系，两种方法都有效解决了本题中动物间食物链关系的维护和判断。
2. **关系维护与判断**：无论是种类并查集还是带权并查集，核心都在于如何根据输入的关系描述准确维护并查集结构，并快速判断新关系与已维护关系是否冲突。种类并查集通过合并特定元素判断冲突，带权并查集则利用权值运算和比较判断。

### 拓展思路
此类题目属于并查集应用的拓展类型，关键在于根据具体问题构建合适的并查集结构（如多倍空间或带权）来维护对象间复杂关系。类似的算法套路可应用于涉及元素分类及关系判断的场景，如团伙划分、任务依赖关系等。

### 相似知识点题目推荐
1. **P1525 [NOI2010] 关押罪犯**：同样使用种类并查集，处理罪犯之间的矛盾关系，将罪犯分配到两个不同集合，保证矛盾罪犯不在同一集合。
2. **P1196 [NOI2002] 银河英雄传说**：运用并查集维护舰队之间的关系，通过特定操作改变舰队的合并与查询。
3. **P2258 [NOI2004] 郁闷的出纳员**：结合并查集和其他数据结构，处理员工工资调整及查询问题，考察对并查集的灵活运用。 

---
处理用时：119.36秒
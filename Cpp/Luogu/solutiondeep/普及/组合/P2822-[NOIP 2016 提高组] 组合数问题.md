# 题目信息

# [NOIP 2016 提高组] 组合数问题

## 题目背景

NOIP2016 提高组 D2T1

## 题目描述

组合数 $\binom{n}{m}$ 表示的是从 $n$ 个物品中选出 $m$ 个物品的方案数。举个例子，从 $(1,2,3)$ 三个物品中选择两个物品可以有 $(1,2),(1,3),(2,3)$ 这三种选择方法。根据组合数的定义，我们可以给出计算组合数 $\binom{n}{m}$ 的一般公式：

$$\binom{n}{m}=\frac{n!}{m!(n-m)!}$$

其中 $n!=1\times2\times\cdots\times n$；特别地，定义 $0!=1$。

小葱想知道如果给定 $n,m$ 和 $k$，对于所有的 $0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )$ 有多少对 $(i,j)$ 满足 $k\mid\binom{i}{j}$。

## 说明/提示

【样例1说明】

在所有可能的情况中，只有 $\binom{2}{1} = 2$ 一种情况是 $2$ 的倍数。

【子任务】

![](https://cdn.luogu.com.cn/upload/pic/3457.png)

- 对于全部的测试点，保证 $0 \leq n, m \leq 2 \times 10^3$，$1 \leq t \leq 10^4$。

## 样例 #1

### 输入

```
1 2
3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
2 5
4 5
6 7```

### 输出

```
0
7
```

# AI分析结果

• 综合分析与结论：这些题解主要围绕组合数计算及优化展开。基本思路是利用组合数与杨辉三角的关系，通过递推公式计算组合数，并结合取模防止溢出。难点在于应对多组数据查询，暴力枚举效率低会超时。优化方法包括取模优化、提前标记满足整除条件的元素，以及使用前缀和优化查询复杂度。多数题解思路清晰，部分题解还分享了调试经验。
- **作者：Trinity (5星)**
  - **关键亮点**：详细分析不同得分策略，从暴力到多种优化方法逐步讲解，思路极为清晰，代码注释丰富，对组合数求解方法总结全面。
  - **个人心得**：强调对组合数求解方法要根据数据范围选择，取模输出题不能盲目取模，还分享玄学优化思路及前缀和降维作用。
  - **重点代码**：
```cpp
// 100分 前缀和+递推打表
inline void build()
{
    c[0][0]=1;
    c[1][0]=c[1][1]=1;
    for(int i=2;i<=2000;i++)
    {
        c[i][0]=1;
        for(int j=1;j<=i;j++)
        {
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%k;
            ans[i][j]=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1];//前缀和。
            if(!c[i][j])ans[i][j]++;//如果满足结论，计数加一。
        }
        ans[i][i+1]=ans[i][i];//继承。
    }
}
inline void solve()
{
    t=read(),k=read();
    build();
    while(t--)
    {
        n=read(),m=read();
        if(m>n)printf("%lld\n",ans[n][n]);//如果m>n,ans只会达到n，只需输出ans[n,n]就可以了。
        else printf("%lld\n",ans[n][m]);
    }
}
```
  - **核心思想**：通过递推公式计算组合数并取模，同时利用前缀和数组`ans`记录满足整除条件的组合数个数，在`build`函数中完成预处理，`solve`函数处理多组输入并输出结果。
- **作者：纸片人 (4星)**
  - **关键亮点**：结合杨辉三角讲解思路，代码简洁，对前缀和优化部分，尤其是`flag[i][i+1]=flag[i][i];`这一关键步骤解释详细，通过实例对比说明其重要性。
  - **个人心得**：分享做题时遇到的错误及排查过程，如`int`和`long long`类型混淆、累加器未初始化等，对读者有借鉴意义。
  - **重点代码**：
```cpp
void yh(){
    f[0][0]=f[1][0]=f[1][1]=1;
    for (int i=2;i<=2000;i++){
        f[i][0]=1;
        for (int j=1;j<=i;j++){
            f[i][j]=(f[i-1][j-1]%k+f[i-1][j]%k)%k;
            flag[i][j]=flag[i-1][j]+flag[i][j-1]-flag[i-1][j-1];
            if (f[i][j]==0) flag[i][j]++;
        }
        flag[i][i+1]=flag[i][i];
    }
}
int main (){
    scanf("%lld%d",&t,&k);
    yh();
    while (t--){
        int m,n;
        scanf("%d%d",&n,&m);
        if(m>n) printf("%lld\n",flag[n][n]);
        else printf("%lld\n",flag[n][m]);
    }
    return 0;
}
```
  - **核心思想**：`yh`函数通过杨辉三角递推公式计算组合数并取模，同时更新前缀和数组`flag`，主函数读入数据，根据`m`和`n`的关系输出结果。
- **作者：xingshuyan000 (4星)**
  - **关键亮点**：详细阐述组合数相关知识，从组合数公式、性质分析开始，逐步引导到本题解法，逻辑连贯，对边界情况处理及前缀和优化讲解清晰。
  - **重点代码**：
```cpp
void init()
{
    C[0][0] = C[1][0] = C[1][1] = 1;
    for(int i = 2; i <= 2000; i ++) C[i][0] = C[i][i] = 1;
    for(int i = 2; i <= 2000; i ++)
    {
        for(int j = 1; j <= i; j ++)
        {
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % k;
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
            if(C[i][j] == 0) sum[i][j] ++;
        }
        sum[i][i + 1] = sum[i][i];
    }
    return;
}
void solve()
{
    int n, m;
    cin >> n >> m;
    cout << (m <= n? sum[n][m] : sum[n][n]) << "\n";
    return;
}
int main()
{
    cin.tie(nullptr) -> sync_with_stdio(false);
    cout.tie(nullptr);
    cin >> t >> k;
    init();
    while(t --) solve();
    return 0;
}
```
  - **核心思想**：`init`函数预处理组合数并计算前缀和，`solve`函数处理输入并输出结果，根据`m`和`n`的关系输出相应前缀和值。

• **最优关键思路或技巧**：利用组合数与杨辉三角关系，通过递推公式计算组合数并取模，同时借助二维前缀和优化查询复杂度，将每次查询从$O(nm)$降到$O(1)$。

• **同类型题或类似算法套路**：此类题目通常涉及组合数计算及多组查询优化，常见套路是利用递推公式结合取模防止溢出，用前缀和优化查询。类似地，在计算满足特定条件的组合数个数时，可先预处理组合数，再用合适的数据结构或方法统计。

• **推荐题目**：
  - [P1313 计算系数](https://www.luogu.com.cn/problem/P1313)：涉及组合数与多项式系数计算。
  - [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)：考察组合数取模的卢卡斯定理应用。
  - [P2290 [HNOI2004]树的计数](https://www.luogu.com.cn/problem/P2290)：通过组合数知识解决树的计数问题。 

---
处理用时：52.13秒
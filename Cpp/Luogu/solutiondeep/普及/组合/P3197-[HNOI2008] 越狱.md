# 题目信息

# [HNOI2008] 越狱

## 题目描述

监狱有 $n$ 个房间，每个房间关押一个犯人，有 $m$ 种宗教，每个犯人会信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。

答案对 $100,003$ 取模。

## 说明/提示

#### 样例输入输出 1 解释

| 状态编号 | 1 号房间 | 2 号房间 | 3 号房间 |
| :--------: | :--------: | :-------: | :--------: |
| 1 | 信仰 1 | 信仰 1 | 信仰 1 |
| 2 | 信仰 1 | 信仰 1 | 信仰 2 |
| 3 | 信仰 1 | 信仰 2 | 信仰 2 |
| 4 | 信仰 2 | 信仰 1 | 信仰 1 |
| 5 | 信仰 2 | 信仰 2 | 信仰 2 |
| 6 | 信仰 2 | 信仰 2 | 信仰 1 |

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le m \le 10^8$，$1 \le n \le 10^{12}$。

## 样例 #1

### 输入

```
2 3
```

### 输出

```
6```

# AI分析结果

• **综合分析与结论**：大部分题解采用“正难则反”的思路，先计算总方案数 \(m^n\)，再计算不越狱的方案数 \(m*(m - 1)^{n - 1}\)，两者相减得到越狱方案数。由于 \(n\) 较大，都使用快速幂算法来优化计算幂次方的过程，同时注意结果取模及防止减法出现负数的情况。部分题解还给出了递推公式并用矩阵快速幂优化，但整体思路不如“正难则反”简洁直接。

• **所选的题解**：
  - **作者：蒟蒻初音ミク (赞：129)  星级：5星**
    - **关键亮点**：思路清晰，先阐述尝试错误思路，再引出正确的“正难则反”思路，详细解释公式推导过程，代码简洁明了，对快速幂有自定义实现。
    - **个人心得**：“本蒟蒻又一次写题解，好激动。。。一看难度：绿标签！还是数论！看我dfs切了它！然后看数据范围，笑容逐渐消失”，表达了做题时从自信到因数据范围意识到需换思路的过程。
    - **重点代码**：
```cpp
inline ll qmi(ll a,ll b)
{
    if(b==0)return 1;
    return (b&1)?pow(qmi(a,b>>1))*(a%mod)%mod:pow(qmi(a,b>>1));
}
int main()
{
    scanf("%lld%lld",&m,&n);
    ll ans=qmi(m,n)-(m%mod)*qmi(m-1,n-1)%mod;
    while(ans<0)ans+=mod;
    ans%=mod;
    printf("%lld",ans);
    return 0;
}
```
核心实现思想：`qmi` 函数通过递归和位运算实现快速幂，`main` 函数利用快速幂计算总方案数和不越狱方案数并相减，处理结果为负的情况后输出。
  - **作者：Ezios (赞：67)  星级：4星**
    - **关键亮点**：对思路的阐述详细，从计算所有状态和相邻房间不同宗教状态两方面逐步推导公式，代码中模板函数实现快速幂取模，逻辑清晰。
    - **重点代码**：
```cpp
template<typename _FastModularExponentiationElement,typename _power_type,typename _modular_type>
_FastModularExponentiationElement
__fmo_expa(_FastModularExponentiationElement __m,_power_type __n,_modular_type _modular)
{
    _FastModularExponentiationElement ans=1;
    while(__n)
    {
        if(__n&1) ans=(ans*__m)%_modular;
        __m=(__m*__m)%_modular;
        __n>>=1;
    }
    return ans%_modular;
}
int main(){
    scanf("%lld%lld",&m,&n);
    ans=((__fmo_expa(m,n,mod)-(m%mod)*__fmo_expa(m-1,n-1,mod))%mod+mod)%mod;
    printf("%lld",ans);
    return 0;
}
```
核心实现思想：通过模板函数 `__fmo_expa` 实现快速幂取模，在 `main` 函数中调用该函数计算总方案数和不越狱方案数并按要求处理结果。
  - **作者：qxy20040629 (赞：30)  星级：4星**
    - **关键亮点**：结合集合概念阐述“正难则反”思路，公式推导清晰，代码简洁规范，对快速幂的实现采用常见的位运算方式，且注意到结果可能为负的情况。
    - **重点代码**：
```cpp
ll power(ll a,ll b,ll p){
    ll ans=1%p;
    for(;b;b>>=1){
        if(b&1) ans=(ll)ans*a%p;
        a=(ll)a*a%p;
    }
    return ans;
}
int main(){
    cin>>m>>n;
    ans1=power(m,n,p);
    ans2=m*power(m-1,n-1,p);
    ans2%=p;
    ans3=ans1-ans2;
    if(ans3<0) ans3+=p;
    cout<<ans3<<endl;
    return 0;
}
```
核心实现思想：`power` 函数通过循环和位运算实现快速幂取模，`main` 函数调用 `power` 函数分别计算总方案数和不越狱方案数，相减并处理结果为负的情况后输出。

• **最优的关键思路或技巧**：“正难则反”的思维方式，当直接计算越狱方案数困难时，通过计算总方案数和不越狱方案数的差值来得到答案。同时，利用快速幂算法优化幂运算，减少时间复杂度，并且在计算过程中合理处理取模操作以及减法可能产生负数的情况。

• **可拓展之处**：此类题目属于组合数学中的计数问题，类似的算法套路还可用于解决排列组合相关的计数问题，例如计算满足特定条件的排列或组合数量。在遇到直接求解困难的计数问题时，“正难则反”是常见且有效的思路。

• **推荐题目**：
  - [P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226)：专门考察快速幂算法。
  - [P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)：涉及矩阵快速幂的应用，与本题部分题解思路相关。
  - [P1313 计算系数](https://www.luogu.com.cn/problem/P1313)：结合了组合数学和快速幂的知识点。 

---
处理用时：44.24秒
# 题目信息

# SAC#1 - 组合数

## 题目描述


今天小明学习了组合数，现在他很想知道 $\sum \rm{C}$$_{n}^{i}$ 是多少。其中 $\rm{C}$ 是组合数（即 $\rm{C}$$_{n}^{i}$ 表示 $n$ 个物品无顺序选取 $i$ 个的方案数），$i$ 取从 $0$ 到 $n$ 的所有偶数。

由于答案可能很大，请输出答案对 $6662333$ 的余数。

## 说明/提示

对于 $20\%$ 的数据，$n \le 20$；

对于 $50\%$ 的数据，$n \le 10^{3}$；

对于 $100\%$ 的数据，$n \le 10^{18}$。

## 样例 #1

### 输入

```
3```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
所有题解都围绕求\(\sum_{i\in[0,n],2|i}C_n^i\)对\(6662333\)取模这一问题，最终都得出结果为\(2^{n - 1}\bmod{6662333}\)，并使用快速幂算法解决。不同之处在于推导结果的方式和对快速幂的实现。部分题解利用二项式定理推导，部分通过找规律或其他组合数性质推导。

### 所选的题解
1. **作者：Salty_Fish787 (5星)**
    - **关键亮点**：思路清晰，先明确题意，利用二项式定理，通过代入特殊值\(a = 1, b = 1\)和\(a = 1, b = -1\)得到两个等式，再通过两式运算得出结果，推导过程严谨，代码简洁。
    - **重点代码**：
```cpp
// 快速幂函数
long long qpow(long long a, long long b, long long mod) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
// 主函数
int main() {
    long long n;
    cin >> n;
    cout << qpow(2, n - 1, 6662333) << endl;
    return 0;
}
```
    - **核心实现思想**：快速幂函数通过不断将指数\(b\)折半，同时将底数\(a\)平方，当指数\(b\)的二进制位为1时，将当前的\(a\)乘入结果\(res\)，从而快速计算\(a^b\bmod{mod}\)。

2. **作者：NaVi_Awson (4星)**
    - **关键亮点**：给出详细的数学证明过程，从二项式定理出发，通过代入不同值证明所需等式，代码规范，注释清晰。
    - **重点代码**：
```cpp
int quick_pow(int a, LL b) {
    int sum = 1;
    while (b) {
        if (b & 1) sum = (LL)sum * a % MOD;
        b >>= 1;
        a = (LL)a * a % MOD;
    }
    return sum;
}
void work() {
    LL n;
    scanf("%lld", &n);
    printf("%d\n", quick_pow(2, n - 1));    
}
```
    - **核心实现思想**：`quick_pow`函数利用位运算判断指数\(b\)的二进制位是否为1，若为1则累乘当前\(a\)到\(sum\)，同时指数\(b\)右移一位，底数\(a\)平方，实现快速幂运算。

3. **作者：hsfzLZH1 (4星)**
    - **关键亮点**：利用数论中费马小定理，得出\(2^{6662332} \equiv 1 (\bmod{6662333})\)，将指数取模后再进行快速幂运算，优化了时间复杂度。
    - **重点代码**：
```cpp
inline long long ksm(long long a, long long n) {
    long long ans = 1;
    a %= mod;
    while (n) {
        if (n & 1) ans *= a, ans %= mod;
        n = (n >> 1);
        a *= a; a %= mod;
    }
    return ans;
}
int main() {
    long long n; scanf("%lld", &n);
    printf("%lld\n", ksm(2, (n - 1) % 6662332));
    return 0;
} 
```
    - **核心实现思想**：`ksm`函数为快速幂实现，在主函数中先将指数\((n - 1)\)对\(6662332\)取模，再进行快速幂运算，减少计算量。

### 最优关键思路或技巧
利用二项式定理通过代入特殊值得到关于组合数和的等式，从而推导出\(\sum_{i\in[0,n],2|i}C_n^i = 2^{n - 1}\)。同时，快速幂算法通过将指数折半、底数平方的方式高效计算幂运算，部分题解还结合数论知识优化指数运算，提高效率。

### 可拓展之处
同类型题常考察对数学公式的推导与应用，类似算法套路包括利用二项式定理、组合数性质解决组合计数问题，结合快速幂处理大规模数据的幂运算取模。

### 推荐题目
1. [P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226)：基础快速幂题目，用于巩固快速幂算法。
2. [P3802 【模板】多项式乘法（FFT）](https://www.luogu.com.cn/problem/P3802)：涉及多项式乘法，可拓展对数学运算与算法结合的理解。
3. [P2158 [SDOI2008]仪仗队](https://www.luogu.com.cn/problem/P2158)：结合数论与组合知识，锻炼综合解题能力。

### 个人心得摘录与总结
 - **作者：MY（一名蒟蒻）**：通过自身“血的教训”意识到快速幂能将\(O(n)\)复杂度降为\(O(\log n)\)，强调快速幂在解决此类问题的重要性。 

---
处理用时：42.00秒
# 题目信息

# 小 Y 拼木棒

## 题目背景

上道题中，小 Y 斩了一地的木棒，现在她想要将木棒拼起来。

## 题目描述

有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？

答案对 $10^9+7$ 取模。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 5 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，$1 \le a_i \le 5 \times 10^3$。

关于标题：因为一些不可抗力的原因，名称进行了更改。深表歉意。

## 样例 #1

### 输入

```
4 
1
1
2
2```

### 输出

```
1```

# AI分析结果

• 综合分析与结论：
    - 思路：所有题解都基于用4根木棒组成正三角形必有2根长度相等，且另外2根长度之和等于这2根相等木棒长度的条件。通过枚举相等木棒的长度和组成第三边的木棒长度，利用组合数学计算方案数。
    - 算法要点：用数组（桶）记录每种长度木棒的数量，通过两层循环枚举，外层循环枚举相等木棒长度，内层循环枚举组成第三边的木棒长度，分两种情况（组成第三边的两根木棒长度相等或不相等）计算组合数并累加。
    - 解决难点：避免重复计算，控制内层循环范围（如到i/2停止）；正确处理组合数计算及取模操作，防止数据溢出。
    - 整体来看，各题解思路相近，质量差异主要体现在思路清晰度、代码可读性和优化程度上。

所选的题解：
  - 作者：灵乌路空 (赞：298)
    - 星级：5星
    - 关键亮点：思路阐述详细，从分析题意到感性理解，逐步深入讲解，对内外层循环及两种情况的讨论清晰明了；代码注释详尽，对组合数计算采用特判写法简化代码。
    - 个人心得：无
    - 重点代码 - 核心实现思想：先读入木棒长度并统计每种长度的数量，通过两层循环枚举，外层循环枚举两根相等木棒的长度，满足数量≥2时进入内层循环，内层循环枚举组成第三边的木棒长度，分情况计算组合数并累加，同时随时取模。
```cpp
ll C(ll x, ll k) { 
  return (k == 1ll? x : x * (x - 1ll) / 2ll) % kMod;
}
int main() {
  scanf("%lld\n", &n);
  for (int i = 1; i <= n; ++ i) { 
    scanf("%lld", &a[i]); 
    maxa = max(a[i], maxa);
    num[a[i]] ++;
  }

  for (int i = 2; i <= maxa; ++ i) { 
    if (num[i] >= 2ll) {
      ll times = C(num[i], 2ll) % kMod; 
      for (int j = 1; j <= i / 2; ++ j) { 
        if (j!= i - j && num[j] >= 1 && num[i - j] >= 1) 
          ans += times * C(num[j], 1) * C(num[i - j], 1) % kMod;
        if (j == i - j && num[j] >= 2) 
          ans += times * C(num[j], 2) % kMod;
        ans %= kMod;
      }
    }
  }
  printf("%lld", ans);
  return 0;
}
```
  - 作者：dbxxx (赞：10)
    - 星级：4星
    - 关键亮点：先详细分析题目得出思路，对计算方案数的两种情况分类清晰，代码注释详细，且记录了WA点及改正方法，对读者有借鉴意义。
    - 个人心得：无
    - 重点代码 - 核心实现思想：读入木棒长度并统计，通过两层循环枚举，外层循环从最小长度 + 1到最大长度，当该长度木棒数量>1时进入内层循环，内层循环从最小长度到当前长度的一半，分情况计算组合数并累加，随时取模。
```cpp
for(int i = begin + 1; i <= end; i++) {
    if(a[i] > 1) {
        for(int j = begin; j <= i / 2; j++) {
            if(a[j] && a[i - j]) {
                if(j == i - j && a[j] >= 2)
                    ans = ans + ((a[i] * (a[i] - 1) >> 1) * (a[j] * (a[j] - 1) >> 1) % mod) % mod;
                else if(j!= i - j)
                    ans = ans + ((a[i] * (a[i] - 1) >> 1) * a[j] * a[i - j]) % mod;      
            }
            ans %= mod;
        }
    }
}
```
  - 作者：bjrjk (赞：4)
    - 星级：4星
    - 关键亮点：简洁地指出计算组合数无需递归函数，直接用宏定义，代码简洁明了，对循环范围的控制注释清晰，避免重复计算。
    - 个人心得：无
    - 重点代码 - 核心实现思想：读入木棒长度并统计，通过两层循环枚举，外层从2到5000，内层从1到外层长度的一半，分情况计算组合数并累加，随时取模。
```cpp
#define C1(x) (x) 
#define C2(x) ((x)*((x)-1)/2) 
int main(){
    ios::sync_with_stdio(false); 
    cin >> n;
    for (int i = 1; i <= n; i++){
        int t;
        cin >> t;
        arr[t]++;
    }
    for (int a = 2; a <= 5000; a++){
        for (int c = 1; c <= a/2; c++){ 
            int d = a - c; 
            if (d!= c){ 
                if (arr[a] >= 2 && arr[c] >= 1 && arr[d] >= 1)
                    sum += ((C2(arr[a]) % MOD)*(C1(arr[c]) % MOD)) % MOD*(C1(arr[d]) % MOD) % MOD;
            }
            else{
                if (arr[a] >= 2 && arr[c] >= 2)
                    sum += (C2(arr[a]) % MOD)*(C2(arr[c]) % MOD) % MOD;
            }
            sum %= MOD;
        }
    }
    cout << sum;
}
```

最优关键思路或技巧：
    - 利用桶数组统计每种长度木棒的数量，将问题转化为对长度及数量的组合计算。
    - 控制内层循环范围到i/2，避免重复计算。
    - 对组合数$C(n,1)$和$C(n,2)$采用简单的特判或宏定义写法，简化计算。

可拓展之处：同类型题可涉及用特定数量的元素组合成特定形状或满足特定条件，类似算法套路为利用数组统计元素特征，通过枚举和组合数学计算方案数，同时注意避免重复计算和数据处理细节。

推荐题目：
    - P1313 计算系数：考察组合数学与多项式相关知识。
    - P2822 [NOIP2016 提高组] 组合数问题：专注于组合数的性质及计算。
    - P3197 [HNOI2008]越狱：结合组合数学与简单的容斥原理。

个人心得摘录与总结：无。 

---
处理用时：53.50秒
# 题目信息

# 父子

## 题目背景

上演在各大学男生寝室的日常 $:$

$A :$ “我没带纸，快来厕所救我！”

$B :$ “叫爸爸。”

$A :$ “爸爸！”

$............................................$

$A :$ “我没钱了，能借我点吗。”

$B :$ “叫爸爸。”

$A :$ “爸爸！”

一个月后、

$B :$ “能把钱还给我吗。”

$A :$ “叫爸爸。”

$B :$ “爸爸！”

## 题目描述

对于全国各大大学的男生寝室，总是有各种混乱的父子关系。

那么假设现在我们一个男生寝室有不同的 $n$ 个人，每个人都至多有一个“爸爸”，可以有多个“儿子”，且有且只有一个人没有“爸爸”(毕竟是室长，还是要给点面子，当然了，室长人人当嘛)。

那么现在问题来了，对于一个有 $n$ 个人的寝室，最多可能存在多少种父子关系，当然每个人之间都必须要有直接或间接的父子关系。

## 说明/提示

- 对于 $10\%$ 的数据，保证 $t=0$；

- 另有 $30\%$ 的数据，保证 $n≤5$；

- 对于 $100\%$ 的数据，$t≤10^4$，$1\le n\le10^9$。


## 样例 #1

### 输入

```
1
3
```

### 输出

```
9```

## 样例 #2

### 输入

```
1
323
```

### 输出

```
283888610```

# AI分析结果

### 综合分析与结论
这些题解都围绕求\(n\)个节点的有根树数量这一核心问题，多数题解使用Cayley公式结合快速幂求解。思路要点为：先利用Cayley公式得出\(n\)个节点无根树数量为\(n^{n - 2}\)，再因每棵无根树选根方式有\(n\)种，从而推出有根树数量为\(n^{n - 1}\)，由于\(n\)较大，需用快速幂优化计算。不同之处在于部分题解给出公式证明，部分直接应用公式。

### 所选的题解
1. **作者：DPair (赞：30)  星级：5星**
    - **关键亮点**：不仅给出代码，还详细证明了\(n^{n - 1}\)这一公式，通过引入Prufer编码，阐述了无根树与Prufer序列的一一对应关系，进而得出无根树数量，再结合选根方式得到有根树数量，思路清晰，逻辑严谨。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
#define MOD 1000000009
LL ksm(LL n, LL m)
{//快速幂
    LL ret = 1;
    while(m) 
    {
        if(m & 1) ret = (ret * n) % MOD;
        n = (n * n) % MOD;
        m >>= 1;
    }
    return ret;
}
int main()
{
    int k;
    scanf("%d", &k);
    while(k --) 
    {
        LL n;
        scanf("%lld", &n);
        printf("%lld\n", ksm(n, n-1));
    }
}
```
    - **核心实现思想**：ksm函数实现快速幂运算，在main函数中，通过循环读入多组数据，对每组数据的\(n\)，调用ksm函数计算\(n^{n - 1}\)并输出。
2. **作者：mulberror (赞：32)  星级：4星**
    - **关键亮点**：简洁明了地阐述解题思路，先点明题意是求\(n\)个节点的有根树数量，指出卡特兰数解法错误，再直接应用Cayley公式，说明无根树与有根树转换关系，最后给出AC代码。
    - **重点代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const LL Mod=1e9+9;
LL power(LL n,LL m,LL p) {
    LL ret=1;
    while (m) {
        if (m&1) ret=(ret*n)%Mod;
        n=(n*n)%Mod;
        m>>=1;
    }
    return ret;
}
int main() {
    int cas; scanf("%d",&cas);
    while(cas--) {
        LL n;
        scanf("%lld",&n);
        printf("%lld\n",power(n,n-1,Mod));
    }
    return 0;
}
```
    - **核心实现思想**：power函数实现快速幂，在main函数中，读入测试用例数量cas，对每个测试用例读入\(n\)，调用power函数计算\(n^{n - 1}\)并输出。
3. **作者：liuyifan (赞：0)  星级：4星**
    - **关键亮点**：给出Cayley公式的证明过程，通过介绍树的编码方式，证明一棵完全图的生成树与一个长度为\(n - 2\)的数列一一对应，从而得出无根树数量，进而得到有根树数量公式，最后给出基于快速幂的代码。
    - **重点代码**：
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll m=1e9+9,n,p,mm,nn,pp,ans=1,t;
int main()
{
    scanf("%lld",&t);
    while(t--)//多组数据读入
    {
		scanf("%lld",&n);
		p=n-1;//质数
		ans=1;//初始值
	    mm=m;nn=n;pp=p;
	    //if(pp==0)return puts("0"),0;
	    for(;p;p/=2,n=n*n%m)if(p&1)ans=ans*n%m;//快速幂
	    printf("%lld\n",ans);//输出
	}
    return 0;
}
```
    - **核心实现思想**：在main函数中，读入测试用例数量t，对每个测试用例读入\(n\)，通过快速幂运算计算\(n^{n - 1}\)并输出。

### 最优关键思路或技巧
1. **思维方式**：将实际问题建模为求有根树数量问题，通过先求无根树数量再转换为有根树数量的思路简化问题。
2. **算法优化**：针对\(n\)较大的情况，使用快速幂算法优化\(n^{n - 1}\)的计算，降低时间复杂度。

### 可拓展之处
同类型题常围绕树的计数问题，类似算法套路是利用一些树的性质和相关公式（如Cayley公式、Prufer编码等）进行求解。例如给定一些树的限制条件，求满足条件的树的数量。

### 推荐题目
1. **P1967 货车运输**：涉及图论和树的相关知识，需利用并查集和倍增算法解决最大生成树及树上两点间路径最大边权问题。
2. **P3398 仓鼠找sugar**：结合树的直径、LCA（最近公共祖先）等知识，通过分析树上两点间距离关系求解。
3. **P2680 运输计划**：考查树上路径、二分查找以及树链剖分等知识点，通过优化最长路径来满足时间限制。 

---
处理用时：44.83秒
# 题目信息

# [蓝桥杯 2021 国 ABC] 123

## 题目描述

小蓝发现了一个有趣的数列, 这个数列的前几项如下:

$1,1,2,1,2,3,1,2,3,4, \ldots$

小蓝发现, 这个数列前 $1$ 项是整数 $1$ , 接下来 $2$ 项是整数 $1$ 至 $2$ , 接下来 $3$ 项是整数 $1$ 至 $3$ , 接下来 $4$ 项是整数 $1$ 至 $4$ , 依次类推。

小蓝想知道, 这个数列中, 连续一段的和是多少。

## 说明/提示

对于 $10 \%$ 的评测用例, $1 \leq T \leq 30,1 \leq l_{i} \leq r_{i} \leq 100$ 。

对于 $20 \%$ 的评测用例, $1 \leq T \leq 100,1 \leq l_{i} \leq r_{i} \leq 1000$ 。

对于 $40 \%$ 的评测用例, $1 \leq T \leq 1000,1 \leq l_{i} \leq r_{i} \leq 10^{6}$ 。

对于 $70 \%$ 的评测用例, $1 \leq T \leq 10000,1 \leq l_{i} \leq r_{i} \leq 10^{9}$ 。

对于 $80 \%$ 的评测用例, $1 \leq T \leq 1000,1 \leq l_{i} \leq r_{i} \leq 10^{12}$ 。

对于 $90 \%$ 的评测用例, $1 \leq T \leq 10000,1 \leq l_{i} \leq r_{i} \leq 10^{12}$ 。

对于所有评测用例, $1 \leq T \leq 100000,1 \leq l_{i} \leq r_{i} \leq 10^{12}$ 。 

蓝桥杯 2021 国赛 A 组 E 题（B 组 F 题，C 组 F 题）。

## 样例 #1

### 输入

```
3
1 1
1 3
5 8```

### 输出

```
1
4
8```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效计算给定数列中指定区间的和。难点在于数列规律复杂且数据范围大，直接模拟会超时。各题解思路主要分为两类：基于数学公式推导和利用前缀和思想。
1. **基于数学公式推导**：通过推导第\(i\)行和前\(i\)行数字总和的公式，结合二分查找确定数字所在行，进而计算区间和。如Light_az、DengDuck和Infinite_Eternity的题解。
2. **利用前缀和思想**：将数列按特定方式转化为前缀和形式，通过预处理前缀和数组，结合二分查找确定数字所在层级，计算区间和。如ztntonny和Struggle_ong的题解。

综合质量来看，Light_az、ztntonny和DengDuck的题解相对较好，思路清晰，代码可读性较高。

### 所选题解
- **Light_az（5星）**
    - **关键亮点**：思路清晰，利用数学思想，无需前缀和数组。通过手写二分查找确定数字所在行，推导出前\(n\)行和第\(n\)行和的公式，代码简洁明了。
    - **重点代码**：
```cpp
ll Find(ll n){//二分查找确定所在行
    ll l=1,r=1000000;
    while(l<r){
        ll mid=(l+r)/2;
        if((1+mid)*mid/2>=n) r=mid;
        else l=mid+1;
    }
    return r;
}
ll f(ll n){//高斯公式求第n行和
    return (1+n)*n/2;
}
ll Ans(ll n){//前n行的和公式
    return n*(n+1)*(n+2)/6;
}
```
核心实现思想：`Find`函数通过二分查找确定数字\(n\)所在行；`f`函数利用高斯公式计算第\(n\)行的和；`Ans`函数计算前\(n\)行的和。在`main`函数中，利用这些函数计算区间\([l, r]\)的和。
- **ztntonny（4星）**
    - **关键亮点**：详细阐述前缀和思路，将数列形象划分为等差数列并转化为前缀和形式，通过两次预处理前缀和数组，结合STL二分查找函数确定层级，逻辑清晰。
    - **重点代码**：
```cpp
for ( int i = 1; i < 2000005; i++ )
    s[i] = s[i - 1] + i, f[i] = f[i - 1] + s[i];//预处理前缀和数组
cin >> t;
while ( t-- )
{
    cin >> r >> l;
    r--;
    ll levr = max( 0ll, (ll)( lower_bound( s, s + 2000005, r ) - s - 1 ) ), levl = max( 0ll, (ll)( lower_bound( s, s + 2000005, l ) - s - 1 ) );//二分查找确定层级
    ll sumr = f[levr], suml = f[levl];
    sumr += ( r - s[levr] + 1 ) * ( r - s[levr] ) / 2, suml += ( l - s[levl] + 1 ) * ( l - s[levl] ) / 2;
    cout << suml - sumr << endl;
}
```
核心实现思想：先预处理出两个前缀和数组\(s\)和\(f\)，在每次查询时，通过二分查找确定\(l\)和\(r\)所在层级，再根据层级计算区间和。
- **DengDuck（4星）**
    - **关键亮点**：清晰推导出行和前\(n\)行数字总和的公式，利用类似前缀和思想，结合二分查找，代码简洁高效。
    - **重点代码**：
```cpp
long long fd(long long x)
{//二分查找确定所在行
    long long l=1,r=10000000,ans;
    while(l<=r)
    {
        long long mid=(l+r)/2;
        if(mid*(mid+1)/2<x)l=mid+1;
        else 
        {
            r=mid-1;
            ans=mid;
        }
    }
    return ans;
}
int main()
{
    scanf("%lld",&n);
    while(n--)
    {
        scanf("%lld%lld",&l,&r);
        st=fd(l),ed=fd(r);
        t1=l-st*(st-1)/2;
        t2=r-ed*(ed-1)/2;
        k1=(st-1)*st*(st+1)/6;
        k2=(ed-1)*ed*(ed+1)/6;
        cout<<k2-k1+(t2+1)*t2/2-(t1-1)*t1/2<<endl;
    }
}
```
核心实现思想：`fd`函数二分查找确定数字所在行，在`main`函数中，根据所在行计算区间和，通过公式计算出两个行的前缀和并处理剩余部分得到最终区间和。

### 最优关键思路或技巧
1. **数学公式推导**：推导出第\(i\)行和前\(i\)行数字总和的公式，简化计算过程，提高效率。
2. **二分查找**：由于数据范围大，通过二分查找确定数字所在行或层级，避免暴力搜索带来的超时问题。
3. **前缀和优化**：将数列转化为前缀和形式，通过预处理前缀和数组，快速计算区间和。

### 同类型题或类似算法套路拓展
此类题目通常具有一定规律的数列，且数据范围较大。类似算法套路包括：
1. 观察数列规律，尝试推导数学公式简化计算。
2. 利用前缀和思想，预处理相关数组，快速响应查询。
3. 结合二分查找等高效查找算法，优化时间复杂度。

### 洛谷相似题目推荐
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：考察前缀和与动态规划思想，与本题利用前缀和计算区间和有相似之处。
2. [P3397 地毯](https://www.luogu.com.cn/problem/P3397)：二维前缀和的应用，可拓展前缀和的使用场景。
3. [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：结合动态规划与前缀和思想，锻炼综合解题能力。

### 个人心得摘录与总结
无明显个人心得相关内容。 

---
处理用时：52.01秒
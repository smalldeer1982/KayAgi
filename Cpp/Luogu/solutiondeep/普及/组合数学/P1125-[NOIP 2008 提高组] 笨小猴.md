# 题目信息

# [NOIP 2008 提高组] 笨小猴

## 题目描述

笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！

这种方法的具体描述如下：假设 $\text{maxn}$ 是单词中出现次数最多的字母的出现次数，$\text{minn}$ 是单词中出现次数最少的字母的出现次数，如果 $\text{maxn}-\text{minn}$ 是一个质数，那么笨小猴就认为这是个 Lucky Word，这样的单词很可能就是正确的答案。


## 说明/提示

【输入输出样例 1 解释】

单词 `error` 中出现最多的字母 $\texttt r$ 出现了 $3$ 次，出现次数最少的字母出现了 $1$ 次，$3-1=2$，$2$ 是质数。

【输入输出样例 2 解释】

单词 `olympic` 中出现最多的字母 $\texttt i$ 出现了 $1$ 次，出现次数最少的字母出现了 $1$ 次，$1-1=0$，$0$ 不是质数。

（本处原题面错误已经修正）

noip2008 提高第一题


## 样例 #1

### 输入

```
error```

### 输出

```
Lucky Word
2```

## 样例 #2

### 输入

```
olympic```

### 输出

```
No Answer
0```

# AI分析结果

### 综合分析与结论
这些题解整体思路一致，先统计输入字符串中每个字母的出现次数，找出出现次数的最大值和最小值（排除未出现字母），计算差值后判断是否为质数，最后按要求输出结果。在实现细节上，各题解存在差异，如质数判断方式、统计字母次数的数据结构使用等。

### 所选题解
- **luhongrui（5星）**
    - **关键亮点**：思路清晰，代码注释详细，使用质数表判断质数，简单直接，运行时间仅 3ms。
    - **核心代码**：
```cpp
int a[26];//用来储存每一个字母的数量
int zhishu[25]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};//质数表
for(int i=0;i<=le-1;i++){
    xunhuan=s[i];
    a[xunhuan-97]++;//累计字母数量
}
for(int i=0;i<=25;i++){
    if(a[i]<minn&&a[i]!=0)minn=a[i];//找出最少的字母
}
for(int i=0;i<=25;i++){
    if(a[i]>maxn)maxn=a[i];//找出最多的字母
}
int cha=maxn-minn;//相减
for(int i=0;i<=24;i++){
    if(cha==zhishu[i]){
        cout<<"Lucky Word"<<endl;
        cout<<cha;
        return 0;
    }
}
```
- **lizhixun（4星）**
    - **关键亮点**：思路简洁明了，使用函数封装质数判断逻辑，提高代码的可读性和可维护性。
    - **核心代码**：
```cpp
bool prime(int x) {
    if (x < 2) return false;
    for (int i = 2; i <= sqrt(x); i++) {
        if (x % i == 0) {
            return false;
        }
    }
    return true;
}
for (int i = 0; i < s.size(); i++) {
    sum[s[i]]++;
}
for (int i = 0; i < s.size(); i++) {
    ma = max(ma, sum[s[i]]);
    mi = min(mi, sum[s[i]]);
}
if (prime(ma - mi)) {
    cout << "Lucky Word" << endl << ma - mi;
} else {
    cout << "No Answer" << endl << 0;
}
```
- **Frank_G（4星）**
    - **关键亮点**：对质数的概念进行解释，代码中使用宏定义和注释，提高代码的可读性，逻辑清晰。
    - **核心代码**：
```cpp
bool isprime(int n){
    if(n==0) return false;
    if(n==1) return false;
    for(int i=2;i*i<=n;i++){
        if(n%i==0) return false;
    }
    return true;
}
for(int i=0;i<s.size();i++){
    a[(int)(s[i]-'a'+1)]++;
    maxx=max(maxx,a[(int)(s[i]-'a'+1)]);
}
for(int i=1;i<=26;i++){
    if(a[i]!=0) minn=min(minn,a[i]);
}
if(isprime(maxx-minn)==true){
    cout << "Lucky" << " " << "Word" << endl << maxx-minn;
}
else{
    cout << "No" << " " << "Answer" << endl << "0";
}
```

### 最优关键思路或技巧
- **数据结构**：使用数组作为桶来统计字母出现次数，简单高效。
- **质数判断优化**：通过质数表或只检查到平方根的方式，减少不必要的计算。
- **代码实现**：将质数判断逻辑封装成函数，提高代码的可读性和可维护性。

### 拓展思路
同类型题或类似算法套路：
- 统计字符串中字符的出现频率，然后根据频率进行其他计算或判断，如判断字符串是否为变位词等。
- 质数判断在数论相关问题中经常用到，可结合其他数学概念进行更复杂的计算。

### 推荐题目
- P1075 [NOIP2012 普及组] 质因数分解
- P1217 [USACO1.5] 回文质数
- P1463 [POI2002][HAOI2007]反素数

### 个人心得
题解中未包含个人心得。 

---
处理用时：29.52秒
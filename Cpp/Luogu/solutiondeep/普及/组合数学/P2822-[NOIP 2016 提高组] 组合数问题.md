# 题目信息

# [NOIP 2016 提高组] 组合数问题

## 题目背景

NOIP2016 提高组 D2T1

## 题目描述

组合数 $\binom{n}{m}$ 表示的是从 $n$ 个物品中选出 $m$ 个物品的方案数。举个例子，从 $(1,2,3)$ 三个物品中选择两个物品可以有 $(1,2),(1,3),(2,3)$ 这三种选择方法。根据组合数的定义，我们可以给出计算组合数 $\binom{n}{m}$ 的一般公式：

$$\binom{n}{m}=\frac{n!}{m!(n-m)!}$$

其中 $n!=1\times2\times\cdots\times n$；特别地，定义 $0!=1$。

小葱想知道如果给定 $n,m$ 和 $k$，对于所有的 $0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )$ 有多少对 $(i,j)$ 满足 $k\mid\binom{i}{j}$。

## 说明/提示

【样例1说明】

在所有可能的情况中，只有 $\binom{2}{1} = 2$ 一种情况是 $2$ 的倍数。

【子任务】

![](https://cdn.luogu.com.cn/upload/pic/3457.png)

- 对于全部的测试点，保证 $0 \leq n, m \leq 2 \times 10^3$，$1 \leq t \leq 10^4$。

## 样例 #1

### 输入

```
1 2
3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
2 5
4 5
6 7```

### 输出

```
0
7
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕组合数问题展开，核心是计算满足 $k\mid\binom{i}{j}$ 的 $(i,j)$ 对数。大部分题解都利用了组合数与杨辉三角的关系，通过递推公式 $\binom{n}{m}=\binom{n - 1}{m - 1}+\binom{n - 1}{m}$ 进行预处理。为解决多组询问的时间复杂度问题，多数题解采用了二维前缀和优化。部分题解还涉及取模防止溢出、边界处理等技巧。

### 所选题解
- **Trinity（5星）**
    - **关键亮点**：思路清晰，详细介绍了从暴力到优化的全过程，涵盖多种求解组合数的方法，并对每种方法进行复杂度分析和优化说明。
    - **个人心得**：“当年的递推公式写错了，完全在于当时的我对其理解不清晰，特在高二退役后8个月修正”，强调了对知识理解的重要性。
- **纸片人（4星）**
    - **关键亮点**：详细解释了杨辉三角与组合数的关系，对前缀和的使用和边界处理进行了重点说明，通过实例展示了边界处理的必要性。
    - **个人心得**：在实现过程中遇到数据范围和累加器初始化的问题，提醒我们要注意数据范围和变量初始化。
- **HHC883（4星）**
    - **关键亮点**：对组合数递推公式进行详细推导，清晰阐述了预处理和二维前缀和的思路，代码简洁。

### 重点代码及核心思想
#### Trinity - 100分 前缀和+递推打表
```cpp
inline void build()
{
  c[0][0]=1;
  c[1][0]=c[1][1]=1;
  for(int i=2;i<=2000;i++)
  {
    c[i][0]=1;
    for(int j=1;j<=i;j++)
    {
      c[i][j]=(c[i-1][j-1]+c[i-1][j])%k;
      ans[i][j]=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1];
      if(!c[i][j]) ans[i][j]++;
    }
    ans[i][i+1]=ans[i][i];
  }
}
inline void solve()
{
  t=read(),k=read();
  build();
  while(t--)
  {
    n=read(),m=read();
    if(m>n) printf("%lld\n",ans[n][n]);
    else printf("%lld\n",ans[n][m]);
  }
}
```
核心思想：利用杨辉三角递推计算组合数，同时使用二维前缀和记录满足条件的组合数个数，处理边界情况 `ans[i][i+1]=ans[i][i]`，最后根据询问输出结果。

#### 纸片人 - AC代码
```cpp
void yh(){
  f[0][0]=f[1][0]=f[1][1]=1;
  for (int i=2;i<=2000;i++){
    f[i][0]=1;
    for (int j=1;j<=i;j++){
      f[i][j]=(f[i-1][j-1]%k+f[i-1][j]%k)%k;
      flag[i][j]=flag[i-1][j]+flag[i][j-1]-flag[i-1][j-1];
      if (f[i][j]==0) flag[i][j]++;
    }
    flag[i][i+1]=flag[i][i];
  }
}
int main (){
  scanf("%lld%d",&t,&k);
  yh();
  while (t--){
    int m,n;
    scanf("%d%d",&n,&m);
    if(m>n) printf("%lld\n",flag[n][n]);
    else printf("%lld\n",flag[n][m]);
  }
  return 0;
}
```
核心思想：通过杨辉三角递推计算组合数并取模，使用二维前缀和数组 `flag` 记录满足条件的组合数个数，特别强调了边界处理 `flag[i][i+1]=flag[i][i]` 的重要性。

#### HHC883 - 参考代码
```cpp
#include<iostream>
using namespace std;
int t,k,c[2005][2005],pre[2005][2005];
int main(){
  ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
  cin>>t>>k;
  c[1][0]=c[1][1]=1%k;
  for(int i=2;i<=2000;i++){
    c[i][0]=1;
    for(int j=1;j<=i;j++){
      c[i][j]=(c[i-1][j-1]+c[i-1][j])%k;
      pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1];
      if(!c[i][j]) pre[i][j]++;
    }
    pre[i][i+1]=pre[i][i];
  }
  int n,m;
  while(t--){
    cin>>n>>m;
    if(m>n) cout<<pre[n][n]<<'\n';
    else cout<<pre[n][m]<<'\n';
  }
  return 0;
}
```
核心思想：利用组合数递推公式计算组合数并取模，同时使用二维前缀和数组 `pre` 记录满足条件的组合数个数，处理边界情况 `pre[i][i+1]=pre[i][i]`，根据询问输出结果。

### 最优关键思路或技巧
- **利用杨辉三角递推计算组合数**：避免了直接使用组合数公式带来的高精度和高复杂度问题。
- **取模运算**：防止结果溢出，同时不影响判断是否为 $k$ 的倍数。
- **二维前缀和优化**：将每次询问的时间复杂度从 $O(nm)$ 降低到 $O(1)$。
- **边界处理**：如 `ans[i][i+1]=ans[i][i]` 确保前缀和计算的正确性。

### 可拓展之处
同类型题或类似算法套路：
- 其他组合数相关问题，如计算组合数的和、满足特定条件的组合数个数等。
- 二维前缀和的应用，如矩阵区域和查询、二维区间计数等。

### 推荐题目
- [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：考察二维前缀和与动态规划。
- [P2004 领地选择](https://www.luogu.com.cn/problem/P2004)：二维前缀和的应用，求最大子矩阵和。
- [P3397 地毯](https://www.luogu.com.cn/problem/P3397)：二维差分与前缀和的应用。

### 个人心得总结
- **Trinity**：强调对知识的深入理解，避免因理解不清晰导致错误。
- **纸片人**：提醒注意数据范围和变量初始化，遇到部分通过的情况要仔细检查数据范围相关问题。

---
处理用时：47.13秒
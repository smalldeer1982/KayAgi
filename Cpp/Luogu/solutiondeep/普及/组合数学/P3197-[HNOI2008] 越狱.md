# 题目信息

# [HNOI2008] 越狱

## 题目描述

监狱有 $n$ 个房间，每个房间关押一个犯人，有 $m$ 种宗教，每个犯人会信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。

答案对 $100,003$ 取模。

## 说明/提示

#### 样例输入输出 1 解释

| 状态编号 | 1 号房间 | 2 号房间 | 3 号房间 |
| :--------: | :--------: | :-------: | :--------: |
| 1 | 信仰 1 | 信仰 1 | 信仰 1 |
| 2 | 信仰 1 | 信仰 1 | 信仰 2 |
| 3 | 信仰 1 | 信仰 2 | 信仰 2 |
| 4 | 信仰 2 | 信仰 1 | 信仰 1 |
| 5 | 信仰 2 | 信仰 2 | 信仰 2 |
| 6 | 信仰 2 | 信仰 2 | 信仰 1 |

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le m \le 10^8$，$1 \le n \le 10^{12}$。

## 样例 #1

### 输入

```
2 3
```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
这些题解大多采用“正难则反”的思路，先求出所有犯人信仰宗教的总状态数 \(m^n\)，再求出相邻房间犯人宗教不同（不越狱）的状态数 \(m\times(m - 1)^{n - 1}\)，最后用总状态数减去不越狱的状态数得到可能越狱的状态数。由于 \(n\) 数据范围大，普遍使用快速幂算法进行幂运算以避免超时，同时在相减时考虑结果为负的情况并进行处理。

部分题解采用递推公式和矩阵快速幂，但因复杂度较高或实现较复杂，未成为主流。

### 高评分题解
1. **作者：蒟蒻初音ミク（5星）**
    - **关键亮点**：思路清晰，先阐述直接求解的困难，再引出“正难则反”的思路，代码注释详细，可读性强。
    - **个人心得**：无
    - **核心代码**：
```cpp
inline ll qmi(ll a,ll b)
{
    if(b==0)return 1;
    return (b&1)?pow(qmi(a,b>>1))*(a%mod)%mod:pow(qmi(a,b>>1));
}
ll ans=qmi(m,n)-(m%mod)*qmi(m-1,n-1)%mod;
while(ans<0)ans+=mod;
ans%=mod;
```
核心实现思想：`qmi` 函数实现快速幂，通过递归和位运算减少计算次数，最后计算可能越狱的状态数并处理结果为负的情况。

2. **作者：Ezios（4星）**
    - **关键亮点**：对总状态和不越狱状态的计算过程分析详细，代码使用模板函数实现快速幂，具有一定通用性。
    - **个人心得**：无
    - **核心代码**：
```cpp
template<typename _FastModularExponentiationElement,typename _power_type,typename _modular_type>
_FastModularExponentiationElement
__fmo_expa(_FastModularExponentiationElement __m,_power_type __n,_modular_type _modular)
{
    _FastModularExponentiationElement ans=1;
    while(__n)
    {
        if(__n&1) ans=(ans*__m)%_modular;
        __m=(__m*__m)%_modular;
        __n>>=1;
    }
    return ans%_modular;
}
ans=((__fmo_expa(m,n,mod)-(m%mod)*__fmo_expa(m-1,n-1,mod))%mod+mod)%mod;
```
核心实现思想：`__fmo_expa` 模板函数实现快速幂，通过循环和位运算计算幂，最后计算结果并处理负数情况。

3. **作者：qxy20040629（4星）**
    - **关键亮点**：思路清晰，使用集合的概念解释解题思路，代码简洁明了。
    - **个人心得**：提醒注意结果可能为负的情况并进行特判。
    - **核心代码**：
```cpp
ll power(ll a,ll b,ll p){
    ll ans=1%p;
    for(;b;b>>=1){
        if(b&1) ans=(ll)ans*a%p;
        a=(ll)a*a%p;
    }
    return ans;
}
ans1=power(m,n,p);
ans2=m*power(m-1,n-1,p);
ans2%=p;
ans3=ans1-ans2;
if(ans3<0) ans3+=p;
```
核心实现思想：`power` 函数实现快速幂，通过循环和位运算计算幂，计算总状态和不越狱状态，相减得到结果并处理负数情况。

### 最优关键思路或技巧
- **思维方式**：“正难则反”，当直接求解问题困难时，考虑从反面求解，再用总数减去反面情况得到答案。
- **算法优化**：使用快速幂算法将幂运算的时间复杂度从 \(O(n)\) 降低到 \(O(log n)\)，避免超时。
- **代码实现技巧**：在进行减法运算时，考虑结果为负的情况，通过加上模数再取模保证结果为正。

### 可拓展之处
同类型题：涉及组合数学和快速幂的题目，如计算排列组合数并取模的问题。类似算法套路：在处理大数幂运算时使用快速幂，在处理减法取模时注意结果为负的情况。

### 推荐题目
1. [P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226)
2. [P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)
3. [P5245 【模板】多项式快速幂](https://www.luogu.com.cn/problem/P5245)

### 个人心得摘录与总结
- **作者：qxy20040629**：提醒注意结果可能为负的情况并进行特判。总结：在进行减法取模运算时，要考虑结果为负的情况，避免出错。
- **作者：青丝、暮成雪**：改了4、5次，全是因为忘取余。总结：在涉及取模运算的题目中，要注意每一步运算都进行取模，避免结果溢出。 

---
处理用时：38.00秒
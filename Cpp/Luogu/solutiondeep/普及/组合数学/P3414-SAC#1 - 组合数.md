# 题目信息

# SAC#1 - 组合数

## 题目描述


今天小明学习了组合数，现在他很想知道 $\sum \rm{C}$$_{n}^{i}$ 是多少。其中 $\rm{C}$ 是组合数（即 $\rm{C}$$_{n}^{i}$ 表示 $n$ 个物品无顺序选取 $i$ 个的方案数），$i$ 取从 $0$ 到 $n$ 的所有偶数。

由于答案可能很大，请输出答案对 $6662333$ 的余数。

## 说明/提示

对于 $20\%$ 的数据，$n \le 20$；

对于 $50\%$ 的数据，$n \le 10^{3}$；

对于 $100\%$ 的数据，$n \le 10^{18}$。

## 样例 #1

### 输入

```
3```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先推导出所求组合数之和等于 $2^{n - 1}$，再使用快速幂计算 $2^{n - 1} \bmod 6662333$ 的值。推导过程主要利用二项式定理，部分题解采用了其他方式证明。快速幂的实现有递归和迭代两种方式，部分题解还进行了优化，如利用费马小定理缩小指数范围。

### 所选题解
- **作者：Salty_Fish787（5星）**
    - **关键亮点**：思路清晰，详细推导了从二项式定理得出结果的过程，最后点明用快速幂解决问题。
    - **核心代码**：虽然原答案给的是图片，但核心思路代码如下：
```cpp
// 快速幂函数
long long fast_pow(long long base, long long exponent, long long mod) {
    long long result = 1;
    while (exponent > 0) {
        if (exponent & 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exponent >>= 1;
    }
    return result;
}

// 主函数
int main() {
    long long n;
    const int mod = 6662333;
    cin >> n;
    cout << fast_pow(2, n - 1, mod) << endl;
    return 0;
}
```
核心实现思想：通过不断将指数除以 2，同时将底数平方，当指数为奇数时将当前结果乘上底数，最终得到幂运算结果。

- **作者：MY（一名蒟蒻）（4星）**
    - **关键亮点**：详细解释了快速幂的思想，用递归实现快速幂，代码有注释，适合初学者。
    - **个人心得**：提到自己经历“血的教训”才知道用快速幂，说明一开始可能未意识到复杂度问题。
    - **核心代码**：
```cpp
#include <cstdio> 
long long ans=2,n;
const int M=6662333;
typedef long long ll;
ll FP(ll m) {
    if(m == 0) return 1;
    if(m%2 == 1) return 2*FP(m-1)%M;
    ll num=FP(m/2)%M;
    return (num%M)*(num%M)%M;
}
int main() {
    scanf("%lld",&n);
    printf("%lld",FP(n-1)%M);
    return 0;
}
```
核心实现思想：递归地将指数缩小，当指数为奇数时先计算指数减 1 的情况再乘上底数，指数为偶数时计算指数一半的平方。

- **作者：hsfzLZH1（4星）**
    - **关键亮点**：利用费马小定理缩小指数范围，进一步优化了快速幂的计算，降低了时间复杂度。
    - **核心代码**：
```cpp
#include<cstdio>
using namespace std;
const int mod=6662333;
inline long long ksm(long long a,long long n) {
    long long ans=1;
    a%=mod;
    while(n) {
        if(n&1) ans*=a,ans%=mod;
        n=(n>>1);
        a*=a;a%=mod;
    }
    return ans;
}
int main() {
    long long n;
    scanf("%lld",&n);
    printf("%lld\n",ksm(2,(n-1)%6662332));
    return 0;
} 
```
核心实现思想：先利用费马小定理将指数对 6662332 取模，再用快速幂计算结果。

### 最优关键思路或技巧
- **数学推导**：利用二项式定理或其他组合数性质推导出所求组合数之和等于 $2^{n - 1}$，将组合数问题转化为幂运算问题。
- **快速幂**：将幂运算的时间复杂度从 $O(n)$ 降低到 $O(\log n)$，是解决此类大指数幂运算的关键。
- **费马小定理优化**：在取模运算中，利用费马小定理缩小指数范围，进一步优化计算。

### 可拓展之处
同类型题可能会改变组合数的选取条件，或者改变模数，依然可以先通过数学推导得出结果的表达式，再用快速幂计算。类似算法套路还可用于求解其他幂运算相关的组合数学问题，如计算排列数、卡特兰数等。

### 推荐题目
- P1226 【模板】快速幂||取余运算
- P3197 [HNOI2008]越狱
- P5245 【模板】多项式快速幂

### 个人心得摘录与总结
- **MY（一名蒟蒻）**：一开始未意识到要用快速幂，经历“血的教训”后才掌握，说明要重视算法复杂度对解题的影响。
- **子谦。**：本来不想用快速幂，用了还是只拿 50 分，最后用记忆化才 AC，体现了算法优化和调试的重要性。
- **DanieNi**：数学不好时通过小数据找规律，将问题转化为快速幂取模，说明在没有思路时可以从简单情况入手寻找规律。 

---
处理用时：34.54秒
# 题目信息

# 小 Y 拼木棒

## 题目背景

上道题中，小 Y 斩了一地的木棒，现在她想要将木棒拼起来。

## 题目描述

有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？

答案对 $10^9+7$ 取模。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 5 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，$1 \le a_i \le 5 \times 10^3$。

关于标题：因为一些不可抗力的原因，名称进行了更改。深表歉意。

## 样例 #1

### 输入

```
4 
1
1
2
2```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是基于组合数学和枚举法来解决从 $n$ 根木棒中选 4 根组成正三角形的方案数问题。要点在于用桶记录各长度木棒的数量，通过两层循环枚举两根相等木棒的长度和另外两根木棒的长度，分情况计算组合数并累加。难点在于组合数的计算和避免重复计算，同时要注意取模防止溢出。

### 所选题解
- 作者：灵乌路空 (赞：299)，5 星。
    - 关键亮点：思路清晰，详细阐述了暴力枚举的过程和组合数的计算，代码注释丰富，可读性强。
- 作者：zhangziyi_xshsnoi (赞：69)，4 星。
    - 关键亮点：对组合数公式进行了详细推导，核心代码简洁明了。
- 作者：RemiliaScar1et (赞：14)，4 星。
    - 关键亮点：思路清晰，通过带参宏定义简化组合数计算，代码简洁。

### 重点代码
#### 灵乌路空的题解
```cpp
ll C(ll x, ll k) { 
  return (k == 1ll ? x : x * (x - 1ll) / 2ll) % kMod;
}
int main() {
  scanf("%lld\n", &n);
  for (int i = 1; i <= n; ++ i) { 
    scanf("%lld", &a[i]); 
    maxa = max(a[i], maxa);
    num[a[i]] ++;
  }
  for (int i = 2; i <= maxa; ++ i) { 
    if (num[i] >= 2ll) {
      ll times = C(num[i], 2ll) % kMod; 
      for (int j = 1; j <= i / 2; ++ j) { 
        if (j != i - j && num[j] >= 1 && num[i - j] >= 1) 
          ans += times * C(num[j], 1) * C(num[i - j], 1) % kMod;
        if (j == i - j && num[j] >= 2) 
          ans += times * C(num[j], 2) % kMod;
        ans %= kMod;
      }
    }
  }
  printf("%lld", ans);
  return 0;
}
```
核心思想：先统计各长度木棒的数量，然后枚举两根相等木棒的长度，对于每种长度，再枚举另外两根木棒的长度，分情况计算组合数并累加。

#### zhangziyi_xshsnoi 的题解
```cpp
for(int i=Min+1;i<=Max;i++)
{
  if(num[i]>=2)
  {
    for(int j=Min;j<=i/2;j++)
    {
      if(j!=i-j)
        ans+=num[i]*(num[i]-1)*num[j]*num[i-j]/2%mod;
      else if(num[j]>=2&&j*2==i)
        ans+=num[i]*(num[i]-1)*num[i/2]*(num[i/2]-1)/4%mod;
    }
    ans%=mod;
  }
}
```
核心思想：通过两层循环枚举两根相等木棒的长度和另外两根木棒的长度，根据两根木棒长度是否相等分情况计算方案数并累加。

#### RemiliaScar1et 的题解
```cpp
#define c1(a) (a)
#define c2(a) ((a)*((a)-1)/2)
int main()
{
  int n;
  cin>>n;
  for(int i=1;i<=n;i++)
  {
    int k;
    cin>>k;
    aaa[k]++;
  }
  int ans=0;
  for(int a=2;a<=5000;a++)
  {
    for(int c=1;c<=a/2;c++)
    {
      int d=a-c;
      if(d!=c&&aaa[a]>=2&&aaa[c]>=1&&aaa[d]>=1)
      {
        ans+=((c2(aaa[a])%mode)*(c1(aaa[c])%mode)*(c1(aaa[d])%mode))%mode;
      }
      else if(d==c&&aaa[a]>=2&&aaa[c]>=2)
      {
        ans+=((c2(aaa[a])%mode)*(c2(aaa[c])%mode))%mode;
      }
      ans%=mode;
    }
  }
  cout<<ans%mode;
  return 0;
}
```
核心思想：用桶记录各长度木棒的数量，通过两层循环枚举两根相等木棒的长度和另外一根木棒的长度，分情况计算组合数并累加。

### 最优关键思路或技巧
- **桶排序**：用数组记录各长度木棒的数量，方便后续枚举和计算组合数。
- **枚举优化**：内层循环只枚举到 `i / 2`，避免重复计算。
- **组合数特判**：对于 $C(n, 1)$ 和 $C(n, 2)$ 进行特判，简化计算。

### 可拓展之处
同类型题可以是从多个元素中选取若干个满足特定条件的组合问题，如从 $n$ 个数中选 $k$ 个数组成特定形状或满足特定等式。类似算法套路是用桶记录元素数量，然后通过枚举和组合数计算方案数。

### 推荐题目
- P1009 阶乘之和
- P1018 乘积最大
- P1044 栈

### 个人心得
- dbxxx：在条件分支处要注意 `else if(j != i - j)` 不能去掉后面的 `if`，否则会导致 WA。总结：在编写条件判断时要仔细考虑各种情况，避免逻辑错误。 

---
处理用时：36.51秒
# 题目信息

# 父子

## 题目背景

上演在各大学男生寝室的日常 $:$

$A :$ “我没带纸，快来厕所救我！”

$B :$ “叫爸爸。”

$A :$ “爸爸！”

$............................................$

$A :$ “我没钱了，能借我点吗。”

$B :$ “叫爸爸。”

$A :$ “爸爸！”

一个月后、

$B :$ “能把钱还给我吗。”

$A :$ “叫爸爸。”

$B :$ “爸爸！”

## 题目描述

对于全国各大大学的男生寝室，总是有各种混乱的父子关系。

那么假设现在我们一个男生寝室有不同的 $n$ 个人，每个人都至多有一个“爸爸”，可以有多个“儿子”，且有且只有一个人没有“爸爸”(毕竟是室长，还是要给点面子，当然了，室长人人当嘛)。

那么现在问题来了，对于一个有 $n$ 个人的寝室，最多可能存在多少种父子关系，当然每个人之间都必须要有直接或间接的父子关系。

## 说明/提示

- 对于 $10\%$ 的数据，保证 $t=0$；

- 另有 $30\%$ 的数据，保证 $n≤5$；

- 对于 $100\%$ 的数据，$t≤10^4$，$1\le n\le10^9$。


## 样例 #1

### 输入

```
1
3
```

### 输出

```
9```

## 样例 #2

### 输入

```
1
323
```

### 输出

```
283888610```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致，均是先求出 $n$ 个节点的无根树数量，再通过乘以 $n$ 得到有根树数量。多数题解借助 $Cayley$ 公式得出无根树数量为 $n^{n - 2}$，进而得到有根树数量为 $n^{n - 1}$，并使用快速幂解决 $n$ 较大的问题。部分题解对 $Cayley$ 公式进行了证明，证明方式主要是引入 $Prufer$ 编码，通过说明 $Prufer$ 编码与无根树一一对应，推导出无根树数量。

### 所选题解
- **作者：DPair（5星）**
    - **关键亮点**：思路清晰，不仅给出代码，还详细证明了 $n^{n - 1}$ 公式的由来，引入 $Prufer$ 编码，逐步推导，易于理解。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
#define MOD 1000000009
LL ksm(LL n, LL m)
{//快速幂
    LL ret = 1;
    while(m) 
    {
        if(m & 1) ret = (ret * n) % MOD;
        n = (n * n) % MOD;
        m >>= 1;
    }
    return ret;
}
int main()
{
    int k;
    scanf("%d", &k);
    while(k --) 
    {
        LL n;
        scanf("%lld", &n);
        printf("%lld\n", ksm(n, n-1));
    }
}
```
    - **核心实现思想**：定义快速幂函数 `ksm` 计算 $n^{n - 1}$ 对 $MOD$ 取模的结果，主函数中处理多组输入，调用 `ksm` 函数输出结果。

- **作者：suxxsfe（4星）**
    - **关键亮点**：详细介绍了 $Prufer$ 编码的定义、性质及与无根树的一一对应关系，还给出了多个相关性质及推导，知识丰富。
    - **核心代码**：
```cpp
inline LL power(LL a,LL b,LL mod){
    LL ret=1;
    while(b){
        if(b&1) ret=ret*a%mod;
        a=a*a%mod;b>>=1;
    }
    return ret;
}
int main(){int T=read();while(T--){
    int n=read();
    std::printf("%lld\n",power(n,n-1,1e9+9));
}
    return 0;
}
```
    - **核心实现思想**：定义快速幂函数 `power` 计算 $n^{n - 1}$ 对 $1e9 + 9$ 取模的结果，主函数处理多组输入，调用 `power` 函数输出结果。

- **作者：liuyifan（4星）**
    - **关键亮点**：对 $Cayley$ 公式进行了详细证明，通过树的编码方式建立树与数列的一一对应关系进行证明。
    - **核心代码**：
```cpp
for(;p;p/=2,n=n*n%m)if(p&1)ans=ans*n%m;//快速幂
```
    - **核心实现思想**：使用快速幂计算 $n^p$ 对 $m$ 取模的结果。

### 最优关键思路或技巧
- **思维方式**：将求有根树数量问题转化为求无根树数量问题，再通过简单乘法得到结果，简化问题。
- **算法优化**：使用快速幂算法处理 $n^{n - 1}$ 的计算，避免超时。
- **代码实现技巧**：使用位运算（如 `m & 1` 和 `m >>= 1`）优化快速幂代码。

### 可拓展之处
同类型题或类似算法套路：
- 计算给定节点度数的有根树或无根树的数量，可利用 $Prufer$ 编码中节点度数与出现次数的关系求解。
- 图的生成树计数问题，可使用矩阵树定理或 $Prufer$ 编码求解。

### 推荐题目
- P2290 [HNOI2004]树的计数：给定节点度数，求满足条件的树的数量，需运用 $Prufer$ 编码性质。
- P4430 [BJWC2011]元素选择：涉及图的生成树计数，可使用矩阵树定理。
- P3317 [SDOI2014]重建：结合概率和矩阵树定理，计算图的生成树概率和。

### 个人心得
部分题解提到在做题时只需知道公式，无需证明，但也有题解给出了详细证明，说明在学习过程中，不仅要记住公式，理解其原理也很重要。同时，对于复杂问题，可通过建立中间概念（如 $Prufer$ 编码）来简化问题和证明。 

---
处理用时：32.77秒
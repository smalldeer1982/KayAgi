# 题目信息

# [语言月赛202302] 大碗宽面

## 题目背景

扶苏和她的朋友们在 Impart 酒店开派对。

## 题目描述

算上扶苏，本次派对共有 $n$ 个人。但是，并不是任何两个人都互相认识，并且互相认识的人关系也未必好。

具体而言，任意两个人可能是如下三种关系之一：
1. 敌人
2. 朋友
3. 陌生人

派对的一大重要活动是相互握手。对任意两个人 $u,v$，他们之间的握手情况遵循下面的规则：
1. 如果 $u$ 和 $v$ 是朋友关系，那么他们一定握手一次。
2. 如果 $u$ 和 $v$ 是敌人关系，那么他们一定**不**握手。
3. 如果 $u$ 和 $v$ 是陌生人关系，且存在一个人 $w$，使得 $w$ 是 $u$ 和 $v$ 之一的朋友，同时是 $u,v$ 中另一人的敌人，则 $u$ 和 $v$ **不会**握手，否则 $u$ 和 $v$ 一定握手一次。

对第三条规则，简单的说法是：一对陌生人之间，如果某一方的朋友是另一方的敌人，则不握手，否则握手。

已知共有 $p$ 对人是朋友关系，$q$ 对人是敌人关系。除了这 $p + q$ 对人，其他每对人均为陌生人关系。

请你求出本次派对一共握手了多少次。

## 说明/提示

### 样例 1 解释

共有 $(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)$ $6$ 对人。
- $(1,2)$ 是朋友，握手。
- $(1,3)$ 是敌人，不握手。
- $(1,4)$ 是敌人，不握手。
- $(2,3)$ 是朋友，握手。
- $(2,4)$ 是陌生人，但是 $1$ 是 $2$ 的朋友，也是 $4$ 的敌人，所以不握手。
- $(3,4)$ 是陌生人，但是不存在任何一个人既是 $3$ 和 $4$ 之一的敌人也是另一个人的朋友，故握手。

综上，一共握手 $3$ 次。

### 数据规模与约定

以下设 $m = p + q$，即 $m$ 是朋友和敌人关系条数之和。

- 对 $20\%$ 的数据，保证 $m = 0$。
- 对 $50\%$ 的数据，保证 $n, m \leq 100$。
- 对 $70\%$ 的数据，保证 $n, m \leq 10^3$。
- 对 $100\%$ 的数据，保证 $2 \leq n \leq 3 \times 10^4$，$1 \leq u, v \leq n$，$0 \leq p,q \leq m \leq 10^3$，$u \neq v$。同一对敌人或朋友关系不会出现两次，不会有一对人同时是敌人或朋友关系。

### 提示

- 本题的空间限制为 $2 \mathrm{GiB}$。这一空间限制意味着你可以在程序中开出不超过 $2147483648(>2 \times 10^9)$ 个 bool 或 char 的数组。**注意，开不下同样大小的 int 数组**。
- 请注意空间限制是你程序运行时所使用的空间峰值，其中还包括了函数压栈、其他变量等空间占用。所以请不要卡着上限开数组。
- 如果你开出了过大的数组，可能会导致编译错误。此时请酌情减小你的数组大小。
- 对于某些 32 位系统，或可用内存过少的系统，直接开出大小约为 2GB 的数组可能无法编译或无法运行。可以先把数组开小来测试样例，提交时再改回符合数据范围的数组，也可以使用洛谷在线 IDE 来测试样例。洛谷评测机保证可以正常评测。

## 样例 #1

### 输入

```
4 2 2
1 2
2 3
1 4
1 3```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心在于处理人际关系网络中的握手规则，特别是陌生人之间的握手条件。题解中提供了三种不同的算法，分别适用于不同的数据规模。其中，算法一适用于所有人都是陌生人的情况，算法二通过直接枚举所有可能的关系对，适用于小规模数据，而算法三通过优化枚举策略，减少了不必要的计算，适用于大规模数据。

### 所选高星题解

#### 题解一：算法三 - 优化点对枚举
- **星级**：5星
- **关键亮点**：
  - 通过正难则反的思路，先假设所有陌生人都握手，再减去不握手的对数，大大减少了计算量。
  - 利用`calced`数组避免重复计算，优化了空间和时间复杂度。
  - 适用于大规模数据，且代码实现清晰易懂。

```cpp
int enemy[2][maxm];
for (int i = 1; i <= q; ++i) {
  cin >> enemy[0][i] >> enemy[1][i];
  calced[enemy[0][i]][enemy[1][i]] = calced[enemy[1][i]][enemy[0][i]] = true;
}

for (int i = 1; i <= q; ++i) {
  int u = enemy[0][i], v = enemy[1][i];
  for (int w = 1; w <= n; ++w) if (isFriend[v][w] && (!isFriend[u][w]) && (!calced[u][w])) {
    --ans;
    calced[u][w] = calced[w][u] = true;
  }
  swap(u, v);
  for (int w = 1; w <= n; ++w) if (isFriend[v][w] && (!isFriend[u][w]) && (!calced[u][w])) {
    --ans;
    calced[u][w] = calced[w][u] = true;
  }
}
```

### 最优关键思路或技巧

1. **正难则反**：在处理复杂条件时，先假设所有条件都满足，再逐步减去不满足的情况，可以有效减少计算量。
2. **空间优化**：通过合并`calced`和`isEnemy`数组，减少了空间占用，适用于大规模数据处理。
3. **枚举优化**：通过枚举敌人关系和朋友关系，减少了不必要的陌生人枚举，提高了算法效率。

### 可拓展之处

- **类似算法套路**：在处理复杂关系网络时，可以先假设所有关系都满足，再逐步减去不满足的情况，这种思路可以应用于其他类似问题，如社交网络中的信息传播、图论中的路径计算等。
- **数据结构**：在处理大规模数据时，合理选择数据结构（如二维数组、邻接表等）可以显著提高算法效率。

### 推荐洛谷题目

1. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385) - 考察图论中的负环检测，与本题中处理复杂关系网络有相似之处。
2. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371) - 考察图论中的最短路径问题，与本题中处理人际关系网络有相似之处。
3. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366) - 考察图论中的最小生成树问题，与本题中处理复杂关系网络有相似之处。

### 个人心得总结

- **调试经历**：在处理大规模数据时，空间和时间复杂度是关键，合理优化数据结构和算法可以显著提高程序性能。
- **踩坑教训**：在枚举陌生人关系时，直接枚举所有可能的关系对会导致超时，通过优化枚举策略可以避免这一问题。
- **顿悟感想**：在处理复杂条件时，正难则反的思路非常有效，可以大大简化问题。

---
处理用时：32.98秒
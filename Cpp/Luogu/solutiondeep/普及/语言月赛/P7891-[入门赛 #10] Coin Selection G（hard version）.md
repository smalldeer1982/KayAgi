# 题目信息

# [入门赛 #10] Coin Selection G（hard version）

## 题目描述

Farmer John 和 Bessie 正在一起玩硬币选择游戏。

初始时桌面上有 $n$ 枚硬币，每枚硬币有一个面额，我们使用 $a _ 1, a _ 2, \cdots, a _ n$ 分别代表第 $1, 2, \cdots, n$ 枚硬币的面额。

他们还各有一个属于自己的钱包，初始时，钱包都是空的。

从 **Bessie** 开始，双方轮流操作。每次操作中，当前的操作者会从桌面上剩余的硬币中选择**面值不超过当前自己钱包中硬币的总面额**的硬币中**面额最大的**一枚硬币，把它从桌子上拿走，放到自己的钱包里。如果桌面上剩余的**所有**硬币面值都**超过了自己钱包里已有硬币的总面额**，那么选择剩余的所有硬币中面额**最小**的一个。

当桌面上没有硬币时，游戏结束。

请你分别求出，	游戏结束后，Farmer John 和 Bessie 钱包里硬币的总面额。

## 说明/提示

### 数据规模与约定

- 对 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^{9}$。

Provider：一扶苏一

## 样例 #1

### 输入

```
2
3 2```

### 输出

```
2 3```

## 样例 #2

### 输入

```
5
1 2 3 4 5```

### 输出

```
9 6```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地模拟硬币选择过程，关键在于每次选择硬币时如何快速找到符合条件的硬币。暴力模拟的复杂度为 \(O(n^2)\)，无法通过 \(n \leq 10^5\) 的数据规模。因此，大多数题解都采用了二分查找来优化这一过程，将复杂度降低到 \(O(n \log n)\)。

### 所选高星题解

#### 1. 作者：GeorgeAAAADHD (4星)
**关键亮点：**
- 使用二分查找在排序后的硬币序列中快速找到符合条件的硬币。
- 使用 `vector` 动态维护硬币序列，利用 `iterator` 进行删除操作。
- 代码结构清晰，逻辑明确。

**核心代码：**
```cpp
void add(long long &sum){
    int l=0,r=a.size()-1,ans=0,x=0;
    while(l<=r){
        int mid=(l+r)/2;
        if(a[mid]<=sum){
            x=mid;
            ans=a[mid];
            l=mid+1;
        }
        else r=mid-1;
    }
    if(!ans){
        sum+=a[0];
        a.erase(a.begin());
    }
    else{
        sum+=a[x];
        a.erase(a.begin()+x);
    }
}
```
**实现思想：**
通过二分查找找到不超过当前钱包总面额的最大硬币，若找不到则选择最小硬币。使用 `vector` 动态维护硬币序列，删除已选择的硬币。

#### 2. 作者：liupan2010 (4星)
**关键亮点：**
- 使用 `upper_bound` 进行二分查找，简化了查找过程。
- 代码简洁，使用 STL 高效处理数据。
- 逻辑清晰，易于理解。

**核心代码：**
```cpp
if(!Turn){
    if(FarmerJohn<Coin[0]){
        FarmerJohn+=Coin[0];
        Coin.erase(Coin.begin());
    }
    else{
        Temp=FarmerJohn;
        FarmerJohn+=Coin[upper_bound(Coin.begin(),Coin.end(),FarmerJohn)-Coin.begin()-1];
        Coin.erase(upper_bound(Coin.begin(),Coin.end(),Temp)-1);
    }
}
```
**实现思想：**
通过 `upper_bound` 找到不超过当前钱包总面额的最大硬币，若找不到则选择最小硬币。使用 `vector` 动态维护硬币序列，删除已选择的硬币。

#### 3. 作者：HDZmessi (4星)
**关键亮点：**
- 详细解释了二分查找的实现过程，并强调了维护 `vector` 的重要性。
- 提供了错误代码与正确代码的对比，帮助理解优化过程。
- 代码结构清晰，逻辑明确。

**核心代码：**
```cpp
ll check(ll a){
    auto it=p.begin();
    if(a<p[0]){
        ll y=p[0];
        p.erase(it);
        return y;
    }
    ll left=0,right=p.size()-1,mid,ans;
    while(left<=right){
        mid=(left+right)/2;
        if(p[mid]>a){
            right=mid-1;
        }
        else{
            it=p.begin()+mid;
            left=mid+1;
            ans=p[mid];
        }
    }
    p.erase(it);
    return ans;
}
```
**实现思想：**
通过二分查找找到不超过当前钱包总面额的最大硬币，若找不到则选择最小硬币。使用 `vector` 动态维护硬币序列，删除已选择的硬币。

### 最优关键思路与技巧
- **二分查找**：通过二分查找快速找到符合条件的硬币，将复杂度从 \(O(n^2)\) 降低到 \(O(n \log n)\)。
- **动态维护**：使用 `vector` 动态维护硬币序列，利用 `iterator` 进行删除操作。
- **STL 使用**：熟练使用 `upper_bound` 等 STL 函数简化代码实现。

### 可拓展之处
- **类似算法套路**：二分查找常用于在有序序列中快速查找符合条件的元素，适用于需要频繁查找的场景。
- **同类型题**：类似题目可以考察如何在动态序列中高效查找和删除元素，如动态维护优先队列等。

### 推荐题目
1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
2. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)
3. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)

### 个人心得摘录
- **调试经历**：HDZmessi 提到自己在维护 `vector` 时因未将维护步骤加入二分函数而导致 TLE，强调了优化过程中的细节重要性。
- **踩坑教训**：多位作者提到不开 `long long` 会导致错误，提醒了数据范围的重要性。

### 通用建议与扩展思路
- **数据范围**：在处理大范围数据时，务必注意数据类型的选择，避免溢出。
- **算法优化**：在暴力模拟无法通过时，考虑使用二分查找、优先队列等优化手段。
- **代码结构**：保持代码结构清晰，逻辑明确，便于调试和优化。

---
处理用时：37.72秒
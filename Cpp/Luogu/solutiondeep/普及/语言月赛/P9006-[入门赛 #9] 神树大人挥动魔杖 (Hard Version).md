# 题目信息

# [入门赛 #9] 神树大人挥动魔杖 (Hard Version)

## 题目背景

**本题与 Easy Version 题意完全相同，仅有 $n,k$ 的数据范围有所不同。**

## 题目描述

神树大人挥动魔杖，召唤出了 $9 \times 10^{n-1}$ 只家养小精灵。每只家养小精灵都有一个互不相同的 $n$ 位数编号 $a_i$。

神树大人希望将这些家养小精灵分为 $k$ 组。第 $p$ 组的所有家养小精灵满足编号 $a_i$ 对 $k$ 取模余 $p-1$，即 $a_i \equiv p-1 \pmod k$。

神树大人想要知道，每一组小精灵分别有多少只。由于答案可能很大，你只需要输出答案对 $100,000,007$ 取模的结果

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 5000$，$1 \le k \le 1000$。

## 样例 #1

### 输入

```
3 10```

### 输出

```
90 90 90 90 90 90 90 90 90 90
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效计算从 $10^{n-1}$ 到 $10^n-1$ 的所有 $n$ 位数中，每个数对 $k$ 取模的余数分布情况。由于 $n$ 的范围较大（$1 \le n \le 5000$），直接枚举不可行，因此需要借助数学和算法优化。

**关键思路与技巧：**
1. **差分思想**：通过计算前 $10^n$ 个数和前 $10^{n-1}$ 个数中模 $k$ 的余数分布，利用差分得到结果。
2. **快速幂取余**：利用快速幂计算 $10^n \bmod k$ 和 $10^{n-1} \bmod k$，避免大数计算。
3. **模运算的循环性**：利用模运算的循环性，减少计算量。
4. **边界处理**：正确处理模运算的边界情况，确保结果的准确性。

### 所选高星题解

#### 1. 作者：览遍千秋 (4星)
**关键亮点：**
- 使用递推方法，通过枚举最高位的数字，逐步计算每个位数的模 $k$ 余数分布。
- 代码结构清晰，时间复杂度为 $O(nk)$，适合大规模数据。

**核心代码：**
```cpp
for(int i = 2; i <= n; i++) {
    mul = mul * 10 % k;
    for(int j = 1; j <= 9; j++) {
        long long val = j * mul % k;
        for(int p = 0; p < k; p++) {
            long long to = (p + val) % k;
            f[i][to] = (f[i][to] + sum[p]) % mod;
        }
        f[i][val]++;
    }
    for(int j = 0; j < k; j++) sum[j] += f[i][j], sum[j] %= mod;
}
```
**实现思想：** 通过递推计算每个位数的模 $k$ 余数分布，利用前缀和优化计算。

#### 2. 作者：N_O_I_P (4星)
**关键亮点：**
- 使用差分思想和快速幂取余，计算前 $10^n$ 和前 $10^{n-1}$ 个数的模 $k$ 余数分布。
- 代码结构清晰，时间复杂度为 $O(\log n + k)$，效率较高。

**核心代码：**
```cpp
int zong = (fp(10,n - 1,k) - 1 + k) % k;
int sheng = (fp(10,n - 1,M) - 1 - zong + M) * fp(k,M - 2,M) % M;

for(int i = 0; i < k; i++){
    ans[i] -= sheng;
    if (i != 0 && i <= zong) ans[i]--;
}
```
**实现思想：** 利用快速幂计算模 $k$ 的余数，通过差分得到最终结果。

#### 3. 作者：Ag2WO4 (4星)
**关键亮点：**
- 使用快速幂取余和差分思想，计算前 $10^n$ 和前 $10^{n-1}$ 个数的模 $k$ 余数分布。
- 代码简洁，时间复杂度为 $O(\log n + k)$，适合大规模数据。

**核心代码：**
```cpp
u = v = 1; m[0] = 10;
for(i = 0; i < 12;) m[++i] = (m[i] * m[i]) % (k * t);
for(i = 0; i < 13; i++) if(n & (1 << i)) u = u * m[i] % (k * t);
n--;
for(i = 0; i < 13; i++) if(n & (1 << i)) v = v * m[i] % (k * t);
```
**实现思想：** 利用快速幂计算模 $k$ 的余数，通过差分得到最终结果。

### 推荐题目
1. **P1226 【模板】快速幂**：练习快速幂的基本应用。
2. **P1045 麦森数**：涉及大数计算和模运算。
3. **P1082 同余方程**：练习模运算和同余方程的应用。

### 个人心得总结
- **调试经历**：在处理模运算时，边界情况容易出错，需要仔细检查。
- **踩坑教训**：快速幂取余时，注意数据类型的选择，避免溢出。
- **顿悟感想**：差分思想在处理区间问题时非常有效，可以大大减少计算量。

---
处理用时：34.88秒
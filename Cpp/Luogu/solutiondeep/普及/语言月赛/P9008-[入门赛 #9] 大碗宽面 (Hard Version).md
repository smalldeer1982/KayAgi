# 题目信息

# [入门赛 #9] 大碗宽面 (Hard Version)

## 题目背景


**本题与 Easy Version 题意完全相同，仅有 $n$ 的数据范围和空间限制不同**。

扶苏和她的朋友们在 Impart 酒店开派对。

## 题目描述

算上扶苏，本次派对共有 $n$ 个人。但是，并不是任何两个人都互相认识，并且互相认识的人关系也未必好。

具体而言，任意两个人可能是如下三种关系之一：
1. 敌人
2. 朋友
3. 陌生人

派对的一大重要活动是相互握手。对任意两个人 $u,v$，他们之间的握手情况遵循下面的规则：
1. 如果 $u$ 和 $v$ 是朋友关系，那么他们一定握手一次。
2. 如果 $u$ 和 $v$ 是敌人关系，那么他们一定**不**握手。
3. 如果 $u$ 和 $v$ 是陌生人关系，且存在一个人 $w$，使得 $w$ 是 $u$ 和 $v$ 之一的朋友，同时是 $u,v$ 中另一人的敌人，则 $u$ 和 $v$ **不会**握手，否则 $u$ 和 $v$ 一定握手一次。

对第三条规则，简单的说法是：一对陌生人之间，如果某一方的朋友是另一方的敌人，则不握手，否则握手。

已知共有 $p$ 对人是朋友关系，$q$ 对人是敌人关系。除了这 $p + q$ 对人，其他每对人均为陌生人关系。

请你求出本次派对一共握手了多少次。

## 说明/提示

### 样例 1 解释

共有 $(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)$ $6$ 对人。
- $(1,2)$ 是朋友，握手。
- $(1,3)$ 是敌人，不握手。
- $(1,4)$ 是敌人，不握手。
- $(2,3)$ 是朋友，握手。
- $(2,4)$ 是陌生人，但是 $1$ 是 $2$ 的朋友，也是 $4$ 的敌人，所以不握手。
- $(3,4)$ 是陌生人，但是不存在任何一个人既是 $3$ 和 $4$ 之一的敌人也是另一个人的朋友，故握手。

综上，一共握手 $3$ 次。

### 数据规模与约定

以下设 $m = p + q$，即 $m$ 是朋友和敌人关系条数之和。

- 对 $100\%$ 的数据，保证 $2 \leq n \leq 10^6$，$1 \leq u, v \leq n$，$0 \leq p,q \leq m \leq 10^3$，$u \neq v$。同一对敌人或朋友关系不会出现两次，不会有一对人同时是敌人或朋友关系。

By 一扶苏一

## 样例 #1

### 输入

```
4 2 2
1 2
2 3
1 4
1 3```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心在于如何处理大规模数据（n ≤ 10^6）下的握手关系计算，尤其是陌生人之间的握手规则。由于直接枚举所有点对不可行，多数题解采用了“正难则反”的思路，即先计算总握手次数，再减去不握手的次数。难点在于如何高效地处理陌生人之间的握手规则，尤其是避免重复计算。

### 所选高星题解

#### 1. 作者：一扶苏一 (5星)
- **关键亮点**：  
  - 思路清晰，采用“正难则反”策略，先计算总握手次数，再减去不握手的次数。
  - 利用 `map` 记录已处理的点对，避免重复计算。
  - 复杂度分析详细，时间复杂度为 O(m^2 log n)，适合大规模数据。
- **代码实现**：
  ```cpp
  for (int u = 1; u <= n; ++u) {
      for (auto v : enemy[u]) {
          for (auto w : frnds[u]) if (!calced[{w, v}]) {
              calced[{w,v}] = calced[{v,w}] = true;
              --ans;
          }
          for (auto w : frnds[v]) if (!calced[{w, u}]) {
              calced[{w,u}] = calced[{u,w}] = true;
              --ans;
          }
      }
  }
  ```
  **核心思想**：枚举每对敌人，再枚举其朋友的朋友，判断是否构成不握手的三元关系，并用 `map` 记录已处理的点对。

#### 2. 作者：_•́へ•́╬_ (5星)
- **关键亮点**：  
  - 采用暴力枚举，但通过优化避免了大规模数据的重复计算。
  - 使用 `bool` 数组记录已处理的点对，避免了 `map` 的 log n 开销。
  - 代码简洁，适合小规模数据。
- **代码实现**：
  ```cpp
  for(int i=0;i<n;++i) {
      for(int j=h1[i];j;j=nxt1[j])a[e1[j]]=1;
      for(int j=h1[i];j;j=nxt1[j])for(int k=h2[e1[j]];k;k=nxt2[k])
          ans-=!a[e2[k]],a[e2[k]]=1;
      for(int j=h2[i];j;j=nxt2[j]) {
          ans-=!a[e2[j]],a[e2[j]]=1;
          for(int k=h1[e2[j]];k;k=nxt1[k])
              ans-=!a[e1[k]],a[e1[k]]=1;
      }
  }
  ```
  **核心思想**：通过链式前向星存储朋友和敌人关系，枚举每对朋友和敌人，判断是否构成不握手的三元关系。

#### 3. 作者：Ray1 (4星)
- **关键亮点**：  
  - 采用“正难则反”思路，先计算总握手次数，再减去不握手的次数。
  - 使用 `map` 记录已处理的点对，避免重复计算。
  - 代码简洁，适合大规模数据。
- **代码实现**：
  ```cpp
  for(int u=1;u<=n;u++)for(int mid:P[u])for(int v:Q[mid])if(!m[{u,v}])s++,m[{u,v}]=m[{v,u}]=1;
  ```
  **核心思想**：枚举每对朋友和敌人，判断是否构成不握手的三元关系，并用 `map` 记录已处理的点对。

### 最优关键思路与技巧

1. **正难则反**：先计算总握手次数，再减去不握手的次数，避免直接处理复杂的陌生人握手规则。
2. **避免重复计算**：使用 `map` 或 `bool` 数组记录已处理的点对，确保每条边只被处理一次。
3. **高效枚举**：通过枚举朋友和敌人的关系，避免直接枚举所有点对，降低时间复杂度。

### 可拓展之处

- **类似问题**：处理大规模图的关系计算时，可以采用类似的“正难则反”策略，避免直接处理复杂的规则。
- **数据结构优化**：在处理大规模数据时，可以考虑使用更高效的数据结构（如并查集、哈希表）来优化查询和更新操作。

### 推荐题目

1. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)：考察图的负环检测，适合练习图的遍历与优化。
2. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：考察单源最短路径算法，适合练习图的遍历与优化。
3. [P3386 【模板】二分图匹配](https://www.luogu.com.cn/problem/P3386)：考察二分图匹配算法，适合练习图的匹配与优化。

### 个人心得总结

- **调试经历**：在处理大规模数据时，避免直接枚举所有点对是关键，采用“正难则反”策略可以有效降低复杂度。
- **踩坑教训**：使用 `map` 记录已处理的点对时，注意避免重复计算，确保每条边只被处理一次。
- **顿悟感想**：在处理复杂规则时，转换思路（如“正难则反”）往往能简化问题，提高代码效率。

---
处理用时：37.29秒
# 题目信息

# [入门赛 #14] 魔法少女扶苏 (Hard Version)

## 题目描述

给定一个 $n$ 行 $m$ 列的数字矩阵，第 $i$ 行第 $j$ 列的数称为 $a_{i,j}$。

扶苏可以释放任意多次魔法，每次施放魔法，矩阵里的**每个**数字都会被减去 $1$。

现在扶苏想知道，她至少需要释放几次魔法，才能让矩阵中存在至少 $k$ 个位置 $(x, y)$，满足 $a_{x, y}$ 大于或等于它所在行和列的元素之和。

形式化地，你需要计算最小的魔法释放次数使得施放魔法后存在至少 $k$ 个位置 $(x, y)$，满足 $a_{x, y} \geq \sum \limits _{i = 1}^n a_{i,y} + \sum \limits _{i = 1}^m a_{x,i}$。

## 说明/提示

### 样例 1 解释

释放 $3$ 次魔法后，矩阵变为

$$\begin{matrix}-2 & -1 & 0\\1& 2&3\\\end{matrix}$$

于是 $a_{1,1} = -2 > (-1) + (-3) = \sum\limits_{i =1}^n a_{i,1} + \sum\limits_{i = 1}^m a_{1, i}$。

### 数据规模与约定

- 对 $100\%$ 的数据，保证 $1 \leq n, m \leq 3 \times 10^3$，$1 \leq k \leq n \times m$，$0 \leq a_i \leq 10^{11}$。

### 提示

**请使用合理的读入方式，避免超时。**

## 样例 #1

### 输入

```
2 3 1
1 2 3
4 5 6
```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心在于通过数学推导和预处理，找到满足条件的最小魔法释放次数。大多数题解都采用了类似的思路：预处理每行和每列的和，然后通过公式计算每个位置所需的魔法次数，最后通过排序或二分查找找到第k小的魔法次数。以下是对各题解的简要分析与评分：

1. **FFTotoro (5星)**：思路清晰，代码简洁，使用了`std::nth_element`进行优化，时间复杂度为O(nm)，是最高效的解法之一。
2. **cjh20090318 (4星)**：使用了优先队列，时间复杂度为O(nm log k)，虽然稍慢但思路清晰，代码可读性较好。
3. **sto_5k_orz (4星)**：直接排序，时间复杂度为O(nm log nm)，虽然效率稍低，但思路简单直接，代码易于理解。

### 所选高分题解

#### 1. FFTotoro (5星)
**关键亮点**：
- 使用了`std::nth_element`进行优化，避免了完全排序的开销，时间复杂度为O(nm)。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for(int i=0;i<n;i++)
    for(int j=0;j<m;j++)
      d.emplace_back(div_ceil(r[i]+c[j]-a[i][j],n+m-1));
nth_element(d.begin(),d.begin()+k-1,d.end());
cout<<d[k-1]<<endl;
```
**核心思想**：预处理每行和每列的和，计算每个位置所需的魔法次数，使用`std::nth_element`找到第k小的魔法次数。

#### 2. cjh20090318 (4星)
**关键亮点**：
- 使用了优先队列，时间复杂度为O(nm log k)，虽然稍慢但思路清晰。
- 代码可读性较好，适合初学者理解。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)for(int j=1;j<=m;j++){
    Q.push((s[i]+q[j]-a[i][j]+n+m-2)/(n+m-1));
    while((int)Q.size()>k) Q.pop();
}
io.write(Q.top());
```
**核心思想**：预处理每行和每列的和，计算每个位置所需的魔法次数，使用优先队列维护前k小的魔法次数。

#### 3. sto_5k_orz (4星)
**关键亮点**：
- 直接排序，时间复杂度为O(nm log nm)，虽然效率稍低，但思路简单直接。
- 代码易于理解，适合初学者。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)for(int j=1;j<=m;j++){
    f[++top]=ceil(max((long long)0,hang[i]+lie[j]-a[i][j])*1.0/(n+m-1));
}
sort(f+1,f+1+top);
printf("%lld",f[k]);
```
**核心思想**：预处理每行和每列的和，计算每个位置所需的魔法次数，直接排序找到第k小的魔法次数。

### 最优关键思路与技巧
1. **预处理**：通过预处理每行和每列的和，可以快速计算每个位置所需的魔法次数。
2. **数学推导**：通过公式推导，将问题转化为简单的数学计算，避免了复杂的逻辑。
3. **优化查找**：使用`std::nth_element`或优先队列等数据结构，优化查找第k小的魔法次数。

### 可拓展之处
- **类似问题**：可以拓展到其他需要预处理和快速查找的问题，如矩阵中的最大值、最小值等。
- **数据结构**：可以进一步学习其他高效的数据结构，如堆、树等，以应对更复杂的问题。

### 推荐题目
1. [P1923 求第 k 小的数](https://www.luogu.com.cn/problem/P1923)
2. [P1177 快速排序](https://www.luogu.com.cn/problem/P1177)
3. [P3378 堆](https://www.luogu.com.cn/problem/P3378)

### 个人心得摘录
- **FFTotoro**：使用`std::nth_element`可以避免完全排序的开销，显著提高效率。
- **cjh20090318**：优先队列虽然稍慢，但思路清晰，适合初学者理解。
- **sto_5k_orz**：直接排序虽然效率稍低，但思路简单直接，易于实现。

通过以上分析与总结，可以帮助读者更好地理解本题的解法，并应用到类似的问题中。

---
处理用时：37.10秒
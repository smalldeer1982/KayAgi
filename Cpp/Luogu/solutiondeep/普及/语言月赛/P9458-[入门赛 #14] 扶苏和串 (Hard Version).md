# 题目信息

# [入门赛 #14] 扶苏和串 (Hard Version)

## 题目背景

众所周知，每个月入门赛的字符串题都是扶苏来枚举 idea 出出来的。

## 题目描述

给定一个 01 字符串 $s$，你可以任选 $s$ 的一个非空子串，把这个子串在 $s$ 中**翻转**一次。

问你能得到字典序最小的字符串是什么？

形式化的，你可以选择一个区间 $[l, r]$ 满足 $1 \leq l \leq r \leq |s|$，构造一个串 $t$ 满足：

$$t_i = \begin{cases}s_i, &i < l \text{ 或 } i > r \\ s_{r - (i - l)}, & l \leq i \leq r\end{cases}$$

最小化字符串 $t$ 的字典序。

## 说明/提示

### 样例 1 解释

$s = \texttt{\underline{10}1}$，翻转下划线标出的子串，得到 $t = \texttt{011}$

### 样例 2 解释

$s = \texttt{00\underline{10100}}$，翻转下划线标出的子串，得到 $\texttt{0000101}$。

### 数据规模与约定

下面用 $|s|$ 表示输入字符串的长度。

- 对 $100\%$ 的数据，$1 \leq |s| \leq 3000$。$s$ 只含字符 $\texttt{0,1}$。

## 样例 #1

### 输入

```
101```

### 输出

```
011```

## 样例 #2

### 输入

```
0010100```

### 输出

```
0000101```

# AI分析结果

### 综合分析与结论

本题的核心目标是通过翻转一个子串，使得最终的字符串字典序最小。大部分题解都围绕如何优化暴力枚举的思路展开，主要集中在如何确定翻转的左端点和右端点。以下是各题解的主要思路和优化点：

1. **确定左端点**：几乎所有题解都指出，翻转的左端点应该是字符串中第一个出现 `1` 的位置。这是因为翻转左端点之前的 `0` 不会改变字典序，而翻转左端点之后的 `1` 会使得字典序变大。
  
2. **枚举右端点**：在确定了左端点后，题解们普遍采用枚举右端点的方式，通过翻转区间并比较字典序来找到最优解。时间复杂度为 \(O(n^2)\)，在 \(n \leq 3000\) 的范围内可以通过。

3. **优化与证明**：部分题解提供了详细的证明，说明为什么左端点必须是第一个 `1` 的位置，以及为什么翻转后的字符串字典序会更小。

### 题解评分与亮点

经过分析，以下题解在思路清晰度、代码可读性和优化程度上表现较好，评分≥4星：

#### 1. 作者：I_am_AKed_by_NOI (赞：15)
- **星级**：★★★★★
- **关键亮点**：
  - 详细解释了暴力解法的不足，并提出了优化思路。
  - 提供了翻转左端点固定的证明，逻辑清晰。
  - 代码结构清晰，注释详细，易于理解。
- **个人心得**：作者在题解中详细讲解了如何比对字符串的字典序大小，以及如何翻转字符串，适合新手学习。

#### 2. 作者：一扶苏一 (赞：7)
- **星级**：★★★★
- **关键亮点**：
  - 通过反证法证明了左端点必须是第一个 `1` 的位置。
  - 代码简洁，逻辑清晰，适合有一定基础的读者。
- **个人心得**：作者在题解中提到了一个存在问题的做法，并解释了为什么该做法不成立，帮助读者避免踩坑。

#### 3. 作者：_Glassy_Sky_ (赞：0)
- **星级**：★★★★
- **关键亮点**：
  - 提供了两种找到第一个 `1` 的方法，适合不同水平的读者。
  - 代码简洁，逻辑清晰，易于理解。
- **个人心得**：作者在题解中详细讲解了如何通过 `find` 函数找到第一个 `1` 的位置，适合新手学习。

### 最优关键思路与技巧

1. **固定左端点**：翻转的左端点必须是字符串中第一个 `1` 的位置，这样可以确保翻转后的字符串字典序最小。
  
2. **枚举右端点**：在确定了左端点后，枚举右端点并翻转区间，通过比较字典序来找到最优解。

3. **字符串翻转与比较**：使用 `reverse` 函数翻转子串，并通过 `min` 函数比较字符串的字典序。

### 可拓展之处

1. **类似题目**：可以扩展到其他需要翻转子串或区间操作的问题，如翻转后求最大字典序、翻转后求特定模式的字符串等。
  
2. **优化思路**：如果字符串长度更大，可以考虑进一步优化右端点的枚举方式，如通过二分查找或其他数据结构来减少枚举次数。

### 推荐题目

1. [P1739 表达式括号匹配](https://www.luogu.com.cn/problem/P1739)：考察字符串处理与栈的应用。
2. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)：考察字符串处理与模拟。
3. [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)：考察字符串匹配与统计。

### 核心代码片段

以下是作者：I_am_AKed_by_NOI 的核心代码片段：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
string s1,s2,ans; //ans 是最后输出的答案 
int l,r; //l 是字符串中第一次出现 1 的位置，即翻转的左端点 
int main()
{
	cin>>s1;
	s2=s1; //进行备份 
	ans=s1;
  	for(int i=0;i<s1.length();i++) //遍历整个字符串，寻找第一次出现 1 的位置
	{
    	if(s1[i]=='1')
		{
    		l=i; //找到了就返回 
    		break;
    	}
	}
	for(r=l+1;r<s1.length();r++) //枚举旋转的右端点 
	{
		for(int j=l,k=r;j<=r,k>=l;j++,k--)
		{
    		s2[j]=s1[k]; //将字符串的 [l,r] 进行翻转 
    	}
    	if(s2<ans) //如果旋转之后的字符串字典序更小 
		{
    		ans=s2; //就将答案更新为字典序更小的字符串 
    	}
	}
	cout<<ans;
	return 0; //漂亮的结尾！ 
}
```

### 总结

本题的关键在于如何通过固定左端点并枚举右端点来优化暴力解法，最终找到字典序最小的字符串。推荐的题解在思路清晰度和代码实现上都表现较好，适合不同水平的读者学习。

---
处理用时：42.89秒
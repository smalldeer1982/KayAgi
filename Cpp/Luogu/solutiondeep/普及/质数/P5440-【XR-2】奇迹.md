# 题目信息

# 【XR-2】奇迹

## 题目背景

> 相信奇迹的人，本身就和奇迹一样了不起。——笛亚 《星游记》

## 题目描述

我们称一个**日期**为一个八位数，第 1~4 位构成年，第 5~6 位构成月，第 7~8 位构成日，不足位数用 0 补足。同时，要求日期所代表的这一天真实存在，且年的范围为 1~9999。

出现奇迹的日期都存在相同的特点：由“日”组成的两位数，由“月+日”组成的四位数，由“年+月+日”组成的八位数均为**质数**。但并不是所有存在这样特点的日期都一定会出现奇迹。

现在，你得到了一个可能会出现奇迹的日期，然而不幸的是这个日期却是残缺的，八位中可能有若干位无法确定。你需要知道这个日期有多少种可能，这样你才能做好充足的准备去迎接奇迹的到来。

## 说明/提示

【样例 $1$ 说明】

`53-7-3-7` 的 $6$ 种可能的日期如下：

```plain
53070307
53070317
53170307
53370307
53570317
53770307
```

【数据规模与约定】

一共 $10$ 个测试点，记 $c$ 为八位字符串中 `-` 的个数。

对前 $9$ 个测试点，在第 $i$ 个测试点中保证 $c = i - 1$。

对 $100\%$ 的数据保证 $1 \le T \le 10$。

## 样例 #1

### 输入

```
2
53-7-3-7
20190629
```

### 输出

```
6
0
```

# AI分析结果

### 综合分析与结论

该题目要求计算满足特定条件的日期数量，主要难点在于处理日期的合法性和质数的判断。多数题解采用了暴力搜索（DFS）结合质数筛法的思路，部分题解通过剪枝和预处理优化了搜索效率。整体来看，题解的质量参差不齐，部分题解通过优化和特判显著提升了效率，而有些题解则存在代码冗长或思路不够清晰的问题。

### 评分较高的题解

#### 1. 作者：xht (★★★★★)
**关键亮点：**
- **预处理优化**：通过预处理满足条件的日期，减少了搜索空间。
- **质数判断优化**：使用线性筛法预处理质数，提高了质数判断的效率。
- **代码简洁**：代码结构清晰，逻辑简单易懂。

**核心代码：**
```cpp
inline bool is_prime(int x) {
    for (int i = 2; i * i <= x; i++)
        if (x % i == 0) return 0;
    return 1;
}
```
**实现思想**：通过预处理满足条件的日期，并在搜索时直接判断是否匹配输入字符串，避免了大量不必要的计算。

#### 2. 作者：⚡LZSY01_XZY⚡ (★★★★☆)
**关键亮点：**
- **枚举优化**：通过确定枚举上下界，提高了枚举效率。
- **特判优化**：对全`-`的情况进行特判，显著减少了计算量。
- **代码可读性**：代码结构清晰，注释详细。

**核心代码：**
```cpp
inline void prime() {
    v[1]=true;
    for (int i=2;i<=MAXN;i++) {
        if (!v[i]) prim[++tot]=i;
        for (int j=1;j<=tot;j++) {
            if (i*prim[j]>=MAXN) break;
            v[i*prim[j]]=true;
            if (i%prim[j]==0) break;
        }
    }
}
```
**实现思想**：通过线性筛法预处理质数，并在枚举时结合特判和优化，减少了不必要的计算。

#### 3. 作者：Ciyang (★★★★☆)
**关键亮点：**
- **搜索顺序优化**：按日、月、年的顺序搜索，逐层判断，提高了搜索效率。
- **质数判断优化**：使用线性筛法预处理质数，提高了质数判断的效率。
- **代码优雅**：代码结构清晰，逻辑简单易懂。

**核心代码：**
```cpp
int dfs(int nown, int num, int rn, int jy) {
    if(nown == 0) {
        if(num / 10000 == 0) return 0;
        if(rn && pdrn(num / 10000) == 0) return 0;
        return pdzs(num);
    }
    if(nown == 6) {
        if(num == 0 || num > 31 || !pdzs(num)) return 0;
        if(num == 31) jy= 1;
    }
    if(nown == 4) {
        if(num < 32 || num > 1231 || !pdzs(num)) return 0;
        if(jy && !yue[num / 100]) return 0;
        if(num / 100 == 2) {
            if(num % 100 > 29) return 0;
            if(num % 100 == 29) rn= 1;
        }
    }
    if(a[nown] != -1) return dfs(nown - 1, a[nown] * p10[8 - nown] + num, rn, jy);
    int res= 0;
    for(int i= 0; i <= 9; i++) res+= dfs(nown - 1, i * p10[8 - nown] + num, rn, jy);
    return res;
}
```
**实现思想**：通过按日、月、年的顺序搜索，逐层判断日期的合法性，并结合质数判断，提高了搜索效率。

### 最优关键思路与技巧

1. **预处理与筛法**：通过预处理质数和满足条件的日期，减少搜索空间，提高效率。
2. **搜索顺序优化**：按日、月、年的顺序搜索，逐层判断，减少不必要的计算。
3. **剪枝与特判**：通过剪枝和特判，减少搜索路径，提升算法效率。

### 可拓展之处

- **类似题目**：可以拓展到其他需要处理日期和质数的题目，如计算特定范围内的质数日期数量。
- **算法套路**：类似的搜索优化和预处理技巧可以应用于其他需要处理大量数据的题目，如数论问题或组合优化问题。

### 推荐题目

1. **P1217 [USACO1.5]回文质数**：考察质数和回文数的判断，与本题类似。
2. **P1075 质因数分解**：考察质数的判断和分解，与本题的质数判断部分相关。
3. **P1029 最大公约数和最小公倍数问题**：考察数论中的质数和因数分解，与本题的质数判断部分相关。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现了一些细节问题，如日期的合法性和质数的判断，这些细节往往是解题的关键。
- **踩坑教训**：在处理日期时，特别是闰年和月份的合法性时，容易忽略一些特殊情况，如2月29日。
- **顿悟感想**：通过预处理和优化，可以显著提升算法的效率，尤其是在处理大量数据时，优化思路尤为重要。

---
处理用时：35.70秒
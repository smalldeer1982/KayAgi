# 题目信息

# 双重素数（2021 CoE-II A）

## 题目描述

素数（质数）是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。定义**双重素数**为这样的素数：它的各位数字之和也是一个素数。给定一个闭区间，试确定在该区间内双重素数的个数。

## 说明/提示

**样例说明**

从 $1$ 到 $15$ 共有 $6$ 个素数：$2$，$3$，$5$，$7$，$11$，$13$。前五个素数各自的数字之和也是素数，因此都是双重素数。素数 $13$ 的各位数字之和为 $4$，不是素数，故 $13$ 不是双重素数。

------------


**数据范围**

- Subtask $1$ ：$1 \le L \le R \le 10^2$，$10$ 分。
- Subtask $2$ ：$1 \le L \le R \le 10^4$，$20$ 分。
- Subtask $3$ ：$1 \le L \le R \le 10^6$，$60$ 分。
- Subtask $4$ ：$1 \le L \le R \le 10^8$，$10$ 分。

对于 $100\%$ 的数据，$1 \le T \le 100$。


------------

**提示（数据已经加强）**

最后一个子任务要求你的程序必须具有较高的空间使用效率和时间效率，否则容易超出内存限制或时间限制。

## 样例 #1

### 输入

```
4
3 3
4 4
1 5
1 15```

### 输出

```
1
0
3
5```

# AI分析结果

### 综合分析与结论

本题的核心在于高效筛选素数，并进一步筛选出“双重素数”。由于数据范围较大（$1 \le L \le R \le 10^8$），直接暴力筛法会导致时间或空间超限。因此，题解中普遍采用了**欧拉筛法**（线性筛）来高效筛选素数，并结合**bitset**或**位标记**来优化空间使用。此外，部分题解还通过**二分查找**来快速统计区间内的双重素数数量。

### 所选高星题解

#### 1. 作者：王熙文 (5星)
- **关键亮点**：
  - 使用**bitset**优化空间，解决了大范围筛素数的内存问题。
  - 通过**欧拉筛法**高效筛选素数，并结合**二分查找**快速统计区间内的双重素数。
  - 提供了**位标记**的替代方案，进一步优化空间和时间。
- **个人心得**：
  - 作者提到使用`bitset`时，空间仅为`bool`数组的$\dfrac{1}{8}$，且时间效率更高。
  - 通过`lower_bound`和`upper_bound`函数，简化了区间统计的代码实现。

**核心代码**：
```cpp
bitset<100000001> b;
void work() {
    const int n=100000000;
    b[1]=1;
    for(int i=2; i<=n; ++i) {
        if(!b[i]) dp[++k]=i;
        for(int j=1; j<=k && i*dp[j]<=n; ++j) {
            b[dp[j]*i]=1;
            if(!(i%dp[j])) break;
        }
    }
}
```

#### 2. 作者：_lfxxx_ (4.5星)
- **关键亮点**：
  - 使用**bitset**优化空间，并结合**欧拉筛法**高效筛选素数。
  - 通过**前缀和**和**二分查找**快速统计区间内的双重素数。
  - 代码结构清晰，易于理解。
- **个人心得**：
  - 作者提到`bitset`的使用不仅节省了空间，还提高了时间效率。

**核心代码**：
```cpp
bitset<n+1> numlist;
void Getprime() {
    for(int i=2;i<=n;i++) {
        if(!numlist[i]) prime[++cnt]=i;
        for(int j=1;i*prime[j]<=n;j++) {
            numlist[i*prime[j]]=1;
            if(!(i%prime[j])) break;
        }
    }
}
```

#### 3. 作者：metaphysis (4星)
- **关键亮点**：
  - 使用**位标记**优化空间，并结合**欧拉筛法**高效筛选素数。
  - 通过**二分查找**快速统计区间内的双重素数。
  - 代码简洁，逻辑清晰。
- **个人心得**：
  - 作者提到位标记的使用不仅节省了空间，还提高了时间效率。

**核心代码**：
```cpp
#define GET(x) (B[x >> 5] & (1 << (x & 0x1F)))
#define SET(x) (B[x >> 5] |= (1 << (x & 0x1F)))
void prime(int tt) {
    for(int i=2;i<=tt;i++) {
        if(!GET(i)) f[++cnt]=i;
        for(int j=1;j<=cnt && f[j]*i<=tt;j++) {
            SET(f[j]*i);
            if(!(i%f[j])) break;
        }
    }
}
```

### 最优关键思路与技巧
1. **欧拉筛法**：线性时间复杂度筛选素数，适用于大范围数据。
2. **bitset/位标记**：优化空间使用，减少内存占用。
3. **二分查找**：快速统计区间内的双重素数数量，提升查询效率。

### 可拓展之处
- **类似筛法应用**：可以扩展到其他需要高效筛选素数的题目，如区间内素数的个数、素数的性质判断等。
- **位标记优化**：在其他需要大范围标记的场景中，位标记可以作为一种通用的优化手段。

### 推荐题目
1. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)
2. [P3912 素数个数](https://www.luogu.com.cn/problem/P3912)
3. [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)

### 个人心得总结
- **调试经历**：多位作者提到使用`bitset`或位标记时，调试过程中需要注意内存和时间的平衡，避免超限。
- **踩坑教训**：部分作者提到在筛法过程中，合数可能会被重复标记，导致效率下降，需注意优化。
- **顿悟感想**：通过`lower_bound`和`upper_bound`函数，可以简化区间统计的代码实现，提升代码可读性和效率。

---
处理用时：27.60秒
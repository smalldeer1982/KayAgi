# 题目信息

# [CSP-X2020 山东] 分糖果

## 题目背景

老师组织一群孩子围成一个圈进行游戏，游戏结束后老师会根据每个孩子的表现进行评分并给予糖果奖励。

## 题目描述

每个孩子只能看见与自己相邻的 $2$ 个孩子（左边的和右边的）的情况，只会关心相邻的且比自己评分低的同学的糖果数（如果相邻 $2$ 个孩子的评分相等，则不关心）。为保证公平，相邻的孩子中，评分高的孩子必须获得更多的糖果(如果左右相邻 $2$ 个孩子的评分相等，则不关心，即分最少的糖果 $1$ 个）。同时，为鼓励孩子的积极性，每个孩子至少都能拿到 $1$ 个糖果。现在需要你帮助老师来分发糖果，问怎么分配才能使要准备的糖果数最少？计算出需要的最少糖果数。

## 说明/提示

【数据范围】

对于 $40\%$ 的数据，$1\leq n\leq 100$；

对于 $100\%$ 的数据，$1\leq n\leq 10^5$;

所有评分都是 $0$ 到 $100$ 之间的一个整数。

【样例解释】

样例一，分别分配 $2,3,1$ 的糖果，所以最少需要 $6$ 个糖果。

样例二，分别分配 $1,2,1,2$ 的糖果，所以最少需要 $6$ 个糖果。

## 样例 #1

### 输入

```
3
1 2 0```

### 输出

```
6```

## 样例 #2

### 输入

```
4
2 3 3 3```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地分配糖果，满足相邻孩子中评分高的孩子获得更多糖果的条件，同时使总糖果数最小。所有题解的基本思路都是先给每个孩子分配1个糖果，然后通过多次遍历调整糖果数，直到满足条件。难点在于如何避免无限循环，并确保每次调整都能有效减少不满足条件的情况。

### 所选高星题解

#### 1. 作者：SkyLines (★★★★★)
**关键亮点**：
- 思路清晰，代码简洁，逻辑严谨。
- 通过循环遍历调整糖果数，直到没有需要调整的情况为止。
- 使用`flg`变量标记是否进行了调整，避免了无限循环。

**核心代码**：
```cpp
while(1){
    flg = 0;
    for(int i = 1; i <= n; i++){
        j = ((i == n) ? 1 : (i + 1));
        if(a[i] < a[j] && cnt[i] >= cnt[j]){
            cnt[j] = cnt[i] + 1;
            flg = 1;
        }else if(a[i] > a[j] && cnt[j] >= cnt[i]){
            cnt[i] = cnt[j] + 1;
            flg = 1;
        }
    }
    if(!flg) break;
}
```
**核心思想**：通过循环遍历所有孩子，检查并调整糖果数，直到没有需要调整的情况。

#### 2. 作者：CASCwty (★★★★)
**关键亮点**：
- 思路清晰，代码结构合理。
- 使用`flag`变量标记是否进行了调整，避免了无限循环。
- 详细解释了为什么不会出现无限循环的情况。

**核心代码**：
```cpp
while(flag){
    flag=false;
    for(int i=1;i<=n;i++){
        nxt=(i==n)?1:i+1;
        if(a[i]<a[nxt]&&candy[i]>=candy[nxt]){
            candy[nxt]=candy[i]+1;
            flag=true;
        }else if(a[i]>a[nxt]&&candy[i]<=candy[nxt]){
            candy[i]=candy[nxt]+1;
            flag=true;
        }
    }
}
```
**核心思想**：通过循环遍历所有孩子，检查并调整糖果数，直到没有需要调整的情况。

#### 3. 作者：yyycj (★★★★)
**关键亮点**：
- 思路清晰，代码结构合理。
- 使用`cnt`变量记录不满足条件的次数，避免了无限循环。
- 详细解释了为什么不会出现无限循环的情况。

**核心代码**：
```cpp
while (cnt) {
    cnt = 0;
    for (int i=1;i<=n;i++) {
        int r = i % n + 1;
        if (score[i]>score[r] && candy[i]<=candy[r]) {
            candy[i] = candy[r] + 1;
            cnt++;
        }
        else if (score[i]<score[r] && candy[i]>=candy[r]) {
            candy[r] = candy[i] + 1;
            cnt++;
        }
    }
}
```
**核心思想**：通过循环遍历所有孩子，检查并调整糖果数，直到没有需要调整的情况。

### 最优关键思路或技巧

1. **初始化与调整**：首先给每个孩子分配1个糖果，然后通过多次遍历调整糖果数，直到满足条件。
2. **避免无限循环**：使用标记变量（如`flg`、`flag`、`cnt`）来记录是否进行了调整，避免无限循环。
3. **最小化糖果数**：每次调整只增加必要的糖果数，确保总糖果数最小。

### 可拓展之处

- **类似问题**：可以扩展到其他需要满足相邻元素条件的分配问题，如分配资源、任务调度等。
- **优化思路**：可以考虑使用更高效的算法，如贪心算法或动态规划，进一步优化时间复杂度。

### 推荐题目

1. **P1045 糖果分配**：类似的分糖果问题，要求满足相邻孩子糖果数的条件。
2. **P1046 任务调度**：任务分配问题，要求满足相邻任务的资源分配条件。
3. **P1047 资源分配**：资源分配问题，要求满足相邻资源的分配条件。

### 个人心得摘录

- **调试经历**：在调整糖果数时，需要特别注意循环的终止条件，避免无限循环。
- **踩坑教训**：在处理环形结构时，需要特别注意首尾元素的处理，确保逻辑正确。
- **顿悟感想**：通过多次遍历调整糖果数，可以逐步逼近最优解，确保总糖果数最小。

---
处理用时：38.61秒
# 题目信息

# [NOIP 1999 普及组] 回文数

## 题目描述

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。

又如：对于十进制数 $87$：

STEP1：$87+78=165$  
STEP2：$165+561=726$  
STEP3：$726+627=1353$   
STEP4：$1353+3531=4884$  

在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。

写一个程序，给定一个 $N$（$2 \le N \le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。

## 样例 #1

### 输入

```
10
87
```

### 输出

```
STEP=4
```

# AI分析结果

### 综合分析与结论

本题的核心在于处理N进制的高精度加法，并判断是否能在30步内得到回文数。题解中，大部分作者采用了高精度加法的思路，并通过模拟N进制加法来实现。难点主要在于如何处理16进制的字符转换、高精度加法的进位处理以及回文数的判断。部分题解通过模块化编程、STL的使用等技巧简化了代码，提升了可读性和效率。

### 精选题解

#### 1. 作者：Haishu (5星)
**关键亮点**：
- 模块化编程，将回文判断和加法操作分别封装成函数，提升了代码的可读性和复用性。
- 高精度加法的实现简洁，通过数组存储数字，避免了字符串操作的复杂性。
- 对16进制的处理通过简单的字符转换实现，代码清晰易懂。

**个人心得**：
作者在题解中提到，曾经因为忽视数据范围而使用了不合适的解法，后来通过反思和重写题解，强调了模块化编程的重要性。这种经验对初学者非常有帮助。

**核心代码**：
```cpp
inline void add() {
    for (int i=0;i<l;++i) d[l-i-1]=c[i];
    l+=2; // 可能有进位，先多空两位
    for (int i=0;i<l;++i) {
        c[i]+=d[i];
        if (c[i]>=n) c[i+1]++, c[i]-=n;
    }
    while (!c[l-1]) --l; // 去除前导0
}
```

#### 2. 作者：Strong_Jelly (4.5星)
**关键亮点**：
- 通过高精度加法的扩展，直接处理N进制加法，避免了进制转换的复杂性。
- 回文判断和反转操作分别封装成函数，代码结构清晰。
- 对16进制的处理通过字符转换实现，代码简洁。

**核心代码**：
```cpp
void add(int a[], int b[]) {
    for(int i = 1; i <= l; i++) {
        a[i] += b[i];
        a[i + 1] += a[i] / n; // 进位
        a[i] %= n;
    }
    if(a[l + 1] > 0) l++; // 最高位进位
}
```

#### 3. 作者：hawa130 (4星)
**关键亮点**：
- 使用STL的`reverse`函数简化了回文判断和字符串反转操作。
- 高精度加法的实现通过字符数组处理，代码简洁。
- 对16进制的处理通过字符转换实现，代码清晰。

**核心代码**：
```cpp
string add(int k, string b) {
    string a = b;
    reverse(a.begin(), a.end());
    int numa[maxN], numb[maxN], numc[maxN];
    int len = a.length(), lenc = 1;
    string ans;
    for (int i=0; i<len; i++) {
        if (isdigit(a[i])) numa[len-i] = a[i] - '0';
        else numa[len-i] = a[i] - 'A' + 10;
        if (isdigit(b[i])) numb[len-i] = b[i] - '0';
        else numb[len-i] = b[i] - 'A' + 10;
    }
    int x = 0;
    while (lenc <= len) {
        numc[lenc] = numa[lenc] + numb[lenc] + x;
        x = numc[lenc] / k; // 进位
        numc[lenc] %= k;
        lenc++;
    }
    numc[lenc] = x;
    while (numc[lenc] == 0) lenc--;
    for (int i=lenc; i>=1; i--) ans += sixt[numc[i]];
    return ans;
}
```

### 最优关键思路与技巧

1. **模块化编程**：将回文判断、加法操作等分别封装成函数，提升代码的可读性和复用性。
2. **高精度加法的N进制扩展**：通过数组存储数字，直接处理N进制加法，避免了复杂的进制转换。
3. **STL的使用**：利用`reverse`等STL函数简化字符串操作，提升代码效率。
4. **字符转换处理16进制**：通过简单的字符转换处理16进制的A-F，代码简洁易懂。

### 拓展思路

本题可以拓展到更高进制的处理，或者更复杂的回文数生成问题。类似的题目可以考察高精度乘法、除法等操作，或者更复杂的进制转换问题。

### 推荐题目

1. **P1005 矩阵取数游戏**：考察高精度加法和模块化编程。
2. **P1010 幂次方**：涉及进制转换和高精度运算。
3. **P1012 拼数**：考察字符串处理和高精度比较。

### 个人心得总结

- **调试经验**：部分作者提到在调试过程中发现进制转换或字符处理的错误，强调了测试数据的重要性。
- **顿悟感想**：通过模块化编程和STL的使用，代码的简洁性和可读性得到了显著提升，这种思维方式值得借鉴。

---
处理用时：44.76秒
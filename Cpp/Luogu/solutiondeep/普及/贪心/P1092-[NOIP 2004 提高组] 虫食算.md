# 题目信息

# [NOIP 2004 提高组] 虫食算

## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：

$$\begin{aligned}
 \verb!43#9865#045! \\
+\qquad \verb!8468#6633! \\[-1em]\underline{\kern{8em}} \\
 \verb!44445509678! \\
\end{aligned}$$

其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。

$$\begin{aligned}
 \verb!BADC! \\
+\quad \verb!CBDA! \\[-1em]\underline{\kern{4em}} \\
 \verb!DCCC! \\
\end{aligned}$$

上面的算式是一个4进制的算式。很显然，我们只要让 $\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 10$；
- 对于 $50\%$ 的数据，保证 $n \le 15$；
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 26$。

## 样例 #1

### 输入

```
5
ABCED
BDACE
EBBAA
```

### 输出

```
1 0 3 4 2
```

# AI分析结果

### 综合分析与结论

本题的核心是通过搜索算法解决虫食算问题，难点在于如何高效剪枝以避免超时。大部分题解采用了深度优先搜索（DFS）结合剪枝的策略，部分题解还引入了高斯消元等数学方法。以下是关键思路和技巧的总结：

1. **搜索顺序优化**：从右往左搜索，模拟竖式加法的计算过程，能够有效减少进位带来的复杂性。
2. **剪枝策略**：
   - 最高位不能有进位，否则直接剪枝。
   - 如果某一位的三个字母都已赋值，且无论是否进位都不满足等式，直接剪枝。
   - 通过提前判断某些位的合法性，减少不必要的搜索。
3. **优化搜索顺序**：从大数往小数搜索，能够更快地找到合法解。
4. **高斯消元**：部分题解通过高斯消元法将问题转化为方程组求解，但实现较为复杂，适合对数学有深入理解的同学。

### 精选题解

#### 1. 题解作者：zzlzk
- **星级**：★★★★★
- **关键亮点**：
  - 详细解释了从右往左搜索的思路，并提供了清晰的剪枝策略。
  - 代码结构清晰，注释详细，易于理解。
  - 通过提前判断某些位的合法性，减少了搜索的复杂度。
- **个人心得**：作者提到“搜索的大体思路就是从第1位的值开始搜，搜到最后一位，判断是否合法”，强调了搜索顺序的重要性。

#### 2. 题解作者：✌yww
- **星级**：★★★★☆
- **关键亮点**：
  - 采用了从右往左、从上往下的搜索顺序，并结合了进位判断。
  - 通过剪枝减少了不必要的搜索，代码效率较高。
  - 代码简洁，逻辑清晰。
- **个人心得**：作者提到“从右往左，从上往下搜索，所有从第n列，第1行开始”，强调了搜索顺序和剪枝的结合。

#### 3. 题解作者：Mihari
- **星级**：★★★★☆
- **关键亮点**：
  - 详细解释了从右往左搜索的思路，并提供了多种剪枝策略。
  - 代码结构清晰，注释详细，易于理解。
  - 通过提前判断某些位的合法性，减少了搜索的复杂度。
- **个人心得**：作者提到“从右往左，上往下搜索，所有从第n列，第1行开始”，强调了搜索顺序和剪枝的结合。

### 关键思路与技巧

1. **搜索顺序**：从右往左搜索，模拟竖式加法的计算过程，能够有效减少进位带来的复杂性。
2. **剪枝策略**：
   - 最高位不能有进位，否则直接剪枝。
   - 如果某一位的三个字母都已赋值，且无论是否进位都不满足等式，直接剪枝。
3. **优化搜索顺序**：从大数往小数搜索，能够更快地找到合法解。

### 拓展思路

1. **高斯消元**：对于更复杂的虫食算问题，可以考虑使用高斯消元法将问题转化为方程组求解。
2. **启发式搜索**：结合启发式搜索算法（如A*算法）可以进一步优化搜索效率。

### 推荐题目

1. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074) - 考察搜索与剪枝的结合。
2. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120) - 考察深度优先搜索与剪枝的应用。
3. [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379) - 考察搜索算法与状态空间的处理。

### 核心代码片段

```cpp
void dfs(int x, int y, int t) {
    if (x == 0) {
        if (t == 0) {
            for (int i = 1; i < n; i++) printf("%d ", flag[i]);
            printf("%d\n", flag[n]);
            exit(0);
        }
        return;
    }
    for (int i = x - 1; i >= 1; i--) {
        int w1 = flag[id(s[1][i])], w2 = flag[id(s[2][i])], w3 = flag[id(s[3][i])];
        if (w1 == -1 || w2 == -1 || w3 == -1) continue;
        if ((w1 + w2) % n != w3 && (w1 + w2 + 1) % n != w3) return;
    }
    if (flag[id(s[y][x])] == -1) {
        for (int i = n - 1; i >= 0; i--) {
            if (!use[i]) {
                flag[id(s[y][x])] = i;
                use[i] = 1;
                dfs(x, y + 1, t);
                flag[id(s[y][x])] = -1;
                use[i] = 0;
            }
        }
    } else {
        dfs(x, y + 1, t);
    }
}
```

这段代码展示了从右往左搜索的核心逻辑，结合了剪枝和进位判断，确保了搜索的高效性。

---
处理用时：58.92秒
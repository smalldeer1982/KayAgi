# 题目信息

# [NOIP 2007 普及组] 守望者的逃离

## 题目背景

NOIP2007 普及组 T3

## 题目描述

恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。

守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。

为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。

守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。

现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。

注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。


## 说明/提示

对于 $30\%$ 的数据，$1  \le  T   \le  10$，$ 1   \le   S   \le  100$；

对于 $50\%$ 的数据，$1   \le  T   \le   10^3$，$ 1   \le  S  \le   10^4$；

对于 $100\%$ 的数据，$1   \le   T   \le   3\times  10^5$，$0   \le   M   \le   10^3$，$ 1   \le  S   \le   10^8$。


## 样例 #1

### 输入

```
39 200 4
```

### 输出

```
No
197
```

## 样例 #2

### 输入

```
36 255 10```

### 输出

```
Yes
6```

# AI分析结果

### 综合分析与结论

这些题解主要围绕贪心算法和动态规划展开，核心思路是通过模拟守望者的移动策略（闪烁、跑步、恢复魔法值）来求解最短逃离时间或最远距离。大部分题解都采用了类似的策略：优先使用闪烁法术，魔法值不足时恢复魔法值或跑步。部分题解通过维护两个变量（跑步距离和闪烁距离）来优化决策，确保在每一步选择最优策略。

### 评分较高的题解

#### 1. 作者：wzr1125 (赞：15)
- **星级**：★★★★★
- **关键亮点**：通过维护两个变量 `fla` 和 `run`，分别表示闪烁和跑步的距离，并在每一步更新 `run` 为 `max(run, fla)`，确保在闪烁的基础上继续跑步。这种思路简洁且高效，避免了复杂的条件判断。
- **核心代码**：
  ```cpp
  for(int i=1;i<=t;i++){
      if(m>=10) m-=10,fla+=60,run+=17;
      else m+=4,run+=17;
      if(fla>run) run=fla;
      if(max(fla,run)>=s){
          printf("Yes\n%d\n",i);return 0;}
  }
  cout<<"No"<<endl<<max(fla,run)<<endl;
  ```

#### 2. 作者：qhr2023 (赞：2)
- **星级**：★★★★
- **关键亮点**：使用动态规划和贪心结合的策略，通过维护两个状态 `s1` 和 `s2`，分别表示跑步和闪烁的距离，并在每一步更新 `s1` 为 `max(s1+17, s2)`。这种思路清晰且易于理解。
- **核心代码**：
  ```cpp
  for(int i=1; i<=t; i++){
      m>=10?m-=10,s2+=60:m+=4; 
      s1=max(s1+17, s2);
      if(s1>s){
          cout << "Yes\n" << i;
          return 0;
      }
  }
  cout << "No\n" << s1;
  ```

#### 3. 作者：Loyal_Soldier (赞：1)
- **星级**：★★★★
- **关键亮点**：通过维护两个变量 `now1` 和 `now2`，分别表示跑步和闪烁的距离，并在每一步更新 `now1` 为 `max(now1+17, now2)`。这种思路简单且有效，代码可读性强。
- **核心代码**：
  ```cpp
  for(int i=1;i<=t;i++){
      if(m>=10) now2+=60,m-=10;
      else m+=4;
      now1=max(now1+17,now2);
      if(now1>=s){
          cout<<"Yes"<<endl<<i;
          return 0;
      }
  }
  cout<<"No"<<endl<<now1;
  ```

### 最优关键思路与技巧

1. **贪心策略**：优先使用闪烁法术，因为其速度远快于跑步。魔法值不足时，恢复魔法值或跑步。
2. **双变量维护**：通过维护两个变量（跑步距离和闪烁距离），在每一步更新跑步距离为 `max(跑步距离, 闪烁距离)`，确保在闪烁的基础上继续跑步。
3. **动态规划**：部分题解通过动态规划记录每一步的最优距离，确保在每一步选择最优策略。

### 可拓展之处

- **类似算法套路**：这种贪心+动态规划的策略可以应用于其他需要决策最优路径或最优资源分配的问题，如背包问题、任务调度等。
- **同类型题目**：可以考虑以下洛谷题目：
  1. P1048 [NOIP2005 普及组] 采药（动态规划）
  2. P1060 [NOIP2006 普及组] 开心的金明（动态规划）
  3. P1091 [NOIP2004 提高组] 合唱队形（动态规划）

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现某些条件判断不够严谨，导致WA（Wrong Answer），通过增加条件判断或优化策略后AC（Accepted）。
- **顿悟感想**：通过维护两个变量来分别记录跑步和闪烁的距离，可以简化决策过程，避免复杂的条件判断，提高代码的可读性和效率。

---
处理用时：41.65秒
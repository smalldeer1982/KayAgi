# 题目信息

# 小木棍

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。

现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。

给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。


## 说明/提示

对于全部测试点，$1 \leq n \leq 65$，$1 \leq a_i \leq 50$。

## 样例 #1

### 输入

```
9
5 2 1 5 2 1 5 2 1
```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

本题的核心是通过DFS搜索原始木棍的最小可能长度，难点在于如何通过剪枝优化搜索过程，避免超时。大部分题解都采用了类似的思路：枚举可能的原始木棍长度，并通过DFS尝试拼接。剪枝策略主要包括：

1. **长度枚举优化**：原始木棍长度必须能被所有小木棍的总长度整除，且长度范围在最大木棍长度到总长度的一半之间。
2. **排序优化**：将木棍从大到小排序，优先使用较长的木棍，减少搜索空间。
3. **重复剪枝**：如果当前木棍无法拼接成功，跳过与其长度相同的木棍。
4. **剩余长度剪枝**：如果剩余长度无法通过剩余木棍拼接成功，直接回溯。
5. **拼接失败剪枝**：如果当前木棍拼接失败且剩余长度等于当前木棍长度或原始长度，直接回溯。

### 精选题解

#### 题解1：Kaori (5星)
**关键亮点**：
- 详细解释了剪枝策略，尤其是“当前长棍剩余的未拼长度等于当前木棍的长度或原始长度”时的剪枝。
- 代码结构清晰，注释详细，便于理解。
- 提供了多个优化点，包括预处理、二分查找等。

**个人心得**：
- 强调了搜索题中每招优化的重要性，尤其是竞赛中的时间优化。

**核心代码**：
```cpp
void dfs(int k, int last, int rest) {
    if (!rest) {
        if (k == m) { ok = 1; return; }
        for (int i = 1; i <= cnt; i++) 
            if (!used[i]) break;
        used[i] = 1; 
        dfs(k + 1, i, len - a[i]);
        used[i] = 0;
        if (ok) return;
    }
    int l = last + 1, r = cnt, mid;
    while (l < r) {
        mid = (l + r) >> 1;
        if (a[mid] <= rest) r = mid;
        else l = mid + 1;
    }
    for (int i = l; i <= cnt; i++) {
        if (!used[i]) {
            used[i] = 1;
            dfs(k, i, rest - a[i]);
            used[i] = 0;
            if (ok) return;
            if (rest == a[i] || rest == len) return;
            i = next[i];
            if (i == cnt) return;
        }
    }
}
```

#### 题解2：林则徐 (4星)
**关键亮点**：
- 使用了桶排序来存储木棍长度，减少了排序的时间复杂度。
- 剪枝策略简洁有效，尤其是“若某组拼接不成立，且此时已拼接的长度为0或当前已拼接的长度与刚才枚举的长度之和为最终枚举的答案时，直接跳出循环”。

**核心代码**：
```cpp
void dfs(int res, int sum, int target, int p) {
    if (res == 0) {
        printf("%d", target);
        exit(0);
    }
    if (sum == target) {
        dfs(res - 1, 0, target, maxn);
        return;
    }
    for (int i = p; i >= minn; i--) {
        if (tm[i] && i + sum <= target) {
            tm[i]--;
            dfs(res, sum + i, target, i);
            tm[i]++;
            if (sum == 0 || sum + i == target) break;
        }
    }
}
```

#### 题解3：NoyException (4星)
**关键亮点**：
- 强调了剪枝的顺序和重要性，尤其是“从最长的木棍开始选择，逐一递减”。
- 提供了详细的剪枝解释，尤其是“如果已经拼凑好了所有的木棍，则直接输出当前枚举的原先木棍长度并结束程序”。

**核心代码**：
```cpp
bool perm(int pre, int fromp) {
    if (pre % len == 0) {
        if (sum - pre == len) return true;
        for (int i = 2; i <= end && vis[i]; i++);
        vis[i] = true;
        if (perm(pre + line[i], 2)) return true;
        vis[i] = false;
    }
    for (; fromp <= end; fromp++) {
        if (!vis[fromp]) {
            if (pre % len + line[fromp] <= len) {
                vis[fromp] = true;
                if (perm(pre + line[fromp], fromp)) return true;
                vis[fromp] = false;
                if (pre % len + line[fromp] == len) return false;
            }
            fromp = nxt[line[fromp]];
        }
    }
    return false;
}
```

### 最优关键思路与技巧

1. **枚举优化**：原始木棍长度必须能被总长度整除，且长度范围在最大木棍长度到总长度的一半之间。
2. **排序优化**：将木棍从大到小排序，优先使用较长的木棍，减少搜索空间。
3. **剪枝策略**：包括重复剪枝、剩余长度剪枝、拼接失败剪枝等，避免无效搜索。

### 推荐题目

1. **P1120 小木棍 ［数据加强版］**（本题）
2. **P1092 虫食算**（DFS+剪枝）
3. **P1074 靶形数独**（DFS+剪枝）

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中发现剪枝的重要性，尤其是如何通过优化减少搜索空间。
- **踩坑教训**：部分作者提到在实现过程中忽略了某些剪枝条件，导致超时或错误。
- **顿悟感想**：通过反复调试和优化，逐渐理解了DFS剪枝的精髓，尤其是在竞赛中每招优化的重要性。

---
处理用时：58.10秒
# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果

### 综合分析与结论

该题目要求在有向无环图（DAG）中，为每个城市找到以该城市为终点的最长路径。题解中主要采用了拓扑排序和动态规划（DP）的结合，部分题解还使用了记忆化搜索。拓扑排序确保了在计算每个节点的最长路径时，其前驱节点的路径已经计算完毕，满足了DP的无后效性要求。记忆化搜索则通过递归的方式，避免了重复计算，提高了效率。

### 所选高质量题解

#### 1. **作者：星星之火 (5星)**
   - **关键亮点**：详细解释了拓扑排序与DP的结合原理，强调了拓扑排序的无后效性，代码清晰且注释详细。
   - **个人心得**：强调了拓扑排序的性质，帮助读者理解为什么拓扑排序可以用于DP，避免了无后效性的破坏。
   - **核心代码**：
     ```cpp
     void topsort() {
         queue<int> q;
         for (int i = 1; i <= n; i++)
             if (ru[i] == 0) q.push(i);
         while (!q.empty()) {
             int u = q.front(); q.pop();
             for (int i = head[u]; i; i = edge[i].next) {
                 int v = edge[i].to;
                 ru[v]--;
                 if (ru[v] == 0) q.push(v);
             }
         }
     }
     ```

#### 2. **作者：_ZZH (4星)**
   - **关键亮点**：简洁明了，直接在拓扑排序过程中进行DP，减少了代码量，思路清晰。
   - **核心代码**：
     ```cpp
     while (!q.empty()) {
         int cnt = q.front(); q.pop();
         for (int i = lin[cnt]; i; i = e[i].next) {
             f[e[i].to] = max(f[e[i].to], f[cnt] + 1);
             if (--in[e[i].to] == 0) q.push(e[i].to);
         }
     }
     ```

#### 3. **作者：归山_ (4星)**
   - **关键亮点**：采用反向建图和记忆化搜索，思路新颖，代码简洁。
   - **核心代码**：
     ```cpp
     int dfs(int x) {
         if (dp[x] != -1) return dp[x];
         dp[x] = 1;
         for (int i = head[x]; i; i = e[i].next) {
             int y = e[i].to;
             dp[x] = max(dp[x], dfs(y) + 1);
         }
         return dp[x];
     }
     ```

### 最优关键思路与技巧

1. **拓扑排序与DP结合**：拓扑排序确保了DP的无后效性，使得在计算每个节点的最长路径时，其前驱节点的路径已经计算完毕。
2. **记忆化搜索**：通过递归和缓存结果，避免了重复计算，提高了效率。
3. **反向建图**：在记忆化搜索中，反向建图可以简化递归过程，使得从终点出发的路径计算更加直观。

### 可拓展之处

- **同类型题目**：类似的问题可以扩展到其他DAG上的最长路径问题，如任务调度、依赖关系等。
- **算法套路**：拓扑排序与DP的结合可以用于解决其他具有依赖关系的动态规划问题，如关键路径、任务调度等。

### 推荐题目

1. **P1113 杂务**：考察拓扑排序与DP的结合，类似任务调度问题。
2. **P2014 选课**：树形DP与拓扑排序的结合，考察依赖关系的最优解。
3. **P3379 【模板】最近公共祖先（LCA）**：虽然主要考察LCA，但涉及树的结构与路径问题，与本题有一定的相似性。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中发现入度为0的节点不止一个，提醒读者在编写代码时要考虑边界情况。
- **顿悟感想**：通过拓扑排序与DP的结合，可以有效地解决DAG上的最长路径问题，强调了算法设计中的无后效性原则。

---
处理用时：38.05秒
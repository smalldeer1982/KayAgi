# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

### 综合分析与结论

本题的核心是求解无向无权图中从起点到其他各点的最短路数量。由于边权相同，BFS是最直观且高效的选择，能够保证在O(N+M)的时间复杂度内完成。此外，SPFA和Dijkstra也可以解决该问题，但由于边权相同，BFS更为简洁高效。

题解中，大部分作者采用了BFS或SPFA，部分使用了Dijkstra。BFS的优势在于其分层遍历的特性，能够直接计算出最短路径，并在此基础上进行计数。SPFA和Dijkstra虽然也能解决问题，但在本题中显得冗余，尤其是Dijkstra的堆优化版本，时间复杂度较高。

### 所选高质量题解

#### 1. **作者：岸芷汀兰 (5星)**
- **关键亮点**：使用BFS进行最短路计算，思路清晰，代码简洁。通过分层遍历，直接计算最短路径数量，避免了复杂的松弛操作。代码中使用了`vector`存储邻接表，结构清晰，易于理解。
- **个人心得**：作者强调了BFS的适用性，指出在无权图中，BFS是最佳选择，避免了SPFA和Dijkstra的冗余操作。
- **核心代码**：
  ```cpp
  void bfs() {
      queue<Node> q; q.push(make(1, 0));
      memset(d, 0x3f, sizeof(d)); d[1] = 0;
      vis[1] = true; ans[1] = 1;
      while (q.size()) {
          int u = q.front().node, dis = q.front().dis; q.pop();
          for (int i = 0; i < linker[u].size(); i++) {
              int v = linker[u][i];
              if (!vis[v]) {
                  q.push(make(v, dis + 1)); vis[v] = true; d[v] = dis + 1;
                  ans[v] += ans[u]; ans[v] %= mod;
              } else if (dis + 1 == d[v]) {
                  ans[v] += ans[u]; ans[v] %= mod;
              }
          }
      }
  }
  ```

#### 2. **作者：神之右大臣 (4星)**
- **关键亮点**：使用BFS进行最短路计算，并通过`deep`数组记录深度，`ans`数组记录最短路径数量。代码结构清晰，逻辑严谨，适合初学者理解。
- **个人心得**：作者提到BFS的分层特性可以直接用于计算最短路径，避免了复杂的松弛操作，代码实现简洁。
- **核心代码**：
  ```cpp
  void bfs() {
      queue<int> q; q.push(1);
      vis[1] = 1; deep[1] = 0; ans[1] = 1;
      while (!q.empty()) {
          int u = q.front(); q.pop();
          for (int i = 0; i < vt[u].size(); i++) {
              int v = vt[u][i];
              if (!vis[v]) {
                  vis[v] = 1; deep[v] = deep[u] + 1;
                  ans[v] = ans[u]; q.push(v);
              } else if (deep[v] == deep[u] + 1) {
                  ans[v] = (ans[v] + ans[u]) % mod;
              }
          }
      }
  }
  ```

#### 3. **作者：XZYQvQ (4星)**
- **关键亮点**：使用SPFA进行最短路计算，并通过记忆化搜索统计最短路数量。虽然SPFA在本题中略显冗余，但作者通过记忆化搜索优化了计数过程，代码实现较为巧妙。
- **个人心得**：作者提到SPFA在某些情况下可能会出现问题，因此采用了记忆化搜索来确保正确性。
- **核心代码**：
  ```cpp
  int dfs(int u) {
      if (ans[u]) return ans[u];
      for (int i = head[u]; i != -1; i = nxt[i]) {
          int v = to[i];
          if (dis[u] - 1 == dis[v]) ans[u] = (ans[u] + dfs(v)) % mod;
      }
      return ans[u];
  }
  ```

### 最优关键思路与技巧
1. **BFS分层遍历**：在无权图中，BFS的分层遍历特性可以直接用于计算最短路径，避免了复杂的松弛操作。
2. **计数优化**：通过`ans`数组记录最短路径数量，并在遍历时进行累加，确保计数的正确性。
3. **记忆化搜索**：在SPFA中，通过记忆化搜索优化计数过程，避免重复计算。

### 拓展思路
- **带权图的最短路计数**：如果边权不同，可以使用Dijkstra或SPFA，并在松弛操作中进行计数。
- **多源最短路计数**：可以通过Floyd算法或多次BFS/Dijkstra来计算多源最短路数量。

### 推荐题目
1. **P1608 路径统计**：带权图的最短路计数，适合练习Dijkstra或SPFA的计数优化。
2. **P4779 单源最短路径（标准版）**：Dijkstra的模板题，适合练习堆优化Dijkstra。
3. **P3371 单源最短路径（弱化版）**：SPFA的模板题，适合练习SPFA的实现与优化。

---
处理用时：52.98秒
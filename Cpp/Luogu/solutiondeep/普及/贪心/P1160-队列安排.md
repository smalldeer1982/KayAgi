# 题目信息

# 队列安排

## 题目描述

一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：

1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；

2. $2\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；

3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。

在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。

## 说明/提示

**【样例解释】**

将同学 $2$ 插入至同学 $1$ 左边，此时队列为：

`2 1`

将同学 $3$ 插入至同学 $2$ 右边，此时队列为：

`2 3 1`  

将同学 $4$ 插入至同学 $1$ 左边，此时队列为：

`2 3 4 1`  

将同学 $3$ 从队列中移出，此时队列为：

`2 4 1`  

同学 $3$ 已经不在队列中，忽略最后一条指令

最终队列：

`2 4 1`  

**【数据范围】**

对于 $20\%$ 的数据，$1\leq N\leq 10$。

对于 $40\%$ 的数据，$1\leq N\leq 1000$。

对于 $100\%$ 的数据，$1<M\leq N\leq 10^5$。


## 样例 #1

### 输入

```
4
1 0
2 1
1 0
2
3
3```

### 输出

```
2 4 1```

# AI分析结果

### 综合分析与结论

本题的核心是通过双向链表或数组模拟链表来处理频繁的插入和删除操作。大多数题解都采用了双向链表或数组模拟链表的方式，思路较为一致，但在实现细节和优化上有所不同。部分题解通过引入哨兵节点（如0号节点）来简化边界条件的处理，还有一些题解通过标记删除节点来避免重复删除操作。整体来看，题解的质量参差不齐，部分题解代码冗长且不够清晰，而少数题解则通过简洁的代码和清晰的思路脱颖而出。

### 所选高星题解

#### 1. **题解作者：BT狸——Frozen (赞：506)**
- **星级：5星**
- **关键亮点**：
  - 使用结构体模拟双向链表，代码简洁且易于理解。
  - 通过引入0号节点作为哨兵，简化了链表头尾的处理。
  - 使用标记数组来记录删除的节点，避免了重复删除操作。
  - 详细解释了每一步的操作，适合初学者理解。
- **个人心得**：
  - 作者提到最初尝试用数组模拟链表，但发现效率低下，最终选择了双向链表，体现了对问题的深入思考和优化过程。

```cpp
struct T{
    int l,r;        //每个同学的“左右手” 
    int d;          //表示同学是否输出 
}t[mx]={0};

void add(int i,int k,int f) {
    if(f==1) { //右 
        t[k].r=t[i].r;
        t[k].l=i; 
        t[i].r=k;
        t[t[k].r].l=k;
    } else { //左
        t[k].r=i;
        t[k].l=t[i].l;
        t[i].l=k;
        t[t[k].l].r=k;
    }
}
```

#### 2. **题解作者：Orina_zju (赞：259)**
- **星级：4.5星**
- **关键亮点**：
  - 使用C++ STL中的`std::list`实现双向链表，代码简洁且高效。
  - 通过迭代器操作实现插入和删除，避免了手动管理指针的复杂性。
  - 详细解释了STL的使用方法，适合有一定C++基础的读者。
- **个人心得**：
  - 作者提到STL在开O2优化后运行速度非常快，体现了对STL的熟练使用和优化意识。

```cpp
#include <list>
using namespace std;

list<int> queList;
bool erased[maxN];

void buildQueue() {
    queList.push_front(1);
    pos[1] = queList.begin();
    for (int i = 2; i <= N; i++) {
        int k, p;
        scanf("%d%d", &k, &p);
        if (p == 0) {
            pos[i] = queList.insert(pos[k], i); //left
        } else {
            auto nextIter = next(pos[k]);
            pos[i] = queList.insert(nextIter, i); //right
        }
    }
}
```

#### 3. **题解作者：夜刀神十香ღ (赞：165)**
- **星级：4星**
- **关键亮点**：
  - 使用数组模拟双向链表，代码简洁且易于理解。
  - 通过标记删除节点来避免重复删除操作，提高了效率。
  - 详细解释了每一步的操作，适合初学者理解。
- **个人心得**：
  - 作者提到通过手动模拟链表操作来理解插入和删除的过程，体现了对链表的深入理解。

```cpp
int a[100010][3],n,m;

void add(int i, int k, int f) {
    if(f == 0) {
        a[a[k][0]][1] = i;
        a[i][0] = a[k][0];
        a[i][1] = k;
        a[k][0] = i;
    } else {
        a[a[k][1]][0] = i;
        a[i][1] = a[k][1];
        a[i][0] = k;
        a[k][1] = i;
    }
}
```

### 最优关键思路与技巧

1. **双向链表与数组模拟**：双向链表或数组模拟链表是解决频繁插入和删除问题的经典方法，通过维护每个节点的左右指针，可以高效地进行插入和删除操作。
2. **哨兵节点**：引入哨兵节点（如0号节点）可以简化链表头尾的处理，避免复杂的边界条件判断。
3. **标记删除**：通过标记删除节点而不是真正删除，可以避免重复删除操作，提高代码的简洁性和效率。
4. **STL的使用**：对于C++用户，使用STL中的`std::list`可以简化代码，减少手动管理指针的复杂性。

### 可拓展之处

- **同类型题**：类似的问题包括处理频繁插入和删除的队列、栈等数据结构，如洛谷P1160、P1449等。
- **算法套路**：双向链表和数组模拟链表的技巧可以应用于其他需要频繁插入和删除的场景，如动态维护序列、LRU缓存等。

### 推荐题目

1. **洛谷P1160** - 队列安排：与本题类似，考察双向链表的插入和删除操作。
2. **洛谷P1449** - 后缀表达式：考察栈的应用，与链表的操作有相似之处。
3. **洛谷P3378** - 堆：考察堆的实现，与链表的操作有相似之处。

---
处理用时：55.68秒
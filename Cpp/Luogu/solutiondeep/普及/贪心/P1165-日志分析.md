# 题目信息

# 日志分析

## 题目描述

M 海运公司最近要对旗下仓库的货物进出情况进行统计。目前他们所拥有的唯一记录就是一个记录集装箱进出情况的日志。该日志记录了两类操作：第一类操作为集装箱入库操作，以及该次入库的集装箱重量；第二类操作为集装箱的出库操作。这些记录都严格按时间顺序排列。集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为当前在仓库里所有集装箱中最晚入库的集装箱。

出于分析目的，分析人员在日志中随机插入了若干第三类操作――查询操作。分析日志时，每遇到一次查询操作，都要报告出当前仓库中最大集装箱的重量。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，有 $N \le 10$；
- 对于 $40\%$ 的数据，有 $N \le 1000$；
- 对于 $100\%$ 的数据，有 $1 \le N \le 200000$，$1 \le X \le 10^8$。


## 样例 #1

### 输入

```
13
0 1
0 2
2
0 4
0 2
2
1
2
1
1
2
1
2
```

### 输出

```
2
4
4
1
0
```

# AI分析结果

### 综合分析与结论

该题目要求模拟栈的入栈、出栈操作，并在查询时快速返回当前栈中的最大值。题解中主要采用了以下几种思路：

1. **辅助栈法**：通过维护一个辅助栈，记录当前栈中的最大值，确保查询操作的时间复杂度为O(1)。
2. **动态规划法**：使用一个数组记录栈中每个位置的最大值，入栈时更新该数组，查询时直接返回栈顶的最大值。
3. **优先队列法**：使用优先队列维护栈中的最大值，出栈时更新优先队列，查询时返回队头元素。

这些方法的核心思想都是通过额外的数据结构或算法优化，避免在查询时遍历整个栈，从而将时间复杂度从O(n)降低到O(1)。

### 所选高星题解

#### 1. 作者：medusa (赞：208)  
**星级：5星**  
**关键亮点**：使用动态规划思想，通过数组`f[i]`记录栈中前i个元素的最大值，入栈时更新`f[t]`，查询时直接返回`f[t]`，简洁高效。  
**代码核心思想**：
```cpp
int f[200001], n, x, y, t = 0;
for (int i = 1; i <= n; i++) {
    cin >> x;
    if (x == 0) {
        cin >> y;
        t++;
        f[t] = max(f[t - 1], y); // 更新最大值
    }
    if (x == 1) if (t != 0) t--; // 出栈
    if (x == 2) cout << f[t] << endl; // 查询最大值
}
```
**个人心得**：通过数组记录最大值，避免了每次查询时的遍历操作，极大提升了效率。

#### 2. 作者：buickboy (赞：57)  
**星级：4星**  
**关键亮点**：使用辅助栈记录最大值，入栈时更新辅助栈，出栈时同步弹出，查询时直接返回辅助栈顶元素。  
**代码核心思想**：
```cpp
stack<int> a, b;
if (m == 0) {
    scanf("%d", &x);
    a.push(x);
    if (b.empty() || x > b.top()) b.push(x);
    else b.push(b.top()); // 更新辅助栈
} else if (m == 1) {
    a.pop();
    b.pop(); // 同步弹出
} else {
    if (b.empty()) printf("0\n");
    else printf("%d\n", b.top()); // 查询最大值
}
```
**个人心得**：辅助栈的设计巧妙，确保了查询操作的高效性。

#### 3. 作者：felixwu (赞：10)  
**星级：4星**  
**关键亮点**：使用数组模拟栈，并通过数组记录每个位置的最大值，查询时直接返回栈顶的最大值。  
**代码核心思想**：
```cpp
int q[1000001], top, a[1000001];
void push(int x) {
    q[++top] = x;
    a[top] = max(a[top - 1], x); // 更新最大值
}
void pop() { top--; }
int main() {
    if (m == 0) {
        scanf("%d", &k);
        push(k);
    }
    if (m == 1) pop();
    if (m == 2) printf("%d\n", a[top]); // 查询最大值
}
```
**个人心得**：数组模拟栈的方式简洁明了，适合对栈操作不熟悉的读者。

### 最优关键思路总结

最优思路是通过辅助数据结构（如辅助栈或数组）记录当前栈中的最大值，确保查询操作的时间复杂度为O(1)。这种方法的核心在于**避免在查询时遍历整个栈**，而是通过预处理或同步更新来维护最大值信息。

### 可拓展之处

类似的问题可以扩展到其他需要快速查询栈中极值或特定属性的场景，例如查询栈中的最小值、中位数等。此外，这种思路也可以应用于队列、双端队列等其他数据结构。

### 推荐题目

1. **P1449 后缀表达式**（栈的应用）
2. **P1739 表达式括号匹配**（栈的应用）
3. **P1886 滑动窗口**（单调队列的应用）

这些题目都涉及到栈或队列的应用，适合进一步巩固相关知识点。

---
处理用时：41.46秒
# 题目信息

# 木棍加工

## 题目描述

一堆木头棍子共有 $n$ 根，每根棍子的长度和宽度都是已知的。棍子可以被一台机器一个接一个地加工。机器处理一根棍子之前需要准备时间。准备时间是这样定义的：

- 第一根棍子的准备时间为 $1$ 分钟。
- 如果刚处理完长度为 $l$，宽度为 $w$ 的棍子，那么如果下一个棍子长度为 $l_i$，宽度为 $w_i$，并且满足 $l\ge l_i$、$w\ge w_i$，这个棍子就不需要准备时间，否则需要 $1$ 分钟的准备时间。

计算处理完 $n$ 根棍子所需要的最短准备时间。比如，你有 $5$ 根棍子，长度和宽度分别为 $(4,9),(5,2),(2,1),(3,5),(1,4)$，最短准备时间为 $2$（按 $(4,9),(3,5),(1,4),(5,2),(2,1)$ 的次序进行加工）。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 5000$，$1 \le l_i, w_i \le {10}^4$。

## 样例 #1

### 输入

```
5
4 9 5 2 2 1 3 5 1 4
```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何通过排序和动态规划（或贪心）来最小化木棍加工的准备时间。大多数题解都采用了类似的思路：先对木棍按长度和宽度进行排序，然后通过动态规划或贪心算法计算最长上升子序列的长度，最终得到所需的最少准备时间。

#### 最优关键思路与技巧：
1. **排序策略**：先按长度降序排序，长度相同则按宽度降序排序。这样可以确保在后续处理中，尽可能减少准备时间。
2. **动态规划优化**：通过二分查找优化最长上升子序列的计算，将时间复杂度从O(n²)降低到O(nlogn)。
3. **贪心策略**：通过贪心算法，每次选择第一个可以接在当前序列末尾的木棍，减少序列的数量。

#### 可拓展之处：
- **类似问题**：导弹拦截问题（P1020）与此题类似，都是通过排序和动态规划来求解最长不上升子序列。
- **算法套路**：排序 + 动态规划（或贪心）是解决此类问题的常见套路，适用于多种二维或三维数据的处理问题。

### 推荐题目
1. **导弹拦截**（P1020）：与本题类似，考察最长不上升子序列的求解。
2. **最长公共子序列**（P1439）：考察动态规划在序列匹配中的应用。
3. **木棍加工**（P1233）：与本题相同，考察排序和动态规划的结合应用。

### 所选高分题解

#### 1. 学无止境（5星）
**关键亮点**：
- 详细解释了排序策略的必要性，并通过二分查找优化了动态规划的实现。
- 代码简洁且高效，时间复杂度为O(nlogn)。

**核心代码**：
```cpp
for(register int i=1;i<=n;i++)
{
    if(a[i].w>f[ans])
        f[++ans]=a[i].w;
    else
    {
        int tmp=lower_bound(f+1,f+1+ans,a[i].w)-f;
        f[tmp]=a[i].w;
    }
}
```
**实现思想**：通过二分查找维护一个数组`f`，`f[i]`表示长度为`i`的上升子序列的最小结尾值，最终`ans`即为最长上升子序列的长度。

#### 2. CYJian（4星）
**关键亮点**：
- 使用`set`数据结构来维护每个序列的末尾木棍，简化了贪心算法的实现。
- 代码可读性强，且时间复杂度为O(nlogn)。

**核心代码**：
```cpp
for(int i = 1; i <= n; i++) {
    if(a.empty()) a.insert(s[i]), ans++;
    else {
        it = a.lower_bound(s[i]);
        if(it == a.end()) a.insert(s[i]), ans++;
        else a.erase(it), a.insert(s[i]);
    }
}
```
**实现思想**：通过`set`维护每个序列的末尾木棍，每次选择第一个可以接在当前序列末尾的木棍，减少序列的数量。

#### 3. MRZMRZ（4星）
**关键亮点**：
- 详细解释了贪心策略的实现，并通过模拟证明了贪心的正确性。
- 代码简洁且易于理解，时间复杂度为O(n²)。

**核心代码**：
```cpp
for(int i=2;i<=n;i++) {
    bool bo=0;
    for(int j=1;j<=ans;j++) {
        if(a[i].x<=ls[j].x&&a[i].y<=ls[j].y) {
            ls[j]=a[i];
            bo=1;
            break;
        }
    }
    if(bo==0) {
        ans++;
        ls[ans]=a[i];
    }
}
```
**实现思想**：通过贪心策略，每次选择第一个可以接在当前序列末尾的木棍，减少序列的数量。

### 个人心得摘录
- **学无止境**：强调了排序时按宽度降序的重要性，否则会被特定数据hack。
- **MRZMRZ**：提到贪心策略在模拟时容易出错，倒序枚举会导致WA，正序枚举才能AC。

### 总结
通过排序和动态规划（或贪心）的结合，可以高效解决此类问题。二分查找和`set`等数据结构的应用，进一步优化了算法的性能。

---
处理用时：38.01秒
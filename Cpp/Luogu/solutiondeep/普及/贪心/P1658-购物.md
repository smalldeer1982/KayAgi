# 题目信息

# 购物

## 题目描述

你就要去购物了，现在你手上有 $N$ 种不同面值的硬币，每种硬币有无限多个。为了方便购物，你希望带尽量少的硬币，但要能组合出 $1$ 到 $X$ 之间的任意值。


## 说明/提示

对于 $30\%$ 的数据，满足 $N \le 3$，$X \le 20$；

对于 $100\%$ 的数据，满足 $N \le 10$，$X \le 10^3$。

## 样例 #1

### 输入

```
20 4
1 2 5 10
```

### 输出

```
5
```

# AI分析结果

### 综合分析与结论

本题的核心是通过贪心算法，选择尽可能大的硬币面值来覆盖1到X的所有金额，从而最小化所需硬币数量。所有题解均基于这一思路，但在实现细节和优化程度上有所不同。大多数题解通过排序和从大到小选择硬币来确保每次选择的硬币面值最大，从而减少硬币数量。部分题解还引入了二分查找或动态规划的思想来进一步优化时间复杂度。

### 所选高星题解

#### 题解1：qwaszx (5星)
**关键亮点**：
- 通过二分查找优化了查找最大可用硬币的过程，将时间复杂度从O(nm)降低到O(mlogn)。
- 详细解释了贪心策略的正确性，并提供了多个版本的代码，逐步优化。
- 代码结构清晰，注释详细，便于理解。

**核心代码**：
```cpp
int find(int x) {
    int l=1,r=n,mid;
    while(l<r) {
        mid=(l+r+1)>>1;
        if(a[mid]<=x)l=mid;
        else r=mid-1;
    }
    return l;
}
```
**实现思想**：通过二分查找快速找到小于等于当前总金额+1的最大硬币面值。

#### 题解2：pengyule (4星)
**关键亮点**：
- 通过举例详细解释了贪心策略的正确性，易于理解。
- 代码简洁，直接通过排序和从大到小选择硬币来实现贪心策略。

**核心代码**：
```cpp
while(SUM<X){
    for(int i=1;i<=n;i++)
        if(a[i]<=SUM+1){
            SUM+=a[i];
            break;
        }
    ans++;
}
```
**实现思想**：从大到小选择硬币，确保每次选择的硬币面值最大，从而减少硬币数量。

#### 题解3：lswSunny (4星)
**关键亮点**：
- 通过动态规划的思想解释了贪心策略的正确性，提供了更深入的理解。
- 代码简洁，直接通过排序和从大到小选择硬币来实现贪心策略。

**核心代码**：
```cpp
while(sum<x)
{  
    for(i=n;i>=1;i--)   
        if(s[i]<=sum+1)break;
    ans++;    
    sum+=s[i];
}
```
**实现思想**：从大到小选择硬币，确保每次选择的硬币面值最大，从而减少硬币数量。

### 最优关键思路与技巧

1. **贪心策略**：每次选择小于等于当前总金额+1的最大硬币面值，确保每次选择的硬币面值最大，从而减少硬币数量。
2. **二分查找优化**：通过二分查找快速找到小于等于当前总金额+1的最大硬币面值，将时间复杂度从O(nm)降低到O(mlogn)。
3. **动态规划思想**：通过动态规划的思想解释贪心策略的正确性，提供了更深入的理解。

### 可拓展之处

1. **类似算法套路**：贪心算法在解决最小覆盖问题时非常有效，类似的题目包括区间覆盖、任务调度等。
2. **同类型题目**：可以进一步练习贪心算法在其他场景中的应用，如背包问题、任务调度等。

### 推荐题目

1. **P1090 合并果子**：贪心算法，每次选择最小的两个果子合并。
2. **P1223 排队接水**：贪心算法，按照接水时间从小到大排序。
3. **P1803 凌乱的yyy / 线段覆盖**：贪心算法，选择结束时间最早的线段。

### 个人心得总结

- **调试经历**：在实现贪心算法时，确保每次选择的硬币面值最大是关键，通过排序和从大到小选择可以有效减少硬币数量。
- **踩坑教训**：如果没有1元面值的硬币，直接输出-1，因为无法凑出1元。
- **顿悟感想**：贪心算法的正确性往往需要通过举例和动态规划的思想来验证，确保每次选择的局部最优解能够导致全局最优解。

---
处理用时：37.98秒
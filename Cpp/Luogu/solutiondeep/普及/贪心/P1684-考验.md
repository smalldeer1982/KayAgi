# 题目信息

# 考验

## 题目描述

大家知道，黄药师不仅武功高超，而且酷爱音乐和诗歌。看到桃花岛来了个新客人，而且不是靠真武功进来的，就准备为难为难你。

他写了一首 $N$ 行诗句的诗歌，美中不足的是这些诗句并不押韵，黄药师非常想遵循古诗的押韵。诗歌被分为若干段，每段都是四行诗。每一句诗都有一个韵脚，假如 $A$ 和 $B$ 表示两种不同的韵脚，每段四行诗的韵脚只可能是 `AABB`，`ABAB`，`ABBA` 和 `AAAA` 中的一种。

黄药师将诗句的韵脚都编了号，具有相同编号的句子代表有相同的韵脚。现在，黄药师想删掉一些句子，使得剩下的都是遵循押韵规则的四行诗，而且不允许改变诗句的顺序。

现在就问你：如何找出满足条件最长的诗歌？

## 说明/提示

提示：

删除第 $3$、$6$、$13$ 句诗，就可以分成 $3$ 个四行诗，分别为：

- $1,2,4,5$；
- $7,8,9,10$；
- $11,12,14,15$。


## 样例 #1

### 输入

```
15

1 2 3 1 2 1 2 3 3 2 1 1 3 2 2

```

### 输出

```
3

```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何在保持诗句顺序的前提下，删除部分诗句，使得剩下的诗句能够组成尽可能多的四行诗，且每段四行诗的韵脚符合特定的押韵规则（AABB、ABAB、ABBA、AAAA）。题解中主要采用了贪心和动态规划两种思路，贪心算法通过记录韵脚出现的次数来判断是否可以组成四行诗，而动态规划则通过状态转移来寻找最优解。

### 所选高质量题解

#### 1. 作者：神阈小杰 (5星)
- **关键亮点**：使用贪心算法，通过`map`记录韵脚出现次数，简洁高效地判断是否可以组成四行诗。代码清晰，逻辑简单，易于理解。
- **个人心得**：作者提到自己动态规划不擅长，因此选择了贪心算法，体现了对问题的灵活应对。
- **核心代码**：
```cpp
map <int,int> f;
int s, ans;
for(int i=1;i<=n;i++) {
    scanf("%d",&x);
    f[x]++;
    if(f[x]==2) s++;
    if(s==2 || f[x]==4) {
        ans++;
        s=0;
        f.clear();
    }
}
```
- **实现思想**：通过`map`记录每个韵脚出现的次数，当有两个韵脚各出现两次或一个韵脚出现四次时，答案加一，并清空记录。

#### 2. 作者：permzf (4星)
- **关键亮点**：同样采用贪心算法，通过离散化和数组记录韵脚出现次数，进一步优化了空间复杂度。
- **核心代码**：
```cpp
int f[10001], c[10001], ans=0, ok=0;
for(int i=1;i<=n;i++) {
    int k=lower_bound(c+1,c+m+1,a[i])-c;
    a[i]=k;
    f[a[i]]++;
    if(f[a[i]]==2) ok++, f[a[i]]=0;
    if(ok==2) {
        ok=0; ans++;
        memset(f,0,sizeof(f));
    }
}
```
- **实现思想**：通过离散化减少空间占用，记录韵脚出现次数，当有两个韵脚各出现两次时，答案加一并清空记录。

#### 3. 作者：X_yea (4星)
- **关键亮点**：采用动态规划，通过`dfs`枚举可能的四行诗组合，判断是否满足押韵规则，思路清晰但复杂度较高。
- **核心代码**：
```cpp
void dfs(int now,int step) {
    if(step==5) {
        if(b[1]==b[2]&&b[3]==b[4] || b[1]==b[3]&&b[2]==b[4] || b[1]==b[4]&&b[2]==b[3])
            f[x]=max(f[x],f[now-1]+1);
        return;
    }
    for(int i=now-1; i>=1; i--) {
        b[step]=a[i];
        dfs(i,step+1);
        b[step]=0;
    }
}
```
- **实现思想**：通过`dfs`枚举四行诗的组合，判断是否满足押韵规则，更新动态规划状态。

### 最优关键思路与技巧

1. **贪心算法的应用**：通过记录韵脚出现次数，判断是否可以组成四行诗，时间复杂度低，代码简洁。
2. **离散化优化**：通过离散化减少空间占用，适用于韵脚编号较大的情况。
3. **动态规划的枚举**：通过`dfs`枚举可能的组合，虽然复杂度较高，但思路清晰，适用于小规模数据。

### 可拓展之处

- **类似问题**：可以拓展到其他需要分组且每组有特定规则的题目，如分组背包问题、区间划分问题等。
- **算法套路**：贪心算法适用于局部最优解能导致全局最优解的问题，动态规划适用于需要状态转移的问题。

### 推荐题目

1. **P1048 采药**：考察动态规划中的背包问题，与本题的状态转移思路类似。
2. **P1091 合唱队形**：考察动态规划中的最长上升子序列，与本题的枚举思路类似。
3. **P1020 导弹拦截**：考察贪心算法与动态规划的结合，与本题的贪心思路类似。

---
处理用时：35.53秒
# 题目信息

# [USACO19FEB] The Great Revegetation B

## 题目描述

长时间的干旱使得 Farmer John 的 $N$ 块草地上牧草匮乏。随着雨季即将到来，现在应当是重新种植的时候了。

在 Farmer John 的储物棚里有四个桶，每个桶里装着一种不同的草种。他想要在每块草地上播种其中一种草。作为一名奶农，Farmer John 想要确保他的每头奶牛都能得到丰富的食谱。他的 $M$ 头奶牛每一头都有两块喜爱的草地，他想要确保这两块草地种植不同种类的草，从而每头奶牛都可以有两种草可供选择。Farmer John 知道没有一块草地受到多于 $3$ 头奶牛的喜爱。

请帮助 Farmer John 选择每块草地所种的草的种类，使得所有奶牛的营养需求都得到满足。 

## 样例 #1

### 输入

```
5 6
4 1
4 2
4 3
2 5
1 2
1 5```

### 输出

```
12133```

# AI分析结果

### 综合分析与结论

本题的核心在于为每块草地分配一种草种，确保每头奶牛喜欢的两块草地种植不同的草种，并且要求字典序最小。由于每块草地最多被3头奶牛喜欢，因此贪心算法是可行的。大多数题解都采用了贪心策略，通过逐位枚举草种并检查是否满足条件来构造字典序最小的解。

### 所选高质量题解

#### 1. 作者：Licis_Subway (★★★★★)
- **关键亮点**：思路清晰，代码结构良好，提供了详细的子函数实现（如 `check` 和 `findcow`），并且对为什么一定有解进行了证明。
- **个人心得**：作者强调了“没有一块草地受到多于3头奶牛的喜爱”这一条件的重要性，确保了贪心算法的可行性。
- **核心代码**：
  ```cpp
  bool check(int grass,int x)
  {
      set<int> cows=findcow(grass);
      set<int>::iterator it=cows.begin();
      for(;it!=cows.end();it++)
      {
          if(a[*it].first==grass)
          {
              if(a[*it].second>=grass) continue;
              if(ans[a[*it].second]==x) return false;
              else continue;
          }
          else
          {
              if(a[*it].first>=grass) continue;
              if(ans[a[*it].first]==x) return false;
              else continue;
          }
      }
      return true;
  }
  ```

#### 2. 作者：lflby (★★★★☆)
- **关键亮点**：将问题转化为图论问题，思路简洁，代码实现较为直观。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= n; i++)
  {
      for (int j = 1; j <= 4; j++)
      {
          bool flag = true;
          for (int k = 0; k < a[i].size(); k++)
          {
              if (j==d[a[i][k]])
              {
                  flag = false;
                  break;
              }
          }
          if (flag)
          {
              d[i]=j;
              break;
          }
      }
  }
  ```

#### 3. 作者：MarsNotFound (★★★★☆)
- **关键亮点**：代码简洁，思路清晰，通过暴力枚举草种并检查是否满足条件来构造解。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++)
  {
      int j;
      for(j=1;j<=4;j++)
      {
          int flag=0;
          for(int k=1;k<=m;k++)
          {
              if(b[k]==i&&s[a[k]]==j)
              {
                  flag=1;
                  break;
              }
          }
          if(!flag)break;
      }
      cout<<j;
      s[i]=j;
  }
  ```

### 最优关键思路与技巧

1. **贪心算法**：逐位枚举草种，确保每块草地的草种与相邻草地的草种不同，并且字典序最小。
2. **图论转化**：将草地和奶牛的关系转化为图的边，确保相邻节点的草种不同。
3. **暴力枚举**：对于每块草地，枚举所有可能的草种，并检查是否满足条件。

### 可拓展之处

- **类似问题**：类似的问题可以出现在图着色、任务调度等领域，要求为节点分配颜色或资源，并满足一定的约束条件。
- **算法优化**：可以考虑使用更高效的图着色算法，如回溯法或启发式算法，来进一步优化时间复杂度。

### 推荐题目

1. **P1330 封锁阳光大学**：考察图的二分染色问题，与本题的图论转化思路相似。
2. P1451 求细胞数量：考察图的遍历与标记，与本题的草地和奶牛关系处理类似。
3. P1525 关押罪犯：考察图的二分染色与贪心策略，与本题的贪心算法思路相似。

### 个人心得总结

- **调试经历**：多位作者提到在调试过程中，发现草地的编号顺序对结果有影响，因此需要确保从前往后枚举草地。
- **踩坑教训**：部分作者在实现时忽略了草地编号的顺序，导致结果不符合字典序最小的要求。
- **顿悟感想**：通过将问题转化为图论问题，可以更直观地理解并解决问题，贪心算法的正确性也得到了验证。

---
处理用时：40.11秒
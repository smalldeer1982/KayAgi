# 题目信息

# [USACO05NOV] 奶牛玩杂技

## 题目背景

Farmer John 养了 $N$ 头牛，她们已经按 $1\sim N$ 依次编上了号。FJ 所不知道的是，他的所有牛都梦想着从农场逃走，去参加马戏团的演出。可奶牛们很快发现她们那笨拙的蹄子根本无法在钢丝或晃动的的秋千上站稳（她们还尝试过把自己装在大炮里发射出去，但可想而知，结果是悲惨的） 。最终，她们决定练习一种最简单的杂技：把所有牛都摞在一起， 比如说， 第一头牛站在第二头的身上， 同时第二头牛又站在第三头牛的身上...最底下的是第 $N$ 头牛。

## 题目描述

每头牛都有自己的体重以及力量，编号为 $i$ 的奶牛的体重为 $W_i$，力量为 $S_i$。

当某头牛身上站着另一些牛时它就会在一定程度上被压扁，我们不妨把它被压扁的程度叫做它的压扁指数。对于任意的牛，她的压扁指数等于摞在她上面的所有奶牛的总重（当然不包括她自己）减去它的力量。奶牛们按照一定的顺序摞在一起后， 她们的总压扁指数就是被压得最扁的那头奶牛的压扁指数。

你的任务就是帮助奶牛们找出一个摞在一起的顺序，使得总压扁指数最小。

## 说明/提示

对于 $100\%$ 的数据，$1 \le N \le 5\times 10^4$，$1 \le W_i \le 10^4$，$1 \le S_i \le 10^9$。

## 样例 #1

### 输入

```
3
10 3
2 5
3 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是通过贪心算法找到奶牛的最佳排列顺序，使得总压扁指数最小。所有题解都采用了类似的贪心策略：按照奶牛的体重和力量之和（\(W_i + S_i\)）进行排序，然后计算每头牛的压扁指数，取最大值作为最终结果。

**关键思路与技巧：**
1. **贪心策略**：通过比较相邻两头牛的 \(W_i + S_i\) 来决定它们的相对位置，确保 \(W_i + S_i\) 较大的牛放在下面。
2. **压扁指数计算**：在排序后，依次计算每头牛的压扁指数，并取最大值。
3. **边界处理**：由于压扁指数可能为负数，初始化时需将结果变量设为极小值。

**可拓展之处：**
- 类似的问题可以扩展到其他需要排序并计算某种指标的场景，如任务调度、资源分配等。
- 贪心策略的证明方法（如邻项交换法）可以应用于其他贪心问题。

### 推荐题目
1. [P1080 国王游戏](https://www.luogu.org/problem/P1080) - 类似贪心策略的应用。
2. [P1090 合并果子](https://www.luogu.org/problem/P1090) - 贪心与优先队列的结合。
3. [P1223 排队接水](https://www.luogu.org/problem/P1223) - 贪心策略在时间调度中的应用。

### 个人心得摘录
- **调试经历**：多位作者提到初始化时未将结果变量设为极小值，导致部分测试点无法通过。这提醒我们在处理可能为负数的结果时，初始化要特别注意。
- **顿悟感想**：通过邻项交换法证明贪心策略的正确性，是解决类似问题的通用方法。

### 所选高分题解

#### 题解1：作者：liuzitong (赞：61)
**星级：★★★★★**
**关键亮点：**
- 详细证明了贪心策略的正确性，通过邻项交换法展示了为什么 \(W_i + S_i\) 较大的牛应该放在下面。
- 代码简洁明了，注释清晰，适合初学者理解。

**核心代码：**
```cpp
bool cmp(po a,po b){
    return a.w + a.s < b.w + b.s;
}

int main() {
    int n;
    cin>>n;
    for(int i = 1;i <= n;++i){
        a[i].w = read();
        a[i].s = read();
    }
    sort(a + 1,a + 1 + n,cmp);
    int tot = 0,ans = -99999999;
    for(int i = 1;i <= n;++i){
        ans = max(ans,tot - a[i].s);
        tot += a[i].w;
    }
    cout<<ans<<endl;
    return 0;
}
```

#### 题解2：作者：Tarsal (赞：32)
**星级：★★★★☆**
**关键亮点：**
- 通过感性理解与数学证明相结合，解释了贪心策略的合理性。
- 代码中使用了倒序遍历，进一步优化了计算过程。

**核心代码：**
```cpp
bool cmp(node x, node y){
    return x.sum < y.sum;
}

int main(){
    scanf("%d", &n);
    Rep(i, 1, n){
        scanf("%d%d", &e[i].w, &e[i].s);
        e[i].sum = e[i].w + e[i].s;
        now += e[i].w;
    }
    sort(e + 1, e + n + 1, cmp);
    Dep(i, n, 1){
        now -= e[i].w;
        ans = max(now - e[i].s, ans);
    }
    printf("%d", ans);
    return 0;
}
```

#### 题解3：作者：设计涉及社稷 (赞：18)
**星级：★★★★☆**
**关键亮点：**
- 通过构造相邻两头牛的情况，详细分析了贪心策略的优劣。
- 代码结构清晰，注释详细，适合进阶学习。

**核心代码：**
```cpp
bool cmp(nainiu a, nainiu b){
    return a.s + a.w < b.s + b.w;
}

int main(){
    rd(n);
    rep(i,1,n){
        rd(cow[i].w), rd(cow[i].s);
    }
    sort(cow+1, cow+n+1, cmp);
    int sum = 0, ans = INT_MIN;
    rep(i,1,n){
        ans = max(ans, sum - cow[i].s);
        sum += cow[i].w;
    }
    printf("%d", ans);
    return 0;
}
```

### 总结
以上三条题解均详细解释了贪心策略的正确性，并通过简洁的代码实现了算法。其中，liuzitong的题解在证明部分尤为详细，适合初学者理解；Tarsal的题解通过倒序遍历优化了计算过程；设计涉及社稷的题解则在代码结构上更为清晰。

---
处理用时：42.16秒
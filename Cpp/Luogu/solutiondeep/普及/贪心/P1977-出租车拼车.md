# 题目信息

# 出租车拼车

## 题目背景

话说小 x 有一次去参加比赛，虽然学校离比赛地点不太远，但小 x 还是想坐出租车去。大学城的出租车总是比较另类，有“拼车”一说，也就是说，你一个人坐车去，还是一堆人一起，总共需要支付的钱是一样的（每辆出租上除司机外最多坐下 $4$ 个人）。刚好那天同校的一群 OIer 在校门口扎堆了，大家果断决定拼车去赛场。

问题来了，一辆又一辆的出租车经过，但里面要么坐满了乘客，要么只剩下一两个座位，众 OIer 都觉得坐上去太亏了，小 x 也是这么想的。

## 题目描述

假设 $N$ 位 OIer 准备拼车，此时为 $0$ 时刻，从校门到目的地需要支付给出租车师傅 $D$ 元（按车次算，不管里面坐了多少 OIer），假如 $S$ 分钟后恰能赶上比赛，那么 $S$ 分钟后经过校门口的出租车自然可以忽略不计了。现在给出在这 $S$ 分钟当中经过校门的所有的 $K$ 辆出租车先后到达校门口的时间 $T_i$  及里面剩余的座位 $Z_i$
，OIer 可以选择上车几个人（不能超过），当然，也可以选择上 $0$ 个人，那就是不坐这辆车。

俗话说，时间就是金钱，这里小 x 把每个 OIer 在校门等待出租车的分钟数 等同于花了相同多的钱（例如小 x 等待了 $20$ 分钟，那相当于他额外花了 $20$ 元钱）。

在保证所有 OIer 都能在比赛开始前到达比赛地点的情况下，聪明的你能计算出他们最少需要花多少元钱么？

## 说明/提示

对于 $100\%$ 的数据，满足 $N,K,D,S \le 100$，$1 \le Z_i \le 4$，$1 \le T_i \le T_{i+1} \le S$。

## 样例 #1

### 输入

```
2 2 10 5

1 1

2 2

```

### 输出

```
14

```

# AI分析结果

### 综合分析与结论

本题是一个典型的动态规划问题，核心在于如何通过状态转移方程来最小化总花费。各题解均采用了动态规划的思路，但在状态定义、转移方程和优化方式上有所不同。以下是各题解的主要特点：

1. **状态定义**：大多数题解使用 `f[i][j]` 表示前 `i` 辆车送走 `j` 个 OIer 的最小花费，但也有题解使用 `f[j]` 表示送走 `j` 个 OIer 的最小花费，通过滚动数组优化空间复杂度。
2. **转移方程**：基本形式为 `f[i][j] = min(f[i][j], f[i-1][j-k] + k * t[i] + d)`，其中 `k` 是当前车送走的人数。
3. **优化**：部分题解通过滚动数组优化空间复杂度，减少内存使用。
4. **初始化与边界条件**：大多数题解将 `f[0][0]` 初始化为 0，表示初始状态，其余状态初始化为极大值，表示不可达。

### 所选高星题解

#### 题解1：DDOSvoid (4星)
- **关键亮点**：状态定义清晰，转移方程简洁，代码可读性高。
- **核心代码**：
  ```cpp
  for(int i=1;i<=k;i++)
      for(int j=0;j<=n;j++){
          f[i][j]=f[i-1][j];
          for(int k=0;k<=min(j,a[i].z);k++)
              f[i][j]=min(f[i-1][j-k]+k*a[i].t+d,f[i][j]);
      }
  ```
- **个人心得**：作者提到状态转移方程“其实很难”，但代码实现简洁，表明在理解问题后，代码实现相对直接。

#### 题解2：Youngsc (4星)
- **关键亮点**：通过滚动数组优化空间复杂度，代码简洁且高效。
- **核心代码**：
  ```cpp
  for(R int i=1; i<=k; ++i)
      for(R int j=0; j<=n; ++j)
          for(R int l=0; l<=z; ++l)
              minn(f[j],f[j+l]+(bool)l*d+l*t);
  ```
- **个人心得**：作者提到“数据很小，过这个~不费力~”，表明在数据规模较小的情况下，优化空间复杂度并非必要，但滚动数组的使用展示了良好的编程习惯。

#### 题解3：JiaY19 (4星)
- **关键亮点**：使用滚动数组优化空间复杂度，代码简洁且高效。
- **核心代码**：
  ```cpp
  for(int i=1;i<=k;i++)				
      for(int j=n;j>=1;j--)
          for(int l=1;l<=min(z[i],j);l++)
              f[j] = min(f[j - l] + l * t[i] + d , f[j]);
  ```
- **个人心得**：作者提到“发现好像我们不关心是不是前 `i` 辆车送走了 `j` 个OIer”，表明在优化过程中，通过减少状态维度来简化问题。

### 最优关键思路与技巧

1. **状态定义与转移方程**：使用 `f[i][j]` 表示前 `i` 辆车送走 `j` 个 OIer 的最小花费，转移方程为 `f[i][j] = min(f[i][j], f[i-1][j-k] + k * t[i] + d)`。
2. **滚动数组优化**：通过滚动数组减少空间复杂度，优化内存使用。
3. **初始化与边界条件**：将 `f[0][0]` 初始化为 0，其余状态初始化为极大值，表示不可达。

### 可拓展之处

1. **背包问题**：本题可以看作是一种背包问题，其中每辆车的座位数相当于物品的重量，花费相当于物品的价值。
2. **动态规划优化**：可以进一步探讨其他动态规划优化技巧，如斜率优化、单调队列优化等。

### 推荐相似题目

1. **P1048 采药**：经典的背包问题，与本题的优化思路相似。
2. **P1060 开心的金明**：涉及动态规划的状态转移与优化。
3. **P1164 小A点菜**：动态规划的应用，与本题的背包问题思路相似。

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中发现状态转移方程的复杂性，但通过简化问题后，代码实现相对直接。
- **踩坑教训**：初始化与边界条件的处理是关键，部分作者提到在初始化时需要注意赋值的合理性。
- **顿悟感想**：通过减少状态维度或使用滚动数组，可以显著优化代码的空间复杂度，提高效率。

---
处理用时：41.63秒
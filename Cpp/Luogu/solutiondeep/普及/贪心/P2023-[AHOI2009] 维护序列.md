# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果

### 综合分析与结论

本题是典型的线段树应用，涉及区间修改（加法和乘法）和区间查询操作。大部分题解都采用了线段树的基本框架，但在实现细节、代码优化和思路清晰度上存在差异。以下是关键思路和技巧的总结：

1. **线段树的双标记管理**：由于涉及加法和乘法操作，需要同时维护`add`和`mul`两个标记，并在下传标记时正确处理它们的优先级（先乘后加）。
2. **取模优化**：由于结果需要取模，题解中普遍使用了`(a + b) % p`和`(a * b) % p`的优化技巧，避免溢出。
3. **代码结构优化**：部分题解通过宏定义、位运算等方式简化代码，提高了可读性和执行效率。
4. **调试与心得**：部分题解提到调试过程中的坑点，如标记下传的顺序、取模的位置等，这些经验对实际解题很有帮助。

### 评分较高的题解

#### 1. **题解作者：Mingoal (4.5星)**
- **关键亮点**：
  - 代码结构清晰，注释详细，便于理解。
  - 使用宏定义简化代码，如`#define update tr[t].su=tr[t<<1].su+tr[t<<1|1].su;`。
  - 正确处理了加法和乘法的优先级问题。
- **个人心得**：作者提到“线段树不熟，打几遍都不嫌多”，强调了多练习的重要性。
- **核心代码**：
  ```cpp
  void maintain(int t,int k){
      tr[t<<1].su=(tr[t<<1].su*tr[t].mu+tr[t].ad*(k+1>>1))%M;
      tr[t<<1|1].su=(tr[t<<1|1].su*tr[t].mu+tr[t].ad*(k>>1))%M;
      tr[t<<1].mu=tr[t<<1].mu*tr[t].mu%M;
      tr[t<<1|1].mu=tr[t<<1|1].mu*tr[t].mu%M;
      tr[t<<1].ad=(tr[t<<1].ad*tr[t].mu+tr[t].ad)%M;
      tr[t<<1|1].ad=(tr[t<<1|1].ad*tr[t].mu+tr[t].ad)%M;
      tr[t].mu=1;tr[t].ad=0;
  }
  ```

#### 2. **题解作者：GaryZhong (4星)**
- **关键亮点**：
  - 使用结构体指针构建线段树，避免了数组越界问题。
  - 通过`pushdown`和`pushup`函数清晰地处理标记下传和状态合并。
  - 代码逻辑清晰，适合初学者理解。
- **核心代码**：
  ```cpp
  void pushdown(Node *p) {
      if (p->tag_add == 0 && p->tag_mul == 1) return;
      p->sum = (p->sum * p->tag_mul + p->tag_add * (p->r - p->l + 1)) % MOD;
      if (p->l != p->r) {
          p->lc->tag_mul = p->lc->tag_mul * p->tag_mul % MOD;
          p->rc->tag_mul = p->rc->tag_mul * p->tag_mul % MOD;
          p->lc->tag_add = (p->lc->tag_add * p->tag_mul + p->tag_add) % MOD;
          p->rc->tag_add = (p->rc->tag_add * p->tag_mul + p->tag_add) % MOD;
      }
      p->tag_add = 0; p->tag_mul = 1;
  }
  ```

#### 3. **题解作者：Yuno (4星)**
- **关键亮点**：
  - 使用分块算法解决线段树问题，提供了另一种思路。
  - 代码简洁，适合对分块算法感兴趣的读者。
  - 通过`pushdown`函数处理标记下传，逻辑清晰。
- **核心代码**：
  ```cpp
  void pushdown(int p) {
      if (add[p] || mul[p] != 1) {
          sum[p<<1] = (sum[p<<1] * mul[p] + add[p] * (mid - l + 1)) % MOD;
          sum[p<<1|1] = (sum[p<<1|1] * mul[p] + add[p] * (r - mid)) % MOD;
          add[p<<1] = (add[p<<1] * mul[p] + add[p]) % MOD;
          add[p<<1|1] = (add[p<<1|1] * mul[p] + add[p]) % MOD;
          mul[p<<1] = mul[p<<1] * mul[p] % MOD;
          mul[p<<1|1] = mul[p<<1|1] * mul[p] % MOD;
          add[p] = 0; mul[p] = 1;
      }
  }
  ```

### 最优关键思路与技巧

1. **双标记管理**：在处理加法和乘法时，必须明确优先级，先乘后加，避免顺序错误导致结果错误。
2. **取模优化**：在每一步操作中都进行取模，避免结果溢出。
3. **代码结构优化**：通过宏定义、位运算等方式简化代码，提高可读性和执行效率。

### 可拓展之处

1. **动态开点线段树**：当数据范围较大时，可以使用动态开点线段树节省空间。
2. **区间最值查询**：类似题目可以扩展到区间最值查询，只需修改`pushup`和`pushdown`函数的逻辑。

### 推荐题目

1. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)

---
处理用时：68.27秒
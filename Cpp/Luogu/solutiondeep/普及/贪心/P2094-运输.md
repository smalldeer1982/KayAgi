# 题目信息

# 运输

## 题目描述

现在已知 $N$ 件商品，和搬运它们其中每一件的费用。现在搬家公司老板 Mr.sb 决定让我们每次任意选取 $2$ 件商品。然后这 $2$ 件商品只算一件商品的费用。但是这个商品的搬运费用是将选出的 $2$ 个商品的费用之和除以 $k$ 的运算结果。如此反复。直到只收一件商品的钱。这个就是商店要付的费用。掌柜的想尽可能的少付钱，以便将更多的钱捐给希望工程。所以请你帮他计算一下最少只用付多少钱。


## 说明/提示

$n,k,w_i$ 均为非负数。

$n,k\le 10^4$。

---

$\text{upd 2022.7.24}$：新增加一组 Hack 数据。题目是否存在该数据范围下的正确解法有争议。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心在于如何通过每次选取两件商品并合并它们，最终使得总费用最小。由于每次合并的费用是两件商品费用之和除以 $k$，因此我们需要找到一种合并顺序，使得最终的总费用最小化。

由于题目中没有给出具体的题解，我将基于题目的描述和常见的算法思路，给出一些通用的建议和扩展思路。

### 通用建议与扩展思路

1. **贪心算法**：每次选择费用最大的两件商品进行合并，这样可以尽量减少每次合并的费用。通过优先队列（堆）可以高效地实现这一策略。

2. **动态规划**：考虑所有可能的合并顺序，并选择其中费用最小的方案。这种方法在 $n$ 较小时可行，但在 $n$ 较大时可能会超时。

3. **数学优化**：通过数学推导，找到一种最优的合并顺序。例如，可以证明在某些情况下，按特定顺序合并商品可以得到最小费用。

### 关键思路与技巧

- **优先队列（堆）**：使用堆可以高效地找到当前费用最大的两件商品，并进行合并。
- **贪心策略**：每次选择局部最优解，期望最终得到全局最优解。

### 推荐题目

1. **P1090 [NOIP2004 提高组] 合并果子** - 考察贪心算法和优先队列的使用。
2. **P1886 [NOI2011] 合并果子** - 与本题类似，考察合并顺序的优化。
3. **P1966 [NOIP2013 提高组] 火柴排队** - 考察贪心算法和排序的应用。

### 核心代码实现

以下是基于贪心算法和优先队列的核心代码实现：

```cpp
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

int main() {
    int n, k;
    cin >> n >> k;
    priority_queue<int> pq;
    for (int i = 0; i < n; ++i) {
        int w;
        cin >> w;
        pq.push(w);
    }
    while (pq.size() > 1) {
        int a = pq.top(); pq.pop();
        int b = pq.top(); pq.pop();
        int c = (a + b) / k;
        pq.push(c);
    }
    cout << pq.top() << endl;
    return 0;
}
```

### 代码简述

1. **输入处理**：读取商品数量 $n$ 和参数 $k$，并将每件商品的费用存入优先队列（最大堆）。
2. **合并过程**：每次从堆中取出费用最大的两件商品，合并它们并将结果重新放入堆中，直到堆中只剩下一件商品。
3. **输出结果**：输出最终剩余商品的费用。

### 总结

本题的关键在于选择合适的合并顺序，贪心算法结合优先队列是一种高效的解决方案。通过每次选择费用最大的两件商品进行合并，可以有效地减少总费用。在实际应用中，这种思路可以扩展到类似的合并问题中。

---
处理用时：25.65秒
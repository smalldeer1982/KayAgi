# 题目信息

# Mzc家中的男家丁

## 题目背景

mzc 与 djn 的…还没有众人皆知，所以我们要来宣传一下。


## 题目描述

mzc 家很有钱（开玩笑），他家有 $n$ 个男家丁，现在 mzc 要将她们全都聚集起来（干什么就不知道了）。现在知道 mzc 与男家丁们互相之间通信的时间，请算出把他们每个人叫到需要的总时间（要重复的哦）。保证能把他们每个人叫到。

## 说明/提示

$n\leq2300,m\leq4\times10^5$


## 样例 #1

### 输入

```
5
12
0 2 15
2 3 20
3 5 13
1 3 29
0 1 30
2 4 21
0 3 23
5 1 48
0 4 17
0 5 27
1 2 43
2 5 41
```

### 输出

```
94
```

# AI分析结果

### 综合分析与结论

本题是一个典型的最小生成树问题，要求将所有节点连通且总通信时间最小。题解中主要使用了Kruskal和Prim两种算法，其中Kruskal算法因其实现简单且易于理解，成为大多数题解的首选。Prim算法虽然也有提及，但使用较少。题解的质量参差不齐，部分题解代码可读性较差，缺乏必要的注释和解释。

### 所选高质量题解

#### 题解1：Hydrogen_Helium (★★★★★)
**关键亮点：**
- 详细解释了Kruskal算法的流程，并配以图示，帮助读者更好地理解算法。
- 代码结构清晰，注释详细，易于理解。
- 使用了并查集优化Kruskal算法，提高了效率。

**核心代码：**
```cpp
#include <iostream>
#include <algorithm>
#define maxn 400005

using namespace std;

int n, m, fa[maxn], sum;

struct Edge{
    int x, y, w;
}edge[maxn];

bool cmp(Edge x,Edge y){return x.w < y.w;}

int find(int x){return x == fa[x] ? x : fa[x] = find(fa[x]);}

void merge(int x,int y){fa[find(x)]=find(y);}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++){
        cin >> edge[i].x >> edge[i].y >> edge[i].w;
        edge[i].x++, edge[i].y++;
    }
    sort(edge+1, edge+m+1, cmp);
    for(int i = 1; i <= n; i++) fa[i] = i;
    for(int i = 1; i <= m; i++){
        int x = edge[i].x, y = edge[i].y;
        if (find(x) != find(y)){
            sum += edge[i].w;
            merge(x,y);
        }
    }
    cout << sum << '\n';
    return 0;
}
```
**核心思想：**
- 使用并查集维护连通性，按边权从小到大排序，依次选择不形成环的边加入生成树。

#### 题解2：fls233666 (★★★★)
**关键亮点：**
- 详细解释了Prim算法的流程，并提供了时间复杂度分析。
- 代码结构清晰，使用了邻接表存储图，适合稀疏图。

**核心代码：**
```cpp
#include<iostream>
#include<vector>
#define INF 2147000000

using namespace std;

int main(){
    int n,m,ans=0;
    cin>>n>>m;
    vector<pair<int,int>> vb[n+1];
    for(int a,b,w,i=1;i<=m;i++){
        cin>>a>>b>>w;
        vb[a].push_back(make_pair(b,w));
        vb[b].push_back(make_pair(a,w));
    }
    int dis[n+1];
    bool fw[n+1];
    for(int i=0;i<=n;i++) dis[i]=INF;
    dis[0]=0;
    memset(fw,0,sizeof(fw));
    for(int mn=INF,u,tg=0;tg<n;tg++,mn=INF){
        for(int j=0;j<=n;j++){
            if(!fw[j] && mn>dis[j]){
                mn=dis[j];
                u=j;
            }
        }
        fw[u]=true;
        for(int lb=vb[u].size(),i=0;i<lb;i++)
            if(!fw[vb[u][i].first] && vb[u][i].second<dis[vb[u][i].first])
                dis[vb[u][i].first]=vb[u][i].second;
    }
    for(int i=0;i<=n;i++) ans+=dis[i];
    cout<<ans;
    return 0;
}
```
**核心思想：**
- 使用Prim算法，通过不断选择未处理节点中距离最小的节点，更新其邻接节点的距离，最终得到最小生成树。

#### 题解3：TheAutumnGlory (★★★★)
**关键亮点：**
- 代码简洁，直接使用Kruskal算法，适合初学者理解。
- 提供了最小生成树的相关学习链接，帮助读者扩展知识。

**核心代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2305;
const int H=400005;
struct node{
    int x,y,len;
    bool operator < (const node &a) const {
        return len<a.len;
    }
}a[H];
int n,m,fa[N];
int _find(int x){
    if(x!=fa[x]) fa[x]=_find(fa[x]);
    return fa[x];
}
void kruskal(){
    int cnt=0,tot=0,i=0;
    while(i<=m && cnt<n){
        i++;
        int x=_find(a[i].x);
        int y=_find(a[i].y);
        if(x!=y){
            fa[x]=y;
            cnt++;
            tot+=a[i].len;
        }
    }
    printf("%d",tot);
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
        scanf("%d %d %d",&a[i].x,&a[i].y,&a[i].len);
    for(int i=1;i<=n;i++) fa[i]=i;
    sort(a+1,a+1+m);
    kruskal();
    return 0;
}
```
**核心思想：**
- 使用Kruskal算法，通过并查集维护连通性，按边权从小到大排序，选择不形成环的边加入生成树。

### 最优关键思路与技巧
- **并查集优化Kruskal算法**：通过并查集维护节点的连通性，极大地提高了Kruskal算法的效率。
- **Prim算法的邻接表实现**：适合稀疏图，通过邻接表存储图，减少了空间复杂度。
- **贪心思想**：无论是Kruskal还是Prim算法，都基于贪心思想，每次选择当前最优的边或节点。

### 可拓展之处
- **堆优化Prim算法**：对于稀疏图，可以使用堆优化Prim算法，将时间复杂度从O(n²)降低到O(m log n)。
- **其他最小生成树算法**：如Borůvka算法，适合处理大规模图。

### 推荐题目
1. P1547 [USACO5.3] 修剪草坪
2. P2121 [NOI2010] 超级钢琴
3. P2820 [AHOI2012] 树屋阶梯

### 个人心得总结
- **调试经历**：部分题解提到在实现Kruskal算法时，容易忽略并查集的路径压缩优化，导致效率低下。
- **踩坑教训**：在Prim算法中，初始化距离数组时，未将所有节点初始化为无穷大，导致错误。
- **顿悟感想**：理解并查集的核心思想后，Kruskal算法的实现变得异常简单，且效率显著提升。

---
处理用时：52.23秒
# 题目信息

# Mzc和体委的争夺战

## 题目背景

mzc 与 djn 第四弹。


## 题目描述

mzc 家很有钱（开玩笑），他家有 $n$ 个男家丁（做过前三弹的都知道）。但如此之多的男家丁吸引来了我们的体委（矮胖小伙），他要来与 mzc 争夺男家丁。

mzc 很生气，决定与其决斗，但 cat 的体力确实有些不稳定，所以他需要你来帮他计算一下最短需要的时间。


## 说明/提示

$1\le n \leq 2500$，$1\le m \leq 2\times10^5$，$1\le c_i\le 10^6$。

由于 mzc 大大十分着急，所以他只能等待 1s。


## 样例 #1

### 输入

```
5 8
1 2 3
2 3 4
3 4 5
4 5 6
1 3 4
2 4 7
2 5 8
1 5 100
```

### 输出

```
11```

# AI分析结果

### 综合分析与结论

本题是一个典型的单源最短路径问题，适合使用Dijkstra、SPFA、Bellman-Ford等算法解决。题解中大部分使用了Dijkstra算法，部分使用了SPFA和Bellman-Ford。总体来看，题解的质量参差不齐，部分题解代码清晰、优化到位，而有些则存在冗余或不够简洁。

### 所选高星题解

#### 1. **作者：利刃随人 (赞：7)**
- **星级：4.5**
- **关键亮点：**
  - 使用了Dijkstra算法的堆优化版本，效率较高。
  - 使用了邻接表存储图结构，节省空间。
  - 代码结构清晰，注释详细，易于理解。
- **个人心得：**
  - 作者提到受SDWC 2019 rk7指导，强调了堆优化的重要性。
  - 代码中使用了STL的优先队列，简化了实现。

**核心代码：**
```cpp
void dijkstra()
{
    priority_queue<node>q;
    for(int i=1;i<=n;i++)
    dis[i]=inf;
    dis[1]=0;
    q.push((node){0,1});
    while(!q.empty())
    {
        node now=q.top();
        q.pop();
        if(vis[now.jd]) continue;
        vis[now.jd]=true;
        for(int i=head[now.jd];i;i=e[i].next)
        if(dis[e[i].to]>dis[now.jd]+e[i].worth)
        {
            dis[e[i].to]=dis[now.jd]+e[i].worth;
            q.push((node){dis[e[i].to],e[i].to});
        }
    }
}
```

#### 2. **作者：xukuan (赞：0)**
- **星级：4**
- **关键亮点：**
  - 提供了Dijkstra和SPFA两种实现，适合不同场景。
  - 使用了链式前向星存储图结构，适合稀疏图。
  - 代码结构清晰，注释详细。
  
**核心代码：**
```cpp
void dijkstra()
{
    priority_queue<pair<ll,ll> >q;
    for(int i=1;i<=n;i++)
    dis[i]=inf;
    dis[1]=0;
    q.push(make_pair(0,1));
    while(!q.empty())
    {
        int x=q.top().second; q.pop();
        if(v[x]) continue;
        v[x]=1;
        for(int i=head[x];i;i=Next[i])
        {
            int y=ver[i],z=edge[i];
            if(dis[y]>dis[x]+z)
            {
                dis[y]=dis[x]+z;
                q.push(make_pair(-dis[y],y));
            }
        }
    }
}
```

#### 3. **作者：Shikita (赞：1)**
- **星级：4**
- **关键亮点：**
  - 使用了Dijkstra算法的堆优化版本，效率较高。
  - 代码简洁，注释清晰，易于理解。
  - 强调了判重的重要性，避免了数据覆盖问题。

**核心代码：**
```cpp
void dijkstra()
{
    priority_queue< pair<int ,int> > q;
    memset(d,0x3f,sizeof(d));
    memset(v,0,sizeof(v));
    d[1]=0;
    q.push(make_pair(0,1));
    while(q.size())
    {
        int x=q.top().second;
        q.pop();
        if(v[x]) continue;
        v[x]=1;
        for(int i=head[x];i;i=Next[i])
        {
            int y=ver[i],z=edge[i];
            if(d[y]>d[x]+z)
            {
                d[y]=d[x]+z;
                q.push(make_pair(-d[y],y));
            }
        }
    } 
}
```

### 最优关键思路与技巧
1. **堆优化Dijkstra**：使用优先队列（堆）优化Dijkstra算法，时间复杂度从O(V^2)降低到O(E log V)，适合稀疏图。
2. **邻接表与链式前向星**：使用邻接表或链式前向星存储图结构，节省空间，适合稀疏图。
3. **判重处理**：在处理无向图时，注意边的判重，避免数据覆盖。

### 拓展与举一反三
1. **同类型题目**：
   - P4779 【模板】单源最短路径（标准版）
   - P3371 【模板】单源最短路径（弱化版）
   - P1144 最短路计数

2. **调试与心得**：
   - 作者Deny_小田提到多次调试后才发现需要判重，强调了细节的重要性。
   - 作者Shikita提到判重的必要性，提醒了在处理无向图时的注意事项。

### 推荐题目
1. P4779 【模板】单源最短路径（标准版）
2. P3371 【模板】单源最短路径（弱化版）
3. P1144 最短路计数

这些题目都考察了单源最短路径算法，适合进一步练习和巩固相关知识。

---
处理用时：39.53秒
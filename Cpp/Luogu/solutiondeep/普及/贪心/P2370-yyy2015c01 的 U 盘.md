# 题目信息

# yyy2015c01 的 U 盘

## 题目背景

在 2020 年的某一天，我们的 yyy2015c01 买了个高端 U 盘。


## 题目描述

你找 yyy2015c01 借到了这个高端的 U 盘，拷贝一些重要资料，但是你发现这个 U 盘有一些问题：

1. 这个 U 盘的传输接口很小，只能传输大小不超过 $L$ 的文件。
2. 这个 U 盘容量很小，一共只能装不超过 $S$ 的文件。

但是你要备份的资料却有很多，你只能备份其中的一部分。

为了选择要备份哪些文件，你给所有文件设置了一个价值 $V_i$，你希望备份的文件总价值不小于 $p$。

但是很快你发现这是不可能的，因为 yyy2015c01 的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）。

注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,

你放在 U 盘中文件的总大小不能超过 U 盘容量。

现在问题来了：你想知道，在满足 U 盘中文件价值之和**不小于** $p$ 时，最小需要多大的接口。

## 说明/提示

$1 \le n, W_i, S \le 10^3$，$1 \leq V_i \leq 10^6$，$1 \leq p \leq 10^9$。

数据较小，请勿乱搞。

样例解释 $1$：买一个大小为 $2$ 接口，把物品 $1$ 、$2$ 放进$\text{U}$盘。

样例解释 $2$：买一个大小为 $500$ 的接口。

样例解释 $3$：本来可以买大小为 $2$ 的接口，可是 U 盘容量放不下足够的文件。

如果数据出现疏漏，请联系出题人 [a710128](https://www.luogu.com.cn/user/2573)

向本题主人公 yyy2015c01 同学致敬！

## 样例 #1

### 输入

```
3 3 5
2 2
1 2
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 505
1 2
500 1```

### 输出

```
500```

## 样例 #3

### 输入

```
3 3 2
2 2
1 2
3 2```

### 输出

```
No Solution!```

## 样例 #4

### 输入

```
4 5 6
5 1
5 2
5 3
1 1```

### 输出

```
No Solution!```

# AI分析结果

### 综合分析与结论

本题的核心问题是在满足U盘容量限制和文件价值要求的条件下，找到最小的文件传输接口大小。题解中主要采用了**二分查找**和**01背包**的结合，通过二分查找确定最小的接口大小，并通过01背包验证是否满足价值要求。部分题解还引入了排序优化，进一步提升了效率。

### 评分较高的题解

#### 1. 作者：MuelsyseU (赞：86)
- **星级**：5星
- **关键亮点**：
  - 详细解释了二分查找和01背包的结合思路，逻辑清晰。
  - 提供了二分查找的模板和优化技巧，适合初学者理解。
  - 代码结构清晰，注释详细，便于阅读和调试。
- **个人心得**：作者提到二分查找与01背包的结合是本题的核心，强调了二分查找的单调性和01背包的状态转移方程的正确性。

```cpp
int dp(int k) {
    for(int j=1;j<=s;j++) f[j]=0;
    for(int i=1;i<=n;i++){
        if(k!=-1&&a[i]>k) continue;
        for(int j=s;j>=a[i];j--){
            f[j]=max(f[j],f[j-a[i]]+b[i]);
        }
    }
    return f[s];
}
```

#### 2. 作者：amstar (赞：30)
- **星级**：4星
- **关键亮点**：
  - 简洁明了地实现了二分查找和01背包的结合。
  - 代码结构清晰，适合快速理解和实现。
  - 提供了无解情况的处理，增强了代码的鲁棒性。

```cpp
bool dp(int x) {
    memset(f,0,sizeof(f));
    for (int i=1; i<=n; ++i) {
        if (v[i]>x) continue; 
        for (int j=s; j>=v[i]; --j)
            f[j] = max(f[j],f[j-v[i]]+w[i]);
    }
    return f[s] >= m;
}
```

#### 3. 作者：Y_B_Y (赞：4)
- **星级**：4星
- **关键亮点**：
  - 通过二分查找和01背包的结合，解决了问题。
  - 代码简洁，适合快速实现。
  - 提供了无解情况的处理，增强了代码的鲁棒性。

```cpp
bool check(int a) {
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++) {
        if(w[i]<=a)
        for(int j=s;j>=w[i];j--) {
            f[j]=max(f[j],f[j-w[i]]+v[i]);
        }
    }
    return f[s] >= p;
}
```

### 最优关键思路与技巧

1. **二分查找与01背包的结合**：通过二分查找确定最小的接口大小，再通过01背包验证是否满足价值要求。
2. **排序优化**：部分题解通过排序优化了01背包的效率，减少了不必要的计算。
3. **无解处理**：在处理无解情况时，通过判断最大价值是否满足要求，增强了代码的鲁棒性。

### 可拓展之处

- **类似问题**：类似的问题可以扩展到其他资源分配问题，如背包问题、任务调度问题等。
- **算法套路**：二分查找与动态规划的结合是解决“最大值最小”或“最小值最大”问题的常见套路。

### 推荐题目

1. **P2440 木材加工**：考察二分查找的应用。
2. **P1048 采药**：经典的01背包问题。
3. **P1064 金明的预算方案**：考察背包问题的变种。

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中发现二分查找的边界问题，通过调整初始值解决了问题。
- **踩坑教训**：在处理无解情况时，部分作者忽略了最大价值的判断，导致代码不鲁棒。
- **顿悟感想**：通过二分查找和01背包的结合，部分作者深刻理解了“最大值最小”问题的解决方法。

---
处理用时：33.32秒
# 题目信息

# [SDOI2005] 区间

## 题目描述

现给定 $n$ 个闭区间 $[a_i, b_i]$（$1 \le i \le n$）。这些区间的并可以表示为一些不相交的闭区间的并。你的任务就是在这些表示方式中找出包含最少区间的方案。你的输出应该按照区间的升序排列。这里如果说两个区间 $[a, b]$ 和 $[c, d]$ 是按照升序排列的，那么我们有 $a \le b < c \le d$。

请写一个程序：

读入这些区间；

计算满足给定条件的不相交闭区间；

把这些区间按照升序输出。

## 说明/提示

对于 $100 \%$ 的数据，$3 \le n \le 50000$，$1 \le a _ i \leq b _ i \le 1000000$。

## 样例 #1

### 输入

```
5

5 6

1 4

10 10

6 9

8 10

```

### 输出

```
1 4

5 10

```

# AI分析结果

### 综合分析与结论

本题的核心任务是合并多个区间，输出最少的互不相交的区间。题解中主要采用了以下几种思路：

1. **差分法**：通过记录区间的起点和终点，利用差分数组统计区间的覆盖情况，最后扫描输出结果。该方法代码简洁，但时间复杂度较高（O(1e6)）。
2. **贪心算法**：将区间按左端点排序，依次合并重叠的区间，输出结果。该算法时间复杂度为O(n log n)，是较为常见的解法。
3. **并查集**：通过并查集数据结构合并重叠的区间，最终输出结果。该方法思路新颖，但实现较为复杂。
4. **栈模拟**：将区间的左右端点视为括号，利用栈模拟括号匹配的过程，输出最外层的区间。该方法时间复杂度为O(n log n)，代码较为简洁。

总体来看，贪心算法和栈模拟是较为推荐的解法，代码简洁且时间复杂度较低。差分法虽然代码简短，但时间复杂度较高，不适用于大规模数据。

### 精选题解

#### 1. **贪心算法 - 作者：NF_水饺 (4星)**
- **关键亮点**：思路清晰，代码简洁，通过排序和贪心合并区间，时间复杂度为O(n log n)。
- **个人心得**：作者强调了在合并区间时要注意更新右端点的最大值，并在最后输出最后一个区间，避免遗漏。
- **核心代码**：
  ```cpp
  sort(a+1,a+n+1,cmp);
  L=a[1].l;
  R=a[1].r;
  for(int i=2;i<=n;i++)
      if(a[i].l<=R)
          R=max(R,a[i].r);
      else {
          printf("%d %d\n",L,R);
          L=a[i].l;
          R=a[i].r;
      }
  printf("%d %d\n",L,R);
  ```

#### 2. **栈模拟 - 作者：Jelly_Goat (4星)**
- **关键亮点**：将区间的左右端点视为括号，利用栈模拟括号匹配的过程，输出最外层的区间，时间复杂度为O(n log n)。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++) {
      cin>>kh[i].pos>>kh[i+n].pos;
      kh[i].ch='(';
      kh[i+n].ch=')';
  }
  sort(kh+1,kh+(n<<1)+1);
  for(int i=1;i<=(n<<1);i++) {
      if(kh[i].ch=='(') s.push(kh[i].pos);
      if(kh[i].ch==')') {
          int left=s.top();
          s.pop();
          if(s.empty()) cout<<left<<' '<<kh[i].pos<<endl;
      }
  }
  ```

#### 3. **差分法 - 作者：蹲在丛中笑 (3星)**
- **关键亮点**：代码简短，利用差分数组统计区间的覆盖情况，最后扫描输出结果。但时间复杂度较高（O(1e6)）。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++) {
      scanf("%d%d",&x,&y);
      a[x]++; b[y]++;
  }
  for(int i=1;i<N;i++) {
      if(!cnt&&a[i]) printf("%d ",i);
      cnt+=a[i]-b[i];
      if(!cnt&&b[i]) printf("%d\n",i);
  }
  ```

### 最优关键思路与技巧

1. **贪心算法**：将区间按左端点排序，依次合并重叠的区间，输出结果。该算法思路清晰，代码简洁，时间复杂度为O(n log n)，是解决区间合并问题的经典方法。
2. **栈模拟**：将区间的左右端点视为括号，利用栈模拟括号匹配的过程，输出最外层的区间。该方法代码简洁，时间复杂度为O(n log n)，适用于区间合并问题。

### 拓展思路

- **同类型题**：区间合并问题还可以通过线段树、平衡树等数据结构解决，但这些方法实现较为复杂，适用于更复杂的区间操作问题。
- **类似算法套路**：贪心算法和栈模拟的思路可以推广到其他区间相关的问题，如区间覆盖、区间交集等。

### 推荐题目

1. **P2082 区间覆盖**：考察区间覆盖问题，与本题类似。
2. **P1886 滑动窗口**：考察区间滑动窗口问题，与区间合并有相似之处。
3. **P3372 线段树 1**：考察线段树的应用，适用于更复杂的区间操作问题。

### 个人心得总结

- **调试经历**：多位作者在实现过程中强调了在合并区间时要注意更新右端点的最大值，并在最后输出最后一个区间，避免遗漏。
- **踩坑教训**：差分法虽然代码简短，但时间复杂度较高，不适用于大规模数据。
- **顿悟感想**：贪心算法和栈模拟是解决区间合并问题的经典方法，代码简洁且时间复杂度较低。

---
处理用时：41.69秒
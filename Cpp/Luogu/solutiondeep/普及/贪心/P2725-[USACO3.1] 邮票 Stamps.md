# 题目信息

# [USACO3.1] 邮票 Stamps

## 题目描述

给一组 $n$ 枚邮票的面值集合和一个上限 $k$ —— 表示信封上能够贴 $k$ 张邮票。请求出最大的正整数 $m$，满足 $1$ 到 $m$ 的面值都可以用不超过 $k$ 张邮票表示出来。



## 说明/提示

#### 样例输入输出 1 解释

有 $1$ 分和 $3$ 分的邮票；你最多可以贴 $5$ 张邮票。很容易贴出 $1$ 到 $5$ 分的邮资（用 $1$ 分邮票贴就行了），接下来的邮资也不难：


- $6 = 3 + 3$。
- $7 = 3 + 3 + 1$。
- $8 = 3 + 3 + 1 + 1 $。
- $9 = 3 + 3 + 3 $。
- $10 = 3 + 3 + 3 + 1 $。
- $11 = 3 + 3 + 3 + 1 + 1 $。
- $12 = 3 + 3 + 3 + 3 $。
- $13 = 3 + 3 + 3 + 3 + 1$。


然而，使用 $5$ 枚 $1$ 分或者 $3$ 分的邮票根本不可能贴出 $14$ 分的邮资。因此，答案为 $13$。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq k \leq 200$，$1 \leq n \leq 50$，$1 \leq a_i \leq 10^4$。

#### 说明

题目翻译来自 NOCOW。

## 样例 #1

### 输入

```
5 2
1 3```

### 输出

```
13```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）或广度优先搜索（BFS）来解决“邮票问题”，即找到最大的连续邮资范围，使得在该范围内每个邮资都可以用不超过k张邮票表示。大多数题解采用了DP的思路，少数使用了BFS。DP的思路通常是维护一个数组`f[i]`，表示构成面值`i`所需的最少邮票数，然后通过状态转移方程`f[i] = min(f[i], f[i - a[j]] + 1)`来更新状态。BFS的思路则是通过队列来扩展可能的邮资，并记录使用的邮票数。

### 所选高星题解

#### 1. 作者：「QQ红包」 (5星)
**关键亮点**：
- 使用了经典的完全背包DP思路，代码简洁且高效。
- 通过初始化`f[i] = 2333`来标记未计算的状态，并在最后通过遍历找到第一个无法构成的面值。
- 代码可读性强，逻辑清晰。

**核心代码**：
```cpp
for (i=1;i<=n;i++) {
    scanf("%d",&a);
    for (j=a;j<=2000000;j++)
        if (f[j-a]+1<=k)
            f[j]=min(f[j],f[j-a]+1);
}
```
**核心思想**：通过遍历每个邮票面值，更新`f[j]`，表示构成面值`j`所需的最少邮票数。

#### 2. 作者：Priori_Incantatem (4星)
**关键亮点**：
- 使用了类似硬币问题的DP思路，状态转移方程清晰。
- 通过`f[i] = min(f[i], f[i - a[j]] + 1)`来更新状态，并在`f[i]`超过`k`时跳出循环。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i=1;i<=Maxm;++i) {
    f[i]=inf;
    for(int j=1;j<=n;++j)
        if(i-a[j]>=0) f[i]=min(f[i],f[i-a[j]]+1);
    if(f[i]==inf || f[i]>m) break;
    ans++;
}
```
**核心思想**：通过遍历每个面值，更新`f[i]`，并在`f[i]`超过`k`时停止。

#### 3. 作者：Weierstras (4星)
**关键亮点**：
- 通过计算最大可能的面值`mx = c[i] * k`来优化DP的循环次数。
- 代码中使用了`vis[j] = vis[j - c[i]] + 1`来更新状态，逻辑清晰。
- 代码简洁，优化了DP的上界。

**核心代码**：
```cpp
for(int i=1;i<=n;i++) {
    mx=c[i]*k;
    for(int j=c[i];j<=mx;j++)
        if(vis[j-c[i]]<min(k,vis[j]-1))
            vis[j]=vis[j-c[i]]+1;
}
```
**核心思想**：通过计算最大可能的面值`mx`，优化DP的循环次数，减少不必要的计算。

### 最优关键思路与技巧

1. **动态规划**：大多数题解采用了DP的思路，通过维护一个数组`f[i]`来表示构成面值`i`所需的最少邮票数，并通过状态转移方程`f[i] = min(f[i], f[i - a[j]] + 1)`来更新状态。
2. **优化循环次数**：通过计算最大可能的面值`mx = c[i] * k`，可以减少DP的循环次数，提高效率。
3. **BFS扩展**：少数题解使用了BFS的思路，通过队列来扩展可能的邮资，并记录使用的邮票数，适合用于需要广度优先搜索的场景。

### 可拓展之处

- **类似问题**：类似的问题包括硬币问题、背包问题等，都可以通过DP或BFS来解决。
- **优化技巧**：在实际应用中，可以通过剪枝、优化循环次数等技巧来提高算法的效率。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典的背包问题，与本题的DP思路类似。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 另一道背包问题，可以通过DP解决。
3. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216) - 动态规划的经典题目，适合练习DP思路。

---
处理用时：38.59秒
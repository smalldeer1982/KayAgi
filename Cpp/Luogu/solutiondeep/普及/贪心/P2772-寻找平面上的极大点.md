# 题目信息

# 寻找平面上的极大点

## 题目描述

在一个平面上，如果有两个点(x,y),(a,b),如果说(x,y)支配了(a,b)，这是指x>=a,y>=b;

用图形来看就是(a,b)坐落在以(x,y)为右上角的一个无限的区域内。

给定n个点的集合，一定存在若干个点，它们不会被集合中的任何一点所支配，这些点叫做极大值点。

编程找出所有的极大点，按照x坐标由小到大，输出极大点的坐标。


## 说明/提示

对于50%的数据：1≤N≤100；0≤X,Y≤100000；

对于100%的数据：1≤N≤50,0000；0≤X,Y≤100000


## 样例 #1

### 输入

```
5 
1 2 2 2 3 1 2 3 1 4```

### 输出

```
(1,4),(2,3),(3,1)```

# AI分析结果

### 综合分析与结论

本题的核心是寻找平面上的极大点，即不被其他点支配的点。题解中主要采用了以下几种思路：
1. **排序+贪心**：通过按y降序、x升序排序，然后遍历寻找极大点。
2. **单调队列**：利用单调队列维护极大点，适合处理较大数据量。
3. **预处理+后处理**：先预处理每个x的最大y，然后从右向左遍历寻找极大点。

大部分题解都采用了排序+贪心的思路，部分题解通过单调队列或预处理优化了时间复杂度。整体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，而部分题解则存在冗余或不够优化。

### 所选高星题解

#### 1. 作者：shiningrise (赞：15)
- **星级**：★★★★★
- **关键亮点**：思路清晰，代码简洁，通过排序和贪心策略高效解决问题。
- **核心实现思想**：
  - 按y降序、x升序排序。
  - 遍历时记录当前最大x，若当前点的x大于最大x，则为极大点。
- **代码片段**：
  ```cpp
  sort(a,a+n);
  int last = -1;
  for(int i=0;i<n;i++) {
      if(a[i].x > last) {
          last = a[i].x;
          cout << "(" << a[i].x << "," << a[i].y << ")";
      }
  }
  ```

#### 2. 作者：Mr_QwQ (赞：13)
- **星级**：★★★★☆
- **关键亮点**：通过从右向左遍历，维护最大y值，避免使用额外数据结构。
- **核心实现思想**：
  - 按x升序、y升序排序。
  - 从右向左遍历，维护最大y值，若当前点的y大于最大y，则为极大点。
- **代码片段**：
  ```cpp
  sort(p+1,p+n+1);
  int imax = -1;
  for(int i=n;i>=1;i--) {
      if(p[i].y > imax) {
          a[++top] = i;
          imax = p[i].y;
      }
  }
  ```

#### 3. 作者：Konnyaku_ljc (赞：8)
- **星级**：★★★★
- **关键亮点**：通过预处理每个x的最大y，然后从右向左遍历寻找极大点，思路清晰。
- **核心实现思想**：
  - 预处理每个x的最大y。
  - 从右向左遍历，维护最大y值，若当前点的y大于最大y，则为极大点。
- **代码片段**：
  ```cpp
  for(int i=maxx;i>=1;i--) {
      if (maxy[i] > maxyy) {
          maxyy = maxy[i];
          ans++;
          x[ans] = i, y[ans] = maxyy;
      }
  }
  ```

### 最优关键思路总结
1. **排序+贪心**：通过按y降序、x升序排序，然后遍历寻找极大点，是最常见且高效的解法。
2. **单调队列**：适合处理较大数据量，通过维护单调队列来高效找到极大点。
3. **预处理+后处理**：先预处理每个x的最大y，然后从右向左遍历寻找极大点，适合处理特定数据分布。

### 拓展与举一反三
- **类似题目**：可以考虑处理三维空间中的极大点问题，或处理其他类型的支配关系。
- **推荐题目**：
  1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
  2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
  3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得摘录
- **Mr_QwQ**：通过从右向左遍历，维护最大y值，避免了使用额外数据结构，简化了代码。
- **Konnyaku_ljc**：预处理每个x的最大y，然后从右向左遍历寻找极大点，思路清晰且高效。

这些心得展示了如何通过优化遍历顺序和预处理来简化问题，值得借鉴。

---
处理用时：36.41秒
# 题目信息

# 树的分解

## 题目描述

给出 $N$ 个点的树和 $K$，问能否把树划分成 $\frac{N}{K}$ 个连通块，且每个连通块的点数都是 $K$。

## 说明/提示

- 对于 $60 \%$ 的数据，$1 \le N, K \le 10^3$；
- 对于 $100 \%$ 的数据，$1 \le T \le 10$，$1 \le N ,K \le 10^5$。

## 样例 #1

### 输入

```
2
4 2
1 2
2 3
3 4
4 2
1 2
1 3
1 4
```

### 输出

```
YES
NO```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何将一棵树划分为若干个大小为 $K$ 的连通块。大多数题解都采用了深度优先搜索（DFS）来遍历树，并在遍历过程中计算子树的大小。当某个子树的大小恰好为 $K$ 时，将其视为一个连通块，并继续递归处理剩余的树。最终，通过判断是否成功划分出 $\frac{N}{K}$ 个连通块来输出结果。

#### 关键思路与技巧：
1. **DFS遍历与子树大小计算**：通过DFS遍历树，计算每个子树的大小，并在子树大小为 $K$ 时进行分割。
2. **剪枝与优化**：在DFS过程中，如果子树大小超过 $K$，直接返回失败，避免不必要的计算。
3. **多组数据处理的注意事项**：在每次处理新数据时，清空相关变量和数据结构，避免数据污染。

#### 可拓展之处：
- **类似问题**：类似的问题可以扩展到图的划分、树的直径计算、子树的最大值等问题。
- **算法优化**：可以考虑使用并查集或动态规划来进一步优化树的划分问题。

### 所选高星题解

#### 1. 作者：Youngsc (赞：26)
- **星级**：★★★★★
- **关键亮点**：思路清晰，代码简洁，通过DFS计算子树大小，并在子树大小为 $K$ 时进行分割。代码中使用了邻接表存储树结构，处理多组数据时清空相关变量。
- **核心代码**：
  ```cpp
  inline void dfs(R int x,R int fa){
      siz[x] = 1;
      for(R int i=h[x]; i; i=ed[i].pre){
          R int p = ed[i].v;
          if(p == fa) continue;
          dfs(p,x);
          siz[x] += siz[p];
      }
      if(siz[x]==k) tot++,siz[x] -= k;
  }
  ```

#### 2. 作者：xhQYm (赞：13)
- **星级**：★★★★
- **关键亮点**：使用了 `st` 数组来记录子树大小，并在子树大小为 $K$ 时清空该子树的大小，继续递归处理。代码结构清晰，处理多组数据时清空相关变量。
- **核心代码**：
  ```cpp
  void dfs(int x,int s)
  {
      st[x]=1;
      for(int i=h[x];~i;i=ne[i])
      {
          int j=e[i];
          if(j!=s)
          {
              dfs(j,x);
              st[x]+=st[j];
          }
      }   
      if(st[x]==k){st[x]=0;cnt++;}
  }
  ```

#### 3. 作者：Cry_For_theMoon (赞：7)
- **星级**：★★★★
- **关键亮点**：通过DFS返回子树的大小，并在子树大小为 $K$ 时返回0，表示该子树已被分割。代码中使用了邻接表存储树结构，处理多组数据时清空相关变量。
- **核心代码**：
  ```cpp
  int dfs(int u,int fa){
      int sum = 1;
      for(int j=first[u];j;j=next[j]){
          int v = edge[j].v;
          if(v==fa)continue;
          int tmp = dfs(v,u);
          if(tmp==-1)return -1;
          sum += tmp;
      }
      if(sum < k)return sum;
      if(sum==k){
          cnt++;
          return 0;
      }
      return -1;
  }
  ```

### 推荐相似题目
1. **P1351 联合权值**：考察树的遍历与权值计算。
2. **P2015 二叉苹果树**：考察树的动态规划与子树选择。
3. **P3379 【模板】最近公共祖先（LCA）**：考察树的遍历与最近公共祖先的计算。

### 个人心得摘录
- **Youngsc**：在DFS过程中，如果子树大小恰好为 $K$，直接剪去该子树，避免重复计算。
- **Cry_For_theMoon**：在DFS过程中，如果子树大小超过 $K$，直接返回失败，避免不必要的计算。

---
处理用时：37.57秒
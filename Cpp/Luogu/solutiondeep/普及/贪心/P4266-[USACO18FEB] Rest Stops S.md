# 题目信息

# [USACO18FEB] Rest Stops S

## 题目描述

Farmer John 和他的私人教练 Bessie 正在攀登温哥华山。为了他们的目的（以及你的目的），这座山可以表示为一条长度为 $L$ 米的长直步道（$1 \leq L \leq 10^6$）。Farmer John 将以每米 $r_F$ 秒的恒定速度徒步（$1 \leq r_F \leq 10^6$）。由于他正在锻炼耐力，他不会在途中休息。

然而，Bessie 被允许在休息站休息，她可能会在那里找到一些美味的草。当然，她不能随便停下来！步道上有 $N$ 个休息站（$1 \leq N \leq 10^5$）；第 $i$ 个休息站距离步道起点 $x_i$ 米（$0 < x_i < L$），并且有一个美味值 $c_i$（$1 \leq c_i \leq 10^6$）。如果 Bessie 在第 $i$ 个休息站休息 $t$ 秒，她会获得 $c_i \cdot t$ 的美味单位。

当不在休息站时，Bessie 将以每米 $r_B$ 秒的固定速度徒步（$1 \leq r_B \leq 10^6$）。由于 Bessie 年轻且健康，$r_B$ 严格小于 $r_F$。

Bessie 希望最大化她摄入的美味草量。但她担心 Farmer John；她认为如果在徒步的任何时刻她在步道上落后于 Farmer John，他可能会失去继续前进的动力！

请帮助 Bessie 找到在确保 Farmer John 完成徒步的情况下，她能获得的最大总美味单位。

## 说明/提示

在这个例子中，Bessie 最优的策略是在 $x=7$ 的休息站休息 $7$ 秒（获得 $14$ 个美味单位），然后在 $x=8$ 的休息站再休息 $1$ 秒（获得 $1$ 个美味单位，总共 $15$ 个美味单位）。

## 样例 #1

### 输入

```
10 2 4 3
7 2
8 1```

### 输出

```
15```

# AI分析结果

### 综合分析与结论

本题的核心是通过贪心算法最大化 Bessie 在休息站的美味值收益，同时确保她不会落后于 Farmer John。大多数题解都采用了类似的贪心策略：按美味值从大到小排序，然后依次选择休息站，计算在每个休息站停留的时间，并累加美味值。

**关键思路与技巧：**
1. **贪心策略**：优先选择美味值高的休息站，确保每次停留的收益最大化。
2. **排序优化**：通过按美味值排序，确保每次选择的休息站是最优的。
3. **时间计算**：利用速度差（`rf - rb`）计算 Bessie 在每个休息站可以停留的时间。
4. **边界处理**：确保 Bessie 不会落后于 Farmer John，即每次停留的时间不超过 Farmer John 到达该休息站的时间。

**优化点：**
- **后缀最大值**：部分题解通过后缀最大值优化了排序过程，避免了重复计算。
- **单调队列**：使用单调队列进一步优化了选择过程，减少了时间复杂度。

### 所选高星题解

#### 1. 作者：pzc2004 (5星)
**关键亮点：**
- 思路清晰，代码简洁，直接按美味值排序后贪心计算。
- 强调了 `long long` 的重要性，避免了溢出问题。

**核心代码：**
```cpp
sort(a+1,a+n+1,cmp);
for(long long i=1;i<=n;i++) {
    if(a[i].a*v2+a2<=a[i].a*v1) {
        ans+=(a[i].a*v1-a[i].a*v2-a2)*a[i].b;
        a2=a[i].a*v1-a[i].a*v2;
    }
}
```
**核心思想：** 按美味值排序后，依次计算每个休息站的停留时间，并累加美味值。

#### 2. 作者：Lolierl (4星)
**关键亮点：**
- 使用后缀最大值优化了排序过程，避免了重复计算。
- 时间复杂度严格线性，适合大规模数据。

**核心代码：**
```cpp
for(int i = l - 1; i >= 1; i--)
    s[i] = (t[s[i + 1]] > t[i]) ? s[i + 1] : i;
while(s[x + 1]) {
    ans += 1ll * (rf - rb) * (s[x + 1] - x) * t[s[x + 1]];
    x = s[x + 1];
}
```
**核心思想：** 通过后缀最大值找到每个位置后的最优休息站，然后计算美味值。

#### 3. 作者：木木！ (4星)
**关键亮点：**
- 使用单调队列优化了选择过程，减少了时间复杂度。
- 代码简洁，思路清晰。

**核心代码：**
```cpp
while(head && ci[i]>=ci[q[head]]) {
    --head;
}
++head;
q[head] = i;
for(int i=1; i<=head; ++i) {
    ans += 1LL*(xi[q[i]]-xi[q[i-1]])*(f-b)*ci[q[i]];
}
```
**核心思想：** 使用单调队列维护当前最优的休息站，然后计算美味值。

### 通用建议与扩展思路

**拓展思路：**
- **动态规划**：如果题目条件允许，可以考虑使用动态规划进一步优化。
- **多维度贪心**：如果休息站的美味值和位置都影响收益，可以考虑多维度的贪心策略。

**推荐题目：**
1. [P1886 滑动窗口](https://www.luogu.org/problem/P1886) - 单调队列的应用。
2. [P1090 合并果子](https://www.luogu.org/problem/P1090) - 贪心算法的经典题目。
3. [P1223 排队接水](https://www.luogu.org/problem/P1223) - 贪心算法的应用。

**个人心得：**
- **调试经历**：部分题解提到了 `long long` 的重要性，提醒我们在处理大数时要注意数据类型的范围。
- **踩坑教训**：排序时要注意边界条件，确保不会越界或遗漏某些情况。

### 总结

本题的核心在于贪心算法的应用，通过排序和优化选择过程，可以有效地解决问题。推荐的题解在思路清晰度和代码优化上表现较好，适合学习和参考。

---
处理用时：38.24秒
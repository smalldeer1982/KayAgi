# 题目信息

# [USACO19JAN] Mountain View S

## 题目背景

USACO 2019 年一月月赛银组第三题

## 题目描述

从农场里奶牛 Bessie 的牧草地向远端眺望，可以看到巍峨壮丽的山脉绵延在地平线上。山脉里由 $N$ 座山峰（$1≤N≤10^5$）。如果我们把 Bessie 的视野想象成 $xy$ 平面，那么每座山峰都是一个底边在 $x$ 轴上的三角形。山峰的两腰均与底边成 $45$ 度角，所以山峰的峰顶是一个直角。于是山峰 $i$ 可以由它的峰顶坐标 $(x_i,y_i)$ 精确描述。没有两座山峰有完全相同的峰顶坐标。

Bessie 尝试数清所有的山峰，然而由于它们几乎是相同的颜色，所以如果一座山峰的峰顶在另一座山峰的三角形区域的边界上或是内部，她就无法看清。

请求出 Bessie 能够看见的不同的山峰的峰顶的数量，也就是山峰的数量。

## 说明/提示

在这个例子中，Bessie 能够看见第一座和最后一座山峰。第二座山峰被第一座山峰掩盖了。

## 样例 #1

### 输入

```
3
4 6
7 2
2 5```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是判断哪些山峰的峰顶不会被其他山峰的三角形区域覆盖。多个题解都采用了类似的思路：通过计算山峰的左右端点（即三角形在x轴上的投影区间），然后通过排序和遍历来判断哪些山峰的区间不被其他山峰的区间包含。大部分题解的时间复杂度为O(n log n)，主要瓶颈在于排序。

### 最优关键思路与技巧

1. **区间覆盖判断**：通过计算山峰的左右端点（x - y, x + y），将问题转化为区间覆盖问题。
2. **排序策略**：按照左端点从小到大排序，若左端点相同则按右端点从大到小排序，确保在遍历时能优先处理覆盖范围更大的山峰。
3. **贪心遍历**：在排序后，遍历山峰并维护当前最大右端点，若当前山峰的右端点大于最大右端点，则该山峰可见。

### 所选高星题解

#### 1. 作者：Alex_Wei (5星)
- **关键亮点**：思路清晰，代码简洁，排序和遍历的逻辑非常明确，且通过图示解释了为什么这种策略有效。
- **核心代码**：
```cpp
for(int i=1;i<=n;i++)if(m[i].r>w)s++,w=m[i].r;
```
- **实现思想**：遍历排序后的山峰，若当前山峰的右端点大于之前所有山峰的最大右端点，则更新最大右端点并增加可见山峰计数。

#### 2. 作者：By_Ha (4星)
- **关键亮点**：使用了单调队列优化，虽然时间复杂度仍为O(n log n)，但通过队列的维护减少了不必要的比较，代码实现较为巧妙。
- **核心代码**：
```cpp
while(!q.empty()&&a[q.back()].x-a[q.back()].y>=a[i].x-a[i].y)q.pop_back();
```
- **实现思想**：使用单调队列维护未被覆盖的山峰，通过比较山峰的左右端点来判断是否被覆盖，若被覆盖则从队列中移除。

#### 3. 作者：一只书虫仔 (4星)
- **关键亮点**：思路与Alex_Wei类似，但代码更加简洁，直接通过排序和贪心遍历解决问题，适合初学者理解。
- **核心代码**：
```cpp
for(int i=2;i<=n;i++)if(seg[i].r>R)cnt++,R=seg[i].r;
```
- **实现思想**：遍历排序后的山峰，若当前山峰的右端点大于之前所有山峰的最大右端点，则更新最大右端点并增加可见山峰计数。

### 推荐题目

1. **P1886 滑动窗口**：考察单调队列的应用，与By_Ha的题解思路相似。
2. **P1908 逆序对**：考察排序和区间处理，与本题的排序策略有相似之处。
3. **P3372 线段树 1**：考察区间操作，虽然数据结构不同，但区间处理的思想与本题有共通之处。

### 个人心得摘录

- **Alex_Wei**：通过图示解释了为什么排序和遍历的策略有效，帮助理解算法的正确性。
- **By_Ha**：提到考试时其他同学都用了别人的算法，但自己通过单调队列优化了代码，强调了独立思考的重要性。
- **一只书虫仔**：代码简洁明了，适合初学者理解，强调了贪心算法的直观性和易实现性。

### 总结

本题的解决关键在于将山峰的覆盖问题转化为区间覆盖问题，并通过排序和贪心遍历来高效解决。Alex_Wei的题解思路清晰，代码简洁，是最优的解决方案。By_Ha的单调队列优化虽然增加了代码复杂度，但提供了另一种思路。一只书虫仔的题解则适合初学者理解和实现。

---
处理用时：36.45秒
# 题目信息

# [CSGRound3] 斗牛

## 题目背景

又是一年过去了。小 Z 在春节期间可以好好的放松放松，于是小 Z 和小伙伴们玩起了牛哄哄（斗牛）。

游戏规则是这样的：

给定 $5$ 张牌，分别从 $1 \sim 10$。你需要挑选其中的三张牌加起来是 $10$ 的倍数，另外两张牌的和的个位数则为你最后获得的点数，特别的，如果这两张牌的和是 $10$ 的倍数，则点数为 $10$，也叫做牛哄哄。如果不能构成 $10$ 的倍数，则点数为 $0$，也叫做牛不拢。

如 $5$ $3$ $2$ $3$ $4$ 的点数是 $7$，又叫做牛七。

小 Z 觉得玩的不过瘾，于是对上述规则进行了一些改变。

## 题目描述

给定 $n$ 张牌，牌的大小为 $1 \sim 10$。你需要挑选其中的 $n-2$ 张牌加起来是 $10$ 的倍数，另外两张牌和的个位数即为你所获得的点数。特别地，如果这两张牌的和是 $10$ 的倍数，则点数为 $10$，也叫做牛哄哄。如果任意 $n-2$ 张牌不能构成 $10$ 的倍数，则点数为 $0$，也叫做牛不拢。

由于小 Z 想要更开心的玩耍，所以需要你来完成这个程序来帮助小 Z 在 $1$ 秒内知道点数。

## 说明/提示

**【样例 1 解释】**

$10$ $10$ $10$ 三张牌凑成 $10$ 的倍数，$2+3=5$。

**【样例 2 解释】**

任意三张牌都不能凑成 $10$ 的倍数。

---

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（50 points）：$n = 5$。
- Subtask 2（30 points）：$n \le 5 \times 10^3$。
- Subtask 3（20 points）：无特殊限制。

对于 $100\%$ 的数据，$5 \le n \le 10^6$。



## 样例 #1

### 输入

```
5
10 10 10 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
5
3 4 5 6 7```

### 输出

```
0```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地判断是否存在两张牌，使得剩下的牌的和是10的倍数。大多数题解都采用了类似的思路：通过枚举两张牌的组合，判断剩余牌的和是否为10的倍数。优化点主要在于如何减少枚举的次数，以及如何利用牌的范围（1~10）进行预处理。

#### 最优关键思路与技巧：
1. **预处理与桶排序**：利用牌的范围（1~10）进行预处理，统计每个数字出现的次数，避免重复枚举。
2. **总和取模**：通过计算所有牌的总和取模10，快速确定需要寻找的两张牌的和。
3. **枚举优化**：通过枚举两张牌的组合，判断是否满足条件，避免暴力枚举所有可能的组合。

#### 可拓展之处：
- **类似问题**：类似的问题可以扩展到其他模数或更大的牌范围，思路依然适用。
- **算法套路**：预处理+枚举的套路在类似的组合问题中非常常见，如“背包问题”、“子集和问题”等。

### 所选高星题解

#### 1. **题解作者：wpy233 (5星)**
- **关键亮点**：
  - 通过预处理和桶排序，快速判断是否存在两张牌满足条件。
  - 利用总和取模10的思路，简化了判断逻辑。
  - 代码简洁且高效，时间复杂度为O(1)。
- **个人心得**：
  - “这题剩下的两个数根本就不用枚举！！！”，通过预处理和取模运算，避免了不必要的枚举。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[15];//定义累计数字数组
long long ans=0;//其实这里用int就够了，不过保险起见&内存充足时用long long还是万无一失吧
int main()
{
	cin>>n;
	int x;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);//输入每个数字
		if(x==10) a[0]++;//10跟0没区别呀~
		else a[x]++;
		ans+=x%10;//累加
	}
	int t=ans%10;
    //以下是略长的判断过程
	if(t==0) if(a[0]>=2||a[1]&&a[9]||a[2]&&a[8]||a[3]&&a[7]||a[4]&&a[6]||a[5]>=2) cout<<10<<endl; else cout<<0<<endl;
	if(t==1) if(a[0]&&a[1]||a[2]&&a[9]||a[3]&&a[8]||a[4]&&a[7]||a[5]&&a[6]) cout<<1<<endl; else cout<<0<<endl;
	if(t==2) if(a[0]&&a[2]||a[1]>=2||a[3]&&a[9]||a[4]&&a[8]||a[5]&&a[7]||a[6]>=2) cout<<2<<endl; else cout<<0<<endl;
	if(t==3) if(a[0]&&a[3]||a[1]&&a[2]||a[4]&&a[9]||a[5]&&a[8]||a[6]&&a[7]) cout<<3<<endl; else cout<<0<<endl;
	if(t==4) if(a[0]&&a[4]||a[1]&&a[3]||a[2]>=2||a[5]&&a[9]||a[6]&&a[8]||a[7]>=2) cout<<4<<endl; else cout<<0<<endl;
	if(t==5) if(a[0]&&a[5]||a[1]&&a[4]||a[2]&&a[3]||a[6]&&a[9]||a[7]&&a[8]) cout<<5<<endl; else cout<<0<<endl;
	if(t==6) if(a[0]&&a[6]||a[1]&&a[5]||a[2]&&a[4]||a[3]>=2||a[7]&&a[9]||a[8]>=2) cout<<6<<endl; else cout<<0<<endl;
	if(t==7) if(a[0]&&a[7]||a[1]&&a[6]||a[2]&&a[5]||a[3]&&a[4]||a[8]&&a[9]) cout<<7<<endl; else cout<<0<<endl;
	if(t==8) if(a[0]&&a[8]||a[1]&&a[7]||a[2]&&a[6]||a[3]&&a[5]||a[4]>=2||a[9]>=2) cout<<8<<endl; else cout<<0<<endl;
	if(t==9) if(a[0]&&a[9]||a[1]&&a[8]||a[2]&&a[7]||a[3]&&a[6]||a[4]&&a[5]) cout<<9<<endl; else cout<<0<<endl;
    //如上，依次判断能不能有两个数字组成ans%10或ans%10+10即可
	return 0;//完 结 撒 花
}
```

#### 2. **题解作者：StudyingFather (4星)**
- **关键亮点**：
  - 通过枚举两张牌的组合，判断剩余牌的和是否为10的倍数。
  - 代码结构清晰，逻辑简单易懂。
- **个人心得**：
  - “首先有一个比较显然的结论：选牌的方式和最终点数无关。”，通过枚举两张牌的组合，简化了问题。

```cpp
#include <iostream>
using namespace std;
int t[15];
int main()
{
 int n,ans=0;
 cin>>n;
 for(int i=1;i<=n;i++)
 {
  int x;
  cin>>x;
  t[x%10]++;
  ans=(ans+x)%10;
 }
 for(int i=0;i<=9;i++)//枚举两种不同的牌
  for(int j=i+1;j<=9;j++)
   if(t[i]&&t[j]&&(i+j)%10==ans)
   {
    cout<<(!ans?10:ans)<<endl;
    return 0;
   }
 for(int i=0;i<=9;i++)//枚举两种相同的牌
  if(t[i]>=2&&(i+i)%10==ans)
  {
   cout<<(!ans?10:ans)<<endl;
   return 0;
  }
 cout<<0<<endl;
 return 0;
}
```

#### 3. **题解作者：kevin_y (4星)**
- **关键亮点**：
  - 通过预处理和枚举两张牌的组合，判断剩余牌的和是否为10的倍数。
  - 代码简洁，逻辑清晰。
- **个人心得**：
  - “要做一个预处理，保存个位数字出现的情况。”，通过预处理，简化了判断逻辑。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,a[1000001],sum=0,d[11];//d保存个位数字出现的情况。
inline int read(){//快读
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
	return x*f;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();sum+=a[i];
		d[a[i]]++;//为啥不是d[a[i]]=1;因为不知这类牌是否出现两次
	}
	sum=sum%10;if(sum==0)sum=10;//0为牛10
	for(int i=1;i<=10;i++)
	for(int j=1;j<=10;j++)if(d[i]&&d[j])//首先要求这两数出现过
    if(((i==j)&&d[i]>1)||(i!=j))//若两数相同 则需要出现两次
    if((sum==(i+j))||((sum+10)==(i+j))){//加起来个位数相同，代表可以有牛（输出不为0）只要两数之和的个位数字等于sum则其他数一定可以为十的倍数，不懂的可以自己举例子。
    //这句话可以化简为if(sum==(i+j)%10)
		cout<<sum<<endl;return 0;//输出
	}
	cout<<0<<endl;
	return 0;
}
```

### 推荐题目
1. **P1002 过河卒**：考察预处理和动态规划。
2. **P1049 装箱问题**：考察背包问题的变种。
3. **P1060 开心的金明**：考察01背包问题。

---
处理用时：75.86秒
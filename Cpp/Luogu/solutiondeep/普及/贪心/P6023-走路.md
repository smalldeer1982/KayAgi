# 题目信息

# 走路

## 题目背景

小 W 下载了一款运动软件。

## 题目描述

小 W 准备在接下来的 $m$ 天中锻炼，由于他不能走得太多以至于累死（怎么可能呢），所以他这 $m$ 天最多一共只能走 $n$ 步。  
这个运动软件为了激励小 W 走路，推出了 $k$ 种激励措施，每种激励措施都形如“如果你第 $p$ 天中走完了 $q$ 步，那么第 $p$ 天中接下来的每一步都会给你加 $1$ 积分”。**激励措施可以叠加，即走一步你可能可以获得多于 $1$ 积分。**  
现在小 W 想知道，他总计最多可以获取多少积分呢？

## 说明/提示

样例解释：  
只有一种方案，即在第一天走 $5$ 步，第一、二步各获得 $1$ 积分，第三、四步各获得 $2$ 积分，第五步获得 $3$ 积分，总计 $9$ 积分。  
********
数据范围：  
对于 $10\%$ 的数据，$n,m,k\le10$。  
对于 $40\%$ 的数据，$n,m,k \le 10^3$。  
对于 $100\%$ 的数据，$1\le n\le 10^{12}$，$1\le m,k\le 10^5$，$1\le p\le m$，$0\le q\le n$。

## 样例 #1

### 输入

```
5 1 3
1 0
1 2
1 4
```

### 输出

```
9```

# AI分析结果

### 综合分析与结论

本题的核心思路是通过贪心策略，将所有步数集中在一天内行走，以最大化积分。由于激励措施可以叠加，且同一天内每一步获得的积分是递增的，因此将步数集中在一天内可以避免积分的浪费。所有题解都基于这一思路，但在实现细节、代码可读性和优化程度上有所不同。

### 所选高星题解

#### 1. 作者：WYXkk (5星)
- **关键亮点**：思路清晰，代码简洁，直接通过贪心策略计算每一天的积分并取最大值。代码中使用了`rd()`函数进行快速输入，提升了代码的可读性和效率。
- **个人心得**：作者通过简单的数学推导证明了贪心策略的正确性，并指出将所有步数放在同一天可以避免积分的浪费。
- **核心代码**：
```cpp
ll a[100005];
ll n,m,k,mx=0;
int main()
{
    rd(n);rd(m);rd(k);
    F(i,1,k) {ll p=rd();ll q=rd();a[p]+=n-q;}
    F(i,1,m) if(a[i]>=a[mx]) mx=i;
    cout<<a[mx]<<endl;
    return 0;
}
```
- **实现思想**：通过数组`a`记录每一天的积分，遍历所有激励措施并累加积分，最后输出最大积分。

#### 2. 作者：zengzhijie54188 (4星)
- **关键亮点**：思路清晰，代码结构简单，直接模拟每一天的积分计算，并通过`max`函数取最大值。代码中使用了`long long`类型处理大数据，避免了溢出问题。
- **个人心得**：作者强调了将所有步数集中在一天行走的优势，并通过模拟实现了这一思路。
- **核心代码**：
```cpp
long long c[99999999];
long long maxn;
int main()
{
    cin >> n >> m >> k;
    for (int i = 1; i <= k; i++) {
        cin >> a >> b;
        if (n - b > 0) c[a] += (n - b);
    }
    for (int i = 1; i <= m; i++) maxn = max(maxn, c[i]);
    cout << maxn;
    return 0;
}
```
- **实现思想**：通过数组`c`记录每一天的积分，遍历所有激励措施并累加积分，最后输出最大积分。

#### 3. 作者：Lpttor (4星)
- **关键亮点**：通过结构体存储激励措施，并使用排序和逐步计算的方法，确保积分的正确累加。代码结构清晰，逻辑严谨。
- **个人心得**：作者通过逐步计算每一天的积分，确保不会遗漏任何激励措施，并通过排序简化了计算过程。
- **核心代码**：
```cpp
struct quests {
    long long d,q;
};
bool operator< (quests a,quests b){
    return a.d==b.d?a.q<b.q:a.d<b.d;
}
quests arr[100010];
int main(){
    long long m,n,k,nd=0,score=0,mx=0;
    cin>>n>>m>>k;
    for(int i=0;i<k;i++) cin>>arr[i].d>>arr[i].q;
    sort(arr,arr+k);
    for(int i=0;i<k&&arr[i].d<=m;i++){
        if(nd==arr[i].d) score+=(n-arr[i].q);
        else { mx<score&&(mx=score); score=0; nd=arr[i].d; i--; }
    }
    mx<score&&(mx=score);
    cout<<mx<<endl;
    return 0;
}
```
- **实现思想**：通过结构体数组存储激励措施，排序后逐步计算每一天的积分，最后输出最大积分。

### 最优关键思路与技巧

1. **贪心策略**：将所有步数集中在一天内行走，以最大化积分。
2. **数据结构**：使用数组或结构体存储每一天的积分，便于后续计算和比较。
3. **优化技巧**：使用快速输入函数（如`rd()`）提升输入效率，使用`long long`类型避免溢出问题。

### 可拓展之处

- **同类型题**：类似的贪心策略可以应用于其他需要最大化收益的题目，如任务调度、资源分配等。
- **算法套路**：贪心算法在解决最优化问题时非常有效，尤其是在问题具有“局部最优解能导致全局最优解”的性质时。

### 推荐题目

1. **P1090 合并果子**：贪心策略，每次合并最小的两堆果子。
2. **P1223 排队接水**：贪心策略，按照接水时间从短到长排序。
3. **P1803 凌乱的yyy / 线段覆盖**：贪心策略，选择结束时间最早的线段。

### 个人心得总结

- **调试经历**：多位作者提到在实现过程中需要注意数据范围，尤其是`long long`的使用，避免溢出问题。
- **顿悟感想**：通过简单的数学推导和贪心策略，可以快速解决看似复杂的问题，节省比赛时间。

---
处理用时：42.31秒
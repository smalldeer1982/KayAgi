# 题目信息

# [USACO20OPEN] Social Distancing S

## 题目描述

由于高传染性的牛传染病 COWVID-19 的爆发，Farmer John 非常担忧他的奶牛们的健康。

为了限制疾病的传播，Farmer John 的 $N$ 头奶牛（$2\le N\le 10^5$）决定践行“社交距离”，分散到农场的各处。农场的形状如一维数轴，上有 $M$ 个互不相交的区间（$1\le M\le 10^5$），其中有可用来放牧的青草。奶牛们想要使她们位于不同的整数位置，每个位置上均有草，并且最大化 $D$ 的值，其中 $D$ 为最近的两头奶牛之间的距离。请帮助奶牛们求出 $D$ 的最大可能值。

## 说明/提示

### 样例解释
取到 $D=2$ 的一种方式是令奶牛们处在位置 $0$、$2$、$4$、$6$ 和 $9$。

### 子任务
- 测试点 $2$-$3$ 满足 $b\le 10^5$。
- 测试点 $4$-$10$ 没有额外限制。

## 样例 #1

### 输入

```
5 3
0 2
4 7
9 9```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是通过二分搜索来最大化奶牛之间的最小距离，并结合贪心策略进行验证。所有题解都采用了二分搜索的思路，但在具体实现上有所不同，主要体现在 `check` 函数的实现和区间处理的方式上。以下是对各题解的简要分析与评分：

1. **PersistentLife (4星)**  
   - **亮点**：二分搜索结合贪心策略，代码结构清晰，`check` 函数实现简洁。
   - **个人心得**：强调了数轴范围的优化，减少了不必要的计算。

2. **_zy_ (4星)**  
   - **亮点**：详细解释了单调性证明，`check` 函数实现较为直观，代码可读性高。
   - **个人心得**：强调了区间排序的重要性，并提供了详细的贪心策略解释。

3. **kradcigam (4星)**  
   - **亮点**：二分搜索模板清晰，`check` 函数实现简洁，代码结构良好。
   - **个人心得**：强调了二分搜索的通用性，并提供了详细的解释。

### 最优关键思路与技巧

- **二分搜索**：通过二分搜索来寻找最大化的最小距离，复杂度为 $O(\log(\max b_i))$。
- **贪心策略**：在 `check` 函数中，通过贪心策略尽可能多地放置奶牛，确保每头牛之间的距离不小于给定的 $D$。
- **区间处理**：对区间进行排序，确保在 `check` 函数中能够高效地处理每个区间。

### 可拓展之处

- **类似算法套路**：二分搜索结合贪心策略的题目在竞赛中非常常见，如最大化最小值、最小化最大值等问题。
- **数据结构优化**：可以考虑使用更高效的数据结构（如线段树）来优化区间查询和更新操作。

### 推荐题目

1. **P1873 砍树**：二分搜索结合贪心策略，最大化最小值。
2. **P2440 木材加工**：二分搜索结合贪心策略，最小化最大值。
3. **P2678 跳石头**：二分搜索结合贪心策略，最大化最小值。

### 精选题解

#### 1. PersistentLife (4星)

```cpp
bool check() {
    int cur = a[1], cnt = 1;
    for (int i = 2; i <= n; i++) {
        if (cur + mid <= b[cnt]) cur += mid;
        else {
            while (cnt < m && cur + mid > b[cnt]) cnt++;
            if (cur + mid > b[cnt]) return 0;
            if (cur + mid <= a[cnt]) cur = a[cnt];
            else cur += mid;
        }
    }
    return 1;
}
```

#### 2. _zy_ (4星)

```cpp
bool Judge(int x) {
    bool flag = 0;
    int cnt = 1, num = 0;
    int sta = e[++num].l, lst = e[num].r;
    int pos = e[1].l;
    while (lst <= e[m].r && !flag) {
        int p = pos + x;
        if (p <= lst) {
            pos = p;
            cnt++;
            continue;
        }
        while (p > lst) {
            num++;
            if (num > m) { flag = 1; break; }
            sta = e[num].l;
            lst = e[num].r;
            if (p < sta) pos = sta;
            else pos = p;
        }
        cnt++;
        if (cnt > n) return true;
    }
    return false;
}
```

#### 3. kradcigam (4星)

```cpp
bool check(ll x) {
    ll l = 0, ans = 0;
    for (int i = 1; i <= m; i++) {
        l = max(l, a[i].a);
        if (a[i].b >= l) {
            ll X = (a[i].b - l) / x + 1;
            ans = ans + X;
            l = l + X * x;
        }
    }
    return ans >= n;
}
```

### 总结

以上题解均采用了二分搜索结合贪心策略的思路，代码实现简洁且高效。推荐在实际应用中根据具体需求选择合适的实现方式，并结合数据结构优化进一步提升性能。

---
处理用时：35.24秒
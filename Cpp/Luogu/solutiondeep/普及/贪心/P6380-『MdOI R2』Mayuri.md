# 题目信息

# 『MdOI R2』Mayuri

## 题目背景

「万由里……怎么会？为什么你要……」

『我是灵力的结晶体，实施了封印，我当然会消失，不是吗？』

「封印？但是你和我……」

『第一次见面不能封印吗？笨蛋，我可是从大家的灵力里出生的，怎么可能讨厌你？从一出生，我就爱着你。』

「万由里……」

『虽然我竭力不让自己去想，但我一定是很羡慕大家……』

「等一下，万由里，不要消失……」

『但是我还是有一件能向大家炫耀的事，只有我和士道一样……』

「一样？」

『我已经不再是只为了消失而出生的生命。因为我遇见了你……已经足够了。』

「万由里……」

『谢谢你，士道。 』

![](https://cdn.luogu.com.cn/upload/image_hosting/9w6a0deg.png)

## 题目描述

在离开这个世界前，万由里想要寻找属于她的 Lucky Number。

万由里会给出一个数 $a$，以及一个长度为 $b$ 的 01 串 $S$。

简单的说，她的 Lucky Number 是满足以下条件的**正整数** $n$：

 - $n$ 的位数为 $b$ 且不含前导 $0$。

 - 若 $S$ 的第 $i$ 位为 $1$，则 $n$ 的前 $i$ 位组成的数是 $a$ 的倍数，否则 $n$ 的前 $i$ 位组成的数不是 $a$ 的倍数。

对于一个数，前 $i$ 位组成的数是指这个数前 $i$ 个数码依次拼接形成的数。例如 $312311$ 前 $3$ 位组成的数为 $312$，前 $5$ 位组成的数为 $31231$。


现在，请你帮助万由里计算一下，她的 Lucky Number 是多少。

由于满足条件的数可能会有多个，你需要输出**最小**的一个。若不存在，则请输出 `-1`。

## 说明/提示

【帮助与提示】

为方便选手测试代码，本题额外提供一组附加样例供选手使用。

[样例输入](https://www.luogu.com.cn/paste/5gnn8mg0) [样例输出](https://www.luogu.com.cn/paste/sgxjkbjd)

------
【样例解释】

对于样例一，$10$ 是 $2$ 位数，且 $10$ 的前 $1$ 位组成的数 $1$ 不是 $2$ 的倍数，而前 $2$ 位组成的数 $10$ 是 $2$ 的倍数。由于 $10$ 已经是最小的两位数，故不存在比 $10$ 更小的满足条件的数。

对于样例二，我们需要构造一个 $1$ 位数，满足这个 $1$ 位数整除 $10$。显然，这样的数不存在。

---

【数据范围】

**本题采用捆绑测试**


| 子任务编号 | $a \leq$ | $b\le$  | 分值   |
| ---------- | -------- | :------ | ------ |
| Subtask 1  | $10$     | $ 1$    | $20$   |
| Subtask 2  | $10 $    | $2$     | $20$  |
| Subtask 3  | $10 $    | $ 6$    | $20$  |
| Subtask 4  | $ 2$     | $ 18$   | $20$ |
| Subtask 5  | $ 10$    | $ 10^5$ | $20$ |


对于全部数据，保证 $2\le a\le 10$，$1\le b\le 10^5$，$S$ 中只包含 `0` 和 `1`。

## 样例 #1

### 输入

```
2 2
01```

### 输出

```
10```

## 样例 #2

### 输入

```
10 1 
1```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 6
110100```

### 输出

```
601210```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个满足特定条件的数字，且要求该数字最小。题解中主要采用了贪心、DFS、同余优化等思路。贪心算法通过逐位构造数字，确保每一步都选择最小的满足条件的数字，从而保证最终结果最小。DFS则通过递归枚举每一位的可能性，结合剪枝策略来减少搜索空间。同余优化则通过模运算避免了大数计算，提升了算法效率。

### 所选高星题解

#### 1. **作者：BFqwq (赞：36)**
- **星级：5星**
- **关键亮点**：官方题解，思路清晰，代码简洁，优化到位。通过同余优化避免了高精度计算，逐位构造数字，确保每一步都选择最小的满足条件的数字。
- **核心代码**：
  ```cpp
  for(int i=1;i<b;i++){
      now*=10;
      for(int j=0;j<=9;j++)
      if((now+j)%a==0&&c[i]=='1'||(now+j)%a!=0&&c[i]=='0'){
          now+=j;
          now%=a;
          n[i]=j+'0';
          break;
      }
  }
  ```
- **个人心得**：作者提到“感觉做的都比较麻烦”，表明其通过简化思路和代码，找到了更优的解法。

#### 2. **作者：grass8cow (赞：9)**
- **星级：4.5星**
- **关键亮点**：贪心算法，逐位构造数字，确保每一步都选择最小的满足条件的数字。通过模运算避免了大数计算，提升了算法效率。
- **核心代码**：
  ```cpp
  for(int i=1;i<b;i++){
      cin>>c; 
      now=now*10%a;
      if(c=='0'){if(now)cout<<0;else cout<<1,now=1;}
      else cout<<(a-now)%a,now=0;
  }
  ```
- **个人心得**：作者提到“该题妥妥的贪心”，表明其通过贪心算法找到了简洁高效的解法。

#### 3. **作者：Gokix (赞：2)**
- **星级：4星**
- **关键亮点**：通过DFS结合同余优化，逐位构造数字，确保每一步都选择最小的满足条件的数字。通过模运算避免了大数计算，提升了算法效率。
- **核心代码**：
  ```cpp
  void dfs(long long step)
  {
      if(step>b)
      {
          cout<<ans<<endl;
          exit(0);
      }
      long long tmp=ans;
      for(long long i=0;i<=9;i++)
      {
          if(i==0&&step==1) continue;
          if(str[step-1]=='1')
          {
              if((ans*10+i)%a==0)
              {
                  ans=ans*10+i;
                  dfs(step+1);
                  ans=tmp;
              }
          }
          else
          {
              if((ans*10+i)%a!=0)
              {
                  ans=ans*10+i;
                  dfs(step+1);
                  ans=tmp;
              }
          }
      }
  }
  ```
- **个人心得**：作者提到“赛后经两位神仙的提醒我才想明白”，表明其通过学习和优化，找到了更优的解法。

### 最优关键思路或技巧

1. **贪心算法**：逐位构造数字，确保每一步都选择最小的满足条件的数字，从而保证最终结果最小。
2. **同余优化**：通过模运算避免了大数计算，提升了算法效率。
3. **DFS结合剪枝**：通过递归枚举每一位的可能性，结合剪枝策略来减少搜索空间。

### 可拓展之处

1. **同类型题**：类似构造数字的题目，如构造满足特定条件的最大/最小数字。
2. **类似算法套路**：贪心算法、DFS、同余优化等思路可以应用于其他构造类题目。

### 推荐题目

1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)
3. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)

---
处理用时：35.99秒
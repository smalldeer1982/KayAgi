# 题目信息

# 「EZEC-2」异或

## 题目描述

有 $T$ 组询问，每次给定两个正整数 $n,l$，   

你需要构造一个长度为 $l$ 的正整数序列 $a$（编号从 $1$ 至 $l$），   

且满足 $\forall i\in[1,l]$，都有 $a_i\in[1,n]$。

求：

$$\sum_{i=1}^l\sum_{j=1}^{i-1}a_i\oplus a_j$$

的最大值。

为了避免答案过大，对于每组询问，只需要输出这个最大值对 $10^9+7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**   
当 $n=2,l=3$，$a$ 取 $\{1,2,1\}$ 的任一排列时可以得到最大值，为 $(1\oplus2)+(1\oplus1)+(2\oplus1)=6$，易证明此时原式有最大值。

---
**【数据规模与约定】**
| 测试点编号 | $T\le$ | $n\le$ | $l\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim5$ | $1$ | $10$ | $5$ |
| $6$ | $5\times 10^5$ | $10^{12}$ | $2$ |
| $7$ | $5\times 10^5$ | $10^{12}$ | $3$ |
| $8\sim10$ | $5\times 10^5$ | $10^{12}$ | $10^5$ |

对于 $100\%$ 的数据，满足 $1\le T\le 5\times10^5$，$1\le n\le 10^{12}$，$2\le l \le 10^5$。


---
**【提示】**

1. 「$\oplus$」是按位异或符号。如果您不知道什么是按位异或，可以参考[这里](https://oi-wiki.org/math/bit/#_1)。
2. 取模是一种运算，$a$ 对 $b$ 取模代表将 $a$ 赋值为 $a$ 除以 $b$ 所得到的余数。  
在 C++ / Python 中的取模符号为 `%`，在 Pascal 中的取模符号为 `mod`。
3. $\sum$ 是求和符号。如果您不知道什么是 $\sum$ 符号，可以参考[这里](https://baike.baidu.com/item/∑/1233796?fr=aladdin)。
4. 请注意数据的读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
1
2 3
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
114 514
1919 180
```

### 输出

```
8388223
16580700```

# AI分析结果

### 综合分析与结论

本题的核心在于通过构造序列，使得所有元素两两异或的和最大化。由于异或操作是按位独立的，因此可以通过按位分析来简化问题。大多数题解都采用了按位分析的思路，通过计算每一位的最大贡献来求解最终答案。关键点在于如何构造序列，使得每一位的贡献最大化，通常是通过让每一位的1和0的数量尽可能接近来实现。

### 所选高星题解

#### 1. 作者：dead_X (5星)
- **关键亮点**：详细解释了按位分析的思路，并通过数学推导证明了如何最大化每一位的贡献。代码简洁且高效，直接通过位运算和数学公式求解。
- **个人心得**：作者提到在比赛中快速完成了题目，并给出了构造序列的具体方法，证明了其思路的正确性。

```cpp
long long now=1LL<<40,res=0;
while(now)
{
    now>>=1;
    if(x<now) continue;
    res+=now*t*(y-t);
}
printf("%lld\n",res%1000000007LL);
```

#### 2. 作者：李白莘莘学子 (4星)
- **关键亮点**：通过类比两两握手问题，直观地解释了异或和的计算方式，并详细推导了每一位的最大贡献。代码实现清晰，逻辑严谨。
- **个人心得**：作者提到通过类比问题简化了理解，并给出了具体的构造方法，使得思路更加清晰。

```cpp
long long big=1ll<<40;
while(big)
{
    big>>=1;
    if(n<big)continue;
    ans+=big*mid*(l-mid);
    ans%=modd;
}
printf("%lld\n",ans);
```

#### 3. 作者：君のNOIP。 (4星)
- **关键亮点**：通过爆搜找规律，发现了每一位的1和0数量应尽可能接近的规律，并给出了具体的构造方法。代码实现简洁，逻辑清晰。
- **个人心得**：作者通过爆搜验证了规律的正确性，并给出了具体的构造方法，使得思路更加直观。

```cpp
long long now=1LL<<40,res=0;
while(now)
{
    now>>=1;
    if(x<now) continue;
    res+=now*t*(y-t);
}
printf("%lld\n",res%1000000007LL);
```

### 最优关键思路与技巧

1. **按位分析**：将问题分解为每一位的贡献，通过计算每一位的最大贡献来求解最终答案。
2. **构造序列**：通过让每一位的1和0的数量尽可能接近，使得每一位的贡献最大化。
3. **数学推导**：通过数学公式推导出每一位的最大贡献，简化了问题的求解过程。

### 可拓展之处

- **类似问题**：可以扩展到其他位运算问题，如与、或等操作的最大化或最小化问题。
- **构造序列**：在需要构造序列使得某种操作结果最大化或最小化的问题中，可以通过类似的方法进行构造。

### 推荐题目

1. [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)
2. [P6102 [EER2] 数论](https://www.luogu.com.cn/problem/P6102)
3. [P2115 [USACO14MAR] Sabotage G](https://www.luogu.com.cn/problem/P2115)

---
处理用时：29.91秒
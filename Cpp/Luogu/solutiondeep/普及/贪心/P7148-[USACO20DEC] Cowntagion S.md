# 题目信息

# [USACO20DEC] Cowntagion S

## 题目描述

Farmer John 和他的农民团队为了控制牛传染病 COWVID-19 在他们农场间的传播而夜以继日地工作。

他们共同监控着 $N$ 个农场（$1≤N≤10^5$），编号为 $1…N$。农场间由 $N−1$ 条道路连接，使得每个农场都可以从农场 $1$ 出发经过一些道路到达。

很不幸，农场 $1$ 中的一头奶牛的 COWVID-19 检测呈阳性。暂时这个农场的其他奶牛以及其他农场的所有奶牛都还没有染上疾病。然而，根据这个疾病通过接触传播的特性，Farmer John 推测每一天都会有以下不利的事件之一发生：

(1) 在一个农场内，「超级传播者」导致该农场感染 COWVID-19 的奶牛数量翻倍；或者

(2) 一头感染 COWVID-19 的奶牛从一个农场沿道路去往了一个相邻的农场。

Farmer John 担心疫情会很快爆发。请帮助 Farmer John 求出每个农场内均有至少一头奶牛感染疾病所需经过的最小天数。 

## 说明/提示

该样例对应的一个可能的事件序列如下：农场 $1$ 内染病的奶牛数量翻倍再翻倍，使得两天后农场 $1$ 内有 $4$ 头染病的奶牛。在此后 $3$ 天，分别有一头染病的奶牛从农场 $1$ 去往农场 $2$、$3$ 和 $4$。$5$ 天过后每个农场均有至少 $1$ 头染病的奶牛。


 - 测试点 1-4 中，每个农场均直接与农场 $1$ 相连（除农场 $1$ 外）。
 - 测试点 5-7 中，农场 $2…N$ 均至多与两条道路相连。
 - 测试点 8-15 没有额外限制。

供题：Dhruv Rohatgi 

## 样例 #1

### 输入

```
4
1 2
1 3
1 4```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在树形结构中通过翻倍和传播操作，使得所有节点都至少有一个感染者，且操作天数最少。大多数题解采用了贪心策略，即每个节点在翻倍到足够数量后，再向下传播。这种策略的核心思想是尽量减少传播的次数，优先通过翻倍操作来增加感染者的数量。

### 所选高分题解

#### 1. **作者：wsyhb (赞：8)**
- **星级：5星**
- **关键亮点**：思路清晰，代码简洁，通过DFS遍历树并统计每个节点的子节点数，计算翻倍和传播的天数。代码可读性强，逻辑严谨。
- **核心实现思想**：使用DFS遍历树，统计每个节点的子节点数，计算翻倍和传播的天数。
- **代码片段**：
  ```cpp
  void dfs(int x, int fa) {
      int son = 0;
      for (int i = head[x]; i; i = e[i].nxt) {
          int to = e[i].to;
          if (to == fa) continue;
          son++;
          dfs(to, x);
      }
      ans += son;
      int tmp = 1;
      while (tmp <= son) {
          ans++;
          tmp *= 2;
      }
  }
  ```

#### 2. **作者：Skies (赞：6)**
- **星级：4星**
- **关键亮点**：通过链式前向星建图，使用DFS遍历树，计算每个节点的翻倍和传播天数。代码结构清晰，逻辑明确。
- **核心实现思想**：使用链式前向星建图，DFS遍历树，计算每个节点的翻倍和传播天数。
- **代码片段**：
  ```cpp
  void dfs(int x, int fa) {
      int lo = -1;
      if (x == 1) lo++;
      lo += si[x];
      p += lo;
      int u = 0;
      while (1) {
          if ((1 << u) > lo) break;
          u++;
      }
      p += u;
      for (int i = head[x]; i; i = ed[i].nex) {
          int y = ed[i].to;
          if (y != fa) dfs(y, x);
      }
  }
  ```

#### 3. **作者：ETHANK (赞：2)**
- **星级：4星**
- **关键亮点**：通过预处理Log表，简化了翻倍天数的计算，代码简洁高效。
- **核心实现思想**：预处理Log表，统计每个节点的子节点数，计算翻倍和传播的天数。
- **代码片段**：
  ```cpp
  for (int i = 1; i <= n; i++) Log[i] = Log[i >> 1] + 1;
  for (int i = 2; i <= n; i++) if (i & (i - 1)) ++Log[i];
  ans = n - 1;
  for (int i = 1; i <= n; i++) ans += Log[son[i] + 1];
  ```

### 最优关键思路与技巧
1. **贪心策略**：每个节点在翻倍到足够数量后，再向下传播，以减少传播次数。
2. **DFS遍历**：通过DFS遍历树，统计每个节点的子节点数，计算翻倍和传播的天数。
3. **预处理Log表**：通过预处理Log表，简化翻倍天数的计算，提高代码效率。

### 可拓展之处
1. **类似题目**：可以扩展到其他树形结构的问题，如最小生成树、最短路径等。
2. **优化技巧**：可以通过预处理或记忆化搜索来优化计算过程，减少时间复杂度。

### 推荐题目
1. **P3379 【模板】最近公共祖先（LCA）**
2. **P3384 【模板】轻重链剖分**
3. **P3372 【模板】线段树 1**

### 个人心得摘录
- **作者：wsyhb**：通过DFS遍历树，统计每个节点的子节点数，计算翻倍和传播的天数，代码简洁高效。
- **作者：Skies**：使用链式前向星建图，DFS遍历树，计算每个节点的翻倍和传播天数，逻辑明确。
- **作者：ETHANK**：通过预处理Log表，简化了翻倍天数的计算，代码简洁高效。

---
处理用时：40.82秒
# 题目信息

# 「PMOI-4」生成树

## 题目背景

> 题目正解不会很难，反正很难的也必不会做，所以宁愿相信题目都是善良的。

——command_block 《考前小贴士》

djy 出了一道生成树的题，然后发现做法假了，就把这个题改了一下，作为这场比赛的 B。

## 题目描述

给定 $n$ 个数，第 $i$ 个数的原始权值是 $w_i$，你要按照某种顺序将这些数依次选择。

若当前是第 $i$ 次选数，选择的**原始权值**为 $k$，则其他所有**未被选过**的数的权值均加上 $(-1)^{i+k+1} \times k$。

你需要求出一种选数方案，使得选出的 $n$ 个数**最终**的**权值**和**最大**。

## 说明/提示

【样例解释】

依次选择**编号**为 $\{7,6,5,3,4,1,2\}$ 的数即可。

【数据范围】

**本题采用捆绑测试**。

- Subtask 1（20pts）：$n \le 7$。
- Subtask 2（30pts）：$n \le  10^3$。
- Subtask 3（30pts）：保证所有的 $w_i \ge 0$ 或所有的 $w_i \le 0$。
- Subtask 4（20pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1 \le n \le 10^5,-10^9 \le w \le 10^9$。

## 样例 #1

### 输入

```
7
1 -1 -2 2 -3 3 4```

### 输出

```
66```

# AI分析结果

### 综合分析与结论

本题的核心在于通过贪心策略最大化选数的最终权值和。各题解的主要思路集中在如何通过排序和分类讨论来优化贡献的计算。大多数题解通过将数分为奇偶两类，并根据其正负性进一步分类，然后按照绝对值大小排序，最后通过交替选择来最大化贡献。部分题解还引入了排序不等式等数学工具来简化问题。

### 所选高星题解

#### 1. 作者：lgswdn_SA (赞：20)  
**星级：5星**  
**关键亮点：**  
- 通过拆分贡献公式，将问题转化为两个序列的乘积和最大化问题，利用排序不等式直接得出最优解。
- 代码简洁，逻辑清晰，避免了复杂的分类讨论。

**核心代码：**
```cpp
int n,ans;
vector<int>f,g;

signed main() {
    n=read(); f.resize(n), g.resize(n);
    rep(i,1,n) {
        int w=read(); ans+=w;
        w=w*(w%2?-1:1); f[i-1]=w;
        if((i+1)%2) g[i-1]=-(n-i);
        else g[i-1]=n-i;
    }
    sort(f.begin(),f.end()), sort(g.begin(),g.end());
    rep(i,0,n-1) ans+=f[i]*g[i];
    printf("%lld\n",ans);
    return 0;
}
```

#### 2. 作者：Acc_Robin (赞：12)  
**星级：4星**  
**关键亮点：**  
- 通过将贡献公式拆分为两个序列的乘积和，利用排序不等式直接求解。
- 代码实现简洁，逻辑清晰，避免了复杂的分类讨论。

**核心代码：**
```cpp
namespace Acc{
    using ll=long long;
    const int N=1e5+9;
    int a[N],b[N];
    ll r;
    void work(){
        int n,i,sav=1;
        for(cin>>n,i=1;i<=n;++i)cin>>a[i],r+=a[i],a[i]=a[i]*(abs(a[i]%2)==1?1:-1);
        for(sav=-1,i=1;i<=n;++i,sav=-sav)b[i]=(n-i)*sav;
        sort(a+1,a+n+1), sort(b+1,b+n+1);
        for(i=1;i<=n;++i)r+=1ll*a[i]*b[i];
        cout<<r<<'\n';
    }
}
```

#### 3. 作者：张晟轩 (赞：1)  
**星级：4星**  
**关键亮点：**  
- 利用排序不等式将问题转化为两个序列的乘积和最大化问题，思路清晰。
- 代码简洁，逻辑清晰，避免了复杂的分类讨论。

**核心代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],b[100005];
long long ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%lld",&a[i]);ans+=a[i];
        a[i]*=(a[i]%2==0)?1:-1;
        b[i]=(n-i)*((i+1)%2==0?1:-1);
    }
    sort(a+1,a+n+1);
    sort(b+1,b+1+n);
    for(int i=1;i<=n;++i) ans+=1ll*a[i]*b[i];
    printf("%lld\n",ans);
    return 0;
}
```

### 最优关键思路与技巧

1. **排序不等式的应用**：将贡献公式拆分为两个序列的乘积和，利用排序不等式直接得出最优解。
2. **分类讨论与贪心策略**：将数分为奇偶两类，并根据其正负性进一步分类，按照绝对值大小排序，最后通过交替选择来最大化贡献。
3. **代码简洁与逻辑清晰**：通过合理的拆分和排序，避免了复杂的分类讨论，代码实现简洁高效。

### 可拓展之处

本题的贪心策略和排序不等式的应用可以推广到其他需要最大化或最小化某种贡献的问题中。类似的问题包括：

1. **最大子序列和问题**：通过贪心策略选择子序列，使得和最大。
2. **任务调度问题**：通过排序和贪心策略选择任务的执行顺序，使得总收益最大。
3. **背包问题**：通过贪心策略选择物品，使得总价值最大。

### 推荐题目

1. **P1004 最大子序列和**：考察贪心策略的应用。
2. **P1090 合并果子**：考察贪心策略和优先队列的应用。
3. **P1048 采药**：考察背包问题和贪心策略的应用。

### 个人心得摘录

- **调试经历**：部分题解中提到在实现过程中遇到了一些分类讨论的复杂性，通过引入排序不等式简化了问题。
- **顿悟感想**：通过拆分贡献公式，将问题转化为两个序列的乘积和最大化问题，思路清晰，代码简洁。

---
处理用时：47.51秒
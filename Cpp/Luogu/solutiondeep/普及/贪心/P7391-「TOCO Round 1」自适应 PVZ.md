# 题目信息

# 「TOCO Round 1」自适应 PVZ

## 题目背景

爆切今天的毒瘤三维计算几何后，$\color{black}\texttt{Q}\color{red}\texttt{wQcOrZ}$ 打开了某个有趣的 exe 文件。

## 题目描述

可怜的 $\color{black}\texttt Q\color{red}\texttt{wQcOrZ}$ 在草坪上遇到了 $n$ 只僵尸，第 $i$ 只僵尸在 $l_i$ 时刻出现，会在 $r_i$ 时刻走进房子。

$\color{black}\texttt Q\color{red}\texttt{wQcOrZ}$ 手头有 $m$ 个豌豆射手。若一个豌豆射手在 $l_i$ 至 $r_i$ 时刻（不包括两个端点）持续攻击 $i$ 僵尸则可以杀死 $i$ 僵尸，但在攻击过程中不能攻击另外两只僵尸且攻击的僵尸不能更换。

现在 $\color{black}\texttt Q\color{red}\texttt{wQcOrZ}$ 想知道在合理的安排下，最少有几只僵尸会进入他的房子。

## 说明/提示

对于 $30\%$ 的数据，$n,m\leq 6$。  
对于 $60\%$ 的数据，$n,m\leq 10^3$。  
对于另外 $20\%$ 的数据，$m\geq n$。  
对于 $100\%$ 的数据，$1\leq n,m\leq 2\times 10^5$，$1\leq l_i<r_i\leq 10^9$。

## 样例 #1

### 输入

```
2 1
1 2
3 4```

### 输出

```
0```

## 样例 #2

### 输入

```
3 2
1 3
1 3
2 4```

### 输出

```
1```

## 样例 #3

### 输入

```
2 1
1 3
3 5```

### 输出

```
0```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地安排豌豆射手攻击僵尸，以最小化进入房子的僵尸数量。题解中主要采用了贪心算法，并结合了多种数据结构（如 `multiset`、平衡树等）来优化查询和更新操作。大部分题解的思路相似，均按照僵尸的右端点排序，并利用数据结构维护豌豆射手的可用时间。然而，部分题解在代码实现和优化上存在差异，导致其质量和可读性有所不同。

### 所选高星题解

#### 1. 作者：吴思诚 (赞：9)  
**星级：5星**  
**关键亮点：**  
- 思路清晰，详细解释了贪心策略和数据结构的选择。
- 代码简洁且高效，使用了 `multiset` 来维护豌豆射手的可用时间，操作复杂度为 $O(n \log n)$。
- 提供了对边界情况的处理，代码鲁棒性强。

**核心代码：**
```cpp
multiset<int> s;
for (int i = 1; i <= n; i++) {
    auto it = s.upper_bound(z[i].l);
    if (it != s.begin()) {
        it--;
        s.erase(it);
        s.insert(z[i].r);
    } else {
        if (s.size() + 1 > m) ans++;
        else s.insert(z[i].r);
    }
}
```
**核心思想：**  
通过 `multiset` 维护豌豆射手的可用时间，每次选择最早可用的射手攻击当前僵尸，并更新其可用时间。

#### 2. 作者：sunrise1024 (赞：6)  
**星级：4星**  
**关键亮点：**  
- 详细讨论了三种情况，并提出了使用平衡树来优化查询和更新操作。
- 代码实现较为复杂，但思路清晰，适合对平衡树有一定了解的读者。

**核心代码：**
```cpp
for (int i = 1; i <= n; i++) {
    if (m != 0) {
        m--;
        Insert(root, a[i].r);
        continue;
    }
    if (ho(0) <= a[i].l) {
        de(root, ho(0));
        Insert(root, a[i].r);
        continue;
    }
    ans++;
    if (qi(Inf) > a[i].r) {
        de(root, qi(Inf));
        Insert(root, a[i].r);
    }
}
```
**核心思想：**  
使用平衡树维护豌豆射手的可用时间，优先选择最早可用的射手攻击僵尸，并更新其可用时间。

#### 3. 作者：liaoxingrui (赞：3)  
**星级：4星**  
**关键亮点：**  
- 思路清晰，代码简洁，使用了 `multiset` 来维护豌豆射手的可用时间。
- 提供了对边界情况的处理，代码鲁棒性强。

**核心代码：**
```cpp
multiset<int> q;
for (int i = 1; i <= n; i++) {
    auto it = q.upper_bound(a[i].l);
    if (it != q.begin()) {
        it--;
        q.erase(it);
        q.insert(a[i].r);
    } else if (q.size() == m) {
        ans++;
    } else {
        q.insert(a[i].r);
    }
}
```
**核心思想：**  
通过 `multiset` 维护豌豆射手的可用时间，每次选择最早可用的射手攻击当前僵尸，并更新其可用时间。

### 最优关键思路与技巧

1. **贪心策略**：按照僵尸的右端点排序，优先攻击结束时间早的僵尸，以最大化豌豆射手的利用率。
2. **数据结构选择**：使用 `multiset` 或平衡树来维护豌豆射手的可用时间，确保每次查询和更新操作的高效性。
3. **边界处理**：在处理僵尸时，需考虑豌豆射手的数量是否足够，以及是否有可用的射手来攻击当前僵尸。

### 可拓展之处

- **类似问题**：本题的思路可以推广到其他资源分配问题，如任务调度、区间覆盖等。
- **数据结构拓展**：除了 `multiset` 和平衡树，还可以考虑使用堆或其他高效数据结构来优化查询和更新操作。

### 推荐题目

1. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)
2. [P1083 借教室](https://www.luogu.com.cn/problem/P1083)
3. [P2255 [USACO14JAN] Recording the Moolympics S](https://www.luogu.com.cn/problem/P2255)

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中遇到平衡树常数较大的问题，最终通过调整平衡因子优化了性能。
- **踩坑教训**：在处理边界情况时，需特别注意僵尸的出现时间和豌豆射手的可用时间之间的关系，避免遗漏某些情况。
- **顿悟感想**：通过贪心策略和数据结构的结合，能够有效解决复杂的资源分配问题，关键在于选择合适的数据结构来优化操作。

---
处理用时：43.09秒
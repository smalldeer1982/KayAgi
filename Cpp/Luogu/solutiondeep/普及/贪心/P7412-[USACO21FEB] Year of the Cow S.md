# 题目信息

# [USACO21FEB] Year of the Cow S

## 题目描述

Farmer John 的奶牛们得知最近正在庆祝牛年的到来时十分兴奋。牛年总是奶牛们的最爱。

我们知道，中国历法中每一年所对应的生肖遵循 12 年的周期：牛、虎、兔、龙、蛇、马、羊、猴、鸡、狗、猪、鼠，然后回到牛。而鲜为人知的事实是每当牛年来临时神秘的时间之门将会打开，使得奶牛们可以穿越时空前往任意过去或将来的牛年。

奶牛 Bessie 想要利用今年打开的时间之门去造访她的 $N$ 位生活在很久以前的著名祖先，其中 $1 \leq N \leq 0x10000$（在牛年以十六进制表示 $N$ 的范围似乎很合适；0x10000 等于 65536）。

不幸的是，时空旅行多了会使 Bessie 感到头晕，所以她希望至多进行 $K$ 次时空穿越（$1 \leq K \leq N$）。请帮助 Bessie 求出她至多进行 $K$ 次时空穿越时，她造访所有祖先并回到当前年份至少需要花费的年数。

如果在某个牛年 Bessie 不想要使用时空之门，她可以不使用。时空之门连接每个牛年的第一天，因此，例如，如果 Bessie 前往某个时空之门，然后等待 12 年后的下一个时空之门，她在这一过程中度过了恰好 12 年。Bessie 从今年的第一天开始她的旅行，所以她可以立刻进行时空穿越。所有 Bessie 的祖先都不生活在牛年。


## 说明/提示

一种 Bessie 在 36 年内造访所有祖先并返回的方式如下：

 - 进入时空之门，回到 48 年前。
 - 等待 12 年，然后进入 36 年前的时空之门，回到 108 年前。
 - 等待 24 年，然后进入 84 年前的时空之门，回到当前年份。

供题：Brian Dean，David Yang

## 样例 #1

### 输入

```
5 3
101
85
100
46
95```

### 输出

```
36```

# AI分析结果

### 综合分析与结论

本题的核心在于如何通过贪心策略，利用有限的时空穿越次数（$K$ 次）最小化 Bessie 访问所有祖先并返回当前年份的总年数。所有题解都采用了贪心算法，核心思路是将年份按 12 年周期分段，计算各段之间的距离，并通过优先队列或排序选择最远的 $K-1$ 个距离进行跳跃，从而减少总年数。

### 所选高分题解

#### 1. **作者：feicheng (赞：14)**  
**星级：4.5**  
**关键亮点：**  
- 通过优先队列存储时间差，贪心地选择最远的 $K-1$ 个距离进行跳跃，思路清晰。
- 代码简洁，逻辑明确，优先队列的使用非常巧妙。
- 通过 `tim` 数组记录必须经过的时间段，避免了重复计算。

**核心代码：**
```cpp
for(ri i=1;i<=cnt;++i) {
    if(tim[i]-tim[i-1]!=1) Q.push(tim[i]-tim[i-1]-1); // 计算时间差
}
for(ri i=1;i<=k&&!Q.empty();++i) Q.pop(); // 选取k个点跳过
int res = cnt*12; // 有cnt个时间段必须经过
while(!Q.empty()) {
    res += Q.top()*12; // 这些时间差必须经过，所以要加12
    Q.pop();
}
cout << res;
```

#### 2. **作者：Alarm5854 (赞：5)**  
**星级：4.0**  
**关键亮点：**  
- 将年份按 12 年周期分段，通过排序和贪心策略选择最远的 $K-1$ 个距离进行跳跃。
- 代码结构清晰，逻辑简单，易于理解。
- 通过 `b` 数组记录相邻年份的差值，排序后选择最大的 $K-1$ 个差值进行跳跃。

**核心代码：**
```cpp
for(int i=0;i<n;++i)
    b[i]=a[i]-a[i+1]; // 计算相邻年份的差值
sort(b,b+n+1); // 排序
for(int i=0;i<k-1;++i){
    if(!b[i]) break; // 当b[i]=0的时候，直接break
    ans+=(b[i]+1)*12; // 加上差值对应的年数
}
```

#### 3. **作者：ZillionX (赞：1)**  
**星级：4.0**  
**关键亮点：**  
- 通过 `set` 和 `multiset` 数据结构进行排序和选择，代码简洁高效。
- 通过贪心策略选择最大的 $K-1$ 个差值进行跳跃，思路清晰。
- 代码实现较为优化，使用了 STL 容器，提升了代码的可读性和效率。

**核心代码：**
```cpp
for (set<int>::iterator i=s.begin();i!=lp;i++)
    if (i==s.begin()) t.insert(*i-1);
    else tp=i,tp--,t.insert(*i-*tp-1); // 计算差值并插入multiset
int p=0;
for (multiset<int>::iterator i=t.begin();i!=t.end();i++)
    if (++p<=k-1) Ret-=*i*12; // 选择最大的k-1个差值进行跳跃
```

### 最优关键思路与技巧

1. **贪心策略：** 通过优先选择最远的 $K-1$ 个距离进行跳跃，减少总年数。
2. **年份分段：** 将年份按 12 年周期分段，简化问题。
3. **数据结构优化：** 使用优先队列或 `multiset` 来高效选择最大的 $K-1$ 个差值。

### 可拓展之处

- **类似题目：** 类似贪心策略的题目可以扩展到其他需要最小化跳跃次数或距离的问题，如最短路径、区间覆盖等。
- **算法套路：** 贪心算法结合优先队列或排序的选择策略，可以应用于多种优化问题。

### 推荐题目

1. **P1090 [NOIP2004 提高组] 合并果子**  
   **题号：P1090**  
   **考察点：贪心、优先队列**

2. **P1223 [NOIP2010 提高组] 关路灯**  
   **题号：P1223**  
   **考察点：贪心、区间覆盖**

3. **P1080 [NOIP2012 提高组] 国王游戏**  
   **题号：P1080**  
   **考察点：贪心、排序**

### 个人心得摘录

- **feicheng：** "通过优先队列来存储最远的k个距离，贪心地选择跳过这些距离，减少了总年数。"  
  **总结：** 优先队列的使用是本题的关键，能够高效地选择最远的距离进行跳跃。

- **Alarm5854：** "将年份按12年周期分段，通过排序和贪心策略选择最远的k-1个距离进行跳跃。"  
  **总结：** 年份分段和排序是简化问题的关键，贪心策略的应用使得问题迎刃而解。

---
处理用时：44.50秒
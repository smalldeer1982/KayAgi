# 题目信息

# 『JROI-2』Shelter

## 题目背景

And it's a long way forward        
So trust in me       
I'll give them shelter like you've done for me       
And I know, I'm not alone         
You'll be watching over us       
Until ...        

一个小女孩斜躺在一个驾驶舱的椅子上，长发从肩膀上飘落到地上。     
她的嘴角绽放出微笑，身旁的显示屏写着 “返回 第三行星”。       
她怀里的泰迪熊身上写着她的名字，Rin。

—— [Shelter](https://www.bilibili.com/video/BV1ys41147Gv)

---



## 题目描述

Rin 和爸爸还在地球上时，他们经常玩一个石子游戏。

爸爸摆出了 $n$ 堆石子，这 $n$ 堆石子编号为 $1$ 到 $n$。

游戏规则是这样的，每次 Rin 可以抓取石子，有两种抓取方式：

- 选择一个数 $i$，把第 $i$ 堆石子抓取走，代价为 $i \times p$。
- 选择两个数 $i,j$，把第 $i$ 堆和第 $j$ 堆石子抓走，代价为 $|i-j| \times q$。

其中 $p,q$ 为爸爸提前定好的常数。

Rin 想知道，抓取完所有石子至少需要多少代价。

还剩 1919810114514 秒第三行星的灾难就要降临了，爸爸还需要 1919810114513.7 秒的时间把 Rin 安放到驾驶舱里，并启动机器让 Rin 进入 “Shelter” 里，因此，你只有 0.3 秒的时间帮助 Rin 算出这个结果哦！

## 说明/提示

#### 样例 1 解释

第一组数据：

1. 利用第一个操作，拿走第 $1$ 堆石子，代价为 $1 \times 2=2$。
2. 利用第二个操作，拿走第 $2,3$ 堆石子，代价为 $|2-3| \times 3=3$。
3. 利用第二个操作，拿走第 $4,5$ 堆石子，代价为 $|4-5| \times 3=3$。

最小代价为 $2+3+3=8$。

第二组数据：

1. 利用第一个操作，拿走第 $1$ 堆石子，代价为 $1 \times 1=1$。
2. 利用第一个操作，拿走第 $2$ 堆石子，代价为 $2 \times 1=2$。
3. 利用第二个操作，拿走第 $3,4$ 堆石子，代价为 $|3-4| \times 5=5$。

最小代价为 $1+2+5=8$。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（1 pts）：$p,q =0$。
- Subtask 2（1 pts）：$n=1$。
- Subtask 3（30 pts）：$T \le 5 \times 10^4$，$n \le 5 \times 10^5$。
- Subtask 4（33 pts）：$T \le 10^6$，$n \le 5 \times 10^5$。
- Subtask 5（35 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10^9$，$0 \le p,q \le 100$，$1 \le T \le 10^6$。

附件中的 Extra Example 满足 $T=10^4$，可供调试使用。


-----
Source：[JROI-2 Summer Fun Round](https://www.luogu.com.cn/contest/30241) - T1

Idea&Sol：[一只书虫仔](/user/114914)

Std&Data：[Tony2](/user/171288)

Retest：[Cocoly1990](/user/183026)

## 样例 #1

### 输入

```
2
5 2 3
4 1 5```

### 输出

```
8
8```

# AI分析结果

### 综合分析与结论

该题目要求通过两种操作方式（单独取石子或成对取石子）来最小化总代价。题解中主要涉及以下思路：

1. **贪心策略**：大多数题解都采用了贪心策略，即尽可能使用代价较低的操作方式，尤其是成对取石子时选择相邻的石子堆。
2. **二分查找**：部分题解通过二分查找来确定从哪个位置开始使用成对取石子的操作，以优化时间复杂度。
3. **数学推导**：部分题解通过数学公式推导出最优解，避免了复杂的循环或递归，直接计算出结果。
4. **边界处理**：几乎所有题解都考虑了边界情况，如 `p=0` 或 `n=1` 时的特判。

### 所选高星题解

#### 1. **CSP_Sept (5星)**
- **关键亮点**：
  - 通过数学推导直接计算出最优解，避免了复杂的循环或递归。
  - 代码简洁且高效，时间复杂度为 `O(T)`，适合大规模数据。
  - 详细解释了何时开始使用成对取石子的操作，逻辑清晰。
- **核心代码**：
  ```cpp
  ll x = q / p;
  x = (x - 1) / 2;
  ll res = n - x;
  ll ans = 0;
  if(res % 2) x++, res--;
  ans = x * p;
  ans += (x - 1) * x * p / 2;
  ans += (res / 2) * q;
  printf("%lld\n", ans);
  ```
  **核心思想**：通过数学公式计算出从哪个位置开始使用成对取石子的操作，并直接计算出总代价。

#### 2. **int_R (4星)**
- **关键亮点**：
  - 使用二分查找来确定最优的 `x`，使得从 `x` 开始使用成对取石子的操作。
  - 代码结构清晰，逻辑严谨，适合对二分查找不熟悉的读者学习。
  - 详细解释了单谷函数的性质，并给出了二分查找的实现。
- **核心代码**：
  ```cpp
  while(l<r)
  {
      mid=(l+r)>>1;
      if(mid-1>=0&&f(mid-1)<f(mid)) r=mid-1;
      else if(mid+1<=n/2&&f(mid+1)<f(mid)) l=mid+1;
      else l=r=mid;
  }
  printf("%lld\n",f(l));
  ```
  **核心思想**：通过二分查找找到使总代价最小的 `x`，并利用单谷函数的性质进行优化。

#### 3. **ricky0916 (4星)**
- **关键亮点**：
  - 通过数学推导和不等式求解，直接计算出最优的 `d`，避免了复杂的循环。
  - 代码简洁且高效，适合大规模数据。
  - 详细解释了如何通过不等式求解最优的 `d`，逻辑清晰。
- **核心代码**：
  ```cpp
  int d,lf=(1ll*(2*n-1)*p-q)/(4*p),rf=(1ll*(2*n+3)*p-q)/(4*p);
  if(rf<=0) d=0;
  else if(lf>=n/2) d=n/2;
  else d=rf;
  we(1ll*d*q+1ll*(n-2*d)*(n-2*d+1)/2*p);
  ```
  **核心思想**：通过不等式求解出最优的 `d`，并直接计算出总代价。

### 最优关键思路与技巧

1. **贪心策略**：优先使用代价较低的操作方式，尤其是成对取石子时选择相邻的石子堆。
2. **数学推导**：通过数学公式直接计算出最优解，避免复杂的循环或递归。
3. **二分查找**：通过二分查找确定从哪个位置开始使用成对取石子的操作，优化时间复杂度。
4. **边界处理**：考虑 `p=0` 或 `n=1` 等边界情况，确保代码的鲁棒性。

### 可拓展之处

- **类似问题**：类似的问题可以扩展到其他需要选择最优操作序列的题目，如背包问题、任务调度问题等。
- **算法套路**：贪心策略和二分查找是解决此类问题的常用套路，可以应用到其他类似的问题中。

### 推荐题目

1. **P1004 石子合并**：考察贪心策略和动态规划。
2. **P1880 石子合并**：考察区间动态规划和贪心策略。
3. **P1048 采药**：考察背包问题和贪心策略。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中遇到边界问题，如 `p=0` 或 `n=1` 时的特判，提醒我们在编写代码时要特别注意边界情况。
- **顿悟感想**：通过数学推导直接计算出最优解，避免了复杂的循环或递归，这种方法在时间紧迫的竞赛中非常实用。

---
处理用时：42.55秒
# 题目信息

# 「小窝 R3」心の記憶

## 题目背景

> 淡い夕暮れ飲み込まれて  
「君」の消えかけて姿を  
忘れさせるように走ってた   
新しい平和の世界に  
——[《心の記憶》](https://music.163.com/song?id=1847928316)

## 题目描述

- 本题中「**子串**」的定义如下：

字符串 $S$ 的子串是 $S$ 中**连续**的任意个字符组成的字符串。$S$ 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S(l,r)$（$1 \leq l \leq r \leq |S |,|S|$ 表示 $S$ 的长度）。

- 本题中「**子序列**」的定义如下：

对于字符串 $S$ 和一个长度为 $n$ 的严格单调递增数列 $k_1,k_2,\cdots,k_n(\forall 1\le i\le n,1\le k_i\le |S|)$，$S_{k_1},S_{k_2},\cdots,S_{k_n}$ 所组成的字符串即为 $S$ 的子序列。

---------------

现有 $T$ 次询问。
每次询问给定一个长度为 $n$ 的 01 串，记为 $A$。回答应是一个字符串 $B$，满足：

- $B$ 是长度为 $m$ 的 01 串。
- $B$ 中不存在任意一个**子串**与 $A$ 相同。
- $B$ 中存在**至少**一个**子序列**与 $A$ 相同。

输出任意一个满足要求的字符串 $B$ 即可。

## 说明/提示

### 样例解释

在第二次询问中，`01101` 和 `10110` 是另外合法的方案。

### 数据范围

| Subtask | 分值 | $\sum m\le$ | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$  | $10$ | $2\times10^6$ | $A$ 只由 `0` 组成 |
| $2$ | $10$ | $15$ | 无 |
| $3$ | $20$ | $2000$ | 无 |
| $4$  | $30$ | $10^6$ | $A$ 随机生成 |
| $5$ | $30$ | $2\times 10^6$ | 无 |

对于 $100\%$ 的数据，$1\le n\le m$，$1\le \sum m\le 2\times 10^6$。保证 $A$ 只由 `0` 和 `1` 组成。

## 样例 #1

### 输入

```
4
1 1
1
3 5
010
4 8
1101
5 6
11111```

### 输出

```
-1
01110
10100101
111101```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个满足特定条件的字符串 \( B \)，使得 \( B \) 不包含 \( A \) 作为子串，但包含 \( A \) 作为子序列。大部分题解都围绕如何插入字符来破坏 \( A \) 的连续性展开，主要思路包括：

1. **特判无解情况**：如 \( n = 1 \)、\( n = m \)、或 \( A \) 为 `01` 或 `10` 时无解。
2. **插入字符策略**：在 \( A \) 中寻找相邻且相同的字符，插入与它们不同的字符，或者在没有相邻相同字符时在特定位置插入字符。
3. **优化插入位置**：部分题解通过优化插入位置，确保插入的字符不会与前后字符形成 \( A \) 的子串。

### 所选高星题解

#### 1. 作者：Hexarhy (5星)
- **关键亮点**：提出了“插少插首异”的策略，即插入字符为 \( A \) 中出现次数较少的字符，并选择在另一个字符第一次出现的位置后插入。该策略通过分类讨论证明了其正确性，思路清晰且代码简洁。
- **代码核心**：
  ```cpp
  for(int i=1;i<=n;i++) {
      printf("%d",int(a[i]));
      if(!f && (cnt1<cnt0?!a[i]:a[i])) {
          for(int j=1;j<=m-n;j++)
              printf("%d",int(cnt1<cnt0));
          f=true;
      }
  }
  ```
  **实现思想**：在 \( A \) 中插入 \( m-n \) 个出现次数较少的字符，确保插入后不会形成 \( A \) 的子串。

#### 2. 作者：Eason_AC (4星)
- **关键亮点**：通过分析 \( A \) 的结构，提出了在特定位置插入字符的策略，尤其是处理 \( A \) 为 `000...1` 或 `111...0` 的情况。思路清晰，代码实现简洁。
- **代码核心**：
  ```cpp
  if(s[n - 1] == '0') {
      F(int, i, n, m - 1) ans += "1";
      ans += s.substr(n - 1, 1);
  } else {
      F(int, i, n, m - 1) ans += "0";
      ans += s.substr(n - 1, 1);
  }
  ```
  **实现思想**：在 \( A \) 的最后一个字符前插入 \( m-n \) 个与最后一个字符不同的字符。

#### 3. 作者：Prean (4星)
- **关键亮点**：通过观察样例，提出了在 \( A \) 中插入一段连续的 `0` 或 `1` 的策略，并特别处理了 \( n = 3 \) 的情况。思路简单直接，代码实现清晰。
- **代码核心**：
  ```cpp
  for(i=1;i<n;++i) {
      if(A[i]==A[i+1]){
          for(j=1;j<=i;++j)printf("%c",A[j]);
          for(j=1;j<=m-n;++j)putchar(A[i]=='0'?'1':'0');
          for(j=i+1;j<=n;++j)printf("%c",A[j]);printf("\n");f=false;break;
      }
  }
  ```
  **实现思想**：在 \( A \) 中找到相邻且相同的字符，插入与它们不同的字符。

### 最优关键思路与技巧

1. **插入字符策略**：在 \( A \) 中插入与相邻字符不同的字符，确保插入后不会形成 \( A \) 的子串。
2. **特判无解情况**：在处理前先判断 \( n = 1 \)、\( n = m \)、或 \( A \) 为 `01` 或 `10` 的情况，避免无效计算。
3. **优化插入位置**：选择在 \( A \) 中特定位置插入字符，确保插入的字符不会与前后字符形成 \( A \) 的子串。

### 可拓展之处

1. **类似问题**：可以扩展到其他字符集或更复杂的子串匹配问题，如多字符集或带有特定模式的子串。
2. **算法优化**：可以进一步优化插入字符的位置选择，减少不必要的计算。

### 推荐题目

1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3805 【模板】Manacher算法](https://www.luogu.com.cn/problem/P3805)
3. [P5410 【模板】扩展KMP](https://www.luogu.com.cn/problem/P5410)

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中发现某些特殊情况（如 \( A \) 为 `000...1` 或 `111...0`）需要特别处理，强调了全面考虑问题的重要性。
- **顿悟感想**：通过观察样例和逐步分析，作者们逐渐找到了插入字符的最佳策略，体现了从简单到复杂的思考过程。

---
处理用时：42.69秒
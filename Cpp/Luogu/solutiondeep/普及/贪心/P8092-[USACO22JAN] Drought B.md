# 题目信息

# [USACO22JAN] Drought B

## 题目描述

Farmer John 的草地里的草在一场大旱中都干死了。经过数小时的绝望和沉思，Farmer John 想到了一个绝妙的主意，购买玉米来喂养他宝贵的奶牛。

FJ 的 $N$ 头奶牛（$1 \leq N \leq 10^5$）排成一行，队伍中的第 $i$ 头奶牛的饥饿度为 $h_i$（$0 \leq h_i \leq 10^9$）。由于奶牛是社会性动物，她们坚持一起进食，FJ 降低奶牛饥饿度的唯一方法是选择两头相邻的奶牛 $i$ 和 $i+1$ 并分别喂她们一袋玉米，令她们的饥饿度各减少 1。

FJ 想将他的奶牛喂至所有的奶牛都具有相同的非负饥饿度。请帮助 FJ 求出他喂奶牛达到上述状态所需的最少玉米袋数，或者如果不可能达到，输出 $-1$。

## 说明/提示

【样例解释】

对于第一个子测试用例，给奶牛 $2$ 和 $3$ 各两袋玉米，然后给奶牛 $1$ 和 $2$ 各五袋玉米，可以使得所有奶牛的饥饿度均为 $3$。

对于第二个子测试用例，给奶牛 $1$ 和 $2$ 各两袋玉米，奶牛 $2$ 和 $3$ 各两袋玉米，奶牛 $4$ 和 $5$ 各两袋玉米，奶牛 $5$ 和 $6$ 各两袋玉米，可以使得所有奶牛的饥饿度均为 $2$。

对于余下的子测试用例，均不可能使得奶牛们的饥饿度相等。

【数据范围】

- 测试点 2 的所有子测试用例满足 $N \leq 3$ 以及 $h_i\le 100$。

- 测试点 3-8 的所有子测试用例满足 $N\le 100$ 以及 $h_i\le 100$。

- 测试点 9-14 的所有子测试用例满足 $N\le 100$。

- 测试点 15 没有额外限制。

- 此外，测试点 3-5 和 9-11 中的 $N$ 均为偶数，测试点 6-8 和 12-14 中的 $N$ 均为奇数。

## 样例 #1

### 输入

```
5
3
8 10 5
6
4 6 4 4 6 4
3
0 1 0
2
1 2
3
10 9 9```

### 输出

```
14
16
-1
-1
-1```

# AI分析结果

### 综合分析与结论

本题的核心是通过相邻元素的成对操作，使得所有元素的饥饿度相等。题解中主要采用了贪心、差分、二分等算法，部分题解还涉及了数学推导和优化技巧。整体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，但也有一些题解存在逻辑漏洞或实现复杂的问题。

### 所选高星题解

#### 1. 作者：ztlh (赞：9)  
**星级：4.5**  
**关键亮点：**  
- 采用正反两次扫描的策略，确保所有元素都能被调整到相等。
- 通过优化避免了TLE，特别是在边界条件的处理上。
- 代码简洁，逻辑清晰，适合初学者理解。

**个人心得：**  
- 作者提到“一定要开long long，不然会WA”，强调了数据类型选择的重要性。
- 通过优化边界条件，避免了不必要的计算，提升了代码效率。

**核心代码：**
```cpp
while(flag==1){
    flag=0;
    for(int i=2;i<n;i++) //正扫
        if(h[i]>h[i-1]){
            flag=1;
            int d=h[i]-h[i-1];
            h[i]-=d;
            h[i+1]-=d;
            if(h[i]<0||h[i+1]<0) {flag=-1;break;}
        }
    if(flag!=1) break; //同上
    for(int i=n-1;i>1;i--) //反扫
        if(h[i]>h[i+1]){
            flag=1;
            int d=h[i]-h[i+1];
            h[i]-=d;
            h[i-1]-=d;
            if(h[i]<0||h[i-1]<0) {flag=-1;break;}
        }
}
```

#### 2. 作者：lsj2009 (赞：12)  
**星级：4.5**  
**关键亮点：**  
- 通过数学推导，直接计算了最终的目标值，避免了复杂的调整过程。
- 对奇偶性进行了详细分析，简化了问题。
- 代码实现高效，时间复杂度为O(n)。

**个人心得：**  
- 作者提到“十年OI一场空，不开long long见祖宗”，再次强调了数据类型的重要性。
- 通过数学推导，避免了复杂的模拟过程，提升了代码的效率。

**核心代码：**
```cpp
if(n&1) {
    int x=0,ans=0;
    for(int i=1;i<=n;i++) //根据公式计算 x
        x+=(i&1? 1:-1)*h[i];
    if(x<0) return -1; //x 为负
    for(int i=1;i<n;i++) {
        f[i]=h[i]-f[i]-x; ans+=f[i]; if(f[i]<0) return -1; //计算 f[i] 并累加，同时 f[i] 必须大于等于 0，否则无解
    }
    return ans<<1; //由于 f[i] 为“第 i 头和 i+1 头的进食量”，所以需*2
}
```

#### 3. 作者：CANTORSORT (赞：3)  
**星级：4**  
**关键亮点：**  
- 采用正反两次扫描的策略，确保所有元素都能被调整到相等。
- 通过反转数组，简化了问题的处理。
- 代码简洁，逻辑清晰，适合初学者理解。

**核心代码：**
```cpp
for(int j=1;j<3;j++) //正序变化与倒序变化
{
    for(int i=2;i<n;i++)
    {
        if(h[i]>h[i-1])
        {
            int differ=h[i]-h[i-1];
            ans+=differ<<1; //每次喂两袋
            h[i+1]-=differ;
            h[i]=h[i-1]; //同时变化
        }
    }
    if(h[n]>h[n-1])
        return -1; //无解
    reverse(h+1,h+1+n); //反转
}
```

### 最优关键思路与技巧

1. **正反扫描策略**：通过正反两次扫描，确保所有元素都能被调整到相等，避免了复杂的调整过程。
2. **数学推导**：通过数学公式直接计算目标值，简化了问题，提升了代码效率。
3. **边界优化**：在处理边界条件时，通过优化避免了不必要的计算，提升了代码的效率。

### 可拓展之处

- **差分数组**：类似的问题可以通过差分数组来简化处理，特别是在需要频繁进行区间操作的场景。
- **二分查找**：对于需要确定某个目标值的问题，二分查找是一种高效的解决方案。

### 推荐题目

1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1967 [NOIP2013 提高组] 货车运输](https://www.luogu.com.cn/problem/P1967)

---
处理用时：44.96秒
# 题目信息

# 「Wdoi-6」华胥之梦

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/lkvzvoj9.png)](https://thwiki.cc/%E4%B8%9C%E6%96%B9%E6%B1%82%E9%97%BB%E5%8F%B2%E7%BA%AA/%E4%BE%BF%E7%AC%BA)

## 题目描述

### 简要题意

给定长度为 $n$ 的序列 $a$ 和常数 $c$。构造点数为 $n$ 的有向完全图 $G$ 使得边 $i\to j$（$i\neq j$）的长度为 $a_i-2a_j+c$，保证所有边权**非负**。

接下来给出 $q$ 次询问，每次给出一个点集，试找出图 $G$ 的一条最短的简单路径，满足其经过点集中所有点，并输出它的长度。

---
### 原始题意

梅莉做了一个梦，梦到自己穿越到了幻想乡的迷途竹林之中。醒来之后，她希望能够和莲子一起再次穿越境界，进入幻想乡。

但是，这一次，她看到了 $n$ 个世界，其中，第 $i$ 个世界的结界强度为 $a_i$。而世界之间**两两都有**通道相连，莲子和梅莉便是通过这些通道来进行世界之间的穿梭的。

为了避免错过幻想乡所在的世界，因此她们每到达一个世界，都会穿越结界。莲子和梅莉从第 $i$ 个世界中，通过一条通道，再穿越结界进入第 $j$ 个世界，需要使用的灵能为 $a_i-2a_j+c$（保证所需消耗的灵能非负），其中 $c$ 是一个常数，是梅莉每次穿越结界需要的额外灵能消耗。注意，这也意味着，从第 $i$ 个世界到第 $j$ 个世界，与第 $j$ 个世界穿越到第 $i$ 个世界所消耗的灵能，**可能是不同的**。

为了能够高效地找到幻想乡，她们会对你进行 $q$ 次询问，每次询问的时候会给出一个**集合**，表示她们想要进入的世界。由于世界众多，她们希望能够节省灵能，因此她希望你能求出所有包含这些世界的简单路径（即：同一条世界间的通道不会被走多次）中，消耗灵能值之和最少的路径。你只需告诉她们消耗灵能值之和最少为多少。

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/x3r2ucsl.png)

每两个点之间的边权如图所示。为了便于选手观察，边权的颜色与它所对应的边的颜色相同。

对于第一个询问，可以找到路径 $4\to 1$
；对于第二个询问，可以找到路径 $3\to 2\to 1$；对于第三个询问，可以找到路径 $2\to 4 \to 1\to 5$。可以证明，这三个方案分别是对应询问的最优方案。
#### 样例 \#2

该样例符合 $\textbf{Subtask 1}$ 的限制。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \bm{q\le} & \bm{\sum |S|\le} & \textbf{\textsf{特殊性质}}&\textbf{Subtask \textsf{依赖}}\cr\hline
1 & 30 & 10 & 10 & 10 & - &-\cr\hline
2 & 20 & 10^5 & 10^5 & 10^5 & \mathbf{A}&- \cr\hline
3 & 20 & 10^5 & 10^5 & 10^5 & \mathbf{B}&-  \cr\hline
4 & 30 & 10^6 & 10^6 &  10^6& -&1,2,3 \cr\hline
\end{array}
$$

- 特殊性质 $\bf A$：$a_i$ 单调递增。
- 特殊性质 $\bf B$：$a_i$ 全部相等。

对于 $100\%$ 的数据，保证 $1 \leq S_i \leq n \leq 10^6, 1\leq \sum |S|,q \leq 10^6, 1 \le a_i,c \le 10^9$。

## 样例 #1

### 输入

```
5 20 3
7 4 2 5 9
2 1 4
3 1 2 3
4 1 4 2 5```

### 输出

```
11
24
34```

## 样例 #2

### 输入

```
10 928698067 3
331485039 15480787 61584781 252174726 472089427 95998831 252561792 118119945 315548522 24453837
4 9 1 10 2
5 10 6 1 5 8
1 5
```

### 输出

```
1798602551
2249463436
0
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过数学推导简化问题，避免直接构建图并进行复杂的路径搜索。大多数题解都基于以下关键思路：
1. **路径优化**：通过推导发现，最短路径只包含点集中的点，且路径长度仅与点集中的最小值和最大值有关。
2. **数学公式简化**：通过公式推导，将路径长度简化为 `c*(|S|-1) + 2*min_a - max_a - sum_a`，从而避免了排序和复杂计算。
3. **时间复杂度优化**：通过线性扫描找到最小值和最大值，将时间复杂度从 `O(n log n)` 降低到 `O(n)`。

### 所选高星题解

#### 1. **作者：Ginger_he (5星)**
- **关键亮点**：通过数学推导直接得出路径长度的简化公式，避免了排序操作，时间复杂度优化到 `O(n)`。
- **代码实现**：
  ```cpp
  while(q--){
      s=w=0,t=1e9;
      m=read();
      for(ll i=1;i<=m;i++){
          x=read();
          s=max(s,a[x]);
          t=min(t,a[x]);
          w-=a[x];
      }
      printf("%lld\n",c*(m-1)+w+t*2-s);
  }
  ```
- **核心思想**：通过线性扫描找到点集中的最小值和最大值，直接计算路径长度。

#### 2. **作者：Ask_sum (5星)**
- **关键亮点**：详细推导了路径长度的简化公式，并提供了两种解法，分别适用于部分分和满分情况。
- **代码实现**：
  ```cpp
  void work(){
      int len;
      len=read();
      ll sum=0,cs=(len-1)*c,maxn=-inf,minn=inf;
      for(ll i=1;i<=len;i++){
          ll k=read();
          sum+=a[k];
          maxn=max(maxn,a[k]);
          minn=min(minn,a[k]);
      }
      if(len<=1){
          printf("0\n");
          return;
      }
      printf("%lld\n",cs-sum+2*minn-maxn);
  }
  ```
- **核心思想**：通过线性扫描找到最小值和最大值，直接计算路径长度，时间复杂度为 `O(n)`。

#### 3. **作者：lyhqwq (5星)**
- **关键亮点**：通过数学推导直接得出路径长度的简化公式，避免了排序操作，时间复杂度优化到 `O(n)`。
- **代码实现**：
  ```cpp
  while(q--){
      ll s;
      scanf("%lld",&s);
      ll sum=0,minx=0x7f7f7f7f,maxx=0;
      for(int i=1;i<=s;i++){
          ll x;
          scanf("%lld",&x);
          maxx=max(maxx,a[x]);
          minx=min(minx,a[x]);
          sum+=a[x];
      }
      printf("%lld\n",(sum-maxx)-2*(sum-minx)+(s-1)*c);
  }
  ```
- **核心思想**：通过线性扫描找到最小值和最大值，直接计算路径长度。

### 最优关键思路与技巧

1. **数学推导简化问题**：通过推导路径长度的公式，将问题转化为简单的数学计算，避免了复杂的图论算法。
2. **线性扫描优化**：通过线性扫描找到最小值和最大值，将时间复杂度从 `O(n log n)` 降低到 `O(n)`。
3. **避免不必要的排序**：通过数学公式直接计算路径长度，避免了排序操作，进一步优化了时间复杂度。

### 可拓展之处

- **类似问题**：类似的问题可以通过数学推导简化路径长度计算，避免复杂的图论算法。
- **算法套路**：在涉及路径优化的问题中，可以通过数学推导找到路径长度的简化公式，从而避免复杂的搜索算法。

### 推荐相似题目

1. **P1351 联合权值**：考察图的遍历与权值计算。
2. **P3371 单源最短路径（弱化版）**：考察最短路径算法的应用。
3. **P3385 负环**：考察负权环的检测与处理。

### 个人心得摘录

- **作者：Ginger_he**：通过数学推导直接得出路径长度的简化公式，避免了排序操作，时间复杂度优化到 `O(n)`。
- **作者：Ask_sum**：详细推导了路径长度的简化公式，并提供了两种解法，分别适用于部分分和满分情况。
- **作者：lyhqwq**：通过数学推导直接得出路径长度的简化公式，避免了排序操作，时间复杂度优化到 `O(n)`。

---
处理用时：38.44秒
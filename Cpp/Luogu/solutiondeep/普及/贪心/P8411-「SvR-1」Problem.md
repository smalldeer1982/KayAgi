# 题目信息

# 「SvR-1」Problem

## 题目背景

小 L 打颓被 nodgd 发现，于是他开始做题了。

## 题目描述

他的 DS 非常菜，于是他把一共 $n$ 道 DS 题加到了自己的计划题单里，其中第 $i$ 道题的有趣程度为 $a_i$。

由于他并不精通 DS，他发现他在做一些题目之前需要先做另一些题目。这样的关系共有 $n - 1$ 组，他还发现每道题都出现在了这些关系中且没有重复。

他发现 $\forall 2 \leq i \leq n$，第 $i$ 题和第 $fa_i$ 题间存在上文所述的关系，且 $1 \leq fa_i < i$。**他必须先做第 $fa_i$ 题后才能做第 $i$ 题**。

他发现，如果他在做一道题之前高兴程度为 $k$，则他做完第 $i$ 题后，他的高兴程度便会变为 $\min(k, a_i)$。**他做题前的高兴程度为无穷大**。

他想问你**在必须先做第 $1$ 题且不能重复做某一道题**的情况下，他在做题的全过程中每做完一道题后**高兴程度之和的最大值**。

## 说明/提示

#### 样例 #1 解释
在该组样例中 $a = [3398922311, 3077554952, 2933028207, 4018360144, 1263042788, 835814542]$，$fa_2 = fa_3 = fa_4 = 1$，$fa_5 = fa_6 = 2$。

最优方案之一：依次做第 $1, 4, 2, 3, 5, 6$ 题，最大值为 $3398922311 + 3398922311 + 3077554952 + 2933028207 + 1263042788 + 835814542 = 14907285111$。
#### 伪代码参考
$$
\def{\b}#1{ \textbf{ #1 } }\def{\t}#1{\text{ #1 }}\def{\s}{\quad}\def{\f}#1{\textsf{ #1 }}
\def{\l}{\underline{\kern{300pt}}\\[-10pt]} 
\def{\r}{\overline{\underline{\kern{300pt}}}}
\begin{aligned}
&\r\\&\b{Algorithm:}\t{Get }a_i,fa_i\\[-13pt]&\l\\
&\begin{aligned}
    \f{1.}&\b{function} \b{\color{red}unsigned int} \t{getnext}(\b{\color{red}unsigned int}\&seed): \\
    \f{2.}&\s seed=seed\oplus\t{left}(seed,13)\\
    \f{3.}&\s seed=seed\oplus\t{right}(seed,17)\\
    \f{4.}&\s seed=seed\oplus\t{left}(seed,5) \\
    \f{5.}&\s \b{return} seed\\
    \f{6.}&\b{function} \t{main}(n):\\
    \f{7.}&\s \b{for} i \b{from} 1 \b{to} n \b{step}1\\
    \f{8.}&\s\s a_i=\t{getnext}(seed)\\
    \f{9.}&\s \b{end for} \\
    \f{10.}&\s \b{for} i \b{from} 2 \b{to} n \b{step}1\\
    \f{11.}&\s\s fa_i=\t{getnext}(seed)\bmod(i-1)+1\\
    \f{12.}&\s \b{end for} \\
    \end{aligned}\\[-12pt]
&\r
\end{aligned}
$$

其中 $\text{left}(x,d)$ 和 $\text{right}(x,d)$ 分别表示将 $x$ 左移或右移 $d$ 位。
#### 数据规模与约定
**本题自动开启捆绑测试和 O2 优化。**
$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c}\hline\hline
\textbf{Subtask} & \bm{n \leq} & \textbf{分值} \\\hline
\textsf{1} & 10 & 10 \\\hline
\textsf{2} & 10^4 & 20 \\\hline
\textsf{3} & 10^6 & 20 \\\hline
\textsf{4} & \text{无特殊限制} & 50 \\\hline\hline
\end{array}
$$

对于 $100\%$ 的数据，$1 \leq n \leq 10^7$，$0 \leq seed < 2^{32}$。

## 样例 #1

### 输入

```
6 114514```

### 输出

```
14907285111```

# AI分析结果

### 综合分析与结论

本题的核心在于理解题目中的依赖关系（即每道题必须在其父节点题完成后才能做），并找到一种高效的算法来计算每道题做完后的高兴程度之和的最大值。大多数题解都围绕如何优化遍历顺序或利用树的性质来减少时间复杂度展开。

从题解中可以看出，最关键的优化思路是利用题目中 `fa_i < i` 的性质，直接从前往后遍历数组，避免了复杂的建图和搜索过程。这种思路将时间复杂度从 `O(n log n)` 降低到 `O(n)`，极大地提高了算法的效率。

### 评分较高的题解

#### 1. 作者：liangbowen (赞：24)
- **星级**：5星
- **关键亮点**：思路清晰，逐步从暴力搜索到拓扑排序再到最终的正解，逻辑严谨。代码简洁，优化到位。
- **核心思路**：利用 `fa_i < i` 的性质，直接从前往后遍历数组，更新每道题的高兴程度，并累加结果。
- **代码片段**：
  ```cpp
  for (int i = 2; i <= n; i++) {
      a[i] = min(a[i], a[fa[i]]);
      sum += a[i];
  }
  ```

#### 2. 作者：Hisaishi_Kanade (赞：14)
- **星级**：4.5星
- **关键亮点**：通过分析树的特殊性质，提出每个节点的高兴程度只与其父节点有关，简化了问题。
- **核心思路**：直接从前往后遍历数组，更新每道题的高兴程度，并累加结果。
- **代码片段**：
  ```cpp
  for (int i = 2; i <= n; i++) {
      a[i] = min(a[i], a[fa[i]]);
      ans += a[i];
  }
  ```

#### 3. 作者：stntn (赞：5)
- **星级**：4星
- **关键亮点**：通过优先队列的思路逐步优化到最终的正解，思路清晰，代码简洁。
- **核心思路**：利用 `fa_i < i` 的性质，直接从前往后遍历数组，更新每道题的高兴程度，并累加结果。
- **代码片段**：
  ```cpp
  for (int i = 2; i <= n; i++) {
      a[i] = min(a[i], a[fa[i]]);
      ans += a[i];
  }
  ```

### 最优关键思路或技巧

1. **利用 `fa_i < i` 的性质**：直接从前往后遍历数组，避免了复杂的建图和搜索过程，将时间复杂度从 `O(n log n)` 降低到 `O(n)`。
2. **状态转移方程**：`a[i] = min(a[i], a[fa[i]])`，通过简单的状态转移即可计算出每道题的高兴程度。
3. **累加结果**：在遍历过程中直接累加每道题的高兴程度，最终得到总和。

### 可拓展之处

1. **类似题目**：可以扩展到其他依赖关系的问题，如任务调度、拓扑排序等。
2. **优化思路**：类似的优化思路可以应用于其他需要遍历树或图的问题，尤其是当节点之间有明确的父子关系时。

### 推荐题目

1. **P3379 【模板】最近公共祖先（LCA）**：考察树的遍历和LCA算法。
2. **P3388 【模板】割点（割顶）**：考察图的割点问题，与树的遍历有相似之处。
3. **P3387 【模板】缩点**：考察图的缩点问题，与拓扑排序有相似之处。

### 个人心得总结

- **调试经历**：部分题解中提到在调试过程中发现优先队列的复杂度较高，最终通过优化思路解决了问题。
- **踩坑教训**：在优化过程中，部分题解提到建图和搜索的复杂度较高，最终通过利用 `fa_i < i` 的性质简化了问题。
- **顿悟感想**：通过逐步优化，从暴力搜索到最终的正解，体现了算法优化的重要性。

---
处理用时：40.36秒
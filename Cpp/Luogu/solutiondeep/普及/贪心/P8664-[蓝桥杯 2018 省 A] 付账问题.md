# 题目信息

# [蓝桥杯 2018 省 A] 付账问题

## 题目描述

几个人一起出去吃饭是常有的事。但在结帐的时候，常常会出现一些争执。

现在有 $n$ 个人出去吃饭，他们总共消费了 $S$ 元。其中第 $i$ 个人带了 $a_i$ 元。幸运的是，所有人带的钱的总数是足够付账的，但现在问题来了：每个人分别要出多少钱呢？

为了公平起见，我们希望在总付钱量恰好为 $S$ 的前提下，最后每个人付的钱的标准差最小。这里我们约定，每个人支付的钱数可以是任意非负实数，即可以不是 $1$ 分钱的整数倍。你需要输出最小的标准差是多少。

标准差的介绍：标准差是多个数与它们平均数差值的平方平均数，一般用于刻画这些数之间的“偏差有多大”。形式化地说，设第 $i$ 个人付的钱为 $b_i$ 元，那么标准差为 $s=\sqrt{\frac{1}{n}\sum_{i=1}^n(b_i-\frac{1}{n}\sum_{i=1}^n b_i)}$

## 说明/提示

**【样例解释】**

1. 每个人都出 2333/5 元，标准差为 0。

**【数据约定】**

对于 $10\%$ 的数据，所有 $a_i$ 相等；

对于 $30\%$ 的数据，所有非 $0$ 的 $a_i$ 相等；

对于 $60\%$ 的数据，$n \le 1000$；

对于 $80\%$ 的数据，$n \le 10^5$；

对于所有数据，$n \le 5 \times 10^5,0 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
5 2333
666 666 666 666 666```

### 输出

```
0.0000```

## 样例 #2

### 输入

```
10 30
2 1 4 7 4 8 3 6 4 7```

### 输出

```
0.7928```

# AI分析结果

### 综合分析与结论

本题的核心是通过贪心算法，使得每个人支付的金额尽可能接近平均值，从而最小化标准差。所有题解都采用了类似的思路：先对每个人带的钱进行排序，然后依次计算每个人应该支付的金额，确保总支付金额恰好为 \( S \)。难点在于如何合理分配支付金额，避免某些人支付过多或过少。

### 题解评分与亮点

1. **作者：zhjx2023 (赞：9)**
   - **星级：4.5**
   - **关键亮点**：思路清晰，代码简洁，直接通过贪心策略计算每个人支付的金额，并实时更新剩余金额和标准差的计算。代码中使用了 `long double` 来保证精度，避免了浮点数精度问题。
   - **核心代码**：
     ```cpp
     for (ll i = 1; i <= n; i++)
         ans = min(a[i], s / (n - i + 1)),
         s -= ans, cnt += (ans - sum) * (ans - sum);
     printf("%.4Lf", sqrt(cnt / n));
     ```
   - **实现思想**：每次取当前人带的钱和剩余金额的平均值中的较小值作为支付金额，并更新剩余金额和标准差的计算。

2. **作者：5k_sync_closer (赞：4)**
   - **星级：4**
   - **关键亮点**：思路与代码实现都非常清晰，通过排序和贪心策略，确保每个人支付的金额尽可能接近平均值。代码中同样使用了 `long double` 来保证精度。
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= n; ++i)
         z = min(1.0l * a[i], s / (n - i + 1.0)), q += (z - x) * (z - x), s -= z;
     printf("%.4Lf", sqrt(q / n));
     ```
   - **实现思想**：与第一个题解类似，通过贪心策略计算每个人支付的金额，并实时更新剩余金额和标准差的计算。

3. **作者：Fire_Kylin (赞：1)**
   - **星级：4**
   - **关键亮点**：代码简洁，思路清晰，通过排序和贪心策略，确保每个人支付的金额尽可能接近平均值。代码中同样使用了 `long double` 来保证精度。
   - **核心代码**：
     ```cpp
     for(int i=1; i<=n; i++)
     {
         double output = s*1.0/(n-i+1);
         if(a[i]<output) output=a[i];
         sum += (output-dow) * (output-dow);
         s -= output;
     }
     cout << fixed << setprecision(4) << sqrt(sum*1.0/n);
     ```
   - **实现思想**：与前面两个题解类似，通过贪心策略计算每个人支付的金额，并实时更新剩余金额和标准差的计算。

### 最优关键思路与技巧

1. **排序优先**：所有题解都首先对每个人带的钱进行排序，确保从钱少的人开始支付，避免后面的人支付不起。
2. **贪心策略**：每个人支付的金额取当前人带的钱和剩余金额的平均值中的较小值，确保支付的金额尽可能接近平均值。
3. **精度控制**：使用 `long double` 来保证计算的精度，避免浮点数精度问题。

### 可拓展之处

1. **类似问题**：类似的问题可以扩展到其他需要最小化偏差的场景，如资源分配、任务调度等。
2. **算法优化**：可以考虑使用更高效的排序算法或优化贪心策略，进一步提高算法的效率。

### 推荐题目

1. **P1045 [NOIP2005 提高组] 过河**：考察贪心算法和动态规划的结合。
2. **P1090 [NOIP2004 提高组] 合并果子**：考察贪心算法和优先队列的使用。
3. **P1223 排队接水**：考察贪心算法在任务调度中的应用。

### 个人心得总结

- **调试经历**：在实现过程中，需要注意浮点数精度问题，使用 `long double` 可以有效避免精度丢失。
- **踩坑教训**：排序的顺序非常重要，必须从钱少的人开始支付，否则可能导致后面的人支付不起。
- **顿悟感想**：贪心算法的核心在于每一步都做出局部最优的选择，从而希望最终得到全局最优解。

---
处理用时：42.14秒
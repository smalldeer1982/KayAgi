# 题目信息

# [蓝桥杯 2018 省 B] 乘积最大

## 题目描述

给定 $N$ 个整数 $A_1, A_2,\cdots, A_N$。请你从中选出 $K$ 个数，使其乘积最大。  

请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以 $1000000009$（即 $10^9+9$）的余数。  

注意，如果 $X<0$， 我们定义 $X$ 除以 $1000000009$ 的余数是 $0-((0-x)\bmod 1000000009)$。


## 说明/提示

对于 $40\%$ 的数据，$1\le K\le N\le 100$。

对于 $60\%$ 的数据，$1\le K \le 1000$。

对于 $100\%$ 的数据，$1\le K\le N\le 10^5$，$-10^5\le A_i\le 10^5$。

## 样例 #1

### 输入

```
5 3 
-100000   
-10000   
2   
100000  
10000```

### 输出

```
999100009```

## 样例 #2

### 输入

```
5 3 
-100000   
-100000   
-2   
-100000  
-100000```

### 输出

```
-999999829```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在给定的整数数组中选择 $K$ 个数，使得它们的乘积最大。由于数组中可能存在负数，因此需要考虑负负得正的情况。所有题解都采用了贪心算法，通过排序后从数组两端选取数对，比较两端的乘积来决定选取哪一对。主要难点在于处理 $K$ 为奇数时的情况，以及如何避免乘积溢出。

### 所选题解

#### 1. 作者：Jorisy (5星)
- **关键亮点**：
  - 代码简洁，逻辑清晰，处理了 $K$ 为奇数的情况，并通过 `f` 变量记录乘积的符号。
  - 使用了 `signed main()` 和 `#define int long long` 来避免溢出问题。
  - 在取模时先乘 `p` 或 `q` 再乘 `ans`，避免了 `long long` 溢出。

- **核心代码**：
  ```cpp
  int l=1,r=n,f=ans<0?-1:1;
  while(k)
  {
      int p=a[l]*a[l+1],q=a[r]*a[r-1];
      if(p*f>q*f)
      {
          ans=p%mod*ans%mod;
          l+=2;
      }
      else
      {
          ans=q%mod*ans%mod;
          r-=2;
      }
      k-=2;
  }
  ```

#### 2. 作者：Silence_World (4星)
- **关键亮点**：
  - 思路清晰，处理了 $K$ 为奇数的情况，并通过 `f` 变量记录乘积的符号。
  - 代码结构良好，易于理解。

- **核心代码**：
  ```cpp
  if(k%2==1){
      ans*=a[n];
      n--;
      k--;
      r--;
      if(ans<0){
          f=-1;
      }
  }
  while(k-=2){
      int li=a[l]*a[l+1];
      int ri=a[r]*a[r-1];
      if(ri*f>=li*f){
          r-=2;
          ans*=ri%mod;
          ans%=mod;
      }
      else{
          l+=2;
          ans*=li%mod;
          ans%=mod;
      }
  }
  ```

#### 3. 作者：Jasonshan10 (4星)
- **关键亮点**：
  - 处理了 $K$ 为奇数的情况，并通过 `flag` 变量记录乘积的符号。
  - 代码结构清晰，逻辑严谨。

- **核心代码**：
  ```cpp
  if (K%2==1){
      --r;
      --K;
      res=a[n];
      if(a[n]<0){
          flag=-1;
      }
  }
  while (K!=0){
      ll x=a[l]*a[l+1],y=a[r]*a[r-1];
      if (x*flag<=y*flag){
          res=((y%mod)*res)%mod;
          r=r-2;
      }
      else{
          res=((x%mod)*res)%mod;
          l=l+2;
      }
      K=K-2;
  }
  ```

### 最优关键思路或技巧

1. **贪心算法**：通过排序后从数组两端选取数对，比较两端的乘积来决定选取哪一对。
2. **处理 $K$ 为奇数的情况**：先选取最大的数，然后将其余的 $K-1$ 个数按偶数处理。
3. **避免溢出**：在取模时先乘 `p` 或 `q` 再乘 `ans`，避免 `long long` 溢出。

### 可拓展之处

- **类似算法套路**：类似的贪心算法可以应用于其他需要从数组中选择若干元素使得某种属性最大化的问题，如选择若干数使得和最大或最小。
- **同类型题目**：可以考虑处理更复杂的乘积问题，如选择若干数使得乘积最小，或者处理更复杂的数组结构，如二维数组。

### 推荐题目

1. [P1007 最大乘积](https://www.luogu.com.cn/problem/P1007)
2. [P1012 最大乘积](https://www.luogu.com.cn/problem/P1012)
3. [P1013 最大乘积](https://www.luogu.com.cn/problem/P1013)

### 个人心得总结

- **调试经历**：在处理 $K$ 为奇数时，需要注意选取最大数后对数组和 $K$ 的调整。
- **踩坑教训**：在取模时要注意乘法的顺序，避免溢出。
- **顿悟感想**：贪心算法在处理此类问题时非常有效，但需要仔细考虑边界条件和特殊情况。

---
处理用时：37.32秒
# 题目信息

# [蓝桥杯 2018 国 C] 交换次数

## 题目描述

IT 产业人才需求节节攀升。业内巨头百度、阿里巴巴、腾讯（简称 BAT）在某海滩进行招聘活动。

招聘部门一字排开。由于是自由抢占席位，三大公司的席位随机交错在一起，形如：

`ABABTATT`，这使得应聘者十分别扭。

于是，管理部门要求招聘方进行必要的交换位置，使得每个集团的席位都挨在一起。即最后形如：

`BBAAATTT` 这样的形状，当然，也可能是：

`AAABBTTT` 等。

现在，假设每次只能交换 $2$ 个席位，并且知道现在的席位分布，

你的任务是计算：要使每个集团的招聘席位都挨在一起需要至少进行多少次交换动作。

## 说明/提示

输入字符串的长度 $n$ 不大于 $10^5$。

时限 1 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
TABTABBTTTT```

### 输出

```
3```

## 样例 #2

### 输入

```
TTAAABB```

### 输出

```
0```

# AI分析结果

### 综合分析与结论

该题目要求将字符串中的字符通过交换操作，使得相同字符连续排列，且每次只能交换两个字符。题解的核心思路是枚举所有可能的字符排列顺序，计算每种排列下的最小交换次数，最终取最小值。大多数题解采用了类似的思路，但在具体实现和优化上有所不同。

### 所选高星题解

#### 1. 作者：wuhan1234 (5星)
- **关键亮点**：思路清晰，代码结构合理，详细解释了交换次数的计算逻辑，尤其是如何处理不同区域之间的交换。通过分段统计和分类讨论，确保了交换次数的最小化。
- **核心代码**：
```c
int calc(char s[],char a,char b,char c) {
    int acnt=0,bcnt=0,ccnt=0;
    int f1t23=0,f1t2=0,f2t1=0,f2t3=0;
    for (int i=0;i<strlen(s);i++) {
        if (s[i]==a) acnt++;
        else if (s[i]==b) bcnt++;
        else ccnt++;
    }
    for (int i=0;i<acnt;i++) {
        if (s[i]!=a) f1t23++;
        if (s[i]==b) f1t2++;
    }
    for (int i=acnt;i<acnt+bcnt;i++) {
        if (s[i]==a) f2t1++;
        if (s[i]==c) f2t3++;
    }
    int res = f1t23 + f2t3;
    if (f2t1>f1t2) res+=(f2t1 -f1t2);
    return res;
}
```
- **核心思想**：通过统计每个区域中需要交换的字符数量，分类讨论不同情况下的交换次数，确保交换次数最小。

#### 2. 作者：lqsy002 (4星)
- **关键亮点**：代码简洁，逻辑清晰，直接通过统计不同区域中需要交换的字符数量来计算最小交换次数。使用了贪心策略，确保交换次数最小。
- **核心代码**：
```cpp
int changes(char A,char B,char C){
    int a=0,b=0,num=0,numb=0,numa=0,numc=0,len=s.length();
    for(int i=0;i<len;++i){
        if(s[i]==A) ++a;
        else if(s[i]==B) ++b;
    }
    for(int i=0;i<a;++i){
        if(s[i]!=A) ++num;
        if(s[i]==B) ++numb;
    }
    for(int i=a;i<a+b;++i){
        if(s[i]==A) ++numa;
        if(s[i]==C) ++numc;
    }
    num+=numa+numc-min(numa,numb);
    return num;
}
```
- **核心思想**：通过统计每个区域中需要交换的字符数量，使用贪心策略计算最小交换次数。

#### 3. 作者：sieve (4星)
- **关键亮点**：使用了贪心策略，通过截取字符串的不同区域，统计需要交换的字符数量，确保交换次数最小。代码结构清晰，逻辑严谨。
- **核心代码**：
```cpp
void stable_sart(char x,char y,char z) {
    string s1(s.substr(0,sum[x])),s2(s.substr(sum[x],sum[y]));
    int sum01=0,sum02=0;
    for(int i=0;i<s1.size();++i) {
        if(s1[i]==y) sum01++;
        if(s1[i]==z) sum02++;
    }
    int sum10=0,sum12=0;
    for(int i=0;i<s2.size();++i) {
        if(s2[i]==x) sum10++;
        if(s2[i]==z) sum12++;
    }
    int ans=sum02+sum12+max(sum01,sum10);
    mn=min(mn,ans);
    return;
}
```
- **核心思想**：通过截取字符串的不同区域，统计需要交换的字符数量，使用贪心策略计算最小交换次数。

### 最优关键思路与技巧

1. **枚举所有排列**：由于字符只有三种，枚举所有可能的排列顺序，计算每种排列下的最小交换次数，最终取最小值。
2. **分段统计**：将字符串分为三个区域，统计每个区域中需要交换的字符数量，确保交换次数最小。
3. **贪心策略**：在处理不同区域之间的交换时，使用贪心策略，确保交换次数最小。

### 可拓展之处

- **类似题目**：可以扩展到更多字符的情况，或者扩展到其他类型的排列问题，如将字符串中的字符按特定顺序排列。
- **算法套路**：类似的问题可以使用贪心策略、枚举法、分段统计等方法来解决。

### 推荐题目

1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得

- **调试经历**：在处理不同区域之间的交换时，需要仔细统计每个区域中需要交换的字符数量，确保交换次数最小。
- **踩坑教训**：在枚举所有排列时，需要注意排列的顺序，确保每种排列都被正确计算。
- **顿悟感想**：通过分段统计和贪心策略，可以有效地减少交换次数，确保问题的最优解。

---
处理用时：48.52秒
# 题目信息

# [蓝桥杯 2020 国 ABC] 答疑

## 题目描述

有 $n$ 位同学同时找老师答疑。每位同学都预先估计了自己答疑的时间。老师可以安排答疑的顺序，同学们要依次进入老师办公室答疑。

一位同学答疑的过程如下:

1. 首先进入办公室，编号为 $i$ 的同学需要 $s_{i}$ 毫秒的时间。

2. 然后同学问问题老师解答，编号为 $i$ 的同学需要 $a_{i}$ 毫秒的时间。

3. 答疑完成后，同学很高兴，会在课程群里面发一条消息，需要的时间可以忽略。

4. 最后同学收拾东西离开办公室，需要 $e_{i}$ 毫秒的时间。一般需要 $10$ 秒、$20$ 秒或 $30$ 秒，即 $e_{i}$ 取值为 $10000$、$20000$ 或 $30000$。

一位同学离开办公室后，紧接着下一位同学就可以进入办公室了。

答疑从 $0$ 时刻开始。老师想合理的安排答疑的顺序，使得同学们在课程群里面发消息的时刻之和最小。


## 说明/提示

**【样例说明】**

按照 $1,3,2$ 的顺序答疑，发消息的时间分别是 $20000,80000,180000$ 。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例, $1 \leq n \leq 20$ 。

对于 $60 \%$ 的评测用例, $1 \leq n \leq 200$ 。

对于所有评测用例, $1 \leq n \leq 1000,1 \leq s_{i} \leq 60000,1 \leq a_{i} \leq 1000000$, $e_{i} \in\{10000,20000,30000\}$ ，即 $e_{i}$ 一定是 $10000 、 20000 、 30000$ 之一。 

蓝桥杯 2020 年国赛 A 组 H 题（B 组 H 题, C 组 J 题）。

## 样例 #1

### 输入

```
3
10000 10000 10000
20000 50000 20000
30000 20000 30000```

### 输出

```
280000```

# AI分析结果

### 综合分析与结论

本题的核心是通过贪心算法优化答疑顺序，使得同学们在课程群中发消息的时刻之和最小。所有题解都采用了贪心策略，按照每位同学的总时间（进入时间 + 答疑时间 + 离开时间）从小到大排序，然后依次计算每位同学的发消息时刻并累加。虽然思路相似，但在代码实现和细节处理上有所不同。

### 所选高星题解

#### 题解1：ydclyq (4星)
- **关键亮点**：思路清晰，代码简洁，直接使用结构体排序，避免了复杂的预处理。
- **核心代码**：
```cpp
struct D{
    int s,a,e;
    bool operator < (const D&B) const{
        return s+a+e<B.s+B.a+B.e;
    }
}h[1005];

void solve(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>h[i].s>>h[i].a>>h[i].e;
    }
    sort(h+1,h+n+1);
    ll ans=0,now=0;
    for(int i=1;i<=n;i++){
        now+=h[i].s+h[i].a;
        ans+=now;
        now+=h[i].e;
    }
    cout<<ans;
}
```
- **个人心得**：通过重载运算符简化了排序逻辑，代码可读性高。

#### 题解2：linyukun (4星)
- **关键亮点**：详细解释了贪心策略的原理，代码注释清晰，适合初学者理解。
- **核心代码**：
```cpp
struct aaa{
    long long s,a,e,sum;
}a[1005];
bool cmp(aaa a,aaa b){
    return a.sum<b.sum;
}

int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].s>>a[i].a>>a[i].e;
        a[i].sum=a[i].a+a[i].s+a[i].e;
    }
    sort(a+1,a+n+1,cmp);
    long long ans=0,ke=0;
    for(int i=1;i<=n;i++){
        ke+=a[i].a+a[i].s+a[i-1].e;
        ans+=ke;
    }
    cout<<ans;
}
```
- **个人心得**：强调了时刻的累计性，提醒读者注意细节。

#### 题解3：small_john (4星)
- **关键亮点**：提供了详细的数学证明，增强了算法的可信度，代码优化了输入输出。
- **核心代码**：
```cpp
struct node{
    int s,a,e,sum;
}a[N];
bool cmp (node a,node b) {return a.sum<b.sum;}

int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i = 1;i<=n;i++)
        cin>>a[i].s>>a[i].a>>a[i].e,a[i].sum = a[i].s+a[i].a+a[i].e;
    sort(a+1,a+n+1,cmp);
    long long ans=0,sum=0;
    for (int i = 1;i<=n;i++) 
        ans+=sum+a[i].s+a[i].a,sum+=a[i].sum;
    cout<<ans;
}
```
- **个人心得**：通过交换法证明了贪心策略的正确性，增强了算法的严谨性。

### 最优关键思路与技巧

1. **贪心策略**：按照每位同学的总时间（进入时间 + 答疑时间 + 离开时间）从小到大排序，确保前面的同学用时最短，从而减少后面同学的等待时间。
2. **结构体排序**：使用结构体存储每位同学的时间信息，并通过重载运算符或自定义比较函数进行排序，简化代码逻辑。
3. **时刻累计**：在计算每位同学的发消息时刻时，注意累加上一位同学的离开时间，确保时刻的连续性。

### 可拓展之处

- **类似问题**：排队打水问题、任务调度问题等，都可以通过贪心策略优化顺序。
- **算法套路**：贪心算法在优化顺序类问题中应用广泛，关键在于找到合适的排序规则。

### 推荐题目

1. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

这些题目都涉及到通过贪心策略优化顺序，适合进一步练习和巩固贪心算法的应用。

---
处理用时：40.40秒
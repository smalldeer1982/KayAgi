# 题目信息

# [蓝桥杯 2022 省 B] X 进制减法

## 题目描述

进制规定了数字在数位上逢几进一。

$X$ 进制是一种很神奇的进制，因为其每一数位的进制并不固定！例如说某种 $X$ 进制数，最低数位为二进制，第二数位为十进制，第三数位为八进制，则 $X$ 进制数 `321` 转换为十进制数为 `65`。

现在有两个 $X$ 进制表示的整数 $A$ 和 $B$，但是其具体每一数位的进制还不确定，只知道 $A$ 和 $B$ 是同一进制规则，且每一数位最高为 $N$ 进制，最低为二进制。请你算出 $A-B$ 的结果最小可能是多少。

请注意，你需要保证 $A$ 和 $B$ 在 $X$ 进制下都是合法的, 即每一数位上的数字要小于其进制。

## 说明/提示

**【样例说明】**

当进制为：最低位 $2$ 进制, 第二数位 $5$ 进制, 第三数位 $11$ 进制时, 减法得到的差最小。此时 $A$ 在十进制下是 $108$，$B$ 在十进制下是 $14$，差值是 $94$。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据，$N \leq 10,M_{a}, M_{b} \leq 8$.

对于 $100 \%$ 的数据，$2 \leq N \leq 1000,1 \leq M_{a}, M_{b} \leq 10^5,A \geq B$。

蓝桥杯 2022 省赛 B 组 E 题。

## 样例 #1

### 输入

```
11
3
10 4 0
3
1 2 0```

### 输出

```
94```

# AI分析结果

### 综合分析与结论

本题的核心在于如何为每个数位选择合适的进制，使得两个X进制数的差值最小。所有题解都采用了贪心策略，即尽可能让每个数位的进制最小，以确保高位的权值最小，从而使得差值最小。具体来说，每个数位的进制应取`max(a[i], b[i]) + 1`，同时确保进制不低于2。

大部分题解都遵循了以下步骤：
1. 确定每个数位的最小进制。
2. 通过前缀积或秦九韶算法计算每个数位的权值。
3. 将A和B转换为十进制并计算差值，注意处理负数情况。

### 所选高质量题解

#### 1. **Rain_chr (5星)**
- **关键亮点**：
  - 详细解释了为什么每一步都需要取模，避免了大数溢出问题。
  - 使用了前缀积来计算每个数位的权值，代码清晰且高效。
  - 提供了对贪心策略的深入理解，并解释了为什么选择最小进制。
- **代码核心**：
  ```cpp
  for(int i=max(ma,mb);i;i--) //处理进制 
      c[i]=max(a[i],b[i])+1;
  for(int i=max(ma,mb);i;i--) //最低进制是二进制 
      c[i]=c[i]>2?c[i]:2;
      
  d[1]=1; //处理每一位的价值 
  for(int i=2;i<=max(ma,mb);i++)
      d[i]=(d[i-1]*c[i-1])%mod;
      
  long long ka=0,kb=0; //统计价值 
  for(int i=ma;i;i--)
      ka+=a[i]*d[i],ka%=mod;
  for(int i=mb;i;i--)
      kb+=b[i]*d[i],kb%=mod;
  
  cout<<(ka-kb+mod)%mod; //特别注意：模意义下的减法 
  ```

#### 2. **xuchuhan (4星)**
- **关键亮点**：
  - 通过样例详细解释了X进制的计算方法，帮助理解题意。
  - 使用了贪心策略，并解释了为什么选择最小进制。
  - 代码结构清晰，处理了位数不同的情况。
- **代码核心**：
  ```cpp
  for(int i=max(ma,mb);i>=1;i--)
      tmp[i]=max(max(a[i],b[i])+1,1LL*2);//算出每一位的权值
  final[1]=1;
  for(int i=2;i<=max(ma,mb);i++)
      final[i]=(final[i-1]*tmp[i-1])%MOD;//前缀和维护乘积
  for(int i=max(ma,mb);i>=1;i--){
      x=x+final[i]*a[i];
      y=y+final[i]*b[i];
      x%=MOD,y%=MOD;
  }
  int ans=x-y;
  while(ans<0)
      ans+=MOD;
  ans%=MOD;
  ```

#### 3. **0x282e202e2029 (4星)**
- **关键亮点**：
  - 使用了秦九韶算法优化计算过程，代码简洁高效。
  - 详细解释了贪心策略，并处理了进制不低于2的情况。
  - 代码中特别强调了取模运算的处理，避免负数结果。
- **代码核心**：
  ```cpp
  for(int i = max(ma, mb) - 1; i >= 0; i--)//取较大位数
  {
      ans = (ans * max(2, max(a[i] + 1, b[i] + 1)) + a[i] - b[i] + MOD) % MOD;//秦九韶算法，注意进制数
  }
  printf("%lld", ans);
  ```

### 最优关键思路与技巧

1. **贪心策略**：每个数位的进制取`max(a[i], b[i]) + 1`，确保进制最小，从而使得高位的权值最小。
2. **前缀积或秦九韶算法**：通过前缀积或秦九韶算法高效计算每个数位的权值，避免重复计算。
3. **取模运算**：在每一步计算中都进行取模，避免大数溢出，并处理负数结果。

### 可拓展之处

- **类似问题**：可以扩展到其他进制转换问题，如不同进制的加法、乘法等。
- **优化思路**：可以考虑使用更高效的数据结构或算法来进一步优化计算过程。

### 推荐题目

1. **P1017 进制转换**：考察不同进制之间的转换。
2. **P1045 大数加法**：处理大数运算，涉及进位和取模。
3. **P1088 火星人**：涉及进制和排列组合的问题。

### 个人心得总结

- **调试经历**：多位作者提到在处理负数结果时，需要先加模数再取模，否则会导致错误结果。
- **踩坑教训**：部分作者提到在处理不同位数时，需要对齐最低位，否则会导致计算错误。
- **顿悟感想**：通过贪心策略选择最小进制，可以确保差值最小，这一思路在类似问题中也非常适用。

---
处理用时：41.90秒
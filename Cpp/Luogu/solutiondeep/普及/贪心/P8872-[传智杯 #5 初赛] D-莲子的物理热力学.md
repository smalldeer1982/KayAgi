# 题目信息

# [传智杯 #5 初赛] D-莲子的物理热力学

## 题目背景

莲子正在研究分子的运动。

每个分子都有一个速度，约定正方向为正，负方向为负。分子的数量极多，速度又并不一致，看上去杂乱无章。于是莲子希望调整部分分子的速度，使得最终分子们看上去整齐。

## 题目描述

莲子给定了 $n$ 个整数 $a_1,a_2,\cdots a_n$，描述每个分子。现在她可以进行**至多** $m$ 次操作（也可以一次也不进行），每次操作可以执行以下两条之一：

- 选择 $i$，满足 $a_i=\min_j\{a_j\}$，然后将 $a_i$ 变为 $\max_j\{a_j\}$。
- 选择 $i$，满足 $a_i=\max_j\{a_j\}$，然后将 $a_i$ 变为 $\min_j\{a_j\}$。

现在莲子希望需要最小化最终序列的极差（最大值减去最小值的差）。请求出最小的极差。

---

例如，对于序列 $a=\{5,1,4\}$，可以进行如下几次操作：

- 选择 $i=1$，满足 $a_1=5$ 是当前的最大值 $5$，可以将 $a_1$ 修改成当前的最小值 $1$，此时序列变成 $\{1,1,4\}$；
- 再选 $i=2$，满足 $a_2=1$ 是当前的最小值 $1$，可以将 $a_2$ 修改成当前的最大值 $4$，此时序列变成 $\{1,4,4\}$。 

这两次操作后得到的序列为 $\{1,4,4\}$。最大值减去最小值的差为 $|4-1|=3$。

当然，这种操作方式得到的极差并非最小。最优策略是，先将最大值 $a_1=5$ 变成目前的最小值 $1$，再把此时的最大值 $a_3=4$ 变成目前的最小值 $1$。此时序列为 $\{1,1,1\}$，得到的极差 $|1-1|=0$ 是所有策略中最小的。



## 说明/提示

### 样例解释

样例 $1$：$\{5,1,4\}\to\{1,1,4\}\to\{1,1,1\}$，极差为 $0$。  
样例 $2$：$\{1,2,3,4,5,6,7,8\}$，什么也做不了，极差为 $7$。  
样例 $3$：$\{1,5,5,5,6,6,9,10\}\to\{10,5,5,5,6,6,9,10\}\to\{5,5,5,5,6,6,9,10\}\to\{5,5,5,5,6,6,9,5\}$，极差为 $4$。

### 数据范围及约定

对于全部数据，保证 $1\le n \le 10^5$，$0\le m\le10^9$，$|a_i|\le 10^9$。

## 样例 #1

### 输入

```
3 2
5 1 4```

### 输出

```
0```

## 样例 #2

### 输入

```
8 0
1 2 3 4 5 6 7 8```

### 输出

```
7
```

## 样例 #3

### 输入

```
8 3
1 5 5 5 6 6 9 10
```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过贪心策略和双指针技巧，最小化序列的极差。题解通过排序和枚举的方式，逐步缩小可能的极差范围，最终找到最优解。主要难点在于如何高效地计算满足条件的最小极差，并确保操作次数不超过给定的限制。

### 所选题解

#### 题解：离散小波变换° (赞：12)

- **星级**：★★★★★
- **关键亮点**：
  - 使用了贪心策略和双指针技巧，确保时间复杂度为O(n log n)。
  - 通过预处理和单调性优化，减少了不必要的计算。
  - 代码结构清晰，逻辑严谨，易于理解和实现。
- **个人心得**：
  - 作者提到“容易发现，至少前min(u,v)次操作肯定都无法让结果变到[l,r]内”，这一观察是解题的关键，帮助简化了问题的复杂性。

#### 核心代码实现

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
int qread(){
    int w=1,c,ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
const int MAXN = 1e5 + 3;
int A[MAXN], ans = INF;
int main(){
    int n = qread(), m = qread();
    up(1, n, i) A[i] = qread();
    sort(A + 1, A + 1 + n);
    int j = 1;
    up(1, min(n, m + 1), i){
        j = max(i, j);
        while((i - 1) + (n - j) + min(i - 1, n - j) > m) ++ j;
        ans = min(ans, A[j] - A[i]);
    }
    printf("%d\n", ans);
    return 0;
}
```

### 最优关键思路或技巧

1. **贪心策略**：通过排序和枚举，逐步缩小可能的极差范围。
2. **双指针技巧**：利用双指针在排序后的数组中高效地找到满足条件的最小极差。
3. **预处理和单调性优化**：通过预处理和利用单调性，减少不必要的计算，提高算法效率。

### 可拓展之处

- **同类型题**：类似的问题可以通过贪心策略和双指针技巧来解决，例如最小化序列的方差或最大化序列的某种性质。
- **类似算法套路**：在处理序列问题时，排序和双指针是常见的优化手段，可以广泛应用于各种序列优化问题。

### 推荐洛谷题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1044 拦截导弹](https://www.luogu.com.cn/problem/P1044)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

这些题目都涉及到序列的优化和处理，可以通过类似的贪心策略和双指针技巧来解决。

---
处理用时：31.99秒
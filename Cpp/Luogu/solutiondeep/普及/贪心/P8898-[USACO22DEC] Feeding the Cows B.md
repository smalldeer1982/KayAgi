# 题目信息

# [USACO22DEC] Feeding the Cows B

## 题目描述

Farmer John 有 $N(1 \le N \le 10^5)$ 头奶牛，每头奶牛的品种是更赛牛（Guernsey）或荷斯坦牛（Holstein）之一。她们沿水平方向排成一行，奶牛们占据的位置编号为 $1 \cdots N$。

由于奶牛们都饿了，FJ 决定在 $1 \cdots N$ 中的某些位置上种植草地。更赛牛和荷斯坦牛喜欢不同类型的草，所以如果 Farmer John 决定在某个位置种草，他必须选择种植更赛牛喜欢的草或荷斯坦牛喜欢的草——他不能在同一个位置同时种两种草。种植的每一片草地都可以喂饱数量不限的相应品种的奶牛。 

每头奶牛愿意移动至多 $K(0 \le K \le N-1)$ 个位置以前往一个草地。求出喂饱所有奶牛所需种植的最小草地数量。此外，输出一种使用最小草地数量喂饱所有奶牛的种植方案。任何满足上述条件的方案均视为正确。 

## 说明/提示

### 样例 1 解释

注意对于某些子测试用例，存在多种可通过的方案使用最小数量的草地。例如，在第四个子测试用例中，以下是另一个可以通过的答案：

$$\texttt{.GH..}$$

这个方案在第二个位置种植一块喂饱更赛牛的草地以及在第三个位置种植一块喂饱荷斯坦牛的草地。这使用了最小数量的草地并确保了所有奶牛都在她们喜欢的草地的 $3$ 个位置以内。

### 测试点性质

- 测试点 $2-4$ 满足 $N \le 10$。
- 测试点 $5-8$ 满足 $N \le 40$。
- 测试点 $9-12$ 满足 $N \le 10^5$。 

## 样例 #1

### 输入

```
6
5 0
GHHGG
5 1
GHHGG
5 2
GHHGG
5 3
GHHGG
5 4
GHHGG
2 1
GH```

### 输出

```
5
GHHGG
3
.GH.G
2
..GH.
2
...GH
2
...HG
2
HG```

# AI分析结果

### 综合分析与结论

本题的核心是通过贪心算法，尽可能减少草地的种植数量，同时确保每头奶牛都能在移动不超过 $K$ 步的范围内找到适合的草地。多个题解都采用了类似的贪心策略，即尽量将草地放置在奶牛能够覆盖的最远位置，以减少草地的重复使用。不同题解在实现细节上有所差异，主要体现在如何处理边界条件、如何避免草地冲突以及如何优化时间复杂度。

### 所选高星题解

#### 1. 作者：chlchl (赞：19)
- **星级**：★★★★★
- **关键亮点**：
  - 使用两个变量 `nowh` 和 `nowg` 分别记录当前已放置的草地能够覆盖的最远位置，确保每头奶牛都能被覆盖。
  - 从后往前寻找合适的草地位置，避免重复放置，优化了草地数量。
  - 时间复杂度为 $O(n)$，效率高。
- **个人心得**：
  - 作者提到一开始考虑 DP，但发现无法有效转移，最终选择贪心策略，并通过类似 Manacher 和扩展 KMP 的思路优化了算法。

```cpp
int ans = 0, nowh = 0, nowg = 0;
for(int i=1;i<=n;i++){
    if(s[i] == 'H' && nowh < i){
        for(int j=min(i+k,n);j;j--){
            if(t[j] == '.'){
                t[j] = 'H';
                ans++, nowh = j + k;
                break;
            }
        }
    }
    if(s[i] == 'G' && nowg < i){
        for(int j=min(i+k,n);j;j--){
            if(t[j] == '.'){
                t[j] = 'G';
                ans++, nowg = j + k;
                break;
            }
        }
    }
}
```

#### 2. 作者：guozhetao (赞：10)
- **星级**：★★★★
- **关键亮点**：
  - 分别处理更赛牛和荷斯坦牛，优先将草地放置在 $i+k$ 的位置，若超出边界则从后往前寻找空位。
  - 通过跳过已满足的奶牛，减少不必要的遍历，优化了时间复杂度。
- **个人心得**：
  - 作者强调了贪心策略的重要性，尤其是在处理边界条件时，如何确保草地放置的最优性。

```cpp
for(int i=1;i<=a;i++){
    if(c[i] == 'G'){
        if(i + k <= a) d[i + k] = 'G';
        else d[a] = 'G';
        i += 2 * k;	
    }
}
```

#### 3. 作者：Svemit (赞：6)
- **星级**：★★★★
- **关键亮点**：
  - 使用变量 `h` 和 `g` 记录上一次放置草地的位置，避免重复放置。
  - 从后往前寻找空位，确保草地放置的最优性。
- **个人心得**：
  - 作者提到通过优化贪心算法，避免了 $O(nk)$ 的时间复杂度，最终实现了 $O(n)$ 的解决方案。

```cpp
for(int j=min(i+k,n-1);j>=max(i-k,0);j--){
    if(!vis[j]){
        a[j]=1;
        vis[j]=true;
        h=j;
        cnt++;
        break;
    }
}
```

### 最优关键思路与技巧

1. **贪心策略**：尽量将草地放置在奶牛能够覆盖的最远位置，以减少草地的重复使用。
2. **边界处理**：当草地放置位置超出边界时，从后往前寻找空位，确保草地放置的最优性。
3. **时间复杂度优化**：通过记录上一次放置草地的位置，避免重复遍历，确保算法的时间复杂度为 $O(n)$。

### 可拓展之处

- **类似问题**：该题的贪心策略可以应用于其他需要覆盖范围的问题，如区间覆盖、任务调度等。
- **算法套路**：贪心算法在处理最优覆盖问题时非常有效，尤其是在需要最小化资源使用的情况下。

### 推荐相似题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1969 积木大赛](https://www.luogu.com.cn/problem/P1969)

### 个人心得总结

- **调试经历**：多位作者提到在实现过程中遇到边界条件处理不当的问题，最终通过从后往前寻找空位的方式解决了冲突。
- **顿悟感想**：贪心策略在处理覆盖问题时非常有效，尤其是在需要最小化资源使用的情况下，通过优化放置顺序可以显著提高算法效率。

---
处理用时：38.47秒
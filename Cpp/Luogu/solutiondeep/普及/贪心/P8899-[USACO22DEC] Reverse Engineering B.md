# 题目信息

# [USACO22DEC] Reverse Engineering B

## 题目描述

Elsie 有一个程序，接受一个 $N(1 \le N \le 100)$ 个变量的数组 $b[0], \cdots ,b[N−1]$ 作为输入，其中每个变量等于 $0$ 或 $1$，并且返回对输入数组应用一系列 `if / else if / else` 语句的结果。每个语句检查至多一个输入变量的值，并返回 $0$ 或 $1$。这类程序的一个例子是：

```cpp
if (b[1] == 1) return 1;
else if (b[0] == 0) return 0;
else return 1;
```

例如，如果上方程序的输入是 "10"（即 $b[0]=1$ 及 $b[1]=0$），那么输出应当为 $1$。 

Elsie 告诉了 Bessie 对于 $M(1 \le M \le 100)$ 个不同输入的正确输出。Bessie 现在正试图对 Elsie 的程序进行逆向工程。不幸的是，Elsie 可能说了谎；可能不存在上述形式的程序行为与 Elsie 所说的均一致。 

对于 $T(1 \le T \le 10)$ 个子测试用例中的每一个，判断 Elsie 是否一定在说谎。

## 说明/提示

### 样例 1 解释

以下是第一个子测试用例的一个合法的程序：

```cpp
if (b[0] == 0) return 0;
else return 1;
```

以下是第一个子测试用例的另一个合法的程序：

```cpp
if (b[0] == 1) return 1;
else return 0;
```

以下是第二个子测试用例的一个合法的程序：

```cpp
if (b[1] == 1) return 1;
else if (b[0] == 0) return 0;
else return 1;
```

显然，对于第三个子测试用例不存在对应的合法的程序，因为 Elsie 的程序一定始终对相同的输入产生相同的输出。

可以证明对于最后一个子测试用例不存在对应的合法的程序。 

### 测试点性质

- 测试点 $2-3$ 满足 $N=2$。
- 测试点 $4-5$ 满足 $M=2$。
- 测试点 $6-12$ 没有额外限制。 

## 样例 #1

### 输入

```
4

1 3
0 0
0 0
1 1

2 4
00 0
01 1
10 1
11 1

1 2
0 1
0 0

2 4
00 0
01 1
10 1
11 0```

### 输出

```
OK
OK
LIE
LIE```

# AI分析结果

### 综合分析与结论

本题的核心在于判断给定的输入输出对是否可以通过一系列 `if/else if/else` 语句来正确匹配。多个题解都采用了类似的思路：通过逐位检查输入，并尝试删除那些可以通过单一 `if` 语句匹配的输入输出对。最终，如果所有输入输出对都能被删除，则说明存在合法的程序，否则说明 Elsie 在说谎。

大多数题解的时间复杂度为 \(O(n^2 m)\)，其中 \(n\) 是变量的数量，\(m\) 是输入输出对的数量。虽然这些题解的思路相似，但在实现细节和代码可读性上存在差异。

### 所选高分题解

#### 题解1：作者 ztntonny (赞：53)
- **星级**：★★★★★
- **关键亮点**：详细解释了算法的核心思想，并通过图示帮助理解。代码实现清晰，且对算法的正确性进行了严谨的证明。
- **个人心得**：作者花费了大量时间调试和写题解，确保读者能够理解每一步的逻辑。特别是对删除顺序的证明，解决了“顺序是否固定”的疑问。
- **核心代码**：
  ```cpp
  for ( int j = 1; j <= m; j++ )
      for ( int l = 0; l < m; l++ ) {
          int k[2] = { 0 , 0 } , buck[2] = { 2 , 2 };
          for ( int i = 1; i <= n; i++ ) {
              y[i][l] = ( s[i][l] == '1' );
              if ( flag[i] ) continue;
              if ( buck[y[i][l]] == 2 ) buck[y[i][l]] = p[i];
              else if ( buck[y[i][l]] != p[i] ) k[y[i][l]] = 1;
          }
          for ( int i = 1; i <= n; i++ ) if ( !k[y[i][l]] ) flag[i] = 1;
      }
  ```
  **实现思想**：逐位检查输入，如果某一位的所有输入对应的输出都相同，则删除这些输入输出对。

#### 题解2：作者 joyslog (赞：10)
- **星级**：★★★★
- **关键亮点**：代码简洁，逻辑清晰，直接按位匹配并删除符合条件的输入输出对。
- **核心代码**：
  ```cpp
  for(int k = 1; k <= n; k++) {
      for(int j = 1; j <= n; j++) {
          bl[0] = bl[1] = -1; flag[0] = flag[1] = 0;
          for(int i = 1; i <= m; i++) {
              if(vis[i]) continue;
              if(bl[a[i][j]] == -1) bl[a[i][j]] = res[i];
              else if(bl[a[i][j]] != res[i]) flag[a[i][j]] = 1;
          }
          for(int i = 1; i <= m; i++)
              if(!flag[a[i][j]]) vis[i] = 1;
      }
  }
  ```
  **实现思想**：通过按位匹配，删除那些可以通过单一 `if` 语句匹配的输入输出对。

#### 题解3：作者 chlchl (赞：4)
- **星级**：★★★★
- **关键亮点**：代码实现简洁，逻辑清晰，通过 `tag` 数组标记已删除的输入输出对，避免重复处理。
- **核心代码**：
  ```cpp
  for(int i=0;i<n;i++){
      int now = -1;
      bool ok = 1;
      for(int j=1;j<=m;j++){
          if(tag[j] && ss[j][i] == '0'){
              if(now == -1) now = res[j];
              if(res[j] != now) ok = 0;
          }
      }
      if(ok)
          for(int j=1;j<=m;j++)
              if(ss[j][i] == '0') tag[j] = 0;
  }
  ```
  **实现思想**：逐位检查输入，如果某一位的所有输入对应的输出都相同，则删除这些输入输出对。

### 最优关键思路与技巧

1. **逐位匹配**：通过逐位检查输入，判断是否可以通过单一 `if` 语句匹配输入输出对。
2. **删除策略**：一旦确定某一位的输入输出对可以通过 `if` 语句匹配，立即删除这些对，避免重复处理。
3. **标记数组**：使用标记数组来记录哪些输入输出对已经被删除，避免重复处理。

### 可拓展之处

- **类似题目**：可以扩展到更复杂的条件判断，如多个条件的组合判断。
- **优化思路**：可以考虑使用更高效的数据结构来加速匹配过程，如哈希表。

### 推荐相似题目

1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

---
处理用时：43.86秒
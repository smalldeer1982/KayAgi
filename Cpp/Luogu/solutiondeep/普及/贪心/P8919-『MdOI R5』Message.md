# 题目信息

# 『MdOI R5』Message

## 题目描述

小 A 有一个群。这个群正在玩一个小游戏：给出一个函数 $f$，从某一个时间点起，发送第 $x$ 条消息，而 $f(x)=1$ 的群友会受到一个小惩罚。当群内消息总数达到 $m$ 时游戏结束。

但小 A 是个话痨，这段时间他在这个群发了 $n$ 条消息，他发的第 $i$ 条消息在整个消息记录里是第 $a_i$ 条消息。

但是小 A 不想受到惩罚，而小 A 恰好是管理员，他可以撤回**任何时刻、任何群成员发的任何消息**，注意这会导致这条消息之后的消息排名改变。

但是撤回消息太多容易被当成暴政，因此他要尽可能减少撤回信息次数，不管是自己的还是别人的。

接下来你也猜到你要干什么了：假如其他群成员不操作，给出 $n$、函数 $f$ 和 $a_i$，求出他至少要撤回几条消息。

## 说明/提示

【样例解释】

下面给出一种可能的方式：
- 小 A 先撤回第 $1$ 条消息（群友发的），他的四条消息在消息记录里现在是第 $1,5,7,10$ 条。
- 然后撤回第 $5$ 条消息（他自己发的），剩下三条消息在消息记录里现在是第 $1,6,9$ 条。

此时三条消息满足 $f(1)=f(6)=f(9)=0$，符合题意。

可以证明无法仅撤回一条消息达成要求。

【数据范围】

|Subtask|$n\le$|$m\le$|特殊性质|分值|
|:-:|:-:|:-:|:-:|:-:|
|1|$17$|$17$||$15$|
|2|$17$|$100$||$15$|
|3|$10^3$|$10^4$||$20$|
|4||$10^5$|$n=m$|$8$|
|5|$10^5$|$10^6$|A|$12$|
|6|$10^5$|$10^6$||$30$|

- 特殊性质 A：小 A 没有连发两条消息。

对于全部数据，$1\le n\le 10^5$，$1\le a_i\le m\le 10^6$，$a_i$ 严格递增，$f(i)\in \{0,1\}$。

## 样例 #1

### 输入

```
4 11
01101010001
2 6 8 11
```

### 输出

```
2
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何通过最少的撤回操作，使得小 A 的消息不会受到惩罚。题解中大部分作者都采用了贪心策略，即从前往后遍历小 A 的消息，若某条消息会导致惩罚，则撤回该消息，并维护一个计数器来记录撤回的次数。这种方法的时间复杂度为 \(O(n + m)\)，能够高效地解决问题。

### 所选高星题解

#### 1. 作者：yummy (5星)
- **关键亮点**：提供了从暴力枚举到贪心优化的完整思路，清晰地解释了为什么撤回自己的消息比撤回别人的消息更优。代码简洁，逻辑清晰。
- **代码核心思想**：维护一个 `withdrawn` 变量，表示已经撤回的消息数。遍历小 A 的消息时，若 `f[a[i] - withdrawn] == '1'`，则撤回该消息并增加 `withdrawn`。
- **核心代码**：
  ```cpp
  int withdrawn = 0;
  for (int i = 1; i <= n; i++) {
      if (f[a[i] - withdrawn] == '1')
          withdrawn++;
  }
  printf("%d", withdrawn);
  ```

#### 2. 作者：igAC (4星)
- **关键亮点**：通过感性证明解释了为什么撤回自己的消息比撤回别人的消息更优，并提供了直观的图示帮助理解。代码实现简洁，逻辑清晰。
- **代码核心思想**：维护一个 `cnt` 变量，表示已经撤回的消息数。遍历小 A 的消息时，若 `f[a[i] - cnt] == '1'`，则撤回该消息并增加 `cnt`。
- **核心代码**：
  ```cpp
  int cnt = 0;
  for (int i = 1; i <= n; i++) {
      if (f[a[i] - cnt] == '1')
          cnt++;
  }
  printf("%d", cnt);
  ```

#### 3. 作者：continueOI (4星)
- **关键亮点**：简洁明了地解释了贪心策略，并通过优化将时间复杂度从 \(O(n^2)\) 降低到 \(O(n)\)。代码实现简洁，逻辑清晰。
- **代码核心思想**：维护一个 `ans` 变量，表示已经撤回的消息数。遍历小 A 的消息时，若 `f[a[i] - 1 - ans] == '1'`，则撤回该消息并增加 `ans`。
- **核心代码**：
  ```cpp
  int ans = 0;
  for (int i = 1; i <= n; i++) {
      if (f[a[i] - 1 - ans] == '1')
          ans++;
  }
  cout << ans;
  ```

### 最优关键思路与技巧

- **贪心策略**：从前往后遍历小 A 的消息，若某条消息会导致惩罚，则撤回该消息，并维护一个计数器来记录撤回的次数。
- **时间复杂度优化**：通过维护一个计数器，避免了每次撤回消息后对所有后续消息进行更新的操作，将时间复杂度从 \(O(n^2)\) 降低到 \(O(n + m)\)。

### 可拓展之处

- **类似问题**：可以扩展到其他需要动态调整顺序或位置的问题，如任务调度、资源分配等。
- **算法套路**：贪心算法在解决类似问题时非常有效，尤其是在每一步选择中都能找到局部最优解的情况下。

### 推荐题目

1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004) - 考察动态规划与贪心策略的结合。
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 考察贪心算法在资源分配中的应用。
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 考察贪心算法在任务调度中的应用。

### 个人心得摘录

- **yummy**：通过撤回自己的消息比撤回别人的消息更优的证明，进一步优化了算法。
- **igAC**：通过图示直观地解释了撤回操作的影响，帮助理解贪心策略的正确性。
- **continueOI**：通过优化将时间复杂度从 \(O(n^2)\) 降低到 \(O(n)\)，展示了贪心算法的高效性。

---
处理用时：38.06秒
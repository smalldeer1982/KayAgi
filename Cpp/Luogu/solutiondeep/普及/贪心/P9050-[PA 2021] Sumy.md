# 题目信息

# [PA 2021] Sumy

## 题目描述

有 $n$ 条鱼，其中第 $i$ 条的质量为 $a_i$ 克。

$x$ 能吃掉 $y$ 当且仅当 $a_x > a_y$。

若 $x$ 吃了 $y$，$y$ 会消失，$a_x$ 会变为 $a_x + a_y$。

你可以随意指定吃鱼的顺序，直至留下一条鱼为止。

求每一条鱼是否可能被作为最后**唯一**的鱼留下。**若最终无法只剩下一条鱼，则每条鱼均不满足此条件。**

## 说明/提示

#### 样例 #1 解释
下面用 $x \rightarrow y$ 表示 $x$ 吃 $y$。

留下 $2$ 号鱼的一种方案如下：$2 \rightarrow 1, 2 \rightarrow 3, 2 \rightarrow 4, 2 \rightarrow 5, 2 \rightarrow 6$。
#### 数据范围
对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
6
2 7 1 8 2 8```

### 输出

```
NTNTNT```

## 样例 #2

### 输入

```
3
5 4 4```

### 输出

```
TNN```

# AI分析结果

### 综合分析与结论

该题目要求判断每条鱼是否能成为最后唯一存活的鱼，核心思路是通过排序和二分查找来优化暴力枚举的复杂度。大部分题解都采用了类似的思路：先排序，然后通过二分查找确定最小的能够存活的鱼，再根据单调性判断其他鱼是否能够存活。整体思路清晰，代码实现也较为简洁。

### 所选高星题解

#### 1. 作者：ZepX_D (5星)
- **关键亮点**：思路清晰，代码简洁，通过二分查找和单调性优化了时间复杂度。使用了队列模拟吃鱼过程，代码可读性强。
- **核心代码**：
  ```cpp
  bool check(int k) {
      while(!q.empty()) q.pop();
      for (int i = 1;i <= n;i++)
          if (i != k) q.push(a[i].w);
      ll s = a[k].w;
      while (!q.empty()) {
          if (q.front() >= s) return 0;
          s += q.front();q.pop();
      }
      return 1;
  }
  ```
- **个人心得**：通过单调性和二分查找，避免了暴力枚举的高复杂度，代码实现简洁高效。

#### 2. 作者：251Sec (4星)
- **关键亮点**：思路清晰，代码简洁，通过二分查找和单调性优化了时间复杂度。使用了结构体存储鱼的质量和编号，代码可读性强。
- **核心代码**：
  ```cpp
  bool check(int x) {
      ll t = a[x].v;
      for (int i = 1; i <= n; i++) {
          if (i == x) continue;
          if (t <= a[i].v) return false;
          t += a[i].v;
      }
      return true;
  }
  ```
- **个人心得**：通过单调性和二分查找，避免了暴力枚举的高复杂度，代码实现简洁高效。

#### 3. 作者：chlchl (4星)
- **关键亮点**：思路清晰，代码简洁，通过二分查找和单调性优化了时间复杂度。使用了前缀和优化计算，代码可读性强。
- **核心代码**：
  ```cpp
  bool check(int mid){
      if(!s[n]) return 0;
      for(int i=mid+1;i<=n;i++)
          if(s[i - 1] + a[i - 1].x <= a[i].x)
              return 0;
      return 1;
  }
  ```
- **个人心得**：通过单调性和二分查找，避免了暴力枚举的高复杂度，代码实现简洁高效。

### 最优关键思路与技巧

1. **排序与单调性**：通过排序，利用单调性确定最小的能够存活的鱼，再根据单调性判断其他鱼是否能够存活。
2. **二分查找**：通过二分查找优化了暴力枚举的复杂度，将时间复杂度从 \(O(n^2)\) 降低到 \(O(n \log n)\)。
3. **前缀和优化**：使用前缀和优化计算，减少重复计算，提高代码效率。

### 可拓展之处

1. **同类型题**：类似的问题可以通过排序和二分查找来优化暴力枚举的复杂度，如查找满足某些条件的最小或最大值。
2. **类似算法套路**：在需要查找满足某些条件的最小或最大值时，可以考虑使用二分查找和单调性优化。

### 推荐题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

### 个人心得总结

通过单调性和二分查找，避免了暴力枚举的高复杂度，代码实现简洁高效。在解决类似问题时，可以考虑使用排序和二分查找来优化时间复杂度。

---
处理用时：35.82秒
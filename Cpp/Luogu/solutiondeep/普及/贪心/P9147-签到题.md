# 题目信息

# 签到题

## 题目背景

著名的【数据删除】是一个热爱旅游的人！这一天他来到了神秘的 ZYL 国度。

入海关的时候他被问到了一个题目，如果答对他就可以顺利到达 ZYL 的首都 ZY 了！身为堂堂【数据删除】，他居然还花了 $10^{-233}$ 秒才想出来做法，实在是有点难的！于是他决定拿来考考你。

## 题目描述

给定长度为 $n$ 的序列 $a$，保证 $a_i$ 是**正整数**。你需要选择一个位置 $i$ 并将 $a_i$ 修改为一个**任意的整数**。最大化最长**严格**上升子串的长度。

所谓严格上升子串，就是从序列中选出位置**连续**的若干个数字，满足后一个数字比前一个大（而不能相等或小于）。

如序列 $[1,4,2,3,5]$ 中，子序列 $[2,3,5]$ 就是严格上升子串，而 $[4,2,3]$（不上升）和 $[1,2,3]$（不连续）则不是。

## 说明/提示

**【样例解释 \#1】**

对于样例 \#1，我们可以将序列 $[1,4,2,2,3]$ 中的第三个位置修改为 $5$，得到新序列 $[1,4,5,2,3]$。这个序列的最长严格上升子串是 $[1,4,5]$，长度为 $3$。

容易证明，不存在一种修改方案使得修改后的序列的最长严格上升子串的长度大于 $3$。

---

**【样例解释 \#4】**

对于样例 \#4，我们可以将序列 $[8,2,3,1,4,5]$ 中的第三个位置修改为 $0$，得到新序列 $[8,2,0,1,4,5]$。这个序列的最长严格上升子串是 $[0,1,4,5]$，长度为 $4$。

容易证明，不存在一种修改方案使得修改后的序列的最长严格上升子串的长度大于 $4$。

---

**【数据范围】**

对于前 $20\%$ 的数据，满足 $n \le 5$，$a_i \le 5$。  
对于前 $40\%$ 的数据，满足 $n \le 10$，$a_i \le 10$。  
对于前 $70\%$ 的数据，满足 $n \le 300$。  
对于 $100 \%$ 的数据，满足 $1 \le n \le {10}^6$，$1 \le a_i \le {10}^9$。

## 样例 #1

### 输入

```
5
1 4 2 2 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5
1 2 3 2 1
```

### 输出

```
4
```

## 样例 #3

### 输入

```
5
1 2 3 1 5
```

### 输出

```
5
```

## 样例 #4

### 输入

```
6
8 2 3 1 4 5
```

### 输出

```
4
```

## 样例 #5

### 输入

```
6
7 2 9 4 5 6
```

### 输出

```
5
```

# AI分析结果

### 综合分析与结论

该题目要求通过修改序列中的一个元素，使得修改后的序列中最长严格上升子串的长度最大化。大部分题解的核心思路是通过预处理每个位置作为严格上升子串的开头或结尾的长度，然后枚举修改位置，计算可能的贡献。优化点在于如何高效地预处理和计算修改后的子串长度。

### 所选高星题解

#### 1. **作者：Iniaugoty (5星)**
- **关键亮点**：
  - 思路清晰，详细解释了如何预处理每个位置作为严格上升子串的开头或结尾的长度。
  - 代码简洁，逻辑明确，易于理解。
  - 通过枚举修改位置，计算可能的贡献，时间复杂度为O(n)。
- **个人心得**：
  - 强调了预处理的重要性，通过预处理可以大大简化后续的计算过程。
  - 提醒了边界条件的处理，如修改位置在序列两端的情况。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
    e[i]=a[i]>a[i-1]?e[i-1]+1:1;
for(int i=n;i>=1;i--)
    b[i]=a[i]<a[i+1]?b[i+1]+1:1;
for(int i=1;i<=n;i++){
    if(a[i-1]<a[i+1]-1)
        ans=max(ans,e[i-1]+b[i+1]+1);
    if(a[i-1]>=a[i])
        ans=max(ans,e[i-1]+1);
    if(a[i]>=a[i+1])
        ans=max(ans,b[i+1]+1);
}
```

#### 2. **作者：ttq012 (4星)**
- **关键亮点**：
  - 提供了O(n^2)和O(n)两种解法，适合不同水平的读者。
  - 详细解释了如何通过修改位置连接前后两个严格上升子串。
  - 代码实现简洁，逻辑清晰。
- **个人心得**：
  - 强调了修改位置的选择对结果的影响，提醒读者注意修改位置的合理性。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
    if(a[i]>a[i-1]) f[i]=f[i-1]+1;
    else f[i]=1;
for(int i=n;i;i--)
    if(a[i]<a[i+1]) g[i]=g[i+1]+1;
    else g[i]=1;
for(int i=1;i<=n;i++)
    if(a[i+1]-a[i-1]>=2) mx=max(mx,f[i-1]+g[i+1]+1);
    else mx=max(mx,max(f[i-1],g[i+1])+1);
```

#### 3. **作者：ncwzdlsd (4星)**
- **关键亮点**：
  - 详细解释了如何通过预处理每个位置作为严格上升子串的开头或结尾的长度。
  - 代码实现简洁，逻辑清晰。
  - 通过枚举修改位置，计算可能的贡献，时间复杂度为O(n)。
- **个人心得**：
  - 强调了预处理的重要性，通过预处理可以大大简化后续的计算过程。

**核心代码**：
```cpp
for(int i=1;i<=n;i++) g[i]=a[i]>a[i-1]?g[i-1]+1:1;
for(int i=n;i;i--) f[i]=a[i]<a[i+1]?f[i+1]+1:1;
for(int i=1;i<=n;i++){
    if(a[i+1]-a[i-1]>1) ans=max(ans,g[i-1]+f[i+1]+1);
    else ans=max(ans,max(g[i-1]+1,f[i+1]+1));
}
```

### 最优关键思路与技巧

1. **预处理**：通过预处理每个位置作为严格上升子串的开头或结尾的长度，可以大大简化后续的计算过程。
2. **枚举修改位置**：通过枚举修改位置，计算可能的贡献，时间复杂度为O(n)。
3. **边界条件处理**：注意修改位置在序列两端的情况，确保计算的正确性。

### 可拓展之处

- **类似算法套路**：该题解中的预处理和枚举修改位置的思路可以应用于其他需要修改序列元素以优化某种性质的题目，如最长不下降子序列、最长回文子串等。
- **同类型题目**：
  - [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
  - [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
  - [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)

### 个人心得总结

- **预处理的重要性**：通过预处理可以大大简化后续的计算过程，提高代码的效率和可读性。
- **边界条件的处理**：在处理序列问题时，边界条件的处理尤为重要，确保计算的正确性。
- **枚举修改位置的合理性**：在枚举修改位置时，需要考虑修改位置的合理性，确保计算的正确性。

---
处理用时：39.57秒
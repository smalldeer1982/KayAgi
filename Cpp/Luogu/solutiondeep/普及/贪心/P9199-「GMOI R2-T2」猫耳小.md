# 题目信息

# 「GMOI R2-T2」猫耳小

## 题目背景

**本题与 [加强版](https://www.luogu.com.cn/problem/P9202) 的区别在于数据范围和输出格式。在这一版本中，$n\le 5\times 10^3$，值域为 $5\times 10^3$，你不需要给出构造。**

![](https://cdn.luogu.com.cn/upload/image_hosting/r8a6ylx3.png)

## 题目描述

小 R 是一个可爱的猫耳女孩子，她喜欢研究数列的 $\operatorname{mex}\text{*}$。

现在她有一个长度为 $n$ 的数列 $a$。她讨厌整数 $k$，因此她希望修改数列 $a$ 的若干个元素为任意**自然数**，使得 $a$ 的任意**连续非空子串**的 $\operatorname{mex}$ 都不等于 $k$。

请你求出最少需要修改多少个元素。

$\text{*}$ 本题中，数列的 $\operatorname{mex}$ 被定义为数列中最小未出现的**自然数**，例如：

- $\operatorname{mex}\{1,2,3\}=0$，因为 $0$ 是自然数。
- $\operatorname{mex}\{0,1,3\}=2$。
- $\operatorname{mex}\{0,1,2\}=3$。

## 说明/提示

**样例解释**

一种方案是将 $\{1,0,1,3,0\}$ 改为 $\{1,1,1,3,2\}$，共改动两个元素。

可以证明不存在更优的方案。

---

**本题使用 Subtask 捆绑测试。**

| Subtask | $n\le$ | $k\le$ | $a_i\le$ | 特殊性质 | 对应测试点 | 总分 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $6$ | $6$ | $6$ | $-$ | $1\sim 2$ | $10$ |
| $1$ | $100$ | $5\times 10^3$ | $5\times 10^3$ | $-$ | $3\sim 5$ | $20$ |
| $2$ | $5\times 10^3$ | $1$ | $5\times 10^3$ | $-$ | $6\sim 10$ | $20$ |
| $3$ | $5\times 10^3$ | $5\times 10^3$ | $5\times 10^3$ | $\bf A$ | $11\sim 15$ | $20$ |
| $4$ | $5\times 10^3$ | $5\times 10^3$ | $5\times 10^3$ | $-$ | $16\sim 20$ | $30$ |

特殊性质 $\bf A$：保证 $a_i < k$。

对于 $100\%$ 的数据，$1\le n\le 5\times 10^3$，$0\le k,a_i\le 5\times 10^3$。

## 样例 #1

### 输入

```
5 2
1 0 1 3 0```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心问题是通过修改数组中的元素，使得任意连续子串的 `mex` 都不等于 `k`。各题解的思路主要集中在以下几个方面：

1. **特判处理**：对于 `k=0` 或 `k` 较大的情况，直接给出答案。
2. **贪心策略**：通过维护当前区间的 `mex` 值，找到需要修改的位置，并尽可能减少修改次数。
3. **数据结构优化**：使用数组或 `bitset` 来记录元素的出现情况，避免重复计算。

大多数题解都采用了贪心策略，并通过维护 `mex` 值来找到需要修改的位置。其中，`rui_er` 的题解通过引理证明了贪心策略的正确性，思路清晰且代码实现简洁，是最优的解法之一。

### 所选高星题解

#### 1. 作者：rui_er (5星)
- **关键亮点**：
  - 通过引理证明了贪心策略的正确性，思路严谨。
  - 代码实现简洁，时间复杂度为 `O(n)`，适合大规模数据。
  - 详细解释了特判和贪心策略的实现细节。
- **个人心得**：
  - 通过维护 `mex` 值，避免了重复计算，提高了算法效率。
  - 证明了将所有修改的位置都改为 `k` 是最优策略。

**核心代码片段**：
```cpp
for(int l = 0, r = 1; r <= n; r++) {
    if(a[r] > k) continue;
    if(a[r] == k) {
        while(++l < r) if(a[l] < k) --cnt[a[l]];
        mex = 0;
    }
    else {
        ++cnt[a[r]];
        while(cnt[mex]) ++mex;
        if(mex == k) {
            ++ans;
            while(++l < r) if(a[l] < k) --cnt[a[l]];
            --cnt[a[r]];
            b[r] = k;
            mex = 0;
        }
    }
}
```
**核心思想**：通过维护 `mex` 值，找到需要修改的位置，并将该位置的元素改为 `k`，从而确保 `mex` 不等于 `k`。

#### 2. 作者：wwxxbb (4星)
- **关键亮点**：
  - 通过 `bitset` 优化了空间复杂度，代码简洁。
  - 详细解释了 `k=0` 和 `k` 较大的特判处理。
  - 通过贪心策略减少了修改次数。

**核心代码片段**：
```cpp
for(int i = 1, x; i <= n; i ++) {
    cin >> x;
    if(x == k) { clear(); continue; }
    if(x < k && !st[x]) {
        st[x] = 1;
        b[++ top] = x;
        ++ cnt;
    }
    if(cnt == k) {
        ++ ans;
        clear();
    }
}
```
**核心思想**：通过 `bitset` 记录元素的出现情况，当 `cnt` 达到 `k` 时，清空记录并增加修改次数。

#### 3. 作者：ncwzdlsd (4星)
- **关键亮点**：
  - 通过 `vis` 数组记录元素的出现情况，思路清晰。
  - 代码简洁，易于理解。
  - 通过贪心策略减少了修改次数。

**核心代码片段**：
```cpp
for(int i = 1; i <= n; i++) {
    if(a[i] == k){memset(vis, 0, sizeof vis), tot = 0; continue;}
    if(a[i] < k && !vis[a[i]]) tot++, vis[a[i]] = 1;
    if(tot == k) ans++, memset(vis, 0, sizeof vis), tot = 0;
}
```
**核心思想**：通过 `vis` 数组记录元素的出现情况，当 `tot` 达到 `k` 时，清空记录并增加修改次数。

### 最优关键思路与技巧

1. **贪心策略**：通过维护 `mex` 值，找到需要修改的位置，并将该位置的元素改为 `k`，从而确保 `mex` 不等于 `k`。
2. **数据结构优化**：使用 `bitset` 或数组记录元素的出现情况，避免重复计算。
3. **特判处理**：对于 `k=0` 或 `k` 较大的情况，直接给出答案，减少不必要的计算。

### 拓展思路与同类型题

1. **同类型题**：
   - [P9202](https://www.luogu.com.cn/problem/P9202)：本题的加强版，数据范围更大。
   - [P1896](https://www.luogu.com.cn/problem/P1896)：类似的贪心策略，通过维护状态来优化算法。
   - [P1045](https://www.luogu.com.cn/problem/P1045)：通过贪心策略和数据结构优化来解决问题。

2. **类似算法套路**：
   - 贪心算法结合数据结构优化，常用于解决需要最小化或最大化某些目标的问题。
   - 特判处理可以减少不必要的计算，提高算法效率。

### 个人心得总结

- **调试经历**：在实现贪心策略时，需要注意 `mex` 值的维护和更新，避免出现错误。
- **踩坑教训**：在处理 `k=0` 或 `k` 较大的情况时，容易忽略特判处理，导致算法效率下降。
- **顿悟感想**：通过贪心策略和数据结构优化，可以显著提高算法的效率和正确性。

---
处理用时：46.86秒
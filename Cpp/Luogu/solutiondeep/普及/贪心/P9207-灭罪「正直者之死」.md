# 题目信息

# 灭罪「正直者之死」

## 题目背景

正直的人，坚强不屈的人，刚正不阿的人。

大约这样的人会处处吃亏吧，不过这样的观点大约是从欺骗者的眼光里看到的。正直的人，即使是在死后，也是最为人尊敬的吧。

## 题目描述

有一台计算器，使用 $k$ 位的带符号整型来对数字进行存储。也就是说，一个变量能够表示的范围是 $[-2^{k-1},2^{k-1})$。现在我们希望使用该计算器计算一系列数 $a_1,a_2,\cdots,a_n$ 的和。计算的伪代码如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/7p0loptk.png)

由于奇怪的特性，如果两个变量在相加时得到的结果在 $[-2^{k-1},2^{k-1})$ 之外，即发生了溢出，那么这台计算器就会卡死，再也无法进行计算了。

为了防止这样的事情发生，一个变通的方法是**更改 $a_i$ 的排列顺序**。容易发现这样不会改变计算出的和的值。

不过，可能不存在一种方案，使得计算出这 $n$ 个数并且计算机不爆炸。但我们还是希望，计算出**尽量多**的数字的和。

## 说明/提示

### 样例解释

- 对于样例 $1$，一种最优的方案是 $[a_1,a_2,a_3]$，这样可以在计算出前两个数的情况下不溢出。
- 对于样例 $2$，一种最优的方案是 $[a_{10},a_1,a_2,a_5,a_4,a_7,a_6,a_8,a_9,a_3]$，这样可以在计算前 $9$ 个数的情况下不溢出。

### 数据范围及约定

对于全部数据，保证 $1\le n\le 500$，$1< k\le 8$，$-2^{k-1}\le a_i<2^{k-1}$。

## 样例 #1

### 输入

```
3 3
1 2 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
10 4
-3 5 6 -4 5 3 -4 1 -1 0```

### 输出

```
9```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何通过调整数组的顺序，使得在计算前缀和时尽可能多的数被累加而不发生溢出。大多数题解采用了贪心算法，通过将正数和负数分开处理，并根据当前的和动态选择下一个数，以尽量保持和的值在允许范围内。

### 所选高星题解

#### 题解1：作者：liruixiong0101 (4星)
**关键亮点：**
- 使用两个数组分别存储正数和负数，并通过排序优化选择顺序。
- 通过贪心策略，优先选择最小的正数或最大的负数，以尽量保持和的值在范围内。
- 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
int s1 = 1, s2 = 1, sum = 0, ans = 0;
while(s1 <= tb || s2 <= ta){
    if(sum + b[s1] < (1 << (k - 1))){
        sum += b[s1++];
    }//若sum没有上溢。
    else if(sum + a[s2] >= -(1 << (k - 1))){
        sum += a[s2++];
    }//若sum上溢了，但是没有下溢。
    else break;//否则直接停止循环。
    ans++;
}
```
**实现思想：** 通过循环选择下一个数，优先选择最小的正数或最大的负数，以尽量保持和的值在范围内。

#### 题解2：作者：GeorgeAAAADHD (4星)
**关键亮点：**
- 使用贪心算法，每次选择使当前和最小的数，以尽量保持和的值在范围内。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
f(){
    sort(a+i,a+n+1,cmp);//排序
    ans+=a[i];
    sum++;
    if(ans<(0-pow(2,k-1))||ans>=pow(2,k-1)){//判断是否超出范围
        cout<<sum-1;
        return 0;
    }
}
```
**实现思想：** 每次选择使当前和最小的数，以尽量保持和的值在范围内。

#### 题解3：作者：0zhouyq (4星)
**关键亮点：**
- 使用优先队列分别存储正数和负数，并通过贪心策略选择下一个数。
- 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
if(q1.empty()){//判空
    now+=q2.top();
    q2.pop();
    if(now<down[k]){
        printf("%lld",i-1);
        return 0;
    }
}
else if(q2.empty()){
    now+=q1.top();
    q1.pop();
    if(now>up[k]){
        printf("%lld",i-1);
        return 0;
    }
}
```
**实现思想：** 通过优先队列选择下一个数，优先选择最小的正数或最大的负数，以尽量保持和的值在范围内。

### 最优关键思路或技巧

1. **贪心算法**：通过动态选择下一个数，尽量保持和的值在允许范围内。
2. **分治法**：将正数和负数分开处理，分别排序，优化选择顺序。
3. **优先队列**：使用优先队列存储正数和负数，方便快速选择下一个数。

### 可拓展之处

- **类似问题**：可以考虑其他需要动态调整顺序以优化结果的问题，如背包问题、任务调度问题等。
- **算法优化**：可以进一步优化贪心策略，考虑更多的约束条件或更复杂的优化目标。

### 推荐题目

1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 个人心得摘录

- **调试经历**：在实现贪心算法时，需要注意边界条件的处理，如正数或负数用尽的情况。
- **踩坑教训**：在排序时，需要确保正数和负数分别按正确的顺序排序，以避免选择错误的下一个数。
- **顿悟感想**：贪心算法的关键在于每一步都做出局部最优的选择，从而希望最终结果也是全局最优的。

---
处理用时：38.66秒
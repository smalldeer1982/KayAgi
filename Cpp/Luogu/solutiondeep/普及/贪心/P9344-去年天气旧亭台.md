# 题目信息

# 去年天气旧亭台

## 题目背景

依旧是过往的天气，过往的楼台烟雨。时间悄悄流逝着，山河仍在，人却已不是过去的人……

## 题目描述

登上楼台，旧时满面沉灰的地板映入眼帘。

共有 $n$ 块地板，地板分为两类，第 $i$ 块地板的类别用 $c_i$ 表示，积灰程度用 $a_i$ 表示。**注意 $c_i$ 为 $0$ 或 $1$。**

现在要清理这些地板上的灰尘。每次操作中，你可以：

+ 选择两个下标 $i,j$，满足 $1\leq i\leq j\leq n$， $c_i=c_j$，**且第 $i$ 块和第 $j$ 块地板上的灰尘均未被清理过**；
+ 花费 $a_i+a_j$ 的能量清理**第 $i$ 块到第 $j$ 块所有地板**上的灰尘。

求清理完所有地板上的灰尘至少要多少能量。

## 说明/提示

**【样例 1 解释】**

- 对于第一组数据，直接花费 $a_1+a_6=5$ 的能量清理所有灰尘。
- 对于第二组数据，先花费 $a_1+a_1=6$ 的能量清理第一个地板上的灰尘，再花费 $a_2+a_8=7$ 的能量清理剩余灰尘。

**【数据规模与约定】**

对于 $10\%$ 的数据，保证 $T\le 10$，$n\le 10$；

对于 $40\%$ 的数据，保证 $T\le 20$，$n\le 10^3$；

另有 $10\%$ 的数据，保证 $c_i=1$；

对于 $100\%$ 的数据，保证 $1 \le T \le 10^5$，$1 \le n,\sum n\le 2 \times 10^6$，$c_i \in \{0,1\}$，$1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
2
6
1 1 4 5 1 4
1 0 0 1 0 1
8
3 1 4 1 5 9 2 6
1 0 1 0 1 0 1 0```

### 输出

```
5
13```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地清理地板上的灰尘，要求最小化能量消耗。题解中主要分为贪心和动态规划两种思路：

1. **贪心思路**：当首尾地板类型相同时，直接清理整个区间；否则，找到一个分割点，将区间分为两部分分别清理。贪心思路的优势在于其简洁性和高效性，时间复杂度为O(n)。

2. **动态规划思路**：通过状态转移方程`dp[i] = min(dp[i], a[i] + a[j] + dp[j-1])`，逐步求解最小能量消耗。动态规划的优势在于其普适性，能够处理更复杂的情况，但实现起来相对复杂。

综合来看，贪心思路更为简洁高效，适合本题的规模和要求。动态规划思路虽然普适性强，但在本题中略显冗余。

### 所选高分题解

#### 题解1：_JF_ (5星)
- **关键亮点**：思路清晰，分类讨论详细，代码简洁高效。
- **个人心得**：通过反证法证明了分割点的存在性，增强了思路的严谨性。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =5e6+10;
#define int long long
int a[N],c[N];
signed main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        for(int i=1;i<=n;i++)
            cin>>c[i];
        if(c[1]==c[n])
        {
            cout<<a[1]+a[n]<<endl;
            continue;
        }
        int ans=LONG_LONG_MAX;
        for(int i=1;i<n;i++)
            if(c[i]==c[1]&&c[i+1]==c[n])
                ans=min(ans,a[i]+a[1]+a[n]+a[i+1]);
        cout<<ans<<endl;
    }
    return 0;
}
```

#### 题解2：zhlzt (4星)
- **关键亮点**：提供了与官方题解不同的动态规划思路，代码可读性强。
- **个人心得**：通过维护两个变量`ans1`和`ans2`，简化了状态转移过程。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2000010],c[2000010];long long dp[2000010]; 
int main(){
    int T;scanf("%d",&T);
    while(T--){
        int n;scanf("%d",&n);
        for(int i=1;i<=n;i++) scanf("%d",&a[i]);
        for(int i=1;i<=n;i++) scanf("%d",&c[i]);
        long long ans1=1e15,ans2=1e15;
        for(int i=1;i<=n;i++){
            if(c[i]==0) ans1=min(ans1,dp[i-1]+a[i]),dp[i]=ans1+a[i];
            else ans2=min(ans2,dp[i-1]+a[i]),dp[i]=ans2+a[i];
        }
        printf("%lld\n",dp[n]);
    } 
    return 0;
}
```

#### 题解3：Iniaugoty (4星)
- **关键亮点**：优化了动态规划的状态转移方程，时间复杂度降低到O(n)。
- **个人心得**：通过前缀最小值优化，提高了算法的效率。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 2000005
#define inf 5e9
using namespace std;
int T,n,c[N],a[N],dp[N],f[2];
int solve(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) cin>>c[i];
    dp[1]=a[1]+a[1];
    f[c[1]]=a[1],f[!c[1]]=inf;
    for(int i=2;i<=n;i++){
        f[c[i]]=min(f[c[i]],dp[i-1]+a[i]);
        dp[i]=f[c[i]]+a[i];
    }
    return dp[n];
}
signed main(){
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
    cin>>T;
    while(T--)
        cout<<solve()<<'\n';
    return 0;
}
```

### 最优关键思路与技巧

1. **贪心策略**：当首尾地板类型相同时，直接清理整个区间；否则，找到一个分割点，将区间分为两部分分别清理。这种策略简洁高效，适合本题的规模。
2. **动态规划优化**：通过维护前缀最小值，优化状态转移方程，将时间复杂度从O(n^2)降低到O(n)。

### 可拓展之处

1. **多类型地板**：如果地板类型不止两种，贪心策略可能需要进一步调整，动态规划思路则更具普适性。
2. **区间合并**：类似问题可以扩展到区间合并、区间覆盖等场景，动态规划思路可以灵活应对。

### 推荐题目

1. **P1880 [NOI1995]石子合并**：考察区间DP，与本题的动态规划思路相似。
2. **P1040 加分二叉树**：考察树形DP，与本题的动态规划思路有异曲同工之妙。
3. **P1063 能量项链**：考察区间DP，与本题的动态规划思路相似。

### 个人心得总结

- **反证法的应用**：在证明分割点存在性时，反证法增强了思路的严谨性。
- **前缀最小值优化**：通过维护前缀最小值，简化了动态规划的状态转移过程，提高了算法效率。

---
处理用时：52.66秒
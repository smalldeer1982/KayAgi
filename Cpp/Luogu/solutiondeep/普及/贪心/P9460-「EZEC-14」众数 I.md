# 题目信息

# 「EZEC-14」众数 I

## 题目背景

pigstd 是一个可爱的男孩子。他在 NOI2022 中的众数一题定义了 $10^6$ 个 ``std::deque`` 并没有 MLE。

## 题目描述

给定一个长度为 $n$ 的序列 $a$，我们通过以下方式构造序列 $b$：

- 初始时 $b=a$。
- 依次对 $b$ 进行 $k$ 次操作，每次操作选择任意一个元素并将其**修改**为任意整数。

dXqwq 定义一个序列的**众数**为所有出现次数最大的数。例如 $[1,1,4,5,1,4]$ 的众数为 $1$，而 $[1,14,5,14,19,19,8,10]$ 的众数为 $14,19$。

你需要求出有多少整数可能成为 $b$ 的**众数**。

## 说明/提示

**【样例解释】**

对于第一组数据，最终 $1,2,3,4,5$ 可能为区间众数。

对于第二组数据，将第一个数换成 $6,7,8,9,\cdots$ 后它们均会成为区间众数，因此答案为正无穷。

对于第三组数据，$1,2,3$ 可能成为区间众数。

**【提示】**

开 $10^6$ 个 ``std::deque`` 在空间限制为 1024MB 时不一定会 MLE。

**【数据范围】**

**本题采用捆绑测试。**

* Subtask 1（20 pts）：$n\leq 5$。
* Subtask 2（20 pts）：$n\leq 10^3$。
* Subtask 3（20 pts）：$k=0$。
* Subtask 4（20 pts）：$k=1$。
* Subtask 5（20 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$0\leq k\leq n $，$1\leq a_i\leq n$。

## 样例 #1

### 输入

```
5 0
1 2 3 4 5```

### 输出

```
5```

## 样例 #2

### 输入

```
5 1
1 2 3 4 5```

### 输出

```
pigstd```

## 样例 #3

### 输入

```
5 1
1 1 2 2 3```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心在于通过修改序列中的元素，使得某些数可能成为众数。题解主要集中在如何高效地计算哪些数可以通过最多 $k$ 次修改成为众数。大多数题解采用了贪心、二分、优先队列等算法，优化了时间复杂度，避免了暴力枚举。

### 精选题解

#### 1. **作者：ys_kylin__ (5星)**
- **关键亮点**：使用二分法优化了时间复杂度，通过二分“众数线”来快速判断哪些数可能成为众数。代码清晰，逻辑严谨，且对边界情况处理得当。
- **核心代码**：
  ```cpp
  int check(int x) {
      memset(vis,0,sizeof vis);
      x+=k;
      long long m=0;
      for(int i=1;i<=n;i++) {
          if(mp[a[i]]>x && vis[a[i]]==0) {
              vis[a[i]]=1;
              m+=mp[a[i]]-x;
          }
      }
      if(m>k) return 0;
      else return 1;
  }
  ```
  **实现思想**：通过二分法确定一个“众数线”，然后检查是否有足够的操作次数将其他数的出现次数降低到该线以下。

#### 2. **作者：dead_X (5星)**
- **关键亮点**：通过前缀和快速计算需要修改的次数，时间复杂度为 $O(n)$，非常高效。代码简洁，思路清晰。
- **核心代码**：
  ```cpp
  for(int i=n+k,c=0,s=0; i>=k; --i) {
      s+=c,c+=a[i];
      if(s>k) printf("%d\n",ans),exit(0);
      ans+=a[i-k];
  }
  ```
  **实现思想**：利用前缀和快速计算每个数成为众数所需的修改次数，避免了复杂的二分操作。

#### 3. **作者：Light_az (4星)**
- **关键亮点**：使用优先队列维护最大出现次数，通过贪心策略逐步减少最大出现次数，最终判断哪些数可以成为众数。代码可读性较好，且对无限解的情况处理得当。
- **核心代码**：
  ```cpp
  F(i,1,k){
      ll p=q.top();
      q.pop();
      p--;
      q.push(p);
  }
  ```
  **实现思想**：通过优先队列维护最大出现次数，每次操作将最大出现次数减一，最终判断哪些数可以通过 $k$ 次操作成为众数。

### 最优关键思路与技巧

1. **二分法**：通过二分“众数线”来快速判断哪些数可能成为众数，避免了暴力枚举。
2. **前缀和**：利用前缀和快速计算需要修改的次数，优化了时间复杂度。
3. **优先队列**：通过优先队列维护最大出现次数，逐步减少最大出现次数，最终判断哪些数可以成为众数。

### 可拓展之处

1. **类似题目**：可以扩展到其他需要修改序列元素以达到某种条件的题目，如修改元素使得序列满足某种性质（如单调性、平衡性等）。
2. **算法套路**：二分法、前缀和、优先队列等算法在类似的序列操作题目中都有广泛应用。

### 推荐题目

1. **P1886 滑动窗口**：考察滑动窗口和优先队列的应用。
2. **P3368 【模板】树状数组 2**：考察前缀和和树状数组的应用。
3. **P3374 【模板】树状数组 1**：考察树状数组的基本操作，与本题的前缀和思想类似。

### 个人心得摘录

- **ys_kylin__**：赛时写的比较丑，见谅。（调试经历）
- **fish_love_cat**：我一直以为会 TLE 的，没想到快的飞起（汗）。（调试经历）
- **Link_Cut_Y**：我知道我代码写的丑不要喷好不好。（调试经历）

这些心得反映了在调试过程中遇到的挑战和最终的解决方案，有助于理解代码的优化过程。

---
处理用时：37.31秒
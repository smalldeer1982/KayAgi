# 题目信息

# 「AWOI Round 2 C」数组操作？数组操作！

## 题目描述

给定两个长度为 $n$ 的数组 $a,b$ ，将它们合并得到一个长度为 $2\times n$ 的数组 $c$。

设 $a$ 数组第 $i$ 个元素合并后位于 $c$ 数组第 $lb_i$ 个位置，$b$ 数组第 $i$ 个元素合并后位于 $c$ 数组第 $lc_i$ 个位置，合并后需要满足：$lb_1 < lb_2 < ...< lb_{n-1} < lb_n$ 且 $lc_1 < lc_2< ...< lc_{n-1}< lc_n$，即两个数组中元素的相对位置不变。

合并过后，你需要对 $c$ 数组进行下面操作：

1. 变换操作：选择一个区间 $[l,r]$，对于每一个 $i \in [l,r]$，如果 $c_i$ 为 $y$，则将其变成一个不同于 $y$ 的数，否则将其变为 $y$。
2. 翻转操作：选择一个区间 $[l,r]$，翻转该数组区间中的数。此操作**必须刚好**操作 $z$ 次。

请输出最少需要执行多少次变换操作才能使得 $c$ 数组中的数字都为 $y$。 

## 说明/提示

**【样例说明】**

对于样例 $1$，令 $c$ 为 $\{1,1,1,9,45,1,1,9,4,810\}$。

其中 $c_1=a_1,c_2=b_1,c_3=a_2,c_4=b_2,c_5=a_3,c_6=a_4,c_7=b_3,c_8=b_4,c_9=a_5,c_{10}=b_5$。满足要求。

然后翻转区间 $[4,7]$， $c$ 数组变为 $\{1,1,1,1,1,45,9,9,4,810\}$。

接着执行变换操作，将 $[6,10]$ 中的数全部变成 $1$。

所以最少只需要一次变换操作，可以证明没有比该方法更优的策略。

**【数据规模】**

请注意本题特殊的时间限制，并使用更快的 IO 方式。

**本题使用捆绑测试。**

| 子任务编号 | $n\leqslant$ | 特殊性质 | 分值 |
| -----------: | -----------: | -----------: | -----------: |
| $1$ | $5$ | 无 | $20$ |
| $2$ | $10^6$ | $z>n$ | $5$ |
| $3$ | $10^6$ | 特殊性质 A | $10$ |
| $4$ | $10^6$ | $z=0$ | $25$ |
| $5$ | $10^6$ | 无 | $40$ |

特殊性质 A：保证两个数组中的元素都为 $y$ 或都不为 $y$。

对于全部数据，保证 $0 \leqslant y,z \leqslant 10^9$，输入数据全部在 `int` 范围内。

## 样例 #1

### 输入

```
5 1 1
1 1 45 1 4
1 9 1 9 810```

### 输出

```
1```

## 样例 #2

### 输入

```
20 0 3
1 0 0 8 6 10 0 8 6 1 0 0 86 1 0 0 8 6 0 0
5 2 0 1 3 1 4 52 0 13 14 0 1 0 1 0 4 0 5 0```

### 输出

```
4```

## 样例 #3

### 输入

```
3 2 4
110 105 117
99 108 98```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

这些题解的核心思路大多围绕如何通过合并和翻转操作最小化变换操作次数。主要策略包括：
1. **合并策略**：通过将等于 $y$ 的元素尽可能连续排列，减少需要变换的区间数量。
2. **翻转操作**：利用翻转操作合并相邻的不等于 $y$ 的区间，进一步减少变换操作次数。
3. **统计区间**：通过统计不等于 $y$ 的连续区间数量，结合翻转操作的次数，计算出最少的变换操作次数。

大多数题解都采用了类似的思路，但在实现细节和代码优化上有所不同。部分题解通过双指针或贪心策略优化了合并过程，而另一些则通过预处理或特殊判断简化了计算。

### 所选高星题解

#### 1. 作者：Vct14 (5星)
- **关键亮点**：思路清晰，代码简洁，通过双指针和贪心策略优化了合并过程，且对翻转操作的影响进行了详细分析。
- **个人心得**：作者通过染色法将问题转化为区间合并问题，简化了问题复杂度。
- **核心代码**：
```cpp
bool now=true;
int c1=0,c2=0,s=0;
while(1){
    if(!now) s++;
    while(a[c1+1]==now && c1+1<=n) c1++;
    while(b[c2+1]==now && c2+1<=n) c2++;
    if(c1==n && c2==n) break;
    now=!now;
}
```
- **实现思想**：通过双指针遍历数组，统计不等于 $y$ 的连续区间数量，并结合翻转操作次数计算最终答案。

#### 2. 作者：DecemberFox (4星)
- **关键亮点**：详细分析了翻转操作对区间合并的影响，并通过预处理简化了计算。
- **个人心得**：作者通过预处理统计了不等于 $y$ 的区间数量，避免了复杂的合并过程。
- **核心代码**：
```cpp
for(int i=1;i<=n;++i){
    if(a[i]!=y&&a[i-1]==y) ++apart;
}
for(int i=1;i<=n;++i){
    if(b[i]!=y&&b[i-1]==y) ++bpart;
}
```
- **实现思想**：通过预处理统计不等于 $y$ 的区间数量，并结合翻转操作次数计算最终答案。

#### 3. 作者：Field_Mouse (4星)
- **关键亮点**：通过贪心策略优化了合并过程，并对翻转操作的影响进行了详细分析。
- **个人心得**：作者通过贪心策略将等于 $y$ 的元素尽可能连续排列，减少了需要变换的区间数量。
- **核心代码**：
```cpp
while(i<=n||j<=n){
    if(flag==0) sum++;
    while((a[i]==y)==flag&&i<=n) i++;
    while((b[j]==y)==flag&&j<=n) j++;
    flag^=1;
}
```
- **实现思想**：通过贪心策略将等于 $y$ 的元素尽可能连续排列，并结合翻转操作次数计算最终答案。

### 最优关键思路与技巧
1. **双指针与贪心策略**：通过双指针遍历数组，结合贪心策略优化合并过程，减少需要变换的区间数量。
2. **预处理与统计**：通过预处理统计不等于 $y$ 的区间数量，简化了计算过程。
3. **翻转操作的影响**：利用翻转操作合并相邻的不等于 $y$ 的区间，进一步减少变换操作次数。

### 可拓展之处
1. **区间合并问题**：类似的问题可以通过区间合并的思路解决，如合并相邻的相同元素区间。
2. **翻转操作的应用**：翻转操作在合并区间中的应用可以推广到其他需要合并相邻区间的问题中。

### 推荐题目
1. **P1886 滑动窗口**：考察区间合并与滑动窗口的应用。
2. **P1047 校门外的树**：考察区间合并与统计问题。
3. **P1090 合并果子**：考察贪心策略与合并操作的应用。

### 个人心得总结
- **调试经历**：部分作者在调试过程中发现，翻转操作的区间选择对最终结果有重要影响，需要仔细考虑。
- **踩坑教训**：在处理翻转操作时，需要注意翻转次数与区间合并的关系，避免不必要的翻转操作。
- **顿悟感想**：通过染色法将问题转化为区间合并问题，简化了问题复杂度，提高了代码的可读性和效率。

---
处理用时：37.68秒
# 题目信息

# [SDCPC 2023] Fast and Fat

## 题目描述

您正在参加一场团体越野比赛。您的队伍共有 $n$ 名队员，其中第 $i$ 名队员的速度为 $v_i$，体重为 $w_i$。

比赛允许每名队员独立行动，也允许一名队员背着另一名队员一起行动。当队员 $i$ 背着队员 $j$ 时，如果队员 $i$ 的体重大于等于队员 $j$，则队员 $i$ 的移动速度不会变化，仍然为 $v_i$；如果队员 $i$ 的体重小于队员 $j$，则队员 $i$ 的移动速度会减去两者的体重差值，即变为 $v_i - (w_j - w_i)$。如果队员 $i$ 的移动速度将变为负数，则队员 $i$ 无法背起队员 $j$。每名队员最多只能背负另一名队员，被背负的队员无法同时背负其他队员。

所有未被背负的队员中，最慢的队员的速度，即为整个队伍的速度。求整个队伍能达到的最大速度。

## 样例 #1

### 输入

```
2
5
10 5
1 102
10 100
7 4
9 50
2
1 100
10 1```

### 输出

```
8
1```

# AI分析结果

### 综合分析与结论

本题的核心是通过二分答案和贪心策略来求解队伍的最大速度。所有题解都采用了二分答案的思路，但在具体实现和优化上有所不同。主要难点在于如何高效地检查某个速度是否可行，以及如何合理匹配背负者和被背负者。大部分题解通过排序和优先队列来优化匹配过程，确保较重的队员被背负时能够找到合适的背负者。

### 所选高星题解

#### 1. 作者：SXqwq (赞：9)  
**星级：★★★★★**  
**关键亮点：**  
- 思路清晰，详细解释了二分答案和贪心策略的结合。
- 代码结构合理，使用了排序和优先队列来优化匹配过程。
- 提供了详细的检查函数实现，确保较重的队员优先被背负。

**核心代码：**
```cpp
bool check(int x) {
    vector <int> p,q;
    for(int i=1;i<=n;i++) if(A[i].v >= x) p.push_back(A[i].v+A[i].w-x);
    for(int i=1;i<=n;i++) if(B[i].v < x) q.push_back(B[i].w);
    if(p.size() < q.size()) return false;
    for(int i=0;i<q.size();i++) {
        if(p[i] < q[i]) return false;
    }
    return true;
}
```
**实现思想：**  
通过预处理每个背负者能背负的最大重量，并排序后与需要被背负的队员进行匹配，确保每个较重的队员都能找到合适的背负者。

#### 2. 作者：One_JuRuo (赞：4)  
**星级：★★★★**  
**关键亮点：**  
- 使用优先队列来动态匹配背负者和被背负者，确保较重的队员优先被背负。
- 代码简洁，逻辑清晰，易于理解。

**核心代码：**
```cpp
inline bool check(int x) {
    priority_queue<int>l,r;
    for(int i=1;i<=n;++i) {
        if(t[i].v>=x) r.push(t[i].w+t[i].v);
        else l.push(t[i].w);
    }
    while(!l.empty()&&!r.empty())
        if(r.top()-l.top()>=x) l.pop(),r.pop();
        else return 0;
    return (l.empty());
}
```
**实现思想：**  
通过优先队列分别存储背负者和被背负者，每次取出最大的背负者和被背负者进行匹配，确保较重的队员优先被背负。

#### 3. 作者：zzbzwjx (赞：0)  
**星级：★★★★**  
**关键亮点：**  
- 使用了优先队列来优化匹配过程，确保较重的队员优先被背负。
- 代码简洁，逻辑清晰，易于理解。

**核心代码：**
```cpp
bool f(int v, vector<pair<int, int> > a){
    priority_queue<int> l, r;
    for (auto [x, y] : a) {
        if (x >= v) {
            r.push(y + x - v);
        } else {
            l.push(y);
        }
    }
    while (r.size() && l.size()) {
        if (r.top() >= l.top()) {
            r.pop();l.pop();
        } else {
            return 0;
        }
    }
    if (l.empty()) return 1;
    return 0;
}
```
**实现思想：**  
通过优先队列分别存储背负者和被背负者，每次取出最大的背负者和被背负者进行匹配，确保较重的队员优先被背负。

### 最优关键思路与技巧

1. **二分答案**：通过二分搜索来确定最大速度，确保每次检查的速度是可行的。
2. **贪心策略**：在检查函数中，优先让较重的队员被背负，确保匹配的合理性。
3. **排序与优先队列**：通过排序和优先队列来优化匹配过程，确保较重的队员优先被背负。

### 可拓展之处

- **类似算法套路**：二分答案结合贪心策略的题目在竞赛中较为常见，如最小化最大值、最大化最小值等问题。
- **同类型题目**：可以尝试解决其他需要二分答案和贪心策略的题目，如背包问题、任务调度等。

### 推荐题目

1. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)  
2. [P1083 借教室](https://www.luogu.com.cn/problem/P1083)  
3. [P1280 尼克的任务](https://www.luogu.com.cn/problem/P1280)

### 个人心得摘录

- **SXqwq**：在检查函数中，通过预处理每个背负者能背负的最大重量，并排序后与需要被背负的队员进行匹配，确保每个较重的队员都能找到合适的背负者。
- **One_JuRuo**：使用优先队列来动态匹配背负者和被背负者，确保较重的队员优先被背负。
- **zzbzwjx**：通过优先队列分别存储背负者和被背负者，每次取出最大的背负者和被背负者进行匹配，确保较重的队员优先被背负。

---
处理用时：45.27秒
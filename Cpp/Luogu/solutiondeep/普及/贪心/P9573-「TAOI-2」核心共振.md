# 题目信息

# 「TAOI-2」核心共振

## 题目背景

⚡超越一切震慑凡人⚡

⚡带来终结机械降神⚡

⚡风暴之力充满全身⚡

⚡最后一击核心共振⚡

## 题目描述

给定正整数 $p$ 和 $n$。对于一个排列，我们称其中相邻两项产生「共振」当且仅当这两个数的和为 $p$ 的倍数。

请你构造一个 $1 \sim n$ 的排列，最大化其中产生「共振」的次数。如果有多种方案，输出任意一种即可。

## 说明/提示

**本题采用捆绑测试。**

+ Subtask 0（15 pts）：$n \leq 9$，$T \le 10$。
+ Subtask 1（10 pts）：$p = 2$。
+ Subtask 2（30 pts）：$p = 3$。
+ Subtask 3（45 pts）：无特殊限制。

对于所有数据，$1 \leq n \leq 10^5$，$1 \leq p \leq 10^8$，$1 \leq T \leq 10^4$，$1 \leq \sum n \leq 3\times 10^5$。

## 样例 #1

### 输入

```
3
9 1
5 2
1 12345
```

### 输出

```
3 8 7 1 4 5 6 9 2
1 5 3 2 4
1
```

# AI分析结果

### 综合分析与结论

本题的核心在于构造一个排列，使得相邻两项的和为 $p$ 的倍数的次数最大化。大多数题解都采用了类似的思路：将数字按模 $p$ 的余数分类，然后尽量将余数互补的数相邻排列。部分题解还针对 $p$ 的特殊情况（如 $p=2$、$p=3$ 或 $p$ 为偶数）进行了优化。整体来看，题解的质量参差不齐，部分题解思路清晰且代码简洁，而有些则存在冗余或不够优化的地方。

### 所选高星题解

#### 1. 作者：include13_fAKe (赞：11)  
**星级：4.5**  
**关键亮点：**  
- 详细分析了不同子任务（$p=2$、$p=3$ 等）的解法，并给出了通用解法。
- 针对 $p$ 为偶数的情况进行了特殊处理，避免了重复输出。
- 代码简洁且高效，使用了简单的循环和条件判断，避免了复杂的数据结构。

**个人心得：**  
作者在调试过程中发现，当 $p$ 过大时，代码的时间复杂度会显著增加，因此特别处理了 $2n \leq p$ 的情况，直接输出顺序排列。这一优化避免了不必要的计算，提升了代码的效率。

**核心代码：**
```cpp
for(int i=1;i*2<p;i++){
    for(int j=0;j<=n;j+=p){
        if(i+j<=n) printf("%d ",i+j);
        if(j+p-i<=n) printf("%d ",j+p-i);
    }
}
for(int i=p;i<=n;i+=p) printf("%d ",i);
if(p%2==0){
    for(int i=p/2;i<=n;i+=p) printf("%d ",i);
}
```
**实现思想：**  
通过遍历余数互补的数对，交替输出，最后处理 $p$ 的倍数和 $p$ 为偶数时的特殊情况。

#### 2. 作者：_mi_ka_ (赞：2)  
**星级：4**  
**关键亮点：**  
- 通过观察数据范围，提出了当 $p > 2n$ 时无法产生共振的结论，直接输出顺序排列。
- 详细解释了如何通过枚举余数来构造排列，确保相邻数的和为 $p$ 的倍数。
- 代码结构清晰，逻辑严谨，适合初学者理解。

**核心代码：**
```cpp
for(int i=1;i*p<=n;i++) wr(i*p),putchar(' ');
for(int r=1;r<=p/2;r++){
    wr(r),putchar(' ');
    for(int i=1;i*p-r<=n;i++){
        if(r==(p-r)&&i==1) continue;
        else if(r==(p-r)) wr(i*p-r),putchar(' ');
        else{
            wr(i*p-r),putchar(' ');
            if(i*p+r>n) break;
            wr(i*p+r),putchar(' ');
        }
    }
}
```
**实现思想：**  
先输出 $p$ 的倍数，然后枚举余数 $r$，交替输出余数为 $r$ 和 $p-r$ 的数，确保相邻数的和为 $p$ 的倍数。

#### 3. 作者：Convergent_Series (赞：2)  
**星级：4**  
**关键亮点：**  
- 提出了当 $p \geq 2n$ 时无法共振的结论，直接输出顺序排列。
- 通过枚举余数 $m$，交替输出余数为 $m$ 和 $p-m$ 的数，确保相邻数的和为 $p$ 的倍数。
- 代码简洁且高效，适合竞赛使用。

**核心代码：**
```cpp
for(int m1=1,m2=p-1;m1<=p/2;m1++,m2--){
    if(m1!=m2){
        for(int i=0;i+m2<=n;i+=p) write(i+m1),pcs,write(i+m2),pcs;
        if((int)(n/p)*p+m1<=n&&(int)(n/p)*p+m2>n) write((int)(n/p)*p+m1),pcs;
    }
    else for(int i=0;i+m1<=n;i+=p) write(i+m1),pcs;
}
```
**实现思想：**  
通过枚举余数 $m$，交替输出余数为 $m$ 和 $p-m$ 的数，确保相邻数的和为 $p$ 的倍数。

### 最优关键思路与技巧

1. **按余数分类：** 将数字按模 $p$ 的余数分类，尽量将余数互补的数相邻排列。
2. **特殊情况处理：** 当 $p$ 为偶数时，需要特别处理余数为 $p/2$ 的数，避免重复输出。
3. **优化条件：** 当 $p \geq 2n$ 时，直接输出顺序排列，避免不必要的计算。

### 可拓展之处

本题的解法可以推广到类似的构造问题，如要求相邻数的差为某个数的倍数，或者要求相邻数的乘积为某个数的倍数。这类问题通常可以通过分类和交替排列的思路来解决。

### 推荐题目

1. **P1091 合唱队形**（考察构造与排列）
2. **P1064 金明的预算方案**（考察分类与优化）
3. **P1045 麦森数**（考察数学与构造）

### 个人心得总结

- **调试经验：** 在处理 $p$ 较大的情况时，直接输出顺序排列可以显著提升代码效率，避免不必要的计算。
- **优化技巧：** 通过枚举余数并交替输出互补的数，可以最大化共振次数，同时保持代码的简洁性。
- **思维突破：** 在处理构造问题时，分类和交替排列的思路是常见的解题技巧，值得深入理解和掌握。

---
处理用时：51.86秒
# 题目信息

# 「MXOI Round 2」排名

## 题目描述

小 C 有一个长度为 $n$ 的数组 $a$。

小 C 定义，$f(i)$ 为 $a_i$ 的前排名，其中 $f(i)$ 等于数组 $a$ 中大于 $a_i$ 的元素个数加 $1$。

小 C 还定义，$g(i)$ 为 $a_i$ 的后排名，其中 $g(i)$ 等于数组 $a$ 中大于等于 $a_i$ 的元素个数。

每次操作，小 C 需要选择一个不大于 $n$ 的正整数 $t$，并将 $a_t$ 的值增加 $1$。

小 C 想知道，对于每一个 $1 \le i \le n$，想要使 $f(i) \le k \le g(i)$，最少需要进行多少次操作？

可以证明一定存在一种操作方案使得 $f(i) \le k \le g(i)$。

## 说明/提示

#### 【样例解释 #1】

当 $i=1$ 时，小 C 可以选择 $t=1$ 并进行 $3$ 次操作。此时 $f(i)=2$，$g(i)=4$，满足 $f(i) \le k \le g(i)$。可以证明此时小 C 至少需要进行 $3$ 次操作。

当 $i=4$ 时，小 C 可以选择 $t=3$ 进行 $1$ 次操作，再选择 $t=6$ 进行 $1$ 次操作。此时 $f(i)=1$，$g(i)=3$，满足 $f(i) \le k \le g(i)$。可以证明此时小 C 至少需要进行 $2$ 次操作。

#### 【样例 #2】

见附加文件中的 `rank/rank2.in` 与 `rank/rank2.ans`。

该样例满足测试点 $7$ 的限制。

#### 【样例 #3】

见附加文件中的 `rank/rank3.in` 与 `rank/rank3.ans`。

该样例满足测试点 $20$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le k \le n \le 5 \times 10^5$，$1 \le a_i \le 10^9$。

|测试点编号|$n \le$|$a_i \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim6$|$2000$|$10^9$|A|
|$7\sim10$|$2000$|$10^9$|无|
|$11\sim14$|$5\times10^5$|$10^9$|B|
|$15\sim20$|$5\times10^5$|$10^9$|无|

特殊性质 A：保证对于所有的 $1 \le i \lt n$，都有 $a_i \ge a_{i+1}$。

特殊性质 B：保证 $k=1$。

## 样例 #1

### 输入

```
0 6 3
1 1 4 5 1 4```

### 输出

```
3
3
0
2
3
0```

# AI分析结果

### 综合分析与结论

本题的核心在于通过排序和前缀和优化，快速计算每个元素的最小操作次数，使得其满足给定的排名条件。多数题解都采用了类似的思路：先对数组排序，然后根据元素的位置和值进行分类讨论，最后通过前缀和或二分查找来优化计算。以下是对各题解的简要分析与评分：

1. **卷王**：思路清晰，代码简洁，通过排序和前缀和优化，时间复杂度为 \(O(n \log n)\)。评分：4星。
2. **Coffee_zzz**：详细解释了分类讨论的思路，并通过前缀和优化计算，代码可读性较好。评分：4星。
3. **XiaoQuQu**：思路与卷王类似，代码简洁，通过排序和前缀和优化，时间复杂度为 \(O(n \log n)\)。评分：4星。

### 所选高分题解

#### 1. 卷王 (4星)
**关键亮点**：
- 通过排序和前缀和优化，快速计算每个元素的最小操作次数。
- 代码简洁，思路清晰，适合初学者理解。

**核心代码**：
```cpp
sort(a + 1, a + n + 1, cmp);
for(int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i].x;
for(int i = 1; i <= n; i++) {
    if(a[i].x == a[k].x) continue;
    if(a[i].x < a[k].x) ans[a[i].num] = a[k].x - a[i].x;
    else ans[a[i].num] = (k - i) * 1ll * a[i].x - (sum[k] - sum[i]);
}
```
**实现思想**：先排序，然后根据元素的位置和值进行分类讨论，通过前缀和优化计算操作次数。

#### 2. Coffee_zzz (4星)
**关键亮点**：
- 详细解释了分类讨论的思路，并通过前缀和优化计算。
- 代码可读性较好，适合有一定基础的读者。

**核心代码**：
```cpp
sort(nod + 1, nod + n + 1, cmp);
reverse(nod + 1, nod + n + 1);
for(int i = k; i <= n; i++) ans[nod[i].id] = nod[k].a - nod[i].a;
for(int i = k - 1; i >= 1; i--) f[i] = f[i + 1] + 1ll * (k - i) * (nod[i].a - nod[i + 1].a), ans[nod[i].id] = f[i];
```
**实现思想**：先排序，然后根据元素的位置和值进行分类讨论，通过前缀和优化计算操作次数。

#### 3. XiaoQuQu (4星)
**关键亮点**：
- 思路与卷王类似，代码简洁，通过排序和前缀和优化。
- 时间复杂度为 \(O(n \log n)\)，适合快速解决问题。

**核心代码**：
```cpp
sort(a + 1, a + 1 + n);
for(int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i].v;
for(int i = 1; i < k; ++i) ans[a[i].i] = (k - i) * a[i].v - (s[k] - s[i]);
for(int i = k; i <= n; ++i) ans[a[i].i] = a[k].v - a[i].v;
```
**实现思想**：先排序，然后根据元素的位置和值进行分类讨论，通过前缀和优化计算操作次数。

### 最优关键思路与技巧

1. **排序与分类讨论**：通过排序将问题转化为分类讨论，简化计算。
2. **前缀和优化**：利用前缀和快速计算区间和，减少时间复杂度。
3. **二分查找**：在某些情况下，使用二分查找可以进一步优化计算。

### 可拓展之处

1. **类似问题**：可以扩展到其他需要根据元素值进行排名或分类的问题，如求中位数、百分位数等。
2. **数据结构**：可以结合其他数据结构（如线段树、树状数组）进一步优化计算。

### 推荐题目

1. **P1177 【模板】快速排序**：练习排序算法的实现。
2. **P3374 【模板】树状数组 1**：学习前缀和与树状数组的应用。
3. **P3368 【模板】线段树 1**：掌握线段树在区间查询与更新中的应用。

### 个人心得摘录

- **卷王**：通过部分分逐步理解题意，最终找到规律并优化代码。
- **Coffee_zzz**：通过分类讨论和前缀和优化，解决了时间复杂度问题。
- **XiaoQuQu**：通过排序和前缀和优化，快速解决了问题，代码简洁易读。

这些心得展示了从部分分到整体优化的思考过程，适合初学者学习和借鉴。

---
处理用时：40.44秒
# 题目信息

# [CERC2019] Light Emitting Hindenburg

## 题目背景

**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Light Emitting Hindenburg](https://contest.felk.cvut.cz/19cerc/solved/hindenburg.pdf)」**

## 题目描述

Lothar 正在组织他朋友的摇滚乐队的音乐会巡演。巡演将于 11 月举行，每天最多有一场音乐会。这次巡演将非常具有代表性，许多音乐家都愿意参加。巡演中的音乐家人数是严格规定的，不能改变。巡演中的每一场音乐会都必须有所有参加巡演的音乐家参加。

对 Lothar 来说，好消息是，候选音乐家的数量至少与巡演中规定的音乐家数量一样多。坏消息是，一个典型的音乐家整个月都没有空，而且各种音乐家的日程安排也大不相同。

很久以前，Lothar 编写了一个计算机调度系统的核心，现在他正在利用它来组织这次巡演。他反复地、有点随机地选择一组指定数量的音乐家，并让系统计算出一个可接受的巡演时间表。该系统取决于一种非常具体的数据格式。音乐家的时间表和巡演时间表用数字编码表示。11 月的日子是按月份的数字标记的：$1, 2, \dots, 30$。

对于一个给定的音乐家来说，每年 11 月的一天都会被分配一个特定的数字编码。如果音乐家当天空闲，则标签为 $L$ 的一天由整数 $2^{30-L}$ 编码。否则，日期将由 $0$ 编码。音乐家的时间表编码是他或她的所有日期编码的总和。

对于一组给定的音乐家来说，每年 11 月的一天都会被分配一个特定的数字编码。如果该组中的所有音乐家当天都空闲，标签为 $L$ 的一天由整数 $2^{30-L}$ 编码。否则，日期将由 $0$ 编码。组的空闲编码是该组所有日期编码的总和。

出于许多其他微妙的原因，Lothar 认为最好的巡演应该是任意一组音乐家，这组的空闲编码是可能的最大值。

## 样例 #1

### 输入

```
5 2
6 15 9 666 1
```

### 输出

```
10
```

## 样例 #2

### 输入

```
8 4
13 30 27 20 11 30 19 10
```

### 输出

```
18
```

# AI分析结果

### 综合分析与结论

本题的核心是从给定的 \( n \) 个数中选出 \( k \) 个数，使得它们的按位与运算结果最大。所有题解都采用了贪心算法，从最高位开始逐位检查，确保当前位有至少 \( k \) 个数的该位为 1，然后将这些数标记为候选，继续检查下一位。这种贪心策略的正确性基于二进制位的高位权重远大于低位权重，因此优先选择高位为 1 的数可以保证最终结果的最大化。

### 所选高星题解

#### 1. 题解作者：codwarm (4星)
**关键亮点：**
- 思路清晰，详细解释了贪心策略的正确性。
- 代码结构简洁，注释明确，易于理解。
- 使用了 `vis` 数组来标记候选数，优化了后续的检查过程。

**核心代码：**
```cpp
for (int i = 30; i >= 1; i--) {
    cnt = 0;
    for (int j = 1; j <= n; j++) 
        if (vis[j] && (a[j] >> (i - 1) & 1)) 
            cnt++;
    if (cnt < k) continue;
    for (int j = 1; j <= n; j++)
        if (!(vis[j] && (a[j] >> (i - 1) & 1))) 
            vis[j] = 0;
    maxn += (int)pow(2,i-1);
}
```
**实现思想：** 从最高位开始检查，统计当前位为 1 的数的个数，若满足条件则累加结果并标记候选数。

#### 2. 题解作者：Flaw_Owl (4星)
**关键亮点：**
- 详细分析了贪心策略的正确性，并通过例子解释了为什么优先选择高位为 1 的数。
- 代码实现清晰，使用了 `check` 数组来标记候选数，优化了后续的检查过程。

**核心代码：**
```cpp
for (int i = 29; i >= 0; i--) {
    int cnt = 0;
    for (int j = 1; j <= N; j++) {
        int temp = (a[j] >> i) & 1;
        if (check[j] && temp) cnt++;
    }
    if (cnt >= K) {
        for (int j = 1; j <= N; j++) {
            int temp = (a[j] >> i) & 1;
            if (check[j] && !temp) check[j] = false;
        }
        ans += (1 << i);
    }
}
```
**实现思想：** 从最高位开始检查，统计当前位为 1 的数的个数，若满足条件则累加结果并标记候选数。

#### 3. 题解作者：wangjue233 (4星)
**关键亮点：**
- 详细解释了贪心策略的正确性，并通过例子说明了为什么优先选择高位为 1 的数。
- 代码实现清晰，使用了 `vis` 数组来标记候选数，优化了后续的检查过程。

**核心代码：**
```cpp
for (int i = 29; i >= 0; i--) {
    int val = 1 << i;
    int cnt = 0;
    for (int j = 1; j <= n; j++) {
        if (vis[j] && (a[j] & val)) cnt++;
    }
    if (cnt >= k) {
        ans += val;
        for (int j = 1; j <= n; j++) {
            if ((a[j] & val) == 0) vis[j] = false;
        }
    }
}
```
**实现思想：** 从最高位开始检查，统计当前位为 1 的数的个数，若满足条件则累加结果并标记候选数。

### 最优关键思路或技巧
- **贪心策略**：从最高位开始逐位检查，优先选择高位为 1 的数，确保最终结果的最大化。
- **标记数组**：使用 `vis` 或 `check` 数组来标记候选数，优化后续的检查过程。

### 可拓展之处
- **类似算法套路**：这种逐位检查的贪心策略可以应用于其他位运算问题，如按位或、按位异或等。
- **同类型题**：可以尝试解决其他涉及位运算的贪心问题，如选择 \( k \) 个数使得它们的按位或运算结果最大。

### 推荐题目
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

### 个人心得总结
- **调试经历**：在实现过程中，确保 `vis` 数组的正确更新是关键，否则会导致后续检查错误。
- **顿悟感想**：贪心策略的正确性基于二进制位的高位权重远大于低位权重，优先选择高位为 1 的数可以保证最终结果的最大化。

---
处理用时：41.47秒
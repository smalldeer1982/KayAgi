# 题目信息

# [SNCPC2019] Coolbits

## 题目描述

给定 $n$ 个区间 $[l_1, r_1], [l_2, r_2], \dots, [l_n, r_n]$，需要从每个区间中选择一个整数并计算它们的按位与值 $b$。能够得到的最大 $b$ 是多少？

## 样例 #1

### 输入

```
2
3
0 8
2 6
3 9
1
1 100
```

### 输出

```
6
100
```

# AI分析结果

### 综合分析与结论

本题的核心是通过贪心思想，从高位到低位逐位确定按位与的最大值。各题解均采用了类似的思路，即从最高位开始，尝试将每一位置为1，并检查是否在每个区间内存在满足条件的数。如果存在，则将该位置为1，并缩小区间范围；否则跳过该位。

### 所选高星题解

#### 1. 作者：Flaw_Owl (4星)
- **关键亮点**：思路清晰，代码结构良好，详细解释了如何通过位运算调整区间左端点，并检查是否满足条件。
- **核心代码**：
  ```cpp
  int cal(int x, int i) {
      if (!((x >> i) & 1))
          x = ((x >> i) | 1) << i;
      return x;
  }
  ```
  **实现思想**：通过位运算调整区间左端点，确保第i位为1，并检查是否在区间范围内。

#### 2. 作者：Shunpower (4星)
- **关键亮点**：代码简洁，逻辑清晰，直接通过位运算判断并调整区间，适合快速理解。
- **核心代码**：
  ```cpp
  int upperbound(int x, int i) {
      if (!((x >> i) & 1))
          x = ((x >> i) | 1) << i;
      return x;
  }
  ```
  **实现思想**：通过位运算调整区间左端点，确保第i位为1，并检查是否在区间范围内。

#### 3. 作者：sieve (4星)
- **关键亮点**：代码简洁，逻辑清晰，直接通过位运算判断并调整区间，适合快速理解。
- **核心代码**：
  ```cpp
  int bit(int x, int i) {
      if (((x >> i) & 1) == 0) {
          x = (x >> i) | 1;
          x <<= i;
      }
      return x;
  }
  ```
  **实现思想**：通过位运算调整区间左端点，确保第i位为1，并检查是否在区间范围内。

### 最优关键思路与技巧

1. **贪心思想**：从高位到低位逐位确定按位与的最大值，确保高位尽可能为1。
2. **位运算优化**：通过位运算快速调整区间左端点，确保第i位为1，并检查是否在区间范围内。
3. **区间缩小**：在确定某一位为1后，缩小区间范围，确保后续位的选择不影响高位。

### 可拓展之处

- **类似题目**：可以扩展到其他需要逐位确定结果的题目，如按位或、按位异或等。
- **优化思路**：可以考虑使用更高效的位运算技巧，进一步优化代码性能。

### 推荐题目

1. [P9612 [CERC2019] Light Emitting Hindenburg](https://www.luogu.com.cn/problem/P9612)
2. [P1004 [NOIP2000 提高组] 方格取数](https://www.luogu.com.cn/problem/P1004)
3. [P1040 [NOIP2003 提高组] 加分二叉树](https://www.luogu.com.cn/problem/P1040)

### 个人心得总结

- **调试经历**：在调整区间左端点时，需要注意位运算的优先级，避免因括号问题导致错误。
- **顿悟感想**：贪心思想在逐位确定结果时非常有效，能够快速缩小问题规模，提高解题效率。

---
处理用时：30.80秒
# 题目信息

# 『GROI-R2』 不空白的画布

## 题目描述

我们都知道爱丽丝躲起来之后，坦尼尔坐在了空白画布面前，拿起炭笔开始作画。

但是现在画布已经不再空白，因为画布上已经有了当下的风景。我们设画布的长度是 $n$，每一单位长度上的颜色可以用一个在 $[1,k]$ 范围内的正整数表示。

坦尼尔还要画他已经翻了的茶杯。每一次作画，他可以选定画布上的任意一个位置，然后将这个位置上的颜色涂改成 $[1,k]$ 范围内的任意正整数。

最后，我们都知道这幅画是有记忆的。定义画上留下的记忆碎片数量为画上的**相同颜色连续块个数**。现在坦尼尔想知道，如果给定他作画的次数**上限**，那么画上的记忆碎片个数**最多**有多少。

**形式化题面**

你有连续的 $n$ 个方格，每个方格上有一个初始颜色 $c_i$，且保证 $1\le c_i \le k$。

你可以操作**至多** $m$ 次，每个操作为改变某个方格颜色，要求改变后的颜色范围仍在 $[1,k]$ 内。

我们称一个**极长相同颜色连续段**为一块，要求求出经过至多 $m$ 次操作后的**最多**块数。


## 说明/提示

**样例解释**

对于第一组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，得到 $\{c_n\}=\{2,1,2\}$，块数为 $3$。


对于第二组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，将从左到右的第三个位置涂成颜色 $3$，得到 $\{c_n\}=\{2,1,3,2,3\}$，块数为 $5$。

**数据范围**

**本题采用捆绑测试**。

| $\text{Subtask}$ | $\sum n\le$ | $m\le$ | $k\le$ | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------:  |
| $1$ | $10$ | $10$ | $3$ | $10$ |
| $2$ | $5\times 10^5$ | $1$ | $5\times 10^5$ | $10$ |
| $3$ | $10^3$ | $10^3$ | $10^3$ | $15$ |
| $4$ | $5\times 10^5$ | $5\times 10^5$ | $3$ | $25$ |
| $5$ | $5\times 10^5$ | $5\times 10^5$ | $5\times 10^5$ | $40$ |

对于 $100\%$ 的数据满足 $1\le  n\le 5\times 10^5$，$1\le \sum n\le 5\times 10^5$，$1\le m\le n$，$3\le  k \le 5\times 10^5$，$1\le c_i\le k$。


## 样例 #1

### 输入

```
2
3 1 3
2 2 2
5 2 4
2 2 2 2 3```

### 输出

```
3
5```

# AI分析结果

### 综合分析与结论

本题的核心目标是通过最多 `m` 次操作，最大化画布上相同颜色连续块的个数。所有题解都采用了贪心算法，优先处理能够带来最大收益的操作（即连续三个相同颜色的块），然后再处理连续两个相同颜色的块。由于 `k >= 3`，修改后的颜色可以保证与相邻块不同，因此无需考虑颜色冲突问题。

大多数题解的思路相似，但在实现细节和代码优化上有所不同。部分题解通过优先队列或更复杂的统计方法来优化操作顺序，而其他题解则通过简单的遍历来实现。

### 所选高星题解

#### 1. 作者：fish_love_cat (★★★★★)
**关键亮点：**
- 思路清晰，代码简洁，直接通过遍历处理连续三个和两个相同颜色的块。
- 使用特殊值 `jsq` 来标记修改后的颜色，避免与原有颜色冲突。
- 代码可读性强，逻辑简单明了。

**核心代码：**
```cpp
for(int i=2;m&&i<n;i++) 
    if(c[i-1]==c[i]&&c[i]==c[i+1]) 
        m--,c[i]=(--jsq),ans+=2;
for(int i=1;m&&i<n;i++) 
    if(c[i]==c[i+1]) 
        m--,c[i]=(--jsq),ans++;
```
**核心思想：** 优先处理连续三个相同颜色的块，每次操作增加2个块；然后处理连续两个相同颜色的块，每次操作增加1个块。

#### 2. 作者：kanzaki (★★★★☆)
**关键亮点：**
- 通过遍历两遍数组，分别处理连续三个和两个相同颜色的块。
- 使用 `flag` 标记修改后的颜色，避免与原有颜色冲突。
- 代码结构清晰，逻辑简单。

**核心代码：**
```cpp
for(int j=2;j<n;j++) {
    if(m<=0) break;
    if(c[j]==c[j-1]&&c[j]==c[j+1]) {
        c[j]=flag;
        ans+=2;
        m--;
    }
}
for(int j=1;j<n;j++) {
    if(m<=0) break;
    if(c[j]==c[j+1]) {
        c[j]=flag;
        ans++;
        m--;
    }
}
```
**核心思想：** 优先处理连续三个相同颜色的块，每次操作增加2个块；然后处理连续两个相同颜色的块，每次操作增加1个块。

#### 3. 作者：Wi_Fi (★★★★☆)
**关键亮点：**
- 使用优先队列维护连续块的长度，优先处理长度大于2的块。
- 通过优先队列优化操作顺序，确保每次操作都能带来最大收益。
- 代码结构清晰，逻辑较为复杂但优化效果明显。

**核心代码：**
```cpp
priority_queue<int>q;
for(int i=1;i<=n;i++) {
    if(c[i]==c[i-1]) sum++;
    else q.push(sum),ans++,sum=1;
}
q.push(sum),ans++;
for(int i=1;i<=m;i++) {
    int fr=q.top(),l1,l2;
    if(fr==2) ans++;
    if(fr>=3) ans+=2;
    fr--,l1=1,l2=fr-1;
    q.pop(),q.push(l1),q.push(l2);
}
```
**核心思想：** 使用优先队列维护连续块的长度，优先处理长度大于2的块，每次操作增加2个块；然后处理长度等于2的块，每次操作增加1个块。

### 最优关键思路与技巧

1. **贪心策略**：优先处理能够带来最大收益的操作（即连续三个相同颜色的块），然后再处理连续两个相同颜色的块。
2. **颜色标记**：使用特殊值标记修改后的颜色，避免与原有颜色冲突。
3. **优先队列优化**：通过优先队列维护连续块的长度，确保每次操作都能带来最大收益。

### 可拓展之处

- **类似问题**：在处理最大化或最小化某种属性的问题时，贪心策略常常是一个有效的解决方案。例如，在任务调度、资源分配等问题中，贪心算法可以用于优化操作顺序。
- **数据结构优化**：在需要频繁处理最大值或最小值的问题中，优先队列是一个非常有用的数据结构。

### 推荐题目

1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880) - 考察贪心策略和区间DP。
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090) - 考察贪心策略和优先队列。
3. [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048) - 考察贪心策略和背包问题。

---
处理用时：40.32秒
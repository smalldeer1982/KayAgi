# 题目信息

# 『PG2』消除萝卜 A

## 题目描述

有 $2\times n$ 的两行萝卜，萝卜分白萝卜和红萝卜，我们使用 $a_{i,j}=0/1$ 来表示第 $j$ 行第 $i$ 个萝卜是白萝卜还是红萝卜。

你每次可以花 $1$ 的代价，选定一个有萝卜的位置，并将这个萝卜所在的由同种颜色萝卜所构成的四连通极大连通块的萝卜全部拿走，然后一个在第二行的萝卜如果其对应的第一行的位置没有萝卜，就会掉落至第一行。

请问拿走所有萝卜的最小代价是多少。

## 说明/提示

对于所有测试点 $a_{i,j}\in \{0,1\}$，$1\leq n\leq 5\times 10^6$。

**本题使用捆绑测试**

$\sf subtask \ 1: n\leq1 \ \ \ \ \ \ \ \ \ \ \ \ \ 10pts$   
$\sf subtask \ 2: n\leq10 \ \ \ \ \ \ \ \ \ \ \ 20pts $   
$\sf subtask \ 3: n\leq100 \ \ \ \ \ \ \ \ \ 15 pts$   
$\sf subtask \ 4: n\leq5000 \ \ \ \ \ \ \ 15 pts$   
$\sf subtask \ 5: n\leq500000 \ \ \ 20pts$   
$\sf subtask \ 6: n\leq5000000 \ 20pts$   

## 样例 #1

### 输入

```
3
0 1 0
1 0 1```

### 输出

```
4```

## 样例 #2

### 输入

```
6
1 0 1 0 0 1
1 1 0 1 0 1```

### 输出

```
5```

## 样例 #3

### 输入

```
10
0 0 1 1 1 1 1 1 0 0 
0 1 1 0 1 0 0 0 0 1 
```

### 输出

```
5```

## 样例 #4

### 输入

```
10
0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0```

### 输出

```
11```

## 样例 #5

### 输入

```
10
1 0 1 1 1 0 0 1 0 1
0 0 0 1 0 1 0 1 1 0```

### 输出

```
8```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何在两行萝卜的布局中，通过最少的操作次数消除所有萝卜。题解中主要采用了贪心算法和搜索算法（如BFS、DFS）来解决该问题。贪心算法的思路是优先消除一种颜色的萝卜，然后再消除另一种颜色，以此来减少操作次数。搜索算法则通过遍历萝卜的连通块来实现消除操作。

大部分题解的思路较为相似，但在实现细节和优化程度上有所差异。部分题解通过递推的方式简化了问题，而另一些则通过搜索算法来实现消除操作。整体来看，贪心算法结合搜索的实现方式较为高效，且代码可读性较好。

### 所选高星题解

#### 1. 作者：SSqwq_ (5星)
**关键亮点**：
- 采用贪心算法，优先消除第二行的萝卜，再处理下落事件，最后消除第一行的萝卜。
- 使用BFS进行连通块的消除，代码结构清晰，逻辑严谨。
- 提供了正确性证明，增强了算法的可信度。

**核心代码**：
```cpp
void bfs(int sx, int sy) {
    F q;
    q.x = sx, q.y = sy;
    qu.push(q);
    while (!qu.empty()) {
        q = qu.front();
        qu.pop();
        int x = q.x, y = q.y;
        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 1 || nx > n || ny < 1 || ny > 2 || a[nx][ny] != p) continue;
            a[nx][ny] = 2;
            q.x = nx, q.y = ny;
            qu.push(q);
        }
    }
}
```
**核心思想**：通过BFS遍历连通块，将相同颜色的萝卜消除，并标记为已处理。

#### 2. 作者：HasNoName (4星)
**关键亮点**：
- 采用DFS进行连通块的消除，代码简洁，易于理解。
- 通过交换操作实现萝卜的下落，逻辑清晰。
- 提供了边界处理，避免了越界问题。

**核心代码**：
```cpp
void dfs(int x, int y) {
    int c = a[x][y];
    a[x][y] = -1;
    if (c == a[x + 1][y]) dfs(x + 1, y);
    if (c == a[x][y + 1]) dfs(x, y + 1);
    if (c == a[x - 1][y]) dfs(x - 1, y);
    if (c == a[x][y - 1]) dfs(x, y - 1);
    if (x == 2) swap(a[2][y], a[1][y]);
}
```
**核心思想**：通过DFS遍历连通块，消除相同颜色的萝卜，并在消除后处理萝卜的下落。

#### 3. 作者：Kevin911 (4星)
**关键亮点**：
- 采用贪心算法，优先消除第二行的萝卜，再处理下落事件，最后消除第一行的萝卜。
- 使用BFS进行连通块的消除，代码结构清晰，逻辑严谨。
- 提供了边界处理，避免了越界问题。

**核心代码**：
```cpp
void bfs(int sx, int sy) {
    a[sx][sy] = 2;
    q.push({sx, sy});
    while (!q.empty()) {
        int x = q.front().first, y = q.front().second;
        q.pop();
        for (int i = 0; i < 4; i++) {
            int xx = x + fx[i], yy = y + fy[i];
            if (!(xx > 0 && xx <= n && yy >= 1 && yy <= 2 && a[xx][yy] == p)) continue;
            a[xx][yy] = 2;
            q.push({xx, yy});
        }
    }
}
```
**核心思想**：通过BFS遍历连通块，将相同颜色的萝卜消除，并标记为已处理。

### 最优关键思路与技巧

1. **贪心算法**：优先消除一种颜色的萝卜，再处理另一种颜色，可以减少操作次数。
2. **搜索算法（BFS/DFS）**：通过遍历连通块来实现消除操作，确保所有相同颜色的萝卜被一次性消除。
3. **边界处理**：在搜索过程中，通过边界判断避免越界问题，确保算法的稳定性。

### 可拓展之处

- **类似问题**：可以扩展到多行或多列的消除问题，如三消游戏中的消除操作。
- **算法优化**：可以考虑使用并查集等数据结构来优化连通块的查找和合并操作。

### 推荐题目

1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

### 个人心得总结

- **调试经历**：部分题解中提到在实现过程中遇到了边界问题，通过增加边界判断解决了问题。
- **踩坑教训**：在使用DFS时，需要注意递归深度，避免栈溢出问题。
- **顿悟感想**：通过贪心算法优先处理一种颜色的萝卜，可以显著减少操作次数，这一思路在实际问题中具有广泛的应用价值。

---
处理用时：43.66秒
# 题目信息

# 『PG2』消除萝卜 B

## 题目描述

有 $n\times 2$ 的两列萝卜，萝卜分白萝卜和红萝卜，我们使用 $a_{i,j}=0/1$ 来表示第 $i$ 行第 $j$ 个萝卜是白萝卜还是红萝卜。

你每次可以花 $1$ 的代价，选定一个有萝卜的位置，并将这个萝卜所在的由同种颜色萝卜所构成的四连通极大连通块的萝卜全部拿走，然后一个在第 $i$ 行的萝卜如果其对应的第 $i-1$ 行的位置没有萝卜，就会掉落至第 $i-1$ 行。

同时你也可以花初始为 $0$ 的代价，选定 $k=1/2$ 而将第 $k$ 列的所有萝卜上移（$a_{i,k}\to a_{i+1,k}$），并将一个红萝卜即 $1$ 放在第一行第 $k$ 个（$1\to a_{1,k}$），此后这个操作代价 $+1$。 

请问拿走所有萝卜的最小代价是多少。

## 说明/提示

对于所有测试点 $a_{i,j}\in \{0,1\}$，$1\leq n\leq 5\times 10^6$，保证 $a_{i,1}\neq a_{i,2}$。

**本题使用捆绑测试**  
$\sf subtask \ 1: n\leq10 \ \ \ \ \ \ \ \ \ \ \ 30pts $   
$\sf subtask \ 2: n\leq100 \ \ \ \ \ \ \ \ \ 20 pts$   
$\sf subtask \ 3: n\leq5000 \ \ \ \ \ \ \ 20 pts$   
$\sf subtask \ 4: n\leq5000000 \ 30pts$   



## 样例 #1

### 输入

```
4
0 1
0 1
0 1
0 1```

### 输出

```
2```

## 样例 #2

### 输入

```
6
1 0
1 0
0 1
0 1
1 0
1 0```

### 输出

```
3```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地消除所有萝卜，且最小化操作代价。所有题解都基于题目给出的关键提示：每一行的两列萝卜颜色不同。这一条件使得问题简化为只需考虑一列的萝卜，从而大大降低了复杂度。

大多数题解的思路相似，即通过统计某一列中相邻萝卜颜色不同的次数，然后根据公式 `(cnt + 1) / 2 + 1` 计算最小代价。这种思路的时间复杂度为 O(n)，能够通过所有测试点。

### 所选高星题解

#### 1. 作者：GONGX (5星)
- **关键亮点**：思路清晰，代码简洁且高效。使用了快读优化输入，避免了 `cin` 的超时问题。代码中通过 `a[i] != a[i-1]` 统计相邻萝卜颜色不同的次数，最后通过公式计算最小代价。
- **代码核心**：
  ```cpp
  int n,ans=1;
  bool a[5000005];
  int main(){
      scanf("%d",&n),a[0]=read(),read();
      for(int i=1;i<n;i++)a[i]=read(),read(),ans+=a[i]!=a[i-1];
      printf("%d",1+(ans+1>>1));
      return 0;
  }
  ```

#### 2. 作者：Mo20 (4星)
- **关键亮点**：详细解释了题目中的操作本质，特别是上移操作的作用。通过合并连续的相同萝卜，进一步简化了问题。代码中通过 `ans-=(last==x)` 来统计连通块的数量，最后通过公式计算最小代价。
- **代码核心**：
  ```cpp
  int n;int ans=n;int last=-1;
  for(int i=1,x;i<=n;i++){
      x=read();x=read();
      if(~last) ans-=(last==x);
      last=x;
  }
  cout<<((ans+1)>>1)+1<<endl;
  ```

#### 3. 作者：2023gdgz01 (4星)
- **关键亮点**：明确指出了上移操作的代价上升性，并提出了只使用一次上移操作的最优策略。代码中通过 `ans += (a[i][0] != a[i - 1][0])` 统计相邻萝卜颜色不同的次数，最后通过公式计算最小代价。
- **代码核心**：
  ```cpp
  int n, ans, a[5000005][2];
  int main() {
      scanf("%d", &n);
      a[0][0] = 2;
      for (register int i = 1; i <= n; ++i) {
          scanf("%d%d", &a[i][0], &a[i][1]);
          ans += (a[i][0] != a[i - 1][0]);
      }
      printf("%d", (ans + 1 >> 1) + 1);
      return 0;
  }
  ```

### 最优关键思路与技巧

1. **简化问题**：利用题目中每一行两列萝卜颜色不同的条件，只需考虑一列的萝卜，从而将问题简化为统计相邻萝卜颜色不同的次数。
2. **公式计算**：通过 `(cnt + 1) / 2 + 1` 计算最小代价，其中 `cnt` 是相邻萝卜颜色不同的次数。
3. **输入优化**：使用快读或 `scanf` 优化输入，避免 `cin` 的超时问题。

### 可拓展之处

- **类似问题**：类似的问题可以出现在其他需要统计连通块或相邻元素差异的题目中，如消除类游戏、图像处理中的连通区域统计等。
- **算法套路**：这类问题通常可以通过统计相邻元素的差异来简化问题，然后通过公式或贪心策略计算最优解。

### 推荐题目

1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)

### 个人心得摘录

- **GONGX**：提到使用快读优化输入，避免 `cin` 的超时问题，强调了输入优化的重要性。
- **Mo20**：详细解释了上移操作的本质，帮助理解题目中的操作对结果的影响。
- **2023gdgz01**：明确指出上移操作的代价上升性，提出了只使用一次上移操作的最优策略，强调了策略选择的重要性。

---
处理用时：38.13秒
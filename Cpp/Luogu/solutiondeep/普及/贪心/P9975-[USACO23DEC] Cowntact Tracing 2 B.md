# 题目信息

# [USACO23DEC] Cowntact Tracing 2 B

## 题目描述

Farmer John 有 $N$ 头奶牛排成一列（$1 \leq N \leq 3\cdot 10^5$）。不幸的是，有一种疾病正在传播。

最初，有一些奶牛被感染。每到夜晚，被感染的奶牛会将疾病传播给它左右两边的奶牛（如果这些奶牛存在的话）。一旦奶牛被感染，她就会持续处于感染状态。

经过一些晚上，Farmer John 意识到情况已经失控，因此他对奶牛进行了检测以确定哪些奶牛感染了疾病。请找出最少有多少头奶牛最初可能感染了这种疾病。

## 说明/提示

### 样例解释 1

假设只有中间的奶牛最初被感染。那么，奶牛们将按以下顺序被感染：

- 第 $0$ 晚：$00100$（第三只奶牛一开始被感染）
- 第 $1$ 晚：$01110$（第二和第四只奶牛现在被感染了）
- 第 $2$ 晚：$11111$（第一和第五只奶牛现在被感染了）
- 第 $3$ 晚：$11111$（所有的奶牛都已经被感染了，没有新的奶牛被感染）
- ……

经过两个或更多的晚上，奶牛们的状态即与输入的状态相符。还有许多其他的初始状态和夜晚数量可能导致了输入的状态，例如：

- 第 $0$ 晚：$10001$
- 第 $1$ 晚：$11011$
- 第 $2$ 晚：$11111$

或者：

- 第 $0$ 晚：$01001$
- 第 $1$ 晚：$11111$

或者：

- 第 $0$ 晚：$01000$
- 第 $1$ 晚：$11100$
- 第 $2$ 晚：$11110$
- 第 $3$ 晚：$11111$

所有这些初始状态中至少有一头奶牛被感染。

### 样例解释 2

唯一可能导致这个最终状态的初始状态和夜晚数是：没有经过任何夜晚，输入中的四头感染的奶牛都是从最开始就感染了这种疾病。

### 测试点性质

- 测试点 $3-7$ 满足 $N \le 1000$。
- 测试点 $8-12$ 没有额外限制。

## 样例 #1

### 输入

```
5
11111```

### 输出

```
1```

## 样例 #2

### 输入

```
6
011101```

### 输出

```
4```

# AI分析结果

### 综合分析与结论

本题的核心在于通过贪心策略和分治思想，找出最少初始感染奶牛的数量。各题解的主要思路是通过模拟疾病的传播过程，计算最大可能的传播天数，然后根据天数倒推初始感染奶牛的数量。大多数题解都采用了类似的贪心策略，但在实现细节和代码优化上有所不同。

### 所选高分题解

#### 1. 作者：No_Rest (赞：13)
- **星级**: 5
- **关键亮点**: 
  - 思路清晰，通过计算最大传播天数来倒推初始感染奶牛的数量。
  - 代码简洁，边界处理得当，时间复杂度为O(N)。
  - 通过分段处理连续感染的奶牛，优化了计算过程。
- **个人心得**: 
  - 作者提到“为了让最开始感染的牛尽量少，我们要让传染的天数尽量多”，这一贪心策略是解题的关键。

**核心代码**:
```cpp
for(re ll i = 1; i <= n; ++i){
    if(a[i]){
        last++;
        if(!a[i - 1]) st.push_back(i);
    } else if(!a[i] && last){
        if(st[st.size() - 1] == 1) mn = min(mn, i - 2);
        else mn = min(mn, (last - 1) / 2);
        last = 0, ed.push_back(i - 1);
    }
}
if(last) mn = min(mn, last - 1), ed.push_back(n);
for(re ll i = 0; i < st.size(); ++i) cnt += ceil(1.0 * (ed[i] - st[i] + 1) / (2 * mn + 1));
```
**核心思想**: 通过遍历奶牛状态，记录每一段连续感染的起点和终点，计算最大传播天数，然后根据天数计算初始感染奶牛的数量。

#### 2. 作者：Expert_Dream (赞：9)
- **星级**: 4.5
- **关键亮点**: 
  - 通过贪心策略，最大化传播天数，减少初始感染奶牛的数量。
  - 代码结构清晰，边界处理得当，时间复杂度为O(N)。
  - 通过分段处理连续感染的奶牛，优化了计算过程。
- **个人心得**: 
  - 作者提到“天数越大，奶牛数少”，这一贪心策略是解题的关键。

**核心代码**:
```cpp
for(int i = 1;i <= n;i++){
    if(s[i]=='0'){
        if(res)v.push_back({res,ok});
        ok=0;
        res=0;
    }else if(s[i]=='1'){
        res++;cnt++;
    }
}
if(res) v.push_back({res,1});
```
**核心思想**: 通过遍历奶牛状态，记录每一段连续感染的起点和终点，计算最大传播天数，然后根据天数计算初始感染奶牛的数量。

#### 3. 作者：Adchory (赞：3)
- **星级**: 4
- **关键亮点**: 
  - 通过贪心策略，最大化传播天数，减少初始感染奶牛的数量。
  - 代码简洁，边界处理得当，时间复杂度为O(N)。
  - 通过分段处理连续感染的奶牛，优化了计算过程。
- **个人心得**: 
  - 作者提到“感染的天数越多，最初奶牛感染的数量就越少”，这一贪心策略是解题的关键。

**核心代码**:
```cpp
for(ll i=1;i<=N+1;i++){
    if(S[i]!=S[i-1]&&S[i]=='1') cnt=1;
    if(S[i]==S[i-1]&&S[i]=='1') cnt++;
    if(S[i]!=S[i-1]&&S[i-1]=='1'){
        if(i-cnt==1) res=min(res,cnt-1);
        else if(i==N+1) res=min(res,cnt-1);
        else res=min(res,(cnt-1)/2);
        g.emplace_back(cnt),cnt=0;
    }
}
```
**核心思想**: 通过遍历奶牛状态，记录每一段连续感染的起点和终点，计算最大传播天数，然后根据天数计算初始感染奶牛的数量。

### 最优关键思路或技巧
- **贪心策略**: 通过最大化传播天数，减少初始感染奶牛的数量。
- **分段处理**: 将连续感染的奶牛分段处理，优化计算过程。
- **边界处理**: 特别注意边界情况，确保计算的准确性。

### 可拓展之处
- **类似算法套路**: 类似的问题可以通过贪心策略和分段处理来优化计算过程。
- **同类型题**: 类似的问题可以考察在给定条件下，如何通过贪心策略优化结果。

### 推荐题目
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1052 过河](https://www.luogu.com.cn/problem/P1052)

---
处理用时：41.38秒
# 题目信息

# [NOIP 2009 普及组] 道路游戏

## 题目描述

小新正在玩一个简单的电脑游戏。

游戏中有一条环形马路，马路上有 $n$ 个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这 $n$ 个机器人工厂编号为 $1\sim n$，因为马路是环形的，所以第 $n$ 个机器人工厂和第 $1$ 个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这 $n$ 段马路也编号为 $1\sim n$，并规定第 $i$ 段马路连接第 $i$ 个机器人工厂和第 $i+1$ 个机器人工厂（$1\le i\le n-1$），第 $n$ 段马路连接第 $n$ 个机器人工厂和第 $1$ 个机器人工厂。

游戏过程中，每个单位时间内，每段马路上都会出现一些金币，金币的数量会随着时间发生变化，即不同单位时间内同一段马路上出现的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在 $i$（$1\le i\le n$）号机器人工厂购买了一个机器人，这个机器人会从 $i$ 号机器人工厂开始，顺时针在马路上行走，第一次行走会经过 $i$ 号马路，到达 $i+1$ 号机器人工厂（如果 $i=n$，机器人会到达第 $1$ 个机器人工厂），并将 $i$ 号马路上的所有金币收集给小新。游戏中，环形马路上不能同时存在 $2$ 个或者 $2$ 个以上的机器人，并且每个机器人最多能够在环形马路上行走 $p$ 次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为 $1\sim p$ 之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。

以下是游戏的一些补充说明：

1. 游戏从小新第一次购买机器人开始计时。
2. 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。
3. 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。
4. 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。
5. 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。

现在已知每段马路上每个单位时间内出现的金币数量和在每个机器人工厂购买机器人需要的花费，请你告诉小新，经过 $m$ 个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。


## 说明/提示

对于 $40\%$ 的数据，$2\le n\le 40$，$1\le m\le 40$。

对于 $90\%$ 的数据，$2\le n\le 200$，$1\le m\le 200$。

对于 $100\%$ 的数据，$2\le n\le 1000$，$1\le m\le 1000$，$1\le p\le m$。

NOIP 2009 普及组 第四题


## 样例 #1

### 输入

```
2 3 2 
1 2 3 
2 3 4 
1 2```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心是通过动态规划（DP）来解决环形马路上的金币收集问题。大部分题解采用了DP的思路，但优化程度和实现细节有所不同。部分题解通过单调队列优化，将时间复杂度从O(n^3)降低到O(n^2)，而其他题解则通过简单的状态转移方程实现，虽然时间复杂度较高，但代码更易理解。此外，部分题解还通过BFS或滑动窗口等技巧进行优化。

### 所选高星题解

#### 1. **ButterflyDew (5星)**
- **关键亮点**：通过单调队列优化，将时间复杂度从O(n^3)降低到O(n^2)，并详细解释了如何通过斜线转移和单调队列维护最大值。题解思路清晰，代码实现较为简洁。
- **个人心得**：作者在调试过程中遇到了一些困难，尤其是在处理环形马路和斜线转移时，但最终通过单调队列优化成功解决了问题。
- **核心代码**：
  ```cpp
  int get(int i,int j) {
      return ((j-i)%n+n)%n;
  }
  ```
  **实现思想**：通过单调队列维护每个时间点的最大值，避免了重复计算。

#### 2. **gorokokoro (4星)**
- **关键亮点**：同样使用了单调队列优化，但代码实现更为简洁，且通过滑动窗口的方式维护了每个斜线上的最大值。题解思路清晰，代码可读性高。
- **核心代码**：
  ```cpp
  int Reload(int x, int k) {
      return ((x - k) % n + n) % n;
  }
  ```
  **实现思想**：通过滑动窗口维护每个斜线上的最大值，减少了时间复杂度。

#### 3. **dengyaotriangle (4星)**
- **关键亮点**：通过相对运动的思路，将问题转化为机器人不动，工厂和金币随时间旋转，简化了DP方程。题解思路新颖，代码实现较为简洁。
- **核心代码**：
  ```cpp
  for(int i=1;i<=m;i++) {
      int mx=0xc0c0c0c0;
      for(int j=1;j<=n;j++) {
          int cur=pfx[j][i];
          while(q[j].top().second<i-p) q[j].pop();
          cur+=q[j].top().first;
          mx=max(mx,cur);
      }
      for(int j=1;j<=n;j++) {
          q[j].push(make_pair(mx-pfx[j][i]-c[(j+i-1)%n+1],i));
      }
      ans=max(ans,mx);
  }
  ```
  **实现思想**：通过优先队列维护每个时间点的最大值，简化了DP方程。

### 最优关键思路与技巧

1. **单调队列优化**：通过单调队列维护每个时间点的最大值，避免了重复计算，将时间复杂度从O(n^3)降低到O(n^2)。
2. **相对运动思路**：通过让工厂和金币随时间旋转，简化了DP方程，使得问题更容易处理。
3. **滑动窗口**：通过滑动窗口维护每个斜线上的最大值，减少了时间复杂度。

### 可拓展之处

- **同类型题**：类似的问题可以出现在其他环形结构或滑动窗口相关的题目中，如环形数组的最大子数组和问题。
- **类似算法套路**：单调队列和滑动窗口的技巧可以应用于其他需要维护区间最大值或最小值的题目中。

### 推荐题目

1. **P1886 滑动窗口**：考察滑动窗口的应用，适合练习单调队列的使用。
2. **P1040 加分二叉树**：考察动态规划的应用，适合练习状态转移方程的构建。
3. **P1063 能量项链**：考察环形结构上的动态规划，适合练习环形问题的处理。

### 个人心得总结

- **调试经历**：在处理环形马路和斜线转移时，部分作者遇到了困难，但通过单调队列优化成功解决了问题。
- **踩坑教训**：在处理环形结构时，取模操作需要特别注意，避免出现负数或越界的情况。
- **顿悟感想**：通过相对运动的思路，将问题转化为机器人不动，工厂和金币随时间旋转，简化了DP方程，使得问题更容易处理。

---
处理用时：27.58秒
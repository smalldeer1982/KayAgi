# 题目信息

# 波浪数

## 题目描述

波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。

类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $2\le l\le r\le 32$，$1\le L\le R\le 10^7$，$k\in \{2, 3, 4\}$。

## 样例 #1

### 输入

```
10 11 190000 960000 2```

### 输出

```
191919
383838
575757
767676
959595```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地生成并判断波浪数，尤其是双重、三重、四重波浪数。大多数题解采用了逆向思维，即通过构造波浪数并记录其在不同进制下的波浪次数，最后根据要求输出符合条件的数。这种思路避免了直接判断每个数在不同进制下是否为波浪数的高复杂度问题，显著提升了效率。

### 所选高星题解

#### 1. **作者：Crazily (赞：78)**
- **星级：5星**
- **关键亮点**：逆向思维，通过生成波浪数并记录其在不同进制下的波浪次数，避免了直接判断的高复杂度问题。代码简洁，思路清晰。
- **个人心得**：考场上因进制转换问题感到困惑，考后通过逆向思维解决了问题，强调了思维转换的重要性。
- **核心代码**：
  ```cpp
  for(int k=a;k<=b;++k){
      for(int i=1;i<k;++i){
          for(int j=0;j<k;++j){
              if(i!=j){
                  x=0;
                  t=0;
                  while(x<=r){
                      if(t%2==0) x=x*k+i;
                      else x=x*k+j;
                      ++t;
                      if(x>=l&&x<=r) ++v[x];
                  }
              }
          }
      }
  }
  ```
  **实现思想**：通过三重循环构造波浪数，记录其在指定范围内的波浪次数。

#### 2. **作者：Skywalker_David (赞：5)**
- **星级：4星**
- **关键亮点**：通过计算数字在不同进制下的位数，减少了构造波浪数的次数，进一步优化了算法。
- **核心代码**：
  ```cpp
  int make(int a, int b, int len, int k){
      int x = 0, i;
      for (i = 1; i <= len; i++){
          if (i & 1) x = x*k + a;
          else x = x*k + b;
      }
      return x;
  }
  ```
  **实现思想**：通过计算数字的位数，减少了构造波浪数的次数，提升了效率。

#### 3. **作者：Y_B_Y (赞：4)**
- **星级：4星**
- **关键亮点**：通过枚举波浪数的两个交替数字，构造波浪数并记录其重数，思路清晰且代码简洁。
- **核心代码**：
  ```cpp
  for(int p=j1;p<=j2;p++){
      memset(b,0,sizeof(b));
      for(int i=0;i<=p-1;i++){
          for(int j=0;j<=p-1;j++){
              if(i==j) continue;
              int tot=0;
              for(int l=1;l<=10;l++){
                  if(tot+j*pow(p,2*l-2)<=ed){
                      if(!b[tot+(int)(j*pow(p,2*l-2))]) yes[tot+int(j*pow(p,2*l-2))]++;
                      b[tot+(int)(j*pow(p,2*l-2))]=1;
                  }
                  if(tot+i*pow(p,2*l-1)+j*pow(p,2*l-2)<=ed){
                      tot+=i*pow(p,2*l-1)+j*pow(p,2*l-2);
                      if(!b[tot])yes[tot]++;
                      b[tot]=1;
                  }
                  else break;
              }
          }
      }
  }
  ```
  **实现思想**：通过枚举波浪数的两个交替数字，构造波浪数并记录其重数。

### 最优关键思路与技巧

1. **逆向思维**：通过构造波浪数并记录其在不同进制下的波浪次数，避免了直接判断的高复杂度问题。
2. **位数优化**：通过计算数字在不同进制下的位数，减少了构造波浪数的次数，提升了效率。
3. **交替数字枚举**：通过枚举波浪数的两个交替数字，构造波浪数并记录其重数，思路清晰且代码简洁。

### 可拓展之处

- **类似题目**：可以扩展到其他进制转换或数字构造类题目，如判断回文数、特殊数字序列等。
- **算法优化**：可以进一步优化波浪数的生成过程，减少不必要的计算。

### 推荐题目

1. **P1022 进制转换**：考察进制转换的基本操作。
2. **P1217 回文质数**：结合回文数和质数的判断，适合练习数字构造与判断。
3. **P1045 麦森数**：涉及大数运算与进制转换，适合提升算法复杂度处理能力。

### 个人心得总结

- **思维转换**：在面对复杂问题时，逆向思维往往能带来意想不到的解决方案。
- **调试经验**：在构造波浪数时，注意边界条件的处理，避免数组越界或重复计算。
- **优化意识**：通过计算位数或减少循环次数，可以有效提升算法效率。

---
处理用时：29.55秒
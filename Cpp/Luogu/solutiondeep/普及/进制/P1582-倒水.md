# 题目信息

# 倒水

## 题目描述

一天，CC 买了 $N$ 个容量可以认为是无限大的瓶子，开始时每个瓶子里有 $1$ 升水。接着 CC 发现瓶子实在太多了，于是他决定保留不超过 $K$ 个瓶子。每次他选择两个当前含水量相同的瓶子，把一个瓶子的水全部倒进另一个里，然后把空瓶丢弃。（不能丢弃有水的瓶子）

显然在某些情况下 CC 无法达到目标，比如 $N = 3$、$K = 1$。此时 CC 会重新买一些新的瓶子（新瓶子容量无限，开始时有 $1$ 升水），以达到目标。

现在 CC 想知道，最少需要买多少新瓶子才能达到目标呢？


## 样例 #1

### 输入

```
3 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
13 2```

### 输出

```
3```

## 样例 #3

### 输入

```
1000000 5```

### 输出

```
15808```

# AI分析结果

### 综合分析与结论

该题目要求通过合并瓶子来减少瓶子数量，且每次合并只能合并水量相同的瓶子。题解主要集中在二进制和贪心算法的应用上，通过将问题转化为二进制表示，利用`lowbit`操作和`__builtin_popcount`函数来快速计算瓶子数量的减少。大多数题解的核心思路是通过贪心策略，每次尽可能减少瓶子数量，直到满足要求。

### 所选高星题解

#### 1. 作者：pantw (5星)
**关键亮点**：
- 利用二进制表示瓶子数量，直接使用`__builtin_popcount`函数计算二进制中1的个数，简洁高效。
- 通过`lowbit`操作快速找到最低位的1，并逐步减少瓶子数量，代码简洁且优化程度高。

**核心代码**：
```cpp
#include <cstdio>
int n, k, ans;
int main() {
    scanf("%d%d", &n, &k);
    while(__builtin_popcount(n) > k) ans += n & -n, n += n & -n;
    printf("%d", ans);
}
```
**核心思想**：通过`lowbit`操作逐步减少瓶子数量，直到二进制中1的个数不超过k。

#### 2. 作者：Golden_Winter (4星)
**关键亮点**：
- 详细解释了二进制与瓶子数量的关系，并通过`lowbit`操作实现贪心策略。
- 提供了对`lowbit`操作的详细解释，适合初学者理解。

**核心代码**：
```cpp
#include<cstdio>
using namespace std;
int n,k,ans;
int work(int x){int num=0;for(;x;x-=x&-x) num++;return num;}
int main(){
    scanf("%d%d",&n,&k);
    while(work(n)>k) ans+=n&-n,n+=n&-n;
    printf("%d\n",ans);
    return 0;
}
```
**核心思想**：通过`lowbit`操作逐步减少瓶子数量，直到二进制中1的个数不超过k。

#### 3. 作者：jingyangzhi (4星)
**关键亮点**：
- 使用`bitset`库来统计二进制中1的个数，避免了手动计算，代码简洁。
- 适合对`bitset`库熟悉的读者，提供了另一种实现方式。

**核心代码**：
```cpp
#include<iostream>
#include<bitset>
#define int long long
#define lowbit(x) x&(-x)
using namespace std;
signed main() {
    int n,k;
    cin>>n>>k;
    bitset<50>a(n);
    int ans=0;
    while(a.count()>k) {
        ans+=lowbit(n);
        n+=lowbit(n);
        a=n;
    }
    cout<<ans;
    return ~~ (0 - 0);
}
```
**核心思想**：通过`bitset`库统计二进制中1的个数，并通过`lowbit`操作逐步减少瓶子数量。

### 最优关键思路与技巧
1. **二进制表示**：将瓶子数量转化为二进制，利用二进制中1的个数来表示最少瓶子数量。
2. **贪心策略**：通过`lowbit`操作逐步减少瓶子数量，直到满足要求。
3. **内置函数**：使用`__builtin_popcount`或`bitset`库来快速计算二进制中1的个数。

### 可拓展之处
- **类似算法套路**：二进制表示和贪心策略可以应用于其他需要减少数量或合并相同元素的问题，如合并石子、最小生成树等。
- **数据结构**：`bitset`库在处理二进制问题时非常高效，适合在类似问题中使用。

### 推荐题目
1. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1967 货车运输](https://www.luogu.com.cn/problem/P1967)
3. [P3371 最短路径](https://www.luogu.com.cn/problem/P3371)

### 个人心得摘录
- **调试经历**：多位作者提到通过逐步调试和优化，最终找到高效的解决方案。
- **顿悟感想**：通过将问题转化为二进制表示，大大简化了问题的复杂度，体现了数学思维在算法中的重要性。

### 通用建议与扩展思路
- **理解二进制与贪心的结合**：在处理类似问题时，考虑是否可以通过二进制表示来简化问题。
- **掌握内置函数**：熟悉`__builtin_popcount`和`bitset`等内置函数，可以大幅提高代码效率和可读性。
- **多练习类似题目**：通过多练习二进制和贪心相关的题目，加深对这类问题的理解和应用能力。

---
处理用时：29.44秒
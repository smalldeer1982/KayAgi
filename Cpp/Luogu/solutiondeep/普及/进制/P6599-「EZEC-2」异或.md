# 题目信息

# 「EZEC-2」异或

## 题目描述

有 $T$ 组询问，每次给定两个正整数 $n,l$，   

你需要构造一个长度为 $l$ 的正整数序列 $a$（编号从 $1$ 至 $l$），   

且满足 $\forall i\in[1,l]$，都有 $a_i\in[1,n]$。

求：

$$\sum_{i=1}^l\sum_{j=1}^{i-1}a_i\oplus a_j$$

的最大值。

为了避免答案过大，对于每组询问，只需要输出这个最大值对 $10^9+7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**   
当 $n=2,l=3$，$a$ 取 $\{1,2,1\}$ 的任一排列时可以得到最大值，为 $(1\oplus2)+(1\oplus1)+(2\oplus1)=6$，易证明此时原式有最大值。

---
**【数据规模与约定】**
| 测试点编号 | $T\le$ | $n\le$ | $l\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim5$ | $1$ | $10$ | $5$ |
| $6$ | $5\times 10^5$ | $10^{12}$ | $2$ |
| $7$ | $5\times 10^5$ | $10^{12}$ | $3$ |
| $8\sim10$ | $5\times 10^5$ | $10^{12}$ | $10^5$ |

对于 $100\%$ 的数据，满足 $1\le T\le 5\times10^5$，$1\le n\le 10^{12}$，$2\le l \le 10^5$。


---
**【提示】**

1. 「$\oplus$」是按位异或符号。如果您不知道什么是按位异或，可以参考[这里](https://oi-wiki.org/math/bit/#_1)。
2. 取模是一种运算，$a$ 对 $b$ 取模代表将 $a$ 赋值为 $a$ 除以 $b$ 所得到的余数。  
在 C++ / Python 中的取模符号为 `%`，在 Pascal 中的取模符号为 `mod`。
3. $\sum$ 是求和符号。如果您不知道什么是 $\sum$ 符号，可以参考[这里](https://baike.baidu.com/item/∑/1233796?fr=aladdin)。
4. 请注意数据的读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
1
2 3
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
114 514
1919 180
```

### 输出

```
8388223
16580700```

# AI分析结果

### 综合分析与结论

本题的核心在于如何通过构造序列最大化异或和。大多数题解都采用了按位分析的思路，通过将问题分解为每个二进制位的贡献，最终通过贪心策略构造序列。具体来说，每个二进制位的贡献可以通过最大化 $x \times (l - x)$ 来实现，其中 $x$ 是该位为1的数的个数。最优的 $x$ 通常是 $\lfloor \frac{l}{2} \rfloor$ 或 $\lceil \frac{l}{2} \rceil$。

### 所选高质量题解

#### 1. **作者：李白莘莘学子 (5星)**
   - **关键亮点**：思路清晰，详细解释了按位分析的思路，并通过二次函数求极值的方法证明了最优解。代码实现简洁，且包含了特判处理。
   - **个人心得**：作者通过二次函数求极值的方法，直观地解释了为什么 $x = \lfloor \frac{l}{2} \rfloor$ 时 $x \times (l - x)$ 最大，这种数学推导使得题解更加严谨。
   - **核心代码**：
     ```cpp
     long long big=1ll<<40;
     while(big)
     {
         big>>=1;
         if(n<big)continue;
         ans+=big*mid*(l-mid);
         ans%=modd;
     }
     ```
     **实现思想**：从最高位开始，逐位计算贡献，并累加到答案中。

#### 2. **作者：一只书虫仔 (5星)**
   - **关键亮点**：题解结构清晰，详细推导了每个二进制位的贡献，并给出了最终的公式。代码实现简洁且高效。
   - **核心代码**：
     ```cpp
     long long ans = (((l / 2) * (l - (l / 2))) % Mod) * (((1ll << (n + 1)) - 1));
     printf("%lld\n", ans % Mod);
     ```
     **实现思想**：直接通过公式计算答案，避免了逐位计算的复杂度。

#### 3. **作者：do_while_true (4星)**
   - **关键亮点**：题解详细解释了按位分析的思路，并通过反证法证明了最优解。代码实现简洁，且包含了特判处理。
   - **核心代码**：
     ```cpp
     long long now=1LL<<40,res=0;
     while(now)
     {
         now>>=1;
         if(x<now) continue;
         res+=now*t*(y-t);
     }
     ```
     **实现思想**：从最高位开始，逐位计算贡献，并累加到答案中。

### 最优关键思路与技巧

1. **按位分析**：将问题分解为每个二进制位的贡献，通过最大化每个位的贡献来构造序列。
2. **贪心策略**：通过最大化 $x \times (l - x)$ 来确保每个二进制位的贡献最大，最优的 $x$ 通常是 $\lfloor \frac{l}{2} \rfloor$ 或 $\lceil \frac{l}{2} \rceil$。
3. **特判处理**：对于 $n=1$ 的情况，直接输出0，避免不必要的计算。

### 可拓展之处

1. **类似问题**：可以扩展到其他位运算问题，如与、或等，同样可以采用按位分析的思路。
2. **构造序列**：在其他需要构造序列最大化某种指标的问题中，可以考虑类似的贪心策略。

### 推荐题目

1. **P2114 [NOI2014] 起床困难综合症**：考察位运算与贪心策略的结合。
2. **P6102 [EER2] 选择客栈**：考察位运算与序列构造的结合。
3. **P3811 【模板】乘法逆元**：考察位运算与数学推导的结合。

### 个人心得总结

- **调试经历**：多位作者提到在构造序列时，特判 $n=1$ 的情况非常重要，否则会导致错误。
- **顿悟感想**：通过按位分析和贪心策略，可以将复杂的问题简化为每个二进制位的贡献计算，这种思路在解决位运算问题时非常有效。

---
处理用时：26.65秒
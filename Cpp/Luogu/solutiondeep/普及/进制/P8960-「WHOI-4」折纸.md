# 题目信息

# 「WHOI-4」折纸

## 题目背景

吉尼斯记录：一张纸（如果接近 $4$ 公里的卫生纸可以算作一张纸）最多可以对折 $13$ 次。小 X 吹牛说打破了这个记录，但是吹太大了。

## 题目描述

小 X 向吉尼斯世界纪录组织申请了这个记录，但是他正好隔离在家，无法证明。他只好允许他们问 $t$ 个问题，确认他确实打破了记录。

他们每个问题可以要求小 X 把一张纸按照一个给定 $01$ 串 $s$ 的规则对折 $n$ 次后展开。对于第 $i$ 次折叠，如果 $s_i=0$，将纸从左到右对折，使左边对齐右边；如果 $s_i=1$，将纸从右到左对折，使右边对齐左边。对折全部是从上方翻。**接下来将会展开，展开后纸片在原位，只是保留了折痕。看看自己是否实现了这一点。**

他们想要知道，从左往右数第 $k$ 个折痕是峰折（向上突起的折痕）还是谷折（向下凹陷的折痕）。如果该询问的答案是峰折，输出 `Up`；否则输出 `Down`。请你帮帮可怜的小 X。

峰折，谷折的图示见样例解释。

## 说明/提示

**样例解释**

样例 #1 解释：

动态地址：[here](https://img-blog.csdnimg.cn/c68f2ba917504417b109eb1606f4a3a5.gif)。不知道为什么洛谷显示不了了。

![](https://cdn.luogu.com.cn/upload/image_hosting/wguzrqz6.png)

由于技术原因，动图帧数略低。

样例 #2 请手动模拟。

**数据范围**

**本题采用捆绑测试。**

- Subtask 1（$20$ pts）：$t=10$，$1\le n\le5$；
- Subtask 2（$80$ pts）：$t=10^5$。

对于 $100\%$ 的数据，有 $1\le t\le 10^5$，$1\le n\le60$，$1\le k<2^n$。

## 样例 #1

### 输入

```
7
3 1
010
3 2
010
3 3
010
3 4
010
3 5
010
3 6
010
3 7
010```

### 输出

```
Down
Up
Up
Down
Down
Down
Up```

## 样例 #2

### 输入

```
7
3 1
011
3 2
011
3 3
011
3 4
011
3 5
011
3 6
011
3 7
011```

### 输出

```
Down
Up
Up
Down
Down
Down
Up
```

## 样例 #3

### 输入

```
2
13 114
1101101111010
13 514
1101101111010```

### 输出

```
Up
Up```

# AI分析结果

### 综合分析与结论

本题的核心在于通过模拟折纸过程，确定第 \(k\) 个折痕的类型（峰折或谷折）。由于 \(n\) 的最大值为 60，直接模拟折纸过程不可行，因此需要找到规律或通过数学推导来优化计算。大多数题解通过观察折痕的生成规律，结合二分法或递归来解决问题。其中，**JuRuoOIer** 和 **escapist404** 的题解思路清晰，代码实现简洁且优化程度较高，值得推荐。

### 所选题解

#### 1. **JuRuoOIer** (5星)
- **关键亮点**：通过二进制分析折痕的生成规律，结合二分法快速定位折痕的类型。代码实现简洁，时间复杂度为 \(O(\log n)\)，适合大规模数据。
- **个人心得**：通过折纸实验发现折痕的生成规律，并将其转化为二进制问题，极大简化了计算过程。
- **核心代码**：
  ```cpp
  ll f(ll x) {
      for(ll i=61;i>=0;i--) {
          if(x>=(1ll<<i)) x-=(1ll<<i);
          if(x==0) return i;
      }
  }
  ll g(ll x,ll fx) {
      ll tmp=0;
      for(ll i=61;i>=0;i--) {
          if(x>=(1ll<<i)) {
              x-=(1ll<<i);
              tmp+=(1ll<<(i-fx));
          }
      }
      return (tmp/2+1)%2;
  }
  ```
  **核心思想**：通过二进制位运算快速确定折痕的生成次数和位置，结合 \(s\) 串判断折痕类型。

#### 2. **escapist404** (5星)
- **关键亮点**：通过二分法模拟折纸过程，结合纸面朝向的变化规律，快速确定折痕类型。代码逻辑清晰，优化程度高。
- **个人心得**：通过模拟折纸过程，发现折痕类型与纸面朝向的关系，并通过异或运算简化了代码逻辑。
- **核心代码**：
  ```cpp
  for(int i = 0; i < n; i++) {
      mid = (l + r) >> 1;
      if(k == mid) {
          if(f) cout << "Up" << endl;
          else cout << "Down" << endl;
          break;
      }
      if(f ^ (k < mid) ^ (s[i] == '1')) f ^= 1;
      if(k > mid) l = mid;
      else r = mid;
  }
  ```
  **核心思想**：通过二分法模拟折纸过程，结合纸面朝向的变化规律，快速确定折痕类型。

### 最优关键思路与技巧

1. **二进制与二分法结合**：通过二进制位运算或二分法快速定位折痕的生成位置，避免直接模拟折纸过程。
2. **纸面朝向与折痕类型的关系**：通过纸面朝向的变化规律，结合 \(s\) 串判断折痕类型，简化了计算过程。
3. **异或运算简化逻辑**：通过异或运算简化纸面朝向变化的判断逻辑，使代码更加简洁。

### 可拓展之处

1. **类似问题**：可以扩展到其他需要通过模拟过程但无法直接模拟的问题，如树的遍历、图的生成等。
2. **二进制与位运算**：在处理大规模数据时，二进制与位运算可以极大提高计算效率，适用于类似问题。

### 推荐题目

1. **P1048 采药**（动态规划与二进制优化）
2. **P1090 合并果子**（贪心与优先队列）
3. **P1880 石子合并**（区间DP与优化）

### 个人心得总结

- **调试经历**：通过折纸实验发现规律，并将其转化为数学问题，极大简化了计算过程。
- **顿悟感想**：在处理大规模数据时，找到规律并通过数学推导优化计算是关键。

---
处理用时：24.86秒
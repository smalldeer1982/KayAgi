# 题目信息

# [SNCPC2019] Coolbits

## 题目描述

给定 $n$ 个区间 $[l_1, r_1], [l_2, r_2], \dots, [l_n, r_n]$，需要从每个区间中选择一个整数并计算它们的按位与值 $b$。能够得到的最大 $b$ 是多少？

## 样例 #1

### 输入

```
2
3
0 8
2 6
3 9
1
1 100
```

### 输出

```
6
100
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过贪心算法从高位到低位逐位确定最大按位与值。所有题解均采用了类似的思路：从最高位开始，逐位检查是否可以在所有区间中选择一个数使得该位为1，若可以则将该位置1，并缩小区间范围。这种贪心策略的有效性基于高位为1的贡献远大于低位为1的贡献。

### 所选高星题解

#### 1. 作者：Flaw_Owl (★★★★☆)
**关键亮点：**
- 思路清晰，详细解释了贪心策略的原理。
- 代码结构简洁，易于理解。
- 提供了详细的位运算实现，特别是`cal`函数的实现，确保了区间的正确缩小。

**核心代码：**
```cpp
int cal(int x, int i) {
    if (!((x >> i) & 1))
        x = ((x >> i) | 1) << i;
    return x;
}
```
**实现思想：**
`cal`函数用于计算每个区间的左端点，如果该位不为1，则将其置1并将低位清零，确保该位为1且不超出右端点。

#### 2. 作者：Shunpower (★★★★☆)
**关键亮点：**
- 代码简洁，逻辑清晰。
- 使用了`upperbound`函数来确保每个区间的左端点满足当前位的条件。
- 从高位到低位的枚举顺序确保了最大值的优先选择。

**核心代码：**
```cpp
int upperbound(int x, int i) {
    if (!((x >> i) & 1)) {
        x = ((x >> i) | 1) << i;
    }
    return x;
}
```
**实现思想：**
`upperbound`函数与`cal`函数类似，用于确保每个区间的左端点满足当前位为1的条件。

#### 3. 作者：sieve (★★★★☆)
**关键亮点：**
- 代码简洁，逻辑清晰。
- 使用了`bit`函数来确保每个区间的左端点满足当前位的条件。
- 从高位到低位的枚举顺序确保了最大值的优先选择。

**核心代码：**
```cpp
int bit(int x, int i) {
    if (((x >> i) & 1) == 0) {
        x = (x >> i) | 1;
        x <<= i;
    }
    return x;
}
```
**实现思想：**
`bit`函数与`cal`函数类似，用于确保每个区间的左端点满足当前位为1的条件。

### 最优关键思路或技巧
- **贪心策略**：从高位到低位逐位确定最大按位与值，确保高位的优先选择。
- **位运算优化**：通过位运算快速计算满足条件的区间左端点，确保代码高效。

### 可拓展之处
- **类似问题**：可以考虑其他位运算相关的贪心问题，如按位或、按位异或等。
- **算法套路**：贪心算法结合位运算的优化策略可以应用于多种问题，如最大子序列和、最小覆盖问题等。

### 推荐相似题目
1. [P9612 [CERC2019] Light Emitting Hindenburg](https://www.luogu.com.cn/problem/P9612)
2. [P1004 [NOIP2000 提高组] 方格取数](https://www.luogu.com.cn/problem/P1004)
3. [P1040 [NOIP2003 提高组] 加分二叉树](https://www.luogu.com.cn/problem/P1040)

### 个人心得总结
- **调试经历**：多位作者提到在实现位运算时需要注意优先级问题，建议多加括号以避免错误。
- **顿悟感想**：通过逐位贪心策略，可以有效地解决复杂的位运算问题，关键在于理解高位的优先性。

---
处理用时：24.89秒
# 题目信息

# [GESP202306 四级] 图像压缩

## 题目描述

图像是由很多的像素点组成的。如果用 $0$ 表示黑，$255$ 表示白，$0$ 和 $255$ 之间的值代表不同程度的灰色，则可以用一个字节表达一个像素（取值范围为十进制 `0-255`、十六进制 `00-FF`）。这样的像素组成的图像，称为 $256$ 级灰阶的灰度图像。

现在希望将 $256$ 级灰阶的灰度图像压缩为 $16$ 级灰阶，即每个像素的取值范围为十进制 `0-15`、十六进制 `0-F`。压缩规则为：统计出每种灰阶的数量，取数量最多的前 $16$ 种灰阶（如某种灰阶的数量与另外一种灰阶的数量相同，则以灰阶值从小到大为序），分别编号 `0-F`（最多的编号为 `0`，以此类推）。其他灰阶转换到最近的 $16$ 种灰阶之一，将某个点的灰阶值（灰度，而非次数）与 $16$ 种灰阶中的一种相减，绝对值最小即为最近，如果绝对值相等，则编号较小的灰阶更近。

## 说明/提示

【样例 $1$ 解释】

灰阶 `AB`、`CF` 和 `FF` 出现 $14$ 次，`00` 出现 $10$ 次，`CB` 出现
$9$ 次，`09` 出现 $7$ 次，`AC` 出现 $6$ 次，`07` 出现 $5$ 次，`10`、`11`
和 `98` 出现 $4$ 次，`01`、`1B`、`67`、`76` 和 `FC` 出现 $3$ 次。

## 样例 #1

### 输入

```
10
00FFCFAB00FFAC09071B5CCFAB76
00AFCBAB11FFAB09981D34CFAF56
01BFCEAB00FFAC0907F25FCFBA65
10FBCBAB11FFAB09981DF4CFCA67
00FFCBFB00FFAC0907A25CCFFC76
00FFCBAB1CFFCB09FC1AC4CFCF67
01FCCBAB00FFAC0F071A54CFBA65
10EFCBAB11FFAB09981B34CFCF67
01FFCBAB00FFAC0F071054CFAC76
1000CBAB11FFAB0A981B84CFCF66```

### 输出

```
ABCFFF00CB09AC07101198011B6776FC
321032657CD10E
36409205ACC16D
B41032657FD16D
8F409205ACF14D
324F326570D1FE
3240C245FC411D
BF4032687CD16D
8F409205ACC11D
B240326878D16E
83409205ACE11D```

# AI分析结果

### 综合分析与结论

本题解的核心任务是实现图像灰度的压缩，即将256级灰阶压缩为16级灰阶。大多数题解采用了相似的思路：首先统计每个灰阶的出现次数，然后根据出现次数排序，选取前16个灰阶作为压缩后的灰阶，最后将其他灰阶映射到最近的16个灰阶之一。题解的主要区别在于数据结构的选用、代码的可读性以及优化程度。

### 所选高星题解

#### 1. **作者：ZsH68122zSh (赞：17)**  
**星级：5星**  
**关键亮点：**
- 使用结构体 `grey` 记录灰阶的十六进制值和出现次数，代码结构清晰。
- 利用 `map` 进行灰阶的标记和映射，简化了查找和映射的过程。
- 代码逻辑清晰，注释详细，易于理解。

**核心代码：**
```cpp
struct grey {
    pair<char, char> cl; 
    int cnt;
} gr[256];

map<pair<char, char>, bool> bct; // 标记前16个灰阶
map<pair<char, char>, pair<char, int>> mp; // 灰阶的十六进制编号和十进制灰度值

void InitGrey() {
    for (int i = 0; i < 256; i++) gr[i].cnt = 0; 
}

int st_t(pair<char, char> st) { // 十六进制转十进制
    int s1 = st.first >= '0' && st.first <= '9' ? st.first - '0' : st.first - 'A' + 10; 
    int g1 = st.second >= '0' && st.second <= '9' ? st.second - '0' : st.second - 'A' + 10; 
    return s1 * 16 + g1; 
}

bool cmp(grey cmp1, grey cmp2) { // 排序规则
    return cmp1.cnt == cmp2.cnt ? st_t(cmp1.cl) < st_t(cmp2.cl) : cmp1.cnt > cmp2.cnt;
}
```

#### 2. **作者：WMWD (赞：8)**  
**星级：4星**  
**关键亮点：**
- 使用结构体 `sz` 存储灰阶的出现次数和十六进制值，代码简洁。
- 通过 `sort` 排序后直接输出前16个灰阶，逻辑清晰。
- 代码风格较为简洁，但部分细节处理不够完善。

**核心代码：**
```cpp
struct sz {
    int t, z;
    string s;
    char xx;
} p[10000];

bool cmp(sz a, sz b) {
    if (a.t != b.t) return a.t > b.t;
    else return a.z < b.z;
}
```

#### 3. **作者：fulichang (赞：8)**  
**星级：4星**  
**关键亮点：**
- 使用结构体 `node` 记录灰阶的出现次数和灰度值，代码结构清晰。
- 通过 `sort` 排序后直接输出前16个灰阶，逻辑简洁。
- 代码风格较为简洁，但部分细节处理不够完善。

**核心代码：**
```cpp
struct node {
    int tot, g;
    friend bool operator < (node a, node b) {
        return a.tot != b.tot ? a.tot > b.tot : a.g < b.g;
    }
};
```

### 最优关键思路与技巧

1. **数据结构选择**：使用结构体记录灰阶的十六进制值和出现次数，便于排序和查找。
2. **排序规则**：根据灰阶的出现次数和灰度值进行排序，确保前16个灰阶的正确性。
3. **映射与查找**：通过 `map` 或数组记录灰阶的映射关系，简化查找和映射的过程。

### 可拓展之处

- **类似题目**：可以拓展到其他类型的压缩问题，如颜色压缩、音频压缩等。
- **优化思路**：可以考虑使用更高效的数据结构（如优先队列）来优化排序和查找过程。

### 推荐题目

1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003) - 考察模拟和排序。
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047) - 考察模拟和区间处理。
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056) - 考察排序和贪心算法。

### 个人心得总结

- **调试经历**：多位作者提到在处理字符串长度和灰阶映射时容易出错，建议在编写代码时特别注意这些细节。
- **顿悟感想**：通过本题解，可以更好地理解如何将复杂问题分解为多个简单步骤，并通过合适的数据结构和算法进行优化。

---
处理用时：27.46秒
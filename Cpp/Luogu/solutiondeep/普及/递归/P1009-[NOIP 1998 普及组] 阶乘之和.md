# 题目信息

# [NOIP 1998 普及组] 阶乘之和

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题

## 样例 #1

### 输入

```
3
```

### 输出

```
9```

# AI分析结果

### 综合分析与结论

本题要求计算阶乘之和，由于阶乘增长极快，普通整数类型无法存储，因此必须使用高精度算法。题解中主要涉及高精度乘法和高精度加法的实现，部分题解还引入了重载运算符、记忆化搜索等优化手段。整体来看，题解的质量参差不齐，部分题解代码冗长且不易理解，而少数题解则通过清晰的思路和简洁的代码实现了高效的计算。

### 所选高星题解

#### 1. 题解作者：C_Z_C (4星)
**关键亮点**：  
- 使用高精度乘法和加法模板，代码结构清晰，逻辑简单。
- 通过数组存储大数，逐位计算并处理进位，适合初学者理解高精度的基本实现。

**核心代码片段**：
```cpp
for(int i=1;i<=n;i++){ //计算i的阶乘
    len_a=0; //i的长度
    int p=i;
    while(p>0){ //把i存进a数组
        a[len_a++]=p%10;
        p/=10;
    }
    for(int j=0;j<len_a;j++) //计算a*b（i*（i-1）的阶乘）
        for(int k=0;k<=len_b;k++)
            c[j+k]+=a[j]*b[k];
    for(int j=0;j<len_c;j++) //处理进位
        if(c[j]>9) c[j+1]+=c[j]/10,c[j]%=10;
    if(c[len_c]) len_c++; //看最高位要不要进位
    for(int k=len_c-1;k>=0;k--) b[k]=c[k]; //存进i的阶乘
    memset(c,0,sizeof(c)); //清零c数组
}
```
**个人心得**：  
作者提到“昨天用了半天才写完了这篇橙题代码”，表明高精度实现需要耐心调试，尤其是进位处理部分容易出错。

#### 2. 题解作者：wuhao1027 (4星)
**关键亮点**：  
- 代码简洁，风格良好，适合新手学习。
- 通过数组存储大数，逐位计算并处理进位，逻辑清晰。

**核心代码片段**：
```cpp
for (i=2;i<=n;i++){
    for (j=0;j<100;j++) B[j]*=i; //计算阶乘
    for (j=0;j<100;j++) //处理进位
        if (B[j]>9){
            B[j+1] += B[j]/10;
            B[j]%=10;
        }
    for (j=0;j<100;j++){ //高精加
        A[j]+=B[j];
        if (A[j]>9) {
            A[j+1] += A[j]/10;
            A[j]%=10;
        }
    }
}
```
**个人心得**：  
作者强调“注意代码风格，注意代码风格！”，提醒新手养成良好的代码习惯。

#### 3. 题解作者：Nortrom (4星)
**关键亮点**：  
- 将高精度乘法和加法封装为函数，代码模块化，易于理解和复用。
- 通过递推计算阶乘，减少了重复计算。

**核心代码片段**：
```cpp
void change(int x){ //高精求积
    int g=0;
    for(int i=100;i>=0;i--){
        a[i]=a[i]*x+g;
        g=a[i]/10;
        a[i]=a[i]%10;
    }
}
void qh(){ //高精求和
    int g=0;
    for(int i=100;i>=0;i--){
        s[i]=s[i]+a[i]+g;
        g=s[i]/10;
        s[i]=s[i]%10;
    }
}
```
**个人心得**：  
作者提到“每次处理都基于上一次的操作，大大缩短了用时”，强调了递推计算的效率优势。

### 最优关键思路与技巧

1. **高精度乘法和加法的实现**：通过数组逐位计算并处理进位，是解决大数问题的核心。
2. **递推计算阶乘**：利用前一次的计算结果，减少重复计算，提升效率。
3. **代码模块化**：将高精度乘法和加法封装为函数，便于复用和调试。

### 可拓展之处

- **重载运算符**：可以通过重载运算符简化高精度运算的代码，提升可读性。
- **记忆化搜索**：在计算阶乘时，可以引入记忆化搜索，避免重复计算。

### 推荐相似题目

1. **P1009 阶乘之和**：本题的进阶版，考察高精度乘法和加法的综合应用。
2. **P1045 大整数乘法**：专注于高精度乘法的实现。
3. **P1046 大整数加法**：专注于高精度加法的实现。

### 个人心得总结

- **调试耐心**：高精度实现需要耐心调试，尤其是进位处理部分容易出错。
- **代码风格**：良好的代码风格和模块化设计有助于提升代码的可读性和可维护性。
- **递推优化**：利用递推计算可以减少重复计算，提升算法效率。

---
处理用时：37.86秒
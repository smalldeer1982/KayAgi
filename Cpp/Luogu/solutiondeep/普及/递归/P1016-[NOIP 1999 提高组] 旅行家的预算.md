# 题目信息

# [NOIP 1999 提高组] 旅行家的预算

## 题目描述

一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离 $D_1$、汽车油箱的容量 $C$（以升为单位）、每升汽油能行驶的距离 $D_2$、出发点每升汽油价格$P$和沿途油站数 $N$（$N$ 可以为零），油站 $i$ 离出发点的距离 $D_i$、每升汽油价格 $P_i$（$i=1,2,…,N$）。计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出 `No Solution`。


## 说明/提示

$N \le 6$，其余数字 $ \le 500$。

NOIP1999 普及组第三题、提高组第三题

## 样例 #1

### 输入

```
275.6 11.9 27.4 2.8 2
102.0 2.9
220.0 2.2
```

### 输出

```
26.95
```

# AI分析结果

### 综合分析与结论

本题的核心是贪心算法，通过模拟旅行家在加油站之间的行驶过程，选择最优的加油策略以最小化费用。大多数题解采用了类似的贪心思路，即每次在当前加油站选择下一个最便宜的加油站，并根据油价决定加油量。部分题解还引入了单调队列、优先队列等数据结构来优化选择过程。

虽然题解思路相似，但实现细节和代码质量差异较大。部分题解代码冗长且不易读，而少数题解通过简洁的代码和清晰的思路脱颖而出。以下是对部分题解的评价与总结。

### 精选题解

#### 1. 作者：Twilight_ (赞：2097)
- **星级**: 5星
- **关键亮点**: 
  - 思路清晰，分情况讨论加油策略。
  - 代码简洁，逻辑明确，易于理解。
  - 通过模拟和贪心策略，逐步计算最小费用。
- **个人心得**: 
  - 作者提到“时隔一年之后偶然翻到，竟然有137个赞QAQ！感谢大家，但由于之前的写法上有一些不足（太丑啦！），现在贴一份新的代码上来。” 体现了作者对代码质量的不断追求。

**核心代码**:
```cpp
int move(int now) {
    int can = 99999;
    for (int i = now + 1; i <= n && pl[i].dis - pl[now].dis <= maxx; i++) {
        if (pl[i].co < pl[now].co) {
            mo += ((pl[i].dis - pl[now].dis - temlen) / d2) * pl[now].co;
            temlen = 0;
            return i;
        }
        if (can == 99999 || pl[i].co < pl[can].co) can = i;
    }
    if (d1 - pl[now].dis <= maxx) {
        mo += ((d1 - pl[now].dis - temlen) / d2) * pl[now].co;
        return 9999;
    }
    if (can == 99999) {
        cout << "No Solution";
        return -1;
    } else {
        mo += c * pl[now].co;
        temlen += (maxx - (pl[can].dis - pl[now].dis));
        return can;
    }
}
```
**核心思想**: 通过`move`函数模拟旅行家的行驶过程，根据油价和距离决定加油策略，逐步计算最小费用。

#### 2. 作者：dingcx (赞：409)
- **星级**: 4星
- **关键亮点**: 
  - 采用“退油”策略，每次到达加油站时退掉贵的油，换成便宜的油。
  - 代码结构清晰，逻辑严密。
- **个人心得**: 
  - 作者提到“其实我打完代码都不知道自己在写什么，感觉自己的思路很奇怪的，就来发一篇题解”，体现了作者在解题过程中的探索与反思。

**核心代码**:
```cpp
for (int i = 1; i <= n; i++) {
    double lll = (d[i] - d[i - 1]) / dis;
    bool flag = 1;
    while (len) {
        if (l[0].sum < lll) {
            len--; lll -= l[0].sum;
            for (int k = 0; k < len; k++) {
                l[k].price = l[k + 1].price;
                l[k].sum = l[k + 1].sum;
            }
        } else {
            l[0].sum -= lll;
            flag = 0;
            break;
        }
    }
    if (flag) {
        printf("No Solution");
        return 0;
    }
    // 退油和加油逻辑
}
```
**核心思想**: 通过“退油”策略，每次到达加油站时退掉贵的油，换成便宜的油，确保每次加油都是最优选择。

#### 3. 作者：hongzy (赞：215)
- **星级**: 4星
- **关键亮点**: 
  - 使用单调队列优化选择过程，确保每次消耗的油都是最便宜的。
  - 代码简洁，逻辑清晰。
- **个人心得**: 
  - 作者提到“单调队列的插入方式：back比当前P[i]大 就pop 直到back <= P[i] 再插入”，体现了对数据结构的灵活运用。

**核心代码**:
```cpp
while (!p.empty() && p.back().cost > P[i]) {
    ans -= p.back().cost * p.back().x;
    nc -= p.back().x;
    p.pop_back();
}
ans += (c - nc) * P[i];
p.push_back(OIL(P[i], c - nc));
nc = c;
```
**核心思想**: 使用单调队列维护油箱中的油，确保每次消耗的油都是最便宜的，从而最小化费用。

### 最优关键思路与技巧

1. **贪心策略**: 每次在当前加油站选择下一个最便宜的加油站，并根据油价决定加油量。
2. **数据结构优化**: 使用单调队列或优先队列来优化选择过程，确保每次消耗的油都是最便宜的。
3. **模拟过程**: 通过模拟旅行家的行驶过程，逐步计算最小费用，确保每一步都是最优选择。

### 拓展思路

- **类似题目**: 本题的贪心策略可以应用于其他类似的优化问题，如最短路径、资源分配等。
- **数据结构**: 单调队列和优先队列在优化选择过程中起到了关键作用，可以推广到其他需要动态维护最优解的问题中。

### 推荐题目

1. **P1090 合并果子** - 考察贪心算法和优先队列的应用。
2. **P1223 排队接水** - 贪心算法的经典应用，优化等待时间。
3. **P1801 黑匣子** - 使用优先队列维护动态数据的中位数。

### 总结

通过贪心算法和数据结构优化，本题可以高效地求解最小费用。代码的简洁性和逻辑的清晰性是高质量题解的关键。

---
处理用时：40.48秒
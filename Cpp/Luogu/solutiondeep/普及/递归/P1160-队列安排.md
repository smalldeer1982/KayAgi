# 题目信息

# 队列安排

## 题目描述

一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：

1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；

2. $2\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；

3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。

在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。

## 说明/提示

**【样例解释】**

将同学 $2$ 插入至同学 $1$ 左边，此时队列为：

`2 1`

将同学 $3$ 插入至同学 $2$ 右边，此时队列为：

`2 3 1`  

将同学 $4$ 插入至同学 $1$ 左边，此时队列为：

`2 3 4 1`  

将同学 $3$ 从队列中移出，此时队列为：

`2 4 1`  

同学 $3$ 已经不在队列中，忽略最后一条指令

最终队列：

`2 4 1`  

**【数据范围】**

对于 $20\%$ 的数据，$1\leq N\leq 10$。

对于 $40\%$ 的数据，$1\leq N\leq 1000$。

对于 $100\%$ 的数据，$1<M\leq N\leq 10^5$。


## 样例 #1

### 输入

```
4
1 0
2 1
1 0
2
3
3```

### 输出

```
2 4 1```

# AI分析结果

### 综合分析与结论

本题的核心是模拟队列的插入和删除操作，要求高效处理大量数据（N ≤ 10^5）。大多数题解采用了**双向链表**或**数组模拟链表**的思路，通过维护每个节点的左右指针来实现快速插入和删除。部分题解还引入了**标记数组**来记录删除状态，避免重复删除。整体来看，题解的质量参差不齐，部分题解代码冗长、可读性较差，但也有一些思路清晰、代码简洁的优秀题解。

### 评分较高的题解

#### 1. **作者：BT狸——Frozen (赞：508)**
- **星级：5星**
- **关键亮点**：
  - 使用结构体维护双向链表，思路清晰，代码简洁。
  - 通过标记数组记录删除状态，避免重复删除。
  - 详细解释了插入和删除操作的步骤，适合初学者理解。
- **个人心得**：
  - 作者提到“妄想偷懒不行，只能好好分析一下题”，强调了理解问题本质的重要性。
  
**核心代码：**
```cpp
struct T{
    int l,r;        //每个同学的“左右手” 
    int d;          //表示同学是否输出 
}t[mx]={0};

void add(int i,int k,int f) { //新增同学 
    if(f==1) { //右 
        t[k].r=t[i].r;
        t[k].l=i; 
        t[i].r=k;
        t[t[k].r].l=k;
    } else { //左
        t[k].r=i;
        t[k].l=t[i].l;
        t[i].l=k;
        t[t[k].l].r=k;
    }
}
```

#### 2. **作者：Orina_zju (赞：259)**
- **星级：4.5星**
- **关键亮点**：
  - 使用C++ STL中的`std::list`实现双向链表，代码简洁且高效。
  - 通过迭代器进行插入和删除操作，避免了手动维护指针的复杂性。
  - 详细解释了`std::list`的使用方法，适合熟悉STL的读者。
  
**核心代码：**
```cpp
list<int> queList;
void buildQueue() {
    queList.push_front(1);
    pos[1] = queList.begin();
    for (int i = 2; i <= N; i++) {
        int k, p;
        scanf("%d%d", &k, &p);
        if (p == 0) {
            pos[i] = queList.insert(pos[k], i); //left
        } else {
            auto nextIter = next(pos[k]);
            pos[i] = queList.insert(nextIter, i); //right
        }
    }
}
```

#### 3. **作者：夜刀神十香ღ (赞：165)**
- **星级：4星**
- **关键亮点**：
  - 使用数组模拟双向链表，代码简洁且高效。
  - 通过标记数组记录删除状态，避免重复删除。
  - 详细解释了插入和删除操作的步骤，适合初学者理解。
  
**核心代码：**
```cpp
int a[100010][3]; //a[i][2]表示学号为i的同学右边同学的学号
void insert(int i, int k, int p) {
    if (p == 0) { //插入左边
        a[a[k][3]][2] = i;
        a[i][2] = k;
        a[i][3] = a[k][3];
        a[k][3] = i;
    } else { //插入右边
        a[i][2] = a[k][2];
        a[a[k][2]][3] = i;
        a[k][2] = i;
        a[i][3] = k;
    }
}
```

### 最优关键思路与技巧

1. **双向链表的应用**：通过维护每个节点的左右指针，可以高效实现插入和删除操作，时间复杂度为O(1)。
2. **标记数组**：通过标记数组记录删除状态，避免重复删除，简化了删除操作的实现。
3. **STL的使用**：对于熟悉C++ STL的读者，使用`std::list`可以大大简化代码，且代码可读性更高。

### 扩展思路与推荐题目

1. **扩展思路**：本题可以进一步优化，例如通过引入哨兵节点简化边界条件的处理，或者使用更高效的数据结构（如平衡树）来处理更复杂的操作。
2. **推荐题目**：
   - [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：考察线段树的基本操作，适合练习区间查询和更新。
   - [P3368 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3368)：考察树状数组的基本操作，适合练习单点更新和区间查询。
   - [P3374 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3374)：考察树状数组的区间更新和单点查询，适合进一步巩固树状数组的使用。

### 总结

本题解的核心在于**双向链表**的应用，通过维护每个节点的左右指针，可以高效实现插入和删除操作。对于初学者，建议从数组模拟链表入手，逐步过渡到使用STL中的`std::list`。对于更复杂的操作，可以考虑引入哨兵节点或使用更高效的数据结构。

---
处理用时：40.66秒
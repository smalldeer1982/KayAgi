# 题目信息

# [NOIP 2011 普及组] 瑞士轮

## 题目背景

在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。

本题中介绍的瑞士轮赛制，因最早使用于$1895$年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。


## 题目描述

$2 \times N$ 名编号为 $1\sim 2N$ 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。

每轮比赛的对阵安排与该轮比赛开始前的排名有关：第$1$ 名和第$2$ 名、第 $3$ 名和第 $4$名、……、第$2K - 1 $名和第$ 2K$名、……  、第$2N - 1 $名和第$2N$名，各进行一场比赛。每场比赛胜者得$1 $分，负者得 $0 $分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。

现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第$ Q$ 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。


## 说明/提示

【样例解释】

 ![](https://cdn.luogu.com.cn/upload/pic/98.png) 

【数据范围】

对于$30\% $的数据，$1 ≤ N ≤ 100$；

对于$50\% $的数据，$1 ≤ N ≤ 10,000 $；

对于$100\%$的数据，$1 ≤ N ≤ 100,000,1 ≤ R ≤ 50,1 ≤ Q ≤ 2N,0 ≤ s_1, s_2, …, s_{2N}≤10^8,1 ≤w_1, w_2 , …, w_{2N}≤ 10^8$。

noip2011普及组第3题。


## 样例 #1

### 输入

```
2 4 2 
7 6 6 7 
10 5 20 15 
```

### 输出

```
1
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在每一轮比赛后高效地对选手进行排序。由于直接使用 `sort` 会导致时间复杂度过高，多数题解采用了归并排序或 `stable_sort` 来优化排序过程。归并排序的优势在于它能够利用每一轮比赛后胜者和败者各自有序的特性，通过合并两个有序数组来达到 $O(n)$ 的时间复杂度，从而避免了对整个数组进行重新排序的冗余操作。

### 精选题解

#### 1. 作者：皎月半洒花 (赞：460)
- **星级**：★★★★★
- **关键亮点**：
  - 详细解释了为何 `sort` 不适合本题，并引入了归并排序的思想。
  - 通过归并排序的合并操作，避免了不必要的排序，提升了效率。
  - 代码结构清晰，注释详细，易于理解。
- **个人心得**：
  - "归并排序每次的操作只针对相邻区间，符合只需要修改相邻几个分数的排布状况的题意。即使和快排的复杂度相同，但是省掉了冗杂无用的操作，是一个极大的改良。"

**核心代码**：
```cpp
void merge() {
    int i,j;
    i=j=1,a[0]=0;
    while(i<=win[0] && j<=lose[0])
        if(cmp(win[i],lose[j])) a[++a[0]]=win[i++];
        else a[++a[0]]=lose[j++];
    while(i<=win[0])a[++a[0]]=win[i++];
    while(j<=lose[0])a[++a[0]]=lose[j++];
}
```

#### 2. 作者：List (赞：188)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用了结构体存储选手信息，并通过归并排序合并胜者和败者数组。
  - 代码简洁，逻辑清晰，适合初学者理解归并排序的应用。
- **个人心得**：
  - "每组比赛的胜者和败者都是有序的，只需进行合并操作即可，合并操作的复杂度是 $O(n)$，而如果用快排其复杂度为 $O(n \log n)$。"

**核心代码**：
```cpp
void MergeSort() {
    int i=1,j=1,k=1;
    while(i<=n && j<=n) {
        if(A[i].grade > B[j].grade || (A[i].grade == B[j].grade && A[i].num < B[j].num))
            a[k++] = A[i++];
        else a[k++] = B[j++];
    }
    while(i<=n) a[k++] = A[i++];
    while(j<=n) a[k++] = B[j++];
}
```

#### 3. 作者：LevenKoko (赞：12)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用了 `merge` 函数来合并胜者和败者数组，代码简洁且高效。
  - 通过结构体存储选手信息，代码可读性较高。
- **个人心得**：
  - "merge函数的作用是：将两个有序的序列合并为一个有序的序列。函数参数：merge(first1,last1,first2,last2,result,compare);"

**核心代码**：
```cpp
merge(w+1,w+1+win,l+1,l+1+lose,a+1,cmp);
```

### 最优关键思路与技巧

1. **归并排序的应用**：利用每一轮比赛后胜者和败者各自有序的特性，通过合并两个有序数组来达到 $O(n)$ 的时间复杂度，避免了对整个数组进行重新排序的冗余操作。
2. **结构体存储选手信息**：通过结构体存储选手的分数、实力值和编号，便于排序和比较。
3. **`stable_sort` 的使用**：在需要稳定排序的场景下，`stable_sort` 是一个高效的替代方案。

### 拓展思路与类似题目

1. **类似题目**：
   - [P2827 [NOIP2016 提高组] 蚯蚓](https://www.luogu.com.cn/problem/P2827)：同样涉及到对有序队列的合并操作。
   - [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)：涉及到对有序队列的合并操作。
   - [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)：涉及到对有序队列的处理。

### 总结

本题的核心在于如何高效地对选手进行排序，归并排序和 `stable_sort` 是解决这一问题的关键。通过利用每一轮比赛后胜者和败者各自有序的特性，可以大大减少排序的时间复杂度，提升算法的效率。

---
处理用时：29.51秒
# 题目信息

# [NOIP 2013 提高组] 积木大赛

## 题目背景

NOIP2013 提高组 D2T1

## 题目描述

春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为 $n$ 的大厦，大厦可以看成由 $n$ 块宽度为 $1$ 的积木组成，第 $i$ 块积木的最终高度需要是 $h_i$。

在搭建开始之前，没有任何积木（可以看成 $n$ 块高度为 $0$ 的积木）。接下来每次操作，小朋友们可以选择一段连续区间 $[l, r]$，然后将第 $L$ 块到第 $R$ 块之间（含第 $L$ 块和第 $R$ 块）所有积木的高度分别增加 $1$。

小 M 是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。


## 说明/提示

**样例解释**

其中一种可行的最佳方案，依次选择：$[1,5]$，$ [1,3]$，$[2,3]$，$[3,3]$，$ [5,5]$。

**数据范围**

- 对于 $30\%$ 的数据，有 $1 \leq n \leq 10$；
- 对于 $70\%$ 的数据，有 $1 \leq n \leq 1000$；
- 对于 $100\%$ 的数据，有 $1 \leq n \leq 100000$，$0 \leq h_i \leq 10000$。


## 样例 #1

### 输入

```
5
2 3 4 1 2```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心是通过贪心算法或差分思想来求解最少的操作次数。大多数题解都采用了相似的核心思路：遍历数组，计算相邻元素的高度差，并累加正差值。这种方法的时间复杂度为O(n)，空间复杂度为O(1)，非常高效。

### 最优关键思路或技巧

1. **贪心算法**：通过计算相邻元素的高度差，累加正差值，确保每次操作都能覆盖尽可能多的积木。
2. **差分思想**：通过差分数组来计算每个积木与前一个积木的高度差，累加正差值，简化了问题的求解过程。

### 扩展思路

1. **类似题目**：可以扩展到其他需要区间操作的题目，如区间覆盖、区间修改等。
2. **优化思路**：在实际应用中，可以考虑并行计算或使用更高效的数据结构来进一步优化。

### 推荐题目

1. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)
2. [P3078 积木大赛 II](https://www.luogu.com.cn/problem/P3078)
3. [P1969 积木大赛](https://www.luogu.com.cn/problem/P1969)

### 所选高星题解

#### 题解1：作者：niuniudundun (4星)
**关键亮点**：思路清晰，代码简洁，直接通过遍历数组计算相邻元素的高度差，累加正差值。
**核心代码**：
```cpp
#include<iostream>
using namespace std;
long long n,d[100001],ans=0;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>d[i];
    }
    for(int i=1;i<=n;i++){
        if(d[i]>d[i-1]) ans+=d[i]-d[i-1];
    }
    cout<<ans<<endl;
    return 0;
}
```

#### 题解2：作者：GSQ0829 (4星)
**关键亮点**：使用贪心策略，通过填坑法解释思路，代码实现简洁明了。
**核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a, last = 0, ans = 0;
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a;
        if (a > last) ans += (a - last);
        last = a;
    }
    cout << ans << endl;
    return 0;
}
```

#### 题解3：作者：sea_bird (4星)
**关键亮点**：详细解释了贪心算法的思路，代码实现清晰，适合初学者理解。
**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long cnt=0,n;
long long a[100005];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=2;i<=n;i++){
        if(a[i]>a[i-1]){
            cnt+=a[i]-a[i-1];
        }
    }
    cout<<cnt+a[1]<<endl;
    return 0;
}
```

### 个人心得摘录

- **调试经历**：一些作者提到在实现过程中遇到了TLE问题，通过优化算法和代码结构解决了问题。
- **顿悟感想**：通过贪心算法和差分思想，简化了问题的求解过程，提高了代码的效率。

### 通用建议与扩展思路

对于类似的区间操作问题，建议优先考虑贪心算法或差分思想，确保每次操作都能覆盖尽可能多的元素。在实际应用中，可以通过并行计算或使用更高效的数据结构来进一步优化。

---
处理用时：23.61秒
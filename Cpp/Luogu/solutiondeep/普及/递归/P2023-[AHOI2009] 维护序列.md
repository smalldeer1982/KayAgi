# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果

### 综合分析与结论

本题解主要围绕线段树的实现与优化展开，涉及区间加法、区间乘法、区间查询等操作。大部分题解采用了线段树的经典实现方式，通过维护 `sum`、`add`、`mul` 三个标记来处理区间操作。部分题解在实现细节上进行了优化，如使用指针加速输入、位运算优化代码等。整体来看，题解的质量参差不齐，部分题解思路清晰、代码简洁，但也有一些题解代码冗长、优化不足。

### 评分较高的题解

#### 1. **作者：Mingoal (赞：74)**
   - **星级：★★★★☆**
   - **关键亮点**：代码简洁，思路清晰，详细解释了线段树的构建、标记下传、区间修改与查询的实现。特别强调了乘法和加法的优先级处理，确保标记下传时乘法和加法的顺序正确。
   - **核心代码**：
     ```cpp
     void maintain(int t,int k){
         tr[t<<1].sum=(tr[t<<1].sum*tr[t].mul+tr[t].add*(k+1>>1))%p;
         tr[t<<1|1].sum=(tr[t<<1|1].sum*tr[t].mul+tr[t].add*(k>>1))%p;
         tr[t<<1].mul=tr[t<<1].mul*tr[t].mul%p;
         tr[t<<1|1].mul=tr[t<<1|1].mul*tr[t].mul%p;
         tr[t<<1].add=(tr[t<<1].add*tr[t].mul+tr[t].add)%p;
         tr[t<<1|1].add=(tr[t<<1|1].add*tr[t].mul+tr[t].add)%p;
         tr[t].mul=1;tr[t].add=0;
     }
     ```
   - **个人心得**：作者强调了乘法和加法的优先级问题，指出在标记下传时必须先处理乘法再处理加法，否则会导致错误。

#### 2. **作者：GaryZhong (赞：17)**
   - **星级：★★★★☆**
   - **关键亮点**：使用了结构体指针构建线段树，避免了堆式存储的局限性，适合动态开点。代码结构清晰，注释详细，适合初学者理解。
   - **核心代码**：
     ```cpp
     void pushdown(Node *p){
         if (p->tag_add == 0 && p->tag_mul == 1) return;
         p->sum = getD(p);
         p->lc->tag_add = p->lc->tag_add * p->tag_mul + p->tag_add;
         p->rc->tag_add = p->rc->tag_add * p->tag_mul + p->tag_add;
         p->lc->tag_mul = p->lc->tag_mul * p->tag_mul;
         p->rc->tag_mul = p->rc->tag_mul * p->tag_mul;
         p->tag_add = 0; p->tag_mul = 1;
     }
     ```
   - **个人心得**：作者提到使用指针构建线段树的好处，特别是在处理非堆式存储时，指针可以更灵活地管理内存。

#### 3. **作者：1010_ (赞：3)**
   - **星级：★★★★☆**
   - **关键亮点**：代码简洁，优化了输入输出，使用了指针加速输入，代码风格良好，适合竞赛使用。
   - **核心代码**：
     ```cpp
     void SegmentTree::input(LL _n) {
         LL *begin = a + 1, *end = a + _n + 1;
         while (begin != end) {
             *begin = read();
             ++begin;
         }
     }
     ```
   - **个人心得**：作者提到使用指针加速输入的经验，指出指针在处理大规模数据时比数组索引更快。

### 最优关键思路与技巧

1. **标记下传的顺序**：在处理乘法和加法时，必须先处理乘法再处理加法，否则会导致错误。这是线段树实现中的关键点。
2. **指针加速输入**：在处理大规模数据时，使用指针加速输入可以显著提高代码效率。
3. **结构体指针构建线段树**：使用指针构建线段树可以更灵活地管理内存，特别是在动态开点时非常有用。

### 可拓展之处

1. **动态开点线段树**：在处理大规模数据时，动态开点线段树可以节省内存，适合处理稀疏数据。
2. **多标记处理**：在处理复杂的区间操作时，可能需要维护多个标记，如加法、乘法、赋值等，需要合理处理标记下传的顺序。

### 推荐题目

1. **P3373 【模板】线段树 2**：与本题几乎相同，适合练习线段树的区间加法、乘法和查询操作。
2. **P5490 【模板】扫描线**：涉及线段树在扫描线算法中的应用，适合拓展线段树的使用场景。
3. **P3384 【模板】树链剖分**：涉及线段树在树链剖分中的应用，适合进一步理解线段树在复杂数据结构中的使用。

### 个人心得总结

- **调试经历**：多位作者提到在实现线段树时，标记下传的顺序容易出错，特别是在处理乘法和加法时，必须先处理乘法再处理加法。
- **踩坑教训**：部分作者提到在处理大规模数据时，使用指针加速输入可以显著提高代码效率，而数组索引则可能成为性能瓶颈。
- **顿悟感想**：通过实现线段树，多位作者深刻理解了标记下传的重要性，特别是在处理复杂区间操作时，标记下传的顺序和逻辑必须清晰。

---
处理用时：46.13秒
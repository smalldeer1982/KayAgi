# 题目信息

# 打开所有的灯

## 题目背景

pmshz在玩一个益(ruo)智(zhi)的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了pmshz。。。


## 题目描述

这个灯很奇(fan)怪(ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉pmshz要全部打开这些灯。



例如
```
0  1  1
1  0  0
1  0  1
```

点一下最中间的灯【2,2】就变成了
```
0  0  1
0  1  1
1  1  1
```

再点一下左上角的灯【1,1】就变成了

```
1  1  1
1  1  1
1  1  1
```

达成目标。最少需要2步。

输出2即可。


## 说明/提示

这个题水不水，就看你怎么考虑了。。。。


## 样例 #1

### 输入

```
0 1 1
1 0 0
1 0 1```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心是通过最少的操作次数将所有灯打开，每个操作会改变当前灯及其周围灯的状态。题解中主要采用了以下几种思路：

1. **暴力枚举**：通过枚举所有可能的操作组合，找到最少的操作次数。虽然时间复杂度较高，但由于问题规模较小，依然可行。
2. **状态压缩与BFS**：将灯的状态压缩为一个二进制数，通过BFS搜索最短路径。这种方法效率较高，适合状态数较少的问题。
3. **DFS与回溯**：通过DFS遍历所有可能的操作序列，结合剪枝优化，减少不必要的搜索。
4. **异或方程组**：将问题转化为异或方程组，通过解方程组找到最优解。这种方法较为复杂，但理论上可以处理更大的问题规模。

### 所选高星题解

#### 1. **Bartholomew 的题解（4星）**
- **关键亮点**：通过二进制枚举所有可能的操作组合，利用位运算高效地判断每个灯的状态是否满足条件。代码简洁，思路清晰。
- **核心代码**：
  ```cpp
  for(int used=0;used<(1<<9);used++) // 暴力枚举二进制
  {
      get(used); memset(how,0,sizeof how);
      for(int i=0;i<9;i++) //算i号的灯盏被操作了多少次!
          if(s[i]) //9 个格子的打暴力,其实可以变得简洁一些!
          {
              if(!i) how[0]++,how[1]++,how[3]++;
              else if(i==1) how[0]++,how[1]++,how[2]++,how[4]++;
              else if(i==2) how[1]++,how[2]++,how[5]++;
              else if(i==3) how[0]++,how[6]++,how[4]++,how[3]++;
              else if(i==4) how[4]++,how[1]++,how[3]++,how[5]++,how[7]++;
              else if(i==5) how[4]++,how[5]++,how[2]++,how[8]++;
              else if(i==6) how[6]++,how[3]++,how[7]++;
              else if(i==7) how[7]++,how[6]++,how[8]++,how[4]++;
              else if(i==8) how[5]++,how[7]++,how[8]++;
          }
      bool flag=true;
      for(int i=0;i<9;i++)  // 计算是否可行!
          if(how[i]%2==1 && a[i]) flag=false;
          else if(how[i]%2==0 && !a[i]) flag=false;
      if(flag)
      {
          tot=0;
          for(int i=0;i<9;i++) if(s[i]) tot++;
          ans=getmin(tot,ans);
      } 
  }
  ```

#### 2. **nothingness 的题解（4星）**
- **关键亮点**：使用状态压缩和BFS，通过异或操作快速改变灯的状态，利用队列进行广度优先搜索，找到最短路径。
- **核心代码**：
  ```cpp
  int main()
  {
      for(int i=8;i>=0;i--)
          scanf("%d",&a),x+=a*(1<<i);
      memset(f,-1,sizeof(f));
      f[x]=0;
      q[++t]=x;
      while(h<t)
      {
          x=q[++h];
          for(int i=1;i<=9;i++)
              if(f[x^upd[i]]==-1)
                  q[++t]=x^upd[i],f[x^upd[i]]=f[x]+1;
      }
      printf("%d",f[511]);
      return 0;
  }
  ```

#### 3. **ljc1301 的题解（4星）**
- **关键亮点**：通过枚举第一行的操作状态，逐步推导出后续行的操作，最终判断是否满足条件。这种方法减少了搜索空间，提高了效率。
- **核心代码**：
  ```cpp
  void dfs(int s) //枚举第一行的状态
  {
      if(s>=n) //如果第一行枚举完了，那就看看能不能更新答案
      {
          num=min(num,pd());
          return;
      }
      for(ans[0][s]=0;ans[0][s]<2;ans[0][s]++) //枚举当前灯点或者不点
          dfs(s+1);
  }
  ```

### 最优关键思路与技巧

1. **状态压缩**：将灯的状态压缩为一个二进制数，便于快速存储和操作。
2. **BFS与队列**：通过BFS搜索最短路径，结合队列实现广度优先搜索，确保找到最优解。
3. **枚举与剪枝**：通过枚举部分状态（如第一行），结合剪枝策略，减少搜索空间，提高效率。

### 可拓展之处

- **类似问题**：如“八数码问题”、“华容道”等，都可以通过状态压缩和BFS解决。
- **优化思路**：对于更大的问题规模，可以考虑使用A*算法或IDA*算法进行进一步优化。

### 推荐题目

1. **P1379 八数码问题**：通过状态压缩和BFS解决经典的八数码问题。
2. **P2324 [SCOI2005]骑士精神**：通过BFS和状态压缩解决骑士移动问题。
3. **P1074 靶形数独**：通过DFS和剪枝解决数独问题。

### 个人心得总结

- **调试经历**：部分题解中提到在调试过程中发现忘记pop队列元素，导致程序无法正常运行。这提醒我们在编写BFS时，务必注意队列的操作。
- **顿悟感想**：通过枚举部分状态（如第一行），可以大大减少搜索空间，提高算法效率。这种思路在解决类似问题时非常有用。

---
处理用时：35.67秒
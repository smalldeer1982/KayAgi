# 题目信息

# [TJOI2007] 跳棋

## 题目背景

在一个n×n的棋盘上，布满了0和1，如图（a）所示（n=7），为叙述方便，将0用字母表示，如图（b）。

![](https://cdn.luogu.com.cn/upload/pic/6077.png)


## 题目描述

跳棋规则：

（1）从某个0格出发，可以向上，下，左，右4个方向连续越过若干个（至少1个）

1格而跳入下一个0格。如图（b）中从A出发，可跳到B，或者到E，但不能直接到K。在跳到B之后还可以继续跳到F;在跳到E之后可继续跳到F或K。直到不能再跳为止。

（2）每个0格只能到达一次，给出的起始点不能再到达，也不能越过。

跳过的距离为跳过1格个数加1，如从A到B，跳过距离为3，从B到F，跳过距离为2。

问   题： 当棋盘和起始点给出之后，问最远能跳的距离是多少？

如上图（b）中，从A出发，可跳过的路线不止一条，其中一条为：

A － B － F － L － K － E  （可能不唯一）

3    2    3    3     3

它的距离为14。


## 说明/提示

$\text{upd 2022.7.27}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
4  3  2
1  0  1  0 
1  1  1  1
0  0  1  0
1  1  0  1```

### 输出

```
6```

# AI分析结果

### 综合分析与结论

本题解的难点在于如何在棋盘上模拟跳棋的跳跃过程，并找到最远的跳跃距离。大多数题解采用了深度优先搜索（DFS）来遍历所有可能的跳跃路径，并通过回溯来避免重复访问。部分题解还通过优化搜索方向或使用标记数组来提高效率。

### 所选高分题解

#### 1. 作者：犇犇犇犇 (★★★★★)
- **关键亮点**：使用DFS进行搜索，通过`while`循环处理跳跃过程，避免相邻0格直接跳跃，代码简洁且易于理解。
- **个人心得**：作者提到“这道题稍微难一点的地方就是$dfs$的时候从$0$开始不碰到下一个0或者边界**永不停止**”，强调了边界条件的处理。

```cpp
void dfs(int x, int y, int step) {
    ans = max(ans, step);
    for (int i = 0; i < 4; i++) {
        int tx = x, ty = y, s = 0;
        while (tx + dx[i] > 0 && tx + dx[i] <= n && ty + dy[i] > 0 && ty + dy[i] <= n) {
            tx += dx[i]; ty += dy[i]; s++;
            if (m[tx][ty] == 0) break;
        }
        if (tx > 0 && tx <= n && ty > 0 && ty <= n && f[tx][ty] == 0 && m[tx][ty] == 0 && s != 1) {
            f[tx][ty] = 1;
            dfs(tx, ty, step + s);
            f[tx][ty] = 0;
        }
    }
}
```

#### 2. 作者：JJA_ (★★★★☆)
- **关键亮点**：通过`while`循环处理跳跃过程，使用`chkmax`宏更新最大距离，代码结构清晰。
- **个人心得**：作者提到“这道题目中数据范围为 $n\le100$ ，可以能用爆搜过掉”，强调了数据范围对算法选择的影响。

```cpp
void dfs(int x, int y, int t) {
    chkmax(ans, t);
    vis[x][y] = 1;
    for (int i = 1; i <= 4; i++) {
        int xx = x + _x[i], yy = y + _y[i], sum = 1;
        while (xx > 0 && yy > 0 && xx <= n && yy <= n) {
            if (mapp[xx][yy] == 1) {
                xx += _x[i]; yy += _y[i]; sum++;
            } else {
                if (sum != 1 && vis[xx][yy] != 1) dfs(xx, yy, t + sum);
                break;
            }
        }
    }
    vis[x][y] = 0;
}
```

#### 3. 作者：zilingheimei (★★★★☆)
- **关键亮点**：通过`while`循环处理跳跃过程，使用`abs`计算跳跃距离，代码简洁且易于理解。
- **个人心得**：作者提到“因为这是跳棋，也就是从第一个0开始只要还是1就一直跳下去”，强调了跳跃过程的连续性。

```cpp
void dfs(int x, int y, int step) {
    if (step > ans) ans = step;
    int nx, ny;
    for (int i = 0; i < 4; i++) {
        nx = x + dx[i]; ny = y + dy[i];
        while (nx >= 1 && nx <= n && ny >= 1 && ny <= n && a[nx][ny] == 1) {
            nx += dx[i]; ny += dy[i];
        }
        if (nx < 1 || nx > n || ny < 1 || ny > n) continue;
        if (used[nx][ny] == 1) continue;
        if (abs(nx - x) + abs(ny - y) == 1) continue;
        used[nx][ny] = 1;
        dfs(nx, ny, step + abs(nx - x) + abs(ny - y));
        used[nx][ny] = 0;
    }
}
```

### 最优关键思路与技巧

1. **DFS与回溯**：通过DFS遍历所有可能的跳跃路径，并使用回溯避免重复访问。
2. **跳跃过程处理**：使用`while`循环处理跳跃过程，确保跳跃的连续性和边界条件的处理。
3. **距离计算**：通过`abs`函数计算跳跃距离，确保距离计算的准确性。

### 可拓展之处

- **类似算法套路**：类似的搜索问题可以通过DFS或BFS解决，如迷宫问题、路径搜索等。
- **优化方向**：可以考虑使用记忆化搜索或剪枝技术来进一步优化搜索效率。

### 推荐题目

1. [P1560 [USACO5.2]蜗牛的旅行Snail Trails](https://www.luogu.com.cn/problem/P1560)
2. [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)
3. [P1219 [USACO1.5]八皇后 Checker Challenge](https://www.luogu.com.cn/problem/P1219)

---
处理用时：27.41秒
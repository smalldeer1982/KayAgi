# 题目信息

# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心是通过广度优先搜索（BFS）或双向BFS来寻找从初始字符串到目标字符串的最短变换路径。由于题目限制了变换步数（最多10步），且字符串长度较短（最多20），BFS是一种较为合适的算法。大部分题解都采用了BFS，并通过字符串替换、判重等技巧来优化搜索过程。

**关键优化点：**
1. **双向BFS**：部分题解采用了双向BFS，从初始字符串和目标字符串同时进行搜索，显著减少了搜索空间，提升了效率。
2. **字符串替换与判重**：通过`string::find`和`string::replace`等STL函数实现字符串的查找与替换，结合`map`或`set`进行判重，避免重复搜索。
3. **剪枝与优化**：部分题解通过剪枝（如步数超过10步时直接停止搜索）和优化（如优先扩展节点数较少的队列）来进一步提升性能。

**通用建议与扩展思路：**
- **双向BFS**：在处理类似的最短路径问题时，双向BFS是一种非常有效的优化手段，尤其当搜索空间较大时。
- **字符串处理技巧**：熟练掌握`string`类的相关操作（如`find`、`replace`、`substr`等）可以大大简化字符串处理问题。
- **判重与剪枝**：在搜索过程中，合理的判重和剪枝策略可以有效减少不必要的计算，提升算法效率。

### 所选高星题解

#### 1. **题解作者：BrandonSoong**
- **星级：5星**
- **关键亮点**：采用了双向BFS，显著减少了搜索空间，代码结构清晰，优化到位。
- **个人心得**：作者提到双向BFS可以减少约50%的搜索空间，实际测试中速度提升明显。
- **核心代码片段：**
```cpp
void bfs() {
    queue<string> q1, q2;
    q1.push(A); q2.push(B);
    map<string, int> vis1, vis2;
    vis1[A] = 0; vis2[B] = 0;
    
    while (!q1.empty() && !q2.empty()) {
        string s1 = q1.front(); q1.pop();
        string s2 = q2.front(); q2.pop();
        
        if (vis1.find(s2) != vis1.end()) {
            cout << vis1[s2] + vis2[s2] << endl;
            return;
        }
        if (vis2.find(s1) != vis2.end()) {
            cout << vis1[s1] + vis2[s1] << endl;
            return;
        }
        
        // 扩展q1和q2
    }
    cout << "NO ANSWER!" << endl;
}
```
- **核心思想**：双向BFS从初始和目标字符串同时进行搜索，当两个队列中的字符串相遇时，输出总步数。

#### 2. **题解作者：Mitch谜团**
- **星级：4星**
- **关键亮点**：使用了迭代加深搜索（IDDFS），通过逐步增加搜索深度来避免DFS的深度过大问题。
- **个人心得**：作者提到IDDFS在步数限制较小的情况下非常有效，避免了BFS的空间开销。
- **核心代码片段：
```cpp
bool dfs(string now, int step, int depth) {
    if (step > depth) return false;
    if (now == B) return true;
    for (int i = 1; i <= n; i++) {
        size_t pos = now.find(a[i]);
        while (pos != string::npos) {
            string tmp = now;
            tmp.replace(pos, a[i].length(), b[i]);
            if (dfs(tmp, step + 1, depth)) return true;
            pos = now.find(a[i], pos + 1);
        }
    }
    return false;
}
```
- **核心思想**：通过逐步增加搜索深度，避免DFS的深度过大问题，适合步数限制较小的情况。

#### 3. **题解作者：coyangjr**
- **星级：4星**
- **关键亮点**：使用了KMP算法进行字符串匹配，提升了字符串查找的效率。
- **个人心得**：作者提到KMP算法在处理字符串匹配时比暴力查找更高效，尤其当字符串较长时。
- **核心代码片段：
```cpp
void KMP(string a, int x, int step) {
    string z = a;
    a = " " + a;
    int j = 0;
    for (int i = 1; i < a.length(); i++) {
        while (j > 0 && a[i] != b[x][j + 1]) j = nxt[x][j];
        if (a[i] == b[x][j + 1]) j++;
        if (j == b[x].length() - 1) {
            int t = i - b[x].length() + 1;
            string tmp = z.substr(0, t) + change[x] + z.substr(t + b[x].length() - 1);
            q.push(Node(tmp, step + 1));
            j = nxt[x][j];
        }
    }
}
```
- **核心思想**：通过KMP算法高效查找字符串中的匹配子串，提升了字符串替换的效率。

### 推荐题目
1. **P3375 【模板】KMP字符串匹配**：考察KMP算法的实现与应用。
2. **P3808 【模板】AC自动机（简单版）**：考察字符串匹配与自动机的应用。
3. **P3796 【模板】AC自动机（加强版）**：进一步考察AC自动机的复杂应用。

---
处理用时：37.04秒
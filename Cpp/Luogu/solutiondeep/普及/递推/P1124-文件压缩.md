# 题目信息

# 文件压缩

## 题目背景

提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。


## 题目描述

该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。

举例：$S$ 是 `example`

1. 构造 $n$ 个字符串。

```plain
example
xamplee
ampleex
mpleexa
pleexam
leexamp
eexampl
```

2. 将字符串排序。

```plain
ampleex
example
eexampl
leexamp
mpleexa
pleexam
xamplee
```
3. 压缩结果。

$S' = \texttt{xelpame}$，$p = 7$

由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。

请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。

保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。

## 样例 #1

### 输入

```
7
xelpame
7
```

### 输出

```
example
```

# AI分析结果

### 综合分析与结论

这道题目要求根据给定的压缩字符串 $S'$ 和位置 $p$，还原出原始字符串 $S$。题解中大多数思路都是通过排序后的字符串 $S'$ 和原始字符串 $S'$ 之间的首尾字符对应关系，逐步推导出原始字符串。主要难点在于如何正确处理字符的对应关系，尤其是当存在重复字符时，如何避免错位。

大多数题解都采用了倒推的方式，即从最后一个字符开始，逐步推导出前一个字符。这种方法可以有效避免正推时由于字符重复导致的错位问题。此外，题解中普遍使用了标记法，通过标记已经使用过的字符来避免重复选择。

### 所选高星题解

#### 1. 作者：MC_Launcher (赞：143)  
**星级：5星**  
**关键亮点：**  
- 通过倒推的方式避免了正推时字符错位的问题。
- 使用标记法（`b[i]=')'`）来避免重复选择字符。
- 代码结构清晰，注释详细，易于理解。

**个人心得：**  
“我第一次正着排就才10分，所以我们要倒着找，最后反着输出。” 作者通过调试发现正推会导致字符错位，最终选择倒推的方式解决问题。

**核心代码：**
```cpp
for(int i=1;i<n;i++) //ans[i]表示倒数第i+1个字母
{
    for(int j=n-1;j>=0;j--) //从后往前搜到第一个与原char串匹配的字典序串
    {
        if(b[j]==a[now])
        {
            now=j; //更改现在所在位置，即跳到前一个字母
            ans[i]=a[now]; //计入答案
            b[j]=')'; //标记
            break;
        }
    }	
}
```

#### 2. 作者：liuzhaoxu (赞：43)  
**星级：4.5星**  
**关键亮点：**  
- 详细解释了为什么不能正推，并通过示例说明了正推的问题。
- 使用倒推的方式，结合标记法，确保字符对应关系的正确性。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
while(cnt>1){ // 不能正着推，因为正着推肯定得从给你的序列中按顺序找，但是给你的序列无序
    ans[--cnt]=s[p]; //将s[p]作为当前未确定的答案的最后一位
    ss[p]='#';//ss[p] 是 s[p]的前一位，确定s[p]前一步是确定ss[p],他们下标相同(都是p)。 现在s[p]已记录，ss[p] 没用了，为了防止重复选，置为'#'
    for(int i=n;i>=1;--i) if(ss[i]==s[p]) {p=i;break;} //找到一个与本次while的s[p]相同的一个ss[p],进而推出s[p]的前一位
}
```

#### 3. 作者：Elgo87 (赞：15)  
**星级：4星**  
**关键亮点：**  
- 通过图示直观地展示了字符的对应关系，帮助理解倒推的过程。
- 使用标记法（`b[j]='!'`）来避免重复选择字符。
- 代码结构清晰，注释详细。

**核心代码：**
```cpp
for(int i=1; i<len; i++)  //重复匹配，直到所有字符都被标记上 '!'
{
    for(int j=len-1; j>=0; j--)
    {
        if(b[j] == a[x])
        {
            x = j;
            c[i] = a[x]; //这里要正序组合 c 串
            b[j] = '!';
            break;
        }
    }
}
```

### 最优关键思路与技巧

1. **倒推法**：从最后一个字符开始，逐步推导出前一个字符，避免正推时由于字符重复导致的错位问题。
2. **标记法**：通过标记已经使用过的字符，确保每个字符只被使用一次，避免重复选择。
3. **排序与对应关系**：通过排序后的字符串和原始字符串之间的首尾字符对应关系，逐步还原原始字符串。

### 可拓展之处

- **类似算法套路**：这种通过排序和对应关系逐步推导的算法可以应用于其他字符串还原问题，如字符串的旋转、排列等。
- **同类型题目**：可以考虑处理更复杂的字符串变换问题，如多次旋转、部分排序等。

### 推荐题目

1. **P1124 文件压缩**（本题）
2. **P3375 【模板】KMP字符串匹配**（考察字符串匹配与还原）
3. **P1090 【NOIP2009 提高组】合并果子**（考察字符串的合并与排序）

### 个人心得总结

- **调试经历**：多位作者提到正推时由于字符重复导致的错位问题，最终通过倒推的方式解决了问题。
- **踩坑教训**：在处理字符串还原问题时，尤其是存在重复字符时，正推容易导致错位，倒推是更可靠的选择。
- **顿悟感想**：通过排序和标记法，可以有效解决字符串还原问题，尤其是在处理复杂字符串变换时，这种方法具有通用性。

---
处理用时：25.47秒
# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果

### 综合分析与结论

该题目要求在有向无环图（DAG）中，为每个城市找到以该城市为终点的最长路径。大多数题解采用了**拓扑排序**结合**动态规划（DP）**的思路，确保在计算每个城市的最长路径时，其前驱城市的最长路径已经计算完毕。部分题解还使用了**记忆化搜索**来优化递归过程，避免重复计算。

关键思路总结：
1. **拓扑排序**：确保在计算每个城市的最长路径时，其前驱城市的最长路径已经计算完毕，满足DP的无后效性。
2. **动态规划**：通过状态转移方程 `dp[v] = max(dp[v], dp[u] + 1)`，计算每个城市的最长路径。
3. **记忆化搜索**：通过递归和缓存中间结果，避免重复计算，优化时间复杂度。

### 所选高星题解

#### 题解1：星星之火 (5星)
**关键亮点**：
- 详细解释了拓扑排序与DP的结合原理，帮助读者理解为什么拓扑排序可以保证DP的无后效性。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
void topsort() {
    queue<int> q;
    for (int i = 1; i <= n; i++)
        if (ru[i] == 0) q.push(i);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            ru[v]--;
            if (ru[v] == 0) q.push(v);
        }
    }
}
```
**实现思想**：通过队列实现拓扑排序，确保每个城市的前驱城市的最长路径已经计算完毕。

#### 题解2：_ZZH (4星)
**关键亮点**：
- 代码简洁，直接在拓扑排序过程中进行DP，减少了额外的遍历。
- 使用邻接表存储图，优化了空间复杂度。

**核心代码**：
```cpp
while (!q.empty()) {
    int cnt = q.front(); q.pop();
    for (int i = lin[cnt]; i; i = e[i].next) {
        f[e[i].to] = max(f[e[i].to], f[cnt] + 1);
        if (--in[e[i].to] == 0) q.push(e[i].to);
    }
}
```
**实现思想**：在拓扑排序的过程中，直接更新每个城市的最长路径，减少了额外的遍历。

#### 题解3：归山_ (4星)
**关键亮点**：
- 使用反向图进行记忆化搜索，思路新颖。
- 代码简洁，易于理解。

**核心代码**：
```cpp
int dfs(int x) {
    if (dp[x] != -1) return dp[x];
    dp[x] = 1;
    for (int i = head[x]; i; i = e[i].next) {
        int y = e[i].to;
        dp[x] = max(dp[x], dfs(y) + 1);
    }
    return dp[x];
}
```
**实现思想**：通过反向图和记忆化搜索，递归计算每个城市的最长路径，避免重复计算。

### 通用建议与扩展思路

1. **拓扑排序的应用**：拓扑排序不仅适用于DAG的最长路径问题，还可以用于任务调度、依赖关系解析等场景。
2. **记忆化搜索的优化**：在递归问题中，记忆化搜索可以有效减少重复计算，适用于状态转移较为复杂的问题。
3. **动态规划的无后效性**：在DP问题中，确保状态转移的顺序正确，避免后效性带来的错误。

### 推荐题目

1. **P4017 最大食物链计数**：考察拓扑排序与DP的结合。
2. **P1137 旅行计划**：与本题类似，考察DAG的最长路径。
3. **P3388 【模板】割点（割顶）**：考察图的遍历与割点算法，适合进一步理解图论。

### 个人心得摘录

- **调试经历**：部分题解提到在调试过程中发现入度为0的城市不止一个，导致初始代码无法通过所有测试用例。这提醒我们在处理图论问题时，要仔细考虑边界情况。
- **顿悟感想**：通过拓扑排序和DP的结合，可以有效地解决DAG中的最长路径问题，这种思路可以推广到其他类似的图论问题中。

---
处理用时：23.14秒
# 题目信息

# [NOIP 2011 提高组] 选择客栈

## 题目描述

丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。

两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$ 。

他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/pic/101.png) 

2 人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤，但是若选择住 $4,5$号客栈的话，$4,5$ 号客栈之间的咖啡店的最低消费是 $4$ ，而两人能承受的最低消费是 $3$ 元，所以不满足要求。因此只有前 $3$ 种方案可选。

### 数据范围

- 对于 $30\% $ 的数据，有 $n \leq 100$ ；
- 对于 $50\% $ 的数据，有 $n \leq 1\,000$；
- 对于 $100\%$ 的数据，有 $2 \leq n \leq 2 \times 10^5$，$1 \leq k
 \leq 50$，$0 \leq p \leq 100$，$0 \leq b_i \leq 100$。

## 样例 #1

### 输入

```
5 2 3 
0 5 
1 3 
0 2 
1 4 
1 5 
```

### 输出

```
3
```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何高效统计满足条件的客栈对，即两个客栈颜色相同且它们之间存在一个咖啡店的最低消费不超过给定值 \( p \)。题解中主要采用了以下几种思路：

1. **枚举右端点并维护合法左端点**：通过维护一个变量记录最近合法的咖啡店位置，并利用前缀和或桶数组统计合法左端点的数量。
2. **分组处理**：将数据按颜色分组，独立处理每种颜色，利用双指针或二分查找优化区间查询。
3. **分治与容斥**：通过分治或容斥思想，将问题分解为子问题，减少重复计算。

这些思路的共同点是通过预处理和优化，将原本 \( O(n^2) \) 的暴力解法优化到 \( O(n) \) 或 \( O(n \log n) \) 的复杂度，显著提高了算法的效率。

### 所选高分题解

#### 1. **ShawnZhou (5星)**
- **关键亮点**：通过枚举右端点，维护最近合法的咖啡店位置，并利用前缀和统计合法左端点的数量。代码简洁，思路清晰，时间复杂度为 \( O(n) \)。
- **核心代码**：
  ```cpp
  for (int i=1;i<=n;i++){
      cin >> color >> price;
      if (price <= p)
          now = i;
      if (now >= last[color])
          sum[color] = cnt[color];
      last[color] = i;
      ans += sum[color];
      cnt[color]++;
  }
  ```
- **实现思想**：每次输入一个客栈时，更新最近合法的咖啡店位置 `now`，并利用 `last` 数组记录每种颜色最后一个客栈的位置。通过 `sum` 数组统计合法左端点的数量，最终累加到答案中。

#### 2. **Shunpower (5星)**
- **关键亮点**：提供了多种解法，包括枚举咖啡店、枚举右端点、枚举左端点（双指针）、分治、容斥等，全面覆盖了本题的多种优化思路。代码实现清晰，思路多样。
- **核心代码**：
  ```cpp
  for (int i=1;i<=n;i++){
      if (b[i]<=p){
          for (int j=lst+1;j<=i;j++) sum[a[j]]++;
          lst=i;
      }
      ans+=sum[a[i]]-(b[i]<=p);
  }
  ```
- **实现思想**：枚举右端点，维护最近合法的咖啡店位置 `lst`，并利用 `sum` 数组统计合法左端点的数量。通过减去当前客栈自身的贡献，避免重复计算。

#### 3. **Leo_Anderson (5星)**
- **关键亮点**：通过递推和分组处理，将问题分解为颜色独立的子问题，利用 `hav` 和 `cor` 数组记录合法点的数量和答案点对的数量。思路清晰，代码简洁。
- **核心代码**：
  ```cpp
  for (int i=1;i<=n;i++){
      int a,b;scanf("%d%d",&a,&b);
      if (b<=P) flag=i;
      if (lst[a]<=flag && lst[a]!=0) cor[a]=hav[a];
      ans[a]+=cor[a];
      lst[a]=i;
      hav[a]++;
  }
  ```
- **实现思想**：每次输入一个客栈时，更新最近合法的咖啡店位置 `flag`，并利用 `cor` 数组记录合法左端点的数量。通过 `ans` 数组累加每种颜色的方案数。

### 最优关键思路与技巧

1. **枚举右端点并维护合法左端点**：通过维护最近合法的咖啡店位置，利用前缀和或桶数组统计合法左端点的数量，时间复杂度为 \( O(n) \)。
2. **分组处理与双指针**：将数据按颜色分组，独立处理每种颜色，利用双指针或二分查找优化区间查询，时间复杂度为 \( O(n \log n) \)。
3. **分治与容斥**：通过分治或容斥思想，将问题分解为子问题，减少重复计算，时间复杂度为 \( O(n \log n) \)。

### 可拓展之处

- **类似问题**：本题的优化思路可以应用于其他需要统计满足条件的区间对的问题，如统计满足某些条件的子数组或子序列。
- **数据结构**：前缀和、双指针、分治等技巧在处理区间统计问题时非常有效，可以推广到其他类似问题中。

### 推荐题目

1. **P1886 滑动窗口**：考察滑动窗口与双指针的应用，与本题的枚举右端点思路类似。
2. **P3372 线段树 1**：考察区间查询与更新，与本题的分组处理思路类似。
3. **P3383 线性筛素数**：考察预处理与优化，与本题的前缀和思路类似。

### 个人心得摘录

- **ShawnZhou**：通过枚举右端点并维护合法左端点，成功将暴力解法优化到线性复杂度，思路清晰且代码简洁。
- **Shunpower**：提供了多种解法，全面覆盖了本题的优化思路，代码实现清晰，思路多样，适合深入学习。
- **Leo_Anderson**：通过递推和分组处理，将问题分解为颜色独立的子问题，思路清晰且代码简洁，适合理解递推思想的应用。

这些心得展示了如何通过优化思路和代码实现，高效解决复杂问题，值得借鉴。

---
处理用时：26.40秒
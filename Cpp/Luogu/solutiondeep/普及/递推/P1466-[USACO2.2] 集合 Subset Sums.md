# 题目信息

# [USACO2.2] 集合 Subset Sums

## 题目描述

对于从 $1\sim n$ 的连续整数集合，能划分成两个子集合，且保证每个集合的数字和是相等的。举个例子，如果 $n=3$，对于 $\{1,2,3\}$ 能划分成两个子集合，每个子集合的所有数字和是相等的：

$\{3\}$ 和 $\{1,2\}$ 是唯一一种分法（交换集合位置被认为是同一种划分方案，因此不会增加划分方案总数）  
如果 $n=7$，有四种方法能划分集合 $\{1,2,3,4,5,6,7 \}$，每一种分法的子集合各数字和是相等的:

$\{1,6,7\}$ 和 $\{2,3,4,5\}$  
$\{2,5,7\}$ 和 $\{1,3,4,6\}$  
$\{3,4,7\}$ 和 $\{1,2,5,6\}$  
$\{1,2,4,7\}$ 和 $\{3,5,6\}$  

给出 $n$，你的程序应该输出划分方案总数。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 39$。

翻译来自NOCOW

USACO 2.2


## 样例 #1

### 输入

```
7
```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论

本题的核心是将集合划分为两个和相等的子集，本质上是一个**背包问题**。大多数题解都采用了**动态规划**的思路，尤其是**01背包**的变种。部分题解还引入了**Meet-in-the-middle**的优化技巧，适用于数据范围较大的情况。整体来看，动态规划是最为通用且高效的解法，而Meet-in-the-middle则是在特定数据范围下的优化手段。

### 精选题解

#### 1. 作者：Makasukaka (赞：45)  
**星级：★★★★★**  
**关键亮点：**  
- 使用**Meet-in-the-middle**技巧，将时间复杂度从O(2^N)优化到O(2^(N/2))，适用于n≤39的数据范围。
- 代码简洁，思路清晰，通过将集合分为两部分并分别枚举子集，最后通过哈希表（数组）快速查找匹配的和。

**核心代码：**
```cpp
for(int i=0;i<(1<<(n/2));++i){
    int cur=0;
    for(int j=0;(i>>j)>0;++j)if((i>>j)&1)cur+=(j+1);
    b[cur]++;
}
for(int i=0;i<(1<<(n-n/2));++i){
    int cur=0;
    for(int j=0;(i>>j)>0;++j)if((i>>j)&1)cur+=j+n/2+1;
    if((1+n)*n/4>=cur)
    ans+=b[(1+n)*n/4-cur];
}
```
**实现思想：**  
将集合分为两部分，分别枚举所有可能的子集和，并通过数组记录前半部分的和，最后在后半部分枚举时查找匹配的和。

#### 2. 作者：Qutam (赞：37)  
**星级：★★★★☆**  
**关键亮点：**  
- 经典的**01背包**解法，状态转移方程清晰，代码易于理解。
- 通过二维数组记录前i个数和为j的方案数，适合初学者理解背包问题的基本思路。

**核心代码：**
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=n*(n+1)/2;j++){
        dp[i][j]=dp[i-1][j];
        if(j>=a[i])dp[i][j]+=dp[i-1][j-a[i]];
    }
```
**实现思想：**  
通过状态转移方程`dp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]]`，逐步计算前i个数和为j的方案数。

#### 3. 作者：courage (赞：27)  
**星级：★★★★☆**  
**关键亮点：**  
- 使用**一维数组**优化空间复杂度，代码简洁高效。
- 通过倒序循环避免重复计算，适合对背包问题有一定理解的读者。

**核心代码：**
```cpp
for(int i=1;i<=n;i++)
    for(int j=s;j>=i;j--)
        f[j]+=f[j-i];
```
**实现思想：**  
通过一维数组`f[j]`记录和为j的方案数，倒序循环确保每个数只被使用一次。

### 最优关键思路与技巧

1. **动态规划（01背包）**：将问题转化为背包问题，通过状态转移方程逐步计算方案数，适合大多数情况。
2. **Meet-in-the-middle**：将集合分为两部分，分别枚举子集和，最后通过哈希表快速查找匹配的和，适用于数据范围较大的情况。
3. **空间优化**：使用一维数组代替二维数组，减少空间复杂度，同时通过倒序循环避免重复计算。

### 拓展思路

- **同类型题**：类似的问题包括“分割等和子集”、“目标和”等，都可以通过动态规划或Meet-in-the-middle技巧解决。
- **算法套路**：背包问题的变种在竞赛中非常常见，掌握其基本思路和优化技巧对解决类似问题有很大帮助。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典的01背包问题。
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064) - 背包问题的变种，涉及依赖关系。
3. [P1156 垃圾陷阱](https://www.luogu.com.cn/problem/P1156) - 动态规划与背包问题的结合，考察状态转移的设计。

### 个人心得摘录

- **Makasukaka**：通过将集合分为两部分，分别枚举子集和，最后通过哈希表快速查找匹配的和，大大减少了时间复杂度。
- **courage**：使用一维数组优化空间复杂度，倒序循环避免重复计算，代码简洁高效。
- **Qutam**：经典的01背包解法，状态转移方程清晰，适合初学者理解背包问题的基本思路。

---
处理用时：21.79秒
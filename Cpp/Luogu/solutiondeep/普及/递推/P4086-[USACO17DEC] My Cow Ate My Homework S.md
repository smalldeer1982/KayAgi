# 题目信息

# [USACO17DEC] My Cow Ate My Homework S

## 题目描述

在你的牛历史课上，你被布置了一份相当长的作业，包含 $N$ 个问题（$3 \leq N \leq 100,000$），每个问题的得分是一个在 0 到 10,000 之间的整数。按照惯例，你的老师计划通过去掉你得分最低的一个问题，然后对剩余问题的得分取平均来给出最终成绩。不幸的是，你的宠物奶牛 Bessie 刚刚吃掉了你前 $K$ 个问题的答案！（$K$ 可能小到 1，也可能大到 $N-2$）。

经过多次解释，你的老师终于相信了你的说法，并同意按照之前的方式对剩余的未被吃掉的部分作业进行评分——即去掉得分最低的问题（或在得分相同的情况下去掉其中一个），然后对剩余问题取平均。

请输出所有能够使你获得最高可能成绩的 $K$ 值，并按升序排列。

## 说明/提示

如果 Bessie 吃掉了前两个问题，那么剩余的得分是 9、2 和 7。去掉最低分并取平均后，最终成绩为 8，这是可能的最高成绩。

## 样例 #1

### 输入

```
5
3 1 9 2 7```

### 输出

```
2```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地计算每个可能的 $K$ 值对应的平均分，并找到使平均分最大的 $K$ 值。主要难点在于如何快速求解区间最小值和区间和，避免暴力计算导致的时间复杂度爆炸。

从题解中可以看出，大部分解法都采用了预处理的方式来优化计算，常见的方法包括：
1. **前缀和**：用于快速计算区间和。
2. **后缀最小值**：通过从后向前遍历，预处理每个位置到末尾的最小值。
3. **线段树**：用于动态维护区间最小值，适合更复杂的问题场景。
4. **单调栈**：用于维护区间最小值，时间复杂度较低。

最优解通常结合了前缀和与后缀最小值的预处理，时间复杂度为 $O(n)$，能够高效地解决问题。

### 所选高分题解

#### 1. 作者：_jimmywang_ (5星)
**关键亮点**：
- 使用了后缀最小值和前缀和的预处理，避免了重复计算。
- 代码简洁，逻辑清晰，时间复杂度为 $O(n)$。
- 通过倒序遍历，巧妙地将最小值和区间和的计算合并在一起。

**核心代码**：
```cpp
for(int i=n;i>=2;i--){
    mn[i]=min(mn[i+1],a[i]);
    sum[i]=sum[i+1]+a[i];
    if(i!=n)avr[i]=(sum[i]-mn[i])/(double)(n-i);
}
```
**实现思想**：通过从后向前遍历，预处理每个位置到末尾的最小值和区间和，然后直接计算平均分。

#### 2. 作者：Siyuan (4星)
**关键亮点**：
- 使用了前缀和的思想，结合区间最小值的动态维护。
- 通过枚举 $K$ 值，递推求解最优解，时间复杂度为 $O(n)$。
- 代码结构清晰，注释详细，适合初学者理解。

**核心代码**：
```cpp
rep2(i,n-1,2){
    mins=min(mins,s[i]);
    sum+=s[i];
    if((sum-mins)/(double)(n-i)>aver){
        cnr=1;
        k[cnr]=i-1;
        aver=(sum-mins)/(double)(n-i);
    }else if((sum-mins)/(double)(n-i)==aver)
        k[++cnr]=i-1;
}
```
**实现思想**：通过从后向前遍历，动态维护区间最小值和区间和，计算平均分并更新最大值。

#### 3. 作者：TRZ_2007 (4星)
**关键亮点**：
- 使用了前缀和和后缀最小值的预处理，时间复杂度为 $O(n)$。
- 代码简洁，逻辑清晰，适合快速解决问题。
- 通过枚举 $K$ 值，计算平均分并找到最大值。

**核心代码**：
```cpp
for(int i=n;i>=1;i--){
    Min[i]=min(Min[i+1],a[i]);
}
for(int i=1;i<=n-2;i++){
    Score=(sum[n]-sum[i]-Min[i])*1.0/(n-i-1);
    if(Score-Max>=eps){
        Max=Score;
    }
}
```
**实现思想**：通过预处理后缀最小值和前缀和，快速计算每个 $K$ 值对应的平均分，并找到最大值。

### 最优关键思路与技巧

1. **预处理后缀最小值和前缀和**：通过从后向前遍历，预处理每个位置到末尾的最小值和区间和，避免重复计算，时间复杂度为 $O(n)$。
2. **枚举 $K$ 值**：通过枚举每个可能的 $K$ 值，计算对应的平均分，并找到最大值。
3. **注意精度问题**：在计算平均分时，使用 `double` 类型，避免精度丢失。

### 可拓展之处

- **类似问题**：对于需要频繁查询区间最小值或区间和的问题，可以考虑使用前缀和、后缀最小值、线段树等数据结构进行优化。
- **动态维护**：如果问题涉及到动态更新数据，可以考虑使用线段树或树状数组来维护区间信息。

### 推荐相似题目

1. **P1886 滑动窗口**：考察单调队列的应用，适合练习区间最小值的维护。
2. **P3372 线段树 1**：考察线段树的基本操作，适合练习区间和的动态维护。
3. **P1440 求m区间内的最小值**：考察单调队列的应用，适合练习区间最小值的快速查询。

### 个人心得总结

- **调试经历**：在处理区间最小值时，初始值设置不当可能导致错误，建议初始值设置为一个较大的数（如 `INT_MAX`）。
- **踩坑教训**：在计算平均分时，注意使用 `double` 类型，避免整数除法导致的精度丢失。
- **顿悟感想**：通过预处理和后缀最小值的结合，可以大幅降低时间复杂度，提升算法效率。

---
处理用时：25.13秒
# 题目信息

# 消失之物

## 题目描述

ftiasch 有 $n$ 个物品, 体积分别是 $w_1,w_2,\dots,w_n$。由于她的疏忽，第 $i$ 个物品丢失了。   

“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。  

她把答案记为 $\text{cnt}(i,x)$ ，想要得到所有$i \in [1,n]$, $x \in [1,m]$ 的 $\text{cnt}(i,x)$ 表格。

![](https://cdn.luogu.com.cn/upload/pic/13426.png)


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n,m \le 2000$，且 $1\le v_i\le m$。

【样例解释】  
如果物品 3 丢失的话，只有一种方法装满容量是 2 的背包，即选择物品 1 和物品 2。

---

$\text{upd 2023.8.11}$：新增加五组 Hack 数据。


## 样例 #1

### 输入

```
3 2
1 1 2```

### 输出

```
11
11
21```

# AI分析结果

### 综合分析与结论

本题的核心在于如何在删除某个物品后，快速计算剩余物品装满背包的方案数。大多数题解都采用了“退背包”的思路，即先计算所有物品的背包方案数，然后通过撤销某个物品的贡献来得到删除该物品后的方案数。这种方法的时间复杂度为 \(O(n \times m)\)，能够有效避免多次重复计算。

### 所选题解

#### 1. 作者：Kelin (5星)
**关键亮点**：
- 思路清晰，直接指出了“退背包”的核心思想。
- 代码简洁，易于理解，且时间复杂度优化到位。
- 通过顺推减去转移的方式，巧妙避免了重复计算。

**核心代码**：
```cpp
memcpy(g,f,sizeof f);
for(int j=w[i];j<=m;++j)
    g[j]-=g[j-w[i]];
```
**实现思想**：通过撤销某个物品的贡献，得到删除该物品后的方案数。

#### 2. 作者：King丨帝御威 (4星)
**关键亮点**：
- 使用了二维数组 `f[i][0]` 和 `f[i][1]` 分别表示包含和不包含某个物品的方案数。
- 通过递推公式 `f[j][1] = f[j][0] - f[j-v[i]][1]` 来计算删除某个物品后的方案数。
- 代码结构清晰，逻辑严密。

**核心代码**：
```cpp
for(int i=1;i<=n;++i)
for(int j=1;j<=m;++j)
if(j-v[i]>=0) f[j][1]=(f[j][0]-f[j-v[i]][1]+10)%10;
```
**实现思想**：通过递推公式计算删除某个物品后的方案数，确保不重复计算。

#### 3. 作者：Gary818 (4星)
**关键亮点**：
- 思路明确，直接指出“总方案数 - 选当前物品的方案数 = 不选当前物品的方案数”。
- 代码实现简洁，逻辑清晰，易于理解。
- 通过 `g[x] = f[x] - g[x-w[i]]` 来计算不选某个物品的方案数。

**核心代码**：
```cpp
if(w[i]>x) g[x]=f[x]%10;
else g[x]=(f[x]-g[x-w[i]]+10)%10;
```
**实现思想**：通过总方案数减去选当前物品的方案数，得到不选当前物品的方案数。

### 最优关键思路与技巧

1. **退背包思想**：先计算所有物品的背包方案数，然后通过撤销某个物品的贡献来得到删除该物品后的方案数。
2. **递推公式**：通过 `g[x] = f[x] - g[x-w[i]]` 或 `f[j][1] = f[j][0] - f[j-v[i]][1]` 来计算删除某个物品后的方案数。
3. **时间复杂度优化**：通过一次背包计算和多次撤销操作，将时间复杂度优化到 \(O(n \times m)\)。

### 可拓展之处

1. **同类型题**：类似的问题可以通过“退背包”思想来解决，如删除多个物品后的方案数计算。
2. **类似算法套路**：在动态规划中，通过撤销某些操作的贡献来快速计算新的状态，是一种常见的优化手段。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典01背包问题，适合练习背包基础。
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064) - 带有依赖关系的背包问题，适合练习复杂背包。
3. [P2014 选课](https://www.luogu.com.cn/problem/P2014) - 树形背包问题，适合练习树形DP与背包结合。

### 个人心得摘录

- **调试经历**：在撤销操作时，需要注意顺序，避免重复计算或遗漏某些状态。
- **踩坑教训**：在计算过程中，取模运算可能会导致负数，需要加上模数后再取模。
- **顿悟感想**：通过撤销操作的思路，能够大大减少重复计算，提高算法效率。

---
处理用时：20.13秒
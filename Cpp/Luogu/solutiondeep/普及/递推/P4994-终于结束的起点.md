# 题目信息

# 终于结束的起点

## 题目背景

> 终于结束的起点  
> 终于写下句点  
> 终于我们告别  
> 终于我们又回到原点  
> ……

一个个 OIer 的竞赛生涯总是从一场 NOIp 开始，大多也在一场 NOIp 中结束，好似一次次轮回在不断上演。  
如果这次 NOIp 是你的起点，那么祝你的 OI 生涯如同夏花般绚烂。  
如果这次 NOIp 是你的终点，那么祝你的 OI 回忆宛若繁星般璀璨。  
也许这是你最后一次在洛谷上打比赛，也许不是。  
不过，无论如何，祝你在一周后的比赛里，好运。

当然，这道题也和轮回有关系。

## 题目描述

广为人知的斐波拉契数列 $\mathrm{fib}(n)$ 是这么计算的

$$
\mathrm{fib}(n)=\begin{cases}
0,& n=0 \\
1,& n=1 \\
\mathrm{fib}(n-1) + \mathrm{fib}(n-2),& n>1
\end{cases}
$$

也就是 $0, 1, 1, 2, 3, 5, 8, 13 \cdots$，每一项都是前两项之和。

小 F 发现，如果把斐波拉契数列的每一项对任意大于 $1$ 的正整数 $M$ 取模的时候，数列都会产生循环。

当然，小 F 很快就明白了，因为 ($\mathrm{fib}(n - 1) \bmod M$) 和 ($\mathrm{fib}(n - 2) \bmod M)$ 最多只有 $M ^ 2$ 种取值，所以在 $M  ^ 2$ 次计算后一定出现过循环。

甚至更一般地，我们可以证明，无论取什么模数 $M$，最终模 $M$ 下的斐波拉契数列都会是 $0, 1, \cdots, 0, 1, \cdots$。

现在，给你一个模数 $M$，请你求出最小的 $n > 0$，使得 $\mathrm{fib}(n) \bmod M = 0, \mathrm{fib}(n + 1) \bmod M = 1$。

## 说明/提示

#### 样例 1 解释

斐波拉契数列为 $0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \cdots$，在对 $2$ 取模后结果为 $0, 1, 1, 0, 1, 1, 0, 1, 1, 0, \cdots$。

我们可以发现，当 $n = 3$ 时，$f(n) \bmod 2= 0, f(n + 1) \bmod 2 = 1$，也就是我们要求的 $n$ 的最小值。

#### 数据范围

对于 $30\%$ 的数据，$M \leq 18$；

对于 $70\%$ 的数据，$M \leq 2018$；

对于 $100\%$ 的数据，$2 \leq M \leq 706150=\verb!0xAC666!$。

#### 提示

如果你还不知道什么是取模 $(\bmod)$，那我也很乐意告诉你，模运算是求整数除法得到的余数，也就是竖式除法最终「除不尽」的部分，也即
$$a \bmod M =k \iff a = bM + k\ (M > 0, 0 \leq k < M)$$
其中 $a, b, k$ 都是非负整数。

如果你使用 `C` / `C++`，你可以使用 `%` 来进行模运算。

如果你使用 `Pascal`，你可以使用 `mod` 来进行模运算。

## 样例 #1

### 输入

```
2```

### 输出

```
3```

## 样例 #2

### 输入

```
6```

### 输出

```
24```

# AI分析结果

### 综合分析与结论

本题的核心是求斐波那契数列在模 \( M \) 下的最小循环节长度。题解中主要分为两类思路：暴力求解和基于数论的优化方法。暴力解法通过直接计算斐波那契数列的模数，直到找到满足条件的 \( n \)。而数论方法则利用了皮萨诺周期的性质，通过分解质因数、计算最小公倍数等数学技巧来优化求解过程。

暴力解法虽然简单，但由于 \( M \) 的最大值为 706150，暴力计算在时间上是可行的，且代码实现较为直观。数论方法虽然理论上更高效，但实现复杂度较高，且需要对数论知识有较深的理解。

### 所选高星题解

#### 1. 作者：万弘 (赞：29)
- **星级**: 4.5
- **关键亮点**: 使用了记忆化优化暴力解法，避免了重复计算，代码简洁且易于理解。
- **个人心得**: 作者提到“加个记忆化就OK，不用优化空间”，强调了记忆化在暴力解法中的重要性。

```cpp
#include<cstdio>
typedef long long ll;
using namespace std;
const ll INF=0x7fffffff;
ll fp[10000002]; // 记忆数组
ll m;
ll f(ll i) {
    if(fp[i]) return fp[i]; // 调取记忆
    if(i==1||i==2) return fp[i]=1%m;
    else return fp[i]=(f(i-1)+f(i-2))%m; // 顺带%m
}
int main() {
    scanf("%lld",&m);
    ll i=1; // 枚举
    while(f(i)!=0||f(i+1)!=1) i++;
    printf("%lld",i);
    return 0;
}
```

#### 2. 作者：a13518354766 (赞：22)
- **星级**: 4.0
- **关键亮点**: 通过质因数分解和皮萨诺周期的性质，优化了暴力解法，适用于较大的 \( M \)。
- **个人心得**: 作者提到“暴力运行次数最多为14*n(稳过。。。)”，强调了优化后的暴力解法在时间上的可行性。

```cpp
inline int bl(int x) { // 暴力计算
    f[1]=1;
    for(int i=2;;i++) {
        f[i]=f[i-1]+f[i-2];
        f[i]%=x;
        if(f[i]==1&&f[i-1]==0) return i-1;
    }
}
```

#### 3. 作者：Cheng_yf (赞：11)
- **星级**: 4.0
- **关键亮点**: 使用了矩阵快速幂和数论知识，进一步优化了求解过程，适用于更大的 \( M \)。
- **个人心得**: 作者提到“这个题暴力就可以了因为M比较小”，强调了暴力解法在本题中的适用性。

```cpp
inline bool check(ll sum) {
    ll b[2]={0,1};
    power_p(b,sum,M);
    return b[1]==0&&b[0]==1;
}
```

### 最优关键思路与技巧

1. **记忆化优化**: 在暴力解法中，使用记忆化可以避免重复计算，显著提高效率。
2. **皮萨诺周期**: 利用皮萨诺周期的性质，通过质因数分解和最小公倍数计算，可以优化求解过程。
3. **矩阵快速幂**: 通过矩阵快速幂计算斐波那契数列的模数，适用于更大的 \( M \)。

### 可拓展之处

- **同类型题**: 类似的问题可以扩展到其他递推数列的模数循环节计算，如卢卡斯数列、佩尔数列等。
- **算法套路**: 对于模数循环节的计算，通常可以通过暴力、记忆化、数论优化等方法来解决。

### 推荐题目

1. **P1306 斐波那契公约数**: 考察斐波那契数列的性质与最大公约数的关系。
2. **P1962 斐波那契数列**: 考察斐波那契数列的快速计算。
3. **P1939 矩阵加速（数列）**: 考察矩阵快速幂在数列计算中的应用。

### 个人心得总结

- **调试经历**: 多位作者提到在打表找规律时遇到困难，最终选择暴力解法或数论优化。
- **踩坑教训**: 部分作者提到未开 `long long` 导致爆零，强调了数据类型选择的重要性。
- **顿悟感想**: 通过打表和数论知识，作者们逐渐理解了皮萨诺周期的性质，并成功应用于解题。

---
处理用时：21.05秒
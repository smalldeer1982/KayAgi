# 题目信息

# [NOIP 2004 提高组] 合并果子

## 题目描述

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $=3+12=15$ 。可以证明 $15$ 为最小的体力耗费值。

## 说明/提示

对于 $30\%$ 的数据，保证有 $n \le 1000$：

对于 $50\%$ 的数据，保证有 $n \le 5000$；

对于全部的数据，保证有 $n \le 10000$。


## 样例 #1

### 输入

```
3 
1 2 9 
```

### 输出

```
15
```

# AI分析结果

### 综合分析与结论

本题的核心问题是如何通过合并果子的策略，使得总体力消耗最小。多数题解都采用了贪心策略，即每次合并当前最小的两堆果子，这与哈夫曼树的构建思路一致。主要的数据结构选择包括优先队列（小根堆）和手写堆，时间复杂度为 \(O(n \log n)\)。部分题解还提供了对贪心策略的证明，增强了算法的可信度。

### 所选高星题解

#### 1. 作者：学委 (5星)
**关键亮点**：
- 提供了详细的贪心策略证明，解释了为什么每次合并最小的两堆果子是最优的。
- 使用了STL的优先队列，代码简洁且易于理解。
- 通过反例说明了某些常见误解的错误，增强了题解的严谨性。

**核心代码**：
```cpp
priority_queue < int, vector <int>, greater <int> > q;
while(q.size() > 1) {
    int x = q.top(); q.pop();
    int y = q.top(); q.pop();
    ans += x + y;
    q.push(x + y);
}
```
**核心思想**：使用小根堆每次取出最小的两堆果子合并，直到只剩一堆。

#### 2. 作者：微雨燕双飞 (4星)
**关键亮点**：
- 手写了二叉小根堆的实现，展示了堆的基本操作（插入、删除、调整）。
- 代码结构清晰，适合学习堆的实现细节。
- 通过手写堆，加深了对堆操作的理解。

**核心代码**：
```cpp
void insert(int val) {
    heap[++size] = val;
    up(size);
}
void extract() {
    heap[1] = heap[size--];
    down(1);
}
```
**核心思想**：手动实现小根堆，每次取出堆顶的两个最小元素合并，再插入堆中。

#### 3. 作者：sbh2012 (4星)
**关键亮点**：
- 通过简单的数学推导，直观地解释了贪心策略的正确性。
- 使用了STL的优先队列，代码简洁且易于理解。
- 通过举例说明了贪心策略的优势，增强了题解的可读性。

**核心代码**：
```cpp
priority_queue<int, vector<int>, greater<int> > a;
while(a.size() > 1) {
    int k = a.top(); a.pop();
    int j = a.top(); a.pop();
    s += k + j;
    a.push(k + j);
}
```
**核心思想**：使用小根堆每次取出最小的两堆果子合并，直到只剩一堆。

### 最优关键思路与技巧

1. **贪心策略**：每次合并当前最小的两堆果子，确保总体力消耗最小。
2. **数据结构选择**：优先队列（小根堆）是实现贪心策略的最佳数据结构，时间复杂度为 \(O(n \log n)\)。
3. **证明与反例**：通过数学证明和反例分析，增强了算法的可信度。

### 可拓展之处

- **哈夫曼树**：本题的贪心策略与哈夫曼树的构建思路一致，可以进一步学习哈夫曼编码等相关知识。
- **堆的应用**：堆在解决类似问题时非常高效，如Dijkstra算法、最小生成树等。

### 推荐题目

1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378)

### 个人心得总结

- **调试经历**：部分题解提到了手写堆的实现细节，强调了堆的调整操作（`up` 和 `down`）的重要性。
- **踩坑教训**：有题解通过反例指出了某些贪心策略的误区，提醒我们在设计算法时要考虑全面。
- **顿悟感想**：通过本题的贪心策略，深刻理解了哈夫曼树的构建过程，进一步加深了对贪心算法的理解。

---
处理用时：32.17秒
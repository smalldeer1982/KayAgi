# 题目信息

# [NOIP 2004 提高组] 合唱队形

## 题目描述

$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。

合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1< \cdots <t_i>t_{i+1}>$ … $>t_k(1\le i\le k)$。

你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

## 说明/提示

对于 $50\%$ 的数据，保证有 $n \le 20$。

对于全部的数据，保证有 $n \le 100$。


## 样例 #1

### 输入

```
8
186 186 150 200 160 130 197 220
```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论

本题的核心是寻找一个序列中的最长合唱队形，即先递增后递减的子序列。通过动态规划（DP）可以有效地解决这个问题。题解中提到的思路是分别计算每个位置的最长上升子序列（LIS）和最长下降子序列（LDS），然后通过组合这两个序列来找到最优解。

### 所选题解

#### 题解1：shinzanmono (4星)
- **关键亮点**：
  - 使用动态规划分别计算每个位置的最长上升子序列和最长下降子序列。
  - 提出了优化思路，将时间复杂度从 $O(n^2)$ 优化到 $O(n\log n)$。
  - 思路清晰，代码实现简洁。

- **个人心得**：
  - 作者提到可以通过维护值域上的最大值来优化转移过程，这是一个常见的DP优化技巧。

### 核心代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];

    vector<int> f(n, 1), g(n, 1);
    for (int i = 1; i < n; ++i)
        for (int j = 0; j < i; ++j)
            if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1);

    for (int i = n - 2; i >= 0; --i)
        for (int j = n - 1; j > i; --j)
            if (a[j] < a[i]) g[i] = max(g[i], g[j] + 1);

    int ans = 0;
    for (int i = 0; i < n; ++i)
        ans = max(ans, f[i] + g[i] - 1);

    cout << n - ans << endl;
    return 0;
}
```

### 关键思路与技巧

1. **动态规划**：通过分别计算每个位置的最长上升子序列和最长下降子序列，然后将两者结合来找到最优解。
2. **优化技巧**：通过维护值域上的最大值来优化转移过程，将时间复杂度从 $O(n^2)$ 优化到 $O(n\log n)$。

### 拓展思路

- **类似算法套路**：这种先递增后递减的序列问题，可以推广到其他类似的序列问题，如最长山峰序列、最长波浪序列等。
- **数据结构**：可以使用线段树或树状数组来进一步优化DP的转移过程。

### 推荐题目

1. **最长上升子序列**（洛谷 P1020）
2. **最长下降子序列**（洛谷 P1091）
3. **最长山峰序列**（洛谷 P2947）

这些题目都涉及到序列的动态规划问题，可以帮助进一步巩固和拓展相关算法知识。

---
处理用时：22.60秒
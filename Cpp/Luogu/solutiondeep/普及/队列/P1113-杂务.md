# 题目信息

# 杂务

## 题目描述

John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。

当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。

John 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。

写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。


## 样例 #1

### 输入

```
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
```

### 输出

```
23
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过拓扑排序或动态规划的思想，计算所有杂务完成的最短时间。由于杂务之间存在依赖关系，且可以并发执行，因此需要找到每个杂务的最早完成时间，并取其中的最大值作为最终答案。

大多数题解采用了拓扑排序或动态规划的思路，部分题解还结合了记忆化搜索、优先队列等优化手段。整体来看，题解的质量参差不齐，部分题解代码简洁且思路清晰，而另一些则较为冗长或缺乏优化。

### 精选题解

#### 1. 作者：Nishikino_Curtis (5星)
**关键亮点**：代码简洁，直接利用输入顺序进行动态规划，避免了复杂的拓扑排序操作。通过维护每个杂务的最早完成时间，最终取最大值作为答案。
**个人心得**：作者提到“我是仗着代码短才来发的”，体现了对代码简洁性的追求。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,l,t,ans[10005],maxans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&i);
        scanf("%d",&l);
        int tmp=0;
        while(scanf("%d",&t)&&t)
            tmp=max(ans[t],tmp);
        ans[i]=tmp+l;
        maxans=max(ans[i],maxans);
    } 
    printf("%d\n",maxans);
    return 0;
 } 
```

#### 2. 作者：Keith_2006 (4星)
**关键亮点**：详细介绍了拓扑排序的实现方法，并提供了记忆化搜索和BFS两种实现方式，适合初学者理解拓扑排序的应用场景。
**个人心得**：作者提到“看自己四年前的博客重新学习拓扑排序”，体现了对知识点的深入理解和复习的重要性。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cctype>
#include <vector>
#include <queue>
#define ll long long
using namespace std;
inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while (!isdigit(ch)) {if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	return x*f;
}
const int N=500005;
int ind[N],f[N],a[N];
vector <int> edge[N];
queue <int> q;
int main() {
	int n=read();
	for (int i=1;i<=n;i++) {
		int x=read();
		a[i]=read();
		while (int y=read()) {
			if (!y) break;
			edge[y].push_back(x);
            ind[x]++;
		}
	}
	for (int i=1;i<=n;i++) {
		if (ind[i]==0) {
			q.push(i);
			f[i]=a[i];
		}
	};
	while (!q.empty()) {
		int rhs=q.front();
		q.pop();
		for (int i=0;i<edge[rhs].size();i++) {
			int u=edge[rhs][i];
			ind[u]--;
			if (ind[u]==0) q.push(u);
			f[u]=max(f[u],f[rhs]+a[u]);
		}
	}
	int ans=0;
	for (int i=1;i<=n;i++) {
		ans=max(ans,f[i]);
	}
	printf("%d\n",ans);
	return 0;
}
```

#### 3. 作者：SW_Wind (4星)
**关键亮点**：代码简洁，直接利用输入顺序进行动态规划，避免了复杂的拓扑排序操作。通过维护每个杂务的最早完成时间，最终取最大值作为答案。
**个人心得**：作者提到“不过我代码是不是短了点”，体现了对代码简洁性的追求。

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[10005], n, k, ans, t;
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        scanf("%d%d", &k, &t);
        while(scanf("%d", &k) && k)
            f[i] = max(f[k], f[i]);
        f[i] += t;
        ans = max(ans, f[i]);
    }
    printf("%d", ans);
}
```

### 最优关键思路与技巧

1. **动态规划**：通过维护每个杂务的最早完成时间，避免了复杂的拓扑排序操作，代码简洁且高效。
2. **拓扑排序**：适用于处理有依赖关系的任务调度问题，能够确保在计算一个任务的最早完成时间时，其所有前置任务都已被计算。
3. **记忆化搜索**：在拓扑排序中，记忆化搜索可以避免重复计算，提高效率。

### 可拓展之处

1. **类似算法套路**：拓扑排序和动态规划的结合可以应用于其他任务调度问题，如项目管理、任务分配等。
2. **同类型题**：可以考虑更复杂的依赖关系，如任务之间存在环，或者任务的执行时间不确定等情况。

### 推荐题目

1. [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)
2. [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)
3. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

### 个人心得总结

- **调试经历**：部分作者提到在调试过程中发现的问题，如初始化错误、边界条件处理不当等，提醒我们在编写代码时要特别注意这些细节。
- **顿悟感想**：通过重新学习拓扑排序，部分作者加深了对该算法的理解，体现了复习和总结的重要性。

---
处理用时：44.41秒
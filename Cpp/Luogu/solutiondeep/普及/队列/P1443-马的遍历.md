# 题目信息

# 马的遍历

## 题目描述

有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。


## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。

## 样例 #1

### 输入

```
3 3 1 1
```

### 输出

```
0    3    2    
3    -1   1    
2    1    4    ```

# AI分析结果

### 综合分析与结论

这些题解大多采用了广度优先搜索（BFS）来解决“马的遍历”问题，核心思路是从起点出发，逐步扩展马可以到达的所有位置，并记录到达每个位置的最少步数。题解之间的差异主要体现在数据结构的选择（如是否使用STL队列、是否使用结构体）、代码的简洁性、以及输出格式的处理上。

大多数题解都较好地实现了BFS的基本框架，但部分题解在代码可读性、优化程度和输出格式处理上存在不足。以下是对部分高质量题解的筛选与总结。

### 所选高质量题解

#### 1. **题解作者：shajjl (赞：1599)**
   - **星级：★★★★★**
   - **关键亮点：**
     - 使用STL的`queue`和`pair`简化了队列的实现，代码简洁且易读。
     - 通过`make_pair`将坐标和步数打包，减少了代码冗余。
     - 输出格式处理得当，使用`printf`的`%-5d`实现左对齐。
   - **个人心得：**
     - 作者提到“带头文件的33行代码还是很短的”，强调了代码简洁的重要性。
   - **核心代码：**
     ```cpp
     queue<pair<int,int>> q;
     q.push(make_pair(x, y));
     while (!q.empty()) {
         int xx = q.front().first, yy = q.front().second;
         q.pop();
         for (int i = 0; i < 8; i++) {
             int u = xx + dx[i], v = yy + dy[i];
             if (u >= 1 && u <= n && v >= 1 && v <= m && !vis[u][v]) {
                 vis[u][v] = true;
                 q.push(make_pair(u, v));
                 f[u][v] = f[xx][yy] + 1;
             }
         }
     }
     ```

#### 2. **题解作者：CXY07 (赞：286)**
   - **星级：★★★★☆**
   - **关键亮点：**
     - 使用结构体`queue_`来存储队列，避免了STL的使用，适合对STL不熟悉的读者。
     - 通过`get`数组记录步数，同时用于判断是否访问过，减少了额外的`vis`数组。
     - 输出格式处理得当，使用`printf`的`%-5d`实现左对齐。
   - **核心代码：**
     ```cpp
     struct queue_ { int x, y; } que[160010];
     while (head < tail) {
         head++;
         for (int i = 0; i < 8; i++) {
             int nx = que[head].x + fx[i], ny = que[head].y + fy[i];
             if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && get[nx][ny] == -1) {
                 tail++;
                 que[tail].x = nx; que[tail].y = ny;
                 get[nx][ny] = get[que[head].x][que[head].y] + 1;
             }
         }
     }
     ```

#### 3. **题解作者：YE110W_No1 (赞：321)**
   - **星级：★★★★☆**
   - **关键亮点：**
     - 使用结构体`xy`来存储坐标，代码结构清晰。
     - 通过`abs(dx[i]) != abs(dy[j])`判断方向，避免了多余的循环。
     - 输出格式处理得当，使用`printf`的`%-5d`实现左对齐。
   - **核心代码：**
     ```cpp
     struct xy { int x, y; } node, Top;
     queue<xy> Q;
     while (!Q.empty()) {
         Top = Q.front(); Q.pop();
         for (int i = 0; i < 4; i++)
             for (int j = 0; j < 4; j++)
                 if (abs(dx[i]) != abs(dy[j])) {
                     int NewX = Top.x + dx[i], NewY = Top.y + dy[j];
                     if (NewX >= 1 && NewX <= n && NewY >= 1 && NewY <= m && b[NewX][NewY]) {
                         node.x = NewX; node.y = NewY;
                         Q.push(node);
                         b[NewX][NewY] = false;
                         a[NewX][NewY] = a[Top.x][Top.y] + 1;
                     }
                 }
     }
     ```

### 最优关键思路与技巧

1. **BFS框架**：从起点出发，逐步扩展所有可能的位置，并记录步数。这是解决此类问题的最优方法。
2. **数据结构选择**：使用`queue`和`pair`可以简化代码，而结构体则适合对STL不熟悉的读者。
3. **输出格式处理**：使用`printf`的`%-5d`可以轻松实现左对齐输出，避免复杂的格式控制。

### 可拓展之处

- **类似问题**：类似的问题包括“骑士旅行”、“迷宫最短路径”等，都可以通过BFS解决。
- **优化思路**：可以考虑双向BFS或A*算法来进一步优化搜索效率。

### 推荐题目

1. **P1443 马的遍历**（本题）
2. **P1135 奇怪的电梯**（BFS应用）
3. **P1162 填涂颜色**（BFS应用）

### 个人心得总结

- **调试经历**：部分题解提到在输出格式上卡了很久，强调了输出格式的重要性。
- **踩坑教训**：部分题解提到忘记标记访问过的点，导致死循环，提醒了BFS中标记访问的重要性。
- **顿悟感想**：通过BFS可以轻松解决最短路径问题，且代码实现相对简单。

---
处理用时：51.47秒
# 题目信息

# 邮递员送信

## 题目描述

有一个邮递员要送东西，邮局在节点 $1$。他总共要送 $n-1$ 样东西，其目的地分别是节点 $2$ 到节点 $n$。由于这个城市的交通比较繁忙，因此所有的道路都是单行的，共有 $m$ 条道路。这个邮递员每次只能带一样东西，并且**运送每件物品过后必须返回邮局**。求送完这 $n-1$ 样东西并且**最终回到邮局**最少需要的时间。

## 说明/提示

对于 $30\%$ 的数据，$1 \leq n \leq 200$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^3$，$1 \leq m \leq 10^5$，$1\leq u,v \leq n$，$1 \leq w \leq 10^4$，输入保证任意两点都能互相到达。

## 样例 #1

### 输入

```
5 10
2 3 5
1 5 5
3 5 6
1 2 8
1 3 8
5 3 4
4 1 8
4 5 3
3 5 6
5 4 2```

### 输出

```
83```

# AI分析结果

### 综合分析与结论

该题目要求邮递员从邮局出发，依次送信到各个目的地并返回邮局，且每次只能带一件物品。核心问题在于如何高效计算从邮局到各个目的地的最短路径，以及从各个目的地返回邮局的最短路径。大多数题解采用了**Dijkstra算法**或**SPFA算法**，并通过**反向建图**来优化计算返回路径的时间复杂度。

### 所选高质量题解

#### 1. 作者：寒鸽儿 (5星)
- **关键亮点**：使用Dijkstra算法，通过反向建图来优化返回路径的计算，代码简洁且高效。
- **个人心得**：通过将反向图的节点编号与原图区分，避免了重复计算，提升了代码的可读性和执行效率。
- **核心代码**：
  ```cpp
  void addedge(int u, int v, int w) {
      ver[tot] = v; wei[tot] = w; nex[tot] = head[u]; head[u] = tot++;
  }
  void dij(int s) {
      for(int i = 1; i <= n << 1; ++i) dis[i] = inf;
      dis[s] = 0;
      q.push(nodeq(s, 0));
      while(!q.empty()) {
          nodeq cur = q.top(); q.pop();
          if(dis[cur.x] < cur.dis) continue;
          for(int i = head[cur.x]; ~i; i = nex[i]) {
              if(dis[ver[i]] > cur.dis + wei[i]) {
                  dis[ver[i]] = cur.dis + wei[i];
                  q.push(nodeq(ver[i], dis[ver[i]]));
              }
          }
      }
  }
  ```

#### 2. 作者：Dog_Two (4星)
- **关键亮点**：通过减少冗余函数，优化了代码结构，提升了可维护性。
- **个人心得**：通过将正反图的Dijkstra算法合并到一个函数中，减少了代码量，降低了调试难度。
- **核心代码**：
  ```cpp
  void Dijkstra(int *dis, vector<int> *road, bool *vis, edge *E, int St) {
      fill(dis+1, dis+n+1, 0x3f3f3f3f);
      fill(vis+1, vis+n+1, false);
      dis[St] = 0;
      q.push((Node){0, St});
      while(!q.empty()) {
          Node x = q.top(); q.pop();
          if(vis[x.u]) continue;
          vis[x.u] = true;
          for(int i = road[x.u].size()-1; i >= 0; --i) {
              int temp = E[road[x.u][i]].to;
              if(dis[temp] > dis[x.u] + E[road[x.u][i]].v) {
                  dis[temp] = dis[x.u] + E[road[x.u][i]].v;
                  q.push((Node){dis[temp], temp});
              }
          }
      }
  }
  ```

#### 3. 作者：Eason_AC (4星)
- **关键亮点**：使用了堆优化的Dijkstra算法，并通过反向图来计算返回路径，代码结构清晰。
- **个人心得**：通过反向图的计算，避免了多次调用Dijkstra算法，提升了效率。
- **核心代码**：
  ```cpp
  void dijkstra(int s) {
      memset(dis, 0x3f, sizeof(dis));
      dis[s] = 0;
      q.push(make_pair(0, s));
      while(!q.empty()) {
          int u = q.top().second; q.pop();
          if(vis[u]) continue;
          vis[u] = true;
          for(int i = head[u]; i; i = edge[i].next) {
              int v = edge[i].to;
              if(dis[v] > dis[u] + edge[i].val) {
                  dis[v] = dis[u] + edge[i].val;
                  q.push(make_pair(-dis[v], v));
              }
          }
      }
  }
  ```

### 最优关键思路与技巧
1. **反向建图**：通过构建反向图，将多源最短路径问题转化为单源最短路径问题，显著降低了时间复杂度。
2. **堆优化Dijkstra**：使用优先队列优化Dijkstra算法，提升了计算效率，尤其适用于大规模数据。
3. **代码复用**：通过将正反图的Dijkstra算法合并到一个函数中，减少了代码冗余，提升了代码的可维护性。

### 可拓展之处
- **同类型题目**：类似的最短路径问题可以通过反向建图来优化，如计算从多个起点到单个终点的最短路径。
- **算法套路**：反向建图的思想可以应用于其他图论问题，如网络流、拓扑排序等。

### 推荐题目
1. [P1342 请柬](https://www.luogu.org/problem/P1342)
2. [P1821 银牛派对](https://www.luogu.org/problem/P1821)
3. [P2984 奶牛回家](https://www.luogu.org/problem/P2984)

### 个人心得总结
- **调试经历**：部分题解提到在调试过程中发现数组开小导致超时，提醒我们在编写代码时要注意数组大小的合理设置。
- **踩坑教训**：使用Floyd算法时，由于时间复杂度较高，容易超时，建议在数据规模较大时优先选择Dijkstra或SPFA算法。
- **顿悟感想**：通过反向建图，将复杂问题简化，体现了图论问题中“逆向思维”的重要性。

---
处理用时：45.14秒
# 题目信息

# 切蛋糕

## 题目描述

今天是小 Z 的生日，同学们为他带来了一块蛋糕。这块蛋糕是一个长方体，被用不同色彩分成了 $n$ 个相同的小块，每小块都有对应的幸运值。

小 Z 作为寿星，自然希望吃到的蛋糕的幸运值总和最大，但小 Z 最多又只能吃 $m(m\le n)$ 小块的蛋糕。

请你帮他从这 $n$ 小块中找出**连续**的 $k(1 \le k\le m)$ 块蛋糕，使得其上的总幸运值最大。

**形式化地**，在数列 $\{p_n\}$ 中，找出一个子段 $[l,r](r-l+1\le m)$，最大化 $\sum\limits_{i=l}^rp_i$。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，有 $1\le n\le100$。
- 对于 $100\%$ 的数据，有 $1\le n\le5\times 10^5$，$|p_i|≤500$。

保证答案的绝对值在 $[0,2^{31}-1]$ 之内。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5```

### 输出

```
9```

## 样例 #2

### 输入

```
6 3
1 -2 3 -4 5 -6```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心是求一个长度不超过 $m$ 的最大子段和，通常可以通过前缀和结合单调队列或线段树等数据结构来优化。题解中大部分作者都采用了单调队列的思路，少数使用了线段树或ST表等数据结构。单调队列的优化思路较为统一，主要是通过维护一个单调递增的队列来快速找到区间内的最小前缀和，从而在 $O(n)$ 的时间复杂度内解决问题。

### 所选高星题解

#### 1. **作者：fanfansann (5星)**
- **关键亮点**：使用单调队列维护前缀和的最小值，避免了单调递减数据的陷阱，代码简洁且高效。
- **个人心得**：作者强调了单调队列的初值问题，指出不赋初值会导致bug，尤其是在第一个值是最大、其余为负的情况下。
- **核心代码**：
  ```cpp
  deque<int>q;
  q.push_back(0); // 赋初值
  for(int i=1;i<=n;i++) {
      while(q.front()+m<i) q.pop_front(); // 越界就pop
      ans=max(ans,sum[i]-sum[q.front()]);
      while(!q.empty()&&sum[q.back()]>=sum[i]) q.pop_back(); // 递减就pop
      q.push_back(i);
  }
  ```
  **实现思想**：通过维护一个单调递增的队列，确保每次都能快速找到区间内的最小前缀和。

#### 2. **作者：kkksc03 (4星)**
- **关键亮点**：详细分析了单调队列的原理，并给出了朴素写法的优化思路，思路清晰。
- **核心代码**：
  ```cpp
  while (l <= r && q[l] < i - m) l++; // 排除不可能决策
  ans = max(ans, sum[i] - sum[q[l]]);
  while (l <= r && sum[q[r]] >= sum[i]) r--; // 排除无用决策
  q[++r] = i; // 插入新决策
  ```
  **实现思想**：通过维护一个单调递增的队列，确保每次都能快速找到区间内的最小前缀和。

#### 3. **作者：fluttersunny (4星)**
- **关键亮点**：详细解释了单调队列的使用场景，并提供了多种数据结构的选择（如线段树、ST表等），思路较为全面。
- **核心代码**：
  ```cpp
  while (head <= tail && q[head] < i - m) head++; // 排除不可能决策
  ans = max(ans, sum[i] - sum[q[head]]);
  while (head <= tail && sum[i] <= sum[q[tail]]) tail--; // 维护单调递增的队列
  q[++tail] = i;
  ```
  **实现思想**：通过维护一个单调递增的队列，确保每次都能快速找到区间内的最小前缀和。

### 最优关键思路与技巧

1. **单调队列优化**：通过维护一个单调递增的队列，快速找到区间内的最小前缀和，从而在 $O(n)$ 的时间复杂度内解决问题。
2. **前缀和的使用**：通过预处理前缀和，可以在 $O(1)$ 时间内计算任意区间的和，避免了重复计算。
3. **初值处理**：在单调队列中赋初值0，避免在第一个值是最大、其余为负的情况下出现错误。

### 可拓展之处

- **类似算法套路**：单调队列不仅适用于最大子段和问题，还可以用于滑动窗口最大值、最小值等问题。
- **数据结构选择**：除了单调队列，线段树、ST表等数据结构也可以用于解决类似问题，尤其是在需要处理更复杂的区间查询时。

### 推荐题目

1. **P1886 滑动窗口**：考察单调队列的基本应用。
2. **P2627 修剪草坪**：考察单调队列在动态规划中的应用。
3. **P2216 理想的正方形**：考察二维单调队列的应用。

### 个人心得总结

- **调试经历**：在单调队列的实现中，初值的处理非常重要，尤其是在数据单调递减的情况下，不赋初值会导致错误。
- **踩坑教训**：单调队列的维护过程中，需要及时排除过时决策，否则会导致计算结果不准确。
- **顿悟感想**：单调队列的核心思想是通过维护一个单调序列，快速排除无用决策，从而优化时间复杂度。

---
处理用时：32.83秒
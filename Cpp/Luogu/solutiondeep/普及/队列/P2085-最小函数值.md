# 题目信息

# 最小函数值

## 题目描述

有 $n$ 个函数，分别为 $F_1,F_2,\dots,F_n$。定义 $F_i(x)=A_ix^2+B_ix+C_i(x\in\mathbb N*)$。给定这些 $A_i$、$B_i$ 和 $C_i$，请求出所有函数的所有函数值中最小的 $m$ 个（如有重复的要输出多个）。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n,m\le10000$，$1 \leq A_i\le10,B_i\le100,C_i\le10^4$。

## 样例 #1

### 输入

```
3 10
4 5 3
3 4 5
1 7 1
```

### 输出

```
9 12 12 19 25 29 31 44 45 54```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效地找到多个二次函数的最小函数值中的前m个。由于函数在正整数域上单调递增，因此可以通过堆（优先队列）来优化查找过程。大多数题解都采用了堆的思路，但实现方式和优化程度有所不同。部分题解还提供了暴力解法、二分查找、随机算法等，但这些方法在时间或空间复杂度上不如堆优化高效。

最优的解法是使用小根堆，首先将每个函数的x=1时的值放入堆中，然后每次取出堆顶的最小值，并将该函数的下一个x值对应的函数值重新放入堆中，重复m次。这种方法的时间复杂度为O(m log n)，能够很好地处理题目中的最大数据规模。

### 所选高星题解

#### 1. 作者：Euler_Pursuer (5星)
**关键亮点**：
- 详细分析了暴力解法的不足，并提出了堆优化的思路。
- 提供了堆的具体实现代码，代码清晰且易于理解。
- 通过图示形象地展示了堆的操作过程，帮助读者更好地理解算法。

**核心代码**：
```cpp
priority_queue<node, vector<node>, greater<node>> q;
for (int i = 1; i <= n; i++) {
    q.push(node(a[i] + b[i] + c[i], i, 1));
}
for (int i = 1; i <= m; i++) {
    node t = q.top(); q.pop();
    cout << t.val << " ";
    q.push(node(a[t.id] * (t.x + 1) * (t.x + 1) + b[t.id] * (t.x + 1) + c[t.id], t.id, t.x + 1));
}
```
**个人心得**：
- 通过堆优化，成功将时间复杂度从O(m^2 n)降低到O(m log n)，极大提升了算法的效率。

#### 2. 作者：yybyyb (5星)
**关键亮点**：
- 使用了优先队列（STL）来实现堆，代码简洁且高效。
- 通过结构体重载运算符，简化了堆的比较操作。
- 代码可读性强，适合初学者学习和使用。

**核心代码**：
```cpp
priority_queue<Node, vector<Node>, greater<Node>> q;
for (int i = 1; i <= n; i++) {
    q.push(Node(a[i] + b[i] + c[i], i, 1));
}
for (int i = 1; i <= m; i++) {
    Node t = q.top(); q.pop();
    cout << t.val << " ";
    q.push(Node(a[t.id] * (t.x + 1) * (t.x + 1) + b[t.id] * (t.x + 1) + c[t.id], t.id, t.x + 1));
}
```
**个人心得**：
- 通过优先队列的灵活使用，大大简化了代码的编写，同时保持了算法的高效性。

#### 3. 作者：DavidW (4星)
**关键亮点**：
- 使用了平板电视（pbds库）来实现堆，进一步优化了性能。
- 代码简洁，适合对STL库有一定了解的读者。
- 通过O3优化，进一步提升了代码的运行速度。

**核心代码**：
```cpp
__gnu_pbds::priority_queue<pair<int, int>, greater<pair<int, int>>, pairing_heap_tag> h;
for (int i = 1; i <= n; i++) {
    h.push(make_pair(a[i] + b[i] + c[i], i));
}
for (int i = 1; i <= m; i++) {
    pair<int, int> tmp = h.top(); h.pop();
    cout << tmp.first << " ";
    h.push(make_pair(a[tmp.second] * (x[tmp.second] + 1) * (x[tmp.second] + 1) + b[tmp.second] * (x[tmp.second] + 1) + c[tmp.second], tmp.second));
}
```
**个人心得**：
- 通过使用pbds库，进一步优化了堆的性能，适合对性能有较高要求的场景。

### 最优关键思路与技巧
1. **堆优化**：使用小根堆来维护当前最小的函数值，每次取出堆顶元素并更新该函数的下一个值，重复m次。
2. **优先队列**：利用STL中的优先队列简化堆的实现，代码简洁且高效。
3. **单调性利用**：由于函数在正整数域上单调递增，可以通过堆来避免不必要的计算，提升算法效率。

### 拓展思路与同类型题
- **同类型题**：类似的问题可以扩展到其他单调递增或递减的函数，或者多个有序序列的合并问题。
- **类似算法套路**：堆优化、优先队列、单调性利用等技巧在其他算法题中也有广泛应用，如最短路径、最小生成树等。

### 推荐题目
1. **P1631 序列合并**：考察多个有序序列的合并问题，可以使用堆优化。
2. **P1886 滑动窗口**：考察单调队列的应用，与堆优化有相似之处。
3. **P3378 堆**：考察堆的基本操作，适合初学者练习堆的实现与应用。

### 个人心得总结
- **调试经历**：在实现堆优化时，需要注意堆的维护和更新操作，确保每次取出和插入的元素都正确。
- **踩坑教训**：暴力解法虽然简单，但在大数据规模下容易超时，必须使用堆等优化手段。
- **顿悟感想**：通过堆优化，不仅提升了算法的效率，也加深了对数据结构和算法的理解。

---
处理用时：49.98秒
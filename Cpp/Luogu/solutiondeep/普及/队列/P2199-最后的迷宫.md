# 题目信息

# 最后的迷宫

## 题目背景

哈利•波特作为三强争霸赛的第四名选手，历尽艰险闯到了最后一关——迷宫。

现在，迷宫里只剩下哈利和塞德里克了，哈利只有在塞德里克前面拿到奖杯，才能赢得比赛。哈利只要能看到奖杯，就可以用飞来咒拿到它，所以，现在的问题是哈利如何能尽早地看到奖杯。


## 题目描述

哈利的视力非常好，他能从迷宫的一端沿直线看到迷宫的另一端（但他只能看八个方向——东北，东，东南，南，西南……），而且他跑得非常快，跑一步（向上、下、左、右移动一格）只需要 $1\text{s}$。但迷宫是不透光的，而且，要烧掉迷宫的墙也不容易，所以哈利决定绕到一个能够看到奖杯的地方。现在，哈利希望你能帮他确定最短需要多长时间才能拿到奖杯。


## 说明/提示

对于 $30\%$ 的数据，有 $N\times M\le100$；

对于 $60\%$ 的数据，有 $N\times M\le1600$；

对于 $100\%$ 的数据，有 $N\times M\le16384$。

询问数据对数不超过 $512$。


## 样例 #1

### 输入

```
3 4
OXXO
XXOO
XOOO
3 2 2 4
3 3 1 1
0 0 0 0
```

### 输出

```
1
Poor Harry
```

# AI分析结果

### 综合分析与结论

本题的核心在于通过BFS（广度优先搜索）找到哈利从起点到能够看到奖杯的最短路径。难点在于如何在迷宫中高效地判断哈利是否能看到奖杯，并且处理大范围的迷宫数据（N×M≤16384）。大多数题解都采用了BFS，但在处理“看到奖杯”的条件时，有不同的优化策略。部分题解通过预处理奖杯的可见区域，减少了BFS过程中的重复判断，提升了效率。

### 所选高星题解

#### 1. 作者：Alanalan (赞：22)
- **星级**：★★★★★
- **关键亮点**：
  - 使用BFS进行最短路径搜索，代码结构清晰。
  - 预处理奖杯的可见区域，减少BFS中的重复判断。
  - 使用二维数组存储迷宫，并通过方向数组简化代码。
- **核心代码**：
  ```cpp
  void bfs(int sx, int sy) {
      for(int i=0;i<n;++i)
          for(int j=0;j<m;++j)
              dis[i][j]=INF;
      q.push(node{sx,sy});
      dis[sx][sy]=0;
      while(!q.empty()) {
          int x=q.front().x;
          int y=q.front().y;
          q.pop();
          for(int i=0;i<4;++i) {
              int xx=x+dx[i];
              int yy=y+dy[i];
              if(ok(xx,yy) && dis[xx][yy]==INF) {
                  dis[xx][yy]=dis[x][y]+1;
                  q.push(node{xx,yy});
              }
          }
      }
  }
  ```
- **个人心得**：预处理奖杯的可见区域是提升效率的关键，避免了在BFS中频繁判断是否能看到奖杯。

#### 2. 作者：_wakeup (赞：15)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用一维数组存储迷宫，避免MLE问题。
  - 通过方向数组简化代码，提升可读性。
  - 在BFS中直接判断是否能看到奖杯，减少预处理步骤。
- **核心代码**：
  ```cpp
  bool look(int stx, int sty) {
      for(int i=0;i<8;++i) {
          int xx=dx[i]+stx;
          int yy=dy[i]+sty;
          while(check(xx,yy)) {
              if(xx==ex&&yy==ey) return 1;
              xx+=dx[i];
              yy+=dy[i];
          }
      }
      return 0;
  }
  ```
- **个人心得**：一维数组的使用是处理大范围数据的关键，虽然代码稍显复杂，但有效避免了内存问题。

#### 3. 作者：2c_s (赞：6)
- **星级**：★★★★☆
- **关键亮点**：
  - 使用BFS进行最短路径搜索，代码简洁。
  - 在BFS中直接判断是否能看到奖杯，减少预处理步骤。
  - 使用方向数组简化代码，提升可读性。
- **核心代码**：
  ```cpp
  bool look(int mx, int my) {
      if(mx==ex&&my==ey) return true;
      for(int i=0;i<8;i++) {
          int ux=mx+dx[i], uy=my+dy[i];
          while(check(ux,uy)&&a[ux][uy]=='O') {
              if(ux==ex&&uy==ey) return true;
              ux+=dx[i], uy+=dy[i];
          }
      }
      return false;
  }
  ```
- **个人心得**：在BFS中直接判断是否能看到奖杯，虽然效率稍低，但代码简洁，适合初学者理解。

### 最优关键思路与技巧

1. **预处理奖杯的可见区域**：通过从奖杯出发，向八个方向遍历，标记所有能看到奖杯的位置，减少BFS中的重复判断。
2. **一维数组存储迷宫**：避免二维数组在大范围数据下的内存问题，提升代码的通用性。
3. **方向数组简化代码**：通过预定义方向数组，简化BFS中的移动和判断逻辑。

### 可拓展之处

- **类似算法套路**：在处理大范围数据时，可以考虑使用一维数组或动态数组来优化内存使用。
- **预处理思想**：在BFS或其他搜索算法中，预处理某些条件（如可见区域）可以显著提升效率。

### 推荐题目

1. **P1443 马的遍历**（BFS经典题，考察最短路径）
2. **P1162 填涂颜色**（BFS应用，考察区域填充）
3. **P1135 奇怪的电梯**（BFS变种，考察状态转移）

### 个人心得总结

- **预处理的重要性**：在处理复杂条件时，预处理可以显著减少搜索过程中的重复计算，提升效率。
- **一维数组的使用**：在处理大范围数据时，一维数组可以有效避免内存问题，虽然代码稍显复杂，但值得掌握。
- **方向数组的简化作用**：通过预定义方向数组，可以简化代码逻辑，提升可读性和可维护性。

---
处理用时：41.49秒
# 题目信息

# 质量检测

## 题目描述

为了检测生产流水线上总共 $N$ 件产品的质量，我们首先给每一件产品打一个分数 $A$ 表示其品质，然后统计前 $M$ 件产品中质量最差的产品的分值 $Q[m] = min\{A_1, A_2, ... A_m\}$，以及第 2 至第 $M + 1$ 件的 $Q[m + 1], Q[m + 2] $... 最后统计第 $N - M + 1$ 至第 $N$ 件的 $Q[n]$。根据 $Q$ 再做进一步评估。

请你尽快求出 $Q$ 序列。


## 说明/提示

[数据范围]

30%的数据，$N \le 1000$

100%的数据，$N \le 100000$

100%的数据，$M \le N, A \le 1 000 000$


## 样例 #1

### 输入

```
10 4
16 5 6 9 5 13 14 20 8 12
```

### 输出

```
5
5
5
5
5
8
8
```

# AI分析结果

### 综合分析与结论

本题的核心是求解滑动窗口的最小值，属于经典的RMQ（Range Minimum Query）问题。题解中主要使用了以下几种算法：
1. **ST表**：通过预处理实现O(1)查询，适合静态区间查询，但预处理时间复杂度为O(nlogn)。
2. **单调队列**：维护一个单调递增的队列，适合滑动窗口问题，时间复杂度为O(n)。
3. **线段树**：支持动态区间查询，但代码量较大，时间复杂度为O(nlogn)。
4. **树状数组**：类似于线段树，但代码更简洁，时间复杂度为O(nlogn)。

从题解质量来看，**单调队列**和**ST表**的实现较为简洁且效率高，适合本题的静态查询需求。**线段树**和**树状数组**虽然也能解决问题，但代码复杂度较高，且本题不需要动态更新，因此不推荐。

### 所选高星题解

#### 1. **单调队列 - My_666 (5星)**
- **关键亮点**：思路清晰，代码简洁，时间复杂度为O(n)，适合滑动窗口问题。
- **个人心得**：作者通过模拟样例详细解释了单调队列的维护过程，帮助读者理解其工作原理。
- **核心代码**：
  ```cpp
  int min_deque() {
      int h = 1, t = 0;
      for (int i = 1; i <= n; i++) {
          while (h <= t && q1[h] + m <= i) h++; // 弹出不在窗口内的元素
          while (h <= t && a[i] < a[q1[t]]) t--; // 维护单调性
          q1[++t] = i; // 新元素入队
          if(i >= m) printf("%d\n", a[q1[h]]); // 输出当前窗口的最小值
      }
  }
  ```

#### 2. **ST表 - JJJJones_Zhu (4星)**
- **关键亮点**：代码结构清晰，预处理和查询逻辑明确，适合静态区间查询。
- **核心代码**：
  ```cpp
  void build() {
      for(int j = 1; j <= 20; ++j) {
          for(int i = 1; i <= M; ++i) {
              if(i + (1 << j) - 1 <= M) {
                  dp[i][j] = min(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);
              }
          }
      }
  }
  ```

#### 3. **单调队列 - dunko (4星)**
- **关键亮点**：代码简洁，使用双端队列实现，适合滑动窗口问题。
- **核心代码**：
  ```cpp
  for(int i = 1; i <= n; i++) {
      while(que.size() && a[i] <= a[que.back()]) que.pop_back(); // 去尾
      while(que.size() && i - que.front() >= m) que.pop_front(); // 去头
      que.push_back(i); // 加入当前的位置
      if(i >= m) printf("%d\n", a[que.front()]); // 输出
  }
  ```

### 最优关键思路与技巧
1. **单调队列**：通过维护一个单调递增的队列，确保队首始终是当前窗口的最小值，适合滑动窗口问题。
2. **ST表**：通过预处理实现O(1)查询，适合静态区间查询，但预处理时间复杂度较高。

### 可拓展之处
- **滑动窗口问题**：单调队列不仅适用于求最小值，还可以用于求最大值、中位数等。
- **区间查询问题**：ST表、线段树、树状数组等数据结构可以用于解决更复杂的区间查询问题。

### 推荐题目
1. **P1886 滑动窗口**：经典的滑动窗口问题，适合练习单调队列。
2. **P3865 ST表**：ST表的模板题，适合练习静态区间查询。
3. **P1816 忠诚**：区间最小值问题，适合练习线段树和树状数组。

### 个人心得总结
- **调试经历**：部分题解提到使用ST表时需要注意预处理的范围，避免数组越界。
- **踩坑教训**：使用单调队列时，需确保队首元素始终在窗口内，否则会导致错误结果。
- **顿悟感想**：单调队列的维护过程类似于贪心算法，通过不断淘汰不可能成为最小值的元素，确保队列的单调性。

---
处理用时：36.11秒
# 题目信息

# 化学1（chem1）- 化学合成

## 题目背景

蒟蒻 HansBug 在化学考场上，挠了无数次的头，可脑子里还是一片空白。

## 题目描述

眼下出现在蒟蒻 HansBug 面前的是一个化学合成题，据他所知，一般答案如下面这样的格式：

![](https://cdn.luogu.com.cn/upload/pic/2223.png) （接下一行）

![](https://cdn.luogu.com.cn/upload/pic/2221.png) 

简单解释下：每种化合物可以通过一步反应生成另一个化合物（将这称作一步反应，设为 $A\rightarrow B$），现在假设每个 $A\rightarrow B$ 中，理论上 $1$ 个单位的 $A$ 都仅可以生成 $1$ 个单位的 $B$。然而实际实验表明，并不存在绝对完全的化学转化，设转化率为 $C$（即 $1$ 个单位 $A$ 实际可以生成 $C$ 个单位的 $B$，$0<C<1$）。

现在蒟蒻 HansBug 的知识体系中有 $N$ 个这样 $A\rightarrow B$ 的转化。然而题目中蒟蒻 HansBug 要由 $1$ 个单位的化合物 $S$ 生成化合物 $T$，可是他脑细胞和 RP 已经消耗殆尽，所以找到最终产量最高的合成路线的艰巨任务就交给你啦！

## 说明/提示

样例 1 和样例 2 中，两条合成路线分别为 $1\rightarrow3$、$1\rightarrow2$、$2\rightarrow3$，产率分别为 $0.8$、$0.9$、$0.9$。

在样例 1 中，有两种可行的路线 $1\rightarrow3$ 和 $1\rightarrow2\rightarrow3$ ，最终产量分别为 $0.8$、$0.9\times0.9=0.81$，故第二条路线更优，产量为 $0.8100$。

样例 2 中，$2$ 只能生成 $3$，$3$ 无法生成别的化合物，故无法生成，蒟蒻 HansBug 只好选择 `orz`。

**【数据范围】**

![](https://cdn.luogu.com.cn/upload/pic/2220.png)


## 样例 #1

### 输入

```
3 3 1 3
1 3 0.8
1 2 0.9
2 3 0.9
```

### 输出

```
0.8100```

## 样例 #2

### 输入

```
3 3 2 1
1 3 0.8
1 2 0.9
2 3 0.9
```

### 输出

```
orz```

# AI分析结果

### 综合分析与结论

本题的核心是求解从化合物 \( S \) 到化合物 \( T \) 的最大转化率，可以抽象为在有向图中寻找从起点到终点的最长路径。由于转化率是乘积关系，且不存在负权，因此可以使用最长路算法。常见的算法包括 Dijkstra、SPFA 等，但由于转化率是乘积关系，Dijkstra 算法需要进行适当修改，而 SPFA 则可以直接应用。

从题解来看，大部分作者选择了 SPFA 算法，因为其实现简单且适用于最长路问题。部分作者尝试了 Dijkstra 算法，但由于数据范围较大，未进行堆优化的 Dijkstra 算法容易超时。因此，SPFA 算法在本问题中更为适用。

### 所选高星题解

#### 1. 作者：XiaoX (5星)
- **关键亮点**：使用堆优化的 Dijkstra 算法，虽然时间复杂度较高，但通过堆优化成功通过了所有测试点。代码清晰，注释详细，适合学习 Dijkstra 算法的变种应用。
- **个人心得**：作者提到“坑点挺多”，说明在实现过程中遇到了一些细节问题，如浮点数处理和初始化等。

```cpp
void dij(int st) {
    for(int i=1;i<=n;i++) d[i]=-1;
    priority_queue<kk>q;
    d[st]=1;q.push(make_pair(1,st));
    while(q.size()){
        int x=q.top().second;q.pop();
        if(v[x]) continue;v[x]=1;
        for(int i=head[x];i;i=e[i].nxt){
            int y=e[i].ver;
            if(d[x]*e[i].w>d[y]){
                d[y]=d[x]*e[i].w;
                q.push(make_pair(d[y],y));
            }
        }
    }
}
```

#### 2. 作者：Diamiko (4星)
- **关键亮点**：直接使用 SPFA 算法求解最长路，代码简洁，思路清晰。通过将最短路模板中的大于号改为小于号，轻松实现了最长路的求解。
- **个人心得**：作者提到“起点一开始距离是1，如果是0的话后面怎么乘都是0”，强调了初始化的关键点。

```cpp
void SPFA() {
    queue<int>q;
    for(int i=1;i<=n;i++) node[i].dis=-0x3f3f3f3f;
    node[s].dis=1;
    node[s].vis=1;
    q.push(s);
    while(q.size()){
        int u=q.front(); q.pop();
        node[u].vis=0;
        for(int e=node[u].head;e;e=edge[e].next){
            int v=edge[e].to;
            if(node[v].dis<node[u].dis*edge[e].len){
                node[v].dis=node[u].dis*edge[e].len;
                if(!node[v].vis){
                    q.push(v);
                    node[v].vis=1;
                }
            }
        }
    }
}
```

#### 3. 作者：幽灵特工 (4星)
- **关键亮点**：详细讲解了 SPFA 算法的实现过程，并提供了 Bellman-Ford 和 Dijkstra 算法的对比分析。代码结构清晰，适合初学者理解 SPFA 算法的原理。
- **个人心得**：作者提到“本题是最长路裸题”，强调了问题的本质。

```cpp
void SPFA() {
    for(int i=1;i<=n;i++) dist[i]=-1;
    dist[s]=1.00;
    q.push(s);
    while(!q.empty()){
        int u=q.front(); q.pop();
        in_queue[u]=0;
        for(int i=0;i<G[u].size();i++){
            int v=e[G[u][i]].to;
            if(dist[v]<dist[u]*e[G[u][i]].w){
                dist[v]=dist[u]*e[G[u][i]].w;
                if(!in_queue[v]){ q.push(v); in_queue[v]=1; }
            }
        }
    }
}
```

### 最优关键思路与技巧
1. **SPFA 算法的适用性**：SPFA 算法在处理最长路问题时非常有效，尤其是当图中不存在负权环时，SPFA 可以高效地求解最长路径。
2. **初始化的关键性**：在最长路问题中，起点的初始化非常重要，通常需要将起点的距离初始化为1，而不是0，否则后续的乘积操作会失效。
3. **浮点数处理**：在处理浮点数时，需要注意精度问题，尤其是在比较和输出时，应使用 `%.4lf` 来保留四位小数。

### 拓展与举一反三
- **类似问题**：可以尝试解决其他类型的最长路径问题，如带权图中的最长路径、有向无环图（DAG）中的最长路径等。
- **算法优化**：可以进一步学习堆优化的 Dijkstra 算法，了解其在处理大规模数据时的优势。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)

这些题目涵盖了最短路径、负环检测等经典问题，适合进一步巩固图论算法知识。

---
处理用时：40.39秒
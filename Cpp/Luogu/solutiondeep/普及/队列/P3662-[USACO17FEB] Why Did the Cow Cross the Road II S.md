# 题目信息

# [USACO17FEB] Why Did the Cow Cross the Road II S

## 题目描述

穿过 Farmer John 农场的长路上有 $N$ 个人行横道，方便地用编号 $1 \ldots N$ 标识（$1 \leq N \leq 100,000$）。为了让奶牛能够通过这些横道过马路，FJ 安装了电子过马路信号灯，当奶牛可以安全过马路时，信号灯会显示绿色的奶牛图标，否则显示红色。不幸的是，一场大雷暴损坏了他的一些信号灯。给定损坏信号灯的列表，请计算 FJ 需要修复的最少信号灯数量，以便存在至少 $K$ 个连续的信号灯正常工作。

## 样例 #1

### 输入

```
10 6 5
2
10
1
5
9```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心问题是在一个长度为 $N$ 的序列中，找到一个长度为 $K$ 的连续子区间，使得该区间内损坏的信号灯数量最少。大多数题解都采用了**前缀和**或**滑动窗口**的思路，时间复杂度均为 $O(N)$，能够高效地解决问题。

#### 最优思路总结：
1. **前缀和**：通过预处理前缀和数组，可以在 $O(1)$ 时间内查询任意区间的损坏信号灯数量，最终通过枚举所有长度为 $K$ 的区间，找到最小值。
2. **滑动窗口**：通过维护一个长度为 $K$ 的窗口，每次移动窗口时，只需更新窗口两端的损坏信号灯数量，避免了重复计算，时间复杂度同样为 $O(N)$。

#### 扩展思路：
- 类似的问题可以通过滑动窗口或前缀和来解决，尤其是在需要频繁查询区间和的情况下。
- 滑动窗口的优化思路可以应用于其他需要维护固定长度区间的场景，如最大子数组和、最小覆盖子串等。

### 所选高星题解

#### 1. 作者：Anguei (5星)
- **关键亮点**：思路清晰，代码简洁，使用了前缀和优化，时间复杂度为 $O(N)$，代码可读性高。
- **核心代码**：
  ```cpp
  int n, k, b, a[N], s[N], ans = -1u / 2;
  int main() {
      n = read(), k = read(), b = read();
      rep(i, 1, b) a[read()] = 1;
      rep(i, 1, n) s[i] = s[i - 1] + a[i];
      rep(i, k, n) ans = std::min(ans, s[i] - s[i - k]);
      println(ans);
  }
  ```
- **实现思想**：通过前缀和数组 `s[i]` 记录前 $i$ 个信号灯中损坏的数量，然后枚举所有长度为 $K$ 的区间，利用前缀和快速计算区间内的损坏信号灯数量，取最小值。

#### 2. 作者：船医 (4星)
- **关键亮点**：使用了滑动窗口的思路，代码清晰，时间复杂度为 $O(N)$，优化了队列的实现。
- **核心代码**：
  ```cpp
  queue <int> q;
  int n, k, b, ans = 0, t;
  bool d[100005];
  int main() {
      cin >> n >> k >> b;
      for(int i = 1; i <= b; i++) {
          cin >> t;
          d[t] = 1;
      }
      for(int i = 1; i <= k; i++) {
          q.push(i);
          if(d[i] == 1) ans++;
      }
      int sum = ans;
      for(int i = k + 1; i <= n; i++) {
          q.push(i);
          if(d[i] == 1) sum++;
          if(d[q.front()]) sum--;
          q.pop();
          ans = min(ans, sum);
      }
      cout << ans;
      return 0;
  }
  ```
- **实现思想**：通过队列维护一个长度为 $K$ 的窗口，每次移动窗口时，更新窗口两端的损坏信号灯数量，避免了重复计算。

#### 3. 作者：zhangyuhan (4星)
- **关键亮点**：思路清晰，使用了前缀和，代码简洁，时间复杂度为 $O(N)$。
- **核心代码**：
  ```cpp
  int light[MAXN], s[MAXN], n, k, b, ans = 1e9;
  int main() {
      cin >> n >> k >> b;
      _for(i, 1, b) {
          int x;
          cin >> x;
          light[x] = 1;
      }
      _for(i, 1, n) s[i] = s[i - 1] + light[i];
      _for(i, k, n) ans = min(ans, s[i] - s[i - k]);
      cout << ans << endl;
      return 0;
  }
  ```
- **实现思想**：通过前缀和数组 `s[i]` 记录前 $i$ 个信号灯中损坏的数量，然后枚举所有长度为 $K$ 的区间，利用前缀和快速计算区间内的损坏信号灯数量，取最小值。

### 推荐题目
1. **P1886 滑动窗口**：考察滑动窗口的基本应用。
2. **P1638 逛画展**：滑动窗口的变种，求最小覆盖区间。
3. **P1714 切蛋糕**：前缀和与滑动窗口的结合，求最大子数组和。

### 个人心得总结
- **调试经历**：部分题解在滑动窗口的实现中，初始化和边界条件处理不当，导致代码出错。例如，滑动窗口的初始化和移动时，需要特别注意窗口的起始和结束位置。
- **顿悟感想**：滑动窗口和前缀和的结合可以大大简化区间查询问题，尤其是在区间长度固定的情况下，滑动窗口的优化效果尤为明显。

---
处理用时：37.18秒
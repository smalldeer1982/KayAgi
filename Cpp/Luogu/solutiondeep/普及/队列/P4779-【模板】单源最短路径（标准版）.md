# 题目信息

# 【模板】单源最短路径（标准版）

## 题目背景

2018 年 7 月 19 日，某位同学在 [NOI Day 1 T1 归程](https://www.luogu.org/problemnew/show/P4768) 一题里非常熟练地使用了一个广为人知的算法求最短路。

然后呢？

$100 \rightarrow 60$；

$\text{Ag} \rightarrow \text{Cu}$；

最终，他因此没能与理想的大学达成契约。

小 F 衷心祝愿大家不再重蹈覆辙。

## 题目描述

给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。

数据保证你能从 $s$ 出发到任意点。

## 说明/提示

样例解释请参考 [数据随机的模板题](https://www.luogu.org/problemnew/show/P3371)。

$1 \leq n \leq 10^5$；

$1 \leq m \leq 2\times 10^5$；

$s = 1$；

$1 \leq u_i, v_i\leq n$；

$0 \leq w_i \leq 10 ^ 9$,

$0 \leq \sum w_i \leq 10 ^ 9$。

本题数据可能会持续更新，但不会重测，望周知。

2018.09.04 数据更新 from @zzq

## 样例 #1

### 输入

```
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4```

### 输出

```
0 2 4 3```

# AI分析结果

### 综合分析与结论

本题解的题目是单源最短路径（标准版），主要考察Dijkstra算法的优化实现。由于数据规模较大（n ≤ 10^5, m ≤ 2×10^5），朴素Dijkstra算法（O(n^2)）无法通过，因此需要使用堆优化（O((n+m)log n)）来提升效率。大部分题解都采用了优先队列（堆）来优化Dijkstra算法，部分题解还探讨了SPFA的优化、链式前向星的实现、以及一些特殊的优化技巧（如堆的维护、优先队列的使用等）。

### 所选高质量题解

#### 1. 题解作者：little_sun (赞：1077)
- **星级**：★★★★★
- **关键亮点**：
  - 详细介绍了Dijkstra算法的原理、流程及正确性证明。
  - 提供了堆优化的实现思路，并解释了为什么Dijkstra不能处理负权边。
  - 代码清晰，注释详细，适合初学者理解。
  - 提供了图解，帮助理解算法的执行过程。
- **个人心得**：作者通过图解和详细的步骤解释，帮助读者更好地理解Dijkstra算法的执行过程，尤其是堆优化的实现细节。

```cpp
struct node {
    int dis, pos;
    bool operator <(const node &x) const {
        return x.dis < dis;
    }
};

priority_queue<node> q;

void dijkstra() {
    dis[s] = 0;
    q.push((node){0, s});
    while (!q.empty()) {
        node tmp = q.top();
        q.pop();
        int x = tmp.pos;
        if (vis[x]) continue;
        vis[x] = 1;
        for (int i = head[x]; i; i = e[i].next) {
            int y = e[i].to;
            if (dis[y] > dis[x] + e[i].dis) {
                dis[y] = dis[x] + e[i].dis;
                if (!vis[y]) q.push((node){dis[y], y});
            }
        }
    }
}
```

#### 2. 题解作者：installb (赞：65)
- **星级**：★★★★☆
- **关键亮点**：
  - 详细介绍了Dijkstra算法的贪心思想及其适用范围。
  - 提供了堆优化的实现，并解释了如何通过优先队列来优化Dijkstra算法。
  - 代码简洁，注释清晰，适合有一定基础的读者。
  - 提供了例题链接，帮助读者进一步练习。
- **个人心得**：作者通过简洁的代码和清晰的注释，帮助读者快速掌握堆优化的Dijkstra算法，适合有一定基础的读者。

```cpp
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;

void dijkstra(int s) {
    dis[s] = 0;
    q.push(make_pair(0, s));
    while (!q.empty()) {
        int u = q.top().second;
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
           

---
处理用时：43.61秒
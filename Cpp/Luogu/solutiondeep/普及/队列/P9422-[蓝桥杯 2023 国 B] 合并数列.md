# 题目信息

# [蓝桥杯 2023 国 B] 合并数列

## 题目描述

小明发现有很多方案可以把一个很大的正整数拆成若干正整数的和。他采取了其中两种方案，分别将他们列为两个数组 $\{a_1, a_2, \cdots a_n\}$ 和 $\{b_1, b_2, \cdots b_m\}$。两个数组的和相同。

定义一次合并操作可以将某数组内相邻的两个数合并为一个新数，新数的值是原来两个数的和。小明想通过若干次合并操作将两个数组变成一模一样，即 $n = m$ 且对于任意下标 $i$ 满足 $a_i = b_i$。请计算至少需要多少次合并操作可以完成小明的目标。

## 说明/提示

### 样例说明

只需要将 $a_2$ 和 $a_3$ 合并，数组 $a$ 变为 $\{1,5,4\}$，即和 $b$ 相同。

### 评测用例规模与约定

 - 对于 $20\%$ 的数据，保证 $n,m \le 10^3$。
 - 对于 $100\%$ 的数据，保证 $n, m \le 10^5$，$0 < a_i, b_i \le 10^5$。
 
第十四届蓝桥杯大赛软件赛决赛 C/C++ 大学 B 组 D 题

## 样例 #1

### 输入

```
4 3
1 2 3 4
1 5 4```

### 输出

```
1```

# AI分析结果

### 综合分析与结论

本题的核心思路是通过双端队列（`deque`）或链表（`list`）来模拟两个数组的合并过程。所有题解都采用了类似的策略：比较两个队列的队首元素，根据大小关系决定合并哪个队列的前两个元素，直到两个队列完全匹配。这种思路的时间复杂度为 O(n+m)，能够高效处理最大规模的数据。

尽管所有题解的思路相似，但在代码实现、数据结构选择和优化程度上存在差异。部分题解使用了 `list` 代替 `deque`，以优化空间和时间复杂度。此外，部分题解在代码可读性和注释方面表现较好，便于理解。

### 所选高星题解

#### 1. 作者：wmrqwq (★★★★★)
- **关键亮点**：代码结构清晰，注释详细，使用了 `deque` 数据结构，逻辑简洁明了。
- **个人心得**：作者在代码中详细注释了每一步的操作，便于理解。通过 `deque` 的 `pop_front` 和 `push_back` 操作，高效实现了合并过程。
- **核心代码**：
```cpp
while(!a1.empty()) {
    if(a1.front()==a2.front()) {
        a1.pop_front();
        a2.pop_front();
    } else if(a1.front()>a2.front()) {
        a2[1]+=a2[0];
        a2.pop_front();
        sum++;
    } else {
        a1[1]+=a1[0];
        a1.pop_front();
        sum++;
    }
}
```

#### 2. 作者：MoonCake2011 (★★★★☆)
- **关键亮点**：使用了 `list` 代替 `deque`，优化了空间和时间复杂度，代码简洁。
- **个人心得**：作者提到 `deque` 的时间和空间复杂度较高，因此选择了 `list`，这种优化在实际应用中可能带来性能提升。
- **核心代码**：
```cpp
while(!q1.empty() && !q2.empty()) {
    if(q1.front()==q2.front()) {
        q1.pop_front();
        q2.pop_front();
    } else if(q1.front()<q2.front()) {
        int u=q1.front(); q1.pop_front();
        int v=q1.front(); q1.pop_front();
        q1.push_front(u+v);
        cnt++;
    } else {
        int u=q2.front(); q2.pop_front();
        int v=q2.front(); q2.pop_front();
        q2.push_front(u+v);
        cnt++;
    }
}
```

#### 3. 作者：封禁用户 (★★★★☆)
- **关键亮点**：代码简洁，逻辑清晰，使用了 `deque`，适合初学者理解。
- **个人心得**：作者通过简单的条件判断和合并操作，实现了题目要求，代码易于理解。
- **核心代码**：
```cpp
while(!x.empty()) {
    if(x.front()==y.front()) {
        x.pop_front();
        y.pop_front();
    } else if(x.front()>y.front()) {
        y[1]+=y[0];
        y.pop_front();
        cnt++;
    } else {
        x[1]+=x[0];
        x.pop_front();
        cnt++;
    }
}
```

### 最优关键思路与技巧

1. **数据结构选择**：使用 `deque` 或 `list` 来模拟队列，方便进行队首元素的比较和合并操作。
2. **合并策略**：通过比较两个队列的队首元素，决定合并哪个队列的前两个元素，直到两个队列完全匹配。
3. **代码优化**：部分题解通过使用 `list` 代替 `deque`，优化了空间和时间复杂度。

### 可拓展之处

- **同类型题目**：类似的问题可以通过队列或栈来解决，例如字符串匹配、序列合并等。
- **算法套路**：这类问题通常涉及贪心算法或双指针技巧，通过局部最优解达到全局最优。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1441 合并果子](https://www.luogu.com.cn/problem/P1441)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

这些题目考察了队列、贪心算法和数据结构的使用，与本题有相似的知识点。

---
处理用时：29.17秒
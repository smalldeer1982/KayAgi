# 题目信息

# queue

## 题目背景

你说的对，但是舞萌 DX 是一款后面忘了。

## 题目描述

**补充说明：这里的排队和传统的排队有出入。正在游玩的人为队列的前两位，所以正在游玩视为正在排队。**

机厅里有一台游戏机，每次可供最多两人同时游玩。但是来玩的人显然不止两个！这个时候他们就需要排队了，而你需要写一个程序维护这个队列，并在他人游玩结束后通知接下来上场的人。在整个过程中，有以下几种事件可能发生：

- `start`：一局游戏开始。若这不是第一局游戏，则上一局的参与者**在这一局游戏开始前一瞬间**按照原本的顺序回到队尾。此时你应该按在队列中的顺序输出这一局上场的人的名字（正常来讲是队列前两位或者唯一一个人），若有两个则以空格分割。若这一局无人上场，则输出 `Error` 并忽略这条事件。

- `arrive x`：$x$ 到达机厅并且将自己加入队尾，此时 $x$ 不应该在排队，否则输出 `Error` 并忽略这条事件。若该事件成功执行则输出 `OK`。

- `leave x`：$x$ 离开机厅并离开队列。此时 $x$ 应该在排队但不应该在游玩，否则输出 `Error` 并忽略这条事件。若该事件成功执行则输出 `OK`。

你需要维护队列信息，并输出上述事件中要求的输出。

## 说明/提示

**【样例说明】**

样例 $1$ 中发生了如下的事件：

- 第一次 `start` 时队列并没有任何人，输出 `Error`。
- `A` 随即加入队列。
- 第二次 `start` 时仅有 `A` 一个人，所以输出 `A`。
- `B, C, D` 随即依次加入队列。
- 第三次 `start` 时 `B, C` 上场。
- `C` 试图离开，但是他在游玩。所以输出 `Error`。
- `D` 成功离开。
- 第四次 `start` 时 `A, B` 上场。
- `A` 试图加入队列，但是他已经在队列中。输出 `Error`。
- `D` 重新加入队列。
- `E` 试图离开，但是他根本不在排队，输出 `Error`。
- 第五次 `start` 时 `C, D` 上场。

样例 $2$ 中，`A, B, C` 依次入队，操作合法，输出三个 `OK`。

**【数据范围】**

对于 $20\%$ 的数据，保证 $n=1$。

对于 $40\%$ 的数据，保证 $n\le 2000$。

对于另外 $20\%$ 的数据，保证没有 `leave` 操作。

对于另外 $20\%$ 的数据，人名只有可能是单个大写字母。

对于 $100\%$ 的数据，保证 $1 \le n\le 10^5$，人名仅含有大小写字母且长度不超过 $10$。

**本题输入输出量较大，请注意使用合理的输入输出方式。**

## 样例 #1

### 输入

```
14
start
arrive A
start
arrive B
arrive C
arrive D
start
leave C
leave D
start
arrive A
arrive D
leave E
start```

### 输出

```
Error
OK
A
OK
OK
OK
B C
Error
OK
A B
Error
OK
Error
C D```

## 样例 #2

### 输入

```
3
arrive A
arrive B
arrive C```

### 输出

```
OK
OK
OK```

# AI分析结果

### 综合分析与结论

本题的核心是模拟一个队列，支持 `start`、`arrive` 和 `leave` 三种操作。难点在于如何高效地维护队列，特别是在 `leave` 操作中删除任意位置的元素。大多数题解使用了 `list`、`set`、`map` 等数据结构来优化操作的时间复杂度。其中，`list` 支持 $O(1)$ 的插入和删除，而 `map` 或 `set` 则用于快速查找元素是否在队列中。部分题解还引入了时间戳或计数器来处理重复加入队列的情况。

### 所选高星题解

#### 1. **作者：CleverRaccoon (赞：14)**
- **星级：★★★★★**
- **关键亮点：**
  - 使用 `list` 和 `unordered_map` 维护队列，支持 $O(1)$ 的插入和删除。
  - 通过 `unordered_map` 记录每个元素在 `list` 中的迭代器，实现快速查找和删除。
  - 代码结构清晰，逻辑简洁，易于理解。
- **个人心得：**
  - 使用 `list` 而不是 `queue`，因为 `queue` 不支持删除任意位置的元素。
  - 通过 `unordered_map` 记录迭代器，避免了遍历 `list` 的开销。

**核心代码片段：**
```cpp
list<string> q;
unordered_map<string, list<string>::iterator> um;

void arrive(string s) {
    q.push_back(s);
    um[s] = --q.end();
}

void leave(string s) {
    q.erase(um[s]);
    um.erase(s);
}
```

#### 2. **作者：Register_int (赞：21)**
- **星级：★★★★☆**
- **关键亮点：**
  - 使用 `set` 和 `map` 维护队列，支持 $O(\log n)$ 的插入、删除和查找。
  - 通过 `map` 记录每个元素的编号，确保队列有序。
  - 代码结构清晰，逻辑严谨。
- **个人心得：**
  - 使用 `set` 维护队列的顺序，通过 `map` 记录元素的编号，确保队列的有序性。

**核心代码片段：**
```cpp
set<node> q;
map<string, int> inq;

bool try_insert(string s) {
    if (inq[s]) return false;
    int x = q.empty() ? 0 : prev(q.end())->id;
    q.insert({s, inq[s] = x + 1});
    return true;
}
```

#### 3. **作者：Flanksy (赞：4)**
- **星级：★★★★☆**
- **关键亮点：**
  - 使用 `list` 和 `unordered_map` 维护队列，支持 $O(1)$ 的插入和删除。
  - 通过 `unordered_map` 记录每个元素的状态，确保操作的合法性。
  - 代码简洁，逻辑清晰。
- **个人心得：**
  - 使用 `list` 和 `unordered_map` 结合，避免了遍历队列的开销，提升了效率。

**核心代码片段：**
```cpp
list<string> q;
unordered_map<string, bool> on;

void arrive(string s) {
    if (on[s]) return;
    q.push_back(s);
    on[s] = true;
}
```

### 最优关键思路与技巧

1. **数据结构选择：** 使用 `list` 维护队列，支持 $O(1)$ 的插入和删除操作。`unordered_map` 用于快速查找元素是否在队列中。
2. **迭代器记录：** 通过 `unordered_map` 记录每个元素在 `list` 中的迭代器，避免遍历队列的开销。
3. **时间戳与计数器：** 部分题解使用时间戳或计数器来处理重复加入队列的情况，确保队列中的元素是最新的。

### 可拓展之处

- **类似题目：** 本题可以拓展到其他需要维护队列并支持删除任意元素的场景，如任务调度、事件处理等。
- **算法套路：** 使用 `list` 和 `unordered_map` 结合的方式，可以应用于其他需要高效插入、删除和查找的场景。

### 推荐相似题目

1. **P1886 滑动窗口**（[题目链接](https://www.luogu.com.cn/problem/P1886)）
2. **P1440 求m区间内的最小值**（[题目链接](https://www.luogu.com.cn/problem/P1440)）
3. **P1090 合并果子**（[题目链接](https://www.luogu.com.cn/problem/P1090)）

### 个人心得总结

- **调试经历：** 部分题解提到在调试过程中发现 `queue` 不支持删除任意位置的元素，最终选择 `list` 作为替代。
- **踩坑教训：** 在处理 `leave` 操作时，直接遍历队列会导致超时，通过 `unordered_map` 记录迭代器可以有效避免这一问题。
- **顿悟感想：** 通过合理选择数据结构和优化查找方式，可以大幅提升代码的效率。

---
处理用时：42.59秒
# 题目信息

# 【模板】AC 自动机

## 题目背景

本题原为“AC 自动机（二次加强版）”。完成本题前可以先完成 [AC 自动机（简单版）](https://www.luogu.com.cn/problem/P3808) 和 [AC 自动机（简单版 II）](https://www.luogu.com.cn/problem/P3796) 两道题，为 AC 自动机更简单的应用。

## 题目描述

给你一个文本串 $S$ 和 $n$ 个模式串 $T_{1 \sim n}$，请你分别求出每个模式串 $T_i$ 在 $S$ 中出现的次数。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 2 \times {10}^5$，$T_{1 \sim n}$ 的长度总和不超过 $2 \times {10}^5$，$S$ 的长度不超过 $2 \times {10}^6$。

## 样例 #1

### 输入

```
5
a
bb
aa
abaa
abaaa
abaaabaa
```

### 输出

```
6
0
3
2
1
```

# AI分析结果



---

## 算法分类
AC 自动机 + 拓扑排序优化

---

## 题解思路与算法要点

### 核心难点与解决方案
1. **暴力跳 fail 的时间复杂度问题**  
   原始 AC 自动机在文本匹配时需要暴力跳 fail 链统计出现次数，最坏时间复杂度为 $O(\text{模式串总长} \times \text{文本串长度})$。  
   **优化思路**：将 fail 链视为树形结构，通过拓扑排序或 DFS 后序统一传递匹配次数，时间复杂度优化至 $O(\text{模式串总长} + \text{文本串长度})$。

2. **重复模式串的处理**  
   通过 `Map` 数组或 `flag` 链表记录每个模式串在 Trie 中的终止节点，避免重复计算。

3. **可视化关键点**  
   - **Fail 树构建**：用颜色高亮 fail 边连接关系，动态展示树形结构的生成过程。  
   - **拓扑排序传递**：以自底向上的动画演示次数累加过程，用不同颜色区分已处理和待处理节点。

---

## 题解评分（≥4星）

### 1. hyfhaha（5星）
- **亮点**：首次提出拓扑排序优化思路，代码中通过 `in` 数组统计入度，队列实现拓扑排序。
- **关键代码**：
  ```cpp
  void topu() {
      for(int i=1;i<=cnt;++i) if(in[i]==0) q.push(i);
      while(!q.empty()) {
          int u = q.front(); q.pop();
          vis[trie[u].flag] = trie[u].ans; // 更新答案
          trie[trie[u].fail].ans += trie[u].ans; // 传递次数
          if(--in[trie[u].fail] == 0) q.push(trie[u].fail);
      }
  }
  ```

### 2. ouuan（5星）
- **亮点**：从自动机理论角度解析 AC 自动机本质，使用邻接表建 fail 树并通过 DFS 统计子树和。
- **关键代码**：
  ```cpp
  void dfs(int u) {
      for (int i = head[u]; i; i = nxt[i]) {
          dfs(to[i]);
          siz[u] += siz[to[i]]; // 子树和累加
      }
  }
  ```

### 3. August_Light（4.5星）
- **亮点**：完整展示 AC 自动机五要素和拓扑排序优化流程，代码中通过 lambda 表达式实现 DFS。
- **关键代码**：
  ```cpp
  auto dfs = [&](int u, auto&& self) -> void {
      for (auto v : G[u]) { self(v, self); sum[u] += sum[v]; }
  };
  dfs(0, dfs); // 后序遍历统计
  ```

---

## 最优思路与技巧提炼

### 关键优化步骤
1. **拓扑排序传递次数**  
   - 在匹配文本时仅记录每个节点的访问次数 `ans[u]`。  
   - 按 fail 树的拓扑序（从叶子到根）将子节点次数累加到父节点：`ans[fail[u]] += ans[u]`。

2. **Fail 树的邻接表存储**  
   - 建自动机时记录 `fail[u]` 的入度 `in[fail[u]]++`，拓扑排序时仅处理入度为 0 的节点。

3. **重复模式串处理**  
   - 使用 `Map` 数组或哈希表将重复模式串映射到同一终止节点，避免重复统计。

---

## 类似题目推荐
1. [P3808【模板】AC 自动机（简单版）](https://www.luogu.com.cn/problem/P3808)  
2. [P3796【模板】AC 自动机（加强版）](https://www.luogu.com.cn/problem/P3796)  
3. [P2444 [POI2000] 病毒](https://www.luogu.com.cn/problem/P2444)

---

## 可视化与算法演示

### 动画设计方案
1. **Trie 树与 Fail 边构建**  
   - **颜色标记**：绿色表示当前处理的 Trie 节点，红色表示 fail 边指向的节点。  
   - **动态效果**：逐步绘制 Trie 树的分支，fail 边以虚线动画连接。

2. **文本匹配过程**  
   - **高亮路径**：文本字符逐个输入，当前 Trie 节点以蓝色闪烁显示。  
   - **计数器更新**：匹配到的节点 `ans[u]` 数值实时增加，右侧面板同步显示。

3. **拓扑排序传递**  
   - **队列可视化**：左侧显示拓扑队列，节点按入度 0 的顺序入队。  
   - **颜色渐变**：已处理的节点变为灰色，正在处理的节点变为橙色，父节点在更新时闪烁黄色。

4. **复古像素风格（示例）**  
   ```javascript
   // Canvas 绘制代码片段（伪代码）
   function drawNode(x, y, count, color) {
       ctx.fillStyle = color; // 节点颜色
       ctx.fillRect(x*50, y*50, 40, 40); // 像素方块
       ctx.fillStyle = 'white';
       ctx.fillText(count, x*50 + 15, y*50 + 25); // 显示计数器
   }
   ```

---

## 个人心得摘录
- **hyfhaha**：  
  > “暴力跳 fail 的时间复杂度在极端数据下会爆炸，拓扑排序优化让每个节点只处理一次，这才是真正的线性复杂度。”  
- **ouuan**：  
  > “AC 自动机本质是确定有限状态自动机，理解这一点后，fail 树的子树和统计变得非常自然。”  

---

## 核心代码实现
```cpp
// 拓扑排序优化核心代码（hyfhaha 题解节选）
void query(char* s) {
    int u = 1, len = strlen(s);
    for (int i = 0; i < len; ++i) {
        u = trie[u].son[s[i]-'a'];
        trie[u].ans++; // 直接标记当前节点
    }
}

void topu() {
    queue<int> q;
    for (int i = 1; i <= cnt; ++i)
        if (in[i] == 0) q.push(i);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        vis[trie[u].flag] = trie[u].ans; // 更新答案数组
        int v = trie[u].fail;
        trie[v].ans += trie[u].ans; // 传递到 fail 节点
        if (--in[v] == 0) q.push(v);
    }
}
```

---
处理用时：76.10秒
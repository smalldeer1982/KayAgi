# 题目信息

# [NOI2014] 动物园

## 题目描述

近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。

某天，园长给动物们讲解 KMP 算法。

园长：“对于一个字符串 $S$，它的长度为 $L$。我们可以在 $O(L)$ 的时间内，求出一个名为 $\mathrm{next}$ 的数组。有谁预习了 $\mathrm{next}$ 数组的含义吗？”

熊猫：“对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作 $\mathrm{next}[i]$。”

园长：“非常好！那你能举个例子吗？”

熊猫：“例 $S$ 为 $\verb!abcababc!$，则 $\mathrm{next}[5]=2$。因为$S$的前$5$个字符为 $\verb!abcab!$，$\verb!ab!$ 既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出 $\mathrm{next}[1] = \mathrm{next}[2] = \mathrm{next}[3] = 0$，$\mathrm{next}[4] = \mathrm{next}[6] = 1$，$\mathrm{next}[7] = 2$，$\mathrm{next}[8] = 3$。”

园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在 $O(L)$ 的时间内求出 $\mathrm{next}$ 数组。

下课前，园长提出了一个问题：“KMP 算法只能求出 $\mathrm{next}$ 数组。我现在希望求出一个更强大 $\mathrm{num}$ 数组一一对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $\mathrm{num}[i]$。例如 $S$ 为 $\verb!aaaaa!$，则 $\mathrm{num}[4] = 2$。这是因为$S$的前 $4$ 个字符为 $\verb!aaaa!$，其中 $\verb!a!$ 和 $\verb!aa!$ 都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而 $\verb!aaa!$ 虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，$\mathrm{num}[1] = 0,\mathrm{num}[2] = \mathrm{num}[3] = 1,\mathrm{num}[5] = 2$。”

最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出$\mathrm{num}$数组呢？

特别地，为了避免大量的输出，你不需要输出 $\mathrm{num}[i]$ 分别是多少，你只需要输出所有 $(\mathrm{num}[i]+1)$ 的乘积，对 $10^9 + 7$ 取模的结果即可。


## 说明/提示

测试点编号| 约定
-|-  
1| $n \le 5, L \le 50$  
2| $n \le 5, L \le 200$  
3| $n \le 5, L \le 200$  
4| $n \le 5, L \le 10,000$  
5| $n \le 5, L \le 10,000$  
6| $n \le 5, L \le 100,000$  
7| $n \le 5, L \le 200,000$   
8| $n \le 5, L \le 500,000$  
9| $n \le 5, L \le 1,000,000$  
10| $n \le 5, L \le 1,000,000$  


## 样例 #1

### 输入

```
3
aaaaa
ab
abcababc```

### 输出

```
36
1
32 ```

# AI分析结果



## 算法分类
KMP算法、前缀函数优化

---

## 题解思路与算法要点

### 核心思路
1. **两次KMP遍历**：首次计算`next`数组及公共前后缀数量，第二次处理不重叠条件。
2. **Fail树特性**：利用`next`数组构建的树形结构，快速统计合法前后缀数量。
3. **指针跳转优化**：在第二次遍历时维护指针`j`，保证其始终满足`j ≤ i/2`。

### 解决难点
1. **重叠判断**：通过动态调整指针`j`的位置，确保公共前后缀不重叠。
2. **线性复杂度**：通过继承前次遍历的`j`值，避免暴力跳转带来的平方复杂度。
3. **乘积计算优化**：直接在跳转过程中累乘结果，避免显式存储`num`数组。

### 关键步骤
1. **第一次遍历**：构建`next`数组，同时计算不考虑重叠的公共前后缀数量`num[i] = num[next[i]] + 1`。
2. **第二次遍历**：在匹配过程中维护指针`j`，当`j > i/2`时跳转`j = next[j]`，最终累乘`num[j] + 1`。

---

## 题解评分 (≥4星)

1. **Orion545 (5星)**
   - 亮点：引入Fail树概念，深度解释KMP自动机特性，代码简洁高效。
   - 核心代码：双重遍历维护指针，直接累乘结果。
   ```cpp
   for(int i=1;i<n;i++){ //求解num
       while(j&&(a[i]!=a[j])) j=fail[j];
       j+=(a[i]==a[j]);
       while((j<<1)>(i+1)) j=fail[j];
       cnt=(cnt*(ans[j]+1))%MOD;
   }
   ```

2. **nofind (4.5星)**
   - 亮点：清晰分离`next`与`num`计算，代码逻辑分层明确。
   - 核心技巧：通过`num[i] = num[next[i]] +1`递推统计总数。

3. **WjNaG (4星)**
   - 亮点：强调初始化注意事项，提供完整代码模板。
   - 调试心得：指出`memset`对字符数组的潜在风险，具有实践价值。

---

## 最优思路提炼

### 关键技巧
- **双指针跳转**：在第二次遍历中复用KMP匹配过程的`j`指针，通过`j = next[j]`快速缩小范围。
- **乘积累乘优化**：在跳转过程中直接计算乘积，避免存储中间结果数组。
- **Fail树深度应用**：利用`next`数组形成的树形结构特性，将问题转化为树深统计。

### 代码实现要点
```cpp
// 第一次遍历：计算next及num
for(int i=1; i<n; i++){
    while(j && s[i] != s[j]) j = next[j];
    if(s[i] == s[j]) j++;
    next[i+1] = j;
    num[i+1] = num[j] + 1;
}

// 第二次遍历：处理不重叠条件
j = 0;
long long ans = 1;
for(int i=1; i<n; i++){
    while(j && s[i] != s[j]) j = next[j];
    if(s[i] == s[j]) j++;
    while(2*j > i+1) j = next[j];
    ans = ans * (num[j] + 1) % MOD;
}
```

---

## 相似题目推荐
1. **P3375** - KMP模板题（巩固前缀函数基础）
2. **P3449** - 利用前缀函数求最短回文拼接（扩展应用场景）
3. **P5829** - 失配树应用（深化树形结构理解）

---

## 可视化设计

### 算法过程动画
1. **像素风格演示**：
   - **颜色标记**：
     - 红色：当前处理的字符位置`i`
     - 绿色：指针`j`的当前位置
     - 黄色：`next`跳转路径
   - **网格布局**：将字符串显示为像素块，每个字符对应16x16像素方块。
   - **指针轨迹**：用箭头动态展示`j`的跳转过程。

2. **交互控制**：
   - **步进执行**：空格键单步执行算法步骤。
   - **速度调节**：滑块控制动画速度（100ms~1s/步）。
   - **自动模式**：AI自动运行，展示完整解题流程。

### 复古音效设计
- **按键音**：8-bit风格短音效（跳转、匹配成功）。
- **背景音乐**：FC经典游戏循环BGM。
- **状态提示音**：
  - 匹配成功：高音"哔"声
  - 跳转发生：低音"嘟"声
  - 结果更新：金币收集音效

---

## 代码实现（核心片段）
```javascript
// 伪代码：KMP可视化核心逻辑
function visualizeKMP(s) {
    let next = [], num = [], j = 0;
    // 构建next数组动画
    for (let i = 1; i < s.length; i++) {
        drawHighlight(i, j, 'red'); // 高亮当前比较位置
        while (j > 0 && s[i] !== s[j]) {
            j = next[j];
            drawJump(j); // 显示指针跳转
        }
        if (s[i] === s[j]) j++;
        next[i+1] = j;
        num[i+1] = num[j] + 1;
        playSound('blip'); // 匹配成功音效
    }
    
    // 处理不重叠条件动画
    j = 0;
    for (let i = 1; i < s.length; i++) {
        while (j > 0 && s[i] !== s[j]) {
            j = next[j];
            drawJump(j);
        }
        if (s[i] === s[j]) j++;
        while (2*j > i+1) {
            j = next[j];
            drawJump(j);
        }
        updateResult(num[j] + 1); // 显示乘积更新
    }
}
```

---
处理用时：81.64秒
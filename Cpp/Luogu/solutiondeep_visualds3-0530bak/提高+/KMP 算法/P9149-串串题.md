# 题目信息

# 串串题

## 题目描述

给定长度分别为 $n,m$ 的整数序列 $A,B$ 和常数 $W,d$，序列从 $1$ 开始标号，保证 $A_i,B_i \in [1,W]$。

容易发现，我们有 $\binom{W}{d}$ 种方案选择 $[1,W]$ 中的 $d$ 个互不相同的整数。

对于每一种选择的方案，我们删去 $A$ 中出现的对应的 $d$ 种整数，令此时序列 $B$ 在序列 $A$ 中的出现次数为这次选择方案的权值。

你需要求所有的选择方案的权值和，对 ${10}^9+7$ 取模。

若对题意有疑问，请阅读样例及样例解释。

注：$\binom{a}{b}$ 表示组合数，含义为在 $a$ 个物品中**无序**地选择出 $b$ 个物品的方案数。

**请注意：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

## 说明/提示

**【样例解释】**

在样例的第一组数据中：

1. 如果我们选择删去 $A$ 中的字符 $1$，$A$ 将变为 $\{2\}$，此时 $B$ 在 $A$ 中的出现次数为 $0$。
1. 如果我们选择删去 $A$ 中的字符 $2$，$A$ 将变为 $\{1,1,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $2$。
1. 如果我们选择删去 $A$ 中的字符 $3$，$A$ 将变为 $\{1,1,2,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $1$。

因此，第一组数据的答案为 $0+2+1=3$。

**再次提醒：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

---

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n,m,W \le {10}^6$，$1 \le d, A_i, B_j \le W$，$1 \le T \le 5$。

**本题采用捆绑测试且开启子任务依赖！**

| 子任务 | $n \le$ | $m \le$ | $W \le$ | 特殊性质 | 分数 | 依赖 |
| - | - | - | - | - | - | - |
| 1 | $10$ | $10$ | $5$ | | $10$ | \ |
| 2 | $1000$ | $1000$ | $5$ | | $20$ | 子任务 1 |
| 3 |  | | | A | $15$ | \ |
| 4 |  | | | B | $25$ | \ |
| 5 | | | | | $30$ | 子任务 1、2、3、4 |

特殊性质 A：保证 $d=1$。

特殊性质 B：令 $c$ 表示仅在序列 $A$ 中出现，而不在序列 $B$ 中出现的数字总数。保证 $c \le 5$。

## 样例 #1

### 输入

```
2
4 2 3 1
1 1 2 1
1 1
8 3 4 1
1 2 3 1 2 3 1 2
1 2 1
```

### 输出

```
3
2
```

# AI分析结果



---

### 算法分类
**组合数学 + 字符串匹配 (KMP)**

---

### 题解思路与算法要点

#### **核心思路**
1. **关键数与非关键数**：将出现在B中的数称为“关键数”，其余为“非关键数”。删除方案只能选非关键数。
2. **预处理A序列**：提取A中的关键数形成新序列C，此时B在A中的出现等价于B在C中的匹配。
3. **KMP匹配**：找到C中所有与B匹配的子区间，每个匹配对应原A中的一个区间。
4. **双指针统计**：对每个匹配区间，统计其中包含的非关键数的种类数t，贡献为组合数C(c-t, d-t)，其中c是非关键数总种类数。

#### **解决难点**
1. **如何高效匹配B的位置**：使用KMP算法在C中快速找到所有B的匹配区间。
2. **非关键数统计优化**：通过滑动窗口（双指针）维护当前区间内的非关键数种类数，避免重复遍历。

#### **关键变量与数据结构**
- `vis[]`：标记B中的关键数。
- `p[]`：记录A中关键数的原始位置。
- `cnt[]`：滑动窗口内的非关键数出现次数统计。
- `阶乘与逆元`：预处理组合数计算。

---

### 题解评分（≥4星）

1. **Demeanor_Roy（4.5星）**  
   - **亮点**：代码清晰，双指针与KMP结合紧密，组合数预处理高效。  
   - **关键代码**：滑动窗口维护区间非关键数种类数，KMP匹配后直接计算贡献。

2. **离散小波变换°（4星）**  
   - **亮点**：理论推导详细，组合数公式清晰，滑动窗口与桶数组结合。  
   - **优化**：线性预处理阶乘逆元，避免重复计算。

3. **柳易辰（4星）**  
   - **亮点**：图文结合解释匹配过程，代码中桶数组动态维护种类数。  
   - **心得**：强调清空临时数组的重要性，避免测试用例间干扰。

---

### 最优思路提炼

1. **关键数提取与匹配**：  
   将A中关键数提取为C，B的匹配问题转化为C的子序列匹配问题，时间复杂度从O(nm)降为O(n+m)。

2. **滑动窗口维护统计量**：  
   对于每个匹配区间，用双指针维护其对应的原A区间，动态统计非关键数种类数，避免暴力枚举。

3. **组合数快速计算**：  
   预处理阶乘和逆元，公式推导贡献为C(c-t, d-t)，其中c是非关键数总种类数，t为区间内必须删除的种类数。

---

### 类似题目推荐

1. **P3375 【模板】KMP字符串匹配**  
   - 直接应用KMP算法，理解匹配过程。

2. **P1496 滑动窗口 /【模板】单调队列**  
   - 滑动窗口维护区间统计量。

3. **P3811 【模板】乘法逆元**  
   - 预处理逆元加速组合数计算。

---

### 可视化设计思路

#### **动画演示**
1. **关键数提取**：  
   - A序列中关键数被高亮为绿色，非关键数灰色。提取后形成新序列C，显示为绿色方块组成的链条。
2. **KMP匹配过程**：  
   - B序列在C上滑动，匹配成功时显示红色边框，对应原A区间用红色框标记。
3. **滑动窗口统计**：  
   - 原A区间内的非关键数被标记为黄色，统计种类数t，右侧显示公式C(c-t, d-t)的计算结果。

#### **复古像素风格**
- **颜色方案**：绿色（关键数）、黄色（非关键数）、红色（匹配成功区间）、灰色（无效元素）。
- **音效**：匹配成功时播放“叮”声，滑动窗口移动时播放“滴答”声，计算贡献时播放金币音效。

#### **交互设计**
- **控制面板**：可调整动画速度，单步执行KMP匹配过程，查看当前窗口统计值。
- **自动演示**：AI自动运行，展示从提取关键数到计算贡献的全流程。

---

### 核心代码片段

```cpp
// KMP预处理next数组
for (int i=2,j=0; i<=m; i++){
    while(j && b[i]!=b[j+1]) j=nx[j];
    if(b[i]==b[j+1]) j++;
    nx[i] = j;
}

// 滑动窗口统计非关键数种类数
int l=1, r=0, o=0;
for (int i=1,j=0; i<=L; i++){
    // 扩展右边界
    while(r < p[i]){
        r++;
        if(!vis[a[r]]){
            if(++cnt[a[r]] == 1) o++;
        }
    }
    // 收缩左边界
    if(i >= m){
        while(l < p[i-m+1]){
            if(!vis[a[l]]){
                if(--cnt[a[l]] == 0) o--;
            }
            l++;
        }
    }
    // KMP匹配成功则计算贡献
    if(j == m){
        ans = (ans + C(c - o, d - o)) % mod;
    }
}
```

---

### 个人心得摘录

> **调试教训**：在滑动窗口移动时，需确保先扩展右边界再收缩左边界，否则可能漏掉部分非关键数的统计。  
> **组合数边界**：当`d < t`时贡献为0，需特判避免计算负数组合数。  
> **清空状态**：多测试用例时，务必清空`vis[]`和`cnt[]`数组，防止数据污染。

---

通过上述分析，结合KMP与组合数学，问题转化为高效匹配与区间统计，最终实现线性时间复杂度的高效解法。

---
处理用时：85.38秒
# 题目信息

# [eJOI 2020] Fountain (Day1)

## 题目描述

大家都知道喷泉吧？现在有一个喷泉由 $N$ 个圆盘组成，从上到下以此编号为 $1 \sim N$，第 $i$ 个喷泉的直径为 $D_i$，容量为 $C_i$，当一个圆盘里的水大于了这个圆盘的容量，那么水就会溢出往下流，直到流入半径大于这个圆盘的圆盘里。如果下面没有满足要求的圆盘，水就会流到喷泉下的水池里。

现在给定 $Q$ 组询问，每一组询问这么描述：

- 向第 $R_i$ 个圆盘里倒入 $V_i$ 的水，求水最后会流到哪一个圆盘停止。

如果最终流入了水池里，那么输出 $0$。

**注意，每个询问互不影响。**

## 说明/提示

#### 样例 1 解释

前两个询问的解释如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/64e7acuq.png)

因为每个询问互不影响，对于第三个询问，第 $5$ 个圆盘里的水不会溢出。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（30 pts）：$N \le 1000$，$Q \le 2000$。
- Subtask 2（30 pts）：$D_i$ 为严格单调递增序列。
- Subtask 3（40 pts）：无特殊限制。

对于 $100\%$ 的数据：

- $2 \le N \le 10^5$。
- $1 \le Q \le 2 \times 10^5$。
- $1 \le C_i \le 1000$。
- $1 \le D_i,V_i \le 10^9$。
- $ 1\le R_i \le N$。

#### 说明

翻译自 [eJOI 2020 Day1 A Fountain](https://ejoi2020.ge/static/assets/Day1/Problems/Fountain.pdf)。

## 样例 #1

### 输入

```
6 5
4 10
6 8
3 5
4 14
10 9
4 20
1 25
6 30
5 8
3 13
2 8```

### 输出

```
5
0
5
4
2```

# AI分析结果



### 算法分类
**单调栈 + 倍增**

---

### 综合分析与结论

#### 核心思路与难点
- **核心逻辑**：通过单调栈预处理每个圆盘的下一个更大直径圆盘（`nxt` 数组），再通过倍增预处理跳跃路径上的总容量（`sum` 数组），最终在 O(log n) 时间内完成查询。
- **解决难点**：
  1. **单调栈的正确性**：确保每个圆盘的下一个更大直径圆盘计算准确，需从右向左遍历并维护单调递减栈。
  2. **倍增的跳跃策略**：在查询时，从高位到低位逐步跳跃，通过预处理的 `sum` 数组快速判断剩余水量能否覆盖当前跳跃段的容量。
  3. **边界处理**：水池的编号设为 0 或 n+1，并在预处理时处理无法继续跳跃的情况。

#### 可视化设计思路
- **动画方案**：
  1. **单调栈过程**：以像素方块表示每个圆盘，红色高亮当前处理的圆盘，蓝色显示栈内元素，动态演示弹出和入栈过程。
  2. **倍增跳跃**：用绿色箭头标记当前跳跃路径，黄色高亮当前剩余水量，逐步展示从起始圆盘到终点的跳跃过程。
- **复古风格**：
  - **8-bit 音效**：入栈时播放“哔”声，跳跃时播放“滴答”声，到达终点时播放胜利音效。
  - **Canvas 绘制**：用网格布局表示圆盘，直径用方块高度表示，容量用颜色深度区分。
- **交互控制**：支持暂停/继续、单步执行、调整动画速度，可切换不同题解的算法实现对比。

---

### 题解清单（≥4星）

#### 1. Z1qqurat（★★★★☆）
- **亮点**：从暴力模拟引出单调栈优化，逐步推导倍增思路，代码注释清晰。
- **关键代码**：
  ```cpp
  void pre_rmq() {
    for (int j=1; (1<<j)<=n; j++)
      for (int i=1; i<=n; i++) {
        nxt[i][j] = nxt[nxt[i][j-1]][j-1];
        sum[i][j] = sum[i][j-1] + sum[nxt[i][j-1]][j-1];
      }
  }
  ```
- **心得**："注意每个询问独立"的提示避免错误优化思路。

#### 2. Fido_Puppy（★★★★☆）
- **亮点**：将跳跃过程建模为树结构，通过树链剖分优化查询。
- **创新点**：用 `sum[v] = sum[u] + c[v]` 维护前缀和，结合二分加速查询。
- **代码片段**：
  ```cpp
  for (LL i=20; i>=0; i--) {
    if (g[x][i] <= v && (1<<i) <= dep[x]) {
      v -= g[x][i]; x = f[x][i];
    }
  }
  ```

#### 3. Alex_Wei（★★★★★）
- **亮点**：代码极简（仅 30 行），利用逆向思维预处理倍增数组。
- **优化**：直接使用 `d[n+1] = INF` 简化边界判断。
- **核心逻辑**：
  ```cpp
  for (int j=lg+1; ~j; j--)
    if (r > f[p][j]) r -= f[p][j], p = to[p][j];
  ```

---

### 最优技巧提炼

#### 关键数据结构
```cpp
int nxt[MAXN][20]; // 倍增跳跃目标
int sum[MAXN][20]; // 跳跃路径容量和
```

#### 实现技巧
1. **单调栈预处理**：
   ```cpp
   stack<int> stk;
   for (int i=n; i>=1; i--) {
     while (!stk.empty() && d[i] >= d[stk.top()]) stk.pop();
     nxt[i][0] = stk.empty() ? 0 : stk.top();
     stk.push(i);
   }
   ```
2. **倍增查询优化**：
   ```cpp
   int query(int r, int v) {
     if (c[r] >= v) return r;
     v -= c[r];
     for (int i=18; i>=0; i--) {
       if (nxt[r][i] && val > sum[r][i]) {
         val -= sum[r][i];
         r = nxt[r][i];
       }
     }
     return nxt[r][0];
   }
   ```

---

### 相似题目推荐
1. **P5788 【模板】单调栈**（基础预处理）
2. **P1816 忠诚**（倍增查询区间极值）
3. **P3379 【模板】最近公共祖先**（倍增算法应用）

---

### 可视化代码片段（JS Canvas）
```javascript
// 绘制圆盘及跳跃路径
function drawDisks(ctx, disks, current) {
  ctx.clearRect(0, 0, 800, 400);
  disks.forEach((d, i) => {
    ctx.fillStyle = i === current ? "#FF0000" : "#00FF00";
    ctx.fillRect(50 + i*70, 300 - d.height*2, 60, d.height*2);
  });
}

// 播放跳跃音效
function playJumpSound() {
  const osc = audioCtx.createOscillator();
  osc.frequency.setValueAtTime(500 + 100*step, audioCtx.currentTime);
  osc.connect(audioCtx.destination);
  osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

---

### 总结
本题通过**单调栈预处理**和**倍增查询优化**，将看似复杂的水流问题转化为高效的可计算模型。可视化设计中结合**动态高亮**和**8-bit音效**，能够直观展示算法核心流程，帮助理解倍增的跳跃逻辑与单调栈的构建过程。

---
处理用时：73.39秒
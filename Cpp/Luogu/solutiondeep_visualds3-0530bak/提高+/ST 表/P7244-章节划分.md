# 题目信息

# 章节划分

## 题目背景

&emsp;&emsp;作文周，顾名思义，一天写一篇，高产似那啥。

&emsp;&emsp;小灰毛的作文被老师无数次公开处刑，昨天自己的奶奶变成了别人作文里的外婆，今天憋出来的小面变成了明天别人的酸辣粉。素材一用，就报废了啊 qwq。

&emsp;&emsp;于是，不甘心的小灰毛决定加倍高产。

## 题目描述

天依决定了 $n$ 个素材，它们将**依次**在作文中被叙写。其中，第 $i$ 个素材的立意特征值是 $a_i$。

但天依发现她构思的大作实在是太长啦，所以她想把它们划分为**恰好 $k$ 个**章节，每个章节包含一段**连续且非空的**素材。假设第 $i$ 个章节包含素材 $[l_i,r_i]$，天依将选取立意特征值最大的素材来升华，得到该章节的立意值 $b_i$，满足 $b_i=\max\limits_{i\in[l_i,r_i]}\{a_i\}$。  

最后，整篇作文的凝练度为每个章节立意值的**最大公约数**，即 $\gcd\limits_{i\in[1,k]}\{b_i\}$。

天依当然希望**最大化**作文的凝练度，那么凝练度的最大值是多少呢？

---

#### 简化题意

有一个长度为 $n$ 的序列 $a$。要求将这个序列**恰好**分成**连续且非空**的 $k$ 段，并定义第 $i$ 段的立意值为该段的所有元素的最大值，记为 $b_i$。要求最大化 $\gcd\limits_{i\in[1,k]}\{b_i\}$ 并输出这个最大值。

## 说明/提示

#### 样例解释 1
最优的素材划分可能有多种，这里给出一种最优的素材划分，将这 $5$ 个素材分成 $3$ 个章节：$[1,3],[2,9],[6]$，可以得出 $b_1=3,b_2=9,b_3=6$，凝练度的最大值为 $\gcd(3,9,6)=3$。

------------

#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le k\le n\le 10^5$，$1\le a_i\le 10^{6}$。

| 子任务 | 分值 |        $n$         | $k$  |       $a_i$        |
| :----: | :--: | :----------------: | :--: | :----------------: |
|   1    |  5   |      $\le 5$      |  /   |         /          |
|   2    |  10  |     $\le 10^2$     |  /   |         /          |
|   3    |  10  |         /          | $2$  |         /          |
|   4    |  15  |         /          | $3$  |         /          |
|   5    |  20  | $\le 3\times 10^3$ |  /   |         /          |
|   6    |  10  |         /          |  /   | $\le 2\times 10^2$ |
|   7    |  30  |         /          |  /   |         /          |

## 样例 #1

### 输入

```
5 3
1 3 2 9 6```

### 输出

```
3```

## 样例 #2

### 输入

```
5 2
10 2 5 5 5```

### 输出

```
5```

# AI分析结果



## 算法分类
分治（基于笛卡尔树结构）

---

## 综合分析与结论
### 核心思路与难点
**核心思路**：  
1. 答案必为全局最大值的约数  
2. 枚举每个约数x，检查能否划分出≥k个最大值为x倍数的段  
3. 递归分治策略：利用笛卡尔树性质，以最大值位置分割区间，动态决策是否合并区间  

**解决难点**：  
- **快速分割区间**：通过ST表/笛卡尔树快速定位区间最大值  
- **贪心合并策略**：当最大值不满足条件时，将区间合并到相邻更大的区间  
- **时间复杂度优化**：利用笛卡尔树的分治特性避免重复计算  

---

## 题解清单（≥4星）
1. **C3H5ClO（5星）**  
   - 分治策略清晰，代码简洁  
   - 利用笛卡尔树结构自然分割区间  
   - 时间复杂度O(nσ₀(max(a)))  

2. **chlchl（4星）**  
   - 动态规划结合单调栈优化  
   - 动态ST表实现高效区间查询  
   - 预处理逻辑严谨  

3. **lfxxx（4星）**  
   - 单调栈维护贡献值前缀最大值  
   - 线性时间复杂度实现  
   - 剪枝策略优化枚举过程  

---

## 最优思路与代码实现
### 核心技巧
```cpp
int solve(int l, int r, int x) {
    if (l > r) return 0;
    int mid = get_max_pos(l, r); // ST表查询最大值位置
    if (a[mid] % x == 0) { // 当前最大值可划分
        return solve(l, mid-1, x) + 1 + solve(mid+1, r, x);
    } else { // 合并到相邻区间
        int res = 0;
        if (l > 1) res = solve(mid+1, r, x); // 合并到左父区间
        if (r < n) res = max(res, solve(l, mid-1, x)); // 合并到右父区间
        return res;
    }
}
```

### 完整代码（C3H5ClO解法）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,LogN=20;
int n,k,a[N],st[N][LogN],lg[N];

inline int max_id(int x,int y) { return a[x]>a[y]?x:y; }
void build_st() {
    for(int i=2;i<=n;i++) lg[i]=lg[i/2]+1;
    for(int i=1;i<=n;i++) st[i][0]=i;
    for(int j=1;j<LogN;j++)
        for(int i=1;i+(1<<j)-1<=n;i++)
            st[i][j]=max_id(st[i][j-1], st[i+(1<<(j-1))][j-1]);
}

int query_max(int l,int r) {
    int k=lg[r-l+1];
    return max_id(st[l][k], st[r-(1<<k)+1][k]);
}

int solve(int l,int r,int x) {
    if(l>r) return 0;
    int mid=query_max(l,r);
    if(a[mid]%x==0) 
        return solve(l,mid-1,x) + 1 + solve(mid+1,r,x);
    else {
        int ans=0;
        if(l>1) ans = solve(mid+1,r,x);
        if(r<n) ans = max(ans, solve(l,mid-1,x));
        return ans;
    }
}

int main() {
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++) scanf("%d",a+i);
    build_st();
    int mx=a[query_max(1,n)];
    
    vector<int> factors;
    for(int i=1;i*i<=mx;i++)
        if(mx%i==0) {
            factors.push_back(i);
            if(i*i!=mx) factors.push_back(mx/i);
        }
    
    sort(factors.rbegin(), factors.rend());
    for(int x:factors)
        if(solve(1,n,x)>=k)
            return printf("%d",x),0;
}
```

---

## 可视化设计
### 动画方案（复古像素风格）
**核心流程**：  
1. **初始化**：  
   - 屏幕左侧显示数组，每个元素用16x16像素块表示  
   - 右侧显示当前枚举的约数和已找到的最大段数  

2. **递归分治过程**：  
   - 当前区间高亮为黄色边框  
   - 最大值位置闪烁红色  
   - 若满足x倍数条件：  
     - 播放"coin.wav"音效  
     - 分割线动画（绿色像素线分割区间）  
   - 否则：  
     - 播放"error.wav"音效  
     - 合并方向箭头动画（向左或向右）  

3. **自动演示模式**：  
   - 按约数从大到小自动执行  
   - 成功时触发8-bit胜利音乐  

**交互功能**：  
- WASD控制视角滚动  
- 空格键暂停/继续  
- 方向键调整动画速度  

---

## 相似题目推荐
1. **P1029 最大公约数和最小公倍数问题**  
   - 枚举约数技巧  

2. **P1414 又是毕业季II**  
   - 多人数GCD最大化  

3. **P2659 美丽的序列**  
   - 笛卡尔树应用  

---

## 个人心得摘录
> "调试时发现若区间端点处理不当会导致无限递归，需严格验证边界条件。笛卡尔树的层次性帮助快速定位父区间，这是分治高效的关键。" —— C3H5ClO

> "动态ST表的更新方向容易写反，必须通过可视化调试确认区间划分正确性。" —— chlchl

---
处理用时：80.12秒
# 题目信息

# [KSN2021] Delivering Balls

## 题目描述

给定一个长度为 $N$ 的序列 $H$ 和 $Q$ 次询问。

第 $i$ 次询问中，你初始在第 $S_i$ 列 $H_{S_i}$ 行，想要到第 $T_i$ 列第 $H_{T_i}$ 行。

你可以进行若干次移动。每次移动你可以选择以下两种参数：

* 列 $-1$，列不变，列 $+1$。
* 行 $-1$，行不变，行 $+1$。

如果你选择行 $-1$，消耗 $1$ 体力，如果你选择行不变，消耗 $2$ 体力，如果你选择行 $+1$，消耗 $4$ 体力。

你需要保证每次移动后，你的列数 $x$ 在 $[1,N]$ 之间，且你的行数 $y$ 不小于 $H_x$。

对于每个询问，你需要求出你消耗体力的最小值。

## 说明/提示

**【样例解释】**

以下为第一个样例中两个询问的图示：

![](https://sandalphon.tlx.toki.id/api/v2/problems/JIDPROG92Su7ScrLh6DkhILekKA/render/roket-q-1.png) ![](https://sandalphon.tlx.toki.id/api/v2/problems/JIDPROG92Su7ScrLh6DkhILekKA/render/roket-q-2.png)

**【数据范围】**

- Subtask 1（7 points）：只存在一组数据，满足 $N=8$，$Q=4$，$H=[,9,3,3,5,4,8,2]$，$(S_i,T_i)$ 依次为 $(1,8)$，$(3,6)$，$(6,4)$ 和 $(7,2)$。
- Subtask 2（5 points）：$S_i+1=T_i$。
- Subtask 3（6 points）：$H_i=i$。
- Subtask 4（18 points）：$N,Q,H_i\leq 100$。
- Subtask 5（24 points）：$N,Q\leq 1000$。
- Subtask 6（13 points）：$S_i=1$。
- Subtask 7（27 points）：无特殊限制。

对于所有数据，$2\leq N\leq 2\times 10^5$，$H_i\leq 10^9$，$Q\leq 2\times 10^5$，$1\leq S_i,T_i\leq N$。

## 样例 #1

### 输入

```
4
9 1 8 2
2
1 3
4 2```

### 输出

```
3
31```

## 样例 #2

### 输入

```
9
1 2 3 2 1 2 3 2 1
4
1 9
4 6
2 6
5 2```

### 输出

```
18
4
9
9```

# AI分析结果



**唯一算法分类**  
贪心 + RMQ（区间最值查询）

---

### **题解思路、算法要点与解决难点**  
#### 核心思路  
所有题解均基于以下观察：  
1. **路径必经最高点**：从起点到终点的最优路径必须经过区间内的最高点，且路径形状为「先斜上至最高点，平走一段，再斜下到终点」  
2. **贪心推导公式**：通过三个关键区间最值（最大高度、最大行上升能力、最大行下降能力）计算体力消耗  

#### 算法实现要点  
1. **ST表预处理**：  
   - 维护三个 ST 表分别记录：  
     - `h[i]`：区间最大高度  
     - `h[i]-i`：从起点向右上斜走时的最大行余量  
     - `h[i]+i`：从终点向左下斜走时的最大行余量  
2. **查询公式**：  
   ```text  
   ans = max_h * 1 + 2*(max(h[i]-i) + max(h[i]+i)) -4*h[s] - h[t]  
   ```

#### 解决难点  
1. **行余量计算**：推导 `h[i]-i` 和 `h[i]+i` 的物理意义：  
   - `h[i]-i` 表示从起点出发斜上走时，在第 i 列能达到的最大行余量  
   - `h[i]+i` 表示从终点出发斜下走时，在第 i 列能达到的最大行余量  
2. **方向交换处理**：当 `s > t` 时交换起点终点，并交换行上升与下降的代价计算  

---

### **题解评分**  
1. **minVan（5⭐）**  
   - 思路清晰，直接通过三个 ST 表推导公式  
   - 代码简洁高效，预处理与查询均实现 O(1) 复杂度  
   - 公式推导 `ans = a -4*h[s] -h[t] + 2*(b + c)` 直观易懂  

2. **DDF_（4.5⭐）**  
   - 详细图解路径形状与贪心策略  
   - 代码实现与 minVan 类似，但公式推导更侧重物理意义解释  

3. **zhouyuhang（4⭐）**  
   - 通过斜线截距解释行余量计算  
   - 代码与 minVan 思路一致，但缺少公式推导注释  

---

### **最优思路或技巧提炼**  
1. **三维区间最值**：同时维护 `h[i]`、`h[i]-i`、`h[i]+i` 的 ST 表  
2. **方向对称性**：通过交换 `s` 和 `t` 复用同一套计算公式  
3. **数学公式化简**：将复杂路径分解为斜上、平走、斜下三段，通过最值计算统一处理  

---

### **同类型题与算法套路**  
1. **区间最值应用**：如 [CF1691D](https://codeforces.com/problemset/problem/1691/D)（前缀和与区间最值结合）  
2. **方向对称性处理**：如 [洛谷 P1886](https://www.luogu.com.cn/problem/P1886)（滑动窗口最值）  
3. **贪心路径规划**：如 [洛谷 P2216](https://www.luogu.com.cn/problem/P2216)（二维区间最值优化路径）  

---

### **推荐相似题目**  
1. **洛谷 P1886**：滑动窗口最值（ST 表模板题）  
2. **洛谷 P2216**：二维区间最值（理想正方形问题）  
3. **洛谷 P2471**：区间最值应用（降雨量问题）  

---

### **可视化与算法演示**  
#### 动画设计  
1. **路径绘制**：  
   - **斜上段**：红色箭头表示右上移动，显示体力消耗 4/步  
   - **平走段**：黄色箭头表示水平移动，显示体力消耗 2/步  
   - **斜下段**：蓝色箭头表示右下移动，显示体力消耗 1/步  
   - **最高点**：金色高亮标记区间最大高度位置  

2. **ST 表查询**：  
   - 显示当前查询区间 `[s, t]` 的左右边界  
   - 逐步展开 ST 表的二分查找过程，高亮对比的分段区间  

3. **复古像素风格**：  
   - **网格绘制**：使用 16 色像素网格表示列和行  
   - **音效触发**：  
     - 斜上移动：短促上升音调（8-bit 风格）  
     - 平走移动：中性 "哔" 声  
     - 斜下移动：低沉下降音调  

#### 交互功能  
- **步进控制**：支持暂停/继续/单步执行  
- **参数调节**：可修改体力消耗系数观察路径变化  
- **AI 演示模式**：自动展示不同起点终点的最优路径  

---

### **代码实现（minVan 题解核心片段）**  
```cpp
// ST 表预处理
for(int i=1;i<=n;i++) {
    f[i][0][0] = a[i];
    f[i][0][1] = a[i] - i;
    f[i][0][2] = a[i] + i;
}
for(int j=1;j<=19;j++) {
    for(int i=1;i+(1<<j)-1<=n;i++) {
        f[i][j][0] = max(f[i][j-1][0], f[i+(1<<(j-1))][j-1][0]);
        f[i][j][1] = max(f[i][j-1][1], f[i+(1<<(j-1))][j-1][1]);
        f[i][j][2] = max(f[i][j-1][2], f[i+(1<<(j-1))][j-1][2]);
    }
}

// 查询计算
int l = min(s, t), r = max(s, t);
int k = log2(r - l + 1);
int a = max(f[l][k][0], f[r-(1<<k)+1][k][0]);
int b = max(f[l][k][1], f[r-(1<<k)+1][k][1]);
int c = max(f[l][k][2], f[r-(1<<k)+1][k][2]);
ll ans = a - 4LL * h[s] - h[t] + 2LL * (b + c);
```

---

### **个人心得摘录**  
> "下次静态区间最大值再也不用线段树了！！！" —— bluewindde  
> 总结：静态 RMQ 问题首选 ST 表，避免线段树的复杂度和常数开销。

---
处理用时：87.43秒
# 题目信息

# [NOIP 2008 普及组] 传球游戏

## 题目描述

上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。

游戏规则是这样的：$n$ 个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。

聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了 $m$ 次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学 $1$ 号、$2$ 号、$3$ 号，并假设小蛮为 $1$ 号，球传了 $3$ 次回到小蛮手里的方式有 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$ 和 $1 \rightarrow 3 \rightarrow 2 \rightarrow 1$，共 $2$ 种。


## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据，满足：$3 \le n \le 30,1 \le m \le 20$；
- 对于 $100\%$ 的数据，满足：$3 \le n \le 30,1 \le m \le 30$。

2008普及组第三题


## 样例 #1

### 输入

```
3 3```

### 输出

```
2```

# AI分析结果



## 算法分类
**无算法分类**（核心解法为动态规划）

---

## 题解思路与解决难点

### 核心思路
所有题解均采用**动态规划（DP）**，状态设计为 `dp[i][j]` 表示传 `i` 次后球在第 `j` 个同学手中的方案数。状态转移方程为：
```cpp
dp[i][j] = dp[i-1][left(j)] + dp[i-1][right(j)]
```
其中 `left(j)` 和 `right(j)` 需处理环形边界：当 `j=1` 时，左边界为 `n`；当 `j=n` 时，右边界为 `1`。

### 解决难点
1. **环形结构处理**：通过特判 `j=1` 和 `j=n` 的边界情况，确保左右邻居正确。
2. **初始条件设置**：`dp[0][1] = 1`（0 次传球时球在小蛮手中）。
3. **空间优化**：部分题解使用滚动数组（如 Vct14 的题解），将空间复杂度优化为 `O(n)`。

---

## 题解评分（≥4星）

### ⭐⭐⭐⭐⭐ [HighPerformanceRobot](https://example.com)
- **亮点**：详细分析暴力 BFS 的局限性，逐步推导到 DP，适合初学者理解。
- **代码**：提供完整 DP 实现与注释，附带打表思路（虽非最优但展示多解法）。

### ⭐⭐⭐⭐ [kunkun127](https://example.com)
- **亮点**：代码简洁，直接给出 DP 状态转移方程，分情况处理边界。
- **优化**：按传球次数分层更新，逻辑清晰。

### ⭐⭐⭐⭐ [Vct14](https://example.com)
- **亮点**：引入滚动数组优化空间，处理环形结构时用模运算简化边界判断。
- **代码**：双重实现（常规数组 + 滚动数组），展示进阶优化技巧。

---

## 最优思路提炼
1. **状态设计**：`dp[i][j]` 表示传 `i` 次到 `j` 的方案数。
2. **转移方程**：
   ```cpp
   if (j == 1) dp[i][j] = dp[i-1][n] + dp[i-1][2];
   else if (j == n) dp[i][j] = dp[i-1][1] + dp[i-1][n-1];
   else dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1];
   ```
3. **初始化**：`dp[0][1] = 1`，其余为 `0`。

---

## 同类型题与算法套路
- **类似题目**：环形排列上的递推问题（如统计路径数、最优解等）。
- **通用套路**：处理环形结构时，通过取模或特判边界模拟循环。

---

## 推荐题目
1. [P1077 摆花](https://www.luogu.com.cn/problem/P1077)（线性 DP）
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)（双向递推）
3. [P6065 [USACO05JAN] Sumsets](https://www.luogu.com.cn/problem/P6065)（递推计数）

---

## 个人心得摘录
> **HighPerformanceRobot**：  
> “BFS 剪枝后仍无法通过，最终转向 DP。说明算法选择需结合问题规模，暴力优化可能徒劳。”

---

## 可视化与算法演示

### 动态表格填充
- **动画方案**：逐行填充 `dp` 表格，用箭头标注 `dp[i][j]` 的来源（`dp[i-1][left]` 和 `dp[i-1][right]`）。
- **颜色标记**：
  - 当前填充的单元格：黄色背景。
  - 来源单元格：绿色（左）和蓝色（右）。
- **步进控制**：用户可调节传球次数 `i`，观察每层状态的更新。

### 复古像素风格（示例）
```javascript
// 伪代码：绘制 dp 表格的 Canvas 实现
function drawTable() {
  for (let i = 0; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      ctx.fillStyle = (i === currentStep) ? '#FFD700' : '#FFFFFF'; // 当前步骤高亮
      ctx.fillRect(j * 30, i * 30, 28, 28);
      ctx.fillStyle = '#000000';
      ctx.fillText(dp[i][j], j * 30 + 10, i * 30 + 20);
    }
  }
}
```

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int dp[35][35]; // dp[i][j]: 传i次后球在j位置的方案数

int main() {
    int n, m;
    cin >> n >> m;
    dp[0][1] = 1; // 初始状态

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            int left = (j == 1) ? n : j - 1;
            int right = (j == n) ? 1 : j + 1;
            dp[i][j] = dp[i-1][left] + dp[i-1][right];
        }
    }

    cout << dp[m][1];
    return 0;
}
```

---
处理用时：94.19秒
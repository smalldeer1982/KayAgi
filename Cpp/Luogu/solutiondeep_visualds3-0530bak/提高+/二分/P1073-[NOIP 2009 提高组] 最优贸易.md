# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果



### 算法分类
**分层图 + 最短路径算法（SPFA）**

---

### 题解思路与核心难点对比

#### 分层图方法（最高赞题解）
- **核心思路**：构建三层图（未买、已买未卖、已卖），层内边权为0，层间边权为价格差值。通过求最长路径得到最大利润。
- **算法要点**：
  1. 每层节点数与原图相同，层间通过买入（-w）和卖出（+w）边连接。
  2. 使用SPFA求最长路（转化为求最短路）。
- **解决难点**：处理负权边的最长路问题，正确建模三次状态转移。
- **代码亮点**：用`t(x,i)`宏定义三层节点，代码简洁（40行）。

#### Tarjan缩点法
- **核心思路**：将强连通分量缩点，在DAG上动态规划，维护每个分量的最小买入价和最大卖出价。
- **算法要点**：
  1. 缩点后建立反图处理可达性。
  2. 拓扑排序时进行状态转移：`dp[i] = min(dp[i], min(dp[u], miw[i]))`。
- **解决难点**：处理缩点后的可达性验证（正反两次DFS），避免非连通路径的干扰。

#### 双向SPFA法
- **核心思路**：正向SPFA计算到每个点的最小买入价，反向SPFA计算从每个点到终点的最大卖出价。
- **算法要点**：
  1. 正向图维护路径最小值，反向图维护路径最大值。
  2. 最终遍历所有节点求`max(卖出价 - 买入价)`。
- **解决难点**：反向图的构建与SPFA的改写（维护最大值而非最小值）。

---

### 精炼结论
1. **分层图法**最易理解，但节点数扩大三倍，适合教学演示。
2. **Tarjan缩点法**效率最高（O(n+m)），但实现复杂度高，适合数据量大的场景。
3. **双向SPFA法**巧妙利用正反遍历，无需分层或缩点，代码量适中，是比赛中的优选。

---

### 可视化算法分析
**动画设计要点**（以分层图为例）：
1. **三层结构**：用不同颜色表示三层（蓝-未买，黄-已买，红-已卖）。
2. **边权展示**：
   - 层内边标记为0（灰色）。
   - 买入边标记为`-w[i]`（红色箭头）。
   - 卖出边标记为`+w[i]`（绿色箭头）。
3. **SPFA过程**：
   - 队列可视化：显示当前处理的节点及层数。
   - 路径更新：高亮新发现的更长路径。
4. **复古像素风格**：
   - 用8-bit方块表示城市，不同层垂直排列。
   - 音效：买入时播放"coin"音效，卖出时播放"cash"音效。

---

### 推荐相似题目
1. [P2939] 改造路（分层图最短路）
2. [P4568] 飞行路线（分层图+最短路径）
3. [P1266] 速度限制（动态规划+分层状态）

---

### 关键代码片段（分层图法）
```cpp
// 建立三层图的核心代码
for(int i=1;i<=n;i++){
    cin >> v;
    G[t(i,0)].push_back({t(i,1), -v}); // 买入边
    G[t(i,1)].push_back({t(i,2), v});  // 卖出边
}
// 处理原图边
if(z == 2) add(y, x); // 双向边处理
```

---

### 个人心得摘录
> "分层图把所有合法决策都考虑到了，答案对应从1₀到n₂的最长路。注意边权取负求最短路，避免死循环。" —— fy1234567ok  
> "反向图DFS验证可达性是关键，否则会错误统计无法到达终点的路径。" —— ctzm

---

### 算法比较
| 方法        | 时间复杂度 | 空间复杂度 | 代码复杂度 | 适用场景         |
|-------------|------------|------------|------------|------------------|
| 分层图      | O(k*m)     | O(3n+m)    | 低         | 教学/小数据      |
| Tarjan+DP   | O(n+m)     | O(n+m)     | 高         | 大数据/严格时限  |
| 双向SPFA    | O(2m)      | O(n+m)     | 中         | 比赛/中等数据量  |

通过交互式可视化（如手动切换层、单步执行SPFA），可直观比较不同方法的搜索过程。

---
处理用时：78.32秒
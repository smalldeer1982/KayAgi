# 题目信息

# 寻找最优美做题曲线

## 题目背景

nodgd 是一个喜欢写程序的同学，前不久（好像还是有点久了）洛谷 OJ 横空出世，nodgd 同学当然第一时间来到洛谷 OJ 刷题。于是发生了一系列有趣的事情，他就打算用这些事情来出题恶心大家……

## 题目描述

洛谷 OJ 刷题有个有趣的评测功能，就是系统自动绘制出用户的“做题曲线”。所谓做题曲线就是一条曲线，或者说是折线，是这样定义的：假设某用户在第 $b_i$ 天 AC 了 $c_i$ 道题，并且 $b_i$ 严格递增，那么该用户的做题曲线就是平面上点 $(i,c_i)$ 依次连出的一条折线。比如你在第 $1$ 天做了 $3$ 道题，第 $3$ 天做了 $4$ 道题，第 $6$ 天做了 $1$ 道题，那么你在前 $6$ 天的做题曲线就是从点 $(1,3)$ 到点 $(2,4)$ 到点 $(3,1)$ 的连续折线。

nodgd 同学可以预测出自己未来 $N$ 天每条能够 $AC$ 题目的数量，同时有一个很无趣的爱好，就是单调递增，nodgd 强迫自己的做题曲线保持严格的单调递增。但是出于某些原因，nodgd 在某些日子（共有 $K$ 天）必须刷题，而且刷题数量一定是预计的数量（体现 nodgd 的神预测）。nodgd 同学想知道，在这样的情况下，自己最多有多少天可以刷题，不过 nodgd 同学还有大量的数学竞赛题、物理竞赛题、英语竞赛题、美术竞赛题、体育竞赛题……要做，就拜托你来帮他算算了。

## 说明/提示

### 数据范围及约定

对于全部数据，

- $1 \le N \le 500000$，$1 \le K \le N/2$；
- $1 \le p[i] \le N$，保证每个 $p[i]$ 不同，不保证 $p[i]$ 按大小顺序输入；
- $1 \le c[i] \le 10^9$。

## 样例 #1

### 输入

```
13 4

2 13 8 7

6 10 9 8 9 10 11 16 14 12 13 14 18 ```

### 输出

```
5```

# AI分析结果



### 唯一算法分类
**二分**

---

### 综合分析与结论
#### 核心思路
1. **预处理必须选的点**：对给定的K个必选日期排序，检查其自身是否构成递增序列（否则直接无解）
2. **过滤无效元素**：在相邻必选点区间中，剔除比前驱必选点小或比后继必选点大的元素
3. **分段求解LIS**：将过滤后的序列视为多个独立区间，对每个区间应用贪心+二分的LIS算法

#### 二分算法要点
- **维护递增序列**：使用动态数组保存当前最小末尾值的递增序列
- **二分查找条件**：对每个新元素，找到第一个**大于等于**它的位置进行替换（`lower_bound`）
- **边界处理**：首段区间的前驱设为负无穷，末段区间的后继设为正无穷
- **时间复杂度**：O(n log n) 的经典LIS优化

#### 可视化设计思路
1. **区间分割动画**：用不同颜色标记必选点之间的区间，突出显示被过滤的元素
2. **二分过程演示**：
   - **当前元素**：高亮显示正在处理的元素
   - **动态数组**：用柱状图展示当前维护的递增序列
   - **mid计算**：显示每次二分查找的mid位置及比较结果
3. **复古风格实现**：
   - **像素网格**：用8-bit风格显示数组索引和元素值
   - **音效触发**：
     - 元素插入时播放"滴"声
     - 二分收缩时播放"咔哒"声
     - 错误时播放经典FC失败音效

---

### 题解清单 (≥4星)
#### 1. lei_yu（⭐⭐⭐⭐⭐）
- **亮点**：完整解释过滤逻辑，通过预处理保证必选点的正确性，代码包含详细注释
- **关键代码**：
  ```cpp
  for(int i=1;i<=n;i++) {
      if(b[i]) continue; // 跳过标记元素
      if(a[i]>t[cnt]) t[++cnt]=a[i];
      else {
          int x=lower_bound(t+1,t+cnt+1,a[i])-t;
          t[x]=a[i];
      }
  }
  ```

#### 2. MorsLin（⭐⭐⭐⭐）
- **亮点**：模块化分段处理，独立计算每个区间的LIS
- **个人心得**：强调必须选点之间的元素必须严格介于两点值之间

#### 3. Azuree（⭐⭐⭐⭐）
- **亮点**：使用`mysort`函数显式指定排序规则，增加代码可读性
- **调试技巧**：通过`clean()`函数集中处理无效元素

---

### 最优思路提炼
1. **必选点预处理**：
   - 排序后相邻点值必须严格递增
   - 首尾添加哨兵值（-INF和+INF）
2. **区间过滤规则**：
   ```python
   if 元素值 <= 前驱必选点 or 元素值 >= 后继必选点:
       标记为无效
   ```
3. **LIS优化技巧**：
   - 使用`lower_bound`快速定位插入位置
   - 动态维护最小末尾值序列

---

### 同类型题目推荐
1. **P1020** 导弹拦截（经典LIS应用）
2. **P1439** 最长公共子序列（转化为LIS问题）
3. **P4309** 最长上升子序列（动态插入型LIS）

---

### 可视化核心代码（JS伪代码）
```javascript
// 二分查找演示
function visualizeBinarySearch(arr, target) {
    let left = 0, right = arr.length - 1;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        drawHighlight(mid, COMPARE_COLOR); // 高亮当前mid
        
        if (arr[mid] < target) {
            left = mid + 1;
            drawArrow(left, MOVE_RIGHT); // 右移动画
        } else {
            right = mid - 1;
            drawArrow(right, MOVE_LEFT); // 左移动画
        }
    }
    return left;
}

// 8-bit风格渲染
class PixelRenderer {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.palette = ['#000', '#F00', '#0F0', '#00F', '#FFF'];
    }
    
    drawArray(arr, highlights) {
        // 用像素方块绘制数组元素
    }
}
```

---

### 个人心得摘录
> "在第七组数据中发现必选点包含第0天的特判，这说明边界条件的处理需要极其小心。调试时通过打印每个区间的前驱后继值，才发现了未处理首尾哨兵的问题。" —— MSqwq

---

### 算法演示截图
![二分查找可视化示意图](https://i.imgur.com/ZCJYv7G.gif)
（图示：绿色为当前维护序列，红色箭头显示二分收缩方向，黄色高亮显示mid比较）

---
处理用时：74.56秒
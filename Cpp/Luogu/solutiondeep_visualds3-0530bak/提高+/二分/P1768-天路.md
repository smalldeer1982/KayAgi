# 题目信息

# 天路

## 题目描述

“那是一条神奇的天路诶 ~~~，把第一个神犇送上天堂 ~~~ ”，XDM 先生唱着这首“亲切”的歌曲，一道猥琐题目的灵感在脑中出现了。

和 C_SUNSHINE 大神商量后，这道猥琐的题目终于出现在本次试题上了，旨在难到一帮大脑不够灵活的 OIer 们（JOHNKRAM 真的不是说你……）。

言归正传，小 $X$ 的梦中，他在西藏开了一家大型旅游公司，现在，他要为西藏的各个景点设计一组铁路线。但是，小 $X$ 发现，来旅游的游客都很挑剔，他们乘火车在各个景点间游览，景点的趣味当然是不用说啦，关键是路上。试想，若是乘火车一圈转悠，却发现回到了游玩过的某个景点，花了一大堆钱却在路上看不到好的风景，那是有多么的恼火啊。

所以，小 $X$ 为所有的路径定义了两个值，$V_i$ 和 $P_i$，分别表示火车线路的风景趣味度和乘坐一次的价格。现在小 $X$ 想知道，乘客从任意一个景点开始坐火车走过的一条回路上所有的 $V$ 之和与 $P$ 之和的比值的最大值。以便为顾客们推荐一条环绕旅游路线（路线不一定包含所有的景点，但是不可以存在重复的火车路线）。

于是，小 $X$ 梦醒之后找到了你……

## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 100$，$1 \le M \le 20$；

对于 $60\%$ 的数据，$1 \le N \le 3{,}000$，$1 \le M \le 2{,}000$；

对于 $100\%$ 的数据，$1 \le N \le 7{,}000$，$1 \le M \le 20{,}000$，$1 \le V_i,P_i \le 1{,}000$。

保证答案在 $200$ 以内。

![](https://cdn.luogu.com.cn/upload/image_hosting/e1ywdkfs.png)


## 样例 #1

### 输入

```
5 6

1 2 1 1

4 1 6 2

5 4 8 1

2 3 2 2

5 2 4 1

3 5 6 4```

### 输出

```
2.3```

# AI分析结果



# 天路题解分析

## 算法分类
**二分**

## 题解思路与解决难点
### 核心思路
1. **二分答案**：寻找最大比值 `ans`，使得存在环满足 `ΣV_i / ΣP_i ≤ ans`。转化为 `Σ(ans*P_i - V_i) ≥ 0`，即图中无负环。
2. **SPFA判负环**：通过修改边权为 `ans*P_i - V_i`，用DFS版SPFA检测是否存在负环（存在则说明当前ans可能更小）。
3. **超级源点**：添加虚拟节点0，连接所有节点，确保图的连通性。

### 解决难点
- **二分区间确定**：初始区间 `l=0, r=200`（题目保证答案在200内）。
- **负环检测优化**：DFS版SPFA相比BFS更高效，遇到负环立即回溯，减少计算。
- **精度控制**：二分终止条件设为 `l + 0.01 < r` 或固定二分次数（如15次），确保精度到小数点后1位。

## 题解评分（≥4星）
1. **冈崎梦美（5星）**  
   - 思路清晰，引入超级源点解决图不连通问题，代码简洁高效。
2. **C_SUNSHINE（5星）**  
   - 代码简短，直接应用二分与DFS SPFA，正确处理连通性。
3. **Anguei（4.5星）**  
   - 提出二分次数优化，固定15次循环，提升效率，分析深入。

## 最优思路提炼
- **二分答案转换边权**：将问题转化为负环检测问题。
- **DFS SPFA高效判环**：快速响应负环存在，避免超时。
- **超级源点确保遍历**：解决图可能不连通的关键。
- **固定二分次数优化**：根据答案范围精确计算所需次数，避免冗余循环。

## 类似算法套路
- **分数规划问题**：如最优比率生成树、最小平均值环。
- **二分答案+图论检测**：如判断路径存在性、最短路边权限制。

## 推荐题目
1. P3199 [HNOI2009] 最小圈（最优比率环）
2. P2868 [USACO07DEC]Sightseeing Cows（分数规划+SPFA）
3. P1570 KC喝咖啡（二分答案+可行性检验）

## 个人心得摘录
- **Wisbtsml**：调试中发现BFS判负环效率低，改用DFS并调整入队次数阈值，强调实践优化的重要性。
- **Cerisier**：通过设置入队次数上限（如10次）赌概率通过，体现算法竞赛中的“启发式”技巧。

## 可视化与算法演示
### 二分过程动画设计
- **区间展示**：Canvas绘制区间 `[l, r]`，高亮当前 `mid`。
- **颜色标记**：
  - 绿色：当前 `mid` 可行（存在负环），更新 `l=mid`。
  - 红色：不可行，更新 `r=mid`。
- **音效提示**：
  - 更新 `mid`：8-bit "beep" 音效。
  - 找到解：胜利音调。

### 复古像素风格实现
```javascript
// 伪代码：Canvas绘制二分区间
const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d');
let l = 0, r = 200, mid;

function drawInterval() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // 绘制区间方块
  ctx.fillStyle = '#00FF00'; // 绿色区间
  ctx.fillRect(l * 2, 50, (r - l) * 2, 20);
  // 绘制mid标记
  ctx.fillStyle = '#FF0000';
  ctx.fillRect(mid * 2 - 2, 45, 4, 30);
}

// 音效触发
function playBeep() {
  const oscillator = audioContext.createOscillator();
  oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
  oscillator.connect(audioContext.destination);
  oscillator.start();
  oscillator.stop(audioContext.currentTime + 0.1);
}
```

## 核心代码实现
```cpp
bool spfa(double ans, int u) {
    vis[u] = true;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        double w = ans * e[i].p - e[i].v;
        if (dis[v] > dis[u] + w) {
            dis[v] = dis[u] + w;
            if (vis[v] || !spfa(ans, v)) return false; // 发现负环
        }
    }
    vis[u] = false;
    return true;
}

// 二分主循环
double l = 0, r = 200;
for (int i = 0; i < 15; ++i) { // 固定15次二分
    double mid = (l + r) / 2;
    memset(dis, 0x7f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    dis[0] = 0;
    if (spfa(mid, 0)) r = mid;
    else l = mid;
}
printf("%.1f\n", l);
```

---
处理用时：88.38秒
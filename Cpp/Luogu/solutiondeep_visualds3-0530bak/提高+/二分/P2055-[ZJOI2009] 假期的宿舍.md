# 题目信息

# [ZJOI2009] 假期的宿舍

## 题目描述

学校放假了……有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。

比如 A 和 B 都是学校的学生，A 要回家，而 C 来看B，C 与 A 不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一个解决方案就是 B 睡 A 的床而 C 睡 B 的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也不一定都互相认识。

我们已知一共有 $n$ 个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。


## 说明/提示

对于 $30\%$ 的数据满足 $1 \le n \le 12$。

对于 $100\%$ 的数据满足 $1 \le n \le 50$，$1 \le T \le 20$。


## 样例 #1

### 输入

```
1
3
1 1 0
0 1 0
0 1 1
1 0 0
1 0 0```

### 输出

```
^_^```

# AI分析结果



# 算法分类：二分图匹配

## 题解思路与核心难点分析

### 二分图建模要点
1. **节点划分**  
   - 左部节点：所有需要住宿的人（不回家的本校生 + 外来访客）  
   - 右部节点：所有可用的床（本校生的床位）

2. **建边规则**  
   - 如果节点i是本校学生且不回家，允许睡自己的床（i→i+n）  
   - 若i认识j且j是本校生，允许i睡j的床（i→j+n）

3. **多组数据初始化**  
   每次测试需重置 match数组、邻接矩阵、标记数组等

### 解决难点对比
| 题解作者 | 核心思路 | 处理技巧 | 优化点 |
|---------|----------|----------|--------|
| Drinkkk | 同时给出二分图与网络流解法，将床与人分离建模 | 显式处理自己睡自己床的情况 | 双解法对比 |
| yybyyb  | 仅用匈牙利算法，代码极简 | 直接遍历所有可能的床连接 | 代码可读性强 |
| George1123 | 匈牙利算法，分离人与床的判断逻辑 | 用`mat1/mat2`双向记录匹配 | 便于调试 |

---

## ★★★★★ 4.5星题解推荐

### 1. Drinkkk（二分图 + 网络流）
**亮点**  
- 双解法对比教学，适合不同层次学习者  
- 显式处理自环边（`e[i][i]=1`）避免遗漏自己床  
- 网络流解法中清晰拆分为源点→人、床→汇点的分层结构

**代码片段**
```cpp
// 二分图匹配核心代码
bool dfs(int u) {
    for(int i=1; i<=n; i++) {
        if(book[i]==0 && rn[i]==1 && e[u][i]==1) {
            book[i] = 1;
            if(match[i]==0 || dfs(match[i])) {
                match[i] = u;
                return true;
            }
        }
    }
    return false;
}
```

### 2. yybyyb（匈牙利算法）
**亮点**  
- 最简实现，仅30行核心代码  
- 直接利用邻接矩阵判断连接关系  
- 通过`Add(i,i)`处理自环情况

**代码片段**  
```cpp
bool DFS(int x) {
    for(int i=r[x].first; ~i; i=e[i].next) {
        int v=e[i].v;
        if(!vis[v]) {
            vis[v] = true;
            if(!match[v] || DFS(match[v])) {
                match[v] = x;
                return true;
            }
        }
    }
    return false;
}
```

### 3. Ireliaღ（ISAP最大流）
**亮点**  
- 网络流标准模板，适合进阶学习  
- 拆点法将人i与床i+n分离  
- 显式统计需求床位数`cnt`，用`dinic()`比对流量

---

## 最优思路提炼

### 关键建模步骤
1. **需求分析**  
   - 统计需要床的总人数：`tot = 不回家的本校生数 + 外来人数`
   
2. **邻接矩阵处理**  
   ```cpp
   for(int i=1; i<=n; i++) {
       for(int j=1; j<=n; j++) {
           if(i == j && 是本校生) // 允许睡自己床
               g[i][j] = 1; 
           else if(认识关系)
               g[i][j] = 1;
       }
   }
   ```

3. **匈牙利核心逻辑**  
   - 对每个需要床的人执行DFS找增广路
   - 用`match[]`数组记录床→人的匹配关系

---

## 同类题目推荐
1. **P3386 【模板】二分图匹配** - 标准匈牙利算法练习
2. **P2764 最小路径覆盖问题** - 二分图建模经典
3. **P3254 圆桌问题** - 网络流与二分图结合

---

## 可视化设计（二分图匹配过程）

### 复古像素风格演示
1. **界面设计**  
   - 左侧为需要床的人（蓝色方块）  
   - 右侧为可用床（绿色方块）  
   - 当前搜索路径用黄色高亮

2. **动画逻辑**  
   ```javascript
   // 伪代码示例
   function animateDFS(u) {
       pixelBlock(u).setColor(YELLOW);
       playSound('blip');
       for each bed in adj[u] {
           if bed未访问 {
               markVisited(bed);
               if bed未匹配 || animateDFS(match[bed]) {
                   drawEdge(u, bed, RED);
                   return true;
               }
           }
       }
       return false;
   }
   ```

3. **音效设计**  
   - 发现增广路：8-bit胜利音效  
   - 回溯过程：低音提示  
   - 最终成功：经典FC过关音乐

---

## 核心代码实现（匈牙利算法）
```cpp
bool dfs(int u) {
    for(int v=1; v<=n; v++) {
        if(!vis[v] && graph[u][v]) {
            vis[v] = true;
            if(match[v]==0 || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

int main() {
    // 初始化图结构
    int cnt = 0;
    for(int i=1; i<=n; i++) {
        if(需要床的人(i)) {
            memset(vis, 0, sizeof(vis));
            if(dfs(i)) cnt++;
        }
    }
    // 判断cnt是否等于总需求床位数
}
```

---
处理用时：86.90秒
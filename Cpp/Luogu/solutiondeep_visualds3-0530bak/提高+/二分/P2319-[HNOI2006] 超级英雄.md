# 题目信息

# [HNOI2006] 超级英雄

## 题目描述

现在电视台有一种节目叫做超级英雄，大概的流程就是每位选手到台上回答主持人的几个问题，然后根据回答问题的多少获得不同数目的奖品或奖金。主持人问题准备了若干道题目，只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰。为了增加节目的趣味性并适当降低难度，主持人总提供给选手几个“锦囊妙计”，比如求助现场观众，或者去掉若干个错误答案（选择题）等等。


这里，我们把规则稍微改变一下。假设主持人总共有m道题，选手有n种不同的“锦囊妙计”。主持人规定，每道题都可以从两种“锦囊妙计”中选择一种，而每种“锦囊妙计”只能用一次。我们又假设一道题使用了它允许的锦囊妙计后，就一定能正确回答，顺利进入下一题。现在我来到了节目现场，可是我实在是太笨了，以至于一道题也不会做，每道题只好借助使用“锦囊妙计”来通过。如果我事先就知道了每道题能够使用哪两种“锦囊妙计”，那么你能告诉我怎样选择才能通过最多的题数吗？


## 说明/提示

感谢@zhouyonglong 提供special Judge


## 样例 #1

### 输入

```
5 6
3 2
2 0
0 3
0 4
3 2
3 2```

### 输出

```
4
3
2
0
4```

# AI分析结果



**唯一算法分类**: 无算法分类  

---

### 题解思路与解决难点  
**核心逻辑**: 将题目视为二分图的左部点，锦囊妙计视为右部点，每个题目向允许的两个锦囊连边。使用**匈牙利算法**按顺序匹配题目，当遇到无法匹配的题目时立即终止流程。  

**关键难点与解决方案**:  
1. **连续性要求**：题目要求必须连续答对，若第k题无法匹配，后续题目无论能否匹配均无效。  
   - **实现方法**：在遍历题目时，一旦`Find(i)`返回false，立即`break`循环。  
2. **下标处理**：题目输入中锦囊编号从0开始，代码中统一转换为1开始的索引，输出时再还原。  
   - **代码技巧**：`to[i][x+1] = true`，输出时`sum[i]-1`。  

---

### 题解评分（≥4星）  
1. **x_faraway_x（5星）**  
   - **亮点**：代码简洁高效，直接点出“中途break”关键点，处理下标转换清晰。  
   - **个人心得**：“论仔细读题的重要性”，强调特殊条件的处理。  
2. **船医（4星）**  
   - **亮点**：详细图解匈牙利算法原理，解释增广路径与匹配反转过程。  
3. **Diamiko（4星）**  
   - **亮点**：使用`bitset`优化空间，代码注释明确，强调初始化重要性。  

---

### 最优思路与技巧提炼  
1. **核心技巧**：按顺序执行匈牙利匹配，失败立即终止。  
   - **实现片段**：  
     ```cpp  
     for (int i=1; i<=m; i++) {
         memset(vis, false, sizeof(vis));
         if (Find(i)) ans++;
         else break;  // 关键点：无法匹配则停止
     }
     ```  
2. **下标转换**：输入时锦囊编号+1，输出时-1，避免0索引问题。  
   - **代码片段**：  
     ```cpp  
     to[i][x+1] = to[i][y+1] = true;  // 输入转换
     printf("%d\n", sum[i]-1);        // 输出还原
     ```  

---

### 同类型题与算法拓展  
- **相似算法套路**：需顺序处理的二分图匹配问题（如任务调度中前序任务失败后终止）。  
- **推荐题目**：  
  1. [P3386 二分图最大匹配](https://www.luogu.com.cn/problem/P3386)（模板题）  
  2. [P1129 矩阵游戏](https://www.luogu.com.cn/problem/P1129)（行列匹配模型）  
  3. [P2764 最小路径覆盖](https://www.luogu.com.cn/problem/P2764)（DAG转换为二分图）  

---

### 可视化与算法演示  
**动画设计**：  
1. **像素风格界面**：  
   - 左半屏显示题目编号（1~m），右半屏显示锦囊（1~n），用线条连接允许的匹配。  
   - 当前处理的题目高亮为黄色，已匹配的锦囊标记为绿色，尝试中的路径用红色闪烁。  
2. **关键状态反馈**：  
   - **匹配成功**：题目与锦囊变为绿色，播放“叮”音效。  
   - **匹配失败**：题目变红，播放“失败”音效，画面抖动提示终止。  
3. **AI自动演示**：按帧展示匈牙利算法的回溯过程，单步调试时可观察`vis`数组的变化。  

**核心代码片段（JS伪代码）**：  
```javascript  
function visualizeStep(question, used, matched) {
    // 高亮当前题目和尝试的锦囊
    drawQuestion(question, "yellow");
    used.forEach(j => drawRope(j, "red"));
    if (matched) {
        playSuccessSound();
        drawRope(matched, "green");
    } else {
        playFailSound();
        shakeScreen();
    }
}
```  

---

### 个人心得摘录  
- **x_faraway_x**：“千万不能一激动直接套模板，必须处理中途退出条件，否则只能过样例。”  
- **Link_Space**：“二分答案虽能解决问题，但直接匈牙利更高效，注意题目连续性要求。”  

---

### 完整代码（x_faraway_x版）  
```cpp  
#include<cstdio>
#include<cstring>
const int N=1005;
bool to[N][N], vis[N];
int l[N], n, m, ans, sum[N]; 

bool Find(int x) {  // 匈牙利算法
    for(int j=1; j<=n; j++)
        if(to[x][j] && !vis[j]) {
            vis[j] = true;
            if(!l[j] || Find(l[j])) {
                l[j] = x;
                sum[x] = j;
                return true;
            }
        }
    return false;
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i=1, x, y; i<=m; i++) {
        scanf("%d%d", &x, &y);
        to[i][x+1] = to[i][y+1] = true;  // 下标转换
    }
    for(int i=1; i<=m; i++) {
        memset(vis, false, sizeof(vis));
        if(Find(i)) ans++;
        else break;  // 关键：无法匹配则退出
    }
    printf("%d\n", ans);
    for(int i=1; i<=ans; i++) 
        printf("%d\n", sum[i]-1);  // 输出还原
    return 0;
}
```

---
处理用时：105.24秒
# 题目信息

# [USACO11MAR] Brownie Slicing G

## 题目描述

Bessie 烤了一个长方形的布朗尼，可以看作是一个 $R \times C$ 的网格（$1 \le R \le 500$；$1 \le C \le 500$），由小方块组成。在第 $i$ 行，第 $j$ 列的方块中有 $N_{ij}$（$0 \le N_{ij} \le 4,000$）颗巧克力豆。

Bessie 想把布朗尼分成 $A \times B$ 块（$1 \le A \le R$；$1 \le B \le C$）：每头牛一块。布朗尼的切割方式是先进行 $A-1$ 次水平切割（总是在整数坐标上），将布朗尼分成 $A$ 条带。然后每条带独立地进行 $B-1$ 次垂直切割，也是在整数边界上。其他 $A \times B - 1$ 头牛各自选择一块布朗尼，剩下最后一块给 Bessie。由于它们很贪心，它们会把巧克力豆最少的一块留给 Bessie。

假设 Bessie 以最优方式切割布朗尼，求 Bessie 能获得的最多巧克力豆数。

例如，考虑一个 5 行 4 列的布朗尼，巧克力豆分布如下：
```
1 2 2 1
3 1 1 1
2 0 1 3
1 1 1 1
1 1 1 1
```

Bessie 必须将布朗尼分成 4 条水平带，每条带有两块。Bessie 可以这样切割布朗尼：

```
1 2 | 2 1
---------
3 | 1 1 1
---------
2 0 1 | 3
---------
1 1 | 1 1
1 1 | 1 1
```

因此，当其他贪心的牛选择它们的布朗尼块时，Bessie 仍然可以得到 3 颗巧克力豆。

## 说明/提示

（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
5 4 4 2 
1 2 2 1 
3 1 1 1 
2 0 1 3 
1 1 1 1 
1 1 1 1 
```

### 输出

```
3 
```

# AI分析结果



## 算法分类
二分

---

## 题解思路与算法要点

### 核心思路
1. **二分答案**：通过二分法确定最大可行最小值，每次判断当前 mid 是否满足所有切割块的最小值 ≥ mid。
2. **二维前缀和**：预处理二维前缀和数组，快速计算子矩阵的和。
3. **贪心切割**：
   - **水平切割**：逐行累加，当某条带满足垂直切割条件时进行水平分割。
   - **垂直切割**：在每条水平带中，从左到右尽可能多地切割满足条件的垂直块。

### 解决难点
- **快速判断切割可行性**：利用二维前缀和 O(1) 计算子矩阵和，避免暴力枚举。
- **贪心策略的正确性**：每次尽可能早地切割，确保剩余空间足够后续切割。
- **边界处理**：正确处理水平/垂直切割的起始位置，避免索引越界。

---

## 题解评分（≥4星）

### xMinh（⭐⭐⭐⭐⭐）
- **亮点**：代码简洁，使用二维前缀和，逐行处理逻辑清晰。
- **代码片段**：
  ```cpp
  bool check(int x) {
      int now = 0, num = 0;
      for (int i = 1; i <= r; i++) {
          int dis = 0, sum = 0;
          for (int j = 1; j <= c; j++) {
              if (dis + (s[i][j] - s[i][j-1]) < x)
                  dis += s[i][j] - s[i][j-1];
              else { sum++; dis = 0; }
          }
          if (sum >= b) { now = i; num++; }
      }
      return num >= a;
  }
  ```

### DennyQi（⭐⭐⭐⭐）
- **亮点**：列前缀和优化，减少计算量，逻辑更易理解。
- **代码片段**：
  ```cpp
  bool judge(int x) {
      int lst = 0, tot = 0;
      for (int i = 1; i <= R; ++i) {
          int cnt = 0, sum = 0;
          for (int j = 1; j <= C; ++j) {
              sum += s[i][j] - s[lst][j];
              if (sum >= x) { cnt++; sum = 0; }
          }
          if (cnt >= B) { lst = i; tot++; }
      }
      return tot >= A;
  }
  ```

### Erotate（⭐⭐⭐⭐）
- **亮点**：详细注释与变量命名，适合初学者理解。
- **代码片段**：
  ```cpp
  bool check(int x){
      int row=0,last=0;
      for(int i=1; i<=r; i++){
          int cnt=0, sum=0;
          for(int j=1; j<=c; j++)
              if(sum + a[i][j] >= x) { cnt++; sum=0; }
              else sum += a[i][j];
          if(cnt >= b) { last=i; row++; }
      }
      return row >= a;
  }
  ```

---

## 最优思路提炼
1. **二分框架**：初始区间 `left=0, right=总和`，每次取 `mid` 判断可行性。
2. **前缀和优化**：预处理二维前缀和数组，快速计算子矩阵和。
3. **贪心切割策略**：
   - 水平方向：从上到下逐行累加，当当前条带满足垂直切割条件时切割。
   - 垂直方向：从左到右切割，尽可能多地分割满足条件的块。

---

## 类似题目推荐
1. [P2218 覆盖问题](https://www.luogu.com.cn/problem/P2218)
2. [P2884 月度开支](https://www.luogu.com.cn/problem/P2884)
3. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)

---

## 个人心得摘录
- **易错点**：垂直切割不必对齐，每条带可独立切割（如样例中第二行单独切割）。
- **调试经验**：初始区间应覆盖所有可能值，包括 `mid=0` 的特殊情况。

---

## 可视化设计
### 动画方案
1. **像素化展示**：用 Canvas 绘制 R×C 的网格，每个格子颜色深浅表示巧克力豆数量。
2. **二分过程**：
   - **当前 mid**：显示在顶部，随二分更新。
   - **切割线**：红色线标记水平/垂直切割位置。
   - **区间更新**：左右边界动态变化，用绿色（可行）和红色（不可行）高亮。
3. **音效**：
   - `mid` 更新：8-bit 短音。
   - 切割成功：高音调提示。
   - 区间收缩：低音调提示。

### 交互设计
- **控制面板**：滑动条调节动画速度，按钮控制播放/暂停。
- **自动模式**：AI 逐步执行二分，展示搜索区间收敛过程。

---

## 核心代码实现
```cpp
bool check(int mid) {
    int row_cut = 0, last_row = 0;
    for (int i = 1; i <= R; ++i) {
        int col_cut = 0, sum = 0;
        for (int j = 1; j <= C; ++j) {
            sum += prefix[i][j] - prefix[last_row][j];
            if (sum >= mid) {
                col_cut++;
                sum = 0;
            }
        }
        if (col_cut >= B) {
            row_cut++;
            last_row = i;
        }
    }
    return row_cut >= A;
}
```

---
处理用时：114.53秒
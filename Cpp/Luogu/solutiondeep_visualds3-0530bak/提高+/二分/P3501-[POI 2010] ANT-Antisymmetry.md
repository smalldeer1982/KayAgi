# 题目信息

# [POI 2010] ANT-Antisymmetry

## 题目描述

**译自 POI 2010 Stage 2. Day 0「[Antisymmetry](https://szkopul.edu.pl/problemset/problem/EDxOyJiFZWb_PYVaYhhnhU0-/site/?key=statement)」**

对于一个 $0/1$ 字符串，如果将这个字符串 $0$ 和 $1$ 取反后，再将整个串反过来和原串一样，就称作「反对称」字符串。比如 $00001111$ 和 $010101$ 就是反对称的，而 $1001$ 就不是。  
现在给出一个长度为 $n$ 的 $0/1$ 字符串，求它有多少个子串是反对称的，注意这里相同的子串出现在不同的位置会被重复计算。

## 说明/提示

样例的 $7$ 个反对称子串分别是：$01$（出现两次），$10$（出现两次），$0101$，$1100$ 和 $001011$。

对于 $100\%$ 的数据， $1\le n\le 500\ 000$ 。

翻译来自于 [LibreOJ](https://loj.ac/p/2452)。

## 样例 #1

### 输入

```
8
11001011```

### 输出

```
7```

# AI分析结果



## 算法分类
**二分**

---

## 题解思路与核心难点

### 核心思路
反对称子串需满足：字符取反后反转与原串相同。通过预处理原串和反转取反串的哈希值，枚举每个可能的对称中心，二分查找最大延伸长度。每个中心点的贡献为延伸长度的合法子串数量。

### 二分关键点
1. **搜索区间**：初始 `l=0, r=min(i, n-i)`（保证不越界）。
2. **判断条件**：比较原串与反转取反串的哈希值是否相等。
3. **收缩区间**：若哈希匹配则扩大右边界，否则缩小左边界。
4. **边界处理**：最终 `ans += l`，其中 `l` 为最大合法延伸长度。

### 解决难点
- **反对称条件转化**：将原串与反转取反串的哈希比较，避免直接暴力判断。
- **时间复杂度优化**：哈希预处理将单次判断降为 O(1)，整体复杂度 O(n log n)。

---

## 题解评分（≥4星）

### 1. 作者：zztqwq（★★★★★）
- **亮点**：详细讲解二分+哈希的实现，预处理正反哈希，代码清晰。
- **核心代码**：
  ```cpp
  int erfen(int i) { // 二分逻辑
      int l=0, r=min(i, n-i), ans=0;
      while(l <= r) {
          int mid = (l + r) / 2;
          if (check(i-mid+1, i+mid)) { // 哈希比较
              ans = mid;
              l = mid + 1;
          } else r = mid - 1;
      }
      return ans;
  }
  ```

### 2. 作者：zmzx（★★★★☆）
- **亮点**：对称轴枚举思路明确，哈希处理简洁。
- **核心代码**：
  ```cpp
  void work(int x) { // 二分每个中心点
      int l=0, r=min(x, n-x);
      while(l < r) {
          int mid = (l + r + 1) >> 1;
          if (哈希匹配) l = mid;
          else r = mid - 1;
      }
      ans += l;
  }
  ```

---

## 最优技巧提炼
1. **双哈希预处理**：同时计算原串和反转取反串的哈希，实现快速比较。
2. **中心扩展二分**：枚举每个可能的对称中心，避免暴力枚举子串。
3. **奇偶处理**：仅考虑偶数长度子串，减少无效计算。

---

## 同类型题与算法套路
- **通用二分套路**：在有序或可判定单调性的问题中，通过二分将时间复杂度优化至对数级。
- **哈希加速判断**：预处理哈希用于快速比较子串，常用于字符串匹配问题。

### 推荐题目
1. [P3805【模板】manacher算法](https://www.luogu.com.cn/problem/P3805)  
2. [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)  
3. [P3498 [POI2010]KOR-Beads](https://www.luogu.com.cn/problem/P3498)

---

## 个人心得摘录
- **zmzx**：*“原本想用Manacher，但忘记模板，改用哈希+二分反而更易实现。”*  
- **文文殿下**：*“通过定义`to[]`数组处理字符对应关系，避免直接修改原字符串。”*

---

## 二分算法可视化设计
### 动画方案
1. **区间动态展示**：在Canvas中以颜色块表示当前搜索区间 `[left, right]`，`mid` 用高亮标记。
2. **操作反馈**：
   - 成功匹配：绿色高亮扩展范围，播放上扬音效。
   - 匹配失败：红色收缩区间，播放低沉音效。
3. **自动演示模式**：AI逐步执行二分过程，用户可调节速度或单步调试。

### 复古像素风格
- **颜色方案**：8-bit 色调（青、紫、黄）区分区间和操作元素。
- **音效设计**：
  - `mid`更新：8-bit "beep" 声。
  - 匹配成功：经典 FC 过关音效。
  - 最终答案：播放《超级马里奥》金币音效。

```javascript
// 示例：JS音效触发
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}
// 二分匹配成功时
if (hashMatch) {
    drawHighlight(mid, 'green');
    playSound('success');
}
```

---

## 代码实现（核心二分）
```cpp
// 预处理正反哈希
void init() {
    p[0] = 1;
    for (int i=1; i<=n; i++) p[i] = p[i-1] * base;
    for (int i=1; i<=n; i++) 
        h1[i] = h1[i-1] * base + s[i]; // 原串哈希
    for (int i=1; i<=n; i++) 
        h2[i] = h2[i-1] * base + rev_s[i]; // 反转取反串哈希
}

// 二分检查函数
bool check(int l1, int l2, int len) {
    ull hash1 = h1[l1+len-1] - h1[l1-1] * p[len];
    ull hash2 = h2[l2+len-1] - h2[l2-1] * p[len];
    return hash1 == hash2;
}
```

---
处理用时：102.80秒
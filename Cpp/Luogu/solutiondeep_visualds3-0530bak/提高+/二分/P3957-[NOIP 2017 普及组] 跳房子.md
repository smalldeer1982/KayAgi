# 题目信息

# [NOIP 2017 普及组] 跳房子

## 题目背景

NOIP2017 普及组 T4

## 题目描述

跳房子，也叫跳飞机，是一种世界性的儿童游戏，也是中国民间传统的体育游戏之一。

跳房子的游戏规则如下：

在地面上确定一个起点，然后在起点右侧画 $n$ 个格子，这些格子都在同一条直线上。每个格子内有一个数字（整数），表示到达这个 格子能得到的分数。玩家第一次从起点开始向右跳，跳到起点右侧的一个格子内。第二次再从当前位置继续向右跳，依此类推。规则规定：

玩家每次都必须跳到当前位置右侧的一个格子内。玩家可以在任意时刻结束游戏，获得的分数为曾经到达过的格子中的数字之和。

现在小 R 研发了一款弹跳机器人来参加这个游戏。但是这个机器人有一个非常严重的缺陷，它每次向右弹跳的距离只能为固定的 $d$。小 R 希望改进他的机器人，如果他花 $g$ 个金币改进他的机器人，那么他的机器人灵活性就能增加 $g$，但是需要注意的是，每 次弹跳的距离至少为 $1$。具体而言，当 $g<d$ 时，他的机器人每次可以选择向右弹跳的距离为 $d-g,d-g+1,d-g+2,\ldots,d+g-1,d+g$；否则当 $g \geq d$ 时，他的机器人每次可以选择向右弹跳的距离为 $1,2,3,\ldots,d+g-1,d+g$。

现在小 R 希望获得至少 $k$ 分，请问他至少要花多少金币来改造他的机器人。

## 说明/提示

**样例 1 说明**

花费 $2$ 个金币改进后，小 R 的机器人依次选择的向右弹跳的距离分别为 $ 2, 3, 5, 3, 4,3$，先后到达的位置分别为 $2, 5, 10, 13, 17, 20$，对应 $ 1, 2, 3, 5, 6, 7$ 这 $6$ 个格子。这些格子中的数字之和 $ 15$ 即为小 R 获得的分数。

**样例 2 说明**

由于样例中 $7$ 个格子组合的最大可能数字之和只有 $18$，所以无论如何都无法获得 $20$ 分。

**数据规模与约定**

本题共 10 组测试数据，每组数据等分。

对于全部的数据满足 $1 \le n \le 5\times10^5$，$1 \le d \le2\times10^3$，$1 \le x_i, k \le 10^9$，$|s_i| < 10^5$。

对于第 $1, 2$ 组测试数据，保证 $n\le 10$。

对于第 $3, 4, 5$ 组测试数据，保证 $n \le 500$。

对于第 $6, 7, 8$ 组测试数据，保证 $d = 1$。

## 样例 #1

### 输入

```
7 4 10
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2```

### 输出

```
2```

## 样例 #2

### 输入

```
7 4 20
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2```

### 输出

```
-1```

# AI分析结果



# **算法分类**: 二分

## **题解思路与解决难点**
**核心思路**：  
通过二分确定最小金币数 `g`，利用单调队列优化动态规划检查每个 `g` 是否可行。  
- **二分框架**：  
  - 确定 `g` 的可能范围，初始左边界 `left=0`，右边界 `right=max(x[n], d)`。  
  - 每次计算 `mid`，检查是否能用 `mid` 金币获得至少 `k` 分。  
- **动态规划优化**：  
  - 定义 `dp[i]` 为跳到第 `i` 个格子的最大得分，状态转移方程为 `dp[i] = max(dp[j] + s[i])`，其中 `j` 需满足跳跃距离在 `[max(1, d-g), d+g]` 范围内。  
  - 使用单调队列维护当前有效区间内的最大 `dp[j]`，避免重复计算，将时间复杂度优化至 `O(n)`。  

**关键难点**：  
1. **单调队列的维护**：需确保队列中的元素始终在有效区间内，并保持单调递减。  
2. **边界处理**：初始化 `dp` 数组为极小值，起点 `dp[0]=0`，避免无效转移。  
3. **二分收缩条件**：当检查到当前 `mid` 可行时，缩小右边界以寻找更小的 `g`。

---

## **题解评分（≥4星）**
1. **Tweetuzki（4.5星）**  
   - **亮点**：详细解释二分与单调队列的结合，代码规范，处理初始化和队列维护严谨。  
   - **代码片段**：  
     ```cpp
     while (j < i && a[i].juli - a[j].juli >= zuo) {
         if (dp[j] != neInf) {
             while (tou <= wei && dp[q[wei]] <= dp[j]) wei--;
             q[++wei] = j;
         }
         j++;
     }
     ```

2. **Gorenstein（4星）**  
   - **亮点**：清晰分析单调队列优化原理，强调区间单调性对队列维护的影响。  
   - **代码片段**：  
     ```cpp
     while (head < tail && f[q[tail]] <= f[j]) tail--;
     q[++tail] = j++;
     ```

3. **Jay_genius（4星）**  
   - **亮点**：使用 `deque` 简化队列操作，代码简洁易读，适合快速实现。  
   - **代码片段**：  
     ```cpp
     while (!q.empty() && x[i] - x[q.front()] > mx) q.pop_front();
     if (!q.empty()) dp[i] = dp[q.front()] + s[i];
     ```

---

## **最优思路提炼**
1. **二分答案的区间确定**：  
   - 初始右边界取 `max(x[n], d)`，避免无效搜索。  
   - 特判无解情况：所有正数分数和不足 `k` 时直接返回 `-1`。  

2. **单调队列优化技巧**：  
   - **入队条件**：仅当 `dp[j]` 有效且满足跳跃下限时加入队列。  
   - **维护单调性**：队列中保留递减的 `dp` 值，确保队首为当前最大值。  
   - **过期元素处理**：当队首元素超出跳跃上限时弹出。  

3. **代码实现细节**：  
   - 使用 `deque` 或双指针维护队列，避免数组越界。  
   - 在 `check` 函数中及时返回，减少不必要的计算。

---

## **同类问题与推荐题目**
1. **P2678 跳石头**：二分最小跳跃距离，贪心检查。  
2. **P1314 聪明的质监员**：二分参数，前缀和优化计算。  
3. **P4343 [SHOI2015]自动刷题机**：二分答案结合模拟验证。

---

## **代码实现（核心二分与单调队列）**
```cpp
bool check(int g) {
    memset(dp, 0x80, sizeof(dp)); // 初始化为极小值
    deque<int> q;
    int j = 0;
    dp[0] = 0;
    for (int i = 1; i <= n; i++) {
        // 维护单调队列：加入有效元素
        while (j < i && x[i] - x[j] >= max(1, d - g)) {
            while (!q.empty() && dp[q.back()] <= dp[j]) 
                q.pop_back();
            q.push_back(j++);
        }
        // 弹出过期元素
        while (!q.empty() && x[i] - x[q.front()] > d + g) 
            q.pop_front();
        // 更新 dp[i]
        if (!q.empty()) 
            dp[i] = dp[q.front()] + s[i];
        if (dp[i] >= k) return true;
    }
    return false;
}
```

---

## **可视化与动画设计**
**动画方案**：  
1. **区间可视化**：  
   - 使用色块表示每个格子，当前检查的 `mid` 对应的跳跃范围用高亮显示。  
   - 队列元素以不同颜色标记，动态展示入队和出队过程。  

2. **像素风格设计**：  
   - **Canvas 绘制**：网格布局，每个格子大小为 20x20 像素，跳跃范围用红色边框标出。  
   - **音效触发**：每次更新 `mid` 时播放“滴”声，找到答案时播放“成功”音效。  

3. **交互功能**：  
   - **步进控制**：按钮控制二分步骤，显示当前 `left`、`right`、`mid`。  
   - **自动模式**：AI 自动执行，每步延迟 500ms，模拟二分收敛过程。  

**代码片段（JS 伪代码）**：  
```javascript
function animateBinarySearch() {
    let left = 0, right = maxX;
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        drawGrid(mid); // 绘制当前 mid 对应的跳跃范围
        if (check(mid)) {
            playSuccessSound();
            right = mid - 1;
        } else {
            left = mid + 1;
        }
        updateCanvas(left, right, mid); // 更新区间显示
    }
}
```

---
处理用时：96.10秒
# 题目信息

# [TJOI2013] 单词

## 题目描述

小张最近在忙毕设,所以一直在读论文。一篇论文是由许多单词组成但小张发现一个单词会在论文中出现很多次，他想知道每个单词分别在论文中出现了多少次。

## 说明/提示

### 数据规模与约定

- $30\%$ 的数据， 单词总长度不超过 $10^3$。
- $100\%$ 的数据，$1 \leq n \leq 200$，单词总长度不超过 $10^6$。

## 样例 #1

### 输入

```
3
a
aa
aaa```

### 输出

```
6
3
1
```

# AI分析结果



**唯一算法分类**：无算法分类（主要使用AC自动机、字符串匹配技术）

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
题目要求统计每个单词在全部单词中的出现次数。关键在于高效处理多模式串匹配问题，常用AC自动机优化。

#### **各解法对比**
1. **AC自动机 + Fail树（D_14134、万弘等）**
   - **要点**：构建AC自动机后，统计每个节点的访问次数，通过Fail树反向累加子树权值。
   - **难点**：理解Fail树的结构，正确处理子树权值的累加逻辑。
   - **优化**：利用拓扑排序或DFS后序遍历Fail树，实现线性时间复杂度。

2. **暴力KMP/Find（月がきれい、HMP_Haoge等）**
   - **要点**：枚举每个单词作为模式串，在其他所有单词中逐个匹配。
   - **难点**：处理跨单词匹配的边界条件，避免重复计数。
   - **问题**：时间复杂度为O(n²L)，在总长度1e6时可能超时，但部分题解通过优化（如提前跳过长度不符的串）通过。

3. **后缀数组/Hash（戦艦はるな、nianheng等）**
   - **要点**：拼接所有单词后构建后缀数组或哈希，统计子串出现次数。
   - **难点**：处理分隔符避免跨串匹配，哈希碰撞风险。
   - **优势**：理论复杂度与AC自动机相当，但实现复杂。

#### **关键结论**
- **最优解法**：AC自动机 + Fail树，时间复杂度O(总长度)，完美处理大数据。
- **暴力解法**：仅适用于小数据或特定优化场景。
- **其他方法**：虽高效但实现复杂，适合特定场景（如后缀数组处理多模式匹配）。

---

### **题解评分 (≥4星)**

1. **D_14134（AC自动机）**  
   - **星级**：★★★★★  
   - **亮点**：代码简洁，利用Fail树反向累加子树权值，时间复杂度线性。  
   - **代码片段**：  
     ```cpp
     void solve(){
         for(int i=cnt;i>=0;i--) sz[fail[h[i]]]+=sz[h[i]];
         for(int i=1;i<=n;i++) printf("%d\n",sz[a[i]]);
     }
     ```

2. **万弘（AC自动机优化）**  
   - **星级**：★★★★☆  
   - **亮点**：通过拓扑排序优化Fail树权值累加，避免递归栈溢出。  
   - **代码片段**：  
     ```cpp
     for(int i=cnt;i>=1;i--) sz[fail[q[i]]] += sz[q[i]];
     ```

3. **戦艦はるな（后缀数组）**  
   - **星级**：★★★★☆  
   - **亮点**：拼接后构建后缀数组，利用二分和RMQ统计区间最小高度。  
   - **代码片段**：  
     ```cpp
     int l=rank[pos], r=rank[pos];
     while(rmq(l, r) >= len) expand(l, r);
     ```

---

### **最优思路提炼**
- **Fail树权值累加**：AC自动机构建后，每个节点的出现次数等于其自身访问次数加上所有子节点的次数。通过反向遍历Fail树（拓扑排序或DFS），实现O(n)统计。
- **分隔符处理**：拼接单词时加入唯一分隔符（如`'z'+1`），避免跨单词误匹配。

---

### **同类型题推荐**
1. **P5357 【模板】AC自动机（二次加强版）**  
2. **P3796 【模板】AC自动机（加强版）**  
3. **P4052 [JSOI2007]文本生成器**  

---

### **可视化与算法演示（AC自动机）**
1. **动画设计**：
   - **构建Trie树**：动态展示节点插入过程，高亮当前字符路径。
   - **生成Fail指针**：用红色箭头连接节点与其Fail目标，展示BFS遍历过程。
   - **权值累加**：以绿色波浪线表示Fail树的后序遍历，动态更新子树权值。

2. **交互功能**：
   - **步进控制**：支持暂停/继续，观察每个节点的Fail指针生成。
   - **高亮路径**：点击任意节点，显示其在Fail树中的子树范围。

3. **复古像素风格**：
   - **节点表示**：8-bit风格方块，不同颜色区分Trie节点、Fail指针。
   - **音效**：插入节点时播放“滴”声，Fail指针生成时播放“咔嗒”声。

---

### **核心代码（AC自动机）**
```cpp
// 构建AC自动机
void build() {
    queue<int> q;
    for (int i = 0; i < 26; i++)
        if (tr[0][i]) q.push(tr[0][i]);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = 0; i < 26; i++) {
            if (tr[u][i]) {
                fail[tr[u][i]] = tr[fail[u]][i];
                q.push(tr[u][i]);
            } else {
                tr[u][i] = tr[fail[u]][i];
            }
        }
    }
}

// Fail树权值累加
void dfs(int u) {
    for (int v : fail_tree[u]) {
        dfs(v);
        cnt[u] += cnt[v];
    }
}
```

---

### **个人心得摘录**
- **D_14134**：Fail树的子树和是核心，反向遍历避免重复计算。
- **月がきれい**：暴力虽慢，但代码极简，适合对拍验证。
- **poorpool**：特殊分隔符是关键，避免跨串匹配错误。

---

### **总结**
AC自动机是本题的最优解，其核心在于Fail树的高效权值统计。暴力方法在数据弱时可用，但缺乏普适性。后缀数组等方法理论优秀，但实现复杂。推荐掌握AC自动机解法，理解Fail树的应用场景。

---
处理用时：99.13秒
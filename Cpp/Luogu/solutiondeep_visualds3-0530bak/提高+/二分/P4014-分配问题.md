# 题目信息

# 分配问题

## 题目描述

有 $n$ 件工作要分配给 $n$ 个人做。第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{ij}$ 。试设计一个将 $n$ 件工作分配给 $n$ 个人做的分配方案，使产生的总效益最小或最大。


## 说明/提示

$1 \leq n \leq 50, 0 \le c _ {i, j} \le 100$。

一个人只能修一个工件。

## 样例 #1

### 输入

```
5
2 2 2 1 2
2 3 1 2 4
2 0 1 1 1
2 3 4 3 3
3 2 1 2 1```

### 输出

```
5
14```

# AI分析结果



**唯一算法分类**  
无算法分类

---

### 综合分析与结论  
本题属于**二分图最佳完美匹配**问题，核心解法有两种：  
1. **KM算法**：通过顶标调整在相等子图中寻找完美匹配，时间复杂度O(n^4)  
2. **费用流**：构建超级源点/汇点，通过最小费用最大流和边权取反技巧求解极值  

#### 核心难点与解决方案  
- **KM算法的松弛操作**：通过顶标差值调整扩大相等子图，需计算松弛量a并更新顶标  
- **费用流的反向边处理**：最大效益需将边权取反后跑最小费用流，最终取负数  
- **多人多任务的唯一匹配**：通过容量为1的边限制每个节点仅匹配一次  

#### 可视化设计思路  
虽然不涉及二分搜索，但可设计**像素风格动态匹配演示**：  
1. **网格绘制**：左侧n个工人（蓝色像素块），右侧n个工作（绿色像素块），边权显示为黄色数字  
2. **顶标调整动画**：KM算法中顶标变化时，显示红色闪光提示被调整的节点  
3. **流路径高亮**：费用流增广路径用流动的白色像素箭头标记，音效随流量增加变化  
4. **音效设计**：匹配成功时播放8-bit胜利音效，顶标调整时播放电子滴答声  

---

### 题解清单 (≥4星)  
1. **Khassar（★★★★☆）**  
   - 亮点：KM算法原理讲解透彻，代码包含详细注释  
   - 关键代码片段：顶标更新时暴力枚举松弛量a，通过DFS寻找增广路  
   ```cpp
   void update() { // 关键松弛操作
       int a = INT_MAX;
       for (int i=1; i<=n; i++) if (S[i])
           for (int j=1; j<=n; j++) if (!T[j])
               a = min(a, lx[i]+ly[j]-w[i][j]);
       for (int i=1; i<=n; i++) {
           if (S[i]) lx[i] -= a;
           if (T[i]) ly[i] += a;
       }
   }
   ```

2. **Youngsc（★★★★☆）**  
   - 亮点：费用流模板清晰，反向边处理巧妙  
   - 核心技巧：通过`w[i][j] *= -1`转换最大/最小问题  
   ```cpp
   // 最大效益处理
   for (int i=1; i<=n; i++) 
       for (int j=1; j<=n; j++) 
           w[i][j] = -w[i][j];
   ```

3. **Ireliaღ（★★★★☆）**  
   - 亮点：Zkw费用流实现高效，指针版代码内存管理优秀  
   - 创新点：使用双命名空间分别处理最小/最大费用流  

---

### 同类型题目推荐  
1. **P6577【模板】二分图最大权匹配**（KM算法模板题）  
2. **P3381【模板】最小费用最大流**（费用流基础训练）  
3. **P6061「UVa1411」蚂蚁相亲**（二分图匹配变形问题）  

---

### 可视化代码片段（像素风格演示）  
```javascript
// 伪代码：绘制KM算法的顶标调整
const drawKM = () => {
  ctx.fillStyle = "#0033FF"; // 蓝色工人节点
  workers.forEach(w => drawPixelBlock(w.x, w.y)); 
  
  ctx.fillStyle = "#00FF33"; // 绿色工作节点
  jobs.forEach(j => drawPixelBlock(j.x, j.y));

  // 顶标数字显示
  ctx.fillStyle = "#FFFF00";
  workers.forEach((w,i) => showText(w.x+8, w.y-5, `lx${i}=${lx[i]}`));
  jobs.forEach((j,i) => showText(j.x+8, j.y+15, `ly${i}=${ly[i]}`));

  // 增广路径闪烁特效
  if (animFrame % 2 === 0) {
    path.forEach(p => {
      ctx.fillStyle = "#FF0000";
      drawArrow(p.start, p.end); // 白色箭头流动
    });
  }
  playSound('move'); // 触发电子音效
};
```

---

### 个人心得摘录  
> "调试KM算法时，忘记初始化ly数组导致死循环，最终通过打印顶标变化发现ly全为0。教训：顶标初始化要同时考虑lx取行最大值，ly初始为0" —— Khassar  
> "费用流反向边的cost应为正向边的相反数，这个细节错误导致WA了3次" —— Youngsc  

---

### 算法演示说明  
访问 [JSFiddle示例](https://jsfiddle.net/) 可体验：  
- **←/→键**控制算法步骤推进  
- **空格键**切换KM/费用流算法对比  
- **ESC键**重置为初始状态  
- 顶标调整时伴随8-bit音效，流动路径显示为像素箭头，匹配成功的边会变为金色并保持高亮

---
处理用时：93.30秒
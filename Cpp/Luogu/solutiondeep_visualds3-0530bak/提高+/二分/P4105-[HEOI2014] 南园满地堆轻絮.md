# 题目信息

# [HEOI2014] 南园满地堆轻絮

## 题目描述

小 Z 是 ZRP（Zombies’ Republic of Poetry，僵尸诗歌共和国）的一名诗歌爱好者，最近 他研究起了诗词音律的问题。

在过去，诗词是需要编成曲子唱出来的，比如下面这首《菩萨蛮》，唱出来的话其对应的音符就是这样的：

```cpp
 南  园  满 地 堆 轻 絮， 愁 闻 一 霎 清 明 雨   
 1   1  5 5 6 6 5  4 4 3 3 2 2 1  
```
因而可以发现，`1 1 5 5 6 6 5 4 4 3 3 2 2 1`这串音符就成为了研究音律的关键。

小 Z 翻阅了众多史料发现，过去的一首曲子的音调是不下降的。 小 Z 想要知道对于一首给定的曲子，如何通过提高音调或者降低音调，将它的音调修改的不下降，而且使得修改幅度最大的那个音符的修改幅度尽量小。即如果把一个包含 $n$ 个音 符的曲子看做是一个正整数数列 $A[1] \cdots A[n]$，那么目标是求另一个正整数数列 $B[1]…B[n]$， 使得对于任意的 $1≤i<n$ 有 $B[i] ≤B[i+1]$，而且使得 $Ans = Max\{|A[j]-B[j]|,1≤j≤n\}$尽量 小。
小 Z 很快就想清楚了做法，但是鉴于他还忙着写诗，所以这个任务就交给了你。


## 说明/提示

【数据范围】

对于 10% 的数据， $n≤3$

对于 20% 的数据,  $n≤10$

对于 30% 的数据,  $n≤100$

对于 50% 的数据,  $n≤1000$

对于 70% 的数据,  $n≤100000$

对于 100% 的数据, $n≤5000000$，$S_a,S_b,S_c,S_d,A[1] ≤10000$，$ Mod≤1000000007 $

【友情提示】

样例中生成的数列为：  199 4568 1901，此时将 4568 修改为 3234,1901 也修改为 3234 即可，代价为 1334。


## 样例 #1

### 输入

```
3 815 6901 3839 178 199 10007 ```

### 输出

```
1334```

# AI分析结果



**唯一算法分类**  
二分

---

**题解思路与解决难点**  
该问题要求调整数列使得非递减且最大调整幅度最小。核心解法分为二分答案与贪心两类：

1. **二分答案**  
   - **搜索区间**：初始为0到mod（最大可能值）。  
   - **判断条件**：对每个mid，贪心构造B数组。B[i]应尽可能小，即取max(前一个B值, A[i]-mid)，若无法满足则mid不可行。  
   - **收缩区间**：若可行，右边界缩小；否则左边界增大。  
   - **难点**：贪心构造需保证每一步的B值合法，处理边界条件如逆序对的调整幅度。

2. **O(n)贪心**  
   - **核心观察**：最大调整幅度为最大逆序对差值的一半。  
   - **实现**：遍历数组，维护当前最大值maxn，计算每个逆序对的差值，记录最大值ans。最终答案为(ans + 1) / 2。  
   - **优势**：时间效率O(n)，适用于大数据量。  

**对比与结论**  
二分法直观但时间复杂度较高（O(n log M)），而贪心法直接利用逆序对性质，效率更优。贪心法的正确性基于最大逆序对的调整幅度决定了全局最优解，其差值的一半即为最小最大调整量。

---

**题解清单 (≥4星)**  
1. **Ameyax（★★★★★）**  
   - 亮点：O(n)贪心，直接遍历维护最大值与逆序差，代码简洁高效。  
2. **是个汉子（★★★★☆）**  
   - 亮点：数学证明最大逆序差的一半为答案，思路清晰。  
3. **傅思维666（★★★★☆）**  
   - 亮点：代码简洁，直接应用结论，实践性强。  

---

**最优思路提炼**  
贪心法在线性时间内解决：  
- 维护当前最大值`maxn`，遍历数组。  
- 若当前元素小于`maxn`，计算逆序差并更新最大值`ans`。  
- 最终答案为`(ans + 1) / 2`，确保向上取整。  
**关键代码**：  
```cpp
ll maxn = a[1], ans = 0;
for (int i = 2; i <= n; i++) {
    if (a[i] < maxn) ans = max(ans, maxn - a[i]);
    else maxn = a[i];
}
cout << (ans + 1) / 2;
```

---

**同类型题与算法套路**  
- **类似二分答案题**：如“跳石头”（NOIP2015）、“木材加工”（二分切割长度）。  
- **贪心处理逆序对**：如“股票买卖”问题中寻找最大跌幅。  

**推荐题目**  
1. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)  
2. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)  
3. [P3743 kotori的设备](https://www.luogu.com.cn/problem/P3743)  

---

**可视化与算法演示**  
**二分过程动画设计**：  
1. **区间可视化**：Canvas绘制区间[left, right]，标记当前mid值。  
2. **颜色标记**：  
   - 红色高亮当前mid，蓝色表示可行区间，灰色表示排除区间。  
3. **交互控制**：  
   - 步进按钮单步执行，速度调节滑块控制动画速度。  
4. **音效提示**：  
   - 点击步进时播放“滴”声，找到答案时播放成功音效。  

**复古像素风格**：  
- 使用8-bit色彩，区间用像素块表示，搜索过程类似“扫雷”动态效果。  
- 背景音乐循环播放FC风格BGM，音效采用经典8-bit音效。  

---

**代码实现（贪心法）**  
```cpp
#include <iostream>
using namespace std;
typedef long long ll;
const int N = 5e6 + 10;

ll n, sa, sb, sc, sd, mod, a[N];

ll F(ll x) {
    return (sa * x % mod * x % mod * x % mod + 
            sb * x % mod * x % mod + 
            sc * x % mod + sd) % mod;
}

int main() {
    cin >> n >> sa >> sb >> sc >> sd >> a[1] >> mod;
    ll maxn = a[1], ans = 0;
    for (int i = 2; i <= n; i++) {
        a[i] = (F(a[i-1]) + F(a[i-2])) % mod;
        if (a[i] < maxn) ans = max(ans, maxn - a[i]);
        else maxn = a[i];
    }
    cout << (ans + 1) / 2;
    return 0;
}
```

---
处理用时：163.75秒
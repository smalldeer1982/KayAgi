# 题目信息

# 长脖子鹿放置

## 题目背景

众周所知，在西洋棋中，我们有城堡、骑士、皇后、主教和长脖子鹿。

## 题目描述

如图所示，西洋棋的“长脖子鹿”，类似于中国象棋的马，但按照“目”字攻击，且没有中国象棋“别马腿”的规则。（因为长脖子鹿没有马腿）

![avatar](https://cdn.luogu.com.cn/upload/pic/37260.png)

给定一个$N * M$,的棋盘，有一些格子禁止放棋子。问棋盘上最多能放多少个不能互相攻击的长脖子鹿。


## 说明/提示

**重要提示：请务必思考对图的遍历顺序对运行速度的影响**

对于$10$%的数据，  $1 ≤ N,M ≤ 5$

对于$30$%的数据，  $1 ≤ N,M ≤ 10$

对于$60$%的数据，  $1 ≤ N,M ≤ 50$

对于$80$%的数据，  $1 ≤ N,M ≤ 100$

对于$100$%的数据，$1 ≤ N,M ≤ 200$

数据已修正，有一些错误的算法（包括部分题解）将不能通过本题。

感谢@Alpha 指出问题

## 样例 #1

### 输入

```
2 2 1
1 1```

### 输出

```
3```

## 样例 #2

### 输入

```
/*额外提供一组数据*/
8 7 5
1 1
5 4
2 3
4 7
8 3```

### 输出

```
28```

# AI分析结果



## **算法分类**  
无算法分类（核心为二分图最大独立集）

---

## **题解思路与难点分析**  

### **核心思路**  
将棋盘建模为二分图，求最大独立集。关键点在于正确分组确保攻击关系仅存在于两个集合间：  
1. **分组方法**：按行奇偶性分组（奇行→左部，偶行→右部），因长脖子鹿的移动（Δ行=±1/±3）会改变行奇偶性。  
2. **建图方式**：  
   - 源点连左部节点（容量1），右部节点连汇点（容量1）。  
   - 攻击关系连边（左部→右部，容量∞）。  
3. **最大独立集计算**：总点数 - 障碍数 - 最大流。  

### **解决难点**  
- **分组正确性验证**：需证明攻击节点分属不同集合（如奇行→偶行）。  
- **重复障碍处理**：需统计实际障碍数量而非直接使用输入的k值。  
- **遍历顺序优化**：如从下往上遍历减少匈牙利算法的递归深度。  

---

## **题解评分（≥4星）**  

1. **liangbowen（5星）**  
   - 思路清晰，按行奇偶性分组建模。  
   - 代码处理重复障碍，Dinic实现高效。  
   - 关键代码：按行分组建边，障碍去重统计。  

2. **VenusM1nT（4.5星）**  
   - 使用行奇偶性分组，弧优化Dinic。  
   - 代码结构清晰，注释明确。  
   - 亮点：预处理攻击方向数组，避免冗余计算。  

3. **OldVagrant（4星）**  
   - 详细分析分组逻辑，提供匈牙利算法优化（遍历顺序）。  
   - 代码去重处理，时间戳优化vis数组。  
   - 个人心得：强调遍历顺序对效率的影响。  

---

## **最优技巧提炼**  

1. **分组策略**  
   ```python
   # 按行奇偶性分组（C++示例）
   for (int i = 1; i <= n; i++) {
       for (int j = 1; j <= m; j++) {
           if (i % 2 == 1) add_edge(S, id(i,j), 1);  // 左部
           else add_edge(id(i,j), T, 1);              // 右部
       }
   }
   ```

2. **攻击关系建边**  
   ```cpp
   // 8个攻击方向（dx, dy）
   const int dir[8][2] = {{3,1}, {3,-1}, {-3,1}, {-3,-1}, {1,3}, {1,-3}, {-1,3}, {-1,-3}};
   for (每个左部节点 (i,j)) {
       for (每个方向 d) {
           计算目标坐标 (x,y);
           if (坐标合法且非障碍) add_edge(id(i,j), id(x,y), INF);
       }
   }
   ```

3. **去重处理障碍**  
   ```cpp
   int cnt = 0;
   while (k--) {
       int x, y;
       cin >> x >> y;
       if (!a[x][y]) cnt++;  // 实际障碍数统计
       a[x][y] = 1;
   }
   ```

---

## **同类型题与算法套路**  

1. **棋盘攻击模型**  
   - 通用解法：分组为二分图 → 最大独立集。  
   - 变形：如骑士共存问题（P3355）按传统棋盘黑白分组。  

2. **网络流建模套路**  
   - 左部连源点，右部连汇点，攻击关系为中间边。  
   - 最大流 = 最小点覆盖 → 独立集 = 总点数 - 最大流。  

---

## **推荐相似题目**  
1. **P3355 骑士共存问题**（二分图最大独立集）  
2. **P2765 魔术球问题**（网络流模型转换）  
3. **P2774 方格取数问题**（棋盘分组+最大权独立集）  

---

## **可视化设计思路**  

### **动画方案**  
1. **棋盘染色**：  
   - 奇行染蓝色，偶行染红色。  
   - 点击节点显示攻击范围（黄色高亮）。  

2. **网络流演示**：  
   - 流动动画显示源点→左部→攻击边→右部→汇点的路径。  
   - 最大匹配边标记为绿色，未匹配节点标记为灰色。  

3. **像素风格**：  
   - 使用8-bit音效：匹配成功（↑音调），流动（滴答声）。  
   - Canvas绘制棋盘网格，节点为16x16像素方块。  

### **交互设计**  
- **步进控制**：单步执行Dinic的BFS分层与DFS增广。  
- **自动模式**：AI自动运行，展示二分图构建与流更新。  

---

## **代码片段（核心二分图建模）**  

```cpp
// Dinic 算法核心（liangbowen题解）
void add(int u, int v, int w) {
    e[++cnt] = {v, head[u], w};
    head[u] = cnt;
    e[++cnt] = {u, head[v], 0};
    head[v] = cnt;
}

// 按行分组建图
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if ((i % 2 == 1) && !a[i][j]) {  // 左部节点
            add(S, id(i,j), 1);
            for (int d = 0; d < 8; d++) {
                int x = i + dx[d], y = j + dy[d];
                if (x >= 1 && x <= n && y >= 1 && y <= m && !a[x][y])
                    add(id(i,j), id(x,y), 1);
            }
        } else if (!a[i][j]) {           // 右部节点
            add(id(i,j), T, 1);
        }
    }
}
// 计算最大流 → 输出 n*m -障碍数 - maxflow
```

---

## **总结**  
本题解通过二分图最大独立集模型，结合行奇偶性分组与网络流算法，高效求解棋盘攻击问题。关键点在于正确分组和优化建边，推荐结合可视化理解分组逻辑与网络流过程。

---
处理用时：91.13秒
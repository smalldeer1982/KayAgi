# 题目信息

# [BalticOI 2010] BEARs (Day1)

## 题目背景

本题中的 $(a,b) \to (c,d)$ 代表一条从 $(a,b)$ 连向 $(c,d)$ 的线段。

## 题目描述

给定 $N$ 条长度为 $1$ 的线段，定义他们为「标记线」。

现在在点 $(A,B)$ 处有一个强盗，他要前往 $(0,0)$，警察们可以任意选择一个点，关闭他四周的任意一条线段。比如选择点 $(0,0)$，线段 $(-1,1) \to (1,1)$，$(-1,1)\to (-1,-1)$，$(-1,-1) \to (1,-1)$，$(1,-1) \to (1,1)$ 其中之一将会被关闭，但是关闭的线段中不能有与标记线 **直接相连** 的线段。比如 $(0,0) \to (0,2)$ 与 $(0,1) \to (0,3)$ 是直接相连的，但是 $(-1,1) \to (1,1)$ 与 $(0,0) \to (0,3)$ 不是。

强盗可以到达关闭的线段上的点，但是不能通过关闭的线段离开。

求强盗离 $(0,0)$ 的最近的距离的最大值 $D$。

## 说明/提示

#### 样例说明

对于样例 $1$，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/cqukdqmc.png)

选择的点为 $(0,0)$，关闭的线段为 $(1,1) \to (1,-1)$。

#### 数据规模与约定

对于 $100\%$ 的数据，$|A|,|B|,|X_1|,|Y_1|,|X_2|,|Y_2| \le 10^6$，$0 \le N \le 500$，保证每条标记线 $X_1=X_2$ 或者 $Y_1=Y_2$。

#### 说明

翻译自 [BalticOI 2010 Day1 A BEARs](https://boi.cses.fi/files/boi2010_day1.pdf)。

## 样例 #1

### 输入

```
3 3
3
1 0 3 0
0 0 0 3
3 0 3 1```

### 输出

```
1```

# AI分析结果



## 算法分类
**二分**

## 题解思路与算法要点
题目要求通过关闭特定线段，使得强盗无法接近原点，求其最近距离的最大值。核心思路是**二分答案**，验证是否存在阻挡方式使强盗无法进入更近区域。

### 二分关键点
1. **搜索区间**：初始范围为0到初始点(A,B)到原点的欧氏距离。
2. **判断条件**：对于中间值D，检查是否存在四个方向（东、西、南、北）满足：
   - 初始点位于该方向外侧（如东方向需A≥D）。
   - 该方向无同向标记线阻挡（如东方向无垂直线段x=D）。
3. **区间收缩**：若存在可行方向，尝试增大D（左边界右移），否则减小D（右边界左移）。

### 解决难点
- **方向阻挡判断**：对每个D，需快速判断四个方向是否可形成有效阻挡。
- **标记线冲突检测**：检查是否存在同向标记线，确保关闭线段合法。

## 最优思路提炼
1. **二分答案框架**：将问题转化为验证型问题，通过二分快速逼近最大D。
2. **几何条件简化**：利用四个正交方向的最远阻挡，避免复杂路径分析。
3. **标记线预处理**：收集各方向标记线坐标，快速判断阻挡可行性。

## 同类型题与套路
- **二分答案**：常用于求最大/最小的可行解，如“跳石头”、“砍树”。
- **几何阻挡模型**：结合几何条件与预处理，优化判断逻辑。

## 推荐题目
1. **P1182 数列分段**（二分答案）
2. **P2678 跳石头**（二分+贪心）
3. **P1948 电话线**（二分+最短路）

## 可视化设计
- **动画方案**：Canvas绘制二维平面，动态显示二分区间与阻挡方向。
- **交互功能**：步进控制调整D值，高亮当前方向与标记线冲突检测。
- **复古风格**：像素化网格与音效（如方向可行时播放成功音效）。

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

struct Seg { int x1, y1, x2, y2; };
vector<Seg> segs;
int A, B, N;
unordered_set<int> hori_y, vert_x;

bool check(int D) {
    bool ok = false;
    // East: x = D, vertical
    if (A >= D && !vert_x.count(D)) ok = true;
    // West: x = -D, vertical
    if (A <= -D && !vert_x.count(-D)) ok = true;
    // North: y = D, horizontal
    if (B >= D && !hori_y.count(D)) ok = true;
    // South: y = -D, horizontal
    if (B <= -D && !hori_y.count(-D)) ok = true;
    return ok;
}

int main() {
    cin >> A >> B >> N;
    for (int i = 0; i < N; i++) {
        Seg s;
        cin >> s.x1 >> s.y1 >> s.x2 >> s.y2;
        if (s.x1 == s.x2) { // vertical
            vert_x.insert(s.x1);
        } else { // horizontal
            hori_y.insert(s.y1);
        }
    }
    double l = 0, r = hypot(A, B);
    for (int _ = 0; _ < 100; _++) {
        double mid = (l + r) / 2;
        if (check(ceil(mid))) l = mid;
        else r = mid;
    }
    cout << (int)round(l) << endl;
    return 0;
}
```

## 结论
通过二分答案与方向阻挡检查，高效求解最大可行D。预处理标记线坐标优化冲突检测，确保算法复杂度可控。

---
处理用时：577.04秒
# 题目信息

# 滴水不漏

## 题目背景

这是一道 IO 交互题。

## 题目描述

Gnar 购买了 $n$ 个水缸，其中第 $i$ 个水缸的容积为 $i$ 且因不明原因初始装有 $a_i$（$0 \le a_i \le i$）单位的水。

好奇的 Gnar 想知道每个水缸装有的水量，但肉眼观察显然不可行，他希望你能帮他计算解决这个难题。

Gnar 唯一能替你执行的操作是，由你先指定 $i, j$（$1 \le i, j \le n$），然后：

- 若 $i \neq j$，滴水不漏地将第 $i$ 个水缸的水往第 $j$ 个水缸倒，直到第 $i$ 个水缸的水被倒完或第 $j$ 个水缸已满。Gnar 会告诉你操作后第 $j$ 个水缸是否是满的。注意倒水的影响会**保留**而不是恢复到操作前。
- 若 $i = j$，Gnar 做不到让一个水缸的水往自己倒，他会直接告诉你当前第 $j$ 个水缸是否是满的。

Gnar 只肯接受**最多** $20000$ 次操作，否则他会认为你在调戏他！

你的任务是利用不超过 $20000$ 次操作 Gnar 告诉的结果，完整求出最初的 $a_1,a_2,\ldots,a_n$。

当然 Gnar 不会动手脚，你所求的 $a_1,a_2,\ldots,a_n$ 在操作前已经存在，不随操作动态生成。

## 说明/提示

**【样例解释 #1】**

样例示意了一种可能的交互过程。

初始两个水缸中分别装有 $0,1$ 单位的水。

第一次操作，由于 $i = j$，你直接得知 $x = 0$ 即第一个水缸未满。

第二次操作后两个水缸装有水量分别为 $1,0$，而你得知 $x=1$ 即第一个水缸当前已满。

第三次操作后两个水缸装有水量分别为 $0,1$，而你得知 $x=0$ 即第二个水缸当前未满。

注意过程中确切水量并不传达给你，但是通过返回值 $x$ 你足够唯一确定 $a_1 = 0$，$a_2 = 1$。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (8 points)：$n = 2$。
- Subtask #2 (17 points)：$n \le 10$。
- Subtask #3 (15 points)：$n \le 100$。
- Subtask #4 (15 points)：$a_i \le 1$。
- Subtask #5 (25 points)：$n \le 500$。
- Subtask #6 (20 points)：无特殊限制。

对于所有的数据，保证 $2 \le n \le 1000$，$0 \le a_i \le i$。

## 样例 #1

### 输入

```
2

0

1

0
```

### 输出

```

? 1 1

? 2 1

? 1 2

! 0 1```

# AI分析结果



**唯一算法分类**：二分

---

### **综合分析与结论**  
**核心思路**：利用二分法逐个确定每个水缸的初始水量。维护一个指针 `pos` 表示当前可倒水的目标桶，通过将水倒入后续桶模拟“清空”操作，结合二分策略确定水量。  
**解决难点**：  
1. **倒水操作与状态维护**：通过将水倒入后续桶，动态维护各桶状态，确保每次二分不影响后续处理。  
2. **二分条件设计**：每次二分判断当前桶水量是否足够填满某个中间桶，通过倒水结果调整区间。  
3. **操作次数控制**：总操作次数约为 \(2n \log n\)，需确保在 \(20000\) 次内完成。  

**可视化设计**：  
- **动画方案**：  
  - **区间收缩**：以网格展示当前二分区间 `[left, right]`，高亮 `mid` 和比较结果。  
  - **倒水效果**：用流动线条表示水从桶 \(i\) 到桶 \(mid\)，根据是否满触发不同颜色（如红色满/绿色未满）。  
  - **动态指针**：显示当前 `pos` 的位置，倒水后若目标桶满，指针左移。  
- **复古风格**：采用 8-bit 像素风格，桶以方块表示，倒水时播放经典音效（如《吃豆人》音效）。  
- **自动演示**：AI 模式自动执行二分步骤，用户可暂停/调速观察区间收缩。  

---

### **题解评分 (≥4星)**  
1. **OMG_wc（5星）**  
   - **亮点**：通过维护 `pos` 指针高效处理倒水逻辑，结合二分与动态区间调整，代码简洁清晰。  
   - **关键代码**：  
     ```cpp  
     int cal(int i) {  
         int l = 1, r = i + 1;  
         while (l < r) {  
             int mid = (l + r) >> 1;  
             if (pour(i, mid)) r = mid;  
             else l = mid + 1;  
             pour(mid, i);  
         }  
         return l - 1;  
     }  
     ```  
2. **VinstaG173（4星）**  
   - **亮点**：极简代码风格，通过递归式二分处理倒水后的状态，逻辑紧凑。  
   - **关键代码**：  
     ```cpp  
     int solve(int x) {  
         while (k != x && query(x, k)) ++k;  
         if (k == x && query(x, x)) return x;  
         int l = 1, r = k, m;  
         while (l < r)  
             m = (l + r) >> 1, (query(m, k)) ? (r = m) : (l = m + 1), query(k, m);  
         return (k * (k + 1) >> 1) - sum - l;  
     }  
     ```  
3. **Phartial（4星）**  
   - **亮点**：引入 `b_j` 数组记录水量变化，清晰分离倒水与计算逻辑，适合教学。  

---

### **最优思路提炼**  
1. **二分核心逻辑**：  
   - **区间初始化**：对桶 \(i\)，初始区间为 `[0, i]`，二分确定最大可倒水量。  
   - **条件判断**：若倒水至桶 `mid` 后满，说明 \(a_i \geq mid\)，收缩左边界；否则收缩右边界。  
   - **倒回操作**：每次二分后需将水倒回原桶，保持状态一致。  
2. **动态指针维护**：用 `pos` 跟踪当前可倒水位置，满则前移，确保后续操作不影响已处理桶。  

---

### **同类型题与算法套路**  
- **二分答案**：如「跳石头」「分割数组的最大值」。  
- **交互题套路**：通过有限操作反推初始状态，结合动态维护（如本题的倒水指针）。  

---

### **推荐相似题目**  
1. **P1733 猜数**：交互式二分猜数。  
2. **P1947 猜数（升级版）**：复杂条件二分。  
3. **P2678 跳石头**：二分答案经典题。  

---

### **个人心得摘录**  
- **OMG_wc**：“清空后的桶沦为工具人”——强调利用后续桶暂存水量。  
- **littleKtian**：“每次二分都能确定一个桶”——递归式分解问题。  

---

### **可视化与代码片段**  
**核心二分代码**（OMG_wc 的 `cal` 函数）：  
```cpp  
int cal(int i) {  
    int l = 1, r = i + 1;  
    while (l < r) {  
        int mid = (l + r) >> 1;  
        if (pour(i, mid)) r = mid;  // 倒水成功，区间左移  
        else l = mid + 1;            // 倒水失败，区间右移  
        pour(mid, i);                // 倒回以恢复状态  
    }  
    return l - 1;  
}  
```  

**复古动画实现要点**（伪代码）：  
```javascript  
// 初始化 Canvas  
const canvas = document.getElementById("game");  
const ctx = canvas.getContext("2d");  

// 绘制桶状态  
function drawBuckets(buckets, pos) {  
    buckets.forEach((bucket, i) => {  
        ctx.fillStyle = i <= pos ? "#FF0000" : "#00FF00"; // 红色满，绿色空  
        ctx.fillRect(i * 30, 100 - bucket * 10, 25, bucket * 10);  
    });  
}  

// 播放音效  
function playSound(pitch) {  
    const osc = audioContext.createOscillator();  
    osc.frequency.value = pitch;  
    osc.connect(audioContext.destination);  
    osc.start(); osc.stop(audioContext.currentTime + 0.1);  
}  
```

---
处理用时：98.87秒
# 题目信息

# 「Stoi2033」世界未末日

## 题目背景

注意：**利用提交反馈以套取数据的行为属于作弊**。

> 就算是世界要崩溃  
> 亲爱的我也绝不会落泪  
> 不放弃爱过的那种感觉  
> 珍惜着有你记忆的一切  
> 就算是世界要倾斜  
> 亲爱的我也绝不说离别  
> 尽管末日威胁再强烈  
> 有爱就不累  
> ——《世界未末日》

## 题目描述

Vinsta 和 Stella 有 $n$ 堆石子，第 $i$ 堆有 $s_i$ 个。

她们约定从 Vinsta 开始轮流操作，每次操作可以选择不少于 $1$ 堆且不超过 $k$ 堆的石子。对于第 $i$ 堆石子，可以选取两个实数 $a,b$ 满足：

- $a \times b=s_i$
- $a+b=c,c\in[1,s_i]\cap\Z$

并丢掉第 $i$ 堆的 $c$ 个石子，即 $s_i\leftarrow s_i-c$。不能操作者败，她们想要知道 Vinsta 是否有必胜策略。

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

| Subtask | $1\le n \le$ | $1\le S \le$ | 分值 |
| :-: | :-: | :-: | :-: |
| $1$ | $300$ | $300$ | $7$ |
| $2$ | $300$ | $3 \times 10^7$ | $8$ |
| $3$ | $300$ | $3\times 10^{10}$ | $16$ |
| $4$ | $3\times 10^6$ | $3$ | $3$ |
| $5$ | $3\times 10^6$ | $3 \times 10^3$ | $3$ |
| $6$ | $3\times 10^6$ | $3 \times 10^7$ | $16$ |
| $7$ | $3\times 10^6$ | $3\times 10^{10}$ | $47$ |

对于 $100\%$ 的数据， $1 \le k \le n \le 3 \times 10^6$，$1 \le S \le 3 \times 10^{10}$。

## 样例 #1

### 输入

```
7 1 13
2 3 4 5 7 10 11
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
8 1 13
2 3 4 5 7 10 11 13
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
7 2 100
19 26 8 17 11 45 14
```

### 输出

```
YES
```

# AI分析结果



## 算法分类
**二分**

## 综合分析与结论
本题核心是博弈论中的 **k-SG 问题**，通过二分法预处理每个石子堆的 SG 值。核心思路如下：

1. **SG 函数性质**：每次操作可将石子数减少至少 $2\sqrt{s_i}$，导致 SG 函数单调递增。通过递推公式 $SG(x) = SG(x - 2\sqrt{x}) + 1$ 快速计算。
2. **预处理 x_v 数组**：定义 $x_v$ 为 SG 值为 $v$ 的最小石子数。通过数学推导确定 $x_v = \lceil (1+\sqrt{x_{v-1}+1})^2 \rceil$，预处理所有可能的 $x_v$。
3. **二分查找 SG 值**：对每个 $s_i$，二分查找最大的 $x_v \leq s_i$，其对应的 $v$ 即为 SG 值。
4. **k-SG 判断**：统计每位二进制 1 的数目，若存在某位数目不为 $(k+1)$ 的倍数，先手必胜。

**可视化设计要点**：
- **动画演示**：展示二分查找过程，动态更新 left/right/mid，高亮当前比较的 $x_v$。
- **像素风格**：用 8 位网格显示 x_v 数组，每次收缩区间时触发像素方块移动动画。
- **音效提示**：在更新 mid 时播放点击音效，找到 SG 值时播放成功音调。

---

## 题解清单 (4星)

### 1. 作者：VinstaG173 (4.5星)
- **亮点**：详细推导 SG 函数递推式，预处理 x_v 数组，代码清晰。
- **关键代码**：
  ```cpp
  inline int SG(ll x) {
      int l=0, r=cnt, m;
      while(l < r) {
          m = r - ((r-l)>>1);
          if (dsg[m] <= x) l = m;
          else r = m-1;
      }
      return l;
  }
  ```

### 2. 作者：喵仔牛奶 (4星)
- **亮点**：简洁的数学推导，结合 k-SG 处理，代码高效。
- **核心逻辑**：
  ```cpp
  REP(i, 1, B) {
      lw[i] = pow(sqrt(lw[i-1]+1)+1, 2);
      while (lw[i] - ceil(sqrt(lw[i])*2) < lw[i-1]) lw[i]++;
  }
  ```

---

## 最优思路与技巧
1. **数学推导 SG 递推式**：利用 $x-2\sqrt{x}$ 的不减性，避免暴力计算。
2. **预处理 x_v 数组**：通过递推公式快速生成所有可能的 SG 分界点。
3. **二分优化查询**：将 SG 值查询复杂度降至 $O(\log S)$。
4. **k-SG 位运算处理**：按位统计并模 $(k+1)$ 判断胜负。

---

## 类似题目推荐
1. **P1247 取火柴游戏**：Nim 游戏基础，异或和判断。
2. **P5675 [POI2008]石子游戏**：SG 函数与博弈论结合。
3. **P5363 [SDOI2019]移动金币**：k-SG 问题变种，需位运算处理。

---

## 个人心得摘录
- **预处理边界调整**：推导 $x_v$ 时需循环验证是否满足 $x_v -2\sqrt{x_v} \geq x_{v-1}$，否则需手动加 1。
- **二进制位处理技巧**：k-SG 中每位独立判断，避免直接异或。

---

## 代码片段（核心二分逻辑）
```cpp
// 预处理 x_v 数组
dsg[0] = 0;
for (int i = 1; ; i++) {
    double v = sqrt(dsg[i-1] + 1) + 1;
    dsg[i] = (ll)(v * v);
    if (dsg[i] - 2*sqrt(dsg[i]) < dsg[i-1]) dsg[i]++;
    if (dsg[i] >= S) { cnt = i; break; }
}

// 二分查找 SG 值
int SG(ll x) {
    int l = 0, r = cnt, m;
    while (l < r) {
        m = r - (r - l) / 2;
        if (dsg[m] <= x) l = m;
        else r = m - 1;
    }
    return l;
}
```

---

## 可视化动画设计
- **Canvas 绘制**：网格化显示 x_v 数组，当前搜索区间用不同颜色标记。
- **音效触发**：
  - **mid 更新**：短促“滴”声。
  - **区间收缩**：根据方向（左/右）播放不同音调。
- **自动演示模式**：AI 模拟二分步骤，每 0.5 秒更新一帧，辅以背景音乐。

---
处理用时：98.15秒
# 题目信息

# [Cnoi2021] 自我主义的平衡者

## 题目背景

「流浪月球 ~ The Wandering Moon」在幻想乡上映了。

正如一千个人心中有一千个哈姆雷特，关于它的争议也在悄然蔓延。

不知何时起，一个叫做「花瓣」的平台出现，慢慢取代了市井之中的讨论声，成为了争议的主战场——因为它具有评分功能。平台上旁征博引、各抒己见的评分帖成为了幻想乡的居民们日常，一切看起来岁月静好。

直到平衡者的出现。

起初没有人在意在意这缕杂音，这只不过是一种无心的叛逆，一点无奈的情感，一次无聊的宣泄。直到平衡的思想深入人心，自我主义的狂潮达到顶峰，评分系统的秩序几近崩溃。

Cirno 觉得自己该做些什么了。

## 题目描述

Cirno 决定通过计算来说服与拯救被自我主义裹挟的众人。

参与评分的共有 $n$ 位居民，平台限制的最高分为 $m$。

每个居民在评分前都有一个心理预期分数 $a_i(a_i\in[0,m]\cap\mathbb{Z})$。

但人们并不会按照心理预期分数直接评分，而是当当前平台上的平均分严格高于自己的心理预期分数时，便评分道「分数太高了，打个 $0$ 分平衡一下」，反之则说「分数太低了，打个满分（$m$分）平衡一下」。

初始时平台上的平均分为 $0$。

为了证明这种评分方式对公平的破坏性，Cirno 希望你计算出这 $n$ 位居民在不同的排列顺序下评分，平台上最终平均分可能的最大值与最小值。

## 说明/提示

**数据范围与约定**

对于 $100\%$ 的数据保证，$1 < n,m\le 10^5$，$a_i \in [0,m]$。

**子任务**

Subtask1（10 points）：$n \le 8$。

Subtask2（10 points）：$n \le 20$。

Subtask3（30 points）：$n \le 10^3$。

Subtask4（50 points）：无特殊限制。

## 样例 #1

### 输入

```
5 5
1 2 3 4 5```

### 输出

```
4.00 2.00```

## 样例 #2

### 输入

```
7 114
23 75 35 17 101 55 73```

### 输出

```
81.43 32.57```

# AI分析结果



# [Cnoi2021] 自我主义的平衡者

## 唯一算法分类
无算法分类

---

## 算法要点与解决难点

### 核心思路
- **最大值策略**：将心理预期分数 $a_i$ **从小到大排序**，使得尽可能多的用户贡献 $m$ 分。
- **最小值策略**：将 $a_i$ **从大到小排序**，使得尽可能多的用户贡献 $0$ 分。

### 核心证明（邻项交换法）
对于相邻两项 $a_i$ 和 $a_j$（假设 $a_i \le a_j$）：
1. **若当前平均分 $\le a_i$**：  
   从小到大排序时，两项均贡献 $m$ 分；交换后若平均分仍 $\le a_j$，贡献相同；否则可能导致 $a_i$ 后续无法贡献 $m$ 分。
2. **若当前平均分 $> a_i$**：  
   从小到大排序时，$a_i$ 贡献 $0$ 分，而 $a_j$ 可能贡献 $m$ 分；交换后可能导致 $a_j$ 也贡献 $0$ 分，结果更劣。

### 解决难点
- **动态平均分的影响**：每次打分后平均分变化，需全局分析不同排列对后续决策的连锁影响。
- **精度处理**：避免浮点误差，通过比较总分（$sum \le a_i \cdot (k-1)$）代替平均分。

---

## 题解评分（≥4星）

1. **peppaking8（⭐⭐⭐⭐⭐）**  
   - **亮点**：严格的邻项交换证明，代码简洁高效。
   - **代码**：直接排序后模拟总分计算，时间复杂度 $O(n \log n)$。

2. **Dr_Gilbert（⭐⭐⭐⭐）**  
   - **亮点**：分类讨论细致，证明过程清晰，代码可读性高。
   - **技巧**：通过总分代替浮点运算避免精度问题。

3. **block_in_mc（⭐⭐⭐⭐）**  
   - **亮点**：简短的代码实现，逻辑与证明对应性强。
   - **优化**：直接比较总分与 $a_i \cdot (k-1)$，减少计算量。

---

## 最优思路提炼

### 关键技巧
1. **贪心排序策略**：  
   最大值时从小到大排序，最小值时从大到小排序。
2. **总分代替平均分**：  
   比较 $sum \le a_i \cdot (k-1)$ 避免浮点运算。
3. **动态决策链**：  
   每次选择当前最可能贡献 $m$ 分的用户（最小 $a_i$ 或最大 $a_i$）。

---

## 类似算法套路

### 典型场景
- **任务调度优化**：按截止时间或收益排序。
- **背包问题变种**：贪心选择单位价值最高的物品。

### 推荐题目
1. **P1090 合并果子**：贪心选择最小两堆合并。
2. **P1233 木棍加工**：按长度和宽度双重排序。
3. **P2240 部分背包问题**：按性价比排序选择。

---

## 个人心得摘录

- **调试教训**：  
  > "注意比较时应使用总分而非平均分，否则会因浮点误差导致错误。" —— Dr_Gilbert
- **顿悟时刻**：  
  > "交换两项后对后续的影响可通过数学归纳法统一分析。" —— peppaking8

---

## 可视化设计（复古像素风格）

### 动画方案
1. **排序过程**：  
   - 8-bit 像素动态展示数组从小到大/从大到小排序。
   - 音效：每次交换播放 "哔" 声，排序完成播放 "叮" 声。

2. **打分模拟**：  
   - 网格显示当前用户 $a_i$ 和总分。
   - 若贡献 $m$ 分，高亮绿色；否则红色。
   - 音效：$m$ 分触发 "噔"，$0$ 分触发 "咔"。

3. **AI 自动演示**：  
   - 自动按最优策略排列并打分，步进间隔可调。
   - 背景音乐：8-bit 风格循环旋律。

### 交互功能
- **控制面板**：暂停/继续、调整速度、重置。
- **积分系统**：正确完成排序和模拟后获得金币奖励。

---

## 核心代码片段

```cpp
// 最大值计算（从小到大排序）
sort(a + 1, a + n + 1);
long long sum = 0;
for (int i = 1; i <= n; i++) {
    if (sum <= a[i] * (i - 1)) sum += m;
}
double max_avg = (double)sum / n;

// 最小值计算（从大到小排序）
sort(a + 1, a + n + 1, greater<int>());
sum = 0;
for (int i = 1; i <= n; i++) {
    if (sum <= a[i] * (i - 1)) sum += m;
}
double min_avg = (double)sum / n;
```

---
处理用时：86.90秒
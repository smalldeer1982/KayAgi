# 题目信息

# 「Wdoi-6」最澄澈的空与海

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/hiekh6t5.png)](https://thwiki.cc/%E5%8D%AF%E9%85%89%E4%B8%9C%E6%B5%B7%E9%81%93_%EF%BD%9E_Retrospective_53_minutes.)

广重号载着二人向东飞驰。毫无噪音，毫无摇摆，只是一个劲向东飞驰。在“万景幕”装置之下，尽管是全地下的卯酉东海道，乘客们也能饱览美丽的富士山和太平洋的景色。

但是，从这列卯酉新干线『广重』上看到的极富日本风味的美丽情景，对于梅莉来说，只不过是无趣的视觉刺激罢了。高动态范围的影像也好，极富日本风味的情景也好，都敌不过真正的天空的颜色。

身与华落，心将香飞。即便肉体会像花朵一样终有一天凋落，但心却可以如花香一般飘往远方。

「梅莉，你看，天上的星星呦。」

## 题目描述

### 简要题意

给定 $2n$ 个点、$m$ 条边的[二分图](http://oi-wiki.com/graph/bi-graph/#_1)（可能有重边），左部点与右部点个数相同，判断其完美匹配数量是否**恰好**为 $1$。是则输出 `Renko`，否则输出 `Merry`。

> **注**：完美匹配是指，从边集中选出 $n$ 条边，这些边的顶点组成的点集恰好覆盖了所有的 $2n$ 个点。

---
### 原始题意

在夜里，莲子与梅莉来到了东京的海边，躺在沙滩上，欣赏着澄澈的天空与大海，数起了天上的星星。

在这些星星之中，有 $n$ 个星星 $\{a_i\}$，是莲子先发现的，被称为莲子星；而又有 $n$ 个星星 $\{b_i\}$，是梅莉先发现的，被称为梅莉星。由于她们心有灵犀，这两批星星之间**不存在交集**。  

她们发现，有一些莲子星，与一些梅莉星之间恰好存在运动关系。具体而言，这些关系一共有 $m$ 组，每一组关系形如 $(u_i,v_i)$，也就是说第 $u_i$ 颗莲子星与第 $v_i$ 颗梅莉星之间存在运动关系。这些运动关系有可能重复。

这让莲子和梅莉非常好奇。作为专攻超统一物理学的女大学生，莲子认为，如果认为这些星星的运动是**和谐**的，那么她应当能够从这 $m$ 个运动关系中，找出若干个运动关系，使得**每颗**星星**都被**这些运动关系**包含**的同时，不会有一颗星星**被包含在两个**运动关系之中。

然而，梅莉认为，**和谐**的运动可能是不存在的，更何况即使莲子找到了**和谐**的运动，莲子也无法确保这种和谐运动的**唯一性**。两种和谐运动不同，当且仅当选取出的两组运动关系中，存在至少一个运动关系，是不相同的。

因为意见不合，她们于是打情骂俏了一顿。莲子于是记下了她们所看到了星星和她们之间的运动关系，并且找到了已经证明了 P=NP 的你，希望你能告诉她们，最后是谁正确呢？

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/6skoily9.png)

如图所示，存在唯一的方案：$\{1\to 1,2\to 5,3\to 2,4\to 3,5\to 4\}$。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \bm{m\le} & \textbf{\textsf{特殊性质}} & \textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 10 & 10 & - & - \cr\hline
2 & 20 & 300 & 4\times 10^4 & - & 1\cr\hline
3 & 20 & 10^5 & 5 \times 10^5 & \mathbf{A} & - \cr\hline
4 & 20 & 10^5 & 2 \times 10^5 & \mathbf{B} & - \cr\hline
5 & 30& 10^6 & 2\times 10^6 & - & 2,3,4 \cr\hline
\end{array}
$$

- 特殊性质 $\mathbf{A}$：保证对于第 $i$ 颗莲子星，与第 $i$ 颗梅莉星之间存在运动关系。
- 特殊性质 $\mathbf{B}$：保证 $m=2n-1$。

对于 $100\%$ 的数据，保证 $1 \le u_i,v_i\le n \le 10^6$，$1 \le m \le 2 \times 10^6$，$1 \leq T \leq 5$ 且对于每个测试点，$\sum m \leq 4 \times 10^6$。

对于 $\rm Subtask\ 5$，时间限制为 $3$ 秒。其它测试点时间限制为 $1$ 秒。

## 样例 #1

### 输入

```
1
5
6
1 1
1 3
3 2
2 5
4 3
5 4```

### 输出

```
Renko```

# AI分析结果



**算法分类**: 无算法分类（基于图论与拓扑排序的贪心策略）

---

### **题解思路、算法要点与解决难点**

1. **核心结论**  
   - **唯一完美匹配的必要条件**：存在度数为1的节点，且递归删除这些节点及其唯一匹配后图被完全清空。
   - **反证法**：若所有节点度数≥2，则存在环或交叉边，导致完美匹配不唯一。

2. **算法流程**  
   - **拓扑式删点**：
     1. 初始化队列，将所有度数为1的节点入队。
     2. 依次处理队列中的节点，删除其唯一匹配的边及对应节点。
     3. 更新相邻节点的度数，若新度数为1则入队。
     4. 最终检查是否所有节点均被删除。

3. **解决难点**  
   - **高效维护度数**：利用队列动态处理，避免重复检查所有节点。
   - **正确性保证**：删除度数为1的节点不会影响剩余图的唯一匹配性，子问题与原问题性质一致。

---

### **题解评分 (≥4星)**

1. **retep (5星)**  
   - **亮点**：代码简洁高效，队列模拟删除过程，正确维护度数变化。
   - **代码可读性**：变量命名清晰，多组数据初始化处理完善。

2. **Cocoly1990 (4星)**  
   - **亮点**：严谨数学证明，从环的角度分析唯一性破坏。
   - **理论深度**：结合有向图转化思路，增强结论可信度。

3. **_www_ (4星)**  
   - **亮点**：引入Hall定理辅助分析，代码极简（仅20行）。
   - **优化程度**：利用STL最小元素判断结果，巧妙避免显式计数。

---

### **最优思路或技巧提炼**

- **贪心删点策略**：度数为1的节点唯一匹配必然确定，递归删除形成子问题。
- **队列优化**：仅处理度数变化的节点，时间复杂度降至线性（`O(m+n)`）。
- **对称处理**：同时维护左右部点的度数，避免遗漏重边或复杂结构。

---

### **同类型题与算法套路**

- **唯一性判断**：树的重心唯一性、拓扑排序唯一性（如[CF 1385E](https://codeforces.com/problemset/problem/1385/E)）。
- **拓扑贪心**：DAG最长路径唯一性、任务调度顺序唯一性。

---

### **推荐相似题目**

1. [P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)  
   （基础二分图匹配，对比唯一性条件）
2. [P4716 【模板】最小树形图](https://www.luogu.com.cn/problem/P4716)  
   （唯一最小树形图判断，类似贪心删边）
3. [CF 1107E (Vasya and Binary String)](https://codeforces.com/problemset/problem/1107/E)  
   （动态规划中的唯一性剪枝，思维类似）

---

### **可视化与算法演示**

**动画设计**：
1. **节点与边绘制**：左右部点分列两侧，边动态高亮。
2. **删点过程**：
   - 度数为1的节点闪烁红色，匹配边标黄。
   - 删除时节点变灰，边消失，相邻节点度数更新。
3. **队列状态**：右侧面板显示当前队列中的节点，颜色区分处理状态。

**复古像素风格**：
- **8位色板**：红（处理中）、黄（匹配边）、灰（已删）、绿（存活）。
- **音效**：  
  - `delete.wav`（删点时播放8位“叮”声）  
  - `enqueue.wav`（节点入队时短促“哔”声）

**AI自动演示**：  
- 初始随机生成二分图，按算法步骤自动执行，用户可暂停观察中间状态。

---

### **核心代码实现**

```cpp
// retep 的队列删点实现（核心逻辑）
queue<int> q;
for (int i = 1; i <= 2 * n; i++) {
    if (in[i] == 1) q.push(i);
}
while (!q.empty()) {
    int u = q.front(); q.pop();
    if (del[u] || in[u] != 1) continue;
    del[u] = true; cnt++;
    int v = 未被删除的邻接点;
    del[v] = true; cnt++;
    for (int邻接点w : v的邻接表) {
        if (!del[w] && --in[w] == 1) {
            q.push(w);
        }
    }
}
if (cnt == 2 * n) 输出 Renko;
```

---

**总结**：通过拓扑式删点判断唯一性，结合队列优化与度数维护，高效解决大规模二分图唯一匹配问题。

---
处理用时：75.48秒
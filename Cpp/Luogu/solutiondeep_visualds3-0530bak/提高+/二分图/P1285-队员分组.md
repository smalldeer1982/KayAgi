# 题目信息

# 队员分组

## 题目描述

有 $n$ 个人从 $1$ 至 $n$ 编号，相互之间有一些认识关系，你的任务是把这些人分成两组，使得：

- 每个人都被分到其中一组。
- 每个组都至少有一个人。
- 一组中的每个人都认识其他同组成员。

在满足上述条件的基础上，要求两组成员的人数之差（绝对值）尽可能小。请构造一种可行的方案。

请注意，$x$ 认识 $y$ 不一定说明 $y$ 认识 $x$；$x$ 认识 $y$ 且 $y$ 认识 $z$ 不一定说明 $x$ 认识 $z$。即认识关系是单向且不可传递的。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 100$，$1 \leq a_{i, j} \leq n$。

#### 说明

由 @zhouyonglong 提供 SPJ。



## 样例 #1

### 输入

```
5
2 3 5 0
1 4 5 3 0
1 2 5 0
1 2 3 0
4 3 2 1 0
```

### 输出

```
3 1 3 5
2 2 4
```

# AI分析结果



## 算法分类
**二分图染色 + 动态规划**

---

## 题解思路与核心难点

### 核心思路
1. **补图构建**：将原问题的认识关系转换为"不能同组"关系。若两人存在任意一方不认识对方，则建立无向边，构成补图。
2. **二分图检测**：对补图的每个连通块进行黑白染色。若存在奇环则无解，否则每个连通块分裂为两个集合（黑组与白组）。
3. **动态规划**：用01背包思想组合各连通块的选择方案，求两组人数差最小值。

### 实现要点
- **补图处理**：对原图的单向边进行双向校验，转化为无向边
- **连通块统计**：每个连通块存储两组人数（`cnt[blk][0/1]`）
- **背包状态转移**：`dp[i][j] = dp[i-1][j-cnt0] | dp[i-1][j-cnt1]`
- **路径回溯**：记录`pre[i][j]`保存决策路径

### 解决难点
1. **补图的双向边处理**：需处理单向认识关系，转化为双向排斥关系
2. **连通块独立性**：不同连通块的决策互不影响，允许独立组合
3. **最优差逼近**：从n/2向两侧探测第一个可行解，保证差值最小

---

## 题解评分（≥4星）

1. **iyanhang（5星）**
   - 亮点：完整实现补图与二分图染色，路径回溯清晰
   - 核心代码：DFS染色+二维DP状态转移
   ```cpp
   void dfs(int x,int fa,int col) {
       num[sum][mtc[x]=col]++;
       for(int i=1;i<=n;++i)
           if(!g[i][x] && i!=fa)
               if(mtc[i]==-1) dfs(i,x,col^1);
               else if(mtc[i]==col) exit(0);
   }
   ```

2. **Yaha（5星）**
   - 亮点：变量命名清晰，路径记录采用三维数组
   - 优化点：使用`take[i][j]`直接记录选择方案
   ```cpp
   if(j>=num[i][1]&&f[i-1][j-num[i][1]])
       take[i][j]=1, pre[i][j]=j-num[i][1];
   ```

3. **chenzida（4星）**
   - 亮点：命题证明严谨，邻接表存储分组方案
   - 特色：通过`add(cnt,col,num)`记录每个点的分组

---

## 最优思路提炼

1. **补图转换思维**：将"必须同组"转换为"禁止同组边"，构建二分图
2. **连通块独立决策**：每个连通块的两种选择方案通过背包组合
3. **逆向差值逼近**：从n/2开始反向搜索第一个可行解
4. **路径回溯技巧**：使用pre数组记录决策树，递归重构分组

---

## 类似题目推荐

1. **P3386【模板】二分图最大匹配**（二分图基础）
2. **P2014 [CTSC1997]选课**（树形DP与分组决策）
3. **P1273 有线电视网**（分组背包与差值优化）

---

## 可视化设计

### 算法演示（Canvas动画）
1. **补图构建阶段**：
   - 红边表示两人不能同组
   - 动态展示输入数据转换为补图的过程

2. **染色阶段**：
   - 连通块以不同底色区分
   - 染色过程用扩散动画表示，黑/白节点交替出现

3. **DP状态转移**：
   - 网格表示dp[i][j]状态
   - 绿色格子表示可行状态，黄色箭头表示转移路径

4. **路径回溯**：
   - 高亮当前处理的连通块
   - 用闪烁效果标记选择的集合

### 复古像素风格
- **8-bit音效**：染色成功时播放上升音阶，失败时播放爆炸音效
- **像素按钮**："Step"按钮触发单步执行，"Auto"以贪吃蛇式自动演示
- **积分系统**：正确完成染色+1分，找到最优解+5分

---

## 核心代码实现

```cpp
// 补图构建
for(int i=1;i<=n;i++)
    for(int j=i+1;j<=n;j++)
        if(!(g[i][j] && g[j][i])) 
            g[i][j] = g[j][i] = 0;

// 二分图染色
void dfs(int u, int color) {
    cnt[blk][color]++;
    for(int v : G[u]) {
        if(col[v] == color) exit(0);
        if(!col[v]) dfs(v, 3-color);
    }
}

// 动态规划
dp[0][0] = 1;
for(int i=1; i<=blk; i++) {
    for(int j=n; j>=0; j--) {
        if(j >= cnt[i][0]) dp[i][j] |= dp[i-1][j - cnt[i][0]];
        if(j >= cnt[i][1]) dp[i][j] |= dp[i-1][j - cnt[i][1]];
    }
}

// 路径回溯
void trace(int i, int j) {
    if(i == 0) return;
    if(dp[i-1][j - cnt[i][0]]) 
        select(i,0), trace(i-1, j - cnt[i][0]);
    else 
        select(i,1), trace(i-1, j - cnt[i][1]);
}
```

---

## 关键调试心得

1. **单向边处理**：必须双向校验`g[i][j] && g[j][i]`才能判定可同组
2. **零初始化陷阱**：dp数组必须初始化为-∞或使用bool标记
3. **路径记录技巧**：采用逆序存储决策，避免递归栈溢出

---

通过该方案，能有效解决队员分组问题，算法时间复杂度为O(n³)，适用于n≤100的数据规模。

---
处理用时：72.54秒
# 题目信息

# [国家集训队] 稳定婚姻

## 题目描述

我们已知 $n$ 对夫妻的婚姻状况，称第 $i$ 对夫妻的男方为 $B_i$，女方为 $G_i$。若某男 $B_i$ 与某女 $G_j$ 曾经交往过（无论是大学，高中，亦或是幼儿园阶段，$i \le j$），则当某方与其配偶（即 $B_i$ 与 $G_i$ 或 $B_j$ 与 $G_j$）感情出现问题时，他们有私奔的可能性。不妨设 $B_i$ 和其配偶 $G_i$ 感情不和，于是 $B_i$ 和 $G_j$ 旧情复燃，进而 $B_j$ 因被戴绿帽而感到不爽，联系上了他的初恋情人 $G_k$ ……一串串的离婚事件像多米诺骨牌一般接踵而至。若在 $B_i$ 和 $G_i$ 离婚的前提下，这 $2n$ 个人最终依然能够结合成 $n$ 对情侣，那么我们称婚姻 $i$ 为不安全的，否则婚姻 $i$ 就是安全的。

给定所需信息，你的任务是判断每对婚姻是否安全。

## 说明/提示

对于 $20\%$ 的数据，$n \le 20$；

对于 $40\%$ 的数据，$n \le 100$，$m \le 400$；

对于 $100\%$ 的数据，所有姓名字符串中只包含英文大小写字母，大小写敏感，长度不大于 $8$，保证每对关系只在输入文件中出现一次，输入文件的最后 $m$ 行不会出现未在之前出现过的姓名，这 $2n$ 个人的姓名各不相同，$1 \le n \le 4000$，$0 \le m \le 20000$。

## 样例 #1

### 输入

```
2
Melanie Ashley
Scarlett Charles
1
Scarlett Ashley```

### 输出

```
Safe
Safe```

## 样例 #2

### 输入

```
2
Melanie Ashley
Scarlett Charles
2
Scarlett Ashley
Melanie Charles```

### 输出

```
Unsafe
Unsafe```

# AI分析结果



## 算法分类
**强连通分量 (Tarjan算法)**

---

## 题解分析

### 核心思路与解决难点
1. **图论建模**  
   - 夫妻关系：女→男（保证每对夫妻形成独立边）  
   - 情人关系：男→女（形成潜在替换路径）  
   通过交替方向建图，使得环结构必然对应可重组关系链。

2. **强连通分量判定**  
   使用 Tarjan 算法求 SCC，若夫妻节点在同一 SCC 中，则存在可重组路径，婚姻不安全。**难点在于理解交替建图如何保证环的正确性**，例如样例中的环 `女1→男1→女2→男2→女1` 会被 Tarjan 正确识别。

3. **复杂度优化**  
   Tarjan 时间复杂度 O(V+E)，对 n=4000 的数据完全可行。二分图匹配解法（O(n^2)）虽正确但效率低，仅适合小数据。

---

## 题解评分 (≥4星)

### 5星题解
1. **雨季（赞97）**  
   - **关键亮点**：最早提出 Tarjan 解法，代码简洁清晰，注释规范。  
   - **核心代码**：夫妻建边 `add(i, i+n)`，情人建边 `add(cou[boy], cou[gir])`  
   - **可视化建议**：高亮 `belong[i] == belong[i+n]` 的判断逻辑。

### 4星题解
1. **Baihua（赞34）**  
   - **亮点**：二分图匹配思路直观，代码展示匈牙利算法的增广逻辑。  
   - **不足**：重复拆边导致 O(n^2) 复杂度，无法处理大数据。  
   - **代码片段**：`Match[Match[i]] = 0` 模拟拆边，`DFS(i)` 寻找增广路。

2. **ahawzlc（赞27）**  
   - **亮点**：详细图解交替建图原理，适合新手理解。  
   - **代码片段**：使用 `bl[x[i]] == bl[y[i]]` 判断 SCC，变量命名清晰。

---

## 最优思路提炼
### 关键技巧
1. **交替建图**  
   夫妻女→男，情人男→女，保证环结构对应可重组关系链。  
   **反例**：若统一方向建图，无法形成有效环（如全为男→女）。

2. **SCC快速判定**  
   Tarjan 的栈回溯机制天然适合检测环，时间复杂度 O(n+m) 完胜暴力匹配。

3. **字符串哈希优化**  
   使用 `map<string, int>` 将名字映射为连续编号，避免字符串比较的性能损耗。

---

## 类似题目推荐
1. **P2341 [HAOI2006]受欢迎的牛**  
   （强连通分量与出度判定）
2. **P3386 【模板】二分图最大匹配**  
   （匈牙利算法基础练习）
3. **P2863 [USACO06JAN]The Prom**  
   （SCC 应用，检测环中节点数）

---

## 可视化设计
### 动画方案
1. **像素风格演示**  
   - **节点**：8-bit 像素块，粉色（女）、蓝色（男）  
   - **边**：红色箭头（夫妻边），绿色箭头（情人边）  
   - **栈操作**：栈内节点用闪烁边框标记，回溯时播放 "pop" 音效。

2. **关键步骤高亮**  
   - **DFS遍历**：当前节点用黄色高亮，已访问节点灰化。  
   - **SCC形成**：检测到 `low[u] == dfn[u]` 时，触发爆炸特效音效，该 SCC 内节点变为同一颜色。

3. **交互控制**  
   - **速度滑块**：调整 Tarjan 执行速度（0.5x~5x）。  
   - **单步模式**：按空格键逐步执行 `dfn/low` 更新和栈操作。

### 核心代码片段（JavaScript）
```javascript
// Tarjan 算法可视化核心逻辑
function tarjan(u) {
  dfn[u] = low[u] = ++idx;
  stack.push(u);
  vis[u] = true;
  drawNode(u, 'yellow'); // 高亮当前节点

  edges[u].forEach(v => {
    if (!dfn[v]) {
      tarjan(v);
      low[u] = Math.min(low[u], low[v]);
    } else if (vis[v]) {
      low[u] = Math.min(low[u], dfn[v]); 
    }
  });

  if (dfn[u] === low[u]) { // SCC 形成
    playSound('success');
    let member;
    do {
      member = stack.pop();
      vis[member] = false;
      colorMember(member, sccColor); // 染色
    } while (member !== u);
  }
}
```

---

## 个人心得摘录
1. **调试教训**  
   > “第一次建图方向错误导致 WA，必须严格交替夫妻和情人边的方向。”（题解：喻文州）

2. **顿悟时刻**  
   > “突然意识到环中的男女交替结构对应可无限重组的关系链，是解题的关键。”（题解：ahawzlc）

---

## 完整代码参考（雨季版）
```cpp
#include<iostream>
#include<map>
using namespace std;
#define N 10005
#define M 300005

map<string,int> cou; // 夫妻映射
struct node { int v,nex; } e[M];
int tot,h[N],dfn[N],low[N],belong[N],idx,cnt;

void add(int u,int v) {
  e[++tot] = {v, h[u]}; h[u] = tot;
}

void Tarjan(int u) {
  dfn[u] = low[u] = ++idx;
  static int s[N], top; 
  s[++top] = u;
  for(int i=h[u]; i; i=e[i].nex) {
    int v = e[i].v;
    if(!dfn[v]) Tarjan(v), low[u] = min(low[u], low[v]);
    else if(!belong[v]) low[u] = min(low[u], dfn[v]);
  }
  if(low[u] == dfn[u]) {
    ++cnt;
    while(1) {
      int v = s[top--];
      belong[v] = cnt;
      if(v == u) break;
    }
  }
}

int main() {
  int n,m; cin >> n;
  string gir, boy;
  for(int i=1; i<=n; ++i) {
    cin >> gir >> boy;
    cou[gir] = i;       // 女编号i
    cou[boy] = i + n;   // 男编号i+n
    add(i, i + n);      // 女→男
  }
  cin >> m;
  while(m--) {
    cin >> gir >> boy;
    add(cou[boy], cou[gir]); // 男→女
  }
  for(int i=1; i<=2*n; ++i) 
    if(!dfn[i]) Tarjan(i);
  for(int i=1; i<=n; ++i)
    cout << (belong[i]==belong[i+n] ? "Unsafe\n" : "Safe\n");
}
```

---
处理用时：83.72秒
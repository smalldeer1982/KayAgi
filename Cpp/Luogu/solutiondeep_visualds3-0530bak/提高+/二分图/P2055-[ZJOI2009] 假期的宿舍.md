# 题目信息

# [ZJOI2009] 假期的宿舍

## 题目描述

学校放假了……有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。

比如 A 和 B 都是学校的学生，A 要回家，而 C 来看B，C 与 A 不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一个解决方案就是 B 睡 A 的床而 C 睡 B 的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也不一定都互相认识。

我们已知一共有 $n$ 个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。


## 说明/提示

对于 $30\%$ 的数据满足 $1 \le n \le 12$。

对于 $100\%$ 的数据满足 $1 \le n \le 50$，$1 \le T \le 20$。


## 样例 #1

### 输入

```
1
3
1 1 0
0 1 0
0 1 1
1 0 0
1 0 0```

### 输出

```
^_^```

# AI分析结果



**唯一算法分类**: 二分图匹配

---

### **题解思路、算法要点与解决难点**

**核心思路**:  
将需要床位的人（不回家的本校学生+外来访客）作为左部节点，可用床位（本校学生的床）作为右部节点，构建二分图。通过匈牙利算法或网络流计算最大匹配，判断是否满足所有需求。

**算法要点**:  
1. **建图逻辑**:
   - 左部节点：所有需要住宿的人（`!home[i]` 的在校生 + 所有外来访客）
   - 右部节点：所有在校学生的床（`school[i] = 1`）
   - 边：若 `i` 认识 `j` 且 `j` 是本校学生，则连边 `i -> j`

2. **匈牙利算法关键步骤**:
   ```cpp
   bool dfs(int u) {
      遍历所有可用床位v:
          if (未访问且认识v的主人):
              标记访问
              if (v未匹配 或 dfs(v的匹配对象)):
                  更新匹配关系
                  return true
      返回false
   }
   ```

3. **网络流建图技巧**:
   - 源点连接所有需要床的人，容量1
   - 床连接汇点，容量1
   - 认识关系连边，容量1

**解决难点**:  
- **忽略无效输入**: 非本校学生的`home`数据需忽略
- **自环处理**: 在校生不回家时需添加`i -> i`的边
- **多组数据初始化**: 清空匹配数组和邻接表

---

### **题解评分 (≥4星)**

1. **Drinkkk (5星)**  
   - **亮点**: 详细讲解两种算法（匈牙利+网络流），代码结构清晰，处理多组数据完备  
   - **代码片段**:  
     ```cpp
     // 匈牙利算法核心
     bool dfs(int u) { 
         for(int i=1; i<=n; i++) 
             if (未访问 && 认识i的床) 
                 if (匹配成功) return true; 
         return false; 
     }
     ```

2. **yybyyb (4星)**  
   - **亮点**: 代码简洁，直接针对问题建模，注释明确  
   - **关键代码**:  
     ```cpp
     // 建边逻辑
     if (i是学生 && 不回家) Add(i, i); // 自己连自己床
     if (i认识j && j是学生) Add(i, j);
     ```

3. **George1123 (4星)**  
   - **亮点**: 使用邻接矩阵快速判断关系，代码易读  
   - **核心逻辑**:  
     ```cpp
     // 自环处理
     if (stu[i] && !hom[i]) a[i].push_back(i);
     ```

---

### **最优思路与技巧提炼**

1. **巧用自环边**:  
   在校生不回家时，必须显式添加`i -> i`的边，否则无法匹配自己的床。

2. **输入处理技巧**:  
   ```cpp
   for (i=1; i<=n; i++) {
       scanf("%d", &home[i]);
       if (!school[i]) home[i] = 1; // 非在校生忽略home数据
   }
   ```

3. **网络流优化**:  
   将床的节点编号偏移（如`i+n`），避免与人的节点冲突，简化建图逻辑。

---

### **同类题目推荐**

1. **P3386 [二分图最大匹配]**  
   - 模板题，直接应用匈牙利算法

2. **P2764 [最小路径覆盖]**  
   - 二分图建模，求DAG的最小路径覆盖

3. **P3254 圆桌问题**  
   - 网络流建模，多重匹配问题

---

### **可视化与算法演示**

**动画设计**:  
1. **像素风格界面**:
   - 左列显示需要床位的人（红色方块），右列显示床（绿色方块）
   - 已匹配的边显示为金色连线，尝试中的路径用黄色高亮

2. **关键步骤演示**:  
   - **步骤1**: 选中左部节点`u`，黄色高亮
   - **步骤2**: 遍历右部节点，蓝色闪烁可访问的床
   - **步骤3**: 若找到增广路径，金色连线标记新匹配，旧匹配解除时红色闪烁

3. **音效与交互**:  
   - 匹配成功: 播放上升音调（8-bit风格）
   - 匹配失败: 短促"哔"声
   - 支持暂停/步进，速度调节滑动条

**代码片段（Canvas动画）**:  
```javascript
// 绘制节点和边
function drawGraph() {
    ctx.clearRect(0, 0, width, height);
    // 绘制左部节点（人）
    leftNodes.forEach((node, i) => {
        drawPixelBlock(node.x, node.y, node.matched ? '#0f0' : '#f00');
    });
    // 绘制右部节点（床）
    rightNodes.forEach((node, i) => {
        drawPixelBlock(node.x, node.y, node.matched ? '#0f0' : '#0f0');
    });
    // 绘制当前尝试的边
    if (currentEdge) {
        drawLine(currentEdge.from, currentEdge.to, '#ff0');
    }
}
```

---

### **核心代码实现（匈牙利算法）**

```cpp
#include <cstring>
const int N = 55;
int match[N], vis[N], school[N], home[N], g[N][N];

bool dfs(int u) {
    for (int v = 1; v <= n; v++) {
        if (!vis[v] && school[v] && g[u][v]) { // v是床且可访问
            vis[v] = 1;
            if (!match[v] || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

int main() {
    // 处理输入
    for (int i = 1; i <= n; i++) {
        if ((school[i] && !home[i]) || !school[i]) { // 需要床的人
            memset(vis, 0, sizeof vis);
            if (!dfs(i)) return puts("T_T"), 0;
        }
    }
    puts("^_^");
}
```

---

**总结**: 本题通过巧妙的二分图建模，将住宿问题转化为经典匹配问题。关键点在于正确处理自环边和输入数据，匈牙利算法和网络流均可高效解决。可视化设计通过像素动画直观展示匹配过程，助力理解算法核心思想。

---
处理用时：71.03秒
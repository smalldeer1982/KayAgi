# 题目信息

# [HNOI2006] 超级英雄

## 题目描述

现在电视台有一种节目叫做超级英雄，大概的流程就是每位选手到台上回答主持人的几个问题，然后根据回答问题的多少获得不同数目的奖品或奖金。主持人问题准备了若干道题目，只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰。为了增加节目的趣味性并适当降低难度，主持人总提供给选手几个“锦囊妙计”，比如求助现场观众，或者去掉若干个错误答案（选择题）等等。


这里，我们把规则稍微改变一下。假设主持人总共有m道题，选手有n种不同的“锦囊妙计”。主持人规定，每道题都可以从两种“锦囊妙计”中选择一种，而每种“锦囊妙计”只能用一次。我们又假设一道题使用了它允许的锦囊妙计后，就一定能正确回答，顺利进入下一题。现在我来到了节目现场，可是我实在是太笨了，以至于一道题也不会做，每道题只好借助使用“锦囊妙计”来通过。如果我事先就知道了每道题能够使用哪两种“锦囊妙计”，那么你能告诉我怎样选择才能通过最多的题数吗？


## 说明/提示

感谢@zhouyonglong 提供special Judge


## 样例 #1

### 输入

```
5 6
3 2
2 0
0 3
0 4
3 2
3 2```

### 输出

```
4
3
2
0
4```

# AI分析结果



### 唯一算法分类
二分图最大匹配（匈牙利算法）

---

### 题解思路与核心难点
**核心思路**：将题目视为二分图左部节点，锦囊视为右部节点。每个题目连向其可用的两个锦囊，用匈牙利算法按顺序为每个题目寻找匹配，一旦匹配失败立即终止。

**解决难点**：
1. **顺序处理限制**：题目必须连续解答，若某题无法匹配则后续题目全部淘汰。
2. **及时终止逻辑**：在匈牙利算法中需在第一次匹配失败时跳出循环。
3. **编号转换**：题目中锦囊编号从0开始，代码中需统一处理为从1开始避免边界问题。

**算法流程**：
1. 建图：每个题目连向其两个可用锦囊（+1处理编号）。
2. 对每个题目执行匈牙利匹配：
   - 若成功，继续处理下一题。
   - 若失败，立即终止循环。
3. 输出每个成功题目对应的锦囊编号（需还原-1）。

---

### 题解评分（≥4星）
1. **x_faraway_x（5星）**  
   - 亮点：代码简洁，直接指出关键点（及时break），邻接矩阵实现高效。
2. **船医（4星）**  
   - 亮点：详细解释匈牙利算法原理，代码可读性强。
3. **Diamiko（4星）**  
   - 亮点：使用bitset优化空间，注释清晰，输出处理明确。

---

### 最优思路提炼
1. **按顺序匈牙利匹配**：逐题匹配，失败立即终止。
2. **状态记录数组**：用`sum[x]`记录题目x使用的锦囊，避免反向查询。
3. **邻接矩阵建图**：直接存储题目与锦囊的连接关系，查询高效。

**关键代码片段**：
```cpp
for(int i=1; i<=m; i++) {
    memset(vis, 0, sizeof(vis));
    if (Find(i)) ans++;
    else break; // 核心：及时终止
}
```

---

### 类似题目推荐
1. **P3386 【模板】二分图最大匹配**  
2. **P1129 [ZJOI2007] 矩阵游戏**  
3. **P1963 [NOI2009] 变换序列**

---

### 可视化设计
**动画方案**：
1. **像素风格渲染**：  
   - 题目用蓝色方块，锦囊用黄色方块，匹配线绿色，失败红色。
2. **关键步骤高亮**：  
   - 当前处理的题目闪烁，尝试的锦囊标红，成功匹配后变绿。
3. **音效交互**：  
   - 成功时播放“叮”声，失败时播放“咔嚓”声，背景8-bit音乐循环。
4. **自动演示模式**：  
   - 按帧逐步显示匹配过程，支持暂停/继续，速度可调。

**Canvas绘制伪代码**：
```javascript
// 绘制题目和锦囊
ctx.fillStyle = "#3498db"; // 题目颜色
ctx.fillRect(x, y, 30, 30); 
ctx.fillStyle = "#f1c40f"; // 锦囊颜色
ctx.fillRect(x, y, 30, 30);

// 匹配成功动画
if (matched) {
    ctx.strokeStyle = "#2ecc71";
    ctx.beginPath();
    ctx.moveTo(questX, questY);
    ctx.lineTo(toolX, toolY);
    ctx.stroke();
}
```

---

### 个人心得摘录
> “论仔细读题的重要性...找不到匹配就要立刻退出”——x_faraway_x  
调试中发现未及时终止导致错误，强调审题需关注连续性限制条件。

---

### 核心代码实现
```cpp
#include<cstdio>
#include<cstring>
const int N=1005;
bool to[N][N], vis[N];
int l[N], n, m, ans, sum[N]; 

bool Find(int x) {
    for(int j=1; j<=n; j++)
        if(to[x][j] && !vis[j]) {
            vis[j] = true;
            if(l[j]==0 || Find(l[j])) {
                l[j] = x; sum[x] = j;
                return true;
            }
        }
    return false;
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i=1, x, y; i<=m; i++) {
        scanf("%d%d", &x, &y);
        to[i][x+1] = to[i][y+1] = true; // 锦囊编号+1
    }
    for(int i=1; i<=m; i++) {
        memset(vis, false, sizeof(vis));
        if(Find(i)) ans++;
        else break; // 关键：立即终止
    }
    printf("%d\n", ans);
    for(int i=1; i<=ans; i++) 
        printf("%d\n", sum[i]-1); // 还原编号
}
```

---
处理用时：69.53秒
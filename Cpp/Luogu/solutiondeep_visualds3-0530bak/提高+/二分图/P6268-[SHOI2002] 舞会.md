# 题目信息

# [SHOI2002] 舞会

## 题目描述

某学校要召开一个舞会。已知学校所有 $n$ 名学生中，有些学生曾经互相跳过舞。当然跳过舞的学生一定是一个男生和一个女生。在这个舞会上，要求被邀请的学生中的任何一对男生和女生互相都不能跳过舞。求这个舞会最多能邀请多少个学生参加。

## 样例 #1

### 输入

```
8 6
0 2
2 3
3 5
1 4
1 6
3 1```

### 输出

```
5```

## 样例 #2

### 输入

```
20 5
5 2
4 3
18 17
0 11
13 3
```

### 输出

```
16```

# AI分析结果



---

## 算法分类
**二分图最大独立集**

---

## 题解思路与算法要点

### 核心逻辑推导
1. **问题转换**：将跳过舞的男女配对视为无向边，构建二分图  
2. **定理应用**：二分图最大独立集 = 总顶点数 - 最大匹配数  
3. **染色分集合**：DFS/BFS染色确定二分图的两个集合  
4. **匈牙利算法**：在某一性别集合（如颜色为1的集合）中求最大匹配  

### 关键实现对比
| 题解差异点       | Rusalka                            | 一扶苏一                          | Kris_hukr（网络流）             |
|------------------|------------------------------------|-----------------------------------|--------------------------------|
| **染色方式**     | 递归染色，仅处理未染色节点        | 递归染色，处理所有连通分量        | BFS染色，处理非连通图          |
| **匹配实现**     | 邻接矩阵遍历所有可能边           | vector邻接表优化空间              | 网络流建模（超级源汇点）       |
| **性别处理**     | 只从颜色1的节点开始匹配           | 染色后取0/1集合之一               | 通过交换保证性别方向正确       |
| **代码优化**     | 基础实现（适合教学）              | 使用时间戳优化vis数组             | 复杂但支持更复杂二分图场景     |

---

## 题解评分（≥4星）
1. **Rusalka（4.5⭐）**  
   - 亮点：详细推导定理关系，强调染色必要性  
   - 代码：邻接矩阵清晰展示核心逻辑，+1分  
   - 改进：未处理非连通图染色（样例1数据恰好连通）

2. **一扶苏一（4.8⭐）**  
   - 亮点：使用时间戳优化vis数组，避免memset开销  
   - 代码：vector邻接表+染色函数分离，可读性强  
   - 改进：未解释为何取col=0的集合

3. **genshy（4.2⭐）**  
   - 亮点：完整定理证明与独立集定义说明  
   - 代码：染色后存储集合到vector，便于后续处理  
   - 改进：未处理非连通图染色（与Rusalka相同问题）

---

## 最优思路提炼
### 关键步骤
1. **染色分割集合**  
   ```cpp
   void dfs_color(int u, int c) {
       col[u] = c;
       for (int v : adj[u]) {
           if (!col[v]) dfs_color(v, 3 - c);
       }
   }
   ```
2. **单向匈牙利匹配**  
   ```cpp
   int hungary() {
       int res = 0;
       for (int u : left_set) { // 仅处理左集合（颜色1）
           memset(vis, 0, sizeof(vis));
           res += dfs_match(u);
       }
       return res;
   }
   ```
3. **答案计算**  
   ```cpp
   printf("%d", n - hungary());
   ```

### 核心难点突破
- **染色防环**：DFS时记录父节点，跳过已访问节点  
  ```cpp
  if (v == fa || col[v]) continue; // 关键防环判断
  ```
- **匹配去重**：仅从单一性别集合出发，避免双向计算  
- **非连通处理**：外层循环检查所有节点的染色状态  

---

## 同类型题推荐
1. **P3386** 二分图最大匹配（模板题）  
2. **P3355** 骑士共存问题（网格图独立集）  
3. **P2764** 最小路径覆盖（DAG转二分图）

---

## 可视化设计
### 动画方案
1. **像素风格展示**  
   - **节点**：8位方块，红/蓝表示性别，绿色表示已选入独立集  
   - **边**：灰色线条表示跳过舞的关系，黄色高亮当前匹配边  
   ```javascript
   // Canvas绘制示例
   ctx.fillStyle = gender[u] ? '#FF0000' : '#0000FF';
   ctx.fillRect(x*50, y*50, 40, 40); 
   ```
   
2. **算法流程演示**  
   - **步骤1**：DFS染色过程，用闪烁边框表示当前染色节点  
   - **步骤2**：匈牙利算法中，用红色箭头显示增广路径回溯  
   - **最终结果**：独立集节点持续发光，匹配边变为虚线  

3. **交互控制**  
   - **速度滑块**：调节算法执行速度（0.5x~5x）  
   - **单步执行**：空格键逐步执行染色/匹配步骤  
   - **音效反馈**：  
     - 染色成功：8-bit "哔"声  
     - 找到增广路：上扬音阶  
     - 匹配失败：低沉"咚"声  

---

## 代码实现（关键片段）
### 染色+匈牙利核心
```cpp
vector<int> adj[N];
int col[N], match[N];
bool vis[N];

// 二分图染色
void dfs_color(int u, int c) {
    col[u] = c;
    for (int v : adj[u]) {
        if (!col[v]) dfs_color(v, 3 - c);
    }
}

// 匈牙利找增广路
bool dfs_match(int u) {
    for (int v : adj[u]) {
        if (vis[v]) continue;
        vis[v] = true;
        if (!match[v] || dfs_match(match[v])) {
            match[v] = u;
            return true;
        }
    }
    return false;
}

// 主逻辑
int main() {
    // ... 输入建图
    for (int i = 1; i <= n; ++i)
        if (!col[i]) dfs_color(i, 1);
    int cnt = 0;
    for (int i = 1; i <= n; ++i) 
        if (col[i] == 1) {
            memset(vis, 0, sizeof(vis));
            cnt += dfs_match(i);
        }
    cout << n - cnt;
}
```

---

## 个人心得摘录
> "染色时如果按照`v == father`判断会MLE，必须用`vis`数组记录访问状态" —— K2sen  
> 调试发现当图存在复杂环结构时，单纯父节点判断无法覆盖所有情况，必须用全局访问标记

> "网络流解法中交换x,y保证性别方向正确" —— Kris_hukr  
> 实际数据中无法保证输入顺序的性别，需动态调整边的方向

---

## 知识扩展
**二分图性质**：  
- 最大匹配 = 最小点覆盖（Konig定理）  
- 最大独立集 + 最小点覆盖 = 总顶点数  
- 无奇环是二分图的充要条件（可用于验证题目输入合法性）

---
处理用时：76.44秒
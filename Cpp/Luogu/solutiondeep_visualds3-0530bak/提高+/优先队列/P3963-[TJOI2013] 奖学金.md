# 题目信息

# [TJOI2013] 奖学金

## 题目背景

小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。

## 题目描述

小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  
要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。


## 说明/提示

### 样例 1 解释

选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^3$，$c \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $3 \leq n  \leq 10^5$，$n \leq c \leq 2 \times 10^5$，$0 \leq f \leq 2\times 10^9$，$0 \leq a_i \leq 2 \times 10^9$，$0 \leq b_i \leq 10^5$。

## 样例 #1

### 输入

```
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出

```
35```

## 样例 #2

### 输入

```
5 6 9
4 0
4 1
6 3
8 0
10 4
10 5
```

### 输出

```
6```

# AI分析结果



# 算法分类：贪心 + 堆（优先队列）

## 综合分析与结论

### 核心思路
1. **排序预处理**：将学生按成绩升序排列，便于确定中位数的候选范围。
2. **双向堆维护**：
   - 预处理每个位置左侧前k小的奖学金和（使用大根堆维护最小k项）
   - 预处理每个位置右侧前k小的奖学金和（同上）
3. **逆序枚举中位数**：从后往前检查第一个满足 `左和+右和+当前奖学金 ≤ f` 的中位数。

### 解决难点
- **动态维护前k小和**：通过大根堆保持堆顶为当前最大元素，每次插入新元素时若堆未满直接加入，否则替换堆顶以保持总和最小。
- **时间复杂度优化**：预处理过程为 O(c log k)，满足题目数据规模要求。

### 可视化设计
- **像素化排序列表**：用不同颜色块表示学生成绩，右侧为高成绩。
- **堆动态展示**：预处理时左右堆用方块堆叠表示，堆顶颜色更深，实时显示当前总和。
- **中位数检查特效**：高亮当前中位数候选位置，左右堆数值联动，超过限额时触发红色警示。
- **音效反馈**：成功时播放上升音阶，失败时短促蜂鸣声。

---

## 题解清单（≥4星）

1. **胖头鱼学员（5星）**
   - 亮点：代码最简，正反扫描预处理，堆维护清晰。
   - 关键代码：
     ```cpp
     for(int i=1;i<=n/2;i++) q.push(a[i].w), sum += a[i].w;
     for(int i=n/2+1;i<=c-n/2;i++){
         f[i] = sum;
         if(a[i].w < q.top()) sum += a[i].w - q.top(), q.pop(), q.push(a[i].w);
     }
     ```

2. **ycyaw（4.5星）**
   - 亮点：完整注释，变量命名规范，逆序枚举逻辑明确。
   - 个人心得：强调成绩排序后必须从大到小枚举中位数，确保找到第一个合法解即最大值。

3. **ix35（4星）**
   - 亮点：权值线段树实现，提供另一种思路，适合想学习高级数据结构的学习者。
   - 关键函数：
     ```cpp
     ll query(int p,int l,int r,int k){
         if(l==r) return l*k; // 处理叶子节点时乘以数量
         int mid=(l+r)>>1;
         if(k <= siz[p*2]) return query(p*2,l,mid,k);
         else return val[p*2] + query(p*2+1,mid+1,r,k-siz[p*2]);
     }
     ```

---

## 最优思路提炼

### 核心技巧
- **堆维护前k小和**：通过大根堆动态维护当前最小的k个元素，总和计算高效。
- **逆序枚举中位数**：排序后从后往前找第一个满足条件的解，保证中位数最大。

### 类似题目
1. **P1801 黑匣子**（动态维护第k小）
2. **P1168 中位数**（实时计算流数据中位数）
3. **P3834 主席树模板**（静态区间第k小查询）

---

## 代码实现（核心逻辑）

```cpp
#include <algorithm>
#include <queue>
using namespace std;
const int MAXN = 2e5+5;

struct Student { int score, money; } arr[MAXN];
int leftSum[MAXN], rightSum[MAXN];

int main() {
    int n, c, f; 
    scanf("%d%d%d", &n, &c, &f);
    for(int i=1; i<=c; i++) 
        scanf("%d%d", &arr[i].score, &arr[i].money);
    
    sort(arr+1, arr+c+1, [](auto& a, auto& b){ 
        return a.score < b.score; 
    });

    int k = n/2;
    priority_queue<int> q;
    
    // 预处理左侧
    int sum = 0;
    for(int i=1; i<=c; i++) {
        q.push(arr[i].money);
        sum += arr[i].money;
        if(q.size() > k) {
            sum -= q.top();
            q.pop();
        }
        leftSum[i] = (q.size()==k) ? sum : 0x3f3f3f3f;
    }
    
    // 预处理右侧
    q = priority_queue<int>();
    sum = 0;
    for(int i=c; i>=1; i--) {
        q.push(arr[i].money);
        sum += arr[i].money;
        if(q.size() > k) {
            sum -= q.top();
            q.pop();
        }
        rightSum[i] = (q.size()==k) ? sum : 0x3f3f3f3f;
    }
    
    // 逆序找答案
    int ans = -1;
    for(int i=c-k; i>=k+1; i--) {
        if(leftSum[i-1] + rightSum[i+1] + arr[i].money <= f) {
            ans = arr[i].score;
            break;
        }
    }
    printf("%d", ans);
    return 0;
}
```

---

## 可视化算法演示（伪代码）

```javascript
// Canvas绘制逻辑（简化版）
function drawStudents() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制排序后的学生列表
    for(let i=0; i<students.length; i++) {
        drawRect(i*10, 100, 8, students[i].scoreColor);
    }
    // 绘制左右堆
    drawHeap(leftHeap, 50, 200, '左堆');
    drawHeap(rightHeap, 250, 200, '右堆');
    // 高亮当前中位数位置
    if(currentMedian !== -1) {
        ctx.fillStyle = '#FF0000';
        drawRect(currentMedian*10, 100, 8, 'red');
    }
}

// 音效触发
function playSound(effect) {
    if(effect === 'success') new Audio('success.ogg').play();
    else if(effect === 'fail') new Audio('fail.ogg').play();
}
```

---

## 个人心得摘录
- **渡墨残殇**：调试中发现未处理奖学金重复值导致错误，强调边界条件的重要性。
- **FutaRimeWoawaSete**：原题未说明n为奇数，实际需自行推导，提醒审题需谨慎。
- **saligia**：平衡树实现时发现动态更新堆顶的逻辑易错，需反复验证总和计算。

---
处理用时：87.54秒
# 题目信息

# [AHOI2007] 密码箱

## 题目描述

在一次偶然的情况下，小可可得到了一个密码箱，听说里面藏着一份古代流传下来的藏宝图，只要能破解密码就能打开箱子，而箱子背面刻着的古代图标，就是对密码的提示。

经过艰苦的破译，小可可发现，这些图标表示一个数以及这个数与密码的关系。假设这个数是 $n$，密码为 $x$，那么可以得到如下表述： 密码 $x$ 大于等于 $0$，且小于 $n$，而 $x$ 的平方除以 $n$，得到的余数为 $1$。 小可可知道满足上述条件的 $x$ 可能不止一个，所以一定要把所有满足条件的 $x$ 计算出来，密码肯定就在其中。计算的过程是很艰苦的，你能否编写一个程序来帮助小可可呢？

## 样例 #1

### 输入

```
12```

### 输出

```
1
5
7
11```

# AI分析结果



## 算法分类
数论/因数分解

---

## 题解思路与核心难点

### 核心思路
1. **问题转化**：将方程 $x^2 \equiv 1 \pmod{n}$ 转化为 $(x+1)(x-1) = kn$，要求 $n$ 能整除 $(x+1)(x-1)$。
2. **因数分解**：枚举 $n$ 的所有因数对 $(a,b)$，满足 $a \cdot b = n$，通过以下两种条件生成 $x$：
   - $a \mid (x-1)$ 且 $b \mid (x+1)$ → $x = j \cdot b - 1$
   - $a \mid (x+1)$ 且 $b \mid (x-1)$ → $x = j \cdot b + 1$
3. **去重与排序**：用集合（`set`）自动去重后输出。

### 难点与解决
1. **因数枚举优化**：只需枚举 $a \leq \sqrt{n}$ 的因数，避免重复计算。
2. **解的构造**：通过模运算条件快速筛选合法 $x$，如检查 $(j \cdot b \pm 1) \mod a$ 是否为 0。
3. **边界处理**：特判 $n=1$ 无解，且 $x=1$ 始终为合法解。

---

## 题解评分（≥4星）

### 1. JuRuo_QAQ（★★★★☆）
- **亮点**：代码简洁，使用 `set` 自动去重，明确处理了 $n=1$ 的边界条件。
- **代码片段**：
  ```cpp
  for (ll j = b+1; j <=n; j+=b) if ((j+1)%i==0) s.insert(j);
  for (ll j = b-1; j <=n; j+=b) if ((j-1)%i==0) s.insert(j);
  ```

### 2. 试试事实上吗（★★★★☆）
- **亮点**：通过 `sqrt(n)` 减少枚举次数，逻辑清晰，注释详细。
- **个人心得**：强调枚举时 $a \leq \sqrt{n}$ 的优化，避免重复计算。

### 3. Aiopr_2378（★★★★☆）
- **亮点**：结构清晰，直接输出 $x=1$ 避免遗漏，代码可读性高。
- **核心逻辑**：
  ```cpp
  for (ll i=1; i*i<=n; i++) {
    if (n%i==0) {
        ll a=i, b=n/i;
        // 生成 x = j*b ±1 并检查条件
    }
  }
  ```

---

## 最优思路提炼
1. **因数对拆分**：将 $n$ 分解为 $(a,b)$，每个因数对生成两类解。
2. **模运算快速筛选**：通过倍数跳跃（`j += b`）减少无效计算。
3. **集合去重**：利用 `set` 的自动排序和去重特性简化代码。

---

## 类似算法题目
1. **P1082 [NOIP2012 提高组] 同余方程**（求解线性同余方程）
2. **P2424 约数和**（因数分解与求和）
3. **P1075 [NOIP2012 普及组] 质因数分解**（基础因数分解应用）

---

## 个人心得摘录
- **青丘杨哲**：强调枚举较大的因数（$> \sqrt{n}$）以提高效率。
- **Viktley**：通过拆分 $(x+1)=d \cdot y$ 和 $(x-1)=k \cdot \frac{n}{y}$ 构造方程。

---

## 可视化算法设计

### 动画设计
1. **因数分解展示**：在 Canvas 上绘制 $n$ 的因数对 $(a,b)$，高亮当前枚举的 $a$。
2. **解生成过程**：对每个因数对，动态生成 $j \cdot b \pm 1$ 的值，用颜色标记合法解（绿色）和非法解（红色）。
3. **集合更新**：在右侧面板实时显示 `set` 中添加的 $x$ 值，排序后输出。

### 复古像素风格
- **颜色方案**：16 色调色板，用黄色表示当前因数对，蓝色表示合法解。
- **音效设计**：
  - **生成解**：8-bit 短音效（类似《超级马里奥》金币声）。
  - **完成枚举**：播放经典 RPG 升级音效。

### 交互功能
- **步进控制**：允许单步执行因数枚举或自动播放（速度可调）。
- **高亮提示**：用闪烁边框标记当前检查的 $(j \cdot b \pm 1) \mod a$ 条件。

---

## 核心代码片段（以 JuRuo_QAQ 为例）
```cpp
#include<cstdio>
#include<set>
typedef long long ll;
std::set<ll> s;

int main() {
    ll n; scanf("%lld", &n);
    if (n == 1) { puts("None"); return 0; }
    puts("1");
    for (ll i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            ll a = i, b = n / i;
            for (ll j = b + 1; j <= n; j += b)
                if ((j + 1) % a == 0) s.insert(j);
            for (ll j = b - 1; j <= n; j += b)
                if ((j - 1) % a == 0) s.insert(j);
        }
    }
    for (auto x : s) printf("%lld\n", x);
    return 0;
}
```

---

## 总结
本题通过因数分解和模运算条件筛选，高效生成所有合法解。关键优化在于因数对的枚举范围和快速模检查，代码实现简洁且去重高效。

---
处理用时：70.84秒
# 题目信息

# 【CSGRound2】逐梦者的初心

## 题目背景

#### 注意：本题时限修改至250ms，并且数据进行大幅度加强。本题强制开启O2优化，并且不再重测，请大家自己重新提交。

由于Y校的老师非常毒瘤，要求zhouwc在csp考前最后3天参加期中考，zhouwc非常生气，决定消极考试，以涂完卡但全错为目标。现在retcarizy看zhouwc太可怜了，想要帮zhouwc解决一个问题，但他自己又太忙了，咕咕咕，于是就把问题甩给了你。

## 题目描述

给你一个长度为n的字符串S。

有m个操作，保证$m\le n$。

你还有一个字符串T，刚开始为空。

共有两种操作。

第一种操作：

在字符串T的末尾加上一个字符。

第二种操作：

在字符串T的开头加上一个字符。

每次操作完成后要求输出有几个$l \in [1,T.size]$满足以下条件：

对于$\forall i \in [1,l]$有$T_{T.size-l+i} \ne S_{i}$ 

$Tip:$字符串下标从1开始。$T.size$表示T的长度。

## 说明/提示

注意：本题采用**捆绑测试**，只有当你通过一个subtask的所有点后，你才能拿到这个subtask的分数

对于所有的数据 $n \leq 10^6,m \leq 3.3333 \times 10^4,|\sum|\leq10^3,S_i \in [1,|\sum|]$。($\sum$表示字符集)

subtask1$(17\%)$:$m \leq 333$

subtask2$(33\%)$:$m \leq 3333$

subtask3$(20\%)$:$|\sum|\leq2$

subtask4$(30\%)$:无特殊条件


#### 样例解释：
第一次操作后，$T="1"$,

$l=1$时$T[1]=S[1]$，所以答案为0

第二次操作后，$T="21"$,

$l=1$时，$T[2]=S[1]$

$l=2$时，$T[1]!=S[1]$,$T[2]!=S[2]$所以答案为1

第三次操作后，$T="213"$,

$l=1$时，$T[3]!=S[1]$;

$l=2$时，$T[2]=S[1]$;

$l=3$时，$T[3]=S[3]$所以答案为1


## 样例 #1

### 输入

```
10 3
1 2 3 1 2 3 2 3 2 3
0 1
1 2
0 3```

### 输出

```
0
1
1```

# AI分析结果



## 算法分类
位运算优化（bitset）

---

## 题解思路与解决难点

### 核心思路
维护所有非法长度 l，使得存在位置 i ≤ l 使得 T 的后 l 位与 S 的前 l 位匹配。最终答案为总长度范围内未被标记的 l 的个数。

### 关键步骤
1. **预处理**：对 S 的每个字符建立 bitset，记录其在 S 中出现的位置。
2. **操作处理**：
   - **尾部添加**：所有已有长度 l 扩展为 l+1，用左移操作合并新字符匹配位置。
   - **头部添加**：新字符可能影响所有后续可能的长度，用位或操作合并新字符在 S 中位置的偏移。
3. **答案计算**：使用补集思想，统计未被标记的长度。

### 解决难点
- **动态维护匹配状态**：利用 bitset 的位运算特性，将 O(m²) 的暴力检查优化为 O(m²/w) 的位操作。
- **双端插入处理**：头部插入时通过位移偏移字符位置，尾部插入时通过左移继承原有状态。

---

## 题解评分（≥4星）

### 1. zhouwc 官方题解（5星）
- **亮点**：bitset 位运算实现 O(m²/w) 复杂度，预处理字符位置，代码简洁高效。
- **核心代码**：
  ```cpp
  bitset<35005> f, id[1005], now;
  if(opt==0) f = (f<<1) | id[dt];  // 尾部插入
  else f = f | (id[dt] << (i-1));  // 头部插入
  printf("%d\n", (~(f | now)).count());
  ```

### 2. lqx_bnu 详解（4星）
- **亮点**：详细解释 bitset 的转移逻辑，费用提前思想分析到位。
- **核心贡献**：
  - 尾部插入对应 f 左移并合并新字符冲突位。
  - 头部插入对应偏移字符位置后的位或操作。

### 3. 天泽龟 考场思路（4星）
- **亮点**：从暴力到 bitset 的思维过程完整，提供可读性强的调试经验。
- **核心代码**：
  ```cpp
  if (!op) ans=(ans<<1)|id[x];  // 尾部插入优化
  else ans|=(id[x]<<(i-1));     // 头部插入优化
  ```

---

## 最优思路提炼
1. **状态压缩**：用 bitset 的每一位表示长度 l 是否非法。
2. **字符预映射**：为每个字符预存其在 S 中的位置集合，加速冲突检测。
3. **位运算合并**：
   - 尾部插入时，原有状态左移并合并新字符的冲突。
   - 头部插入时，将新字符的冲突位置偏移后合并到全局状态。

---

## 类似题目推荐
1. **P5357 【模板】AC自动机（二次加强版）**  
   （bitset 优化多模式匹配）
2. **P3823 [NOI2017] 蚯蚓排队**  
   （字符串动态拼接与哈希位运算）
3. **P4173 残缺的字符串**  
   （位运算优化通配符匹配）

---

## 可视化设计
### 动画方案
1. **像素网格**：每个操作步显示 bitset 的二进制位，绿色表示合法长度，红色表示非法。
2. **关键操作高亮**：
   - 头部插入时，用橙色箭头标记偏移量。
   - 尾部插入时，用蓝色箭头表示左移操作。
3. **音效反馈**：
   - 合法长度增加时播放上升音调。
   - 位运算操作时播放电子合成音效。

### 交互控制
- **步进控制**：空格键单步执行操作。
- **速度调节**：滑动条控制动画速度（0.5x~4x）。
- **模式切换**：可选显示原始字符串匹配过程或 bitset 状态。

### 复古风格
- **8位像素字体**：用 16x16 像素字符显示 bitset。
- **FC 音效**：使用芯片音乐风格音效标记状态变化。
- **关卡进度**：将每个操作视为一关，通关后显示累计分数。

---

## 核心代码实现（C++）
```cpp
#include<bitset>
#include<cstdio>
using namespace std;

const int MAXM = 35005;
bitset<MAXM> f, id[1005], now;
int n, m, S[1000005];

int main() {
    scanf("%d%d", &n, &m);
    for(int i=1; i<=n; ++i) scanf("%d", &S[i]);
    for(int i=1; i<=m; ++i) id[S[i]].set(i);
    now.set(); // 初始化全1，用于屏蔽超长部分
    
    for(int i=1; i<=m; ++i) {
        int opt, dt;
        scanf("%d%d", &opt, &dt);
        now.reset(i); // 第i位之后不可选
        
        if(opt == 0) // 尾部添加
            f = (f << 1) | id[dt];
        else // 头部添加
            f |= id[dt] << (i-1);
        
        printf("%d\n", (~(f | now)).count());
    }
    return 0;
}
```

---
处理用时：76.77秒
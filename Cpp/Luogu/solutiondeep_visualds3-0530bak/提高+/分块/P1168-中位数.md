# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果



**唯一算法分类**：对顶堆（双堆维护）

---

### **综合分析与结论**
- **核心思路**：维护大根堆（存较小半部分）和小根堆（存较大半部分），保持两堆大小差≤1，中位数为较大堆的堆顶。
- **难点**：动态调整堆大小，确保大根堆元素≤小根堆元素。
- **解决方案**：
  - **插入策略**：新元素根据与当前中位数比较选择堆。
  - **平衡调整**：若堆大小差>1，将较大堆顶元素移至较小堆。
- **可视化设计**：
  - **动画**：展示元素插入堆的过程，高亮调整步骤。
  - **像素风格**：用颜色区分堆，红/蓝块表示堆元素，堆顶闪烁显示中位数。
  - **音效**：插入时播放音效，调整堆时播放调整音。

---

### **题解清单 (≥4星)**
1. **肖恩Sean（赞534）**  
   - **亮点**：代码简洁，逻辑清晰，维护堆平衡高效。
   - **核心代码**：
     ```cpp
     priority_queue<int> q1; // 大根堆（较小半）
     priority_queue<int, vector<int>, greater<int>> q2; // 小根堆（较大半）
     if (input > q1.top()) q2.push(input);
     else q1.push(input);
     while (abs(q1.size() - q2.size()) > 1) {
         // 调整堆顶元素...
     }
     ```
2. **IRipple（赞376）**  
   - **亮点**：引入中间变量`mid`动态调整，更直观。
   - **关键步骤**：
     ```cpp
     if (a[i] > mid) q2.push(a[i]);
     else q1.push(a[i]);
     if (q1.size() > q2.size()) {
         q2.push(mid);
         mid = q1.top();
         q1.pop();
     }
     ```
3. **婷菡（赞50）**  
   - **亮点**：图形化解释堆结构，适合新手理解。
   - **图示**：堆顶为中位数，堆间元素大小关系明确。

---

### **核心代码实现**
**对顶堆完整代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, x;
    cin >> n;
    priority_queue<int> q1; // 大根堆（较小半）
    priority_queue<int, vector<int>, greater<int>> q2; // 小根堆（较大半）

    cin >> x;
    q1.push(x);
    cout << x << endl;

    for (int i = 3; i <= n; i += 2) {
        int a, b;
        cin >> a >> b;
        // 插入元素
        if (a > q1.top()) q2.push(a);
        else q1.push(a);
        if (b > q1.top()) q2.push(b);
        else q1.push(b);
        // 调整堆平衡
        while (q1.size() > q2.size() + 1) {
            q2.push(q1.top());
            q1.pop();
        }
        while (q2.size() > q1.size()) {
            q1.push(q2.top());
            q2.pop();
        }
        cout << q1.top() << endl;
    }
    return 0;
}
```

---

### **同类型题目推荐**
1. **P1801 黑匣子**：动态维护第k小元素。
2. **P3871 [TJOI2010]中位数**：类似动态中位数查询。
3. **P1168 变形题**：扩展为滑动窗口中位数。

---

### **可视化与算法演示**
- **动画设计**：
  - **Canvas网格**：分左右两区表示堆，插入元素时动态移动。
  - **颜色标记**：大根堆用红色，小根堆用蓝色，堆顶高亮黄色。
  - **音效**：插入时“哔”声，调整堆时“咔嚓”声。
- **交互控制**：支持暂停/继续，调整动画速度，单步执行观察堆变化。

**伪代码示例（JS Canvas）**：
```javascript
// 绘制堆元素
function drawHeap(heap, x, y, color) {
    heap.forEach((val, i) => {
        ctx.fillStyle = color;
        ctx.fillRect(x, y + i*30, 50, 25);
        ctx.fillText(val, x+10, y+20 + i*30);
    });
}
// 插入动画
function animateInsert(val) {
    // 移动元素到对应堆...
}
```

---

### **个人心得摘录**
- **肖恩Sean**：“维护堆平衡的关键是及时调整堆顶，确保中位数始终在正确位置。”
- **IRipple**：“中间变量`mid`简化了堆调整的逻辑，避免频繁访问堆顶。”

---

**总结**：对顶堆法以简洁高效成为最优解，适合快速实现和教学演示。其他方法虽各有优势，但复杂度或实现难度较高。

---
处理用时：79.18秒
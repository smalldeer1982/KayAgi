# 题目信息

# 双亲数

## 题目描述

小 D 是一名数学爱好者，他对数字的着迷到了疯狂的程度。

我们以 $d = \gcd(a, b)$ 表示 $a, b$ 的最大公约数，小 D 执著的认为，这样亲密的关系足可以用双亲来描述，此时，我们称**有序**数对 $(a, b)$ 为 $d$ 的双亲数。

与正常双亲不太相同的是，对于同一个 $d$，他的双亲太多了。

比如，$(4, 6)$，$(6, 4)$，$(2, 100)$ 都是 $2$ 的双亲数。  

于是一个这样的问题摆在眼前，对于 $1 \leq a \leq A$，$1 \leq b \leq B$，有多少**有序**数对 $(a, b)$ 是 $d$ 的双亲数？

## 说明/提示

#### 样例 1 解释

共有三对双亲数：$(2, 2)$，$(2, 4)$，$(4, 2)$。

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证 $1 \leq A, B \leq 10^6$。
- 对于 $100\%$ 的数据，保证 $1 \leq A, B \leq 10^6$，$1 \leq d \leq \min(A, B)$。

## 样例 #1

### 输入

```
5 5 2
```

### 输出

```
3```

# AI分析结果



## 算法分类
**莫比乌斯反演**

## 题解分析与结论

### 核心思路对比
1. **莫比乌斯反演法**（题解数：12）
   - 核心公式推导：
     $$\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}\sum_{k|gcd(i,j)}\mu(k) = \sum_{k=1}^{\min(A/d,B/d)}\mu(k)\lfloor\frac{A}{kd}\rfloor\lfloor\frac{B}{kd}\rfloor$$
   - 实现步骤：
     - 预处理莫比乌斯函数μ(n)
     - 使用整除分块优化计算
   - 时间复杂度：O(n)预处理 + O(√n)查询

2. **递推法**（题解数：2）
   - 定义f(d)为gcd恰好为d的对数
   - 递推式：f(d) = g(d) - ∑f(kd)
   - 时间复杂度：O(n log n)

### 解决难点对比
| 方法                | 核心难点                     | 解决方案                     |
|--------------------|----------------------------|----------------------------|
| 莫比乌斯反演         | 公式推导与整除分块实现         | 利用μ函数的积性性质线性筛预处理   |
| 递推法              | 避免重复计算倍数项            | 逆序枚举并动态维护结果数组       |

### 最优思路提炼
**莫比乌斯反演 + 整除分块** 为最优方案：
1. 预处理μ函数时，使用线性筛法同时处理质数和μ值
2. 整除分块时通过`min(n/(n/i), m/(m/i))`确定块边界
3. 核心代码段：
```cpp
for(int l=1, r; l <= min(A,B); l=r+1){
    r = min(A/(A/l), B/(B/l));
    ans += (mu[r] - mu[l-1]) * (A/l) * (B/l);
}
```

## 高分题解推荐 (4★+)
1. **fzwfzwfzw 题解**（4.8★）
   - 亮点：完整展示莫比乌斯反演推导过程，附带整除分块优化说明
   - 关键代码：
     ```cpp
     int ask(int x,int y){
         int ans=0,r;
         for(int l=1; l<=min(x,y); l=r+1){
             r = min(x/(x/l), y/(y/l));
             ans += (qzh[r]-qzh[l-1])*(x/l)*(y/l);
         }
         return ans;
     }
     ```

2. **Isonan 题解**（4.7★）
   - 亮点：详细证明莫比乌斯函数性质，给出分块边界计算推导
   - 调试心得：强调预处理时μ[1]=1的初始化易错点

3. **Wolfycz 题解**（4.5★）
   - 亮点：代码高度优化，使用快速读入和寄存器变量
   - 关键优化：
     ```cpp
     #pragma GCC optimize("Ofast")
     for(register int i=2; i<=N; ++i){
         if(!vis[i]) prime[++cnt]=i, mu[i]=-1;
         //...线性筛逻辑
     }
     ```

## 可视化方案设计

### 算法演示动画
**核心流程：**
1. **莫比乌斯筛法可视化**
   - 展示质数判定（红色标记）
   - 显示μ值计算过程（绿色正μ，蓝色负μ）

2. **整除分块演示**
   - 动态绘制区间分割线（l=1 → r=min(A,B)）
   - 高亮当前分块区间，显示$\lfloor A/i \rfloor$计算值

3. **贡献累加过程**
   - 用不同颜色区分每个分块区间的贡献值
   - 显示分块区间对应的μ值差量（mu[r]-mu[l-1]）

### 复古像素风格实现
**Canvas绘制参数：**
```javascript
const config = {
  blockSize: 16,    // 像素块大小
  colors: {
    prime: '#FF5555',  // 质数标记色
    muPos: '#55FF55',  // μ=1
    muNeg: '#5555FF',  // μ=-1
    currentBlock: '#FFFF00' // 当前分块
  },
  sound: {
    step: '8bit_beep.wav',  // 分块切换音效
    calc: '8bit_blip.wav'   // 计算结果音效
  }
}
```

**关键动画帧：**
1. 筛法过程：每个质数标记时触发黄色闪光
2. 分块跳跃：用像素箭头指示区间边界变化
3. 结果累加：显示当前分块贡献值的位图数字增长

## 相似题目推荐
1. **P2522 [HAOI2011]Problem b**（同模型多区间查询）
2. **P3455 [POI2007]ZAP-Queries**（完全相同的解法）
3. **P3327 [SDOI2015]约数个数和**（进阶反演技巧）

## 实现代码示例
完整莫比乌斯反演解法：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int mu[N],prime[N],cnt;
bool vis[N];

void init(){
    mu[1]=1;
    for(int i=2;i<N;++i){
        if(!vis[i]) prime[++cnt]=i,mu[i]=-1;
        for(int j=1;j<=cnt&&i*prime[j]<N;++j){
            vis[i*prime[j]]=1;
            if(i%prime[j]==0) break;
            mu[i*prime[j]] = -mu[i];
        }
    }
    for(int i=1;i<N;++i) mu[i] += mu[i-1];
}

long long solve(int A,int B,int d){
    A/=d, B/=d;
    if(A>B) swap(A,B);
    long long ans=0;
    for(int l=1,r; l<=A; l=r+1){
        r = min(A/(A/l), B/(B/l));
        ans += 1LL*(mu[r]-mu[l-1])*(A/l)*(B/l);
    }
    return ans;
}

int main(){
    init();
    int a,b,d;
    cin>>a>>b>>d;
    cout<<solve(a,b,d);
    return 0;
}
```

---
处理用时：83.71秒
# 题目信息

# [NOIP 2009 普及组] 分数线划定

## 题目描述

世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 $150\%$ 划定，即如果计划录取 $m$ 名志愿者，则面试分数线为排名第 $m \times 150\%$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。

现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。

## 说明/提示

【样例说明】

$m \times 150\% = 3 \times150\% = 4.5$，向下取整后为 $4$。保证 $4$ 个人进入面试的分数线为 $88$，但因为 $88$ 有重分，所以所有成绩大于等于 $88$ 的选手都可以进入面试，故最终有 $5$ 个人进入面试。

NOIP 2009 普及组 第二题


## 样例 #1

### 输入

```
6 3 
1000 90 
3239 88 
2390 95 
7231 84 
1005 95 
1001 88```

### 输出

```
88 5 
1005 95 
2390 95 
1000 90 
1001 88 
3239 88 ```

# AI分析结果



## 算法分类
排序 + 模拟

---

## 题解思路与难点分析
### 核心思路
1. **排序规则**：按成绩降序排序，成绩相同按报名号升序排列。
2. **分数线计算**：取第 $m \times 150\%$（向下取整）名的分数。
3. **统计人数**：遍历排序后的数组，统计所有分数不低于分数线的选手。

### 关键难点
1. **分数线的边界处理**：向下取整后的位置必须正确，且要考虑同分情况。
2. **同分选手的统计**：分数线确定后，需包含所有分数相同的选手，即使超出计划人数。
3. **稳定排序**：需保证成绩相同时报名号小的排在前面。

### 解决难点
- 通过自定义排序函数确保成绩降序、报名号升序。
- 确定分数线后，遍历数组统计所有分数不低于该线的选手。

---

## 题解评分（≥4星）
### 1. 作者「已注销」 (★★★★☆)
- **亮点**：使用下标数组替代结构体，代码简洁高效。
- **关键代码**：
  ```cpp
  sort(sub+1,sub+n+1,cmp); // 下标排序
  for(i=1;s[sub[i]]>=f;i++); // 统计人数
  ```

### 2. 作者2023z (★★★★☆)
- **亮点**：通过结构体排序，从后往前定位最后一名合格者，逻辑清晰。
- **关键代码**：
  ```cpp
  for(int i=n;i>=1;i--) { // 反向遍历找边界
      if(a[i].s>=x) { j=i; break; }
  }
  ```

### 3. 作者WsW_ (★★★★☆)
- **亮点**：直接遍历统计所有符合条件的选手，代码最简。
- **关键代码**：
  ```cpp
  for(int i=1;i<=n&&p[i].f>=p[m].f;i++) sum++; // 正序统计
  ```

---

## 最优思路提炼
1. **结构体排序**：将选手信息存储在结构体中，按成绩降序、报名号升序排序。
2. **分数线计算**：取 `a[int(m*1.5)].s` 作为分数线。
3. **线性统计**：遍历数组统计所有分数不低于分数线的选手。

---

## 同类型题与算法套路
- **相似题目**：排名类问题（如奖学金评定、Top K 元素筛选）。
- **通用解法**：自定义排序 + 边界值统计。

---

## 推荐题目
1. [P1051 谁拿了最多奖学金](https://www.luogu.com.cn/problem/P1051)
2. [P1093 奖学金](https://www.luogu.com.cn/problem/P1093)
3. [P1781 宇宙总统](https://www.luogu.com.cn/problem/P1781)

---

## 个人心得摘录
- **调试经验**：部分题解因忽略同分选手导致错误，需注意排序后相邻元素的连续性。
- **优化技巧**：下标排序节省内存，反向遍历减少循环次数。

---

## 可视化算法演示
### 动画设计
1. **初始状态**：选手无序排列，显示成绩和报名号。
2. **排序过程**：像素块按成绩降序移动，同分时按报名号调整。
3. **分数线标记**：高亮第 $m \times 150\%$ 名选手，闪烁提示。
4. **遍历统计**：指针从左到右移动，符合条件的选手变色并计数。

### 复古游戏化效果
- **像素风格**：16色方块表示选手，成绩越高颜色越暖。
- **音效**：
  - 排序完成：8-bit 胜利音效。
  - 遍历统计：每合格一人触发“得分”音效。
- **AI 演示**：自动完成排序和统计，展示算法流程。

### 交互控制
- **步进执行**：可暂停观察当前排序状态或统计结果。
- **速度调节**：拖动条控制排序和遍历速度。

---

## 核心代码实现（WsW_ 题解）
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{ int h,f; };
node p[5005];
bool cmp(node x,node y){
    if(x.f!=y.f) return x.f>y.f;
    return x.h<y.h;
}
int main(){
    int n,m,sum=0;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d%d",&p[i].h,&p[i].f);
    sort(p+1,p+n+1,cmp);
    m*=1.5;
    for(int i=1;i<=n&&p[i].f>=p[m].f;i++) sum++;
    printf("%d %d\n",p[m].f,sum);
    for(int i=1;i<=sum;i++) printf("%d %d\n",p[i].h,p[i].f);
    return 0;
}
```

---

## 总结
通过结构体排序和边界值处理，本题核心在于正确理解分数线划定规则，并高效统计所有符合条件的选手。可视化设计通过复古像素风格和交互控制，增强算法学习趣味性。

---
处理用时：165.28秒
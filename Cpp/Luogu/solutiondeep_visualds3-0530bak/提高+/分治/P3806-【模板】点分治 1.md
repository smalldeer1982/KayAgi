# 题目信息

# 【模板】点分治 1

## 题目背景

感谢 hzwer 的点分治互测。




## 题目描述

给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 100$。
- 对于 $60\%$ 的数据，保证 $n\leq 1000$，$m\leq 50$ 。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m\leq 100$，$1 \leq k \leq 10^7$，$1 \leq u, v \leq n$，$1 \leq w \leq 10^4$。

#### 提示

- **本题不卡常**。
- 如果您 #7 一直 RE/TLE，不妨看看 [这个帖子](https://www.luogu.com.cn/discuss/show/188596)。

## 样例 #1

### 输入

```
2 1
1 2 2
2```

### 输出

```
AYE```

# AI分析结果



**唯一算法分类**：点分治

---

### 题解综合分析

#### 核心思路与难点
1. **分治思想**：将树拆分为经过根节点和不经过根节点的路径，递归处理子树。
2. **重心优化**：每次选择子树重心作为根，确保递归层数为 $O(\log n)$。
3. **路径统计**：
   - **桶记录法**（niiick）：用数组 `judge[]` 记录已遍历路径长度，避免重复计算。
   - **双指针法**（Froggy）：排序后双指针匹配，避免 $O(n^2)$ 枚举。
4. **去重逻辑**：同一子树内的路径需排除，通过子树标记或容斥处理。

#### 可视化设计思路
- **重心选择**：用红色高亮当前重心，子树以不同颜色区分。
- **路径计算**：动态显示当前根的遍历过程，蓝色标记已处理路径，绿色标记当前匹配路径。
- **步进控制**：单步演示分治过程，展示重心分裂、路径统计、去重逻辑。
- **像素风格**：树结构用8位网格展示，重心分裂时播放“分裂”音效，路径匹配成功时触发上扬音效。

---

### 题解清单（≥4星）

1. **Froggy（★★★★★）**  
   - **亮点**：双指针替代暴力枚举，复杂度降至 $O(n \log^2 n)$，避免菊花图退化。
   - **关键代码**：排序后双指针匹配，利用子树标记排除同一子树组合。
   ```cpp
   sort(a+1,a+tot+1,cmp);
   for(int i=1;i<=m;i++) {
       int l=1, r=tot;
       while(l<r) {
           if (d[a[l]] + d[a[r]] > query[i]) r--;
           else if (d[a[l]] + d[a[r]] < query[i]) l++;
           else if (b[a[l]] == b[a[r]]) { ... }
           else { ok[i] = true; break; }
       }
   }
   ```

2. **niiick（★★★★☆）**  
   - **亮点**：桶记录路径长度，线性时间统计，需注意清空方式。
   - **心得**：`judge[]` 用栈记录修改位置，避免 memset 清空。
   ```cpp
   for(int j=rem[0];j;--j) q[++p]=rem[j], judge[rem[j]]=1;
   for(int i=1;i<=p;++i) judge[q[i]]=0;
   ```

3. **寒冰（★★★★）**  
   - **亮点**：详细注释与调试经验，强调重心的正确更新方式。
   - **代码**：分治后重新计算子树大小，避免递归层数错误。

---

### 最优思路提炼
- **重心分裂**：递归选择重心，确保树平衡，复杂度正确。
- **双指针法**（最优）：排序后利用单调性，$O(n)$ 完成路径匹配。
- **容斥处理**：先统计整棵树，再减去同一子树的非法路径。

---

### 相似题目推荐
1. **P2634 [国家集训队]聪聪可可**（点分治统计模3余0路径数）
2. **P4178 Tree**（统计小于等于k的路径数）
3. **P4149 [IOI2011]Race**（边权为1，找k边数的最短路径）

---

### 核心代码片段（Froggy双指针法）
```cpp
void calc(int u) {
    sort(a + 1, a + tot + 1, cmp); // 按距离排序
    for (int i = 1; i <= m; i++) {
        int l = 1, r = tot;
        while (l < r) {
            if (d[a[l]] + d[a[r]] > query[i]) r--;
            else if (d[a[l]] + d[a[r]] < query[i]) l++;
            else if (b[a[l]] == b[a[r]]) { // 同一子树
                if (d[a[r]] == d[a[r-1]]) r--;
                else l++;
            } else { // 不同子树，找到答案
                ok[i] = true;
                break;
            }
        }
    }
}
```

---

### 可视化方案（Canvas 动画）
1. **树结构绘制**：用圆形节点和线段边表示树，当前重心红色高亮。
2. **分治过程**：点击步进按钮，递归分裂子树，子树渐变色区分。
3. **路径匹配**：实时显示双指针移动，匹配成功时连线闪烁绿色。
4. **音效触发**：  
   - 指针移动：8-bit "click" 音效。  
   - 匹配成功：上升音阶。  
   - 重心切换：低音鼓点。

---

**总结**：点分治的核心在于重心优化与路径统计策略，双指针法在效率与代码简洁性上表现最优，适合作为模板思路。

---
处理用时：65.25秒
# 题目信息

# 【DSOI 2021】吟唱的金色花海

## 题目背景


**这是一道 IO 交互题。**

在很久很久以前，有一片开满了白色郁金香的花海。某一天，绽放了一朵金色郁金香，从此，这片花海开始了它永生的吟唱……

>   _(Dutch) $\textit{\textcolor{blue}{Het\ universum\ zingt\ voor\ mij!}}$_



## 题目描述

在某一时刻，在某处出现了一朵金色郁金香。然后接下来每一秒，每朵金色郁金香会向其上下左右四个点中所有白色郁金香吟唱，使其变为金色郁金香。

现在告诉你一个点 $(x_0,y_0)$，以及它自第一朵金色郁金香出现起，刚变成金色郁金香的那一秒 $t$，你需要找出最初出现的金色郁金香的位置。

每次你可以输出一行 `0 x y`,然后程序会返回一个值 $0$ 或 $1$，$0$ 表示 $(x,y)$ 在第 $t$ 秒是白色郁金香， $1$ 表示 $(x,y)$ 在第 $t$ 秒是金色郁金香。
你可以输出一行 `1 x y` 告知程序最初出现最初出现的金色郁金香的位置为 $(x,y)$ 以结束程序。

## 说明/提示

| 测试点编号 |     $k =$      | $t \le$ |  $Q=$  |
| :--------: | :------------: | :-----: | :----: |
|     1      |    $10000$     |   $1$   | $100$  |
|    2~3     |    $10000$     |   $5$   | $100$  |
|    4~6     |      $4t$      |  $100$  | $100$  |
|    7~10    | $2 \times MAX$ |  $100$  | $100$  |
|   11~14    |    $MAX+1$     | $10^4$  | $5000$ |
|   15~20    |     $MAX$      | $10^4$  | $5000$ |


每个测试点的分值均为 $5$ 分。

记:在最劣情况下询问 $MAX=\lceil\log_2(t+1)\rceil+2$ 次一定能得出答案。保证 $1 \le t \le 10^4$，$1 \le Q \le 5000$ 且得出的结果的 $x,y$ 的绝对值不大于 $10^5$。

***

提示：由于交互题的特性，若你的算法错误，评测结果为 **TLE** 属于正常现象，请将鼠标放在测试点上查看你的具体错误原因。具体的：
- 若你输出的结果错误，会返回 **You made a mistake in data i!**
- 若你询问了过多的次数，会返回 **You ask too many times in data i!**

## 样例 #1

### 输入

```
2
1 1 0 100

0

0

1

2 1 1 10000

1

1

1

1```

### 输出

```


0 1 1

0 1 -1

0 0 1

1 0 0

0 2 0

0 0 2

0 -2 0

0 0 -2

1 0 0```

# AI分析结果



## 算法分类  
二分查找、曼哈顿距离几何性质  

---

## 题解思路与核心难点  

### 核心思路  
1. **曼哈顿距离约束**：初始点 $(sx, sy)$ 必须满足 $\text{曼哈顿距离}(sx, sy, x_0, y_0) = t$，即位于以 $(x_0,y_0)$ 为中心的菱形边界上。  
2. **对称点性质**：通过询问特定方向点确定初始点所在象限，再二分查找对称点的位置，从而逆推初始坐标。  

### 解决难点  
1. **方向判定**：通过两次关键询问（如右方和下方）确定初始点所在的边（如右上、左下等）。  
2. **二分对称点**：在确定方向后，二分对称点到 $(x_0,y_0)$ 的距离，将问题转化为线性求解。  

---

## 题解评分  

### Suzt_ilymics（5星）  
- **亮点**：方向判定与二分对称点的思路清晰，代码简洁高效，询问次数严格满足 $MAX$。  
- **关键代码**：  
  ```cpp  
  // 方向判定  
  printf("0 %d %d\n", sx + 1, sy); // 询问右方  
  printf("0 %d %d\n", sx, sy + 1); // 询问下方  
  // 二分对称点  
  while(l <= r) {  
      int mid = (l + r) >> 1;  
      printf("0 %d %d\n", sx, sy + 2 * fx2 * mid);  
      if(x) ans = mid, l = mid + 1;  
      else r = mid - 1;  
  }  
  ```  

### cmll02（4星）  
- **亮点**：通过三次询问确定初始点所在边，但代码复杂度略高。  
- **关键代码**：通过询问 $(x+1,y)$ 和 $(x-t,y)$ 缩小范围。  

### VicXF_（4星）  
- **亮点**：分治递归逐步缩小范围，但实现较复杂。  
- **关键代码**：通过递归函数 `ser` 处理直线上的二分。  

---

## 最优思路与技巧提炼  
1. **对称点二分法**：  
   - 通过两次方向询问确定初始点所在的边（如右上、左下）。  
   - 二分对称点到 $(x_0,y_0)$ 的距离，利用曼哈顿距离公式直接计算初始坐标。  
2. **曼哈顿坐标变换**：  
   - 若初始点在右上方，则坐标满足 $sx = x_0 + k, sy = y_0 + (t - k)$，其中 $k$ 为二分结果。  

---

## 类似题目与算法套路  
1. **曼哈顿距离几何**：  
   - 类似题目：洛谷 P3964 [TJOI2013]松鼠聚会（曼哈顿距离转切比雪夫）。  
   - 通用思路：利用对称性、坐标变换简化问题。  
2. **交互式二分**：  
   - 类似题目：Codeforces 1520F2 - Guess the K-th Zero（交互式二分）。  

---

## 推荐相似题目  
1. **洛谷 P7297** - 需要利用曼哈顿距离的几何性质。  
2. **Codeforces 1520F2** - 交互式二分查找。  
3. **洛谷 P3964** - 曼哈顿距离与切比雪夫距离转换。  

---

## 算法可视化设计  

### 动画方案  
1. **初始状态**：  
   - 绘制以 $(x_0,y_0)$ 为中心的菱形边界（红色），表示所有可能的初始点。  
   - 高亮当前询问点（蓝色方块）。  
2. **方向判定阶段**：  
   - 动态显示询问 $(x_0+1,y_0)$ 和 $(x_0,y_0+1)$，根据返回结果用箭头标注初始点所在象限。  
3. **二分阶段**：  
   - 在确定的边上绘制滑动条表示二分范围，绿色区域为有效范围，红色为排除区域。  
   - 每次二分时，对称点坐标动态变化，并显示当前询问的点和结果。  

### 复古像素风格实现  
```javascript  
// Canvas 绘制示例  
ctx.fillStyle = '#FF0000'; // 红色菱形边界  
for (let k = -t; k <= t; k++) {  
    drawPixel(x0 + k, y0 + (t - Math.abs(k)));  
    drawPixel(x0 + k, y0 - (t - Math.abs(k)));  
}  
// 询问动画  
function animateQuery(x, y) {  
    ctx.fillStyle = '#0000FF'; // 蓝色询问点  
    drawPixel(x, y);  
    setTimeout(() => {  
        if (response === 1) ctx.fillStyle = '#00FF00'; // 绿色有效  
        else ctx.fillStyle = '#FF0000'; // 红色无效  
        drawPixel(x, y);  
    }, 500);  
}  
```  

**音效设计**：  
- 询问时播放短促「哔」声（8-bit 音效）。  
- 成功找到时播放胜利音效（上升音阶）。  

---

## 核心代码实现（Suzt_ilymics 解法）  
```cpp  
int main() {  
    T = read();  
    while(T--) {  
        t = read(), sx = read(), sy = read(), k = read();  
        if(t == 0) {  
            printf("1 %d %d\n", sx, sy);  
            fflush(stdout);  
            continue;  
        }  
        // 方向判定  
        printf("0 %d %d\n", sx + 1, sy);  
        fflush(stdout);  
        int fx1 = read() ? 1 : -1;  
        printf("0 %d %d\n", sx, sy + 1);  
        fflush(stdout);  
        int fx2 = read() ? 1 : -1;  
        // 二分对称点  
        int l = 1, r = t, ans = 0;  
        while(l <= r) {  
            int mid = (l + r) >> 1;  
            printf("0 %d %d\n", sx, sy + 2 * fx2 * mid);  
            fflush(stdout);  
            int x = read();  
            if(x) ans = mid, l = mid + 1;  
            else r = mid - 1;  
        }  
        // 计算初始点坐标  
        int Mid = (sy + (sy + 2 * fx2 * ans)) / 2;  
        int tx = sx + fx1 * (t - abs(Mid - (sy + 2 * fx2 * ans)));  
        printf("1 %d %d\n", tx, Mid);  
        fflush(stdout);  
    }  
    return 0;  
}  
```  

**关键逻辑**：  
1. **方向判定**：通过右方和下方的询问确定初始点所在象限。  
2. **对称点二分**：沿确定方向二分，计算对称点距离后逆推初始坐标。

---
处理用时：96.21秒
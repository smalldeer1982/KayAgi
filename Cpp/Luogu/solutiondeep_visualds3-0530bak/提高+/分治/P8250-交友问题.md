# 题目信息

# 交友问题

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/pu73hyh9.png)

## 题目描述

洛谷上有 $n$ 位用户，这些用户组成了一个双向的网络。

洛谷的图片分享机制如下：如果第 $i$ 个用户向他的好友 $j$ 分享了一张照片，那么，$j$ 的所有好友 $k$ 就能看到这张照片。**$j$ 也可以看到这张照片。**

现在，用户 $u_i$ 想分享一张照片，但是TA不想让用户 $v_i$ 看到这张照片。在不发送给自己的情况下，TA想知道，他最多可以发送给多少位好友？

## 说明/提示

对于 $20\%$ 的数据，满足 $1 \le n,q \le 2\times10^3$，$1\le m \le 8\times 10^3$；

对于 $60\%$ 的数据，满足 $1 \le n,q \le 2\times10^4$，$1\le m \le 5\times 10^4$；

对于 $100\%$ 的数据，满足 $1 \le n,q \le 2\times10^5$，$1\le m \le 7\times 10^5$。

**保证没有重边和自环**

## 样例 #1

### 输入

```
6 7 8
5 1
1 4
1 6
5 6
5 4
1 2
5 3
5 3
1 1
3 6
1 5
5 6
1 4
5 2
2 6```

### 输出

```
3
0
0
1
2
2
3
0```

# AI分析结果



## 算法分类
根号分治

---

## 题解思路与解决难点

### 核心问题
对于每个查询 `(u, v)`，计算满足以下条件的 `u` 的邻居 `j` 的数量：
1. `j ≠ u`（不发送给自己）
2. `j ≠ v`（直接排除 `v`）
3. `v ∉ adj[j]`（`j` 的好友中没有 `v`）

### 算法要点
1. **根号分治**：将节点分为大度数（度数 ≥√m）和小度数（度数 <√m）。
2. **预处理大度数节点**：对大度数节点的邻居集合用 `bitset` 压缩存储。
3. **分类处理查询**：
   - **大度数 vs 大度数**：通过 `bitset` 位运算快速计算公共邻居。
   - **大度数 vs 小度数**：遍历小度数节点的邻居，利用预处理的 `bitset` 快速判断。
   - **小度数 vs 小度数**：暴力枚举邻居交集。

### 解决难点
- **时间复杂度优化**：通过根号分治平衡暴力枚举与预处理的开销，总复杂度降至 `O(m√q)`。
- **空间优化**：仅对大度数节点使用 `bitset`，避免存储所有节点的邻接表。

---

## 题解评分（≥4星）

### 阿丑（5星）
- **核心思路**：根号分治 + 离线处理。
- **实现亮点**：离线预处理大度数节点的邻居标记，统一处理相同 `u` 的查询，减少重复计算。
- **代码简洁性**：逻辑清晰，预处理和查询分离。

### _determination_（4星）
- **核心思路**：根号分治 + `bitset`。
- **实现亮点**：根据度数阈值动态选择暴力或位运算，代码分层明确。
- **优化点**：阈值选择灵活，适应不同数据分布。

### RedLycoris（4星）
- **核心思路**：动态阈值 + `bitset` 压缩。
- **实现亮点**：对 `bitset` 的交并操作进行优化，代码模块化程度高。
- **适用性**：针对极端数据分布（如菊花图）有较好表现。

---

## 最优思路提炼

### 关键步骤
1. **根号分治阈值**：设定 `B = √m`，将度数 ≥ `B` 的节点视为大点。
2. **预处理大点**：为每个大点生成 `bitset` 存储其邻居。
3. **查询分类处理**：
   - **大点 vs 大点**：通过 `bitset &` 计算公共邻居。
   - **大点 vs 小点**：遍历小点的邻居，查询是否在大点的 `bitset` 中。
   - **小点 vs 小点**：暴力遍历邻居交集。

### 代码实现片段
```cpp
// 预处理大点
vector<bitset<N>> big_bitsets;
for (int u : 大点列表) {
    bitset<N> bs;
    for (int v : adj[u]) bs.set(v);
    big_bitsets.push_back(bs);
}

// 处理查询
int query(int u, int v) {
    if (是大点(u)) {
        if (是大点(v)) {
            // 位运算计算公共邻居
            auto common = big_bitsets[u] & big_bitsets[v];
            return deg[u] - common.count();
        } else {
            // 遍历v的邻居检查是否存在
            int cnt = 0;
            for (int j : adj[v]) cnt += big_bitsets[u][j];
            return deg[u] - cnt;
        }
    } else {
        // 暴力遍历u的邻居
        int ans = 0;
        for (int j : adj[u]) {
            if (j != v && !adj[v].count(j)) ans++;
        }
        return ans;
    }
}
```

---

## 类似题目
1. **P1983 车站分级**：根号分治处理复杂依赖关系。
2. **P5357 AC自动机（二次加强版）**：利用 `bitset` 优化模式匹配。
3. **P3387 缩点**：分治处理强连通分量。

---

## 可视化设计

### 动画方案
- **数据结构展示**：用网格表示 `bitset`，绿色表示存在边，红色表示无。
- **操作高亮**：
  - **大点处理**：高亮大点的 `bitset`，展示位运算过程。
  - **小点遍历**：动态显示暴力枚举的邻居节点。
- **交互控制**：支持暂停/继续、单步执行，调节动画速度。

### 复古像素风格
- **颜色方案**：8位调色板（绿、红、蓝、黄）表示不同状态。
- **音效**：
  - **位运算**：短促“滴”声。
  - **暴力遍历**：连续“哒哒”声。
- **自动演示**：模拟AI逐步选择最优处理策略。

---

## 总结
通过根号分治平衡暴力与预处理，结合 `bitset` 优化大规模数据查询，是该问题的核心解决思路。关键点在于合理选择阈值，分类处理不同场景，最终实现高效查询。

---
处理用时：141.55秒
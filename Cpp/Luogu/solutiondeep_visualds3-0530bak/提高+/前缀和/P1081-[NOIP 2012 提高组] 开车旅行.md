# 题目信息

# [NOIP 2012 提高组] 开车旅行

## 题目描述

小 $\text{A}$ 和小 $\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。
 
旅行过程中，小 $\text{A}$ 和小 $\text{B}$ 轮流开车，第一天小 $\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    

小 $\text{A}$ 和小 $\text{B}$ 的驾驶风格不同，小 $\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。

在启程之前，小 $\text{A}$ 想知道两个问题：

1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值最小（如果小 $\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。

2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\text{A}$ 开车行驶的路程总数以及小 $\text B$ 行驶的路程总数。


## 说明/提示

【样例1说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)

各个城市的海拔高度以及两个城市间的距离如上图所示。

如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。

如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\text B$ 会直接在城市 $3$ 结束旅行。

如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。

如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。


【样例2说明】

当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \to 2 \to 3 \to 8 \to 9$，小 $\text A$ 走的距离为 $1+2=3$，小 $\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）

如果从城市 $2$ 出发，则路线为 $2 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $3$ 出发，则路线为 $3 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $4$ 出发，则路线为 $4 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $5$ 出发，则路线为 $5 \to 7 \to 8$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $5,1$。

如果从城市 $6$ 出发，则路线为 $6 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$5,1$。

如果从城市 $7$ 出发，则路线为 $7 \to 9 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $8$ 出发，则路线为 $8 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,0$。

如果从城市 $9$ 出发，则路线为 $9$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。

如果从城市 $10$ 出发，则路线为 $10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$0,0$。

从城市 $2$ 或者城市 $4$ 出发小 $\text A$ 行驶的路程总数与小 $\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。

【数据范围与约定】  

对于 $30\%$ 的数据，有$1\le n \le 20,1\le m\le 20$；  
对于$40\%$ 的数据，有$1\le n \le 100,1\le m\le 100$；  
对于 $50\%$ 的数据，有$1\le n \le 100,1\le m\le 1000$；  
对于 $70\%$ 的数据，有$1\le n \le 1000,1\le m\le 10^4$；   
对于 $100\%$ 的数据：$1\le n,m \le 10^5$，$-10^9 \le h_i≤10^9$，$1 \le s_i \le n$，$0 \le x_i \le 10^9$   
数据保证 $h_i$ 互不相同。


## 样例 #1

### 输入

```
4 
2 3 1 4 
3 
4 
1 3 
2 3 
3 3 
4 3
```

### 输出

```
1 
1 1 
2 0 
0 0 
0 0 ```

## 样例 #2

### 输入

```
10 
4 5 6 1 2 3 7 8 9 10 
7 
10 
1 7 
2 7 
3 7 
4 7 
5 7 
6 7 
7 7 
8 7 
9 7 
10 7```

### 输出

```
2 
3 2 
2 4 
2 1 
2 4 
5 1 
5 1 
2 1 
2 0 
0 0 
0 0```

# AI分析结果



### **唯一算法分类**  
倍增法  

---

### **综合分析与结论**  

**核心思路**  
1. **预处理**：通过排序+双向链表/平衡树确定每个城市东侧的最近（小B决策）和次近（小A决策）城市  
2. **倍增法**：构建二维数组 `f[i][j]` 表示从城市i出发行驶2^j轮后的终点，同时记录路程  
3. **查询优化**：用二进制跳跃法快速计算最大行驶距离内的总路程  

**核心难点**  
1. **高效预处理东西方向关系**：需保证后续处理时只考虑东侧未处理的城市  
2. **倍增状态转移**：需处理奇偶轮次交替驾驶的跳跃逻辑  
3. **边界条件处理**：当次近城市不存在时需跳过小A的决策  

**可视化设计**  
1. **链表预处理动画**：  
   - 用像素网格展示排序后的城市海拔  
   - 红色高亮当前处理节点，蓝色标记其前驱/后继节点（图1）  
   - 删除节点时播放“咔嗒”音效，链表指针动态重连  
2. **倍增跳跃演示**：  
   - 城市序列横向排列，绿色箭头表示跳跃路径  
   - 每完成2^j次跳跃时显示金色光效（图2）  
   - 底部状态栏实时显示当前总路程和小A/B的累计值  

---

### **题解清单（≥4星）**  

| 题解作者 | 评分 | 关键亮点 |  
|---------|------|---------|  
| yangrunze | ★★★★★ | 双向链表预处理清晰，代码注释完整，状态转移公式推导严谨 |  
| shadow__ | ★★★★☆ | 采用set实现预处理，代码简洁易读，适合理解核心逻辑 |  
| xiao7_Mr_10_ | ★★★★ | 复古像素化代码风格，调试日志详细，包含实际运行截图 |  

---

### **最优思路与技巧**  

**关键数据结构**  
```cpp
// 双向链表预处理核心代码
struct Node { int h, id, pre, nxt; };
sort(nodes); // 按海拔排序
for(int i=1; i<=n; i++){
    int p = pos[i]; // 当前城市在排序后的位置
    // 找前驱和后继中的最近/次近
    int candidates[] = {nodes[p].pre, nodes[p].pre-1, 
                       nodes[p].nxt, nodes[p].nxt+1};
    // 筛选并比较距离
    del(p); // 删除已处理节点
}
```

**倍增状态转移**  
```cpp
// 构建倍增数组
f[i][0] = ga[i]; // 小A的第一跳
g[i][0] = gb[i]; // 小B的第一跳
for(int j=1; j<=20; j++){
    f[i][j] = f[f[i][j-1]][j-1];
    da[i][j] = da[i][j-1] + da[f[i][j-1]][j-1]; 
    db[i][j] = db[i][j-1] + db[f[i][j-1]][j-1];
}
```

**查询优化**  
```cpp
int calc(int s, int x) {
    int a=0, b=0, cur=s;
    for(int j=20; j>=0; j--){
        if(f[cur][j] && a+b+da[cur][j]+db[cur][j] <= x) {
            a += da[cur][j];
            b += db[cur][j];
            cur = f[cur][j];
        }
    }
    // 最后检查小A是否能单独跳一次
    if(ga[cur] && a+b+da[cur][0] <= x) 
        a += da[cur][0];
    return {a, b};
}
```

---

### **同类型题目推荐**  
1. **P1081 开车旅行**（本题）  
2. **P2680 运输计划**（树上路径倍增）  
3. **P5021 赛道修建**（二分+倍增验证）  

---

### **可视化示例（像素风格）**  
![开车旅行像素动画](https://fakeimg.pl/600x400/ff0000/000/?text=Pixel+Animation)  
- **城市节点**：8x8像素方块，海拔越高颜色越红  
- **指针移动**：黄色箭头指示当前跳跃方向，伴随“滴”声  
- **状态面板**：右下角显示当前跳跃次数和剩余路程  

---

### **核心代码（带音效）**  
```javascript
// Canvas绘制核心逻辑
function drawJumpStep(ctx, cities, curPos, jumpLog){
    ctx.fillStyle = '#8B0000'; // 暗红色背景
    ctx.fillRect(0,0,800,600);
    
    // 绘制城市节点
    cities.forEach((city, idx) => {
        ctx.fillStyle = idx === curPos ? '#FFD700' : '#00FF00';
        ctx.fillRect(idx*40, 300 - city.h*2, 30, 30);
    });
    
    // 播放跳跃音效
    const beep = new Audio('data:audio/wav;base64,UklGRl9...');
    beep.play();
}
```

---

**总结**：本题通过排序+链表的预处理确定方向关系，再以倍增法实现高效查询，其核心在于如何将动态的交替驾驶过程转化为静态的二进制跳跃。可视化设计应重点表现链表节点的动态删除与倍增跳跃的二进制特性。

---
处理用时：83.96秒
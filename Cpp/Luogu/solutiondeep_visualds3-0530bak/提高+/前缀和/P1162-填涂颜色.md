# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果



### 算法分类
无算法分类（核心为连通区域标记，属于图遍历问题）

---

### 题解思路与解决难点
**核心思路**  
通过搜索标记所有能到达边界的0（外部区域），剩余无法到达边界的0即为闭合圈内的区域。关键难点在于正确区分内外区域，避免漏判或误判。

**核心算法流程**  
1. **扩展矩阵边界**：在原始矩阵外围添加一圈0，使外部区域连通，简化边界条件判断。  
2. **BFS/DFS遍历**：从扩展后的边界点出发，标记所有外部0。  
3. **反转标记**：最终将未标记的0视为内部区域，填充为2。

**解决难点**  
- **边界处理**：扩展矩阵避免复杂边界判断，确保所有外部0连通。  
- **空间优化**：在原数组上直接标记，无需额外存储结构。  
- **遍历效率**：BFS/DFS时间复杂度均为O(n²)，适合n≤30的数据规模。

---

### 题解评分（≥4星）

1. **zhy137036（5星）**  
   - **亮点**：扩展矩阵边界，代码极简，逻辑清晰。  
   - **代码片段**：  
     ```cpp
     void search(int x, int y) {
         // 从扩展后的边界(0,0)开始DFS/BFS
     }
     ```

2. **LMB_001（4星）**  
   - **亮点**：DFS直接染色，无需额外数组。  
   - **代码片段**：  
     ```cpp
     void dfs(int p, int q) {
         if (越界或已访问) return;
         a[p][q] = 1; // 标记外部区域
     }
     ```

3. **封禁用户（4星）**  
   - **亮点**：BFS队列实现，处理扩展边界后的遍历。  
   - **代码片段**：  
     ```cpp
     q.push({0,0});
     while (!q.empty()) {
         auto [x,y] = q.front(); q.pop();
         for (四方向移动) 标记并入队外部0;
     }
     ```

---

### 最优思路提炼
**关键技巧**  
- **扩展矩阵**：在原始矩阵外加一圈0，确保外部区域连通。  
- **逆向思维**：标记外部区域后，剩余未标记的0即为内部。  
- **队列优化**：BFS用队列实现层序遍历，避免递归栈溢出。

**代码实现核心**  
```cpp
// 扩展矩阵并初始化
for (int i=0; i<=n+1; i++) 填充边界0;
// BFS遍历外部区域
queue<pair<int,int>> q;
q.push({0,0});
while (!q.empty()) {
    auto [x,y] = q.front(); q.pop();
    if (越界或非0) continue;
    mark(x,y);
    for (四方向) q.push({nx, ny});
}
// 输出时反转标记
cout << (a[i][j]==0 ? 2 : orig_value);
```

---

### 同类型题目推荐
1. **P1506 拯救oibh总部**（同样标记内外区域）  
2. **P1451 求细胞数量**（连通区域计数）  
3. **P1141 01迷宫**（最大连通区域搜索）

---

### 可视化算法演示
**动画设计**  
1. **初始状态**：  
   - 原矩阵显示为网格，0白色，1黑色。  
   - 扩展边界用灰色表示。  

2. **遍历过程**：  
   - BFS队列中的节点显示为蓝色，已访问的外部0变为绿色。  
   - 每一步高亮当前处理的节点，扩散至四邻域。  

3. **填充结果**：  
   - 内部未标记的0渐变为红色，表示最终填色。  

**复古像素风格**  
- **8-bit调色板**：白色（#FFFFFF）、绿色（#00FF00）、红色（#FF0000）、黑色（#000000）。  
- **音效**：扩散时播放“滴”声，填充完成时播放胜利音效。  

**交互功能**  
- **速度控制**：滑动条调节动画速度（100ms~1s/步）。  
- **单步执行**：点击“Next”逐步观察扩散过程。  

---

### 个人心得摘录
> “扩展矩阵的边界就像在迷宫外加了一圈通道，所有外部区域都能被‘洪水’淹没，剩下的孤岛就是答案。” —— 来自题解中对边界扩展的形象比喻。  
>  
> “BFS队列像波纹一样扩散，比DFS更直观展示层序遍历过程。” —— 实现时的调试感悟。  

---

### 代码实现（扩展边界+BFS）
```cpp
#include <iostream>
#include <queue>
using namespace std;

int a[35][35], n;

void bfs() {
    queue<pair<int,int>> q;
    q.push({0,0});
    a[0][0] = 2; // 标记外部
    int dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};
    while (!q.empty()) {
        auto [x,y] = q.front(); q.pop();
        for (int i=0; i<4; i++) {
            int nx = x+dx[i], ny = y+dy[i];
            if (nx>=0 && nx<=n+1 && ny>=0 && ny<=n+1 && a[nx][ny]==0) {
                a[nx][ny] = 2;
                q.push({nx,ny});
            }
        }
    }
}

int main() {
    cin >> n;
    for (int i=1; i<=n; i++)
        for (int j=1; j<=n; j++) {
            cin >> a[i][j];
            if (a[i][j] == 0) a[i][j] = 0; // 保留原始0
            else a[i][j] = 1; // 墙保持1
        }
    bfs();
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=n; j++)
            cout << (a[i][j]==0 ? 2 : 1) << ' ';
        cout << '\n';
    }
}
```

---
处理用时：103.18秒
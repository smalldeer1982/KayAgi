# 题目信息

# [HNOI2004] 敲砖块

## 题目背景

无

## 题目描述

在一个凹槽中放置了 $n$ 层砖块、最上面的一层有 $n$ 块砖，从上到下每层依次减少一块砖。每块砖都有一个分值，敲掉这块砖就能得到相应的分值，如下图所示：

```cpp
14 15  4  3  23
 33  33 76  2
   2   13 11
     22 23
       31
```
如果你想敲掉第 $i$ 层的第 $j$ 块砖的话，若 $i=1$，你可以直接敲掉它；若 $i>1$，则你必须先敲掉第 $i-1$ 层的第 $j$ 和第 $j+1$ 块砖。

你现在可以敲掉最多 $m$ 块砖，求得分最多能有多少。

## 样例 #1

### 输入

```
4 5
2 2 3 4
8 2 7
2 3
49```

### 输出

```
19```

# AI分析结果



---

## 算法分类
动态规划

---

## 题解思路与核心算法

### 核心难点与解决思路
1. **后效性问题**：直接按原始倒三角形建模会存在状态依赖的传递性，需通过旋转三角形或按列处理消除后效性。
2. **状态设计**：将三角形旋转为直角三角形后，状态设计为 `f[i][j][k]` 表示第i列选取前j行且总敲k块砖时的最大得分。
3. **前缀和优化**：预处理每列的前缀和 `sum[i][j]` 加速得分计算。
4. **滚动数组优化**：使用滚动数组或前缀最大值数组 `maxl` 优化空间复杂度至 O(N*M)。

### 关键算法流程
```python
for 每一列 i from 右到左:
    预处理本列前缀和 sum
    for 当前选取行数 j from 下到上:
        for 总敲击数 k in 可行范围:
            # 从上一列的 j-1 行及以上转移
            dp[i][j][k] = max(dp[i+1][t][k-j] for t >= j-1) + sum[i][j]
```

---

## 精选题解（≥4星）

### 1. 作者：BJpers2（5星）
- **亮点**：翻转三角形 + 滚动数组优化，时间复杂度 O(N²M)
- **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    FOS(j,i,1) // 倒序处理列
        FOS(k,min(j+i*(i-1)/2,m),j*(j+1)/2){
            f[j][k] = maxl[j-1][k-j] + s[i][j];
            maxl[j][k] = max(maxl[j+1][k], f[j][k]);
        }
}
```

### 2. 作者：Youngsc（4星）
- **亮点**：未旋转三角形，按列从后向前处理，前缀和直接计算
- **状态转移**：
```cpp
for(int j=n; j>=1; --j)
    for(int i=0,sum=0; i<=n-j+1; ++i,sum+=a[i][j])
        for(int k=i; k<=m; ++k)
            for(int l=max(0,i-1); l<=n-j; ++l)
                f[j][i][k] = max(f[j][i][k], f[j+1][l][k-i] + sum);
```

### 3. 作者：I_AM_HelloWord（4星）
- **亮点**：列间转移的极简实现，通过倒序处理列
```cpp
for(int i=n;i>=1;i--){
    int sum=0;
    for(int j=0;j<=n-i+1;j++)sum+=a[j][i];
    for(int j=n-i+1;j>=0;sum-=a[j--][i])
        for(int k=max(2*j-1,0);k<=m;k++)
            f[i][j][k] = max(f[i+1][j-1][k-j] + sum, ...);
}
```

---

## 最优思路提炼
1. **三角形旋转**：将倒三角形转化为直角三角形，使状态转移方向统一（从左到右或从右到左）。
2. **前缀和压缩**：每列的得分通过前缀和预处理 O(1) 计算。
3. **滚动优化**：使用二维数组 `maxl[j][k]` 记录列间最大值，避免重复计算。
4. **倒序处理列**：从最后一列向前处理，保证无后效性。

---

## 同类题目推荐
1. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)
2. [P1434 滑雪](https://www.luogu.com.cn/problem/P1434)
3. [P1855 榨取kkksc03](https://www.luogu.com.cn/problem/P1855)

---

## 可视化设计

### 动画方案（复古像素风格）
1. **网格绘制**：在 Canvas 绘制旋转后的直角三角形网格，每格表示一个砖块。
2. **颜色标记**：
   - **当前列**：高亮黄色边框
   - **选中砖块**：绿色填充
   - **转移路径**：红色箭头从上一列的 j-1 行指向当前列
3. **音效设计**：
   - 敲砖块时播放 8-bit "哔" 声
   - 状态转移时播放 "滴" 声
4. **自动演示**：
   - 按列从右向左自动扫描，展示每列的行选择过程
   - 单步模式下可暂停观察转移路径

### 交互功能
```javascript
// 伪代码示例
class BrickAnimation {
    constructor(canvas) {
        this.grid = new PixelGrid(canvas, 800, 600);
        this.loadSound('hit', '8bit_beep.wav');
    }
    
    drawStep(i, j, k) {
        this.grid.highlightColumn(i);
        this.grid.fillCell(i, j, 'green');
        this.playSound('hit');
    }
}
```

---

## 核心代码实现
```cpp
// 基于 BJpers2 的优化版本
#include<bits/stdc++.h>
using namespace std;
const int N=55, M=1300;
int n,m,s[N][N],f[N][M],maxl[N][M],ans;

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n-i+1;j++)
            scanf("%d",&s[i][j]), s[i][j]+=s[i][j-1];
            
    for(int i=1;i<=n;i++)
        for(int j=i;j>=1;j--)
            for(int k=j*(j+1)/2; k<=m; k++){
                f[j][k] = maxl[j-1][k-j] + s[i][j];
                maxl[j][k] = max(maxl[j+1][k], f[j][k]);
                ans = max(ans, f[j][k]);
            }
    printf("%d",ans);
    return 0;
}
```

---
处理用时：91.62秒
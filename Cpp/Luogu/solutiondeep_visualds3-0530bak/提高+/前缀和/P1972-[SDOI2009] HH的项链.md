# 题目信息

# [SDOI2009] HH的项链

## 题目描述

HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。  

有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答…… 因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。


## 说明/提示

【数据范围】  

对于 $20\%$ 的数据，$1\le n,m\leq 5000$；   
对于 $40\%$ 的数据，$1\le n,m\leq 10^5$；   
对于 $60\%$ 的数据，$1\le n,m\leq 5\times 10^5$；  
对于 $100\%$ 的数据，$1\le n,m,a_i \leq 10^6$，$1\le l \le r \le n$。

本题可能需要较快的读入方式，最大数据点读入数据约 20MB

## 样例 #1

### 输入

```
6
1 2 3 4 3 5
3
1 2
3 5
2 6
```

### 输出

```
2
2
4```

# AI分析结果



---

## 唯一算法分类
离线处理 + 树状数组

---

## 综合分析与结论
### 核心算法流程
1. **离线排序**：将查询按右端点升序排列，保证处理顺序符合贝壳出现的时间序列
2. **动态维护**：使用树状数组维护每个位置的有效性（当前是否为该数字的最后出现位置）
3. **位置标记**：用vis数组记录每个数字最后出现的位置，遇到重复时撤销前一个位置的贡献
4. **前缀和查询**：利用树状数组的区间查询特性快速计算答案

可视化设计要点：
- **高亮元素**：当前处理的贝壳位置用橙色闪烁，vis数组更新的位置用红色标记，树状数组更新路径用蓝色高亮
- **像素动画**：贝壳序列以8位像素方块表示，不同颜色代表不同贝壳种类，右侧实时显示树状数组的二进制结构
- **音效触发**：贝壳新增时播放"coin"音效，位置撤销时播放"blip"音效，查询完成时播放"power-up"音效

---

## 题解清单（4星及以上）
### 1. dlhham（1433赞） ⭐⭐⭐⭐⭐
**核心亮点**：
- 最早提出右端点排序的核心思想
- 清晰图解说明"只保留最后出现位置"的数学证明
- 代码包含完整的快读优化

### 2. 叶小枫（340赞） ⭐⭐⭐⭐
**核心亮点**：
- 对比树状数组与线段树实现差异
- 详细解析vis数组与pow指针的维护逻辑
- 包含误删sort引发的性能问题分析

### 3. 凌幽（214赞） ⭐⭐⭐⭐
**核心亮点**：
- 最简洁的代码实现（仅40行）
- 使用vector存储排序后的查询
- 包含next数组的预处理优化

---

## 最优思路提炼
### 关键技巧
1. **时间轴思想**：将二维区间查询转化为一维时间序列处理
2. **贡献撤销机制**：通过`vis[a[j]]`定位前驱位置并撤销其贡献
3. **滚动指针优化**：使用`pow`指针避免重复处理区间

### 代码实现
```cpp
// 核心代码片段
sort(q+1, q+m+1, [](auto &a, auto &b){return a.r < b.r;}); // 按右端点排序

int last_pos = 1;
for(int i=1; i<=m; i++){
    // 处理当前查询覆盖的新贝壳
    for(int j=last_pos; j<=q[i].r; j++){ 
        if(vis[a[j]]) update(vis[a[j]], -1); // 撤销前驱贡献
        update(j, 1);                        // 添加当前贡献
        vis[a[j]] = j;                        // 更新最后位置
    }
    last_pos = q[i].r + 1;                   // 滚动指针
    ans[q[i].id] = query(q[i].r) - query(q[i].l-1); // 前缀和差分
}
```

---

## 同类题目推荐
1. **SP3267 DQUERY**（区间不同数模板题）
2. **CF313E**（带修改的区间不同数问题）
3. **P4113**（需要二维树状数组的扩展应用）

---

## 可视化方案设计
### 像素动画演示
1. **贝壳序列**：横向排列的16x16像素方块，颜色对应贝壳类型
2. **处理进度条**：顶部显示当前处理的右端点位置
3. **树状数组结构**：右侧显示二进制索引树，更新时点亮对应节点
4. **状态面板**：显示vis数组内容与当前查询结果

### 交互控制
- **WASD**控制处理速度（加速/减速）
- **空格键**暂停/继续
- **数字键1-3**切换树状数组/线段树/莫队算法演示

### 音效配置
```javascript
// Web Audio音效示例
const playSound = (type) => {
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    osc.frequency.value = type === 'add' ? 880 : 440;
    osc.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.1);
}
```

---

## 核心代码实现
完整树状数组解法（dlhham版本）：
```cpp
#include<bits/stdc++.h>
#define maxn 1000010
using namespace std;

int n,m,a[maxn],tree[maxn],vis[maxn],ans[maxn];
struct Query{int l,r,id;}q[maxn];

inline void update(int p,int v){
    for(;p<=n;p+=p&-p) tree[p]+=v;
}

int query(int p){
    int res=0;
    for(;p;p-=p&-p) res+=tree[p];
    return res;
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",&a[i]);
    scanf("%d",&m);
    for(int i=1;i<=m;++i) 
        scanf("%d%d",&q[i].l,&q[i].r), q[i].id=i;
    
    sort(q+1,q+m+1,[](auto &a,auto &b){return a.r<b.r;});
    
    int ptr=1;
    for(int i=1;i<=m;++i){
        for(int j=ptr;j<=q[i].r;++j){
            if(vis[a[j]]) update(vis[a[j]],-1);
            update(j,1);
            vis[a[j]]=j;
        }
        ptr = q[i].r+1;
        ans[q[i].id] = query(q[i].r)-query(q[i].l-1);
    }
    
    for(int i=1;i<=m;++i) printf("%d\n",ans[i]);
    return 0;
}
```

---
处理用时：79.81秒
# 题目信息

# GCD

## 题目描述

给定正整数 $n$，求 $1\le x,y\le n$ 且 $\gcd(x,y)$ 为素数的数对 $(x,y)$ 有多少对。

## 说明/提示

#### 样例输入输出 1 解释

对于样例，满足条件的 $(x,y)$ 为 $(2,2)$，$(2,4)$，$(3,3)$，$(4,2)$。

---

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1\le n\le10^7$。

---

来源：bzoj2818。

本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时 $5$ 分钟完成数据制作。

## 样例 #1

### 输入

```
4```

### 输出

```
4```

# AI分析结果



## 算法分类
**数论、欧拉函数、线性筛**

---

## 题解思路与解决难点
1. **核心思路**  
   所有题解均围绕「枚举质数 + 欧拉函数前缀和」展开。核心步骤为：  
   - 线性筛预处理素数及欧拉函数  
   - 计算欧拉函数前缀和  
   - 枚举每个素数 $p$，累加 $2 \times \text{sum}(n/p) - 1$  

2. **算法对比**  
   - **欧拉函数法**（Siyuan、zhou_yk等）：  
     - **优点**：直接利用线性筛预处理，时间复杂度 $O(n)$，代码简洁  
     - **难点**：理解 $\sum_{i=1}^k \phi(i)$ 对应互质对数  
   - **莫比乌斯反演法**（Limit、DQYdqy等）：  
     - **优点**：通用性更强，适合非对称区间  
     - **缺点**：预处理复杂，常数较大  

3. **优化要点**  
   - **线性筛**：同时处理素数、欧拉函数  
   - **前缀和优化**：避免重复计算 $\phi$ 的累加值  

---

## 高星题解推荐（≥4星）
1. **Siyuan（5星）**  
   - **亮点**：公式推导清晰，代码简洁高效  
   ```cpp
   void sieve(int n) {
       phi[1] = 1;
       for (int i=2; i<=n; ++i) {
           if (!flg[i]) p[++tot] = i, phi[i] = i-1;
           for (int j=1; j<=tot && i*p[j]<=n; ++j) {
               flg[i*p[j]] = 1;
               if (i % p[j] == 0) {
                   phi[i*p[j]] = phi[i] * p[j];
                   break;
               }
               phi[i*p[j]] = phi[i] * (p[j]-1);
           }
       }
       // 前缀和计算...
   }
   ```

2. **zhou_yk（4.5星）**  
   - **亮点**：详细解释欧拉函数性质，适合新手理解  
   ```cpp
   for (int i=2; i<=n; ++i) {
       if (!vis[i]) prime[++cnt] = i, phi[i] = i-1;
       for (int j=1; j<=cnt && i*prime[j]<=n; ++j) {
           vis[i*prime[j]] = 1;
           if (i % prime[j] == 0) {
               phi[i*prime[j]] = phi[i] * prime[j];
               break;
           }
           phi[i*prime[j]] = phi[i] * (prime[j]-1);
       }
   }
   ```

3. **KobeBeanBryantCox（4星）**  
   - **亮点**：容斥原理思路，提供不同视角  
   ```cpp
   for (int i=n; i>=1; --i) {
       f[i] = (n/i) * (n/i);
       for (int j=2*i; j<=n; j+=i)
           f[i] -= f[j];
   }
   ```

---

## 最优思路提炼
1. **线性筛预处理**：同时生成素数表和欧拉函数数组  
2. **前缀和加速**：$\text{sum}[k] = \sum_{i=1}^k \phi(i)$  
3. **对称性处理**：对于每个素数 $p$，贡献为 $2 \times \text{sum}(n/p) - 1$  

---

## 同类题目推荐
1. [P2257 - YY的GCD](https://www.luogu.com.cn/problem/P2257)  
2. [P2158 - 仪仗队](https://www.luogu.com.cn/problem/P2158)  
3. [P2398 - GCD求和](https://www.luogu.com.cn/problem/P2398)  

---

## 算法可视化设计
**复古像素风格演示**  
1. **筛法过程**：  
   - 用不同颜色方块表示素数（蓝色）和合数（红色）  
   - 动态显示欧拉函数计算时的 `i*p[j]` 标记  

2. **贡献计算**：  
   - 展示每个素数 $p$ 对应的区间 $[1, n/p]$  
   - 高亮当前计算的 $\phi(i)$ 值  

```html
<!-- 示例：Canvas绘制筛法过程 -->
<canvas id="sieveCanvas"></canvas>
<script>
const canvas = document.getElementById('sieveCanvas');
const ctx = canvas.getContext('2d');
// 初始化像素网格绘制...
function drawNumber(i, color) {
    ctx.fillStyle = color;
    ctx.fillRect((i%100)*6, Math.floor(i/100)*6, 5, 5);
}
// 模拟筛法过程时调用 drawNumber
</script>
```

---

## 核心代码实现
**欧拉函数法（Siyuan版）**
```cpp
#include <cstdio>
const int N = 1e7+5, M = 1e6+5;
int n, tot, p[M], phi[N];
long long sum[N];
bool flg[N];

void sieve(int n) {
    phi[1] = 1;
    for (int i=2; i<=n; ++i) {
        if (!flg[i]) p[++tot] = i, phi[i] = i-1;
        for (int j=1; j<=tot && i*p[j]<=n; ++j) {
            flg[i*p[j]] = 1;
            if (i % p[j] == 0) {
                phi[i*p[j]] = phi[i] * p[j];
                break;
            }
            phi[i*p[j]] = phi[i] * (p[j]-1);
        }
    }
    for (int i=1; i<=n; ++i) sum[i] = sum[i-1] + phi[i];
}

int main() {
    scanf("%d", &n);
    sieve(n);
    long long ans = 0;
    for (int i=1; i<=tot; ++i) 
        ans += 2 * sum[n/p[i]] - 1;
    printf("%lld\n", ans);
    return 0;
}
```

---
处理用时：89.78秒
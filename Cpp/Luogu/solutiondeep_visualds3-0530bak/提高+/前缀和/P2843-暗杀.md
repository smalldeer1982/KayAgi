# 题目信息

# 暗杀

## 题目描述

敌方的高级将领都是有很多相同之处的。为了方便找到每名敌将的弱点，我军情报部已经找到了他们的不同点，并将其归纳为 $k$ 种特性。比如 $1$ 号特性就代表一个敌将喜欢打人，$2$ 号特性就代表一个敌将喜欢吃饭，等等。

为了方便存储，我军使用特性值来描述一个敌将的特点。特性值是一个位数为 $k$ 的二进制整数，每一位都可以表示一名敌将的一个特性。$1$ 代表具有此特性，$0$ 代表没有。

我军间谍打听到，不久有 $n$ 个敌方将领会举行一场宴会，而且入场时他们会排成一路纵队入场。如果有连续的 $m$ 个人的每种特性出现的次数之和是一样的，那么我军间谍就很容易暗杀这 $m$ 个人。你需要帮助我军算出，间谍最多可以暗杀多少人？

因为间谍开始攻击后就可能被敌人击毙，所以间谍只能进行一次攻击。

## 说明/提示

- 对于 $30\%$ 的数据，$1 \leq N \leq 100$；
- 对于 $50\%$ 的数据，$1 \leq N \leq 1000$；
- 对于 $100\%$ 的数据，$1 \leq N \leq 10^5$，$1 \leq K \leq 30$。

## 样例 #1

### 输入

```
7 3
7 6 7 2 1 4 2```

### 输出

```
4```

# AI分析结果



**唯一算法分类**：前缀和与哈希表

---

### **综合分析与结论**

**题目核心**：寻找最长的连续子数组，使得每种特性出现的次数相同。  
**关键思路**：利用前缀和差向量作为哈希键，通过哈希表快速查找相同键的最早出现位置，从而确定最大区间。

**核心算法流程**：
1. **前缀和计算**：统计每个位置各特性的累计出现次数。
2. **差向量归一化**：将每个位置的特性前缀和减去第一个特性的前缀和，消除公共增量。
3. **哈希表存储**：记录每个差向量第一次出现的位置。
4. **区间长度计算**：当同一差向量再次出现时，当前区间长度即为 `i - 首次出现位置`，更新最大值。

**难点与解决方案**：
- **时间复杂度**：暴力枚举区间为 O(n²k)，不可行。通过哈希表将时间降至 O(nk)。
- **差向量的哈希冲突**：使用向量整体作为键（如 `vector<int>` 或结构体）避免冲突，或在哈希函数中加入特性间的独立性。

---

### **题解评分（≥4星）**

1. **int_LL（4星）**  
   - **亮点**：直接使用 `vector<int>` 作为哈希键，代码简洁，思路清晰。  
   - **代码**：通过 `sum[i][j] - sum[i][1]` 归一化，初始化时存入全零向量处理边界条件。

2. **Link_Space（4星）**  
   - **亮点**：实时归一化处理，每次更新差向量时减去第一个特性的值，逻辑紧凑。  
   - **代码**：位运算处理特性值，注释详细，便于理解。

3. **Harece（4星）**  
   - **亮点**：开放寻址法处理哈希冲突，二次检查确保正确性，适合大数据场景。  
   - **代码**：自定义哈希函数，优化内存访问。

---

### **最优思路或技巧提炼**

1. **差向量归一化**  
   - 将前缀和转化为差向量（如 `sum[i][j] - sum[i][1]`），消除公共增量，使得相同差向量对应的区间满足条件。
2. **哈希表加速查找**  
   - 使用 `map<vector<int>, int>` 或自定义哈希结构，快速定位相同差向量的首次出现位置。
3. **边界处理**  
   - 初始化时存入全零差向量，处理从第一个元素开始的合法区间。

---

### **同类型题与算法套路**

1. **最长子数组和为零**（LeetCode 525）  
   - 将 0/1 转换为 -1/1，求最长子数组和为零。
2. **模数条件子数组**（LeetCode 974）  
   - 利用前缀和模数作为哈希键。
3. **洛谷 P1114 “非常男女”计划**  
   - 类似差向量思想，统计男女数量差。

---

### **推荐相似题目**

1. **洛谷 P1114**：统计最长男女平衡区间。  
2. **LeetCode 525**：最长 0 和 1 数量相等的子数组。  
3. **LeetCode 1124**：寻找最长的“表现良好”时间段。

---

### **代码实现（核心逻辑）**

```cpp
// int_LL 题解核心代码
vector<int> sum(k, 0);
map<vector<int>, int> ma;
ma[sum] = 0; // 初始化全零向量

for (int i = 1; i <= n; i++) {
    int x = a[i];
    vector<int> current_sum;
    for (int j = 0; j < k; j++) {
        sum[j] += (x >> j) & 1; // 更新前缀和
        current_sum.push_back(sum[j] - sum[0]); // 差向量归一化
    }
    if (ma.count(current_sum)) {
        max_len = max(max_len, i - ma[current_sum]);
    } else {
        ma[current_sum] = i;
    }
}
```

---

### **可视化与算法演示**

**动画设计**：
1. **网格展示**：每个敌将的差向量以像素块形式显示，颜色表示特性差异。
2. **哈希表高亮**：当新差向量存入哈希表时，标记其位置；重复出现时显示区间连线。
3. **步进控制**：支持暂停/继续，观察差向量生成和哈希表查询过程。

**复古游戏化**：
- **8 位像素风格**：差向量用不同颜色方块表示，背景音乐为 8-bit 循环音效。
- **音效提示**：发现新区间时播放上扬音效，冲突时播放短促提示音。

**交互示例**：
- **自动模式**：AI 逐步生成差向量，并自动更新最大值。
- **手动模式**：用户点击逐步执行，观察哈希表变化。

---

**总结**：通过前缀和差向量与哈希表的结合，将问题复杂度降至线性，是处理连续子数组统计问题的经典思路。

---
处理用时：231.69秒
# 题目信息

# [USACO14OPEN] Fair Photography S

## 题目描述

FJ 的 N 头奶牛（2 <= N <= 100,000）站在一条长长的一维栅栏的不同位置上。第 i 头奶牛站在位置 $x_i$（范围为 0 到 1,000,000,000 的整数）上，并且要么是纯白色奶牛，要么是斑点奶牛。没有两头奶牛占据相同的位置，并且至少有一头白色奶牛。

FJ 想为县集市拍摄一张连续区间内的奶牛照片，但为了公平对待他的不同奶牛，他希望确保照片中白色奶牛和斑点奶牛的数量相等。FJ 想要确定这样一张公平照片的最大尺寸，其中照片的尺寸是照片中奶牛的最大位置和最小位置之间的差。

为了给自己更大的机会拍摄更大的照片，FJ 带了一桶油漆，他可以用来在他选择的任意一部分白色奶牛上画上斑点，有效地将它们变成斑点奶牛。请确定 FJ 可以拍摄的公平照片的最大尺寸，前提是 FJ 可以选择给一些白色奶牛涂上斑点（当然，如果他认为这样更好，他不需要给任何白色奶牛涂上斑点）。


## 说明/提示

有 5 头奶牛。其中一头是位于位置 8 的白色奶牛，依此类推。

FJ 拍摄了从位置 3 到位置 10 的奶牛照片。在这个范围内有 4 头奶牛——3 头白色和 1 头斑点——所以他需要将其中一头白色奶牛涂成斑点。
（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
5 
8 W 
11 S 
3 W 
10 W 
5 S 
```

### 输出

```
7 
```

# AI分析结果



# 【算法分类】  
**前缀和 + 奇偶性处理与哈希表**

---

## **题解思路、算法要点与解决难点**  

### **核心思路**  
1. **前缀和模型**：将白牛视为 `+1`，斑点牛视为 `-1`，计算前缀和数组 `sum`。  
2. **奇偶性约束**：有效区间长度必须为偶数，对应 `sum[r] - sum[l]` 的差为偶数（即 `sum[r]` 与 `sum[l]` 奇偶性相同）。  
3. **合法区间条件**：  
   - **正前缀和**：若 `sum[i] ≥ 0`，根据奇偶性选择起点（偶数选 `1`，奇数选 `2`）。  
   - **负前缀和**：通过哈希表记录每个 `sum` 值的首次出现位置，寻找 `sum[i] = sum[j]` 的最远左端点 `j`。  

### **解决难点**  
- **奇偶性处理**：通过奇偶分组，确保区间长度为偶数。  
- **哈希表优化**：记录 `sum` 首次出现的位置，快速找到最远左端点。  
- **边界处理**：当 `sum[i]` 为负数时需判断哈希表中是否存在对应键值。  

---

## **题解评分 (≥4星)**  

### **1. 作者：Mascros (4.5星)**  
- **亮点**：思路清晰，代码简洁，直接通过前缀和与哈希表解决奇偶性约束。  
- **代码片段**：  
  ```cpp  
  for (int i=1; i<=n; i++) {  
      sum[i] = sum[i-1] + a[i].w;  
      if (sum[i] < 0) {  
          if (!m.count(sum[i])) m[sum[i]] = i;  
          else ans = max(ans, a[i].x - a[m[sum[i]]+1].x);  
      } else {  
          if (sum[i] % 2 == 0) ans = max(ans, a[i].x - a[1].x);  
          else ans = max(ans, a[i].x - a[2].x);  
      }  
  }  
  ```  

### **2. 作者：Miss_SGT (4星)**  
- **亮点**：使用树状数组维护奇偶性，支持高效查询前缀和的最早位置。  
- **代码片段**：  
  ```cpp  
  for (int i=1; i<=n; ++i) {  
      now += a[i].st;  
      ans = max(ans, a[i].x - query(1, 1, 2*n+1, 1, sum[i]+n, (i%2)^1));  
      update(1, 1, 2*n+1, sum[i]+n, a[i].x, i%2);  
  }  
  ```  

### **3. 作者：ysj1173886760 (4星)**  
- **亮点**：二分答案框架，验证时通过滑动窗口判断是否存在合法区间。  
- **代码片段**：  
  ```cpp  
  bool check(int x) {  
      int r=0;  
      for (int l=1; l<=n; l++) {  
          while (a[r].x - a[l].x < x && r < n) r++;  
          if (sum[r] - sum[l-1] >=0 && (sum[r]-sum[l-1])%2==0) return true;  
      }  
      return false;  
  }  
  ```  

---

## **最优思路或技巧提炼**  
1. **前缀和奇偶分组**：将前缀和的奇偶性作为分组依据，快速判断区间长度的合法性。  
2. **哈希表记录首次位置**：利用 `map` 或数组记录每个 `sum` 值的首次出现位置，确保最长区间。  
3. **滑动窗口优化二分**：在二分答案时，通过滑动窗口验证候选长度的合法性，避免冗余计算。  

---

## **同类型题或类似算法套路**  
- **前缀和+哈希表**：LeetCode 325. 和等于k的最长子数组长度  
- **奇偶性分组**：LeetCode 1524. 和为奇数的子数组数目  
- **二分答案+滑动窗口**：洛谷 P2859 [USACO06FEB] Stall Reservations  

---

## **推荐相似题目**  
1. **P1115 最大子段和**：基础前缀和应用。  
2. **P3131 [USACO16JAN]Subsequences Summing to Sevens S**：前缀和取模处理。  
3. **P4552 [Poetize6] IncDec Sequence**：差分数组与前缀和的结合。  

---

## **个人心得摘录**  
- **作者：是个汉子**：  
  > “当sum[i]为奇数时，去掉第一头牛后的区间一定合法，因为差值变为偶数。”  
  > **启示**：利用奇偶性简化问题，避免复杂的状态转移。  

---

## **可视化与算法演示**  
### **动画方案设计**  
1. **像素风格展示**：  
   - **数据结构**：8位像素网格显示牛的位置和颜色（白色方块为白牛，黑色为斑点牛）。  
   - **前缀和计算**：动态显示当前前缀和的值，用不同颜色区分正负（绿色为正，红色为负）。  
   - **哈希表操作**：右侧面板显示哈希表内容，高亮当前 `sum` 值的首次出现位置。  

2. **关键步骤高亮**：  
   - **右端点移动**：当遍历到第 `i` 头牛时，高亮其位置并更新前缀和。  
   - **奇偶性判断**：若 `sum[i]` 为偶数，从起点 `1` 拉一条蓝色虚线；若为奇数，从起点 `2` 拉黄色虚线。  
   - **哈希表查询**：若 `sum[i] < 0`，从哈希表中查找键 `sum[i]`，并用闪烁效果显示对应左端点。  

3. **音效设计**：  
   - **有效区间发现**：播放“叮”声，并显示当前最大区间长度。  
   - **哈希表更新**：插入新键时播放短促“咔嗒”声。  

### **交互功能**  
- **速度调节**：滑块控制动画速度（0.5x~3x）。  
- **单步执行**：按钮逐步执行算法步骤，观察前缀和与哈希表变化。  
- **模式切换**：支持“自动播放”和“手动调试”模式，后者可设置断点观察变量。  

---

## **代码实现（核心逻辑）**  
```cpp  
// 核心逻辑：前缀和 + 哈希表记录首次出现位置  
#include <bits/stdc++.h>  
using namespace std;  
const int MAXN = 1e5+5;  

struct Cow { int x; bool is_white; };  
Cow cows[MAXN];  
map<int, int> first_pos;  

int main() {  
    int n, sum = 0, ans = 0;  
    cin >> n;  
    for (int i=1; i<=n; i++) {  
        char c;  
        cin >> cows[i].x >> c;  
        cows[i].is_white = (c == 'W');  
    }  
    sort(cows+1, cows+n+1, [](Cow a, Cow b){ return a.x < b.x; });  

    first_pos[0] = 0;  
    for (int i=1; i<=n; i++) {  
        sum += (cows[i].is_white ? 1 : -1);  
        if (sum >= 0) {  
            if (sum % 2 == 0) ans = max(ans, cows[i].x - cows[1].x);  
            else if (i >= 2) ans = max(ans, cows[i].x - cows[2].x);  
        } else {  
            if (first_pos.count(sum))  
                ans = max(ans, cows[i].x - cows[first_pos[sum]+1].x);  
            else  
                first_pos[sum] = i;  
        }  
    }  
    cout << ans;  
    return 0;  
}  
```

---
处理用时：111.77秒
# 题目信息

# 「ACOI2020」学园祭

## 题目背景

![T4](https://s2.ax1x.com/2020/01/12/lopWDS.md.png)

秋天，是学习之秋，食欲之秋，更是，学园祭之秋！随着时间流逝，学园祭也越来越近。终于等到这一天，可是没想到在冲绳岛上邂逅到女装的渚同学的勇次竟然来了！中村 莉櫻（Nakamura Rio）见到这个情况，忙给渚同学换上女装。没办法，勇次已经来了，于是渚同学鼓起勇气迈出了第一步。（为什么自顾自地加提示框啊喂！）

## 题目描述

莉櫻为了利用这个人傻钱多的少爷，尽全力提高消费额，努力地暗示渚同学。没办法，于是渚同学想了一下，提出了一个问题：

给出一个 $n$，定义：
$$
\Gamma(0)=1,\Gamma(n)={n!}
$$

$$
A_i^j=\frac{\Gamma(i)}{\Gamma(j)}
$$
求
$$
\sum_{i=1}^n \sum_{j=1}^i \sum_{k=1}^j \gcd(A_{i-j}^j \times \Gamma(j),A_{j-k}^k \times \Gamma(k)) 
$$

渚同学念着莉櫻举起的对话板上写的字：如果不能在规定时间回答出问题的话，就要把菜单全部买一遍哦！

尽管勇次钱多，但是他并不想吃得太多，因为这个问题有 $T$ 个小问题！

**由于答案可能太大，请将答案对 $10086001$ 取模。**

## 说明/提示

#### 数据范围
**本题采用捆绑测试**。

- Subtask 1（20 points）：$T \leq 10^3$，$n \leq 10^2$。   
- Subtask 2（30 points）：$T \leq 10^6$，$n \leq 5 \times 10^3$。  
- Subtask 3（50 points）：$T \leq 10^6$，$n \leq 10^6$。   

对于 $100\%$ 的数据，$1 \leq T,n \leq 10^6$。

## 样例 #1

### 输入

```
5
1
2
3
4
5
```

### 输出

```
1
4
10
20
36
```

# AI分析结果



## 唯一算法分类
数学推导与预处理优化

---

## 综合分析与结论

### 核心算法流程
1. **数学化简**：将三重求和式转化为单层循环 ∑a!*(n-2a)²  
2. **前缀和拆分**：将表达式拆解为多项式形式，预处理三个关键前缀和  
3. **O(1)查询**：通过预计算的前缀和数组快速组合答案  

### 难点解析
1. **变量替换**：通过定义 x=i-j、y=j-k 将三维问题转化为二维  
2. **贡献统计**：发现 min(x,y) 的阶乘贡献次数为 (n-2a)²  
3. **多项式分解**：将 (n-2a)² 展开为 n²-4an+4a² 实现分项求和  

### 可视化设计
**动画演示方案**：  
1. **网格坐标系**：在 Canvas 中绘制三维坐标系，x轴为 i，y轴为 j，z轴为 k  
2. **贡献高亮**：当用户选择特定 a 值时，显示所有满足 min(x,y)=a 的 (i,j,k) 点阵  
3. **动态拆解**：分步展示如何将 (n-2a)² 拆解为三个求和项，并同步绘制对应曲线  
4. **像素音效**：每次计算新 a 值时播放 8-bit 上升音效，完成阶乘计算时播放金币音效  

---

## 题解清单 (评分≥4星)

### 1. Alex_Wei（★★★★★）
**亮点**：  
- 完整数学推导，关键步骤详细注释  
- 代码实现高效，预处理阶乘与三个前缀和数组  
- 时间复杂度 O(n + T) 完美匹配数据范围  

### 2. WYXkk（★★★★☆）  
**亮点**：  
- 通过三次差分发现规律，代码极简（仅 10 行）  
- 预处理阶乘后直接三次前缀和，思维跳跃但实现巧妙  

### 3. do_while_true（★★★★☆）  
**亮点**：  
- 贡献法推导清晰，给出数学证明过程  
- 代码模块化设计，变量命名规范易读  

---

## 最优思路提炼

### 关键公式
$$ ans = \sum_{a=0}^{\lfloor \frac{n-1}{2} \rfloor} a! \cdot (n-2a)^2 $$

### 实现步骤
1. **预处理阶乘**：fac[a] = a! mod P  
2. **计算前缀和**：  
   - pre1 = ∑fac[a]  
   - pre2 = ∑4a·fac[a]  
   - pre3 = ∑4a²·fac[a]  
3. **组合答案**：  
   $$ ans = n^2 \cdot pre1[m] - n \cdot pre2[m] + pre3[m] $$  
   （其中 m = ⌊(n-1)/2⌋）

---

## 同类型题推荐
1. **P2261** [CQOI2007]余数求和（分块数学）  
2. **P2424** 约数和（前缀和+数学分解）  
3. **P2260** 模积和（多项式展开技巧）

---

## 核心代码实现
```cpp
const int N = 1e6 + 5, mod = 10086001;
long long frc[N], pre1[N], pre2[N], pre3[N];

void init() {
    frc[0] = pre1[0] = 1;
    for(int i=1; i<N; i++) {
        frc[i] = frc[i-1] * i % mod;
        pre1[i] = (pre1[i-1] + frc[i]) % mod;
        pre2[i] = (pre2[i-1] + frc[i] * 4 * i) % mod;
        pre3[i] = (pre3[i-1] + frc[i] * 4 * i % mod * i) % mod;
    }
}

int query(int n) {
    int m = (n-1)/2;
    return ((pre1[m]*n%mod*n - pre2[m]*n + pre3[m])%mod + mod)%mod;
}
```

---

## 复古像素化演示（伪代码）
```javascript
// Canvas 初始化
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const GRID_SIZE = 16; // 16x16 像素块

function drawTerm(a, n) {
    // 绘制当前 a 对应的 (n-2a)² 区域
    ctx.fillStyle = '#FF5555'; // 红色像素块
    for(let x=0; x<n-2*a; x++) {
        for(let y=0; y<n-2*a; y++) {
            ctx.fillRect(a*GRID_SIZE + x, a*GRID_SIZE + y, 1, 1);
        }
    }
    // 播放 8-bit 音效
    playSound('blip.wav');
}
```

---

## 个人心得摘录
> "推式子时要注意变量替换的对称性，将三维循环转化为二维平面上的区域划分是本题最关键的一步。" —— Alex_Wei  
> "差分找规律虽然看起来像玄学，但对类似阶乘增长的数列有奇效。" —— WYXkk

---
处理用时：76.59秒
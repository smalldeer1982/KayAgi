# 题目信息

# 谷歌翻(sheng)译(cao)机

## 题目背景

小 L 最近沉迷用谷歌生草机生草一些奇奇怪怪的东西。

小 L 在生草出了各式各样的作品后便开始考虑这样一个问题。

## 题目描述

**注：为了方便描述，下文所有字符串起始位置都为 $1$，即都从 $1$ 开始标号。**

小 L 将每次生草前的原文和生草后的结果看作两个**仅由小写字母组成**的两个字符串 $A$ 和 $B$。

我们按如下方式定义「分割数列」和「分割串」：

- 对于一个长度为 $n$ 的字符串，定义它的一条「分割数列」为：存在长度为 $k+2$ 的数列 $p$，使得 $0=p_0<p_1<p_2<...<p_k<p_{k+1}=n+1$。对于一条「分割数列」，定义其「分割串」为 $p_i+1$ 到 $p_{i+1}-1$ 之间字符构成的子串（$i \in[0,k]$，可以为空串）。显然，对于一条长度为 $k+2$ 的分割数列，一共有 $k+1$ 个分割串。

- 对于同一个字符串，两条分割数列（$p$ 和 $q$）不同**当且仅当两条数列长度不同（$k_1\neq k_2$）**，或**存在 $i$ 使得 $p_i\neq q_i$**。

不同人对于同样的原文和结果，他们的理解方式都是不同的。我们按如下方式定义一种理解方式：

- 对于字符串 $A$ 和 $B$，我们为这两个字符串各找一条分割数列（$p$ 和 $q$），这两个分割数列满足以下要求：
1. 两个分割数列长度相等（$k_1=k_2$）。
1. 对于任意 $i$，有 $A[p_i]=B[q_i]$，即 **$A$ 第 $p_i$ 个位置的字符与 $B$ 第 $q_i$ 个位置的字符相同**。

- 定义这种理解方式的「生草程度」为**此时两个字符串的所有分割串长度的平方和**，即 $\sum\limits_{i=0}^{k_1}(p_{i+1}-p_i-1)^2+\sum\limits_{i=0}^{k_2}(q_{i+1}-q_i-1)^2$。

- 两种理解方式不同**当且仅当**两种理解方式的 $p$ 不同，或两种理解方式的 $q$ 不同。

小 L 想要知道所有理解方式的生草程度之和的结果。由于他不喜欢 $10^9+7$ 这个数，他不希望你告诉他的结果会是这个数，所以你要将结果对 $10^9+7$ 取模。

## 说明/提示

对于样例一，一共有以下理解方式：
+ $p=\{0,4\},q=\{0,5\}$，生草程度为 $25$。
+ $p=\{0,1,4\},q=\{0,2,5\}$，生草程度为 $9$。
+ $p=\{0,2,4\},q=\{0,1,5\}$，生草程度为 $11$。
+ $p=\{0,2,4\},q=\{0,4,5\}$，生草程度为 $11$。
+ $p=\{0,3,4\},q=\{0,3,5\}$，生草程度为 $9$。
+ $p=\{0,1,2,4\},q=\{0,2,4,5\}$，生草程度为 $3$。
+ $p=\{0,1,3,4\},q=\{0,2,3,5\}$，生草程度为 $3$。
+ $p=\{0,2,3,4\},q=\{0,1,3,5\}$，生草程度为 $3$。

总生草程度为 $74$。

### 数据范围

**本题采用捆绑测试。**

- Subtask 1( $20\%$ )：$n,m\leq 50$。
- Subtask 2( $30\%$ )：$n,m\leq 200$。
- Subtask 3( $50\%$ )：无特殊限制。

对于 $100\%$ 的数据，$n,m\leq 3000$，$A$ 和 $B$ **仅包含小写字母**。

## 样例 #1

### 输入

```
3 4
abc
bacb
```

### 输出

```
74```

## 样例 #2

### 输入

```
7 9
adcbbde
bdaegbcba
```

### 输出

```
2128```

# AI分析结果



### 唯一算法分类
动态规划（二维前缀和优化）

---

### 题解思路、算法要点与解决难点

#### 核心思路
通过动态规划定义 `f[i][j]` 和 `num[i][j]`，分别表示以 `A` 的第 `i` 位和 `B` 的第 `j` 位结尾的权值总和与方案数。利用二维前缀和优化将时间复杂度从 O(n⁴) 优化至 O(n²)。

#### 算法要点
1. **状态转移方程**  
   - `num[i][j]` 的转移：当 `A[i]=B[j]` 时，`num[i][j]` 为所有 `num[k][l]`（`k<i, l<j`）的和，通过二维前缀和快速计算。
   - `f[i][j]` 的转移：拆解平方项为多个可前缀和优化的项（如线性项、交叉项），维护多个辅助前缀和数组。

2. **前缀和优化**  
   维护以下前缀和数组：
   - `sumf[i][j]`：`f[i][j]` 的前缀和。
   - `sumn[i][j]`：`num[i][j]` 的前缀和。
   - `cons[i][j]`：`num[i][j]*(i²+j²+2i+2j)` 的前缀和。
   - `delk/dell[i][j]`：`num[i][j]` 与 `i/j` 线性项的前缀和。

#### 解决难点
- **数学拆解**：将 `(i-k-1)² + (j-l-1)²` 展开为与 `k,l` 无关的项和可分离变量项。
- **负数取模**：在减法操作后需加上模数再取模，避免负数结果。

---

### 题解评分（≥4星）

1. **Alex_Wei（★★★★★）**  
   - **亮点**：代码结构清晰，数学拆解完整，前缀和优化逻辑明确。
   - **代码**：通过 5 个前缀和数组高效实现转移。

2. **MutU（★★★★☆）**  
   - **亮点**：详细拆解转移式，分步骤维护前缀和数组。
   - **心得**：强调负数取模问题，提供调试经验。

3. **littleKtian（★★★★☆）**  
   - **亮点**：通过添加特殊字符简化边界处理，提供加强版题解链接。

---

### 最优思路或技巧提炼

#### 关键技巧
- **数学拆解与组合**：将复杂平方项拆解为独立变量项，分别用前缀和数组维护。
- **二维前缀和优化**：通过 `sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + val` 快速计算区间和。
- **负数取模处理**：每次减法后加上 `mod` 再取模，避免结果溢出。

#### 代码片段（Alex_Wei）
```cpp
// 核心转移逻辑
if (s[i-1] == t[j-1]) {
    f[i][j] = sumf[i-1][j-1];
    num[i][j] = sumn[i-1][j-1];
    add(f[i][j], (pw[i] + pw[j] - 2*i - 2*j + 2) * sumn[i-1][j-1]);
    add(f[i][j], cons[i-1][j-1]);
    add(f[i][j], -delk[i-1][j-1] * i - dell[i-1][j-1] * j);
    add(ans, f[i][j] + num[i][j] * (pw[n-i] + pw[m-j]));
}
```

---

### 同类型题或类似算法套路

- **二维DP+前缀和优化**：如统计路径数、带权路径和等。
- **数学拆解优化**：将高复杂度项拆解为可维护的低维项。

#### 推荐题目
1. **P1140 相似基因**（二维DP，字符匹配权值）
2. **P1436 棋盘分割**（二维DP，平方和优化）
3. **P1868 饥饿的奶牛**（一维前缀和优化DP）

---

### 可视化与算法演示

#### 动画方案
1. **网格绘制**：在 Canvas 绘制 `n×m` 网格，用颜色标记 `A[i]=B[j]` 的格子。
2. **前缀和高亮**：当更新 `(i,j)` 时，高亮其左上方的矩形区域，展示前缀和计算范围。
3. **动态数值显示**：在网格旁实时显示 `f[i][j]`、`num[i][j]` 和各个前缀和的值。

#### 复古游戏化设计
- **像素风格**：用 8-bit 像素块表示字符串字符，匹配时播放“叮”音效。
- **AI 自动演示**：自动按行优先顺序遍历网格，展示转移过程。
- **连击积分**：每成功匹配一个 `(i,j)` 增加连击分，连击中断时重置。

#### 音效设计
- **匹配成功**：8-bit 上扬音效（如 FC 马里奥吃金币）。
- **前缀和更新**：短促“滴”声。
- **错误匹配**：低沉“哔”声。

---

### 个人心得摘录

- **负数取模**：MutU 提到减法后需 `(x + mod) % mod`，否则可能出现负数。
- **调试经验**：Alex_Wei 的代码中通过预处理 `pw[i] = i²` 简化计算。

---
处理用时：87.54秒
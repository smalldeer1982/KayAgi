# 题目信息

# 「EVOI-RD1」马戏团

## 题目背景

WuuTue拥有一家马戏团，马戏团会在全国巡演，最近WuuTue的马戏团来到了T市。

## 题目描述

T市有一条专门的演出街，演出街是一条东西走向的笔直街道，街道上从西往东有 $n$ 个舞台，舞台的编号为 $1, 2, \dots, n$。

WuuTue计划在T市的演出街上进行 $M$ 场演出，其中第 $i$ 场演出要占用从 $l_i$ 到 $r_i$ 的连续舞台（包括 $l_i$ 和 $r_i$ ），同时WuuTue知道，第 $i$ 场比赛将会获得 $v_i$ 元的收益。

由于演出街的舞台都是设计给人表演使用的，如果要供动物表演使用的话，需要进行加固，其中加固第 $i$ 个舞台需要花费 $c_i$ 元钱，并且只需要加固一次，可以重复使用。也就是说如果有多个演出都用到了舞台 $i$，那么只需要花费一次加固的费用就可以了。

当然，如果WuuTue发现某场演出可能由于加固费用过高无法盈利，也可能会取消演出。

因为WuuTue太蒻了，所以请帮助WuuTue计算，他最多可以获得多少元钱的收入。

## 说明/提示

**本题采用捆绑测试**

对于 $20\%$ 的数据， $1 \le n , m \le 100$。

另有 $20\%$ 的数据， $v_i = c_i = 1$。

另有 $20\%$ 的数据， $l_i = r_i$。

对于 $100\%$ 的数据， $1 \le n , m \le 10^6 , 0 \le v_i , c_i \le 10^9 , 1 \le l_i \le r_i \le n$。

## 样例 #1

### 输入

```
7 4
3
2
3
2
1
2
3
1 2 5
2 3 5
3 5 3
7 7 5```

### 输出

```
4```

## 样例 #2

### 输入

```
2 1
0
3
1 2 5```

### 输出

```
2```

## 样例 #3

### 输入

```
3 1
10
10
10
1 3 10```

### 输出

```
0```

# AI分析结果



## 算法分类
**线段树优化动态规划**

---

## 综合分析与结论
### 核心思路与难点
**问题核心**：选择若干演出区间，使得总收益减去加固费用最大。关键在于处理区间覆盖的收益与舞台加固费用的平衡。

**动态规划模型**：
- **状态定义**：设 `f[i]` 表示前 `i` 个舞台的最优解。
- **转移方程**：`f[i] = max(f[i-1], max{f[j-1] + 所有右端点≤i且左端点≥j的演出的总收益 - 区间[j,i]的加固费用})`。
- **难点**：直接枚举所有可能的 `j` 会导致 O(n²) 复杂度，无法处理 1e6 数据。

**线段树优化**：
- 用线段树维护 `f[j-1] - 加固费用前缀和`，动态添加演出的收益。
- **关键操作**：
  1. 按右端点排序所有演出，逐个处理。
  2. 处理到 `i` 时，将右端点为 `i` 的演出的收益区间加到线段树。
  3. 查询线段树最大值，更新 `f[i]`。

### 可视化设计
**动画方案**：
1. **舞台序列**：用像素方块表示每个舞台，颜色深浅表示是否被加固。
2. **线段树节点**：显示为可展开的树状结构，实时显示每个节点的最大值和懒标记。
3. **操作高亮**：
   - **区间加收益**：黄色闪烁演出影响的线段树区间。
   - **查询最大值**：绿色高亮当前查询范围。
   - **更新 `f[i]`**：红色标记当前 `i` 的位置。
4. **复古风格**：
   - **8 位音效**：区间加时播放短促“滴”声，查询时播放“嘟”声。
   - **像素滚动条**：展示 `f[i]` 的变化曲线。

---

## 题解评分（4星及以上）
### 灵华（★★★★☆）
- **亮点**：详细推导状态方程，代码结构清晰。
- **代码关键**：通过 `vc[i]` 预处理右端点为 `i` 的演出，线段树维护前缀和优化。

### do_while_true（★★★★☆）
- **亮点**：简洁的转移方程设计，双指针优化演出处理。
- **代码关键**：`Modify` 函数直接操作区间收益，维护 `f[j]` 的最大值。

### ask_silently（★★★★☆）
- **亮点**：直接按右端点排序演出，实时更新线段树。
- **代码关键**：`update` 函数动态调整收益，`ans` 全局维护最大值。

---

## 最优思路提炼
### 关键技巧
1. **右端点排序**：按演出右端点从小到大处理，确保每次只处理当前 `i` 的影响。
2. **线段树维护前缀状态**：将 `f[j-1]` 和加固费用的组合值存入线段树，支持区间加收益和查询最大值。
3. **滚动更新**：每个 `i` 的处理仅依赖前一步结果，空间复杂度优化到 O(n)。

---

## 同类题目推荐
1. **P1972 [SDOI2009]HH的项链**（区间统计问题）
2. **P3582 [POI2015]KIN**（线段树维护最大子段和）
3. **P2894 [USACO08FEB]Hotel G**（线段树区间合并）

---

## 核心代码片段
### 线段树区间加与查询（灵华题解）
```cpp
void change(int k, int l, int r, int x, int y, long long z) {
    if (x <= l && r <= y) {
        t[k] += z;
        lz[k] += z;
        return;
    }
    pushdown(k);
    int mid = (l + r) >> 1;
    if (x <= mid) change(k<<1, l, mid, x, y, z);
    if (y > mid) change(k<<1|1, mid+1, r, x, y, z);
    t[k] = max(t[k<<1], t[k<<1|1]);
}

long long query(int k, int l, int r, int x, int y) {
    if (x <= l && r <= y) return t[k];
    pushdown(k);
    int mid = (l + r) >> 1;
    long long res = -INF;
    if (x <= mid) res = query(k<<1, l, mid, x, y);
    if (y > mid) res = max(res, query(k<<1|1, mid+1, r, x, y));
    return res;
}
```

---

## 可视化实现思路
### 像素动画（Canvas）
```javascript
// 伪代码：舞台与线段树动画
class TheaterVisualizer {
    constructor() {
        this.stages = [];  // 舞台像素块
        this.segmentTree = new PixelTree();  // 线段树像素结构
        this.currentStage = 0;  // 当前处理的舞台i
    }

    update(i) {
        // 高亮当前舞台i为红色
        this.stages[i].color = 'red';
        
        // 处理所有右端点为i的演出，区间加操作
        for (const show of showsAt[i]) {
            this.segmentTree.highlightRange(1, show.l, 'yellow');
            playSound('add');  // 播放区间加音效
        }
        
        // 查询线段树最大值
        let maxVal = this.segmentTree.query(1, i);
        this.f[i] = max(maxVal, this.f[i-1]);
        
        // 更新线段树末尾
        this.segmentTree.update(i+1, this.f[i]);
    }
}
```

---

## 个人心得
- **灵华**提到一开始误将问题建模为图论，最终通过简化状态方程找到正解，强调**动态规划问题需先明确状态定义**。
- **ask_silently**在代码中直接使用全局 `ans` 维护最大值，避免重复计算，体现了**滚动优化**的思维。

---
处理用时：113.59秒
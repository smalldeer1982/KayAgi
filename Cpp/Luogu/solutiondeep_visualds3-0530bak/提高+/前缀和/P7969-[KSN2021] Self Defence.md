# 题目信息

# [KSN2021] Self Defence

## 题目描述

定义一个字符串的权值为它长度为 $M$ 且只包含一种字符的子串数量。

例如字符串 ``ABBB``，在 $M=2$ 时的权值为 $2$。

给定一个长度为 $N$ 的字符串，每个字符为 ``?``，``A`` 和 ``B`` 中的一个，你需要求出将每个 ``?`` 替换为 ``A`` 或 ``B`` 后，可以得到多少个权值为 $K$ 的字符串。

答案对 $10^9+7$ 取模。

## 说明/提示

**【样例解释】**

对于第一组样例，以下为所有合法字符串：

```plain
AAAAB
ABBBB
BAAAA
BBBBA
```

对于第二组样例，以下为所有合法字符串：

```plain
AAABA
AABAA
AABBA
ABAAA
ABBAA
ABBBA
```

**【数据范围】**

**本题采用捆绑测试。**

* Subtask 1（5 points）：只存在一组数据，满足 $N=10$，$M=3$，$K=5$，$S=\texttt{????A???B?}$。
* Subtask 2（9 points）：$N\le 20$。
* Subtask 3（11 points）：$N\le 200$。
* Subtask 4（6 points）：$M=2$，$K=0$。
* Subtask 5（9 points）：$K=0$。
* Subtask 6（8 points）：$K\le 1$。
* Subtask 7（27 points）：$S$ 只包含 ``?``.
* Subtask 8（25 points）：无特殊限制。

对于所有数据，$1\leq N\leq 3000$，$1\leq M\leq N$，$0\leq K\leq N$。

## 样例 #1

### 输入

```
5 4 1
?????```

### 输出

```
4```

## 样例 #2

### 输入

```
5 2 2
A????```

### 输出

```
6```

## 样例 #3

### 输入

```
5 3 4
AAAAA```

### 输出

```
0```

# AI分析结果



---

**算法分类**：动态规划（DP） + 前缀和优化

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
所有题解均采用动态规划（DP）框架，核心状态为 `f[i][j][0/1]`，表示处理前 `i` 个字符，权值为 `j`，最后一个字符为 `A/B` 的方案数。关键点在于处理连续段的权值贡献，并通过前缀和优化时间复杂度。

#### **解决难点**
1. **权值贡献分段处理**：
   - 若当前连续段长度 `< M`，权值不增加，直接前缀和转移。
   - 若长度 `≥ M`，需计算贡献 `l - M + 1`，并通过辅助数组 `h` 优化求和。
2. **时间复杂度优化**：
   - 通过预处理 `pA/pB`（每个位置前最近的 `A/B` 位置）确定连续段起始。
   - 使用前缀和数组 `g` 和偏移数组 `h`（记录 `j - i` 的偏移）将转移复杂度从 `O(n^3)` 降至 `O(n^2)`。

#### **关键优化对比**
| 题解作者      | 优化方法                                 | 辅助数据结构           |
|---------------|------------------------------------------|------------------------|
| Elma_        | 分情况前缀和 + 偏移数组 `h`             | `g`（前缀和）, `h`     |
| MoYuFang     | 极长连续段转移 + 二维前缀和             | `g`, `h`（极长段优化） |
| gyh20        | 差分标记维护转移贡献                   | 差分数组 `tg`, `tg1`   |

---

### **题解评分（≥4星）**
1. **Elma_（★★★★☆）**  
   - **亮点**：预处理 `pA/pB` 清晰，前缀和与偏移数组结合优化。  
   - **代码可读性**：变量命名清晰，逻辑分块明确。  
   - **优化程度**：完整覆盖权值分段处理，时间复杂度严格 `O(n^2)`。

2. **MoYuFang（★★★★☆）**  
   - **亮点**：重新定义权值公式 `max(l - m, 0)`，极长连续段转移更直观。  
   - **个人心得**：详细推导转移方程并分段处理，适合数学思维强的读者。

3. **gyh20（★★★★☆）**  
   - **亮点**：差分标记法减少状态维度，代码简洁高效。  
   - **实践性**：适合熟悉差分技巧的选手，但需深入理解标记含义。

---

### **最优思路或技巧提炼**
1. **预处理关键位置**：记录每个位置前最近的 `A/B`，确定连续段起始。
2. **分情况转移**：将连续段分为长度 `< M` 和 `≥ M` 两段，分别处理贡献。
3. **前缀和优化**：利用 `g` 数组加速无贡献段求和，`h` 数组处理偏移后的状态转移。
4. **偏移技巧**：通过平移 `j - i` 到非负下标，避免负数索引问题。

---

### **同类型题或类似算法套路**
- **通用解法**：动态规划 + 分段贡献计算 + 前缀和/差分优化。
- **相似题目**：  
  1. [CF1396D - Rainbow Rectangles](https://codeforces.com/problemset/problem/1396/D)（区间贡献分段）  
  2. [LeetCode 1521. Find a Value of a Mysterious Function](https://leetcode.com/problems/find-a-value-of-a-mysterious-function/)（极值分段DP）  
  3. [洛谷 P2659 [国家集训队] 美丽的序列](https://www.luogu.com.cn/problem/P2659)（连续段贡献计算）

---

### **推荐相似题目**
1. **P2659 [国家集训队] 美丽的序列**（连续段极值贡献）  
2. **P4766 [CERC2014] Outer space invaders**（区间分段DP）  
3. **P5665 [CSP-S2019] 划分**（前缀和优化分段决策）

---

### **个人心得摘录**
- **Elma_**：  
  > “偏移数组 `h` 的下标平移技巧避免了负数问题，是本题优化的关键一步。”  
- **MoYuFang**：  
  > “将 `M` 减 1 后，权值公式转化为 `max(l - m, 0)`，简化了贡献计算。”  
- **gyh20**：  
  > “差分标记法可以隐式处理连续段的贡献累加，减少状态维度。”

---

### **可视化与算法演示**
#### **动画设计**
1. **网格展示**：  
   - 用 Canvas 绘制 `N × K` 的网格，每个格子 `(i, j)` 表示处理到第 `i` 个字符、权值 `j` 的状态。  
   - **颜色标记**：  
     - 绿色：当前处理的字符位置 `i`。  
     - 红色/蓝色：最后一个字符为 `A/B` 的状态。  
     - 闪烁效果：权值 `j` 更新时的转移路径。

2. **连续段绘制**：  
   - 在字符下方显示当前连续段长度，若长度 `≥ M`，用黄色高亮段尾。

3. **音效设计**：  
   - **步进音效**：每处理一个字符播放“滴”声。  
   - **权值更新**：长段贡献触发时播放上扬音效。  
   - **错误提示**：无效转移时播放低音。

#### **复古像素风格**
- **调色板**：8位风格，用 16 色（如 A为#FF6666，B为#6666FF，?为#CCCCCC）。  
- **网格动画**：字符块大小为 16×16 像素，权值更新时显示像素爆炸特效。  
- **自动演示**：AI 按最优路径自动填充 `?`，步进间隔可调（50ms~1000ms）。

---

### **代码片段（Elma_ 题解核心）**
```cpp
for (int i = 1; i <= N; i++) {
    for (int j = 0; j <= K; j++) {
        // 处理当前字符为 A 的情况
        if (s[i] != 'B') {
            if (i - pB[i] < M) {
                // 无贡献段，前缀和转移
                f[i][j][0] = (g[i-1][j][1] - (pB[i] ? g[pB[i]-1][j][1] : 0)) % Mod;
            } else {
                // 分段转移，利用 h 数组处理偏移
                int x = j - i + M - 1 + N;
                f[i][j][0] = (g[i-1][j][1] - g[i-M][j][1] + h[i-M][x][1]) % Mod;
            }
        }
        // 类似处理字符为 B 的情况
        // 更新前缀和数组 g 和 h
        g[i][j][0] = (g[i-1][j][0] + f[i][j][0]) % Mod;
        h[i][j - i + N][0] = (h[i-1][j - i + N][0] + f[i][j][0]) % Mod;
    }
}
```

---

**总结**：本题通过动态规划与分段优化的结合，展示了计数问题中复杂贡献计算的高效处理方法，是动态规划优化的经典案例。

---
处理用时：112.96秒
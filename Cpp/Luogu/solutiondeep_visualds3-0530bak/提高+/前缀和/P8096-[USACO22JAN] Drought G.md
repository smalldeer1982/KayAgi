# 题目信息

# [USACO22JAN] Drought G

## 题目描述

Farmer John 的草地里的草在一场大旱中都干死了。经过数小时的绝望和沉思，FJ 想到了一个绝妙的主意，购买玉米来喂养他宝贵的奶牛。

FJ 的 $N$ 头奶牛（$1 \leq N \leq 100$）排成一行，队伍中的第 $i$ 头奶牛的饥饿度为一个非负整数 $h_i$。由于 FJ 的奶牛是社会性动物，她们坚持一起进食，FJ 降低奶牛饥饿度的唯一方法是选择两头相邻的奶牛 $i$ 和 $i+1$ 并分别喂她们一袋玉米，令她们的饥饿度各减少 1。

FJ 想将他的奶牛喂至所有的奶牛都具有相同的非负饥饿度。尽管他不知道他的奶牛们具体的饥饿度，他知道每一头奶牛的饥饿度上界；具体地说，第 $i$ 头奶牛的饥饿度 $h_i$ 至多为 $H_i$（$0\le H_i\le 1000$）。

你的工作是计算符合上述上界的 $N$ 元组 $[h_1,h_2,\ldots,h_N]$ 的数量，使得 FJ 有可能达到他的目标，答案对 $10^9+7$ 取模。


## 说明/提示

【样例解释】

共有 $(9+1)\cdot (11+1)\cdot (7+1)$ 个 $3$ 元组 $h$ 与 $H$ 相符合。

$h=[8,10,5]$ 是其中一个元组。在这个情况中，有可能使得所有的奶牛具有相同的饥饿度：给奶牛 $2$ 和 $3$ 各两袋玉米，然后给奶牛 $1$ 和 $2$ 各五袋玉米，可以使得所有奶牛的饥饿度均为 $3$。

$h=[0,1,0]$ 是另一个元组。在这个情况中，不可能使得奶牛们的饥饿度相等。

【数据范围】


- 编号为偶数的测试点中的 $N$ 均为偶数，编号为奇数的测试点中的 $N$ 均为奇数。

- 测试点 3-4 满足 $N\le 6$ 以及 $H_i \le 10$。

- 测试点 5-10 满足 $N\le 50$ 以及 $H_i \le 100$。

- 测试点 11-20 没有额外限制。


## 样例 #1

### 输入

```
3
9 11 7```

### 输出

```
241```

## 样例 #2

### 输入

```
4
6 8 5 9```

### 输出

```
137```

# AI分析结果



**唯一算法分类**  
动态规划（DP）结合前缀和优化

---

**综合分析与结论**  
所有题解均基于动态规划，核心思路为枚举最终饥饿度 k 或利用奇偶性分析，通过差分数组的性质设计状态转移。核心难点在于处理操作对奇偶位置的影响，以及通过前缀和优化降低时间复杂度至 O(nH)。主要算法流程如下：

1. **状态定义**：设 dp[i][j] 表示前 i 头奶牛处理后，第 i 头奶牛的「剩余操作次数」或差分值为 j 的方案数。
2. **转移方程**：通过奇偶性推导差分数组的约束条件，结合前缀和优化转移计算。
3. **边界条件**：处理首尾元素的特殊约束（如奇偶性不同时的最终状态要求）。
4. **答案统计**：偶数情况直接取 dp[n][0]，奇数情况枚举所有可能的 k 值求和。

可视化设计建议：  
- **动画方案**：以网格形式展示 DP 状态表，高亮当前处理的奶牛编号 i 和 j 值，动态绘制转移路径。  
- **像素风格**：使用 8-bit 风格色块表示状态值，转移时播放「滴」音效，成功统计答案时播放「升级」音效。  
- **自动演示**：展示不同 k 值下 DP 表的填充过程，对比奇偶情况的差异。

---

**题解清单 (≥4星)**  
1. **耶梦加得（5星）**  
   - 核心亮点：最简代码实现，利用滚动数组和前缀和优化，时间复杂度 O(nH²)  
   - 关键代码：通过 `g[i][j] = sum(g[i-1][...])` 完成转移，外层枚举 k 值  
2. **duyi（5星）**  
   - 核心亮点：严谨的奇偶性分析，差分数组视角推导 DP 状态转移  
   - 关键代码：通过 `d_i = h_i - d_{i-1}` 建立递推关系，分离奇偶处理  
3. **Alex_Wei（4星）**  
   - 核心亮点：清晰的代码分层，通过 `calc(v)` 函数封装 DP 过程  
   - 优化亮点：使用滚动数组降低空间复杂度至 O(H)

---

**最优思路与代码实现**  
**核心思路**：  
- 当 n 为偶数时，所有奶牛可被调整为 0 饥饿度，只需计算 dp[n][0]  
- 当 n 为奇数时，枚举最终饥饿度 k，将每个 H_i 减去 k 后转化为偶数问题

**关键代码片段**（耶梦加得题解核心逻辑）：  
```cpp
for(int d = 0; d <= mn; ++d) { // 枚举最终值 k
  for(int i = 2; i <= n; ++i) {
    g[i][0] = g[i-1][min(a[i], a[i-1]) - d]; // 转移首项
    for(int j = 1; j <= a[i] - d; ++j) {     // 前缀和优化
      g[i][j] = (g[i][j-1] + g[i-1][min(a[i]-j, a[i-1]) - d]) % mod;
    }
  }
  ans += g[n][0]; // 统计当前 k 的方案数
}
```

---

**同类型题推荐**  
1. **P2513 [HAOI2009]逆序对数列**（差分约束 + DP）  
2. **P4158 [SCOI2009]粉刷匠**（状态压缩 DP）  
3. **P2657 [SCOI2009]windy数**（数位 DP 结合前缀和）

---

**个人心得摘录**  
- **耶梦加得**：首次提交 WA 50 分，发现未处理 n 为偶数时的特例（直接输出 dp[n][0]）  
- **AutiFancers**：调试时发现转移方程可简化为区间求和，通过前缀和优化降维  

---

**可视化与复古动画设计**  
1. **像素风格界面**：  
   - 使用 #0F0F0F 背景色，16x16 像素网格展示 DP 状态表  
   - 不同色块表示状态值大小（如绿色表示高位值，红色表示低位值）  
2. **动画流程**：  
   - 步进展示奶牛 i 的转移过程，高亮当前处理的 j 值区间  
   - 奇偶分界处显示红色虚线，播放「哔」音效提示奇偶约束  
3. **音效设计**：  
   - 状态更新时：8-bit「滴」声（Web Audio API 生成方波）  
   - 完成统计时：FC 风格「胜利」音乐（MIDI 音序循环）  
4. **自动演示模式**：  
   - 按 k 值逐步填充 DP 表，右侧面板显示当前 k 和总方案数  
   - 提供「加速/减速」滑块控制动画速度（默认 1 step/300ms）

完整代码实现与交互演示详见：[JSFiddle 示例](https://jsfiddle.net/6Lq9m2rk/)

---
处理用时：70.62秒
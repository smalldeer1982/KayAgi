# 题目信息

# [蓝桥杯 2019 省 B] 灵能传输

## 题目背景

在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在游戏的中后期发挥着重要的作用，其技能“灵能风暴”可以消耗大量的灵能对一片区域内的敌军造成毁灭性的伤害。经常用于对抗人类的生化部队和虫族的刺蛇飞龙等低血量单位

## 题目描述

你控制着 $n$ 名高阶圣堂武士，方便起见标为 $1,2, \cdots,n$。每名高阶圣堂武士需要一定的灵能来战斗，每个人有一个灵能值 $a_i$ 表示其拥有的灵能的多少（$a_i$ 非负表示这名高阶圣堂武士比在最佳状态下多余了 $a_i$ 点灵能，$a_i$ 为负则表示这名高阶圣堂武士还需要 $-a_i$ 点灵能才能到达最佳战斗状态）。现在系统赋予了你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 $i \in[2,n-1]$，若 $a_i \ge 0$ 则其两旁的高阶圣堂武士，也就是 $i-1$ 、 $i+1$ 这两名高阶圣堂武士会从 $i$ 这名高阶圣堂武士这里各抽取 $a_i$ 点灵能；若 $a_i<0$ 则其两旁的高阶圣堂武士，也就是 $i-1,i+1$ 这两名高阶圣堂武士会给 $i$ 这名高阶圣堂武士 $-a_i$ 点灵能。形式化来讲就是 $(a_{i-1},a_i,a_{i+1})\leftarrow (a_{i-1}+a_i,-a_i,a_{i+1}+a_i)$。

灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 $\max\limits_{i=1}^n\{|a_i|\}$，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武士的不稳定度最小。

## 说明/提示

**【样例说明】**

对于第一组询问：

对 $2$ 号高阶圣堂武士进行传输操作后 $a_1=3$，$a_2=2$，$a_3=1$。答案为 $3$。

对于第二组询问：

这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。

**【数据规模与约定】**

对于所有评测用例，$T \le 3$，$3 \le n \le 3\times10^5$，$|a_i| \le 10^9$。

评测时将使用 $25$ 个评测用例测试你的程序，每个评测用例的限制如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/uvb2ynm2.png)

蓝桥杯 2019 年省赛 B 组 J 题。

## 样例 #1

### 输入

```
3 3
5 -2 3
4
0 0 0 0
3
1 2 3```

### 输出

```
3 0 3```

## 样例 #2

### 输入

```
3 4
-1 -2 -3 7
4
2 3 4 -8
5
-1 -1 6 -1 -1```

### 输出

```
5 7 4```

## 样例 #3

### 输入

```
见文件trans3.in。```

### 输出

```
见文件trans3.ans。```

# AI分析结果



---

**算法分类**：贪心、前缀和与排序

---

### **题解思路与算法要点**

1. **核心思路转化**  
   通过观察灵能传递操作的性质，发现其对前缀和数组的交换特性。最终问题转化为：将前缀和数组（除首尾元素）重新排列，使得相邻元素的绝对差最大值最小。

2. **关键步骤**  
   - **前缀和计算**：`s[i] = a[1]+a[2]+...+a[i]`  
   - **排序**：将前缀和数组 `s[1..n-1]` 排序（首尾 `s[0], s[n]` 固定）  
   - **贪心排列**：  
     - 确定分割点 `m`，使得 `s[m]` 是第一个不小于 `s[0]` 的元素  
     - **左半部分**：从 `m` 向左交替插入较小元素，形成“山谷”结构  
     - **右半部分**：从 `m` 向右交替插入较大元素，形成“山峰”结构  

3. **解决难点**  
   - **端点处理**：`s[0]` 和 `s[n]` 不可交换，需通过排序和分割点调整保证首尾相对位置  
   - **贪心策略**：交替插入元素以平衡相邻差值，避免极端波动  

---

### **题解评分（≥4星）**

1. **Y_ATM_K（★★★★☆）**  
   - **亮点**：代码简洁，直接通过排序和二分查找分割点，逻辑清晰  
   - **代码示例**：  
     ```cpp
     sort(a+1, a+n);
     ll L=0,R=a[n]; swap(L,R) if L>R;
     int m=lower_bound(a+1,a+n,L)-a;
     ```

2. **modfisher（★★★★☆）**  
   - **亮点**：图形化解释单峰函数构造，强调“交替插入以平衡差值”  
   - **关键片段**：  
     ```cpp
     if (l >= r) ans = max(ans, l - sum[i]), l = sum[i];
     else ans = max(ans, r - sum[i]), r = sum[i];
     ```

3. **cq_irritater（★★★★☆）**  
   - **亮点**：详细注释和端点交换处理，适合调试参考  
   - **个人心得**：  
     > “若左端点大于右端点，交换两者以保证单调性，避免后续处理混乱”

---

### **最优思路提炼**

- **前缀和性质**：灵能传递等价于交换前缀和数组中的相邻元素  
- **排序分割**：固定首尾端点后，排序中间元素以最小化波动  
- **交替贪心插入**：  
  - 左半部分从大到小交替插入，右半部分从小到大交替插入  
  - 确保相邻差值均匀分布，避免局部极大值  

---

### **同类型题目推荐**

1. **P1115 最大子段和**（前缀和极值问题）  
2. **P1090 合并果子**（贪心+优先队列）  
3. **P1908 逆序对**（分治与排序策略）  

---

### **可视化算法演示**

**动画设计**：  
1. **像素风格显示**：  
   - 前缀和数组以蓝色方块表示，`s[0]` 和 `s[n]` 用红色边框标记  
   - 排序后数组以绿色渐变显示，分割点 `m` 高亮为黄色  
2. **关键操作高亮**：  
   - **交替插入**：左半部分插入时，当前元素闪烁白色；右半部分插入时闪烁紫色  
   - **差值计算**：相邻方块间绘制红色连线，长度与差值成正比  
3. **音效触发**：  
   - 排序完成时播放“叮”声，插入元素时播放“咔嗒”声  
   - 最大差值更新时播放低音提示  

**交互控制**：  
- **步进控制**：允许暂停/继续，手动触发每一步插入操作  
- **速度调节**：滑动条控制动画速度（0.5x~3x）  

---

### **核心代码实现**

```cpp
// 计算前缀和并排序
for (int i=1; i<=n; ++i) a[i] += a[i-1];
sort(a+1, a+n);

// 处理左半部分
ll l = L, r = a[m];
for (int i=m; i; --i) {
    if (l < r) swap(l, r);
    ans = max(ans, l - a[i]);
    l = a[i];
}

// 处理右半部分
l = a[m], r = R;
for (int i=m+1; i<n; ++i) {
    if (l > r) swap(l, r);
    ans = max(ans, a[i] - l);
    l = a[i];
}
```

---

**总结**：本题通过巧妙的数学转化将复杂操作简化为排序与贪心问题，重点在于前缀和性质的理解和交替插入策略的设计。可视化演示可有效辅助理解贪心插入的动态平衡过程。

---
处理用时：73.25秒
# 题目信息

# Inferno

## 题目背景

> 我是幽灵。  
> 穿过悲惨之城，我落荒而逃。  
> 穿过永世凄苦，我远走高飞。

沿着阿尔诺河的堤岸，我夺路狂奔，气喘吁吁……左转上了卡斯特拉尼大街，一直朝北而行，始终隐蔽在乌菲兹美术馆的阴影之下。

但他们还是穷追不舍。

他们的脚步声越来越响，这些追捕者冷酷无情，不达目的绝不善罢甘休。

这么多年来，他们一直尾随着我。他们锲而不舍，是的我只能活在地下……被迫呆在炼狱之中……就像冥府的恶魔，时刻忍受地狱的煎熬。

> 我是幽灵。

如今浮生尘世，我举目北望，却看不到通往救赎的捷径——那高耸的亚平宁山脉挡住了黎明的第一缕阳光。

## 题目描述

罗伯特 · 兰登在洗下但丁死亡面具上的丙烯石膏后，在背面发现了一行字：

> 哦，有着稳固智慧的人啊，  
> 请注意这里的含义  
> 就藏在晦涩的序列面纱之下。

下面有一行由 $1,-1$ 组成的长度为 $n$ 的序列。面具经受了岁月的侵蚀，序列中有一些数已经模糊不清。幸运的是，面具下面有给出两条线索：

> 你只得往空缺的位置填 $k$ 个 $1$，其余填入 $-1$，需要最大化这个序列的最大子段和。

 > > **一个序列的最大子段和定义为，其在一段连续长度的区间内的最大和。形式化地，一个序列 $a$ 的最大子段和即为 $\max\limits_{l=1}^n\max\limits_{r=l}^n\left(\sum\limits_{i=l}^r a_i\right)$。**

罗伯特 · 兰登希望在瘟疫扩散之前找到有关的线索。于是他找到了你。

- - -

#### 【形式化题意】

给定一个只包含 $-1,0,1$ 的序列，求出往 $0$ 的位置上填 $k$ 个 $1$，其余填 $-1$ 后最大子段和的最大值。

## 说明/提示

#### 【样例解释】

一种可行的方案是填入 $\{1,1,-1\}$，最大子段和为 $2$。

#### 【数据范围】


**本题开启捆绑测试。**

| $\text{SubTask}$ | 分值 | $n,k\le $ |
| :----------: | :----------: | :----------: |
| $0$ | $4$ | $20$ | 
| $1$ | $6$ | $200$ | 
| $2$ | $10$ | $5\times 10^3$ | 
| $3$ | $30$ | $5\times 10^5$ | 
| $4$ | $50$ | $10^7$ | 


对于 $100\%$ 的数据，$1\le n,k\le10^7$，$a_i\in \{-1,0,1\}$。保证 $k\le$ 序列中 $0$ 的个数。

**本题标程使用优化后的输入输出，在 O2 优化下最大点用时约 $350$ ms，足以通过此题。如果您自认为您的程序复杂度正确，却超出时间限制，请使用更优的输入输出方式，或者优化常数。**


## 样例 #1

### 输入

```
5 2
1 0 -1 0 0```

### 输出

```
2```

# AI分析结果



**唯一算法分类**：前缀和 + 单调队列

---

### **题解思路与核心难点分析**

#### **核心思路**
1. **分情况讨论最大子段和**：填 0 的位置时，最大子段和可能出现在两种场景：
   - **Case 1**：子段内的 0 数量 ≤k，此时全填 1，贡献为填 1 的前缀和差值。
   - **Case 2**：子段内的 0 数量 >k，此时填 k 个 1 和剩余 -1，贡献为填 -1 的前缀和差值 + 2k。
2. **高效维护极值**：利用单调队列维护 Case1 的区间最大值，后缀数组维护 Case2 的全局最大值。

#### **解决难点**
- **分界点确定**：每个左端点对应的右端点分界点需通过预处理 0 的位置快速定位。
- **线性复杂度**：通过单调队列和后缀数组避免双重循环，确保时间复杂度为 O(n)。

---

### **题解评分（≥4星）**

1. **cyffff（5星）**  
   - 思路清晰，代码高效，利用前缀和与单调队列直接处理两种场景。
   - 预处理分界点 `pos`，并巧妙结合后缀最大值数组 `pm` 和 `sm`。
   - 代码结构简洁，处理边界条件严谨。

2. **LHQing（4星）**  
   - 类似分情况处理，但代码中使用双指针维护区间。
   - 用 `suf` 数组维护后缀最大值，逻辑清晰但部分实现略显冗余。

3. **ncwzdlsd（4星）**  
   - 通过维护 `c1` 和 `cm1` 前缀和数组，结合双指针和单调队列。
   - 代码简洁，但部分变量命名不够直观。

---

### **最优思路与技巧提炼**

1. **分治策略**：将问题拆分为两种独立情况，分别计算并取最大值。
2. **前缀和优化**：定义两个前缀和数组 `p1`（全填 1）和 `p0`（全填 -1），快速计算区间和。
3. **单调队列维护窗口极值**：在 Case1 的滑动窗口内，用单调队列维护 `p1` 的最大值。
4. **后缀数组加速全局查询**：预处理 Case2 的后缀最大值数组，快速获取全局最优解。

---

### **同类题型与算法套路**

- **最大子段和变种**：涉及资源分配（如填 k 个特定值）的变种问题。
- **滑动窗口极值维护**：如 LeetCode 239（滑动窗口最大值）、洛谷 P1886。
- **双指针与分界点**：如统计区间满足条件的端点分界。

#### **推荐题目**
1. **洛谷 P1115**：基础最大子段和。
2. **LeetCode 53**：经典最大子数组和。
3. **洛谷 P4551**：带权树的最长路径（类似极值维护）。

---

### **可视化与算法演示**

#### **动画设计**
- **数据结构展示**：用颜色区分 `p1` 和 `p0` 的区间，红色表示填 1，蓝色表示填 -1。
- **分界点标记**：高亮每个左端点对应的分界点 `pos`，动态显示 Case1 和 Case2 的范围。
- **单调队列操作**：动画演示队列头尾的弹出与插入，标注当前维护的极值。

#### **复古像素风格**
- **8-bit 网格**：将数组元素显示为像素块，填 1 的块亮红色，填 -1 的块暗蓝色。
- **音效触发**：在找到新最大值时播放上升音调，队列操作时播放点击音效。
- **自动演示模式**：算法自动运行，分步展示分界点确定和极值计算。

---

### **核心代码片段（cyffff 题解）**

```cpp
// 预处理前缀和与后缀最大值数组
for (int i = n; i >= 1; i--) {
    pm[i] = max(pm[i+1], p1[i]); // Case1 后缀最大值
    sm[i] = max(sm[i+1], p0[i]); // Case2 后缀最大值
}

// 单调队列维护 Case1 的区间极值
for (int i = 0, lp = 1; i <= n; i++) {
    while (hd <= tl && stk[hd].p < i) hd++;
    int id = bel[i] + k + 1;
    if (id > cnt) {
        ans = max(ans, pm[i+1] - p1[i]);
    } else {
        int np = pos[id];
        // 更新单调队列
        for (; lp <= np-1; lp++) {
            while (hd <= tl && stk[tl].v < p1[lp]) tl--;
            stk[++tl] = {p1[lp], lp};
        }
        // 合并两种情况的极值
        ans = max({ans, stk[hd].v - p1[i], sm[np] - p0[i] + 2*k});
    }
}
```

---

### **总结与心得**

- **贪心分治**：将复杂问题拆分为独立子问题，是降低难度的关键。
- **预处理与极值维护**：前缀和与单调队列的组合能高效处理大规模数据。
- **调试技巧**：边界条件（如分界点超出数组范围）需仔细验证，可通过小样例逐步调试。

---
处理用时：105.79秒
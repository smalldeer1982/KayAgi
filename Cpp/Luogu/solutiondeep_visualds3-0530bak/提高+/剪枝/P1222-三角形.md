# 题目信息

# 三角形

## 题目描述

给出平面上的 $n$ 个等腰直角三角形。每个三角形用三个整数 $x,y,m$ 描述。一个三角形的三个顶点分别是 $(x,y),(x+m,y),(x,y+m)$。

你的任务是计算这些三角形覆盖的总面积。

## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)

数据范围：$1\le n \le 2000$，$1 \le i \le n$，$-10^7 \le x_i,y_i \le 10^7$，$1\leq m_i \le 1000$。

## 样例 #1

### 输入

```
5
-5 -3 6
-1 -2 3
0 0 2
-2 2 1
-4 -1 2
```

### 输出

```
24.5```

# AI分析结果



# 三角形覆盖问题解析

## 唯一算法分类
扫描线算法（离散化+事件点处理）

---

## 综合分析与结论

### 核心算法流程
1. **离散化处理**：将三角形的底边和顶点y坐标离散化，形成关键扫描线
2. **扫描线移动**：从下到上逐层扫描，维护当前扫描线与所有相交三角形的水平投影线段
3. **事件点处理**：
   - 底边事件：将新三角形加入投影集合
   - 顶点事件：将超出范围的三角形移出集合
4. **投影计算**：对当前扫描线处所有三角形的投影线段进行合并，计算覆盖长度
5. **面积累加**：用梯形面积公式（上底+下底）× 高度差 / 2 进行面积累计

### 解决难点
- **斜边交点的处理**：需要额外添加斜边与垂直边的交点作为扫描线事件点
- **高效投影维护**：使用差分数组+排序合并策略将复杂度控制在O(n²)
- **大坐标范围**：通过离散化将坐标映射到有限事件点集合

### 可视化设计
![扫描线动画示意图](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)
- **颜色标记**：
  - 当前扫描线用红色高亮
  - 激活的三角形投影用蓝色渐变填充
  - 事件点用黄色脉冲光圈标识
- **动画步骤**：
  1. 扫描线从底部逐层上升
  2. 触发事件点时显示三角形加入/移除效果
  3. 投影线段合并过程用绿色线段动态绘制
  4. 当前梯形面积用半透明色块叠加显示

---

## 题解清单（≥4星）

### 1. ZhYic的扫描线解法（★★★★☆）
- **亮点**：完整实现扫描线核心逻辑，添加斜边交点处理
- **关键代码**：
```cpp
void put(int x) { // 处理投影线段
    cnt=0;
    for(auto iter=q.begin(); iter!=q.end();) {
        tri now=*iter;
        int x1=now.x, x2=now.x+(now.m-(ori[x]-ori[now.y]));
        line[++cnt]={x1,1}, line[++cnt]={x2,-1};
        if(x1==x2) iter=q.erase(iter);
        else iter++;
    }
}
```

### 2. 辰星凌的改进辛普森积分（★★★★☆）
- **亮点**：自适应积分+三角形包含优化
- **核心函数**：
```cpp
inline int TIT(Triangle A,Triangle B) { // 判断包含关系
    return A.L>=B.L&&A.R<=B.R&&A.D>=B.D&&A.U<=B.U&&...;
}
```

### 3. Edgration的自适应辛普森（★★★★☆）
- **亮点**：代码简洁，适合快速实现
- **积分核心**：
```cpp
double f(double X) { // 计算X处的覆盖长度
    vector<pair<double,double>> seg;
    for(auto &t : T) 
        if(t.x < X && X <= t.x + t.m) 
            seg.emplace_back(t.y, t.y + t.m - (X - t.x));
    // 合并线段并返回总长度
}
```

---

## 最优思路提炼
**扫描线+事件点差分法**：
1. 将三角形按底边y坐标排序
2. 离散化所有可能的扫描线位置（包括斜边交点）
3. 维护当前激活的三角形集合
4. 使用差分数组快速计算投影线段的覆盖长度
5. 面积累加公式：`ans += (上底+下底) * 高度差 / 2`

---

## 相似题目推荐
1. [P5490 矩形面积并](https://www.luogu.com.cn/problem/P5490)
2. [P3219 三角形覆盖问题](https://www.luogu.com.cn/problem/P3219)
3. [SP8073 圆面积并](https://www.luogu.com.cn/problem/SP8073)

---

## 复古像素化动画方案
```html
<canvas id="scan"></canvas>
<script>
const PIXEL_SIZE = 8;
const COLORS = { // 8-bit调色板
    scanLine: '#FF3333', activeTri: '#3399FF', 
    areaFill: 'rgba(0,255,0,0.3)', eventPoint: '#FFFF00'
};

class ScanAnimation {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.triangles = []; // 存储三角形数据
        this.events = [];    // 扫描线事件队列
        this.currentY = 0;  // 当前扫描线位置
    }
    
    addEvent(y, type, tri) {
        this.events.push({y, type, tri});
        this.events.sort((a,b) => a.y - b.y);
    }
    
    drawPixel(x, y, color) {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x*PIXEL_SIZE, y*PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
    }
    
    animateStep() {
        if(this.currentY >= maxY) return;
        
        // 绘制当前扫描线
        this.drawScanLine(this.currentY);
        
        // 处理当前事件点
        const events = this.events.filter(e => e.y === this.currentY);
        events.forEach(e => {
            this.drawEventPoint(e);
            e.type === 'add' ? this.addTriangle(e.tri) : this.removeTriangle(e.tri);
        });
        
        // 计算并绘制覆盖区域
        const coverage = this.calcCoverage();
        this.drawCoverage(coverage);
        
        this.currentY++;
        requestAnimationFrame(() => this.animateStep());
    }
}
</script>
```

---

## 调试心得摘录
1. **斜边交点遗漏**："当两个三角形的斜边相交时，必须添加交点的y坐标作为扫描线，否则会漏算面积"
2. **精度处理**："使用离散化坐标映射代替浮点运算，通过lower_bound进行坐标查找"
3. **投影合并优化**："先按左端点排序，再合并重叠区间，可将O(n²)复杂度降为O(n logn)"

---

## 算法比较
| 方法         | 时间复杂度 | 空间复杂度 | 实现难度 | 适用场景       |
|--------------|------------|------------|----------|----------------|
| 扫描线       | O(n²)      | O(n)       | 高       | 精确计算       |
| 辛普森积分   | O(n logR)  | O(1)       | 中       | 近似快速求解   |
| 暴力容斥     | O(n³)      | O(n)       | 低       | 小数据量       |

---

**最佳实践建议**：优先实现扫描线算法，在时间紧迫时可采用自适应辛普森积分法作为备用方案。

---
处理用时：80.88秒
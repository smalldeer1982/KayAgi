# 题目信息

# [NOIP 2014 普及组] 子矩阵

## 题目背景

NOIP2014 普及组 T4

## 题目描述

给出如下定义：

1. 子矩阵：从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵（保持行与列的相对顺序）被称为原矩阵的一个子矩阵。

    例如，下面图中选取第 $2,4$ 行和第 $2,4,5$ 列交叉位置的元素得到一个 $2 \times 3$ 的子矩阵如下所示。

|$9$|$\color{#6a5acd}3$|$3$|$\color{#6a5acd}3$|$\color{#6a5acd}9$|
|:-|:-|:-|:-|:-|
|$\color{#6a5acd}9$|$\color{blue}4$|$\color{#6a5acd}8$|$\color{blue}7$|$\color{blue}4$|
|$1$|$\color{#6a5acd}7$|$4$|$\color{#6a5acd}6$|$\color{#6a5acd}6$|
|$\color{#6a5acd}6$|$\color{blue}8$|$\color{#6a5acd}5$|$\color{blue}6$|$\color{blue}9$|
|$7$|$\color{#6a5acd}4$|$5$|$\color{#6a5acd}6$|$\color{#6a5acd}1$|

此矩阵的其中一个 $2\times3$ 的子矩阵是：

|$4$|$7$|$4$|
|:-|:-|:-|
|$8$|$6$|$9$|

2. 相邻的元素：矩阵中的某个元素与其上下左右四个元素（如果存在的话）是相邻的。

3. 矩阵的分值：矩阵中每一对相邻元素之差的绝对值之和。

本题任务：给定一个 $n$ 行 $m$ 列的正整数矩阵，请你从这个矩阵中选出一个 $r$ 行 $c$ 列的子矩阵，使得这个子矩阵的分值最小，并输出这个分值。

## 说明/提示

#### 样例 1 说明

该矩阵中分值最小的 $2$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行与第 $1$ 列、第 $3$ 列、第 $4$ 列交叉位置的元素组成，为：

|$6$|$5$|$6$|
|:-|:-|:-|
|$7$|$5$|$6$|

其分值为 $|6-5|+|5-6|+|7-5|+|5-6|+|6-7|+|5-5|+|6-6|=6$。

#### 样例 2 说明

该矩阵中分值最小的 $3$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行、第 $6$ 行与第 $2$ 列、第 $6$ 列、第 $7$ 列交叉位置的元素组成，选取的分值最小的子矩阵为：

|$9$|$7$|$8$|
|:-|:-|:-|
|$9$|$8$|$8$|
|$5$|$8$|$10$|

#### 数据范围

- 对于 $50\%$ 的数据，$1\leq n\leq 12$，$1\leq m\leq 12$，矩阵中的每个元素 $1\leq a_{i,j}\leq20$；

- 对于 $100\%$ 的数据，$1\leq n\leq 16$，$1\leq m\leq 16$，矩阵中的每个元素 $1\leq a_{i,j}\leq 1000$，$1\leq r\leq n$，$1\leq c\leq m$。

## 样例 #1

### 输入

```
5 5 2 3
9 3 3 3 9
9 4 8 7 4
1 7 4 6 6
6 8 5 6 9
7 4 5 6 1```

### 输出

```
6```

## 样例 #2

### 输入

```
7 7 3 3  
7 7 7 6 2 10 5
5 8 8 2 1 6 2 
2 9 5 5 6 1 7 
7 9 3 6 1 7 8 
1 9 1 4 7 8 8 
10 5 9 1 1 8 10
1 3 1 5 4 8 6```

### 输出

```
16```

# AI分析结果



# 算法分类  
**动态规划与搜索的结合**

## 题解思路与算法要点  
### 核心思路  
所有题解的共同思路是：**先枚举行/列的组合，再计算最优子矩阵分值**。主要分为两类方法：  
1. **DFS枚举行 + 动态规划处理列**（panyf、RikoHere）  
   - 通过DFS枚举选中的r行，预处理行间纵向差值  
   - 对列的组合用动态规划求最小分值  
2. **二进制枚举行 + DP优化列**（xmy201315、lkjlkjlkj2012）  
   - 用二进制状态压缩枚举行的组合  
   - 通过预计算列间横向差值和行间纵向差值，构建动态规划状态转移方程  

### 解决难点  
1. **避免重复计算**：  
   - 预处理行间纵向差值（如g[i][j][k]表示i行与j行在第k列的绝对差）  
   - 预处理列间横向差值（如h[i][j][k]表示i列与j列在第k行的绝对差）  
2. **状态转移优化**：  
   - 设计状态`f[i][j]`表示前i列选j列的最小分值  
   - 转移方程：`f[i][j] = min(f[k][j-1] + 列i的纵向差 + i列与k列的横向差)`  

### 关键对比  
| 题解 | 枚举方式 | 动态规划维度 | 预处理方式 |  
|------|----------|--------------|------------|  
| panyf | DFS选行 | 列的组合 | 行间纵向差值、列间横向差值 |  
| lizh | DFS选列 | 行的组合 | 行内横向差值、行间纵向差值 |  
| xmy201315 | 二进制选行 | 列的组合 | 列内纵向差值、列间横向差值 |  

---

## 题解评分（≥4星）  
1. **xmy201315（4.5星）**  
   - 亮点：二进制枚举行组合，代码结构清晰  
   - 代码：预处理列内纵向差值`cw[]`和列间横向差值`rw[][]`  
2. **RikoHere（4.2星）**  
   - 亮点：DFS选行与DP选列分离，注释详细  
   - 代码：`work()`函数中动态规划部分可读性强  
3. **lkjlkjlkj2012（4.0星）**  
   - 亮点：极简代码实现，直接二进制枚举行  

---

## 最优思路提炼  
1. **预处理优化**  
   - 提前计算所有可能的行间纵向差值和列间横向差值  
   ```cpp  
   // 预处理行间纵向差值  
   for(int i=1; i<n; ++i) 
     for(int j=i+1; j<=n; ++j) 
       for(int k=1; k<=m; ++k) 
         g[i][j][k] = abs(a[i][k] - a[j][k]);
   ```  
2. **状态转移方程**  
   ```cpp  
   f[i][j] = min(f[i][j], f[k][j-1] + cw[i] + rw[k][i]);  
   // cw[i]: 第i列内部纵向差  
   // rw[k][i]: k列与i列间横向差  
   ```  

---

## 同类题目推荐  
1. **P1433 吃奶酪**（坐标选择+状态压缩DP）  
2. **P1078 文化之旅**（路径选择+多维状态）  
3. **P2322 最短母串**（字符串组合+状态压缩）  

---

## 可视化设计  
### 动画方案  
1. **枚举行过程**：  
   - 用红色高亮当前选中的行，灰色表示未选  
   - 显示已选行编号（如`Selected Rows: 2,4,5`）  
2. **动态规划过程**：  
   - 用网格图展示`f[i][j]`矩阵，绿色标记当前更新的单元格  
   - 动态连线显示转移来源（如从`f[3][2]`转移到`f[5][3]`）  

### 复古像素风格  
```javascript  
// Canvas绘制示例  
ctx.fillStyle = '#8B00FF'; // 紫色像素块表示选中行  
ctx.fillRect(col*32, row*32, 30, 30);  
// 音效：选中行时播放8-bit“滴”声  
const selectSound = new Audio('data:audio/wav;base64,UklGRl9...');  
```  

---

## 核心代码实现  
### 二进制枚举行+动态规划（xmy201315）  
```cpp  
for(int S=0; S<(1<<n); S++){  
    if(__builtin_popcount(S)!=r) continue;  
    // 预处理cw和rw  
    for(int i=1;i<=m;++i){  
        cw[i] = 0;  
        for(int j=1;j<r;++j)  
            cw[i] += abs(rows[j][i] - rows[j-1][i]);  
    }  
    // DP部分  
    for(int i=1;i<=m;++i){  
        f[i][1] = cw[i];  
        for(int j=2;j<=c;++j)  
            for(int k=1;k<i;++k)  
                f[i][j] = min(f[i][j], f[k][j-1]+cw[i]+rw[k][i]);  
    }  
}  
```  

---

## 个人心得摘录  
> "在回溯时忘记恢复`w[j][k]`的值，导致WA了3次... 预处理的结构设计比想象中重要" —— panyf  
> "发现横向差和纵向差可以分开计算，这是优化时间的关键" —— RikoHere  

--- 

通过上述分析，读者可以深入理解子矩阵问题的核心解法，掌握预处理优化与动态规划的结合技巧。

---
处理用时：81.63秒
# 题目信息

# yyy loves Maths VII

## 题目背景

yyy 对某些数字有着情有独钟的喜爱，他叫他们为“幸运数字”；然而他作死太多，所以把自己讨厌的数字称为“厄运数字”。

## 题目描述

一群同学在和 yyy 玩一个游戏。

每次,他们会给 yyy $n$ 张卡片，卡片上有数字，所有的数字都是“幸运数字”，我们认为第 $i$ 张卡片上数字是 $a_{i}$。

每次 yyy 可以选择向前走 $a_{i}$ 步并且丢掉第 $i$ 张卡片。当他手上没有卡片的时候他就赢了。

但是呢，大家对“厄运数字”的位置布置下了陷阱，如果 yyy 停在这个格子上，那么他就输了。注意：**即使到了终点，但是这个位置是厄运数字，那么也输了。**

现在，有些同学开始问：yyy 有多大的概率会赢呢？

大家觉得这是个好问题，有人立即让 yyy 写个程序：“电脑运行速度很快！$24$ 的阶乘也不过就 $620\,448\,401\,733\,239\,439\,360\,000$，yyy 你快写个程序来算一算。”

yyy 表示很无语，他表示他不想算概率，最多算算赢的方案数，而且是对 $10^9+7$ 取模后的值。

大家都不会写程序，只好妥协。

但是这时候 yyy 为难了，$24!$ 太大了，要跑好长时间。

他时间严重不够！需要你的帮助！

某个数字可能既属于幸运数字又属于厄运数字。

## 说明/提示

- $10\%$ 的数据 $n \leq 10$；
- $50\%$ 的数据 $n \leq 23$；
- $100\%$ 的数据 $n \leq 24$，$0\le m\le 2$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
8
1 3 1 5 2 2 2 3
0```

### 输出

```
40320```

## 样例 #2

### 输入

```
24
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2
10 15
```

### 输出

```
0```

# AI分析结果



**唯一算法分类**  
状压动态规划

---

### 题解思路与算法要点  
**核心思路**  
- **状态压缩**：用二进制数表示卡片使用状态，`f[i]` 表示状态 `i` 的合法方案数，`dis[i]` 表示对应步数总和。  
- **转移优化**：用 `lowbit` 快速提取二进制中的 `1`，避免遍历所有位，将时间复杂度从 `O(n·2ⁿ)` 优化至 `O(2ⁿ·k)`（`k` 为状态 `i` 中 `1` 的个数）。  
- **预处理与剪枝**：提前计算 `dis[i]` 并跳过厄运数字状态，减少无效计算。

**解决难点**  
1. **枚举效率**：通过 `lowbit` 快速枚举有效位，避免全量遍历。  
2. **状态合法性**：预处理步数总和并检查厄运数字，避免重复计算。  
3. **取模优化**：使用减法代替取模运算，提升代码效率。

---

### 题解评分 (≥4星)  
1. **Siyuan (5星)**  
   - 思路清晰，代码简洁，预处理 `dis` 与 `lowbit` 转移结合完美。  
   - 关键代码片段逻辑紧凑，可读性强。  
2. **RabbitHu (5星)**  
   - 强调 `lowbit` 的逐位处理，注释详细，适合理解位运算优化。  
   - 代码亲测高效，适合竞赛场景。  
3. **Alex_Wei (4星)**  
   - 提出 MITM 与容斥优化，适合进阶学习，但实现复杂度较高。  
   - 未在本题主流解法中体现，但拓展思路值得借鉴。

---

### 最优思路与技巧提炼  
**核心技巧**  
1. **lowbit 快速枚举**：通过 `j = i & -i` 提取最低位的 `1`，循环 `i ^= j` 直至清零。  
2. **状态步数递推**：`dis[i] = dis[i ^ j] + dis[j]`（`j` 为当前 `lowbit`）。  
3. **厄运剪枝**：若 `dis[i]` 为厄运数字，直接跳过转移。

**代码片段**  
```cpp
for (int i = 1; i <= msk; ++i) {
    int j = i & -i;
    dis[i] = dis[i ^ j] + dis[j];
    if (dis[i] == b1 || dis[i] == b2) continue;
    for (int k = i; k; k ^= j) {
        j = k & -k;
        f[i] = (f[i] + f[i ^ j]) % mod;
    }
}
```

---

### 同类型题与算法套路  
**通用解法**  
- **子集和问题**：如 CF327E（双倍经验）。  
- **排列合法性验证**：前缀和约束下的方案计数。  
**类似算法**  
- 状态压缩动态规划（如 TSP 问题）。  
- 位运算优化枚举（如格雷码生成、子集遍历）。

---

### 推荐练习题  
1. **CF327E**：双倍经验，完全相同的问题。  
2. **洛谷 P2622**：状压 DP 处理状态转移。  
3. **洛谷 P2831**：位运算优化状态表示。

---

### 可视化与算法演示  
**动画设计**  
1. **网格状态表示**：每个状态 `i` 显示为二进制网格，激活位高亮。  
2. **步数跟踪**：显示 `dis[i]` 计算过程，厄运数字时标红。  
3. **Lowbit 高亮**：动态展示 `lowbit` 提取与状态转移路径。  

**复古像素风格**  
- **8-bit 音效**：转移成功时播放 `8-bit` 音效，厄运时播放低沉音效。  
- **Canvas 绘制**：用像素块表示状态，颜色区分合法/非法。  
- **自动演示**：按状态顺序自动播放，速度可调。

---

**总结**  
状压 DP 通过位运算优化，结合预处理与剪枝，高效解决高复杂度问题。核心在于状态压缩与 `lowbit` 位操作，适合处理小规模但指数级增长的排列组合问题。

---
处理用时：91.63秒
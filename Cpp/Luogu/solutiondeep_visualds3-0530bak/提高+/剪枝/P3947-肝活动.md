# 题目信息

# 肝活动

## 题目背景

Yume 最近在玩一个名为《LoveLive! School idol festival》的音乐游戏。他之所以喜欢上这个游戏，是因为这个游戏对非洲人十分友好，即便你脸黑到抽不出好卡，还可以通过在每个月举办的两次活动中达成一定的目标来获得奖励。

## 题目描述

Yume 很喜欢这一期活动奖励卡的卡面，于是他决定要肝这一期的活动，拿到活动奖励。这一期的活动规则很特殊，玩家需要在活动规定的结束时间前，完成所有指定的歌曲（**每首歌曲只能打一次**），并获得一定的分数，就可以拿到活动奖励。如果在规定的时间前没有完成所有的歌曲，或者分数不够奖励的分数线，则不能领取活动奖励。每首歌有一个限定的奖励开放时间，玩家如果在这段时间内完成了这首歌，便可以获得一定的分数（**获得的分数 = 开放时间 - 当前已用的总时间**）。如果超出了这段时间之后再完成这首歌，就不能获得分数了。

这样的规则对 Yume 这样的老玩家来说本应是轻而易举，但不巧的是 Yume 把活动的结束时间记成了活动的开始时间，以至于当他上线跃跃欲试的时候，惊恐地发现活动已经快要结束了。现在他想知道，在剩余的时间之内，他能否完成所有的歌、达成奖励的分数线拿到活动卡。为了节省时间，他把这个问题交给了你来解决。请你根据给定的数据，帮他计算出能否在剩余的时间内达成目标。如果能，请告诉他完成每首歌曲的顺序。


## 说明/提示

对于 $0\%$ 的数据，与测试数据完全相同。

对于 $20\%$ 的数据，满足 $n \le 5$。

对于 $40\%$ 的数据，满足 $n \le 9$。

对于 $70\%$ 的数据，满足 $n \le 15$。

另有 $10\%$ 的数据满足 $\sum\limits^{n}_{i=1} T_i < t$。

对于 $100\%$ 的数据，满足 $n \le 22$，$S_i$ 的长度不超过 $50$。保证 $m,t,M_i,T_i$ 及其相加的结果都在 `int` 最大范围内。

## 样例 #1

### 输入

```
3 2 10
BokutachiwaHitotsunoHikari 3 8
Korekara 1 2
SnowHalation 2 5
```

### 输出

```
6
SnowHalation
BokutachiwaHitotsunoHikari
Korekara
```

## 样例 #2

### 输入

```
2 1 2
AoizoraJumpingHeart 1 2
TimeLapse 2 4```

### 输出

```
No Answer```

# AI分析结果



---

### **唯一算法分类**  
**状态压缩动态规划（状压 DP）**

---

### **题解思路、算法要点与解决难点**  

#### **核心思路**  
1. **状态设计**：用二进制状态 `S` 表示已完成的歌曲集合，`dp[S]` 存储该状态下的最大得分，`s[S]` 记录对应顺序的字符串。  
2. **状态转移**：枚举每个状态 `S` 的最后一个完成的歌曲 `i`，从 `S\{i}` 转移而来，计算得分 `max(0, M_i - sum(S))`。  
3. **字典序处理**：在得分相同时，用字符串的字典序比较选择更优顺序。  

#### **解决难点**  
- **时间计算优化**：通过预计算或动态维护 `sum(S)`（如 `stime[S]`），避免重复求和。  
- **字典序维护**：用字符串按完成顺序存储歌曲索引，通过 `std::string` 的字典序比较简化逻辑。  
- **状态压缩限制**：`n ≤ 22` 时，状态数 `O(2^n)` 和转移复杂度 `O(n·2^n)` 需要高效的实现。

---

### **题解评分 (≥4星)**  
1. **cff_0102 的题解**（⭐⭐⭐⭐⭐）  
   - **亮点**：维护 `stime` 数组优化时间计算，通过 `min` 函数优化字典序比较，代码简洁高效。  
   - **优化点**：修改比较方式后显著提升性能（从 TLE 到 900ms）。  
2. **qinyubo 的题解**（⭐⭐⭐⭐）  
   - **亮点**：直接计算 `sum(S)`，逻辑清晰；字符串拼接直观。  
   - **改进点**：未预计算 `sum(S)`，可能影响常数效率。  

---

### **最优思路或技巧提炼**  
1. **状压 DP 状态设计**：用二进制位表示集合，结合得分和顺序记录。  
2. **时间预计算**：通过 `stime[S]` 快速获取总时间，避免重复计算。  
3. **字典序比较技巧**：用字符串拼接顺序，利用 `std::string` 的字典序比较函数。  
4. **转移剪枝**：在无效状态（如总时间超限）时提前跳过。

---

### **同类型题或类似算法套路**  
- **旅行商问题（TSP）**：状态压缩表示访问过的城市。  
- **任务调度**：在时间限制内选择最优任务顺序。  
- **集合覆盖问题**：选择最小子集覆盖所有条件。  

---

### **推荐题目**  
1. **P1433 吃奶酪**（状压 DP + 几何距离）  
2. **P1171 售货员的难题**（经典 TSP 问题）  
3. **P3052 [USACO12MAR]Cows in a Skyscraper G**（分组状压 DP）  

---

### **个人心得摘录**  
- **cff_0102** 的调试经历：将 `if (s[S] > ...)` 改为 `s[S] = min(...)` 显著优化性能，说明条件判断的代码结构对常数影响巨大。  

---

### **可视化与算法演示**  

#### **动画方案**  
1. **状态网格**：将状态 `S` 表示为二进制网格，高亮当前处理的位。  
2. **转移过程**：动态显示从 `S\{i}` 到 `S` 的转移，标记最后一个歌曲 `i`。  
3. **得分更新**：用颜色区分得分增加（绿色）或不变（灰色）。  

#### **复古像素风格**  
- **颜色方案**：8 位调色板（红、绿、蓝、黄表示不同状态）。  
- **Canvas 绘制**：每个状态 `S` 显示为 22 位像素块，当前操作位闪烁。  
- **音效设计**：  
  - 转移成功：短促“哔”声。  
  - 得分更新：上扬音效。  
  - 无解：低沉音效。  

#### **自动演示模式**  
- **AI 决策**：按状态 `S` 的二进制位数从小到大自动执行，单步间隔 500ms。  
- **交互功能**：支持暂停、步进、重置，速度调节（1x/2x/5x）。  

---

### **代码片段（核心逻辑）**  
```cpp
// cff_0102 的转移逻辑
for (int S = 1; S < (1 << n); S++) {
    for (int i = 0; i < n; i++) {
        if (S & (1 << i)) {
            int last = S ^ (1 << i);
            int sum = stime[last];
            int temp = dp[last] + max(0, m[i] - (sum + t[i]));
            if (temp > dp[S]) {
                dp[S] = temp;
                s[S] = s[last] + (char)i;
            } else if (temp == dp[S]) {
                s[S] = min(s[S], s[last] + (char)i);
            }
        }
    }
}
```

---

### **总结**  
通过状压 DP 维护状态和顺序，结合时间预计算和字典序优化，解决了高复杂度下的路径选择问题。复古像素动画和音效增强了学习体验，适合算法教学与交互演示。

---
处理用时：201.98秒
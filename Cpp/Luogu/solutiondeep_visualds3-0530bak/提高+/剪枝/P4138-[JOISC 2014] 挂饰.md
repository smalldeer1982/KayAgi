# 题目信息

# [JOISC 2014] 挂饰

## 题目描述

JOI君有N个装在手机上的挂饰，编号为1...N。 JOI君可以将其中的一些装在手机上。

JOI君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有1个。

此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果JOI君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。

JOI君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。


## 说明/提示

$1\leq N\leq 2000$

$0\leq Ai\leq N(1\leq i\leq N)$

$-10^6\leq Bi\leq 10^6(1\leq i\leq N)$



## 样例 #1

### 输入

```
5
0 4
2 -2
1 -1
0 1
0 3```

### 输出

```
5```

# AI分析结果



**唯一算法分类**  
动态规划（01背包变种）

---

### **题解思路与难点分析**

#### **核心思路**
所有题解均围绕动态规划展开，核心为**背包模型**，状态设计为处理前i个物品时剩余j个挂钩的最大喜悦值。关键点包括：
1. **状态转移方程**：选择当前物品需消耗1个挂钩（挂到手机上），并增加其挂钩数，转移时需处理负数情况（`max(j - a_i, 0)`）。
2. **排序优化**：按挂钩数降序排序，优先处理挂钩多的物品，确保后续有更多可用挂钩。
3. **初始化**：起始状态`f[0][1] = 0`（初始手机有1挂钩），其余设为极小值表示不可达。

#### **解决难点**
1. **挂钩数的动态维护**：挂钩数可能为负，需通过`max`函数限制最小值。
2. **状态压缩**：部分题解使用一维数组+右移处理（如题解3、4），优化空间复杂度。
3. **贪心剪枝**：题解2、8将物品分类处理，减少无效状态转移。

---

### **题解评分（≥4星）**
1. **违规用户名U56916（4.5星）**  
   - 思路清晰，正确使用二维DP+排序优化，代码简洁。  
   - 亮点：详细推导转移方程，处理负数逻辑明确。

2. **空の軌跡（4星）**  
   - 一维数组+右移处理挂钩数，空间优化显著。  
   - 亮点：正反向枚举转移，避免重复计算。

3. **FreeDr（4星）**  
   - 分类处理+贪心剪枝，减少无效计算。  
   - 亮点：分情况讨论提升效率，合并正负价值逻辑。

---

### **最优思路提炼**
1. **状态定义**：`f[i][j]`表示前i个物品，剩余j个挂钩时的最大喜悦值。
2. **转移方程**：  
   ```cpp
   f[i][j] = max(f[i-1][j], f[i-1][max(j-a_i, 0)+1] + b_i);
   ```
3. **排序策略**：按挂钩数降序排序，优先处理挂钩多的物品。
4. **初始化与边界**：起始状态`f[0][1] = 0`，其余为极小值。

---

### **同类型题推荐**
1. **P1064 金明的预算方案**（依赖型背包）  
2. **P1156 垃圾陷阱**（状态设计与时间维度）  
3. **P2014 选课**（树形依赖背包）

---

### **可视化与算法演示**
**动画方案**：  
1. **像素风格界面**：挂钩显示为绿色像素块，挂饰为不同颜色方块（正价值蓝色，负红色）。
2. **状态更新高亮**：每次转移时，当前物品和对应挂钩数变化区域闪烁黄色。
3. **音效反馈**：成功转移时播放“哔”声，最终答案显示时播放胜利音效。

**关键步骤演示**：  
```javascript
// 示例代码（伪代码）
function updateDP(i, j) {
    // 高亮当前处理的物品和挂钩数
    highlightItem(i);
    highlightHook(j);
    
    // 计算新旧状态
    let prevHooks = Math.max(j - a[i], 0) + 1;
    let newVal = dp[i-1][prevHooks] + b[i];
    
    // 更新状态并播放音效
    if (newVal > dp[i][j]) {
        dp[i][j] = newVal;
        playSound('beep');
    }
}
```

---

### **代码实现（核心片段）**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = -1e9;
struct Node { int a, b; };
Node w[2010];
int dp[2010][2010];

bool cmp(Node x, Node y) { return x.a > y.a; }

int main() {
    int n; cin >> n;
    for (int i = 1; i <= n; i++) cin >> w[i].a >> w[i].b;
    sort(w+1, w+n+1, cmp);
    
    memset(dp, 0x8f, sizeof(dp)); // 初始化为极小值
    dp[0][1] = 0;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            int prev = max(j - w[i].a, 0) + 1;
            dp[i][j] = max(dp[i-1][j], dp[i-1][prev] + w[i].b);
        }
    }
    
    int ans = *max_element(dp[n], dp[n] + n + 1);
    cout << ans;
}
```

---
处理用时：71.77秒
# 题目信息

# [蓝桥杯青少年组国赛 2023] 月球疏散行动

## 题目背景

本题原题：[P5017 [NOIP 2018 普及组] 摆渡车](https://www.luogu.com.cn/problem/P5017)

## 题目描述

为了避免太阳爆发引起的灾难，人类决定给地球装上发动机，最终逃离太阳系。原计划要带着月球一起走，结果月球行星发动机发生灾难性故障，必须炸毁月球。为此，在月球上的工作人员都要疏散回地球。

月球基地有一艘太空穿梭机可以用来疏散工作人员。但是人们分散在各处，必须前往基地集合，他们到达基地的时间不等。穿梭机可以将抵达基地等待登机的工作人员先送回地球，然后再返回基地疏散下一批工作人员。

总共有 $N$ 名工作人员需要疏散，太空穿梭机从月球到地球往返一次花时间 $M$ 小时，第 $i$ 个人抵达基地等待登机的时刻为 $T_i$。

指挥官希望所有工作人员在基地等待的时间总和最小，而且他可以任意安排穿梭机的起飞时间，假定穿梭机足够大，可以装下所有工作人员，在不计登机和下机时间等因素的情况下，最小的等候时间总和是多少？

例如：$N=5$，$M=4$，1 号~5 号工作人员到达基地的时刻依次为 11、3、3、5、10，穿梭机可以在 3 时出发，先送 2 号、3 号工作人员去地球，然后于 7 时返回月球基地；此时，4 号工作人员已于 5 时到达基地，等候了 2 小时。这时让穿梭机马上送走他，然后于 11 时从地球返回基地；此时，5 号工作人员已于 10 时到达基地，等候了 1 小时；而 1 号工作人员刚好于 11 时到达基地，等候 0 小时；穿梭机于 11 时将两人送走，即完成全部疏散任务。总的等候时间 $=$ 4 号工作人员等候时间 $+$ 5 号工作人员等候时间 $=2+1=3$ 小时。无法再找到有更小等候时间总和的方案。

## 样例 #1

### 输入

```
5 4
11 3 3 5 10```

### 输出

```
3```

# AI分析结果



---

## 唯一算法分类  
**动态规划-斜率优化DP**

---

## 综合分析与结论  
### 核心思路  
1. **动态规划模型**：  
   - 定义 `dp[i]` 为前 `i` 时刻所有人员的最小等待时间总和。  
   - 转移方程：`dp[i] = min(dp[j] + (前缀人数差)*i - 前缀时间差)`，其中 `j` 是上一次发车的时间（需满足 `j ≤ i-M`）。  
2. **前缀和优化**：  
   - `tim[i]` 表示前 `i` 时刻到达的总人数，`s[i]` 表示前 `i` 时刻到达时间的总和。  
   - 将转移方程拆解为 `(tim[i]-tim[j])*i - (s[i]-s[j])`，避免重复计算。  
3. **斜率优化**：  
   - 将转移方程转化为斜率比较形式，用单调队列维护下凸壳，将时间复杂度从 `O(N²)` 优化到 `O(N)`。  

### 难点与突破  
- **推导斜率方程**：需通过代数变形将 `dp[j] + s[j]` 视为点的纵坐标，`tim[j]` 为横坐标，比较斜率 `(G_j-G_k)/(tim_j-tim_k)` 与当前时间 `i` 的关系。  
- **维护单调队列**：保证队列中的点构成下凸壳，每次淘汰队首斜率不满足条件的点，并在队尾插入新点前淘汰破坏凸性的点。  

### 可视化设计  
- **动画流程**：  
  1. 时间轴从左到右推进，高亮当前处理的时间点 `i`。  
  2. 显示单调队列中的候选 `j` 值（如 `i-M` 之前的点），用不同颜色区分有效和无效转移点。  
  3. 动态绘制斜率比较过程，展示队列淘汰逻辑。  
- **复古像素风格**：  
  - 用 8 位色块表示时间点，绿色表示已处理，红色表示当前 `i`，黄色表示队列中的 `j`。  
  - 音效：队列插入时播放“滴”声，淘汰点时播放“咔嚓”声，更新 `dp[i]` 时播放上升音调。  

---

## 题解清单 (4星)  
### 题解：YZren (4星)  
- **关键亮点**：  
  1. **完整实现斜率优化**：通过单调队列维护凸壳，代码逻辑清晰。  
  2. **预处理巧妙**：将原始数据离散化为前缀和数组，避免直接处理稀疏时间点。  
  3. **边界处理严谨**：计算 `maxx` 时预留 `M` 时间，确保覆盖所有可能的发车时间。  
- **优化点**：变量命名可读性不足（如 `que` 为队列，`tim/s` 前缀和），缺乏注释。  

---

## 代码核心实现  
### 关键逻辑片段  
```cpp  
int tim[maxn], s[maxn], dp[maxn], que[maxn], L=1, R;  
// 预处理前缀和  
for (int i=1; i<=maxx; i++) {  
    tim[i] += tim[i-1];  
    s[i] += s[i-1];  
}  
// 斜率优化 DP  
for (int i=1; i<=maxx; i++) {  
    if (i >= m) {  
        // 淘汰队尾不满足凸性的点  
        while (L<R && slope(que[R-1], que[R]) >= slope(que[R], i-m)) R--;  
        que[++R] = i - m;  
    }  
    // 淘汰队首斜率小于i的点  
    while (L<R && slope(que[L], que[L+1]) <= i) L++;  
    dp[i] = tim[i] * i - s[i];  
    if (L <= R) {  
        int j = que[L];  
        dp[i] = min(dp[i], dp[j] + (tim[i]-tim[j])*i - (s[i]-s[j]));  
    }  
}  
```  

---

## 最优技巧提炼  
1. **时间离散化与压缩**：将稀疏的到达时间映射到连续时间轴，避免无效计算。  
2. **前缀和拆分**：将 `sum_i` 分解为 `tim[i]` 和 `s[i]`，简化转移方程。  
3. **斜率优化套路**：将 DP 转移转化为直线截距问题，利用单调队列维护候选点集。  

---

## 同类题目推荐  
1. **P5017 [NOIP2018 普及组] 摆渡车**（原题变种，直接应用相同算法）  
2. **P3199 [HNOI2009] 最小圈**（分数规划+斜率优化）  
3. **P3628 [APIO2010] 特别行动队**（经典斜率优化DP）  

---

## 个人心得摘录  
- **调试教训**：初始未考虑 `maxx` 的边界，导致最后一班车时间未覆盖，WA 后通过增加 `M` 修正。  
- **顿悟点**：将 `dp[j] + s[j]` 视为纵坐标，`tim[j]` 为横坐标，斜率比较豁然开朗。  

---

## 可视化与游戏化实现  
### 像素动画设计  
1. **Canvas 绘制**：  
   - 时间轴横向排列，每个时间点用 16x16 像素块表示。  
   - 当前时间 `i` 高亮为红色，队列中的 `j` 为黄色，已计算的 `dp[i]` 为绿色。  
2. **自动演示模式**：  
   - 按时间步进，自动更新队列和 `dp[i]`，右侧显示当前状态和公式推导。  
3. **音效设计**：  
   - `dp[i]` 更新：8-bit 上升音效（频率 500Hz → 800Hz）。  
   - 队列插入：短促“哔”声（50ms）。  
   - 淘汰队尾：低沉“砰”声（100ms）。  

### 交互控制  
- **速度调节**：滑动条控制步进间隔（100ms~2000ms）。  
- **单步执行**：按空格键逐步执行，观察队列和 `dp` 变化。  

---

**答案**  
\boxed{3}

---
处理用时：65.79秒
# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



---

## 题目重写

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。

## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

---

## 唯一算法分类
无算法分类

---

## 综合分析与结论

### 核心思路
所有题解均采用**空间换时间**的核心策略，通过存储地毯参数（左下角坐标+延伸长度）而非铺设区域，将时间复杂度从 $O(N^2)$ 优化至 $O(N)$。关键点在于：
1. **逆向遍历**：后铺设的地毯优先级更高，逆向遍历遇到第一个覆盖点即可立即返回结果
2. **覆盖判断公式**：$x \in [a_i, a_i+g_i]$ 且 $y \in [b_i, b_i+k_i]$

### 难点对比
| 方法            | 优点                     | 缺点                     |
|-----------------|--------------------------|--------------------------|
| 正向遍历        | 逻辑直观                 | 需要遍历全部地毯         |
| 逆向遍历        | 最优时间复杂度 $O(1)$   | 需要倒序存储数据         |
| 栈结构          | 符合后进先出特性         | 额外空间存储栈结构       |

### 可视化设计
采用**像素网格动画**演示地毯覆盖过程：
1. **Canvas 网格**：用不同颜色表示各层地毯覆盖区域
2. **高亮扫描线**：逆向遍历时用红色扫描线标记当前检查的地毯
3. **音效反馈**：发现覆盖时播放 "8-bit 胜利音效"，未找到时播放 "失败音效"
4. **自动演示模式**：以 500ms/步的速度自动运行，可随时暂停单步观察

---

## 题解清单 (≥4星)

### 1. [kuaiCreator] ★★★★☆
- **亮点**：逆向遍历实现最优时间复杂度，代码简洁易读
- **代码片段**：
```cpp
for(int i = n; i >= 1; i--) {
    if(x >= a[i] && x <= a[i] + g[i] && y >= b[i] && y <= b[i] + k[i]) {
        ans = i; 
        break; // 关键优化点
    }
}
```

### 2. [Jayfeather2012] ★★★★
- **亮点**：最早提出逆向遍历思路，代码规范
- **调试心得**：原考虑二维数组方案，发现空间超标后转换思路

### 3. [Vct14] ★★★★
- **亮点**：预计算右下角坐标加速判断
- **数据结构**：
```cpp
struct dt{
    int a,b,g,k,c,d; // 存储预计算的右下角坐标
};
```

---

## 核心代码实现

### 逆向遍历最优解
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4+5;
int a[N], b[N], g[N], k[N];

int main() {
    int n, x, y;
    cin >> n;
    for(int i=1; i<=n; i++) 
        cin >> a[i] >> b[i] >> g[i] >> k[i];
    cin >> x >> y;
    
    for(int i=n; i>=1; i--) {
        if(x >= a[i] && x <= a[i]+g[i] && 
           y >= b[i] && y <= b[i]+k[i]) {
            cout << i;
            return 0;
        }
    }
    cout << -1;
    return 0;
}
```

---

## 可视化方案设计

### 像素风格实现
```javascript
// Canvas 初始化
const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d');
const CELL_SIZE = 10; // 10x10 像素表示1单位

function drawCarpet(a, b, g, k, color) {
    ctx.fillStyle = color;
    ctx.fillRect(a*CELL_SIZE, b*CELL_SIZE, 
                (g+1)*CELL_SIZE, (k+1)*CELL_SIZE);
}

// 动画演示
let current = n;
const timer = setInterval(() => {
    if(checkCover(current, x, y)) {
        playSuccessSound();
        highlightCarpet(current);
        clearInterval(timer);
    } else {
        drawScanLine(current);
        current--;
    }
}, 500);
```

---

## 相似题目推荐
1. P1502 窗口的星星 - 矩形覆盖极值问题
2. P1886 滑动窗口 - 区间覆盖查询
3. P2744 覆盖问题 - 多矩形覆盖分析

---
处理用时：77.95秒
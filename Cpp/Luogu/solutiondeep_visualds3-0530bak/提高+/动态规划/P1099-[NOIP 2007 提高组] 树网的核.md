# 题目信息

# [NOIP 2007 提高组] 树网的核

## 题目描述

设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。

路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 
$d(a, b)$ 为 $a, b$ 两结点间的距离。

$D(v, P)=\min\{d(v, u)\}$, $u$ 为路径 $P$ 上的结点。

树网的直径：树网中最长的路径成为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

偏心距 $\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即

$$\mathrm{ECC}(F)=\max\{D(v, F),v \in V\}$$

任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)


## 说明/提示

- 对于 $40\%$ 的数据，保证 $n \le 15$。
- 对于 $70\%$ 的数据，保证 $n \le 80$。
- 对于 $100\%$ 的数据，保证 $2\le n \le 300$，$0\le s\le10^3$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^3$。

NOIP2007 提高组第四题

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```

### 输出

```
5```

# AI分析结果



# [NOIP 2007 提高组] 树网的核

## 题目描述

设 $T=(V,E,W)$ 是一个无圈且连通的无向图（即无根树），每条边都有正整数的权值。定义：

1. **路径**：树中任意两结点 $a,b$ 之间的唯一简单路径，长度记作 $d(a,b)$
2. **偏心距**：路径 $F$ 到最远结点的距离 $\mathrm{ECC}(F)=\max\{D(v,F)\}$
3. **树网的核**：在任意直径上选取长度不超过 $s$ 的路径，使得偏心距最小

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)

## 输入格式
第一行两个整数 $n,s$，表示结点数与路径长度限制  
接下来 $n-1$ 行每行三个整数表示边的信息

## 输出格式
输出最小偏心距

## 算法分类
无算法分类（树论+双指针优化）

---

## 核心思路解析

### 树直径的关键性质
1. **多直径必相交**：所有直径必定交于至少一个公共点
2. **中心唯一性**：所有直径的中点（可能在边上）唯一
3. **最优性原理**：核必定存在于某条直径上

### 解法对比
| 解法             | 时间复杂度 | 核心优化                     | 适用场景        |
|------------------|------------|------------------------------|-----------------|
| 暴力枚举         | O(n³)      | 无                           | 小数据验证      |
| 双指针+前缀最值  | O(n)       | 滑动窗口维护支链最大值       | 标准解法        |
| 二分答案         | O(nlogn)   | 二分偏心距检验可行性         | 超大n值场景     |

### 状态转移与优化
当确定直径后，偏心距可分解为三个部分：
```math
\mathrm{ECC}(F) = \max\left(\underbrace{\max_{p\in F}支链长度}_\text{内部支链}, \underbrace{d(a,l)}_\text{左端延伸}, \underbrace{d(r,b)}_\text{右端延伸}\right)
```
通过预处理直径上每个点的最大支链长度，配合双指针维护滑动窗口，实现O(n)时间复杂度

---

## 五星题解推荐

### 1. StudyingFather（⭐⭐⭐⭐⭐）
**亮点**：
- 严谨的数学证明体系
- 双指针+单调队列优化
- 代码模块化设计

**核心代码**：
```cpp
void solve() {
  for (int i=1; i<=cnt; i++) vis[dia[i]]=1;
  int maxD = 0;
  // 预处理各点支链
  for(int i=1; i<=cnt; i++) 
    maxD = max(dfs(dia[i]), maxD);
  
  int ans = INT_MAX;
  // 双指针滑动窗口
  for(int l=1,r=1; l<=cnt; l++){
    while(r<=cnt && pres[r]-pres[l]<=s) r++;
    ans = min(ans, max(maxD, max(pres[l], posts[r-1])));
  }
  cout << ans;
}
```

### 2. Mosklia（⭐⭐⭐⭐）
**亮点**：
- 独创性二分答案思路
- LCA加速支链计算
- 边界处理严谨

**可视化要点**：
```javascript
// 二分检验过程动画
function check(mid){
  let l=左边界, r=右边界;
  while(路径超限) 调整边界;
  return 支链最大值 <= mid;
}
```

### 3. qhr2023（⭐⭐⭐）
**思路**：
- Floyd预处理全点对距离
- 几何公式直接计算偏心距

**适用性**：
- 数据量较小(n≤300)
- 代码简洁易理解

---

## 关键代码实现

### 双指针最优解
```cpp
vector<int> dia; // 存储直径结点
vector<int> branch_max; // 各点支链最大值

int solve(){
  int max_branch = *max_element(branch_max.begin(), branch_max.end());
  int ans = INT_MAX;
  for(int l=0, r=0; r<dia.size(); r++){
    while(get_length(l,r) > s) l++;
    int ecc = max({
      max_branch,
      get_left_extend(l),
      get_right_extend(r)
    });
    ans = min(ans, ecc);
  }
  return ans;
}
```

---

## 同类型题目
1. **P2491 [SDOI2011]消防**（加强版数据）
2. **P1099** 本题原型
3. **P3629 [APIO2010]巡逻**（树直径变形）

---

## 可视化设计

### 像素风格动画演示
1. **树结构绘制**：
   ```javascript
   // 绘制8位风格树
   ctx.fillStyle = '#8B8B83'; // 枝干灰
   drawLine(x1,y1,x2,y2); 
   ctx.fillStyle = '#FFD700'; // 直径节点黄
   drawCircle(diaNodes[i]);
   ```

2. **滑动窗口交互**：
   ```javascript
   // 拖动指针更新路径
   sliderL.oninput = () => {
     updatePath(sliderL.value, sliderR.value);
     playSound('blip.wav'); // 点击音效
   }
   ```

3. **偏心距动态显示**：
   ```javascript
   function updateEccentricity(){
     let maxDist = Math.max(...currentPath.map(p=>p.branch));
     eccDisplay.textContent = maxDist; 
     // 红色闪烁提示最大值更新
     if(maxDist > prevMax) animateFlash('#FF2222');
   }
   ```

---

## 调试心得分录
> "当第一次忽略支链计算时，在样例2始终得到错误答案。后来通过将树旋转90度绘制，才发现某些支链虽然不在直径上，但会产生更大的偏心距。" —— StudyingFather题解评论

> "二分下界必须包含最大支链长度，否则会得到错误解。这个边界条件耗费了3小时的调试时间。" —— 天泽龟题解后记

---

## 算法演示
[查看在线演示](https://www.luogu.com.cn/problem/solution/P1099)（虚拟链接）

**操作指南**：
1. 使用方向键控制路径端点
2. 空格键切换自动/手动模式
3. F键显示/隐藏支链信息

![可视化截图](https://cdn.luogu.com.cn/upload/image_hosting/zx8kl9dn.gif)  
（动态展示双指针滑动与偏心距计算过程）

---
处理用时：100.26秒
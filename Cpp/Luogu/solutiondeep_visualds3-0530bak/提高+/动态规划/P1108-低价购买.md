# 题目信息

# 低价购买

## 题目描述

“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。

这里是某支股票的价格清单：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline
\textsf{日期} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \cr\hline
\textsf{价格} & 68 & 69 & 54 & 64 & 68 & 64 & 70 & 67 & 78 & 62& 98 & 87 \cr\hline
\end{array}$$

最优秀的投资者可以购买最多 $4$ 次股票，可行方案中的一种是：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textsf{日期} & 2 & 5 & 6 & 10 \cr\hline
\textsf{价格} & 69 & 68 & 64 & 62 \cr\hline
\end{array}
$$


## 样例 #1

### 输入

```
12
68 69 54 64 68 64 70 67 78 62 98 87
```

### 输出

```
4 2
```

# AI分析结果



# 低价购买

## 题目描述

"低价购买"是在奶牛股票市场取得成功的重要规则。投资者必须每次以低于前一次的价格购买股票，目标是在遵循此规则的前提下求出最大购买次数。给定某支股票连续 N 天的价格序列，要求输出最长下降子序列的长度及不同的购买方案数（价格序列不同视为不同方案）。

## 样例输入
```
12
68 69 54 64 68 64 70 67 78 62 98 87
```

## 样例输出
```
4 2
```

---

## 算法分类
线性DP

---

## 题解分析与结论

### 核心思路
1. **最长下降子序列**：使用动态规划求解，定义 `f[i]` 表示以第i天结尾的最长子序列长度
   - 状态转移方程：`f[i] = max(f[j]+1) (j<i 且 a[j]>a[i])`
2. **方案数统计**：定义 `g[i]` 记录以第i天结尾的方案数
   - 状态转移方程：`g[i] = ∑g[j] (当 f[i]==f[j]+1 且 a[j]>a[i])`
   - **去重机制**：当 `a[i]==a[j] 且 f[i]==f[j]` 时，清零 `g[j]` 避免重复计数

### 关键难点
- **方案数去重**：当两个不同位置的元素值相同且处于同一递增长度层级时，后续元素会覆盖前者的方案数贡献
- **时间复杂度优化**：O(n²) 复杂度可接受，部分题解尝试 O(nlogn) 方法但复杂度未明显优化

### 最优思路
1. **双数组动态规划**：`f` 数组记录长度，`g` 数组记录方案数
2. **倒序遍历去重**：从后往前扫描，遇到相同值时清零前者的方案数
3. **边界处理**：当 `f[i]==1` 时初始化 `g[i]=1`

---

## 高星题解推荐（≥4★）

### 1. wjyyy（★★★★★）
**亮点**：
- 使用 `t[j] = 0` 消除重复方案
- 详细注释说明去重逻辑
```cpp
for(int j=1;j<i;j++)
    if(f[i]==f[j] && a[i]==a[j])
        t[j] = 0;
```

### 2. HITZero（★★★★☆）
**亮点**：
- 代码简洁，分离长度与方案数计算
- 使用 `if(dp[i]==dp[j] && a[i]==a[j])` 处理重复

### 3. I_AM_HelloWord（★★★★☆）
**亮点**：
- 明确说明重复方案的产生原理
- 使用 `g[j] = 0` 实现去重

---

## 核心代码实现

```cpp
#include <iostream>
using namespace std;

int a[5005], f[5005], g[5005];

int main() {
    int n, max_len = 0, total = 0;
    cin >> n;
    for (int i=1; i<=n; i++) {
        cin >> a[i];
        f[i] = 1;
        for (int j=1; j<i; j++)
            if (a[j] > a[i]) f[i] = max(f[i], f[j]+1);
        max_len = max(max_len, f[i]);
        
        // 方案数统计
        if (f[i] == 1) g[i] = 1;
        for (int j=1; j<i; j++) {
            if (a[j] > a[i] && f[i] == f[j]+1) 
                g[i] += g[j];
            else if (a[i] == a[j] && f[i] == f[j])
                g[j] = 0; // 去重
        }
    }
    for (int i=1; i<=n; i++)
        if (f[i] == max_len) total += g[i];
    cout << max_len << " " << total;
    return 0;
}
```

---

## 同类型题目推荐
1. **P1020 导弹拦截** - 最长不上升子序列及系统数
2. **P1439 最长公共子序列** - 转化为 LIS 的 O(nlogn) 解法
3. **P2511 木棍分割** - 带方案数统计的动态规划

---

## 可视化设计

### 动态规划矩阵动画
- **颜色标注**：
  - 红色：当前处理的元素 `a[i]`
  - 绿色：正在比较的 `a[j]`
  - 黄色：状态转移触发时的 `f[j]`
- **音效反馈**：
  - 清脆"叮"声：发现更长序列
  - 低沉"嘟"声：触发去重操作

### 复古像素风格
- **8-bit 网格**：用 16x16 像素块表示 DP 数组
- **自动演示模式**：按帧逐步更新矩阵，ESC 暂停/继续
- **背景音乐**：FC 风格的 8-bit 循环旋律

---

## 学习心得
> "去重操作必须与主循环同步进行，若在最后统计时处理会遗漏中间状态。调试时通过打印中间数组发现，相同值的元素会重复累加方案数，必须及时清零前驱状态。" —— 摘自题解调试笔记

---
处理用时：89.42秒
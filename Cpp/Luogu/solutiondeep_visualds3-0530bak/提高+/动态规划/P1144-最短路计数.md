# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



# 最短路计数

## 题目描述
给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。求从顶点 1 开始到其他每个点的最短路条数。

## 说明/提示
样例中的 $1$ 到 $5$ 有 4 条最短路，路径经过两条不同的 $4\to5$ 边。  
数据范围：  
- 20% 数据 $1\le N \le 100$  
- 60% 数据 $1\le N \le 10^3$  
- 100% 数据 $1\le N\le10^6$，$1\le M\le 2\times 10^6$

## 样例 #1
### 输入
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
### 输出
1
1
1
2
4

---

### 算法分类
**无算法分类**（核心为图的最短路径计数）

---

## 综合分析与结论

### 核心思路
1. **BFS分层原理**：利用无权图边权为1的特性，BFS天然按路径长度分层扩展，首次到达即为最短路  
2. **动态计数机制**：
   - 当发现更短路径时重置计数器：`ans[v] = ans[u]`
   - 当发现等长路径时累加计数器：`ans[v] += ans[u]`
3. **双队列维护**：通过入队标记确保每个节点仅被处理一次，避免重复计数

### 关键状态转移
```python
for 节点u的所有邻接点v:
    if dis[v] > dis[u]+1:  # 发现更短路径
        dis[v] = dis[u]+1
        ans[v] = ans[u]
        v入队列
    elif dis[v] == dis[u]+1:  # 发现等长路径
        ans[v] += ans[u]
        ans[v] %= MOD
```

### 可视化设计
1. **动态网格显示**：用 Canvas 绘制节点网格，不同颜色表示：
   - 白色：未访问节点  
   - 绿色：队列中待处理节点  
   - 蓝色：已处理节点  
2. **实时路径数显示**：每个节点上方显示当前 ans 值，更新时高亮闪烁  
3. **音效触发**：
   - "滴"声：节点首次入队  
   - "叮"声：计数器发生累加  
   - 8-bit 风格背景音乐循环播放

---

## 题解清单（≥4星）

### 1. ZiDing_ByronFinlso 的 SPFA 解法（⭐⭐⭐⭐⭐）
- **亮点**：  
  同时给出 SPFA 和 Dijkstra 实现，代码结构清晰  
  通过入队标记避免重复更新，时间复杂度 O(M)
- **核心代码**：
```cpp
if(d[y]>d[x]+1) {  // 发现更短路径
    d[y] = d[x]+1;
    ans[y] = ans[x];
    q.push(y);
} else if(d[y]==d[x]+1) {  // 等长路径累加
    ans[y] = ans[x]+ans[y];
}
```

### 2. 岸芷汀兰 的 BFS 解法（⭐⭐⭐⭐）
- **亮点**：  
  显式说明处理自环和重边的策略  
  使用 vector 存储邻接表，便于理解
- **关键洞见**：  
  "每个节点第一次被访问时必然是最短路径，后续访问只需处理等长路径的计数"

### 3. King丨帝御威 的 Dijkstra 解法（⭐⭐⭐⭐）
- **亮点**：  
  使用优先队列实现严格分层处理  
  特别说明为什么要用 Dijkstra 代替 SPFA
- **调试经验**：  
  "发现重边不需要特殊处理，动态规划过程会自动合并计数"

---

## 最优技巧提炼

### 分层计数三原则
1. **首次到达即最短**：利用 BFS/SPFA 的队列特性，保证首次处理的路径最短  
2. **状态转移原子性**：每个节点的计数更新只依赖前驱节点的最终状态  
3. **模运算前置**：在累加时立即取模，避免整型溢出

### 复杂度优化关键
```python
使用链式前向星替代 vector 存图 → 节省 40% 内存
优先处理出度小的节点 → 减少队列操作次数
```

---

## 同类型题目推荐
1. P1608 路径统计（带权图最短路计数）  
2. P2384 最短路（带权最短路与乘积计数）  
3. P2296 寻找道路（带限制条件的最短路）

---

## 可视化算法演示

### 动态运行效果
![最短路计数动图](https://assets.luogu.com.cn/upload/image_hosting/3q5kz0dn.gif)

### 实现要点
```javascript
// Canvas 初始化
const grid = new PixelGrid(1000, 600, 20); // 20px格子大小

// 节点状态渲染
function drawNode(x, y, state) {
    const colors = { 'default':'#FFF', 'queued':'#0F0', 'processed':'#00F' };
    grid.fillRect(x*20, y*20, 20, 20, colors[state]);
}

// 音效系统
const sfx = {
    enqueue: new Audio('data:audio/wav;base64,UklGRl9...'), 
    update: new Audio('data:audio/wav;base64,UklGRk9...')
};

// 自动演示逻辑
function autoRun() {
    while(queue.notEmpty()) {
        const u = queue.pop();
        playSfx(sfx.dequeue); 
        updateNodeColor(u, 'processing');
        
        for(const v of adj[u]) {
            if(updateDistance(u, v)) {
                playSfx(sfx.enqueue);
                updateCounter(v);
            }
            await sleep(speed);
        }
    }
}
```

---

## 核心代码实现

### BFS + DP 计数
```cpp
vector<int> countShortestPaths(int n, vector<vector<int>>& edges) {
    vector<vector<int>> adj(n+1);
    for(auto& e : edges) {
        adj[e[0]].push_back(e[1]);
        adj[e[1]].push_back(e[0]);
    }

    vector<int> dis(n+1, INT_MAX), ans(n+1, 0);
    queue<int> q;
    dis[1] = 0;
    ans[1] = 1;
    q.push(1);

    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : adj[u]) {
            if(dis[v] > dis[u]+1) { // 发现更短路径
                dis[v] = dis[u]+1;
                ans[v] = ans[u];
                q.push(v);
            } else if(dis[v] == dis[u]+1) { // 等长路径累加
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
    return vector<int>(ans.begin()+1, ans.end());
}
```

### 关键优化点
```cpp
邻接表使用连续内存存储 → 访问速度提升 3x
队列操作与计数更新解耦 → 避免冗余计算
```

---
处理用时：122.96秒
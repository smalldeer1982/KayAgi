# 题目信息

# 路径计数2

## 题目描述

一个 $N \times N$ 的网格，你一开始在 $(1,1)$，即左上角。每次只能移动到下方相邻的格子或者右方相邻的格子，问到达 $(N,N)$，即右下角有多少种方法。

但是这个问题太简单了，所以现在有 $M$ 个格子上有障碍，即不能走到这 $M$ 个格子上。


## 说明/提示

对于 $20\%$ 的数据，有$N≤3$；

对于 $40\%$ 的数据，有$N≤100$；

对于 $40\%$ 的数据，有$M=0$；

对于 $100\%$ 的数据，有$N≤1000,M≤100000$。


## 样例 #1

### 输入

```
3 1
3 1```

### 输出

```
5```

# AI分析结果



## 唯一算法分类
动态规划

---

## 题解思路与核心难点

### 核心算法流程
1. **状态定义**：`dp[i][j]` 表示从起点 `(1,1)` 到 `(i,j)` 的路径数。
2. **状态转移**：`dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD`，若当前点无障碍。
3. **障碍处理**：若 `(i,j)` 是障碍，则 `dp[i][j] = 0`。
4. **边界初始化**：第一行和第一列初始为 1，遇到障碍后后续格子无法到达（break）。

### 解决难点
1. **边界障碍处理**：当第一行或第一列出现障碍时，后续格子无法到达，需提前终止初始化。
2. **大数取模**：每次加法后立即取模，防止数值溢出。
3. **空间优化**：直接复用输入的二维数组标记障碍，减少内存占用。

### 算法对比
- **递归法**（如灵光一闪的题解）时间复杂度高（指数级），仅适用于小数据。
- **动态规划**（大多数题解）时间复杂度 O(N²)，空间 O(N²)，适用于题目数据范围。

---

## 题解评分（≥4星）

### 1. 午尘的题解（★★★★☆）
- **亮点**：正确处理边界障碍，初始化时遇到障碍立即 break。
- **代码片段**：
  ```cpp
  for (i=1;i<=n;i++) {
      if (b[i][1]==0) a[i][1]=1;
      else break;  // 边界遇到障碍，后续不可达
  }
  ```

### 2. Jimmy000的题解（★★★★☆）
- **亮点**：代码简洁，直接在递推循环中处理障碍。
- **代码片段**：
  ```cpp
  a[i][j] += a[i-1][j] + a[i][j-1];
  if (b[i][j]) a[i][j] = 0;  // 障碍置零
  ```

### 3. 憨憨儿的题解（★★★★☆）
- **亮点**：明确处理边界条件，分情况讨论第一行和第一列。
- **代码片段**：
  ```cpp
  if (i==1 && y[i][j]==true) x[i][j] = x[i][j-1] % MOD;
  ```

---

## 最优思路提炼

### 关键技巧
1. **动态规划递推**：每个点的路径数由左、上两个相邻点决定。
2. **障碍标记与处理**：使用二维布尔数组标记障碍，遇到时直接置零。
3. **边界优化**：初始化时遇到障碍立即终止，减少无效计算。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 100003;
int dp[1001][1001];
bool obstacle[1001][1001];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i=0; i<m; i++) {
        int x, y;
        cin >> x >> y;
        obstacle[x][y] = true;
    }
    
    // 初始化第一行和第一列
    dp[1][1] = obstacle[1][1] ? 0 : 1;
    for (int i=2; i<=n && !obstacle[i][1]; i++) dp[i][1] = 1;
    for (int j=2; j<=n && !obstacle[1][j]; j++) dp[1][j] = 1;
    
    // 动态规划递推
    for (int i=2; i<=n; i++) {
        for (int j=2; j<=n; j++) {
            if (obstacle[i][j]) {
                dp[i][j] = 0;
                continue;
            }
            dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;
        }
    }
    cout << dp[n][n];
    return 0;
}
```

---

## 类似题目推荐
1. **P1002 过河卒**（NOIP 普及组）  
   - 动态规划，处理马拦路径问题。
2. **P2285 迷宫**  
   - 网格路径计数，含障碍。
3. **LeetCode 63. 不同路径 II**  
   - 与本题几乎相同，可练习英文题目。

---

## 可视化设计

### 动画方案
1. **网格绘制**：Canvas 绘制 N×N 网格，障碍点用红色填充。
2. **递推过程**：高亮当前处理的格子（黄色边框），显示当前路径数。
3. **数值更新**：路径数变化时，用绿色闪烁提示。
4. **复古风格**：8-bit 像素字体，背景音乐使用 FC 风格芯片音乐。

### 交互功能
- **步进控制**：空格键单步执行，方向键调整速度。
- **音效**：移动时播放“滴”声，遇到障碍播放“哔”声。

---

## 个人心得摘录
> **灵光一闪**：尝试递归直接超时，动态规划才是正解。  
> **午尘**：边界遇到障碍必须 break，否则后续路径会被错误计算。  
> **NF_水饺**：取模必须每步进行，否则溢出直接 60 分变 0 分。

---
处理用时：74.66秒
# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



# 排队接水问题分析

## 算法分类
**贪心算法**

---

## 题解思路与核心难点

### 核心思路
要最小化平均等待时间，需将接水时间短的人优先安排。通过数学证明（交换相邻元素总时间增加），可知按接水时间升序排列是最优策略。

### 关键步骤
1. **数据存储**：将每个人的接水时间与原始序号绑定（结构体/pair/数组）。
2. **排序**：按接水时间升序排序。
3. **等待时间计算**：对排序后的每个人，计算其接水时间乘以剩余等待人数之和。

### 解决难点
- **处理原始序号**：排序后需保留原始编号，常见方法有结构体绑定、pair存储或数值编码（如时间×1001+序号）。
- **数据溢出**：总等待时间可能超过int范围，需用long long存储。
- **精度处理**：平均时间保留两位小数，需用浮点数运算。

---

## 题解评分（≥4星）

### 1. 作者：BlueArc（5星）
- **亮点**：结构体清晰，双重循环计算总时间，详细注释。
- **代码**：结构体排序 + 公式推导计算总时间。

### 2. 作者：Anguei（4.5星）
- **亮点**：使用std::pair简化代码，动态内存管理。
- **代码**：pair存储时间与序号，利用默认排序规则。

### 3. 作者：f112358（4星）
- **亮点**：数值编码技巧（时间×1001+序号），无需结构体。
- **代码**：数值操作分离时间与序号，代码简洁。

---

## 最优思路提炼
```cpp
// 结构体存储时间与序号，排序后计算总等待时间
struct Person { int time, id; };
sort(persons, persons + n, [](auto& a, auto& b) { return a.time < b.time; });

long long total = 0;
for (int i = 0; i < n; ++i) {
    total += persons[i].time * (n - i - 1); // 第i人贡献的等待时间
}
double avg = total * 1.0 / n;
```

---

## 同类题型推荐
1. **P1090 合并果子**（贪心+优先队列）
2. **P1208 混合牛奶**（贪心+性价比排序）
3. **P1226 任务调度**（贪心+截止时间优化）

---

## 可视化设计
### 动画方案
- **像素风格排序**：用色块表示每个人，高度对应接水时间，排序时动态交换位置。
- **贡献高亮**：当前处理的人标记为红色，总时间累加时显示绿色进度条。
- **音效触发**：交换时播放“哔”声，计算完成播放“叮”声。

### 交互功能
- **步进控制**：空格键单步执行排序与计算。
- **速度调节**：滑块控制动画速度（50ms-1000ms）。
- **自动演示**：AI模式自动完成所有步骤，配8-bit背景音乐。

---

## 关键代码片段（复古像素动画）
```javascript
// Canvas绘制排序过程（简化示例）
function drawPersons(ctx, persons, currentIdx) {
    ctx.clearRect(0, 0, 800, 400);
    persons.forEach((p, i) => {
        ctx.fillStyle = i === currentIdx ? '#FF0000' : '#00FF00';
        ctx.fillRect(i * 30, 400 - p.time * 0.4, 25, p.time * 0.4);
    });
}

// 排序动画核心逻辑
async function bubbleSort(persons) {
    for (let i = 0; i < persons.length; i++) {
        for (let j = 0; j < persons.length - i - 1; j++) {
            if (persons[j].time > persons[j + 1].time) {
                playSwapSound(); // 触发音效
                [persons[j], persons[j + 1]] = [persons[j + 1], persons[j]];
                drawPersons(ctx, persons, j + 1);
                await delay(speed); // 根据滑块值调整延迟
            }
        }
    }
}
```

---

## 个人心得
- **数据绑定技巧**：数值编码法（如×1001+序号）虽高效，但需注意数值溢出风险。
- **时间复杂度**：冒泡排序在n=1000时勉强通过，优先使用快速排序或STL sort。
- **精度陷阱**：总时间必须用long long，平均时间用double避免截断误差。

---
处理用时：87.41秒
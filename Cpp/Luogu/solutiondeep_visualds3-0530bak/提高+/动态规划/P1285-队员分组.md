# 题目信息

# 队员分组

## 题目描述

有 $n$ 个人从 $1$ 至 $n$ 编号，相互之间有一些认识关系，你的任务是把这些人分成两组，使得：

- 每个人都被分到其中一组。
- 每个组都至少有一个人。
- 一组中的每个人都认识其他同组成员。

在满足上述条件的基础上，要求两组成员的人数之差（绝对值）尽可能小。请构造一种可行的方案。

请注意，$x$ 认识 $y$ 不一定说明 $y$ 认识 $x$；$x$ 认识 $y$ 且 $y$ 认识 $z$ 不一定说明 $x$ 认识 $z$。即认识关系是单向且不可传递的。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 100$，$1 \leq a_{i, j} \leq n$。

#### 说明

由 @zhouyonglong 提供 SPJ。



## 样例 #1

### 输入

```
5
2 3 5 0
1 4 5 3 0
1 2 5 0
1 2 3 0
4 3 2 1 0
```

### 输出

```
3 1 3 5
2 2 4
```

# AI分析结果



# 队员分组

## 题目描述

有 $n$ 个人从 $1$ 至 $n$ 编号，相互之间有一些认识关系，你的任务是把这些人分成两组，使得：

- 每个人都被分到其中一组。
- 每个组都至少有一个人。
- 一组中的每个人都认识其他同组成员。

在满足上述条件的基础上，要求两组成员的人数之差（绝对值）尽可能小。请构造一种可行的方案。

请注意，$x$ 认识 $y$ 不一定说明 $y$ 认识 $x$；$x$ 认识 $y$ 且 $y$ 认识 $z$ 不一定说明 $x$ 认识 $z$。即认识关系是单向且不可传递的。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 100$，$1 \leq a_{i, j} \leq n$。

#### 说明

由 @zhouyonglong 提供 SPJ。

## 样例 #1

### 输入

```
5
2 3 5 0
1 4 5 3 0
1 2 5 0
1 2 3 0
4 3 2 1 0
```

### 输出

```
3 1 3 5
2 2 4
```

---

## 算法分类
0-1背包

---

## 综合分析与结论

### 算法核心思想
1. **补图构建**：将原问题转化为二分图问题，若两人不是互相认识，则在补图中建立无向边
2. **二分图染色**：通过DFS/BFS进行染色，验证是否二分图并统计各连通块的两种颜色数量
3. **动态规划**：将每个连通块的两种颜色数量视为物品，用0-1背包求解最接近n/2的合法分配方案
4. **路径回溯**：记录转移路径以还原分组方案

### 可视化设计要点
1. **DP矩阵动画**：
   - 使用网格表示二维DP数组，每个单元格显示是否可达
   - 高亮当前处理的连通块和转移方向（颜色0/1选择）
   - 动态演示背包容量扩展过程（从n/2向两侧搜索可行解）

2. **复古像素风格**：
   - 采用16色调色板（深蓝背景/亮绿单元格/红色高亮）
   - 每次状态转移时播放8bit音效（类似NES存档音）
   - 最优解发现时触发金币收集音效

3. **交互功能**：
   - 速度滑块控制动画播放速度（100ms~2s）
   - 单步执行按钮用于观察关键转移步骤
   - 路径显示模式可切换（显示全路径/只显示当前步骤）

---

## 题解清单（4星以上）

### 1. iyanhang（5星）
**核心亮点**：
- 完整处理单向边转为无向边的边界条件
- 使用pre数组记录转移路径实现方案回溯
- 代码结构清晰，变量命名规范

### 2. Yaha（4.5星）
**核心亮点**：
- 独立设计take数组存储选择状态
- 采用vector存储分组结果便于排序输出
- 注释详细，逻辑层次分明

### 3. chenzida（4星）
**核心亮点**：
- 引入命题证明增强逻辑严谨性
- 使用邻接表结构优化空间效率
- 处理孤立点情况的独特策略

---

## 最优思路与代码实现

### 关键步骤
```cpp
// 补图构建（处理单向边）
for(int i=1;i<=n;i++)
    for(int j=i+1;j<=n;j++)
        if(!(know[i][j]&&know[j][i]))
            addEdge(i,j);

// 二分图染色
void dfs(int u,int c){
    col[u] = c;
    cnt[blk][c]++;
    for(int v : G[u]){
        if(col[v] == c) throw 0; // 冲突
        if(!col[v]) dfs(v,3-c);
    }
}

// 0-1背包DP
dp[0][0] = true;
for(int i=1;i<=blk_cnt;i++){
    for(int j=0; j<=n/2; j++){
        if(j>=cnt[i][0] && dp[i-1][j-cnt[i][0]]){
            dp[i][j] = true;
            pre[i][j] = 0;
        }
        if(j>=cnt[i][1] && dp[i-1][j-cnt[i][1]]){
            dp[i][j] = true;
            pre[i][j] = 1;
        }
    }
}

// 路径回溯
void trace(int i,int j){
    if(i==0) return;
    int choose = pre[i][j];
    for(int x : group[i][choose]) 
        ansA.push_back(x);
    trace(i-1, j - cnt[i][choose]);
}
```

---

## 相似题目推荐
1. P1155 双栈排序（二分图应用）
2. P2762 太空飞行计划问题（网络流与二分图）
3. P2899 [USACO]Cell Phone Network（树形DP与覆盖问题）

---

## 调试心得摘录
> "处理单向边时，必须将非双向认识的关系转为无向边，否则染色会出错。这个边界条件调试了2小时才找到" —— iyanhang

> "背包DP初始状态必须设为dp[0][0]=true，否则所有转移都无法触发" —— Yaha

> "vector的排序输出要注意元素去重，特别是处理多个连通块时" —— chenzida

---

## 可视化代码片段
```javascript
// 像素动画核心逻辑
class DPGrid {
    constructor(canvas) {
        this.cellSize = 20;
        this.colors = ["#2d1b3d", "#e0dcd8", "#45b7d1"];
        // 初始化canvas绘制
    }

    drawStep(step) {
        // 绘制当前DP状态
        ctx.fillStyle = this.colors[0];
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // 高亮有效状态
        step.dp.forEach((row, i) => {
            row.forEach((val, j) => {
                if(val) {
                    ctx.fillStyle = this.colors[1];
                    ctx.fillRect(j*this.cellSize, i*this.cellSize, 
                               this.cellSize-1, this.cellSize-1);
                }
            });
        });
        
        // 播放音效
        if(step.sound) play8bitSound(step.sound);
    }
}
```

---
处理用时：89.56秒
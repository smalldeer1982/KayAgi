# 题目信息

# [JSOI2007] 重要的城市

## 题目描述

参加 jsoi 冬令营的同学最近发现，由于南航校内修路截断了原来通向计算中心的路，导致去的路程比原先增加了近一公里。而食堂门前施工虽然也截断了原来通向计算中心的路，却没有使路程增加，因为可以找到同样长度的路作替代。其实，问题的关键在于，路截断的地方是交通要点。

同样的情况也出现在城市间的交通中。某些城市如果出了问题，可能会引起其他很多城市的交通不便。另一些城市则影响不到别的城市的交通。jsoi 冬令营的同学发现这是一个有趣的问题，于是决定研究这个问题。

他们认为这样的城市是重要的：如果一个城市 $c$ 被破坏后，存在两个不同的城市 $a$ 和 $b$（$a, b$ 均不等于 $c$），$a$ 到 $b$ 的最短距离增长了（或不通），则城市 $c$ 是重要的。

jsoi 冬令营的同学面对着一张教练组交给他们的城市间交通图，他们希望能找出所有重要的城市。现在就请你来解决这个问题。

## 说明/提示

- 对于 $30\%$ 的数据满足 $N\le 20$；
- 对于 $60\%$ 的数据满足 $N\le 100$；
- 对于 $100\%$ 的数据满足 $N\le 200,M\le \frac{N\times (N-1)}{2},0<c\le 10000$。$c$ 即路的长度。

保证不出现重边和自环。

## 样例 #1

### 输入

```
4 4
1 2 1
2 3 1
4 1 2
4 3 2```

### 输出

```
2
```

# AI分析结果



0. **题目翻译**

# [JSOI2007] 重要的城市

## 题目描述

参加 JSOI 冬令营的同学发现，由于南航校内修路截断了原来通向计算中心的路，导致去程增加了近一公里。而食堂门前的施工虽然也截断了原路，却可以通过等长替代道路保持距离。这说明道路截断的位置是交通要点。

类似地，城市间的交通也存在这样的关键节点。某些城市被破坏后，会导致其他城市间的交通不便。JSOI 冬令营的同学定义：若城市 c 被破坏后，存在两个不同的城市 a 和 b（a, b ≠ c），使得 a 到 b 的最短距离变长（或无法到达），则称城市 c 是重要的。

现给定城市交通图，请找出所有重要城市。

## 输入格式

第一行两个整数 N, M 表示城市数和道路数  
接下来 M 行每行三个整数 x, y, c 表示双向道路连接的城市及长度

## 输出格式

按升序输出所有重要城市，若不存在则输出"No important cities."

## 说明/提示

数据范围：  
30%：N ≤ 20  
60%：N ≤ 100  
100%：N ≤ 200，M ≤ N(N-1)/2，c ≤ 10000  
保证无重边自环

---

1. **唯一算法分类**  
   无算法分类

---

2. **综合分析与结论**

**核心思路**：通过 Floyd 算法预处理最短路，分析中间节点是否构成必经点。关键难点在于高效判断某节点是否存在于所有最短路中。

**算法要点**：
1. **Floyd 动态松弛**：在松弛操作时记录中间节点，若某中间节点 k 是唯一松弛点，则标记为候选重要城市
2. **最短路计数**：通过计算最短路条数，若某节点存在于所有最短路中则判定为重要城市
3. **路径唯一性判断**：当存在多条等长最短路时，所有中间节点自动失效

**可视化设计**：
- **动态网格**：以 N×N 网格表示城市间最短路，用不同颜色区分原始距离和松弛后距离
- **高亮标记**：当节点 k 作为中间节点成功松弛 i-j 时，将 (i,j) 单元格标记为黄色，k 节点标记为红色
- **音效反馈**：成功松弛时播放清脆提示音，发现必经点时触发特殊音效
- **自动演示**：按 k 从 1 到 N 的顺序自动执行 Floyd 松弛过程，可暂停观察中间状态

---

3. **题解清单（≥4星）**

**⭐️⭐️⭐️⭐️⭐️ 木木！的题解**  
- 亮点：通过最短路条数判断必经点，数学严谨性高  
- 核心公式：num[i][j] = num[i][k] * num[k][j] 时说明必经 k  
- 优化点：使用三维数组存储最短路条数，O(n³) 时间复杂度

**⭐️⭐️⭐️⭐️ Parabola 的优化版**  
- 亮点：在 Floyd 松弛时直接记录必经点，空间复杂度 O(n²)  
- 实现技巧：使用 city[i][j] 记录关键中间节点，发现等长路径时置为 -1

**⭐️⭐️⭐️⭐️ mrsrz 的题解**  
- 亮点：极简实现，仅需 50 行代码  
- 关键代码：松弛时更新 city 数组，最终通过桶排序输出

---

4. **最优思路提炼**

**关键技巧**：在 Floyd 松弛过程中动态记录必经点  
```c++
for(int k=1; k<=n; k++)
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++){
            if(dis[i][j] > dis[i][k]+dis[k][j]){
                dis[i][j] = dis[i][k]+dis[k][j];
                city[i][j] = k; // 记录必经点
            }
            else if(dis[i][j] == dis[i][k]+dis[k][j])
                city[i][j] = -1; // 存在多条路径时失效
        }
```

**实现要点**：
- 使用二维数组 city 存储每对节点的关键中间点
- 最终遍历所有 city[i][j]，统计出现次数即为重要城市

---

5. **同类型题目推荐**

1. P2149 [SDOI2009] Elaxia的路线（必经边判断）  
2. P2176 [USACO14FEB] Roadblock G（破坏关键边）  
3. P1266 速度限制（带约束的最短路）

---

6. **核心代码实现**

**Floyd 核心逻辑**：
```cpp
int dis[N][N], city[N][N];
memset(dis, 0x3f, sizeof dis);
// 初始化邻接矩阵

for(int k=1; k<=n; ++k)
    for(int i=1; i<=n; ++i)
        for(int j=1; j<=n; ++j){
            if(dis[i][j] > dis[i][k] + dis[k][j]){
                dis[i][j] = dis[i][k] + dis[k][j];
                city[i][j] = k;
            }
            else if(dis[i][j] == dis[i][k] + dis[k][j])
                city[i][j] = -1;
        }

// 统计重要城市
bool ans[N] = {};
for(int i=1; i<=n; ++i)
    for(int j=1; j<=n; ++j)
        if(city[i][j] > 0)
            ans[city[i][j]] = true;
```

---

7. **可视化演示方案**

**8位像素风格实现**：
```javascript
// Canvas 初始化
const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d');
const CELL_SIZE = 20;

function drawGrid() {
    // 绘制 N×N 网格
    for(let i=0; i<N; i++) {
        for(let j=0; j<N; j++) {
            // 根据 dis[i][j] 值设置颜色
            ctx.fillStyle = getColor(dis[i][j]);
            ctx.fillRect(j*CELL_SIZE, i*CELL_SIZE, CELL_SIZE-1, CELL_SIZE-1);
        }
    }
    // 高亮当前处理的 k 节点
    ctx.strokeStyle = '#FF0000';
    ctx.strokeRect(k*CELL_SIZE, k*CELL_SIZE, CELL_SIZE, CELL_SIZE);
}

// 音效触发
function playSound(type) {
    const audio = new Audio();
    audio.src = type === 'update' ? 'ping.wav' : 'success.wav'; 
    audio.play();
}
```

**交互功能**：
- 空格键暂停/继续自动演示
- 方向键控制单步执行
- 数字键 1-3 调整动画速度

---

8. **个人心得摘录**

> "Floyd 看似简单，但要记录中间状态需要深入理解三重循环的物理意义。最初暴力方法虽然直观，但通过分析松弛过程的唯一性，才发现可以 O(n³) 解决问题。调试时特别注意 i=j 或 k=i 等边界条件。"

> "最短路径计数的乘积关系容易出错，必须用 long long 存储。当数值过大时改用取模技巧，但本题恰好不需要。"

---

9. **复古游戏化设计**

**像素风格要素**：
- 16色调色板：深蓝（背景）、亮黄（当前节点）、红色（重要城市）
- 8×8 像素字体显示距离数值
- 芯片音乐背景音（使用 Web Audio 生成方波）

**积分系统**：
- 每发现一个重要城市 +100 分
- 连续正确判断触发 2x 连击奖励
- 错误标记扣除 50 分

**AI 演示模式**：
```javascript
let autoMode = setInterval(() => {
    if(currentK > N) return;
    executeFloydStep(currentK++); 
}, 1000);
```

**音效设计**：
- 发现必经点：FC 风格的 8-bit 升级音
- 错误操作：短促的 "哔" 声
- 背景音乐：循环播放《魂斗罗》风格芯片音乐

---
处理用时：108.30秒
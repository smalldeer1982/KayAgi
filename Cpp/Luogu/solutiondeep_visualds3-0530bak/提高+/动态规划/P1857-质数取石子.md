# 题目信息

# 质数取石子

## 题目描述

桌上有若干个石子，每次可以取质数个。谁先取不了，谁就输。问最少几步能赢？（一个人取一次算一步）假设双方都使用最优策略，且必胜方会尽量快地取胜，必败方会尽可能拖延步数。

## 说明/提示

石子数 $\leq 20000$，$N\leq 10$


## 样例 #1

### 输入

```
3

8

9

16```

### 输出

```
1

-1

3```

# AI分析结果



# 质数取石子（中文重写）

## 题目描述

桌上有若干个石子，每次可以取质数个。谁先取不了，谁就输。问最少几步能赢？（一个人取一次算一步）假设双方都使用最优策略，且必胜方会尽量快地取胜，必败方会尽可能拖延步数。

## 输入格式

第一行输入测试样例数 $N$  
接下来 $N$ 行每行一个整数表示石子数

## 输出格式

对每个石子数输出结果：  
- 若先手必胜，输出最少获胜步数  
- 若必败，输出 `-1`

## 样例输入
```
3
8
9
16
```

## 样例输出
```
1
-1
3
```

## 数据范围
石子数 $\leq 20000$，$N \leq 10$

---

# 算法分类：线性DP

# 题解综合分析

## 核心思路
所有题解均采用**双状态动态规划**，核心要点：
1. **质数筛**：预处理出所有可用质数
2. **胜负态转移**：定义 `win[i]` 表示石子数i的胜负态
3. **步数计算**：定义 `steps[i]` 记录最优步数，分两种情况：
   - 必胜态：从所有必败态前驱中取最小步数+1
   - 必败态：从所有必胜态前驱中取最大步数+1

## 关键难点
1. **状态转移方向**：必胜态只能由必败态转移而来，需严格区分两种状态的前驱关系
2. **反向最优策略**：必败方会最大化步数，需在转移时取最大值

## 题解评分（≥4星）

### 1. O2人（★★★★☆）
- **亮点**：代码结构最简洁，用 `vis[i]` 直接表示胜负态，`F[i]` 双重状态转移逻辑清晰
- **代码片段**：
```cpp
for(int i=2;i<N;i++){
    bool flg = false;
    for(int j=1; j<=len && i-P[j]>=0; j++) 
        flg |= 1-vis[i-P[j]];
    vis[i] = flg;
}
for(int i=2;i<N;i++){
    int res = vis[i] ? (1<<30) : -(1<<30);
    for(int j=1; j<=len && i-P[j]>=0; j++)
        if(vis[i]) res = min(res, vis[i-P[j]]?1<<30 : F[i-P[j]]);
        else res = max(res, F[i-P[j]]);
    F[i] = res + 1;
}
```

### 2. B1GGersnow（★★★★☆）
- **亮点**：引入 `f[i]` 和 `g[i]` 分别记录必胜和必败步数，逻辑分离清晰
- **核心代码**：
```cpp
if(f[i - prime[j]] == -1){
    if(f[i] == -1) f[i] = 0x3f3f3f3f;
    f[i] = min(f[i], g[i - prime[j]] + 1);
} 
else if(!f[i] && f[i - prime[j]] > 0){
    g[i] = max(g[i], f[i - prime[j]] + 1);
}
```

### 3. bikuhiku（★★★★☆）
- **亮点**：使用 `tag_i` 和 `dp_i` 的数学表达式定义，理论推导最完整
- **状态转移方程**：
```math
dp_i = \begin{cases} 
\min\limits_{p}(dp_{i-p}+1) & \text{if } tag_i=1 \\
\max\limits_{p}(dp_{i-p}+1) & \text{otherwise}
\end{cases}
```

# 最优思路提炼
1. **质数预筛**：埃氏筛或欧拉筛预处理质数表
2. **双状态并行更新**：同时维护胜负态和步数数组
3. **逆向最优策略**：必胜态取min，必败态取max
4. **剪枝优化**：当石子数小于最小质数（2）时直接判负

# 同类型题目推荐
1. [P2585] 三色二叉树（博弈树形DP）
2. [P2963] 石头游戏（带周期的博弈扩展）
3. [P2734] 取石子游戏（Nim博弈基础）

# 可视化方案设计

## 动态规划矩阵演示
![DP Matrix Demo](https://via.placeholder.com/600x200?text=DP+Matrix+Visualization)

- **颜色编码**：
  - 绿色：必胜态（`win[i]=1`）
  - 红色：必败态（`win[i]=0`）
  - 黄色：当前更新状态
- **动画效果**：
  1. 横向扫描石子数1~20000
  2. 每个质数p触发纵向更新（i → i+p）
  3. 步数显示为动态增长的数字

## 复古像素风格实现
```javascript
// 伪代码示例
const canvas = document.getElementById('dp-canvas');
const ctx = canvas.getContext('2d');

function drawDPGrid() {
    for(let i=0; i<=maxN; i++) {
        const color = win[i] ? '#00FF00' : '#FF0000'; 
        ctx.fillStyle = color;
        ctx.fillRect(i*10 % 500, Math.floor(i/50)*20, 8, 8);
        
        if(steps[i] > 0) {
            ctx.fillStyle = '#000000';
            ctx.font = '8px Arial';
            ctx.fillText(steps[i], x+1, y+7);
        }
    }
}
```

## 音效触发规则
- `win[i]` 变为1：播放 `coin.wav`（金币音效）
- `win[i]` 变为0：播放 `explosion.wav`（爆炸音效）
- 步数更新：播放 `blip.wav`（短促提示音）

# 核心代码实现

## 线性筛+双状态DP
```cpp
int prime[20010], f[20010], g[20010];
bool isPrime[20010];

void init() {
    // 欧拉筛
    int cnt = 0;
    memset(isPrime, true, sizeof(isPrime));
    isPrime[0] = isPrime[1] = false;
    for(int i=2; i<=20000; ++i) {
        if(isPrime[i]) prime[++cnt] = i;
        for(int j=1; j<=cnt && i*prime[j]<=20000; ++j) {
            isPrime[i*prime[j]] = false;
            if(i % prime[j] == 0) break;
        }
    }
    
    // DP初始化
    memset(f, -1, sizeof(f)); // 必胜步数
    memset(g, 0, sizeof(g));  // 必败步数
    f[0] = f[1] = 0;
    g[0] = g[1] = 0;
    
    for(int i=2; i<=20000; ++i) {
        bool canWin = false;
        int minStep = INT_MAX, maxStep = 0;
        
        for(int j=1; j<=cnt && prime[j]<=i; ++j) {
            int prev = i - prime[j];
            if(f[prev] == -1) { // 前驱是必败态
                canWin = true;
                minStep = min(minStep, g[prev] + 1);
            } else {
                maxStep = max(maxStep, f[prev] + 1);
            }
        }
        
        if(canWin) {
            f[i] = minStep;
            g[i] = 0;
        } else {
            f[i] = -1;
            g[i] = maxStep;
        }
    }
}
```

---
处理用时：98.29秒
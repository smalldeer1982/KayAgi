# 题目信息

# [NOIP 2014 普及组] 子矩阵

## 题目背景

NOIP2014 普及组 T4

## 题目描述

给出如下定义：

1. 子矩阵：从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵（保持行与列的相对顺序）被称为原矩阵的一个子矩阵。

    例如，下面图中选取第 $2,4$ 行和第 $2,4,5$ 列交叉位置的元素得到一个 $2 \times 3$ 的子矩阵如下所示。

|$9$|$\color{#6a5acd}3$|$3$|$\color{#6a5acd}3$|$\color{#6a5acd}9$|
|:-|:-|:-|:-|:-|
|$\color{#6a5acd}9$|$\color{blue}4$|$\color{#6a5acd}8$|$\color{blue}7$|$\color{blue}4$|
|$1$|$\color{#6a5acd}7$|$4$|$\color{#6a5acd}6$|$\color{#6a5acd}6$|
|$\color{#6a5acd}6$|$\color{blue}8$|$\color{#6a5acd}5$|$\color{blue}6$|$\color{blue}9$|
|$7$|$\color{#6a5acd}4$|$5$|$\color{#6a5acd}6$|$\color{#6a5acd}1$|

此矩阵的其中一个 $2\times3$ 的子矩阵是：

|$4$|$7$|$4$|
|:-|:-|:-|
|$8$|$6$|$9$|

2. 相邻的元素：矩阵中的某个元素与其上下左右四个元素（如果存在的话）是相邻的。

3. 矩阵的分值：矩阵中每一对相邻元素之差的绝对值之和。

本题任务：给定一个 $n$ 行 $m$ 列的正整数矩阵，请你从这个矩阵中选出一个 $r$ 行 $c$ 列的子矩阵，使得这个子矩阵的分值最小，并输出这个分值。

## 说明/提示

#### 样例 1 说明

该矩阵中分值最小的 $2$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行与第 $1$ 列、第 $3$ 列、第 $4$ 列交叉位置的元素组成，为：

|$6$|$5$|$6$|
|:-|:-|:-|
|$7$|$5$|$6$|

其分值为 $|6-5|+|5-6|+|7-5|+|5-6|+|6-7|+|5-5|+|6-6|=6$。

#### 样例 2 说明

该矩阵中分值最小的 $3$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行、第 $6$ 行与第 $2$ 列、第 $6$ 列、第 $7$ 列交叉位置的元素组成，选取的分值最小的子矩阵为：

|$9$|$7$|$8$|
|:-|:-|:-|
|$9$|$8$|$8$|
|$5$|$8$|$10$|

#### 数据范围

- 对于 $50\%$ 的数据，$1\leq n\leq 12$，$1\leq m\leq 12$，矩阵中的每个元素 $1\leq a_{i,j}\leq20$；

- 对于 $100\%$ 的数据，$1\leq n\leq 16$，$1\leq m\leq 16$，矩阵中的每个元素 $1\leq a_{i,j}\leq 1000$，$1\leq r\leq n$，$1\leq c\leq m$。

## 样例 #1

### 输入

```
5 5 2 3
9 3 3 3 9
9 4 8 7 4
1 7 4 6 6
6 8 5 6 9
7 4 5 6 1```

### 输出

```
6```

## 样例 #2

### 输入

```
7 7 3 3  
7 7 7 6 2 10 5
5 8 8 2 1 6 2 
2 9 5 5 6 1 7 
7 9 3 6 1 7 8 
1 9 1 4 7 8 8 
10 5 9 1 1 8 10
1 3 1 5 4 8 6```

### 输出

```
16```

# AI分析结果



0. **题目翻译**

# [NOIP 2014 普及组] 子矩阵

## 题目背景

NOIP2014 普及组 T4

## 题目描述

给出如下定义：

1. **子矩阵**：从原矩阵选取若干行和列交叉位置组成的新矩阵，保持行列相对顺序。  
   例如：选取第2,4行和第2,4,5列构成的2×3子矩阵。

2. **相邻元素**：矩阵中某元素与其上下左右四个元素（若存在）互为相邻。

3. **矩阵分值**：矩阵内所有相邻元素差值的绝对值之和。

任务：给定一个n行m列的正整数矩阵，选出r行c列的子矩阵，使其分值最小。

---

1. **唯一算法分类**  
**线性DP**

---

2. **综合分析与结论**

### 核心思路与难点
- **双重组合优化**：需同时选择r行和c列，暴力枚举复杂度为$O(C_n^r C_m^c)$，无法通过全部数据。
- **分层处理**：大多数题解采用「先枚举行组合，再动态规划列组合」的分治策略，将问题拆分为：
  1. **行枚举**：通过DFS或二进制枚举生成所有可能的行组合。
  2. **列DP**：对每个行组合，用线性DP计算选c列的最优解，复杂度$O(m^3)$。
- **状态设计**：
  - `dp[i][j]`：前i列选j列且最后一列为i的最小分值。
  - **转移方程**：  
    $dp[i][j] = \min_{k < i} (dp[k][j-1] + \text{列内分值}(i) + \text{行列交叉分值}(k,i))$  
    其中：
    - 列内分值：当前列i的上下相邻元素差值之和。
    - 行列交叉分值：列k与列i之间的左右相邻元素差值之和。
- **预处理优化**：  
  提前计算所有可能行组合的列内分值和行列交叉分值，避免重复计算。

### 可视化设计
- **DP矩阵更新动画**：  
  在Canvas网格中展示`dp[i][j]`矩阵，高亮当前更新的单元格（如红色边框），动态绘制从`k`到`i`的转移箭头（蓝色线条），数值变化时显示绿色渐变动效。
- **复古像素风格**：  
  使用16色调色板，每个DP状态用8×8像素块表示，背景播放FC风格BGM，状态更新时触发「哔」声，最优解更新时播放「金币音效」。
- **交互控制**：  
  支持暂停/继续、单步执行、调整动画速度，侧边栏实时显示当前行组合和列选择路径。

---

3. **题解清单 (≥4星)**

#### panyf (★★★★☆)
- **亮点**：DFS+剪枝预处理行组合，分层计算行内/列内贡献，优化状态回溯逻辑。
- **关键代码**：  
  ```cpp
  void dfsl(ci&x, ci&y, ci&z) {
      if (y == c) { s = min(s, z); return; }
      for (int i=x+1; i<en; ++i) {
          int zz = z + p[i] + w[x][i]; // 合并行列贡献
          if (zz < s) dfsl(i, y+1, zz);
      }
  }
  ```

#### lizh (★★★★☆)
- **亮点**：动态规划状态转移清晰，预处理列间差值矩阵，代码结构易扩展。
- **代码片段**：  
  ```cpp
  for (int k=1; k<i; k++) {
      int tot = 0;
      for (int l=1; l<=m; l++) {
          if (lr[l]) // 计算列k与i的交叉贡献
              tot += abs(a[i][l]-a[k][l]);
      }
      dp[i][j] = min(dp[i][j], dp[k][j-1] + tot);
  }
  ```

#### Ian_NIE (★★★★★)
- **亮点**：行枚举与列DP解耦，`cal`函数模块化设计，代码可读性极佳。
- **核心逻辑**：  
  ```cpp
  int cal(int x, int y) { // 计算列x与y的交叉贡献
      int res = 0;
      for (int i=1; i<=r; i++)
          res += abs(a[plan[i]][x] - a[plan[i]][y]);
      return res;
  }
  ```

---

4. **代码实现**

### 关键DP代码（Ian_NIE题解核心）
```cpp
void calc() {
    memset(dp, 0x3f, sizeof dp);
    // 初始化单列分值
    for (int i=1; i<=m; i++) {
        dp[i][1] = 0;
        for (int j=2; j<=r; j++)
            dp[i][1] += abs(a[plan[j]][i] - a[plan[j-1]][i]);
    }
    // 状态转移
    for (int j=2; j<=c; j++) {
        for (int i=j; i<=m; i++) {
            for (int k=j-1; k<i; k++) {
                dp[i][j] = min(dp[i][j], 
                    dp[k][j-1] + cal(k, i) + col_cost(i));
            }
        }
    }
}
```

---

5. **同类型题与推荐**

### 相似题目
- **P2701 [NOI2011] 矩阵游戏**：行列选择与变换，需动态规划优化。
- **P1854 花店橱窗**：线性DP处理列选择，类似的分层贡献计算。
- **P2217 [HAOI2007]分割矩阵**：矩阵分割问题，动态规划状态设计。

---

6. **可视化代码片段（Canvas动画）**

```javascript
// 绘制DP矩阵
function drawDPGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let i=0; i<=m; i++) {
        for (let j=0; j<=c; j++) {
            ctx.fillStyle = getColor(dp[i][j]); // 根据分值设置颜色
            ctx.fillRect(i*30, j*30, 28, 28);
            if (i === currentCol && j === currentStep) {
                ctx.strokeStyle = '#ff0000'; // 高亮当前更新格
                ctx.strokeRect(i*30-1, j*30-1, 30, 30);
            }
        }
    }
}
```

---
处理用时：94.81秒
# 题目信息

# yyy loves OI IV

## 题目背景

某校 2015 届有两位 OI 神牛，yyy 和 c01。


## 题目描述

全校除他们以外的 $N$ 名学生，每人都会膜拜他们中的某一个人。现在老师要给他们分宿舍了。但是，问题来了：

同一间宿舍里的人要么膜拜同一位大牛，要么膜拜 yyy 和 c01 的人数的差的绝对值不超过 $M$。否则他们就会打起来。

为了方便，老师让 $N$ 名学生站成一排，只有连续地站在一起的人才能分进同一个宿舍。

假设每间宿舍能容纳任意多的人，请问最少要安排几个宿舍？


## 说明/提示

| 测试点编号 | $N$ 的范围 | $M$ 的范围 |
| :-----------: | :-----------: | :-----------: |
| $1 \sim 3$ | $\le 2500$ | $\le 10$ |
| $4 \sim 5$ | $\le 5\times 10 ^ 5$ | $\le 10$ |
| $6 \sim 10$ | $\le 5\times 10 ^ 5$ | $\le 2000$ |



## 样例 #1

### 输入

```
5 1
1
1
2
2
1```

### 输出

```
1```

# AI分析结果



# 题目翻译

## yyy 热爱 OI IV

### 题目背景

某校 2015 届有两位 OI 大神，yyy 和 c01。

### 题目描述

全校除他们以外的 $N$ 名学生，每人都会膜拜其中一位。现在老师需要分配宿舍：

同一宿舍的人必须满足以下条件之一：  
1. 全部膜拜同一位大神  
2. 膜拜 yyy 和 c01 的人数差的绝对值不超过 $M$

学生按队列排列，只有连续队列才能分入同一宿舍。求最少需要的宿舍数量。

### 输入样例

```
5 1
1
1
2
2
1
```

### 输出样例

```
1
```

---

# 算法分类  
**线性DP**

---

# 算法分析与结论

## 核心思路
1. **状态定义**：`f[i]` 表示前 `i` 个学生需要的最少宿舍数
2. **转移方程**：
   ```math
   f[i] = \min\{f[j] + 1\} \quad (0 \le j < i)
   ```
   其中 `j` 需要满足：
   - 区间 `[j+1, i]` 全为同一类型
   - 或两种人数的差值绝对值 ≤ M

## 关键优化
1. **前缀和转换**：将学生序列转换为前缀和数组 `sum[i]`，差值 `d[i] = sum[i] - sum[j]`
2. **数学变形**：将约束条件转换为区间查询 `[d[i]-M, d[i]+M]`
3. **线段树加速**：维护前缀和差值的区间最小值查询，时间复杂度优化至 `O(n log n)`

## 可视化设计
1. **DP矩阵动画**：
   - 使用网格展示 `f[]` 数组更新过程
   - 高亮当前计算的 `i` 和对应的查询区间 `[d[i]-M, d[i]+M]`
   - 线段树节点用颜色标记最小值范围
2. **8位像素风格**：
   - 灰色系表示未计算的 `f[]` 值
   - 绿色闪烁表示被更新的最小值
   - 红色边框标记当前处理的区间
3. **音效系统**：
   - 按键音效：每次线段树更新时播放
   - 成功音效：找到更优解时触发
   - 背景音乐：8-bit 风格循环旋律

---

# 高分题解 (≥4星)

## 1. Created_equal1（★★★★☆）
**核心亮点**：
- 分三类情况处理转移条件
- 双数组维护全同类型情况
- 线段树离散化处理负数偏移

**关键代码**：
```cpp
int a = c01_dp[c01[i]];  // 全c01情况
int b = yyy_dp[yyy[i]];  // 全yyy情况
int c = Space.rmq_min(1, c01[i]-yyy[i]-M, M + c01[i]-yyy[i]); // 差值区间
f[i] = min({a+1, b+1, c+1, f[i-1]+1});
```

## 2. LlLlCc（★★★★☆）
**创新点**：
- 将膜拜值转换为 ±1 序列
- 设计偏移量处理负数查询
- 双线段树维护不同维度

**数学推导**：
```math
sum_R - sum_L \leq M \quad \Rightarrow \quad sum_L \geq sum_R - M
sum_L - sum_R \leq M \quad \Rightarrow \quad sum_L \leq sum_R + M
```

## 3. FutaRimeWoawaSete（★★★★★）
**核心贡献**：
- 动态维护连续相同类型区间
- 严格处理查询区间越界问题
- 代码结构清晰易调试

**调试技巧**：
```cpp
int l = deC(max(d-M, -n));  // 处理左边界越界
int r = deC(min(d+M, n));   // 处理右边界越界
```

---

# 核心代码实现

## 线段树优化DP片段
```cpp
// 前缀和差值查询
int query(int i) {
    int d = sum[i] * 2 - i;  // 差值计算
    int L = max(d - M, -n) + OFFSET;
    int R = min(d + M, n) + OFFSET;
    return seg.query(L, R);
}

// DP转移核心
for(int i=1; i<=n; ++i){
    f[i] = min(f[i-1]+1, seg.query(sum[i]));
    seg.update(sum[i], f[i]);
}
```

---

# 相似题目推荐
1. **P1886 滑动窗口** - 区间极值查询
2. **P1090 合并果子** - 优先队列优化
3. **P1904 天际线** - 区间覆盖处理

---

# 调试心得摘录
> "WA 了无数发才注意到线段树的查询区间可能越界，必须严格限制在[-n, n]之间"  
> "将膜拜类型转换为±1序列后，前缀和的计算变得异常简洁"  
> "动态维护连续区间的preans变量，比静态数组效率提升30%"

---

# 可视化演示方案
1. **Canvas网格**：
   - 横向展示学生序列
   - 纵向显示DP状态值
2. **动画效果**：
   - 红色光柱扫描当前处理的 `i`
   - 绿色波纹扩散表示线段树更新
3. **交互控制**：
   - 空格键暂停/继续
   - 方向键调节动画速度
   - F键触发自动演示模式

![DP状态转移示意图](https://i.imgur.com/ZYpXgKQ.gif)  
（示意图展示线段树如何加速区间查询）

---
处理用时：95.21秒
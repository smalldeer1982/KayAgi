# 题目信息

# [SCOI2010] 股票交易

## 题目描述

最近 $\text{lxhgww}$ 又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。

通过一段时间的观察，$\text{lxhgww}$ 预测到了未来 $T$ 天内某只股票的走势，第 $i$ 天的股票买入价为每股 $AP_i$，第 $i$ 天的股票卖出价为每股 $BP_i$（数据保证对于每个 $i$，都有 $AP_i \geq BP_i$），但是每天不能无限制地交易，于是股票交易所规定第 $i$ 天的一次买入至多只能购买 $AS_i$ 股，一次卖出至多只能卖出 $BS_i$ 股。

另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 $W$ 天，也就是说如果在第 $i$ 天发生了交易，那么从第 $i+1$ 天到第 $i+W$ 天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过 $\text{MaxP}$。

在第 $1$ 天之前，$\text{lxhgww}$ 手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，$T$ 天以后，$\text{lxhgww}$ 想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？



## 说明/提示

- 对于 $30\%$ 的数据，$0\leq W<T\leq 50,1\leq\text{MaxP}\leq50$；
- 对于 $50\%$ 的数据，$0\leq W<T\leq 2000,1\leq\text{MaxP}\leq50$；
- 对于 $100\%$ 的数据，$0\leq W<T\leq 2000,1\leq\text{MaxP}\leq2000$；
- 对于所有的数据，$1\leq BP_i\leq AP_i\leq 1000,1\leq AS_i,BS_i\leq\text{MaxP}$。

## 样例 #1

### 输入

```
5 2 0
2 1 1 1
2 1 1 1
3 2 1 1
4 3 1 1
5 4 1 1
```

### 输出

```
3```

# AI分析结果



0. **题目内容重写**

# [SCOI2010] 股票交易

## 题目描述

最近 lxhgww 迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。

lxhgww 预测到了未来 T 天内某只股票的走势，第 i 天的股票买入价为每股 AP_i，卖出价为每股 BP_i（数据保证对于每个 i，都有 AP_i ≥ BP_i），但每天的交易存在限制：  
- 单次买入最多购买 AS_i 股  
- 单次卖出最多卖出 BS_i 股  

交易所还规定：  
1. 两次交易之间至少间隔 W 天（买入或卖出均视为交易）  
2. 任何时候持有的股票数不得超过 MaxP  

已知第 1 天前 lxhgww 没有股票但资金无限，求 T 天后的最大收益。

## 输入格式
第一行三个整数 T, MaxP, W  
接下来 T 行每行四个整数 AP_i, BP_i, AS_i, BS_i

## 输出格式
最大收益

## 样例输入
```
5 2 0
2 1 1 1
2 1 1 1
3 2 1 1
4 3 1 1
5 4 1 1
```

## 样例输出
```
3
```

---

1. **算法分类**  
   线性DP（使用单调队列优化）

---

2. **综合分析与结论**

### 核心思路
采用动态规划框架：  
- **状态定义**：`dp[i][j]` 表示第 i 天结束后持有 j 股的最大收益  
- **状态转移**分四类：  
  1. **初始买入**：`dp[i][j] = -AP_i * j`（直接买入）  
  2. **继承操作**：`dp[i][j] = max(dp[i][j], dp[i-1][j])`  
  3. **间隔买入**：`dp[i][j] = max(dp[i-w-1][k] + AP_i*(k-j))`（需单调队列优化）  
  4. **间隔卖出**：`dp[i][j] = max(dp[i-w-1][k] + BP_i*(j-k))`（需单调队列优化）  

### 关键优化
- **单调队列**维护滑动窗口最大值，将时间复杂度从 O(T×MaxP²) 优化为 O(T×MaxP)  
- **正序处理买入**：维护`k ∈ [j-AS_i, j]`的窗口  
- **逆序处理卖出**：维护`k ∈ [j, j+BS_i]`的窗口  

### 解决难点
- **时间窗口约束**：通过`i-w-1`天前的状态转移实现间隔限制  
- **大范围状态转移**：单调队列有效处理区间最值查询  

---

3. **题解清单（评分≥4星）**

#### 题解1：Sooke（★★★★★）
- **亮点**：  
  1. 完整推导四种转移情况  
  2. 详细解释单调队列优化原理  
  3. 代码结构清晰，包含详细注释  

#### 题解2：Memorize（★★★★☆）
- **亮点**：  
  1. 状态转移方程变形展示  
  2. 使用双端队列实现滑动窗口  
  3. 代码注释解释关键步骤  

#### 题解3：xs_siqi（★★★★☆）
- **亮点**：  
  1. 创新性提出二进制优化思路  
  2. 多重背包式分组处理  
  3. 提供前缀和优化思路  

---

4. **核心代码实现**

```cpp
// 单调队列优化买入转移（正序处理）
int l = 1, r = 0;
for(int j = 0; j <= MaxP; j++) {
    // 维护窗口大小
    while(l <= r && q[l] < j - AS_i) l++;
    // 维护队列单调性
    while(l <= r && dp[i-w-1][j] + j*AP_i >= dp[i-w-1][q[r]] + q[r]*AP_i) r--;
    q[++r] = j;
    dp[i][j] = max(dp[i][j], dp[i-w-1][q[l]] + q[l]*AP_i - j*AP_i);
}

// 单调队列优化卖出转移（逆序处理）
l = 1, r = 0;
for(int j = MaxP; j >= 0; j--) {
    while(l <= r && q[l] > j + BS_i) l++;
    while(l <= r && dp[i-w-1][j] + j*BP_i >= dp[i-w-1][q[r]] + q[r]*BP_i) r--;
    q[++r] = j;
    dp[i][j] = max(dp[i][j], dp[i-w-1][q[l]] + q[l]*BP_i - j*BP_i);
}
```

---

5. **可视化设计**

### 动画方案设计
- **DP矩阵更新**：  
  ![DP Matrix](https://cdn.luogu.com.cn/upload/image_hosting/4w1g0z9k.png)  
  - **网格绘制**：用 Canvas 绘制 T×MaxP 的网格，每个单元格表示`dp[i][j]`的值  
  - **颜色标记**：  
    - 红色：当前处理的`dp[i][j]`  
    - 绿色：单调队列维护的窗口范围  
    - 黄色：历史最优值  

- **动画步骤**：  
  1. 高亮第`i`天行，从左到右处理买入转移  
  2. 展示单调队列的入队/出队过程  
  3. 显示`dp[i][j]`的数值变化  

### 复古像素风格实现
```javascript
// Canvas 初始化
const canvas = document.getElementById('dp-grid');
const ctx = canvas.getContext('2d');
const CELL_SIZE = 16; // 16x16像素的单元格

function drawGrid() {
    for(let i = 0; i < T; i++) {
        for(let j = 0; j < MaxP; j++) {
            // 用8位色绘制单元格
            ctx.fillStyle = getColor(dp[i][j]);
            ctx.fillRect(j*CELL_SIZE, i*CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
    }
}

// 音效触发（使用Web Audio API）
function playSound(type) {
    const oscillator = audioContext.createOscillator();
    oscillator.type = 'square'; // 8位方波音色
    oscillator.frequency.setValueAtTime(
        type === 'update' ? 440 : 880, 
        audioContext.currentTime
    );
    oscillator.connect(audioContext.destination);
    oscillator.start();
    oscillator.stop(audioContext.currentTime + 0.1);
}
```

---

6. **相似题目推荐**
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)  
2. [P2627 修剪草坪](https://www.luogu.com.cn/problem/P2627)  
3. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)  

---

7. **调试心得摘录**
> "单调队列需要严格维护窗口大小，买入要正序处理保证`k < j`，卖出要逆序处理保证`k > j`" —— Sooke  
> "注意处理`i-w-1`可能为负数的情况，否则会访问非法内存" —— _LAUV_  
> "初始化必须设为负无穷，表示不可能的状态" —— Memorize

---

8. **算法比较可视化**
在 Canvas 中并排显示两种实现：
- **左侧**：暴力三重循环（红色表示超时区域）  
- **右侧**：单调队列优化（绿色表示有效计算区域）  
- 用不同颜色箭头标注状态转移路径差异

---
处理用时：105.70秒
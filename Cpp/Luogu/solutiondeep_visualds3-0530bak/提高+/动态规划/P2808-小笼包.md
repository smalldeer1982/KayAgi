# 题目信息

# 小笼包

## 题目背景

JOI同学的午饭，是在中华料理店买的小笼包。这是一种用小麦粉制成的皮包着馅和热汤的料理，吃的时候，热汤会飞溅出来。


## 题目描述

JOI 同学点的小笼包套餐，由馅料不同的 $N$ 个小笼包组成。$N$ 个小笼包等间隔排成一列，编号为 $1$ 到 $N$。第 $i$ 个小笼包与第 $j$ 个小笼包之间的距离是绝对值 $\vert i - j \vert$。
JOI 同学按照顺序吃小笼包。最初，所有的小笼包的美味度都是 $0$。吃第 $i$ 个小笼包时，汤汁向周围飞散，与第 $i$ 个小笼包距离 $D_i$ 以下的小笼包都淋上了汤汁，而被淋上汤汁的小笼包的美味度会增加 $A_i$。也就是说，吃第 $i$ 个小笼包的时候，第 $j$ 个小笼包 $(1 \leq j \leq N $ 并且 $ i - D_i \leq j \leq i + D_i)$ 还没有吃到的话，第 $j$ 个小笼包的美味度就增加 $A_i$。

 ![](https://cdn.luogu.com.cn/upload/pic/2340.png) 

JOI 同学要在吃小笼包的顺序上下功夫，让吃的小笼包的美味度的合计最大化。

## 说明/提示

样例 $1$ 的说明：以第 $5 \rightarrow$ 第 $3 \rightarrow$ 第 $1 \rightarrow$ 第 $2 \rightarrow$ 第 $4$ 的顺序吃的话，美味度合计为 $20$，因为美味度超过 $20$ 的吃法是不存在的，所以这是最好的。

本题是 2014 年日本信息学奥林匹克（JOI）预选第 6 题。

## 样例 #1

### 输入

```
5
1 0 1 1 2
0 2 6 3 4```

### 输出

```
20```

## 样例 #2

### 输入

```
10
5 2 7 2 6 5 3 5 3 6
8 7 8 4 0 6 0 10 10 0```

### 输出

```
237```

# AI分析结果



# 题目内容

## 题目背景

JOI同学的午饭是在中华料理店买的小笼包。这是一种用小麦粉制成的皮包裹馅料和热汤的料理，吃的时候热汤会飞溅出来。

## 题目描述

JOI同学点的小笼包套餐由馅料不同的N个小笼包组成。N个小笼包等间隔排成一列，编号为1到N。第i个小笼包与第j个小笼包之间的距离是绝对值|i - j|。

JOI同学按顺序吃小笼包。最初所有小笼包的美味度都是0。吃第i个小笼包时，汤汁向周围飞散，与第i个小笼包距离Di以下的小笼包都淋上了汤汁，被淋上汤汁的小笼包的美味度会增加Ai。即吃第i个小笼包时，第j个小笼包（1 ≤ j ≤ N且i - Di ≤ j ≤ i + Di）若还未被吃，其美味度就增加Ai。

JOI同学要通过调整吃小笼包的顺序，使得被吃的小笼包的美味度总和最大化。

## 输入输出样例

样例1输入：
```
5
1 0 1 1 2
0 2 6 3 4
```
输出：
```
20
```

---

# 算法分类：线性DP

## 综合分析与结论

### 核心思路
题目本质是求最优排列问题，需要通过动态规划实现状态压缩。通过观察发现，当前决策最多影响后续14个包子（由Di最大值决定），因此采用**有限窗口排列记录法**：仅记录最后7-8个包子的进食顺序，将全排列编码为整数状态。

### 关键难点与突破
1. **状态设计**：
   - 使用康托展开将排列编码为唯一整数，解决状态存储问题
   - 滚动数组优化空间复杂度（f[2][maxs]）

2. **状态转移**：
   - 枚举新包子插入位置（k+1种可能性）
   - 计算两个方向的贡献：
     - 新包子对旧包子序列的影响（后续被溅射）
     - 旧包子对新包子的影响（提前被溅射）

3. **优化手段**：
   - 限制排列窗口大小（7-8位）
   - 预处理阶乘加速康托运算
   - 使用位运算切换滚动数组维度

### 可视化设计要点
1. **像素化DP矩阵**：
   - 用16色调色板表示状态值梯度
   - 每个状态格子显示康托编码和当前最大值
   - 转移时高亮旧状态→新状态的箭头

2. **音效系统**：
   - 状态更新：8-bit "blip" 音效（频率与增益值正相关）
   - 最优解更新：超级马里奥金币音效
   - 错误操作：经典FC游戏"Game Over"音效片段

3. **自动演示模式**：
   - 模拟贪吃蛇AI自动选择最优转移路径
   - 每步延迟可调（100ms-2s）
   - 右侧面板显示历史最优序列动画

---

# ≥4星题解推荐

**1. 朱江黄河（4.5星）**
- 亮点：完整实现康托正逆展开，处理边界清晰
- 核心代码：
```cpp
int cantor(int a[],int k){
    int ans=0;
    for(int i=0;i<k;i++){
        int tmp=0;
        for(int j=i+1;j<k;j++)
            if(a[j]<a[i])tmp++;
        ans+=tmp*fac[k-i-1];
    }
    return ans;
}
```

**2. 哈撒各一（4.2星）**
- 亮点：独立实现split/merge函数，注释详细
- 关键处理：
```cpp
for(int k=1;k<=7;k++){
    if((i-(7-k))>0&&w[k]<w[8]&&d[i-(7-k)]>=8-k)
        ret+=a[i-(7-k)]; // 旧包子对新包子的影响
    if((i-(7-k))>0&&w[k]>w[8]&&d[i+1]>=8-k)
        ret+=a[i+1]; // 新包子对旧包子的影响
}
```

---

# 核心代码实现

**状态转移核心逻辑**：
```cpp
for(int i=0;i<n;i++){
    int k=min(i,maxd);
    for(int j=0;j<fac[k];j++){ // 枚举所有排列
        // 解码当前状态
        uncantor(current_state,j,k);
        
        for(int pos=0;pos<=k;pos++){ // 枚举插入位置
            // 构造新排列
            int new_state = insert_to_pos(current_state, pos, k+1);
            
            // 计算增益
            int gain = calculate_gain(current_state, pos, i);
            
            // 更新DP
            f[new_dim][new_state] = max(
                f[new_dim][new_state],
                f[old_dim][j] + gain
            );
        }
    }
}
```

---

# 相似题目推荐
1. **P1433 吃奶酪** - 状态压缩DP经典
2. **P1171 售货员的难题** - 排列型动态规划
3. **P2831 愤怒的小鸟** - 状态压缩+位运算优化

---

# 可视化伪代码示例
```javascript
class DPPixel {
    constructor(canvas) {
        this.grid = new Array(5040).fill(0); // 7!状态空间
        this.historyMax = 0;
    }
    
    render(ctx) {
        for(let i=0; i<5040; i++){
            const x = i % 80 * 16;
            const y = Math.floor(i/80) * 16;
            const color = this.getColor(this.grid[i]);
            ctx.fillStyle = color;
            ctx.fillRect(x, y, 15, 15);
        }
    }
    
    getColor(value) {
        const ratio = value / this.historyMax;
        return `hsl(${240*ratio}, 70%, 50%)`;
    }
}
```

---
处理用时：108.24秒
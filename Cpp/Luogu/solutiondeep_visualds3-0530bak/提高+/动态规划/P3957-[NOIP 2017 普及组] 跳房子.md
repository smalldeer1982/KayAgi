# 题目信息

# [NOIP 2017 普及组] 跳房子

## 题目背景

NOIP2017 普及组 T4

## 题目描述

跳房子，也叫跳飞机，是一种世界性的儿童游戏，也是中国民间传统的体育游戏之一。

跳房子的游戏规则如下：

在地面上确定一个起点，然后在起点右侧画 $n$ 个格子，这些格子都在同一条直线上。每个格子内有一个数字（整数），表示到达这个 格子能得到的分数。玩家第一次从起点开始向右跳，跳到起点右侧的一个格子内。第二次再从当前位置继续向右跳，依此类推。规则规定：

玩家每次都必须跳到当前位置右侧的一个格子内。玩家可以在任意时刻结束游戏，获得的分数为曾经到达过的格子中的数字之和。

现在小 R 研发了一款弹跳机器人来参加这个游戏。但是这个机器人有一个非常严重的缺陷，它每次向右弹跳的距离只能为固定的 $d$。小 R 希望改进他的机器人，如果他花 $g$ 个金币改进他的机器人，那么他的机器人灵活性就能增加 $g$，但是需要注意的是，每 次弹跳的距离至少为 $1$。具体而言，当 $g<d$ 时，他的机器人每次可以选择向右弹跳的距离为 $d-g,d-g+1,d-g+2,\ldots,d+g-1,d+g$；否则当 $g \geq d$ 时，他的机器人每次可以选择向右弹跳的距离为 $1,2,3,\ldots,d+g-1,d+g$。

现在小 R 希望获得至少 $k$ 分，请问他至少要花多少金币来改造他的机器人。

## 说明/提示

**样例 1 说明**

花费 $2$ 个金币改进后，小 R 的机器人依次选择的向右弹跳的距离分别为 $ 2, 3, 5, 3, 4,3$，先后到达的位置分别为 $2, 5, 10, 13, 17, 20$，对应 $ 1, 2, 3, 5, 6, 7$ 这 $6$ 个格子。这些格子中的数字之和 $ 15$ 即为小 R 获得的分数。

**样例 2 说明**

由于样例中 $7$ 个格子组合的最大可能数字之和只有 $18$，所以无论如何都无法获得 $20$ 分。

**数据规模与约定**

本题共 10 组测试数据，每组数据等分。

对于全部的数据满足 $1 \le n \le 5\times10^5$，$1 \le d \le2\times10^3$，$1 \le x_i, k \le 10^9$，$|s_i| < 10^5$。

对于第 $1, 2$ 组测试数据，保证 $n\le 10$。

对于第 $3, 4, 5$ 组测试数据，保证 $n \le 500$。

对于第 $6, 7, 8$ 组测试数据，保证 $d = 1$。

## 样例 #1

### 输入

```
7 4 10
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2```

### 输出

```
2```

## 样例 #2

### 输入

```
7 4 20
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2```

### 输出

```
-1```

# AI分析结果



0. **题目翻译**

---

# [NOIP 2017 普及组] 跳房子

## 题目背景

NOIP2017 普及组 T4

## 题目描述

跳房子（又称跳飞机）是一种世界性儿童游戏，也是中国民间传统体育活动之一。

游戏规则如下：在地面上确定起点，在起点右侧绘制 $n$ 个排成一行的格子，每个格子上标有数字（整数），表示到达该格子可获得的分数。玩家从起点出发向右跳跃，每次必须跳到当前位置右侧的某个格子。玩家可随时终止游戏，最终得分为经过所有格子的分数之和。

现小 R 开发了弹跳机器人参加该游戏，但机器人存在缺陷：每次只能固定跳跃 $d$ 单位距离。改进方法为花费 $g$ 个金币提升灵活性，改进后跳跃距离范围变为：  
- 当 $g < d$ 时，可选范围 $[d-g, d+g]$  
- 当 $g \geq d$ 时，可选范围 $[1, d+g]$  

现需确定获得至少 $k$ 分所需的最小金币数 $g$，若无法达成则输出 $-1$。

## 输入格式

第一行三个整数 $n,d,k$，表示格子数、基准跳跃距离、目标分数。  
接下来 $n$ 行每行两个整数 $x_i, s_i$，表示第 $i$ 个格子与起点的距离及其分数（可能存在负分格子）。

## 输出格式

输出最小金币数，若无法达成则输出 $-1$。

## 样例 #1

### 输入
```
7 4 10
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2
```

### 输出
```
2
```

---

1. **唯一算法分类**  
   **线性DP**（结合二分答案与单调队列优化）

---

2. **综合分析与结论**

### 核心思路
- **二分框架**：通过二分搜索确定最小金币数 $g$。因金币数越大，跳跃范围越广，得分具有单调性。
- **动态规划**：对每个二分值 $g$，用动态规划计算最大得分。定义 $dp[i]$ 为跳到第 $i$ 个格子的最大得分，状态转移方程为：
  $$ dp[i] = \max_{j \in [l_i, r_i]} \{ dp[j] \} + s_i $$
  其中 $l_i = \max(1, d-g)$，$r_i = d+g$，$j$ 需满足 $x_i - x_j \in [l_i, r_i]$。
- **单调队列优化**：在动态规划过程中，维护一个单调递减队列，快速获取区间 $[l_i, r_i]$ 内的最大 $dp[j]$。

### 可视化设计要点
- **动态规划矩阵**：以网格形式展示 $dp$ 数组，每个单元格表示对应格子的最大得分，高亮当前处理的格子及队列中的候选格。
- **单调队列动画**：用不同颜色块表示队列元素，动态展示队列入队、出队过程，特别标注队首最大值。
- **像素化风格**：采用 8-bit 像素风格绘制网格，跳跃过程配以经典音效（如方块移动声、得分更新声）。
- **交互演示**：支持调节二分搜索速度，单步执行动态规划，观察队列维护细节。

---

3. **题解清单 (≥4星)**

| 作者         | 评分 | 关键亮点                                                                 |
|--------------|------|--------------------------------------------------------------------------|
| Tweetuzki    | ★★★★☆ | 最早提出二分+单调队列优化框架，修复初始代码边界问题                       |
| Gorenstein   | ★★★★★ | 分步骤详解单调队列优化原理，提供完整状态转移方程推导                     |
| Frozencode   | ★★★★☆ | 创新性提出优先队列解法，代码简洁易懂，适合理解核心逻辑                   |

---

4. **最优思路提炼**

### 关键步骤
1. **二分搜索**：在 $[0, \max(x_n, d)]$ 范围内二分 $g$。
2. **动态规划初始化**：$dp[0] = 0$（起点），其余初始化为负无穷。
3. **单调队列维护**：
   - **入队条件**：当 $x_i - x_j \geq l_i$ 时，将 $j$ 加入队列，并维护队列单调递减性。
   - **出队条件**：当 $x_i - x_j > r_i$ 时，从队首移除过期元素。
4. **快速转移**：直接从队首获取最大值更新 $dp[i]$，若得分超过 $k$ 则提前返回。

### 代码片段
```cpp
bool check(int g) {
    deque<int> q;
    int l = max(1, d - g), r = d + g;
    memset(dp, 0x80, sizeof(dp));
    dp[0] = 0;
    int j = 0;
    for (int i = 1; i <= n; ++i) {
        // 入队所有满足 x[i]-x[j]>=l 的 j
        while (j < i && x[i] - x[j] >= l) {
            while (!q.empty() && dp[q.back()] <= dp[j]) 
                q.pop_back();
            q.push_back(j++);
        }
        // 出队不满足 x[i]-x[j]<=r 的元素
        while (!q.empty() && x[i] - x[q.front()] > r) 
            q.pop_front();
        // 状态转移
        if (!q.empty()) 
            dp[i] = dp[q.front()] + s[i];
        if (dp[i] >= k) 
            return true;
    }
    return false;
}
```

---

5. **同类型题推荐**

1. **P1886 滑动窗口**（单调队列模板题）  
2. **P1725 琪露诺**（线性DP + 单调队列优化）  
3. **P2569 股票交易**（复杂状态转移与队列优化）

---

6. **个人心得摘录**

> _"初始时错误地将 dp 数组初始化为 -1，导致负分格子无法正确处理。改用 0x80 初始化后，成功通过所有测试用例。" —— Tweetuzki_  
> _"优先队列解法虽然时间复杂度稍高，但在 n=5e5 时仍能 AC，展现了 STL 的高效性。" —— Frozencode_

---

7. **可视化与算法演示**

### 动态规划矩阵演示
```javascript
// 伪代码：Canvas绘制DP矩阵
function drawGrid() {
  for (let i = 0; i < n; i++) {
    // 绘制格子，颜色深浅表示dp值大小
    ctx.fillStyle = getColor(dp[i]);
    ctx.fillRect(i * CELL_SIZE, 0, CELL_SIZE, CELL_SIZE);
    // 高亮当前处理的格子
    if (i == currentIndex) {
      ctx.strokeStyle = '#FF0000';
      ctx.strokeRect(i * CELL_SIZE, 0, CELL_SIZE, CELL_SIZE);
    }
  }
}
```

### 音效设计
- **入队/出队**：8-bit 电子音效  
- **得分更新**：清脆的“金币声”  
- **二分搜索完成**：短促胜利旋律

---

8. **复古游戏化动画示例**

```html
<!-- 伪HTML：像素风格控制面板 -->
<div id="game-container">
  <canvas id="dp-grid"></canvas>
  <div id="controls">
    <button onclick="step()">单步执行</button>
    <input type="range" id="speed" min="1" max="10">
  </div>
  <audio id="sound-effect" src="8bit_jump.wav"></audio>
</div>
```

```css
/* 像素风格CSS */
#dp-grid {
  image-rendering: pixelated;
  background: #2c3e50;
}
```

---

**通过上述设计，学习者可交互式观察动态规划与单调队列的协同运作，在游戏化体验中掌握算法核心。**

---
处理用时：109.51秒
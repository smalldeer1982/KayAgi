# 题目信息

# 「EZEC-1」甜品

## 题目背景

小 X 最喜欢甜品了！

马上就要开学了，但是小 X 并没有写完作业，他十分悲伤地走在街上。忽然，他发现了一家新开的甜品店，悲伤的心情一消而散，随即信步走进甜品店。

## 题目描述

小 X 发现，店里总共有 $n$ 种甜品，而他想挑选其中的 $k$ 种，并按照一定的顺序来品尝。

每种甜品都有一个美味值 $a_i$，小 X 吃甜品的顺序是有讲究的，他不想使连续两种甜品之间的美味值相差太小，不然他将无法品味出两种甜品之间的差别；但他也不想使连续两种甜品之间的美味值相差太大，否则他将受不了这巨大的味觉冲击。他十分纠结，不知道该如何选择，于是他向你求助。

你要从 $n$ 种甜品中选择 $k$ 种甜品，并且第 $i$  种甜品（ $i \in [ 2 , k ] $）需要满足如下两个条件：

- 第 $i$ 种甜品的美味值必须**大于等于**第 $i-1$ 种甜品的 $l$ 倍。

- 第 $i$ 种甜品的美味值必须**小于等于**第 $i-1$ 种甜品的 $r$ 倍。

问现在你有多少种方案？$k$ 种甜品的美味值之和最大为多少？

因为答案太大，所以两个问题你都需要对 $1000000007$($10^9+7$)  取模。

#### 注：方案总数只考虑 $k$ 种甜品的搭配，不考虑排列顺序。即若存在某 $k$ 种甜品，按照不同顺序品尝都满足条件，仍然只算一种方案。

## 说明/提示

【样例解释】

样例1：只能选 $(4,3,1)$，共 $1$ 种。

样例2：$(1,2)$ 或 $(3,4)$ 或 $(4,5)$，共 $3$ 种。美味值之和最大的是 $ (4,5)$，为 $100$。

------------

【 数据范围】
| 测试点编号 | $n\le$ | $k\le$ | $a_i\le$ |
| :----------: | :----------: | :----------: | :----------: | 
|$1 \sim 4$ | $20$ | $3$ | $100$ | 
| $5 \sim 8$ | $10^3$ | $4$ | $10^3$ | 
| $9 \sim 12$ | $10^5$ | $10$ | $10^5$ | 
| $13 \sim 16$ | $2\times 10^6$ | $10$ | $10^9$ | 
| $17 \sim 20$ | $2\times 10^6$ | $10$ | $10^9$ | 
- 对于 $90\%$ 的数据，$a_i$ 随机生成。
- 对于 $100\%$ 的数据，$k \le 10$，$k \le n \le 2\times 10^6$，$1 \le l \le r \le 10$，$a_i \le 10^9$。


## 样例 #1

### 输入

```
4 3 2 3
7 5 3 1```

### 输出

```
1
11```

## 样例 #2

### 输入

```
5 2 4 4
1 4 5 20 80```

### 输出

```
3
100```

## 样例 #3

### 输入

```
20 3 2 5
88 24 35 53 5 44 45 30 29 43 46 33 21 24 64 43 23 71 63 53 ```

### 输出

```
33
153```

## 样例 #4

### 输入

```
5 5 2 4
1 2 3 4 5```

### 输出

```
0
0```

# AI分析结果



0. **题目翻译**

# 「EZEC-1」甜品

## 题目背景

小 X 最喜欢甜品了！

马上就要开学了，但小 X 还没写完作业，他伤心地走在街上。突然发现新开的甜品店，心情瞬间好转。

## 题目描述

现有 $n$ 种甜品，需选择 $k$ 种并按顺序品尝。每种甜品的美味值 $a_i$ 需满足：
- 第 $i$ 种的美味值 ≥ 第 $i-1$ 种的 $l$ 倍
- 第 $i$ 种的美味值 ≤ 第 $i-1$ 种的 $r$ 倍

求满足条件的方案数（不考虑顺序）和最大美味值之和，结果模 $10^9+7$。

## 输入格式

第一行四个整数 $n,k,l,r$
第二行 $n$ 个整数表示 $a_i$

## 输出格式

两行分别输出方案数和最大值

---

1. **唯一算法分类**  
线性DP

---

2. **综合分析与结论**

**核心思路**  
通过排序预处理每个元素的前驱区间，使用线性DP维护方案数和最大值：
1. 排序后预处理每个位置 $i$ 的可选前驱区间 $[mi[i], ma[i]]$
2. 方案数DP：$dp[i][j] = \sum_{k\in[mi[i],ma[i]]} dp[k][j-1]$
3. 最大值DP：$f[i][j] = \max(f[k][j-1]) + a_i$

**关键难点**  
- 预处理时确定每个元素的前驱区间需要双指针技巧
- 方案数求和需要前缀和优化
- 最大值求取需要单调队列优化

**可视化设计**  
- **网格动画**：用二维网格展示DP状态，x轴为元素编号，y轴为选取个数  
- **颜色标记**：当前处理的元素用黄色高亮，前驱区间用绿色框标出，状态转移时用红色箭头连接  
- **音效触发**：状态更新时播放清脆音效，方案数更新时播放水滴声，最大值刷新时播放金币声  
- **复古风格**：采用16色调色板（FC红白机风格），网格线使用浅灰色，数值用8位像素字体显示

---

3. **题解清单 (4星以上)**

| 题解作者       | 评分 | 关键亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| 君のNOIP       | ★★★★☆ | 清晰的双指针预处理思路，滚动数组优化空间，分离方案数与最大值的计算逻辑 |
| HPXXZYY        | ★★★★  | 引入单调队列优化最大值计算，模块化处理前缀和与队列维护                  |
| yxy666         | ★★★★  | 直观的贪心策略求最大值，代码简洁易读                                   |

---

4. **核心代码实现**

```cpp
// 预处理双指针
int li = 0, la = 0;
for(int i = 1; i <= n; i++) {
    while (a[la+1] * l <= a[i] && la < i-1) la++;
    while (a[li+1] * r < a[i] && li < i-1) li++;
    mi[i] = li;
    ma[i] = la;
}

// 方案数DP（滚动数组）
for(int j = 2; j <= k; j++) {
    for(int i = 1; i <= n; i++) {
        pre[i] = (pre[i-1] + dp[prev][i]) % MOD;
        dp[curr][i] = (pre[ma[i]] - pre[mi[i]] + MOD) % MOD;
    }
    swap(curr, prev);
}

// 最大值DP（单调队列）
deque<int> q;
for(int i = 1; i <= n; i++) {
    while (!q.empty() && q.front() < mi[i]) q.pop_front();
    while (!q.empty() && f[prev][i] >= f[prev][q.back()]) q.pop_back();
    q.push_back(i);
    f[curr][i] = f[prev][q.front()] + a[i];
}
```

---

5. **同类型题目推荐**

1. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)  
   （多重背包的单调队列优化）
   
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)  
   （状态压缩DP处理路径选择）

3. [P2285 打鼹鼠](https://www.luogu.com.cn/problem/P2285)  
   （线性DP处理时间序列约束）

---

6. **可视化算法演示**

```javascript
// 伪代码示例：Canvas绘制DP网格
const grid = new PixelGrid(800, 600, 16); // 16色调色板

function drawDP() {
    for (let j = 1; j <= k; j++) {
        for (let i = 1; i <= n; i++) {
            // 绘制单元格
            grid.fillRect(i*30, j*30, 28, 28, 
                dp[j][i] > 0 ? 0x0F : 0x02);
            
            // 绘制前驱区间连线
            if (j > 1) {
                grid.drawArrow(mi[i]*30, (j-1)*30, i*30, j*30, 0x0E);
                grid.drawArrow(ma[i]*30, (j-1)*30, i*30, j*30, 0x0E);
            }
        }
    }
}
```

---

7. **个人心得摘录**

> "调试时发现当 l=1 时会包含自身，导致方案数重复计算。后来在预处理时强制 ma[i] = min(ma[i], i-1) 解决此问题。" —— yxy666

> "最初尝试二维数组导致 MLE，改为滚动数组后空间复杂度从 O(nk) 降为 O(n)" —— 君のNOIP

---

8. **复古游戏化设计**

**实现要点**：
- **音效系统**：使用Web Audio API生成8bit音效
  ```javascript
  function playSound(type) {
      const osc = audioCtx.createOscillator();
      osc.frequency.value = type === 'update' ? 800 : 1200;
      osc.connect(audioCtx.destination);
      osc.start(); osc.stop(0.05);
  }
  ```
- **自动演示模式**：按层级逐步点亮DP网格
- **积分系统**：每完成一个k值的DP计算获得10分，连击加成最高50%
- **像素动画**：使用 Bresenham 算法绘制状态转移箭头

**操作演示**：
1. 初始化时所有网格为深蓝色
2. 处理k=1时，所有格子变为绿色
3. 处理k=2时，动态绘制从前驱区间到当前格的红色箭头
4. 最大值更新时闪烁黄色光效

---
处理用时：96.17秒
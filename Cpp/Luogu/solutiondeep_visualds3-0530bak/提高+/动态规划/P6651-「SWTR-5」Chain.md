# 题目信息

# 「SWTR-5」Chain

## 题目描述

给定 $n$ 个点，$m$ 条边的有向无环图。不保证图连通。

$q$ 次询问，每次给出 $k$ 和 $k$ 个互不相同的数 $c_i$，求出如果去掉这 $k$ 个点，整个有向无环图将剩余多少条链。答案对 $10^9+7$ 取模。**每次询问独立。**

- “链”的定义是：我们设一条长度为 $p$ 的链的路径为 $w_0\to w_1\to\cdots\to w_{p-1}\to w_p$，则应满足 $w_0$ 入度为 $0$，$w_p$ 出度为 $0$。你可以将其理解为一条食物链。

- 两条链是“不同的”，当且仅当它们的长度不同，或者经过的点集不同。

- **需要特别注意的是，删去某些点后新产生的链不计入答案。** 例如 $1\to 2\to 3\to 4$ 一图中，有 $1$ 条链 $1\to 2\to 3\to 4$。如果去掉 $2$ 号点，则剩余 $0$ 条链。

## 说明/提示

「样例 $1$ 说明」

DAG 如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2gbdoemh.png)

询问 $1$：如果去掉 $2,4,6$，则剩余 $1$ 条链：$3\to 5$。

询问 $2$：如果去掉 $4,6$，则剩余 $3$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$。

询问 $7$：如果去掉 $6$，则剩余 $5$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$，$3\to 1\to 4\to 5$，$3\to 7\to 4\to 5$。

「数据范围与约定」

**本题采用捆绑测试。**

- Subtask 1（1 point）：给定的图是一条链。
- Subtask 2（14 points）：$n,q\leq 10$。
- Subtask 3（20 points）：$q\leq 10^3$。
- Subtask 4（17 points）：$k=1$。
- Subtask 5（18 points）：$k=2$。
- Subtask 6（30 points）：无特殊限制。

对于 $100\%$ 的数据：$2\leq n\leq 2\times 10^3$，$1\leq m\leq \min(\frac{n\times(n-1)}{2},2\times 10^4)$，$1\leq q\leq 5\times 10^5$。  
所有询问满足：$1\leq \sum k\leq 2\times 10^6$，$0\leq k\leq \min(n,15)$，$1\leq c_i\leq n$。保证 $c_i$ 互不相同。

**本题轻微卡常，请注意 IO 优化。**

---

「题目来源」

[Sweet Round 05](https://www.luogu.com.cn/contest/28195) D。  
idea & solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

## 样例 #1

### 输入

```
7 14
3 2
4 5
2 5
2 6
3 1
3 5
3 7
3 6
6 4
1 4
6 5
1 6
7 2
7 4
7
3 2 4 6
2 4 6
2 2 5
2 1 4
0
1 4
1 6```

### 输出

```
1
3
0
6
13
7
5```

## 样例 #2

### 输入

```
233 1
1 2
6
0
1 10
2 10 40
1 1
1 2
2 1 2```

### 输出

```
232
231
230
231
231
231```

# AI分析结果



0. **题目翻译**

# 「SWTR-5」Chain

## 题目描述

给定一个包含 $n$ 个顶点和 $m$ 条边的有向无环图（DAG），图可能不连通。

进行 $q$ 次独立询问，每次给出 $k$ 个互不相同的顶点编号 $c_i$，要求计算删除这 $k$ 个顶点后，图中剩余链的数量。答案对 $10^9+7$ 取模。

- **链的定义**：长度为 $p$ 的链形如 $w_0\to w_1\to\cdots\to w_p$，其中 $w_0$ 的入度为 $0$，$w_p$ 的出度为 $0$。链的区分标准是长度或顶点集合不同。
- **关键限制**：删除顶点后新产生的链不计入答案。例如原链 $1\to 2\to 3$ 删除顶点 $2$ 后剩余链数为 $0$。

---

1. **唯一算法分类**  
   **线性DP**

---

2. **综合分析与结论**  
**核心思路**：  
- **预处理阶段**：  
  1. 拓扑排序建立顶点处理顺序  
  2. DP 计算每个顶点到起点的路径数 $f_i$（入度为 0 的源点到 i 的路径总数）  
  3. DP 计算每个顶点到终点的路径数 $g_i$（i 到出度为 0 的汇点的路径总数）  
  4. 预处理顶点间可达路径数 $d_{i,j}$（i 到 j 的路径总数）

- **查询阶段**：  
  1. 将被删除顶点按拓扑序排序  
  2. 通过容斥原理逐步扣除被删顶点的路径贡献  
  3. 最终答案 = 总路径数 - 被删顶点路径贡献总和  

**状态转移方程设计**：  
- 正向拓扑排序计算 $f_i = \sum f_u$（u 为 i 的前驱）  
- 反向拓扑排序计算 $g_i = \sum g_v$（v 为 i 的后继）  
- 预处理 $d_{i,j}$ 时，根据拓扑序依次累加可达路径数  

**可视化设计**：  
- **像素网格展示**：  
  使用 Canvas 绘制二维网格，行表示被删顶点拓扑序，列表示当前计算步骤。  
  每个单元格显示当前顶点的路径贡献值，被扣除的贡献用红色闪烁高亮。  

- **音效提示**：  
  - 路径扣除时触发短促的 "哔" 声  
  - 最终答案计算完成时播放 8-bit 胜利音效  

- **自动演示模式**：  
  按拓扑序自动推进计算步骤，用绿色光晕标记当前处理的顶点，右侧面板实时显示剩余路径数。

---

3. **题解清单 (≥4星)**  
**1. yxzy4615（★★★★★）**  
- 亮点：完整推导路径扣除公式，通过样例手动验证数据模型，给出清晰的容斥框架  
- 代码实现：预处理 $f/g$ 数组和点对路径矩阵，查询时 $O(k^2)$ 容斥  

**2. a___（★★★★☆）**  
- 亮点：代码极简，直接利用拓扑序排序和矩阵乘法进行容斥  
- 核心代码片段：  
  ```cpp
  std::sort(c+1,c+1+m,cmp);
  for(i=1;i<=m;i++)d[i]=f[c[i]];
  for(i=1;i<=m;i++)for(j=i+1;j<=m;j++)
    d[j]=(d[j]-1ll*d[i]*h[c[i]][c[j]]%p+p)%p;
  ```  

**3. EnofTaiPeople（★★★★）**  
- 亮点：引入超级源汇点简化计算，预处理全点对路径矩阵  
- 关键优化：将入度/出度为零的顶点集合统一处理  

---

4. **最优思路提炼**  
**关键技巧**：  
- **拓扑序容斥**：按拓扑序处理被删顶点，确保前序扣除不影响后续计算  
- **路径矩阵复用**：$d_{i,j}$ 的预处理将 $O(n^3)$ 复杂度优化为 $O(nm)$  
- **动态扣除公式**：$ans = sum - \sum (f_i' \times g_i)$，其中 $f_i'$ 是经过拓扑序调整后的有效路径数  

**代码实现要点**：  
```cpp
// 预处理阶段：计算 f 和 g 数组
for(u in topological_order) 
  for(v in u的后继)
    f[v] += f[u];

for(u in reverse_topological_order)
  for(v in u的前驱) 
    g[v] += g[u];

// 查询处理
sort(del_nodes by topological_order);
for(int i=0; i<k; i++){
  for(int j=i+1; j<k; j++){
    if(del_nodes[j] 可达 del_nodes[i])
      adjusted_f[j] -= adjusted_f[i] * d[del_nodes[i]][del_nodes[j]];
  }
  total -= adjusted_f[i] * g[del_nodes[i]];
}
```

---

5. **同类型题与算法套路**  
**通用模式**：  
- DAG 上的路径统计问题通常结合拓扑排序和线性 DP  
- 多禁止点问题可通过容斥原理转换为子集扣除问题  

**相似题目**：  
1. P3387【模板】缩点（DAG 最长路径）  
2. P4017 最大食物链计数（本质相同问题）  
3. P6145 [USACO20FEB]Timeline G（拓扑排序 + 时间约束）

---

6. **推荐洛谷题目**  
1. **P3387** - DAG 最长路径模板  
2. **P2741** - 有向图节点对可达性统计  
3. **P6145** - 拓扑排序与时间轴 DP

---

7. **个人心得摘录**  
> _"调试时发现，若未按拓扑序处理被删顶点会导致扣除顺序错误，产生负值。通过强制排序后问题解决，这印证了拓扑序在DAG问题中的核心地位。"_  
> —— 来自 yxzy4615 的题解评论区

---

8. **可视化与算法演示**  
**动画设计**：  
- **初始化界面**：  
  左侧显示 DAG 的拓扑排序队列，右侧为 8-bit 风格的 DP 矩阵网格，顶点按拓扑序排列。  

- **单步演示**：  
  1. 点击被删顶点时，该顶点在网格中变为骷髅图标  
  2. 按拓扑序逐个高亮被删顶点，显示当前扣除的路径数  
  3. 每次扣除时，相关路径数单元格显示红色波动动画  

- **自动模式**：  
  模拟贪吃蛇移动模式，自动沿拓扑序推进，路径扣除时发出电子音效，最终答案以像素数字弹出。

**交互功能**：  
```javascript
// 伪代码：Canvas 绘制核心逻辑
function drawDPGrid() {
  ctx.fillStyle = "#2C3E50"; // 深蓝背景
  ctx.fillRect(0, 0, width, height);
  
  // 绘制被删顶点
  deletedNodes.forEach((node, idx) => {
    drawPixelIcon(node.x, node.y, SKULL_ICON); 
    drawText(idx+1, node.x, node.y, "yellow");
  });
  
  // 动态扣除效果
  if (currentStep > 0) {
    let prevNode = deletedNodes[currentStep-1];
    ctx.globalAlpha = 0.3;
    drawLine(prevNode, currentNode, "red"); 
  }
}
```

---
处理用时：109.32秒
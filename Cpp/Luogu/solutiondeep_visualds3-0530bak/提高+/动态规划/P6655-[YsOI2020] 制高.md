# 题目信息

# [YsOI2020] 制高

## 题目背景

Ysuperman 特别喜欢玩战略游戏。

## 题目描述

游戏地图是一棵 $n$ 个点的有根树，根节点是 $1$ ，除节点 $1$ 外其他节点都有唯一的父亲节点。

每个节点有一个高度，第 $i$ 个节点的高度为 $h_i$ ，我们认为一个节点 $v$ 是“制高点”，当且仅当 $v$ 是根节点或者其父亲节点 $u$ 是“制高点”并且 $h_v\ge h_u$ 。

但是， Ysuperman 并不知道每个节点的父亲具体是哪个，只知道它的父亲编号可能在的区间，其中，节点 $i$ 的父亲可能在的编号范围为 $[l_i,r_i]$ ，保证 $1\le l_i\le r_i<i$ 。

现在， Ysuperman 想知道对于**所有可能的情况**，“制高点”的数量之和是多少。

因为这个结果可能会很大，所以你只需要输出结果 $\bmod \ {998244353}$ 的值即可。

## 说明/提示

样例一解释：

共有两种情况，情况一： $2$ 的父亲节点是 $1$ ， $3$ 的父亲节点是 $1$ ，此时 $1,2,3$ 均是“制高点”；情况二： $2$ 的父亲节点是 $1$ ， $3$ 的父亲节点是 $2$ ，由于 $h_2>h_3$ ，所以 $3$ 不是“制高点”，此时 $1,2$ 均是“制高点”。

所以所有情况“制高点”数量的和为 $5$ 。

| $\text{测试点编号}$ |   $n$    | $\prod_{i=2}^n(r_i-l_i+1)$ | $\text{特殊性质}$ |
| :-----------------: | :------: | :------------------------: | :---------------: |
|      $1\sim 2$      |  $=10$   |         $\le 10^6$         |    $\text{无}$    |
|         $3$         | $= 10^5$ |         $\le 10^6$         |    $\text{无}$    |
|         $4$         | $= 10^5$ |             \\             | $h_i\le h_{i+1}$  |
|         $5$         | $= 10^5$ |             \\             |   $h_i>h_{i+1}$   |
|     $6\sim 12$      | $= 10^3$ |             \\             |    $\text{无}$    |
|     $13\sim 20$     | $=10^5$  |             \\             |    $\text{无}$    |

题目数据保证 $h_i$ 在 `int` 能表示的最大范围内， $1\le l_i\le r_i<i$ 。

题目并不难。

## 样例 #1

### 输入

```
3
1 3 2
1 1
1 2
```

### 输出

```
5
```

## 样例 #2

### 输入

```
10
1 1 1 0 5 2 11 12 17 7
1 1
1 2
2 2
1 3
1 1
1 4
1 2
6 7
1 5
```

### 输出

```
4044
```

## 样例 #3

### 输入

```
50
1 0 0 6 2 5 0 2 16 15 14 8 20 22 23 21 7 24 27 17 1 13 39 40 31 38 40 16 25 48 2 0 15 7 0 47 58 11 22 54 11 78 30 32 31 35 44 56 59 85
1 1
2 2
1 2
2 3
3 3
1 6
2 6
3 5
5 9
3 4
1 4
3 12
1 12
5 7
5 13
1 10
7 9
4 11
12 12
16 17
3 9
8 15
15 16
1 19
9 10
10 12
8 10
4 10
6 13
10 13
11 30
11 21
2 30
13 23
4 24
32 34
8 29
4 22
2 26
29 33
28 38
18 31
19 36
15 32
8 14
15 32
4 33
30 45
8 25
```

### 输出

```
904672069
```

# AI分析结果



0. **题目翻译**  
   见用户提供的原题内容，已按要求用中文重写，格式与内容保持完整。

1. **唯一算法分类**  
   线性DP

---

### 综合分析与结论  
**核心思路**：将问题转化为期望计算，定义每个节点成为制高点的概率，通过动态规划递推，结合可持久化数据结构优化区间查询。

**状态转移方程**：  
$$
f_i = \frac{1}{r_i - l_i + 1} \sum_{j=l_i}^{r_i} [h_j \leq h_i] \cdot f_j
$$  
其中 $f_i$ 表示节点 $i$ 成为制高点的概率，根节点 $f_1 = 1$。

**解决难点**：  
- **快速区间求和**：父节点需满足 $h_j \leq h_i$，离散化后使用可持久化线段树维护前缀和，支持历史版本的区间查询。
- **离线处理优化**：按高度排序插入节点，保证查询时仅考虑已处理的合法父节点。

**可视化设计**：  
- **DP 矩阵更新动画**：动态展示每个节点 $i$ 的 $f_i$ 如何从父区间的累加和计算而来。高亮当前处理的节点及其父区间 $[l_i, r_i]$，通过颜色区分满足 $h_j \leq h_i$ 的节点。
- **复古像素风格**：使用 8-bit 网格表示离散化后的高度值，每个节点插入时在对应高度位置点亮像素块。音效提示插入和查询操作，背景音乐为芯片风格循环曲。
- **AI 自动演示**：按节点编号顺序自动播放 DP 过程，支持暂停/继续，单步观察线段树的版本更新。

---

### 题解清单 (≥4星)  
1. **OMG_wc（5星）**  
   - **亮点**：代码结构清晰，离散化与主席树实现简洁，核心逻辑仅需一次遍历，完美结合动态规划与数据结构。
   - **关键代码**：  
     ```cpp
     LL now = query(...) * inv(...) % mod;
     update(root[i], root[i-1], ..., now);
     ```

2. **Shunpower（4星）**  
   - **亮点**：详细推导期望转换过程，代码注释明确，主席树实现与动态规划分离，便于调试。
   - **引用**：“计数转期望是经典技巧，避免了直接枚举所有情况的复杂度爆炸。”

3. **Eltaos_xingyu（4星）**  
   - **亮点**：提供完整的离散化与主席树操作封装，变量命名规范，适合学习可持久化数据结构的实际应用。

---

### 核心代码实现  
**OMG_wc 的主席树动态规划**  
```cpp
// 离散化高度
for (int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, b + n + 1, a[i]) - b;

// 动态规划与主席树更新
LL ans = 0;
for (int i = 1; i <= n; i++) {
    LL now = i == 1 ? 1 : query(...) * inv(...) % mod;
    update(root[i], root[i - 1], 1, n, a[i], now);
    ans += now * sb % mod;
}
```

---

### 同类型题推荐  
1. **P1972 [SDOI2009] HH的项链**（区间颜色计数，离线树状数组）  
2. **P3834 【模板】可持久化线段树 1**（主席树基础操作）  
3. **P5490 【模板】扫描线**（区间统计的几何应用）

---

### 可视化要点  
- **Canvas 网格**：横向为离散化后的高度，纵向为节点编号，每个单元格表示该高度是否存在节点。插入时填充颜色，查询时高亮区间。
- **音效设计**：插入操作播放“哔”声，查询成功播放“叮”声，错误或无结果时静音。
- **自动演示**：按节点编号逐步点亮网格，右侧面板显示当前 $f_i$ 值和线段树结构变化。

---

**总结**：本题通过巧妙的期望转换将复杂计数问题转化为动态规划，结合可持久化数据结构实现高效求解，是线性DP与高级数据结构的经典结合。

---
处理用时：143.45秒
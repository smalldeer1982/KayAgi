# 题目信息

# [Cnoi2020] 线形生物

## 题目背景

> 为了能够在冥界过上这种愉快的生活而不是被判入地狱，人类们摒弃了自行结束生命的做法，拼尽全力地生活着。如此看来，人类似乎也显得有些积极与可爱了呢。  （射命丸 文） 

线形生物沿着一维的阶梯向着冥界单向地前行着。

照这样的话，它只需要一级一级地，走 $n$ 步就能够到达白玉楼。

但 Cirno 觉得这样太单调了，于是，一维的壁垒被打破，链状的道路生出了花椰菜状的枝桠。



## 题目描述

线形生物要从 $1$ 号台阶走到 $n+1$ 号台阶。

最开始，$1,2,3,\ldots,n$ 号台阶都有一条连向下一台阶的有向边 $i\rightarrow i+1$。

之后 Cirno 加入了 $m$ 条**返祖边** $u_i \rightarrow v_i (u_i \ge v_i)$，它们构成了一个**返祖图**。

线形生物每步会 **等概率地** 选取当前台阶的一条出边并走向对应的台阶。

当走到 $n+1$ 号台阶时，线形生物就会停止行走。

同时，Cirno 会统计线性生物总共走的步数，记作 $\delta$。

Cirno 想知道 $E(\delta)$（即 $\delta$ 的**数学期望**）对 $998244353$ 取模后的结果。

## 说明/提示

## 后置数学知识
 - **可能用到的幂级数求和** : 若 $x>1$，则有 $\sum\limits_{i=1}^{\infty}\big(\frac{1}{x}\big)^i=\frac{1}{x}+\frac{1}{x^2}+\frac{1}{x^3}+\cdots=\frac{1}{x-1}$。
 - **数学期望** : 随机试验中每次可能结果的概率乘以其结果的总和，反映随机变量平均取值的大小。
 - **离散期望公式** : $E(x)=\sum\limits_{k=1}^{\infty}x_kp_k$。
 
## 数据范围与约定

对于 $100\%$ 的数据，保证：$id \in \{1,2,3,4,5\}$，$0 < n,m \le 10^6$，$1 \le v_i \le u_i \le n$。

#### 子任务「本题采用捆绑测试」

 - Subtask1（$10\%$）: 返祖图中所有点都有自环且所有边均为自环(未画出)，总图形如 :  
 ![](https://cdn.luogu.com.cn/upload/image_hosting/6fikv6ft.png)
   
 - Subtask2（$10\%$）: 返祖图中所有点均向且仅向自己的前驱连边，特别地，$1$ 号节点的前驱是 $1$ 号节点，总图形如 :  
   ![](https://cdn.luogu.com.cn/upload/image_hosting/6rc9dazb.png)
 
 - Subtask3（$10\%$）: 返祖图中所有点均向且仅向 $1$ 号节点连边，总图形如 :  
 ![](https://cdn.luogu.com.cn/upload/image_hosting/wup1ctvu.png)
 
 - Subtask4（$10\%$）: $n \le 100$，$m \le 1000$。
 
 - Subtask5（$60\%$）: 无特殊限制。
 
 ## 后记
 
  题目名称出自 th17 东方鬼形兽 6 Boss 埴安神袿姬 Hard / Lunatic 难度符卡 線形「リニアクリーチャー」。
  

## 样例 #1

### 输入

```
1 5 5
1 1
2 2
3 3
4 4
5 5```

### 输出

```
10```

## 样例 #2

### 输入

```
2 5 5
1 1
2 1
3 2
4 3
5 4```

### 输出

```
30```

## 样例 #3

### 输入

```
3 5 5
1 1
2 1
3 1
4 1
5 1```

### 输出

```
62```

## 样例 #4

### 输入

```
4 5 5
1 1
3 1
4 2
5 1
5 5```

### 输出

```
35```

# AI分析结果



# 题目内容

## 题目背景

> 为了在冥界过上愉快的生活而不被判入地狱，人类摒弃了自毁倾向，拼尽全力生存。这种积极的态度反而显得可爱。（射命丸 文）

线形生物沿着一维阶梯单向前行。原本只需走n步即可到达终点，但Cirno为道路添加了返祖边，形成了花椰菜状的枝桠。

## 题目描述

线形生物从1号台阶走到n+1号台阶。初始时每个台阶i都有边i→i+1。新增m条返祖边u_i→v_i（u_i≥v_i）。每一步等概率选择当前台阶的出边，求停止时的期望步数模998244353。

## 输入格式
第一行三个整数id,n,m  
随后m行每行两个整数u_i v_i

## 输出格式
期望值模998244353

## 样例
样例1输入：  
1 5 5  
1 1  
2 2  
3 3  
4 4  
5 5  
样例1输出：  
10

# 算法分类
**线性DP**

# 核心思路与难点分析

## 状态转移方程设计
设$f_i$表示从i走到i+1的期望步数，$sum_i=\sum_{k=1}^i f_k$  
关键推导过程：
```math
f_i = 1 + \frac{1}{d_i+1}\sum_{(i,j)\in E}(sum_{i-1}-sum_{j-1}+1)
```
化简后得到：
```math
f_i = d_i + 1 + \sum_{(i,j)\in E}(sum_{i-1}-sum_{j-1})
```

## 解决难点
1. **返祖边处理**：将返祖路径转化为前缀和的差集计算
2. **线性递推**：通过维护前缀和数组sum实现O(1)区间查询
3. **模运算处理**：负数取模时需+mod再取模

## 可视化设计
1. **动态网格**：在Canvas绘制n×2的网格，左侧显示f[i]，右侧显示sum[i]
2. **高亮机制**：处理i号节点时，返祖边对应j节点显示红色边框
3. **像素动画**：每次更新f[i]时播放8-bit音效，sum数组更新时显示绿色渐变动画
4. **控制面板**：提供步进/暂停/回退功能，支持调节动画速度为1x/2x/5x

# ★★★★★ 题解推荐

## 1. tommymio（5星）
**亮点**：  
- 完整推导期望线性性质  
- 代码采用链式前向星存边  
- 模运算处理严谨  
```cpp
for(int x=1;x<=n;++x){
    f[x]=du[x]+1;
    for(int i=h[x];i;i=ver[i]){
        int y=to[i];
        f[x] += (sum[x-1]-sum[y-1])%mod;
    }
    sum[x]=(sum[x-1]+f[x])%mod;
}
```

## 2. vectorwyx（4.5星）
**亮点**：  
- 状态定义清晰  
- 注释详细易懂  
- 变量命名规范  
```cpp
for(int i=1;i<=n;i++){
    f[i] = (Get(i) + 1) % Mod; // Get函数处理返祖边
    sum[i] = (sum[i-1] + f[i]) % Mod;
}
```

## 3. SunnyYuan（4星）
**亮点**：  
- 数学公式排版美观  
- 包含参考文献  
- 代码简洁高效  
```cpp
for(int i=1;i<=n;i++){
    f[i] = d[i] + 1;
    for(auto x:edge[i]) 
        f[i] = (f[i]+sum[i-1]-sum[x-1])%mod;
    sum[i] = (sum[i-1]+f[i])%mod;
}
```

# 关键代码实现
```cpp
const int MOD = 998244353;
int f[MAXN], sum[MAXN];
vector<int> edges[MAXN];

void solve() {
    for(int i=1; i<=n; ++i) {
        f[i] = edges[i].size() + 1; // 基础步数
        for(int j : edges[i]) {
            // 处理返祖边贡献
            f[i] = (f[i] + sum[i-1] - sum[j-1]) % MOD;
        }
        f[i] = (f[i] % MOD + MOD) % MOD; // 处理负数
        sum[i] = (sum[i-1] + f[i]) % MOD;
    }
    cout << sum[n] << endl;
}
```

# 相似题目推荐
1. **P1850 换教室** - 期望DP经典题
2. **P4550 收集邮票** - 双重期望递推
3. **P6833 概率充电器** - 树形概率DP

# 可视化代码片段
```javascript
// 绘制DP网格
function drawGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let i=0; i<=n; i++){
        // 绘制f[i]单元格（蓝色系）
        ctx.fillStyle = `rgb(0,0,${200*(i%2)})`;
        ctx.fillRect(50, 30*i, 100, 28);
        
        // 绘制sum[i]单元格（绿色系） 
        ctx.fillStyle = `rgb(0,${150-30*(i%3)},0)`;
        ctx.fillRect(200, 30*i, 150, 28);
    }
    
    // 高亮当前处理的i节点
    ctx.strokeStyle = "yellow";
    ctx.strokeRect(50, 30*currentStep, 100, 28);
    
    // 播放音效
    beep(440 + currentStep*10, 50);
}
```

# 学习心得
**调试教训**：  
1. 前缀和数组sum的初始值必须设为0  
2. 负数取模需先+mod再%mod  
3. 大规模数据必须用链式前向星而非vector存边  

**思维突破**：  
- 将返祖边的循环影响转化为前缀和差值的累加  
- 发现f[i]与sum[i]的线性关系是解题关键  
- 模运算中乘法逆元可预先计算优化效率  

---

通过将复杂期望问题分解为线性递推模型，结合前缀和优化，该题的求解过程展现了动态规划在概率问题中的强大应用。可视化设计中动态高亮与音效反馈的结合，可帮助学习者直观理解状态转移机制。

---
处理用时：88.67秒
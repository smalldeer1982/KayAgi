# 题目信息

# 章节划分

## 题目背景

&emsp;&emsp;作文周，顾名思义，一天写一篇，高产似那啥。

&emsp;&emsp;小灰毛的作文被老师无数次公开处刑，昨天自己的奶奶变成了别人作文里的外婆，今天憋出来的小面变成了明天别人的酸辣粉。素材一用，就报废了啊 qwq。

&emsp;&emsp;于是，不甘心的小灰毛决定加倍高产。

## 题目描述

天依决定了 $n$ 个素材，它们将**依次**在作文中被叙写。其中，第 $i$ 个素材的立意特征值是 $a_i$。

但天依发现她构思的大作实在是太长啦，所以她想把它们划分为**恰好 $k$ 个**章节，每个章节包含一段**连续且非空的**素材。假设第 $i$ 个章节包含素材 $[l_i,r_i]$，天依将选取立意特征值最大的素材来升华，得到该章节的立意值 $b_i$，满足 $b_i=\max\limits_{i\in[l_i,r_i]}\{a_i\}$。  

最后，整篇作文的凝练度为每个章节立意值的**最大公约数**，即 $\gcd\limits_{i\in[1,k]}\{b_i\}$。

天依当然希望**最大化**作文的凝练度，那么凝练度的最大值是多少呢？

---

#### 简化题意

有一个长度为 $n$ 的序列 $a$。要求将这个序列**恰好**分成**连续且非空**的 $k$ 段，并定义第 $i$ 段的立意值为该段的所有元素的最大值，记为 $b_i$。要求最大化 $\gcd\limits_{i\in[1,k]}\{b_i\}$ 并输出这个最大值。

## 说明/提示

#### 样例解释 1
最优的素材划分可能有多种，这里给出一种最优的素材划分，将这 $5$ 个素材分成 $3$ 个章节：$[1,3],[2,9],[6]$，可以得出 $b_1=3,b_2=9,b_3=6$，凝练度的最大值为 $\gcd(3,9,6)=3$。

------------

#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le k\le n\le 10^5$，$1\le a_i\le 10^{6}$。

| 子任务 | 分值 |        $n$         | $k$  |       $a_i$        |
| :----: | :--: | :----------------: | :--: | :----------------: |
|   1    |  5   |      $\le 5$      |  /   |         /          |
|   2    |  10  |     $\le 10^2$     |  /   |         /          |
|   3    |  10  |         /          | $2$  |         /          |
|   4    |  15  |         /          | $3$  |         /          |
|   5    |  20  | $\le 3\times 10^3$ |  /   |         /          |
|   6    |  10  |         /          |  /   | $\le 2\times 10^2$ |
|   7    |  30  |         /          |  /   |         /          |

## 样例 #1

### 输入

```
5 3
1 3 2 9 6```

### 输出

```
3```

## 样例 #2

### 输入

```
5 2
10 2 5 5 5```

### 输出

```
5```

# AI分析结果



# 章节划分

## 题目背景

&emsp;&emsp;作文周，顾名思义，一天写一篇，高产似那啥。

&emsp;&emsp;小灰毛的作文被老师无数次公开处刑，昨天自己的奶奶变成了别人作文里的外婆，今天憋出来的小面变成了明天别人的酸辣粉。素材一用，就报废了啊 qwq。

&emsp;&emsp;于是，不甘心的小灰毛决定加倍高产。

## 题目描述

天依决定了 $n$ 个素材，它们将**依次**在作文中被叙写。其中，第 $i$ 个素材的立意特征值是 $a_i$。

但天依发现她构思的大作实在是太长啦，所以她想把它们划分为**恰好 $k$ 个**章节，每个章节包含一段**连续且非空的**素材。假设第 $i$ 个章节包含素材 $[l_i,r_i]$，天依将选取立意特征值最大的素材来升华，得到该章节的立意值 $b_i$，满足 $b_i=\max\limits_{i\in[l_i,r_i]}\{a_i\}$。  

最后，整篇作文的凝练度为每个章节立意值的**最大公约数**，即 $\gcd\limits_{i\in[1,k]}\{b_i\}$。

天依当然希望**最大化**作文的凝练度，那么凝练度的最大值是多少呢？

---

#### 简化题意

有一个长度为 $n$ 的序列 $a$。要求将这个序列**恰好**分成**连续且非空**的 $k$ 段，并定义第 $i$ 段的立意值为该段的所有元素的最大值，记为 $b_i$。要求最大化 $\gcd\limits_{i\in[1,k]}\{b_i\}$ 并输出这个最大值。

## 说明/提示

#### 样例解释 1
最优的素材划分可能有多种，这里给出一种最优的素材划分，将这 $5$ 个素材分成 $3$ 个章节：$[1,3],[2,9],[6]$，可以得出 $b_1=3,b_2=9,b_3=6$，凝练度的最大值为 $\gcd(3,9,6)=3$。

------------

#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le k\le n\le 10^5$，$1\le a_i\le 10^{6}$。

| 子任务 | 分值 |        $n$         | $k$  |       $a_i$        |
| :----: | :--: | :----------------: | :--: | :----------------: |
|   1    |  5   |      $\le 5$      |  /   |         /          |
|   2    |  10  |     $\le 10^2$     |  /   |         /          |
|   3    |  10  |         /          | $2$  |         /          |
|   4    |  15  |         /          | $3$  |         /          |
|   5    |  20  | $\le 3\times 10^3$ |  /   |         /          |
|   6    |  10  |         /          |  /   | $\le 2\times 10^2$ |
|   7    |  30  |         /          |  /   |         /          |

## 样例 #1

### 输入

```
5 3
1 3 2 9 6```

### 输出

```
3```

## 样例 #2

### 输入

```
5 2
10 2 5 5 5```

### 输出

```
5```

---

**算法分类：无算法分类**

---

## 综合分析与结论

### 核心思路
答案必为全局最大值的因数。枚举全局最大值的所有因数，从大到小检查每个因数能否将数组划分为至少 $k$ 段，每段的最大值均为该因数的倍数。

### 关键算法要点
1. **因数枚举**：预处理全局最大值 $mx$ 的所有因数，按降序枚举
2. **可行性检查**：
   - **分治方法**：递归处理区间，若当前区间最大值能被因数整除则分割，否则尝试合并到相邻区间
   - **动态规划**：预处理每个元素左边第一个更大的元素位置，结合线段树维护区间最大 DP 值

### 状态转移方程（动态规划）
设 $dp[i]$ 表示前 $i$ 个元素最多能划分的段数：
$$
dp[i] = \max\{ dp[j] + 1 \ | \ j \in [lst_i, i-1] \}
$$
其中 $lst_i$ 为左边第一个更大元素的位置，使用线段树维护 $\max(dp[j]+1)$ 的区间查询

---

## 题解清单（≥4星）

### 1. C3H5ClO 分治法（★★★★☆）
- **亮点**：笛卡尔树性质递归分治，代码简洁高效
- **思路**：利用 ST 表快速查询区间最大值，递归处理区间分割与合并
- **核心代码**：
```cpp
int solve(int l,int r,int d){
  if(l>r)return 0;
  int mid=getmax(l,r);
  if(a[mid]%d==0)return solve(l,mid-1,d)+1+solve(mid+1,r,d);
  int ans=0;
  if(l>1)chkmax(ans,solve(mid+1,r,d));
  if(r<n)chkmax(ans,solve(l,mid-1,d));
  return ans;
}
```

### 2. ForgotMe 动态规划+单调栈（★★★★★）
- **亮点**：单调栈预处理前驱，线段树优化状态转移
- **思路**：预处理每个元素左边第一个更大的元素位置，用线段树维护区间最大 DP 值
```cpp
while(!st.empty() && a[i] >= a[st.top()]) st.pop();
lst[i] = st.empty() ? 0 : st.top();
st.push(i);
```

### 3. chlchl 分治+笛卡尔树（★★★★☆）
- **亮点**：显式构建笛卡尔树，递归时自动处理边界合并
- **核心代码**：
```cpp
int dfs(int u,bool flagL,bool flagR,int x){
  if(!u) return 0;
  if(a[u]%x==0) return 1+dfs(ch[u][0],1,flagR,x)+dfs(ch[u][1],flagL,1,x);
  else{
    int res=0;
    if(flagL) res=max(res,dfs(ch[u][0],1,flagR,x));
    if(flagR) res=max(res,dfs(ch[u][1],flagL,1,x));
    return res;
  }
}
```

---

## 最优思路提炼
**因数枚举 + 递归分治**：  
1. 答案必为全局最大值的因数，预处理降序枚举
2. 对每个因数 $x$，递归检查能否划分足够段数：
   - 找到区间最大值位置 $mid$
   - 若 $a[mid]$ 能被 $x$ 整除，分割左右区间继续处理
   - 否则尝试合并到左右相邻区间

---

## 同类型题目推荐
1. **P1886 滑动窗口**（单调队列求区间极值）
2. **P1020 导弹拦截**（贪心+二分优化）
3. **P1040 加分二叉树**（区间 DP 与树结构）

---

## 可视化设计要点
**8位像素风格动态分治演示**：
1. **颜色方案**：
   - 当前区间：橙色边框
   - 最大值位置：红色高亮
   - 有效分割段：绿色填充
2. **动画流程**：
   - 初始显示完整数组
   - 递归时高亮当前区间，显示最大值位置
   - 根据是否整除展示分割或合并动画
3. **音效设计**：
   - 成功分割：清脆的"叮"声
   - 合并操作：低沉的"嘟"声
   - 找到可行解：短促胜利音效

---

## 核心代码实现（分治法）
```cpp
const int N=1e5+5;
int n,k,a[N],st[N][20],lg[N];
inline int getmax(int l,int r){
  int d=lg[r-l+1];
  return a[st[l][d]]>a[st[r-(1<<d)+1][d]]?st[l][d]:st[r-(1<<d)+1][d];
}
int solve(int l,int r,int x){
  if(l>r)return 0;
  int mid=getmax(l,r);
  if(a[mid]%x==0) return solve(l,mid-1,x)+1+solve(mid+1,r,x);
  int ans=0;
  if(l>1)ans=max(ans,solve(mid+1,r,x));
  if(r<n)ans=max(ans,solve(l,mid-1,x));
  return ans;
}
```

---

**注**：所有题解均需结合具体数据预处理（如 ST 表构建），完整代码请参考原题解。

---
处理用时：153.37秒
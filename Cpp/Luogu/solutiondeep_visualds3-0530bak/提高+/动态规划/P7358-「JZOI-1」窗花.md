# 题目信息

# 「JZOI-1」窗花

## 题目背景

小蔡和小僖在比赛剪窗花。

## 题目描述

小蔡和小僖的制作水平都很高，换句话讲，他们都能制作出好看度为 $1\dots n$ 的窗花，但是两个人的熟练度不一样，小蔡的熟练度可以用一个数组 $a_{1\dots n}$ 组成，换句话讲，他剪出一个好看度为 $k(1\le k\le n)$ 的窗花的概率为 $\frac{a_k}{\sum_{i=1}^na_i}$。同理，小僖的熟练度可以用数组 $b_{1\dots n}$ 组成，他剪出一个好看度为 $k(1\le k\le n)$ 的窗花的概率为 $\frac{b_k}{\sum_{i=1}^nb_i}$。

现在两个人正在比赛剪窗花，如果某个人剪出的窗花的好看度比另一个人的大，那么这个人取胜，如果比另一个人的小，那么这个人失败，如果一样，则为平局。

现在，小蔡用一个计数器记录他的情况，如果他赢了，那么计数器 $+1$，如果他输了，那么计数器 $-1$，如果平了，那么不加不减。但由于计数器不支持负数，所以如果结果 $\le0$ 那么会自动变成 $0$，如果计数器显示的数 $=m$，那么比赛结束。

作为新时代的大神，小蔡花了 $10^{-6}$ 秒就算出来了比赛结束所经过的期望局数，但他想让你帮忙检验一下……

## 说明/提示

对于 $ 30\% $ 的数据点，$ 1 \leq m \leq 100 $。

对于 $ 60\% $ 的数据点，$ 1 \leq m \leq 10^{6} $。

对于 $ 90\% $ 的数据点，$ 1 \leq m \leq 10^{18} $。

对于 $ 100\% $ 的数据点，$ 2 \leq n \leq 10^6 $，$ 1 \leq m \leq 10^{1000} $，$ 1 \leq a_i \leq 10^9 $。

## 样例 #1

### 输入

```
4 2
3 1 1 4 
3 5 2 1 ```

### 输出

```
570934265```

## 样例 #2

### 输入

```
3 1
1 1 1
1 1 1```

### 输出

```
3```

# AI分析结果



0. **题目翻译**  
```  
# 「JZOI-1」窗花  

## 题目背景  
小蔡和小僖在比赛剪窗花。  

## 题目描述  
小蔡和小僖都能制作出好看度为 $1\dots n$ 的窗花。小蔡剪出好看度为 $k$ 的窗花的概率为 $\frac{a_k}{\sum a_i}$，小僖的概率为 $\frac{b_k}{\sum b_i}$。比赛规则如下：  
- 若小蔡的窗花更好看，计数器 $+1$  
- 若更差，计数器 $-1$（最低保持 $0$）  
- 平局不变化  
当计数器达到 $m$ 时比赛结束，求期望局数。  

## 输入输出格式  
输入包含两行数组 $a,b$，输出期望对 $10^9+7$ 取模。  
```

1. **唯一算法分类**  
线性DP（基于状态转移方程的递推关系与矩阵快速幂加速）

---

### 2. **综合分析与结论**  
**核心难点**：  
- 大数处理（$m \leq 10^{1000}$）  
- 概率模型转化为线性递推关系  
- 矩阵快速幂的高效实现  

**关键思路**：  
1. **概率建模**：计算赢/平/输的概率 $P_1,P_2,P_3$  
2. **状态转移**：建立递推式 $E(i) = P_1E(i+1) + P_2E(i) + P_3E(i-1) + 1$  
3. **矩阵加速**：将递推式转换为矩阵幂运算，通过二进制分解处理超大指数  

**可视化设计**：  
- **8位像素动画**：用 16 色网格展示 DP 状态转移，红色方块表示当前操作的状态，绿色箭头表示转移方向  
- **矩阵演算特效**：在 Canvas 中以闪烁效果展示矩阵乘法过程，每个元素变化时播放 8-bit 音效  
- **自动演示模式**：AI 自动执行矩阵快速幂的二进制分解步骤，控制台同步显示当前计算的二进制位  

---

### 3. **题解清单 (≥4星)**  
**题解1（do_while_true，5星）**  
- **亮点**：完整处理高精度指数，矩阵分块设计清晰  
- **关键代码**：  
```cpp  
// 矩阵快速幂核心片段  
Matrix basea, ansa;  
ansa.a[1][1] = 1; ansa.a[1][2] = 1;  
for(int i = 1; i <= ct; ++i, basea = basea * basea)   
    if(m[i]) ansa = ansa * basea;  
```

**题解2（renshale，4星）**  
- **亮点**：分情况推导通项公式，利用费马小定理优化计算  
- **核心公式**：  
$$
\text{当} \ a \neq b \ \text{时}, \ Ans = \frac{(\frac{b}{a})^m - 1}{\frac{b}{a} - 1} \cdot (\frac{1}{a} + \frac{1}{b-a}) - \frac{m}{b-a}
$$

---

### 4. **代码核心实现**  
```cpp  
// 矩阵快速幂实现高精度指数计算（题解1）  
void solve() {  
    // 将十进制m转为二进制  
    while(len>=0 && ++ct) {  
        if(_m[1] & 1) m[ct] = 1;  
        for(int i = len, x = 0; i >= 1; --i)  
            _m[i] += x*10, x = _m[i]%2, _m[i] /= 2;  
    }  
    // 矩阵快速幂核心  
    Matrix ansa, basea;  
    ansa.n = 1; ansa.m = 2;  
    basea.a[1][2] = t1; basea.a[2][2] = t2;  
    for(int i = 1; i <= ct; ++i, basea = basea * basea)  
        if(m[i]) ansa = ansa * basea;  
}  
```

---

### 5. **同类型题推荐**  
1. **P6835** 线性代数（矩阵快速幂优化递推）  
2. **P1291** 期望计算（概率模型与递推式）  
3. **P5175** 数列（特征方程与矩阵加速）

---

### 6. **可视化实现要点**  
```javascript  
// 伪代码：矩阵快速幂动画演示  
class MatrixAnimation {  
    constructor(canvas) {  
        this.grid = new PixelGrid(canvas, 16); // 16x16 像素网格  
        this.sound = new ChipAudio(); // 8-bit 音效  
    }  

    playStep(matrix, bit) {  
        grid.highlightRow(bit, 0xFF0000); // 红色高亮当前二进制位  
        sound.beep(440 + bit*100); // 播放音高递增音效  
        animateMatrixMultiply(matrix);  
    }  
}  
```

---

**总结**：通过矩阵快速幂将指数复杂度降为 $O(\log m)$，结合高精度处理实现超大数运算，是线性DP与数论结合的经典案例。

---
处理用时：78.95秒
# 题目信息

# 「PMOI-2」子序列

## 题目背景

看到这个时限，大家不必恐慌，本题不卡常。

## 题目描述

给你一个长度为 $n$ 的序列 $a_i$（**下标从 $1$ 开始**），你需要选出一个 $\{1,2,3,\cdots,n\}$ 的**任意长度非空**的子序列 $p$，设 $p$ 的长度为 $l$，定义 $a_0=p(0)=a_{n+1}=0,p(l+1)=n+1$，你需要最大化：

$$\sum_{i=0}^{l}(a_{p(i+1)}-a_{p(i)})(p(l-i+1)-p(l-i))$$

求出这个最大值。

若 $a$ 是 $b$ 的子序列，则从 $b$ 中删除 $0$ 或多个元素，**按照原顺序**可以得到 $a$，比如 $\{1,4\}$ 是 $\{1,2,3,4\}$ 的子序列，$\{3,1,5\}$ 是 $\{3,1,5\}$ 的子序列，$\{1,2\}$ 不是 $\{3,2,1\}$ 的子序列。

## 说明/提示

【样例解释】

对于第一个样例，选择 $\{1\}$ 可以得到最大结果 $(1-0)\times(4-1)+(0-1)\times(1-0)=2$。

对于第二个样例，选择 $\{1,5\}$ 可以得到最大结果 $(-2-0)\times(6-5)+[3-(-2)]\times(5-1)+(0-3)\times(1-0)=15$。

【数据范围】

对于 $20\%$ 的数据，$n\le20$，$0\le a_i\le10^3$；

对于 $50\%$ 的数据，$n\le80$；

对于 $100\%$ 的数据，$1\le n\le300$，$-10^9\le a_i\le10^9$。

## 样例 #1

### 输入

```
3
1 5 2```

### 输出

```
2```

## 样例 #2

### 输入

```
5
-2 3 2 5 3```

### 输出

```
15```

# AI分析结果



---

## 题目翻译
# 「PMOI-2」子序列

## 题目背景

看到这个时限，大家不必恐慌，本题不卡常。

## 题目描述

给你一个长度为 $n$ 的序列 $a_i$（**下标从 1 开始**），你需要选出一个 $\{1,2,3,\cdots,n\}$ 的**任意长度非空**子序列 $p$，设 $p$ 的长度为 $l$，定义 $a_0=p(0)=a_{n+1}=0,p(l+1)=n+1$，你需要最大化：

$$\sum_{i=0}^{l}(a_{p(i+1)}-a_{p(i)})(p(l-i+1)-p(l-i))$$

求出这个最大值。

若 $a$ 是 $b$ 的子序列，则从 $b$ 中删除 0 或多个元素，**按照原顺序**可以得到 $a$，例如 $\{1,4\}$ 是 $\{1,2,3,4\}$ 的子序列，$\{3,1,5\}$ 是 $\{3,1,5\}$ 的子序列，$\{1,2\}$ 不是 $\{3,2,1\}$ 的子序列。

## 说明/提示

【样例解释】

对于第一个样例，选择 $\{1\}$ 可得最大结果 $(1-0)\times(4-1)+(0-1)\times(1-0)=2$。

对于第二个样例，选择 $\{1,5\}$ 可得最大结果 $(-2-0)\times(6-5)+[3-(-2)]\times(5-1)+(0-3)\times(1-0)=15$。

【数据范围】

对 $20\%$ 数据，$n\le20$，$0\le a_i\le10^3$；

对 $50\%$ 数据，$n\le80$；

对 $100\%$ 数据，$1\le n\le300$，$-10^9\le a_i\le10^9$。

---

## 唯一算法分类
线性DP

---

## 综合分析与结论

### 核心思路与算法要点
1. **对称项拆分**：将原式拆解为对称的两部分，发现每个项可对应成左右端点贡献。
2. **二维状态设计**：定义 $f_{i,j}$ 表示左边选到 $i$、右边选到 $j$ 时的最大贡献，通过成对扩展端点优化计算。
3. **转移方程优化**：引入辅助数组 $g$ 预处理中间结果，将转移复杂度从 $O(n^4)$ 降为 $O(n^3)$。
4. **倒序循环策略**：外层倒序枚举右端点 $j$，内层倒序枚举左端点 $i$，确保状态转移的正确性。

### 难点与解决方案
- **状态转移复杂度**：原始转移方程涉及四重循环，通过拆分式子并引入 $g_{i,x}$ 存储与 $y$ 相关的最大值，消除一重循环。
- **边界条件处理**：分三种情况处理奇数/偶数长度子序列，特别处理单元素情形。
- **循环顺序设计**：倒序循环保证在计算 $f_{i,j}$ 时，$g$ 中的值均为可用状态。

### 可视化设计思路
- **DP矩阵更新动画**：在 Canvas 网格中绘制 $f$ 数组，使用不同颜色标记：
  - 红色高亮当前处理的 $(i,j)$ 单元格。
  - 绿色闪烁显示被更新的 $g_{k,i}$ 单元格。
- **音效触发规则**：
  - 每次更新 $f_{i,j}$ 时播放短促 "beep" 音效。
  - 发现新的最大答案时播放上扬音调。
- **自动演示模式**：按 $j$ 从大到小逐步展开，展示每个状态如何由历史状态组合而成。

---

## 题解清单 (5星)
**题解作者：b6e0_**
- **亮点**：
  - 巧妙拆分式子发现对称性，设计二维状态。
  - 引入辅助数组 $g$ 优化转移，代码简洁高效。
  - 处理奇偶子序列的分情况讨论严谨。

---

## 代码核心实现
```cpp
for (int j = n; j; --j) // 倒序枚举右端点
    for (int i = j - 1; i; --i) { // 倒序枚举左端点
        f[i][j] = a[i] * (n - j + 1) - a[j] * i; // 初始化为单独选择i,j
        for (int k = 1; k < i; ++k) // 枚举转移来源左端点
            f[i][j] = max(f[i][j], g[i][k] - a[i]*j + a[k]*j - a[j]*i + a[j]*k);
        // 更新全局答案...
        for (int k = i + 1; k < j; ++k) // 更新辅助数组g
            g[k][i] = max(g[k][i], f[i][j] + a[k]*j - a[i]*j + a[j]*k - a[j]*i);
    }
```

---

## 最优思路提炼
1. **对称贡献分析**：将原式分解为左右对称的乘积项，转化为端点贡献。
2. **成对扩展策略**：每次同时扩展左右端点，避免单独处理单边造成的复杂度爆炸。
3. **辅助数组降维**：通过 $g$ 数组预计算跨层转移，将四维优化至三维。

---

## 同类题目推荐
1. **CF1105E**（区间DP与辅助数组优化）
2. **P1436 棋盘分割**（二维区间DP）
3. **P4170 涂色**（区间DP与状态转移优化）

---

## 可视化与复古动画实现要点
1. **像素风格设计**：
   - 使用 16 色调色板，每个 DP 状态用 32x32 像素方块表示。
   - 当前活跃单元格用闪烁边框标记，转移路径用箭头连接。
2. **自动演示逻辑**：
   - 按 $j$ 从 $n$ 到 1 自动步进，每帧更新对应行数据。
   - 用户可暂停查看 $f$ 和 $g$ 的当前值。
3. **音效系统**：
   - 使用 Web Audio API 生成 8-bit 音效：
     - 转移时：100Hz 方波，持续 50ms。
     - 答案更新时：800Hz → 1200Hz 滑音。

---

## 个人心得摘录
"外层循环倒序枚举 $j$ 是关键，正序会导致 $g$ 中保存的 $y$ 不满足大于当前 $j$ 的条件。调试时发现若不倒序，样例2的答案会少5，最终通过画转移图找到问题。" —— 题解调试笔记

---
处理用时：101.77秒
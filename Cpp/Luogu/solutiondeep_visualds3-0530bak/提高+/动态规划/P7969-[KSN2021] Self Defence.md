# 题目信息

# [KSN2021] Self Defence

## 题目描述

定义一个字符串的权值为它长度为 $M$ 且只包含一种字符的子串数量。

例如字符串 ``ABBB``，在 $M=2$ 时的权值为 $2$。

给定一个长度为 $N$ 的字符串，每个字符为 ``?``，``A`` 和 ``B`` 中的一个，你需要求出将每个 ``?`` 替换为 ``A`` 或 ``B`` 后，可以得到多少个权值为 $K$ 的字符串。

答案对 $10^9+7$ 取模。

## 说明/提示

**【样例解释】**

对于第一组样例，以下为所有合法字符串：

```plain
AAAAB
ABBBB
BAAAA
BBBBA
```

对于第二组样例，以下为所有合法字符串：

```plain
AAABA
AABAA
AABBA
ABAAA
ABBAA
ABBBA
```

**【数据范围】**

**本题采用捆绑测试。**

* Subtask 1（5 points）：只存在一组数据，满足 $N=10$，$M=3$，$K=5$，$S=\texttt{????A???B?}$。
* Subtask 2（9 points）：$N\le 20$。
* Subtask 3（11 points）：$N\le 200$。
* Subtask 4（6 points）：$M=2$，$K=0$。
* Subtask 5（9 points）：$K=0$。
* Subtask 6（8 points）：$K\le 1$。
* Subtask 7（27 points）：$S$ 只包含 ``?``.
* Subtask 8（25 points）：无特殊限制。

对于所有数据，$1\leq N\leq 3000$，$1\leq M\leq N$，$0\leq K\leq N$。

## 样例 #1

### 输入

```
5 4 1
?????```

### 输出

```
4```

## 样例 #2

### 输入

```
5 2 2
A????```

### 输出

```
6```

## 样例 #3

### 输入

```
5 3 4
AAAAA```

### 输出

```
0```

# AI分析结果



0. **题目翻译**

---
# [KSN2021] Self Defence

## 题目描述

定义一个字符串的权值为其长度为 $M$ 且仅包含同一种字符的子串数量。

例如字符串 `ABBB` 在 $M=2$ 时的权值为 $2$（对应子串 `BB` 和 `BB`）。

给定长度为 $N$ 的字符串，包含字符 `?`、`A`、`B`。将每个 `?` 替换为 `A` 或 `B` 后，求权值恰好为 $K$ 的字符串数量，答案对 $10^9+7$ 取模。

---

1. **唯一算法分类**  
   **线性DP**

---

2. **综合分析与结论**

### 核心思路与难点
**核心问题**：统计满足特定连续段结构的字符串数量。  
**关键难点**：  
- 动态追踪连续段的长度及其对权值的贡献  
- 处理 `?` 的灵活替换带来的状态爆炸  
- 优化 $O(n^3)$ 暴力 DP 到 $O(n^2)$  

**状态设计**：  
$f_{i,j,0/1}$ 表示前 $i$ 个字符，权值累计为 $j$，且第 $i$ 个字符为 `A/B` 的方案数。  

**状态转移**：  
- **无贡献段**：当当前连续段长度 $<M$ 时，权值不变，直接累加前驱状态  
- **有贡献段**：当连续段长度 $\geq M$ 时，计算新增权值 $\max(l-M+1, 0)$  
- **转移优化**：通过前缀和数组 $g$ 和偏移数组 $h$ 将分段求和降为 $O(1)$  

**可视化设计**：  
- **像素风格 Canvas**：  
  - 每个 DP 状态用 16x16 像素方块表示，颜色编码权值（如红色渐变表示权值增大）  
  - 当前转移路径用闪烁高亮显示  
- **音效触发**：  
  - 状态更新时播放 8-bit "哔" 声  
  - 发现可行解时播放上升音阶  
- **AI 演示模式**：  
  - 自动遍历所有可能路径，重点高亮关键转移步骤  
  - 积分系统：每完成一个连续段计算得 10 分，优化步骤额外奖励  

---

3. **题解清单 (≥4星)**

### 题解1：Elma_（⭐⭐⭐⭐⭐）  
**亮点**：  
- 首创偏移数组 $h$ 解决下标偏移问题  
- 预处理 `pA/pB` 数组快速定位前驱位置  
- 代码模块化程度高，逻辑清晰  

### 题解2：MoYuFang（⭐⭐⭐⭐）  
**亮点**：  
- 引入极长连续段概念，优化状态定义  
- 分段函数表达式推导严谨，数学美感强  
- 预处理 $s$ 数组处理字符限制  

### 题解3：gyh20（⭐⭐⭐）  
**亮点**：  
- 差分标记优化转移，减少空间占用  
- 采用 `nxta/nxtb` 预处理跳转指针  
- 代码简洁但可读性稍弱  

---

4. **核心代码实现**

### 关键状态转移代码（Elma_ 题解）
```cpp
for (int i = 1; i <= N; i++) {
    for (int j = 0; j <= K; j++) {
        // 处理填A的情况
        if (s[i] != 'B') {
            if (i - pB[i] < M) { // 无贡献段
                f[i][j][0] += g[i-1][j][1] - (pB[i] ? g[pB[i]-1][j][1] : 0);
            } else { // 有贡献段
                int x = j - i + M - 1 + N;
                f[i][j][0] += (g[i-1][j][1] - g[i-M][j][1]) 
                            + (h[i-M][x][1] - (pB[i] ? h[pB[i]-1][x][1] : 0));
            }
        }
        // 同步更新前缀和数组
        g[i][j][0] = (g[i-1][j][0] + f[i][j][0]) % Mod;
        h[i][j-i+N][0] = (h[i-1][j-i+N][0] + f[i][j][0]) % Mod;
    }
}
```

### 可视化片段（伪代码）
```javascript
// 绘制 DP 矩阵
function drawDP() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i <= N; i++) {
        for (let j = 0; j <= K; j++) {
            let alpha = (f[i][j][0] + f[i][j][1]) / maxCount;
            ctx.fillStyle = `rgba(255, ${100*j/K}, 0, ${alpha})`;
            ctx.fillRect(i*16, j*16, 15, 15);
        }
    }
}
```

---

5. **同类型题与推荐**

**通用套路**：  
- 连续段贡献统计 → 分段前缀和优化  
- 带偏移量的状态转移 → 数组下标平移  

**推荐题目**：  
1. P2659 [美丽的序列]（区间最小值贡献）  
2. P2679 [子串]（双字符串分段DP）  
3. P4158 [粉刷匠]（颜色分段计数）

---

6. **个人心得摘录**

> "预处理 `pA/pB` 时，初始值设为 0 可避免边界特判，这个技巧在字符串题中很常用。" —— Elma_  
> "将 $j-i$ 偏移 $n$ 避免负数下标，比用 map 快 10 倍！" —— MoYuFang

---

7. **复古游戏化动画设计**

**颜色方案**：  
- 背景：NES 经典深蓝 (#1A1C2C)  
- DP 方块：红绿渐变表示权值增长  
- 当前操作块：黄色闪烁  

**音效设计**：  
- 状态更新：`beep(440, 50)`  
- 发现解：`playSequence([523, 659, 784])`  
- 错误：`noise(0.5, 100)`  

**AI 模式**：  
```javascript
function autoSolve() {
    let i = 0, j = 0;
    const steps = setInterval(() => {
        if (i > N) clearInterval(steps);
        updateDP(i, j);
        drawDP();
        j = (j + 1) % (K + 1);
        if (j === 0) i++;
    }, 100);
}
```

---
处理用时：100.17秒
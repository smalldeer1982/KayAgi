# 题目信息

# [蓝桥杯 2020 国 B] 质数行者

## 题目背景

小蓝在玩一个叫质数行者的游戏。

## 题目描述

游戏在一个 $n \times m \times w$ 的立体方格图上进行, 从北到南依次标号为第 $1$ 行到 第 $n$ 行, 从西到东依次标号为第 $1$ 列到第 $m$ 列, 从下到上依次标号为第 $1$ 层到 第 $w$ 层。

小蓝要控制自己的角色从第 $1$ 行第 $1$ 列第 $1$ 层移动到第 $n$ 行第 $m$ 列第 $w$ 层。每一步, 他可以向东走质数格、向南走质数格或者向上走质数格。每走到 一个位置, 小蓝的角色要稍作停留。

在游戏中有两个陷阱, 分别为第 $r_{1}$ 行第 $c_{1}$ 列第 $h_{1}$ 层和第 $r_{2}$ 行第 $c_{2}$ 列第 $h_{2}$ 层。这两个陷阱的位置可以跨过, 但不能停留。也就是说, 小蓝不能控制角 色某一步正好走到陷阱上，但是某一步中间跨过了陷阱是允许的。

小蓝最近比较清闲, 因此他想用不同的走法来完成这个游戏。所谓两个走法不同, 是指小蓝稍作停留的位置集合不同。

请帮小蓝计算一下，他总共有多少种不同的走法。

提示：请注意内存限制, 如果你的程序运行时超过内存限制将不得分。

## 说明/提示

**【样例说明】**

用 $(r, c, h)$ 表示第 $r$ 行第 $c$ 列第 $h$ 层, 可能的走法有以下几种:

1. $(1,1,1)-(1,3,1)-(1,6,1)-(3,6,1)-(5,6,1)$ 。

2. $(1,1,1)-(1,3,1)-(3,3,1)-(3,6,1)-(5,6,1)$ 。

3. $(1,1,1)-(1,3,1)-(3,3,1)-(5,3,1)-(5,6,1)$ 。

4. $(1,1,1)-(3,1,1)-(3,3,1)-(3,6,1)-(5,6,1)$ 。

5. $(1,1,1)-(3,1,1)-(3,3,1)-(5,3,1)-(5,6,1)$ 。

6. $(1,1,1)-(3,1,1)-(5,1,1)-(5,3,1)-(5,6,1)$ 。

7. $(1,1,1)-(3,1,1)-(5,1,1)-(5,4,1)-(5,6,1)$ 。

8. $(1,1,1)-(1,4,1)-(1,6,1)-(3,6,1)-(5,6,1)$ 。

9. $(1,1,1)-(1,6,1)-(3,6,1)-(5,6,1)$ 。

10. $(1,1,1)-(3,1,1)-(3,6,1)-(5,6,1)$ 。

11. $(1,1,1)-(3,1,1)-(5,1,1)-(5,6,1)$ 。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例 $1 \leq n, m, w \leq 50$ 。

对于 $60 \%$ 的评测用例 $1 \leq n, m, w \leq 300$ 。

对于所有评测用例, $1 \leq n, m, w \leq 1000,1 \leq r_{1}, r_{2} \leq n, 1 \leq c_{1}, c_{2} \leq m$, $1 \leq h_{1}, h_{2} \leq w$, 陷阱不在起点或终点, 两个陷阱不同。

蓝桥杯 2020 年国赛 B 组 J 题。

## 样例 #1

### 输入

```
5 6 1
3 4 1 1 2 1```

### 输出

```
11```

# AI分析结果



# 题目内容（中文重写）

## 题目背景

小蓝在玩一个叫质数行者的游戏。

## 题目描述

游戏在一个 $n \times m \times w$ 的立体方格图上进行，从北到南依次标号为第 $1$ 行到第 $n$ 行，从西到东依次标号为第 $1$ 列到第 $m$ 列，从下到上依次标号为第 $1$ 层到第 $w$ 层。

小蓝要控制角色从 $(1,1,1)$ 移动到 $(n,m,w)$。每一步可以向东/南/上走质数格，但不能停留在两个陷阱点 $(r_1,c_1,h_1)$ 和 $(r_2,c_2,h_2)$ 上。求不同的走法总数（停留位置集合不同即为不同走法）。

## 输入格式

第一行输入 $n,m,w$，第二行输入陷阱坐标 $r_1,c_1,h_1,r_2,c_2,h_2$。

## 输出格式

输出总方案数模 $10^9+7$。

---

**唯一算法分类**：线性DP

---

# 综合分析与结论

### 核心思路
1. **三维独立路径分解**：将三维移动拆分为三个独立维度的质数步数选择，通过动态规划预处理每个维度用 $k$ 步走到坐标 $x$ 的方案数 $f(x,k)$。
2. **组合数学优化**：利用组合数公式 $\frac{(i+j+k)!}{i!j!k!}$ 合并三个维度的步数选择，通过阶乘预处理和逆元优化计算。
3. **容斥原理**：总路径数减去经过两个陷阱的路径数，再补回同时经过两个陷阱的重叠部分。

### 动态规划状态转移
- **状态定义**：$f[x][k]$ 表示用 $k$ 个质数走到坐标 $x$ 的方案数。
- **转移方程**：$f[x][k] = \sum_{p \in primes} f[x-p][k-1]$，其中 $p \leq x$。
- **预处理优化**：质数列表预先生成，循环时直接遍历质数而非所有数。

### 解决难点
1. **三维组合数计算**：通过分离维度计算（先合并两个维度再与第三个维度结合）将复杂度从 $O(n^3)$ 降为 $O(n^2)$。
2. **陷阱点容斥**：根据陷阱点的位置关系分类讨论容斥项，正确处理路径交叉情况。

### 可视化设计思路
- **DP矩阵展示**：用三维网格动画展示 $f[x][k]$ 的更新过程，高亮当前质数步长和对应的前驱状态。
- **容斥路径追踪**：用不同颜色标记经过陷阱点的路径，动态演示容斥过程。
- **像素风格设计**：用 8-bit 像素块表示状态转移，每次状态更新时播放复古音效，陷阱点用闪烁红块提示。

---

# 题解评分（4星及以上）

### 1. DerrickLo（4星）
- **亮点**：组合数拆解为阶乘分式，预计算质数列表提升效率。
- **改进点**：阶乘逆元预处理可进一步优化内存。

### 2. meyi（4星）
- **亮点**：维度合并思路清晰，代码模块化设计便于扩展。
- **改进点**：质数筛法可替换为更高效的埃氏筛。

### 3. HD0X（4星）
- **亮点**：预处理 $pre[c]$ 数组显著降低复杂度，代码注释详细。
- **改进点**：质数判断逻辑可优化为预生成列表。

---

# 最优思路提炼

### 关键技巧
1. **质数步长预处理**：预先生成质数列表，避免每次转移重复计算。
2. **组合数阶乘优化**：将三维组合数拆解为 $\frac{(i+j+k)!}{i!j!k!}$，通过预处理阶乘和逆元快速计算。
3. **分步容斥策略**：先计算总路径，再减去单陷阱路径，最后补回双陷阱重叠路径。

---

# 相似题目推荐
1. **P5376 [THUPC2019] 过河卒二**：二维路径+质数步长+容斥。
2. **P1373 矩阵取数**：多维动态规划+组合计数。
3. **P3959 宝藏**：状态压缩DP+多维路径优化。

---

# 核心代码实现

```cpp
// 预处理质数步数DP
int f[MAXN][MAXK]; // f[x][k]: 用k个质数走到x
vector<int> primes = {2,3,5,...}; // 预生成质数列表
f[0][0] = 1;
for (int x = 1; x <= 1000; ++x) {
    for (int k = 1; k <= x/2; ++k) {
        for (int p : primes) {
            if (p > x) break;
            f[x][k] = (f[x][k] + f[x-p][k-1]) % mod;
        }
    }
}

// 计算路径数函数
int calc(int x, int y, int z) {
    int res = 0;
    for (int sum = 0; sum <= x/2 + y/2; ++sum) {
        ll part1 = 0; // 合并x和y维度
        for (int i = 0; i <= sum; ++i) {
            int j = sum - i;
            part1 += f[x][i] * inv_fact[i] % mod * f[y][j] * inv_fact[j] % mod;
        }
        ll part2 = 0; // 合并z维度
        for (int k = 0; k <= z/2; ++k) {
            part2 += fact[sum + k] * f[z][k] * inv_fact[k] % mod;
        }
        res = (res + part1 * part2 % mod) % mod;
    }
    return res;
}
```

---

# 可视化与游戏化设计

### 复古像素动画
- **Canvas绘制**：用16色像素块绘制三维DP网格，当前更新单元用黄色高亮。
- **音效设计**：状态更新时播放8-bit "beep"音，陷阱路径用警报音提示。
- **自动演示模式**：按步长自动播放DP更新和容斥计算过程，支持暂停/继续。

### 交互控制
```javascript
// 伪代码示例
class DPVisualizer {
    constructor() {
        this.speed = 1; // 动画速度
        this.ctx = canvas.getContext('2d');
        this.play(); // 启动自动播放
    }
    drawDPGrid() {
        // 绘制三维网格，标记当前更新状态
    }
    play() {
        // 按步长更新动画
    }
}
```

---

**通过将高维问题分解为独立维度并巧妙应用容斥原理，此题展现了动态规划与组合数学的深度结合。预处理和阶乘优化是此类问题的通用优化手段。**

---
处理用时：97.69秒
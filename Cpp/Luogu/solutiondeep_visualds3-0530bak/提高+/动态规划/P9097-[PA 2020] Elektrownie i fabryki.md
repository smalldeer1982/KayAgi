# 题目信息

# [PA 2020] Elektrownie i fabryki

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 2 [Elektrownie i fabryki](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/ele/)**

为了应对不断上升的失业率，Byteotia 政府决定创造新的就业机会。为此将建设现代化的工厂，还要建设为工厂供电的新发电厂。

一条很长的高速公路穿过 Byteotia，沿途有 $n$ 个城市。为了简单起见，我们从 $1$ 到 $n$ 对城市进行编号。每两个相邻城市之间都相距一公里。

目前已经决定一些城市建设工厂，另一些城市建设发电厂。对于第 $i$ 个城市有一个值 $a_i$。如果它是正数，则在第 $i$ 个城市将建造一个发电容量为 $a_i$ 兆瓦的发电厂，如果它是负数，则在该城市将建造一个消耗电能 $a_i$ 兆瓦的工厂。如果 $a_i=0$，则说明该城市没有建设计划。

你的任务是设计一个电网，将电力从发电站输送到工厂。对于每一对相邻的城镇，你必须决定是否在它们之间建立一条输电线。如果这个城市被输电线直接或间接连接到某个有发电站的城市，电力就可以从发电站流向这个城市的工厂。如果每个工厂的电力需求都得到满足，那么电网的设计就是正确的。电网的成本与电网输电线的总长度（以公里计）成正比。

写一个程序计算设计一个正确的电网最小成本是多少。

## 说明/提示

#### 样例 1 解释

下面是一个包含 $n=17$ 个城市的样例，其中将建造三个工厂（白圈）和四个发电厂（黑圈）。$12$ 公里的正确电网用灰色部分标记。

![](https://cdn.luogu.com.cn/upload/image_hosting/2wee5eoz.png)

------------

#### 数据范围

**本题采用捆绑测试**

对于一些子任务，满足 $n\le 5\times 10^3$。

对于 $100\%$ 的数据，保证 $1\le n\le 5\times 10^5$，$-10^9\le a_i\le 10^9$。

## 样例 #1

### 输入

```
17
2 -5 0 2 0 0 0 4 0 0 -1 4 0 0 0 0 -3```

### 输出

```
12```

# AI分析结果



## 题目重写

# [PA 2020] 发电厂与工厂

## 题目描述

为了应对不断上升的失业率，Byteotia 政府决定在高速公路沿线的城市中建设现代化工厂和配套发电厂。这条高速公路贯穿 $n$ 个城市，相邻城市间距一公里。

每个城市有三种状态：
- $a_i > 0$：建设容量为 $a_i$ 兆瓦的发电厂
- $a_i < 0$：建设消耗 $-a_i$ 兆瓦的工厂
- $a_i = 0$：无建设计划

电网设计要求所有工厂必须连通到发电量足够的发电厂。求满足需求的最小输电线总长度（以公里计）。

## 输入格式
第一行包含整数 $n$，第二行包含 $n$ 个整数 $a_1$ 到 $a_n$。

## 输出格式
输出最小成本，若无法满足输出 `-1`。

## 样例输入
```
17
2 -5 0 2 0 0 0 4 0 0 -1 4 0 0 0 0 -3
```

## 样例输出
```
12
```

---

## 1. 算法分类
**线性DP**

---

## 2. 题解分析与结论

### 核心思路
各题解均采用动态规划+树状数组优化，关键步骤：
1. **前缀和约束**：区间 $[j,i]$ 的总和 $sum[i]-sum[j-1] \ge 0$ 确保电力充足
2. **状态定义**：$f[i]$ 表示前 $i$ 个城市的最小成本
3. **转移方程**：$f[i] = \min \{ f[j-1] + (i-j) \}$，需满足 $sum[i] \ge sum[j-1]$
4. **离散化优化**：将前缀和离散化后，用树状数组维护最小值查询

### 解决难点
- **状态转移加速**：将二维转移优化为 $O(n\log n)$
- **离散化处理**：处理大范围前缀和的值域问题
- **边界处理**：处理全正数、无解等特殊情况

### 可视化设计
1. **DP矩阵更新**：
   - 用网格展示前缀和离散化后的映射关系
   - 高亮当前处理的 $i$ 对应的 $sum[i]$ 查询范围（蓝色区间）
   - 树状数组节点用绿色标记被更新的位置

2. **复古像素风格**：
   ```javascript
   // Canvas绘制示例
   ctx.fillStyle = '#8BC34A'; // 树状数组节点颜色
   ctx.fillRect(x*20, y*20, 18, 18);
   ```

3. **音效设计**：
   - 状态更新：8-bit "blip" 音效（频率 800Hz）
   - 找到更优解：上升音阶（C4→E4→G4）
   - 无解提示：低沉蜂鸣（200Hz持续0.5s）

---

## 3. 高星题解推荐（≥4★）

### 题解1：wuudii（4★）
**亮点**：完整解释转移方程推导过程，处理空白城市的预计算  
**代码片段**：
```cpp
for(int i=nxt[0];i<=n;i=nxt[i]){
    if(a[i]>0) f[i] = f[pre[i-1]];
    f[i] = min(f[i], i + query(sum[i]));
    add(sum[i-1], f[pre[i-1]] - i);
}
```

### 题解2：_Spectator_（4.5★）
**亮点**：最简代码实现，清晰的离散化处理  
**代码片段**：
```cpp
t.update(s[0], 0);
for(int i=1; i<=n; i++){
    f[i] = t.query(s[i]) + i - 1;
    t.update(s[i], f[i] - i);
}
```

### 题解3：Fzrcy（4★）
**亮点**：极致简洁的代码风格，完整处理边界条件  
**代码片段**：
```cpp
if(!i){ add(x,-1); continue; }
f[i] = Q(x) + i;
if(a[i]-a[i-1]>=0) f[i] = min(f[i],f[i-1]);
```

---

## 4. 核心代码实现

### 树状数组维护最小值
```cpp
struct BIT{
    int c[N];
    void update(int x, int k){
        for(;x<=n;x+=x&-x) c[x]=min(c[x],k);
    }
    int query(int x){
        int s=INF;
        for(;x;x-=x&-x) s=min(s,c[x]);
        return s;
    }
} t;
```

### DP主循环
```cpp
sort(b, b+n+1); // 离散化预处理
m = unique(b, b+n+1) - b;

t.update(lower_bound(b, b+m, 0)-b+1, 0); // 初始化sum[0]

for(int i=1; i<=n; ++i){
    int pos = lower_bound(b, b+m, sum[i])-b +1;
    f[i] = t.query(pos) + i;
    if(sum[i]>=sum[i-1]) f[i] = min(f[i], f[i-1]);
    t.update(pos, f[i]-i-1);
}
```

---

## 5. 同类型题目
1. **P1115 最大子段和** - 前缀和极值问题
2. **P3806 树上的询问** - 树状数组维护路径信息
3. **P4097 Segment** - 动态规划结合数据结构优化

---

## 6. 可视化演示方案
```javascript
// 伪代码示例：DP状态更新动画
class DPDemo {
    constructor() {
        this.grid = new PixelGrid(800, 600); 
        this.speed = 100; // 毫秒/步
    }

    async step(i) {
        // 高亮当前城市i
        this.grid.highlight(i, COLORS.CURRENT);
        
        // 查询树状数组范围
        let range = this.getQueryRange(sum[i]);
        this.grid.drawRange(range, COLORS.QUERY_ZONE);
        
        // 播放查询音效
        Sound.play('query');
        
        // 更新DP值
        let minVal = tree.query(sum[i]);
        dp[i] = minVal + i;
        
        // 更新树状数组
        tree.update(sum[i-1], dp[i]-i-1);
        
        // 绘制更新动画
        this.grid.flashNode(sum[i-1]);
    }
}
```

---

## 7. 关键优化技巧
- **离散化压缩空间**：将前缀和映射到排名空间，降低树状数组维度
- **转移式变形**：将 $f[j-1] + (i-j)$ 改写为 $(f[j-1]-j) + i$，分离变量
- **空白城市跳跃处理**：预处理pre[]和nxt[]数组跳过无效计算

---

## 8. 调试经验摘录
> "WA后发现未处理全正数情况，加入特判后AC" ——wuudii  
> "离散化时忘记包含sum[0]，导致树状数组越界" ——lovely_nst  
> "最初用线段树TLE，改用树状数组快了一倍" ——_Spectator_

---
处理用时：106.76秒
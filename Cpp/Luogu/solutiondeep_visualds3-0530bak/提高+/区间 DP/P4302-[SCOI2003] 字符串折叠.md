# 题目信息

# [SCOI2003] 字符串折叠

## 题目描述

折叠的定义如下：

1. 一个字符串可以看成它自身的折叠。记作 ```S = S```

2. ```X(S)``` 是 $X$ 个 ```S``` 连接在一起的串的折叠。记作 ```X(S) = SSSS…S```。

3. 如果 ```A = A’```, ```B = B’```，则 ```AB = A’B’ ```。例如：因为 ```3(A) = AAA```, ```2(B) = BB```，所以 ```3(A)C2(B) = AAACBB```，而 ```2(3(A)C)2(B) = AAACAAACBB```

给一个字符串，求它的最短折叠。

例如 ```AAAAAAAAAABABABCCD``` 的最短折叠为：```9(A)3(AB)CCD```。

## 说明/提示

一个最短的折叠为：`2(NEERC3(YES))`

## 样例 #1

### 输入

```
NEERCYESYESYESNEERCYESYESYES```

### 输出

```
14```

# AI分析结果



### 算法分类
**区间动态规划 (区间DP)**

---

### 题解思路与解决难点
#### 核心思路
1. **状态定义**：  
   `f[i][j]` 表示字符串区间 `[i,j]` 的最短折叠长度。
2. **状态转移**：  
   - **分割合并**：枚举分割点 `k`，取 `f[i][k] + f[k+1][j]` 的最小值。  
   - **整体折叠**：若区间存在循环节，计算折叠后的长度（循环节长度 + 数字位数 + 2）。
3. **循环节检查**：  
   暴力检查区间是否能被某个长度 `len` 的循环节重复构成，时间复杂度 `O(n)`。
4. **数字位数预处理**：  
   预计算 `1~100` 的位数，避免重复计算。

#### 解决难点
- **循环节判断优化**：通过模运算和逐字符比较快速判断能否折叠。
- **剪枝策略**：仅当区间长度能被循环节长度整除时才进行折叠检查。
- **边界处理**：初始化为单个字符长度为 `1`，其他区间初始化为极大值。

---

### 题解评分 (≥4星)
| 题解作者 | 评分 | 关键亮点 |
|---------|------|----------|
| kradcigam | ★★★★★ | 代码清晰，四层循环剪枝优化，详细注释 |
| Plus_Ultra | ★★★★☆ | 状态转移方程简洁，代码短小精悍 |
| Frozen_Heart | ★★★★☆ | 记忆化搜索实现，逻辑易读 |

---

### 最优思路提炼
1. **区间DP框架**：  
   外层循环区间长度，内层循环起点和分割点。
2. **折叠条件剪枝**：  
   ```cpp
   if (l % len != 0) continue; // 长度不整除则跳过
   if (check(i, j, len)) // 检查循环节
   ```
3. **数字位数预处理**：  
   ```cpp
   m[100] = {0}; // 预计算数字位数
   m[i] = (i<=9 ? 1 : (i<=99 ? 2 : 3));
   ```

---

### 同类型题推荐
1. **石子合并（区间DP基础）**：[P1880](https://www.luogu.com.cn/problem/P1880)  
2. **能量项链（环形区间DP）**：[P1063](https://www.luogu.com.cn/problem/P1063)  
3. **括号染色（状态转移设计）**：[P4170](https://www.luogu.com.cn/problem/P4170)

---

### 可视化与算法演示
#### 动画设计
- **颜色标记**：  
  - 红色：当前处理的区间 `[i,j]`  
  - 蓝色：分割点 `k`  
  - 绿色：折叠后的循环节  
- **步进控制**：  
  允许单步调试区间扩展和折叠检查。
- **音效提示**：  
  - 折叠成功：短促“滴”声  
  - 分割合并：点击声效  

#### 复古像素风格
- **Canvas 绘制**：  
  用像素网格表示字符串，循环节用闪烁动画突出。
- **音效**：8-bit 风格背景音乐，折叠时播放复古合成音。

---

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
string st;
int n, m[110], f[110][110];

bool check(int l, int r, int len) {
    for (int i = l; i <= r; i++)
        if (st[i] != st[(i - l) % len + l]) return false;
    return true;
}

int main() {
    cin >> st;
    n = st.size();
    st = ' ' + st;
    // 预处理数字位数
    for (int i = 1; i <= 9; i++) m[i] = 1;
    for (int i = 10; i <= 99; i++) m[i] = 2;
    m[100] = 3;
    // 初始化DP
    memset(f, 0x3f, sizeof(f));
    for (int i = 1; i <= n; i++) f[i][i] = 1;
    // 区间DP
    for (int l = 2; l <= n; l++) {
        for (int i = 1, j = i + l - 1; j <= n; i++, j++) {
            // 分割合并
            for (int k = i; k < j; k++)
                f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]);
            // 整体折叠
            for (int k = i; k < j; k++) {
                int len_seg = k - i + 1;
                if (l % len_seg != 0) continue;
                if (check(i, j, len_seg))
                    f[i][j] = min(f[i][j], f[i][k] + 2 + m[l / len_seg]);
            }
        }
    }
    cout << f[1][n];
    return 0;
}
```

---

### 关键注释
- **预计算优化**：`m[]` 数组避免重复计算数字位数。  
- **折叠检查**：`check()` 函数通过模运算快速验证循环节。  
- **四层循环剪枝**：通过 `l % len` 跳过无效分割。

---
处理用时：65.66秒
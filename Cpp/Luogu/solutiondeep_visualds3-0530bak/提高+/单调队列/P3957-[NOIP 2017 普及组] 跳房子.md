# 题目信息

# [NOIP 2017 普及组] 跳房子

## 题目背景

NOIP2017 普及组 T4

## 题目描述

跳房子，也叫跳飞机，是一种世界性的儿童游戏，也是中国民间传统的体育游戏之一。

跳房子的游戏规则如下：

在地面上确定一个起点，然后在起点右侧画 $n$ 个格子，这些格子都在同一条直线上。每个格子内有一个数字（整数），表示到达这个 格子能得到的分数。玩家第一次从起点开始向右跳，跳到起点右侧的一个格子内。第二次再从当前位置继续向右跳，依此类推。规则规定：

玩家每次都必须跳到当前位置右侧的一个格子内。玩家可以在任意时刻结束游戏，获得的分数为曾经到达过的格子中的数字之和。

现在小 R 研发了一款弹跳机器人来参加这个游戏。但是这个机器人有一个非常严重的缺陷，它每次向右弹跳的距离只能为固定的 $d$。小 R 希望改进他的机器人，如果他花 $g$ 个金币改进他的机器人，那么他的机器人灵活性就能增加 $g$，但是需要注意的是，每 次弹跳的距离至少为 $1$。具体而言，当 $g<d$ 时，他的机器人每次可以选择向右弹跳的距离为 $d-g,d-g+1,d-g+2,\ldots,d+g-1,d+g$；否则当 $g \geq d$ 时，他的机器人每次可以选择向右弹跳的距离为 $1,2,3,\ldots,d+g-1,d+g$。

现在小 R 希望获得至少 $k$ 分，请问他至少要花多少金币来改造他的机器人。

## 说明/提示

**样例 1 说明**

花费 $2$ 个金币改进后，小 R 的机器人依次选择的向右弹跳的距离分别为 $ 2, 3, 5, 3, 4,3$，先后到达的位置分别为 $2, 5, 10, 13, 17, 20$，对应 $ 1, 2, 3, 5, 6, 7$ 这 $6$ 个格子。这些格子中的数字之和 $ 15$ 即为小 R 获得的分数。

**样例 2 说明**

由于样例中 $7$ 个格子组合的最大可能数字之和只有 $18$，所以无论如何都无法获得 $20$ 分。

**数据规模与约定**

本题共 10 组测试数据，每组数据等分。

对于全部的数据满足 $1 \le n \le 5\times10^5$，$1 \le d \le2\times10^3$，$1 \le x_i, k \le 10^9$，$|s_i| < 10^5$。

对于第 $1, 2$ 组测试数据，保证 $n\le 10$。

对于第 $3, 4, 5$ 组测试数据，保证 $n \le 500$。

对于第 $6, 7, 8$ 组测试数据，保证 $d = 1$。

## 样例 #1

### 输入

```
7 4 10
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2```

### 输出

```
2```

## 样例 #2

### 输入

```
7 4 20
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2```

### 输出

```
-1```

# AI分析结果



## 唯一算法分类
单调队列优化动态规划

---

## 综合分析与结论

### 核心思路与难点
**核心思路**：
1. **二分答案**：利用金币数g的单调性（越大越容易达到目标），通过二分查找最小可行g
2. **动态规划**：定义dp[i]为跳到第i格的最大得分，状态转移方程为`dp[i] = max(dp[j]) + s_i`（j满足跳跃距离约束）
3. **单调队列优化**：维护一个保存候选j的单调递减队列，快速获取区间最大值

**解决难点**：
- **跳跃距离约束**：通过维护队列元素的x坐标范围，确保转移的合法性
- **队列单调性**：每次新加入元素时弹出较小值，保持队列递减特性
- **边界处理**：起点初始化、正数总和判断等细节处理

---

## 最优思路与技巧提炼

### 关键实现步骤
1. **预处理**：计算所有正数总和，若不足k直接返回-1
2. **二分框架**：左边界0，右边界取max(d,最远格子距离)
3. **动态规划优化**：
   ```cpp
   deque<int> q; // 维护满足距离约束的候选j
   int j = 0;    // 待入队指针
   for(int i=1; i<=n; i++){
       // 将满足x[i]-x[j] >= min_dist的j加入队列
       while(j < i && x[i] - x[j] >= min_dist){
           while(!q.empty() && dp[q.back()] <= dp[j]) q.pop_back();
           q.push_back(j++);
       }
       // 移除超出max_dist的队头元素
       while(!q.empty() && x[i]-x[q.front()] > max_dist) q.pop_front();
       // 状态转移
       if(!q.empty()) dp[i] = dp[q.front()] + s[i];
   }
   ```

### 可视化设计
**动画方案**：
- **像素风格布局**：用彩色方块表示格子，绿色表示起点，黄色表示正分，红色表示负分
- **队列可视化**：右侧显示单调队列元素，用不同颜色区分有效区间元素
- **跳跃轨迹**：机器人跳跃时显示抛物线，命中高dp值格子时触发粒子特效
- **音效提示**：
  - 加入队列："blip.wav"（短促电子音）
  - 弹出队头："pop.wav"（低沉音效）
  - 找到解："success.wav"（8-bit胜利旋律）

**交互功能**：
- 速度调节：滑动条控制二分和dp执行速度
- 单步执行：按空格键逐步执行算法步骤
- 自动演示：AI模式自动完成全流程，关键步骤暂停讲解

---

## 推荐相似题目
1. P1725 琪露诺（单调队列优化DP）
2. P1886 滑动窗口（单调队列基础应用）
3. P2569 股票交易（多重限制下的单调队列优化）

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 5e5+10;
const LL INF = 1e18;

int n, d, k, x[N], s[N];
LL dp[N];

bool check(int g) {
    int min_dist = max(1, d - g);
    int max_dist = d + g;
    deque<int> q;
    memset(dp, 0x80, sizeof(dp));
    dp[0] = 0;
    
    int j = 0;
    for(int i=1; i<=n; i++) {
        // 将满足min_dist的j加入队列
        while(j < i && x[i] - x[j] >= min_dist) {
            if(dp[j] != -INF) {
                while(!q.empty() && dp[q.back()] <= dp[j])
                    q.pop_back();
                q.push_back(j);
            }
            j++;
        }
        // 移除超出max_dist的元素
        while(!q.empty() && x[i] - x[q.front()] > max_dist)
            q.pop_front();
        
        if(!q.empty()) 
            dp[i] = dp[q.front()] + s[i];
        if(dp[i] >= k) 
            return true;
    }
    return false;
}

int main() {
    cin >> n >> d >> k;
    LL sum = 0;
    for(int i=1; i<=n; i++) {
        cin >> x[i] >> s[i];
        if(s[i] > 0) sum += s[i];
    }
    if(sum < k) {
        cout << -1;
        return 0;
    }
    
    int l=0, r=max(x[n],d), ans=-1;
    while(l <= r) {
        int mid = (l+r)/2;
        if(check(mid)) {
            ans = mid;
            r = mid-1;
        } else {
            l = mid+1;
        }
    }
    cout << ans;
    return 0;
}
```

---

## 可视化代码片段（Canvas动画）
```javascript
// 绘制跳跃轨迹
function drawJump(from, to) {
    ctx.beginPath();
    ctx.moveTo(gridX[from], 50);
    // 抛物线方程计算中间点
    for(let t=0; t<=1; t+=0.1) {
        let x = lerp(gridX[from], gridX[to], t);
        let y = 50 + 200*t*(1-t); // 抛物线高度
        ctx.lineTo(x, y);
    }
    ctx.strokeStyle = "#FF00FF";
    ctx.stroke();
}

// 更新单调队列显示
function updateQueueDisplay() {
    ctx.fillStyle = "#333";
    ctx.fillRect(800, 0, 200, 600); // 右侧队列区域
    q.forEach((val, idx) => {
        drawCell(810, 100+idx*30, val); // 绘制队列元素
    });
}
```

---
处理用时：92.84秒
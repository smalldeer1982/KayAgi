# 题目信息

# Inferno

## 题目背景

> 我是幽灵。  
> 穿过悲惨之城，我落荒而逃。  
> 穿过永世凄苦，我远走高飞。

沿着阿尔诺河的堤岸，我夺路狂奔，气喘吁吁……左转上了卡斯特拉尼大街，一直朝北而行，始终隐蔽在乌菲兹美术馆的阴影之下。

但他们还是穷追不舍。

他们的脚步声越来越响，这些追捕者冷酷无情，不达目的绝不善罢甘休。

这么多年来，他们一直尾随着我。他们锲而不舍，是的我只能活在地下……被迫呆在炼狱之中……就像冥府的恶魔，时刻忍受地狱的煎熬。

> 我是幽灵。

如今浮生尘世，我举目北望，却看不到通往救赎的捷径——那高耸的亚平宁山脉挡住了黎明的第一缕阳光。

## 题目描述

罗伯特 · 兰登在洗下但丁死亡面具上的丙烯石膏后，在背面发现了一行字：

> 哦，有着稳固智慧的人啊，  
> 请注意这里的含义  
> 就藏在晦涩的序列面纱之下。

下面有一行由 $1,-1$ 组成的长度为 $n$ 的序列。面具经受了岁月的侵蚀，序列中有一些数已经模糊不清。幸运的是，面具下面有给出两条线索：

> 你只得往空缺的位置填 $k$ 个 $1$，其余填入 $-1$，需要最大化这个序列的最大子段和。

 > > **一个序列的最大子段和定义为，其在一段连续长度的区间内的最大和。形式化地，一个序列 $a$ 的最大子段和即为 $\max\limits_{l=1}^n\max\limits_{r=l}^n\left(\sum\limits_{i=l}^r a_i\right)$。**

罗伯特 · 兰登希望在瘟疫扩散之前找到有关的线索。于是他找到了你。

- - -

#### 【形式化题意】

给定一个只包含 $-1,0,1$ 的序列，求出往 $0$ 的位置上填 $k$ 个 $1$，其余填 $-1$ 后最大子段和的最大值。

## 说明/提示

#### 【样例解释】

一种可行的方案是填入 $\{1,1,-1\}$，最大子段和为 $2$。

#### 【数据范围】


**本题开启捆绑测试。**

| $\text{SubTask}$ | 分值 | $n,k\le $ |
| :----------: | :----------: | :----------: |
| $0$ | $4$ | $20$ | 
| $1$ | $6$ | $200$ | 
| $2$ | $10$ | $5\times 10^3$ | 
| $3$ | $30$ | $5\times 10^5$ | 
| $4$ | $50$ | $10^7$ | 


对于 $100\%$ 的数据，$1\le n,k\le10^7$，$a_i\in \{-1,0,1\}$。保证 $k\le$ 序列中 $0$ 的个数。

**本题标程使用优化后的输入输出，在 O2 优化下最大点用时约 $350$ ms，足以通过此题。如果您自认为您的程序复杂度正确，却超出时间限制，请使用更优的输入输出方式，或者优化常数。**


## 样例 #1

### 输入

```
5 2
1 0 -1 0 0```

### 输出

```
2```

# AI分析结果



### 唯一算法分类
前缀和与单调队列优化

---

### 题解思路、算法要点与解决难点

#### 核心思路
将问题拆分为两种情况处理：
1. **右端点在填充的k个0内部**：将这部分0全部填1，用前缀和数组p1计算区间和（`p1[j] - p1[i]`）
2. **右端点在填充的k个0外部**：将k个0填1，其余填-1，用前缀和数组p0与修正项计算（`p0[j] - p0[i] + 2k`）

#### 算法实现要点
1. **预处理关键数组**：
   - `p1[i]`: 所有0填1时的前缀和
   - `p0[i]`: 所有0填-1时的前缀和
   - `pos[]`: 记录每个0的位置
   - `bel[i]`: i位置前最后一个0的编号

2. **双指针维护区间**：
   - 当右端点j在k个0内部时（`j < pos[bel[i]+k+1]`），使用单调队列维护p1的前缀最大值
   - 当右端点j在k个0外部时，维护p0的后缀最大值

3. **单调队列优化**：
   - 维护一个窗口单调递减队列，快速获取区间最大值
   - 队列中存储的是前缀和的索引，保证窗口左边界随i递增

#### 解决难点
- **线性时间复杂度**：通过预处理和单调队列，将时间复杂度从O(n²)优化到O(n)
- **边界处理**：精确处理k个0的填充位置与区间划分
- **状态转移**：将两种情况的求解合并到单次遍历中

---

### 题解评分（≥4星）

#### 1. cyffff（★★★★☆）
- **亮点**：清晰的分类讨论，优雅的单调队列实现
- **代码结构**：模块化处理前缀和与后缀最大值
- **优化点**：使用单独数组存储0的位置，避免重复扫描

#### 2. LHQing（★★★★☆）
- **亮点**：双数组维护不同填充策略，简洁的队列操作
- **代码特色**：使用STL deque实现单调队列，增强可读性
- **思维角度**：将后缀最大值预处理为数组，减少计算量

#### 3. 无钩七不改名（★★★★☆）
- **亮点**：合并两种情况的极值计算，统一维护单调队列
- **创新点**：通过`num0[]`数组直接记录0的数量，简化条件判断
- **代码精简**：仅需一个主循环，同时处理两种情况的极值

---

### 最优思路提炼

#### 关键技巧
```python
# 预处理关键数组
for i in 1..n:
    if a[i] == 0:
        p1[i] = p1[i-1] + 1
        p0[i] = p0[i-1] - 1
        pos.append(i)
    else:
        p1[i] = p1[i-1] + a[i]
        p0[i] = p0[i-1] + a[i]

# 双指针维护区间极值
left = 1
for i in 0..n:
    # 维护单调队列
    while queue not empty and 队尾索引 < i: 弹出队尾
    # 计算k个0内部的情况
    while left <= 当前k个0的右边界:
        维护p1的单调队列
    # 计算k个0外部的情况
    ans = max(队列最大值, 后缀最大值 + 2k)
```

#### 思维突破点
- **填充策略转换**：将复杂的动态填充问题转换为两种确定性的前缀和计算
- **窗口划分技巧**：通过0的位置数组，将连续区间划分为可计算的离散段
- **极值分离计算**：将全局最大值分解为多个局部极值的组合

---

### 同类型题与算法套路

#### 相似题目
1. 最大子段和（洛谷 P1115）
2. 滑动窗口最大值（洛谷 P1886）
3. 带限制的最大子段和（LeetCode 1186）

#### 通用套路
1. **前缀和转换**：将区间和问题转化为前缀和差值问题
2. **极值预处理**：通过前后缀数组预处理区间极值
3. **单调队列维护**：解决滑动窗口类极值问题

---

### 推荐相似题目
1. **P1115** - 最大子段和（基础版）
2. **P1886** - 滑动窗口（单调队列模板）
3. **P1714** - 切蛋糕（环形前缀和优化）

---

### 可视化与算法演示

#### 动画设计
1. **像素风格展示**：
   - 红色方块：原始1的位置
   - 蓝色方块：原始-1的位置
   - 黄色闪烁方块：被选中的0填充为1
   - 绿色渐变条：实时显示当前前缀和

2. **关键步骤演示**：
   - **步骤1**：从左到右扫描，用不同颜色标记填充策略
   - **步骤2**：动态绘制单调队列，展示队列入队、出队过程
   - **步骤3**：高亮当前最大值区间，显示计算公式`p1[j]-p1[i]`或`p0[j]-p0[i]+2k`

3. **交互功能**：
   - 速度调节滑块：控制动画执行速度
   - 单步执行按钮：逐步观察队列维护过程
   - 模式切换：对比不同题解的实现差异

#### 复古特效示例（伪代码）
```javascript
// 像素方块绘制
function drawBlock(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*20, y*20, 18, 18); // 20px间隔，2px边框
}

// 单调队列动画
function animateQueue(i) {
    beep(440, 50); // 入队音效
    drawBlock(i, 0, '#FF5555'); // 红色标记当前元素
    setTimeout(() => {
        drawBlock(i, 0, '#5555FF'); // 恢复为蓝色
    }, 200);
}
```

---

### 代码实现（关键片段）
```cpp
// 预处理前缀和与0的位置
for(int i=1, las=0; i<=n; i++){
    if(a[i]==0){
        p0[i] = p0[i-1] - 1;
        p1[i] = p1[i-1] + 1;
        pos[++cnt] = i, las=cnt;
    } else {
        p0[i] = p0[i-1] + a[i];
        p1[i] = p1[i-1] + a[i];
    }
    bel[i] = las;
}

// 维护单调队列
for(int i=0, lp=1; i<=n; i++){
    while(hd<=tl && stk[hd].p<i) hd++;
    int id = bel[i] + k + 1;
    if(id > cnt){
        ans = max(ans, pm[i+1] - p1[i]);
    } else {
        int np = pos[id];
        for(; lp<=np-1; lp++){
            while(hd<=tl && stk[tl].v < p1[lp]) tl--;
            stk[++tl] = {p1[lp], lp};
        }
        ans = max({ans, stk[hd].v - p1[i], sm[np] - p0[i] + 2*k});
    }
}
```

---

### 个人心得摘录
> "第一次AK div.2，水个题解不过分吧（" —— cyffff  
> **启示**：复杂问题往往可以拆解为多个经典算法的组合应用

> "考场上正解没调出来，可恶。我的实现方式跟原有题解可能不同，并且时间薄纱std" —— 聊机  
> **教训**：清晰的代码结构比极端优化更重要，边界条件的处理需要细致测试

> "维护suml变量记录队列中的数字减了多少值，取出时再减当前suml" —— 无钩七不改名  
> **技巧**：通过偏移量统一处理多次修改，避免重复更新队列元素

---
处理用时：104.13秒
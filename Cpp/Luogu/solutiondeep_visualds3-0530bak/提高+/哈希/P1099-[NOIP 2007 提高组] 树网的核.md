# 题目信息

# [NOIP 2007 提高组] 树网的核

## 题目描述

设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。

路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 
$d(a, b)$ 为 $a, b$ 两结点间的距离。

$D(v, P)=\min\{d(v, u)\}$, $u$ 为路径 $P$ 上的结点。

树网的直径：树网中最长的路径成为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

偏心距 $\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即

$$\mathrm{ECC}(F)=\max\{D(v, F),v \in V\}$$

任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)


## 说明/提示

- 对于 $40\%$ 的数据，保证 $n \le 15$。
- 对于 $70\%$ 的数据，保证 $n \le 80$。
- 对于 $100\%$ 的数据，保证 $2\le n \le 300$，$0\le s\le10^3$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^3$。

NOIP2007 提高组第四题

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```

### 输出

```
5```

# AI分析结果



---

## 算法分类  
树的最长路径（直径）性质 + 双指针滑动窗口优化  

---

## 综合分析与结论  

### 核心算法流程  
1. **确定直径**：两次DFS确定直径端点，记录路径上的所有节点。  
2. **预处理支链最大值**：对直径上的每个节点，计算其非直径分支的最远距离（支链）。  
3. **双指针滑动窗口**：在直径上维护一个长度≤s的窗口，动态计算窗口左端到直径起点的距离、右端到直径终点的距离，结合预处理的支链最大值，取三者最大值即为当前窗口的偏心距。  

### 解决难点  
- **直径唯一性处理**：通过严格数学证明，所有直径必然相交且中点唯一，因此任选一条直径即可。  
- **支链影响**：通过预处理每个节点的支链最大值，避免动态计算的复杂逻辑。  
- **高效枚举路径**：利用双指针维护滑动窗口，将时间复杂度从O(n²)优化至O(n)。  

### 可视化设计思路  
- **颜色标记**：  
  - 红色高亮当前滑动窗口的左右端点。  
  - 蓝色标记直径路径，绿色显示支链最大距离。  
- **动画控制**：步进式展示双指针移动过程，每步更新三个偏心距分量，突出最大值来源。  
- **复古像素风**：用8位风格绘制树结构，直径节点显示为黄色方块，支链用绿色线条延伸。  

---

## 题解评分（≥4星）  

1. **StudyingFather（5星）**  
   - 亮点：严谨的数学证明，覆盖所有边界情况，代码模块化设计。  
   - 关键代码：双指针滑动窗口结合前缀和优化。  

2. **Mosklia（4星）**  
   - 亮点：O(n)时间复杂度实现，利用单调队列动态维护区间最大值。  
   - 心得：“没事千万别死磕题，智商会下降的”——调试经验真实。  

3. **Hyvial（4星）**  
   - 亮点：简洁的双指针实现，预处理支链最大值提升效率。  
   - 代码：`work()`函数高效整合DFS与双指针逻辑。  

---

## 最优思路提炼  

### 关键步骤  
```cpp  
// 预处理支链最大值  
void Getmxd() {  
    for (int u : diameter_nodes) {  
        vis[u] = true; // 标记直径节点  
        dfs(u, 0); // 非直径方向DFS找支链最远距离  
        mxd[u] = max_distance;  
    }  
}  

// 双指针滑动窗口  
int ans = INF;  
for (int l=0, r=0; l < diameter.size(); l++) {  
    while (r < diameter.size() && sum[r]-sum[l] <= s) r++;  
    int ecc = max({left_dist[l], right_dist[r], max_chain(l, r)});  
    ans = min(ans, ecc);  
}  
```  

### 数学优化  
偏心距公式：  
\[ \text{ECC}(F) = \max\left(\text{左端到起点}, \text{右端到终点}, \max_{i \in F}(\text{支链}_i)\right) \]  

---

## 相似题目推荐  
1. **P2491 [SDOI2011]消防**：同题数据加强版，需进一步优化。  
2. **P4408 [NOI2003]逃学的小孩**：基于直径性质的最优化问题。  
3. **P3629 [APIO2010]巡逻**：动态调整树结构后的最长路径问题。  

---

## 可视化实现片段（Canvas）  

```javascript  
// 绘制直径路径  
ctx.fillStyle = '#00f';  
diameter.forEach((node, idx) => {  
    ctx.fillRect(idx*20, 100, 15, 15); // 蓝色方块  
});  

// 滑动窗口高亮  
ctx.fillStyle = '#f00';  
ctx.fillRect(leftIdx*20, 100, 15, 15); // 左端点  
ctx.fillRect(rightIdx*20, 100, 15, 15); // 右端点  

// 支链动画  
ctx.beginPath();  
ctx.moveTo(nodeX, nodeY);  
ctx.lineTo(branchX, branchY);  
ctx.strokeStyle = '#0f0'; // 绿色线条  
ctx.stroke();  
```  

---

## 复古游戏化设计  
- **音效**：  
  - 移动指针：8-bit“哔”声（Web Audio API生成）。  
  - 找到更优解：上升音阶提示。  
- **积分系统**：每缩小1单位偏心距得10分，连击加成。  
- **自动演示模式**：AI控制双指针移动，速度可调（1x/2x/5x）。  

---

**答案**  
\boxed{5}

---
处理用时：74.02秒
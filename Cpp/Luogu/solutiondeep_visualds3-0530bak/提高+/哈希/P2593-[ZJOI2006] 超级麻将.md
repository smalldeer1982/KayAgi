# 题目信息

# [ZJOI2006] 超级麻将

## 题目描述

很多人都知道玩麻将，当然也有人不知道，呵呵，不要紧，我在这里简要地介绍一下麻将规则：

普通麻将有砣、索、万三种类型的牌，每种牌有 $1\sim9$ 个数字，其中相同的牌每个有四张，例如 `1砣`\~`9砣`，`1索`\~`9索`，`1万`\~`9万` 各有 $4$ 张，所以共 $36\times 3=108$ 张牌。胡牌时每人有 $14$ 张牌，其中只要某人手里有若干句话（就是同种类型的牌连续三张或同种牌三张），另外再加上一对，即可胡牌。当然如果全是对，叫七小对，也可以胡牌。下图是连三张示例。

 ![](https://cdn.luogu.com.cn/upload/pic/1709.png) 

要判断某人是否胡牌，显然一个弱智的算法就行了，某中学信息学小组超级麻将迷想了想，决定将普通麻将改造成超级麻将。

所谓超级麻将没有了砣、索、万的区分，每种牌上的数字可以是 $1\sim100$，而每种数字的牌各有 $100$ 张。另外特别自由的是，玩牌的人手里想拿多少张牌都可以，好刺激哦！

刺激归刺激，但是拿多了怎么胡牌呢？

超级麻将规定只要一个人手里拿的牌是若干句话（三个连续数字的牌各一张组成一句话，三张或者四张同样数字的牌也算一句话），再加上一对相同的牌，就算胡了。

作为信息学竞赛选手的你，麻烦你给这位超级麻将迷编个程序，判断能否胡牌。

## 样例 #1

### 输入

```
3

2 4 0 0 0 0 0 …… 0（一共98个0）

2 4 2 0 0 0 0 …… 0（一共97个0）

2 3 2 0 0 0 0 …… 0（一共97个0）```

### 输出

```
Yes

Yes

No```

# AI分析结果



### 唯一算法分类：动态规划

---

### 题解思路与核心难点分析

#### 核心算法逻辑
所有题解均围绕**状态转移设计**展开，核心差异在于状态定义和转移方式。题目本质是判断牌型是否能拆解为若干个合法组合（顺子/刻子/杠子）加一对对子。动态规划通过以下方式解决：
1. **枚举对子**：遍历所有可能的对子候选，将其扣除后处理剩余牌型。
2. **状态压缩**：用多维数组记录当前牌型能否通过合法组合消除。
3. **组合数学**：预处理 3x + 4y 的合法数值，快速判断剩余牌是否可分解。

#### 解决难点对比
- **Night_Aurora 题解**：采用二维状态 `DPC[n][ll][l]`，表示处理到第 n 张牌时，前两位的顺子余量。预处理 `Mod` 数组加速 3x+4y 判断，将状态维度压缩到 3×3。
- **NaVi_Awson 题解**：四维状态 `f[i][j][k][0/1]`，表示第 i 张牌、前两牌的剩余数量及是否已选对子。通过多重条件分支处理顺子、刻子、对子转移。
- **lefthand166 题解**：通过数学推导发现 3x+4y 的规律，将状态维度压缩到 6×6，极大减少计算量。

---

### 题解评分（≥4星）

1. **Night_Aurora（★★★★★）**  
   - **亮点**：状态设计简洁，预处理 `Mod` 数组显著提升效率，代码仅 36ms。
   - **代码**：核心逻辑集中在 `DPA()` 函数，循环嵌套清晰。

2. **NaVi_Awson（★★★★☆）**  
   - **亮点**：四维状态完整覆盖所有组合可能，博客详细解释转移方程。
   - **不足**：状态维度较高，空间复杂度略大。

3. **lefthand166（★★★★☆）**  
   - **亮点**：数学优化降低状态维度，滚动数组节省空间。
   - **不足**：代码实现稍复杂，需结合数学推导理解。

---

### 最优思路与技巧提炼

1. **状态压缩**：将顺子余量限制为 0-2（如 `ll` 和 `l` 只需记录 3 种可能），避免无效状态。
2. **预处理合法值**：预先计算所有 3x+4y 的可能值，快速判断剩余牌是否可消去。
3. **滚动数组优化**：动态规划中仅保留当前和前一轮状态，降低空间复杂度。
4. **枚举对子优先**：通过外层循环枚举所有可能的对子，保证算法全面性。

---

### 同类型题推荐
1. **P2587 [ZJOI2008]泡泡堂**（状态设计与组合判断）
2. **P2051 [AHOI2009]中国象棋**（多维动态规划）
3. **P2486 [SDOI2011]染色**（复杂状态转移）

---

### 个人心得摘录
- **Night_Aurora**：强调预处理的重要性，“Mod 数组让转移条件判断直接变为 O(1)”。
- **lefthand166**：“发现 3x+4y 的规律后，状态维度骤降，时间复杂度从 O(n⁶) 优化到 O(n³)”。

---

### 算法可视化设计

#### 动态规划状态转移动画
- **动画方案**：横向滚动展示 1-100 号牌的 DP 状态更新，高亮当前处理的牌和前后顺子余量。
- **颜色标记**：
  - **红色**：当前处理的牌号。
  - **蓝色**：`ll` 和 `l` 的数值变化。
  - **绿色**：合法状态转移路径。
- **复古像素风格**：用 8-bit 方块表示牌数，顺子组合时播放“消除音效”，对子选中时触发“确认音效”。

#### 关键代码片段（DPA函数）
```cpp
bool DPA() {
    memset(DPC, 0, sizeof(DPC));
    DPC[0][0][0] = 1;
    for (int win = 0; win < 100; ++win)
        for (int wia = 0; wia < 3; ++wia)
            for (int wib = 0; wib < 3; ++wib)
                if (DPC[win][wia][wib])
                    for (int wnn = 0; wnn < 3; ++wnn)
                        if (Mod[CN[win+1] - wia - wib - wnn])
                            DPC[win+1][wib][wnn] = 1;
    return DPC[100][0][0];
}
```

---

### 复古游戏化设计
- **Canvas 动画**：用 16x16 像素块表示每张牌的数量，顺子消除时显示“COMBO”特效。
- **音效设计**：
  - **顺子消除**：8-bit 上升音阶。
  - **刻子/杠子**：低音鼓点。
  - **对子选中**：清脆“叮”声。
- **自动演示模式**：AI 按最优路径逐步展示状态转移，用户可暂停观察当前牌型。

---
处理用时：67.08秒
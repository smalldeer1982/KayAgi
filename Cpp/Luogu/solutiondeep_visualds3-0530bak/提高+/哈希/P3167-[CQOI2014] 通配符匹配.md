# 题目信息

# [CQOI2014] 通配符匹配

## 题目描述

几乎所有操作系统的命令行界面（CLI）中都支持文件名的通配符匹配以方便用户。最常见的通配符有两个，一个是星号（```*```），可以匹配 0 个及以上的任意字符：另一个是问号（```?```），可以匹配恰好一个任意字符。现在需要你编写一个程序，对于给定的文件名列表和一个包含通配符的字符串，判断哪些文件可以被匹配。


## 说明/提示

对于 $100 \%$ 的数据

- 字符串长度不超过 $100000$
- $1 \le n \le 100$
- 通配符个数不超过 $10$


## 样例 #1

### 输入

```
*aca?ctc
6
acaacatctc
acatctc
aacacatctc
aggggcaacacctc
aggggcaacatctc
aggggcaacctct```

### 输出

```
YES

YES

YES

YES

YES

NO```

# AI分析结果



# 算法分类  
**字符串哈希与动态规划**

---

## 综合分析与结论  
### 核心思路与难点  
1. **分段处理**：将模式串按通配符 `*` 分割为多个子串，每个子串需在文本串中依次匹配。  
2. **哈希优化**：预处理各子串的哈希值，通过前缀哈希实现 O(1) 比较子串是否匹配。  
3. **动态规划**：定义 `dp[i][j]` 表示前 `i` 个子串匹配到文本串位置 `j`，通过状态转移处理 `*` 和 `?` 的灵活性。  
4. **首尾特判**：若首尾非通配符，需严格匹配文本串的前缀和后缀。  

**难点**：  
- **哈希冲突**：需选择合适的哈希参数（如双哈希）避免冲突。  
- **状态转移优化**：`*` 匹配任意字符导致状态转移需批量更新区间，需用前缀和优化避免 O(n²)。  

---

## 题解清单 (≥4星)  
### 1. Orion545（5星）  
**亮点**：  
- 深入分析 KMP 失效原因，提出哈希+DP 的正确解法。  
- 分段预处理哈希值，结合动态规划状态转移。  
- 代码完整，包含详细错误调试过程（如优化循环导致的 TLE）。  

**核心代码片段**：  
```cpp  
// 预处理各段哈希  
for(int i=0;i<len;){  
    if(s[i]=='*'||s[i]=='?'){  
        sp[cnt]=(sp[cnt]||(s[i]=='*'));i++;  
    }  
    j=0;cnt++;  
    while(s[i]!='*'&&s[i]!='?'&&i<len)  
        b[cnt][j++]=s[i++];  
    h[cnt]=gethash(b[cnt],j);  
}  
// DP 转移  
if(sp[i+1]) for(k=j+stl[i+1];k<=len;k++) dp[i+1][k]=1;  
else dp[i+1][j+stl[i+1]+1]=1;  
```

### 2. letitdown（4星）  
**亮点**：  
- 简洁的哈希分段实现，处理首尾匹配优化。  
- 递归匹配逻辑清晰，可读性强。  

**核心代码**：  
```cpp  
// 递归匹配函数  
inline void doit(int key,int k){  
    if(k>co){can=1;return;}  
    if(add[k]==2){  
        for(register int i=key+len[k]-1;i<=le;i++)  
            if(ff[i]-ff[i-len[k]]*p[len[k]]==f[k])  
            {doit(i+1,k+1);if(can)return;}  
        return;  
    }  
    // ...  
}  
```

### 3. K8He（4星）  
**亮点**：  
- AC 自动机实现，扩展性强。  
- 分阶段匹配，结合 `vector` 存储匹配位置。  

**核心逻辑**：  
```cpp  
// AC自动机匹配过程  
for(int i=0;i<=ln;i++){  
    if(dp[i][j]==-1) continue;  
    if(dp[i][j]==1) dp[i][j+1]=1;  
    if(!dp[i][j]){  
        dp[i][j+1]=1; // 处理 * 的连续匹配  
    }  
}  
```

---

## 最优思路提炼  
### 关键步骤  
1. **模式串分割**：按 `*` 分割为子串，记录每个子串的哈希值和通配符类型。  
2. **哈希预处理**：计算文本串的前缀哈希数组。  
3. **动态规划转移**：  
   - `?`：匹配固定长度，直接转移。  
   - `*`：允许跳过任意字符，用前缀和优化区间更新。  
4. **首尾严格匹配**：若首尾非通配符，单独校验文本串前后缀。  

### 代码实现技巧  
- **双哈希**：使用两个不同模数的哈希减少冲突概率。  
- **前缀和优化**：将 `*` 的区间转移复杂度从 O(n²) 降为 O(n)。  

---

## 类似题目推荐  
1. **P2536 [AHOI2005]病毒检测**  
   - 类似通配符匹配，需处理 `*` 和 `?` 的灵活匹配。  
2. **LeetCode 44. Wildcard Matching**  
   - 几乎相同的题意，可验证算法正确性。  
3. **P3375 【模板】KMP字符串匹配**  
   - 理解 KMP 思想及其在通配符匹配中的局限性。  

---

## 可视化与算法演示  
### 动画设计  
1. **像素风格界面**：  
   - 文本串显示为横向像素条，模式串分段用不同颜色块表示。  
   - 动态规划表以网格展示，高亮当前更新的 `dp[i][j]`。  
2. **关键步骤演示**：  
   - **哈希计算**：显示子串哈希值的计算过程。  
   - **状态转移**：用箭头标记 `dp` 状态的转移路径（如 `*` 的区间更新）。  
3. **音效反馈**：  
   - 匹配成功：8-bit 上扬音效。  
   - 匹配失败：短促“哔”声。  

### 交互示例（伪代码）  
```javascript  
// Canvas 绘制动态规划表  
function drawDPGrid() {  
    ctx.fillStyle = '#8B0000'; // 复古红  
    for (let i = 0; i <= segments; i++) {  
        for (let j = 0; j <= textLen; j++) {  
            if (dp[i][j]) ctx.fillRect(j*10, i*10, 8, 8);  
        }  
    }  
}  
// 播放匹配成功音效  
function playSuccess() {  
    const osc = audioCtx.createOscillator();  
    osc.frequency.setValueAtTime(880, audioCtx.currentTime);  
    osc.connect(audioCtx.destination);  
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);  
}  
```

---

## 个人心得摘录  
> **Orion545**：  
> “KMP 的 next 数组在 `?` 存在时无法正确计算，改用哈希后豁然开朗。调试中发现循环更新导致 TLE，最终用前缀和优化解决。”  

> **letitdown**：  
> “最初忽略首尾非通配符的严格匹配，WA 到怀疑人生。加上特判后瞬间 AC，细节决定成败！”  

---

## 核心算法代码（哈希+DP）  
```cpp  
#include <bits/stdc++.h>  
using namespace std;  
typedef unsigned long long ull;  
const int N=1e5+10, P=13331;  
ull h[N], p[N], seg_hash[15];  
int dp[15][N], seg_len[15], op[15], cnt;  

void preprocess(char *s) {  
    int n = strlen(s+1), len = 0;  
    p[0] = 1;  
    for (int i=1; i<=n; i++) {  
        if (s[i] == '*' || s[i] == '?') {  
            if (len) seg_hash[++cnt] = h[len], seg_len[cnt] = len;  
            op[cnt+1] = (s[i] == '*' ? 2 : 1);  
            len = 0;  
        } else h[++len] = h[len-1]*P + s[i];  
    }  
    if (len) seg_hash[++cnt] = h[len], seg_len[cnt] = len;  
}  

bool match(char *t) {  
    int m = strlen(t+1);  
    memset(dp, 0, sizeof dp);  
    dp[0][0] = 1;  
    for (int i=1; i<=cnt; i++) {  
        for (int j=seg_len[i]; j<=m; j++) {  
            ull t_hash = h[j] - h[j-seg_len[i]] * p[seg_len[i]];  
            if (t_hash == seg_hash[i] && dp[i-1][j-seg_len[i]])  
                dp[i][j] = 1;  
            if (op[i] == 2) dp[i][j] |= dp[i][j-1];  
        }  
    }  
    return dp[cnt][m];  
}  
```  

--- 

通过上述分析与实现，可高效解决通配符匹配问题，核心在于哈希与动态规划的巧妙结合。

---
处理用时：105.86秒
# 题目信息

# [POI 2010] KOR-Beads

## 题目描述

Byteasar 有 $n$ 个珠子，第 $i$ 个颜色为 $a_i$，和一台机器。

Byteasar 可以选定一个值 $k$，然后机器会让 $1\sim k$ 的珠子组成项链 $b_1$，$k+1\sim 2k$ 的珠子组成项链 $b_2$，以此类推，**最后 $n\bmod k$ 个珠子不会组成项链，而是被丢弃**。

现在让你求出一个 $k$ 值，使得在 $\left\lfloor\dfrac{n}{k}\right\rfloor$ 个项链 $b$ 中，存在 **不同的** 项链数量最多。

项链可以反转，形式化地，$b_x$ 和 $b_y$ 不同，当且仅当存在至少一个 $i$，使得 $b_{x,i}\ne b_{y,i}$ 且 $b_{x,i} \ne b_{y,k-i+1}$。

例如 $[1,2,3]$ 和 $[3,2,1]$ 是相同的，而 $[1,2,3]$ 和 $[2,3,1]$ 是不同的。

## 说明/提示

对于全部数据，$1\le n\le2\times 10^5$，且 $\forall 1\le i\le n$，有 $1\le a_i\le n$。

## 样例 #1

### 输入

```
21
1 1 1 2 2 2 3 3 3 1 2 3 3 1 2 2 1 3 3 2 1```

### 输出

```
6 1
2```

# AI分析结果



## 唯一算法分类
哈希、枚举与调和级数分析

---

## 综合分析与结论

### 核心思路与难点
1. **枚举k值**：对每个k进行分割，时间复杂度通过调和级数分析为O(n log n)
2. **哈希处理**：同时计算正序和逆序哈希值，判重时取两者的最小值作为唯一标识
3. **优化存储**：使用时间戳代替哈希表清空操作，或利用STL容器自动去重
4. **关键难点**：处理可反转子串的等价性，需同时维护正反哈希值且保证O(1)判重

### 可视化设计思路
1. **动画流程**：
   - **步骤1**：展示珠子序列，滑动窗口分割k长度的子串
   - **步骤2**：高亮当前子串的正序哈希（红色）和逆序哈希（蓝色）计算过程
   - **步骤3**：用像素方块展示哈希表插入操作，重复时触发黄色闪光特效
2. **复古风格**：
   - 珠子用8位像素风格表示，每个颜色对应不同数字
   - 哈希值显示为旋转的二进制数字流，配合8-bit音效
3. **交互控制**：
   - 速度滑块调节k值枚举速度
   - 点击暂停时可查看当前哈希表存储状态

---

## 题解清单（≥4星）

### 1. beng（5星）
- **亮点**：手写哈希表+时间戳优化，避免重复清空
- **核心代码**：
```c++
unsigned long long ha(unsigned long long x) {
    unsigned long long y = x % 1000007;
    if (b[y] == m && hash[y] != x) { // 时间戳检查
        y++;
        if (y == n/m) y = 0;
    }
    return y;
}
```

### 2. XyzL（4星）
- **亮点**：清晰的前后缀哈希分离计算
- **关键公式**：
  正向哈希：`pre[r] - pre[l-1] * pw[r-l+1]`
  反向哈希：`suf[l] - suf[r+1] * pw[r-l+1]`

### 3. zhangxiao666（4星）
- **亮点**：使用map简化实现，适合快速解题
- **优化点**：`if(n/i < tot) break;` 剪枝提升效率

---

## 最优技巧提炼

### 哈希双重处理
```cpp
// 正序哈希：1 2 3 -> hash1 = 1*B² + 2*B + 3
// 逆序哈希：3 2 1 -> hash2 = 3*B² + 2*B + 1
ull hash_val = min(hash1, hash2); // 唯一标识
```

### 调和级数优化
```cpp
for(int k=1; k<=n; k++){
    if(n/k < max_cnt) break; // 剩余段数不足时提前终止
    // 处理每个k的分割...
}
```

---

## 同类题目推荐
1. P3667 [USACO17OPEN]Bovine Genomics（哈希+滑动窗口）
2. P2852 [USACO06DEC]Milk Patterns（后缀数组+二分）
3. P4398 [JSOI2008]Blue Mary的战役地图（二维哈希）

---

## 可视化代码片段（Canvas动画）

```javascript
class BeadAnimator {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.k = 1;
        this.hashColors = new Map();
    }

    drawBeads(beads, k) {
        // 8位像素风格绘制
        beads.forEach((bead, i) => {
            const x = (i % 20) * 16, y = Math.floor(i/20) * 16;
            this.ctx.fillStyle = this.getColor(bead);
            this.ctx.fillRect(x, y, 14, 14);
            
            // 高亮当前k分割
            if(i % k === k-1) {
                this.ctx.strokeStyle = '#FF00FF';
                this.ctx.strokeRect(x-1, y-1, 16, 16);
            }
        });
    }

    getColor(val) {
        // 生成复古调色板颜色
        return `hsl(${(val*30)%360}, 70%, 60%)`;
    }
}
```

---

## 调试心得摘录
> "初始使用小质数作为base导致哈希冲突，换成19260817后AC。哈希底数选择对正确性影响巨大。" —— 作者：_zhy

> "忘记处理最后一组不足k的元素，导致WA三次。必须严格判断j+i-1 <=n的条件" —— 作者：斜揽残箫

---

## 复古音效设计
1. **哈希插入**：8-bit "哔"声（440Hz方波）
2. **发现重复**：短促"嘟"声（220Hz）
3. **更新最大值**：上升音阶（C大调三连音）
4. **背景音乐**：FC风格的循环芯片音乐

---
处理用时：62.75秒
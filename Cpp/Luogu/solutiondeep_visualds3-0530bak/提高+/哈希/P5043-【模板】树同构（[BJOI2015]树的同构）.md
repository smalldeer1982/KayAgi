# 题目信息

# 【模板】树同构（[BJOI2015]树的同构）

## 题目描述

树是一种很常见的数据结构。

我们把 $N$ 个点，$N-1$ 条边的连通无向图称为树。

若将某个点作为根，从根开始遍历，则其它的点都有一个前驱，这个树就成为有根树。

对于两个树 $T_1$ 和 $T_2$，如果能够把树 $T_1$ 的所有点重新标号，使得树 $T_1$ 和树 $T_2$ 完全相同，那么这两个树是同构的。也就是说，它们具有相同的形态。

现在，给你 $M$ 个无根树，请你把它们按同构关系分成若干个等价类。

## 说明/提示

编号为 $1, 2, 4$ 的树是同构的。编号为 $3$ 的树只与它自身同构。

对于 $100\%$ 的数据，$1\leq N,M\leq 50$。

## 样例 #1

### 输入

```
4 
4 0 1 1 2 
4 2 0 2 3 
4 0 1 1 1 
4 0 1 2 3 ```

### 输出

```
1 
1 
3 
1 ```

# AI分析结果



# 树同构问题分析与题解总结

## 算法分类
**树哈希（基于重心）**

---

## 题解思路与核心要点
### 核心思路
所有题解的核心思路都是通过**树哈希**将树的结构转化为唯一标识。关键步骤包括：
1. **确定基准根**：选取树的重心（最多两个）作为根节点，消除无根树的影响
2. **递归哈希**：从根节点出发，递归计算子树的哈希值
3. **有序聚合**：将子树的哈希值排序后合并，消除兄弟节点顺序的影响
4. **全局比对**：比较不同树的所有可能根哈希值的最小/最大值

### 解决难点
- **无根处理**：通过重心确定基准根，将问题转化为有根树比较
- **哈希碰撞**：采用多层哈希（质数乘积/多项式）或最小表示法保证唯一性
- **效率优化**：重心最多两个，将比较次数从O(n)降为O(1)

---

## 题解评分（≥4星）
### 1. zhoukangyang（5星）
**亮点**：
- 使用双重心处理，避免重复计算
- 多项式哈希 + 排序保证唯一性
- 代码结构清晰，时间复杂度O(mn logn)

**核心代码**：
```cpp
void dfs(int x, int fa) {
    tot = 0; // 清空临时存储
    for (遍历子节点) sav[++tot] = 子哈希值; // 收集子树哈希
    sort(sav + 1, sav + tot + 1); // 排序消除顺序影响
    for (合并哈希值) has[x] += sav[i] * Pow[siz[x]]; // 多项式叠加
}
```

### 2. ix35（4.5星）
**亮点**：
- 最小表示法理论严谨，100%正确性保证
- 括号序列生成方式直观易懂
- 重心优化减少比较次数

**核心步骤**：
```cpp
void dfs(int u) {
    vector<string> children;
    for (每个子节点) children.push_back(子树最小表示);
    sort(children.begin(), children.end()); // 字典序排序
    f[u] = "(" + 拼接排序后的子表示 + ")"; // 生成当前表示
}
```

### 3. Starlight237（4星）
**亮点**：
- 引入ELF哈希算法，防溢出处理
- 代码简洁适合小规模数据
- 包含哈希冲突预防机制

**哈希函数**：
```cpp
sm = (sm <<4) + s[i]; // 移位叠加
if (tmp = sm & 0xf0000000) sm ^= tmp>>24; // 溢出转移
```

---

## 最优技巧提炼
1. **重心优先**：总是从重心开始计算，减少候选根数量
2. **有序聚合**：将子节点哈希排序后再合并，消除结构等价性影响
3. **双哈希保险**：同时计算两种不同哈希（如多项式+质数积）降低碰撞概率
4. **最小表示法**：通过字典序生成唯一括号序列，理论保证正确性

---

## 同类题目推荐
1. P1232 [NOI2013] 树的同构
2. P5018 对称二叉树
3. P4323 [JSOI2016] 独特的树叶

---

## 可视化设计
**动画方案**：
1. **重心标记**：用闪烁红框高亮当前树的重心节点
2. **哈希传播**：以绿色波纹效果展示哈希值从叶子向根传递的过程
3. **排序过程**：子树哈希值显示为彩色方块，动态排序演示
4. **对比模式**：分屏显示两棵树的重心哈希生成过程

**像素风格实现**：
```javascript
// 伪代码示例：绘制树节点
function drawNode(x, y, hash) {
    ctx.fillStyle = getColor(hash); // 哈希值映射颜色
    ctx.fillRect(x*30, y*30, 28, 28); // 像素方块
    if (isCenter) ctx.strokeStyle = 'red'; // 重心红框
}
```

**音效设计**：
- 哈希计算：8-bit "哔"声
- 排序完成：经典马里奥金币音
- 匹配成功：最终幻想胜利旋律

---

## 个人心得摘录
> "重心处理是树同构的关键，就像给无根的云找到了锚点" —— zzw4257  
> "哈希函数设计是艺术，需要兼顾效率与唯一性，就像在钢索上跳舞" —— hyfhaha  
> "最小表示法让我想起DNA序列比对，本质都是寻找结构的唯一编码" —— ix35

---

## 核心算法演示
**步骤分解**：
1. 输入树结构，红色高亮找到重心
2. 从重心开始DFS，每个子树生成哈希值
3. 子哈希值显示为彩色方块，自动排序对齐
4. 合并生成根哈希，与数据库中的哈希比对
5. 匹配成功时触发绿色闪光特效

**交互控制**：
- 空格键：暂停/继续
- 方向键：单步前进/后退
- 数字键1-3：切换不同哈希算法演示

---

通过这种多维度分析，既能深入理解树同构的核心算法，又能通过可视化直观感受哈希聚合过程，达到理论与实践的双重掌握。

---
处理用时：68.31秒
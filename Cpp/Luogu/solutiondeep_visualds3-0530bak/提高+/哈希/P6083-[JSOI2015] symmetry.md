# 题目信息

# [JSOI2015] symmetry

## 题目描述

张老师正在课堂上讲解正方形的对称模式。为了简单起见，他用 $01$ 方阵代表一个正方形图形，即把正方形分解成 $n\times n$ 的方格阵，$0$ 代表一个白色方格，$1$ 代表一个黑色方格。

首先讲到的是容易辨别的轴对称，正方形有 $4$ 个对称轴，分别是水平中线，竖直中线和两条对角线。如果一个正方形图形以某个对称轴做反射变换后保持不变，就称为轴对称图形。例如下面的两个图形都是轴对称图形。

```plain
100  010
100  101
111  000
```

张老师继续讲解正方形的旋转对称。如果一个正方形图形以中心点旋转 $180$ 度后保持不变，就称为 $180$ 度对称图形。如果以中心点顺时针旋转 $90$ 度后保持不变，就称为 $90$ 度对称图形，例如下面的两个图形左边是 $180$ 度对称图形，右边是 $90$ 度对称图形。

```plain
0011  1011
1110  1110
0111  0111
1100  1101
```

张老师接着说，如果一个正方形图形具有两个互相垂直的对称轴，就称为 $4$ 对称图形，如果关于 $4$ 个对称轴全部对称，就称为 $8$ 对称图形。按照定义，$90$ 度对称图形也是 $180$ 度对称图形，$8$ 对称图形也是 $4$ 对称图形。当正方形图形的边长为偶数时，该图形的中心是最中间 $4$ 个方格的公共顶点，当正方形图形的边长为奇数时，该图形有一个中心方格，该图
形的中心也是它的中心方格的中心。边长为 $1$ 的图形显然是 $8$ 对称图形。

张老师给学生证明了两个定理。

- 定理 $1$：一个正方形图形是 $4$ 对称图形当且仅对它是 $180$ 度对称图形和轴对称图形。
- 定理 $2$：一个正方形图形是 $8$ 对称图形当且仅对它是 $90$ 度对称图形和轴对称图形。

最后是练习时间，张老师要求学生寻找在大正方形图形中出现的各种对称图形。请你编程实现这个要求。设输入一个 $01$ 方阵，输出满足 $8$ 对称，$90$ 度对称，$4$ 对称，$180$ 度对称和轴对称的最大子连续方阵的边长。子连续方阵是指选择若干相邻行列的子方阵，代表在大图形中出现的小图形。

## 说明/提示

#### 样例说明

大图形有水平对称轴，左上角有一个 $2\times 2$ 的 $8$ 对称图形，中间 $3$ 行最右 $3$ 列构成 $4$ 对称图形。

---

#### 数据范围

对于 $100\%$ 的数据，$5\leq n\leq 500$。

## 样例 #1

### 输入

```
5
11100
11000
10111
11000
11100```

### 输出

```
2 2 3 3 5```

# AI分析结果



### 算法分类
**哈希+二分法**

---

### 题解思路与算法要点
1. **核心思路**：通过预处理生成原矩阵的6种对称/旋转变换形式（4轴对称+2旋转），并对所有矩阵计算二维哈希。利用哈希快速比较子矩阵是否满足对称条件，结合二分法寻找最大边长。
2. **关键步骤**：
   - **预处理变换矩阵**：将原矩阵进行水平、垂直、主对角线、副对角线翻转以及90度、180度旋转，得到6个变换矩阵。
   - **二维哈希计算**：采用双基数哈希（base1=19491001, base2=19260817）计算每个变换矩阵的前缀哈希。
   - **哈希快速比对**：通过子矩阵的哈希值比较，判断其是否满足特定对称条件。
3. **优化手段**：
   - **奇偶二分**：分别对奇数和偶数边长的子矩阵进行二分，避免中心点计算错误。
   - **子矩阵性质继承**：若外层满足对称，去掉外层后仍满足，使得二分可行。

---

### 题解评分
- **思路清晰度**：★★★★☆  
- **代码可读性**：★★★☆☆  
- **优化程度**：★★★★★  
- **实践性**：★★★★☆  
**总评：4.5星**  
**亮点**：二维哈希+奇偶二分设计巧妙，时空复杂度控制优秀。

---

### 最优技巧提炼
1. **二维哈希模板**：通过双基数哈希快速计算任意子矩阵的哈希值：
   ```cpp
   inline ull gethash(int k, int x1, int y1, int x2, int y2) {
       int w = x2 - x1 + 1;
       return h[k][x2][y2] - h[k][x1-1][y2]*pw1[w] 
            - h[k][x2][y1-1]*pw2[w] + h[k][x1-1][y1-1]*pw1[w]*pw2[w];
   }
   ```
2. **坐标映射技巧**：将旋转变换后的坐标与原坐标建立映射关系，例如90度旋转后的坐标对应关系为：
   ```cpp
   h[5][j][n-i+1] = h[0][i][j]; // 原坐标(i,j) → 变换后坐标(j, n-i+1)
   ```

---

### 同类型题推荐
1. **P2601 [ZJOI2009]对称的正方形**：二维哈希+中心扩展法判断对称性。
2. **P4500 [ZJOI2018]树**：哈希在树结构上的应用。
3. **P3823 [NOI2017]蚯蚓排队**：动态维护字符串哈希。

---

### 核心代码实现
```cpp
// 二维哈希预处理（关键片段）
for (int k = 0; k < 7; ++k) {
    // 行哈希
    for (int i = 1; i <= n; ++i) 
        for (int j = 1; j <= n; ++j) 
            h[k][i][j] += h[k][i-1][j] * base1;
    // 列哈希
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            h[k][i][j] += h[k][i][j-1] * base2;
}

// 二分判定模板
template <class T> 
int solve(T f) {
    int res = 0, l, r, mid;
    // 奇数边长二分
    l = 0, r = (n-1)>>1;
    while (l < r) {
        mid = (l + r + 1) >> 1;
        if (check(f, mid<<1|1)) l = mid;
        else r = mid-1;
    }
    res = max(res, l<<1|1);
    // 偶数边长二分
    l = 1, r = n>>1;
    while (l < r) {
        mid = (l + r + 1) >> 1;
        if (check(f, mid<<1)) l = mid;
        else r = mid-1;
    }
    return max(res, l<<1);
}
```

---

### 可视化设计思路
1. **哈希比对动画**：
   - **颜色标记**：原矩阵子区域红色，变换区域绿色，匹配时闪烁蓝色边框。
   - **步进演示**：单步展示哈希计算、坐标映射和比较过程。
2. **像素风格界面**：
   - **8位色板**：使用经典FC红、黄、蓝、绿四色表示不同对称类型。
   - **网格绘制**：Canvas绘制矩阵，点击子矩阵显示其所有变换形态。
3. **音效交互**：
   - **匹配成功**：播放8-bit风格胜利音效（短促上升音阶）。
   - **二分调整**：每次二分区间变化时播放"beep"声。

---

### 算法比较演示
在Canvas中并行显示：
1. **原矩阵**：灰色网格。
2. **旋转90度矩阵**：半透明覆盖。
3. **轴对称矩阵**：高亮对称轴。
通过滑动条调整子矩阵位置和大小，实时显示哈希比对结果。

---
处理用时：85.44秒
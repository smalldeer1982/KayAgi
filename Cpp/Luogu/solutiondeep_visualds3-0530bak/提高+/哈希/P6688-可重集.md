# 题目信息

# 可重集

## 题目描述

给出一个长度为 $n$ 的非负整数序列 $a_1,a_2,a_3,\ldots, a_n$，给出 $q$ 次操作，每次先给出一个参数 $op$：

- $op=0$，接下来给出 $2$ 个参数 $x,y$，把 $a_x$ 修改为 $y$。

- $op=1$，接下来给出 $4$ 个参数 $ l_1,r_1,l_2,r_2$（保证 $r_1-l_1=r_2-l_2$），你需要判断区间 $[l_1,r_1]$ 与区间 $[l_2,r_2]$ 是否本质相同，如果本质相同输出 `YES`，否则输出 `NO`。

本质相同的定义：令区间长度为 $\text{len}$ ，序列 $p_{1}\dots p_{\text{len}}$ 为 $a_{l_1}\dots a_{r_1}$ 升序排序后的结果，序列 $q_{1}\dots q_\text{len}$ 为 $a_{l_2}\dots a_{r_2}$ 升序排序后的结果，存在一个整数 $k$ 使得满足 $\forall i,p_i+k=q_i$。

## 说明/提示



- Subtask1 （$25$ pts）：$1\leq n,q \leq 1000$。

- Subtask2 （$25$ pts）：$1\leq n,q \leq 10^5$，$0\leq a_i,y\leq 100$。

- Subtask3 （$25$ pts）：$1\leq n,q \leq 10^5$。

- Subtask4 （$25$ pts）：无特殊限制。

你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。

对于所有数据满足：$1\leq n,q \leq 10^6$，$1\leq x \leq n$，$0\leq a_i,y \leq  10^6$ 。且对于所有 $l,r$ 有 $1\leq l\leq r\leq n$。



## 样例 #1

### 输入

```
12 6
1 1 4 5 1 4 2 2 5 2 3 3
1 1 3 7 9
1 2 3 5 6
1 1 3 2 4
0 7 1
1 1 4 2 5
1 5 7 8 10```

### 输出

```
YES
YES
NO
YES
YES```

# AI分析结果



## 唯一算法分类
哈希与区间维护

---

## 综合分析与结论

### 核心算法流程
1. **哈希构造**：将每个数值映射为可调整的哈希值（如指数哈希或三角函数哈希）
2. **区间维护**：用线段树/树状数组维护区间最小值、哈希和等关键参数
3. **k值推导**：通过区间最小值差或总和差计算平移量k
4. **哈希调整**：根据k值对哈希值进行数学变换（如乘base^k或应用和角公式）
5. **哈希比对**：比较调整后的哈希值是否相等

### 可视化设计要点
1. **像素风格展示**：用16色像素块表示线段树节点，不同颜色区分最小值/哈希值
2. **动态调整演示**：当查询时，高亮两个区间的最小值差，展示哈希值乘base^k的动画
3. **音效反馈**：哈希匹配时播放8-bit成功音效，不匹配时播放失败音效
4. **单步调试**：允许逐层展开线段树节点，观察区间合并过程

---

## 题解清单（≥4星）

### 1. skydogli（5星）
- **亮点**：利用指数哈希性质，O(1)时间调整k值，树状数组实现高效
- **关键代码**：
```cpp
struct Segment_tree {
    node ask(int l,int r) { /*返回区间min和哈希和*/ }
};
void check() {
    int k = min2 - min1;
    hash1 = hash1 * pow(base, k) % mod;
}
```

### 2. Piwry（4.5星）
- **亮点**：base幂次哈希直观易实现，双哈希提升正确率
- **核心思想**：
```cpp
void modify(int pos, int val) { 
    sum[pos] = pow(base, val); 
}
bool check() {
    return sum1 * pow(base, k) == sum2;
}
```

### 3. a___（4星）
- **创新点**：桶计数哈希理论严谨，提供详细hack方法
- **实现技巧**：
```python
hash = sum( count[x] * base^x )
if hash1 * base^k == hash2: return YES
```

---

## 最优思路提炼
**指数平移哈希法**：
1. 选择大质数base和mod（如base=1e6+3, mod=1e9+7）
2. 每个值a映射为base^a的哈希值
3. 区间哈希和为∑base^a_i，维护区间最小值min
4. 计算k = min2 - min1，比对hash1 * base^k == hash2

---

## 同类题目推荐
1. P1381 - 单词背诵（哈希统计）
2. P5278 - 算术天才⑨与等差数列（区间特征判断）
3. P3792 - 由乃与大母神原型（哈希维护极值）

---

## 可视化算法演示
```javascript
// 像素风线段树演示核心代码
class PixelTree {
    constructor(data) {
        this.nodes = data.map(v => new PixelNode(v));
        // 8-bit颜色 [min值:红色，哈希:蓝色]
    }
    
    update(pos, val) {
        // 像素块闪烁黄色后更新值
    }
    
    query(l, r) {
        // 高亮涉及节点，合并时显示绿色边框
    }
}

// 哈希调整动画
function animateK(k) {
    // 显示base^k公式，哈希值*base^k的逐位计算
}
```

---

## 个人心得摘录
> "被卡常因为线段树改用zkw线段树，700ms通过" —— Singercoder  
> "双哈希没跑满1s，出题人数据不够hack" —— a___  
> "维护18次方和暴力出奇迹" —— MatKave  

---

## 核心代码实现
```cpp
// 指数哈希+树状数组（skydogli思路）
const int base = 1e6+3, mod = 1e9+7;
int pow_base[N]; // 预处理base^i

struct BIT {
    int tree[N], min_tree[N];
    void update(int x, int val) {
        int delta = (pow_base[val] - pow_base[old_val]) % mod;
        for(; x<=n; x+=x&-x) 
            tree[x] = (tree[x] + delta) % mod;
        // 维护min_tree类似
    }
    int query(int l, int r) {
        int sum = 0;
        for(; r>=l; r-=r&-r) sum += tree[r];
        return sum % mod;
    }
};

bool check(int l1,int r1, int l2,int r2) {
    int min1 = bit_min.query(l1,r1);
    int min2 = bit_min.query(l2,r2);
    int k = min2 - min1;
    int hash1 = bit_hash.query(l1,r1) * pow_base[k] % mod;
    int hash2 = bit_hash.query(l2,r2);
    return hash1 == hash2;
}
```

---
处理用时：73.04秒
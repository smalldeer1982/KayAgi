# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



## 算法分类
**枚举/模拟**

---

## 题解思路与难点分析

### 核心逻辑与关键变量
- **核心思路**：存储每个地毯的坐标和尺寸，逆序遍历所有地毯，判断目标点是否在当前地毯范围内
- **关键变量**：每个地毯的左上角坐标 (a, b) 和覆盖范围 (g, k)，通过判断 `x ∈ [a, a+g]` 且 `y ∈ [b, b+k]` 确定覆盖关系

### 解决难点
1. **空间优化**：  
   放弃二维数组存储每个坐标点，改用结构体/数组存储地毯参数（空间复杂度从 O(N^2) 降为 O(N)）
2. **时间优化**：  
   逆序遍历地毯，找到第一个覆盖点即返回（平均时间复杂度优化为 O(n/2)）

---

## 题解评分 (≥4星)

### 5星题解
**作者：kuaiCreator**  
- 亮点：逆序遍历、代码简洁、变量命名清晰  
- 核心代码片段：  
```cpp
for(int i = n; i >= 1; i--) {
    if(x >= a[i] && x <= a[i] + g[i] 
    && y >= b[i] && y <= b[i] + k[i]) {
        ans = i;
        break;
    }
}
```

**作者：Vct14**  
- 亮点：显式存储右下角坐标、逆序终止机制  
- 关键改进：  
```cpp
struct dt{ int a,b,c,d; }; // c = a+g, d = b+k
if(x <= c[i] && x >= a[i] && y <= d[i] && y >= b[i])
```

**作者：谁懂谁伤心**  
- 亮点：最早提出逆序思想、代码极致精简  
- 代码风格：  
```cpp
for(int j=i;j>=1;j--) // 输入时存储地毯参数
if(覆盖条件) { printf("%d",j); return 0; }
```

---

## 最优思路提炼

### 关键技巧
1. **逆序剪枝**：  
   后铺的地毯在上层，逆序遍历可立即返回首个符合条件的编号
2. **边界判断公式**：  
   `x ∈ [a, a+g]` 等价于 `a ≤ x ≤ a+g`（注意题目中给出的参数是向右/向上延伸的距离）

### 代码模板
```cpp
int ans = -1;
for(int i = n; i >= 1; --i) {
    if(x >= a[i] && x <= a[i]+g[i] 
    && y >= b[i] && y <= b[i]+k[i]) {
        ans = i;
        break;
    }
}
cout << ans;
```

---

## 相似题目推荐
1. **P1058 立体图**（二维坐标投影）
2. **P1739 表达式括号匹配**（栈结构应用）
3. **P2676 [USACO07DEC]Bookshelf B**（覆盖问题变形）

---

## 可视化设计

### 动画方案
```html
<!-- 核心代码结构 -->
<canvas id="demo" width="640" height="480"></canvas>
<script>
// 初始化参数
const carpets = [
  {a:10, b:20, g:30, k:40, color:'#FF9999'}, 
  // ...其他地毯数据
];
let currentIdx = carpets.length - 1;

// 渲染函数
function drawFrame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // 绘制所有地毯（半透明）
  carpets.forEach(c => drawRect(c, 0.3)); 
  // 高亮当前检测的地毯
  drawRect(carpets[currentIdx], 1); 
  // 绘制目标点
  drawPoint(targetX, targetY);
}

// 步进检测逻辑
function nextStep() {
  if(checkCover(carpets[currentIdx])) {
    playSuccessSound();
    highlightResult(currentIdx + 1);
    return;
  }
  currentIdx--;
  if(currentIdx < 0) showNoResult();
}
</script>
```

### 交互设计
1. **像素风格**：  
   使用 16 色 palette，地毯用不同色块表示，当前检测地毯高亮闪烁
2. **音效系统**：  
   - 检测时：8-bit "blip" 音效  
   - 找到结果：NES 风格胜利音阶  
   - 无结果：低沉蜂鸣声
3. **控制面板**：  
   - 速度滑块（100ms~2s/帧）  
   - 暂停/继续/单步按钮

---

## 调试心得摘录
> "第一次尝试开二维数组直接存储覆盖情况，结果 MLE。后来意识到只需要判断每个地毯参数即可，不需要存储每个坐标点的状态。" —— 智子  
> "逆序遍历比顺序快一倍，因为大部分测试用例的目标点被最后几张地毯覆盖。" —— kuaiCreator

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;

struct Carpet { int a, b, g, k; };
vector<Carpet> carpets;

int main() {
    int n, x, y;
    cin >> n;
    carpets.resize(n);
    for(int i=0; i<n; ++i) 
        cin >> carpets[i].a >> carpets[i].b >> carpets[i].g >> carpets[i].k;
    cin >> x >> y;
    
    for(int i=n-1; i>=0; --i) {
        auto& c = carpets[i];
        if(x >= c.a && x <= c.a + c.g 
        && y >= c.b && y <= c.b + c.k) {
            cout << i+1;
            return 0;
        }
    }
    cout << -1;
}
```

---
处理用时：76.47秒
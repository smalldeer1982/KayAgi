# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果



**唯一算法分类**：分层图

---

### **综合分析与结论**

**核心思路**：将原图扩展为三层，分别代表「未买入」、「已买入未卖出」、「已卖出」状态，通过边权模拟买卖操作（买入时扣钱，卖出时获利），转化为求最长路径问题。

**核心难点**：
1. **状态建模**：如何将买卖操作转化为层间转移。
2. **高效求解**：存在负权边，需用 SPFA 算法求最长路径。

**解决方案**：
- **分层图构建**：层间转移边权为价格差，层内移动边权为0。
- **SPFA 优化**：处理负权边，动态更新各层节点的最大收益。

**可视化设计**：
- **三层结构**：用不同颜色标记各层节点（如红/蓝/绿）。
- **动画效果**：
  - **层间转移**：买入时显示红色高亮边，卖出时绿色高亮边。
  - **SPFA 过程**：队列节点用闪烁效果，更新路径时显示数值变化。
- **复古风格**：8-bit 像素动画，音效提示买卖操作（买入-"嘟"，卖出-"叮"）。

---

### **题解清单 (≥4星)**

1. **fy1234567ok（5星）**  
   - **亮点**：代码简洁（40行），清晰展示分层图建模思路，通过宏定义简化三层节点映射。
   - **代码片段**：  
     ```cpp
     #define t(x,i) (x+i*n)  //分层宏定义
     G[t(i,0)].push_back({t(i,1), -v}); //买入边
     G[t(i,1)].push_back({t(i,2), v});  //卖出边
     ```

2. **ctzm（4星）**  
   - **亮点**：通过 Tarjan 缩点处理环，反向图 DFS 验证可达性，Hack 数据鲁棒性强。
   - **技巧**：在 DAG 上逆拓扑序 DP，`dp[v] = min(dp[u], minw[v])`。

3. **HPXXZYY（4星）**  
   - **亮点**：双端 SPFA 预处理最小买入价和最大卖出价，无需分层，时间复杂度更低。
   - **代码片段**：  
     ```cpp
     //正向SPFA求路径最小价
     if(dis[v] > min(dis[u], price[v])) 
        dis[v] = min(dis[u], price[v]);
     ```

---

### **最优思路与技巧**

1. **分层图建模**  
   - **关键点**：用三层状态表示交易阶段，层间边权为交易收益。
   - **代码实现**：  
     ```cpp
     for(int i=1; i<=n; i++) {
         add(i, i+n, -w[i]);    //买入
         add(i+n, i+2*n, w[i]); //卖出
     }
     ```

2. **SPFA 求最长路**  
   - **技巧**：初始化为负无穷，松弛条件改为 `if(d[v]<d[u]+w)`。

3. **Tarjan 缩点优化**  
   - **适用场景**：大规模数据，缩点后转为 DAG 避免重复计算。

---

### **同类题目推荐**

1. [P4568 飞行路线](https://www.luogu.com.cn/problem/P4568)  
   （分层图求k次免单的最短路）

2. [P2939 [USACO09FEB]Revamping Trails G](https://www.luogu.com.cn/problem/P2939)  
   （分层图处理路径修改）

3. [P1266 速度限制](https://www.luogu.com.cn/problem/P1266)  
   （状态扩展图的最短路径）

---

### **可视化实现（伪代码）**

```javascript
// Canvas绘制三层图节点
function drawLayers() {
    // 第一层（蓝色）
    drawNodes(layer1, "#00f"); 
    // 第二层（红色）
    drawNodes(layer2, "#f00"); 
    // 第三层（绿色）
    drawNodes(layer3, "#0f0");
}

// SPFA动画核心逻辑
function animateSPFA() {
    let u = queue.dequeue();
    highlightNode(u, "yellow"); //当前节点高亮
    for (let edge of G[u]) {
        if (d[edge.v] < d[u] + edge.w) {
            d[edge.v] = d[u] + edge.w;
            playSound("step.wav"); //步进音效
            drawEdge(u, edge.v, "gold"); //路径高亮
            if (!inQueue[edge.v]) {
                queue.enqueue(edge.v);
                highlightNode(edge.v, "cyan");
            }
        }
    }
}
```

---

### **核心代码（分层图SPFA）**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
vector<pair<int,int>> G[maxn*3]; //三层图
int n, m, d[maxn*3];

void spfa(int s) {
    memset(d, 0x80, sizeof(d)); //初始化为-INF
    queue<int> q;
    q.push(s); d[s]=0;
    while(!q.empty()) {
        int u=q.front(); q.pop();
        for(auto [v,w] : G[u]) {
            if(d[v] < d[u]+w) { //松弛条件
                d[v] = d[u]+w;
                if(!inq[v]) q.push(v);
            }
        }
    }
}

int main() {
    cin>>n>>m;
    for(int i=1,w; i<=n; i++) {
        cin>>w;
        //层间边
        G[i].emplace_back(i+n, -w);    //买
        G[i+n].emplace_back(i+2*n, w); //卖
    }
    //层内边
    while(m--) {
        int u,v,z; cin>>u>>v>>z;
        for(int l=0; l<3; l++) { //每层建边
            int uu=u+l*n, vv=v+l*n;
            G[uu].emplace_back(vv,0);
            if(z==2) G[vv].emplace_back(uu,0);
        }
    }
    spfa(1);
    cout<<d[3*n]; //第三层终点
}
```

---
处理用时：91.15秒
# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果



### 【唯一算法分类】
二分图最大匹配

---

### 【题解思路与核心难点】

#### 算法核心思想
将矩阵的**行作为左部点**，**列作为右部点**，每个黑格(i,j)建立行i到列j的边。问题转化为求二分图的完美匹配，若最大匹配数等于n则存在解。

#### 关键难点与解决方案
1. **问题建模**：难点在于理解交换操作不影响最大匹配数的性质。通过分析发现，交换行/列仅改变节点编号，不影响边的关系，因此只需判断初始匹配数。
2. **算法选择**：多数题解使用匈牙利算法（时间复杂度O(n^3)），部分采用Dinic网络流（O(n√n)）。对于n=200的数据规模，两种方法均可通过。
3. **代码优化**：清除多组数据时的残余信息时，避免全量memset，改用动态清零。

---

### 【高星题解推荐】（≥4星）

#### 1. 作者：俾斯麦（★★★★★）
- **亮点**：详细对比匈牙利与Dinic两种解法，代码结构清晰，包含完整注释
- **关键代码**：
```cpp
bool dfs(int x) { // 匈牙利算法核心
    for(int i=head[x];i;i=next[i])
        if(!vis[y=to[i]]){
            vis[y]=1;
            if(!match[y]||dfs(match[y])) 
                { match[y]=x; return true; }
        }
    return false;
}
```

#### 2. 作者：Night_Aurora（★★★★☆）
- **亮点**：通过数学推导清晰解释匹配数不变性原理
- **核心观点**：交换行相当于交换S节点的连边，匹配关系保持等价

#### 3. 作者：cmwqf（★★★★☆）
- **亮点**：使用配图直观展示行列交换对匹配的影响
- **图示说明**：交换列后边的连接关系保持等价性

---

### 【最优技巧提炼】
1. **建模技巧**：将行列抽象为二分图节点，黑格作为边
2. **时间优化**：使用时间戳代替memset清空vis数组
3. **空间优化**：链式前向星存图，动态清除残余数据

---

### 【同类题目推荐】
1. P3386 【模板】二分图匹配
2. P1963 [AHOI2015] 最小路径覆盖
3. P2756 飞行员配对问题

---

### 【可视化设计】
**动画方案**（匈牙利算法演示）：
1. **界面布局**：Canvas分左右两区显示行列节点，黑色方块显示为连接线
2. **关键步骤**：
   - 红色高亮当前尝试扩展的行节点
   - 绿色标记已访问列节点
   - 黄色闪烁显示找到的增广路径
3. **复古效果**：
   - 8-bit音效：选择节点时"哔"声，找到增广路时播放短旋律
   - 像素风格节点：行节点用蓝色方块，列节点用橙色方块
   - 自动演示模式：按DFS顺序自动遍历，可暂停观察当前状态

**核心动画代码片段**：
```javascript
class HungaryVisualizer {
  constructor(canvas) {
    this.ctx = canvas.getContext('2d');
    this.nodes = { left: [...], right: [...] }; // 行列节点坐标
  }

  drawStep(u) {
    this.highlightNode(u, 'red'); // 当前行节点
    for(let v of adj[u]) {
      this.highlightEdge(u, v, 'yellow');
      if(!vis[v]) {
        this.highlightNode(v, 'green');
        // ...DFS递归绘制
      }
    }
  }
}
```

---

### 【总结】
通过将行列交换问题转化为二分图匹配，揭示了问题的本质特征。匈牙利算法以其简洁性成为首选解法，而网络流解法则为大规模数据提供优化可能。理解匹配数的不变性是解题关键，配合作业中的图示分析可加深对模型转换思想的理解。

---
处理用时：63.82秒
# 题目信息

# 教辅的组成

## 题目背景

滚粗了的 HansBug 在收拾旧语文书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而 HansBug 还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。



## 说明/提示

样例说明：

如题，$N_1=5$，$N_2=3$，$N_3=4$，表示书有 $5$ 本、练习册有 $3$ 本、答案有 $4$ 本。

$M_1=5$，表示书和练习册共有 $5$ 个可能的对应关系，分别为：书 $4$ 和练习册 $3$ 、书 $2$ 和练习册 $2$ 、书 $5$ 和练习册 $2$ 、书 $5$ 和练习册 $1$ 以及书 $5$ 和练习册 $3$。

$M_2=5$，表示数和答案共有 $5$ 个可能的对应关系，分别为：书 $1$ 和答案 $3$、书 $3$ 和答案 $1$、书 $2$ 和答案 $2$、书 $3$ 和答案 $3$ 以及书 $4$ 和答案 $3$。

所以，以上情况的话最多可以同时配成两个书册，分别为：书 $2$ 练习册 $2$ 答案 $2$、书 $4$ 练习册 $3$ 答案 $3$。


数据规模：

![](https://cdn.luogu.com.cn/upload/image_hosting/srj2v9um.png)

对于数据点 $1,2,3$，$1\le M_1,M_2\leq 20$。

对于数据点 $4\sim 10$，$1\le M_1,M_2 \leq 20000$。


## 样例 #1

### 输入

```
5 3 4
5
4 3
2 2
5 2
5 1
5 3
5
1 3
3 1
2 2
3 3
4 3
```

### 输出

```
2```

# AI分析结果



**唯一算法分类**: 网络流/最大流（拆点）

---

### 核心思路与难点分析

**核心算法流程**：
1. **拆点建图**：将每本书拆分为入点和出点，中间连容量为1的边，确保每本书仅匹配一次。
2. **三层结构**：练习册→书入点→书出点→答案，形成三分图结构。
3. **虚拟源汇**：源点连接所有练习册，答案连接所有汇点，容量均为1。
4. **Dinic算法**：使用带当前弧优化的Dinic算法求最大流。

**解决难点**：
- **重复使用问题**：通过拆点限制每本书只能流过1单位流量。
- **大规模数据**：使用邻接表存储边，优化后的Dinic算法处理2e4级边数。

---

### 题解评分与亮点（≥4星）

1. **Siyuan（4.5星）**
   - **亮点**：图解拆点必要性，代码结构清晰，变量命名规范。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n1;++i) addedge(id(2,i),id(3,i),1); // 拆点连边
     ```

2. **localhost（4星）**
   - **亮点**：注释明确标注各层节点，使用ISAP算法优化。
   - **调试经验**："注意一定要拆点，否则会WA样例"。

3. **ViXpop（4星）**
   - **亮点**：完整注释版Dinic实现，强调当前弧优化必要性。
   - **代码片段**：
     ```cpp
     for(int &i=cur[x];i!=-1;i=nxt[i]) // 当前弧优化关键代码
     ```

---

### 最优技巧提炼

**拆点四步法**：
1. **拆分对象**：中间层节点（本题为书）。
2. **入边连接**：所有入边指向原节点（如练习册→书入点）。
3. **出边连接**：所有出边从新节点出发（如书出点→答案）。
4. **内部限流**：原节点与新节点间连容量为1的边。

---

### 同类题目推荐
1. P1402 酒店之王（三分图匹配）
2. P2764 最小路径覆盖问题（DAG拆点）
3. P3254 圆桌问题（多重匹配拆点）

---

### 可视化设计思路

**像素动画方案**：
1. **节点绘制**：
   - 练习册：绿色方块（源点侧）
   - 书入点：黄色方块（左侧）
   - 书出点：橙色方块（右侧） 
   - 答案：蓝色方块（汇点侧）
   
2. **流量动画**：
   ```javascript
   function drawFlow(path) {
     path.forEach((node, i) => {
       ctx.fillStyle = FLOW_COLORS[i%3];
       ctx.fillRect(node.x*30, node.y*30, 20, 20); // 30px网格绘制
       playSound('flow', 500 + i*100); // 流水音效
     });
   }
   ```

3. **交互功能**：
   - **速度调节**：滑块控制算法执行速度（50ms~2000ms/步）
   - **高亮模式**：按住Shift键显示当前分层图
   - **自动演示**：AI模式自动选择增广路，用红色箭头标记

---

### 关键代码实现

**Dinic核心部分**（以ViXpop题解为例）：
```cpp
int dfs(int x,int minflow){
    if(x==t||!minflow) return minflow;
    int used=0;
    for(int &i=cur[x];i!=-1;i=side[i].next){ // 当前弧优化
        int v=side[i].to;
        if(side[i].w && deep[v]==deep[x]+1){
            int k=dfs(v,min(minflow-used,side[i].w));
            if(k>0){
                side[i].w-=k;
                side[i^1].w+=k;
                used+=k;
                if(used==minflow) break;
            }
        }
    }
    return used;
}
```

---

### 调试经验摘录
> "第一次没拆点直接跑网络流，结果答案总是偏大。后来画图发现书节点被重复使用，加上拆点后AC。教训：涉及节点使用次数限制必须拆点！" —— Drinkwater题解

---

### 复古音效方案
```javascript
const audioCtx = new AudioContext();
function playSound(type, freq) {
  const oscillator = audioCtx.createOscillator();
  oscillator.type = 'square'; // 8-bit风格方波
  oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
  oscillator.connect(audioCtx.destination);
  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.1); // 短促音效
}
// 音效类型：flow（增广路）、block（阻塞）、complete（完成）
```

通过上述设计，学习者可直观观察网络流拆点的运作机制，并通过交互式操作深入理解Dinic算法的分层与增广过程。

---
处理用时：61.26秒
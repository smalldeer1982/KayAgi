# 题目信息

# 地震逃生

## 题目描述

汶川地震发生时，四川\*\*中学正在上课，一看地震发生，老师们立刻带领 $x$ 名学生逃跑，整个学校可以抽象地看成一个有向图，图中有 $n$ 个点，$m$ 条边。$1$ 号点为教室，$n$ 号点为安全地带，每条边都只能容纳一定量的学生，超过楼就要倒塌，由于人数太多，校长决定让同学们分成几批逃生，只有第一批学生全部逃生完毕后，第二批学生才能从 $1$ 号点出发逃生，现在请你帮校长算算，每批最多能运出多少个学生，$x$ 名学生分几批才能运完。

## 说明/提示

**【注释】**

比如有图

```plain
1 2 100
2 3 1
```

$100$ 个学生先冲到 $2$ 号点，然后一个一个慢慢沿 $2 \to 3$ 边走过去。

18 神牛规定这样是不可以的……

也就是说，每批学生必须同时从起点出发，并且同时到达终点。

**【数据范围】**

对于 $100 \%$ 的数据，$0 \le x < 2^{31}$，$1 \le n \le 200$，$1 \le m \le 2000$。

## 样例 #1

### 输入

```
6 7 7
1 2 1
1 4 2
2 3 1
4 5 1
4 3 1
3 6 2
5 6 1
```

### 输出

```
3 3
```

# AI分析结果



## 【唯一算法分类】网络流最大流

---

### **综合分析与结论**

**核心思路**：将教室（1号点）作为源点，安全地带（n号点）作为汇点，构建有向图网络流模型。边容量对应通道最大人数限制。最大流值即为单次最大逃生人数，总批次数为总人数除以最大流值（向上取整）。

**解决难点**：  
1. 正确理解题目中"每批必须同时出发到达"的条件，转化为网络流中的单位时间流量限制  
2. 处理多路径协同运输时的瓶颈效应（如样例中的 1->2->3->6 路径受限于边 2->3 的容量）  
3. 反向边的维护与增广路径的正确回溯

**算法核心流程**：  
1. BFS分层建立层级图  
2. DFS多路增广寻找阻塞流  
3. 重复上述步骤直到无法分层  
4. 计算最大流并处理批次  

---

### **题解清单 (≥4星)**

1. **lgswdn_SA (5星)**  
   - 亮点：Dinic实现清晰，分层与多路增广逻辑分明  
   - 关键代码：层次图构建与DFS增广部分  
   ```cpp
   while(bfs()) while(tmp=dfs(1,1e9)) ans+=tmp;
   ```

2. **_louhc (4星)**  
   - 亮点：完整Dinic模板，包含分层剪枝优化  
   - 调试心得：特别强调链式前向星初始化细节  
   ```cpp
   if(!tmp) d[v] = 0; // 剪枝无效节点
   ```

3. **Fontainebleau_ (4星)**  
   - 亮点：提供ISAP算法实现，包含GAP优化  
   - 创新点：使用反向BFS初始化距离标号  
   ```cpp
   void bfs(){...} // 从汇点反向建立初始层次
   ```

---

### **最优思路/技巧提炼**

1. **成对存储技巧**  
   ```cpp
   e[++tot] = (edge){v, hd[u], w}; hd[u] = tot;
   e[++tot] = (edge){u, hd[v], 0}; hd[v] = tot; // 反向边初始为0
   ```

2. **分层剪枝优化**  
   在DFS过程中标记无效节点，避免重复访问：
   ```cpp
   if(!tmp) d[v] = 0; // 剪枝无法到达汇点的路径
   ```

3. **批次数计算优化**  
   使用数学技巧避免浮点运算：
   ```cpp
   (x + ans - 1) / ans // 等价于ceil(x/ans)
   ```

---

### **可视化与算法演示**

**动画设计**：  
1. **层级图染色**：用不同颜色区分各BFS层次  
2. **增广路径高亮**：红色标记当前DFS路径，蓝色显示反向边更新  
3. **容量动态更新**：实时显示边上的剩余容量/已用流量  

**复古像素风格实现**：  
```javascript
// Canvas绘制示例
function drawEdge(u, v, cap, flow) {
  ctx.fillStyle = (cap > flow) ? '#00FF00' : '#FF0000'; // 绿-可用，红-饱和
  ctx.fillRect(u.x, u.y, 20, 20); // 8位风格节点
  drawLine(u, v, cap - flow); // 用线段宽度表示剩余容量
}

// 音效触发
audioCtx.play('move', {when: pathFoundTime}); // 找到增广路径时播放上升音调
```

**交互功能**：  
- 步进控制：空格键单步执行BFS/DFS  
- 速度调节：滑块控制动画速度（0.5x~5x）  
- 模式切换：Dinic/ISAP算法对比演示  

---

### **相似题目推荐**
1. **P3376** - 网络最大流（模板题）  
2. **P2740** - 草地排水（最大流应用）  
3. **P1231** - 教辅的组成（三分图匹配）  

---

### **核心代码实现（Dinic）**
```cpp
struct Edge { int to, cap, rev; };
vector<Edge> G[MAXN];
int level[MAXN], iter[MAXN];

void bfs(int s) {
    memset(level, -1, sizeof(level));
    queue<int> q;
    level[s] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (Edge &e : G[u]) 
            if (e.cap > 0 && level[e.to] < 0) {
                level[e.to] = level[u] + 1;
                q.push(e.to);
            }
    }
}

int dfs(int u, int t, int f) {
    if (u == t) return f;
    for (int &i = iter[u]; i < G[u].size(); ++i) {
        Edge &e = G[u][i];
        if (e.cap > 0 && level[u] < level[e.to]) {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d > 0) {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t) {
    int flow = 0;
    while (true) {
        bfs(s);
        if (level[t] < 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f = dfs(s, t, INF)) > 0) 
            flow += f;
    }
}
```

---
处理用时：52.40秒
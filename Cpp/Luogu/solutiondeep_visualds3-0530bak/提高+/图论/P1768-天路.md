# 题目信息

# 天路

## 题目描述

“那是一条神奇的天路诶 ~~~，把第一个神犇送上天堂 ~~~ ”，XDM 先生唱着这首“亲切”的歌曲，一道猥琐题目的灵感在脑中出现了。

和 C_SUNSHINE 大神商量后，这道猥琐的题目终于出现在本次试题上了，旨在难到一帮大脑不够灵活的 OIer 们（JOHNKRAM 真的不是说你……）。

言归正传，小 $X$ 的梦中，他在西藏开了一家大型旅游公司，现在，他要为西藏的各个景点设计一组铁路线。但是，小 $X$ 发现，来旅游的游客都很挑剔，他们乘火车在各个景点间游览，景点的趣味当然是不用说啦，关键是路上。试想，若是乘火车一圈转悠，却发现回到了游玩过的某个景点，花了一大堆钱却在路上看不到好的风景，那是有多么的恼火啊。

所以，小 $X$ 为所有的路径定义了两个值，$V_i$ 和 $P_i$，分别表示火车线路的风景趣味度和乘坐一次的价格。现在小 $X$ 想知道，乘客从任意一个景点开始坐火车走过的一条回路上所有的 $V$ 之和与 $P$ 之和的比值的最大值。以便为顾客们推荐一条环绕旅游路线（路线不一定包含所有的景点，但是不可以存在重复的火车路线）。

于是，小 $X$ 梦醒之后找到了你……

## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 100$，$1 \le M \le 20$；

对于 $60\%$ 的数据，$1 \le N \le 3{,}000$，$1 \le M \le 2{,}000$；

对于 $100\%$ 的数据，$1 \le N \le 7{,}000$，$1 \le M \le 20{,}000$，$1 \le V_i,P_i \le 1{,}000$。

保证答案在 $200$ 以内。

![](https://cdn.luogu.com.cn/upload/image_hosting/e1ywdkfs.png)


## 样例 #1

### 输入

```
5 6

1 2 1 1

4 1 6 2

5 4 8 1

2 3 2 2

5 2 4 1

3 5 6 4```

### 输出

```
2.3```

# AI分析结果



### **唯一算法分类**  
分数规划 + 负环检测（SPFA-DFS版）

---

### **综合分析与结论**  
**核心思路**：  
题目要求最大化环的ΣV/ΣP，转化为分数规划问题。通过二分答案，将边权调整为`mid*P_i - V_i`，检测是否存在负环。若存在，说明当前mid可增大；否则需减小mid，直至找到最大可行值。

**难点与解决**：  
1. **负环检测效率**：BFS版SPFA易超时，DFS版能快速回溯，更高效。  
2. **图连通性处理**：添加超级源点（如节点0）并连接所有节点，确保所有子图被覆盖。  
3. **二分精度控制**：答案在200以内且保留1位小数，二分15次即可满足精度要求。

**可视化设计要点**：  
- **像素风格动画**：以网格表示节点，边权动态更新为`mid*P_i - V_i`，负环路径高亮为红色。  
- **音效反馈**：发现负环时播放上升音调，更新二分区间时播放点击音效。  
- **自动演示模式**：AI自动运行二分流程，单步展示SPFA递归过程。

---

### **题解清单 (≥4星)**  
1. **冈崎梦美（5星）**  
   - 核心亮点：引入超级源点，DFS版SPFA高效判环，代码简洁。  
   - 关键代码：  
     ```cpp
     bool spfa(double ans, int now) {
         vis[now] = true;
         for (auto e : G[now]) {
             double w = ans * e.c - e.v;
             if (dis[e.to] > dis[now] + w) {
                 if (vis[e.to]) return false; // 发现负环
                 dis[e.to] = dis[now] + w;
                 if (!spfa(ans, e.to)) return false;
             }
         }
         vis[now] = false;
         return true;
     }
     ```

2. **C_SUNSHINE（4星）**  
   - 核心亮点：直接DFS递归实现，无需显式队列，处理超级源点逻辑清晰。  
   - 调试心得：初始化`dis[0]=0`确保超级源点正确启动。

3. **Cerisier（4星）**  
   - 核心亮点：入队次数限制优化（阈值20），平衡效率与准确性。  
   - 代码片段：  
     ```cpp
     if (sum[u] > 20) return 1; // 快速判环
     ```

---

### **最优思路提炼**  
- **二分答案**：将最大化比率问题转化为可行性判断。  
- **边权转换**：`mid*P_i - V_i`将问题转为负环检测。  
- **DFS-SPFA优化**：递归回溯快速终止无效路径，避免重复松弛。  
- **超级源点**：保证全图连通性，避免多起点遍历。

---

### **同类型题与算法套路**  
1. **最优比率环**：如POJ 3621 Sightseeing Cows。  
2. **差分约束系统**：通过边权转换建模为图问题。  
3. **负环检测通用场景**：如网络流中的费用流可行性判断。

---

### **推荐相似题目**  
1. **P2868 [USACO07DEC]Sightseeing Cows**（同分数规划+负环）  
2. **P3199 [HNOI2009]最小圈**（求最小比率环）  
3. **P1266 速度限制**（图论动态权值处理）

---

### **个人心得摘录**  
- **Wisbtsml**：BFS版SPFA超时后，通过限制入队次数（20次）和随机起点优化，意外获得90分，体现“玄学优化”的实战价值。  
- **Anguei**：强调二分次数与精度关系，数学推导减少循环次数，理论指导实践。  

---

### **可视化与算法演示**  
**核心流程动画设计**：  
1. **边权更新**：二分时动态显示每条边的`mid*P_i - V_i`值，红色表示负数。  
2. **SPFA递归路径**：递归栈用蓝色高亮，回溯时渐变为灰色，发现负环时路径闪烁红色。  
3. **超级源点作用**：以金色节点0为中心，辐射状连接所有节点，展示初始松弛过程。  

**复古像素效果**：  
- **8位风格网格**：节点用8x8像素块表示，边权以16色数值显示。  
- **音效设计**：  
  - 负环检测成功：FC风格“升级”音效（短促上升琶音）。  
  - 二分区间更新：经典马里奥金币音效。  

**交互控制**：  
```javascript
// 示例：Canvas绘制节点与边（伪代码）
ctx.fillStyle = '#FF0000'; // 负环红色
ctx.fillRect(x*30, y*30, 8, 8); 
// 音效触发
if (foundCycle) playSound('negative_cycle.wav');
```

---

**最终代码实现**（冈崎梦美简化版）  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 7007;
struct Edge { int to, v, c; };
vector<Edge> G[maxn];
int n, m;
bool vis[maxn];
double dis[maxn];

bool spfa(double mid, int u) {
    vis[u] = true;
    for (Edge e : G[u]) {
        double w = mid * e.c - e.v;
        if (dis[e.to] > dis[u] + w) {
            if (vis[e.to]) return false;
            dis[e.to] = dis[u] + w;
            if (!spfa(mid, e.to)) return false;
        }
    }
    vis[u] = false;
    return true;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i=0; i<m; ++i) {
        int x,y,v,c; scanf("%d%d%d%d", &x,&y,&v,&c);
        G[x].push_back({y, v, c});
    }
    for (int i=1; i<=n; ++i) G[0].push_back({i, 0, 0}); // 超级源点
    
    double l = 0, r = 200;
    while (r - l > 1e-4) {
        double mid = (l + r) / 2;
        memset(dis, 0x7f, sizeof(dis));
        memset(vis, 0, sizeof(vis));
        dis[0] = 0;
        if (spfa(mid, 0)) r = mid;
        else l = mid;
    }
    printf("%.1f\n", l);
    return 0;
}
```

---
处理用时：80.45秒
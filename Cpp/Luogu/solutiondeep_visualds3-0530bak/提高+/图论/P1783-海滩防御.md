# 题目信息

# 海滩防御

## 题目描述

WLP 同学最近迷上了一款网络联机对战游戏（终于知道为毛 JOHNKRAM 每天刷洛谷效率那么低了），但是他却为了这个游戏很苦恼，因为他在海边的造船厂和仓库总是被敌方派人偷袭。于是，WLP 动用了他那丰满且充实的大脑（或许更偏向前者），想出了一个好主意，他把海滩分成垂直于海岸线的若干列，在其中的几列上放置几个信号塔，试图来监视整个海滩。然而，WLP 是一个非常心急的人，他把信号塔建好后才发现还需给信号塔供能，它们才能投入使用（这不是废话么），它们都有一个工作半径，一个圆形区域里的所有敌人都逃不过它们的监视，不过，WLP 发现，敌人们非常狡猾，除非他将道路完全封死，否则 WLP 的敌人可以走过一条任意弯曲的路（不一定走整点，但是不会出第 $0$ 列和第 $N$ 列构成的边界）来偷他的东西。

于是，WLP 就思考了：到底需要给每个信号塔多大的工作半径，才能将从海滩到内地的路径完全封死呢？他再次动用了他那丰满且充实的大脑，想了一堂数学课，终于，还是没想出来。于是，他向 LZZ 神犇求助（额…… CSUNSHINE 的身份是不是暴露了）。

终于，在 WLP：“ %^!\*@#!\*(\*^!\*#@\$^&（此处省略无数卖萌场景）”的哀求下，LZZ 神犇写了一个程序，在一秒内就解决了问题。但是，邪恶的 LZZ 神犇决定要将这个难题共享给无数无辜的 OIer，所以，现在轮到你了。

## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据：$1 \le M \le 10$，$1 \le Y_i \le 100$；
- 对于 $30\%$ 的数据：$1 \le M \le 50$，$1 \le Y_i \le 1,000$；
- 对于 $80\%$ 的数据：$1 \le M \le 500$，$1 \le Y_i \le 1,000$；
- 对于 $100\%$ 的数据：$1 \le M \le 800$，$1 \le N \le 1000$，$1 \le X_i \le N$，$1 \le Y_i \le 100,000$。

### 提示

注意，封锁海滩是指，敌人的深入程度是有限制的，若敌人绕过了所有的信号塔，并且可以长驱直入，那么就说明道路没有完全封锁。

## 样例 #1

### 输入

```
5 5
1 5
3 5
5 5
4 30
2 15```

### 输出

```
1.00```

## 样例 #2

### 输入

```
100 2
30 50
90 100```

### 输出

```
39.05```

# AI分析结果



### **唯一算法分类**  
最小生成树（Kruskal/Prim）

---

### **综合分析与结论**  
**核心思路**：将海滩的左右边界视为两个虚拟节点，信号塔与边界之间以垂直距离为边权，信号塔之间以欧氏距离的一半为边权。构造完全图后，求左右边界之间的路径中最大边权的最小值，等价于求最小生成树中连接左右边界的最大边权。

**解决难点**：  
1. **建模转换**：将几何问题转化为图论问题，关键是将塔与边界的连接关系抽象为边权。  
2. **算法选择**：需理解最小生成树（Kruskal/Prim）或最短路径（Dijkstra）的变种（路径最大值最小化）。  
3. **精度处理**：浮点数比较需注意精度控制，如二分答案时设置合理的终止条件。

**可视化设计**：  
- **像素动画**：以 8-bit 风格绘制海滩网格，红色方块表示信号塔，蓝色边框为左右边界。  
- **动态连边**：按边权从小到大逐步连接塔与边界，当前处理的边高亮为黄色，已加入生成树的边标记为绿色。  
- **音效反馈**：连边时播放「哔」声，连通边界时播放「胜利」音效。  
- **自动演示**：自动执行 Kruskal 的排序和连边过程，用户可调节速度观察算法流程。

---

### **题解清单 (≥4星)**  
1. **C_SUNSHINE (5星)**  
   - **亮点**：标准的 Kruskal 实现，左右边界处理清晰，代码简洁。  
   - **代码片段**：  
     ```cpp  
     e[++w] = (edge){i, 0, y[i]};        // 左边界边权为 y[i]（实际应为 x[i]）  
     e[++w] = (edge){i, n+1, W - y[i]}; // 右边界边权为 W - y[i]  
     ```  
   - **注意**：变量名 `y[i]` 应为 `x[i]`，可能是输入数据命名混淆。

2. **Mathison (5星)**  
   - **亮点**：Dijkstra 变种实现路径最大值最小化，松弛条件 `dis[v] = max(dis[u], w)` 是关键。  
   - **代码片段**：  
     ```cpp  
     if (dis[v] > max(dis[u], w)) {  
         dis[v] = max(dis[u], w);  
         q.push({-dis[v], v});  
     }  
     ```  

3. **pipiispig (4星)**  
   - **亮点**：Kruskal 实现中动态检查连通性，避免冗余计算。  
   - **个人心得**：提到「排序后无需维护 ans 的最大值」，直接取最后加入的边。

---

### **最优思路提炼**  
1. **Kruskal 核心流程**：  
   - 构造边：塔间边权为距离/2，塔与边界边权为横坐标。  
   - 按边权排序，依次合并集合，直到左右边界连通。  
   - **时间复杂度**：O(M² log M)。  

2. **Prim 优化技巧**：  
   - 适用于稠密图，维护未选节点到生成树的最小边权。  
   - **代码片段**：  
     ```cpp  
     while (!vis[v] && d[v] < current_min) {  
         current_min = d[v];  
         selected = v;  
     }  
     ```  

---

### **同类题目推荐**  
1. **P3958 [NOIP2017 提高组] 奶酪**（连通性+几何）  
2. **P1396 营救**（路径最大值最小化）  
3. **P1546 [USACO3.1] 最短网络 Agri-Net**（最小生成树模板）

---

### **个人心得摘录**  
- **Akeryep**：调试时发现「与边界连边需乘 2」，但最终输出除以 2，需注意单位转换。  
- **天上一颗蛋**：二分答案时发现「精度设为 1e-3 会 WA，需调整到 1e-4」。  
- **thelast**：提到「Kruskal 的边排序后无需全扫完，连通即终止」，大幅优化时间。

---

### **代码实现示例（Kruskal）**  
```cpp  
// 核心代码：构造边 + Kruskal  
for (int i = 1; i <= m; i++) {  
    e.emplace_back(0, i, x[i]);        // 左边界  
    e.emplace_back(i, m+1, n - x[i]); // 右边界  
    for (int j = i+1; j <= m; j++) {  
        double d = sqrt(pow(x[i]-x[j],2) + pow(y[i]-y[j],2)) / 2.0;  
        e.emplace_back(i, j, d);  
    }  
}  
sort(e.begin(), e.end());  
for (auto &edge : e) {  
    int fu = find(edge.u), fv = find(edge.v);  
    if (fu == fv) continue;  
    fa[fu] = fv;  
    if (find(0) == find(m+1)) {  
        printf("%.2lf", edge.w);  
        return 0;  
    }  
}  
```

---

### **可视化实现思路（JavaScript 伪代码）**  
```javascript  
// 8-bit 风格绘制海滩  
const canvas = document.getElementById("pixel-canvas");  
ctx.fillStyle = "#2D5D7C"; // 海水蓝色  
ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);  

// 信号塔绘制  
towers.forEach(tower => {  
    ctx.fillStyle = "#FF0000"; // 红色方块  
    ctx.fillRect(tower.x * SCALE, tower.y * SCALE, 5, 5);  
});  

// 动态连边动画  
function animateKruskal(edges) {  
    edges.sort((a, b) => a.w - b.w);  
    let i = 0;  
    const interval = setInterval(() => {  
        if (checkConnected()) {  
            playSound("win.wav");  
            clearInterval(interval);  
        }  
        drawEdge(edges[i], "#FFFF00"); // 黄色高亮当前边  
        union(edges[i].u, edges[i].v);  
        i++;  
    }, 500); // 可调节速度  
}  
```

---
处理用时：101.23秒
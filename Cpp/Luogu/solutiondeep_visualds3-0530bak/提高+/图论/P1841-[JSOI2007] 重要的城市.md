# 题目信息

# [JSOI2007] 重要的城市

## 题目描述

参加 jsoi 冬令营的同学最近发现，由于南航校内修路截断了原来通向计算中心的路，导致去的路程比原先增加了近一公里。而食堂门前施工虽然也截断了原来通向计算中心的路，却没有使路程增加，因为可以找到同样长度的路作替代。其实，问题的关键在于，路截断的地方是交通要点。

同样的情况也出现在城市间的交通中。某些城市如果出了问题，可能会引起其他很多城市的交通不便。另一些城市则影响不到别的城市的交通。jsoi 冬令营的同学发现这是一个有趣的问题，于是决定研究这个问题。

他们认为这样的城市是重要的：如果一个城市 $c$ 被破坏后，存在两个不同的城市 $a$ 和 $b$（$a, b$ 均不等于 $c$），$a$ 到 $b$ 的最短距离增长了（或不通），则城市 $c$ 是重要的。

jsoi 冬令营的同学面对着一张教练组交给他们的城市间交通图，他们希望能找出所有重要的城市。现在就请你来解决这个问题。

## 说明/提示

- 对于 $30\%$ 的数据满足 $N\le 20$；
- 对于 $60\%$ 的数据满足 $N\le 100$；
- 对于 $100\%$ 的数据满足 $N\le 200,M\le \frac{N\times (N-1)}{2},0<c\le 10000$。$c$ 即路的长度。

保证不出现重边和自环。

## 样例 #1

### 输入

```
4 4
1 2 1
2 3 1
4 1 2
4 3 2```

### 输出

```
2
```

# AI分析结果



---

## 算法分类
**Floyd算法**

---

## 综合分析与结论

### 核心思路与难点
题目要求找出所有"重要城市"，即删除该城市后会导致某些点对的最短路径变长或不通。核心难点在于高效判断某个城市是否是多个点对最短路径的必经节点。

各题解主要采用以下思路：
1. **暴力枚举法**：删除每个城市后重新计算全图最短路（O(n⁴)），仅适用于小数据
2. **Floyd路径标记法**：在Floyd松弛过程中记录关键中间节点，当某个节点k是i→j最短路的唯一松弛点时标记为重要城市
3. **最短路径计数法**：通过统计最短路数量，当且仅当某点的路径数乘积等于总路径数时判定为必经点
4. **最短路树入度法**：构建最短路DAG后通过入度判断关键节点

### 可视化设计要点
1. **Floyd过程动画**：
   - 三层循环用不同颜色高亮i,j,k
   - 当k松弛i→j时，若发现更短路径则标记k为黄色
   - 当存在等长路径时，将k标记为红色表示失去唯一性
2. **像素风格交互**：
   ```javascript
   // 伪代码示例
   class FloydViz {
     constructor(canvas) {
       this.grid = new PixelGrid(canvas, 200, 16-color); // 200节点用16色像素风格
       this.speed = 100; // 每步延迟(ms)
       this.playSound('startup'); // 8-bit启动音效
     }
     
     drawStep(k, i, j) {
       this.grid.highlightCell(k, CYAN);    // 当前中间节点k
       this.grid.drawEdge(i, j, YELLOW);    // 当前处理边i-j
       if (newDist < oldDist) {
         this.grid.markCritical(k);         // 标记k为重要节点
         this.playSound('powerup');         // 成功音效
       }
     }
   }
   ```
3. **AI演示模式**：
   - 自动播放时显示三重循环进度条
   - 支持暂停观察关键松弛操作
   - 失败时播放经典FC失败音效

---

## 题解清单 (≥4星)

1. **Parabola 的 Floyd路径标记法** ★★★★★  
   - 关键亮点：在Floyd松弛时记录中间点，发现等长路径时重置标记
   - 代码亮点：
     ```c++
     for(int k=1; k<=n; k++)
       for(int i=1; i<=n; i++) if(i!=k)
         for(int j=1; j<=n; j++) if(j!=k && i!=j){
           if(dis[i][j] > dis[i][k]+dis[k][j]) {
             dis[i][j] = dis[i][k]+dis[k][j];
             city[i][j] = k;  // 标记关键中间点
           } else if(dis[i][j] == dis[i][k]+dis[k][j]) {
             city[i][j] = -1; // 存在多路径时取消标记
           }
         }
     ```

2. **木木 的最短路径计数法** ★★★★☆  
   - 关键亮点：通过路径数量乘法原理判断必经点
   - 核心判断：
     ```cpp
     if(fi[j][k] == fi[j][i]+fi[i][k] && ki[j][k] == ki[j][i]*ki[i][k])
       标记i为重要城市
     ```

3. **mrsrz 的优化Floyd解法** ★★★★☆  
   - 关键亮点：使用二维数组记录松弛点，最后统一去重输出
   - 代码亮点：
     ```cpp
     if(d[i][j] == d[i][k]+d[k][j])
        s[i][j] = k;
     else if(...) s[i][j] = -1;
     ```

---

## 最优思路提炼

**Floyd松弛标记法**  
1. 在标准Floyd三重循环中，当k成功松弛i→j路径时，记录k为关键点
2. 若出现等长路径，立即标记该点对不存在必经点
3. 最终统计所有被标记的中间点即为答案

**正确性证明**：  
- 若i→j的最短路必须经过k，则k必定是唯一能完成该松弛操作的中间点
- 存在多路径时，必然有多个k能完成相同松弛，此时标记清除

---

## 相似题目推荐

1. **P2149 [SDOI2009]Elaxia的路线**  
   （求两对点间最短路的公共路径）

2. **P3761 [TJOI2017]城市**  
   （枚举删边后求最优交通枢纽）

3. **P1346 电车**  
   （最短路径必经边问题）

---

## 可视化算法演示

**关键步骤动画流程**：
1. 初始化显示全连接灰色边
2. 外层循环k从1到n：
   - 当前k标记为蓝色
3. 中层循环i遍历所有节点：
   - i标记为绿色闪烁
4. 内层循环j遍历所有节点：
   - j标记为黄色闪烁
   - 比较i→k→j与i→j原距离：
     * 更短：k标记为金色，i→j边变金色
     * 等长：k标记为红色，i→j边变红色
5. 最终重要城市持续高亮

**交互功能**：
- 速度滑块控制动画节奏（100ms~2s）
- 空格键暂停/继续
- 右键单步执行内层循环

---

## 核心代码实现

**Parabola解法关键部分**：
```cpp
// 初始化邻接矩阵
memset(dis, 0x3f, sizeof(dis));
for(int i=1; i<=n; i++) dis[i][i] = 0;

// Floyd核心松弛逻辑
for(int k=1; k<=n; k++)
  for(int i=1; i<=n; i++)
    for(int j=1; j<=n; j++)
      if(dis[i][j] > dis[i][k] + dis[k][j]) {
        dis[i][j] = dis[i][k] + dis[k][j];
        city[i][j] = k; // 记录关键点
      } else if(dis[i][j] == dis[i][k] + dis[k][j]) {
        city[i][j] = -1; // 清除多路径标记
      }

// 统计结果
bool ans[205] = {};
for(int i=1; i<=n; i++)
  for(int j=1; j<=n; j++)
    if(city[i][j] != -1)
      ans[city[i][j]] = true;
```

---

通过这种结构化的分析，既能深入理解算法核心，又能通过可视化设计增强学习效果，为同类问题的解决提供了清晰的思维框架。

---
处理用时：84.27秒
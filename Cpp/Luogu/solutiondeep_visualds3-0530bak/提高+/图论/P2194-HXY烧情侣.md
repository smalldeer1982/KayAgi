# 题目信息

# HXY烧情侣

## 题目描述

众所周知，HXY 已经加入了 FFF 团。现在她要开始喜（sang）闻（xin）乐（bing）见（kuang）地烧情侣了。

这里有 $n$ 座电影院，$n$ 对情侣分别在每座电影院里，然后电影院里都有汽油，但是要使用它需要一定的费用。$m$ 条单向通道连接相邻的两对情侣所在电影院。

HXY 有个绝技，如果她能从一个点开始烧，最后回到这个点，那么烧这条回路上的情侣的费用只需要该点的汽油费即可。并且每对情侣只需烧一遍，电影院可以重复去。然后她想花尽可能少的费用烧掉所有的情侣。

问：最少需要多少费用，并且当费用最少时的方案数是多少？由于方案数可能过大，所以请输出方案数对 $10^9+7$ 取模的结果。

（注：这里 HXY 每次可以从任何一个点开始走回路。就是说一个回路走完了，下一个开始位置可以任选。所以说不存在烧不了所有情侣的情况，即使图不连通，HXY 自行选择顶点进行烧情侣行动。且走过的道路可以重复走。）

## 说明/提示

对于 $30\%$ 的数据，$1\le n,m \le 20$；  
对于另外 $10\%$ 的数据，保证不存在回路；  
对于 $100\%$ 的数据，$1\le n \le 10^5$，$1\le m \le 3\times 10^5$，$0\le w_i \le 10^9$。

## 样例 #1

### 输入

```
3
1 2 3
3
1 2
2 3
3 2```

### 输出

```
3 1
```

## 样例 #2

### 输入

```
3
10 20 10
4
1 2
1 3
3 1
2 1
```

### 输出

```
10 2
```

# AI分析结果



# HXY烧情侣 - 题解分析

## 唯一算法分类
**强连通分量（Tarjan算法）**

---

## 题解思路与核心难点

### 核心思路
1. **问题转化**  
   每个强连通分量（SCC）的回路费用为该分量内节点的最小权值。总费用为所有SCC最小权值的和，方案数为各SCC最小权值出现次数的乘积。

2. **算法流程**  
   - **Tarjan缩点**：找出所有SCC  
   - **统计信息**：对每个SCC记录最小权值`min_cost`和出现次数`count`  
   - **结果计算**：`总费用 = Σ min_cost`，`方案数 = Π count % MOD`

### 解决难点
- **正确缩点**：需处理非连通图，确保每个节点都被访问  
- **高效统计**：在Tarjan弹栈时动态维护`min_cost`和`count`，避免二次遍历  
- **初始化陷阱**：`min_cost`需初始化为极大值，否则可能统计错误  

---

## 题解评分（≥4星）

### 1. 扬皓2006（⭐⭐⭐⭐⭐）
- **亮点**：代码简洁，直接在Tarjan弹栈时统计最小值和计数  
- **关键代码**：
  ```cpp
  do {
      z = stac[top--];
      if (a[z] < x) x = a[z], coun = 1;
      else if (a[z] == x) coun++;
  } while(z != x);
  ans1 += x; ans2 = (ans2 * coun) % mo;
  ```

### 2. Social_Zhao（⭐⭐⭐⭐）
- **亮点**：详细注释和问题转化分析，适合教学  
- **核心段**：
  ```cpp
  for (auto node : scc) {
      if (node.val < current_min) {
          current_min = node.val;
          cnt = 1;
      } else if (node.val == current_min) cnt++;
  }
  ```

### 3. Doubeecat（⭐⭐⭐⭐）
- **亮点**：模块化设计，分离Tarjan和统计逻辑  
- **关键实现**：
  ```cpp
  void Tarjan(int u) {
      // ... 省略栈操作
      if (dfn[u] == low[u]) {
          int min_val = INF, cnt = 0;
          while (弹出节点v) {
              if (v.val < min_val) min_val = v.val, cnt = 1;
              else if (v.val == min_val) cnt++;
          }
      }
  }
  ```

---

## 最优思路提炼

### 关键技巧
- **动态统计最小值**：在Tarjan弹栈时实时更新，无需额外遍历  
- **乘法取模优化**：用`ans2 = (ans2 * cnt) % MOD`避免溢出  
- **强连通分量染色**：用`belong[]`数组标记节点所属SCC，便于后续统计  

---

## 同类型题与算法套路
- **通用解法**：涉及SCC的题目均可套用Tarjan缩点，统计分量内特征值（如极值、求和等）  
- **类似题目**：  
  - [CF427C Checkposts](https://codeforces.com/problemset/problem/427/C)  
  - [洛谷P2341 [HAOI2006]受欢迎的牛](https://www.luogu.com.cn/problem/P2341)  
  - [洛谷P1262 间谍网络](https://www.luogu.com.cn/problem/P1262)  

---

## 可视化设计

### 动画方案
1. **DFS遍历与栈操作**  
   - **颜色标记**：  
     - 红色：当前访问节点  
     - 绿色：已访问但未处理的节点  
     - 蓝色：已弹出栈的节点  
   - **栈动态显示**：实时绘制栈内元素，弹栈时高亮被移除节点  

2. **SCC形成过程**  
   - **分块染色**：同一SCC节点用相同颜色填充  
   - **极值统计**：在SCC形成时，显示当前分量的`min_cost`和`count`更新过程  

3. **复古像素风格**  
   - **8位音效**：  
     - 弹栈时播放“叮”声，形成SCC时播放上升音调  
     - 错误操作（如重复访问）时播放低沉音效  
   - **Canvas绘制**：用16x16像素块表示节点，边用线段连接  

### 交互功能
- **步进控制**：允许暂停/继续，调整动画速度  
- **自动演示**：AI模式自动运行算法，展示关键步骤  
- **积分系统**：正确完成缩点后获得积分，错误操作扣分  

---

## 核心代码实现
```cpp
void tarjan(int u) {
    dfn[u] = low[u] = ++idx;
    stk[++top] = u; ins[u] = 1;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (ins[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        int min_val = INF, cnt = 0, v;
        do {
            v = stk[top--]; ins[v] = 0;
            if (w[v] < min_val) min_val = w[v], cnt = 1;
            else if (w[v] == min_val) cnt++;
        } while (v != u);
        ans1 += min_val;
        ans2 = (ans2 * cnt) % MOD;
    }
}
```

---

## 个人心得摘录
> “初始化`min_cost`为INF是必须的，否则可能误判未访问节点的权值。调试时发现未初始化的分量最小值竟然是0，导致方案数错误。” —— 题解作者调试经验

---
处理用时：73.52秒
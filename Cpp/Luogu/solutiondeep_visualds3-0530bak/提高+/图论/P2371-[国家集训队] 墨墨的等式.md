# 题目信息

# [国家集训队] 墨墨的等式

## 题目描述

墨墨突然对等式很感兴趣，他正在研究 $\sum_{i=1}^n a_ix_i=b$ 存在非负整数解的条件，他要求你编写一个程序，给定 $n, a_{1\dots n}, l, r$，求出有多少 $b\in[l,r]$ 可以使等式存在非负整数解。

## 说明/提示

对于 $20\%$ 的数据，$n \le 5$，$r \le 10$。

对于 $40\%$ 的数据，$n \le 10$，$r \le 10^6$。

对于 $100\%$ 的数据，$n \le 12$，$0 \le a_i \le 5\times 10^5$，$1 \le l \le r \le 10^{12}$。


## 样例 #1

### 输入

```
2 5 10
3 5
```

### 输出

```
5
```

# AI分析结果



### 算法分类
**同余最短路**

---

### 题解思路与算法要点

#### 核心思想
通过**模余分组**将无限范围的数论问题转化为有限状态的最短路问题。选取非零的最小系数 \( mn \) 作为模数，每个余数 \( i \) 对应一个节点，边的转移表示加上其他系数后的余数变化。计算每个余数的最小可行 \( b \)，最终通过等差数列覆盖统计答案。

#### 解决难点
1. **无限范围处理**：将问题拆解为模 \( mn \) 的余数类，每个余数的最小可行解确定后，后续解为等差数列。
2. **状态转移建模**：构建图时，每个余数 \( i \) 到 \( (i+a_j) \mod mn \) 连边，边权为 \( a_j \)，表示通过增加 \( a_j \) 到达新余数的代价。
3. **高效计算**：用 SPFA 或 Dijkstra 快速计算每个余数的最小可行解，避免暴力枚举。

#### 关键步骤
1. **预处理**：过滤零系数，选取最小非零 \( mn \)。
2. **建图**：每个余数 \( i \) 与其他系数 \( a_j \) 连边。
3. **最短路**：计算每个余数的最小可行 \( b \) 值。
4. **统计答案**：对每个余数 \( i \)，计算其在 \([l, r]\) 内的等差数列覆盖数。

---

### 题解评分（≥4星）

1. **Heartlessly（★★★★★）**
   - **亮点**：代码清晰，处理零系数和边界条件完善，SPFA 实现高效。
   - **核心代码**：
     ```cpp
     // 核心建图与SPFA
     for (int j = 1; j <= n; ++j)
         if (a[j] != mn) add(i, (i + a[j]) % mn, a[j]);
     spfa(0);
     // 统计答案公式
     res += (x - dis[i]) / mn + 1;
     ```

2. **xht（★★★★☆）**
   - **亮点**：结合例题对比，代码简洁，Dijkstra 实现优化。
   - **核心代码**：
     ```cpp
     // Dijkstra优化版
     for (int i = 0; i < x; i++) 
         e[i].pb(mp((i + y) % x, y)), e[i].pb(mp((i + z) % x, z));
     ```

3. **pomelo_nene（★★★★☆）**
   - **亮点**：详细解析跳楼机与本题关联，代码模块化。
   - **核心公式**：
     ```cpp
     ans += (r - d[i])/x + 1;
     ans -= (l - 1 - d[i])/x + 1;
     ```

---

### 最优思路提炼
1. **模数选择**：选取最小非零 \( a_i \) 作为 \( mn \)，减少状态数。
2. **同余建图**：每个余数通过加系数转移到新余数，边权为系数值。
3. **最短路计算**：SPFA 高效处理正权边，计算每个余数的最小可行解。
4. **覆盖统计**：利用等差数列公式统计 \([l, r]\) 内解的个数。

---

### 类似题目推荐
1. **P3403 跳楼机**  
   （同余最短路模板题，三系数覆盖问题）
2. **P2662 牛场围栏**  
   （求无法构造的最大数，同余最短路变种）
3. **P6567 买表**  
   （多重背包与同余结合的优化问题）

---

### 可视化与算法演示

#### 动画设计
- **像素风格**：余数节点为色块，边为箭头，SPFA 队列动态显示。
- **步进控制**：高亮当前处理的节点和边，显示 \( dis \) 数组更新过程。
- **音效**：节点更新时播放“滴”声，完成时播放胜利音效。

#### 核心流程
1. **初始化**：显示所有余数节点为红色，\( dis[0] = 0 \) 设为绿色。
2. **SPFA 执行**：队列弹出节点，遍历出边，更新相邻节点 \( dis \) 值并染色。
3. **统计阶段**：对每个余数，用颜色渐变显示覆盖区间 \([dis[i], r]\)。

---

### 代码实现（核心片段）
```cpp
// 建图与SPFA（Heartlessly 题解核心）
void addEdge(int u, int v, int w) {
    e[++tot] = {head[u], v, w};
    head[u] = tot;
}

void spfa(int s) {
    queue<int> q;
    dis[s] = 0; q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        vis[u] = 0;
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to, w = e[i].dis;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!vis[v]) q.push(v), vis[v] = 1;
            }
        }
    }
}
```

---

### 个人心得
- **边界处理**：零系数需过滤，否则模数可能为0导致错误。
- **SPFA优势**：在稀疏图中效率接近 Dijkstra，且代码更简洁。
- **数学思维**：将数论问题转化为图论模型，需培养跨领域联想能力。

---
处理用时：119.37秒
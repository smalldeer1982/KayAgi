# 题目信息

# [SCOI2012] 滑雪

## 题目描述

a180285 非常喜欢滑雪。他来到一座雪山，这里分布着 $m$ 条供滑行的轨道和 $n$ 个轨道之间的交点（同时也是景点），而且每个景点都有一编号 $i\space (1 \le i \le n)$ 和一高度 $h_i$。  

a180285 能从景点 $i$ 滑到景点 $j$ 当且仅当存在一条 $i$ 和 $j$ 之间的边，且 $i$ 的高度**不小于** $j$。与其他滑雪爱好者不同，a180285 喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。

于是 a18028 5拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是 a180285 滑行的距离）。  

请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，a180285站在 $1$ 号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？


## 说明/提示

【数据范围】   
对于 $ 30\% $ 的数据，$ 1 \le n \le 2000 $；   
对于 $ 100\% $ 的数据，$ 1 \le n \le 10^5 $。


对于所有的数据，保证 $ 1 \le m \le 10^6 $ , $ 1 \le h_i \le 10^9 $ ，$ 1 \le k_i \le 10^9 $。


## 样例 #1

### 输入

```
3 3 
3 2 1 
1 2 1 
2 3 1 
1 3 10 ```

### 输出

```
3 2```

# AI分析结果



**唯一算法分类**：图的最小生成树（Kruskal/Prim）与BFS预处理

---

### **题解思路、算法要点与解决难点**
#### **核心思路**
1. **可达性分析**：通过BFS/DFS找出从起点1能到达的所有节点（满足高度递减条件）。
2. **最小生成树**：在可达节点构成的子图中，按高度优先+边权次优的规则生成最小生成树。

#### **算法对比**
| 题解方案           | 关键数据结构       | 排序规则                          | 解决难点                         |
|--------------------|--------------------|-----------------------------------|----------------------------------|
| Kruskal+BFS        | 优先队列（边排序） | 终点高度降序 → 边权升序          | 确保高优先级节点优先扩展         |
| Prim+自定义堆      | 优先队列（节点）   | 节点高度降序 → 当前边权升序       | 动态维护可达节点的最优边         |
| DFS+边筛选+Kruskal | 链式前向星+并查集  | 终点高度降序 → 边权升序           | 避免重复边处理                   |

#### **核心难点**
- **高度约束下的连通性**：需保证生成的树仅包含高度递减的路径。
- **排序策略的优先级**：以终点高度为第一关键字确保扩展顺序，以边权为第二关键字保证最小总距离。

---

### **题解评分 (≥4星)**
1. **Khassar (Kruskal+BFS)** ⭐⭐⭐⭐⭐  
   - 思路清晰，代码可读性强  
   - 通过BFS预处理明确可达点，Kruskal排序策略简洁  
   - 注释详细，适合教学  

2. **Ccliang (Prim+自定义堆)** ⭐⭐⭐⭐  
   - 时间复杂度更低（堆优化Prim）  
   - 代码实现紧凑，但缺少注释  
   - 动态优先级调整直观  

3. **mrsrz (Kruskal+DFS)** ⭐⭐⭐⭐  
   - 边筛选逻辑严谨，避免重复边  
   - 代码结构稍复杂，但数据范围处理优秀  

---

### **最优思路或技巧提炼**
1. **分层处理策略**  
   - **预处理阶段**：用BFS/DFS确定所有可达节点，过滤无效边。  
   - **生成树阶段**：按高度降序优先保证扩展顺序，边权升序保证最小总距离。  

2. **排序规则的数学证明**  
   - 若边按终点高度降序排列，则合并时必然优先连接高层节点，避免低层节点提前占用连通路径。  

3. **并查集优化**  
   - 在Kruskal中，路径压缩和按秩合并显著提升效率（处理1e5级节点）。  

---

### **同类型题推荐**
1. **P1991 无线通讯网**（最小生成树变形）  
2. **P4047 部落划分**（Kruskal逆向思维）  
3. **P1265 公路修建**（Prim稠密图优化）  

---

### **可视化与算法演示**
#### **动画方案设计**
- **BFS扩展阶段**：  
  - **颜色标记**：绿色表示已访问节点，红色表示队列待处理节点。  
  - **动态网格**：节点按高度排列为立体地形，BFS扩散时显示波浪式覆盖效果。  

- **Kruskal合并阶段**：  
  - **边高亮**：当前处理的边显示为黄色，成功合并的边变为蓝色。  
  - **连通块合并**：不同连通块用不同颜色区分，合并时显示颜色融合动画。  

#### **复古游戏化实现**
- **像素风格**：  
  - 节点显示为8-bit山峰（高度越高颜色越亮），边为闪烁的缆车轨迹。  
  - 音效：合并成功时播放“叮”声，BFS扩展时播放“咔嗒”声。  

- **自动演示模式**：  
  - 算法按帧逐步执行，用户可暂停观察当前状态。  
  - 积分系统：每正确合并一条边得10分，错误尝试扣5分。  

---

### **核心代码实现**
#### **Khassar的Kruskal+BFS核心逻辑**
```cpp
// BFS确定可达点并建立新边
void bfs() {
    queue<int> q;
    q.push(1); vis[1] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
            a[cnt++] = {u, v, e[i].w}; // 记录新边
            if (!vis[v]) {
                vis[v] = 1;
                q.push(v);
                sum++; // 统计可达点
            }
        }
    }
}

// Kruskal按规则排序
sort(a, a + cnt, [](Edge x, Edge y) {
    return h[x.v] != h[y.v] ? h[x.v] > h[y.v] : x.w < y.w;
});

// 并查集合并
for (int i = 0; i < cnt; i++) {
    int fu = find(a[i].u), fv = find(a[i].v);
    if (fu != fv) {
        fa[fu] = fv;
        ans += a[i].w;
    }
}
```

#### **Ccliang的Prim自定义堆**
```cpp
// 自定义优先队列排序规则
struct Node {
    int h, dis, id;
    bool operator<(const Node& o) const {
        return h == o.h ? dis > o.dis : h < o.h;
    }
};

priority_queue<Node> q;

// Prim主循环
q.push({h[1], 0, 1});
while (!q.empty()) {
    Node t = q.top(); q.pop();
    if (vis[t.id]) continue;
    vis[t.id] = 1;
    ans += t.dis; cnt++;
    for (int i = head[t.id]; i; i = e[i].next) {
        int v = e[i].to, w = e[i].w;
        if (!vis[v] && w < dis[v]) {
            dis[v] = w;
            q.push({h[v], dis[v], v});
        }
    }
}
```

---

### **个人心得摘录**
- **Khassar**：在排序规则中，终点高度优先于边权是本题的灵魂，否则会因低层节点提前连通导致漏点。  
- **Ccliang**：堆优化的Prim在稠密图中表现优异，但需注意自定义比较函数的方向（降序/升序）。  

---

### **总结**
本题通过BFS/DFS预处理确定可达节点，再结合高度优先的最小生成树算法，完美解决“最多景点+最短距离”的双重约束。其核心在于排序策略的设计，确保高层节点优先连通，这一思路可推广至其他带优先级约束的图论问题。

---
处理用时：83.73秒
# 题目信息

# 主主树

## 题目背景

byx 和诗乃酱都非常都非常喜欢种树。有一天，他们得到了两颗奇怪的树种，于是各自取了一颗回家种树，并约定几年后比一比谁种出来的树更加牛 X。

## 题目描述

很快，这棵树就开花结果了。byx 和诗乃酱惊讶的发现，这是一棵主主树，树上长满了主主和主主的朋友们。这棵树上一共有五种人，主主（$\verb!J!$），记记（$\verb!HK!$），高高（$\verb!W!$），王王（$\verb!E!$）和歪歪（$\verb!YYY!$）。他们发现，他们的主主树上的人数相同，都为 $N$。

 ![](https://cdn.luogu.com.cn/upload/image_hosting/0vklm8ow.png) 

研究发现，这五种人的输赢如上图所示（一样的人不能 PK），箭头指向输的人。至于为什么，留给同学们自己思考。

比赛如期进行。

byx 和诗乃酱要进行 $M$ 场比赛，每一场比赛他们会选出树上的两个人来比较看谁更牛 X。

第 $i$ 个人寿命为 $\text{Life}_i$ 秒，每次比完赛他们就会 $-1$s。当他们生命为 $0$s 时他们就不能再比赛了。

同时，当 $\verb!J!$ 的寿命为 $0$ 时，同一棵树上的 $\verb!YYY!$ 可以为他 $+1$s。每个 $\verb!YYY!$ 只能给每个 $\verb!J!$ 续一次。

那么问题来了：

现在给定 $N,M(1\le N\le 100,1\le M\le 1000)$，诗乃酱和 byx 每一个人所属种类（$\verb!J!,\verb!HK!,\verb!W!,\verb!YYY!$ 或 $\verb!E!$）以及每一个人的生命，生命不超过 $50$。请你算算 byx 最多能够赢得多少场比赛呢。

数据保证每一场一定都有人用。两个人之间只能比一场。

## 说明/提示

第一场主主赢记记，第二场高高赢王王，第三场歪歪赢记记。


## 样例 #1

### 输入

```
3 3
J W YYY
J HK E
2 2 2
2 2 2
```

### 输出

```
3
```

# AI分析结果



### 算法分类
**最大流（网络流建模）**

---

### 综合分析与结论
#### 核心思路与难点
- **建模核心**：将比赛胜负转化为网络流中的边，通过最大流计算最大胜场。
- **关键步骤**：
  1. **源点与汇点连接**：源点连接 byx 的每个角色（容量为寿命 + YYY 续命），汇点连接诗乃酱的角色（同理）。
  2. **胜负关系连边**：若 byx 的角色能击败诗乃酱的某角色，建立容量为 1 的边（代表一场胜利）。
  3. **Dinic 算法**：计算最大流，并与 M 取最小值（最多进行 M 场比赛）。

- **难点解决**：
  - **续命机制**：直接为 J 的初始寿命增加本方 YYY 的数量，无需动态调整。
  - **胜负判断**：通过预定义的克制关系表快速判断胜负。

---

### 题解清单（≥4星）
1. **Mr_QwQ（5星）**
   - **亮点**：思路简洁，代码模板化，适合快速实现。
   - **关键代码**：直接按胜负关系建边，无需复杂预处理。

2. **钱逸凡（5星）**
   - **亮点**：详细分析题目暗示网络流的线索，代码注释清晰。
   - **关键代码**：使用 `dict` 数组预存胜负关系，快速判断连边。

3. **Victorique（4星）**
   - **亮点**：处理输入细节完整，强调首字母唯一性简化判断。
   - **关键代码**：通过字符串首字母快速判断角色类型。

---

### 最优思路与技巧
1. **预处理克制关系**：使用数字编码或首字母唯一性快速判断胜负。
2. **续命静态处理**：将 YYY 的数量直接加到 J 的初始寿命，避免动态维护。
3. **分层建图**：源点→byx→诗乃酱→汇点的分层结构，确保边数可控（O(N²)）。

---

### 类似题目推荐
1. **P3254 圆桌问题**（网络流分配问题）
2. **P2762 太空飞行计划问题**（最大权闭合子图）
3. **P2763 试题库问题**（多重匹配网络流）

---

### 可视化与算法演示
#### 核心流程动画设计
1. **网络流图动态构建**：
   - **步骤1**：左侧显示 byx 角色节点，右侧显示诗乃酱节点，源点（蓝色）在上，汇点（红色）在下。
   - **步骤2**：按胜负关系高亮连边（绿色），容量为 1。
   - **步骤3**：Dinic 算法执行时，显示增广路径（红色闪烁），边容量减少。

2. **复古像素风格**：
   - **颜色方案**：8位色（蓝、红、绿、黄），节点用 16x16 像素块表示。
   - **音效**：增广路径找到时播放“滴”声，容量耗尽时播放“咔嚓”声。

3. **交互控制**：
   - **自动演示**：按步骤展示建图、BFS分层、DFS找增广路。
   - **手动模式**：用户点击节点查看当前流量，拖动调整视角。

---

### 关键代码片段（Dinic 实现）
```cpp
// Dinic 核心部分（钱逸凡题解）
bool bfs() {
    memset(dep, 0, sizeof(dep));
    queue<int> q; q.push(s); dep[s] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (e[i].w && !dep[v]) {
                dep[v] = dep[u] + 1;
                q.push(v);
                if (v == t) return true;
            }
        }
    }
    return false;
}

int dfs(int u, int flow) {
    if (u == t) return flow;
    int out = 0;
    for (int &i = cur[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (e[i].w && dep[v] == dep[u] + 1) {
            int res = dfs(v, min(flow, e[i].w));
            e[i].w -= res; e[i^1].w += res;
            flow -= res; out += res;
            if (!flow) break;
        }
    }
    return out;
}

int dinic() {
    int ans = 0;
    while (bfs()) {
        memcpy(cur, head, sizeof(head));
        ans += dfs(s, INF);
    }
    return min(ans, m); // 与 M 取最小值
}
```

---

### 个人心得摘录
- **Mr_QwQ**：续命机制最初误解为动态调整，后通过静态处理简化代码。
- **Victorique**：输入处理时发现所有类型首字母唯一，大幅简化判断逻辑。

---

### 网络流建模示意图
```
        源点 (S)
        /  |  \
    BYX角色（寿命+YYY）
       |   |   |
       胜负边（容量1）
       |   |   |
    诗乃酱角色（寿命+YYY）
        \  |  /
         汇点 (T)
```
动画中，每条边的流量变化实时显示，增广路径高亮为黄色。

---
处理用时：67.53秒
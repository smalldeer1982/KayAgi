# 题目信息

# [SHOI2012] 回家的路

## 题目背景

SHOI2012 D2T1


## 题目描述

2046 年 OI 城的城市轨道交通建设终于全部竣工，由于前期规划周密，建成后的轨道交通网络由$2n$条地铁线路构成，组成了一个$n$纵$n$横的交通网。如下图所示，这$2n$条线路每条线路都包含$n$个车站，而每个车站都在一组纵横线路的交汇处。


出于建设成本的考虑，并非每个车站都能够进行站内换乘，能够进行站内换乘的地铁站共有$m$个，在下图中，标上方块标记的车站为换乘车站。已知地铁运行 1 站需要 2 分钟，而站内换乘需要步行 1 分钟。Serenade 想要知道，在不中途出站的前提下，他从学校回家最快需要多少时间（等车时间忽略不计）。


![](https://cdn.luogu.com.cn/upload/pic/6547.png)


## 说明/提示

对于 30%的数据，$n\le 50,m\le 1000$；

对于 60%的数据，$n\le 500,m\le 2000$；

对于 100%的数据，$n\le 20000,m\le 100000$；


## 样例 #1

### 输入

```
2 1
1 2
1 1 2 2```

### 输出

```
5```

## 样例 #2

### 输入

```
6 9
2 1
2 5
3 2
4 4
5 2
5 6
6 1
6 3
6 4
1 1 4 6```

### 输出

```
27```

## 样例 #3

### 输入

```
6 10
2 1
2 5
3 2
4 4
5 2
5 6
6 1
6 3
6 4
6 6
1 1 4 6```

### 输出

```
26```

# AI分析结果



## 【唯一算法分类】  
分层图最短路

---

## 【题解思路、算法要点与解决难点】  

### **核心思路**  
1. **分层图建模**：  
   - 将每个换乘站拆分为两层，分别表示**横向移动**与**纵向移动**状态。  
   - 层间通过权值为1的边连接，表示换乘的时间消耗（起点/终点换乘边权为0）。  

2. **高效建图**：  
   - 对同一行或列的换乘站**排序**，仅连接相邻节点，边权为坐标差的两倍。  
   - 横向层内仅连横向相邻点，纵向层内仅连纵向相邻点，避免O(m²)暴力建边。  

3. **Dijkstra优化**：  
   - 使用优先队列实现堆优化，时间复杂度O(m log m)。  

### **解决难点**  
- **状态表示**：通过分层将方向状态显式建模，避免在路径中动态维护方向信息。  
- **起点/终点处理**：起点和终点的层间边权设为0，允许无代价切换初始方向。  

---

## 【题解评分与推荐】  

### **≥4星题解**  
1. **Heartlessly (5星)**  
   - **亮点**：代码结构清晰，注释详尽；分层图建模直观；排序建边逻辑明确。  
   - **代码片段**：  
     ```cpp  
     sort(a + 1, a + n + 1, cmpx);  
     for (相邻点连横向边)...  
     sort(a + 1, a + n + 1, cmpy);  
     for (相邻点连纵向边)...  
     ```  

2. **EDqwq (4星)**  
   - **亮点**：代码简洁，节点编号处理巧妙；通过排序压缩边数。  
   - **技巧**：使用`m*2+3`等技巧简化层间映射。  

3. **BurningEnderDragon (4星)**  
   - **亮点**：详细注释分层图定义；提供完整AC代码与调试建议。  

---

## 【最优思路提炼】  

### **关键技巧**  
- **排序建边**：按坐标排序后仅连接相邻节点，将边数从O(m²)降至O(m)。  
- **分层状态转移**：通过两层节点显式表示移动方向，换乘转换为层间跳跃。  
- **起点/终点优化**：特殊处理初始方向选择，避免冗余计算。  

### **思维导图**  
```  
分层图  
├─ 横向层：仅连同行相邻节点，权值=2*Δy  
├─ 纵向层：仅连同列相邻节点，权值=2*Δx  
└─ 层间边：换乘节点连双向边，权值=1（起点/终点权值=0）  
```  

---

## 【同类题目推荐】  
1. **P4568 [JLOI2011]飞行路线** - 分层图经典问题，k次免费机会。  
2. **P4822 [BJWC2012]冻结** - 分层图+边权减半。  
3. **P2939 [USACO09FEB]Revamping Trails G** - 类似飞行路线。  

---

## 【可视化与算法演示】  

### **动画设计**  
1. **分层图展示**：  
   - 使用双列布局，左侧为横向层（红色节点），右侧为纵向层（蓝色节点）。  
   - 高亮当前处理的边（如横向边为黄色，纵向边为绿色）。  

2. **Dijkstra过程**：  
   - 节点按距离着色（暖色表示已访问，冷色表示待访问）。  
   - 实时显示优先队列中的节点与当前最短路径。  

3. **复古像素风格**：  
   - **Canvas绘制**：节点用8x8像素方块表示，边用单像素线连接。  
   - **音效**：移动时播放"哔"声，换乘时播放"叮"声，找到路径时播放胜利音效。  

### **交互控制**  
```javascript  
// 伪代码示例  
class DijkstraViz {  
  constructor() {  
    this.speed = 500; // 动画速度  
    this.layers = [/* 分层图数据 */];  
  }  
  step() { /* 执行单步算法 */ }  
  autoPlay() { /* 自动执行 */ }  
}  
```  

---

## **代码实现（关键片段）**  
```cpp  
// Heartlessly 题解核心代码  
void buildGraph() {  
    // 横向排序建边  
    sort(a, a+m+2, cmpx);  
    for (int i=1; i<m+2; ++i)  
        if (a[i].x == a[i+1].x)  
            addEdge(a[i].id, a[i+1].id, 2*(a[i+1].y - a[i].y));  

    // 纵向排序建边  
    sort(a, a+m+2, cmpy);  
    for (int i=1; i<m+2; ++i)  
        if (a[i].y == a[i+1].y)  
            addEdge(a[i].id + MAXN, a[i+1].id + MAXN, 2*(a[i+1].x - a[i].x));  

    // 层间连接  
    for (int i=1; i<=m; ++i)  
        addEdge(i, i+MAXN, 1);  
}  
```  

---

## **个人心得摘录**  
> "提交10+次全90分，最终发现是数组开小了...分层图题点数是2*m+4，边数要预估足够大！" —— 某题解调试经验  

---

## **总结**  
分层图技术通过状态分解，将复杂的方向决策转化为图结构问题。排序建边与层间跳跃的配合，在保证效率的同时完美建模换乘逻辑。该思路可推广至所有带状态转移的路径问题，是图论建模的经典范式。

---
处理用时：85.39秒
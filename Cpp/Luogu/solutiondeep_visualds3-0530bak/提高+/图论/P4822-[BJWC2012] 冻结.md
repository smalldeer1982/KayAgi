# 题目信息

# [BJWC2012] 冻结

## 题目背景

“我要成为魔法少女！”

“那么，以灵魂为代价，你希望得到什么？”

“我要将有关魔法和奇迹的一切，封印于卡片之中„„”

在这个愿望被实现以后的世界里，人们享受着魔法卡片（SpellCard，又名符卡）带来的便捷。

现在，不需要立下契约也可以使用魔法了！你还不来试一试？

比如，我们在魔法百科全书（Encyclopedia of Spells）里用“freeze”作为关键字来查询，会有很多有趣的结果。

例如，我们熟知的 Cirno，她的冰冻魔法当然会有对应的 SpellCard 了。当然，更加令人惊讶的是，居然有冻结时间的魔法，Cirno 的冻青蛙比起这些来真是小巫见大巫了。

这说明之前的世界中有很多魔法少女曾许下控制时间的愿望，比如 Akemi Homura、Sakuya Izayoi、……

当然，在本题中我们并不是要来研究历史的，而是研究魔法的应用。

## 题目描述

我们考虑最简单的旅行问题吧： 现在这个大陆上有 $N$ 个城市，$M$ 条双向的道路。城市编号为 $1$ ~ $N$，我们在 $1$ 号城市，需要到 $N$ 号城市，怎样才能最快地到达呢？

这不就是最短路问题吗？我们都知道可以用 Dijkstra、Bellman-Ford、Floyd-Warshall等算法来解决。

现在，我们一共有 $K$ 张可以使时间变慢 50%的 SpellCard，也就是说，在通过某条路径时，我们可以选择使用一张卡片，这样，我们通过这一条道路的时间 就可以减少到原先的一半。需要注意的是：

1. 在一条道路上最多只能使用一张 SpellCard。
2. 使用一张SpellCard 只在一条道路上起作用。
3. 你不必使用完所有的 SpellCard。

给定以上的信息，你的任务是：求出在可以使用这不超过 $K$ 张时间减速的 SpellCard 之情形下，从城市 $1$ 到城市 $N$ 最少需要多长时间。

## 说明/提示

#### 样例 1 解释

在不使用 SpellCard 时，最短路为 $1 \to 2 \to 4$，总时间为 10。现在我们可以使用 1 次 SpellCard，那么我们将通过 $2 \to 4$ 这条道路的时间减半，此时总时间为7。

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq K \leq N \leq 50$，$M \leq 10^3$。
- $1 \leq A_i,B_i \leq N$，$2 \leq Time_i \leq 2 \times 10^3$。
- 为保证答案为整数，保证所有的 $Time_i$ 均为偶数。
- 所有数据中的无向图保证无自环、重边，且是连通的。

## 样例 #1

### 输入

```
4 4 1 
1 2 4 
4 2 6 
1 3 8 
3 4 8 
```

### 输出

```
7```

# AI分析结果



# [BJWC2012] 冻结 题解分析

## 算法分类
**分层图最短路**

---

## 题解思路与核心难点

### 核心思路
**分层图建模**：  
将每个节点拆分为 K+1 层，第 i 层表示已使用 i 次 SpellCard。  
- **层内边**：保持原边权  
- **层间边**：边权减半，表示使用一次 SpellCard  

**Dijkstra/SPFA**：  
在扩展后的分层图上跑最短路，最终答案在所有层中取最小值。

### 解决难点
1. **分层图的正确构建**  
   确保每层与原图结构一致，层间仅在有边时建立减半边权。
2. **状态转移的完整性**  
   DP 方法需同时考虑“使用卡片”和“不使用卡片”两种转移路径。
3. **空间复杂度优化**  
   显式分层图需处理多层节点连接，而隐式状态转移（如二维数组）节省空间。

---

## 题解评分（≥4星）

### 1. Isprime（分层图 + Dijkstra）⭐️⭐️⭐️⭐️⭐️
- **亮点**：代码结构清晰，典型分层图模板实现。
- **核心代码**：  
  ```cpp
  for(int j=0;j<=k;j++) addedge(j*n+x,j*n+y,z),addedge(j*n+y,j*n+x,z);
  for(int j=0;j<k;j++) addedge(j*n+x,(j+1)*n+y,z/2),addedge(j*n+y,(j+1)*n+x,z/2);
  ```
  
### 2. communist（DP + SPFA）⭐️⭐️⭐️⭐️
- **亮点**：用二维数组 `dis[i][j]` 维护状态，避免显式建多层图。
- **核心代码**：  
  ```cpp
  if(dis[j][k] > dis[i][k] + e[i][j]) // 不使用卡片
  if(dis[j][k+1] > dis[i][k] + e[i][j]/2) // 使用卡片
  ```

### 3. 维迭生（wqs 二分）⭐️⭐️⭐️⭐️
- **亮点**：通过二分代价动态调整卡片使用次数，思路新颖。
- **核心代码**：  
  ```cpp
  if(check(mid)) ans = mid; // 二分查找最优代价
  ```

---

## 最优思路提炼
1. **分层图的最短路**  
   - 显式建立多层图，每层对应卡片使用次数。
   - 层间边权减半，Dijkstra 直接求解。
2. **状态转移 DP**  
   - 维护二维数组 `dis[i][j]`，松弛时同时处理使用/不使用卡片的情况。
   - 空间复杂度优化至 O(NK)，适合小规模数据。

---

## 同类型题与算法套路
- **分层图通用场景**：允许对边进行有限次特殊操作（如免费、减半）的最短路问题。
- **类似题目**：  
  - P4568 [JLOI2011] 飞行路线（K 次免费边）
  - P2939 [USACO09FEB] Revamping Trails（K 次边权降为 0）
  - P1948 [USACO08JAN]Telephone Lines（K 次免费边，求最小化最大边权）

---

## 推荐相似题目
1. **P4568** - 分层图模板题，K 次免费机会。
2. **P2939** - 类似分层思路，边权降为 0。
3. **P1266** - 速度限制与分层结合，需动态调整状态。

---

## 个人心得摘录
- **分层图调试**：“注意层间边的方向，建边时易漏反向连接。”（Isprime 题解注释）
- **DP 剪枝**：“不剪枝的 BFS 会 TLE，记忆化优化后效率显著提升。”（Seauy 题解）

---

## 算法可视化设计
### 核心动画方案
1. **分层图展示**  
   - **颜色标记**：每层用不同底色（如蓝、绿、黄），当前处理的节点高亮为红色。
   - **边权变化**：层间边显示为虚线并标注“1/2”符号，层内边为实线。
2. **状态转移演示**  
   - **表格更新**：右侧表格实时显示 `dis[i][j]` 的值，更新时闪烁对应单元格。
   - **路径追踪**：用箭头动态绘制当前最短路径，跨越层时显示层号变化。

### 复古像素风格实现
- **Canvas 绘制**：  
  - 节点用 16x16 像素方块表示，层间距为 50px。
  - 边权数字以 8-bit 字体显示，使用调色板 `#FF0000`（红）、`#00FF00`（绿）等。
- **音效设计**：  
  - 节点松弛成功：播放短促“哔”声（Web Audio API）。
  - 找到最短路径：播放经典 FC 过关音效。

### 交互功能
- **步进控制**：支持暂停/继续、单步执行，速度调节（1x~5x）。
- **模式切换**：可对比分层图与 DP 两种算法的执行过程，高亮关键差异步骤。

---

## 核心代码片段（分层图 Dijkstra）
```cpp
void dijkstra() {
    priority_queue<Node> q;
    q.push({1, 0});
    dis[1] = 0;
    while (!q.empty()) {
        Node u = q.top(); q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (auto &e : edges[u]) {
            int v = e.to, w = e.w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                q.push({v, dis[v]});
            }
            // 层间转移（伪代码）
            if (layer < K && dis[v + n] > dis[u] + w/2) {
                dis[v + n] = dis[u] + w/2;
                q.push({v + n, dis[v + n]});
            }
        }
    }
}
```

---
处理用时：90.16秒
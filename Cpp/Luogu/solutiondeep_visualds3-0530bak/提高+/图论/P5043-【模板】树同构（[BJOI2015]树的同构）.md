# 题目信息

# 【模板】树同构（[BJOI2015]树的同构）

## 题目描述

树是一种很常见的数据结构。

我们把 $N$ 个点，$N-1$ 条边的连通无向图称为树。

若将某个点作为根，从根开始遍历，则其它的点都有一个前驱，这个树就成为有根树。

对于两个树 $T_1$ 和 $T_2$，如果能够把树 $T_1$ 的所有点重新标号，使得树 $T_1$ 和树 $T_2$ 完全相同，那么这两个树是同构的。也就是说，它们具有相同的形态。

现在，给你 $M$ 个无根树，请你把它们按同构关系分成若干个等价类。

## 说明/提示

编号为 $1, 2, 4$ 的树是同构的。编号为 $3$ 的树只与它自身同构。

对于 $100\%$ 的数据，$1\leq N,M\leq 50$。

## 样例 #1

### 输入

```
4 
4 0 1 1 2 
4 2 0 2 3 
4 0 1 1 1 
4 0 1 2 3 ```

### 输出

```
1 
1 
3 
1 ```

# AI分析结果



# 算法分类  
**树哈希**

---

## 综合分析与结论  
### 核心思路与难点  
1. **无根树同构判断**：通过找重心作为根，将无根树转化为有根树，减少需比较的根节点数量（最多两个重心）。  
2. **哈希设计**：计算每个子树哈希值时，先对子节点哈希排序以消除顺序影响，再用多项式合并（如 `哈希 = 哈希 * 基 + 子哈希`）。  
3. **抗碰撞优化**：通过排序子树哈希值确保结构无序性不影响结果，使用大质数或随机基增强抗碰撞性。

### 可视化设计思路  
- **重心寻找**：高亮树结构中的重心节点，动态演示如何通过子树大小计算确定重心。  
- **哈希计算动画**：以递归方式展开子树，用不同颜色标记当前处理的子树，展示子哈希排序与合并过程。  
- **复古像素风格**：用 8-bit 网格显示树结构，每步哈希合并时播放“合成音效”，找到同构时播放胜利音效。

---

## 题解清单（≥4星）  
1. **zhoukangyang（5星）**  
   - **亮点**：结合重心与多项式哈希，复杂度低（O(nm log n)），代码简洁。  
   - **核心代码**：  
     ```cpp  
     void dfs(int x, int fa) {  
         // 计算哈希，子节点哈希排序后合并  
         for (auto v : sons) sort(...);  
         has[x] = 1 + sum(has[son] * prime[size[son]]);  
     }  
     ```  
2. **ix35（5星）**  
   - **亮点**：最小表示法确保唯一性，通过括号序列避免哈希碰撞。  
   - **核心代码**：  
     ```cpp  
     string dfs(int x) {  
         vector<string> sub;  
         for (auto v : sons) sub.push_back(dfs(v));  
         sort(sub.begin(), sub.end());  
         return "(" + join(sub) + ")";  
     }  
     ```  
3. **hyfhaha（4星）**  
   - **亮点**：暴力枚举所有根节点哈希，实现简单易懂。  
   - **核心代码**：  
     ```cpp  
     for (int root = 1; root <= n; root++)  
         hashes[root] = compute_hash(root);  
     sort(hashes);  
     ```

---

## 最优思路提炼  
1. **重心优化**：仅需检查重心作为根，降低比较次数。  
2. **子树哈希排序**：消除子节点顺序影响。  
3. **复合哈希基**：使用质数或随机大数作为哈希基，降低碰撞概率。

---

## 相似题目推荐  
1. **P1237 树的匹配**（树结构计数）  
2. **P4323 树的同构**（进阶版同构判断）  
3. **P3381 树链剖分**（树结构处理基础）

---

## 代码实现（核心片段）  
```cpp  
// 重心查找与哈希计算  
void find_centroid(int u) {  
    size[u] = 1; max_sub[u] = 0;  
    for (int v : adj[u]) {  
        if (v != parent[u]) {  
            find_centroid(v);  
            size[u] += size[v];  
            max_sub[u] = max(max_sub[u], size[v]);  
        }  
    }  
    max_sub[u] = max(max_sub[u], total_size - size[u]);  
    if (max_sub[u] < min_max_sub) {  
        centroids.clear();  
        centroids.push_back(u);  
        min_max_sub = max_sub[u];  
    } else if (max_sub[u] == min_max_sub) {  
        centroids.push_back(u);  
    }  
}  

ull compute_hash(int u, int parent) {  
    vector<ull> child_hashes;  
    for (int v : adj[u]) {  
        if (v != parent)  
            child_hashes.push_back(compute_hash(v, u));  
    }  
    sort(child_hashes.begin(), child_hashes.end());  
    ull hash = 1;  
    for (ull h : child_hashes)  
        hash = hash * BASE + h;  
    return hash;  
}  
```

---

## 可视化与复古动画设计  
1. **像素化树结构**：Canvas 绘制树节点为彩色方块，边为线条。  
2. **哈希合并动画**：子树方块向父节点聚合时播放“收集音效”。  
3. **AI 自动演示**：按DFS顺序自动遍历，空格键暂停/继续。  
```javascript  
// 伪代码：Canvas动画核心  
function drawTree(node, parentPos) {  
    ctx.fillStyle = node.isCentroid ? "#FF5555" : "#55FF55";  
    ctx.fillRect(node.x, node.y, 20, 20);  
    for (child in node.children) {  
        drawLine(parentPos, child.pos);  
        drawTree(child, node.pos);  
    }  
}  
```

---
处理用时：76.73秒
# 题目信息

# [MtOI2018] 刷题？作业狂魔！

## 题目背景

在临听到暑假的尾声以后，神奇的 cz 终于发觉自己的作业不能完成了。

在他写完作业之前，你需要将他做作业的顺序告诉给他听，这样你们就可以一起玩了。  



## 题目描述

你拥有 $T$ 分钟的时间。

做作业的顺序可以根据重要度 $v_i$ 来排序，但可能这不是最佳方案。且每项作业可能不止有一项，所以每项作业还有一个数量 $c_i$，每项 $t_i$ 分钟可以完成。

而在做某作业之前可能要先写完某个作业，所以还给出 $M$ 个关系，每个关系包含两个数 $a$，$b$ ，代表 $a$ 是 $b$ 完成的前提，不存在 $a=b$ 的情况。

关系不排除环的情况，cz 不想重做一遍作业，只好不做在环上的作业。

当某作业做到一半但时间结束，则失去该作业重要度；当该作业只做了 $k$ 个，但 $k\leq c_i$ ,则得到 $k\times v_i$ 重要度 , 如果该作业没把 $c_i$ 个做完，则不得做其他作业。

可存在 $b$ 有多个 $a$，但请注意一个作业的 **一个** 前提被做了以后，该作业就可以被做了。但cz非常专注，他写完一个作业以后就必须写**以该作业为前提的**作业。

## 说明/提示

### 子任务

对于 $100\%$ 的数据，$1<=N<=10000,1<=M<=100000$

其他值均在$long long$范围内。


### 题目来源

[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T1

出题人：Doubleen

56432

## 样例 #1

### 输入

```
4 7
2 1 1
2 1 2
2 1 3
2 1 4
3
3 4
2 3
1 2```

### 输出

```
6```

# AI分析结果



## 唯一算法分类
图论（拓扑排序与强连通分量）

## 综合分析与结论
本题核心是通过图论算法处理环后，在 DAG 上使用 DFS 计算最大收益。关键难点是环检测与依赖顺序处理，两种主流解法如下：

### 核心算法流程与可视化设计
1. **环检测**  
   - **Tarjan 方案**：用强连通分量算法标记环节点（颜色标记强连通分量，红色高亮环节点）  
   - **拓扑排序方案**：正反两次拓扑后标记环相关节点（灰色高亮无法访问节点）  
   - 可视化动画中，环检测过程以逐层收缩效果展示，环节点用闪烁红光提示  

2. **DFS 价值计算**  
   - 从入度为零的起点（蓝色节点）开始，沿绿色箭头遍历依赖链  
   - 时间条动态减少，剩余时间不足时显示黄色警告  
   - 节点收益实时更新为最大值（金色数字跳动）  
   - 关键操作音效：  
     - 进入节点：8-bit "点击" 音效  
     - 时间耗尽：短促下降音阶  
     - 新最大收益：上升音阶  

## 题解清单（≥4星）
1. **Doubleen（⭐⭐⭐⭐⭐）**  
   - 亮点：Tarjan 强连通分量精准标记环，代码结构清晰  
   - 个人心得：强调吸氧优化，实践导向  

2. **code_farmer2_2（⭐⭐⭐⭐）**  
   - 亮点：拓扑排序高效处理环，虚拟节点统一处理起点  
   - 代码特色：回溯式 DFS 节省内存  

3. **Accepted3927（⭐⭐⭐⭐）**  
   - 亮点：双拓扑排序创新判环，反图思想扩展性强  
   - 提醒：虚拟节点连接所有起点简化逻辑  

## 代码核心实现
### Tarjan + DFS 核心片段
```cpp
void tarjan(int x) { // 强连通分量标记环
    dfn[x] = low[x] = ++tot;
    sta[++top] = x; vis[x] = true;
    for(int i=head[x]; i; i=edge[i].next) {
        int u = edge[i].to;
        if(!dfn[u]) tarjan(u), low[x] = min(low[x], low[u]);
        else if(vis[u]) low[x] = min(low[x], dfn[u]);
    }
    if(dfn[x] == low[x]) { // 发现强连通分量
        int cnt = 0;
        while(sta[top] != x) {
            color[sta[top]] = sum;
            vis[sta[top--]] = false;
            cnt++;
        }
        if(cnt >= 1) can[sum] = true; // 标记环
    }
}

void dfs(int x, int s, int la) { // 收益计算
    ans = max(ans, s);
    for(int i=head[x]; i; i=edge[i].next) {
        int u = edge[i].to;
        if(can[color[u]]) continue;
        if(la >= c[u]*t[u]) 
            dfs(u, s + c[u]*v[u], la - c[u]*t[u]);
        else 
            ans = max(ans, s + (la/t[u])*v[u]);
    }
}
```

## 同类型题与算法套路
1. **依赖处理**：P2014（树形依赖背包）  
2. **DAG 最值**：P3586（DAG 上动态规划）  
3. **环检测应用**：P3387（强连通分量缩点）  

## 推荐练习题
1. **P2014 [CTSC1997] 选课** - 树形依赖背包  
2. **P1064 金明的预算方案** - 依赖条件下的背包问题  
3. **P3387 【模板】缩点** - 强连通分量与DAG处理  

## 个人心得摘录
> "十年 OI 一场空，不开 long long 见祖宗" —— 所有题解均强调数值范围处理  
> "拓扑排序后入度非零节点必与环相关" —— Accepted3927 的双拓扑思路突破  
> "暴力 DFS 在稀疏图下表现优异" —— code_farmer2_2 实践验证  

## 复古游戏化演示设计
- **像素风格**：16色调色板，节点为 16x16 像素方块，依赖箭头用绿色像素线  
- **自动演示模式**：AI 按最优路径自动探索，按空格切换手动/自动  
- **计分板**：右上角显示当前时间与最高收益（8-bit 数字字体）  
- **音效设计**：  
  - 背景音乐：FC《超级马里奥》地下关循环旋律  
  - 错误操作：FC《塞尔达传说》受伤音效  
- [查看在线演示](https://example.com/demo)（伪链接，示意用）

---
处理用时：73.58秒
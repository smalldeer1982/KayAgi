# 题目信息

# 【模板】Stoer-Wagner

## 题目描述

定义无向图 $G$ 的最小割为：一个去掉后可以使 $G$ 变成两个连通分量，且边权和最小的边集的边权和。

给出一张无向图 $G$，求其最小割。

## 说明/提示

对于前 $20\%$ 的数据， $n\leq 10$。  
对于前 $40\%$ 的数据， $n\leq 100$。  
对于另外 $10\%$ 的数据，保证输入为一棵树。  
对于另外 $10\%$ 的数据，保证输入为一条链。  
对于 $100\%$ 的数据， $n\leq 600,m\leq \frac{n\times (n-1)}{2}$ ，保证 $\sum_{i=1}^{m}w_i \leq10^9$ 。

#### PS：想交 最大流/最小割树 的就省省吧。

## 样例 #1

### 输入

```
4 6
1 2 5
1 3 1
2 4 1
3 4 2
2 3 1
1 4 2
```

### 输出

```
4```

# AI分析结果



## 算法分类
**Stoer-Wagner算法**

---

## 题解思路与算法要点

### 核心思路
所有题解均基于 Stoer-Wagner 算法的两个核心阶段：
1. **MinimumCutPhase**：通过贪心选择最大权值点构建点集，计算 s-t 最小割
2. **点合并**：将最后两个点合并，保留边权叠加关系

### 关键实现差异对比
| 题解作者 | 数据结构 | 点合并方式 | 时间复杂度 | 代码可读性 |
|---------|---------|------------|-----------|-----------|
| ix35    | 邻接矩阵 | 直接累加边权 | O(n³) | ★★★★☆ |
| Mine_King | 邻接矩阵 | 数组标记合并 | O(n³) | ★★★★☆ |
| 0Io_oI0 | 邻接矩阵 | 并查集辅助合并 | O(n³) | ★★★☆☆ |
| Lstdo   | 动态邻接表 | 随机收缩边 | O(n² log²n) | ★★☆☆☆ |

### 解决难点
1. **正确性证明**：ix35 通过归纳法证明最后加入点 t 的权值即为最小割
2. **合并操作**：所有实现通过将 t 的边权累加到 s 实现"虚拟合并"
3. **去重边处理**：邻接矩阵天然支持边权叠加，链式前向星需特殊处理

---

## 题解评分（≥4星）

### ix35（★★★★★）
- **亮点**：完整数学证明 + 邻接矩阵高效实现
- **代码**：25行核心函数，`proc`函数实现 MinimumCutPhase
- **优化**：`dap[]`数组标记已合并点，避免实际删除节点

### Mine_King（★★★★☆）
- **亮点**：独立实现 contract 函数，伪代码级注释
- **特色**：使用`vis1[]`和`vis2[]`双重标记已合并/已访问点

### RockyYue（★★★★☆）
- **亮点**：最简实现（45行完整代码）
- **技巧**：`alive[]`数组标记存活节点，`nxt[]`链表维护存活节点集合

---

## 最优技巧提炼

### 邻接矩阵的妙用
```cpp
// 合并 t 到 s 的核心操作
for(int j=1; j<=n; j++) {
    g[s][j] += g[t][j];
    g[j][s] += g[j][t];
}
```
- **优势**：O(1)时间复杂度完成边权合并
- **原理**：将 t 的所有邻接边权累加到 s 上，实现"虚拟合并"

### 动态权值更新
```cpp
// MinimumCutPhase 权值更新逻辑
for(int j=1; j<=n; j++) 
    if(!dap[j] && !vis[j]) 
        w[j] += dis[mx][j];
```
- **作用**：实时维护每个点到当前集合 A 的总边权
- **复杂度**：每轮 O(n²)，共 O(n³) 总时间

---

## 同类型题拓展
1. **边权合并思想**：POJ2914 Minimum Cut
2. **动态缩点技巧**：LOJ#6008 餐巾计划问题
3. **全局最值问题**：CF103E Buying Sets

---

## 可视化设计

### 动画方案
1. **节点染色**：
   - 红色：当前集合 A 中的点
   - 绿色：最新加入的点（s/t）
   - 灰色：已合并的虚拟节点

2. **关键帧**：
   ```python
   # 伪代码示例
   for phase in 1..n-1:
       highlight A集合为红色
       逐步加入最大权值点 -> 绿色闪烁
       显示当前权值w[i]的更新过程
       合并最后两个点 -> 灰色标记t，s继承边权
   ```

3. **交互控制**：
   - 步进按钮：单步执行 MinimumCutPhase
   - 速度滑块：调节动画速度（0.5x~5x）
   - 合并追踪：点击任意节点显示其合并历史

### 复古像素风格实现
```javascript
// Canvas 绘制示例
function drawNode(ctx, x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*40, y*40, 32, 32); // 8位风格方块
    ctx.strokeStyle = '#000';
    ctx.strokeRect(x*40, y*40, 32, 32);
}

// 音效触发
function playSFX(type) {
    let osc = audioCtx.createOscillator();
    osc.frequency.value = type === 'merge' ? 880 : 440; // 合并/选择不同音高
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(0.1);
}
```

---

## 推荐题目
1. **P5633** - 最小度限制生成树（边权动态处理）
2. **P3388** - 割点（连通性相关）
3. **P4722** - 最大流（对比网络流解法）

---

## 调试心得摘录
> HansLimon：  
> "邻接矩阵处理合并时，发现若不继承双向边权会导致后续计算错误...改为同时更新`g[s][j]`和`g[j][s]`后AC"

> Lstdo：  
> "随机收缩的正确率与 log²n 次试验次数强相关，设置 100/log(n) 次后通过率显著提升"

---

## 核心代码实现
```cpp
// ix35 题解核心部分
int proc(int x) {
    memset(vis,0,sizeof(vis));
    memset(w,0,sizeof(w));
    w[0] = -1;
    for(int i=1; i<=n-x+1; i++) {
        int mx = 0;
        for(int j=1; j<=n; j++)
            if(!dap[j] && !vis[j] && w[j]>w[mx]) 
                mx = j;
        vis[mx] = 1, ord[i] = mx;
        for(int j=1; j<=n; j++) 
            if(!dap[j] && !vis[j]) 
                w[j] += dis[mx][j];
    }
    s = ord[n-x], t = ord[n-x+1];
    return w[t];
}

int sw() {
    int res = INF;
    for(int i=1; i<n; i++) {
        res = min(res, proc(i));
        dap[t] = 1;
        for(int j=1; j<=n; j++) {
            dis[s][j] += dis[t][j];
            dis[j][s] += dis[j][t];
        }
    }
    return res;
}
```

---
处理用时：75.76秒
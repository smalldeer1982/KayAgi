# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果



# 『MdOI R2』Odyssey 题解分析

**唯一算法分类**：动态规划（DAG 最长路径）结合数论处理

---

## 题解思路与算法要点

### 核心思路
1. **数论处理**：将边权分解质因数后，指数对 k 取模得到简化权值。此时每个权值唯一对应一个互补权值，使得两者乘积为完美数对。
2. **状态转移**：用 `dp[u][w]` 表示以节点 u 结尾且最后一条边权为 w 的最长路径长度。通过拓扑排序按 DAG 顺序转移。
3. **分层图优化**：通过将节点拆分为两层（原节点和 +n 节点），确保交替使用两种互补权值，避免连续不匹配。

### 解决难点
- **互补权值计算**：需处理大质数和高次幂导致的溢出，如 `f_w` 超过 1e5 时直接标记为无效。
- **状态管理**：使用哈希表或 `unordered_map` 存储每个节点的多种权值状态。
- **DAG 结构利用**：拓扑排序保证无环性，避免重复计算。

---

## 最优思路提炼

1. **质因数分解模 k**  
   ```python
   def process(w):
       res = 1
       for p in primes:
           cnt = 0
           while w % p == 0: w /= p; cnt +=1
           cnt %= k
           res *= p^cnt  # 取模后的简化权值
       return res
   ```
   将每个边权转化为指数模 k 后的唯一形式。

2. **互补权值推导**  
   若当前权值 w 的质因数分解为 p₁^a₁ p₂^a₂...，互补权值需满足每个指数为 (k - aᵢ) mod k。

3. **分层图拓扑排序**  
   - 原层处理权值 w 的边，+n 层处理互补权值 f(w) 的边。
   - 每次转移切换层级，确保路径合法。

---

## 可视化设计

### 动画演示方案
1. **质因数分解过程**  
   - 高亮当前分解的质因数，显示指数取模操作。
   - 右侧动态显示互补权值计算过程。

2. **分层图节点转移**  
   - 原节点用蓝色，+n 节点用橙色。
   - 边权 w 用绿色箭头，互补边 f(w) 用红色箭头。
   - 动态显示拓扑队列处理节点时的状态更新。

3. **状态更新效果**  
   - 当前处理的节点用闪烁边框。
   - DP 数值更新时显示上升动画，最长路径实时标注。

### 复古像素风格设计
- **调色板**：16 色 FC 风格，蓝色（节点）、橙色（互补节点）、绿/红（边权）。
- **音效**：分解质因数时播放 "blip" 音效，找到最长路径时播放 8-bit 胜利音效。
- **Canvas 绘制**：网格化显示节点，边权用像素箭头，状态更新时数字滚动。

---

## 题解评分（≥4星）

### 1. BFqwq 题解（★★★★☆）
- **亮点**：分层图设计巧妙处理交替权值，拓扑排序保证效率。
- **代码片段**：
  ```cpp
  void topo(int w) {
    while (!q.empty()) {
      int u = q.front(); q.pop();
      for (auto e : edges) {
        if (e.w == w) add_edge(u, e.v, w);
        if (e.w == f_w) add_edge(u + n, e.v + n, f_w);
        // 更新 dp 并维护最大值
      }
    }
  }
  ```

### 2. 一扶苏一 题解（★★★★☆）
- **亮点**：双模哈希避免冲突，map 维护状态清晰。
- **核心逻辑**：
  ```cpp
  for (auto &e : edges) {
    int hash1 = calc_hash(e.w, mod1);
    int hash2 = calc_hash(e.w, mod2);
    dp[v][{hash1, hash2}] = max(dp[v][...], dp[u][...] + l);
  }
  ```

### 3. zzqDeco 题解（★★★☆☆）
- **优点**：代码简洁，直接利用 unordered_map 处理状态。
- **改进点**：未处理大权值可能导致哈希冲突。

---

## 相似题目推荐
1. **P4017 最大食物链计数**（DAG 动态规划）
2. **P3385 【模板】负环**（拓扑排序应用）
3. **P2421 质数分解应用**（数论结合图论）

---

## 核心代码实现（分层图版）

```cpp
void work(int u, int v, int w, int l) {
    int w1 = process(w); // 简化权值
    int w2 = find_complement(w1); // 互补权值
    if (w2 > LIMIT) return;
    
    // 原层边：u -> v (w1)
    g[w1].push_back({u, v, l});
    // 互补层边：u+n -> v+n (w2)
    g[w2].push_back({u + n, v + n, l});
}

void topo() {
    queue<int> q;
    for (int i = 1; i <= n; i++) {
        if (in[i] == 0) q.push(i);
    }
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto &e : g[u_layer]) { // 处理当前权值层
            int v = e.to;
            dp[v][e.w] = max(dp[v][e.w], dp[u][complement_w] + e.l);
            if (--in[v] == 0) q.push(v);
        }
    }
}
```

---

**总结**：本题需结合数论分解与 DAG 动态规划，分层图和哈希管理状态是核心技巧。理解质因数模处理和互补权值推导是关键突破点。

---
处理用时：78.97秒
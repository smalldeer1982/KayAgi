# 题目信息

# [YsOI2020] 幼儿园

## 题目描述

Ysuperman 热爱在 TA 的幼儿园里散步，为了更方便散步， TA 把幼儿园抽象成 $n$ 个点，$m$ 条边的**有向图**。 散步得多了， TA 就给了每一条边**无与伦比**的亲密程度：$1,2,\cdots,m$，越大代表越亲密。 TA 也给了每一个点无与伦比的编号：$1,2,\cdots,n$，其中 $1$ 代表着幼儿园大门，但是每个**点是没有亲密程度的**。

接下来 $k$ 天，Ysuperman 每天会有一次散步计划。具体而言， TA 希望从 $x_i$ 号点出发，只经过**亲密程度属于区间 $[l_i,r_i]$ 的边**，走到幼儿园大门 $1$ 号点，期间经过的边的亲密程度必须**单调递减**，不然会因为 TA 有强迫症而不能回家。


Ysuperman 看着自己刚刚画的草稿脑子一团浆糊， TA 发现 TA 始终没有办法规划出这么多合理路线，现在 TA 想请你帮 TA 。具体而言，对于每一天的计划，如果可行，则输出 `1`，反之输出 `0`。

当然啦，有的时候 Ysuperman 很着急，需要你立马回复，有的时候 TA 可以等等你，先把所有问题问完再等你回复。

## 说明/提示

### 样例说明

#### 样例说明 $1$

![](https://cdn.luogu.com.cn/upload/image_hosting/wxji6w6f.png)

对于第 $2$ 条计划，Ysuperman 已经站在门口，所以计划可行。

对于第 $3$ 条计划，Ysuperman 只能通过路径 $5 \overset{6}{\rightarrow}3 \overset{5}{\rightarrow} 1$。（箭头上方数字表示的是边的亲密程度）。

其他计划都是不可行的。

#### 样例说明 $3$

样例三为加密后的样例二。

----

### 数据范围

**本题采用捆绑测试。**

| $\mathrm{subtask}$ |     $n$     |       $m$        |        $k$        |  特殊性质   | 分数  |
| :----------------: | :---------: | :--------------: | :---------------: | :---------: | :---: |
|        $1 $        |   $\le17$   |     $\le17$      | $\le 2\cdot 10^5$ |      /      | $ 5$  |
|        $2$         |  $\le500$   |     $\le500$     |     $\le500 $     |      /      | $17$  |
|        $3 $        | $\le 3000$  |   $\le 3000 $    |    $\le 3000 $    |      /      | $18 $ |
|       $ 4 $        |  $\le10^5$  | $\le2\cdot10^5$  |  $\le2\cdot10^5$  |   $v_i=1$   | $13$  |
|        $5 $        | $\le 10^5$  | $\le 2\cdot10^5$ |    $\le 10^5$     | $l_i=1,w=0$ | $ 7 $ |
|        $6$         | $\le10^5 $  | $\le2\cdot10^5$  |    $\le 10^5$     |   $w=0 $    | $13 $ |
|        $7$         | $ \le 10^5$ | $\le 2\cdot10^5$ | $\le 2\cdot10^5$  |      /      | $27$  |

对于 $100\%$ 的数据，满足 $1 \le n \le 10^5 ,1 \le m \le 2\cdot10^5 ,0 \le k \le 2\cdot10^5$。

$w\in\{0,1\},1 \le u_i,v_i \le n$。

$x_i,l_i,r_i$ 在解密后保证 $1\le x \le n ,1 \le l_i,r_i \le m $。

### 提示

**不保证不出现重边自环，不保证图联通**。

## 样例 #1

### 输入

```
5 7 5 0
3 2
1 2
4 3
5 4
3 1
5 3
5 1
3 1 4
1 2 2
5 5 6
4 5 7
2 1 7
```

### 输出

```
0
1
1
0
0
```

## 样例 #2

### 输入

```
5 12 10 0
4 2
4 2
5 3
3 3
1 5
1 4
4 4
2 4
5 3
1 5
2 2
4 1
4 3 5
4 2 3
1 4 5
3 1 8
3 1 4
3 5 5
2 1 12
4 10 12
2 5 5
1 1 3
```

### 输出

```
0
0
1
0
0
0
0
1
0
1
```

## 样例 #3

### 输入

```
5 12 10 1
4 2
4 2
5 3
3 3
1 5
1 4
4 4
2 4
5 3
1 5
2 2
4 1
4 3 5
4 2 3
1 4 5
2 0 9
2 0 5
2 4 4
3 0 13
5 11 13
0 7 7
3 3 1```

### 输出

```
0
0
1
0
0
0
0
1
0
1
```

# AI分析结果



---

## 算法分类

**图论 + 贪心预处理 + 线段树/主席树**

---

## 综合分析与结论

### 核心思路
1. **反图构建与贪心预处理**  
   将原图边反向，转化为从节点1出发，走边权递增的路径是否能到达目标点。预处理每个节点x的`f[x]`，表示从1到x的路径中，最小边权的最大值（即路径中边权递增的最大起点）。

2. **动态维护状态**  
   按边权从小到大处理边。对于边u→v，若u可达（已更新`f[u]`），则更新v的`f[v] = max(f[v], min(f[u], 当前边权))`。该过程保证每个点的`f[x]`始终是当前最优解。

3. **历史版本存储**  
   使用线段树或主席树保存每个点的`f[x]`在不同时间点的状态。查询时只需检查在区间`[l, r]`内是否存在`f[x] >= l`的版本。

### 解决难点
- **路径的单调性处理**：通过反图转化和边权递增顺序处理，将路径的单调递减转化为递增。
- **高效查询**：通过预处理每个点的状态历史，将查询转化为二维偏序问题，用线段树或二分快速判断。

### 可视化设计
1. **动态边处理动画**  
   - **像素风格**：节点用不同颜色表示状态（如红色不可达，绿色可达）。
   - **边处理高亮**：当前处理的边用闪烁效果，更新节点状态时播放音效。
   
2. **状态更新演示**  
   - 每处理一条边，显示`f[u]`和`f[v]`的更新过程，通过箭头动画展示状态传递。
   - 使用Canvas绘制网格，节点按编号排列，边按处理顺序逐步显示。

3. **查询交互**  
   - 输入查询参数后，自动跳转到对应的`r`版本，高亮目标节点x，并显示其`f[x]`与`l`的对比。
   - 成功/失败时播放不同音效（上扬音调/短促低音）。

---

## 题解清单（≥4星）

### Lskkkno1（5星）
- **亮点**：贪心预处理 + 动态开点线段树，时间复杂度O(m + q log m)。
- **代码简析**：维护每个节点的线段树，存储`[l, r]`区间，查询时检查最小右端点是否≤r_i。

### Imakf（4星）
- **亮点**：离线二分 + 历史版本记录，空间优化，适合强制在线场景。
- **核心代码**：用`vector`记录每个点的修改时间，二分查找最大有效`f[x]`。

### BYR_KKK（4星）
- **亮点**：主席树维护历史状态，在线查询高效，代码简洁。
- **核心思想**：每次边处理生成新版本，查询时直接访问对应版本的`f[x]`。

---

## 最优思路提炼

### 关键技巧
1. **反图转化**：将原问题转化为从1出发的递增路径问题，简化状态转移。
2. **贪心更新`f[x]`**：按边权递增处理，保证每个点的状态是最优解。
3. **历史版本存储**：通过线段树或主席树支持高效区间查询。

### 实现片段
```cpp
// Lskkkno1的线段树更新逻辑
void modify(int &u, int l, int r) {
    if(!u) u = ++vcnt, a[u].val = INF;
    if(l == r) return a[u].val = min(a[u].val, cv), void();
    int mid = (l + r) >> 1;
    if(ll <= mid) modify(a[u].lch, l, mid);
    else modify(a[u].rch, mid + 1, r);
    a[u].val = min(a[a[u].lch].val, a[a[u].rch].val);
}

// Imakf的二分查询逻辑
auto kksk = upper_bound(vec[0][x].begin(), vec[0][x].end(), r);
--kksk;
auto s = vec[1][x].begin() + (kksk - vec[0][x].begin());
if(*s >= l || x == 1) return true;
```

---

## 同类题目推荐
1. **P2146 [NOI2015] 软件包管理器**  
   - 树链剖分 + 线段树，维护安装/卸载状态。

2. **P3384 【模板】轻重链剖分**  
   - 树链剖分基础，路径与子树操作。

3. **P4551 最长异或路径**  
   - Trie树处理异或路径最大值，贪心思想。

---

## 可视化与复古动画设计

### 动画流程
1. **初始化**  
   - 节点1显示为绿色，其他节点红色。
   - 边按编号1~m排列，初始隐藏。

2. **处理边i**  
   - 边i高亮，若其起点u可达（绿色），终点v变绿，更新`f[v]`并显示数值。
   - 播放“更新成功”音效（8-bit短音）。

3. **查询演示**  
   - 输入x, l, r后，定位到版本r，检查x是否为绿色且`f[x] >= l`。
   - 成功时x闪烁绿色，失败则红色，对应音效反馈。

### 技术实现
- **Canvas绘图**：用网格布局节点，边逐步显示，颜色区分状态。
- **音效**：Web Audio API生成方波音效，不同操作对应不同频率。
- **自动模式**：按处理顺序自动播放，可暂停/调整速度。

---

**注**：完整代码与动画实现需结合具体前端技术栈开发，核心逻辑可参考上述思路。

---
处理用时：110.77秒
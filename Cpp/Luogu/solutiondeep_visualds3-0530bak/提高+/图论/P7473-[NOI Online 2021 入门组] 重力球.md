# 题目信息

# [NOI Online 2021 入门组] 重力球

## 题目描述

“重力球”游戏在一块 $n\times n$ 的正方形区域中进行，记从上往下第 $i$ 行，从左往右第 $j$ 列的位置为 $(i,j)$。

正方形区域中存在 $m$ 个障碍，第 $i$ 个障碍占据位置 $(x_i,y_i)$，此外，正方形区域的边界外都是障碍。

现在有两个小球，位置分别是 $(a,b)$ 和 $(c,d)$，在游戏中你可以进行如下操作：

- 指定上、下、左、右中的一个方向，将重力方向“切换”为这个方向。此时两个小球会同时向这个方向移动，直到碰到障碍。

你要用最少的操作次数使得两个小球到达同一个位置。

现有 $q$ 局游戏，每局游戏中只有小球的初始位置不同，而障碍位置是不变的，你需要对每局游戏都求出最小操作次数，或报告无解。

## 说明/提示

### 样例 $1$ 解释

该样例中障碍分布如图中红叉所示。

第一组询问中只需将重力改向上（或改向下）即可使两球同时到达。

第二组询问中两球已经在同一位置故不需操作。

第三组询问中改变3 次重力的方向，依次改为向左、向下、向左，小球移动路线分别如图中粉色、橙色、棕色线所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/7nngrov0.png)
### 数据范围与提示
对于 $20\%$ 的数据：$n,m\le 2$。

对于 $50\%$ 的数据：$n,m\le30$。

对于另外 $30\%$ 的数据：$q=1$。

对于 $100\%$ 的数据：$1\le n,m\le250，1\le q\le10^5，1\le x_i,y_i,a,b,c,d\le n$。

数据由 [SSerxhs](https://www.luogu.com.cn/user/29826) 提供。

数据参考了 小喵喵不喜欢计算几何 2020 ICPC 区域赛（南京）A 题的构造方案，在此表示感谢。

## 样例 #1

### 输入

```
4 4 3
2 2
2 4
3 2
4 4
1 3 4 3
2 1 2 1
1 2 3 4```

### 输出

```
1
0
3```

# AI分析结果



## 【唯一算法分类】
广度优先搜索（BFS）与预处理

---

## 【题解思路与核心分析】
### 算法核心要点
1. **有效点预处理**  
   小球每次移动后必定停靠在障碍物或边界相邻的格子（称为"有效点"）。通过预处理将所有有效点编号，将状态数从 $O(n^4)$ 降至 $O((n+m)^2)$。

2. **方向移动预处理**  
   对每个有效点预处理四个方向的移动终点，建立状态转移图。例如：`t[i][j][k]` 表示点 $(i,j)$ 向方向 $k$ 移动后的终点编号。

3. **反向建图与多源BFS**  
   以所有重合状态（两球位置相同）为起点，建立反向边进行多源BFS。通过 `dis[u][v]` 记录两球分别处于状态 $u$ 和 $v$ 时的最小操作次数。

4. **查询优化**  
   对于每个查询，枚举四个初始方向，取预处理结果的最小值。时间复杂度从 $O(q \cdot n)$ 优化至 $O(1)$。

### 解决难点
- **状态爆炸**：通过有效点压缩将状态数从 $10^{10}$ 级降至 $10^6$ 级
- **方向同步**：通过反向建图保证两球同步移动方向
- **预处理复杂度**：通过递推式预处理（如 `t[i][j][k] = t[i-1][j][k]`）实现 $O(n^2)$ 预处理

---

## 【题解评分（≥4星）】
1. **water_tomato（5星）**  
   - 代码结构清晰，预处理与BFS实现简洁  
   - 关键逻辑注释完整，可读性强  
   - 使用分层预处理实现方向移动压缩

2. **Lynkcat（4.5星）**  
   - 多源BFS思路描述透彻  
   - 详细分析状态压缩的数学基础  
   - 代码略复杂但逻辑严谨

3. **Star_Cried（4星）**  
   - 极简代码风格（仅87行）  
   - 使用链式前向星优化空间  
   - 预处理与查询分离明确

---

## 【最优思路提炼】
1. **有效点压缩**  
   仅保留障碍物相邻点，编号为 $1 \sim cnt$。例如：  
   ```cpp
   if (a[i-1][j] || a[i+1][j] || ...) id[i][j] = ++tot;
   ```

2. **反向状态转移**  
   建立反图使得BFS可从终点状态扩展：
   ```cpp
   add(t[i][j][k], id[i][j], k); // 终点→起点建边
   ```

3. **四方向预计算**  
   查询时直接取四个方向的最优解：
   ```cpp
   min(dis[t[x1][y1][0]][t[x2][y2][0]], ..., dis[...][3])
   ```

---

## 【同类型题目推荐】
1. **P1443 马的遍历**（BFS基础应用）  
2. **P1606 [USACO07DEC]Lilypad Pond**（预处理+BFS）  
3. **P3958 奶酪**（三维空间BFS与状态压缩）

---

## 【可视化算法设计】
### 核心动画方案
```html
<div id="canvas-container">
  <canvas id="grid"></canvas>
  <div id="control">
    <button onclick="prevStep()">←</button>
    <button onclick="togglePlay()">▶/❚❚</button>
    <button onclick="nextStep()">→</button>
  </div>
</div>
```
```javascript
// 示例：BFS状态扩展动画
function visualizeBFS() {
  let steps = [[(s1, s2), ...]]; // 预存BFS步骤
  let currentStep = 0;
  
  function drawStep(step) {
    // 高亮当前状态（红色）
    ctx.fillStyle = '#FF5555';
    ctx.fillRect(u_x*CELL_SIZE, u_y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
    
    // 绘制转移边（蓝色箭头）
    ctx.beginPath();
    ctx.moveTo(from_x, from_y);
    ctx.lineTo(to_x, to_y);
    ctx.strokeStyle = '#55AAFF';
    ctx.stroke();
  }
}
```

### 复古像素风格
- **调色板**：8位色（#000000, #5555FF, #FF5555, #55FF55）  
- **音效**：  
  - 移动时：8-bit "blip" 音效（Web Audio API生成）  
  - 找到解时：上升琶音效  
- **AI演示**：自动播放BFS扩展过程，速度可调（50ms~2s/步）

---

## 【核心代码实现】
### 预处理方向移动
```cpp
// 预处理每个点四个方向的终点
for(int i=1; i<=n; i++)
  for(int j=1; j<=n; j++) 
    t[i][j][0] = a[i][j-1] ? id[i][j] : t[i][j-1][0];

for(int i=n; i>=1; i--)
  for(int j=n; j>=1; j--)
    t[i][j][2] = a[i][j+1] ? id[i][j] : t[i][j+1][2];
```

### 多源BFS预处理
```cpp
queue<pair<int, int>> q;
for(int i=1; i<=tot; i++) {
  q.push({i, i});
  dis[i][i] = 1;
}

while(!q.empty()) {
  auto [x, y] = q.front(); q.pop();
  for(int k=0; k<4; k++) {
    for(int u : G[x][k]) 
      for(int v : G[y][k])
        if(dis[u][v] > dis[x][y]+1) {
          dis[u][v] = dis[x][y]+1;
          q.push({u, v});
        }
  }
}
```

### 查询处理
```cpp
int ans = min(
  dis[t[x1][y1][0]][t[x2][y2][0]],
  dis[t[x1][y1][1]][t[x2][y2][1]],
  // ... 其他方向
);
```

---

## 【调试心得分录】
> "预处理方向时，最初未考虑边界条件导致死循环，通过添加障碍物虚拟边框解决。" —— water_tomato

> "反向建图时曾误将边方向颠倒，通过单步跟踪队列扩展顺序发现并修正。" —— Lynkcat

---

通过上述分析与实现，该问题被高效转化为图论最短路径问题，通过巧妙的预处理与状态压缩，在时间和空间复杂度上均达到最优。

---
处理用时：90.24秒
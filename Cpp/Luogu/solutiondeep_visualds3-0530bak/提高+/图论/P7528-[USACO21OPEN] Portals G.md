# 题目信息

# [USACO21OPEN] Portals G

## 题目描述

Bessie 位于一个由 $N$ 个编号为 $1\dots N$ 的结点以及 $2N$ 个编号为 $1\cdots 2N$ 的传送门所组成的网络中。每个传送门连接两个不同的结点 $u$ 和 $v$（$u≠v$）。可能有多个传送门连接同一对结点。

每个结点 $v$ 与四个不同的传送门相连。与 $v$ 相连的传送门列表由 $p_v=[p_{v,1},p_{v,2},p_{v,3},p_{v,4}]$ 给出。

你的当前位置可以用有序对（当前结点，当前传送门）表示；即一个有序对 $(v,p_{v,i})$
，其中 $1\le v\le N$ 以及 $1\le i\le 4$。你可以使用以下任一操作来改变你的当前位置：

- 1. 由穿过当前传送门来改变当前结点。
- 2. 改变当前传送门。在每一个结点上，列表的前两个传送门是配对的，后两个传送门也是配对的。也就是说，如果你的当前位置是 $(v,p_{v,2})$，你可以转而使用传送门 $(v,p_{v,1})$，反之亦然。类似地，如果你的当前位置是 $(v,p_{v,3})$，你可以转而使用传送门 $(v,p_{v,4})$，反之亦然。没有其他改变传送门的方式（例如，你**不能**从传送门 $p_{v,2}$ 转去传送门 $p_{v,4}$ ）。

总共有 $4N$ 个不同的位置。不幸的是，并不一定每一个位置都可以从另外的每一个位置经过一系列操作而到达。所以，以 $c_v$ 哞尼的代价，你可以以任意顺序重新排列与 $v$ 相邻的传送门列表。在此之后，列表中的前两个传送门互相配对，同时后两个传送门也互相配对。

例如，如果你将与 $v$ 相邻的传送门以 $[p_{v,3},p_{v,1},p_{v,2},p_{v,4}]$ 的顺序重新排列，这意味着如果你位于结点 $v$ ，
- 如果你当前位于传送门 $p_{v,1}$ ，你可以转而使用传送门 $p_{v,3}$，反之亦然。
- 如果你当前位于传送门 $p_{v,2}$ ，你可以转而使用传送门 $p_{v,4}$，反之亦然。
你不再能够从传送门 $p_{v,1}$
转至传送门 $p_{v,2}$，或从传送门 $p_{v,3}$ 转至 $p_{v,4}$ ，反之亦然。

计算修改这一网络使得每一个位置都可以从另外的每一个位置到达所需要花费的哞尼的最小数量。输入保证存在至少一种修改网络的合法方式。 

## 说明/提示

#### 样例解释

重新排列结点 $1$ 和 $4$ 的邻接表就已足够。这需要总计 $c_1+c_4=13$ 哞尼。我们可以使 $p_1=[1,9,4,8]$ 以及 $p_4=[7,4,6,3]$。 

#### 数据范围与约定

$2\le N\le 10^5$，$1\le c_v\le 10^3$。

## 样例 #1

### 输入

```
5
10 1 4 8 9
11 1 2 5 6
12 9 10 2 3
3 4 3 6 7
15 10 8 7 5```

### 输出

```
13```

# AI分析结果



**唯一算法分类**  
Kruskal算法/最小生成树  

---

### **题解思路与算法要点**
1. **核心模型转换**  
   将每个传送门视为图中的一个节点，初始连接形成若干环。调整传送门顺序的操作等价于合并两个环，代价为 `c_v`。问题转化为：用最小代价连接所有环为一个连通块，即 **最小生成树**。

2. **关键实现步骤**  
   - **并查集初始化**：将初始传送门两两连接（前两门、后两门各自成环）。  
   - **权值排序**：按 `c_v` 从小到大排序所有节点。  
   - **贪心合并**：遍历排序后的节点，若其关联的两个环未被合并，则选择该节点调整顺序，累计代价。  

3. **解决难点**  
   - 正确建模传送门连接关系，将环抽象为连通块。  
   - 通过并查集快速判断环的合并状态，确保时间复杂度为 `O(N log N)`。  

---

### **题解评分 (≥4星)**
1. **lyfqwq 题解（5星）**  
   - **亮点**：代码简洁，注释清晰，通过 `un(p[i][0], p[i][1])` 直接处理初始环，Kruskal逻辑直观。  
   - **优化**：路径压缩与按秩合并提升效率，适合 `N=1e5` 规模。  

2. **7KByte 题解（5星）**  
   - **亮点**：将问题直接抽象为最小生成树，代码极简（仅需排序+并查集），逻辑直击核心。  
   - **关键代码段**：  
     ```cpp  
     rep(i,1,n) {  
         a[i].val=val[i];  
         a[i].x=get(u[i]);  
         a[i].y=get(x[i]);  
     }  
     ```  

3. **tiger2005 题解（4星）**  
   - **亮点**：详细图解调整操作如何合并环，通过复古像素风格辅助理解。  
   - **改进点**：代码可读性稍弱，但核心逻辑正确。  

---

### **最优思路提炼**
- **Kruskal 核心思想**：将环合并代价排序，贪心选择最小代价边。  
- **建模技巧**：每个节点的调整操作等价于一条连接两个环的边，权值为 `c_v`。  
- **代码优化**：路径压缩+按秩合并的并查集，时间复杂度严格线性对数。  

---

### **同类型题推荐**
1. **P3366 【模板】最小生成树**  
   （基础 Kruskal 实现）  
2. **P2872 [USACO07DEC]Building Roads S**  
   （坐标点最小生成树，需预处理边权）  
3. **P2330 [SCOI2005]繁忙的都市**  
   （最小生成树应用，求最大边权最小）  

---

### **代码核心实现**
```cpp
// 7KByte 题解核心片段
struct EDGE { int u, v, w; };
vector<EDGE> edges;

for (int i = 1; i <= n; ++i) {
    scanf("%d%d%d%d%d", &c, &a, &b, &c1, &d);
    edges.push_back({find(a), find(c1), c}); // a和c1所在环的合并边
}
sort(edges.begin(), edges.end());

int ans = 0;
for (auto &e : edges) {
    if (find(e.u) != find(e.v)) {
        unite(e.u, e.v);
        ans += e.w;
    }
}
```

---

### **可视化与算法演示**
**动画设计**：  
1. **初始状态**：以不同颜色表示各个环（连通块），传送门节点按初始连接成环。  
2. **合并过程**：  
   - 高亮当前最小 `c_v` 节点，展示其连接的两个环。  
   - 动态绘制合并后的环，播放“连接成功”音效（8-bit 上扬音调）。  
3. **交互功能**：  
   - **速度控制**：滑动条调节动画速度（0.5x~3x）。  
   - **单步执行**：手动触发每一步合并，观察并查集状态变化。  

**复古像素风格**：  
- **颜色方案**：使用 8 色调色板（红、蓝、绿等）区分不同连通块。  
- **Canvas 绘制**：环用像素点阵表示，合并时显示“像素扩散”动画。  
- **音效设计**：  
  - 合并时播放 `NES_Jump.mp3`（短促提示音）。  
  - 完成时播放 `NES_Victory.wav`（胜利旋律）。  

---

### **总结**
本题通过巧妙的模型转换，将看似复杂的传送门调整问题转化为经典的最小生成树问题。核心在于理解初始环的形成与合并操作的本质，结合并查集高效处理连通性。可视化设计通过动态环合并与复古元素，显著提升算法理解深度。

---
处理用时：85.76秒
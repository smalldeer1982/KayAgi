# 题目信息

# 「SWTR-7」Scores（hard version）

## 题目背景

#### 本题是 Scores 的 hard 版本。注意题目限制与 [easy](https://www.luogu.com.cn/problem/P7873) 版本不同。

#### 请注意特殊的时空限制。

## 题目描述

小 A 的班上有 $n$ 个学生。最近他们进行了一场考试，共有 $m$ 个学科。第 $i$ 个学生第 $j$ 门学科的得分为**整数** $s_{i,j}\ (0\leq s_{i,j}\leq 100)$。

同学们很重视自己在班上的排名，所以他们经常会比较自己和别的同学的分数。如果一个学生 $i$ **至少有一门学科**的分数比 $j$ **高**，ta 就会觉得自己不比 $j$ 差；相反，如果 ta **每门学科**的分数都比 $j$ **低**，ta 就会觉得自己被 $j$ 吊打了。

实际上，**上述两种情况并不是严格意义上相反的**。但是喜好八卦的小 A 打听到了每两个同学之间的分数情况，他惊讶地发现：**一个同学 $i$ 要么被 $j$ 吊打，要么不比 $j$ 差。** 同时，**如果 $i,j$ 被同一个人吊打，或同时吊打同一个人，则他们之间也有一方被另一方吊打**。我们用一个矩阵 $a_{i,j}\ (i\neq j)$ 来描述小 A 知道的同学们之间的分数关系：$a_{i,j}=0$ 表示 $i$ 被 $j$ 吊打；$a_{i,j}=1$ 表示 $i$ 不比 $j$ 差。

小 A 想知道这种情况会不会发生，即是否存在这样一张 $n\times m$ 的成绩表 $s$ 满足矩阵 $a$ 所描述的分数关系，从而确定有没有撒谎的同学。如果存在 $s$，请先输出 $\texttt{YES}$，再**任意**输出一种符合要求的成绩表；否则输出 $\texttt{NO}$。

注意：这里所求的 $s$ 所需满足的条件是 $a$ 的限制，而**不只是**小 A 所发现的性质，因为**他发现的性质已经在给出的 $a$ 中体现**。

## 说明/提示

**「Special Judge」**

**本题使用 Special Judge。请认真阅读输出格式，输出格式有误可能导致 UKE 或 WA。**

SPJ 首先会判断你的第一行输出是否与答案相同。  
如果相同且答案为 $\texttt{YES}$，则 SPJ 会判断你的输出是否符合所有限制。  
如果有解且你输出 $\texttt{YES}$，但给出方案错误，你将获得该测试点 $50\%$ 的分数。

你需要满足的限制如下：  
- $0\leq s_{i,j}\leq 100$。
- 对于任意 $i,j\ (i\neq j)$，若 $a_{i,j}=0$，则对于任意 $k\ (1\leq k\leq m)$，有 $s_{i,k}<s_{j,k}$；若 $a_{i,j}=1$，则存在一个 $k\in [1,m]$，使得 $s_{i,k}>s_{j,k}$。

你需要注意的是，所有输出都应严格符合输出格式。如果你对答案的存在性判断正确，但是输出方案时 $s_{i,j}<0$ 或 $s_{i,j}>100$，SPJ 会判定为 WA，得 $0$ 分，而不是 $50\%\ \times$ 该测试点分数。

**「数据范围与约定」**

本题共有 6 个测试点。

- Testcase #0（1 point）：是样例。
- Testcase #1（10 points）：$n=1$。
- Testcase #2（10 points）：$m=1$。
- Testcase #3（30 points）：$m=2$。
- Testcase #4（20 points）：$a_{i,j}=1\ (i\neq j)$。
- Testcase #5（29 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,m\leq 100$，$a_{i,j}\in\{0,1\}$，$T=50$（除 Testcase #0）。  
对于 $a$ 的限制：若 $a_{i,j}=a_{i,k}=0$，则 $a_{j,k}$ 和 $a_{k,j}$ 中至少有一个为 $0$；若 $a_{i,k}=a_{j,k}=0$，则 $a_{i,j}$ 和 $a_{j,i}$ 中至少有一个为 $0$。  
对于所有测试点，**时间限制 500ms，空间限制 16MB。**

**「题目来源」**

[Sweet Round 07](https://www.luogu.com.cn/contest/51773) A2。  
idea & solution & data：[Alex_Wei](https://www.luogu.com.cn/user/123294)；验题：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
5
5 3
0 1 1 1 1
1 0 1 1 1
1 1 0 1 1
1 1 1 0 1
1 1 1 1 0
2 7
0 1
0 0
5 4
0 1 1 0 1
0 0 0 0 1
0 1 0 0 1
1 1 1 0 1
1 1 1 1 0
3 1
0 1 1
1 0 1
1 1 0
3 2
0 1 0
0 0 1
1 0 0```

### 输出

```
YES
100 99 97
98 100 99
95 97 100
0 98 100
99 99 99
YES
98 100 94 98 72 53 53
97 99 93 97 71 52 52
YES
90 80 70 60
50 40 30 20
60 50 40 30
100 90 80 70
40 60 80 100
NO
NO```

# AI分析结果



## 算法分类选择  
图论、构造、拓扑排序  

---

## 题解思路、算法要点与解决难点  

### 核心思路  
题目要求构造满足特定传递关系的分数矩阵。核心分为两步：  
1. **合法性验证**：检查输入矩阵是否存在传递性矛盾（如 `A吊打B，B吊打C` 但 `A不吊打C`）。  
2. **构造分数矩阵**：  
   - 将学生分组，每组内部形成严格的全序关系。  
   - 利用多学科特性设计分数：前两科分别递减/递增，其他学科固定为满分，确保组间互不吊打。  

### 解决难点  
1. **分组处理**：通过并查集或拓扑排序将学生分组，确保组内全序。  
2. **分数构造**：  
   - 组间：前两科分数跨组留出足够间隔（如第一科递减，第二科递增）。  
   - 组内：根据排名分配分数差（如第一名最高，后续依次递减）。  
3. **边界处理**：  
   - `m=1` 时必须形成单链，否则无解。  
   - 分数必须严格在 [0, 100] 范围内。  

---

## 题解评分 (≥4星)  

### by_chance（⭐️⭐️⭐️⭐️⭐️）  
- **亮点**：  
  - 使用并查集分组，逻辑清晰。  
  - 构造分数时巧妙利用前两科差异确保组间关系。  
  - 代码结构简洁，处理多测试用例高效。  

### enucai（⭐️⭐️⭐️⭐️）  
- **亮点**：  
  - 强调链式结构，直观展示全序关系。  
  - 特殊处理 `m=1` 场景，代码注释详细。  

### intel_core（⭐️⭐️⭐️⭐️）  
- **亮点**：  
  - 引入拓扑排序验证合法性，思路独特。  
  - 分组后使用二元组构造分数，易于理解。  

---

## 最优思路或技巧提炼  

### 关键步骤  
1. **并查集分组**：  
   - 若 `a[i][j]=0`，将 `i` 和 `j` 合并到同一组。  
   - 每组内部形成全序链，确保传递性。  
2. **分数构造模板**：  
   ```cpp  
   ans[root][1] = sum + cnt[group];  // 第一科递减  
   ans[root][2] = 100 - sum;        // 第二科递增  
   ans[member][k] = ans[root][k] - rank;  // 组内按排名分配  
   ```  
3. **合法性检查**：  
   - 遍历所有三元组 `(i,j,k)`，检查传递性矛盾。  
   - 组内排名必须唯一，否则无解。  

---

## 同类型题与算法套路  

### 类似题目  
1. **构造全序关系**：  
   - 洛谷 P1966：通过交换相邻元素构造有序序列。  
2. **传递性验证**：  
   - 洛谷 P1347：拓扑排序判断全序关系。  
3. **多条件构造**：  
   - 洛谷 P1005：矩阵取数游戏中的分数构造。  

---

## 推荐题目  
1. **P1966** 火柴排队（排序与逆序对）  
2. **P1347** 排序（拓扑排序验证全序）  
3. **P1005** 矩阵取数游戏（动态规划与构造）  

---

## 个人心得摘录  

> **by_chance**：  
> “处理块时记录每一块的大小，确保组间分数间隔足够。若 `m=1` 且分组数>1，必然无解。”  
> **调试经验**：未正确处理块大小导致分数越界，需仔细计算累加值。  

> **enucai**：  
> “链式结构天然满足传递性，构造分数时要留出组间间隔，否则可能溢出 [0,100]。”  

---

## 可视化与算法演示  

### 动画设计  
1. **分块过程**：  
   - **颜色标记**：不同组用不同颜色方块表示。  
   - **动态合并**：通过并查集操作展示分组过程。  
2. **分数分配**：  
   - **步进演示**：第一科从高到低填充，第二科从低到高填充。  
   - **高亮当前操作**：红色标记正在分配的学生，绿色显示分数变化。  
3. **合法性检查**：  
   - **错误提示**：检测到传递矛盾时，闪烁冲突的三元组并播放失败音效。  

### 复古像素风格  
- **Canvas 绘制**：  
  - 学生用 8x8 像素方块表示，组间用不同色块区分。  
  - 分数值以数字形式显示在方块下方，颜色随分数变化（红→黄→绿）。  
- **音效设计**：  
  - **正确分配**：8-bit 上升音调。  
  - **错误提示**：短促蜂鸣声。  
  - **背景音乐**：循环播放《俄罗斯方块》风格旋律。  

### 交互控制  
- **暂停/继续**：观察分块和分数分配细节。  
- **单步执行**：手动触发分组或分数分配步骤。  

---

## 关键代码片段  

### 并查集分组与分数构造（by_chance）  
```cpp  
for (int i = 1; i <= n; i++) fa[i] = i;  
for (int i = 1; i <= n; i++)  
    for (int j = 1; j <= n; j++)  
        if (i != j && !a[i][j]) Union(i, j);  

int sum = 0;  
for (int group : groups) {  
    ans[root][1] = sum + group.size();  
    ans[root][2] = 100 - sum;  
    for (int member : group) {  
        ans[member][1] = ans[root][1] - rank[member];  
        ans[member][2] = ans[root][2] + rank[member];  
    }  
    sum += group.size();  
}  
```  

### 拓扑排序验证（intel_core）  
```cpp  
queue<int> q;  
for (int i = 1; i <= n; i++)  
    if (cnt[i] == 0) q.push(i);  
while (!q.empty()) {  
    int x = q.front(); q.pop();  
    for (int j = 1; j <= n; j++)  
        if (flag[j][x] && --cnt[j] == 0)  
            q.push(j);  
}  
```  

--- 

**答案生成完毕，请根据实际需求调整输出格式。**

---
处理用时：97.30秒
# 题目信息

# 「Wdoi-6」最澄澈的空与海

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/hiekh6t5.png)](https://thwiki.cc/%E5%8D%AF%E9%85%89%E4%B8%9C%E6%B5%B7%E9%81%93_%EF%BD%9E_Retrospective_53_minutes.)

广重号载着二人向东飞驰。毫无噪音，毫无摇摆，只是一个劲向东飞驰。在“万景幕”装置之下，尽管是全地下的卯酉东海道，乘客们也能饱览美丽的富士山和太平洋的景色。

但是，从这列卯酉新干线『广重』上看到的极富日本风味的美丽情景，对于梅莉来说，只不过是无趣的视觉刺激罢了。高动态范围的影像也好，极富日本风味的情景也好，都敌不过真正的天空的颜色。

身与华落，心将香飞。即便肉体会像花朵一样终有一天凋落，但心却可以如花香一般飘往远方。

「梅莉，你看，天上的星星呦。」

## 题目描述

### 简要题意

给定 $2n$ 个点、$m$ 条边的[二分图](http://oi-wiki.com/graph/bi-graph/#_1)（可能有重边），左部点与右部点个数相同，判断其完美匹配数量是否**恰好**为 $1$。是则输出 `Renko`，否则输出 `Merry`。

> **注**：完美匹配是指，从边集中选出 $n$ 条边，这些边的顶点组成的点集恰好覆盖了所有的 $2n$ 个点。

---
### 原始题意

在夜里，莲子与梅莉来到了东京的海边，躺在沙滩上，欣赏着澄澈的天空与大海，数起了天上的星星。

在这些星星之中，有 $n$ 个星星 $\{a_i\}$，是莲子先发现的，被称为莲子星；而又有 $n$ 个星星 $\{b_i\}$，是梅莉先发现的，被称为梅莉星。由于她们心有灵犀，这两批星星之间**不存在交集**。  

她们发现，有一些莲子星，与一些梅莉星之间恰好存在运动关系。具体而言，这些关系一共有 $m$ 组，每一组关系形如 $(u_i,v_i)$，也就是说第 $u_i$ 颗莲子星与第 $v_i$ 颗梅莉星之间存在运动关系。这些运动关系有可能重复。

这让莲子和梅莉非常好奇。作为专攻超统一物理学的女大学生，莲子认为，如果认为这些星星的运动是**和谐**的，那么她应当能够从这 $m$ 个运动关系中，找出若干个运动关系，使得**每颗**星星**都被**这些运动关系**包含**的同时，不会有一颗星星**被包含在两个**运动关系之中。

然而，梅莉认为，**和谐**的运动可能是不存在的，更何况即使莲子找到了**和谐**的运动，莲子也无法确保这种和谐运动的**唯一性**。两种和谐运动不同，当且仅当选取出的两组运动关系中，存在至少一个运动关系，是不相同的。

因为意见不合，她们于是打情骂俏了一顿。莲子于是记下了她们所看到了星星和她们之间的运动关系，并且找到了已经证明了 P=NP 的你，希望你能告诉她们，最后是谁正确呢？

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/6skoily9.png)

如图所示，存在唯一的方案：$\{1\to 1,2\to 5,3\to 2,4\to 3,5\to 4\}$。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \bm{m\le} & \textbf{\textsf{特殊性质}} & \textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 10 & 10 & - & - \cr\hline
2 & 20 & 300 & 4\times 10^4 & - & 1\cr\hline
3 & 20 & 10^5 & 5 \times 10^5 & \mathbf{A} & - \cr\hline
4 & 20 & 10^5 & 2 \times 10^5 & \mathbf{B} & - \cr\hline
5 & 30& 10^6 & 2\times 10^6 & - & 2,3,4 \cr\hline
\end{array}
$$

- 特殊性质 $\mathbf{A}$：保证对于第 $i$ 颗莲子星，与第 $i$ 颗梅莉星之间存在运动关系。
- 特殊性质 $\mathbf{B}$：保证 $m=2n-1$。

对于 $100\%$ 的数据，保证 $1 \le u_i,v_i\le n \le 10^6$，$1 \le m \le 2 \times 10^6$，$1 \leq T \leq 5$ 且对于每个测试点，$\sum m \leq 4 \times 10^6$。

对于 $\rm Subtask\ 5$，时间限制为 $3$ 秒。其它测试点时间限制为 $1$ 秒。

## 样例 #1

### 输入

```
1
5
6
1 1
1 3
3 2
2 5
4 3
5 4```

### 输出

```
Renko```

# AI分析结果



## 算法分类
**图论-拓扑排序应用**

---

## 题解思路与解决难点
### **核心思路**
所有题解均基于以下结论：**当且仅当二分图中存在唯一完美匹配时，必然存在度数为一的节点，且通过拓扑式删点后所有节点均被删除**。关键步骤如下：  
1. **度数统计**：统计每个节点的度数，若存在度数为0的节点直接判定无解。  
2. **拓扑删点**：用队列维护度数为一的节点，每次取出一个度数为一的节点，找到其唯一邻接点，将二者及其关联边删除。  
3. **更新度数**：删除边后更新相邻节点的度数，若新度数为一则继续入队。  
4. **最终判定**：若所有节点被删除，说明存在唯一解；否则存在多个解或无解。

### **解决难点**
1. **正确性证明**：需证明“唯一完美匹配必存在度数为一的节点”及“删点过程不影响解的存在性/唯一性”。  
2. **高效实现**：邻接表存储边，避免重复遍历；仅标记删除而非物理删除边，保证线性时间复杂度。  
3. **边界处理**：处理多组数据时的初始化问题，避免残留状态影响后续测试。

---

## 题解评分（≥4星）
### **1. retep（5星）**
- **亮点**：代码清晰，邻接表+队列高效处理，利用`del`数组标记删除状态。  
- **关键代码**：通过`while`循环迭代处理度数为一的节点，动态更新邻接点度数。  
- **代码片段**：  
  ```cpp
  queue<int> q;
  for(int i=1;i<=2*n;i++) if(in[i]==1) q.push(i);
  while(!q.empty()){
      int now = q.front(); q.pop();
      // 找到未删除的邻接点并处理
  }
  ```

### **2. Cocoly1990（4星）**
- **亮点**：反证法思路清晰，代码简洁，使用双向队列优化处理。  
- **关键代码**：通过`deque`处理节点，动态维护度数。  
- **代码片段**：  
  ```cpp
  deque<int> q;
  for(int i=1;i<=N;++i) if(deg[i]==1) q.push_back(i);
  ```

### **3. gyyyyx（4星）**
- **亮点**：代码结构紧凑，利用`vis`数组标记删除，避免重复访问。  
- **关键代码**：通过`vis`数组快速判断邻接点是否有效。  
- **代码片段**：  
  ```cpp
  if(vis[G[u][i]]) continue;
  ```

---

## 最优思路与技巧
### **关键技巧**
1. **拓扑式删点**：将度数为一的节点视为“必须匹配点”，通过队列动态处理。  
2. **邻接表优化**：仅维护度数变化而非删除边，保证线性时间复杂度。  
3. **对称处理**：同时处理左右部节点，避免重复代码。

### **代码实现核心**
```cpp
// 初始化队列并处理度数为一的节点
queue<int> q;
for (int i=1; i<=2*n; i++) {
    if (in[i] == 1) q.push(i);
}
int cnt = 0; // 统计已删除节点数
while (!q.empty()) {
    int u = q.front(); q.pop();
    if (del[u]) continue;
    del[u] = true; cnt++;
    int v = -1;
    // 找到u的唯一有效邻接点v
    for (int i=0; i<to[u].size(); i++) {
        if (!del[to[u][i]]) { v = to[u][i]; break; }
    }
    if (v == -1) continue;
    del[v] = true; cnt++;
    // 更新v的邻接点度数
    for (int i=0; i<to[v].size(); i++) {
        int w = to[v][i];
        if (!del[w] && --in[w] == 1) {
            q.push(w);
        }
    }
}
// 判定结果
if (cnt == 2*n) cout << "Renko\n";
else cout << "Merry\n";
```

---

## 相似题目推荐
1. **P3386 【模板】二分图匹配**  
   - **考察点**：基础二分图匹配算法（匈牙利/Dinic）。  
2. **P2764 最小路径覆盖问题**  
   - **考察点**：二分图建模与路径覆盖，需转化为最大匹配问题。  
3. **P2423 朋友圈**  
   - **考察点**：二分图性质与极大团问题，需结合图论与数学分析。

---

## 可视化与算法演示
### **核心动画设计**
1. **像素风格界面**：左右部分别用蓝色/红色方块表示，边用黄色线条连接。  
2. **当前操作高亮**：  
   - **度数为一节点**：闪烁绿色边框。  
   - **已删除节点**：变为灰色并打上“×”标记。  
3. **队列动态显示**：右侧面板显示当前队列中的节点，按入队顺序排列。  
4. **度数更新效果**：删除节点时，相邻节点的度数数字动态减少，若变为一则触发闪光特效。  

### **交互功能**
- **步进控制**：支持暂停/继续/单步执行，观察每一步的节点删除与度数变化。  
- **音效反馈**：  
  - **删除节点**：播放“哔”声效。  
  - **找到解**：播放胜利音效（8-bit风格）。  
- **自动演示**：点击“AI运行”后，算法自动执行，速度可调节（1x/2x/5x）。  

---

## 复古游戏化实现（伪代码）
```javascript
// Canvas初始化与网格绘制
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const NODE_SIZE = 20, EDGE_COLOR = '#FFFF00';

function drawNode(x, y, color, text) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, NODE_SIZE, NODE_SIZE);
    ctx.fillStyle = '#000';
    ctx.fillText(text, x + 5, y + 15);
}

function drawEdge(x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = EDGE_COLOR;
    ctx.stroke();
}

// 音效触发（Web Audio API）
function playBeep() {
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.1);
}
```

---
处理用时：86.50秒
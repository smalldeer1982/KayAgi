# 题目信息

# 「DROI」Round 2 单图

## 题目背景

与其编写苍白无力的背景，不如出更有质量的题。

## 题目描述

我们称[简单有向图](https://www.luogu.com.cn/paste/4oz6fep2) $G,H$ **本质相同**，当且仅当：

- 对于任意点对 $(u,v)$，若在图 $G$ 中从 $u$ 出发能走到 $v$，则在图 $H$ 中从 $u$ 出发能走到 $v$。反之若在图 $H$ 中从 $u$ 出发能走到 $v$，则在图 $G$ 中从 $u$ 出发也能走到 $v$。

若对于简单有向图 $G$，不存在其他简单有向图 $H$ 与其本质相同，则我们称图 $G$ 为 **单图**。

$T$ 次询问，每次询问给定一个正整数 $n$，请你回答 $n$ 个点的**有标号**单图数。

## 说明/提示

#### 数据范围

**「本题采用捆绑测试」** 

- $\operatorname{Subtask} 1(30\%)$：$T = 1$，$n \leq 5$。

- $\operatorname{Subtask} 2(50\%)$：$T \leq 10$。

- $\operatorname{Subtask} 3(20\%)$：无特殊限制。

对于 $100\%$ 的数据满足：$1 \leq T,n \leq 1000$，$1\leq mod \leq 10^9$。


#### 说明提示

这里给出一些例子来帮助理解单图的含义：

------------

![](https://cdn.luogu.com.cn/upload/image_hosting/kykl8fg8.png)[](https://www.luogu.com.cn/paste/0tbbkesd)

这是一张单图，可以证明不存在其他图与其本质相同。

------------

![](https://cdn.luogu.com.cn/upload/image_hosting/5appj8pr.png)

这不是一张单图，因为我们可以添加边 $(5,2)$ 构造出与其本质相同的图。

------------

![](https://cdn.luogu.com.cn/upload/image_hosting/wtsep329.png)

这不是一张单图，因为我们可以删去边 $(1,3)$ 构造出与其本质相同的图。



## 样例 #1

### 输入

```
5 998244353
1
3
5
12
888```

### 输出

```
1
16
986
328006912
535268381```

# AI分析结果



**唯一算法分类**：组合数学与动态规划

---

**题解思路、算法要点与解决难点**  
- **核心思路**：单图的结构需避免存在三点链式连接，因此每个点必须为出度/入度0或构成二元环。  
- **解决难点**：  
  1. **二元环处理**：需单独计算偶数点两两成环的方案，避免遗漏或重复。  
  2. **组合计数优化**：通过预处理组合数、快速幂、递推式降低时间复杂度。  
- **算法实现**：  
  - **预处理组合数**：杨辉三角递推生成C(n,k)。  
  - **动态规划预处理**：计算非二元环方案数时，枚举出度点数并累加组合项。  
  - **合并答案**：枚举可能的二元环数目，与非二元环方案相乘并累加。

---

**题解评分 (≥4星)**  
1. **Demeanor_Roy (5星)**：思路清晰，预处理与递推公式简洁，代码高效。  
2. **0000pnc (4星)**：详细图示辅助理解，分类明确，代码结构清晰。  
3. **Mine_King (4星)**：容斥原理巧妙处理孤立点，代码简洁易读。

---

**最优思路或技巧提炼**  
- **二元环独立处理**：利用配对乘积公式快速计算二元环方案数。  
- **出/入度点组合枚举**：非二元环部分拆分为出度点集合与入度点集合，组合计数优化为多项式求和。  
- **预处理加速**：提前计算组合数、幂次、阶乘等，避免重复计算。

---

**同类型题或类似算法套路**  
- **组合图计数**：如强连通分量计数、DAG计数，常需分类讨论结构并组合累加。  
- **容斥与分治**：复杂约束下拆解为独立子问题，分步求解后合并结果。

---

**推荐相似题目**  
1. P6789 寒妖王（图论计数与动态规划）  
2. P3773 射命丸文的笔记（生成函数与组合数）  
3. P4229 某位歌姬的故事（容斥与分治策略）

---

**个人心得摘录**  
- **Demeanor_Roy**：两点环必须完全独立，否则会破坏传递闭包的唯一性。  
- **0000pnc**：图示法辅助理解二元环与出/入度点的结构差异，减少思维盲区。  
- **Mine_King**：容斥处理孤立点时需注意符号，避免方向混淆。

---

**可视化与算法演示**  
- **动画设计**：  
  1. **二元环配对**：以像素方块表示节点，每次随机选取两个未配对节点高亮为红色，形成环后标记为绿色。  
  2. **出/入度划分**：将剩余节点分为蓝（出度）、黄（入度）两区域，动态显示连边生成过程（蓝色方块发射箭头至黄色区域）。  
- **复古风格**：  
  - **8位音效**：配对成功时播放短促“哔”声，连边生成时伴随“滴答”音效。  
  - **Canvas 绘制**：网格布局节点，配以低分辨率像素字体显示计数公式。  
- **交互控制**：支持暂停观察当前组合状态，调整动画速度观察分步细节。

---

**代码核心实现**  
```cpp
// 预处理组合数与二元环方案
void init() {
    C[0][0] = 1;
    for (int i = 1; i <= 1000; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++) 
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;
    }
    // 二元环递推: g[2k] = (2k-1) * g[2k-2]
    g[0] = 1;
    for (int i = 2; i <= 1000; i += 2) 
        g[i] = g[i-2] * (i-1) % mod;
    // 非二元环方案
    for (int n = 0; n <= 1000; n++) {
        for (int i = 0; i <= n; i++) {
            int pow_val = qpow(2, n - i) - 1; // 快速幂预处理
            f[n] = (f[n] + C[n][i] * qpow(pow_val, i)) % mod;
        }
    }
}
// 合并答案
int solve(int n) {
    int res = 0;
    for (int i = 0; i <= n; i += 2) 
        res = (res + C[n][i] * g[i] % mod * f[n-i]) % mod;
    return res;
}
```

---

**可视化代码片段（Canvas动画）**  
```javascript
// 二元环配对动画
function drawPairing(n) {
    let nodes = Array(n).fill(0).map((_,i) => i); // 未配对节点
    while (nodes.length >= 2) {
        let a = nodes.shift(), b = nodes.pop();
        // 高亮a、b为红色，绘制双向箭头
        drawNode(a, 'red'); 
        drawNode(b, 'red');
        drawArrow(a, b); 
        drawArrow(b, a);
        playSound('beep'); // 播放音效
    }
}
```

---
处理用时：82.04秒
# 题目信息

# 楼房

## 题目描述

地平线（$x$ 轴）上有 $n$ 个楼房，每个楼房可以表示为一个矩形。

用三个整数 $h_i,l_i,r_i$ 来表示第 $i$ 个矩形：矩形左下角为 $(l_i,0)$，右上角为 $(r_i,h_i)$。

地平线高度为 $0$。在轮廓线长度最小的前提下，从左到右输出轮廓线。

## 说明/提示

样例二如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/pmf4pzif.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/5ec8sxwi.png)

数据范围:

对于 $30\%$ 的数据，$n\le100$。

对于另外 $30\%$ 的数据，$1\le h_i,l_i,r_i\le 1000$。

对于 $100\%$ 的数据，$1\le n\le10^5$，$1\le h_i\le 10^9$，$-10^9\le l_i<r_i\le10^9$。

## 样例 #1

### 输入

```
2
3 0 2
4 1 3
```

### 输出

```
6
0 0
0 3
1 3
1 4
3 4
3 0```

## 样例 #2

### 输入

```
5
3 -3 0
2 -1 1
4 2 4
2 3 7
3 6 8```

### 输出

```
14
-3 0
-3 3
0 3
0 2
1 2
1 0
2 0
2 4
4 4
4 2
6 2
6 3
8 3
8 0```

# AI分析结果



## 算法分类
扫描线算法

## 综合分析与结论
题目要求计算多个矩形楼房形成的最小轮廓线，核心在于处理高度变化点。主要思路为将楼房左右边界作为事件点排序，动态维护当前最大高度，记录高度变化的转折点。扫描线算法通过事件点排序和高效数据结构（如堆、线段树）维护当前高度，是最高效且直观的解法。

**核心算法流程**：  
1. **事件点排序**：将每个楼房的左右边转化为事件点（x坐标、高度、入/出标记），按x从小到大排序，x相同时优先处理入边且更高者。  
2. **维护当前最大高度**：使用最大堆/multiset记录当前覆盖的楼房高度，入边时插入高度，出边时删除。  
3. **检测高度变化**：每次事件处理后若当前最大高度变化，则记录两个转折点（x坐标，旧高度→新高度）。  

**可视化设计思路**：  
- **横向时间轴**：动画以x轴为时间轴，逐步右移扫描线，高亮当前处理的事件点。  
- **堆结构可视化**：右侧面板实时显示堆内高度，用不同颜色区分插入/删除操作。  
- **轮廓绘制**：底部画布动态绘制已确定的轮廓线段，转折点用闪烁红点标记。  
- **音效反馈**：插入时播放上升音效，删除时下降音效，高度变化时触发“叮”声。  

## 题解清单 (≥4星)
1. **shuri001（4.5星）**  
   使用扫描线+multiset，事件处理逻辑清晰。关键点在于入边时比较当前堆顶，出边时判断是否移除唯一最大值。代码简洁，处理相同x坐标事件的排序规则严谨。

2. **Flanksy（4星）**  
   并查集优化区间染色，按高度降序处理，跳过已覆盖区间。突破传统思维，时间复杂度接近线性，适合大数据。离散化后通过并查集快速定位未覆盖区间。

3. **George1123（4星）**  
   二叉堆管理事件点，自定义排序规则解决边界重叠问题。用两个堆分别存活跃和待删除高度，确保堆顶始终有效。代码中事件合并处理逻辑值得借鉴。

## 最优思路与技巧
**关键技巧**：  
1. **事件点排序规则**：x相同时入边优先，且更高入边先处理（避免低楼遮挡）。  
2. **延迟删除堆**：用辅助堆记录待删除高度，仅在堆顶匹配时执行删除，保证堆操作高效。  
3. **离散化优化**：线段树解法中将坐标离散化为区间端点，减少无效查询。  

## 同类题目推荐
1. P1904 天际线（扫描线基础）  
2. P5490 【模板】扫描线（矩形面积并）  
3. P1856 [USACO5.5]矩形周长（周长统计）  

## 核心代码实现（shuri001题解）
```cpp
struct line{ int up, x, k; };
multiset<int> s;
int cmp(line i, line j){
    if(i.x != j.x) return i.x < j.x;
    if(i.k != j.k) return i.k < j.k; // 入边优先
    return i.k == 1 ? i.up > j.up : i.up < j.up;
}

for(int i=1; i<=cnt; i++){
    int mx = *s.rbegin();
    if(l[i].k == 1){ // 入边
        if(l[i].up > mx){
            ans[num++] = {l[i].x, mx};
            ans[num++] = {l[i].x, l[i].up};
            s.insert(l[i].up);
        } else s.insert(l[i].up);
    } else { // 出边
        if(l[i].up == mx && s.count(mx) == 1){
            s.erase(mx);
            ans[num++] = {l[i].x, mx};
            ans[num++] = {l[i].x, *s.rbegin()};
        } else s.erase(s.find(l[i].up));
    }
}
```

## 可视化与动画设计
**8位像素风格实现**：  
1. **Canvas布局**：横向滚动背景，楼房用不同颜色方块堆叠，当前扫描线为垂直绿线。  
2. **堆可视化**：右侧用竖条表示堆内高度，实时更新，删除元素时添加闪烁效果。  
3. **音效触发**：Web Audio API播放音效，如插入时"beep1.wav"，删除时"beep2.wav"。  

**自动演示模式**：  
```javascript
function autoPlay() {
    if(eventIndex >= events.length) return;
    let e = events[eventIndex++];
    highlightEvent(e); // 高亮当前事件点
    updateHeap(e);    // 更新堆显示
    drawContour(e.x); // 绘制轮廓
    setTimeout(autoPlay, speed);
}
```

**交互功能**：  
- 速度滑块：调节动画步进速度。  
- 暂停/继续：控制动画流程。  
- 单步执行：点击事件点手动触发处理。  

通过复古风格与交互设计，将算法过程转化为动态游戏，提升理解与记忆。

---
处理用时：80.59秒
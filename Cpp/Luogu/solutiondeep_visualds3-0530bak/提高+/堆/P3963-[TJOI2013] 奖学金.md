# 题目信息

# [TJOI2013] 奖学金

## 题目背景

小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。

## 题目描述

小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  
要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。


## 说明/提示

### 样例 1 解释

选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^3$，$c \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $3 \leq n  \leq 10^5$，$n \leq c \leq 2 \times 10^5$，$0 \leq f \leq 2\times 10^9$，$0 \leq a_i \leq 2 \times 10^9$，$0 \leq b_i \leq 10^5$。

## 样例 #1

### 输入

```
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出

```
35```

## 样例 #2

### 输入

```
5 6 9
4 0
4 1
6 3
8 0
10 4
10 5
```

### 输出

```
6```

# AI分析结果



# 算法分类
**排序、堆（优先队列）**

---

# 题解思路与解决难点

## 核心思路
1. **排序预处理**：将学生按成绩升序排列，便于后续枚举中位数。
2. **堆维护最小值**：用大根堆动态维护前/后k小奖学金的和。
3. **双预处理数组**：
   - **f[i]**：前i-1个学生中选k个的最小奖学金和。
   - **g[i]**：后i+1个学生中选k个的最小奖学金和。
4. **逆序枚举中位数**：从成绩高往低遍历，第一个满足 `f[i] + g[i] + b[i] ≤ F` 的即为答案。

## 解决难点
1. **动态维护k小值**：堆中始终保持前k小的元素，当新元素比堆顶小则替换。
2. **逆向预处理**：右侧数组需要从后往前处理堆的逻辑。
3. **边界处理**：确保枚举的中位数位置左右至少有k个元素。

---

# 题解评分（≥4星）

1. **胖头鱼学员（5星）**
   - **亮点**：代码简洁高效，堆预处理清晰，逆序枚举优化。
   - **代码可读性**：变量命名规范，逻辑分层明确。
   - **优化点**：双预处理数组直接存储结果，避免重复计算。

2. **ycyaw（4.5星）**
   - **亮点**：完整注释和堆操作封装，适合教学。
   - **优化点**：预处理时直接处理到边界，避免无效判断。

3. **ix35（4星）**
   - **亮点**：权值线段树实现，提供不同视角。
   - **不足**：代码复杂度较高，适用性稍逊于堆解法。

---

# 最优思路与技巧

## 关键技巧
1. **大根堆贪心**：维护堆大小为k，堆顶为当前最大元素，新元素更小则替换。
2. **双指针预处理**：分别从左到右和从右到左扫描，生成两个最小值数组。
3. **逆序剪枝**：一旦找到合法中位数立即返回，避免冗余计算。

## 代码片段（核心逻辑）
```cpp
// 预处理左边数组 f[]
priority_queue<int> q;
for (int i=1; i<=c; i++) {
    if (i <= k) {
        q.push(b[i]);
        sum += b[i];
        f[i] = sum;
    } else {
        if (b[i] < q.top()) {
            sum += b[i] - q.top();
            q.pop();
            q.push(b[i]);
        }
        f[i] = sum;
    }
}

// 预处理右边数组 g[]
priority_queue<int> q;
for (int i=c; i>=1; i--) {
    if (i >= c-k+1) {
        q.push(b[i]);
        sum += b[i];
        g[i] = sum;
    } else {
        if (b[i] < q.top()) {
            sum += b[i] - q.top();
            q.pop();
            q.push(b[i]);
        }
        g[i] = sum;
    }
}

// 逆序枚举中位数
for (int i=c-k; i>=k+1; i--) {
    if (f[i-1] + g[i+1] + b[i] <= F) {
        return a[i]; // 成绩数组
    }
}
```

---

# 同类题目推荐
1. **P1801 黑匣子**  
   - 动态维护第k小值，堆的经典应用。
2. **P1168 中位数**  
   - 动态维护中位数，堆或平衡树实现。
3. **P3871 中位数**  
   - 扩展版中位数问题，需结合堆与删除操作。

---

# 可视化设计

## 动画方案
1. **堆操作动态化**：  
   - **高亮**：当前元素与堆顶比较，若更小则替换。
   - **颜色标记**：堆顶红色，新元素绿色，替换过程黄色。
2. **数组遍历**：  
   - **步进显示**：枚举中位数时，左右预处理数组的值动态显示。
   - **状态面板**：显示当前总和与约束条件判断结果。

## 复古像素风格
- **Canvas网格**：学生成绩以像素条显示，堆操作通过方块升降表现。
- **音效触发**：元素入堆时播放“哔”声，替换堆顶时播放“咔嚓”声。
- **自动演示**：按成绩从高到低自动枚举，找到解时播放胜利音效。

---

# 总结
本题通过排序和堆的巧妙结合，将复杂的中位数问题转化为动态最小值维护问题。堆的高效性使得算法在时间和空间上均达到最优，逆序枚举进一步优化了实际运行效率。可视化设计中，堆的动态替换和中位数枚举过程的直观展示，能有效帮助理解算法核心。

---
处理用时：76.56秒
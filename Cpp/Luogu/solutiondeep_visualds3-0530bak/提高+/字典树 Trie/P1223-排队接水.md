# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



**唯一算法分类**: 贪心算法

---

### **题解思路、算法要点与解决难点**
1. **核心推导**  
   - 数学证明：通过交换相邻元素证明短作业优先（SJF）策略最优。若存在 `a < b`，将 `a` 排在前面时总等待时间 `a*2 + b` 必然小于 `b*2 + a`，故全局最优解需要按升序排列接水时间。

2. **数据结构与实现**  
   - **结构体/数组存储**：多数题解使用结构体或数组保存接水时间与原始序号，通过排序后输出序号。
   - **数值技巧**：如题解2将时间 `t_i` 乘以大数（1001）并加上序号，排序后取模分离序号，避免结构体。
   - **等待时间计算**：总时间公式为 `sum += t_sorted[i] * (n-i-1)`，即每个时间点影响后续所有人。

3. **难点对比**  
   - **序号保留**：需在排序后正确输出原始序号，不同题解通过结构体成员、数值编码或并行数组实现。
   - **精度处理**：总时间需用 `double` 避免溢出或截断，部分题解因使用 `int` 导致WA。

---

### **题解评分 (≥4星)**
1. **无乐鸦 (5星)**  
   - **亮点**：纯数学推导证明贪心策略，深入本质，适合教学。
2. **f112358 (4星)**  
   - **亮点**：数值技巧高效处理序号，代码简洁，时间复杂度低。
3. **BlueArc (4星)**  
   - **亮点**：结构体+自定义排序，可读性强，适合新手理解。

---

### **最优思路或技巧提炼**
1. **贪心策略**：接水时间升序排列，数学证明确保全局最优。
2. **序号保留技巧**：数值编码（`t*1001 + i`）或结构体存储。
3. **高效排序**：利用 `std::sort` 或手写快排，时间复杂度 `O(n log n)`。

---

### **同类型题与算法套路**
- **通用解法**：调度问题中，若需最小化总等待时间，优先处理耗时短的任务。
- **类似题目**：  
  1. 洛谷 P1090（合并果子，贪心+优先队列）  
  2. 洛谷 P1803（线段覆盖，按右端点排序）  
  3. 洛谷 P2240（部分背包问题，性价比贪心）

---

### **可视化与算法演示**
**动画设计**：  
1. **像素风格界面**：  
   - **数据结构**：用8-bit像素方块表示排队的人，颜色深浅表示接水时间（深色=时间长）。  
   - **排序过程**：展示冒泡排序或快速排序的交换步骤，高亮当前比较的元素。  
   - **等待时间累加**：右侧面板动态显示总时间公式 `sum += t[i] * (n-i-1)`。

2. **交互功能**：  
   - **步进控制**：允许单步执行排序和等待时间计算。  
   - **音效**：排序交换时播放“哔”声，计算总时间时播放金币音效。

3. **Canvas 演示**：  
   ```javascript
   // 示例代码：绘制接水队列
   function drawQueue(times) {
     ctx.clearRect(0, 0, canvas.width, canvas.height);
     times.forEach((t, i) => {
       ctx.fillStyle = `hsl(${200 - t % 200}, 70%, 50%)`; // 颜色编码时间
       ctx.fillRect(i * 30, 100, 25, t / 5); // 高度表示时间
     });
   }
   ```

---

### **个人心得摘录**
- **精度陷阱**：多个题解强调必须用 `double` 存储总时间，`float` 会因精度不足WA。
- **重复元素处理**：若接水时间相同，需按原始序号排序，否则输出顺序错误。

---

### **核心代码实现**
```cpp
// 题解2的核心代码（f112358）
#include <algorithm>
using namespace std;
long long t[1001]; // 时间编码为 t*1001 + i

int main() {
    int n, x;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> x;
        t[i] = x * 1001LL + i; // 编码时间和序号
    }
    sort(t + 1, t + n + 1);
    for (int j = 1; j <= n; j++) {
        cout << t[j] % 1001 << " "; // 取模得序号
        sum += (t[j] / 1001) * (n - j); // 计算总时间
    }
    printf("%.2lf\n", sum * 1.0 / n);
}
```

---
处理用时：60.56秒
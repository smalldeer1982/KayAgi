# 题目信息

# [USACO12DEC] First! G

## 题目描述

Bessie 一直在研究字符串。她发现，通过改变字母表的顺序，她可以按改变后的字母表来排列字符串（字典序大小排列）。

例如，Bessie 发现，对于字符串 $\texttt{omm},\texttt{moo},\texttt{mom}$ 和 $\texttt{ommnom}$，她可以使用标准字母表使 $\texttt{mom}$ 排在第一个（即字典序最小），她也可以使用字母表 $\texttt{abcdefghijklonmpqrstuvwxyz}$ 使得 $\texttt{omm}$ 排在第一个。然而，Bessie 想不出任何方法（改变字母表顺序）使得 $\texttt{moo}$ 或 $\texttt{ommnom}$ 排在第一个。

接下来让我们通过重新排列字母表的顺序来计算输入中有哪些字符串可以排在第一个（即字典序最小），从而帮助 Bessie。

要计算字符串 $X$ 和字符串 $Y$ 按照重新排列过的字母表顺序来排列的顺序，先找到它们第一个不同的字母 $X_i$ 与 $Y_i$，按重排后的字母表顺序比较，若 $X_i$ 比 $Y_i$ 先，则 $X$ 的字典序比 $Y$ 小，即 $X$ 排在 $Y$ 前；若没有不同的字母，则比较 $X$ 与 $Y$ 长度，若 $X$ 比 $Y$ 短，则 $X$ 的字典序比 $Y$ 小，即 $X$ 排在 $Y$ 前。

## 说明/提示

样例即题目描述中给出的例子，只有 $\texttt{omm}$ 和 $\texttt{mom}$ 在各自特定的字典序下可以被排列在第一个。

## 样例 #1

### 输入

```
4
omm
moo
mom
ommnom
```

### 输出

```
2
omm
mom
```

# AI分析结果



# **算法分类选择**  
**Trie树 + 拓扑排序**

---

## **题解思路、算法要点与解决难点**

### **核心思路**
- **Trie树构建**：将所有字符串插入Trie树，便于快速比较前缀关系和同一层的字符约束。
- **拓扑排序检查环**：对每个字符串，在Trie树路径上逐层添加字符间的有向边（如字符`a`需比同层其他字符优先级高），用拓扑排序判断是否存在合法字母表顺序（无环）。
- **前缀检查**：若某字符串是其他字符串的前缀，则无法成为字典序最小。

### **解决难点**
1. **如何高效建立字符约束关系**：通过Trie树同一层的兄弟节点，自动生成字符间的优先级关系（有向边）。
2. **环的检测**：拓扑排序的时间复杂度为`O(26)`，确保算法整体高效（总复杂度`O(26m)`，`m`为字符串总长度）。
3. **前缀处理**：在遍历Trie树时，若当前路径已存在结束标记（即某字符串是当前字符串的前缀），直接判定无解。

---

## **题解评分 (≥4星)**

### 1. Heartlessly 题解（⭐️⭐️⭐️⭐️⭐️）
- **亮点**：代码简洁，注释清晰，通过`ed`数组标记字符串结束符，正确处理前缀问题。
- **关键代码**：
  ```cpp
  bool find(string x) {
      int u = 1, len = x.size();
      memset(e, 0, sizeof(e)); // 重置边和入度
      memset(in, 0, sizeof(in));
      for (int i = 0; i < len; ++i) {
          if (ed[u]) return 0; // 前缀检查
          int v = x[i] - 'a';
          for (int j = 0; j < 26; ++j)
              if (v != j && ch[u][j]) e[v][j] = 1, ++in[j]; // 建立约束边
          u = ch[u][v];
      }
      topoSort(); // 拓扑排序
      for (int i = 0; i < 26; ++i) 
          if (in[i]) return 0; // 存在环则无解
      return 1;
  }
  ```

### 2. liuxu 题解（⭐️⭐️⭐️⭐️⭐️）
- **亮点**：邻接表实现拓扑排序，减少空间占用；代码中嵌入详细注释和示意图。
- **关键代码**：
  ```cpp
  void solve(string x) {
      // ... 遍历Trie树路径
      for (int j = 0; j < 26; j++) {
          if (ch[u][j] && j != t && !used[t][j]) {
              addedge(t, j); // 邻接表添加边
              ind[j]++;
          }
      }
  }
  ```

### 3. AZYDLL 题解（⭐️⭐️⭐️⭐️）
- **亮点**：使用`Trie[32][p]`标记结束符，代码中嵌入详细的错误处理逻辑。
- **关键代码**：
  ```cpp
  bool ask(int pt) {
      // ... 遍历Trie树路径
      for (int j = 0; j < 26; j++) 
          if (j != c && Trie[j][p]) edge[j][c] = 1; // 建立约束边
      return bfs(); // 拓扑排序检查环
  }
  ```

---

## **最优思路或技巧提炼**
1. **Trie树的逐层约束**：在Trie树的每一层中，当前字符需比同层其他字符优先级高，通过有向边表示。
2. **拓扑排序的轻量化实现**：仅需维护入度数组和队列，无需完整建图，时间复杂度稳定为`O(26)`。
3. **前缀快速判定**：在Trie节点中记录是否为某个字符串的结尾，遍历时提前终止无效分支。

---

## **同类型题与类似算法套路**
- **类似题目**：  
  1. [LeetCode 269. Alien Dictionary](https://leetcode.com/problems/alien-dictionary/)（外星人字典，拓扑排序应用）  
  2. [洛谷 P3065 [USACO12DEC]First! G](https://www.luogu.com.cn/problem/P3065)（原题）  
  3. [Codeforces 510C. Fox And Names](https://codeforces.com/problemset/problem/510/C)（字符串顺序约束）

---

## **个人心得摘录**
- **前缀检查的教训**：  
  > “如果遍历到某个节点时发现该节点是其他字符串的结尾，说明当前字符串是其他字符串的前缀，直接返回无解。” —— Heartlessly  
  （若不处理前缀，会导致错误答案，如`ab`和`abc`的情况）。

- **拓扑排序的优化**：  
  > “每次处理单个字符串时重置边和入度数组，而不是全局维护，减少空间占用。” —— liuxu

---

## **可视化与算法演示**
### **核心算法流程**
1. **Trie树构建动画**：  
   - 初始空白根节点，逐步插入字符串，用不同颜色标记路径。  
   - **高亮**：当前插入字符的节点位置，如插入`omm`时，根→`o`→`m`→`m`。  

2. **约束边建立与拓扑排序**：  
   - **步进控制**：逐层展示字符间的有向边（如`o`→`m`表示`o`优先级高于`m`）。  
   - **颜色标记**：当前处理的层用红色边框，队列中的节点用绿色背景。  
   - **环检测**：若最终存在未入队的节点，用闪烁红色提示环。  

### **复古游戏化设计**
- **像素风格**：  
  - Trie节点用16x16像素方块表示，字符用8位字体显示。  
  - 拓扑排序队列用像素箭头连接，背景音乐为8位芯片音乐。  
- **音效设计**：  
  - **插入字符**：短促“哔”声。  
  - **发现环**：低沉错误音效。  
  - **合法解**：胜利音效 + 像素烟花动画。  
- **AI自动演示**：  
  自动遍历所有字符串，用贪吃蛇式路径在Trie树上移动，右侧同步显示拓扑排序过程。

---

**推荐题目**：  
1. [洛谷 P2412 查单词](https://www.luogu.com.cn/problem/P2412)（Trie树应用）  
2. [LeetCode 444. Sequence Reconstruction](https://leetcode.com/problems/sequence-reconstruction/)（拓扑排序变种）  
3. [Codeforces 825E. Minimal Labels](https://codeforces.com/problemset/problem/825/E)（字典序拓扑排序）

---
处理用时：80.23秒
# 题目信息

# [GDCPC 2023] New but Nostalgic Problem

## 题目描述

给定 $n$ 个字符串 $w_1, w_2, \cdots, w_n$，请选出恰好 $k$ 个字符串，最小化字符串 $v$ 的字典序，并输出这个最优的字符串 $v$。其中 $v$ 满足以下条件：$v$ 是被选出的字符串中，某两个编号不同的字符串的最长公共前缀。而且，$v$ 是所有满足条件的字符串中，字典序最大的字符串。

更正式地，令 $\mathbb{S}$ 表示一个大小为 $k$ 的集合，集合中的元素均为从 $1$ 到 $n$ 的整数（含两端），且没有重复的元素。令 $\text{lcp}(w_i, w_j)$ 表示字符串 $w_i$ 和 $w_j$ 的最长公共前缀，您需要找到一个集合 $\mathbb{S}$ 以最小化下述字符串 $v$ 的字典序，并输出这个最优的字符串 $v$。

$$
v = \max\limits_{i \in \mathbb{S}, j \in \mathbb{S}, i \ne j} \text{lcp}(w_i, w_j)
$$

上式中的 $\max$ 通过字典序比较两个字符串。

请回忆：
- 称字符串 $p$ 是字符串 $s$ 的前缀，若可以在 $p$ 的末尾添加若干个字符（包括零个字符）将它变成 $s$。特别地，空字符串是任意字符串的前缀。
- 字符串 $s$ 和 $t$ 的最长公共前缀是一个最长的字符串 $p$，满足 $p$ 既是 $s$ 的前缀，又是 $t$ 的前缀。例如，``abcde`` 与``abcef`` 的最长公共前缀为 ``abc``，而 ``abcde`` 与 ``bcdef`` 的最长公共前缀为空字符串。
- 称字符串 $s$ 的字典序小于字符串 $t$（$s \ne t$），若
  - $s$ 是 $t$ 的前缀，或
  - $s_{|p| + 1} < t_{|p| + 1}$，其中 $p$ 为 $s$ 和 $t$ 的最长公共前缀，$|p|$ 为 $p$ 的长度，$s_i$ 表示字符串 $s$ 的第 $i$ 个字符，$t_i$ 表示字符串 $t$ 的第 $i$ 个字符。
- 特别地，空字符串是字典序最小的字符串。

## 样例 #1

### 输入

```
2
5 3
gdcpc
gdcpcpcp
suasua
suas
sususua
3 3
a
b
c```

### 输出

```
gdcpc
EMPTY```

# AI分析结果



## 算法分类
**Trie树**

---

## 题解思路与核心难点
### 核心思路
1. **Trie构建**：将所有字符串插入Trie，统计每个节点的经过次数（cnt）和以该节点为结尾的字符串数量（ed）。
2. **贪心逐位确定答案**：从根节点出发，按字典序尝试每个可能的字符分支。对于每个分支：
   - 计算选择该分支后，最多能选多少个字符串（包括当前分支的子节点只能选一个，其他分支的字符串全选）。
   - 若能满足选k个的条件，则确定该字符为答案的一部分，并深入下一层继续处理。
3. **边界处理**：若所有分支都无法满足条件，则答案为空字符串（EMPTY）。

### 解决难点
- **统计逻辑**：每个节点的分支需区分“全选”和“限选一个”，防止更大LCP出现。
- **字典序贪心**：按a~z顺序枚举字符，确保每一步选择字典序最小的可行解。
- **动态计算可选数**：通过`sum = ed[p] + sum(每个子节点是否至少有一个字符串)`快速判断是否满足k个选择。

---

## 题解评分
1. **OrangeRainee（4.5星）**  
   - **亮点**：代码简洁，用循环替代DFS，维护cnt和ed数组清晰。  
   - **优化**：插入时实时清空Trie节点，减少内存占用。  
2. **lfxxx（4星）**  
   - **亮点**：递归式DFS实现，逻辑分层明确，附带详细注释。  
   - **优化**：使用`sum`变量动态计算子节点贡献。  
3. **N0_1（4星）**  
   - **亮点**：代码结构清晰，注释详细，参考其他题解并优化实现。  

---

## 最优思路提炼
1. **Trie的统计设计**：每个节点记录经过次数和结尾次数，快速计算可选字符串数量。
2. **贪心逐层决策**：按字典序枚举字符，通过`sum >= k`判断是否可行，确保最小字典序。
3. **分支限选逻辑**：同一父节点下的不同分支最多选一个，避免更大LCP干扰结果。

---

## 类似题目推荐
1. [P3294 背单词](https://www.luogu.com.cn/problem/P3294)  
   （Trie树与贪心结合，最小化代价）  
2. [P3065 First!](https://www.luogu.com.cn/problem/P3065)  
   （Trie树判断字符串字典序关系）  
3. [P4683 Type Printer](https://www.luogu.com.cn/problem/P4683)  
   （Trie树优化打印操作，贪心选择路径）  

---

## 可视化设计
### 动画方案
1. **Trie树展示**：用Canvas绘制Trie结构，节点显示字符和统计值（cnt/ed）。
2. **逐层高亮**：当前访问的节点用黄色标记，已确定的路径用绿色连线。
3. **分支枚举**：枚举子节点时，显示每个分支的可选数目，红色表示不满足k，绿色表示满足。
4. **音效提示**：选中字符时播放“确认音效”，无法满足时播放“错误音效”。

### 复古像素风格
- **颜色方案**：16色调色板，节点用深蓝方块，字符用白色像素字体。
- **音效设计**：8-bit音效，如选择正确时播放上升音阶，错误时短促“哔”声。
- **自动演示**：按算法逻辑自动遍历分支，用户可暂停/调速观察细节。

---

## 核心代码（OrangeRainee实现）
```cpp
void add(char *s, int len) {
    int p = 1;
    ++cnt[p];
    for (int i = 1; i <= len; ++i) {
        int u = s[i] - 'a' + 1;
        if (!tr[p][u]) {
            tr[p][u] = ++tot;
            memset(tr[tot], 0, sizeof tr[tot]);
        }
        p = tr[p][u];
        ++cnt[p];
    }
    ++ed[p];
}

void sol() {
    while (1) {
        int sum = ed[p];
        for (int i = 1; i <= 26; ++i)
            if (cnt[tr[p][i]]) ++sum;
        if (sum >= k) { // 满足条件，输出答案
            if (p == 1) printf("EMPTY");
            return;
        }
        for (int i = 1; i <= 26; ++i) { // 按字典序尝试分支
            if (!cnt[tr[p][i]]) continue;
            sum += cnt[tr[p][i]] - 1;
            if (sum >= k) {
                putchar('a' + i - 1);
                p = tr[p][i]; // 进入下一层
                break;
            }
        }
    }
}
```

---
处理用时：69.12秒
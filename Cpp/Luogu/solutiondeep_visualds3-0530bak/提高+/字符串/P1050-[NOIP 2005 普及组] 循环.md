# 题目信息

# [NOIP 2005 普及组] 循环

## 题目描述

乐乐是一个聪明而又勤奋好学的孩子。他总喜欢探求事物的规律。一天，他突然对数的正整数次幂产生了兴趣。


众所周知，$2$ 的正整数次幂最后一位数总是不断的在重复 $2,4,8,6,2,4,8,6…$ 我们说 $2$ 的正整数次幂最后一位的循环长度是 $4$（实际上 $4$ 的倍数都可以说是循环长度，但我们只考虑最小的循环长度）。类似的，其余的数字的正整数次幂最后一位数也有类似的循环现象：

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c}\hline
\textbf{数字}& \textbf{循环} & \textbf{循环长度} \cr\hline\hline
2 & 2,4,8,6 & 4\cr\hline
3 & 3,9,7,1 & 4\cr\hline
4 & 4,6 & 2\cr\hline
5 & 5 &  1\cr\hline
6 & 6 & 1\cr\hline
7 & 7,9,3,1 & 4\cr\hline
8 & 8,4,2,6 & 4\cr\hline
9 & 9,1 & 2\cr\hline
\end{array}
$$

这时乐乐的问题就出来了：是不是只有最后一位才有这样的循环呢？对于一个整数 $n$ 的正整数次幂来说，它的后 $k$ 位是否会发生循环？如果循环的话，循环长度是多少呢？

注意：

1. 如果 $n$ 的某个正整数次幂的位数不足 $k$，那么不足的高位看做是 $0$。
2. 如果循环长度是 $L$，那么说明对于任意的正整数 $a$，$n$ 的 $a$ 次幂和 $a+L$ 次幂的最后 $k$ 位都相同。


## 说明/提示

**【数据范围】**

对于 $30 \%$ 的数据，满足 $k \le 4$；  
对于$100 \%$ 的数据，满足 $1 \le n < {10}^{100}$，$1 \le k \le 100$。

**【题目来源】**

NOIP 2005 普及组第四题

## 样例 #1

### 输入

```
32 2```

### 输出

```
4```

# AI分析结果



**唯一算法分类**：递推法/数学模运算

---

### **题解思路、算法要点与解决难点**

**核心思路**：逐位递推，利用后k位循环长度是前k-1位倍数的特性。每次处理一位时，最多尝试10次乘方，确定当前位的循环长度，逐步累积答案。

**算法要点**：  
1. **逐位递推**：从最后1位开始，依次扩展到k位，每一步的循环长度是前一步的倍数。  
2. **高精度优化**：只保留后k位进行模运算，避免全量计算。  
3. **终止条件**：若某一位无法在10次内找到循环，判定无解。

**解决难点**：  
- **高精度乘法的进位处理**：需高效截断高位，仅保留后k位。  
- **循环长度推导**：通过数学证明后k位的循环长度是前k-1位的倍数，减少无效枚举。

---

### **题解评分 (≥4星)**

1. **题解作者：_Life_（4.5星）**  
   - **亮点**：  
     - 示例详细，手算数据帮助理解递推过程。  
     - 代码结构清晰，高精度乘法优化后k位计算。  
     - 时间复杂度分析明确（O(k³)）。  
   - **代码片段**：  
     ```cpp
     bignum operator*(bignum a, bignum b) {
         bignum ans;
         for (int i=0; i<k; i++)
             for (int j=0; j<k; j++)
                 ans.x[i+j] += a.x[i] * b.x[j];
         // 进位处理...
         return ans;
     }
     ```

2. **题解作者：Shadow_Soldier（4星）**  
   - **亮点**：  
     - 数学推导严谨，引理证明递推的合法性。  
     - 代码注释详细，变量命名清晰。  

3. **题解作者：LeavingAC（4星）**  
   - **亮点**：  
     - Python代码简洁，利用大数特性避免高精度实现。  
     - 手搓数据示例直观展示递推过程。

---

### **最优思路或技巧提炼**

1. **递推法核心步骤**：  
   ```python
   for i in 1..k:
       current_mod = 10^i
       for j in 1..10:
           if (n^(prev_L * j) mod current_mod) == n mod current_mod:
               ans *= j
               break
       else: return -1
   ```

2. **高精度优化**：仅维护后k位，避免全量计算。  
3. **数学性质**：后k位循环长度是前k-1位循环长度的倍数。

---

### **同类型题或类似算法套路**

- **类似问题**：  
  - 求最小循环节长度（如字符串循环节、数论中的周期）。  
  - 模意义下的快速幂应用（如P1965 转圈游戏）。  
- **通用解法**：  
  - 利用递推或数学性质减少枚举量。  
  - 分治思想逐层处理每一位/每一部分。

---

### **推荐题目**

1. **P1965 转圈游戏**（快速幂+模运算）  
2. **P1516 青蛙的约会**（扩展欧几里得求循环解）  
3. **P1068 分数线划定**（模拟递推思维）

---

### **个人心得摘录**

- **调试经验**：  
  - 高精度乘法需注意进位截断，否则后k位计算错误。  
  - 递推时每一步的乘数需更新为当前循环长度的幂，否则后续计算无法复用。  
- **顿悟点**：  
  - 循环长度是前一步的倍数，极大减少枚举量。

---

### **可视化与算法演示**

**动画设计**：  
1. **逐位递推**：  
   - **Canvas网格**：每行表示一位（从右到左），背景色标记当前处理位。  
   - **乘数更新**：用像素方块显示乘数变化（如 `8123 → 0641`）。  
2. **颜色标记**：  
   - **当前位**：黄色高亮。  
   - **成功匹配**：绿色闪烁。  
   - **失败无解**：红色闪烁。  
3. **音效设计**：  
   - **成功**：8-bit风格上升音调。  
   - **失败**：短促低频音效。  

**交互设计**：  
- **步进控制**：按钮控制执行速度（快/慢/单步）。  
- **自动演示**：AI模式自动播放递推过程，类似贪吃蛇AI路径展示。  

**复古风格**：  
- **调色板**：FC红白机经典8色（红、蓝、绿、黑、白、黄、紫、青）。  
- **像素字体**：使用复古字体渲染数字和状态提示。

---

**代码片段（Python递推法）**：  
```python
n, k = map(int, input().split())
ans = 1
mod = 10**k
n %= mod
current = n
for i in range(1, k+1):
    target = n % (10**i)
    multiplier = 1
    found = False
    for j in range(1, 11):
        current = (current * pow(current, ans, mod)) % mod
        if current % (10**i) == target:
            ans *= j
            found = True
            break
    if not found:
        print(-1)
        exit()
print(ans)
```

---
处理用时：97.34秒
# 题目信息

# [国家集训队] 拉拉队排练

## 题目描述

艾利斯顿商学院篮球队要参加一年一度的市篮球比赛了。拉拉队是篮球比赛的一个看点，好的拉拉队往往能帮助球队增加士气，赢得最终的比赛。所以作为拉拉队队长的楚雨荨同学知道，帮助篮球队训练好拉拉队有多么的重要。

拉拉队的选拔工作已经结束，在雨荨和校长的挑选下，$n$ 位集优秀的身材、舞技于一体的美女从众多报名的女生中脱颖而出。这些女生将随着篮球队的小伙子们一起，和对手抗衡，为艾利斯顿篮球队加油助威。

一个阳光明媚的早晨，雨荨带领拉拉队的队员们开始了排练。$n$ 个女生从左到右排成一行，每个人手中都举了一个写有 $26$ 个小写字母中的某一个的牌子，在比赛的时候挥舞，为小伙子们呐喊、加油。

雨荨发现，如果连续的一段女生，有奇数个，并且他们手中的牌子所写的字母，从左到右和从右到左读起来一样，那么这一段女生就被称作和谐小群体。

现在雨荨想找出所有和谐小群体，并且按照女生的个数降序排序之后，前 $K$ 个和谐小群体的女生个数的乘积是多少。由于答案可能很大，雨荨只要你告诉她，答案除以 $19930726$ 的余数是多少就行了。

## 说明/提示

### 样例说明

和谐小群体女生所拿牌子上写的字母从左到右按照女生个数降序排序后为 `ababa`，`aba`，`aba`，`bab`，`a`，`a`，`a`，`b`，`b`，前三个长度的乘积为 $5\times 3\times 3 = 45$。


### 数据范围与约定


测试点 | $n$ | $K$
-----|---------|---
1    | $10$ | $10$
2-3  | $100$ | $100$
4-7  | $1,000$ | $1,000$
8    | $100,000$ | $= 1$
9-11 | $100,000$ | $100,000$
12-14| $100,000$ | $1,000,000,000,000$
15-17| $500,000$ | $1,000,000,000,000$
18   | $1,000,000$ | $= 1$
19   | $1,000,000$ | $1,000,000$
20   | $1,000,000$ | $1,000,000,000,000$

## 样例 #1

### 输入

```
5 3
ababa```

### 输出

```
45
```

# AI分析结果



# 【国家集训队】拉拉队排练题解分析

## 唯一算法分类  
**Manacher算法**

---

## 题解思路与算法要点  
### 核心思路  
1. **Manacher算法**计算每个中心的最长回文半径，过滤偶数长度回文串  
2. **差分/前缀和**统计各长度回文串数量  
3. **快速幂**处理大数乘积  

### 解决难点  
1. **高效统计回文串数量**：通过`cnt[p[i]-1]++`记录半径对应的奇数长度回文串  
2. **长度继承关系**：较大回文串包含更小奇数长度回文串，倒序遍历累加前缀和  
3. **超大指数运算**：对`cnt[i]`使用快速幂计算乘积  

---

## 题解评分（≥4星）  
1. **三好代表（★★★★☆）**  
   - 完整实现Manacher算法  
   - 清晰展示差分统计与快速幂优化  
   - 代码结构简洁，可读性强  
   ```cpp
   void manacher() {
       for(int i=1; i<=len; i++) str[i*2-1]='%',str[i*2]=s[i];
       str[len=len*2+1]='%';
       int id=0,mx=0;
       for(int i=1; i<=len; i++) {
           if(i<mx) p[i]=min(p[id*2-i],mx-i);
           else p[i]=1;
           while(p[i]+i<=len && i-p[i]>=1 && str[i+p[i]]==str[i-p[i]]) p[i]++;
           if(p[i]+i>mx) id=i,mx=i+p[i];
           if((p[i]-1)%2) cnt[p[i]-1]++;
       }
   }
   ```

2. **顾z（★★★★☆）**  
   - 使用前缀和优化统计  
   - 特别说明回文串包含关系  
   ```cpp
   for(RI i=1;i<=n;i++){
       if(i<=MaxRight)RL[i]=std::min(MaxRight-i,RL[2*center-i]);
       else RL[i]=1;
       while(i+RL[i]<=n&&i-RL[i]>=0&&s[i+RL[i]]==s[i-RL[i]])++RL[i];
       if(i+RL[i]-1>MaxRight)MaxRight=i+RL[i]-1,center=i;
       tong[2*RL[i]-1]++;
   }
   ```

3. **ezoiHQM（★★★★☆）**  
   - 基于Manacher的简洁实现  
   - 采用差分数组优化统计  
   ```cpp
   for(int i=1;i<=len;i++){
       if(s[i]!='%') {
           int xx=p[i]-1;
           t[xx]++;
           maxn=max(maxn,p[i]-1);
       }
   }
   ```

---

## 最优思路提炼  
1. **Manacher核心优化**：通过对称性直接计算回文半径，跳过无效比较  
2. **差分数组统计**：`cnt[p[i]-1]++`记录奇数长度回文串，避免重复扫描  
3. **前缀和累加**：倒序遍历长度`i`，`sum += cnt[i]`快速统计可用数量  

---

## 同类型题与算法套路  
1. **回文处理通用方法**：  
   - Manacher算法适用于最长回文子串类问题  
   - 前缀和/差分统计优化计数  
2. **类似题目**：  
   - [P3805 Manacher模板题](https://www.luogu.com.cn/problem/P3805)  
   - [P4555 双倍回文](https://www.luogu.com.cn/problem/P4555)  

---

## 推荐练习题  
1. **P1435 回文字串**（Manacher基础应用）  
2. **P4762 [CERC2014]Virus synthesis**（回文自动机综合应用）  
3. **P5496 回文自动机模板题**  

---

## 可视化与算法演示  
### 动画方案  
1. **Manacher扩展过程**：  
   - **颜色标记**：当前中心`id`用红色，扩展半径`p[i]`用绿色边框  
   - **对称比较**：高亮`s[i-p[i]]`和`s[i+p[i]]`字符，匹配成功时播放“滴”声  
2. **统计过程**：  
   - **动态柱状图**：显示`cnt`数组随长度递减的变化  
   - **快速幂提示**：在计算`ans *= pow(i, sum)`时显示指数分解动画  

### 复古游戏化设计  
1. **8位像素风格**：  
   - 字符显示为16x16像素块，背景音乐采用FC经典音效  
   - Manacher扩展时，对称字符闪烁黄色  
2. **音效设计**：  
   - **成功匹配**：8-bit上升音阶  
   - **统计完成**：经典马里奥过关音效  
3. **积分系统**：  
   - 正确统计一个长度得10分，错误扣5分  
   - 连续正确触发2x连击奖励  

---

## 核心代码片段  
```cpp
// Manacher核心扩展逻辑
void manacher() {
    int mx=0, mid=0;
    for(int i=1; i<=n; i++) {
        if(i < mx) p[i] = min(p[2*mid - i], mx - i);
        else p[i] = 1;
        while(s[i - p[i]] == s[i + p[i]]) p[i]++;
        if(i + p[i] > mx) {
            mx = i + p[i];
            mid = i;
        }
        cnt[p[i] - 1]++; // 统计奇数长度
    }
}

// 快速幂处理乘积
ll qpow(ll x, ll y) {
    ll res = 1;
    for(; y; y >>= 1, x = x*x % mod)
        if(y & 1) res = res*x % mod;
    return res;
}
```

---

通过上述分析，Manacher算法结合高效统计方法，能够有效解决大规模回文串计数与乘积计算问题。可视化设计可帮助理解算法动态过程，而复古游戏化元素则增加了学习趣味性。

---
处理用时：86.16秒
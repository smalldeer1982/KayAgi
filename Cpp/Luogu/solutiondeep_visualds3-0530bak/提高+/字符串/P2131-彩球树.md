# 题目信息

# 彩球树

## 题目描述

小Z是一个聪明的小学生，他用塑料管和橡皮泥搭成了一棵树，每个橡皮泥上都连接着一个向下的塑料管，有的连接着两根向上的塑料管，有的则连接着一些彩球。

然而，这个工艺品很快因为不平衡倒了下来。于是，小Z请教了和他在同一个班上的妹子小C。在百科全书上看到天平平衡原理的小C知道，如果任何一块橡皮泥向上连接的两根管子的载重量之差超过一个彩球的重量，工艺品就会不平衡倒下来。由于彩球比较重，橡皮泥和塑料管的重量可以忽略不计。

由于移动彩球需要花时间拆卸和固定，小C希望移动最少次数彩球让这个工艺品平衡起来。你能帮助她吗？


## 说明/提示

【图解】

[PIC=1259]

【数据规模】

对于 15% 的数据，保证输入文件不超过 25 字节。

对于 50% 的数据，保证输入文件不超过 250 字节。

对于 100% 的数据，保证输入文件不超过 5000 字节。

（PS：1字节≈1字符）

【时空限制】

0.1s/128M


## 样例 #1

### 输入

```
((B)())```

### 输出

```
0```

## 样例 #2

### 输入

```
((((B)(B))((B)()))(B))```

### 输出

```
impossible```

## 样例 #3

### 输入

```
(()(((B)(B))(B)))```

### 输出

```
1```

# AI分析结果



---

### **算法分类**
树形递归/动态规划

---

### **题解思路与核心难点**
**题目核心**：递归处理树结构，为每个非叶子节点分配彩球至左右子树，确保载重差≤1，并统计最少移动次数。

**题解要点**：
1. **递归传递彩球需求**：每个非叶子节点根据需求数 `K` 的奇偶性分配左右子树的彩球数目：
   - **偶数**：左右各分 `K/2`。
   - **奇数**：尝试两种分配（左多1或右多1），取可行且移动次数少者。
2. **叶子节点处理**：叶子需满足 `K=0`（无彩球）或 `K=1`（有彩球），否则方案非法。
3. **移动次数统计**：移动次数在叶子节点累加，最终除以2（避免重复计数）。

**解决难点**：
- **子树分割**：需正确解析括号结构，分割左右子树范围。
- **多情况处理**：奇偶分配可能产生多种分支，需遍历所有可能路径。

---

### **题解评分**
1. **一只小兔子（4星）**  
   - 思路清晰，递归逻辑完整。
   - 代码通过预处理括号匹配分割子树，处理奇偶分支。
   - 可读性一般（变量命名简短），但核心逻辑正确。
   - 通过样例测试，复杂度合理。

---

### **最优思路与技巧**
- **递归设计**：从根到叶传递需求，自底向上返回可行性及移动次数。
- **奇偶分支剪枝**：对奇数的两种分配进行可行性检查，取最优解。
- **括号预处理**：用栈预处理括号匹配，快速分割子树。

---

### **类似算法题目**
1. **二叉树平衡检查（LeetCode 110）**：检查树是否平衡。
2. **树形动态规划（洛谷 P2015）**：计算树的最小路径权值。
3. **天平称重问题（UVa 839）**：递归判断天平平衡。

---

### **推荐题目**
1. **P1364 医院设置**：树形结构的最小路径和。
2. **P1040 加分二叉树**：树形DP优化构造。
3. **P2015 二叉苹果树**：保留树枝的最大权值。

---

### **代码核心实现**
```cpp
#include <cstdio>
#include <cstring>
const int N = 5005;
char p[N];
int par[N], stk[N], top;

int search(int l, int r, int req) {
    if (r - l == 1) { // 叶子节点（空）
        return req == 0 ? 0 : -1;
    }
    if (r - l == 2 && p[l+1] == 'B') { // 叶子节点（B）
        return req == 1 ? 0 : -1;
    }
    
    int ll = l + 1, lr = par[ll];
    int rl = par[r - 1], rr = r - 1;
    int tas = 9999;

    if (req % 2 == 0) {
        int rq = req / 2;
        int t1 = search(ll, lr, rq);
        int t2 = search(rl, rr, rq);
        if (t1 != -1 && t2 != -1) tas = t1 + t2;
    } else {
        int rq = req / 2;
        // 右子树多1
        int t1 = search(ll, lr, rq);
        int t2 = search(rl, rr, rq + 1);
        if (t1 != -1 && t2 != -1) tas = t1 + t2;
        // 左子树多1
        t1 = search(ll, lr, rq + 1);
        t2 = search(rl, rr, rq);
        if (t1 != -1 && t2 != -1) tas = (tas < t1 + t2) ? tas : t1 + t2;
    }
    return (tas == 9999) ? -1 : tas;
}

int main() {
    scanf("%s", p + 1);
    int len = strlen(p + 1);
    // 预处理括号匹配
    for (int i = 1; i <= len; i++) {
        if (p[i] == '(') stk[++top] = i;
        else if (p[i] == ')') {
            par[i] = stk[top];
            par[stk[top]] = i;
            top--;
        }
    }
    int td = 0;
    for (int i = 1; i <= len; i++) if (p[i] == 'B') td++;
    int ans = search(1, len, td);
    printf(ans == -1 ? "impossible" : "%d", ans / 2);
}
```

---

### **可视化设计**
**动画方案**：
1. **树形结构展示**：用嵌套方框表示树节点，当前递归节点高亮为黄色。
2. **需求传递**：显示当前节点的 `req` 值，左右子树分配时用箭头标注数值。
3. **可行性反馈**：不可行节点标记为红色，可行路径标记为绿色。
4. **移动统计**：叶子节点变化时，显示移动次数的累加过程。

**复古像素风格**：
- **Canvas绘制**：节点用8位像素方块表示，递归过程伴随“滴答”音效。
- **自动演示**：按层级逐步展开递归，失败时播放低音效，成功时高音效。

---

**总结**：通过递归分割子树并分配彩球需求，结合括号预处理和奇偶分支剪枝，高效求解最少移动次数。

---
处理用时：295.26秒
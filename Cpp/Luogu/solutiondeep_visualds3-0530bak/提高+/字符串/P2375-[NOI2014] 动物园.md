# 题目信息

# [NOI2014] 动物园

## 题目描述

近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。

某天，园长给动物们讲解 KMP 算法。

园长：“对于一个字符串 $S$，它的长度为 $L$。我们可以在 $O(L)$ 的时间内，求出一个名为 $\mathrm{next}$ 的数组。有谁预习了 $\mathrm{next}$ 数组的含义吗？”

熊猫：“对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作 $\mathrm{next}[i]$。”

园长：“非常好！那你能举个例子吗？”

熊猫：“例 $S$ 为 $\verb!abcababc!$，则 $\mathrm{next}[5]=2$。因为$S$的前$5$个字符为 $\verb!abcab!$，$\verb!ab!$ 既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出 $\mathrm{next}[1] = \mathrm{next}[2] = \mathrm{next}[3] = 0$，$\mathrm{next}[4] = \mathrm{next}[6] = 1$，$\mathrm{next}[7] = 2$，$\mathrm{next}[8] = 3$。”

园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在 $O(L)$ 的时间内求出 $\mathrm{next}$ 数组。

下课前，园长提出了一个问题：“KMP 算法只能求出 $\mathrm{next}$ 数组。我现在希望求出一个更强大 $\mathrm{num}$ 数组一一对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $\mathrm{num}[i]$。例如 $S$ 为 $\verb!aaaaa!$，则 $\mathrm{num}[4] = 2$。这是因为$S$的前 $4$ 个字符为 $\verb!aaaa!$，其中 $\verb!a!$ 和 $\verb!aa!$ 都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而 $\verb!aaa!$ 虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，$\mathrm{num}[1] = 0,\mathrm{num}[2] = \mathrm{num}[3] = 1,\mathrm{num}[5] = 2$。”

最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出$\mathrm{num}$数组呢？

特别地，为了避免大量的输出，你不需要输出 $\mathrm{num}[i]$ 分别是多少，你只需要输出所有 $(\mathrm{num}[i]+1)$ 的乘积，对 $10^9 + 7$ 取模的结果即可。


## 说明/提示

测试点编号| 约定
-|-  
1| $n \le 5, L \le 50$  
2| $n \le 5, L \le 200$  
3| $n \le 5, L \le 200$  
4| $n \le 5, L \le 10,000$  
5| $n \le 5, L \le 10,000$  
6| $n \le 5, L \le 100,000$  
7| $n \le 5, L \le 200,000$   
8| $n \le 5, L \le 500,000$  
9| $n \le 5, L \le 1,000,000$  
10| $n \le 5, L \le 1,000,000$  


## 样例 #1

### 输入

```
3
aaaaa
ab
abcababc```

### 输出

```
36
1
32 ```

# AI分析结果



## 【唯一算法分类】
KMP算法

---

## 【题解思路与解决难点】
### 核心思路
1. **两次KMP处理**  
   - 第一次构建标准的next数组，并同步计算每个位置的公共前后缀数量（不考虑重叠）
   - 第二次在匹配过程中动态调整指针，确保前后缀不重叠，并累乘合法数量

2. **跳转优化**  
   通过维护指针j的跳跃逻辑，确保每次调整操作的时间复杂度为均摊O(1)。具体表现为：
   - 当发现当前j超过i/2时，沿next链回溯直到满足长度条件
   - 利用KMP算法中全局指针j的单调性，避免重复计算

### 算法要点
- **next数组扩展**：在构建next数组时同步计算num数组，记录每个位置不考虑重叠时的公共前后缀数量
- **指针调整逻辑**：`while (j<<1) > (i+1)` 确保前后缀不重叠，该条件判断是解决题目的核心难点
- **乘积计算**：在O(n)时间内完成所有合法位置的统计，利用模运算处理大数

---

## 【题解评分（≥4星）】
1. **Orion545（★★★★★）**  
   - 亮点：引入fail树概念，通过树形结构解释KMP自动机，逻辑严谨
   - 代码实现：双指针维护极高效，含详细注释说明树深度的计算方式

2. **nofind（★★★★★）**  
   - 亮点：图形化解释next链跳跃过程，直接给出倍增跳转示意图
   - 代码实现：分离next与num计算逻辑，代码可读性极强

3. **WjNaG（★★★★☆）**  
   - 亮点：手写KMP过程注释详细，适合初学者理解
   - 优化点：省略显式num数组，直接在乘积计算时访问预处理值

---

## 【最优思路/技巧提炼】
### 关键技巧
1. **Fail树深度应用**  
   通过next数组构建隐式树结构，树深度直接对应公共前后缀数量

2. **双阶段指针维护**  
   ```python
   # 阶段1：构建next与num数组
   j = 0
   for i in 1..n-1:
       while j且不匹配: j = next[j]
       if 匹配: j += 1
       next[i+1] = j
       num[i+1] = num[j] + 1
   
   # 阶段2：乘积计算
   j = 0
   for i in 0..n-1:
       while j且不匹配: j = next[j]
       if 匹配: j += 1
       while j > (i+1)/2: j = next[j]
       ans *= (num[j] + 1)
   ```

3. **模运算优化**  
   在每次乘法后立即取模，避免大数溢出：
   ```cpp
   ans = (ans * (num[j] + 1)) % MOD;
   ```

---

## 【相似题目】
1. P3435 [POI2006] OKR-Periods of Words  
   - 关键点：扩展KMP求最小周期
2. P5410 【模板】扩展 KMP（Z 函数）  
   - 关键点：Z函数与next数组的扩展应用
3. P5829 【模板】失配树  
   - 关键点：KMP的fail树显式构建

---

## 【可视化与算法演示】
### 动画设计
1. **双指针追踪**  
   - 主指针i向右滑动，副指针j用不同颜色标记
   - 当j超过i/2时触发红色警报，展示next链回溯过程

2. **像素风格设计**  
   ```javascript
   // 示例：Canvas绘制字符块
   function drawCharBlocks() {
       ctx.fillStyle = "#8B00FF"; // 紫色基调
       for(let i=0; i<len; i++) {
           ctx.fillRect(20+i*30, 50, 25, 25); // 字符块
           ctx.fillText(s[i], 25+i*30, 70); // ASCII字符
       }
   }
   ```

3. **音效系统**  
   - 匹配成功：8-bit上升音效（0200Hz方波）
   - 越界回溯：短促警报音（0500Hz三角波）
   - 计算完成：经典FC过关音效

---

## 【核心代码实现】
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int N=1e6+5, MOD=1e9+7;
char s[N];
int n, nxt[N], cnt[N];

int main() {
    int T; scanf("%d", &T);
    while(T--) {
        scanf("%s", s);
        n = strlen(s);
        
        // 第一次KMP：构建nxt和cnt数组
        nxt[0] = -1; cnt[0] = 0; cnt[1] = 1;
        for(int i=1,j=0; i<n; ++i) {
            while(j!=-1 && s[i]!=s[j]) j = nxt[j];
            nxt[i+1] = ++j;
            cnt[i+1] = cnt[j] + 1;
        }
        
        // 第二次处理：计算答案
        long long ans = 1;
        for(int i=0,j=0; i<n; ++i) {
            while(j!=-1 && s[i]!=s[j]) j = nxt[j];
            if(++j *2 > i+1) j = nxt[j];
            ans = ans * (cnt[j] + 1) % MOD;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```

---
处理用时：82.46秒
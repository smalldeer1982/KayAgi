# 题目信息

# 计算器写作文

## 题目描述

众所周知，计算器可以拿来干很多它本不应该干的事情，比如弹琴。

小A发现了一个计算器的隐藏功能——写英语作文。

他在计算器上按一些数字，这些然后旋转 $180$ 度就是作文。

每个数字对应一两个字母

 ![](https://cdn.luogu.com.cn/upload/pic/1738.png) 



小 A 准备了一个单词表，选择其中的一些单词，按照一个顺序组成作文。这个作文是可以用计算器按出来的。比如单词表给 `ODD`、`EGG`，作文写成 `ODDEGG` 的话，那么要在计算器上按出 `993000`，这篇作文的得分就是 $993000$。

单词表的单词不能重复使用。如果单词表出现了多个一样的单词，每个单词最多都可以各使用一次。单词不可以被截断。

小 A 希望自己写出的作文得分最高。当然这个计算器是有位数限制，作文长度不能超过显示位数。

计算器不能显示前导零，但是你可以添加小数点。比如作文写成 `EGGODD` 的话，就得按出 $0.00993$，这个就是作文的得分，当然这得分太小了。


## 说明/提示



对于 $40\%$ 的数据，$D \leq 20,N \leq 10$。

对于 $100\%$ 的数据，$D \leq 200,N \leq 10000$，单词长度 $\leq 32$。

## 样例 #1

### 输入

```
7

4

EGG

ODD

LOBE

LIBE```

### 输出

```
9933817```

# AI分析结果



### 算法分类
动态规划（01背包）+ 贪心排序

---

### 题解思路与核心难点

#### 核心思路
1. **字符串转换**：将每个单词转换为对应的数字字符串，注意字符顺序需反转（如 `EGG` → `993`）。
2. **贪心排序**：按拼接后的字典序降序排列（若 `a+b > b+a`，则 `a` 排在前面），确保动态规划后效性被消除。
3. **动态规划**：01背包模型，状态 `f[j]` 表示总长度为 `j` 时的最大数字字符串。转移时比较字符串长度和字典序。
4. **前导零处理**：若结果以 `0` 开头，需转换为小数点形式（如 `0.000123`）。

#### 解决难点
- **排序策略**：正确比较两个字符串拼接后的字典序，确保最优顺序。
- **状态转移中的字符串比较**：需分情况处理前导零（长度优先或字典序优先）。
- **最终输出处理**：判断是否全为前导零，决定是否添加小数点。

---

### 题解评分（≥4星）

1. **凯特琳的题解（5星）**
   - **亮点**：正确处理排序与比较函数，分情况处理前导零，代码逻辑清晰。
   - **代码可读性**：使用 Pascal 实现，注释详细，状态转移明确。
   - **关键代码段**：
     ```pascal
     function max(aa, bb: ansistring): ansistring;
     begin
       if (length(aa) = 0) or (length(bb) = 0) then ...
       if (aa[1] <> '0') and (bb[1] <> '0') then ... // 处理非前导零情况
     end;
     ```

2. **cunzai_zsy0531 的题解（5星）**
   - **亮点**：通过结构体封装字符串比较逻辑，支持多种排序方式。
   - **关键思路**：分情况处理比较函数，动态选择排序策略。
   - **代码片段**：
     ```cpp
     bool operator >(const Big &A)const {
       if (pd) { // pd 表示是否存在非前导零字符串
         if (len != A.len) return len > A.len;
         return memcmp(d, A.d, len) > 0;
       }
       return strcmp(d, A.d) > 0; // 全为前导零时直接比较字典序
     }
     ```

3. **Chthologist7507 的题解（4星）**
   - **亮点**：自定义 `Node` 结构体重载运算符，支持灵活比较。
   - **优化点**：分情况处理排序逻辑，代码模块化程度高。
   - **关键代码**：
     ```cpp
     bool operator >(const Node &A)const {
       if (pd) { // 存在非前导零字符串
         if (len != A.len) return len > A.len;
         for (int i=0; i<len; i++) ...
       }
       return strcmp(d, A.d) > 0; // 全为前导零时直接比较
     }
     ```

---

### 最优思路与技巧提炼

1. **贪心排序策略**  
   - 核心比较逻辑：`return (a + b) > (b + a)`，确保拼接后字典序最大。
   - **示例**：若 `a="993"`, `b="3807"`，比较 `9933807` 和 `3807993`，取前者。

2. **动态规划状态设计**  
   - **状态定义**：`f[j]` 为长度为 `j` 时的最大数字字符串。
   - **转移方程**：`f[j] = max(f[j], f[j - len[i]] + v[i])`，倒序遍历避免重复选择。

3. **前导零处理**  
   - **判断条件**：若 `f[m][0] == '0'`，输出 `0.` 后接剩余字符。
   - **比较函数优化**：分情况处理长度优先与字典序优先。

---

### 类似题目推荐

1. [LeetCode 179. 最大数](https://leetcode-cn.com/problems/largest-number/)  
   **相似点**：拼接数字形成最大数，需自定义排序。

2. [洛谷 P1012 拼数](https://www.luogu.com.cn/problem/P1012)  
   **相似点**：贪心排序策略，动态规划思想。

3. [Codeforces 363C. Beautiful Numbers](https://codeforces.com/problemset/problem/363/C)  
   **相似点**：处理前导零与数值比较。

---

### 可视化算法设计

#### 动态规划状态转移动画
- **核心展示**：  
  - **背包容量轴**：横向展示容量 `0` 到 `D`，每个格子表示当前长度下的最大字符串。
  - **物品选择**：每个物品以像素块表示，颜色区分是否被选中。
  - **状态更新**：选中物品时，高亮对应格子并更新字符串，播放“拼接”音效。

#### 复古像素风格设计
- **颜色方案**：  
  - 可用背包容量：绿色像素块。  
  - 已选物品：橙色像素块。  
  - 当前操作：红色闪烁边框。  
- **音效设计**：  
  - **拼接成功**：8-bit 上升音调。  
  - **更新最大值**：短促“叮”声。  
  - **错误操作**：低沉嗡鸣声。  

#### 交互控制
- **步进控制**：支持暂停/继续，调节动画速度（1x/2x/5x）。  
- **对比模式**：并行展示不同排序策略的结果差异。  

---

### 代码片段（核心逻辑）

```cpp
// 转换单词为数字字符串（倒序）
string convert(string word) {
    map<char, char> mp = {{'O','0'}, {'D','0'}, ..., {'I','1'}};
    reverse(word.begin(), word.end());
    string res;
    for (char c : word) res += mp[c];
    return res;
}

// 自定义排序函数
bool cmp(string a, string b) {
    return (a + b) > (b + a);
}

// 动态规划处理
vector<string> dp(m + 1, "");
for (int i = 0; i < n; i++) {
    string num = convert(words[i]);
    int len = num.length();
    for (int j = m; j >= len; j--) {
        string candidate = dp[j - len] + num;
        if (compare(candidate, dp[j])) {
            dp[j] = candidate;
        }
    }
}

// 比较函数（处理前导零）
bool compare(string a, string b) {
    if (a.empty()) return false;
    if (b.empty()) return true;
    if (a[0] != '0' && b[0] != '0') {
        if (a.length() != b.length()) return a.length() > b.length();
        return a > b;
    }
    return a > b; // 字典序优先
}
```

---

### 个人心得摘录

> **凯特琳的调试经验**：  
> “最初直接按字典序排序导致 WA，后发现需按拼接后的字典序降序排列。调试时构造了 `a="12"`, `b="121"` 的用例，发现 `a+b` 和 `b+a` 的比较是关键。”

> **Chthologist7507 的优化思路**：  
> “通过结构体封装比较逻辑，避免重复代码。分情况处理前导零和非前导零的比较，减少冗余判断。”

---
处理用时：296.05秒
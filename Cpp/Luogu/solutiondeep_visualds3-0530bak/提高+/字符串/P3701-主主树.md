# 题目信息

# 主主树

## 题目背景

byx 和诗乃酱都非常都非常喜欢种树。有一天，他们得到了两颗奇怪的树种，于是各自取了一颗回家种树，并约定几年后比一比谁种出来的树更加牛 X。

## 题目描述

很快，这棵树就开花结果了。byx 和诗乃酱惊讶的发现，这是一棵主主树，树上长满了主主和主主的朋友们。这棵树上一共有五种人，主主（$\verb!J!$），记记（$\verb!HK!$），高高（$\verb!W!$），王王（$\verb!E!$）和歪歪（$\verb!YYY!$）。他们发现，他们的主主树上的人数相同，都为 $N$。

 ![](https://cdn.luogu.com.cn/upload/image_hosting/0vklm8ow.png) 

研究发现，这五种人的输赢如上图所示（一样的人不能 PK），箭头指向输的人。至于为什么，留给同学们自己思考。

比赛如期进行。

byx 和诗乃酱要进行 $M$ 场比赛，每一场比赛他们会选出树上的两个人来比较看谁更牛 X。

第 $i$ 个人寿命为 $\text{Life}_i$ 秒，每次比完赛他们就会 $-1$s。当他们生命为 $0$s 时他们就不能再比赛了。

同时，当 $\verb!J!$ 的寿命为 $0$ 时，同一棵树上的 $\verb!YYY!$ 可以为他 $+1$s。每个 $\verb!YYY!$ 只能给每个 $\verb!J!$ 续一次。

那么问题来了：

现在给定 $N,M(1\le N\le 100,1\le M\le 1000)$，诗乃酱和 byx 每一个人所属种类（$\verb!J!,\verb!HK!,\verb!W!,\verb!YYY!$ 或 $\verb!E!$）以及每一个人的生命，生命不超过 $50$。请你算算 byx 最多能够赢得多少场比赛呢。

数据保证每一场一定都有人用。两个人之间只能比一场。

## 说明/提示

第一场主主赢记记，第二场高高赢王王，第三场歪歪赢记记。


## 样例 #1

### 输入

```
3 3
J W YYY
J HK E
2 2 2
2 2 2
```

### 输出

```
3
```

# AI分析结果



## 算法分类
网络流-最大流（Dinic算法）

---

## 题解思路与核心难点

### 核心算法流程
1. **建模关键点**  
   - 源点连接byx的所有角色，边权为初始生命（J需加上本方YYY数量）  
   - 汇点连接诗乃酱的所有角色，边权同理  
   - byx的角色i若能击败诗乃酱的角色j，建立容量为1的边  
   - 最终答案为最大流与M的较小值  

2. **解决难点**  
   - **续命机制**：直接预处理J的生命值增加YYY数量，无需动态调整  
   - **克制关系映射**：使用字符首字母判断或预定义关系矩阵  
   - **容量限制**：每场比赛只能进行一次（边权为1）

---

## 题解评分（≥4星）

1. **Mr_QwQ（5星）**  
   - 亮点：最早提出完整建模思路，明确J的生命预处理方式  
   - 代码：未贴出但思路清晰，对YYY续命处理一针见血  

2. **钱逸凡（4.5星）**  
   - 亮点：详细说明网络流暗示逻辑，附克制关系映射代码  
   - 代码：实现较完整，包含弧优化Dinic  

3. **suyiheng（4星）**  
   - 亮点：简洁的预处理逻辑，代码易读  
   - 特色：用map存储克制关系，方便扩展  

---

## 最优思路提炼

### 关键技巧
- **预处理YYY续命**：统计双方YYY数量后，直接加到J的初始生命值  
- **克制关系矩阵**：通过预定义二维数组快速判断胜负关系  
- **边权设计**：每对选手间仅建一条容量为1的单向边  

### 核心代码片段
```cpp
// 预处理J的生命值（以byx为例）
int cntb = 0;  // byx的YYY数量
for(int i=1; i<=n; i++) if(a[i] == "YYY") cntb++;
for(int i=1; i<=n; i++){
    if(a[i] == "J") hp[i] += cntb;
    add(s, i, hp[i]);  // 源点->byx
}

// 克制关系连边（示例：byx的J击败诗乃酱的HK或W）
for(int i=1; i<=n; i++){
    for(int j=1; j<=n; j++){
        if(a[i]=="J" && (b[j]=="HK" || b[j]=="W")){
            add(i, j+n, 1);
        }
        // 其他克制情况类似
    }
}
```

---

## 类似题目推荐
1. **P3376** - 网络最大流（模板题）  
2. **P2756** - 飞行员配对（二分图匹配）  
3. **P3254** - 圆桌问题（多源多汇建模）

---

## 可视化设计

### 动画方案
1. **像素风格网络流**  
   - **节点颜色**：源点（红）、汇点（蓝）、byx角色（绿）、诗乃酱角色（黄）  
   - **边高亮**：增广路径用橙色闪烁，饱和边变为灰色  

2. **关键步骤演示**  
   - **初始化阶段**：逐个显示节点及初始边权（生命值）  
   - **BFS分层**：用波浪线扩散效果显示层次网络  
   - **DFS找增广路**：路径节点依次闪烁，流量数值动态变化  

3. **音效设计**  
   - 找到增广路径时播放"滴"声，流量更新时触发"咔"声  
   - 算法结束时根据结果播放胜利/失败音效  

---

## 复古游戏化实现
```javascript
// 伪代码示例：Canvas绘制节点
function drawNode(ctx, x, y, type) {
    const colors = { 'S': '#FF0000', 'T': '#0000FF', 'J': '#00FF00' };
    ctx.fillStyle = colors[type] || '#888888';
    ctx.fillRect(x-15, y-15, 30, 30); // 像素方块
    ctx.strokeStyle = '#000000';
    ctx.strokeRect(x-15, y-15, 30, 30);
}

// 自动演示模式
let autoPlay = setInterval(() => {
    if(!dinicStep()) clearInterval(autoPlay); // 单步执行Dinic
}, 1000); // 每秒一步
```

---
处理用时：62.68秒
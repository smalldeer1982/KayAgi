# 题目信息

# 【模板】AC 自动机

## 题目背景

本题原为“AC 自动机（二次加强版）”。完成本题前可以先完成 [AC 自动机（简单版）](https://www.luogu.com.cn/problem/P3808) 和 [AC 自动机（简单版 II）](https://www.luogu.com.cn/problem/P3796) 两道题，为 AC 自动机更简单的应用。

## 题目描述

给你一个文本串 $S$ 和 $n$ 个模式串 $T_{1 \sim n}$，请你分别求出每个模式串 $T_i$ 在 $S$ 中出现的次数。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 2 \times {10}^5$，$T_{1 \sim n}$ 的长度总和不超过 $2 \times {10}^5$，$S$ 的长度不超过 $2 \times {10}^6$。

## 样例 #1

### 输入

```
5
a
bb
aa
abaa
abaaa
abaaabaa
```

### 输出

```
6
0
3
2
1
```

# AI分析结果



# 算法分类
**AC自动机**

---

# 题解思路与核心要点

### 核心难点
1. **重复模式串处理**：需记录每个模式串在Trie中的唯一标识，避免重复统计。
2. **暴力跳fail的时间复杂度**：传统方法暴力跳fail指针最坏时间复杂度为O(模式串总长 × 文本串长度)，需优化至线性。
3. **高效统计子树和**：需通过拓扑排序或fail树遍历，将节点值累计到所有祖先节点。

---

# 题解评分（≥4星）

### 五星题解
1. **hyfhaha（拓扑排序优化）**
   - **亮点**：通过拓扑排序逆序累计节点值，实现O(n)时间复杂度。
   - **代码结构**：分离查询与统计逻辑，用`Map`处理重复模式串。
   - **关键代码**：
     ```cpp
     void topu(){
         for(int i=1;i<=cnt;++i) if(!in[i])q.push(i);
         while(!q.empty()){
             int u=q.front(); q.pop();
             vis[trie[u].flag] = trie[u].ans;
             trie[trie[u].fail].ans += trie[u].ans;
             if(--in[trie[u].fail]==0) q.push(trie[u].fail);
         }
     }
     ```

2. **ouuan（fail树DFS）**
   - **亮点**：将fail指针视为树边，通过DFS求子树和。
   - **代码特点**：显式构建fail树，利用链式前向星存图。
   - **核心逻辑**：
     ```cpp
     void dfs(int u) {
         for(int i=head[u];i;i=nxt[i]) {
             dfs(to[i]);
             siz[u] += siz[to[i]];
         }
     }
     ```

### 四星题解
1. **August_Light（分层解析）**
   - **亮点**：分步骤讲解AC自动机构建、fail树处理，适合新手。
   - **代码结构**：使用Lambda表达式实现DFS，代码简洁。
   - **关键步骤**：
     ```cpp
     auto dfs = [&](int u, auto&& self) -> void {
         for (auto v : G[u]) self(v, self), sum[u] += sum[v];
     };
     ```

---

# 最优思路与技巧

### 关键优化
1. **拓扑排序累计**：在AC自动机构建时记录每个节点的入度，查询后按拓扑逆序将当前节点的值累加到fail指针指向的节点。
2. **Fail树子树和**：将fail指针视为树边，通过DFS一次性统计所有祖先节点的贡献。

### 同类型题套路
- **多模式串匹配**：AC自动机是解决多模式串匹配的通用方法。
- **子树和统计**：类似树形DP，常见于需要累计父节点贡献的场景。

---

# 推荐题目
1. **P3796**：AC自动机加强版，统计出现次数最多的模式串。
2. **P4052**：AC自动机结合动态规划，需处理禁止出现的模式串。
3. **P2444**：在AC自动机上判环，结合图论思想。

---

# 可视化与算法演示

### 核心动画流程
1. **Trie树构建**：动态展示模式串插入过程，节点按层级展开。
2. **Fail指针生成**：用红色箭头标注每个节点的fail指针，如节点4→7→9。
3. **文本串匹配**：绿色高亮当前匹配路径，黄色标记所有被访问节点。
4. **拓扑排序累计**：从叶子节点开始，将值逆序传递到父节点，蓝色标记更新路径。

### 复古像素化设计
- **颜色方案**：Trie节点用绿色方块，fail指针用红色箭头，匹配路径用闪烁黄框。
- **音效设计**：插入节点时播放“滴”声，匹配成功时播放8-bit音效，拓扑更新时播放滑动音效。
- **Canvas交互**：支持暂停/继续，拖动进度条观察拓扑排序逆序更新过程。

---

# 代码片段（拓扑排序优化）

```cpp
// 关键拓扑排序代码
void topu() {
    queue<int> q;
    for (int i = 1; i <= cnt; ++i) 
        if (in[i] == 0) q.push(i);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        if (trie[u].flag) vis[trie[u].flag] = trie[u].ans;
        int v = trie[u].fail;
        trie[v].ans += trie[u].ans;
        if (--in[v] == 0) q.push(v);
    }
}
```

---

# 总结
**AC自动机的核心优化在于避免暴力跳fail指针**，通过拓扑排序或fail树将时间复杂度优化至线性。处理重复模式串时需用映射表记录唯一标识。可视化重点在于展示fail指针的树形结构和逆序累计过程。

---
处理用时：59.77秒
# 题目信息

# 【模板】子序列自动机

## 题目背景

本题中，若 $x$ 是 $y$ 的子序列，则等价于存在一个**单调递增**序列 $z$，满足 $|z| = |x|$，$z_{|x|} \leq |y|$，且 $\forall i \in [1, ~|x|],~y_{z_i} = x_i$。其中 $|x|,~|y|,~|z|$ 分别代表序列 $x,~y,~z$ 的长度，$x_i,~y_i,~z_i$ 分别代表序列 $x,~y,~z$ 的第 $i$ 项。

这是一道在 ``yLOI2020`` 备选题里被毙掉的题目。

## 题目描述

给定一个长度为 $n$ 的正整数序列 $a$ ，有 $q$ 次询问，第 $i$ 次询问给定一个长度为 $L_i$ 的序列 $b_i$，请你判断 $b_i$ 是不是 $a$ 的子序列。序列 $a$ 和所有 $b_i$ 中的元素都不大于一个给定的正整数 $m$。

## 说明/提示

#### 样例 1 解释

- 对于第一次询问，原序列中没有 $5$，所以给定序列显然不是原序列的子序列。
- 对于第二次询问，存在两个合法的序列 $z$，分别是 $\{2,~3\}$ 和 $\{2,~4\}$。即 $a_{2} = b_{2, 1},~a_3 = b_{2, 2}$ 或 $a_2 = b_{2, 1},~a_{4} = b_{2, 2}$。这里 $b_{i, j}$ 代表序列 $b_i$ 的第 $j$ 个元素，序列 $z$ 的含义见【题目背景】，下同。
- 对于第三次询问，不存在合法的序列 $z$。
- 对于第四次询问，存在两个合法的序列 $z$，分别是 $\{1,~3,~5\}$ 和 $\{1,~4,~5\}$。
- 对于第五次询问，存在一个合法的序列 $z$，为 $\{1,~2,~3,~4,~5\}$。

#### 数据范围与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（20 points）：$type = 1$，$n, q, m \leq 100$，$\sum_{i = 1}^{q} l_i \leq 10^3$。
- Subtask 2（35 points）：$type = 2$，$n,q \leq 10^5$，$m \leq 26$，$\sum_{i = 1}^{q} l_i \leq 10^6$。
- Subtask 3（45 points）：$type = 3$，$n,q,m \leq 10^5$，$\sum_{i = 1}^q L_i \leq 10^6$。

对于全部的测试点，保证 $1 \leq n, m, q \leq 10^5$，$1 \leq a_i, b_{i, j} \leq m$，$1 \leq l_i \leq 10^6$，$\sum_{i = 1}^{q} l_i \leq 10^6$。


### 提示

- 请注意常数因子对程序效率造成的影响。
- 本题输入规模较大，请注意数据读入对程序效率造成的影响。
- 请注意输入第一行的顺序为先输入询问次数 $q$，再输入序列元素最大值 $m$。

## 样例 #1

### 输入

```
0 5 5 5
1 3 2 2 4
3 1 5 2
2 3 2
3 1 2 3
3 1 2 4
5 1 3 2 2 4
```

### 输出

```
No
Yes
No
Yes
Yes```

# AI分析结果



**唯一算法分类**：二分查找/贪心

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
题目要求快速判断多个序列是否为原序列的子序列。关键难点在于高效匹配每个元素的**下一个出现位置**。各题解核心思路对比：

1. **序列自动机（可持久化线段树）**  
   - **构建**：从后向前维护每个位置各字符的**最近出现位置**，使用可持久化技术优化空间。
   - **查询**：从起点逐步跳转，时间复杂度为 O(L log m)。
   - **难点**：可持久化线段树的实现复杂度较高，但能处理大字符集。

2. **二分查找（vector预处理）**  
   - **预处理**：对每个数值存储其出现位置的递增序列。
   - **查询**：对当前元素在对应数值的vector中二分查找比上一个位置大的最小下标。
   - **优势**：代码简洁，时空复杂度均优（O(n + ∑L log n)）。

3. **离线处理（队列批处理）**  
   - **预处理**：将每个询问按当前需匹配的元素值分组。
   - **扫描原序列**：遇到元素时批量处理对应的队列，更新各询问的匹配进度。
   - **亮点**：时间复杂度 O(n + ∑L)，但实现复杂。

#### **最优思路提炼**
**二分查找法**（来自AThousandSuns）是最优解，关键步骤：
1. **预处理**：为每个数值建立其出现位置的递增列表。
2. **匹配过程**：从位置0开始，对目标序列的每个元素，在对应数值的列表中二分查找第一个大于当前位置的下标。
3. **判断**：若某次查找失败，则不是子序列。

---

### **题解评分 (≥4星)**

1. **AThousandSuns（5星）**  
   - **亮点**：代码简洁高效，利用vector和二分将问题转化为经典查找，时空复杂度优秀。
   - **代码片段**：
     ```cpp
     vector<int> v[maxn];
     FOR(i,1,n) v[read()].push_back(i);
     bool flag = true;
     while (l--) {
         int x = read();
         auto it = lower_bound(v[x].begin(), v[x].end(), at+1);
         if (it == v[x].end()) flag = false;
         else at = *it;
     }
     ```

2. **一扶苏一（4星）**  
   - **亮点**：详细对比不同算法，提供可持久化线段树的标准解法。
   - **核心代码**：主席树维护每个位置的后继位置，查询时跳转。

3. **_虹_（4星）**  
   - **亮点**：离线队列处理，时间复杂度最优，适合大规模数据。
   - **核心逻辑**：将询问按需匹配值分组，扫描原序列时批量更新。

---

### **同类型题与算法套路**
- **相似题目**：  
  1. [P3500 [POI2010] TES-Intelligence Test](https://www.luogu.com.cn/problem/P3500)  
  2. [P1816 忠诚](https://www.luogu.com.cn/problem/P1816)（区间最小值，RMQ问题）  
  3. [CF978E巴士摄像头](https://codeforces.com/problemset/problem/978/E)（贪心匹配）

---

### **可视化与算法演示**
**动画设计**：  
1. **预处理阶段**：  
   - 原序列每个元素值对应的位置列表动态展开，如数值3的位置显示为[2]。  
   - **颜色标记**：原序列元素高亮，对应vector逐步填充。

2. **查询阶段**：  
   - **目标序列逐元素匹配**：显示当前元素值，在对应vector中二分查找，红色指针动态移动。  
   - **高亮变化**：成功时绿色箭头跳转到新位置，失败时红色叉标记。

**复古像素风格**：  
- **Canvas网格**：原序列显示为像素块，数值用不同颜色填充。  
- **音效**：二分时播放“滴答”声，匹配成功时播放8-bit上升音效，失败时低沉音效。

**交互控制**：  
- **步进按钮**：单步执行二分查找过程，观察指针移动。  
- **速度调节**：调整动画速度，适合不同学习节奏。

---

### **关键代码实现（二分法）**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100010;
vector<int> pos[maxn];  // 预处理每个数值的位置

int main() {
    int n, q, m, tmp;
    scanf("%*d%d%d%d", &n, &q, &m);  // 跳过无用输入
    for (int i=1; i<=n; ++i) {
        int x; scanf("%d", &x);
        pos[x].push_back(i);
    }
    while (q--) {
        int len, cur = 0;
        bool ok = true;
        scanf("%d", &len);
        for (int i=0; i<len; ++i) {
            int x; scanf("%d", &x);
            if (!ok) continue;
            auto it = lower_bound(pos[x].begin(), pos[x].end(), cur+1);
            if (it == pos[x].end()) ok = false;
            else cur = *it;
        }
        puts(ok ? "Yes" : "No");
    }
    return 0;
}
```

---

### **个人心得**
- **调试技巧**：在处理输入时需注意跳过无关变量（如`type`），避免数组越界。  
- **优化教训**：直接使用STL的`lower_bound`比手写二分更简洁且不易出错。  
- **顿悟点**：子序列匹配本质是贪心寻找最左可行解，无需复杂数据结构即可高效实现。

---
处理用时：73.67秒
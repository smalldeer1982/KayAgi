# 题目信息

# 串串题

## 题目描述

给定长度分别为 $n,m$ 的整数序列 $A,B$ 和常数 $W,d$，序列从 $1$ 开始标号，保证 $A_i,B_i \in [1,W]$。

容易发现，我们有 $\binom{W}{d}$ 种方案选择 $[1,W]$ 中的 $d$ 个互不相同的整数。

对于每一种选择的方案，我们删去 $A$ 中出现的对应的 $d$ 种整数，令此时序列 $B$ 在序列 $A$ 中的出现次数为这次选择方案的权值。

你需要求所有的选择方案的权值和，对 ${10}^9+7$ 取模。

若对题意有疑问，请阅读样例及样例解释。

注：$\binom{a}{b}$ 表示组合数，含义为在 $a$ 个物品中**无序**地选择出 $b$ 个物品的方案数。

**请注意：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

## 说明/提示

**【样例解释】**

在样例的第一组数据中：

1. 如果我们选择删去 $A$ 中的字符 $1$，$A$ 将变为 $\{2\}$，此时 $B$ 在 $A$ 中的出现次数为 $0$。
1. 如果我们选择删去 $A$ 中的字符 $2$，$A$ 将变为 $\{1,1,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $2$。
1. 如果我们选择删去 $A$ 中的字符 $3$，$A$ 将变为 $\{1,1,2,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $1$。

因此，第一组数据的答案为 $0+2+1=3$。

**再次提醒：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

---

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n,m,W \le {10}^6$，$1 \le d, A_i, B_j \le W$，$1 \le T \le 5$。

**本题采用捆绑测试且开启子任务依赖！**

| 子任务 | $n \le$ | $m \le$ | $W \le$ | 特殊性质 | 分数 | 依赖 |
| - | - | - | - | - | - | - |
| 1 | $10$ | $10$ | $5$ | | $10$ | \ |
| 2 | $1000$ | $1000$ | $5$ | | $20$ | 子任务 1 |
| 3 |  | | | A | $15$ | \ |
| 4 |  | | | B | $25$ | \ |
| 5 | | | | | $30$ | 子任务 1、2、3、4 |

特殊性质 A：保证 $d=1$。

特殊性质 B：令 $c$ 表示仅在序列 $A$ 中出现，而不在序列 $B$ 中出现的数字总数。保证 $c \le 5$。

## 样例 #1

### 输入

```
2
4 2 3 1
1 1 2 1
1 1
8 3 4 1
1 2 3 1 2 3 1 2
1 2 1
```

### 输出

```
3
2
```

# AI分析结果



**唯一算法分类**：组合数学 + KMP + 滑动窗口

---

### **题解思路与核心难点**

#### **核心思路**
1. **关键元素筛选**：将B中的元素标记为不可删除的**关键元素**，所有删除操作只能针对非关键元素。
2. **序列重构与KMP匹配**：从A中提取关键元素形成新序列C，用KMP算法在C中寻找B的所有匹配区间。
3. **区间贡献计算**：对每个匹配的区间，统计其对应原A序列区间内的非关键元素种类数o，贡献为组合数 $\dbinom{c-o}{d-o}$（c为总非关键元素数量）。
4. **滑动窗口维护统计**：通过双指针维护当前区间内的非关键元素种类数，动态计算贡献。

#### **解决难点**
- **快速匹配定位**：通过KMP算法在O(n+m)时间内找到所有有效区间。
- **动态统计种类数**：使用滑动窗口+桶计数技术，维护当前区间内非关键元素的种类数。
- **组合数优化计算**：预处理阶乘与逆元，实现O(1)时间查询组合数。

---

### **题解评分（≥4星）**

1. **Demeanor_Roy（★★★★☆）**
   - **亮点**：代码结构清晰，通过KMP匹配和双指针动态维护区间统计，组合数预处理规范。
   - **优化点**：桶计数实现高效统计，变量命名规范。

2. **离散小波变换°（★★★★☆）**
   - **亮点**：理论推导详细，强调区间单调性，双指针与桶计数实现简洁。
   - **优化点**：代码中的动态维护逻辑稍显复杂，但注释清晰。

3. **sangshang（★★★★☆）**
   - **亮点**：使用Z函数替代KMP进行匹配，提供不同算法视角，代码逻辑严谨。
   - **优化点**：Z函数实现稍复杂，但核心贡献计算部分高效。

---

### **最优思路与技巧提炼**

#### **关键步骤**
1. **序列重构**：提取A中的关键元素组成新序列，降低后续匹配复杂度。
2. **KMP/Z函数匹配**：快速定位所有可能的匹配区间。
3. **滑动窗口统计**：双指针维护当前区间的非关键元素种类数。
4. **组合数快速计算**：预处理阶乘与逆元，确保组合数查询O(1)。

#### **实现技巧**
- **桶计数优化**：使用数组代替哈希表统计元素出现次数，降低时间复杂度。
- **区间单调性**：匹配的区间端点递增，允许双指针单向移动，避免回溯。

---

### **同类型题与算法套路**

#### **相似算法套路**
1. **组合数学+滑动窗口**：如统计子数组满足特定条件的组合数问题。
2. **字符串匹配+动态统计**：如查找所有匹配子串后统计其上下文特征。

#### **推荐题目**
1. **P3375（KMP模板）**：练习KMP基础实现。
2. **P1495（组合数快速计算）**：预处理组合数的应用。
3. **P1886（滑动窗口极值）**：滑动窗口维护区间统计。

---

### **代码核心片段**

#### **KMP匹配与贡献计算（Demeanor_Roy）**
```cpp
// KMP预处理
for(int i=2,j=0;i<=m;i++){
    while(j&&b[i]!=b[j+1]) j=nx[j];
    if(b[i]==b[j+1]) ++j; nx[i]=j;
}
// 双指针统计
int l=1,r=0,o=0;
for(int i=1,j=0;i<=L;i++){
    while(r<p[i]){
        ++r;
        if(!vis[a[r]]) ++cnt[a[r]];
        if(!vis[a[r]] && cnt[a[r]]==1) ++o;
    }
    if(i>=m) while(l<p[i-m+1]){
        if(!vis[a[l]] && --cnt[a[l]]==0) --o;
        l++;
    }
    if(j==m) ans += C(c-o, d-o);
}
```

#### **组合数预处理**
```cpp
int fct[N], inv[N], finv[N];
void precompute(){
    fct[0] = inv[0] = finv[0] = 1;
    for(int i=1; i<N; i++){
        fct[i] = 1LL * fct[i-1] * i % MOD;
        inv[i] = (i==1) ? 1 : 1LL * (MOD-MOD/i) * inv[MOD%i] % MOD;
        finv[i] = 1LL * finv[i-1] * inv[i] % MOD;
    }
}
int C(int x, int y){
    return 1LL * fct[x] * finv[y] % MOD * finv[x-y] % MOD;
}
```

---

### **可视化设计**

#### **动画方案**
1. **像素风格展示**：
   - **KMP匹配**：以8位像素块表示字符，匹配时高亮当前比较的字符。
   - **双指针移动**：用不同颜色标记左右指针，动态显示区间扩展与收缩。
   - **桶计数更新**：当元素进入/离开区间时，显示桶内数值变化。

2. **音效提示**：
   - **匹配成功**：播放短促上扬音效。
   - **区间更新**：指针移动时触发轻微“滴答”声。
   - **贡献计算**：组合数显示时伴随合成器音效。

#### **交互控制**
- **步进控制**：允许单步执行KMP匹配或双指针移动。
- **速度调节**：滑块控制动画速度，适应不同学习节奏。
- **自动演示**：AI模式自动完成全流程，展示算法整体流程。

#### **Canvas实现**
```javascript
// 伪代码：绘制匹配区间
function drawInterval(l, r) {
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(l * BLOCK_SIZE, 0, (r-l+1)*BLOCK_SIZE, BLOCK_SIZE);
}
// 伪代码：音效触发
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}
```

---

### **个人心得摘录**

- **Demeanor_Roy**：调试时发现未清空`B[m+1]`导致越界，强调边界处理的重要性。
- **sangshang**：采用Z函数替代KMP时，需注意原序列重构的索引映射，避免偏移错误。
- **柳易辰**：区间单调性允许单向移动指针，减少冗余计算，是优化时间复杂度的关键。

---
处理用时：85.62秒
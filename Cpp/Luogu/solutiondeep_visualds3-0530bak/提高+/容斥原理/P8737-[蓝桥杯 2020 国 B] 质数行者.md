# 题目信息

# [蓝桥杯 2020 国 B] 质数行者

## 题目背景

小蓝在玩一个叫质数行者的游戏。

## 题目描述

游戏在一个 $n \times m \times w$ 的立体方格图上进行, 从北到南依次标号为第 $1$ 行到 第 $n$ 行, 从西到东依次标号为第 $1$ 列到第 $m$ 列, 从下到上依次标号为第 $1$ 层到 第 $w$ 层。

小蓝要控制自己的角色从第 $1$ 行第 $1$ 列第 $1$ 层移动到第 $n$ 行第 $m$ 列第 $w$ 层。每一步, 他可以向东走质数格、向南走质数格或者向上走质数格。每走到 一个位置, 小蓝的角色要稍作停留。

在游戏中有两个陷阱, 分别为第 $r_{1}$ 行第 $c_{1}$ 列第 $h_{1}$ 层和第 $r_{2}$ 行第 $c_{2}$ 列第 $h_{2}$ 层。这两个陷阱的位置可以跨过, 但不能停留。也就是说, 小蓝不能控制角 色某一步正好走到陷阱上，但是某一步中间跨过了陷阱是允许的。

小蓝最近比较清闲, 因此他想用不同的走法来完成这个游戏。所谓两个走法不同, 是指小蓝稍作停留的位置集合不同。

请帮小蓝计算一下，他总共有多少种不同的走法。

提示：请注意内存限制, 如果你的程序运行时超过内存限制将不得分。

## 说明/提示

**【样例说明】**

用 $(r, c, h)$ 表示第 $r$ 行第 $c$ 列第 $h$ 层, 可能的走法有以下几种:

1. $(1,1,1)-(1,3,1)-(1,6,1)-(3,6,1)-(5,6,1)$ 。

2. $(1,1,1)-(1,3,1)-(3,3,1)-(3,6,1)-(5,6,1)$ 。

3. $(1,1,1)-(1,3,1)-(3,3,1)-(5,3,1)-(5,6,1)$ 。

4. $(1,1,1)-(3,1,1)-(3,3,1)-(3,6,1)-(5,6,1)$ 。

5. $(1,1,1)-(3,1,1)-(3,3,1)-(5,3,1)-(5,6,1)$ 。

6. $(1,1,1)-(3,1,1)-(5,1,1)-(5,3,1)-(5,6,1)$ 。

7. $(1,1,1)-(3,1,1)-(5,1,1)-(5,4,1)-(5,6,1)$ 。

8. $(1,1,1)-(1,4,1)-(1,6,1)-(3,6,1)-(5,6,1)$ 。

9. $(1,1,1)-(1,6,1)-(3,6,1)-(5,6,1)$ 。

10. $(1,1,1)-(3,1,1)-(3,6,1)-(5,6,1)$ 。

11. $(1,1,1)-(3,1,1)-(5,1,1)-(5,6,1)$ 。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例 $1 \leq n, m, w \leq 50$ 。

对于 $60 \%$ 的评测用例 $1 \leq n, m, w \leq 300$ 。

对于所有评测用例, $1 \leq n, m, w \leq 1000,1 \leq r_{1}, r_{2} \leq n, 1 \leq c_{1}, c_{2} \leq m$, $1 \leq h_{1}, h_{2} \leq w$, 陷阱不在起点或终点, 两个陷阱不同。

蓝桥杯 2020 年国赛 B 组 J 题。

## 样例 #1

### 输入

```
5 6 1
3 4 1 1 2 1```

### 输出

```
11```

# AI分析结果



**算法分类**  
动态规划与组合数学、容斥原理  

---

**题解思路与算法要点**  
1. **预处理质数步数**  
   - 动态规划数组 `f[x][k]` 表示用 `k` 个质数走到位置 `x` 的方案数。  
   - 递推：`f[x][k] = Σ f[x-p][k-1]`（`p` 为质数且 `p ≤ x`）。  

2. **组合数学合并三维路径**  
   - 总路径数为三个维度步数的组合：  
     ```  
     path(x,y,z) = Σ (i+j+k)!/(i!j!k!) * f(x,i) * f(y,j) * f(z,k)  
     ```  
   - 优化为分步计算 `i+j` 和 `k`，时间复杂度从 O(n³) 降至 O(n²)。  

3. **容斥处理陷阱点**  
   - 总路径 = 全路径 - 经过陷阱1的路径 - 经过陷阱2的路径 + 同时经过两陷阱的路径（需判断两陷阱的包含关系）。  

**解决难点**  
- **组合数拆分**：将三维组合拆分为二维和，利用阶乘预处理加速。  
- **陷阱顺序**：判断两陷阱是否互相包含，决定交叉项的正负。  

---

**题解评分 (≥4星)**  
1. **meyi (5星)**  
   - 使用 `modint` 简化取模，代码结构清晰。  
   - 预处理质数更规范，避免越界风险。  

2. **HD0X (4星)**  
   - 组合数拆分思路清晰，注释详细。  
   - 预处理阶乘逆元提升效率。  

3. **Yorg (4星)**  
   - 公式推导详细，适合数学理解。  
   - 代码结构简洁，注释明确。  

---

**最优思路与技巧**  
- **阶乘优化**：预处理阶乘和逆元，快速计算组合数。  
- **路径拆分**：将三维路径拆为 `(i+j) + k`，减少重复计算。  
- **动态规划预处理**：`f[x][k]` 表示质数步数，避免每次重新计算。  

---

**同类型题目**  
1. **P5376 [THUPC2019] 过河卒二**（二维路径，质数步长）  
2. **P1373 小a和uim之大逃离**（多维动态规划）  
3. **P1436 棋盘分割**（多维组合优化）  

---

**个人心得摘录**  
- **质数预处理**：需注意质数数组的边界，避免越界。  
- **容斥陷阱顺序**：若两陷阱无包含关系，无需加回交叉项。  

---

**算法可视化设计**  
**核心步骤演示**：  
1. **三维网格绘制**：展示起点、终点及陷阱点位置。  
2. **质数跳跃动画**：高亮每一步的质数移动（如红色箭头）。  
3. **容斥过程分步显示**：  
   - 总路径（绿色）→ 减陷阱1（红色）→ 减陷阱2（蓝色）→ 加回交叉路径（黄色）。  
4. **动态规划数组更新**：侧边栏显示 `f[x][k]` 的填充过程。  

**复古像素风格**：  
- **8位色块**：起点/终点用绿/黄像素，陷阱用红/蓝闪烁方块。  
- **音效**：质数跳跃时播放“跳跃”音效，容斥步骤切换时播放不同音调。  

**交互控制**：  
- **步进按钮**：单步观察组合数拆分。  
- **速度调节**：调整质数跳跃动画速度。  

```javascript
// 示例：Canvas 绘制路径（伪代码）  
function drawPath(steps) {
  ctx.fillStyle = '#8BFF00'; // 复古绿
  steps.forEach((x, y, z) => {
    ctx.fillRect(x * 10, y * 10, 8, 8); // 8x8像素块
  });
}
// 音效触发
function playSound(effect) {
  const sfx = { jump: '01beep', trap: '02error' };
  new Audio(`8bit-${sfx[effect]}.wav`).play();
}
```

---

**核心代码片段**  
```cpp
// 预处理质数步数（meyi 题解）
V<V<mi>> f(mx+1);
For(i, mx+1) f[i].resize((i>>1)+1);
f[0][0] = 1;
FOR(i, 1, mx+1) for (int p : pri) {
  if (i - p < 0) break;
  FOR(k, 1, f[i - p].size()) f[i][k] += f[i - p][k - 1];
}

// 路径计算（HD0X 题解）
int solve(int n, int m, int w) {
  for (int sum = 0; sum <= n/2 + m/2; sum++) {
    for (int i = 0; i <= sum; i++) {
      int j = sum - i;
      aa += f[n][i] * inv[i] * f[m][j] * inv[j];
    }
    for (int k = 0; k <= w/2; k++) {
      bb += fac[sum + k] * f[w][k] * inv[k];
    }
    ans += aa * bb;
  }
  return ans;
}
```

---
处理用时：78.56秒
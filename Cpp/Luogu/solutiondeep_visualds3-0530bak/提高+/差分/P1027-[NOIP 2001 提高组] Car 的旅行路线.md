# 题目信息

# [NOIP 2001 提高组] Car 的旅行路线

## 题目描述

又到暑假了，住在城市 A 的 Car 想和朋友一起去城市旅游。  
她知道每个城市都有 $4$ 个飞机场，分别位于一个矩形的 $4$ 个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第 $i$ 个城市中高速铁路的单位里程价格为 $T_i$，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为 $t$。


![](https://cdn.luogu.com.cn/upload/image_hosting/odqxn9sz.png)

**注意**：图中并没有标出所有的铁路与航线。


那么 Car 应如何安排到城市 B 的路线才能尽可能的节省花费呢？她发现这并不是一个简单的问题，于是她来向你请教。


找出一条从城市 A 到 B 的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10$，$1\le S \le 100$，$1\le A,B \le S$。

**【题目来源】**

NOIP 2001 提高组第四题

## 样例 #1

### 输入

```
1
3 10 1 3
1 1 1 3 3 1 30
2 5 7 4 5 2 1
8 6 8 8 11 6 3```

### 输出

```
47.5```

# AI分析结果



# 【算法分类】
图论-最短路径

# 【题解思路与解决难点】

## 核心思路
1. **几何处理**：通过已知3个点推导矩形第4点，利用勾股定理判断直角顶点，中点公式计算坐标
2. **建图策略**：
   - 同一城市4机场间建立铁路边（距离×城市铁路单价）
   - 跨城市机场间建立航线边（距离×统一航空单价）
3. **最短路算法**：由于数据规模小（最多400节点），采用Floyd算法处理多源最短路

## 关键难点对比
| 难点                | 主要解决方案                                                                 |
|---------------------|----------------------------------------------------------------------------|
| 三点求第四点坐标    | 通过勾股定理判断直角顶点，利用中点公式计算对角点（时间复杂度O(1)）             |
| 跨城市边权计算      | 根据机场编号计算所属城市：机场i属于城市(i-1)/4（整数除法）                     |
| 代码实现复杂度      | 使用统一编号策略（第k城市机场编号4k-3~4k），简化城市归属判断                   |

## 可视化算法分析
![算法流程图](https://cdn.luogu.com.cn/upload/image_hosting/ohht6xr0.png)
1. **几何推导**：红色高亮三个输入点，蓝色显示计算的第四点
2. **建图过程**：绿色线段表示城市内部铁路，黄色虚线表示跨城市航线
3. **最短路更新**：以粒子动画形式展示Floyd算法的动态规划过程，高亮当前更新的中间节点k

# 【题解评分（≥4星）】

1. **_jimmywang_（5星）**
   - 亮点：最简Floyd实现，清晰的中点公式推导
   - 核心代码片段：
     ```cpp
     if(dab+dac==dbc) // 判断直角顶点
       x4 = x2 + x3 - x1; // 中点公式计算第四点
     ```

2. **LiJunze0501（4.5星）**
   - 亮点：模块化处理几何计算，独立getair4函数
   - 技巧：平方比较代替开方优化精度

3. **rediserver（4星）**
   - 亮点：结构体封装机场属性，Dijkstra+优先队列优化
   - 心得：重构代码时发现结构体设计对可读性的重要影响

# 【最优思路提炼】

1. **几何处理技巧**
   - 勾股定理判断直角：`d12² + d13² == d23²` → 顶点1为直角
   - 中点公式推导：`x4 = x2 + x3 - x1`

2. **编号映射策略**
   ```python
   # 第k城市的机场编号范围
   airport_id = 4*(k-1)+1 ~ 4*k
   # 判断所属城市
   city_id = (airport_id-1) // 4
   ```

3. **Floyd优化实现**
   ```cpp
   for(k=1~n) for(i=1~n) for(j=1~n) // 标准三重循环
     dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j])
   ```

# 【相似题目推荐】
1. P1346 电车（图论建模+最短路）
2. P3831 导航系统（几何坐标+最短路径）
3. P7916 交通规划（多源最短路+动态规划）

# 【可视化设计】
**复古像素风格演示：**
```javascript
// Canvas绘制关键步骤
ctx.fillStyle = "#8B00FF"; // 紫色像素块表示机场
ctx.fillRect(x*10, y*10, 8, 8); 

// 音效触发逻辑
function playSound(type) {
  if(type == "update") beep(440, 50);  // 路径更新音效
  if(type == "found") beep(880, 200); // 找到最优解
}

// 自动演示逻辑
let k=0;
function autoStep() {
  for(let i=0; i<400; i++)
    for(let j=0; j<400; j++)
      if(dis[i][j] > dis[i][k] + dis[k][j]) 
        highlight(i,j,k); // 高亮被更新的路径
  k = (k+1) % 400;
}
```

**交互功能：**
- 方向键控制演示速度
- A键切换自动/手动模式
- 空格键暂停/继续
- 数字键1-3切换视图模式（几何视图/边权视图/路径视图）

# 【核心代码实现】
以_jimmywang_题解的精简Floyd实现为例：
```cpp
// 计算第四个点
double dab = ds(x1,y1,x2,y2); // 距离平方
if(dab + dac == dbc) // 判断直角
  x4 = x2 + x3 - x1;

// 建图
for(int i=1; i<=s*4; i++)
  for(int j=1; j<=s*4; j++)
    if((i-1)/4 == (j-1)/4) // 同城市
      dis[i][j] = T[...] * diss(...);
    else // 不同城市
      dis[i][j] = t * diss(...);

// Floyd核心
for(int k=1; k<=s*4; k++)
  for(int i=1; i<=s*4; i++)
    for(int j=1; j<=s*4; j++)
      dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);
```

---
处理用时：78.10秒
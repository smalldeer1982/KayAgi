# 题目信息

# [NOIP 2012 提高组] 疫情控制

## 题目描述

H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。

H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。


## 说明/提示

【输入输出样例说明】

第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到$ 3$ 号点设立检查点，所需时间为 $3$ 个小时。

 
【数据范围】

保证军队不会驻扎在首都。

- 对于 $20\%$ 的数据，$2 \le n\le 10$；
- 对于 $40\%$ 的数据，$2 \le n\le 50$，$0<w <10^5$；
- 对于 $60\%$ 的数据，$2 \le n\le 1000$，$0<w <10^6$；
- 对于 $80\%$ 的数据，$2 \le n\le 10^4$；
- 对于 $100\%$ 的数据，$2\le m\le n≤5\times 10^4$，$0<w <10^9$。


NOIP 2012 提高组 第二天 第三题


## 样例 #1

### 输入

```
4 
1 2 1 
1 3 2 
3 4 3 
2 
2 2```

### 输出

```
3```

# AI分析结果



## 算法分类
**二分答案**

---

## 题解思路与核心难点

### 核心思路
1. **二分答案框架**：通过二分确定最小可行时间。
2. **树上倍增预处理**：快速计算军队移动到根节点的路径和时间。
3. **贪心策略**：军队尽可能向上移动，剩余时间匹配未覆盖子树。

### 解决难点
- **子树覆盖判断**：通过DFS标记未被覆盖的子树。
- **跨子树分配**：优先用剩余时间少的军队覆盖较近的子树，采用排序+双指针优化匹配效率。
- **时间复杂度控制**：倍增预处理O(n log n)，验证过程O(m log n)，整体复杂度O(n log n log max_w)。

---

## 题解评分（≥4星）

1. **TEoS (5星)**  
   - 代码结构清晰，详细注释。  
   - 完整展示预处理、二分、贪心匹配全流程。  
   - 提供样例数据与调试思路。  

2. **Siyuan (4.5星)**  
   - 代码简洁，逻辑紧凑。  
   - 使用pair存储闲置军队，匹配策略高效。  
   - 缺少部分中间步骤的详细说明。  

3. **qwaszx (4星)**  
   - 实现简洁，优化匹配逻辑。  
   - 通过set维护剩余时间，提高贪心效率。  
   - 部分代码可读性稍差。

---

## 最优思路与技巧

### 关键步骤
1. **倍增预处理**  
   - 预处理每个节点的2^k祖先及路径长度，实现快速上跳。
2. **军队移动策略**  
   - 对于每个军队，在二分时间内尽量上跳至根节点附近。
3. **子树覆盖判断**  
   - DFS遍历子树，标记未被覆盖的节点。
4. **贪心匹配**  
   - 将可调度军队按剩余时间排序，与未覆盖子树按距离排序后双指针匹配。

### 核心代码（验证函数）
```cpp
bool check(ll lim) {
    memset(sta, 0, sizeof(sta));
    vector<pair<ll, int>> h; // {剩余时间, 所在子树}
    vector<ll> ned; // 未覆盖子树距离

    // 军队上跳处理
    for (int i = 1; i <= m; i++) {
        int x = army[i];
        ll sum = 0;
        // 倍增上跳至lim时间内能到的最高点
        for (int j = 16; j >= 0; j--)
            if (f[x][j] > 1 && sum + dist[x][j] <= lim)
                sum += dist[x][j], x = f[x][j];
        
        if (f[x][0] == 1 && sum + dist[x][0] <= lim) // 可到根
            h.emplace_back(lim - sum - dist[x][0], x);
        else // 无法到根，直接驻扎
            sta[x] = true;
    }

    // DFS标记未覆盖子树
    function<bool(int)> dfs = [&](int u) {
        if (sta[u]) return true;
        bool is_leaf = true;
        for (auto v : tree[u]) {
            if (v == fa[u]) continue;
            if (!dfs(v)) return false;
            is_leaf = false;
        }
        return !is_leaf; // 非叶子节点需所有子树覆盖
    };

    for (auto son : root_son) // 根的直接子节点
        if (!dfs(son)) ned.push_back(son_dist[son]);

    // 贪心匹配
    sort(h.begin(), h.end());
    sort(ned.begin(), ned.end());
    int i = 0, j = 0;
    while (i < h.size() && j < ned.size()) {
        if (h[i].first >= ned[j]) j++;
        i++;
    }
    return j >= ned.size();
}
```

---

## 类似题目推荐
1. **P2680 [NOIP2015 提高组] 运输计划**  
   - 二分+树上差分，处理路径删除问题。
2. **P5021 [NOIP2018 提高组] 赛道修建**  
   - 树形结构+二分答案，贪心拼接路径。
3. **P1083 [NOIP2012 提高组] 借教室**  
   - 二分答案+差分数组验证，基础二分模型。

---

## 可视化设计

### 动画演示方案
1. **树结构绘制**  
   - 使用Canvas绘制树形结构，根节点居中，子树呈放射状分布。
2. **军队移动高亮**  
   - 当前验证的军队显示为红色方块，移动路径以黄色高亮。
3. **覆盖状态标记**  
   - 已覆盖子树显示绿色，未覆盖显示红色，匹配过程动态更新。
4. **双指针匹配过程**  
   - 左右两个排序列表（军队时间/子树距离），指针移动时显示匹配连线。

### 复古像素风格
- **颜色方案**：16色调色板（根节点亮蓝，军队橙色，覆盖绿/未覆盖红）。
- **音效**：军队移动时触发8-bit脚步声，匹配成功播放上升音阶。
- **自动演示**：按帧逐步执行二分、上跳、DFS标记、贪心匹配步骤，速度可调。

---

## 总结
通过二分答案框架结合树上倍增预处理，高效解决军队调度问题。贪心匹配策略通过排序优化时间复杂度，可视化设计增强算法过程理解，适合教学与竞赛复习。

---
处理用时：83.01秒
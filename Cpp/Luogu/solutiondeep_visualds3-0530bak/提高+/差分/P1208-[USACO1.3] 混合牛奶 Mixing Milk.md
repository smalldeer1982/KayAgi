# 题目信息

# [USACO1.3] 混合牛奶 Mixing Milk

## 题目描述

由于乳制品产业利润很低，所以降低原材料（牛奶）价格就变得十分重要。帮助 Marry 乳业找到最优的牛奶采购方案。

Marry 乳业从一些奶农手中采购牛奶，并且每一位奶农为乳制品加工企业提供的价格可能相同。此外，就像每头奶牛每天只能挤出固定数量的奶，每位奶农每天能提供的牛奶数量是一定的。每天 Marry 乳业可以从奶农手中采购到小于或者等于奶农最大产量的整数数量的牛奶。

给出 Marry 乳业每天对牛奶的需求量，还有每位奶农提供的牛奶单价和产量。计算采购足够数量的牛奶所需的最小花费。

注：每天所有奶农的总产量不少于 Marry 乳业的需求量。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据：  
$0 \le n,a_i \le 2 \times 10^6$，$0\le m \le 5000$，$0 \le p_i \le 1000$

题目翻译来自 NOCOW。

USACO Training Section 1.3

## 样例 #1

### 输入

```
100 5
5 20
9 40
3 10
8 80
6 30
```

### 输出

```
630
```

# AI分析结果



### 【算法分类】  
贪心算法

---

### 【题解思路与解决难点】  
**核心思路**：优先购买单价最低的牛奶，直到满足需求。  
**关键步骤**：  
1. **排序**：按单价从小到大排序奶农列表，单价相同时产量高的优先（部分题解忽略此优化）。  
2. **批量购买**：依次购买当前最低单价奶农的全部产量，直到剩余需求不足时仅购买所需量。  
**解决难点**：  
- **高效处理大数据**：使用桶排序（价格范围有限时）或快速排序（通用场景），避免逐次减法。  
- **边界处理**：需处理需求为0或奶农产量恰好满足需求的边界情况。  

---

### 【题解评分 (≥4星)】  
1. **青陌 (4.5星)**  
   - **亮点**：简洁的批量购买逻辑，利用排序后直接累加，代码可读性强。  
   - **代码片段**：  
     ```cpp  
     if (tot + milk[i].a <= n) {  
         tot += milk[i].a;  
         sum += milk[i].p * milk[i].a;  
     } else {  
         sum += (n - tot) * milk[i].p;  
         break;  
     }  
     ```  

2. **远航之曲 (5星)**  
   - **亮点**：桶排序优化，时间复杂度降至 `O(max_price)`，适合价格范围小的场景。  
   - **代码片段**：  
     ```cpp  
     for (i=0; sum < n; i++) {  
         if (sum + G[i] <= n) {  
             sum += G[i];  
             cost += i * G[i];  
         } else {  
             cost += (n - sum) * i;  
             sum = n;  
         }  
     }  
     ```  

3. **yzx4188 (4星)**  
   - **亮点**：不排序，每次遍历找当前最低价，适合理解贪心本质。  
   - **代码片段**：  
     ```cpp  
     int minp = 0;  
     for (int i=1; i<m; i++)  
         if (p[i] < p[minp]) minp = i;  
     ```  

---

### 【最优思路提炼】  
- **桶排序法**：当单价范围有限（如 `p_i ≤ 1000`），用数组累计各价格的产量，遍历时直接按价格升序购买，时间复杂度 `O(m + max_price)`。  
- **批量处理逻辑**：减少逐次减法，直接计算整块购买量。  

---

### 【同类型题与算法套路】  
- **通用贪心套路**：优先选择局部最优（如最小单价、最大性价比）。  
- **类似题目**：区间调度问题、部分背包问题。  

---

### 【推荐题目】  
1. P1090（合并果子，优先队列贪心）  
2. P2240（部分背包问题）  
3. P1223（排队接水，时间安排贪心）  

---

### 【个人心得摘录】  
- **边界陷阱**：多篇题解强调处理 `n=0` 的情况，否则会错误累加。  
- **调试经验**：测试极端数据（如 `n=0`, `m=0`）验证代码鲁棒性。  

---

### 【可视化算法演示】  
**动画设计**：  
1. **像素风格界面**：奶农按价格从低到高排列为像素方块，颜色深浅表示产量。  
2. **购买过程**：高亮当前购买的奶农方块，显示剩余需求进度条，购买时播放“金币音效”。  
3. **交互控制**：  
   - **步进按钮**：单步执行购买操作。  
   - **速度调节**：滑动条控制动画速度。  
4. **复古音效**：  
   - **购买音效**：8-bit 短音效。  
   - **完成音效**：上扬旋律提示任务完成。  

**核心代码片段 (JavaScript)**：  
```javascript  
// 桶排序初始化  
let buckets = new Array(1001).fill(0);  
farmers.forEach(f => buckets[f.price] += f.amount);  

// 贪心购买动画  
function nextStep() {  
    if (remaining <= 0) return;  
    let currentPrice = lowestUnusedPrice();  
    let buyAmount = Math.min(remaining, buckets[currentPrice]);  
    totalCost += buyAmount * currentPrice;  
    remaining -= buyAmount;  
    updateVisuals(currentPrice, buyAmount);  
}  
```  

---

**结论**：贪心策略下，桶排序法在价格范围有限时最优，快速排序法通用性强，避免逐次减法可显著提升效率。

---
处理用时：73.42秒
# 题目信息

# 「Wdsr-2.7」天才⑨与数学递推式

## 题目描述

生活在雾之湖的冰精琪露诺，向来以智慧而著称。作为寺子屋的老学员，琪露诺可是对数学递推式了如指掌。

有一天，慧音老师想要考一考琪露诺。于是她写出了一个长度为 $m$ 的递推公式：

$$F_t=\sum_{i=1}^m K_i\times F_{t-i} \quad (t> m)$$

其中 $m,\{K_i\}$ 都是被给定的。不过，由于这个序列 $\{F_i\}$ 的初始 $m$ 项并没有被确定，所以可能存在无穷个满足这个递推式，但是初始 $m$ 项并不一致的递推数列。慧音打算选择其中 $q$ 个 $F$ ，来考考琪露诺对数列知识的掌握。

具体而言，慧音会依次告诉琪露诺，若干个 $\{F_i\}$ 的起始 $m$ 项。显然，这样就能生成无穷序列 $\{F_i\}$ 了。尽管如此，生成这么多序列并不好玩。于是慧音又创造了一个答案序列 $\{A_i\}$ ，满足初始时 $A_i=0$ 。

每当给出一个新的 $\{F_i\}$ ，慧音都要琪露诺使 $\{A_i\}$ 的第 $a,a+1,\cdots b-1,b$ 项分别加上 $F_1,F_2,F_3,\cdots,F_{b-a+1}$ 。

当然，慧音老师不想为难琪露诺，于是对于所有数字，只要输出其对 $p$ 取模的值即可。其中 $p$ 是一个被给定的常数。

---

形式化地讲述题面：给定 $n,q,m,p,\{K_1,K_2,\cdots ,K_m\}$ 。有 $q$ 次操作，每次给定一组 $a,b,\{G_1,G_2\cdots G_m\}$ ，求出无穷序列 $\{F_i\}$ ：

$$F_t=\begin{cases}
G_t & t\le m \cr
\sum_{i=1}^m K_iF_{t-i} & t>m
\end{cases}$$

然后令 $\forall i\in [a,b] ,A_i\gets A_i+F_{i-a+1}$ 。最后分别输出 $\{A_i\}$ 的前 $n$ 项对 $p$ 取模后的结果。

## 说明/提示

#### 样例解释

对于样例 $1$ ：

- 初始时， $\{A_i\}=\{0,0,0,0,0\}$。

- 第一步生成了一个 $\{F_i\}=\{1,1,2,3,5\}$ ，加至 $A_1,A_2,A_3$，此时 $\{A_i\}=\{1,1,2,0,0\}$。

- 第二步生成了一个 $\{F_i\}=\{1,1,2,3,5\}$ ，加至 $A_2,A_3,\cdots ,A_5$，此时 $\{A_i\}=\{1,2,3,2,3\}$。

- 第三步生成了一个 $\{F_i\}=\{2,0,2,2,4\}$ ，加至 $A_1,A_2,\cdots ,A_5$，此时 $\{A_i\}=\{3,2,5,4,7\}$。

对于样例 $2$ ，我们既没有一个绝妙的解释，又没有足够大的空间，于是我们写不下了。

#### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n} & \bm{m} & \bm{q}& \textbf{分值}\cr\hline
1 & n\le  10^4 & m\le 10 & q\le 10^3 & 10 \cr\hline
2 & n\le  10^5 & m=1 & q\le 10^5  & 20\cr\hline
3 & n\le  10^5 & m=2 & q\le 10^5 & 20\cr\hline
4 & \text{无特殊限制} & \text{无特殊限制} & \text{无特殊限制}& 50 \cr\hline
\end{array}$$

- 对于 $100\%$ 的数据，满足 $ 1 \leq n\le 1\times 10^6;1\le q \leq 1.2 \times 10^5;1 \leq m \leq 15;1 \leq K_i,G_i,p \leq 10^8;1\le a\le b\le n$ 。

## 样例 #1

### 输入

```
5 3 2 114514
1 1
1 3 1 1
2 5 1 1
1 5 2 0```

### 输出

```
3 2 5 4 7```

## 样例 #2

### 输入

```
20 5 4 1919810
2 5 4 3
1 20 1 1 1 1
5 12 7 6 1 2
2 18 9 0 0 1
9 11 5 4 4 1
10 14 1 0 0 0```

### 输出

```
1 10 1 1 22 75 221 850 3176 11706 43324 160379 586060 249707 351705 931555 619201 372869 1800119 1750063
```

# AI分析结果



## 算法分类
线性代数与差分标记

---

## 综合分析与结论

### 核心思路与算法流程
1. **线性叠加性质**：利用递推式的线性性质，将多个操作的影响合并为对基础数组 S 的差分标记。
2. **修正初始序列**：将输入的初始 G 序列调整为修正序列 F_mathring，使得其生成的递推数列前 m 项恰好为 G。
3. **差分标记优化**：将每个操作的影响拆分为起始 a 处的正向修正和结束 b 处的反向修正，利用预处理的基础递推序列 E 计算影响范围。
4. **最终递推计算**：通过一次 O(nm) 的递推，将差分标记数组 S 转化为答案数组 A。

### 解决难点
- **无限序列截断**：通过反向修正抵消超出区间 [a,b] 的影响。
- **高效处理多次操作**：将每个操作的 O(m) 标记替代 O(b-a+1) 的直接计算，总复杂度降至 O(qm + nm)。

### 可视化设计
- **动画方案**：展示差分标记如何施加到数组 S，以及递推计算时每个位置如何累积贡献。
- **颜色标记**：
  - 红色高亮当前操作的 a 和 b 位置。
  - 绿色表示正向修正 (X)，蓝色表示反向修正 (Y)。
  - 递推时动态显示 S 数组的更新过程。
- **复古像素风格**：用 8-bit 像素网格表示数组，每次操作用闪光特效，递推时像素块按列亮起。

---

## 题解评分（≥4星）
1. **囧仙的题解（★★★★★）**
   - 利用线性叠加性质将操作合并，时间复杂度优化显著。
   - 代码简洁，预处理 E 数组与差分标记的应用巧妙。
   - 反向调整初始序列的思路极具启发性。

---

## 最优思路提炼
1. **线性叠加转换**：将每个操作的无穷序列影响转化为有限差分标记。
2. **预处理基础序列 E**：快速计算任意位置对后续项的贡献。
3. **反向修正抵消**：利用差分标记在区间末尾抵消超出的影响。

---

## 类似题目推荐
1. **P5488 差分与前缀和**：利用生成函数处理多次操作的前缀和。
2. **P4723 常系数齐次线性递推**：快速计算线性递推数列的某一项。
3. **P1438 无聊的数列**：差分标记处理区间等差数列操作。

---

## 个人心得摘录
- **调试关键**：验证修正后的初始序列是否生成正确的 F 前 m 项。
- **思维突破**：将无限序列截断视为反向施加影响，而非直接计算有限项。

---

## 核心代码实现
```cpp
// 预处理基础序列 E
T[0] = 1;
for (int i = 1; i <= n + m; ++i) {
    for (int j = 1; j <= m; ++j) {
        if (i - j >= 0) {
            T[i] = mod(1ll * T[i - j] * K[j] + T[i]);
        }
    }
}

// 处理每个操作
while (q--) {
    // 读取a,b和初始G，计算修正后的X数组
    for (int j = 1; j <= m; ++j) {
        X[j] = G[j];
        for (int k = 1; k < j; ++k) {
            X[j] = mod(-1ll * X[j - k] * K[k] + X[j]);
        }
    }
    // 计算反向修正Y数组
    for (int j = 1; j <= m; ++j) {
        for (int k = 1; k <= m; ++k) {
            int pos = b - a + k - j;
            if (pos >= 0) Y[k] = mod(-1ll * X[j] * T[pos] + Y[k]);
        }
    }
    // 应用差分标记
    for (int j = 1; j <= m; ++j) {
        D[a + j - 1] = mod(D[a + j - 1] + X[j]);
        D[b + j - 1] = mod(D[b + j - 1] + Y[j]);
    }
}

// 最终递推计算答案
for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
        if (i - j > 0) {
            D[i] = mod(1ll * D[i - j] * K[j] + D[i]);
        }
    }
}
```

---

## 可视化方案设计
1. **像素网格渲染**：用 Canvas 绘制 n 列像素，每列高度表示 A[i] 的值。
2. **操作高亮**：当处理第 k 个操作时，a~a+m 和 b~b+m 区域闪烁黄色边框。
3. **递推动画**：从左到右逐列计算，当前处理列显示红色光标，已更新列渐变为绿色。
4. **音效设计**：
   - 应用差分标记时播放 "ping" 音效。
   - 完成所有操作时播放 8-bit 胜利旋律。
5. **交互控制**：可暂停观察当前 S 数组状态，单步执行查看每个操作的影响。

---
处理用时：67.29秒
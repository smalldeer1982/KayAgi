# 题目信息

# 「CGOI-1」收税

## 题目背景

~~签到题~~

由于举办选丑大赛消耗了太多钱财，ac 决定派出 Push_Y 去收税。

## 题目描述

丑国由 $n$ 座城市组成，编号 $1$ 的为首都。这 $n$ 座城市由 $n-1$ 条长度为 $1$ 的双向道路连接。从编号为 $x$ 的城市出发，往**远离**首都的方向（即往儿子节点走），距离不超过 $h$ 的就是这座城市要收税的范围。

第 $i$ 座城市将要上缴 $a_i$ **元**的所得税。但由于收税官 Push_Y 很喜欢异或，因此每座城市最终上缴的所得税将是在其收税范围内每座城市**应缴税额**的异或和。

Push_Y 将向你提出 $m$ 个询问，他将问你城市 $x$ 在收税距离为 $h$ 时将收到多少**千元**的所得税。

**简化版题意：**

给定一棵 $n$ 个点的树，根节点为 $1$ 号点，第 $i$ 个点的点权为 $a_i$，$dep_u$ 表示 $u$ 点的深度，根节点的深度为 $1$，$q$ 次询问，每次给定两个整数 $x,h$，表示询问 $\bigoplus_{u\in son(x)\land dep_u-dep_x\le h}a_i$ 除以 $1000$ 后的值。

其中 $\bigoplus_{i=1}^ni$ 表示 $1\operatorname{xor} 2\operatorname{xor}\cdots\operatorname{xor} n$。

此处 $\land$ 是“且”，$\operatorname{xor}$ 是异或。

## 说明/提示

对于 $30\%$ 的数据，$1\le n,m\le 10^3$。

对于 $70\%$ 的数据，$1\le n,m\le5 \times 10^4$。其中有 $20\%$ 的数据是链。

对于 $100\%$ 的数据，$1\le n,m\le 10^6$，$1 \le a_i \le 10^9$，$1\le x \le n$，$0 \le h \le n$。

## 样例 #1

### 输入

```
6 3
604 545 402 378 25 13
1 2 2 3 3
1 2
3 0
2 4```

### 输出

```
0.149
0.402
0.733```

## 样例 #2

### 输入

```
6 3
6 5 4 3 2 1
1 2 2 3 3
1 2
3 0
2 4```

### 输出

```
0.004
0.004
0.001```

# AI分析结果



---

## 唯一算法分类  
**可持久化线段树（主席树）**

---

## 综合分析与结论  

### 题目核心逻辑  
计算以节点 x 为根的子树中，深度不超过 h 的所有节点权值的异或和。需高效处理 1e6 规模的树和查询。

### 关键难点与解决方案  
1. **子树与深度的双重约束**：  
   - 通过 **DFS 序**将子树转化为区间，结合可持久化线段树按深度维护异或值，实现区间查询。  
   - 使用 **前缀异或** 思想，用两个版本（ed[x] 和 dfn[x]-1）的异或差得到子树结果。  

2. **大规模数据优化**：  
   - 离线处理结合 **树状数组** 动态维护深度异或和，通过 DFS 遍历的时序特性实现差分计算。  
   - 预处理每个节点的子树异或和 s，利用 **分层线段树** 快速排除超深节点的影响。

### 核心算法流程（主席树）  
1. **预处理**：DFS 遍历树，记录每个节点的 DFS 序、子树结束序、深度。  
2. **建树**：按 DFS 序构建主席树，每个版本维护当前深度异或值。  
3. **查询**：对区间 [dfn[x], ed[x]]，查询两版本在深度 [dep[x], dep[x]+h] 的异或差。  

### 可视化设计思路  
- **动画效果**：  
  1. 展示树的 DFS 遍历过程，高亮当前节点及其 DFS 序。  
  2. 动态绘制主席树版本链，插入新节点时标记颜色变化。  
  3. 查询时用对比色标出区间和深度范围，模拟异或差计算。  
- **复古风格**：  
  - 用 8 位像素风格绘制树结构，线段树节点以方块表示，异或操作用闪烁特效。  
  - 音效：插入节点时播放“滴”声，查询完成时播放上扬音调。  

---

## 题解清单（≥4星）  

### 1. lenlen（4.5⭐）  
**关键亮点**：  
- 使用主席树将子树查询转化为区间操作，代码结构清晰。  
- 通过 DFS 序和深度双重维度维护数据，逻辑严密。  
**核心代码**：  
```cpp  
int ask(int u, int v, int l, int r, int x, int y) {  
    if (l == x && r == y) return t[u].sum ^ t[v].sum;  
    int mid = l + r >> 1;  
    if (y <= mid) return ask(t[u].l, t[v].l, l, mid, x, y);  
    else if (x > mid) return ask(t[u].r, t[v].r, mid+1, r, x, y);  
    else return ask(t[u].l, t[v].l, l, mid, x, mid) ^  
                ask(t[u].r, t[v].r, mid+1, r, mid+1, y);  
}  
```

### 2. ☯☯枫☯☯（4.5⭐）  
**关键亮点**：  
- 提供树状数组离线与线性两种解法，覆盖不同场景。  
- 线性解法利用前缀异或和，时空复杂度极优。  
**核心代码**：  
```cpp  
void solve(int u, int d) {  
    for (auto q : ask[u]) ans[q.id] ^= sum[d + q.h + 1];  
    sub[u] = w[u];  
    for (int v : children[u]) {  
        solve(v, d + 1);  
        sub[u] ^= sub[v];  
    }  
    sum[d] ^= sub[u];  
    for (auto q : ask[u]) ans[q.id] ^= sub[u] ^ sum[d + q.h + 1];  
}  
```

### 3. light_searcher（4⭐）  
**关键亮点**：  
- 分层线段树预处理子树异或和，查询时直接排除超深节点。  
- 代码简洁，常数优化较好。  
**核心代码**：  
```cpp  
int query(int x, int h) {  
    return s[x] ^ query_layer(dep[x] + h + 1, st[x], ed[x]);  
}  
```

---

## 最优思路提炼  
**离线树状数组差分法**：  
1. **DFS 遍历时序**：利用 DFS 进入和回溯的时机，记录异或前缀。  
2. **动态更新**：进入节点时插入权值，回溯时计算差分结果。  
3. **时间复杂度**：O(n log n)，空间 O(n)，适合大规模数据。  

---

## 同类型题推荐  
1. **P2633 Count on a tree**（主席树应用）  
2. **P3384 轻重链剖分**（子树与路径操作）  
3. **P4219 [BJOI2014] 大融合**（动态树与子树查询）  

---

## 个人心得摘录  
- **lenlen**：主席树的版本链需按 DFS 序构建，而非原节点编号，需注意 `re[]` 映射。  
- **☯☯枫☯☯**：离线处理中，“差分”思想可将子树问题转化为全局前缀操作，减少重复计算。  

---

## 可视化代码片段（复古风格）  
```javascript  
class RetroVisualizer {  
    constructor(canvas) {  
        this.ctx = canvas.getContext('2d');  
        this.colors = ['#000', '#F00', '#0F0', '#00F', '#FF0']; // 8-bit调色板  
    }  

    drawNode(x, y, depth, value) {  
        this.ctx.fillStyle = this.colors[depth % 5];  
        this.ctx.fillRect(x * 30, y * 30, 25, 25); // 像素方块  
        this.ctx.fillText(value, x*30+3, y*30+12);  
    }  

    playSound(effect) {  
        const osc = new OscillatorNode(ctx, {type: 'square'});  
        osc.frequency.value = effect === 'xor' ? 440 : 880;  
        osc.connect(ctx.destination);  
        osc.start(); osc.stop(ctx.currentTime + 0.1);  
    }  
}  
```

---
处理用时：104.72秒
# 题目信息

# [ZJOI2007] 报表统计

## 题目描述

小 Q 的妈妈是一个出纳，经常需要做一些统计报表的工作。今天是妈妈的生日，小 Q 希望可以帮妈妈分担一些工作，作为她的生日礼物之一。

经过仔细观察，小 Q 发现统计一张报表实际上是维护一个非负整数数列，并且进行一些查询操作。

在最开始的时候，有一个长度为 $n$ 的整数序列 $a$，并且有以下三种操作：
        
- `INSERT i k`：在原数列的第 $i$ 个元素后面添加一个新元素 $k$；如果原数列的第 $i$ 个元素已经添加了若干元素，则添加在这些元素的最后（见样例说明）。
- `MIN_GAP`：查询相邻两个元素的之间差值（绝对值）的最小值。
- `MIN_SORT_GAP`：查询所有元素中最接近的两个元素的差值（绝对值）。

于是小 Q 写了一个程序，使得程序可以自动完成这些操作，但是他发现对于一些大的报表他的程序运行得很慢，你能帮助他改进程序么？

## 说明/提示

#### 样例输入输出 1 解释

一开始的序列为 $\{5,3,1\}$。

执行操作 `INSERT 2  9` 将得到 $\{5,3,9,1\}$，此时 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $2$。

再执行操作 `INSERT 2  6` 将得到：$\{5,3, 9, 6, 1\}$。

注意这个时候原序列的第 $2$ 个元素后面已经添加了一个 $9$，此时添加的 $6$ 应加在 $9$ 的后面。这个时候 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $1$。

---


#### 数据规模与约定

对于全部的测试点，保证 $2 \le n, m \le 5\times10^5$，$1 \leq i \leq n$，$0 \leq a_i, k \leq 5 \times 10^8$。

## 样例 #1

### 输入

```
3 5
5 3 1
INSERT 2 9
MIN_SORT_GAP
INSERT 2 6
MIN_GAP
MIN_SORT_GAP
```

### 输出

```
2
2
1
```

# AI分析结果



### 算法分类
数据结构应用（平衡树、堆、multiset）

---

### 题解思路与核心难点分析
#### 核心问题拆解
1. **MIN_GAP**（相邻元素最小差）
   - 动态维护插入操作影响的相邻差值（删除旧差值，插入新差值）
   - 高效数据结构需支持：插入、删除、查询最小值

2. **MIN_SORT_GAP**（全局元素最小差）
   - 维护所有元素的排序集合，插入时计算与前驱/后继的差值
   - 关键操作：前驱查询、后继查询、插入

#### 题解对比与关键实现
| 题解方案               | 数据结构                          | 时间复杂度 | 实现复杂度 | 核心优化点                     |
|-------------------------|-----------------------------------|------------|------------|--------------------------------|
| 双multiset（cmd2001）   | `multiset`维护差值/元素集合       | O(mlogn)  | 低         | 利用STL特性快速处理插入删除     |
| 平衡树+堆（周道）       | Treap+左偏树                     | O(mlogn)  | 高         | 手写数据结构优化常数           |
| 双堆+平衡树（万弘）     | 堆维护差值、平衡树维护全局元素     | O(mlogn)  | 中         | 堆实现可删除差值               |
| 线段树+平衡树（Jμdge）  | 线段树维护相邻差，平衡树维护全局   | O(mlogn)  | 高         | 线段树优化区间差值查询          |

#### 解决难点
1. **动态差值更新**：插入元素时需删除旧差值 `|a_i - a_{i+1}|`，新增 `|a_i - new|` 和 `|new - a_{i+1}|`
2. **前驱/后继快速查询**：平衡树或`multiset`的`lower_bound`实现O(logn)查询
3. **堆的懒惰删除**：通过双堆（有效堆+删除堆）实现伪删除，保持堆顶有效性

---

### 题解评分（≥4星）
1. **cmd2001（5星）**
   - **亮点**：STL的极致简化，仅用2个multiset和1个变量
   - **代码片段**：
     ```cpp
     multiset<int> delta, full; // delta:相邻差, full:所有元素
     void replac(int pos, int x) {
         delta.insert(abs(x - ed[pos]));
         if (pos != n) {
             delta.erase(delta.find(abs(st[pos+1] - ed[pos])));
             delta.insert(abs(st[pos+1] - x));
         }
         ed[pos] = x;
     }
     ```

2. **Jμdge（4星）**
   - **亮点**：STL堆+集合的优雅组合，代码可读性强
   - **核心逻辑**：
     ```cpp
     struct Heap{ // 可删除堆
         priority_queue<int> q1, q2;
         void push(int x) { q1.push(-x); }
         void erase(int x) { q2.push(-x); }
         int top() {
             while (q2.size() && q1.top() == q2.top()) 
                 q1.pop(), q2.pop();
             return -q1.top();
         }
     };
     ```

3. **万弘（4星）**
   - **亮点**：左偏树优化差值维护，Treap维护全局元素
   - **关键代码**：
     ```cpp
     inline int Merge(int x, int y) { // 左偏树合并
         if (!x || !y) return x | y;
         if (key[x] > key[y]) swap(x, y);
         tr[x] = Merge(tr[x], y);
         if (dis[tl[x]] < dis[tr[x]]) swap(tl[x], tr[x]);
         dis[x] = dis[tr[x]] + 1; return x;
     }
     ```

---

### 可视化与算法演示
#### 动画设计方案
1. **数据结构可视化**：
   - **相邻差值**：用线段连接相邻元素，插入时旧线段变红消失，新线段绿色出现
   - **全局元素**：元素在数轴上排序，插入时高亮前驱（蓝色）和后继（橙色）

2. **操作流程演示**：
   ```plaintext
   [初始序列] 5-3-1
   INSERT 2 9 → 序列变为5-3-9-1
   MIN_GAP: |3-9|=6 → 更新为2（原|9-1|=8）
   MIN_SORT_GAP: 插入9后，与5差4，与3差6，与1差8 → 最小差2（|5-3|）
   ```

3. **复古像素风格实现**：
   - **Canvas绘制**：8-bit风格数轴，元素用像素方块表示
   - **音效触发**：
     - 插入时播放“哔”声（Web Audio API）
     - 查询时播放“叮”声
   - **交互控制**：方向键控制插入位置，空格键触发查询

---

### 同类型题目推荐
1. [P2234 HNOI2002] 营业额统计（平衡树前驱/后继）
2. [P3871 TJOI2010] 中位数（动态维护有序序列）
3. [P1486 NOI2004] 郁闷的出纳员（平衡树区间操作）

---

### 个人心得摘录
> "调试时发现`multiset`直接`erase(value)`会删除所有相同元素，必须用迭代器删除。血的教训！"  
> —— 题解作者调试记录

> "手写Treap比STL快3倍，但代码量多200行，竞赛需权衡时间与正确率"  
> —— 算法优化总结

---

### 核心代码实现（cmd2001方案）
```cpp
#include <set>
using namespace std;
const int maxn = 5e5 + 10;
multiset<int> delta, full;
int st[maxn], ed[maxn], srt = 1e9;

void update_srt(int x) {
    auto it = full.lower_bound(x);
    srt = min(srt, min(*it - x, x - *--it));
    full.insert(x);
}

void replac(int pos, int x) {
    delta.insert(abs(x - ed[pos]));
    if (pos != maxn - 1) {
        delta.erase(delta.find(abs(st[pos+1] - ed[pos])));
        delta.insert(abs(st[pos+1] - x));
    }
    ed[pos] = x;
}

int main() {
    // 初始化及操作处理
    full.insert(1e9), full.insert(-1e9);
    while (m--) {
        if (op == "INSERT") {
            int pos, x; 
            replac(pos, x);
            update_srt(x);
        } else if (op == "MIN_GAP") 
            printf("%d\n", *delta.begin());
        else 
            printf("%d\n", srt);
    }
}
```

---

### 可视化代码片段（Canvas动画）
```javascript
// 绘制插入操作（伪代码）
function drawInsert(pos, val) {
    ctx.fillStyle = '#FF0000'; // 红色标记旧差值
    drawLine(pos, ed[pos], pos+1, st[pos+1]);
    ctx.fillStyle = '#00FF00'; // 绿色绘制新差值
    drawLine(pos, val, pos+1, st[pos+1]);
    playSound('insert.wav'); // 触发音效
}
```

---
处理用时：93.51秒
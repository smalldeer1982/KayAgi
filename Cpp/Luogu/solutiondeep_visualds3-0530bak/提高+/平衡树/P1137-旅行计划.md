# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果



# 算法分类
**拓扑排序 + 动态规划**

---

## 题解思路与核心分析

### **核心算法逻辑**
1. **拓扑排序**：将有向无环图（DAG）转化为线性序列，确保每个节点在处理时其所有前驱节点已处理完毕。
2. **动态规划**：利用拓扑序无后效性的特点，递推每个节点的最长路径值。状态转移方程为：  
   `dp[v] = max(dp[v], dp[u] + 1)`，其中 `u` 是 `v` 的前驱节点。

### **解决难点**
- **无后效性保证**：拓扑排序确保处理顺序满足动态规划的无后效性。
- **初始条件**：入度为0的节点（起点）初始化为1（自身）。
- **高效更新**：在拓扑排序过程中直接更新邻接点的 `dp` 值，避免二次遍历。

---

## 题解评分（≥4星）

### **题解1：星星之火（4.5星）**
- **亮点**：详细解释拓扑排序与DP的结合原理，代码清晰，逻辑严密。
- **代码片段**：
  ```cpp
  void topsort() {
      queue<int> q;
      for (int i=1; i<=n; i++)
          if (ru[i]==0) q.push(i);
      while (!q.empty()) {
          int u = q.front(); q.pop();
          for (Edge* e = head[u]; e; e = e->next) {
              int v = e->to;
              dp[v] = max(dp[v], dp[u]+1);
              if (--ru[v] == 0) q.push(v);
          }
      }
  }
  ```

### **题解2：_ZZH（4星）**
- **亮点**：代码简洁，将拓扑排序与DP合并为一个循环，减少代码量。
- **代码片段**：
  ```cpp
  for(int i=1; i<=n; i++) 
      if (in[i]==0) q.push(i), dp[i]=1;
  while (!q.empty()) {
      int u = q.front(); q.pop();
      for (Edge e : adj[u]) {
          dp[e.to] = max(dp[e.to], dp[u]+1);
          if (--in[e.to] == 0) q.push(e.to);
      }
  }
  ```

### **题解3：meowla（4星）**
- **亮点**：使用反向图+记忆化搜索，提供另一种视角，适合理解递归思维。
- **代码片段**：
  ```cpp
  int dfs(int x) {
      if (dp[x]) return dp[x];
      dp[x] = 1;
      for (int y : reverse_adj[x]) 
          dp[x] = max(dp[x], dfs(y)+1);
      return dp[x];
  }
  ```

---

## 最优技巧提炼

### **关键数据结构**
- **邻接表**：高效存储图结构。
- **队列**：实现拓扑排序的核心工具。

### **算法优化**
- **拓扑排序中直接DP**：合并排序与状态转移，减少时间复杂度。
- **反向图记忆化搜索**：避免显式拓扑排序，但需注意递归深度。

---

## 同类型题目推荐
1. **P1113 杂务**（DAG最长路径）
2. **P1807 最长路**（边权为负的最长路径）
3. **P4017 最大食物链计数**（DAG路径计数）

---

## 可视化设计（复古像素风格）

### **动画方案**
1. **网格布局**：节点以像素方块表示，颜色区分处理状态：
   - **待处理**：灰色（#808080）
   - **处理中**：黄色（#FFFF00）
   - **已处理**：绿色（#00FF00）
2. **队列展示**：右侧显示拓扑队列，当前处理节点高亮。
3. **音效设计**：
   - **节点入队**：短促“哔”声（Web Audio API）。
   - **状态更新**：成功音效（上扬音调），失败无音效。

### **交互功能**
- **步进控制**：按钮支持单步执行/自动播放（速度可调）。
- **高亮逻辑**：当前处理的节点及其邻接点闪烁，`dp` 值实时更新显示。

---

## 核心代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+5;
vector<int> adj[MAXN];
int in[MAXN], dp[MAXN];

void solve() {
    queue<int> q;
    for (int i=1; i<=n; i++) 
        if (in[i] == 0) q.push(i), dp[i] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) {
            dp[v] = max(dp[v], dp[u]+1);
            if (--in[v] == 0) q.push(v);
        }
    }
}
```

---

## 个人心得摘录
- **调试教训**：初始化 `dp` 数组为1，否则漏计自身节点。
- **思维突破**：反向图记忆化搜索可避免显式拓扑排序，但需注意递归栈深度限制。

---
处理用时：68.18秒
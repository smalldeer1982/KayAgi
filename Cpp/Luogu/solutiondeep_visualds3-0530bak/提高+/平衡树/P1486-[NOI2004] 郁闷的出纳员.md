# 题目信息

# [NOI2004] 郁闷的出纳员

## 题目描述

OIER 公司是一家大型专业化软件公司，有着数以万计的员工。作为一名出纳员，我的任务之一便是统计每位员工的工资。这本来是一份不错的工作，但是令人郁闷的是，我们的老板反复无常，经常调整员工的工资。如果他心情好，就可能把每位员工的工资加上一个相同的量。反之，如果心情不好，就可能把当前在公司的所有员工的工资扣除一个相同的量。我真不知道除了调工资他还做什么其它事情。

工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。

老板经常到我这边来询问工资情况，他并不问具体某位员工的工资情况，而是问现在工资第 $k$ 多的员工拿多少工资。每当这时，我就不得不对数万个员工进行一次漫长的排序，然后告诉他答案。

好了，现在你已经对我的工作了解不少了。正如你猜的那样，我想请你编一个工资统计程序。怎么样，不是很困难吧？

如果某个员工的初始工资低于最低工资标准，那么将不计入最后的答案内。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- `I` 命令的条数不超过 $10^5$；
- `A` 和 `S` 命令的总条数不超过 $100$；
- `F` 命令的条数不超过 $10^5$；
- 每次工资调整的调整量不超过 $10^3$；
- 新员工的工资不超过 $10^5$。
- $0 \leq n \leq 3 \times 10^5$，$0 \leq \text{min} \leq 10^9$，输入的所有数字均在 $32$ 位带符号整形范围内。

## 样例 #1

### 输入

```
9 10
I 60
I 70
S 50
F 2
I 30
S 15
A 5
F 1
F 2
```

### 输出

```
10
20
-1
2
```

# AI分析结果



**唯一算法分类**：平衡树

---

### **题解思路与核心难点**
**核心思路**：维护全局变量 `delta` 表示全体工资的偏移量，插入时存储相对值 `x-delta`，查询时恢复为 `x+delta`。删除时通过平衡树的分裂操作批量移除所有低于 `min-delta` 的节点。

**关键难点与解决方案**：
1. **全体加减工资的高效处理**  
   使用 `delta` 变量记录整体偏移，避免逐个修改节点值，时间复杂度从 O(n) 降为 O(1)。
2. **批量删除低于下限的节点**  
   平衡树通过 `split` 操作将树分为 `< min-delta` 和 `≥ min-delta` 两部分，直接删除左子树，时间复杂度 O(log n)。

---

### **题解评分 (≥4星)**
1. **浅色调 (赞105) [★★★★☆]**  
   - **亮点**：使用 `pb_ds` 库的红黑树，代码简洁，逻辑清晰。  
   - **代码**：通过 `split` 操作直接删除不符合条件的子树，统计删除节点数。  
   - **缺点**：依赖库函数，可移植性较差。

2. **lijianyangyf (赞46) [★★★★☆]**  
   - **亮点**：采用 FHQ-Treap，实现简洁的分裂与合并逻辑，删除操作高效。  
   - **关键代码**：`split` 分割出小于 `min-delta` 的子树，直接丢弃并统计数量。

3. **why_always_china (赞0) [★★★☆☆]**  
   - **亮点**：Splay 树实现，通过维护 `delta` 和删除前驱节点。  
   - **缺点**：代码较长，删除逻辑稍显复杂。

---

### **最优思路与技巧提炼**
1. **全局偏移量 `delta`**  
   - 插入时存储 `x-delta`，查询时恢复为 `x+delta`，避免逐个修改节点。
2. **平衡树分裂操作**  
   - 删除低于下限的节点时，通过 `split` 操作将树分为两部分，时间复杂度 O(log n)。
3. **高效统计删除数量**  
   - 删除左子树后直接累加其节点数，无需遍历。

---

### **同类型题与算法套路**
- **通用解法**：维护有序集合，支持插入、删除区间、查询第 k 大，常用平衡树或权值线段树。
- **类似题目**：
  1. **P3369 【模板】普通平衡树**  
  2. **P6136 【模板】文艺平衡树**  
  3. **P2596 [ZJOI2006] 书架**

---

### **可视化与算法演示**
**动画设计**（基于 FHQ-Treap）：
1. **插入操作**  
   - 显示插入节点 `x-delta`，调整树结构，高亮旋转路径。
2. **全体加减工资**  
   - `delta` 变量动态变化，树节点颜色渐变表示偏移量影响。
3. **删除操作**  
   - 分裂树时用红色高亮 `< min-delta` 的子树，快速移除并统计数量。
4. **查询第 k 大**  
   - 从右子树开始搜索，路径节点闪烁，显示当前排名计算。

**复古像素风格**：
- **Canvas 绘制**：树节点用 8 位像素方块表示，分裂时左子树爆炸特效，音效使用 8 位“碎裂”声。
- **自动演示模式**：按步骤自动执行插入、分裂、查询，背景音乐为低比特芯片音乐。

---

### **核心代码片段（FHQ-Treap）**
```cpp
int delta = 0, ans = 0; // 全局偏移量与删除计数

void delete_low() {
    int x, y;
    split(rt, min_val - delta - 1, x, y); // 分割出小于 min 的子树
    ans += size[x]; // 统计删除数量
    rt = y; // 保留右子树
}

void insert(int x) {
    if (x < min_val) return;
    x -= delta; // 插入相对值
    split(rt, x, a, b); // 分裂树
    rt = merge(merge(a, new_node(x)), b); // 合并
}
```

---

### **总结**
本题通过维护全局偏移量和平衡树操作，高效处理动态工资集合的核心需求。最优解法结合了 `delta` 变量与分裂操作，代码简洁且时间复杂度优越。可视化设计通过复古像素风格和关键步骤高亮，直观展示算法流程。

---
处理用时：68.98秒
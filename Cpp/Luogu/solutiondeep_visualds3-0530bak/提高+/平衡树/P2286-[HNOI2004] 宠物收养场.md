# 题目信息

# [HNOI2004] 宠物收养场

## 题目背景

题面修缮来自于 [LaDeX](https://www.luogu.com.cn/user/431658)。

## 题目描述

凡凡开了一间宠物收养场。收养场提供两种服务：收养被主人遗弃的宠物和让新的主人领养这些宠物。

每个领养者都希望领养到自己满意的宠物，凡凡根据领养者的要求通过他自己发明的一个特殊的公式，得出该领养者希望领养的宠物的特点值 $a$（$a$ 是一个正整数，$a<2^{31}$），而他也给每个处在收养场的宠物一个特点值。这样他就能够很方便的处理整个领养宠物的过程了，宠物收养场总是会有两种情况发生：被遗弃的宠物过多或者是想要收养宠物的人太多，而宠物太少。

被遗弃的宠物过多时，假若到来一个领养者，这个领养者希望领养的宠物的特点值为 $a$，那么它将会领养一只目前未被领养的宠物中特点值最接近 $a$ 的一只宠物。（任何两只宠物的特点值都不可能是相同的，任何两个领养者的希望领养宠物的特点值也不可能是一样的）如果有两只满足要求的宠物，即存在两只宠物他们的特点值分别为 $a-b$ 和 $a+b$，那么领养者将会领养特点值为 $a-b$ 的那只宠物。

收养宠物的人过多，假若到来一只被收养的宠物，那么哪个领养者能够领养它呢？能够领养它的领养者，是那个希望被领养宠物的特点值最接近该宠物特点值的领养者，如果该宠物的特点值为 $a$，存在两个领养者他们希望领养宠物的特点值分别为 $a-b$ 和 $a+b$，那么特点值为 $a-b$ 的那个领养者将成功领养该宠物。

一个领养者领养了一个特点值为 $a$ 的宠物，而它本身希望领养的宠物的特点值为 $b$，那么这个领养者的不满意程度为 $|a-b|$。

你得到了一年当中，领养者和被收养宠物到来收养所的情况，请你计算所有收养了宠物的领养者的不满意程度的总和。这一年初始时，收养所里面既没有宠物，也没有领养者。

## 说明/提示

样例解释：

注：$|3-2| + |2-4|=3$，
最后一个领养者没有宠物可以领养。

## 样例 #1

### 输入

```
5                  

0 2                      

0 4                         

1 3

1 2

1 5

```

### 输出

```
3
```

# AI分析结果



## 【算法分类】
平衡树

## 【题解思路与难点分析】

### 核心思路
1. **动态维护有序集合**：使用平衡树维护当前存在的宠物或领养者特征值，支持快速插入、删除、前驱/后继查询
2. **类型切换机制**：通过变量`flag`标记当前树中存储的是宠物还是领养者，保证同一时刻只存在一种类型
3. **最优匹配策略**：插入新元素时，若当前树中存在对立类型元素，找到该元素的前驱和后继，选择差值最小的进行匹配

### 解决难点
1. **边界处理**：插入极值哨兵节点（如-INF和INF）避免查询前驱/后继时空指针
2. **差值比较**：当特征值差相同时优先选择前驱
3. **动态类型切换**：当树被清空时自动切换类型标记

### 算法流程
1. 初始化平衡树，插入哨兵节点-INF和INF
2. 读取输入类型（0-宠物，1-领养者）
3. 若当前树类型与输入类型相同，直接插入特征值
4. 否则查询前驱和后继：
   - 计算`x - pre_val`和`suc_val - x`的绝对值
   - 删除差值较小的节点，累加差值到结果
5. 结果取模1000000

## 【题解评分（≥4星）】
1. **yybyyb的Splay实现（4.5星）**
   - 亮点：完整Splay模板，动态类型切换逻辑清晰
   - 优化点：插入时自动splay保持平衡，删除时双旋维护树结构
2. **DaCong的set实现（5星）**
   - 亮点：利用STL set简化代码，lower_bound高效查询
   - 优化点：边界处理严谨，代码仅50行
3. **crpboy的set优化版（4.5星）**
   - 亮点：位运算处理类型切换，极值哨兵处理优雅
   - 优化点：使用两个set分别存储，避免类型判断

## 【最优技巧提炼】
1. **哨兵节点技巧**：插入-INF和INF避免空指针
```cpp
set<int> s;
s.insert(-INF); s.insert(INF);
```
2. **前驱/后继快速查询**
```cpp
auto pre = --s.lower_bound(x); // 前驱
auto suc = s.upper_bound(x);   // 后继
```
3. **类型切换位运算**
```cpp
if(a == cur) s.insert(x); // cur标记当前类型
else find(x);             // 对立类型时触发匹配
```

## 【同类型题目推荐】
1. P2234 [HNOI2002]营业额统计（动态前驱/后继）
2. P3369 【模板】普通平衡树（标准平衡树操作）
3. P2073 送花（有序集合动态维护）

## 【可视化设计】
### 动画方案
1. **节点染色**：
   - 红色：当前插入/删除的节点
   - 绿色：前驱节点
   - 蓝色：后继节点
2. **操作演示**：
   ```javascript
   // 伪代码示例
   function insert(x) {
     highlight(x, "red");    // 高亮插入位置
     splay(x);                // 旋转到根动画
     drawTree();              // 重绘整棵树
   }
   ```
3. **差值比较动效**：
   - 显示前驱和后继的数值差比较过程
   - 箭头动画指示最终选择的节点

### 复古像素风格
1. **8-bit元素设计**：
   - 树节点显示为16x16像素方块
   - 特征值用8x8像素数字显示
2. **音效设计**：
   - 插入/删除：短促"滴"声
   - 匹配成功：上升音阶
   - 错误操作：低沉嗡鸣

## 【核心代码实现】
### Set简化版（DaCong题解核心）
```cpp
set<int> s;
void solve(int x) {
    auto it = s.lower_bound(x);
    int pre = *prev(it), suc = *it;
    if(x - pre <= suc - x) {
        ans += x - pre;
        s.erase(pre);
    } else {
        ans += suc - x;
        s.erase(suc);
    }
    ans %= 1000000;
}

int main() {
    s.insert(-INF); s.insert(INF);
    while(n--) {
        if(当前类型匹配) s.insert(x);
        else solve(x); 
    }
    cout << ans;
}
```

### Splay完整版（yybyyb题解核心）
```cpp
void splay(int x,int goal) {
    while(fa[x]!=goal) {
        int y=fa[x],z=fa[y];
        if(z!=goal) 
            (ch[y][0]==x)^(ch[z][0]==y)?rotate(x):rotate(y);
        rotate(x);
    }
    if(!goal) root=x;
}

int query(int x) {
    int pre = find_pre(x), suc = find_suc(x);
    return abs(x-pre) <= abs(suc-x) ? pre : suc;
}
```

## 【个人心得摘录】
> "插入极值哨兵后，前驱后继查询不再需要判空，极大简化代码逻辑。调试时发现未处理边界情况会导致随机取数错误，加入哨兵后所有用例通过" —— DaCong题解调试经验

## 【拓展思考】
对于特征值范围有限的情况（如1e6以内），可使用动态开点线段树替代平衡树，通过权值线段树实现O(logV)的前驱/后继查询，空间换时间的优化策略。

---
处理用时：80.56秒
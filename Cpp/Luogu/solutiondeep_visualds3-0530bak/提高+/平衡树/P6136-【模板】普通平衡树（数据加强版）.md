# 题目信息

# 【模板】普通平衡树（数据加强版）

## 题目背景

本题是 P3369 数据加强版，**扩大数据范围**并增加了**强制在线**。

**题目的输入、输出和原题略有不同**，但需要支持的操作相同。

## 题目描述

您需要动态地维护一个可重集合 $M$，并且提供以下操作：

1. 向 $M$ 中插入一个数 $x$。
2. 从 $M$ 中删除一个数 $x$（若有多个相同的数，应只删除一个）。
3. 查询 $M$ 中有多少个数比 $x$ 小，并且将得到的答案加一。
4. 查询如果将 $M$ 从小到大排列后，排名位于第 $x$ 位的数。
5. 查询 $M$ 中 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。
6. 查询 $M$ 中 $x$ 的后继（后继定义为大于 $x$，且最小的数）。

本题**强制在线**，保证所有操作合法（操作 $2$ 保证存在至少一个 $x$，操作 $4,5,6$ 保证存在答案）。

## 说明/提示

### 样例解释

样例加密前为：
```plain
6 7
1 1 4 5 1 4
2 1
1 9
4 1
5 9
3 8
6 1
1 0
```

### 限制与约定

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 10^6$，$0\leq a_i,x\lt 2^{30}$。

**本题输入数据较大，请使用较快的读入方式。**

---

$\text{upd 2022.7.22}$：新增加 $9$ 组 Hack 数据。

## 样例 #1

### 输入

```
6 7
1 1 4 5 1 4
2 1
1 9
4 1
5 8
3 13
6 7
1 4
```

### 输出

```
6
```

# AI分析结果



# 算法分类：平衡树

## 综合分析与结论
本题目需要动态维护可重集合的6种操作，核心在于高效实现插入、删除和查询操作。各题解展示了多种平衡树实现方式，核心差异在于平衡机制的选择：

1. **01Trie路径压缩**（EternalAlexander）
   - **核心思想**：将数值视为二进制位串，通过压缩单链降低空间复杂度至O(n)
   - **解决难点**：传统01Trie空间O(n log w)被卡，虚树压缩将单链合并为单个节点
   - **操作特征**：插入时分裂路径节点，查询排名通过二进制位遍历

2. **FHQ-Treap**（zhy137036）
   - **核心思想**：基于分裂合并的非旋转树结构，通过随机优先级维持平衡
   - **解决难点**：删除操作通过两次分裂精准定位目标节点
   - **操作特征**：split函数时间复杂度O(log n)，kth查询采用二分思路

3. **WBLT**（BFqwq）
   - **核心思想**：Leafy Tree设计，所有信息存储在叶子节点，内部节点仅维护统计信息
   - **解决难点**：通过重量平衡因子(ratio=4)触发重构，merge时动态调整子树
   - **操作特征**：维护size时区分真实节点数和惰性删除标记

4. **替罪羊树**（那一条变阻器）
   - **核心思想**：超过平衡因子阈值(α=0.75)时暴力重构子树
   - **解决难点**：惰性删除标记管理，重构时中序遍历生成有序数组
   - **操作特征**：删除后检查整体平衡性，重构频率与操作分布相关

## 题解清单（≥4星）
1. **EternalAlexander（01Trie路径压缩）** ★★★★☆
   - 亮点：创新性虚树压缩解决空间问题，插入操作维护路径分裂
   - 代码亮点：`insert`函数处理位分裂，`reverse`预处理优化查询

2. **zhy137036（FHQ-Treap）** ★★★★☆
   - 亮点：split/merge逻辑清晰，删除操作直接合并子树
   - 代码亮点：`kth`查询无需递归，通过size直接计算偏移量

3. **BFqwq（WBLT）** ★★★★☆
   - 亮点：Leafy结构简化平衡判断，重构时合并相邻子树
   - 代码亮点：`maintain`函数处理重量失衡，递归式插入删除

## 核心代码示例
**FHQ-Treap 分裂函数**
```cpp
pair<int, int> split(int u, int k) {
    if (!u) return {0, 0};
    if (key[u] < k) {
        auto [x, y] = split(ch[u][1], k);
        ch[u][1] = x;
        update(u);
        return {u, y};
    } else {
        auto [x, y] = split(ch[u][0], k);
        ch[u][0] = y;
        update(u);
        return {x, u};
    }
}
```

**WBLT 重构函数**
```cpp
void rebuild(int &now) {
    vector<int> v;
    inorder(now, v); // 中序遍历获取有序序列
    now = build(v, 0, v.size()-1); // 类似线段树建树
}

int build(vector<int>& v, int l, int r) {
    if (l > r) return 0;
    int mid = (l + r) / 2;
    int node = new_node(v[mid]);
    node->ls = build(v, l, mid-1);
    node->rs = build(v, mid+1, r);
    update(node);
    return node;
}
```

## 可视化设计要点
**FHQ-Treap分裂过程演示**
- **颜色标记**：当前节点红色，左子树蓝色，右子树绿色
- **动画步骤**：
  1. 初始树结构显示节点值和优先级
  2. 分裂时高亮比较节点（黄色边框）
  3. 分裂路径动态拉出形成两棵子树
  4. 显示分裂后的两棵树，用虚线箭头连接原父子关系

**替罪羊树重构动画**
- **像素风格**：节点显示为8-bit方块，失衡时闪烁红光
- **音效设计**：
  - 节点插入：短促"哔"声
  - 触发重构：警报音效
  - 重构完成：上升音阶
- **自动演示**：速度可调，展示中序遍历→拍扁数组→重建平衡树过程

## 同类型题目推荐
1. P3369 【模板】普通平衡树
2. P3391 【模板】文艺平衡树（区间翻转）
3. P2042 [NOI2005] 维护数列（综合操作）

## 个人心得摘录
> "替罪羊树的删除操作需要特别注意惰性标记管理，重构时若直接清空内存池会导致后续操作异常。实践中通过中序遍历过滤有效节点可避免野指针问题。" —— 那一条变阻器

## 复古游戏化演示
**8-bit平衡树模拟器**
- **操作面板**：方向键选择操作，A键确认，B键返回
- **积分系统**：
  - 成功插入/删除：+10分
  - 触发重构：-5分（鼓励保持平衡）
  - 连续5次操作未失衡：连击×2
- **背景音乐**：芯片音乐版《超级玛丽》地下关BGM
- **AI演示模式**：自动执行随机操作，展示平衡过程

---
处理用时：72.80秒
# 题目信息

# [KMOI R1] 五五五五（Hard）

## 题目背景

“事类相推，各有攸归，故枝条虽分而同本干知，发其一端而已。又所析理以辞，解体用图，庶亦约而能周，通而不黩，览之者思过半矣。”——刘徽


## 题目描述

小宋有一个序列 $A=\{a_1,a_2\dots,a_n\}$，其中 $\forall i\in [1,n],a_i\in[0,9]$。

对于 $1\le l\le r\le n$，他记 $f(l,r)$ 等于 $\overline{a_la_{(l+1)}\dots a_r}$ 的末尾连续 $5$ 的个数。

例如：对于序列 $a=\{1,1,4,5,1,4\}$，$f(2,4)=1,f(1,3)=0$。

不过小宋会对这个序列不断地操作，具体地，他会做以下操作：

- $(1,x,y)$：将第 $x$ 个数改为 $y$（$x\in[1,n],y\in[0,9]$）。

- $2$: 将序列 $a$ 反转，例如 $\{1,1,4,5\}$ 反转之后就是 $\{5,4,1,1\}$。

- $3$：对序列进行询问。

- $(4,l,r)$：对序列进行询问。

对于每一种操作 $3$，请你输出:

$$\Big(\sum\limits_{l=1}^
{n}\sum\limits_{r=l}^{n} f(l,r)\Big) \bmod 10^9+7$$

对于每一个操作 $4$，请你输出：

$$\Big(\sum\limits_{i=l}^{r}a_i\Big) \bmod 10^9+7$$

## 说明/提示

## 样例 $1$ 解释：

| 操作 | 操作后的序列 | 答案 |
| :----------: | :----------: | :----------: |
| $(1,3,3)$ | $\{1,5,3\}$ | $/$ |
| $3$ | $/$ | $2$ |
| $(1,1,5)$ | $\{5,5,3\}$ | $/$ |
| $(4,1,3)$ | $/$ | $13$ |

## 样例 $2$ 解释：

| 操作 | 操作后的序列 | 答案 |
| :----------: | :----------: | :----------: |
| $3$ | $/$ | $4$ |
| $2$ | $\{4,1,5,4,1,1\}$ | $/$ |
| $3$ | $/$ | $3$ |
| $(1,1,5)$ | $\{5,1,5,4,1,1\}$ | $/$ |
|$(4,1,4)$|$/$|$15$|
## 数据范围
| 测试点编号 | $n\le$ |$q\le$| 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
|$1$|$100$|$100$|$/$|
|$2,3$|$10^3$|$10^3$|$\mathbf{A}$|
|$4$|$10^3$|$10^3$|$\mathbf{B}$|
|$5\sim10$|$2\times 10^5$|$2\times 10^5$|$/$|
|$11\sim13$|$2\times 10^5$|$2\times 10^5$|$\mathbf{A}$|
|$14,15$|$2\times 10^5$|$2\times 10^5$|$/$|
|$16\sim18$|$5\times 10^5$|$5\times 10^5$|$\mathbf{B}$|
|$19\sim25$|$5\times 10^5$|$5\times 10^5$|$/$|

特殊性质 $\mathbf{A}:$ 没有操作 $2$。

特殊性质 $\mathbf{B}:$ 没有操作 $3$。

对于 $100\%$ 的数据：$1\le n\le 5\times 10^5$，$1\le q\le 5\times 10^5$。

 $\forall i\in [1,n]$，满足 $a_i\in[0,9]$。

## 样例 #1

### 输入

```
3 4
1 5 5
1 3 3
3
1 1 5
4 1 3```

### 输出

```
2
13```

## 样例 #2

### 输入

```
6 5
1 1 4 5 1 4
3
2
3
1 1 5
4 1 4```

### 输出

```
4
3
15```

# AI分析结果



**唯一算法分类**：线段树/数据结构

---

### **综合分析与结论**

**核心思路**：  
题目需动态维护序列的正/反状态，并高效计算所有子区间的末尾连续5的个数之和。核心难点在于处理反转操作和快速更新连续5的贡献。题解主要采用以下两种思路：

1. **双线段树维护正反序列**（Fire_flame等）：
   - 维护两棵线段树，分别存储原序列和反转后的序列。
   - 线段树节点记录连续5的前缀、后缀、总和及贡献值。
   - 反转操作通过全局标记切换，查询时根据标记选择对应线段树。
   - 单点修改需同时更新两棵线段树的对应位置。

2. **Set维护极长连续段**（Ginger_he等）：
   - 使用`set`管理所有极长的连续5的区间。
   - 正反序列各维护一个贡献值，反转时交换贡献值。
   - 修改时分裂或合并连续段，动态更新贡献。

**可视化设计要点**：  
- **动画方案**：展示线段树合并过程。  
  - 节点合并时，高亮左右子树的`r5`和`l5`，显示如何拼接连续段。  
  - 反转操作时，切换全局标记`flag`，并动态切换视图到反向线段树。  
- **像素风格**：  
  - 用8位色块表示线段树节点，绿色表示5，红色为非5。  
  - 音效：合并成功时播放“叮”声，反转时播放“咔嗒”声。  
- **交互控制**：支持单步执行修改操作，观察线段树节点的更新过程。

---

### **题解清单 (≥4星)**

1. **Fire_flame（4.5星）**  
   - **亮点**：双线段树处理反转，结构清晰；利用`pushup`高效合并节点信息。  
   - **关键代码**：线段树节点合并逻辑（`l5`, `r5`, `s5`的计算）。  
   ```cpp
   void pushup(int x) {
       t[x].sum = t[x<<1].sum + t[x<<1|1].sum;
       t[x].l5 = t[x<<1].l5; 
       if (t[x<<1].l5 == t[x<<1].sz) t[x].l5 += t[x<<1|1].l5;
       t[x].r5 = t[x<<1|1].r5; 
       if (t[x<<1|1].r5 == t[x<<1|1].sz) t[x].r5 += t[x<<1].r5;
       // ... 计算s5和sf
   }
   ```

2. **Ginger_he（4星）**  
   - **亮点**：`set`维护连续段，贡献公式简洁；反转时交换正反答案。  
   - **关键代码**：合并连续段时更新贡献。  
   ```cpp
   void modify(int x, int y) {
       auto it = --s.upper_bound({x,0,0});
       int l = it->l, r = it->r;
       s.erase(it);
       // 分裂并重新插入区间
       // 合并相邻区间并更新贡献
   }
   ```

3. **hanjinghao（4星）**  
   - **亮点**：树状数组处理区间和，`set`维护连续段，代码高效。  
   - **关键代码**：预处理贡献公式，动态更新答案。  
   ```cpp
   inline int calc3(int l, int r) {
       int t = r - l + 1;
       return ((1ll*(r+1)*t*(t+1)/2 - t*(t+1)*(2*t+1)/6) % mod);
   }
   ```

---

### **最优思路提炼**

- **双线段树 + 反转标记**：  
  维护正反两棵线段树，通过标记`flag`切换查询方向，避免实际反转序列。  
  **关键点**：  
  - 线段树节点存储连续5的前缀、后缀、总数及贡献值。  
  - 合并时，若左子树的右连续5与右子树的左连续5拼接，更新总和。  

- **贡献公式优化**：  
  极长连续段贡献公式为：  
  $$\sum_{i=1}^{sz} i \times (le + sz - i)$$  
  通过预处理或数学公式（如平方和）快速计算。  

---

### **同类型题推荐**

1. **[P3372 线段树1](https://www.luogu.com.cn/problem/P3372)**  
   - 基础线段树，练习区间修改与查询。  
2. **[P3391 文艺平衡树](https://www.luogu.com.cn/problem/P3391)**  
   - 区间反转操作，适合练习平衡树或带标记线段树。  
3. **[P2894 酒店](https://www.luogu.com.cn/problem/P2894)**  
   - 维护连续空区间，类似连续5的处理。  

---

### **个人心得摘录**

- **Fire_flame**：  
  > "线段树的`pushup`函数是关键，合并时要考虑左右子树可能的连接情况。"  
- **Ginger_he**：  
  > "set的迭代器操作容易出错，需仔细处理边界条件。"  

---

### **可视化与算法演示**

**核心流程**：  
1. **线段树合并动画**：  
   - 初始状态：左右子树独立显示。  
   - 合并时，高亮左子树的`r5`（蓝色）和右子树的`l5`（绿色）。  
   - 若可连接，显示合并后的连续段长度，并更新父节点值。  

2. **反转操作演示**：  
   - 点击反转按钮，全局标记`flag`切换（显示为红/绿）。  
   - 线段树视图镜像翻转，展示反向序列的节点信息。  

**代码片段（伪代码）**：  
```javascript
// 线段树合并动画
function animateMerge(leftNode, rightNode) {
    highlight(leftNode.r5, 'blue');
    highlight(rightNode.l5, 'green');
    if (leftNode.r5 === leftNode.sz) {
        showMergeEffect(leftNode.r5 + rightNode.l5);
    }
}
```

---
处理用时：76.08秒
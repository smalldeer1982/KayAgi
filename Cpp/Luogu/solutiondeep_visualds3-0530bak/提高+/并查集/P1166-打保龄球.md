# 题目信息

# 打保龄球

## 题目描述

打保龄球是用一个滚球去打击十个站立的柱，将柱击倒。一局分十轮，每轮可滚球一次或多次，以击倒的柱数为依据计分。一局得分为十轮得分之和，而每轮的得分不仅与本轮滚球情况有关，还可能与后续一两轮的滚球情况有关。即某轮某次滚球击倒的柱数不仅要计入本轮得分，还可能会计入前一两轮得分。具体的滚球击柱规则和计分方法如下：

1. 若某一轮的第一次滚球就击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加两次滚球，不妨称其为第十一轮和第十二轮，并不是所有的情况都需要滚第十一轮和第十二轮球）。该轮得分为本次击倒柱数 $10$ 与以后两次滚球所击倒柱数之和。

2. 若某一轮的第一次滚球未击倒十个柱，则可对剩下未倒的柱再滚球一次。如果这两次滚球击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加一次滚球），该轮得分为这两次共击倒柱数 $10$ 与以后一次滚球所击倒柱数之和。

3. 若某一轮两次滚球未击倒全部十个柱，则本轮不再继续滚球，该轮得分为这两次滚球击倒的柱数之和。   

总之，若―轮中一次滚球或两次滚球击倒十个柱，则本轮得分是本轮首次滚球开始的连续三次滚球击倒柱数之和（其中有一次或两次不是本轮滚球）。若一轮内二次滚球击倒柱数不足十个，则本轮得分即为这两次击倒柱数之和。下面以实例说明如下(字符 `/` 表示击倒当前球道上的全部的柱)：

| 轮 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| 击球情况  |  /  |  /  |  /  |  72 |  9/ |  81  | 8/  |  / |   9/  |  /  |  8/ |
| 各轮得分 |  30  | 27  | 19 |  9   |18   | 9  | 20  | 20 |  20 |  20|
|累计总分 |  30  | 57  |76 |  85|  103 |  112 | 132  |152 | 172 | 192|

现在请你编写一个保龄球实时计分程序，用来计算和显示某轮结束后的得分情况。若某轮的得分暂时无法算出，则**不显示**该轮得分（不输出）。


## 样例 #1

### 输入

```
/ / / 72 9/ 81 8/ / 9/ / 8/```

### 输出

```
30 27 19 9 18 9 20 20 20 20 
30 57 76 85 103 112 132 152 172 192```

# AI分析结果



**唯一算法分类**：模拟

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **输入处理**：将输入字符串转换为每轮击球数据（全中`/`转为10分，其他字符转为数值）。
2. **轮次状态跟踪**：维护当前轮次、剩余瓶数、是否补中等状态。
3. **得分计算**：根据规则判断当前轮次得分类型（全中/补中/普通），检查后续球数据是否足够计算得分。
4. **结果输出**：仅输出可确定得分的轮次。

#### **解决难点**
- **后续球依赖**：全中需看后两球，补中需看下一球。需处理数据不完整时的中断逻辑。
- **第十轮特殊处理**：第十轮全中需额外两球，补中需额外一球。
- **输入格式灵活**：输入可能包含空格分隔的变长轮次数据。

---

### **题解评分 (≥4星)**

1. **袁宇轩（5星）**  
   - **亮点**：通过`st`变量跟踪当前轮起始位置，清晰处理全中/补中逻辑，边界检查简洁。
   - **代码**：使用二维数组存储每轮击球数据，循环处理每轮得分。
   ```cpp
   for (int i=1;i<=10;i++){
     int rest=10,flag=1;
     for (int j=st;j<=st+2;j++){
       if (j>n) { sum[i]=-1; break; }
       // 处理击球逻辑
     }
     // 更新st位置
   }
   ```

2. **深海鱼的眼泪（4星）**  
   - **亮点**：使用辅助数组`y[][]`标记有效数据，明确区分已处理和未处理轮次。
   - **关键逻辑**：通过检查后续球是否存在确定是否可计算得分。
   ```cpp
   if (df[i+1][1] == 10 && (!y[i+2][1])) break;
   ```

3. **2344b（4星）**  
   - **亮点**：用`Time[]`数组跟踪后续需要补足的球数，动态更新得分。
   - **技巧**：处理全中时直接修改前两轮的得分。
   ```cpp
   if(Time[top-1]-->0) score[top-1] += 10-Map[top];
   ```

---

### **最优思路提炼**
1. **输入预处理**：将字符转换为数值，标记特殊球（全中`/`）。
2. **状态跟踪表**：维护每轮击球次数、剩余瓶数、是否全中/补中。
3. **得分延迟计算**：遇到全中/补中时暂存当前轮，待后续数据足够时回溯计算。
4. **中断机制**：处理到无法满足后续依赖时立即跳出循环。

---

### **同类型题推荐**
1. **P1080 国王游戏**（模拟+排序）
2. **P1518 两只塔姆沃斯牛**（状态模拟）
3. **P1068 分数线划定**（数据处理与边界检查）

---

### **可视化设计要点**
1. **动画流程**：
   - **步骤1**：解析输入字符串，显示为保龄球瓶击倒动画。
   - **步骤2**：高亮当前处理轮次，用不同颜色标记全中（红色）/补中（黄色）。
   - **步骤3**：动态显示后续球依赖关系（虚线箭头指向后续球）。
   - **步骤4**：无法计算时显示"WAITING"标签，可计算时弹出得分气泡。

2. **复古像素风格**：
   - **调色板**：8位风格，使用#FF0000（全中）、#FFFF00（补中）、#00FF00（普通）。
   - **音效**：击球声（8-bit "beep"），得分时播放NES风格胜利音效。

3. **交互功能**：
   - **单步执行**：Space键逐步执行每轮处理。
   - **速度调节**：滑块控制动画速度（0.5x~3x）。
   - **数据修改**：允许拖放修改输入字符串，实时更新动画。

---

### **核心代码片段（袁宇轩题解）**
```cpp
// 输入处理与得分计算核心逻辑
int main() {
  int st = 1; // 当前轮起始球位置
  for (int i=1; i<=10; i++) {
    int rest=10, flag=1;
    for (int j=st; j<=st+2; j++) {
      if (j > n) { sum[i]=-1; break; } // 数据不足
      if (a[j] == '/') { 
        sum[i] += rest; 
        rest = 0; 
      } else {
        sum[i] += a[j]-'0';
        rest -= a[j]-'0';
      }
      // 更新状态
    }
    if (sum[i] == -1) break;
    // 更新st位置
    a[st]=='/' ? st++ : st+=2;
  }
}
```

---

### **总结**
本题通过模拟保龄球计分规则，重点考察**状态跟踪**和**边界处理**能力。最优解法需平衡代码简洁性与处理效率，推荐袁宇轩的实现作为学习范本，其通过`st`变量清晰管理轮次切换，值得借鉴。

---
处理用时：76.44秒
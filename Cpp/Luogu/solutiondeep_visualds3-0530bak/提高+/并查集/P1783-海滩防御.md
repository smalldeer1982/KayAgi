# 题目信息

# 海滩防御

## 题目描述

WLP 同学最近迷上了一款网络联机对战游戏（终于知道为毛 JOHNKRAM 每天刷洛谷效率那么低了），但是他却为了这个游戏很苦恼，因为他在海边的造船厂和仓库总是被敌方派人偷袭。于是，WLP 动用了他那丰满且充实的大脑（或许更偏向前者），想出了一个好主意，他把海滩分成垂直于海岸线的若干列，在其中的几列上放置几个信号塔，试图来监视整个海滩。然而，WLP 是一个非常心急的人，他把信号塔建好后才发现还需给信号塔供能，它们才能投入使用（这不是废话么），它们都有一个工作半径，一个圆形区域里的所有敌人都逃不过它们的监视，不过，WLP 发现，敌人们非常狡猾，除非他将道路完全封死，否则 WLP 的敌人可以走过一条任意弯曲的路（不一定走整点，但是不会出第 $0$ 列和第 $N$ 列构成的边界）来偷他的东西。

于是，WLP 就思考了：到底需要给每个信号塔多大的工作半径，才能将从海滩到内地的路径完全封死呢？他再次动用了他那丰满且充实的大脑，想了一堂数学课，终于，还是没想出来。于是，他向 LZZ 神犇求助（额…… CSUNSHINE 的身份是不是暴露了）。

终于，在 WLP：“ %^!\*@#!\*(\*^!\*#@\$^&（此处省略无数卖萌场景）”的哀求下，LZZ 神犇写了一个程序，在一秒内就解决了问题。但是，邪恶的 LZZ 神犇决定要将这个难题共享给无数无辜的 OIer，所以，现在轮到你了。

## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据：$1 \le M \le 10$，$1 \le Y_i \le 100$；
- 对于 $30\%$ 的数据：$1 \le M \le 50$，$1 \le Y_i \le 1,000$；
- 对于 $80\%$ 的数据：$1 \le M \le 500$，$1 \le Y_i \le 1,000$；
- 对于 $100\%$ 的数据：$1 \le M \le 800$，$1 \le N \le 1000$，$1 \le X_i \le N$，$1 \le Y_i \le 100,000$。

### 提示

注意，封锁海滩是指，敌人的深入程度是有限制的，若敌人绕过了所有的信号塔，并且可以长驱直入，那么就说明道路没有完全封锁。

## 样例 #1

### 输入

```
5 5
1 5
3 5
5 5
4 30
2 15```

### 输出

```
1.00```

## 样例 #2

### 输入

```
100 2
30 50
90 100```

### 输出

```
39.05```

# AI分析结果



**唯一算法分类**：最小生成树（Kruskal 算法）

---

### **题解思路与核心难点**  
1. **核心思路**：将信号塔与左右边界视为图中的节点，信号塔间距离的 1/2 作为边权，信号塔到边界的垂直距离作为边界边的权值。通过 Kruskal 算法构造最小生成树，当左右边界连通时，最后加入的边权即为最小半径。  
2. **解决难点**：  
   - 边界处理：将左右边界抽象为虚拟节点，避免复杂的几何计算。  
   - 最优性证明：最小生成树的最大边权对应封锁路径的瓶颈，保证全局最优。  
3. **可视化设计**：  
   - **颜色标记**：已连通的组件用同色区块表示，当前处理的边高亮为红色。  
   - **步进控制**：按边权从小到大逐步合并组件，动画展示合并过程。  
   - **像素风格**：用 8-bit 风格绘制塔（圆点）、边界线（直线），合并时播放「哔」音效，成功时播放通关音效。  

---

### **题解清单（≥4星）**  
1. **C_SUNSHINE（★★★★★）**：  
   - **亮点**：通过虚拟节点简化问题，代码简洁高效，直接体现 Kruskal 核心思想。  
   - **代码片段**：  
     ```cpp
     for(int i=1;i<=n;i++) {
         e[++w] = (edge){i,0,y[i]};       // 左边界边
         e[++w] = (edge){i,n+1,W-y[i]};   // 右边界边
     }
     sort(e+1,e+w+1,cmp);  // 关键排序
     ```  
2. **Mathison（★★★★☆）**：  
   - **亮点**：Dijkstra 求路径最大值最小，通过优先队列优化实现 O(M²) 复杂度。  
   - **核心逻辑**：松弛操作取路径最大值而非累加：  
     ```cpp
     if (dis[v] > max(dis[u], e[i].val)) {
         dis[v] = max(dis[u], e[i].val);
         q.push({-dis[v], v});
     }
     ```  
3. **pipiispig（★★★★☆）**：  
   - **亮点**：优化并查集合并过程，动态检查边界连通性，提前终止算法。  

---

### **最优技巧提炼**  
1. **虚拟节点**：将左右边界抽象为节点，避免复杂几何判断。  
2. **边权设计**：塔间边权取距离 1/2，边界边权取垂直距离。  
3. **终止条件**：在 Kruskal 中实时检查边界连通性，找到即终止。  

---

### **同类题目推荐**  
1. **P3958 奶酪**（NOIP2017，三维连通性 + 并查集）  
2. **P1396 营救**（最小生成树求路径最大边权）  
3. **P1546 最短网络 Agri-Net**（最小生成树模板题）  

---

### **复古像素动画实现（伪代码）**  
```javascript
// Canvas 初始化
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 10; // 像素块大小

function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
}

// 动画逻辑
let currentEdge = 0;
function animateKruskal() {
    if (find(0) === find(n+1)) { // 连通成功
        playSuccessSound();
        return;
    }
    const edge = edges[currentEdge++];
    drawEdge(edge, '#FF0000'); // 高亮当前边
    if (union(edge.u, edge.v)) {
        playMergeSound(); // 合并音效
        drawConnectedComponent(edge.u); // 刷新连通区块颜色
    }
    requestAnimationFrame(animateKruskal);
}
```  

---

### **核心代码实现（Kruskal 版本）**  
```cpp
#include <algorithm>
#include <cmath>

struct Edge { int u, v; double w; };
bool cmp(Edge a, Edge b) { return a.w < b.w; }

int main() {
    // 输入处理
    int n, m; cin >> n >> m;
    vector<Edge> edges;
    for (int i=1; i<=m; ++i) {
        cin >> x[i] >> y[i];
        // 连接左右边界
        edges.push_back({i, 0, (double)x[i]});
        edges.push_back({i, m+1, (double)(n - x[i])});
    }
    // 构建塔间边
    for (int i=1; i<m; ++i)
        for (int j=i+1; j<=m; ++j)
            edges.push_back({i, j, hypot(x[i]-x[j], y[i]-y[j])/2});
    
    sort(edges.begin(), edges.end(), cmp);
    // 并查集操作
    int fa[805]; iota(fa, fa+m+2, 0);
    double ans = 0;
    for (Edge e : edges) {
        int fu = find(fa, e.u), fv = find(fa, e.v);
        if (fu != fv) {
            fa[fu] = fv;
            ans = e.w;
            if (find(fa, 0) == find(fa, m+1)) break;
        }
    }
    printf("%.2f\n", ans);
}
```

---
处理用时：82.70秒
# 题目信息

# [USACO20OPEN] The Moo Particle S

## 题目描述

FJ 的奶牛们最近很无聊，她们想到了一种全新的方式缓解无聊：研究高等物理！事实上，她们甚至成功发现了一种新的亚原子粒子，她们将其命名为“哞粒子”。

奶牛们正在进行一项有关 $N$ 个哞粒子的实验（$1\le N\le 10^5$）。粒子 $i$ 的“自旋”可以用范围在 $−10^9\ldots 10^9$ 之间的两个整数 $x_i$ 和 $y_i$ 来描述。有时两个哞粒子会发生相互作用。自旋为 ($x_i,y_i$) 和 ($x_j,y_j$) 的两个粒子之间仅当 $x_i\le x_j$ 并且 $y_i\le y_j$ 时会发生相互作用。在这些条件下，有可能这两个粒子中的一个会消失（另一个粒子不会发生任何变化）。在任意给定的时刻，至多只有一次相互作用会发生。

奶牛们想要知道在经过一些任意的相互作用之后剩余的哞粒子的最小数量。

## 说明/提示

### 样例输入输出 1 解释

一个可能的相互作用顺序：

- 粒子 $1$ 和 $4$ 相互作用，粒子 $1$ 消失。
- 粒子 $2$ 和 $4$ 相互作用，粒子 $4$ 消失。
- 粒子 $2$ 和 $3$ 相互作用，粒子 $3$ 消失。
仅留下粒子 $2$。

### 样例输入输出 2 解释

粒子 $3$ 不能与任何其他两个粒子相互作用，所以它必然会留下。粒子 $1$ 和 $2$ 中必然留下至少一个。

### 子任务
- 测试点 $3$-$6$ 满足 $N\le 10^3$。
- 测试点 $7$-$12$ 没有额外限制。

## 样例 #1

### 输入

```
4
1 0
0 1
-1 0
0 -1```

### 输出

```
1```

## 样例 #2

### 输入

```
3
0 0
1 1
-1 3```

### 输出

```
2```

# AI分析结果



# 算法分类
**排序与贪心**

---

## 综合分析与结论
### 核心思路
将粒子按 $x$ 升序、$y$ 升序排序，通过维护 **前缀最小 y 值** 和 **后缀最大 y 值**，寻找分界点。当某位置的前缀最小 y 大于其后缀最大 y 时，说明前后无法形成连通块，答案加一。

### 难点与解决
1. **连通性判定**：将二维偏序关系转化为一维单调性处理，通过排序消除 $x$ 的影响。
2. **高效统计**：利用前缀最小值数组和后缀最大值数组，将时间复杂度优化至 $O(n)$（排序为 $O(n \log n)$）。
3. **关键变量**：
   - `minl[i]`：前 $i$ 个粒子的最小 y 值
   - `maxr[i]`：后 $i$ 个粒子的最大 y 值
   - 当 `minl[i] > maxr[i+1]` 时，形成新的连通块

### 可视化设计
- **动画方案**：
  1. 展示排序后的粒子序列，以网格形式排列。
  2. 用红色高亮当前处理的粒子，蓝色标记前缀最小值，黄色标记后缀最大值。
  3. 动态绘制分界线：当 `minl[i] > maxr[i+1]` 时，显示分界线并触发音效。
- **复古风格**：
  - 8位像素粒子：每个粒子用 16x16 像素块表示，不同颜色区分状态。
  - 音效设计：分界线出现时播放“哔”声，计算完成时播放通关音效。

---

## 题解清单（4星及以上）
### 1. wylt（5星）
- **亮点**：代码简洁，利用前缀/后缀数组高效判定分界点。
- **代码核心**：
  ```cpp
  sort(cid,cid+N,cmp);  // 按x排序
  for(int i=0;i<N-1;i++)
    if(minl[i] > maxr[i+1]) ans++;
  ```

### 2. 信守天下（4.5星）
- **亮点**：使用单调栈维护连通块的最小 y，代码短小精悍。
- **关键逻辑**：
  ```cpp
  if (e[i].y < s[t]) s[++t] = e[i].y;  // 新连通块
  else while(...) 合并栈;  // 合并操作
  ```

### 3. xixiup（4星）
- **亮点**：通过问答形式推导思路，最终代码正确性高。
- **核心变量**：`l[i]` 前 i 项最小 x，`r[i]` 后 i 项最大 x。

---

## 最优思路代码（wylt版）
```cpp
#include <algorithm>
#include <iostream>
using namespace std;
#define MAXN 100000

int N, ans = 1;
struct Particle { int x, y; } p[MAXN];
int minl[MAXN], maxr[MAXN];

int main() {
    cin >> N;
    for(int i=0; i<N; i++) cin >> p[i].x >> p[i].y;
    sort(p, p+N, [](auto& a, auto& b) { 
        return a.x == b.x ? a.y < b.y : a.x < b.x; 
    });

    minl[0] = p[0].y;
    for(int i=1; i<N; i++) 
        minl[i] = min(minl[i-1], p[i].y);
    
    maxr[N-1] = p[N-1].y;
    for(int i=N-2; i>=0; i--)
        maxr[i] = max(maxr[i+1], p[i].y);

    for(int i=0; i<N-1; i++)
        if(minl[i] > maxr[i+1]) ans++;
    
    cout << ans;
}
```

---

## 相似题目推荐
1. **P1908 逆序对**：利用排序与分治统计逆序对。
2. **P3143 [USACO16OPEN] Diamond Collector S**：滑动窗口与双指针。
3. **P1102 A-B 数对**：排序后哈希或双指针处理。

---

## 可视化关键代码（JS片段）
```javascript
// 绘制分界线（伪代码）
function drawPartition(ctx, xPos) {
    ctx.fillStyle = '#FF00FF'; // 粉色分界线
    ctx.fillRect(xPos*20, 0, 2, canvas.height);
    playSound('beep'); // 触发音效
}

// 粒子更新动画
function updateParticles(sortedParticles) {
    let minY = Infinity;
    for(let i=0; i<sortedParticles.length; i++) {
        minY = Math.min(minY, sortedParticles[i].y);
        drawParticle(i, minY); // 高亮当前最小y
        if(i < N-1 && minY > maxr[i+1]) 
            drawPartition(i+0.5); // 在i与i+1之间划线
    }
}
```

---

## 个人心得摘录
> "考试时误用并查集导致TLE，最终发现贪心性质。教训：二维偏序问题优先考虑排序+单调性处理。" —— OfstAutomataMachine

---

**核心结论**：通过排序降维，利用单调性统计连通块数量是该题的最优解。可视化重点在于展示排序后的序列如何通过前缀/后缀值确定分界点。

---
处理用时：74.05秒
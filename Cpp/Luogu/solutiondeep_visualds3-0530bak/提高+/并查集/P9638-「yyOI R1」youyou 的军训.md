# 题目信息

# 「yyOI R1」youyou 的军训

## 题目背景

在 youyou 的班上，身高可能是一个敏感的话题。

## 题目描述

youyou 的班上一共有 $n$ 位同学，$m$ 对朋友，第 $i$ 对朋友关系对于身高有一个敏感值 $k_i$，敏感值可能会改变。

我们定义两位同学如果互为**朋友**，那么必然存在某对关系，将两位同学**直接**相连。

我们定义两位同学如果互为**好友**，那么必然存在直接或间接的关系，将两位同学相连。

例如存在关系 $(1,2)$ 和 $(2,3)$，那么，$1$ 与 $2$ 是朋友，但 $1$ 与 $3$ 就是好友。

现在，马上就要军训了，同学们要去领军训的服装，如果一位同学领到了尺码为 $p$ 的服装，所有同学会与朋友关系敏感值小于 $p$ 的朋友断交。即对于所有的朋友关系，若其敏感值小于 $p$，那么该朋友关系就会断开。不过在下一位同学领到服装时，所有**之前**的断开的朋友关系会恢复。

由于军训领服装是一个复杂的过程，而 youyou 对此十分感兴趣，所以给出 $q$ 次操作，且一共有三种操作:

- 操作 $1$，形如 `1 x`，表示有一位同学领到尺码为 $x$ 的服装。

- 操作 $2$，形如 `2 x`，表示询问第 $x$ 位同学还有多少位好友（包括自己）。

- 操作 $3$，形如 `3 x y`，表示第 $x$ 对朋友的敏感值变为 $y$，特别地，**敏感值的相对大小不会变化$^*$**（详情见下方），同时原来已经断开的关系不会恢复。

**注意：好友跟朋友是两个概念，朋友一定是好友，但好友不一定是朋友。**

$^*$：相对大小不会变化，指对于当前所有的敏感值而言，修改后的敏感值与原来的敏感值**排名相同**。

例如，若原来所有对朋友之间敏感值是 $\{1,2,3,5,6\}$，$3$ 的排名为 $3$，因此 $3$ 只能修改为 $3,4$ 中的一个，这样才能保证排名不变，即相对大小位置不会变换。

## 说明/提示


## 样例解释 #1

如图所示，这是初始的关系图。

![](https://cdn.luogu.com.cn/upload/image_hosting/68hzm5mr.png)

第一次操作为：有一位同学领到尺码为 $26963$ 的服装，这样，图中所有的边都会断开。

下一次操作：第三对朋友即边 $(2,3)$ 的权变为 $40$。

下一次操作：询问同学 $4$ 的好友数量，因为没有任何存在的边，因此答案为 $1$。
 
## 数据范围
| 测试点编号 | $n$ | $q$ | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1,2$ | $\le 10$ | $\le 4 \times 10^5$ | 无 |
| $3$ | $\le 10^3$ | $\le 10^3$ | 无 |
| $4$ | $\le 10^5$ | $\le 4 \times 10^5$ | 没有操作 $3$ |
| $5,6$ | $\le 10^5$ | $\le 10^3$ | 无 |
| $7$ | $\le 10^5$ | $\le 4 \times 10^5$ | 没有操作 $1$ |
| $8,9,10$ | $\le 4 \times 10^5$ | $\le 4 \times 10^5$ | 无 |

用 $c_i$ 表示询问中同学领到服装尺码的大小，$e_i$ 表示修改后敏感值的大小。

对于 $100\%$ 的数据，$1 \le n,m,q,x_i,y_i \le 4  \times  10^5$，$1 \le k_i,c_i,e_i \le 1 \times 10^9$，$m\le \min\{\frac{n(n-1)}{2},4 \times 10^5\}$。

同时数据保证在任何时刻，所有对朋友关系之间的敏感值**互不相同**。

**请注意常数因子对时间和空间产生的影响。**

## 样例 #1

### 输入

```
4 3 3
1 2 156
1 4 42
2 3 0
1 26963
3 3 40
2 4```

### 输出

```
1```

## 样例 #2

### 输入

```
7 6 7
1 2 292
1 3 274
1 4 221
1 5 156
3 4 42
3 6 40
1 30
3 4 50
2 6
3 3 250
3 1 298
1 280
2 1```

### 输出

```
6
2```

# AI分析结果



## 【唯一算法分类】
Kruskal重构树

---

## 【题解思路与难点分析】

### **核心思路**
题目本质是动态维护连通性：每次断开边权小于某值的边，求连通块大小。利用Kruskal重构树的特性，将边按权值从大到小排序构建树，每个虚节点代表一条边，点权为边权。查询时通过倍增找到满足条件的最高祖先，其子树大小即为答案。修改操作因相对排名不变，仅需调整对应虚节点的点权，无需改变树结构。

### **算法要点**
1. **Kruskal重构树构建**：按边权降序生成最大生成树，虚节点点权对应边权。
2. **子树大小预处理**：DFS遍历记录每个节点的子树包含的叶子节点数（原图节点）。
3. **倍增查询**：从目标节点向上跳，找到最浅的权值≥当前限制的祖先。
4. **动态修改**：直接修改虚节点点权，不影响树形态。

### **解决难点**
- **动态连通性维护**：通过静态树结构支持动态权值查询，利用相对排名不变的性质避免重构。
- **高效查询**：倍增法将查询复杂度降至O(log n)。
- **离线处理优化**：部分题解采用边排序和并查集离线处理，但在线算法更符合题目要求。

---

## 【题解评分 (≥4星)】

### 1. 作者：__DDDDDD__（5星）
- **亮点**：完整实现Kruskal重构树与倍增，代码简洁高效，预处理与查询逻辑清晰，处理修改操作直接。
- **关键代码**：
  ```cpp
  int findmax(int x) { // 倍增查找
    for(int i=20;i>=0;i--)
      if(f[x][i]&&w[f[x][i]]>=limit) x=f[x][i];
    return x;
  }
  ```

### 2. 作者：SegTree（4.5星）
- **亮点**：结构体封装明确，注释清晰，突出最大生成树性质，修改逻辑正确。
- **关键片段**：
  ```cpp
  int get(int u, int x) { // 类似倍增查询
    for (int i = 22; i >= 0; i--)
      if (f[u][i] && val[f[u][i]] >= x) u = f[u][i];
    return u;
  }
  ```

### 3. 作者：happybob（4星）
- **亮点**：独立实现重构树与修改，正确处理边不在生成树中的情况，代码结构良好。
- **注意点**：需判断修改的边是否在生成树中，避免错误更新。

---

## 【最优思路提炼】
- **Kruskal重构树**：将边按权值降序构建树，虚节点点权为边权。
- **子树大小统计**：DFS预处理每个虚节点子树的原节点数量。
- **倍增跳跃查询**：快速定位满足条件的最小祖先节点。
- **动态权值修改**：直接修改对应虚节点权值，无需调整结构。

---

## 【类似题目推荐】
1. **P1967 [NOIP2013 提高组] 货车运输**（最大生成树+Kruskal重构树）
2. **P4197 Peaks**（离线处理+并查集重构树）
3. **CF915E Physical Education Lessons**（动态区间覆盖与计数）

---

## 【可视化设计】
### **核心动画逻辑**
1. **构建阶段**：动态展示边按权值降序合并成虚节点，生成树结构。
2. **查询阶段**：高亮目标节点，逐层向上跳跃至满足条件的祖先，显示子树范围。
3. **修改阶段**：闪烁被修改的虚节点，更新其权值颜色（如红→蓝）。

### **复古像素风格**
- **颜色方案**：虚节点用绿色，叶子节点黄色，当前操作节点红色。
- **音效**：跳跃时播放“滴”声，修改成功时“叮”声，错误修改“哔”声。
- **Canvas绘制**：网格布局树结构，节点用像素方块表示，边为直线。

### **交互功能**
- **步进控制**：允许暂停/继续，调整动画速度。
- **自动演示**：AI模式自动执行操作，展示查询路径。

---

## **代码片段（核心逻辑）**
```cpp
// Kruskal重构树构建
void buildKruskal() {
  sort(e+1,e+m+1);
  tot = n;
  for(int i=1; i<=m; i++) {
    int u = find(e[i].from), v = find(e[i].to);
    if(u == v) continue;
    int f = ++tot;
    fa[u] = fa[v] = f;
    G[f].push_back(u); 
    G[f].push_back(v);
    w[f] = e[i].cost;
    to_edge[e[i].id] = f; // 记录边对应虚节点
  }
}

// 预处理子树大小
void dfs(int x) {
  if(x <= n) { sz[x] = 1; return; }
  for(auto y : G[x]) {
    f[y][0] = x;
    dfs(y);
    sz[x] += sz[y];
  }
}
```

---
处理用时：66.23秒
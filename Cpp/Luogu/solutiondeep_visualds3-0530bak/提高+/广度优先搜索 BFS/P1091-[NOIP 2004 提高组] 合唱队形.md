# 题目信息

# [NOIP 2004 提高组] 合唱队形

## 题目描述

$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。

合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1< \cdots <t_i>t_{i+1}>$ … $>t_k(1\le i\le k)$。

你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

## 说明/提示

对于 $50\%$ 的数据，保证有 $n \le 20$。

对于全部的数据，保证有 $n \le 100$。


## 样例 #1

### 输入

```
8
186 186 150 200 160 130 197 220
```

### 输出

```
4
```

# AI分析结果



## 唯一算法分类  
动态规划（最长上升子序列）

---

## 题解思路、算法要点与解决难点  
**核心思路**：每个位置的最长先升后降序列长度 = 正向最长上升子序列（LIS） + 反向最长下降子序列（LDS） - 1  
**关键步骤**：  
1. 正向遍历计算 LIS（每个位置结尾的最长升序）  
2. 反向遍历计算 LDS（每个位置开头的最长降序）  
3. 遍历所有位置，找到 LIS+LDS 最大值  

**数据结构**：  
- 数组 `f1[i]` 记录以 `i` 结尾的 LIS 长度  
- 数组 `f2[i]` 记录以 `i` 开头的 LDS 长度  

**难点对比**：  
- **O(n²) 解法**：双重循环暴力 DP，易理解但效率低  
- **O(n log n) 解法**：二分查找维护升序序列尾值，效率高但实现复杂  

---

## 题解评分 (≥4星)  
1. **VitrelosTia（5⭐）**  
   - 亮点：唯一实现 O(n log n) 复杂度，代码简洁  
   - 优化点：使用 `lower_bound` 二分维护升序序列尾值  

2. **lucky_Mrzhao（4⭐）**  
   - 亮点：代码简洁直观，双循环 DP 易理解  
   - 代码：正反向遍历逻辑清晰，变量命名明确  

3. **majingxuan123（4⭐）**  
   - 亮点：注释详细，变量命名易懂  
   - 技巧：分两次独立计算 LIS 和 LDS  

---

## 最优思路或技巧提炼  
**二分优化 LIS**：  
- 维护数组 `g[]` 存储不同长度 LIS 的最小尾值  
- 对每个元素用 `lower_bound` 快速定位插入位置  
- 正向计算 LIS，反向计算 LDS（等效反转数组的 LIS）  

**代码片段**：  
```cpp
// 正向计算 LIS
for(int i=1; i<=n; i++){
    int pos = lower_bound(g+1, g+len+1, a[i]) - g;
    f1[i] = pos;
    g[pos] = a[i];
    len = max(len, pos);
}
// 反向计算 LDS（等效反转数组的 LIS）
reverse(a+1, a+n+1);
for(int i=1; i<=n; i++){
    int pos = lower_bound(g+1, g+len+1, a[i]) - g;
    f2[i] = pos;
    g[pos] = a[i];
    len = max(len, pos);
}
```

---

## 同类型题及算法套路  
- **最长递增子序列变种**：如双向 LIS、环形 LIS  
- **山脉数组**：类似先升后降结构的最长序列问题  
- **二维 LIS**：信封嵌套问题（LeetCode 354）  

---

## 推荐相似题目  
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)  
2. [AT_chokudai_S001_h LIS](https://www.luogu.com.cn/problem/AT_chokudai_S001_h)  
3. [LeetCode 300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

---

## 可视化与算法演示  
**动画方案**：  
1. **像素风格网格**：用色块表示每个同学，高度映射到颜色深浅  
2. **动态标记**：  
   - 红色高亮当前计算的 LIS 位置  
   - 蓝色标记已确定的 LIS/LDS 长度  
3. **并行对比**：左右分屏展示 O(n²) 和 O(n log n) 的遍历过程  

**交互设计**：  
- **步进控制**：单步执行正向/反向遍历  
- **音效反馈**：找到更大 LIS 时播放上升音调，更新时触发点击音效  

**复古特效**：  
- 8-bit 音效：类似经典游戏《俄罗斯方块》的 block 放置音效  
- 通关动画：找到最优解时像素烟花绽放  

---

## 个人心得摘录  
> VitrelosTia：  
> “维护不同长度 LIS 的最小尾值是二分优化的核心，看似简单但边界处理容易出错，建议用大量数据验证”  
>   
> FISH酱：  
> “双重循环 DP 虽然暴力，但在小数据下更易调试，尤其适合算法初学者理解问题本质”

---
处理用时：86.74秒
# 题目信息

# [HNOI2006] 马步距离

## 题目描述

在国际象棋和中国象棋中，马的移动规则相同，都是走“日”字，我们将这种移动方式称为马步移动。

如下图所示，从标号为 $0$ 的点出发，可以经过一步马步移动达到标号为 $1$ 的点，经过两步马步移动达到标号为 $2$ 的点。

![](https://cdn.luogu.com.cn/upload/pic/15477.png)

任给平面上的两点 $p$ 和 $s$，它们的坐标分别为 $(x_p,y_p)$ 和 $(x_s,y_s)$，从 $(x,y)$ 出发经过一步马步移动可以达到 $(x+1,y+2)$，$(x+2,y+1)$，$(x+1,y-2)$，$(x+2,y-1)$，$(x-1,y+2)$，$(x-2,y+1)$，$(x-1,y-2)$、$(x-2,y-1)$。

假设棋盘充分大，并且坐标可以为负数。现在请你求出从点 $p$ 到点 $s$ 至少需要经过多少次马步移动？

## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，保证 $1 \leq x_p,y_p,x_s,y_s \leq 10^7$。

## 样例 #1

### 输入

```
1 2 7 9```

### 输出

```
5```

# AI分析结果



**唯一算法分类**：贪心 + 打表（BFS预处理）

---

### **题解思路与核心难点**
1. **核心思路**：  
   - **大范围贪心**：当两点距离较远时，每次选择最优移动策略（优先减少较大的坐标差，例如 `x -= 2, y -= 1`），快速逼近目标。  
   - **小范围打表**：当坐标差 ≤ 4 时，直接查预计算的最小步数表（通过 BFS 或手动推导生成）。

2. **解决难点**：  
   - **贪心策略推导**：需证明贪心移动不会错过最优路径（例如：距离越远，贪心步数误差越小）。  
   - **打表优化**：通过 BFS 生成 5×5 表格覆盖所有小范围情况，避免复杂数学推导。

---

### **题解评分（≥4星）**
1. **hulean（5星）**  
   - 思路清晰，代码简洁高效，贪心与打表结合完美。  
   - 亮点：5×5 打表覆盖所有边界情况，贪心逻辑明确。

2. **wzmzmhk（4星）**  
   - 贪心 + BFS 实现灵活，适合动态调整小范围。  
   - 亮点：用 `map` 处理负坐标，通用性强。

3. **konjacq（4星）**  
   - 对称处理简化问题，贪心方向优化合理。  
   - 亮点：通过对称性减少打表范围，代码可读性高。

---

### **最优思路与技巧提炼**
1. **贪心逼近逻辑**：  
   ```cpp
   while (x > 4 || y > 4) {
       if (x < y) swap(x, y); // 保证 x ≥ y
       x -= 2; y -= 1;        // 最优移动方向
       ans++;
   }
   ```
   - **核心变量**：`x` 和 `y` 为两坐标差的绝对值，始终保证 `x ≥ y`。  
   - **操作高亮**：每次循环减少 `x` 2 单位和 `y` 1 单位，动画中可用红色标记减少部分。

2. **打表设计**：  
   ```cpp
   int biao[5][5] = {
       {0,3,2,3,2},
       {3,2,1,2,3},
       {2,1,4,3,2},
       {3,2,3,2,3},
       {2,3,2,3,4}
   };
   ```
   - **生成方式**：通过 BFS 计算 0 ≤ x, y ≤4 的所有情况。  
   - **查表逻辑**：最终步数 = 贪心步数 + `biao[x][y]`。

---

### **同类型题目与算法套路**
1. **通用解法**：大范围贪心 + 小范围精确计算（如 BFS/DP）。  
2. **类似题目**：  
   - **P2324 骑士精神**：棋盘状态用 IDA* 优化搜索。  
   - **P1514 引水入城**：贪心覆盖区间 + 动态规划。  
   - **P1379 八数码难题**：A* 算法 + 状态压缩。

---

### **推荐洛谷题目**
1. **P2324**（骑士精神，IDA* 算法）  
2. **P1379**（八数码，A* 与状态处理）  
3. **P1514**（引水入城，贪心与动态规划结合）

---

### **可视化与算法演示**
1. **动画设计**：  
   - **贪心阶段**：棋盘上显示当前坐标 `(x, y)`，每次移动后坐标更新，绿色箭头标记移动方向。  
   - **打表阶段**：切换至 5×5 网格，高亮查表位置，黄色显示最终步数。  
   - **复古风格**：  
     - **像素棋盘**：用 16 色像素块表示坐标差，贪心移动时播放 8-bit 音效。  
     - **自动演示**：按空格键切换手动/自动模式，速度可调。

2. **代码片段（Canvas 绘制）**：  
   ```javascript
   function drawGrid() {
       ctx.fillStyle = "#8B8B7A"; // 复古棋盘色
       for (let i = 0; i <= x; i += 2) {
           for (let j = 0; j <= y; j += 1) {
               ctx.fillRect(i*10, j*10, 8, 8); // 像素块
           }
       }
   }
   ```

---

### **核心代码实现（hulean 题解）**
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans;
int biao[5][5] = {{0,3,2,3,2}, {3,2,1,2,3}, {2,1,4,3,2}, {3,2,3,2,3}, {2,3,2,3,4}};

int main() {
    int sx, sy, tx, ty;
    cin >> sx >> sy >> tx >> ty;
    int x = abs(sx - tx), y = abs(sy - ty);
    while (x > 4 || y > 4) { // 贪心逼近
        if (x < y) swap(x, y);
        x -= 2; y -= 1;
        ans++;
        x = abs(x); y = abs(y);
    }
    cout << ans + biao[x][y];
    return 0;
}
```

---
处理用时：101.49秒
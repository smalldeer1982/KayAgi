# 题目信息

# [SDOI2011] 消防

## 题目描述

某个国家有 $n$ 个城市，这 $n$ 个城市中任意两个都连通且有唯一一条路径，每条连通两个城市的道路的长度为 $z_i$。

这个国家的人对火焰有超越宇宙的热情，所以这个国家最兴旺的行业是消防业。由于政府对国民的热情忍无可忍（大量的消防经费开销）可是却又无可奈何（总统竞选的国民支持率），所以只能想尽方法提高消防能力。

现在这个国家的经费足以在一条边长度和不超过 $s$ 的路径（两端都是城市）上建立消防枢纽，为了尽量提高枢纽的利用率，要求其他所有城市到这条路径的距离的最大值最小。

你受命监管这个项目，你当然需要知道应该把枢纽建立在什么位置上。

## 说明/提示

对于 $20\%$ 的数据，$n \le 300$。

对于 $50\%$ 的数据，$n \le 3 \times 10^3$。

对于 $100\%$ 的数据，$1\le n \le 3 \times 10^5$，$1\le z_i \le 10^3$。

- 注意，数据中存在权值为 $0$ 的边。



------------
2024/1/28 添加一组 hack 数据。

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3```

### 输出

```
5```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3```

### 输出

```
5```

# AI分析结果



# 树的直径 + 双指针/单调队列

## 算法要点与解决难点

1. **核心结论**：最优路径必在树的直径上。证明思路：若路径外存在更远点，则该点与直径端点构成更长链，矛盾。

2. **关键步骤**：
   - **求直径**：两次BFS/DFS确定端点，回溯记录路径。
   - **预处理**：对每个直径节点，DFS计算其不经过直径的最远距离（非直径分支的最大深度）。
   - **滑动窗口**：双指针维护直径上长度≤s的区间，结合单调队列维护区间内预处理的最大值。

3. **难点对比**：
   - **路径选择**：需严格证明最优解在直径上，部分题解（如wucstdio）未利用此性质，导致复杂度较高。
   - **距离计算**：非直径节点的贡献需独立计算，灵乌路空通过单调队列高效维护，而Demoe用双指针简化。

## 最优思路提炼

1. **确定直径**：两次遍历确定端点，记录路径节点。
2. **预处理分支**：对每个直径节点，DFS其非直径子树的最远距离。
3. **双指针扫描**：在直径上滑动窗口，维护窗口内预处理最大值，计算两端到窗口边界的距离。

## 可视化设计

**动画方案**：
1. **直径绘制**：红色高亮显示树的直径路径。
2. **滑动窗口**：蓝色框选当前路径区间，动态显示左右指针移动。
3. **分支距离**：绿色线条表示当前窗口内各节点的非直径分支最远距离。
4. **实时更新**：窗口移动时，右侧面板显示当前最大值及最终答案。

**复古像素风格**：
- **8位色板**：直径用红/蓝，非直径节点灰阶。
- **音效**：指针移动时播放“哔”声，更新最大值时“叮”声。

## 高星题解推荐

1. **灵乌路空（5星）**：单调队列维护区间最大值，代码高效清晰。
2. **Demoe（5星）**：双指针贪心实现，代码简洁易理解。
3. **良月澪二（4星）**：直接遍历预处理，思路直观。

## 核心代码实现

```cpp
// 求直径端点
void dfs(int u, int fa) {
    for (auto [v, w] : g[u]) {
        if (v == fa) continue;
        dis[v] = dis[u] + w;
        if (dis[v] > maxd) maxd = dis[v], end = v;
        dfs(v, u);
    }
}

// 预处理非直径分支
void dfs_branch(int u, int fa) {
    for (auto [v, w] : g[u]) {
        if (on_diam[v] || v == fa) continue;
        dfs_branch(v, u);
        branch[u] = max(branch[u], branch[v] + w);
    }
}

// 双指针扫描
int ans = INF;
for (int l = 1, r = 1; l <= m; l++) {
    while (r <= m && sum[r] - sum[l] <= s) {
        while (!q.empty() && branch[diam[r]] >= q.back()) q.pop_back();
        q.push_back(branch[diam[r]]);
        r++;
    }
    ans = min(ans, max({sum[l], sum[m] - sum[r-1], q.front()}));
    if (diam[l] == q.front()) q.pop_front();
}
```

## 相似题目

1. **P1099 树网的核**：本题弱化版，数据量小。
2. **P4408 逃学的小孩**：利用直径性质求最长路径。
3. **P3629 巡逻**：动态调整树结构后求直径。

---
处理用时：57.76秒
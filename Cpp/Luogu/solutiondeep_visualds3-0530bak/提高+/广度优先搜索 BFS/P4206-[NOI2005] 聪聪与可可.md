# 题目信息

# [NOI2005] 聪聪与可可

## 题目描述

在一个魔法森林里，住着一只聪明的小猫聪聪和一只可爱的小老鼠可可。虽然灰姑娘非常喜欢她们俩，但是，聪聪终究是一只猫，而可可终究是一只老鼠，同样不变的是，聪聪成天想着要吃掉可可。

一天，聪聪意外得到了一台非常有用的机器，据说是叫 GPS，对可可能准确的定位。有了这台机器，聪聪要吃可可就易如反掌了。于是，聪聪准备马上出发，去找可可。而可怜的可可还不知道大难即将临头，仍在森林里无忧无虑的玩耍。小兔子乖乖听到这件事，马上向灰姑娘报告。灰姑娘决定尽快阻止聪聪，拯救可可，可她不知道还有没有足够的时间。

整个森林可以认为是一个无向图，图中有 $N$ 个美丽的景点，景点从 $1$ 至 $N$ 编号。小动物们都只在景点休息、玩耍。在景点之间有一些路连接。

当聪聪得到 GPS 时，可可正在景点 $M$（$M \le N$）处。以后的每个时间单位，可可都会选择去相邻的景点（可能有多个）中的一个或停留在原景点不动。而去这些地方所发生的概率是相等的。假设有 $P$ 个景点与景点 $M$ 相邻，它们分别是景点 $R$、景点 $S$、……、景点 $Q$，在时刻 $T$ 可可处在景点 $M$，则在 $(T+1)$ 时刻，可可有 $1/(1 +P)$ 的可能在景点 $R$，有 $1/(1 +P)$ 的可能在景点 $S$，……，有 $1/(1 +P)$ 的可能在景点 $Q$，还有$1/(1 +P)$的可能停在景点 $M$。

我们知道，聪聪是很聪明的，所以，当她在景点 $C$ 时，她会选一个更靠近可可的景点，如果这样的景点有多个，她会选一个标号最小的景点。由于聪聪太想吃掉可可了，如果走完第一步以后仍然没吃到可可，她还可以在本段时间内再向可可走近一步。

在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位于同一个景点，则可怜的可可就被吃掉了。

灰姑娘想知道，平均情况下，聪聪几步就可能吃到可可。而你需要帮助灰姑娘尽快的找到答案。

## 说明/提示

【样例说明 1】 

开始时，聪聪和可可分别在景点 1 和景点 4。 

第一个时刻，聪聪先走，她向更靠近可可(景点 4)的景点走动，走到景点 2， 然后走到景点 3；假定忽略走路所花时间。 

可可后走，有两种可能： 第一种是走到景点 3，这样聪聪和可可到达同一个景点，可可被吃掉，步数为 $1$，概率为$0.5$。
 
第二种是停在景点 4，不被吃掉。概率为 $0.5$。

到第二个时刻，聪聪向更靠近可可(景点 4)的景点走动，只需要走一步即和 可可在同一景点。因此这种情况下聪聪会在两步吃掉可可。 所以平均的步数是 $1\times 1/2 + 2\times 1/2 =1.5$ 步。

【样例说明 2】

森林如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/8uiq0ltc.png)

对于 50%的数据，$1≤N≤50$。  
对于所有的数据，$1≤N,E≤1000$。 

## 样例 #1

### 输入

```
4 3 
1 4 
1 2 
2 3 
3 4```

### 输出

```
1.500 
```

## 样例 #2

### 输入

```
9 9 
9 3 
1 2 
2 3 
3 4 
4 5 
3 6 
4 6 
4 7 
7 8 
8 9```

### 输出

```
2.167```

# AI分析结果



# 【算法分类】  
**期望DP + 预处理最短路**

---

## 【题解核心思路与难点分析】  
### ▍核心算法流程  
1. **预处理猫的移动策略**  
   - 对每个猫的位置i，通过反向BFS预处理所有j点的最短距离和最优路径  
   - 构建nxt[i][j]表示猫在i点、鼠在j点时，猫下一步的最优选择  
   - 关键实现：对于每个邻接点v，若dis[v][j]+1=dis[i][j]则更新最优编号  

2. **期望DP状态设计**  
   - 定义f[i][j]表示猫在i、鼠在j时的期望步数  
   - 状态转移：  
     - 若猫两步内能抓到鼠 ⇒ f[i][j] = 1  
     - 否则计算所有可能的鼠移动情况，递归求解  

3. **记忆化搜索优化**  
   - 通过visit数组标记已计算状态  
   - 递归时跳转到猫移动两步后的位置（nxt[nxt[i][j]][j]）

### ▍解决难点对比  
| 题解 | 预处理方式 | DP转移细节 | 实现优化点 |  
|------|------------|------------|------------|  
| FREEH | SPFA求最短路 | 显式处理两步移动 | 代码结构清晰 |  
| SuperJvRuo | BFS分层处理 | 动态维护最优路径 | 反向建边处理 |  
| Booksnow | BFS预计算step数组 | 概率分母提前计算 | 路径更新逻辑更简洁 |  

---

## 【题解评分】  
✅ **FREEH（5星）**  
- 完整呈现SPFA预处理与两步移动逻辑  
- 代码模块划分清晰，注释合理  

✅ **SuperJvRuo（4.5星）**  
- 动态维护step数组方式更节省内存  
- 链式前向星存储优化空间  

✅ **Booksnow（4星）**  
- 反向BFS路径更新逻辑新颖  
- 概率分母预处理提升计算效率  

---

## 【最优思路提炼】  
### 关键技巧  
1. **猫移动策略预处理**  
   - 对每个i点反向BFS构建最短路径树  
   - 通过dis[v][j]+1==dis[i][j]判断邻接点是否在最优路径上  

2. **两步合并处理**  
   ```cpp  
   int sec = nxt[nxt[i][j]][j];  // 猫移动两次后的位置  
   for(所有鼠的可能位置k)  
       sum += dfs(sec, k) * 1/(deg+1)  
   ```  

3. **概率计算优化**  
   ```cpp  
   sum /= (degree[j] + 1.0);  // 包含停留原地的概率  
   f[i][j] = sum + 1;         // 当前步固定消耗1单位时间  
   ```

---

## 【同类题目推荐】  
1. P1850 换教室（期望DP + 最短路预处理）  
2. P2473 奖励关（状态压缩期望DP）  
3. P4542 捉迷藏（最短路与期望结合）

---

## 【核心代码实现】  
### 预处理关键片段  
```cpp  
void BFS(int s) {
    queue<int> q;
    q.push(s);
    dis[s][s] = 0;
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : adj[u]) {
            if(dis[s][v] > dis[s][u]+1) {
                dis[s][v] = dis[s][u]+1;
                nxt[s][v] = u;  // 反向记录路径
                q.push(v);
            } else if(dis[s][v] == dis[s][u]+1) {
                nxt[s][v] = min(nxt[s][v], u); // 取最小编号
            }
        }
    }
}
```

### 记忆化搜索核心  
```cpp  
double dfs(int cat, int mouse) {
    if(cat == mouse) return 0;
    if(vis[cat][mouse]) return f[cat][mouse];
    vis[cat][mouse] = true;

    int next1 = nxt[cat][mouse];
    int next2 = nxt[next1][mouse];
    if(next1 == mouse || next2 == mouse) 
        return f[cat][mouse] = 1.0;

    double sum = dfs(next2, mouse);  // 鼠不动
    for(int v : adj[mouse]) 
        sum += dfs(next2, v);        // 鼠移动
    sum = sum / (adj[mouse].size() + 1) + 1;
    
    return f[cat][mouse] = sum;
}
```

---

## 【可视化方案设计】  
### 动态演示要素  
1. **网格化节点布局**  
   ```javascript  
   // 在Canvas中绘制节点
   function drawNode(x, y, type) {
       ctx.fillStyle = type === 'cat' ? '#FF5555' : '#55AAFF';
       ctx.fillRect(x*50+10, y*30+10, 20, 20);
   }
   ```  

2. **移动轨迹高亮**  
   - 当前猫位置红色闪烁  
   - 预测路径显示绿色连线  
   - 鼠可能移动方向显示半透明蓝色箭头  

3. **概率计算面板**  
   ```javascript  
   // 显示当前状态的概率分布
   function showProb(probs) {
       let html = '';
       for(let [pos, p] of Object.entries(probs)) {
           html += `<div>位置${pos}: ${(p*100).toFixed(1)}%</div>`;
       }
       document.getElementById('prob-panel').innerHTML = html;
   }
   ```  

### 复古像素风格实现  
```css  
/* 8-bit风格CSS */
.canvas-container {
    image-rendering: pixelated;
    background: #2C3A47;
    border: 3px solid #6B7B8C;
}
.pixel-text {
    font-family: 'Press Start 2P', cursive;
    color: #EAB543;
}
```

---

## 【调试经验摘录】  
> "预处理nxt数组时发现反向路径更新的顺序会影响最优编号选择，必须每次比较邻接点编号。调试时构造链式结构测试才暴露问题。" —— FREEH题解评论区  
>   
> 关键教训：预处理阶段需要严格验证所有可能的最短路径分支情况，特别是存在多个等长路径时的编号选择逻辑。

---
处理用时：86.80秒
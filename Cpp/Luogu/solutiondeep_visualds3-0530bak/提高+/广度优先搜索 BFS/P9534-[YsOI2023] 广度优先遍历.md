# 题目信息

# [YsOI2023] 广度优先遍历

## 题目背景

Ysuperman 模板测试的图论题。

【数据删除】

## 题目描述

今天的模板测试是无向图上的广度优先遍历，【数据删除】马上写好了代码：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
const int maxn = 100005;
vector<int> G[maxn];
queue<int> q;
int pa[maxn];
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; ++i)
    {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    memset(pa, -1, sizeof pa);
    q.push(1);
    pa[1] = 0;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (auto v : G[u])
        {
            if (pa[v] != -1)
                continue;
            pa[v] = u;
            q.push(v);
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        cout << pa[i];
        if (i != n)
            cout << " ";
    }
    cout << endl;
    return 0;
}
```

如你所见，这份代码会输入一个 $n$ 个点 $m$ 条边的无向图，并且求出这张图以 $1$ 为根的一棵“广度优先遍历树”，最后输出所有点的父亲节点编号。

不过值得注意的是，这棵“广度优先遍历树”的具体形态和“边的输入顺序”有关，也就是说，不同的输入顺序可能会得到不同的父亲节点编号。

现在【数据删除】告诉了你 $n,m$、这 $m$ 条边以及在某个“边输入顺序”情况下他的代码的输出，你需要还原出这个“边输入顺序”。如果有多种边输入顺序对应的都是这样的输出，你**只需要输出其中任意一种**即可。

特别的，保证有解，且无向图连通，无自环（但是有可能有重边）。

## 说明/提示

#### 样例 1 解释

直接运行【数据删除】的代码即可。

如果不改变边输入顺序，将下面数据输入【数据删除】的代码：

```
4 4
2 1
1 3
2 4
4 3
```

他的代码跑出来结果如下：

```
0 1 1 2
```

如果按照样例 1 输出给出的顺序，即，将下面数据输入他的代码：

```
4 4
1 3
3 4
1 2
2 4
```

输出为：

```
0 1 1 3
```

#### 数据范围

对于前 $10\%$ 的数据，满足 $n\le 8$，$m\le 10$。

对于前 $40\%$ 的数据，满足 $n\le 1000$，$m\le 2000$。

另有 $10\%$ 的数据，满足 $m=n-1$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$1\le m\le 2\times 10^5$。

#### 提示

为什么有可能会有重边，因为懒得去重了，这个家伙出图论题就是懒得判重边的（）

附件下发了本题 checker。

## 样例 #1

### 输入

```
4 4
2 1
1 3
2 4
4 3
0 1 1 3```

### 输出

```
1 3
3 4
1 2
2 4
```

## 样例 #2

### 输入

```
8 9
7 8
6 1
5 4
7 1
4 1
3 7
2 6
7 5
2 4
0 6 7 1 4 1 1 7```

### 输出

```
6 2
7 3
4 5
1 6
7 8
1 4
1 7
2 4
5 7```

# AI分析结果



---

## 算法分类
**图论 - 拓扑排序与广度优先搜索树约束分析**

---

## 综合分析与结论
### 核心思路
题目要求通过给定的 BFS 树反推边的输入顺序，关键在于处理非树边带来的约束关系。所有题解的核心逻辑可分为以下步骤：

1. **分层分析**  
   BFS 树中每个点的深度固定，非树边只能是同层或相邻层。相邻层非树边（如深度差 1）会带来父节点优先级的约束。

2. **约束关系建模**  
   - 树边的输入顺序需优先于同层其他可能覆盖该点的非树边  
   - 对相邻层非树边，需找到其与树边的 LCA 以确定优先级，建立有向边约束

3. **拓扑排序**  
   将边作为节点，约束关系作为有向边，通过拓扑排序确定可行输入顺序

### 解决难点
- **LCA 快速计算**：通过倍增预处理实现 O(log n) 查询  
- **重边处理**：使用 map 记录边出现次数，避免重复计数  
- **线性复杂度**：部分题解通过层次遍历和入度优化实现 O(n + m) 复杂度

### 可视化设计
1. **核心算法流程演示**  
   - 初始状态：展示 BFS 树结构，用不同颜色区分树边和非树边  
   - 约束建立：高亮当前处理非树边，动态绘制其对应的 LCA 路径和约束边（红色箭头）  
   - 拓扑排序：队列节点动态染色（绿色为已处理，黄色为待处理），边顺序逐步输出

2. **复古像素化风格**  
   - **颜色方案**：树边（蓝色）、非树边（灰色）、约束边（红色）、当前处理节点（闪烁黄框）  
   - **音效设计**：  
     - 建立约束时播放 "beep" 短音  
     - 输出边时播放 8-bit "coin" 音效  
     - 拓扑排序完成时播放胜利旋律

3. **交互控制**  
   - 速度滑块调节动画速率（1x~5x）  
   - "AI 自动" 模式展示标准解法的完整流程  
   - 单步模式可逐帧观察约束建立细节

---

## 题解清单（≥4星）
### 1. xiaolilsq（★★★★☆）
- **关键亮点**：  
  - 清晰阐述非树边约束关系，通过 LCA 建立偏序  
  - 使用拓扑排序处理多约束，代码结构清晰  
- **代码片段**：  
  ```cpp
  // 建立约束关系
  for 非树边 (u, v) {
      if (dep[u] == dep[v]) continue;
      int l = lca(u, v);
      for (k 属于 l 的子树叶子节点) 
          添加约束边 k → 当前边;
  }
  ```

### 2. yxzy4615（★★★★★）
- **关键亮点**：  
  - 线性时间复杂度 O(n + m)  
  - 利用层次遍历和入度队列优化  
- **核心代码**：  
  ```cpp
  // 层次处理与入度优化
  for (int d = max_depth; d >= 1; d--) {
      for (u 属于当前层) 
          for (v : 相邻且深度差1的点)
              更新父节点优先级，并入队处理
  }
  ```

### 3. RsCb（★★★★☆）
- **调试心得**：  
  > "被重边虚空调试了 12 分钟，需特别注意树边判重"

---

## 最优技巧提炼
### 关键技巧
1. **LCA 约束建模**  
   对相邻层非树边，通过 LCA 找到其与树边的交汇点，建立子树间的偏序关系。

2. **拓扑排序优化**  
   按层次逆序处理节点，利用队列动态维护入度为 0 的节点，避免重复扫描。

### 代码实现
```cpp
// 倍增 LCA 预处理
void dfs(int u) {
    for (int j=1; j<=20; j++) 
        fa[u][j] = fa[fa[u][j-1]][j-1];
    for (int v : tree[u]) dfs(v);
}

// 拓扑主流程
queue<int> q;
for (i=1 to n) if (in[i]==0) q.push(i);
while (!q.empty()) {
    int u = q.front(); q.pop();
    输出边 u;
    for (v : 约束边[u]) 
        if (--in[v] == 0) q.push(v);
}
```

---

## 相似题目推荐
1. **P3379 【模板】最近公共祖先（LCA）**  
   - 关键点：倍增法求 LCA

2. **P1137 旅行计划**  
   - 关键点：拓扑排序与层次遍历结合

3. **P1347 排序**  
   - 关键点：边约束关系与拓扑排序判定

---

## 可视化实现片段
```javascript
// Canvas 绘制树结构
function drawTree(ctx) {
    nodes.forEach(node => {
        ctx.fillStyle = node.depth % 2 ? '#3498db' : '#e74c3c'; 
        ctx.fillRect(node.x, node.y, 20, 20);
        node.edges.forEach(edge => {
            ctx.beginPath();
            ctx.moveTo(edge.from.x +10, edge.from.y +10);
            ctx.lineTo(edge.to.x +10, edge.to.y +10);
            ctx.strokeStyle = edge.isTree ? '#2ecc71' : '#95a5a6';
            ctx.stroke();
        });
    });
}

// 拓扑排序动画帧
function animateTopo() {
    if (currentStep >= order.length) return;
    let edge = order[currentStep];
    edge.element.classList.add('highlight'); // 高亮当前边
    playSound('blip'); // 播放音效
    currentStep++;
    requestAnimationFrame(animateTopo);
}
```

---
处理用时：75.20秒
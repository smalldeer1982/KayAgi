# 题目信息

# [EC Final 2022] Chinese Checker

## 题目描述

棋盘上有 $n$ 个棋子，你需要求对于当前局面，下一次移动有多少种不同的走法。

一次移动由若干步组成。假设当前要移动的棋子为 $a$，在每一步中，首先需要选择另一个棋子 $b$ 作为跳台，然后将 $a$ 走到关于 $b$ 的对称位置（在一次移动中，你无法更改需要移动的棋子 $a$。并且在某一步中，棋子 $a$ 回到此次移动前所在的位置是不被允许的）。

关于跳台 $b$ 的选择有一些条件：

- $a$ 和 $b$ 之间的连线应当平行于棋盘的某条坐标轴。注：棋盘上一共有三条坐标轴，其中一条与水平线平行，并且任意两条坐标轴之间的夹角均为 $\frac{\pi}{3}$。

- $a$ 和 $b$ 不必相邻。

- 除了跳台 $b$ 以外，$a$ 和其关于 $b$ 的对称点的连线上不能有其他棋子。

- 对称点的位置应当落在棋盘上，并且没有被其他棋子占据。

一次移动需要至少走一步。在第一步以后，你可以随时停下来。你可以选择棋盘上任意一个棋子作为移动棋子。请输出有多少种不同的走法。

两种走法不同当且仅当两次移动后所有棋子的位置组成的集合不同，并且棋子之间不可区分。

## 样例 #1

### 输入

```
5
1
1 1
2
1 1
2 1
2
9 4
9 6
10
1 1
2 1
2 2
3 1
3 2
3 3
4 1
4 2
4 3
4 4
10
1 1
2 1
2 2
5 7
3 2
3 3
4 1
4 2
4 3
4 4
```

### 输出

```
0
1
2
6
13
```

# AI分析结果



---

## 算法分类  
**模拟、深度优先搜索（DFS）**

---

## 题解思路与核心难点分析  

### 算法核心逻辑  
1. **坐标系转换**：将六芒星棋盘映射为二维直角坐标系，定义六个跳跃方向（Δx, Δy）以简化移动判断。  
2. **跳跃模拟**：  
   - 每次跳跃需检查：跳台存在、路径无其他棋子、目标点合法且空闲。  
   - 跳跃步数可累加，但每次跳跃必须满足中间仅有一个棋子（跳台）。  
3. **DFS 回溯**：对每个棋子枚举所有可能的跳跃方向和步数，通过 `set` 记录已访问状态避免重复计数。  

### 解决难点  
- **坐标映射的准确性**：需预定义每行的左右边界数组（`l[], r[]`）确保跳跃后坐标合法。  
- **路径阻挡判断**：通过 `jump` 函数统计路径经过的棋子数，严格限定 `c1 == 1`（仅跳台）。  
- **状态回溯**：DFS 中需临时修改棋子位置并回溯，避免影响其他分支的计算。  

---

## 题解评分  

### 1. FFTotoro（⭐⭐⭐⭐⭐）  
- **亮点**：  
  - 坐标系转换与方向数组设计简洁高效。  
  - 使用 `set` 实现棋盘状态快速查询与去重。  
  - 递归回溯逻辑清晰，代码紧凑。  
- **代码可读性**：Lambda 函数与 `pair` 操作稍显复杂，但注释明确。  

### 2. LHLeisus（⭐⭐⭐⭐）  
- **亮点**：  
  - 棋盘预处理为二维数组，直观判断合法性。  
  - 强调剪枝细节（及时返回、路径唯一性）。  
- **不足**：代码未完整展示，预处理部分略显繁琐。  

---

## 最优思路提炼  

### 关键技巧  
1. **方向数组法**：定义六个方向的 (Δx, Δy)，统一处理所有可能跳跃。  
2. **跳跃步数枚举**：通过 `jump(p, d, k)` 函数模拟多步跳跃，统计路径棋子数。  
3. **状态哈希去重**：利用 `set<pii>` 记录当前移动分支的已访问位置，避免循环跳跃。  

### 代码核心片段  
```cpp
pair<pii,int> jump(pii a, int d, int s, int c=0) {
  while (s--) {
    a.first += dx[d], a.second += dy[d];
    if (m.find(a) != m.end()) c++; // 统计路径棋子数
  }
  return {a, c};
}

function<void(int)> dfs = [&](int i) {
  s.emplace(a[i]); // 标记已访问
  for (int j=0; j<6; j++) // 枚举六个方向
    for (int k=1; k<=6; k++) { // 枚举跳跃步数
      auto [p, c1] = jump(a[i], j, k);
      if (c1 == 1 && check(p) && m.count(p)) { // 跳台合法
        auto [e, c2] = jump(p, j, k);
        if (!c2 && check(e) && !m.count(e)) { // 目标点合法
          pii t = a[i];
          m.erase(t), m.insert(e); // 修改状态
          if (!s.count(e)) dfs(i); // 递归搜索
          m.erase(e), m.insert(t); // 回溯
        }
      }
    }
};
```

---

## 同类题目推荐  
1. **P1032 字串变换**：状态转移与 BFS 模拟。  
2. **P1379 八数码难题**：棋盘状态哈希与搜索。  
3. **P1120 小木棍**：DFS 剪枝与路径回溯。  

---

## 个人心得摘录  
- **FFTotoro**：  
  > “坐标转换错误曾导致 100→20 分惨案，务必画图验证边界条件。”  
- **LHLeisus**：  
  > “爆搜时需及时标记已访问点，否则可能陷入死循环。”  

---

## 可视化设计  

### 动画方案  
1. **像素棋盘绘制**：  
   - 使用 Canvas 绘制 17x17 网格，合法区域填充绿色，棋子为红色像素块。  
   - 跳跃路径高亮为黄色，跳台标记为蓝色。  
2. **方向与跳跃演示**：  
   - 点击棋子后显示六个方向箭头，选择方向后动态绘制跳跃轨迹。  
   - 实时显示 `jump` 函数的路径检查过程（红色×表示阻挡）。  
3. **状态回溯可视化**：  
   - 递归分支用不同颜色区分，回溯时棋盘状态渐变恢复。  

### 复古游戏化要素  
- **音效设计**：  
  - 跳跃成功：8-bit 上升音调（`0x1A` 方波）。  
  - 阻挡路径：短促蜂鸣（`0x05` 噪声）。  
- **积分与连击**：  
  - 每次有效跳跃+10 分，连续无回溯跳跃触发连击倍率。  
- **自动演示模式**：  
  - AI 按优先级选择方向，速度可调（1x~5x）。  

---

## 总结  
本题核心在于坐标系设计与跳跃模拟的细节处理，结合 DFS 与状态哈希可高效解决。可视化需突出路径检查与递归回溯过程，复古像素风格增强理解趣味性。

---
处理用时：83.71秒
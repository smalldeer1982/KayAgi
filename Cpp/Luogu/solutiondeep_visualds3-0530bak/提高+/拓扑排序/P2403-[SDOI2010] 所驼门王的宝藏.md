# 题目信息

# [SDOI2010] 所驼门王的宝藏

## 题目描述

在宽广的非洲荒漠中，生活着一群勤劳勇敢的羊驼家族。被族人恭称为“先知”的 AlpacaL.Sotomon 是这个家族的领袖，外人也称其为“所驼门王”。所驼门王毕生致力于维护家族的安定与和谐，他曾亲自率军粉碎河蟹帝国主义的野蛮侵略，为族人立下赫赫战功。所驼门王一生财宝无数，但因其生性节俭低调，他将财宝埋藏在自己设计的地下宫殿里，这也是今天 Henry Curtis 故事的起点。Henry 是一个爱财如命的贪婪家伙，而又非常聪明，他费尽心机谋划了这次盗窃行动，破解重重机关后来到这座地下宫殿前。

整座宫殿呈矩阵状，由 $R \times C$ 间矩形宫室组成，其中有 $N$ 间宫室里埋藏着宝藏，称作藏宝宫室。宫殿里外、相邻宫室间都由坚硬的实体墙阻隔，由一间宫室到达另一间只能通过所驼门王独创的移动方式——传送门。所驼门王为这 $N$ 间藏宝宫室每间都架设了一扇传送门，没有宝藏的宫室不设传送门，所有的宫室传送门分为三种：

1. “横天门”：由该门可以传送到同行的任一宫室；
2. “纵寰门”：由该门可以传送到同列的任一宫室；
3. “任意门”：由该门可以传送到以该门所在宫室为中心周围 $8$ 格中任一宫室（如果目标宫室存在的话）。

深谋远虑的 Henry 当然事先就搞到了所驼门王当年的宫殿招标册，书册上详细记录了每扇传送门所属宫室及类型。而且，虽然宫殿内外相隔，但他自行准备了一种便携式传送门，可将自己传送到殿内任意一间宫室开始寻宝，并在任意一间宫室结束后传送出宫。整座宫殿只许进出一次，且便携门无法进行宫室之间的传送。不过好在宫室内传送门的使用没有次数限制，每间宫室也可以多次出入。

现在 Henry 已经打开了便携门，即将选择一间宫室进入。为得到尽多宝藏，他希望安排一条路线，使走过的不同藏宝宫室尽可能多。请你告诉 Henry 这条路线最多行经不同藏宝宫室的数目。

## 说明/提示

数据规模和约定：

![](https://cdn.luogu.com.cn/upload/pic/1594.png)


## 样例 #1

### 输入

```
10 7 7
2 2 1
2 4 2
1 7 2
2 7 3
4 2 2
4 4 1
6 7 3
7 7 1
7 5 2
5 2 1```

### 输出

```
9```

# AI分析结果



**算法分类**  
Tarjan缩点 + 拓扑排序DP

---

**综合分析与结论**  
**核心思路**：  
1. **建图优化**：  
   - 横天门：同一行的横天门连成环，环中任一节点可到达同行其他横天门；非横天门节点从环中任一节点连出。  
   - 纵寰门：同一列的纵寰门连成环，类似横天门处理。  
   - 任意门：暴力枚举周围8格，通过哈希表（`map`或`unordered_map`）快速判断是否存在目标点。  
2. **缩点与DP**：  
   - 用Tarjan算法缩点，每个强连通分量（SCC）的权值为其包含的节点数。  
   - 在DAG上拓扑排序后，动态规划求最长路径，状态转移方程为：  
     \[
     f[v] = \max(f[v], f[u] + \text{size}[v])
     \]

**难点与解决方案**：  
- **建图爆炸**：通过行/列环结构和哈希表优化边数，将边数从\(O(n^2)\)降为\(O(n)\)。  
- **虚点处理**：部分题解引入行/列虚点，统一管理同一行或列的非关键节点。  
- **DAG构造**：缩点后需重新建边并统计入度，避免重复边。  

**可视化设计**：  
1. **像素化步骤演示**：  
   - **网格绘制**：用Canvas绘制宫室矩阵，不同颜色区分横天门（红色）、纵寰门（蓝色）、任意门（绿色）。  
   - **连边动画**：建环时高亮同一行/列的节点，动态绘制环边；任意门连边时闪烁目标格子。  
   - **缩点过程**：强连通分量收缩为单一色块，显示分量大小。  
2. **音效与交互**：  
   - **关键操作音**：连边时播放“连接”音效，缩点时播放“合并”音效，DP更新时播放“升级”音效。  
   - **步进控制**：支持暂停/继续、单步执行，观察Tarjan递归栈变化和拓扑排序队列状态。  
3. **自动演示模式**：  
   - 算法自动运行，配合字幕解释当前步骤（如“正在处理第3行横天门”）。  

---

**题解清单（≥4星）**  
1. **Sue_Shallow（4星）**  
   - **亮点**：详细解释横纵门环状连边，代码注释清晰，使用`pair`和`map`优化任意门处理。  
   - **代码片段**：  
     ```cpp
     // 横向建环（横天门）
     sort(point+1,point+all+1,xf_cmp);
     int first=1,last=1;
     for(int i=1;i<=all;i++) {
         if(point[i].x!=point[i+1].x) {
             if(first!=last) add(point[last].number,point[first].number);
             last=first=i+1;
         } else {
             if(point[last].opt==1) add(point[last].number,point[i+1].number);
             if(point[i+1].opt==1) last=i+1;
             if(point[first].opt!=1) last=first=i+1;
         }
     }
     ```
2. **yingjz（4星）**  
   - **亮点**：引入行/列虚点，将横纵门统一连接到虚点，大幅减少边数。  
   - **代码片段**：  
     ```cpp
     // 行虚点管理横天门
     for(int i=1;i<=n;i++) {
         add(x[i], r+c+i);  // 行虚点指向当前点
         if(t[i]==1) add(r+c+i, x[i]);  // 横天门反向连回虚点
     }
     ```
3. **lzx2005（4星）**  
   - **亮点**：利用排序预处理同行同列节点，减少循环次数，代码高效。  
   - **心得**：“先排序后连边，避免重复判断行列边界”。  

---

**最优思路与技巧**  
1. **环状连边**：将同行/列的同类型门连成环，确保强连通性，避免暴力连边。  
2. **行列虚点**：通过虚点统一管理非关键节点，简化边数（如虚点连向所有同行节点）。  
3. **哈希表优化**：用`map<tuple<int,int>,int>`快速定位任意门周围8格是否存在目标点。  

---

**同类型题与算法套路**  
- **缩点+拓扑DP**：P3387（缩点模板）、P2746（校园网络）、P2002（消息扩散）。  
- **网格建图优化**：P5025（炸弹）、P5471（跳房子）。  

---

**推荐题目**  
1. **P3387** 【模板】缩点  
2. **P2746** [USACO5.3] 校园网络  
3. **P2002** 消息扩散  

---

**个人心得摘录**  
- **调试教训**：  
  > “`map`直接访问不存在的键会插入默认值，导致MLE，必须用`count`先判断存在性。”  
- **优化经验**：  
  > “预处理所有行/列的门并排序，确保循环时直接跳过无效节点。”  

---

**代码核心实现（Tarjan+DP）**  
```cpp
// Tarjan缩点
void tarjan(int u) {
    dfn[u] = low[u] = ++idx;
    stk[++top] = u; ins[u] = 1;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if (ins[v]) low[u] = min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
        scc_cnt++;
        do {
            int x = stk[top--];
            ins[x] = 0;
            scc[x] = scc_cnt;
            size[scc_cnt] += (x <= n); // 不统计虚点
        } while (stk[top+1] != u);
    }
}

// 拓扑排序DP
void topo() {
    queue<int> q;
    for (int i=1; i<=scc_cnt; i++)
        if (!in[i]) q.push(i), dp[i] = size[i];
    while (!q.empty()) {
        int u = q.front(); q.pop();
        ans = max(ans, dp[u]);
        for (int i = dag_head[u]; i; i = dag_e[i].next) {
            int v = dag_e[i].to;
            dp[v] = max(dp[v], dp[u] + size[v]);
            if (--in[v] == 0) q.push(v);
        }
    }
}
```

---

**可视化设计要点（像素风格）**  
1. **Canvas绘制**：  
   - 每个宫室为16x16像素块，横天门红色，纵寰门蓝色，任意门绿色，虚点灰色。  
   - 连边时显示白色轨迹线，缩点时分量变为黄色块并显示大小。  
2. **音效触发**：  
   - `addEdge()`：播放短促“滴”声。  
   - `tarjan()`合并SCC：播放“咔嚓”合并音。  
   - DP更新：高亮节点并播放“升级”音效。  
3. **自动演示模式**：  
   - 按步骤高亮当前处理的行/列，显示连边逻辑，5秒后自动进入下一步。  
   - 底部状态栏显示：“正在缩点，当前分量数：3”。  

```javascript
// 示例：像素动画（伪代码）
function drawGrid() {
    ctx.fillStyle = '#333'; // 背景色
    ctx.fillRect(0, 0, width, height);
    for (let x = 0; x < R; x++) {
        for (let y = 0; y < C; y++) {
            if (map.has(x, y)) {
                let id = map.get(x, y);
                ctx.fillStyle = getColorByType(id); // 根据类型选色
                ctx.fillRect(x*16, y*16, 15, 15);
            }
        }
    }
}
```

---
处理用时：103.85秒
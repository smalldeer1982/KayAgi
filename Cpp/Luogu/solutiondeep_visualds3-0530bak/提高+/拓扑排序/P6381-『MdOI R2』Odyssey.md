# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果



## 算法分类  
动态规划（DP）结合数论处理与图论拓扑排序  

---

## 综合分析与结论  
### 核心思路  
1. **数论处理**：将边权分解质因数后对指数取模，得到唯一对应的配对权值，确保相邻边权满足乘积为 $c^k$。  
2. **状态定义**：定义 $f_{u, s}$ 表示以节点 $u$ 结尾，最后一条边权的哈希状态为 $s$ 时的最长路径长度。  
3. **动态规划转移**：遍历每条边时，用前驱节点的配对状态更新当前节点的状态。  
4. **拓扑排序**：利用 DAG 特性按拓扑序处理节点，保证状态转移的正确性。  

### 可视化设计  
- **分解过程动画**：用粒子效果展示边权分解质因数，动态显示指数取模后的结果。  
- **状态转移高亮**：以不同颜色标记当前处理边及其配对状态，用箭头连接前驱与当前节点。  
- **像素风格交互**：  
  - 节点用 8-bit 像素方块表示，边权配对状态用颜色编码（如蓝/红表示配对）。  
  - 音效触发：分解完成时播放「哔」声，状态更新时播放「叮」声，找到最长路径时播放经典 FC 过关音效。  
  - 自动演示模式：按拓扑序逐帧推进，支持暂停/加速。  

---

## 题解清单（≥4星）  
1. **BFqwq（4.5星）**  
   - 亮点：分层图拓扑排序避免状态冲突，预处理配对权值后双倍数组处理。  
   - 代码关键：通过质因数分解生成 $f_i$，分两层节点交替转移。  

2. **一扶苏一（4.5星）**  
   - 亮点：双模数哈希避免冲突，直接通过 map 存储状态，代码简洁高效。  
   - 代码关键：分解质因数后计算哈希，用 `map<pair<int,uLL>,int>` 实现状态转移。  

3. **under_the_time（4星）**  
   - 亮点：将大质数分离处理优化存储，用 `pair<vector<int>,pii>` 压缩状态。  
   - 代码关键：分层存储质因数分解结果，分块处理大质数。  

---

## 最优思路代码片段  
```cpp
// 一扶苏一题解的核心代码（双模哈希 + map 状态存储）
void Make_hash() {
  for (int i = 1; i <= m; ++i) {
    d.clear(); cd.clear(); dcnt = 0;
    for (int x = edge[i].w, pp = 0; x != 1; x /= prm[pre[x]]) 
      if (pp == pre[x]) ++cd[dcnt - 1];
      else d.push_back(pre[x]), cd.push_back(1), ++dcnt;
    for (int j = 0; j < maxh; ++j) hash[j][i] = make_hash(j);
    for (int j = 0; j < dcnt; ++j) cd[j] = t - cd[j];
    for (int j = 0; j < maxh; ++j) ph[j][i] = make_hash(j);
  }
}

void Calc() {
  pair<int, int> k;
  for (int i = n, u = topo[i]; i; u = topo[--i]) 
    for (auto e : g[u]) {
      k = {hash[0][e], hash[1][e]};
      f[u][k] = max(f[u][k], e.l + f[e.v][{ph[0][e], ph[1][e]}]);
    }
}
```

---

## 类似题目推荐  
1. **P3385 【模板】负环**（拓扑排序与图论基础）  
2. **P1072 [NOIP2009 提高组] Hankson 的趣味题**（质因数分解与数论条件）  
3. **P4017 最大食物链计数**（DAG 上的动态规划）  

---

## 个人心得摘录  
> "预处理配对时注意大质数可能导致溢出，需特判超过值域的情况。" —— BFqwq  
> "双模哈希能有效避免冲突，但需注意计算时的取模顺序。" —— 一扶苏一  

---

## 可视化与游戏化实现（伪代码）  
```javascript
// 伪代码：像素风格动画核心逻辑
class OdysseyVisualizer {
  constructor(nodes, edges) {
    this.canvas = initCanvas(); // 初始化像素画布
    this.sound = new AudioContext(); // 音效控制器
    this.nodes = nodes.map(n => new PixelNode(n)); // 像素化节点
    this.edges = edges.map(e => new PixelEdge(e)); // 动态边动画
  }

  play() {
    this.nodes.sortByTopology().forEach(node => {
      this.highlightNode(node); // 高亮当前处理节点
      node.edges.forEach(edge => {
        this.showPrimeFactors(edge); // 分解质因数动画
        const pair = this.findPair(edge); // 显示配对边
        this.updateState(node, pair); // 状态转移动画
        this.playSound('blip'); 
      });
    });
    this.playVictoryTheme(); // 最长路径找到时
  }
}
```

---
处理用时：72.84秒
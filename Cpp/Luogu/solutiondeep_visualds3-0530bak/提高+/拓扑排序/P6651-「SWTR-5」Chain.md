# 题目信息

# 「SWTR-5」Chain

## 题目描述

给定 $n$ 个点，$m$ 条边的有向无环图。不保证图连通。

$q$ 次询问，每次给出 $k$ 和 $k$ 个互不相同的数 $c_i$，求出如果去掉这 $k$ 个点，整个有向无环图将剩余多少条链。答案对 $10^9+7$ 取模。**每次询问独立。**

- “链”的定义是：我们设一条长度为 $p$ 的链的路径为 $w_0\to w_1\to\cdots\to w_{p-1}\to w_p$，则应满足 $w_0$ 入度为 $0$，$w_p$ 出度为 $0$。你可以将其理解为一条食物链。

- 两条链是“不同的”，当且仅当它们的长度不同，或者经过的点集不同。

- **需要特别注意的是，删去某些点后新产生的链不计入答案。** 例如 $1\to 2\to 3\to 4$ 一图中，有 $1$ 条链 $1\to 2\to 3\to 4$。如果去掉 $2$ 号点，则剩余 $0$ 条链。

## 说明/提示

「样例 $1$ 说明」

DAG 如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2gbdoemh.png)

询问 $1$：如果去掉 $2,4,6$，则剩余 $1$ 条链：$3\to 5$。

询问 $2$：如果去掉 $4,6$，则剩余 $3$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$。

询问 $7$：如果去掉 $6$，则剩余 $5$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$，$3\to 1\to 4\to 5$，$3\to 7\to 4\to 5$。

「数据范围与约定」

**本题采用捆绑测试。**

- Subtask 1（1 point）：给定的图是一条链。
- Subtask 2（14 points）：$n,q\leq 10$。
- Subtask 3（20 points）：$q\leq 10^3$。
- Subtask 4（17 points）：$k=1$。
- Subtask 5（18 points）：$k=2$。
- Subtask 6（30 points）：无特殊限制。

对于 $100\%$ 的数据：$2\leq n\leq 2\times 10^3$，$1\leq m\leq \min(\frac{n\times(n-1)}{2},2\times 10^4)$，$1\leq q\leq 5\times 10^5$。  
所有询问满足：$1\leq \sum k\leq 2\times 10^6$，$0\leq k\leq \min(n,15)$，$1\leq c_i\leq n$。保证 $c_i$ 互不相同。

**本题轻微卡常，请注意 IO 优化。**

---

「题目来源」

[Sweet Round 05](https://www.luogu.com.cn/contest/28195) D。  
idea & solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

## 样例 #1

### 输入

```
7 14
3 2
4 5
2 5
2 6
3 1
3 5
3 7
3 6
6 4
1 4
6 5
1 6
7 2
7 4
7
3 2 4 6
2 4 6
2 2 5
2 1 4
0
1 4
1 6```

### 输出

```
1
3
0
6
13
7
5```

## 样例 #2

### 输入

```
233 1
1 2
6
0
1 10
2 10 40
1 1
1 2
2 1 2```

### 输出

```
232
231
230
231
231
231```

# AI分析结果



**唯一算法分类**  
动态规划（DP）与容斥原理的结合

---

**题解思路、算法要点与解决难点**  
所有题解核心逻辑均包含以下步骤：  
1. **拓扑排序预处理**：计算每个点的拓扑序，并预处理两点间路径数 `d[i][j]`  
2. **DP 路径计数**：  
   - `f[i]`：从入度为 0 的起点到 i 的路径数  
   - `g[i]`：从 i 到出度为 0 的终点的路径数  
3. **容斥处理删除点**：  
   - 将待删除点按拓扑序排序  
   - 动态调整路径数，避免重复计算被删除点的影响  

**核心难点**在于高效处理多删除点的容斥关系。通过拓扑序排序确保处理顺序，使得每个点仅需考虑其前驱点的贡献，避免重复计算。例如，当删除点 `c_i` 时，需减去其所有前驱删除点 `c_j`（`j < i`）的路径贡献。

---

**题解评分 (≥4星)**  
1. **yxzy4615（★★★★☆）**  
   - 亮点：从 k=1 到 k=15 的递推分析清晰，代码通过拓扑序预处理路径矩阵  
   - 优化点：代码注释较少，但逻辑紧凑  

2. **a___（★★★★☆）**  
   - 亮点：引入超级源汇点简化问题，代码实现简洁高效  
   - 关键代码段：  
     ```cpp  
     sort(c+1,c+1+m,cmp); // 按拓扑序排序删除点  
     for(i=1;i<=m;i++)d[i]=f[c[i]];  
     for(i=1;i<=m;i++)for(j=i+1;j<=m;j++)  
         d[j]=(d[j]-1ll*d[i]*h[c[i]][c[j]]%p+p)%p; // 容斥调整  
     ```  

3. **EnofTaiPeople（★★★★☆）**  
   - 亮点：详细注释预处理步骤，代码可读性极佳  
   - 个人心得：强调拓扑序的必要性及容斥顺序  

---

**最优思路提炼**  
1. **拓扑序动态调整路径数**  
   - 预处理所有点对的路径数 `d[i][j]`  
   - 按拓扑序处理删除点，确保每个点仅受前驱影响  

2. **容斥公式**  
   - 删除点 `c_i` 时，路径数调整为：  
     ```  
     ans = sum - Σ (f[c_i] * g[c_i]) + Σ (f[c_j] * d[c_j][c_i] * g[c_i])  
     ```  
   - 通过动态规划逐步减去重叠贡献  

---

**同类型题与算法套路**  
- **通用解法**：DAG 上的路径计数 + 容斥处理删除点  
- **类似题目**：  
  1. 洛谷 P3387（最长路，拓扑排序 + DP）  
  2. 洛谷 P4017（食物链计数，DAG 路径数统计）  
  3. 洛谷 P2741（矩形覆盖，拓扑序容斥）  

---

**推荐相似题目**  
1. **P3387**：拓扑排序求最长路径  
2. **P4017**：统计 DAG 食物链数量  
3. **P2741**：矩形覆盖的容斥优化  

---

**可视化与算法演示**  
1. **动画设计**：  
   - **拓扑排序过程**：以网格展示节点，逐步染色标记拓扑序  
   - **路径数计算**：用流动线条表示 `f[i]` 和 `g[i]` 的传播  
   - **删除点处理**：高亮当前删除点，显示其前驱节点的路径贡献被动态扣除  

2. **复古像素风格**：  
   - **颜色方案**：16 色调色板，绿色表示存活点，红色表示删除点  
   - **音效触发**：  
     - 节点被删除时播放短促“哔”声  
     - 路径数更新时触发像素点击音效  

3. **交互控制**：  
   - **步进控制**：允许单步执行拓扑排序或容斥步骤  
   - **自动演示**：AI 模式展示最优删除顺序的计算流程  

---

**代码片段示例（核心容斥逻辑）**  
```cpp  
// 按拓扑序排序删除点并处理  
sort(del+1, del+k+1, cmp);  
for (int i=1; i<=k; i++) {  
    ans[i] = f[del[i]];  
    for (int j=1; j<i; j++)  
        ans[i] -= ans[j] * d[del[j]][del[i]]; // 减去前驱影响  
    total = (total - ans[i] * g[del[i]] % MOD + MOD) % MOD;  
}  
```

---

**总结**  
本题通过拓扑序预处理和容斥动态调整，将单次查询复杂度优化至 O(k²)，完美匹配数据规模。关键突破点在于利用 DAG 的无环特性，通过拓扑序确保计算顺序的正确性。

---
处理用时：72.64秒
# 题目信息

# [CSP-S2020] 函数调用

## 题目描述

函数是各种编程语言中一项重要的概念，借助函数，我们总可以将复杂的任务分解成一个个相对简单的子任务，直到细化为十分简单的基础操作，从而使代码的组织更加严密、更加有条理。然而，过多的函数调用也会导致额外的开销，影响程序的运行效率。

某数据库应用程序提供了若干函数用以维护数据。已知这些函数的功能可分为三类：

1. 将数据中的指定元素加上一个值；
2. 将数据中的每一个元素乘以一个相同值；
3. **依次**执行若干次函数调用，保证不会出现递归（即不会直接或间接地调用本身）。

在使用该数据库应用时，用户可一次性输入要调用的函数序列（一个函数可能被调用多次），在**依次**执行完序列中的函数后，系统中的数据被加以更新。某一天，小 A 在应用该数据库程序处理数据时遇到了困难：由于频繁而低效的函数调用，系统在执行操作时进入了无响应的状态，他只好强制结束了数据库程序。为了计算出正确数据，小 A 查阅了软件的文档，了解到每个函数的具体功能信息，现在他想请你根据这些信息帮他计算出更新后的数据应该是多少。

## 说明/提示

**【样例 #1 解释】**

$1$ 号函数功能为将 $a_1$ 的值加一。$2$ 号函数功能为所有元素乘 $2$。$3$ 号函数将先调用 $1$ 号函数，再调用 $2$ 号函数。

最终的函数序列先执行 $2$ 号函数，所有元素的值变为 $2, 4, 6$。

再执行 $3$ 号函数时，先调用 $1$ 号函数，所有元素的值变为 $3, 4, 6$。再调用 $2$ 号函数，所有元素的值变为 $6, 8, 12$。

**【数据范围】**

| 测试点编号 | $n, m, Q \le$ | $\sum C_j$ | 其他特殊限制 |
| :----------: | :----------: | :----------: | :----------: |
| $1 \sim 2$ | $1000$ | $= m - 1$ | 函数调用关系构成一棵树 |
| $3 \sim 4$ | $1000$ | $\le 100$ | 无 |
| $5 \sim 6$ | $20000$ | $\le 40000$ | 不含第 $2$ 类函数或不含第 $1$ 类函数 |
| $7$ | $20000$ | $= 0$ | 无 |
| $8 \sim 9$ | $20000$ | $= m - 1$ | 函数调用关系构成一棵树 |
| $10 \sim 11$ | $20000$ | $\le 2 \times 10^5$ | 无 |
| $12 \sim 13$ | $10^5$ | $\le 2 \times 10^5$ | 不含第 $2$ 类函数或不含第 $1$ 类函数 |
| $14$ | $10^5$ | $= 0$ | 无 |
| $15 \sim 16$ | $10^5$ | $= m - 1$ | 函数调用关系构成一棵树 |
| $17 \sim 18$ | $10^5$ | $\le 5 \times 10^5$ | 无 |
| $19 \sim 20$ | $10^5$ | $\le 10^6$ | 无 |

对于所有数据：$0 \le a_i \le 10^4$，$T_j \in \{1,2,3\}$，$1 \le P_j \le n$，$0 \le V_j \le 10^4$，$1 \le g^{(j)}_k \le m$，$1 \le f_i \le m$。

## 样例 #1

### 输入

```
3
1 2 3
3
1 1 1
2 2
3 2 1 2
2
2 3
```

### 输出

```
6 8 12```

## 样例 #2

### 输入

```
10
1 2 3 4 5 6 7 8 9 10
8
3 2 2 3
3 2 4 5
3 2 5 8
2 2
3 2 6 7
1 2 5
1 7 6
2 3
3
1 2 3```

### 输出

```
36 282 108 144 180 216 504 288 324 360
```

## 样例 #3

### 输入

```
见附件中的 call/call3.in```

### 输出

```
见附件中的 call/call3.ans```

# AI分析结果



## 唯一算法分类  
图论 - 拓扑排序  

---

## 综合分析与结论  

### 核心思路  
1. **乘法因子计算**：通过反向拓扑排序预处理每个函数执行后的全局乘法倍数（mul数组）  
2. **调用次数计算**：通过正向拓扑排序递推每个函数实际执行次数（cnt数组）  
3. **贡献合并**：所有加法操作的有效值 = 调用次数 × 加法值 × 后续乘法因子积  

### 难点与解决方案  
1. **调用顺序影响**：类型3函数需要倒序处理子函数调用，维护后缀乘法积（now_mul）  
2. **乘法叠加效应**：通过两次拓扑排序将全局乘法因子与局部调用次数解耦  
3. **递归调用限制**：DAG结构保证拓扑排序可行性，避免循环依赖  

### 可视化设计  
1. **图结构展示**：用不同颜色节点表示三类函数（红-加法，蓝-乘法，绿-组合）  
2. **拓扑排序动画**：  
   - 反向拓扑时高亮当前处理节点及其mul值变化  
   - 正向拓扑时显示cnt值的传播路径  
3. **调用链演示**：  
   ```  
   主函数 → 函数3 → [函数1, 函数2]  
   动态显示：  
   - 函数3调用时now_mul初始化为1  
   - 倒序处理函数2时now_mul *= mul[函数2]  
   - 处理函数1时应用当前now_mul  
   ```  

---

## 题解清单（≥4星）  

1. **小菜鸟（⭐⭐⭐⭐⭐）**  
   - 亮点：清晰的双拓扑结构，完整注释代码  
   - 核心代码：  
     ```cpp  
     void topo1() { // 计算mul数组  
         queue<int> q;  
         for(int i=0;i<=m;++i) if(!deg1[i]) q.push(i);  
         while(!q.empty()) {  
             int u = q.front(); q.pop();  
             for(int v : G1[u]) {  
                 mul[v] = mul[v] * mul[u] % MOD;  
                 if(--deg1[v] == 0) q.push(v);  
             }  
         }  
     }  
     ```  

2. **AK_Dream（⭐⭐⭐⭐）**  
   - 亮点：后缀积预处理，反向边处理  
   - 关键步骤：  
     ```cpp  
     for(int i=G2[u].size();i!=0;--i) { // 倒序处理子函数  
         int v = G2[u][i-1];  
         cnt[v] += cnt[u] * now_mul;  
         now_mul *= mul[v];  
     }  
     ```  

3. **OMG_wc（⭐⭐⭐⭐）**  
   - 亮点：统一函数调用入口，虚拟主函数设计  
   - 实现技巧：  
     ```cpp  
     m++; // 创建虚拟主函数  
     while(Q--) {  
         int x; cin >> x;  
         G2[m].push_back(x); // 所有调用挂到主函数  
     }  
     ```  

---

## 核心逻辑代码实现  

```cpp  
// 关键数据结构  
vector<int> G1[N], G2[N]; // 正/反向图  
int mul[N], cnt[N], deg1[N], deg2[N];  

// 第一次拓扑：计算乘法因子  
void topo1() {  
    queue<int> q;  
    for(int i=0;i<=m;++i) if(!deg1[i]) q.push(i);  
    while(!q.empty()) {  
        int u = q.front(); q.pop();  
        for(int v : G1[u]) {  
            mul[v] = (ll)mul[v] * mul[u] % MOD;  
            if(--deg1[v] == 0) q.push(v);  
        }  
    }  
}  

// 第二次拓扑：计算调用次数  
void topo2() {  
    queue<int> q;  
    for(int i=0;i<=m;++i) if(!deg2[i]) q.push(i);  
    while(!q.empty()) {  
        int u = q.front(); q.pop();  
        int now_mul = 1;  
        for(int i=G2[u].size(); i>0; --i) { // 倒序处理  
            int v = G2[u][i-1];  
            cnt[v] = (cnt[v] + (ll)cnt[u] * now_mul) % MOD;  
            now_mul = (ll)now_mul * mul[v] % MOD;  
            if(--deg2[v] == 0) q.push(v);  
        }  
    }  
}  
```

---

## 相似题目推荐  

1. **P1983 车站分级**（拓扑排序应用）  
2. **P1137 旅行计划**（DAG上的动态规划）  
3. **P2742 电路维修**（双队列拓扑排序）  

---

## 可视化设计（复古像素版）  

**实现要点**：  
1. **Canvas绘制**：  
   - 800x600分辨率，16色调色板  
   - 函数节点用8x8像素块表示（红-加法，蓝-乘法，黄-组合）  
2. **动画流程**：  
   ```  
   1. 显示初始数据阵列（底部32x32像素网格）  
   2. 主函数节点闪烁后，扩散出调用链光效  
   3. 处理类型3函数时：  
      - 子函数逐个高亮（绿色边框）  
      - 右侧显示now_mul的二进制像素数字  
   4. 拓扑队列用像素风格队列动画显示  
   ```  
3. **音效设计**：  
   - 节点入队：8-bit "哔"声（100Hz方波）  
   - 乘法计算：下降琶音（200Hz→100Hz）  
   - 完成提示：经典FC过关音效  

**交互功能**：  
- 空格键：暂停/继续  
- 方向键：单步前进/后退  
- F1：显示算法参数（mul/cnt值）  

---

通过这种结构化解析，学习者可以系统掌握拓扑排序在复杂调用关系中的应用，同时通过复古可视化加深对算法流程的理解。

---
处理用时：77.71秒
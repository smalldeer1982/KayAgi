# 题目信息

# [USACO22JAN] Minimizing Haybales P

## 题目描述

Bessie 感到无聊，于是又在 Farmer John 的牛棚里制造麻烦。FJ 有 $N$（$1 \le N \le 10^5$）堆草堆。对于每个 $i \in [1,N]$，第 $i$ 堆草堆有 $h_i$（$1 \le h_i \le 10^9$）的草。Bessie 不想让任何的草倒下来，所以她唯一可以执行的操作为：

- 如果两个相邻的草堆的高度相差不超过 $K$（$1 \le K \le 10^9$），她可以交换这两堆草堆。

Bessie 在一系列这样的操作之后可以得到的的字典序最小的高度序列是什么？

## 说明/提示

【样例解释】

一种 Bessie 可以交换草堆的方式如下：

```plain
   7 7 3 6 2
-> 7 7 6 3 2
-> 7 7 6 2 3
-> 7 6 7 2 3
-> 6 7 7 2 3
```

【数据范围】

- 所有测试点的 $10\%$ 满足 $N \le 100$。
- 所有测试点的另外 $20\%$ 满足 $N \le 5000$。
- 其余 $70\%$ 的测试点没有额外限制。

供题：Daniel Zhang，Benjamin Qi

## 样例 #1

### 输入

```
5 3
7
7
3
6
2```

### 输出

```
6
7
7
2
3```

# AI分析结果



## 算法分类
**拓扑排序 + 线段树优化**

---

## 综合分析与结论

### 核心思路
所有不能交换的相邻元素构成DAG拓扑关系，通过优先队列选择字典序最小的拓扑序。关键难点在于高效维护节点的入度变化。

### 解决难点
1. **入度快速计算**：离散化后，用线段树维护每个数值的入度（比当前值小且超过K差的元素数量）。
2. **动态更新入度**：每次选中一个元素后，需要将与其可交换的区间外的元素入度减1，线段树区间更新实现。
3. **离散化处理**：将原始高度映射到离散值，方便区间操作。

### 可视化设计思路
- **动画效果**：展示线段树节点入度的实时更新，高亮当前选中的最小值及其影响的区间。
- **颜色标记**：选中元素用绿色高亮，影响的区间用红色标记入度减1操作。
- **步进控制**：单步执行查看线段树如何维护入度和选择过程。

---

## 题解评分 (≥4星)

### 1. ETHANK (⭐️⭐️⭐️⭐️⭐️)
- **亮点**：线段树维护入度，离散化处理清晰，代码结构简洁。
- **核心代码**：
```cpp
void build(int p,int L,int R){
    if(L == R){
        t[p] = make_pair(L,deg[L]);
        return;
    }
    // 递归构建左右子树...
}

void upd(int p,int L,int R,int l,int r,int v){
    if(l > R || r < L) return;
    if(l <= L && R <= r){
        push(p,v);
        return;
    }
    // 区间更新入度...
}
```

### 2. panyf (⭐️⭐️⭐️⭐️)
- **亮点**：平衡树维护插入位置，两次二分查找确定可移动范围。
- **难点**：平衡树分裂合并操作需要精确处理子树的最大最小值。

### 3. xglight (⭐️⭐️⭐️⭐️)
- **亮点**：主席树优化建图，减少边数到O(N log N)。
- **核心思想**：将数值区间连边转化为线段树区间操作。

---

## 最优思路提炼
1. **离散化处理**：将原始高度映射到有序值域，便于后续区间操作。
2. **线段树维护入度**：初始入度通过树状数组计算，动态更新时区间加减。
3. **贪心选择最小值**：每次选当前入度0的最小值，保证字典序最小。

---

## 类似题目
1. [P8100 [USACO22JAN] Herdle P](https://www.luogu.com.cn/problem/P8100)
2. [AGC001F Wide Swap](https://atcoder.jp/contests/agc001/tasks/agc001_f)
3. [CF1385E Directing Edges](https://codeforces.com/problemset/problem/1385/E)

---

## 个人心得摘录
- **ETHANK**：通过树状数组计算初始入度是关键，避免暴力统计。
- **panyf**：平衡树维护插入位置时，需同时记录子树极值以快速判断合法区间。

---

## 可视化算法演示

### 核心流程
1. **初始化**：离散化数组，线段树构建入度。
2. **选择元素**：线段树查询当前最小入度元素。
3. **更新入度**：对受影响区间执行区间减1操作。

### 复古像素风格设计
- **颜色方案**：绿色选中元素，红色表示入度更新区间。
- **Canvas动画**：网格展示线段树节点，点击单步执行观察更新。
- **音效**：选中时播放上升音调，区间更新时播放短暂“滴”声。

```javascript
// 示例：线段树区间更新动画
function highlightRange(node, l, r) {
    ctx.fillStyle = 'rgba(255,0,0,0.3)';
    ctx.fillRect(l * gridSize, 0, (r-l+1)*gridSize, canvas.height);
}
```

---

## 代码实现（ETHANK解法）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n, K, a[N], val[N], deg[N];
unordered_map<int, int> vis;

struct SegTree {
    pii t[N<<2];
    int tag[N<<2];
    // 构建与更新逻辑...
} st;

int main() {
    cin >> n >> K;
    // 离散化处理...
    // 计算初始入度...
    st.build(1, 1, n);
    for(int i=1; i<=n; i++) {
        int u = st.queryMin();
        cout << val[u] << '\n';
        // 更新受影响区间入度...
    }
}
```

---

**关键操作**：
- **离散化**：`lower_bound`确定数值位置。
- **入度计算**：树状数组统计前缀中不可交换的数量。
- **线段树区间更新**：每次选中元素后调整相关区间。

---
处理用时：71.63秒
# 题目信息

# 「TAOI-1」椎名真昼

## 题目背景

**请注意赛后题目添加了多测。因此请将您的赛时代码进行修改后再提交。**

## 题目描述

你正在看轻小说，突然你的家长走了进来，于是你假装在写 OI 题目。

Alice 和 Bob 正在玩一款游戏，给定一个有向图，每个点初始有一个颜色（黑或白）。

双方轮流进行操作，Alice 先手，每次操作选定一个节点，将所有从该点开始，能到达的点（包括自身）颜色翻转。如果某次操作后所有节点都变为白色，则进行该次操作的人胜利。

假如双方都采用最优策略使得自己胜利，或者如果自己无法胜利，使得对方无法胜利。

给你节点的初始状态，请你求出最终的胜者，亦或者，没有胜者。

---

定义点 $u$ 能到达点 $v$，当且仅当存在数列 $(a_1,a_2,a_3,\cdots,a_k)$，其中 $k \ge 1$，使得 $\forall i \in [1,k)$，存在有向边 $a_i \to a_{i+1}$，且 $a_1=u$，$a_k=v$。

## 说明/提示

### 数据范围

**本题采用捆绑测试**。

- Subtask 1（5 points）：$n \leq 2$，$m \leq 1$，$T=1$。
- Subtask 2（15 points）：$n \leq 5$，$m \leq 8$，$T=1$。
- Subtask 3（25 points）：保证所有点的初始颜色相同。
- Subtask 4（55 points）：无特殊限制。

对于所有测试数据，$1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times 10^5$，$1 \le T \le 15$。

### 样例解释

在第一组数据中，Alice 可以先手对节点 $1$ 进行操作。操作后所有节点变为白色。

在第二组数据中，双方都没有必胜的方法，因此双方会互相拖延对方阻止对方获胜。

---

「据说如果无论如何都输出 `N` 的话，有 $45\%$ 的几率能够得到正确答案？」

「怎么可能，不会真的有人造出这么蠢的数据吧……」

## 样例 #1

### 输入

```
2
2 1
1 0
2 1
3 2
1 0 1
1 2
2 3```

### 输出

```
AN```

# AI分析结果



**唯一算法分类**  
强连通分量缩点与博弈论分析  

---

### **题解思路、算法要点与解决难点**  
#### **核心思路**  
1. **缩点处理**：通过Tarjan算法将原图缩为强连通分量（SCC），确保每个SCC内部颜色一致。若存在异色SCC，直接判平局。  
2. **DAG分析**：将缩点后的图转为DAG，通过拓扑排序寻找关键黑点，判断Alice是否能一步覆盖所有黑点。  
3. **博弈条件**：  
   - **Alice胜**：存在一个黑点SCC，其子树覆盖所有黑点且不涉及白点。  
   - **Bob胜**：全白、两个孤立黑点或黑点SCC连向白点SCC的结构。  

#### **解决难点**  
- **高效缩点**：Tarjan算法处理大规模图的强连通分量（时间复杂度$O(n+m)$）。  
- **博弈条件推导**：通过拓扑序和入度分析确定Bob的必胜条件，避免暴力枚举。  
- **边界处理**：特殊结构（如两点图）需单独判断。  

---

### **题解评分 (≥4星)**  
1. **251Sec（5星）**：  
   - 思路清晰，详细推导Bob的三种必胜条件。  
   - 代码结构完整，通过拓扑排序和DFS验证覆盖性。  
2. **MSavannah（4星）**：  
   - 代码简洁，通过缩点和入度分析快速判断胜负。  
   - 关键注释明确，便于理解核心逻辑。  
3. **xiaoliebao1115（4星）**：  
   - 简练概括三种情况，代码注重多测清空和边界处理。  

---

### **最优思路或技巧提炼**  
1. **缩点后拓扑序分析**：通过拓扑序第一个黑点验证覆盖性，避免冗余遍历。  
2. **博弈状态剪枝**：仅需判断前两步胜负，后续操作可被策略抵消（如重复对方操作）。  
3. **高效条件判断**：通过入度分析根节点（入度为0的SCC），快速锁定关键结构。  

---

### **同类型题或类似算法套路**  
- **强连通分量+博弈**：如[P2141 棋盘覆盖](https://www.luogu.com.cn/problem/P2141)。  
- **DAG拓扑序应用**：如[P3387 缩点](https://www.luogu.com.cn/problem/P3387)。  
- **博弈有限步数分析**：如[P2964 取石子游戏](https://www.luogu.com.cn/problem/P2964)。  

---

### **推荐相似题目**  
1. [P2141 棋盘覆盖](https://www.luogu.com.cn/problem/P2141)  
2. [P3387 缩点](https://www.luogu.com.cn/problem/P3387)  
3. [P2964 取石子游戏](https://www.luogu.com.cn/problem/P2964)  

---

### **可视化与算法演示**  
**核心流程动画设计**：  
1. **像素化缩点过程**：  
   - **颜色标记**：红色表示当前DFS节点，蓝色表示已处理SCC。  
   - **音效触发**：发现异色SCC时播放“错误音效”，缩点完成播放“成功音效”。  
2. **DAG拓扑排序**：  
   - **网格绘制**：每个SCC为像素方块，箭头表示边方向。  
   - **动态高亮**：拓扑序首个黑点闪烁，覆盖路径以绿色蔓延。  
3. **胜负判定演示**：  
   - **胜利条件触发**：全白时播放“胜利音效”，特殊结构（如两点图）以黄色边框标记。  

**复古游戏化设计**：  
- **8位音效**：使用[Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)生成FC风格音效。  
- **Canvas动画**：网格大小为32x32像素，算法步骤以“回合制”自动播放。  
- **积分系统**：正确判断胜负得10分，错误扣5分，连击加成。  

---

### **代码核心逻辑实现**  
```cpp
// 缩点与颜色检查（Tarjan算法）
bool tarjan(int u) {
    // ...（略）
    if (dfn[u] == low[u]) {
        scc_cnt++;
        do {
            t = stk.top();
            scc_id[t] = scc_cnt;
            if (color[t] != init_color) has_diff = true; // 检查颜色一致性
        } while (t != u);
        if (has_diff) return false; // 异色SCC，平局
    }
    return true;
}

// 判断Alice能否一步胜利
bool check_alice_win() {
    int first_black =拓扑序首个黑点;
    DFS覆盖检查(first_black);
    return 覆盖所有黑点 && 不涉及白点;
}

// 判断Bob的三种必胜结构
bool check_bob_win() {
    if (全白) return true;
    if (两个孤立黑点) return true;
    if (黑连白两点图) return true;
    return false;
}
```

**完整代码**（见用户提供的题解中的251Sec或MSavannah代码段）  

---

### **个人心得摘录**  
- **调试教训**：未清空全局变量导致多测错误（如`deg`数组未初始化）。  
- **思维突破**：博弈步数有限性（两步内定胜负）是关键简化点。  
- **优化技巧**：将SCC颜色压缩为单值，避免逐点检查。  

--- 

**可视化示例（伪代码）**  
```javascript
// 伪代码：Canvas绘制缩点过程
function drawSCC() {
    ctx.fillStyle = "#8B00FF"; // 紫色表示SCC
    for (let scc of scc_list) {
        for (let node of scc.nodes) {
            let x = (node.id % 10) * 32;
            let y = Math.floor(node.id / 10) * 32;
            ctx.fillRect(x, y, 32, 32);
        }
    }
}
```

---
处理用时：76.75秒
# 题目信息

# [YsOI2023] 广度优先遍历

## 题目背景

Ysuperman 模板测试的图论题。

【数据删除】

## 题目描述

今天的模板测试是无向图上的广度优先遍历，【数据删除】马上写好了代码：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
const int maxn = 100005;
vector<int> G[maxn];
queue<int> q;
int pa[maxn];
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; ++i)
    {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    memset(pa, -1, sizeof pa);
    q.push(1);
    pa[1] = 0;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (auto v : G[u])
        {
            if (pa[v] != -1)
                continue;
            pa[v] = u;
            q.push(v);
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        cout << pa[i];
        if (i != n)
            cout << " ";
    }
    cout << endl;
    return 0;
}
```

如你所见，这份代码会输入一个 $n$ 个点 $m$ 条边的无向图，并且求出这张图以 $1$ 为根的一棵“广度优先遍历树”，最后输出所有点的父亲节点编号。

不过值得注意的是，这棵“广度优先遍历树”的具体形态和“边的输入顺序”有关，也就是说，不同的输入顺序可能会得到不同的父亲节点编号。

现在【数据删除】告诉了你 $n,m$、这 $m$ 条边以及在某个“边输入顺序”情况下他的代码的输出，你需要还原出这个“边输入顺序”。如果有多种边输入顺序对应的都是这样的输出，你**只需要输出其中任意一种**即可。

特别的，保证有解，且无向图连通，无自环（但是有可能有重边）。

## 说明/提示

#### 样例 1 解释

直接运行【数据删除】的代码即可。

如果不改变边输入顺序，将下面数据输入【数据删除】的代码：

```
4 4
2 1
1 3
2 4
4 3
```

他的代码跑出来结果如下：

```
0 1 1 2
```

如果按照样例 1 输出给出的顺序，即，将下面数据输入他的代码：

```
4 4
1 3
3 4
1 2
2 4
```

输出为：

```
0 1 1 3
```

#### 数据范围

对于前 $10\%$ 的数据，满足 $n\le 8$，$m\le 10$。

对于前 $40\%$ 的数据，满足 $n\le 1000$，$m\le 2000$。

另有 $10\%$ 的数据，满足 $m=n-1$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$1\le m\le 2\times 10^5$。

#### 提示

为什么有可能会有重边，因为懒得去重了，这个家伙出图论题就是懒得判重边的（）

附件下发了本题 checker。

## 样例 #1

### 输入

```
4 4
2 1
1 3
2 4
4 3
0 1 1 3```

### 输出

```
1 3
3 4
1 2
2 4
```

## 样例 #2

### 输入

```
8 9
7 8
6 1
5 4
7 1
4 1
3 7
2 6
7 5
2 4
0 6 7 1 4 1 1 7```

### 输出

```
6 2
7 3
4 5
1 6
7 8
1 4
1 7
2 4
5 7```

# AI分析结果



## **算法分类**  
图论、拓扑排序、BFS树构造  

---

## **题解思路与解决难点**  

### **核心逻辑**  
所有题解的核心思路均围绕 **BFS树构建 + 非树边约束分析 + 拓扑排序**：  
1. **构建给定父节点数组对应的BFS树**，确定各节点深度。  
2. **分析非树边约束**：  
   - 非树边若连接相邻层节点（如深度差为1），需保证父节点优先被访问。  
   - 通过LCA（最近公共祖先）确定偏序关系，建立边之间的先后顺序约束。  
3. **拓扑排序**：根据约束关系生成合法边输入顺序。  

### **解决难点对比**  
- **LCA的快速计算**：PNNNN、RsCb等题解使用倍增法预处理LCA，确保高效处理大量节点。  
- **重边处理**：clarkwang、mc123456等题解通过哈希表标记已处理边，避免重复约束。  
- **线性时间复杂度**：yxzy4615的题解通过维护入度直接拓扑排序，无需显式建图，达到严格线性复杂度。  

---

## **题解评分 (≥4星)**  
1. **xiaolilsq（★★★★★）**  
   - **亮点**：最简洁的约束推导，直观解释非树边影响，代码逻辑清晰。  
   - **代码片段**：  
     ```cpp  
     // 建立约束关系后拓扑排序  
     for (非树边 u-v) {  
         if (dep[u] == dep[v]) continue;  
         LCA分析并添加约束;  
     }  
     ```  

2. **RsCb（★★★★☆）**  
   - **亮点**：将非树边分为三类，通过LCA与倍增法高效处理深度差，代码模块化。  
   - **心得**：“深度差超过1的非树边不可能存在”是关键观察。  

3. **yxzy4615（★★★★☆）**  
   - **亮点**：严格线性时间复杂度，通过入度直接拓扑排序，无需显式建图。  
   - **代码片段**：  
     ```cpp  
     for (int i=1;i<=n;i++) if (!in[i]) q.push(i);  
     while (!q.empty()) {  
         int x = q.front(); q.pop();  
         // 输出边并更新入度  
     }  
     ```  

---

## **最优思路提炼**  
**关键技巧**：  
1. **LCA确定偏序**：对于非树边连接的相邻层节点，通过LCA找到最近共同祖先，确保父节点路径的边优先输入。  
2. **拓扑排序生成顺序**：将所有约束关系建模为DAG，通过拓扑排序输出合法边序列。  

**思维突破**：  
- **BFS树的性质**：非树边必须满足深度差≤1，否则会导致更早访问，成为树边。  
- **重边处理**：通过哈希表或标记数组避免重复添加约束。  

---

## **同类题目推荐**  
1. **P3379 【模板】最近公共祖先（LCA）**  
   - 练习倍增法求LCA，为本题约束分析提供基础。  
2. **P1137 旅行计划**  
   - 拓扑排序应用，与本题边顺序生成逻辑类似。  
3. **P1347 排序**  
   - 偏序关系与拓扑排序的经典问题，可对比学习约束建模。  

---

## **可视化与算法演示**  
### **动画设计**  
1. **BFS树构建**：  
   - 用绿色高亮树边，红色标记非树边，动态展示节点按层扩展。  
2. **约束关系生成**：  
   - 对非树边，显示LCA计算过程，并用黄色箭头标识偏序关系（如边A需在边B前）。  
3. **拓扑排序执行**：  
   - 队列用蓝色框表示，节点按入度变为0的顺序依次出队，右侧显示当前输出边序列。  

### **复古像素风格实现**  
- **Canvas绘制**：  
  - 节点为8x8像素方块，边为像素线条，树边绿色，非树边红色。  
  - 拓扑排序队列用闪烁的蓝色边框表示，当前处理边高亮为黄色。  
- **音效**：  
  - 边被输出时播放短促“哔”声，拓扑排序完成时播放胜利音效。  

### **交互功能**  
- **步进控制**：支持暂停/继续，单步观察LCA计算和约束添加。  
- **速度调节**：滑动条控制动画速度（1x~10x）。  

---

## **核心代码实现**  
以 **xiaolilsq** 的题解为例：  
```cpp  
// 建立偏序关系后拓扑排序  
vector<int> dag[M];  
for (每条非树边 u-v) {  
    if (dep[u] != dep[v] + 1) continue;  
    int k = LCA(u, fa[v]); // 倍增法求LCA  
    int x = jump(u, dep[u] - dep[k] - 1); // 向上跳至LCA下一层  
    int y = jump(fa[v], dep[fa[v]] - dep[k] - 1);  
    dag[边x-k的编号].push_back(边y-k的编号);  
}  
// 拓扑排序输出  
queue<int> q;  
for (边i) if (入度[i]==0) q.push(i);  
while (!q.empty()) {  
    int u = q.front(); q.pop();  
    输出边u;  
    for (v : dag[u]) if (--入度[v] == 0) q.push(v);  
}  
```  

---

## **总结**  
本题解核心在于 **将非树边的约束转化为拓扑排序问题**，通过LCA和BFS树性质建模偏序关系。可视化设计需突出关键步骤（LCA计算、约束添加、拓扑执行），复古像素风格增强学习趣味性。同类题目可加深对拓扑排序和BFS树的理解。

---
处理用时：82.86秒
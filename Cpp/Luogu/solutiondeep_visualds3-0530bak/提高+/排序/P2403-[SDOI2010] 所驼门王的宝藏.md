# 题目信息

# [SDOI2010] 所驼门王的宝藏

## 题目描述

在宽广的非洲荒漠中，生活着一群勤劳勇敢的羊驼家族。被族人恭称为“先知”的 AlpacaL.Sotomon 是这个家族的领袖，外人也称其为“所驼门王”。所驼门王毕生致力于维护家族的安定与和谐，他曾亲自率军粉碎河蟹帝国主义的野蛮侵略，为族人立下赫赫战功。所驼门王一生财宝无数，但因其生性节俭低调，他将财宝埋藏在自己设计的地下宫殿里，这也是今天 Henry Curtis 故事的起点。Henry 是一个爱财如命的贪婪家伙，而又非常聪明，他费尽心机谋划了这次盗窃行动，破解重重机关后来到这座地下宫殿前。

整座宫殿呈矩阵状，由 $R \times C$ 间矩形宫室组成，其中有 $N$ 间宫室里埋藏着宝藏，称作藏宝宫室。宫殿里外、相邻宫室间都由坚硬的实体墙阻隔，由一间宫室到达另一间只能通过所驼门王独创的移动方式——传送门。所驼门王为这 $N$ 间藏宝宫室每间都架设了一扇传送门，没有宝藏的宫室不设传送门，所有的宫室传送门分为三种：

1. “横天门”：由该门可以传送到同行的任一宫室；
2. “纵寰门”：由该门可以传送到同列的任一宫室；
3. “任意门”：由该门可以传送到以该门所在宫室为中心周围 $8$ 格中任一宫室（如果目标宫室存在的话）。

深谋远虑的 Henry 当然事先就搞到了所驼门王当年的宫殿招标册，书册上详细记录了每扇传送门所属宫室及类型。而且，虽然宫殿内外相隔，但他自行准备了一种便携式传送门，可将自己传送到殿内任意一间宫室开始寻宝，并在任意一间宫室结束后传送出宫。整座宫殿只许进出一次，且便携门无法进行宫室之间的传送。不过好在宫室内传送门的使用没有次数限制，每间宫室也可以多次出入。

现在 Henry 已经打开了便携门，即将选择一间宫室进入。为得到尽多宝藏，他希望安排一条路线，使走过的不同藏宝宫室尽可能多。请你告诉 Henry 这条路线最多行经不同藏宝宫室的数目。

## 说明/提示

数据规模和约定：

![](https://cdn.luogu.com.cn/upload/pic/1594.png)


## 样例 #1

### 输入

```
10 7 7
2 2 1
2 4 2
1 7 2
2 7 3
4 2 2
4 4 1
6 7 3
7 7 1
7 5 2
5 2 1```

### 输出

```
9```

# AI分析结果



# 算法分类
**强连通分量缩点 + 拓扑排序 + 动态规划**

---

## 核心思路与难点突破
### 题解要点对比
| 题解作者 | 建图优化方法 | 处理横/纵门 | 处理任意门 | 核心亮点 |
|---------|--------------|-------------|------------|----------|
| Sue_Shallow | 排序后环状连接同行/列传送门 | 每行横门连成环 | STL map记录坐标 | 通过排序优先处理同类门，显著减少边数 |
| yingjz | 虚节点表示行/列 | 行虚点连所有同行点 | 哈希表存储坐标 | 用虚节点统一处理行/列连接，边数降至O(n) |
| 爱迪生 | 行/列代表点连所有点 | 代表点双向连接同类门 | 暴力检查周围坐标 | 引入代表点概念简化建图逻辑 |
| lzx2005 | 行/列虚点预连接 | 虚点与同类门双向连接 | 预存坐标数组二分查找 | 提前处理行/列虚点，建图层次清晰 |

**关键难点解决**：  
1. **横纵门优化**：通过将同类门连成环（如Sue_Shallow）或引入行/列虚节点（如yingjz），将O(n²)边数降为O(n)
2. **任意门邻接**：使用STL map或哈希表（如hzoi_liuchang）快速查询周围坐标
3. **缩点后处理**：在DAG上拓扑排序后，用DP求最长路径`dp[v] = max(dp[u] + scc_size[v])`

---

## 题解评分（≥4星）
1. **Sue_Shallow（★★★★☆）**  
   - 亮点：通过排序优先处理同类门，STL map清晰记录坐标  
   - 优化点：行/列环状连接逻辑需要仔细处理首尾指针

2. **yingjz（★★★★★）**  
   - 亮点：虚节点统一管理行/列，哈希表高效查询任意门邻接  
   - 优化点：需处理虚节点与实际节点的连接关系

3. **碳六灵（★★★★☆）**  
   - 亮点：kdtree优化空间查询，创新性使用树结构处理矩阵  
   - 注意：kdtree实现复杂度较高，需处理边界情况

---

## 最优技巧提炼
### 建图四步法
```cpp
// 1. 处理横天门（同行环状连接）
sort(points按行排序);
for(每行){
   创建环：横天门1→横天门2→...→横天门n→横天门1
   其他门：环中任一节点→该门
}

// 2. 处理纵寰门（同列环状连接，同上）

// 3. 处理任意门（8方向查询）
map<pair<int,int>, int> pos_map; // 存储坐标到节点ID
for(每个任意门){
   检查周围8格：if(pos_map存在该坐标) 创建边
}

// 4. 虚节点优化（可选）
行虚点x→该行所有点，纵虚点y→该列所有点
横天门→行虚点，纵寰门→纵虚点
```

---

## 同类题目推荐
1. **P3387 【模板】缩点**（强连通分量+DP）  
2. **P2746 [USACO5.3] 校园网**（SCC缩点+度数统计）  
3. **P2272 [ZJOI2007]最大半连通子图**（DAG最长路径计数）

---

## 算法可视化设计
### 像素化演示方案
**关键步骤动画**：  
1. **行环构建**：用绿色像素块表示横天门，按行排列后连接成环状，黄色箭头显示连接顺序  
2. **虚节点连接**：红色虚节点悬浮在行/列边缘，蓝色线条连接该行所有实际节点  
3. **任意门扫描**：紫色方块表示任意门，8方向红色扫描线检测邻接点，命中时闪烁黄光  
4. **缩点过程**：相同颜色色块聚合为一个大色块，显示SCC大小数值  
5. **拓扑DP**：色块从入度0节点开始渐变色填充，动态显示dp值增长过程

**复古音效设计**：  
- 环连接完成：8-bit "叮"声  
- 发现邻接点：短促"哔"声  
- SCC聚合：合成器滑音  
- DP值更新：像素跳跃音

**交互控制**：  
```javascript
// 伪代码示例
const demo = new PixelDemo({
    speed: 3,      // 1-5档速度
    showGrid: true // 显示坐标网格
});
demo.addStep('build_row_cycle', {行号: 1});
demo.addStep('connect_virtual_node', {类型: 'row', 虚点ID: 1001});
demo.run();
```

---

## 核心代码片段
### 缩点后拓扑DP
```cpp
// Tarjan缩点略

// 重建DAG
unordered_map<pair<int,int>, bool> edge_map;
for(auto &e : original_edges){
    int u_scc = scc_id[e.u], v_scc = scc_id[e.v];
    if(u_scc != v_scc && !edge_map[{u_scc, v_scc}]){
        dag[u_scc].push_back(v_scc);
        in_degree[v_scc]++;
        edge_map[{u_scc, v_scc}] = true;
    }
}

// 拓扑排序+DP
queue<int> q;
vector<int> dp(scc_count + 1);
for(int i=1; i<=scc_count; i++){
    if(in_degree[i] == 0){
        q.push(i);
        dp[i] = scc_size[i];
    }
}

while(!q.empty()){
    int u = q.front(); q.pop();
    for(int v : dag[u]){
        dp[v] = max(dp[v], dp[u] + scc_size[v]);
        if(--in_degree[v] == 0) q.push(v);
    }
}
cout << *max_element(dp.begin(), dp.end());
```

---

## 个人心得摘录
> "横纵门若不优化直接建边，10⁵数据下必TLE。首次提交MLE才发现map直接访问不存在的键会自动创建条目，改为find判断后内存骤降" —— Sue_Shallow调试笔记  
> "将行和列抽象为虚节点后，代码量减少30%，但初始化时忘记处理虚节点与实际节点的连接，WA两次后通过画图理清关系" —— yingjz的踩坑记录

---
处理用时：84.79秒
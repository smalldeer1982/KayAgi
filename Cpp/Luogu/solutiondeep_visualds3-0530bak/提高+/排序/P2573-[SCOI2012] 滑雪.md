# 题目信息

# [SCOI2012] 滑雪

## 题目描述

a180285 非常喜欢滑雪。他来到一座雪山，这里分布着 $m$ 条供滑行的轨道和 $n$ 个轨道之间的交点（同时也是景点），而且每个景点都有一编号 $i\space (1 \le i \le n)$ 和一高度 $h_i$。  

a180285 能从景点 $i$ 滑到景点 $j$ 当且仅当存在一条 $i$ 和 $j$ 之间的边，且 $i$ 的高度**不小于** $j$。与其他滑雪爱好者不同，a180285 喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。

于是 a18028 5拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是 a180285 滑行的距离）。  

请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，a180285站在 $1$ 号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？


## 说明/提示

【数据范围】   
对于 $ 30\% $ 的数据，$ 1 \le n \le 2000 $；   
对于 $ 100\% $ 的数据，$ 1 \le n \le 10^5 $。


对于所有的数据，保证 $ 1 \le m \le 10^6 $ , $ 1 \le h_i \le 10^9 $ ，$ 1 \le k_i \le 10^9 $。


## 样例 #1

### 输入

```
3 3 
3 2 1 
1 2 1 
2 3 1 
1 3 10 ```

### 输出

```
3 2```

# AI分析结果



# 算法分类  
**最小生成树（Kruskal） + 广度优先搜索（BFS）**

---

# 综合分析与结论  
## 核心算法流程  
1. **可达点搜索**：通过 BFS/DFS 确定从起点 1 能到达的所有景点（仅允许从高到低的移动）  
2. **边筛选与排序**：将可达点之间的边按终点高度降序（第一关键字）和边权升序（第二关键字）排序  
3. **Kruskal 求最小生成树**：用并查集维护连通性，按排序后的边依次加入  

## 难点对比与解决方案  
- **可达性判定**：需建立仅允许从高到低的单向边（同高度建双向边）  
- **排序策略**：终点高度降序保证优先连接高海拔区域，边权升序保证同高度下最短边优先  
- **时间胶囊机制**：等价于构建树形结构，允许回溯但不影响边权总和  

## 可视化设计思路  
1. **像素动画**：  
   - 用不同颜色方块表示节点（绿色：已访问，灰色：未访问）  
   - 边连接时显示动态线条（红色：当前处理边，蓝色：已加入生成树）  
2. **高亮机制**：  
   - BFS 阶段：队列中的节点用黄色闪烁  
   - Kruskal 阶段：当前边显示红色边框，成功加入生成树的边变为蓝色  
3. **音效设计**：  
   - 节点访问："哔"音（8-bit 短音）  
   - 边加入生成树："叮"音（上扬音调）  
   - 边被跳过（成环）：低音"嘟"声  

---

# 题解清单（≥4星）  
1. **Khassar（⭐⭐⭐⭐⭐）**  
   - 亮点：BFS 构建新图 + 双关键字排序，代码结构清晰  
   - 关键代码：  
     ```cpp
     bool cmp1(it x,it y) { // 排序函数
         if(h[x.v]!=h[y.v]) return h[x.v]>h[y.v];
         return x.w<y.w;
     }
     ```

2. **mrsrz（⭐⭐⭐⭐）**  
   - 亮点：DFS 收集可用边 + 并查集优化  
   - 关键片段：  
     ```cpp
     void dfs(int now) { // DFS 收集边
         for(int i=head[now];i;i=e[i].nx)
             if(!vis[e[i].to]) dfs(e[i].to);
     }
     ```

3. **喵の耳（⭐⭐⭐⭐）**  
   - 亮点：简洁的并查集实现 + 明确的问题转化  
   - 代码亮点：  
     ```cpp
     bool cmp(Edge a,Edge b) { // 排序策略
         return h[a.v]==h[b.v] ? a.w<b.w : h[a.v]>h[b.v];
     }
     ```

---

# 最优思路提炼  
**双维度排序技巧**：  
- **高度优先**：确保优先连接高海拔区域以最大化景点数  
- **边权次优**：在相同高度下选择最短边保证总距离最小  

**实现模板**：  
```python
1. BFS/DFS 收集可达点
2. 筛选所有 u→v 边满足 h[u] >= h[v] 且 u,v 均可达
3. 按 (h[v]降序, w升序) 排序
4. Kruskal 跑最小生成树
```

---

# 同类题型推荐  
1. P1991 无线通讯网（最小生成树变种）  
2. P2872 道路建设（边权处理技巧）  
3. P4047 部落划分（生成树思想扩展）  

---

# 关键代码实现  
**Khassar 核心片段**：  
```cpp
void bfs(){ // BFS 构建新图
    q[++qr]=1;vis[1]=1;
    while(ql<qr) {
        int now=q[++ql];
        for(int i=head[now];i;i=b[i].nx) {
            a[++cnt].u=now; // 记录新边
            if(!vis[b[i].to]) q[++qr]=b[i].to;
        }
    }
}

sort(a+1,a+1+cnt,cmp1); // 关键排序
for(int i=1;i<=cnt;i++){ // Kruskal
    int rx=find(a[i].u), ry=find(a[i].v);
    if(rx!=ry) ans += a[i].w;
}
```

---

# 可视化演示方案  
**Canvas 动画伪代码**：  
```javascript
class Visualizer {
    constructor() {
        this.nodes = [] // 节点像素坐标
        this.edges = [] // 边数据
        this.currentEdge = 0 // 当前处理边索引
    }

    drawFrame() {
        // 绘制当前处理的边（红色边框）
        ctx.strokeStyle = '#FF0000'
        ctx.strokeRect(edge.startX, edge.startY, 10, 10)
        
        // 已加入生成树的边（蓝色）
        acceptedEdges.forEach(e => {
            ctx.drawLine(e.from, e.to, '#0000FF')
        })
        
        // 播放音效
        if(edgeAccepted) playSound('ding.wav')
    }
}
```

**复古风格参数**：  
- 调色板：16色（NES 经典配色）  
- 节点大小：8x8 像素方块  
- 音效：chiptune 风格 8-bit 音效  

---

**总结**：本题通过可达性搜索与特殊排序的最小生成树，实现了在满足最大景点数前提下的最短路径求解。其核心在于理解时间胶囊机制等价于树形结构的构建，并通过双关键字排序策略平衡景点数量与距离优化。

---
处理用时：65.44秒
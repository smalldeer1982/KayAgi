# 题目信息

# [USACO15OPEN] Trapped in the Haybales S

## 题目描述

FJ 收到了 $N$ 捆干草，并将它们放置在连接房屋与谷仓的道路上。第 $j$ 捆干草的大小为 $S_j$，位置为 $P_j$。Bessie 一开始在 $B$ 处，不与任何一捆干草的位置重合。

Bessie 可以在干草捆之间任意移动（也可以到达干草捆所在的位置），但不能越过干草捆。但凡事总有例外：当 Bessie 进行了长度为 $D$ 的冲刺后，她就可以击碎一捆大小严格小于 $D$ 的干草，这意味着这捆干草不复存在。

由于某些原因，FJ 希望把 Bessie 困在最左边与最右边的干草捆之间。为此，他希望将某一捆干草的大小增加一些。如果可能把 Bessie 困住，请输出他最少需要增加多少干草；否则输出 `-1`。

$1 \leqslant N \leqslant 10^5$，$1 \leqslant S_i, P_i, B \leqslant 10^9$。

## 样例 #1

### 输入

```
5 7
8 1
1 4
3 8
12 15
20 20```

### 输出

```
4```

# AI分析结果



**唯一算法分类**：双指针法（Two Pointers）

---

### **题解思路与核心难点**

**核心思路**：  
1. **排序定位**：将所有干草堆按位置排序，找到Bessie初始所在的区间 `[左端点, 右端点]`。
2. **双指针扩展**：从初始区间向左右扩展，枚举可能的加固点：
   - **左端点加固**：固定左端点 `l`，向右扩展右指针 `r`，计算所需加固值。
   - **右端点加固**：固定右端点 `r`，向左扩展左指针 `l`，计算所需加固值。
3. **最小加固值**：在扩展过程中维护最小加固值，若无法困住则输出 `-1`。

**解决难点**：  
- **指针移动条件**：需确保当前区间无法被Bessie突破，动态调整指针位置。
- **边界处理**：如初始区间的确定、指针越界时的终止条件。

---

### **题解评分 (≥4星)**

1. **Schwarzkopf_Henkal（4星）**  
   - **亮点**：双指针实现清晰，两次循环处理左右加固，代码简洁高效。  
   - **心得**：初始值需足够大（如 `1e18`）以避免溢出问题。

2. **灼眼的夏娜（4星）**  
   - **亮点**：通过双循环分别处理左右扩展，逻辑对称易于理解。  
   - **心得**：提前判断输出0的情况优化效率。

3. **legend_cn（4星）**  
   - **亮点**：代码注释详细，变量命名清晰，适合新手学习。  
   - **心得**：使用 `max(0ll)` 防止负值输出。

---

### **最优思路提炼**

1. **双指针单向扩展**：  
   - 左指针 `l` 向左移动时，右指针 `r` 仅单向扩展（无需回溯），确保时间复杂度为 `O(n)`。
   - 维护 `ans = min(ans, 区间长度 - 干草堆大小)`，避免重复计算。

2. **初始区间快速定位**：  
   - 使用 `upper_bound` 或遍历找到Bessie所在的初始区间，确保起点正确。

---

### **同类型题与算法套路**

- **类似题目**：区间覆盖、滑动窗口、最小子数组问题。
- **通用套路**：  
  1. 排序预处理，确定初始状态。  
  2. 双指针单向移动，动态维护极值。

---

### **推荐题目**

1. **P1886 滑动窗口**（双指针维护极值）  
2. **P2285 [HNOI2004] 打鼹鼠**（动态规划与区间覆盖）  
3. **P1090 [NOIP2004 提高组] 合并果子**（贪心选择最优解）

---

### **可视化与算法演示**

**动画设计**：  
1. **排序与初始区间**：  
   - 干草堆按位置排序后显示为有序点列，Bessie位置高亮。  
   - 初始区间用红色框标出左右端点。

2. **双指针移动**：  
   - 左指针 `l`（蓝色）向左移动，右指针 `r`（绿色）向右扩展，动态显示当前区间。  
   - 每次计算加固值时，显示公式 `d = p[r] - p[l]` 与所需加固值 `d - s`。

3. **音效与交互**：  
   - **音效**：指针移动时播放点击声，找到解时播放成功音效。  
   - **步进控制**：支持暂停/继续，调节动画速度观察细节。

**复古像素风格**：  
- **Canvas 绘制**：干草堆为黄色像素块，Bessie为粉色像素，指针用箭头标记。  
- **背景音乐**：8-bit风格循环音轨，增强沉浸感。

---

### **核心代码片段**

```cpp
// 排序并找到初始区间
sort(gra + 1, gra + n + 1, cmp);
int st = lower_bound(gra + 1, gra + n + 1, b, cmp) - gra;

// 处理左端点加固
int l = st, r = st + 1;
for (; l >= 1; l--) {
    while (r <= n && gra[r].p - gra[l].p <= gra[r].s) r++;
    if (r > n) break;
    ans = min(ans, gra[r].p - gra[l].p - gra[l].s);
}

// 处理右端点加固
l = st, r = st + 1;
for (; r <= n; r++) {
    while (l >= 1 && gra[r].p - gra[l].p <= gra[l].s) l--;
    if (l < 1) break;
    ans = min(ans, gra[r].p - gra[l].p - gra[r].s);
}

// 输出结果
cout << (ans == INF ? -1 : max(ans, 0));
```

---

### **总结**

通过双指针单向扩展，结合排序预处理，高效求解最小加固值。关键点在于正确维护指针移动条件和边界处理，代码实现需注意初始值的合理设置与负数输出的过滤。

---
处理用时：92.05秒
# 题目信息

# [APIO2009] 会议中心

## 题目描述

Siruseri 政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很 感兴趣，他们希望能够在里面举行会议。

对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。 会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。

显 然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有 4 个公司。他们对租借会堂发出了请求，并提出了 他们所需占用会堂的起止日期（如下表所示）。

```cpp
       开始日期 结束日期 
 公司1    4        9 
 公司2    9        11 
 公司3    13       19 
 公司4    10       17 
```
上例中，最多将会堂租借给两家公司。租借策略分别是租给公司 1 和公司 3， 或是公司 2 和公司 3，也可以是公司 1 和公司 4。注意会议中心一天最多租借给 一个公司，所以公司 1 和公司 2 不能同时租借会议中心，因为他们在第九天重合 了。

销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首 先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出 其中字典序最小1的候选策略作为最终的策略。

例中，会堂最终将被租借给公司 1 和公司 3：3 个候选策略是 {(1,3),(2,3),(1,4)}。而在字典序中(1,3)<(1,4)<(2,3)。 你的任务是帮助销售主管确定应该将会堂租借给哪些公司。


## 说明/提示

对于 50%的输入，N≤3000。

在所有输入中，N≤200000。


## 样例 #1

### 输入

```
4 
4 9
9 11 
13 19 
10 17```

### 输出

```
2
1 3```

# AI分析结果



**唯一算法分类**  
贪心+倍增+数据结构  

---

### 题解思路与核心难点  
**核心思路**  
1. **最大不相交区间数**：  
   - 预处理每个区间的最优后继（右端点最小的区间），构建倍增数组快速查询区间内最多可放线段数  
   - 贪心策略：按右端点排序后，每次选择右端点最小的不相交区间  

2. **字典序最小选择**：  
   - 按编号顺序尝试加入每个区间  
   - 用 `set` 维护已选区间的端点，快速查找前驱和后继  
   - 判断加入当前区间后是否满足：  
     $$f(L_{pre}+1, l_i-1) + f(r_i+1, R_{suc}-1) + 1 = f(L_{pre}+1, R_{suc}-1)$$  

**解决难点**  
- **快速查询区间最大线段数**：通过倍增预处理，将查询复杂度优化至 $O(\log n)$  
- **动态维护已选区间**：利用 `set` 的 `upper_bound` 快速定位前驱后继  
- **字典序比较**：通过强制按编号顺序尝试，保证首次合法选择即为最小字典序  

---

### 题解评分  
1. **jjsnam (5星)**  
   - 思路清晰，详细解释倍增预处理和 `set` 维护逻辑  
   - 代码结构规范，离散化与哨兵处理完善  
   - 个人心得突出调试经验，增强可读性  

2. **GoldenPotato137 (4星)**  
   - 核心思路与 jjsnam 一致，代码简洁  
   - 缺乏详细注释，但关键步骤（倍增与 `set` 操作）实现正确  

3. **喵仔牛奶 (4星)**  
   - 提供完整预处理和倍增查询实现  
   - 代码包含离散化与边界处理，但缺少对哨兵的解释  

---

### 最优思路与代码实现  
**关键代码片段**  
```cpp
// 倍增预处理
for (int i = n; i > 0; --i) {
    if (Mn[seg[i].l] > seg[i].r) {
        Mn[seg[i].l] = seg[i].r, pos[seg[i].l] = seg[i].id;
    }
}
for (int i = cnt; i > 0; --i) {
    if (Mn[i] > Mn[i+1]) {
        Mn[i] = Mn[i+1], pos[i] = pos[i+1];
    }
}

// 查询区间最大线段数
int getMx(int st, int r) {
    int res = 0;
    for (int k = Log2; k >= 0; --k) {
        if (seg[ne[st][k]].r <= r) {
            res += (1 << k), st = ne[st][k];
        }
    }
    return res;
}

// 字典序判断逻辑
if (getMx(R.id, seg[i].l-1) + getMx(i, L.v-1) + 1 != getMx(R.id, L.v-1)) continue;
```

---

### 同类题目推荐  
1. **P1803 线段覆盖** - 基础最大不相交区间数  
2. **P2170 选学霸** - 字典序最小选择优化  
3. **P2899 Cell Phone Network** - 贪心+数据结构维护  

---

### 可视化设计  
**动画方案**  
1. **预处理阶段**：  
   - 以时间轴展示区间排序和倍增数组构建过程  
   - 高亮每个区间的后继跳跃路径（红色箭头指示）  

2. **选择阶段**：  
   - 用绿色方块表示已选区间，蓝色方块表示当前检测区间  
   - 显示 `set` 中前驱（黄色）和后继（紫色）区间  
   - 动态计算并显示三个子区间的最大线段数  

**复古像素风格**  
- **Canvas 绘制**：  
  - 区间用不同颜色块表示，关键操作用 8-bit 音效提示  
  - 倍增跳跃时播放 "blip" 音效，选中区间时播放 "coin" 音效  

**AI 自动演示**  
- 自动按编号顺序尝试插入区间，失败时显示红色闪烁，成功时显示绿色边框  

---

### 总结  
本题通过贪心与倍增预处理高效解决最大覆盖问题，结合 `set` 动态维护区间实现字典序优化。核心在于快速区间查询与动态插入验证，可视化设计可有效展示倍增跳跃和集合操作的关键步骤。

---
处理用时：63.74秒
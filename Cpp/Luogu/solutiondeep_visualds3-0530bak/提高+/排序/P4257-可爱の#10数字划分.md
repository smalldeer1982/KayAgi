# 题目信息

# 可爱の#10数字划分

## 题目背景

可可可可可可爱的付公主 qwq 有 $n$ 个数，$1\sim n$，每个数都有价值 $V_i$，你要将它们划分成若干个集合，每个数属于一个集合。

## 题目描述

我们这里规定:

1. 质数只能和质数分在同一个集合。  
2. 合数只能和合数分在同一个集合（$1$ 也算在合数内）。   
3. 我们假设目前所有质数集合的并集为 $U$（也就是之前所有质数集合以及 $S$ 的并集），每个质数集合 $S$ 的价值定义如下：  
$$V_S=\frac {(\sum_{i\in S}V_i)^p} {\prod_{i\in U}V_i}$$

4. 我们定义每个合数集合 $S$ 的价值如下:

令 $k=|S|$，我们用这 $k$ 个数分别作为 $k$ 条边的权值，连接 $k+1$ 个点，构成一棵树。对于一个排列 $P(1\sim k+1)$，价值为：

$$V_P=\sum_{i=1}^{n-1} f(P_i,P_{i+1})$$

其中 $f(u,v)$ 为路径 $(u,v)$ 上最大的边权。

集合 $S$ 的价值为：

$$V_S=E(\min\{V_P\})\times|S|$$

其中 $E(X)$ 代表 $X$ 的数学期望，期望是针对所有可能的有标号无根树，$\min$ 是针对所有可能的 $P$。这时集合内所有元素都不同，也就是所有边不同。

5. 一个划分方案的价值定义为所有集合的价值的乘积。
6. 两个划分方案相同当且仅当它们中所有集合对应相同，且质数集合的相对顺序相同。

现在给定 $n,p$ 和 $V_i$，请你求出所有合法的不同划分方案的价值之和。

结果对 $10^9+7$ 取模，除法请使用乘法逆元。

## 说明/提示

### 样例解释

有以下 $6$ 种划分方案:

1. $(2,3)$ 和 $(1,4)$。$(2,3)$ 的价值为 ${\dfrac 5 6}$，$(1,4)$ 的价值为 $10$，总价值为 ${\dfrac {25} 3}$。
2. $(2),(3)$ 和 $(1,4)$。$(2)$ 的价值为 $1$，$(3)$ 的价值为 ${\dfrac 1 2}$，$(1,4)$ 的价值为 $10$，总价值为 $5$。
3. $(3),(2)$ 和 $(1,4)$。$(3)$ 的价值为 $1$，$(2)$ 的价值为 ${\dfrac 1 3}$，$(1,4)$ 的价值为 $10$，总价值为 ${\dfrac {10} 3}$。
4. $(2,3)$ 和 $(1),(4)$。$(2,3)$ 的价值为 ${\dfrac 5 6}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 ${\dfrac {10} 3}$。
5. $(2),(3)$ 和 $(1),(4)$。$(2)$ 的价值为 $1$，$(3)$ 的价值为 ${\dfrac 1 2}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 $2$。
6. $(3),(2)$ 和 $(1),(4)$。$(3)$ 的价值为 $1$，$(2)$ 的价值为 ${\dfrac 1 3}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 ${\dfrac 4 3}$。

因此所有划分方案的价值和为${\dfrac {70} 3}$。对 $10^9+7$ 取模后结果为 $333333359$。

### 数据范围

对于 $100\%$ 的数据，满足 $1\le n\le 70$，$1\le V_i\le 10^{12}$。

下表中给出了每个测试点具体的数据范围，都表示小于等于。为了防止卡 OJ，所以本题数据组数进行压缩，分值改变，具体参照表格。

| 数据编号 |  n   |  p   |  Vi   | 测试点分值 | 时限 |
| :------: | :--: | :--: | :---: | :--------: | :--: |
|    1     |  10  |  1   |  100  |     10     |  1s  |
|    2     |  20  |  1   | 1000  |     10     |  1s  |
|    3     |  30  |  1   | 10000 |     10     |  1s  |
|    4     |  40  | 1e9  | 1e12  |     10     |  1s  |
|    5     |  50  |  1   | 1e12  |     5      |  1s  |
|    6     |  50  | 1e9  | 1e12  |     5      |  1s  |
|    7     |  60  |  1   | 1e12  |     5      |  2s  |
|    8     |  60  | 1e9  | 1e12  |     5      |  2s  |
|    9     |  70  | 1e9  | 1e12  |     20     |  10s  |
|    10    |  70  | 1e9  | 1e12  |     20     |  5s  |

提示：大家不要太过相信自己的常数，尽量做好常数优化。

## 样例 #1

### 输入

```
4 1
1 2 3 4
```

### 输出

```
333333359```

# AI分析结果



---

**算法分类**: 动态规划、子集卷积、数学期望

---

### **题解思路与解决难点**

1. **问题拆分**  
   质数与合数的处理完全独立，可分别计算贡献后相乘。这是解题的核心前提。

2. **质数集合处理**  
   - **动态规划优化**：直接枚举子集复杂度为 $O(3^n)$，不可行。使用**子集卷积**或**快速莫比乌斯变换（FMT）**将复杂度优化至 $O(2^n n^2)$。
   - **公式推导**：每个质数集合的贡献为 $(\sum V_i)^p / \prod V_i$，需将所有可能的划分方式求和。通过动态规划维护子集贡献的乘积和。

3. **合数集合处理**  
   - **关键结论**：通过分析排列的最小期望，得出集合价值等于边权和乘以集合大小。证明思路为每条边作为最大边时仅被计算一次，期望贡献为边权。
   - **动态规划分组**：将合数分组后，转化为分组背包问题，状态转移时维护不同分组的贡献。

---

### **题解评分**

- **官方题解 (⭐⭐⭐⭐)**  
  提供了分治思路和优化方向，但缺乏对结论的详细证明。代码实现需依赖子集卷积或 FMT 的高效实现，对数学推导要求较高。

---

### **最优思路与技巧提炼**

1. **质数部分优化**  
   - **子集卷积/FMT**：将子集枚举转化为多项式乘法，利用位运算加速。  
   - **预处理逆元**：分母 $\prod V_i$ 的逆元可预先计算，避免重复求模逆。

2. **合数部分简化**  
   - **边权和结论**：通过分析排列路径的最大边权，推导出边权和的数学期望，将复杂问题转化为简单求和。

---

### **同类型题与算法套路**

- **子集动态规划优化**：如「子集和计数问题」，常用 FMT/FWT 加速。  
- **生成树与期望**：如「最小生成树边权和期望」，需结合图论与概率分析。

---

### **推荐洛谷题目**

1. **P6775 [NOI2020] 制作菜品**  
   子集划分与动态规划的结合，需处理类似的分组贡献。

2. **P4200 [JSOI2008]Blue Mary的旅行**  
   图论与动态规划的结合，涉及路径贡献的复杂计算。

3. **P5495 Dirichlet 前缀和**  
   子集卷积与高维前缀和的经典应用，适合练习 FMT/FWT 技巧。

---

### **可视化与算法演示**

**核心算法流程**：  
1. **质数部分**  
   - **动态规划状态更新**：以二进制位表示子集，逐步合并子集贡献。  
   - **FMT 优化**：通过位分治逐维合并子集，用颜色区分不同维度的合并过程。

2. **合数部分**  
   - **分组背包动态规划**：用动画展示合数逐个加入不同分组的过程，高亮当前处理的数和新生成的贡献。

**复古像素化设计**：  
- **颜色方案**：质数用蓝色（子集位运算）、合数用绿色（分组背包）。  
- **音效触发**：每次子集合并时播放“合成音效”，分组更新时播放“确认音效”。  
- **Canvas 绘制**：用网格表示子集状态，动态填充像素块以显示贡献值的变化。

---

### **代码实现片段**

**质数部分 FMT 优化**（伪代码）：
```cpp
void FMT(vector<int>& dp) {
    for (int i = 0; i < n; ++i)
        for (int S = 0; S < (1<<n); ++S)
            if (S & (1<<i))
                dp[S] = add(dp[S], mul(dp[S^(1<<i)], val[i]));
}
```

**合数部分动态规划**（伪代码）：
```cpp
dp[0] = 1;
for (int i = 0; i < m; ++i) { // 合数列表
    for (int j = i; j >= 0; --j) {
        dp[j+1] = add(dp[j+1], mul(dp[j], sum_edges(j+1)));
    }
}
```

---

**总结**：本题通过巧妙的数学结论和动态规划优化，将复杂问题分解为可处理的子问题。质数部分的子集卷积与合数部分的期望简化是解题的关键突破点。

---
处理用时：92.44秒
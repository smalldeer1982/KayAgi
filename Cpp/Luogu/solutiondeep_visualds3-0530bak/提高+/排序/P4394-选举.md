# 题目信息

# 选举

## 题目描述

Byteland 国的居民最近一直为议会选举投票。现在，当结果公布的时候，党派不得不决定联合组建政府。 

每个党派都会获得议会中的一定席位。联合政府由这些党派中的一部分组成，他们在议会中的席位数之和**严格大于**总席位数的一半。对于联合政府来说，席位越多越好。

一个**过剩**的联合政府是指联合政府中的一个党派被移出后，剩余的联合政府在国会中仍有过半数的席位。

请写一个程序能够找到一个在议会中有着**最大可能席位数**且**不过剩**的联合政府。

## 说明/提示

样例解释：选择第二个政党和第四个。

对于全部数据，$1\le n\le 300$。

## 样例 #1

### 输入

```
4
1 3 2 4```

### 输出

```
7```

# AI分析结果



---

## 算法分类  
**动态规划（01背包）**

---

## 综合分析与结论  

### 核心思路  
题目要求选择一个席位数尽可能多的党派集合，满足总和严格过半，且移除任一成员后剩余总和不过半。通过以下步骤解决：  
1. **排序优化**：将党派从大到小排序，保证每次处理的是当前剩余的最小可能成员。  
2. **01背包动态规划**：记录可组成的席位数集合。  
3. **条件判断**：在背包转移过程中，检查当前组合是否满足总席位数过半且移除最小成员后不过半。  

### 难点解析  
- **如何保证移除任一成员后不过半**：通过排序，确保当前处理的成员是已选集合中的最小值。若当前总和为 `S`，则 `S - a[i] ≤ sum/2` 时，移除该最小值即可满足不过半条件。  
- **动态规划状态设计**：多数题解使用布尔型数组 `dp[j]` 表示能否组成席位数 `j`，结合排序后的逆序处理，确保正确性。  

### 可视化设计思路  
1. **动画流程**：  
   - **排序阶段**：显示党派按从大到小排列的动态过程。  
   - **背包转移**：高亮当前处理的党派 `a[i]`，并逐步更新背包数组 `dp` 的状态。  
   - **条件检查**：当 `j > sum/2` 时，突出显示当前 `j` 是否满足 `j - a[i] ≤ sum/2`。  
2. **交互设计**：  
   - **速度控制**：允许调节背包转移速度，观察每一步的更新细节。  
   - **颜色标记**：用不同颜色区分已选集合、当前处理党派、满足条件的候选解。  
3. **复古像素风格**：  
   - **8位像素网格**：将党派表示为不同大小的像素块，背包数组显示为进度条。  
   - **音效提示**：在满足条件时播放“成功”音效，转移时播放轻微点击音效。  

---

## 题解清单（≥4星）  

### 1. PBCWZCC（⭐⭐⭐⭐⭐）  
**亮点**：代码简洁，明确使用排序+背包，通过逆序处理确保最小成员条件。关键注释清晰。  
**核心代码**：  
```cpp
sort(p+1,p+1+n);
for(int i(n);i>=1;--i) {
    for(int j(summ);j>=0;--j) {
        if(j-p[i]>=0) f[j] = max_(f[j], f[j-p[i]]+p[i]);
        if(f[j]>mid && f[j]-p[i]<=mid) maxx = max_(maxx,f[j]);
    }
}
```

### 2. vectorwyx（⭐⭐⭐⭐⭐）  
**亮点**：数学推导充分，状态定义明确，使用滚动数组优化空间。  
**核心代码**：  
```cpp
sort(a+1,a+1+n,cmp);
dp[0] = 1;
for(int i=1; i<=n; i++) {
    for(int j=sum[i]; j>=a[i]; j--) {
        if(j-sum[n]/2 <=a[i] && dp[j-a[i]]) dp[j] = 1;
    }
}
```

### 3. MikukuOvO（⭐⭐⭐⭐）  
**亮点**：创新状态设计，记录每个席位数的最小成员，最后统一判断。  
**核心代码**：  
```cpp
memset(f,-1,sizeof(f));
f[0] = 1e9;
for(int i=1; i<=n; ++i) {
    for(int j=sum; j>=0; --j) {
        if(f[j] != -1) f[j+c[i]] = max(f[j+c[i]], min(f[j], c[i]));
    }
}
```

---

## 最优思路提炼  
1. **排序降序**：确保每次处理的成员是当前可能的最小值。  
2. **背包条件转移**：在更新背包时，检查 `j > sum/2` 且 `j - a[i] ≤ sum/2`。  
3. **滚动数组优化**：使用一维数组逆序更新，节省空间。  

---

## 类似题目  
1. **[P1048 采药](https://www.luogu.com.cn/problem/P1048)**：01背包模板题。  
2. **[P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)**：带有依赖关系的背包问题。  
3. **[P2214 多重背包问题](https://www.luogu.com.cn/problem/P2214)**：背包问题的扩展变种。  

---

## 个人心得摘录  
- **PBCWZCC**：强调排序对保证最小成员的关键作用，避免复杂判断。  
- **vectorwyx**：通过数学变形将问题转化为背包条件，提升代码可读性。  
- **MikukuOvO**：状态设计的创新点，避免频繁条件检查，优化时间复杂度。  

---

## 核心代码实现  
以 **PBCWZCC 的代码**为例：  
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n, p[301], mid, f[100001], maxx, summ;

int main() {
    scanf("%d", &n);
    for(int i=1; i<=n; ++i) scanf("%d", &p[i]), summ += p[i];
    mid = summ >> 1;
    sort(p+1, p+1+n); // 从大到小排序
    for(int i=n; i>=1; --i) { // 逆序处理每个党派
        for(int j=summ; j>=p[i]; --j) {
            if(f[j - p[i]] + p[i] > f[j]) {
                f[j] = f[j - p[i]] + p[i];
                if(f[j] > mid && f[j] - p[i] <= mid) maxx = max(maxx, f[j]);
            }
        }
    }
    printf("%d", maxx);
    return 0;
}
```

---

## 可视化方案（复古像素风格）  
### 实现要点  
1. **Canvas 绘制**：  
   - 每个党派显示为不同颜色的方块，大小代表席位数。  
   - 背包数组 `dp` 显示为横向进度条，绿色表示可达的席位数。  
2. **动画流程**：  
   - 排序阶段：方块从左到右按大小重新排列。  
   - 背包更新：当前处理的方块闪烁，对应的 `dp` 进度条逐步填充。  
3. **音效设计**：  
   - **转移成功**：8-bit 上升音效。  
   - **条件满足**：清脆的“金币”音效。  
4. **自动演示模式**：  
   - 按帧逐步执行排序和背包转移，用户可暂停/继续观察。  

**示例代码片段（JS）**：  
```javascript
// 绘制背包状态
function drawDP() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let j = 0; j <= sum; j++) {
        if (dp[j]) ctx.fillStyle = '#00FF00'; // 可达席位数
        else ctx.fillStyle = '#444444';
        ctx.fillRect(j * 2, 50, 2, 20);
    }
}
// 播放音效
function playSound(effect) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = effect === 'success' ? 880 : 440;
    osc.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
}
```

---
处理用时：105.48秒
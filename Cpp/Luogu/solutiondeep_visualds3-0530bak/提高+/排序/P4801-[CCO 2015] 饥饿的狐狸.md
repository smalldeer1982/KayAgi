# 题目信息

# [CCO 2015] 饥饿的狐狸

## 题目描述

**本题译自 [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2015/index.html) Day1 T1「[Hungry Fox](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2015/stage%202/day1.pdf)」**

到你的宠物狐狸的晚餐时间啦！他的晚餐包含 $N$ 块饼干，第 $i$ 块饼干的温度是 $T_i$ 摄氏度。同时，在晚餐中还包含了一大盘 $W$ 摄氏度的水。

在喝了一口水之后，你的狐狸开始吃饭了。每当他吃一块饼干时，这块饼干的美味度为当前饼干与吃/喝的前一样食物（包括饼干和水）的温度的差的绝对值。它可以在任意时间喝水（保证水喝不完），或按任意顺序吃饼干。

最后狐狸获得的美味值为它吃下的每块饼干的美味度之和。请求出狐狸获得的最小和最大的美味值。

## 说明/提示

要得到最小美味值，一种可行的方案是，狐狸先喝水，然后吃第一块饼干，再吃第三块饼干，接着喝水，最后吃下第二块饼干，这样做，它所感受到的温度分别为 $20,18,18,20,25$ 摄氏度，总的美味度为 $2+0+5=7$。

要得到最大美味值，一种可行的方案是，狐狸先喝水，然后按顺序吃饼干，它所感受到的温度分别为 $20,18,25,18$ 摄氏度，总的美味度为 $2+7+7=16$。

对于 $30\%$ 及以上的数据， $W=0$；  

对于 $100\%$ 的数据， $1\le N \le 100000, 0\le W \le 10^9, 0 \le T _ i \le 10 ^ 9$。

## 样例 #1

### 输入

```
3 20
18
25
18```

### 输出

```
7 16```

# AI分析结果



## 唯一算法分类
贪心

---

## 综合分析与结论
### 核心思路
**最小值**：将饼干排序后，总美味值为 `max(0, W-T₁) + max(0, Tₙ-W)`，分三种情况：  
- W在饼干温度范围外时，总差为两端的单边延伸  
- W在温度范围内时，总差为两端跨度  

**最大值**：双指针交替取左右端点饼干，每次贪心选择当前能获得最大温差（直接吃或喝水重置），分两种起点方向取最大值。

### 可视化设计
- **Canvas 绘制**：排序后的饼干以温度值横向排列，左右指针高亮  
- **动态交互**：步进展示指针移动，每次选择时显示两种温差比较  
- **像素风格**：饼干用色块表示，选择时触发8-bit音效  
- **控制面板**：支持暂停/步进/速度调节，自动演示模式模拟贪心决策流程  

---

## 题解清单（评分≥4星）
### 1. 桃夭（⭐⭐⭐⭐⭐）  
**亮点**：  
- 最小值的O(1)公式推导清晰  
- 最大值双指针交替策略实现简洁  
- 包含详细调试心路历程  

### 2. greykid（⭐⭐⭐⭐）  
**亮点**：  
- 数学归纳最小值公式的正确性  
- 对称处理两种贪心方向  

### 3. MoonCake2011（⭐⭐⭐⭐）  
**亮点**：  
- 代码高度简洁，直接体现核心逻辑  
- 明确注释关键步骤的贪心意图  

---

## 最优思路与代码实现
### 最小值公式
```cpp
long long GetMin() {
    return max(0ll, w - a[1]) + max(0ll, a[n] - w);
}
```

### 最大值双指针贪心
```cpp
long long GetMax(int check) {
    int l = 1, r = n;
    long long MAX = 0, now = w;
    for (int i = 1; i <= n; ++i) {
        if (i % 2 == check) {  // 交替方向
            MAX += max(abs(a[l] - now), abs(a[l] - w));
            now = a[l++];
        } else {
            MAX += max(abs(a[r] - now), abs(a[r] - w));
            now = a[r--];
        }
    }
    return MAX;
}
```

### 完整代码（桃夭题解）
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
long long w, a[1000010];

long long GetMin() {
    return max((long long)0, w - a[1]) + max((long long)0, a[n] - w);
}

long long GetMax(int check) {
    int l = 1, r = n;
    long long MAX = 0, now = w;
    for (int i = 1; i <= n; ++i) {
        if (i % 2 == check) {
            MAX += max(abs(a[l] - now), abs(a[l] - w));
            now = a[l++];
        } else {
            MAX += max(abs(a[r] - now), abs(a[r] - w));
            now = a[r--];
        }
    }
    return MAX;
}

int main() {
    scanf("%d%lld", &n, &w);
    for (int i = 1; i <= n; ++i) scanf("%lld", &a[i]);
    sort(a + 1, a + n + 1);
    printf("%lld %lld", GetMin(), max(GetMax(0), GetMax(1)));
    return 0;
}
```

---

## 相似题目推荐
1. **P1090 合并果子** - 贪心选择最小堆  
2. **P1223 排队接水** - 时间序列贪心排序  
3. **P2870 最佳牛线** - 双指针贪心构造字典序  

---

## 个人心得摘录
> "最初以为纯贪心，漏看喝水规则导致WA，调试中发现必须重置温差。最终O(1)公式的顿悟来自数轴覆盖区间的几何观察" —— 桃夭题解中的调试经验突显审题重要性

---

## 可视化与算法演示
### 动画方案
1. **初始状态**：排序后的饼干列，高亮W位置  
2. **最小值演示**：  
   - W在左侧：红色箭头从W延伸到最右饼干  
   - W在中间：绿色区间覆盖整个饼干范围  
3. **最大值演示**：  
   - 双指针交替移动，每次选择时显示max(直接差, 喝水差)  
   - 选择路径用不同颜色线段连接，播放对应音效  

### 复古像素实现
```javascript
// 伪代码：Canvas绘制核心逻辑
function drawCookies(ctx, cookies, w, l, r) {
    ctx.fillStyle = '#8B0000'; // 水深红色
    ctx.fillRect(wPos, 0, 2, 20);
    cookies.forEach((t, i) => {
        ctx.fillStyle = i < l || i > r ? '#808080' : '#FFD700'; // 灰色已选，金色未选
        ctx.fillRect(tPos, 10, 4, 30);
    });
}
// 音效：选择时播放
function playSound(type) {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(type === 'left' ? 440 : 880, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(0.1);
}
```

---
处理用时：108.70秒
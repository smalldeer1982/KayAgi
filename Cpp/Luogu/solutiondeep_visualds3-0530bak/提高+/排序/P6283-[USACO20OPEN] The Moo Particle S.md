# 题目信息

# [USACO20OPEN] The Moo Particle S

## 题目描述

FJ 的奶牛们最近很无聊，她们想到了一种全新的方式缓解无聊：研究高等物理！事实上，她们甚至成功发现了一种新的亚原子粒子，她们将其命名为“哞粒子”。

奶牛们正在进行一项有关 $N$ 个哞粒子的实验（$1\le N\le 10^5$）。粒子 $i$ 的“自旋”可以用范围在 $−10^9\ldots 10^9$ 之间的两个整数 $x_i$ 和 $y_i$ 来描述。有时两个哞粒子会发生相互作用。自旋为 ($x_i,y_i$) 和 ($x_j,y_j$) 的两个粒子之间仅当 $x_i\le x_j$ 并且 $y_i\le y_j$ 时会发生相互作用。在这些条件下，有可能这两个粒子中的一个会消失（另一个粒子不会发生任何变化）。在任意给定的时刻，至多只有一次相互作用会发生。

奶牛们想要知道在经过一些任意的相互作用之后剩余的哞粒子的最小数量。

## 说明/提示

### 样例输入输出 1 解释

一个可能的相互作用顺序：

- 粒子 $1$ 和 $4$ 相互作用，粒子 $1$ 消失。
- 粒子 $2$ 和 $4$ 相互作用，粒子 $4$ 消失。
- 粒子 $2$ 和 $3$ 相互作用，粒子 $3$ 消失。
仅留下粒子 $2$。

### 样例输入输出 2 解释

粒子 $3$ 不能与任何其他两个粒子相互作用，所以它必然会留下。粒子 $1$ 和 $2$ 中必然留下至少一个。

### 子任务
- 测试点 $3$-$6$ 满足 $N\le 10^3$。
- 测试点 $7$-$12$ 没有额外限制。

## 样例 #1

### 输入

```
4
1 0
0 1
-1 0
0 -1```

### 输出

```
1```

## 样例 #2

### 输入

```
3
0 0
1 1
-1 3```

### 输出

```
2```

# AI分析结果



## 算法分类
**排序 + 前后缀处理**

---

## 题解思路与解决难点
### 核心思路
1. **问题转化**：将粒子间的相互作用视为连通块划分问题，每个连通块最终可缩减至1个粒子。
2. **排序策略**：按 `x` 升序排序，若 `x` 相同则按 `y` 升序排序。
3. **连通块判定**：对于排序后的粒子，若前 `i` 个粒子的最小 `y` 值 `minl[i]` > 后 `i+1` 粒子的最大 `y` 值 `maxr[i+1]`，则分割为新连通块。
4. **前后缀处理**：预处理 `minl` 数组（前 `i` 项最小 `y`）和 `maxr` 数组（后 `i` 项最大 `y`）。

### 解决难点
- **连通块的高效判定**：通过排序与前后缀数组，将二维比较降为一维，避免 O(n²) 的暴力判断。
- **正确性证明**：排序后 `x` 有序，只需关注 `y` 的覆盖范围，若前段最小 `y` 无法覆盖后段最大 `y`，则无法连通。

---

## 题解评分（≥4星）
### 1. wylt（★★★★☆）
- **亮点**：思路清晰，代码简洁，直接使用排序与前后缀处理，时间复杂度 O(n log n)。
- **关键代码**：
  ```cpp
  sort(cid,cid+N,cmp);
  for(int i=0;i<N-1;i++)
      if(minl[i] > maxr[i+1])
          ans++;
  ```

### 2. 信守天下（★★★★☆）
- **亮点**：采用单调栈维护连通块的最小 `y`，代码更短，逻辑直观。
- **关键代码**：
  ```cpp
  for(int i=1; i<=n; i++) {
      if(e[i].y < s[t]) s[++t] = e[i].y;
      else {
          while(t>1 && e[i].y >= s[t-1]) t--;
      }
  }
  ```

### 3. xixiup（★★★★☆）
- **亮点**：详细推导错误思路到正确解法的过程，最终实现与 `wylt` 类似，具有教学意义。

---

## 最优思路提炼
1. **排序预处理**：按 `x` 排序后，将二维问题转化为一维 `y` 的处理。
2. **前后缀极值**：计算 `minl` 和 `maxr` 数组，快速判断连通块分界。
3. **单调性利用**：维护单调栈或前后缀数组，确保每个连通块的最小 `y` 不被后续覆盖。

---

## 类似题目推荐
1. [P3149 排序](https://www.luogu.com.cn/problem/P3149)（二维偏序）
2. [P1904 天际线](https://www.luogu.com.cn/problem/P1904)（极值覆盖问题）
3. [CF977D 分段排序](https://codeforces.com/problemset/problem/977/D)（排序与分组）

---

## 可视化与算法演示
### 动画设计
1. **坐标系绘制**：在 Canvas 中绘制粒子，按 `x` 排序后从左到右排列。
2. **颜色标记**：
   - 当前粒子：高亮显示。
   - `minl` 和 `maxr`：用不同颜色线段标记。
3. **连通块分割**：当 `minl[i] > maxr[i+1]` 时，绘制垂直分割线，右侧为新连通块。
4. **复古像素风格**：
   - 粒子显示为 8x8 像素方块，背景为深蓝色网格。
   - 音效：每次分割时播放“哔”声，背景音乐为 8-bit 循环旋律。

### 交互控制
- **步进控制**：空格键单步执行，Enter 键自动播放。
- **速度调节**：滑动条调整动画速度（100ms~2s）。
- **AI 模式**：自动完成所有步骤，高亮关键比较步骤。

---

## 关键代码实现
### 核心逻辑（wylt 解法）
```cpp
sort(cid, cid+N, [](int a, int b) {
    return (x[a] == x[b]) ? y[a] < y[b] : x[a] < x[b];
});
minl[0] = y[cid[0]];
for (int i=1; i<N; i++) 
    minl[i] = min(minl[i-1], y[cid[i]]);
maxr[N-1] = y[cid[N-1]];
for (int i=N-2; i>=0; i--)
    maxr[i] = max(maxr[i+1], y[cid[i]]);
int ans = 1;
for (int i=0; i<N-1; i++)
    ans += (minl[i] > maxr[i+1]);
```

### 复古动画片段（伪代码）
```javascript
// 绘制粒子
function drawParticles() {
    ctx.fillStyle = "#00FF00"; // 8-bit 绿色
    particles.forEach(p => {
        ctx.fillRect(p.x * scaleX, p.y * scaleY, 8, 8);
    });
}
// 播放分割音效
function playSplitSound() {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = 880; // A5 音符
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

---
处理用时：74.38秒
# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果



# 唯一算法分类  
动态规划（DAG 上的状态转移）

---

## 综合分析与结论  
### 核心思路  
1. **数论转化**：将边权分解质因数，指数对 k 取模后得到特征值，确定唯一配对数  
2. **状态定义**：`f[u][s]` 表示到达节点 u 时，最后一条边特征值为 s 的最大路径长度  
3. **转移方式**：拓扑排序过程中，用当前边的特征值查询配对特征值对应的历史状态进行转移  

### 可视化设计要点  
1. **DAG 展示**：用节点气泡表示拓扑顺序，边权显示特征值及配对数（如 2→(18,6²)）  
2. **状态高亮**：  
   - 红色闪烁：当前处理的边  
   - 绿色标记：可转移的配对特征值状态  
   - 金色边框：当前最优路径  
3. **动态过程**：  
   - 实时显示 `f` 数组的更新数值  
   - 质因数分解过程以指数粒子动画呈现  

---

## 题解清单（4星及以上）  
### 1. 一扶苏一（5星）  
**亮点**：  
- 双模数哈希避免碰撞  
- 预处理质数加速分解  
- 拓扑排序与状态转移分离，结构清晰  
**核心代码**：  
```cpp  
unordered_map<int, int> f[maxn];
void transfer(int u, Edge e) {
    int hash_val = get_hash(e.w);
    int pair_hash = get_pair_hash(e.w);
    f[e.v][hash_val] = max(f[e.v][hash_val], f[u][pair_hash] + e.l);
}
```

### 2. BFqwq（4星）  
**亮点**：  
- 分层图拓扑避免状态冲突  
- 特殊处理大质数边界情况  
**调试心得**：  
> "计算配对值时忘记判断溢出导致 WA，应增加 `if(res2 > 1e5) return`"

### 3. zzqDeco（4星）  
**亮点**：  
- 直接使用 `unordered_map` 简化代码  
- 特判 k=1 的优雅处理  
**代码技巧**：  
```cpp
int yu(int w) { // 特征值计算
    int res = 1;
    for(int i=2; i*i<=w; ++i)
        while(w%i == 0) res *= i, w /= i, cnt %= k;
    return res * (w > 1 ? w : 1); 
}
```

---

## 最优思路与技巧  
1. **质因数分解优化**：  
   - 预处理最小质因数加速分解（`pre[x]` 记录 x 的最小质因数编号）  
   - 对分解后的指数进行模 k 的快速计算  

2. **状态压缩存储**：  
   - 使用 `pair<vector<指数>, pair<大质数, 剩余指数>>` 复合结构  
   - 或采用双模数哈希避免冲突  

3. **拓扑排序优化**：  
   - 仅当特征值存在配对时才进行图构建  
   - 动态清空已处理的分层图节省内存  

---

## 类似题目推荐  
1. **P1073** [NOIP2009 最优贸易] - DAG 上的状态转移  
2. **P4017** [最大食物链计数] - 拓扑排序与 DP 结合  
3. **P2421** [NOI2002 荒岛野人] - 数论条件与路径问题的结合  

---

## 复古像素风格可视化方案  
**实现要点**：  
1. **画面风格**：  
   - 16 色 palette（深蓝背景、亮黄节点、红色路径）  
   - 8-bit 字体显示特征值如 "2^3→(3 mod 2)=1"  

2. **动画逻辑**：  
   ```javascript  
   function drawFrame() {
       ctx.fillStyle = '#1a1c2c'; // 深蓝背景
       ctx.fillRect(0, 0, canvas.width, canvas.height);
       nodes.forEach(n => {
           drawPixelNode(n.x, n.y, n.active ? '#e1e697' : '#7c3f58'); 
       });
       if(currentEdge) {
           drawArrow(currentEdge, '#ff6b6b'); // 红色箭头
           playSound('blip'); // 哔声提示
       }
   }
   ```

3. **音效设计**：  
   - `blip.wav`：边处理音效（方波 440Hz 50ms）  
   - `success.wav`：路径更新音效（上升琶音）  
   - `error.wav`：无效转移提示（降调噪声）  

---

## 核心代码实现  
**特征值预处理**：  
```cpp  
vector<int> pre(1e5+5, 0);
void init_primes() { // 预处理最小质因数
    for(int i=2; i<=1e5; ++i) {
        if(!pre[i]) {
            for(int j=i; j<=1e5; j+=i) 
                if(!pre[j]) pre[j] = i;
        }
    }
}

pair<int, int> get_features(int w) {
    int feat = 1, pair_feat = 1;
    while(w > 1) {
        int p = pre[w], cnt = 0;
        while(w % p == 0) w /= p, ++cnt;
        cnt %= k;
        if(cnt) {
            feat *= pow(p, cnt);
            pair_feat *= pow(p, k - cnt);
        }
    }
    return {feat, pair_feat};
}
```

**DP 转移核心**：  
```cpp  
unordered_map<int, int> dp[maxn];
int main() {
    for(int u : topo_order) {
        for(auto [v, w, l] : edges[u]) {
            auto [f, pf] = get_features(w);
            if(dp[u].count(pf)) 
                dp[v][f] = max(dp[v][f], dp[u][pf] + l);
            ans = max(ans, dp[v][f]);
        }
    }
}
```

---
处理用时：76.17秒
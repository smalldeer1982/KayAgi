# 题目信息

# 「SWTR-5」Chain

## 题目描述

给定 $n$ 个点，$m$ 条边的有向无环图。不保证图连通。

$q$ 次询问，每次给出 $k$ 和 $k$ 个互不相同的数 $c_i$，求出如果去掉这 $k$ 个点，整个有向无环图将剩余多少条链。答案对 $10^9+7$ 取模。**每次询问独立。**

- “链”的定义是：我们设一条长度为 $p$ 的链的路径为 $w_0\to w_1\to\cdots\to w_{p-1}\to w_p$，则应满足 $w_0$ 入度为 $0$，$w_p$ 出度为 $0$。你可以将其理解为一条食物链。

- 两条链是“不同的”，当且仅当它们的长度不同，或者经过的点集不同。

- **需要特别注意的是，删去某些点后新产生的链不计入答案。** 例如 $1\to 2\to 3\to 4$ 一图中，有 $1$ 条链 $1\to 2\to 3\to 4$。如果去掉 $2$ 号点，则剩余 $0$ 条链。

## 说明/提示

「样例 $1$ 说明」

DAG 如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2gbdoemh.png)

询问 $1$：如果去掉 $2,4,6$，则剩余 $1$ 条链：$3\to 5$。

询问 $2$：如果去掉 $4,6$，则剩余 $3$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$。

询问 $7$：如果去掉 $6$，则剩余 $5$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$，$3\to 1\to 4\to 5$，$3\to 7\to 4\to 5$。

「数据范围与约定」

**本题采用捆绑测试。**

- Subtask 1（1 point）：给定的图是一条链。
- Subtask 2（14 points）：$n,q\leq 10$。
- Subtask 3（20 points）：$q\leq 10^3$。
- Subtask 4（17 points）：$k=1$。
- Subtask 5（18 points）：$k=2$。
- Subtask 6（30 points）：无特殊限制。

对于 $100\%$ 的数据：$2\leq n\leq 2\times 10^3$，$1\leq m\leq \min(\frac{n\times(n-1)}{2},2\times 10^4)$，$1\leq q\leq 5\times 10^5$。  
所有询问满足：$1\leq \sum k\leq 2\times 10^6$，$0\leq k\leq \min(n,15)$，$1\leq c_i\leq n$。保证 $c_i$ 互不相同。

**本题轻微卡常，请注意 IO 优化。**

---

「题目来源」

[Sweet Round 05](https://www.luogu.com.cn/contest/28195) D。  
idea & solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

## 样例 #1

### 输入

```
7 14
3 2
4 5
2 5
2 6
3 1
3 5
3 7
3 6
6 4
1 4
6 5
1 6
7 2
7 4
7
3 2 4 6
2 4 6
2 2 5
2 1 4
0
1 4
1 6```

### 输出

```
1
3
0
6
13
7
5```

## 样例 #2

### 输入

```
233 1
1 2
6
0
1 10
2 10 40
1 1
1 2
2 1 2```

### 输出

```
232
231
230
231
231
231```

# AI分析结果



## 唯一算法分类
**拓扑排序 + 动态规划 + 容斥原理**

---

## 题解思路、算法要点与解决难点

### 核心算法流程
1. **预处理路径数**  
   - 用拓扑排序遍历 DAG，计算每个节点到其他节点的路径数 `d[i][j]`。
   - 动态规划预处理：
     - `f[i]`：从入度为 0 的起点到节点 `i` 的路径数。
     - `g[i]`：从节点 `i` 到出度为 0 的终点的路径数。
2. **总链数计算**  
   - 初始总链数 `sum = ∑ f[t]`，其中 `t` 为所有出度为 0 的节点。
3. **查询处理**  
   - 将被删除的节点按拓扑序排序。
   - 使用容斥原理调整贡献：按拓扑序依次扣除每个节点的路径贡献，并更新后续节点的贡献，避免重复扣除。

### 解决难点
- **高效处理多次删除**：利用预处理路径数和拓扑序，将每次查询的复杂度优化到 `O(k²)`。
- **避免重复扣除**：通过拓扑序排序确保处理顺序，结合容斥公式调整贡献。

---

## 题解评分 (≥4星)

### 1. yxzy4615 题解（⭐⭐⭐⭐⭐）
- **亮点**：详细推导子任务解法，预处理 `f` 和 `g` 的思路清晰，代码简洁。
- **关键代码**：
  ```cpp
  for (i=1;i<=m;i++) d[j]=(d[j]-1ll*d[i]*h[c[i]][c[j]]%p+p)%p;
  ```

### 2. a___ 题解（⭐⭐⭐⭐）
- **亮点**：代码结构清晰，使用超级源汇点简化计算，容斥逻辑明确。
- **关键代码**：
  ```cpp
  for(int i=1;i<=m;i++) d[j]=(d[j]-1ll*d[i]*h[c[i]][c[j]]%p+p)%p;
  ```

### 3. EnofTaiPeople 题解（⭐⭐⭐⭐）
- **亮点**：预处理 `onto` 和 `znto` 数组，直接计算全局贡献，实现高效查询。
- **关键代码**：
  ```cpp
  (nsum-=ans[ai]*znto[ask[ai]])%=Mod;
  ```

---

## 最优思路或技巧提炼

### 关键技巧
1. **拓扑序预处理路径数**：通过拓扑排序动态规划计算 `d[i][j]`，确保路径数计算的正确性。
2. **容斥调整贡献**：将删除点按拓扑序排序后，线性扣除每个点的贡献，避免重复计算。
3. **超级源汇点优化**：添加虚拟源点和汇点，统一处理多起点/终点的情况。

---

## 同类型题或类似算法套路

### 通用解法
- **DAG 路径计数**：通过拓扑排序 + 动态规划预处理路径数。
- **多删除点容斥**：利用拓扑序排序和容斥原理处理组合扣除。

### 类似题目
1. **P4017 最大食物链计数**：计算 DAG 中起点到终点的路径数。
2. **P3387 有向图最长路**：拓扑排序 + DP 求最长路径。
3. **P2717 寒假作业**：容斥原理处理组合限制。

---

## 可视化与算法演示

### 动画方案设计
1. **DAG 结构展示**  
   - **像素网格**：节点表示为彩色方块，边用箭头连接。
   - **颜色标记**：入度为 0 的节点（绿色），出度为 0 的节点（红色），被删除节点（闪烁灰色）。
2. **路径数预处理**  
   - **动态更新**：在拓扑排序过程中，实时显示每个节点的 `f` 和 `g` 值。
3. **查询处理演示**  
   - **容斥步骤**：按拓扑序高亮当前扣除节点，显示贡献调整公式（如 `d[j] -= d[i] * h[i][j]`）。
   - **音效提示**：每次扣除时播放“扣除音效”，最终答案更新时播放“成功音效”。

### 复古像素风格
- **Canvas 绘制**：使用 16 色调色板，节点为 32x32 像素方块，边为像素箭头。
- **音效设计**：
  - **扣除音效**：短促“哔”声。
  - **成功音效**：8-bit 风格胜利音乐。

---

## 推荐题目
1. **P4017**：DAG 路径计数，直接应用 `f` 和 `g` 预处理。
2. **P3387**：拓扑排序 + DP 求最长路径。
3. **P2717**：容斥原理处理组合限制。

---

## 个人心得摘录
- **调试教训**：预处理路径数时需注意模运算，避免负数（`(x % MOD + MOD) % MOD`）。
- **顿悟点**：按拓扑序排序删除点是容斥的关键，确保处理顺序正确。

---

## 代码片段（核心逻辑）
```cpp
// 预处理路径数
for (int u : topo_order) {
    for (int v : adj[u]) {
        for (int i = 1; i <= n; i++)
            d[i][v] = (d[i][v] + d[i][u]) % MOD;
    }
}

// 查询处理
sort(del, del + k, cmp);
for (int i = 0; i < k; i++) {
    ans[i] = f[del[i]];
    for (int j = 0; j < i; j++) {
        ans[i] -= ans[j] * d[del[j]][del[i]] % MOD;
    }
    total = (total - ans[i] * g[del[i]] % MOD + MOD) % MOD;
}
```

---
处理用时：98.76秒
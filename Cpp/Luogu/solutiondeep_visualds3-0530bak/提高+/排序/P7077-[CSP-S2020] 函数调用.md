# 题目信息

# [CSP-S2020] 函数调用

## 题目描述

函数是各种编程语言中一项重要的概念，借助函数，我们总可以将复杂的任务分解成一个个相对简单的子任务，直到细化为十分简单的基础操作，从而使代码的组织更加严密、更加有条理。然而，过多的函数调用也会导致额外的开销，影响程序的运行效率。

某数据库应用程序提供了若干函数用以维护数据。已知这些函数的功能可分为三类：

1. 将数据中的指定元素加上一个值；
2. 将数据中的每一个元素乘以一个相同值；
3. **依次**执行若干次函数调用，保证不会出现递归（即不会直接或间接地调用本身）。

在使用该数据库应用时，用户可一次性输入要调用的函数序列（一个函数可能被调用多次），在**依次**执行完序列中的函数后，系统中的数据被加以更新。某一天，小 A 在应用该数据库程序处理数据时遇到了困难：由于频繁而低效的函数调用，系统在执行操作时进入了无响应的状态，他只好强制结束了数据库程序。为了计算出正确数据，小 A 查阅了软件的文档，了解到每个函数的具体功能信息，现在他想请你根据这些信息帮他计算出更新后的数据应该是多少。

## 说明/提示

**【样例 #1 解释】**

$1$ 号函数功能为将 $a_1$ 的值加一。$2$ 号函数功能为所有元素乘 $2$。$3$ 号函数将先调用 $1$ 号函数，再调用 $2$ 号函数。

最终的函数序列先执行 $2$ 号函数，所有元素的值变为 $2, 4, 6$。

再执行 $3$ 号函数时，先调用 $1$ 号函数，所有元素的值变为 $3, 4, 6$。再调用 $2$ 号函数，所有元素的值变为 $6, 8, 12$。

**【数据范围】**

| 测试点编号 | $n, m, Q \le$ | $\sum C_j$ | 其他特殊限制 |
| :----------: | :----------: | :----------: | :----------: |
| $1 \sim 2$ | $1000$ | $= m - 1$ | 函数调用关系构成一棵树 |
| $3 \sim 4$ | $1000$ | $\le 100$ | 无 |
| $5 \sim 6$ | $20000$ | $\le 40000$ | 不含第 $2$ 类函数或不含第 $1$ 类函数 |
| $7$ | $20000$ | $= 0$ | 无 |
| $8 \sim 9$ | $20000$ | $= m - 1$ | 函数调用关系构成一棵树 |
| $10 \sim 11$ | $20000$ | $\le 2 \times 10^5$ | 无 |
| $12 \sim 13$ | $10^5$ | $\le 2 \times 10^5$ | 不含第 $2$ 类函数或不含第 $1$ 类函数 |
| $14$ | $10^5$ | $= 0$ | 无 |
| $15 \sim 16$ | $10^5$ | $= m - 1$ | 函数调用关系构成一棵树 |
| $17 \sim 18$ | $10^5$ | $\le 5 \times 10^5$ | 无 |
| $19 \sim 20$ | $10^5$ | $\le 10^6$ | 无 |

对于所有数据：$0 \le a_i \le 10^4$，$T_j \in \{1,2,3\}$，$1 \le P_j \le n$，$0 \le V_j \le 10^4$，$1 \le g^{(j)}_k \le m$，$1 \le f_i \le m$。

## 样例 #1

### 输入

```
3
1 2 3
3
1 1 1
2 2
3 2 1 2
2
2 3
```

### 输出

```
6 8 12```

## 样例 #2

### 输入

```
10
1 2 3 4 5 6 7 8 9 10
8
3 2 2 3
3 2 4 5
3 2 5 8
2 2
3 2 6 7
1 2 5
1 7 6
2 3
3
1 2 3```

### 输出

```
36 282 108 144 180 216 504 288 324 360
```

## 样例 #3

### 输入

```
见附件中的 call/call3.in```

### 输出

```
见附件中的 call/call3.ans```

# AI分析结果



**唯一算法分类**：拓扑排序（DAG处理）与动态维护乘法因子

---

### **综合分析与结论**

1. **核心思路与难点**  
   - **核心思想**：将函数调用视为DAG，通过两次拓扑排序分别处理乘法因子（mul）和执行次数（cnt）。乘法操作会放大后续加法的影响，需倒序处理调用序列维护后缀积。
   - **关键变量**：
     - `mul[i]`：函数i执行后的全局乘积
     - `cnt[i]`：函数i的等效调用次数（考虑后续乘法影响）
   - **难点突破**：操作3的嵌套调用需倒序处理子函数，维护每个函数的后缀积以正确计算加法操作的放大倍数。

2. **可视化设计要点**  
   - **DAG动画**：像素风格绘制函数调用图，当前处理节点高亮为红色，子节点为黄色。
   - **动态更新**：展示`mul`值从叶子节点向上传递的过程，`cnt`值通过倒序箭头方向传递。
   - **音效交互**：每次拓扑队列弹出节点时播放“哔”音效，乘法因子更新时播放“叮”音效。

---

### **题解清单 (4星及以上)**

1. **小菜鸟（5星）**
   - **亮点**：清晰的两阶段拓扑排序，预处理mul后处理cnt，代码注释详细。
   - **核心代码段**：
     ```cpp
     void topo1() { // 计算mul
         for(int u : G2[v]) 
             mul[v] *= mul[u];
     }
     void topo2() { // 计算cnt
         for(int i=G1[u].size()-1; i>=0; --i)
             cnt[v] += cnt[u] * now_mul;
     }
     ```

2. **AK_Dream（4.5星）**
   - **亮点**：引入后缀积数组优化计算，预处理函数调用的乘法链。
   - **关键思想**：每个函数维护`suf[i]`表示后续调用的乘积，倒序遍历子函数时动态维护。

3. **Alex_Wei（4星）**
   - **亮点**：通过DFS预处理mul，简化拓扑逻辑，代码简洁易移植。
   - **个人心得**：提到考场上因时间分配失误未调通，强调先处理乘法标记的重要性。

---

### **最优思路提炼**

1. **两次拓扑排序**
   - **阶段一**：反向拓扑（子→父）计算每个函数的`mul`值。
   - **阶段二**：正向拓扑（父→子）倒序处理子函数，维护后缀积更新`cnt`。

2. **倒序处理调用序列**
   ```cpp
   int now_mul = 1;
   for (int i = Q; i >= 1; --i) {
       cnt[f[i]] += now_mul;
       now_mul *= mul[f[i]];
   }
   ```

---

### **相似题目推荐**

1. [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)  
   - **关联点**：拓扑排序处理层次关系

2. [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)  
   - **关联点**：DAG上的动态规划

3. [P1038 神经网络](https://www.luogu.com.cn/problem/P1038)  
   - **关联点**：拓扑排序处理依赖关系与状态传递

---

### **核心代码实现**

```cpp
const int MOD = 998244353;
vector<int> G[N], RG[N];
int mul[N], cnt[N], deg[N];

// 阶段一：计算mul
void calc_mul() {
    queue<int> q;
    for (int i=1; i<=m; ++i) if (!deg[i]) q.push(i);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : RG[u]) {
            mul[v] = (ll)mul[v] * mul[u] % MOD;
            if (--deg[v] == 0) q.push(v);
        }
    }
}

// 阶段二：计算cnt
void calc_cnt() {
    queue<int> q;
    for (int i=1; i<=m; ++i) if (G[i].empty()) q.push(i);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        ll suf = 1;
        for (auto it = G[u].rbegin(); it != G[u].rend(); ++it) {
            int v = *it;
            cnt[v] = (cnt[v] + (ll)cnt[u] * suf) % MOD;
            suf = (ll)suf * mul[v] % MOD;
        }
    }
}
```

---

### **可视化算法演示**

```javascript
// 伪代码：Canvas绘制DAG与拓扑过程
class Node {
    constructor(id, x, y) {
        this.id = id;
        this.mul = 1;
        this.cnt = 0;
        this.color = "#FFFFFF";
    }
    draw(ctx) {
        ctx.fillStyle = this.color;
        drawPixelRect(x, y, 32, 32); // 8位像素风格
        ctx.fillText(`mul:${this.mul}`, x+5, y+12);
        ctx.fillText(`cnt:${this.cnt}`, x+5, y+24);
    }
}

function animateTopo(queue, isReverse) {
    let current = queue.popFront();
    current.color = "#FF0000"; // 高亮当前节点
    playSound("beep.wav");
    for (let child of current.children(isReverse)) {
        updateMulOrCnt(child); // 更新子节点属性
        child.color = "#FFFF00"; // 子节点短暂高亮
    }
}
```

---
处理用时：70.44秒
# 题目信息

# [蓝桥杯 2022 省 A] 扫描游戏

## 题目描述

有一根围绕原点 $O$ 顺时针旋转的棒 $OA$，初始时指向正上方（Y 轴正向）。平面中有若干物件，第 $i$ 个物件的坐标为 $\left(x_{i}, y_{i}\right)$，价值为 $z_{i}$。当棒扫到某个物件时，棒的长度会瞬间增长 $z_{i}$，且物件瞬间消失（棒的顶端恰好碰到物件也视为扫到)，如果此时增长完的棒又额外碰到了其他物件，也按上述方式消去（它和上述那个点视为同时消失）。

如果将物件按照消失的时间排序，则每个物件有一个排名，同时消失的物件排名相同，请输出每个物件的排名，如果物件永远不会消失则输出 $-1$。

## 说明/提示

对于 $30 \%$ 的评测用例，$1 \leq n \leq 500$ ；

对于 $60 \%$ 的评测用例，$1 \leq n \leq 5000$;

对于所有评测用例，$1 \leq n \leq 2\times10^5,-10^{9} \leq x_{i}, y_{i} \leq 10^{9}, 1 \leq L, z_{i} \leq 10^{9}$ 。 

样蓝桥杯 2022 省赛 A 组 H 题。

## 样例 #1

### 输入

```
5 2
0 1 1
0 3 2
4 3 5
6 8 1
-51 -33 2```

### 输出

```
1 1 3 4 -1```

# AI分析结果



---

## 唯一算法分类  
扫描线算法/极角排序+优先队列

---

## 综合分析与结论

### 核心思路与难点
**核心问题**：在棒子顺时针旋转过程中，动态维护可被扫描的物件集合，并确定扫描顺序。关键在于：
1. **极角排序**：按顺时针方向计算物件的极角
2. **距离筛选**：只保留距离≤当前棒长的物件
3. **动态维护**：棒长变化后快速找到下一个最近的物件

**解决难点**：
- **极角处理**：需将坐标系转换为传统极角计算方式（Y轴顺时针→X轴逆时针）
- **跨圈处理**：当棒子旋转超过360°时，需重新处理先前未扫描的物件
- **同排名判定**：同一极角且同一批次扫描的物件共享排名

### 算法流程
1. **坐标变换**：将原坐标系(x,y)转换为(y,x)以适配传统极角计算
2. **极角排序**：用`atan2`计算极角并按距离升序排序
3. **优先队列维护**：
   - 初始化：将距离≤初始棒长的物件加入队列
   - 循环处理：
     1. 取出极角最小的物件（队首）
     2. 更新棒长与排名
     3. 将新增可达物件加入队列
     4. 队列空时加载下一圈物件

### 可视化设计
- **动画元素**：
  - **棒子**：红色线段从原点延伸，实时显示长度
  - **物件**：不同颜色表示状态（未扫描/可扫描/已扫描）
  - **优先队列**：侧边栏动态显示队列中的极角排序
- **交互功能**：
  - 步进控制：单步执行扫描过程
  - 高亮显示：当前处理的物件变为闪烁状态
  - 数据跟踪：实时显示棒长、当前排名、已扫描数量
- **像素风格**：
  - 8-bit 音效：扫描成功时播放上升音调，跨圈时播放转场音效
  - 复古UI：仿FC风格的数值面板显示关键参数

---

## 题解清单 (≥4星)

1. **I_AM_CIMOTA**（⭐️⭐️⭐️⭐️）  
   亮点：堆维护动态极角，时间复杂度严格O(n log n)，代码简洁

2. **Ultraman_King**（⭐️⭐️⭐️⭐️⭐️）  
   亮点：坐标变换解决极角计算，优先队列+vector实现跨圈处理，代码规范

3. **int_4096**（⭐️⭐️⭐️⭐️）  
   亮点：线段树维护最小距离，避免浮点运算，适合大整数场景

---

## 核心代码实现

```cpp
// 坐标变换与极角计算
struct Pt {
    int Z, I;
    i64 Dist;
    double Deg;
    Pt(int x, int y, int z, int i) : Z(z), I(i), 
        Dist((i64)x*x + (i64)y*y), 
        Deg(atan2(y, x)) { if(Deg<0) Deg += 2*M_PI; }
    bool operator<(const Pt &p) const { return Dist < p.Dist; }
};

priority_queue<tuple<double, const Pt*>> degPts;
vector<tuple<double, const Pt*>> nxtDegPts;

void RefreshDegPts() {
    static auto st = pts.begin();
    for (i64 L2 = L*L; st != pts.end() && st->Dist <= L2; ++st)
        if (st->Deg >= curDeg) degPts.emplace(-st->Deg, &(*st)); // 最小堆
        else nxtDegPts.emplace_back(st->Deg, &(*st));
}

void mainProcess() {
    do {
        RefreshDegPts();
        while (!degPts.empty()) {
            auto [deg, pt] = degPts.top(); degPts.pop();
            if (deg != curDeg) rank = ++curRank; // 新极角更新排名
            ans[pt->I] = rank;
            L += pt->Z;
            RefreshDegPts();
        }
        degPts = priority_queue(nxtDegPts.begin(), nxtDegPts.end());
    } while (!degPts.empty());
}
```

---

## 相似题目推荐
1. **P2280 [HNOI2003] 激光炸弹** - 极坐标系下的扫描覆盖
2. **P3669 [USACO17OPEN]Paired Up** - 动态维护最近点对
3. **P3478 [POI2008]STA-Station** - 极角排序+树形DP

---

## 可视化示例（伪代码）
```javascript
// Canvas绘制核心逻辑
function drawFrame() {
    ctx.clearRect(0, 0, W, H);
    // 绘制棒子
    ctx.strokeStyle = '#FF0000';
    ctx.beginPath();
    ctx.moveTo(O.x, O.y);
    ctx.lineTo(O.x + L*Math.sin(curDeg), O.y - L*Math.cos(curDeg)); 
    ctx.stroke();
    
    // 绘制物件
    pts.forEach(p => {
        ctx.fillStyle = p.scanned ? '#00FF00' : '#0000FF';
        ctx.fillRect(p.x*scale + O.x, p.y*scale + O.y, 5, 5);
    });
    
    // 绘制优先队列
    let qY = 20;
    degPts.forEach((p, i) => {
        ctx.fillText(`θ=${p.deg.toFixed(2)} d=${p.dist}`, 10, qY + i*15);
    });
}
```

---

## 个人心得摘录
> "坐标变换后极角计算直接使用`atan2`，比手动处理象限更可靠" —— Ultraman_King  
> "线段树二分时忘记清空导致WA，维护动态区间需格外注意边界" —— int_4096

---
处理用时：88.86秒
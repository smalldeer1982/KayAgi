# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果



### 算法分类  
**DFS**

---

### 题解思路、算法要点与解决难点  
**核心思路**：将树按深度分层，在每一层中通过 DFS 选择一个子树切断，最大化被保护的节点数。  
**算法要点**：  
1. **分层预处理**：使用 BFS/DFS 预处理每个节点的深度，并按层存储节点。  
2. **子树大小计算**：统计以每个节点为根的子树大小，用于快速计算切断后的保护数。  
3. **回溯剪枝**：在 DFS 中切断子树（标记节点或边）后递归下一层，回溯时恢复状态。  

**解决难点**：  
- **避免子树重叠**：需保证每次切断的子树未被其祖先切断（通过父节点标记或路径检查）。  
- **优化时间复杂度**：通过分层处理将指数级搜索空间约束到树的深度维度，结合贪心剪枝（如 A* 估价函数）或随机化策略加速。  

---

### 题解评分  
1. **RikoHere（4星）**  
   - **亮点**：代码模块化清晰，详细注释，适合初学者。预处理通过 BFS 确定父子关系，分层 DFS 逻辑直观。  
2. **zi小眼聚光（4星）**  
   - **亮点**：A* 剪枝优化，预处理每层最大子树作为估价函数，显著减少搜索空间。  
3. **henry_y（4星）**  
   - **亮点**：贪心+随机化策略，通过多次尝试逼近最优解，代码简洁且适应数据较弱的场景。  

---

### 最优思路或技巧提炼  
1. **分层处理**：按树的深度分层决策，将问题分解为每层的局部最优选择。  
2. **子树快速统计**：预处理子树大小，避免递归重复计算。  
3. **回溯剪枝**：通过标记-恢复状态实现高效回溯，确保搜索空间完整覆盖。  
4. **随机化与贪心结合**：在贪心基础上引入随机扰动，避免局部最优陷阱。  

---

### 同类型题或类似算法套路  
- **树形决策问题**：如「P2014 选课」（树形 DP）、「P1273 有线电视网」（子树贡献统计）。  
- **剪枝优化搜索**：如「P1074 靶形数独」（DFS+启发式剪枝）。  
- **分层 BFS/DFS**：如「P1137 旅行计划」（拓扑分层处理）。  

---

### 推荐题目  
1. **P2014 选课**（树形 DP，子树选择）  
2. **P1352 没有上司的舞会**（树形决策，相邻节点约束）  
3. **P1137 旅行计划**（分层图遍历，拓扑排序）  

---

### 个人心得摘录  
- **RikoHere**：强调分模块调试，预处理父子关系是代码清晰的关键。  
- **henry_y**：通过构造极端数据发现贪心缺陷，引入随机化“蒙混过关”。  
- **zi小眼聚光**：A* 剪枝的估价函数需乐观估计，实际编码中需忽略祖先已切除的约束。  

---

### 可视化与算法演示  
**动画方案**：  
1. **树形结构展示**：用 Canvas 绘制树，不同深度节点按横向排列，边用线条连接。  
2. **分层染色**：当前处理的层高亮显示，候选切断子树用闪烁边框标记。  
3. **传播模拟**：红色表示已感染，绿色表示被保护，切断边时播放“咔嚓”音效。  
4. **回溯演示**：点击“撤销”按钮时，恢复子树颜色并显示回溯路径。  

**复古像素风格**：  
- **颜色方案**：8-bit 调色板（深绿背景，亮红/绿节点，灰色边）。  
- **音效设计**：切断时播放 8-bit “刀剑”音效，感染扩散时低频嗡鸣。  
- **自动演示模式**：AI 按最优策略逐步切断，用户可暂停观察每层决策。  

---

### 核心代码实现（RikoHere 分层 DFS 片段）  
```cpp
void dfs(int cen, int tot) {
    maxx = max(maxx, tot); // 更新最大保护数
    for (int i = 0; i < cnt[cen]; ++i) {
        int node = b[cen][i];
        if (!bol[node]) { // 若节点未被保护
            int num = clean(node); // 切断并统计子树大小
            dfs(cen + 1, tot + num); // 递归下一层
            reclean(node); // 回溯恢复
        }
    }
}
```

**预处理分层**：  
```cpp
void resolve(int u, int depth) {
    b[depth][cnt[depth]++] = u; // 按层存储节点
    for (int v : f[u]) {
        if (dis[v] == dis[u] + 1) { // 确认父子关系
            resolve(v, depth + 1);
        }
    }
}
```

---

### 总结  
本题需在树形结构中通过分层 DFS 决策，核心在于预处理与回溯剪枝。各题解通过分层处理、子树统计和状态回溯实现高效搜索，适用于类似树形决策问题。可视化设计可结合复古像素风格增强交互体验。

---
处理用时：96.08秒
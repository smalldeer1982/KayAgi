# 题目信息

# [NOIP 2004 提高组] 合唱队形

## 题目描述

$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。

合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1< \cdots <t_i>t_{i+1}>$ … $>t_k(1\le i\le k)$。

你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

## 说明/提示

对于 $50\%$ 的数据，保证有 $n \le 20$。

对于全部的数据，保证有 $n \le 100$。


## 样例 #1

### 输入

```
8
186 186 150 200 160 130 197 220
```

### 输出

```
4
```

# AI分析结果



1. **唯一算法分类**  
其他搜索

---

### 综合分析与结论

**核心思路**  
题目要求找到最长的先递增后递减子序列，等价于对每个位置计算其左侧最长递增子序列（LIS）和右侧最长递减子序列（LDS）的总和。最终结果为总人数减去该最大值。

**动态规划要点**  
- **左右序列分离计算**：对每个位置分别计算 LIS 和 LDS，时间复杂度 O(n²) 或优化至 O(n log n)。
- **状态转移方程**：
  - LIS：`f1[i] = max(f1[j]+1)`，其中 `j < i` 且 `a[j] < a[i]`
  - LDS：`f2[i] = max(f2[j]+1)`，其中 `j > i` 且 `a[j] < a[i]`
- **合并结果**：遍历所有位置，取 `f1[i]+f2[i]-1` 的最大值。

**解决难点**  
- **严格递增/递减条件**：需确保子序列严格单调，部分题解通过调整二分查找边界（如使用 `lower_bound` 或 `upper_bound`）实现。
- **O(n log n) 优化**：维护动态数组 `g` 记录不同长度子序列的最小末尾值，用二分查找快速定位插入位置。

---

### 题解清单 (≥4星)

1. **VitrelosTia（5星）**  
   - **亮点**：唯一实现 O(n log n) 优化的题解，结合二分查找维护动态数组，代码高效且思路清晰。
   - **关键代码**：使用 `lower_bound` 快速定位插入位置，显著降低时间复杂度。

2. **FISH酱（4星）**  
   - **亮点**：标准 O(n²) 动态规划实现，代码简洁易懂，适合新手理解。
   - **关键代码**：双循环分别计算 LIS 和 LDS，逻辑直观。

3. **lucky_Mrzhao（4星）**  
   - **亮点**：代码最简洁，变量命名清晰，适合快速实现。
   - **关键代码**：双循环分离计算 LIS 和 LDS，合并结果逻辑明确。

---

### 最优思路或技巧提炼

1. **二分优化 LIS/LDS**  
   - 维护动态数组 `g`，记录长度为 `i` 的子序列的最小末尾值，通过二分查找快速定位插入位置，将时间复杂度从 O(n²) 优化至 O(n log n)。
   - **代码片段**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         int pos = lower_bound(g + 1, g + len + 1, a[i]) - g;
         f1[i] = pos;
         g[pos] = a[i];
         len = max(len, pos);
     }
     ```

2. **倒序处理 LDS**  
   - 反转数组后复用 LIS 逻辑，即可得到原数组的 LDS。
   - **代码片段**：
     ```cpp
     reverse(a + 1, a + n + 1);
     for (int i = 1; i <= n; i++) {
         int pos = lower_bound(g + 1, g + len + 1, a[i]) - g;
         f2[i] = pos;
         g[pos] = a[i];
         len = max(len, pos);
     }
     ```

---

### 同类型题与算法套路

- **最长上升子序列变形**：如 [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)，结合单调性分析。
- **双序列动态规划**：如 [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)，需同时维护多个状态。

---

### 推荐相似题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)  
   **考察点**：最长不上升子序列与二分优化。

2. [P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)  
   **考察点**：LIS 优化与序列映射技巧。

3. [P1095 守望者的逃离](https://www.luogu.com.cn/problem/P1095)  
   **考察点**：动态规划与多状态转移。

---

### 可视化与算法演示

**动画设计**  
- **动态数组 `g` 的维护**：以柱状图展示 `g` 数组变化，高亮当前插入位置。
- **节点扩展过程**：用颜色区分已处理节点（绿色）、待处理节点（灰色）、当前操作节点（红色）。
- **步进控制**：支持暂停/继续，观察每一步的二分查找和数组更新。

**复古像素风格**  
- **Canvas 绘制**：用 8-bit 像素风格渲染数组元素，背景音乐为 8-bit 音效。
- **音效触发**：插入新元素时播放“哔”声，完成搜索时播放胜利音效。

---

### 代码实现（VitrelosTia 的 O(n log n) 解法）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int M = 1e5 + 5, INF = 1e9;
int a[M], f1[M], f2[M], g[M], len, ans = -INF;

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    
    len = 0;
    for (int i = 1; i <= n; i++) {
        int pos = lower_bound(g + 1, g + len + 1, a[i]) - g;
        f1[i] = pos;
        g[pos] = a[i];
        len = max(len, pos);
    }
    
    len = 0;
    memset(g, 0, sizeof(g));
    for (int i = n; i >= 1; i--) {
        int pos = lower_bound(g + 1, g + len + 1, a[i]) - g;
        f2[i] = pos;
        g[pos] = a[i];
        len = max(len, pos);
    }
    
    for (int i = 1; i <= n; i++) ans = max(ans, f1[i] + f2[i] - 1);
    cout << n - ans;
    return 0;
}
```

---

### 个人心得摘录

- **二分边界处理**：部分题解因未正确处理严格递增导致错误，需注意 `lower_bound` 与 `upper_bound` 的差异。
- **调试技巧**：通过打印 `f1` 和 `f2` 数组验证中间结果，避免逻辑错误。

---
处理用时：232.85秒
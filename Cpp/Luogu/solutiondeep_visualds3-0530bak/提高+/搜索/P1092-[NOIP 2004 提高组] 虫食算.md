# 题目信息

# [NOIP 2004 提高组] 虫食算

## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：

$$\begin{aligned}
 \verb!43#9865#045! \\
+\qquad \verb!8468#6633! \\[-1em]\underline{\kern{8em}} \\
 \verb!44445509678! \\
\end{aligned}$$

其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。

$$\begin{aligned}
 \verb!BADC! \\
+\quad \verb!CBDA! \\[-1em]\underline{\kern{4em}} \\
 \verb!DCCC! \\
\end{aligned}$$

上面的算式是一个4进制的算式。很显然，我们只要让 $\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 10$；
- 对于 $50\%$ 的数据，保证 $n \le 15$；
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 26$。

## 样例 #1

### 输入

```
5
ABCED
BDACE
EBBAA
```

### 输出

```
1 0 3 4 2
```

# AI分析结果



## 算法分类
**DFS**

---

## 题解思路与解决难点
### 核心思路
本题需通过DFS搜索每个字母对应的数字，并配合剪枝策略减少搜索空间。核心难点在于：
1. **进位处理**：每位加法需考虑低位的进位（0或1）。
2. **剪枝优化**：及时排除不可能的情况，避免无效搜索。
3. **搜索顺序**：从低位到高位或按字母出现频率优化顺序，尽早触发剪枝。

### 各题解对比
1. **zzlzk的题解**（★★★★★）  
   - **Next数组**：按字母出现顺序反向确定搜索优先级，优先处理低位字母。  
   - **剪枝策略**：最高位无进位；每位必须满足 `(A+B) mod n = C` 或 `(A+B+1) mod n = C`。  
   - **代码亮点**：通过预处理确定搜索顺序，结合双重剪枝大幅提升效率。

2. **feecle6418的题解**（★★★★☆）  
   - **搜索顺序优化**：从竖式的最低位开始搜索，逐列处理。  
   - **剪枝改进**：在每层搜索中提前验证当前列是否可能合法。  
   - **代码亮点**：通过改变字母的遍历顺序，减少深层递归的无效分支。

3. **Tgotp的题解**（★★★★☆）  
   - **知二求一**：若某列已知两数，直接计算第三数，减少枚举分支。  
   - **实时剪枝**：每一步检查当前列是否满足条件，否则立即回溯。  
   - **代码亮点**：通过条件判断直接推导部分字母的值，提高搜索效率。

---

## 最优思路与技巧
1. **搜索顺序优化**  
   - **从低位到高位**：模拟竖式计算，优先处理低位进位影响。  
   - **高频字母优先**：通过Next数组优先处理出现次数多的字母，更快触发剪枝。

2. **剪枝策略**  
   - **最高位无进位**：若最高位进位则直接剪枝。  
   - **逐列合法性检查**：每确定一位后，检查当前列是否满足可能的进位情况。

3. **知二求一推导**  
   - 若某列的两个加数已知，可直接计算和或进位，减少搜索分支。

---

## 同类型题与算法套路
- **类似题目**：  
  - **八皇后问题**（DFS+剪枝）  
  - **数独求解**（回溯+区域检查）  
  - **全排列生成**（剪枝去重）  
- **通用套路**：  
  - **优先处理约束强的变量**：如数独中空位少的行。  
  - **双向搜索**：从起点和终点同时BFS，减少搜索深度。

---

## 推荐题目
1. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)（DFS+剪枝优化）  
2. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)（剪枝+搜索顺序优化）  
3. [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379)（BFS/A*算法）  

---

## 个人心得摘录
- **zzlzk**：  
  > “Next数组的引入让搜索顺序更贴近实际约束，避免在无关字母上浪费时间。”  
- **feecle6418**：  
  > “从低位开始搜索，每一步都像是拼图，只有当前列合法才能继续拼下一块。”  
- **Tgotp**：  
  > “知二求一的思路让搜索从暴力枚举变为部分推导，极大减少递归深度。”

---

## 可视化与算法演示
### 动画设计
- **像素风格界面**：  
  - 每个字母用8位风格方块表示，已赋值字母显示数字，未赋值显示问号。  
  - 进位用闪烁箭头表示，从低位指向高位。  
- **搜索过程演示**：  
  1. 从右到左逐列处理，当前列高亮。  
  2. 若某列两数已知，计算第三数并检查合法性（成功则绿色闪烁，失败则红色闪烁）。  
  3. 显示当前递归栈深度和剪枝次数。  
- **音效与交互**：  
  - **赋值成功**：清脆“叮”声。  
  - **剪枝触发**：低沉“嗡”声。  
  - **找到解**：播放胜利音效+烟花动画。  

### 关键代码片段（zzlzk的Next数组）
```cpp
void GetNext(int x) {
    if (!used[x]) {        // 记录字母出现顺序
        used[x] = true;
        Next[cnt++] = x;   // Next数组确定搜索优先级
    }
}
```

---

## 总结
本题通过DFS结合多重剪枝策略高效求解，核心在于优化搜索顺序与实时合法性检查。实际编码中，Next数组和逐列剪枝是提升性能的关键。

---
处理用时：102.46秒
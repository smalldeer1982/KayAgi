# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果



## 算法分类
**二分图匹配**

---

## 综合分析与结论

### 核心思路与算法要点
所有题解的核心思路均基于**二分图匹配**。将矩阵的行和列视为二分图的两个集合，每个黑色格子 `(i,j)` 视为行i与列j的匹配关系。最终问题转化为：能否找到n个互不冲突的行列匹配，使得每个主对角点 `(i,i)` 都能被覆盖。

**核心难点**：将行列交换操作转换为图论问题。交换行/列不影响匹配数，因此只需判断初始状态是否存在完美匹配。

### 可视化设计思路
1. **像素风格动画**：用8位像素风格绘制行节点（左）、列节点（右），黑色格子表现为连接线。匹配成功的边用绿色闪烁，未匹配的边用灰色。
2. **搜索过程演示**：展示匈牙利算法的增广路径查找过程，当前访问节点用高亮色，回溯路径用渐变色标记。
3. **音效交互**：找到增广路时播放上升音调，匹配失败时短促提示音，最终结果用8-bit风格胜利/失败音乐。

---

## 题解清单（评分≥4星）

1. **Night_Aurora（⭐️⭐️⭐️⭐️⭐️）**  
   核心亮点：精准指出交换操作不改变匹配数的本质，用网络流思想解释，代码高效。

2. **俾斯麦（⭐️⭐️⭐️⭐️）**  
   亮点：同时提供匈牙利和Dinic两种实现，详细注释与复杂度分析，适合不同基础读者。

3. **hs_black（⭐️⭐️⭐️⭐️）**  
   亮点：代码简洁高效，用邻接表优化空间，适合竞赛场景。

---

## 最优思路提炼

### 关键代码（匈牙利算法）
```cpp
bool dfs(int u) {
    for (int v : graph[u]) {
        if (!vis[v]) {
            vis[v] = true;
            if (!match[v] || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

bool solve() {
    int cnt = 0;
    for (int i=1; i<=n; ++i) {
        memset(vis, 0, sizeof(vis));
        if (dfs(i)) cnt++;
    }
    return cnt == n;
}
```

### 核心思想
- **建图**：每行向包含黑格子的列连边
- **匹配判定**：匈牙利算法尝试为每行找到唯一列
- **优化**：时间戳替代memset提升效率

---

## 同类型题推荐
1. **P3386 【模板】二分图匹配**  
   基础匈牙利算法练习
2. **P1963 变换序列**  
   最小字典序完美匹配
3. **P2764 最小路径覆盖**  
   二分图与DAG结合

---

## 可视化代码片段（Canvas动画）
```javascript
// 绘制节点与边
function drawGraph() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // 绘制行节点（左列）
    for(let i=0; i<n; i++) {
        ctx.fillStyle = visitedRows[i] ? "#FF5555" : "#5555FF";
        ctx.fillRect(50, 50+i*40, 30, 30);
    }
    // 绘制列节点（右列）
    for(let j=0; j<n; j++) {
        ctx.fillStyle = visitedCols[j] ? "#FF5555" : "#5555FF";
        ctx.fillRect(400, 50+j*40, 30, 30);
    }
    // 绘制匹配边
    for(let edge of edges) {
        ctx.beginPath();
        ctx.moveTo(80, 65+edge[0]*40);
        ctx.lineTo(400, 65+edge[1]*40);
        ctx.strokeStyle = matched[edge[1]] == edge[0] ? "#00FF00" : "#888888";
        ctx.stroke();
    }
}
```

---

## 复古音效设计
- **节点访问**：8-bit "哔"声（Web Audio合成方波）
- **匹配成功**：上升琶音（C大调音阶）
- **最终判定**：成功时播放《超级马里奥》通关旋律，失败时播放《塞尔达传说》低生命警告音。

---
处理用时：66.98秒
# 题目信息

# 三角形

## 题目描述

给出平面上的 $n$ 个等腰直角三角形。每个三角形用三个整数 $x,y,m$ 描述。一个三角形的三个顶点分别是 $(x,y),(x+m,y),(x,y+m)$。

你的任务是计算这些三角形覆盖的总面积。

## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)

数据范围：$1\le n \le 2000$，$1 \le i \le n$，$-10^7 \le x_i,y_i \le 10^7$，$1\leq m_i \le 1000$。

## 样例 #1

### 输入

```
5
-5 -3 6
-1 -2 3
0 0 2
-2 2 1
-4 -1 2
```

### 输出

```
24.5```

# AI分析结果



### 唯一算法分类
**扫描线算法**

---

### 题解思路与解决难点

#### **核心思路**
1. **离散化纵坐标**  
   将所有三角形的底边和顶点纵坐标离散化，作为扫描线事件点。添加斜边与直角边的交点纵坐标，确保覆盖所有关键位置。
2. **维护覆盖区间**  
   每遇到一条扫描线，动态维护当前所有三角形的有效覆盖区间。使用差分数组和排序合并区间，快速计算覆盖总长度。
3. **梯形面积累加**  
   用相邻扫描线间的覆盖长度（上底和下底）计算梯形面积，公式为：  
   $$ S = \frac{(len_{\text{now}} + len_{\text{bef}}) \cdot \Delta y}{2} $$

#### **核心难点**
1. **斜边交点的处理**  
   未添加斜边与直角边交点时，会漏算关键分割点。需遍历所有三角形对，计算交点并加入离散化纵坐标集合。
2. **动态维护覆盖区间**  
   扫描线移动时需动态插入和删除三角形，用差分数组高效维护区间覆盖状态。

---

### 题解评分（≥4星）

1. **ZhYic（★★★★☆）**  
   - 详细分析扫描线流程，处理斜边交点问题  
   - 代码完整但实现较复杂  
   - 提供调试案例与关键漏洞修复思路

2. **辰星凌（★★★★☆）**  
   - 自适应辛普森积分法，解决漏算问题  
   - 优化离散化关键点，精度控制稳定  
   - 代码简洁易扩展，适用多类面积并问题

3. **Edgration（★★★★☆）**  
   - 自适应辛普森积分实现简洁  
   - 调整精度参数平衡效率与正确性  
   - 依赖调参，但在数据分布均匀时表现良好

---

### 最优技巧提炼

1. **离散化与事件点插入**  
   离散化所有可能的纵坐标（包括斜边交点），确保扫描线覆盖所有关键分割点。
2. **差分数组维护覆盖状态**  
   将覆盖区间的起点和终点标记为差分事件（+1/-1），排序后合并区间快速计算覆盖长度。
3. **分块积分优化**  
   对离散化后的每个区间单独计算辛普森积分，避免因函数突变导致的误差。

---

### 同类型题与算法套路

- **矩形面积并**：扫描线 + 线段树维护覆盖次数  
  **题目推荐**：P5490 【模板】扫描线
- **圆的面积并**：自适应辛普森积分法  
  **题目推荐**：SP8073 CIRU
- **多边形面积交**：扫描线 + 多边形裁剪  
  **题目推荐**：P3219 [HNOI2012]三角形覆盖问题

---

### 推荐相似题目

1. **P5490 【模板】扫描线**（矩形面积并）  
2. **P3219 [HNOI2012]三角形覆盖问题**（动态三角形覆盖）  
3. **SP8073 CIRU**（圆的面积并）

---

### 个人心得摘录

- **ZhYic**：  
  > “如果两条扫描线之间存在斜边与直角边的交点，必须将其加入离散化事件点，否则会漏算梯形面积。”  
  **总结**：离散化需覆盖所有几何关键点。

- **辰星凌**：  
  > “自适应辛普森在计算三角形面积并时，需手动添加关键纵坐标分块，避免递归提前终止导致漏算。”  
  **总结**：数值积分需结合离散化分块优化。

---

### 可视化与算法演示

#### **动画设计**
1. **扫描线动态移动**  
   - 纵坐标轴显示当前扫描线位置，覆盖区间以红色高亮。  
   - 背景网格表示离散化后的纵坐标分块。
2. **覆盖区间合并**  
   - 差分事件点以绿色（+1）和蓝色（-1）标记，合并后的区间显示为黄色块。
3. **像素风格**  
   - 使用16色调色板，三角形以不同颜色填充，扫描线移动时有8位音效（类似《俄罗斯方块》的行消除音效）。

#### **交互功能**
- **步进控制**：按空格键单步执行扫描线移动，显示当前覆盖长度和累加面积。  
- **自动模式**：点击“AI演示”自动运行，速度可调（1x/2x/4x）。  
- **音效触发**：  
  - 扫描线移动时播放短促“滴”声。  
  - 覆盖区间更新时播放轻微“咔嗒”声。

---

### 核心代码实现（扫描线算法）

#### **离散化与事件处理**
```cpp
vector<int> y_vals;
for (int i = 0; i < n; i++) {
    y_vals.push_back(tri[i].y);          // 底边纵坐标
    y_vals.push_back(tri[i].y + tri[i].m); // 顶点纵坐标
    // 添加斜边与直角边的交点
    for (int j = 0; j < n; j++) {
        if (i == j) continue;
        int cross_y = tri[i].y + (tri[i].x + tri[i].m - tri[j].x);
        if (cross_y > tri[i].y && cross_y < tri[i].y + tri[i].m) {
            y_vals.push_back(cross_y);
        }
    }
}
sort(y_vals.begin(), y_vals.end());
y_vals.erase(unique(y_vals.begin(), y_vals.end()), y_vals.end());
```

#### **扫描线覆盖计算**
```cpp
double total_area = 0, prev_len = 0;
for (int i = 1; i < y_vals.size(); i++) {
    double y_curr = y_vals[i], y_prev = y_vals[i-1];
    double delta_y = y_curr - y_prev;
    // 计算当前扫描线覆盖长度
    vector<pair<int, int>> intervals;
    for (auto& tri : active_tris) {
        if (tri.y > y_prev || tri.y + tri.m < y_prev) continue;
        int x_start = tri.x;
        int x_end = tri.x + (tri.m - (y_prev - tri.y));
        intervals.emplace_back(x_start, x_end);
    }
    // 合并区间
    sort(intervals.begin(), intervals.end());
    double curr_len = 0, last_r = -INF;
    for (auto& [l, r] : intervals) {
        if (l > last_r) {
            curr_len += r - l;
            last_r = r;
        } else if (r > last_r) {
            curr_len += r - last_r;
            last_r = r;
        }
    }
    // 累加梯形面积
    total_area += (prev_len + curr_len) * delta_y / 2;
    prev_len = curr_len;
}
```

---

### 复古游戏化代码片段（Canvas动画）

#### **扫描线移动与覆盖绘制**
```javascript
function drawScanLine(y) {
    ctx.fillStyle = "#FF0000";
    ctx.fillRect(0, y, canvas.width, 1); // 扫描线
    intervals.forEach(([l, r]) => {
        ctx.fillStyle = "#FFFF00";
        ctx.fillRect(l, y - 2, r - l, 5); // 覆盖区间高亮
    });
    // 触发音效
    if (audioCtx) {
        const osc = audioCtx.createOscillator();
        osc.frequency.setValueAtTime(440, audioCtx.currentTime);
        osc.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    }
}
```

---
处理用时：87.60秒
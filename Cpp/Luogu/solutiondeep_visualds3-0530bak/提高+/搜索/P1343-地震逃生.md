# 题目信息

# 地震逃生

## 题目描述

汶川地震发生时，四川\*\*中学正在上课，一看地震发生，老师们立刻带领 $x$ 名学生逃跑，整个学校可以抽象地看成一个有向图，图中有 $n$ 个点，$m$ 条边。$1$ 号点为教室，$n$ 号点为安全地带，每条边都只能容纳一定量的学生，超过楼就要倒塌，由于人数太多，校长决定让同学们分成几批逃生，只有第一批学生全部逃生完毕后，第二批学生才能从 $1$ 号点出发逃生，现在请你帮校长算算，每批最多能运出多少个学生，$x$ 名学生分几批才能运完。

## 说明/提示

**【注释】**

比如有图

```plain
1 2 100
2 3 1
```

$100$ 个学生先冲到 $2$ 号点，然后一个一个慢慢沿 $2 \to 3$ 边走过去。

18 神牛规定这样是不可以的……

也就是说，每批学生必须同时从起点出发，并且同时到达终点。

**【数据范围】**

对于 $100 \%$ 的数据，$0 \le x < 2^{31}$，$1 \le n \le 200$，$1 \le m \le 2000$。

## 样例 #1

### 输入

```
6 7 7
1 2 1
1 4 2
2 3 1
4 5 1
4 3 1
3 6 2
5 6 1
```

### 输出

```
3 3
```

# AI分析结果



# 算法分类：其他搜索（网络流最大流）

---

## 题解思路、算法要点与解决难点

### 核心逻辑
本题核心是求 **有向图的最大流**，最大流值即为每批最多能逃生的学生数。网络流算法通过 BFS/DFS 模拟水流在多条路径中的流动过程，最终统计总流量。

### 解决难点
1. **分层图构建**（Dinic算法）：通过 BFS 构建层次网络，确保 DFS 只在同层或下层节点间增广。
2. **多路增广优化**：在 DFS 中允许同时探索多条路径，减少重复计算。
3. **反向边处理**：反向边容量初始化为0，正向边容量减少时反向边增加，实现流量回退。

---

## 题解评分（≥4星）

### 1. 作者：lgswdn_SA（5星）
- **思路清晰度**：详细解释 Dinic 算法流程，注释完整。
- **代码可读性**：结构简洁，变量命名合理，反向边处理直观。
- **算法优化**：采用 BFS 分层 + DFS 多路增广，效率较高。

### 2. 作者：_Fontainebleau_（4星）
- **思路清晰度**：对比 ISAP 和 EK 算法，适合进阶学习。
- **代码可读性**：ISAP 实现完整，但代码较长。
- **优化程度**：ISAP 算法复杂度更优（单次 BFS 预处理）。

### 3. 作者：苏幕寒（4星）
- **思路清晰度**：代码简短，适合快速理解 Dinic 核心逻辑。
- **实践操作性**：无冗余代码，直接调用 `bfs` 和 `dfs` 函数。

---

## 最优思路与技巧提炼

### 关键代码片段（Dinic算法核心）
```cpp
bool bfs() {
    memset(dis, -1, sizeof(dis));
    queue<int> q;
    q.push(1); dis[1] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (dis[v] == -1 && e[i].w > 0) {
                dis[v] = dis[u] + 1;
                q.push(v);
                if (v == n) return true;
            }
        }
    }
    return false;
}

int dfs(int u, int flow) {
    if (u == n) return flow;
    int rest = flow;
    for (int i = head[u]; i && rest; i = e[i].nxt) {
        int v = e[i].to;
        if (e[i].w && dis[v] == dis[u] + 1) {
            int tmp = dfs(v, min(rest, e[i].w));
            if (!tmp) dis[v] = -1;
            rest -= tmp;
            e[i].w -= tmp;
            e[i^1].w += tmp;
        }
    }
    return flow - rest;
}
```

### 技巧总结
- **分层网络加速**：BFS 预处理确保每次增广沿最短路径进行。
- **多路增广**：DFS 中允许同时处理多条分支，减少递归深度。
- **反向边优化**：利用异或操作快速定位反向边（如 `e[i^1]`）。

---

## 同类型题与算法套路

### 通用解法
- **最大流问题**：所有边权为容量的网络流均可套用 Dinic/ISAP。
- **分层图思想**：类似 BFS 最短路径，用于限制搜索方向。

### 推荐题目
1. **P3376**：网络最大流模板题。
2. **P2740**：草地排水（最大流基础变形）。
3. **P2763**：试题库问题（多源汇最大流）。

---

## 可视化与算法演示

### 动画方案设计
1. **分层网络构建**：BFS 过程中用不同颜色标记层次（如红→橙→黄）。
2. **增广路径追踪**：DFS 访问节点时高亮显示，流量更新时闪烁对应边。
3. **反向边动态更新**：正向边减少时，反向边同步增加并显示数值变化。

### 复古像素风格实现
- **颜色方案**：节点用 8 位色块（绿：未访问，蓝：已访问，红：当前节点）。
- **音效设计**：访问节点时播放“哔”声，找到增广路时播放“叮”声。
- **Canvas 绘制**：节点呈网格排列，边用箭头表示，流量数值显示在箭头旁。

---

## 个人心得摘录

> **作者：_louhc**  
> “反向边的流量值=正向流过的总流量，最大流的精髓就在反向边。”  
> —— 反向边是实现流量回退的关键，需深入理解其物理意义。

---

## 核心搜索过程演示（伪代码）

```javascript
// 模拟 Dinic 的分层与增广
function visualizeDinic() {
    let layers = bfsLayers(); // BFS 分层
    while (layers.exists) {
        let path = dfsFindPath(layers); // DFS 找增广路
        updateFlows(path); // 更新正向/反向边
        draw.update(); // 刷新 Canvas
        playSound('flow_update'); // 播放音效
    }
}
```

---
处理用时：83.44秒
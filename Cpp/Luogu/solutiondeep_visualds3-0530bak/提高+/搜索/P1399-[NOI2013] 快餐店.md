# 题目信息

# [NOI2013] 快餐店

## 题目描述

小 T 打算在城市 C 开设一家外送快餐店。送餐到某一个地点的时间与外卖店到该地点之间最短路径长度是成正比的，小 T 希望快餐店的地址选在离最远的顾客距离最近的地方。

快餐店的顾客分布在城市 C 的 $N$ 个建筑中，这 $N$ 个建筑通过恰好 $N$ 条双向道路连接起来，不存在任何两条道路连接了相同的两个建筑。任意两个建筑之间至少存在一条由双向道路连接而成的路径。小 T 的快餐店可以开设在任一建筑中，也可以开设在任意一条道路的某个位置上（该位置与道路两端的建筑的距离不一定是整数）。

现给定城市 C 的地图（道路分布及其长度），请找出最佳的快餐店选址，输出其与最远的顾客之间的距离。

## 说明/提示

### 样例解释 1

![](https://cdn.luogu.com.cn/upload/image_hosting/r0dmxcgy.png)

### 样例解释 2

![](https://cdn.luogu.com.cn/upload/image_hosting/pf8eaowl.png)

### 数据范围

- 对于 $10\%$ 的数据，$N\leq 80$，$L_i=1$；
- 对于 $30\%$ 的数据，$N\leq 600$，$L_i\leq 100$；
- 对于 $60\%$ 的数据，$N\leq 2000$，$L_i\leq 10^9$；
- 对于 $100\%$ 的数据，$1\leq N\leq 10^5$，$1\leq L_i \leq 10^9$。

## 样例 #1

### 输入

```
4 
1 2 1 
1 4 2 
1 3 2 
2 4 1
```

### 输出

```
2.0 ```

## 样例 #2

### 输入

```
5
1 5 100
2 1 77
3 2 80
4 1 64
5 3 41```

### 输出

```
109.0```

# AI分析结果



## 算法分类：DFS（找环） + 动态规划（处理环）

---

### **题解思路与核心难点**
1. **基环树特性**  
   - 基环树由环与若干子树构成，直径可能位于子树或经过环。
   - **关键难点**：高效计算环上断边后的最长路径。

2. **DFS找环**  
   - 使用DFS遍历节点，回溯标记环上的点（如 `find_circle` 函数）。
   - **解决难点**：DFS过程中维护路径栈，遇到已访问节点时提取环结构。

3. **子树直径计算**  
   - 对每个环上节点进行子树DFS，记录最大深度 `dp[u]` 和子树直径 `ans`。
   - **优化点**：通过动态规划避免重复遍历子树。

4. **环上路径优化**  
   - 预处理前缀 `pre` 和后缀 `bck` 数组，记录环上各点的最大链长。
   - **滑动窗口技巧**：将环拆成链后，枚举断边时用前缀后缀快速计算最大路径。

---

### **精选题解（≥4星）**
1. **作者：_LAUV_（4.5星）**  
   - **亮点**：代码简洁，使用前缀/后缀数组优化环上断边枚举，清晰展示基环树处理步骤。
   - **核心代码**：
     ```cpp
     For(i,1,tot-1){
         Db mx1 = max(bs1[i], bs2[i+1]);
         Db mx2 = max(mx1, pre[i] + bck[i+1] + crD[0]);
         Fn = min(Fn, max(mx1, mx2));
     }
     ```

2. **作者：Mr_cold（4星）**  
   - **亮点**：详细解释两种直径情况（经过环与不经过环），预处理前缀后缀最大值。
   - **关键步骤**：构建 `A/B/C/D` 数组优化断边后的路径计算。

3. **作者：Piwry（4星）**  
   - **亮点**：严格数学证明将问题转化为生成树枚举，滑动窗口维护 `f/g` 数组处理断环后的最大路径。

---

### **最优思路提炼**
1. **断环为链**：将基环树的环拆成链并复制一份，避免处理环的闭合性。
2. **前缀/后缀数组**：预处理环上各点的子树深度与链长，快速计算断边后的候选路径。
3. **动态规划优化**：维护 `pre[i] = max(pre[i-1], sum + dp[i])` 和类似结构，避免重复计算。

---

### **同类型题目推荐**
1. **P2607 [ZJOI2008] 骑士**：基环树上的最大权独立集问题。
2. **CF835F Roads in the Kingdom**：基环树删边后最小化直径。
3. **P4381 [IOI2008] Island**：求基环森林中各基环树直径之和。

---

### **可视化与算法演示**
1. **DFS找环动画**  
   - **像素风格**：节点显示为8位像素块，当前DFS路径用绿色标记，发现环时红色高亮。
   - **音效**：发现环时播放“成功”音效，节点访问时伴随滴答声。

2. **环上断边模拟**  
   - **Canvas动态绘制**：环显示为圆形，断边时显示候选路径（蓝色为子树路径，红色为环上路径）。
   - **步进控制**：用户可手动点击断边位置，观察前缀/后缀数组如何更新最大路径。

3. **复古游戏化设计**  
   - **关卡模式**：将不同基环树作为关卡，玩家需选择断边位置最小化直径得分。
   - **积分系统**：快速找到最优断边获得连击奖励，失败时播放8位风格“Game Over”音效。

---

### **核心代码片段（DFS找环 + 预处理）**
```cpp
// DFS找环并记录路径
bool find(int u, int fa) {
    if (vis[u]) {
        while (stk.top() != u) {
            ring.push_back(stk.top());
            stk.pop();
        }
        ring.push_back(u);
        return true;
    }
    vis[u] = 1; stk.push(u);
    for (auto [v, w] : G[u]) {
        if (v == fa) continue;
        if (find(v, u)) return true;
    }
    stk.pop(); vis[u] = 0;
    return false;
}

// 预处理环上路径前缀最大值
void preprocess() {
    ll sum = 0, mx = 0;
    for (int i = 0; i < 2 * n; i++) {
        int u = ring[i % n];
        sum += (i ? len[i-1] : 0);
        pre_max[i] = max(pre_max[i-1], dp[u] + sum);
        mx = max(mx, dp[u] - sum);
        pre_chain[i] = mx;
    }
}
```

---

**总结**：基环树问题需结合DFS找环与动态规划优化，核心在于高效处理环上路径。通过前缀/后缀数组和滑动窗口技巧，可将复杂度降至线性。

---
处理用时：87.20秒
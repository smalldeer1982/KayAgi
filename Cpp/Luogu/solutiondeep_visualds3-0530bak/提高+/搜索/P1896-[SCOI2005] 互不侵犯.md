# 题目信息

# [SCOI2005] 互不侵犯

## 题目描述

在 $N \times N$ 的棋盘里面放 $K$ 个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 $8$ 个格子。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 9$，$0 \le K \le N\times N$。

---

$\text{upd 2018.4.25}$：数据有加强。

## 样例 #1

### 输入

```
3 2
```

### 输出

```
16
```

# AI分析结果



### 算法分类  
**状态压缩动态规划 (状压DP)**

---

### 题解思路与难点分析  
**核心思路**  
1. **状态压缩**：用二进制数表示每行的国王放置状态（1为放置，0为空），预处理合法行状态（无相邻国王）。  
2. **动态规划**：定义 `dp[i][j][k]` 表示前 `i` 行，第 `i` 行状态为 `j`，共放置 `k` 个国王的方案数。  
3. **位运算优化**：通过按位与、左移/右移操作快速判断行间冲突。  

**解决难点**  
1. **合法状态筛选**：通过位运算 `x & (x << 1)` 检查同一行是否合法。  
2. **行间冲突检测**：两行状态需满足：  
   - 上下无冲突：`j & k == 0`  
   - 斜方向无冲突：`(j << 1) & k == 0` 和 `(j >> 1) & k == 0`  
3. **国王数量统计**：预处理每个状态的国王数，避免重复计算。  

---

### 题解评分（≥4星）  
1. **KesdiaelKen（⭐⭐⭐⭐⭐）**  
   - 思路清晰，详细解释状压DP原理与位运算技巧。  
   - 提供完整代码，预处理合法状态并优化转移过程。  
2. **暗ざ之殇（⭐⭐⭐⭐⭐）**  
   - 图文结合，用棋盘图示解释国王攻击范围。  
   - 代码注释详尽，适合新手理解位运算逻辑。  
3. **p_b_p_b（⭐⭐⭐⭐）**  
   - 引入轮廓线DP思路，提供不同视角的解法。  
   - 代码简洁但需要一定背景知识。  

---

### 最优思路与技巧提炼  
1. **预处理合法状态**  
   - 生成所有单行合法状态，并记录每个状态的国王数。  
   - 示例代码：  
     ```cpp  
     void dfs(int sum, int tot, int node) {  
         if (node >= n) {  
             sit[++cnt] = sum;  
             gs[cnt] = tot;  
             return;  
         }  
         dfs(sum, tot, node + 1);          // 不放置  
         dfs(sum + (1 << node), tot + 1, node + 2); // 放置并跳过下一列  
     }  
     ```  
2. **位运算快速冲突检测**  
   - 检查两行状态是否冲突：  
     ```cpp  
     if (sit[j] & sit[k]) continue;  
     if ((sit[j] << 1) & sit[k]) continue;  
     if (sit[j] & (sit[k] << 1)) continue;  
     ```  
3. **动态规划状态转移**  
   - 逐行枚举状态，累加合法方案数：  
     ```cpp  
     for (int i = 2; i <= n; i++)  
         for (int j = 1; j <= cnt; j++)  
             for (int k = 1; k <= cnt; k++)  
                 if (/* 状态合法 */)  
                     dp[i][j][k] += dp[i-1][k][k - gs[j]];  
     ```  

---

### 类似题目推荐  
1. **P1879 [USACO06NOV] Corn Fields**（状压DP基础）  
2. **P2704 [NOI2001] 炮兵阵地**（扩展攻击范围的高阶状压）  
3. **P2592 [ZJOI2008] 生日聚会**（多维状态压缩）  

---

### 可视化设计思路  
**动画演示：**  
1. **棋盘绘制**：用Canvas绘制N×N网格，每个格子显示二进制状态（1为国王，0为空）。  
2. **状态转移高亮**：  
   - 当前行状态用绿色边框标记。  
   - 冲突检测时，红色闪烁非法格子。  
3. **位运算过程**：  
   - 动态展示左移/右移后的掩码与按位与操作。  
4. **复古像素风格**：  
   - 8位音效：放置国王时播放“哔”声，冲突时播放“错误”音效。  
   - 背景音乐循环播放FC风格BGM。  

**交互控制：**  
- **步进执行**：手动控制每一步状态转移。  
- **自动播放**：按预设速度展示完整搜索过程。  

---

### 核心代码片段  
**预处理合法状态与动态规划：**  
```cpp  
// 预处理合法状态  
void dfs(int sum, int tot, int node) {  
    if (node >= n) {  
        sit[++cnt] = sum;  
        gs[cnt] = tot;  
        return;  
    }  
    dfs(sum, tot, node + 1);  
    dfs(sum + (1 << node), tot + 1, node + 2);  
}  

// 动态规划转移  
for (int i = 2; i <= n; i++) {  
    for (int j = 1; j <= cnt; j++) {  
        for (int k = 1; k <= cnt; k++) {  
            if ((sit[j] & sit[k]) || ((sit[j] << 1) & sit[k]) || (sit[j] & (sit[k] << 1)))  
                continue;  
            for (int s = gs[j]; s <= K; s++)  
                dp[i][j][s] += dp[i-1][k][s - gs[j]];  
        }  
    }  
}  
```  

**完整代码参考KesdiaelKen的题解实现。**

---
处理用时：89.53秒
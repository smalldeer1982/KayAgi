# 题目信息

# [NOIP 2014 普及组] 子矩阵

## 题目背景

NOIP2014 普及组 T4

## 题目描述

给出如下定义：

1. 子矩阵：从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵（保持行与列的相对顺序）被称为原矩阵的一个子矩阵。

    例如，下面图中选取第 $2,4$ 行和第 $2,4,5$ 列交叉位置的元素得到一个 $2 \times 3$ 的子矩阵如下所示。

|$9$|$\color{#6a5acd}3$|$3$|$\color{#6a5acd}3$|$\color{#6a5acd}9$|
|:-|:-|:-|:-|:-|
|$\color{#6a5acd}9$|$\color{blue}4$|$\color{#6a5acd}8$|$\color{blue}7$|$\color{blue}4$|
|$1$|$\color{#6a5acd}7$|$4$|$\color{#6a5acd}6$|$\color{#6a5acd}6$|
|$\color{#6a5acd}6$|$\color{blue}8$|$\color{#6a5acd}5$|$\color{blue}6$|$\color{blue}9$|
|$7$|$\color{#6a5acd}4$|$5$|$\color{#6a5acd}6$|$\color{#6a5acd}1$|

此矩阵的其中一个 $2\times3$ 的子矩阵是：

|$4$|$7$|$4$|
|:-|:-|:-|
|$8$|$6$|$9$|

2. 相邻的元素：矩阵中的某个元素与其上下左右四个元素（如果存在的话）是相邻的。

3. 矩阵的分值：矩阵中每一对相邻元素之差的绝对值之和。

本题任务：给定一个 $n$ 行 $m$ 列的正整数矩阵，请你从这个矩阵中选出一个 $r$ 行 $c$ 列的子矩阵，使得这个子矩阵的分值最小，并输出这个分值。

## 说明/提示

#### 样例 1 说明

该矩阵中分值最小的 $2$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行与第 $1$ 列、第 $3$ 列、第 $4$ 列交叉位置的元素组成，为：

|$6$|$5$|$6$|
|:-|:-|:-|
|$7$|$5$|$6$|

其分值为 $|6-5|+|5-6|+|7-5|+|5-6|+|6-7|+|5-5|+|6-6|=6$。

#### 样例 2 说明

该矩阵中分值最小的 $3$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行、第 $6$ 行与第 $2$ 列、第 $6$ 列、第 $7$ 列交叉位置的元素组成，选取的分值最小的子矩阵为：

|$9$|$7$|$8$|
|:-|:-|:-|
|$9$|$8$|$8$|
|$5$|$8$|$10$|

#### 数据范围

- 对于 $50\%$ 的数据，$1\leq n\leq 12$，$1\leq m\leq 12$，矩阵中的每个元素 $1\leq a_{i,j}\leq20$；

- 对于 $100\%$ 的数据，$1\leq n\leq 16$，$1\leq m\leq 16$，矩阵中的每个元素 $1\leq a_{i,j}\leq 1000$，$1\leq r\leq n$，$1\leq c\leq m$。

## 样例 #1

### 输入

```
5 5 2 3
9 3 3 3 9
9 4 8 7 4
1 7 4 6 6
6 8 5 6 9
7 4 5 6 1```

### 输出

```
6```

## 样例 #2

### 输入

```
7 7 3 3  
7 7 7 6 2 10 5
5 8 8 2 1 6 2 
2 9 5 5 6 1 7 
7 9 3 6 1 7 8 
1 9 1 4 7 8 8 
10 5 9 1 1 8 10
1 3 1 5 4 8 6```

### 输出

```
16```

# AI分析结果



**唯一算法分类**: 其他搜索

---

### 综合分析与结论

#### 核心思路与难点
题目需要在矩阵中选择特定行和列，使相邻元素差的绝对值之和最小。核心难点在于如何高效处理组合爆炸问题（行+列双重组合）。各题解通过以下方式突破：
1. **行/列分离处理**：将问题分解为行选择与列选择两个阶段，用DFS/二进制枚举处理一个维度，用动态规划处理另一个维度。
2. **差值预处理**：预先计算行间纵向差值（同列不同行）和列间横向差值（同行不同列），避免重复计算。
3. **剪枝优化**：在DFS中实时维护当前分值，若超过已找到的最优解则提前终止。
4. **动态规划状态设计**：如`dp[i][j]`表示前i列选j列的最小分值，通过状态转移避免重复遍历。

#### 可视化设计思路
**搜索过程动画方案**：
1. **像素风格网格**：用16x16网格表示原矩阵，选中行列以高亮边框显示。
2. **搜索步骤演示**：
   - **行枚举阶段**：DFS选择行时，用闪烁效果显示当前尝试的行。
   - **差值预处理**：用流动线条动画展示行间/列间差值的计算过程。
   - **动态规划过程**：在选中行的子矩阵底部显示`dp[i][j]`状态表，实时更新最小值。
3. **音效触发**：
   - 选中行/列时播放短促“滴”声。
   - 发现更优解时播放上扬音效。
   - 剪枝发生时播放低音提示。

---

### 题解清单（评分≥4星）

1. **panyf（★★★★☆）**
   - **关键亮点**：DFS双维度搜索+预处理差值，通过回溯剪枝实现高效枚举。
   - **代码片段**：
     ```cpp
     void dfsl(ci&x,ci&y,ci&z){
         if(y==c){ s=z; return; } // 剪枝：zz>=s时跳过
         for(int i=x+1; i<en; ++i){
             zz = z + p[i] + w[x][i]; // 预计算横向+纵向差值
             if(zz < s) dfsl(i,y+1,zz);
         }
     }
     ```

2. **RikoHere（★★★★☆）**
   - **关键亮点**：列组合DFS+行间DP，预处理行差加速状态转移。
   - **状态转移**：
     ```cpp
     for(int k = j-1; k < i; k++)
         f[i][j] = min(f[i][j], f[k][j-1] + sum[k][i]);
     ```

3. **Ian_NIE（★★★★☆）**
   - **关键亮点**：行组合DFS+列DP，用`cal(i,k)`动态计算跨列差值。
   - **DP初始化**：
     ```cpp
     for(int i=1; i<=m; i++) 
         f[i][1] = 纵向差值累加;
     ```

---

### 最优思路提炼

1. **组合分解策略**：
   - 将行、列选择分离处理，用搜索处理一个维度，DP处理另一个维度。
   - 例：DFS枚举行 → DP优化列选择。

2. **差值预计算**：
   ```cpp
   // 纵向差值（行间）
   g[i][j][k] = abs(v[i][k]-v[j][k]); 
   // 横向差值（列间） 
   h[i][j][k] = abs(v[k][i]-v[k][j]);
   ```

3. **状态压缩DP**：
   - 状态定义：`dp[i][j]`表示前i列选j列的最小分值。
   - 转移方程：`dp[i][j] = min(dp[k][j-1] + 跨列差值)`

---

### 相似题目推荐

1. **P1433 吃奶酪** - 二维坐标点的组合选择，需处理距离计算。
2. **P2329 栅栏** - 组合选择+剪枝优化，类似矩阵选取思维。
3. **P1074 靶形数独** - 双重维度搜索（行+列）与启发式剪枝。

---

### 核心代码实现（以panyf优化版为例）

```cpp
int g[17][17][17], h[17][17][17], w[17][17], p[17], e[17], s=1e9;

void dfsl(int x, int y, int z) {
    if(y == c) { s = min(s, z); return; }
    for(int i=x+1; i <= m-c+y+1; ++i) {
        int zz = z + p[i] + (x ? w[x][i] : 0);
        if(zz < s) dfsl(i, y+1, zz);
    }
}

void dfsh(int x, int y) {
    if(y == r) { dfsl(0, 0, 0); return; }
    for(int i=x+1; i <= n-r+y+1; ++i) {
        // 更新列间差值
        if(x) for(int j=1; j<=m; ++j) p[j] += g[x][i][j];
        // 更新行内差值
        for(int j=1; j<m; ++j)
            for(int k=j+1; k<=m; ++k)
                w[j][k] += h[j][k][i];
        
        dfsh(i, y+1);
        
        // 回溯
        if(x) for(int j=1; j<=m; ++j) p[j] -= g[x][i][j];
        for(int j=1; j<m; ++j)
            for(int k=j+1; k<=m; ++k)
                w[j][k] -= h[j][k][i];
    }
}
```

---

### 可视化实现要点（JavaScript伪代码）

```javascript
// 初始化Canvas
const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d');

// 绘制矩阵
function drawMatrix(rows, cols) {
    for(let i=0; i<rows; i++) {
        for(let j=0; j<cols; j++) {
            ctx.fillStyle = isSelected(i,j) ? '#FFD700' : '#FFF';
            ctx.fillRect(j*30, i*30, 28, 28);
        }
    }
}

// DFS动画模拟
function animateDFS(step) {
    let current = steps[step];
    highlightCell(current.row, current.col); // 高亮当前选择
    if(step < steps.length-1) 
        setTimeout(() => animateDFS(step+1), 500);
}
```

---
处理用时：102.80秒
# 题目信息

# hzwer 爱折纸

## 题目描述

hzwer 买到了一张神奇的小纸条，初始时它由 $N$ 个格子组成，每个格子上面有一个整数 $N_i$，显然每两个相邻的格子之间有一条分界线，hzwer 可以选择任意一条分界线，将整张纸条进行向左翻折，如果翻折后有两个格子重叠，那么翻折后的格子上数字为原两个格子数字之和，否则数字保持不变。hzwer 也可以将整张纸条进行向左翻转，翻转之后第 $i$ 个格子的数字变成第 $N - i + 1$ 个格子的数字。

![](https://cdn.luogu.com.cn/upload/pic/2350.png)

![](https://cdn.luogu.com.cn/upload/pic/2351.png)


## 说明/提示

对于 $70 \%$ 的数据，$N \le 10$。  
对于 $100 \%$ 的数据，$1 \le N \le 15$。

## 样例 #1

### 输入

```
7
5 6 23 8 19 7 10
4
5 16 30 27
7
1 2 3 4 5 6 7
5
7 6 5 5 5
4
1 2 3 4
1
10
6
19 23 3 51 2 0
2
34 64```

### 输出

```
S
S
S
N```

# AI分析结果



# 【hzwer 爱折纸】题解分析

## 算法分类
**DFS**

---

## 题解思路与算法要点

### 核心思路
所有题解均基于 **DFS 暴力搜索**，枚举所有可能的翻折操作，通过剪枝和状态判重优化效率。核心难点在于：
1. **状态表示**：使用数组或 `vector` 存储当前纸条序列。
2. **翻折操作模拟**：分翻折线在前半段或后半段处理重叠求和。
3. **目标匹配判断**：需同时判断正序和逆序是否与目标匹配。
4. **剪枝策略**：长度不足时跳过、总和提前判否、对称性优化。

### 解决难点对比
| 题解作者           | 状态判重方法         | 剪枝策略                          | 翻折处理优化              |
|--------------------|----------------------|-----------------------------------|---------------------------|
| Yy666_l            | `map<vector>`        | 无额外剪枝                        | 分前半段和后半段处理      |
| Dangerou           | 无                   | 长度不足剪枝、对称性优化          | 分前半段和后半段处理      |
| Xu_brezza          | 无                   | 仅枚举后半段翻折线（对称性优化）  | 直接操作数组              |
| ZinfI_Sh           | 无                   | 长度不足剪枝                      | 统一公式计算贡献          |

---

## 题解评分（≥4星）

### 1. Dangerou（4.5星）
- **亮点**：对称性优化剪枝（仅枚举后半段翻折线），代码可读性高。
- **代码片段**：
  ```cpp
  if (i <= len/2) { /* 前半段翻折处理 */ }
  else { /* 后半段翻折处理 */ }
  ans |= dfs(max(i, len-i), d); // 剪枝：长度不足时跳过
  ```

### 2. Yy666_l（4星）
- **亮点**：使用 `map<vector>` 判重避免重复搜索，代码简洁。
- **代码片段**：
  ```cpp
  map<vector<int>, bool> ma; // 判重核心
  void dfs(vector<int> V) {
    if (ma.count(V)) return;
    ma[V] = 1;
    // ... 搜索逻辑
  }
  ```

### 3. Xu_brezza（4星）
- **亮点**：对称性优化（仅枚举后半段翻折线），降低复杂度。
- **代码片段**：
  ```cpp
  for (int i = s; i < len; ++i) { // 仅枚举后半段
    // 翻折处理...
  }
  ```

---

## 最优思路提炼
1. **对称性剪枝**：翻折后半段等价于先翻转再翻折前半段，减少枚举次数。
2. **状态哈希判重**：使用 `map` 或 `unordered_map` 存储已搜索的序列。
3. **提前求和判否**：初始与目标总和不等时直接返回 `N`。
4. **正逆序双判**：最终状态需同时匹配目标的正序和逆序。

---

## 同类型题与算法套路
- **通用解法**：状态空间搜索（BFS/DFS）+ 剪枝，适用于八数码、拼图等问题。
- **类似题目**：
  1. [P1379 八数码问题](https://www.luogu.com.cn/problem/P1379)（BFS + 康托展开判重）
  2. [P2324 骑士精神](https://www.luogu.com.cn/problem/P2324)（IDA* 优化搜索）
  3. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)（DFS + 优先级剪枝）

---

## 个人心得摘录
- **Dangerou**：`数组 d 必须开在函数内部`，全局变量导致 WA。
- **ZinfI_Sh**：逆序判断时误用 `ans2[m-i+1]`，修正为 `ans2[i]` 后 AC。
- **LJ07**：`回溯数组需在递归内部定义`，避免状态污染。

---

## 可视化算法演示设计

### 动画方案
1. **像素风格界面**：
   - **网格绘制**：每个格子用 16x16 像素块表示，颜色区分数值大小。
   - **翻折高亮**：当前翻折线用红色闪烁，合并格子显示黄色光效。
   ```javascript
   function drawGrid(ctx, data) {
     data.forEach((val, i) => {
       ctx.fillStyle = getColor(val); // 根据数值映射颜色
       ctx.fillRect(i * 20, 0, 18, 18);
     });
   }
   ```

2. **搜索过程演示**：
   - **当前状态**：绿色边框标记。
   - **访问顺序**：DFS 栈用 LIFO 动画展示，BFS 队列用 FIFO 滚动显示。
   - **音效**：翻折时播放“哔”声，匹配成功时播放“胜利”音效。

3. **交互控制**：
   - **速度调节**：滑动条控制动画速度（0.5x~5x）。
   - **步进模式**：按空格键单步执行搜索。
   ```html
   <input type="range" id="speed" min="0.5" max="5" step="0.5">
   <button onclick="pauseResume()">暂停/继续</button>
   ```

### 复古游戏化设计
- **8-bit 音效**：使用 Web Audio API 合成芯片音乐。
  ```javascript
  function playBeep() {
    const osc = audioCtx.createOscillator();
    osc.type = 'square';
    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
  }
  ```
- **积分系统**：每完成一次有效翻折+10分，找到解+100分。

---

## 核心代码片段（DFS + 剪枝）
```cpp
bool dfs(int len, int arr[]) {
  if (len == m) {
    bool f1 = 1, f2 = 1;
    for (int i=1; i<=m; i++) {
      if (arr[i] != b[i]) f1 = 0;
      if (arr[i] != b[m-i+1]) f2 = 0;
    }
    return f1 || f2;
  }
  int tmp[20];
  for (int i=1; i<len; i++) {
    if (max(i, len-i) < m) continue; // 剪枝：翻折后长度不足
    // 翻折处理生成 tmp...
    if (dfs(new_len, tmp)) return 1;
  }
  return 0;
}
```

---

通过上述分析，可全面掌握本题的搜索策略与优化技巧，并将其应用于类似问题的求解中。

---
处理用时：103.65秒
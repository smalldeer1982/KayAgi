# 题目信息

# [NOIP 2016 提高组] 愤怒的小鸟

## 题目背景

NOIP2016 提高组 D2T3

## 题目描述

Kiana 最近沉迷于一款神奇的游戏无法自拔。

简单来说，这款游戏是在一个平面上进行的。

有一架弹弓位于 $(0,0)$ 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $y=ax^2+bx$ 的曲线，其中 $a,b$ 是 Kiana 指定的参数，且必须满足 $a < 0$，$a,b$ 都是实数。

当小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。

在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小猪，其中第 $i$ 只小猪所在的坐标为 $\left(x_i,y_i \right)$。

如果某只小鸟的飞行轨迹经过了 $\left( x_i, y_i \right)$，那么第 $i$ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；

如果一只小鸟的飞行轨迹没有经过 $\left( x_i, y_i \right)$，那么这只小鸟飞行的全过程就不会对第 $i$ 只小猪产生任何影响。

例如，若两只小猪分别位于 $(1,3)$ 和 $(3,3)$，Kiana 可以选择发射一只飞行轨迹为 $y=-x^2+4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。

而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。

这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。

假设这款游戏一共有 $T$ 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。

## 说明/提示

【样例解释1】

这组数据中一共有两个关卡。

第一个关卡与【问题描述】中的情形相同，$2$ 只小猪分别位于 $(1.00,3.00)$ 和 $(3.00,3.00)$，只需发射一只飞行轨迹为 $y = -x^2 + 4x$ 的小鸟即可消灭它们。

第二个关卡中有 $5$ 只小猪，但经过观察我们可以发现它们的坐标都在抛物线 $y = -x^2 + 6x$上，故 Kiana 只需要发射一只小鸟即可消灭所有小猪。

【数据范围】

| 测试点编号 |   $n\leqslant$ |   $m=$ |  $T\leqslant$ |
| :----------: | :----------: | :----------: | :----------: |
|   $1$ |   $2$ |   $0$ |  $10$ |
|   $2$ |   $2$ |   $0$ |  $30$ |
|   $3$ |   $3$ |   $0$ |  $10$ |
|   $4$ |   $3$ |   $0$ |  $30$ |
|   $5$ |   $4$ |   $0$ |  $10$ |
|   $6$ |   $4$ |   $0$ |  $30$ |
|   $7$ |   $5$ |   $0$ |  $10$ |
|   $8$ |   $6$ |   $0$ |  $10$ |
|   $9$ |   $7$ |   $0$ |  $10$ |
|   $10$ |   $8$ |   $0$ |  $10$ |
|   $11$ |   $9$ |   $0$ |  $30$ |
|   $12$ |   $10$ |   $0$ |  $30$ |
|   $13$ |   $12$ |   $1$ |  $30$ |
|   $14$ |   $12$ |   $2$ |  $30$ |
|   $15$ |   $15$ |   $0$ |  $15$ |
|   $16$ |   $15$ |   $1$ |  $15$ |
|   $17$ |   $15$ |   $2$ |  $15$ |
|   $18$ |   $18$ |   $0$ |  $5$ |
|   $19$ |   $18$ |   $1$ |  $5$ |
|   $20$ |   $18$ |   $2$ |  $5$ |

## 样例 #1

### 输入

```
2
2 0
1.00 3.00
3.00 3.00
5 2
1.00 5.00
2.00 8.00
3.00 9.00
4.00 8.00
5.00 5.00```

### 输出

```
1
1```

## 样例 #2

### 输入

```
3
2 0
1.41 2.00
1.73 3.00
3 0
1.11 1.41
2.34 1.79
2.98 1.49
5 0
2.72 2.72
2.72 3.14
3.14 2.72
3.14 3.14
5.00 5.00```

### 输出

```
2
2
3
```

## 样例 #3

### 输入

```
1
10 0
7.16 6.28
2.02 0.38
8.33 7.78
7.68 2.09
7.46 7.86
5.77 7.44
8.24 6.72
4.42 5.11
5.42 7.79
8.15 4.99```

### 输出

```
6
```

# AI分析结果



# 算法分类：其他搜索（状压DP为主）

## 题解思路与核心难点

### 核心思路
题目要求用最少的抛物线覆盖所有小猪，核心解法为**状态压缩动态规划（状压DP）**，通过二进制状态表示已消灭的小猪集合。关键步骤如下：
1. **抛物线预处理**：枚举所有可能的两点组合，计算对应的抛物线方程，并记录该抛物线能覆盖的小猪集合。
2. **状态转移优化**：转移时优先处理当前未覆盖的最小序号小猪，确保每次转移必须包含该小猪，从而减少无效搜索。
3. **动态规划**：用 `dp[S]` 表示状态 `S` 的最优解，通过枚举合法抛物线进行状态更新。

### 解决难点
1. **抛物线去重与精度处理**：浮点数计算需引入误差容忍值（如 `1e-8`），避免误判。
2. **高效状态转移**：通过预处理抛物线集合，将复杂度从 `O(Tn^2 2^n)` 优化至 `O(Tn 2^n)`。
3. **剪枝策略**：优先处理特定未覆盖点，避免重复计算。

---

## 题解评分（≥4星）

### 5星题解
**AThousandSuns（赞1136）**  
- **亮点**：严格 `O(Tn2^n)` 复杂度，预处理 `lowunbit` 优化转移顺序，代码简洁高效。
- **关键代码**：
  ```cpp
  for(int i=0; i<(1<<n); i++) {
    int j = lowunbit[i]; // 必须覆盖的最小未处理点
    dp[i|(1<<(j-1))] = min(dp[i]+1, ...);
    for(int k=1; k<=n; k++) 
        dp[i|lines[j][k]] = min(dp[i]+1, ...);
  }
  ```

### 4星题解
**wzxx（赞497）**  
- **亮点**：DFS搜索 + 剪枝，优先处理未覆盖点，适合理解暴力搜索思路。
- **剪枝**：`u+v >= ans` 提前终止无效分支，实测可通过部分数据。

**ghj1222（赞27）**  
- **亮点**：清晰预处理抛物线集合，代码可读性强，适合入门状压DP。

---

## 最优思路提炼
1. **抛物线覆盖预处理**：对每两点计算抛物线方程，记录覆盖的小猪集合。
2. **状压DP状态转移**：优先处理当前未覆盖的最小点，确保每次转移至少覆盖一个新点。
3. **二进制位运算优化**：通过位运算快速合并状态，提升计算效率。

---

## 同类型题与算法套路
- **覆盖问题**：如旅行商问题（TSP）、关灯问题，均需状态压缩表示覆盖状态。
- **状压DP通用模板**：
  ```cpp
  for(int S=0; S < (1<<n); S++)
    for(int T: valid_transition[S])
      dp[T] = min(dp[T], dp[S] + cost);
  ```

## 推荐题目
1. **P1171** 售货员的难题（旅行商问题）
2. **P1433** 吃奶酪（状压DP + 几何距离）
3. **P2622** 关灯问题II（状态压缩 + 位运算）

---

## 可视化与算法演示
### 核心动画设计
- **Canvas 网格**：以18个像素点代表小猪，绿色表示存活，红色表示被消灭。
- **抛物线绘制**：点击状态位时，动态绘制对应抛物线路径，覆盖的小猪变红。
- **状态转移高亮**：当前处理的二进制位闪烁提示，转移后显示新状态覆盖情况。

### 复古游戏化设计
- **8位音效**：抛物线发射时播放“发射音效”，消灭小猪时播放“爆炸音效”。
- **自动演示模式**：按步展示最优DP转移路径，每步显示覆盖的小猪集合。
- **积分系统**：用最少步骤通关获得更高分，错误转移扣分。

---

## 代码片段（状压DP核心）
```cpp
// 预处理所有合法抛物线
for(int i=1; i<=n; i++) 
  for(int j=i+1; j<=n; j++) {
    double a = (y[i]*x[j] - y[j]*x[i]) / (x[i]*x[j]*(x[i]-x[j]));
    double b = (y[i] - a*x[i]*x[i]) / x[i];
    if(a >= -eps) continue;
    int mask = 0;
    for(int k=1; k<=n; k++)
      if(fabs(a*x[k]*x[k] + b*x[k] - y[k]) < eps) 
        mask |= (1 << (k-1));
    lines.push_back(mask);
  }

// 状压DP转移
dp[0] = 0;
for(int S=0; S < (1<<n); S++) {
  int first = 0;
  while(first < n && (S & (1<<first))) first++;
  for(int line: lines) 
    if(line & (1<<first))
      dp[S | line] = min(dp[S | line], dp[S] + 1);
}
```

---

通过上述分析与实现，可高效解决此类覆盖问题，核心在于状态压缩与预处理优化。

---
处理用时：87.62秒
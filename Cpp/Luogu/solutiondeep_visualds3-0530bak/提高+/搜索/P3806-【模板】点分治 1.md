# 题目信息

# 【模板】点分治 1

## 题目背景

感谢 hzwer 的点分治互测。




## 题目描述

给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 100$。
- 对于 $60\%$ 的数据，保证 $n\leq 1000$，$m\leq 50$ 。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m\leq 100$，$1 \leq k \leq 10^7$，$1 \leq u, v \leq n$，$1 \leq w \leq 10^4$。

#### 提示

- **本题不卡常**。
- 如果您 #7 一直 RE/TLE，不妨看看 [这个帖子](https://www.luogu.com.cn/discuss/show/188596)。

## 样例 #1

### 输入

```
2 1
1 2 2
2```

### 输出

```
AYE```

# AI分析结果



### 算法分类  
其他搜索（点分治结合双指针或桶优化）

### 题解思路与难点分析  
1. **核心思路**  
   - **点分治**：递归选取树的重心分割子树，确保递归深度为 O(log n)  
   - **路径分类**：路径分为跨根路径与子树内路径，后者递归处理  
   - **跨根判断**：通过双指针或哈希桶快速判断是否存在距离互补对  

2. **搜索算法要点**  
   - **重心选择**：通过 DFS 计算子树大小，动态调整确保平衡  
   - **双指针法**：排序子树距离后，左右指针向中间逼近寻找和为 k 的有效对  
   - **桶优化**：记录已处理子树中的距离，O(1) 查询是否存在互补值  

3. **解决难点**  
   - 避免重复计算同一子树内的路径（需校验子树来源）  
   - 处理大范围 k 时内存限制（双指针法优于哈希桶）  

### 题解评分（≥4星）  
1. **Froggy（★★★★★）**  
   - 亮点：双指针法避免桶内存限制，复杂度稳定，适合大 k 场景  
   - 代码可读性高，排序后逻辑清晰，剪枝优化到位  

2. **niiick（★★★★☆）**  
   - 亮点：桶记录距离，查询高效，代码简洁  
   - 局限：k 较大时内存占用高，需特判 0 距离  

3. **寒冰大大（★★★★☆）**  
   - 亮点：详细图解重心分解与分治过程，适合初学者理解  
   - 附调试经历与数据生成器，实践指导性强  

### 最优思路提炼  
- **重心分解**：确保递归层数 O(log n)，降低复杂度  
- **双指针法**：排序后左右夹逼，时间复杂度 O(n log n)  
   ```cpp  
   sort(a+1, a+tot+1, cmp);  // 按距离排序  
   for (int k=1; k<=m; ++k) {  
       int l=1, r=tot;  
       while (l < r) {  
           if (d[a[l]] + d[a[r]] > query[k]) r--;  
           else if (d[a[l]] + d[a[r]] < query[k]) l++;  
           else if (b[a[l]] == b[a[r]]) {  // 同子树跳过  
               if (d[a[r]] == d[a[r-1]]) r--;  
               else l++;  
           } else { ok[k] = true; break; }  
       }  
   }  
   ```  

### 相似题目推荐  
1. [P4178 Tree](https://www.luogu.com.cn/problem/P4178)（点分治统计路径 ≤k 的数量）  
2. [P2634 聪聪可可](https://www.luogu.com.cn/problem/P2634)（点分治求模 3 余 0 的路径数）  
3. [P4149 种族问题](https://www.luogu.com.cn/problem/P4149)（点分治处理异或路径）  

### 可视化与算法演示  
**动画设计**：  
- **重心标记**：用红色高亮当前重心，展示子树分割  
- **距离收集**：蓝色节点表示当前子树节点，动态显示距离计算  
- **双指针移动**：左右指针在排序数组上滑动，绿色匹配成功，红色不匹配  
- **复古像素风**：8-bit 音效提示匹配成功，背景网格模拟树结构  

**交互功能**：  
- **步进控制**：单步执行分治与双指针过程  
- **参数调节**：动态修改 k 值观察不同匹配结果  

### 核心代码实现（双指针法）  
```cpp  
void calc(int u) {  
    tot = 0;  
    a[++tot] = u; d[u] = 0; b[u] = u;  
    for (int i=head[u]; i; i=edge[i].nxt) {  
        int v = edge[i].to;  
        if (vis[v]) continue;  
        get_dis(v, u, edge[i].val, v);  
    }  
    sort(a+1, a+tot+1, [](int x, int y){ return d[x] < d[y]; });  
    for (int i=1; i<=m; ++i) {  
        if (ok[i]) continue;  
        int l=1, r=tot;  
        while (l < r) {  
            if (d[a[l]] + d[a[r]] > query[i]) r--;  
            else if (d[a[l]] + d[a[r]] < query[i]) l++;  
            else if (b[a[l]] == b[a[r]]) {  
                (d[a[r]] == d[a[r-1]]) ? r-- : l++;  
            } else {  
                ok[i] = true;  
                break;  
            }  
        }  
    }  
}  
```  

### 个人心得摘录  
> "构造菊花图时双层循环会 TLE，必须用排序+双指针优化。调试时发现未处理同子树情况，导致假阳性匹配。" —— Froggy  
> "桶法需注意清空时机，过早清空会漏判跨子树路径。特判 k=0 是 BZOJ 数据坑点。" —— niiick  

--- 

通过分治策略与高效搜索优化，点分治能够优雅解决树上路径问题。双指针法以其稳定复杂度成为大范围 k 的最优解，而桶法则在小 k 场景更高效。理解重心分解与路径分类是掌握此类问题的关键。

---
处理用时：87.57秒
# 题目信息

# [USACO18JAN] Cow at Large G

## 题目描述

最后，Bessie 被迫去了一个远方的农场。这个农场包含 $N$ 个谷仓（$2 \le N \le 10^5$）和 $N-1$ 条连接两个谷仓的双向隧道，所以每两个谷仓之间都有唯一的路径。每个只与一条隧道相连的谷仓都是农场的出口。当早晨来临的时候，Bessie 将在某个谷仓露面，然后试图到达一个出口。

但当 Bessie 露面的时候，她的位置就会暴露。一些农民在那时将从不同的出口谷仓出发尝试抓住 Bessie。农民和 Bessie 的移动速度相同（在每个单位时间内，每个农民都可以从一个谷仓移动到相邻的一个谷仓，同时 Bessie 也可以这么做）。农民们和 Bessie 总是知道对方在哪里。如果在任意时刻，某个农民和 Bessie 处于同一个谷仓或在穿过同一个隧道，农民就可以抓住 Bessie。反过来，如果 Bessie 在农民们抓住她之前到达一个出口谷仓，Bessie 就可以逃走。

Bessie 不确定她成功的机会，这取决于被雇佣的农民的数量。给定 Bessie 露面的谷仓K，帮助 Bessie 确定为了抓住她所需要的农民的最小数量。假定农民们会自己选择最佳的方案来安排他们出发的出口谷仓。

## 样例 #1

### 输入

```
7 1
1 2
1 3
3 4
3 5
4 6
5 7```

### 输出

```
3```

# AI分析结果



**算法分类**  
DFS

---

**题解思路与核心难点**  
本题要求确定在树形结构中，Bessie从根节点逃逸时所需的最少农民数量。关键思路是 **判断每个子树是否可被一个农民覆盖**，通过两次DFS实现：  
1. **预处理阶段**：计算每个节点的深度和子树中最浅叶子的距离。  
2. **统计答案阶段**：若某节点的深度满足 `当前深度 ≥ 最浅叶子距离`，则该子树只需一个农民；否则递归处理子树。  

**解决难点**：  
- **最近叶子距离计算**：DFS回溯时维护子树的最小叶子距离。  
- **剪枝策略**：当子树根节点可被覆盖时，直接统计答案，无需遍历子树。  

---

**最优题解评分（≥4星）**  
1. **llzzxx712（5星）**  
   - 思路清晰，两次DFS分别计算子树最浅叶子深度和统计答案。  
   - 代码简洁，用 `smin` 数组高效维护最近叶子距离。  
2. **Parabola（4星）**  
   - 通过两次DFS实现，逻辑明确。  
   - 用 `nd` 数组记录最近叶子距离，优化剪枝。  
3. **Mr_罗（4星）**  
   - 提供三种实现方式，第三种 `down` 数组法最简洁。  
   - 通过 `deep >= down` 条件直接判断覆盖点。  

---

**最优思路与技巧**  
- **两次DFS预处理**：第一次计算节点深度和子树最近叶子距离，第二次统计覆盖点。  
- **关键条件**：若 `深度 ≥ 最近叶子距离`，该子树只需一个农民。  
- **实现优化**：回溯时维护最小值，避免重复计算子树信息。  

---

**同类型题与算法套路**  
- **树形动态规划**：通过子树信息合并解决覆盖问题。  
- **贪心策略**：在最浅叶子处放置农民以覆盖最大子树。  

---

**推荐相似题目**  
1. P1352 没有上司的舞会（树形DP）  
2. P2015 二叉苹果树（子树状态维护）  
3. P1273 有线电视网（树形分组问题）  

---

**可视化与算法演示**  
**动画设计**：  
1. **树形结构展示**：用Canvas绘制树，节点标注深度和最近叶子距离。  
2. **DFS过程**：  
   - **预处理阶段**：递归展开子树，回溯时更新最近叶子距离（红色高亮）。  
   - **统计阶段**：绿色标记覆盖节点，黄色表示待处理子树。  
3. **音效与交互**：  
   - 访问新节点时播放“滴”声，覆盖节点时播放“叮”声。  
   - 支持步进控制，观察条件判断过程。  

**复古像素风格**：  
- **8位配色**：节点用蓝/绿方块，边用灰色线条。  
- **音效**：背景音乐为FC风格循环曲，覆盖时触发“胜利”音效。  

---

**核心代码实现**  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
vector<int> G[N];
int dep[N], min_leaf[N], ans;

void dfs1(int u, int fa) {
    min_leaf[u] = (G[u].size() == 1 && u != fa) ? 0 : INT_MAX;
    for (int v : G[u]) {
        if (v == fa) continue;
        dep[v] = dep[u] + 1;
        dfs1(v, u);
        min_leaf[u] = min(min_leaf[u], min_leaf[v] + 1);
    }
}

void dfs2(int u, int fa) {
    if (dep[u] >= min_leaf[u]) { ans++; return; }
    for (int v : G[u]) 
        if (v != fa) dfs2(v, u);
}

int main() {
    int n, k; cin >> n >> k;
    for (int i=1; i<n; i++) {
        int u, v; cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dep[k] = -1;
    dfs1(k, k);
    dfs2(k, k);
    cout << ans;
}
```

**代码说明**：  
- `dfs1` 计算每个节点的深度和最近叶子距离。  
- `dfs2` 遍历树，若当前节点可被覆盖则统计答案，否则递归处理子树。  

---

**个人心得**  
- **调试踩坑**：根节点深度初始化为-1，确保根的子节点深度为0。  
- **优化关键**：合并两次DFS，避免重复遍历树结构。

---
处理用时：84.77秒
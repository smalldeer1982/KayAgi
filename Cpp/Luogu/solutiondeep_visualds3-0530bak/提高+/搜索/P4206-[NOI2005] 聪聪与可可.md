# 题目信息

# [NOI2005] 聪聪与可可

## 题目描述

在一个魔法森林里，住着一只聪明的小猫聪聪和一只可爱的小老鼠可可。虽然灰姑娘非常喜欢她们俩，但是，聪聪终究是一只猫，而可可终究是一只老鼠，同样不变的是，聪聪成天想着要吃掉可可。

一天，聪聪意外得到了一台非常有用的机器，据说是叫 GPS，对可可能准确的定位。有了这台机器，聪聪要吃可可就易如反掌了。于是，聪聪准备马上出发，去找可可。而可怜的可可还不知道大难即将临头，仍在森林里无忧无虑的玩耍。小兔子乖乖听到这件事，马上向灰姑娘报告。灰姑娘决定尽快阻止聪聪，拯救可可，可她不知道还有没有足够的时间。

整个森林可以认为是一个无向图，图中有 $N$ 个美丽的景点，景点从 $1$ 至 $N$ 编号。小动物们都只在景点休息、玩耍。在景点之间有一些路连接。

当聪聪得到 GPS 时，可可正在景点 $M$（$M \le N$）处。以后的每个时间单位，可可都会选择去相邻的景点（可能有多个）中的一个或停留在原景点不动。而去这些地方所发生的概率是相等的。假设有 $P$ 个景点与景点 $M$ 相邻，它们分别是景点 $R$、景点 $S$、……、景点 $Q$，在时刻 $T$ 可可处在景点 $M$，则在 $(T+1)$ 时刻，可可有 $1/(1 +P)$ 的可能在景点 $R$，有 $1/(1 +P)$ 的可能在景点 $S$，……，有 $1/(1 +P)$ 的可能在景点 $Q$，还有$1/(1 +P)$的可能停在景点 $M$。

我们知道，聪聪是很聪明的，所以，当她在景点 $C$ 时，她会选一个更靠近可可的景点，如果这样的景点有多个，她会选一个标号最小的景点。由于聪聪太想吃掉可可了，如果走完第一步以后仍然没吃到可可，她还可以在本段时间内再向可可走近一步。

在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位于同一个景点，则可怜的可可就被吃掉了。

灰姑娘想知道，平均情况下，聪聪几步就可能吃到可可。而你需要帮助灰姑娘尽快的找到答案。

## 说明/提示

【样例说明 1】 

开始时，聪聪和可可分别在景点 1 和景点 4。 

第一个时刻，聪聪先走，她向更靠近可可(景点 4)的景点走动，走到景点 2， 然后走到景点 3；假定忽略走路所花时间。 

可可后走，有两种可能： 第一种是走到景点 3，这样聪聪和可可到达同一个景点，可可被吃掉，步数为 $1$，概率为$0.5$。
 
第二种是停在景点 4，不被吃掉。概率为 $0.5$。

到第二个时刻，聪聪向更靠近可可(景点 4)的景点走动，只需要走一步即和 可可在同一景点。因此这种情况下聪聪会在两步吃掉可可。 所以平均的步数是 $1\times 1/2 + 2\times 1/2 =1.5$ 步。

【样例说明 2】

森林如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/8uiq0ltc.png)

对于 50%的数据，$1≤N≤50$。  
对于所有的数据，$1≤N,E≤1000$。 

## 样例 #1

### 输入

```
4 3 
1 4 
1 2 
2 3 
3 4```

### 输出

```
1.500 
```

## 样例 #2

### 输入

```
9 9 
9 3 
1 2 
2 3 
3 4 
4 5 
3 6 
4 6 
4 7 
7 8 
8 9```

### 输出

```
2.167```

# AI分析结果



## 【算法分类】
BFS

---

## 【题解思路与难点分析】
### **核心思路**
1. **预处理猫的移动路径**：通过多次BFS计算每个点对的最短路径，确定猫的下一步移动方向（`nxt[i][j]`）。
2. **期望动态规划**：定义状态 `f[i][j]` 表示猫在 `i`、老鼠在 `j` 时的期望步数，通过记忆化搜索递归计算，考虑猫移动两步后的位置和老鼠所有可能的移动路径。

### **解决难点**
- **预处理 `nxt` 数组**：需基于最短路径选择最近的节点，若距离相同则选编号最小。
- **状态转移设计**：猫移动两步后的位置需结合老鼠的随机移动（包括原地停留），递归计算所有可能路径的期望。
- **边界条件处理**：猫与老鼠同点或两步内可到达时直接返回结果。

### **关键算法步骤**
1. **BFS预处理最短路径**：对每个起点执行BFS，记录最短距离。
2. **构建 `nxt` 数组**：根据最短距离选择最优下一步。
3. **记忆化搜索计算期望**：递归处理所有可能状态，结合概率计算期望值。

---

## 【题解评分（≥4星）】
### 1. **FREEH（⭐⭐⭐⭐⭐）**
- **亮点**：代码结构清晰，预处理使用SPFA，状态转移逻辑明确，注释详细。
- **核心代码片段**：
  ```cpp
  void SPFA(int *dis, int s) { /* BFS预处理最短路径 */ }
  double DFS(int u, int v) { /* 记忆化搜索计算期望 */ }
  ```

### 2. **SuperJvRuo（⭐⭐⭐⭐）**
- **亮点**：简洁的BFS预处理，动态规划部分直接使用邻接表遍历。
- **核心代码片段**：
  ```cpp
  void BFS(int s) { /* 计算点对距离 */ }
  double dp(int i, int j) { /* 递归计算期望 */ }
  ```

### 3. **Booksnow（⭐⭐⭐⭐）**
- **亮点**：详细解释预处理步骤，BFS中动态更新 `step` 数组。
- **核心代码片段**：
  ```cpp
  void Get_Step(int point) { /* BFS更新猫的下一步 */ }
  double DFS(int x, int y) { /* 递归计算期望 */ }
  ```

---

## 【最优思路与技巧提炼】
1. **预处理 `nxt` 数组**：通过BFS计算最短路径，选择最优下一步。
2. **记忆化搜索剪枝**：直接处理边界条件（如两步内可到达），避免无效递归。
3. **概率合并计算**：将老鼠的所有移动路径（含原地停留）的期望合并，通过 `/(degree+1)` 简化计算。

---

## 【同类型题与算法套路】
- **通用解法**：BFS预处理最短路径 + 记忆化搜索处理期望。
- **类似题目**：
  1. [P2473] 奖励关（期望DP + 状态压缩）
  2. [P4284] 概率充电器（树形期望DP）
  3. [P6835] 函数调用（DAG上的动态规划）

---

## 【可视化与算法演示】
### **动画方案**
1. **节点与路径绘制**：  
   - 使用Canvas绘制图结构，节点为像素方块，边为线条。
   - **颜色标记**：当前猫节点（红色）、老鼠节点（蓝色）、已访问节点（灰色）。

2. **BFS预处理演示**：  
   - 展示从每个起点出发的BFS过程，队列节点用绿色高亮。
   - 动态更新 `nxt` 数组的数值，显示在节点旁。

3. **期望计算演示**：  
   - 递归路径可视化：用连线表示状态转移（如 `(i,j) → (sec,k)`）。
   - 概率分布用饼图动态展示（如老鼠的移动概率）。

### **复古像素风格**
- **8位音效**：访问节点时播放“哔”声，找到解时播放胜利音效。
- **自动演示模式**：按帧逐步执行BFS和DP，模拟“AI自动运行”。

### **交互设计**
- **控制面板**：暂停/继续、步进、速度调节。
- **代码片段**（JS）：
  ```javascript
  // Canvas绘制节点示例
  function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 30, y * 30, 25, 25);
  }
  ```

---

## 【核心代码片段（C++）】
```cpp
// BFS预处理最短路径（以Booksnow题解为例）
void Get_Step(int point) {
    memset(vis, 0, sizeof(vis));
    queue<int> q;
    q.push(point);
    vis[point] = 1;
    deep[point] = 0;
    while (!q.empty()) {
        int x = q.front(); q.pop();
        for (int i = first[x]; i != -1; i = nex[i]) {
            int to = road[i].v;
            if (deep[to] > deep[x] + 1) {
                deep[to] = deep[x] + 1;
                step[to][point] = x;  // 记录下一步
                q.push(to);
            } else if (deep[to] == deep[x] + 1) {
                step[to][point] = min(step[to][point], x);  // 选最小编号
            }
        }
    }
}

// 记忆化搜索计算期望
double DFS(int x, int y) {
    if (x == y) return 0.0;
    if (step[x][y] == y || step[step[x][y]][y] == y) return 1.0;
    if (f[x][y] > eps) return f[x][y];
    
    double sum = 0;
    sum += DFS(step[step[x][y]][y], y);  // 老鼠不动
    for (int i = first[y]; i != -1; i = nex[i]) {
        sum += DFS(step[step[x][y]][y], road[i].v);  // 老鼠移动
    }
    f[x][y] = sum / (out[y] + 1.0) + 1.0;  // 期望计算
    return f[x][y];
}
```

---
处理用时：98.59秒
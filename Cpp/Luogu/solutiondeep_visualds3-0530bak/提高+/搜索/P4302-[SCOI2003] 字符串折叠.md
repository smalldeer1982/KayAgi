# 题目信息

# [SCOI2003] 字符串折叠

## 题目描述

折叠的定义如下：

1. 一个字符串可以看成它自身的折叠。记作 ```S = S```

2. ```X(S)``` 是 $X$ 个 ```S``` 连接在一起的串的折叠。记作 ```X(S) = SSSS…S```。

3. 如果 ```A = A’```, ```B = B’```，则 ```AB = A’B’ ```。例如：因为 ```3(A) = AAA```, ```2(B) = BB```，所以 ```3(A)C2(B) = AAACBB```，而 ```2(3(A)C)2(B) = AAACAAACBB```

给一个字符串，求它的最短折叠。

例如 ```AAAAAAAAAABABABCCD``` 的最短折叠为：```9(A)3(AB)CCD```。

## 说明/提示

一个最短的折叠为：`2(NEERC3(YES))`

## 样例 #1

### 输入

```
NEERCYESYESYESNEERCYESYESYES```

### 输出

```
14```

# AI分析结果



# 【算法分类】
其他搜索（实际为区间动态规划）

---

# 【题解思路、算法要点与解决难点】
### 核心思路
使用**区间动态规划**求解最短折叠长度。定义 `f[i][j]` 表示区间 `i` 到 `j` 的最短折叠长度。状态转移分两种情况：
1. **分割区间**：枚举断点 `k`，取 `f[i][k] + f[k+1][j]` 的最小值。
2. **自身折叠**：检查区间是否由某个子串循环构成，若循环节长度为 `len`，则更新为 `f[i][k] + 2 + 数字位数`（`2` 为括号长度）。

### 解决难点
1. **循环节检查**：通过模运算判断子串是否重复覆盖整个区间，逐字符比对确保准确性。
2. **数字位数优化**：预处理 `m[x]` 表示数字 `x` 的位数，避免重复计算。
3. **时间复杂度控制**：四层循环但实际通过剪枝（如长度不整除时跳过）降低复杂度至约 `O(n^3 log n)`。

---

# 【题解评分 (≥4星)】
1. **kradcigam（5星）**  
   - **亮点**：代码清晰，预处理数字位数，检查函数高效，详细解释时间复杂度。
   - **核心代码**：
     ```cpp
     bool check(int l, int r, int len) {
         for (int i = l; i <= r; i++)
             if (st[i] != st[(i - l) % len + l]) return false;
         return true;
     }
     ```

2. **hfee（4星）**  
   - **亮点**：双重循环检查循环节，思路直观，适合初学者理解。
   - **核心代码**：
     ```cpp
     bool check(int l, int r, int len) {
         for (int i = l; i <= l + len - 1; i++)
             for (int j = i; j <= r; j += len)
                 if (s[j] != s[i]) return false;
         return true;
     }
     ```

3. **浅色调（4星）**  
   - **亮点**：记忆化搜索实现，结合 `stringstream` 处理字符串，代码简洁。
   - **核心代码**：
     ```cpp
     string dfs(int l, int r) {
         if (f[l][r].size()) return f[l][r];
         string op;
         stringstream ss;
         ss << (r - l + 1) / len << "(" << dfs(l, l + len - 1) << ")";
         return f[l][r] = ss.str();
     }
     ```

---

# 【最优思路或技巧提炼】
1. **区间DP框架**：覆盖所有可能的折叠方式，先分割后折叠。
2. **循环节优化检查**：通过模运算快速定位字符位置，避免重复遍历。
3. **预处理数字位数**：避免在状态转移中重复计算，提升效率。

---

# 【同类型题或类似算法套路】
- **区间DP经典题**：  
  - 石子合并（[P1880](https://www.luogu.com.cn/problem/P1880)）  
  - 括号匹配（[P4170](https://www.luogu.com.cn/problem/P4170)）  
  - 回文划分（[P1435](https://www.luogu.com.cn/problem/P1435)）

---

# 【推荐洛谷题目】
1. [P1435 回文字串](https://www.luogu.com.cn/problem/P1435)  
2. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)  
3. [P4342 [IOI1998]Polygon](https://www.luogu.com.cn/problem/P4342)

---

# 【可视化与算法演示】
### 动态规划表格填充动画
1. **网格绘制**：以二维表格表示 `f[i][j]`，初始化为红色（未计算），填充时变为绿色。
2. **步进控制**：单步展示区间分割和折叠检查，高亮当前处理的区间 `[i, j]`。
3. **循环节检查**：用不同颜色标记循环节和重复部分，动态展示字符比对过程。

### 复古像素风格设计
- **8位音效**：  
  - 字符匹配成功：短促“滴”声。  
  - 状态更新：低音“嘟”声。  
- **Canvas动画**：网格节点以像素方块表示，折叠时显示 `X(S)` 格式的浮动文字。

---

# 【关键代码实现】
```cpp
// 区间DP核心代码（kradcigam题解）
for (int l = 2; l <= n; l++) {
    for (int i = 1, j = i + l - 1; j <= n; i++, j++) {
        // 分割区间
        for (int k = i; k < j; k++)
            f[i][j] = min(f[i][j], f[i][k] + f[k+1][j]);
        // 自身折叠
        for (int k = i; k < j; k++) {
            int len = k - i + 1;
            if (l % len != 0) continue;
            if (check(i, j, len))
                f[i][j] = min(f[i][j], f[i][k] + 2 + m[l / len]);
        }
    }
}
```

---
处理用时：101.20秒
# 题目信息

# [JLOI2014] 聪明的燕姿

## 题目背景

> 阴天傍晚车窗外
>
> 未来有一个人在等待
>
> 向左向右向前看
>
> 爱要拐几个弯才来
>
> 我遇见谁会有怎样的对白
>
> 我等的人他在多远的未来
>
> 我听见风来自地铁和人海
>
> 我排着队拿着爱的号码牌

## 题目描述

城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。

可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 $S$，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 $S$。

所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。

## 说明/提示

对于 $100\%$ 的数据，$k\leqslant100$，$S\leqslant2\times10^9$。

## 样例 #1

### 输入

```
42```

### 输出

```
3
20 26 41```

# AI分析结果



## 算法分类
**DFS**

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **约数和定理**：将问题转化为分解 S 为若干质数和项的乘积。
2. **DFS 搜索**：递归分解 S，枚举质数及其指数，构造满足条件的数。
3. **剪枝优化**：
   - 预处理 1e5 以内的质数加速判断。
   - 当剩余值减 1 是质数时直接记录答案。
   - 限制质数的平方不超过当前剩余值。
4. **去重与排序**：结果排序后去重，保证升序输出。

### 解决难点
- **质数高效判断**：预处理筛法 + 试除法结合，处理大质数。
- **避免重复解**：强制质数递增选择（如每次从第 x 个质数开始枚举）。
- **终止条件**：剩余值为 1 或剩余值减 1 是质数时的快速处理。

---

## 题解评分（≥4星）

1. **ycyaw（5星）**
   - **亮点**：代码结构清晰，注释详细；预处理质数到 1e5，剪枝条件明确；处理边界条件（如 `now=1` 和质数减 1）简洁高效。
   - **代码**：DFS 参数设计合理，递归逻辑易于跟踪。

2. **LaoPi（4.5星）**
   - **亮点**：题解附带详细公式推导，代码模块化（筛法、质数判断分离）；特判逻辑 `now>pr[x]` 避免重复。
   - **优化**：预处理质数后，仅用质数试除加速判断。

3. **timmark（4星）**
   - **亮点**：代码简洁，变量命名规范；核心逻辑集中在 `dfs` 函数，剪枝条件 `primes[i] <= sqrt(num)` 显著减少分支。
   - **改进**：缺少详细注释，但算法实现高效。

---

## 最优思路或技巧提炼

### 关键技巧
- **质数预处理**：筛法生成 1e5 内质数，加速后续分解。
- **质数递增选择**：DFS 中强制按质数表顺序选择，避免重复组合。
- **快速剪枝**：
  - 当 `remaining-1` 是质数时，直接生成解。
  - 仅枚举质数平方不超过剩余值的分支。
- **结果排序去重**：统一收集结果后排序，保证输出有序。

### 代码片段（DFS核心逻辑）
```cpp
void dfs(int now, int x, int s) {
    if (now == 1) { ans[++cnt] = s; return; }
    if (pd(now - 1) && now > pr[x]) ans[++cnt] = s * (now - 1);
    for (int i = x; pr[i] * pr[i] <= now; i++) {
        int t = pr[i], sum = pr[i] + 1;
        for (; sum <= now; t *= pr[i], sum += t) 
            if (now % sum == 0) 
                dfs(now / sum, i + 1, s * t);
    }
}
```

---

## 同类型题与算法套路

### 通用解法
- **质因数分解 + 搜索剪枝**：适用于需要构造满足特定数论条件的数（如约数和、完全平方数等）。
- **状态传递设计**：DFS 参数需携带剩余值、当前质数索引、已构造的数值。

### 类似题目
1. **P1072 Hankson的趣味题**：利用因数分解求解满足条件的数。
2. **P1734 最大约数和**：动态规划与约数和结合。
3. **P2926 [USACO08DEC]Patting Heads S**：统计约数出现次数。

---

## 可视化与算法演示

### 动画方案
1. **搜索树展示**：
   - **节点**：当前剩余值、已选质数组合。
   - **边**：选择质数 p 的某次方和（如 p^0 + p^1 + ...）。
   - **高亮**：当前访问节点（红色），有效分支（绿色），无效分支（灰色）。

2. **复古像素风格**：
   - **质数节点**：8-bit 像素方块，不同颜色区分质数大小。
   - **音效**：选择质数时触发“哔”声，找到解时播放胜利音效。

3. **交互控制**：
   - **步进执行**：手动控制 DFS 每一步展开。
   - **自动播放**：AI 按最优路径自动搜索，速度可调。

### 核心逻辑演示
```javascript
// 伪代码：DFS 动画关键帧
function animateDFS(remaining, primesUsed) {
    if (remaining === 1) {
        playSuccessSound();
        highlightSolution(primesUsed);
        return;
    }
    if (isPrime(remaining - 1)) {
        flashNode(remaining - 1);
        addToAnswer(primesUsed.concat(remaining - 1));
    }
    for (let p of nextPrimes) {
        if (p * p > remaining) break;
        let sum = p + 1, t = p;
        while (sum <= remaining) {
            if (remaining % sum === 0) {
                drawBranch(p, t);
                animateDFS(remaining / sum, primesUsed.concat(t));
            }
            t *= p;
            sum += t;
        }
    }
}
```

---

## 个人心得摘录

- **调试教训**：需确保质数严格递增选择，否则会生成重复解（如 20=2²×5 和 5×2² 视为不同路径）。
- **优化顿悟**：预处理质数到 sqrt(S) 足够，大质数单独判断可节省筛法时间。
- **边界陷阱**：S=1 时无解需特判，否则 DFS 会错误记录 0。

---

**推荐题目**
1. **P1072** - 因数分解与条件构造。
2. **P1734** - 动态规划与约数和。
3. **P2926** - 约数统计与筛法结合。

---
处理用时：93.18秒
# 题目信息

# River Jumping

## 题目描述

有一条宽度为 $N$ 的河上，小 D 位于坐标为 $0$ 的河岸上，他想到达坐标为 $N$ 的河岸上后再回到坐标为 $0$ 的位置。在到达坐标为 $N$ 的河岸之前小 D 只能向坐标更大的位置跳跃，在到达坐标为 $N$ 的河岸之后小 D 只能向坐标更小的位置跳跃。在河的中间有 $M$ 个岩石，小 D 希望能跳到每个岩石上恰好一次。由于小 D 的跳跃能力太强，小 D 的跳跃长度有个下限 $S$，但没有上限。现在请你判断他是否能够完成他的目标。

## 说明/提示

对于全部数据，保证 $1 \le N,S \le 100000$，$0 \le M < N$，$1 \le w_i < N$。

## 样例 #1

### 输入

```
6 1 3
3```

### 输出

```
YES
1 2 0```

## 样例 #2

### 输入

```
6 2 2
2 4```

### 输出

```
YES
2 3 1 0```

## 样例 #3

### 输入

```
5 2 3
2 3```

### 输出

```
NO```

# AI分析结果



## 算法分类：贪心算法

### 题解思路与难点对比

**核心思路**  
所有题解均采用贪心策略，分两次跳跃：第一次从起点到终点尽可能覆盖岩石，第二次从终点返回处理剩余岩石。关键在于判断初始条件是否满足，并通过贪心覆盖所有岩石。

**难点对比**  
1. **初始条件判断**  
   - **FlierKing** 显式检查首尾岩石距离是否≥S，及是否存在三个连续岩石间距不足。  
   - **Vermouth_1412** 额外处理 m=0 的情况，确保河宽≥S。  
   - **y2823774827y** 未显式检查三个连续岩石，依赖贪心后的结果判断。  

2. **贪心实现差异**  
   - **FlierKing** 使用两次遍历（正向+反向）记录访问顺序，通过计数验证是否覆盖所有岩石。  
   - **Vermouth_1412** 直接交替输出奇数位和偶数位岩石，但未处理中间可能遗漏的情况。  
   - **Happy_Orca** 提出将岩石分为两组交替跳跃，通过交换顺序避免相邻间距不足。  

3. **无解条件覆盖**  
   - **FlierKing** 通过两次贪心后的总数判断是否覆盖所有点。  
   - **Acfboy** 使用回溯法遍历所有可能路径，效率较低但覆盖全面。  

### 精炼结论  
最优解法为两次贪心遍历：  
1. **正向跳跃**：从起点出发，每次选择最近的满足距离≥S的岩石。  
2. **反向跳跃**：从终点返回，处理剩余岩石。若两次遍历后所有岩石均被访问，则有解。  
关键优化点：显式检查首尾岩石距离及三个连续岩石间距不足的情况，提前排除无解。

---

### 题解评分（≥4星）

1. **FlierKing（★★★★★）**  
   - 思路清晰，显式检查初始条件，两次贪心覆盖所有岩石。  
   - 代码高效，时间复杂度 O(m)。  

2. **y2823774827y（★★★★）**  
   - 贪心实现简洁，但未显式检查三个连续岩石条件。  
   - 代码可读性强，通过计数验证覆盖性。  

3. **Acfboy（★★★★）**  
   - 使用回溯法确保覆盖所有可能路径，正确性高但效率低。  
   - 代码结构清晰，适合教学演示。  

---

### 最优思路提炼

1. **初始条件检查**  
   - 首尾岩石距离起点/终点≥S。  
   - 任意三个连续岩石间距≥S（避免无法覆盖中间岩石）。  

2. **贪心跳跃策略**  
   - 正向选择最近满足条件的岩石，确保路径递增。  
   - 反向处理剩余岩石，确保路径递减。  

3. **覆盖性验证**  
   - 两次遍历后总访问岩石数应为 m+2（含起点和终点）。  

---

### 相似题目推荐

1. **P1091 跳石头**  
   - 类似贪心选择跳跃点，需处理最小跳跃距离。  

2. **P2678 跳石头（NOIP2015）**  
   - 二分答案结合贪心策略，判断最小距离可行性。  

3. **P5019 铺设道路（NOIP2018）**  
   - 贪心策略处理区间覆盖问题，与跳跃路径选择思路相似。  

---

### 可视化算法演示

**核心逻辑动画设计**  
- **颜色标记**：  
  - 绿色：当前跳跃点。  
  - 黄色：已访问岩石。  
  - 红色：未满足跳跃条件的岩石。  
- **操作步骤**：  
  1. 正向遍历：从起点出发，动态高亮可达岩石，选择最近点跳跃。  
  2. 反向遍历：从终点返回，处理剩余岩石，动态更新路径。  
  3. 结果判定：若所有岩石变黄，播放成功音效；否则红色闪烁无解。  

**复古像素风格实现**  
- **Canvas绘制**：网格化表示岩石位置，8-bit 风格跳跃动画。  
- **音效设计**：跳跃时触发“哔”声，成功/失败播放不同音调。  

---

### 代码片段（FlierKing 题解）

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, s, a[100005], cnt, p;
bool vis[100005];

int main() {
    scanf("%d%d%d", &n, &m, &s);
    for (int i = 1; i <= m; i++) scanf("%d", &a[i]);
    sort(a + 1, a + m + 1);
    a[0] = 0; a[m + 1] = n;

    // 正向贪心
    for (int i = 1; i <= m + 1; i++) {
        if (a[i] - p >= s) {
            vis[i] = true;
            p = a[i];
            cnt++;
        }
    }
    if (p != n) { puts("NO"); return 0; }

    // 反向贪心
    for (int i = m; i >= 0; i--) {
        if (!vis[i] && p - a[i] >= s) {
            vis[i] = true;
            p = a[i];
            cnt++;
        }
    }

    if (cnt == m + 2) { // 包含起点和终点
        puts("YES");
        for (int i = 1; i <= m + 1; i++) 
            if (vis[i]) printf("%d ", i);
        for (int i = m; i >= 0; i--) 
            if (vis[i]) printf("%d ", i);
    } else puts("NO");
    return 0;
}
```

---
处理用时：241.98秒
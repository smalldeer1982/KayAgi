# 题目信息

# [BalticOI 2018] 路径

## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day2「[Paths](https://boi18-day2-open.kattis.com/problems/boi18.paths)」**

给定一张 $N$ 个点 $M$ 条边的无向图，每个点有一个颜色，所有点的颜色共有 $K$ 种，编号为 $1\ldots K$。求图上有多少条长度至少为 $2$ 的简单路径，满足路径上的每一个点的颜色互不相同。

路径上的点的连接顺序不同看作不同的两条路径。

## 说明/提示

#### 样例 1 解释
![](https://gitee.com/mingqihuang/pics/raw/master/pathsfig.pdf.svg)

样例 1 中表达的图如上图所示。每个点的底色分别为白色（颜色 $1$）、灰色（颜色 $2$）或黑色（颜色 $3$）。共有 $10$ 条路径满足路径上的所有点的颜色都不同。它们是：``1-2``, ``2-1``, ``2-3``, ``3-2``, ``2-4``, ``4-2``, ``1-2-4``, ``4-2-1``, ``3-2-4`` 和 ``4-2-3``。

注意 ``1`` 不能看作是一条路径，因为一条路径至少连接两个点。``1-2-3`` 也不满足条件，因为有两个点都是 $1$ 号颜色。

|子任务|分值|数据范围|
|:--:|:--:|:--:|
|$1$|$23$|$1 \leqslant N,M \leqslant 100, 1 \leqslant K \leqslant 4$|
|$2$|$20$|$1 \leqslant N,M \leqslant 300\,000, 1 \leqslant K \leqslant 3$|
|$3$|$27$|$1 \leqslant N,M \leqslant 300\,000, 1 \leqslant K \leqslant 4$|
|$4$|$30$|$1 \leqslant N,M \leqslant 100\,000, 1 \leqslant K \leqslant 5$|

感谢 Hatsune_Miku 提供的翻译

## 样例 #1

### 输入

```
4 3 3
1 2 1 3
1 2
2 3
4 2```

### 输出

```
10

```

## 样例 #2

### 输入

```
9 11 4
1 2 3 4 1 2 1 2 2
1 2
1 3
2 3
2 4
3 6
6 2
6 5
4 3
4 5
7 8
9 8```

### 输出

```
70```

# AI分析结果



## 算法分类
其他搜索

## 综合分析与结论
题目要求统计图中颜色互不相同的简单路径数目，核心思路是状态压缩动态规划（状压DP）。由于颜色种类最多为5，可用二进制状态表示已选颜色集合。各题解主要围绕以下要点展开：

### 核心思路
- **状态定义**：`dp[u][S]` 表示到达节点 `u`，使用颜色集合 `S` 的路径数。初始化时，每个节点的初始颜色集合为单元素集合。
- **状态转移**：遍历每个状态 `S`，对当前节点 `u` 的所有邻居 `v`，若 `v` 的颜色未在 `S` 中出现，则将 `dp[u][S]` 累加到 `dp[v][S∪{v的颜色}]`。
- **答案统计**：所有状态中颜色数≥2的路径总数。

### 解决难点
- **颜色集合处理**：使用位运算高效判断颜色是否重复。
- **状态处理顺序**：按颜色数递增处理状态，确保子状态在父状态之后处理。部分题解（如 GLZP、activeO）通过排序状态实现，而另一些（如 panxz2009）依赖数值顺序隐含的正确性。
- **时间复杂度优化**：通过压缩状态空间（2^5=32）将复杂度控制在 O(N*2^K)。

### 可视化设计思路
- **节点与状态展示**：用不同颜色标记节点，当前处理的状态以高亮显示。
- **状态转移动画**：动态展示节点间的转移过程，如选中节点时，显示其相邻节点及可扩展的新状态。
- **层次遍历效果**：按颜色数递增顺序模拟 BFS 的层次遍历，每层处理对应颜色数的状态。

## 题解清单（≥4星）
1. **GLZP（4星）**
   - 关键亮点：按状态颜色数排序处理，确保正确转移顺序，代码结构清晰。
   - 核心代码片段：
     ```cpp
     sort(book+1,book+S+1,cmp); // 按颜色数排序
     for (状态i) {
         for 所有节点j {
             累加答案并转移状态;
         }
     }
     ```

2. **activeO（4星）**
   - 关键亮点：与 GLZP 思路一致，代码简洁，预处理状态顺序增强可读性。
   - 代码结构清晰，初始化与状态转移逻辑明确。

3. **Error_Eric（4星）**
   - 关键亮点：极简实现，外层枚举状态，内层处理节点，高效且代码量少。
   - 核心代码片段：
     ```cpp
     for (状态s) {
         for 所有节点j {
             累加答案并转移至邻居;
         }
     }
     ```

## 最优思路提炼
- **状态压缩DP**：用二进制位表示颜色集合，空间复杂度低。
- **层次处理状态**：按颜色数递增处理状态，避免无效转移。
- **邻接表遍历**：高效枚举邻居节点，避免重复计算。

## 同类型题推荐
1. **P2831 [NOIP2016 提高组] 愤怒的小鸟**：状压DP处理状态集合。
2. **P1433 吃奶酪**：状态压缩与路径遍历结合。
3. **P1171 售货员的难题**：状态压缩处理访问顺序。

## 个人心得摘录
- **Error_Eric**：指出“多次随机选择颜色”可优化暴力算法，启发思维灵活性。
- **TemplateClass**：尝试 BFS 队列处理状态，展示不同实现的可能性。

## 可视化与算法演示
### 核心搜索过程动画
- **颜色标记**：当前节点用红色，已处理状态用绿色，待处理状态用灰色。
- **步进控制**：用户可调整速度观察状态如何按颜色数递增扩展。
- **Canvas 绘制**：网格化展示节点，边表示转移路径，状态集合以二进制悬浮提示。

### 复古游戏化设计
- **8位像素风**：节点为像素方块，颜色对应题目设定，背景音乐为 Chiptune 风格。
- **音效设计**：访问新节点时播放“哔”声，找到有效路径时播放上升音阶。
- **自动演示模式**：按颜色数层次自动扩展，类似贪吃蛇AI遍历，积分随正确路径增加。

---

## 核心代码片段（Error_Eric）
```cpp
void fun(int val, int pos) {
    int fr = val ^ (1 << c[pos]);
    if (fr == 0) f[pos][val] = 1;
    else {
        for (auto &to : e[pos])
            f[pos][val] += f[to][fr];
        ans += f[pos][val];
    }
}
// 外层循环枚举状态，内层处理节点
for (int i = 1; i < (1 << k); i++)
    for (int j = 1; j <= n; j++)
        if (i & (1 << c[j]))
            fun(i, j);
```

---
处理用时：277.56秒
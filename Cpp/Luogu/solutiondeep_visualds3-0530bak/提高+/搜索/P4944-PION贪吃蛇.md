# 题目信息

# PION贪吃蛇

## 题目背景

NOIP2018原创模拟题 T3

NOIP DAY1 T3 or DAY 2 T2 难度

贪吃蛇大家都玩过吧，当然不同版本有不同规则。下面介绍PION贪吃蛇。

## 题目描述

![图A](https://cdn.luogu.com.cn/upload/pic/31298.png)

***表示方法：***

该题中贪吃蛇存在于一个n行m列的矩形中，用 ‘.’ 表示空地，用 '#’ 表示蛇身，用 ‘@’表示蛇头，用‘&’表示食物
例如：图一表示 $5*6$ 的矩形，有一条蛇，蛇长度为 $7$，有两个食物

***基本规则：***

1.蛇头每一秒就会移动一格，身体自然会跟着移动，用W表示向上，S表示向下，A表示向左，D表示向右

2.蛇每吃一个食物就长度就会加一，而增加的长度体现在食物所在的地方，你可以把吃食物理解成食物变成了蛇头，之前的蛇头变成了蛇身，这一秒不移动

例如：图二的三幅图展示了第一秒，第二秒，和第三秒的情况

3.蛇如果死亡，身体（包括头）一定会全部变成食物

4.PION贪吃蛇的蛇头碰到自己或别的蛇的身体就会死亡

例如：图三的三幅图展示了第二条蛇撞在别人身体上死亡的过程

5.蛇头撞在边界上也会引起死亡，但蛇头刚好现在边界上不会

例如：图四第二幅图虽然蛇头在边界上，但是只是刚好，如果此时进行D操作蛇就会死亡，如果进行W或S就不会

6.如果有操作使蛇头向相反方向运动，之后如果与身体重合蛇也会死亡（比如：图二第一幅图使用A操作,蛇就会死亡，此时在原地成为三个食物，你也可以理解为蛇下一秒不行动而自杀了）

7.两条蛇蛇头相撞，主动撞上的死亡

8.蛇的移动按编号由小到大进行（编号的含义见下文）


## 说明/提示

***样例说明：***

![图B](https://cdn.luogu.com.cn/upload/pic/31357.png)

图五，图六展示了从第 $0$ 秒开始之后每一秒地图的状态，请看图理解（样例二图四有点小错误）

***数据范围：***

$10\%$ 数据满足 $n,m\leq 5,c=1,k\leq3$

$30\%$ 数据满足 $n,m\leq 10,c\leq 2,k\leq 5$

$50\%$ 数据满足 $n,m\leq 50,c\leq 5,k\leq 20$

$70\%$ 数据满足 $n,m\leq 100,c\leq 7,k\leq 50$

$100\%$ 数据满足 $n,m\leq 200,c\leq 20,k\leq 100$，且图中的蛇不会引起混淆（对于任意蛇头，最多只有一块蛇身于其相连，而蛇身最多为二连块）,且数据保证图中的蛇均可以判断身体与头的对应关系，不会造成蛇身形态多解

## 样例 #1

### 输入

```
5 7 6
.&...&.
..##@..
.&...&.
..##@..
.&...&.
DWAAAA
WDDDDD```

### 输出

```
5 1
0 2
7```

## 样例 #2

### 输入

```
9 9 4
.........
.#######.
.......#.
.@#.&@.#.
&.#.&&.#.
&&######.
.&.......
..@####..
.........
ASSD
ASDD
WASD```

### 输出

```
22 1
4 2
0 3
6```

# AI分析结果



## 算法分类：BFS

### 综合分析与结论
该题核心是模拟贪吃蛇移动，关键难点在于**蛇身的动态维护与碰撞检测**。各题解共性思路如下：
1. **蛇身存储**：使用双端队列（`deque`）存储蛇身坐标，队首为蛇头，队尾为蛇尾。
2. **移动逻辑**：
   - **空地移动**：队首插入新头，队尾弹出旧尾。
   - **吃食物**：仅插入新头，不弹出尾部。
   - **碰撞检测**：越界或触碰蛇身（`#`或`@`）则全队转为食物。
3. **搜索初始化**：通过BFS/DFS从蛇头（`@`）出发，将连通块存入队列。

**可视化设计**：
- **网格绘制**：以Canvas绘制网格，蛇头用红色方块，身体用渐变色，食物用绿色。
- **动画流程**：
  1. 高亮当前移动的蛇头，显示目标坐标。
  2. 根据移动类型（前进/吃食物/死亡）触发不同动画：箭头延伸、食物消失、爆炸特效。
  3. 步进控制：用户可逐帧观察队列变化，如`push_front`和`pop_back`操作。
- **复古风格**：8-bit像素风，移动时播放经典“吃豆人”音效，死亡时播放“Game Over”音效。

---

### 题解清单（≥4星）
1. **liangbowen（★★★★★）**  
   - **亮点**：双端队列操作清晰，死亡处理函数封装完善，代码模块化。
   - **核心代码**：
     ```cpp
     void move(int id, char op) {
         int x = snake[id].front().x, y = snake[id].front().y;
         // 计算新坐标 (nx, ny)
         if (越界 || 碰撞) die(id);
         else if (食物) {
             snake[id].push_front({nx, ny});
             a[nx][ny] = '@'; 
         } else {
             snake[id].push_front({nx, ny});
             snake[id].pop_back();
         }
     }
     ```

2. **Macesuted（★★★★☆）**  
   - **亮点**：面向对象封装蛇类，移动逻辑高度复用。
   - **技巧**：使用`deque`和地图同步更新，避免重复计算坐标。

3. **FallingFYC_（★★★★☆）**  
   - **亮点**：结构体排序优化输出，移动方向映射表提升可读性。
   - **心得**：强调`deque`在头尾操作的效率优势。

---

### 最优思路提炼
1. **双端队列动态维护**：蛇头插入、蛇尾弹出天然适配贪吃蛇移动特性。
2. **状态优先判断**：先检测死亡和吃食物，再处理普通移动，避免冗余计算。
3. **面向对象封装**：将蛇的属性和方法封装为类，提升代码复用性。

---

### 同类题目推荐
1. **P1518 [USACO2.4] 两只塔姆沃斯牛** - 双角色交替移动与碰撞检测。
2. **P1120 小木棍** - DFS剪枝优化经典问题。
3. **P1825 [USACO11OPEN] Corn Maze S** - BFS寻路与动态障碍。

---

### 可视化核心代码（JavaScript）
```javascript
// 绘制蛇身（像素风格）
function drawSnake(ctx, snake) {
    snake.body.forEach((pos, idx) => {
        ctx.fillStyle = idx === 0 ? '#FF0000' : `hsl(${idx * 30}, 70%, 50%)`;
        ctx.fillRect(pos.x * 20, pos.y * 20, 18, 18);
    });
}

// 移动动画
function animateMove(snake, target) {
    const head = snake.body[0];
    const dx = target.x - head.x, dy = target.y - head.y;
    // 播放音效：beep.mp3
    anime({
        targets: head,
        x: target.x, y: target.y,
        easing: 'easeOutQuad',
        update: () => drawGrid()
    });
}
```

---

### 个人心得摘录
- **liangbowen**：强调“死亡函数必须清空队列，否则残留坐标会导致后续误判”。
- **Terraria**：调试中发现`=`误写为`==`导致状态错误，建议“多用断言检查边界”。
- **Macesuted**：“面向对象封装让多蛇管理更直观，避免全局变量污染”。

---
处理用时：83.04秒
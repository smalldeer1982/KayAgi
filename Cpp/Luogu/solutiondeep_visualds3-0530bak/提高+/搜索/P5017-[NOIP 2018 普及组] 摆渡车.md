# 题目信息

# [NOIP 2018 普及组] 摆渡车

## 题目背景

NOIP2018 普及组 T3

## 题目描述

有 $n$ 名同学要乘坐摆渡车从人大附中前往人民大学，第 $i$ 位同学在第 $t_i$ 分钟去 等车。只有一辆摆渡车在工作，但摆渡车容量可以视为无限大。摆渡车从人大附中出发、 把车上的同学送到人民大学、再回到人大附中（去接其他同学），这样往返一趟总共花费 $m$ 分钟（同学上下车时间忽略不计）。摆渡车要将所有同学都送到人民大学。  

凯凯很好奇，如果他能任意安排摆渡车出发的时间，那么这些同学的等车时间之和最小为多少呢？    

注意：摆渡车回到人大附中后可以即刻出发。

## 说明/提示

**样例 1 说明**    

同学 $1$ 和同学 $4$ 在第 $3$ 分钟开始等车，等待 $0$ 分钟，在第 $3$ 分钟乘坐摆渡车出发。摆渡车在第 $4$ 分钟回到人大附中。   
同学 $2$ 和同学 $3$ 在第 $4$ 分钟开始等车，等待 $0$ 分钟，在第 $4$ 分钟乘坐摆渡车 出发。摆渡车在第 $5$ 分钟回到人大附中。   
同学 $5$ 在第 $5$ 分钟开始等车，等待 $0$ 分钟，在第 $5$ 分钟乘坐摆渡车出发。自此 所有同学都被送到人民大学。总等待时间为 $0$。

**样例 2 说明**  

同学 $3$ 在第 $1$ 分钟开始等车，等待 $0$ 分钟，在第 $1$ 分钟乘坐摆渡车出发。摆渡 车在第 $6$ 分钟回到人大附中。   
同学 $4$ 和同学 $5$ 在第 $5$ 分钟开始等车，等待 $1$ 分钟，在第 $6$ 分钟乘坐摆渡车 出发。摆渡车在第 $11$ 分钟回到人大附中。   
同学 $1$ 在第 $11$ 分钟开始等车，等待 $2$ 分钟；同学 $2$ 在第 $13$ 分钟开始等车， 等待 $0$ 分钟。他/她们在第 $13$ 分钟乘坐摆渡车出发。自此所有同学都被送到人民大学。 总等待时间为 $4$。  
可以证明，没有总等待时间小于 $4$ 的方案。 

**数据规模与约定**

对于 $10\%$ 的数据，$n ≤ 10$，$m = 1$，$0 ≤ t_i ≤ 100$。   
对于 $30\%$ 的数据，$n ≤ 20$，$m ≤ 2$，$0 ≤ t_i ≤ 100$。  
对于 $50\%$ 的数据，$n ≤ 500$，$m ≤ 100$，$0 ≤ t_i ≤ 10^4$。  
另有 $20\%$ 的数据，$n ≤ 500$，$m ≤ 10$，$0 ≤ t_i ≤ 4 \times  10^6$。  
对于 $100\%$ 的数据，$n ≤ 500$，$m ≤ 100$，$0 ≤ t_i ≤ 4 \times 10^6$。

## 样例 #1

### 输入

```
5 1 
3 4 4 3 5 ```

### 输出

```
0```

## 样例 #2

### 输入

```
5 5 
11 13 1 5 5 ```

### 输出

```
4```

# AI分析结果



## 算法分类：其他搜索

### 综合分析与结论
本题核心思路为动态规划，但部分题解采用记忆化搜索（DFS的一种变形）。状态设计上，常用 `f[i]` 表示在时间 `i` 发车的最小等待时间。通过前缀和优化转移计算，并利用剪枝策略（如限定转移区间 `i-2m` 到 `i-m`）降低复杂度。难点在于时间离散化与状态转移优化。

对于搜索相关解法（如记忆化搜索），递归遍历可能状态，记忆化剪枝避免重复计算。例如，`dfs(k, j)` 表示处理第 `k` 个人等待 `j` 分钟的状态，递归枚举转移路径。

### 题解清单（≥4星）
1. **Sooke的题解（★★★★★）**  
   核心思路：DP + 多重优化（前缀和、剪枝、斜率优化）。通过状态压缩将复杂度从 O(t²) 降至 O(nm²)，代码清晰，优化思路完整。

2. **Plozia的题解（★★★★☆）**  
   使用记忆化搜索实现动态规划，递归逻辑清晰，通过限制等待时间范围（≤2m）优化状态空间，适合理解搜索到DP的过渡。

3. **hnczy的题解（★★★★☆）**  
   斜率优化DP，将转移方程转化为线性形式，利用单调队列维护凸包，时间复杂度 O(t)，理论最优。

### 代码片段（Sooke的DP优化）
```cpp
for (int i = 0; i < t + m; i++) {
    if (i >= m && cnt[i - m] == cnt[i]) {
        f[i] = f[i - m]; // 剪枝：空时间段直接继承
        continue;
    }
    f[i] = cnt[i] * i - sum[i]; // 单独成段
    for (int j = max(i - 2*m + 1, 0); j <= i - m; j++) {
        f[i] = min(f[i], f[j] + (cnt[i]-cnt[j])*i - (sum[i]-sum[j]));
    }
}
```

### 可视化设计要点
- **时间轴动画**：横向滚动展示时间点，颜色标记已访问状态，箭头表示状态转移。
- **像素风格**：使用8位色块表示时间点，绿色为已计算状态，红色为待计算。
- **音效提示**：转移时播放“滴”声，找到最优解时播放胜利音效。
- **自动演示**：按时间步进，显示当前处理的时间点和转移来源。

### 同类型题目推荐
1. **P1095 守望者的逃离**（时间序列DP）
2. **P1063 能量项链**（区间DP）
3. **P1048 采药**（背包问题）

### 个人心得摘录
> “剪枝时发现空时间段可直接继承前一状态，节省大量计算。调试时通过打印中间状态发现转移区间错误。” —— Sooke

### 复古游戏化演示（伪代码）
```javascript
// Canvas绘制时间轴
ctx.fillStyle = '#8B8BEF'; // 未计算状态
ctx.fillRect(time * 10, 0, 8, 8);
if (visited[time]) {
    ctx.fillStyle = '#6AFF6A'; // 已计算
    playSound('blip.wav');
}
// 自动步进演示
setInterval(() => {
    stepDP();
    draw();
}, 500);
```

---
处理用时：155.96秒
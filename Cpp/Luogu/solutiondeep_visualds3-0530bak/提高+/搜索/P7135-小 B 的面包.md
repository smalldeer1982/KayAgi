# 题目信息

# 小 B 的面包

## 题目背景

本题是一道**函数式交互题**。

小 B 获得了很多面包，小 Y 很愤怒，他想抢夺面包。

小 Y 提出要和小 B 玩一个有趣的游戏，如果小 B 输了，小 B 就要被抢走所有面包。

小 B 还要到【数据删除】江边散步，所以他把这个任务交给了你。

聪明的你能帮小 B 守卫他宝贵的面包吗？

## 题目描述

**本题建议使用 `c++` 语言编程**。

小 Y 把 $9$ 个面包依次放在了桌子上，第 $i$ 个面包的质量为 $i$。

小 Y 与你轮流选取面包，谁选取的面包中，任意三个面包的总质量先恰好达到 $15$，谁就获胜，另外一方则落败。**每个面包只能取一次，一个人取了某个面包后另一个人就不能再选取了，选取面包后不能再放回**。

如果最后面包全部选取完后双方未均达到，则为平局。

---

本题中，你需要且只需要实现以下三个函数（可以在其中调用或访问你的自写函数或全局变量）：

```cpp
extern "C" int choose(int x);
extern "C" void init();
extern "C" void newgame(bool f);
/* 注意以上三个函数之前的 extern "C" 不可省略 */
```

评测时，交互库将首先调用一次你所实现的 `init()` 函数。`init()` 函数的作用为方便你最开始初始化，之后不会再次调用，如果你不需要初始化也请加入 `extern "C" void init() {}`。

接下来交互库会调用你所实现的 `newgame(bool f)` 函数，交互库调用 `newgame(bool f)` 函数表示开始一场新游戏，传入的 `f` 若等于 $1$ 表示是由交互库先选择，否则由你先选择。

接下来交互库将会不断调用你实现的 `choose(int x)` 函数，传入的 $x$ 表示小 Y 选取了第 $x$ 个面包，此函数运行结束后你需要返回一个整数 $y(1 \le y \le 9)$，表示你选取了第 $y$ 个面包，即：

```cpp
extern "C" int choose(int x) { /*x为交互库选取的面包 */
    /* 你的代码 */
    return y; /* y为你选取的面包 */
}
```

特别地，当传入的 $x=0$ 时，表示是由你先选取面包。如果你 `choose(int x)` 函数返回了不合法的值，该场游戏立即结束，且结果为交互库获胜。

不停调用 `choose(int x)` 函数直到某一方胜利或平局，即该场游戏结束。接着，交互库又会调用 `newgame(bool f)` 函数，开始一场新游戏。交互库一共会调用 $1800$ 次 `newgame(bool f)` 函数，表示进行 $1800$ 场游戏。

详细可查看`template_game.cpp`。

---

在附加文件中，有以下一个文件：

`template_game.cpp`——你将在其中实现上述三个函数，内含详细注释，也包括交互库参考代码，请仔细阅读，**建议在此基础上答题**。

本地可直接在 IDE 中编译。

## 说明/提示

**保证交互库采用完全随机选取策略，即每次均会从未选取的面包中等概率选取一个面包**

$1800$ 场游戏中，有 $600$ 场是由你的程序先选取，有 $1200$ 场是由交互库先选取。

具体来说，对于第 $i$ 场游戏，若 $i \bmod 3 =0$ ，则由你的程序先选取，否则由交互库先选取。

本题首先会受到和传统题相同的限制，例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。

你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。

**本题只有一个测试点，你的得分按如下规定判定：**

设你程序获胜了 $x$ 场，平局为 $y$ 场，你最终的得分用计分函数 $f(x,y)$ 表示为：

$$
f(x,y)=\lfloor (\frac{x+y}{6}-200) \cdot \min((\frac{x}{x + y})^2+0.2,1) \rfloor
$$

最低得分为 $0$ 分。

**实际评测的交互库与下发的不相同，选手的程序应不依赖于交互库实现**。

详细可查看`template_game.cpp`。

# AI分析结果



---

**唯一算法分类**：其他搜索（博弈树搜索与记忆化）

---

### **题解思路、算法要点与解决难点**

#### **核心思路转化**
- **井字棋模型**：将面包选择转化为3x3井字棋，每个格子对应和为15的三元组。胜利条件等价于连成一行/列/对角线。
- **状态压缩**：使用三进制数表示每个面包的状态（0未选，1对手选，2己方选），哈希值唯一标识游戏状态。

#### **算法要点**
1. **预处理博弈树**：DFS深度优先遍历所有可能游戏状态，记录每个状态下的最佳决策与胜率。
2. **记忆化搜索**：用哈希表`f[state][turn]`存储状态结果，避免重复计算。
3. **胜负判定**：检查所有三元组是否满足和为15且归属同一玩家。
4. **交互实时响应**：根据当前状态哈希直接查表返回最优选择。

#### **解决难点**
- **状态爆炸**：三进制哈希将状态数压缩至3⁹=19683，可控预处理。
- **对手随机性**：对手随机选择时，需计算平均期望而非单纯Minimax。

---

### **最优思路与技巧提炼**
1. **井字棋映射**：发现原问题与井字棋的等价性，快速建立模型。
2. **状态哈希压缩**：三进制编码高效表示游戏进程。
3. **预计算博弈树**：离线计算所有可能状态，实现O(1)实时决策。

---

### **同类型题与算法套路**
- **博弈类问题**：如取石子游戏、Nim博弈等，常需预计算状态树。
- **状态压缩搜索**：适用于状态有限且可编码的交互式题目。

---

### **推荐相似题目**
1. **P1275 井字棋**：直接模拟井字棋对弈。
2. **P1510 取石子游戏**：博弈树与状态分析。
3. **P2325 三子棋（Tic-Tac-Toe）**：类似胜利条件判定。

---

### **可视化与算法演示**
#### **核心搜索动画设计**
- **网格可视化**：绘制3x3井字棋盘，格子标注对应面包编号（如2,9,4等）。
- **状态染色**：已选面包用不同颜色区分玩家（红色）与对手（蓝色）。
- **搜索过程**：以树状图动态展开预处理时的DFS路径，高亮当前访问节点。
- **音效反馈**：选择时播放8-bit点击音，胜利时播放胜利旋律。

#### **复古像素化实现**
- **Canvas绘制**：使用16色调色板，棋盘边框为像素风格。
- **自动演示模式**：AI自动执行双方最优策略，速度可调。
- **音效系统**：Web Audio API生成芯片音乐，增强沉浸感。

---

### **代码实现核心片段**
```cpp
struct st {
    int a[10]; // 状态数组，a[i]=0/1/2
    int Hash() { // 三进制压缩
        int h = 0;
        for (int i=1; i<=9; i++) h += a[i] * Pow[i-1];
        return h;
    }
    int win() { // 胜负判定
        for (int i=1; i<=9; i++) 
            for (int j=i+1; j<=9; j++) 
                for (int k=j+1; k<=9; k++)
                    if (i+j+k ==15 && a[i]==a[j] && a[j]==a[k])
                        return a[i];
        return 0;
    }
};

void dfs(int key, st x, int turn) {
    if (f[key][turn].tot) return; // 记忆化剪枝
    int res = x.win();
    if (res) { // 终止条件处理
        f[key][turn] = {res==2 ? 1 : 0, 1, 0};
        return;
    }
    // 递归搜索子状态...
}
```

---

### **结论与评分**
- **题解评分**：★★★★☆（4星，预处理逻辑清晰，但代码可读性一般）
- **关键亮点**：巧妙建模+高效预处理，实现降维打击。

---
处理用时：80.92秒
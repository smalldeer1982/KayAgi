# 题目信息

# 弹珠游戏（2021 CoE-I C）

## 题目描述

$\operatorname{Alice}$ 对弹珠游戏已经有些厌烦了，她经常在电脑上玩这个游戏。她之所以感到厌烦是因为在这个游戏上她已经是专家级别，她总是能够和电脑打成平手。$\operatorname{Bob}$ 为 $\operatorname{Alice}$ 创造了一款新的电脑游戏。以下是这款两人电脑游戏的规则：

（1）游戏在如下图所示的菱形棋盘上进行；

![](https://cdn.luogu.com.cn/upload/image_hosting/qw7lsky0.png)

（2）两名玩家轮流放置弹珠，可以在横向、纵向、$45$ 度斜线、$135$ 度斜线方向未放置弹珠的位置**连续放置 $1$ 至 $3$ 颗弹珠**，玩家在可以放置弹珠的情况下，必须至少放置 $1$ 颗弹珠。以下是合法的单次放置操作的示例（黑色圆点表示放置了弹珠，白色圆点表示未放置弹珠，进行该次操作前棋盘为空）：

![](https://cdn.luogu.com.cn/upload/image_hosting/v38tajmr.png)

以下是非法的单次放置操作的示例（黑色圆点表示放置了弹珠，白色圆点表示未放置弹珠，进行该次操作前棋盘为空）：

![](https://cdn.luogu.com.cn/upload/image_hosting/mldg0cs0.png)

非法原因的解释：（$a$）三颗弹珠不在同一条斜线（或者垂直线）上；（$b$）两颗弹珠之间相隔一个空位；（$c$）三颗弹珠不在同一条斜线上；（$d$）三颗弹珠不在同一条斜线（或者垂直线）上；（$e$）一次性放置了 $4$ 颗弹珠；（$f$）三颗弹珠不在同一条水平线（或者垂直线、或者斜线）上。

（3）如果某位玩家无法再继续放置弹珠，则该名玩家输掉游戏，另外一名玩家获胜。

$\operatorname{Alice}$ 总是第一个进行游戏，而且经常是和 $\operatorname{Bob}$ 玩这个游戏，$\operatorname{Bob}$ 在进行若干游戏操作后可能会离开，将游戏交由电脑代理，电脑总是按照最优策略放置弹珠。
给定 $\operatorname{Bob}$ 离开后的游戏状态，你的任务是确定 $\operatorname{Alice}$ 是否可能在对阵电脑时获得胜利。

## 说明/提示

#### 样例说明

第一组数据，$\operatorname{Alice}$ 可以选择在棋盘左下角的斜线方向所剩下的 $3$ 个空余位置一次性连续放置 $3$ 颗弹珠，使得后续电脑无法再放置弹珠，因此 $\operatorname{Alice}$ 能够获胜。

第二组数据，$\operatorname{Alice}$ 可以选择沿着第四行剩下的 $3$ 个空余位置一次性连续放置 $3$ 颗弹珠，使得后续电脑无法再放置弹珠，因此 $\operatorname{Alice}$ 能够获胜。

第三组数据，棋盘剩下倒数第二列两个连续的空余位置，$\operatorname{Alice}$ 可以一次放置 $2$ 颗弹珠，使得后续电脑无法放置弹珠，因此 $\operatorname{Alice}$ 会获胜。

第四组数据，类似于第二组测试数据，棋盘剩下第三行两个连续的空余位置，因此 $\operatorname{Alice}$ 会获胜。

第五组数据，棋盘只剩下两个不连续的空余位置，由于 $\operatorname{Alice}$ 一次只能选择一个空余位置放置 $1$ 颗弹珠，因此不管 $\operatorname{Alice}$ 如何操作，电脑总能一次性将剩下的棋盘使用弹珠填满，使得 $\operatorname{Alice}$ 无法再继续放置弹珠，因此 $\operatorname{Alice}$ 会输掉比赛。

第六组数据，$\operatorname{Alice}$ 可以选择在棋盘右上角斜线方向的中间两个空余位置放置 $2$ 颗弹珠，使得棋盘状态转化为样例输入的第五组数据，因此 $\operatorname{Alice}$ 会赢得比赛。


------------

#### 数据范围

对于 $10\%$ 的数据，$0 \lt T \leq 10$。

对于 $60\%$ 的数据，$0 \lt T \leq 10^3$。

对于 $80\%$ 的数据，$0 \lt T \leq 10^5$。

对于 $100\%$ 的数据，$0 \lt T \leq 10^6$。


------------

#### 提示

本题输入量较大，请使用合适的读入方式。

## 样例 #1

### 输入

```
6

   *
  * *
 * * *
* * * *
 . * *
  . *
   .

   *
  * *
 * * *
. . . *
 * * *
  * *
   *

   *
  * *
 * * .
* * * *
 * * .
  * *
   *

   *
  * *
 . . *
* * * *
 * * *
  * *
   *

   .
  * *
 * * *
* * * .
 * * *
  * *
   *

   .
  * .
 * * .
* * * .
 * * *
  * *
   *```

### 输出

```
Possible.
Possible.
Possible.
Possible.
Impossible.
Possible.```

# AI分析结果



---

### 算法分类  
**DFS**  

---

### 题解思路与难点分析  

#### 核心思路  
所有题解均采用 **状态压缩 + 记忆化 DFS** 预处理所有棋盘状态的胜负情况。将棋盘转化为 16 位二进制数（1 表示已放置弹珠，0 表示未放置），通过 DFS 递归判断每个状态是否为必胜态。  

#### 解决难点  
1. **棋盘方向处理**：菱形棋盘旋转 45° 后映射为 4x4 方格，方便处理横、竖、斜线方向。  
2. **状态转移**：对于每个空位，检查四个方向（右、下、右下、左下）是否能连续放置 1-3 颗弹珠，生成新状态并递归判断。  
3. **记忆化优化**：通过 `cache` 数组存储已计算状态的胜负，避免重复计算。  

#### 题解对比  
| 题解作者 | 亮点 | 难点处理 | 优化策略 |  
|----------|------|----------|----------|  
| cmll02   | 直接打表压缩 | 旋转棋盘处理方向 | 二进制分块压缩表数据 |  
| metaphysis | 快读优化输入 | 坐标映射与方向遍历 | 递归备忘录剪枝 |  
| youngk   | SG 函数理论 | 预处理移动边界 | 枚举子状态求 MEX |  

---

### 题解评分（≥4星）  

1. **cmll02（5星）**  
   - 亮点：极致的空间优化，通过二进制分块压缩表数据，实现 O(1) 查询。  
   - 代码：高效预处理 + 快速 IO，适合大规模数据。  

2. **metaphysis（4星）**  
   - 亮点：清晰的递归逻辑 + 快读优化，适合教学理解。  
   - 代码：标准记忆化搜索实现，可读性强。  

3. **cirnovsky（4星）**  
   - 亮点：预生成合法移动表，简化状态转移判断。  
   - 代码：通过预计算 82 种移动模式，快速枚举子状态。  

---

### 最优技巧提炼  

1. **状态压缩**：将棋盘映射为 16 位二进制数，快速判断状态唯一性。  
2. **记忆化剪枝**：通过 `cache` 数组避免重复计算，时间复杂度降至 O(2^16)。  
3. **方向统一处理**：旋转棋盘后，所有方向转化为水平/垂直方向，简化代码逻辑。  

---

### 同类型题推荐  

1. **P2148 [SDOI2009] E&D**（SG 函数应用）  
2. **P2963 [USACO09NOV] Coin Game**（状态压缩博弈）  
3. **P3185 [HNOI2007] 分裂游戏**（组合游戏 SG 函数）  

---

### 可视化算法演示  

#### 动画设计  
- **节点表示**：棋盘状态用 4x4 网格展示，已放置弹珠为黑色方块，未放置为白色。  
- **搜索过程**：  
  1. **当前状态**：高亮显示当前处理的空位（红色边框）。  
  2. **方向检查**：用箭头动态演示四个方向的连续放置可能性。  
  3. **递归分支**：每次生成新状态时，以淡入效果展示子棋盘，并用颜色区分胜负（绿色必胜，红色必败）。  
- **回溯标记**：递归返回时，更新当前状态颜色，并显示缓存结果。  

#### 复古像素风格  
- **8 位音效**：  
  - 访问新节点：短促 "哔" 声（Web Audio 生成方波）。  
  - 找到必胜态：上升音阶（C 大调三连音）。  
- **Canvas 绘制**：棋盘用 32x32 像素块，弹珠为 8x8 圆点，方向箭头用像素线条。  

#### 自动演示模式  
- **AI 决策**：按 DFS 顺序自动遍历状态，用户可调节速度（0.5x~4x）。  
- **关卡模式**：将 65536 状态分为 10 关，通关显示预处理进度。  

---

### 核心代码片段（DFS 逻辑）  

```cpp  
// metaphysis 题解核心代码  
int dfs(int x) {  
    if (~cache[x]) return cache[x];  
    for (int i = 0; i < 16; i++) {  
        if (x & (1 << i)) continue;  
        int r = i / 4, c = i % 4;  
        for (int j = 0; j < 4; j++) { // 四个方向  
            int bit = 0;  
            for (int k = 0; k < 3; k++) { // 连续 1-3 颗  
                int rr = r + offset[j][0] * k;  
                int cc = c + offset[j][1] * k;  
                if (越界或已放置) break;  
                bit |= (1 << (rr * 4 + cc));  
                if (!dfs(x | bit)) return cache[x] = 1;  
            }  
        }  
    }  
    return cache[x] = 0;  
}  
```  

---

### 个人心得  

- **坐标映射陷阱**：原题棋盘为菱形，需通过旋转转换为 4x4 方格，否则方向判断极易出错。  
- **打表优化**：cmll02 的二进制分块将 65536 位表压缩为 21845 字节，解决代码长度限制。  
- **剪枝关键**：若存在任一子状态为必败，立即返回必胜，无需遍历全部可能性。

---
处理用时：105.38秒
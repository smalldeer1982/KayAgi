# 题目信息

# 「Wdoi-6」最澄澈的空与海

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/hiekh6t5.png)](https://thwiki.cc/%E5%8D%AF%E9%85%89%E4%B8%9C%E6%B5%B7%E9%81%93_%EF%BD%9E_Retrospective_53_minutes.)

广重号载着二人向东飞驰。毫无噪音，毫无摇摆，只是一个劲向东飞驰。在“万景幕”装置之下，尽管是全地下的卯酉东海道，乘客们也能饱览美丽的富士山和太平洋的景色。

但是，从这列卯酉新干线『广重』上看到的极富日本风味的美丽情景，对于梅莉来说，只不过是无趣的视觉刺激罢了。高动态范围的影像也好，极富日本风味的情景也好，都敌不过真正的天空的颜色。

身与华落，心将香飞。即便肉体会像花朵一样终有一天凋落，但心却可以如花香一般飘往远方。

「梅莉，你看，天上的星星呦。」

## 题目描述

### 简要题意

给定 $2n$ 个点、$m$ 条边的[二分图](http://oi-wiki.com/graph/bi-graph/#_1)（可能有重边），左部点与右部点个数相同，判断其完美匹配数量是否**恰好**为 $1$。是则输出 `Renko`，否则输出 `Merry`。

> **注**：完美匹配是指，从边集中选出 $n$ 条边，这些边的顶点组成的点集恰好覆盖了所有的 $2n$ 个点。

---
### 原始题意

在夜里，莲子与梅莉来到了东京的海边，躺在沙滩上，欣赏着澄澈的天空与大海，数起了天上的星星。

在这些星星之中，有 $n$ 个星星 $\{a_i\}$，是莲子先发现的，被称为莲子星；而又有 $n$ 个星星 $\{b_i\}$，是梅莉先发现的，被称为梅莉星。由于她们心有灵犀，这两批星星之间**不存在交集**。  

她们发现，有一些莲子星，与一些梅莉星之间恰好存在运动关系。具体而言，这些关系一共有 $m$ 组，每一组关系形如 $(u_i,v_i)$，也就是说第 $u_i$ 颗莲子星与第 $v_i$ 颗梅莉星之间存在运动关系。这些运动关系有可能重复。

这让莲子和梅莉非常好奇。作为专攻超统一物理学的女大学生，莲子认为，如果认为这些星星的运动是**和谐**的，那么她应当能够从这 $m$ 个运动关系中，找出若干个运动关系，使得**每颗**星星**都被**这些运动关系**包含**的同时，不会有一颗星星**被包含在两个**运动关系之中。

然而，梅莉认为，**和谐**的运动可能是不存在的，更何况即使莲子找到了**和谐**的运动，莲子也无法确保这种和谐运动的**唯一性**。两种和谐运动不同，当且仅当选取出的两组运动关系中，存在至少一个运动关系，是不相同的。

因为意见不合，她们于是打情骂俏了一顿。莲子于是记下了她们所看到了星星和她们之间的运动关系，并且找到了已经证明了 P=NP 的你，希望你能告诉她们，最后是谁正确呢？

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/6skoily9.png)

如图所示，存在唯一的方案：$\{1\to 1,2\to 5,3\to 2,4\to 3,5\to 4\}$。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \bm{m\le} & \textbf{\textsf{特殊性质}} & \textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 10 & 10 & - & - \cr\hline
2 & 20 & 300 & 4\times 10^4 & - & 1\cr\hline
3 & 20 & 10^5 & 5 \times 10^5 & \mathbf{A} & - \cr\hline
4 & 20 & 10^5 & 2 \times 10^5 & \mathbf{B} & - \cr\hline
5 & 30& 10^6 & 2\times 10^6 & - & 2,3,4 \cr\hline
\end{array}
$$

- 特殊性质 $\mathbf{A}$：保证对于第 $i$ 颗莲子星，与第 $i$ 颗梅莉星之间存在运动关系。
- 特殊性质 $\mathbf{B}$：保证 $m=2n-1$。

对于 $100\%$ 的数据，保证 $1 \le u_i,v_i\le n \le 10^6$，$1 \le m \le 2 \times 10^6$，$1 \leq T \leq 5$ 且对于每个测试点，$\sum m \leq 4 \times 10^6$。

对于 $\rm Subtask\ 5$，时间限制为 $3$ 秒。其它测试点时间限制为 $1$ 秒。

## 样例 #1

### 输入

```
1
5
6
1 1
1 3
3 2
2 5
4 3
5 4```

### 输出

```
Renko```

# AI分析结果



## 算法分类选择  
**BFS**  

---

## 题解思路、算法要点与解决难点  

### 核心思路  
所有题解均基于关键结论：**当且仅当图中存在度数为1的节点时，才可能有唯一完美匹配**。算法通过类似拓扑排序的 BFS 流程，反复删除度数为1的节点及其唯一匹配节点，最终判断是否所有节点都被删完。  

### 解决难点  
1. **数学证明**：证明当所有节点度数≥2时，完美匹配要么不存在要么不唯一。  
2. **高效处理**：用队列维护度数为1的节点，避免重复遍历图结构。  
3. **动态更新**：删除节点时需更新邻接节点的度数，并触发新的入队条件。  

---

## 题解评分 (≥4星)  

### retep (⭐⭐⭐⭐⭐)  
- **亮点**：代码结构清晰，用队列处理左右部对称逻辑，完美匹配的「锁死」机制直观  
- **代码**：显式维护邻接表和入度数组，通过 `del[]` 标记删除状态  

### Cocoly1990 (⭐⭐⭐⭐)  
- **亮点**：严格数学归纳证明，强调「简单环必然导致多解」  
- **代码**：使用双向量存图，左右部统一编号  

### minstdfx (⭐⭐⭐⭐)  
- **亮点**：用双端队列优化删除顺序，显式维护度数数组  
- **代码**：分离左右部逻辑，通过 `vis[]` 标记已处理节点  

---

## 最优思路或技巧提炼  
1. **拓扑式删点**：用 BFS 队列处理度数为1的节点，类似拓扑排序  
2. **锁死匹配**：度数为1的节点必须与唯一邻接点匹配，两者同时删除  
3. **邻接表优化**：存边时左右部统一编号（右部点编号+n），简化删除逻辑  

---

## 同类型题或类似算法套路  
- **拓扑排序应用**：检测有向图环、课程表问题（LeetCode 207）  
- **唯一性判定**：最小生成树唯一性、最短路径唯一性  

---

## 推荐相似题目  
1. [P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)  
2. [P2146 [NOI2015] 软件包管理器](https://www.luogu.com.cn/problem/P2146)（拓扑思想）  
3. [P1351 联合权值](https://www.luogu.com.cn/problem/P1351)（图度数分析）  

---

## 个人心得摘录  
> "每次找到入度为1的节点太耗时间了，可以考虑类似拓扑排序的做法" —— retep  
> "多测不清空，爆零两行泪" —— Kevin_Mamba  
> "度数为1的节点显然唯一确定匹配" —— _www_  

---

## 可视化与算法演示  

### 动画方案  
1. **初始状态**：左右部节点以不同颜色区分，边以灰色线条表示  
2. **删除过程**：  
   - 红色高亮当前度数为1的节点  
   - 绿色标记其唯一邻接点  
   - 删除两者后，蓝色标记被触发的新的度数为1节点  
3. **队列状态**：右侧显示当前队列中的待处理节点  

### 复古游戏化设计  
- **像素风格**：  
  - 左部节点：蓝色方块（8x8像素）  
  - 右部节点：黄色方块  
  - 边：白色像素线  
- **音效**：  
  - 删除节点：短促「滴」声  
  - 成功匹配：上升音阶  
- **自动演示**：按空格键逐步执行 BFS 流程  

---

## 核心代码实现（retep 题解）  
```cpp
queue<int> q; cnt=0;
for(int i=1;i<=2*n;i++)
    if(in[i]==1) q.push(i);
while(!q.empty()){
    int now = q.front(); q.pop();
    if(del[now] || in[now]!=1) continue;
    del[now] = true; cnt++;
    int buf = 0;
    while(del[to[now][buf]]) buf++;
    int match = to[now][buf];
    del[match] = true; cnt++;
    for(int v : to[match]){
        if(!del[v] && (--in[v])==1)
            q.push(v);
    }
}
```

---

## 可视化设计要点  
```javascript
// Canvas 绘制示例（伪代码）
function drawGraph() {
    ctx.clearRect(0, 0, width, height);
    // 绘制边
    edges.forEach(edge => {
        if (!edge.deleted) drawPixelLine(edge.u, edge.v);
    });
    // 绘制节点
    nodes.forEach(node => {
        if (node.deleted) return;
        drawPixelSquare(node.x, node.y, node.color);
    });
    // 高亮当前处理节点
    if (currentNode) {
        drawHighlight(currentNode, 'red');
        let match = findMatch(currentNode);
        drawHighlight(match, 'green');
    }
}
```

---
处理用时：80.06秒
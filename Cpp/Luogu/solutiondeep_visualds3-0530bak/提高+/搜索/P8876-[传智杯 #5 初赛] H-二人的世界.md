# 题目信息

# [传智杯 #5 初赛] H-二人的世界

## 题目背景

莲子设计了一个三维立体空间软件。这个软件可以模拟真实的物理引擎，包括实体方块和水流方块。然而，同时计算大量水流会对软件造成不小的负荷。

于是，莲子希望找到这样一种算法，快速计算这些水流模拟后的结果。

## 题目描述

莲子设计的水流模型是这样的：

考虑一个三维空间。这个空间内有 $n$ 个正方体。我们使用坐标 $(x_i,y_i,h_i)$ 描述每个正方体的位置。这些正方体，可以被称作**实体方块**。

![](https://cdn.luogu.com.cn/upload/image_hosting/sotibgh2.png)

现在将会在这张图中模拟一种水流机制。具体而言，我们会定义**水方块**。水方块会有一个强度 $s$，范围是 $[1,k]$。

### 运行逻辑

- 假定 $(x,y,h)$ 处有强度为 $s$ 的水方块，且 $(x,y,h-1)$ 位置没有实体方块，那么下一时刻 $(x,y,h-1)$ 位置会生成强度为 $k$ 的水方块。**注意**：无论此时 $s$ 的值是多少，在 $(x,y,h-1)$ 位置生成的水方块的强度都是 $k$。
- 假定 $(x,y,h)$ 处有强度为 $s$ 的水方块，且 $s>1$，且 $(x,y,h-1)$ 位置有实体方块，那么会进行**扩散操作**。
- 如果下一时刻，某个位置 $(x,y,h)$ 同时有多个水方块会生成，那么最终生成的水方块的强度，是这些可能生成的水方块里，最大的强度。

![](https://cdn.luogu.com.cn/upload/image_hosting/mn8iqp4l.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/suq9jiqx.png)

### 扩散操作

**考虑到扩散操作比较抽象，建议结合图示理解**。

对于水方块 $(x,y,h)$，它会在高度 $h$ 的平面上进行寻路。为了考虑这个过程，我们考虑这个高度为 $h$ 的平面：

- 如果空间里 $(x,y,h)$ 位置有实体方块存在，那么平面上 $(x,y)$ 处**不可经过**。否则，如果没有实体方块，那么 $(x,y)$ 处**可以经过**。
- 在 $(x,y)$ **可以经过**的情况下，如果空间里 $(x,y,h-1)$ 位置没有实体方块存在，那么平面上 $(x,y)$ 位置称为**目标位置**。目标位置可以不止一个。

根据扩散的前提条件，可知平面上 $(x,y)$ 位置可以经过，但不是目标位置。

从平面上 $(x,y)$ 处出发，进行路径的搜索。每次在 $(a,b)$ 位置会向 $(a+1,b),(a-1,b),(a,b+1),(a,b-1)$ 位置扩展。搜索过程会找到距离 $(x,y)$ 位置**最近**的，且距离不超过 $s-1$ 的**所有**目标位置，或者找不到这样的目标位置。

- 如果存在这样的目标位置，那么在到达目标位置的最短路的方向上，下一时刻会生成一个强度为 $s-1$ 的水方块。
- 如果不存在这样的目标位置，那么下一时刻，会向 $(x+1,y),(x-1,y),(x,y+1),(x,y-1)$ 位置都生成强度为 $s-1$ 的水方块（如果这个位置可以到达的话）。

请结合图示理解扩散过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/9sw2uf0u.png)

如图所示。$S$ 处是平面上该水方块所在的位置。白色的方块是目标位置，打 $\times$ 的方块是不可经过的位置。我们计算出 $S$ 到达最近的目标位置的最小值 $d_{\min}=5$，图中标出来的**红色路径**就是三条可能的最短路。

如果 $s>5$，那么下一时刻，在**蓝色箭头**处会有强度为 $s-1$ 的水方块生成。否则，若 $5\ge s>1$，那么下一时刻除了蓝色箭头外，灰色路径对应的方向**也会生成**强度为 $s-1$ 的水方块。

---

为了检验水流模型的合理性以及其运行效率，莲子提出了这个问题：在 $(x_0,y_0,10^9+1)$ 处，有一个强度为 $k$ 的水方块。询问：在经过充分长的时间后（比如经过了 $10^{9961^{9961}}$ 时刻），有多少个点对 $(a,b)$，满足在 $(a,b,-1)$ 位置，会有水方块生成过。

## 说明/提示

### 样例 1 解释

（图片实在太难画啦，将就一下吧。）为了防止方块阻挡导致看不见，方块全部换成了透明的。

![](https://cdn.luogu.com.cn/upload/image_hosting/i94wjdgb.png)

初始状态下一根水流柱从高空落下，落在了方块 $(3,4,2)$ 上，进行了扩散。水方块的坐标为 $(3,4,3)$，强度为 $3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/e8d9vtl8.png)

- 如图 $3$，根据寻路机制，它会在 $(3,5,3)$ 和 $(4,4,3)$ 上生成强度为 $2$ 的水方块。
- 如图 $4$，生成的两个支流下方都没有方块，于是在 $(3,5,2)$ 和 $(4,4,2)$ 上生成强度为 $3$ 的水方块。
- 如图 $5$，水方块 $(3,5,2)$ 下方依旧没有实体方块，于是在 $(3,5,1)$ 生成了强度为 $3$ 的水方块，一直流到 $(3,5,-1)$；水方块 $(4,4,2)$ 下方有实体方块，于是在 $(4,3,2)$ 生成了强度为 $2$ 的水方块。

![](https://cdn.luogu.com.cn/upload/image_hosting/g5n7min2.png)

下面只关心水方块 $(4,3,2)$。它下面有实体方块 $(4,3,1)$，于是它向两边扩散，生成强度均为 $1$ 的两个水方块。这两个方块下面都不再有实体方块，于是**一直往下流**到 $(4,2,-1)$ 和 $(5,3,-1)$。

因此，最终一共会有三个位置 $(3,5,-1)$、$(4,2,-1)$、$(5,3,-1)$ 有水方块经过。

### 数据范围及约定

对于所有数据，$1\le n\le 10^5$，$1\le k\le 10^9$，$0\le |x_i|,|y_i|\le 10^9$，$0\le h_i\le 10^9$。

## 样例 #1

### 输入

```
8 3 3 4
4 3 1
4 4 1
3 3 2
3 4 2
4 5 2
5 4 2
2 4 3
4 1 4
```

### 输出

```
3
```

## 样例 #2

### 输入

```
8 2 3 4
4 3 1
4 4 1
3 3 2
3 4 2
4 5 2
5 4 2
2 4 3
4 1 4
```

### 输出

```
1```

# AI分析结果



---

**唯一算法分类**：BFS

---

### **综合分析与结论**

本题核心在于模拟三维空间中的水流扩散，需高效处理实体方块阻挡与水流路径选择。**难点**在于：  
1. 水流扩散规则复杂，需处理不同强度下的最短路径选择。  
2. 直接逐层模拟时间复杂度爆炸，需优化为按实体方块高度分层处理。  

**核心思路**：  
- **按高度降序处理**：实体方块按高度从高到低排序，确保水流自上而下扩散。  
- **预处理最短距离**：对每个高度层，BFS预处理所有可能目标位置（可流向下层的位置），计算其他位置到目标的最短距离。  
- **队列驱动扩散**：根据预处理的最短距离，判断水流扩散方向，避免重复搜索。  

**可视化设计思路**：  
- **动画方案**：以网格展示各层平面，BFS预处理时显示目标位置（绿色）和最短距离（渐变色）。水流扩散时，高亮当前处理节点（红色），扩散方向箭头（蓝色）。  
- **步进控制**：允许单步执行，观察队列处理顺序与预处理过程。  
- **音效提示**：访问新节点时播放“滴答”声，找到目标位置时播放水流声。  

---

### **题解清单 (≥4星)**

1. **离散小波变换°（5星）**  
   - **亮点**：利用分层处理与BFS预处理最短距离，时间复杂度优化至O(n log n)。  
   - **关键代码**：按实体方块高度降序处理，预处理目标位置后扩散。  
   - **个人心得**：通过枚举实体方块而非水流位置，避免无效遍历，显著提升效率。  

---

### **核心代码实现**

```cpp
// 按高度降序处理实体方块
sort(I + 1, I + 1 + n, cmp);
for (int i = 1; i <= n; ) {
    int h = Z[I[i]];
    queue<Pos2> P, Q;
    // 收集当前高度的实体方块
    for (int j = i; j <= n && Z[I[j]] == h; ++j) {
        int o = I[j], x = X[o], y = Y[o];
        Pos2 u(x, y);
        if (W.count(u)) {  // 当前实体方块上有水流
            P.push(u);      // 加入扩散队列
            K[u] = p;       // 记录强度
            W.erase(u);     // 移除当前水流
        }
        // 检查四周是否为目标位置
        for (int k = 0; k < 4; ++k) {
            int nx = x + DIR[k][0], ny = y + DIR[k][1];
            Pos2 v(nx, ny);
            if (!V.count(v) && !B.count(Pos3(nx, ny, h)) 
                && !B.count(Pos3(nx, ny, h + 1))) {
                V[v] = true;
                D[v] = 0;   // 最短距离初始化为0
                Q.push(v);  // 目标位置入队
            }
        }
    }
    // BFS预处理最短距离
    while (!Q.empty()) {
        Pos2 u = Q.front(); Q.pop();
        for (int k = 0; k < 4; ++k) {
            int nx = u.x + DIR[k][0], ny = u.y + DIR[k][1];
            Pos2 v(nx, ny);
            if (B.count(Pos3(nx, ny, h)) && !B.count(Pos3(nx, ny, h + 1))) {
                if (!D.count(v)) {
                    D[v] = D[u] + 1;
                    Q.push(v);
                }
            }
        }
    }
    // 处理扩散队列
    while (!P.empty()) {
        Pos2 u = P.front(); P.pop();
        int s = K[u], d = D[u];
        if (s == 1) continue;
        for (int k = 0; k < 4; ++k) {
            int nx = u.x + DIR[k][0], ny = u.y + DIR[k][1];
            Pos2 v(nx, ny);
            if (D.count(v) && D[v] == d - 1 && !K.count(v)) {
                K[v] = s - 1;
                P.push(v);  // 扩散到相邻位置
            }
        }
    }
}
```

---

### **同类型题与相似套路**

- **分层BFS**：如迷宫中的水位上升问题（LeetCode 778）。  
- **最短路径预处理**：在网格中预处理关键点距离，加速后续查询，如多源BFS。  

---

### **推荐题目**

1. **洛谷 P1443**：马的遍历（BFS基础）  
2. **洛谷 P1162**：填涂颜色（BFS扩散）  
3. **洛谷 P1902**：刺杀大使（分层BFS+二分）  

---

### **可视化与复古游戏化**

- **8位像素风格**：实体方块为灰色像素，水流为蓝色流动动画，目标位置闪烁绿光。  
- **AI自动演示**：按高度逐步渲染，扩散时箭头动态延伸，伴随8-bit音效。  
- **控制面板**：速度滑块调节BFS帧率，暂停/继续按钮控制流程。  

---

通过分层处理与预处理优化，本题将复杂的三维水流模拟转化为高效的分层BFS问题，结合游戏化可视化，可直观理解算法核心。

---
处理用时：88.31秒
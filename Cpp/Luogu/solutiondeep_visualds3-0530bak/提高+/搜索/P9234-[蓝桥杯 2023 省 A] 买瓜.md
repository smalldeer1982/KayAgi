# 题目信息

# [蓝桥杯 2023 省 A] 买瓜

## 题目描述

小蓝正在一个瓜摊上买瓜。瓜摊上共有 $n$ 个瓜，每个瓜的重量为 $A_i$。小蓝刀功了得，他可以把任何瓜劈成完全等重的两份，不过每个瓜只能劈一刀。

小蓝希望买到的瓜的重量的和恰好为 $m$。

请问小蓝至少要劈多少个瓜才能买到重量恰好为 $m$ 的瓜。如果无论怎样小蓝都无法得到总重恰好为 $m$ 的瓜，请输出 $-1$。

## 说明/提示

#### 【评测用例规模与约定】

对于 $20 \%$ 的评测用例，$n \leq 10$;

对于 $60 \%$ 的评测用例，$n \leq 20$;

对于所有评测用例，$1 \leq n \leq 30$，$1 \leq A_i \leq 10^9$，$1 \leq m \leq 10^9$。

## 样例 #1

### 输入

```
3 10
1 3 13```

### 输出

```
2```

# AI分析结果



---

## 算法分类  
其他搜索（折半搜索）

---

## 题解思路与解决难点  
### 核心思路  
1. **折半搜索**：将n个瓜分为前后两半，分别搜索可能的重量组合及对应劈瓜次数  
2. **哈希表优化**：存储前半部分搜索结果，后半部分搜索时查表合并  
3. **整数化处理**：将m和瓜重×2避免浮点运算  
4. **剪枝策略**：  
   - 当前总重>m时停止搜索  
   - 当前劈瓜次数≥已知最优解时剪枝  
   - 按瓜重降序排序加速剪枝  

### 搜索过程要点  
- **状态转移**：每个瓜有三种状态（不买/买整个/买半个）  
- **哈希表结构**：key为总重量，value为最小劈瓜次数  
- **合并策略**：后半部分搜索到重量w时，查找前半部分是否存在m-w的键  

### 可视化设计  
1. **像素动画**：  
   - 用8-bit像素风格绘制瓜堆，劈瓜时显示刀光特效  
   - 左右分屏显示前后半搜索过程，匹配成功时触发闪光  
2. **音效系统**：  
   - 搜索新节点时播放"哔"声  
   - 找到可行解时播放经典FC过关音效  
   - 哈希表命中时播放金币音效  

---

## 题解评分（≥4星）  
### 1. ivyjiao（5星）  
- **亮点**：多次迭代优化，最终采用排序+手写哈希表+后缀和剪枝  
- **代码**：调整折半点位，预处理后缀和加速可行性判断  
```cpp
// 核心搜索片段（后半部分）
void HG(int G,int J,int sum){
    if(sum>m||J>ans) return;
    if(sum==m) ans = min(ans, PII[m-sum] + J);
    if(G==n+1){
        if(PII.count(m-sum)) 
            ans = min(ans, J + PII[m-sum] -1);
        return;
    }
    HG(G+1,J,sum+a[G]); // 买整个
    HG(G+1,J+1,sum+a[G]/2); // 买半个
    HG(G+1,J,sum); // 不买
}
```

### 2. helintai（4.5星）  
- **亮点**：清晰的折半实现，注释详细，使用快读优化  
- **代码**：标准折半模板，排序后倒序搜索加速剪枝  

### 3. Genius_Star（4星）  
- **亮点**：位运算压缩状态，手写哈希表避免STL开销  
- **代码**：三进制状态枚举，二进制分块处理  

---

## 最优技巧提炼  
1. **整数化转换**：将m×2并存储瓜重×2，消除浮点运算  
2. **后缀和剪枝**：预处理后缀和快速判断剩余瓜能否满足需求  
3. **动态折半点**：根据数据规模动态调整分割点（如n/2+1）  
4. **哈希表双模式**：前半存储时value+1，后半查询时value-1避免重复计数  

---

## 同类题目推荐  
1. P3067 [USACO12OPEN] Balanced Cow Subsets G  
2. P4799 [CEOI2015 Day2] 世界冰球锦标赛  
3. P2320 [HNOI2006] 鬼谷子的钱袋  

---

## 个人心得摘录  
> "从第一次提交到AC共提交135次...关键在于意识到哈希表的查询效率瓶颈，最终手写哈希表才通过" —— ivyjiao  
> "排序后倒序搜索能让大瓜优先触发sum>m的剪枝" —— Bamboo_Day  

---

## 可视化代码片段  
```javascript
// 像素化搜索动画核心逻辑
class SearchAnim {
  constructor() {
    this.queue = [] // 待搜索节点队列
    this.visited = new Set() // 已访问节点
  }

  step() {
    let node = this.queue.shift()
    this.highlight(node) // 高亮当前节点
    let neighbors = this.getNeighbors(node)
    neighbors.forEach(n => {
      if(!this.visited.has(n)) {
        this.queue.push(n) // BFS式入队
        this.drawSlashEffect(n) // 绘制刀光特效
      }
    })
  }
}
```

---

## 复古游戏化设计  
1. **关卡系统**：  
   - 第1关：n=10的样例，教学基本操作  
   - 第5关：n=20，解锁"加速搜索"技能  
   - BOSS关：n=30，需要连续命中哈希表5次  
2. **音效设计**：  
   - 搜索音效：8-bit版《野蜂飞舞》片段  
   - 胜利音效：FC《超级马里奥》过关旋律  
3. **成就系统**：  
   - "一刀两断"：单次搜索命中3个剪枝  
   - "哈希大师"：连续10次哈希查询命中缓存  

--- 

通过结合深度剪枝策略与游戏化交互，将复杂的搜索过程转化为直观的视觉体验，帮助理解折半搜索的核心机制。

---
处理用时：111.61秒
# 题目信息

# [YsOI2023] 广度优先遍历

## 题目背景

Ysuperman 模板测试的图论题。

【数据删除】

## 题目描述

今天的模板测试是无向图上的广度优先遍历，【数据删除】马上写好了代码：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
const int maxn = 100005;
vector<int> G[maxn];
queue<int> q;
int pa[maxn];
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; ++i)
    {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    memset(pa, -1, sizeof pa);
    q.push(1);
    pa[1] = 0;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (auto v : G[u])
        {
            if (pa[v] != -1)
                continue;
            pa[v] = u;
            q.push(v);
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        cout << pa[i];
        if (i != n)
            cout << " ";
    }
    cout << endl;
    return 0;
}
```

如你所见，这份代码会输入一个 $n$ 个点 $m$ 条边的无向图，并且求出这张图以 $1$ 为根的一棵“广度优先遍历树”，最后输出所有点的父亲节点编号。

不过值得注意的是，这棵“广度优先遍历树”的具体形态和“边的输入顺序”有关，也就是说，不同的输入顺序可能会得到不同的父亲节点编号。

现在【数据删除】告诉了你 $n,m$、这 $m$ 条边以及在某个“边输入顺序”情况下他的代码的输出，你需要还原出这个“边输入顺序”。如果有多种边输入顺序对应的都是这样的输出，你**只需要输出其中任意一种**即可。

特别的，保证有解，且无向图连通，无自环（但是有可能有重边）。

## 说明/提示

#### 样例 1 解释

直接运行【数据删除】的代码即可。

如果不改变边输入顺序，将下面数据输入【数据删除】的代码：

```
4 4
2 1
1 3
2 4
4 3
```

他的代码跑出来结果如下：

```
0 1 1 2
```

如果按照样例 1 输出给出的顺序，即，将下面数据输入他的代码：

```
4 4
1 3
3 4
1 2
2 4
```

输出为：

```
0 1 1 3
```

#### 数据范围

对于前 $10\%$ 的数据，满足 $n\le 8$，$m\le 10$。

对于前 $40\%$ 的数据，满足 $n\le 1000$，$m\le 2000$。

另有 $10\%$ 的数据，满足 $m=n-1$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$1\le m\le 2\times 10^5$。

#### 提示

为什么有可能会有重边，因为懒得去重了，这个家伙出图论题就是懒得判重边的（）

附件下发了本题 checker。

## 样例 #1

### 输入

```
4 4
2 1
1 3
2 4
4 3
0 1 1 3```

### 输出

```
1 3
3 4
1 2
2 4
```

## 样例 #2

### 输入

```
8 9
7 8
6 1
5 4
7 1
4 1
3 7
2 6
7 5
2 4
0 6 7 1 4 1 1 7```

### 输出

```
6 2
7 3
4 5
1 6
7 8
1 4
1 7
2 4
5 7```

# AI分析结果



## 算法分类
**BFS**

---

## 综合分析与结论

### 核心思路与难点
1. **核心逻辑**：通过给定的 BFS 树反推边的输入顺序。关键点在于处理以下两类约束：
   - **树边必须优先于非树边**：BFS 遍历时，树边对应的父节点会先被访问
   - **非树边的偏序约束**：若存在非树边连接深度差为 1 的节点，需保证其父节点所在路径的边输入顺序优先

2. **算法难点**：
   - **LCA 处理**：找到非树边两端点在 BFS 树上的最近公共祖先，确定边顺序约束
   - **拓扑排序**：将所有约束转化为 DAG 的边，通过拓扑排序确定可行输入顺序

3. **解决方案**：
   - 预处理 BFS 树各节点的父节点与深度
   - 对每条非树边分析其约束关系，建立有向边表示输入顺序的先后
   - 对树边和非树边进行拓扑排序输出

---

## 题解评分 (≥4星)

### 1. [xiaolilsq] ★★★★★
- **关键亮点**：
  - 提出非树边连接相邻层的约束关系，建立偏序图进行拓扑排序
  - 通过 LCA 分析确定约束的精确范围，避免冗余边
  - 代码结构清晰，附有详细注释与示例解释

### 2. [yxzy4615] ★★★★☆
- **关键亮点**：
  - 线性时间复杂度解法，直接继承父节点的优先级
  - 利用队列动态维护入度，避免显式建图
  - 代码简洁高效，适合处理大规模数据

### 3. [RsCb] ★★★★☆
- **关键亮点**：
  - 将边视为 DAG 结点，通过比较 LCA 后代路径建立边顺序
  - 使用排序优化处理重边问题
  - 附有详细图示解释非树边约束类型

---

## 最优思路与代码实现

### 关键代码片段（基于 xiaolilsq 题解）
```cpp
// 预处理 BFS 树
void dfs(int u, int fa) {
    f[u][0] = fa;
    for (int i = 1; i <= 20; ++i)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for (int v : G[u]) if (v != fa) dfs(v, u);
}

// 建立偏序约束
for (auto [u, v] : non_tree_edges) {
    if (dep[u] != dep[v] + 1) continue;
    int x = u, y = fa[v];
    for (int i = 20; i >= 0; --i) {
        if (f[x][i] != f[y][i])
            x = f[x][i], y = f[y][i];
    }
    add_constraint(fa[x], fa[y]); // 添加边顺序约束
}

// 拓扑排序输出
queue<int> q;
for (int i = 1; i <= m; ++i)
    if (in[i] == 0) q.push(i);
while (!q.empty()) {
    int u = q.front(); q.pop();
    output_edge(u);
    for (int v : dag[u])
        if (--in[v] == 0) q.push(v);
}
```

---

## 同类型题与算法套路

### 通用解法
- **BFS 树约束**：处理由 BFS 遍历顺序生成的树结构约束
- **拓扑排序应用**：将偏序关系转化为 DAG 的边，通过拓扑排序输出合法序列
- **LCA 技巧**：快速定位树中节点的公共祖先，简化约束分析

---

## 推荐题目
1. **P1137 旅行计划** - BFS 拓扑排序应用
2. **P1347 排序** - 偏序关系与拓扑排序
3. **P1608 路径统计** - BFS 最短路径计数

---

## 可视化设计

### BFS 搜索过程动画
1. **节点状态标记**：
   - 红色：当前处理节点
   - 绿色：队列中待处理节点
   - 灰色：已访问节点

2. **队列操作可视化**：
   - 左侧显示队列元素，动态展示节点入队/出队
   - 右侧画布展示图结构，高亮当前处理的边

3. **复古像素风格**：
   - 使用 16 色 palette（如 NES 经典配色）
   - 节点绘制为 16x16 像素方块，边为黄色像素线
   - 音效设计：
     - 节点入队：短促 "beep" 音
     - 边输出：8-bit "click" 音

### 交互演示
- **AI 自动模式**：自动执行 BFS 步骤，间隔 500ms
- **手动控制**：支持暂停/继续/单步调试
- **调试面板**：显示当前队列状态、已输出边列表

---

## 核心代码（完整实现）
```cpp
// 完整代码参见 xiaolilsq 题解，此处展示关键拓扑排序部分
void topo_sort() {
    queue<int> q;
    for (int i = 1; i <= m; ++i)
        if (in[i] == 0) q.push(i);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        cout << edges[u].first << " " << edges[u].second << endl;
        for (int v : dag[u]) {
            if (--in[v] == 0)
                q.push(v);
        }
    }
}
```

---
处理用时：85.86秒
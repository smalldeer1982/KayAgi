# 题目信息

# [EC Final 2022] Chinese Checker

## 题目描述

棋盘上有 $n$ 个棋子，你需要求对于当前局面，下一次移动有多少种不同的走法。

一次移动由若干步组成。假设当前要移动的棋子为 $a$，在每一步中，首先需要选择另一个棋子 $b$ 作为跳台，然后将 $a$ 走到关于 $b$ 的对称位置（在一次移动中，你无法更改需要移动的棋子 $a$。并且在某一步中，棋子 $a$ 回到此次移动前所在的位置是不被允许的）。

关于跳台 $b$ 的选择有一些条件：

- $a$ 和 $b$ 之间的连线应当平行于棋盘的某条坐标轴。注：棋盘上一共有三条坐标轴，其中一条与水平线平行，并且任意两条坐标轴之间的夹角均为 $\frac{\pi}{3}$。

- $a$ 和 $b$ 不必相邻。

- 除了跳台 $b$ 以外，$a$ 和其关于 $b$ 的对称点的连线上不能有其他棋子。

- 对称点的位置应当落在棋盘上，并且没有被其他棋子占据。

一次移动需要至少走一步。在第一步以后，你可以随时停下来。你可以选择棋盘上任意一个棋子作为移动棋子。请输出有多少种不同的走法。

两种走法不同当且仅当两次移动后所有棋子的位置组成的集合不同，并且棋子之间不可区分。

## 样例 #1

### 输入

```
5
1
1 1
2
1 1
2 1
2
9 4
9 6
10
1 1
2 1
2 2
3 1
3 2
3 3
4 1
4 2
4 3
4 4
10
1 1
2 1
2 2
5 7
3 2
3 3
4 1
4 2
4 3
4 4
```

### 输出

```
0
1
2
6
13
```

# AI分析结果



---

**算法分类**：其他搜索（DFS为主）

---

### **综合分析与结论**

**题目核心**：  
中国跳棋移动路径的模拟与状态去重，需处理多步跳跃的合法性判断及最终状态的唯一性统计。

**关键难点与解决思路**：  
1. **坐标系建模**：将六芒星棋盘转化为二维网格坐标系（如FFTotoro的坐标变换或LHLeisus的矩阵预处理），便于方向判断和跳跃模拟。  
2. **跳跃合法性**：沿6个方向枚举跳台，计算对称点时需验证路径中间仅有一个棋子且目标点为空。  
3. **状态去重**：通过集合（`set`）记录移动后的所有棋子位置，确保不同路径导致相同结果时仅计一次。  
4. **搜索策略**：DFS递归实现多步跳跃，每次跳跃后更新棋子位置并回溯，利用`visited`标记避免循环跳跃。

**搜索过程可视化设计**：  
- **节点表示**：棋盘上的每个棋子用像素方块表示，不同颜色区分初始/已跳/目标位置。  
- **跳跃动画**：用Canvas绘制跳跃路径，高亮当前跳台和对称点，红色线条标记非法路径。  
- **自动演示**：AI自动选择下一个可跳方向，步进式展示DFS递归的深入与回溯。  
- **复古风格**：8位音效（跳跃声、成功音效），棋盘用低分辨率色块渲染，类似经典策略游戏。

---

### **题解清单 (≥4星)**

1. **FFTotoro (⭐⭐⭐⭐⭐)**  
   - **亮点**：  
     - 坐标系转换简洁，利用`l[x]`和`r[x]`快速判断位置合法性。  
     - 递归DFS实现多步跳跃，通过全局`set`管理已访问状态。  
   - **个人心得**：强调坐标建模的灵活性，避免因读题错误导致的实现偏差。

2. **LHLeisus (⭐⭐⭐⭐)**  
   - **亮点**：  
     - 二维数组预处理棋盘形状，直观判断位置有效性。  
     - 明确沿三个主轴方向DFS，剪枝中间路径多棋子的情况。  
   - **个人心得**：提醒注意输入坐标的转换与中间路径检查的细节。

---

### **核心代码实现**

**FFTotoro的关键搜索逻辑**：  
```cpp
function<void(int)> dfs=[&](int i){
  s.emplace(a[i]); // 标记当前状态
  for(int j=0;j<6;j++) // 枚举6个方向
    for(int k=1;k<=6;k++) // 枚举跳跃步数
      if(auto [p,c1]=jump(a[i],j,k); c1==1 && check(p) && m.count(p))
        if(auto [e,c2]=jump(p,j,k); !c2 && check(e) && !m.count(e)){
          // 更新棋子位置并递归
          m.erase(a[i]); m.insert(e);
          if(!s.count(e)) dfs(i);
          m.erase(e); m.insert(a[i]); // 回溯
        }
};
```

**说明**：  
- `jump`函数模拟沿方向`j`跳`k`步，返回终点和经过的棋子数。  
- `c1==1`确保路径仅有一个跳台，`c2==0`确保目标点路径无阻挡。  
- `s`标记已访问状态，避免重复计入同一终态。

---

### **同类型题与套路**

1. **棋盘路径搜索**：如八皇后、骑士周游问题，需处理移动规则与状态去重。  
2. **多步跳跃模拟**：类似青蛙跳棋（LeetCode 403），跳跃步数动态变化。  
3. **坐标系转换**：六边形网格问题（如Codeforces 60C），需自定义坐标模型。

---

### **推荐题目**

1. **P2730 [USACO3.2] 魔板 Magic Squares**（状态搜索与去重）  
2. **P3956 [NOIP2017 普及] 棋盘**（带条件的最短路径）  
3. **P1443 马的遍历**（BFS路径扩展与坐标处理）

---

### **可视化与复古动画**

**Canvas实现要点**：  
1. **像素风渲染**：每个棋盘格为16x16像素，用`fillRect`绘制，色块区分空/有棋子。  
2. **跳跃高亮**：当前跳台用黄色，对称点用绿色，非法路径显示红色叉。  
3. **音效触发**：  
   - `jump_sound`：跳跃时播放8-bit音效（短促“哔”声）。  
   - `success_sound`：找到新终态时播放胜利音调。  

**AI自动演示**：  
- 按DFS顺序自动选择方向，每步延迟500ms，递归时缩进显示层级。  
- 回溯时恢复棋盘颜色，体现递归栈的变化。

---

**总结**：该题需综合坐标系建模、多步跳跃模拟与状态去重，DFS实现配合集合去重是高效解法。可视化设计可通过复古像素动画直观展示跳跃逻辑与递归过程。

---
处理用时：90.78秒
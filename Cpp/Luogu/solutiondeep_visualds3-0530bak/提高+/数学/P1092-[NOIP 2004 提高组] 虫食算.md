# 题目信息

# [NOIP 2004 提高组] 虫食算

## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：

$$\begin{aligned}
 \verb!43#9865#045! \\
+\qquad \verb!8468#6633! \\[-1em]\underline{\kern{8em}} \\
 \verb!44445509678! \\
\end{aligned}$$

其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。

$$\begin{aligned}
 \verb!BADC! \\
+\quad \verb!CBDA! \\[-1em]\underline{\kern{4em}} \\
 \verb!DCCC! \\
\end{aligned}$$

上面的算式是一个4进制的算式。很显然，我们只要让 $\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 10$；
- 对于 $50\%$ 的数据，保证 $n \le 15$；
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 26$。

## 样例 #1

### 输入

```
5
ABCED
BDACE
EBBAA
```

### 输出

```
1 0 3 4 2
```

# AI分析结果



# 虫食算题解分析

## 算法分类
组合数学（排列组合与剪枝优化）

---

## 题解思路与难点解析

### 核心数学逻辑
设每个字母为变量，建立竖式约束方程：
```
A[i] + B[i] + carry[i] = C[i] + n*carry[i+1]
```
其中 carry[i] ∈ {0,1} 表示进位，需满足：
1. 各字母取值唯一性（0~n-1的排列）
2. 最高位无进位（carry[0]=0）
3. 每位运算需满足两种可能进位情况

### 题解对比分析
1. **zzlzk（⭐⭐⭐⭐⭐）**
   - **核心技巧**：按从右到左的顺序搜索，优先处理低位
   - **剪枝策略**：
     ```python
     if (A+B) %n != C and (A+B+1)%n != C → 剪枝
     if 最高位有进位 → 剪枝
     ```
   - **Next数组**：动态确定搜索顺序（优先处理出现频率高的字母）

2. **feecle6418（⭐⭐⭐⭐）**
   - **搜索顺序优化**：按字母在竖式中出现的顺序搜索
   - **双重剪枝**：
     - 提前判断各列是否可能满足两种进位情况
     - 使用used数组避免重复赋值

3. **Tgotp（⭐⭐⭐⭐）**
   - **知二求一**：若某列已知两个变量，可直接计算第三个
   - **进位传递**：用k数组记录进位状态
   - **即时判断**：在递归过程中即时验证各列合法性

### 最优思路提炼
1. **搜索顺序**：从右到左按列搜索，优先处理低位（更容易触发进位约束）
2. **剪枝公式**：
   ```python
   # 当前列i的三种可能情况
   (a + b + carry) %n == c 或
   (a + b + carry +1) %n == c
   ```
3. **进位传递**：用数组记录每列的进位状态，实现递推式验证

---

## 题解评分（≥4星）

| 题解 | 评分 | 亮点 |
|-----|-----|-----|
| zzlzk | ⭐⭐⭐⭐⭐ | 动态搜索顺序+双重剪枝 |
| Tgotp | ⭐⭐⭐⭐   | 知二求一+即时进位验证 |
| feecle6418 | ⭐⭐⭐⭐ | 竖式顺序搜索+复合剪枝 |

---

## 关键代码实现
zzlzk解法中的剪枝判断与进位传递：
```cpp
bool CanPrune() {
    if(num[a[0]] + num[b[0]] >= n) return true; // 最高位剪枝
    for(int i=n-1; i>=0; i--){
        int A=num[a[i]], B=num[b[i]], C=num[c[i]];
        if(A==-1 || B==-1 || C==-1) continue;
        if((A+B)%n != C && (A+B+1)%n != C) 
            return true; // 当前列剪枝
    }
    return false;
}

void dfs(int x) {
    if(CanPrune()) return;
    if(x == n && Judge()) Print(); // 最终验证
    //...尝试赋值并递归
}
```

---

## 同类题目推荐
1. **P1074 靶形数独**（复杂数独的剪枝优化）
2. **P1120 小木棍**（排列组合+多重剪枝）
3. **P1784 数独**（经典DFS剪枝问题）

---

## 可视化设计
**8位机风格竖式计算演示**：
1. **动画流程**：
   - 显示竖式各列从右向左依次高亮
   - 当前列用闪烁光标标记，显示已赋值字母和进位值
   - 剪枝时播放"error.wav"并显示红色X

2. **交互功能**：
   ```javascript
   class Visualizer {
       constructor() {
           this.speed = 100; // 每步动画时间(ms)
           this.carry = 0;   // 当前进位值
       }
       
       showStep(col, A, B, C) {
           // 在Canvas绘制当前列的三数及进位
           // 若(A+B+carry)%n != C则触发剪枝动画
       }
   }
   ```

3. **音效设计**：
   - 正确赋值：8-bit "click.wav"
   - 剪枝发生：低音"buzz.wav"
   - 解题完成：马里奥过关音效

---

## 总结
本题通过DFS与剪枝策略的巧妙结合，将指数级复杂度优化到可行范围。核心在于：  
1. **竖式顺序搜索**符合问题自然约束  
2. **双重剪枝条件**极大减少无效路径  
3. **动态变量顺序**优先处理关键约束  
该模式可推广至各类约束满足问题，如数独、密码算术等。

---
处理用时：72.99秒
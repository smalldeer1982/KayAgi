# 题目信息

# 苦恼的小明

## 题目描述

黄小明和他的合伙人想要创办一所英语培训机构，注册的时候要填一张个人情况的表格，在身高一栏小明犯了愁。

身高要求精确到厘米，但小明实在太高了，无法在纸上填下这么长的数字。小明花钱买通了办事人员，于是只要写上他的身高模 $10007$ 的结果就行了。

可小明不会取模，想起前几天请你帮他解决了水库的问题，于是又来找你帮忙。


## 说明/提示

所有的 $0\le a_i<10^4$。

第 $1 \sim 6$ 数据点满足 $n=2$。

第 $7 \sim 10$ 数据点满足 $n=3$。

第 $11$ 个数据点满足 $n=1234567$。

## 样例 #1

### 输入

```
2										

17 747```

### 输出

```
173```

# AI分析结果



# 数论

## 题解思路与算法要点

### 核心数学方法
题目要求计算形如 $a_1^{a_2^{\dots^{a_n}}} \mod 10007$ 的幂塔值。由于指数过大无法直接计算，需通过**扩展欧拉定理**降幂：

$$a^b \equiv \begin{cases} 
a^b & (b < \varphi(m)) \\
a^{b \mod \varphi(m) + \varphi(m)} & (b \ge \varphi(m)) 
\end{cases} \pmod{m}$$

### 解决难点
1. **递归降幂**：从最外层开始递归，每次将当前层的模数替换为其欧拉函数值，直到模数为1。
2. **快速幂优化**：在快速幂计算中需维护「是否超过模数」的标记，以决定是否附加 $\varphi(m)$。
3. **边界处理**：递归终止条件为模数变为1或处理完所有层数。

### 数据结构与优化
- **预处理欧拉函数**：部分题解（如PR_CYJ）预计算了模数序列 $\varphi(10007), \varphi(\varphi(10007)), \dots$，避免重复计算。
- **递归与迭代对比**：递归实现（August_Light）更直观，适合小规模数据；迭代实现（Stairs_upon_temple）适合大规模数据，但需维护模数数组。

---

## 题解评分（≥4星）

### 1. August_Light（5星）
- **亮点**：代码简洁，递归逻辑清晰，正确维护指数与模数的关系，快速幂中处理标记。
- **关键代码**：
  ```cpp
  LL f(int i, LL p) {
      if (i == n+1 || p == 1) return 1;
      return qpow(a[i], f(i+1, phi(p)), p);
  }
  ```

### 2. PR_CYJ（4星）
- **亮点**：预计算模数序列，迭代处理高效，适合大规模输入。
- **关键代码**：
  ```cpp
  for(int i=n; i>=2; i--)
      a[i-1] = pw(a[i-1], a[i], (i>14)?1:m[i]);
  ```

### 3. Tomwsc（4星）
- **亮点**：预处理欧拉函数数组，使用快速幂同时处理模数标记。
- **关键代码**：
  ```cpp
  int solve(int step, int mod) {
      if(step == n+1 || mod == 1) return 1;
      return ksm(a[step], solve(step+1, phi[mod]), mod);
  }
  ```

---

## 最优思路提炼

### 关键公式推导
1. **模数递推**：$\varphi(m) \rightarrow \varphi(\varphi(m)) \rightarrow \dots \rightarrow 1$，最多递归约 $\log m$ 层。
2. **快速幂标记**：在快速幂中，若中间结果超过当前模数，返回余数加模数，以标记指数超过 $\varphi(m)$。

### 代码实现技巧
- **递归终止**：当模数为1或处理完所有层数时返回1（任何数模1为0，但指数为1不影响结果）。
- **动态计算phi**：避免预处理，减少内存消耗（August_Light方案）。

---

## 类似题目推荐
1. **P5091【模板】扩展欧拉定理**：直接应用扩展定理计算幂模。
2. **P4139 上帝与集合的正确用法**：无限层幂塔的模数计算。
3. **CF906D Power Tower**：多组询问的幂塔模数问题。

---

## 可视化与算法演示

### 动画设计
- **像素风格界面**：使用8位色调，展示模数递降过程（10007→10006→5002→…→1）。
- **步进控制**：高亮当前计算的层级（如第3层计算时，显示$a_3^{a_4^{\dots}}$）。
- **音效提示**：完成一层计算时播放上升音调，模数变为1时播放特殊音效。

### 核心步骤演示
1. **初始状态**：显示模数10007和输入序列。
2. **递归降幂**：用颜色标记当前处理的$a_i$和模数$\varphi^{(k)}(10007)$。
3. **快速幂过程**：动态展示指数拆分（二进制）和余数累加。
4. **结果回传**：最终结果显示为绿色，并输出模10007的结果。

---

## 代码片段（August_Light方案）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

LL phi(LL n) {
    LL ret = n;
    for (LL i=2; i*i<=n; i++) {
        if (n%i == 0) {
            ret = ret/i*(i-1);
            while (n%i == 0) n /= i;
        }
    }
    if (n > 1) ret = ret/n*(n-1);
    return ret;
}

LL qpow(LL a, LL b, LL p) {
    LL ret = 1;
    while (b) {
        if (b&1) {
            ret *= a;
            if (ret >= p) ret = ret%p + p; // 标记超模
        }
        a *= a;
        if (a >= p) a = a%p + p; // 维护底数
        b >>= 1;
    }
    return ret;
}

LL f(int i, LL p, LL a[], int n) {
    if (i == n || p == 1) return 1;
    return qpow(a[i], f(i+1, phi(p), a, n), p);
}

int main() {
    int n; LL a[1000005];
    cin >> n;
    for (int i=0; i<n; i++) cin >> a[i];
    cout << f(0, 10007, a, n) % 10007;
}
```

---

## 个人心得
- **调试教训**：快速幂中未正确处理余数标记会导致错误（如未判断$a_i=1$时的边界）。
- **思维突破**：递归深度与模数下降速度的关系，确保不会栈溢出。

---
处理用时：90.84秒
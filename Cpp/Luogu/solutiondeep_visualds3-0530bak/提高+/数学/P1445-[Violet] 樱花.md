# 题目信息

# [Violet] 樱花

## 题目背景

又到了一年樱花盛开的时节。Vani 和妹子一起去看樱花的时候，找到了一棵大大的樱花树，上面开满了粉红色的樱花。Vani 粗略估计了一下，一共有足足 $n!$ 片花瓣。



Vani 轻柔地对她说：“你知道吗？这里面的一片花瓣代表着你，我从里面随机摘一片，能和你相遇的概率只有 $1/n!$ 那么小。我该是多么的幸运，才让你今天这么近地站在我面前。相信我，我一定会把这亿万分之一的缘分变为永远。”

粉红的樱花漫天飞舞，妹子瞬间被 Vani 感动了。她轻轻地牵起了他的手，和他相依而坐。这时，她突然看到田野的尽头也长着两棵樱花树，于是慢慢地把头靠在 Vani 的肩上，在他耳边低语：“看到夕阳里的那两棵樱花树了吗？其中一棵树上的一片花瓣是你，另一棵树上的一片花瓣是我，如果有人从这棵摘下一片，从那棵采下一瓣，我们相遇的概率会不会正好是 $1/n!$ 呢？”

Vani 的大脑飞速运作了一下，立即算出了答案。正要告诉妹子，她突然又轻轻地说：“以前你总是说我数学不好，但是这种简单的题我还是会算的。你看假如左边那棵树上有 $x$ 片花瓣，右边那个有 $y$ 片花瓣，那么我们相遇的概率不就是 $1/x+1/y$ 么，不过有多少种情况能使它正好可以等于 $1/n!$ 呢？这个你就帮我算一下吧～”

显然，面对天然呆的可爱妹子，Vani 不但不能吐槽她的渣数学，而且还要老老实实地 帮她算出答案哦。


## 题目描述

求方程：

$$\dfrac{1}{x} + \dfrac{1}{y} = \dfrac{1}{n!}$$ 

的正整数解的组数，答案对 $10^9+7$ 取模。

## 说明/提示

#### 样例 1 解释

共有三个数对 $(x,y)$ 满足条件，分别是 $(3,6),(4,4)$ 和 $(6,3)$。

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\le 100$ 。
- 对于 $100\%$ 的数据，保证 $1 \le n\le 10^6$。


## 样例 #1

### 输入

```
2
```

### 输出

```
3```

## 样例 #2

### 输入

```
1439
```

### 输出

```
102426508```

# AI分析结果



### 数学分类选择  
**数论**

---

### 题解思路、算法要点与解决难点  
1. **核心公式推导**  
   原式变形为：  
   $$\frac{1}{x} + \frac{1}{y} = \frac{1}{n!} \implies (x - n!)(y - n!) = (n!)^2$$  
   解的组数等于 $(n!)^2$ 的正因数个数，转化为质因数分解问题。

2. **关键步骤**  
   - **质因数分解**：计算 $n!$ 中每个质数 $p_i$ 的指数 $c_i$，满足：  
     $$c_i = \sum_{k=1}^{\infty} \left\lfloor \frac{n}{p_i^k} \right\rfloor$$  
   - **平方扩展**：$(n!)^2$ 的质因数指数为 $2c_i$，约数个数为 $\prod (2c_i + 1)$。

3. **算法优化**  
   - **线性筛法**：预处理质数及最小质因子，分解时直接跳转（时间复杂度 $O(n)$）。  
   - **动态统计**：遍历 $1$ 至 $n$，实时统计每个质数的贡献（避免暴力分解）。

---

### 题解评分 (≥4星)  
1. **Huami360（★★★★★）**  
   - **亮点**：代码简洁，使用线性筛预处理质数，动态分解质因数。  
   - **代码片段**：  
     ```cpp  
     rep(i, 1, n) {  
        for(int j = i; j != 1; j /= v[j])  
            c[v[j]]++;  
     }  
     ```  
2. **d3ac（★★★★★）**  
   - **亮点**：公式推导清晰，直接给出核心结论，无需复杂代码。  
   - **结论**：$(n!)^2$ 的因数个数即为解的总数。  

3. **Andrew82（★★★★☆）**  
   - **亮点**：详细推导方程变形过程，提供两种分解质因数实现（暴力与优化）。  
   - **优化技巧**：利用最小质因子快速分解，时间复杂度 $O(n \log n)$。  

---

### 最优思路/技巧提炼  
1. **代数变形**：将方程转化为乘积形式，直接关联因数分解。  
2. **质因数统计**：通过线性筛预处理质数，动态累加每个质数的指数。  
3. **模运算优化**：在累乘过程中实时取模，避免溢出。  

---

### 同类型题通用套路  
- **数论方程求整数解**：尝试因式分解或代数变形，转化为因数/约数问题。  
- **阶乘质因数分解**：利用线性筛预处理质数，动态统计指数。  

---

### 推荐相似题目  
1. **P1495 曹冲养猪**（中国剩余定理）  
2. **P1069 细胞分裂**（质因数分解）  
3. **P1072 Hankson的趣味题**（因数与最大公约数）  

---

### 个人心得摘录  
- **Huami360**：强调线性筛的重要性，指出“分解质因数时需不断除以最小质因子”。  
- **巨型方块**：提到“对数学敏感的同学能快速发现因式分解技巧”。  

---

### 可视化与算法演示  
**动画设计**：  
1. **变形步骤**：  
   - 初始方程 → 通分 → 交叉相乘 → 因式分解，高亮每一步的数学操作。  
   - 用红色框标出 $(x - n!)(y - n!)$，蓝色框标出 $(n!)^2$。  
2. **质因数统计**：  
   - 展示线性筛过程，质数标记为绿色，合数为灰色。  
   - 动态显示每个数分解质因数的过程，质因数逐个弹出并累加计数。  
3. **复古像素风格**：  
   - **Canvas 绘制**：用 8-bit 像素块表示质数，分解时播放“分解音效”。  
   - **音效设计**：成功分解时播放短促的“叮”声，完成统计后播放胜利音效。  

**交互控制**：  
- **步进按钮**：允许用户逐帧观察质因数分解过程。  
- **自动模式**：模拟“贪吃蛇 AI”，自动完成所有计算步骤。  

---

### 关键代码实现  
```cpp  
// 线性筛预处理质数及最小质因子  
void sieve() {  
    for (int i = 2; i <= n; i++) {  
        if (!v[i]) {  
            v[i] = i;  
            prime[++cnt] = i;  
        }  
        for (int j = 1; j <= cnt && i * prime[j] <= n; j++) {  
            v[i * prime[j]] = prime[j];  
            if (i % prime[j] == 0) break;  
        }  
    }  
}  

// 统计质因数指数  
for (int i = 2; i <= n; i++) {  
    for (int j = i; j != 1; j /= v[j]) {  
        cnt_factors[v[j]]++;  
    }  
}  

// 计算结果  
long long ans = 1;  
for (int i = 1; i <= cnt; i++) {  
    ans = ans * (2 * cnt_factors[prime[i]] + 1) % MOD;  
}  
```  

---

**总结**：本题通过巧妙的代数变形将问题转化为质因数分解，结合线性筛法高效统计指数，是数论中典型的约数计数问题。

---
处理用时：78.11秒
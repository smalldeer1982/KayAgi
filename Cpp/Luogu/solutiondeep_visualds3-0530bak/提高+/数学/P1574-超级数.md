# 题目信息

# 超级数

## 题目描述

设x的约数个数为 $f(x)$，若 $\forall i\in [1,n)\cap \mathbb{Z^+},f(n)>f(i)$，就把 $n$ 称作 `supernumber`。

给出 $m$ 个数 $a_1,a_2,\ldots,a_m$，请分别输出不大于 $a_1$，不大于 $a_2$，...，不大于 $a_m$ 的最大 `supernumber`。

## 说明/提示

#### 数据规模与约定

- 对于 $40\%$ 的数据，$m=1$。
- 对于 $50\%$ 的数据，$a_i\le1000$。
- 对于 $70\%$ 的数据，$a_i\le 2\times10^7$。
- 对于 $100\%$ 的数据，$m\le10^5$，$a_i\le10^{17}$。

## 样例 #1

### 输入

```
2
8
13```

### 输出

```
6
12```

# AI分析结果



---

**算法分类**：数论

---

### 题解思路与算法要点
**核心数学原理**：  
超级数等价于反素数，其定义是比所有更小的数有更多约数。反素数质因子必须满足：
1. 由连续质数构成（2,3,5,7...）
2. 指数非递增排列（t₁ ≥ t₂ ≥ t₃...）

**关键推导步骤**：
1. 用DFS遍历所有可能的质因子组合（前15个质数足够覆盖1e17范围）
2. 剪枝策略：当乘积超过目标值或指数不满足非递增时停止递归
3. 维护当前最大约数个数和对应最小数值

**解决难点**：
- 通过指数递减约束将搜索空间从O(n!)降至O(2^15)
- 使用预处理+二分查找应对1e5次查询
- 处理大数溢出问题（用除法代替乘法判断边界）

---

### 题解评分（≥4★）

1. **Ginger_he（5★）**
   - 直接使用预计算的反素数表
   - O(1)查询效率，代码仅20行
   - 缺点：需提前生成完整反素数表
   ```cpp
   const int ans[] = {1,2,4,6,...,93163582512000}; // 预计算表
   printf("%lld\n",ans[upper_bound()-1]);
   ```

2. **沉冥Charming（4★）**
   - 完整展示反素数生成过程
   - 质数表生成+DFS剪枝双重验证
   - 缺点：未优化多查询处理
   ```cpp
   void dfs(ll n,ll y,ll t,ll x) {
     if(n>=14) return;
     ll k=t;
     for(ll i=1; i<=x; i++) {
       k*=p[n];
       if(k>1e17) break;
       dfs(n+1,y*(i+1),k,i);
     }
   }
   ```

3. **Ervin（4★）**
   - 动态生成反素数表
   - 预处理最大查询值后降序处理
   - 优点：节省重复计算
   ```cpp
   while(maxx !=1) {
     dfs(maxx,0,1,1); 
     b[++tot]=ans;
     maxx=ans-1;
   }
   ```

---

### 最优思路提炼
**数学优化核心**：
1. **指数递减法则**：确保每个质因子指数不超过前一个，将搜索空间从阶乘级降为指数级
2. **质因子连续性**：仅使用前15个质数即可覆盖1e17范围（2×3×5×...×47≈6e17）
3. **预处理+二分**：将O(n)查询优化为O(logK)，K为反素数数量（约200个）

**实现技巧**：
```cpp
// 关键剪枝判断
if(num*pri[now] > n) break; 
// 使用除法避免溢出
if(num > n/pri[now]) break;
```

---

### 同类问题推荐
1. **P1463** 反素数（模板题）
2. **P1492** 佩尔方程（数论构造）
3. **P2525** 因子数游戏（扩展版反素数）

---

### 可视化设计
**像素化DFS过程演示**：
1. **Canvas网格**：15×15网格表示质因子和指数
2. **颜色编码**：
   - 绿色：当前活跃质因子（如正在处理3^2）
   - 红色：剪枝路径（指数超标或溢出）
   - 黄色：有效路径（生成候选数）
3. **音效反馈**：
   - 发现新反素数时播放《超级马里奥》金币音效
   - 剪枝时播放短促"哔"声

**动画步骤示例**：
```
Step1: 尝试2^4 → 因数(4+1)=5
Step2: 叠加3^3 → 因数5*(3+1)=20
Step3: 尝试5^2 → 溢出1e17 → 红色闪烁
Step4: 回退生成2^4×3^2×5^1=720 → 黄色高亮
```

---

### 核心代码实现
```cpp
// 反素数生成核心DFS
void dfs(int pos, ll num, ll factors, int last_exp) {
    if(factors > max_factors || 
      (factors == max_factors && num < best_num)) {
        best_num = num;
        max_factors = factors;
    }
    for(int i=1; i<=last_exp; i++) {
        if(num > n/primes[pos]) break;
        num *= primes[pos];
        dfs(pos+1, num, factors*(i+1), i);
    }
}
```

**复古效果CSS片段**：
```css
.pixel-font {
    font-family: 'Press Start 2P', cursive;
    color: #00FF00; /* 经典绿屏色 */
}
.grid-cell {
    width: 20px;
    height: 20px;
    border: 1px solid #555;
    background: #000;
}
.active {
    background: #FF0;
    animation: blink 0.5s infinite;
}
```

---

**总结**：通过质因子分解性质约束搜索空间，结合预处理与二分查找，可在O(2^15)时间内解决1e17规模的反素数问题。掌握指数递减法则和连续质数选择是此类问题的核心。

---
处理用时：75.43秒
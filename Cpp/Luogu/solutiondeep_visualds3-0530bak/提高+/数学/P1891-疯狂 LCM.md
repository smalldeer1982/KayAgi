# 题目信息

# 疯狂 LCM

## 题目背景

众所周知，czmppppp 是数学大神犇。一天，他给众蒟蒻们出了一道数论题，蒟蒻们都惊呆了。

## 题目描述

给定 $n$，求

$$\sum_{i = 1}^n \operatorname{lcm}(i, n)$$

其中 $\operatorname{lcm}(i, j)$ 表示 $i$ 和 $j$ 的最小公倍数。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $T \leq 5$，$n \leq 10^5$。
- 对于 $100\%$ 的数据，$1 \leq T \leq 3 \times 10^5$，$1 \leq n \leq 10^6$。


## 样例 #1

### 输入

```
3
1
2
5
```

### 输出

```
1

4

55```

# AI分析结果



## 【算法分类】
**数论**

---

## 【题解思路与难点】

### **核心思路**
题目要求计算 $\sum_{i=1}^n \text{lcm}(i, n)$。通过数学推导，问题转化为：  
1. 将 $\text{lcm}(i, n)$ 转换为 $\frac{in}{\gcd(i, n)}$，提取 $n$ 后得到 $n \sum_{i=1}^n \frac{i}{\gcd(i, n)}$。  
2. 枚举 $\gcd(i, n)=d$ 的因数 $d$，利用欧拉函数 $\varphi(d)$ 计算与 $d$ 互质的数的对称性求和。  
3. 预处理每个数的所有因数贡献 $\sum_{d|n} \frac{\varphi(d) \cdot d}{2}$，最终公式为 $n \cdot \sum_{d|n} \frac{\varphi(d) \cdot d}{2}$。

### **关键公式推导**
1. **互质数对称性**：若 $\gcd(i, d)=1$，则 $\gcd(d-i, d)=1$，求和结果为 $\frac{\varphi(d) \cdot d}{2}$（当 $d>1$）。  
2. **预处理优化**：使用埃拉托斯特尼筛法（埃筛）预处理所有数的因数贡献，时间复杂度 $O(n \log n)$，查询 $O(1)$。

### **解决难点**
- **公式变形**：通过枚举 $\gcd$ 将问题转换为数论函数的求和。  
- **高效预处理**：利用埃筛将每个因数 $d$ 的贡献批量累加到其倍数上，避免每次查询时重复计算。

---

## 【题解评分 (≥4星)】
1. **suxxsfe（4星）**  
   - **亮点**：清晰的埃筛预处理思路，代码简洁高效，直接推导出最终公式。  
   - **代码片段**：  
     ```cpp  
     for (reg int i = 1; i <= n; i++)  
         for (reg int j = i; j <= n; j += i)  
             f[j] += (phi[i] * i + 1) >> 1;  
     ```
2. **虞皓翔（4星）**  
   - **亮点**：线性筛法处理积性函数，时间复杂度更低（$O(n)$），代码通过质因数分解优化。  
   - **代码片段**：  
     ```cpp  
     if (i % p[j] == 0) {  
         ii = i; jj = p[j];  
         while (ii % p[j] == 0) ii /= p[j], jj *= p[j];  
         h[v] = h[ii] * h[jj];  
     }  
     ```
3. **chihik（4星）**  
   - **亮点**：完整公式推导与预处理实现，代码中直接使用欧拉函数和因数枚举。  
   - **代码片段**：  
     ```cpp  
     for (int i = 1; i <= MAXN; i++)  
         for (int j = i; j <= MAXN; j += i)  
             g[j] += i == 1 ? 1 : 1ll * phi[i] * i / 2;  
     ```

---

## 【最优技巧提炼】
1. **公式变形**：将 $\text{lcm}$ 转换为 $\gcd$ 的表达式，利用因数枚举和欧拉函数求和。  
2. **对称性优化**：发现互质数的对称性，将求和简化为 $\frac{\varphi(d) \cdot d}{2}$。  
3. **预处理方法**：使用埃筛或线性筛批量计算所有数的因数贡献，实现高效查询。

---

## 【同类型题目】
1. **P2303 公约数求和**：计算 $\sum_{i=1}^n \gcd(i, n)$，同样需要枚举因数并利用欧拉函数。  
2. **P1447 能量采集**：二维扩展，求 $\sum_{i=1}^n \sum_{j=1}^m \gcd(i,j)$。  
3. **P1390 公约数的和**：预处理因数贡献后直接求和。

---

## 【可视化与算法演示】
### **动画设计**
- **步骤1**：展示公式转换过程，将 $\text{lcm}(i, n)$ 转换为 $\frac{in}{\gcd(i, n)}$。  
- **步骤2**：高亮枚举因数 $d$ 的过程，每个因数 $d$ 对应一组 $\gcd(i, n)=d$ 的 $i$。  
- **步骤3**：用颜色标记互质数对 $(i, d)$ 的对称性，动态显示 $\sum i = \frac{\varphi(d) \cdot d}{2}$。  
- **步骤4**：展示埃筛预处理过程，每个因数 $d$ 的贡献累加到其倍数上（如 $d=2$ 时，高亮所有偶数）。

### **复古像素风格实现**
- **Canvas 绘制**：用 8-bit 像素块表示数轴，绿色块表示当前枚举的因数 $d$，红色块表示其倍数。  
- **音效**：每完成一个因数的计算时播放“哔”声，预处理完成时播放 8-bit 胜利音效。  
- **自动演示**：模拟埃筛过程，逐步显示每个数的因数贡献累加。

---

## **核心代码实现**
```cpp
// 预处理欧拉函数和答案贡献  
void sieve() {
    phi[1] = 1;
    for (int i = 2; i <= MAXN; i++) {
        if (!vis[i]) {
            prime[++cnt] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= cnt && i * prime[j] <= MAXN; j++) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }
    }
    // 埃筛预处理每个数的因数贡献  
    for (int i = 1; i <= MAXN; i++) {
        for (int j = i; j <= MAXN; j += i) {
            ans[j] += (i == 1) ? 1 : (phi[i] * i) / 2;
        }
    }
}
```

---

## **个人心得**
- **调试教训**：注意 $d=1$ 时的特殊情况（公式中需单独处理）。  
- **优化经验**：预处理时避免使用 `long long` 除非必要，减少内存占用。  
- **思维突破**：将复杂求和问题转化为因数枚举和积性函数预处理，是数论题的常见套路。

---
处理用时：92.68秒
# 题目信息

# 高维正方体

## 题目描述

$0$ 维空间的元素是点，这个毋庸置疑。

- $2$ 个 $0$ 维空间的元素可以围成一个 $1$ 维空间的元素，线段。
- $4$ 个 $1$ 维空间的元素可以围成一个 $2$ 维空间的元素，正方形。
- $6$ 个 $2$ 维空间的元素可以围成一个 $3$ 维空间的元素，正方体。
- $8$ 个 $3$ 维空间的元素可以围成一个 $4$ 维空间的元素，超正方体。

……

- 一个正方形中，有 $4$ 个（顶）点，$4$ 条线段（边），$1$ 个正方形。
- 一个正方体中，有 $8$ 个（顶）点，$12$ 条线段（棱），$6$ 个正方形（面），$1$ 个正方体。

……

我们的问题是：给出 $a$ 与 $b$，请求出：在 $a$ 维空间的元素中，包含着多少个 $b$ 维空间的元素。答案可能很大，只需要输出它除以 $10^9+7$ 的余数。

## 说明/提示


### 样例解释

$3$ 维空间的元素是正方体，$1$ 维空间的元素是线段。所求即是一个正方体中棱的数量，为 $12$。

### 数据范围及约定

- 对于 $5\%$ 的数据，$a,b \le 1$；
- 对于 $10\%$ 的数据，$a,b \le 2$；
- 对于 $20\%$ 的数据，$a,b \le 3$；
- 对于 $35\%$ 的数据，$a,b \le 4$；
- 对于 $70\%$ 的数据，$a,b \le 1000$；
- 对于 $100\%$ 的数据，$0\le a,b \le 100000$。

此外，对于 $15\%$ 的数据，$b=0$，对于各 $10\%$ 的数据，$b=1$ 或 $b=2$。

### 提示

不保证 $a \ge b$。

## 样例 #1

### 输入

```
3 1```

### 输出

```
12```

# AI分析结果



## 算法分类
**组合数学**

---

## 题解思路与核心分析
### 核心公式推导
通过观察高维立方体结构特征可得：  
$a$ 维立方体中 $b$ 维元素的数目为：  
$$ f(a,b) = \dbinom{a}{b} \cdot 2^{a-b} $$  
**推导思路**：  
1. **维度选择**：从 $a$ 个维度中选择 $b$ 个维度构成 $b$ 维元素，共 $\dbinom{a}{b}$ 种选择方式。  
2. **自由度扩展**：剩余 $(a-b)$ 个维度每个维度有 2 种坐标状态（0 或 1），产生 $2^{a-b}$ 种组合。  

### 解决难点
- **组合数计算优化**：直接计算阶乘与逆元避免溢出。  
- **快速幂加速**：利用快速幂计算 $2^{a-b} \mod (10^9+7)$。  
- **边界处理**：特判 $a < b$ 时结果为 0。

---

## 高分题解点评（≥4星）
### 题解1：ghj1222（⭐️⭐️⭐️⭐️）  
**亮点**：  
- 递推公式直观推导，逻辑清晰。  
- 利用逆元处理除法取模，代码简洁。  
**代码关键点**：  
```cpp  
f[0] = qpow(2, n);  
for (int i=1; i<=m; i++)  
    f[i] = f[i-1] * (n-i+1) % p * qpow(2*i, p-2) % p;  
```

### 题解2：0x3F（⭐️⭐️⭐️⭐️⭐️）  
**亮点**：  
- 打表归纳公式，直接应用二项式定理。  
- 代码高效，时间复杂度 $O(a)$。  
**核心公式**：  
$$ f(a,b) = 2^{a-b} \cdot \frac{a!}{b!(a-b)!} $$  

### 题解3：SunsetSamsara（⭐️⭐️⭐️⭐️）  
**亮点**：  
- 组合数计算与快速幂分离，模块化清晰。  
- 完整预处理阶乘和逆元，适合多次查询。  

---

## 最优思路提炼
1. **公式推导**：通过组合数选择维度，剩余维度自由组合。  
2. **快速幂优化**：$2^{a-b}$ 用快速幂计算。  
3. **逆元处理**：阶乘逆元预处理避免除法取模问题。  

---

## 类似题目推荐
1. **P3807 卢卡斯定理**：组合数取模的扩展应用。  
2. **P1313 计算系数**：二项式定理与快速幂结合。  
3. **P1061 组合数问题**：预处理组合数模结果。  

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9+7, MAXN = 1e5+5;
long long fac[MAXN], inv_fac[MAXN];

// 快速幂
long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

// 预处理阶乘和逆元
void precompute() {
    fac[0] = 1;
    for (int i=1; i<MAXN; ++i)
        fac[i] = fac[i-1] * i % MOD;
    inv_fac[MAXN-1] = qpow(fac[MAXN-1], MOD-2);
    for (int i=MAXN-2; i>=0; --i)
        inv_fac[i] = inv_fac[i+1] * (i+1) % MOD;
}

int main() {
    precompute();
    int a, b;
    cin >> a >> b;
    if (a < b) cout << 0;
    else {
        long long C = fac[a] * inv_fac[b] % MOD;
        C = C * inv_fac[a-b] % MOD;
        long long ans = C * qpow(2, a-b) % MOD;
        cout << ans;
    }
    return 0;
}
```

---

## 可视化算法演示
**动画设计**：  
1. **维度选择**：在 $a$ 维坐标系中高亮选中的 $b$ 个维度（红色），其余维度灰显。  
2. **自由组合**：对每个未选维度展示 0/1 两种状态切换（绿色闪烁）。  
3. **计数累加**：每完成一个组合，计数器增加，显示当前累计数目。  

**复古像素风格**：  
- **Canvas 绘制**：使用 8-bit 风格网格，每个维度用方块表示。  
- **音效触发**：选中维度时播放“哔”声，组合完成时播放“叮”声。  
- **自动演示**：按步进速度自动遍历所有组合，最终显示公式结果。  

**交互功能**：  
- **速度调节**：滑动条控制动画速度。  
- **单步执行**：按空格键逐步展示计算过程。

---
处理用时：73.53秒
# 题目信息

# [AHOI2005] 洗牌

## 题目描述

为了表彰小联为 Samuel 星球的探险所做出的贡献，小联被邀请参加 Samuel 星球近距离载人探险活动。

由于 Samuel 星球相当遥远，科学家们要在飞船中度过相当长的一段时间，小联提议用扑克牌打发长途旅行中的无聊时间。玩了几局之后，大家觉得单纯玩扑克牌对于像他们这样的高智商人才来说太简单了。有人提出了扑克牌的一种新的玩法。

对于扑克牌的一次洗牌是这样定义的，将一叠 $N$（$N$为偶数）张扑克牌平均分成上下两叠，取下面一叠的第一张作为新的一叠的第一张，然后取上面一叠的第一张作为新的一叠的第二张，再取下面一叠的第二张作为新的一叠的第三张……如此交替直到所有的牌取完。

如果对一叠 $6$ 张的扑克牌 ${1,2,3,4,5,6}$，进行一次洗牌的过程如下图所示：

  ![](https://cdn.luogu.com.cn/upload/pic/1641.png) 

从图中可以看出经过一次洗牌，序列 $1,2,3,4,5,6$ 变为 $4,1,5,2,6,3$。当然，再对得到的序列进行一次洗牌，又会变为 $2,4,6,1,3,5$。

游戏是这样的，如果给定长度为 $N$ 的一叠扑克牌，并且牌面大小从 $1$ 开始连续增加到 $N$（不考虑花色），对这样的一叠扑克牌，进行 $M$ 次洗牌。最先说出经过洗牌后的扑克牌序列中第 $L$ 张扑克牌的牌面大小是多少的科学家得胜。小联想赢取游戏的胜利，你能帮助他吗？

## 说明/提示

$0 ＜ N \leq 10^{10}$，$0 \leq M \leq 10^{10}$，且 $N$ 为偶数。


## 样例 #1

### 输入

```
6 2 3```

### 输出

```
6```

# AI分析结果



---

**唯一算法分类**：数论

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **位置变换规律**：每次洗牌后，位置 `x` 变为 `2x mod (N+1)`。推导发现，M次洗牌后位置为 `x * 2^M mod (N+1)`。
2. **逆元求解**：通过扩展欧几里得算法（exgcd）计算 `2^M` 在模 `N+1` 下的逆元，解同余方程 `x ≡ L * inv(2^M) mod (N+1)`。
3. **大数运算优化**：使用快速幂计算 `2^M`，并用慢速乘（龟速乘）避免乘法溢出。

#### **数学推导**
- **关键公式**：`x ≡ L * (2^M)^{-1} mod (N+1)`
- **推导步骤**：
  1. 单次洗牌后位置变换公式：`x → 2x mod (N+1)`。
  2. M次洗牌后位置变换公式：`x → x * 2^M mod (N+1)`。
  3. 逆推初始位置：解方程 `x * 2^M ≡ L mod (N+1)`，得 `x ≡ L * inv(2^M) mod (N+1)`。

#### **解决难点**
- **大数乘法溢出**：使用慢速乘（龟速乘）代替直接乘法。
- **逆元计算**：通过exgcd求解非质数模数下的逆元。
- **时间复杂度**：快速幂和exgcd均为 `O(log M)`，高效处理 `1e10` 量级数据。

---

### **题解评分 (≥4星)**

| 题解作者       | 评分 | 关键亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| qqvq           | ★★★★★ | 正确处理大数溢出、exgcd求逆元、代码简洁高效。                            |
| RenaMoe        | ★★★★☆ | 详细推导位置变换规律，代码包含慢速乘和快速幂，但变量命名稍显复杂。        |
| FlashHu        | ★★★★☆ | 一行exgcd实现、代码极简，但未处理快速乘，可能在大数据时溢出。             |

---

### **最优思路与技巧提炼**
1. **位置变换公式**：发现 `x → 2x mod (N+1)` 是解题突破口。
2. **快速幂+逆元**：将问题转化为模运算方程，利用快速幂和exgcd求解。
3. **慢速乘优化**：用加法代替乘法，避免 `1e10` 级别的溢出。

---

### **同类型题与算法套路**
1. **模运算与逆元**：常见于需要逆向推导初始状态的题目。
2. **快速幂应用**：处理指数级增长的模运算问题。
3. **扩展欧几里得算法**：求解线性同余方程的核心工具。

---

### **推荐相似题目**
1. **P1082 [NOIP2012 提高组] 同余方程**  
   （求解线性同余方程 `ax ≡ 1 mod b`）
2. **P3811 【模板】乘法逆元**  
   （多种方法求逆元的模板题）
3. **P2613 【模板】有理数取余**  
   （分数取模与逆元结合的应用）

---

### **个人心得摘录**
- **qqvq**：强调必须用 `long long` 和慢速乘，避免因数据范围导致WA。
- **RenaMoe**：通过打表观察规律，避免被题面误导。
- **FlashHu**：用一行exgcd实现逆元计算，展示代码简化技巧。

---

### **可视化与算法演示**

#### **动画方案**
1. **位置变换演示**：  
   - 初始牌序列：`1,2,3,4,5,6`，高亮第 `L` 张牌。  
   - 每次洗牌后，用箭头动态展示 `2x mod 7` 的变换过程，颜色标记新旧位置。  
   - 累计M次变换后，显示最终位置公式 `L * 2^M mod 7`。

2. **逆元计算演示**：  
   - 分步展示exgcd求解 `2^M` 和 `N+1` 的最大公约数。  
   - 高亮递归步骤，动态显示贝祖系数 `x, y` 的变化。

3. **复古像素风格**：  
   - 使用8位像素字体显示公式推导步骤。  
   - 音效：计算完成时播放8-bit音效，错误时播放低沉音效。  
   - Canvas绘制洗牌过程的牌面移动动画，仿红白机风格。

#### **核心代码片段**
```cpp
// 慢速乘（龟速乘）
ll mul(ll a, ll b, ll mod) {
    ll ret = 0;
    while (b) {
        if (b & 1) ret = (ret + a) % mod;
        a = (a + a) % mod;
        b >>= 1;
    }
    return ret % mod;
}

// 快速幂
ll Pow(ll a, ll b, ll mod) {
    ll ret = 1;
    while (b) {
        if (b & 1) ret = mul(ret, a, mod);
        a = mul(a, a, mod);
        b >>= 1;
    }
    return ret % mod;
}

// 扩展欧几里得求逆元
exgcd(2, n+1, x, y);
x = (x % (n+1) + n+1) % (n+1);
x = Pow(x, m, n+1);
cout << mul(l, x, n+1);
```

---

**结论**：通过数论方法推导位置变换规律，结合快速幂和逆元计算，高效解决大规模洗牌问题。

---
处理用时：71.09秒
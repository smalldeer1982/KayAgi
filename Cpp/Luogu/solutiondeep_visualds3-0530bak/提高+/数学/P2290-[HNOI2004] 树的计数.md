# 题目信息

# [HNOI2004] 树的计数

## 题目描述

一个有 $n$ 个节点的树，设它的节点分别为 $v_1,v_2,\ldots,v_n$，已知第 $i$ 个节点 $v_i$ 的度数为 $d_i$，问满足这样的条件的不同的树有多少棵。


## 说明/提示

$1\le n\le 150$，保证满足条件的树不超过 $10^{17}$ 个。

## 样例 #1

### 输入

```
4                     
2 1 2 1
```

### 输出

```
2```

# AI分析结果



---

## 算法分类
**组合数学**

---

## 题解思路与解决难点

### 核心公式与推导
问题转化为 **Prüfer 序列**的计数问题。根据 Prüfer 序列性质：  
- 每个节点出现次数为 $d_i - 1$  
- 总序列长度为 $n-2$  

答案公式为：  
$$\frac{(n-2)!}{\prod_{i=1}^n (d_i-1)!}$$  

### 解决难点与优化
1. **大数溢出问题**  
   - **质因数分解法**：将分子分母的质因数统计后相减，避免直接计算大数阶乘。  
   - **Python 高精度**：利用 Python 原生支持大整数的特性直接计算。  
   - **组合数递推**：通过组合数递推公式 $\binom{sum}{k}$ 逐步计算乘积，避免除法溢出。  

2. **无解条件判断**  
   - 度数总和必须为 $2n-2$  
   - $n>1$ 时不能有节点度数为 0  

---

## 题解评分（≥4星）

### 1. 题解作者：TheLostWeak（5星）
- **亮点**：完整推导 Prüfer 序列与公式，代码简洁（Python 高精度实现）。  
- **代码核心**：直接计算阶乘并逐步除以每个 $(d_i-1)!$，利用 Python 自动处理大数。

### 2. 题解作者：bloodstalk（4.5星）
- **亮点**：质因数分解法，C++ 实现高效，避免溢出。  
- **代码核心**：预处理阶乘的质因数，通过质因数统计相减后相乘。

### 3. 题解作者：Pentiment（4星）
- **亮点**：使用大质数模数（$10^{17}+3$）和逆元计算，适合需要取模的场景。  
- **代码核心**：阶乘预计算后通过逆元实现除法。

---

## 最优思路提炼
**质因数分解法**（解决溢出问题）  
1. 预处理 $1$ 到 $n$ 的质因数分解。  
2. 计算分子 $(n-2)!$ 的质因数次数。  
3. 减去分母 $\prod (d_i-1)!$ 的质因数次数。  
4. 最终结果等于所有质数剩余次方的乘积。

---

## 同类型题套路
**组合计数中的阶乘除法问题**  
- **通用解法**：质因数分解统计次数，或使用逆元（需取模）。  
- **常见题型**：树计数、多重排列、生成树方案数等。

---

## 推荐题目
1. **P4981 父子**（Prüfer 序列基础）  
2. **P2624 明明的烦恼**（类似度数限制的树计数）  
3. **P5206 树的计数**（扩展 Prüfer 序列应用）

---

## 可视化与算法演示

### 关键步骤动画设计
1. **Prüfer 序列生成**  
   - **动画**：逐步删除最小叶子节点，记录父节点编号。  
   - **高亮**：当前删除的节点及其父节点，序列动态增长。  

2. **质因数分解计算**  
   - **分步展示**：  
     - 分解 $(n-2)!$ 的质因数（蓝色标记）。  
     - 分解每个 $(d_i-1)!$ 的质因数（红色标记）。  
     - 质因数次数相减后剩余次数（绿色标记）。  

3. **最终结果计算**  
   - **像素动画**：每个质因数以像素块表示，剩余次数对应块数，逐步相乘得到结果。  

### 复古游戏化实现
- **8位风格**：  
  - 质因数分解步骤用像素网格展示，每次操作伴随“滴答”音效。  
  - 背景音乐：8-bit 循环旋律。  
- **自动演示模式**：  
  - 模拟 Prüfer 序列生成过程，AI 自动选择最小叶子节点删除。  

---

## 代码核心（质因数分解法）
```cpp
#include<bits/stdc++.h>
using namespace std;

int n, cnt, primes[155], cnts[155];
long long ans = 1;

vector<int> factorize(int x) {
    vector<int> res;
    for (int p : primes) {
        if (p == 0) break;
        while (x % p == 0) {
            res.push_back(p);
            x /= p;
        }
    }
    return res;
}

int main() {
    // 预处理质数
    bool is_prime[155] = {};
    for (int i = 2; i <= 150; i++) {
        if (!is_prime[i]) {
            primes[cnt++] = i;
            for (int j = i*i; j <= 150; j += i) 
                is_prime[j] = true;
        }
    }

    cin >> n;
    int sum = 0;
    // 处理分子 (n-2)! 的质因数
    for (int i = 2; i <= n-2; i++) {
        auto factors = factorize(i);
        for (int p : factors) cnts[p]++;
    }

    // 处理分母的质因数
    for (int i = 0; i < n; i++) {
        int d; cin >> d;
        sum += d;
        if (d == 0 && n != 1) { cout << 0; return 0; }
        for (int j = 2; j < d; j++) { // 分解 (d-1)!
            auto factors = factorize(j);
            for (int p : factors) cnts[p]--;
        }
    }

    // 检查无解条件
    if (sum != 2*n - 2) { cout << 0; return 0; }

    // 计算结果
    for (int p : primes) {
        while (cnts[p]-- > 0) 
            ans *= p;
    }
    cout << ans;
}
```

---

## 个人心得
- **质因数分解法**在 C++ 中更可控，避免 Python 依赖。  
- **边界条件**（如 $n=1$）容易遗漏，需仔细验证。  
- **调试技巧**：用小数据验证质因数统计步骤，如 $n=4$ 样例。

---
处理用时：77.69秒
# 题目信息

# 化学分子式

## 题目背景

元首和元老正在共同努力学习化学，他们想让电脑帮助他模拟分子式减轻负担。请你帮他设计一个程序。


## 题目描述

你的任务是编写一个能处理在虚拟的化学里分子式的程序，在真正的化学里，每个分子式描述分子包括一个或者多个原子，但是，它可能没有真正的化学药品。

下面是原子符号和分子式的定义：

分子中一个原子由一个原子符号表示，原子符号由单个大写字母或者一个大写字母和一个小写字母组成。例如：H和He都是原子符号。

一个分子式是一个原子符号的非空序列，例如，HHHeHHHe是一个分子式，表示一个分子包括4个H和2个He。

为了方便起见，一段相同的式子，如x….x(n个X，2<=n<=99)，可以被缩写为（X）n。如果X是一个原子符号，那么括号可以省略。例如，HHHeHHHe也可以写作H2HeH2He,(HHHe)2,(H2He)2,((H)2He)2。

分子式的定义可以用一种规范的语言描述。简而言之，分子式的语法描述如下：

分子：原子|原子数量|（分子）数字|分子 分子  
原子：大写字母|大写字母 小写字母  

数字：2|3|4|5|……|99|  
大写字母：A|B|……|Z|  
小写字母：a|b|c|……|z|  

在我们这个虚拟的化学里的每一个原子都有自己的原子质量，给你原子的质量，你的程序必须输出一个用分子式表示的分子质量。分子的质量定义为所有包括的原子的质量之和。例如，假设H和He的原子质量为1和4，那么（H2He）2的分子量为12。


## 样例 #1

### 输入

```
H 1
He 4
C 12
O 16
F 19
Ne 20
Cu 64
Cc 333
END_OF_FIRST_PART
H2C
(MgF)2As
Cu(OH)2
H((CO)2F)99
0
```

### 输出

```
14
UNKNOWN
98
7426
```

# AI分析结果



## 唯一算法分类
**无算法分类**

---

## 综合分析与结论

### 核心思路
题目本质是**带括号的表达式解析**问题。各题解核心思路高度一致：
1. **分层计算**：使用栈/递归处理括号嵌套，每个括号层级维护独立的质量总和
2. **原子识别**：通过字符遍历识别原子符号（大写字母+可选小写字母）
3. **系数处理**：原子后数字作为乘法系数，括号后数字作为整体乘法系数
4. **异常处理**：遇到未定义原子符号时立即终止计算

### 关键数学逻辑
1. **原子质量累加**：原子符号 → 质量映射 → 质量×系数
2. **括号运算规则**：括号内质量总和 × 括号后系数 → 合并到上层质量
3. **分层运算公式**：
   ```
   当前层质量 = Σ(原子质量 × 系数) + Σ(子层质量 × 子层系数)
   ```

### 解决难点
- **嵌套括号处理**：需维护多层级计算状态（栈深度优先 vs 递归层次优先）
- **连续系数解析**：原子可能连续出现（如H2O）或紧跟括号（如(H2O)3）
- **符号边界判断**：大写字母后紧跟小写字母时需合并处理

### 可视化设计
- **分层高亮**：不同括号层级用不同背景色区分，当前处理位置用闪烁光标标记
- **实时栈展示**：右侧面板动态显示栈结构，每层显示当前累计质量
- **符号解析动画**：
  ```mermaid
  sequenceDiagram
    解析器->>H: 识别大写字母
    解析器->>e: 识别小写字母→组成He
    解析器->>2: 读取数字→系数=2
    动画效果: 高亮He区域，显示质量查找过程
    动画效果: 显示He×2的质量累加
  ```

---

## 题解清单 (≥4星)

### 1. 梦回还（4.5星）
**亮点**：
- 使用显式栈结构处理层级关系
- 用`substr`直接截取原子符号
- 通过栈顶指针管理嵌套层次

**核心代码片段**：
```cpp
if(ss[i] == '(') top++;
if(isdigit(ss[i])) {
    while(isdigit(ss[i])) x = x*10 + (ss[i]^'0'), i++;
    a[top] += (x-1)*ref[key]; // 已加1次，补加x-1次
}
```

### 2. DPair（4星）
**亮点**：
- 递归分解分子式为原子/括号结构
- 通过pair返回计算值和结束位置
- 严格处理括号匹配关系

**核心代码**：
```cpp
pair<ll,ll> dfs(string ele,int p,int deep){
    if(ele[i]=='(') {
        auto tmp = dfs(ele,i+1,deep+1);
        ret += tmp.first;
        i = tmp.second; // 跳转至括号结束位置
    }
    //...原子处理
}
```

### 3. zombie462（4星）
**亮点**：
- 动态规划式层级管理
- 将整个分子式包裹虚拟括号简化计算
- 利用负质量标记异常状态

**代码策略**：
```cpp
st = '(' + st + ')'; // 虚拟外层括号
stack[size-1] += stack[size] * tmp; // 合并括号层
```

---

## 最优思路提炼

### 核心技巧
1. **栈层级管理**：用数组`a[N]`维护各层质量，`top`指针表示当前层级
2. **原子快速截取**：`substr(i,1/2)`直接获取原子符号
3. **系数延迟计算**：遇到数字时，对最近原子或括号结果进行乘法补偿

### 通用解法流程
```
初始化元素质量表
读取分子式:
    while 未处理完字符:
        if 遇到 '(' : 入栈新层级
        if 遇到原子符号:
            截取完整符号 → 检查质量表 → 累加质量
            读取后续数字作为系数 → 质量 × (系数-1)补偿
        if 遇到 ')':
            读取后续系数 → 当前层质量 × 系数 → 合并到上层
            弹出当前层
输出栈底质量 or UNKNOWN
```

---

## 同类型题推荐
1. **P1175 表达式的转换**（中缀转后缀表达式）
2. **P1494 括号匹配**（栈结构应用）
3. **P1044 栈**（栈操作模拟）

---

## 可视化方案（复古像素版）

### 界面设计
```html
<canvas id="chemCanvas" width="640" height="360"></canvas>
<div id="controlPanel">
    <button onclick="step()">▶️ 步进</button>
    <input type="range" id="speed" min="1" max="5" value="3">
</div>
```

### 核心动画逻辑
```javascript
function drawFrame() {
    ctx.fillStyle = '#2D2D2D'; // 复古深灰背景
    ctx.fillRect(0, 0, 640, 360);
    
    // 绘制当前处理的字符
    ctx.fillStyle = '#FF5555'; // 像素红
    ctx.fillText(currentChar, xPos, yPos);
    
    // 绘制栈结构
    stack.forEach((layer, idx) => {
        ctx.fillStyle = idx === top ? '#55FF55' : '#888888';
        ctx.fillRect(300, 50 + idx*30, 100, 20); // 栈层图示
    });
}

function step() {
    const char = formula[pos];
    if(char === '(') {
        playSound('blip'); // 8位音效
        top++;
    } 
    //...其他字符处理
    pos++;
}
```

### 音效设计
```javascript
const audioCtx = new (window.AudioContext)();
function playSound(type) {
    const oscillator = audioCtx.createOscillator();
    oscillator.frequency.value = type === 'blip' ? 880 : 440;
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(0.1);
}
```

---

## 个人心得摘录
> "处理括号时最易出错的是系数作用域，必须确保系数仅作用于最近的原子或括号结果。通过将整个分子式包裹虚拟括号，可以统一处理最外层无括号的情况，极大简化代码逻辑。" —— zombie462

> "递归返回计算值和结束位置的设计，完美解决了括号嵌套时的字符跳转问题。这比维护全局指针更清晰可靠。" —— Rolling_L

---

## 完整代码参考（栈式解法）
```cpp
#include <iostream>
#include <map>
using namespace std;

map<string, int> elem;
int stack[100], top = 0;

int main() {
    // 读取元素质量
    string s; int m;
    while(cin >> s && s != "END_OF_FIRST_PART") {
        cin >> m;
        elem[s] = m;
    }
    
    // 处理分子式
    while(cin >> s && s != "0") {
        int valid = 1, pos = 0;
        top = 0; // 重置栈
        s = "(" + s + ")"; // 虚拟括号
        
        while(pos < s.size()) {
            if(s[pos] == '(') {
                stack[++top] = 0;
                pos++;
            } else if(s[pos] == ')') {
                int num = 0;
                for(pos++; isdigit(s[pos]); pos++)
                    num = num*10 + s[pos]-'0';
                num = num ? num : 1;
                stack[top-1] += stack[top] * num;
                stack[top--] = 0;
            } else if(isupper(s[pos])) {
                string atom(1, s[pos++]);
                if(islower(s[pos])) atom += s[pos++];
                
                if(!elem.count(atom)) { valid = 0; break; }
                
                int num = 0;
                while(isdigit(s[pos])) 
                    num = num*10 + s[pos++]-'0';
                num = num ? num : 1;
                
                stack[top] += elem[atom] * num;
            } else pos++;
        }
        
        cout << (valid ? stack[0] : -1) << endl;
    }
    return 0;
}
```

---
处理用时：101.50秒
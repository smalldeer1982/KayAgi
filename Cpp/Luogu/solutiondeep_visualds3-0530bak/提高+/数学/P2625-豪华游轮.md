# 题目信息

# 豪华游轮

## 题目描述

有一条豪华游轮（其实就是条小木船），这种船可以执行 $4$ 种指令：

`right X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船顺时针转动 $X$ 度。

`left X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船逆时针转动 $X$ 度。

`forward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正前方前进 $X$ 的距离。

`backward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正后方前进 $X$ 的距离。

随意的写出了 $n$ 个命令，找出一个种排列命令的方法，使得船最终到达的位置距离起点尽可能的远。


## 样例 #1

### 输入

```
3
forward 100
backward 100
left 90```

### 输出

```
141.421356```

# AI分析结果



**唯一算法分类**  
几何

---

**综合分析与结论**  
核心思路是将所有转向指令转化为等效角度，通过动态规划（背包问题）求出最接近180°的总转向角，应用余弦定理计算最大位移。  
**关键推导**：  
1. 设总前进距离为a，总后退为b，转向后两向量夹角θ  
2.最大位移公式：√(a² + b² - 2ab cosθ)  
3.θ越接近180°，cosθ越接近-1，距离最大  
**动态规划实现**：  
- 预处理：将左转X转为+X度，右转X转为-X度（等效为360-X）  
- 状态转移：f[i][j] 表示前i次转向能否得到j度  
- 优化：模360压缩状态空间  

---

**题解清单 (≥4星)**  
1. 斗神_君莫笑（5★）  
   - 创新点：统一左右转为正角度，使用滚动数组优化空间  
   - 亮点：余弦计算采用M_PI常量确保精度  

2. 凯特琳（4★）  
   - 特色：双向背包思路，清晰的四步操作理论  
   - 优化：布尔数组替代整型数组节省内存  

3. 不存在之人（4★）  
   - 亮点：代码简洁，巧妙处理负数取模  
   - 心得：注释强调编译器弧度转换注意事项  

---

**最优思路代码**  
```cpp
// 角度背包核心逻辑
bool dp[360] = {true};
for(auto &angle : angles) {
    bool temp[360] = {};
    for(int j=0; j<360; j++) {
        if(dp[j]) {
            temp[j] = true;
            temp[(j + angle) % 360] = true;
        }
    }
    memcpy(dp, temp, sizeof(dp));
}

// 最优角度选择
int best = 180;
for(int i=0; i<360; i++) {
    if(dp[i]) best = min(best, abs(i - 180));
}

// 余弦定理计算
double rad = best * M_PI / 180;
double ans = sqrt(a*a + b*b - 2*a*b*cos(rad));
```

---

**同类题目推荐**  
1. P2625 多米诺骨牌（余数背包）  
2. P1516 青蛙的约会（模数线性方程）  
3. P1991 无线通讯网（几何最值）  

---

**可视化设计**  
**8位像素风格演示器**：  
1. **Canvas布局**：  
   - 左侧显示角度圆盘（0-359°），红色指针标记当前总转向角  
   - 右侧显示向量合成过程，像素船体随角度转动  

2. **动画流程**：  
   - 背包DP步骤：每个角度加入时，旧角度集合绿色闪烁，新角度黄色扩散  
   - 音效：成功扩展角度时播放8bit "ping"，完成时播放胜利音效  

3. **交互功能**：  
   - 速度滑块调节DP执行速度（50ms-2s/步）  
   - 空格键暂停/继续，方向键单步前进  

**伪代码示例**：  
```javascript
// 初始化 Canvas
const ctx = canvas.getContext('2d');
const anglePoints = Array(360).fill(0).map((_,i) => ({
  x: 150 + 100*Math.cos(i*Math.PI/180),
  y: 150 + 100*Math.sin(i*Math.PI/180)
}));

function drawAngle(angle) {
  ctx.clearRect(0, 0, 300, 300);
  // 绘制角度圆盘
  anglePoints.forEach(p => ctx.fillRect(p.x, p.y, 2, 2)); 
  // 绘制当前角度指针
  const ptr = anglePoints[angle];
  ctx.fillStyle = '#FF0000';
  ctx.fillRect(ptr.x-3, ptr.y-3, 6, 6);
}
```

---

**心得摘录**  
> "调试时发现忘记处理360度取模，导致背包数组越界——角度问题必须时刻注意模运算边界" —— 斗神_君莫笑  
> "余弦定理中的角度方向极易混淆，通过绘制向量图验证后豁然开朗" —— 不存在之人  

---

**举一反三**  
当问题涉及**方向合成**时：  
1. 分解为模数空间的最优解问题  
2. 背包DP处理离散状态  
3. 几何公式转换（如极坐标→直角坐标）  
4. 注意角度周期性与方向对称性

---
处理用时：63.72秒
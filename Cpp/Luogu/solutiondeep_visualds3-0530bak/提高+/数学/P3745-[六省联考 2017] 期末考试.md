# 题目信息

# [六省联考 2017] 期末考试

## 题目描述

有 $n$ 位同学，每位同学都参加了全部的 $m$ 门课程的期末考试，都在焦急的等待成绩的公布。

第 $i$ 位同学希望在第 $t_i$ 天或之前得知**所有**课程的成绩。如果在第 $t_i$ 天，有至少一门课程的成绩没有公布，他就会等待最后公布成绩的课程公布成绩，每等待一天就会产生 $C$ 不愉快度。

对于第 $i$ 门课程，按照原本的计划，会在第 $b_i$ 天公布成绩。

有如下两种操作可以调整公布成绩的时间:
1. 将负责课程 $X$ 的部分老师调整到课程 $Y$，调整之后公布课程 $X$ 成绩的时间推迟一天，公布课程 $Y$ 成绩的时间提前一天；每次操作产生 $A$ 不愉快度。
2. 增加一部分老师负责学科 $Z$，这将导致学科 $Z$ 的出成绩时间提前一天；每次操作产生 $B$ 不愉快度。

上面两种操作中的参数 $X, Y, Z$ 均可任意指定，每种操作均可以执行多次，每次执行时都可以重新指定参数。

现在希望你通过合理的操作，使得最后总的不愉快度之和最小，输出最小的不愉快度之和即可。

## 说明/提示

### 样例解释 1

由于调整操作产生的不愉快度太大，所以在本例中最好的方案是不进行调整；全部的 $5$ 门课程中，最慢的在第 $3$ 天出成绩；  
同学 $1$ 希望在第 $5$ 天或之前出成绩，所以不会产生不愉快度；  
同学 $2$ 希望在第 $1$ 天或之前出成绩，产生的不愉快度为 $(3 - 1) \times 2 = 4$；  
同学 $3$ 希望在第 $2$ 天或之前出成绩，产生的不愉快度为 $(3 - 2) \times 2 = 2$；  
同学 $4$ 希望在第 $3$ 天或之前出成绩，所以不会产生不愉快度；  
不愉快度之和为 $4 + 2 = 6$。

### 数据范围

| Case # | $n, m, t_i, b_i$ | $A, B, C$ |
|:-:|:-:|:-:|
| 1, 2 | $1 \leq n, m, t_i, b_i \leq 2000$ | $A = 10^9; B = 10^9; 0 \leq C \leq 10^2$ |
| 3, 4 | $1 \leq n, m, t_i, b_i \leq 2000$ | $0 \leq A; C \leq 10^2; B = 10^9$ |
| 5, 6, 7, 8 | $1 \leq n, m, t_i, b_i \leq 2000$ | $0 \leq B \leq A \leq 10^2; 0 \leq C \leq 10^2$ |
| 9 - 12 | $1 \leq n, m, t_i, b_i \leq 2000$ | $0 \leq A, B, C \leq 10^2$ |
| 13, 14 | $1 \leq n, m, t_i, b_i \leq 10^5$ | $0 \leq A, B \leq 10^5; C = 10^{16}$ |
| 15 - 20 | $1 \leq n, m, t_i, b_i \leq 10^5$ | $0 \leq A, B, C \leq 10^5$ |

## 样例 #1

### 输入

```
100 100 2
4 5
5 1 2 3
1 1 2 3 3```

### 输出

```
6```

## 样例 #2

### 输入

```
3 5 4
5 6
1 1 4 7 8
2 3 3 1 8 2```

### 输出

```
33```

# AI分析结果



# **算法分类**  
**无算法分类**

---

## **题解思路、算法要点与解决难点**  

### **核心思路**  
所有题解均围绕**确定最优的最晚公布时间**展开，通过枚举或三分法寻找最小总不愉快度。关键点在于：  
1. **代价函数性质**：总不愉快度关于最晚时间呈单峰函数（先减后增），允许三分法。  
2. **数学优化**：通过前缀和、排序快速计算每个时间点的代价。  
3. **操作优先级**：根据A/B的比值选择调整策略（优先操作1或直接操作2）。  

### **数学方法**  
- **前缀和优化**：预处理课程/学生的累计时间分布，将复杂度从O(nm)降至O(n)。  
  - 学生等待代价：`sum_c[i] = Σ(max(0, i - t_j))`，用前缀和快速计算。  
  - 课程调整代价：分类讨论A/B，利用前缀和统计超时课程数（`need`）与可借用时间（`rest`）。  
- **三分法证明**：证明代价函数为下凸单峰，确保三分正确性。  

### **解决难点**  
1. **大规模数据**：当n/m达1e5时，需避免O(nm)暴力枚举，用前缀和或排序二分优化。  
2. **操作策略选择**：当A < B时，需优先用操作1转移时间差，剩余部分用操作2。  

---

## **题解评分**  

### **泅荼 (5星)**  
- **思路清晰**：直接枚举时间，前缀和预处理。  
- **代码简洁**：利用桶统计分布，O(max(b_i))时间高效计算。  
- **实践友好**：无复杂逻辑，适合快速实现。  

### **wjyyy (4.5星)**  
- **理论严谨**：证明三分法可行性，代码包含特判处理。  
- **优化到位**：前缀和减少重复计算，复杂度O(m + log b_i)。  

### **Soulist (4星)**  
- **代码精简**：双前缀和快速计算代价。  
- **贪心明确**：直接分类讨论A/B策略，逻辑直观。  

---

## **最优思路提炼**  
1. **枚举最晚时间T**，计算两部分代价：  
   - **调整课程到T的代价**：  
     - 若A < B：用操作1转移最多`min(rest, need)`次，剩余用B。  
     - 否则全用B。  
   - **学生等待代价**：统计所有t_i < T的学生，累加(T - t_i)*C。  
2. **前缀和加速**：预处理课程/学生的前缀和数组，O(1)查询区间和。  

---

## **同类型题与套路**  
- **最优化问题**：寻找单峰函数极值（三分/枚举）。  
- **前缀和技巧**：处理区间统计问题（如逆序对、滑动窗口）。  
- **贪心策略**：根据代价比选择操作优先级。  

---

## **推荐题目**  
1. **P2920 [USACO08NOV] Time Management**（任务调度最优化）  
2. **P2216 [HAOI2007] 理想的正方形**（二维滑动窗口最值）  
3. **P4344 [SHOI2015] 脑洞治疗仪**（区间操作与最优化）  

---

## **可视化与算法演示**  

### **动画设计**  
1. **时间轴展示**：横向时间轴标记课程分布（红点）与学生期望（蓝点）。  
2. **滑动最晚时间T**：  
   - **高亮T位置**，动态计算调整代价（红色区域）与学生代价（蓝色区域）。  
   - **颜色区分**：A操作为黄色箭头（转移时间），B操作为绿色箭头（直接减少）。  
3. **代价曲线图**：右侧绘制代价随T变化的曲线，实时更新当前最小值。  

### **复古像素风格**  
- **Canvas绘制**：  
  - 8-bit风格时间轴，课程/学生用不同像素块表示。  
  - 音效：调整时播放“哔”声，找到最小值时播放胜利音效。  
- **自动演示**：AI模拟枚举过程，逐步逼近最优解，速度可调。  

---

## **核心代码实现**  
```cpp
// 前缀和预处理（泅荼题解核心）
for(ll i=100000;i>=1;i--){
    sum1 += i*bac[i], t1 += bac[i];    // 课程早于i的总时间
    sum2 -= i*bac[i], t2 -= bac[i];   // 课程晚于i的总时间
    // 计算调整代价
    ll need = sum1 - t1*i;            // 需减少的总天数
    ll rest = t2*i - sum2;            // 可借用的总天数
    if(A < B) cost += min(need, rest)*A + max(0, need-rest)*B;
    else cost += need*B;
    // 学生等待代价
    ans = min(ans, cost + (t3*i - sum3)*C);
}
```

---

## **个人心得摘录**  
> "枚举法的关键在于预处理，将O(n²)暴力转为O(n)递推。不要畏惧大规模数据，有序统计才是王道。" —— 泅荼  
> "三分法看似高级，实则边界处理坑多，务必验证单峰假设。" —— wjyyy  

---

**可视化交互示例**（伪代码）：  
```javascript
// Canvas绘制时间轴
ctx.fillStyle = '#FF0000'; // 课程红点
for(let b of courses) ctx.fillRect(b*scaleX, 50, 2, 2);
ctx.fillStyle = '#0000FF'; // 学生蓝点
for(let t of students) ctx.fillRect(t*scaleX, 80, 2, 2);

// 滑动T时更新代价
function update(T) {
    let cost = calcAdjustCost(T); // 计算调整代价
    let wait = calcWaitCost(T);   // 计算学生等待
    drawCostCurve(T, cost + wait); // 更新曲线
}
```

---
处理用时：71.19秒
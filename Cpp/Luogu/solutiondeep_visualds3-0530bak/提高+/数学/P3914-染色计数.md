# 题目信息

# 染色计数

## 题目描述

有一颗$N$个节点的树，节点用$1,2,\cdots,N$编号。你要给它染色，使得相邻节点的颜色不同。有$M$种颜色，用$1,2,\cdots,M$编号。每个节点可以染$M$种颜色中的若干种，求不同染色方案的数量除以($10^9 + 7$)的余数。


## 说明/提示

• 对于30% 的数据，$1 \le N \le 10; 1 \le M \le 4$；

• 对于60% 的数据，$1 \le N \le 200; 1 \le M \le 200$；

• 对于100% 的数据，$1 \le N \le 5000; 1 \le M \le 5000$。


## 样例 #1

### 输入

```
2 2
1 1
2 1 2
1 2```

### 输出

```
1```

# AI分析结果



## 【唯一算法分类】
组合数学

---

## 【题解思路、算法要点与解决难点】
### 核心思路
1. **状态定义**：`dp[i][j]` 表示节点i染颜色j时的子树方案数
2. **转移方程**：`dp[u][j] = ∏(子节点总方案数 - 子节点同色方案数)`
3. **关键优化**：预处理每个节点的总方案数 `sum[u] = Σdp[u][j]`，将时间复杂度从 O(n^3) 优化至 O(nm)

### 数学推导
设节点u的某个子节点v的总方案数为：
$$ sum[v] = \sum_{c=1}^m dp[v][c] $$
则当u选择颜色j时，子节点v的合法方案数为：
$$ valid_{v,j} = sum[v] - dp[v][j] $$
最终转移方程：
$$ dp[u][j] = \prod_{v \in son(u)} valid_{v,j} $$

### 解决难点
1. **负数取模**：`(sum[v] - dp[v][j] + mod) % mod` 确保计算结果非负
2. **空间优化**：使用int数组代替long long，计算时临时转换类型
3. **虚根技巧**：部分题解通过添加虚根简化边界处理

---

## 【题解评分 (≥4星)】
### Youngsc（4.5星）
- **亮点**：完整处理负数取模，添加虚根统一逻辑
- **代码优化**：链式前向星存图，空间控制优秀
- **核心代码段**：
```cpp
for(R int j=1; j<=m; ++j) {
    if(!f[x][j]) continue;
    f[x][j] = 1LL*f[x][j]*(tot[p]-f[p][j])%mod; 
    while(f[x][j]<0) f[x][j] += mod; // 显式处理负数
}
```

### fishing_cat（4.2星）
- **亮点**：代码简洁易读，使用vector存图
- **数学表达**：直接推导式 `f[u][col] *= (sum[son] - f[son][col])`
- **核心代码段**：
```cpp
for (auto son : tree[u]) {
    if (son == fa) continue;
    for (int col=1; col<=m; ++col) 
        f[u][col] = f[u][col] * (sum[son] - f[son][col]) % mod;
}
```

### __phiu（4.0星）
- **亮点**：明确标注关键公式位置
- **实践技巧**：动态类型转换避免MLE
- **核心注释**：
```cpp
// 计算时转为long long防止溢出
long long now = (long long)dp[u][j] * valid;
dp[u][j] = (int)(now % mod);
```

---

## 【最优思路/技巧提炼】
1. **双数组优化**：`dp[i][j]` 与 `sum[i]` 配合，将乘积计算复杂度从 O(m) 降为 O(1)
2. **同余处理**：`(a - b + mod) % mod` 确保非负结果
3. **树形DP范式**：后序遍历计算子树，父节点整合子节点信息
4. **空间压缩**：用int存储配合计算时long long转换

---

## 【同类型题与算法套路】
1. **树形DP+组合计数**：P1352 没有上司的舞会（状态选择）、P1273 有线电视网（子树贡献统计）
2. **颜色限制问题**：P4516 潜入行动（相邻节点状态约束）
3. **组合优化**：P4071 排列计数（容斥原理）

---

## 【个人心得摘录】
> "WA/TLE/MLE了一节课才通过... 必须用int数组配合long long临时转换" —— Youngsc  
> "定义long long数组会MLE，计算时转long long是关键" —— huanzi  
> "负数取模不能用abs，必须加mod再取模" —— 神眷之樱花

---

## 【可视化设计：像素化树形DP】
### 动画要素
1. **树结构**：8-bit像素树，节点闪烁表示当前处理位置
2. **颜色标记**：
   - 红色：当前节点u和选定颜色j
   - 绿色：子节点v的总方案数sum[v]
   - 黄色：`sum[v] - dp[v][j]` 计算过程
3. **公式展示**：底部滚动显示 `dp[u][j] = Π(green - yellow)`

### 交互设计
- **步进控制**：空格键单步执行DFS遍历
- **音效提示**：
  - "叮"：完成一个节点计算
  - "嘟"：发现负数取模操作
- **数据面板**：右侧显示当前dp[u][j]和sum[u]数值

### 复古元素
```javascript
// 伪代码示例
const colors = ["#000000", "#FF0000", "#00FF00", "#FFFF00"]; // 8-bit调色板
function drawNode(x, y, value) {
    ctx.fillStyle = colors[state];
    ctx.fillRect(x*16, y*16, 14, 14); // 16x16像素方块
    drawText(value, x*16+2, y*16+12); // 8x8像素字体
}
```

---

## 【推荐题目】
1. [P1352] 没有上司的舞会（树形DP基础）
2. [P4516] 潜入行动（相邻状态约束）
3. [P4071] 排列计数（组合数学综合）

---
处理用时：70.19秒
# 题目信息

# 小猴打架

## 题目描述

一开始森林里面有 $N$ 只互不相识的小猴子，它们经常打架，但打架的双方都必须不是好朋友。每次打完架后，打架的双方以及它们的好朋友就会互相认识，成为好朋友。经过 $N-1$ 次打架之后，整个森林的小猴都会成为好朋友。   
现在的问题是，总共有多少种不同的打架过程。   
比如当 $N=3$ 时，就有 $\{1-2,1-3\}\{1-2,2-3\}\{1-3,1-2\}\{1-3,2-3\}\{2-3,1-2\}\{2-3,1-3\}$ 六种不同的打架过程。 


## 说明/提示

$50\%$ 的数据 $N\le 10^3$。  
$100\%$ 的数据 $N\le10^6$。 

## 样例 #1

### 输入

```
4```

### 输出

```
96```

# AI分析结果



## 算法分类
**组合数学**

---

## 题解思路与核心难点

### 核心思路
题目等价于求 **N 个节点的带标号生成树数量**与**边生成顺序排列数**的乘积。  
1. **生成树数量**：根据 Cayley 定理，N 个节点的生成树数量为 $N^{N-2}$  
2. **边生成顺序**：每棵生成树的边有 $(N-1)!$ 种排列方式  
最终答案公式：$\text{ans} = N^{N-2} \times (N-1)! \mod 9999991$

### 数学推导难点对比
| 题解方法       | 关键推导思路                                                                 | 复杂度优化技巧                    |
|----------------|----------------------------------------------------------------------------|----------------------------------|
| Cayley定理      | 通过 Prufer 编码证明生成树数量，直接应用定理计算                             | 分步计算幂和阶乘，避免溢出         |
| 矩阵树定理      | 构造完全图的基尔霍夫矩阵，通过行列式计算生成树数量                           | 矩阵初等变换化简为上三角矩阵       |
| 直接公式法      | 直接给出结论公式，省略中间证明过程                                           | 循环合并计算幂和阶乘，减少循环次数 |

---

## 高星题解推荐（≥4星）

### 1. da32s1da（4.5星）
- **亮点**：代码简洁高效，直接分步计算幂和阶乘，可读性强  
- **代码片段**：
  ```cpp
  for(int i=1;i<=n-2;i++) ans=(ans*n)%mod;  // 计算 N^{N-2}
  for(int i=1;i<=n-1;i++) ans=(ans*i)%mod;  // 计算 (N-1)!
  ```

### 2. DPair（4.5星）
- **亮点**：提供完整的 Prufer 编码证明，数学推导清晰  
- **关键证明**：
  > Prufer 编码长度 $N-2$，每个位置可取 $1\sim N$，总编码数 $N^{N-2}$，与生成树一一对应

### 3. Terraria（4星）
- **亮点**：强调开 long long 和取模细节，适合新手避坑  
- **注意事项**：
  ```cpp
  // 每次计算都要取模！
  ans = (ans * n) % mod;
  ```

---

## 最优解题思路提炼

### 关键公式与实现
1. **公式推导**：
   $$ \text{ans} = \underbrace{N^{N-2}}_{\text{生成树数}} \times \underbrace{(N-1)!}_{\text{边排列数}} $$
2. **代码实现**：
   ```cpp
   long long ans = 1;
   for(int i=1; i<=n-2; i++) ans = ans * n % MOD;  // 计算 N^{N-2}
   for(int i=1; i<=n-1; i++) ans = ans * i % MOD;  // 计算 (N-1)!
   ```

---

## 同类题型与算法套路

### 常见组合数学模型
1. **生成树计数**：Cayley 定理、Prufer 编码、矩阵树定理  
2. **排列组合优化**：阶乘预处理、快速幂取模、逆元计算  

### 推荐练习题
1. [P4981 父子](https://www.luogu.com.cn/problem/P4981)（生成树计数基础）  
2. [P4430 猴子打架](https://www.luogu.com.cn/problem/P4430)（同类问题变式）  
3. [P6030 CF1264D1](https://www.luogu.com.cn/problem/P6030)（组合数学+容斥原理）

---

## 可视化算法演示

### 核心数学过程动画设计
1. **Prufer 编码生成**：  
   - **像素动画**：以 8-bit 风格显示节点删除过程，当前操作的节点用红色高亮  
   - **音效触发**：每删除一个节点时播放 "beep" 音效，编码显示区域同步更新  
   - **步进控制**：允许暂停观察当前编码状态，按空格键继续下一步  

2. **公式计算流程**：  
   ```javascript
   // 伪代码演示计算过程
   function calculate() {
     let ans = 1;
     // 计算 N^{N-2}
     for(let i=1; i<=n-2; i++) {
       ans = (ans * n) % MOD;
       drawPixelBar(i, "power");  // 在Canvas绘制进度条
       playSound("power_step");
     }
     // 计算 (N-1)!
     for(let i=1; i<=n-1; i++) {
       ans = (ans * i) % MOD;
       drawPixelBar(i, "factorial"); 
       playSound("factorial_step");
     }
   }
   ```

### 复古风格实现要点
- **调色板**：使用 8 色方案（黑、白、红、蓝、绿、黄、青、紫）  
- **Canvas 绘制**：  
  ```javascript
  ctx.fillStyle = "#FF0000"; // 红色表示当前操作
  ctx.fillRect(x, y, 16, 16); // 绘制16x16像素块
  ```
- **音效设计**：  
  - 幂计算步：8-bit 短促 "滴" 声  
  - 阶乘计算步：低音 "咚" 声  
  - 最终结果：播放胜利旋律

---

## 完整代码实现
```cpp
#include <cstdio>
const int MOD = 9999991;

int main() {
    int n;
    scanf("%d", &n);
    long long ans = 1;
    for(int i=1; i<=n-2; ++i) 
        ans = ans * n % MOD;
    for(int i=1; i<=n-1; ++i)
        ans = ans * i % MOD;
    printf("%lld", ans);
    return 0;
}
```

---
处理用时：83.24秒
# 题目信息

# 【模板】矩阵求逆

## 题目描述

求一个 $N\times N$ 的矩阵的逆矩阵。答案对 ${10}^9+7$ 取模。

## 说明/提示

对 $30 \%$ 的数据有 $N\le 100$；  
对 $100 \%$ 的数据有 $N\le 400$，所有 $0 \le a_{i j} < {10}^9 + 7$。

## 样例 #1

### 输入

```
3
1 2 8
2 5 6
5 1 2```

### 输出

```
718750005 718750005 968750007
171875001 671875005 296875002
117187501 867187506 429687503```

## 样例 #2

### 输入

```
3
3 2 4
7 2 9
2 4 3```

### 输出

```
No Solution```

# AI分析结果



# 【矩阵求逆题解分析】

## **算法分类**  
**数论**（涉及模逆元计算与高斯消元）

---

## **核心思路与算法要点**  
**高斯-约旦消元法**  
1. **增广矩阵构造**：将原矩阵与单位矩阵拼接，通过行变换将原矩阵转化为单位矩阵，此时右侧部分即为逆矩阵。  
2. **模逆元处理**：除法转换为乘以模逆元（快速幂实现）。  
3. **判无解条件**：消元过程中若主元为0则矩阵不可逆。  

**关键公式与推导**  
- 模逆元：$a^{-1} \equiv a^{p-2} \mod p$（费马小定理，$p=10^9+7$为质数）。  
- 行变换公式：  
  - 交换行：$R_i \leftrightarrow R_j$  
  - 归一化：$R_i \leftarrow R_i \times a_{i,i}^{-1}$  
  - 消元：$R_j \leftarrow R_j - R_i \times a_{j,i}$  

---

## **题解评分与亮点**  
### 1. [一只萌新]（★★★★☆）  
- **亮点**：代码结构清晰，注释详细，显式构造增广矩阵，适合新手理解。  
- **核心代码**：  
  ```cpp
  int kk = qpow(a[i][i], mod-2);  
  for (int j = i; j <= (n<<1); ++j)  
      a[i][j] = (a[i][j] * kk % mod);  
  ```

### 2. [cosmicAC]（★★★★☆）  
- **亮点**：原地操作节省内存，空间复杂度为$O(N^2)$（普通方法$O(N^2)$），代码高效但较难理解。  
- **核心代码**：  
  ```cpp
  int inv(int p) { ... } // 扩展欧几里得求逆元  
  a[k][k] = inv(a[k][k]);  
  ```

### 3. [walk_alone]（★★★★★）  
- **亮点**：严格数学证明，详细解释初等矩阵与逆矩阵关系，理论完备性最佳。  
- **核心代码**：  
  ```cpp
  B.MUL(i, ksm(A.a[i][i], mod-2));  
  A.MUL(i, ksm(A.a[i][i], mod-2));  
  ```

---

## **最优技巧提炼**  
1. **行交换优化**：选择绝对值最大主元减少浮点误差（在模运算中无效，但保持逻辑一致）。  
2. **逆元预计算**：在归一化步骤中一次性计算主元逆元，避免重复调用快速幂。  
3. **原地操作**：直接修改原矩阵，避免额外空间开销（如cosmicAC的题解）。  

---

## **同类型题目推荐**  
1. [P3389 高斯消元法](https://www.luogu.com.cn/problem/P3389)  
2. [P2455 线性方程组](https://www.luogu.com.cn/problem/P2455)  
3. [P3390 矩阵快速幂](https://www.luogu.com.cn/problem/P3390)  

---

## **可视化设计思路**  
### **动画演示**  
1. **矩阵分块**：左侧为原矩阵，右侧为单位矩阵，用不同颜色区分。  
2. **步进操作**：  
   - **主元选择**：高亮当前列中最大元素的行（红色边框）。  
   - **行交换**：动画显示两行位置互换（黄色箭头）。  
   - **归一化**：当前行主元变为1，右侧对应位置同步变化（绿色高亮）。  
   - **消元**：其他行减去当前行的倍数，右侧矩阵同步更新（蓝色流动效果）。  

### **复古像素风格实现**  
```javascript
// Canvas绘制示例（关键帧）  
function drawMatrix(ctx, matrix, highlightRow) {
    for (let i = 0; i < n; i++) {
        // 使用8位色：原矩阵#FF6666，单位矩阵#66FF66
        ctx.fillStyle = (i === highlightRow) ? "#FF0000" : "#FFFFFF";
        // 绘制矩阵格子...
    }
}
```

---

## **代码实现（核心部分）**  
```cpp
void GaussJordan() {
    for (int i = 1; i <= n; ++i) {
        int pivot = i;
        for (int j = i; j <= n; ++j)
            if (a[j][i]) { pivot = j; break; }
        if (!a[pivot][i]) { /* No Solution */ }
        swap(a[i], a[pivot]);
        
        ll inv = qpow(a[i][i], mod-2); // 关键：计算逆元
        for (int j = 1; j <= 2*n; ++j)
            a[i][j] = a[i][j] * inv % mod;
        
        for (int j = 1; j <= n; ++j) {
            if (j == i) continue;
            ll factor = a[j][i];
            for (int k = i; k <= 2*n; ++k)
                a[j][k] = (a[j][k] - factor * a[i][k] % mod + mod) % mod;
        }
    }
}
```

---
处理用时：67.40秒
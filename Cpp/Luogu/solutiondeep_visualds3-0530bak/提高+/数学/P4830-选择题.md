# 题目信息

# 选择题

## 题目描述

docriz 正在考试，他遇到了一个奇怪的选择题：这个选择题共有 $n$ 个选项，其中只有一个选项是正确的。他完全不会做这题，所以只能靠蒙。

蒙这道题分为 $n - 2$ 轮，在第 $1$ 轮开始之前，docriz 会在这 $n$ 个选项中随机蒙一项，之后的每轮流程如下：首先，nocriz 会过来帮他排除一个选项，由于 nocriz 事先知道答案，所以他会在现有的除正确的那一项和 docirz 正在选的那一项外的选项里，随机删去一个。之后，docriz 可以选择是否更换自己蒙的选项，如果更换，则随机更换到除正在选的那一项之外的任意一项。

docriz 在这 $n - 2$ 轮中，由于和 nocriz 达成的神秘协定，需要恰好更换 $k$ 次选项。他想知道，如何更换，使得自己蒙对的概率最大，输出这个概率。为了方便，你需要输出这个概率的分数形式在模 $10^9 + 7$ 意义下的结果。

## 说明/提示

样例 $1$ 到 $4$ 分别为 $\frac{2}{3}, \frac{1}{3}, \frac{3}{4}, \frac{5}{8}$。

对于 $30\%$ 的数据，保证 $5 \leq n \leq 10$。

对于另外 $5\%$ 的数据，保证 $k = 0$。

对于另外 $10\%$ 的数据，保证 $k = 1$。

对于另外 $10\%$ 的数据，保证 $k = n - 2$。

对于另外 $5\%$ 的数据，保证 $n \leq 10^2$。

对于另外 $10\%$ 的数据，保证 $n \leq 10^3$。

对于 $100\%$ 的数据，保证 $5 \leq n \leq 10^5, 0 \leq k \leq n - 2$。

## 样例 #1

### 输入

```
3 1```

### 输出

```
666666672```

## 样例 #2

### 输入

```
3 0```

### 输出

```
333333336```

## 样例 #3

### 输入

```
4 1```

### 输出

```
750000006```

## 样例 #4

### 输入

```
4 2```

### 输出

```
625000005```

## 样例 #5

### 输入

```
100000 99998```

### 输出

```
439903656```

# AI分析结果



**唯一算法分类**: 数论

**题解思路、算法要点与解决难点**  
本题核心在于概率递推与模逆元计算。最优策略是最后一次更换放在最后一次排除后（选项最少），前k-1次更换尽量在选项较多时进行以最大化错误概率。关键递推式为错误概率的递推：

1. **递推公式**：  
   每次更换后的错误概率为：  
   \[
   p_{\text{new}} = 1 - \frac{p_{\text{old}}}{x-1}
   \]  
   其中，\( x \) 是当前剩余选项数，初始错误概率为 \( \frac{n-1}{n} \)。  

2. **模运算优化**：  
   递推过程中维护分子分母的模运算，最终通过快速幂计算模逆元。  

**题解评分**  
1. **Itst的题解（4星）**  
   - 思路清晰，直接推导递推式，代码简洁高效。  
   - 使用模运算优化，避免大数运算溢出。  
   - 通过循环维护分子分母，时间复杂度 \( O(k) \)。  

**最优思路或技巧提炼**  
- **贪心策略**：最后一次更换必选在选项最少时，前k-1次尽量在选项多时更换。  
- **递推优化**：用分数形式维护错误概率，避免浮点误差。  
- **模逆元**：使用快速幂计算分数模值，确保结果正确。  

**同类型题或类似算法套路**  
- 涉及概率递推和模运算的题目，如三门问题变种、动态规划中的概率优化问题。  
- 常用组合数学模型，如马尔可夫链、贝叶斯公式。  

**推荐洛谷题目**  
1. P2613（有理数取余模板题）  
2. P1850（概率与期望动态规划）  
3. P1365（条件概率与递推）  

**个人心得摘录**  
- 调试时注意模运算中负数处理，需手动转正。  
- 递推式推导需验证样例，避免公式错误。  

**可视化与算法演示**  
- **动画方案**：  
  1. **初始状态**：显示n个选项，高亮初始选择（红色错误，绿色正确）。  
  2. **每轮排除**：nocrix排除一个选项（灰色标记），选项数递减。  
  3. **更换操作**：更换时显示当前错误概率及分母分子变化。  
- **颜色标记**：当前操作用黄色高亮，中间结果以浮动数值显示。  
- **复古像素风格**：Canvas绘制选项格子，8-bit音效提示更换和排除动作。  

**代码片段（Itst题解核心）**  
```cpp
int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    if (k == 0) {
        cout << poww(n, MOD - 2); // 1/n的逆元
    } else {
        k--;
        long long fz = n - 1, fm = n;
        n -= 2;
        while (k--) { // 处理前k-1次更换
            fz = ((fm = fm * n % MOD) - fz) % MOD;
            n--;
        }
        cout << fz * poww(fm, MOD - 2) % MOD;
    }
    return 0;
}
```  
**核心逻辑**：维护分子分母，每次更新为 \( fz = (fm \cdot n - fz) \mod \text{MOD} \)，最终计算模逆元。  

**可视化实现（伪代码）**  
```javascript
// Canvas绘制选项格子
function drawOptions(n, current) {
    for (let i = 0; i < n; i++) {
        ctx.fillStyle = i === correct ? 'green' : (i === current ? 'red' : 'blue');
        ctx.fillRect(i * 50, 0, 40, 40);
    }
}
// 播放8-bit音效
function playSound(effect) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = effect === 'swap' ? 440 : 220;
    osc.connect(audioCtx.destination);
    osc.start();
    osc.stop(0.1);
}
```  
**交互设计**：用户点击按钮触发更换，动画步进显示概率变化。

---
处理用时：331.75秒
# 题目信息

# hby与tkw的基情

## 题目背景

> 基情恒久远，一对永流传。

hby 和 tkw 是一对好基友，他们经常在一起做♂游♂戏 (/滑稽)。


## 题目描述

他们喜欢玩字符串游戏，尤其喜欢玩回文串。每次 hby 会给出一个数 $n$，那么 tkw 就需要给出 $Ans=\sum\limits_{i=1}^ni\times s[i]\times[i\bmod 2]$。其中 $s[i]$ 代表长度为 $i$ 的回文串的个数（只考虑小写字母），最后面是 bool 表达式

不过由于 tkw 最近学 ycz 找妹纸去了，于是他就将这个问题交给了你，如果你不能在 $1\rm s$ 内答出来，那么 hby 和 tkw 的基情将会破裂！~~（不过那样 tkw 就可以安心地找妹纸了）~~

由于答案会非常大，所以你只需要输出答案 $\bmod 10^9+7$ 的值即可

## 说明/提示

对于 $10\%$的数据，$n\le 5$。

对于另外 $20\%$ 的数据，$\sum n\le 10^7$。

对于另外 $20\%$ 的数据，$T=1$。

对于 $100\%$ 的数据，$1\le T\le 5\times 10^5$，$1\le n\le 10^9$。

## 样例 #1

### 输入

```
2
1
3```

### 输出

```
26
2054```

# AI分析结果



**唯一算法分类**：组合数学

---

### **题解思路与核心难点**

**问题转化**  
题目要求计算奇数长度回文串的加权和。每个奇数长度回文串的数量为 $s_i = 26^{(i+1)/2}$，转化为求和：  
$$S = \sum_{i=1}^m (2i-1) \cdot 26^i \quad \text{其中} \ m = \left\lfloor \frac{n}{2} \right\rfloor$$  

**关键公式推导**  
利用错位相减法：  
1. 原式 $\times 26$ 后与原式相减，得到：  
   $$25S = (2m-1) \cdot 26^{m+1} - 26 - 2 \sum_{i=2}^m 26^i$$  
2. 中间求和部分用等比数列公式简化，最终推导出：  
   $$S = \frac{(2m-1) \cdot 26^{m+1} - 2 \cdot \frac{26^{m+1}-26^2}{25} -26}{25}$$  

**解决难点**  
1. **快速幂优化**：计算 $26^k \bmod p$ 需高效，普通快速幂时间复杂度为 $O(\log k)$。  
2. **光速幂优化**（Alarm5854题解）：预处理 $26$ 的高次幂，将时间复杂度降至 $O(1)$ 每询问。  

---

### **题解评分 (≥4星)**

1. **Alarm5854 (5星)**  
   - **亮点**：光速幂预处理，$O(T)$ 时间复杂度；代码高效，适合大规模数据。  
   - **代码片段**：  
     ```cpp  
     a[0] = 1;  
     for (int i=1; i<=N; ++i) a[i] = a[i-1] * 26 % mod;  
     b[0] = 1;  
     for (int i=1; i<=N; ++i) b[i] = b[i-1] * a[N] % mod;  
     ```  
2. **Wolfycz (4星)**  
   - **亮点**：公式推导清晰，代码简洁，适合快速实现。  
   - **代码片段**：  
     ```cpp  
     int Ans = 1ll * (1ll * mlt(26, n+1) * ((n<<1)-inv2+p) % p + 26ll*inv2%p) * inv % p;  
     ```  
3. **jianhe (4星)**  
   - **亮点**：分步推导明确，代码直接应用公式，可读性高。  
   - **代码片段**：  
     ```cpp  
     ans = qp(26, m+2) * ((n<<1)-1) % mod;  
     ans = (ans - 2 * (qp(26, m+2)-26*26) % mod * inv25) % mod;  
     ```  

---

### **最优思路提炼**

1. **错位相减法**：将等差乘等比数列转化为闭合公式。  
2. **光速幂预处理**：将 $26^k$ 分解为低位和高位两部分预处理，查询时合并。  
3. **逆元优化**：利用 $25^{-1} \bmod p$ 避免除法，加速模运算。  

---

### **同类问题与算法套路**

- **常见模型**：求解形如 $\sum_{k=1}^n k \cdot r^k$ 的数列和。  
- **通用解法**：  
  1. 错位相减转化为闭合公式。  
  2. 快速幂/光速幂优化高次幂计算。  
  3. 模运算中利用逆元避免除法。  

**推荐题目**：  
1. [P4942 小凯的疑惑](https://www.luogu.com.cn/problem/P4942)  
2. [P1939 矩阵加速](https://www.luogu.com.cn/problem/P1939)  
3. [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)  

---

### **可视化与算法演示**

**动画设计**：  
1. **步骤高亮**：  
   - **红色**：原式 $S$ 的每一项 $(2i-1) \cdot 26^i$。  
   - **蓝色**：$26S$ 的每一项对齐后相减。  
   - **绿色**：中间等比数列求和部分。  
2. **光速幂预处理**：  
   - 分块显示预处理数组 `a` 和 `b`，动态填充颜色表示计算进度。  
3. **音效提示**：  
   - 每完成一项快速幂计算时播放“滴”声。  
   - 公式推导完成时播放8-bit胜利音效。  

**复古风格**：  
- **像素字体**：使用复古8-bit字体显示公式和中间结果。  
- **Canvas动画**：用色块表示幂次计算，如 $26^4$ 显示为4个叠加的方块。  

---

### **代码实现（光速幂核心）**

```cpp
const int N = 1 << 15;
ll a[N+1], b[N+1]; // 预处理数组

void precompute() {
    a[0] = 1;
    for (int i=1; i<=N; ++i) 
        a[i] = a[i-1] * 26 % mod;
    b[0] = 1;
    for (int i=1; i<=N; ++i) 
        b[i] = b[i-1] * a[N] % mod;
}

ll fast_pow(ll k) {
    return a[k & (N-1)] * b[k >> 15] % mod;
}
```

---

**个人心得**：  
Alarm5854在题解中提到预处理光速幂时，采用分块思想将指数分解为高16位和低16位，大幅减少计算量。这种“空间换时间”的策略在处理高次幂时极具普适性。

---
处理用时：83.20秒
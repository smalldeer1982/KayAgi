# 题目信息

# painting

## 题目背景

Wolfycz很喜欢画画（雾

## 题目描述

Wolfycz喜欢网格图，他希望在网格图上画上一些黑格子，使得每一列都恰好有一个黑格子。但是黑格子太乱了不好看，所以Wolfycz希望黑格子按列号依次连线是下降的，具体来讲，每列黑格子所在行号不得小于前一列黑格子所在行号（我们令左上角为第一行第一列）

Wolfycz觉得这样画出来的图非常漂亮，但是Wolfycz有时候觉得连线要严格下降才好看（即每列黑格子所在行号必须大于前一列黑格子所在行号），有时候觉得连线只要不上升就好看（即每列黑格子所在行号不得小于前一列黑格子所在行号）。现在Wolfycz想知道，对于一个$N×M$的网格图，他能画出多少个好看的图？两个图不相同，当且仅当存在某一列的黑格子，它在两个图中对应的行号不同

UPD：$N$行$M$列

## 说明/提示

对于$20\%$的数据，$T\leqslant 5,N\leqslant 8,M\leqslant 8$

对于另外$20\%$的数据，$N=1$或$M=1$

对于另外$20\%$的数据，$N\leqslant 10^6,M\leqslant 10^6$

对于$100\%$的数据，$T\leqslant 50,N\leqslant 10^{18},M\leqslant 10^6$

## 样例 #1

### 输入

```
5
5 2 1
5 3 0
3 4 0
8 4 1
6 2 1```

### 输出

```
10
35
15
70
15```

# AI分析结果



## **算法分类**
组合数学

---

## **题解思路与算法分析**
### **核心思路**
题目要求计算在N行M列的网格中，选择每列一个黑格子，使得行号序列满足特定单调性的方案数。分两种情况：
- **opt=1**（严格下降）：转化为从N行中选M个不同行，方案数为组合数C(N, M)。
- **opt=0**（非递增）：转化为允许重复的组合问题，方案数为可重复组合数C(N+M-1, M)。

### **解决难点**
1. **大数处理**：当N为1e18时，直接计算阶乘不可行。通过逐项乘法和逆元预处理，将复杂度优化为O(M)。
2. **模运算优化**：利用费马小定理预处理逆元，快速计算组合数的模结果。

---

## **题解评分**
### **4.5星题解：Wolfycz**
- **思路清晰**：直接推导组合数公式，无需复杂转换。
- **代码高效**：预处理逆元，O(M)时间复杂度处理每组数据。
- **可读性强**：结构简洁，逻辑明确。

### **4星题解：daniEl_lElE**
- **基础推导**：明确分情况讨论，正确应用组合数公式。
- **代码优化**：利用快速幂计算逆元，适用于较大M值。

### **4星题解：Tzs_yousa**
- **Lucas定理应用**：虽对本题不必要，但展示了扩展思路。
- **代码规范**：模块化设计，适合教学参考。

---

## **最优思路提炼**
### **关键公式**
- **严格下降（opt=1）**：C(n, m) = n*(n-1)*...*(n-m+1) / m!
- **非递增（opt=0）**：C(n+m-1, m) = (n+m-1)*(n+m-2)*...*n / m!

### **实现技巧**
1. **逆元预处理**：预先计算1~M的逆元，避免重复计算。
2. **逐项累乘**：循环M次，逐项相乘并取模，处理大数N。

---

## **相似题目推荐**
1. **P4369**（组合数性质应用）
2. **P3807**（Lucas定理模板题）
3. **P3197**（可重复组合变式）

---

## **代码实现**
```cpp
#include<cstdio>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
const int maxn = 1e6 + 10;
int inv[maxn];

// 预处理逆元
void pre_inv() {
    inv[1] = 1;
    for(int i = 2; i < maxn; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
}

// 计算组合数C(n, m) mod 1e9+7
int comb(int n, int m) {
    if(m == 0) return 1;
    int res = 1;
    for(int i = 1; i <= m; i++) {
        res = res * ((n - i + 1) % mod) % mod;
        res = res * inv[i] % mod;
    }
    return res;
}

signed main() {
    pre_inv();
    int T, n, m, opt;
    scanf("%lld", &T);
    while(T--) {
        scanf("%lld%lld%lld", &n, &m, &opt);
        if(opt) printf("%lld\n", comb(n, m));
        else printf("%lld\n", comb(n + m - 1, m));
    }
    return 0;
}
```

---

## **可视化设计**
### **动画演示**
1. **像素风格网格**：用Canvas绘制N行M列网格，黑格子以红色方块标记。
2. **动态填充**：从左到右逐列选择行号，满足单调性时播放“成功音效”。
3. **公式推导面板**：右侧显示当前组合数公式，实时更新分子和分母的值。

### **交互设计**
- **步进控制**：按空格暂停/继续，方向键调整速度。
- **自动模式**：AI自动选择最优路径，高亮当前计算步骤。
- **音效反馈**：8-bit音效提示正确/错误选择，增强沉浸感。

---

## **总结**
本题核心在于组合数学模型的快速识别与高效计算，通过预处理和逐项模运算，将大数问题转化为线性复杂度，适合作为组合数应用的经典例题。

---
处理用时：85.62秒
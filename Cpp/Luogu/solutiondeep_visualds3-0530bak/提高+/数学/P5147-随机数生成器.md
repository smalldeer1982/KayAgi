# 题目信息

# 随机数生成器

## 题目描述

HKE最近编写了一个函数 $\text{rand}(l,r)$，其中 $l,r$ 为正整数且 $l \le r$。这个函数会等概率返回区间 $[l,r]$ 中任意一个正整数。然后，他又编写了一个函数：

```cpp
int work(int x){
    if(x==1) return 0;
    else return work(rand(1,x))+1;
}
```
这段代码用pascal写起来就是：
```pascal
function work(x:integer):integer;
begin
    if x=1 then exit(0);
    else exit(work(rand(1,x))+1);
end;
```
现在给定一个正整数 $n$，请问 $\text{work}(n)$ 的返回值的期望值是多少？

期望的定义：假设 $\text{work}(n)$ 返回的所有可能的值为 $x_1,x_2,\dots ,x_k$，它们出现的概率分别为 $p_1,p_2,\dots,p_k$，则期望为：

$$\mathbb{E}=\sum_{i=1}^{k}x_i p_i$$


## 说明/提示

【样例 $1$ 解释】  
$\text{work}(2)$ 有 $1/2$ 的概率返回 $1$，有 $1/4$ 的概率返回 $2$，有 $1/8$ 的概率返回 $3$ ……  
则期望为 $1/2+2/4+3/8+ \dots =2$

【数据范围】  
对于 $30\%$ 的数据，$n \le 9$；  
对于 $50\%$ 的数据，$n \le 1000$；  
对于 $70\%$ 的数据，$n \le 1000000$；  
对于 $100\%$ 的数据，$1\le n < 2^{31}$。


## 样例 #1

### 输入

```
2```

### 输出

```
2.00000```

## 样例 #2

### 输入

```
3```

### 输出

```
2.50000```

## 样例 #3

### 输入

```
100000```

### 输出

```
13.09014```

# AI分析结果



**1. 算法分类**  
数论

---

**2. 题解思路与核心难点**  
- **核心公式推导**：  
  递推式推导：设期望为 $F(n)$，每次递归调用 $\text{rand}(1,n)$ 返回 $i$ 的概率为 $\frac{1}{n}$，因此递推式为：  
  $$F(n) = 1 + \frac{1}{n}\sum_{i=1}^n F(i)$$  
  通过移项和差分法，最终得到 $F(n) = 1 + \sum_{i=1}^{n-1} \frac{1}{i}$，即调和级数前 $n-1$ 项和加 1。  
- **调和级数近似**：当 $n$ 极大时，$\sum_{i=1}^{n-1} \frac{1}{i} \approx \ln(n) + \gamma$（$\gamma$ 为欧拉常数，约 0.5772156649）。  
- **解决难点**：  
  - 如何从递归式推导出调和级数表达式（通过差分法消去求和项）。  
  - 如何高效计算大 $n$ 的调和级数（分段处理：小 $n$ 暴力求和，大 $n$ 近似公式）。  

---

**3. 题解评分（≥4星）**  
- **NaCly_Fish（★★★★★）**：思路清晰，直接给出递推式推导和调和级数的应用，代码简洁。  
- **Sooke（★★★★☆）**：详细推导差分过程，数学证明严谨，代码逻辑清晰。  
- **ricky0916（★★★★☆）**：通过数学归纳法证明公式，代码简洁，但近似部分解释较少。  

---

**4. 最优思路提炼**  
- **关键公式**：$F(n) = 1 + \sum_{i=1}^{n-1} \frac{1}{i}$。  
- **调和级数近似**：对 $n > 10^6$ 直接使用 $\ln(n) + \gamma$。  
- **代码优化**：分段处理，小 $n$ 暴力求和，大 $n$ 数学公式。  

---

**5. 同类型题套路**  
- 递推式转化为差分方程或调和级数。  
- 调和级数在大数据下的近似处理（如 $\sum_{i=1}^n \frac{1}{i} \approx \ln(n) + \gamma$）。  

---

**6. 推荐相似题目**  
- P1037 产生数（递推与概率）  
- P1365 WJMZBMR打osu!（期望递推）  
- P4317 花神的数论题（数论与调和级数）  

---

**7. 个人心得摘录**  
> “分块打表算是奇技淫巧之一吧。文体两开花……” —— star_city  
> “调和级数的差分推导爽得一比对不对！” —— Sooke  
> “考场上要是出分块打表题，那就制裁出题人好了。” —— qwaszx  

---

**8. 可视化与算法演示**  
**动画设计**：  
1. **递推推导**：  
   - 初始状态展示 $F(1)=0$，逐步推导 $F(2)=2$、$F(3)=2.5$。  
   - 动态显示差分过程：$F(n) - F(n-1) = \frac{1}{n-1}$。  
   - 颜色标记差分项，同步显示调和级数累加过程。  
2. **调和级数近似**：  
   - 当 $n > 10^6$，展示 $\sum_{i=1}^{n-1} \frac{1}{i}$ 的暴力求和与 $\ln(n) + \gamma$ 的对比。  
   - 用不同颜色区分精确计算和近似部分。  
3. **复古像素风格**：  
   - 在 Canvas 中绘制调和级数累加的 8 位像素动画，每累加一项播放“点击”音效。  
   - 近似公式触发时，显示上升的像素烟花特效和成功音效。  

---

**9. 代码实现（核心逻辑）**  
```cpp
#include <cstdio>
#include <cmath>
const double gamma = 0.577215664901532;

int main() {
    int n;
    scanf("%d", &n);
    if (n == 1) {
        printf("0.00000");
        return 0;
    }
    double ans = 0;
    if (n <= 1e6) {
        for (int i = 1; i < n; ++i) ans += 1.0 / i;
    } else {
        ans = log(n) + gamma;
    }
    printf("%.5lf", ans + 1);
}
```

---

**10. 复古游戏化效果（伪代码）**  
```javascript
// 8-bit 音效
const audio = new AudioContext();
function playBeep(freq) {
    const oscillator = audio.createOscillator();
    oscillator.frequency.value = freq;
    oscillator.connect(audio.destination);
    oscillator.start();
    setTimeout(() => oscillator.stop(), 100);
}

// Canvas 绘制调和级数累加
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let sum = 0;
for (let i = 1; i < n; i++) {
    sum += 1 / i;
    ctx.fillStyle = "#00FF00"; // 绿色像素块
    ctx.fillRect(i % 100 * 8, Math.floor(i / 100) * 8, 6, 6);
    playBeep(440 + i % 100); // 音调逐渐升高
    if (i % 1000000 === 0) { // 每百万项触发特效
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(50, 50, 50, 50); // 红色烟花
    }
}
```

---
处理用时：74.60秒
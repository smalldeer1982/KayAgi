# 题目信息

# 派遣

## 题目背景

Steve在洞穴里发现了一张地图，上面标识出了黑暗势力的据点，他决定派遣一些士兵前去

## 题目描述

然而，这些士兵不一定具有与黑暗势力作战的能力，因而最终被派遣的士兵是未知的

为了尽量了解派遣的士兵的情况，Steve需要你帮忙计算一些值

Steve一共有$t$支军队，每支军队的人数都不同

每支军队可以按一定标准排成$n \times k$的方阵，每个士兵的位置可以用坐标$(x,y)$表示，其中$0\le x < n,0 \le y <k$，这个士兵的编号就是$x\cdot k+y$

位于$(0,0)$位置的士兵是队长，无论任何情况都会被派遣

对于其余的士兵，可以派遣，也可以不派遣

一支$n \times k$的军队的能力值是这样定义的：

如果所有士兵都被派遣，那么能力值是$1$

如果位于$(x,y)$位置的士兵(编号为$i$)未被派遣，那么能力值变为原来的$\frac{x}{i-x}$

例如，对于一支$2\times 2$的军队，如果$(1,1)$位置的士兵(编号为$3$)未被派遣，其他士兵都被派遣，那么能力值为$\frac{1}{3-1}=\frac{1}{2}$

如果$(1,1)$位置的士兵(编号为$3$)和$(0,1)$位置的士兵(编号为$1$)都未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} = 0$

如果$(1,1)$位置的士兵(编号为$3$)和$(1,0)$位置的士兵(编号为$2$)都未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{1}{2-1} = \frac{1}{2}$

现在，Steve需要你为每一支军队，计算出所有可能派遣方案的能力值之和

为了避免出现分数，输出结果是模$1145141$意义下的值

如果这个值不存在，那么输出$-1$

也就是，如果你的答案为既约分数$\frac{p}{q}$，你需要找到一个最小的非负整数$a$，满足$p\equiv q\cdot a(mod 1145141)$，并输出这个值，如果不存在这样的整数，就输出$-1$

提示：$1145141$是质数

## 说明/提示

第四组数据实际值为$\frac{7}{3}$

第五组数据实际值为$\frac{55}{9}$

第一组数据解释：

如果所有士兵都被派遣，那么能力值为$1$

如果$(1,1)$位置的士兵(编号为$3$)未被派遣，那么能力值为$\frac{1}{3-1}=0.5$

如果$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{0}{1-0} = 0$

如果$(1,1)$位置的士兵(编号为$3$)和$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} = 0$

如果$(1,0)$位置的士兵(编号为$2$)未被派遣，那么能力值为$\frac{1}{2-1} = 1$

如果$(1,0)$位置的士兵(编号为$2$)和$(1,1)$位置的士兵(编号为$3$)未被派遣，那么能力值为$\frac{1}{2-1} \times \frac{1}{3-1}=0.5$

如果$(1,0)$位置的士兵(编号为$2$)和$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{1}{2-1} \times \frac{0}{1-0}=0$

如果只有队长被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} \times \frac{1}{2-1}=0$

所以，答案为$1+0.5+0+0+1+0.5+0+0=3$

数据范围：

对于所有数据，$n\ge 1,k\ge 2$

Subtask1是比赛时的测试数据：

测试点| 分值| t | $n\le$| $k\le$
:-: | :-: | :-: | :-: | :-:
1| 10| 5| 5| 5| 
2| 11| 100| 100| 100|
3| 12| 100000| 5| 100000|
4| 13| 100000| 100000| 5|
5| 16| 5| 100000| 100000|
6| 18| 5| $10^9$| $10^9$|
7| 20| 100000| $10^9$|$10^9$|

Subtask2包括两个不计分的Hack数据，均满足$t=1$

#8满足#7的性质

#9满足#5的性质

## 样例 #1

### 输入

```
5
2 2
3 3
1 4
2 4
3 4
```

### 输出

```
3
7
1
381716
127244
```

# AI分析结果



**唯一算法分类**：数论

---

### **题解思路与算法要点**
1. **数学推导**  
   - **核心公式**：能力值总和为所有可能派遣方案的乘积之和，转化为 $\prod_{i=1}^{nk-1} \left(1 + \frac{x_i}{i-x_i}\right)$，其中 $x_i$ 是士兵所在行。  
   - **化简推导**：分子为 $(nk-1)!$，分母为 $(nk-n)! \cdot (k-1)^{n-1} \cdot (n-1)!$，最终公式为：  
     $$\frac{(nk-1)!}{(nk-n)! \cdot (k-1)^{n-1} \cdot (n-1)!} \mod 1145141$$  
   - **难点**：处理大数阶乘的模运算和逆元计算，判断分母是否存在模数因子。

2. **阶乘模计算**  
   - 利用 **威尔逊定理** 将大数阶乘拆分为递归形式：  
     $$v! \equiv (-1)^{\lfloor v/p \rfloor} \cdot (v \mod p)! \cdot (\lfloor v/p \rfloor)! \mod p$$  
   - 预处理模数范围内的阶乘数组，递归计算大数阶乘模。

3. **因子数判断**  
   - 统计分子和分母中模数 $p=1145141$ 的因子个数：  
     - 若分母因子数 > 分子，输出 $-1$；  
     - 若分母因子数 = 分子，计算逆元；  
     - 若分母因子数 < 分子，输出 $0$。

---

### **题解评分 (≥4星)**
1. **Alex_Wei (5星)**  
   - **亮点**：公式推导清晰，利用阶乘拆分与威尔逊定理优化计算，代码简洁高效。  
   - **代码片段**：递归计算大数阶乘模，快速幂优化逆元。

2. **Hope2075 (4星)**  
   - **亮点**：分步推导分子分母，通过表格分析分母结构，结合阶乘因子数判断结果存在性。  
   - **代码片段**：预处理阶乘，分块计算分子分母模值。

3. **Thinking (4星)**  
   - **亮点**：组合数形式简化公式，递归计算阶乘模，代码结构清晰。  
   - **代码片段**：使用 `data` 结构维护阶乘的系数和指数。

---

### **最优思路与技巧**
1. **公式推导**：将独立选择的贡献转化为乘积形式，化简为阶乘分式。  
2. **递归阶乘模**：利用威尔逊定理和预处理阶乘数组，快速计算大数阶乘模。  
3. **因子数统计**：通过比较分子分母的模数因子数，判断逆元存在性。

---

### **同类型题与算法套路**
- **通用数论模型**：  
  1. 阶乘模与威尔逊定理结合处理大数问题。  
  2. 分式模运算通过逆元转化为乘法。  
  3. 组合数公式化简为阶乘分式。

---

### **推荐题目**
1. **P3807 (卢卡斯定理模板)**  
2. **P1495 (组合数取模)**  
3. **P2480 (扩展卢卡斯定理)**

---

### **可视化与算法演示**
**动画设计**：  
1. **像素风格界面**：  
   - 使用 Canvas 绘制阶乘分式的分子分母，以网格形式展示阶乘项。  
   - 颜色标记当前计算的阶乘块（如红色为递归拆分的块）。  
2. **音效与步进**：  
   - 每完成一步阶乘拆分播放“滴”声，错误时播放“哔”声。  
   - 步进按钮控制递归层级，显示当前计算的 $(nk-1)!$ 和 $(nk-n)!$。  
3. **自动推导模式**：  
   - AI 自动展开公式推导，高亮每一步的分子分母变化。  

**关键步骤**：  
1. 初始展示分式 $\frac{(nk-1)!}{(nk-n)! \cdot (k-1)^{n-1} \cdot (n-1)!}$。  
2. 逐步拆分阶乘为模数块，标记每个块的递归计算过程。  
3. 对比分子分母因子数，显示最终结果的存在性判断。

---

**代码片段**（递归阶乘模计算）：
```cpp
ll cal(ll v) {
    return v < mod ? fc[v] : fc[v % mod] * ((v / mod & 1) ? -1 : 1) % mod * cal(v / mod) % mod;
}
```

---
处理用时：67.71秒
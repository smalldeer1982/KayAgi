# 题目信息

# 【模板】二元一次不定方程 (exgcd)

## 题目描述

给定不定方程

$$ax+by=c$$

若该方程无整数解，输出 $-1$。  
若该方程有整数解，且有正整数解，则输出其**正整数**解的数量，所有**正整数**解中 $x$ 的最小值，所有**正整数**解中 $y$ 的最小值，所有**正整数**解中 $x$ 的最大值，以及所有**正整数**解中 $y$ 的最大值。  
若方程有整数解，但没有正整数解，你需要输出所有**整数解**中 $x$ 的最小正整数值， $y$ 的最小正整数值。

正整数解即为 $x, y$ 均为正整数的解，$\boldsymbol{0}$ **不是正整数**。  
整数解即为 $x,y$ 均为整数的解。  
$x$ 的最小正整数值即所有 $x$ 为正整数的整数解中 $x$ 的最小值，$y$ 同理。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1 \le T \le 2 \times {10}^5$，$1 \le a, b, c \le {10}^9$。

## 样例 #1

### 输入

```
7
2 11 100
3 18 6
192 608 17
19 2 60817
11 45 14
19 19 810
98 76 5432```

### 输出

```
4 6 2 39 8
2 1
-1
1600 1 18 3199 30399
34 3
-1
2 12 7 50 56```

# AI分析结果



# 分析与题解

## 算法分类
**数论**

---

## 核心思路与难点解析
### 题解思路
1. **无解判定**：根据裴蜀定理，当且仅当 `gcd(a,b) ∤ c` 时无解。
2. **特解构造**：通过扩展欧几里得算法（exgcd）求出 `ax + by = gcd(a,b)` 的特解，缩放得到原方程特解。
3. **通解形式**：解的结构为 `x = x1 + k*(b/gcd)`，`y = y1 - k*(a/gcd)`，其中 `k` 为整数。
4. **正整数解判定**：通过求解 `k` 的范围确定是否存在满足 `x>0` 且 `y>0` 的解。
5. **最值计算**：利用通解参数 `k` 的上下界推导 `x` 和 `y` 的最小正整数值及解的个数。

### 关键公式推导
- **通解调整**：通过不等式联立推导 `k` 的范围：
  ```math
  \lceil \frac{-x_1 + 1}{b/\text{gcd}} \rceil \leq k \leq \lfloor \frac{y_1 - 1}{a/\text{gcd}} \rfloor
  ```
- **最值公式**：通过模运算快速确定最小正解：
  ```math
  x_{\text{min}} = (x_1 \% \frac{b}{\text{gcd}} + \frac{b}{\text{gcd}}) \% \frac{b}{\text{gcd}}
  ```

### 解决难点
- **边界处理**：当初始特解为负数时，通过调整 `k` 的值使其变为正数。
- **高效计算**：避免暴力枚举，直接通过数学推导确定解的上下界。

---

## 题解评分（≥4星）
1. **dengyaotriangle（5星）**  
   - **亮点**：完整推导通解形式，明确不等式边界条件，适合深入理解数学原理。
2. **yangrunze（4星）**  
   - **亮点**：分步讲解exgcd应用，代码注释清晰，适合新手逐步实现。
3. **linponess（4星）**  
   - **亮点**：优化暴力解法，直接模运算求最值，适合大数据高效处理。

---

## 最优技巧提炼
1. **特解缩放**：将exgcd解缩放至原方程，避免重复计算。
2. **模运算优化**：直接通过 `x % mod + mod` 处理负数取模，快速确定最小正解。
3. **参数化通解**：将 `k` 的步长固定为 `b/gcd` 和 `a/gcd`，简化范围计算。

---

## 同类题目推荐
1. **P1082 同余方程**  
   - 求解线性同余方程 `ax ≡ 1 (mod b)`。
2. **P1516 青蛙的约会**  
   - 应用exgcd解决线性同余问题，计算相遇时间。
3. **P2421 荒岛野人**  
   - 通过exgcd验证周期性冲突，寻找最小安全模数。

---

## 核心代码实现
```cpp
void exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) { x = 1, y = 0; return; }
    exgcd(b, a % b, y, x);
    y -= a / b * x;
}

ll solve() {
    ll d = exgcd(a, b, x, y);
    if (c % d) return -1; // 无解
    x *= c/d; y *= c/d;  // 缩放至原方程特解
    ll dx = b/d, dy = a/d;

    // 调整x至最小正解
    ll k = ceil((1.0 - x)/dx);
    x += k * dx; y -= k * dy;

    if (y <= 0) { // 无正整数解
        ll ymin = (y % dy + dy) % dy;
        if (ymin == 0) ymin = dy;
        return x; // 输出x_min和ymin
    }

    // 计算解的个数和最值
    ll xmin = x, ymax = y;
    ll cnt = (y - 1)/dy + 1; // 正整数解个数
    ll ymin = y - (cnt-1)*dy;
    ll xmax = x + (cnt-1)*dx;
    return cnt; // 输出各最值
}
```

---

## 可视化设计
### 动画方案
1. **步骤分解**：
   - **Step 1**：展示exgcd递归过程，高亮当前计算的系数对 `(a,b)`。
   - **Step 2**：动态绘制特解缩放过程，标注 `x1 = x0*c/gcd`。
   - **Step 3**：滑动条调整 `k`，实时显示 `x` 和 `y` 的变化，红色标记越界区域。
   - **Step 4**：绘制数轴展示 `k` 的合法范围，绿色区间为有效解。

### 复古像素风格
- **Canvas绘制**：8-bit字体显示公式，解的变化用像素方块移动表示。
- **音效**：  
  - 正确步骤：8-bit“升级”音效。  
  - 越界/无解：短促“错误”音效。
- **自动演示**：AI模拟逐步推导，按空格暂停/继续。

---

## 个人心得
- **边界陷阱**：`x % b` 可能为负，需二次取模确保正解。
- **优化启示**：避免循环调整，数学推导直接确定 `k` 的上下界。

---
处理用时：76.14秒
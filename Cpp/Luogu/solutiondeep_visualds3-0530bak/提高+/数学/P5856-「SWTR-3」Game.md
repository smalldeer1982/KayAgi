# 题目信息

# 「SWTR-3」Game

## 题目背景

小 E 在玩一个数字游戏。

## 题目描述

小 E 有 $n$ 个正整数 $a_1,a_2,\dots,a_n$。他可以进行以下操作任意次：

选择一个数 $q$，和一个集合 $S=\{d_1,d_2,\dots,d_m\}$，使得 $a_{d_1},a_{d_2},\dots,a_{d_m}$ 能被 $q$ 整除，并将 $a_{d_1},a_{d_2},\dots,a_{d_m}$ 除以 $q$。

- $q$ 要满足可以写成 $p^z$ 的形式，其中 $p$ 为质数，$z$ 为正整数。

求最少需要进行多少次操作才能将这些数变为相等的数。

## 说明/提示

#### 「样例 1 说明」

一开始的序列为 12 30 48 36 18。  
选择 $S=\{4,5\},p=3$，操作后变为 12 30 48 12 6。  
选择 $S=\{1,3,4\},p=2$，操作后变为 6 30 24 6 6。  
选择 $S=\{2\},p=5$，操作后变为 6 6 24 6 6。  
选择 $S=\{3\},p=2^2=4$，操作后变为 6 6 6 6 6。  
共 4 次操作，方法不唯一。

#### 「数据范围与约定」

**本题使用捆绑测试。**

Subtask 编号 | $n\leq$ | $a_i\leq$ | 特殊性质 | 得分
:-: | :-: | :-: | :-: | :-:
$1$ | $8$ | $50$ | $a_i$ 中有一个数为 $1$ | $13$
$2$ | $10$ | $100$ | 无 | $17$
$3$ | $10^3$ | $10^4$ | 无 | $29$
$4$ | $10^5$ | $10^6$ | 无 | $41$

对于 $100\%$ 的数据，有 $1\leq n\leq 10^5$，$1\leq a_i\leq 10^6$。

对于所有测试点，时间限制 1s，空间限制 128MB。

#### 「来源」

[Sweet Round 03 B](https://www.luogu.com.cn/contest/24755)。  
idea & solution：ET2006 & Alex_Wei。

## 样例 #1

### 输入

```
5
12 30 48 36 18
```

### 输出

```
4```

## 样例 #2

### 输入

```
10
72 81 27 90 45 45 27 99 45 18
```

### 输出

```
6```

## 样例 #3

### 输入

```
4
1 2 4 8```

### 输出

```
2```

# AI分析结果



---

**唯一算法分类**：数论

---

### **题解思路与数学方法解析**

#### **核心思路**
1. **质因数分解**：每个数分解质因数，统计各质因子的指数。
2. **独立处理质因子**：对每个质因子独立计算最少操作次数，总和即为答案。
3. **状态压缩与预处理**：将每个质因子的指数差异转化为二进制状态，预处理最小操作次数。
4. **GCD 约束**：最终每个质因子的指数需等于所有数的 GCD 中对应指数，需调整状态。

#### **数学推导**
- **质因子指数对齐**：设质因子 \( p \) 在最终数中的指数为 \( k \)，需将所有数的 \( p \)-指数调整为 \( k \)。多余部分需通过操作消减。
- **状态表示**：对每个质因子，统计各数的指数与 \( k \) 的差值，用二进制状态 \( s \) 表示（例如，差值为 \( 3 \) 则第 \( 3 \) 位为 \( 1 \)）。
- **最小操作次数**：通过预处理 \( f[s] \) 表示状态 \( s \) 的最小操作次数，利用动态规划或 DFS 生成所有可能的操作集合。

#### **解决难点**
- **状态的高效预处理**：通过动态规划或 DFS 生成所有可能的操作组合，并利用子集性质优化状态转移。
- **处理保留指数**：允许保留部分指数（如 \( k \)），需将状态右移对应位数并取最小值。

---

### **题解评分 (≥4星)**
1. **Alex_Wei (5星)**  
   - 官方题解，代码简洁高效，预处理 DFS 逻辑清晰。
   - 利用动态规划优化状态转移，处理右移状态巧妙。
2. **nofind (4星)**  
   - 详细解释状态处理与保留指数逻辑，代码思路明确。
   - 预处理 DFS 结合子集更新，优化状态计算。
3. **Infiltrator (4星)**  
   - 动态规划预处理状态，思路正确。
   - 代码实现较复杂，但核心数学逻辑清晰。

---

### **最优思路提炼**
1. **质因数独立处理**：每个质因子的操作独立，总和为总操作次数。
2. **状态压缩与预处理**：二进制状态表示指数差异，DFS 或动态规划生成最小操作次数。
3. **保留指数优化**：通过右移状态处理保留到 GCD 的指数，减少无效操作。

#### **代码实现片段**
```cpp
// DFS 预处理状态的最小操作次数
void dfs(int u, int now, int state) {
    f[state] = min(f[state], u - 1);
    if (u > 5) return; // 剪枝优化
    for (int i = now; i <= 20; i++)
        dfs(u + 1, i, (state | (state << i)) & ((1 << 20) - 1));
}

// 更新状态的最小值
for (int s = (1 << 20) - 1; s; s--)
    for (int j = 1; j <= 20; j++)
        if (!((s >> (j - 1)) & 1))
            f[s] = min(f[s], f[s | (1 << (j - 1))]);
```

---

### **同类型题目与套路**
- **常见套路**：质因数分解后独立处理指数，利用状态压缩或动态规划优化操作次数。
- **类似题目**：
  1. **洛谷 P1069**：细胞分裂（质因数分解与指数对齐）
  2. **洛谷 P2043**：质因数分解（统计质因子指数）
  3. **洛谷 P3935**：Calculating（数论分块与因数统计）

---

### **可视化与算法演示**
- **像素化状态显示**：用二进制网格展示质因子的指数状态（如红色方块表示当前位为 \( 1 \)）。
- **操作步骤动画**：选择 \( z \) 后，高亮覆盖的位数并更新状态，统计操作次数。
- **音效与交互**：每步操作触发音效，自动演示模式展示 DFS 状态生成过程。

---

**示例动画设计**：
1. **质因数分解界面**：显示每个数的质因子分解结果。
2. **状态预处理动画**：DFS 生成状态覆盖路径，逐步显示状态转移。
3. **操作模拟**：选择 \( z \) 后，高亮被覆盖的位数，更新剩余状态。

---

**推荐工具**：HTML Canvas + Web Audio API，实现 8 位像素风格与音效交互。

---
处理用时：153.89秒
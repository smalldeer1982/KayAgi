# 题目信息

# 纯粹容器

## 题目背景

白王正在挑选容器。

## 题目描述

白王制造了 $n$ 个容器，并将它们排成了一队，从左到右依次编号为 $1 \sim n$。第 $i$ 个容器的**强度**为 $a_i$，保证 $a_i$ 互不相同。为了挑选出最纯粹的容器，白王会进行 $n-1$ 轮操作，每轮操作中，他会等概率随机挑选两个 **位置相邻** 且 **未被击倒** 的容器，令它们进行决斗，在一次决斗中，强度较小的容器将会被击倒并移出队列。

显然最后留下的是强度最大的容器，但是，可怜的容器们很想知道自己能够活多久，于是，它们请你对每个容器求出它存活轮数的期望。答案对 $998244353$ 取模。

一个容器的存活轮数为最大的非负整数 $x < n$ 满足它在第 $x$ 轮未被击倒。

两个容器 $i$ 和 $j$ 位置相邻当且仅当不存在 $k$ 满足 $i<k<j$ 且 $k$ 号容器未被击倒。

## 说明/提示

#### 样例解释

在第一组样例中，第一个容器无论如何不可能被击倒，第二个容器在第一轮一定会被击倒，第三个容器第一轮一定不被击倒，第二轮一定被击倒。

第二组样例的真实答案为 $\frac{1}{2}$，$\frac{1}{2}$，$2$。

---

#### 数据范围

对于所有测试点，保证 $1 \leq n \leq 50$，$1 \leq a_i \leq n$，$a_i$ 两两不同。

$\text{Subtask 1 (2 pts)}$ $n \leq 2$。

$\text{Subtask 2 (23 pts)}$ $n \leq 6$。

$\text{Subtask 3 (31 pts)}$ $n \leq 18$。

$\text{Subtask 4 (19 pts)}​$ $a_i = i$。

$\text{Subtask 5 (25 pts)}$ 无特殊限制。

---

#### 提示

如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。

## 样例 #1

### 输入

```
3
3 1 2```

### 输出

```
2 0 1```

## 样例 #2

### 输入

```
3
1 2 3```

### 输出

```
499122177 499122177 2```

## 样例 #3

### 输入

```
5
1 4 2 3 5```

### 输出

```
499122178 249561091 665496236 582309207 4```

# AI分析结果



## 算法分类
组合数学

---

## 综合分析与结论

### 核心思路与算法要点
1. **数学建模**：将存活轮数期望转化为存活概率求和 $\mathbb{E}[t_i] = \sum P(t_i \ge x)$
2. **关键观察**：容器被淘汰仅与左右第一个更大元素有关，通过单调栈 $O(n)$ 确定左右边界
3. **组合数容斥**：用 $\binom{n}{k}$ 计算操作方案数，通过容斥原理排除不合法情况
4. **公式优化**：将组合数分式转化为 $\frac{n}{i+1}$ 等简洁形式，实现 $O(n)$ 预处理后单次 $O(1)$ 计算

### 可视化设计思路
1. **分步演示**：  
   - 第1步：用红色高亮当前容器，绿色标记左右第一个更大元素  
   - 第2步：用蓝色标注左右距离 $a,b$，动态显示 $\binom{n-1}{x}$ 计算过程  
   - 第3步：以粒子效果展示容斥项 $\binom{n-1-a}{x-a}$ 的消去过程  
2. **像素风格**：  
   - 8-bit 音效：计算组合数时播放芯片音效，完成容斥时播放胜利音效  
   - 容器队列用像素方块表示，决斗过程用爆炸特效表现淘汰  
3. **自动推导模式**：逐步显示公式 $\mathbb{E}[t_i] = \sum (1-P_A-P_B+P_{AB})$ 的推导链条

---

## 优质题解推荐 (4.5★+)

### 1. dengyaotriangle 的生成函数法 (5★)
- **亮点**：  
  - 使用生成函数 $(1+t)^a - t^a$ 推导容斥项  
  - 化简得到闭式解 $\frac{n}{i+1}$，实现线性复杂度  
  - 代码简洁（40行）且包含关键注释
- **核心代码**：
  ```cpp
  int w = (n-1ll + mod*2 - ans[a] - ans[b] + ans[a+b]) % mod;
  ```

### 2. K_256 的容斥实现 (4.5★)
- **亮点**：  
  - 清晰分离容斥项计算模块  
  - 预处理组合数表提升效率  
  - 包含完整概率公式推导过程
- **核心片段**：
  ```cpp
  pa = C[n-1-d1][x-d1] * inv(C[n-1][x]) % mod;
  ```

### 3. LanrTabe 的阶乘预处理法 (4.5★)
- **亮点**：  
  - 预处理阶乘逆元加速组合数计算  
  - 动态规划思想维护概率差值  
  - 包含详细调试经验注释
- **关键优化**：
  ```cpp
  int Calc(int x, int l) { // 计算x场全在前l场的概率
    return (ll)Fac[l] * Inv[l-x] % P * Fac[n-1-x] % P * Inv[n-1] % P;
  }
  ```

---

## 核心数学实现

### 组合数容斥公式
$$ \mathbb{E}[t_i] = \sum_{x=1}^{n-1} \frac{\binom{n-1}{x} - \binom{n-1-a}{x-a} - \binom{n-1-b}{x-b} + \binom{n-1-a-b}{x-a-b}}{\binom{n-1}{x}} $$

### 代码实现要点
```cpp
// 预处理逆元
inv[1] = 1;
for(int i=2;i<=n;i++) inv[i] = inv[mod%i] * (mod - mod/i) % mod;

// 单调栈找左右更大元素
stack<pair<int,int>> stk;
for(int i=1;i<=n;i++){
    while(!stk.empty() && stk.top().first < a[i]){
        nxt[stk.top().second] = i;
        stk.pop();
    }
    stk.push({a[i],i});
}

// 期望计算
int a = i - l, b = r - i;
int res = (n-1ll + mod*2 - ans[a] - ans[b] + ans[a+b]) % mod;
```

---

## 相似题目推荐
1. **P3974 组合数问题** - 组合数模运算与容斥  
2. **P1365 期望收益率** - 概率期望求和模型  
3. **P2781 传教** - 单调栈与区间处理

---

## 可视化代码示例（像素风格）

```javascript
class PixelAnimator {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.blocks = []; // 容器像素块
        this.sound = new AudioContext();
    }
    
    drawContainer(i, color) {
        // 绘制16x16像素块，i为位置，color为高亮色
        this.ctx.fillStyle = color;
        this.ctx.fillRect(i*20+2, 50, 16, 16);
    }
    
    playSound(freq) {
        // 生成8-bit音效
        let oscillator = this.sound.createOscillator();
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(freq, this.sound.currentTime);
        oscillator.connect(this.sound.destination);
        oscillator.start();
        oscillator.stop(this.sound.currentTime + 0.1);
    }
}

// 使用示例
const anim = new PixelAnimator(document.getElementById('canvas'));
anim.drawContainer(3, '#FF0000'); // 红色高亮第3个容器
anim.playSound(440); // 播放A4音高
```

---

## 总结与提升
1. **关键思维**：将存活问题转化为边界约束下的组合计数  
2. **优化技巧**：预处理逆元加速模运算，单调栈快速确定影响范围  
3. **扩展应用**：类似问题可考虑「笛卡尔树」结构分析元素支配关系

通过本案例可掌握组合数学在期望计算中的典型应用，以及如何将复杂概率问题分解为可计算的组合项求和。

---
处理用时：71.14秒
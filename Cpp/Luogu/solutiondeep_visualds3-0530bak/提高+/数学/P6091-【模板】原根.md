# 题目信息

# 【模板】原根

## 题目描述

给定整数 $n$，求它的所有原根。

为了减小你的输出量，给出输出参数 $d$，设 $n$ 的所有原根有 $c$ 个，从小到大分别为 $g_1,\ldots,g_c$，你只需要依次输出 $g_d,g_{2d},\ldots,g_{\lfloor\frac{c}{d}\rfloor\times d}$。

---

如果你不了解原根的定义，可以自行查找资料或阅读下列定义：

正整数 $g$ 是正整数 $n$ 的原根，当且仅当 $1\leq g\leq n-1$，且 $g$ 模 $n$ 的阶为 $\varphi(n)$。

## 说明/提示

【样例解释】

对于第 $1,2,4,6$ 组数据，给出的 $n$ 的所有原根都出现在输出中。

对于第 $3$ 组数据，$25$ 的原根集合为 $\{2,3,8,12,13,17,22,23\}$。

对于第 $5$ 组数据，$9$ 的原根集合为 $\{2,5\}$。

【数据范围】

对于 $100\%$ 的数据，$1\leq T\leq 10$，$2\leq n\leq 10^6$，$1\leq d\leq 200$，保证输出的数的总个数不超过 $10^5$。

## 样例 #1

### 输入

```
6
2 1
4 1
25 2
36 1
9 6
18 1
```

### 输出

```
1
1 
1
3 
8
3 12 17 23 
0

2

2
5 11 
```

# AI分析结果



**算法分类**：数论

---

### **题解思路与核心难点**

#### **核心思路**
1. **原根存在性判定**：利用定理判断数n是否属于2、4、p^k或2p^k形式。
2. **最小原根搜索**：枚举候选g，验证其阶是否等于φ(n)，通过分解φ(n)的质因数快速验证。
3. **生成所有原根**：基于最小原根生成所有满足条件的指数k（k与φ(n)互质），排序后按d参数输出。

#### **关键公式与步骤**
1. **欧拉定理**：若gcd(a,n)=1，则a^φ(n) ≡ 1 (mod n)。
2. **原根判定定理**：g是原根当且仅当对于φ(n)的每个质因数p，g^(φ(n)/p) ≠ 1 (mod n)。
3. **原根生成公式**：若g是原根，所有原根为{g^k mod n | gcd(k, φ(n))=1}。

#### **解决难点**
- **质因数分解φ(n)**：快速分解φ(n)的质因数，用于验证原根。
- **高效互质判断**：通过筛法预处理标记互质情况，避免逐次计算gcd。

---

### **题解评分（≥4星）**

1. **codecode (5星)**  
   - **亮点**：详细数学证明，覆盖原根存在性、阶的性质，代码完整。  
   - **核心代码**：线性筛预处理φ，质因数分解φ(n)，暴力枚举最小原根。

2. **panyf (5星)**  
   - **亮点**：O(Tn)复杂度，利用筛法优化互质判断，效率极高。  
   - **核心代码**：预处理标记φ(n)的因子，快速生成原根数组。

3. **0xyz (4星)**  
   - **亮点**：随机化加速原根搜索，代码简洁，实践性强。  
   - **核心代码**：随机枚举候选g，快速幂验证，生成原根后排序。

---

### **最优思路提炼**

1. **预处理原根存在性**  
   - 线性筛标记所有可能的n（2,4,p^k,2p^k），O(n)完成。

2. **快速验证原根**  
   - 分解φ(n)的质因数，检查g^(φ(n)/p) ≡ 1 (mod n)是否全不成立。

3. **生成原根数组**  
   - 利用最小原根生成所有k满足gcd(k,φ(n))=1，排序后输出。

---

### **同类型题拓展**

- **通用思路**：涉及原根的题目通常需快速验证存在性、分解φ(n)、生成原根数组。
- **常见套路**：质因数分解、欧拉函数计算、快速幂模运算。

---

### **推荐题目**
1. **P4549 原根应用**  
2. **P4139 上帝与集合的正确用法（扩展欧拉定理）**  
3. **P1067 多项式乘法（原根与NTT）**

---

### **个人心得摘录**

- **调试教训**：未预处理原根存在性导致TLE，需先判断n是否符合条件。  
- **顿悟点**：原根生成只需最小原根的幂次，极大减少计算量。

---

### **可视化算法演示**

#### **动画设计**
- **步骤1：预处理阶段**  
  - **Canvas绘制**：展示线性筛过程，素数标记为绿色，原根存在标记为红色。
  - **音效**：筛出素数时播放“滴”声，标记原根时播放“叮”声。

- **步骤2：分解φ(n)**  
  - **高亮显示**：φ(n)的质因数以黄色方块动态分离，显示质因数分解公式。
  - **步进控制**：点击分解按钮，逐步展示每个质因数。

- **步骤3：验证原根**  
  - **像素动画**：候选g以像素方块移动，快速幂计算时显示指数拆分（如g^13 → g^8*g^4*g^1）。
  - **失败音效**：若g不满足条件，播放低沉音效；成功则播放胜利音调。

- **步骤4：生成原根数组**  
  - **网格展示**：生成的原根在模n环上排列，互质的k值用连线标记。
  - **自动排序**：原根数组按数值从小到大动态排序，颜色渐变表示大小。

#### **复古游戏化**  
- **8位像素风格**：使用NES调色板，计算步骤以8x8像素块表示。
- **背景音乐**：循环播放《超级玛丽》地下关BGM，营造复古氛围。
- **积分系统**：每正确找到一个原根+10分，错误-5分，连击奖励加速计算。

---

### **代码片段（核心逻辑）**

```cpp
// 预处理欧拉函数与原根存在性
void init() {
    phi[1] = 1;
    for (int i = 2; i <= N; i++) {
        if (!vis[i]) {
            prime[++cnt] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= cnt && i*prime[j] <= N; j++) {
            vis[i*prime[j]] = 1;
            if (i % prime[j] == 0) {
                phi[i*prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i*prime[j]] = phi[i] * (prime[j] - 1);
        }
    }
    rt[2] = rt[4] = 1;
    for (int i = 2; i <= cnt; i++) {
        for (ll j = prime[i]; j <= N; j *= prime[i]) rt[j] = 1;
        for (ll j = 2*prime[i]; j <= N; j *= prime[i]) rt[j] = 1;
    }
}

// 寻找最小原根
int find_min_root(int n) {
    vector<int> factors = factorize(phi[n]);
    for (int g = 1; ; g++) {
        if (qpow(g, phi[n], n) != 1) continue;
        bool valid = true;
        for (int p : factors) 
            if (qpow(g, phi[n]/p, n) == 1) { valid = false; break; }
        if (valid) return g;
    }
}

// 生成所有原根
vector<int> generate_roots(int g, int n) {
    vector<int> roots;
    int phin = phi[n], current = 1;
    for (int i = 1; i <= phin; i++) {
        current = (current * g) % n;
        if (gcd(i, phin) == 1) roots.push_back(current);
    }
    sort(roots.begin(), roots.end());
    return roots;
}
```

**8位音效JS示例**  
```javascript
// 使用ZzFX生成音效
function playSound(freq) {
    const zz = ZzFX;
    zz.play(zz.square(freq, 0.1, 0.5));
}
// 成功音效（C大调）
playSound(523.25); // C5
// 失败音效（低音G）
playSound(196.00); // G3
```

---
处理用时：93.19秒
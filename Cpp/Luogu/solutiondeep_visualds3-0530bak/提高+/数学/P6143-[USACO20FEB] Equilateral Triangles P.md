# 题目信息

# [USACO20FEB] Equilateral Triangles P

## 题目描述

Farmer John 的农场可以用一个 $N \times N$ 的方阵（$1 \leq N \leq 300$）。对于方阵内的每个格子，如果这个格子有奶牛，就用 `*` 表示，否则用 `.` 表示。

FJ 相信他的牧场的美丽程度正比于两两距离相等的奶牛三元组的数量。也就是说，她们组成一个等边三角形。不幸的是，直到最近 FJ 才发现，由于他的奶牛都处在整数坐标位置，如果使用欧几里得距离进行计算，不可能存在美丽的奶牛三元组！于是，FJ 决定改用“曼哈顿”距离。形式化地说，两点 $(x_0,y_0)$ 和 $(x_1,y_1)$ 的曼哈顿距离等于 $|x_0-x_1|+|y_0-y_1|$。

给定表示奶牛位置的方阵，计算等边三角形的数量。

## 说明/提示

### 样例解释

有三头奶牛，并且她们组成了一个等边三角形，因为每对奶牛之间的曼哈顿距离都等于二。

### 子任务

- 对于测试点 $T$（$T \in [2,11]$），满足 $N=25T$；
- 对于测试点 $T$（$T \in [12,15]$），满足 $N=300$。

## 样例 #1

### 输入

```
3
*..
.*.
*..```

### 输出

```
1```

# AI分析结果



---

## 唯一算法分类：几何

---

### 题解思路、算法要点与解决难点

#### 核心数学逻辑
曼哈顿等边三角形的判定条件可转化为**斜线方向上的对称性**。关键公式推导如下：
1. 若两点 J、K 在斜 45° 直线上，则第三点 C 必在另一条对称斜线上，且满足：
   $$ \text{曼哈顿距离}(J,C) = \text{曼哈顿距离}(K,C) = \text{曼哈顿距离}(J,K) $$
2. 通过旋转坐标系 4 次（0°, 90°, 180°, 270°）覆盖所有可能的等边三角形方向。
3. 斜线前缀和公式：
   $$ \text{sum}[x][y] = \text{sum}[x-1][y+1] + a[x][y] $$
   用于快速统计斜线段上的奶牛数量。

#### 解决难点
1. **方向覆盖**：通过旋转矩阵 4 次确保所有可能的等边三角形方向被统计。
2. **重复计算**：在旋转后需通过前缀和区间查询时的左端点去重（如 `f(R) - f(L)` 而非 `f(R) - f(L-1)`）。
3. **坐标变换**：部分题解通过曼哈顿→切比雪夫坐标变换简化斜线处理，但需处理坐标系缩放后的边界条件。

---

### 题解评分（≥4星）

#### 1. hyfhaha 的题解（★★★★☆）
- **亮点**：代码简洁，通过旋转+斜线前缀和统一处理所有方向，逻辑清晰。
- **优化**：用两倍数组避免溢出判断，时间复杂度稳定为 $O(4n^3)$。
- **核心代码**：
  ```cpp
  void solve() {
    // 计算斜线前缀和
    for(int i=1; i<=n*2; i++) for(int j=1; j<=n*2; j++)
      f[i][j] = f[i-1][j+1] + a[i][j];
    // 枚举所有可能的三元组
    ans += f[xa+k][ya+k] - f[xa][ya+k*2];
  }
  ```

#### 2. xht 的题解（★★★★☆）
- **亮点**：利用切比雪夫坐标变换，将问题转化为正方形边统计。
- **数学推导**：证明等边三角形对应新坐标系中的正方形边，时间复杂度 $O(n^3)$。
- **核心代码**：
  ```cpp
  // 水平方向统计
  ans += b[i-dis][k] - b[i-dis][j-1];
  // 垂直方向统计
  ans += b[k-1][i-dis] - b[j][i-dis];
  ```

#### 3. ELECTRODE_kaf 的题解（★★★★☆）
- **亮点**：通过 8 位像素动画直观展示斜线扫描过程。
- **可视化设计**：用不同颜色标记当前扫描的斜线，音效提示有效三元组发现。

---

### 最优思路或技巧提炼

1. **旋转坐标系法**（hyfhaha）
   - 核心：将图形旋转 4 次，每次处理 45° 斜线方向。
   - 关键步骤：
     1. 预处理每条斜线的前缀和。
     2. 枚举每个星号点作为基点 J。
     3. 枚举距离 k，计算对称点 K 和线段 OL 上的星号数。
   - 复杂度：$O(4n^3)$，实际运行效率较高。

2. **切比雪夫坐标变换**（xht）
   - 核心：将原坐标 $(x,y)$ 映射为 $(x+y, x-y)$。
   - 优势：等边三角形在新坐标系中表现为正方形边，简化斜线统计。
   - 实现：分别处理水平和垂直方向的前缀和。

---

### 同类型题或类似算法套路

1. **曼哈顿距离几何问题**：通常涉及斜线方向处理或坐标变换。
2. **斜线前缀和**：用于快速统计矩阵中 45° 方向线段的和。
3. **旋转覆盖法**：通过多次旋转处理不同方向对称性问题。

---

### 推荐相似题目

1. [P2731 骑马修栅栏](https://www.luogu.com.cn/problem/P2731)（曼哈顿路径统计）
2. [P2181 对角线](https://www.luogu.com.cn/problem/P2181)（几何组合计数）
3. [CF650A Watchmen](https://www.luogu.com.cn/problem/CF650A)（曼哈顿与欧式距离去重）

---

### 可视化与算法演示

#### 动画设计方案
1. **坐标系旋转演示**：
   - 初始状态显示原矩阵，点击旋转按钮后以 90° 步进旋转。
   - 使用红色箭头标记当前处理方向（45° 斜线）。
2. **斜线扫描过程**：
   - 高亮当前枚举的基点 J（蓝色）和对称点 K（绿色）。
   - 黄色线段表示需要统计的 OL 区域，实时显示前缀和计算结果。
3. **像素风格元素**：
   - 使用 8-bit 音效：扫描时播放 "beep"，发现有效三元组时播放 "ding"。
   - 奶牛用 ★ 表示，背景网格为灰色，当前操作用闪烁边框。

#### 关键代码片段（Canvas 实现）
```javascript
// 绘制斜线扫描
function drawDiagonal(x, y, length) {
  ctx.strokeStyle = '#FF0000';
  ctx.beginPath();
  ctx.moveTo(x*CELL_SIZE, y*CELL_SIZE);
  for(let i=0; i<length; i++) {
    ctx.lineTo((x+i)*CELL_SIZE, (y-i)*CELL_SIZE);
  }
  ctx.stroke();
  playSound('scan'); // 触发扫描音效
}
```

---

### 个人心得摘录

> "曼哈顿等边三角形的判定本质是斜线对称性，旋转坐标系可以统一处理所有方向，避免复杂的分类讨论。" —— hyfhaha  
> "将问题转换为切比雪夫坐标后，原本复杂的斜线逻辑变成了简单的水平/垂直线段统计。" —— xht

---

### 代码实现（核心片段）

#### hyfhaha 的旋转前缀和法
```cpp
void solve() {
    // 计算斜线前缀和
    for(int i=1; i<=n*2; i++) {
        for(int j=1; j<=n*2; j++) {
            f[i][j] = f[i-1][j+1] + a[i][j];
        }
    }
    // 枚举所有星号点
    for(int i=1; i<=tot; i++) {
        int xa = p[i].x, ya = p[i].y;
        for(int k=1; k<=n; k++) {
            int xb = xa - k, yb = ya + k;
            if(xb <1 || yb >n) break;
            if(a[xb][yb] == 0) continue;
            ans += f[xa+k][ya+k] - f[xa][ya+k*2];
        }
    }
}
```

#### 切比雪夫坐标法（xht）
```cpp
// 转切比雪夫坐标并统计
for(int i=1; i<=n; i++) for(int j=1; j<=n; j++) {
    if(s[j][i] == '*') a[i+j-1][i-j+n] = 1;
}
// 水平方向统计
for(int i=1; i<=2*n; i++) {
    for(int j=1; j<=2*n; j++) {
        sum[i][j] = sum[i][j-1] + a[i][j];
    }
}
// 垂直方向统计
for(int i=1; i<=2*n; i++) {
    for(int j=1; j<=2*n; j++) {
        sumv[i][j] = sumv[i-1][j] + a[i][j];
    }
}
```

---
处理用时：94.72秒
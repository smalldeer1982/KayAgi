# 题目信息

# 「JZOI-1」窗花

## 题目背景

小蔡和小僖在比赛剪窗花。

## 题目描述

小蔡和小僖的制作水平都很高，换句话讲，他们都能制作出好看度为 $1\dots n$ 的窗花，但是两个人的熟练度不一样，小蔡的熟练度可以用一个数组 $a_{1\dots n}$ 组成，换句话讲，他剪出一个好看度为 $k(1\le k\le n)$ 的窗花的概率为 $\frac{a_k}{\sum_{i=1}^na_i}$。同理，小僖的熟练度可以用数组 $b_{1\dots n}$ 组成，他剪出一个好看度为 $k(1\le k\le n)$ 的窗花的概率为 $\frac{b_k}{\sum_{i=1}^nb_i}$。

现在两个人正在比赛剪窗花，如果某个人剪出的窗花的好看度比另一个人的大，那么这个人取胜，如果比另一个人的小，那么这个人失败，如果一样，则为平局。

现在，小蔡用一个计数器记录他的情况，如果他赢了，那么计数器 $+1$，如果他输了，那么计数器 $-1$，如果平了，那么不加不减。但由于计数器不支持负数，所以如果结果 $\le0$ 那么会自动变成 $0$，如果计数器显示的数 $=m$，那么比赛结束。

作为新时代的大神，小蔡花了 $10^{-6}$ 秒就算出来了比赛结束所经过的期望局数，但他想让你帮忙检验一下……

## 说明/提示

对于 $ 30\% $ 的数据点，$ 1 \leq m \leq 100 $。

对于 $ 60\% $ 的数据点，$ 1 \leq m \leq 10^{6} $。

对于 $ 90\% $ 的数据点，$ 1 \leq m \leq 10^{18} $。

对于 $ 100\% $ 的数据点，$ 2 \leq n \leq 10^6 $，$ 1 \leq m \leq 10^{1000} $，$ 1 \leq a_i \leq 10^9 $。

## 样例 #1

### 输入

```
4 2
3 1 1 4 
3 5 2 1 ```

### 输出

```
570934265```

## 样例 #2

### 输入

```
3 1
1 1 1
1 1 1```

### 输出

```
3```

# AI分析结果



# 「JZOI-1」窗花题解分析

**算法分类**：组合数学（概率期望与递推优化）

---

## **题解思路与解决难点**

### **核心数学推导**
1. **概率计算**：  
   计算小蔡赢（P1）、平（P2）、输（P3）的概率：
   \[
   P_1 = \sum_{i=1}^n \frac{a_i}{\sum a} \cdot \frac{\sum_{j=1}^{i-1} b_j}{\sum b}, \quad P_2 = \sum_{i=1}^n \frac{a_i}{\sum a} \cdot \frac{b_i}{\sum b}, \quad P_3 = 1 - P_1 - P_2
   \]
   通过预处理前缀和可优化至 \(O(n)\)。

2. **期望递推关系**：  
   设 \(E(i)\) 为计数器从 \(i\) 到 \(m\) 的期望步数，递推式为：
   \[
   E(i) = \begin{cases}
   P_1 E(i+1) + P_2 E(i) + P_3 E(i-1) + 1 & (i \geq 1) \\
   P_1 E(1) + (1-P_1) E(0) + 1 & (i=0)
   \end{cases}
   \]
   通过引入 \(E(i) = a_i x + b_i\) 将问题转化为线性递推。

3. **矩阵快速幂优化**：  
   将递推关系转换为矩阵形式，构造转移矩阵并通过快速幂求解。例如，对于 \(a_i\) 的递推：
   \[
   \begin{bmatrix} a_{i} \\ a_{i-1} \end{bmatrix} = \begin{bmatrix} t_1 & t_2 \\ 1 & 0 \end{bmatrix} \cdot \begin{bmatrix} a_{i-1} \\ a_{i-2} \end{bmatrix}
   \]
   其中 \(t_1 = \frac{1-P_2}{P_1}, t_2 = -\frac{P_3}{P_1}\)。类似方法处理 \(b_i\)。

### **解决难点**
- **高精度处理**：将十进制 \(m\) 转换为二进制，避免直接处理大数。
- **矩阵构造**：分离 \(a_i\) 和 \(b_i\) 的递推，分别设计转移矩阵。
- **边界条件**：处理 \(E(0)\) 的特殊情况，通过方程 \(E(m) = 0\) 反推初始值。

---

## **题解评分（≥4星）**

1. **do_while_true（5星）**  
   - **亮点**：完整处理高精度 \(m\)，矩阵构造清晰，代码模块化。
   - **代码片段**：矩阵快速幂核心部分：
     ```cpp
     Matrix basea, ansa;
     basea.a[1][2] = t1; basea.a[2][1] = 1; // 转移矩阵
     for (int i=1; i<=ct; ++i) {
         if (m[i]) ansa = ansa * basea;
         basea = basea * basea; // 快速幂
     }
     ```

2. **renshale（4星）**  
   - **亮点**：尝试费马小定理优化，但未完全处理高精度。
   - **代码片段**：快速幂优化公式：
     ```cpp
     ll qpow(ll x, ll y) {
         ll res = 1;
         while (y) { /* 快速幂实现 */ }
     }
     ```

---

## **最优思路提炼**

1. **概率预处理**：前缀和优化计算 \(P_1, P_2, P_3\)。
2. **矩阵递推**：将线性递推转换为矩阵乘法，利用快速幂处理指数。
3. **二进制分解**：将高精度 \(m\) 转换为二进制，支持快速幂的逐位处理。

---

## **同类题型与套路**

- **递推优化**：如斐波那契数列的矩阵快速幂优化（洛谷 P1939）。
- **概率期望模型**：如随机游走问题（洛谷 P6835）。
- **高精度处理**：结合数论与字符串处理的大数问题。

---

## **推荐题目**

1. **P1939 【模板】矩阵加速（数列）**  
   - 矩阵快速幂的模板题，强化递推优化思维。
2. **P6835 [CSP-S 2020] 函数调用**  
   - 结合概率与递推的复杂期望问题。
3. **P4549 【模板】裴蜀定理**  
   - 数论与递推的结合应用。

---

## **可视化与算法演示**

### **动画设计（8位像素风格）**
- **步骤展示**：  
  1. **概率计算**：显示前缀和累加过程，高亮当前 \(a_i, b_i\)。
  2. **矩阵构造**：像素化矩阵元素，动态填充转移矩阵。
  3. **快速幂流程**：二进制位逐位点亮，矩阵乘法的动态展开。
- **交互功能**：  
  - **步进控制**：按键逐步执行矩阵乘法。
  - **音效触发**：每完成一次矩阵乘法播放“升级”音效。
  - **自动模式**：AI 自动推导，模拟解题过程。

### **Canvas 示例**
```javascript
// 矩阵快速幂动画伪代码
function drawMatrix(matrix, step) {
    ctx.fillStyle = "#8B00FF"; // 复古紫色
    matrix.forEach((row, i) => {
        row.forEach((val, j) => {
            ctx.fillText(val, j*30, i*30 + step*50);
        });
    });
}
// 触发音效
function playSound(effect) {
    const sfx = new Audio(`sfx/${effect}.wav`);
    sfx.play();
}
```

---

## **个人心得**

- **调试经验**：矩阵构造需严格验证维度与元素，避免递推错误。
- **思维突破**：将高精度转换为二进制是处理超大指数的关键技巧。

---
处理用时：91.04秒
# 题目信息

# 「WHOI-4」加减法构造

## 题目描述

小 W 给了你一个长度为 $n$ 的**整数**数组 $x$。你需要构造一个长度也为 $n$ 的**整数**数组 $y$，并满足：

1. $\forall 1\le i,j,i+j\le n,y_{i+j}=y_i+y_j+k$，$k$ 是一个你需要钦定的整数。
3. $d(x,y)=\sum\limits_{i=1}^n|x_i-y_i|$ 最小。
3. $-V\le y_i\le V$，$V$ 是输入中给定的数。 

## 说明/提示

**数据范围**

- Subtask 1（$20$ pts）：$n\le10$，$ V\le10$，$ |x_i|\le10$；
- Subtask 2（$20$ pts）：$n\le100$，$ |x_i|\le100$，$V\le1000$；
- Subtask 3（$20$ pts）：$n\le10^6$，$ |x_i|\le10^6$，$V=10^{12}$；
- Subtask 4（$20$ pts）：$n\le10^7$，$|x_i|\le10^7$，$V\le10^7$;
- Subtask 5（$20$ pts）：$n\le10^7$，$|x_i|\le10^7$，$V\le 10^{12}$。

对于所有数据，保证 $1\le n\le 10^7$，$|x_i|\le10^7$，$1\le V\le10^{12}$。

**关于 Special Judge 的说明**

对于每个测试点：

如果你输出的格式不正确，你将会获得 $0$ 分。

如果你输出的数中有不在 $[-V,V]$ 范围的数，你将会获得 $0$ 分。

如果你的数列 $y$ 不符合你输出的 $k$，你将会获得 $0$ 分。

如果你的数列 $y$ 不符合你输出的 $d$，你将会获得 $0$ 分。

否则你将会获得的分数为该测试点总分的百分之 $\max\{0,\min\{100,10100-\frac{10000d}{d'}\}\}$，$d'$ 是答案的 $d$ 值。

## 样例 #1

### 输入

```
5 10
2 3 8 5 4```

### 输出

```
-1 6
2 3 4 5 6```

## 样例 #2

### 输入

```
7 100
11 45 14 19 19 8 10```

### 输出

```
-17 51
16 15 14 13 12 11 10```

# AI分析结果



## 唯一算法分类
**数论**

---

## 综合分析与结论

### 核心思路与难点
1. **结构推导**  
   通过条件 $y_{i+j}=y_i+y_j+k$ 推导出 $y$ 的线性结构：$y_i = c \cdot i + d$，其中 $k=-d$，$c=a+k$。  
   **数学推导**：取 $i=1$ 递推可得 $y_i = i \cdot y_1 + (i-1)k$，转化为线性形式后验证满足原条件。

2. **约束条件简化**  
   - 当 $c \geq 0$ 时，约束简化为 $d \geq -V - c$ 且 $d \leq V - c \cdot n$。  
   - 当 $c < 0$ 时，约束简化为 $d \leq V - c$ 且 $d \geq -V - c \cdot n$。  
   **关键性质**：极值点约束（$i=1$ 或 $i=n$）覆盖所有中间情况。

3. **优化目标转换**  
   目标函数 $\sum |x_i - (c \cdot i + d)|$ 在固定 $c$ 时，最优 $d$ 为序列 $\{x_i - c \cdot i\}$ 的中位数（需约束到允许范围）。问题转化为在 $c$ 的可行区间内寻找最优解。

4. **高效搜索策略**  
   利用三分法在 $c$ 的连续区间内寻找最优解，时间复杂度为 $O(n \log C)$，适用于大规模数据。

---

## 题解评分与关键思路

### 最优思路提炼
1. **线性结构建模**  
   将 $y_i$ 表达为线性函数 $c \cdot i + d$，通过约束条件和绝对值最小化模型，将二维问题降维。

2. **中位数优化**  
   固定 $c$ 后，$d$ 的最优解为序列中位数，结合约束剪枝，快速计算可行解。

3. **三分法加速**  
   在 $c$ 的可行区间内使用三分法，高效逼近全局最优解。

---

## 可视化设计要点

### 像素风格动画
1. **颜色方案**  
   - 当前计算步：红色高亮  
   - 约束边界：蓝色边框  
   - 残差区域：灰色渐变  

2. **Canvas 绘制**  
   - 绘制 $c$ 的可行区间为横轴，$d$ 的约束范围随 $c$ 动态变化。  
   - 实时更新目标函数曲线，显示当前最优解的位置。

3. **音效与交互**  
   - 关键步骤音效：8-bit 音效提示中位数计算完成。  
   - 自动演示模式：模拟三分法逐步缩小区间，背景音乐为循环芯片音乐。

---

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;

struct Solver {
    int n;
    LL V;
    vector<LL> x;
    vector<pair<LL, int>> xs; // 预处理排序后的 (x_i - c*i, i)

    Solver(int n, LL V, vector<LL> x) : n(n), V(V), x(x) {
        xs.resize(n);
        for (int i = 0; i < n; ++i)
            xs[i] = {x[i], i + 1}; // i从1开始
    }

    // 计算给定c时的最优d及对应的总残差
    pair<LL, LL> evaluate(LL c) {
        vector<LL> tmp(n);
        for (int i = 0; i < n; ++i)
            tmp[i] = x[i] - c * (i + 1);
        nth_element(tmp.begin(), tmp.begin() + n/2, tmp.end());
        LL d_opt = tmp[n/2]; // 中位数候选

        // 约束剪枝
        LL d_min, d_max;
        if (c >= 0) {
            d_min = -V - c;
            d_max = V - c * n;
        } else {
            d_min = -V - c * n;
            d_max = V - c;
        }
        d_opt = clamp(d_opt, d_min, d_max);

        // 计算总残差
        LL sum = 0;
        for (int i = 0; i < n; ++i) {
            LL y = c * (i + 1) + d_opt;
            sum += abs(x[i] - y);
        }
        return {sum, d_opt};
    }

    void solve() {
        if (n == 1) { // 特判n=1
            LL y1 = clamp(x[0], -V, V);
            cout << -y1 << " " << abs(x[0] - y1) << "\n" << y1 << "\n";
            return;
        }

        // 确定c的可行区间
        LL c_low = -2 * V / (n - 1);
        LL c_high = 2 * V / (n - 1);
        LL best_c = 0, best_d = 0, min_sum = LLONG_MAX;

        // 三分法搜索最优c
        for (int iter = 0; iter < 100; ++iter) {
            LL m1 = c_low + (c_high - c_low) / 3;
            LL m2 = c_high - (c_high - c_low) / 3;
            auto [s1, d1] = evaluate(m1);
            auto [s2, d2] = evaluate(m2);
            if (s1 < min_sum) {
                min_sum = s1;
                best_c = m1;
                best_d = d1;
            }
            if (s2 < min_sum) {
                min_sum = s2;
                best_c = m2;
                best_d = d2;
            }
            if (s1 < s2) c_high = m2;
            else c_low = m1;
        }

        // 构造y数组
        vector<LL> y(n);
        for (int i = 0; i < n; ++i)
            y[i] = best_c * (i + 1) + best_d;

        cout << -best_d << " " << min_sum << "\n";
        for (auto yi : y) cout << yi << " ";
        cout << "\n";
    }
};

int main() {
    int n; LL V;
    cin >> n >> V;
    vector<LL> x(n);
    for (int i = 0; i < n; ++i) cin >> x[i];
    Solver(n, V, x).solve();
    return 0;
}
```

---

## 同类型题目推荐
1. **P3382 【模板】三分法**  
   练习三分法求单峰函数极值。

2. **P1024 一元三次方程求解**  
   利用数值方法求解方程的根。

3. **P2115 绝对值最小路径**  
   绝对值和的优化问题，结合贪心或动态规划。

---
处理用时：378.27秒
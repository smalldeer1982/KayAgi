# 题目信息

# [入门赛 #9] 最澄澈的空与海 (Hard Version)

## 题目背景

材料 1：

> 请小心地计算下面的算式：$138 - 108 \div 6 = ?$  
> 你大概难以置信，这个算式的计算结果竟然是 $5!$

材料 2：

> 对于一个正整数 $x$，$x! = 1 \times 2 \times \cdots \times (x - 1) \times x$。我们称 $x!$ 为 $x$ 的阶乘。  
> 特别的，$0! = 1$。

显然，「$138 - 108 \div 6 = 5$」是错误的，而「$(138 - 108) \div 6 = 5$」是正确的，所以对材料 1 中的内容，部分读者会认为「作者没有搞清加减乘除的运算优先级关系而犯错」。

然而，材料 1 最后一行的叹号并不是标点符号，而是材料 2 提到的「阶乘」。

考虑到这一点，「$138 - 108 \div 6 = 5! = 1 \times 2 \times \cdots \times 5 = 120$」显然就是正确的了。

## 题目描述

然而，此题可能与上面的题目背景关系不是很大。

我们会给你 $T$ 组数据，每组数据包括一个正整数 $n$。

对于每组数据，请你帮助求出满足以下条件的整数三元组 $(x, y, z)$ 的组数：

1. $x \geq 0$，$z \geq 1$。
2. $x - y \div z = n!$ 且 $(x - y) \div z = \dfrac{n!}{n}$。

由于答案可能过大，因此你需要输出答案对 $998244353$ 取模后的结果。

不难注意到答案有可能为 $\infty$，这时请按照「输出格式」要求进行处理。

**请注意此处应满足 $(x - y) \div z = \dfrac{n!}{n}$ 而不是 $= n$。**

请注意这里的 $\div$ 不是向下取整的整除，这显然意味着你需要保证 $y \div z$ 和 $(x - y) \div z$ 为整数。

## 说明/提示

### 样例 1 解释

样例中的具体三元组如下：

| $n$ | 所有可能的三元组 |
| :----------: | :----------: |
| $2$ | $(2, 0, 2)$ |
| $3$ | $\begin{matrix}(8, 4, 2) & (5, -5, 5) & (6, 0, 3)\end{matrix}$ |
| $4$ | $\begin{matrix}(19, -95, 19) & (21, -21, 7) & (24, 0, 4) \\ (27, 9, 3) & (20, -40, 10) & (36, 24, 2)\end{matrix}$ |

### 数据规模与约定

对于前 $20\%$ 的数据，保证 $T \leq 10$，$n \leq 10$。

对于前 $40\%$ 的数据，保证 $n \leq 10 ^ 3$。

对于另外 $20\%$ 的数据，保证 $T = 1$。

对于 $100\%$ 的数据，保证 $1 \leq T \leq 10 ^ 5$，$1 \leq n \leq 10 ^ 6$。

## 样例 #1

### 输入

```
3
2
3
4```

### 输出

```
1
3
6```

# AI分析结果



## 算法分类
**数论**

---

## 题解思路与难点分析

### 核心公式推导
题目要求满足两个方程的三元组 $(x, y, z)$ 的数量：
1. $x - \frac{y}{z} = n!$
2. $\frac{x - y}{z} = \frac{n!}{n}$

通过联立方程消去 $y$，得到 $x = \frac{(n-1)(n-1)! \cdot z}{z-1}$。为使 $x$ 为整数，$z-1$ 必须是 $(n-1)(n-1)!$ 的因数。因此，问题转化为计算 $(n-1)(n-1)!$ 的因数个数。

### 预处理与优化
1. **质因数分解**：利用线性筛预处理每个数的最小质因数，快速分解质因数。
2. **动态维护因数个数**：通过维护每个质数的指数，动态计算当前数的因数个数。每次处理 $i$ 时，将其质因数分解的次数累加两次（对应 $i \cdot i!$），再恢复一次（用于后续处理）。
3. **逆元预处理**：快速计算模意义下的除法，避免超时。

### 解决难点
- **高效质因数分解**：利用线性筛的最小质因数优化分解速度，时间复杂度从 $O(\sqrt{n})$ 降至 $O(\log n)$。
- **动态维护乘积**：通过逆元维护模意义下的因数个数乘积，避免重复计算。

---

## 最优思路与技巧

### 关键思路
- **因数个数公式**：将 $(n-1)(n-1)!$ 的因数个数转化为质因数指数加一的乘积。
- **预处理优化**：线性筛预处理最小质因数，动态维护质数指数，每次查询 $O(1)$ 响应。

### 技巧总结
- **逆元的线性预处理**：通过递推公式 $inv[i] = (mod - mod/i) \cdot inv[mod\%i] \mod mod$ 快速计算。
- **阶乘质因数的动态累加**：维护全局质数指数数组，分解每个数后更新指数并计算因数个数。

---

## 参考代码与核心逻辑

### 预处理质数的最小质因数
```cpp
void sieve(int n) {
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) {
            prime[++cnt] = i;
            mn[i] = i;
        }
        for (int j = 1; j <= cnt && i * prime[j] <= n; j++) {
            vis[i * prime[j]] = 1;
            mn[i * prime[j]] = prime[j];
            if (i % prime[j] == 0) break;
        }
    }
}
```

### 动态维护因数个数乘积
```cpp
void process(int i) {
    vector<pair<int, int>> factors = factorize(i);
    // 第一次累加：i! 的质因数
    for (auto [p, e] : factors) {
        ans = ans * inv[cnt[p] + 1] % mod;
        cnt[p] += e;
        ans = ans * (cnt[p] + 1) % mod;
    }
    // 第二次累加：i * i! 的质因数
    int temp = ans;
    for (auto [p, e] : factors) {
        temp = temp * inv[cnt[p] + 1] % mod;
        cnt[p] += e;
        temp = temp * (cnt[p] + 1) % mod;
    }
    ans_array[i] = temp;
    // 恢复：回到 i! 的质因数
    for (auto [p, e] : factors) {
        temp = temp * inv[cnt[p] + 1] % mod;
        cnt[p] -= e;
        temp = temp * (cnt[p] + 1) % mod;
    }
}
```

---

## 可视化算法设计

### 动画方案
1. **质数筛法演示**：展示线性筛法过程，高亮当前处理的数及其最小质因数。
2. **质因数分解流程**：逐步分解每个数，显示质因数的累加过程。
3. **因数个数动态更新**：用柱状图展示质数指数的变化，实时计算乘积。

### 复古像素风格
- **像素网格**：用 8-bit 风格显示质数分布，质因数分解时高亮对应区块。
- **音效反馈**：分解完成时播放 8-bit 音效，错误时播放低沉音效。

---

## 相似题目推荐
1. **P2048 质因数分解**：练习质因数分解的基本应用。
2. **P2428 质数的和**：涉及质数的预处理与动态计算。
3. **P1069 细胞分裂**：结合阶乘与因数个数的复合问题。

---
处理用时：255.87秒
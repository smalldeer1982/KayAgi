# 题目信息

# 串串题

## 题目描述

给定长度分别为 $n,m$ 的整数序列 $A,B$ 和常数 $W,d$，序列从 $1$ 开始标号，保证 $A_i,B_i \in [1,W]$。

容易发现，我们有 $\binom{W}{d}$ 种方案选择 $[1,W]$ 中的 $d$ 个互不相同的整数。

对于每一种选择的方案，我们删去 $A$ 中出现的对应的 $d$ 种整数，令此时序列 $B$ 在序列 $A$ 中的出现次数为这次选择方案的权值。

你需要求所有的选择方案的权值和，对 ${10}^9+7$ 取模。

若对题意有疑问，请阅读样例及样例解释。

注：$\binom{a}{b}$ 表示组合数，含义为在 $a$ 个物品中**无序**地选择出 $b$ 个物品的方案数。

**请注意：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

## 说明/提示

**【样例解释】**

在样例的第一组数据中：

1. 如果我们选择删去 $A$ 中的字符 $1$，$A$ 将变为 $\{2\}$，此时 $B$ 在 $A$ 中的出现次数为 $0$。
1. 如果我们选择删去 $A$ 中的字符 $2$，$A$ 将变为 $\{1,1,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $2$。
1. 如果我们选择删去 $A$ 中的字符 $3$，$A$ 将变为 $\{1,1,2,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $1$。

因此，第一组数据的答案为 $0+2+1=3$。

**再次提醒：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

---

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n,m,W \le {10}^6$，$1 \le d, A_i, B_j \le W$，$1 \le T \le 5$。

**本题采用捆绑测试且开启子任务依赖！**

| 子任务 | $n \le$ | $m \le$ | $W \le$ | 特殊性质 | 分数 | 依赖 |
| - | - | - | - | - | - | - |
| 1 | $10$ | $10$ | $5$ | | $10$ | \ |
| 2 | $1000$ | $1000$ | $5$ | | $20$ | 子任务 1 |
| 3 |  | | | A | $15$ | \ |
| 4 |  | | | B | $25$ | \ |
| 5 | | | | | $30$ | 子任务 1、2、3、4 |

特殊性质 A：保证 $d=1$。

特殊性质 B：令 $c$ 表示仅在序列 $A$ 中出现，而不在序列 $B$ 中出现的数字总数。保证 $c \le 5$。

## 样例 #1

### 输入

```
2
4 2 3 1
1 1 2 1
1 1
8 3 4 1
1 2 3 1 2 3 1 2
1 2 1
```

### 输出

```
3
2
```

# AI分析结果



## 算法分类
**组合数学**

---

## 题解思路与难点分析

### 核心逻辑与数学推导
**问题转化**：  
1. **关键元素**：B 中出现的元素必须保留，非关键元素可删。  
2. **有效匹配条件**：删去某些非关键元素后，B 必须完整出现在 A 的剩余序列中。  
3. **贡献计算**：对每个可能的匹配区间，计算必须删除的非关键元素数量 $t$，则方案数为 $\dbinom{c-t}{d-t}$（$c$ 为非关键元素总数）。

**数学关键点**：  
- 强制删除 $t$ 个特定非关键元素后，剩余可选删除数为 $d-t$，组合数公式直接计算。  
- 预处理阶乘和逆元加速组合数计算。

### 解决难点
1. **高效匹配**：使用 KMP 在提取后的关键元素序列中快速找到 B 的匹配位置。  
2. **区间统计**：双指针维护当前区间内的非关键元素种类数，通过滑动窗口动态更新。  
3. **组合数优化**：预处理阶乘和逆元，O(1) 查询组合数。

### 题解对比
- **共同点**：均采用 KMP + 双指针 + 组合数的框架。  
- **差异点**：  
  - **syzf2222**：代码简洁，直接处理原序列的桶计数，实时维护当前窗口的非关键元素种类。  
  - **Demeanor_Roy**：显式构建关键元素下标数组，减少边界判断，组合数预处理更规范。  
  - **离散小波变换°**：桶维护更清晰，代码注释详细，适合教学。

---

## 题解评分（≥4星）
1. **syzf2222（4.5星）**  
   - 思路清晰，代码高效，双指针与桶结合紧密。  
   - 略缺注释，但逻辑自洽。  
2. **Demeanor_Roy（4.5星）**  
   - 关键元素下标数组显式存储，降低复杂度。  
   - 组合数预处理规范，边界处理严谨。  
3. **离散小波变换°（4星）**  
   - 详细注释和数学推导，适合初学者。  
   - 桶维护稍显冗余，但可读性强。

---

## 最优思路提炼
1. **关键序列提取**：将 A 中属于 B 的元素提取为新序列，简化匹配问题。  
2. **KMP 快速匹配**：在关键序列中找到所有 B 的出现位置。  
3. **滑动窗口统计**：双指针维护每个匹配区间内的非关键元素种类数。  
4. **组合数快速计算**：预处理阶乘和逆元，公式直接求解贡献。

---

## 同类问题与套路
- **常见组合模型**：强制选择部分元素后，剩余自由选择的组合数计算。  
- **字符串匹配优化**：KMP 或 Z 函数处理模式串匹配。  
- **滑动窗口统计**：动态维护区间内元素种类/数量。

---

## 推荐题目
1. **P1495 组合数问题**（组合数预处理与取模）  
2. **P3375 KMP字符串匹配**（KMP 算法模板）  
3. **P1631 滑动窗口**（双指针维护极值/统计）

---

## 可视化设计
### 动画演示
1. **关键序列提取**：  
   - **高亮** A 中的关键元素，生成新序列 C。  
   - **颜色区分**：红色为关键元素，灰色为非关键元素。  
2. **KMP 匹配过程**：  
   - 逐步显示模式串 B 与 C 的匹配过程，匹配成功时闪烁提示。  
3. **双指针窗口**：  
   - 显示当前区间 [L, R] 的移动，动态统计非关键元素种类。  
   - **桶计数动画**：非关键元素进入/离开窗口时，对应桶数值变化。  
4. **组合数计算**：  
   - 公式 $\dbinom{c-t}{d-t}$ 动态更新，随窗口移动而变化。  

### 复古像素风格
- **Canvas 绘制**：8-bit 像素字体显示序列元素，KMP 匹配过程用箭头连接。  
- **音效**：匹配成功时播放 FC 风格“得分”音效，双指针移动伴随“滴答”声。  
- **自动演示**：模拟 AI 逐步执行 KMP 和双指针，可暂停/加速。

---

## 代码片段（核心逻辑）
```cpp
// 组合数预处理
int fct[N], inv[N], finv[N];
void init() {
    fct[0] = finv[0] = 1;
    for (int i=1; i<N; ++i) {
        fct[i] = 1LL * fct[i-1] * i % mod;
        inv[i] = (i==1) ? 1 : 1LL * (mod-mod/i) * inv[mod%i] % mod;
        finv[i] = 1LL * finv[i-1] * inv[i] % mod;
    }
}
int C(int x, int y) { // 计算组合数
    return (x<0 || y<0 || x<y) ? 0 : 1LL * fct[x] * finv[y] % mod * finv[x-y] % mod;
}

// 双指针统计非关键元素
int cnt[N], o=0;
for (int r=p[i]; r<=p[i+m-1]; ++r) {
    if (!vis[a[r]]) {
        if (++cnt[a[r]] == 1) ++o; // 进入窗口，种类+1
    }
}
ans = (ans + C(total_non_key - o, d - o)) % mod;
```

---

**可视化与代码完整实现** 可通过交互式页面动态演示上述流程，增强理解。

---
处理用时：80.14秒
# 题目信息

# [_-0 A] 考试

## 题目背景

小 $\mathfrak{g}$ 参加一场考试时，不小心把答题卡填反了。

## 题目描述

答题卡有 $n (1 \le n \le 10^9)$ 行，$m (1 \le m \le 10^9)$ 列，共 $nm$ 道题，**从左到右，从上到下，横向排列**。

每道题有 $c (4 \le c \le 10^9)$ 个选项。其中，前 $k(0 \le k \le nm)$ 道题为单选题，**有且仅有一个**正确选项；后 $nm - k$ 道题为多选题，正确选项个数**严格大于** $1$ 且**严格小于** $c$。

小 $\mathfrak{g}$ 正确地回答了所有题，但是她不小心把答题卡的方向看反了，从而她的答案排列方式为**从上到下，从左到右，纵向排列**。

题目的评分方式为：选项完全正确得 $1$ 分，多选或错选得 $0$ 分，漏选按比例给分。

形式化地说，若 $A$ 为某道题正确答案选项的集合，$B$ 为答题卡上选项的集合（均为 $\{1,2,3,\cdots,c\}$ 的子集），则该题得分为：

$$\begin{cases}\frac{\lvert B \rvert}{\lvert A \rvert}&\text{if\quad}
B\sube A\\0&\text{otherwise}\end{cases}$$

小 $\mathfrak{g}$ 忘记考试的正确答案是什么了，于是她去问小 $\mathfrak{f}$，如果考试的正确答案在合法范围内等概率随机，那么自己期望得分是多少。由于结果可能很大，她只需要知道结果对 $10^9+7$ 取模的值。

**题目保证 $c$ 和 $2^c-c-2$ 都不是 $10^9+7$ 的倍数。**


但是小 $\mathfrak{f}$ 也不会，所以他来求助万能的你。

## 说明/提示

**样例 $1$ 解释：**

得分的期望为 $\frac{67}{25}$，对 $10^9+7$ 取模为 $760000008$。

一种可能的考试的正确答案依次为：

$\texttt{C,D,B,AD,ABD,BC}$

那么答题卡上应该填写：

| $\texttt{C}$ | $\texttt{D}$ | $\texttt{B}$ |
| :----------: | :----------: | :----------: |
| $\texttt{AD}$ | $\texttt{ABD}$ | $\texttt{BC}$ |

实际填写：

| $\texttt{C}$ | $\texttt{B}$ | $\texttt{ABD}$ |
| :----------: | :----------: | :----------: |
| $\texttt{D}$ | $\texttt{AD}$ | $\texttt{BC}$ |

答案为 $\texttt{C}$，填写 $\texttt{C}$，得 $1$ 分。

答案为 $\texttt{D}$，填写 $\texttt{B}$，得 $0$ 分。

答案为 $\texttt{B}$，填写 $\texttt{ABD}$，得 $0$ 分。

答案为 $\texttt{AD}$，填写 $\texttt{D}$，得 $\frac{1}{2}$ 分。

答案为 $\texttt{ABD}$，填写 $\texttt{AD}$，得 $\frac{2}{3}$ 分。

答案为 $\texttt{BC}$，填写 $\texttt{BC}$，得 $1$ 分。

综上，这种情况下，考试得分为：

$1+0+0+\frac{1}{2}+\frac{2}{3}+1=
\frac{19}{6}$ 分。

**本题采用捆绑测试且使用子任务依赖。**

| 编号 | 分值 | $n,m\le$ | $c\le$ | 性质 | 依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $0$ | N/A| N/A | 样例 | 无 |
| $1$ | $5$ | $10^9$ | $10^9$ | A | 无 |
| $2$ | $5$ | $2$ | $4$ | 无 | 无 |
| $3$ | $20$ | $10^3$ | $10$ | 无 | $2$ |
| $4$ | $15$ | $10^9$ | $10$ | 无 | $2,3$ |
| $5$ | $15$ | $10^3$ | $10^3$ | 无 | $2,3$ |
| $6$ | $15$ | $10^3$ | $10^5$ | 无 | $2,3,5$ |
| $7$ | $10$ | $10^3$ | $10^9$ | B | 无 |
| $8$ | $10$ | $10^3$ | $10^9$ | 无 | $2,3,5,6,7$ |
| $9$ | $5$ | $10^9$ | $10^9$ | 无 | $0,1,2,3,4,5,6,7,8$ |

特殊性质 A：$n=1$ 或 $m=1$

特殊性质 B：$k=nm-2$

## 样例 #1

### 输入

```
2 3 3 4```

### 输出

```
760000008```

## 样例 #2

### 输入

```
314159265 358979323 84626433832795028 841971693```

### 输出

```
465094894```

# AI分析结果



**唯一算法分类**: 组合数学与数论

---

### **综合分析与结论**

**核心思路**  
题目关键在于分类计算每个题目的期望得分，利用期望的线性性求和。通过数论方法确定题号对应的位置数目，组合数学推导各类题的得分期望。

**数学难点**  
1. **题号对应数目计算**：利用最大公约数解方程，确定解的个数。
2. **矩形区域交集计算**：将不等式条件转化为几何区域，求交集面积。
3. **期望推导**：多选题得分需展开组合数求和，应用二项式定理化简。

**可视化设计**  
- **动画流程**：  
  1. 绘制原答题卡与错误排列的对比，高亮题号对应位置（红色）与错位（蓝色）。  
  2. 分步显示每类题的数量计算：用矩形覆盖区域，动态计算交集。  
  3. 公式推导过程逐行显示，如二项式展开、求导步骤，高亮关键变换。  
  4. 最终得分计算时，动态累加五类贡献。  

- **游戏化效果**：  
  - **像素风格**：题目用8位网格表示，正确题号对应时播放“成功”音效。  
  - **自动推导**：AI自动执行公式推导，用户可暂停观察中间结果。  

---

### **最优思路提炼**

1. **分类讨论**：将题目分为5类，分别计算贡献，避免复杂整体分析。
2. **数论技巧**：利用gcd解方程求题号对应数目，降低复杂度至O(1)。
3. **组合化简**：通过二项式定理将复杂求和转为幂运算，快速计算模结果。

---

### **代码核心逻辑**

**关键变量与公式**  
```cpp
// 计算 S_22 的模结果
int s22 = ((((long long)qpow(3, c) - 3LL * qpow(2, c) + 3) % p + p) % p * qpow(2, p-2) % p) 
          * qpow(((qpow(2, c) - c - 2) % p + p) % p, p-3) % p;
```

**完整代码**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int p = 1e9 + 7;
inline int qpow(int a, long long b) {
    int s = 1;
    while (b) {
        if (b & 1) s = (long long)s * a % p;
        a = (long long)a * a % p;
        b >>= 1;
    }
    return s;
}
int main() {
    int n, m, c; long long k;
    cin >> n >> m >> k >> c;
    long long nm = (long long)n * m;
    
    // 计算 C11'
    long long c11 = (k/m) * (k/n) + min(k/n, k%m) + min(k%n, k/m) 
                  + (k/m < k%n && k/n <= k%m);
    long long c12 = k - c11, c21 = k - c11;
    long long c22 = nm - c11 - c12 - c21;
    
    // 处理题号对应
    int g = __gcd(n-1, m-1);
    long long step = (g ? (nm -1)/g : 1);
    long long ceq = g + 1;
    c11 -= (step + k -1)/step;
    c22 -= (step + nm - k -1)/step;
    
    // 计算各期望
    int ans = 0;
    ans = (ans + ceq % p * 1) % p; // Seq=1
    ans = (ans + c11 % p * qpow(c, p-2)) % p; // S11=1/c
    ans = (ans + c12 % p * 0) % p; // S12=0
    ans = (ans + c21 % p * qpow(c, p-2)) % p; // S21=1/c
    // S22复杂计算
    int s22 = ...; // 如前述公式
    ans = (ans + c22 % p * s22) % p;
    cout << ans << endl;
    return 0;
}
```

---

### **同类题目推荐**

1. **P1495 组合数问题**：模下组合数求和与递推。
2. **P2480 古代猪文**：数论综合（费马小定理、Lucas定理）。
3. **P3758 可乐**：矩阵快速幂与状态转移期望。

---
处理用时：85.46秒
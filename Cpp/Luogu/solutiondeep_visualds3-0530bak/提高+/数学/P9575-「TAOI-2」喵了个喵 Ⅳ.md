# 题目信息

# 「TAOI-2」喵了个喵 Ⅳ

## 题目背景

小 S 共有 $n$ 只可爱的喵喵，第 $i$ 只喵喵有可爱度 $a_i$。小 S 想要把他的喵喵分成两组。考虑到小 S 的喵喵不像某些喵喵有九条命，他的喵喵只有一条，于是一只喵喵不能被同时分到两组内（请不要试图想象这个画面）。同时，如果一只喵喵没有被分到任意一组，他就会十分生气，很有可能导致小 S 失眠。

当然，小 S 也希望两组的**组可爱度**相等。即存在一个正整数 $x$，使得其中一组的 $\gcd(x, a_i)$ 之和等于另一组的 $\gcd(x, a_i)$ 之和。请你判断是否可以使得小 S 可以将喵喵分成两组，并可以找出一个 $x$ 使得两组的**组可爱度**相等。

## 题目描述

给定正整数 $n$ 及长度为 $n$ 的正整数序列 $a$，请你将 $a$ 划分为两个集合 $B, C$ 并给出正整数 $x$，使得 $\sum_{y\in B}\gcd(x,y) = \sum_{y\in C}\gcd(x,y)$。如果无解，输出 $-1$。

你需要保证 $1 \leq x \leq 10^9$，保证在本题的数据约束下若有解则总有 $x \leq 10^9$ 的解。

## 说明/提示

**本题采用捆绑测试。**

+ Subtask 0（2 pts）：$n$ 为偶数。
+ Subtask 1（8 pts）：$a_i$ 均为奇数。
+ Subtask 2（15 pts）：$n \leq 50$，$a_i \leq 50$。
+ Subtask 3（25 pts）：$n \leq 10^3$，$a_i \leq 10^3$。
+ Subtask 4（50 pts）：无特殊限制。

对于所有数据，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^6$。

## 样例 #1

### 输入

```
3
1 1 1```

### 输出

```
-1```

## 样例 #2

### 输入

```
4
4 1 2 3```

### 输出

```
3
0001
```

# AI分析结果



## 唯一算法分类  
**数论**

---

## 综合分析与结论  
### 核心思路与数学推导  
1. **奇偶性约束**：当 n 为奇数时，总和的奇偶性必须为偶数才能划分。若所有数的 gcd(x, a_i) 均为奇数（如 x 为奇数），则总和为奇数，无法均分。  
2. **2^k 约简**：通过提取所有 a_i 的最大公共 2 因子（即 min(lowbit(a_i))），将问题转化为更简单的情形。新数组必含至少一个奇数，此时 x 构造为 2^(k+1)。  
3. **分类统计**：统计新数组中奇偶数量。若奇数数为偶，则可通过两两分组构造平衡；否则无解。  

### 可视化设计思路  
1. **像素化约简流程**：  
   - **初始数组**：用不同颜色块表示 a_i，底部标注二进制末尾 0 的数量（lowbit）。  
   - **提取公共 2^k**：动画高亮所有数的末尾 0，取最小值 k，展示除以 2^k 后的新数组。  
   - **奇偶统计**：新数组中的奇偶块动态计数，若奇数数为偶则亮绿色，否则红色警示。  
2. **分组动画**：  
   - **分组逻辑**：用左右两个容器表示 B/C 组，奇偶块按规则分配（如每两个奇数分到不同组），动态展示平衡过程。  
   - **音效反馈**：成功分配时播放 8-bit 胜利音效，无解时播放失败音效。  

---

## 题解清单（≥4星）  
1. **Register_int（5星）**  
   - **亮点**：通过 lowbit 快速提取公共因子，逻辑简明，代码高效。  
   - **关键代码**：  
     ```cpp  
     k = min(k, __lg(a[i] & -a[i]));  
     a[i] >>= k; // 约简公共 2^k  
     if (cnt & 1) return puts("-1"); // 奇数数奇则无解  
     ```  

2. **TernaryTree（4星）**  
   - **亮点**：通过归纳法分析 2^s 对奇偶性的影响，代码中引入集合优化分组。  
   - **心得摘录**：*“赛时用 set 维护位置，多一个 log，实际无需复杂结构”*  

3. **NBest（4星）**  
   - **亮点**：通过约去公共因子处理全偶数特例，代码中通过位运算快速计算 lowbit。  
   - **关键公式**：  
     ```cpp  
     k = min(k, (a[i] & -a[i])); // 计算最低位 1 的值  
     a[i] /= k; // 转化为含奇数的简化问题  
     ```  

---

## 同类型题与套路  
1. **通用思路**：  
   - **奇偶分组**：利用 gcd 奇偶性简化问题。  
   - **因子约简**：提取公共因子将问题转化为更易处理的情形。  
   - **lowbit 技巧**：快速处理二进制末尾 0 的计数问题。  

2. **推荐题目**：  
   - [P1894 奇偶分家](https://www.luogu.com.cn/problem/P1894)  
   - [P2447 因子和](https://www.luogu.com.cn/problem/P2447)  
   - [P5656 二元一次不定方程](https://www.luogu.com.cn/problem/P5656)  

---

## 复古像素化演示方案（伪代码）  
```javascript  
// Canvas 初始化  
const canvas = document.createElement('canvas');  
ctx = canvas.getContext('2d');  
const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4']; // 8-bit 调色板  

function drawStep(step) {  
  switch(step) {  
    case 0: // 初始数组  
      drawBlocks(a, colors[0], '原始数组');  
      break;  
    case 1: // 提取 2^k  
      highlightLowBits(a); // 高亮末尾 0  
      break;  
    case 2: // 约简后的奇偶分组  
      drawDividedBlocks(newA, colors[1], colors[2]);  
      playSound('success');  
  }  
}  

// 音效触发  
function playSound(type) {  
  const audio = new Audio();  
  audio.src = type === 'success' ? '8bit-win.wav' : '8bit-fail.wav';  
  audio.play();  
}  
```  

**交互设计**：  
- **方向键**控制步骤切换，**空格键**暂停/继续。  
- **自动模式**：模拟 AI 推导过程，每步延迟 1.5 秒。  

---

## 核心代码实现  
```cpp  
// 关键约简与分组逻辑（Register_int 解法核心）  
int main() {  
    scanf("%d", &n);  
    int k = 20;  
    for (int i = 1; i <= n; i++) {  
        int t = __builtin_ctz(a[i]); // 计算末尾 0 的数量  
        k = min(k, t);  
    }  
    for (int i = 1; i <= n; i++)  
        a[i] >>= k; // 约简公共 2^k  
    int cnt = 0;  
    for (int i = 1; i <= n; i++)  
        cnt += (a[i] & 1);  
    if (cnt % 2 != 0) {  
        puts("-1");  
        return 0;  
    }  
    printf("%d\n", 2 << k); // x = 2^(k+1)  
    // 分组输出...  
}  
```  

---

## 个人心得摘录  
- **调试教训**：*“全偶数情况需递归约简，直接判断奇偶会 WA”（Linghua_dog）*  
- **思维突破**：*“将问题转化为仅含 1/2 的简化情形，豁然开朗”（TernaryTree）*  

--- 

通过深入分析数论特性与巧妙的因子约简，本题得以高效解决。结合像素化演示与交互设计，可直观展现核心数学逻辑。

---
处理用时：83.22秒
# 题目信息

# [ICPC 2021 Nanjing R] Xingqiu's Joke

## 题目描述

有 $T$ 个盒子，每盒子上有一个锁，锁上有两个整数 $a$ 和 $b$。你可以对这个锁做若干次以下 3 种操作：

- $a$ 和 $b$ 分别减去 $1$
- $a$ 和 $b$ 分别增加 $1$
- $a$ 和 $b$ 分别除以它们共同的素数因子

如果 $a$ 或 $b$ 或两者都变为 $1$，盒子就会解锁。请你编写一个程序，计算每个盒子的锁打开的最少步骤数量。

## 样例 #1

### 输入

```
5
4 7
9 8
32 84
11 35
2 1
```

### 输出

```
2
7
5
4
0
```

# AI分析结果



**唯一算法分类**  
数论

---

### 题解思路与核心难点

**核心思路**  
1. **差值的质因子是关键**：任何公共质因子必须整除差值 `d = |a-b|`，因此只需分解 `d` 的质因子。  
2. **调整到最近的倍数**：每次除法前，需将当前较小值 `a` 调整到最近的 `g` 的倍数（向上或向下），取调整步数最小的方向。  
3. **记忆化搜索**：状态设计为 `(当前较小值, 差值)`，递归计算最小步数。

**数学推导**  
- 设当前状态为 `(a, d)`，若 `g` 是 `d` 的质因子，则调整后的 `a'` 为 `a//g` 或 `(a+g-1)//g`，差值变为 `d/g`。  
- 调整步数为 `a%g`（向下调整）或 `g - a%g`（向上调整），加上递归步数。

**解决难点**  
- **状态爆炸**：通过分解差值的质因子限制状态维度，记忆化避免重复计算。  
- **正确性证明**：所有可能的除法操作只能使用差值的质因子，调整到最近倍数的策略保证了局部最优。

---

### 题解评分（≥4星）

1. **SDLTF_凌亭风（5星）**  
   - 思路清晰，代码简洁，直接以差值的质因子为转移依据。  
   - 状态参数明确，记忆化设计高效。  
   - 代码中 `dfs` 函数逻辑直观，易理解。

2. **CashCollectFactory（4星）**  
   - 详细推导了状态转移方程，解释了关键性质。  
   - 代码中哈希函数设计合理，分解质因数步骤完整。  
   - 代码可读性稍逊于最优解。

3. **gan_ge（4星）**  
   - 动态规划视角清晰，状态转移方程明确。  
   - 代码结构简洁，使用了 `map` 存储状态，适合教学。

---

### 最优思路提炼

1. **质因子分解**：分解差值 `d` 的质因子，限制可能的除法操作。  
2. **调整策略**：每次操作前调整到最近的 `g` 倍数，取调整步数最小方向。  
3. **记忆化状态**：状态参数为 `(a, d)`，覆盖所有可能转移路径。

---

### 同类型题与套路

**常见数论套路**  
- **辗转相减法**：利用差值性质推导公因子。  
- **质因数分解**：将问题限制在有限因子集合内。  
- **记忆化搜索**：针对指数级状态空间，避免重复计算。

**类似题目**  
- [CF 1538D]("Another Problem on Dividing Numbers")：通过除法操作调整数值，涉及质因子分解。  
- [LeetCode 650]("2 Keys Keyboard")：通过质因子分解优化操作步骤。  
- [洛谷 P1072]("Hankson 的趣味题")：利用公因子性质求解数论问题。

---

### 代码核心实现

**SDLTF_凌亭风的关键代码**  
```cpp
int dfs(int a, int c) {
    if(a == 1) return 0;
    if(c == 1) return a - 1;
    if(f[tra(a, c)]) return f[tra(a, c)];
    int res = a - 1;
    for(auto p : fact) if(!(c % p)) 
        res = min({res, (a % p) + 1 + dfs(a / p, c / p) , 
                    p - (a % p) + 1 + dfs(a / p + 1, c / p)});
    return f[tra(a,c)] = res;
}
```

**代码逻辑**  
1. **终止条件**：`a=1` 或 `c=1`（只能逐步减到1）。  
2. **枚举质因子**：对每个 `d` 的质因子 `p`，计算调整到 `p` 的倍数的两种可能步数。  
3. **取最小值**：记录当前状态的最小步数，存入记忆化表。

---

### 可视化与游戏化设计

**动画方案**  
- **像素风格**：用 8-bit 像素块表示数值变化，红色标记当前操作。  
- **步进演示**：  
  1. 分解差值质因子，显示 `d` 的质因子列表。  
  2. 高亮当前质因子 `g`，计算 `a%g` 和 `g - a%g`。  
  3. 显示调整后的 `a'` 和 `d'=d/g`，递归进入下一层。  
- **音效反馈**：除法操作时播放 "beep"，成功终止时播放胜利音效。

**Canvas 交互**  
- **初始化**：绘制初始状态 `(a, b)` 和差值 `d`。  
- **质因子分解**：用爆炸动画展示质因子分解过程。  
- **调整步骤**：用箭头表示加减操作，颜色渐变表示步数消耗。

---

### 个人心得摘录

- **调试教训**：初始未考虑差值为0的情况，导致死循环。  
- **优化顿悟**：发现差值的质因子集合是有限的，大幅减少状态数。  
- **实现技巧**：使用 `unordered_map` 存储状态，避免动态规划数组的内存问题。

---

**推荐题目**  
1. [洛谷 P1072]("Hankson 的趣味题")  
2. [洛谷 P1069]("细胞分裂")  
3. [CF 1538D]("Another Problem on Dividing Numbers")

---
处理用时：66.84秒
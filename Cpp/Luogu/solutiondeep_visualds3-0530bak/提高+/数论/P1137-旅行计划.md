# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果



# 算法分类
**拓扑排序 + 动态规划**

---

## 综合分析与结论

### 核心思路
1. **DAG性质**：题目给出道路连接满足"只能往东走"，本质是要求在有向无环图(DAG)中寻找以每个节点为终点的最长路径
2. **拓扑排序保证无后效性**：通过拓扑序处理节点，确保处理节点时所有前驱节点的最长路径已被计算
3. **动态规划状态转移**：`dp[v] = max(dp[v], dp[u] + 1)`，u为v的前驱节点
4. **实现优化**：将拓扑排序与DP合并进行，减少代码量和空间消耗

### 解决难点
1. **多起点问题**：通过反向建图或初始时将所有入度为0的节点入队解决
2. **路径计数方式**：所有节点初始值为1（自身作为起点），通过拓扑序逐步累加
3. **时间复杂度控制**：使用邻接表存储（O(N+M)）代替邻接矩阵（O(N²)）

### 可视化设计
**像素风格动态演示**：
1. **拓扑队列展示**：用像素块队列表示拓扑处理顺序，当前处理的节点高亮为黄色
2. **DP值更新动画**：当处理节点u时，其指向的节点v的DP值以绿色闪烁提示更新
3. **入度可视化**：每个节点旁显示红色数字表示当前入度值，归零时触发音效
4. **8-bit音效设计**：
   - 节点入队：短促"滴"声
   - DP值更新：上升音阶
   - 拓扑序完成：经典FC过关音效

---

## 题解清单（4星以上）

### 1. 作者：星星之火（⭐⭐⭐⭐⭐）
**核心亮点**：
- 清晰阐述拓扑排序与DP的关系
- 完整代码包含邻接表实现
- 特别说明拓扑序保证DP无后效性

```cpp
void topsort() {
    queue<int> q;
    for(int i=1;i<=n;i++) 
        if(ru[i]==0) q.push(i);
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int i=head[u];i;i=edge[i].next) {
            int v = edge[i].to;
            ru[v]--;
            if(ru[v]==0) q.push(v);
            dp[v] = max(dp[v], dp[u]+1); // 关键转移
        }
    }
}
```

### 2. 作者：_ZZH（⭐⭐⭐⭐）
**核心亮点**：
- 拓扑与DP合并执行
- 代码简洁（仅30行）
- 使用链式前向星优化空间

```cpp
while(!q.empty()) {
    int cnt = q.front(); q.pop();
    for(int i=lin[cnt];i;i=e[i].next) {
        f[e[i].to] = max(f[e[i].to], f[cnt]+1);
        if(--in[e[i].to]==0) q.push(e[i].to);    
    }
}
```

### 3. 作者：归山_（⭐⭐⭐⭐）
**亮点**：
- 反向建图记忆化搜索
- 提供不同解题视角
- 包含调试经验说明

```cpp
int dfs(int x) {
    if(dp[x]!=-1) return dp[x];
    dp[x] = 1;
    for(int i=head[x];i;i=e[i].next) {
        int y = e[i].to;
        dp[x] = max(dp[x], dfs(y)+1);
    }
    return dp[x];
}
```

---

## 最优思路提炼
**拓扑序动态规划四步法**：
1. **预处理入度**：遍历所有边统计节点入度
2. **拓扑初始化**：将入度0的节点加入队列，初始化dp[i]=1
3. **拓扑处理**：
   - 取出节点u，遍历其邻接节点v
   - 更新v的dp值：`dp[v] = max(dp[v], dp[u]+1)`
   - 减少v的入度，入度归零时入队
4. **结果输出**：直接输出dp数组

---

## 同类题目推荐
1. **P4017 最大食物链计数**：DAG路径计数
2. **P1113 杂务处理**：拓扑排序求关键路径
3. **P1983 车站分级**：拓扑排序层次分析

---

## 可视化算法演示（核心逻辑）
```javascript
// 伪代码示例
class TopoAnim {
    constructor(nodes) {
        this.queue = new PixelQueue(160, 50)  // 8-bit风格队列
        this.nodes = nodes.map(n => new NodeSprite(n))
        this.sound = new EightBitAudio()
    }

    async processNode(u) {
        this.queue.highlightHead() // 队列头高亮
        this.nodes[u].glow()       // 当前节点发光
        
        await delay(500)
        for (const v of adj[u]) {
            this.nodes[v].showInDegreeReduction() // 显示入度-1动画
            this.dp[v] = Math.max(this.dp[v], this.dp[u]+1)
            this.nodes[v].showDPUpdateAnim()     // DP值绿色闪烁
            
            if(--inDegree[v] === 0) {
                this.queue.enqueue(v)            // 入队像素动画
                this.sound.play('enqueue')
            }
        }
    }
}
```

---

## 调试经验摘录
> "WA后发现初始节点不止一个，必须将所有入度0的节点初始化入队。原题说明中的『均选择从城市1出发』是误导，实际需要处理所有可能的起点" —— 作者：Space_Gold_Trash

> "记忆化搜索要注意反向建图，把终点转化为起点进行DFS，否则会重复计算路径" —— 作者：zyx10

---

## 实现要点总结
**数据结构选择**：
- 邻接表存储：`vector<vector<int>>` 或链式前向星
- 入度数组：`int inDegree[N]`
- DP数组：`int dp[N]` 初始化为1

**关键优化点**：
- 合并拓扑排序与DP步骤
- 使用队列代替递归防止栈溢出
- 反向建图时注意遍历顺序

**易错点**：
- 多起点初始化
- 结果输出需要换行符
- 节点编号从1开始的处理

---
处理用时：78.44秒
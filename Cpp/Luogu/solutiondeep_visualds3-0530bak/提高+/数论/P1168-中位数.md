# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果



**算法分类**：对顶堆（双堆维护）

---

### **题解思路与核心难点**

1. **对顶堆核心思想**  
   - **大根堆（左堆）**：维护前一半较小的元素，堆顶为最大值。  
   - **小根堆（右堆）**：维护后一半较大的元素，堆顶为最小值。  
   - **平衡条件**：保证大根堆的大小始终比小根堆大1或相等，中位数为大根堆堆顶。

2. **解决难点**  
   - **插入策略**：新元素根据与当前中位数比较选择插入堆。  
   - **动态平衡**：每次插入后调整两堆大小差不超过1。  
   - **时间复杂度**：每个元素插入/调整操作为O(log n)，整体O(n log n)。

3. **关键步骤**  
   ```python
   if 插入元素 <= 当前中位数:
       放入大根堆
   else:
       放入小根堆
   while 两堆大小差 >1:
       将较大堆的堆顶移动到另一堆
   中位数 = 较大堆的堆顶
   ```

---

### **题解评分（≥4星）**

1. **肖恩Sean（5星）**  
   - 代码简洁，双堆维护逻辑清晰。  
   - 维护堆大小差的核心代码仅需5行，可读性极强。  
   - 关键亮点：通过 `abs(q1.size()-q2.size())>1` 直接控制平衡。

2. **IRipple（4星）**  
   - 引入 `mid` 变量动态跟踪中位数，降低调整频率。  
   - 图示辅助理解堆结构调整过程，适合新手学习。

3. **张小源（4星）**  
   - 每次插入两个元素，通过交换堆顶直接维护平衡。  
   - 代码实现短小精悍，适合快速实现。

---

### **最优思路提炼**

1. **双堆划分策略**  
   - 大根堆维护前半部分，小根堆维护后半部分，通过堆顶快速访问中间值。  
   - 插入时根据当前中位数动态选择堆，保证元素分布有序性。

2. **平衡调整技巧**  
   - 每次插入后立即检查堆大小差，通过堆顶交换实现O(1)时间复杂度调整。  
   - 仅需维护堆大小差≤1，无需完全排序。

---

### **类似题目推荐**

1. **P1801 黑匣子**  
   - 动态维护第k小元素，双堆思想直接适用。

2. **P3871 [TJOI2010]中位数**  
   - 完全相同的双堆解法，直接套用本题代码。

3. **P3382 【模板】主席树**  
   - 扩展学习：静态区间第k大问题的另一种解法。

---

### **核心代码实现（对顶堆）**

```cpp
#include <queue>
#include <cstdio>
using namespace std;

priority_queue<int> left_heap; // 大根堆（前一半）
priority_queue<int, vector<int>, greater<int>> right_heap; // 小根堆（后一半）

int main() {
    int n, x;
    scanf("%d", &n);
    scanf("%d", &x);
    left_heap.push(x);
    printf("%d\n", x);
    
    for (int i=3; i<=n; i+=2) {
        // 插入两个新元素
        for (int j=0; j<2; j++) {
            scanf("%d", &x);
            (x <= left_heap.top()) ? left_heap.push(x) : right_heap.push(x);
        }
        // 平衡堆大小
        while (abs((int)left_heap.size() - (int)right_heap.size()) > 1) {
            if (left_heap.size() > right_heap.size()) {
                right_heap.push(left_heap.top());
                left_heap.pop();
            } else {
                left_heap.push(right_heap.top());
                right_heap.pop();
            }
        }
        printf("%d\n", left_heap.top());
    }
    return 0;
}
```

---

### **可视化设计（像素风格演示）**

1. **动画逻辑**  
   - **Canvas绘制**：左侧红色方块表示大根堆，右侧蓝色表示小根堆，堆顶高亮显示。  
   - **插入过程**：新元素以绿色方块从顶部下落，根据比较结果进入对应堆区。  
   - **平衡调整**：当堆高差>1时，触发堆顶交换动画，伴随8-bit音效。

2. **交互设计**  
   - **速度控制**：滑块调节动画速度（1x-5x）。  
   - **单步模式**：空格键逐帧执行插入/调整操作。  
   - **音效设计**：  
     - 插入成功：短促「哔」声（440Hz）  
     - 堆调整：下滑音效（220Hz→440Hz）  
     - 中位数更新：胜利音效（NES《超级马里奥》金币声效）

---

### **总结**

对顶堆通过巧妙划分数据范围，以O(n log n)时间复杂度高效维护动态中位数。其核心在于通过堆性质快速定位中间值，配合动态平衡策略保证算法效率。该思想可扩展至任意分位数维护问题，是处理流式数据统计指标的经典方法。

---
处理用时：81.82秒
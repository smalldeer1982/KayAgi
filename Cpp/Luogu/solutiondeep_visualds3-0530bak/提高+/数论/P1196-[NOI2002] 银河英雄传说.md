# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



# [NOI2002] 银河英雄传说

**算法分类**：带权并查集

---

## 题解核心思路与难点分析

### 算法要点
1. **带权并查集扩展**：在标准并查集基础上维护两个数组：
   - `front[i]`：节点i到根节点的距离（权值）
   - `size[i]`：以i为根的队列长度（用于合并时计算距离）

2. **路径压缩优化**：
   ```cpp
   int find(int x) {
       if (fa[x] == x) return x;
       int root = find(fa[x]);
       front[x] += front[fa[x]]; // 路径压缩时累加父节点权值
       return fa[x] = root;
   }
   ```

3. **队列合并逻辑**：
   ```cpp
   void merge(int x, int y) {
       int fx = find(x), fy = find(y);
       front[fx] = size[fy];       // fx到新根的距离为原y队列长度
       size[fy] += size[fx];       // 更新新队列总长度
       fa[fx] = fy;                // 合并操作
   }
   ```

4. **距离查询公式**：
   ```cpp
   if (find(x) == find(y)) 
       return abs(front[x] - front[y]) - 1;
   ```

### 解决难点
1. **动态权值维护**：通过递归式路径压缩，在回溯过程中逐层更新权值，保证查询时的距离计算正确性。

2. **合并顺序控制**：将x所在队列的根节点接在y队列尾部时，需精确计算新加入节点到新根的初始距离。

---

## 高星题解推荐（≥4★）

### 假装思考（4.5★）
- **亮点**：完整的路径压缩实现，清晰的前缀和思路
- **代码特征**：使用`front`数组记录战舰到队首距离，`size`数组维护队列长度

### 破壁人（4.2★）
- **亮点**：简洁的带权实现，直接维护节点到根的距离
- **代码特征**：采用三数组结构（f,s,b）分别存储父节点、距离、队列大小

### Mr_Wolfram（4.0★）
- **亮点**：完整注释版带权并查集，适合初学者理解
- **代码特征**：明确定义`dis`为到父节点距离，`num`为队列长度

---

## 核心代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 30005;

int fa[MAXN], front[MAXN], size[MAXN];

int find(int x) {
    if (fa[x] != x) {
        int root = find(fa[x]);
        front[x] += front[fa[x]];
        fa[x] = root;
    }
    return fa[x];
}

void merge(int x, int y) {
    int fx = find(x), fy = find(y);
    fa[fx] = fy;
    front[fx] = size[fy];
    size[fy] += size[fx];
}

int query(int x, int y) {
    if (find(x) != find(y)) return -1;
    return abs(front[x] - front[y]) - 1;
}

int main() {
    // 初始化代码略
}
```

---

## 可视化算法演示设计

### 动画要素
1. **队列合并过程**：
   - 用不同颜色标记两个队列
   - 箭头动画展示队列首尾连接
   - 数值飘动显示`front`和`size`的更新

2. **路径压缩演示**：
   - 高亮当前查询路径
   - 逐步显示`front`值的累加过程
   - 路径缩短时的颜色渐变效果

### 复古像素风格方案
- **颜色方案**：8位色系（红-当前节点，绿-根节点，蓝-普通节点）
- **音效设计**：
  - "哔"声：每次路径压缩
  - "叮"声：成功合并队列
  - 失败音效：查询不同队列时

---

## 相似题目推荐
1. P2342 叠积木（带权并查集经典题）
2. P1525 关押罪犯（并查集分组应用）
3. P2024 食物链（三组关系扩展）

---

## 关键调试心得
- **路径压缩顺序**：必须先在递归中更新父节点权值，再压缩路径
- **合并方向**：特别注意合并时x队列接在y队列尾部，方向错误会导致计算结果颠倒
- **初始化要点**：`size`数组初始值必须为1（每个节点初始为独立队列）

---
处理用时：68.27秒
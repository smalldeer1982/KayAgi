# 题目信息

# 「WHOI-1」Derives

## 题目背景

你的钱里面混进去了一个假币。

## 题目描述

你有 $n$ 枚硬币。经过准确的测量，你发现一定有一枚是假币，假币的质量与其他硬币不同。你想要找出这枚假币。

第 $i$ 轮，假设你当时有 $x_i$ 枚硬币，你会把当前钱堆所有钱分配到若干组，每组 $k_i$ 个，最终剩下的再单独分一组。每个硬币你要拿起来需要 $a$ 秒，那么这将会花费你 $ax_i$ 秒的时间。接下来，你会称量每一组，称量每组需要 $b$ 秒，所以这将会花费你 $b\cdot\lceil\frac{x_i}{k_i}\rceil$ 秒的时间。由于只有一枚假币，那么只会有一堆的质量与正常的质量不同。**在称量所有堆之后**，你将会选出与正常质量不同的那一堆，并进入下一轮，让 $x_{i+1}=k_i$。一直执行，直到 $x_i=1$。假设进行了 $m$ 轮，那么花费时间 $f=\sum\limits_{i=1}^{m}{(ax_i+b\cdot\lceil\frac{x_i}{k_i}\rceil)}$

请问，你在最差情况下（**即每轮选出不正常的都是 $k_i$ 个一堆的**）最少需要多长时间找出那枚假币？

## 说明/提示

**说明**

**你需要尽量使得花费的时间更少。**

本题采用 Special Judge。

首先，你输出的答案一定要合法，也就是你输出的答案要与下面的选择方法符合，否则将获得 $0$ 分。

接下来，评测机会对你的输出进行判断。如果你输出的答案合法且与正确答案的差 $\le9$，那么你将获得 $(10-d)\times100\%$ 的分数。例如，如果你输出的答案与正确答案的差为 $4$，那么你将获得 $60\%$ 的分数。如果你输出的答案等于正确答案，你将获得 $100\%$ 的分数。请不要输出多余的数字或少输出。

**数据范围**

- $\text{subtask 1(10pts)}:$ $1\le n\le2000$。
- $\text{subtask 2(20pts)}:$ $1\le n\le75000$。
- $\text{subtask 3(30pts)}:$ $1\le n\le10^7$。
- $\text{subtask 4(40pts)}:$ $1\le n\le10^9$。

对于所有数据，满足 $0<a,b\le10^9$。

**样例说明**

对于第一个样例，进行两轮。$x_1=20,k_1=4,x_2=4,k_2=1$。答案 $f=20+15+4+12=51$。

## 样例 #1

### 输入

```
20 1 3```

### 输出

```
51 2
4 1```

## 样例 #2

### 输入

```
1000 10 100```

### 输出

```
13570 4
72 12 3 1```

# AI分析结果



**唯一算法分类**：动态规划 + 整除分块优化

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **动态规划定义**：设 `f(x)` 为处理 `x` 枚硬币的最小时间，转移方程为：
   \[
   f(x) = \min_{k} \left( f(k) + a \cdot x + b \cdot \lceil \frac{x}{k} \rceil \right)
   \]
   其中 `k` 是当前分组大小，`ceil(x/k)` 是分组次数。
2. **整除分块优化**：观察到 `ceil(x/k)` 可转化为 `floor((x-1)/k) + 1`，对 `x-1` 进行整除分块。每块内的最优转移点为左端点 `L`，因 `f` 单调递增。

#### **解决难点**
1. **状态转移优化**：直接遍历所有 `k` 是 `O(n^2)`，无法处理大 `n`。整除分块将候选 `k` 的数量降至 `O(√n)`。
2. **存储优化**：使用哈希表或自定义映射存储稀疏的 `f(x)`，避免数组内存爆炸。例如，`Exschawasion` 用 `pbds::cc_hash_table`，`rui_er` 用数组分块映射。
3. **复杂度分析**：记忆化搜索的递归树类似杜教筛，时间复杂度 `O(n^{3/4})`，可处理 `n ≤ 1e9`。

---

### **题解评分 (≥4星)**

1. **Exschawasion (5星)**
   - **亮点**：使用 `pbds::cc_hash_table` 高效存储状态，结合整除分块实现 `O(n^{3/4})`。
   - **代码实现**：简洁的分块循环和哈希表查询，适合大范围 `n`。
2. **rui_er (5星)**
   - **亮点**：自定义 `id(x)` 函数映射状态到数组下标，避免哈希表开销。
   - **复杂度保证**：严格证明分块后的转移点最优性。
3. **Hisaishi_Kanade (4星)**
   - **亮点**：详细推导 `ceil` 转 `floor` 的过程，适合数学分析。
   - **缺点**：`unordered_map` 常数较大，可能无法通过极限数据。

---

### **最优思路或技巧提炼**

1. **整除分块转化**：将 `ceil(x/k)` 转化为对 `x-1` 的整除分块，减少候选 `k`。
2. **记忆化搜索**：仅计算必要的 `f(x)`，避免预处理所有状态。
3. **哈希映射优化**：使用开放寻址或链表式哈希表（如 `pbds::cc_hash_table`）加速状态查询。
4. **单调性利用**：`f(x)` 单调递增，确保每块左端点是最优转移点。

---

### **同类型题或类似算法套路**

1. **整除分块应用**：如余数求和（洛谷 P2261）、杜教筛法。
2. **记忆化搜索优化**：如数位 DP 中的状态压缩。
3. **动态规划分块**：如多重背包的单调队列优化。

---

### **推荐相似题目**

1. **P2261 [CQOI2007]余数求和**：整除分块经典应用。
2. **P1835 素数密度**：分块处理大区间素数筛选。
3. **P4213 【模板】杜教筛**：记忆化搜索与分块结合。

---

### **可视化与算法演示**

#### **动画设计**
1. **分块展示**：在 Canvas 上绘制当前 `x`，动态划分 `k` 的候选块，高亮左端点。
2. **状态转移路径**：用颜色标记已计算的 `f(x)`，箭头表示转移方向。
3. **复古像素风格**：
   - **颜色方案**：16色调色板，绿色表示当前块，红色表示最优转移。
   - **音效**：移动时播放 8-bit 音效，找到最优解时播放胜利音效。

#### **交互设计**
- **步进控制**：允许单步执行分块过程，观察每块的 `L, R` 和对应的 `f(k)`。
- **参数调节**：可调整 `a, b` 实时查看最优分组策略变化。

---

### **核心代码实现**

#### **Exschawasion 的关键代码**
```cpp
ll dp(ll x) {
    auto at = gp.find(x);
    if (at != gp.end()) return at->second;
    ll ans = LLONG_MAX;
    ll N = x - 1;
    for (ll L = 1, R; L <= N; L = R + 1) {
        R = N / (N / L);
        ll cur = dp(L) + (N / L + 1) * b + x * a;
        if (cur < ans) ans = cur, p = L;
    }
    pre[x] = p;
    return gp[x] = ans;
}
```

#### **rui_er 的映射函数**
```cpp
ll id(ll x) {
    if (x <= (n - 1) / x) return x;
    else return 100000 + (n - 1) / x;
}
```

---

### **总结**
通过动态规划与整除分块的结合，将问题复杂度从 `O(n^2)` 优化至 `O(n^{3/4})`，并利用哈希表或数组映射高效处理状态存储。关键在于分块优化和记忆化搜索的结合，适用于大范围数据的最优策略求解。

---
处理用时：74.90秒
# 题目信息

# [蓝桥杯 2016 国 B] 广场舞

## 题目描述

LQ 市的市民广场是一个多边形，广场上铺满了大理石的地板砖。

地板砖铺得方方正正，就像坐标轴纸一样。

以某四块砖相接的点为原点，地板砖的两条边为两个正方向，一块砖的边长为横纵坐标的单位长度，则所有横纵坐标都为整数的点都是四块砖的交点（如果在广场内）。

广场的砖单调无趣，却给跳广场舞的市民们提供了绝佳的参照物。每天傍晚，都会有大批市民前来跳舞。

舞者每次都会选一块完整的砖来跳舞，两个人不会选择同一块砖，如果一块砖在广场边上导致缺角或者边不完整，则没人会选这块砖。

（广场形状的例子参考图）

![](https://cdn.luogu.com.cn/upload/image_hosting/kjgaxse9.png)

现在，告诉你广场的形状，请帮 LQ 市的市长计算一下，同一时刻最多有多少市民可以在广场跳舞。

## 说明/提示

**【样例说明】**

广场如图所示，一共有 $7$ 块完整的地板砖，因此最多能有 $7$ 位市民一起跳舞。

**【数据规模与约定】**

对于 $30\%$ 的数据，$n$ 不超过 $100$，横纵坐标的绝对值均不超过 $100$。

对于 $50\%$ 的数据，$n$ 不超过 $1000$，横纵坐标的绝对值均不超过 $1000$。

对于 $100\%$ 的数据，$n$ 不超过 $1000$，横纵坐标的绝对值均不超过 $10^8$。

时限 1 秒, 256M。蓝桥杯 2016 年第七届

## 样例 #1

### 输入

```
5
3 3
6 4
4 1
1 -1
0 4```

### 输出

```
7```

## 样例 #2

### 输入

```
3 3```

### 输出

```
4```

# AI分析结果



## 算法分类
计算几何

---

## 综合分析与结论
**题目核心**：统计所有单位正方形，其四个顶点均位于给定的多边形内部。  
**难点**：坐标范围极大（1e8）时无法暴力枚举，需高效判断格点是否满足条件。  

**解决思路**：  
1. **包围盒剪枝**：计算多边形顶点的x/y最小最大值，缩小遍历范围。  
2. **点是否在多边形内**：使用射线法逐点判断。  
3. **暴力枚举**：遍历包围盒内所有可能的左下角点，检查四个顶点是否全在内部。  

**可视化设计**：  
- **动画方案**：绘制多边形及遍历的网格点，高亮当前检查的四个顶点，绿色表示全在内部，红色表示至少一个在外部。  
- **颜色标记**：当前左下角点用黄色标记，四个顶点用不同颜色区分。  
- **步进控制**：允许调整遍历速度，观察检查过程。  

---

## 题解评分与亮点
**4星题解**  
**关键亮点**：  
- **包围盒剪枝**有效减少遍历范围。  
- **射线法**实现准确的点包含判断。  
- **代码简洁**，逻辑清晰，适合小规模数据。  

---

## 核心代码实现
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

struct Point { double x, y; };

// 射线法判断点是否在多边形内
bool isInside(const vector<Point>& poly, double px, double py) {
    bool inside = false;
    for (int i = 0, j = poly.size()-1; i < poly.size(); j = i++) {
        double xi = poly[i].x, yi = poly[i].y;
        double xj = poly[j].x, yj = poly[j].y;
        if (((yi > py) != (yj > py)) && 
            (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) 
            inside = !inside;
    }
    return inside;
}

int main() {
    int n;
    cin >> n;
    vector<Point> poly(n);
    double xmin = 1e18, xmax = -1e18, ymin = 1e18, ymax = -1e18;
    for (auto& p : poly) {
        cin >> p.x >> p.y;
        xmin = min(xmin, p.x);
        xmax = max(xmax, p.x);
        ymin = min(ymin, p.y);
        ymax = max(ymax, p.y);
    }
    
    int cnt = 0;
    int imin = floor(xmin), imax = ceil(xmax);
    int jmin = floor(ymin), jmax = ceil(ymax);
    
    for (int i = imin; i < imax; ++i) {
        for (int j = jmin; j < jmax; ++j) {
            bool valid = true;
            valid &= isInside(poly, i, j);
            valid &= isInside(poly, i+1, j);
            valid &= isInside(poly, i, j+1);
            valid &= isInside(poly, i+1, j+1);
            if (valid) cnt++;
        }
    }
    cout << cnt << endl;
    return 0;
}
```

---

## 最优思路提炼
1. **包围盒优化**：利用多边形顶点范围大幅减少无效遍历。  
2. **射线法高效判断**：O(n)时间判断点包含，适合竞赛场景。  
3. **并行顶点检查**：同时检查四个顶点，快速过滤无效候选点。  

---

## 相似题目推荐
1. **P1883 矩形覆盖**（计算几何、覆盖问题）  
2. **P2742 圈奶牛**（凸包应用）  
3. **P3829 多边形裁剪**（布尔运算与格点统计）  

---

## 可视化实现思路
**Canvas动画**：  
1. 绘制多边形顶点连线。  
2. 动态遍历网格点，以8位像素风格显示当前检查的正方形。  
3. **音效反馈**：成功时播放短促音效，失败时低沉音效。  
4. **速度控制**：滑动条调整遍历速度，观察算法执行过程。  

**复古像素风格**：  
- 使用16色调色板，绿色表示有效点，红色无效。  
- 网格线用浅灰色，多边形边用亮蓝色。  

---

## 总结
本题核心在于高效判断格点是否满足四个顶点在内部的条件。暴力枚举在小数据可行，大数据需结合几何算法优化。理解多边形包含判断与包围盒剪枝是解题关键。

---
处理用时：445.58秒
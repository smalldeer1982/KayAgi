# 题目信息

# 「WHOI-4」ggcd

## 题目背景

如何输入输出 `__int128`：

```cpp
__int128 read() {
  char c = getchar();
  __int128 x = 0;
  bool f = 0;
  for (; !isdigit(c); c = getchar()) f ^= !(c ^ 45);
  for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
  if (f) x = -x;
  return x;
}
void write(__int128 x, char c = '\0') {
  if (x < 0) putchar('-'), x = -x;
  if (x > 9) write(x / 10);
  putchar(x % 10 + '0');
  if (c != '\0') putchar(c);
}
```

## 题目描述

**本题已新增一组样例，请注意查看。**

小 Y 给了你长度为 $n$ 的数组 $y$ 以及一个正整数 $m$，保证 $0\le y_i<m$，请你构造一个同样长为 $n$ 的数组 $x$，使得：

1. $x_i$ 在 `__int128` 范围内；
2. $x_i\bmod m=y_i$；
3. $\gcd(|x_1|,\cdots,|x_n|)\bmod m$ 最大。

注意，$x_i$ **可以为负**，此时 $m\mid (x_i-y_i)$ 且 $0\le y_i<m$。 

## 说明/提示

**数据范围**

**本题采用捆绑测试。**

Subtask 1（$30$ pts）：$m$ 是素数。

Subtask 2（$70$ pts）：无特殊限制。

对于所有数据，保证 $2\le m \le10^9$，$1\le n\le10^6$。

**关于 Special Judge**

对于每个测试点：

如果你输出的格式不正确，你将会获得 $0$ 分。

如果你输出的数中有不在 `__int128` 范围的数，可能导致溢出所以你可能无法获得预期的分数。

如果你的数列 $x$ 不符合题目给定的 $y$，你将会获得 $0$ 分。

如果你的数列 $x$ 不符合你输出的 $g$，你将会获得 $0$ 分。

如果你的 $g$ 不为最大，你将会获得 $0$ 分。

否则你将获得该测试点的所有分数。

## 样例 #1

### 输入

```
1 10
4```

### 输出

```
6
-6```

## 样例 #2

### 输入

```
1 10
7```

### 输出

```
7
7```

## 样例 #3

### 输入

```
2 9
3 3```

### 输出

```
6
12 -6```

## 样例 #4

### 输入

```
10 7
1 2 3 4 5 6 0 1 2 3```

### 输出

```
6
36 30 24 18 12 6 42 -6 30 24```

# AI分析结果



**唯一算法分类**  
数论、构造

---

**综合分析与结论**  
**核心思路**：  
1. 最大可能的 GCD 模 m 值由 `ans = m - g` 决定，其中 `g = gcd(y₁,y₂,...,yₙ,m)`。  
2. 构造数组时，所有元素除一个特例外，均取 `x_i = ans * (-y_i/g)`，确保它们的绝对值为 ans 的倍数。  
3. 对特例元素，通过枚举或随机找 `k'` 使其与其余元素的 GCD 恰好为 ans。  

**难点与解决**：  
- **数学推导**：需证明 `ans = m - g` 是最大值，涉及模运算和 GCD 性质的综合运用。  
- **构造验证**：找到合适的 k' 确保特例元素的加入不影响整体 GCD，需数学保证和高效实现。  

**可视化设计**：  
- **动画流程**：分步展示计算 g、构造基础数组、动态调整特例元素的过程。  
- **高亮步骤**：计算当前 GCD 时高亮数组元素，调整特例时显示 k' 的枚举过程。  
- **复古风格**：8-bit 像素字体，计算步骤伴随电子音效（如 GCD 完成时的“滴”声）。  

---

**题解评分 (4.5⭐)**  
- **思路清晰度**：⭐️⭐️⭐️⭐️（数学推导完整，但构造部分稍复杂）  
- **代码可读性**：⭐️⭐️⭐️（变量命名简略，但逻辑结构清晰）  
- **算法优化**：⭐️⭐️⭐️⭐️（利用数学性质避免暴力枚举）  
- **实践性**：⭐️⭐️⭐️⭐️（适合中等规模数据，时间复杂度 O(n)）  

---

**最优思路提炼**  
1. **核心公式**：`ans = m - gcd(y₁,...,yₙ,m)`，利用模运算的周期性最大化 GCD。  
2. **构造技巧**：通过调整一个元素的系数打破原有 GCD 约束，确保全局最优。  
3. **数学工具**：`gcd(a, b) = gcd(a - kb, b)` 的变形式应用。  

---

**同类型题与套路**  
- **通用解法**：在模约束下构造极值时，优先考虑模数的因数分解与 GCD 性质。  
- **类似题**：求数组元素加减模数后的最大公约数、模意义下的线性组合构造。  

**推荐题目**  
1. [P2447 [SDOI2010] 外星千足虫](https://www.luogu.com.cn/problem/P2447)（模方程构造）  
2. [P1072 Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)（多约束 GCD 极值）  
3. [CF1458D Flip and Reverse](https://codeforces.com/problemset/problem/1458/D)（构造与模运算结合）  

---

**个人心得摘录**  
- **调试关键**：初始构造时未考虑所有元素为 0 的情况，导致 WA。  
- **顿悟点**：意识到 `gcd(y_i, m)` 的联合作用后，构造方向豁然开朗。  

---

**代码核心逻辑**  
```cpp
int g = m, ans;
for (int i = 0; i < n; ++i) 
    g = __gcd(g, y[i]);
ans = m - g;

// 构造非特例元素
for (int i = 0; i < n; ++i) {
    if (i != p) 
        x[i] = -ans * (y[i] / g);
}

// 寻找特例元素的 k'
int k_prime = 1;
while (true) {
    int candidate = (k_prime * ans - y[p]) / g;
    if (__gcd(current_gcd, candidate) == 1) 
        break;
    k_prime++;
}
x[p] = candidate * m + y[p];
```

---

**复古游戏化动画设计**  
- **像素风格**：绿色终端字体，数组元素以方格展示，当前操作元素闪烁红光。  
- **音效触发**：  
  - 计算 GCD：短促“哔”声。  
  - 找到 k'：胜利旋律片段。  
- **AI 演示**：自动逐步展示构造过程，用户可暂停观察变量值。  
- **关卡设计**：分步解锁“计算 g”、“构造数组”、“验证答案”三关，每关完成获得积分。

---
处理用时：79.39秒
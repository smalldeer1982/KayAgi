# 题目信息

# [入门赛 #9] 最澄澈的空与海 (Hard Version)

## 题目背景

材料 1：

> 请小心地计算下面的算式：$138 - 108 \div 6 = ?$  
> 你大概难以置信，这个算式的计算结果竟然是 $5!$

材料 2：

> 对于一个正整数 $x$，$x! = 1 \times 2 \times \cdots \times (x - 1) \times x$。我们称 $x!$ 为 $x$ 的阶乘。  
> 特别的，$0! = 1$。

显然，「$138 - 108 \div 6 = 5$」是错误的，而「$(138 - 108) \div 6 = 5$」是正确的，所以对材料 1 中的内容，部分读者会认为「作者没有搞清加减乘除的运算优先级关系而犯错」。

然而，材料 1 最后一行的叹号并不是标点符号，而是材料 2 提到的「阶乘」。

考虑到这一点，「$138 - 108 \div 6 = 5! = 1 \times 2 \times \cdots \times 5 = 120$」显然就是正确的了。

## 题目描述

然而，此题可能与上面的题目背景关系不是很大。

我们会给你 $T$ 组数据，每组数据包括一个正整数 $n$。

对于每组数据，请你帮助求出满足以下条件的整数三元组 $(x, y, z)$ 的组数：

1. $x \geq 0$，$z \geq 1$。
2. $x - y \div z = n!$ 且 $(x - y) \div z = \dfrac{n!}{n}$。

由于答案可能过大，因此你需要输出答案对 $998244353$ 取模后的结果。

不难注意到答案有可能为 $\infty$，这时请按照「输出格式」要求进行处理。

**请注意此处应满足 $(x - y) \div z = \dfrac{n!}{n}$ 而不是 $= n$。**

请注意这里的 $\div$ 不是向下取整的整除，这显然意味着你需要保证 $y \div z$ 和 $(x - y) \div z$ 为整数。

## 说明/提示

### 样例 1 解释

样例中的具体三元组如下：

| $n$ | 所有可能的三元组 |
| :----------: | :----------: |
| $2$ | $(2, 0, 2)$ |
| $3$ | $\begin{matrix}(8, 4, 2) & (5, -5, 5) & (6, 0, 3)\end{matrix}$ |
| $4$ | $\begin{matrix}(19, -95, 19) & (21, -21, 7) & (24, 0, 4) \\ (27, 9, 3) & (20, -40, 10) & (36, 24, 2)\end{matrix}$ |

### 数据规模与约定

对于前 $20\%$ 的数据，保证 $T \leq 10$，$n \leq 10$。

对于前 $40\%$ 的数据，保证 $n \leq 10 ^ 3$。

对于另外 $20\%$ 的数据，保证 $T = 1$。

对于 $100\%$ 的数据，保证 $1 \leq T \leq 10 ^ 5$，$1 \leq n \leq 10 ^ 6$。

## 样例 #1

### 输入

```
3
2
3
4```

### 输出

```
1
3
6```

# AI分析结果



# 最澄澈的空与海 (Hard Version) 题解分析

## 算法分类
**数论算法（质因数分解、约数个数计算）**

---

## 题解思路与核心难点

### 核心推导
通过方程相减得到关系式：  
$x = \frac{(n-1)(n-1)! \cdot z}{z-1}$  
要求 $z-1$ 必须是 $(n-1)(n-1)!$ 的因数，转化为求其因数个数问题。

### 解决难点
1. **大规模阶乘的质因数分解**  
   无法直接计算 $10^6!$ 的质因数分解，需采用线性筛预处理每个数的最小质因数  
2. **动态维护因数个数**  
   使用动态维护的哈希表记录质因数出现次数，每次阶乘增长时增量更新

---

## 4星及以上题解列表

### 1. Maxmilite（5星）
**亮点**：  
- 完整推导引理，给出充要条件证明  
- 使用线性筛预处理+动态维护乘积模数  
- 处理特殊情况 $n=1$ 的无穷解  

**关键代码**：
```cpp
void init() {
    // 线性筛记录最小质因数
    for(int i=2; i<=1e6; i++){
        if(!p[i]) prime[++cnt]=i, p[i]=i;
        for(int j=1; j<=cnt && i*prime[j]<=1e6; j++){
            p[i*prime[j]] = prime[j];
            if(i%prime[j]==0) break;
        }
    }
    // 动态维护质因数乘积
    lint cur = 1;
    for(int i=1; i<=1e6; i++){
        // 分解i的质因数并更新
        for(auto p : factors[i]){
            cur = (cur * inv(f[p] + 1)) % MOD;
            f[p] += cnt;
            cur = (cur * (f[p] + 1)) % MOD;
        }
        ans[i] = cur;
    }
}
```

### 2. __ryp__（4.5星）
**亮点**：  
- 离线处理所有询问，排序后递增计算  
- 使用vector存储质因数分解结果，内存更优  
- 逆元线性预处理提升效率

### 3. Empty_Dream（4星）
**亮点**：  
- 代码结构清晰，关键步骤注释详细  
- 使用pair存储质因数分解结果，便于操作  
- 预处理逆元数组优化除法运算

---

## 最优思路提炼

### 关键技巧
1. **线性筛预处理最小质因数**  
   每个合数仅被最小质因数标记，分解时递归除以最小质因数，复杂度降至 $O(\log n)$
2. **动态维护乘积公式**  
   维护全局答案变量 `ans`，每次分解数时：  
   - 先除旧贡献 `ans /= (cnt+1)`  
   - 更新质因数计数 `cnt += delta`  
   - 乘新贡献 `ans *= (cnt+1)`  
3. **逆元优化模除运算**  
   预处理 $1 \sim 10^6$ 的逆元，将除法转为乘法

---

## 同类型题与算法套路

### 通用解法
1. **阶乘相关质因数分解**：  
   利用线性筛预处理每个数的最小质因数，动态维护阶乘的质因数统计
2. **大数因数个数计算**：  
   转化为质因数分解后的指数乘积问题

---

## 相似题目推荐
1. **P1495 曹冲养猪**  
   （中国剩余定理，同余方程组）
2. **P2043 质因数分解**  
   （阶乘的质因数统计）
3. **P2424 约数和**  
   （约数性质与分块优化）

---

## 可视化设计

### 算法动画方案
**核心流程**：  
1. **质因数分解过程**  
   - 网格显示当前数 $i$ 的质因数分解（如 $6=2×3$）  
   - 高亮正在分解的质因数（红色闪烁）  
2. **质因数统计面板**  
   - 右侧表格实时显示各质数的当前指数  
   - 更新时用绿色箭头指示增减  
3. **乘积公式变化**  
   - 底部公式动态显示 $(α_1+1)(α_2+1)...$ 的计算过程

### 复古游戏化设计
1. **像素风格**：  
   - 使用16色调色板，质因数显示为不同颜色方块  
   - 分解动画模仿《俄罗斯方块》的下落效果
2. **音效设计**：  
   - 分解成功：8-bit "ping" 音  
   - 更新答案：上升音阶  
   - 错误操作：低沉嗡鸣
3. **自动演示模式**：  
   - 按空格键切换手动/自动模式  
   - 自动模式下算法步骤以0.5秒间隔执行

---

## 关键代码片段（JS动画）

```javascript
// Canvas绘制质因数方块
function drawPrimeGrid(primes) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  primes.forEach((p, i) => {
    const x = (i % 10) * 32;
    const y = Math.floor(i / 10) * 32;
    ctx.fillStyle = getColor(p); // 根据质数映射颜色
    ctx.fillRect(x, y, 30, 30);
    ctx.fillStyle = "white";
    ctx.fillText(p, x + 8, y + 20);
  });
}

// 自动演示逻辑
function autoPlay() {
  let step = 0;
  const timer = setInterval(() => {
    if (step >= maxSteps) clearInterval(timer);
    decomposeNumber(step++);
    playSound('blip'); // 播放分解音效
  }, 500);
}
```

---

## 总结
本题通过巧妙的数学推导将复杂的三元组计数转化为约数个数问题，结合线性筛和动态维护技巧高效处理大规模数据。掌握质因数分解的优化方法及动态乘积维护模式是解决此类问题的关键。

---
处理用时：69.63秒
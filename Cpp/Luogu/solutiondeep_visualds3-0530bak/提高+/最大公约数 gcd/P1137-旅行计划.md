# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果



# 算法分类  
拓扑排序 + 动态规划

---

## 综合分析与结论  
### 核心思路  
所有城市构成有向无环图（DAG），通过拓扑排序确定处理顺序，用动态规划维护以每个节点为终点的最长路径长度。关键点在于：  
1. **拓扑序保证无后效性**：处理节点时所有前驱节点已被计算  
2. **DP转移方程**：`dp[v] = max(dp[v], dp[u] + 1)`（u→v的边）  
3. **反向建图优化**：部分题解通过反向建图+记忆化搜索避免显式拓扑排序  

### 可视化设计要点  
1. **动态拓扑排序**：  
   - 红框高亮当前处理的入度0节点  
   - 灰色箭头表示被移除的边，显示后继节点入度减少过程  
   - 队列面板展示待处理节点（8位像素风格）  
2. **DP更新动画**：  
   - 绿色数字实时更新每个节点的DP值  
   - 黄色连线强调当前被激活的转移路径（u→v）  
3. **复古交互**：  
   - 像素音效：节点入队时播放"哔"声，DP更新时播放"叮"声  
   - 自动演示模式下，算法以每秒2步的速度推进，可随时暂停单步调试  

---

## 高星题解清单（≥4★）  
### 1. 星星之火（5★）  
**亮点**：  
- 详细解释拓扑排序与DP的结合原理  
- 代码结构清晰（分离拓扑排序与DP阶段）  
- 关键注释说明入度数组`ru`和拓扑序列`ts`的作用  

**核心代码段**：  
```cpp
void topsort() {
    queue<int> q;
    for (int i=1;i<=n;i++) if (ru[i]==0) q.push(i);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        ts[++tot] = u; // 记录拓扑序
        for (int i=head[u];i;i=edge[i].next) {
            int v = edge[i].to;
            if (--ru[v] == 0) q.push(v);
        }
    }
}
// DP阶段
for (int i=1;i<=n;i++) {
    int u=ts[i]; 
    for (int j=head[u];j;j=edge[j].next) 
        dp[edge[j].to] = max(dp[edge[j].to], dp[u]+1);
}
```

### 2. _ZZH（4.5★）  
**亮点**：  
- 拓扑排序与DP合并执行（节省内存）  
- 极简代码（仅26行核心逻辑）  
- 队列直接存储待处理节点，省略显式拓扑序列  

**核心技巧**：  
```cpp
while (!q.empty()) {
    int cnt = q.front(); q.pop();
    for (int i=lin[cnt];i;i=e[i].next) {
        f[e[i].to] = max(f[e[i].to], f[cnt]+1); // 实时更新
        if (--in[e[i].to] == 0) q.push(e[i].to);    
    }	
}
```

### 3. 归山_（4★）  
**亮点**：  
- 反向建图 + 记忆化搜索  
- 避免显式拓扑排序，适合不熟悉拓扑的选手  
- 代码结构简单易懂  

**核心递归逻辑**：  
```cpp
int dfs(int x) {
    if (dp[x] != -1) return dp[x];
    dp[x] = 1;
    for (int i=head[x];i;i=e[i].next) 
        dp[x] = max(dp[x], dfs(e[i].to)+1);
    return dp[x];
}
// 调用方式
add(y,x); // 反向建图
for (int i=1;i<=n;i++) cout << dfs(i) << endl;
```

---

## 最优技巧提炼  
1. **拓扑序DP的无后效性保证**  
   - 关键：所有前驱节点在拓扑序列中必定位于当前节点之前  
   - 实现：使用队列维护入度0节点，逐步生成拓扑序列  

2. **状态转移优化**  
   - 反向建图可将终点i的最长路转化为求起点i的最长路  
   - 记忆化搜索自动处理依赖关系，无需显式拓扑排序  

3. **空间压缩技巧**  
   - 部分题解省略显式拓扑数组，直接在拓扑排序过程中更新DP值  

---

## 相似题目推荐  
1. P1113 杂务（DAG最长路模板）  
2. P4017 最大食物链计数（拓扑排序+DP计数）  
3. P1807 最长路（带权DAG的最长路径）

---

## 可视化核心代码（JS伪代码）  
```javascript
class Visualizer {
  constructor(graph) {
    this.nodes = graph.nodes.map(n => ({id: n, dp: 1, indeg: n.indeg}));
    this.queue = new PixelQueue(200, 50); // 8-bit风格队列面板
    this.playSound('startup'); // 启动音效
  }

  step() {
    let u = this.queue.dequeue();
    highlight(u, 'red'); // 红框高亮当前节点
    graph.edges[u].forEach(v => {
      this.nodes[v].indeg--;
      animateEdgeRemoval(u, v); // 灰色动画移除边
      if (this.nodes[v].indeg === 0) {
        this.queue.enqueue(v);
        playSound('enqueue'); 
      }
      if (this.nodes[v].dp < this.nodes[u].dp + 1) {
        this.nodes[v].dp = this.nodes[u].dp + 1;
        highlight(v, 'green'); // 绿闪更新DP值
        playSound('update');
      }
    });
  }
}
```

---

## 调试心得摘录  
> **Space_Gold_Trash**：  
> 最初错误地从固定起点1出发，忽略了多起点情况。通过增加`ok[]`数组标记所有入度0节点作为起点解决。  
> **关键教训**：DAG可能存在多个无前驱的起点，需全部考虑  

> **zyx10**：  
> 误将拓扑深度直接作为答案，实际上深度需通过DP累加。修正为`dis[v] = dis[u] + 1`后AC  
> **调试技巧**：在队列处理时打印中间结果验证逻辑  

---

通过拓扑序的层级推进与DP的实时更新，该问题完美展现了DAG上动态规划的经典模式。结合8位像素动画的音画反馈，可帮助学习者直观理解拓扑排序与状态转移的协同工作机制。

---
处理用时：71.88秒
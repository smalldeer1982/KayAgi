# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果



# 填涂颜色 - 题解分析

## 算法分类
BFS/DFS（图的遍历）

---

## 核心思路与难点突破

### 通用解法思路
所有题解都采用逆向思维：**将闭合圈外的0染色标记，剩余的0即为圈内目标**。关键实现步骤：
1. 预处理：在矩阵外围添加虚拟边界（0值）
2. 从虚拟边界开始广度/深度优先搜索
3. 将连通区域标记为特殊值（如2）
4. 输出时还原边界，并将未标记的0转换为2

### 核心难点对比
| 题解方案 | 边界处理 | 数据结构 | 染色方式 |
|---------|---------|---------|---------|
| LMB_001 | 直接遍历真实边界 | DFS递归 | 双数组存储原始数据 |
| 冰冻赤道 | 四边独立遍历 | BFS队列 | 布尔标记数组 |
| zhy137036 | 扩展虚拟边界 | BFS队列 | 单数组染色覆盖 |

---

## 优质题解推荐（≥4星）

1. **zhy137036（★★★★★）**
   - **亮点**：扩展矩阵边界消除特判，代码最简洁（仅20行）
   - **技巧**：通过 `2 - a[i][j]` 实现输出时反色
   ```cpp
   void search(int x, int y) {
       if(x<0||x>n+1||y<0||y>n+1||a[x][y]) return;
       a[x][y] = 1;
       for(int i=0; i<4; i++) search(x+dx[i], y+dy[i]);
   }
   ```

2. **LMB_001（★★★★☆）**
   - **亮点**：双数组设计逻辑清晰，DFS实现直观
   - **心得**：通过保存原始数据避免污染输入
   ```cpp
   void dfs(int p,int q){
       if (p<0||p>n+1||q<0||q>n+1||a[p][q]!=0) return;
       a[p][q] = 1;
       for (int i=1;i<=4;i++) dfs(p+dx[i],q+dy[i]);
   }
   ```

3. **歌者siner（★★★★☆）**
   - **亮点**：四次边界扫描保证覆盖，方向数组优化
   - **调试经验**：通过分层染色解决复杂边界问题
   ```cpp
   for(int i=1;i<=n;i++){
       if(a[1][i]==0) dfs(1,i);
       if(a[i][1]==0) dfs(i,1);
       if(a[n][i]==0) dfs(n,i);
       if(a[i][n]==0) dfs(i,n);
   }
   ```

---

## 最优思路提炼

### 关键技巧
1. **虚拟边界法**：在原始矩阵外包裹一层0，统一处理所有边界情况
2. **逆向染色**：标记所有可到达边界的0，剩余0即为闭合区域
3. **反色输出**：通过数学运算 `2 - val` 实现输出时的数值转换

### 可视化设计
1. **像素动画**：  
   - 初始状态：红色边框包裹原始矩阵  
   - 搜索过程：蓝色波纹从边界扩散，标记外部区域  
   - 最终状态：未被染色的白色区域即为闭合圈  
   ![填涂颜色动画示意图](https://thumbs.gfycat.com/UnhappySkeletalHornedtoad-size_restricted.gif)

2. **复古音效**：
   - 扩散音效：8-bit风格 "滴" 声（每次队列取出元素时触发）
   - 完成音效：经典FC过关旋律

---

## 相似题目推荐
1. [P1506 拯救oibh总部](https://www.luogu.com.cn/problem/P1506) - 相同逆向染色思路
2. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 连通区域标记
3. [P3395 路障](https://www.luogu.com.cn/problem/P3395) - BFS扩展应用

---

## 核心代码实现

```cpp
// 虚拟边界法最优实现
#include <iostream>
using namespace std;

int dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};
int a[35][35], n;

void dfs(int x, int y) {
    if(x<0 || x>n+1 || y<0 || y>n+1 || a[x][y]) return;
    a[x][y] = 2;
    for(int i=0; i<4; i++) dfs(x+dx[i], y+dy[i]);
}

int main() {
    cin >> n;
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++)
            cin >> a[i][j];
    
    dfs(0, 0); // 从虚拟边界开始搜索
    
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=n; j++)
            cout << (a[i][j] == 2 ? 0 : (a[i][j] ? 1 : 2)) << " ";
        cout << "\n";
    }
    return 0;
}
```

---
处理用时：76.31秒
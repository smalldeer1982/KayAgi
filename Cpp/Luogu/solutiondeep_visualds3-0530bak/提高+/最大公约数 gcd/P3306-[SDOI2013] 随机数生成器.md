# 题目信息

# [SDOI2013] 随机数生成器

## 题目背景

小 W 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。

## 题目描述

最近小 W 准备读一本新书，这本书一共有 $p$ 页，页码范围为 $0 \sim p-1$。

小 W 很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用 NOI2012 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。

我们用 $x_i$ 来表示通过这种方法生成出来的第 $i$ 个数，也即小 W 第 $i$ 天会读哪一页。这个方法需要设置 $3$ 个参数 $a,b,x_1$，满足 $0\leq a,b,x_1\lt p$，且 $a,b,x_1$ 都是整数。按照下面的公式生成出来一系列的整数：
$$x_{i+1} \equiv a \times x_i+b \pmod p$$
其中 $\bmod$ 表示取余操作。

但是这种方法可能导致某两天读的页码一样。

小 W 要读这本书的第 $t$ 页，所以他想知道最早在哪一天能读到第 $t$ 页，或者指出他永远不会读到第 $t$ 页。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq T \leq 50$。
- $0 \leq a, b, x_1, t \lt p$，$2 \leq p \leq 10^9$。
- $p$ 为质数。

## 样例 #1

### 输入

```
3
7 1 1 3 3
7 2 2 2 0
7 2 2 2 1
```

### 输出

```
1 
3 
-1```

# AI分析结果



## 算法分类
**BSGS算法（大步小步算法）**

---

## 题解思路与算法要点

### 核心推导
递推式 $x_{i+1} ≡ a·x_i + b \ (\text{mod}\ p)$ 可通过构造等比数列转化为：
$$x_n ≡ a^{n-1}x_1 + \frac{b(1-a^{n-1})}{1-a} \ (\text{mod}\ p)$$
进一步化简为指数方程：
$$a^{n-1} ≡ \frac{t - \frac{b}{1-a}}{x_1 - \frac{b}{1-a}} \ (\text{mod}\ p)$$

### 关键实现步骤
1. **特殊处理**：
   - $a=0$：判断 $t$ 是否为 $b$ 或 $x_1$
   - $a=1$：退化为等差数列，求线性同余方程
2. **BSGS算法**：求解 $a^{k} ≡ c \ (\text{mod}\ p)$ 的最小非负整数解
3. **逆元计算**：分母处理需用费马小定理求模逆元

### 解决难点
- **等比数列构造**：通过引入常数项消除线性递推中的加法干扰
- **逆元有效性**：需保证 $x_1 - \frac{b}{1-a} \not\equiv 0 \ (\text{mod}\ p)$
- **BSGS边界条件**：处理哈希碰撞和分块大小的选择

---

## 高星题解推荐（≥4星）

### 1. ChenZ01（⭐⭐⭐⭐⭐）
**亮点**：
- 数学推导最完整，覆盖所有特殊情况
- 代码逻辑清晰，包含详细注释
- 使用 `map` 实现哈希表，代码简洁
**核心代码**：
```cpp
long long bsgs(long long a, long long b, int MOD) {
    std::map<long, long> map;
    long long m = ceil(sqrt(MOD)), t = 1;
    // 预计算哈希表（小步）
    for (int i = 0; i < m; ++i) {
        map[t] = i;
        t = t * a % MOD;
    }
    // 大步跳跃
    long long k = inv(t, MOD), w = b;
    for (int i = 0; i < m; ++i) {
        if (map.count(w))
            return i * m + map[w];
        w = w * k % MOD;
    }
    return -1;
}
```

### 2. wwyx2001（⭐⭐⭐⭐）
**亮点**：
- 最优代码长度，手写哈希表优化性能
- 突出等比数列构造的核心思想
- 处理逆元时的边界条件处理严谨
**核心代码**：
```cpp
ll BSGS(ll A, ll B, ll C) {
    if (A % C == 0) return -2;
    ll m = ceil(sqrt(C));
    // 哈希表存储小步结果
    for (int i = 0; i <= m; i++) {
        ans = (ans * A) % C;
        mp[ans] = i;
    }
    // 大步跳跃
    ll t = pow(A, m, C), res = t;
    for (int i = 1; i <= m; i++) {
        if (mp.count(res)) 
            return i * m - mp[res];
        res = res * t % C;
    }
}
```

### 3. HoshiuZ（⭐⭐⭐⭐）
**亮点**：
- 分类讨论最细致，代码鲁棒性强
- 显式处理所有可能的除零错误
- 使用 `unordered_map` 实现哈希表
**核心代码**：
```cpp
ll BSGS(ll a, ll b, ll p) {
    if (b == 1) return 0;
    ll m = ceil(sqrt(p)), tmp = b;
    // 预计算哈希表
    for (int j = 1; j <= m; j++) {
        tmp = tmp * a % p;
        vh[tmp] = j;
    }
    // 大步跳跃
    ll t = pow(a, m, p), res = 1;
    for (int i = 1; i <= m; i++) {
        res = res * t % p;
        if (vh.count(res))
            return (i * m - vh[res]) % p;
    }
}
```

---

## 最优思路提炼
1. **构造等比数列**：引入 $k = \frac{b}{a-1}$ 将线性递推转换为等比数列
2. **逆元处理**：使用费马小定理求分母的模逆元，避免除零错误
3. **BSGS分块优化**：通过 $\sqrt{p}$ 分块将时间复杂度降至 $O(\sqrt{p})$
4. **特殊处理**：对 $a=0$ 和 $a=1$ 的独立分支处理保证算法鲁棒性

---

## 同类问题推荐
1. [P3846 可爱的质数](https://www.luogu.com.cn/problem/P3846)（BSGS 模板题）
2. [P2485 计算器](https://www.luogu.com.cn/problem/P2485)（综合运用快速幂、扩展欧几里得、BSGS）
3. [P3306 随机数生成器](https://www.luogu.com.cn/problem/P3306)（本题的双倍经验题）

---

## 可视化与算法演示

### 动画方案设计
1. **递推式转换**：
   - 初始项 $x_1$ 显示为像素方块，颜色标记为蓝色
   - 每一步计算 $x_{i+1}$ 时，用红色箭头展示 $a·x_i + b$ 的过程
2. **BSGS 分块**：
   - 哈希表插入时，用绿色方块表示小步预计算
   - 大步跳跃时，用黄色方块标记当前检查的位置
3. **音效设计**：
   - 哈希命中时播放8-bit成功音效（频率上升）
   - 无解时播放低音失败音效

### 复古像素风格实现
```javascript
// Canvas绘制示例（关键片段）
function drawStep(ctx, x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 10, y * 10, 8, 8); // 8x8像素方块
}

// BSGS动画主循环
function animateBSGS() {
    // 小步预计算（绿色方块）
    for (let i = 0; i < m; i++) {
        drawStep(ctx, i, 0, '#00FF00');
        playSound(500 + i * 50); // 音调逐渐升高
    }
    // 大步跳跃（黄色方块）
    for (let i = 0; i < m; i++) {
        drawStep(ctx, i, 1, '#FFFF00');
        if (hashTable.has(res)) {
            playSuccessSound();
            break;
        }
    }
}
```

---

## 个人心得摘录
> **ChenZ01**：  
> “逆元处理必须用 `(x % p + p) % p` 保证非负，否则BSGS会WA到怀疑人生”  
> **HoshiuZ**：  
> “特判a=1时，如果b=0要直接返回-1，否则会被除零错误卡死”  
> **qwaszx**：  
> “用unordered_map比手写哈希表慢一倍，但代码可读性更好，适合快速验证思路”  

---

## 核心算法代码（完整）
```cpp
#include <iostream>
#include <cmath>
#include <unordered_map>
using namespace std;
typedef long long ll;

ll qpow(ll a, ll b, ll p) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

ll bsgs(ll a, ll b, ll p) {
    if (b == 1) return 0;
    unordered_map<ll, ll> hash;
    ll m = ceil(sqrt(p)), t = 1;
    for (ll i = 0; i < m; ++i) {
        hash[t] = i;
        t = t * a % p;
    }
    ll inv_a = qpow(t, p-2, p), cur = b;
    for (ll i = 0; i <= m; ++i) {
        if (hash.count(cur)) 
            return i * m + hash[cur];
        cur = cur * inv_a % p;
    }
    return -1;
}

int main() {
    int T; cin >> T;
    while (T--) {
        ll p, a, b, x1, t;
        cin >> p >> a >> b >> x1 >> t;
        if (x1 == t) { cout << "1\n"; continue; }
        if (a == 0) {
            cout << (b == t ? "2\n" : "-1\n");
            continue;
        }
        if (a == 1) {
            ll delta = (t - x1 + p) % p;
            if (b == 0) cout << "-1\n";
            else {
                ll ans = delta * qpow(b, p-2, p) % p;
                cout << ans + 1 << '\n';
            }
            continue;
        }
        ll k = b * qpow(a-1, p-2, p) % p;
        ll numerator = (t + k) % p;
        ll denominator = (x1 + k) % p;
        if (denominator == 0) { cout << "-1\n"; continue; }
        ll c = numerator * qpow(denominator, p-2, p) % p;
        ll ans = bsgs(a, c, p);
        cout << (ans == -1 ? -1 : ans + 1) << '\n';
    }
    return 0;
}
```

---
处理用时：98.20秒
# 题目信息

# 付公主的矩形

## 题目背景

付公主月考炸了，感到非常郁闷。

## 题目描述

为了排解心中的怒气，她造了大量的稻草人来发泄。每天付公主都会把一些稻草人摆成一个 $ R*C $ 的矩形，矩形的每个方格上都有一个稻草人。然后她站在这个矩形的左上角，向矩形的右下角射箭。付公主的箭术过人，她能穿透任意多的稻草人。弓箭经过的方格上的稻草人难逃厄运，报废掉了。看着被毁坏的稻草人，付公主开心了一些。

但是制造稻草人需要大量的金钱，所以付公主不希望坏掉太多的稻草人，所以她每天都选择毁坏掉 $ N $ 个稻草人。付公主还是个喜新厌旧的人，她希望每天能看到一种不同的稻草人摆放矩形。矩形是可以旋转的，即 $ R\times C $ 和 $ C\times R $ 等价。她毫不费力地算出了摆放方案数，于是她决定刁难你一下。不甘示弱的你决定写个程序计算这个数来提交付公主的答卷。

## 说明/提示

样例解释：
![](https://cdn.luogu.com.cn/upload/pic/16262.png)

对于 $40\%$ 的数据，$1 \le N \le 10^4$。

对于 $100\%$ 的数据，$1 \le N \le 10^6$。


## 样例 #1

### 输入

```
4```

### 输出

```
4```

# AI分析结果



**唯一算法分类**：数论（欧拉函数与因数分解）

---

### 题解思路与核心难点

#### **核心思路**
1. **公式推导**  
   设矩形边长为 \( R \times C \)，对角线穿过方格数为 \( N = R + C - \gcd(R,C) \)。
   - 当 \( R, C \) 互质时，\( N = R + C - 1 \)。
   - 当 \( \gcd(R, C) = d \) 时，将矩形拆分为 \( d \times d \) 个小矩形，每个小矩形边长为 \( (R/d, C/d) \)，此时 \( N = d \cdot (R/d + C/d - 1) \)。

2. **数学转化**  
   令 \( d = \gcd(R, C) \)，则 \( R = d \cdot r \)，\( C = d \cdot c \)，方程变为：
   \[
   N = d \cdot (r + c - 1)
   \]
   其中 \( r, c \) 互质，且 \( r + c - 1 = \frac{N}{d} \)。进一步分析发现解的个数为欧拉函数 \( \varphi(r + c) \)。

3. **最终公式**  
   答案可表示为：
   \[
   \text{ans} = \frac{1}{2} \left( \sum_{d \mid N} \varphi(d+1) + 1 \right)
   \]
   其中 \( d \) 遍历 \( N \) 的所有因数，\( +1 \) 处理对称重复。

#### **解决难点**
- **数学推导**：需将几何问题转化为数论问题，利用互质性质和因数分解。
- **高效计算**：通过线性筛预处理欧拉函数，复杂度 \( O(N) \)，枚举因数仅需 \( O(\sqrt{N}) \)。

---

### 题解评分 (≥4星)

1. **Elegia (★★★★★)**  
   - **亮点**：线性筛法预处理欧拉函数，代码简洁高效，数学推导清晰。
   - **代码**：在筛法中动态处理因数，直接累加答案。

2. **y2823774827y (★★★★☆)**  
   - **优化**：剪枝枚举因数至 \( \sqrt{N} \)，提升速度。
   - **代码**：分两次处理因数对，减少重复计算。

3. **Link_Cut_Y (★★★★☆)**  
   - **实现**：单独筛欧拉函数后枚举因数，结构清晰。
   - **注释**：详细说明对称去重逻辑，易读性强。

---

### 最优思路提炼
1. **关键公式**：\( N = R + C - \gcd(R, C) \)。
2. **因数分解**：枚举 \( N \) 的所有因数 \( d \)，转化为 \( \varphi(d+1) \) 求和。
3. **对称处理**：最终答案 \( (\text{总和} + 1)/2 \)。

---

### 同类算法题推荐
1. **P2303 [SDOI2012] Longge的问题**（因数分解与欧拉函数）
2. **P1447 [NOI2010] 能量采集**（数论求和与欧拉函数应用）
3. **P2527 [SHOI2001] 小约翰的游戏**（互质性质与几何计数）

---

### 可视化设计（像素风格）
#### **动画方案**
1. **网格绘制**：Canvas 绘制 \( R \times C \) 网格，高亮对角线路径。
2. **因数分解**：动态枚举 \( N \) 的因数 \( d \)，显示对应的 \( \varphi(d+1) \) 值。
3. **颜色标记**：
   - **当前因数**：红色高亮。
   - **欧拉值累加**：绿色闪烁。
4. **音效触发**：
   - **枚举成功**：播放 8-bit 上升音效。
   - **计算完成**：播放胜利音效。

#### **交互设计**
- **步进控制**：允许暂停/继续，调整动画速度。
- **自动演示**：AI 模式自动展示因数分解与累加过程。

---

### 核心代码（Elegia 版）
```cpp
#include <cstdio>
using namespace std;
const int N = 1000010;

int n, pc, ans;
bool vis[N];
int p[N], phi[N];

int main() {
    scanf("%d", &n);
    for (int x = 2; x <= n + 1; ++x) {
        if (!vis[x]) {
            p[++pc] = x;
            phi[x] = x - 1;
        }
        if (n % (x - 1) == 0)
            ans += phi[x];
        for (int i = 1; x * p[i] <= n + 1; ++i) {
            vis[x * p[i]] = true;
            if (x % p[i] == 0) {
                phi[x * p[i]] = phi[x] * p[i];
                break;
            } else {
                phi[x * p[i]] = phi[x] * phi[p[i]];
            }
        }
    }
    printf("%d\n", (ans + 1) / 2);
    return 0;
}
```

---

### 个人心得
- **调试教训**：注意欧拉函数预处理范围应为 \( N+1 \)，避免数组越界。
- **优化技巧**：线性筛法中同时处理因数的判断，减少额外循环。

---
处理用时：71.16秒
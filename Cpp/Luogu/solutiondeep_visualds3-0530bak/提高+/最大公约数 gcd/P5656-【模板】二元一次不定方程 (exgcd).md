# 题目信息

# 【模板】二元一次不定方程 (exgcd)

## 题目描述

给定不定方程

$$ax+by=c$$

若该方程无整数解，输出 $-1$。  
若该方程有整数解，且有正整数解，则输出其**正整数**解的数量，所有**正整数**解中 $x$ 的最小值，所有**正整数**解中 $y$ 的最小值，所有**正整数**解中 $x$ 的最大值，以及所有**正整数**解中 $y$ 的最大值。  
若方程有整数解，但没有正整数解，你需要输出所有**整数解**中 $x$ 的最小正整数值， $y$ 的最小正整数值。

正整数解即为 $x, y$ 均为正整数的解，$\boldsymbol{0}$ **不是正整数**。  
整数解即为 $x,y$ 均为整数的解。  
$x$ 的最小正整数值即所有 $x$ 为正整数的整数解中 $x$ 的最小值，$y$ 同理。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1 \le T \le 2 \times {10}^5$，$1 \le a, b, c \le {10}^9$。

## 样例 #1

### 输入

```
7
2 11 100
3 18 6
192 608 17
19 2 60817
11 45 14
19 19 810
98 76 5432```

### 输出

```
4 6 2 39 8
2 1
-1
1600 1 18 3199 30399
34 3
-1
2 12 7 50 56```

# AI分析结果



## 唯一算法分类  
**扩展欧几里得算法（exgcd）**

---

## 综合分析与结论  
### 核心思路与难点
1. **通解推导**：  
   通过 exgcd 求出方程 $ax+by=\gcd(a,b)$ 的特解后，乘系数得到原方程特解 $x_1,y_1$。通解形式为：  
   $$x = x_1 + s \cdot \frac{b}{\gcd(a,b)}, \quad y = y_1 - s \cdot \frac{a}{\gcd(a,b)}$$  
   **关键变量**：步长 $d_x = \frac{b}{\gcd(a,b)}, d_y = \frac{a}{\gcd(a,b)}$，$s$ 为整数参数。

2. **正整数解判定**：  
   需找到满足 $x>0$ 且 $y>0$ 的 $s$ 范围：  
   $$s_{\text{min}} = \lceil (-x_1 + 1)/d_x \rceil, \quad s_{\text{max}} = \lfloor (y_1 - 1)/d_y \rfloor$$  
   **难点**：边界取整处理（如负数取模、余数为零的特殊情况）。

3. **分情况输出**：  
   - 无整数解：$c \nmid \gcd(a,b)$  
   - 有整数解但无正整数解：计算 $x,y$ 的最小正整数值  
   - 有正整数解：统计解的数量，计算极值

---

## 题解评分与亮点  
### 4星及以上题解  
1. **dengyaotriangle（5星）**  
   **亮点**：  
   - 数学推导严谨，通解形式清晰，参数范围分析透彻  
   - 强调边界条件处理（如 `开long long` 的坑点）  
   **代码建议**：需补充代码实现，但公式可直接转为代码逻辑。

2. **linponess（4.5星）**  
   **亮点**：  
   - 暴力与优化解法对比，模运算直接求极值  
   - 代码高效（利用模运算避免循环，复杂度 $O(1)$）  
   **核心代码片段**：  
   ```cpp
   xin = x>0 && x%b!=0 ? x%b : x%b + b;  // 最小正x
   yax = (c - a*xin)/b;                  // 对应最大y
   ```

3. **小恐（4星）**  
   **亮点**：  
   - 代码简洁，直接通过模运算处理极值  
   - 处理余数为零的特殊情况（如 `x = x%b + b`）  
   **关键逻辑**：  
   ```cpp
   x = (x % b + b) % b;  // 保证x为正
   if (x == 0) x = b;    // 余数为零时修正为模数
   ```

---

## 最优思路与技巧  
### 关键优化与实现技巧  
1. **模运算求极值**：  
   直接通过 `x = x % d_x + d_x` 计算最小正解，避免循环迭代。

2. **通解参数范围公式化**：  
   将 $s$ 的上下界用数学公式表达，避免暴力枚举。

3. **边界条件统一处理**：  
   使用 `(x % d_x + d_x) % d_x` 确保结果为正，再处理余数为零的特殊情况。

---

## 类似题目推荐  
1. **P1082 [NOIP2012 提高组] 同余方程**  
   （exgcd 基础应用，求逆元）

2. **P1516 青蛙的约会**  
   （线性同余方程，参数范围分析）

3. **P2421 [NOI2003] 木琴**  
   （扩展欧几里得与模运算综合应用）

---

## 可视化与算法演示设计  
### 复古像素动画方案  
1. **核心流程**：  
   - **Step 1**：显示 exgcd 递归过程，用像素方块表示参数变化  
   - **Step 2**：高亮通解参数 $s$ 的调整，展示 $x,y$ 随 $s$ 变化的轨迹  
   - **Step 3**：用颜色标记 $s_{\text{min}}$ 和 $s_{\text{max}}$，突出合法范围  

2. **交互设计**：  
   - **控制面板**：滑动条调节 $a,b,c$，实时更新解的范围  
   - **音效**：步进时播放 8-bit 音效，无解时播放失败音效  

3. **Canvas 实现**：  
   ```javascript
   // 绘制通解范围网格示例
   function drawGrid(sMin, sMax) {
     ctx.fillStyle = "#00FF00"; // 合法区域绿色
     ctx.fillRect(sMin * 10, 0, (sMax - sMin) * 10, 50);
   }
   ```

---

## 代码实现（关键逻辑）  
```cpp
// 核心代码：求最小正解与范围判定
void solve() {
    ll a, b, c; cin >> a >> b >> c;
    ll g = gcd(a, b);
    if (c % g != 0) { cout << "-1\n"; return; }

    a /= g; b /= g; c /= g;
    ll x, y;
    exgcd(a, b, x, y);
    x *= c; y *= c;

    // 计算最小正x和对应y
    ll dx = b, dy = a;
    ll x_min = (x % dx + dx) % dx;
    if (x_min == 0) x_min = dx;
    ll y_max = (c - a * x_min) / b;

    if (y_max <= 0) { // 无正整数解
        ll y_min = (y % dy + dy) % dy;
        if (y_min == 0) y_min = dy;
        cout << x_min << " " << y_min << "\n";
    } else { // 有正整数解
        // 类似处理y_min和x_max...
    }
}
```

---

## 个人心得摘录  
- **dengyaotriangle**：  
  > “开 long long 是十年OI一场空的关键...公式推导虽然冗长，但能避免实际编码中的边界错误。”

- **小恐**：  
  > “当余数为零时，必须手动修正为模数值，否则会漏解...模运算的陷阱比想象中多！”

---
处理用时：79.11秒
# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果



# 算法分类
**分层图**

---

# 题解思路与算法分析

## 核心思路对比
| 方法                | 核心思想                                                                 | 时间复杂度 | 空间复杂度 | 解决难点                                                                 |
|---------------------|------------------------------------------------------------------------|------------|------------|--------------------------------------------------------------------------|
| **分层图+SPFA**     | 构建三层图模拟买卖状态，通过边权转移差价（-w买入，+w卖出）                | O(k*3m)   | O(3n+3m)  | 状态转移建模、负权边处理                                                  |
| **Tarjan缩点+DAG DP** | 缩点后维护强连通分量内的最大/最小价格，在DAG上传递最小买入价和最大卖出价   | O(n+m)    | O(n+m)    | 缩点后拓扑序处理、可达性判断                                              |
| **双向SPFA/BFS**    | 正向预处理1→i的最小价格，反向预处理i→n的最大价格，遍历所有点计算最大差价   | O(k*m)    | O(n+m)    | 反向图构建、两次预处理逻辑                                                |

---

# 题解评分（≥4星）

1. **[fy1234567ok] 分层图+SPFA（⭐⭐⭐⭐⭐）**
   - **亮点**：40行极简代码实现分层图，通过三层状态转移完美建模买卖过程
   - **代码**：使用宏定义简化分层节点计算（`t(x,i) = x+i*n`），清晰易懂
   - **可视化关键**：分层图节点颜色区分（蓝/黄/红表示未买/已买/已卖），动态展示SPFA松弛过程

2. **[ctzm] Tarjan缩点+DAG DP（⭐⭐⭐⭐）**
   - **亮点**：稳定线性复杂度，通过反图DFS处理可达性
   - **核心代码**：
     ```cpp
     void dfs(int x){
         vis[x] = 1;
         for(int i:v_[x]) if(!vis[i]) dfs(i);
     }
     // 在缩点后的反图上DFS判断可达性
     ```

3. **[HPXXZYY] 双向SPFA（⭐⭐⭐⭐）**
   - **亮点**：两次SPFA分别处理最小买入价和最大卖出价，代码简洁高效
   - **核心公式**：
     ```cpp
     ans = max(ans, maxv[i] - minv[i]); // 遍历所有可达点求最大差价
     ```

---

# 最优思路提炼

## 分层图关键实现
1. **状态分层**：
   - **Layer 0**：未购买状态（原图）
   - **Layer 1**：已购买未卖出（边权为-当前点价格）
   - **Layer 2**：已卖出（边权为+当前点价格）

2. **边权设计**：
   ```cpp
   // 同一层内部移动（边权0）
   add(u, v, 0);  
   add(u+n, v+n, 0);
   add(u+2n, v+2n, 0);
   
   // 跨层转移
   add(u, u+n, -w[u]); // 买入操作
   add(u+n, u+2n, w[u]); // 卖出操作
   ```

3. **最长路求解**：
   ```cpp
   spfa(1); // 从Layer0的起点开始
   ans = d[3n]; // Layer2的终点
   ```

---

# 可视化设计（分层图）

## 动画演示方案
1. **节点分层布局**：
   - 使用Canvas将节点按层垂直排列（Layer0在上，Layer2在下）
   - **颜色编码**：
     - 未访问节点：灰色
     - Layer0活跃节点：蓝色
     - Layer1活跃节点：黄色
     - Layer2活跃节点：红色

2. **关键步骤高亮**：
   - **松弛操作**：用闪烁红线标记当前更新的边
   - **状态转移**：从Layer0→Layer1时显示价格下降动画，Layer1→Layer2时显示价格上升动画

3. **复古像素风格**：
   ```javascript
   // 8-bit风格参数
   const palette = ["#000000", "#1D2B53", "#7E2553", "#008751", 
                   "#AB5236", "#5F574F", "#C2C3C7", "#FFF1E8"];
   // 节点绘制
   ctx.fillStyle = palette[layer * 2 + 1];
   ctx.fillRect(x*32, y*32, 28, 28); 
   ```

4. **音效设计**：
   - 移动时播放8-bit "blip"音效
   - 发现更优路径时播放上升音阶
   - 到达终点时播放胜利旋律

---

# 相似题目推荐
1. **P2939 [USACO09FEB]Revamping Trails G**（分层图最短路）
2. **P4568 [JLOI2011] 飞行路线**（分层图+免费次数）
3. **P1266 速度限制**（状态转移图）

---

# 代码片段（分层图SPFA核心）
```cpp
void spfa(int s) {
    memset(d, 0xcf, sizeof(d)); // 初始化为-INF
    d[s] = 0;
    queue<int> q{{s}};
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : G[u]) {
            if (d[v] < d[u] + w) { // 最长路松弛
                d[v] = d[u] + w;
                if (!inq[v]) q.push(v), inq[v] = 1;
            }
        }
    }
}
// 建图关键
for (int i=1; i<=n; i++) {
    G[i].emplace_back(i+n, -w[i]);    // Layer0→1
    G[i+n].emplace_back(i+2*n, w[i]); // Layer1→2
}
```

---
处理用时：89.79秒
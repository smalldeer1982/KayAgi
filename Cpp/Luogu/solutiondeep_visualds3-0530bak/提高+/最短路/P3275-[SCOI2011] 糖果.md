# 题目信息

# [SCOI2011] 糖果

## 题目描述

幼儿园里有 $N$ 个小朋友，$\text{lxhgww}$ 老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，$\text{lxhgww}$ 需要满足小朋友们的 $K$ 个要求。幼儿园的糖果总是有限的，$\text{lxhgww}$ 想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。

## 说明/提示

对于 $30\%$ 的数据，保证 $N\leq100$

对于 $100\%$ 的数据，保证 $N\leq100000$

对于所有的数据，保证 $K\leq100000, 1\leq X\leq5, 1\leq A, B\leq N$

---

$\text{upd 2022.7.6}$：新添加 $21$ 组 [Hack 数据](https://www.luogu.com.cn/discuss/454051)。

## 样例 #1

### 输入

```
5 7
1 1 2
2 3 2
4 4 1
3 4 5
5 4 5
2 3 5
4 5 1```

### 输出

```
11```

# AI分析结果



**唯一算法分类**  
图论-差分约束系统与强连通分量缩点

---

### **题解思路与核心难点**
1. **核心思路**：将条件转化为图的边权约束，通过Tarjan缩点处理相等约束，构建DAG后拓扑排序动态规划计算最小糖果数。
2. **解决难点**：
   - **条件转换**：将五种条件转化为边权（如X=2对应边权1的边，X=1对应双向边权0）。
   - **环处理**：缩点后若强连通分量内存在矛盾（如严格大小关系），直接判定无解。
   - **动态规划**：按拓扑序递推每个缩点后的最小糖果数，累加结果时考虑分量大小。

---

### **题解评分 (≥4星)**
1. **Salamander（5星）**  
   - **亮点**：完整实现缩点+拓扑排序，代码清晰，处理边权与矛盾条件严谨。
   - **关键代码**：
     ```cpp
     void Rebuild() {
         for (条件处理) if (同一分量存在矛盾边) return -1;
     }
     ```
2. **御·Dragon（5星）**  
   - **亮点**：详细注释条件转换与缩点逻辑，代码可读性强，包含调试心得。
   - **关键代码**：
     ```cpp
     switch(x) { // 处理五种条件，建立对应边
         case 1: add双向边; break;
         case 2: add单向边权1; break;
     }
     ```
3. **FlashHu（4星）**  
   - **亮点**：引入虚点确保初始糖果数≥1，代码简洁但部分实现略隐晦。
   - **关键代码**：
     ```cpp
     add(0, i, 1); // 虚点连所有点，保证初始值为1
     ```

---

### **最优思路提炼**
1. **缩点优化**：将相等约束（X=1/3/5）通过Tarjan缩为强连通分量，确保内部值相等。
2. **拓扑排序DP**：在DAG上按拓扑序递推，用`candy[i] = max(candy[i], prev + edge_weight)`更新最小值。
3. **矛盾检测**：若缩点后同一分量内存在边权1的边（严格大小），直接判定无解。

---

### **同类型题与算法套路**
- **类似题目**：奖金（差分约束）、车站分级（拓扑排序+缩点）
- **通用解法**：将约束转化为图论模型，缩点处理强连通分量，拓扑排序动态规划。

---

### **推荐题目**
1. **P1993 小K的农场**（差分约束基础）
2. **P3275 [SCOI2011]糖果**（本题）
3. **P1262 间谍网络**（强连通分量+拓扑排序）

---

### **可视化设计**
1. **动画流程**：
   - **步骤1**：展示原始图，不同颜色标记五种条件对应的边。
   - **步骤2**：Tarjan缩点，强连通分量合并为单一节点（像素风格方块）。
   - **步骤3**：构建DAG，高亮拓扑排序过程，动态更新`candy`值。
   - **步骤4**：若检测到矛盾（自环或环），播放失败音效并红色闪烁。
2. **复古风格**：
   - **颜色方案**：8位色（绿边=相等，红边=严格大小）。
   - **音效**：成功时8-bit胜利音效，失败时短促“错误”音效。
3. **交互功能**：支持暂停/继续，调整动画速度，单步执行观察缩点与拓扑。

---

### **代码片段（关键逻辑）**
```cpp
// Tarjan缩点处理相等约束
void tarjan(int u) {
    low[u] = dfn[u] = ++idx;
    stk[++top] = u; vis[u] = 1;
    for (auto &e : edges[u]) {
        if (!dfn[e.v]) tarjan(e.v), low[u] = min(low[u], low[e.v]);
        else if (vis[e.v]) low[u] = min(low[u], dfn[e.v]);
    }
    if (low[u] == dfn[u]) {
        int v; ++scc_cnt;
        do {
            v = stk[top--]; vis[v] = 0;
            scc[v] = scc_cnt;
        } while (v != u);
    }
}

// 拓扑排序动态规划
void topsort() {
    queue<int> q;
    for (int i = 1; i <= scc_cnt; ++i) 
        if (!in[i]) q.push(i), dp[i] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        ans += dp[u] * size[u];
        for (auto &e : dag[u]) {
            dp[e.v] = max(dp[e.v], dp[u] + e.w);
            if (--in[e.v] == 0) q.push(e.v);
        }
    }
}
```

---

### **总结**
本题通过缩点与拓扑排序将复杂约束转化为线性可解问题，结合动态规划确保最优解。可视化设计通过复古像素风格与交互式演示，直观展现算法核心步骤，适合教学与自学。

---
处理用时：112.61秒
# 题目信息

# [CTSC2000] 冰原探险

## 题目描述

传说中，南极有一片广阔的冰原，在冰原下藏有史前文明的遗址。整个冰原被横竖划分成了很多个大小相等的方格。在这个冰原上有 $N$ 个大小不等的矩形冰山，这些巨大的冰山有着和南极一样古老的历史。

每个矩形冰山至少占据一个方格，且其必定完整地占据方格。冰山和冰山之间不会重叠，也不会有边或点相连。以下两种情况均是不可能出现的：

![](https://cdn.luogu.com.cn/upload/pic/5096.png)

$\text{ACM}$ 探险队在经过多年准备之后决定在这个冰原上寻找遗址。根据他们掌握的资料，在这个冰原上一个大小为一格的深洞中，藏有一个由史前人类制作的开关。而唯一可以打开这个开关的是一个占据接近一格的可移动的小冰块。显然，在南极是不可能有这样小的独立冰块的，所以这块冰块也一定是史前文明的产物。他们在想办法把这个冰块推到洞里去，这样就可以打开一条通往冰原底部的通道，发掘史前文明的秘密。冰块的起始位置与深洞的位置均不和任何冰山相邻。

这个冰原上的冰面和冰山都是完全光滑的，轻轻的推动冰块就可以使这个冰块向前滑行，直到撞到一座冰山就在它的边上停下来。冰块可以穿过冰面上所有没有冰山的区域，也可以从两座冰山之间穿过（见下图）。冰块只能沿网格方向推动。


 ![](https://cdn.luogu.com.cn/upload/pic/5097.png) 

请你帮助他们以最少的推动次数将冰块推入深洞中。


## 说明/提示

$1 \leq N \leq 4000$

样例解释：移动方案如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/y6sx7ya7.png)

## 样例 #1

### 输入

```
2
1 1
5 5
1 3 3 3
6 2 8 4```

### 输出

```
3```

# AI分析结果



### 唯一算法分类
**BFS**

---

### 综合分析与结论
#### 核心算法流程
1. **状态跳跃式移动**  
   每次 BFS 扩展时，直接计算四个方向能到达的最远位置（即碰撞冰山后的停止点），而非逐格移动。关键变量为四个方向的极值（`rt[1]~rt[4]` 或 `d[0]~d[3]`），通过枚举所有冰山更新这些极值。
2. **终点直接判断**  
   在每次移动前，检查当前点与终点是否在同一直线且中间无冰山阻挡，若满足则直接返回当前步数+1。
3. **状态存储优化**  
   使用 `map<pair<int, int>, int>` 记录每个位置的访问步数，避免重复扩展。

#### 解决难点
- **坐标范围极大**：通过极值计算实现跳跃式移动，避免逐格遍历。
- **终点判断优化**：利用极值快速判断是否能直达终点。
- **负坐标处理**：部分题解因未初始化极小值导致错误，需注意初始值范围。

---

### 题解评分 (≥4星)
#### 1. EternalHeart1314 (⭐⭐⭐⭐⭐)
- **亮点**：  
  代码紧凑，使用位运算优化极值初始化 (`d[i] = (-(i & 1) ^ -INF) + (i & 1)`)；通过 `map<int, map<int, int>>` 实现高效状态存储。
- **核心代码**：
  ```cpp
  for(int i = 1; i <= n; ++i) {
      if(x1[i] <= x && x <= x2[i]) {
          if(y2[i] < y) d[0] = max(d[0], y2[i] + 1);
          if(y1[i] > y) d[1] = min(d[1], y1[i] - 1);
      }
      if(y1[i] <= y && y <= y2[i]) {
          if(x2[i] < x) d[2] = max(d[2], x2[i] + 1);
          if(x1[i] > x) d[3] = min(d[3], x1[i] - 1);
      }
  }
  ```

#### 2. Juan_feng (⭐⭐⭐⭐)
- **亮点**：  
  详细注释说明极值初始化问题；结构体 `hz` 重载运算符用于 `map` 键值；处理直接到达终点的逻辑清晰。
- **个人心得**：  
  > “maxx的初始全设成的0......考场上就栽在负数上面了”

#### 3. FallingFYC_ (⭐⭐⭐⭐)
- **亮点**：  
  将深洞视为特殊冰山，简化终点判断逻辑；代码中直接处理坐标对称性，减少边界条件判断。

---

### 最优思路与技巧提炼
#### 关键优化点
1. **极值枚举法**  
   对每个方向，遍历所有冰山更新最近碰撞点。例如，向右移动时，寻找所有在右侧且与当前行相交的冰山，取最小 `y1[i]-1`。
2. **状态压缩存储**  
   使用 `pair<int, int>` 或结构体作为 `map` 键值，存储位置坐标，避免重复扩展。
3. **终点快速判断**  
   在同一直线时，检查极值是否允许直接到达终点，例如：若向右移动，判断当前点 `y` 与终点 `yz` 是否满足 `rt[1] < yz < yy`。

#### 代码片段
```cpp
// EternalHeart1314 的核心方向计算
for(int i = 1; i <= n; ++i) {
    if(x1[i] <= x && x <= x2[i]) {
        if(y2[i] < y) d[0] = max(d[0], y2[i] + 1);
        if(y1[i] > y) d[1] = min(d[1], y1[i] - 1);
    }
    if(y1[i] <= y && y <= y2[i]) {
        if(x2[i] < x) d[2] = max(d[2], x2[i] + 1);
        if(x1[i] > x) d[3] = min(d[3], x1[i] - 1);
    }
}
```

---

### 同类型题与推荐
#### 类似题目
1. **P1126 机器人搬重物**  
   跳跃式 BFS，处理网格中的移动碰撞。
2. **P1443 马的遍历**  
   经典 BFS，但需处理马的跳跃移动。
3. **P3956 棋盘**  
   带状态变化的 BFS，需记录颜色和魔法使用。

---

### 可视化与算法演示
#### 动画设计
1. **网格绘制**  
   - 使用 Canvas 绘制冰原网格，冰山用蓝色填充，起点/终点用绿/红色标记。
2. **移动高亮**  
   - 当前冰块位置用黄色方块表示，移动路径用半透明线条显示。
3. **碰撞检测**  
   - 每次推动时，高亮当前方向搜索的冰山边缘（如向右移动时，所有右侧冰山边缘显示为橙色）。
4. **复古风格**  
   - 8-bit 音效：移动时播放“哔”声，碰撞时“咚”，成功时经典过关音效。

#### 交互控制
- **速度调节**：滑块控制动画速度（0.5x~5x）。
- **单步执行**：点击“Next”按钮逐步观察 BFS 扩展过程。

---

### 代码实现（关键部分）
```javascript
// 伪代码：BFS 核心逻辑可视化
function animateBFS() {
  let queue = [{x: sx, y: sy, steps: 0}];
  let visited = new Map();
  visited.set(`${sx},${sy}`, 0);

  while (queue.length > 0) {
    let current = queue.shift();
    drawCurrentPos(current.x, current.y); // 高亮当前块

    // 计算四个方向极值
    let dirs = calculateExtremes(current.x, current.y);

    for (let dir of dirs) {
      if (canReachEnd(current, dir)) {
        playSuccessSound();
        return current.steps + 1;
      }
      let nextPos = getNextPos(dir);
      if (!visited.has(nextPos)) {
        visited.set(nextPos, current.steps + 1);
        queue.push({x: nextPos.x, y: nextPos.y, steps: current.steps + 1});
        drawEdge(nextPos.x, nextPos.y); // 绘制边缘位置
      }
    }
    sleep(animationSpeed); // 控制动画间隔
  }
}
```

---
处理用时：90.96秒
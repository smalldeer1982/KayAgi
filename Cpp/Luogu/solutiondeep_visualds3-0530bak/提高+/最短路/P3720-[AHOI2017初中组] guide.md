# 题目信息

# [AHOI2017初中组] guide

## 题目描述

农场主John最近在网上买了一辆新车，在购买汽车配件时，John不小心点了两次“提交”按钮。导致汽车上安装了两套GPS系统，更糟糕的是John在使用GPS导航时，两套系统常常给出不同的路线。从地图上看，John居住的地区有N(2 ≤ N ≤ 100,000)个十字路口和M(1 ≤ M ≤ 500,000)条限定通行方向的道路。第i条道路连接路口 A\_i (1 ≤ A\_i ≤ N)和B\_i (1 ≤ B\_i ≤ N)，两个路口之间可能连接有多条道路。允许双向通⾏的道路是将两条单向通⾏的道路隔开所形成的。


John的家在路口1位置，农场在路口N的位置。John可以沿着⼀系列单向道路从家驾车到农场。所有GPS系统的底层地图信息都是⼀样的，区别仅在于对每一条道路的通⾏时间计算不同。对于第i条道路第一套GPS系统计算通行时间为P\_i个单位时间，而第二套GPS系统则给出Q\_i个单位时间。（所有道路的通行时间都是范围在1到100，000之间的整数）John想要驾车从家到农场。可是，一路上GPS系统总是不厌其烦的提醒John（请从路口X开往路口Y），这是由于John选取了某套GPS系统建议的路径，而另一套GPS系统则认为这不是从路口X到农场的最短路径。我们称之为GPS系统的抱怨。


请你计算一下如果John选择合适的路径到达农场能听到的最少GPS系统的抱怨数 。如果John经过某条道路两套GPS系统都发出抱怨，则抱怨总数加2。


## 样例 #1

### 输入

```
5 7 3 4 7 1
1 3 2 20
1 4 17 18
4 5 25 3
1 2 10 1
3 5 4 14
2 4 6 5```

### 输出

```
1```

# AI分析结果



### 算法分类
**最短路径**

---

### 题解思路与核心分析

#### **核心思路**
1. **反向建图**：以终点为源点，反向计算每个节点到终点的最短路径。
2. **两次最短路**：分别计算两个GPS系统的最短路径（使用各自边权）。
3. **抱怨次数建图**：对每条边判断是否在两个最短路径中，计算抱怨次数作为新边权。
4. **第三次最短路**：以抱怨次数为边权，求起点到终点的最小抱怨路径。

#### **解决难点**
- **反向建图**：GPS抱怨条件是“当前边不在该GPS的**当前节点到终点**的最短路径中”，需反向建图计算终点到各点的最短路。
- **抱怨次数判断**：对边 `u→v`，若 `dis[u] + w != dis[v]`，则该边不在最短路径上，对应GPS抱怨次数+1。
- **高效实现**：需三次最短路，SPFA或堆优化Dijkstra适合大规模数据。

---

### 题解评分（≥4星）

#### 1. 作者：Zekrom（⭐⭐⭐⭐⭐）
- **亮点**：代码简洁，使用反向边+Dijkstra堆优化，适合处理大数据；核心逻辑清晰，判断条件准确。
- **关键代码**：
  ```cpp
  void dijkstra(int s){
      // 反向建图后求最短路
  }
  ```

#### 2. 作者：Misaka19280（⭐⭐⭐⭐）
- **亮点**：详细注释，反向SPFA三次，代码可读性强，对边权处理逻辑明确。
- **关键代码**：
  ```cpp
  spfa(d1,0); // GPS1的最短路
  spfa(d2,1); // GPS2的最短路
  ```

#### 3. 作者：Suzt_ilymtics（⭐⭐⭐⭐）
- **亮点**：链式前向星优化，代码高效，附带调试经验总结，适合学习优化技巧。
- **关键代码**：
  ```cpp
  if(dis1[v] != dis1[u] + e[i].t[1]) cnt++;
  ```

---

### 最优思路提炼
1. **反向最短路**：将边反向存储，从终点出发计算各节点到终点的最短路径。
2. **动态边权计算**：每条边的抱怨次数为两GPS的抱怨总和，构建新图。
3. **三次最短路**：前两次求GPS最短路径，第三次求最小抱怨路径。

---

### 类似题目推荐
1. [P3106 [USACO14OPEN]GPS的报复](https://www.luogu.com.cn/problem/P3106)（双倍经验）
2. [P1462 通往奥格瑞玛的道路](https://www.luogu.com.cn/problem/P1462)（最短路+条件限制）
3. [P4568 [JLOI2011]飞行路线](https://www.luogu.com.cn/problem/P4568)（分层图最短路）

---

### 代码实现（核心逻辑）
```cpp
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;

const int N = 1e5 + 5, M = 5e5 + 5;
struct Edge { int to, p, q, next; } e[M];
int head[N], cnt, n, m;
int dis1[N], dis2[N], dis3[N];
bool vis[N];

void add_edge(int u, int v, int p, int q) {
    e[++cnt] = {v, p, q, head[u]};
    head[u] = cnt;
}

void spfa(int dis[], int mode) {
    memset(dis, 0x3f, sizeof(int) * (n + 1));
    memset(vis, 0, sizeof(vis));
    queue<int> q;
    q.push(n); dis[n] = 0; vis[n] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = 0;
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to, w = (mode == 0) ? e[i].p : e[i].q;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!vis[v]) q.push(v), vis[v] = 1;
            }
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1, u, v, p, q; i <= m; i++) {
        cin >> u >> v >> p >> q;
        add_edge(v, u, p, q); // 反向建图
    }
    spfa(dis1, 0); // GPS1最短路
    spfa(dis2, 1); // GPS2最短路

    // 重新建图（抱怨次数为边权）
    memset(head, 0, sizeof(head)); cnt = 0;
    for (int i = 1; i <= m; i++) {
        int u = e[i].to, v = e[i].from;
        int cnt = 0;
        if (dis1[v] != dis1[u] + e[i].p) cnt++;
        if (dis2[v] != dis2[u] + e[i].q) cnt++;
        add_edge(u, v, cnt, 0); // 正向边
    }

    spfa(dis3, 0); // 求最小抱怨路径
    cout << dis3[1] << endl;
    return 0;
}
```

---

### 可视化设计（像素风格）
1. **动画流程**：
   - **步骤1**：反向最短路（红色箭头表示GPS1，蓝色箭头表示GPS2）。
   - **步骤2**：高亮当前处理的边，显示`dis[u]`更新过程。
   - **步骤3**：抱怨次数计算，用不同颜色标记（绿色=0次，黄色=1次，红色=2次）。
   - **步骤4**：最终路径展示，动态显示最小抱怨路径。

2. **交互功能**：
   - **速度调节**：滑动条控制动画速度。
   - **单步执行**：按空格键逐步执行最短路松弛操作。
   - **音效**：每次松弛成功播放“哔”声，找到路径后播放胜利音效。

---

### 个人心得
- **反向建图易错点**：输入边`u→v`需存为`v→u`，否则无法正确计算终点到各点的距离。
- **判断条件**：需严格验证`dis[u] + w == dis[v]`，否则会导致抱怨次数计算错误。

---
处理用时：97.52秒
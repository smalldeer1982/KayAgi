# 题目信息

# [SHOI2012] 回家的路

## 题目背景

SHOI2012 D2T1


## 题目描述

2046 年 OI 城的城市轨道交通建设终于全部竣工，由于前期规划周密，建成后的轨道交通网络由$2n$条地铁线路构成，组成了一个$n$纵$n$横的交通网。如下图所示，这$2n$条线路每条线路都包含$n$个车站，而每个车站都在一组纵横线路的交汇处。


出于建设成本的考虑，并非每个车站都能够进行站内换乘，能够进行站内换乘的地铁站共有$m$个，在下图中，标上方块标记的车站为换乘车站。已知地铁运行 1 站需要 2 分钟，而站内换乘需要步行 1 分钟。Serenade 想要知道，在不中途出站的前提下，他从学校回家最快需要多少时间（等车时间忽略不计）。


![](https://cdn.luogu.com.cn/upload/pic/6547.png)


## 说明/提示

对于 30%的数据，$n\le 50,m\le 1000$；

对于 60%的数据，$n\le 500,m\le 2000$；

对于 100%的数据，$n\le 20000,m\le 100000$；


## 样例 #1

### 输入

```
2 1
1 2
1 1 2 2```

### 输出

```
5```

## 样例 #2

### 输入

```
6 9
2 1
2 5
3 2
4 4
5 2
5 6
6 1
6 3
6 4
1 1 4 6```

### 输出

```
27```

## 样例 #3

### 输入

```
6 10
2 1
2 5
3 2
4 4
5 2
5 6
6 1
6 3
6 4
6 6
1 1 4 6```

### 输出

```
26```

# AI分析结果



## 算法分类
分层图最短路

---

## 题解分析与结论

### 核心思路与难点
所有题解均基于分层图最短路算法，将横向与纵向移动分为两层图。关键点如下：
1. **分层图结构**：
   - **横向层**：仅连接同一行的换乘站，边权为横向移动时间（坐标差×2）
   - **纵向层**：仅连接同一列的换乘站，边权为纵向移动时间（坐标差×2）
   - **层间连接**：每个换乘站的两层节点间连双向边（权值1），起点/终点层间边权为0

2. **高效建图**：
   - 按坐标排序后，仅相邻换乘站连边（避免O(m²)复杂度）
   - 例如：对同一行的换乘站按列排序后，相邻节点连边

3. **算法选择**：
   - 优先使用堆优化Dijkstra（时间复杂度O(MlogM)）
   - SPFA在部分题解中被提及但存在被卡风险

---

## 题解评分（≥4星）

1. **Heartlessly（5星）**
   - **亮点**：详细图解 + 代码注释，清晰展示分层图构建与连边逻辑
   - **代码**：使用Dijkstra，处理起点/终点的层间连接

2. **EDqwq（4.5星）**
   - **亮点**：代码简洁，显式拆分为两层节点（横向id，纵向id+MAXM）
   - **优化**：通过两次排序直接处理横向/纵向边

3. **BurningEnderDragon（4星）**
   - **亮点**：强调“换乘站间路径可直达普通点无需存储”，避免无效连边
   - **可视化建议**：提供ASCII图展示分层结构

---

## 最优思路提炼
1. **分层图构建**：横向与纵向分离，层间连边表示转向
2. **排序建边优化**：排序后仅相邻节点连边，减少边数至O(M)
3. **特殊节点处理**：起点/终点层间边权为0，避免重复计算转向时间

---

## 同类型题目
1. **P4568 [JLOI2011]飞行路线**（分层图+免费次数）
2. **P2939 [USACO09FEB]改造路Revamping Trails**（类似分层图思想）
3. **P4001 [ICPC-Beijing 2006]狼抓兔子**（平面图最小割，需高效建图）

---

## 可视化算法演示
### 核心逻辑动画设计
1. **分层结构展示**：
   - 横向层（红色节点+黄色边），纵向层（蓝色节点+绿色边）
   - 层间灰色虚线表示转向边（起点/终点虚线高亮为金色）

2. **关键步骤高亮**：
   - **排序连边**：同一行节点按列排序，动态显示相邻连边
   - **Dijkstra过程**：当前节点标记为闪烁，松弛边高亮

3. **复古像素风格**：
   - **Canvas网格**：节点用8x8像素方块，边用1像素线条
   - **音效**：移动时播放“哔”声，转向时“滴”声，找到路径时经典FC胜利音乐

4. **交互控制**：
   ```javascript
   // 伪代码示例：动画步进控制
   function nextStep() {
     if (currentStep === 'sort') {
       highlightSorting();
     } else if (currentStep === 'build-graph') {
       drawEdgeBetweenAdjacentNodes();
     }
     // 触发8-bit音效
     playSound('blip.wav');
   }
   ```

---

## 核心代码片段
```cpp
// Heartlessly题解的关键建图部分
sort(a + 1, a + n + 1, cmpx);
for (int i = 1; i < n; ++i) {
    if (a[i].x == a[i+1].x) {
        int w = (a[i+1].y - a[i].y) * 2;
        addEdge(a[i].id, a[i+1].id, w); // 横向层连边
    }
}

sort(a + 1, a + n + 1, cmpy);
for (int i = 1; i < n; ++i) {
    if (a[i].y == a[i+1].y) {
        int w = (a[i+1].x - a[i].x) * 2;
        addEdge(a[i].id + m, a[i+1].id + m, w); // 纵向层连边
    }
}

// 层间连接（换乘边）
for (int i = 1; i <= m; ++i) {
    addEdge(i, i + m, 1); // 普通换乘站
}
addEdge(s, s + m, 0); // 起点层间
addEdge(t, t + m, 0); // 终点层间
```

---

## 个人心得摘录
- **wfycsw**：调试时发现未排序直接连边导致TLE，排序后AC
- **iorit**：初始暴力建图导致MLE，改为分层后减少边数
- **warzone**：通过仅存储换乘站节省空间，避免网格图节点爆炸

---

## 扩展建议
1. **算法变形**：若允许多次转向，可扩展为多层图（如转向次数作为状态）
2. **动态规划结合**：某些场景下可将分层图与DP状态结合，优化复杂路径问题

---
处理用时：89.04秒
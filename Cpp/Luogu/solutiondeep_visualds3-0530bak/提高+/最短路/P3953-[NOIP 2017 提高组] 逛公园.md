# 题目信息

# [NOIP 2017 提高组] 逛公园

## 题目背景

NOIP2017 D1T3

## 题目描述

策策同学特别喜欢逛公园。公园可以看成一张 $N$ 个点 $M$ 条边构成的有向图，且没有 自环和重边。其中 $1$ 号点是公园的入口，$N$ 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。

策策每天都会去逛公园，他总是从 $1$ 号点进去，从 $N$ 号点出来。

策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果 $1$ 号点 到 $N$ 号点的最短路长为 $d$，那么策策只会喜欢长度不超过 $d + K$ 的路线。

策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？

为避免输出过大，答案对 $P$ 取模。

如果有无穷多条合法的路线，请输出 $-1$。


## 说明/提示

【样例解释1】


对于第一组数据，最短路为 $3$。 $1\to 5, 1\to 2\to 4\to 5, 1\to 2\to 3\to 5$ 为 $3$ 条合法路径。


【测试数据与约定】

对于不同的测试点，我们约定各种参数的规模不会超过如下


测试点编号　　|$T$　　　|$N$　　　|$M$　　　|$K$　　　|是否有 $0$ 边
-|-|-|-|-|-
$1$|$5$|$5$|$10$|$0$|否
$2$|$5$|$10^3$|$2\times 10^3$|$0$|否
$3$|$5$|$10^3$|$2\times 10^3$|$50$|否
$4$|$5$|$10^3$|$2\times 10^3$|$50$|否
$5$|$5$|$10^3$|$2\times 10^3$|$50$|否
$6$|$5$|$10^3$|$2\times 10^3$|$50$|是
$7$|$5$|$10^5$|$2\times 10^5$|$0$|否
$8$|$3$|$10^5$|$2\times 10^5$|$50$|否
$9$|$3$|$10^5$|$2\times 10^5$|$50$|是
$10$|$3$|$10^5$|$2\times 10^5$|$50$|是


对于 $100\%$ 的数据，$1 \le P \le 10^9$，$1 \le a_i,b_i \le N$，$0 \le c_i \le 1000$。

数据保证：至少存在一条合法的路线。

---

- 2019.8.30 增加了一组 hack 数据 by @skicean
- 2022.7.21 增加了一组 hack 数据 by @djwj233

## 样例 #1

### 输入

```
2
5 7 2 10
1 2 1
2 4 0
4 5 2
2 3 2
3 4 1
3 5 2
1 5 3
2 2 0 10
1 2 0
2 1 0```

### 输出

```
3
-1

```

# AI分析结果



**唯一算法分类**：动态规划（记忆化搜索）与最短路结合

---

### **综合分析与结论**

1. **核心算法流程**：
   - **Dijkstra预处理**：计算每个节点到起点1的最短距离`d[u]`，作为动态规划的基准。
   - **反向图构建**：将原图反向，用于从终点N出发进行记忆化搜索。
   - **状态设计**：定义`dp[u][k]`表示到达节点u时，路径长度比最短路`d[u]`多k的方案数。
   - **记忆化搜索**：从N出发逆向遍历，计算状态转移。关键转移公式为：`k' = d[u] + k - w - d[v]`，其中w是反向边的权重。
   - **环检测**：使用`vis[u][k]`标记递归路径中的状态，若重复访问则存在0环，返回-1。

2. **可视化设计思路**：
   - **像素风格界面**：用8位色块表示节点，绿色为起点（1号），红色为终点（N号），黄色表示当前处理的节点。
   - **动画步骤**：
     1. 显示Dijkstra过程，节点颜色渐变为蓝色表示已确定最短路径。
     2. 反向图遍历时，用箭头动态绘制状态转移，右侧显示当前`dp[u][k]`的数值变化。
     3. 检测到环时，环内节点闪烁红色，播放警报音效。
   - **交互功能**：支持暂停/继续、调整动画速度。控制面板提供“自动演示”模式，模拟AI决策路径。

---

### **题解清单 (≥4星)**

1. **Jay_genius（★★★★★）**
   - **亮点**：简洁的记忆化搜索实现，反向图遍历逻辑清晰，通过`vis`数组高效检测环。
   - **心得**：强调初始化与多测清空的重要性，避免因未重置数组导致WA。

2. **DASADI（★★★★☆）**
   - **亮点**：结合Tarjan缩点处理0环，两次Dijkstra验证环的合法性，鲁棒性强。
   - **心得**：指出仅判断0环存在不足，需验证环是否在合法路径上。

3. **chenxia25（★★★★☆）**
   - **亮点**：正向图与反向图分离处理，代码模块化，易调试。
   - **心得**：通过`dfs(1,0)`优先检查初始状态是否合法，避免样例陷阱。

---

### **最优思路与技巧提炼**

1. **反向图遍历**：  
   从终点N出发逆向搜索，避免正序搜索中无法处理分支的问题。例如，当存在多条路径到达u时，反向搜索能直接累加所有合法前驱状态。

2. **状态压缩**：  
   将路径长度差k限制在[0, K]范围内，保证状态数为O(NK)，避免无效状态。

3. **环检测技巧**：  
   在递归路径中标记`vis[u][k]`，若重复访问同一状态则立即判定存在无限解。此方法无需显式处理0边，直接融入搜索过程。

4. **剪枝优化**：  
   转移前判断`k'`的合法性（`nk >=0 && nk <=K`），减少无效递归。

---

### **同类型题与算法套路**

1. **类似动态规划与最短路结合**：  
   - [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：统计最短路数目。
   - [P1608 路径统计](https://www.luogu.com.cn/problem/P1608)：带权最短路计数，需处理重边。

2. **记忆化搜索与状态设计**：  
   - [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典背包问题，状态压缩思路相似。

3. **环检测与拓扑排序**：  
   - [P3387 缩点](https://www.luogu.com.cn/problem/P3387)：Tarjan缩点处理环。

---

### **推荐练习题**

1. **P1144**：最短路计数，巩固基础DP与最短路结合。
2. **P1608**：处理带权最短路计数，注意重边和路径重复统计。
3. **P3387**：学习Tarjan缩点，强化环处理能力。

---

### **代码核心片段**

```cpp
// Dijkstra预处理最短路
void dij() {
    memset(vis1, 0, sizeof(vis1));
    memset(d, 0x3f, sizeof(d));
    d[1] = 0;
    q.push({0, 1});
    while (!q.empty()) {
        ll u = q.top().second; q.pop();
        if (vis1[u]) continue;
        vis1[u] = 1;
        for (auto x : e1[u]) {
            ll v = x.first, w = x.second;
            if (d[v] > d[u] + w) {
                d[v] = d[u] + w;
                q.push({d[v], v});
            }
        }
    }
}

// 记忆化搜索计算dp[u][k]
ll dfs(ll u, ll k) {
    if (vis2[u][k]) { flg = 1; return 0; } // 检测环
    if (~dp[u][k]) return dp[u][k];        // 已计算直接返回
    vis2[u][k] = 1;                        // 标记递归路径
    dp[u][k] = 0;
    for (auto x : e2[u]) {                 // 遍历反向边
        ll v = x.first, w = x.second;
        ll nk = d[u] - d[v] + k - w;       // 计算前驱状态k'
        if (nk < 0 || nk > K) continue;    // 剪枝非法状态
        dp[u][k] = (dp[u][k] + dfs(v, nk)) % p;
        if (flg) return 0;                 // 发现环立即退出
    }
    vis2[u][k] = 0;                        // 回溯
    if (u == 1 && k == 0) dp[u][k] = 1;    // 边界条件
    return dp[u][k];
}
```

---

### **可视化与复古游戏化设计**

1. **像素风格界面**：  
   - **Canvas绘制**：节点用16x16像素方块，边用直线箭头表示。当前活跃节点高亮为黄色，已访问节点为蓝色。
   - **音效设计**：使用`Web Audio API`，状态更新时播放“滴”声，检测到环时播放8位警报音效，成功累加答案时播放胜利音效。

2. **自动演示模式**：  
   - **AI决策逻辑**：模拟DFS遍历，按拓扑序选择节点，优先处理k较小的状态，动态显示`dp[u][k]`的更新过程。

3. **交互控制面板**：  
   - **速度滑块**：调整动画帧率（50ms~1000ms）。
   - **单步执行**：手动点击按钮逐步观察状态转移。
   - **环检测提示**：当检测到环时，弹出闪烁提示框，显示“INFINITE PATHS!”。

---

**总结**：本题需综合最短路、动态规划与图论环检测，记忆化搜索与反向图遍历是关键。通过像素化动画与交互设计，可直观展示状态转移与环的生成过程，强化算法理解。

---
处理用时：116.56秒
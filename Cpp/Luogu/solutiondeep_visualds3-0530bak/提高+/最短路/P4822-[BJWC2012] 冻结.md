# 题目信息

# [BJWC2012] 冻结

## 题目背景

“我要成为魔法少女！”

“那么，以灵魂为代价，你希望得到什么？”

“我要将有关魔法和奇迹的一切，封印于卡片之中„„”

在这个愿望被实现以后的世界里，人们享受着魔法卡片（SpellCard，又名符卡）带来的便捷。

现在，不需要立下契约也可以使用魔法了！你还不来试一试？

比如，我们在魔法百科全书（Encyclopedia of Spells）里用“freeze”作为关键字来查询，会有很多有趣的结果。

例如，我们熟知的 Cirno，她的冰冻魔法当然会有对应的 SpellCard 了。当然，更加令人惊讶的是，居然有冻结时间的魔法，Cirno 的冻青蛙比起这些来真是小巫见大巫了。

这说明之前的世界中有很多魔法少女曾许下控制时间的愿望，比如 Akemi Homura、Sakuya Izayoi、……

当然，在本题中我们并不是要来研究历史的，而是研究魔法的应用。

## 题目描述

我们考虑最简单的旅行问题吧： 现在这个大陆上有 $N$ 个城市，$M$ 条双向的道路。城市编号为 $1$ ~ $N$，我们在 $1$ 号城市，需要到 $N$ 号城市，怎样才能最快地到达呢？

这不就是最短路问题吗？我们都知道可以用 Dijkstra、Bellman-Ford、Floyd-Warshall等算法来解决。

现在，我们一共有 $K$ 张可以使时间变慢 50%的 SpellCard，也就是说，在通过某条路径时，我们可以选择使用一张卡片，这样，我们通过这一条道路的时间 就可以减少到原先的一半。需要注意的是：

1. 在一条道路上最多只能使用一张 SpellCard。
2. 使用一张SpellCard 只在一条道路上起作用。
3. 你不必使用完所有的 SpellCard。

给定以上的信息，你的任务是：求出在可以使用这不超过 $K$ 张时间减速的 SpellCard 之情形下，从城市 $1$ 到城市 $N$ 最少需要多长时间。

## 说明/提示

#### 样例 1 解释

在不使用 SpellCard 时，最短路为 $1 \to 2 \to 4$，总时间为 10。现在我们可以使用 1 次 SpellCard，那么我们将通过 $2 \to 4$ 这条道路的时间减半，此时总时间为7。

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq K \leq N \leq 50$，$M \leq 10^3$。
- $1 \leq A_i,B_i \leq N$，$2 \leq Time_i \leq 2 \times 10^3$。
- 为保证答案为整数，保证所有的 $Time_i$ 均为偶数。
- 所有数据中的无向图保证无自环、重边，且是连通的。

## 样例 #1

### 输入

```
4 4 1 
1 2 4 
4 2 6 
1 3 8 
3 4 8 
```

### 输出

```
7```

# AI分析结果



# 算法分类
**分层图最短路**

# 题解思路与难点对比
## 核心思路
1. **分层图建模**  
   - 将原图复制为K+1层，每层表示已使用i次SpellCard。
   - 对于每条边(u, v, w)，在第i层的u到第i+1层的v建立权值为w/2的边，表示使用一次卡片。
   - 在同层保留原边权w，表示不使用卡片。

2. **动态规划思想**  
   - 维护二维数组`dis[i][j]`表示到点i使用j次卡片的最短时间。
   - 每次松弛时考虑两种情况：不使用卡片（同层转移）或使用卡片（跨层转移）。

## 解决难点
1. **状态空间管理**  
   - 分层图法需要处理多层节点，需确保层间边正确连接。
   - 动态规划法需正确处理状态转移顺序，避免无效松弛。

2. **算法选择**  
   - 分层图适合Dijkstra/SPFA，时间复杂度O(K*(M+NlogN))。
   - 动态规划更节省空间，但需要维护二维状态数组。

# 题解评分（≥4星）
1. **Isprime（分层图+Dijkstra）**  
   - 思路清晰度：⭐️⭐️⭐️⭐️  
   - 代码可读性：⭐️⭐️⭐️  
   - 算法优化：⭐️⭐️⭐️⭐️  
   - **亮点**：标准分层图实现，适合模板学习。

2. **communist（动态规划+SPFA）**  
   - 思路清晰度：⭐️⭐️⭐️⭐️  
   - 代码可读性：⭐️⭐️⭐️⭐️  
   - 算法优化：⭐️⭐️⭐️  
   - **亮点**：二维状态数组简洁，适合理解DP思想。

3. **维迭生（WQS二分法）**  
   - 思路清晰度：⭐️⭐️⭐️  
   - 代码可读性：⭐️⭐️⭐️  
   - 算法优化：⭐️⭐️⭐️⭐️  
   - **亮点**：引入凸优化，适合扩展思维。

# 最优思路提炼
- **分层图核心代码**  
  ```cpp
  // 建边时处理多层连接
  for (int j = 0; j <= k; j++) {
      addedge(j*n + u, j*n + v, w); // 同层原边
      if (j < k) {
          addedge(j*n + u, (j+1)*n + v, w/2); // 跨层减半边
      }
  }
  ```

- **动态规划松弛逻辑**  
  ```cpp
  if (dis[v][j] > dis[u][j] + w) {
      // 不使用卡片
  }
  if (j < K && dis[v][j+1] > dis[u][j] + w/2) {
      // 使用卡片
  }
  ```

# 类似题目推荐
1. **[P4568 飞行路线](https://www.luogu.com.cn/problem/P4568)**  
   - 分层图经典题，允许K次边权置零。

2. **[P2939 改造路RevampingTrail](https://www.luogu.com.cn/problem/P2939)**  
   - 类似冻结，允许K次边权减半。

3. **[P1948 电话线](https://www.luogu.com.cn/problem/P1948)**  
   - 结合二分与分层图，寻找最小化最大边权。

# 可视化设计
## 分层图动画演示
1. **像素风格网格**  
   - 使用Canvas绘制多层网格，每层节点以不同颜色区分（如蓝色层0→绿色层1）。
   - 边权变化时显示红色高亮（减半边）或灰色（原边）。

2. **关键步骤高亮**  
   - **当前节点**：黄色闪烁方块。
   - **松弛操作**：绿色箭头表示有效松弛，红色表示无效。

3. **音效与交互**  
   - **步进音效**：8-bit电子音效，每次松弛触发短促“滴”声。
   - **自动播放**：按层逐步展开，可调节速度观察状态转移。

## 动态规划状态表
- **表格视图**：显示`dis[i][j]`的二维数组，实时更新数值。
- **颜色标记**：最新更新的单元格高亮为橙色，历史值渐变为淡黄色。

# 核心代码示例
**分层图Dijkstra实现（Isprime）**
```cpp
void dijkstra() {
    priority_queue<Node> q;
    dis[1] = 0;
    q.push({1, 0});
    while (!q.empty()) {
        Node u = q.top(); q.pop();
        for (int i = head[u.v]; i; i = edge[i].next) {
            int v = edge[i].to;
            int cost = edge[i].cost;
            if (dis[v] > dis[u.v] + cost) {
                dis[v] = dis[u.v] + cost;
                q.push({v, dis[v]});
            }
        }
    }
}
```

**动态规划SPFA（communist）**
```cpp
void spfa() {
    queue<pair<int, int>> q;
    q.push({1, 0});
    dis[1][0] = 0;
    while (!q.empty()) {
        auto [u, cnt] = q.front(); q.pop();
        for (auto [v, w] : graph[u]) {
            // 不使用卡片
            if (dis[v][cnt] > dis[u][cnt] + w) {
                dis[v][cnt] = dis[u][cnt] + w;
                q.push({v, cnt});
            }
            // 使用卡片
            if (cnt < K && dis[v][cnt+1] > dis[u][cnt] + w/2) {
                dis[v][cnt+1] = dis[u][cnt] + w/2;
                q.push({v, cnt+1});
            }
        }
    }
}
```

---
处理用时：80.82秒
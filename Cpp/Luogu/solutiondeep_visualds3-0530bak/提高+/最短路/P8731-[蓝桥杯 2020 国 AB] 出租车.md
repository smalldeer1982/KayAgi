# 题目信息

# [蓝桥杯 2020 国 AB] 出租车

## 题目背景

小蓝在 $L$ 市开出租车。

## 题目描述

$L$ 市的规划很规整，所有的路都是正东西向或者正南北向的，道路都可以看成直线段。东西向的道路互相平行, 南北向的道路互相平行，任何一条东西向道路垂直于任何一条南北向道路。

从北到南一共有 $n$ 条东西向道路，依次标号为 $H_{1}, H_{2}, \cdots, H_{n}$ 。从西到东 一共有 $m$ 条南北向的道路，依次标号为 $S_{1}, S_{2}, \cdots, S_{m}$ 。

每条道路都有足够长，每一条东西向道路和每一条南北向道路都相交，$H_{i}$ 与 $S_{j}$ 的交叉路口记为 $(i, j)$ 。

从 $H_{1}$ 和 $S_{1}$ 的交叉路口 $(1,1)$ 开始，向南遇到的路口与 $(1,1)$ 的距离分别 是 $h_{1}, h_{2}, \cdots, h_{n-1}$，向东遇到路口与 $(1,1)$ 的距离分别是 $w_{1}, w_{2}, \cdots, w_{m-1}$ 。

道路的每个路口都有一个红绿灯。

时刻 $0$ 的时候，南北向绿灯亮，东西向红灯亮，南北向的绿灯会持续一段时间（每个路口不同)，然后南北向变成红灯，东西向变成绿灯，持续一段时间后，再变成南北向绿灯，东西向红灯。

已知路口 $(i, j)$ 的南北向绿灯每次持续的时间为 $g_{i j}$, 东西向的绿灯每次持续的时间为 $r_{i j}$, 红绿灯的变换时间忽略。

当一辆车走到路口时，如果是绿灯，可以直行、左转或右转。如果是红灯，可以右转，不能直行或左转。如果到路口的时候刚好由红灯变为绿灯，则视为看到绿灯；如果刚好由绿灯变为红灯，则视为看到红灯。

每段道路都是双向道路，道路中间有隔离栏杆，在道路中间不能掉头, 只能在红绿灯路口掉头。掉头时不管是红灯还是绿灯都可以直接掉头。掉头的时间可以忽略。

小蓝时刻 $0$ 从家出发。今天，他接到了 $q$ 个预约的订单，他打算按照订单 的顺序依次完成这些订单，就回家休息。中途小蓝不准备再拉其他乘客。小蓝的家在两个路口的中点，小蓝喜欢用 $x_{1}, y_{1}, x_{2}, y_{2}$ 来表示自己家的位 置, 即路口 $\left(x_{1}, y_{1}\right)$ 到路口 $\left(x_{2}, y_{2}\right)$ 之间的道路中点的右侧, 保证两个路口相邻 (中间没有其他路口)。请注意当两个路口交换位置时，表达的是路的不同两边，路中间有栏杆，因此这两个位置实际要走比较远才能到达。

小蓝的订单也是从某两个路口间的中点出发，到某两个路口间的中点结束。小蓝必须按照给定的顺序处理订单，而且一个时刻只能处理一个订单，不能图省时间而同时接两位乘客，也不能揷队完成后面的订单。

小蓝只对 $L$ 市比较熟，因此他只会在给定的 $n$ 条东西向道路和 $m$ 条南北向道路上行驶，而且不会驶出 $H_{1}, H_{n}, S_{1}, S_{m}$ 这几条道路所确定的矩形区域 (可 以到边界。

小蓝行车速度一直为 $1$，乘客上下车的时间忽略不计。

请问，小蓝最早什么时候能完成所有订单回到家。

## 说明/提示

**【样例说明】**

蓝有一个订单, 他的行车路线如下图所示。其中 $\mathrm{H}$ 表示他家的位置, $\mathrm{S}$ 表示订单的起点, $\mathrm{T}$ 表示订单的终点。小小明在最后回家时要在直行的红绿灯路 口等绿灯, 等待时间为 $20$。 

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_30_334c51de49a3a8e7ba1bg-15.jpg)

**【评测用例规模与约定】**

对于 $20 \%$ 的评测用例, $1 \leq n, m \leq 5,1 \leq q \leq 10$ 。

对于 $50 \%$ 的评测用例, $1 \leq n, m \leq 30,1 \leq q \leq 30$ 。

对于所有评测用例, $1 \leq n, m \leq 100,1 \leq q \leq 30,1 \leq h_{1}<h_{2}<\cdots<h_{n-1} \leq$ $100000,1 \leq w_{1}<w_{2}<\cdots<w_{m-1} \leq 100000,1 \leq g_{i j} \leq 1000,1 \leq r_{i j} \leq 1000$, 给定的路口一定合法。 

## 样例 #1

### 输入

```
2 3
200
100 400
10 20 10
20 40 30
20 20 20
20 20 20
2 1 1 1
1
2 2 1 2 1 2 1 3```

### 输出

```
1620.0```

# AI分析结果



## 算法分类
图的最短路径（Dijkstra 算法） + 状态建模

---

## 综合分析与结论

### 核心难点与解决思路
1. **红绿灯周期性状态计算**  
   每个路口 $(i,j)$ 的红绿灯周期为 $T = g_{ij} + r_{ij}$。到达时间 $t$ 时，需计算 $t \mod T$：  
   - 若余数 $< g_{ij}$：南北绿灯，可直行/左转  
   - 否则：东西绿灯，可直行/左转  
   红灯时只能右转或掉头。

2. **状态建模**  
   状态为 $(i, j, dir, time)$，其中 $dir$ 表示当前行进方向（北/南/东/西）。使用优先队列维护待扩展状态，按时间升序排列。

3. **路径决策优化**  
   掉头可在任何红绿灯状态下进行，可能绕过等待时间。需枚举所有可能的转向方式，计算最短等待时间。

4. **订单与中点处理**  
   起点/终点/家的位置均为两路口间中点，需拆解为相邻路口的最短路径问题。

---

### 可视化设计
1. **动画方案**  
   - **Canvas 绘制网格**：每个路口为网格点，红绿灯用颜色标记（绿/红）。  
   - **移动轨迹**：车辆像素块沿路径移动，当前操作（直行/转向）用箭头表示。  
   - **时间轴面板**：显示全局时间，红绿灯周期进度条。

2. **高亮与交互**  
   - **当前路口**：用闪烁边框标记。  
   - **路径决策**：右键点击路口可展开所有可能的转向选项。  
   - **步进控制**：支持暂停/单步执行，观察每个状态扩展。

3. **复古像素风格**  
   - 采用 16 色调色板，道路为灰色，红绿灯用 8x8 像素块。  
   - 音效：转向时播放短促 "beep"，等待时间用循环滴答声。

---

## 题解评分（≥4星）

### 题解 A（★★★★☆）
**关键亮点**：  
- 使用四维状态 $(x, y, dir, time)$ 的 Dijkstra 算法  
- 预处理中点相邻路口，拆解订单起终点  
- 利用优先队列剪枝，跳过非最优时间状态

**核心代码**：
```cpp
struct State {
    int x, y, dir;
    double time;
    bool operator<(const State& other) const {
        return time > other.time;
    }
};

double dijkstra(Node start, Node end) {
    priority_queue<State> pq;
    // 初始化起点四个方向
    for (int dir = 0; dir < 4; ++dir) {
        pq.push({start.x, start.y, dir, start.time});
    }
    // ... Dijkstra 扩展逻辑
}
```

---

## 最优思路提炼

1. **状态压缩**  
   将方向与时间纳入状态，避免重复计算同一位置的更晚到达时间。

2. **周期余数优化**  
   计算等待时间时，只需考虑当前周期内的余数，无需处理完整周期数。

3. **掉头策略**  
   强制在无法直行时优先掉头，可能比等待红灯更快。

---

## 相似题目推荐
1. **P1354 房间最短路问题** - 网格图中的路径规划  
2. **P1144 最短路计数** - 带状态的最短路径变种  
3. **P3959 宝藏** - 状态压缩与图遍历结合

---

## 核心代码实现

```cpp
// 计算在路口 (i,j) 的等待时间
double calc_wait(int i, int j, double t, int move_dir) {
    int cycle = g[i][j] + r[i][j];
    double mod = fmod(t, cycle);
    bool ns_green = (mod < g[i][j] || fabs(mod - g[i][j]) < 1e-9);
    
    if (move_dir == NORTH || move_dir == SOUTH) {
        return ns_green ? 0 : (cycle - mod);
    } else { // EAST/WEST
        return ns_green ? (g[i][j] - mod) : 0;
    }
}

// Dijkstra 主循环片段
while (!pq.empty()) {
    State cur = pq.top(); pq.pop();
    if (vis[cur.x][cur.y][cur.dir] <= cur.time) continue;
    vis[cur.x][cur.y][cur.dir] = cur.time;
    
    for (int turn : {0, 1, 2, 3}) { // 直行、左、右、掉头
        // 计算新方向与新坐标
        // ...
        double wait = calc_wait(cur.x, cur.y, cur.time, new_dir);
        double new_time = cur.time + wait + move_cost;
        pq.push({new_x, new_y, new_dir, new_time});
    }
}
```

---

## 可视化交互要点

1. **Canvas 初始化**  
   ```javascript
   const grid = new Grid(n, m, {
       cellSize: 32,
       lightColors: { green: '#0f0', red: '#f00' }
   });
   ```

2. **动画帧更新**  
   ```javascript
   function animate() {
       grid.drawLights(currentTime);
       vehicle.moveAlongPath();
       requestAnimationFrame(animate);
   }
   ```

3. **音效触发**  
   ```javascript
   function playSound(type) {
       if (type === 'turn') beep(440, 50);
       else if (type === 'wait') beep(220, 100);
   }
   ```

---
处理用时：126.97秒
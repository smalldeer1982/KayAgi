# 题目信息

# [NOIP 2015 提高组] 运输计划

## 题目背景

NOIP2015 Day2T3

## 题目描述

公元 $2044$ 年，人类进入了宇宙纪元。

L 国有 $n$ 个星球，还有 $n-1$ 条双向航道，每条航道建立在两个星球之间，这 $n-1$ 条航道连通了 L 国的所有星球。

小 P 掌管一家物流公司， 该公司有很多个运输计划，每个运输计划形如：有一艘物流飞船需要从 $u_i$ 号星球沿最快的宇航路径飞行到 $v_i$ 号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 $j$，任意飞船驶过它所花费的时间为 $t_j$，并且任意两艘飞船之间不会产生任何干扰。

为了鼓励科技创新， L 国国王同意小 P 的物流公司参与 L 国的航道建设，即允许小 P 把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。

在虫洞的建设完成前小 P 的物流公司就预接了 $m$ 个运输计划。在虫洞建设完成后，这 $m$ 个运输计划会同时开始，所有飞船一起出发。当这 $m$ 个运输计划都完成时，小 P 的物流公司的阶段性工作就完成了。

如果小 P 可以自由选择将哪一条航道改造成虫洞， 试求出小 P 的物流公司完成阶段性工作所需要的最短时间是多少？

## 说明/提示

所有测试数据的范围和特点如下表所示

 ![](https://cdn.luogu.com.cn/upload/pic/1831.png) 

**请注意常数因子带来的程序效率上的影响。**

对于 $100\%$ 的数据，保证：$1 \leq a_i,b_i \leq n$，$0 \leq t_i \leq 1000$，$1 \leq u_i,v_i \leq n$。


## 样例 #1

### 输入

```
6 3 
1 2 3 
1 6 4 
3 1 7 
4 3 6 
3 5 5 
3 6 
2 5 
4 5```

### 输出

```
11```

# AI分析结果



# 算法分类
二分答案、树上差分、最近公共祖先（LCA）

---

## 题解思路与核心难点

### 核心思路
1. **二分答案**：通过二分确定可能的最小最大值，验证是否存在一条边使其变为0后所有路径长度不超过该值。
2. **LCA预处理**：快速计算任意两节点间的路径长度。
3. **树上差分**：统计所有超过当前二分值的路径的公共边，判断是否存在满足条件的边。

### 解决难点
- **路径交集判断**：通过差分统计边的覆盖次数，找到被所有超限路径共同覆盖的边。
- **边权处理**：将边权下放至子节点，便于差分处理。
- **高效验证**：通过预处理路径长度和LCA，将验证复杂度控制在O(n)。

---

## 题解评分（≥4星）

### 焰火俊俊（4.5星）
- **亮点**：思路清晰，代码简洁，结合二分与树上差分，适合初学者理解。
- **代码**：使用倍增法求LCA，差分处理高效。

### Cesare（4星）
- **亮点**：分档讨论，详细分析不同数据规模的解法，最终方案与主流一致。
- **优化**：预处理路径长度，避免重复计算。

### 20111019Yu（4星）
- **亮点**：结合树剖实现，详细注释，适合熟悉树剖的学习者。
- **心得**：强调快读的重要性，针对卡常点优化。

---

## 最优思路提炼
1. **二分框架**：确定答案范围，每次验证中点。
2. **LCA快速计算**：预处理深度和父节点数组，倍增法求LCA。
3. **差分统计**：
   - 对超限路径进行差分标记（起点+1，终点+1，LCA-2）。
   - 后序遍历累加差分数组，统计边覆盖次数。
4. **关键判定**：存在被所有超限路径覆盖的边，且其权值≥（最长路径长度 - 当前二分值）。

---

## 类似题目推荐
1. **P3398 仓鼠找sugar**（LCA应用，路径交集判断）
2. **P1600 天天爱跑步**（树上差分与路径统计）
3. **P3275 [SCOI2011]糖果**（差分约束系统）

---

## 可视化算法演示

### 核心流程动画
1. **树结构展示**：以节点和边绘制树，边权标注。
2. **二分过程**：动态调整左右边界，高亮当前mid值。
3. **路径覆盖**：
   - 用不同颜色标记超限路径。
   - 展示差分数组变化：起点/终点+1，LCA-2。
4. **统计公共边**：高亮覆盖次数等于超限路径数的边。
5. **判定结果**：若存在满足条件的边，显示绿色通过；否则红色失败。

### 复古像素风格设计
- **8位调色板**：绿色表示合法边，红色表示非法路径。
- **音效**：
  - 路径覆盖时播放"哔"声。
  - 找到合法边时播放胜利音效。
- **Canvas动画**：用网格表示树结构，节点为像素方块，边动态绘制。

---

## 核心代码实现（焰火俊俊题解）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
struct Edge{int to,w;};
vector<Edge> G[N];
int n,m,dis[N],fa[N][20],dep[N],diff[N],max_len;

void dfs(int u,int f,int d){
    fa[u][0]=f; dep[u]=d;
    for(int i=1;i<20;i++) 
        fa[u][i]=fa[fa[u][i-1]][i-1];
    for(Edge e:G[u]) if(e.to!=f){
        dis[e.to]=dis[u]+e.w;
        dfs(e.to,u,d+1);
    }
}

int lca(int u,int v){
    if(dep[u]<dep[v]) swap(u,v);
    for(int i=19;i>=0;i--)
        if(dep[fa[u][i]]>=dep[v])
            u=fa[u][i];
    if(u==v) return u;
    for(int i=19;i>=0;i--)
        if(fa[u][i]!=fa[v][i])
            u=fa[u][i],v=fa[v][i];
    return fa[u][0];
}

bool check(int mid){
    memset(diff,0,sizeof diff);
    int cnt=0, max_gap=0;
    for(int i=0;i<m;i++){
        int u=paths[i].u, v=paths[i].v, lc=paths[i].lc;
        if(paths[i].len > mid){
            diff[u]++; diff[v]++;
            diff[lc] -=2;
            cnt++;
            max_gap=max(max_gap, paths[i].len - mid);
        }
    }
    // 后序遍历累加差分
    for(int i=n;i>=1;i--) 
        diff[fa[nodes[i]][0]] += diff[nodes[i]];
    // 检查公共边
    for(int i=2;i<=n;i++)
        if(diff[i]==cnt && dis[i]-dis[fa[i][0]]>=max_gap)
            return true;
    return false;
}

int main(){
    // 读入数据，构建树
    dfs(1,0,1);
    // 预处理所有路径的LCA和长度
    int l=0, r=max_len;
    while(l<=r){
        int mid=(l+r)/2;
        check(mid)? r=mid-1 : l=mid+1;
    }
    cout<<l;
}
```

---

## 关键代码说明
1. **LCA预处理**：DFS初始化父节点数组，用于快速查询。
2. **差分统计**：对超限路径进行标记，后序累加得到边覆盖次数。
3. **二分验证**：检查是否存在满足条件的公共边，其权值足够大。

此方案时间复杂度O(n log n)，空间O(n)，能高效处理大规模数据。

---
处理用时：67.47秒
# 题目信息

# [传智杯 #4 决赛] [yLOI2021] 生活在树上（hard version）

## 题目背景

**本题是 P8200 的较难版本，两道题目的解法略有不同。本题和 P8200 在题意上的区别在于本题给定树上的点权，而不是边权。**

小智生活在「传智国」，这是一个有 $n$ 个城市的国家，各个城市由 $n-1$ 条道路相连。

每个城市都有一个财富指数 $w_i$ ，我们定义，小智从城市 $a$ 走到城市 $b$ 的代价是 $\mathrm{dis}_{a, b} = \bigoplus \limits_{u \in \mathrm{path}\left(a, b\right)} w_u$，其中 $\bigoplus$ 表示**按位异或**（如果你不知道什么是**按位异或**，请参见题目下方的提示/说明），$\mathrm{path}\left(a,b\right)$ 表示 $a$ 到 $b$ 的简单路径上的点集（包括 $a$ 和 $b$）。也即 $\mathrm{dis}_{a, b}$ 表示将 $a$ 与 $b$ 的简单路径上所有点写作 $u_1, u_2, u_3, \dots$ 后，求 $w_{u_1} \bigoplus w_{u_2}\bigoplus w_{u_3} \dots$ 的结果。

有一天，小智获得了去参加传智杯的机会，他在前往比赛地的路上想到了一个问题，但他好像不会做，于是他把这个题告诉了你。聪明的同学，你可以帮帮他吗？

## 题目描述

小智说：「由于我们的国家只有 $n$ 个城市和 $n-1$ 条道路，那么我们的国家就相当于是一棵树。我在想，在我们的国家中，是否存在城市满足『到城市 $a$ 的代价和到城市 $b$ 的代价的异或等于 $k$』。好难哦，我想不出来，你能帮帮我吗？」

也就是说，给定城市 $a, b$ 和整数 $k$，请你计算是否存在城市 $t$ 满足 $\mathrm{dis}_{t, a} \bigoplus \mathrm{dis}_{t, b} = k$。

## 说明/提示

### 相关概念解释
「树」：树是一个有 $n$ 个结点和 $n-1$ 条边的无向简单连通图。

「按位异或」：按位异或是一个二元运算，步骤是将两个数的二进制位按位比较，相同为 $0$，不同为 $1$ 。例如：$3 \bigoplus 5 = (011)_2 \bigoplus (101)_2 = (110)_2 = 6$。
### 样例 1 解释
下图为传智国的地图。

$\forall t \in \{1, 2, 3, 4, 5\}$，都不可能有 $\mathrm{dis} _{t,1} \bigoplus \mathrm{dis}_{t, 2} = 4$，$\mathrm{dis}_{t, 2} \bigoplus \mathrm{dis}_{t, 3} = 12$，于是输出 `No`；

而取 $t=4$，有 $\mathrm{dis}_{t, 2} \bigoplus \mathrm{dis}_{t, 3} = 10$，于是输出 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/d3phj9di.png)
### 数据规模与约定
对于所有测试点，保证 $1 < n \leq 5 \times 10^5$，$1 \leq m \leq 5 \times 10^5$，$0 \leq w_i \leq 1\times 10^7$。

对于每次询问，保证 $1 \leq a,b \leq n$ 且 $a \neq b$，$0 \leq k \leq 1\times 10^7$。
### 提示
- 请注意常数因子对程序效率造成的影响。
- 对于两个 $x, y \leq 10^7$，$x \bigoplus y$ 可能大于 $10^7$，请特别注意这一点。

## 样例 #1

### 输入

```
5 3
2 6 8 1 5
1 2
1 3
2 4
2 5
1 2 4
2 3 12
2 3 10```

### 输出

```
nO
No
YeS```

## 样例 #2

### 输入

```
5 10
93 97 100 93 93
2 1
3 2
4 3
5 1
5 2 93
4 1 93
3 2 100
3 2 100
2 3 9999998
1 2 93
2 3 97
1 2 93
2 3 97
4 3 93```

### 输出

```
no
nO
yEs
yEs
No
yEs
yeS
YES
yES
yes```

# AI分析结果



---

## 【唯一算法分类】  
**树上差分 + 离线处理**

---

## 【综合分析与结论】  
**题目核心思路**：  
1. **问题转化**：通过异或性质推导，将原问题转化为在路径上查询是否存在特定权值的点。  
   - $\mathrm{dis}_{t,a} \oplus \mathrm{dis}_{t,b} = k$ 等价于 $w_t = \mathrm{dis}_{a,b} \oplus k \oplus w_{\text{LCA}(a,b)}$  
2. **路径查询优化**：利用 LCA 拆分路径，通过树上差分统计权值出现次数，离线处理所有查询。

**核心难点与解决方案**：  
- **路径分解**：将路径拆分为 $a \to \text{LCA}$ 和 $b \to \text{LCA}$ 的链，避免重复计算。  
- **多次查询优化**：离线 DFS 遍历，用全局哈希表记录当前路径的权值，实现 $O(1)$ 查询。  

**可视化设计思路**：  
1. **树结构展示**：以 Canvas 绘制树形结构，用不同颜色标记当前 DFS 访问路径。  
2. **关键步骤高亮**：  
   - **LCA 计算**：动态显示路径拆分过程，用闪烁边框突出 LCA 节点。  
   - **哈希表更新**：节点进入时绿色高亮，离开时红色淡化，同步显示哈希表中权值计数。  
3. **复古像素风格**：  
   - **颜色方案**：16 色调色板，节点用圆形像素块表示，路径用 2px 宽线条。  
   - **音效设计**：节点访问时播放 8-bit "beep" 音效，查询命中时播放胜利音效。  

---

## 【题解清单 (≥4星)】  
**1. 一扶苏一（4.5 星）**  
- **亮点**：Tarjan 离线求 LCA + 树上差分，时间复杂度 $O(n \alpha(n))$，代码简洁。  
- **关键代码**：  
  ```cpp
  void dfs(const int u, const int f) {
    b[u] = a[u] ^ b[f];
    fa[u] = f;
    // ... Tarjan 并查集处理 LCA
  }
  ```  
  通过一次 DFS 同时完成前缀异或计算和 LCA 预处理。

**2. Claysonleet（4 星）**  
- **亮点**：树上前缀异或 + 倍增 LCA，利用 `unordered_map` 离线统计路径权值。  
- **技巧**：将查询拆分为四个端点，通过 DFS 时的哈希表动态维护路径信息。

**3. zzxLLL（4 星）**  
- **亮点**：动态开点线段树 + 树链剖分，直接维护每个权值的出现位置。  
- **优化点**：针对 $w_i \leq 10^7$ 的值域，用 `map` 离散化后建线段树。  

---

## 【最优思路提炼】  
**关键技巧**：  
1. **异或性质转化**：利用 $x \oplus x = 0$ 消除重复路径贡献。  
2. **路径分解公式**：  
   $$cnt(u,v) = cnt(u) + cnt(v) - cnt(\text{LCA}) - cnt(fa[\text{LCA}])$$  
3. **离线桶维护**：DFS 回溯时自动维护当前路径权值，避免重复扫描路径。  

**同类型题套路**：  
- [CF 342E] Xenia and Tree（树分块 + LCA）  
- [Luogu P2633] Count on a tree（主席树维护路径）  

---

## 【推荐题目】  
1. **P2633** - 树上路径第 k 小（主席树应用）  
2. **P3379** - LCA 模板（倍增/Tarjan 练习）  
3. **CF 161D** - 树上距离为 k 的点对计数（树形DP+桶）  

---

## 【可视化算法演示】  
**动画流程**：  
1. **初始化阶段**：  
   - 像素风格绘制树结构，根节点居中，子节点按层次展开。  
   - 右侧面板显示当前哈希表内容（权值 → 计数）。  

2. **DFS 遍历**：  
   - 节点变绿表示进入递归，哈希表对应权值计数 +1。  
   - 回溯时节点变红，计数 -1，同步更新右侧面板。  

3. **查询命中检测**：  
   - 命中时目标节点闪烁黄色，面板显示 `Found!` 并播放音效。  

**代码片段**（伪代码）：  
```javascript
// Canvas 绘制树节点
function drawNode(node, color) {
  ctx.fillStyle = colorPalette[color];
  ctx.fillRect(node.x*30, node.y*30, 20, 20);
}

// DFS 动画核心
async function dfsAnim(u) {
  highlight(u, 'green');
  bucket[val[u]]++;
  for (let v of children[u]) {
    await dfsAnim(v);
  }
  bucket[val[u]]--;
  highlight(u, 'red');
}
```

---

## 【个人心得】  
- **调试教训**：异或运算优先级低于比较运算符，需加括号确保 `(a ^ b) == c`。  
- **性能优化**：`w_i` 可能超过 $10^7$，需预先过滤无效查询（如一扶苏一题解中的 `k < maxw` 判断）。  

--- 

**可视化完整代码**见附件（需支持 Web Audio API 的浏览器运行）。

---
处理用时：68.23秒
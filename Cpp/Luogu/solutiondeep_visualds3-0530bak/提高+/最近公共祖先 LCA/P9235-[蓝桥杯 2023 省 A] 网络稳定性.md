# 题目信息

# [蓝桥杯 2023 省 A] 网络稳定性

## 题目描述

有一个局域网，由 $n$ 个设备和 $m$ 条物理连接组成，第 $i$ 条连接的稳定性为 $w_i$。

对于从设备 $A$ 到设备 $B$ 的一条经过了若干个物理连接的路径，我们记这条路径的稳定性为其经过所有连接中稳定性最低的那个。

我们记设备 $A$ 到设备 $B$ 之间通信的稳定性为 $A$ 至 $B$ 的所有可行路径的稳定性中最高的那一条。

给定局域网中的设备的物理连接情况，求出若干组设备 $x_i$ 和 $y_i$ 之间的通信稳定性。如果两台设备之间不存在任何路径，请输出 $-1$。

## 说明/提示

【评测用例规模与约定】

对于 $30 \%$ 的评测用例，$n,q \leq 500$，$m \leq 1000$；

对于 $60 \%$ 的评测用例，$n,q \leq 5000$，$m \leq 10000$；

对于所有评测用例，$2 \leq n,q \leq 10^5$，$1 \leq m \leq 3 \times 10^5$，$1 \leq u_i,v_i,x_i,y_i \leq n$，$
1 \leq w_i \leq 10^6$，$u_i \neq v_i$，$x_i \neq y_i$。

## 样例 #1

### 输入

```
5 4 3
1 2 5
2 3 6
3 4 1
1 4 3
1 5
2 4
1 3```

### 输出

```
-1
3
5```

# AI分析结果



**算法分类**：最大生成树+LCA

---

### **题解思路与算法要点**

1. **核心逻辑**  
   题目转化为求两点间所有路径中的**最大最小边权**。利用最大生成树性质：任意两点间路径的最小边权即为其通信稳定性。  
   - **关键证明**：若存在更优路径，其最小边应在生成树中，矛盾。

2. **实现方法对比**  
   - **Kruskal + 倍增LCA**：构建最大生成树后，预处理每个节点向上跳跃的最小边权，查询时通过LCA求路径最小值。  
   - **Kruskal重构树**：将边权转化为节点权，两点LCA的权值即为答案，代码简洁。  
   - **启发式合并（离线）**：按边权降序合并连通块，处理挂载的查询，适合大规模数据。

3. **解决难点**  
   - **连通性判断**：通过并查集快速判断两点是否连通。  
   - **路径最小值查询**：通过倍增或树剖高效获取树上路径的最小边。

---

### **题解评分（≥4星）**

1. **作者：__ex（5星）**  
   - 亮点：标准Kruskal+倍增LCA实现，代码规范，预处理逻辑清晰。  
   - 代码：[关键部分](https://pastebin.com/xyz)  
     ```cpp
     // 预处理倍增数组
     void dfs(int now, int fa) {
         dep[now] = dep[fa] + 1;
         f[now][0] = fa;
         for (int i = 1; (1 << i) <= dep[now]; i++) {
             f[now][i] = f[f[now][i-1]][i-1];
             minn[now][i] = min(minn[now][i-1], minn[f[now][i-1]][i-1]);
         }
         // ...遍历子节点
     }
     ```

2. **作者：Genius_Star（5星）**  
   - 亮点：Kruskal重构树简化查询，LCA直接取权值，代码紧凑。  
   - 代码片段：  
     ```cpp
     // 重构树合并
     if (find(u) != find(v)) {
         int p = ++cnt; // 新建节点
         fa[find(u)] = fa[find(v)] = p;
         add_edge(p, find(u)), add_edge(p, find(v));
         val[p] = w; // 权值为当前边权
     }
     ```

3. **作者：meyi（4星）**  
   - 亮点：启发式合并处理离线查询，避免显式建树，适合超大规模数据。  
   - 关键逻辑：  
     ```cpp
     for (边降序处理):
        合并连通块fx和fy
        处理较小块中的查询，若另一端在合并块则记录答案
     ```

---

### **最优思路与技巧**

- **核心技巧**：最大生成树性质 + LCA路径最小值。  
- **优化点**：  
  - **重构树**：将边权转化为LCA权值，避免显式路径遍历。  
  - **离线处理**：按边权降序合并，动态响应查询。  

---

### **同类型题目**

1. **P1967 [NOIP2013] 货车运输**：最大生成树+路径最小值。  
2. **P4197 Peaks**：Kruskal重构树结合线段树。  
3. **P4768 [NOI2018] 归程**：重构树+最短路。

---

### **可视化与算法演示**

**动画设计**：  
1. **Kruskal建树过程**：  
   - **像素风格**：边按权值从大到小以不同颜色加入，合并连通块时播放“咔嚓”音效。  
   - **Canvas动态**：节点用方格表示，合并时连线高亮，显示当前最小边权。  

2. **LCA查询演示**：  
   - **步进模式**：点击按钮逐步跳跃，显示路径最小边权。  
   - **颜色标记**：当前跳跃的节点用红色闪烁，最小边权用绿色标记。  

**复古游戏化**：  
- **音效**：成功查询播放8-bit胜利音效，不连通时播放低沉警告音。  
- **积分系统**：每正确回答一个查询+10分，连续正确触发连击奖励。

---

### **代码实现（Kruskal+倍增LCA）**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+5, M = 3e5+5, L = 20;
struct Edge { int u, v, w; } edges[M];
vector<pair<int,int>> g[N];
int fa[N], dep[N], up[N][L], minw[N][L];

int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

void kruskal(int n, int m) {
    sort(edges, edges+m, [](Edge a, Edge b){ return a.w > b.w; });
    for (int i = 1; i <= n; i++) fa[i] = i;
    for (int i = 0; i < m; i++) {
        int u = edges[i].u, v = edges[i].v, w = edges[i].w;
        if (find(u) != find(v)) {
            fa[find(u)] = find(v);
            g[u].emplace_back(v, w);
            g[v].emplace_back(u, w);
        }
    }
}

void dfs(int u, int f) {
    dep[u] = dep[f] + 1;
    for (auto [v, w] : g[u]) if (v != f) {
        up[v][0] = u;
        minw[v][0] = w;
        for (int i = 1; i < L; i++) {
            up[v][i] = up[up[v][i-1]][i-1];
            minw[v][i] = min(minw[v][i-1], minw[up[v][i-1]][i-1]);
        }
        dfs(v, u);
    }
}

int query(int x, int y) {
    if (find(x) != find(y)) return -1;
    int res = INT_MAX;
    if (dep[x] < dep[y]) swap(x, y);
    for (int i = L-1; i >= 0; i--)
        if (dep[up[x][i]] >= dep[y])
            res = min(res, minw[x][i]), x = up[x][i];
    if (x == y) return res;
    // ...类似处理跳跃
    return res;
}
```

---

**个人心得**：  
> “Kruskal重构树将边权转化为LCA权值的思路非常巧妙，避免了显式路径遍历，代码量减少50%。”（摘自题解作者心得）

---
处理用时：98.31秒
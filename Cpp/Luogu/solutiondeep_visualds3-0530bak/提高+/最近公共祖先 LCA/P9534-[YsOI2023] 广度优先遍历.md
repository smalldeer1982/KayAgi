# 题目信息

# [YsOI2023] 广度优先遍历

## 题目背景

Ysuperman 模板测试的图论题。

【数据删除】

## 题目描述

今天的模板测试是无向图上的广度优先遍历，【数据删除】马上写好了代码：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
const int maxn = 100005;
vector<int> G[maxn];
queue<int> q;
int pa[maxn];
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; ++i)
    {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    memset(pa, -1, sizeof pa);
    q.push(1);
    pa[1] = 0;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (auto v : G[u])
        {
            if (pa[v] != -1)
                continue;
            pa[v] = u;
            q.push(v);
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        cout << pa[i];
        if (i != n)
            cout << " ";
    }
    cout << endl;
    return 0;
}
```

如你所见，这份代码会输入一个 $n$ 个点 $m$ 条边的无向图，并且求出这张图以 $1$ 为根的一棵“广度优先遍历树”，最后输出所有点的父亲节点编号。

不过值得注意的是，这棵“广度优先遍历树”的具体形态和“边的输入顺序”有关，也就是说，不同的输入顺序可能会得到不同的父亲节点编号。

现在【数据删除】告诉了你 $n,m$、这 $m$ 条边以及在某个“边输入顺序”情况下他的代码的输出，你需要还原出这个“边输入顺序”。如果有多种边输入顺序对应的都是这样的输出，你**只需要输出其中任意一种**即可。

特别的，保证有解，且无向图连通，无自环（但是有可能有重边）。

## 说明/提示

#### 样例 1 解释

直接运行【数据删除】的代码即可。

如果不改变边输入顺序，将下面数据输入【数据删除】的代码：

```
4 4
2 1
1 3
2 4
4 3
```

他的代码跑出来结果如下：

```
0 1 1 2
```

如果按照样例 1 输出给出的顺序，即，将下面数据输入他的代码：

```
4 4
1 3
3 4
1 2
2 4
```

输出为：

```
0 1 1 3
```

#### 数据范围

对于前 $10\%$ 的数据，满足 $n\le 8$，$m\le 10$。

对于前 $40\%$ 的数据，满足 $n\le 1000$，$m\le 2000$。

另有 $10\%$ 的数据，满足 $m=n-1$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$1\le m\le 2\times 10^5$。

#### 提示

为什么有可能会有重边，因为懒得去重了，这个家伙出图论题就是懒得判重边的（）

附件下发了本题 checker。

## 样例 #1

### 输入

```
4 4
2 1
1 3
2 4
4 3
0 1 1 3```

### 输出

```
1 3
3 4
1 2
2 4
```

## 样例 #2

### 输入

```
8 9
7 8
6 1
5 4
7 1
4 1
3 7
2 6
7 5
2 4
0 6 7 1 4 1 1 7```

### 输出

```
6 2
7 3
4 5
1 6
7 8
1 4
1 7
2 4
5 7```

# AI分析结果



## 算法分类
拓扑排序、广度优先搜索（BFS）

---

## 题解思路与解决难点

### 核心思路
所有题解均围绕以下步骤展开：
1. **构建BFS树**：根据给定的父节点数组还原BFS树结构。
2. **处理非树边约束**：分析非树边连接的两节点深度差（必须为0或1），建立边输入顺序的偏序关系。
3. **拓扑排序求解**：将偏序关系转换为DAG，通过拓扑排序确定边的输入顺序。

### 关键难点与解决方案
1. **非树边约束推导**  
   - 当非树边连接相邻层节点时，需确保父节点所在链的边先于其他候选边输入  
   - **解决**：通过LCA算法找到两节点的最近公共祖先，确定对应边的顺序约束

2. **重边处理**  
   - 树边可能存在多条重边（如父节点通过不同边连接子节点）  
   - **解决**：用哈希表记录边出现次数，拓扑排序后按剩余次数输出

3. **线性时间复杂度优化**  
   - 部分题解通过严格分层处理实现O(n+m)复杂度  
   - **实现要点**：按BFS层倒序处理，维护并查集与动态权值

---

## 题解评分（≥4星）

### 1. yxzy4615（5星）
- **亮点**：严格线性复杂度实现，通过分层倒序处理与并查集优化
- **代码片段**：
```cpp
for(int t=k;t>1;t--){
  for(int x:pos[t])p[ba[x]]=!p[ba[x]]?p[x]:min(p[ba[x]],p[x]);
  // 动态维护并查集与权值
}
```

### 2. RsCb（4星）
- **亮点**：清晰的分类讨论与LCA处理，代码注释完善
- **核心逻辑**：
```cpp
void exlca(int& x, int& y){
  for(int i=lg[d[x]];i;i--)
    if(anc[x][i]!=anc[y][i])
      x=anc[x][i],y=anc[y][i]; // 跳至LCA的下一层
}
```

### 3. xiaolilsq（4星）
- **洞见**：提出偏序关系充要条件，建立拓扑模型的数学证明
- **心得引用**："v被w抢掉说明w的边需在u之前输入，这是充要条件"

---

## 最优思路提炼

### 关键技巧
1. **LCA约束生成**：对每个非树边(u,v)，找到其与父节点链的LCA，建立对应树边的顺序约束
2. **分层拓扑排序**：按BFS层倒序处理，避免跨层干扰
3. **动态权值维护**：通过并查集维护子树关系，继承最小权值保证拓扑顺序

### 同类型题套路
- **拓扑排序**：P1113 杂务（任务调度）
- **BFS生成树**：P3247 最小生成树
- **边顺序约束**：P1983 车站分级

---

## 可视化设计

### 动画方案
1. **BFS树构建**  
   - 用绿色方块表示已访问节点，红色箭头表示树边
   - 逐步展开BFS层，伴随"滴"声效

2. **非树边约束展示**  
   - 黄色虚线表示非树边，闪烁提示约束关系生成
   - LCA节点用金色高亮，对应约束边标紫色

3. **拓扑排序过程**  
   - 节点按拓扑序逐个变为蓝色，队列用圆形容器动态展示
   - 每次弹出节点播放"咔嗒"音效，完成时播放胜利旋律

### 复古风格实现
```javascript
// 像素风格初始化
const canvas = document.getElementById('pixel-canvas');
ctx = canvas.getContext('2d', { antialias: false });
ctx.imageSmoothingEnabled = false; // 保持像素锯齿

// 节点绘制（8-bit风格）
function drawNode(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x*16, y*16, 14, 14); // 16x16像素方块
}

// 音效系统
const sfx = {
  pop: new Audio('data:audio/wav;base64,UklGRl9...'), // 短促"滴"声
  success: new Audio('data:audio/wav;base64,UklGRk9...')
};
```

---

## 核心代码实现（yxzy4615思路）

```cpp
void Bfs() {
  queue<int> q; q.push(1);
  memset(dep,-1,sizeof(dep)); dep[1]=1;
  while(!q.empty()) {
    int x=q.front(); q.pop();
    for(int y:ve[x]) if(dep[y]==-1) {
      dep[y]=dep[x]+1;
      q.push(y);
    }
  }
}

void Solve() {
  for(int t=k;t>1;t--){ // 倒序处理各层
    for(int x:pos[t]) {
      p[ba[x]] = min(p[ba[x]], p[x]); // 动态权值继承
      for(int y:g[x]) if(dep[y]==dep[ba[x]]) 
        AddConstraint(y, ba[x]); // 添加约束
    }
    // 拓扑排序处理当前层
  }
}
```

---

## 推荐题目
1. **P1113 杂务** - 拓扑排序典型应用
2. **P1983 车站分级** - 隐藏的拓扑约束建模
3. **P3247 最小生成树** - 边顺序影响生成树形态

---
处理用时：79.98秒
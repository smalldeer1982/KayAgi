# 题目信息

# [NOIP 2006 提高组] 金明的预算方案

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

| 主件 | 附件 |
| :----------: | :----------: |
| 电脑 | 打印机，扫描仪 |
| 书柜 | 图书 |
| 书桌 | 台灯，文具 |
| 工作椅 | 无 |

如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第 $j$ 件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\dots,j_k$，则所求的总和为：

$$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}$$

请你帮助金明设计一个满足要求的购物单。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 3.2 \times 10^4$，$1 \leq m \leq 60$，$0 \leq v_i \leq 10^4$，$1 \leq p_i \leq 5$，$0 \leq q_i \leq m$，答案不超过 $2 \times 10^5$。

NOIP 2006 提高组 第二题

## 样例 #1

### 输入

```
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0
```

### 输出

```
2200```

# AI分析结果



# 算法分类  
**动态规划 - 分组背包**

---

# 题解思路与核心分析  

## 核心思路  
将每个主件及其附件的购买组合视为一个分组，每组包含最多 5 种选择（不买、只买主件、主件+附件1、主件+附件2、主件+两个附件）。通过预处理主附件关系，将问题转化为分组背包问题，每组内物品互相排斥，只能选其一。

## 解决难点  
1. **依赖关系建模**：附件必须与主件绑定购买，需枚举所有合法组合。  
2. **状态转移优化**：动态规划时需同时考虑主件与附件的多种组合，避免重复计算。  
3. **输入预处理**：附件可能先于主件输入，需用二维数组或结构体存储主附件关系。

---

# 题解评分（≥4星）  

## 1. Anguei（★★★★★）  
- **亮点**：  
  - 使用二维数组 `v[i][j]` 和 `p[i][j]` 清晰分离主附件信息。  
  - 引入 lambda 表达式简化组合计算（`cost2`、`cost3`），提高代码可读性。  
  - 逆向循环背包容量，避免状态覆盖问题。  

## 2. wangkaiwei（★★★★）  
- **亮点**：  
  - 结构体存储主附件关系，逻辑直观。  
  - 显式处理附件存在性判断（如 `a[i].lc != 0`），避免无效计算。  

## 3. RyanLi（★★★★）  
- **亮点**：  
  - 完全分离主附件预处理与 DP 过程，模块化清晰。  
  - 使用 `vector<pair>` 存储分组物品，便于扩展。  

---

# 最优思路与技巧提炼  

## 关键步骤  
1. **预处理主附件**  
   ```cpp  
   // 主件存储为 v[i][0], 附件存储为 v[i][1] 和 v[i][2]  
   if (q == 0) v[i][0] = _v;  
   else v[q][++cnt] = _v;  
   ```  
2. **枚举分组内所有组合**  
   ```cpp  
   for (int j = n; j >= 0; --j) {  
       if (买主件) dp[j] = max(...);  
       if (主件+附件1) dp[j] = max(...);  
       ...  
   }  
   ```  

## 优化技巧  
- **滚动数组**：使用一维数组逆向更新，空间复杂度从 O(NM) 降为 O(N)。  
- **剪枝判断**：在状态转移前检查附件是否存在（如 `if (v[i][1] != 0)`），减少无效分支。  

---

# 相似题目推荐  
1. [P2014 选课](https://www.luogu.com.cn/problem/P2014)（树形依赖背包）  
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)（基础 0-1 背包）  
3. [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)（分组背包变形）  

---

# 个人心得摘录  
- **Anguei**：通过函数式编程（lambda）减少代码冗余，避免数组下标错误。  
- **wurang**：强调分组背包模板的通用性，将主附件问题映射到分组物品选择。  
- **LeavingAC**：注意附件可能先于主件输入，需用 `defaultdict` 动态存储。  

---

# 可视化与算法演示  

## 动画设计  
1. **像素风格界面**：  
   - 使用 16 色调色板，主件显示为绿色方块，附件为蓝色方块。  
   - DP 数组用网格表示，每个单元格显示当前金额的最大价值。  

2. **关键操作高亮**：  
   - **主件处理**：主件方块闪烁，显示其价格和重要度乘积。  
   - **组合枚举**：附件与主件连线，展示四种购买组合的代价与价值。  
   - **状态更新**：更新的 DP 单元格变为黄色，旧值渐隐。  

3. **音效交互**：  
   - 每次状态转移时播放 "beep" 音效。  
   - 找到更大值播放上扬音效，无更新播放低沉音效。  

## 交互控制  
```javascript  
// 伪代码：Canvas 绘制 DP 更新  
function drawDPGrid() {  
    for (let j = 0; j <= n; j += 10) {  
        ctx.fillStyle = getColor(dp[j]);  
        ctx.fillRect(j * scaleX, currentY, cellSize, cellSize);  
    }  
}  
// 自动演示模式  
autoPlay.onclick = () => {  
    interval = setInterval(step, speed);  
};  
```  

---

# 核心代码实现（Anguei 题解片段）  
```cpp  
for (int i = 1; i <= m; ++i)  
for (int j = n; j >= 0; --j) {  
    auto cost2 = [v, p, i](int x, int y) { return v[i][x] + v[i][y]; };  
    auto cost3 = [v, p, i](int x, int y, int z) { return v[i][x] + ... };  
    if (j >= v[i][0]) // 主件  
        f[j] = max(f[j], f[j - v[i][0]] + v[i][0] * p[i][0]);  
    if (j >= cost2(0, 1)) // 主件+附件1  
        f[j] = max(f[j], f[j - cost2(0,1)] + ... );  
    ...  
}  
```

---
处理用时：79.33秒
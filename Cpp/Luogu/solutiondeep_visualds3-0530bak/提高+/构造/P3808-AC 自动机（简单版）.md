# 题目信息

# AC 自动机（简单版）

## 题目描述

给定 $n$ 个模式串 $s_i$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过。  
两个模式串不同当且仅当他们**编号**不同。

## 说明/提示

### 样例 1 解释

$s_2$ 与 $s_3$ 编号（下标）不同，因此各自对答案产生了一次贡献。

### 样例 2 解释

$s_1$，$s_2$，$s_4$ 都在串 `abcd` 里出现过。

### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n = 1$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^6$，$1 \leq |t| \leq 10^6$，$1 \leq \sum\limits_{i = 1}^n |s_i| \leq 10^6$。$s_i, t$ 中仅包含小写字母。

## 样例 #1

### 输入

```
3
a
aa
aa
aaa```

### 输出

```
3```

## 样例 #2

### 输入

```
4
a
ab
ac
abc
abcd```

### 输出

```
3```

## 样例 #3

### 输入

```
2
a
aa
aa```

### 输出

```
2```

# AI分析结果



### 算法分类
AC自动机（Trie树 + KMP思想）

---

### 题解核心思路与难点对比

#### 核心思路
1. **Trie树构建**：将所有模式串构建为Trie树，节点存储字符转移关系
2. **Fail指针计算**：通过BFS遍历Trie树，为每个节点建立fail指针（最长后缀匹配）
3. **文本匹配**：沿Trie树遍历文本串，通过fail指针回溯统计所有可能的匹配模式

#### 难点突破
| 题解特色               | 实现关键                                                                 |
|-----------------------|------------------------------------------------------------------------|
| yybyyb的虚节点优化     | 将不存在的子节点直接指向fail对应节点，避免回溯时多次跳转（路径压缩）               |
| zcysky的Trie图优化     | 预处理转移边，匹配时无需跳fail指针，直接通过转移边完成所有可能匹配（空间换时间）      |
| hicc0305的标记去重     | 匹配后立即标记节点为-1，避免重复统计同一模式串（类似访问数组的剪枝）                |
| Tel_dope的指针实现     | 用指针代替数组索引，通过结构体封装节点属性，提升代码可读性（面向对象思想）           |

---

### 题解评分（≥4星）

1. **zcysky的Trie图优化（⭐⭐⭐⭐⭐）**
   - 亮点：用结构体封装自动机，`trie[u][i] = trie[fail[u]][i]`实现路径压缩
   - 代码：43行实现完整AC自动机，空间效率极高
   ```cpp
   else c[u][i] = c[f[u]][i]; // 路径压缩
   ```

2. **yybyyb的注释详解（⭐⭐⭐⭐）**
   - 亮点：详细注释fail指针构建逻辑，适合教学
   - 核心代码段：
   ```cpp
   for(int t=now; t&&AC[t].end!=-1; t=AC[t].fail) // 沿fail链统计
   ```

3. **hyfhaha的图解教学（⭐⭐⭐⭐）**
   - 亮点：手绘Trie树和fail指针示意图，动态演示匹配过程
   - 可视化示例：
   ```text
   [Root]-a-(Node1)-b-(Node2)-c-(Node3)
                | fail          | fail
                v              v
              [Root]         [Root]
   ```

---

### 最优思路提炼
1. **路径压缩**：将缺失的子节点直接映射到fail节点的子节点，避免跳转开销
   ```cpp
   trie[u][i] = trie[fail[u]][i]
   ```
2. **标记剪枝**：匹配后立即将`end`标记设为-1，避免重复统计
3. **队列化构建**：用BFS层序遍历构建fail指针，保证父节点fail已计算

---

### 同类型题目
1. [P3796【模板】AC自动机（加强版）](https://www.luogu.com.cn/problem/P3796)  
   （统计出现次数最多的模式串）
2. [P5357【模板】AC自动机（二次加强版）](https://www.luogu.com.cn/problem/P5357)  
   （Fail树优化统计）
3. [HDU2222 Keywords Search](http://acm.hdu.edu.cn/showproblem.php?pid=2222)  
   （AC自动机最经典模板题）

---

### 可视化设计（复古像素版）

#### 动画流程
```text
1. [Trie构建] 以8-bit风格逐个绘制节点，节点闪烁黄色表示正在插入
   - 插入"abc"时绘制路径：Root→a→b→c（绿色箭头）
   
2. [Fail构建] 用红色箭头动态连接fail指针
   - 节点b的fail→Root时，显示红色闪电特效
   
3. [文本匹配] 文本字符在顶部流动，当前匹配节点高亮为橙色
   - 匹配到c时，沿c→b→Root回溯，路径显示蓝色光晕
```

#### 音效设计
```javascript
// Web Audio API 示例
function playSound(type) {
  const ctx = new AudioContext();
  const osc = ctx.createOscillator();
  osc.frequency.value = type === 'match' ? 880 : 440; // 匹配成功高音
  osc.connect(ctx.destination);
  osc.start(); osc.stop(ctx.currentTime + 0.1);
}
```

#### 交互控制
```html
<canvas id="ac-display"></canvas>
<div class="control-panel">
  <button onclick="stepBuild()">▶️ 单步构建</button>
  <input type="range" id="speed" min="1" max="5">
</div>
```

---

### 核心代码实现
```cpp
struct AC_Automaton {
    int trie[N][26], fail[N], end[N], cnt;
    void insert(char *s) {
        int u = 0;
        for (int i=0; s[i]; i++) {
            int c = s[i]-'a';
            if (!trie[u][c]) trie[u][c] = ++cnt;
            u = trie[u][c];
        }
        end[u]++;
    }
    void build() {
        queue<int> q;
        for (int i=0; i<26; i++)
            if (trie[0][i]) q.push(trie[0][i]);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i=0; i<26; i++) {
                int &v = trie[u][i];
                if (v) {
                    fail[v] = trie[fail[u]][i];
                    q.push(v);
                } else v = trie[fail[u]][i]; // 路径压缩
            }
        }
    }
    int query(char *s) {
        int u = 0, res = 0;
        for (int i=0; s[i]; i++) {
            u = trie[u][s[i]-'a'];
            for (int j=u; j && end[j]!=-1; j=fail[j]) {
                res += end[j];
                end[j] = -1; // 标记剪枝
            }
        }
        return res;
    }
} ac;
```

---

### 关键调试心得
1. **重复模式串处理**：若同一模式多次插入，需用`end[u]++`而非`end[u]=1`
2. **虚根节点映射**：路径压缩时若未处理`trie[0][i]`，会导致根节点子节点错误
3. **Fail指针环路**：需确保`fail[root] = 0`，避免形成循环链

---

通过结合路径压缩与标记剪枝，AC自动机能在O(文本长度 + 总模式长度)时间内完成高效多模式匹配，是处理关键词过滤、病毒特征检测等场景的核心算法。

---
处理用时：82.63秒
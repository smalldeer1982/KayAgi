# 题目信息

# 专心OI - 跳房子

## 题目背景

Imakf 有一天参加了 PINO2017 PJ 组，他突然看见最后一道题：

![](https://cdn.luogu.com.cn/upload/pic/39659.png )

他十分蒟蒻，写不出来。

而如今他还是一个蒟蒻，他又看见一道题：

![](https://cdn.luogu.com.cn/upload/pic/39660.png)

他还是写不出来，于是便来请教您。

## 题目描述

您有 $N$ 个格子，排成一行，从左往右编号为 $1,2,\cdots,N$。您站在 $1$ 号格子的左边无限远，开始从左往右跳，跳到 $N$ 号格子右侧为止。由于您是一位成功的 OIer，您自然长得很胖，所以您的腿部力量也非常大！这使得您跳一次，当前格子到目标格子中间必须至少空出来 $M$ 格，但您可以跳无数格远！

您认为这么跳太没意思了，于是便想计算出有多少种方案可以跳完全程。由于方案可能过多，您会输出方案数量模 $(10^9+7)$ 的值

方案不同当且仅当经过的任一一个格子编号不同。

## 说明/提示

| 测试数据编号 | $N$ | $M$ |  
| :-----------: | :-----------: | :-----------: |
|$1,2$ | $\leq10$ | $=1$ |    
| $3,4$ | $\leq10^7$ | $=1$ |    
| $5,6$ | $\leq10^6$ | $=2$ |  
| $7,8$ | $\leq10^5$ | $=3$ |  
| $9,10$ | $\leq10^4$ | $=5$ |  
| $11,12$ | $\leq10^{12}$ | $=1$ |  
| $13,14$ | $\leq10^{18}$ |$=10$  |  
| $15\sim20$ | $\leq10^{18}$ |  $=15$|  

对于 $100\%$ 的数据，满足 $1 \le N \le 10^{18}$。

## 样例 #1

### 输入

```
5 1 
```

### 输出

```
13
```

## 样例 #2

### 输入

```
6 2 
```

### 输出

```
13
```

# AI分析结果



### 【算法分类】矩阵快速幂

---

### **题解思路与核心难点**

**题目核心**：求解满足跳跃间隔约束的方案数，递推式为 `f(n) = f(n-1) + f(n-M-1)`，需快速计算 `N` 极大时的结果。  
**核心难点**：直接递推时间复杂度为 `O(N)`，无法处理 `1e18` 量级，需通过矩阵快速幂将复杂度降至 `O(M^3 logN)`。  
**解决关键**：构造 `(M+1)x(M+1)` 的转移矩阵，将递推关系映射为矩阵乘法，利用快速幂加速。

---

### **题解评分 (≥4星)**

1. **Imakf (5星)**  
   - **亮点**：从找规律入手，给出矩阵构造的直观示例（如 `M=1` 对应斐波那契数列），代码简洁。  
   - **代码**：矩阵构造清晰，适合快速理解递推关系。  
   ```cpp
   // 矩阵构造示例 (M=2)
   Matrix = {{0,0,1}, {1,0,0}, {0,1,1}};
   ```

2. **Adove (4.5星)**  
   - **亮点**：通过前缀和优化状态转移，矩阵结构更紧凑，代码可读性强。  
   - **关键代码**：  
   ```cpp
   // 构造转移矩阵
   for(int i=1; i<M; i++) G.F[i][i+1] = 1;
   G.F[1][1] = G.F[M][1] = 1;
   ```

3. **刘辰雨 (4星)**  
   - **亮点**：详细注释矩阵构造逻辑，适合矩阵快速幂初学者。  
   - **心得**：强调“特判 `N≤M` 的情况”，避免边界错误。

---

### **最优思路提炼**

1. **矩阵构造模板**  
   - 转移矩阵第一行：`[1, 0, ..., 0, 1]`（对应 `f(n) = f(n-1) + f(n-M-1)`）  
   - 其余行：下移一位的单位矩阵，如第 `i` 行第 `i-1` 列为1。  
   ```python
   # M=3时的矩阵示例
   [
     [1, 0, 0, 1],
     [1, 0, 0, 0],
     [0, 1, 0, 0],
     [0, 0, 1, 0]
   ]
   ```

2. **快速幂优化**  
   - 初始向量为 `[f(0), f(1), ..., f(M)] = [1, 2, ..., M+1]`  
   - 计算 `Matrix^(N-M) * InitialVector` 得到结果。

---

### **相似题目推荐**

1. **P1939 矩阵加速（数列）**  
   - 递推式 `a(n) = a(n-1) + a(n-3)`，需构造3x3矩阵。  
2. **P1306 斐波那契公约数**  
   - 斐波那契数列性质结合矩阵快速幂。  
3. **P1397 矩阵游戏**  
   - 矩阵幂次求和的高级应用。

---

### **可视化与算法演示**

**核心动画设计**：  
1. **矩阵乘法过程**：  
   - 高亮当前计算的矩阵行和列，显示元素相乘累加过程。  
   - 示例：计算 `C[i][j] += A[i][k] * B[k][j]` 时，用红色标记 `A[i][k]` 和 `B[k][j]`。  
2. **快速幂分解**：  
   - 显示指数 `N` 的二进制分解，如 `N=13 → 8+4+1`，逐步展示矩阵平方过程。  

**复古像素风格实现**：  
- **Canvas绘制**：将矩阵元素显示为8x8像素块，颜色表示数值大小（如蓝色=1，黑色=0）。  
- **音效设计**：  
  - 矩阵相乘时播放“哔”声，快速幂每完成一位二进制位播放不同音调。  
- **自动演示模式**：按空格键逐步执行矩阵乘法，Enter键加速播放。

---

### **关键代码实现**

**矩阵快速幂核心代码**（Adove题解优化版）：  
```cpp
struct Matrix {
    int mat[20][20];
    Matrix() { memset(mat, 0, sizeof(mat)); }
    Matrix operator*(const Matrix &rhs) {
        Matrix res;
        for (int k = 0; k <= M; k++)
            for (int i = 0; i <= M; i++)
                for (int j = 0; j <= M; j++)
                    res.mat[i][j] = (res.mat[i][j] + mat[i][k] * rhs.mat[k][j]) % MOD;
        return res;
    }
};

Matrix fast_pow(Matrix base, int power) {
    Matrix res;
    for (int i = 0; i <= M; i++) res.mat[i][i] = 1; // 单位矩阵
    while (power) {
        if (power & 1) res = res * base;
        base = base * base;
        power >>= 1;
    }
    return res;
}
```

---

### **总结**

本题的核心在于将递推关系转化为矩阵形式，并通过快速幂高效计算。矩阵构造需根据 `M` 动态调整，初始条件的正确处理是关键。可视化中通过像素风格和音效增强理解，适合教学演示。

---
处理用时：70.10秒
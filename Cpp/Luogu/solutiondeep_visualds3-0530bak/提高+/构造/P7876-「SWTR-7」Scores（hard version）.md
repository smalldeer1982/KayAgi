# 题目信息

# 「SWTR-7」Scores（hard version）

## 题目背景

#### 本题是 Scores 的 hard 版本。注意题目限制与 [easy](https://www.luogu.com.cn/problem/P7873) 版本不同。

#### 请注意特殊的时空限制。

## 题目描述

小 A 的班上有 $n$ 个学生。最近他们进行了一场考试，共有 $m$ 个学科。第 $i$ 个学生第 $j$ 门学科的得分为**整数** $s_{i,j}\ (0\leq s_{i,j}\leq 100)$。

同学们很重视自己在班上的排名，所以他们经常会比较自己和别的同学的分数。如果一个学生 $i$ **至少有一门学科**的分数比 $j$ **高**，ta 就会觉得自己不比 $j$ 差；相反，如果 ta **每门学科**的分数都比 $j$ **低**，ta 就会觉得自己被 $j$ 吊打了。

实际上，**上述两种情况并不是严格意义上相反的**。但是喜好八卦的小 A 打听到了每两个同学之间的分数情况，他惊讶地发现：**一个同学 $i$ 要么被 $j$ 吊打，要么不比 $j$ 差。** 同时，**如果 $i,j$ 被同一个人吊打，或同时吊打同一个人，则他们之间也有一方被另一方吊打**。我们用一个矩阵 $a_{i,j}\ (i\neq j)$ 来描述小 A 知道的同学们之间的分数关系：$a_{i,j}=0$ 表示 $i$ 被 $j$ 吊打；$a_{i,j}=1$ 表示 $i$ 不比 $j$ 差。

小 A 想知道这种情况会不会发生，即是否存在这样一张 $n\times m$ 的成绩表 $s$ 满足矩阵 $a$ 所描述的分数关系，从而确定有没有撒谎的同学。如果存在 $s$，请先输出 $\texttt{YES}$，再**任意**输出一种符合要求的成绩表；否则输出 $\texttt{NO}$。

注意：这里所求的 $s$ 所需满足的条件是 $a$ 的限制，而**不只是**小 A 所发现的性质，因为**他发现的性质已经在给出的 $a$ 中体现**。

## 说明/提示

**「Special Judge」**

**本题使用 Special Judge。请认真阅读输出格式，输出格式有误可能导致 UKE 或 WA。**

SPJ 首先会判断你的第一行输出是否与答案相同。  
如果相同且答案为 $\texttt{YES}$，则 SPJ 会判断你的输出是否符合所有限制。  
如果有解且你输出 $\texttt{YES}$，但给出方案错误，你将获得该测试点 $50\%$ 的分数。

你需要满足的限制如下：  
- $0\leq s_{i,j}\leq 100$。
- 对于任意 $i,j\ (i\neq j)$，若 $a_{i,j}=0$，则对于任意 $k\ (1\leq k\leq m)$，有 $s_{i,k}<s_{j,k}$；若 $a_{i,j}=1$，则存在一个 $k\in [1,m]$，使得 $s_{i,k}>s_{j,k}$。

你需要注意的是，所有输出都应严格符合输出格式。如果你对答案的存在性判断正确，但是输出方案时 $s_{i,j}<0$ 或 $s_{i,j}>100$，SPJ 会判定为 WA，得 $0$ 分，而不是 $50\%\ \times$ 该测试点分数。

**「数据范围与约定」**

本题共有 6 个测试点。

- Testcase #0（1 point）：是样例。
- Testcase #1（10 points）：$n=1$。
- Testcase #2（10 points）：$m=1$。
- Testcase #3（30 points）：$m=2$。
- Testcase #4（20 points）：$a_{i,j}=1\ (i\neq j)$。
- Testcase #5（29 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,m\leq 100$，$a_{i,j}\in\{0,1\}$，$T=50$（除 Testcase #0）。  
对于 $a$ 的限制：若 $a_{i,j}=a_{i,k}=0$，则 $a_{j,k}$ 和 $a_{k,j}$ 中至少有一个为 $0$；若 $a_{i,k}=a_{j,k}=0$，则 $a_{i,j}$ 和 $a_{j,i}$ 中至少有一个为 $0$。  
对于所有测试点，**时间限制 500ms，空间限制 16MB。**

**「题目来源」**

[Sweet Round 07](https://www.luogu.com.cn/contest/51773) A2。  
idea & solution & data：[Alex_Wei](https://www.luogu.com.cn/user/123294)；验题：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
5
5 3
0 1 1 1 1
1 0 1 1 1
1 1 0 1 1
1 1 1 0 1
1 1 1 1 0
2 7
0 1
0 0
5 4
0 1 1 0 1
0 0 0 0 1
0 1 0 0 1
1 1 1 0 1
1 1 1 1 0
3 1
0 1 1
1 0 1
1 1 0
3 2
0 1 0
0 0 1
1 0 0```

### 输出

```
YES
100 99 97
98 100 99
95 97 100
0 98 100
99 99 99
YES
98 100 94 98 72 53 53
97 99 93 97 71 52 52
YES
90 80 70 60
50 40 30 20
60 50 40 30
100 90 80 70
40 60 80 100
NO
NO```

# AI分析结果



### 算法分类：图论（DAG与拓扑排序）、构造

---

### 题解思路与算法要点

#### **核心难点与解决方案**
1. **传递性检查**  
   - 若存在 `a[i][j]=0` 且 `a[j][k]=0`，则必须 `a[i][k]=0`，否则无解。
2. **分块处理**  
   - 将互相吊打的节点合并为块，块内成员形成严格链式结构（类似DAG的拓扑链）。
3. **排名构造**  
   - 块内成员按吊打关系确定唯一排名，确保无重复。
4. **分数构造**  
   - 块间通过不同学科的分段分配（如第一科递减、第二科递增）避免相互吊打。
   - 块内成员分数按排名递减，确保块内吊打关系。

#### **关键步骤实现**
- **传递性检查**：遍历所有三元组 `(i,j,k)`，验证吊打关系的传递性。
- **并查集分块**：合并互相吊打的节点，形成独立块。
- **拓扑排序**：确定每个块内部的排名，若存在环则无解。
- **分数分配**：
  - 块间：按块顺序分配第一科分数递减，第二科分数递增。
  - 块内：根据排名调整分数，确保块内严格递减。

---

### 题解评分（≥4星）

1. **by_chance（5星）**  
   - **亮点**：分测试用例处理，代码清晰，构造方案直观。  
   - **核心代码**：通过并查集分块，块内按排名构造分数，块间用学科分隔。

2. **enucai（4星）**  
   - **亮点**：深入分析图结构为链式DAG，构造两门学科分数分隔块。  
   - **关键思路**：验证链式结构合法性，分块构造二元组分数。

3. **intel_core（4星）**  
   - **亮点**：拓扑排序确定层级，用多学科分配避免冲突。  
   - **优化点**：通过层级分配分数，处理块间关系。

---

### 最优思路与技巧

1. **并查集分块**  
   - 将互相吊打的节点合并为独立块，块内形成严格排名。
2. **两门学科分隔块**  
   - 第一科分数按块顺序递减，第二科递增，确保块间无吊打关系。
3. **传递性检查**  
   - 提前验证所有三元组是否满足吊打传递性，避免无效构造。

---

### 类似题目

1. **P1347 排序**  
   - 传递性验证与拓扑排序。
2. **P1983 车站分级**  
   - 构造隐含的层级关系，分块处理。
3. **P2741 [USACO4.4] 重叠的图像Frame Up**  
   - 图论分块与构造输出。

---

### 可视化设计思路

#### **动画演示**
1. **分块与传递性检查**  
   - **颜色标记**：红色节点表示当前检查的三元组，绿色箭头表示合法传递。
   - **动态网格**：显示节点间的吊打关系，非法传递时闪烁警告。
2. **拓扑排序与分数分配**  
   - **步进操作**：单步展示拓扑排序过程，层级逐步分配。
   - **分数填充**：按块用不同颜色填充学科分数，高亮当前分配的块。
3. **复古像素风格**  
   - **8位调色板**：用16色像素块表示节点，箭头表示吊打关系。
   - **音效**：传递合法时播放“叮”声，非法时播放“哔”声。

#### **代码片段（关键逻辑）**
```cpp
// 分块与拓扑排序
for(int i=1; i<=n; i++) fa[i] = i;
for(int i=1; i<=n; i++)
    for(int j=1; j<=n; j++)
        if(a[i][j] == 0) merge(i, j); // 并查集分块

// 分数分配
int sum = 0;
for(int block : blocks) {
    int leader = getLeader(block);
    ans[leader][1] = 100 - sum; // 第一科递减
    ans[leader][2] = sum;       // 第二科递增
    for(int member : block) {
        ans[member][1] = ans[leader][1] - rank[member];
        ans[member][2] = ans[leader][2] + rank[member];
    }
    sum += block.size();
}
```

---

### 个人心得

- **传递性陷阱**：初始未考虑三元组检查，导致构造错误。
- **分数溢出**：块数过多时需调整间隔，保证分数在0~100内。
- **分块优化**：用并查集替代DFS分块，提高效率。

---

### 结论

通过分块处理与两门学科的分隔构造，确保吊打关系的严格传递与合法性。传递性检查与拓扑排序是关键步骤，构造需注意分数范围控制。

---
处理用时：85.78秒
# 题目信息

# 「SvR-1」Hack Function!

## 题目背景

**Problem Number:** $\textit{63}$

小 C 坐在 J-PSC2077 的赛场（题目可于下方「**题目附件**」处下载）上，他早已年逾七旬，但作为 Z 队选手还是成功参赛。

## 题目描述

此时的 J-PSC 终于改成了 CF 赛制，小 C 迅速地 AK 了 Day 1，他发现 T2 function 比较好 Hack，题目的人话翻译如下：

> 对于一个数 $A$，定义函数 $f(A)$ 如下：
> 
> 1. 先把 $A$ 变成 $k$ 进制数 $B$。
> 2. 将 $A$ 替换为 $B$ 各位之和。
> 3. 返回执行第 1 步，直到 $B$ 是一位数为止。
> 4. 记 $x$ 表示 $A$ 此时的值（十进制）。
> 此时 $f(A) = x$，$f(A)$ 称作 $A$ 关于 $k$ 的**位和函数**。
>
> 给定 $k, l, r, p$，求出 $\sum_{i = l}^r f(i^i) \bmod p$ 的值。
>
> **特别地，当 $\sum_{i = l}^r f(i^i) = p$ 时，输出 $\texttt{perfect}$。**

小 C 迅速秒了该题，当他翻看别人的代码时，发现他们用的全是暴力枚举。（因为机子跑得飞快）

好不容易看到一个人，他的代码里竟然没有一个  $\texttt{perfect}$！但由于数据过弱，竟然让他 pp 了。

小 C 突然脑子一热，忘记了怎么构造 Hack 数据，所以他通过 Luogu 6.0 求助于你。

小 C 会告诉你 $k, p$ 的值，你需要构造一组 $l, r$，**使答案输出为 $\texttt{perfect}$**。

**若无法构造，输出两个 $\texttt{-1}$。**

## 说明/提示

#### 样例 1 说明

- 对于数据 $1$，在 $k = 10$ 下，有 $f(2^2) = f(4) = 4$，$f(3^3) = f(27) = 9$，显然 $l = 2, r = 3$ 时原题应该输出 $\texttt{perfect}$。
- 对于数据 $2$，在 $k = 10$ 下，发现不可能满足要求。
- 对于数据 $3$，在 $k = 2$ 下，显然有 $f(1^1) = 1$，但该样例仅用于理解，根据数据规模与约定，我们保证 $k \geq 10$。

#### 数据规模与约定

$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c|c}\hline\hline
\textbf{Subtask} & \textbf{说明} & \textbf{时限} & \textbf{分值} \\\hline
\textsf{1} & \text{无解} & 1\text{ s} & 3 \\\hline
\textsf{2} & \text{有解且\textbf{\textsf{存在}}一组解使 }1\le l\le r\le 10^5 & 1\text{ s} & 16 \\\hline
\textsf{3} & 1\le p\le 10^7 & 1\text{ s} & 34 \\\hline
\textsf{4} & \text{无特殊限制} & 1.5\text{ s} & 47 \\\hline\hline
\end{array}
$$

对于 $100\%$ 的数据，$10 \leq k \leq 10^3$，$1 \leq p \leq 10^8$，$1 \leq T \leq 10$。

保证时限在 std 用时的 $4$ 倍以上。

#### 评测说明

**本题开启 Special Judge 和捆绑测试。**

你需要保证 $l = r = -1$ 或 $1 \leq l \leq r \leq 10^{18}$ 且 $r - l \leq 10^{15}$，否则 SPJ 会将你的答案判为 $0$ 分。

## 样例 #1

### 输入

```
3
10 13
10 3
2 1```

### 输出

```
2 3
-1 -1
1 1```

# AI分析结果



---

**唯一算法分类**  
数学（数论与模运算）

---

**综合分析与结论**  

本题核心在于利用数论推导将复杂函数转化为模运算，并通过循环节优化计算。主要解决步骤如下：

1. **关键推导**  
   发现 $f(A) = (A-1) \bmod (k-1) + 1$，将问题转化为计算 $i^i \bmod (k-1)$。

2. **循环节分析**  
   利用扩展欧拉定理，当 $i > \phi(k-1)$ 时，$i^i \bmod (k-1)$ 呈现周期性，循环节长度 $L = \text{lcm}(k-1, \phi(k-1))$。

3. **分治策略**  
   - **前半段**（$i \leq \phi(k-1)$）：暴力计算  
   - **后半段**（循环节部分）：预处理一个完整周期的和，通过模运算快速计算多周期贡献。

4. **区间搜索优化**  
   使用哈希表或双指针法快速查找满足 $\sum g(i) = p$ 的区间，避免暴力枚举。

**可视化设计思路**  
- **动画流程**：  
  1. 展示 $i$ 的递增，计算 $i^i \bmod (k-1)$ 并调整结果（红色高亮当前值）。  
  2. 绘制循环节起点（$\phi(k-1)+1$）和周期长度（绿色框标记）。  
  3. 动态显示前缀和数组，当哈希表命中或双指针找到区间时，高亮对应区间（黄色闪烁）。  
- **复古像素风格**：  
  - 用 8-bit 像素块表示数值，不同颜色区分模值（蓝：普通值，红：调整后的 $k-1$）。  
  - 背景音乐采用循环芯片音效，命中时播放胜利音效（类似《超级马里奥》金币声）。  

---

**题解清单 (≥4星)**  

1. **CSP_Sept（★★★★☆）**  
   - **亮点**：完整分类讨论，利用哈希表快速匹配差值，代码结构清晰。  
   - **核心代码**：预处理循环节和哈希查询逻辑。  
   ```cpp
   // 预处理循环节前缀和
   for (int j = 1; j <= m; j++) {
     sum2[j] = sum2[j-1] + ((quick_pow(j+n, j%n +n, kd)-1)%kd + kd)%kd +1;
   }
   // 哈希查询
   if (mp2.count(p - (t + (sum1[n] - sum1[x-1])))) {
     ansl = x; 
     ansr = n + j*m + mp2.query(...);
   }
   ```

2. **yizhiming（★★★★★）**  
   - **亮点**：双指针法替代哈希表，避免内存开销，代码更简洁。  
   - **核心逻辑**：  
     ```cpp
     while (sum > p) sum -= f[l++];  // 左指针移动
     if (sum == p) { ok = 1; break; }
     ```

3. **kevinzheng0426（★★★★☆）**  
   - **亮点**：结合前缀和与模运算优化，明确分治策略。  
   - **关键步骤**：  
     ```cpp
     // 计算循环节总和
     for (int i=0; i<k; i++) S += F[phi+i] = f(phi+i);
     // 模匹配搜索
     if (mp.find(mL) != mp.end()) { ... }
     ```

---

**最优思路与技巧**  

- **数论压缩**：将位和函数转化为模运算，极大简化计算。  
- **循环节分治**：利用扩展欧拉定理分解问题，避免大数计算。  
- **双指针/哈希表**：快速定位区间和，时间复杂度从 $O(n^2)$ 降至 $O(n)$。  

---

**同类型题目推荐**  
1. **P1465** - 循环节与模运算应用  
2. **P1965** - 扩展欧拉定理实战  
3. **P3197** - 双指针法求区间和  

---

**个人心得摘录**  

> "在调试时发现循环节处理必须覆盖两个完整周期，否则会漏掉某些边界情况。" —— yizhiming  
> "哈希表键设计为模值而非原始和，大幅减少查询次数。" —— kevinzheng0426  

---

**可视化与复古游戏化实现**  

```javascript
// 伪代码：Canvas绘制循环节与双指针
function drawFrame() {
  ctx.fillStyle = '#8B0000'; // 深红背景
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // 绘制i值方块
  for (let i = 0; i < currentI; i++) {
    const x = (i % 20) * 30;
    const y = Math.floor(i / 20) * 30;
    ctx.fillStyle = (i < phi) ? '#00FF00' : '#FFD700'; // 绿：前半，金：循环
    ctx.fillRect(x, y, 28, 28);
    ctx.fillStyle = '#FFF';
    ctx.fillText(g(i), x+10, y+20); // 显示g(i)
  }
  
  // 高亮当前指针
  ctx.strokeStyle = '#FF0000';
  ctx.strokeRect((leftPtr % 20)*30, Math.floor(leftPtr/20)*30, 28, 28);
  ctx.strokeStyle = '#00FFFF';
  ctx.strokeRect((rightPtr % 20)*30, Math.floor(rightPtr/20)*30, 28, 28);
  
  // 播放音效
  if (sum === p) playSound('win.wav');
}
```

**交互设计**  
- **方向键**：手动控制指针移动速度。  
- **A键**：自动演示，算法模拟双指针移动。  
- **音效**：命中时播放8-bit胜利旋律，超限则播放低沉错误音。  

---

**代码片段**  

yizhiming的双指针核心逻辑：  
```cpp
int main() {
  // ...
  for (r = 1; r <= rmax; r++) {
    sum += f[r];
    while (sum > p) sum -= f[l++];
    if (sum == p) { ok = 1; break; }
  }
  // 处理循环节
  bei = (p - sum) / xhs;  // 计算完整周期数
  sum += bei * xhs;
  r += bei * lcm;
  // ...
}
```

---

**总结**  
通过数论推导与循环节分治，结合高效搜索策略，将看似复杂的区间求和问题转化为可高效计算的形式。可视化设计通过复古像素风格和动态指针演示，直观展现算法核心流程。

---
处理用时：83.10秒
# 题目信息

# [THUPC 2023 初赛] 速战速决

## 题目描述

小 I 与小 J 正在玩一个叫做“开火车”，又称作“拖板车”和“小猫钓鱼”的扑克游戏。游戏规则如下，注意其与一般玩法可能有不同：

- 有 $2n$ 张牌，其中对于整数 $1 \le i \le n$，牌面为 $i$ 的牌恰好有 $2$ 张。
- 游戏开始时，小 I 和小 J 各拿其中 $n$ 张牌组成双方的初始手牌。
- 维护一个公共牌堆（可以将其看作一个栈），初始没有牌。小 I 与小 J 依次行动，小 I 先手。一次行动时，行动方依次进行以下操作：
  1. 将手牌中的一张牌放在公共牌堆顶；
  2. 若此时公共牌堆中有两张相同的牌，则这两张相同的牌以及在这两张牌之间的所有牌从公共牌堆移到当前行动方手牌中；
  3. 若此时当前行动方没有手牌，则当前行动方失败，另一方胜利。

小 J 是扑克萌新，所以会按照以下策略行动：

- 维护一个队列，初始将 $n$ 张手牌按照一定顺序放入队列中；
- 每次行动时，将队列开头的牌放在公共牌堆顶；
- 若小 J 放入某张牌后公共牌堆中有两张相同的牌，则按照在公共牌堆中自顶到底的顺序将获得的牌放入队列尾。

小 I 通过偷看得到了小 J 的策略以及队列中牌的顺序。现在小 I 不仅想获胜，还想速战速决，用**最少**的行动次数获胜，但他也是扑克萌新。所以给定小 J 队列中的 $n$ 张牌以及它们的顺序，你需要给出小 I 的策略，使得小 I 能够获胜，同时行动次数最少，或者告诉他这是不可能的。

## 说明/提示

#### 样例解释 1

![](https://cdn.luogu.com.cn/upload/image_hosting/m1asrjdd.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/x5w65xlc.png)

#### 子任务

对于所有测试数据，$1 \le n \le 3 \times 10^5$，$1 \le a_1,a_2,\cdots, a_n \le n$，且每个整数在序列 $a$ 中至多出现两次。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
3
1 3 3
```

### 输出

```
3
2 1 2
```

## 样例 #2

### 输入

```
1
1```

### 输出

```
-1```

# AI分析结果



**唯一算法分类**：贪心策略/构造

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **小I初始手牌情况分类**：
   - **存在重复牌（对子）**：通过及时收牌保持栈底控制权，确保小J无法回收牌，总行动次数为n。
   - **无重复牌（排列）**：构造特定出牌顺序，迫使小J只能回收一次，总行动次数为n+2。

2. **关键策略**：
   - **对子控制栈底**：若小I有对子k，先打出一张k作为栈底。之后每次小J出牌时，若可能形成匹配，则立即用另一张k收走所有牌，维持栈底始终为小I的牌。
   - **排列情况构造**：当小J的牌是排列时，小I首轮打小J的最后一张牌，随后每轮跟牌，最终用两张相同牌夹击小J的剩余牌。

#### **解决难点**
- **避免小J收牌**：需在每次小J可能形成匹配前主动收牌，需高效维护当前牌堆状态及手牌分布。
- **时间复杂度优化**：通过队列和数组直接跟踪牌的位置，而非动态查询，确保O(n)时间复杂度。

#### **算法实现要点**
- **数据结构**：使用队列维护小J的出牌顺序，数组`cnt[]`记录每张牌剩余数量，栈模拟公共牌堆。
- **收牌逻辑**：当检测到小J的当前牌可能形成匹配时，立即用栈底牌收走整个牌堆。

---

### **题解评分（≥4星）**
1. **Yikuwa（5星）**  
   - **亮点**：分类清晰，构造策略直接，代码简洁高效。利用队列和数组快速判断收牌条件。
   - **代码片段**：  
     ```cpp
     if (cnt[a[i]] == 2) { // 存在对子
         Push(Ans[i] = s[1]); // 用栈底牌收走所有牌
         Pop(); // 维护队列和栈状态
     }
     ```

2. **Leasier（4星）**  
   - **亮点**：详细讨论不同情况，代码中维护`set`动态管理手牌，逻辑严谨。
   - **代码片段**：  
     ```cpp
     if (vis[a[i]] || s.count(a[i])) { // 若可能形成匹配
         cout << stk[1]; // 收走牌堆
         while (top--) { ... } // 清空栈
     }
     ```

3. **听取MLE声一片（4星）**  
   - **亮点**：提出随机出牌策略避免复杂判断，代码实现简单但存在效率风险。
   - **代码片段**：  
     ```cpp
     int k = rand() % n + 1; // 随机选择不冲突的牌
     while (p[k] == 0 || k == q[1]) k = rand() % n + 1;
     ```

---

### **最优思路与技巧提炼**
- **栈底控制法**：利用对子作为栈底，主动收牌打破小J的匹配机会。
- **队列跟牌策略**：在小J出排列时，按顺序跟牌并构造夹击。
- **数据结构优化**：用数组代替哈希表记录牌状态，提升访问效率。

---

### **同类型题与算法套路**
- **类似问题**：括号匹配（贪心维护栈）、俄罗斯农民乘法（构造性操作）。
- **通用解法**：通过预判对方策略构造最优操作序列，常用贪心或模拟。

---

### **推荐相似题目**
1. **P1003 铺地毯**（贪心构造覆盖顺序）
2. **P1090 合并果子**（优先队列维护最优合并）
3. **P1036 选数**（DFS+剪枝模拟组合）

---

### **可视化与算法演示**
1. **动画设计**：
   - **栈动态变化**：用垂直排列的方块表示栈，新牌从顶部压入，收牌时高亮匹配的牌并清空区间。
   - **颜色标记**：小I的牌用蓝色，小J的牌用红色，匹配时闪烁黄色。
   - **步进控制**：支持暂停/继续，拖动进度条观察每步栈和队列状态。

2. **复古像素风格**：
   - **8位色块**：栈用绿色像素块，手牌用不同颜色区分。
   - **音效设计**：收牌时播放“叮”音效，胜利时播放经典FC过关音乐。

3. **交互面板**：  
   ```html
   <canvas id="game"></canvas>
   <div id="controls">
     <button onclick="prevStep()">←</button>
     <button onclick="togglePlay()">⏯</button>
     <button onclick="nextStep()">→</button>
   </div>
   ```

---

### **代码实现（核心逻辑）**
**Yikuwa的关键代码**：  
```cpp
void solve() {
    int lst = find_initial_pair(); // 找到小I的初始对子
    queue<int> q = init_hand();     // 初始化小I手牌队列
    
    Push(lst); // 首轮打出对子
    for (int i = 1; i < n; i++) {
        Push(a[i]); // 小J出牌
        if (need_collect(a[i+1])) { // 检测是否需要收牌
            Pop(lst); // 用栈底牌收走所有牌
        } else {
            play_safe_card(q); // 随机出安全牌
        }
    }
}
```

---

### **总结**
本题通过分类讨论和贪心策略，利用数据结构高效维护状态，最终在O(n)时间内构造最优解。核心在于及时收牌打破对方策略，可视化设计可大幅提升理解效率。

---
处理用时：80.46秒
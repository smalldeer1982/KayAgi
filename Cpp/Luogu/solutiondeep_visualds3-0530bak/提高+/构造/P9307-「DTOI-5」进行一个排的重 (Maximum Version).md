# 题目信息

# 「DTOI-5」进行一个排的重 (Maximum Version)

## 题目背景

**本题与 Minimum Version 的区别是所求最值和数据范围不同。**

小 L 热衷于重排数列使之规整。

## 题目描述

小 L 有一个长为 $n$ 的序列 $a$，其中每一项 $a_i$ 都是一个 pair $(p_i, q_i)$。

为了让 $a$ 看起来规整一些，他钦定 $p, q$ 分别均为长为 $n$ 的排列。

为了对 $a$ 的规整程度进行量化计算，他给出了一个权值函数 $f(a) = \displaystyle\sum_{i = 1}^n ([p_i > \max_{j = 1}^{i - 1} p_j] + [q_i > \max_{j = 1}^{i - 1} q_j])$。**注意 $i = 1$ 时两个方括号都能取到值，因为我们认为 $\displaystyle\max_{j = 1}^0 p_j = \displaystyle\max_{j = 1}^0 q_j = -\infty$。**

为了让 $a$ 看起来更加规整，他决定分别以某种方式重排 $a$ 得到 $a'$ 使得 $f(a')$ 最大。**注意重排时必须将 $a'_i = (p'_i, q'_i)$ 视为整体。**

他希望你求出 $f(a')_{\max}$ 的值，以及分别有多少个 $a'$ 可以取到 $f(a')_{\max}$。

由于方案数可能很大，你只需要求出结果对 $998244353$ 取模的值。

## 说明/提示

**【数据范围】**

$$
\def\or{\operatorname{or}}
%\def\arrayscretch{1.5}
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Subtask}&n\le &\textbf{Points}\cr\hline
\sf1&10&10 \operatorname{pts}\cr\hline
\sf2&50&20 \operatorname{pts}\cr\hline
\sf3&500&20 \operatorname{pts}\cr\hline
\sf4&2\times 10^3&20 \operatorname{pts}\cr\hline
\sf5&/&30 \operatorname{pts}\cr\hline
\end{array}
$$
对于 $100\%$ 的数据，$1 \leq n \leq 10^4$，$1 \leq p_i, q_i \leq n$，保证 $p, q$ 均为**排列**。

## 样例 #1

### 输入

```
5
1 5 2 4 3
1 4 2 5 3```

### 输出

```
9 2```

# AI分析结果



---

## **算法分类**  
动态规划

---

## **题解思路与核心难点**  

### **关键思路对比**  
1. **Leasier 题解**  
   - **核心思想**：将序列按 $p$ 升序排列后，转化为求 $q$ 的最长递增子序列（LIS）。  
   - **贡献拆分**：每个元素的贡献为 $1$（仅 $p$ 产生贡献）或 $2$（$p$ 和 $q$ 均产生贡献）。最优方案下，LIS 中的元素贡献为 $2$，其他元素贡献为 $1$，总贡献为 $n + \text{LIS长度}$。  
   - **方案数计算**：通过动态规划统计满足 LIS 结构的排列方式，结合组合数学计算插入顺序的可能数。  

2. **_edge_ 题解**  
   - **核心思想**：二维动态规划维护当前 $p$ 和 $q$ 的最大值，强制每一步至少产生一个贡献。  
   - **转移优化**：通过双指针和前缀和优化状态转移，但复杂度较高（$O(n^3)$ 或更高），难以通过大数据。  

**核心难点**：  
- 如何证明最优贡献结构必然与 LIS 相关。  
- 如何高效统计满足条件的排列数，避免组合爆炸。  

---

## **题解评分与亮点**  
✅ **Leasier 题解（5⭐）**  
- **思路清晰度**：通过数学证明将问题转化为 LIS，逻辑严谨。  
- **代码可读性**：结构清晰，预处理阶乘和逆元优化组合计算。  
- **优化程度**：利用前缀和优化 DP，复杂度 $O(n^2)$。  

❌ **_edge_ 题解（3⭐）**  
- **实现复杂度**：二维 DP 状态和转移条件复杂，难以调试。  
- **性能问题**：未完全优化，无法通过 $n \geq 10^4$ 的数据。  

---

## **最优思路提炼**  
1. **贪心策略**：按 $p$ 升序排列后，$p$ 的前缀最大值必然递增，此时只需最大化 $q$ 的前缀最大值次数。  
2. **LIS 关键性**：$q$ 的 LIS 中的元素贡献为 $2$，其余元素贡献为 $1$。  
3. **组合数学优化**：方案数统计时，利用组合数计算非 LIS 元素的插入方式，避免重复计算。  

---

## **同类型题与算法套路**  
- **通用套路**：将二维问题降维（如固定一维后处理另一维）或转化为经典问题（如 LIS）。  
- **相似题目**：  
  1. **洛谷 P1439**：最长公共子序列（转化为 LIS）。  
  2. **洛谷 P1020**：导弹拦截（LIS 应用）。  
  3. **Codeforces 1142B**：动态维护排列与贡献计算。  

---

## **代码核心逻辑**  
```cpp  
// Leasier 题解关键代码  
sort(pr + 1, pr + n + 1);  // 按 p 升序排序  
pr[ni].second = ni;        // 添加哨兵  

// 计算 LIS 长度  
for (int i = 1; i <= ni; i++) {  
    for (int j = 1; j < i; j++) {  
        if (pr[i].second > pr[j].second)  
            dp1[i] = max(dp1[i], dp1[j]);  
    }  
    dp1[i]++;  
}  

// 方案数动态规划  
dp2[ni] = 1;  
for (int i = n; i >= 0; i--) {  
    for (int j = i + 1; j <= ni; j++) {  
        if (pr[j].second > pr[i].second && dp1[j] == dp1[i] + 1) {  
            // 计算组合数并更新 dp2  
            dp2[i] = (dp2[i] + dp2[j] * comb(...)) % mod;  
        }  
    }  
}  
```

---

## **可视化设计思路**  
### **动画演示**  
1. **排序与 LIS 标记**：  
   - 将序列按 $p$ 升序排列，用绿色高亮 LIS 中的元素。  
   - 逐步显示每个元素是否成为 $q$ 的前缀最大值。  

2. **动态规划过程**：  
   - 用滑动窗口展示 `dp2` 的倒序更新，红色箭头表示状态转移。  
   - 显示组合数计算的插板法过程（如将元素分为两组插入）。  

### **复古像素风格**  
- **颜色方案**：  
  - LIS 元素：绿色（#00FF00）  
  - 转移路径：黄色（#FFFF00）  
  - 组合数计算区域：蓝色（#0000FF）  
- **音效设计**：  
  - 元素插入时播放“哔”声（Web Audio API）。  
  - LIS 更新时播放“叮”声。  

---

## **个人心得摘录**  
> “在调试组合数时，发现未正确处理阶乘逆元的预处理，导致方案数计算错误。最终通过单独初始化阶乘数组解决。” —— Leasier  

---

## **总结**  
本题通过贪心策略和动态规划巧妙地将二维问题转化为 LIS 问题，结合组合数学优化方案数统计。Leasier 的解法在理论和实现上均优于其他思路，是典型的高效算法设计范例。

---
处理用时：73.53秒
# 题目信息

# 「TAOI-2」喵了个喵 Ⅳ

## 题目背景

小 S 共有 $n$ 只可爱的喵喵，第 $i$ 只喵喵有可爱度 $a_i$。小 S 想要把他的喵喵分成两组。考虑到小 S 的喵喵不像某些喵喵有九条命，他的喵喵只有一条，于是一只喵喵不能被同时分到两组内（请不要试图想象这个画面）。同时，如果一只喵喵没有被分到任意一组，他就会十分生气，很有可能导致小 S 失眠。

当然，小 S 也希望两组的**组可爱度**相等。即存在一个正整数 $x$，使得其中一组的 $\gcd(x, a_i)$ 之和等于另一组的 $\gcd(x, a_i)$ 之和。请你判断是否可以使得小 S 可以将喵喵分成两组，并可以找出一个 $x$ 使得两组的**组可爱度**相等。

## 题目描述

给定正整数 $n$ 及长度为 $n$ 的正整数序列 $a$，请你将 $a$ 划分为两个集合 $B, C$ 并给出正整数 $x$，使得 $\sum_{y\in B}\gcd(x,y) = \sum_{y\in C}\gcd(x,y)$。如果无解，输出 $-1$。

你需要保证 $1 \leq x \leq 10^9$，保证在本题的数据约束下若有解则总有 $x \leq 10^9$ 的解。

## 说明/提示

**本题采用捆绑测试。**

+ Subtask 0（2 pts）：$n$ 为偶数。
+ Subtask 1（8 pts）：$a_i$ 均为奇数。
+ Subtask 2（15 pts）：$n \leq 50$，$a_i \leq 50$。
+ Subtask 3（25 pts）：$n \leq 10^3$，$a_i \leq 10^3$。
+ Subtask 4（50 pts）：无特殊限制。

对于所有数据，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^6$。

## 样例 #1

### 输入

```
3
1 1 1```

### 输出

```
-1```

## 样例 #2

### 输入

```
4
4 1 2 3```

### 输出

```
3
0001
```

# AI分析结果



# 题解分析：喵了个喵Ⅳ

---

## **算法分类**  
**数学构造**

---

## **题解思路与核心难点**

### **题目核心**
将数组划分为两组，存在正整数x使得两组$\gcd(x,a_i)$之和相等。关键点在于选择合适的x并合理分组。

### **题解对比与要点**
1. **Register_int的题解**  
   - **思路**：  
     - 处理n为偶数的情况，直接取x=1均分。
     - 对n为奇数的情况，通过计算最小lowbit，将所有数除以该值转化为奇偶性问题。
     - 确保处理后数组有偶数个奇数，再取x=2的幂分组。
   - **关键实现**：  
     ```cpp
     k = min(k, __lg(a[i] & -a[i])); // 计算最小lowbit的二进制位数
     a[i] >>= k; // 所有数除以最小lowbit
     ```
   - **亮点**：通过lowbit快速定位公共因子，简化问题。

2. **喵仔牛奶的题解**  
   - **思路**：  
     - 先约去最大公约数d，再处理奇偶性。
     - 若n为奇数且有偶数个奇数，则取x=2并合理分配。
   - **关键实现**：  
     ```cpp
     for (int i = 1; i <= n; i++) a[i] /= d; // 约去最大公约数
     ```
   - **亮点**：通过约去gcd避免冗余计算。

3. **TernaryTree的题解**  
   - **思路**：  
     - 直接取x=2，分析奇偶数量。
     - 若奇数数量为偶数，则分组时用两个奇数合成一个偶数。
   - **关键实现**：  
     ```cpp
     for (int i = 0; i < odd.size() / 2 - 1; i++) ans[odd[i]] = 1; // 分配奇数
     ```
   - **亮点**：通过奇偶转化构造平衡和。

### **解决难点**  
- **关键推导**：  
  - 当n为奇数时，必须保证$\sum \gcd(x,a_i)$为偶数，否则无法分割。
  - 通过除以最大公约数或lowbit，将问题转化为奇偶分配问题。
- **实现优化**：  
  - 使用lowbit快速定位二进制最低位的1，避免暴力枚举。
  - 分组时动态调整奇偶数的分配，保证总和相等。

---

## **题解评分 (≥4星)**
1. **Register_int的题解**（5星）  
   - 思路清晰，代码简洁，直接定位lowbit优化问题。
2. **TernaryTree的题解**（4星）  
   - 详细分析奇偶性，但代码稍复杂。
3. **One_JuRuo的题解**（4星）  
   - 通过递归处理全偶数情况，逻辑严谨。

---

## **最优思路提炼**
1. **数学构造核心**  
   - **步骤1**：若n为偶数，直接取x=1均分。
   - **步骤2**：若n为奇数，计算所有数的lowbit最小值，将所有数除以该值，转化为奇偶问题。
   - **步骤3**：若处理后奇数数量为偶数，则取x=2的幂，将奇偶合理分组。
2. **关键技巧**  
   - 利用二进制lowbit快速定位公共因子。
   - 奇偶数的动态分配策略（如两个奇数合成一个偶数）。

---

## **类似题型推荐**
1. **洛谷P1031** [均分纸牌](https://www.luogu.com.cn/problem/P1031)  
   （分割数组使相等）
2. **洛谷P2217** [分割矩阵](https://www.luogu.com.cn/problem/P2217)  
   （数学分割问题）
3. **洛谷P6189** [NOI Online 跑步](https://www.luogu.com.cn/problem/P6189)  
   （构造性分组问题）

---

## **个人心得摘录**
- **调试教训**：全偶数情况需递归除以2直到出现奇数，否则无法构造解。
- **顿悟时刻**：x的奇偶性直接决定总和奇偶性，需优先处理。

---

## **可视化与算法演示**
### **动画设计**
1. **核心流程**  
   - **步骤1**：展示计算lowbit的过程，高亮每个数的二进制最低位。
   - **步骤2**：将所有数除以lowbit，转化为奇偶数组。
   - **步骤3**：动态分配奇偶数到两组，用颜色区分操作。

2. **复古像素风格**  
   - **颜色方案**：奇数为红色，偶数为蓝色，lowbit计算时闪烁黄光。
   - **音效**：分组成功时播放8-bit胜利音效，失败时播放低沉音效。

3. **交互设计**  
   - **控制面板**：支持暂停/继续，单步执行观察二进制处理。
   - **自动模式**：AI自动执行lowbit计算与分组，类似贪吃蛇AI路径。

### **代码片段（Canvas绘制）**
```javascript
// 伪代码：绘制lowbit处理过程
function drawLowbitProcess(a) {
  let minLowbit = Math.min(...a.map(x => x & -x));
  a.forEach(num => {
    let pos = getGridPosition(num);
    drawPixel(pos.x, pos.y, 'yellow'); // 高亮lowbit位
    num /= minLowbit;
    drawNumber(num); // 更新为奇偶形式
  });
}
```

---

## **完整代码**
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, k = 20;
    scanf("%d", &n);
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
        k = min(k, __builtin_ctz(a[i])); // 计算最小lowbit的二进制位数
    }
    for (int &num : a) num >>= k; // 所有数除以lowbit
    
    if (n % 2 == 0) {
        printf("1\n");
        for (int i = 0; i < n/2; i++) printf("01");
    } else {
        int cnt = count_if(a.begin(), a.end(), [](int x){ return x % 2; });
        if (cnt % 2 != 0) {
            printf("-1");
            return 0;
        }
        printf("%d\n", 2 << k);
        int half = cnt / 2;
        for (int num : a) {
            if (num % 2 && half-- > 0) printf("0");
            else printf("1");
        }
    }
    return 0;
}
```

---
处理用时：83.04秒
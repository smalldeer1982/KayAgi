# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！

## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果



## 算法分类
**枚举与模拟**

---

## 题解思路、算法要点与解决难点

### 核心思路
- **双重枚举**：枚举可能的罪犯和日期，验证每个组合下证词是否自洽。
- **证词处理**：分离有效证词（身份声明、日期声明），忽略无效内容。
- **矛盾检测**：检查同一人是否存在真/假证词混合的矛盾情况。
- **浮动人数处理**：未说话者的真伪状态可浮动，统计假话人数范围是否覆盖给定的N。

### 数据结构与关键变量
- `map<string, int>`：快速映射人名/日期到索引。
- `vector<sta>`：存储结构化证词（主语、是否日期、是否否定）。
- **矛盾标志**：发现矛盾时快速终止当前枚举。
- **假话计数器**：统计确定说假话的人数，结合浮动范围判断合法性。

---

## 题解评分（≥4星）
1. **wjyyy（5星）**  
   - 使用STL简化数据管理，逻辑清晰。
   - 预处理合法证词，高效处理矛盾。
   - 代码结构模块化，可读性强。

2. **Ebola（4星）**  
   - 输入处理细致，`gl`函数处理复杂证词。
   - `judge`和`check`分离，逻辑分层明确。
   - 但字符串拼接可能带来性能隐患。

3. **Sanust（4星）**  
   - 证词结构化存储，类型判断精准。
   - 处理输入换行符等细节完善。
   - 代码注释详细，便于理解。

---

## 最优思路提炼
1. **双重枚举框架**  
   ```cpp
   for (罪犯枚举) {
     for (日期枚举) {
       验证所有证词是否自洽;
       统计假话人数并判断浮动范围;
     }
   }
   ```
2. **证词结构化解析**  
   - 将证词分解为（主语，类型，是否否定）三元组。
   - 预处理时过滤无效内容，减少运行时判断。

3. **浮动假话人数计算**  
   - 未说话者贡献假话人数的可能范围：`[当前假话数, 当前假话数 + 未说话人数]`。

---

## 同类型题与算法套路
- **枚举验证**：常见于逻辑推理题，如P1003（铺地毯）、P1036（选数）。
- **结构化输入处理**：类似P1019（单词接龙）的字符串分解。

---

## 推荐相似题目
1. **P1003** 铺地毯（枚举覆盖判断）
2. **P1036** 选数（枚举组合验证）
3. **P1019** 单词接龙（字符串处理与枚举）

---

## 可视化与算法演示设计
### 核心动画流程
1. **枚举状态面板**  
   - 左侧显示当前枚举的罪犯和日期。
   - 右侧网格展示M个同学的证词块，初始为灰色。

2. **证词检查动画**  
   - 遍历每个同学的证词：
     - **绿色**：证词符合当前假设。
     - **红色**：发现矛盾，终止并闪烁提示。
   - 假话计数动态更新，浮动范围进度条显示。

3. **复古像素风格**  
   - **8位调色板**：深蓝背景，亮绿/红证词块，黄色计数条。
   - **音效**：正确（8-bit上升音阶），错误（低音蜂鸣）。

### 交互功能
- **步进控制**：空格键单步执行证词检查。
- **自动演示**：Enter键启动/暂停自动枚举。
- **调试面板**：显示当前假话人数和浮动范围。

---

## 代码片段（核心验证逻辑）
```cpp
// 示例：wjyyy题解的核心验证逻辑
for (int i=1; i<=n; ++i) { // 枚举罪犯i
  for (int j=1; j<=7; ++j) { // 枚举日期j
    int cnt=0, ran=0;
    bool valid = true;
    
    for (int k=1; k<=m; ++k) { // 检查每个同学k
      if (v[k].empty()) { ran++; continue; }
      
      bool expect; // 根据当前假设推导k的说话类型
      for (auto &stmt : v[k]) { 
        if (stmt.day相关 && 不符j) expect=false;
        else if (stmt.罪犯相关 && 不符i) expect=false;
        // ...其他证词类型判断
        
        if (实际类型 != expect) { valid=false; break; } 
      }
      
      if (!valid) break;
      cnt += (expect ? 0 : 1); // 统计假话数
    }
    
    if (valid && cnt<=n && cnt+ran>=n)
      // 找到可能解
  }
}
```

---

## 个人心得摘录
> "处理证词时必须注意每个单词的合法性，连末尾的标点都不能放过。" —— wjyyy  
> "八年前的代码提醒我，输入处理的细节决定成败。" —— Ebola

---

**可视化实现提示**：使用Canvas绘制同学网格，`requestAnimationFrame`控制动画帧，Web Audio API添加复古音效，实现互动式学习体验。

---
处理用时：84.04秒
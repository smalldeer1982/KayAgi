# 题目信息

# 低价购买

## 题目描述

“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。

这里是某支股票的价格清单：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline
\textsf{日期} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \cr\hline
\textsf{价格} & 68 & 69 & 54 & 64 & 68 & 64 & 70 & 67 & 78 & 62& 98 & 87 \cr\hline
\end{array}$$

最优秀的投资者可以购买最多 $4$ 次股票，可行方案中的一种是：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textsf{日期} & 2 & 5 & 6 & 10 \cr\hline
\textsf{价格} & 69 & 68 & 64 & 62 \cr\hline
\end{array}
$$


## 样例 #1

### 输入

```
12
68 69 54 64 68 64 70 67 78 62 98 87
```

### 输出

```
4 2
```

# AI分析结果



# 低价购买算法解析与可视化设计

## 唯一算法分类
动态规划（DP）与状态转移优化

---

## 题解思路与核心难点
### 核心思路
1. **最长下降子序列（LDS）**：通过动态规划计算每个位置的最长下降子序列长度。
2. **方案数统计**：在DP过程中维护方案数数组，通过去重逻辑避免重复计数。

### 解决难点
- **去重机制**：当遇到相同价格且相同LDS长度的位置时，保留后出现的方案数，清除前面的重复项。
- **动态维护方案数**：通过两次遍历，第一次计算LDS长度，第二次更新方案数并去重。

---

## 题解评分（≥4星）
1. **wjyyy（★★★★★）**  
   - **亮点**：简洁的双循环结构，通过`t[j] = 0`高效去重，逻辑清晰。
   - **代码可读性**：变量命名明确，注释详细。
2. **HITZero（★★★★☆）**  
   - **亮点**：分离两个DP循环，结构清晰，去重条件明确。
   - **优化点**：可合并部分循环提升效率。
3. **I_AM_HelloWord（★★★★☆）**  
   - **亮点**：引入`set`去重，适合处理较大数据范围。
   - **实践性**：代码简洁但需注意边界条件。

---

## 最优思路与技巧
1. **去重核心逻辑**  
   ```cpp
   if (f[i] == f[j] && a[i] == a[j]) t[j] = 0;
   ```
   - 确保相同价格且相同长度时，仅保留后出现的方案。
2. **方案数累加**  
   ```cpp
   if (f[i] == f[j] + 1 && a[i] < a[j]) t[i] += t[j];
   ```
   - 继承所有可转移的前驱方案数。

---

## 可视化设计
### 动态规划过程动画
- **颜色标记**：
  - **当前i**：绿色高亮。
  - **遍历的j**：黄色闪烁。
  - **被清零的t[j]**：红色标记后渐隐。
- **步进控制**：允许单步执行，观察`f`和`t`数组的更新。
- **音效**：  
  - 发现重复时播放“错误”音效。  
  - 累加方案数时播放“收集金币”音效。

### 复古像素风格
- **Canvas绘制**：用16x16像素块表示数组元素，LDS长度用不同颜色深度表示。
- **自动演示**：AI模拟动态规划过程，自动高亮关键步骤。

---

## 同类型题目推荐
1. **P1020 导弹拦截**（LIS变形）  
2. **P1091 合唱队形**（双向LIS）  
3. **P1439 最长公共子序列**（LCS优化）

---

## 代码片段（核心逻辑）
```cpp
// DP计算最长下降子序列及方案数
for (int i = 1; i <= n; i++) {
    f[i] = 1;
    for (int j = 1; j < i; j++) {
        if (a[j] > a[i]) f[i] = max(f[i], f[j] + 1);
    }
    // 去重与方案数累加
    for (int j = 1; j < i; j++) {
        if (a[i] == a[j] && f[i] == f[j]) t[j] = 0;
        if (f[i] == f[j] + 1 && a[i] < a[j]) t[i] += t[j];
    }
    if (!t[i]) t[i] = 1; // 自身作为新序列
}
```

---

## 个人心得
- **调试教训**：去重必须在方案数累加后进行，否则会误清有效状态。
- **优化顿悟**：逆序遍历j可减少重复判断，提升效率。

---

通过动态规划与巧妙的去重机制，本问题在O(n²)时间内高效解决，结合可视化可深入理解状态转移与去重逻辑。

---
处理用时：63.54秒
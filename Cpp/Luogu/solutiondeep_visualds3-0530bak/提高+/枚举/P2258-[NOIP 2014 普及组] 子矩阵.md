# 题目信息

# [NOIP 2014 普及组] 子矩阵

## 题目背景

NOIP2014 普及组 T4

## 题目描述

给出如下定义：

1. 子矩阵：从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵（保持行与列的相对顺序）被称为原矩阵的一个子矩阵。

    例如，下面图中选取第 $2,4$ 行和第 $2,4,5$ 列交叉位置的元素得到一个 $2 \times 3$ 的子矩阵如下所示。

|$9$|$\color{#6a5acd}3$|$3$|$\color{#6a5acd}3$|$\color{#6a5acd}9$|
|:-|:-|:-|:-|:-|
|$\color{#6a5acd}9$|$\color{blue}4$|$\color{#6a5acd}8$|$\color{blue}7$|$\color{blue}4$|
|$1$|$\color{#6a5acd}7$|$4$|$\color{#6a5acd}6$|$\color{#6a5acd}6$|
|$\color{#6a5acd}6$|$\color{blue}8$|$\color{#6a5acd}5$|$\color{blue}6$|$\color{blue}9$|
|$7$|$\color{#6a5acd}4$|$5$|$\color{#6a5acd}6$|$\color{#6a5acd}1$|

此矩阵的其中一个 $2\times3$ 的子矩阵是：

|$4$|$7$|$4$|
|:-|:-|:-|
|$8$|$6$|$9$|

2. 相邻的元素：矩阵中的某个元素与其上下左右四个元素（如果存在的话）是相邻的。

3. 矩阵的分值：矩阵中每一对相邻元素之差的绝对值之和。

本题任务：给定一个 $n$ 行 $m$ 列的正整数矩阵，请你从这个矩阵中选出一个 $r$ 行 $c$ 列的子矩阵，使得这个子矩阵的分值最小，并输出这个分值。

## 说明/提示

#### 样例 1 说明

该矩阵中分值最小的 $2$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行与第 $1$ 列、第 $3$ 列、第 $4$ 列交叉位置的元素组成，为：

|$6$|$5$|$6$|
|:-|:-|:-|
|$7$|$5$|$6$|

其分值为 $|6-5|+|5-6|+|7-5|+|5-6|+|6-7|+|5-5|+|6-6|=6$。

#### 样例 2 说明

该矩阵中分值最小的 $3$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行、第 $6$ 行与第 $2$ 列、第 $6$ 列、第 $7$ 列交叉位置的元素组成，选取的分值最小的子矩阵为：

|$9$|$7$|$8$|
|:-|:-|:-|
|$9$|$8$|$8$|
|$5$|$8$|$10$|

#### 数据范围

- 对于 $50\%$ 的数据，$1\leq n\leq 12$，$1\leq m\leq 12$，矩阵中的每个元素 $1\leq a_{i,j}\leq20$；

- 对于 $100\%$ 的数据，$1\leq n\leq 16$，$1\leq m\leq 16$，矩阵中的每个元素 $1\leq a_{i,j}\leq 1000$，$1\leq r\leq n$，$1\leq c\leq m$。

## 样例 #1

### 输入

```
5 5 2 3
9 3 3 3 9
9 4 8 7 4
1 7 4 6 6
6 8 5 6 9
7 4 5 6 1```

### 输出

```
6```

## 样例 #2

### 输入

```
7 7 3 3  
7 7 7 6 2 10 5
5 8 8 2 1 6 2 
2 9 5 5 6 1 7 
7 9 3 6 1 7 8 
1 9 1 4 7 8 8 
10 5 9 1 1 8 10
1 3 1 5 4 8 6```

### 输出

```
16```

# AI分析结果



## 算法分类  
动态规划 + 深度优先搜索（剪枝优化）

---

## 题解思路与核心难点  

### 核心思路  
所有题解均采用 **行列分治** 策略：  
1. **DFS 枚举行或列的组合**，时间复杂度为组合数级（如 C(n,r)）  
2. **预处理行/列间差值贡献**，避免重复计算  
3. **动态规划优化另一维度**（如枚举行后，DP处理列的选择）  

### 关键实现  
- **状态设计**：如 `f[i][j]` 表示前 i 列选 j 列的最小分值  
- **转移方程**：`f[i][j] = min(f[k][j-1] + 列间贡献 + 行间贡献)`  
- **预处理优化**：提前计算行间/列间相邻元素的差值绝对值之和  

### 解决难点  
1. **组合爆炸问题**：通过剪枝（如当前分值超过最优解时提前终止）降低搜索空间  
2. **重复计算问题**：预处理行/列贡献矩阵（如 `g[i][j][k]` 存储第 i 行与第 j 行在第 k 列的差值）  
3. **状态转移复杂度**：将行/列贡献拆分为独立部分，在 DFS 过程中增量维护  

---

## 题解评分（≥4星）  

### 1. panyf 题解（⭐⭐⭐⭐⭐）  
- **亮点**：分步剪枝 + 双预处理 + 回溯优化  
- **关键代码**：在 DFS 列时动态累加行贡献，通过寄存器变量优化常数  
```cpp
void dfsl(ci&x, ci&y, ci&z) {
    if (y == c) { s = min(s, z); return; }
    for (int i = x+1; i <= m; ++i) {
        int new_z = z + p[i] + (x ? h[x][i][e[j]] : 0);
        if (new_z < s) dfsl(i, y+1, new_z);
    }
}
```

### 2. RikoHere 题解（⭐⭐⭐⭐）  
- **亮点**：清晰的列枚举DP框架 + 模块化贡献计算  
- **关键优化**：`cal` 函数分离行列贡献，便于状态转移  
```cpp
int cal(int x, int y) { // 计算新增列x与已有列y的贡献
    int res = 0;
    for (int i = 1; i <= r; ++i) 
        res += abs(a[plan[i]][x] - a[plan[i]][y]);
    return res;
}
```

### 3. algo_h 题解（⭐⭐⭐⭐）  
- **亮点**：增量维护贡献矩阵 + 回溯优化空间  
- **创新点**：在 DFS 过程中动态更新 `dp[0][j]`（列内贡献）和 `inc[i][j]`（列间贡献）  

---

## 最优思路提炼  
1. **行列分治**：将问题分解为行选择和列选择两个子问题  
2. **贡献预处理**：  
   - 行贡献：`g[i][j][k] = abs(row_i_col_k - row_j_col_k)`  
   - 列贡献：`h[i][j][k] = abs(col_i_row_k - col_j_row_k)`  
3. **动态规划优化**：对未被枚举的维度设计 O(m²c) 级别 DP  
4. **剪枝策略**：在 DFS 过程中实时比较当前分值与已知最优解  

---

## 相似题目推荐  
1. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)（状压DP+几何距离计算）  
2. [P2329 栅栏](https://www.luogu.com.cn/problem/P2329)（DFS剪枝+贪心优化）  
3. [P2831 愤怒的小鸟](https://www.luogu.com.cn/problem/P2831)（状态压缩+几何预处理）  

---

## 可视化算法分析  

### 动画设计  
1. **像素风格矩阵**：用 16x16 网格表示原矩阵，选中行列高亮显示  
2. **贡献值展示**：  
   - 行选择阶段：相邻选中行用垂直箭头连接，显示纵向差值  
   - 列选择阶段：相邻选中列用水平箭头连接，显示横向差值  
3. **DP状态面板**：右侧显示 `f[i][j]` 矩阵，当前更新位置闪烁黄色  

### 关键帧示例  
1. **DFS行选择**：  
   - 第1帧：选择第2行（蓝色）  
   - 第2帧：选择第4行（紫色），计算与第2行的纵向差值  
2. **DP列转移**：  
   - 显示 `f[3][2] = min(f[1][1]+Δ1, f[2][1]+Δ2)`  
   - 用不同颜色区分历史最优解和当前计算路径  

### 交互功能  
- **速度调节**：滑块控制动画速度（0.5x~4x）  
- **模式切换**：手动单步执行 / 自动播放  
- **音效反馈**：  
  - 选择行列时播放 "哔" 声  
  - 找到更优解时播放上扬音效  

---

## 核心代码实现  
以 panyf 题解为例的关键预处理与 DFS：  
```cpp
// 预处理行间纵向差值
for (int i = 1; i <= n; ++i) {
    for (int j = i+1; j <= n; ++j) {
        for (int k = 1; k <= m; ++k) {
            g[i][j][k] = abs(v[i][k] - v[j][k]);
        }
    }
}

// DFS 选择行
void dfsh(int x, int y) {
    if (y == r) {
        // 初始化列贡献数组 p[]
        for (int j = 1; j <= m; ++j) {
            p[j] = 0;
            for (int i = 1; i < r; ++i) 
                p[j] += g[e[i-1]][e[i]][j];
        }
        dfsl(0, 0, 0);
        return;
    }
    // 枚举下一行并回溯
    for (int i = x+1; i <= n; ++i) {
        e[y] = i;
        dfsh(i, y+1);
    }
}
```

---

通过行列分治策略与动态规划优化，该算法将指数级复杂度降为可接受范围（C(16,8)×16³ ≈ 1.6e8），结合预处理和剪枝技巧，实现了高效求解。

---
处理用时：79.89秒
# 题目信息

# [USACO5.1] 夜空繁星Starry Night

## 题目背景

高高的星空，簇簇闪耀的群星形态万千。一个星座(cluster)是一群连通的星组成的非空连通星系，这里的连通是指水平，垂直或者对角相邻的两个星星。一个星座不能是另一个更大星座的一部分， 星座可以相似(similar)。如果两个星座有相同的形状，而且包括相同数目的星体，那么不管其方向性如何，就算相似。一般而言，星座可能的方向有八个，如图1所示。

![](https://cdn.luogu.com.cn/upload/pic/1970.png)


## 题目描述

夜空可以表示为一份天体图(sky map)，它是一个由字符0和1组成的二维矩阵，字符1表示所在的位置有一颗星；字符0表示该位置上是空的.给定一份天体图，用同一个小写英文标识(mark)相似的所有星座。相似的星座必须用相同的字母标识，不同的星座表示为不同的字母。标识一个星座，就是将其中各星体对应的字符1替换为相应的小写字母.


## 说明/提示

在这种情况下，天体图是一个长23宽为15的二维矩阵。请注意这幅天体图是对应（corresponds to）下面这个矩阵的图像。

Starry-2.gif 图starry-2：天体图

 ![](https://cdn.luogu.com.cn/upload/pic/1971.png) 

这是上述输入实例的一个可能的结果。请注意，该输出文件对应于下面的天空景象。


 ![](https://cdn.luogu.com.cn/upload/pic/1972.png) 

### 数据范围

0 <= 星空的长和宽 <= 100

0 <= 星座个数 <= 500

0 <= 不相似的星座个数 <= 26

1 <= 每个星座中星星个数 <= 160


## 样例 #1

### 输入

```
23
15
10001000000000010000000
01111100011111000101101
01000000010001000111111
00000000010101000101111
00000111010001000000000
00001001011111000000000
10000001000000000000000
00101000000111110010000
00001000000100010011111
00000001110101010100010
00000100110100010000000
00010001110111110000000
00100001110000000100000
00001000100001000100101
00000001110001000111000```

### 输出

```
a000a0000000000b0000000
0aaaaa000ccccc000d0dd0d
0a0000000c000c000dddddd
000000000c0b0c000d0dddd
00000eee0c000c000000000
0000e00e0ccccc000000000
b000000e000000000000000
00b0f000000ccccc00a0000
0000f000000c000c00aaaaa
0000000ddd0c0b0c0a000a0
00000b00dd0c000c0000000
000g000ddd0ccccc0000000
00g0000ddd0000000e00000
0000b000d0000f000e00e0b
0000000ddd000f000eee000```

# AI分析结果



## 【唯一算法分类】  
图遍历与几何变换处理

---

## 【题解思路与核心难点】  

### **核心难点**  
1. **连通块识别**：需用DFS/BFS遍历所有相邻（8方向）的'1'构成星座。  
2. **相似性判断**：需处理星座的旋转、对称等8种变换，判断形状等价性。  

### **题解对比分析**  
1. **距离和法（QQ红包、Celebrate等）**  
   - **核心**：计算星座内所有点对的欧氏距离之和，若两星座总和相差极小则视为相似。  
   - **优点**：代码简洁，计算复杂度O(n²)（n为星座点数）。  
   - **缺点**：存在浮点精度误差风险，极端形状可能误判。  

2. **变换标准化法（小菜鸟、VCVCVCFop_zz）**  
   - **核心**：枚举8种旋转/对称变换，将星座坐标平移至原点后排序，比较对应点偏移量是否一致。  
   - **优点**：无精度问题，准确率高。  
   - **缺点**：需处理大量坐标变换，代码冗长（约100行变换逻辑）。  

3. **矩阵哈希法（小手冰凉、w33z8kqrqk8zzzx33）**  
   - **核心**：对星座的最小包围矩阵生成哈希，考虑所有变换后的哈希值，取最小值作为唯一标识。  
   - **优点**：哈希比较速度快，适合大量星座去重。  
   - **缺点**：哈希冲突需额外处理（如双哈希）。  

---

## 【题解评分 (≥4星)】  
1. **QQ红包（4.5星）**  
   - **亮点**：距离和法实现极简，赞数最高，适合竞赛快速解题。  
   - **优化点**：使用`sqrt`累加可能存在性能损耗，可用平方距离优化。  

2. **小菜鸟（4星）**  
   - **亮点**：变换枚举法无精度问题，代码逻辑清晰，附带详细注释。  
   - **优化点**：8种变换的代码可通过循环进一步简化。  

3. **w33z8kqrqk8zzzx33（4星）**  
   - **亮点**：哈希法高效，自定义旋转/对称变换生成最小哈希，代码模块化。  
   - **优化点**：哈希函数选择`MOD=1e12+39`可降低冲突概率。  

---

## 【最优思路提炼】  
**关键技巧**：  
1. **坐标标准化**：将星座平移至原点，消除平移差异。  
   ```cpp  
   int mx = min_x, my = min_y;  
   for(pii& v : points) v = {v.x-mx, v.y-my};  
   ```  
2. **变换枚举法**：生成8种可能变换的坐标序列，排序后比较。  
3. **哈希优化**：对标准化后的坐标序列生成滚动哈希，取所有变换中的最小值作为唯一标识。  

---

## 【同类型题与算法套路】  
1. **图像模式匹配**：如[LeetCode 48. 旋转图像](https://leetcode.com/problems/rotate-image/)  
2. **连通块处理**：如[洛谷P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)  
3. **几何哈希**：如[Codeforces 1017E - The Supersonic Rocket](https://codeforces.com/contest/1017/problem/E)  

---

## 【推荐练习题】  
1. **P1162 填涂颜色**（二维矩阵连通块染色）  
2. **P1443 马的遍历**（8方向BFS应用）  
3. **P3663 星座计数**（相似形状统计）  

---

## 【个人心得摘录】  
- **小菜鸟**：_“变换比较虽然代码长，但全是无脑复制，比调浮点误差舒服多了。”_  
- **Celebrate**：_“sqrt爆精度让我WA了3次，改用平方和后直接AC。”_  

---

## 【可视化算法演示】  
### **动画设计**  
1. **连通块遍历**：  
   - **颜色标记**：当前探索的格子用绿色高亮，已访问的用蓝色。  
   - **步进控制**：按空格键单步执行DFS，展示如何扩展8邻居。  

2. **相似性判断**：  
   - **变换演示**：左侧展示原星座，右侧轮播其8种变换形态，匹配时闪烁黄框。  
   - **坐标对齐**：平移后的星座用红色框标出原点，显示平移后的坐标差。  

### **复古像素风格**  
- **调色板**：16色FC风格，星座用亮黄（#FFFF00），背景深蓝（#000080）。  
- **音效**：  
  - **探索音**：8-bit短促“滴”声（每次移动格子）。  
  - **匹配成功**：经典FC过关音效（#C040B0）。  

### **交互功能**  
- **速度滑块**：调整DFS探索速度（50ms~1000ms/步）。  
- **模式切换**：选择“距离和法”或“变换法”对比不同算法的匹配过程。  

---

## **核心代码片段（变换法）**  
```cpp  
// 标准化坐标并生成8种变换的哈希  
ll canon_hash(vector<pii> points) {  
    int min_x = 105, min_y = 105;  
    for(auto [x,y] : points) {  
        min_x = min(min_x, x);  
        min_y = min(min_y, y);  
    }  
    for(auto &[x,y] : points) {  
        x -= min_x;  
        y -= min_y;  
    }  
    sort(points.begin(), points.end());  
    ll min_hash = compute_hash(points);  
    // 生成旋转和对称变换的哈希  
    for(int i=0; i<3; i++) {  
        rotate(points);  
        min_hash = min(min_hash, compute_hash(points));  
    }  
    flip(points);  
    // ...类似生成其他变换的哈希  
    return min_hash;  
}  
```  

完整代码与可视化Demo见[GitHub仓库](https://github.com/algviz/starry-night-animation)（虚构链接）。

---
处理用时：77.49秒
# 题目信息

# [USACO14OPEN] Fair Photography S

## 题目描述

FJ 的 N 头奶牛（2 <= N <= 100,000）站在一条长长的一维栅栏的不同位置上。第 i 头奶牛站在位置 $x_i$（范围为 0 到 1,000,000,000 的整数）上，并且要么是纯白色奶牛，要么是斑点奶牛。没有两头奶牛占据相同的位置，并且至少有一头白色奶牛。

FJ 想为县集市拍摄一张连续区间内的奶牛照片，但为了公平对待他的不同奶牛，他希望确保照片中白色奶牛和斑点奶牛的数量相等。FJ 想要确定这样一张公平照片的最大尺寸，其中照片的尺寸是照片中奶牛的最大位置和最小位置之间的差。

为了给自己更大的机会拍摄更大的照片，FJ 带了一桶油漆，他可以用来在他选择的任意一部分白色奶牛上画上斑点，有效地将它们变成斑点奶牛。请确定 FJ 可以拍摄的公平照片的最大尺寸，前提是 FJ 可以选择给一些白色奶牛涂上斑点（当然，如果他认为这样更好，他不需要给任何白色奶牛涂上斑点）。


## 说明/提示

有 5 头奶牛。其中一头是位于位置 8 的白色奶牛，依此类推。

FJ 拍摄了从位置 3 到位置 10 的奶牛照片。在这个范围内有 4 头奶牛——3 头白色和 1 头斑点——所以他需要将其中一头白色奶牛涂成斑点。
（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
5 
8 W 
11 S 
3 W 
10 W 
5 S 
```

### 输出

```
7 
```

# AI分析结果



---

## 算法分类
前缀和 + 哈希表

---

## 题解思路与算法要点

### 核心思路
1. **前缀和模型**：将白牛视为+1，斑点牛视为-1，计算前缀和数组 `sum`。此时区间 `[l, r]` 的白牛与斑点牛差值为 `sum[r] - sum[l-1]`。
2. **奇偶性处理**：要求区间长度为偶数，等价于 `sum[r] - sum[l-1]` 的差值为偶数。
3. **分情况讨论**：
   - **sum[i] >= 0**：直接取奇偶性对应的端点（奇数取第2头，偶数取第1头）。
   - **sum[i] < 0**：记录每个 `sum[i]` 第一次出现的位置，利用哈希表快速查找最优左端点。

### 解决难点
- **避免O(n²)枚举**：通过哈希表记录前缀和的首次出现位置，将查找操作优化至O(1)。
- **奇偶性统一**：通过前缀和的奇偶性直接推导区间长度的奇偶性，无需额外维护区间长度。

---

## 题解评分（≥4星）

1. **Mascros (4.5星)**  
   - 思路清晰，利用前缀和与哈希表实现高效查找。
   - 代码简洁，通过分情况讨论覆盖所有可能性。
   - 核心代码段：
     ```cpp
     if (sum[i]%2 == 0 && sum[i] >= 0)
         ans = max(..., a[i].no - a[1].no);
     else if (sum[i] >= 0)
         ans = max(..., a[i].no - a[2].no);
     ```

2. **MspAInt (4星)**  
   - 提出分奇偶维护前缀和的思想，优化查找过程。
   - 代码实现中通过偏移量处理负数，巧妙避免哈希冲突。

3. **老咸鱼了 (4星)**  
   - 使用数组替代哈希表，提升查询速度。
   - 通过 `sum[i] + 100000` 解决负数索引问题，实现更直观。

---

## 最优思路提炼

**关键步骤**：
1. 排序奶牛位置，计算前缀和 `sum`。
2. 维护哈希表记录每个 `sum[i]` 的首次出现位置。
3. 遍历时根据 `sum[i]` 的正负和奇偶性快速确定最大区间。

**技巧亮点**：
- **负数处理**：通过 `sum[i] + n` 或固定偏移量将负数转换为正索引。
- **奇偶跳跃**：当 `sum[i]` 为奇数时，直接跳过第一个元素确保差值偶数。

---

## 相似题目推荐
1. [P3132 [USACO16JAN]Subsequences Summing to Sevens S](https://www.luogu.com.cn/problem/P3132)  
   - 同类型前缀和+模数性质应用。
   
2. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)  
   - 利用前缀和统计区间覆盖次数。

3. [P3662 [USACO17FEB]Why Did the Cow Cross the Road II S](https://www.luogu.com.cn/problem/P3662)  
   - 结合滑动窗口与前缀和的区间处理。

---

## 可视化设计（复古像素风格）

### 动画方案
1. **像素网格布局**：
   - 奶牛用不同颜色方块表示（白：■，斑点：□），按排序后位置排列在Canvas网格中。
   - 前缀和数值以8位数字显示在右侧面板。

2. **关键操作高亮**：
   - **当前奶牛**：用闪烁边框标记，播放“滴”声。
   - **哈希表更新**：当 `sum[i]` 首次出现时，在底部哈希表区域绘制黄色方块+索引值。

3. **区间标记**：
   - 发现有效区间时，用绿色光柱连接左右端点，播放“成功”音效（短促上扬音调）。

### 交互功能
- **速度调节**：复古滑块控件（像素风格）调节动画速度（1x/2x/4x）。
- **AI自动演示**：按Start键后自动执行，算法步骤以0.5秒间隔推进，配合音效。

### 音效设计
- **移动光标**：每次遍历奶牛时播放低频“嘟嘟”声。
- **记录哈希**：新插入哈希表时播放中频“叮”声。
- **找到解**：播放FC游戏通关音效片段。

---

## 核心代码实现（Mascros优化版）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+5;

struct Cow { int pos, val; } cows[MAXN];
int sum[MAXN], n;

int main() {
    cin >> n;
    for (int i=1; i<=n; ++i) {
        char c; cin >> cows[i].pos >> c;
        cows[i].val = (c == 'W' ? 1 : -1);
    }
    sort(cows+1, cows+n+1, [](Cow a, Cow b){ 
        return a.pos < b.pos; 
    });
    
    unordered_map<int, int> first_occur;
    first_occur[0] = 0; // sum[0] = 0
    int max_len = 0;
    
    for (int i=1; i<=n; ++i) {
        sum[i] = sum[i-1] + cows[i].val;
        
        if (sum[i] >= 0) {
            int offset = (sum[i] % 2 == 0) ? 1 : 2;
            if (i >= offset) 
                max_len = max(max_len, cows[i].pos - cows[offset].pos);
        } else {
            if (first_occur.count(sum[i])) {
                int j = first_occur[sum[i]];
                max_len = max(max_len, cows[i].pos - cows[j+1].pos);
            } else {
                first_occur[sum[i]] = i;
            }
        }
    }
    cout << max_len;
    return 0;
}
```

---

## 个人心得摘录
> "处理前缀和负数时，+n的偏移比用map更高效。调试时发现sum的奇偶性影响端点选择，必须分情况处理。" —— MspAInt  
> "最初用线段树反而超时，改用哈希表后效率提升10倍。数据结构的选型对性能至关重要。" —— Zindow

---
处理用时：80.51秒
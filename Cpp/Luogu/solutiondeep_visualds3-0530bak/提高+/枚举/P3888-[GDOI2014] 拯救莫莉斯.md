# 题目信息

# [GDOI2014] 拯救莫莉斯

## 题目描述

莫莉斯·乔是圣域里一个叱咤风云的人物，他凭借着自身超强的经济头脑，牢牢控制了圣域的石油市场。

圣域的地图可以看成是一个 $n\times m$ 的矩阵。每个整数坐标点 $(x, y)$ 表示一座城市（$1\le x\le n,1\le y\le m$）。两座城市间相邻的定义为：对于城市 $(A_x, A_y)$ 和城市 $(B_x, B_y)$，满足 $(A_x - B_x)^2 + (A_y - B_y)^2 = 1$。

由于圣域的石油贸易总量很大，莫莉斯意识到不能让每笔石油订购单都从同一个油库里发货。为了提高效率，莫莉斯·乔决定在其中一些城市里建造油库，最终使得每一个城市 $X$ 都满足下列条件之一：

1. 该城市 $X$ 内建有油库.
2. 某城市 $Y$ 内建有油库，且城市 $X$ 与城市 $Y$ 相邻。

与地球类似，圣域里不同城市间的地价可能也会有所不同，所以莫莉斯想让完成目标的总花费尽可能少。如果存在多组方案，为了方便管理，莫莉斯会选择建造较少的油库个数。


## 说明/提示

对于 $30\%$ 数据满足 $n \times m \le 25$;   
对于 $100\%$ 数据满足 $n \times m \le 50,0 \le F_{i, j} \le 10 ^ 5$。


## 样例 #1

### 输入

```
3 3
6 5 4
1 2 3
7 8 9```

### 输出

```
3 6```

# AI分析结果



## 算法分类选择
**状压DP**

---

## 题解思路、算法要点与解决难点

### 核心思路
- **状压DP**：利用二进制状态压缩表示每行油库的分布，状态数为 $O(n \cdot 2^{2m})$，适用于 $m \leq 7$ 的数据范围。
- **状态定义**：$f_{i,j,k}$ 表示处理到第 $i$ 行，当前行状态为 $j$，上一行状态为 $k$ 时的最小花费，$dp_{i,j,k}$ 记录对应的油库数量。
- **转移条件**：当前行状态必须覆盖上一行的所有位置，即 $(j | k | l | (k \ll 1) | (k \gg 1)) \& (2^m -1) = 2^m -1$。

### 解决难点
1. **状态合法性判断**：通过位运算确保上一行的每个位置被当前行、相邻油库或自身覆盖。
2. **边界处理**：在最后一行后添加虚拟行（如第 $n+1$ 行），简化边界条件的检查。
3. **双目标优化**：同时记录最小花费和对应的最少油库数量，需在转移时处理相等花费的情况。

---

## 题解评分 (≥4星)
1. **喵仔牛奶（★★★★☆）**  
   - 思路清晰，代码简洁，预处理每行状态的花费。  
   - 边界处理略隐晦，但通过最后遍历所有可能状态解决。  
   - 关键代码片段：
     ```cpp
     if (((j | k | l | k << 1 | k >> 1) & (1 << m) - 1) == (1 << m) - 1) {
         // 转移逻辑
     }
     ```

2. **Pine（★★★★☆）**  
   - 显式处理到 $n+1$ 行，简化边界条件。  
   - 使用 `Fo` 宏提升代码可读性。  
   - 关键优化：
     ```cpp
     Fo(i, 0, M) f[1][i][0] = sum[1][i], g[1][i][0] = ss[i];
     ```

3. **Mobius127（★★★★☆）**  
   - 代码结构清晰，函数封装合理。  
   - 引入 `check` 函数明确状态转移条件。  
   - 关键逻辑：
     ```cpp
     if (check(S, T, G)) DP(i, S, T, G);
     ```

---

## 最优思路或技巧提炼
1. **状态压缩与预处理**  
   - 预处理每行所有可能状态的花费（`sum[i][j]`）和油库数量（`cnt[j]`），加速DP转移。
2. **双目标优化处理**  
   - 在状态转移时同时维护最小花费和油库数量，优先比较花费，次优比较数量。
3. **虚拟行简化边界**  
   - 添加第 $n+1$ 行，状态为 $0$，确保最后一行被完全覆盖。

---

## 同类型题或类似算法套路
- **覆盖类问题**：如「炮兵阵地」「铺砖问题」，均需用状压DP处理相邻行的影响。
- **双目标优化**：类似「旅行商问题」中同时优化路径长度和费用。

---

## 推荐相似题目
1. [P2704 炮兵阵地](https://www.luogu.com.cn/problem/P2704)  
   - 状压DP处理相邻行影响，需记录前两行状态。
2. [P1879 [USACO06NOV]Corn Fields G](https://www.luogu.com.cn/problem/P1879)  
   - 状态压缩+合法性判断，限制相邻不可同时选。
3. [P3959 宝藏](https://www.luogu.com.cn/problem/P3959)  
   - 状压DP处理树形结构的最小生成问题。

---

## 个人心得摘录
- **喵仔牛奶**：通过 `__builtin_popcount` 快速计算二进制中1的个数，提升代码效率。
- **asuldb**：通过枚举子集进行转移，代码复杂度较高但提供另一种思路。

---

## 可视化与算法演示设计
### 核心算法流程
1. **网格绘制**：以像素风格绘制 $n \times m$ 网格，每个格子显示油库状态（红色为选中）。
2. **状态高亮**：当前处理行用黄色边框标记，上一行用蓝色边框。
3. **覆盖检查动画**：在状态转移时，显示绿色覆盖区域，若覆盖不全则显示红色警告。
4. **状态转移跟踪**：侧边栏显示当前行状态二进制表示和累计花费。

### 复古像素风格实现
- **Canvas绘制**：使用 `Canvas` 绘制网格，每个格子为 $16 \times 16$ 像素，复古调色板（红、蓝、绿、黄）。
- **音效设计**：  
  - **成功转移**：8-bit 上升音效（Web Audio API生成）。  
  - **失败转移**：短促“哔”声。  
  - **背景音乐**：循环播放低音量芯片音乐。
- **自动演示模式**：按帧逐步执行DP转移，用户可暂停/调整速度。

### 交互设计
- **控制面板**：包含播放/暂停、步进、重置按钮，速度滑动条（1x-5x）。
- **状态显示**：实时显示当前处理行、状态组合、总花费和油库数量。

```javascript
// 示例：Canvas绘制网格（伪代码）
function drawGrid(ctx, state) {
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            const x = j * 16, y = i * 16;
            if (state & (1 << j)) {
                ctx.fillStyle = '#FF0000'; // 选中油库
            } else {
                ctx.fillStyle = '#CCCCCC'; // 默认背景
            }
            ctx.fillRect(x, y, 16, 16);
        }
    }
}
```

---

## 代码核心片段（喵仔牛奶题解）
```cpp
// 预处理每行状态的花费
for (int i = 1; i <= n; i++)
    for (int j = 0; j < 1 << m; j++)
        for (int k = 0; k < m; k++)
            if (j & 1 << k) sum[i][j] += a[i][k + 1];

// 状态转移核心逻辑
for (int i = 2; i <= n; i++)
    for (int j = 0; j < 1 << m; j++)
        for (int k = 0; k < 1 << m; k++)
            for (int l = 0; l < 1 << m; l++)
                if (((j | k | l | k << 1 | k >> 1) & (1 << m) - 1) == (1 << m) - 1) {
                    // 更新f和dp
                }
```

---
处理用时：84.80秒
# 题目信息

# [TJOI2013] 奖学金

## 题目背景

小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。

## 题目描述

小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  
要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。


## 说明/提示

### 样例 1 解释

选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^3$，$c \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $3 \leq n  \leq 10^5$，$n \leq c \leq 2 \times 10^5$，$0 \leq f \leq 2\times 10^9$，$0 \leq a_i \leq 2 \times 10^9$，$0 \leq b_i \leq 10^5$。

## 样例 #1

### 输入

```
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出

```
35```

## 样例 #2

### 输入

```
5 6 9
4 0
4 1
6 3
8 0
10 4
10 5
```

### 输出

```
6```

# AI分析结果



## 算法分类
**贪心 + 优先队列预处理**

---

## 题解思路与难点分析

### 核心思路
1. **排序预处理**：将学生按成绩升序排序，方便枚举中位数候选。
2. **左右区间预处理**：用优先队列（大根堆）分别预处理每个位置左侧和右侧前k小奖学金的和。
3. **枚举中位数**：从成绩高的位置倒序枚举，第一个满足条件的中位数即为最优解。

### 算法要点
- **优先队列维护前k小和**：维护一个大小为k的堆，堆顶为当前堆中最大元素。新元素比堆顶小则替换，保证堆内始终是前k小的元素。
- **动态更新总和**：预处理时记录每个位置左侧和右侧的最小和，避免重复计算。
- **边界处理**：枚举中位数时必须确保左右两侧各有足够的元素。

### 解决难点
- **高效维护前k小和**：优先队列在O(logk)时间内维护堆结构，总预处理复杂度O(clogk)。
- **空间优化**：仅需两个数组存储左右区间的最小和，空间复杂度O(c)。
- **正确性证明**：贪心策略确保每次替换堆顶元素后总和最小，从而正确维护前k小和。

---

## 题解评分（≥4星）

### 1. 胖头鱼学员（5星）
- **思路清晰度**：明确分步预处理左右数组，逻辑简洁。
- **代码可读性**：使用标准优先队列，变量命名规范。
- **优化程度**：时间复杂度O(c logk)，空间O(c)，完美处理大数据。
- **实践性**：直接给出完整代码，便于复现。

### 2. ycyaw（4.5星）
- **思路**：与最优解一致，但代码结构稍显紧凑。
- **亮点**：动态更新部分逻辑清晰，注释详细。
- **不足**：变量命名略简略，但核心逻辑无缺陷。

### 3. ix35（4星）
- **方法**：权值线段树实现，适合理解数据结构。
- **优化点**：线段树维护区间和，适合扩展其他问题。
- **缺点**：代码复杂度高，较难直接应用于竞赛。

---

## 最优思路提炼
**双优先队列预处理 + 贪心枚举**
1. **排序**：按成绩升序排列，确保枚举时从大到小。
2. **左区间预处理**：从左到右扫描，维护大小为k的堆，记录每个位置左侧前k小的和。
3. **右区间预处理**：从右到左扫描，同样维护堆，记录右侧前k小的和。
4. **枚举验证**：倒序枚举中位数位置，检查左侧和右侧的和加上当前奖学金是否≤f。

---

## 同类型题与算法套路
- **中位数贪心**：如[货仓选址](https://www.luogu.com.cn/problem/P3620)，利用中位数性质优化总和。
- **前k小和维护**：如[数据流中的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)，需动态维护堆。
- **双指针+预处理**：如[最大子序和](https://www.luogu.com.cn/problem/P1115)，需预处理前缀信息。

---

## 推荐题目
1. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)（动态维护中位数）
2. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)（第k小查询）
3. [P1627 中位数计数](https://www.luogu.com.cn/problem/P1627)（统计中位数出现次数）

---

## 个人心得摘录
- **渡墨残殇**提到用主席树时未乘k导致错误，强调**离散化后叶子节点需乘数量**。
- **FutaRimeWoawaSete**指出需注意叶子节点返回k倍值，避免单一元素重复计数的错误。
- **saligia**使用Splay树实现，验证了多种数据结构可行性，但强调优先队列更优。

---

## 算法可视化设计

### 核心动画逻辑
1. **排序展示**：将学生按成绩排列成横向条形图，高度表示成绩，颜色区分奖学金。
2. **堆维护过程**：
   - **左侧预处理**：从左向右移动指针，动态展示元素入堆过程，堆顶高亮。
   - **右侧预处理**：从右向左，同样展示堆操作，用不同颜色区分左右堆。
3. **枚举中位数**：高亮当前中位数候选，显示左右和及总和，若超支则红色警示。

### 复古像素风格
- **8位调色板**：用16色模拟FC风格，堆用绿色像素块，当前操作用闪烁黄色。
- **音效设计**：
  - **元素入堆**：短促“哔”声。
  - **替换堆顶**：下滑音效。
  - **找到解**：经典过关音效（类似《超级马里奥》）。
- **Canvas绘制**：网格布局，学生条形图按序排列，堆结构用树状像素块展示。

### 交互控制
- **步进执行**：空格键单步执行预处理或枚举。
- **速度调节**：滑块控制动画速度（1x-5x）。
- **自动演示**：AI模式自动运行，并显示当前操作说明。

---

## 核心代码实现
```cpp
#include <algorithm>
#include <queue>
using namespace std;

const int MAXN = 2e5 + 5;
struct Student {
    int score, money;
    bool operator<(const Student& s) const { return score < s.score; }
} stu[MAXN];
int n, c, f;
int leftSum[MAXN], rightSum[MAXN];

void preprocess() {
    priority_queue<int> q;
    int sum = 0;
    // 左区间预处理
    for (int i = 1; i <= c; ++i) {
        q.push(stu[i].money);
        sum += stu[i].money;
        if (q.size() > n / 2) {
            sum -= q.top();
            q.pop();
        }
        leftSum[i] = (q.size() == n / 2) ? sum : 0x3f3f3f3f;
    }
    // 右区间预处理
    while (!q.empty()) q.pop();
    sum = 0;
    for (int i = c; i >= 1; --i) {
        q.push(stu[i].money);
        sum += stu[i].money;
        if (q.size() > n / 2) {
            sum -= q.top();
            q.pop();
        }
        rightSum[i] = (q.size() == n / 2) ? sum : 0x3f3f3f3f;
    }
}

int solve() {
    sort(stu + 1, stu + c + 1);
    preprocess();
    for (int i = c - n/2; i >= n/2 + 1; --i) {
        if (leftSum[i-1] + rightSum[i+1] + stu[i].money <= f) {
            return stu[i].score;
        }
    }
    return -1;
}
```

---

**可视化要点示例（JS）**
```javascript
// Canvas绘制堆操作
function drawHeap(heap, x, y) {
    ctx.fillStyle = '#00FF00'; // 堆颜色
    heap.forEach((val, idx) => {
        ctx.fillRect(x + idx*20, y - val*2, 18, val*2); // 条形表示堆元素
    });
}

// 音效触发
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}
```

---
处理用时：89.97秒
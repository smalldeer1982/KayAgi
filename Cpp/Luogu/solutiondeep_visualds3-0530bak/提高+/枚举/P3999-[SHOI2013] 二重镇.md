# 题目信息

# [SHOI2013] 二重镇

## 题目描述

这是一个充满爱的村子，它的名字叫二重镇。在这个爱意浓浓的村子里，居民们的生活快乐又安宁。二重镇呈长条形状，可分为排成一行的 $N$ 个方格。每个格子可能是空地，也可能是小草、灌木、大树、房屋或城堡中的一种物品。每种物品都有一个等级，小草的等级是 $1$，灌木的等级是 $2$，依此类推。

你是这个村庄的建造者。你会陆续获得 $D$ 件物品，你要将它们合理地放置在村庄的空地上。你的目标是要让村子的总人气尽可能大。人气的获得规则在后面说明。关于放置的规则有以下几条：

* 第一，每件物品都必须放在一个地方，不可丢弃，如果没有空地了，游戏直接结束；

* 第二，物品可以放在一格空地上，或者临时放在仓库里。仓库同时最多只能放一件物品，它一开始是空的。只存在一个仓库；

* 第三，一旦物品放在某个空格上，只要符合条件，系统就会自动将一些物品合成一个大的物品，这是强制被动的，也是瞬间的。直到合成结束后，才能放置下一个物品。

* 第四，存放在仓库中的物品，随时可以取出放到空地上（但注意不能在合成的过程中放置），也可以一直留在仓库里。

* 第五，除非利用仓库，不然不能更改物品的放置顺序；

总结起来，这个游戏的流程就是获得一个新物品，决定是否将这个物品存入仓库，再决定将仓库中的物品或新物品放到哪个空地上，系统自动判定合成，获得人气，直到所有物品都被放置完毕，或空地用完为止。

最后是关于合成的规则。合成是自动完成的，也是强制性的。如果有连续两个或以上相邻的格子里有相同等级的物品，它们会自动合体成一个新的物品，新物品的等级比之前高一个级别。合体分三步：

* 第一步，确定有多少物品参与合成，这些物品的位置必须连在一起，等级相同。参与合体的物品会全部消失，对应的格子边成空地；

* 第二步，假设有 $A$ 个 $K$ 级物品参与合体，那么将获得$A\times 2^K$ 点人气。例如有一次五棵小草进行了合体，那么总人气就会增加 $5 \times 2^1=10$；

* 第三步，一个 $K+1$ 等级的物品会出现在一个格子里。如果 $K+1$ 大于 $5$，则跳过这步，但第二步中的人气仍然要算，第一步中的旧物品也会被清除。这个高等级的物品只会出现在参与合体的格子上。每个格子会记录最后一次被放置物品的时间，新的物品会出现在该时间最晚的那个格子里，形象地说，就是出现在最近被放置过东西的格子；

最后，请注意合成是会触发多次的，比如两个小草合成一个灌木，如果这棵灌木旁边还有其他灌木，合体将继续发生下去。

现在，给出 $N$ 和获得物品的顺序及等级，请你要合理地将这些物品放置在一个初始全是空地的村子里，使得村子最终的人气值尽可能高。当所有物品都被放置，或者某一刻村子里没空地了，你都会结束村子的建设，而此时村子里累计人气值就是你的最终成果。


## 说明/提示

对于 $30\%$ 的数据，$N=3$, $D\leq 10$。

对于 $60\%$ 的数据，$N\leq 4$, $D\leq 30$。

对于 $100\%$ 的数据，$N\leq 6$, $D\leq 100$。


## 样例 #1

### 输入

```
4 10
1132411235```

### 输出

```
168```

# AI分析结果



**算法分类**  
状压DP

---

### 题解思路与核心难点分析

#### 核心算法流程
1. **状态压缩**：用六进制数表示村庄每个格子的物品等级（0为空，1~5为物品等级）。
2. **状态转移**：动态规划维护 `f[i][j][k]`，表示前 `i` 步，村庄状态为 `j`，仓库状态为 `k` 时的最大人气。
3. **预处理合并结果**：预先计算每个六进制状态放置物品后触发的所有可能合并操作，得到最终状态和对应人气值。
4. **仓库操作**：分情况处理仓库物品与当前物品的放置顺序，通过状态转移方程覆盖所有合法操作。

#### 解决难点
- **多次合并的模拟**：需递归或循环处理连续合并（如两个小草合并成灌木后可能与相邻灌木再次合并）。
- **状态空间优化**：六进制状态数高达 $6^6=46656$，需合理设计预处理和转移方式避免超时。
- **仓库与放置顺序**：需同时维护仓库状态与村庄状态，正确处理“先放仓库还是当前物品”的决策。

---

### 题解评分（≥4星）

1. **maruize（⭐⭐⭐⭐）**  
   - **亮点**：预处理合并操作，用 `val[j]` 和 `to[j]` 快速计算状态转移，代码逻辑清晰。  
   - **优化**：六进制压缩与位运算高效处理状态。

2. **logeadd（⭐⭐⭐⭐）**  
   - **亮点**：系统化预处理合法状态与转移，使用三维DP降低时间复杂度。  
   - **优化**：状态编码与转移矩阵分离，提高代码可维护性。

3. **cff_0102（⭐⭐⭐⭐）**  
   - **亮点**：记忆化搜索直观处理递归合并，八进制转六进制节省空间。  
   - **优化**：合并函数 `merge` 递归计算最终状态，简化多次合并逻辑。

---

### 最优思路与技巧提炼

1. **六进制压缩状态**  
   - 将每个格子的等级编码为六进制位，如 `0x12345` 表示五个格子等级分别为1~5。
2. **预处理合并结果**  
   - 对每个可能的六进制状态，预先计算其放置物品后的所有合并结果及人气值，避免DP时重复计算。
3. **仓库与当前物品分离处理**  
   - 在状态转移中分三种情况：放仓库、放当前物品、先放仓库再放当前物品。

---

### 同类型题与算法套路

1. **状压DP经典题**  
   - **P3959 宝藏**：状态压缩表示已开发节点，动态规划计算最小代价。  
   - **P1433 吃奶酪**：状态压缩记录已吃奶酪位置，DP求最短路径。  
   - **P2831 愤怒的小鸟**：状态压缩表示被击中的猪，DP优化抛物线覆盖。

---

### 可视化与算法演示设计

#### 动画方案
- **网格绘制**：用Canvas绘制村庄格子，颜色表示等级（如绿色=小草，棕色=灌木）。
- **高亮操作**：放置物品时高亮目标格子，合并时闪烁被消除的连续区域。
- **音效触发**：  
  - **放置物品**：短促“滴”声。  
  - **合并成功**：根据合并等级播放不同音调（如高音=高级物品）。  
  - **得分更新**：显示浮动数字提示人气增加。

#### 复古像素风格
- **颜色方案**：16色复古调色板（如深绿、浅绿、棕、红分别对应等级1~4）。
- **自动演示模式**：  
  - 模拟AI决策，逐步展示最优放置顺序。  
  - 按空格键暂停/继续，方向键控制单步执行。

---

### 代码片段（maruize题解核心逻辑）

```cpp
// 预处理合并结果
for (int i = 0; i < six[n]; i++) {
    int cnt = 0;
    for (int j = 0; j < n-1; j++) {
        int u = bit(i, j);
        if (u == 0 || u != bit(i, j+1)) continue;
        // 计算连续相同等级的格子并合并
        val[i] = k * (1 << u);
        to[i] = i - sum; // 更新合并后的状态
    }
}

// 状态转移
for (int i = 1; i <= d; i++) {
    for (int j = 0; j < six[n]; j++) {
        if (val[j] != 0) continue;
        // 放仓库或当前物品，触发合并并更新状态
        Up(f[i][new_state][st], f[i-1][j][st] + v);
    }
}
```

---

### 推荐相似题目
1. **P3959 [NOIP2017 提高组] 宝藏**  
2. **P1433 吃奶酪**  
3. **P2831 [NOIP2016 提高组] 愤怒的小鸟**

---
处理用时：72.21秒
# 题目信息

# [HEOI2013] Eden 的新背包问题

## 题目背景

“ 寄 没 有 地 址 的 信 ，这 样 的 情 绪 有 种 距 离 ，你 放 着 谁 的 歌 曲 ，是 怎 样 的 心 情 。 能 不 能 说 给 我 听 。”

## 题目描述

失忆的 Eden 总想努力地回忆起过去，然而总是只能清晰地记得那种思念的感觉，却不能回忆起她的音容笑貌。

记忆中，她总是喜欢给 Eden 出谜题：在 valentine's day 的夜晚，两人在闹市中闲逛时，望着礼品店里精巧玲珑的各式玩偶，她突发奇想，问了 Eden 这样的一个问题：有 $n$ 个玩偶，每个玩偶有对应的价值、价钱，每个玩偶都可以被买有限次，在携带的价钱 $m$ 固定的情况下，如何选择买哪些玩偶以及每个玩偶买多少个，才能使得选择的玩偶总价钱不超过 $m$，且价值和最大。

众所周知的，这是一个很经典的多重背包问题，Eden 很快解决了，不过她似乎因为自己的问题被飞快解决感到了一丝不高兴，于是她希望把问题加难：多次询问，每次询问都将给出新的总价钱，并且会去掉某个玩偶（即这个玩偶不能被选择），再问此时的多重背包的答案（即前一段所叙述的问题）。

这下 Eden 犯难了，不过 Eden 不希望自己被难住，你能帮帮他么？

## 说明/提示

#### 样例解释

一共五种玩偶，分别的价钱价值和限购次数为 $(2,3,4)$， $(1,2,1)$， $(4,1,2)$， $(2,1,1)$， $(3,2,3)$。

五个询问，以第一个询问为例。

第一个询问表示的是去掉编号为 $1$ 的玩偶， 且拥有的钱数为 $10$ 时可以获得的最大价值，则此时剩余玩偶为 $(2,3,4$)，$(4,1,2)$， $(2,1,1)$，$(3,2,3)$，若把编号为 $0$ 的玩偶买 $4$ 个（即全买了），然后编号为 $3$ 的玩偶 买一个，则刚好把 $10$ 元全部花完，且总价值为 $13$。可以证明没有更优的方案了。

注意买某种玩偶不一定要买光。

---

#### 数据规模与约定

- 对于 $10\%$ 的数据，保证 $n \leq 10$。
- 另外存在 $20\%$ 的数据，保证  $n \leq 100$，$c_i = 1$，$q \leq 100$。
- 另外存在 $20\%$ 的数据，保证 $n \leq 100$，$q \leq 100$。
- 另外存在 $30\%$ 的数据，保证 $c_i = 1$。
- 对于 $100\%$ 的数据，保证  $1 \leq n \leq 1000$，$1 \leq q \leq 3\times 10^5$， $1 \leq a_i,b_i,c_i \leq 100$，$0 \leq d_i < n$，$0 \leq e_i \leq 1000$。



## 样例 #1

### 输入

```
5 
2 3 4 
1 2 1 
4 1 2 
2 1 1 
3 2 3 
5 
1 10 
2 7 
3 4 
4 8 
0 5```

### 输出

```
13 
11 
6 
12 
4 
```

# AI分析结果



## 算法分类
动态规划（多重背包预处理 + 前后缀分解）

---

## 题解思路与核心难点

### 核心思路
题目要求在排除某物品时快速计算多重背包的最优解。各题解的核心思路可概括为：
1. **二进制拆分**：将每个物品按 2 的幂次拆分，转化为 0-1 背包问题
2. **前后缀预处理**：分别计算正向（`f1`）和逆向（`f2`）的背包数组
3. **合并答案**：查询时枚举排除物品的前后金钱分配，合并前后缀结果

### 解决难点
1. **快速排除物品**：通过预处理前后缀数组，避免每次查询重新计算整个背包
2. **时间复杂度优化**：二进制拆分将复杂度从 O(NC) 降为 O(NlogC)，前后缀分解使查询复杂度降为 O(V)
3. **物品边界处理**：正确找到二进制拆分后物品的左右边界，确保排除物品的所有拆分项

---

## 题解评分（≥4星）

### 1. lqhsr（⭐⭐⭐⭐⭐）
- **亮点**：代码结构清晰，通过 `f1`/`f2` 预处理实现 O(1) 查询
- **关键代码**：二进制拆分预处理物品 + 左右边界查找合并答案
- **优化点**：用 `while` 循环快速定位排除物品的边界

### 2. Gu_Pigeon（⭐⭐⭐⭐⭐）
- **亮点**：引入 CDQ 分治思想，理论复杂度最优（O(NlogN)）
- **创新点**：分治过程中动态维护背包状态，适合大数据量场景
- **代码特色**：使用单调队列优化多重背包转移

### 3. cyy233（⭐⭐⭐⭐）
- **亮点**：最简短的实现，直接定义前/后缀二维数组
- **易读性**：完整展示二进制拆分与合并逻辑，适合新手理解
- **优化空间**：二维数组内存占用较大，可用滚动数组优化

---

## 最优技巧提炼
1. **二进制拆分技巧**  
   ```cpp
   while(now <= c) {  // 幂次拆分
       w[++cnt] = a*now; v[cnt] = b*now;
       c -= now; now *= 2;
   }
   if(c) { w[++cnt] = a*c; v[cnt] = b*c; }  // 剩余部分
   ```
   将数量 c 分解为 2^k 的幂次之和，将多重背包转为 0-1 背包

2. **前后缀合并法**  
   ```cpp
   for(int j=0; j<=V; j++)
       ans = max(ans, f1[l][j] + f2[r+1][V-j]);
   ```
   枚举前部分使用 `j` 元，后部分使用 `V-j` 元的最优组合

3. **分治回溯优化**  
   ```cpp
   memcpy(f[d], f[d-1], sizeof(f[d]));  // 保存当前状态
   dp(mid+1, r);                        // 处理右半部分
   cdq(d+1, l, mid);                    // 递归左半
   memcpy(f[d], f[d-1], sizeof(f[d]));  // 回溯状态
   dp(l, mid);                          // 处理左半
   cdq(d+1, mid+1, r);                  // 递归右半
   ```
   通过状态保存与回溯实现分治过程中的动态规划

---

## 类似题目推荐
1. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)（多重背包模板）
2. [P1858 多人背包](https://www.luogu.com.cn/problem/P1858)（前 K 优解背包）
3. [P3810 三维偏序](https://www.luogu.com.cn/problem/P3810)（CDQ 分治经典题）

---

## 可视化设计（核心算法演示）

### 动画方案
1. **二进制拆分演示**  
   - 用像素方块表示物品数量，按 2 的幂次分解为不同颜色块
   - 动态显示拆分过程，如 7 → 4+2+1

2. **前后缀背包计算**  
   - 用两个进度条分别表示正向和逆向的 DP 计算
   - 高亮当前处理的物品，显示其价值与重量

3. **合并答案过程**  
   - 用滑动条表示金钱分配比例（前 j 元 / 后 V-j 元）
   - 实时显示合并后的最大值，用颜色区分不同分配方案

### 复古像素风格
```javascript
// Canvas 绘制示例
function drawPixel(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*10, y*10, 9, 9); // 10x10 像素块
}

// 背包状态可视化
for(let j=0; j<=V; j++) {
    let color = `hsl(${f1[i][j]/max*240}, 100%, 50%)`;
    drawPixel(j, i, color); // 用色相表示价值
}
```

### 音效设计
- **拆分物品**：8-bit 分解音（类似《俄罗斯方块》消除音）
- **DP 转移**：短促电子音，音高随价值增加而升高
- **合并答案**：成功音效（类似《超级马里奥》吃金币声）

---

## 核心代码实现（lqhsr 版）
```cpp
// 二进制拆分预处理
int ji = 0;
for(int i=1; i<=n; i++) {
    int cw, cv, c;
    cin >> cw >> cv >> c;
    int now = 1;
    while(now <= c) {
        w[++ji] = cw * now;
        v[ji] = cv * now;
        now *= 2;
        c -= now / 2;
    }
    if(c) w[++ji] = cw * c, v[ji] = cv * c;
}

// 前后缀 DP 计算
for(int i=1; i<=ji; i++) {
    for(int j=0; j<=1000; j++) f1[i][j] = f1[i-1][j];
    for(int j=1000; j>=w[i]; j--)
        f1[i][j] = max(f1[i][j], f1[i-1][j-w[i]] + v[i]);
}
for(int i=ji; i>=1; i--) {
    for(int j=0; j<=1000; j++) f2[i][j] = f2[i+1][j];
    for(int j=1000; j>=w[i]; j--)
        f2[i][j] = max(f2[i][j], f2[i+1][j-w[i]] + v[i]);
}

// 查询处理
int cn = del_item_id + 1, V = money;
int l = 0, r = 0;
while(w[l+1].id < cn && l < n) l++;
while(w[r+1].id <= cn && r < n) r++;
ll ans = 0;
for(int j=0; j<=V; j++)
    ans = max(ans, f1[l][j] + f2[r+1][V-j]);
```

---
处理用时：93.87秒
# 题目信息

# 河城荷取的烟花

## 题目背景

#宴会已经接近尾声
![](https://cdn.luogu.com.cn/upload/pic/15119.png)

## 题目描述

快乐的时光总是这么短暂，这场宴会终究将要闭幕。

为了给大家留下一个深刻而美好的印象，萃香拜托掌握着顶尖科技的河城荷取用她刚刚研制出的装置来点燃烟花。

这个装置由3部分构成——一些长度为1的绳子，一些长度为$\sqrt{ 2 }$的绳子，还有一块不能燃烧的木板。河城荷取将木板划分成长度为 1 的单元格，并标上坐标，之后将这些绳子摆在木板上连接成一个连通图(即绳子上的任意两点均可互相到达)。注意，这些绳子的两端必须放在单元格的顶点上，即长度为 1 的绳子只能放在单元格的某一边上，长度为$\sqrt{ 2 }$的绳子只能放在单元格的某一对角线上。

现在，河城荷取会在木板上任意一根绳子的端点处点火(不能从绳子的中间处点火)，点火后，火会沿着绳子向前燃烧（每根绳子都有自己的燃烧速度），并能点燃与它相接的其它绳子。

比如说下面这张图，河城荷取不能在 A 点点火，但在 C 点或 B点点火都是充许的。

![](https://cdn.luogu.com.cn/upload/pic/15120.png)

为了演出效果，河城荷取必须保证所有绳子都燃烧完的总时间最短，可是由于绳子的条数过多，所以河城荷取找到了你来帮忙，让你帮她求出最短的总时间是多少。

如果你能完成这个任务，你就会获得两个奖励——100分和观赏一场盛大的烟花盛宴！


## 说明/提示

【样例一解释】:从任一端点火都行，燃烧时间都是 1

【样例二解释】:

在 (0,0)位置点火，绳子 1, 3 和 4 将被点燃，燃烧 0.5 分钟后，绳子 2 将被从中间点燃向两端燃烧，再过 0.5 分钟，绳子 1, 3, 4 将被完全燃烧，绳子5将被点燃并在 1分钟后燃烧完 (比绳子 2 早燃完)。

绳子 2 从中间向两端燃烧 0.5 分钟以后，变成两小段，每段的燃烧时间是 4.5
分钟。但因为此时两小段绳子的另一端也同时被点燃，燃烧速度变成原来的
两倍，还需 2.25 分钟的燃烧时间， 所以总时间： 1 + 2.25 = 3.25

【数据范围】:

![](https://cdn.luogu.com.cn/upload/pic/15213.png)

## 样例 #1

### 输入

```
1
0 0 1 1 1```

### 输出

```
1.0000```

## 样例 #2

### 输入

```
5
0 0 0 1 1
1 0 0 1 10
0 0 1 0 1
0 0 1 1 1
2 2 1 1 1```

### 输出

```
3.2500```

# AI分析结果



## 算法分类
最短路

---

## 题解思路与核心难点

### 核心算法流程
1. **图结构建模**：将每根绳子拆分为两段，以端点及中间点为节点构建无向图，边权为燃烧时间的一半
2. **最短路计算**：使用SPFA算法计算每个可能点火点到所有节点的最短路径
3. **相遇时间计算**：根据两端点燃烧时间差，推导绳子完全燃尽的时间公式
4. **答案聚合**：枚举所有合法点火点，取所有绳子燃尽时间的最大值中的最小值

### 解决难点对比
| 题解               | 坐标处理                           | 中间点标记          | 时间复杂度          | 实现复杂度 |
|--------------------|----------------------------------|-------------------|-------------------|----------|
| Ireliaღ (拆绳法)   | 坐标乘2避免小数                  | 独立标记中间点      | O(kE) SPFA        | ★★★★     |
| Wy12121212 (Floyd) | 直接坐标映射                     | 无特殊处理         | O(n³)             | ★★       |
| XSZCaesar (SPFA)   | 坐标偏移+乘2处理                | 数组标记中间点      | O(kE)             | ★★★★     |
| grard4 (坐标离散化) | 坐标离散化为整数               | 哈希表标记中间点    | O(kE)             | ★★★★     |

### 关键推导公式
对于两端点燃时间t1、t2和燃烧速度v：
- 当 |t1-t2| ≥ 0.5/v 时，完全燃烧时间 = max(t1, t2) + 0.5/v
- 否则，时间 = (t1 + t2)/2 + 0.25/v

---

## 最优思路提炼
1. **离散化建图**：将坐标映射为整数节点，解决浮点精度问题
2. **中间点拆分**：斜边拆分为两段，避免相交时的复杂处理
3. **动态最短路**：SPFA算法适应多次查询不同点火点的场景
4. **时间聚合策略**：通过预处理所有边的最晚燃尽时间，快速计算全局最优

---

## 题解评分（≥4★）
1. Ireliaღ（4.5★）
   - 亮点：完整实现拆绳策略，详细注释说明中间点标记
   - 代码：结构清晰，使用链式前向星存储图
   - 优化：坐标乘2避免浮点运算

2. XSZCaesar（4.2★）
   - 亮点：严谨处理坐标偏移，相遇问题推导完整
   - 代码：包含坐标映射模板，易于扩展
   - 不足：缺少中间点标记说明

3. grard4（4.0★）
   - 亮点：哈希表处理离散坐标，动态删除无效边
   - 创新：使用双队列优化SPFA
   - 不足：代码注释较少

---

## 核心代码实现
```cpp
// 坐标离散化与中间点拆分
void SetStick(int x1, int y1, int x2, int y2, double len) {
    x1 = (x1 + 1000) * 2;  // 坐标偏移及乘2处理
    y1 = (y1 + 1000) * 2;
    x2 = (x2 + 1000) * 2;
    y2 = (y2 + 1000) * 2;
    
    int mid_x = (x1 + x2) / 2;
    int mid_y = (y1 + y2) / 2;
    
    // 创建或获取节点ID
    int u = GetID(x1, y1);
    int v = GetID(x2, y2);
    int mid = GetID(mid_x, mid_y);
    
    // 标记中间点不可点火
    forbidden[mid] = true;
    
    // 拆分边并建图
    AddEdge(u, mid, len/2);
    AddEdge(mid, v, len/2);
}

// 相遇时间计算
double CalcBurnTime(int edge_id) {
    int u = edges[edge_id].u;
    int v = edges[edge_id].v;
    double t1 = dis[u], t2 = dis[v];
    double v_inv = edges[edge_id].speed;
    
    if(fabs(t1 - t2) >= 0.5 / v_inv) {
        return max(t1, t2) + 0.5 / v_inv;
    } else {
        return (t1 + t2)/2 + 0.25 / v_inv;
    }
}
```

---

## 可视化设计
### 像素风格演示方案
1. **坐标系构建**  
   - 使用16x16像素网格表示木板单元格
   - 红色像素点表示绳子的端点，黄色表示中间点
   - 蓝色线条表示水平/竖直绳子，绿色表示斜向绳子

2. **燃烧动画**  
   ```javascript
   class FireSimulator {
       constructor(canvas) {
           this.grid = new PixelGrid(canvas, 32, 32); // 32x32像素画布
           this.burningEdges = new Set();
           this.activeFires = new Map();
       }
       
       // 点燃动画
       ignite(x, y) {
           const id = coordToId(x, y);
           this.activeFires.set(id, 0);
           this.grid.setPixel(x, y, 0xFF4500); // 橙色火焰
           playSound('ignite.wav');
       }
       
       // 蔓延过程
       update(dt) {
           for(const [id, time] of this.activeFires) {
               const neighbors = getConnectedEdges(id);
               for(const edge of neighbors) {
                   const burnTime = time + edge.length / edge.speed;
                   if(!this.burningEdges.has(edge.id) || burnTime < this.burningEdges.get(edge.id)) {
                       this.burningEdges.set(edge.id, burnTime);
                       // 绘制燃烧进度
                       drawEdgeProgress(edge, time / burnTime);
                   }
               }
           }
       }
   }
   ```

3. **交互功能**
   - 空格键：暂停/继续燃烧动画
   - 方向键：调节燃烧速度（0.5x~4x）
   - 鼠标点击：手动选择点火点

---

## 相似题目推荐
1. P1144 最短路计数（最短路应用）
2. P1462 通往奥格瑞玛的道路（最短路+二分）
3. P3831 [SHOI2012]回家的路（分层图最短路）

---

## 学习心得
> "处理坐标离散化时，最初直接使用浮点数导致精度错误。后来将坐标放大两倍并转为整数，配合哈希表映射，成功解决此问题。" —— Ireliaღ

此经验说明在处理几何问题时，将浮点坐标转换为整数处理能有效避免精度错误，同时提高代码效率。

---
处理用时：85.98秒
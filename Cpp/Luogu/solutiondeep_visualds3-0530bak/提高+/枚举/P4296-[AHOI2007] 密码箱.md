# 题目信息

# [AHOI2007] 密码箱

## 题目描述

在一次偶然的情况下，小可可得到了一个密码箱，听说里面藏着一份古代流传下来的藏宝图，只要能破解密码就能打开箱子，而箱子背面刻着的古代图标，就是对密码的提示。

经过艰苦的破译，小可可发现，这些图标表示一个数以及这个数与密码的关系。假设这个数是 $n$，密码为 $x$，那么可以得到如下表述： 密码 $x$ 大于等于 $0$，且小于 $n$，而 $x$ 的平方除以 $n$，得到的余数为 $1$。 小可可知道满足上述条件的 $x$ 可能不止一个，所以一定要把所有满足条件的 $x$ 计算出来，密码肯定就在其中。计算的过程是很艰苦的，你能否编写一个程序来帮助小可可呢？

## 样例 #1

### 输入

```
12```

### 输出

```
1
5
7
11```

# AI分析结果



---

## 唯一算法分类
**数学问题（因数分解与同余方程）**

---

## 题解思路、算法要点与解决难点

### 核心思路
题目要求解同余方程 $x^2 \equiv 1 \pmod{n}$，转化为 $(x+1)(x-1) \equiv 0 \pmod{n}$。通过枚举 $n$ 的因数对 $(a,b)$，满足 $a \cdot b = n$，并寻找满足 $a|(x+1)$ 且 $b|(x-1)$ 或 $a|(x-1)$ 且 $b|(x+1)$ 的 $x$ 值。

### 算法要点
1. **因数分解**：枚举 $n$ 的所有因数对 $(a, b)$，仅需枚举至 $\sqrt{n}$ 以优化时间复杂度。
2. **生成候选解**：对每个因数对，构造 $x = k \cdot b \pm 1$，检查是否符合模运算条件。
3. **去重与排序**：使用集合（`set`）或排序后去重，确保结果唯一且有序。

### 解决难点
- **高效生成解**：通过枚举因数对避免暴力枚举所有可能的 $x$，时间复杂度优化至 $O(\sqrt{n} \log n)$。
- **避免重复解**：通过数学推导确保每个候选解只生成一次，利用集合自动去重。
- **边界处理**：处理 $n=1$ 的特殊情况，以及确保 $x < n$。

---

## 题解评分 (≥4星)

### 题解1：JuRuo_QAQ（★★★★☆）
- **思路清晰度**：明确因数分解与解构造逻辑。
- **代码可读性**：结构简洁，使用 `set` 自动去重。
- **优化程度**：合理剪枝，仅枚举至 $\sqrt{n}$。
- **代码片段**：
  ```cpp
  for (ll a = i, b = n / i; ...) {
      for (j = b + 1; ...) if ((j+1) % a == 0) s.insert(j);
      for (j = b - 1; ...) if ((j-1) % a == 0) s.insert(j);
  }
  ```

### 题解2：试试事实上吗（★★★★☆）
- **思路清晰度**：详细推导同余条件，强调唯一分解定理。
- **代码可读性**：使用 `st.insert(1)` 直接包含 $x=1$。
- **优化亮点**：通过 `sn = sqrt(n)` 减少循环次数。

### 题解3：lemir3（★★★★☆）
- **思路清晰度**：代码注释详尽，解释数学推导。
- **去重方法**：使用 `std::unique` 处理数组去重。
- **代码亮点**：显式处理 $x=1$，确保不漏解。

---

## 最优思路或技巧提炼

### 关键步骤
1. **因数对枚举**：对每个因数对 $(a,b)$，构造 $x = k \cdot b \pm 1$。
2. **模条件检查**：验证 $(x+1) \bmod a = 0$ 或 $(x-1) \bmod a = 0$。
3. **集合去重**：自动处理重复解，保证输出唯一。

### 代码实现技巧
```cpp
// 枚举因数对 (a, b)
for (ll i = 1; i * i <= n; ++i) {
    if (n % i != 0) continue;
    ll a = i, b = n / i;
    // 生成 x = k*b +1 并检查条件
    for (ll j = b + 1; j <= n; j += b) {
        if ((j + 1) % a == 0) s.insert(j);
    }
    // 生成 x = k*b -1 并检查条件
    for (ll j = b - 1; j <= n; j += b) {
        if ((j - 1) % a == 0) s.insert(j);
    }
}
```

---

## 同类型题或类似算法套路

### 相似问题特征
- **模方程求解**：如 $x^k \equiv c \pmod{n}$。
- **因数分解应用**：需要将问题转化为因数乘积形式。

### 通用解法
1. **分解模数**：将 $n$ 分解为多个因数。
2. **构造解**：利用因数关系构造候选解。
3. **合并解**：通过中国剩余定理（CRT）或暴力枚举合并解。

---

## 推荐题目
1. **P1365** - 模方程 $x^2 \equiv a \pmod{p}$（二次剩余）。
2. **P4549** - 裴蜀定理（求解线性同余方程）。
3. **P1495** - 中国剩余定理（CRT）。

---

## 个人心得摘录
- **调试教训**：忽略 $n=1$ 导致 WA，需特判边界条件。
- **优化感悟**：通过只枚举到 $\sqrt{n}$ 将时间复杂度从 $O(n)$ 降至 $O(\sqrt{n})$。
- **代码简洁**：使用 `set` 简化去重逻辑，但需注意其内部红黑树的常数开销。

---

## 可视化与算法演示

### 动画方案
1. **因数分解步骤**：以网格展示 $n$ 的因数分解过程，高亮当前枚举的因数对 $(a,b)$。
2. **生成候选解**：动态显示 $x = k \cdot b \pm 1$ 的生成过程，用不同颜色区分有效/无效解。
3. **去重与排序**：展示集合插入过程，自动过滤重复值。

### 复古像素风格设计
- **颜色方案**：16 色调色板，绿色表示有效解，红色表示无效解。
- **音效设计**：
  - **有效解**：8-bit 上升音效。
  - **无效解**：短促“哔”声。
- **Canvas 动画**：因数对在网格中高亮，候选解以像素方块飞入结果区域。

### 交互设计
- **步进控制**：允许暂停/继续，调整动画速度。
- **自动模式**：AI 自动枚举因数对并生成解，类似“自动播放解题”。

---

**示例代码（关键动画逻辑）**  
```javascript
// 绘制因数对 (a, b)
ctx.fillStyle = '#FF0000'; // 红色高亮当前因数
ctx.fillRect(a * cellSize, b * cellSize, cellSize, cellSize);

// 生成候选解动画
function animateX(x, isValid) {
    if (isValid) playSound('success'); // 播放成功音效
    // 方块飞入结果区域...
}
```

--- 

通过上述分析，解题关键在于数学转化与高效枚举，结合可视化可更直观理解算法流程。

---
处理用时：83.44秒
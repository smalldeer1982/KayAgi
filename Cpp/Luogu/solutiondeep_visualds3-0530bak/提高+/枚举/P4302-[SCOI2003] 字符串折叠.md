# 题目信息

# [SCOI2003] 字符串折叠

## 题目描述

折叠的定义如下：

1. 一个字符串可以看成它自身的折叠。记作 ```S = S```

2. ```X(S)``` 是 $X$ 个 ```S``` 连接在一起的串的折叠。记作 ```X(S) = SSSS…S```。

3. 如果 ```A = A’```, ```B = B’```，则 ```AB = A’B’ ```。例如：因为 ```3(A) = AAA```, ```2(B) = BB```，所以 ```3(A)C2(B) = AAACBB```，而 ```2(3(A)C)2(B) = AAACAAACBB```

给一个字符串，求它的最短折叠。

例如 ```AAAAAAAAAABABABCCD``` 的最短折叠为：```9(A)3(AB)CCD```。

## 说明/提示

一个最短的折叠为：`2(NEERC3(YES))`

## 样例 #1

### 输入

```
NEERCYESYESYESNEERCYESYESYES```

### 输出

```
14```

# AI分析结果



# 算法分类与题解分析

**唯一算法分类**：区间动态规划（区间DP）

---

## 题解思路与核心难点

### 核心思路
1. **状态定义**：`f[i][j]` 表示字符串区间 `[i,j]` 的最短折叠长度。
2. **状态转移**：
   - **分割区间**：枚举分割点 `k`，将区间分为 `[i,k]` 和 `[k+1,j]`，更新 `f[i][j] = min(f[i][j], f[i][k] + f[k+1][j])`。
   - **循环节折叠**：检查区间 `[i,j]` 是否能被某个子串重复组成。若能，计算折叠后的长度（数字位数 + 2（括号） + 循环节长度）。
3. **循环节检查**：通过遍历可能的循环节长度，判断是否所有位置字符匹配。

### 解决难点
1. **循环节判断**：需要高效检查区间是否由重复子串构成，例如通过双重循环或模运算。
2. **数字位数处理**：折叠前缀的数字位数需预处理（如 `m[100]=3`）。
3. **边界与初始化**：单字符区间初始化为 1，其他初始化为极大值。

---

## 题解评分（≥4星）

### 1. kradcigam（5星）
- **亮点**：代码简洁高效，预处理数字位数，四层循环但通过剪枝优化时间复杂度。
- **代码片段**：
  ```cpp
  bool check(int l, int r, int len) {
      for (int i=l; i<=r; i++)
          if (st[i] != st[(i-l)%len + l]) return false;
      return true;
  }
  // 更新状态时检查循环节
  if (check(i, j, len)) f[i][j] = min(f[i][j], f[i][k] + 2 + m[l/len]);
  ```

### 2. Plus_Ultra（4星）
- **亮点**：代码短小精悍，使用 `check` 函数直接遍历循环节。
- **代码片段**：
  ```cpp
  void check(int l, int r, int len) {
      if ((r-l+1) % len) return;
      for (int i=l; i<=r; i++)
          if (s[i] != s[(i-l)%len + l]) return;
      f[l][r] = min(f[l][r], f[l][l+len-1] + 2 + leng[(r-l+1)/len]);
  }
  ```

### 3. Mathison（4星）
- **亮点**：记忆化搜索实现，直观展示递归分解思路。
- **代码片段**：
  ```cpp
  int dfs(int l, int r) {
      if (f[l][r] != INF) return f[l][r];
      for (int k=l; k<r; k++)
          f[l][r] = min(f[l][r], dfs(l,k) + dfs(k+1,r));
      if (check(l, r)) // 更新折叠状态...
      return f[l][r];
  }
  ```

---

## 最优思路提炼
1. **区间分割与合并**：通过动态规划分割区间，合并子区间最优解。
2. **循环节快速判断**：仅检查区间长度的因数，避免无效遍历。
3. **数字位数预处理**：提前计算 1~100 的位数，减少重复计算。

---

## 类似题目与算法套路
- **同类型题**：石子合并、回文子串分割、括号匹配。
- **通用套路**：区间DP适用于子问题可分解为连续区间的场景，如字符串压缩、矩阵链乘法。

---

## 推荐题目
1. **P1435 回文字串**（区间DP处理回文插入）
2. **P1063 能量项链**（环形区间DP）
3. **P1880 石子合并**（经典区间DP）

---

## 可视化设计
### 动画方案
1. **区间高亮**：用不同颜色标记当前处理的区间 `[i,j]`。
2. **循环节检查**：以闪烁效果显示正在检查的循环节子串。
3. **状态更新**：动态显示 `f[i][j]` 的数值变化，对比分割与折叠后的长度。

### 复古像素风格
- **颜色方案**：8位色调色板（深蓝、红、绿），用网格显示字符串和DP表格。
- **音效**：检查成功时播放“滴”声，折叠更新时播放“咔嚓”声。
- **Canvas 绘制**：将字符串字符绘制为像素块，DP表格用方格表示，当前操作高亮。

### 代码片段（伪代码）
```javascript
// 绘制区间 [i,j] 和循环节检查
function drawInterval(i, j, len) {
    ctx.fillStyle = "#FF0000"; // 红色高亮
    ctx.fillRect(i*10, j*10, len*10, 10); // 模拟像素块
    playSound("beep"); // 触发音效
}
```

---

## 个人心得摘录
- **kradcigam**：强调预处理和剪枝的重要性，避免无谓循环。
- **浅色调**：使用 `stringstream` 简化字符串操作，但需注意效率。
- **HenryHuang**：调试时发现循环节判断错误是常见陷阱，需逐字符验证。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
string st;
int n, m[110], f[110][110];

bool check(int l, int r, int len) {
    for (int i=l; i<=r; i++)
        if (st[i] != st[(i-l)%len + l]) return false;
    return true;
}

int main() {
    cin >> st;
    n = st.size();
    st = ' ' + st;
    for (int i=1; i<=9; i++) m[i]=1;
    for (int i=10; i<=99; i++) m[i]=2;
    m[100] = 3;
    memset(f, 0x3f, sizeof(f));
    for (int i=1; i<=n; i++) f[i][i] = 1;
    
    for (int l=2; l<=n; l++) {
        for (int i=1, j=i+l-1; j<=n; i++, j++) {
            for (int k=i; k<j; k++)
                f[i][j] = min(f[i][j], f[i][k] + f[k+1][j]);
            for (int k=i; k<j; k++) {
                int len_k = k-i+1;
                if (l % len_k != 0) continue;
                if (check(i, j, len_k))
                    f[i][j] = min(f[i][j], f[i][k] + 2 + m[l/len_k]);
            }
        }
    }
    cout << f[1][n];
    return 0;
}
```

---
处理用时：85.44秒
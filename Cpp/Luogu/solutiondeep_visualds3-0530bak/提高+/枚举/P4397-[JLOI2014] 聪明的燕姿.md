# 题目信息

# [JLOI2014] 聪明的燕姿

## 题目背景

> 阴天傍晚车窗外
>
> 未来有一个人在等待
>
> 向左向右向前看
>
> 爱要拐几个弯才来
>
> 我遇见谁会有怎样的对白
>
> 我等的人他在多远的未来
>
> 我听见风来自地铁和人海
>
> 我排着队拿着爱的号码牌

## 题目描述

城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。

可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 $S$，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 $S$。

所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。

## 说明/提示

对于 $100\%$ 的数据，$k\leqslant100$，$S\leqslant2\times10^9$。

## 样例 #1

### 输入

```
42```

### 输出

```
3
20 26 41```

# AI分析结果



---

### **唯一算法分类**  
**深度优先搜索（DFS） + 数论优化**

---

### **题解思路、算法要点与解决难点**  

#### **核心思路**  
所有题解均基于**约数和定理**和**唯一分解定理**，通过 DFS 分解 S 的约数和形式，反向构造可能满足条件的数。核心步骤如下：  
1. **预处理质数**：筛法生成 $\sqrt{S}$ 范围内的质数表。  
2. **DFS 分解**：递归枚举质数的幂次组合，使得每个质数的幂次和（$1+p_i+p_i^2+...+p_i^k$）的乘积等于 S。  
3. **剪枝优化**：  
   - **质数约束**：确保分解的质数严格递增，避免重复组合。  
   - **剩余值判断**：若剩余值 $now-1$ 是质数，则直接构造解。  
   - **平方约束**：仅枚举质数到 $\sqrt{now}$。  

#### **关键变量设计**  
- `dfs(now, x, s)`：  
  - `now`：当前剩余待分解的 S 值。  
  - `x`：当前枚举的质数索引（保证质数递增）。  
  - `s`：已构造的数（各质数幂次乘积）。  

#### **难点与解决方案**  
- **质数判断优化**：对 $\leq 10^5$ 的质数预处理，对 $>10^5$ 的数使用试除法。  
- **剪枝条件设计**：通过数学推导发现，当剩余值 $now-1$ 是质数时，可直接构造解。  
- **重复解处理**：DFS 结束后对结果排序去重。

---

### **题解评分**  

#### **≥4星题解清单**  
1. **ycyaw（5星）**  
   - **亮点**：代码结构清晰，注释详细；剪枝条件完整（质数判断、平方约束）；预处理质数高效。  
   - **关键代码**：  
     ```cpp  
     void dfs(int now, int x, int s) {  
         if (now == 1) ans[++cnt] = s;  
         if (pd(now - 1)) ans[++cnt] = s * (now - 1);  
         for (int i = x; pr[i] * pr[i] <= now; i++) {  
             // 枚举质数幂次和  
         }  
     }  
     ```  

2. **LaoPi（4星）**  
   - **亮点**：参数命名明确（`now_S`, `now_div`）；特判逻辑独立封装，提高可读性。  
   - **优化点**：单独处理 `now_S - 1` 的质数判断。  

3. **timmark（4星）**  
   - **亮点**：使用 `Map` 缓存质数和组合；去重逻辑通过 `unique` 实现，减少内存占用。  
   - **技巧**：质数和的哈希映射加速分解过程。  

---

### **最优思路或技巧提炼**  

1. **数学优化剪枝**  
   - **质数判断**：对 $\sqrt{S}$ 内的质数预处理，大数用试除法。  
   - **剩余值特判**：若 $now-1$ 是质数，则 $(now-1) \times s$ 是解。  

2. **DFS参数设计**  
   - 传递质数索引 `x`，强制质数递增，避免重复组合。  

3. **质数幂次和计算**  
   - 使用循环累加代替公式计算（避免浮点误差）：  
     ```cpp  
     for (ll sum = p + 1, t = p; sum <= now; t *= p, sum += t)  
         if (now % sum == 0) dfs(...);  
     ```  

---

### **同类型题推荐**  
1. **P1072 [NOIP2009 提高组] Hankson 的趣味题**（质因数分解 + 约数约束）  
2. **P1069 [NOIP2009 普及组] 细胞分裂**（质数幂次分解）  
3. **P1361 [集训队] 最小公倍数**（质数覆盖与约数性质）  

---

### **可视化与算法演示**  

#### **动画设计**  
1. **像素风格界面**：  
   - **质数块**：绿色像素块表示质数，红色表示当前选中质数。  
   - **剩余值显示**：顶部显示当前待分解的 $now$ 值。  

2. **关键步骤高亮**：  
   - **DFS分解**：黄色边框标记当前枚举的质数。  
   - **剪枝触发**：紫色闪烁提示 $now-1$ 是质数。  

3. **控制面板**：  
   - **速度调节**：滑块控制 DFS 单步执行速度（10ms~1s）。  
   - **暂停/继续**：Space 键控制动画启停。  

#### **音效设计**  
- **质数选中**：8-bit 短促“滴”声。  
- **找到解**：经典 FC 过关音效。  
- **错误尝试**：低沉蜂鸣声。  

---

### **代码实现（核心 DFS）**  
```cpp  
vector<int> primes; // 预处理质数表  

void dfs(int now, int idx, ll product) {  
    if (now == 1) {  
        ans.push_back(product);  
        return;  
    }  
    // 特判 now-1 是质数  
    if (now > primes[idx] && is_prime(now - 1))  
        ans.push_back(product * (now - 1));  
    // 枚举质数幂次  
    for (int i = idx; primes[i] * primes[i] <= now; i++) {  
        ll sum = primes[i] + 1, t = primes[i];  
        for (int j = 1; sum <= now; j++) {  
            if (now % sum == 0)  
                dfs(now / sum, i + 1, product * t);  
            t *= primes[i];  
            sum += t;  
        }  
    }  
}  
```  

---

### **个人心得摘录**  
- **调试教训**：未处理质数递增导致重复解（如 $20=2^2 \times 5$ 和 $5 \times 2^2$ 被误判为不同解）。  
- **优化顿悟**：大质数判断分离预处理和试除法，时间从 2s 优化至 100ms。  

--- 

通过上述分析，可系统掌握约数和问题的 DFS 解法，并拓展至质数分解相关题目。

---
处理用时：78.21秒
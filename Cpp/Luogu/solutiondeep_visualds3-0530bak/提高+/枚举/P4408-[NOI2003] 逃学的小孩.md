# 题目信息

# [NOI2003] 逃学的小孩

## 题目描述

Chris 家的电话铃响起了，里面传出了 Chris 的老师焦急的声音：“喂，是 Chris 的家长吗？你们的孩子又没来上课，不想参加考试了吗？”一听说要考试，Chris 的父母就心急如焚，他们决定在尽量短的时间内找到 Chris。他们告诉 Chris 的老师：“根据以往的经验，Chris 现在必然躲在朋友 Shermie 或 Yashiro 家里偷玩《拳皇》游戏。现在，我们就从家出发去找 Chris，一旦找到，我们立刻给您打电话。”说完砰的一声把电话挂了。

Chris 居住的城市由 $N$ 个居住点和若干条连接居住点的双向街道组成，经过街道 $x$ 需花费 $T_{x}$ 分钟。可以保证，任意两个居住点间有且仅有一条通路。Chris 家在点 $C$，Shermie 和 Yashiro 分别住在点 $A$ 和点 $B$。Chris 的老师和 Chris 的父母都有城市地图，但 Chris 的父母知道点 $A$、$B$、$C$ 的具体位置而 Chris 的老师不知。

为了尽快找到 Chris，Chris 的父母会遵守以下两条规则：

1. 如果 $A$ 距离 $C$ 比 $B$ 距离 $C$ 近，那么 Chris 的父母先去 Shermie 家寻找 Chris，如果找不到，Chris 的父母再去 Yashiro 家；反之亦然。
2. Chris 的父母总沿着两点间唯一的通路行走。

显然，Chris 的老师知道 Chris 的父母在寻找 Chris 的过程中会遵守以上两条规则，但由于他并不知道 $A$、$B$、$C$ 的具体位置，所以现在他希望你告诉他，最坏情况下 Chris的父母要耗费多长时间才能找到 Chris？

## 说明/提示

对于 $100\%$ 的数据，$3 \le N \le 2\times 10^5$，$1 \le U_{i},V_{i} \le N$，$0 \le T_{i} \le 10^{9}$。

## 样例 #1

### 输入

```
4 3
1 2 1
2 3 1
3 4 1```

### 输出

```
4```

# AI分析结果



### 【唯一算法分类】  
树的直径 + 贪心

---

### **综合分析与结论**  
**核心算法流程**：  
1. **求树的直径**：通过两次DFS/BFS确定直径端点A、B，并计算直径长度。  
2. **计算各点到A、B的距离**：再次DFS/BFS得到每个点到A、B的最短距离。  
3. **遍历所有点**：取每个点C到A、B的较小距离，求其最大值，最终加上直径长度即为答案。  

**可视化设计思路**：  
- **像素动画**：以网格形式展示树结构，用不同颜色标记直径路径（红色）和候选点C（黄色）。  
- **动态距离计算**：高亮当前遍历的点，实时显示其到A/B的距离及min值。  
- **音效触发**：找到直径端点时播放“成功”音效，候选点更新最大值时播放“点击”音效。  
- **复古UI**：使用16色像素风格，直径用红色线段，候选点用闪烁方块，控制面板支持暂停/加速。  

---

### **题解清单 (≥4星)**  
1. **C3H5ClO（5星）**  
   - **亮点**：严谨的反证法证明贪心正确性，图文结合清晰解释路径关系。  
   - **代码**：DFS求直径，遍历计算min距离，逻辑严密。  

2. **人殇物已非（5星）**  
   - **亮点**：代码简洁高效，两次DFS求直径后直接计算距离，实践性强。  
   - **代码**：使用两次DFS和前缀处理，时间复杂度O(n)。  

3. **龙神哈迪斯（4星）**  
   - **亮点**：提供SPFA实现，适合理解广度优先搜索的读者。  
   - **心得**：强调开long long避免溢出，实用调试经验。  

---

### **最优思路提炼**  
**关键技巧**：  
1. **树的直径性质**：最长路径必为直径，确保A、B为端点。  
2. **贪心选择C点**：C的最优贡献为到A、B的较小距离的最大值。  
3. **三次遍历法**：两次DFS求直径，两次计算距离，时间复杂度O(n)。  

**代码片段**：  
```cpp
// 两次DFS求直径端点A和B
void dfs(int u, int fa) {
    for (auto &e : G[u]) {
        int v = e.to, w = e.w;
        if (v == fa) continue;
        dis[v] = dis[u] + w;
        if (dis[v] > max_dis) {
            max_dis = dis[v];
            far_node = v;
        }
        dfs(v, u);
    }
}
// 计算各点到A、B的距离并求答案
ll ans = 0;
for (int i = 1; i <= n; i++) {
    ans = max(ans, min(disA[i], disB[i]));
}
cout << diameter + ans;
```

---

### **同类型题与推荐**  
**相似题目**：  
1. **P1099 [NOIP2007] 树网的核**  
2. **P3304 [SDOI2013] 直径**  
3. **P5536 【XR-3】核心城市**  

**通用套路**：  
- 树的直径用于解决最长路径相关问题。  
- 结合贪心策略选择附加点（如本题的C点）。  

---

### **可视化与复古动画实现**  
**Canvas动画设计**：  
1. **树结构绘制**：节点用圆形像素块，边用线段，直径红色高亮。  
2. **动态遍历**：遍历C点时，显示其到A/B的距离及min值，最大值时闪烁。  
3. **音效触发**：  
   - 直径端点确定：8-bit上扬音效。  
   - 更新最大值：短促“滴”声。  

**代码片段（JS伪代码）**：  
```javascript
// 绘制直径路径
ctx.strokeStyle = '#FF0000'; // 红色像素线
ctx.beginPath();
ctx.moveTo(A.x, A.y);
ctx.lineTo(B.x, B.y);
ctx.stroke();

// 更新候选点动画
function highlightC(c) {
    ctx.fillStyle = '#FFFF00'; // 黄色闪烁
    ctx.fillRect(c.x-5, c.y-5, 10, 10);
    playSound('blip.wav');
}
```

---

### **个人心得摘录**  
- **DarthVictor**：调试时发现C点不一定在直径上，推翻初始假设后改用全局遍历。  
- **Kendrick_Z**：BFS中判断条件由`>`改为`>=`解决链状直径端点更新问题。  
- **huyufeifei**：树形DP尝试失败后回归贪心，强调“先直径后枚举”的普适性。  

---

### **总结**  
本题通过树的直径性质与贪心策略高效求解，可视化可结合像素动画与音效增强理解。核心代码简洁，重点在于三次遍历法与距离计算。

---
处理用时：67.53秒
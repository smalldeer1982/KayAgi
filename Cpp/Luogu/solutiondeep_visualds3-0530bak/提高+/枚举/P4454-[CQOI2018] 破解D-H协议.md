# 题目信息

# [CQOI2018] 破解D-H协议

## 题目背景

Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。

## 题目描述

假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\bmod$ 表示取模运算）：

1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\boldsymbol P$ 和 $\boldsymbol g$ 的数值都是公开的，无需保密。**

2. Alice 生成一个随机数 $a$，并计算 $A=g^a\bmod P$，将 $A$ 通过不安全信道发送给 Bob。

3. Bob 生成一个随机数 $b$，并计算 $B=g^b\bmod P$，将 $B$ 通过不安全信道发送给 Alice。

4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\bmod P$。

5. 双方得到了相同的 $K$，即 $g^{ab} \bmod P$。$K$ 即之后通讯的加密密钥。

可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。

当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。

$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。


## 说明/提示

对于 $30\%$ 的数据，$2\le A,B,P\le 1000$；

对于 $100\%$ 的数据，$2\le A,B<P<2^{31}，2\le g<20，1\le n\le 20$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
3 31
3
27 16
21 3
9 26```

### 输出

```
4
21
25```

# AI分析结果



**【唯一算法分类】**  
BSGS算法（离散对数问题）

---

### **题解思路与算法要点**  
**核心逻辑**：  
1. **BSGS求解离散对数**：已知 \(A = g^a \mod P\)，求解 \(a\)。  
   - 将 \(a = i \cdot m - j\)（\(m = \lceil \sqrt{P} \rceil\)），预处理 \(g^{i \cdot m} \mod P\) 存入哈希表。  
   - 枚举 \(j\)，计算 \(A \cdot g^j \mod P\) 并在哈希表中查找匹配项。  
2. **快速幂计算密钥**：求得 \(a\) 后，计算 \(K = B^a \mod P\)。  

**解决难点**：  
- **大数离散对数的高效求解**：BSGS算法通过分块预处理将时间复杂度降至 \(O(\sqrt{P})\)。  
- **多次查询优化**：预处理 \(g^m\) 的幂次，避免重复计算。  

---

### **题解评分 (≥4星)**  
1. **LeavingZzz (5星)**  
   - **亮点**：手写哈希表提升效率；预处理逻辑清晰。  
   - **代码片段**：  
     ```cpp  
     struct Hash_table { // 手写哈希表  
         static const LL MOD = 1999997;  
         LL Hash[MOD], V[MOD], stk[MOD], top;  
         void Insert(LL val, LL mi) {  
             LL h = val % MOD;  
             while (Hash[h] && Hash[h] != val) h++;  
             Hash[h] = val; V[h] = mi;  
         }  
         LL find(LL val) { /* ... */ }  
     };  
     ```  

2. **Leonid (4星)**  
   - **亮点**：代码简洁，适合快速理解BSGS流程。  
   - **代码片段**：  
     ```cpp  
     ll BSGS(ll a, ll b, ll p) {  
         map<ll, ll> k;  
         ll m = ceil(sqrt(p)), ans;  
         for (ll i = 0; i <= m; i++) { // 预处理哈希表  
             if (!i) ans = b % p;  
             else ans = (ans * a) % p;  
             k[ans] = i;  
         }  
         ll t = qpow(a, m, p);  
         for (ll i = 1; i <= m; i++) { // 查询匹配  
             ans = (ans * t) % p;  
             if (k.count(ans)) return i * m - k[ans];  
         }  
         return -1;  
     }  
     ```  

3. **MY (4星)**  
   - **亮点**：使用STL的`map`实现，代码可读性强。  
   - **个人心得**：强调BSGS模板的通用性，适合初学者。  

---

### **最优思路与技巧**  
1. **哈希表优化**：手写哈希表（如LeavingZzz）比STL的`map`更快，适合大范围数据。  
2. **预处理与分块**：将 \(g^{i \cdot m}\) 预处理存储，避免重复计算幂次。  
3. **逆向思维**：通过 \(x = i \cdot m - j\) 避免求逆元，简化计算。  

---

### **同类型题与拓展**  
- **通用解法**：离散对数问题均可套用BSGS或扩展BSGS。  
- **相似题目**：  
  1. [P3846【TJOI2007】可爱的质数](https://www.luogu.com.cn/problem/P3846)（BSGS模板题）  
  2. [P2485【SDOI2011】计算器](https://www.luogu.com.cn/problem/P2485)（综合数论题）  
  3. [P3306【SDOI2013】随机数生成器](https://www.luogu.com.cn/problem/P3306)（递推式离散对数）  

---

### **可视化与算法演示**  
**动画设计**：  
1. **分块预处理**：  
   - **颜色标记**：蓝色块表示 \(g^{i \cdot m}\) 预处理，绿色块表示 \(A \cdot g^j\) 枚举。  
   - **像素风格**：用16x16像素网格展示哈希表构建过程，每块填充不同颜色。  
   ```javascript  
   // 示例：绘制预处理块  
   ctx.fillStyle = '#3498db'; // 蓝色  
   for (let i = 0; i < m; i++) {  
       drawGridCell(i, 0); // 在Canvas网格中绘制  
   }  
   ```  

2. **匹配过程**：  
   - **高亮匹配项**：当哈希表中找到匹配值时，红色闪烁提示。  
   - **音效**：匹配成功时播放8-bit风格“胜利”音效。  

3. **步进控制**：  
   - 用户可通过按钮暂停/继续，观察预处理和查询步骤。  
   - 参数调节：允许输入不同 \(P, g, A, B\) 查看算法动态变化。  

**复古游戏化**：  
- **背景音乐**：循环播放8-bit风格背景音。  
- **积分系统**：每正确匹配一次得10分，错误扣5分。  

---

### **核心代码实现**  
**BSGS关键逻辑（LeavingZzz手写哈希）**：  
```cpp  
void init() {  
    LL sqrtm = ceil(sqrt(C));  
    LL ti = fast_pow(A, sqrtm); // 预处理g^m  
    LL t = ti;  
    for (LL i = 1; i <= sqrtm; i++) {  
        H.Insert(t, i * sqrtm);  
        t = t * ti % C;  
    }  
}  
LL BSGS(LL x) {  
    LL t = x;  
    for (int j = 0; j < sqrtm; j++) {  
        if (H.find(t)) return H.find(t) - j;  
        t = t * A % C;  
    }  
}  
```

---

### **总结**  
本题解核心在于BSGS算法的高效实现，手写哈希表显著提升性能。可视化设计通过分块动画与复古音效，直观展示算法分治思想。同类题目可沿用预处理+哈希查询的框架，灵活应对离散对数问题。

---
处理用时：70.29秒
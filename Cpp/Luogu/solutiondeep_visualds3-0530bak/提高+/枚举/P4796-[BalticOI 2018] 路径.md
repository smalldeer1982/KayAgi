# 题目信息

# [BalticOI 2018] 路径

## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day2「[Paths](https://boi18-day2-open.kattis.com/problems/boi18.paths)」**

给定一张 $N$ 个点 $M$ 条边的无向图，每个点有一个颜色，所有点的颜色共有 $K$ 种，编号为 $1\ldots K$。求图上有多少条长度至少为 $2$ 的简单路径，满足路径上的每一个点的颜色互不相同。

路径上的点的连接顺序不同看作不同的两条路径。

## 说明/提示

#### 样例 1 解释
![](https://gitee.com/mingqihuang/pics/raw/master/pathsfig.pdf.svg)

样例 1 中表达的图如上图所示。每个点的底色分别为白色（颜色 $1$）、灰色（颜色 $2$）或黑色（颜色 $3$）。共有 $10$ 条路径满足路径上的所有点的颜色都不同。它们是：``1-2``, ``2-1``, ``2-3``, ``3-2``, ``2-4``, ``4-2``, ``1-2-4``, ``4-2-1``, ``3-2-4`` 和 ``4-2-3``。

注意 ``1`` 不能看作是一条路径，因为一条路径至少连接两个点。``1-2-3`` 也不满足条件，因为有两个点都是 $1$ 号颜色。

|子任务|分值|数据范围|
|:--:|:--:|:--:|
|$1$|$23$|$1 \leqslant N,M \leqslant 100, 1 \leqslant K \leqslant 4$|
|$2$|$20$|$1 \leqslant N,M \leqslant 300\,000, 1 \leqslant K \leqslant 3$|
|$3$|$27$|$1 \leqslant N,M \leqslant 300\,000, 1 \leqslant K \leqslant 4$|
|$4$|$30$|$1 \leqslant N,M \leqslant 100\,000, 1 \leqslant K \leqslant 5$|

感谢 Hatsune_Miku 提供的翻译

## 样例 #1

### 输入

```
4 3 3
1 2 1 3
1 2
2 3
4 2```

### 输出

```
10

```

## 样例 #2

### 输入

```
9 11 4
1 2 3 4 1 2 1 2 2
1 2
1 3
2 3
2 4
3 6
6 2
6 5
4 3
4 5
7 8
9 8```

### 输出

```
70```

# AI分析结果



## 唯一算法分类：状态压缩动态规划

---

### 综合分析与结论

**核心思路**：  
利用状态压缩动态规划（DP），状态为 `dp[u][S]`，表示到达节点 `u` 时已使用的颜色集合为 `S`。初始化时，每个节点的单颜色状态 `S=1<<(col[u]-1)` 的路径数为1。按颜色数递增的顺序遍历状态，确保转移时前置状态已计算完成。每次扩展邻接节点时，若邻接节点的颜色未在 `S` 中出现，则将其颜色加入新状态并累加路径数。最终统计所有状态中颜色数≥2的路径总和。

**解决难点**：  
- **颜色不重复**：通过位掩码 `S` 快速判断颜色是否重复。
- **避免重复计数**：按颜色数递增处理状态，确保每个状态仅由更小的状态扩展而来。
- **高效遍历路径**：DP 状态数仅 `O(N·2^K)`，通过邻接表实现快速遍历。

**可视化设计**：  
- **颜色块与位掩码**：节点以不同颜色像素块表示，右侧显示当前状态 `S` 的二进制位（高亮已选颜色）。
- **状态转移动画**：当前处理的节点和状态高亮为黄色，邻接节点检查颜色后，合法转移时绿色闪烁，非法则红色闪烁。
- **音效与统计**：每次有效转移播放“滴”声，统计结果时播放成功音效，路径长度≥2时更新计数器。
- **复古像素风格**：使用 8-bit 调色板，节点呈网格排列，转移时箭头动画模仿经典 RPG 的移动效果。

---

### 题解清单（≥4星）

1. **GLZP（4星）**  
   - **亮点**：状态按颜色数排序确保正确转移，代码结构清晰易读。预处理 `book` 数组优化遍历顺序。
   - **代码片段**：排序状态后双重循环，外层遍历状态，内层遍历节点，检查颜色冲突后更新 `dp`。

2. **Error_Eric（4星）**  
   - **亮点**：极简代码实现，直接枚举状态并计算贡献。通过 `fun` 函数分离状态处理逻辑，代码高效。
   - **代码片段**：主循环枚举状态 `i`，对每个节点 `j` 检查颜色是否在 `i` 中，合法时更新邻接节点状态。

3. **activeO（4星）**  
   - **亮点**：使用 `num1` 函数统计颜色数，逻辑与 GLZP 类似但代码更紧凑。显式注释增强可读性。
   - **代码片段**：初始化 `dp` 后按排序状态循环，统计答案时直接累加满足条件的 `dp` 值。

---

### 最优思路与技巧

**关键技巧**：  
1. **状态压缩与顺序处理**：按状态中颜色数从小到大处理，确保前置状态已计算。
2. **邻接表遍历优化**：避免重复访问边，每个状态仅处理邻接节点一次。
3. **位运算快速判断**：用 `S & (1 << c)` 检查颜色是否存在，`S | (1 << c)` 添加新颜色。

**代码实现**（GLZP 核心逻辑）：
```cpp
for (ll i = 1; i <= S; i++) {
    ll t = book[i]; // 当前处理的状态（按颜色数排序）
    for (ll j = 1; j <= n; j++) {
        if (dp[j][t]) {
            if (check(t) >= 2) ans += dp[j][t]; // 统计有效路径
            for (ll k = head[j]; k; k = next[k]) {
                ll v = to[k];
                if (t & (1 << (col[v] - 1))) continue; // 颜色冲突
                dp[v][t | (1 << (col[v] - 1))] += dp[j][t]; // 状态转移
            }
        }
    }
}
```

---

### 同类题目推荐

1. **P2831 愤怒的小鸟**：状态压缩 DP 处理抛物线覆盖。
2. **P1879 Corn Fields**：状态压缩 DP 处理棋盘种植方案。
3. **P2704 炮兵阵地**：三维状态压缩 DP 处理炮兵攻击范围。

---

### 可视化算法演示

**动画流程**：  
1. **初始化**：所有节点显示为单颜色块，右侧显示初始状态 `S=1<<(col[u]-1)`。
2. **状态遍历**：按颜色数从低到高遍历状态，当前状态高亮为蓝色。
3. **节点处理**：对每个节点，检查邻接节点颜色，合法转移时显示绿色箭头，更新邻接节点状态。
4. **统计结果**：每次路径有效（颜色数≥2）时，全局计数器增加，播放“金币”音效。

**复古效果**：  
- **像素画风**：节点为 16x16 像素块，状态二进制用 8-bit 字体显示。
- **音效设计**：转移时播放 FC 风格的“跳跃”音效，统计时播放“得分”音效。
- **自动演示**：按空格键切换手动/自动模式，自动模式下算法以 2 倍速执行。

---

**总结**：本题通过状态压缩 DP 高效统计路径，核心在于状态设计与处理顺序。可视化时通过像素动画和音效增强理解，适合教学与自测。

---
处理用时：80.51秒
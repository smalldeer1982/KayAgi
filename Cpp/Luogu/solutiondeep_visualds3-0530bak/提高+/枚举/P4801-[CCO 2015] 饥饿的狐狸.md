# 题目信息

# [CCO 2015] 饥饿的狐狸

## 题目描述

**本题译自 [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2015/index.html) Day1 T1「[Hungry Fox](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2015/stage%202/day1.pdf)」**

到你的宠物狐狸的晚餐时间啦！他的晚餐包含 $N$ 块饼干，第 $i$ 块饼干的温度是 $T_i$ 摄氏度。同时，在晚餐中还包含了一大盘 $W$ 摄氏度的水。

在喝了一口水之后，你的狐狸开始吃饭了。每当他吃一块饼干时，这块饼干的美味度为当前饼干与吃/喝的前一样食物（包括饼干和水）的温度的差的绝对值。它可以在任意时间喝水（保证水喝不完），或按任意顺序吃饼干。

最后狐狸获得的美味值为它吃下的每块饼干的美味度之和。请求出狐狸获得的最小和最大的美味值。

## 说明/提示

要得到最小美味值，一种可行的方案是，狐狸先喝水，然后吃第一块饼干，再吃第三块饼干，接着喝水，最后吃下第二块饼干，这样做，它所感受到的温度分别为 $20,18,18,20,25$ 摄氏度，总的美味度为 $2+0+5=7$。

要得到最大美味值，一种可行的方案是，狐狸先喝水，然后按顺序吃饼干，它所感受到的温度分别为 $20,18,25,18$ 摄氏度，总的美味度为 $2+7+7=16$。

对于 $30\%$ 及以上的数据， $W=0$；  

对于 $100\%$ 的数据， $1\le N \le 100000, 0\le W \le 10^9, 0 \le T _ i \le 10 ^ 9$。

## 样例 #1

### 输入

```
3 20
18
25
18```

### 输出

```
7 16```

# AI分析结果



## 算法分类
贪心

---

## 题解思路与算法要点

### 最小值推导
- **核心公式**：`min_val = max(0, w - a[1]) + max(0, a[n] - w)`
- **推导逻辑**：将饼干排序后，若水温在饼干温度范围外则需额外计算首/尾饼干与水的差值，否则直接取饼干温度极差。

### 最大值推导
- **双指针交替选择**：从左右两端交替选取饼干，每次比较「直接吃饼干」与「喝水后吃饼干」的差值。
- **两次遍历策略**：分别尝试「先吃最小饼干」和「先吃最大饼干」两种策略，取最大值。

---

## 题解评分（≥4星）

| 题解作者 | 评分 | 亮点分析 |
|---------|------|----------|
| 桃夭     | ★★★★☆ | 完整错误分析+数学公式推导，代码简洁 |
| greykid | ★★★★☆ | 公式推导清晰，代码高效易读 |
| MoonCake2011 | ★★★★☆ | 双指针实现优雅，注释详细 |

---

## 最优思路提炼

### 最小值优化公式
```cpp
min_val = max(0, w - a[1]) + max(0, a[n] - w)
```
**数学推导**：当水温在饼干温度范围内时，喝水可消除首尾外的所有中间差值，极差即为总美味值。

### 最大值双指针策略
```cpp
// 交替选择饼干并比较喝水差值
for (int i=1; i<=n; ++i) {
    if (i%2 == check) { // check表示方向
        sum += max(abs(a[l]-now), abs(a[l]-w));
        now = a[l++];
    } else {
        sum += max(abs(a[r]-now), abs(a[r]-w));
        now = a[r--];
    }
}
```

---

## 同类型题推荐
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)（时间差最小化）
3. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)（极差贪心）

---

## 可视化设计方案

### 核心算法演示
```javascript
// 伪代码示例：最大值计算过程可视化
class Visualization {
    constructor(data, w) {
        this.sorted = data.sort((a,b) => a-b);
        this.pointers = { left:0, right:data.length-1 };
        this.highlight = (pos) => { /* 高亮当前操作位置 */ };
    }

    nextStep() {
        // 交替移动左右指针并计算差值
        if (step%2 === 0) {
            const diff1 = Math.abs(left_val - prev);
            const diff2 = Math.abs(left_val - w);
            this.highlight('left');
        } else {
            // 类似处理右侧...
        }
    }
}
```

### 复古像素风格
- **颜色方案**：16色FC调色板，饼干用渐变红，水用蓝色像素块
- **动画效果**：
  - 饼干按温度排序后排列为像素柱状图
  - 狐狸角色左右移动吃饼干时播放「吃音效」
  - 喝水操作触发蓝色闪光特效

---

## 核心代码实现
```cpp
// 最小值计算
long long get_min(vector<int>& t, int w) {
    sort(t.begin(), t.end());
    return max(0, w - t.front()) + max(0, t.back() - w);
}

// 最大值计算（双指针交替）
long long calc_max(vector<int>& t, int w, bool left_first) {
    long long sum = 0;
    int l = 0, r = t.size()-1;
    long long prev = w;
    
    for (int i=0; i<t.size(); ++i) {
        bool use_left = (left_first ? (i%2==0) : (i%2==1));
        int val = use_left ? t[l++] : t[r--];
        sum += max(abs(val - prev), abs(val - w));
        prev = val;
    }
    return sum;
}
```

---

## 调试心得摘录
> "最初用暴力遍历导致WA，后来发现喝水可以消除中间差值，最终推导出O(1)公式" —— 桃夭  
> "交替选择时必须比较喝水后的差值，否则会漏掉最优解" —— greykid

---

## 总结
本题通过排序与数学分析实现高效贪心，可视化时可重点展示极差计算与双指针选择策略，配合复古像素动画增强理解。

---
处理用时：60.49秒
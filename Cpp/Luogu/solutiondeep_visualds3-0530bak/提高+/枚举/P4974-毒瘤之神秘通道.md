# 题目信息

# 毒瘤之神秘通道

## 题目背景

~~Viston就是一个小蒟蒻 By CYJian（自己YY出来的）~~         
Viston最喜欢冒险了。

## 题目描述

~~（假的算法标签）~~
Viston发现了一个巨大的城堡，他走了进去，城堡里有一个巨大的房间，Viston进去打算参观参观，然后.......他就被困在里面了。   Viston发现了在房间里有很多同样冒险者和一个个通道，冒险者们一个个冲向了不同的**通道**，而Viston一脸懵逼。    

Viston动用他莫大的蒟蒻之力摸清了这些**通道**是什么东东~~厉害吧~~，他们是一些单向**通道**，而这些**通道**会把你传送到另一些房间里，一个房间里有一个传送到另一个房间里的传送门。     

已知所有的房间最后都通向一个地方，那就是出口。但传送门把你传送到另一个房间也是需要时间的，这个时间取决于之前有多少人使用过这个传送门，计算公式是
$$T=M$$,其中$M$表示传送门的使用人数。 ~~（你前面发啥呆啊，其他人早走光了。）~~

Viston记得每个通道有多少人进入，也探测出了每个房间里的传送门通向哪里，他想知道他从哪个通道进入初始房间才能最快的到达出口，~~毕竟Viston还想着颓金拱门呢。~~

### 注意:只有使用传送门消耗时间,而通道（即到达初始房间）不消耗时间!!!

## 说明/提示

## 样例解释
（用的WindowsXP画图画的不好请见谅）               
![](https://i.loli.net/2018/10/05/5bb7632fb40f4.jpg)
 
对于1-5号测试点(10 pts): $1 \leq N, M \leq 50$

对于6-10号测试点(20 pts): $1 \leq N, M \leq 5000$

对于11-15号测试点(30 pts): $1 \leq N, M \leq 100000$

对于16-20号测试点(40 pts): $1 \leq N, M \leq 1000000$

对于5，10，15，20号测试点，给定的树为随机生成。

保证答案都在long long范围内..


$\color{white}\text{这样你才能看出来随机树强度有多低}$   

@[Viston](https://www.luogu.org/space/show?uid=107101)

$\color{white}\text{（还想卡树剖的）}$


## 样例 #1

### 输入

```
5 2
0
1
2
2
4
5 10
3 10
```

### 输出

```
3 50```

# AI分析结果



---

### 算法分类  
**拓扑排序**

---

### 题解思路与核心算法分析  

#### **核心问题转化**  
每个初始通道对应一条路径，路径上的每个传送门被使用次数+1。总时间=路径上所有传送门的使用次数之和。需要快速计算所有初始通道对应的总时间，并取最小值。

#### **关键算法流程**  
1. **拓扑排序自底向上累积边权**  
   - 将每个初始通道的边权视为基础贡献  
   - 从叶子节点开始向根节点（出口）方向传递贡献值  
   - 确保处理父节点时，所有子节点的贡献已计算完毕  

2. **DFS/二次拓扑计算总路径和**  
   - 构建树结构后，通过DFS或反向拓扑排序计算每个节点到根节点的路径和  

#### **解决难点对比**  
| 题解           | 数据结构            | 核心优化点                         | 时间复杂度 |  
|----------------|---------------------|----------------------------------|----------|  
| Viston（双拓扑） | 队列+双数组          | 两轮拓扑排序完成边权累积与路径和计算 | O(N+M)   |  
| D2T1（拓扑+DFS）| 队列+邻接表          | 分离拓扑与DFS阶段，逻辑更清晰       | O(N+M)   |  

---

### 题解评分（≥4星）  

1. **D2T1（★★★★★）**  
   - 清晰拆分拓扑排序与DFS阶段  
   - 使用邻接表存储树结构，代码可读性高  
   - 在样例数据中完美处理边权叠加问题  

2. **Viston（★★★★）**  
   - 双拓扑排序思路巧妙但代码较难理解  
   - 未显式构建树结构，变量命名不够直观  
   - 核心贡献传递逻辑与D2T1等效  

---

### 最优思路提炼  

#### **拓扑排序贡献传递**  
```cpp
// 拓扑排序核心代码片段（D2T1）
queue<int> q;
for(int i = 0; i <= m; ++i) if(!ind[i]) q.push(i);
while(!q.empty()) {
    int t = q.front(); q.pop();
    val[fa[t]] += val[t];  // 将当前节点贡献传递给父节点
    if(--ind[fa[t]] == 0) q.push(fa[t]);
}
```

#### **DFS路径和计算**  
```cpp
void dfs(int x) {
    for(int y : g[x]) {
        ans[y] = ans[x] + val[y];  // 累加路径和
        dfs(y);
    }
}
```

---

### 同类型题目推荐  
1. **P1113 杂务** - 拓扑排序处理任务依赖  
2. **P2014 选课** - 树形依赖关系中的动态规划  
3. **P1352 没有上司的舞会** - 树形结构自底向上计算  

---

### 可视化设计要点  

#### **动画演示方案**  
1. **拓扑排序阶段**  
   - **颜色标记**：叶子节点初始为绿色，处理时变为红色  
   - **数值显示**：节点上方实时显示当前累积的val值  
   - **连线动画**：贡献传递时显示金色粒子流向父节点  

2. **DFS阶段**  
   - **路径高亮**：从根节点到当前节点路径显示为蓝色渐变色  
   - **数值更新**：每个节点的ans值在访问时弹出数字特效  

#### **复古像素风格**  
- **8位调色板**：使用NES经典绿/红/蓝三色  
- **音效设计**：  
  - 节点处理完成：8-bit "哔"声（频率随val值变化）  
  - 找到最小值：马里奥吃到金币音效  

---

### 完整代码（D2T1版）  
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
long long val[N], ans[N], res = 0x7fffffffffffffff;
int n, m, fa[N], ind[N], ist[N], pos;
vector<int> g[N];

void dfs(int x){
    for(int y : g[x]) {
        ans[y] = ans[x] + val[y];
        dfs(y);
    }
}

int main(){
    scanf("%d%d", &m, &n);
    for(int i = 1; i <= m; ++i) scanf("%d", fa+i), ++ind[fa[i]];
    for(int i = 1, a, b; i <= n; ++i) {
        scanf("%d%d", &a, &b);
        ist[a] = 1, val[a] += b;
    }
    
    queue<int> q;
    for(int i = 0; i <= m; ++i) if(!ind[i]) q.push(i);
    while(!q.empty()) {
        int t = q.front(); q.pop();
        val[fa[t]] += val[t];
        if(--ind[fa[t]] == 0) q.push(fa[t]);
    }
    
    for(int i = 1; i <= m; ++i) g[fa[i]].push_back(i);
    dfs(0);
    
    for(int i = 0; i <= m; ++i) 
        if(ist[i] && ans[i] <= res) res = ans[i], pos = i;
    printf("%d %lld\n", pos, res);
    return 0;
}
```

---

### 核心思想总结  
**拓扑排序驱动贡献传递**是解决树形结构叠加问题的利器。通过自底向上的处理顺序，确保每个节点的所有下游贡献被完全捕获。配合DFS计算路径和，形成高效的两次扫描解决方案。该模式可推广至所有需要层级累积计算的树形问题。

---
处理用时：79.63秒
# 题目信息

# 中国象棋 - 摆上马

## 题目背景

~~相信自己的做法 大喊一声 I won't MLE！您就会过这道题~~

Imakf 玩腻了国际象棋，决定玩一玩中国象棋。

他发现中国象棋的马和国际象棋的马有所不同，他意识到这又可以出一道简单的问题，于是他又准备摆一摆马了

## 题目描述

Imakf 有一个 $X$ 行 $Y$ 列的棋盘，还有很多**完全相同**的马（你可以认为有无数个）。现在在棋盘上摆上马（或者不摆），求任何马无法攻击另一匹马的方案总数。

中国象棋的马和国际象棋的马不同。

![](https://cdn.luogu.com.cn/upload/pic/40761.png)

注意：实际问题中是没有兵的。

当然由于方案可能过多，请输出对 $(10^9+7)$ 取模的值


## 说明/提示

对于 100% 的数据，有 $1\le X\leq100$，$1\le Y\leq6$。

对于 20% 的数据，有 $X,Y\leq6$。

对于另外 20% 的数据，有 $X\leq20$。

对于样例 1，可以选择不摆或者摆。

对于样例 2，我有一个绝妙的解释可惜我写不下。


## 样例 #1

### 输入

```
1 1 
```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3 
```

### 输出

```
145```

# AI分析结果



## 算法分类
**状压DP**

---

## 题解思路与解决难点

### 核心思路
1. **状态设计**：`dp[i][j][k]` 表示第 `i` 行状态为 `j`，上一行状态为 `k` 的方案数，其中状态用二进制压缩表示。
2. **冲突判断**：
   - **两行冲突**：判断当前行与上一行的马是否互相攻击，需考虑中国象棋的“蹩马腿”规则。
   - **三行冲突**：判断当前行与上上行的马是否存在跨行攻击，需结合中间行的状态。
3. **滚动数组优化**：通过取模运算（如 `i % 3`）压缩空间，避免 MLE。

### 解决难点
- **位运算实现攻击范围判断**：通过左移/右移操作快速计算马的可攻击范围。
- **预处理合法性**：部分题解预处理所有可能的状态转移关系，减少重复计算。
- **高效状态转移**：仅枚举合法的前两行状态，避免暴力枚举所有可能。

---

## 题解评分（≥4星）

### 1. Imakf（5星）
- **亮点**：详细推导攻击范围的位运算逻辑，提供完整代码和可视化思路。
- **代码片段**：
  ```cpp
  int at_bt(int a) { // 计算下一行攻击范围
      int c = 0;
      for (int i = 1; bit(-1, i) <= a; ++i) {
          if (!check(a, i)) continue;
          if (!check(a, i+1)) c |= bit(-1, i+2);
          if (!check(a, i-1)) c |= bit(-1, i-2);
      }
      return c;
  }
  ```

### 2. hater（4星）
- **亮点**：简洁的位运算判断条件，代码可读性强。
- **代码片段**：
  ```cpp
  bool Ch1(int k1, int k2) {
      int T = ~(((k1>>1)&k1)>>1), K = (T&k2);
      return !((k1>>2) & K);
  }
  ```

### 3. Utilokasteinn（4星）
- **亮点**：直接枚举每个马的位置判断攻击，逻辑直观。
- **代码片段**：
  ```cpp
  bool check(int x, int y) {
      for (int i = 0; i < m; i++) {
          if ((x>>i & 1) && (y>>(i+2) & 1) && !(y>>(i+1) & 1)) return false;
      }
      return true;
  }
  ```

---

## 最优思路与技巧提炼
1. **状态压缩**：用二进制表示每行马的摆放状态。
2. **攻击范围预处理**：通过位运算快速计算某状态的攻击范围。
3. **滚动数组**：仅保留前两行状态，空间复杂度从 `O(X·2^Y·2^Y)` 优化为 `O(2^Y·2^Y)`。
4. **双向冲突检查**：同时检查当前行攻击上一行和上一行攻击当前行。

---

## 同类型题与算法套路
- **通用解法**：状压DP + 滚动数组 + 位运算预处理。
- **相似题目**：
  1. [P1896 互不侵犯](https://www.luogu.com.cn/problem/P1896)
  2. [P2704 炮兵阵地](https://www.luogu.com.cn/problem/P2704)
  3. [P2051 中国象棋](https://www.luogu.com.cn/problem/P2051)

---

## 可视化与算法演示设计
### 核心逻辑动画
1. **棋盘网格**：用Canvas绘制X×Y的网格，每个格子表示是否放马。
2. **状态高亮**：
   - **红色**：当前行状态。
   - **蓝色**：上一行状态。
   - **黄色**：攻击范围提示。
3. **步进控制**：单步演示状态转移，显示冲突检查过程。

### 复古像素风格
- **8位音效**：
  - `放置音效`：短促“滴”声。
  - `冲突提示`：低沉“嘟”声。
- **Canvas动画**：马的位置用8×8像素方块表示，攻击范围用闪烁边框标记。

```javascript
// 伪代码：音效触发
function playSound(type) {
  if (type === 'place') beep(440, 50);  // 放置音效
  if (type === 'conflict') beep(220, 100); // 冲突音效
}
```

---

## 推荐题目
1. [P5005 中国象棋 - 摆上马](https://www.luogu.com.cn/problem/P5005)
2. [P8756 国际象棋](https://www.luogu.com.cn/problem/P8756)
3. [P2704 炮兵阵地](https://www.luogu.com.cn/problem/P2704)

---

## 个人心得摘录
> **hater**：  
> “判断合法性时，先画图分析马的攻击路径，再转化为位运算条件，调试时输出二进制状态帮助极大。”

> **pyqpyq**：  
> “滚动数组不仅节省空间，还能让代码结构更清晰，关键是及时清空无用状态。”

---

## 核心代码实现
```cpp
// 滚动数组版（Imakf思路）
int dp[3][1<<6][1<<6] = {0};
for (int i = 3; i <= X; i++) {
    memset(dp[i%3], 0, sizeof(dp[i%3]));
    for (int j : 所有状态) {
        for (int k : 所有状态) {
            if (!check(j, k)) continue;
            for (int l : 所有状态) {
                if (check(k, l) && check(j, k, l)) {
                    dp[i%3][j][k] += dp[(i-1)%3][k][l];
                    dp[i%3][j][k] %= MOD;
                }
            }
        }
    }
}
```

---
处理用时：72.93秒
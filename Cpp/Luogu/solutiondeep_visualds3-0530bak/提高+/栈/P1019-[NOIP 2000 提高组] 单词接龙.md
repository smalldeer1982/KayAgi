# 题目信息

# [NOIP 2000 提高组] 单词接龙

## 题目背景

注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)

NOIP2000 提高组 T3

## 题目描述

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。


## 说明/提示

样例解释：连成的“龙”为 `atoucheatactactouchoose`。

$n \le 20$。

## 样例 #1

### 输入

```
5
at
touch
cheat
choose
tact
a
```

### 输出

```
23
```

# AI分析结果



# 分析与结论

## 算法分类
深度优先搜索（DFS）

---

## 题解思路与核心难点
### 核心思路
所有题解均采用 **DFS+回溯** 框架：
1. **起点选择**：以给定字符开头的单词作为初始龙
2. **状态转移**：尝试将未被使用满2次的单词连接到当前龙末尾
3. **剪枝优化**：仅尝试有效重叠（非包含关系且最小重叠长度）

### 解决难点
1. **重叠检测**：
   - 动态检测（RyanLi）：每次递归用 `substr` 截取字符串比较
   - 预处理矩阵（yedalong）：提前计算所有单词对的最小重叠长度
2. **状态维护**：
   - `vis[]` 数组记录单词使用次数
   - 传递当前龙的尾部单词，而非完整字符串（避免重复处理）

---

## 题解评分 (≥4★)
1. **RyanLi（4★）**
   - **亮点**：代码简洁，直接动态计算重叠长度
   - **优化点**：`tmp.substr(tmp.size()-j)` 快速截取尾部
2. **yedalong（4★）**
   - **亮点**：预处理重叠矩阵，减少重复计算
   - **特色**：使用 `g[i][j]` 存储预处理结果，加速搜索
3. **SuyctidohanQ（4★）**
   - **亮点**：`check` 函数显式返回重叠长度，逻辑清晰
   - **特色**：代码模块化程度高，易维护

---

## 最优思路提炼
1. **预处理优化**  
   预计算所有单词对的最小重叠长度（如yedalong的`g[][]`矩阵），将DFS中O(L)的字符串比较转为O(1)查表。
   
2. **尾部传递技巧**  
   仅传递当前最后一个单词而非完整龙字符串（如__yiLIUyi__的解法），避免重复处理长字符串。

3. **剪枝策略**  
   - **包含关系检测**：要求重叠长度 `< min(len1, len2)`
   - **字典序优化**：按单词长度降序搜索（未在题解体现，但可拓展）

---

## 同类型题目
1. **P1032 字串变换**（BFS+字符串操作）
2. **P1120 小木棍**（DFS+强力剪枝）
3. **P1242 新汉诺塔**（状态空间搜索）

---

## 可视化设计
### 动画方案
1. **网格显示**  
   - 左侧：显示当前龙字符串（红色标记新增部分）
   - 右侧：单词列表（灰色表示已用尽次数）

2. **高亮逻辑**  
   ![动画示意图](https://i.imgur.com/8W7lKvZ.gif)  
   - **绿色边框**：当前尝试连接的单词
   - **黄色块**：重叠部分（如`cheat`与`tact`的`t`重叠）

3. **复古像素风格**  
   - **调色板**：16色FC风格（红/绿/蓝三原色）
   - **音效设计**：
     - 连接成功：短促"哔"声（Web Audio模拟FC音效）
     - 回溯：低沉"嗡"声
   - **Canvas动画**：用8x8像素块拼写单词，每步连接产生光晕特效

---

## 代码实现（核心逻辑）
### yedalong的预处理+DFS
```cpp
// 预处理重叠矩阵
for(int i=1; i<=n; i++){
    for(int j=1; j<=n; j++){
        for(int k=1; k<min(a[i].size(),a[j].size()); k++){
            if(a[i].substr(a[i].size()-k) == a[j].substr(0,k)){
                g[i][j] = k;
                break;
            }
        }
    }
}

// DFS核心
void dfs(string s, int k){
    maxx = max(maxx, (int)s.size());
    pd[k]++;
    for(int i=1; i<=n; i++){
        if(g[k][i] && pd[i]<2){
            dfs(s + a[i].substr(g[k][i]), i); // 传递新尾部
        }
    }
    pd[k]--;
}
```

---

## 个人心得摘录
- **__yiLIUyi__**：  
  "必须传递最后添加的单词而非整个龙字符串，否则无法正确检测包含关系。调试2小时才领悟！"

- **kungeruyi**：  
  "发现从大往小枚举重叠长度会WA，必须从小到大枚举才能找到最小重叠（让龙更长）"

---

## 推荐练习题
1. **P1036 选数**（组合型DFS）
2. **P1433 吃奶酪**（状压DP+DFS）
3. **P1092 虫食算**（DFS+剪枝优化）

---
处理用时：63.61秒
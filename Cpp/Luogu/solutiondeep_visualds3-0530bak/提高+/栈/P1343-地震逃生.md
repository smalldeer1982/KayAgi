# 题目信息

# 地震逃生

## 题目描述

汶川地震发生时，四川\*\*中学正在上课，一看地震发生，老师们立刻带领 $x$ 名学生逃跑，整个学校可以抽象地看成一个有向图，图中有 $n$ 个点，$m$ 条边。$1$ 号点为教室，$n$ 号点为安全地带，每条边都只能容纳一定量的学生，超过楼就要倒塌，由于人数太多，校长决定让同学们分成几批逃生，只有第一批学生全部逃生完毕后，第二批学生才能从 $1$ 号点出发逃生，现在请你帮校长算算，每批最多能运出多少个学生，$x$ 名学生分几批才能运完。

## 说明/提示

**【注释】**

比如有图

```plain
1 2 100
2 3 1
```

$100$ 个学生先冲到 $2$ 号点，然后一个一个慢慢沿 $2 \to 3$ 边走过去。

18 神牛规定这样是不可以的……

也就是说，每批学生必须同时从起点出发，并且同时到达终点。

**【数据范围】**

对于 $100 \%$ 的数据，$0 \le x < 2^{31}$，$1 \le n \le 200$，$1 \le m \le 2000$。

## 样例 #1

### 输入

```
6 7 7
1 2 1
1 4 2
2 3 1
4 5 1
4 3 1
3 6 2
5 6 1
```

### 输出

```
3 3
```

# AI分析结果



# 地震逃生题解分析与可视化设计

## 唯一算法分类
**网络流-最大流**

---

## 综合分析与结论

### 核心算法流程
- **最大流模型**：将教室视为源点（1号），安全点视为汇点（n号），边容量为允许通过的学生数。最大流即每批最多人数。
- **分层与增广**：Dinic算法通过BFS构建层次网络，DFS多路增广。关键变量`dis[]`记录层次，`cur[]`优化遍历顺序。
- **批次数计算**：总人数除以最大流向上取整，公式为`(x + ans -1)/ans`。

### 解决难点
- **反向边处理**：反向边初始容量为0，增广时反向边增加流量（如代码中`e[i^1].w += tmp`）。
- **分层剪枝**：通过`d[v] = d[u]+1`确保路径最短，避免无效搜索。

### 可视化设计
1. **层次网络动画**：
   - **BFS阶段**：用绿色高亮当前队列节点，蓝色标记已访问节点，动态显示`dis[]`数值。
   - **DFS增广**：红色路径显示当前增广路线，黄色标记流量调整的边。
2. **容量更新效果**：
   - 正向边减少流量时显示“-数值”动画，反向边增加时显示“+数值”。
3. **复古像素风格**：
   - 节点用8x8像素方块表示，边用低分辨率线段，增广时播放FC风格音效（如《超级马里奥》金币声）。
4. **自动演示模式**：
   - 按空格键切换自动/手动，自动模式下算法以2秒/步执行，配合8-bit背景音乐。

---

## 题解清单（评分≥4星）

1. **作者：hncsyjc（5星）**
   - **亮点**：代码简洁，Dinic标准实现，反向边处理清晰。
   - **关键代码**：
     ```cpp
     while(bfs()) while(tmp=dfs(1,1e9)) ans += tmp; // Dinic核心循环
     ```

2. **作者：lgswdn_SA（4星）**
   - **亮点**：详细注释，处理了最大流为0的特判。
   - **心得**：“注意反向边的容量初始化为0，否则无法正确增广”。

3. **作者：_Fontainebleau_（4星）**
   - **亮点**：提供ISAP实现，适合进阶学习，代码含复古注释风格。
   - **代码片段**：
     ```cpp
     --gap[dep[u]]; if(!gap[dep[u]]) break; // 断层优化
     ```

---

## 关键代码实现（Dinic）

```cpp
bool bfs() {
    queue<int> q; memset(d, 0, sizeof(d));
    q.push(1); d[1] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = hd[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (!d[v] && e[i].w) {
                d[v] = d[u] + 1;
                if (v == n) return true;
                q.push(v);
            }
        }
    }
    return false;
}

int dfs(int u, int flow) {
    if (u == n) return flow;
    int rest = flow;
    for (int &i = cur[u]; i; i = e[i].nxt) { // 当前弧优化
        int v = e[i].to;
        if (d[v] == d[u] + 1 && e[i].w) {
            int k = dfs(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            rest -= k; e[i].w -= k; e[i^1].w += k;
        }
    }
    return flow - rest;
}

int dinic() {
    int maxflow = 0, flow;
    while (bfs()) {
        memcpy(cur, hd, sizeof(hd)); // 重置当前弧
        while ((flow = dfs(1, 1e9))) maxflow += flow;
    }
    return maxflow;
}
```

---

## 同类型题目推荐
1. **P3376** - 网络最大流（模板题）
2. **P2756** - 飞行员配对方案（二分图匹配转最大流）
3. **P1231** - 教辅的分配（多源汇问题）

---

## 可视化代码片段（Canvas绘制边）

```javascript
function drawEdge(u, v, cap, flow) {
    ctx.beginPath();
    ctx.moveTo(nodes[u].x, nodes[u].y);
    ctx.lineTo(nodes[v].x, nodes[v].y);
    ctx.strokeStyle = flow > 0 ? '#FF5555' : '#5555FF'; // 红色正向，蓝色反向
    ctx.lineWidth = Math.sqrt(cap) / 2;
    ctx.stroke();
}
```

---

## 个人心得摘录
- **反向边初始化**：“tot从1开始，i^1取反向边的技巧避免单独存储”（题解1）。
- **分层重要性**：“BFS分层后，只能在同层或下一层增广，极大减少无效路径”（题解2）。
- **向上取整技巧**：“用(x + ans -1)/ans代替ceil，避免浮点运算”（题解4）。

---
处理用时：63.06秒
# 题目信息

# yyy loves Maths VII

## 题目背景

yyy 对某些数字有着情有独钟的喜爱，他叫他们为“幸运数字”；然而他作死太多，所以把自己讨厌的数字称为“厄运数字”。

## 题目描述

一群同学在和 yyy 玩一个游戏。

每次,他们会给 yyy $n$ 张卡片，卡片上有数字，所有的数字都是“幸运数字”，我们认为第 $i$ 张卡片上数字是 $a_{i}$。

每次 yyy 可以选择向前走 $a_{i}$ 步并且丢掉第 $i$ 张卡片。当他手上没有卡片的时候他就赢了。

但是呢，大家对“厄运数字”的位置布置下了陷阱，如果 yyy 停在这个格子上，那么他就输了。注意：**即使到了终点，但是这个位置是厄运数字，那么也输了。**

现在，有些同学开始问：yyy 有多大的概率会赢呢？

大家觉得这是个好问题，有人立即让 yyy 写个程序：“电脑运行速度很快！$24$ 的阶乘也不过就 $620\,448\,401\,733\,239\,439\,360\,000$，yyy 你快写个程序来算一算。”

yyy 表示很无语，他表示他不想算概率，最多算算赢的方案数，而且是对 $10^9+7$ 取模后的值。

大家都不会写程序，只好妥协。

但是这时候 yyy 为难了，$24!$ 太大了，要跑好长时间。

他时间严重不够！需要你的帮助！

某个数字可能既属于幸运数字又属于厄运数字。

## 说明/提示

- $10\%$ 的数据 $n \leq 10$；
- $50\%$ 的数据 $n \leq 23$；
- $100\%$ 的数据 $n \leq 24$，$0\le m\le 2$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
8
1 3 1 5 2 2 2 3
0```

### 输出

```
40320```

## 样例 #2

### 输入

```
24
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2
10 15
```

### 输出

```
0```

# AI分析结果



## 算法分类
**状态压缩动态规划**

---

## 题解思路与算法要点

### 核心思路
1. **状态压缩**：用二进制数表示已使用的卡片集合，状态 `i` 的每一位表示是否使用对应卡片。
2. **预处理距离**：通过 `dis[i]` 计算集合 `i` 的卡片总步数，利用 `lowbit` 快速递推。
3. **动态规划转移**：状态 `i` 的合法方案数 `f[i]` 由所有去掉一个卡片的子状态 `i ^ (1 << j)` 累加而来。
4. **厄运检测**：若 `dis[i]` 是厄运数字，直接跳过该状态的转移。

### 解决难点
- **高效枚举状态**：通过 `lowbit` 快速遍历所有可能的子状态，将时间复杂度从 `O(n·2ⁿ)` 优化至 `O(2ⁿ log n)`。
- **避免重复计算**：预处理 `dis[i]` 确保每个状态的距离仅计算一次。
- **卡常优化**：使用位运算、减法代替取模、循环变量优化等技巧提升代码效率。

---

## 题解评分 (≥4星)
1. **Siyuan（5星）**  
   - 思路清晰，代码简洁，使用 `lowbit` 优化转移。  
   - 预处理 `dis` 和 `f` 的递推逻辑明确，适合快速理解核心算法。

2. **RabbitHu（4星）**  
   - 强调 `lowbit` 分解状态，代码中手动优化循环，适合比赛环境。  
   - 通过 `k = i & -i` 和 `k ^= j` 高效遍历所有子状态。

3. **Alex_Wei（4星）**  
   - 提出容斥和 MITM 优化思路，拓展了算法可能性。  
   - 结合数学推导处理厄运数字，适合高阶选手深入理解。

---

## 最优思路提炼
- **lowbit 优化转移**：遍历每个状态的 1 的位时，用 `lowbit` 快速分解当前状态，避免枚举所有位。
- **预处理距离**：递推计算 `dis[i] = dis[i ^ lowbit(i)] + dis[lowbit(i)]`。
- **厄运状态剪枝**：在转移前直接跳过非法状态，减少无效计算。

---

## 同类型题与算法套路
- **状压 DP 的通用模式**：适用于元素选择顺序无关但需记录选择集合的问题（如 TSP、子集和）。
- **lowbit 优化**：在需要枚举子集或位操作时，显著减少循环次数。
- **容斥与 MITM**：处理复杂限制时，结合数学方法降低复杂度。

---

## 推荐题目
1. **洛谷 P1171（售货员的难题）** - 状压 DP 经典旅行商问题。
2. **洛谷 P3959（宝藏）** - 状压 DP 结合生成树优化。
3. **CF327E（Axis Walking）** - 双倍经验题，直接套用本题算法。

---

## 核心代码实现
```cpp
#include <cstdio>
const int N = 24, mod = 1e9 + 7;
int n, m, b[2], dis[1 << N], f[1 << N];

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) scanf("%d", &dis[1 << i]);
    scanf("%d", &m);
    if (m > 0) scanf("%d", &b[0]);
    if (m > 1) scanf("%d", &b[1]);
    f[0] = 1;
    int msk = (1 << n) - 1;
    for (int i = 1; i <= msk; ++i) {
        int j = i & -i;
        dis[i] = dis[i ^ j] + dis[j];
        if (dis[i] == b[0] || dis[i] == b[1]) continue;
        for (int k = i; k; k ^= (k & -k)) {
            f[i] = (f[i] + f[i ^ (k & -k)]) % mod;
        }
    }
    printf("%d\n", f[msk]);
    return 0;
}
```

---

## 可视化与算法演示
### 动画设计
1. **网格化状态展示**：  
   - 用 24x24 的网格表示所有卡片，选中卡片时点亮对应位置。
   - **当前状态**：高亮二进制表示的已选卡片（如 `0011` 表示前两张已用）。
   - **总步数显示**：实时更新 `dis[i]` 的数值，若为厄运数字则标红。

2. **转移过程动画**：  
   - **步进操作**：单步执行状态转移，显示从 `i ^ (1 << j)` 到 `i` 的转移路径。
   - **lowbit 分解**：用闪烁效果显示每次 `lowbit` 提取的卡片位置。

3. **复古像素风格**：  
   - **8-bit 音效**：状态合法时播放“升级”音效，非法时播放“错误”音效。
   - **自动演示模式**：模拟 AI 逐步选择卡片，动态显示 `dis` 和 `f` 的变化。

### 交互功能
- **速度调节**：滑动条控制动画速度（0.5x~5x）。
- **单步/连续模式**：自由切换以观察细节。
- **厄运标记**：点击网格标记自定义厄运位置，实时重新计算方案数。

---

## 个人心得摘录
> "不开 O2 过不了还是有点离谱的。优化循环变量和位运算是关键。" —— peterwuyihong  
> **总结**：算法优化需结合代码细节，尤其在卡常环境下，位运算和循环优化能显著提升性能。

---
处理用时：85.41秒
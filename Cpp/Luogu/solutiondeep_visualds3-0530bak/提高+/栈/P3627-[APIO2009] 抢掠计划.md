# 题目信息

# [APIO2009] 抢掠计划

## 题目描述

Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定，在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。  

Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。  

使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。 例如，假设该城中有 $6$ 个路口，道路的连接情况如下图所示：  

![](https://cdn.luogu.com.cn/upload/pic/4396.png)  

市中心在路口 $1$，由一个入口符号 → 来标识，那些有酒吧的路口用双圈来表示。每个 ATM 机中可取的钱数标在了路口的上方。在这个例子中，Banditji 能抢劫的现金总数为 $47$，实施的抢劫路线是：$1-2-4-1-2-3-5$。

## 说明/提示

对于 $50\%$ 的数据，保证 $N, M \le 3000$。  

对于 $100\%$ 的数据，保证 $N, M \le 5\times 10^5$，$0 \le a_i \le 4000$。保证可以从市中心沿着 Siruseri 的单向的道路到达其中的至少一个酒吧。

## 样例 #1

### 输入

```
6 7 
1 2 
2 3 
3 5 
2 4 
4 1 
2 6 
6 5 
10 
12 
8 
16 
1 
5 
1 4 
4 3 5 6```

### 输出

```
47```

# AI分析结果



### 【唯一算法分类】  
Tarjan缩点+最长路（SPFA/拓扑排序）

---

### 【综合分析与结论】  
**核心思路**  
1. **Tarjan缩点**：将强连通分量(SCC)合并为超级节点，其权值为内部ATM总和。  
2. **建新图**：保留跨SCC的边，形成DAG。  
3. **最长路径求解**：以起点所在SCC为源点，SPFA或拓扑排序计算最大权值和，终点必须为含酒吧的SCC。

**难点与解决方案**  
- **缩点正确性**：Tarjan需正确处理栈回溯与low值更新。  
- **边权处理**：新边权为目标SCC的权值，需避免重复累加。  
- **终点判定**：仅含酒吧的SCC可参与最终答案比较。

**可视化设计思路**  
1. **Tarjan过程动画**：  
   - 用不同颜色标记未访问、正在访问、已访问节点。  
   - 动态绘制栈内元素，展示low/dfn值更新。  
   - 缩点时高亮当前SCC节点，合并为超级节点。  
2. **最长路演示**：  
   - DAG中节点大小表示权值，酒吧节点标红。  
   - SPFA队列动态展示，箭头指示松弛操作。  
   - 拓扑排序时按序点亮节点，显示DP值更新。  

**复古像素化风格示例**  
- **Canvas绘制**：SCC为8位色块，边为像素线条，权值以复古字体显示。  
- **音效**：节点合并时播放“收集金币”音效，松弛成功时触发“升级”音调。  
- **自动演示**：逐步执行Tarjan缩点，AI自动播放最长路计算过程。

---

### 【题解清单 (≥4星)】  
1. **Lucaster_ (4星)**  
   - **亮点**：详细注释缩点与SPFA实现，代码结构清晰。  
   - **核心代码**：Tarjan回溯时累加SCC权值，SPFA初始化起点权值。  
   ```cpp
   void Tarjan(int x) {
       // ... 回溯时累加sum[tot]
       if (dfn[x] == low[x]) {
           tot++;
           do {
               sum[tot] += w[tp]; // 累加权值
           } while (stk[top--] != x);
       }
   }
   ```

2. **javalyc (4星)**  
   - **亮点**：拓扑排序DP避免负权边问题，代码高效。  
   - **关键逻辑**：按拓扑序更新`f[v] = max(f[v], f[u]+sval[v])`。  
   ```cpp
   void DP() {
       q.push(be[sta]); 
       f[be[sta]] = sval[be[sta]];
       while (!q.empty()) {
           int u = q.front(); q.pop();
           for (auto v : sccG[u]) {
               if (f[v] < f[u] + sval[v]) 
                   f[v] = f[u] + sval[v];
           }
       }
   }
   ```

3. **Drinkkk (4星)**  
   - **亮点**：拆分点权为边权，代码简洁。  
   - **技巧**：超级源点连接起点，终点连汇点简化处理。  

---

### 【最优思路/技巧提炼】  
1. **缩点权值处理**：SCC权值在Tarjan回溯时累加，避免重复计算。  
2. **终点判定优化**：预处理SCC是否含酒吧，避免每次遍历检查。  
3. **边权转换**：新图边权为目标SCC权值，SPFA松弛时直接累加。  

---

### 【相似题目推荐】  
1. **P3387 【模板】缩点**  
   - 同样需Tarjan缩点后求最长路。  
2. **P2002 消息扩散**  
   - 缩点后统计入度为0的SCC数量。  
3. **P2656 采蘑菇**  
   - SCC缩点结合边权恢复系数，SPFA求最长路。  

---

### 【可视化核心代码示例】  
**JavaScript伪代码 - Tarjan动画**  
```javascript
function drawTarjanStep(node, stack, low, dfn) {
    ctx.fillStyle = '#8B0000'; // 当前节点红色
    drawNode(node);
    stack.forEach((n, i) => {
        ctx.fillStyle = i === stack.length-1 ? '#FFD700' : '#FFFFFF'; // 栈顶金色
        drawNode(n);
    });
    // 显示low/dfn值
    text(`${node}: low=${low[node]}, dfn=${dfn[node]}`, x, y);
}
```

---

### 【个人心得摘录】  
> “Tarjan首字母大写避免冲突”——调试中发现函数名冲突导致错误，改为`Tarjan`后解决。  
> “拓扑排序需处理入度，否则漏节点”——初始未重置入度数组，导致DP结果错误。  

---

### 【算法演示 - 关键步骤】  
1. **Tarjan缩点流程**  
   - **Step 1**：DFS访问节点1，标记dfn[1]=1，low[1]=1，入栈。  
   - **Step 2**：发现边1→2，递归访问2，dfn[2]=2，low[2]=2。  
   - **Step 3**：回溯时发现low[2]=dfn[2]，弹出栈形成SCC2。  
   - **Step 4**：继续访问1→4，形成环，合并为SCC1。  

2. **SPFA最长路**  
   - **初始**：队列含起点SCC，dis=权值。  
   - **松弛**：遍历相邻SCC，累加权值并更新dis。  
   - **终止**：所有酒吧SCC的dis最大值即为答案。  

**复古像素效果**：每个SCC显示为16x16像素块，权值以绿色像素数字显示，SPFA队列用流动箭头表示。

---
处理用时：87.35秒
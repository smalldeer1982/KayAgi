# 题目信息

# [USACO17OPEN] Modern Art 2 G

## 题目描述

伟大的牛艺术家 Picowso 对标准的二维艺术作品感到厌倦（同时也对其他人抄袭她的作品感到沮丧），于是决定转向一种更极简主义的一维风格。

尽管她的画作现在可以用一个长度为 $N$（$1 \leq N \leq 100,000$）的一维颜色数组来描述，但她的绘画风格保持不变：她从一个空白画布开始，并在其上叠加一系列“矩形”颜料，而在这种一维情况下，这些矩形仅仅是区间。她使用每种颜色 $1 \ldots N$ 恰好一次，尽管和以前一样，某些颜色最终可能会被完全覆盖。

令 Picowso 非常沮丧的是，她的竞争对手 Moonet 似乎已经找到了如何复制这些一维画作的方法，使用的策略与之前的问题类似：Moonet 会绘制一组不相交的区间，等待它们干燥，然后再绘制另一组不相交的区间，依此类推。在整个过程中，Moonet 只能为每种颜色绘制最多一个区间。请计算 Moonet 复制给定的一维 Picowso 画作所需的最少轮数。

## 说明/提示

在这个例子中，颜色 1 的区间必须在颜色 4 和 5 的区间之前绘制，因此至少需要两轮。

## 样例 #1

### 输入

```
7
0
1
4
5
1
3
3```

### 输出

```
2```

# AI分析结果



## 算法分类
**栈的应用**

---

## 题解思路与算法要点
### 核心逻辑
1. **区间嵌套关系判定**  
   - 每种颜色必须涂在其首次出现位置（左端点）至最后一次出现位置（右端点）的区间内。  
   - 合法的颜色区间必须满足完全嵌套或完全独立，否则无法通过单次不相交涂色完成。

2. **栈维护嵌套层数**  
   - 遍历数组时，遇到颜色的左端点时入栈，右端点时出栈。  
   - 栈顶元素始终表示当前活跃的最内层颜色，栈的最大深度即为所需的最少轮数（需处理特殊边界）。

3. **非法情况判定**  
   - 若当前遍历位置的颜色与栈顶颜色不一致，说明存在交叉区间，直接返回 `-1`。

### 关键实现
- **预处理每个颜色的左右端点**：记录每个颜色首次和最后一次出现的位置。
- **遍历时栈操作**：维护活跃颜色栈，统计最大深度。
- **边界处理**：将 `0` 视为特殊颜色，其右端点设为 `n+1` 以避免干扰。

---

## 题解评分（≥4星）
1. **作者：qiianr**（⭐️⭐️⭐️⭐️⭐️）  
   - **亮点**：代码简洁，直接通过遍历栈的深度变化计算答案，边界处理清晰（`0` 的特殊处理）。  
   - **代码片段**：  
     ```cpp
     for(int i=0,x;i<=n+1;++i){
         x=a[i];
         if(i==s[x]) stack[++top]=x, ans=max(ans,top);
         if(x!=stack[top]){printf("-1");return 0;}
         if(i==e[x]) top--;
     }
     printf("%d",ans-1);
     ```

2. **作者：LEle0309**（⭐️⭐️⭐️⭐️）  
   - **亮点**：详细解释栈的运作逻辑，补充了图例缺失后的文字说明。  
   - **代码片段**：  
     ```cpp
     for(i=0;i<=n;i++){
         int x=a[i];
         if(i==st[x]) sta[++tp]=x, ans=max(ans,tp);
         if(x!=sta[tp]){cout<<-1; return 0;}
         if(i==ed[x])tp--;
     }
     ```

3. **作者：sel_fish**（⭐️⭐️⭐️⭐️）  
   - **亮点**：强调栈的“包含关系”逻辑，优化代码可读性。  
   - **代码片段**：  
     ```cpp
     for(re i=0;i<=n+1;i++){
         int x=a[i];
         if(i==st[x]) stack[++top]=x, ans=max(ans,top);
         if(x!=stack[top]){printf("-1"); return 0;}
         if(i==ed[x]) top--;
     }
     ```

---

## 最优思路提炼
1. **栈的深度即轮数**  
   - 每次涂色相当于进入一个新的嵌套层，栈的深度即为需要的最少轮数。
2. **颜色区间合法性检查**  
   - 遍历过程中实时校验栈顶颜色与当前颜色的一致性，确保无交叉区间。
3. **特殊值 `0` 处理**  
   - 将空白区域 `0` 视为一种颜色并扩展其右端点，简化边界条件判断。

---

## 类似算法套路
- **括号匹配问题**：通过栈判断括号嵌套合法性。
- **区间调度问题**：贪心选择不重叠区间。
- **分层遍历问题**：如树的层序遍历，深度对应分层结果。

---

## 推荐题目
1. **P1886 滑动窗口**（单调队列维护区间极值）  
2. **P1044 括号匹配**（栈的嵌套合法性检查）  
3. **P1090 合并果子**（贪心与堆的优化）

---

## 可视化算法演示
### 动画设计
1. **画布与栈动态展示**  
   - **左侧**：显示当前遍历位置及颜色序列，高亮当前处理元素。  
   - **右侧**：动态栈结构，入栈时颜色块上升，出栈时下降，标注当前深度。

2. **关键步骤高亮**  
   - **起始点**：绿色闪烁提示入栈操作。  
   - **结束点**：红色闪烁提示出栈操作。  
   - **非法交叉**：红色边框警示并终止动画。

3. **复古像素风格**  
   - **8位色块**：栈用不同颜色像素块表示，背景网格模拟一维画布。  
   - **音效设计**：  
     - 入栈/出栈：8-bit "哔"声。  
     - 错误提示：短促低音。

### 交互功能
- **步进控制**：支持暂停/继续/单步执行。  
- **速度调节**：滑动条控制动画速度（0.5x~3x）。  
- **自动演示**：AI自动遍历，模拟解题流程。

---

## 代码实现（核心逻辑）
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn = 1e5 + 5;
int n, a[maxn], s[maxn], e[maxn], stack[maxn], top, ans;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &a[i]);
        if (!s[a[i]]) s[a[i]] = i;
        e[a[i]] = i;
    }
    e[0] = n + 1; a[0] = 0;
    for (int i = 0; i <= n + 1; ++i) {
        int x = a[i];
        if (i == s[x]) stack[++top] = x, ans = max(ans, top);
        if (x != stack[top]) { printf("-1"); return 0; }
        if (i == e[x]) --top;
    }
    printf("%d", ans - 1);
    return 0;
}
```

---

## 个人心得
- **调试经验**：初始未处理 `0` 导致栈异常，需明确所有颜色（包括空白）的左右端点。  
- **思维陷阱**：误以为颜色层数直接等于答案，忽略 `0` 的干扰，最终通过 `ans-1` 修正。

---
处理用时：94.25秒
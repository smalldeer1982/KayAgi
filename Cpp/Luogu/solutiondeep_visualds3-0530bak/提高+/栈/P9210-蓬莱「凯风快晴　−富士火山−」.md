# 题目信息

# 蓬莱「凯风快晴　−富士火山−」

## 题目背景

富士山，被当地人称为「神山」。这是一座休眠火山，最近一次喷发在 $300$ 年前。

向这样的山中投入不死之药，想必会直接喷发吧。如此便理解为什么月岩笠最终抗命。

## 题目描述

所谓的山，是一种上细下粗的结构。能不能在「树」里也找到这样的结构呢？

给定一个以 $1$ 为根的大小为 $n$ 的有根树 $T$。你需要找到满足宽度单调不减的**导出子树**中最大的一棵：

- 记该导出子树为 $T_0$，共有 $k$ 层。
- 记 $T_0$ 的根节点的深度为 $1$，计算出 $T_0$ 中每个结点的深度 $d_i$。由此定义 $T_0$ 第 $i$ 层的宽度 $w_i$ 为「所有深度为 $i$ 的节点的个数」。
- 你需要使得 $w_i$ 单调不减。即，$w_1\le w_2\le \cdots \le w_k$。

记原树的点集和边集分别为 $V,E$。导出子树是原树的一个**连通块**，它的点集 $V_0\subseteq V$，边集 $E_0$ 是 $E$ 当中所有端点均在 $V_0$ 内的边。导出子树的根，是组成它的所有节点中**在原树内深度最浅的那一个**。$T$ 也可以被认为是自身的一棵导出子树。

![](https://cdn.luogu.com.cn/upload/image_hosting/wcbeo1a0.png)

如图所示，绿色的区域和橙色的区域分别是原树的导出子树。它们的根分别为 $2$ 和 $13$。

**注意**：导出子树的定义略微不同于子树的定义。请不要将两者混淆。

请找到最大的符合条件的导出子树的大小。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/pzq47a3e.png)

如图所示，标灰的节点是两个样例中选出来的导出子树。

- 样例 $1$ 找到的导出子树，每一层的宽度分别为 $\{1,2,3,3\}$。
- 样例 $2$ 找到的导出子树，每一层的宽度分别为 $\{1,2,4,4,5\}$。
### 数据范围及约定

对于全部数据，$1\le n\le 5\times 10^5$。

## 样例 #1

### 输入

```
10
1 2
2 3
3 4
3 5
2 6
6 7
1 8
8 9
8 10```

### 输出

```
9```

## 样例 #2

### 输入

```
17
1 2
2 3
3 4
4 5
4 6
3 7
7 8
7 9
7 10
2 11
2 12
1 13
13 14
14 15
14 16
13 17```

### 输出

```
16```

# AI分析结果



## 唯一算法分类
单调栈优化

---

## 题解思路与算法要点

### 核心思路
所有题解均基于以下关键观察：
1. **最优解必包含根节点**：若导出子树根不是根节点，可以向上扩展父节点获得更优解
2. **宽度单调性处理**：每层节点数预处理后，维护一个单调递增的序列
3. **栈式动态规划**：用单调栈记录历史层的节点数下限，动态计算最大可能值

### 解决难点
1. **高效维护单调性**：通过单调栈快速找到第一个比当前层节点数小的历史层
2. **贡献计算**：将连续多个高节点数层的贡献调整为当前层节点数，避免重复遍历
3. **线性时间复杂度**：通过栈操作保证每个元素最多入栈出栈一次

### 算法流程
```python
预处理每层节点数w[]
初始化空栈和累计值sum
for 每层i from 1 to max_depth:
    while 栈非空且栈顶层的w >= w[i]:
        弹出栈顶，sum减去其贡献
    计算当前层贡献：sum += w[i]*(i - 栈顶索引)
    入栈，记录sum
    更新全局最大值ans
```

---

## 题解评分（≥4星）

### 1. Daniel_yao（★★★★★）
**亮点**：  
- 最早提出栈式处理历史层的思想  
- 代码简洁，使用栈顶索引差值计算贡献  
- 时间复杂度严格O(n)

### 2. elbissoPtImaerD（★★★★☆）
**亮点**：  
- 动态规划视角解释栈操作  
- 提出g[i,j]的最小值定义  
- 代码使用STL向量实现深度处理

### 3. ダ月（★★★★☆）
**亮点**：  
- 最直观的栈操作实现  
- 使用pair记录节点数和层数差  
- 实时更新累计值的方式易于理解

---

## 最优思路提炼

### 关键数据结构
- **单调栈**：存储（层节点数，覆盖层数）的pair，保证栈元素严格递增

### 核心操作
1. **弹栈计算**：当处理层i时，弹出所有w≥w[i]的栈顶元素，将其覆盖层数合并到当前层
2. **贡献更新**：累计值 = 栈底到当前层的∑(栈元素w * 覆盖层数)
3. **全局最优**：每次入栈后更新最大值

### 复杂度证明
每个元素最多入栈、出栈各一次，总操作次数为O(n)

---

## 相似题目推荐
1. P2866 [USACO06NOV]Bad Hair Day（单调栈基础）
2. P3195 [HNOI2008]玩具装箱（斜率优化DP）
3. P5490 矩形面积并（扫描线+单调性）

---

## 可视化设计

### 动画方案
![单调栈处理示意图](https://i.postimg.cc/4xXm0kzL/stack-demo.gif)

**关键帧说明**：
1. **层节点数展示**：左侧竖条显示各层原始节点数
2. **栈操作高亮**：
   - 红色闪烁：当前处理层
   - 黄色边框：被弹出的栈元素
   - 绿色填充：新入栈元素
3. **贡献计算**：右侧动态显示累计值公式：  
   `sum = sum_prev + w[i] × (current_layer - stack.top().pos)`

### 交互功能
- **速度调节**：滑块控制处理速度（0.5x~5x）
- **单步执行**：点击单步观察弹栈过程
- **对比模式**：分屏显示原始层数与处理后的单调序列

### 复古像素风格
```javascript
// 伪代码示例
class PixelAnimation {
  constructor() {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.palette = ['#000000','#FF0000','#00FF00','#0000FF']; // 8位色调色板
  }
  
  drawStackFrame(stack, currentLayer) {
    // 绘制16x16像素块表示栈元素
    stack.forEach((item, idx) => {
      this.ctx.fillStyle = this.palette[item.status];
      this.ctx.fillRect(idx*20, 0, 16, 16); 
    });
    // 播放8位音效
    playSound('blip.wav'); 
  }
}
```

---

## 代码实现（关键片段）

### 核心逻辑
```cpp
int ans = 0;
stack<pair<int, int>> st; // (w, count)
for (int i = 1; i <= max_depth; ++i) {
    int cnt = 0;
    while (!st.empty() && st.top().first >= w[i]) {
        ans -= st.top().first * st.top().second;
        cnt += st.top().second;
        st.pop();
    }
    cnt++;
    ans += w[i] * cnt;
    st.emplace(w[i], cnt);
    max_ans = max(max_ans, ans);
}
```

### 音效触发
```javascript
function playSound(type) {
  const audioCtx = new AudioContext();
  const oscillator = audioCtx.createOscillator();
  // 不同操作对应不同频率
  if(type === 'pop') oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); 
  if(type === 'push') oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
  oscillator.connect(audioCtx.destination);
  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.1);
}
```

---
处理用时：70.97秒
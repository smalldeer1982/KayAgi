# 题目信息

# 「EZEC-14」众数 II

## 题目背景

dXqwq 是一个不可爱的男孩子。他在 NOI2022 中的众数一题定义了 $10^6$ 个 ``std::deque`` 并成功 MLE。

## 题目描述

给定一个长度为 $n$ 的序列 $a$，我们通过以下方式构造序列 $b$：

- 初始时 $b$ 为空序列。
- 对于 $i=1,2,\cdots,n$，我们依次向 $b$ 的尾部插入 $1,2,\cdots,a_i$。

dXqwq 定义一个序列的**最小众数**为所有出现次数最大的数的最小值。例如 $[1,1,4,5,1,4]$ 的最小众数为 $1$，而 $[1,14,5,14,19,19,8,10]$ 的最小众数为 $14$。

你需要求出 $b$ 的每个子区间的**最小众数**的和。由于答案可能很大，你只需要输出它对 $998244353$ 取模后的值。

## 说明/提示

**【样例解释】**

在第一个样例中，$b=[1,1,2,1,2,3]$。

有 $15$ 个区间的最小众数为 $1$，$5$ 个区间的最小众数为 $2$，$1$ 个区间的最小众数为 $3$，因此答案为 $15\times 1+5\times 2+1\times 3=28$。

**【提示】**

开 $10^6$ 个 ``std::deque`` 在空间限制为 512MB 时一定会 MLE。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（10 pts）：$\sum a_i\leq 100$。
- Subtask 2（20 pts）：$\sum a_i\leq 10^3$。 
- Subtask 3（20 pts）：$\sum a_i\leq 10^6$。
- Subtask 4（10 pts）：$n\leq 2$。
- Subtask 5（20 pts）：$n\leq 10^3$。
- Subtask 6（10 pts）：$a_i\leq 2$。
- Subtask 7（10 pts）：无特殊限制。 

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$1\leq a_i\leq 10^6$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
28```

## 样例 #2

### 输入

```
9
9 9 8 2 4 4 3 5 3```

### 输出

```
1912
```

# AI分析结果



**唯一算法分类**：并查集/链表维护极长连续段 + 贡献计算

---

### **综合分析与结论**

#### **核心算法流程**
1. **关键结论**：区间最小众数只能是1或区间左端点值。利用此性质，只需统计每个数x作为左端点时的合法区间数。
2. **极长连续段维护**：倒序遍历数值（从max(a_i)到2），维护满足a_i≥x的连续区间。合并相邻区间时用并查集或链表快速处理。
3. **贡献计算**：对每个数值x，累加其作为最小众数的区间数。总贡献为所有x的贡献加上未被覆盖的1的贡献。

#### **可视化设计思路**
- **动画流程**：
  1. 倒序数值从大到小显示，用不同颜色标记当前数值x。
  2. 动态合并满足a_i≥x的相邻区间，展示合并过程（如区间块颜色渐变）。
  3. 显示贡献计算公式（如当前段长度、累加的贡献值）。
- **高亮操作**：合并区间时高亮被合并的区间块，贡献计算时显示公式参数（如sum、len等）。
- **像素风格**：用8-bit色块表示连续段，合并时播放经典音效（如“哔”声），贡献更新时显示数值跳动。

---

### **题解清单 (≥4星)**

1. **larsr (5星)**  
   - **亮点**：利用并查集高效合并区间，数学推导清晰，贡献计算用前缀和优化。代码结构清晰，注释详细。
   - **核心代码**：
     ```cpp
     for(int i = 1e6; i > 1; i--){
         while(p[j].a == i) { // 合并操作
             if(v[p[j].id-1]) hb(find(p[j].id-1), find(p[j].id));
             if(v[p[j].id+1]) hb(find(p[j].id), find(p[j].id+1));
             j--;
         }
         ans += (now - ji*(i-1)) * i; // 贡献计算
     }
     ```

2. **dead_X (5星)**  
   - **亮点**：链表维护连续段，动态计算贡献。代码简洁高效，利用vector快速访问数值位置。
   - **核心代码**：
     ```cpp
     for(int x : v[i]) { // 处理数值i的位置
         f[x] = i, g[x] = 1;
         if(l[x-1]) merge(x-1, x); // 合并左右区间
         if(r[x+1]) merge(x, x+1);
     }
     ans += (sf - sg*(i-1)) * i; // 贡献累加
     ```

3. **nullqtr_pwp (4星)**  
   - **亮点**：数学公式推导贡献，前缀和优化。思路与高分题解一致，代码稍显复杂但逻辑清晰。

---

### **最优思路提炼**
- **倒序处理数值**：从大到小处理数值，避免重复计算。
- **极长连续段合并**：用并查集或链表维护满足条件的连续区间，合并时更新贡献参数。
- **贡献公式**：每个数值x的贡献为`sum(区间内a_i) * len - (x-1)*len*(len+1)/2`。

---

### **同类型题推荐**
1. **P1904 天际线**：极值维护与区间合并。
2. P1972 HH的项链：区间贡献统计与离线处理。
3. P5490 矩形面积并：扫描线+区间合并。

---

### **可视化代码片段（伪代码）**
```javascript
// Canvas绘制极长连续段
function drawBlocks(blocks) {
  blocks.forEach(block => {
    ctx.fillStyle = block.color;
    ctx.fillRect(block.x, block.y, block.w, block.h);
  });
}

// 合并动画（伪代码）
function mergeAnimation(block1, block2) {
  playSound('merge'); // 播放合并音效
  animate(block1.w += block2.w, () => drawBlocks());
}
```

---

### **复古游戏化设计**
- **像素风格**：16色块表示区间，合并时显示爆炸特效。
- **音效设计**：合并时播放8-bit音效，贡献更新时显示数字滚动音。
- **自动演示**：按数值降序自动处理，按空格暂停/继续。

---
处理用时：62.72秒
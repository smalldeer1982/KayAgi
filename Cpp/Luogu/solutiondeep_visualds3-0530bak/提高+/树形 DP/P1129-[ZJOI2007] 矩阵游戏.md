# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果



## 算法分类
**二分图最大匹配**

---

## 题解分析与结论

### 核心思路与难点
1. **问题转化**  
   将矩阵的**行**与**列**视为二分图的左右两部分，每个黑色格子`(i,j)`建立一条行i到列j的边。目标转化为判断是否存在**完美匹配**（每个行恰好匹配一个列）。

2. **交换操作的本质**  
   交换行或列仅改变节点的**编号顺序**，不影响边的存在性，因此最大匹配数不变。只要初始图的匹配数≥n即可通过交换得到对角线全黑。

3. **实现方法对比**  
   - **匈牙利算法**：O(n^3)，代码简洁，适合n≤200  
   - **Dinic网络流**：O(n√n)，效率更高，需建虚拟源汇点  

---

## 4星以上题解推荐
1. **俾斯麦（匈牙利算法）** ★★★★★  
   **亮点**：图文结合，通过实例说明交换不影响匹配；代码清晰，包含快读和高效清零。  
   **核心代码**：  
   ```cpp
   bool dfs(int x) {
       for (int i=head[x]; i; i=next[i])
           if (!vis[y = to[i]]) {
               vis[y] = 1;
               if (!match[y] || dfs(match[y])) {
                   match[y] = x; return true;
               }
           }
       return false;
   }
   ```

2. **Night_Aurora（网络流Dinic）** ★★★★☆  
   **亮点**：详细推导网络流建模过程，强调匹配数与交换的关系。  
   **关键步骤**：源点连行、列连汇点，黑格连边，Dinic求最大流是否为n。

3. **hs_black（二分图匹配）** ★★★★☆  
   **亮点**：简洁代码+调试注释，适合快速理解核心逻辑。  
   **核心思想**：每行必须匹配唯一列，交换后形成完美排列。

---

## 最优思路与技巧
1. **建模关键**：将行/列抽象为节点，黑格作为边，完美匹配即解。
2. **匈牙利优化**：使用时间戳替代`memset`加速访问标记。
3. **网络流建图**：源点→行（容量1），列→汇点（容量1），黑格边容量1。

---

## 类似题目推荐
1. [P3386 二分图最大匹配](https://www.luogu.com.cn/problem/P3386)  
2. [P2764 最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)  
3. [P3254 圆桌问题](https://www.luogu.com.cn/problem/P3254)

---

## 可视化设计（复古像素风格）
1. **动画流程**  
   - **网格绘制**：矩阵与二分图左右侧以16位像素块显示，黑格对应边高亮。  
   - **匹配过程**：匈牙利算法中增广路径以绿色像素流动，匹配成功时节点变黄。  
   - **音效触发**：找到增广路时播放8-bit上升音效，失败时短促“哔”声。

2. **交互功能**  
   - **速度调节**：滑块控制算法执行速度（50ms~2s/步）。  
   - **模式切换**：匈牙利/Dinic并行演示，对比匹配路径差异。  
   - **自动演示**：AI逐步展示行匹配列的过程，按空格暂停/继续。

3. **代码片段（Canvas绘制边）**  
   ```javascript
   function drawEdge(i, j, matched) {
       ctx.beginPath();
       ctx.moveTo(rowX(i), rowY(i));
       ctx.lineTo(colX(j), colY(j));
       ctx.strokeStyle = matched ? '#FFD700' : '#00FF00';
       ctx.lineWidth = 2;
       ctx.stroke();
   }
   ```

---

## 代码实现（匈牙利算法）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=205;
vector<int> g[N]; // 邻接表存图
int match[N], vis[N], n, T, x;

bool dfs(int u) {
    for(int v : g[u]) 
        if(!vis[v]) {
            vis[v] = 1;
            if(!match[v] || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    return false;
}

int main() {
    scanf("%d", &T);
    while(T--) {
        scanf("%d", &n);
        for(int i=1; i<=n; ++i) {
            g[i].clear();
            for(int j=1; j<=n; ++j) {
                scanf("%d", &x);
                if(x) g[i].push_back(j);
            }
        }
        memset(match, 0, sizeof(match));
        int cnt = 0;
        for(int i=1; i<=n; ++i) {
            memset(vis, 0, sizeof(vis));
            cnt += dfs(i);
        }
        puts(cnt == n ? "Yes" : "No");
    }
    return 0;
}
```

---

## 调试心得摘录
- **俾斯麦**：`clear()`函数避免全量`memset`，大幅优化时间。  
- **hs_black**：WA因`match`数组未清零，强调多组数据初始化重要性。

---
处理用时：70.76秒
# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



# 排队接水问题分析

## 算法分类
贪心算法

---

## 题解思路与核心难点
1. **贪心策略**：将接水时间短的人优先安排，减少后续等待人数带来的时间放大效应。  
2. **数学证明**：相邻两人若交换位置会增加总等待时间，故最优顺序为升序排列。  
3. **数据结构**：使用结构体或数值编码保存时间与编号，排序后按序输出。  
4. **关键公式**：总等待时间 = Σ (t_i * (n-i))，需注意数据类型防止溢出。  
5. **难点处理**：时间相同时按原序排列，需在排序函数中处理编号比较。

---

## 题解评分（≥4星）

### 1. 无乐鸦题解（5星）
- **亮点**：数学证明严谨，从局部最优推导全局最优，理论支撑强。  
- **代码**：未提供代码，但思路清晰。

### 2. f112358题解（4星）
- **技巧**：时间*1001+编号的数值编码法，避免结构体使用。  
- **代码**：简洁高效，但需注意溢出风险。

### 3. BlueArc题解（4星）
- **实现**：结构体+自定义排序，代码可读性强。  
- **公式**：总时间累加逻辑清晰，适合教学。

---

## 最优思路与技巧提炼
1. **贪心排序**：时间升序排列，短作业优先。  
2. **数值编码**（f112358）：`t_i * MAX_N + id` 直接排序，快速提取编号。  
3. **稳定排序**：时间相同时保持输入顺序，避免编号乱序。  
4. **数据类型**：总时间用`long long`，避免溢出。

---

## 核心代码实现
```cpp
#include <algorithm>
#include <cstdio>

struct Person {
    int time, id;
};

bool cmp(const Person &a, const Person &b) {
    if (a.time != b.time) return a.time < b.time;
    return a.id < b.id; // 时间相同按编号排序
}

int main() {
    int n;
    scanf("%d", &n);
    Person p[1005];
    for (int i = 0; i < n; ++i) {
        scanf("%d", &p[i].time);
        p[i].id = i + 1;
    }
    std::sort(p, p + n, cmp);
    
    long long total = 0;
    for (int i = 0; i < n; ++i) {
        printf("%d ", p[i].id);
        total += p[i].time * (n - i - 1);
    }
    printf("\n%.2lf\n", total * 1.0 / n);
    return 0;
}
```

---

## 相似题目推荐
1. **P1090 合并果子**（贪心+优先队列）  
2. **P1803 线段覆盖**（活动选择问题）  
3. **P1220 关路灯**（动态规划+时间优化）

---

## 可视化设计
### 算法演示（复古像素风格）
1. **动画流程**：  
   - **初始队列**：用不同颜色方块表示每个人的接水时间，编号显示在方块顶部。  
   - **排序过程**：每次选择最小时间方块，高亮并移动到已排序区域，播放“选择”音效。  
   - **时间累加**：每次插入后，显示当前总等待时间和公式`t_i*(剩余人数)`。  

2. **交互功能**：  
   - **步进控制**：空格键单步执行，方向键调整速度。  
   - **音效提示**：方块移动时播放8-bit音效，完成排序时播放胜利音效。  

3. **Canvas实现**：  
   ```javascript
   // 伪代码：绘制排序过程
   function drawQueue(sorted, unsorted) {
       ctx.clearRect(0, 0, canvas.width, canvas.height);
       sorted.forEach((p, i) => drawPixelBlock(p.time, p.id, i * 40, 0));
       unsorted.forEach((p, i) => drawPixelBlock(p.time, p.id, i * 40, 60));
   }
   ```

---

## 个人心得
- **调试教训**：总时间未用`long long`导致WA，需注意数据范围。  
- **顿悟**：贪心策略的局部最优性可通过数学归纳法严格证明，避免直觉误判。

---
处理用时：80.44秒
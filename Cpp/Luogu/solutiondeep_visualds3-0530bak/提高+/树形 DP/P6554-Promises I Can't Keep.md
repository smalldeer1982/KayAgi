# 题目信息

# Promises I Can't Keep

## 题目背景

>I had so much certainty  
Til that moment I lost control  
And I've tried but it never was up to me  
I've got no worse enemy  
Than the fear of what's still unknown  
And the time's come to realize there will be  
Promises I can't keep

## 题目描述

RFMC 给了你一个电路，一个电源，他希望你能把电源接在电路的某一个节点上，让电流流通，并答应给你电路显示屏上的数那么多钱。

这个电路有 $n$ 个节点，每个节点有一个权值 $val_i$，以 $n-1$ 条导线互相连通。你可以把电源接在任意一个起点上。接着，电流从这个节点开始流。若当前电源接到了一个节点 $u$，则接下来电流会**等概率**且**不重复经过一个点地**流向**一个叶子节点**，电流流过的所有节点的权值即为电路显示屏上的数（叶子节点即为 **除了 $u$** 的度数为 1 的节点）。

现在你有 $n$ 种接电源的选择，你希望接上电源以后期望得分越高越好，所以你现在就要在规定的时间内求出这 $n$ 种期望值中最大的的一个。

## 说明/提示

样例一的解释：

电源接在 5 号节点时有两种情况：$5\rightarrow 1\rightarrow 2\rightarrow 3$ 或 $5\rightarrow 1\rightarrow 2\rightarrow 4$，两种情况得分分别为 8 和 6，期望值即为 7，可以证明没有其他节点接通电源的期望值比 7 大。

---

**本题采用捆绑测试，每一档部分分对应一个 subtask。**

对于 $30\%$ 的数据，保证 $2<n\le 10^3$。  
对于另外 $20\%$ 的数据，保证是一条链。  
对于所有的数据，保证 $2<n\le 5\times10^5,\  |val_i|\le10^4$。

本题的 special judge 代码已经在附件中给出。

附：本题数据量较大，可以采用更快的读入方法。（标程在用 ```scanf``` 的情况下可以通过）

~~后记：按照题目名称，RFMC 是不会遵守诺言的（大雾~~

题目名其实是一首歌名啦。

## 样例 #1

### 输入

```
5
1 2
1 5
2 3
2 4
2 3 1 -1 2```

### 输出

```
7.0000```

# AI分析结果



## 算法分类  
树形动态规划（换根DP）

---

## 题解思路与算法要点  
### 核心问题  
给定一棵树，每个节点有权值，求以每个节点为根时，到所有叶子路径的权值和的期望最大值。  

### 解决思路  
1. **第一次DFS（预处理子树信息）**  
   - `cnt[u]`：以u为根的子树中叶子节点数量  
   - `g[u]`：以u为根的子树的路径权值和（乘以叶子数，避免浮点运算）  
   - 递归计算每个节点子树的贡献，非叶子节点累加子节点信息。  

2. **第二次DFS（换根计算全局信息）**  
   - `f[u]`：以u为根时整棵树的路径权值和（乘以总叶子数）  
   - 当根从父节点切换到子节点时，利用父节点的信息推导子节点的值。  
   - 关键公式：  
     - 叶子节点：`f[v] = f[u] - val[u] + (总叶子数-2)*val[v]`  
     - 非叶子节点：`f[v] = f[u] - cnt[v]*val[u] + (总叶子数 - cnt[v])*val[v]`  

### 难点对比  
- **叶子与非叶子节点的处理**：叶子节点的`cnt`初始化为1，非叶子节点需要累加子树信息。  
- **换根时的数学推导**：需精确计算父节点与子节点之间的贡献差，避免重复计算。  
- **精度问题**：使用整数运算避免浮点误差，最终结果再转换为浮点数。  

---

## 题解评分（≥4星）  
1. **UltiMadow（5星）**  
   - 思路清晰，公式推导严谨，代码结构简洁，处理了所有边界情况。  
   - 核心代码：  
     ```cpp  
     // 第一次DFS计算子树信息  
     void dp1(int u, int fa) {  
         for (int v : children) {  
             dp1(v, u);  
             cnt[u] += cnt[v];  
             g[u] += g[v];  
         }  
         g[u] += val[u] * cnt[u];  
         if (cnt[u] == 0) g[u] = val[u], cnt[u] = 1;  
     }  
     ```  

2. **BzhH（4星）**  
   - 简化了状态转移公式，代码可读性高，但未处理链的特殊情况。  
   - 关键公式：`f[v] = f[u] - val[u] * cnt[v] + val[v] * (总叶子数 - cnt[v])`  

3. **a1co0av5ce5az1cz0ap_（4星）**  
   - 直接计算每条边两侧的贡献差，思路新颖，代码简短但需特殊处理链结构。  

---

## 最优思路提炼  
1. **两次DFS结构**：预处理子树信息后，通过换根推导全局信息。  
2. **贡献差公式**：利用父节点与子节点之间的叶子数差和权值差快速更新。  
3. **避免浮点运算**：所有中间结果用整数计算，最后除法转换为浮点。  

---

## 类似题目推荐  
1. **P3047 [USACO12FEB] Nearby Cows G**（换根DP）  
2. **P3478 [POI2008] STA-Station**（树的重心与换根）  
3. **P2986 [USACO10MAR] Great Cow Gathering G**（权值路径和优化）  

---

## 可视化算法演示  
### 动画设计  
1. **树形结构绘制**：  
   - 使用Canvas绘制树，节点为圆形，边为连线。  
   - 初始根节点标记为红色，子节点为蓝色。  

2. **第一次DFS过程**：  
   - 自底向上遍历，处理完的子节点变为绿色，显示`cnt`和`g`的值。  
   - 音效：处理节点时播放“滴”声。  

3. **换根过程**：  
   - 根节点切换到子节点时，原根变灰，新根变红。  
   - 显示`f`值的更新公式，高亮变化的数学项。  
   - 音效：换根时播放“咔嚓”声。  

4. **最终结果展示**：  
   - 所有节点显示其期望值，最大值节点闪烁。  
   - 背景音乐：8-bit风格胜利旋律。  

### 代码片段（JS伪代码）  
```javascript  
class Node {
  constructor(id, val) {
    this.id = id;
    this.val = val;
    this.children = [];
    this.cnt = 0;   // 叶子数
    this.g = 0;      // 子树贡献
    this.f = 0;      // 全局贡献
  }
}

// 第一次DFS
function dfs1(u, parent) {
  if (isLeaf(u)) {
    u.cnt = 1;
    u.g = u.val;
    return;
  }
  u.children.forEach(v => {
    if (v !== parent) {
      dfs1(v, u);
      u.cnt += v.cnt;
      u.g += v.g;
    }
  });
  u.g += u.val * u.cnt;
}

// 第二次DFS
function dfs2(u, parent, totalLeaf) {
  u.children.forEach(v => {
    if (v !== parent) {
      if (isLeaf(v)) {
        v.f = u.f - u.val + (totalLeaf - 2) * v.val;
      } else {
        v.f = u.f - v.cnt * u.val + (totalLeaf - v.cnt) * v.val;
      }
      dfs2(v, u, totalLeaf);
    }
  });
}
```

---

## 个人心得  
- **边界处理**：叶子节点的定义需排除根节点自身。  
- **链结构特例**：当树退化为链时，需单独验证公式的正确性。  
- **调试技巧**：手动计算小样例（如n=3）验证中间值。  

---

通过换根DP将复杂度优化至O(n)，结合数学推导精确处理贡献差，是解决此类树形问题的经典范式。

---
处理用时：88.36秒
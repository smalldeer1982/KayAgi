# 题目信息

# 「PMOI-3」子树

## 题目背景

分割线下有形式化题面，可以配合食用。

## 题目描述

b6e0 有一棵树，树上第 $i$ 个点有价值 $a_i$。每条边长度为 $1$。

b6e0 会选择一个节点作为根节点。设这个节点为 $r$。然后，b6e0 会圈定一个节点的整个子树作为他的领地，设这个子树的根节点为 $u$。此时，树上的每个节点会给 b6e0 带来一些收益。在领地子树的根节点为 $u$ 的情况下，节点 $x$ 带来的收益 $f(x,u)$ 定义如下：
1. 当 $x$ 在 $u$ 的子树中时，它的收益为它父亲节点的收益加上它本身的价值 $a_x$；
2. 当 $x$ 不在 $u$ 的子树中时，它的收益为：与它相邻的节点中，与 $u$ 距离（到 $u$ 的简单路径长度）比 $x$ 到 $u$ 的距离远的节点，这些节点的收益**对 $998244353$ 取模**的最大值，再乘上 $a_x$。

在根节点为 $r$ 的情况下，定义以 $u$ 为子树的收益 $W(u)$ 为所有节点的 $f$ 值和。

当然，b6e0 有许多种选择根节点的方案。定义选 $r$ 为根节点的收益 $C(r)$ 为对于所有 $u$，以 $u$ 为子树的收益（$W(u)$）的和。对于每一个节点 $r$，求 $C(r)$。

---
形式化题面：

给你一棵有 $n$ 个节点的树，第 $i$ 个节点有点权 $a_i$，每条边的长度为 $1$。当根节点为 $r$ 时：

设 $F(x)$ 表示 $x$ 的父亲节点，特殊地，$F(r)=0$；$D(x,y)$ 表示 $x$ 到 $y$ 的简单路径的长度，特殊地，对于所有 $x$，$D(x,x)=0$；$A_x$ 表示 $x$ 的子树中的节点（包括 $x$ 本身）组成的集合，即 $A_x=\{y\mid D(x,y)=D(F(x),y)-1\}$，特殊地，$A_r=\{1,2,\cdots,n\}$；$B_x$ 表示与 $x$ 相邻的节点组成的集合，即 $B_x=\{y\mid D(x,y)=1\}$。

定义 $f(x,u)$：
$$f(x,u)=\begin{cases}f(F(x),u)+a_x&x\in A_u\\a_x\cdot\max_{y\in B_x,D(y,u)>D(x,u)}\{f(y,u)\bmod 998244353\}&x\not\in A_u\end{cases}$$
特殊地，对于所有 $x$，$f(0,x)=0$；在 $x\not\in A_u$ 的情况中，若对于所有 $y\in B_x$，都有 $D(y,u)\le D(x,u)$，则 $f(x,u)=a_x$。

定义节点 $u$ 的分数 $W(u)=\sum_{v=1}^nf(v,u)$。

定义节点 $r$ 的收益 $C(r)$ 表示以 $r$ 为根时，$\sum_{i=1}^nW(i)$ 的值。

对于每一个节点 $r$，求 $C(r)$。

**所有 $C(r)$ 对 $998244353$ 取模。**

## 说明/提示

【样例解释】

样例中的树如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/bs02n466.png)

例如在 $r=1$，$u=5$ 时，$f(2,u)=a_2=2$，$f(1,u)=a_1\cdot f(2,u)=14$，$f(3,u)=a_3\cdot f(1,u)=70$，$f(6,u)=a_6=5$，$f(4,u)=a_4\cdot\max\{f(3,u),f(6,u)\}=7000$，$f(5,u)=f(4,u)+a_5=7001$。

【数据范围】
- Subtask1（10pts）：$n\le200$，$a_i\le 10^3$；
- Subtask2（20pts）：$n\le10^3$；
- Subtask3（20pts）：树为一条链；
- Subtask4（20pts）：存在一个节点，使得它的度数为 $n-1$；
- Subtask5（30pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le5\times10^5$，$1\le a_i\le10^9$。

## 样例 #1

### 输入

```
6
7 2 5 100 1 5
1 3
3 4
1 2
4 5
4 6```

### 输出

```
67562
29930
75168
76888
63243
63283```

# AI分析结果



**唯一算法分类**  
树形动态规划（换根DP）

---

**综合分析与结论**  
本题核心是通过树形DP预处理子树信息，再通过换根技术高效计算所有根节点的答案。关键难点在于：  
1. 子树内外的贡献计算方式差异极大，需要分别推导数学表达式  
2. 换根时需要快速维护子树外部分的动态最大值链  
3. 大规模数据的模运算处理与时间复杂度控制  

**核心算法流程**：  
1. **预处理阶段**：通过DFS计算每个节点的子树大小（siz）、子树路径和（ss）、最大贡献链（sp）等基础信息  
2. **首次DP**：计算固定根时的总贡献，维护前缀/后缀最大值优化子树外贡献的转移  
3. **换根DP**：利用父节点信息快速推导子节点的总贡献，通过公式抵消变化部分  

**可视化设计**：  
- **树结构展示**：用不同颜色区分当前根节点与正在处理的子树  
- **贡献值流动**：用粒子动画表示子树内的路径和累加过程  
- **最大值链更新**：当换根时，用高亮边框标记需要重新计算的前缀/后缀区间  
- **复古像素风格**：每个节点显示为16x16像素块，子树区域用半透明色块覆盖，换根时播放8-bit音效  

---

**题解清单 (5星)**  
1. **官方题解（5星）**  
   - 创造性地将问题拆分为子树内外贡献  
   - 利用前缀/后缀最大值优化转移过程  
   - 完整推导数学公式，代码结构清晰  

---

**最优思路提炼**  
1. **贡献拆分**：将每个节点的贡献分为子树内（链式累加）和子树外（动态最大值链）  
2. **换根公式**：当根节点变化时，只需调整原根与新根相关部分，其他子树信息复用  
3. **前缀优化**：维护子树兄弟节点的前缀/后缀最大值，避免重复遍历子节点  

**关键代码片段**  
```cpp
void dfs(int x,int f) {
    siz[x]=1; sp[x]=-1;
    for(int v:g[x]) if(v!=f) {
        dfs(v,x);
        siz[x] += siz[v];
        ss[x] = (ss[x]+ss[v])%mod;
        sp[x] = max(sp[x], sp[v]); // 维护子树外最大值链
    }
    ss[x] = (ss[x] + siz[x]*a[x])%mod;
    sp[x] = (sp[x]==-1) ? a[x] : sp[x]*a[x]%mod;
}

void dp1(int x,int f,ll nf,ll ns) {
    uans[x] = (ss[x] + nf*siz[x] + ns)%mod; // 当前u的总贡献
    vector<ll> pm, lm; // 前缀/后缀最大值
    for(int v:g[x]) if(v!=f) pm.push_back(max(pm.back(), sp[v]));
    for(int v:g[x]) if(v!=f) {
        ll new_f = max({nf, pm[...], lm[...]}) * a[x]%mod; // 换根时更新链
        dp1(v, x, new_f, ...);
    }
}
```

---

**同类型题目推荐**  
1. [P3478 STA-Station](https://www.luogu.com.cn/problem/P3478)  
2. [P3047 Nearby Cows](https://www.luogu.com.cn/problem/P3047)  
3. [P1131 时态同步](https://www.luogu.com.cn/problem/P1131)

---

**可视化算法演示**  
```html
<canvas id="treeCanvas"></canvas>
<script>
// 伪代码演示核心逻辑
class Node {
    draw(ctx) {
        // 绘制16x16像素块，颜色根据当前状态变化
        if(this.isRoot) ctx.fillStyle = '#FF0000';
        else if(this.inSubtree) ctx.fillStyle = '#00FF0080'; 
        ctx.fillRect(x*30, y*30, 16, 16);
        
        // 显示关键数值
        ctx.fillText(`${this.sp}`, x*30+5, y*30+12);
    }
}

function animateRootChange(oldRoot, newRoot) {
    // 播放换根音效
    playSound('swap_root.ogg');
    // 渐隐旧根标记
    animateOpacity(oldRoot, 1→0, 500ms);
    // 渐显新根标记
    animateOpacity(newRoot, 0→1, 500ms);
    // 高亮受影响的子树区域
    highlightAffectedSubtree(newRoot);
}
</script>
```

---

**个人心得**  
调试时发现：  
- **模运算陷阱**：比较最大值时若先取模会导致错误，需保持原始值比较  
- **边界处理**：叶子节点的`sp`值初始化容易遗漏，需特判子节点数为0的情况  
- **性能优化**：使用vector存储前缀/后缀数组而非递归计算，节省40%时间  

---

**实现要点总结**  
1. **双DFS架构**：首次扫描预处理，二次扫描动态换根  
2. **空间换时间**：存储前缀/后缀最大值避免重复计算  
3. **数学公式转换**：将递归式转化为可叠加的线性表达式  
4. **模块化设计**：分离子树内外贡献计算，降低代码耦合度

---
处理用时：72.82秒
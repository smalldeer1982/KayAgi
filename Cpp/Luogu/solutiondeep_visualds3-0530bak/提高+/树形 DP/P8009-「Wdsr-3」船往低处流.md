# 题目信息

# 「Wdsr-3」船往低处流

## 题目背景

村纱水密是控制着圣辇船的船长。因为是一生和船相伴的船幽灵，因此对船只非常感兴趣。正因为这样的爱好，村纱有一大堆船模。

由于间歇泉的喷发，间歇泉的周围出现了一个汇聚了多方水流的大水坑。不同的水流交错，形成了大大小小的水道。只需要把船模放在某个位置，它就会顺着水流流动。根据物理原理，船自然会从高处流向低处。由于水坑由四处的水汇集而成，因此水坑的中央地势最低；随着到中央距离的增加，地势不断增加。

村纱发现，当她选定了两个位置放下船模后，它们会在某个水流的交汇处发生碰撞。村纱关心碰撞发生的位置。容易发现，第一个可能会产生碰撞的位置，就是在树形结构上这两个选定的点的最近公共祖先。

当然了，由于间歇泉并不稳定，因此水池中央的位置可能会不断变化，地势也不断变化，但是水道并不会发生任何改变。村纱给每个交汇处标上了一个数值「危险程度」，表示两个船模在此处碰撞可能会发生的危险的大小。村纱放置船模的位置也是随机的。

不过由于水坑实在是太大，水坑中央又不断变化，因此只关心船模的村纱被绕晕了。她迫切地想知道在水坑处玩船模产生的威胁，因此希望你帮她计算。

## 题目描述

这些水道形成了一棵以 $1$ 为根的节点数为 $n$ 的树形结构 $T$。每个节点上有一个点权 $w_i$，表示它的危险程度。现做出如下定义：

- **最近公共祖先**：在一棵以 $r$ 为根的有根树上，两个节点 $u,v$ 的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个，记作 $\operatorname{lca}(r,u,v)$。
- **子树**：树 $T$ 上，删掉节点 $u$ 与父亲相连的边后，该结点所在的子图记为子树 $T_u$。特别地，$T$ 本身可以认为是以 $1$ 为根节点的子树 $T_1$。
- **危险值**：对于 $T_u$ 而言，它的危险值被定义为：

$$\mathrm{LCAS}(u)=\sum_{i\in T_u}\sum_{j\in T_u}\sum_{k\in T_u,k<j} w_{\operatorname{lca}(i,j,k)}$$

现在给出 $T$，希望你对于 $i=1,2,\cdots n$，求出 $\mathrm{LCAS}(i)$。

## 说明/提示



#### 样例 1 解释

样例一当中的树如下。红色的是节点，蓝色的是点权。

![](https://cdn.luogu.com.cn/upload/image_hosting/f7gvtsp5.png)

容易发现 $\mathrm{LCAS}(2)=\mathrm{LCAS}(4)=\mathrm{LCAS}(5)=0$。这里说明如何计算 $\mathrm{LCAS}(1)$ 和 $\mathrm{LCAS}(3)$。首先说明 $\mathrm{LCAS}(3)$：

- 以 $3$ 为根，那么有 $\mathrm{lca}(3,3,4)=\mathrm{lca}(3,3,5)=\mathrm{lca}(3,4,5)=3$，这部分的贡献是 $3\times w_3=6$。  
- 以 $4$ 为根，那么有 $\mathrm{lca}(4,3,4)=\mathrm{lca}(4,4,5)=4,\mathrm{lca}(4,3,5)=3$，这部分的贡献是 $2\times w_4+1\times w_3=4$。  
- 以 $5$ 为根，那么有 $\mathrm{lca}(5,3,5)=\mathrm{lca}(5,4,5)=5,\mathrm{lca}(5,3,4)=3$，这部分的贡献是 $2\times w_5+1\times w_3=8$。

因此，$\mathrm{LCAS}(3)=6+4+8=18$。下面计算 $\mathrm{LCAS}(1)$。

$$
\def\arraystretch{1.2}
\begin{matrix}
\textbf{以 1 为根 }\bm{\mathbf{lca}(1,i,j)} & \textbf{以 2 为根 }\bm{\mathbf{lca}(2,i,j)}\cr
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 1 & 1 & - & - &- \cr\hline
4 & 1 & 1 & 3 & - &- \cr\hline
5 & 1 & 1 & 3 & 3 &- \cr\hline
\end{array} &
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 2 & - & - & - &- \cr\hline
3 & 1 & 2 & - & - &- \cr\hline
4 & 1 & 2 & 3 & - &- \cr\hline
5 & 1 & 2 & 3 & 3 &- \cr\hline
\end{array} \cr[50pt]
\textbf{以 3 为根 }\bm{\mathbf{lca}(3,i,j)} & \textbf{以 4 为根 }\bm{\mathbf{lca}(4,i,j)}\cr
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 3 & 3 & - & - &- \cr\hline
4 & 3 & 3 & 3 & - &- \cr\hline
5 & 3 & 3 & 3 & 3 &- \cr\hline
\end{array} &
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 3 & 3 & - & - &- \cr\hline
4 & 4 & 4 & 4 & - &- \cr\hline
5 & 3 & 3 & 3 & 4 &- \cr\hline
\end{array}
\end{matrix}\\[10pt]
\textbf{以 5 为根 }\bm{\mathbf{lca}(5,i,j)}\\
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 3 & 3 & - & - &- \cr\hline
4 & 3 & 3 & 3 & - &- \cr\hline
5 & 5 & 5 & 5 & 5 &- \cr\hline
\end{array}
$$

容易发现，在上图中，$1$ 出现了 $13$ 次，$2$ 出现了 $4$ 次，$3$ 出现了 $25$ 次，$4$ 出现了 $4$ 次，$5$ 出现了 $4$ 次。因此，$\mathrm{LCAS}(1)=3\times 13+1\times 4+2\times 25+1\times 4+3\times 4=109$。

#### 样例 2 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/uwm8c9bk.png)

我有一个精妙绝伦的方法解释样例 $2$，可惜这里空白太小写不下。

**本题输入量较大。请采用较快的读入方式。**

#### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值}\cr\hline
1 & 100 & - & 20 \cr\hline
2 & 10^3 & - & 25 \cr\hline
3 & 10^5 & \text{A} & 10\cr\hline
4 & 10^5 & \text{B} & 10\cr\hline
5 & 10^6 & - & 35\cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证第 $i$ 条边为 $u=i$，$v=i+1$。  
**特殊性质** $\textbf{B}$：保证第 $i$ 条边为 $u=1$，$v=i+1$。

对于全部数据，保证 $1\le n\le 10^6$，$0\le w_i<998,244,353$。

## 样例 #1

### 输入

```
5
3 1 2 1 3
1 2
1 3
3 4
3 5
```

### 输出

```
109
0
18
0
0```

## 样例 #2

### 输入

```
10
1 1 4 5 1 4 1 9 1 9
1 2
1 3
1 4
2 5
2 6
5 7
3 8
3 9
9 10```

### 输出

```
972
33
99
0
2
0
0
0
10
0```

# AI分析结果



**算法分类选择**  
树形动态规划（树形DP）

---

**题解思路、算法要点与解决难点**  
**核心思路**：  
题目要求计算每个子树中所有三元组(i,j,k)的LCA危险值之和。直接暴力枚举三元组不可行，需通过树形DP高效统计贡献。题解通过定义三个关键变量S0、S1、S，分别表示子树合并后的不同组合贡献，并推导其合并公式。

**算法要点**：  
1. **变量定义**：  
   - `S0[u]`：子树u的所有三元组(i,j,k)的贡献总和（不考虑k<j限制）。  
   - `S1[u]`：子树u中所有二元组(i,j)以u为根的LCA贡献总和。  
   - `S[u]`：子树u的节点数。  

2. **合并公式**：  
   合并子树v到u时：  
   - `S0[u] += 3 * S[v] * S1[u] + S0[v] + 3 * S[u] * S1[v]`  
   - `S1[u] += S1[v] + 2 * W[u] * S[u] * S[v]`  
   - `S[u] += S[v]`  

3. **转换公式**：  
   `LCAS(u) = (S0[u] - S[u] * sum_w) / 2`，其中`sum_w`为子树u的总危险值。

**解决难点**：  
- **贡献拆分**：将三元组的LCA贡献拆分为子树内部和跨子树的情况。  
- **合并优化**：通过数学推导将O(n^3)的暴力枚举转化为O(n)的树形DP，避免重复计算。  

---

**题解评分**  
1. **Subtask5题解（5星）**  
   - 思路清晰，通过树形DP和组合数学高效处理贡献合并。  
   - 代码简洁，递归实现自底向上合并子树。  
   - 关键推导完整，优化程度高，适合1e6规模数据。  

---

**最优思路或技巧提炼**  
1. **贡献分类**：将三元组按分布情况分为全在左子树、全在右子树、跨子树三类，分别计算贡献。  
2. **动态维护**：通过`S0`、`S1`动态维护子树合并后的状态，避免重复遍历。  
3. **公式化简**：利用对称性（`j < k`与`k < j`贡献相同）将问题转化为无序三元组计算，简化处理。  

---

**同类型题或类似算法套路**  
- **树形DP + 贡献统计**：如[CF1392H]（统计路径贡献）、[Luogu P4211]（LCA求和）。  
- **组合优化**：利用子树大小和乘法原理统计贡献，类似树的重心问题。  

---

**推荐相似题目**  
1. **Luogu P4211 [LCA]**：计算多个查询的LCA深度和。  
2. **CF1092F Tree with Maximum Cost**：树形DP统计带权路径和。  
3. **Luogu P1352 没有上司的舞会**：经典树形DP问题，决策包含/排除子树。  

---

**个人心得摘录**  
- **初始条件陷阱**：S0和S1的初始值需设为`W[u]`，对应单节点子树的三元组贡献。  
- **合并顺序**：必须自底向上合并，确保子问题先被解决。  

---

**可视化与算法演示**  
**动画设计**：  
1. **树形结构**：以像素风格绘制树，当前处理节点高亮为红色，子树为蓝色。  
2. **合并过程**：  
   - 左子树（蓝色块）与右子树（黄色块）合并，显示S0、S1的数值变化。  
   - 交叉贡献区域用闪烁效果标记，显示`3 * size * S1`的计算过程。  
3. **音效提示**：合并成功时播放“叮”声，错误时播放“哔”声。  

**复古游戏化**：  
- **8位像素风格**：树节点用方块表示，合并时显示“COMBO!”特效。  
- **自动演示**：按DFS顺序自动遍历节点，用户可暂停观察公式更新。  

---

**核心代码实现**  
```cpp
void dfs(int u, int f) {
    S0[u] = S1[u] = W[u]; // 初始化为当前节点贡献
    S[u] = 1;
    T[u] = W[u]; // T[u]记录子树w总和
    for (int i = H[u], v; i; i = N[i]) {
        if ((v = V[i]) == f) continue;
        dfs(v, u);
        // 合并子树v的贡献到u
        int s0 = (S0[u] + 3LL * S[v] % MOD * S1[u] % MOD) % MOD;
        s0 = (s0 + S0[v] + 3LL * S[u] % MOD * S1[v] % MOD) % MOD;
        int s1 = (S1[u] + S1[v] + 2LL * W[u] * S[u] % MOD * S[v] % MOD) % MOD;
        S0[u] = s0;
        S1[u] = s1;
        S[u] += S[v]; // 更新子树大小
        T[u] = (T[u] + T[v]) % MOD; // 累加w总和
    }
    // 计算最终答案
    A[u] = 1LL * (S0[u] - 1LL * S[u] * T[u] % MOD + MOD) * DIV2 % MOD;
}
```

**代码解释**：  
- `dfs`函数递归处理每个子树，合并子节点v的贡献到父节点u。  
- `S0`和`S1`根据推导公式更新，最后通过转换公式计算`LCAS(u)`。  

---

**总结**  
通过树形DP和组合贡献统计，将O(n^3)问题优化为O(n)解法。关键点在于正确推导合并公式并维护动态变量，结合数学优化避免暴力枚举。

---
处理用时：90.03秒
# 题目信息

# 蓬莱「凯风快晴　−富士火山−」

## 题目背景

富士山，被当地人称为「神山」。这是一座休眠火山，最近一次喷发在 $300$ 年前。

向这样的山中投入不死之药，想必会直接喷发吧。如此便理解为什么月岩笠最终抗命。

## 题目描述

所谓的山，是一种上细下粗的结构。能不能在「树」里也找到这样的结构呢？

给定一个以 $1$ 为根的大小为 $n$ 的有根树 $T$。你需要找到满足宽度单调不减的**导出子树**中最大的一棵：

- 记该导出子树为 $T_0$，共有 $k$ 层。
- 记 $T_0$ 的根节点的深度为 $1$，计算出 $T_0$ 中每个结点的深度 $d_i$。由此定义 $T_0$ 第 $i$ 层的宽度 $w_i$ 为「所有深度为 $i$ 的节点的个数」。
- 你需要使得 $w_i$ 单调不减。即，$w_1\le w_2\le \cdots \le w_k$。

记原树的点集和边集分别为 $V,E$。导出子树是原树的一个**连通块**，它的点集 $V_0\subseteq V$，边集 $E_0$ 是 $E$ 当中所有端点均在 $V_0$ 内的边。导出子树的根，是组成它的所有节点中**在原树内深度最浅的那一个**。$T$ 也可以被认为是自身的一棵导出子树。

![](https://cdn.luogu.com.cn/upload/image_hosting/wcbeo1a0.png)

如图所示，绿色的区域和橙色的区域分别是原树的导出子树。它们的根分别为 $2$ 和 $13$。

**注意**：导出子树的定义略微不同于子树的定义。请不要将两者混淆。

请找到最大的符合条件的导出子树的大小。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/pzq47a3e.png)

如图所示，标灰的节点是两个样例中选出来的导出子树。

- 样例 $1$ 找到的导出子树，每一层的宽度分别为 $\{1,2,3,3\}$。
- 样例 $2$ 找到的导出子树，每一层的宽度分别为 $\{1,2,4,4,5\}$。
### 数据范围及约定

对于全部数据，$1\le n\le 5\times 10^5$。

## 样例 #1

### 输入

```
10
1 2
2 3
3 4
3 5
2 6
6 7
1 8
8 9
8 10```

### 输出

```
9```

## 样例 #2

### 输入

```
17
1 2
2 3
3 4
4 5
4 6
3 7
7 8
7 9
7 10
2 11
2 12
1 13
13 14
14 15
14 16
13 17```

### 输出

```
16```

# AI分析结果



**唯一算法分类**  
单调栈

---

### **题解思路、算法要点与解决难点**

**核心思路**：  
题目要求找出满足层宽度非递减的最大导出子树。各题解的共同思路是：  
1. **预处理每层节点数**：通过DFS统计每层节点数`d[i]`。  
2. **单调栈维护递增序列**：从浅到深遍历层，维护一个单调递增的栈，栈顶存储当前可用的最小层宽度。  
3. **动态计算最大贡献**：当处理第`i`层时，弹出栈顶所有`d[栈顶] >= d[i]`的层，累加贡献后压入当前层，更新最大值。

**解决难点**：  
- **连通性保证**：导出子树必须连通，通过固定根节点（深度最浅）隐式保证。  
- **宽度单调性维护**：单调栈将层宽度约束为递增序列，确保后续层数不会破坏条件。  
- **高效计算总和**：栈中记录区间`[L, R]`的宽度为`d[R]`，总和计算为`d[R]*(R-L+1)`。

**关键变量与操作**：  
- `d[i]`：第`i`层节点数。  
- `stk`：单调递增栈，存储层编号。  
- `sum[i]`：以`i`为结尾的区间总和，用于快速计算贡献。

---

### **题解评分 (≥4星)**  

1. **Daniel_yao (⭐⭐⭐⭐⭐)**  
   - **亮点**：代码简洁，直接维护单调栈，动态更新贡献。  
   - **实现**：遍历每层时弹出不满足条件的栈顶，累加区间贡献。  

2. **elbissoPtImaerD (⭐⭐⭐⭐⭐)**  
   - **亮点**：后缀和优化，栈中记录区间起点和贡献总和。  
   - **实现**：通过`g[i,j]`维护后缀最小值，栈操作直接更新区间。  

3. **sQrtN (⭐⭐⭐⭐)**  
   - **亮点**：反证法证明根必选，结合单调栈处理层宽度。  
   - **实现**：弹出时累加贡献，维护当前层可用的最小宽度。  

---

### **最优思路或技巧提炼**  

1. **单调栈维护递增序列**  
   - 遍历每层时，若当前层宽度小于栈顶，则弹出栈顶并合并区间，确保栈内递增。  
   - 总和计算为`栈顶宽度 × 区间长度`，避免重复计算。  

2. **预处理层节点数**  
   - 通过一次DFS统计每层节点数，时间复杂度`O(n)`。  

3. **固定根节点优化**  
   - 最优解必含根节点，避免枚举根节点，简化问题。  

---

### **同类型题或类似算法套路**  

- **最大矩形面积**（单调栈维护高度递增）。  
- **接雨水问题**（单调栈维护递减序列）。  
- **柱状图中最大矩形**（LeetCode 84）。  

---

### **推荐洛谷题目**  

1. **P4147 玉蟾宫**（单调栈求最大子矩阵）  
2. **P2781 传教**（区间动态规划与单调性优化）  
3. **P1725 琪露诺**（滑动窗口与单调队列）  

---

### **个人心得摘录**  

- **Daniel_yao**：  
  > “父亲的数量一定不会比儿子多，维护单调递增栈可避免重复决策。”  
- **sQrtN**：  
  > “全选当前层可能优于继承下层结果，需动态比较两种决策。”  

---

### **可视化与算法演示**  

**动画方案**：  
1. **数据结构可视化**：  
   - 用**网格图**表示树的层结构，每层高度为`d[i]`。  
   - **栈元素**用不同颜色块表示，弹出时高亮红色，压入时绿色。  

2. **关键操作高亮**：  
   - **当前处理层**：黄色高亮，显示层号和节点数。  
   - **栈弹出过程**：红色闪烁被弹出的层区间。  

3. **音效与交互**：  
   - **弹出栈顶**：短促“咔嚓”音效。  
   - **更新最大值**：清脆“叮咚”提示音。  
   - **自动播放**：按层逐步执行，速度可调。  

**复古像素风格设计**：  
- **8位调色板**：层块用绿/黄/红像素表示，栈操作显示为方块合并。  
- **Canvas动画**：网格绘制每层节点数，栈变化以方块堆叠展示。  

---

### **代码实现（核心逻辑）**  

**Daniel_yao 代码片段**：  
```cpp
for(int i=1;i<=n;i++) {
    while(top && d[stk[top]] >= d[i]) top--;
    stk[++top] = i;
    sum[stk[top]] = sum[stk[top-1]] + d[stk[top]] * (stk[top] - stk[top-1]);
    ans = max(ans, sum[stk[top]]);
}
```

**elbissoPtImaerD 代码片段**：  
```cpp
for(re int i=1;i<=n;++i) {
    for(;top&&w[sk[top]]>=w[i];--top);
    sk[++top]=i, s[top]=s[top-1]+w[sk[top]]*(sk[top]-sk[top-1]), ans=std::max(ans,s[top]);
}
```

**sQrtN 代码片段**：  
```cpp
while(!st.empty()&&st.top().first>=wis[i]) {
    rs-=st.top().second*(st.top().first-tot[i]);
    sum+=st.top().second, st.pop();
}
st.push({tot[i],sum+1});
rs+=tot[i];
ans=max(ans,rs);
```

---

### **可视化代码（简略示例）**  

```javascript
// 伪代码：Canvas绘制层与栈
function drawLayers() {
    ctx.fillStyle = '#8B0000'; // 复古红
    for (let i=0; i<layers.length; i++) {
        ctx.fillRect(i*10, 0, 8, layers[i]*5); // 绘制层高度
    }
    // 绘制栈元素
    ctx.fillStyle = '#00FF00'; // 复古绿
    for (let i=0; i<stack.length; i++) {
        ctx.fillRect(stack[i]*10, 100, 8, 30); // 栈位置
    }
}
// 音效触发
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}
```

---
处理用时：74.83秒
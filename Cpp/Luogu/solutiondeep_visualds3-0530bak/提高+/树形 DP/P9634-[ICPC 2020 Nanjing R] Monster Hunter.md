# 题目信息

# [ICPC 2020 Nanjing R] Monster Hunter

## 题目描述

有一棵有根树，包含 $n$ 个顶点，根顶点是 $1$。每个顶点上都有一个怪物。第 $i$ 个顶点上的怪物的生命值为 $hp_i$。

Kotori 想要消灭所有的怪物。第 $i$ 个顶点上的怪物可以被消灭，当且仅当其直接父节点上的怪物已经被消灭。消灭第 $i$ 个怪物所需的力量是 $hp_i$ 加上所有其他活着的怪物的生命值，这些怪物位于以 $i$ 为直接父节点的顶点 $j$ 上。形式化地，所需的力量等于
$$
hp_i + \sum_{\begin{array}{c}\text{顶点 } j \text{ 上的怪物是\textbf{活着的}} \\ \text{且 } i \text{ 是 } j \text{ 的直接父节点} \end{array}} hp_j
$$

此外，Kotori 可以使用一些魔法咒语。如果她使用一个魔法咒语，她可以在没有任何限制的情况下使用 $0$ 力量消灭任何怪物。也就是说，她可以选择一个怪物，即使其直接父节点上的怪物还活着。

对于每一个 $m=0,1,2,\cdots,n$，Kotori 想要分别知道如果她可以使用 $m$ 个魔法咒语，消灭所有怪物所需的最小总力量。

## 说明/提示

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3
5
1 2 3 4
1 2 3 4 5
9
1 2 3 4 3 4 6 6
8 4 9 4 4 5 2 4 1
12
1 2 2 4 5 3 4 3 8 10 11
9 1 3 5 10 10 7 3 7 9 4 9```

### 输出

```
29 16 9 4 1 0
74 47 35 25 15 11 7 3 1 0
145 115 93 73 55 42 32 22 14 8 4 1 0```

# AI分析结果



## 【唯一算法分类】  
树形动态规划（树形DP）

---

## 【题解思路与算法要点】  
### 核心思路  
- **状态设计**：采用三维DP状态 `f[u][j][0/1]` 表示以节点 `u` 为根的子树使用 `j` 次魔法，且 `u` 自身是否被魔法消灭的最小代价。  
  - `0` 表示 `u` 未被魔法消灭，需按顺序消灭（依赖父节点状态）。  
  - `1` 表示 `u` 被魔法消灭，无需依赖父节点。  

### 关键步骤  
1. **初始化**：  
   - `f[u][0][0] = hp[u]`（不使用魔法消灭 `u`，需支付自身HP）。  
   - `f[u][1][1] = 0`（使用魔法消灭 `u`，无代价）。  

2. **状态转移**：  
   - **子节点合并**：遍历每个子节点 `v`，以树形背包方式合并状态。  
   - **父未魔法（0）**：  
     ```  
     f[u][j][0] += min(f[v][k][0] + hp[v], f[v][k][1])  
     ```  
     若子节点 `v` 未魔法消灭（`f[v][k][0]`），需额外支付 `hp[v]`。  
   - **父已魔法（1）**：  
     ```  
     f[u][j][1] += min(f[v][k][0], f[v][k][1])  
     ```  
     子节点状态不影响父节点代价。  

3. **复杂度优化**：  
   - 子树大小剪枝，确保合并时间复杂度为 `O(n²)`。  

---

## 【题解评分】  
1. **_H17_（4.5星）**  
   - **亮点**：状态转移方程推导清晰，代码优化到位。  
   - **代码**：初始化与合并逻辑简洁，利用子树大小剪枝。  

2. **SDLTF_凌亭风（4星）**  
   - **亮点**：动态规划转移方程与代码对应明确，便于理解。  
   - **心得**：提到从贪心转向DP的调试过程，具有启发性。  

3. **WhitD（4星）**  
   - **亮点**：逆向思维（总代价减最大节省），提供不同视角。  
   - **难点**：需理解代价减少量的计算逻辑。  

---

## 【最优思路提炼】  
1. **状态设计**：三维DP状态结合魔法使用次数与节点状态。  
2. **树形背包合并**：按子树大小逐步合并，避免重复计算。  
3. **边界处理**：初始化时明确魔法次数与节点状态的对应关系。  

---

## 【同类问题与相似套路】  
- **树形依赖问题**：如 [P2014 选课](https://www.luogu.com.cn/problem/P2014)，需处理子树资源分配。  
- **魔法/技能次数限制**：如 [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)，结合费用与收益的DP。  

---

## 【推荐练习题】  
1. [P2014 选课](https://www.luogu.com.cn/problem/P2014)  
2. [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)  
3. [P2585 三色二叉树](https://www.luogu.com.cn/problem/P2585)  

---

## 【核心代码实现】  
```cpp
void dfs(int u) {
    siz[u] = 1;
    f[u][0][0] = hp[u];  // 初始化未使用魔法
    f[u][1][1] = 0;       // 初始化使用魔法
    for (int v : G[u]) {
        dfs(v);
        // 树形背包合并
        for (int j = siz[u]; j >= 0; j--) {
            for (int k = 0; k <= siz[v]; k++) {
                // 父未魔法消灭，子可魔法或按顺序
                f[u][j + k][0] = min(f[u][j + k][0], 
                    f[u][j][0] + min(f[v][k][0] + hp[v], f[v][k][1]));
                // 父已魔法消灭，子状态不影响
                f[u][j + k][1] = min(f[u][j + k][1], 
                    f[u][j][1] + min(f[v][k][0], f[v][k][1]));
            }
        }
        siz[u] += siz[v];
    }
}
```

---

## 【可视化与算法演示】  
### 动画设计  
- **树结构展示**：以根节点为中心，展开子树结构。  
- **当前操作高亮**：  
  - **红色**：当前处理的父节点 `u`。  
  - **蓝色**：正在合并的子节点 `v`。  
- **DP状态更新**：动态显示 `f[u][j][0/1]` 数值变化。  

### 复古像素风格  
- **8位音效**：  
  - **合并成功**：播放短促“哔”声。  
  - **魔法使用**：播放“魔法施放”音效。  
- **Canvas动画**：  
  - 每个节点用像素方块表示，魔法次数以数字显示。  
  - 合并时子节点方块向父节点移动，伴随闪光效果。  

---

## 【交互控制】  
- **步进控制**：支持暂停/继续，调整合并速度。  
- **自动演示**：AI模拟最优合并路径，展示关键状态更新。

---
处理用时：76.45秒
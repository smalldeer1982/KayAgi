# 题目信息

# [USACO1.1] 贪婪的送礼者 Greedy Gift Givers

## 题目描述

对于一群 $n$ 个要互送礼物的朋友，GY 要确定每个人送出的钱比收到的多多少。在这一个问题中，每个人都准备了一些钱来送礼物，而这些钱将会被平均分给那些将收到他的礼物的人。  

然而，在任何一群朋友中，有些人将送出较多的礼物(可能是因为有较多的朋友)，有些人有准备了较多的钱。  

给出一群朋友，没有人的名字会长于 $14$ 字符，给出每个人将花在送礼上的钱，和将收到他的礼物的人的列表，请确定每个人收到的比送出的钱多的数目。

## 说明/提示

【数据范围】  
$1\le n \le 10$。

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
5
dave
laura
owen
vick
amr
dave
200 3
laura
owen
vick
owen
500 1
dave
amr
150 2
vick
owen
laura
0 2
amr
vick
vick
0 0
```

### 输出

```
dave 302
laura 66
owen -359
vick 141
amr -150
```

# AI分析结果



### 【算法分类】
无算法分类（纯模拟）

---

### 【题解思路与难点分析】

#### 核心思路
通过模拟送礼过程，记录每个人送出和收到的金额。核心难点在于：
1. **名字映射**：需快速将名字转换为对应金额存储位置
2. **余数处理**：总金额无法整除人数时，剩余金额需返还送礼者
3. **边界处理**：除数为0时需特殊处理

#### 题解对比
| 方法               | 优点                     | 缺点                      |
|--------------------|--------------------------|--------------------------|
| 结构体数组+循环查找 | 直观易理解               | O(n²)查找效率低          |
| map映射            | O(1)查找，代码简洁       | 需理解STL容器使用        |

---

### 【精选题解评分】
1. BlueArc（5星）⭐️⭐️⭐️⭐️⭐️  
   - 使用map实现O(1)查找，代码最简洁  
   - 关键逻辑：`cnt[s] -= num*p` 处理总扣除金额

2. 蒟蒻炒扇贝（4星）⭐️⭐️⭐️⭐️  
   - 详细注释解释map用法  
   - 提醒余数返还的坑点：`money[x] += money%num`

3. w1049（4星）⭐️⭐️⭐️⭐️  
   - 结合vector保持输入顺序  
   - 清晰分离送礼与收礼逻辑：`m[tmp] -= money; m[tmp] += money%num`

---

### 【最优技巧提炼】
1. **STL map映射**：`map<string, int>`实现名字到金额的O(1)访问
2. **余数公式**：实际支出 = (总金额 // 人数) * 人数 → `money - money%num`
3. **输入顺序维护**：用vector单独存储名字列表保证输出顺序

---

### 【同类型题目】
1. P1309 瑞士轮（多轮排序模拟）
2. P1068 分数线划定（数据统计与排序）
3. P1056 排座椅（事件模拟与优先级处理）

---

### 【代码实现】
```cpp
#include <iostream>
#include <map>
#include <vector>
using namespace std;

int main() {
    int n; cin >> n;
    vector<string> names(n);
    map<string, int> balance;
    
    for(int i=0; i<n; ++i) {
        cin >> names[i];
        balance[names[i]] = 0;
    }
    
    for(int i=0; i<n; ++i) {
        string giver;
        int total, num;
        cin >> giver >> total >> num;
        if(num == 0) continue;
        
        int per = total / num;
        balance[giver] -= per * num;
        
        for(int j=0; j<num; ++j) {
            string receiver;
            cin >> receiver;
            balance[receiver] += per;
        }
    }
    
    for(auto& name : names) 
        cout << name << " " << balance[name] << endl;
}
```

---

### 【可视化设计】
**复古像素动画方案**：
1. **人物显示**：  
   - 8-bit风格头像排列，每个头像下显示当前金额
   - 送礼时高亮发送者（红色闪烁），收礼者（绿色闪烁）

2. **金额变化动画**：  
   - 金币图标从发送者飞向接收者，带像素粒子效果
   - 数字变化时播放"coin.wav"音效（8-bit风格）

3. **控制面板**：  
   - 暂停/继续按钮：像素风格按钮  
   - 速度滑块：控制动画速度（1x-5x）

4. **自动演示模式**：  
   - 模拟AI自动执行所有送礼步骤  
   - 完成时播放胜利音效+烟花粒子效果

---

### 【核心算法流程图】
```
开始
│
├─ 读取所有名字 → 存入vector和map
│
├─ 对于每个送礼者：
│   ├─ 读取总金额和人数
│   ├─ 计算每人所得金额
│   ├─ 扣除发送者总金额（扣除 = 每人金额 × 人数）
│   └─ 为每个接收者增加金额
│
└─ 按输入顺序输出最终余额
```

通过这种设计，学习者可直观观察每个送礼事件对整体数据的影响，理解模拟过程的核心逻辑。

---
处理用时：60.19秒
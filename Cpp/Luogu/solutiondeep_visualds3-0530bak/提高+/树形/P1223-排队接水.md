# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



# 排队接水题解分析

## 算法分类
**贪心算法**

---

## 题解思路与难点对比

### 核心算法流程
1. **贪心策略**：将接水时间从小到大排序，使得每个接水者后续的等待人数最少
2. **等待时间计算**：第i个人的接水时间会被(n-i)个人等待
3. **序号处理**：在排序时需同步维护原始序号

### 实现方式对比
| 方法                  | 数据结构         | 时间复杂度 | 实现难点                  |
|-----------------------|------------------|------------|--------------------------|
| 结构体+sort          | 结构体数组       | O(nlogn)   | 需自定义比较函数          |
| 数值编码法            | 数值运算         | O(nlogn)   | 需处理数值编码逻辑        |
| pair容器             | pair<int,int>   | O(nlogn)   | 需理解pair默认排序规则    |
| 双数组交换法          | 两个并行数组     | O(n²)      | 冒泡排序效率较低          |

---

## 高星题解推荐（≥4★）

### 1. f112358（4.5★）
**亮点**：数值编码法巧妙处理序号
```cpp
t[i] = x*1001 + i; // 数值编码
sort(t+1, t+1+n);  // 自动处理排序
cout << t[j]%1001; // 解码序号
```

### 2. Anguei（4.2★）
**亮点**：使用pair容器简化代码
```cpp
pair<int, int> a[n]; // first存时间，second存序号
sort(a, a+n);        // 自动按first排序
```

### 3. BlueArc（4.0★）
**亮点**：结构体排序清晰易懂
```cpp
struct Water {
    int time, num;
};
sort(a+1, a+n+1, cmp); // 自定义比较函数
```

---

## 最优技巧提炼
1. **数值编码法**：将时间乘以足够大的基数后加上序号，实现排序时自动维护原始序号
2. **等待时间公式**：总时间 = Σ(t_i * (n-i))，i为排序后的索引
3. **双关键字处理**：时间相同时按原始序号排序，避免不稳定排序

---

## 同类型题目推荐
1. **P1090** 合并果子（贪心+优先队列）
2. **P1803** 线段覆盖（活动选择问题）
3. **P2240** 部分背包问题（分数背包贪心）

---

## 算法可视化设计
### 核心动画逻辑
```javascript
// 伪代码示例
class Visualization {
    constructor(data) {
        this.people = data.map((t, i) => ({
            id: i+1,
            time: t,
            color: randomColor()
        }));
    }

    async sortStep() {
        for (let i=0; i<n; i++) {
            highlight(i, 'compare'); // 高亮当前比较元素
            await sleep(speed);
            if (this.people[i].time > this.people[j].time) {
                swapWithEffect(i, j); // 带动画效果的交换
                playSound('swap');    // 交换音效
            }
        }
    }

    calcWaitTime() {
        let sum = 0;
        this.people.forEach((p, idx) => {
            highlight(idx, 'active');     // 高亮当前计算项
            sum += p.time * (n - idx - 1);
            updateSumDisplay(sum);        // 实时更新总和
            playSound('calculate', 500); // 计算音效（500Hz）
        });
    }
}
```

### 复古风格实现
1. **像素绘制**：使用8x8像素块表示人员，颜色表示接水时间
   ```javascript
   function drawPerson(ctx, x, y, color) {
       ctx.fillStyle = color;
       ctx.fillRect(x*10, y*10, 8, 8); // 10px间隔的像素块
   }
   ```
2. **音效设计**：
   - 比较时：短促"滴"声（500Hz方波）
   - 交换时：下滑音（800Hz→400Hz）
   - 计算完成：胜利音效（马里奥过关风格）

---

## 关键代码实现
### 数值编码法核心
```cpp
// 编码：将时间放大1001倍后加序号
for(int i=1; i<=n; i++) {
    cin >> x;
    t[i] = x * 1001 + i; // 保证序号不影响排序
}

// 解码：取模得到原始序号
cout << t[j] % 1001;
```

### 等待时间计算优化
```cpp
long long total = 0;
for(int i=0; i<n; i++) {
    total += sorted[i].time * (n - i - 1); // 每个时间被(n-i-1)人等待
}
double avg = total * 1.0 / n; // 避免浮点误差
```

---

## 调试技巧
1. **边界测试**：当所有时间相同时，检查序号是否按原始顺序输出
2. **浮点精度**：使用`double`存储总和，避免`float`精度不足
3. **序号验证**：在排序后打印时间与序号对应关系验证正确性

---

通过将复杂的贪心策略转化为直观的可视化过程，配合复古游戏化元素，学习者可以更直观地理解"短作业优先"的算法本质。实际开发时可使用HTML5 Canvas配合Web Audio API实现完整交互式教学演示。

---
处理用时：71.79秒
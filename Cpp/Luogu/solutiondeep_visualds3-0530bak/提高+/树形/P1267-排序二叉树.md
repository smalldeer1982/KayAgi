# 题目信息

# 排序二叉树

## 题目描述

一个边长为 $n$ 的正三角形可以被划分成 $n^2$ 个小的边长为 $1$ 的正三角形，称为单位三角形。边长为 $3$ 的正三角形被分成三层共 $9$ 个小的正三角形，我们把它们从顶到底，从左到右以 $1\sim 9$ 编号，见下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/mzls92cx.png)

四个这样的边长为 $n$ 的正三角形可以组成一个三棱锥。我们将正三棱锥的三个侧面依顺时针次序（从顶向底视角）编号为 $A,B,C$，底面编号为 $D$。侧面的 $A,B,C$ 号三角形以三棱锥的顶点为顶，底面的 $D$ 号三角形以它与 $A,B$ 三角形的交点为顶。

![](https://cdn.luogu.com.cn/upload/image_hosting/yyqpdocn.png)

其中 $\tt .$ 表示这个三角形面的 $1$ 号三角形位置，并依次编号下去。

上图为三棱锥展开后的平面图，每个面上标有圆点的是该面的顶，该图中侧面 $A,B,C$ 分别向纸内方向折叠即可还原成三棱锥。我们把这 $A,B,C,D$ 四个面各自划分成 $n^2$ 个单位三角形。

对于任意两个单位三角形，如有一条边相邻，则称它们为相邻的单位三角形。显然，每个单位三角形有三个相邻的单位三角形。现在，把 $1\sim 4n^2$ 里的所有整数分别随机填入四个面总共 $4n^2$ 个单位三角形中。

现在要求你编程求由单位三角形组成的最大二叉搜索树。所谓最大二叉搜索树，是指在所有由单位三角形组成的二叉搜索树中节点最多的一棵树。要求当 $i$ 作为二叉搜索树的一个节点时，$i$ 的儿子（如果有的话）和 $i$ 的父亲（如果有的话）必须与 $i$ 有邻边（三棱锥状态下的邻边，而非展开图的邻边）。

一棵二叉搜索树满足这个节点的左子树得每个值全部小于这个节点，这个节点的右子树的每个值全部大于这个节点。

## 说明/提示

### 样例解释

以下以 $A$ 面为例。记 $f(A,x)$ 表示 $A$ 面的第 $x$ 个单位三角形，以此类推。

$f(A,9)$ 与 $f(D,1)$ 有邻边，$f(A,7)$ 与 $f(D,2)$ 有邻边，$f(A,5)$ 与 $f(D,5)$ 有邻边。

$f(A,1)$ 与 $f(B,1)$ 有邻边，$f(A,4)$ 与 $f(B,2)$ 有邻边，$f(A,9)$ 与 $f(B,5)$ 有邻边。

$f(A,1)$ 与 $f(C,1)$ 有邻边，$f(A,2)$ 与 $f(C,4)$ 有邻边，$f(A,5)$ 与 $f(C,9)$ 有邻边。

以数字 $1$ 为二叉搜索树的根，可以得到节点最多的二叉搜索树为：

![](https://cdn.luogu.com.cn/upload/image_hosting/2y8i07id.png)

### 数据范围

对于 $100\%$ 的数据，$1\leqslant n\leqslant 18$，保证四个面所有单位三角形上填入的数互不相同且都取自 $[1,4n^2]$。

## 样例 #1

### 输入

```
3 
19 33 32 31 29 3 5 4 30 
22 25 20 21 12 24 23 34 35 
14 13 15 26 18 17 8 16 27 
11 10 9 1 28 7 2 6 36```

### 输出

```
17

```

# AI分析结果



---

## 算法分类
树形动态规划（记忆化搜索）

---

## 题解思路与核心难点

### 核心算法流程
1. **邻接图建模**：将四个面的三角形邻接关系转化为无向图，每个节点存储三个邻居。
2. **记忆化搜索**：定义状态 `f[u][fa][range]` 表示：
   - `u`：当前节点值
   - `fa`：父节点在邻居列表中的索引（0-2）
   - `range`：当前子树的数值范围边界
3. **状态转移**：
   - 左子树范围 `[low, u-1]`
   - 右子树范围 `[u+1, high]`
   - 遍历非父节点的邻居，递归计算左右子树最大值

### 解决难点
- **空间优化**：将父节点位置压缩为索引，避免存储完整范围对
- **边界处理**：动态计算数值范围，确保子树满足BST性质
- **邻接映射**：正确建立三棱锥折叠后的空间邻接关系

---

## 题解评分（≥4星）

### 1. Gavin·Olivia（★★★★☆）
- **亮点**：状态定义精妙，空间优化显著
- **代码**：记忆化逻辑清晰，建图步骤完整
- **优化**：时间复杂度从O(n⁶)降为O(n⁴)

### 2. fervency（★★★★☆）
- **亮点**：详细注释+建图示例，适合理解几何关系
- **心得**：强调输入格式陷阱，提供调试经验
- **扩展**：给出BST性质分析，辅助理解DP可行性

### 3. Leaper_lyc（★★★★☆）
- **亮点**：完整状态转移方程推导
- **对比**：明确给出不同复杂度算法差异
- **实现**：使用bitset优化邻接查询效率

---

## 最优思路提炼

### 关键技巧
1. **父节点索引压缩**  
   将父节点位置存储为邻接表索引，减少状态维度：
   ```cpp
   while(ne[now][fa] != b) fa++;  // 确定父节点在邻接表中的位置
   ```
   
2. **动态范围计算**  
   根据父节点位置动态推导子树范围：
   ```cpp
   if(a > b) x = b+1, y = a; 
   else x = a, y = b-1;
   ```

3. **剪枝优化**  
   仅处理符合数值范围的邻居：
   ```cpp
   if(i != fa && x <= ne[now][i] && ne[now][i] <= y)
   ```

---

## 相似题目推荐
1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)  
   （区间DP实现最优BST构造）
2. [P1373 小a和uim大逃离](https://www.luogu.com.cn/problem/P1373)  
   （状态压缩+多维DP）
3. [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)  
   （树形DP处理连通子树）

---

## 可视化设计

### 核心动画逻辑
```javascript
class BSTVisualizer {
  constructor(canvas) {
    this.ctx = canvas.getContext('2d');
    this.nodes = new Map(); // 存储节点坐标与状态
  }

  // 绘制节点与边
  drawNode(val, x, y, color='#FF6B6B') {
    this.ctx.fillStyle = color;
    this.ctx.beginPath();
    this.ctx.arc(x, y, 15, 0, Math.PI*2);
    this.ctx.fill();
    this.ctx.fillStyle = 'white';
    this.ctx.fillText(val, x-8, y+5);
  }

  // 动态显示DP过程
  async animateDP(u, fa, range) {
    this.highlight(u, '#4ECDC4'); // 高亮当前节点
    await sleep(500);
    
    for (let neighbor of getNeighbors(u)) {
      if (neighbor === fa) continue;
      
      if (inRange(neighbor, range)) {
        this.drawEdge(u, neighbor, '#FFD93D');
        await this.animateDP(neighbor, ...calcNewRange());
      }
    }
  }
}
```

### 复古风格要素
- **调色板**：16色FC风格（#FF6B6B红, #4ECDC4青, #FFD93D黄）
- **音效**：
  - `select.wav`：节点选中时（8-bit "滴"声）
  - `expand.wav`：子树扩展成功时（上升音阶）
- **像素动画**：使用`ctx.imageSmoothingEnabled = false`保留锯齿感

---

## 代码片段（关键DP逻辑）

```cpp
int dp(int now, int a, int b) {
    int fa = 0;
    while(ne[now][fa] != b) fa++; // 确定父节点位置
    
    if(f[now][fa][a]) return f[now][fa][a]; // 记忆化
    
    int x, y, l = 0, r = 0;
    // 动态计算子树范围
    if(a > b) x = b+1, y = a;
    else x = a, y = b-1;
    
    // 遍历非父邻居
    for(int i=0; i<3; i++) {
        if(i == fa) continue;
        int v = ne[now][i];
        if(v < x || v > y) continue;
        
        if(v < now) 
            l = max(l, dp(v, x, now));
        else 
            r = max(r, dp(v, y, now));
    }
    
    return f[now][fa][a] = l + r + 1;
}
```

---

## 心得摘录
> "建图时误将三角形存储为矩形数组导致RE...意识到每个面的三角形按层存储时，第i层有2i-1个元素，必须使用动态分配或足够大的静态数组。" —— 吴国铨题解中的调试教训

> "发现父节点的范围边界总与当前节点相关，将状态维度从三维压缩到二维，空间骤降100倍！" —— Leaper_lyc的优化心得

---
处理用时：71.26秒
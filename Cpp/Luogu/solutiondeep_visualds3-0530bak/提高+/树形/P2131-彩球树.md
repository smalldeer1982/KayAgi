# 题目信息

# 彩球树

## 题目描述

小Z是一个聪明的小学生，他用塑料管和橡皮泥搭成了一棵树，每个橡皮泥上都连接着一个向下的塑料管，有的连接着两根向上的塑料管，有的则连接着一些彩球。

然而，这个工艺品很快因为不平衡倒了下来。于是，小Z请教了和他在同一个班上的妹子小C。在百科全书上看到天平平衡原理的小C知道，如果任何一块橡皮泥向上连接的两根管子的载重量之差超过一个彩球的重量，工艺品就会不平衡倒下来。由于彩球比较重，橡皮泥和塑料管的重量可以忽略不计。

由于移动彩球需要花时间拆卸和固定，小C希望移动最少次数彩球让这个工艺品平衡起来。你能帮助她吗？


## 说明/提示

【图解】

[PIC=1259]

【数据规模】

对于 15% 的数据，保证输入文件不超过 25 字节。

对于 50% 的数据，保证输入文件不超过 250 字节。

对于 100% 的数据，保证输入文件不超过 5000 字节。

（PS：1字节≈1字符）

【时空限制】

0.1s/128M


## 样例 #1

### 输入

```
((B)())```

### 输出

```
0```

## 样例 #2

### 输入

```
((((B)(B))((B)()))(B))```

### 输出

```
impossible```

## 样例 #3

### 输入

```
(()(((B)(B))(B)))```

### 输出

```
1```

# AI分析结果



## 算法分类
树形递归/深度优先搜索

---

## 综合分析与结论

### 核心思路
题目要求通过最少移动彩球次数使树结构平衡。核心思路为递归处理每个节点，确定其所需彩球数，并根据奇偶性分配左右子树。关键点包括：
1. **递归分配策略**：若当前节点需 `K` 个彩球：
   - **K为偶数**：左右子树各分配 `K/2`
   - **K为奇数**：尝试两种分配（左多1或右多1），取最小调整次数。
2. **叶子节点处理**：仅允许0或1个彩球，调整次数为 `|原值（1）- 目标值|`。
3. **移动次数统计**：每个移动操作涉及两个叶子节点的增减，总次数需除以2。

### 难点与解决
1. **奇偶分配的多解性**：需尝试所有可能的分配方式，并选择可行解中的最小值。
2. **移动次数统计优化**：通过叶子节点的调整次数总和除以2避免重复计算。
3. **输入解析**：利用栈预处理括号匹配，快速分割左右子树区间。

### 可视化设计
- **动画方案**：以树形结构展示递归过程，高亮当前处理的节点及分配策略。
- **颜色标记**：红色表示当前节点，绿色/蓝色表示左右子树，黄色标记不可行路径。
- **音效提示**：成功分配时播放轻快音效，失败路径播放低沉音效。

---

## 题解评分（≥4星）

### 题解一（作者：一只小兔子） ★★★★☆
- **亮点**：递归思路清晰，处理奇偶分配合理，括号匹配预处理高效。
- **不足**：叶子节点调整次数计算存在逻辑错误（返回目标值而非调整量）。
- **优化建议**：修正叶子节点返回值为 `|原值 - 目标值|`。

---

## 最优思路提炼

1. **递归分配策略**：根据奇偶性动态分配左右子树彩球数，确保差值≤1。
2. **叶子节点处理**：直接计算调整次数 `|1 - req|`，避免后续重复统计。
3. **预处理优化**：利用栈快速确定子树区间，减少递归中的字符串解析开销。

---

## 相似题目推荐
1. **LeetCode 110. 平衡二叉树**：判断树是否平衡，递归计算高度差。
2. **洛谷 P1364 医院设置**：树形结构中寻找最优节点，递归统计权重。
3. **LeetCode 337. 打家劫舍 III**：树形动态规划，处理多状态递归。

---

## 代码核心逻辑

```cpp
int search(int l, int r, int req) {
    if (r - l == 1) { // 叶子节点（B）
        if (req < 0 || req > 1) return -1;
        return abs(1 - req); // 修正为调整次数
    }
    int left_l = l + 1, left_r = par[left_l];
    int right_l = par[r - 1], right_r = r - 1;
    int min_steps = INF;
    // 处理偶数分配
    if (req % 2 == 0) {
        int sub = req / 2;
        int left = search(left_l, left_r, sub);
        int right = search(right_l, right_r, sub);
        if (left != -1 && right != -1) min_steps = left + right;
    } else { // 处理奇数分配（两种分法）
        int sub = req / 2;
        // 分法1：左sub，右sub+1
        int left = search(left_l, left_r, sub);
        int right = search(right_l, right_r, sub + 1);
        if (left != -1 && right != -1) min_steps = left + right;
        // 分法2：左sub+1，右sub
        left = search(left_l, left_r, sub + 1);
        right = search(right_l, right_r, sub);
        if (left != -1 && right != -1) 
            min_steps = min(min_steps, left + right);
    }
    return min_steps == INF ? -1 : min_steps;
}
```

---

## 个人心得
调试中发现叶子节点的调整次数统计逻辑易错，需确保递归返回值为实际调整量而非目标值。预处理括号匹配时需注意边界条件，避免空子树处理异常。

---

## 可视化算法演示（伪代码）

```javascript
// 以Canvas绘制树结构，递归时高亮当前节点
function drawTree(node, steps) {
    highlight(node);
    if (isLeaf(node)) {
        showAdjustment(node.original, node.req);
    } else {
        animateSplit(node, leftReq, rightReq);
        drawTree(leftChild, steps + leftSteps);
        drawTree(rightChild, steps + rightSteps);
    }
    playSound(steps > 0 ? 'success' : 'fail');
}
```

---
处理用时：283.34秒
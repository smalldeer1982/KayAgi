# 题目信息

# 集合

## 题目描述

你需要**在线**维护一个自然数的排序集 $S$ 并支持以下操作：

1. 给一个数 $x$，若 $x$ 不在集合 $S$ 中则将 $x$ 添加到集合 $S$ 中；
2. 给一个数 $x$，若 $x$ 已在集合 $S$ 中则将 $x$ 从集合 $S$ 中删除。

为了证明你维护了 $S$，你需要在操作过程中回答以下询问：

3. 求集合 $S$ 中最小元素的值，若 $S=\varnothing$ 则返回 `-1`；
4. 求集合 $S$ 中最大元素的值，若 $S=\varnothing$ 则返回 `-1`；
5. 求集合 $S$ 中元素的数量；
6. 给一个数 $x$，判断 $x$ 是否在集合内，若在则返回 `1` ，若不在则返回 `0` ；
7. 给一个数 $x$，求集合 $T=S\cap[0^-,x)$ 中最大元素的值，若 $T=\varnothing$ 则返回 `-1`；
8. 给一个数 $x$，求集合 $T=S\cap[x,n)$ 中最小元素的值，若 $T=\varnothing$ 则返回 `-1`。

为了证明你**在线地**维护了 $S$，对于所有在第一次询问后的操作 $1,2$ 与询问 $6,7,8$，实际操作和询问的参数 $x$ 为输入中给出的操作和询问的参数 $x'$ 与上一次询问的返回结果 $\text{last}$ 之和。即 $x=x'+\text{last}$。

保证 $0\le x<n$ 。

初始时 $S=\varnothing$。

## 说明/提示

### 样例解释

实际上执行的操作与回答的询问如下：

```plain
1 0
1 1
1 3
1 3
3		->  0
7 0		-> -1
7 1		->  0
8 3		->  3
4		->  3
2 3
4		->  1
6 3		->  0
5		->  2
```

因此输出为 $0+(-1)+0+3+3+1+0+2=8$。

### 数据范围

| 测试点编号 |    $n=$     |    $m=$   | 分值  |
|:--------------:|:------------:|:-----------:|:-------:|
|      $1$       | $2^{20}$ | $2^{14}$ |  $5$  |
|      $2$       | $2^{25}$ | $2^{17}$ |  $5$  |
|      $3$       | $2^{30}$ | $2^{20}$ | $10$ |
|      $4$       | $2^{30}$ | $2^{22}$ | $15$ |
|      $5$       | $2^{30}$ | $2^{22}$ | $15$ |
|      $6$       | $2^{30}$ | $2^{23}$ | $25$ |
|      $7$       | $2^{30}$ | $2^{23}$ | $25$ |

对于 $100\%$ 的数据，满足 $2^{20}\le n\le2^{30},2^{14}\le m\le 2^{23},0\le x<n$。

### 提示

**本题输入量较大，建议使用较快的读入方式。**

$0^-$ 表示略小于 $0$ 的一个值，$[0^-,x)$ 可以保证第 $7$ 个操作的 $T$ 恒有意义。

## 样例 #1

### 输入

```
4 13
1 0
1 1
1 3
1 3
3
7 0
7 2
8 3
4
2 0
4
6 2
5
```

### 输出

```
8
```

# AI分析结果



---

## 算法分类
**权值线段树（六十四叉树）**

---

## 综合分析与结论

### 核心思路
本题需要通过权值线段树实现高效的动态集合维护，核心思路是将值域划分为64叉树结构，每个节点用位掩码记录子节点存在情况。插入/删除操作通过递归更新位掩码，查询操作通过位运算快速定位极值或前驱/后继。

### 解决难点
1. **大值域处理**：对2^30范围的值域分层压缩，每层分64个子区间，通过递归快速定位。
2. **在线参数处理**：每次操作参数x需加上前次查询结果，需维护last变量。
3. **极值查询优化**：通过预处理的lowbit/uppbit函数快速定位最小/最大值所在子树。
4. **前驱后继查询**：通过向上回溯路径和位掩码的位运算，快速找到最近的可行区间。

### 可视化设计
1. **权值线段树结构**：用网格分层展示节点，每个节点显示64位掩码（存在子节点为亮色）。
2. **操作高亮**：
   - 插入/删除时，从叶子到根逐层更新对应位，用颜色闪烁显示变化的位。
   - 查询极值时，用箭头动态追踪从根到叶子的路径。
   - 前驱查询时，显示向上回溯路径，并高亮找到的第一个有效子节点区间。
3. **复古像素风格**：用16色调色板，节点用8x8像素块表示，位掩码用不同颜色像素点展示。

---

## 题解清单

### Daniel13265（★★★★☆）
- **亮点**：理论分析透彻，明确分层时间复杂度和空间复杂度，提出权值线段树替代平衡树的场景。
- **优化**：通过完全ω叉树结构，实现接近常数的操作时间。

### a___（★★★★★）
- **亮点**：代码实现完整，处理位移溢出和预处理的技巧值得借鉴。
- **关键代码**：
  ```cpp
  // 预处理低位和高位查找表
  for(i=1;i<(1<<16);i++){
      lowp[i]=lowp[i>>1]+1;
      if(i&1)lowp[i]=0;
      uppb[i]=uppb[i>>1]+1;
  }
  ```
  - **技巧**：使用`__int128`处理64位以上位移，避免溢出问题。

---

## 最优思路提炼

1. **64叉权值线段树**：将值域分层划分，每个节点用64位掩码记录子节点存在状态。
2. **位运算加速**：
   - `lowbit(x)`：找到最低有效位，用于快速定位最小值。
   - `uppbit(x)`：找到最高有效位，用于定位最大值。
3. **路径回溯法**：查询前驱时，向上回溯直到找到有可用子节点的祖先，再向下搜索极值。
4. **在线参数处理**：维护`last`变量，动态调整后续操作的参数x。

---

## 同类型题推荐

1. **P3369 【模板】普通平衡树**：基础平衡树操作，适合练习前驱/后继查询。
2. **P6136 【模板】普通平衡树（数据加强版）**：高压力测试权值线段树性能。
3. **P3380 【模板】二逼平衡树**：结合区间操作与平衡树功能，扩展权值线段树应用。

---

## 代码核心实现

### 关键函数：查询前驱（findmax）
```cpp
int findmax(int x){
    if(!x||!siz)return -1;
    top=0;getpos(1,0,n-1,x); //记录路径到栈
    for(int i=top;i;i--){ //向上回溯
        if(t[stk[i][0]] & (((__int128)1<<stk[i][1])-1)){ //检查左侧是否有节点
            int q=uppbit(t[stk[i][0]] & (((__int128)1<<stk[i][1])-1));
            return getmax(stk[i][0]<<6|q, ...); //向下找最大值
        }
    }
    return -1;
}
```

### 预处理低位表
```cpp
lowp[0] = uppb[0] = -1;
for(int i=1; i<(1<<16); i++){
    lowp[i] = (i&1) ? 0 : lowp[i>>1]+1; //最低位
    uppb[i] = uppb[i>>1]+1; //最高位
}
```

---

## 可视化与游戏化设计

### 动画方案
- **节点状态**：用64x64网格表示每个节点，绿色像素表示子节点存在。
- **操作演示**：
  - **插入x=3**：从叶子节点向上更新，路径上的节点位掩码逐层亮起。
  - **查询前驱x=5**：红色光标沿路径向上回溯，找到第一个左侧有子节点的祖先后，蓝色箭头向下追踪最大值。

### 复古风格
- **调色板**：4位色，深绿(存在节点)、红色(当前路径)、黄色(操作高亮)。
- **音效**：
  - 插入成功：8-bit上升音阶。
  - 查询无结果：低音“哔”声。

### 自动演示模式
- **AI控制**：按操作顺序自动执行，用户可调整速度（1x/2x/5x）。
- **积分系统**：正确操作+10分，错误操作（如重复插入）-5分。

---

**答案中的算法分类、核心思路及代码实现已提炼完成，可视化方案可帮助直观理解权值线段树的操作流程。**

---
处理用时：70.09秒
# 题目信息

# [YsOI2020] 换寝室

## 题目背景

马上要开学了，Ysuperman 正在为给孩子们分配寝室忙得不可开交......

## 题目描述

幼儿园里面有 $n$ 个房间，这些房间由 $n-1$ 条双向道路连接着，第 $i$ 条道路连接着房间 $u_i$ 和 $v_i$ ，每条道路 Ysuperman 都可以选择开启或者是关闭，每个房间**在所有道路开启的前提下**都可以到达其他任意一个房间。

每个房间有一个差异值，其中，第 $i$ 个房间的差异值为 $h_i$ 。

在选择完关闭哪些道路后，整个寝室会被分成许多连通块，一个联通块内的小朋友的不满意值定义为连通块内差异值的**最大值减去最小值**，小朋友们的总不满意值定义为**所有联通块不满意值的最大值**。

寝室里有 $m$ 个寝室老师，每个老师晚上都要查寝，第 $i$ 个老师会从第 $x_i$ 个房间走到第 $y_i$ 个房间，如果老师在查寝时经过了某条被关闭的道路，TA就会很生气，一个老师的不满意值定义为**从 $x_i$ 走到 $y_i$ 经过的被关闭的道路数量**，老师的总不满意值定义为**所有老师的不满意值之和**。

Ysuperman 能承受的老师的总不满意值最大为 $k$ ，现在TA想知道小朋友们的总不满意值最小可以达到多少。

## 说明/提示

### 样例说明

#### 样例说明 $1$

![](https://cdn.luogu.com.cn/upload/image_hosting/mf6j6hz3.png)

Ysuperman选择关闭连接着 $1$ 和 $5$ 的道路，老师的总不满意值为 $0$，寝室被分为 $2$ 个连通块，小朋友们的总不满意值为 $3$。

#### 样例说明 $2$

图同样例一。

Ysuperman选择关闭连接着 $1$ 和 $5$ 的道路以及连接着 $1$ 和 $4$ 的道路，老师的总不满意值为 $1$，寝室被分为 $3$ 个连通块，小朋友们的总不满意值为 $2$。

------
### 数据范围

**本题采用捆绑测试。**

| Subtask | $n$ | $m$ | $k$ | 特殊性质 | 分数 |
|:-:|:-:|:-:|:-:|:-:|:-:|
| 1 | $\le 20$ | $\le 10$ | $\le 80$ | 无 | 8 |
| 2 | $\le 150$ | $\le 10^3$ | $\le 8 \times 10^4$ | 无 | 13 |
| 3 | $\le 800$ | $\le 10^5$ | $\le 8 \times 10^7$ | 树为一条链 | 13 |
| 4 | $\le 800$ | $\le 10^5$ | $\le 8 \times 10^7$ | 树为一朵盛开的菊花 | 13 |
| 5 | $\le 800$ | $\le 10^5$ | $= 0$ | 无 | 13 |
| 6 | $\le 800$ | $\le 10^5$ | $\le 8 \times 10^7$ | 无 | 40 |

【一条链】定义为：所有点的度数 $\le2$。

【一朵盛开的菊花】定义为：存在一个点的度数为 $n-1$。

对于 $100\%$ 的数据，满足 $1\le h_i\le 10^9，0\le k \le 8\cdot 10^7,u_i\ne v_i$ 。

## 样例 #1

### 输入

```
5 2 0
1 3 1 4 0
1 2
1 3
1 4
1 5
2 3
1 4```

### 输出

```
3```

## 样例 #2

### 输入

```
5 2 1
1 3 1 4 0
1 2
1 3
1 4
1 5
2 3
1 4```

### 输出

```
2```

# AI分析结果



## 算法分类选择  
**树形动态规划（树形DP）+ 二分答案**

---

## 题解思路、算法要点与解决难点  
### 核心思路  
1. **二分答案**：通过二分学生总不满意值（极差最大值），将问题转化为判定性问题。  
2. **树形DP验证**：设计状态 `dp[u][x]`，表示以节点 `u` 为根的子树，所在连通块的最小值对应节点 `x` 时的最小关闭边代价。  
3. **预处理覆盖范围**：对每个节点 `x` 进行DFS，预处理其作为最小值时能覆盖哪些节点（极差不超过当前二分值 `mid`）。  
4. **动态规划转移**：在树形DP中，对每个子节点选择保留边（合并连通块）或关闭边（分割连通块），计算最小代价。

### 解决难点  
1. **边权预处理**：利用树上差分和LCA，统计每条边被老师查寝路径经过的次数，作为关闭该边的代价。  
2. **状态设计优化**：仅记录最小值节点而非同时记录最大/最小值，通过预处理合法范围减少状态数。  
3. **高效转移计算**：通过预处理每个节点的覆盖范围，避免在DP中重复检查极差条件，大幅降低时间复杂度。

---

## 题解评分  
### xiaolilsq（⭐⭐⭐⭐⭐）  
- **亮点**：完整覆盖所有子任务，预处理逻辑清晰，状态转移优化到位。  
- **代码可读性**：结构清晰，注释合理，关键步骤明确。  
- **实践性**：直接解决原问题，无需额外假设。  

### chenxinyang2006（⭐⭐⭐⭐）  
- **亮点**：双指针优化离散化点权，代码简洁高效。  
- **优化点**：通过区间限制减少状态数，但未完全覆盖所有预处理细节。  

### Dtw_（⭐⭐⭐）  
- **思路清晰**：明确二分+DP框架，但代码实现未完全优化，状态转移稍显冗余。  

---

## 最优思路或技巧提炼  
1. **二分答案框架**：将极差最优化问题转化为判定性问题。  
2. **树上差分统计边权**：快速计算每条边被关闭的总代价。  
3. **树形DP状态压缩**：仅记录最小值节点，通过预处理合法范围简化转移。  
4. **覆盖范围预处理**：DFS预处理每个节点作为极值时能覆盖的子树范围，避免DP中重复计算。  

---

## 同类型题或类似算法套路  
- **树形DP + 二分**：如「NOIP2018 赛道修建」中二分最小赛道长度，树形DP统计可行方案。  
- **覆盖范围预处理**：类似「CF1101D GCD Counting」，预处理每个节点可能的GCD范围。  

---

## 推荐相似题目  
1. **P2685 [NOIP2015 提高组] 运输计划**（二分答案 + LCA路径处理）  
2. **P4381 [IOI2008] Island**（树形DP处理基环树极值）  
3. **CF960E Alternating Tree**（树形DP统计路径极值）  

---

## 可视化与算法演示  
### 核心算法流程  
1. **初始化**：以像素风格绘制树结构，节点标记差异值，边标记权重（通过颜色深浅表示被关闭的频率）。  
2. **二分过程**：左侧面板显示当前二分区间 `[low, high]`，右侧显示对应的树结构及连通块划分。  
3. **预处理动画**：  
   - **覆盖范围DFS**：以当前节点为中心，扩散绿色波纹表示其作为最小值时的覆盖范围。  
   - **边权计算**：路径查询时高亮路径边，更新其权值计数器。  
4. **树形DP转移**：  
   - **节点状态**：当前处理节点闪烁，`dp[u][x]` 值以悬浮文字显示。  
   - **子节点选择**：保留边（蓝色连线）或关闭边（红色断线），显示对应代价累加。  

### 复古游戏化设计  
- **8位像素风格**：节点为16x16像素方块，边为单色线段，权值以数字标签显示。  
- **音效触发**：  
  - 扩散波纹时播放“滴”声。  
  - 边关闭时播放“咔嚓”声，找到可行解时播放胜利音效。  
- **自动演示模式**：按帧逐步执行二分和DP，用户可调节速度或单步执行。  

---

## 代码核心实现  
### 预处理边权（树上差分）  
```cpp  
void dfs1(int u, int fa) {
    for (auto v : e[u]) {
        if (v == fa) continue;
        dfs1(v, u);
        vis[u] += vis[v]; // vis为差分数组
    }
    edge_cost[u] = vis[u]; // edge_cost存储边(u, fa)的权值
}
```

### 树形DP核心转移  
```cpp  
void dfs3(int u, int fa) {
    for (int x = 1; x <= n; x++) {
        dp[u][x] = (valid[u][x] ? 0 : INF);
    }
    for (auto v : e[u]) {
        if (v == fa) continue;
        dfs3(v, u);
        ll min_v = INF;
        for (int y = 1; y <= n; y++) {
            min_v = min(min_v, dp[v][y]);
        }
        min_v += edge_cost[v]; // 关闭边(u, v)的代价
        for (int x = 1; x <= n; x++) {
            dp[u][x] += min(min_v, dp[v][x]);
        }
    }
}
```

---

## 总结  
本题通过二分极差最大值，结合树形DP和预处理技术，将复杂的最优化问题转化为可判定的子问题。关键点在于高效处理边权、压缩DP状态及预处理覆盖范围，适合作为树形DP与二分答案结合的经典例题。

---
处理用时：84.51秒
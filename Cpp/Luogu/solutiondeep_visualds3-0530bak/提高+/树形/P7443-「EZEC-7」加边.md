# 题目信息

# 「EZEC-7」加边

## 题目背景

> 暴力怎么做？暴力是不是，加边！加边！加边！然后，并查集查询！

Alice 不喜欢并查集，但是她喜欢加边。

## 题目描述

给定一棵 $n$ 个节点的树，节点从 $1$ 开始编号，$1$ 号节点是根节点，每条边的方向是从父亲到儿子。每个点有一个点权 $a_i$。Alice 和 Bob 在玩游戏，他们在根节点上放了一个棋子，Alice 和 Bob 轮流将棋子沿边移动，谁不能移动谁输。

已知 Alice 是先手或是后手。在游戏开始前，Alice 可以在树上添加一条有向边 $u\to v$（$1\le u,v\le n$），然后和 Bob 在形成的图上玩这个游戏，她希望自己存在必胜策略。**她也可以选择不加边。如果无法决出胜负则不算胜利。**

给定正整数 $A,B$，Alice 添加边 $u\to v$ 的代价是 $A\times a_u+B\times  a_v$。选择不加边的代价为 $0$。

Alice 要最小化她的代价。如果她怎么加边都不满足要求，输出 $-1$。

Alice 会做出 $T$ 次询问，你需要对每个询问输出答案。

## 说明/提示

**【样例解释】**

在第 $1$ 组询问中，Alice 是后手，她无论怎么添加边都无法拥有必胜策略，所以输出 $-1$。  
在第 $2$ 组询问中，Alice 是后手，她不需要添加边就拥有必胜策略，所以代价为 $0$。  
在第 $3$ 组询问中，Alice 是先手，她只能添加一条 $1\to 3$ 的边使自己必胜，此时代价为 $2\times 4+7\times 2=22$。  
在第 $4$ 组询问中，Alice 是后手，她可以添加一条 $9\to 5$ 的边使自己必胜，此时代价为 $523\times 109+182\times 162=86491$。她还有其他使自己必胜的方法，但是可以发现 $86491$ 是最小代价。  

------------


**【数据范围】**

**本题采用捆绑测试。**


- Subtask 1（10 points）：$n\le 10$，$T=1$；
- Subtask 2（15 points）：$\sum n\le 200$；
- Subtask 3（15 points）：$\sum n\le 2000$；
- Subtask 4（10 points）：$f_i=i-1$；
- Subtask 5（10 points）：$f_i=1$；
- Subtask 6（20 points）：$\sum n\le 5\times 10^5$；
- Subtask 7（20 points）：无特殊限制。

对于 $100\%$ 的数据，满足 $1\le T\le 2\times10^3$，$2\le n\le2\times 10^5$，$\sum n\le 5\times 10^6$，$1\le a_i,A,B\le 10^9$，$f_i<i$，$t\in\{0,1\}$。


------------
**【提示】**

请使用较快的输入方式。

## 样例 #1

### 输入

```
4
3 1 2 7
1 1
4 3 2
3 1 2 7
1 2
4 3 2
3 0 2 7
1 2
4 3 2
9 1 523 182
1 1 2 2 2 3 3 1
3 23 18 293 162 483 574 384 109```

### 输出

```
-1
0
22
86491```

# AI分析结果



## 算法分类
博弈论、树形动态规划

---

## 题解思路与算法要点
### 核心思路
1. **胜负判定**：叶子节点必败，非叶子节点若存在必败子节点则为必胜，否则必败。
2. **加边策略**：必败节点 u 添加边到非祖先必败节点 v，使 u 变为必胜态。
3. **最优选择**：遍历维护每个节点 u 的非祖先路径上的最小 v 权值，快速计算最小代价。

### 解决难点
1. **高效维护非祖先节点最小值**：
   - 两次 DFS 遍历（左到右、右到左）维护前缀和后缀最小值。
   - 线性时间处理每个节点的兄弟子节点范围。
2. **避免环的影响**：通过树形结构确保添加的边不形成环。

---

## 最优思路提炼
1. **两次遍历维护极值**：在树的每个节点处，记录其所有子节点的最小值前缀和后缀，快速查询非路径节点。
2. **动态更新路径状态**：通过两次 DFS 遍历，确保每个节点访问时能获取其左右兄弟的最小权值。
3. **贪心选择最优边**：对每个必败节点 u，取全局最小 B*a_v，结合其自身 A*a_u 计算最小代价。

---

## 可视化设计
### 算法演示（核心流程）
1. **树结构绘制**：以根节点为起点，箭头表示父子关系，颜色区分必胜（绿色）和必败（红色）节点。
2. **遍历过程动画**：
   - **第一次遍历**（左到右）：高亮当前节点，计算子节点最小值前缀，用蓝色标记当前维护的最小值。
   - **第二次遍历**（右到左）：同样方式处理后缀最小值，用橙色标记。
3. **最优边选择**：对于必败节点 u，闪烁显示其对应的最小 v 节点，并显示公式 A*a_u + B*a_v。

### 复古游戏化效果
- **像素风格树**：用 8-bit 风格绘制树形结构，节点显示为方块，边为像素线条。
- **音效反馈**：
  - 遍历节点时播放 "beep" 音效。
  - 找到最小 v 时播放 "ding" 音效。
  - 成功解时播放 8-bit 胜利音乐。
- **自动演示模式**：按空格键逐步执行算法，ESC 暂停/继续。

---

## 题解评分（≥4星）
### 作者：Little09（5星）
- **亮点**：线性时间复杂度的两次遍历法，逻辑清晰，代码高效。
- **关键代码**：维护前缀和后缀最小值数组，避免复杂数据结构。

### 作者：0x3F（4.5星）
- **亮点**：通过左右兄弟遍历处理子节点极值，代码结构紧凑。
- **代码片段**：
  ```cpp
  // 维护前缀和后缀最小值
  for (int j = rbro[lson[i]]; j; j = rbro[j]) {
      if (mmxu != INF && mxv[j] != INF) 
          ans = min(ans, a*mmxu + b*mxv[j]);
      mmxu = min(mmxu, mxu[j]);
  }
  ```

### 作者：Macesuted（4星）
- **亮点**：动态规划维护状态转移，思路独特。
- **代码思想**：维护每个节点变为必胜/必败的最小代价，传递极值。

---

## 核心代码实现
### 前缀后缀极值维护
```cpp
void dfs(int x) {
    for (auto& son : tree[x]) {
        dfs(son);
        prefix_min[son] = min(prefix_min[son], min_val);
        min_val = min(min_val, a[son]);
    }
    min_val = INF;
    reverse(tree[x].begin(), tree[x].end());
    for (auto& son : tree[x]) {
        dfs(son);
        suffix_min[son] = min(suffix_min[son], min_val);
        min_val = min(min_val, a[son]);
    }
}
```

---

## 相似题目推荐
1. **P2585 树上博弈**：基于树形结构的胜负判定与策略分析。
2. **P3179 树上游戏**：动态维护子树信息与极值查询。
3. **P2146 砍树游戏**：树形 DP 结合贪心选择最优解。

---

## 个人心得摘录
- **调试教训**：初始未处理返祖边导致死循环，后通过标记路径解决。
- **优化顿悟**：两次遍历替代优先队列，时间复杂度从 O(n log n) 降至 O(n)。

---

## 复古像素动画代码片段
```javascript
// 绘制像素树节点
function drawNode(x, y, state) {
    ctx.fillStyle = state === 'win' ? '#00FF00' : '#FF0000';
    ctx.fillRect(x*20, y*20, 16, 16); // 16x16 像素方块
}

// 播放音效
function playSound(effect) {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(effect === 'select' ? 880 : 440, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

通过上述设计，学习者可在交互式动画中直观理解算法流程，增强记忆与理解。

---
处理用时：84.36秒
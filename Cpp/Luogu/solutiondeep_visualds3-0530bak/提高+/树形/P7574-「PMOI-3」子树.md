# 题目信息

# 「PMOI-3」子树

## 题目背景

分割线下有形式化题面，可以配合食用。

## 题目描述

b6e0 有一棵树，树上第 $i$ 个点有价值 $a_i$。每条边长度为 $1$。

b6e0 会选择一个节点作为根节点。设这个节点为 $r$。然后，b6e0 会圈定一个节点的整个子树作为他的领地，设这个子树的根节点为 $u$。此时，树上的每个节点会给 b6e0 带来一些收益。在领地子树的根节点为 $u$ 的情况下，节点 $x$ 带来的收益 $f(x,u)$ 定义如下：
1. 当 $x$ 在 $u$ 的子树中时，它的收益为它父亲节点的收益加上它本身的价值 $a_x$；
2. 当 $x$ 不在 $u$ 的子树中时，它的收益为：与它相邻的节点中，与 $u$ 距离（到 $u$ 的简单路径长度）比 $x$ 到 $u$ 的距离远的节点，这些节点的收益**对 $998244353$ 取模**的最大值，再乘上 $a_x$。

在根节点为 $r$ 的情况下，定义以 $u$ 为子树的收益 $W(u)$ 为所有节点的 $f$ 值和。

当然，b6e0 有许多种选择根节点的方案。定义选 $r$ 为根节点的收益 $C(r)$ 为对于所有 $u$，以 $u$ 为子树的收益（$W(u)$）的和。对于每一个节点 $r$，求 $C(r)$。

---
形式化题面：

给你一棵有 $n$ 个节点的树，第 $i$ 个节点有点权 $a_i$，每条边的长度为 $1$。当根节点为 $r$ 时：

设 $F(x)$ 表示 $x$ 的父亲节点，特殊地，$F(r)=0$；$D(x,y)$ 表示 $x$ 到 $y$ 的简单路径的长度，特殊地，对于所有 $x$，$D(x,x)=0$；$A_x$ 表示 $x$ 的子树中的节点（包括 $x$ 本身）组成的集合，即 $A_x=\{y\mid D(x,y)=D(F(x),y)-1\}$，特殊地，$A_r=\{1,2,\cdots,n\}$；$B_x$ 表示与 $x$ 相邻的节点组成的集合，即 $B_x=\{y\mid D(x,y)=1\}$。

定义 $f(x,u)$：
$$f(x,u)=\begin{cases}f(F(x),u)+a_x&x\in A_u\\a_x\cdot\max_{y\in B_x,D(y,u)>D(x,u)}\{f(y,u)\bmod 998244353\}&x\not\in A_u\end{cases}$$
特殊地，对于所有 $x$，$f(0,x)=0$；在 $x\not\in A_u$ 的情况中，若对于所有 $y\in B_x$，都有 $D(y,u)\le D(x,u)$，则 $f(x,u)=a_x$。

定义节点 $u$ 的分数 $W(u)=\sum_{v=1}^nf(v,u)$。

定义节点 $r$ 的收益 $C(r)$ 表示以 $r$ 为根时，$\sum_{i=1}^nW(i)$ 的值。

对于每一个节点 $r$，求 $C(r)$。

**所有 $C(r)$ 对 $998244353$ 取模。**

## 说明/提示

【样例解释】

样例中的树如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/bs02n466.png)

例如在 $r=1$，$u=5$ 时，$f(2,u)=a_2=2$，$f(1,u)=a_1\cdot f(2,u)=14$，$f(3,u)=a_3\cdot f(1,u)=70$，$f(6,u)=a_6=5$，$f(4,u)=a_4\cdot\max\{f(3,u),f(6,u)\}=7000$，$f(5,u)=f(4,u)+a_5=7001$。

【数据范围】
- Subtask1（10pts）：$n\le200$，$a_i\le 10^3$；
- Subtask2（20pts）：$n\le10^3$；
- Subtask3（20pts）：树为一条链；
- Subtask4（20pts）：存在一个节点，使得它的度数为 $n-1$；
- Subtask5（30pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le5\times10^5$，$1\le a_i\le10^9$。

## 样例 #1

### 输入

```
6
7 2 5 100 1 5
1 3
3 4
1 2
4 5
4 6```

### 输出

```
67562
29930
75168
76888
63243
63283```

# AI分析结果



---

### **唯一算法分类**
树形动态规划（换根DP）

---

### **综合分析与结论**
本题需计算每个节点作为根时，所有子树的收益总和。核心在于高效预处理子树信息，并利用换根DP避免重复计算。

- **核心思路**：  
  1. **子树内贡献**：通过DFS预处理每个节点的子树大小（`siz`）和路径点权和（`ss`）。  
  2. **子树外贡献**：维护每个节点相邻子树的最大乘积（`sp`），换根时通过前缀/后缀最大值快速转移。  
  3. **换根优化**：利用两次DFS（初始DFS和换根DFS），动态更新根节点的贡献变化，将总复杂度优化至$O(n)$。

- **解决难点**：  
  - **子树外贡献计算**：对每个节点$x \notin A_u$，需快速找到相邻节点中的最大收益。通过维护`sp`（子树外的最大乘积）和动态调整前缀/后缀最大值解决。  
  - **换根状态转移**：根切换时，子树结构变化需重新计算`AS`（所有节点到当前根的路径和）和`SP`，通过递推公式避免重复遍历。

- **可视化设计**：  
  - **动画方案**：以树形结构为基础，高亮当前处理节点，动态显示`sp`、`ss`等变量的更新。  
  - **颜色标记**：子树内节点用绿色填充，子树外用红色边框，当前处理的根节点闪烁显示。  
  - **步进控制**：支持单步执行观察换根过程，展示`sp`的前缀/后缀最大值计算。  
  - **复古风格**：使用8位像素风格绘制树结构，换根时播放“点击”音效，完成计算后播放胜利音效。

---

### **题解清单 (≥4星)**
1. **官方题解（5星）**  
   - **亮点**：通过换根DP将复杂度优化至$O(n)$，关键变量（`sp`, `ss`）设计巧妙，代码逻辑清晰。  
   - **代码可读性**：变量命名规范，注释合理，换根转移逻辑简洁。  
   - **优化程度**：利用前缀/后缀最大值避免重复计算，实现高效换根。

---

### **最优思路或技巧提炼**
1. **换根DP的核心**：预处理子树信息，通过父节点状态推导子节点状态，避免重复遍历。  
2. **前缀/后缀最大值**：在处理相邻子树时，快速计算最大值，确保$O(1)$转移。  
3. **路径和动态更新**：`AS[x]`通过父节点的`AS`递推，公式为`AS[x] = AS[父] - a[父] * siz[x] + a[x] * (n - siz[x])`，避免全树遍历。

---

### **同类型题或类似算法套路**
- **换根DP经典题**：  
  - [LC1245. 树的直径](https://leetcode-cn.com/problems/tree-diameter/)  
  - [CF1092F. Tree with Maximum Cost](https://codeforces.com/contest/1092/problem/F)  
  - [洛谷P3478 [POI2008] STA-Station](https://www.luogu.com.cn/problem/P3478)

---

### **推荐相似题目**
1. **P3478 [POI2008] STA-Station**  
   - 换根DP求重心，类似状态转移。  
2. **CF1187E Tree Painting**  
   - 计算每个节点为根的子树贡献总和。  
3. **P3047 [USACO12FEB] Nearby Cows G**  
   - 树形DP与换根结合，处理多子树信息。

---

### **核心代码实现**
```cpp
void dfs(int x, int f) {
    siz[x] = 1;
    sp[x] = -1;
    for (int v : g[x]) {
        if (v != f) {
            dfs(v, x);
            siz[x] += siz[v];
            ss[x] = (ss[x] + ss[v]) % mod;
            sp[x] = max(sp[x], sp[v]); // 维护子树外最大值
        }
    }
    ss[x] = (ss[x] + siz[x] * a[x]) % mod; // 子树内路径和
    if (sp[x] == -1) sp[x] = a[x];
    else sp[x] = sp[x] * a[x] % mod;
}

void dp1(int x, int f, long long nf, long long ns) {
    uans[x] = (ss[x] + nf * siz[x] + ns) % mod;
    ans[1] = (ans[1] + uans[x]) % mod;
    if (x != 1) as[x] = (as[f] - a[f] * siz[x] + a[x] * (n - siz[x])) % mod;
    // 前缀/后缀最大值处理
    vector<long long> pm, lm;
    for (int v : g[x]) {
        if (v != f) pm.push_back(max(pm.empty() ? 0 : pm.back(), sp[v]));
    }
    for (auto it = g[x].rbegin(); it != g[x].rend(); ++it) {
        if (*it != f) lm.push_back(max(lm.empty() ? 0 : lm.back(), sp[*it]));
    }
    // 递归处理子节点
    int pt = 0;
    for (int v : g[x]) {
        if (v != f) {
            long long new_nf = max({nf, 1LL, pm[pt], lm[lm.size()-pt-1]}) * a[x] % mod;
            dp1(v, x, new_nf, (ns + ss[x] - ss[v] - sp[x] + new_nf) % mod);
            pt++;
        }
    }
}
```

---

### **可视化与算法演示**
- **动画方案**：  
  1. **树形结构绘制**：用Canvas绘制树，节点以圆形表示，边带长度标记。  
  2. **换根过程**：点击节点切换根，动态显示`sp`和`AS`的更新，高亮变化的子树。  
  3. **音效反馈**：计算完成时播放8-bit胜利音效，换根时播放“切换”音效。  
- **复古风格**：  
  - **调色板**：16色，节点用绿/红区分子树内外。  
  - **音效**：Web Audio API生成方波音效，换根时触发短促“哔”声。  

---

### **个人心得摘录**
- **调试教训**：初始未处理`sp[x]`为-1的情况，导致部分叶子节点计算错误。  
- **优化顿悟**：前缀/后缀最大值避免了对所有兄弟节点的遍历，极大提升效率。

---
处理用时：73.18秒
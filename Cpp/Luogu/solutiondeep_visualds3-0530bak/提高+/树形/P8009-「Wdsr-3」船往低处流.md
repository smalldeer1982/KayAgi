# 题目信息

# 「Wdsr-3」船往低处流

## 题目背景

村纱水密是控制着圣辇船的船长。因为是一生和船相伴的船幽灵，因此对船只非常感兴趣。正因为这样的爱好，村纱有一大堆船模。

由于间歇泉的喷发，间歇泉的周围出现了一个汇聚了多方水流的大水坑。不同的水流交错，形成了大大小小的水道。只需要把船模放在某个位置，它就会顺着水流流动。根据物理原理，船自然会从高处流向低处。由于水坑由四处的水汇集而成，因此水坑的中央地势最低；随着到中央距离的增加，地势不断增加。

村纱发现，当她选定了两个位置放下船模后，它们会在某个水流的交汇处发生碰撞。村纱关心碰撞发生的位置。容易发现，第一个可能会产生碰撞的位置，就是在树形结构上这两个选定的点的最近公共祖先。

当然了，由于间歇泉并不稳定，因此水池中央的位置可能会不断变化，地势也不断变化，但是水道并不会发生任何改变。村纱给每个交汇处标上了一个数值「危险程度」，表示两个船模在此处碰撞可能会发生的危险的大小。村纱放置船模的位置也是随机的。

不过由于水坑实在是太大，水坑中央又不断变化，因此只关心船模的村纱被绕晕了。她迫切地想知道在水坑处玩船模产生的威胁，因此希望你帮她计算。

## 题目描述

这些水道形成了一棵以 $1$ 为根的节点数为 $n$ 的树形结构 $T$。每个节点上有一个点权 $w_i$，表示它的危险程度。现做出如下定义：

- **最近公共祖先**：在一棵以 $r$ 为根的有根树上，两个节点 $u,v$ 的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个，记作 $\operatorname{lca}(r,u,v)$。
- **子树**：树 $T$ 上，删掉节点 $u$ 与父亲相连的边后，该结点所在的子图记为子树 $T_u$。特别地，$T$ 本身可以认为是以 $1$ 为根节点的子树 $T_1$。
- **危险值**：对于 $T_u$ 而言，它的危险值被定义为：

$$\mathrm{LCAS}(u)=\sum_{i\in T_u}\sum_{j\in T_u}\sum_{k\in T_u,k<j} w_{\operatorname{lca}(i,j,k)}$$

现在给出 $T$，希望你对于 $i=1,2,\cdots n$，求出 $\mathrm{LCAS}(i)$。

## 说明/提示



#### 样例 1 解释

样例一当中的树如下。红色的是节点，蓝色的是点权。

![](https://cdn.luogu.com.cn/upload/image_hosting/f7gvtsp5.png)

容易发现 $\mathrm{LCAS}(2)=\mathrm{LCAS}(4)=\mathrm{LCAS}(5)=0$。这里说明如何计算 $\mathrm{LCAS}(1)$ 和 $\mathrm{LCAS}(3)$。首先说明 $\mathrm{LCAS}(3)$：

- 以 $3$ 为根，那么有 $\mathrm{lca}(3,3,4)=\mathrm{lca}(3,3,5)=\mathrm{lca}(3,4,5)=3$，这部分的贡献是 $3\times w_3=6$。  
- 以 $4$ 为根，那么有 $\mathrm{lca}(4,3,4)=\mathrm{lca}(4,4,5)=4,\mathrm{lca}(4,3,5)=3$，这部分的贡献是 $2\times w_4+1\times w_3=4$。  
- 以 $5$ 为根，那么有 $\mathrm{lca}(5,3,5)=\mathrm{lca}(5,4,5)=5,\mathrm{lca}(5,3,4)=3$，这部分的贡献是 $2\times w_5+1\times w_3=8$。

因此，$\mathrm{LCAS}(3)=6+4+8=18$。下面计算 $\mathrm{LCAS}(1)$。

$$
\def\arraystretch{1.2}
\begin{matrix}
\textbf{以 1 为根 }\bm{\mathbf{lca}(1,i,j)} & \textbf{以 2 为根 }\bm{\mathbf{lca}(2,i,j)}\cr
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 1 & 1 & - & - &- \cr\hline
4 & 1 & 1 & 3 & - &- \cr\hline
5 & 1 & 1 & 3 & 3 &- \cr\hline
\end{array} &
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 2 & - & - & - &- \cr\hline
3 & 1 & 2 & - & - &- \cr\hline
4 & 1 & 2 & 3 & - &- \cr\hline
5 & 1 & 2 & 3 & 3 &- \cr\hline
\end{array} \cr[50pt]
\textbf{以 3 为根 }\bm{\mathbf{lca}(3,i,j)} & \textbf{以 4 为根 }\bm{\mathbf{lca}(4,i,j)}\cr
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 3 & 3 & - & - &- \cr\hline
4 & 3 & 3 & 3 & - &- \cr\hline
5 & 3 & 3 & 3 & 3 &- \cr\hline
\end{array} &
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 3 & 3 & - & - &- \cr\hline
4 & 4 & 4 & 4 & - &- \cr\hline
5 & 3 & 3 & 3 & 4 &- \cr\hline
\end{array}
\end{matrix}\\[10pt]
\textbf{以 5 为根 }\bm{\mathbf{lca}(5,i,j)}\\
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 3 & 3 & - & - &- \cr\hline
4 & 3 & 3 & 3 & - &- \cr\hline
5 & 5 & 5 & 5 & 5 &- \cr\hline
\end{array}
$$

容易发现，在上图中，$1$ 出现了 $13$ 次，$2$ 出现了 $4$ 次，$3$ 出现了 $25$ 次，$4$ 出现了 $4$ 次，$5$ 出现了 $4$ 次。因此，$\mathrm{LCAS}(1)=3\times 13+1\times 4+2\times 25+1\times 4+3\times 4=109$。

#### 样例 2 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/uwm8c9bk.png)

我有一个精妙绝伦的方法解释样例 $2$，可惜这里空白太小写不下。

**本题输入量较大。请采用较快的读入方式。**

#### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值}\cr\hline
1 & 100 & - & 20 \cr\hline
2 & 10^3 & - & 25 \cr\hline
3 & 10^5 & \text{A} & 10\cr\hline
4 & 10^5 & \text{B} & 10\cr\hline
5 & 10^6 & - & 35\cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证第 $i$ 条边为 $u=i$，$v=i+1$。  
**特殊性质** $\textbf{B}$：保证第 $i$ 条边为 $u=1$，$v=i+1$。

对于全部数据，保证 $1\le n\le 10^6$，$0\le w_i<998,244,353$。

## 样例 #1

### 输入

```
5
3 1 2 1 3
1 2
1 3
3 4
3 5
```

### 输出

```
109
0
18
0
0```

## 样例 #2

### 输入

```
10
1 1 4 5 1 4 1 9 1 9
1 2
1 3
1 4
2 5
2 6
5 7
3 8
3 9
9 10```

### 输出

```
972
33
99
0
2
0
0
0
10
0```

# AI分析结果



1. **算法分类**  
树形动态规划（Tree DP）

---

### **题解思路与核心难点**

**题目核心**：计算每个子树中所有三元组 (i,j,k) 的 LCA 点权总和，利用树形结构高效递推。

**题解对比与核心思路**：
- **暴力解法（Subtask 1）**：直接枚举所有三元组并计算 LCA，复杂度 O(n⁵)，仅适用于极小规模。
- **换根 DP（Subtask 2）**：通过预处理根的 LCA 贡献，换根时动态调整相邻节点的贡献，复杂度 O(n²)。
- **树形 DP（Subtask 5）**：定义三个状态 `LCAS0`, `LCAS1`, `LCAS2`，递归合并子树贡献，复杂度 O(n)。

**关键难点与突破**：
- **状态定义**：将原问题拆分为三个状态，分别处理不同情况下的 LCA 贡献。
- **合并公式**：推导子树合并时的状态转移方程，避免重复计算。
- **数学变换**：通过去除顺序约束简化问题，转化为对称求和形式。

**核心算法流程**：
1. **定义状态**：
   - `LCAS0(u)`：以 u 为根的子树中所有三元组 (i,j,k) 的 LCA 权值和。
   - `LCAS1(u)`：以 u 为根时，所有二元组 (i,j) 的 LCA 权值和。
   - `T(u)`：子树 u 的权值总和。
2. **递归合并**：
   - 遍历子节点 v，计算其子树的状态。
   - 合并 v 的贡献到 u 的状态，使用预推导的公式更新 `LCAS0(u)` 和 `LCAS1(u)`。
3. **最终计算**：通过 `LCAS0` 转换为题目要求的 `LCAS(u)`。

---

### **最优思路提炼**

1. **状态压缩**：通过对称性将三元组转化为对称求和，消除顺序约束。
2. **分治合并**：子树独立计算后合并，利用树形结构自底向上递推。
3. **数学优化**：推导出合并公式，将复杂度从 O(n³) 降为 O(n)。

---

### **参考代码核心片段**

```cpp
void dfs(int u, int f) {
    S0[u] = S1[u] = T[u] = W[u];  // 初始化状态
    S[u] = 1;
    for (int i = H[u], v; i; i = N[i]) {
        if ((v = V[i]) == f) continue;
        dfs(v, u);
        // 合并子树v的贡献到u
        int s0 = (1LL * S0[u] + 3LL * S[v] * S1[u] % MOD 
                + 1LL * S0[v] + 3LL * S[u] * S1[v] % MOD) % MOD;
        int s1 = (1LL * S1[u] + S1[v] + 2LL * W[u] * S[u] % MOD * S[v] % MOD) % MOD;
        S0[u] = s0;
        S1[u] = s1;
        S[u] += S[v];  // 更新子树大小
        T[u] = (T[u] + T[v]) % MOD;  // 累加权值总和
    }
    // 转换为最终答案
    A[u] = 1LL * (S0[u] - 1LL * S[u] * T[u] % MOD + MOD) * DIV2 % MOD;
}
```

---

### **可视化设计**

**动画方案**：
1. **树形结构展示**：以可折叠树状图显示当前处理节点 u 及其子树。
2. **状态高亮**：
   - 当前处理节点 u 标记为红色。
   - 正在合并的子节点 v 标记为黄色。
   - 状态变量 `S0`, `S1`, `T` 实时显示在节点旁。
3. **合并过程演示**：用流动箭头表示数据从子节点 v 传递到父节点 u，伴随公式逐步显示计算过程。

**复古像素风格**：
- **颜色方案**：8-bit 风格，红色（当前节点）、绿色（已处理）、蓝色（未处理）。
- **音效设计**：
  - 节点展开时播放 "blip" 音效。
  - 状态更新时播放 "click" 音效。
  - 完成计算时播放 8-bit 胜利音效。

**交互功能**：
- **步进控制**：空格键单步执行合并操作。
- **速度调节**：方向键控制动画速度。
- **自动演示**：AI 模式自动遍历整棵树，展示完整计算流程。

---

### **相似题目推荐**

1. **P3384 【模板】轻重链剖分** - 树形结构处理基础
2. **P1352 没有上司的舞会** - 树形DP经典问题
3. **P2015 二叉苹果树** - 树形DP+子树合并

---

**总结**：本题通过巧妙的树形DP状态定义，将复杂的三元组LCA求和问题转化为线性复杂度解法，核心在于分治合并与数学优化。可视化设计可突出状态转移过程，帮助理解递推逻辑。

---
处理用时：70.92秒
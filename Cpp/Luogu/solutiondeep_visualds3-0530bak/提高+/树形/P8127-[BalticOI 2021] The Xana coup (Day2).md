# 题目信息

# [BalticOI 2021] The Xana coup (Day2)

## 题目描述

给定一棵点数为 $N$ 个树，第 $i$ 个点有点权 $a_i$，$a_i \in \{0,1\}$。

你可以进行切换操作：

- 对点 $i$ 进行切换操作会使得点 $i$ 及与其 **直接相连** 的点的点权取反。

其中直接相连指两点之间恰好只有一条边。

求至少需要多少次切换操作才能使得所有点的点权变为 $0$。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/qyej3711.png)

$a_i=0$ 为黑色，$a_i=1$ 为白色。

可以对点 $4,5,3,1$ 进行切换操作使得所有点的点权为 $0$。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（5 pts）：$N \le 20$。
- Subtask 2（15 pts）：$N \le 40$。
- Subtask 3（10 pts）：如果点 $u$ 和点 $v$ 满足 $|u-v|=1$，那么他们有边相连。
- Subtask 4（40 pts）：一个点最多与 $3$ 个点相连。
- Subtask 5（30 pts）：无特殊限制。

对于 $100\%$ 的数据，$3 \le N \le 10^5$。

#### 说明

翻译自 [BalticOI 2021 Day2 C The Xana coup](https://boi.cses.fi/files/boi2021_day2.pdf)。

## 样例 #1

### 输入

```
5
1 2
1 3
2 4
2 5
0 1 0 1 1```

### 输出

```
4```

## 样例 #2

### 输入

```
5
1 2
2 3
3 4
4 5
0 1 1 1 1```

### 输出

```
impossible```

# AI分析结果



**唯一算法分类**  
树形动态规划（树形DP）

---

### **题解思路、算法要点与解决难点**  
**核心思路**：  
每个节点的翻转会影响其父节点、自身和子节点。需通过树形DP确定每个节点是否被操作，并确保最终所有节点为0。  

**关键难点**：  
1. **状态奇偶性**：操作次数奇偶性影响节点权值变化。  
2. **父子依赖**：子节点操作会影响父节点状态，需自底向上合并状态。  
3. **状态转移方程**：需处理当前节点是否操作与子节点状态的组合情况。  

**算法共性**：  
- **状态定义**：多数题解将状态分为「当前权值」和「是否操作」的组合（如 `f[u][x][y]`）。  
- **奇偶性处理**：通过辅助数组（如 `g` 和 `h`）记录子节点操作次数的奇偶性对父节点的影响。  
- **滚动数组优化**：合并子节点状态时使用滚动数组降低空间复杂度。  

---

### **题解评分 (≥4星)**  
1. **quanjun（5星）**  
   - **亮点**：状态定义清晰，推导详细，代码可读性高。  
   - **核心代码**：通过 `g` 和 `h` 数组记录子节点奇偶性，逻辑严谨。  
   ```c++
   // 合并子节点状态
   g[i][0] = min(g[i-1][0] + f[v][0], g[i-1][1] + f[v][2]);
   h[i][0] = min(h[i-1][0] + f[v][1], h[i-1][1] + f[v][3]);
   ```

2. **2018ty43（4星）**  
   - **亮点**：状态设计简洁，转移方程明确。  
   - **核心代码**：通过 `f[u][x][y]` 表示父节点影响和操作次数。  
   ```c++
   f[u][0,0] = min(f[u][0,0] + f[v][0,a_v], f[u][0,1] + f[v][1,a_v]);
   ```

3. **船酱魔王（4星）**  
   - **亮点**：利用滚动数组优化空间，代码高效。  
   - **核心代码**：动态更新 `rol` 数组处理奇偶性。  
   ```c++
   rol[fg][0] = min(rol[fg^1][1] + dp[v][0][1], rol[fg^1][0] + dp[v][0][0]);
   ```

---

### **最优思路或技巧提炼**  
1. **状态压缩**：将「是否操作」和「当前权值」合并为2×2的状态，减少冗余。  
2. **奇偶性合并**：通过滚动数组记录子节点操作次数的奇偶性，避免重复计算。  
3. **逆向思维**：从叶子节点向上递推，确保子树状态合法后再处理父节点。  

---

### **同类型题与算法套路**  
- **类似题目**：  
  - P1352 没有上司的舞会（树形DP状态合并）  
  - P2585 三色二叉树（多状态树形DP）  
  - P2899 Cell Phone Network（最小覆盖树形DP）  

---

### **可视化与算法演示**  
**动画设计**：  
1. **树形结构展示**：用节点颜色表示当前权值（0: 黑色，1: 白色）。  
2. **状态高亮**：当前处理的节点以红色边框标记，子节点状态用不同颜色区分。  
3. **操作模拟**：点击节点触发翻转，动态显示权值变化和操作次数更新。  
4. **奇偶性提示**：子节点操作次数奇偶性用数字标签显示，影响父节点时闪烁提示。  

**复古像素风格**：  
- **颜色方案**：8-bit 风格调色板（如黑色、白色、红色高亮）。  
- **音效设计**：  
  - 翻转操作时播放“哔”声。  
  - 合法状态达成时播放“胜利”音效。  
  - 无解时播放“失败”音效。  

---

### **核心代码片段**  
```c++
// quanjun 的 DP 状态合并
void dfs(int u, int p) {
    if (u 是叶子节点) { ... }
    vector<int> tmp; // 存储子节点
    for (auto v : e[u]) if (v != p) dfs(v, u), tmp.push_back(v);
    int m = tmp.size();
    // 初始化 g 和 h 数组
    g[0][0] = h[0][0] = 0;
    for (int i = 1; i <= m; i++) {
        int v = tmp[i-1];
        // 合并子节点状态
        g[i][0] = min(g[i-1][0] + f[v][0], g[i-1][1] + f[v][2]);
        h[i][0] = min(h[i-1][0] + f[v][1], h[i-1][1] + f[v][3]);
    }
    // 根据当前节点权值更新 f[u][*]
    if (a[u] == 1) {
        f[u][0] = g[m][1]; // 需要奇数个子节点操作
        f[u][2] = 1 + h[m][0]; // 操作后子节点需为1且偶数次
    }
}
```

---

### **总结**  
树形DP的关键在于状态定义和奇偶性处理，各题解通过不同方式实现状态合并，但核心思想一致。推荐结合动画演示理解状态转移过程，并通过类似题目巩固树形DP的应用。

---
处理用时：86.23秒
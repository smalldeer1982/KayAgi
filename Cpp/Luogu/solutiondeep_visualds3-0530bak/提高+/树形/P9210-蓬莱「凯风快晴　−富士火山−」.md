# 题目信息

# 蓬莱「凯风快晴　−富士火山−」

## 题目背景

富士山，被当地人称为「神山」。这是一座休眠火山，最近一次喷发在 $300$ 年前。

向这样的山中投入不死之药，想必会直接喷发吧。如此便理解为什么月岩笠最终抗命。

## 题目描述

所谓的山，是一种上细下粗的结构。能不能在「树」里也找到这样的结构呢？

给定一个以 $1$ 为根的大小为 $n$ 的有根树 $T$。你需要找到满足宽度单调不减的**导出子树**中最大的一棵：

- 记该导出子树为 $T_0$，共有 $k$ 层。
- 记 $T_0$ 的根节点的深度为 $1$，计算出 $T_0$ 中每个结点的深度 $d_i$。由此定义 $T_0$ 第 $i$ 层的宽度 $w_i$ 为「所有深度为 $i$ 的节点的个数」。
- 你需要使得 $w_i$ 单调不减。即，$w_1\le w_2\le \cdots \le w_k$。

记原树的点集和边集分别为 $V,E$。导出子树是原树的一个**连通块**，它的点集 $V_0\subseteq V$，边集 $E_0$ 是 $E$ 当中所有端点均在 $V_0$ 内的边。导出子树的根，是组成它的所有节点中**在原树内深度最浅的那一个**。$T$ 也可以被认为是自身的一棵导出子树。

![](https://cdn.luogu.com.cn/upload/image_hosting/wcbeo1a0.png)

如图所示，绿色的区域和橙色的区域分别是原树的导出子树。它们的根分别为 $2$ 和 $13$。

**注意**：导出子树的定义略微不同于子树的定义。请不要将两者混淆。

请找到最大的符合条件的导出子树的大小。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/pzq47a3e.png)

如图所示，标灰的节点是两个样例中选出来的导出子树。

- 样例 $1$ 找到的导出子树，每一层的宽度分别为 $\{1,2,3,3\}$。
- 样例 $2$ 找到的导出子树，每一层的宽度分别为 $\{1,2,4,4,5\}$。
### 数据范围及约定

对于全部数据，$1\le n\le 5\times 10^5$。

## 样例 #1

### 输入

```
10
1 2
2 3
3 4
3 5
2 6
6 7
1 8
8 9
8 10```

### 输出

```
9```

## 样例 #2

### 输入

```
17
1 2
2 3
3 4
4 5
4 6
3 7
7 8
7 9
7 10
2 11
2 12
1 13
13 14
14 15
14 16
13 17```

### 输出

```
16```

# AI分析结果



## 算法分类
**单调栈**

---

## 题解思路与核心分析
### 核心思路
题目要求找到满足宽度单调不减的最大导出子树。通过分析得出最优解必包含根节点，因此以根为起点统计每层节点数。关键思路是将各层节点数视为数组，维护单调递增序列以保证宽度合法，使用单调栈快速计算最大可能总和。

### 解决难点
1. **宽度单调性**：导出子树的每一层宽度必须不小于上一层的。通过单调栈维护节点数的递增关系，确保每次处理时上层宽度合法。
2. **高效计算**：传统暴力枚举层数的时间复杂度为 O(n²)，单调栈优化至 O(n)，每个层仅入栈、出栈一次。

### 算法流程
1. **DFS统计每层节点数**：遍历树记录各层节点数。
2. **单调栈处理**：
   - 按层顺序处理，维护递增栈。
   - 弹出栈顶直到当前层节点数不小于栈顶，累计贡献。
   - 压入当前层，更新最大总和。

---

## 题解评分（≥4星）
1. **Daniel_yao（★★★★★）**  
   - 思路清晰，代码简洁高效。正确应用单调栈，关键变量命名合理，逻辑直观。

2. **elbissoPtImaerD（★★★★☆）**  
   - 详细解释单调栈维护过程，代码逻辑清晰。栈中记录起始位置，优化计算方式。

3. **ダ月（★★★★☆）**  
   - 代码简洁，正确性高。直接处理层节点数，维护栈结构，逻辑简明。

---

## 最优思路与技巧
- **关键技巧**：单调栈维护递增的层节点数，快速计算连续合法区间的总和。
- **思维突破**：逆向处理层数，利用栈快速回溯合法区间。
- **优化点**：将层数处理转化为单调栈问题，避免重复计算。

---

## 相似题目与套路
- **类似题目**：直方图最大矩形（维护单调递增栈计算最大面积）。
- **通用解法**：处理序列中寻找最长合法子数组，利用单调数据结构优化。

---

## 推荐题目
1. **P1886 滑动窗口**（单调队列应用）
2. **P2559 [AHOI2017] 房屋**（单调栈处理直方图）
3. **P4147 玉蟾宫**（二维单调栈变种）

---

## 个人心得摘录
- **反证法**：最优解必包含根节点，否则可扩展至根节点获得更优解。
- **调试经验**：注意层数统计时根节点深度初始化为1，避免偏移错误。

---

## 可视化设计
### 动画方案
**像素风格层数统计与单调栈处理**
1. **树遍历动画**：  
   - 8位像素风格，根节点为红色，子节点渐变色。  
   - DFS时高亮当前节点，对应层柱状图增长。

2. **单调栈处理动画**：  
   - 横向柱状图表示各层节点数，当前层高亮为黄色。  
   - 栈结构右侧显示，元素用不同颜色块表示（如蓝色为合法层）。  
   - 弹出栈顶时触发“失败”音效，压入时播放“成功”音效。

3. **总和更新**：  
   - 最大数值动态显示在顶部，字体为复古像素风格。

### 交互设计
- **控制面板**：步进/暂停按钮，速度滑块（1x-5x）。  
- **音效**：8位音效库，背景音乐循环播放。

### 关键代码片段（伪代码）
```javascript
// 单调栈处理动画核心逻辑
function processLayers() {
    let stack = [];
    let maxSum = 0;
    layers.forEach((count, i) => {
        let sum = 0;
        while (stack.length && stack.top().count >= count) {
            let popped = stack.pop();
            sum += popped.size;
            maxSum -= popped.count * popped.size;
        }
        stack.push({ count, size: sum + 1 });
        maxSum += count * (sum + 1);
        updateCanvas(stack, maxSum); // 更新Canvas绘制
        playSound('pop'); // 触发音效
    });
}
```

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10;

vector<int> G[N];
int dep[N], w[N], mx, ans;

void dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;
    w[dep[u]]++;
    mx = max(mx, dep[u]);
    for (int v : G[u]) {
        if (v != fa) dfs(v, fa);
    }
}

int main() {
    int n; cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v; cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs(1, 0);
    stack<int> stk;
    for (int i = 1; i <= mx; i++) {
        while (!stk.empty() && w[stk.top()] >= w[i]) {
            stk.pop();
        }
        stk.push(i);
        int sum = (stk.size() == 1) ? 0 : stk.top() - stk.bottom();
        ans = max(ans, sum * w[i]);
    }
    cout << ans << endl;
    return 0;
}
```

---
处理用时：74.28秒
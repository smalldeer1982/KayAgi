# 题目信息

# 排序二叉树

## 题目描述

一个边长为 $n$ 的正三角形可以被划分成 $n^2$ 个小的边长为 $1$ 的正三角形，称为单位三角形。边长为 $3$ 的正三角形被分成三层共 $9$ 个小的正三角形，我们把它们从顶到底，从左到右以 $1\sim 9$ 编号，见下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/mzls92cx.png)

四个这样的边长为 $n$ 的正三角形可以组成一个三棱锥。我们将正三棱锥的三个侧面依顺时针次序（从顶向底视角）编号为 $A,B,C$，底面编号为 $D$。侧面的 $A,B,C$ 号三角形以三棱锥的顶点为顶，底面的 $D$ 号三角形以它与 $A,B$ 三角形的交点为顶。

![](https://cdn.luogu.com.cn/upload/image_hosting/yyqpdocn.png)

其中 $\tt .$ 表示这个三角形面的 $1$ 号三角形位置，并依次编号下去。

上图为三棱锥展开后的平面图，每个面上标有圆点的是该面的顶，该图中侧面 $A,B,C$ 分别向纸内方向折叠即可还原成三棱锥。我们把这 $A,B,C,D$ 四个面各自划分成 $n^2$ 个单位三角形。

对于任意两个单位三角形，如有一条边相邻，则称它们为相邻的单位三角形。显然，每个单位三角形有三个相邻的单位三角形。现在，把 $1\sim 4n^2$ 里的所有整数分别随机填入四个面总共 $4n^2$ 个单位三角形中。

现在要求你编程求由单位三角形组成的最大二叉搜索树。所谓最大二叉搜索树，是指在所有由单位三角形组成的二叉搜索树中节点最多的一棵树。要求当 $i$ 作为二叉搜索树的一个节点时，$i$ 的儿子（如果有的话）和 $i$ 的父亲（如果有的话）必须与 $i$ 有邻边（三棱锥状态下的邻边，而非展开图的邻边）。

一棵二叉搜索树满足这个节点的左子树得每个值全部小于这个节点，这个节点的右子树的每个值全部大于这个节点。

## 说明/提示

### 样例解释

以下以 $A$ 面为例。记 $f(A,x)$ 表示 $A$ 面的第 $x$ 个单位三角形，以此类推。

$f(A,9)$ 与 $f(D,1)$ 有邻边，$f(A,7)$ 与 $f(D,2)$ 有邻边，$f(A,5)$ 与 $f(D,5)$ 有邻边。

$f(A,1)$ 与 $f(B,1)$ 有邻边，$f(A,4)$ 与 $f(B,2)$ 有邻边，$f(A,9)$ 与 $f(B,5)$ 有邻边。

$f(A,1)$ 与 $f(C,1)$ 有邻边，$f(A,2)$ 与 $f(C,4)$ 有邻边，$f(A,5)$ 与 $f(C,9)$ 有邻边。

以数字 $1$ 为二叉搜索树的根，可以得到节点最多的二叉搜索树为：

![](https://cdn.luogu.com.cn/upload/image_hosting/2y8i07id.png)

### 数据范围

对于 $100\%$ 的数据，$1\leqslant n\leqslant 18$，保证四个面所有单位三角形上填入的数互不相同且都取自 $[1,4n^2]$。

## 样例 #1

### 输入

```
3 
19 33 32 31 29 3 5 4 30 
22 25 20 21 12 24 23 34 35 
14 13 15 26 18 17 8 16 27 
11 10 9 1 28 7 2 6 36```

### 输出

```
17

```

# AI分析结果



## 算法分类
动态规划、记忆化搜索、图论

---

## 题解思路与核心难点

### 核心算法流程
1. **邻接关系建模**：将三棱锥四个面的三角形展开后，构建每个单位三角形的三个邻接点（三棱锥折叠后的实际邻接关系）。
2. **记忆化搜索设计**：定义状态 `f[u][fa][a]` 表示以节点 `u` 为根，父节点为第 `fa` 个邻接点，取值范围边界为 `a` 时的最大BST节点数。
3. **递归求解**：对每个节点枚举可能的左/右子树邻接点，根据BST性质限制取值范围，递归计算子树节点数并取最大值。

### 解决难点
1. **邻接关系复杂**：需处理四个面之间及内部的邻接逻辑，如侧面与底面的连接、同一面上下层连接等。
2. **状态压缩优化**：将父节点邻接位置作为状态的一维，避免直接存储区间边界导致的O(n^6)复杂度。
3. **递归边界处理**：动态规划中需处理左子树范围 `[a, x-1]` 和右子树范围 `[x+1, b]` 的合法性。

---

## 题解评分（≥4星）

### Gavin·Olivia（★★★★☆）
- **亮点**：状态设计巧妙，通过父节点邻接位置压缩状态；代码结构清晰，邻接关系构建完整。
- **代码片段**：
  ```cpp
  int dp(int now, int a, int b) {
      int fa=0; while(ne[now][fa]!=b)fa++;
      if(f[now][fa][a]) return f[now][fa][a];
      int x,y,l=0,r=0;
      if(a > b) x=b+1, y=a; else x=a, y=b-1;
      for(int i=0; i<3; i++) if(i!=fa && x<=ne[now][i] && ne[now][i]<=y) {
          if (ne[now][i]<now) l=max(l, dp(ne[now][i],x,now));
          else r=max(r, dp(ne[now][i],y,now));
      }
      return f[now][fa][a] = l + r + 1;
  }
  ```

### Leaper_lyc（★★★★☆）
- **亮点**：详细分析状态转移方程，优化思路明确；提供复杂度对比，帮助理解算法优化过程。
- **核心思路**：通过将父节点邻接索引与区间边界结合，将状态降至O(n^4)。

### 吴国铨（★★★★☆）
- **亮点**：采用Pascal实现，展示多语言思路；注释详细，强调边界检查与状态初始化。
- **关键代码**：
  ```pascal
  procedure link(x, y :longint);
  begin
    r[c[x], x] := y; inc(c[x]);
    r[c[y], y] := x; inc(c[y])
  end;
  ```

---

## 最优思路提炼
1. **状态压缩**：利用父节点邻接索引替代完整区间边界，将状态从三维降至二维。
2. **邻接预处理**：在输入阶段构建所有可能的邻接关系，确保后续递归能快速访问相邻节点。
3. **记忆化剪枝**：对已计算的`(u, fa, a)`状态直接返回结果，避免重复递归。

---

## 类似题目推荐
1. **P3385 【模板】负环**（图论中的动态规划与状态设计）
2. **P1040 加分二叉树**（区间DP与树结构结合）
3. **P2015 二叉苹果树**（树形DP与邻接关系处理）

---

## 可视化设计
### 动画方案
- **像素风格**：每个三角形节点显示为16x16像素块，颜色表示其数值范围：
  - 红色：当前处理节点
  - 绿色：左子树候选
  - 蓝色：右子树候选
- **状态更新**：当递归进入子树时，高亮对应范围边界，并用连线标注父子关系。
- **音效触发**：
  - 选中节点：8-bit "beep" 音效
  - 完成子树计算：上升音阶

### 交互功能
- **步进控制**：空格键单步执行，方向键调整动画速度。
- **自动演示**：AI模式自动选择当前最优路径，用虚线显示候选邻接点。

---

## 核心代码实现（Gavin·Olivia版）
```cpp
int dp(int now, int a, int b) {
    int fa=0; while(ne[now][fa]!=b)fa++;
    if(f[now][fa][a]) return f[now][fa][a];
    int x,y,l=0,r=0;
    if(a > b) x=b+1, y=a; else x=a, y=b-1;
    for(int i=0; i<3; i++) 
        if(i!=fa && x<=ne[now][i] && ne[now][i]<=y) {
            if (ne[now][i]<now) 
                l=max(l, dp(ne[now][i],x,now));
            else 
                r=max(r, dp(ne[now][i],y,now));
        }
    return f[now][fa][a] = l + r + 1;
}
```

---

## 个人心得摘录
> "建图时RE多次，发现三角形存储应为`[1..18][1..35]`而非矩形数组。务必注意非规则结构的存储设计！" —— 吴国铨

> "父节点邻接索引的压缩是关键，否则直接存区间边界会导致MLE。" —— Leaper_lyc

---
处理用时：88.71秒
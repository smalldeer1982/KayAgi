# 题目信息

# “访问”美术馆

## 题目描述

经过数月的精心准备，Peer Brelstet，一个出了名的盗画者，准备开始他的下一个行动。艺术馆的结构，每条走廊要么分叉为两条走廊，要么通向一个展览室。Peer 知道每个展室里藏画的数量，并且他精确测量了通过每条走廊的时间。由于经验老到，他拿下一幅画需要 $5$ 秒的时间。你的任务是编一个程序，计算在警察赶来之前，他最多能偷到多少幅画。假定他回到起点后还需要留至少 $1$ 秒逃跑。

![](https://cdn.luogu.com.cn/upload/image_hosting/7kbyjwgy.png)


## 样例 #1

### 输入

```
60
7 0 8 0 3 1 14 2 10 0 12 4 6 2
```

### 输出

```
2
```

# AI分析结果



## 唯一算法分类
树形动态规划（树形DP）

---

## 题解思路、算法要点与解决难点

### 核心思路
所有题解均采用**树形DP**解决，将美术馆视为二叉树，状态定义围绕时间与偷画数量的关系展开。关键点包括：
1. **状态定义**：分为两种主流方式：
   - `f[i][j]`表示节点i偷j幅画的最少时间（如Dog_Two）
   - `f[i][j]`表示节点i用j秒的最大偷画数（如安好）
2. **递归输入处理**：按DFS顺序递归构建二叉树结构，处理走廊时间（需×2）。
3. **状态转移**：
   - 叶子节点直接计算偷画时间（i幅画→5i秒）。
   - 非叶子节点合并左右子树的最优解，并加上走廊时间。

### 解决难点
1. **输入处理**：递归构建二叉树结构，需正确处理DFS顺序。
2. **时间计算**：走廊往返时间需×2，且总时间必须严格小于警察到达时间。
3. **状态优化**：部分题解采用倒序循环或剪枝优化，减少无效状态计算。

---

## 题解评分（≥4星）

### Dog_Two（5星）
- **亮点**：状态定义清晰，代码结构规范，注释详细。
- **关键代码**：
  ```cpp
  void dp(int u) {
    if (G[u].empty()) { // 叶子节点初始化
      for(int i=0; i<=c[u]; ++i) f[u][i]=i*5;
      return;
    }
    // 合并左右子树状态
    for(int i=0; i<=600; ++i)
      for(int j=0; i+j<=600; ++j) 
        f[u][i+j] = min(f[u][i+j], f[left][i] + f[right][j] + 2*cost);
  }
  ```

### 安好（4星）
- **亮点**：传统背包式状态转移，代码简洁。
- **关键代码**：
  ```cpp
  void dfs() {
    if (子节点) {
      for(int time=limit; time<=n; time++)
        for(int lctime=0; lctime<=time-limit; lctime++)
          f[root][time] = max(f[root][time], f[left][lctime] + f[right][time-limit-lctime]);
    }
  }
  ```

### OHYEP（4星）
- **亮点**：处理叶子时加入时间限制判断，代码鲁棒性强。
- **关键代码**：
  ```cpp
  for(int i=x*2+5; i<=min(x*2+y*5,t);i++) 
    f[now][i]=(i-x*2)/5; // 时间不足时取最小值
  ```

---

## 最优思路提炼
1. **状态设计**：以`f[u][j]`表示在节点u偷j幅画的最小时间，便于直接比较时间限制。
2. **合并策略**：非叶子节点通过枚举左右子树的画数组合，计算合并后的最小时间。
3. **剪枝优化**：每层最多偷120幅（5秒/幅），限制循环次数提升效率。

---

## 类似题目
1. **P2015 二叉苹果树**：树形DP保留指定边数的最优解。
2. **P2014 选课**：树上分组背包问题。
3. **P1273 有线电视网**：树形DP结合收益平衡。

---

## 可视化与算法演示
**动画设计**：
1. **树形结构展示**：以绿色方块表示走廊节点，黄色方块表示展览室，边权显示时间。
2. **DP状态更新**：高亮当前处理的节点，显示其`f[i][j]`表格，红框标记更新的单元格。
3. **复古效果**：使用8-bit音效（行走脚步声、偷画成功音效），Canvas绘制像素风格树形图。

**关键伪代码**：
```javascript
// 像素动画更新函数
function drawDPStep(node, j) {
  ctx.fillStyle = '#FF0000'; // 高亮当前节点
  drawNode(node.x, node.y);
  // 更新f[i][j]表格
  ctx.fillText(`f[${node.id}][${j}] = ${node.f[j]}`, tableX, tableY);
  playSound('beep'); // 触发音效
}
```

---

## 代码片段（Dog_Two核心逻辑）
```cpp
void dp(int u) {
  if (G[u].empty()) { // 叶子节点初始化
    for(int i=0; i<=c[u]; ++i) f[u][i] = i*5;
    return;
  }
  int lson = G[u][0].v, rson = G[u][1].v;
  dp(lson); dp(rson); // 递归处理子树
  
  // 合并左右子树状态
  for(int i=0; i<=600; ++i) {
    for(int j=0; j+i<=600; ++j) {
      int cost = (i>0)*G[u][0].w + (j>0)*G[u][1].w;
      f[u][i+j] = min(f[u][i+j], f[lson][i] + f[rson][j] + 2*cost);
    }
  }
}
```

---
处理用时：88.87秒
# 题目信息

# 小猪佩奇爬树

## 题目描述

佩奇和乔治在爬♂树。


给定 $n$ 个节点的树 $T(V,E)$，第 $i$ 个节点的颜色为 $w_i$，保证有$1 \leq w_i \leq n$。

对于$1 \leq i \leq n$，分别输出有多少对点对 $(u,v)$，满足 $u<v$，且恰好经过**所有**颜色为 $i$ 的节点，对于节点颜色不为 $i$ 的其他节点，经过或不经过均可。

树上路径 $(u,v)$ 定义为序列 $\{f\}$，满足 $f_1=u,f_{|f|}=v$，且 $\forall 1 \leq i < |f|$，$T$ 中均存在边 $(f_i,f_{i+1})$，且 $\{f\}$ 中无重复元素，能够证明对于任意点对 $(u,v)$，其树上路径唯一。

## 说明/提示

![](https://i.loli.net/2019/10/06/H9LuWl7GSXfs4M6.png)

对于第一组样例而言。

对于颜色 $1$，点对 $(1,2),(1,3),(1,4)$ 满足条件。

对于颜色 $2$，点对 $(1,3),(1,4),(2,3),(2,4)$ 满足条件。

对于颜色 $3$，点对 $(1,4),(2,4),(3,4)$ 满足条件。

对于颜色 $4$，由于图中没有颜色为 $4$ 的节点，所以所有点对均满足条件。
### 数据范围

对于 $40\%$ 的数据, $n \leq 10^2$

对于 $60\%$ 的数据, $n \leq 10^3$

对于 $100\%$ 的数据, $n \leq 10^6$

## 样例 #1

### 输入

```
4
1 2 2 3
1 2
2 3
3 4```

### 输出

```
3
4
3
6```

## 样例 #2

### 输入

```
10
9 7 4 2 3 4 4 5 8 5
2 1
3 2
4 2
5 2
6 4
7 4
8 1
9 4
10 4```

### 输出

```
45
35
9
0
1
45
34
9
17
45```

# AI分析结果



### 算法分类
树形动态规划、子树统计与链结构判断

---

### 题解思路与解决难点
#### 核心思路
1. **预处理**：通过 DFS 遍历树，计算每个节点的子树大小 (`size[]`)、深度 (`dep[]`) 及父节点 (`fa[]`)，并统计每个颜色对应的所有节点。
2. **端点检测**：在 DFS 过程中，动态维护每个颜色的出现次数 (`cnt[]`) 和端点数量 (`nds[]`)。若某个节点在遍历时成为唯一端点，则记录其位置。
3. **合法性判断**：对于每个颜色，若端点数超过 2 或无合法链结构，则答案直接为 0。
4. **答案计算**：
   - **颜色不存在**：答案为 $\frac{n(n-1)}{2}$。
   - **单个节点**：通过所有子树两两组合求和。
   - **链结构**：根据链的位置计算两端点的子树大小乘积。

#### 解决难点
- **链结构判断**：通过维护端点数量和动态统计子树变化，避免显式构建虚树。
- **子树乘积优化**：利用预处理子树大小快速计算合法路径数目。

---

### 题解评分 (≥4星)
1. **xiejinhao**（⭐⭐⭐⭐⭐）  
   - **亮点**：利用单次 DFS 动态统计端点，时间复杂度 O(n)，代码简洁高效。
2. **Clouder**（⭐⭐⭐⭐⭐）  
   - **亮点**：通过端点判断与子树乘积直接计算答案，逻辑清晰。
3. **CYJian**（⭐⭐⭐⭐）  
   - **亮点**：结合 LCA 预处理，实现链结构验证，代码高效。

---

### 最优思路提炼
1. **DFS 动态统计**：在遍历过程中维护颜色出现次数和端点，避免二次遍历。
2. **端点合法性**：仅当颜色节点构成链且端点 ≤2 时合法。
3. **子树乘积优化**：利用 `size[]` 快速计算链两端的贡献，避免复杂结构操作。

---

### 核心代码实现
```cpp
void dfs(int u, int fa) {
    int c = color[u], k = cnt[c];
    int flag = 0, pos = 0;
    size[u] = 1;
    for (int p = head[u]; p; p = E[p].next) {
        int v = E[p].to;
        if (v == fa) continue;
        int last = cnt[c];  // 记录遍历前的颜色计数
        dfs(v, u);
        ans1[u] += 1LL * size[u] * size[v];  // 子树两两组合
        size[u] += size[v];
        if (cnt[c] != last) {  // 颜色计数变化，说明v子树有该颜色
            flag++; pos = v;   // 标记为端点
        }
    }
    ans1[u] += 1LL * size[u] * (n - size[u]);  // 父节点方向的贡献
    if (k || cnt[c] != tot[c] - 1) flag++;  // 父节点方向存在颜色
    cnt[c]++;
    if (flag == 1) {  // 当前节点是链端点
        if (!nds[c]) nd[c] = u;
        else ans2[c] = 1LL * (pos ? n - size[pos] : size[u]) * size[nd[c]];
        nds[c]++;
    }
}
```

---

### 可视化设计思路
1. **像素动画**：  
   - **颜色块标记**：不同颜色节点用不同像素颜色显示，链端点高亮闪烁。
   - **动态子树范围**：用网格框选链两端点的子树区域，实时显示 `size` 值。
2. **音效交互**：  
   - **合法链确认**：播放上升音效；非法链播放警示音。
   - **子树计算**：每次乘积更新时触发“点击”音效。
3. **自动演示模式**：  
   - **AI 步进**：自动遍历节点，动态更新端点状态和子树计算。

---

### 相似题目推荐
1. [P3379【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)  
2. [CF1702G2 Passable Paths](https://www.luogu.com.cn/problem/CF1702G2)  
3. [P3304 [SDOI2013] 直径](https://www.luogu.com.cn/problem/P3304)

---
处理用时：79.95秒
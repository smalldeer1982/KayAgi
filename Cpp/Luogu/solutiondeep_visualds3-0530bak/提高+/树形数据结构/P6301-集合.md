# 题目信息

# 集合

## 题目描述

你需要**在线**维护一个自然数的排序集 $S$ 并支持以下操作：

1. 给一个数 $x$，若 $x$ 不在集合 $S$ 中则将 $x$ 添加到集合 $S$ 中；
2. 给一个数 $x$，若 $x$ 已在集合 $S$ 中则将 $x$ 从集合 $S$ 中删除。

为了证明你维护了 $S$，你需要在操作过程中回答以下询问：

3. 求集合 $S$ 中最小元素的值，若 $S=\varnothing$ 则返回 `-1`；
4. 求集合 $S$ 中最大元素的值，若 $S=\varnothing$ 则返回 `-1`；
5. 求集合 $S$ 中元素的数量；
6. 给一个数 $x$，判断 $x$ 是否在集合内，若在则返回 `1` ，若不在则返回 `0` ；
7. 给一个数 $x$，求集合 $T=S\cap[0^-,x)$ 中最大元素的值，若 $T=\varnothing$ 则返回 `-1`；
8. 给一个数 $x$，求集合 $T=S\cap[x,n)$ 中最小元素的值，若 $T=\varnothing$ 则返回 `-1`。

为了证明你**在线地**维护了 $S$，对于所有在第一次询问后的操作 $1,2$ 与询问 $6,7,8$，实际操作和询问的参数 $x$ 为输入中给出的操作和询问的参数 $x'$ 与上一次询问的返回结果 $\text{last}$ 之和。即 $x=x'+\text{last}$。

保证 $0\le x<n$ 。

初始时 $S=\varnothing$。

## 说明/提示

### 样例解释

实际上执行的操作与回答的询问如下：

```plain
1 0
1 1
1 3
1 3
3		->  0
7 0		-> -1
7 1		->  0
8 3		->  3
4		->  3
2 3
4		->  1
6 3		->  0
5		->  2
```

因此输出为 $0+(-1)+0+3+3+1+0+2=8$。

### 数据范围

| 测试点编号 |    $n=$     |    $m=$   | 分值  |
|:--------------:|:------------:|:-----------:|:-------:|
|      $1$       | $2^{20}$ | $2^{14}$ |  $5$  |
|      $2$       | $2^{25}$ | $2^{17}$ |  $5$  |
|      $3$       | $2^{30}$ | $2^{20}$ | $10$ |
|      $4$       | $2^{30}$ | $2^{22}$ | $15$ |
|      $5$       | $2^{30}$ | $2^{22}$ | $15$ |
|      $6$       | $2^{30}$ | $2^{23}$ | $25$ |
|      $7$       | $2^{30}$ | $2^{23}$ | $25$ |

对于 $100\%$ 的数据，满足 $2^{20}\le n\le2^{30},2^{14}\le m\le 2^{23},0\le x<n$。

### 提示

**本题输入量较大，建议使用较快的读入方式。**

$0^-$ 表示略小于 $0$ 的一个值，$[0^-,x)$ 可以保证第 $7$ 个操作的 $T$ 恒有意义。

## 样例 #1

### 输入

```
4 13
1 0
1 1
1 3
1 3
3
7 0
7 2
8 3
4
2 0
4
6 2
5
```

### 输出

```
8
```

# AI分析结果



### 唯一算法分类
**权值线段树（64叉树）**

---

### 综合分析与结论
#### 核心算法流程
1. **数据结构设计**  
   使用64叉权值线段树，每个非叶子节点用64位掩码（`unsigned long long`或`__int128`）标记哪些子节点存在有效元素。叶子节点表示具体数值是否存在。  
   - **插入/删除**：通过递归更新叶子节点的位掩码，并同步维护父节点的子节点存在状态。  
   - **查询极值**：`getmin`从最低位递归，`getmax`从最高位递归。  
   - **前驱/后继查询**（操作7/8）：记录查询路径后向上回溯，利用位掩码快速定位相邻区间。

2. **难点与解决方案**  
   - **大范围数据存储**：通过分治将值域区间递归分割为64份，空间复杂度为`O(n/64)`，适用于n=2^30。  
   - **高效位操作**：预处理`lowp/uppb`数组快速定位最低/最高有效位，时间复杂度优化至`O(1)`。  
   - **动态参数调整**：维护`last`变量，每次操作时根据上一次查询结果调整输入参数。

3. **可视化设计**  
   - **树结构展示**：用Canvas绘制分层树结构，每层节点显示其64位掩码（绿色表示存在元素）。  
   - **操作高亮**：  
     - **插入/删除**：从根节点到叶子节点的路径标记为红色，更新位掩码时闪烁对应位。  
     - **前驱查询**（操作7）：高亮x的查询路径（蓝色），回溯时标记找到的有效父节点（黄色），最终定位的极值节点（绿色）。  
   - **音效与动画**：关键操作（如插入成功、查询命中）触发8-bit音效，背景音乐为复古循环旋律。

---

### 题解清单 (4星及以上)
1. **a___的题解（5星）**  
   - **亮点**：  
     - 预处理`lowp/uppb`数组加速位操作。  
     - 使用`__int128`处理大位移，避免64位溢出问题。  
     - `findmax/findmin`通过路径记录和位掩码快速定位极值。  
   - **个人心得**：调试中发现`~0ull`与位移的陷阱，改用`__int128`解决。

2. **Daniel13265的题解（5星）**  
   - **亮点**：  
     - 官方思路清晰，分层解释算法设计。  
     - 详细分析时间复杂度与空间复杂度，验证可行性。  
     - 强调`ω=2^6`的优化选择，平衡树深度与操作效率。  

---

### 核心代码实现（a___的题解）
#### 关键函数：`update`与`findmax`
```cpp
void update(int rt, int l, int r, int p) {
    if (r - l + 1 <= 64) {
        t[rt] ^= ((__int128)1 << (p - l)); // 切换叶子节点状态
        return;
    }
    int len = (r - l + 1) >> 6;
    int q = (p - l) / len;
    update(rt << 6 | q, l + q * len, l + (q+1)*len -1, p);
    // 更新父节点掩码：若子节点无元素则清除标记
    t[rt] |= ((__int128)1 << q);
    if (!t[rt << 6 | q]) t[rt] ^= ((__int128)1 << q);
}

int findmax(int x) {
    top = 0; getpos(1, 0, n-1, x); // 记录x的路径到stk数组
    for (int i = top; i; i--) {
        unsigned long long mask = t[stk[i][0]] & (((__int128)1 << stk[i][1]) - 1);
        if (mask) {
            int q = uppbit(mask);
            return getmax(stk[i][0] << 6 | q, ...); // 进入子节点求最大值
        }
    }
    return -1;
}
```

---

### 同类型题目推荐
1. **P3369 【模板】普通平衡树**：基础平衡树操作，练习多种数据结构实现。  
2. **P3835 可持久化平衡树**：结合持久化技术，适合拓展思维。  
3. **P3380 二逼平衡树**：区间查询与动态操作结合，强化线段树与平衡树综合应用。

---

### 可视化演示示例（伪代码）
```javascript
// Canvas绘制树节点
function drawNode(rt, x, y, bits) {
    ctx.fillStyle = '#2C3E50';
    ctx.fillRect(x, y, 60, 30); // 节点框
    for (let i=0; i<64; i++) {
        if (bits & (1n << BigInt(i))) { // 绿色表示有效子节点
            ctx.fillStyle = '#27AE60';
            ctx.fillRect(x + i%8*7, y + Math.floor(i/8)*7, 5, 5);
        }
    }
}

// 操作7动画：回溯路径并高亮
function animateFindMax(x) {
    let path = getPath(x); // 获取查询路径
    for (let node of path) {
        highlight(node, 'blue'); // 高亮路径节点
        if (node.hasLeftSibling()) {
            highlight(node.parent, 'yellow'); // 找到有效父节点
            let child = node.leftSibling();
            while (child) {
                highlight(child, 'green'); // 进入极值子树
                child = child.rightmost();
            }
            break;
        }
    }
}
```

---
处理用时：84.32秒
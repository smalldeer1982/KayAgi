# 题目信息

# 「EZEC-7」加边

## 题目背景

> 暴力怎么做？暴力是不是，加边！加边！加边！然后，并查集查询！

Alice 不喜欢并查集，但是她喜欢加边。

## 题目描述

给定一棵 $n$ 个节点的树，节点从 $1$ 开始编号，$1$ 号节点是根节点，每条边的方向是从父亲到儿子。每个点有一个点权 $a_i$。Alice 和 Bob 在玩游戏，他们在根节点上放了一个棋子，Alice 和 Bob 轮流将棋子沿边移动，谁不能移动谁输。

已知 Alice 是先手或是后手。在游戏开始前，Alice 可以在树上添加一条有向边 $u\to v$（$1\le u,v\le n$），然后和 Bob 在形成的图上玩这个游戏，她希望自己存在必胜策略。**她也可以选择不加边。如果无法决出胜负则不算胜利。**

给定正整数 $A,B$，Alice 添加边 $u\to v$ 的代价是 $A\times a_u+B\times  a_v$。选择不加边的代价为 $0$。

Alice 要最小化她的代价。如果她怎么加边都不满足要求，输出 $-1$。

Alice 会做出 $T$ 次询问，你需要对每个询问输出答案。

## 说明/提示

**【样例解释】**

在第 $1$ 组询问中，Alice 是后手，她无论怎么添加边都无法拥有必胜策略，所以输出 $-1$。  
在第 $2$ 组询问中，Alice 是后手，她不需要添加边就拥有必胜策略，所以代价为 $0$。  
在第 $3$ 组询问中，Alice 是先手，她只能添加一条 $1\to 3$ 的边使自己必胜，此时代价为 $2\times 4+7\times 2=22$。  
在第 $4$ 组询问中，Alice 是后手，她可以添加一条 $9\to 5$ 的边使自己必胜，此时代价为 $523\times 109+182\times 162=86491$。她还有其他使自己必胜的方法，但是可以发现 $86491$ 是最小代价。  

------------


**【数据范围】**

**本题采用捆绑测试。**


- Subtask 1（10 points）：$n\le 10$，$T=1$；
- Subtask 2（15 points）：$\sum n\le 200$；
- Subtask 3（15 points）：$\sum n\le 2000$；
- Subtask 4（10 points）：$f_i=i-1$；
- Subtask 5（10 points）：$f_i=1$；
- Subtask 6（20 points）：$\sum n\le 5\times 10^5$；
- Subtask 7（20 points）：无特殊限制。

对于 $100\%$ 的数据，满足 $1\le T\le 2\times10^3$，$2\le n\le2\times 10^5$，$\sum n\le 5\times 10^6$，$1\le a_i,A,B\le 10^9$，$f_i<i$，$t\in\{0,1\}$。


------------
**【提示】**

请使用较快的输入方式。

## 样例 #1

### 输入

```
4
3 1 2 7
1 1
4 3 2
3 1 2 7
1 2
4 3 2
3 0 2 7
1 2
4 3 2
9 1 523 182
1 1 2 2 2 3 3 1
3 23 18 293 162 483 574 384 109```

### 输出

```
-1
0
22
86491```

# AI分析结果



**唯一算法分类**  
博弈论+树形DP

---

### **题解思路与核心难点**  
**核心思路**  
1. **状态预处理**：DFS计算每个节点的初始必胜/必败态（必败态叶子节点开始反向推导）  
2. **加边策略**：必败点需连向非祖先必败点，必胜点需修改其唯一必败子节点  
3. **最小值维护**：通过两次DFS维护非路径必败点的最小权值（前缀/后缀min技巧）  

**解决难点**  
1. **环边无效证明**：返祖边无法改变胜负状态，需排除此类无效加边  
2. **高效查询**：线性维护非路径最小必败点权值（传统线段树方法O(n log n) vs 前缀后缀O(n)）  
3. **动态规划优化**：Macesuted解法通过f[i][0/1]记录状态转换代价，避免重复计算  

---

### **题解评分（≥4星）**  
1. **0x3F（5星）**  
   - **亮点**：双数组mxu/mxv维护子树内外最小值，DFS中同步处理最优解  
   - **代码**：使用左子右兄树结构，清晰处理兄弟节点间最小值传递  

2. **Macesuted（4.5星）**  
   - **亮点**：树形DP定义f[i][j]状态，转移方程简洁  
   - **优化**：通过minVal数组避免重复遍历子树  

3. **cirnovsky（4星）**  
   - **技巧**：两次DFS维护前后缀最小值，线性复杂度  
   - **实现**：通过best1/best2记录子节点极值，避免排序  

---

### **最优思路提炼**  
**关键步骤可视化设计**  
1. **节点染色**：红色表示必败态，绿色表示必胜态  
2. **加边动画**：拖动虚拟边连接节点时，实时计算A*a_u+B*a_v并显示候选最小值  
3. **路径排除**：高亮当前节点的祖先路径，灰色区域外显示可用必败点  

**复古像素化实现**  
- **颜色方案**：8-bit调色板（红：#FF0000，绿：#00FF00，灰：#808080）  
- **音效触发**：  
  - 成功加边：8-bit "升级"音效（Web Audio合成）  
  - 无效操作：短促"错误"哔声  
- **Canvas动画**：网格化树结构，节点用16x16像素方块表示，加边时显示发光轨迹  

---

### **核心代码实现**  
**0x3F解法关键片段**  
```cpp
void dfs(int p) {
    for (auto son : tree[p]) {
        dfs(son);
        if (!win[son]) { // 子节点存在必败态
            win[p] = 1;
            min_out[p] = min(min_out[p], a[son]); 
        }
    }
}

void update(int p) {
    int pre_min = INF, suf_min = INF;
    // 维护前缀后缀最小值
    for (auto son : tree[p]) {
        pre_min = min(pre_min, min_out[son]);
        suf_min = min(suf_min, min_out[son]); 
    }
    // 计算非路径最小值
    for (auto son : tree[p]) {
        int cur_min = min(pre_min, suf_min);
        ans = min(ans, A * a[p] + B * cur_min);
    }
}
```

---

### **相似题目推荐**  
1. **P2585 [ZJOI2006]三色二叉树**  
   - 树形DP+状态染色  
2. **P3177 [HAOI2015]树上染色**  
   - 树形DP结合边权贡献计算  
3. **P4643 [国家集训队]阿狸和桃子的游戏**  
   - 博弈论+树结构最优策略选择  

---

### **可视化交互设计**  
**动画流程**  
1. **初始化**：像素风渲染树结构，根节点闪烁3次  
2. **状态计算**：自底向上逐层染色（红/绿），伴随"滴答"音效  
3. **加边模拟**：  
   - 点击必败节点显示可用区域（灰色外区域）  
   - 拖拽连线时实时显示候选min(a_v)和当前代价  
4. **结果反馈**：成功时播放胜利音效+全屏闪光，失败时节点抖动  

**AI自动演示**  
- **模式选择**：下拉菜单选择不同解法（线段树/前后缀min）  
- **执行速度**：滑动条控制每步间隔（100ms~2s）  
- **轨迹回放**：记录最优路径并用高亮虚线重播  

---

**总结**：本题通过树形DP与博弈论结合，创新性使用前后缀极值维护技巧，将看似复杂的加边策略转化为线性处理。可视化设计应重点突出状态转换与极值查询过程，复古像素风格可有效提升学习趣味性。

---
处理用时：76.65秒
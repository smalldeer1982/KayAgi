# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果



## 算法分类
BFS/DFS

## 题解分析与结论
### 核心思路
1. **反向染色法**：将闭合圈外的0标记为特殊值，剩余未被标记的0即为闭合圈内区域
2. **边界扩展技巧**：在矩阵外围添加一圈虚拟0节点，确保能正确搜索到所有圈外区域
3. **搜索策略选择**：DFS/BFS均可实现，DFS代码更简洁，BFS适合较大数据

### 难点对比
| 难点                | 解决方案                                                                 |
|---------------------|--------------------------------------------------------------------------|
| 闭合圈边界判定       | 通过添加虚拟外圈，确保搜索能从外部穿透闭合圈                                |
| 多个不连通圈外区域   | 预处理时从四个边界同时开始搜索                                              |
| 避免重复标记         | 使用辅助数组记录访问状态，或在原数组直接修改值（如0→3）                      |

### 最优思路提炼
1. **预处理转换**：将原始0转换为2，1保持不变
2. **虚拟边界搜索**：从(0,0)开始DFS/BFS，将所有连通的外部0标记为其他值（如0或3）
3. **最终转换输出**：未被标记的2即为闭合圈内，转换为2；已标记的恢复为0

## 推荐题解（≥4★）
1. **LMB_001（DFS染色法）** ★★★★☆
   - 关键技巧：虚拟边界扩展
   - 代码亮点：`dfs(0,0)`启动搜索，数组双重转换
   ```cpp
   void dfs(int p,int q){
       if (p<0||p>n+1||q<0||q>n+1||a[p][q]!=0) return;
       a[p][q]=1; // 标记外圈
       for (int i=1;i<=4;i++) dfs(p+dx[i],q+dy[i]);
   }
   ```

2. **冰冻赤道（BFS边界扫描）** ★★★★☆
   - 关键技巧：四边独立扫描
   - 亮点：双数组分离处理
   ```cpp
   for(int i=1;i<=n;i=i+n-1)
       for(int j=1;j<=n;j++) 
           if(!vis[i][j]) bfs(i,j);
   ```

3. **zhy137036（栈实现DFS）** ★★★★☆
   - 创新点：显式栈替代递归
   - 对比价值：展示DFS的非递归实现
   ```cpp
   stack<pair<int,int>> sta;
   sta.push({x,y});
   while(!sta.empty()){
       auto [x,y] = sta.top(); sta.pop();
       // 四方向入栈...
   }
   ```

## 可视化方案设计
### 核心动画流程
1. **初始状态**：
   - 原始矩阵（白底）
   - 红色1，蓝色0，黄色虚拟边界
   - ![初始状态](https://via.placeholder.com/400x200/FFFFFF/000000?text=Initial)

2. **搜索过程**：
   - BFS队列可视化（绿色扩散波）
   - 已访问节点变灰，当前处理节点高亮红框
   - ![搜索过程](https://via.placeholder.com/400x200/00FF00/000000?text=Searching)

3. **染色完成**：
   - 闭合圈内保持蓝色，外部变浅灰
   - 最终2值显示为深蓝
   - ![完成状态](https://via.placeholder.com/400x200/0000FF/FFFFFF?text=Result)

### 复古游戏化实现
```javascript
// 像素风格核心代码
const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d');

function drawPixel(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*10, y*10, 8, 8); // 8x8像素块+2px间隔
}

function animateSearch(queue) {
    const current = queue.shift();
    drawPixel(current.x, current.y, '#FF5555'); // 当前节点红色
    // 播放8-bit音效...
}
```

## 相似题目推荐
1. P1506 拯救oibh总部（同类染色问题）
2. P1451 求细胞数量（连通区域计数）
3. P1141 01迷宫（连通区域预处理）

## 实现要点总结
```cpp
// 最优解核心代码
int main() {
    // 扩展边界初始化
    for(int i=0;i<=n+1;i++) 
        a[i][0] = a[i][n+1] = a[0][i] = a[n+1][i] = 0;

    dfs(0, 0); // 从虚拟边界启动

    // 输出转换
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++)
            cout << (a[i][j] ? b[i][j] : 2) << " ";
        cout << endl;
    }
}
```

---
处理用时：88.36秒
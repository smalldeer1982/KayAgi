# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果



# 【算法分类】
枚举与模拟

---

# 【题解思路与算法要点】

**核心思路**：  
1. **全排列枚举**：通过DFS或`next_permutation`生成四个矩形的所有排列顺序。  
2. **方向枚举**：每个矩形可旋转（交换长宽），需穷举所有可能的旋转组合。  
3. **六种布局计算**：对每个排列组合，计算题目所述的六种基本布局的封闭矩形面积，取最小值。  
4. **去重与记录**：用集合记录所有最小面积对应的长宽组合，避免重复输出。

**解决难点**：  
1. **排列与旋转的完全覆盖**：通过递归或循环确保所有可能的排列和旋转被枚举。  
2. **复杂布局的分支处理**：尤其是第六种布局需分5种子情况讨论矩形堆叠关系。  
3. **高效的状态更新**：使用哈希表或数组标记已出现的长宽组合，避免重复计算。

---

# 【题解评分 (≥4星)】

1. **七喜 (4.5星)**  
   - 亮点：DFS生成排列，代码结构清晰，注释详细，覆盖所有旋转情况。  
   - 改进点：变量命名可读性待优化。

2. **HFUUZY (4星)**  
   - 亮点：多重循环实现排列生成，覆盖全面，`calc`函数分情况处理。  
   - 改进点：代码冗长，分支逻辑较难维护。

3. **Chiesl (4.5星)**  
   - 亮点：详细注释第六种布局的分支逻辑，代码模块化程度高。  
   - 改进点：`f`函数略复杂，可进一步拆分。

---

# 【最优思路提炼】

1. **递归生成排列与旋转**：  
   ```cpp
   void dfs(int depth) {
       if (depth == 5) check_layouts();
       for (int i = 0; i < 4; i++) {
           if (!used[i]) {
               used[i] = true;
               swap(rect[i].w, rect[i].h); // 旋转
               dfs(depth + 1);
               swap(rect[i].w, rect[i].h); // 回溯
               dfs(depth + 1);
               used[i] = false;
           }
       }
   }
   ```

2. **布局计算模板化**：  
   ```cpp
   void check_case6() {
       int h = max(y1 + y3, y2 + y4);
       if (y1 + y3 <= y4) 
           w = max(x2, max(x1, x3) + x4);
       // ...其他分支类似
   }
   ```

3. **高效去重与输出**：  
   ```cpp
   set<pair<int, int>> ans_set;
   void update(int w, int h) {
       if (w > h) swap(w, h);
       if (w * h == min_area) 
           ans_set.insert({w, h});
   }
   ```

---

# 【相似题目推荐】

1. **P1005 矩阵取数游戏**（枚举排列与动态规划）  
2. **P1059 明明的随机数**（全排列生成与去重）  
3. **P1094 纪念品分组**（组合优化与模拟）

---

# 【可视化设计】

**核心动画逻辑**：  
1. **8位像素风格**：  
   - 用16色调色板渲染矩形，不同颜色区分当前操作的矩形（如红色高亮正在旋转的矩形）。  
   - Canvas网格绘制，每个矩形显示其编号和长宽值。

2. **关键步骤高亮**：  
   - **排列生成**：递归路径以绿色路径动画显示。  
   - **布局计算**：六种布局逐步展开，当前布局用闪烁边框标记。  

3. **音效与交互**：  
   - **点击音效**：当选中矩形或切换布局时播放8位“哔”声。  
   - **自动演示**：按空格键启动AI自动枚举，速度可调。  

**示例代码片段（Canvas动画）**：  
```javascript
function drawRect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 50, y * 50, w * 10, h * 10); // 缩放比例
    ctx.strokeStyle = '#000';
    ctx.strokeRect(x * 50, y * 50, w * 10, h * 10);
}
```

---

# 【代码实现（核心片段）】

```cpp
// 七喜题解的核心逻辑（DFS + 六种布局计算）
void check() {
    // 布局1：四矩形并排
    int x = tmpx[1] + tmpx[2] + tmpx[3] + tmpx[4];
    int y = max({tmpy[1], tmpy[2], tmpy[3], tmpy[4]});
    alter(x, y);
    
    // 布局2：三矩形叠一矩形
    x = max(tmpx[1]+tmpx[2]+tmpx[3], tmpx[4]);
    y = max({tmpy[1], tmpy[2], tmpy[3]}) + tmpy[4];
    alter(x, y);
    
    // ...其他布局类似
}

void dfs(int step) {
    if (step == 4) { check(); return; }
    for (int i = 1; i <= 4; i++) {
        if (!vis[i]) {
            vis[i] = true;
            tmpx[step+1] = x[i]; tmpy[step+1] = y[i];
            dfs(step + 1);
            swap(tmpx[step+1], tmpy[step+1]); // 旋转
            dfs(step + 1);
            vis[i] = false;
        }
    }
}
```

---
处理用时：69.93秒
# 题目信息

# 曼哈顿距离最小生成树

## 题目背景

题目修改自 [Library Checker](https://judge.yosupo.jp/problem/manhattanmst)，及[数据生成器 / 校验器来源](https://github.com/yosupo06/library-checker-problems/tree/master/geo/manhattanmst)。

请注意原题所有下标从 $0$ 开始（$0$-indexed），本题所有下标从 $1$ 开始（$1$-indexed）。

## 题目描述

给定平面上的 $n$ 个点 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$。

考虑一个有 $n$ 个结点的完全图，对于 $1\le u,v\le n(u\ne v)$，结点 $u,v$ 之间有一条权值为 $|x_u-x_v|+|y_u-y_v|$ 的边。

请求出该图的最小生成树。

## 说明/提示

对于 $20\%$ 的数据，$1\le n\le 1000$。

对于 $100\%$ 的数据，$1\le n\le 2\times 10^5$，$0\le x_i,y_i\le 10^9$。

## 样例 #1

### 输入

```
6
3 8
4 9
2 1
10 5
4 9
2 0```

### 输出

```
21
5 2
6 3
1 2
3 1
4 1```

# AI分析结果



---

**唯一算法分类**：曼哈顿距离几何性质优化 + Kruskal 算法

---

### **综合分析与结论**

#### **核心思路**
1. **曼哈顿距离性质**：通过将平面划分为 8 个 45° 区域，证明每个点只需连接每个区域内最近的 1 个点，即可保留所有可能被选入最小生成树的边。
2. **坐标变换**：利用对称性（交换 x/y 或取反），将 8 个区域简化为 4 种情况处理，大幅减少重复计算。
3. **数据结构优化**：对变换后的坐标离散化排序，用树状数组维护后缀最小值，快速找到每个点的最近邻点。

#### **算法流程**
1. **生成候选边**：
   - 对原坐标进行 4 种变换（原坐标、x/y 互换、x 取反、x 取反后互换 x/y）。
   - 每次变换后，按离散化后的 x 轴排序，树状数组维护 `x + y` 的最小值，生成候选边。
2. **Kruskal 算法**：收集所有候选边后，按边权排序，用并查集合并连通分量。

#### **复杂度分析**
- 时间：O(n log n)（4 种变换 × 离散化排序 + 树状数组操作）
- 空间：O(n)

---

### **题解评分（4.5星）**

**关键亮点**：
- **严格数学证明**：通过区域划分和三元环性质，科学减少边数。
- **对称性优化**：通过坐标变换将 8 区域简化为 4 种情况，降低常数。
- **树状数组高效查询**：离散化后后缀查询时间复杂度 O(log n)。

**改进建议**：
- 代码中坐标变换逻辑可注释更详细。
- 离散化部分可封装为独立函数提升可读性。

---

### **最优思路与技巧提炼**

1. **曼哈顿距离转极角区域**  
   - 核心观察：曼哈顿距离 `|x1-x2| + |y1-y2|` 可转化为极角坐标系中的区域划分。
   - 实现技巧：通过坐标变换（交换 x/y 或取反）统一处理不同区域。

2. **树状数组维护后缀极值**  
   - 关键操作：按离散化后的 x 排序，树状数组维护 `x + y` 最小值，快速找到最近邻点。
   - 代码片段：
     ```cpp
     fenwick_tree<pii, mn, id> t(b.size());
     for (int i=0; i<p.size(); i++) {
         auto [x,y] = p[a[i]];
         int w = get(x); // 离散化后的 x 坐标
         auto [s,j] = t.suf_sum(w); // 查询后缀最小值
         if (~j) e.emplace_back(a[i], a[j], s - x - y);
         t.add(w, make_pair(x+y, i)); // 维护 x+y 的最小值
     }
     ```

3. **对称性减少计算量**  
   - 代码实现：
     ```cpp
     for (int r1=0; r1<2; r1++) { // x 取反
         for (auto &[x,y] : p) x = -x;
         for (int r2=0; r2<2; r2++) { // 交换 x/y
             for (auto &[x,y] : p) swap(x, y);
             // 处理 R1 区域逻辑
         }
     }
     ```

---

### **同类型题与算法套路**

1. **几何图的最小生成树**  
   - 如欧几里得距离 MST（Delaunay 三角剖分优化）、切比雪夫距离 MST。
2. **二维偏序问题**  
   - 树状数组/线段树维护极值，常用于区间查询与点更新。

---

### **相似洛谷题目推荐**
1. P1991 无线通讯网（曼哈顿距离应用）
2. P2212 [USACO14MAR]Watering the Fields（欧几里得 MST）
3. P2330 [SCOI2005]繁忙的都市（Kruskal 基础）

---

### **可视化与复古动画设计**

**动画方案**：
1. **坐标变换演示**：在 Canvas 上绘制原坐标系和变换后的坐标系，用不同颜色区分区域。
2. **树状数组操作**：以网格形式展示离散化后的坐标，高亮当前查询的后缀区间。
3. **候选边生成**：用闪烁线段表示每次找到的候选边，播放 8-bit 音效提示成功匹配。
4. **Kruskal 过程**：像素小人沿边移动，合并连通块时触发“合并音效”。

**复古风格**：
- **8-bit 调色板**：用经典 FC 红/蓝/绿区分不同区域。
- **音效设计**：
  - 查询成功：短促“哔”声。
  - 合并成功：上升音阶。
  - 错误操作：低沉“嗡”声。

**交互功能**：
- **自动演示模式**：AI 逐步展示坐标变换与查询过程。
- **单步调试**：手动控制树状数组查询与合并步骤。

---

### **代码实现（核心部分）**

```cpp
// 坐标变换与候选边生成
for (int r1=0; r1<2; r1++) {
    for (auto &[x,y] : p) x = -x; // x 取反
    for (int r2=0; r2<2; r2++) {
        for (auto &[x,y] : p) swap(x, y); // 交换 x/y
        vector<int> a(p.size()), b;
        // 离散化 x 坐标
        for (auto [x,y] : p) b.push_back(x);
        sort(b.begin(), b.end());
        b.erase(unique(b.begin(), b.end()), b.end());
        auto get = [&](int x) { 
            return lower_bound(b.begin(), b.end(), x) - b.begin();
        };
        // 按 y-x 排序
        iota(a.begin(), a.end(), 0);
        sort(a.begin(), a.end(), [&](int i, int j) {
            int di = p[i].second - p[i].first;
            int dj = p[j].second - p[j].first;
            return di == dj ? p[i].first > p[j].first : di > dj;
        });
        // 树状数组维护 x+y 最小值
        fenwick_tree<pii, mn, id> t(b.size());
        for (int i : a) {
            auto [x, y] = p[i];
            int w = get(x);
            auto [s, j] = t.suf_sum(w);
            if (j != -1) e.emplace_back(i, j, s - x - y);
            t.add(w, {x + y, i});
        }
    }
}
```

---

**总结**：本题结合几何性质与数据结构优化，将高复杂度问题转化为可处理的规模，是典型的最优性剪枝与对称性简化案例。

---
处理用时：96.67秒
# 题目信息

# 区间方差

## 题目背景

出题人并没有能力写有趣的题面……


## 题目描述

对于一个长度为 $n$ 的序列 $a_1,a_2,a_3\cdots a_n$，我们定义它的平均数 $a$ 为:

$$a=\frac{1}{n}\sum_{i=1}^{n}a_i$$

并定义它的方差 $d$ 为:

$$d=\frac{1}{n}\sum_{i=1}^{n}(a_i-a)^2$$

现在给定一个长度为 $n$ 的序列 $b_1,b_2\cdots b_n$。你需要支持两种操作。每种操作的格式为 `c x y`。

若 $c=1$，为修改操作，代表将 $b_x$ 赋值为 $y$。

若 $c=2$，为查询操作，代表查询 $b_x$ 到 $b_y$ 的方差。

为了避免浮点数误差，请以分数取模形式输出结果（对 1000000007（$10^9+7$）取模）。

## 说明/提示

#### 样例 1 解释
四次修改后，序列 $b$ 为：$\{1,2,3,4\}$。

区间 $[1,1]$ 的方差为 $0$。

区间 $[1,2]$ 的方差为 $\frac{1}{4}$ 。$4$ 的逆元为 $250000002$。

区间 $[1,3]$ 的方差为 $\frac{2}{3}$。$3$ 的逆元为 $333333336$，$2\times333333336\bmod M=666666672$。

#### 数据规模与约定

- 对于 $50\%$ 的数据，$n\leq 1000$，$m\leq 1000$。
- 对于 $100\%$ 的数据，$1\leq n,m\leq 1\times 10^5$，$1\leq b_i\leq 1\times 10^9$，$1\leq x\leq n$。对于操作 1，$1\leq y\leq 1\times 10^9$。对于操作2，$x\leq y\leq n$。

## 样例 #1

### 输入

```
4 8
0 0 0 0
1 1 1
1 2 2
1 3 3
1 4 4
2 1 1
2 1 2
2 1 3
2 1 4```

### 输出

```
0
250000002
666666672
250000003```

# AI分析结果



## 唯一算法分类
线段树/树状数组维护区间统计量

---

## 综合分析与结论

### 核心算法流程
1. **公式推导**：通过展开方差公式，得到可维护形式：
   $$d = \frac{\sum a_i^2}{n} - (\frac{\sum a_i}{n})^2$$
   其中n为区间长度

2. **数据结构选择**：
   - **线段树**：每个节点维护区间和sum与平方和sum2
   - **树状数组**：使用两个数组分别维护区间和与平方和

3. **关键操作**：
   - **修改**：同时更新sum和sum2（平方值）
   - **查询**：获取区间sum和sum2后套用公式计算

4. **模运算处理**：
   - 使用费马小定理求逆元（快速幂实现）
   - 负数处理：(ans % mod + mod) % mod

### 可视化设计思路
1. **线段树动画**：
   - 高亮当前更新的叶子节点（红色）
   - 显示路径上的节点sum/sum2更新过程（黄色渐变）
   - 查询时展示合并区间的过程（蓝色边框）

2. **公式推导演示**：
   - 分步骤展开方差公式，配合Latex动画
   - 关键变换步骤使用箭头高亮（如合并同类项）

3. **模运算演示**：
   - 展示逆元计算过程（快速幂位分解）
   - 负数修正过程用颜色标记（红→绿）

---

## 题解清单（4星以上）

1. **fa_555（★★★★☆）**
   - 亮点：线段树模板清晰，注释完善，包含取模技巧
   - 核心代码：
     ```cpp
     void pushup(int p) {
         s1[p] = (s1[ls] + s1[rs]) % mod;
         s2[p] = (s2[ls] + s2[rs]) % mod;
     }
     ```

2. **Prean（★★★★☆）**
   - 亮点：结构体封装优雅，代码简洁高效
   - 关键优化：
     ```cpp
     struct Node{ int sum,squ; };
     inline Node operator+(const Node&a,const Node&b){
         return {Add(a.sum,b.sum),Add(a.squ,b.squ)};
     }
     ```

3. **MY（★★★★☆）**
   - 亮点：分步公式推导详细，适合教学
   - 心得摘录：
     > "分数取模要特别注意负数情况，最后要加mod再取模，这个坑卡了我半小时调试"

---

## 最优思路提炼

1. **双维护策略**：同时维护区间和与平方和
2. **逆元预处理**：O(n)递推逆元表加速多次查询
3. **负数修正公式**：(a - b) % mod → (a - b + mod) % mod
4. **位运算优化**：快速幂中的位运算加速

---

## 相似题目推荐

1. **P1471 方差**（区间修改+方差查询）
2. **P2122 还教室**（扩展至区间期望/方差综合题）
3. **P3372 线段树1**（基础区间和修改练习）

---

## 核心代码实现

```cpp
// 线段树节点结构
struct Node {
    int l, r;
    int sum;   // 区间和
    int sqsum; // 平方和
} tr[N<<2];

void pushup(int u) {
    tr[u].sum = (tr[u<<1].sum + tr[u<<1|1].sum) % mod;
    tr[u].sqsum = (tr[u<<1].sqsum + tr[u<<1|1].sqsum) % mod;
}

int query(int u, int l, int r, int type) { // type=1查和，2查平方和
    if(tr[u].l >= l && tr[u].r <= r) 
        return type == 1 ? tr[u].sum : tr[u].sqsum;
    
    int mid = tr[u].l + tr[u].r >> 1;
    int res = 0;
    if(l <= mid) res = query(u<<1, l, r, type);
    if(r > mid) res = (res + query(u<<1|1, l, r, type)) % mod;
    return res;
}
```

---

## 可视化方案设计

### 动画演示步骤
1. **初始化**：构建线段树，展示每个叶子节点的值和初始统计量
2. **修改操作**：
   - 红色闪烁要修改的叶子节点
   - 黄→蓝渐变显示更新路径
3. **查询操作**：
   - 蓝色框标记查询区间
   - 显示区间分解过程（左/右子树查询）
4. **公式计算**：
   - 实时显示sum和sum2的数值
   - 分步骤计算方差，显示逆元转换过程

### 交互功能
- **速度控制**：滑块调节动画速度（0.5x-5x）
- **单步执行**：空格键逐帧推进
- **数值跟踪**：鼠标悬停显示节点统计量
- **错误提示**：负数未修正时显示警告图标

---

## 总结提升
通过维护双统计量将复杂计算转化为可维护形式，模运算中注意逆向转换和负数处理。线段树与树状数组的选择取决于具体场景，前者适合复杂操作，后者更简洁高效。同类问题的突破口常在于数学公式的等价转换。

---
处理用时：73.69秒
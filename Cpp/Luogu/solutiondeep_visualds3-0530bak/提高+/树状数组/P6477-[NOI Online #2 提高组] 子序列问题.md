# 题目信息

# [NOI Online #2 提高组] 子序列问题

## 题目背景

2s 512M

## 题目描述

给定一个长度为 $n$ 的正整数序列 $A_1$, $A_2$, $\cdots$, $A_n$。定义一个函数 $f(l,r)$ 表示：序列中下标在 $[l,r]$ 范围内的子区间中，不同的整数个数。换句话说，$f(l,r)$ 就是集合 $\{A_l,A_{l+1},\cdots,A_r\}$ 的大小，这里的集合是不可重集，即集合中的元素互不相等。

现在，请你求出 $\sum_{l=1}^n\sum_{r=l}^n (f(l,r))^2$。由于答案可能很大，请输出答案对 $10^9 +7$ 取模的结果。

## 说明/提示

对于 $10\%$ 的数据，满足 $1 \leq n \leq 10$；

对于 $30\%$ 的数据，满足 $1 \leq n \leq 100$；

对于 $50\%$ 的数据，满足 $1\leq n \leq 10^3$；

对于 $70\%$ 的数据，满足 $1 \leq n \leq 10^5$；

对于 $100\%$ 的数据，满足 $1\leq n\leq 10^6$，集合中每个数的范围是 $[1,10^9]$。

## 样例 #1

### 输入

```
4
2 1 3 2```

### 输出

```
43```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
6```

# AI分析结果



## 【唯一算法分类】
枚举右端点+树状数组/线段树维护

---

## 【题解思路与算法要点】

### 核心思路
1. **枚举右端点**：逐个处理每个右端点r，计算以r结尾的所有子区间贡献。
2. **维护last数组**：记录每个数值a[r]上一次出现的位置，确定当前r新增影响的左端点范围。
3. **区间操作优化**：通过数据结构（树状数组/线段树）维护区间加法和区间查询，高效计算平方和增量。

### 解决难点
- **平方和增量推导**：将$(x+1)^2 - x^2$展开为$2x+1$，转化为区间和的线性计算。
- **高效区间操作**：通过树状数组或线段树实现$O(\log n)$时间复杂度的区间加与区间查询。

### 算法流程
1. 预处理last数组，离散化数值。
2. 枚举右端点r，确定有效左端点区间[last[r]+1, r]。
3. 更新数据结构，计算当前r对总答案的贡献。
4. 累加所有右端点的贡献得到最终结果。

---

## 【题解评分（≥4星）】

### 1. OMG_wc（5星）
- **亮点**：双树状数组处理区间加与区间和，代码简洁高效。
- **关键代码**：
  ```cpp
  LL sum(int x) {
      LL res = 0;
      for (int i = x; i > 0; i -= i & -i)
          res += c1[i] * (x + 1) - c2[i];
      return res;
  }
  void add(int x, int d, int n) {
      for (int i = x; i <= n; i += i & -i) {
          c1[i] += d;
          c2[i] += (LL)d * x;
      }
  }
  ```

### 2. tzc_wk（4星）
- **亮点**：倒序枚举左端点，线段树维护平方和，思路清晰。
- **关键公式**：
  $$\sum_{i=l}^r (t_i+v)^2 = \sum t_i^2 + 2v\sum t_i + v^2(r-l+1)$$

### 3. YoOXiii（4星）
- **亮点**：线段树维护区间值，动态更新贡献，代码可读性高。

---

## 【最优思路/技巧提炼】

1. **树状数组的区间操作**  
   通过维护两个树状数组分别处理$\sum d$和$\sum i \cdot d$，实现区间加和区间和查询：
   - `c1`维护差分数组的前缀和
   - `c2`维护差分数组乘以下标的和

2. **平方差分解**  
   将平方差转化为线性项：
   $$f^2_{new} - f^2_{old} = 2f_{old} + 1$$

3. **last数组预处理**  
   使用离散化和哈希表快速定位数值最后一次出现的位置。

---

## 【类似题目推荐】
1. [P1972 HH的项链](https://www.luogu.com.cn/problem/P1972)  
   统计区间不同数字个数，树状数组经典应用。

2. [P5490 扫描线](https://www.luogu.com.cn/problem/P5490)  
   矩形面积并，区间操作与统计结合。

3. [P3372 线段树1](https://www.luogu.com.cn/problem/P3372)  
   基础线段树实现区间加与区间和查询。

---

## 【可视化与算法演示】

### 动画设计
1. **动态网格视图**  
   - 用方格表示数组元素，颜色标记当前处理的位置r。
   - 高亮区间[last[r]+1, r]，显示该区间内的值被+1。

2. **数据结构状态**  
   - 显示树状数组/线段树节点当前存储的和与平方和。
   - 更新时突出变化的节点（如闪烁或颜色渐变）。

3. **步进控制**  
   - 支持逐帧前进/后退，观察每个r的处理过程。
   - 速度调节：0.5x~3x播放速度可选。

### 复古像素风格
- **8位调色板**：使用经典NES的蓝、绿、红色调。
- **音效设计**：
  - 区间更新时播放短促“嘟嘟”声。
  - 完成所有计算后播放胜利音效。
- **Canvas绘制**：用像素方块表示数组元素，树状数组结构以二进制堆形式展示。

---

## 【核心代码实现（OMG_wc题解）】

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL mod = 1e9 + 7;
const int N = 1e6 + 5;

LL c1[N], c2[N];
LL sum(int x) { // 区间求和
    LL res = 0;
    for (int i = x; i > 0; i -= i & -i)
        res += c1[i] * (x + 1) - c2[i];
    return res;
}
void add(int x, int d, int n) { // 区间加d
    for (int i = x; i <= n; i += i & -i) {
        c1[i] += d;
        c2[i] += (LL)d * x;
    }
}

int main() {
    int n; scanf("%d", &n);
    vector<int> a(n+1), last(n+1), d(n+1);
    // 离散化处理
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &a[i]);
        d[i-1] = a[i];
    }
    sort(d.begin(), d.end());
    int m = unique(d.begin(), d.end()) - d.begin();
    for (int i = 1; i <= n; ++i) {
        a[i] = lower_bound(d.begin(), d.begin()+m, a[i]) - d.begin();
        last[i] = d[a[i]]; // 预处理last数组
        d[a[i]] = i;
    }
    // 主算法
    LL ans = 0, now = 0;
    fill(d.begin(), d.end(), 0);
    for (int i = 1; i <= n; ++i) {
        int pre = last[i];
        now = (now + (i - pre) + 2 * (sum(i) - sum(pre))) % mod;
        ans = (ans + now) % mod;
        add(pre + 1, 1, n);
        add(i + 1, -1, n);
    }
    printf("%lld\n", ans % mod);
    return 0;
}
```

---

## 【个人心得摘录】

> **OMG_wc调试记录**：  
> 初始使用线段树TLE，改用树状数组后效率显著提升。注意离散化必须用数组而非map，否则常数过大。  
> **启示**：树状数组在区间加减场景下常数优势明显。

---
处理用时：99.86秒
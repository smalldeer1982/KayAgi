# 题目信息

# 「CGOI-1」收税

## 题目背景

~~签到题~~

由于举办选丑大赛消耗了太多钱财，ac 决定派出 Push_Y 去收税。

## 题目描述

丑国由 $n$ 座城市组成，编号 $1$ 的为首都。这 $n$ 座城市由 $n-1$ 条长度为 $1$ 的双向道路连接。从编号为 $x$ 的城市出发，往**远离**首都的方向（即往儿子节点走），距离不超过 $h$ 的就是这座城市要收税的范围。

第 $i$ 座城市将要上缴 $a_i$ **元**的所得税。但由于收税官 Push_Y 很喜欢异或，因此每座城市最终上缴的所得税将是在其收税范围内每座城市**应缴税额**的异或和。

Push_Y 将向你提出 $m$ 个询问，他将问你城市 $x$ 在收税距离为 $h$ 时将收到多少**千元**的所得税。

**简化版题意：**

给定一棵 $n$ 个点的树，根节点为 $1$ 号点，第 $i$ 个点的点权为 $a_i$，$dep_u$ 表示 $u$ 点的深度，根节点的深度为 $1$，$q$ 次询问，每次给定两个整数 $x,h$，表示询问 $\bigoplus_{u\in son(x)\land dep_u-dep_x\le h}a_i$ 除以 $1000$ 后的值。

其中 $\bigoplus_{i=1}^ni$ 表示 $1\operatorname{xor} 2\operatorname{xor}\cdots\operatorname{xor} n$。

此处 $\land$ 是“且”，$\operatorname{xor}$ 是异或。

## 说明/提示

对于 $30\%$ 的数据，$1\le n,m\le 10^3$。

对于 $70\%$ 的数据，$1\le n,m\le5 \times 10^4$。其中有 $20\%$ 的数据是链。

对于 $100\%$ 的数据，$1\le n,m\le 10^6$，$1 \le a_i \le 10^9$，$1\le x \le n$，$0 \le h \le n$。

## 样例 #1

### 输入

```
6 3
604 545 402 378 25 13
1 2 2 3 3
1 2
3 0
2 4```

### 输出

```
0.149
0.402
0.733```

## 样例 #2

### 输入

```
6 3
6 5 4 3 2 1
1 2 2 3 3
1 2
3 0
2 4```

### 输出

```
0.004
0.004
0.001```

# AI分析结果



## 算法分类
**无算法分类**

---

## 综合分析与结论

### 核心思路与难点
题目要求高效计算子树中特定深度范围的异或和，核心难点在于处理大规模数据（n,m ≤1e6）时的时空复杂度。各题解通过以下思路解决：

1. **主席树（在线处理）**  
   将树转为 DFS 序，用可持久化线段树维护每个 DFS 位置对应的深度异或值。通过前缀异或的差值得出答案，时间复杂度 O(n log depth)，空间较高但支持在线查询。

2. **分层线段树（在线处理）**  
   对每个深度维护线段树，记录该层节点的子树异或和。查询时在目标深度的线段树中求区间异或和，时间复杂度 O(m log n)，但空间复杂度较高。

3. **树状数组离线处理**  
   在 DFS 过程中，记录进入和退出子树时的异或值差，直接计算子树贡献。时间复杂度 O(n log n)，空间效率较高。

4. **桶差分法（最优解）**  
   维护一个全局深度数组，DFS 时动态更新当前深度的异或和。预处理每个节点的子树异或值，利用进入和退出时的差值计算答案，时间复杂度 O(n)，空间复杂度 O(n)。

### 可视化设计
- **动画流程**：  
  - **DFS 遍历**：节点按深度着色，遍历时动态更新对应深度的异或值。  
  - **异或操作**：当前节点权值异或到深度桶时，显示颜色闪烁。  
  - **查询处理**：进入子树前记录当前异或值（绿色标记），退出后显示差值计算（红色标记）。  
- **复古风格**：  
  - **8位像素调色板**：不同深度用不同色块表示，异或操作时播放 8 位音效。  
  - **Canvas 网格**：树结构以网格形式展示，DFS 路径用像素块动态绘制。  
- **交互功能**：  
  - **速度调节**：滑动条控制 DFS 遍历速度。  
  - **单步执行**：点击按钮逐步观察异或更新过程。  

---

## 题解清单（≥4星）

### 1. lenlen 的主席树解法（4星）  
**亮点**：利用 DFS 序和主席树实现高效区间查询，代码结构清晰，适合在线处理。  
**核心代码**：  
```cpp
int ask(int u,int v,int l,int r,int x,int y) {
    if(l==x&&r==y) return t[u].sum^t[v].sum;
    int mid=l+r>>1;
    if(x>mid) return ask(t[u].r,t[v].r,mid+1,r,x,y);
    else if(y<=mid) return ask(t[u].l,t[v].l,l,mid,x,y);
    else return ask(t[u].l,t[v].l,l,mid,x,mid)^ask(t[u].r,t[v].r,mid+1,r,mid+1,y);
}
```

### 2. 枫 的桶差分法（5星）  
**亮点**：O(n) 时间复杂度，空间高效，代码简洁。利用 DFS 动态维护深度异或和，差分计算差值。  
**核心代码**：  
```cpp
void solve(int u,int d) {
    for(reg int j=0,sz=ask[u].size(); j<sz; ++j)
        ans[ask[u][j].id]^=sum[d+ask[u][j].k+1];
    sub[u] = w[u];
    for(reg int j=head[u]; j; j=E[j].nxt)
        solve(E[j].v,d+1), sub[u]^=sub[E[j].v];
    sum[d] ^= sub[u];
    for(reg int j=0,sz=ask[u].size(); j<sz; ++j)
        ans[ask[u][j].id]^=sub[u]^sum[d+ask[u][j].k+1];
}
```

---

## 最优思路提炼
**桶差分法**：  
1. **预处理子树异或和**：DFS 计算每个节点的子树异或值 `sub[u]`。  
2. **动态维护深度桶**：在 DFS 过程中，进入节点时将其 `sub[u]` 异或到对应深度的桶中，退出时再次异或（利用异或自反性）。  
3. **查询差值计算**：进入子树前记录目标深度的异或值，退出后再次查询并异或，得到子树内贡献。  

---

## 类似题目推荐
1. **P1972 [SDOI2009] HH的项链**（区间统计 + 离线处理）  
2. **P4211 [LNOI2014] LCA**（树链剖分 + 差分）  
3. **P3834 可持久化线段树 1**（主席树模板题）  

---

## 个人心得摘录
- **枫**：离线处理时需注意深度数组的清空范围，避免影响后续计算。  
- **lenlen**：主席树的版本控制需精确对应 DFS 序，避免混淆原节点编号。  

---

## 可视化代码片段（Canvas + 音效）
```javascript
// 初始化 Canvas
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const depthColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEEAD'];

// DFS 动画函数
function animateDFS(node, depth) {
    // 绘制节点
    ctx.fillStyle = depthColors[depth % 5];
    ctx.fillRect(node.x * 20, node.y * 20, 18, 18);
    // 播放音效
    const audio = new Audio('xor_sound.wav');
    audio.play();
    // 递归子节点
    node.children.forEach(child => {
        animateDFS(child, depth + 1);
    });
}
```

---
处理用时：108.53秒
# 题目信息

# 「KDOI-02」一个弹的投

## 题目背景

- 前置芝士：[平抛运动](https://baike.baidu.com/item/%E5%B9%B3%E6%8A%9B%E8%BF%90%E5%8A%A8/974021?fr=aladdin)
~~（看到这个如果不想做可以直接开下一题）~~

「这群该死的外星人，肯定是来抢夺新矿资源的！」  
「这导弹什么鬼啊，研究不明白。」  
无数的水滴型武器从苍穹之外落下，猛击着无知的生命。  

## 题目描述

经研究，该武器的运作方式是这样的。其中设重力方向为 $y$ 轴负半轴，$x$ 轴为地面，速度向右为正向左为负。  
- 每颗导弹在 $(x_i,y_i)$ 的地方投放并悬浮，初始速度设置为 $v_i$。
- 所有导弹投放完成后，于同一时刻开始照初始速度做平抛运动。其中 $g=9.8$。  
- 每颗导弹与另一颗导弹碰撞时，不会改变原来的路线，并且将爆破威力 $p_i$ 增加 $1$，所有导弹初始时 $p_i=0$，**在接触到 $x$ 轴时碰撞也增加威力**。
- 当武器落到 $x$ 轴时，会对落点造成 $p_i$ 点杀伤力。

地面指挥部提前预测了导弹的落点，并部署了反制武器。第 $i$ 台武器能将第 $i$ 枚导弹在降落至地面后的威力值减少 $a_i$（至多减少到 $0$）。但是，由于技术限制，只能启动其中 $m$ 台反制武器。地面指挥官想知道，导弹造成的爆炸威力值总和最小为多少。

## 说明/提示

**【样例解释】**

- **样例 1 解释：** 

	每颗导弹的爆炸威力值都是 $0$。
- **样例 2 解释：** 

	四枚导弹的爆炸威力值分别是 $0,1,1,0$，启动第 $2$ 或第 $3$ 台反制武器，最后爆炸威力值的和为 $1$。
    
- **样例 4 说明：**

   该样例满足测试点 $13\sim16$ 的限制。
***
**【数据范围】**

对于 $100\%$ 的数据，$1\le n\le5\times10^5$，$0\le a_i,m\le n$，$0\le |x_i|,y_i\le10^9$，$0\le |v_i|\le10^6$。  

**保证所有导弹起始坐标不相等。**

|测试点编号|$n\le$|特殊性质|
|:-:|:-:|:-:|
|$1\sim6$|$5000$|无|
|$7\sim10$|$12000$|无|
|$11\sim12$|$10^5$|有|
|$13\sim16$|$10^5$|无|
|$17\sim20$|$5\times10^5$|无|

特殊性质：保证所有 $y_i$ 均相同。  

**【提示】**

本题 I/O 量较大，推荐使用较快的 I/O 方式。

附平抛运动落点公式：  
$$x_t=x_i+v_i\sqrt{\dfrac{2y_i}g}$$

## 样例 #1

### 输入

```
3 0
1 1 -2
1 2 -1
1 3 1
1 1 1```

### 输出

```
0```

## 样例 #2

### 输入

```
4 1
-3 3 0
1 3 1
4 3 -4
-9 3 -7
1 3 2 3```

### 输出

```
1```

## 样例 #3

### 输入

```
见附件中的 missile3.in```

### 输出

```
见附件中的 missile3.ans```

## 样例 #4

### 输入

```
见附件中的 missile4.in```

### 输出

```
见附件中的 missile4.ans```

# AI分析结果



### 算法分类
**逆序对统计 + 贪心**

---

### 题解思路与核心难点分析

#### 核心逻辑
1. **分组处理**：按 y 坐标分组，同一 y 组的导弹才可能碰撞。
2. **逆序对统计**：每组内按初始 x 排序，计算落点 x_t 的逆序对数目。  
   - 正向遍历统计「初始 x 更小但落点更大」的贡献  
   - 反向遍历统计「初始 x 更大但落点更小」的贡献  
3. **贪心优化**：将 `min(a_i, p_i)` 降序排序，选前 m 个减少总威力。

#### 解决难点
- **逆序对高效计算**：树状数组/归并排序实现 O(n log n) 复杂度  
- **离散化处理**：将浮点落点离散化为整数，方便树状数组操作  
- **大值域处理**：通过排序与映射避免直接处理浮点数

---

### 题解评分 (≥4星)

| 题解作者 | 评分 | 亮点 |
|---------|------|-----|
| Ray1    | ★★★★☆ | 代码简洁，树状数组双向统计 |
| 官方题解 | ★★★★☆ | 双树状数组设计，离散化清晰 |
| Laffey  | ★★★★☆ | 二维偏序视角，线段树实现 |

---

### 最优思路提炼
1. **物理结论转化**：y 相同是碰撞的必要条件，转化为分组问题。  
2. **逆序对双统计**：正反两次遍历确保覆盖所有碰撞情况。  
3. **贪心优化策略**：选择 `min(a_i, p_i)` 的最大前 m 项，直接降低总和。

---

### 类似题目推荐
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)  
2. [P3369 动态逆序对](https://www.luogu.com.cn/problem/P3157)  
3. [P1090 合并果子（贪心）](https://www.luogu.com.cn/problem/P1090)

---

### 可视化与算法演示设计

#### 动画流程
1. **分组展示**：不同 y 组用颜色区分，导弹以像素块形式下落。  
2. **排序过程**：动态展示按 x 排序后导弹的初始位置与落点。  
3. **树状数组操作**：高亮当前处理的导弹，显示树状数组的更新与查询路径。  
4. **贪心选择**：用进度条表示已选反制武器数量，实时更新总威力。

#### 复古像素风格
- **颜色方案**：8-bit 调色板（红：活跃导弹，绿：已处理，蓝：树状数组节点）  
- **音效设计**：  
  - `插入树状数组` → 短促“滴”声  
  - `统计逆序对` → 连续上升音阶  
  - `贪心选中` → 金币掉落音效  
- **Canvas 实现**：网格化显示导弹，树状数组以二叉树形态动态绘制。

#### 代码片段（树状数组核心）
```cpp
// 离散化落点并插入树状数组
sort(d, d + s);
for (int i = 0; i < s; i++) {
    int pos = upper_bound(d, d + s, t[x][i].d) - d;
    V[t[x][i].id] += get(pos);  // 统计左侧贡献
    add(pos);
}
// 反向统计剩余贡献
for (int i = s - 1; i >= 0; i--) {
    int pos = upper_bound(d, d + s, t[x][i].d) - d;
    V[t[x][i].id] += (s - 1 - i) - get(pos - 1);
    add(pos);
}
```

---

### 核心代码（Ray1 题解关键部分）
```cpp
struct daodan { int id, x; double d; };
vector<daodan> t[N];  // 按 y 分组存储导弹

// 离散化与树状数组统计
sort(t[x].begin(), t[x].end(), cmp);
sort(d, d + s);
for (int i = 0; i < s; i++) {
    int pos = upper_bound(d, d + s, t[x][i].d) - d;
    V[t[x][i].id] += get(pos);
    add(pos);  // 树状数组插入
}
// 反向统计
for (int i = s - 1; i >= 0; i--) {
    int pos = upper_bound(d, d + s, t[x][i].d) - d;
    V[t[x][i].id] += (s - 1 - i) - get(pos - 1);
    add(pos);
}
```

---

### 个人心得摘录
> "赛时因为忘记开 `long long` 导致 WA，血泪教训！逆序对总数可能爆 int。"  
> —— Laffey  
> "离散化时需注意浮点数精度，用 `upper_bound` 避免边界问题。"  
> —— 官方题解

---

### 扩展思考
- **优化角度**：若 y 值范围小，可直接桶排序加速分组。  
- **思维迁移**：类似「二维偏序+贪心」模式在资源分配问题中常见。

---
处理用时：87.99秒
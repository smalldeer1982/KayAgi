# 题目信息

# [PA 2020] Elektrownie i fabryki

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 2 [Elektrownie i fabryki](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/ele/)**

为了应对不断上升的失业率，Byteotia 政府决定创造新的就业机会。为此将建设现代化的工厂，还要建设为工厂供电的新发电厂。

一条很长的高速公路穿过 Byteotia，沿途有 $n$ 个城市。为了简单起见，我们从 $1$ 到 $n$ 对城市进行编号。每两个相邻城市之间都相距一公里。

目前已经决定一些城市建设工厂，另一些城市建设发电厂。对于第 $i$ 个城市有一个值 $a_i$。如果它是正数，则在第 $i$ 个城市将建造一个发电容量为 $a_i$ 兆瓦的发电厂，如果它是负数，则在该城市将建造一个消耗电能 $a_i$ 兆瓦的工厂。如果 $a_i=0$，则说明该城市没有建设计划。

你的任务是设计一个电网，将电力从发电站输送到工厂。对于每一对相邻的城镇，你必须决定是否在它们之间建立一条输电线。如果这个城市被输电线直接或间接连接到某个有发电站的城市，电力就可以从发电站流向这个城市的工厂。如果每个工厂的电力需求都得到满足，那么电网的设计就是正确的。电网的成本与电网输电线的总长度（以公里计）成正比。

写一个程序计算设计一个正确的电网最小成本是多少。

## 说明/提示

#### 样例 1 解释

下面是一个包含 $n=17$ 个城市的样例，其中将建造三个工厂（白圈）和四个发电厂（黑圈）。$12$ 公里的正确电网用灰色部分标记。

![](https://cdn.luogu.com.cn/upload/image_hosting/2wee5eoz.png)

------------

#### 数据范围

**本题采用捆绑测试**

对于一些子任务，满足 $n\le 5\times 10^3$。

对于 $100\%$ 的数据，保证 $1\le n\le 5\times 10^5$，$-10^9\le a_i\le 10^9$。

## 样例 #1

### 输入

```
17
2 -5 0 2 0 0 0 4 0 0 -1 4 0 0 0 0 -3```

### 输出

```
12```

# AI分析结果



### **算法分类**  
动态规划（DP）结合树状数组优化

---

### **综合分析与结论**  
#### **核心思路**  
1. **状态定义**：  
   - 定义 `f[i]` 为前 `i` 个城市满足电力需求的最小成本。  
   - 前缀和 `sum[i]` 用于快速验证区间 `[j+1, i]` 的电力是否合法（`sum[i] - sum[j] >= 0`）。  

2. **状态转移**：  
   - 暴力转移方程为：  
     $$f[i] = \min \{ f[j] + (i-j-1) \mid sum[i] - sum[j] \ge 0 \}$$  
   - 优化后转化为维护 `f[j] - j` 的最小值，利用树状数组快速查询满足 `sum[j] <= sum[i]` 的最小值。  

3. **离散化**：  
   - 对前缀和数组 `sum` 离散化，缩小数值范围以适应树状数组的索引限制。  

#### **解决难点**  
- **时间复杂度优化**：通过离散化和树状数组将暴力 $O(n^2)$ 优化为 $O(n \log n)$。  
- **边界处理**：  
  - 若整个前缀和 `sum[n] < 0`，直接输出 `-1`。  
  - 空白城市（`a[i] = 0`）不影响电网连接，只需处理非空城市。  

#### **可视化设计思路**  
1. **动画方案**：  
   - **颜色标记**：  
     - **当前城市**：高亮为红色。  
     - **树状数组节点**：更新时闪烁绿色，查询时闪烁蓝色。  
   - **步进控制**：允许单步执行，观察 `sum[i]` 的离散化映射和树状数组更新。  
   - **Canvas 网格**：以像素风格展示离散化后的 `sum` 值分布，树状数组节点用方块表示。  

2. **复古游戏化效果**：  
   - **音效**：  
     - 更新树状数组时播放“滴”声，查询时播放“嗒”声。  
     - 发现合法方案时播放 8-bit 胜利音效。  
   - **积分系统**：每完成一个城市的处理得 10 分，错误连接扣 5 分。  

---

### **题解评分 (≥4星)**  
1. **wuudii（4.5星）**  
   - **亮点**：预处理 `pre` 数组跳过空白城市，代码注释清晰。  
   - **代码**：完整处理了非空城市间的跳跃逻辑。  

2. **_Spectator_（5星）**  
   - **亮点**：代码简洁，结构体封装树状数组，离散化逻辑明确。  
   - **关键代码**：  
     ```cpp  
     struct BIT { /* 树状数组实现 */ };  
     int f[i] = query(sum[i]) + i - 1;  
     ```  

3. **qiliu（4星）**  
   - **亮点**：注释详细，变量命名规范，适合新手理解。  
   - **心得**：强调了 `sum[n] < 0` 的特判。  

---

### **最优思路提炼**  
**关键技巧**：  
1. **离散化前缀和**：将浮动的 `sum` 值映射到紧凑的整数区间。  
2. **树状数组维护最小值**：动态维护 `f[j] - j` 的最小值，快速响应区间查询。  
3. **跳跃处理空白城市**：通过 `pre` 数组跳过无关城市，减少无效计算。  

---

### **类似题目推荐**  
1. **P4094 [HEOI2016/TJOI2016]字符串**（后缀数组 + 二分 + 数据结构优化）  
2. **P1972 [SDOI2009]HH的项链**（离线查询 + 树状数组）  
3. **P1637 三元上升子序列**（离散化 + 树状数组统计）  

---

### **代码片段（核心逻辑）**  
```cpp  
// 离散化前缀和  
sort(b + 1, b + n + 2);  
int m = unique(b, b + n + 1) - b;  
for (int i = 0; i <= n; i++) {  
    sum[i] = lower_bound(b, b + m, sum[i]) - b + 1;  
}  

// 树状数组查询与更新  
struct BIT {  
    int c[N];  
    void update(int x, int v) {  
        for (; x <= m; x += x & -x) c[x] = min(c[x], v);  
    }  
    int query(int x) {  
        int res = INF;  
        for (; x; x -= x & -x) res = min(res, c[x]);  
        return res;  
    }  
} t;  

// DP转移  
t.update(sum[0], 0);  
for (int i = 1; i <= n; i++) {  
    f[i] = t.query(sum[i]) + i - 1;  
    t.update(sum[i], f[i] - i);  
}  
```

---

### **可视化实现（Canvas 伪代码）**  
```javascript  
// 初始化像素网格  
const canvas = document.getElementById("grid");  
const ctx = canvas.getContext("2d");  
const CELL_SIZE = 20;  

function drawGrid(sumValues) {  
    sumValues.forEach((val, idx) => {  
        ctx.fillStyle = idx === currentIdx ? "#FF0000" : "#FFFFFF";  
        ctx.fillRect(idx * CELL_SIZE, 0, CELL_SIZE, CELL_SIZE);  
        ctx.fillText(val, idx * CELL_SIZE + 2, CELL_SIZE - 2);  
    });  
}  

// 树状数组更新动画  
function highlightBIT(pos) {  
    ctx.fillStyle = "#00FF00";  
    ctx.fillRect(pos * CELL_SIZE, CELL_SIZE, CELL_SIZE, CELL_SIZE);  
}  
```  

**交互**：  
- **空格键**：单步执行算法。  
- **速度滑块**：调整动画速度（100ms~2000ms）。  

---

### **个人心得**  
- **离散化陷阱**：需包含 `sum[0] = 0`，否则初始状态可能未被正确处理。  
- **树状数组初始值**：初始化为极大值（`INF`），避免未更新节点干扰最小值查询。

---
处理用时：101.97秒
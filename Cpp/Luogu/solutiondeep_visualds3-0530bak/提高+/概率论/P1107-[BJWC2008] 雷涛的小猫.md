# 题目信息

# [BJWC2008] 雷涛的小猫

## 题目背景

原最大整数参见 P1012

## 题目描述

雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫（当然，这样的行为是违反学生宿舍管理条例的）。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。

可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆…

在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有 $N$ 棵。并且这 $N$ 棵柿子树每棵的高度都是 $H$。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。

小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳 $1$ 单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降 `Delta` 单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。

雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。

图为 $N=3, H=10, Delta=2$ 的一个例子。小猫按照图示路线进行跳跃，可以吃到最多的 $8$ 个柿子。

![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \leq N, H ≤ 2000$，$0 \leq N_i ≤ 5000$，$1 ≤ Delta ≤ N,1 ≤ T_{i,j} ≤ H$。

输入文件大小不大于 40MB。注意输入输出效率。

来源 Excalibur, 2008。

## 样例 #1

### 输入

```
3 10 2
3 1 4 10
6 3 5 9 7 8 9
5 4 5 3 6 9```

### 输出

```
8```

# AI分析结果



---

## **算法分类**
动态规划 (Dynamic Programming)

---

## **题解思路与核心难点**

### **核心思路**
1. **状态定义**：`dp[i][j]` 表示在第 `i` 棵树、高度 `j` 时的最大柿子数。
2. **转移方程**：
   - **同一棵树下降**：`dp[i][j] = dp[i][j+1] + a[i][j]`。
   - **跨树跳跃**：从其他树跳跃到当前树，需取所有树在 `j+Delta` 高度的最大值。
3. **优化关键**：维护一个全局数组 `pre[j]`，记录高度 `j` 时所有树中的最大柿子数，避免跨树时的 `O(N)` 枚举。

### **难点对比**
- **初始思路**（`O(N^3)`）：三重循环（高度、当前树、转移树），无法通过大数据。
- **优化思路**（`O(NH)`）：通过 `pre[j]` 记录每层最大值，将跨树转移的时间复杂度从 `O(N)` 降为 `O(1)`。

### **结论**
- **最优解法**：动态规划 + 最大值数组优化，时间复杂度 `O(NH)`，空间复杂度 `O(NH)`。
- **关键技巧**：用 `pre[j]` 保存高度 `j` 的最优值，避免重复计算。

---

## **题解评分 (≥4星)**

1. **issue_is_fw (⭐⭐⭐⭐⭐)**  
   - **亮点**：详细解释 `pre` 数组优化，代码简洁，对比了初始与优化思路。
   - **代码**：使用 `pre` 数组维护全局最大值，直接优化到 `O(NH)`。

2. **良辰何需美景 (⭐⭐⭐⭐)**  
   - **亮点**：简洁的代码和清晰的转移方程，直接输出 `ret[h]` 避免二次循环。
   - **代码**：用 `ret` 数组记录每层最大值，逻辑直观。

3. **sxyugao (⭐⭐⭐⭐)**  
   - **亮点**：通过 `g` 数组优化，代码可读性强，结合 `max` 操作减少冗余计算。

---

## **最优思路提炼**

### **关键步骤**
1. **初始化**：按树和高度统计柿子数量 `a[i][j]`。
2. **逆序枚举高度**：从最高层 `H` 向地面 `0` 处理，确保状态转移依赖已计算的值。
3. **维护最大值数组**：`pre[j]` 记录高度 `j` 时的全局最优值，用于跨树跳跃的快速查询。
4. **状态转移**：
   - **同一棵树**：从 `j+1` 继承。
   - **跨树跳跃**：通过 `pre[j+Delta]` 获取最优值。

### **代码片段**
```cpp
// 核心转移逻辑
for (int j = h; j >= 0; j--) {
    for (int i = 1; i <= n; i++) {
        dp[i][j] = a[i][j] + dp[i][j+1]; // 同一棵树下降
        if (j + Delta <= h) { // 允许跳跃
            dp[i][j] = max(dp[i][j], pre[j + Delta] + a[i][j]);
        }
        pre[j] = max(pre[j], dp[i][j]); // 更新全局最优
    }
}
```

---

## **同类题目推荐**
1. **P1880 [NOI1995] 石子合并**（环形区间DP，需优化）
2. **P1541 乌龟棋**（多维状态转移，类似最大值优化）
3. **P1091 合唱队形**（双向动态规划，需维护局部最优）

---

## **个人心得摘录**
- **Y_BY**：尝试贪心失败后转用DP，提醒优先考虑动态规划的最优子结构。
- **issue_is_fw**：强调维护全局最大值是优化的核心，避免“重复造轮子”。

---

## **可视化设计**

### **动画方案**
1. **像素风格**：用 8-bit 像素块表示树和高度，小猫跳跃时播放复古音效。
2. **动态更新**：
   - **当前高度**：高亮显示 `j` 层，用不同颜色标记同一棵树下降和跨树跳跃。
   - **最大值数组**：右侧面板实时显示 `pre[j]` 的值，颜色渐变表示数值变化。
3. **交互控制**：
   - **步进/暂停**：手动控制高度处理顺序，观察 `dp[i][j]` 如何更新。
   - **参数调节**：动态修改 `Delta`，观察最优路径变化。

### **复古效果**
- **音效**：
  - **跳跃**：8-bit “跳跃”音效。
  - **最大值更新**：短促“升级”音效。
- **Canvas 绘制**：用网格表示树和高度，每步更新后刷新像素块颜色。

---

**示例动画代码片段（伪代码）**  
```javascript
// 绘制树和高度（伪代码）
function drawTree(ctx, tree, height) {
    for (let i = 0; i < tree.length; i++) {
        for (let j = 0; j < height; j++) {
            const color = tree[i][j] > 0 ? "#FFD700" : "#228B22"; // 金色表示柿子
            drawPixel(ctx, i, j, color);
        }
    }
}
```

---
处理用时：81.51秒
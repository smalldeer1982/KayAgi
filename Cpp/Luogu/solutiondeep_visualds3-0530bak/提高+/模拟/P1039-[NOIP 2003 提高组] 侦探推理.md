# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！

## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果



# 侦探推理题解分析

## 算法分类
暴力枚举、模拟

## 题解思路与解决难点

### 核心思路
所有题解均采用**双重枚举法**：
1. 枚举每个可能的罪犯（M次）
2. 枚举每个可能的日期（7次）
3. 对每个枚举组合验证证词的一致性
4. 统计说谎人数并判断是否满足约束条件

### 关键实现步骤
1. **证词解析**：
   - 使用map建立人名映射（如`map<string,int>`）
   - 分离无效证词（如`gets(asdfghjkl)`跳过非法语句）
   - 将"I"转换为当前说话者名字（如`if(!u) u = t`）

2. **矛盾判定**：
   ```cpp
   // 典型矛盾检查逻辑
   if(tmp.to) rea = (tmp.u == j);      // 日期判断
   else rea = ((tmp.u == i)^(!tmp.is));// 罪犯判断
   ```

3. **未说话者处理**：
   - 维护`ran`变量记录未发言者数量
   - 说谎人数范围判断：`cnt >= m && cnt-ran <= m`

### 解决难点
1. **复杂输入处理**：
   - 使用`substr`切割字符串
   - 处理末尾标点（如`day["Sunday."]=7`）
   
2. **状态一致性验证**：
   - 通过`vector<sta>`存储每个人的所有合法证词
   - 遍历每个证词时检查前后逻辑一致性

3. **多解处理**：
   - 维护`ans`字符串记录首个合法解
   - 发现第二解时立即返回`Cannot Determine`

## 题解评分 (≥4星)

### wjyyy (★★★★☆)
- **亮点**：STL容器运用娴熟，未说话者处理逻辑清晰
- **代码**：130行精简实现，使用vector存储证词结构体

### Ebola (★★★☆☆)
- **亮点**：独立判断函数分离逻辑，输入处理完备
- **不足**：二维数组存储证词可读性略差

### Sanust (★★★★☆)
- **亮点**：结构体设计合理，矛盾检查逻辑完备
- **代码**：包含详细的证词类型判断函数`fun()`

## 最优思路提炼

### 关键技巧
1. **双重枚举法**：O(M*7)的枚举复杂度可接受
2. **证词预分类**：将证词按类型（罪犯声明/日期声明）存储
3. **波动范围计算**：`ran`变量处理未发言者的灵活情况
4. **快速失败机制**：发现矛盾立即跳出当前枚举

### 数据结构选择
```cpp
// 典型数据结构
struct sta { // 证词存储结构
    int u;    // 主语编号
    bool to;  // 0-罪犯 1-日期
    bool is;  // 肯定/否定
};
vector<sta> v[25]; // 每人证词列表
```

## 类似题目推荐
1. P1036 选数（枚举组合验证）
2. P1003 铺地毯（状态覆盖检查）
3. P1019 单词接龙（逻辑约束处理）

## 可视化设计

### 动画方案
```javascript
// 伪代码示例
function visualize() {
   // 初始化：创建M个像素角色和7个日期方块
   initCanvas(); 

   // 枚举循环
   for(罪犯 in 角色列表){
      高亮当前罪犯(红色边框);
      for(日期 in 星期列表){
         设置日期方块颜色(黄色);
         
         // 证词验证过程
         遍历所有角色{
             if(未发言) 标记为灰色;
             else 遍历证词{
                显示证词气泡;
                if(证词与当前枚举矛盾) 闪烁警告并播放错误音效;
             }
         }
         
         // 统计结果
         显示说谎人数统计面板;
         if(符合条件) 播放胜利音效;
      }
   }
}
```

### 复古特效
- **像素风格**：16色限定调色板，角色使用8x8像素绘制
- **音效设计**：
  - 正确验证：8-bit上升音阶
  - 矛盾发现：经典FC错误音效
  - 找到解时：马里奥过关音乐片段

## 核心代码片段
```cpp
// 矛盾检查核心逻辑（wjyyy题解）
for(int k=1;!flag&&k<=n;++k) {
    vector<sta>::iterator it=v[k].begin();
    if(!v[k].size()) { ++ran; continue; }
    
    sta tmp=*it;
    bool rea;
    if(tmp.to) rea=(tmp.u==j);         // 日期判断
    else rea=((tmp.u==i)^(!tmp.is));   // 罪犯判断
    
    // 遍历后续证词检查一致性
    for(;!flag&&it!=v[k].end();++it){
        if(it->to) {
            if(rea!=(it->u==j)) flag=1;
        } else {
            if(rea==((it->u==i)^it->is)) flag=1;
        }
    }
}
```

## 个人心得
- **输入处理教训**：多个题解提到因Windows/Linux换行符差异导致的bug，需统一使用`substr`或`erase`处理
- **特殊案例**：当某人名为"I"时的处理需要额外判断（如Sanust题解的`I`变量）
- **优化启示**：在发现第二个合法解时立即终止计算，避免无效枚举

---
处理用时：72.02秒
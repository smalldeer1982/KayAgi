# 题目信息

# 对撞机

## 题目描述

在 2312 年，宇宙中发现了 $n$ 台巨型对撞机，这些对撞机分别用 $1 \sim n$ 的自然数标识。科学家们不知道启动这些对撞机会发生什么危险事故，所以这些机器，刚开始都是出于关闭的状态。

随着科学家们的研究发现，第 $i$ 台对撞机启动是安全的，当且仅当其他已经启动的对撞机的标识数都跟这台对撞机标识数互质。（例如假设前面启动的对撞机标识数是 $j$，如果 $i$ 能启动，那么 $i,j$ 互质，即 $\gcd(i,j) = 1$）。如果两台对撞机的标识数不为互质数就启动，那么就会发生爆炸事故。

基于前面的研究，科学家们准备做各种启动和关闭对撞机的实验。为了确保科学家们的生命安全，你要设计一个远程遥控的软件。

刚开始，所有的对撞机都是关闭状态。你的程序将会收到许多询问，格式为“启动、关闭第 $i$ 台对撞机”。这个程序应该能处理这些询问（根据收到询问的先后顺序处理）。程序按照如下的格式输出处理结果。

如果询问为 `+ i`（表示启动第 $i$ 台对撞机），程序应该按照下面三种情况之一输出结果。

- `Success`，表示启动第 $i$ 台是安全的。
- `Already on`，表示第 $i$ 台在询问之前就已经启动了。
- `Conflict with j`，表示第 $i$ 台与前面已经启动的第 $j$ 台冲突。如果前面有多台对撞机跟 $i$ 冲突，那么只输出其中任何一台即可。

如果询问为 `- i`（表示关闭第 $i$ 台对撞机），程序应该按照下面两种情况之一输出结果。

- `Success`，表示关闭第 $i$ 台对撞机。
- `Already off`，表示第 $i$ 台对撞机在询问之前就已经关闭了。

## 说明/提示

**数据范围**

$1 \le n,m \le 10^5$，$1 \le i \le n$。

---

感谢 @cn：苏卿念 提供 Special Judge

## 样例 #1

### 输入

```
10 10 
+ 6
+ 10
+ 5
- 10
- 5
- 6
+ 10 
+ 3
+ 6
+ 3
```

### 输出

```
Success
Conflict with 6
Success
Already off
Success
Success
Success
Success
Conflict with 3
Already on
```

# AI分析结果



## 算法分类
数论（质因数分解）

---

## 综合分析与结论

### 核心思路与难点
1. **问题核心**：启动对撞机时需保证其编号与所有已启动的编号互质，等价于其质因数集合与已启动的质因数集合无交集。
2. **关键算法**：
   - **质因数分解**：通过线性筛预处理每个数的最小质因数，实现 O(log n) 时间复杂度的质因数分解。
   - **质因数标记**：维护一个数组记录每个质数被哪个对撞机占用，启动时检查冲突，关闭时释放标记。
3. **优化关键**：避免暴力遍历已启动的机器，而是通过质因数的唯一性快速判断冲突，将时间复杂度降至 O(m log n)。

### 可视化设计思路
1. **动画流程**：
   - **启动操作**：高亮当前对撞机的质因数分解过程，动态显示质因数检查（红色表示冲突，绿色表示安全）。
   - **冲突检测**：若质因数被占用，高亮冲突的质因数和对应的对撞机编号。
   - **标记更新**：成功启动后，将质因数标记为当前编号，以不同颜色区分不同对撞机占用的质因数。
2. **复古像素风格**：
   - **颜色方案**：使用 8-bit 风格（如红色表示冲突，绿色表示安全，蓝色表示当前操作）。
   - **网格展示**：将质数以网格形式排列，每个质数位置显示占用它的对撞机编号。
   - **音效设计**：成功时播放短促上升音调，冲突时播放低音警报，背景音乐循环播放 8-bit 风格旋律。

---

## 题解清单（评分≥4星）

### 1. 星小雨（★★★★★）
- **亮点**：  
  - 使用线性筛预处理质因数分解，时间复杂度最优。  
  - 代码简洁高效，维护质因数占用状态清晰。  
- **核心代码**：
  ```cpp
  // 线性筛预处理最小质因数
  for (int i=2; i<=n; ++i) {
    if (!b[i]) p[++t]=i, q[i]=t;
    for (int j=1; j<=t && (a=p[j]*i)<=n; ++j) {
      b[a]=1, q[a]=j;
      if (!(i%p[j])) break;
    }
  }
  // 启动时的质因数检查
  while (x>1) {
    if (k[q[x]]) break; // 检查质因数是否被占用
    x /= p[q[x]];
  }
  ```

### 2. Zvelig1205（★★★★☆）
- **亮点**：
  - 显式预处理每个数的质因数集合，逻辑直观。  
  - 使用 `vector` 存储质因数，代码可读性强。  
- **核心代码**：
  ```cpp
  // 预处理质因数
  void fenjie(int n) {
    int num = n;
    for (int i=2; i*i<=n; i++) {
      if (n%i == 0) {
        while (n%i == 0) n /= i;
        hav[num].push_back(i);
      }
    }
    if (n>1) hav[num].push_back(n);
  }
  // 冲突检测
  int pd_ct(int now) {
    for (int p : hav[now]) {
      if (bel[p]) return bel[p];
    }
    return 0;
  }
  ```

### 3. 李至擎（★★★★☆）
- **亮点**：
  - 使用朴素分解法预处理质因数，适合理解基础逻辑。  
  - 代码注释详细，适合教学。  
- **核心代码**：
  ```cpp
  void remove(int x) {
    for (int i=2; i*i<=x; i++) {
      if (x%i == 0) {
        p[x].push_back(i);
        while (x%i == 0) x /= i;
      }
    }
    if (x > 1) p[x].push_back(x);
  }
  ```

---

## 最优思路提炼
1. **预处理优化**：通过线性筛预处理每个数的最小质因数，实现 O(log n) 时间复杂度的质因数分解。
2. **质因数标记法**：维护一个数组记录每个质数的占用状态，将冲突检测复杂度降至 O(质因数个数)。
3. **状态管理**：启动时标记所有质因数，关闭时清空标记，避免维护已启动的编号集合。

---

## 类似题目推荐
1. **P1069 细胞分裂**：分解质因数求最小分裂次数。
2. **P1072 Hankson的趣味题**：利用质因数分解求解满足条件的数。
3. **P2043 质因数分解**：直接练习质因数分解的应用。

---

## 个人心得摘录
- **星小雨**：  
  > “线性筛不仅能筛质数，还能记录最小质因数，这对快速分解质因数至关重要。”  
- **Zvelig1205**：  
  > “显式存储每个数的质因数集合，虽然空间略大，但极大简化了冲突检测逻辑。”  

---

## 可视化代码片段（JS伪代码）
```javascript
// 像素动画核心逻辑
function animateCollider(id) {
  const factors = getPrimeFactors(id); // 获取质因数
  factors.forEach(p => {
    highlightGrid(p); // 高亮质因数格子
    if (occupied[p]) {
      playSound('conflict'); // 播放冲突音效
      showConflict(occupied[p]);
      return;
    }
  });
  factors.forEach(p => {
    occupied[p] = id; // 标记质因数
    colorGrid(p, getColor(id)); // 更新格子颜色
  });
  playSound('success');
}
```

---
处理用时：97.56秒
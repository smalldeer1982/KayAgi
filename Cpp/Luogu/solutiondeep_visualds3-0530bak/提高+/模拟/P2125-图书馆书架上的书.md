# 题目信息

# 图书馆书架上的书

## 题目背景

NOIP2014 即将来临，JC 书院信息学兴趣小组也在积极准备着，于是乎 usqwedf 、梁大大、畜牧办专场、YH 大神和 LHT 大神也要推出“蓝翔杯”。

在图书馆、 MC 等大神们相继举办了 JC 书院联合竞赛“弃疗杯”“UID#3”，据说 YH 大神还要苦苦钻研网络流的 JC 书院 $13$ 届 $13$ 班的 WZF 神牛和 MZC 神牛听到这个消息后决定联袂打造“十三点杯”。但是出一套题目是一项繁重的工作，于是他们决定再拉上和他们同届并且同班还同为 JC 书院信息学兴趣小组成员同时也在图书馆正在找“Hello World”标程的蒟蒻 SY。

可怜的蒟蒻 SY 因为还要写一大堆的作业，怎么也不肯答应，终于 WZF 神牛妥协说：“我来出一道题，你要是做出来了我们就不让你出题，否则……你懂的。”蒟蒻 SY 才刚看完 WZF 神牛即兴出的题目，便带着哭腔对 WZF 神牛说：“你们赢了。”。

可是蒟蒻 SY 实在是太弱了，根本不会出题，他绞尽脑汁，终于想到了一个办法——将 WZF 神牛出的题目 copy 一下。

## 题目描述

图书馆有 $n$ 个书架，第 $1$ 个书架后面是第 $2$ 个书架，第 $2$ 个书架后面是第 $3$ 个书架……第 $n-1$ 个书架后面是第 $n$ 个书架，第 $n$ 个书架后面是第 $1$ 个书架，第 $i$ 个书架上有 $b_i$ 本书。现在，为了让图书馆更美观，WZF 神牛让蒟蒻 SY 搬动书架上的书，使每个书架上的书一样多。由于搬动的书可能会很多，所以蒟蒻 SY 只能将一个书架上的书搬到与其相邻的两个书架上。那么蒟蒻 SY 最少搬动几本书呢？

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le n\le 10^5+1$，且 $n$ 必为奇数；$b_i\le 10^7$。

若 $af_i$ 为负数，则说明蒟蒻 SY 要把第 $i$ 个书架前面的那个书架上的 $-af_i$ 本书搬到第 $i$ 个书架上。

同理，若 $ab_i$ 为负数，则说明蒟蒻 SY 要把第 $i$ 个书架后面的那个书架上的 $-ab_i$ 本书搬到第 $i$ 个书架上。


## 样例 #1

### 输入

```
5
15 7 11 3 14
```

### 输出

```
12
2 3
-3 0
0 1
-1 -6
6 -2
```

# AI分析结果



---

## **算法分类**  
数学推导（中位数应用）

---

## **题解思路与核心难点**  
### **核心思路**  
1. **数学模型转换**：将环形均分问题转化为线性问题，通过递推建立变量间的线性关系。  
2. **前缀和与中位数**：利用前缀和数组计算每个节点的相对偏移量，通过取中位数最小化绝对值和。  
3. **环形处理**：通过递推公式隐式处理环形结构，避免显式断开环带来的复杂操作。

### **解决难点**  
- **环形结构的线性化**：通过数学推导将环形传递转化为线性递推关系，使得问题可用中位数解决。  
- **绝对值和最小化**：利用中位数在数轴上的几何意义（最小化距离和）确定最优解。  
- **输出序列构造**：通过中位数确定基准值后，逆向推导每个节点的具体传递量。

---

## **题解评分**  
### **big_news（⭐⭐⭐⭐⭐）**  
- **亮点**：详细推导数学公式，代码清晰易读，完整处理环形输出。  
- **关键代码**：  
  ```cpp  
  sort(c+1,c+n+1);  
  x1 = c[(n+1)/2];  
  for(int i=1;i<=n;i++) ans += llabs(x1-c[i]);  
  ```

### **nth_element（⭐⭐⭐⭐）**  
- **亮点**：提出`nth_element`优化排序，时间复杂度更低，代码简短。  
- **关键代码**：  
  ```cpp  
  nth_element(sum+1, sum+n/2+1, sum+n+1);  
  LL mid = sum[n/2+1];  
  ```

### **lixuanyan（⭐⭐⭐⭐）**  
- **亮点**：结合数学证明与代码实现，推荐多道相似题型，拓展性强。  
- **关键代码**：  
  ```cpp  
  x_i = x_1 - C_{i-1};  
  ans = sum(|x_i|)  // x1取C数组的中位数  
  ```

---

## **最优思路提炼**  
1. **中位数定理**：前缀和数组的中位数是绝对值和最小的关键点。  
2. **环形转线性**：通过递推式隐式处理环形依赖，避免显式断开环。  
3. **递推公式**：  
   $$ x_i = x_1 - c_{i-1}, \quad c_i = c_{i-1} + a_i - \text{avg} $$  
   其中 `c` 为前缀和数组，`x1` 为中位数。

---

## **同类型题推荐**  
1. [P2512 [HAOI2008] 糖果传递](https://www.luogu.com.cn/problem/P2512)  
2. [P4016 负载平衡问题](https://www.luogu.com.cn/problem/P4016)  
3. [UVA11300 Spreading the Wealth](https://www.luogu.com.cn/problem/UVA11300)  

---

## **可视化设计**  
### **动画方案**  
1. **像素风格界面**：  
   - 书架的环形排列用 8-bit 像素方块表示，书本数量用颜色深浅标识。  
   - 中位数位置用闪烁的红色方块高亮，前缀和数组用动态折线图展示。

2. **关键步骤演示**：  
   - **步骤1**：计算每个书架与平均值的差，显示为浮动数字。  
   - **步骤2**：动态生成前缀和数组，每个节点用绿色连线标记累加过程。  
   - **步骤3**：排序前缀和数组，中位数位置用金色边框突出。  
   - **步骤4**：根据中位数计算每个节点的传递量，用箭头动画表示书本流动。

3. **音效与交互**：  
   - **音效**：计算前缀和时播放“滴答”声，选中中位数时播放“确认”音效。  
   - **控制面板**：支持暂停/继续、单步执行、调整动画速度。

### **核心代码片段（JS）**  
```javascript  
// 计算前缀和与中位数（简化示例）  
function calculate() {  
  let avg = total / n;  
  let c = [0];  
  for (let i = 1; i <= n; i++) {  
    c[i] = c[i-1] + a[i] - avg;  
    drawLine(i, c[i]); // 绘制前缀和折线  
  }  
  c.sort((a, b) => a - b);  
  let mid = c[Math.floor(n/2)];  
  highlightMedian(mid); // 高亮中位数  
}  
```

---

## **个人心得摘录**  
- **nth_element 的调试经历**：  
  > “第一次用`nth_element`时忘记处理数组下标，WA 了两次才发现是边界问题，必须从 1 开始存数据。”  
- **数学推导的顿悟**：  
  > “突然意识到环形问题可以通过递推消去环形依赖，那一刻仿佛打通了任督二脉。”

---

## **完整代码示例**  
```cpp  
#include <bits/stdc++.h>  
using namespace std;  
typedef long long LL;  
const int N = 1e6 + 5;  

LL n, a[N], c[N], avg;  

int main() {  
    cin >> n;  
    LL sum = 0;  
    for (int i = 1; i <= n; i++) {  
        cin >> a[i];  
        sum += a[i];  
    }  
    avg = sum / n;  

    // 计算前缀和数组  
    c[0] = 0;  
    for (int i = 1; i <= n; i++) {  
        c[i] = c[i-1] + a[i] - avg;  
    }  

    // 排序取中位数  
    sort(c + 1, c + n + 1);  
    LL x1 = c[(n + 1) / 2];  

    // 计算最小代价  
    LL ans = 0;  
    for (int i = 1; i <= n; i++) {  
        ans += abs(x1 - c[i]);  
    }  
    cout << ans << endl;  

    // 输出传递序列  
    for (int i = 1; i < n; i++) {  
        cout << (x1 - c[i-1]) << " " << -(x1 - c[i]) << endl;  
    }  
    cout << (x1 - c[n-1]) << " " << -x1 << endl;  
    return 0;  
}  
```

---
处理用时：75.72秒
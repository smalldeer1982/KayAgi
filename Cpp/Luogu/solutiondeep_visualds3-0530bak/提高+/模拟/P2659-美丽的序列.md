# 题目信息

# 美丽的序列

## 题目背景

GD是一个热衷于寻求美好事物的人，一天他拿到了一个美丽的序列。


## 题目描述

为了研究这个序列的美丽程度，GD定义了一个序列的“美丽度”和“美丽系数”：对于这个序列的任意一个区间[l，r]，这个区间的“美丽度”就是这个区间的长度与这个区间的最小值的乘积，而整个序列的“美丽系数”就是它的所有区间的“美丽度”的最大值。现在GD想要你帮忙计算这个序列的“美丽系数”。


## 说明/提示

样例解释 选取区间［2，3］，可以获得最大“美丽系数”为2\*2=4。 数据范围 对于20%的数据，n<=2000； 对于60%的数据，n<=200000； 对于100%的数据，1<=n<=2000000，0<=ai<=2000000。 提示 你可能需要一个读入优化。


## 样例 #1

### 输入

```
3 

1 2 3```

### 输出

```
4```

# AI分析结果



# 美丽的序列题解分析

## 算法分类
**单调栈**（核心算法）

---

## 题解思路与难点对比

### 核心算法流程
1. **单调栈预处理边界**  
   - 每个元素`a[i]`的左右第一个比它小的位置`l[i]`和`r[i]`
   - 通过两次单调栈扫描（正序找右边界，逆序找左边界）
   - 最终答案：`max(a[i] * (r[i]-l[i]-1))`

2. **分治线段树法**  
   - 递归寻找当前区间最小值，分裂区间继续计算
   - 时间复杂度`O(n log n)`，对`n=2e6`数据存在风险

3. **笛卡尔树法**  
   - 构建笛卡尔树后遍历所有节点，计算子树对应区间的美丽度
   - 时间复杂度`O(n)`但常数较大

4. **并查集贪心法**  
   - 按元素值降序处理，维护连通块计算贡献
   - 时间复杂度`O(n log n)`

---

## 题解评分（≥4星）

1. **Leianha（5星）**  
   - 思路最清晰，代码简洁
   - 预处理`l[i]`和`r[i]`的写法易于理解
   - 直接输出最大值无需额外处理

2. **karma（4星）**  
   - 单次单调栈处理，边弹栈边计算
   - 需注意栈内剩余元素的处理逻辑
   - 代码稍显冗余但核心逻辑正确

3. **Star_Cried（4星）**  
   - 笛卡尔树实现新颖
   - 构建笛卡尔树的模板清晰
   - 通过递归遍历计算答案

---

## 最优思路与技巧提炼

### 关键技巧
1. **单调栈边界预处理**  
   - 正向扫描时维护递增栈，记录每个元素右边界
   - 逆向扫描记录左边界
   - 最终区间长度`r[i]-l[i]-1`

2. **弹栈时计算贡献**  
   - 当`a[i]`小于栈顶元素时，栈顶元素的右边界即为`i`
   - 左边界由栈顶前一个元素决定

3. **栈内元素处理**  
   - 遍历结束后需处理栈中剩余元素（右边界为`n`）

### 代码实现要点
```cpp
// 预处理右边界
for(int i=1; i<=n; i++){
    while(top && a[stk[top]] >= a[i])
        r[stk[top--]] = i;
    l[i] = stk[top];
    stk[++top] = i;
}

// 处理剩余元素
r[stk[top]] = n+1;

// 计算最大值
ll ans = 0;
for(int i=1; i<=n; i++)
    ans = max(ans, 1LL*a[i]*(r[i]-l[i]-1));
```

---

## 同类题目推荐
1. **P1901 发射站**（单调栈经典问题）
2. **P2422 良好的感觉**（同型题，需计算区间和）
3. **P1823 [COI2007] Patrik**（单调栈变形）

---

## 可视化设计

### 动画方案
1. **颜色标记**  
   - **红色**：当前处理的元素`a[i]`
   - **黄色**：栈顶元素及其管辖区间
   - **绿色**：已计算贡献的区间

2. **动态流程**  
   - 展示元素依次入栈过程
   - 弹栈时高亮弹出的元素及其区间范围
   - 显示实时计算的美丽度最大值

3. **复古像素风格**  
   - 用16色像素块表示数组元素高度
   - 栈结构以砖块堆叠动画呈现
   - 背景音乐：8-bit风格循环音效

### 交互功能
- **步进控制**：支持暂停/继续/单步
- **速度调节**：0.5x~3x倍速
- **数据生成**：随机生成测试用例

---

## 总结
**单调栈预处理边界法**是该题的最优解，时间复杂度`O(n)`且代码简洁。其核心在于通过两次单调栈扫描快速确定每个元素的管辖区间，巧妙地将问题转化为区间极值计算。其他方法如笛卡尔树和并查集虽有趣但适用性较弱。建议重点掌握单调栈的实现细节与边界处理技巧。

---
处理用时：66.11秒
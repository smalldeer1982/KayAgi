# 题目信息

# [TJOI2010] 分金币

## 题目描述

现在有 $n$ 枚金币，它们可能会有不同的价值，第 $i$ 枚金币的价值为 $v_i$。

现在要把它们分成两部分，要求这两部分金币数目之差不超过 $1$，问这样分成的两部分金币的价值之差最小是多少？



## 说明/提示

#### 数据规模与约定

- 对 $30\%$ 的数据，保证 $1 \leq v_i \leq 1000$
- 对于 $100\%$ 的数据，保证 $1 \leq T \leq 20$，$1 \leq n \leq 30$，$1 \leq v_i \leq 2^{30}$。

## 样例 #1

### 输入

```
2
3
2 2 4
4
1 2 3 6
```

### 输出

```
0
2
```

# AI分析结果



### 唯一算法分类
折半搜索（Meet-in-the-Middle）

---

### 综合分析与结论
#### 核心思路与难点
1. **问题核心**：将 30 枚金币分为两堆，要求数量差 ≤1 且价值差最小。
2. **核心难点**：直接暴力枚举 2^30 种情况不可行，需寻找高效优化策略。
3. **关键解法**：
   - **折半搜索**：将金币分为前后两半，分别枚举所有子集组合，利用排序+二分快速匹配最优解。
   - **模拟退火**：通过随机交换金币分组，以概率接受次优解跳出局部最优。
   - **剪枝搜索**：通过排序优化搜索顺序，结合前缀和剪枝大幅减少无效分支。

#### 算法流程可视化设计
- **折半搜索**：
  1. **前半枚举**：用 Canvas 绘制前半部分所有子集生成过程，高亮当前处理的金币（红色方块），已选金币标记为绿色。
  2. **后半匹配**：后半部分枚举时，动态绘制二分查找过程，用蓝色箭头指示查找区间收缩。
  3. **差值计算**：用对比色条动态展示前后两半组合后的总差值变化，最小值以闪烁特效标记。
- **像素风格**：
  - 使用 8-bit 音效：生成子集时播放短促 "beep"，找到更优解时播放上扬音效。
  - 金币用 16x16 像素方块表示，选中状态切换为绿色边框。

---

### 题解评分（≥4星）
| 题解作者       | 评分 | 关键亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| star_city      | ★★★★☆ | 折半状压+排序优化，复杂度稳定 O(2^(n/2))，代码清晰                      |
| 7KByte         | ★★★★☆ | 深度优先搜索+双重剪枝，可读性强，完整展示剪枝逻辑                       |
| Luan_233       | ★★★★  | 折半状压+set 优化，通过差值编码避免负数下标问题                         |

---

### 最优思路提炼
#### 折半搜索优化技巧
1. **状态编码**：前 15 枚金币的每个子集记录两个值：
   ```cpp
   struct State { int cnt;  // 选的数量差（选A数-选B数）
                   ll val; }; // 价值差（A总价值-B总价值）
   ```
2. **排序分组**：按 `cnt` 分组排序，使相同数量差的子集连续存储：
   ```cpp
   sort(states, states + (1<<15), [](State a, State b){
       return a.cnt < b.cnt || (a.cnt == b.cnt && a.val < b.val);
   });
   ```
3. **二分匹配**：枚举后 15 枚的子集时，在对应 `cnt` 组内二分查找最接近目标值的补集：
   ```cpp
   auto it = lower_bound(group.begin(), group.end(), target_val);
   min_diff = min(abs(*it - target_val), abs(*(it-1) - target_val));
   ```

---

### 同类型题与算法套路
1. **子集和问题**：如 [洛谷 P3067](https://www.luogu.com.cn/problem/P3067)，均需枚举所有可能子集。
2. **双向搜索**：当 n≈40 时，折半搜索是唯一可行解，如 [洛谷 P4799](https://www.luogu.com.cn/problem/P4799)。
3. **剪枝优化**：通过排序预处理+前缀和剪枝，可处理 n≈50 的深搜问题。

---

### 推荐相似题目
1. **P3067** [USACO12OPEN] Balanced Cow Subsets  
   - **难点**：需找出所有平衡子集划分，折半搜索+哈希去重
2. **P4799** [CEOI2015] 世界冰球锦标赛  
   - **技巧**：折半搜索模板题，直接枚举前后半子集求和
3. **P2320** [HNOI2006] 鬼谷子的钱袋  
   - **思维**：二进制分组思想，与折半搜索的拆分策略异曲同工

---

### 个人心得摘录
> **star_city 题解调试经验**：  
> _"最初未对前半子集按 cnt 分组，导致二分查找效率极低。改为先排序再记录分组边界后，耗时从 800ms 降至 200ms。"_

> **7KByte 剪枝心得**：  
> _"将金币降序排列后，优先选取大额金币能更快触发前缀和剪枝，搜索树规模减少 90% 以上。"_

---

### 可视化与算法演示（折半搜索）
#### 核心动画流程
```javascript
// 伪代码：Canvas 绘制前半子集生成
const coins = [2, 4, 2]; // 示例金币
let states = [];

function drawSubset(mask) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  let sumA = 0, sumB = 0;
  for (let i = 0; i < coins.length; i++) {
    const x = 50 + i * 60, y = 100;
    if (mask & (1 << i)) { // 绘制选中状态
      drawCoin(x, y, coins[i], "green");
      sumA += coins[i];
    } else {
      drawCoin(x, y, coins[i], "gray");
      sumB += coins[i];
    }
  }
  // 记录状态并排序...
}

// 8-bit 音效触发
function playSound(type) {
  const freq = type === 'better' ? 880 : 440;
  synth.triggerAttackRelease(freq, '8n');
}
```

#### 复古像素风格设计
- **调色板**：16 色 FC 风格，金币用 #FF5555（红）、选中状态 #55FF55（绿）。
- **动画帧**：每生成 100 个子集更新一帧，伴随 8-bit "blip" 音效。
- **AI 演示**：自动切换最优子集组合，差值变化时展示对比色条波动。

---

### 核心代码实现（折半搜索）
```cpp
vector<State> pre, suf;

// 生成前半部分所有子集状态
for (int mask = 0; mask < (1 << 15); mask++) {
    int cnt = 0;
    ll val = 0;
    for (int i = 0; i < 15; i++) {
        if (mask & (1 << i)) {
            cnt++;
            val += a[i];
        } else {
            cnt--;
            val -= a[i];
        }
    }
    pre.push_back({cnt, val});
}

// 按 cnt 分组并排序
sort(pre.begin(), pre.end());

// 枚举后半子集并匹配
ll min_diff = INF;
for (int mask = 0; mask < (1 << 15); mask++) {
    int cnt = 0;
    ll val = 0;
    for (int i = 0; i < 15; i++) {
        if (mask & (1 << i)) {
            cnt--;
            val += b[i];
        } else {
            cnt++;
            val -= b[i];
        }
    }
    // 在 pre 中查找 cnt 互补的组
    auto it = lower_bound(pre_group[cnt].begin(), pre_group[cnt].end(), -val);
    if (it != pre_group[cnt].end()) 
        min_diff = min(min_diff, abs(*it + val));
}
```

---
处理用时：82.35秒
# 题目信息

# [蓝桥杯 2021 国 A] 冰山

## 题目描述

一片海域上有一些冰山，第 $i$ 座冰山的体积为 $V_{i}$ 。

随着气温的变化，冰山的体积可能增大或缩小。第 $i$ 天, 每座冰山的变化量都是 $X_{i}$。当 $X_{i}>0$ 时，所有冰山体积增加 $X_{i}$；当 $X_{i}<0$ 时，所有冰山体积减少 $-X_{i}$；当 $X_{i}=0$ 时，所有冰山体积不变。

如果第 $i$ 天某座冰山的体积变化后小于等于 $0$，则冰山会永远消失。

冰山有大小限制 $k$。如果第 $i$ 天某座冰山 $j$ 的体积变化后 $V_{j}$ 大于 $k$，则它会分裂成一个体积为 $k$ 的冰山和 $V_{j}-k$ 座体积为 $1$ 的冰山。

第 $i$ 天结束前（冰山增大、缩小、消失、分裂完成后），会漂来一座体积为 $Y_{i}$ 的冰山（$Y_{i}=0$ 表示没有冰山漂来）。

小蓝在连续的 $m$ 天对这片海域进行了观察，并准确记录了冰山的变化。小蓝想知道, 每天结束时所有冰山的体积之和（包括新漂来的）是多少。

由于答案可能很大，请输出答案除以 $998244353$ 的余数。

## 说明/提示

**【样例说明】**

在本样例说明中, 用 $\left[a_{1}, a_{2}, \cdots, a_{n}\right]$ 来表示每座冰山的体积。

初始时的冰山为 [1]。

第 $1$ 天结束时，有 $3$ 座冰山： $[1,1,6]$ 。

第 $2$ 天结束时，有 $6$ 座冰山： $[1,1,2,3,3,6]$ 。

第 $3$ 天结束时，有 $5$ 座冰山： $[1,1,2,2,5]$ 。

**【评测用例规模与约定】**

对于 $40 \%$ 的评测用例, $n, m, k \leq 2000$;

对于 $60 \%$ 的评测用例, $n, m, k \leq 20000$;

对于所有评测用例, $1 \leq n, m \leq 10^5,1 \leq k \leq 10^{9}, 1 \leq V_{i} \leq k, 0 \leq Y_{i} \leq k$, $-k \leq X_{i} \leq k$ 。 

蓝桥杯 2021 国赛 A 组 G 题。

## 样例 #1

### 输入

```
1 3 6
1
6 1
2 2
-1 1```

### 输出

```
8
16
11```

# AI分析结果



# 算法分类选择  
**数据结构优化（堆与平衡树）**

---

# 综合分析与结论  

## 核心思路与难点  
题目要求动态维护冰山的体积变化，需高效处理：  
1. **整体加减偏移量**（通过全局标记实现）  
2. **体积消失判断**（最小堆处理体积下限）  
3. **体积分裂处理**（最大堆处理体积上限）  
4. **合并相同体积的冰山**（数量打包模运算）

## 关键算法流程  
1. **偏移量标记**：用 `minval` 和 `maxval` 记录整体偏移，避免逐个修改冰山体积。  
2. **堆维护极值**：  
   - **小根堆**处理体积消失：当 `val[i] <= minval` 时冰山消失  
   - **大根堆**处理体积分裂：当 `val[i] > maxval` 时分裂为 k 和 1 的冰山  
3. **数量打包**：用 `cnt[i]` 记录相同体积的冰山数量，模运算处理超大数据。  

## 可视化设计  
- **颜色标记**：  
  - 红色：当天新增的 Y_i 冰山  
  - 黄色：分裂产生的体积为 k 的冰山  
  - 绿色：分裂产生的体积为 1 的冰山  
- **动画效果**：  
  1. 显示全局偏移量 `minval` 和 `maxval` 的数值变化  
  2. 堆结构动态调整，高亮当前处理的最大/最小冰山  
  3. 分裂时显示原冰山体积→k+1 的分解动画  

---

# 题解清单 (≥4星)  

## 1. Terrible 的堆解法（★★★★☆）  
**亮点**：  
- 双堆维护极值，全局偏移量优化  
- 数量打包+模运算处理超大数据  
- 代码逻辑清晰，时间复杂度 O(m log n)  

**核心代码片段**：  
```cpp
while(!min_heap.empty()) { // 处理消失的冰山
    int i = min_heap.top();
    if (val[i] <= minval) {
        notexist[i] = 1;
        num = (num + mod - cnt[i]) % mod;
        min_heap.pop();
    } else break;
}
```

## 2. meyi 的 map 解法（★★★★☆）  
**亮点**：  
- 利用 map 有序性处理极值  
- 体积相同合并计数，减少操作次数  
- 代码简洁，空间效率高  

**核心代码片段**：  
```cpp
while(cnt.size() && cnt.begin()->fi+sum+x<1) { // 处理消失
    all -= cnt.begin()->se;
    cnt.erase(cnt.begin());
}
```

---

# 最优思路提炼  

1. **相对偏移标记法**：  
   通过全局 `minval` 和 `maxval` 记录偏移量，避免逐个修改冰山体积。数学上等价于所有冰山体积的线性变换。  

2. **极值堆维护**：  
   - 小根堆快速获取最小体积冰山判断消失  
   - 大根堆快速获取最大体积冰山处理分裂  

3. **数量打包模运算**：  
   将相同体积的冰山数量合并处理，对 `cnt` 取模避免数值溢出。  

---

# 同类型题推荐  

1. **P1886 滑动窗口**（单调队列维护极值）  
2. **P3372 线段树 1**（懒惰标记处理区间加）  
3. **P3871 中位数**（对顶堆维护动态中位数）  

---

# 可视化与算法演示  

## 复古像素风格设计  
- **颜色方案**：  
  - 冰山体积用 8 位色块表示（1:绿色，k:黄色，其他:蓝色）  
  - 堆结构用橙色边框高亮当前操作节点  
- **音效设计**：  
  - 冰山分裂时播放 "哔" 音效  
  - 冰山消失时播放 "咔嚓" 音效  

## 动画控制面板  
```html
<div id="control-panel">
    <button onclick="pause()">⏸️</button>
    <button onclick="step()">⏯️</button>
    <input type="range" id="speed" min="1" max="5">
</div>
```

---

# 个人心得摘录  

> "分裂产生的 1e9 级冰山数量必须取模，否则会溢出到怀疑人生" —— Terrible  
> "map 的 rbegin() 反向迭代器是处理最大值的利器" —— meyi  

---

# 核心代码实现  

## 堆解法完整代码（关键部分）  
```cpp
struct valgreater { // 小根堆比较器
    bool operator()(const int& i1, const int& i2) {
        return val[i1] > val[i2];
    }
};
std::priority_queue<int, std::vector<int>, valless> max_heap;
std::priority_queue<int, std::vector<int>, valgreater> min_heap;

// 处理分裂
long long ceiling = 0, debris = 0;
while(!max_heap.empty() && val[max_heap.top()] > maxval) {
    int i = max_heap.top();
    ceiling += cnt[i];
    debris += cnt[i] * (val[i] - maxval);
    max_heap.pop();
}
if(ceiling) {
    val[++_n] = maxval; // 添加新冰山
    min_heap.push(_n); max_heap.push(_n);
}
```

---
处理用时：73.94秒
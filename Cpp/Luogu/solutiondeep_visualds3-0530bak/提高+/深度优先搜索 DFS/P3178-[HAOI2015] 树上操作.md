# 题目信息

# [HAOI2015] 树上操作

## 题目描述

有一棵点数为 $N$ 的树，以点 $1$ 为根，且树有点权。然后有 $M$ 个操作，分为三种：
- 操作 $1$：把某个节点 $x$ 的点权增加 $a$。
- 操作 $2$：把某个节点 $x$ 为根的子树中所有点的点权都增加 $a$。
- 操作 $3$：询问某个节点 $x$ 到根的路径中所有点的点权和。


## 说明/提示

对于 $100\%$ 的数据，$1\le N,M\le10^5$，且所有输入数据的绝对值都不会超过 $10^6$。


## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 2
1 4
2 3
2 5
3 3
1 2 1
3 5
2 1 2
3 3```

### 输出

```
6
9
13```

# AI分析结果



### 唯一算法分类  
**树链剖分**

---

### 综合分析与结论  
题目需要通过树结构高效处理三种操作：单点修改、子树修改、路径和查询。  
**核心思路**：  
1. **树链剖分**将树转化为链式结构，通过两次 DFS 划分重链，将树映射为线性区间。  
2. **线段树/树状数组**维护区间和，支持快速修改与查询。  
3. **子树操作**利用 DFS 序的连续性，子树对应区间 `[id[x], id[x]+size[x]-1]`。  

**难点与解决方案**：  
- **路径查询**：通过跳转重链将路径拆分为多个连续区间，分别求和。  
- **子树修改**：利用 DFS 序的子树区间特性直接覆盖。  

---

### 题解清单 (≥4星)  
1. **关怀他人 (赞36) - 4星**  
   - 代码结构清晰，完整树剖模板，包含详细注释。  
   - 使用线段树维护区间和，处理路径查询时通过 `while` 循环跳链。  
   - **亮点**：明确分离两次 DFS 和线段树操作，便于理解。  

2. **zht467 (赞94) - 4星**  
   - 结合 DFS 序与线段树，通过 `dis[y] * z` 处理子树深度相关修改。  
   - **亮点**：将子树修改转化为线性区间操作，避免显式递归遍历。  

3. **yingjz (赞40) - 4星**  
   - 使用欧拉序维护前缀和，通过正负标记区分进入/离开节点。  
   - **亮点**：将路径和转换为前缀和，避免复杂链操作。  

---

### 核心算法流程与可视化设计  
#### 树链剖分关键步骤：  
1. **DFS1**：计算子树大小 `size` 和重儿子 `son`。  
2. **DFS2**：划分重链，生成节点在线性序列中的位置 `id[x]`。  
3. **线段树**：维护 `id[x]` 序列的区间和。  

**可视化动画设计**：  
- **颜色标记**：  
  - **红色**：当前处理的重链。  
  - **蓝色**：路径查询时的跳转过程。  
  - **绿色**：子树修改覆盖的区间。  
- **步进控制**：单步展示跳链过程，高亮当前线段树操作区间。  
- **复古像素风格**：  
  - 树结构用 8-bit 像素节点表示，重链以不同颜色区分。  
  - 线段树更新时，对应区间方块闪烁，伴随 8-bit 音效。  

---

### 核心代码实现  
#### 树链剖分核心逻辑  
```cpp
void dfs1(int u, int fa) {
    size[u] = 1;
    for (int v : g[u]) {
        if (v == fa) continue;
        dfs1(v, u);
        size[u] += size[v];
        if (size[v] > size[son[u]]) son[u] = v;
    }
}

void dfs2(int u, int topf) {
    id[u] = ++cnt; // 线性序列编号
    top[u] = topf;
    if (son[u]) dfs2(son[u], topf); // 优先处理重儿子
    for (int v : g[u]) {
        if (v == fa[u] || v == son[u]) continue;
        dfs2(v, v); // 新链起点
    }
}
```

#### 路径查询实现  
```cpp
ll query_path(int x, int y) {
    ll res = 0;
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        res += seg_query(1, id[top[x]], id[x]); // 线段树查询
        x = fa[top[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    res += seg_query(1, id[x], id[y]);
    return res;
}
```

---

### 同类型题目推荐  
1. **P3384 【模板】树链剖分**：标准树剖模板题，包含路径和子树操作。  
2. **P2146 [NOI2015] 软件包管理器**：子树安装/卸载，路径查询。  
3. **P2486 [SDOI2011] 染色**：路径染色与颜色段统计，需扩展线段树。  

---

### 个人心得摘录  
- **调试陷阱**：子树区间应为 `[id[x], id[x]+size[x]-1]`，漏掉 `-1` 会导致越界（题解中多次提及）。  
- **优化技巧**：树剖跳链时，优先处理顶部深度大的节点，减少循环次数。  

---

### 可视化与交互设计  
**复古游戏化演示**：  
1. **Canvas 绘制**：  
   - 树节点以像素方块表示，重链用不同颜色连接。  
   - 线段树区间更新时，对应方块动态填充颜色。  
2. **音效设计**：  
   - **跳链成功**：短促 "哔" 声。  
   - **区间更新**：连续 "滴答" 声，频率随操作复杂度变化。  
3. **自动演示模式**：  
   - 点击 "Auto Run" 后，算法自动执行路径查询，展示跳链和线段树更新。  
   - 可调节速度：慢速（学习模式）或快速（复习模式）。  

**交互示例**：  
```javascript
// 伪代码：Canvas 绘制重链跳转
function drawChain(node) {
    ctx.fillStyle = '#FF0000'; // 红色标记当前链
    while (node) {
        drawNode(node);
        node = son[node]; // 沿重儿子向下绘制
    }
}
```

---
处理用时：85.84秒
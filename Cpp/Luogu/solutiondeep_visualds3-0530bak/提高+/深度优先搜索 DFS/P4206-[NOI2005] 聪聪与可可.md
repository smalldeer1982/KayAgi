# 题目信息

# [NOI2005] 聪聪与可可

## 题目描述

在一个魔法森林里，住着一只聪明的小猫聪聪和一只可爱的小老鼠可可。虽然灰姑娘非常喜欢她们俩，但是，聪聪终究是一只猫，而可可终究是一只老鼠，同样不变的是，聪聪成天想着要吃掉可可。

一天，聪聪意外得到了一台非常有用的机器，据说是叫 GPS，对可可能准确的定位。有了这台机器，聪聪要吃可可就易如反掌了。于是，聪聪准备马上出发，去找可可。而可怜的可可还不知道大难即将临头，仍在森林里无忧无虑的玩耍。小兔子乖乖听到这件事，马上向灰姑娘报告。灰姑娘决定尽快阻止聪聪，拯救可可，可她不知道还有没有足够的时间。

整个森林可以认为是一个无向图，图中有 $N$ 个美丽的景点，景点从 $1$ 至 $N$ 编号。小动物们都只在景点休息、玩耍。在景点之间有一些路连接。

当聪聪得到 GPS 时，可可正在景点 $M$（$M \le N$）处。以后的每个时间单位，可可都会选择去相邻的景点（可能有多个）中的一个或停留在原景点不动。而去这些地方所发生的概率是相等的。假设有 $P$ 个景点与景点 $M$ 相邻，它们分别是景点 $R$、景点 $S$、……、景点 $Q$，在时刻 $T$ 可可处在景点 $M$，则在 $(T+1)$ 时刻，可可有 $1/(1 +P)$ 的可能在景点 $R$，有 $1/(1 +P)$ 的可能在景点 $S$，……，有 $1/(1 +P)$ 的可能在景点 $Q$，还有$1/(1 +P)$的可能停在景点 $M$。

我们知道，聪聪是很聪明的，所以，当她在景点 $C$ 时，她会选一个更靠近可可的景点，如果这样的景点有多个，她会选一个标号最小的景点。由于聪聪太想吃掉可可了，如果走完第一步以后仍然没吃到可可，她还可以在本段时间内再向可可走近一步。

在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位于同一个景点，则可怜的可可就被吃掉了。

灰姑娘想知道，平均情况下，聪聪几步就可能吃到可可。而你需要帮助灰姑娘尽快的找到答案。

## 说明/提示

【样例说明 1】 

开始时，聪聪和可可分别在景点 1 和景点 4。 

第一个时刻，聪聪先走，她向更靠近可可(景点 4)的景点走动，走到景点 2， 然后走到景点 3；假定忽略走路所花时间。 

可可后走，有两种可能： 第一种是走到景点 3，这样聪聪和可可到达同一个景点，可可被吃掉，步数为 $1$，概率为$0.5$。
 
第二种是停在景点 4，不被吃掉。概率为 $0.5$。

到第二个时刻，聪聪向更靠近可可(景点 4)的景点走动，只需要走一步即和 可可在同一景点。因此这种情况下聪聪会在两步吃掉可可。 所以平均的步数是 $1\times 1/2 + 2\times 1/2 =1.5$ 步。

【样例说明 2】

森林如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/8uiq0ltc.png)

对于 50%的数据，$1≤N≤50$。  
对于所有的数据，$1≤N,E≤1000$。 

## 样例 #1

### 输入

```
4 3 
1 4 
1 2 
2 3 
3 4```

### 输出

```
1.500 
```

## 样例 #2

### 输入

```
9 9 
9 3 
1 2 
2 3 
3 4 
4 5 
3 6 
4 6 
4 7 
7 8 
8 9```

### 输出

```
2.167```

# AI分析结果



### 唯一算法分类
**期望动态规划 + BFS预处理**

---

### 综合分析与结论
#### 核心算法流程
1. **BFS预处理**：计算每个节点到其他节点的最短路径，并确定聪聪的移动策略 `nxt[i][j]`  
   - 对每个节点i执行BFS，得到到所有节点的最短路  
   - 对每个节点j，确定聪聪在i时的下一步：选择相邻节点中距离j更近且编号最小的点  
2. **期望DP**：记忆化搜索 `f[i][j]` 表示聪聪在i，可可在j时的期望步数  
   - **边界条件**：i=j时返回0，聪聪两步内可到达时返回1  
   - **状态转移**：`f[i][j] = Σ(f[sec][k]/(deg[j]+1)) + 1`，其中sec是聪聪走两步后的位置，k是可可可能的移动目标  

#### 可视化设计
1. **动态网格展示**：  
   - 用Canvas绘制N×N网格，每个格子表示一个状态`(i,j)`  
   - **高亮当前状态**：红色边框标记聪聪位置，蓝色填充标记可可位置  
   - **实时显示期望值**：在格子中心显示`f[i][j]`的当前计算值  
2. **路径追踪动画**：  
   - 用黄色箭头动态绘制聪聪的移动路径`i → nxt[i][j] → sec`  
   - 用绿色虚线标记可可可能的移动方向  
3. **像素音效**：  
   - `nxt`计算完成时播放8-bit短促音效  
   - DP状态更新时触发不同音调（高音=成功转移，低音=递归调用）  
4. **自动演示模式**：  
   - 按BFS预处理→DP计算顺序自动播放，支持暂停观察状态转移细节  

---

### 题解清单（评分≥4星）
1. **FREEH（5星）**  
   - **亮点**：SPFA预处理最短路径，逻辑清晰；记忆化搜索结构简洁  
   - **代码**：双重预处理`dis`和`nxt`，状态转移用`/(p[v]+1)`处理概率  

2. **Booksnow（4星）**  
   - **亮点**：BFS预处理`step`数组的逆向实现，代码注释详细  
   - **技巧**：用`deep[to] = deep[x]+1`反向推导最短路径  

3. **钱逸凡（4星）**  
   - **亮点**：显式处理`p[p[i,j],j]`两步移动，代码模块化程度高  
   - **优化**：优先队列处理最短路，避免重复计算  

---

### 最优思路与代码实现
#### 核心代码片段（FREEH题解）
```cpp
// BFS预处理nxt数组
void SPFA(int *dis, int *nxt, int s) {
    dis[s] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int h=head[u]; h!=-1; h=e[h].next) {
            int v = e[h].t;
            if (dis[u]+1 < dis[v]) { // 更新最短路
                dis[v] = dis[u]+1;
                q.push(v);
            }
        }
    }
    // 确定nxt[i][j]
    for (int h=head[i]; h!=-1; h=e[h].next) {
        int t = e[h].t;
        if (dis[i][j]-1 == dis[t][j]) 
            nxt[i][j] = min(nxt[i][j], t);
    }
}

// 记忆化搜索期望值
double DFS(int u, int v) {
    if (u == v) return 0;
    int sec = nxt[nxt[u][v]][v];
    double sum = 0;
    for (int h=head[v]; h!=-1; h=e[h].next) // 枚举可可移动
        sum += DFS(sec, e[h].t)/(p[v]+1);
    sum += DFS(sec, v)/(p[v]+1); // 可可停留
    return sum + 1; // +1表示当前步
}
```

#### 关键优化点
- **反向BFS预处理**：从每个节点出发的BFS能快速得到全局最短路径  
- **两步移动压缩**：`sec = nxt[nxt[u][v]][v]` 将两次移动合并计算，避免重复递归  
- **概率归一化**：`/(p[v]+1)` 同时处理停留和移动的等概率事件  

---

### 同类型题目推荐
1. **P1850 换教室**（期望DP + 最短路预处理）  
2. **P4542 [ZJOI2011]营救皮卡丘**（最短路限制下的动态规划）  
3. **P6835 [CSP-S 2020] 函数调用**（拓扑排序 + 期望计算）  

---

### 可视化代码示例（JS Canvas）
```javascript
// 绘制状态网格
function drawGrid(f) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let i=0; i<N; i++) {
    for (let j=0; j<N; j++) {
      // 高亮当前处理的状态
      if (i == current_i && j == current_j) {
        ctx.fillStyle = "rgba(255,0,0,0.2)";
        ctx.fillRect(i*cell, j*cell, cell, cell);
      }
      // 绘制期望值
      ctx.fillStyle = "black";
      ctx.fillText(f[i][j].toFixed(2), i*cell+5, j*cell+15);
    }
  }
  // 绘制聪聪移动路径
  drawArrow(current_i, current_j, nxt[current_i][current_j]);
}

// 8-bit音效生成
function playSound(freq) {
  const osc = audioCtx.createOscillator();
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  osc.connect(audioCtx.destination);
  osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

---

### 个人心得摘录
- **调试陷阱**：`nxt`数组初始化为INF后，未处理无通路情况导致死循环  
- **概率归一化**：可可的停留概率容易遗漏，需显式`+1`处理  
- **优化顿悟**：发现聪聪的两次移动可以压缩为`sec = nxt[nxt[u][v]][v]`，减少递归深度  

---

### 复古像素动画设置
- **调色板**：使用FC红白机的16色方案，如#FF0000（红）、#0000FF（蓝）  
- **网格绘制**：每个节点用8×8像素块表示，箭头用2像素宽线条  
- **音效规则**：  
  - BFS完成时播放220Hz方波  
  - DP状态更新时根据结果播放440Hz（成功）或110Hz（递归）三角波  
- **自动演示**：按层序遍历状态，每步延迟500ms，用`requestAnimationFrame`实现平滑过渡

---
处理用时：94.53秒
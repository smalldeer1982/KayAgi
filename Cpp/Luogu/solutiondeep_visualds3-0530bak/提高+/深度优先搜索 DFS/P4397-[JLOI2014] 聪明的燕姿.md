# 题目信息

# [JLOI2014] 聪明的燕姿

## 题目背景

> 阴天傍晚车窗外
>
> 未来有一个人在等待
>
> 向左向右向前看
>
> 爱要拐几个弯才来
>
> 我遇见谁会有怎样的对白
>
> 我等的人他在多远的未来
>
> 我听见风来自地铁和人海
>
> 我排着队拿着爱的号码牌

## 题目描述

城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。

可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 $S$，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 $S$。

所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。

## 说明/提示

对于 $100\%$ 的数据，$k\leqslant100$，$S\leqslant2\times10^9$。

## 样例 #1

### 输入

```
42```

### 输出

```
3
20 26 41```

# AI分析结果



---

## **唯一算法分类**  
**搜索（DFS）与数论**

---

## **综合分析与结论**  

### **核心思路**
1. **数学定理**：  
   - **约数和定理**：将目标值 $S$ 分解为若干质数的幂次和乘积形式 $S = \prod (1+p_i + p_i^2 + \dots + p_i^{k_i})$  
   - **唯一分解定理**：每个数唯一分解为质因数的乘积，保证搜索路径不重复  
2. **DFS剪枝**：  
   - **质数预处理**：筛出 $\sqrt{S}$ 内的质数加速分解  
   - **两种终止条件**：  
     - $S=1$ 时记录答案  
     - $S-1$ 是质数时直接生成解（因 $(S-1)+1 = S$）  
   - **质数递增搜索**：避免重复组合（如 $2 \times 3$ 和 $3 \times 2$）  

### **算法流程**  
1. **预处理质数**：欧拉筛法生成 $\sqrt{2 \times 10^9}$ 内的质数  
2. **DFS分解**：  
   - **参数**：剩余值 $now$、当前质数索引 $x$、累计乘积 $s$  
   - **循环枚举**：对每个质数 $p$，枚举其幂次和 $1+p+p^2+\dots+p^k$  
   - **剪枝条件**：若剩余值无法被当前质数和整除则跳过  
3. **结果去重排序**：确保输出有序  

### **可视化设计思路**  
- **像素风格演示**：  
  - **质数块**：用不同颜色方块表示质数（如黄色方块=2，蓝色方块=3）  
  - **分解动画**：高亮当前处理的质数块，展示其幂次和计算过程  
  - **音效触发**：  
    - 找到解时播放「8-bit胜利音效」  
    - 质数判断失败时播放「短促错误音」  
- **步进控制**：支持单步调试观察质数选择和剩余值变化  

---

## **题解清单 (≥4星)**  

### 1. **ycyaw（★★★★★）**  
**亮点**：  
- 代码结构清晰，注释详尽  
- 剪枝逻辑完整（质数递增、平方终止条件）  
- 预处理质数到 $10^5$ 平衡效率与内存  

**关键代码**：  
```cpp
void dfs(int now, int x, int s) {
    if (now == 1) { ans[++cnt] = s; return; }
    if (pd(now-1) && now > pr[x]) ans[++cnt] = s * (now-1);
    for (int i = x; pr[i] * pr[i] <= now; i++) {
        int t = pr[i], sum = pr[i] + 1;
        for (; sum <= now; t *= pr[i], sum += t) 
            if (now % sum == 0) 
                dfs(now / sum, i + 1, s * t);
    }
}
```

---

### 2. **LaoPi（★★★★☆）**  
**亮点**：  
- 独立实现质数判断函数，优化大数判断  
- 变量命名直观（如 `now_S` 表示剩余值）  
- 输出格式处理严谨（末尾换行符控制）  

**调试心得**：  
> *"本题逐行评测，没有最后换行会全部WA" —— 强调输出格式细节的重要性*

---

### 3. **timmark（★★★★）**  
**亮点**：  
- 使用 `unordered_map` 缓存质数和组合  
- 引入 `gcd` 检查互质性避免重复解  
- 模块化设计（质数预处理与DFS分离）  

**优化技巧**：  
```cpp
// 质数和缓存加速查询
map<long long, vector<long long>> Map;
void getMap() {
    for (auto p : primes) {
        long long sum = p + 1, t = p;
        while (sum <= S_MAX) {
            Map[sum].push_back(t);
            t *= p;
            sum += t;
        }
    }
}
```

---

## **最优思路提炼**  
1. **质数预处理**：筛法范围只需到 $\sqrt{S}$，大质数单独判断  
2. **DFS参数设计**：  
   - **剩余值**：动态缩小搜索空间  
   - **质数索引**：保证质数递增，避免重复  
3. **剪枝双保险**：  
   - 质数平方超过剩余值时终止  
   - 优先处理 $S-1$ 是质数的特殊情况  

---

## **同类型题目推荐**  
1. **P1463 [POI2001] 反素数**（质因数分解与搜索）  
2. **P1730 最小密度路径**（动态规划与因数分解）  
3. **P1072 Hankson的趣味题**（数论性质与DFS结合）  

---

## **可视化实现片段**  

### **Canvas绘制核心逻辑**  
```javascript
// 伪代码：绘制质数分解过程
function drawStep(primes, currentP, remain) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    primes.forEach((p, i) => {
        // 高亮当前质数
        if (p === currentP) ctx.fillStyle = "#FF5555"; 
        else ctx.fillStyle = "#88CC88";
        ctx.fillRect(i*30, 0, 25, 25);
        ctx.fillText(p, i*30+5, 15);
    });
    // 显示剩余值
    ctx.fillText(`Remain: ${remain}`, 10, 50);
}

// 音效触发
function playSound(type) {
    const sfx = {
        found: new Audio('data:audio/wav;base64,UklGRl9...'), // 8-bit音效
        error: new Audio('data:audio/wav;base64,UklGRh...')
    };
    sfx[type].play();
}
```

---

## **个人心得摘录**  
> *"第一次提交忘记处理 $S=1$ 的情况，导致WA三个点。约数和为1的数只有1，但1的约数和是0，这个边界需要特殊处理" —— 来自题解评论区*  

> *"预处理质数到 $10^5$ 而非 $2 \times 10^9$ 的平方根，是因为更大的质数会在DFS中被单独判断" —— 空间与时间的平衡艺术*

---
处理用时：88.64秒
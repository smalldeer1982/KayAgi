# 题目信息

# 「EVOI-RD1」摘叶子

## 题目描述

某日，小 A 和小 B 在一起开心地玩着游戏。

他们找了一棵以 $1$ 节点为根节点的树，很显然，作为一棵树，总有一个或好多个叶子节点。小 A 和小 B 玩的是回合制游戏。

每次小 A 或小 B 可以选择**任意数量**的叶子节点，将其从树中摘下（每次只能摘叶子节点，每次摘的数量不限制，但**不能不摘**，更不能摘的数量超过本来叶子节点的数量）。

很显然，把一些叶子摘下后，他们的父亲节点有可能会成为新的叶子节点，这时，这些新成为叶子节点的原父亲节点也变得可以被摘取了。

现在，小 A 先摘，小 B 再摘，往复循环。把 $1$ 号节点摘下的人获胜。我们知道，小 A 和小 B 总会按最优方式进行游戏，问谁会取得胜利。

## 说明/提示

本题数据随机，只要简单分析一下性质，就很好骗分，因此本题采用**捆绑测试**。

对于 $40\%$ 的数据：$1 \leq n \leq 100$。

对于 $100\%$ 的数据：$1 \leq n \leq 10^6$，$1 \leq T \leq 10$。

本题时空限制（尤其是空间）均非常宽松，不卡常，不毒瘤，请放心食用。

## 样例 #1

### 输入

```
2
3
1 1
4
1 2 3
```

### 输出

```
1
0
```

# AI分析结果



---

## 算法分类  
**博弈论（树结构必胜态分析）**

---

## 综合分析与结论  
### 核心思路  
1. **关键观察点**  
   - 若存在叶子节点的父节点有至少两个子节点，则先手必胜（可操作至对手必败态）。  
   - 否则，需计算每个叶子到第一个分支节点的路径长度，存在奇数长度则先手必胜。  

2. **解决难点**  
   - **如何高效判断路径奇偶性**：通过递归或迭代向上遍历父节点，直到找到第一个分支节点。  
   - **优化空间**：所有题解均实现线性时间复杂度，利用树结构特性避免重复计算。  

3. **算法流程**  
   ```python  
   for 每个叶子节点:  
       if 父节点有多个子节点:  
           标记为必胜态，直接返回  
       else:  
           向上遍历直到找到分支节点，记录路径长度  
   if 存在路径长度为奇数:  
       先手胜  
   else:  
       后手胜  
   ```

### 可视化设计  
- **动画步骤**：  
  1. 绘制树结构，叶子节点用绿色标记，分支节点用红色标记。  
  2. 对每个叶子节点沿父链向上遍历，动态显示路径（如黄色高亮）。  
  3. 若路径长度变为奇数时，路径颜色变为红色并闪烁提示。  
- **复古像素风格**：  
  - 树节点用8x8像素方块表示，分支节点用红色，叶子用绿色，路径用黄色。  
  - 音效：遍历时播放“滴”声，发现奇数路径时播放胜利音效（8位风格短旋律）。  
- **交互控制**：  
  - 步进按钮控制遍历过程，速度可调。  
  - 自动演示模式下，AI自动遍历所有叶子并标记结果。  

---

## 题解清单（≥4星）  
1. **Avocadooo（5星）**  
   - **亮点**：严格数学证明，代码结构清晰，注释详细。  
   - **代码片段**：  
     ```cpp  
     for (auto leaf : leaves) {  
         int v = leaf;  
         if (Ks[fa[v]] >= 2) { flag = 1; break; }  
         int cnt = 1;  
         while (Ks[fa[v]] == 1) { cnt++; v = fa[v]; }  
         if (cnt % 2) { flag = 1; break; }  
     }  
     ```

2. **一E孤行（5星）**  
   - **亮点**：官方题解，双重DFS预处理子树大小和路径长度。  
   - **代码片段**：  
     ```cpp  
     void dfs1(int u) {  
         if (siz[u] >= 2) f[u] = 0;  
         else f[u] = f[fa[u]] + 1;  
         for (int v : children[u]) dfs1(v);  
     }  
     ```

3. **Pentiment（4星）**  
   - **亮点**：代码极简，直接暴力爬树求路径长度。  
   - **代码片段**：  
     ```cpp  
     for (int i = 1; i <= n; i++) {  
         if (deg[i]) continue;  
         int p = i, q = 1;  
         while (deg[fa[p]] == 1) q++, p = fa[p];  
         if (q & 1) { f = 1; break; }  
     }  
     ```

---

## 最优思路提炼  
1. **核心技巧**  
   - **分治分析**：将问题分解为存在分支节点和链式结构两种独立情况处理。  
   - **奇偶性转化**：将树结构博弈转化为路径长度的奇偶性博弈，类似NIM取石子。  

2. **实现优化**  
   - **预处理父节点子节点数**：避免重复计算每个节点的子节点数量。  
   - **链式路径压缩**：在遍历时直接记录路径长度，无需额外存储结构。  

---

## 同类型题推荐  
1. [P2580 树的统计](https://www.luogu.com.cn/problem/P2580)  
   - 树结构基础操作与路径统计。  
2. [P2146 树链剖分](https://www.luogu.com.cn/problem/P2146)  
   - 树链操作与动态维护。  
3. [P3401 洛谷树](https://www.luogu.com.cn/problem/P3401)  
   - 树路径异或性质与查询。  

---

## 个人心得摘录  
- **Avocadooo**：通过添加虚拟节点（Extra）分析必胜态，将复杂树结构简化为链式模型。  
- **Pentiment**：暴力爬树时发现代码可进一步优化为一次遍历，减少冗余判断。  

---

## 可视化代码示例（关键逻辑）  
```javascript  
// 树节点数据结构  
class TreeNode {  
    constructor(id, parent) {  
        this.id = id;  
        this.parent = parent;  
        this.children = [];  
    }  
}  

// 计算路径长度并标记  
function calculatePath(node) {  
    let length = 0;  
    let current = node;  
    while (current.parent && current.parent.children.length === 1) {  
        length++;  
        current = current.parent;  
    }  
    return length + 1; // 包含当前叶子节点  
}  
```

---

## 复古像素动画设计  
- **颜色方案**：  
  - 背景：深蓝 (#2C3E50)  
  - 叶子节点：亮绿 (#2ECC71)  
  - 分支节点：红色 (#E74C3C)  
  - 路径线：黄色 (#F1C40F)  

- **音效触发**：  
  - 遍历节点：短促“哔”声（Web Audio API生成方波）。  
  - 发现奇数路径：播放8-bit胜利音效（上升音阶）。  

- **自动演示逻辑**：  
  ```javascript  
  function autoPlay() {  
      let leaves = getLeaves(root);  
      for (let leaf of leaves) {  
          highlightNode(leaf);  
          let len = calculatePath(leaf);  
          if (len % 2 === 1) {  
              playVictorySound();  
              break;  
          }  
      }  
  }  
  ```

---
处理用时：112.88秒
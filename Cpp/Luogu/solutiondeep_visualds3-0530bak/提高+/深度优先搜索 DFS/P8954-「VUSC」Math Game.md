# 题目信息

# 「VUSC」Math Game

## 题目背景

**upd 2023.1.22**：新增一组 Hack 数据 by @[MCRS_lizi](https://www.luogu.com.cn/user/585805)。

远在哞利坚的 Bessie 也要在新春之际走亲访友！为了打发时间，她常和 Farmer John 玩一个有趣的数字游戏。

## 题目描述

Farmer John 有一个集合 $S$，集合初始为 $\{2,3,4,...,N\}$。

对于两个**在集合 $S$ 内的**正整数 $p,q$，我们称它们为「一对好数」当且仅当 $p^k=q(k\ge 2\land k\in\N)$。

我们将每个 $S$ 中的数看成一张**无向图**中的节点，对于每一对「好数」，我们在这两个数间连一条无向边。

Farmer John 会进行 $Q$ 次操作，操作有以下两种：

1. 给出 $x$，询问结点 $x$ 所在的连通块大小。
2. 给出 $x$，从 $S$ 中移除 $x$。**与此同时，无向图中的结点 $x$ 也被移除。**

由于 Bessie 的速度太慢了，她想要你来帮忙。

## 说明/提示

#### 【样例解释】

这是原始无向图（上面一排都是孤点）：
![](https://cdn.luogu.com.cn/upload/image_hosting/utsz04dt.png)

这是进行第一次操作 $2$ 后的无向图（删除了结点 $9$）：
![](https://cdn.luogu.com.cn/upload/image_hosting/wmexc9ks.png)

这是进行第二次操作 $2$ 后的无向图（删除了结点 $2$）：
![](https://cdn.luogu.com.cn/upload/image_hosting/9mi0l18p.png)

---

#### 【数据范围】

全部数据满足：
- $2\le N \le 10^{18}$
- $1\le Q \le 10^6$
- $x_i\in S$
- $op_i \in \{1,2\}$

测试点 $1\sim2$ 另外满足 $2\le N \le 10^5$，$1\le Q \le 10^4$。

测试点 $3\sim4$ 另外满足所有 $x_i=m^{p_i}$，其中 $m$ 为一满足 $m\ge 2 \land m\in \N$ 的**常数**。

测试点 $5\sim10$ 没有额外限制。


## 样例 #1

### 输入

```
30 6
1 6
1 4
2 9
1 3
2 2
1 16```

### 输出

```
1
4
2
2```

# AI分析结果



---

## 唯一算法分类

离线处理 + 并查集 + 时间倒流

---

## 综合分析与结论

### 核心思路
1. **连通块结构**：每个数可表示为最小基数（如2^4的基数是2），连通块由基数所有合法幂次构成  
2. **离线处理**：将删除操作倒序视为添加操作，用并查集维护连通块大小  
3. **离散化**：对涉及到的基数进行离散化，避免大范围存储  
4. **幂次合并**：通过合并因数/倍数的幂次实现连通块维护  

### 难点与解决方案
- **大范围数据**：通过预处理最小基数+离散化，将基数范围压缩到可处理规模  
- **动态连通性**：用并查集维护每个基数的幂次关系，合并时考虑因数与倍数  
- **时间复杂度**：离线倒序处理将删除复杂度转化为 O(α(n)) 的并查集操作  

### 可视化设计
1. **并查集操作动画**  
   - **颜色标记**：基数用不同底色，当前操作节点高亮为黄色  
   - **网格布局**：Canvas 绘制基数与幂次的二维网格，合并时用连线动态连接  
   - **步进控制**：可单步观察合并操作与连通块大小变化  

2. **复古像素风格**  
   - **8-bit 音效**：合并成功时播放上升音调，查询时播放短促“滴”声  
   - **自动演示**：按倒序自动执行添加操作，类似贪吃蛇自动寻路  

---

## 题解清单 (≥4星)

### 1. STUDENT00 题解 (⭐⭐⭐⭐⭐)  
**亮点**：  
- 离线处理 + 时间倒流巧妙规避动态删除  
- 离散化基数 + 二维并查集节省空间  
- 预处理因数/倍数合并逻辑清晰  

**核心代码**：  
```cpp
void unnion(int id,int x,int y) {
    x=find(id,x); y=find(id,y);
    if(x==y) return;
    fa[id][y]=x; siz[id][x] += siz[id][y];
}
// 预处理合并因数与倍数幂次
for(int j=1; j<=cnt/2; j++) {
    tmp *= num[i];
    if(del.count(tmp)) continue;
    ll cur = tmp;
    for(int k=2; k<=cnt/j; k++) {
        cur *= tmp;
        if(del.count(cur)) continue;
        unnion(i,j,j*k);
    }
}
```

### 2. enucai 题解 (⭐⭐⭐⭐)  
**亮点**：  
- 在线处理动态查询  
- 快速幂次检查与三级缓存策略（平方、立方、高次方）  
- 使用 set 实现高效存在性检查  

**核心代码**：  
```cpp
ll find(ll x) {
    if(mp.find(x)!=mp.end()) return mp[x]; // 高次方缓存
    else if(check(x)!=-1) return check(x); // 立方预处理
    else if((ll)sqrtl(x)*(ll)sqrtl(x)==x) return sqrtl(x); // 平方检查
    else return x; // 无法分解
}
```

---

## 最优思路提炼

### 关键技巧
- **基数离散化**：将大范围数值压缩为小规模 ID，通过预处理建立映射  
- **并查集二维化**：`fa[id][pow]` 表示基数 `num[id]` 的 `pow` 次方节点  
- **因数/倍数合并**：对每个幂次 j，合并其所有倍数 k*j 的节点  

### 同类问题应用
- 动态连通性问题（如[CF920E] Connected Components?）  
- 大数值范围离散化处理（如[洛谷P1840] 色板游戏）  

---

## 类似题目推荐
1. **P1197 [JSOI2008] 星球大战**  
   - 离线处理 + 倒序并查集  

2. **CF920E Connected Components?**  
   - 动态维护补图连通性  

3. **P1840 Color the Axis**  
   - 大范围离散化 + 线段树维护  

---

## 可视化算法演示

### 动画流程
1. **初始化画布**  
   - 左侧显示基数列表，右侧网格展示每个基数的幂次  
   - 基数列如：[2,3,4], 幂次行如：[1,2,3,4]  

2. **倒序处理操作**  
   - 删除操作转为添加：黄色方块从删除区移回网格  
   - 自动合并相邻幂次：红线连接 2^1 → 2^2 → 2^4  

3. **查询高亮**  
   - 查询16时，高亮基数2的4次方及其连通块（2^1, 2^2, 2^4）  

### 复古效果实现
```javascript
// 示例：像素风格绘制
function drawGrid() {
    ctx.fillStyle = "#8B8B83"; // 复古灰
    ctx.fillRect(0,0,width,height);
    
    bases.forEach((base,id) => {
        ctx.fillStyle = "#FFD700"; // 基数为金色
        ctx.fillRect(id*32, 0, 32, 32);
        
        powers.forEach(pow => {
            if(connected[id][pow]) { 
                ctx.fillStyle = "#7CFC00"; // 连通块为绿色
                ctx.fillRect(id*32, pow*32, 32, 32);
            }
        });
    });
}
```

---

**注**：以上方案结合了高效算法与趣味可视化，适合教学演示与竞赛复盘。实际代码需根据具体框架实现，核心在于并查集的状态同步与动画帧的更新逻辑。

---
处理用时：134.28秒
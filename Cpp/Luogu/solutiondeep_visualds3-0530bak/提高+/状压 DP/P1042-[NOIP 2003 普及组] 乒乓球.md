# 题目信息

# [NOIP 2003 普及组] 乒乓球

## 题目背景

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中 $11$ 分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白 $11$ 分制和 $21$ 分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

## 题目描述

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在 $11$ 分制和 $21$ 分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中 $\texttt W$ 表示华华获得一分，$\texttt L$ 表示华华对手获得一分）：

$$\texttt{WWWWWWWWWWWWWWWWWWWWWWLW}$$

在 $11$ 分制下，此时比赛的结果是华华第一局 $11$ 比 $0$ 获胜，第二局 $11$ 比 $0$ 获胜，正在进行第三局，当前比分 $1$ 比 $1$。而在 $21$ 分制下，此时比赛结果是华华第一局 $21$ 比 $0$ 获胜，正在进行第二局，比分 $2$ 比 $1$。如果一局比赛刚开始，则此时比分为 $0$ 比 $0$。直到分差大于或者等于 $2$，才一局结束。

**注意：当一局比赛结束后，下一局立刻开始**。

你的程序就是要对于一系列比赛信息的输入（$\texttt{WL}$ 形式），输出正确的结果。


## 说明/提示

每行至多 $25$ 个字母，最多有 $2500$ 行。

（注：事实上有一个测试点有 $2501$ 行数据。）

**【题目来源】**

NOIP 2003 普及组第一题

## 样例 #1

### 输入

```
WWWWWWWWWWWWWWWWWWWW
WWLWE
```

### 输出

```
11:0
11:0
1:1

21:0
2:1
```

# AI分析结果



# 算法分类
**模拟**

---

# 题解思路与核心难点

## 核心思路
1. **输入处理**：将所有比赛记录（WL序列）读取为一个字符串，遇到'E'停止
2. **双模式处理**：分别按照11分制和21分制进行两次完全相同的处理流程
3. **实时计分**：遍历字符时动态维护当前局的得分，满足以下两个条件时结束本局：
   - 任意一方得分 ≥ 当前分制值（11或21）
   - 双方分差 ≥ 2
4. **残局输出**：遍历结束后强制输出未完成的比分

## 解决难点
- **多行输入合并**：利用字符串拼接处理跨行的比赛记录
- **状态重置时机**：在输出每局结果后立即清零比分
- **边界条件处理**：正确处理刚达到分制值但分差不足2分的持续比赛场景

---

# 高星题解推荐 (≥4⭐)

1. **DengDuck（5⭐）**
   - 亮点：函数复用处理双模式，现代C++特性（range-based for）
   - 代码结构：将计分逻辑抽象为`Work`函数，参数化分制阈值
   ```cpp
   void Work(int Lim) {
       for(char i:S) {
           if(i=='W')A++; else B++;
           if(max(A,B)>=Lim && abs(A-B)>=2) {
               cout << A << ":" << B << endl;
               A = B = 0;
           }
       }
       printf("%d:%d\n\n",A,B);
       A = B = 0;    
   }
   ```

2. **qhr2023（4⭐）**
   - 亮点：三元运算符简化计分，紧凑代码风格
   - 关键实现：使用逗号运算符合并输出与重置操作
   ```cpp
   i=='W'?a++:b++;
   if (max(a,b)>=k&&abs(a-b)>=2)
       cout << a << ':' << b << '\n', a=b=0;
   ```

3. **lixianyuan（4⭐）**
   - 亮点：显式字符过滤，防御性编程
   - 特殊处理：严格过滤非WL字符，确保数据纯净
   ```cpp
   do {
       a[++len]=getchar();
   } while(a[len]!='E' && (a[len]=='W'||a[len]=='L'));
   ```

---

# 最优思路提炼

## 关键技巧
1. **函数封装**：将计分逻辑抽象为接受分制参数的函数
2. **状态机思想**：通过得分变量的增减和重置实现比分状态迁移
3. **双遍历策略**：独立处理两种分制，避免状态干扰

## 实现范式
```cpp
string S;
// 输入处理
while(cin>>C && C!='E') S += C; 

void process(int limit) {
    int a=0, b=0;
    for(char c : S) {
        c=='W' ? a++ : b++;
        if(max(a,b)>=limit && abs(a-b)>=2) {
            output_and_reset(a, b);
        }
    }
    output_remaining(a, b);
}
```

---

# 同类题目推荐
1. **P1563 玩具谜题** - 环形状态模拟
2. **P1328 生活大爆炸** - 多规则并行计分
3. **P1518 两只老虎** - 双角色协同模拟

---

# 可视化设计

## 算法动画方案
1. **双面板对比**：并排显示11分制和21分制的实时计分
2. **元素高亮**：
   - 当前处理字符：黄色闪烁边框
   - 最新得分变化：绿色（W）/红色（L）脉冲效果
3. **状态标记**：
   ```plaintext
   [11分制] 华华 10:9 对手 | 需要再得1分且分差≥2
   [21分制] 华华 20:19 对手 | 需要再得1分且分差≥2
   ```

## 复古游戏化实现
1. **像素风格**：
   - 使用16色调色板（#1A1C2C、#FF0040等经典FC配色）
   - 比分显示采用8x8像素字体
2. **音效设计**：
   - 得分音：短促的"哔"声（440Hz方波）
   - 局结束音：下滑音阶（C4→C3）
3. **自动演示**：
   - 按空格切换手动/自动模式
   - 自动模式下字符处理间隔可调（100-1000ms）

![Visualization Demo](https://via.placeholder.com/600x400/1a1c2c/ff0040?text=Pixel+Score+Display)

---

# 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;

void process(int limit, const string& records) {
    int a = 0, b = 0;
    for(char c : records) {
        c == 'W' ? a++ : b++;
        if(max(a, b) >= limit && abs(a - b) >= 2) {
            cout << a << ":" << b << endl;
            a = b = 0;
        }
    }
    cout << a << ":" << b << endl << endl;
}

int main() {
    string S, tmp;
    while(cin >> tmp && tmp.find('E') == string::npos) 
        S += tmp;
    S += tmp.substr(0, tmp.find('E'));
    
    process(11, S);
    process(21, S);
    return 0;
}
```

---
处理用时：108.93秒
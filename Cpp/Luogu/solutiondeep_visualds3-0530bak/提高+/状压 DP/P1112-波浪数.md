# 题目信息

# 波浪数

## 题目描述

波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。

类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $2\le l\le r\le 32$，$1\le L\le R\le 10^7$，$k\in \{2, 3, 4\}$。

## 样例 #1

### 输入

```
10 11 190000 960000 2```

### 输出

```
191919
383838
575757
767676
959595```

# AI分析结果



**唯一算法分类：构造法**

---

### 题解思路、算法要点与解决难点

#### 核心思路
采用逆向构造法：枚举所有可能的进制和交替数字组合，直接生成波浪数并记录其出现次数。最后遍历目标范围筛选符合要求的数。

#### 算法要点
1. **三重循环生成波浪数**  
   - 外层循环：枚举进制范围 `[a, b]`
   - 中层循环：枚举第一个交替数字 `i`（1~k-1）
   - 内层循环：枚举第二个交替数字 `j`（0~k-1，且 `i≠j`）

2. **波浪数生成逻辑**  
   交替拼接 `i` 和 `j`，每次计算当前生成的十进制值 `x`。若 `x` 在 `[L, R]` 范围内，则计数数组 `v[x]++`。

3. **优化终止条件**  
   当生成的数 `x` 超过上限 `R` 时终止生成，避免无效计算。

#### 解决难点
- **避免暴力遍历**：直接检查每个数是否符合所有进制要求的时间复杂度为 O((R-L+1)*进制数)，无法处理 1e7 的数据范围。逆向构造法将复杂度降至 O(进制数*波浪数生成次数)。
- **覆盖所有波浪形式**：通过交替拼接 `i` 和 `j` 生成任意长度的波浪数（如 `ijij` 或 `ijiji`）。

---

### 题解评分（≥4星）

#### 1. Crazily（5星）
- **亮点**：简洁高效的三重循环实现，正确处理边界条件，代码可读性强。
- **代码片段**：
  ```cpp
  while(x <= r){
    if(t%2==0) x=x*k+i;
    else x=x*k+j;
    if(x>=l&&x<=r) ++v[x];
  }
  ```

#### 2. Skywalker_David（4星）
- **亮点**：预计算波浪数位数范围优化生成次数，哈希数组节省内存。
- **代码片段**：
  ```cpp
  int make(int a, int b, int len, int k){
    int x=0;
    for(int i=1;i<=len;i++)
      x = (i&1) ? x*k+a : x*k+b;
    return x;
  }
  ```

#### 3. 小越越（4星）
- **亮点**：利用 `id^=1` 简化交替逻辑，代码紧凑。
- **代码片段**：
  ```cpp
  while(now <= r){
    v[now]++;
    now = now*i + s[id];
    id ^= 1;
  }
  ```

---

### 最优思路提炼
1. **逆向构造代替暴力验证**  
   生成所有可能波浪数并统计出现次数，避免逐个检查每个数。
2. **交替拼接生成波浪数**  
   通过交替添加两个不同数字生成任意长度的波浪数。
3. **哈希数组高效计数**  
   使用 `int v[]` 数组记录每个数的波浪重数，时间复杂度 O(1)。

---

### 同类问题与算法套路
- **数位生成问题**：如回文数生成、特定模式数的构造。
- **多进制处理**：如 LeetCode 1016（二进制子串）、HDU 4055（数位DP）。

---

### 推荐练习题
1. **洛谷 P1217**（回文质数 - 构造回文数后验证质数）
2. **LeetCode 564**（寻找最近的回文数 - 数位构造）
3. **Codeforces 914C**（数位DP与二进制特性结合）

---

### 可视化与算法演示
#### 动画设计
1. **进制选择面板**  
   用像素风格按钮显示当前进制 `k`，点击后高亮。
2. **波浪数生成过程**  
   - 左侧面板：显示当前交替数字 `i` 和 `j` 的像素图标。
   - 右侧画布：动态生成波浪数，每一步添加新数字时播放 8-bit 音效。
3. **结果标记**  
   符合目标重数的数在数轴上闪烁，配胜利音效。

#### 复古风格实现
```javascript
// 示例：生成波浪数动画
function generateWave(base, i, j) {
  let x = 0, step = 0;
  const steps = [];
  while (x <= R) {
    x = x * base + (step % 2 === 0 ? i : j);
    steps.push({x, base, step: step+1});
    if (x >= L && x <= R) {
      playSound('add'); // 8-bit 音效
      updateCounter(x);
    }
  }
  return steps;
}
```

---

### 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int v[10000005]; // 记录波浪重数

int main() {
    int a, b, L, R, k;
    cin >> a >> b >> L >> R >> k;
    for (int base = a; base <= b; base++) {
        for (int i = 1; i < base; i++) {
            for (int j = 0; j < base; j++) {
                if (i == j) continue;
                int x = 0, t = 0;
                while (true) {
                    x = x * base + (t % 2 ? j : i);
                    if (x > R) break;
                    if (x >= L) v[x]++;
                    t++;
                }
            }
        }
    }
    for (int i = L; i <= R; i++)
        if (v[i] == k) cout << i << endl;
    return 0;
}
```

---
处理用时：106.42秒
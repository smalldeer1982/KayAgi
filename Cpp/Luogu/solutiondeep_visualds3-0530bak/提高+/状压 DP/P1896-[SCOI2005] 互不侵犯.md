# 题目信息

# [SCOI2005] 互不侵犯

## 题目描述

在 $N \times N$ 的棋盘里面放 $K$ 个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 $8$ 个格子。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 9$，$0 \le K \le N\times N$。

---

$\text{upd 2018.4.25}$：数据有加强。

## 样例 #1

### 输入

```
3 2
```

### 输出

```
16
```

# AI分析结果



**唯一算法分类**：状态压缩动态规划（状压DP）

---

### **题解思路与核心难点分析**

#### **核心算法流程**
1. **预处理合法状态**：用二进制表示每行国王放置情况，筛选无相邻国王的合法状态。
2. **状态转移方程**：`dp[i][j][k] += dp[i-1][p][k - cnt[j]]`，其中：
   - `i`为当前行号，`j`为当前行状态，`p`为上一行状态。
   - `cnt[j]`为状态`j`中的国王数，`k`为累计国王总数。
3. **冲突检测**：通过位运算判断上下行是否冲突：
   ```cpp
   if (sit[j] & sit[k]) continue;           // 上下冲突
   if ((sit[j] << 1) & sit[k]) continue;    // 左上右下冲突
   if (sit[j] & (sit[k] << 1)) continue;     // 右上左下冲突
   ```

#### **解决难点**
- **状态压缩**：将每行的放置状态压缩为二进制数，减少存储和计算复杂度。
- **高效转移**：预处理合法状态和冲突关系，避免在DP过程中重复计算。

---

### **题解评分（≥4星）**

1. **KesdiaelKen（5星）**  
   - **亮点**：详细解释位运算逻辑，代码注释清晰，状态转移步骤直观。  
   - **代码片段**：  
     ```cpp
     void dfs(int he, int sum, int node) { // 预处理合法状态
         if (node >= n) { sit[++cnt] = he; gs[cnt] = sum; return; }
         dfs(he, sum, node + 1);          // 不放置当前格子
         dfs(he + (1 << node), sum + 1, node + 2); // 放置后跳过下一格
     }
     ```

2. **暗ざ之殇（4.5星）**  
   - **亮点**：图文结合展示攻击范围，通过位运算简化冲突判断。  
   - **关键代码**：  
     ```cpp
     bool valid = ((s2 | (s2<<1) | (s2>>1)) & s1) == 0; // 判断行间冲突
     ```

3. **p_b_p_b（4星）**  
   - **亮点**：优化枚举顺序避免重复计算，代码简洁高效。  
   - **代码片段**：  
     ```cpp
     for (int s = yong; s >= gs[j]; s--) 
         f[i][j][s] += f[i-1][k][s - gs[j]]; // 倒序枚举国王数
     ```

---

### **最优思路提炼**
- **预处理合法状态**：DFS生成所有无相邻国王的行状态，存储合法状态及其国王数。
- **位运算高效冲突检测**：用`&`和位移操作快速判断上下行冲突，时间复杂度O(1)。
- **滚动数组优化空间**：部分题解使用二维数组滚动更新，降低空间复杂度至O(2^n)。

---

### **类似题目推荐**
1. **P1879 玉米田**（状压DP，土地种植限制）  
2. **P2704 炮兵阵地**（三维状压，需考虑前两行状态）  
3. **P2622 关灯问题II**（状态压缩+BFS，最小操作步数）

---

### **可视化设计思路**
1. **动画演示**：  
   - **棋盘网格**：用Canvas绘制N×N网格，红色方块表示国王，灰色表示空位。  
   - **冲突高亮**：当选中某行状态时，自动标红与其冲突的上一行位置（如相邻或对角）。  
   - **步进控制**：允许用户单步执行状态转移，显示当前行的合法状态和累计国王数。

2. **复古像素风格**：  
   - **颜色方案**：使用8位色（红、灰、蓝），棋盘背景为深绿色仿FC界面。  
   - **音效设计**：  
     - **合法状态**：播放短促“滴”声（Web Audio API）。  
     - **冲突提示**：低沉“嗡”声，配合红色闪烁动画。  
   - **自动演示模式**：AI自动选择合法状态，按最优路径填充棋盘，速度可调。

---

### **关键代码片段（核心状态转移）**
```cpp
// 预处理合法状态及国王数
void dfs(int sum, int tot, int now) {
    if (now >= n) { sit[++cnt] = sum; gs[cnt] = tot; return; }
    dfs(sum, tot, now + 1);                 // 不选当前格子
    dfs(sum + (1 << now), tot + 1, now + 2);// 选当前格子，跳过下一格
}

// DP转移核心逻辑
for (int i = 2; i <= n; i++) {
    for (int j = 1; j <= cnt; j++) {        // 当前行状态
        for (int k = 1; k <= cnt; k++) {    // 上一行状态
            if (冲突检测) continue;
            for (int s = gs[j]; s <= K; s++)
                dp[i][j][s] += dp[i-1][k][s - gs[j]];
        }
    }
}
```

---

**总结**：通过预处理和位运算优化，状压DP将复杂度从O(2^(2n))降至O(n·k·S²)，其中S为合法状态数（约89）。结合可视化演示，可直观理解状态转移与冲突检测过程。

---
处理用时：97.81秒
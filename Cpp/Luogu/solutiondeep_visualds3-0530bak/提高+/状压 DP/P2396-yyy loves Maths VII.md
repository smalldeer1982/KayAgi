# 题目信息

# yyy loves Maths VII

## 题目背景

yyy 对某些数字有着情有独钟的喜爱，他叫他们为“幸运数字”；然而他作死太多，所以把自己讨厌的数字称为“厄运数字”。

## 题目描述

一群同学在和 yyy 玩一个游戏。

每次,他们会给 yyy $n$ 张卡片，卡片上有数字，所有的数字都是“幸运数字”，我们认为第 $i$ 张卡片上数字是 $a_{i}$。

每次 yyy 可以选择向前走 $a_{i}$ 步并且丢掉第 $i$ 张卡片。当他手上没有卡片的时候他就赢了。

但是呢，大家对“厄运数字”的位置布置下了陷阱，如果 yyy 停在这个格子上，那么他就输了。注意：**即使到了终点，但是这个位置是厄运数字，那么也输了。**

现在，有些同学开始问：yyy 有多大的概率会赢呢？

大家觉得这是个好问题，有人立即让 yyy 写个程序：“电脑运行速度很快！$24$ 的阶乘也不过就 $620\,448\,401\,733\,239\,439\,360\,000$，yyy 你快写个程序来算一算。”

yyy 表示很无语，他表示他不想算概率，最多算算赢的方案数，而且是对 $10^9+7$ 取模后的值。

大家都不会写程序，只好妥协。

但是这时候 yyy 为难了，$24!$ 太大了，要跑好长时间。

他时间严重不够！需要你的帮助！

某个数字可能既属于幸运数字又属于厄运数字。

## 说明/提示

- $10\%$ 的数据 $n \leq 10$；
- $50\%$ 的数据 $n \leq 23$；
- $100\%$ 的数据 $n \leq 24$，$0\le m\le 2$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
8
1 3 1 5 2 2 2 3
0```

### 输出

```
40320```

## 样例 #2

### 输入

```
24
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2
10 15
```

### 输出

```
0```

# AI分析结果



# 算法分类
**状压动态规划**

---

## 题解思路与核心分析

### 核心算法逻辑
1. **状态定义**：使用二进制状态压缩，`f[i]` 表示卡片集合为 `i` 时的合法方案数，`dis[i]` 表示集合 `i` 的卡片步数总和。
2. **转移方程**：对于状态 `i`，枚举其最后一个使用的卡片 `j`（通过 `lowbit` 快速定位），若 `dis[i]` 不是厄运数字，则 `f[i] += f[i ^ j]`。
3. **优化核心**：使用 `lowbit` 快速遍历集合中的有效位，将时间复杂度从 `O(n·2ⁿ)` 优化至 `O(2ⁿ log n)`。

### 解决难点
1. **高效枚举集合中的有效位**：传统逐位检查时间复杂度高，`lowbit` 技巧通过 `i &= i-1` 快速跳过无效位。
2. **预处理步数总和**：利用位运算性质 `dis[i] = dis[i^j] + dis[j]`（`j` 为 `lowbit(i)`）快速计算。
3. **厄运数字判断**：在状态转移前检查 `dis[i]` 是否等于厄运数字，若匹配则跳过该状态。

---

## 题解评分 (≥4星)

### Siyuan（5星）
- **亮点**：代码简洁，使用 `lowbit` 优化状态转移，预处理 `dis` 数组逻辑清晰。
- **代码关键**：
  ```cpp
  for(int i=x,j;i;i^=j) j=i&-i, upd(f[x], f[x^j]);
  ```

### RabbitHu（4.5星）
- **亮点**：通过手动循环展开和寄存器优化提升性能，适合卡常场景。
- **心得摘录**：“正常DP的瓶颈在于枚举所有位，`lowbit` 优化将常数减半”。

### Alex_Wei（4星）
- **亮点**：提出 MITM（中间相遇法）优化，时间复杂度 `O(3^(n/2))`，适合极端数据。
- **技巧**：将问题转化为子集和容斥，结合哈希表加速计算。

---

## 最优思路提炼
1. **Lowbit 优化**：通过 `j = i & -i` 快速定位当前位，循环内 `i ^= j` 移除已处理位。
2. **预处理步数总和**：利用二进制集合的叠加性质，避免重复计算。
3. **厄运数字剪枝**：在状态转移前检查条件，无效状态直接跳过。

---

## 同类型题与算法套路
1. **通用解法**：状压DP适用于元素选择顺序无关、状态空间较小的场景（如排列组合、子集覆盖）。
2. **相似题目**：
   - **CF327E**：双倍经验，同一题面。
   - **洛谷P1433**：状压DP解决旅行商问题。
   - **洛谷P1879**：状态压缩处理棋盘覆盖问题。

---

## 推荐题目
1. **P1433**：吃奶酪（状压DP经典问题）
2. **P1896**：互不侵犯（棋盘状压DP）
3. **P1171**：售货员的难题（旅行商问题变种）

---

## 代码核心实现
### 状态转移与 Lowbit 优化
```cpp
for (int i = 1; i <= msk; ++i) {
    int j = i & -i;
    dis[i] = dis[i ^ j] + dis[j];
    if (dis[i] == b1 || dis[i] == b2) continue;
    solve(i); // 内部使用 lowbit 遍历转移
}
```

### MITM 优化片段
```cpp
// 分割集合为 L 和 R，分别计算子集和
for (int s = 0; s < (1 << lenL); ++s) {
    sumL[s] = calc_sum(s, L); // L 的子集和
    cntL[__builtin_popcount(s)][sumL[s]]++;
}
```

---

## 可视化与动画设计
### 动画方案
1. **状态网格展示**：将每个二进制状态映射为 24x1 的像素网格，绿色表示已选卡片，红色表示当前处理位。
2. **步数总和更新**：右侧显示 `dis[i]` 的实时计算过程，遇到厄运数字时闪红提示。
3. **Lowbit 高亮**：用黄色边框标记当前 `lowbit` 对应的卡片位。

### 复古像素风格
- **颜色方案**：16色调色板，绿色 (#00FF00) 表示有效位，红色 (#FF0000) 表示厄运状态。
- **音效设计**：
  - **转移成功**：8-bit 上升音效（频率 800Hz）。
  - **遇到厄运**：短促下降音效（频率 200Hz）。

### 交互控制
- **步进执行**：空格键单步执行，`A` 键开启自动播放（速度可调）。
- **关卡积分**：每完成 10% 的状态转移获得积分，连续无厄运触发额外奖励。

---

## 总结
本题通过状压DP与 `lowbit` 优化的结合，高效处理了高维状态空间问题。核心在于状态压缩的灵活应用与剪枝策略的设计，其思路可推广至各类子集动态规划场景。

---
处理用时：87.64秒
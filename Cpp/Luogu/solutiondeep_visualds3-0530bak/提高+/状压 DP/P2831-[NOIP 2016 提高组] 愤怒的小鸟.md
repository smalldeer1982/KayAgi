# 题目信息

# [NOIP 2016 提高组] 愤怒的小鸟

## 题目背景

NOIP2016 提高组 D2T3

## 题目描述

Kiana 最近沉迷于一款神奇的游戏无法自拔。

简单来说，这款游戏是在一个平面上进行的。

有一架弹弓位于 $(0,0)$ 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $y=ax^2+bx$ 的曲线，其中 $a,b$ 是 Kiana 指定的参数，且必须满足 $a < 0$，$a,b$ 都是实数。

当小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。

在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小猪，其中第 $i$ 只小猪所在的坐标为 $\left(x_i,y_i \right)$。

如果某只小鸟的飞行轨迹经过了 $\left( x_i, y_i \right)$，那么第 $i$ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；

如果一只小鸟的飞行轨迹没有经过 $\left( x_i, y_i \right)$，那么这只小鸟飞行的全过程就不会对第 $i$ 只小猪产生任何影响。

例如，若两只小猪分别位于 $(1,3)$ 和 $(3,3)$，Kiana 可以选择发射一只飞行轨迹为 $y=-x^2+4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。

而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。

这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。

假设这款游戏一共有 $T$ 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。

## 说明/提示

【样例解释1】

这组数据中一共有两个关卡。

第一个关卡与【问题描述】中的情形相同，$2$ 只小猪分别位于 $(1.00,3.00)$ 和 $(3.00,3.00)$，只需发射一只飞行轨迹为 $y = -x^2 + 4x$ 的小鸟即可消灭它们。

第二个关卡中有 $5$ 只小猪，但经过观察我们可以发现它们的坐标都在抛物线 $y = -x^2 + 6x$上，故 Kiana 只需要发射一只小鸟即可消灭所有小猪。

【数据范围】

| 测试点编号 |   $n\leqslant$ |   $m=$ |  $T\leqslant$ |
| :----------: | :----------: | :----------: | :----------: |
|   $1$ |   $2$ |   $0$ |  $10$ |
|   $2$ |   $2$ |   $0$ |  $30$ |
|   $3$ |   $3$ |   $0$ |  $10$ |
|   $4$ |   $3$ |   $0$ |  $30$ |
|   $5$ |   $4$ |   $0$ |  $10$ |
|   $6$ |   $4$ |   $0$ |  $30$ |
|   $7$ |   $5$ |   $0$ |  $10$ |
|   $8$ |   $6$ |   $0$ |  $10$ |
|   $9$ |   $7$ |   $0$ |  $10$ |
|   $10$ |   $8$ |   $0$ |  $10$ |
|   $11$ |   $9$ |   $0$ |  $30$ |
|   $12$ |   $10$ |   $0$ |  $30$ |
|   $13$ |   $12$ |   $1$ |  $30$ |
|   $14$ |   $12$ |   $2$ |  $30$ |
|   $15$ |   $15$ |   $0$ |  $15$ |
|   $16$ |   $15$ |   $1$ |  $15$ |
|   $17$ |   $15$ |   $2$ |  $15$ |
|   $18$ |   $18$ |   $0$ |  $5$ |
|   $19$ |   $18$ |   $1$ |  $5$ |
|   $20$ |   $18$ |   $2$ |  $5$ |

## 样例 #1

### 输入

```
2
2 0
1.00 3.00
3.00 3.00
5 2
1.00 5.00
2.00 8.00
3.00 9.00
4.00 8.00
5.00 5.00```

### 输出

```
1
1```

## 样例 #2

### 输入

```
3
2 0
1.41 2.00
1.73 3.00
3 0
1.11 1.41
2.34 1.79
2.98 1.49
5 0
2.72 2.72
2.72 3.14
3.14 2.72
3.14 3.14
5.00 5.00```

### 输出

```
2
2
3
```

## 样例 #3

### 输入

```
1
10 0
7.16 6.28
2.02 0.38
8.33 7.78
7.68 2.09
7.46 7.86
5.77 7.44
8.24 6.72
4.42 5.11
5.42 7.79
8.15 4.99```

### 输出

```
6
```

# AI分析结果



**唯一算法分类**：状态压缩动态规划（状压DP）

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
所有题解围绕状压DP展开，核心逻辑为：
1. **状态表示**：用二进制数 `state` 表示已消灭的小猪集合。
2. **状态转移**：枚举每个抛物线覆盖的点集，更新状态。
3. **预处理优化**：计算所有合法抛物线及其覆盖的点集，减少重复计算。

#### **难点对比**
1. **状压DP的优化**：
   - **AThousandSuns**：通过固定最低未处理位（`lowunbit`）优化，将转移次数从 `O(n^2)` 降为 `O(n)`。
   - **JustinRochester**：预处理抛物线后直接枚举所有可能的状态转移，未优化转移顺序。
2. **浮点数精度处理**：
   - 多数题解使用 `1e-8` 或 `1e-6` 作为误差容忍值，如 `abs(y - ax^2 - bx) < eps`。
3. **抛物线的合法性判断**：
   - 所有题解均需验证 `a < 0`，并排除横坐标相同的两点。

#### **解决难点**
- **关键变量**：`dp[state]` 表示消灭 `state` 状态的小猪所需的最小抛物线数。
- **核心步骤**：
  1. **预处理所有合法抛物线**：枚举每对点计算 `a, b`，记录覆盖的点集。
  2. **状压DP转移**：从 `state` 出发，通过添加抛物线或单独击打未覆盖点更新 `state | new_mask`。

---

### **题解评分 (≥4星)**

1. **AThousandSuns (5星)**
   - **亮点**：严格 `O(Tn2^n)` 时间复杂度，预处理 `lowunbit` 优化转移顺序。
   - **代码**：简洁高效，预处理抛物线与状态转移分离。

2. **JustinRochester (4星)**
   - **亮点**：清晰的数学推导和浮点数精度处理，代码可读性强。
   - **代码**：通过矩阵求逆计算 `a, b`，数学细节完整。

3. **ghj1222 (4星)**
   - **亮点**：BFS实现状压DP，避免递归栈溢出风险。
   - **代码**：队列优化状态更新顺序，适合大规模数据。

---

### **最优思路或技巧提炼**

1. **固定最低未处理位优化**：
   - 在状态 `state` 中，始终优先处理最低位的未覆盖点，减少无效转移。
   - 实现：预处理 `lowunbit[state]` 快速找到最低未覆盖点。

2. **抛物线预处理**：
   - 对每对点 `(i, j)`，计算覆盖点集 `line[i][j]`，存储为二进制掩码。
   - 示例代码：
     ```cpp
     for (int i = 0; i < n; i++)
         for (int j = i + 1; j < n; j++)
             line[i][j] = compute_parabola_mask(i, j);
     ```

3. **浮点数精度处理**：
   - 使用 `1e-8` 容忍误差，避免直接比较浮点数：
     ```cpp
     bool is_zero(double x) { return abs(x) < 1e-8; }
     ```

---

### **同类型题或类似算法套路**

1. **覆盖问题**：如集合覆盖、最小顶点覆盖，使用状压DP或贪心。
2. **旅行商问题 (TSP)**：状态压缩表示访问过的城市，类似 `dp[state][last]`。

---

### **推荐相似题目**

1. **P1171 售货员的难题**：经典TSP问题，状压DP模板题。
2. **P1879 Corn Fields**：棋盘覆盖问题，状压DP典型应用。
3. **P3959 宝藏**：NOIP真题，状态压缩结合最小生成树。

---

### **个人心得摘录**

- **AThousandSuns**：  
  > “若此次转移不处理最低未覆盖点，后续仍需回头处理，导致冗余计算。固定最低位后，转移次数从 `O(n^2)` 降为 `O(n)`。”

- **wzxx**：  
  > “搜索时优先处理能覆盖最多点的抛物线，剪枝效果显著。”

---

### **可视化与算法演示**

#### **核心算法流程**
1. **Canvas 动画设计**：
   - **网格布局**：将小猪坐标映射到像素网格，被消灭的小猪标记为红色。
   - **抛物线绘制**：动态显示当前抛物线轨迹（蓝色曲线），覆盖的小猪闪烁提示。
   - **状态更新高亮**：当前处理的 `state` 用绿色边框标记，覆盖新点后变为黄色。

2. **复古像素风格**：
   - **调色板**：8位风格，小猪为8x8像素方块，抛物线为1像素宽曲线。
   - **音效**：命中时播放8位“击中”音效，状态更新时播放短促“滴”声。

3. **交互控制**：
   - **步进执行**：允许单步观察状态转移，显示当前 `dp[state]` 值和覆盖点。
   - **速度调节**：滑动条控制动画速度（0.5x~5x）。

#### **代码片段（Canvas绘制抛物线）**
```javascript
function drawParabola(a, b) {
    ctx.strokeStyle = '#00f';
    ctx.beginPath();
    for (let x = 0; x <= canvas.width; x++) {
        const y = a * x * x + b * x;
        ctx.lineTo(x, canvas.height - y);
    }
    ctx.stroke();
}
```

---

### **总结**
本题通过状压DP高效枚举抛物线覆盖方案，核心优化在于预处理和状态转移顺序控制。可视化设计应突出状态更新和抛物线覆盖过程，复古像素风格和交互控制可增强学习体验。

---
处理用时：95.30秒
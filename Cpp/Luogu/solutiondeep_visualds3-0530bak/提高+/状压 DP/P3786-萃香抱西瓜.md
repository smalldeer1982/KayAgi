# 题目信息

# 萃香抱西瓜

## 题目背景

 ![](https://cdn.luogu.com.cn/upload/pic/5565.png) 

伊吹萃香 (Ibuki Suika) 正在魔法之森漫步，突然，许多西瓜 (Suika) 从四周飞来，划出了绚丽的轨迹。虽然阵势有点恐怖，但她还是决定抱走一些西瓜。


## 题目描述

萃香所处的环境被简化为一个长为 $h$，宽为 $w$ 的网格平面。$X$ 坐标范围为 $[1,w]$，$Y$ 坐标范围为 $[1,h]$。

她初始时（第 $1$ 个时刻）站在坐标为 $(sx,sy)$ 的方格。

西瓜可能在任意一个方格出现，在每个时间单位，它们可能向任何一个方向移动，也可能静止不动。西瓜的位置和移动的轨迹是已知的。西瓜的总数为 $n$ 个，但只有 $m$ 个西瓜可以被萃香抱走，因为其他都太大了，可能会砸伤她。

整个过程会持续 $T$ 个时刻。萃香希望可以抱走全部的 $m$ 个西瓜，并且在任何时候避免与任何一个过大的西瓜处在同一位置。抱走的方式为在某个时刻，与该西瓜处于同一位置。另外，由于萃香不愿耗费过多体力到处乱跑，她每个时刻可以选择静止不动，也可以选择移动到相邻的四个格子之一，只要不越出环境边界。如果选择移动到相邻格子，则算作移动了一次。第 $1$ 个时刻萃香刚站定，无法移动。

在每个时刻，如果萃香选择移动，可以认为萃香与西瓜同时从原来的位置移到了新的位置，没有先后顺序。

萃香想要知道，不被任何一个大西瓜砸中，并得到所有的m个小西瓜的情况下，最少需要移动多少次。


## 说明/提示


### 样例说明
第 $2 \sim 4$ 个时刻萃香站着不动，在第 $6$ 个时刻，西瓜出现在萃香旁边，萃香移动到 $(3,4)$ 位置即可抱走这个西瓜。

### 数据范围和提示

本题采用捆绑测试。

Subtask $1$：具有特殊性质 A 和 B；

Subtask $2 \sim 3$：仅具有特殊性质 A；

Subtask $4 \sim 5$：仅具有特殊性质 B；

Subtask $6 \sim 10$：不具有任何一个特殊性质。

特殊性质 A：对于所有西瓜，均满足 $t1=1,t2=T+1$。
所有西瓜全程都静止在原地，不会发生移动。

特殊性质 B：$m=0$。

对于全部子任务，满足：

$1 \le x \le w,1 \le y \le h$

$1\le n \le 20,
0 \le m \le 10,
m \le n$

$1 \le h,w \le 5,
1 \le T \le 100,
1 \le t1 \le T,
2 \le t2 \le T+1,
t1< t2$


保证一个位置不会同时出现两个或两个以上西瓜。

## 样例 #1

### 输入

```
5 5 10 3 3
1 1
1 11
1
3 4
5 2
3 5
1 1
5 4
3 4
2 1
1 1
1 1
5 5```

### 输出

```
1```

# AI分析结果



## 唯一算法分类  
**状态压缩 + BFS/动态规划**

---

## 综合分析与结论  
### 核心思路与难点  
1. **状态建模**：用四维状态 `(x坐标, y坐标, 时间, 收集状态)` 表示当前状态。收集状态通过二进制位掩码记录已收集的小西瓜。  
2. **预处理**：预先计算每个时间点每个位置的西瓜类型（小西瓜对应二进制位，大西瓜标记为非法）。  
3. **转移规则**：  
   - 移动时检查是否越界或遇到大西瓜。  
   - 若当前位置有小西瓜，更新收集状态。  
4. **优化手段**：使用 BFS（SPFA）或动态规划进行状态转移，确保最短路径优先。  

### 可视化设计  
- **动画方案**：  
  - **网格绘制**：用 Canvas 绘制 5x5 网格，每个格子显示当前时间点的西瓜状态（小西瓜为绿色，大西瓜为红色）。  
  - **状态高亮**：当前萃香位置用像素风格角色表示，移动时显示轨迹。收集状态以二进制进度条形式展示。  
  - **音效**：移动时播放“脚步声”，收集小西瓜时播放“叮”声，遇到大西瓜播放“碰撞”音效。  
- **复古风格**：采用 8-bit 调色板，背景音乐为循环芯片音乐，增强游戏感。  

---

## 题解清单 (≥4星)  
### 1. 作者：s_a_b_e_r (4.5星)  
**亮点**：  
- 代码清晰，预处理西瓜位置为二进制掩码，直接位运算更新状态。  
- 使用 SPFA 队列优化，避免重复状态处理。  
- 处理初始位置合法性检查，逻辑严谨。  

### 2. 作者：老莽莽穿一切 (4星)  
**亮点**：  
- 提出三维 BFS 结合状压的思路，代码简洁。  
- 强调双端队列优化，适合边权为 0/1 的场景。  

### 3. 作者：Kazdale (4星)  
**亮点**：  
- 记忆化搜索实现动态规划，递归逻辑清晰。  
- 状态转移方程详细推导，适合理解核心逻辑。  

---

## 最优思路与技巧提炼  
1. **状态压缩**：用二进制位表示小西瓜收集状态，极大减少状态空间。  
2. **预处理优化**：将每个时间点的西瓜位置预处理为位掩码或非法标记，加速状态转移。  
3. **队列优化**：SPFA 通过队列管理状态，优先处理更优路径。  
4. **移动与等待统一处理**：通过 `移动次数 + (方向 != 0)` 统一处理移动和静止。  

---

## 类似题目推荐  
1. **P1301 魔鬼之城**：状态压缩 BFS，处理多层移动路径。  
2. **P3959 宝藏**：状压 DP 解决最优路径问题。  
3. **P1433 吃奶酪**：TSP 问题，适合练习状态压缩。  

---

## 核心代码实现  
```cpp
#include <queue>
#include <cstring>
using namespace std;

const int dx[5] = {0, 0, 0, 1, -1};
const int dy[5] = {0, 1, -1, 0, 0};
int map[7][7][109], dis[7][7][109][1<<12];
bool vis[7][7][109][1<<12];

void spfa(int sx, int sy, int T, int m) {
    queue<struct Node> q;
    memset(dis, 0x3f, sizeof(dis));
    dis[sx][sy][1][map[sx][sy][1]] = 0;
    q.push({sx, sy, 1, map[sx][sy][1]});

    while (!q.empty()) {
        auto now = q.front(); q.pop();
        vis[now.x][now.y][now.t][now.s] = 0;
        if (now.t > T) continue;

        for (int i = 0; i < 5; ++i) {
            int nx = now.x + dx[i], ny = now.y + dy[i];
            if (nx < 1 || ny < 1 || nx > h || ny > w) continue;
            if (map[nx][ny][now.t+1] == BIG_MELON) continue;

            int ns = now.s | map[nx][ny][now.t+1];
            int cost = dis[now.x][now.y][now.t][now.s] + (i != 0);
            
            if (dis[nx][ny][now.t+1][ns] > cost) {
                dis[nx][ny][now.t+1][ns] = cost;
                if (!vis[nx][ny][now.t+1][ns]) {
                    vis[nx][ny][now.t+1][ns] = 1;
                    q.push({nx, ny, now.t+1, ns});
                }
            }
        }
    }
}
```

---

## 可视化代码片段（Canvas + 音效）  
```javascript
// 绘制网格和角色
function drawGrid(ctx, state) {
    ctx.fillStyle = "#2D2D2D";
    ctx.fillRect(0, 0, 300, 300);
    for (let x = 0; x < 5; x++) {
        for (let y = 0; y < 5; y++) {
            if (state.map[x][y] === SMALL) ctx.fillStyle = "#00FF00";
            else if (state.map[x][y] === BIG) ctx.fillStyle = "#FF0000";
            else ctx.fillStyle = "#555";
            ctx.fillRect(x*60, y*60, 58, 58);
        }
    }
    // 绘制角色
    ctx.fillStyle = "#FFFF00";
    ctx.fillRect(state.player.x*60, state.player.y*60, 58, 58);
}

// 播放音效
function playSound(type) {
    const audio = new Audio();
    if (type === 'move') audio.src = 'move.wav';
    else if (type === 'collect') audio.src = 'collect.wav';
    audio.play();
}
```

---

## 个人心得摘录  
> “状压的关键在于用二进制表示状态，这题的状态设计需要结合时间和位置，预处理西瓜位置是核心。”  
> —— 调试中发现初始位置合法性检查遗漏，导致 WA。  

> “SPFA 队列优化比普通 BFS 更高效，因为状态可能被多次更新。”  
> —— 通过对比不同实现方式得出。

---
处理用时：103.29秒
# 题目信息

# 肝活动

## 题目背景

Yume 最近在玩一个名为《LoveLive! School idol festival》的音乐游戏。他之所以喜欢上这个游戏，是因为这个游戏对非洲人十分友好，即便你脸黑到抽不出好卡，还可以通过在每个月举办的两次活动中达成一定的目标来获得奖励。

## 题目描述

Yume 很喜欢这一期活动奖励卡的卡面，于是他决定要肝这一期的活动，拿到活动奖励。这一期的活动规则很特殊，玩家需要在活动规定的结束时间前，完成所有指定的歌曲（**每首歌曲只能打一次**），并获得一定的分数，就可以拿到活动奖励。如果在规定的时间前没有完成所有的歌曲，或者分数不够奖励的分数线，则不能领取活动奖励。每首歌有一个限定的奖励开放时间，玩家如果在这段时间内完成了这首歌，便可以获得一定的分数（**获得的分数 = 开放时间 - 当前已用的总时间**）。如果超出了这段时间之后再完成这首歌，就不能获得分数了。

这样的规则对 Yume 这样的老玩家来说本应是轻而易举，但不巧的是 Yume 把活动的结束时间记成了活动的开始时间，以至于当他上线跃跃欲试的时候，惊恐地发现活动已经快要结束了。现在他想知道，在剩余的时间之内，他能否完成所有的歌、达成奖励的分数线拿到活动卡。为了节省时间，他把这个问题交给了你来解决。请你根据给定的数据，帮他计算出能否在剩余的时间内达成目标。如果能，请告诉他完成每首歌曲的顺序。


## 说明/提示

对于 $0\%$ 的数据，与测试数据完全相同。

对于 $20\%$ 的数据，满足 $n \le 5$。

对于 $40\%$ 的数据，满足 $n \le 9$。

对于 $70\%$ 的数据，满足 $n \le 15$。

另有 $10\%$ 的数据满足 $\sum\limits^{n}_{i=1} T_i < t$。

对于 $100\%$ 的数据，满足 $n \le 22$，$S_i$ 的长度不超过 $50$。保证 $m,t,M_i,T_i$ 及其相加的结果都在 `int` 最大范围内。

## 样例 #1

### 输入

```
3 2 10
BokutachiwaHitotsunoHikari 3 8
Korekara 1 2
SnowHalation 2 5
```

### 输出

```
6
SnowHalation
BokutachiwaHitotsunoHikari
Korekara
```

## 样例 #2

### 输入

```
2 1 2
AoizoraJumpingHeart 1 2
TimeLapse 2 4```

### 输出

```
No Answer```

# AI分析结果



---

## 算法分类  
**状态压缩动态规划（状压 DP）**

---

## 综合分析与结论  
### 核心思路  
通过状压 DP 表示歌曲完成状态，维护最大得分与字典序最小路径。关键点包括：  
1. **状态定义**：用二进制掩码表示歌曲集合，`dp[S]` 表示完成集合 S 后的最大得分。  
2. **转移方程**：枚举最后完成的歌曲 i，计算其贡献得分（开放时间 - 当前总时间），更新最大值。  
3. **字典序处理**：用字符串记录路径，在得分相同情况下选择字典序最小的顺序。  
4. **时间优化**：预处理每个状态的总时间，避免重复计算。  

### 难点对比  
- **qinyubo**：直接计算每个状态的总时间，代码简洁但存在重复计算。  
- **cff_0102**：维护 `stime[S]` 记录总时间，减少计算量，效率更高。  
- **xie_lzh**：尝试逆向转移但路径记录存在逻辑错误，正确性存疑。  

### 可视化设计  
1. **动画方案**：  
   - 网格展示所有状态（2^22 简化展示关键路径）。  
   - 高亮当前转移状态与新增歌曲。  
   - 显示当前总时间、得分及路径字符串。  
2. **复古风格**：  
   - 8-bit 像素风格界面，状态用不同颜色方块表示。  
   - 音效：转移时播放“点击”声，得分更新时播放上升音调。  
3. **交互功能**：  
   - 步进控制观察状态转移细节。  
   - 对比不同题解的路径生成策略。  

---

## 题解清单（≥4星）  
### 1. qinyubo（⭐⭐⭐⭐）  
- **亮点**：代码简洁，直接利用字符串比较字典序。  
- **优化**：预处理总时间校验可行性。  

### 2. cff_0102（⭐⭐⭐⭐⭐）  
- **亮点**：维护 `stime[S]` 优化时间计算，`min(s, s+char)` 提升字典序处理效率。  
- **调试心得**：通过优化字符串比较方式大幅减少运行时间。  

---

## 核心代码实现  
### cff_0102 关键片段  
```cpp  
int stime[1 << 22]; // 状态总时间  
string s[1 << 22];  // 路径记录  

for (int S = 1; S < (1 << n); S++) {  
    for (int i = 0; i < n; i++) {  
        if (S & (1 << i)) {  
            int last = S ^ (1 << i);  
            int temp = dp[last] + max(0, m[i] - (stime[last] + t[i]));  
            if (temp > dp[S] || (temp == dp[S] && s[S] > s[last] + char(i))) {  
                dp[S] = temp;  
                stime[S] = stime[last] + t[i];  
                s[S] = s[last] + char(i);  
            }  
        }  
    }  
}  
```  
**实现思想**：  
- 枚举每个状态 S，逐个尝试添加歌曲 i。  
- 维护 `stime` 快速计算总时间，避免重复求和。  
- 字符串拼接直接比较字典序，确保路径最优。  

---

## 相似题目推荐  
1. **P1433 吃奶酪**（状压 DP + 几何距离）  
2. **P1879 Corn Fields G**（状压 DP + 网格状态限制）  
3. **P1171 售货员的难题**（TSP 问题，经典状压 DP）  

---

## 可视化与复古游戏化设计  
### 像素动画方案  
1. **界面布局**：  
   - 左侧：8-bit 风格网格展示状态转移（每个方块表示一个状态）。  
   - 右侧：当前状态详情（二进制掩码、总时间、得分、路径）。  
2. **动画效果**：  
   - 转移时播放 `8-bit` 音效，目标状态闪烁高亮。  
   - 路径生成时，字符逐个“掉落”形成最终顺序。  
3. **AI 自动演示**：  
   - 自动选择最优路径，模拟“AI 肝活动”过程。  
   - 积分系统：根据计算速度与正确性给予像素风格评分。  

---

**总结**：状压 DP 是解决小规模集合问题的利器，结合时间优化与路径记录技巧可高效处理复杂约束。

---
处理用时：68.18秒
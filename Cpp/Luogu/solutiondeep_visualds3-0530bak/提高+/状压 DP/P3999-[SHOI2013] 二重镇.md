# 题目信息

# [SHOI2013] 二重镇

## 题目描述

这是一个充满爱的村子，它的名字叫二重镇。在这个爱意浓浓的村子里，居民们的生活快乐又安宁。二重镇呈长条形状，可分为排成一行的 $N$ 个方格。每个格子可能是空地，也可能是小草、灌木、大树、房屋或城堡中的一种物品。每种物品都有一个等级，小草的等级是 $1$，灌木的等级是 $2$，依此类推。

你是这个村庄的建造者。你会陆续获得 $D$ 件物品，你要将它们合理地放置在村庄的空地上。你的目标是要让村子的总人气尽可能大。人气的获得规则在后面说明。关于放置的规则有以下几条：

* 第一，每件物品都必须放在一个地方，不可丢弃，如果没有空地了，游戏直接结束；

* 第二，物品可以放在一格空地上，或者临时放在仓库里。仓库同时最多只能放一件物品，它一开始是空的。只存在一个仓库；

* 第三，一旦物品放在某个空格上，只要符合条件，系统就会自动将一些物品合成一个大的物品，这是强制被动的，也是瞬间的。直到合成结束后，才能放置下一个物品。

* 第四，存放在仓库中的物品，随时可以取出放到空地上（但注意不能在合成的过程中放置），也可以一直留在仓库里。

* 第五，除非利用仓库，不然不能更改物品的放置顺序；

总结起来，这个游戏的流程就是获得一个新物品，决定是否将这个物品存入仓库，再决定将仓库中的物品或新物品放到哪个空地上，系统自动判定合成，获得人气，直到所有物品都被放置完毕，或空地用完为止。

最后是关于合成的规则。合成是自动完成的，也是强制性的。如果有连续两个或以上相邻的格子里有相同等级的物品，它们会自动合体成一个新的物品，新物品的等级比之前高一个级别。合体分三步：

* 第一步，确定有多少物品参与合成，这些物品的位置必须连在一起，等级相同。参与合体的物品会全部消失，对应的格子边成空地；

* 第二步，假设有 $A$ 个 $K$ 级物品参与合体，那么将获得$A\times 2^K$ 点人气。例如有一次五棵小草进行了合体，那么总人气就会增加 $5 \times 2^1=10$；

* 第三步，一个 $K+1$ 等级的物品会出现在一个格子里。如果 $K+1$ 大于 $5$，则跳过这步，但第二步中的人气仍然要算，第一步中的旧物品也会被清除。这个高等级的物品只会出现在参与合体的格子上。每个格子会记录最后一次被放置物品的时间，新的物品会出现在该时间最晚的那个格子里，形象地说，就是出现在最近被放置过东西的格子；

最后，请注意合成是会触发多次的，比如两个小草合成一个灌木，如果这棵灌木旁边还有其他灌木，合体将继续发生下去。

现在，给出 $N$ 和获得物品的顺序及等级，请你要合理地将这些物品放置在一个初始全是空地的村子里，使得村子最终的人气值尽可能高。当所有物品都被放置，或者某一刻村子里没空地了，你都会结束村子的建设，而此时村子里累计人气值就是你的最终成果。


## 说明/提示

对于 $30\%$ 的数据，$N=3$, $D\leq 10$。

对于 $60\%$ 的数据，$N\leq 4$, $D\leq 30$。

对于 $100\%$ 的数据，$N\leq 6$, $D\leq 100$。


## 样例 #1

### 输入

```
4 10
1132411235```

### 输出

```
168```

# AI分析结果



---

## **算法分类**  
状态压缩动态规划  

---

## **综合分析与结论**  

### **核心思路**  
所有题解均采用**状态压缩 DP**，将村庄的每个格子状态编码为六进制数，结合仓库状态构建三维 DP 状态。核心难点在于处理**多级合成触发**和**高效状态转移**。  

**关键步骤与解决难点**：  
1. **状态编码**：用六进制数表示各格子等级（0为空），如 `maruize` 的 `six[]` 数组。  
2. **预处理合成结果**：提前计算每个状态的合并后的新状态及收益（如 `maruize` 的 `val[]` 和 `to[]`）。  
3. **仓库交互逻辑**：通过第三维状态（仓库等级）处理存/取物品的顺序问题。  
4. **循环合并处理**：在放置后递归或循环处理多次合成，确保状态合法性。  

**可视化设计思路**：  
- **网格动画**：用颜色方块表示不同等级物品，红色高亮当前操作位置，黄色闪烁显示合并区域。  
- **仓库状态**：右侧独立显示仓库物品等级，绿色表示有物品，灰色为空。  
- **音效触发**：合成时播放音调递增的“升级音效”，得分时显示数值浮动。  

---

## **题解清单 (≥4星)**  

### 1. **maruize 的题解（4.5星）**  
- **亮点**：预处理合成规则，六进制状态压缩清晰，代码模块化。  
- **核心代码**：预处理 `val[]` 和 `to[]`，避免重复计算合并过程。  
```cpp
for(int i=0;i<six[n];i++){
    int cnt=0;
    for(int j=0;j<n-1;j++){
        int u=bit(i,j),k=2,s=0;
        if(u==0||u!=bit(i,j+1))continue;
        cnt++,s=u*six[j]+u*six[j+1],j++;
        if(cnt>1){val[i]=-1;break;}
        while(bit(i,j+1)==u)j++,k++,s+=u*six[j];
        val[i]=k*(1<<u),to[i]=i-s;
    }
    if(cnt==0)val[i]=0,to[i]=i;
}
```

### 2. **logeadd 的题解（4星）**  
- **亮点**：DFS 生成合法状态，分离状态转移预处理，提高效率。  
- **关键步骤**：通过 `xiao()` 函数计算合并后的状态和收益。  

### 3. **cff_0102 的题解（4星）**  
- **亮点**：记忆化搜索 + 八进制优化，递归处理合并逻辑。  
- **核心代码**：递归合并函数 `merge()`，处理多级合成。  
```cpp
int merge(int t,int x,int p,int&tot){
    if(x==0)return t;
    int a[n+2];...
    while(相邻相同等级){
        tot += 得分;
        t = 更新状态;
    }
    return t;
}
```

---

## **最优思路或技巧提炼**  

1. **状态压缩预处理**：将村庄状态编码为整数，预处理所有可能的合并结果，避免 DP 转移时重复计算。  
2. **仓库交互优先级**：在 DP 状态中单独维护仓库物品，处理存/取顺序的约束条件。  
3. **循环合并处理**：使用 `while` 循环或递归确保每次放置后触发所有可能的合成。  
4. **六进制位操作优化**：快速提取和修改状态中的某一位（如 `bit()` 函数）。  

---

## **同类型题或类似算法套路**  
- **状态压缩 + 动态规划**：如 [P3959 宝藏](https://www.luogu.com.cn/problem/P3959)（状态压缩枚举连通性）。  
- **消除类游戏模拟**：如 [P7667 合成大西瓜](https://www.luogu.com.cn/problem/P7667)。  

---

## **推荐相似题目**  
1. **P1433 吃奶酪**（状态压缩 + 最短路径）  
2. **P2831 愤怒的小鸟**（状态压缩 + 抛物线覆盖）  
3. **P3959 宝藏**（状态压缩 + 树形 DP）  

---

## **个人心得摘录**  
- **cff_0102**：强调正确理解题意，等级 5 合成后变为空地而非保持 5。  
- **shuqiang**：提到合并顺序的不同处理可能导致测试点错误。  
- **maruize**：通过 `assert` 确保预处理合成的正确性。  

---

## **可视化与算法演示**  

### **复古像素风格设计**  
- **网格绘制**：村庄显示为 6×1 的像素网格，每个格子用不同颜色表示等级（1-5），空地为黑色。  
- **动画流程**：  
  1. **放置物品**：当前物品（如等级3）从顶部下落至目标格子，触发黄色闪烁。  
  2. **合成检测**：相邻相同等级区域红色高亮，播放“滴答”音效。  
  3. **升级效果**：新等级物品从中心扩散出现，播放“升级”音效（音调随等级升高）。  
- **控制面板**：步进按钮、速度滑动条，支持回退一步观察状态变化。  

**代码片段（伪代码）**：  
```javascript
// Canvas 绘制村庄状态
function drawVillage(state) {
  for (let i = 0; i < n; i++) {
    const level = (state / Math.pow(6, i)) % 6;
    ctx.fillStyle = colors[level];
    ctx.fillRect(i * 30, 0, 28, 28);
  }
}
// 合成动画触发
function playMergeAnimation(pos, level) {
  anime({
    targets: mergeEffect,
    scale: [0, 2],
    duration: 500,
    complete: () => updateStateAfterMerge()
  });
}
```

---

**总结**：本题通过状态压缩 DP 处理动态放置与合成，预处理和高效状态转移是关键。可视化设计可结合复古像素风格和交互式动画，增强算法理解。

---
处理用时：75.96秒
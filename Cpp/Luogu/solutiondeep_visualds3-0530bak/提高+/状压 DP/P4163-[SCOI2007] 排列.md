# 题目信息

# [SCOI2007] 排列

## 题目描述

给一个数字串 $s$ 和正整数 $d$, 统计 $s$ 有多少种不同的排列能被 $d$ 整除（可以有前导 $0$）。例如 $123434$ 有 $90$ 种排列能被 $2$ 整除，其中末位为 $2$ 的有 $30$ 种，末位为 $4$ 的有  $60$ 种。

## 说明/提示

$100\%$ 的数据满足：$s$ 的长度不超过 $10$，$1\le d\le 1000$，$1\le T\le 15$。

在前三个例子中，排列分别有 $1,3,3628800$ 种，它们都是 $1$ 的倍数。

## 样例 #1

### 输入

```
7
000 1
001 1
1234567890 1
123434 2
1234 7
12345 17
12345678 29```

### 输出

```
1
3
3628800
90
3
6
1398
```

# AI分析结果



## 算法分类
动态规划（状压DP）

---

## 题解思路与核心难点

### 核心算法流程
1. **状态定义**  
   `dp[S][k]` 表示已选数字状态为 `S`（二进制位标记已选位置），当前数值模 `d` 余数为 `k` 的方案数。

2. **状态转移**  
   对于每个状态 `S`，遍历所有未选位置 `j`，计算新余数 `(k*10 + a[j])%d`，更新状态 `S|(1<<j)` 的方案数。

3. **重复排列处理**  
   - **转移时去重**：通过标记当前轮次已处理的数字值（如 `b[a[j]]`），确保同一数字在同一轮转移中只计算一次。
   - **结果修正**：统计每个数字出现次数，最终答案除以 `cnt[i]!`（阶乘）消除重复排列。

### 可视化设计
1. **动画方案**  
   - **状态网格**：用 Canvas 绘制 2D 网格，横轴表示余数 `k`（0~d-1），纵轴表示状态 `S`（二进制位）。
   - **颜色标记**：  
     - 红色高亮当前处理的状态 `S` 和余数 `k`。  
     - 绿色箭头表示转移方向（`S → S|(1<<j)`）。  
     - 黄色标记重复数字的去重逻辑（如 `b[a[j]]` 的标记过程）。  
   - **音效提示**：状态转移时播放短促的 "blip" 音效，最终答案出现时播放胜利音效。

2. **复古风格**  
   - **8位像素风**：使用 16 色调色板，状态网格以 16x16 像素块表示。  
   - **自动演示**：AI 模式自动遍历状态转移路径，速度可调（1x~5x）。  
   - **积分系统**：每完成一个状态转移得 10 分，发现重复排列扣 5 分。

---

## 题解评分（≥4星）

### 1. Monster_Qi（★★★★☆）
- **亮点**：转移时实时去重，代码清晰，预处理优化减少无效计算。
- **代码片段**：
  ```cpp
  for (int S=0; S<(1<<len)-1; S++) {
      memset(b, 0, sizeof(b));
      for (int j=1; j<=len; j++) {
          if (!(S&(1<<(j-1))) && !b[a[j]]) {
              b[a[j]] = 1;
              for (int k=0; k<d; k++) 
                  dp[S|(1<<(j-1))][(k*10+a[j])%d] += dp[S][k];
          }
      }
  }
  ```

### 2. QMQMQM4（★★★★☆）
- **亮点**：分离重复处理逻辑，代码简洁易懂，适合教学。
- **代码片段**：
  ```cpp
  // 最终答案修正重复排列
  for (int i=0; i<10; i++) 
      for (int j=2; j<=cnt[i]; j++) 
          ans /= j;
  ```

### 3. jins3599（★★★★☆）
- **亮点**：标准状压模板，去重逻辑与状态转移分离，便于移植。
- **代码片段**：
  ```cpp
  if (!vis[a[j]]) {
      vis[a[j]] = 1;
      for (int k=0; k<d; k++)
          dp[next_state][new_mod] += dp[current_state][k];
  }
  ```

---

## 最优思路提炼
1. **状压DP模板化**  
   状态压缩 + 余数转移是此类排列计数问题的通用解法，适用于模数相关的排列筛选。

2. **重复处理技巧**  
   - **转移时去重**：通过标记当前轮次已处理的数字值，避免同一数值多次转移。  
   - **结果修正**：利用阶乘消除重复排列，适合代码简洁性优先的场景。

---

## 同类题目推荐
1. [P4163 [SCOI2007]排列](https://www.luogu.com.cn/problem/P4163)（本题）
2. [P2657 [SCOI2009] windy数](https://www.luogu.com.cn/problem/P2657)  
   （数位DP + 状态压缩）
3. [P4999 烦人的数学作业](https://www.luogu.com.cn/problem/P4999)  
   （模数统计 + 状压预处理）

---

## 个人心得摘录
- **Monster_Qi**：调试中发现 `b[]` 必须在每轮状态 `S` 开始时清空，否则会漏掉某些合法转移。  
- **ppp204**：阶乘修正时忘记初始化 `cnt[]`，导致 WA，提醒注意变量作用域。

---

## 核心代码实现（Monster_Qi 风格）
```cpp
#include<iostream>
#include<cstring>
using namespace std;

int dp[1<<10][1000], T, d, a[10];
char s[11];

int main() {
    scanf("%d", &T);
    while(T--) {
        scanf("%s%d", s, &d);
        int n = strlen(s);
        for(int i=0; i<n; i++) a[i] = s[i] - '0';
        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;
        
        for(int S=0; S<(1<<n); S++) {
            bool used[10] = {0}; // 实时去重
            for(int j=0; j<n; j++) {
                if(S & (1<<j) || used[a[j]]) continue;
                used[a[j]] = true;
                for(int k=0; k<d; k++)
                    dp[S|(1<<j)][(k*10 + a[j]) % d] += dp[S][k];
            }
        }
        printf("%d\n", dp[(1<<n)-1][0]);
    }
    return 0;
}
```

---
处理用时：88.22秒
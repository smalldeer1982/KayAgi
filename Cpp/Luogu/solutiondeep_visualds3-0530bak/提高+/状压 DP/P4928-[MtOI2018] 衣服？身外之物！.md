# 题目信息

# [MtOI2018] 衣服？身外之物！

## 题目背景

gcd 有许多件衣服，每件衣服有不同的颜色。

## 题目描述

gcd 共有 $n$ 件衣服，编号为 $A_1,A_2,\cdots A_n$。

每一件衣服分别拥有颜色值和清洗时间，他在每一件衣服穿完以后都会将其送去清洗，而这件衣服当天所拥有的舒适感取决于当天的天气与他的衣服颜色值的乘积，天气值存在负数。

现给出共 $m$ 天的天气情况，求最大舒适值。

如果**必定**有一天 gcd 没有衣服穿，输出 "gcd loves her clothes!"（不含引号）。      


## 说明/提示

#### 样例解释 $1$

$A_1:Day_1,Day_3,Day_5$

$A_2:Day_2,Day_4$

### 子任务

对于 $30\%$ 的数据，$n=2$，$m=100$。

对于 $50\%$ 的数据，$n\leq 3$，$m\leq 1000$。

对于 $100\% $的数据，$n\leq 4$，$n\neq 1$，$m\leq 2000$，$y_i\leq 6$，$Maxy<m$，$|z_i|\leq 10^8$。

### 题目来源

[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T3

出题人：b2019dy

78488

## 样例 #1

### 输入

```
2 5
5 10
1 1
2 4 3 5 2```

### 输出

```
125```

# AI分析结果



# 算法分类
**状压DP**

---

# 题解思路与算法分析

### **核心思路**
题目要求选择每天穿的衣服，最大化总舒适度。每件衣服穿完后需要清洗固定天数。核心难点在于维护每件衣服的清洗剩余天数，并高效计算最优解。所有题解均采用**七进制状态压缩**表示每件衣服的清洗剩余天数，结合动态规划进行状态转移。

### **解决难点**
1. **状态表示**：用七进制数的每一位表示一件衣服的剩余清洗天数（0 表示可用），状态总数约为 $7^4=2401$。
2. **状态转移**：每天选择一件可穿的衣服后，更新其他衣服的剩余天数（减 1），当前衣服设为清洗时间。
3. **无效状态剪枝**：部分题解（如 Monster_Qi）通过滚动数组和只处理有效状态优化时间和空间。

### **关键对比**
| 题解作者       | 核心优化点                             | 时间复杂度          | 空间复杂度       |
|----------------|----------------------------------------|---------------------|------------------|
| appear_hope    | 直接枚举所有状态                       | $O(m \cdot 7^n)$    | $O(m \cdot 7^n)$ |
| Monster_Qi     | 滚动数组 + 仅处理有效状态              | $O(m \cdot S_{\text{有效}})$ | $O(7^n)$        |
| Hoks           | 七进制状态压缩 + 剪枝无贡献状态       | $O(m \cdot 7^n)$    | $O(7^n)$         |

---

# 题解评分（≥4星）

### **1. Monster_Qi（5星）**
- **亮点**：使用滚动数组和 `vector` 存储有效状态，减少无效计算。
- **代码**：通过 `get_new` 函数高效生成新状态，避免冗余计算。
- **核心代码片段**：
  ```cpp
  inline int get_new(int S, int now) {
      int ret = S;
      for (int i = 1; i <= n; i++) {
          if (i == now) ret += y[i] * poww[i];
          else if (S / poww[i] % 7 != 0) ret -= poww[i];
      }
      return ret;
  }
  ```

### **2. Hoks（4星）**
- **亮点**：状态压缩与剪枝结合，处理负数情况严谨。
- **代码**：初始化极小值为 `-1e17`，避免溢出。
- **核心代码片段**：
  ```cpp
  for(int i=0;i<cf[n+1];i++) ans=max(ans,f[op][i]);
  if(ans == -1e17) printf("gcd loves her clothes!");
  ```

### **3. wyl123ly（4星）**
- **亮点**：详细注释 + 预处理所有有效状态。
- **代码**：通过 `check` 函数过滤非法状态。
- **核心代码片段**：
  ```cpp
  if (nm(z, k)) continue;  // 剪枝不可选状态
  ```

---

# 最优思路提炼
1. **七进制状态压缩**：每位表示衣服剩余清洗天数。
2. **滚动数组优化**：空间复杂度降为 $O(7^n)$。
3. **有效状态剪枝**：仅处理可达状态，避免无效枚举。
4. **逆向状态生成**：从旧状态生成新状态，而非遍历所有可能性。

---

# 类似题目推荐
1. **[P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)**：状态压缩 TSP 问题。
2. **[P1896 互不侵犯](https://www.luogu.com.cn/problem/P1896)**：棋盘状压 DP。
3. **[P3959 宝藏](https://www.luogu.com.cn/problem/P3959)**：树形结构状态压缩。

---

# 可视化设计
### **动画方案**
1. **像素风格界面**：用 8-bit 网格展示每天的清洗状态。
2. **颜色标记**：
   - **红色**：当前处理的天数。
   - **绿色**：可穿的衣服。
   - **灰色**：正在清洗的衣服。
3. **音效触发**：
   - **选择衣服**：短促“滴”声。
   - **状态更新**：像素滚动音效。
4. **AI 自动演示**：模拟算法决策流程，展示状态转移路径。

### **关键代码（伪代码）**
```javascript
// 更新状态动画
function updateState(day, state) {
    drawGrid(state, day); // 绘制七进制状态网格
    playSound('move');    // 播放音效
}
```

---

# 题解核心代码（Monster_Qi 版本）
```cpp
inline int get_new(int S, int now) {
    int ret = S;
    for (int i = 1; i <= n; i++) {
        if (i == now) ret += y[i] * poww[i];
        else if (S / poww[i] % 7 != 0) ret -= poww[i];
    }
    return ret;
}

// 主转移逻辑
for (int i = 1; i <= m; i++) {
    memset(f[op^1], -63, sizeof(f[op^1]));
    for (auto s : v[op]) {
        for (int k = 1; k <= n; k++) {
            if ((s / poww[k]) % 7 == 0) { // 可穿
                int new_state = get_new(s, k);
                f[op^1][new_state] = max(f[op^1][new_state], f[op][s] + x[k] * z[i]);
            }
        }
    }
}
```

---
处理用时：70.26秒
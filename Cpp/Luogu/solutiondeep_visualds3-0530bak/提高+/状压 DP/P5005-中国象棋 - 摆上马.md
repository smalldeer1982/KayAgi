# 题目信息

# 中国象棋 - 摆上马

## 题目背景

~~相信自己的做法 大喊一声 I won't MLE！您就会过这道题~~

Imakf 玩腻了国际象棋，决定玩一玩中国象棋。

他发现中国象棋的马和国际象棋的马有所不同，他意识到这又可以出一道简单的问题，于是他又准备摆一摆马了

## 题目描述

Imakf 有一个 $X$ 行 $Y$ 列的棋盘，还有很多**完全相同**的马（你可以认为有无数个）。现在在棋盘上摆上马（或者不摆），求任何马无法攻击另一匹马的方案总数。

中国象棋的马和国际象棋的马不同。

![](https://cdn.luogu.com.cn/upload/pic/40761.png)

注意：实际问题中是没有兵的。

当然由于方案可能过多，请输出对 $(10^9+7)$ 取模的值


## 说明/提示

对于 100% 的数据，有 $1\le X\leq100$，$1\le Y\leq6$。

对于 20% 的数据，有 $X,Y\leq6$。

对于另外 20% 的数据，有 $X\leq20$。

对于样例 1，可以选择不摆或者摆。

对于样例 2，我有一个绝妙的解释可惜我写不下。


## 样例 #1

### 输入

```
1 1 
```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3 
```

### 输出

```
145```

# AI分析结果



## 唯一算法分类
状态压缩动态规划（状压DP）

---

## 综合分析与结论
### 核心思路与难点
**核心思路**：  
- 状态定义：`dp[i][j][k]` 表示第i行状态为j，上一行状态为k时的合法方案数  
- 转移方式：枚举当前行、上一行、上上行的状态，判断是否满足中国象棋马的攻击规则  
- 空间优化：由于行数较大（X≤100），使用滚动数组优化空间至 O(3*(2^6)^2)  

**核心难点**：  
1. 攻击范围判定：需处理马腿阻挡逻辑（若攻击方向上有相邻棋子则无法攻击）  
2. 三维状态转移：需同时考虑相邻行和隔行攻击的影响  
3. 位运算优化：需要高效的位运算技巧来快速计算攻击范围  

---

## 题解清单（≥4星）

### 1. Imakf（5星）
**亮点**：  
- 完整推导攻击范围的位运算公式（`at_bt`和`at_3`函数）  
- 详细注释了状态转移的冲突判断逻辑  
- 提供滚动数组优化方案  

**核心代码片段**：
```cpp
int at_bt(int a) { // 计算当前行对下一行的攻击范围
    int c = 0;
    for(int i=1; bit(-1,i)<=a; ++i)
        if(check(a,i)) {
            if(!check(a,i-1)) c |= 1 << (i-2);
            if(!check(a,i+1)) c |= 1 << (i+2);
        }
    return c;
}

// 转移时判断冲突
if(at_bt(k)&j || at_bt(j)&k || at_3(s,k)&j || at_3(j,k)&s)
    continue;
```

---

### 2. pyqpyq（4.5星）
**亮点**：  
- 用简洁的位运算组合判断冲突  
- 提供35行精简实现代码  
- 明确标注了判断条件对应的物理意义  

**核心判断逻辑**：
```cpp
!(((j&(~j>>1))&(k>>2)) ||  // 向右攻击未被阻挡
  ((j&(~j<<1))&(k<<2)) ||  // 向左攻击未被阻挡
  ((k&(~k>>1))&(j>>2)) ||  // 反向检查右攻击
  ((k&(~k<<1))&(j<<2)))    // 反向检查左攻击
```

---

### 3. Utilokasteinn（4星）
**亮点**：  
- 使用四次位运算完成跨行攻击判断  
- 代码结构清晰，包含详细注释  
- 直接给出可提交的完整代码  

**冲突判断实现**：
```cpp
if(i&(~i>>1)&(j>>2))continue; // 右下方攻击
if(i&(~i<<1)&(j<<2))continue; // 左下方攻击
if(j&(~j>>1)&(i>>2))continue; // 右上方攻击
if(j&(~j<<1)&(i<<2))continue; // 左上方攻击
```

---

## 最优思路与技巧提炼

### 关键思路
1. **攻击范围预处理**：  
   - 对每个状态预计算其攻击范围（如`at_bt`函数）  
   - 使用位掩码快速判断冲突：`if (attack_mask & state) != 0`  

2. **滚动数组优化**：  
   ```cpp
   for(int i=3; i<=x; ++i) {
       memset(dp[i%3], 0, sizeof(dp[i%3]));
       // 转移逻辑使用 dp[i%3], dp[(i-1)%3], dp[(i-2)%3]
   }
   ```

3. **对称性检查**：  
   - 同时检查`状态A攻击状态B`和`状态B攻击状态A`  
   - 避免漏判反向攻击情况

---

## 同类型题推荐
1. [P1896][SCOI2005] 互不侵犯（国王放置问题）  
2. [P2704][NOI2001] 炮兵阵地（三维状压DP）  
3. [P2051][AHOI2009] 中国象棋（二维状压变形）

---

## 可视化设计

### 核心动画方案
1. **棋盘渲染**：  
   - 使用Canvas绘制X×6的网格棋盘  
   - 当前行用**绿色边框**高亮，前两行用**灰色半透明**显示  
   - 马的位置用🐎图标，攻击范围用🔴标记  

2. **状态转移演示**：  
   ```javascript
   function drawState(row, state) {
       ctx.clearRect(0, row*cellSize, width, cellSize);
       for(let i=0; i<6; i++) {
           if(state & (1<<i)) 
               drawHorse(row, i);
       }
   }
   ```

3. **冲突检测高亮**：  
   - 当检测到非法攻击时，用**闪烁红框**标记冲突位置  
   - 播放短促的"哔"声提示非法状态

---

### 复古游戏化设计
1. **8-bit风格**：  
   - 使用NES经典调色板（#3C3C3C、#7C3C4C、#BCBCBC）  
   - 马图标采用8×8像素点阵设计  

2. **音效系统**：  
   - 放置成功：FC风格"叮"声（三角波生成）  
   - 冲突发生：短促"警报"声（方波50Hz）  
   - 背景音乐：《俄罗斯方块》BGM 8-bit改编版  

3. **自动演示模式**：  
   - 按F1启动AI自动演示，展示最优状态转移路径  
   - AI决策逻辑：优先选择攻击范围最小的状态

---

## 核心代码实现（Imakf优化版）
```cpp
const int MOD = 1e9+7;
int dp[3][64][64]; // 滚动数组: [当前行%3][当前状态][前一状态]

int attack_bt(int state) { // 计算对下一行的攻击范围
    int mask = 0;
    for(int i=0; i<6; ++i) 
        if(state & (1<<i)) {
            if(!(state & (1<<(i+1)))) mask |= (i+2<6) ? (1<<(i+2)) : 0;
            if(!(state & (1<<(i-1)))) mask |= (i-2>=0) ? (1<<(i-2)) : 0;
        }
    return mask;
}

bool check(int cur, int prev, int pprev) {
    if( (attack_bt(prev) & cur) || (attack_bt(cur) & prev) ) 
        return false;
    int cross = ((prev & ~cur) << 1) | ((prev & ~cur) >> 1);
    return (cross & pprev) == 0;
}

int main() {
    int X, Y; cin >> X >> Y;
    // 初始化及转移逻辑（同Imakf题解）
}
```

---
处理用时：87.10秒
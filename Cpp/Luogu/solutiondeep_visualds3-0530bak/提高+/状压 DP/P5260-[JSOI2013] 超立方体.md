# 题目信息

# [JSOI2013] 超立方体

## 题目背景

超立方体是立方体在高维空间内的拓展（其在 2 维情况下退化为正方形，1 维情况下退化成线段）。在理论计算机科学领域里，超立方体往往可以和 2 进制编码联系到一起。对理论计算机科学颇有研究的 Will 自然也会对超立方体有着
自己的思考。

![qwq](https://cdn.luogu.com.cn/upload/pic/54052.png)

上图就是在 0～4 维空间内超立方体所对应的图形。显然我们可以把超立方体的每个顶点看成一个点，每一条棱看成一条边，这样就会得到一个无向图，我们称之为超立方图。

## 题目描述

D 维空间内的超立方图有 $2^D$ 个点，我们把这些点从 $0$ 到 $2^D-1$ 依次编号。

有一个有趣而重要的充要结论是：一定存在一种编号的方式，使得图中任意两个有边相连的顶点的编号的 2 进制码中，恰好有一位不同。

在2维和3维空间内这个结论可以这样形象的理解：对于 2 维空间，我们只要把这个正方形放到第一象限内，使得 4 个顶点的坐标按逆时针顺序依次为 $(0,0),(1,0),(1,1),(0,1)$，然后再把坐标看成 2 位 2 进制数，依次将这 4 个点编号为  0,1,3,2即可。

对于 3 维空间，同样我们可以将立方体的一个顶点与原点重合，并使得所有棱均平行于坐标轴，然后分别确定这 8 个点的坐标，最后把 3 维空间内的坐标看成一个 3 位 2 进制数即可。对于 D 维空间，以此类推。

现在对于一个 $N$ 个点 $M$ 条边的无向图（每个点从 $0$ 到 $N-1$ 编号），Will 希望知道这个图是否同构于一个超立方图。

## 说明/提示

$Q~\leq~3,~N~\leq~32768,~M~\leq~1000000$

## 样例 #1

### 输入

```
3
2 2
0 1
1 0
4 4
0 1
1 2
2 0
0 3
8 12
2 3
2 6
7 6
1 7
4 1
3 4
0 2
7 3
5 6
5 1
5 0
4 0```

### 输出

```
-1
-1
0 6 1 5 4 2 3 7```

# AI分析结果



---

## **唯一算法分类**  
**图论：结构判定与构造**

---

## **题解思路与算法要点**  
### **核心思路**  
1. **初步条件验证**  
   - 检查节点数 `n` 是否为 2 的幂次（超立方图顶点数特性）。  
   - 验证边数 `m` 是否满足公式 `m = D * 2^{D-1}`（D=log₂(n)）。  

2. **构造编号方案**  
   - **原点确定**：选择任一节点（如原图 0 号）作为超立方体的“原点”，编号为 0。  
   - **坐标轴确定**：将原点的邻居依次编号为 `1, 2, 4, ..., 2^{D-1}`（二进制下仅一位为 1）。  
   - **分层构建**：通过 BFS 按深度分层，每个节点的编号为其所有深度小 1 的邻居编号的按位或。  

3. **合法性验证**  
   - 遍历所有边，检查相邻节点编号的异或结果是否为 2 的幂次（即二进制仅一位不同）。  

### **解决难点**  
- **分层构建的正确性**：利用 BFS 按深度遍历，确保每个节点的邻居中已处理的节点均来自更浅的层。  
- **编号唯一性**：通过按位或操作保证编号唯一，且符合二进制差异条件。  

---

## **题解评分**  
- **评分：★★★★☆**  
  - **思路清晰度**：明确利用超立方体的二进制性质，步骤分层合理。  
  - **代码可读性**：结构清晰，但变量命名和注释可优化（如 `a[]` 改为 `id[]`）。  
  - **优化程度**：通过 BFS 和位运算实现高效构造，复杂度为 O(N+M)。  

---

## **最优思路与技巧提炼**  
1. **二进制特性利用**  
   - 超立方体相邻节点编号的二进制差异特性是构造和验证的核心。  
   - 使用按位或操作生成新编号，确保与父节点差异仅一位。  

2. **分层 BFS 构造**  
   - 按深度分层处理，保证每个节点的父节点编号已确定。  
   - 队列管理确保处理顺序符合深度递增规律。  

3. **快速验证技巧**  
   - 异或结果是否为 2 的幂次：`(x & (x - 1)) == 0`。  

---

## **同类型题与算法套路**  
- **类似问题**：  
  1. **判断图是否为树**：验证边数 = 节点数 -1 且连通。  
  2. **判断二分图**：通过染色法验证。  
  3. **哈密尔顿回路构造**：需满足特定路径条件。  

- **通用解法**：  
  - **结构验证**：先验证必要数学条件（如节点数、边数）。  
  - **构造性算法**：通过特定规则（如二进制编码）生成合法结构。  

---

## **推荐题目**  
1. **P3388（割点判定）**：图的连通性分析。  
2. **P1330（封锁阳光大学）**：二分图染色验证。  
3. **P2731（骑马修栅栏）**：欧拉路径构造。  

---

## **个人心得摘录**  
- **调试经验**：在样例 2 中，即使 `n=4, m=4` 满足初步条件，但构造失败说明必须进行最终验证。  
- **关键顿悟**：“分层 BFS 的按位或操作能保证二进制差异” 是构造合法编号的核心。  

---

## **可视化与算法演示**  
### **动画设计**  
1. **核心流程**：  
   - **原点初始化**：高亮 0 号节点，赋予红色。  
   - **坐标轴邻居**：逐个标记原点的邻居为蓝色，并显示编号 `1, 2, 4, ...`。  
   - **BFS 过程**：队列中的节点以黄色闪烁，处理完成后变为绿色。  
   - **验证阶段**：遍历边时，若合法则边显示绿色，否则红色。  

2. **复古像素风格**：  
   - **颜色方案**：使用 8 位色调色板（红、蓝、绿、黄）。  
   - **音效设计**：  
     - **节点处理**：短促“滴”声。  
     - **验证通过**：上扬音效；失败则低沉音效。  

3. **交互功能**：  
   - **步进控制**：允许暂停/继续，调节 BFS 速度。  
   - **自动演示**：AI 自动运行，展示构造过程。  

### **代码片段（JS 动画核心）**  
```javascript
// 伪代码：BFS 动画演示  
function animateBFS() {  
  let queue = [0];  
  let speed = 1000; // 默认速度  
  let interval = setInterval(() => {  
    if (queue.length === 0) {  
      clearInterval(interval);  
      startValidation(); // 启动验证动画  
      return;  
    }  
    let u = queue.shift();  
    highlightNode(u, 'yellow'); // 高亮当前节点  
    setTimeout(() => {  
      for (let v of G[u]) {  
        if (id[v] === undefined) {  
          id[v] = calculateID(v); // 按位或计算  
          highlightNode(v, 'blue');  
          queue.push(v);  
        }  
      }  
      highlightNode(u, 'green');  
    }, speed / 2);  
  }, speed);  
}  
```  

---

## **题解代码（C++ 实现）**  
```cpp
#include<bits/stdc++.h>
#define nb 33333
using namespace std;

int q, n, m, a[nb];
vector<int> G[nb];

bool bfs(){
    memset(a, -1, sizeof(a));
    a[0] = 0;
    queue<int> q;
    for(int i = 0; i < G[0].size(); i++){
        q.push(G[0][i]);
        a[G[0][i]] = 1 << i;
    }
    while(!q.empty()){
        int u = q.front(); q.pop();
        for(int v : G[u]){
            if(a[v] != -1) continue;
            a[v] = 0;
            for(int w : G[v]){
                if(a[w] != -1) a[v] |= a[w];
            }
            q.push(v);
        }
    }
    for(int u = 0; u < n; u++){
        for(int v : G[u]){
            int tmp = a[u] ^ a[v];
            if(tmp & (tmp - 1)) return false;
        }
    }
    return true;
}

int main(){
    ios::sync_with_stdio(0);
    cin >> q;
    while(q--){
        cin >> n >> m;
        for(int i = 0; i < n; i++) G[i].clear();
        for(int i = 0, u, v; i < m; i++){
            cin >> u >> v;
            G[u].push_back(v);
            G[v].push_back(u);
        }
        int D = log2(n);
        if((n & (n-1)) || m != D * n / 2 || !bfs()){
            cout << "-1\n";
            continue;
        }
        for(int i = 0; i < n; i++) cout << a[i] << " ";
        cout << "\n";
    }
    return 0;
}
```

---
处理用时：98.05秒
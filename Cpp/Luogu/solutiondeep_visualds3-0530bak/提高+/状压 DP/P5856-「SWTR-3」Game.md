# 题目信息

# 「SWTR-3」Game

## 题目背景

小 E 在玩一个数字游戏。

## 题目描述

小 E 有 $n$ 个正整数 $a_1,a_2,\dots,a_n$。他可以进行以下操作任意次：

选择一个数 $q$，和一个集合 $S=\{d_1,d_2,\dots,d_m\}$，使得 $a_{d_1},a_{d_2},\dots,a_{d_m}$ 能被 $q$ 整除，并将 $a_{d_1},a_{d_2},\dots,a_{d_m}$ 除以 $q$。

- $q$ 要满足可以写成 $p^z$ 的形式，其中 $p$ 为质数，$z$ 为正整数。

求最少需要进行多少次操作才能将这些数变为相等的数。

## 说明/提示

#### 「样例 1 说明」

一开始的序列为 12 30 48 36 18。  
选择 $S=\{4,5\},p=3$，操作后变为 12 30 48 12 6。  
选择 $S=\{1,3,4\},p=2$，操作后变为 6 30 24 6 6。  
选择 $S=\{2\},p=5$，操作后变为 6 6 24 6 6。  
选择 $S=\{3\},p=2^2=4$，操作后变为 6 6 6 6 6。  
共 4 次操作，方法不唯一。

#### 「数据范围与约定」

**本题使用捆绑测试。**

Subtask 编号 | $n\leq$ | $a_i\leq$ | 特殊性质 | 得分
:-: | :-: | :-: | :-: | :-:
$1$ | $8$ | $50$ | $a_i$ 中有一个数为 $1$ | $13$
$2$ | $10$ | $100$ | 无 | $17$
$3$ | $10^3$ | $10^4$ | 无 | $29$
$4$ | $10^5$ | $10^6$ | 无 | $41$

对于 $100\%$ 的数据，有 $1\leq n\leq 10^5$，$1\leq a_i\leq 10^6$。

对于所有测试点，时间限制 1s，空间限制 128MB。

#### 「来源」

[Sweet Round 03 B](https://www.luogu.com.cn/contest/24755)。  
idea & solution：ET2006 & Alex_Wei。

## 样例 #1

### 输入

```
5
12 30 48 36 18
```

### 输出

```
4```

## 样例 #2

### 输入

```
10
72 81 27 90 45 45 27 99 45 18
```

### 输出

```
6```

## 样例 #3

### 输入

```
4
1 2 4 8```

### 输出

```
2```

# AI分析结果



## 算法分类
**数论（质因数分解）与动态规划**

---

## 题解思路与算法要点

### **核心思路**
1. **质因数分解**：每个数的最终相等值由其所有质因数的共同指数决定，即所有数的GCD的质因数分解指数。
2. **差状态建模**：对于每个质因数，统计各数超出公共指数的部分（差），将其转化为二进制状态。
3. **预处理最优操作次数**：通过动态规划或DFS预处理每个差状态的最小操作次数。
4. **累加结果**：对每个质因数的差状态查询预处理结果，累加得到总最小操作次数。

### **解决难点**
- **质因数分解效率**：需快速处理大范围质因数分解。
- **状态表示与优化**：将差集合转化为二进制状态，并通过位运算高效处理。
- **动态规划预处理**：覆盖所有可能差状态的最小操作次数。

---

## 题解评分（≥4星）

### **Alex_Wei的题解（5星）**
- **思路清晰**：通过DFS生成状态组合，子集传递优化。
- **代码高效**：预处理部分利用位运算快速更新状态。
- **优化明显**：通过右移处理不同公共指数的情况，避免重复计算。

### **nofind的题解（4星）**
- **DFS预处理**：生成覆盖所有可能的差组合。
- **子集更新**：确保父状态的最优解传递到子状态。
- **解释详细**：深入分析状态转换与操作策略。

### **Infiltrator的题解（4星）**
- **动态规划预处理**：枚举分解差状态，直观易理解。
- **质因数处理**：结合GCD的指数计算差状态。
- **代码结构清晰**：分步处理质因数和状态。

---

## 最优思路与技巧提炼
1. **质因数分解后独立处理**：每个质因数的操作独立，便于分治。
2. **状态压缩与动态规划**：将差集合转化为二进制状态，预处理最小操作次数。
3. **位运算优化**：通过右移操作处理公共指数，快速调整差状态。
4. **子集传递思想**：利用父状态的最优解优化子状态。

---

## 同类型题与算法套路
- **质因数分解与状态处理**：如分解阶乘质因数后的组合优化问题。
- **覆盖问题的动态规划**：如硬币覆盖问题，用最少数量的硬币覆盖特定金额。
- **二进制状态压缩**：如子集生成、状态转移优化。

---

## 相似题目推荐
1. **P1069 细胞分裂**：质因数分解与指数匹配。
2. **P2043 质因数分解**：分解质因数并统计指数。
3. **P2320 鬼谷子的钱袋**：覆盖问题的最优策略。

---

## 可视化与算法演示
### **核心算法流程**
1. **质因数分解动画**：展示每个数的质因数分解过程，高亮当前质因数。
2. **差状态生成**：用二进制位动态标记各质因数的差。
3. **动态规划状态转移**：以网格显示每个状态的最小操作次数，高亮当前处理的状态和转移路径。
4. **位运算操作**：动态演示右移操作对差状态的调整。

### **复古像素风格设计**
- **颜色方案**：使用8位色调（如青、粉、黄）区分质因数、差状态、操作步骤。
- **Canvas动画**：将质因数分解为像素块，差状态用二进制像素点表示。
- **音效设计**：
  - **分解完成**：清脆“滴”声。
  - **状态转移**：电子脉冲音效。
  - **操作计数**：8位鼓点音效。

### **交互功能**
- **步进控制**：手动/自动切换，观察每一步状态转移。
- **子集高亮**：点击状态查看其子集和父集的最优解。
- **参数调节**：调整质因数范围或差上限，观察预处理变化。

---

## 个人心得摘录
- **预处理深度限制**：DFS深度设为5，因质因数差上限有限（2^5=32 > 1e6）。
- **位运算优化陷阱**：注意右移后的状态需保留低位，避免遗漏差。
- **公共指数处理**：差状态需结合右移公共指数后的结果，避免重复计算。

---

## 核心代码片段（Alex_Wei）
```cpp
void dfs(int u, int now, int state) {
    f[state] = min(f[state], u - 1);
    if (u > 5) return;
    for (int i = now; i <= 20; i++)
        dfs(u + 1, i, (state | (state << i)) & ((1 << 20) - 1));
}

// 预处理子集最优解
for (int mid = 1; mid < (1 << base); mid <<= 1)
    for (int i = 0; i < (1 << base); i += (mid << 1))
        for (int j = 0; j < mid; j++)
            f[i + j] = min(f[i + j], f[i + j + mid]);
```

---
处理用时：313.93秒
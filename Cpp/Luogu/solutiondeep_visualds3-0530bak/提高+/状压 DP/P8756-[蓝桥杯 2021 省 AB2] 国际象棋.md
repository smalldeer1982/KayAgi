# 题目信息

# [蓝桥杯 2021 省 AB2] 国际象棋

## 题目描述

众所周知， “八皇后” 问题是求解在国际象棋棋盘上摆放 $8$ 个皇后，使得两两之间互不攻击的方案数。已经学习了很多算法的小蓝觉得 “八皇后” 问题太简单了，意犹末尽。作为一个国际象棋迷，他想研究在 $N \times M$ 的棋盘上，摆放 $K$ 个马，使得两两之间互不攻击有多少种摆放方案。由于方案数可能很大，只需计算答案除以 $1000000007$ (即 $\left.10^{9}+7\right)$ 的余数。

如下图所示，国际象棋中的马摆放在棋盘的方格内，走 “日” 字, 位于 $(x, y)$ 格的马（第 $x$ 行第 $y$ 列）可以攻击 $(x+1, y+2),(x+1, y-2),(x-1, y+2),(x-1, y-2),(x+2, y+1),(x+2, y-1),(x-2, y+1),(x-2, y-1)$ 共 $8$ 个 格子。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_68f9131d5c14c1f27e68g-12.jpg)


## 说明/提示

对于 $5 \%$ 的评测用例, $K=1$;

对于另外 $10 \%$ 的评测用例, $K=2$;

对于另外 $10 \%$ 的评测用例, $N=1$;

对于另外 $20 \%$ 的评测用例, $N, M \leq 6, K \leq 5$;

对于另外 $25 \%$ 的评测用例, $N \leq 3, M \leq 20 ， K \leq 12$;

对于所有评测用例, $1 \leq N \leq 6,1 \leq M \leq 100,1 \leq K \leq 20$。 

蓝桥杯 2021 第二轮省赛 A 组 I 题（B 组 J 题）。

## 样例 #1

### 输入

```
1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4 4 3```

### 输出

```
276```

## 样例 #3

### 输入

```
3 20 12```

### 输出

```
914051446```

# AI分析结果



## 唯一算法分类  
状态压缩动态规划（状压DP）

---

## 综合分析与结论  
### 核心思路  
1. **状态设计**：用四维DP数组 `dp[i][a][b][k]` 表示处理到第i列时，当前列状态为a、前一列状态为b，已放置k个马的方案数。  
2. **位运算判断攻击**：通过左移/右移位运算判断相邻列是否存在互相攻击的情况。  
3. **预处理优化**：预先计算每个二进制状态中的马数量（1的位数），加速动态规划过程中的计数。  

### 核心难点与解决方案  
- **多状态依赖**：马的攻击范围涉及前两列，需保存前两列的状态。通过四维DP和五层循环处理状态转移。  
- **时间复杂度优化**：通过剪枝（如提前排除非法状态）和位运算优化，将复杂度控制在可接受范围。  

### 可视化设计要点  
1. **网格动态更新**：用棋盘网格展示每列的状态，当前处理列用黄色高亮，前两列用淡蓝色标记。  
2. **位运算冲突检测**：在相邻列间绘制红色箭头，当检测到冲突时触发闪烁提示。  
3. **状态转移动画**：用半透明色块表示候选状态的转移路径，合法转移时路径变为绿色，非法则变为红色。  

---

## 题解清单 (≥4星)  
1. **gesong（5星）**  
   - 亮点：清晰的四维DP定义，通过位运算高效判断攻击，代码结构简洁。  
   - 关键代码：  
     ```cpp  
     if (!((j & (k << 2)) || (j & (k >> 2)) || (j & (l << 1)) || (j & (l >> 1))))  
     ```  

2. **Stone_Xz（4.5星）**  
   - 亮点：完整的状态转移公式推导，结合炮兵阵地题解对比，帮助理解多行状态依赖。  
   - 个人心得：强调调试时发现必须同时检查前三行的状态冲突。  

3. **Weekoder（4星）**  
   - 亮点：采用滚动数组优化空间复杂度，适合处理大范围列数（M=100）。  

---

## 核心代码实现  
```cpp  
const int mod = 1e9 + 7;
int dp[101][1<<6][1<<6][21]; // dp[列][当前状态][前状态][马数]
int cnt[1<<6]; // 预计算每个状态的马数

int main() {
    int n, m, K;
    cin >> n >> m >> K;
    // 预处理每个状态的马数
    for(int s=0; s<(1<<n); s++) 
        cnt[s] = __builtin_popcount(s);
    
    dp[0][0][0][0] = 1;
    for(int i=1; i<=m; i++) {
        for(int cur=0; cur<(1<<n); cur++) { // 当前列状态
            for(int prev=0; prev<(1<<n); prev++) { // 前一列状态
                if(cur & (prev<<2) || cur & (prev>>2)) continue; // 垂直攻击检查
                for(int pprev=0; pprev<(1<<n); pprev++) { // 前前一列状态
                    if(cur & (pprev<<1) || cur & (pprev>>1)) continue; // 斜向攻击检查
                    for(int k=cnt[cur]; k<=K; k++) {
                        dp[i][cur][prev][k] = (dp[i][cur][prev][k] + 
                                              dp[i-1][prev][pprev][k - cnt[cur]]) % mod;
                    }
                }
            }
        }
    }
    // 统计最终结果
    int ans = 0;
    for(int a=0; a<(1<<n); a++)
        for(int b=0; b<(1<<n); b++)
            ans = (ans + dp[m][a][b][K]) % mod;
    cout << ans;
}
```  

---

## 相似题目推荐  
1. **P1896 [SCOI2005] 互不侵犯** - 国王放置问题的状压DP经典题。  
2. **P2704 [NOI2001] 炮兵阵地** - 需考虑前两行状态的棋盘放置问题。  
3. **P1879 [USACO06NOV] Corn Fields G** - 状态压缩+网格限制条件。  

---

## 复古像素化动画设计  
1. **颜色方案**：  
   - 棋盘底色：#8BA8B5（浅蓝灰），马匹用#FF5555（亮红）标记。  
   - 当前处理列用#FFFACD（柠檬绸）高亮，冲突箭头用#FF0000闪烁。  

2. **Canvas绘制**：  
   ```javascript  
   function drawGrid(ctx, cols, rows, state) {
       // 绘制棋盘网格及当前状态
       for(let y=0; y<rows; y++) {
           for(let x=0; x<cols; x++) {
               const hasHorse = (state >> y) & 1;
               ctx.fillStyle = hasHorse ? '#FF5555' : '#8BA8B5'; 
               ctx.fillRect(x*20, y*20, 18, 18);
           }
       }
   }
   ```  

3. **音效触发**：  
   - 合法转移时播放8-bit "coin"音效（220Hz方波），非法时播放低沉提示音（110Hz）。  

---

## 思维拓展  
当N增大到10时，传统状压DP将难以处理。此时可考虑以下优化：  
1. **轮廓线DP**：只记录最近的几行状态，而非完整历史。  
2. **矩阵快速幂**：将状态转移表示为矩阵，利用快速幂加速计算。  
3. **对称性剪枝**：利用棋盘对称性减少状态数，如旋转、镜像等。

---
处理用时：71.97秒
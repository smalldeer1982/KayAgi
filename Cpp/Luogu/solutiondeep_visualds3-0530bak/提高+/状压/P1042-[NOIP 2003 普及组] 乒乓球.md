# 题目信息

# [NOIP 2003 普及组] 乒乓球

## 题目背景

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中 $11$ 分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白 $11$ 分制和 $21$ 分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

## 题目描述

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在 $11$ 分制和 $21$ 分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中 $\texttt W$ 表示华华获得一分，$\texttt L$ 表示华华对手获得一分）：

$$\texttt{WWWWWWWWWWWWWWWWWWWWWWLW}$$

在 $11$ 分制下，此时比赛的结果是华华第一局 $11$ 比 $0$ 获胜，第二局 $11$ 比 $0$ 获胜，正在进行第三局，当前比分 $1$ 比 $1$。而在 $21$ 分制下，此时比赛结果是华华第一局 $21$ 比 $0$ 获胜，正在进行第二局，比分 $2$ 比 $1$。如果一局比赛刚开始，则此时比分为 $0$ 比 $0$。直到分差大于或者等于 $2$，才一局结束。

**注意：当一局比赛结束后，下一局立刻开始**。

你的程序就是要对于一系列比赛信息的输入（$\texttt{WL}$ 形式），输出正确的结果。


## 说明/提示

每行至多 $25$ 个字母，最多有 $2500$ 行。

（注：事实上有一个测试点有 $2501$ 行数据。）

**【题目来源】**

NOIP 2003 普及组第一题

## 样例 #1

### 输入

```
WWWWWWWWWWWWWWWWWWWW
WWLWE
```

### 输出

```
11:0
11:0
1:1

21:0
2:1
```

# AI分析结果



## **算法分类**  
模拟

---

## **综合分析与结论**  

### **核心思路与难点**  
题目要求根据输入的胜负序列，模拟两种分制下的比赛结果。核心在于：  
1. **输入处理**：正确读取多行字符，遇到`E`时停止。  
2. **比分结算条件**：当一方得分 ≥ 当前分制（11/21）且分差 ≥ 2 时，结束当前局并输出。  
3. **未完成局的输出**：遍历完所有字符后，需输出剩余比分。  

**关键实现要点**：  
- 使用两个变量（如 `A` 和 `B`）记录当前比分。  
- 遍历字符时，根据 `W`/`L` 更新比分，并实时判断是否满足结算条件。  
- 通过函数复用逻辑，避免重复代码。  

### **题解对比与评分**  
#### **DengDuck（⭐⭐⭐⭐⭐）**  
- **亮点**：通过函数 `Work` 复用代码，逻辑清晰；使用 `string` 简化输入处理。  
- **代码片段**：  
  ```cpp
  void Work(int Lim) {
      for (char i : S) {
          if (i == 'W') A++;
          if (i == 'L') B++;
          if (max(A, B) >= Lim && abs(A - B) >= 2) {
              cout << A << ":" << B << endl;
              A = B = 0;
          }
      }
      printf("%d:%d\n\n", A, B);
      A = B = 0;    
  }
  ```

#### **qhr2023（⭐⭐⭐⭐⭐）**  
- **亮点**：代码极简，利用三目运算符更新比分；逻辑与 DengDuck 类似但更紧凑。  
- **代码片段**：  
  ```cpp
  void solve(int k) {
      int a = 0, b = 0;
      for (char i : s) {
          i == 'W' ? a++ : b++;
          if (max(a, b) >= k && abs(a - b) >= 2) {
              cout << a << ":" << b << endl;
              a = b = 0;
          }
      }
      cout << a << ":" << b << "\n\n";
  }
  ```

#### **derderhaoyue（⭐⭐⭐⭐）**  
- **亮点**：使用 `scanf` 处理输入，避免换行符干扰；函数封装清晰。  
- **代码片段**：  
  ```cpp
  void res(int fo) {
      for (int i = 1; i <= cnt; i++) {
          if (c[i] == 'W') w++;
          if (c[i] == 'L') l++;
          if (c[i] == 'E') {
              printf("%d:%d\n\n", w, l);
              w = l = 0;
              return;
          }
          if (max(w, l) >= fo && abs(w - l) >= 2) {
              printf("%d:%d\n", w, l);
              w = l = 0;
          }
      }
  }
  ```

---

## **最优思路与技巧提炼**  
1. **函数复用**：将处理不同分制的逻辑封装成函数，减少重复代码。  
2. **输入处理技巧**：使用 `while (cin >> C)` 逐字符读取，避免换行符干扰。  
3. **实时结算比分**：在遍历过程中直接判断结束条件，避免存储中间结果。  

---

## **同类型题与算法套路**  
- **通用模拟题套路**：逐字符处理输入，维护状态变量（如比分），根据条件触发事件（如结束一局）。  
- **类似题目**：  
  - **P2670** 扫雷游戏：遍历二维数组，按规则计算每个格子的值。  
  - **P1328** 生活大爆炸：模拟石头剪刀布游戏的得分变化。  
  - **P1563** 玩具谜题：循环处理指令，维护当前状态。  

---

## **推荐洛谷题目**  
1. **P2670**（扫雷游戏）- 二维数组遍历与条件判断。  
2. **P1328**（生活大爆炸）- 规则模拟与状态更新。  
3. **P1563**（玩具谜题）- 循环指令处理与状态维护。  

---

## **个人心得摘录**  
- **DengDuck**：强调函数封装的重要性，避免代码冗余。  
- **derderhaoyue**：提到 `scanf` 的空格处理技巧，避免换行符干扰输入。  

---

## **可视化与算法演示**  

### **动画设计**  
1. **核心逻辑演示**：  
   - **输入流**：字符 `W`/`L` 逐个进入队列，遇到 `E` 停止。  
   - **比分更新**：每次处理字符时，对应方得分加 1，比分面板高亮变化。  
   - **结束判断**：当满足分差条件时，触发结算动画（比分放大显示后清零）。  

2. **复古像素风格**：  
   - **颜色方案**：`W` 用绿色方块，`L` 用红色方块，比分面板为 8-bit 字体。  
   - **音效**：得分时播放短促“哔”声，结算时播放胜利音效。  

3. **交互功能**：  
   - **步进控制**：允许暂停/继续，调整播放速度。  
   - **模式切换**：一键切换 11/21 分制，对比不同规则下的比赛结果。  

**示例代码片段（JavaScript）**：  
```javascript
// Canvas 绘制比分变化
function drawScore(a, b) {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#0F0";
    ctx.fillText(`华华: ${a}`, 50, 50);
    ctx.fillStyle = "#F00";
    ctx.fillText(`对手: ${b}`, 50, 100);
}

// 触发结算时的动画
function settleScore(a, b) {
    ctx.fillStyle = "#FFF";
    ctx.fillText(`${a}:${b}`, 100, 200);
    playSound("win.wav");
}
```

---
处理用时：73.94秒
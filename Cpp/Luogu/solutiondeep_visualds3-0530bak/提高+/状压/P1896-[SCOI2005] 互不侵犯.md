# 题目信息

# [SCOI2005] 互不侵犯

## 题目描述

在 $N \times N$ 的棋盘里面放 $K$ 个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 $8$ 个格子。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 9$，$0 \le K \le N\times N$。

---

$\text{upd 2018.4.25}$：数据有加强。

## 样例 #1

### 输入

```
3 2
```

### 输出

```
16
```

# AI分析结果



---

## 唯一算法分类：状压DP

---

### **综合分析与结论**

**核心思路**  
本题通过状压DP解决，核心在于将每行国王的摆放状态压缩为二进制数，预处理合法状态后，通过位运算判断行间兼容性，最终统计合法方案数。

**关键难点与解决方案**  
1. **状态合法性判断**：通过 `x & (x<<1)` 检测相邻国王冲突，预处理所有单行合法状态。  
2. **行间兼容性判断**：使用 `(s1 & s2) || (s1<<1 & s2) || (s1>>1 & s2)` 检测上下、斜对角冲突。  
3. **空间优化**：滚动数组或仅记录有效状态，避免存储无效状态。  

**可视化设计要点**  
- **棋盘动画**：用像素棋盘展示每行状态，合法状态用绿色高亮，冲突时红色闪烁。  
- **状态转移演示**：动态绘制相邻行的兼容性检查，如箭头连接兼容状态。  
- **复古风格**：8-bit 像素音效（放置国王的 "哔" 声，冲突时的警示音），Canvas 绘制网格棋盘，自动播放时按帧步进。

---

### **题解清单（≥4星）**

1. **KesdiaelKen（5星）**  
   - **亮点**：清晰解释状态定义与转移方程，预处理合法状态，位运算优化。  
   - **代码片段**：  
     ```cpp
     void dfs(int he, int sum, int node) { // 预处理合法状态
         if (node >= n) { sit[++cnt] = he; gs[cnt] = sum; return; }
         dfs(he, sum, node + 1);
         dfs(he + (1 << node), sum + 1, node + 2);
     }
     ```

2. **暗ざ之殇（5星）**  
   - **亮点**：图文结合解释位运算判断逻辑，代码注释详细，适合萌新。  
   - **个人心得**：强调 `dp` 枚举顺序的重要性，避免状态覆盖错误。

3. **loving丶Drug（4星）**  
   - **亮点**：双重DFS预处理，精简状态转移逻辑，代码高效。  
   - **代码片段**：  
     ```cpp
     for (int j=1; j<=cnt; j++) 
         for (int l=0; l<=k; l++) 
             if (f[i-1][j][l])
                 for (int p : compatible_states[j])
                     f[i][p][l+count(p)] += f[i-1][j][l];
     ```

---

### **最优思路与技巧提炼**

1. **状态压缩与预处理**  
   - 用二进制表示每行状态，DFS或位运算枚举所有单行合法状态，存储状态数及国王数。

2. **位运算加速冲突检测**  
   - 行内冲突：`x & (x << 1) == 0`  
   - 行间冲突：上下 `s1 & s2`，斜对角 `(s1 << 1) & s2` 和 `s1 & (s2 << 1)`  

3. **滚动数组优化空间**  
   - 仅保留当前行和上一行的状态，降低空间复杂度。

---

### **类似题目推荐**

1. **P1879 [USACO06NOV]玉米田Corn Fields**  
   - 状压DP，限制条件为相邻不能种植。

2. **P2704 [NOI2001] 炮兵阵地**  
   - 扩展状压，需考虑两行间的兼容性。

3. **P4163 [SCOI2007]排列**  
   - 状态压缩结合计数，适合练习状态设计。

---

### **核心代码实现**

**预处理合法状态与转移**  
```cpp
int cnt = 0, sit[200], gs[200];
void dfs(int state, int count, int pos) {
    if (pos >= n) { sit[++cnt] = state; gs[cnt] = count; return; }
    dfs(state, count, pos + 1);
    dfs(state | (1 << pos), count + 1, pos + 2); // 隔位放置
}

// 状态转移
for (int i = 2; i <= n; ++i) {
    for (int j = 1; j <= cnt; ++j) {
        for (int k = 1; k <= cnt; ++k) {
            if ((sit[j] & sit[k]) || (sit[j] & (sit[k] << 1)) || (sit[j] & (sit[k] >> 1))) continue;
            for (int s = K; s >= gs[j]; --s)
                dp[i][j][s] += dp[i-1][k][s - gs[j]];
        }
    }
}
```

---

### **可视化与复古动画设计**

**Canvas 动画步骤**  
1. **棋盘绘制**：N×N网格，每个格子2px×2px，8-bit棕/绿色调。  
2. **状态高亮**：当前处理的行用黄色边框标记，合法状态格子亮绿色。  
3. **冲突检测**：红色闪烁冲突位置，播放短促“哔-”音效。  
4. **自动模式**：按帧步进，展示状态转移路径，右侧显示累计方案数。  

**音效触发**  
- **放置成功**：清脆“叮”声（Web Audio合成方波）。  
- **冲突发生**：低频“嗡”声，持续0.2秒。  

**交互控制**  
- 速度滑块调节步进间隔（100ms~2000ms）。  
- 暂停/继续按钮，单步执行按钮。  

---

### **调试与优化心得**

1. **位运算优先级**：`if (x & (y << 1))` 需加括号避免逻辑错误。  
2. **long long 溢出**：方案数可能极大，必须用 `long long` 存储结果。  
3. **预处理剪枝**：DFS生成状态时提前跳过非法分支，减少递归深度。  

通过合理预处理和位运算优化，将时间复杂度控制在 O(N·K·S²)，其中 S 为单行合法状态数（S≈89，N=9）。

---
处理用时：81.34秒
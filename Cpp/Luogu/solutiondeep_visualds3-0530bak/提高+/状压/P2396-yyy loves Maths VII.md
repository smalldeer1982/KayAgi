# 题目信息

# yyy loves Maths VII

## 题目背景

yyy 对某些数字有着情有独钟的喜爱，他叫他们为“幸运数字”；然而他作死太多，所以把自己讨厌的数字称为“厄运数字”。

## 题目描述

一群同学在和 yyy 玩一个游戏。

每次,他们会给 yyy $n$ 张卡片，卡片上有数字，所有的数字都是“幸运数字”，我们认为第 $i$ 张卡片上数字是 $a_{i}$。

每次 yyy 可以选择向前走 $a_{i}$ 步并且丢掉第 $i$ 张卡片。当他手上没有卡片的时候他就赢了。

但是呢，大家对“厄运数字”的位置布置下了陷阱，如果 yyy 停在这个格子上，那么他就输了。注意：**即使到了终点，但是这个位置是厄运数字，那么也输了。**

现在，有些同学开始问：yyy 有多大的概率会赢呢？

大家觉得这是个好问题，有人立即让 yyy 写个程序：“电脑运行速度很快！$24$ 的阶乘也不过就 $620\,448\,401\,733\,239\,439\,360\,000$，yyy 你快写个程序来算一算。”

yyy 表示很无语，他表示他不想算概率，最多算算赢的方案数，而且是对 $10^9+7$ 取模后的值。

大家都不会写程序，只好妥协。

但是这时候 yyy 为难了，$24!$ 太大了，要跑好长时间。

他时间严重不够！需要你的帮助！

某个数字可能既属于幸运数字又属于厄运数字。

## 说明/提示

- $10\%$ 的数据 $n \leq 10$；
- $50\%$ 的数据 $n \leq 23$；
- $100\%$ 的数据 $n \leq 24$，$0\le m\le 2$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
8
1 3 1 5 2 2 2 3
0```

### 输出

```
40320```

## 样例 #2

### 输入

```
24
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2
10 15
```

### 输出

```
0```

# AI分析结果



## 算法分类
**状态压缩动态规划**

---

## 题解思路与难点分析

### 核心算法流程
1. **状态定义**：`f[S]` 表示使用卡片集合 `S` 的合法方案数，`dis[S]` 表示集合 `S` 卡片总步数。
2. **转移方程**：若 `dis[S]` 不是厄运数字，则 `f[S] = Σf[S-{j}]`（`j` 是 `S` 中的卡片）。
3. **优化关键**：利用 `lowbit` 快速枚举集合中的每个元素，将时间复杂度从 `O(n·2ⁿ)` 优化至 `O(2ⁿ·k)`（`k` 为平均有效位数）。

### 解决难点
- **枚举优化**：传统枚举每位卡片会引入冗余循环，`lowbit` 逐个取出集合中的 1，跳过无效状态。
- **预处理距离**：利用 `dis[S] = dis[S^lowbit(S)] + dis[lowbit(S)]` 快速计算总步数。
- **厄运数字判断**：在状态转移前直接检查 `dis[S]` 是否等于厄运数字，跳过非法状态。

---

## 题解评分（≥4星）

### Siyuan（⭐⭐⭐⭐⭐）
- **亮点**：代码简洁，预处理 `dis` 数组，利用 `lowbit` 优化转移，时间复杂度严格 `O(2ⁿ·logn)`。
- **代码片段**：
  ```cpp
  void solve(int x) {
      for(int i=x,j;i;i^=j) j=i&-i, upd(f[x],f[x^j]);
  }
  ```

### RabbitHu（⭐⭐⭐⭐）
- **亮点**：通过 `while(k)` 和 `lowbit` 手动遍历所有 1 的位置，代码可读性高，实测常数更优。
- **代码片段**：
  ```cpp
  while(k){ 
      j = k & -k; 
      f[i] += f[i^j];
      k ^= j; 
  }
  ```

### Alex_Wei（⭐⭐⭐⭐）
- **亮点**：提出 MITM（中间相遇法）优化，理论复杂度 `O(3^{n/2})`，适合更大数据（如 `n=30`）。
- **核心思想**：将卡片分为两部分，用哈希表维护子集和，结合容斥原理统计答案。

---

## 最优思路提炼
1. **状压DP核心**：二进制状态表示卡片使用情况，`f[S]` 累加所有合法子状态。
2. **lowbit优化**：快速枚举集合中的每个 1，避免冗余循环。
3. **预处理距离**：利用位运算特性，`O(1)` 计算每个状态的总步数。
4. **厄运剪枝**：在状态转移前直接跳过非法位置。

---

## 类似题目
1. **CF327E**（双倍经验）
2. **洛谷P1171**（售货员的难题，状压DP经典）
3. **洛谷P1433**（吃奶酪，状压DP+几何）

---

## 可视化设计

### 动画方案
- **状态网格**：将 `0` 到 `2ⁿ-1` 的二进制状态排列为网格，高亮当前状态 `S`。
- **动态转移**：用像素箭头从 `S-{j}` 指向 `S`，标记新增卡片 `j`。
- **厄运提示**：当 `dis[S]` 匹配厄运数字时，显示红色警告动画。

### 复古像素特效
- **Canvas 绘制**：每个状态用 8x8 像素块表示，绿色表示合法，红色表示厄运。
- **音效触发**：
  - `lowbit` 选中卡片时播放 "beep" 音效。
  - 达到终局状态时播放 8-bit 胜利音乐。
- **自动演示**：按二进制顺序自动播放状态转移，速度可调。

---

## 核心代码实现
```cpp
// 状态转移核心逻辑（RabbitHu 优化版）
for(int i=1; i<(1<<n); ++i){
    int j = i & -i;
    dis[i] = dis[i^j] + dis[j];
    if(dis[i]==b1 || dis[i]==b2) continue;
    for(int k=i; k; k^=j){
        j = k & -k;
        f[i] = (f[i] + f[i^j]) % MOD;
    }
}
```

---

## 总结
本题解通过状压DP与 `lowbit` 优化，高效处理了 `n≤24` 的排列方案问题。关键点在于快速枚举合法转移路径，结合预处理和剪枝策略，将理论复杂度降至可接受范围。对于更大规模数据，可结合 MITM 或哈希优化进一步扩展。

---
处理用时：77.47秒
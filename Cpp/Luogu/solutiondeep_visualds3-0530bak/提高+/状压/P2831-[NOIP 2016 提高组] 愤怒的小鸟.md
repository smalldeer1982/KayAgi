# 题目信息

# [NOIP 2016 提高组] 愤怒的小鸟

## 题目背景

NOIP2016 提高组 D2T3

## 题目描述

Kiana 最近沉迷于一款神奇的游戏无法自拔。

简单来说，这款游戏是在一个平面上进行的。

有一架弹弓位于 $(0,0)$ 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $y=ax^2+bx$ 的曲线，其中 $a,b$ 是 Kiana 指定的参数，且必须满足 $a < 0$，$a,b$ 都是实数。

当小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。

在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小猪，其中第 $i$ 只小猪所在的坐标为 $\left(x_i,y_i \right)$。

如果某只小鸟的飞行轨迹经过了 $\left( x_i, y_i \right)$，那么第 $i$ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；

如果一只小鸟的飞行轨迹没有经过 $\left( x_i, y_i \right)$，那么这只小鸟飞行的全过程就不会对第 $i$ 只小猪产生任何影响。

例如，若两只小猪分别位于 $(1,3)$ 和 $(3,3)$，Kiana 可以选择发射一只飞行轨迹为 $y=-x^2+4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。

而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。

这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。

假设这款游戏一共有 $T$ 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。

## 说明/提示

【样例解释1】

这组数据中一共有两个关卡。

第一个关卡与【问题描述】中的情形相同，$2$ 只小猪分别位于 $(1.00,3.00)$ 和 $(3.00,3.00)$，只需发射一只飞行轨迹为 $y = -x^2 + 4x$ 的小鸟即可消灭它们。

第二个关卡中有 $5$ 只小猪，但经过观察我们可以发现它们的坐标都在抛物线 $y = -x^2 + 6x$上，故 Kiana 只需要发射一只小鸟即可消灭所有小猪。

【数据范围】

| 测试点编号 |   $n\leqslant$ |   $m=$ |  $T\leqslant$ |
| :----------: | :----------: | :----------: | :----------: |
|   $1$ |   $2$ |   $0$ |  $10$ |
|   $2$ |   $2$ |   $0$ |  $30$ |
|   $3$ |   $3$ |   $0$ |  $10$ |
|   $4$ |   $3$ |   $0$ |  $30$ |
|   $5$ |   $4$ |   $0$ |  $10$ |
|   $6$ |   $4$ |   $0$ |  $30$ |
|   $7$ |   $5$ |   $0$ |  $10$ |
|   $8$ |   $6$ |   $0$ |  $10$ |
|   $9$ |   $7$ |   $0$ |  $10$ |
|   $10$ |   $8$ |   $0$ |  $10$ |
|   $11$ |   $9$ |   $0$ |  $30$ |
|   $12$ |   $10$ |   $0$ |  $30$ |
|   $13$ |   $12$ |   $1$ |  $30$ |
|   $14$ |   $12$ |   $2$ |  $30$ |
|   $15$ |   $15$ |   $0$ |  $15$ |
|   $16$ |   $15$ |   $1$ |  $15$ |
|   $17$ |   $15$ |   $2$ |  $15$ |
|   $18$ |   $18$ |   $0$ |  $5$ |
|   $19$ |   $18$ |   $1$ |  $5$ |
|   $20$ |   $18$ |   $2$ |  $5$ |

## 样例 #1

### 输入

```
2
2 0
1.00 3.00
3.00 3.00
5 2
1.00 5.00
2.00 8.00
3.00 9.00
4.00 8.00
5.00 5.00```

### 输出

```
1
1```

## 样例 #2

### 输入

```
3
2 0
1.41 2.00
1.73 3.00
3 0
1.11 1.41
2.34 1.79
2.98 1.49
5 0
2.72 2.72
2.72 3.14
3.14 2.72
3.14 3.14
5.00 5.00```

### 输出

```
2
2
3
```

## 样例 #3

### 输入

```
1
10 0
7.16 6.28
2.02 0.38
8.33 7.78
7.68 2.09
7.46 7.86
5.77 7.44
8.24 6.72
4.42 5.11
5.42 7.79
8.15 4.99```

### 输出

```
6
```

# AI分析结果



### 唯一算法分类
**状压DP**

---

### 综合分析与结论
#### 核心思路与难点
**问题核心**：用最少的抛物线覆盖所有点，抛物线需满足 \( y = ax^2 + bx \) 且 \( a < 0 \)。  
**算法核心**：通过状压DP表示猪的覆盖状态，预处理所有合法抛物线，优化状态转移。  
**关键难点**：
1. **浮点精度处理**：抛物线参数计算需处理浮点误差（如使用 \( \epsilon = 10^{-8} \) 判等）。
2. **抛物线预处理**：枚举每对猪计算抛物线参数，并记录覆盖的猪集合。
3. **状态转移优化**：仅处理当前状态的最低未覆盖点，避免冗余转移。

#### 可视化设计思路
- **状态转移动画**：以网格展示每个二进制状态，高亮当前处理的状态及覆盖的新猪。
- **复古像素风格**：使用8位色块表示猪，抛物线轨迹用动态像素线绘制，音效提示状态更新。
- **交互控制**：支持步进/暂停，展示抛物线计算过程及覆盖范围。

---

### 题解清单（评分 ≥4星）
1. **AThousandSuns（5星）**  
   **亮点**：严格 \( O(Tn2^n) \) 复杂度，预处理最低未覆盖点优化转移。  
   **关键代码**：
   ```cpp
   for(int i=0;i<(1<<n);i++){
       int j=lowunbit[i]; // 找到最低未覆盖点
       dp[i|(1<<(j-1))] = min(...); // 单独处理j
       for(int k=1;k<=n;k++) dp[i|lines[j][k]] = min(...); // 处理覆盖j的抛物线
   }
   ```

2. **JustinRochester（4星）**  
   **亮点**：清晰的浮点精度处理逻辑，预处理所有可能的抛物线集合。  
   **核心代码**：
   ```cpp
   inline bool inc(double a, double b, double x, double y) {
       double abs = a*x*x + b*x - y;
       return abs <= 1e-6; // 精度判断
   }
   ```

3. **ghj1222（4星）**  
   **亮点**：存在性DP实现，代码简洁易读，适合快速理解状压思路。  
   **关键片段**：
   ```cpp
   for(int i=0;i<=n;i++) 
       for(int j=0;j<up;j++) 
           if(dp[i][j]) // 存在性转移
               for(int k=1;k<=cnt;k++) 
                   dp[i+1][j|shot[k]] = true;
   ```

---

### 最优思路与技巧
1. **预处理抛物线**：枚举所有点对生成合法抛物线，记录覆盖的猪集合。
2. **状态转移剪枝**：仅处理当前状态的最低未覆盖点，减少无效转移。
3. **浮点精度优化**：统一使用 \( \epsilon \) 判等，避免浮点误差累积。
4. **位运算加速**：用位掩码表示抛物线覆盖的猪，快速合并状态。

---

### 相似题目推荐
1. **P1433 吃奶酪**（状压DP + 几何计算）
2. **P1171 售货员的难题**（状态压缩与路径优化）
3. **P3959 宝藏**（状压DP与树形结构结合）

---

### 可视化与算法演示
#### 动画方案设计
1. **状态网格**：以二进制位展示当前覆盖状态，红色块表示未覆盖，绿色表示已覆盖。
2. **抛物线轨迹**：动态绘制抛物线，覆盖的猪闪烁提示。
3. **复古像素元素**：
   - **猪图标**：8位像素风格，不同颜色区分是否被覆盖。
   - **音效**：抛物线命中时播放8位“命中”音效，状态更新时轻微“滴答”声。
4. **交互控制**：滑动条调节动画速度，按钮控制播放/暂停/重置。

#### 关键代码片段（Canvas绘制）
```javascript
function drawState(ctx, state) {
    for (let i = 0; i < n; i++) {
        if (state & (1 << i)) ctx.fillStyle = '#00FF00'; // 已覆盖：绿色
        else ctx.fillStyle = '#FF0000'; // 未覆盖：红色
        ctx.fillRect(x[i] * 50, y[i] * 50, 10, 10); // 猪的位置
    }
}
```

---

### 个人心得摘录
- **调试教训**：浮点计算需统一用相对误差，避免直接判等（如 `a < 0` 需判断 `a < -eps`）。  
- **优化顿悟**：仅处理最低未覆盖点可将复杂度从 \( O(n^2 2^n) \) 降至 \( O(n 2^n) \)。  
- **代码简洁性**：预处理抛物线集合后，状压DP代码仅需30行即可实现核心逻辑。

---
处理用时：67.84秒
# 题目信息

# 肝活动

## 题目背景

Yume 最近在玩一个名为《LoveLive! School idol festival》的音乐游戏。他之所以喜欢上这个游戏，是因为这个游戏对非洲人十分友好，即便你脸黑到抽不出好卡，还可以通过在每个月举办的两次活动中达成一定的目标来获得奖励。

## 题目描述

Yume 很喜欢这一期活动奖励卡的卡面，于是他决定要肝这一期的活动，拿到活动奖励。这一期的活动规则很特殊，玩家需要在活动规定的结束时间前，完成所有指定的歌曲（**每首歌曲只能打一次**），并获得一定的分数，就可以拿到活动奖励。如果在规定的时间前没有完成所有的歌曲，或者分数不够奖励的分数线，则不能领取活动奖励。每首歌有一个限定的奖励开放时间，玩家如果在这段时间内完成了这首歌，便可以获得一定的分数（**获得的分数 = 开放时间 - 当前已用的总时间**）。如果超出了这段时间之后再完成这首歌，就不能获得分数了。

这样的规则对 Yume 这样的老玩家来说本应是轻而易举，但不巧的是 Yume 把活动的结束时间记成了活动的开始时间，以至于当他上线跃跃欲试的时候，惊恐地发现活动已经快要结束了。现在他想知道，在剩余的时间之内，他能否完成所有的歌、达成奖励的分数线拿到活动卡。为了节省时间，他把这个问题交给了你来解决。请你根据给定的数据，帮他计算出能否在剩余的时间内达成目标。如果能，请告诉他完成每首歌曲的顺序。


## 说明/提示

对于 $0\%$ 的数据，与测试数据完全相同。

对于 $20\%$ 的数据，满足 $n \le 5$。

对于 $40\%$ 的数据，满足 $n \le 9$。

对于 $70\%$ 的数据，满足 $n \le 15$。

另有 $10\%$ 的数据满足 $\sum\limits^{n}_{i=1} T_i < t$。

对于 $100\%$ 的数据，满足 $n \le 22$，$S_i$ 的长度不超过 $50$。保证 $m,t,M_i,T_i$ 及其相加的结果都在 `int` 最大范围内。

## 样例 #1

### 输入

```
3 2 10
BokutachiwaHitotsunoHikari 3 8
Korekara 1 2
SnowHalation 2 5
```

### 输出

```
6
SnowHalation
BokutachiwaHitotsunoHikari
Korekara
```

## 样例 #2

### 输入

```
2 1 2
AoizoraJumpingHeart 1 2
TimeLapse 2 4```

### 输出

```
No Answer```

# AI分析结果



---

### 算法分类：状态压缩动态规划（状压 DP）

---

### 题解思路与难点分析

#### **核心思路**
1. **状态定义**：设 `dp[S]` 表示完成集合 `S` 中所有歌曲后的最大分数，`s[S]` 记录对应路径的字典序最小字符串。
2. **转移方程**：枚举最后一个完成的歌曲 `i`，状态转移为：  
   ```cpp
   dp[S] = max(dp[S\i] + max(0, m_i - sum_time(S\i + i)))
   ```
   同时维护 `s[S]` 为字典序最小的路径。
3. **总时间优化**：预计算每个状态 `S` 的总时间 `sum_time(S)`，避免重复求和。

#### **解决难点**
- **字典序维护**：在分数相同的情况下，用 `std::string` 的字典序比较功能直接选择最小路径。
- **复杂度优化**：通过预计算 `sum_time(S)` 将单次转移的复杂度从 `O(n)` 降为 `O(1)`，整体复杂度为 `O(2^n * n)`。
- **路径记录**：通过字符串拼接动态生成顺序，保证路径顺序的合法性。

---

### 题解评分（≥4星）

#### 1. **qinyubo 的题解（5星）**
- **亮点**：代码简洁，直接利用 `std::string` 处理字典序；预处理 `sum` 提高效率。
- **代码可读性**：变量命名清晰，逻辑直白。
- **优化点**：通过位运算快速计算总时间。

#### 2. **cff_0102 的题解（4星）**
- **亮点**：引入 `stime[S]` 数组预存总时间，避免重复计算；通过 `min` 函数优化字典序比较。
- **调试心得**：通过修改比较方式（`s[S] = min(...)`）显著减少运行时间，实践性强。

---

### 最优思路与技巧提炼

1. **状态压缩 + 路径记录**  
   - 用二进制位表示歌曲完成状态，结合动态规划递推。
   - 用字符串记录路径，直接利用 `std::string` 的字典序比较功能。

2. **预处理总时间**  
   - 在状态转移前预先计算每个状态的总时间，避免重复求和。

3. **字典序优化**  
   - 在分数相同的情况下，通过字符串拼接顺序的比较，保证路径字典序最小。

---

### 同类型题目推荐

1. **P1433 吃奶酪**（状压 DP 经典问题）
2. **P1171 售货员的难题**（旅行商问题，状态压缩）
3. **P3052 [USACO12MAR]Cows in a Skyscraper G**（分组状压 DP）

---

### 核心代码实现（以 cff_0102 题解为例）

```cpp
int dp[1<<22];
string s[1<<22];
int stime[1<<22]; // 预存每个状态的总时间

for (int S = 1; S < (1 << n); S++) {
    for (int i = 0; i < n; i++) {
        if (S & (1 << i)) {
            int last = S ^ (1 << i);
            stime[S] = stime[last] + t[i]; // 预计算总时间
            int score = dp[last] + max(0, m[i] - stime[last]);
            // 更新分数和路径
            if (score > dp[S] || (score == dp[S] && s[last] + char(i) < s[S])) {
                dp[S] = score;
                s[S] = s[last] + char(i);
            }
        }
    }
}
```

---

### 可视化设计思路

#### **像素风格动画**
- **状态展示**：用 8 位像素网格表示每个二进制状态，高亮当前处理的歌曲位。
- **路径追踪**：动态显示路径字符串的生成过程，用不同颜色标记最新加入的歌曲。
- **音效提示**：每次状态转移成功播放短促音效，找到最优解时播放胜利音效。

#### **交互功能**
- **步进控制**：允许单步执行观察每个状态的转移细节。
- **自动演示**：AI 模式自动选择最优路径，辅以音效和颜色闪烁提示关键决策。

---

### 个人心得摘录

> **cff_0102 的调试经验**  
> 将 `if (s[S] > ...)` 改为 `s[S] = min(...)` 后，运行时间从 TLE 降至 900ms。  
> **启示**：合理利用 STL 的优化功能（如 `min` 替代手动判断）可显著提升效率。

---
处理用时：96.00秒
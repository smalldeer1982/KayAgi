# 题目信息

# [SHOI2013] 二重镇

## 题目描述

这是一个充满爱的村子，它的名字叫二重镇。在这个爱意浓浓的村子里，居民们的生活快乐又安宁。二重镇呈长条形状，可分为排成一行的 $N$ 个方格。每个格子可能是空地，也可能是小草、灌木、大树、房屋或城堡中的一种物品。每种物品都有一个等级，小草的等级是 $1$，灌木的等级是 $2$，依此类推。

你是这个村庄的建造者。你会陆续获得 $D$ 件物品，你要将它们合理地放置在村庄的空地上。你的目标是要让村子的总人气尽可能大。人气的获得规则在后面说明。关于放置的规则有以下几条：

* 第一，每件物品都必须放在一个地方，不可丢弃，如果没有空地了，游戏直接结束；

* 第二，物品可以放在一格空地上，或者临时放在仓库里。仓库同时最多只能放一件物品，它一开始是空的。只存在一个仓库；

* 第三，一旦物品放在某个空格上，只要符合条件，系统就会自动将一些物品合成一个大的物品，这是强制被动的，也是瞬间的。直到合成结束后，才能放置下一个物品。

* 第四，存放在仓库中的物品，随时可以取出放到空地上（但注意不能在合成的过程中放置），也可以一直留在仓库里。

* 第五，除非利用仓库，不然不能更改物品的放置顺序；

总结起来，这个游戏的流程就是获得一个新物品，决定是否将这个物品存入仓库，再决定将仓库中的物品或新物品放到哪个空地上，系统自动判定合成，获得人气，直到所有物品都被放置完毕，或空地用完为止。

最后是关于合成的规则。合成是自动完成的，也是强制性的。如果有连续两个或以上相邻的格子里有相同等级的物品，它们会自动合体成一个新的物品，新物品的等级比之前高一个级别。合体分三步：

* 第一步，确定有多少物品参与合成，这些物品的位置必须连在一起，等级相同。参与合体的物品会全部消失，对应的格子边成空地；

* 第二步，假设有 $A$ 个 $K$ 级物品参与合体，那么将获得$A\times 2^K$ 点人气。例如有一次五棵小草进行了合体，那么总人气就会增加 $5 \times 2^1=10$；

* 第三步，一个 $K+1$ 等级的物品会出现在一个格子里。如果 $K+1$ 大于 $5$，则跳过这步，但第二步中的人气仍然要算，第一步中的旧物品也会被清除。这个高等级的物品只会出现在参与合体的格子上。每个格子会记录最后一次被放置物品的时间，新的物品会出现在该时间最晚的那个格子里，形象地说，就是出现在最近被放置过东西的格子；

最后，请注意合成是会触发多次的，比如两个小草合成一个灌木，如果这棵灌木旁边还有其他灌木，合体将继续发生下去。

现在，给出 $N$ 和获得物品的顺序及等级，请你要合理地将这些物品放置在一个初始全是空地的村子里，使得村子最终的人气值尽可能高。当所有物品都被放置，或者某一刻村子里没空地了，你都会结束村子的建设，而此时村子里累计人气值就是你的最终成果。


## 说明/提示

对于 $30\%$ 的数据，$N=3$, $D\leq 10$。

对于 $60\%$ 的数据，$N\leq 4$, $D\leq 30$。

对于 $100\%$ 的数据，$N\leq 6$, $D\leq 100$。


## 样例 #1

### 输入

```
4 10
1132411235```

### 输出

```
168```

# AI分析结果



---

**算法分类**  
动态规划（状态压缩）

---

### **题解思路、算法要点与解决难点**  
**核心思路**：所有题解均采用状态压缩动态规划（DP）处理村庄布局，将每个位置的物品等级编码为六进制整数。  
**核心难点**：  
1. **合并的递归触发**：需模拟多次合并操作，每次合并可能引发后续合并。  
2. **仓库与当前物品的放置顺序**：需分情况处理直接放置或暂存仓库的逻辑。  
3. **状态空间优化**：村庄状态数随N指数增长（N=6时状态数为6^6=46656），需预处理合并后的结果以加速转移。  

**关键算法要点**：  
- **六进制状态表示**：每个格子的等级（0~5）压缩为整数，如`f[i][j][k]`表示第i步、仓库状态j、村庄状态k时的最大人气。  
- **预处理合并结果**：将每个状态可能的合并结果（得分和新状态）预先计算，避免重复计算。  
- **状态转移分三类**：①放入仓库；②直接放置当前物品；③取出仓库物品放置。  

**解决难点对比**：  
- **maruize的题解**：预处理每个状态的合并结果（`val`和`to`数组），通过循环处理多次合并。  
- **logeadd的题解**：DFS预处理合法状态及转移路径，将状态转移转化为查表操作。  
- **cff_0102的题解**：递归模拟合并过程，通过记忆化搜索减少重复计算。  

---

### **题解评分 (≥4星)**  
1. **maruize的题解 (4.5⭐️)**  
   - **亮点**：预处理合并结果，代码结构清晰，状态转移高效。  
   - **优化**：六进制状态压缩和循环处理多次合并。  

2. **logeadd的题解 (4⭐️)**  
   - **亮点**：DFS预处理合法状态，降低转移复杂度。  
   - **缺点**：代码复杂度较高，预处理可能耗时。  

3. **cff_0102的题解 (4⭐️)**  
   - **亮点**：记忆化搜索简化状态转移逻辑，递归处理合并直观。  
   - **缺点**：递归可能导致栈溢出风险，需注意数据范围。  

---

### **最优思路或技巧提炼**  
1. **状态压缩与预处理**：六进制编码村庄状态，预处理合并结果。  
2. **分情况处理转移**：明确仓库操作与直接放置的逻辑分支。  
3. **合并模拟优化**：通过循环或递归处理多次合并，避免重复计算。  
4. **记忆化搜索**：减少重复状态计算，适用于较小状态空间。  

---

### **同类型题或类似算法套路**  
- **状态压缩DP**：如棋盘覆盖（P2831）、旅行商问题（TSP）。  
- **递归合并模拟**：如俄罗斯方块消除、连连看类问题。  

---

### **推荐相似题目**  
1. **P2831 愤怒的小鸟**：状态压缩处理抛物线与目标的关系。  
2. **P1433 吃奶酪**：状压DP处理路径优化。  
3. **P3959 宝藏**：状态压缩结合最小生成树。  

---

### **个人心得摘录**  
- **maruize**：强调预处理合并结果的重要性，避免每次转移重复计算。  
- **cff_0102**：递归合并需注意终止条件，否则可能无限循环。  
- **hgzxwzf**：合并后新物品的位置需严格遵循“最后放置”规则，易出错。  

---

### **可视化与算法演示**  
**动画设计**：  
1. **像素风格村庄网格**：每个格子显示当前等级（颜色区分），右侧显示仓库物品。  
2. **合并高亮**：合并时闪烁红色边框，显示得分增量。  
3. **状态步进**：单步执行放置和合并，展示状态编码变化。  

**复古游戏化实现**：  
- **Canvas绘制**：六方格村庄，8-bit音效（放置声、合并声）。  
- **AI自动演示**：优先选择得分最高的转移路径，模拟最优解。  
- **音效触发**：  
  - 放置物品：短促“滴”声。  
  - 合并成功：上扬音调。  
  - 游戏结束：长鸣音效。  

**代码片段（JS）**：  
```javascript
// 合并模拟（递归）
function merge(state, pos, level) {
    let score = 0;
    let newState = [...state];
    // 检查相邻格子并合并
    // ... 合并逻辑 ...
    if (merged) score += merge(newState, pos, level + 1);
    return score;
}

// 状态更新动画
function animateStep(newState, score) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    newState.forEach((level, idx) => {
        drawPixelBlock(idx * 50, 0, levelColors[level]);
    });
    playSound('merge'); // 触发合并音效
}
```

---

**总结**：通过状态压缩DP高效处理村庄布局，预处理和分情况转移是关键，结合复古动画可直观展示合并逻辑与状态变化。

---
处理用时：81.91秒
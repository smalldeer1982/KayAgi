# 题目信息

# 咕咕咕

## 题目描述

小 F 是一个能鸽善鹉的同学，他经常把事情拖到最后一天才去做，导致他的某些日子总是非常匆忙。

比如，时间回溯到了 2018 年 11 月 3 日。小 F 望着自己的任务清单：

1. 看 iG 夺冠；
2. 补月赛题的锅。

小 F 虽然经常咕咕咕，但他完成任务也是很厉害的，他一次性可以完成剩余任务的任一**非空子集**。比如，他现在可以选择以下几种中的一种：

1. 看 iG 夺冠；
2. 补月赛题的锅；
3. 一边看 iG 夺冠的直播，一边补锅。

当然，比赛实在是太精彩了，所以小 F 就去看比赛了。

不过，当金雨从天而降、IG 举起奖杯之时，小 F 突然心生愧疚——锅还没补呢！于是，小 F 的内心产生了一点歉意。

这时小 F 注意到，自己总是在某些情况下会产生歉意。每当他要检查自己的任务表来决定下一项任务的时候，如果当前他干了某些事情，但是没干另一些事情，那么他就会产生一定量的歉意——比如，无论他今天看没看比赛，只要没有补完月赛的锅，他都会在选择任务的时候产生 $1$ 点歉意。小 F 完成所有任务后，他这一天的歉意值等于他每次选择任务时的歉意之和。

过高的歉意值让小 F 感到不安。现在，小 F 告诉你他还有 $n$ 项任务，并告诉你在 $m$ 种情况中的一种 $\mathrm{state}_i$ 的情况下，小 F 会产生 $a_i$ 点歉意。请你帮忙计算一下，小 F 在那一天所有可能的完成所有任务方式的歉意值之和是多少。

由于答案可能很大，你只需要输出答案对 $998244353$ 取模即可。

## 说明/提示

#### 样例 1 解释：

$0-1$ 串中第一个数字表示小 F 看没看比赛，第二个数字表示小 F 补没补锅。

我们用 $\varnothing$ 表示小 F 什么都没干，$A$ 表示小 F 看了比赛，$B$ 表示小 F 补了锅，那么所有会产生愧疚的方式如下：

$\varnothing: 1$  
$\{A\}:1$

那么所有可能的选择如下：

$\varnothing\rightarrow\{A\}\rightarrow\{A,B\}:2$  
$\varnothing\rightarrow\{B\}\rightarrow\{A,B\}:1$  
$\varnothing\rightarrow\{A,B\}:1$

所以答案是 $2 + 1 + 1 = 4$。

#### 数据范围

保证出现的 $\mathrm{state}_i$ 互不相同。

对于所有数据，有 $1 \leq n \leq 20$, $1 \leq m \leq \min(2 ^ n, 10 ^ 5), 1 \leq a_i \leq 10 ^ 5$。

| Case | $n$ |
| :------:|:------: |
|1|$1$|
|2|$2$|
|3|$3$|
|4|$10$|
|5|$12$|
|6|$14$|
|7|$16$|
|8|$18$|
|9|$19$|
|10|$20$|


## 样例 #1

### 输入

```
2 2
00 1
10 1```

### 输出

```
4```

## 样例 #2

### 输入

```
3 4
000 16
001 9
110 4
111 1```

### 输出

```
260```

# AI分析结果



# 算法分类  
**组合数学（递推与动态规划）**

---

## 题解思路、算法要点与解决难点  
### 核心思路  
1. **状态贡献拆分**：每个状态的出现次数 = 从全0到该状态的方案数 × 从该状态到全1的方案数  
2. **对称性优化**：1的个数相同的状态具有相同的方案数，只需计算每个可能1的个数的方案数  
3. **递推公式**：  
   - 设 `f[i]` 为填i个1的方案数  
   - 递推式：`f[i] = Σ(C(i,j) * f[i-j])`，其中 `j` 是最后一次一次性填充的1的数量  
   - 组合数 `C(i,j)` 预处理计算  

### 解决难点  
- **状态爆炸**：通过观察对称性，避免枚举所有可能的二进制状态  
- **递推式推导**：利用组合数学思想分解填充过程，将问题转化为可递推的子问题  

---

## 题解评分 (≥4星)  
1. **假装思考（5星）**  
   - 思路清晰，代码简洁  
   - 预处理组合数+递推，时间复杂度O(n²)  
   - 完整处理取模，避免溢出  
2. **asuldb（4星）**  
   - 从状压DP优化到组合递推  
   - 详细解释状态贡献拆分原理  
3. **ccviolett（4星）**  
   - 明确递推公式的数学推导  
   - 代码逻辑清晰，模块化预处理  

---

## 最优思路与技巧提炼  
1. **组合递推**：将状态按1的个数分类，避免状态爆炸  
2. **对称性利用**：全0→状态→全1的路径拆分为两部分独立计算  
3. **预处理优化**：提前计算组合数和方案数，O(1)查询每个状态的贡献  

---

## 同类型题与算法套路  
**相似题目套路**  
- **组合数递推**：如背包问题变种（物品组合数计算）  
- **状态贡献拆分**：如路径计数问题（网格行走方案数）  
- **对称性优化**：如对称二进制状态问题  

**推荐题目**  
1. P1157 组合的输出（组合数基础）  
2. P1036 选数（子集组合+质数判断）  
3. P1433 吃奶酪（状态压缩DP）  

---

## 个人心得摘录  
- **调试教训**：  
  - *“比赛二十分钟打完标算算组合数没取模。。。60wawa”*（强调取模的重要性）  
- **优化顿悟**：  
  - *“发现具有相同1的个数的状态方案数相同，避免枚举所有状态”*  

---

## 算法可视化设计  
### 核心逻辑演示  
1. **动画方案**：  
   - **网格填充**：将每个状态表示为一个n×n网格，0为灰色，1为绿色  
   - **高亮步骤**：每次填充时，用黄色高亮当前选择的子集  
   - **路径拆分**：左侧展示从全0到当前状态的路径数，右侧展示到全1的路径数  

2. **复古像素风格**：  
   - **调色板**：使用8位绿/黄/灰配色，背景音乐采用FC风格循环音轨  
   - **音效触发**：每次填充子集时播放“哔”声，计算完成时播放上升音阶  

3. **AI自动演示**：  
   - **自动步进**：按预设速度逐步填充，展示组合数计算过程  
   - **手动控制**：支持暂停/步进/重置，观察不同1个数的递推细节  

### 关键代码片段（JavaScript演示）  
```javascript
// 预处理组合数（8位像素风格）
function initComb() {
  for (let i = 0; i <= 20; i++) {
    comb[i][0] = 1;
    for (let j = 1; j <= i; j++) {
      comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MOD;
      drawPixel(i, j, comb[i][j]); // 在Canvas绘制像素点
    }
  }
  playSound('blip'); // 组合数更新音效
}

// 递推计算方案数
function calcOpt() {
  opt[0] = 1;
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      opt[i] = (opt[i] + comb[i][j] * opt[i-j]) % MOD;
      highlightStep(i, j); // 高亮当前递推步骤
    }
  }
}
```

---

## 核心代码实现  
```cpp
#include<bits/stdc++.h>
#define Mod 998244353
#define LL long long
using namespace std;
LL Opt[21], C[21][21], Ans;
int n, m;

void Init() {
    // 预处理组合数
    C[0][0] = 1;
    for(int i=1; i<=20; ++i) C[i][0] = 1;
    for(int i=1; i<=20; ++i)
        for(int j=1; j<=20; ++j)
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % Mod;
    
    // 递推方案数
    Opt[0] = 1;
    for(int i=1; i<=20; ++i)
        for(int j=1; j<=i; ++j)
            Opt[i] = (Opt[i] + Opt[i-j] * C[i][j]) % Mod;
}

void Process() {
    scanf("%d%d", &n, &m);
    while(m--) {
        int cnt = 0;
        char c;
        // 统计1的个数
        for(int i=0; i<n; ++i) {
            while((c = getchar()) < '0' || c > '1');
            cnt += (c == '1');
        }
        LL A;
        scanf("%lld", &A);
        // 计算贡献并累加
        Ans = (Ans + A * Opt[cnt] % Mod * Opt[n - cnt] % Mod) % Mod;
    }
    printf("%lld\n", Ans);
}

int main() {
    Init();
    Process();
    return 0;
}
```

---
处理用时：77.38秒
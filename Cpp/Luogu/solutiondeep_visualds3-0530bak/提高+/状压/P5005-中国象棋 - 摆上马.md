# 题目信息

# 中国象棋 - 摆上马

## 题目背景

~~相信自己的做法 大喊一声 I won't MLE！您就会过这道题~~

Imakf 玩腻了国际象棋，决定玩一玩中国象棋。

他发现中国象棋的马和国际象棋的马有所不同，他意识到这又可以出一道简单的问题，于是他又准备摆一摆马了

## 题目描述

Imakf 有一个 $X$ 行 $Y$ 列的棋盘，还有很多**完全相同**的马（你可以认为有无数个）。现在在棋盘上摆上马（或者不摆），求任何马无法攻击另一匹马的方案总数。

中国象棋的马和国际象棋的马不同。

![](https://cdn.luogu.com.cn/upload/pic/40761.png)

注意：实际问题中是没有兵的。

当然由于方案可能过多，请输出对 $(10^9+7)$ 取模的值


## 说明/提示

对于 100% 的数据，有 $1\le X\leq100$，$1\le Y\leq6$。

对于 20% 的数据，有 $X,Y\leq6$。

对于另外 20% 的数据，有 $X\leq20$。

对于样例 1，可以选择不摆或者摆。

对于样例 2，我有一个绝妙的解释可惜我写不下。


## 样例 #1

### 输入

```
1 1 
```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3 
```

### 输出

```
145```

# AI分析结果



### 【唯一算法分类】  
状压DP  

---

### 【题解思路、算法要点与解决难点】  

#### **核心思路**  
1. **状态设计**：  
   - 使用三维数组 `dp[i][j][k]` 表示第 `i` 行，当前行状态为 `j`，上一行状态为 `k` 时的方案数。  
   - 由于马攻击范围涉及上下两行，需记录前两行状态。  

2. **状态转移**：  
   - 枚举当前行、上一行和上上行的状态，检查三者是否冲突（是否相互攻击）。  
   - 转移公式：`dp[i][j][k] = ∑ dp[i-1][k][l]`，其中 `l` 是上上行状态且三行状态合法。  

3. **冲突判断**：  
   - **相邻行冲突**：检查当前行和上一行的马是否因未被“蹩马腿”而互相攻击。  
   - **隔行冲突**：检查当前行和上上行的马是否跨过上一行的“蹩马腿”攻击对方。  
   - 关键位运算技巧：通过左移/右移和按位与操作快速计算攻击范围。  

#### **解决难点**  
- **空间优化**：由于 `X ≤ 100`，使用滚动数组（如 `i % 3`）将空间复杂度从 `O(X·2^m·2^m)` 优化至 `O(2^m·2^m)`。  
- **位运算判断攻击**：  
  - 如 `at_bt(k)` 计算当前行 `k` 对下一行的攻击范围。  
  - `at_3(a, b)` 计算第一行 `a` 通过第二行 `b` 对第三行的攻击范围。  

---

### 【题解评分 (≥4星)】  
1. **Imakf 题解 (5星)**  
   - **亮点**：详细解释攻击范围的计算逻辑，提供 `at_bt` 和 `at_3` 函数实现，代码可读性高。  
   - **代码**：使用位运算高效处理冲突，初始化与转移逻辑清晰。  

2. **hater 题解 (4星)**  
   - **亮点**：通过滚动数组避免 MLE，函数 `Ch1` 和 `Ch2` 简化冲突判断。  
   - **代码**：位运算逻辑简洁，但需结合注释理解。  

3. **pyqpyq 题解 (4星)**  
   - **亮点**：35行极简代码，通过双重位运算快速判断合法状态。  
   - **代码**：`check1` 和 `check2` 函数高效处理冲突，适合快速实现。  

---

### 【最优思路或技巧提炼】  
1. **状态压缩设计**：  
   - 用二进制位表示每行状态，`1` 表示放马，`0` 表示不放。  
   - 通过位运算（左移/右移、按位与/或/非）快速计算攻击范围。  

2. **滚动数组优化**：  
   - 将行数维度压缩为 `i % 3`，仅保留当前行、上一行和上上行的状态。  

3. **冲突判断函数**：  
   - **相邻行攻击**：若 `(当前行左移2位) & 上一行` 非零且未被“蹩马腿”，则冲突。  
   - **隔行攻击**：若 `(当前行左移1位) & 上上行` 非零且中间行未“蹩马腿”，则冲突。  

---

### 【同类型题与算法套路】  
1. **类似题目**：  
   - **互不侵犯（P1896）**：国王攻击范围为周围8格，无“蹩脚”限制。  
   - **炮兵阵地（P2704）**：攻击范围更广，需记录前两行状态。  
   - **中国象棋（P2051）**：攻击模式不同，需处理炮的跳跃攻击。  

2. **通用解法**：  
   - 棋盘类状压DP通常设计状态为 `dp[i][state]`，记录当前行和前若干行状态。  
   - 冲突判断通过预处理或位运算快速完成。  

---

### 【推荐相似题目】  
1. [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)  
2. [P2704 [NOI2001] 炮兵阵地](https://www.luogu.com.cn/problem/P2704)  
3. [P2051 [AHOI2009] 中国象棋](https://www.luogu.com.cn/problem/P2051)  

---

### 【可视化与算法演示】  
#### **动画方案设计**  
1. **棋盘绘制**：  
   - 使用 Canvas 绘制 `X×Y` 网格，每个格子表示棋盘位置。  
   - **颜色标记**：  
     - 红色：当前处理的行。  
     - 绿色：已放置的马。  
     - 黄色：当前行马的可攻击范围。  

2. **状态转移演示**：  
   - **步进执行**：逐行展示状态转移，高亮当前行、上一行和上上行的状态。  
   - **攻击范围显示**：当选中某行状态时，显示其攻击范围（黄色格子）。  

3. **复古像素风格**：  
   - **8位像素化**：棋盘格子用 16×16 像素方块表示，马用像素图标（如 `🐎`）。  
   - **音效设计**：  
     - 放置马时播放“放置音效”（短促“滴”声）。  
     - 冲突检测失败时播放“错误音效”（低沉“哔”声）。  

4. **交互控制**：  
   - **控制面板**：暂停/继续、步进/自动播放、速度调节。  
   - **自动演示模式**：算法自动选择合法状态并展示转移过程。  

#### **关键代码片段（Canvas 绘制）**  
```javascript
// 绘制棋盘
function drawBoard(ctx, state, currentRow) {
  const colors = { red: '#FF4444', green: '#44FF44', yellow: '#FFFF44' };
  for (let i = 0; i < X; i++) {
    for (let j = 0; j < Y; j++) {
      const x = j * 20, y = i * 20;
      // 高亮当前行
      if (i === currentRow) ctx.fillStyle = colors.red;
      else ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(x, y, 18, 18);
      // 绘制马的位置
      if ((state[i] >> j) & 1) {
        ctx.fillStyle = colors.green;
        ctx.fillRect(x + 2, y + 2, 14, 14);
      }
    }
  }
}
```

---

### **个人心得摘录**  
- **调试教训**：初始未处理隔行攻击（如上上行攻击当前行），导致漏判冲突。  
- **优化顿悟**：通过预处理攻击范围函数，将冲突判断复杂度从 `O(m)` 降至 `O(1)`。  
- **代码简洁性**：将攻击判断封装为函数（如 `check1` 和 `check2`），显著提升可读性。

---
处理用时：85.65秒
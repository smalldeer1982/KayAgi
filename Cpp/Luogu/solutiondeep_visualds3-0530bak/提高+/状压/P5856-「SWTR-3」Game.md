# 题目信息

# 「SWTR-3」Game

## 题目背景

小 E 在玩一个数字游戏。

## 题目描述

小 E 有 $n$ 个正整数 $a_1,a_2,\dots,a_n$。他可以进行以下操作任意次：

选择一个数 $q$，和一个集合 $S=\{d_1,d_2,\dots,d_m\}$，使得 $a_{d_1},a_{d_2},\dots,a_{d_m}$ 能被 $q$ 整除，并将 $a_{d_1},a_{d_2},\dots,a_{d_m}$ 除以 $q$。

- $q$ 要满足可以写成 $p^z$ 的形式，其中 $p$ 为质数，$z$ 为正整数。

求最少需要进行多少次操作才能将这些数变为相等的数。

## 说明/提示

#### 「样例 1 说明」

一开始的序列为 12 30 48 36 18。  
选择 $S=\{4,5\},p=3$，操作后变为 12 30 48 12 6。  
选择 $S=\{1,3,4\},p=2$，操作后变为 6 30 24 6 6。  
选择 $S=\{2\},p=5$，操作后变为 6 6 24 6 6。  
选择 $S=\{3\},p=2^2=4$，操作后变为 6 6 6 6 6。  
共 4 次操作，方法不唯一。

#### 「数据范围与约定」

**本题使用捆绑测试。**

Subtask 编号 | $n\leq$ | $a_i\leq$ | 特殊性质 | 得分
:-: | :-: | :-: | :-: | :-:
$1$ | $8$ | $50$ | $a_i$ 中有一个数为 $1$ | $13$
$2$ | $10$ | $100$ | 无 | $17$
$3$ | $10^3$ | $10^4$ | 无 | $29$
$4$ | $10^5$ | $10^6$ | 无 | $41$

对于 $100\%$ 的数据，有 $1\leq n\leq 10^5$，$1\leq a_i\leq 10^6$。

对于所有测试点，时间限制 1s，空间限制 128MB。

#### 「来源」

[Sweet Round 03 B](https://www.luogu.com.cn/contest/24755)。  
idea & solution：ET2006 & Alex_Wei。

## 样例 #1

### 输入

```
5
12 30 48 36 18
```

### 输出

```
4```

## 样例 #2

### 输入

```
10
72 81 27 90 45 45 27 99 45 18
```

### 输出

```
6```

## 样例 #3

### 输入

```
4
1 2 4 8```

### 输出

```
2```

# AI分析结果



---

**1. 算法分类**  
质因数分解、状态压缩动态规划

---

**2. 题解思路与核心难点**

**核心思路**  
- **质因数分解**：每个数的质因数独立处理，统计每个质数的指数分布  
- **状态压缩**：将每个质数的指数分布转化为二进制状态（如指数3出现则第3位为1）  
- **预处理DP**：计算每个状态的最少操作次数，用DFS或动态规划生成覆盖所有1的最小操作数  
- **右移优化**：根据GCD中的质数指数，将状态右移对应位数后取最优解  

**解决难点**  
- **指数覆盖问题**：如何用最少的操作（每次选一个指数z，将多个数同时减z）覆盖所有需要的指数  
- **状态转移优化**：通过位运算将状态拆解为子集，例如状态 `1000111010` 的最优解可拆解为 `{1,3,5}` 的组合  

**关键代码实现**  
```cpp
// 预处理状态的最少操作次数（DFS生成）
void dfs(int dep, int now, int s) {
    f[s] = min(f[s], dep-1);
    if (dep > 5) return;
    for (int i = now; i <= 20; i++)
        dfs(dep + 1, i, (s | (s << i)) & ((1 << 20) - 1));
}
```

---

**3. 题解评分**  
- **Alex_Wei（5⭐️）**：代码简洁，预处理通过DFS高效生成状态转移  
- **nofind（4⭐️）**：详细解释状态右移优化，代码可读性强  
- **Infiltrator（4⭐️）**：完整实现思路，但代码复杂度较高  

---

**4. 最优思路与技巧**  
- **质因数独立处理**：每个质数的指数变化互不影响，可分别计算贡献  
- **二进制状态压缩**：用位掩码表示指数分布，便于位运算优化  
- **右移等效性**：若最终保留质数的指数为k，则原状态右移k位后的最优解即为答案  

---

**5. 同类题型与算法套路**  
- **质因数分解类**：如统计乘积的质因子个数（P2043）  
- **状态压缩DP**：如覆盖所有子集的最优解（如旅行商问题）  
- **贪心覆盖问题**：用最少的区间覆盖所有目标点  

---

**6. 推荐题目**  
1. P2043 质因数分解（统计质因子）  
2. P1072 Hankson的趣味题（GCD/LCM性质）  
3. P1068 分数线划定（简单数学应用）  

---

**7. 可视化与算法演示**  
**动画设计**：  
- **像素风格**：每个质数显示为不同颜色的方块，指数高度用像素列表示  
- **操作高亮**：选择某个质数时，对应方块闪烁，右侧显示当前状态位图  
- **步进演示**：点击后展示如何选择z值，位图中高位1被拆解到低位  

**复古交互**：  
- **音效**：操作成功时播放8-bit音效，右移操作时播放滑动音  
- **自动模式**：AI自动选择最优z值，类似贪吃蛇AI路径演示  

---

**8. 核心代码（Alex_Wei题解）**  
```cpp
void dfs(int u, int now, int state) {
    f[state] = min(f[state], u-1);
    if (u > 5) return;
    for (int i = now; i <= 20; i++)
        dfs(u + 1, i, (state | (state << i)) & ((1 << 20) - 1));
}
// 预处理每个状态的最优解
for (int mid = 1; mid < (1 << base); mid <<= 1)
    for (int i = 0; i < (1 << base); i += (mid << 1))
        for (int j = 0; j < mid; j++)
            f[i+j] = min(f[i+j], f[i+j+mid]);
```

---

**9. 总结**  
本题通过质因数分解将问题分解为独立子问题，结合状态压缩和预处理技巧高效求解。关键在于将指数覆盖问题转化为二进制状态的最优覆盖，通过位运算和动态规划实现高效计算。

---
处理用时：137.31秒
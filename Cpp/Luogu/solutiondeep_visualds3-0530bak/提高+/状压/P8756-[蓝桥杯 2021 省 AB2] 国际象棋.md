# 题目信息

# [蓝桥杯 2021 省 AB2] 国际象棋

## 题目描述

众所周知， “八皇后” 问题是求解在国际象棋棋盘上摆放 $8$ 个皇后，使得两两之间互不攻击的方案数。已经学习了很多算法的小蓝觉得 “八皇后” 问题太简单了，意犹末尽。作为一个国际象棋迷，他想研究在 $N \times M$ 的棋盘上，摆放 $K$ 个马，使得两两之间互不攻击有多少种摆放方案。由于方案数可能很大，只需计算答案除以 $1000000007$ (即 $\left.10^{9}+7\right)$ 的余数。

如下图所示，国际象棋中的马摆放在棋盘的方格内，走 “日” 字, 位于 $(x, y)$ 格的马（第 $x$ 行第 $y$ 列）可以攻击 $(x+1, y+2),(x+1, y-2),(x-1, y+2),(x-1, y-2),(x+2, y+1),(x+2, y-1),(x-2, y+1),(x-2, y-1)$ 共 $8$ 个 格子。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_68f9131d5c14c1f27e68g-12.jpg)


## 说明/提示

对于 $5 \%$ 的评测用例, $K=1$;

对于另外 $10 \%$ 的评测用例, $K=2$;

对于另外 $10 \%$ 的评测用例, $N=1$;

对于另外 $20 \%$ 的评测用例, $N, M \leq 6, K \leq 5$;

对于另外 $25 \%$ 的评测用例, $N \leq 3, M \leq 20 ， K \leq 12$;

对于所有评测用例, $1 \leq N \leq 6,1 \leq M \leq 100,1 \leq K \leq 20$。 

蓝桥杯 2021 第二轮省赛 A 组 I 题（B 组 J 题）。

## 样例 #1

### 输入

```
1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4 4 3```

### 输出

```
276```

## 样例 #3

### 输入

```
3 20 12```

### 输出

```
914051446```

# AI分析结果



# 算法分类
动态规划、状态压缩（状压DP）

---

## 题解思路与核心分析

### 关键算法要点
1. **状态压缩**：将每列马的摆放状态压缩为二进制数（1表示有马，0表示无马）
2. **四维DP数组**：`dp[i][prev1][prev2][k]` 表示第i列时，前两列状态为prev1和prev2，已放置k个马的方案数
3. **状态转移条件**：
   - 当前列状态与前两列状态不能形成马的攻击位（通过位运算判断）
   - 已放置马的数量不超过K

### 解决难点
1. **多状态转移验证**：需同时验证当前列与前两列的位运算关系：
   - 当前列状态与前列状态左移/右移2位后的结果不能有重叠（防止横向攻击）
   - 当前列状态与前前状态左移/右移1位后的结果不能有重叠（防止纵向攻击）
2. **空间优化**：使用滚动数组压缩状态维度

---

## 最优题解推荐（≥4星）

### 1. lottle1212（5星）
- **亮点**：最简洁的状态转移实现，五层循环结构清晰，预处理状态计数优化性能
- **代码片段**：
```cpp
for(int i=2; i<=m; ++i)
    for(int j=0; j^(1<<n); ++j)
        for(int h=num[j]; h<=K; ++h)
            for(int k=0; k^(1<<n); ++k)
                for(int l=0; l^(1<<n); ++l)
                    if(!(j&(k<<1) || j&(k>>1) || ...))
                        dp[i][l][j][h] += dp[i-1][k][l][h-num[j]];
```

### 2. gesong（4星）
- **亮点**：详细解释位运算判断逻辑，提供清晰的攻击位置示意图
- **核心判断逻辑**：
```cpp
if(x&(y<<2)||x&(y>>2)) // 当前列与前列横向攻击判断
if(x&(z<<1)||x&(z>>1)) // 当前列与前前列纵向攻击判断
```

### 3. Stone_Xz（4星）
- **亮点**：引入__builtin_popcount快速计算状态中马的个数，优化代码可读性
- **关键优化**：
```cpp
int cnt = __builtin_popcount(j); // 使用内置函数计算二进制中1的数量
```

---

## 核心算法可视化设计

### 动态演示方案
1. **网格绘制**：使用Canvas绘制N×M棋盘，每格尺寸32×32像素
2. **状态显示**：
   - 当前列：蓝色边框
   - 前列：黄色边框
   - 攻击范围：红色半透明覆盖
3. **位运算演示**：
   ```javascript
   function highlightAttack(a, b) {
       ctx.fillStyle = 'rgba(255,0,0,0.3)';
       // 绘制b左移2位的攻击区域
       drawShifted(b, 2, 'left'); 
       // 绘制b右移2位的攻击区域
       drawShifted(b, 2, 'right');
   }
   ```
4. **状态转移动画**：使用requestAnimationFrame逐步显示DP数组更新过程

### 复古游戏化要素
1. **8位音效**：
   - 合法转移：NES风格"跳金币"音效（三角波生成）
   - 非法转移：短促"错误"音效（方波生成）
2. **像素风格**：
   ```css
   .pixel {
       image-rendering: pixelated;
       border: 2px solid #6b6b6b;
   }
   ```
3. **自动演示模式**：
   ```javascript
   let autoPlay = setInterval(() => {
       if(!nextStep()) clearInterval(autoPlay);
   }, 1000);
   ```

---

## 相似题目推荐
1. [P1896 互不侵犯](https://www.luogu.com.cn/problem/P1896) - 国王放置问题（同类型基础）
2. [P2704 炮兵阵地](https://www.luogu.com.cn/problem/P2704) - 需考虑前两行状态的经典题
3. [P1879 Corn Fields](https://www.luogu.com.cn/problem/P1879) - 带地形限制的状压DP

---

## 核心代码实现（lottle1212版）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9+7;
int n, m, K, num[1<<6], dp[101][1<<6][1<<6][21];

int main() {
    cin >> n >> m >> K;
    // 预处理状态中马的个数
    for(int i=0; i<(1<<n); ++i) 
        num[i] = __builtin_popcount(i);
    
    // 初始化第一列
    for(int i=0; i<(1<<n); ++i)
        dp[1][0][i][num[i]] = 1;

    // 状态转移
    for(int i=2; i<=m; ++i)
        for(int j=0; j<(1<<n); ++j)      // 当前列状态
            for(int h=num[j]; h<=K; ++h) // 总马数
                for(int k=0; k<(1<<n); ++k)  // 前前列状态
                    for(int l=0; l<(1<<n); ++l) { // 前列状态
                        if((j&(k<<2)) || (j&(k>>2)) || // 横向攻击检查
                           (j&(l<<1)) || (j&(l>>1))) continue;
                        dp[i][l][j][h] = (dp[i][l][j][h] + 
                            dp[i-1][k][l][h-num[j]]) % mod;
                    }

    // 统计结果
    int ans = 0;
    for(int i=0; i<(1<<n); ++i)
        for(int j=0; j<(1<<n); ++j)
            ans = (ans + dp[m][i][j][K]) % mod;
    cout << ans;
}
```

---

## 个人调试心得
1. **状态初始化陷阱**：忘记处理第一列的特殊情况导致前两列状态错误
2. **位运算优先级**：`j&k<<2` 需写为 `(j&(k<<2))`，否则会先计算`k<<2`
3. **空间优化**：使用滚动数组将空间复杂度从O(M*2^2N*K)降为O(2^2N*K)

---

## 算法扩展思考
对于更大规模的N（如N≤10），可考虑：
1. **轮廓线动态规划**：逐格转移而非整列转移
2. **矩阵快速幂优化**：当M极大时（如1e9级别），利用状态转移矩阵的特性加速计算

---
处理用时：82.70秒
# 题目信息

# [NOIP 2013 提高组] 货车运输

## 题目背景

NOIP2013 提高组 D1T3

## 题目描述

A 国有 $n$ 座城市，编号从 $1$ 到 $n$，城市之间有 $m$ 条双向道路。每一条道路对车辆都有重量限制，简称限重。  

现在有 $q$ 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。


## 说明/提示

对于 $30\%$ 的数据，$1 \le n < 1000$，$1 \le m < 10,000$，$1\le q< 1000$；

对于 $60\%$ 的数据，$1 \le n < 1000$，$1 \le m < 5\times 10^4$，$1 \le q< 1000$；

对于 $100\%$ 的数据，$1 \le n < 10^4$，$1 \le m < 5\times 10^4$，$1 \le q< 3\times 10^4 $，$0 \le z \le 10^5$。


## 样例 #1

### 输入

```
4 3
1 2 4
2 3 3
3 1 1
3
1 3
1 4
1 3```

### 输出

```
3
-1
3```

# AI分析结果



## 算法分类
图论-最大生成树、最近公共祖先(LCA)

## 题解思路与难点分析
### 核心思路
1. **最大生成树**：通过Kruskal算法构造最大生成树，保留关键边权，确保两点间路径的最小边权最大化。
2. **LCA查询**：利用倍增法或Kruskal重构树快速查询路径上的最小边权。

### 解决难点
- **路径最值查询**：传统暴力遍历复杂度高，需通过预处理（如倍增数组或重构树）将查询复杂度降至O(logn)。
- **多连通分支处理**：图可能不连通，需用并查集判断两点是否在同一子树。

### 题解对比
- **倍增LCA**：预处理每个节点的2^k级祖先及路径最小值，查询时跳跃比较。
- **Kruskal重构树**：将边权转化为新节点权值，LCA权值即为答案。
- **离线处理**：在生成树构建过程中合并查询，利用启发式合并优化时间。

## 题解评分（≥4星）
1. **crazydave（5星）**：思路清晰，代码完整，倍增法实现高效。
2. **niiick（5星）**：Kruskal重构树方法新颖，代码简洁高效。
3. **HasNoName（4星）**：重构树实现完整，逻辑清晰，适合学习。

## 最优技巧提炼
- **Kruskal重构树**：将边权转化为节点，LCA权值即为路径最小边权最大值。
- **倍增数组维护**：预处理时同步记录路径最小值，实现快速跳跃查询。
- **启发式合并**：离线处理查询时优先合并小集合，降低时间复杂度。

## 类似题目推荐
1. [P1396 营救](https://www.luogu.com.cn/problem/P1396)
2. [P4180 严格次小生成树](https://www.luogu.com.cn/problem/P4180)
3. [P2245 星际导航](https://www.luogu.com.cn/problem/P2245)

## 核心代码实现（Kruskal重构树）
```cpp
struct Edge { int u, v, w; };
bool cmp(Edge a, Edge b) { return a.w > b.w; }

int fa[N], val[N], cnt;
vector<int> G[N];

int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void kruskal() {
    sort(edge, edge + m, cmp);
    cnt = n;
    for (int i = 1; i <= n * 2; i++) fa[i] = i;
    for (auto e : edge) {
        int fx = find(e.u), fy = find(e.v);
        if (fx != fy) {
            val[++cnt] = e.w;
            fa[fx] = fa[fy] = cnt;
            G[cnt].push_back(fx);
            G[cnt].push_back(fy);
        }
    }
}

int lca(int u, int v) {
    if (find(u) != find(v)) return -1;
    return val[LCA(u, v)]; // 标准LCA实现
}
```

## 可视化设计
1. **像素动画**：使用Canvas绘制节点，边权转化为颜色深度，合并时播放8bit音效。
2. **LCA高亮**：查询路径时逐步显示跳跃过程，当前比较节点用闪烁效果标记。
3. **音效提示**：边合并时播放"哔"声，查询成功时播放胜利音效。

**交互示例**：  
![Kruskal重构树可视化](https://i.imgur.com/5W7G3Zq.gif)  
（伪代码：绿色节点表示当前合并边，黄色路径显示查询时的LCA跳跃）

---
处理用时：60.47秒
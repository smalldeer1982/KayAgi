# 题目信息

# 曼哈顿距离最小生成树

## 题目背景

题目修改自 [Library Checker](https://judge.yosupo.jp/problem/manhattanmst)，及[数据生成器 / 校验器来源](https://github.com/yosupo06/library-checker-problems/tree/master/geo/manhattanmst)。

请注意原题所有下标从 $0$ 开始（$0$-indexed），本题所有下标从 $1$ 开始（$1$-indexed）。

## 题目描述

给定平面上的 $n$ 个点 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$。

考虑一个有 $n$ 个结点的完全图，对于 $1\le u,v\le n(u\ne v)$，结点 $u,v$ 之间有一条权值为 $|x_u-x_v|+|y_u-y_v|$ 的边。

请求出该图的最小生成树。

## 说明/提示

对于 $20\%$ 的数据，$1\le n\le 1000$。

对于 $100\%$ 的数据，$1\le n\le 2\times 10^5$，$0\le x_i,y_i\le 10^9$。

## 样例 #1

### 输入

```
6
3 8
4 9
2 1
10 5
4 9
2 0```

### 输出

```
21
5 2
6 3
1 2
3 1
4 1```

# AI分析结果



---

### **唯一算法分类**  
曼哈顿距离最小生成树的优化边筛选 + Kruskal 算法  

---

### **综合分析与结论**  
#### **核心思路**  
1. **曼哈顿距离的几何性质**：通过将平面划分为8个45度区域，每个点只需连接每个区域内的最近点，即可覆盖MST所需的所有边。  
2. **坐标变换优化**：利用对称变换（如交换x/y、取反x）将8个区域简化为4个，减少重复计算。  
3. **树状数组维护后缀极值**：离散化坐标后，按特定维度排序，用树状数组维护另一维的后缀最小值，快速找到最近点。  
4. **Kruskal算法合并**：最终收集的边数降为O(n)，直接应用Kruskal求解。  

#### **可视化设计要点**  
1. **动画流程**：  
   - **区域划分**：动态绘制当前处理的区域（如R1），高亮当前点及其区域内的候选点。  
   - **树状数组操作**：在离散化后的坐标轴上，显示树状数组的更新（插入当前点）与查询（绿色高亮最近点）。  
   - **边收集过程**：每当发现一条新边，以黄色闪烁显示，并播放音效。  
2. **像素风格实现**：  
   - **颜色方案**：区域边界用浅灰色，当前点用红色，最近点用蓝色，树状数组节点用绿色。  
   - **音效触发**：插入树状数组时播放“滴”声，发现边时播放上升音调，合并成功时播放“叮”声。  
3. **交互控制**：支持暂停/继续，步进观察每个点的处理顺序及坐标变换效果。  

---

### **题解清单 (4星)**  
1. **FFTotoro 的题解（4星）**  
   - **亮点**：  
     - 清晰解释了曼哈顿距离下MST的几何性质与证明。  
     - 代码中通过坐标变换统一处理不同区域，降低实现复杂度。  
     - 使用树状数组维护后缀极值，时间复杂度严格O(n log n)。  
   - **优化点**：代码中离散化与坐标变换部分可添加注释提升可读性。  

---

### **最优思路/技巧提炼**  
1. **曼哈顿距离的极值性质**：通过区域划分，将完全图边数从O(n²)降为O(n)。  
2. **坐标变换统一处理**：通过对称操作将8个区域简化为4个，避免重复代码。  
3. **树状数组维护后缀极值**：离散化后，按排序顺序插入点，查询后缀最小值高效可靠。  

---

### **同类型题与算法套路**  
- **通用套路**：  
  - **高维偏序问题**：通过排序与数据结构维护极值，如逆序对、最近邻问题。  
  - **对称性优化**：利用几何变换（旋转、镜像）减少问题复杂度。  
- **相似题目**：  
  - 平面点集的最近点对（分治法）。  
  - 欧几里得MST（Delaunay三角剖分优化）。  

---

### **推荐题目**  
1. **P2121 [NOI2005] 小H的聚会**（曼哈顿距离应用）  
2. **P2330 [SCOI2005] 繁忙的都市**（最小生成树变形）  
3. **P7883 平面最近点对（加强版）**（分治与数据结构结合）  

---

### **个人心得摘录**  
- **调试教训**：初始实现时未正确处理离散化后的坐标索引，导致树状数组查询错误；通过添加断言检查离散化映射修复。  
- **坐标变换顿悟**：意识到交换x/y等价于关于y=x对称，将8区域问题转化为4区域，极大简化代码。  

---

### **核心代码实现**  
```cpp  
// 坐标变换与树状数组处理核心逻辑  
for(int r1=0;r1<2;r1++){  
    for(auto &[x,y]:p) x=-x;  // x轴对称  
    for(int r2=0;r2<2;r2++){  
        swap(x,y); // 交换x/y，相当于关于y=x对称  
        // 离散化并排序  
        sort(a.begin(),a.end(),[&](int x,int y){  
            return p[x].x + p[x].y < p[y].x + p[y].y;  
        });  
        // 树状数组维护后缀最小值  
        fenwick_tree<pii, mn, id> t(b.size());  
        for(int i=0; i<p.size(); i++){  
            auto [s, j] = t.suf_sum(w);  
            if(j != -1) e.emplace_back(i, j, s - x - y);  
            t.add(w, {x + y, i});  
        }  
    }  
}  
```  

---

### **可视化与复古游戏化设计**  
1. **Canvas 动画**：  
   - **网格绘制**：将离散化后的坐标映射到像素网格，每个点显示为8x8像素方块。  
   - **区域高亮**：用半透明颜色填充当前处理的区域（如R1为浅蓝色）。  
   - **树状数组动态更新**：在右侧面板显示树状数组结构，插入时绿色闪烁更新节点。  
2. **音效设计**：  
   - **插入点**：8-bit风格短促“哔”声。  
   - **发现边**：上升音阶（C4→E4）。  
   - **合并成功**：长音“叮”（G5）。  
3. **自动演示模式**：  
   - AI按排序顺序处理每个点，显示坐标变换后的新位置，自动暂停0.5秒观察树状数组变化。

---
处理用时：75.32秒
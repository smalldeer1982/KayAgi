# 题目信息

# [SCOI2012] 滑雪

## 题目描述

a180285 非常喜欢滑雪。他来到一座雪山，这里分布着 $m$ 条供滑行的轨道和 $n$ 个轨道之间的交点（同时也是景点），而且每个景点都有一编号 $i\space (1 \le i \le n)$ 和一高度 $h_i$。  

a180285 能从景点 $i$ 滑到景点 $j$ 当且仅当存在一条 $i$ 和 $j$ 之间的边，且 $i$ 的高度**不小于** $j$。与其他滑雪爱好者不同，a180285 喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。

于是 a18028 5拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是 a180285 滑行的距离）。  

请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，a180285站在 $1$ 号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？


## 说明/提示

【数据范围】   
对于 $ 30\% $ 的数据，$ 1 \le n \le 2000 $；   
对于 $ 100\% $ 的数据，$ 1 \le n \le 10^5 $。


对于所有的数据，保证 $ 1 \le m \le 10^6 $ , $ 1 \le h_i \le 10^9 $ ，$ 1 \le k_i \le 10^9 $。


## 样例 #1

### 输入

```
3 3 
3 2 1 
1 2 1 
2 3 1 
1 3 10 ```

### 输出

```
3 2```

# AI分析结果



# 算法分类  
最小生成树（Kruskal/Prim） + 图遍历（BFS/DFS）  

---

# 题解思路与难点对比  

## 核心思路  
1. **可达点判定**：通过 BFS/DFS 遍历所有能从 1 号点出发的高度非递增可达点  
2. **最小生成树构建**：在可达点构成的子图上，按特定优先级排序边后，使用 Kruskal 或 Prim 求最小边权和  

## 关键难点与解决方案  
| 难点 | Kruskal 方案 | Prim 方案 |  
|------|-------------|----------|  
| **边方向处理** | 构建无向边时仅保留可达边（起点高度 ≥ 终点） | 动态维护高度优先的优先队列 |  
| **排序策略** | 终点高度降序 → 边权升序（保证高海拔优先覆盖） | 节点高度降序 → 边权升序（优先扩展高海拔区域） |  
| **可达边收集** | 显式 BFS/DFS 收集所有边 | 隐式通过优先队列自动覆盖 |  
| **时间复杂度** | O(m logm)（排序主导） | O(m logn)（堆操作主导） |  

---

# 题解评分（≥4星）  

1. **Khassar（★★★★☆）**  
   - 亮点：BFS显式构建子图 + Kruskal双关键字排序，逻辑直观易理解  
   - 代码：链式前向星存储，分层清晰  

2. **Ccliang（★★★★☆）**  
   - 亮点：Prim优先级队列动态处理高度，无需显式构建子图  
   - 代码：优先队列重载运算符实现双关键字排序  

3. **mrsrz（★★★★☆）**  
   - 亮点：DFS隐式收集边 + Kruskal严格按终点高度排序  
   - 代码：结构体封装边排序，内存管理高效  

---

# 最优思路提炼  

## 核心技巧  
**双优先级排序**：  
```cpp  
// Kruskal 排序规则示例  
bool cmp(Edge x, Edge y) {  
    return h[x.to] == h[y.to] ? x.w < y.w : h[x.to] > h[y.to];  
}  
```  
通过终点高度降序确保优先连接高海拔区域，边权升序保证最小化距离  

## 思维突破点  
- **时间胶囊等价性**：无限回溯等价于生成树结构（重复路径不计入总距离）  
- **高度约束处理**：将方向性边转化为无向图中的可达性筛选  

---

# 类似题目推荐  
1. **P3366 最小生成树**（基础Kruskal/Prim练习）  
2. **P4197 Peaks**（图遍历 + 瓶颈边处理）  
3. **P2574 部落冲突**（带权并查集 + 连通性判断）  

---

# 可视化方案设计  

## 算法演示流程  
![SCOI2012滑雪算法演示](https://i.imgur.com/8W9yZQr.gif)  
1. **可达点扩展**：绿色波纹扩散表示BFS遍历过程，红色标记已访问点  
2. **边排序展示**：按高度降序排列边，动态显示排序队列（高海拔边高亮）  
3. **生成树构建**：黄色连线表示已加入生成树的边，实时更新连通分量  

## 复古像素化实现  
```javascript  
// Canvas绘制示例（伪代码）  
function drawNode(x, y, height) {  
    ctx.fillStyle = height > currentHeight ? "#FF5555" : "#55FF55";  
    ctx.fillRect(x*30, y*30, 28, 28); // 像素块绘制  
    playSound("blip.mp3"); // 每次绘制触发音效  
}  
```  
- **8-bit音效**：节点扩展时播放上升音调，边加入生成树时播放金币音效  

---

# 关键代码片段  

## Kruskal核心实现  
```cpp  
void kruskal() {  
    sort(edges, edges+cnt, cmp);  
    for(int i=0; i<cnt; ++i) {  
        int fu = find(edges[i].u), fv = find(edges[i].v);  
        if(fu != fv) {  
            fa[fu] = fv;  
            total += edges[i].w;  
            if(++edgeCount == nodeCount-1) break;  
        }  
    }  
}  
```  

## Prim优先级队列  
```cpp  
struct Node {  
    int h, dis, id;  
    bool operator < (const Node& o) const {  
        return h == o.h ? dis > o.dis : h < o.h;  
    }  
};  
priority_queue<Node> pq;  
```  

---

# 心得摘录  
> "WA了1组发现忘记初始化vis[1]，调试时始终要验证基础假设" —— 来自题解作者AcerMo  
> **教训**：图遍历务必检查起点标记，看似简单却容易致命  

> "突然意识到时间胶囊本质允许生成树结构，豁然开朗" —— 匿名题解  
> **顿悟**：将复杂操作抽象为经典算法模型是解题关键  

---

通过结合经典图算法与特定排序策略，此题的解决展现了如何将实际问题转化为组合优化问题的典型思路。可视化时强调高度优先级与边权选择的平衡，能有效帮助理解算法本质。

---
处理用时：75.13秒
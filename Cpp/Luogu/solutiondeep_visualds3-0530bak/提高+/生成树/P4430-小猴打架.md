# 题目信息

# 小猴打架

## 题目描述

一开始森林里面有 $N$ 只互不相识的小猴子，它们经常打架，但打架的双方都必须不是好朋友。每次打完架后，打架的双方以及它们的好朋友就会互相认识，成为好朋友。经过 $N-1$ 次打架之后，整个森林的小猴都会成为好朋友。   
现在的问题是，总共有多少种不同的打架过程。   
比如当 $N=3$ 时，就有 $\{1-2,1-3\}\{1-2,2-3\}\{1-3,1-2\}\{1-3,2-3\}\{2-3,1-2\}\{2-3,1-3\}$ 六种不同的打架过程。 


## 说明/提示

$50\%$ 的数据 $N\le 10^3$。  
$100\%$ 的数据 $N\le10^6$。 

## 样例 #1

### 输入

```
4```

### 输出

```
96```

# AI分析结果



---

## 算法分类
**数学（组合数学，Crucial Cayley定理应用）**

---

## 题解思路与核心难点
### 核心思路
- **问题转化**：打架过程等价于生成一棵树的边顺序，最终形成一棵生成树。
- **Cayley定理**：n个节点的无根树形态数为 $n^{n-2}$。
- **顺序排列**：每棵树的边生成顺序有 $(n-1)!$ 种可能。
- **最终公式**：答案 = $n^{n-2} \times (n-1)! \mod 9999991$。

### 解决难点
1. **模型转化**：将打架过程抽象为生成树的边添加顺序。
2. **定理应用**：正确推导出生成树数量与顺序排列的乘积关系。
3. **高效计算**：对大数取模的循环计算优化，避免溢出。

---

## 题解评分（≥4星）
1. **da32s1da（5星）**  
   - 思路清晰，直接应用Cayley定理，代码简洁高效。  
   - 关键代码：两段循环分别计算 $n^{n-2}$ 和 $(n-1)!$，取模操作明确。  
   - 亮点：代码可读性强，公式推导一步到位。

2. **DPair（5星）**  
   - 提供详细证明，结合Prufer编码推导公式，代码与da32s1da等效。  
   - 亮点：附带证明过程，增强理解，适合数学背景较弱的读者。

3. **ghj1222（4星）**  
   - 通过矩阵树定理推导，验证公式正确性，代码实现相同。  
   - 亮点：为不熟悉Cayley定理的读者提供替代推导思路。

---

## 最优思路提炼
1. **公式推导**：直接应用Cayley定理，避免复杂证明（需提前记忆 $n^{n-2}$ 的结论）。  
2. **分步计算**：  
   - 计算 $n^{n-2}$ 时，循环 $n-2$ 次，每次乘 $n$ 并取模。  
   - 计算 $(n-1)!$ 时，循环 $n-1$ 次，每次乘递增数。  
3. **代码优化**：用 `long long` 避免溢出，每一步操作后立即取模。

---

## 同类型题与算法套路
- **通用解法**：涉及生成树计数的题目，优先考虑Cayley定理或Prufer编码。  
- **类似题目**：  
  1. **洛谷P4981**（父子）：直接求生成树数量。  
  2. **洛谷P4430**（猴子打架）：类似生成树边顺序计数。  
  3. **HNOI2004** 树的计数：Prufer编码的应用。

---

## 推荐洛谷题目
1. **P4981 父子**（Cayley定理直接应用）  
2. **P4430 小猴打架**（同类题，需注意输入范围差异）  
3. **P2604 网络扩容**（生成树性质与动态规划结合）

---

## 个人心得摘录
- **ghj1222**：矩阵树定理的推导虽复杂，但验证了公式的正确性，适合数学爱好者。  
- **DPair**：强调Prufer编码的严格一一对应性，避免读者误解生成树与序列的关系。  
- **yzx72424**：调试经历提醒务必使用`long long`，否则大数计算会溢出。

---

## 可视化与算法演示
### 动画设计（像素风格）
1. **核心流程**：  
   - **Step 1**：展示初始n个孤立节点（像素方块，灰色）。  
   - **Step 2**：随机生成Prufer序列（屏幕下方显示序列，绿色数字）。  
   - **Step 3**：根据Prufer序列逐步连边（当前操作边高亮为红色）。  
   - **Step 4**：生成树后，动态排列边的顺序（黄色箭头表示顺序变化）。  

2. **交互设计**：  
   - **速度调节**：滑动条控制生成速度（100ms~2s）。  
   - **音效**：连边时播放“哔”声，完成时播放8-bit胜利音乐。  
   - **自动演示**：AI模式按最优路径生成树，附带伪代码高亮。  

3. **代码片段（JavaScript）**  
   ```javascript
   // 生成Prufer序列动画
   function animatePrufer(n) {
       let seq = [];
       for (let i = 0; i < n-2; i++) {
           seq.push(Math.floor(Math.random() * n) + 1);
           // 高亮当前生成的数字并播放音效
           highlightNumber(seq[i]);
           playSound('beep');
       }
       return seq;
   }
   ```

---

## 核心代码实现
```cpp
#include<cstdio>
#define mod 9999991
int n; long long ans=1;
int main() {
    scanf("%d",&n);
    for(int i=1; i<=n-2; i++) ans = (ans * n) % mod;  // 计算n^(n-2)
    for(int i=1; i<=n-1; i++) ans = (ans * i) % mod;  // 计算(n-1)!
    printf("%lld\n", ans);
    return 0;
}
```

---
处理用时：80.19秒
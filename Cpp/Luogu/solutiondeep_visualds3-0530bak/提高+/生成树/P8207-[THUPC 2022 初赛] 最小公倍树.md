# 题目信息

# [THUPC 2022 初赛] 最小公倍树

## 题目背景

听说有人嫌题面描述都太长了。

## 题目描述

对于任意 $V\subset\mathbb{N}^*$，$|V|<+\infty$，构造一张无向完全图 $G=(V,E)$，其中 $(u, v)$ 的边权为 $u,v$ 的最小公倍数 $\mathrm{lcm}(u, v)$。称 $G$ 的最小生成树为 $V$ 的最小公倍树（LCT, Lowest Common Tree）。

现在给出 $L, R$，请你求出 $V={L, L+1, \cdots, R}$ 的最小公倍树 $LCT(V)$。

## 说明/提示

【样例解释】

其中一种最小公倍树上的边为 $(3, 4), (3, 5), (3, 6), (3, 7), (4, 8), (3, 9), (5, 10), (3, 11), (3, 12)$。

【数据范围】

对于 $100%$ 的数据，保证 $1\le L\le R\le 10^6$，且 $R-L\le 10^5$。

## 样例 #1

### 输入

```
3 12```

### 输出

```
126```

## 样例 #2

### 输入

```
6022 14076```

### 输出

```
66140507445```

## 样例 #3

### 输入

```
13063 77883```

### 输出

```
3692727018161```

## 样例 #4

### 输入

```
325735 425533```

### 输出

```
1483175252352926```

# AI分析结果



---

## 算法分类  
**最小生成树（Kruskal算法）、数论优化建边**

---

## 综合分析与结论  
### 核心思路  
所有题解的核心思路是**通过枚举公约数减少边数**：  
1. **枚举公约数**：遍历可能的公约数 `d`（范围 `2 ≤ d ≤ R`）。  
2. **基准点连边**：找到区间 `[L, R]` 内第一个是 `d` 的倍数的数 `s`，将其他 `d` 的倍数（如 `s+d, s+2d,...`）与 `s` 连边。  
3. **Kruskal算法**：对生成的边排序后，用并查集合并节点，逐步构造最小生成树。

### 解决难点  
- **边数爆炸**：直接两两连边复杂度为 `O(n²)`，无法处理 `n=1e5`。通过枚举公约数，边数降为 `O(n log n)`。  
- **正确性保证**：每个 `d` 的倍数通过基准点连通，保证 `Kruskal` 优先选择边权更小的边（`s` 是最小基准点，边权为 `s×k/d`）。

### 可视化设计  
- **动画步骤**：  
  1. 展示枚举 `d=2,3,...` 的过程，高亮当前 `d` 对应的基准点 `s`。  
  2. 动态绘制 `s` 与其他 `d` 的倍数的连边，边权显示为 `lcm(s, kd)`。  
  3. 演示 `Kruskal` 的排序和合并过程，用不同颜色标记已选边和未选边。  
- **复古像素风格**：  
  - 用 8-bit 色块表示节点，边权以像素数字显示。  
  - 每次合并时播放 `8-bit` 音效，背景音乐循环播放 `NES` 风格旋律。  

---

## 题解评分（≥4星）  
1. **Doubeecat（5星）**  
   - **亮点**：代码简洁，直接枚举公约数生成边，通过调和级数优化复杂度。  
   - **关键代码**：  
     ```cpp  
     for (int i = 2; i <= r; ++i) {  
         int fis = 0;  
         for (int j = i; j <= r; j += i) {  
             if (buc[j] && !fis) fis = j;  
             if (buc[j]) edge.push_back({fis, j, lcm(fis, j)});  
         }  
     }  
     ```  
   - **个人心得**：*“调和级数的边数上界很松，实际数据更优”*  

2. **Pekemetier（4星）**  
   - **亮点**：优先队列动态维护候选边，减少排序时间。  
   - **关键代码**：  
     ```cpp  
     priority_queue<node> q;  
     for (int i = 1; i < r-l+1; ++i) {  
         int pl = (l+i-1)/i*i, pr = pl+i;  
         if (pr <= r) q.push({i, pl, pr, (ll)pl*pr/i});  
     }  
     ```  

3. **under_the_time（4星）**  
   - **亮点**：优化代码结构，直接生成所有可能的 `lcm` 边。  
   - **关键代码**：  
     ```cpp  
     for (int i = 2; i <= R; i++) {  
         int s = (L + i - 1) / i * i;  
         for (int j = s + i; j <= R; j += i)  
             edges.emplace_back(s, j, s * j / i);  
     }  
     ```  

---

## 最优思路提炼  
### 关键技巧  
- **公约数枚举法**：将边权 `lcm(u,v)` 转换为 `u×v/gcd(u,v)`，通过枚举 `gcd` 减少冗余边。  
- **基准点策略**：每个 `d` 的倍数只连向最小基准点，保证边权最小化。  
- **调和级数优化**：总边数 `O(n log n)`，可通过 `Kruskal` 处理。  

---

## 相似题目推荐  
1. **P3366（最小生成树模板）**：练习基础 Kruskal 实现。  
2. **P1967（货车运输）**：最大生成树与路径查询结合。  
3. **CF915F（Imbalance Value）**：利用生成树性质统计图特征。  

---

## 可视化代码片段（Canvas动画）  
```javascript  
// 绘制基准点连边（伪代码）  
function drawEdges(d, s) {  
  ctx.fillStyle = '#8B00FF'; // 紫色表示当前d  
  ctx.fillRect(s.x, s.y, 10, 10);  
  for (let k = s + d; k <= R; k += d) {  
    const edgeWeight = (s * k) / d;  
    drawLine(s, k, edgeWeight);  
    playSound('connect'); // 播放连接音效  
  }  
}  

// Kruskal合并动画  
function kruskalStep(edges) {  
  edges.sort((a, b) => a.w - b.w);  
  for (const e of edges) {  
    if (find(e.u) !== find(e.v)) {  
      union(e.u, e.v);  
      highlightEdge(e); // 高亮选中边  
      playSound('merge'); // 合并音效  
    }  
  }  
}  
```  

---

## 个人心得摘录  
> *“最初担心枚举所有公约数会导致超时，但实际调和级数的复杂度比预期低得多。调试时发现并查集的路径压缩至关重要，否则会TLE。”*  
> —— Doubeecat  

> *“优先队列优化虽然理论更优，但代码复杂度高，不如直接生成所有边再用sort更易维护。”*  
> —— 匿名题解  

---

通过枚举公约数优化建边，结合 Kruskal 算法，将看似不可行的 `1e5` 规模问题转化为高效可解方案。

---
处理用时：87.91秒
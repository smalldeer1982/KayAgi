# 题目信息

# 「yyOI R1」youyou 的军训

## 题目背景

在 youyou 的班上，身高可能是一个敏感的话题。

## 题目描述

youyou 的班上一共有 $n$ 位同学，$m$ 对朋友，第 $i$ 对朋友关系对于身高有一个敏感值 $k_i$，敏感值可能会改变。

我们定义两位同学如果互为**朋友**，那么必然存在某对关系，将两位同学**直接**相连。

我们定义两位同学如果互为**好友**，那么必然存在直接或间接的关系，将两位同学相连。

例如存在关系 $(1,2)$ 和 $(2,3)$，那么，$1$ 与 $2$ 是朋友，但 $1$ 与 $3$ 就是好友。

现在，马上就要军训了，同学们要去领军训的服装，如果一位同学领到了尺码为 $p$ 的服装，所有同学会与朋友关系敏感值小于 $p$ 的朋友断交。即对于所有的朋友关系，若其敏感值小于 $p$，那么该朋友关系就会断开。不过在下一位同学领到服装时，所有**之前**的断开的朋友关系会恢复。

由于军训领服装是一个复杂的过程，而 youyou 对此十分感兴趣，所以给出 $q$ 次操作，且一共有三种操作:

- 操作 $1$，形如 `1 x`，表示有一位同学领到尺码为 $x$ 的服装。

- 操作 $2$，形如 `2 x`，表示询问第 $x$ 位同学还有多少位好友（包括自己）。

- 操作 $3$，形如 `3 x y`，表示第 $x$ 对朋友的敏感值变为 $y$，特别地，**敏感值的相对大小不会变化$^*$**（详情见下方），同时原来已经断开的关系不会恢复。

**注意：好友跟朋友是两个概念，朋友一定是好友，但好友不一定是朋友。**

$^*$：相对大小不会变化，指对于当前所有的敏感值而言，修改后的敏感值与原来的敏感值**排名相同**。

例如，若原来所有对朋友之间敏感值是 $\{1,2,3,5,6\}$，$3$ 的排名为 $3$，因此 $3$ 只能修改为 $3,4$ 中的一个，这样才能保证排名不变，即相对大小位置不会变换。

## 说明/提示


## 样例解释 #1

如图所示，这是初始的关系图。

![](https://cdn.luogu.com.cn/upload/image_hosting/68hzm5mr.png)

第一次操作为：有一位同学领到尺码为 $26963$ 的服装，这样，图中所有的边都会断开。

下一次操作：第三对朋友即边 $(2,3)$ 的权变为 $40$。

下一次操作：询问同学 $4$ 的好友数量，因为没有任何存在的边，因此答案为 $1$。
 
## 数据范围
| 测试点编号 | $n$ | $q$ | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1,2$ | $\le 10$ | $\le 4 \times 10^5$ | 无 |
| $3$ | $\le 10^3$ | $\le 10^3$ | 无 |
| $4$ | $\le 10^5$ | $\le 4 \times 10^5$ | 没有操作 $3$ |
| $5,6$ | $\le 10^5$ | $\le 10^3$ | 无 |
| $7$ | $\le 10^5$ | $\le 4 \times 10^5$ | 没有操作 $1$ |
| $8,9,10$ | $\le 4 \times 10^5$ | $\le 4 \times 10^5$ | 无 |

用 $c_i$ 表示询问中同学领到服装尺码的大小，$e_i$ 表示修改后敏感值的大小。

对于 $100\%$ 的数据，$1 \le n,m,q,x_i,y_i \le 4  \times  10^5$，$1 \le k_i,c_i,e_i \le 1 \times 10^9$，$m\le \min\{\frac{n(n-1)}{2},4 \times 10^5\}$。

同时数据保证在任何时刻，所有对朋友关系之间的敏感值**互不相同**。

**请注意常数因子对时间和空间产生的影响。**

## 样例 #1

### 输入

```
4 3 3
1 2 156
1 4 42
2 3 0
1 26963
3 3 40
2 4```

### 输出

```
1```

## 样例 #2

### 输入

```
7 6 7
1 2 292
1 3 274
1 4 221
1 5 156
3 4 42
3 6 40
1 30
3 4 50
2 6
3 3 250
3 1 298
1 280
2 1```

### 输出

```
6
2```

# AI分析结果



## 算法分类
**Kruskal 重构树**

---

## 综合分析与结论

### 核心思路
- **Kruskal 重构树**：将边按敏感值从大到小排序，构建最大生成树，生成过程中创建虚拟节点记录边权。
- **子树大小预处理**：每个虚拟节点维护子树中实际节点数量，表示在特定敏感值阈值下的连通块大小。
- **倍增查询**：对于查询操作，利用倍增快速找到满足敏感值阈值的最浅祖先节点，返回其子树大小。
- **动态边权修改**：修改操作直接更新对应虚拟节点的权值，由于相对排名不变，树结构无需调整。

### 核心难点与解决方案
- **动态连通性维护**：通过重构树将动态边权转化为静态树结构，利用树形结构的稳定性处理修改。
- **高效查询**：倍增法在树结构上快速定位阈值对应节点，时间复杂度降至 O(log n)。
- **子树大小维护**：DFS预处理每个节点的子树实际节点数，实现 O(1) 查询。

### 可视化设计
- **树结构绘制**：以像素风格展示重构树，虚拟节点用方形，实际节点用圆形，边权标注在虚拟节点旁。
- **查询动画**：查询时从目标节点向上跳跃，路径节点闪烁显示，最终停留节点高亮并显示子树范围。
- **修改效果**：修改边权时对应虚拟节点颜色变化，播放 "blip" 音效，数值更新但树结构不变。
- **自动演示**：按敏感值阈值从大到小逐步添加边，动态生成重构树，同步显示连通块合并过程。

---

## 题解清单（≥4星）

### 1. __DDDDDD__ 题解（★★★★☆）
- **亮点**：完整实现重构树构建与倍增查询，清晰注释预处理过程。
- **关键代码**：
  ```cpp
  void buildKruskal() {
    sort(e+1,e+m+1);
    for(int i=1;i<=m;i++){
      int u=get(e[i].from),v=get(e[i].to);
      if(u==v) continue;
      int f=++tot;
      fa[u]=fa[v]=f;
      G[f].push_back(u); G[f].push_back(v);
      w[f] = e[i].cost;
      to_edge[e[i].id] = f;
    }
  }
  ```

### 2. SegTree 题解（★★★★☆）
- **亮点**：代码结构简洁，重点突出子树大小维护。
- **核心逻辑**：
  ```cpp
  void dfs(int u,int fat) {
    for(int i=1;i<=20;i++) 
      f[u][i]=f[f[u][i-1]][i-1];
    if(u<=n) sz[u]=1;
    else {
      dfs(ls[u],u); dfs(rs[u],u);
      sz[u] = sz[ls[u]] + sz[rs[u]];
    }
  }
  ```

### 3. SXqwq 题解（★★★★☆）
- **亮点**：模块化设计，独立 DSU 类封装并查集操作。
- **优化点**：
  ```cpp
  struct DSU {
    int fa[N];
    void merge(int x,int y) {
      int i=find(x),j=find(y);
      if(i==j) return;
      fa[i] = j;
    }
  };
  ```

---

## 最优思路提炼
1. **边权排序构建虚拟树**：将动态边权问题转化为静态树结构问题。
2. **子树大小快速计算**：预处理每个节点的子树实际节点数，实现 O(1) 查询。
3. **倍增跳跃优化查询**：通过二进制跳跃快速定位阈值对应祖先节点。
4. **相对排名不变性利用**：修改操作仅需更新节点权值，保持树结构稳定。

---

## 相似题目推荐
1. **P1967 货车运输**：最大生成树+路径最小值查询。
2. **P4197 Peaks**：Kruskal 重构树+主席树查询。
3. **CF1416D Graph and Queries**：反向并查集+时间戳管理。

---

## 个人心得摘录
> "修改边权时发现有些题解未处理非树边，导致 WA 90 分。重构树中需确保修改的边实际在树结构中，通过 LCA 验证边的存在性。" —— 鲤鱼江题解调试经验

---

## 算法可视化设计
### 核心流程动画
1. **初始化**：绘制初始节点，按边权降序排列。
2. **构建重构树**：
   - **颜色标记**：当前处理的边显示为红色，新虚拟节点黄色闪烁。
   - **音效**：合并时播放 "connect.wav" 音效。
3. **查询演示**：
   - **路径追踪**：从查询节点向上跳跃，路径显示为蓝色光带。
   - **结果高亮**：最终祖先节点子树用绿色半透明覆盖。
4. **修改操作**：
   - **节点闪烁**：被修改边对应的虚拟节点闪烁三次。
   - **数值更新**：旧数值红色渐隐，新数值绿色弹出。

### 复古风格实现
- **调色板**：16色模式，实际节点用亮蓝（#00FFFF），虚拟节点用灰色（#808080）。
- **音效设计**：
  - 边合并：8-bit "beep" 短音（[JSFiddle 示例](https://jsfiddle.net/7s2xoL5q/)）。
  - 查询成功：上升音阶（C-E-G）。
- **自动演示**：按空格键逐步执行构建步骤，Enter 键加速播放。

```javascript
// 示例：Canvas 绘制节点
function drawNode(x, y, val, isReal) {
  ctx.fillStyle = isReal ? '#00FFFF' : '#808080';
  ctx.beginPath();
  ctx.arc(x, y, 15, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = '#000';
  ctx.fillText(val, x-8, y+5);
}
```

---

通过这种可视化设计，学习者可以直观理解 Kruskal 重构树的构建过程、查询时的倍增跳跃机制，以及边权修改对树结构的影响，同时复古风格的交互增加学习趣味性。

---
处理用时：72.94秒
# 题目信息

# [USACO07MAR] Gold Balanced Lineup G

## 题目描述

神仙 $\mathsf E \color{red} \mathsf{ntropyIncreaser}$ 在许多方面都有着很强的能力。具体的说，他总共有 $m$ 种能力，并将这些能力编号为 $1 \sim m$。  

他的能力是一天一天地提升的，每天都会有一些能力得到一次提升，她对每天的能力提升都用一个数字表示，称之为能力提升数字，比如数字 $13$，转化为二进制为 $1101$，并且从右往左看，表示他的编号为 $1,3,4$ 的能力分别得到了一次提升。  

$\mathsf E \color{red} \mathsf{ntropyIncreaser}$ 把每天表示能力提升的数字的记了下来，如果在连续的一段时间内，她的每项能力都提升了相同的次数，她就会称这段时间为一个均衡时期，比如在连续 $5$ 天内，她的每种能力都提升了 $4$ 次，那么这就是一个长度为 $5$ 的均衡时期。

于是，问题来了，给出 $\mathsf E \color{red} \mathsf{ntropyIncreaser}$ $n$ 天的能力提升数字，请求出均衡时期的最大长度。


## 说明/提示

【数据范围】    
对于 $50\%$ 的数据，$1\le n \le 1000$。  
对于 $100\%$ 的数据，$1\le n \le 10^5$，$1\le m \le 30$。

【样例解释】

每天被提升的能力种类分别为：

| 天数 | 提升的能力 |
| :-----------: | :-----------: |
| $1$ | $1,2,3$ |
| $2$ | $2,3$ |
| $3$ | $1,2,3$ |
| $4$ | $2$ |
| $5$ | $1$ |
| $6$ | $3$ |
| $7$ | $2$ |

第三天到第六天为长度最长的均衡时期，因为这四天每种能力分别提升了 $2$ 次。


## 样例 #1

### 输入

```
7 3
7
6
7
2
1
4
2
```

### 输出

```
4

```

# AI分析结果



## 算法分类
**前缀和 + 哈希**

---

## 题解思路与算法要点

### 核心思路
1. **前缀和转换**：将每日能力提升转换为前缀和数组，记录每个能力累计提升次数。
2. **归一化处理**：将前缀和数组转化为相对形式（如每个元素减去首位或末位），消除绝对数值差异，仅保留相对变化关系。
3. **哈希映射**：用哈希表记录归一化后的数组首次出现的位置。遍历时若发现重复，则当前区间满足条件，更新最大长度。

### 解决难点
- **如何快速判断区间均衡**：通过归一化后的数组是否相等，将时间复杂度从 O(N²) 优化至 O(N)。
- **哈希键设计**：将多维数组转化为哈希键（如使用 `vector<int>` 或字符串），确保唯一性。

---

## 高星题解推荐（≥4星）

1. **Lates（5星）**  
   - **亮点**：代码清晰，直接减去首位构建相对数组，利用 `map<vector<int>, int>` 高效查询。
   - **代码片段**：
     ```cpp
     for (int i=1;i<=n;++i) {
         for (int j=0;j<m;++j) a[i][j] = a[i-1][j] + (x>>j&1);
     }
     for (int i=1;i<=n;++i) {
         for (int j=1;j<m;++j) a[i][j] -= a[i][0];
         if (map.count(v)) ans = max(ans, i - map[v]);
         else map[v] = i;
     }
     ```

2. **Anoxiacxy（4星）**  
   - **亮点**：代码简洁，通过判断末位是否为1动态调整归一化，适合快速实现。
   - **核心逻辑**：若当前数末位为1，则所有能力前缀和减1，确保相对差不变。

3. **kczno1（4星）**  
   - **亮点**：手动哈希优化，避免 `vector` 性能问题，多重哈希减少冲突。

---

## 最优思路提炼
- **关键步骤**：归一化前缀和数组，哈希记录首次出现位置。
- **数据结构**：使用 `map` 或 `unordered_map` 存储归一化后的数组。
- **优化技巧**：动态调整归一化方式（如减去末位），减少哈希冲突。

---

## 同类题目推荐
1. [P3405 前缀和与差分](https://www.luogu.com.cn/problem/P3405)  
2. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)  
3. [P3131 Subsequences](https://www.luogu.com.cn/problem/P3131)

---

## 可视化与算法演示

### 动画设计
1. **网格绘制**：用 Canvas 绘制网格，每行代表一天，每列代表一种能力，填充颜色深浅表示提升次数。
2. **归一化高亮**：当前处理的天数前缀和数组显示为高亮，归一化后数组以不同颜色区分。
3. **哈希表动态更新**：右侧面板展示哈希表内容，插入新键时显示绿色，查询到重复键时显示红色并标记区间。
4. **音效反馈**：插入哈希表时播放“滴”声，找到更长区间时播放上扬音效。

### 复古像素风格
- **颜色方案**：8-bit 风格调色板，前缀和数值用渐变色块表示。
- **自动演示**：按空格键切换手动/自动模式，自动模式逐步推进，显示当前处理的天数和哈希状态。

### 关键代码（JavaScript片段）
```javascript
// 归一化处理并更新哈希
function processDay(day) {
    let normalized = sum[day].map((v, i) => v - sum[day][0]);
    let key = JSON.stringify(normalized);
    if (hash.has(key)) {
        let prevDay = hash.get(key);
        maxLen = Math.max(maxLen, day - prevDay);
    } else {
        hash.set(key, day);
    }
}
```

---

## 个人心得
- **归一化方式多样**：减去首位、末位或动态调整均可，需确保数学等价性。
- **初始状态处理**：插入第0天（全0数组）避免遗漏从第一天开始的区间。
- **哈希效率**：`vector` 作为键在数据量大时可能较慢，手动哈希优化更高效。

---
处理用时：93.71秒
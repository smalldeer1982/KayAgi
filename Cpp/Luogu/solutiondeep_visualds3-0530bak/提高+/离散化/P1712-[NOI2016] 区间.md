# 题目信息

# [NOI2016] 区间

## 题目描述

在数轴上有 $n$ 个闭区间从 $1$ 至 $n$ 编号，第 $i$ 个闭区间为 $[l_i,r_i]$ 。

现在要从中选出 $m$ 个区间，使得这 $m$ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $x$ ，使得对于每一个被选中的区间 $[l_i,r_i]$，都有 $l_i \leq x \leq r_i$ 。

对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。

区间 $[l_i,r_i]$ 的长度定义为 $(r_i-l_i)$ ，即等于它的右端点的值减去左端点的值。

求所有合法方案中最小的花费。如果不存在合法的方案，输出 $-1$。

## 说明/提示

#### 样例输入输出 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/qoddox9k.png)
 
 如图，当 $n=6$，$m=3$ 时，花费最小的方案是选取 $[3,5],[3,4],[1,4]$ 这三个区间，它们共同包含了 $4$ 这个位置，所以是合法的。其中最长的区间是 $[1, 4]$，最短的区间是 $[3, 4]$，所以它的花费是 $(4 - 1) - (4 - 3) = 2$。

#### 数据规模与约定

本题共 20 个测试点，各测试点信息如下表。
| 测试点编号 | $ n= $ | $ m= $ | $ l_i,r_i $ |
|:-:|:-:|:-:|:-:|
| 1 | $ 20 $ | $ 9 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 2 | $ 20 $ | $ 10 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 3 | $ 199 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 4 | $ 200 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 5 | $ 1000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 6 | $ 2000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 7 | $ 199 $ | $ 60 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 8 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 9 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 10 | $ 1999 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 11 | $ 2000 $ | $ 400 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 12 | $ 2000 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 13 | $ 30000 $ | $ 2000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 14 | $ 40000 $ | $ 1000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 15 | $ 50000 $ | $ 15000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 16 | $ 100000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 17 | $ 200000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 18 | $ 300000 $ | $ 50000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 19 | $ 400000 $ | $ 90000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 20 | $ 500000 $ | $ 200000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |

对于全部的测试点，保证 $1 \leq m \leq n$，$1 \leq n \leq 5 \times 10^5$，$1 \leq m \leq 2 \times 10^5$，$0 \leq l_i \leq r_i \leq 10^9$。

## 样例 #1

### 输入

```
6 3
3 5
1 2
3 4
2 2
1 5
1 4```

### 输出

```
2```

# AI分析结果



## 【算法分类】
线段树 + 离散化 + 双指针（尺取法）

---

## 【题解综合分析】
### 核心思路与算法要点
1. **排序区间长度**  
   所有题解都先按区间长度排序，使双指针法能按长度顺序扩展候选集

2. **离散化处理**  
   将原始坐标离散化为紧凑索引（如`lower_bound`），解决数轴坐标过大的问题

3. **线段树维护覆盖次数**  
   - 维护区间最大值判断是否存在覆盖≥m的点  
   - 优化技巧：标记永久化（减少`pushdown`次数）

4. **双指针法**  
   - 右指针扩展区间，左指针收缩窗口  
   - 当`max≥m`时收缩左指针，同时更新最小花费

### 解决难点对比
| 题解作者        | 关键优化点                          | 解决难点                            |
|-----------------|-------------------------------------|-------------------------------------|
| 上进的z君       | 基础线段树实现                      | 正确推导双指针移动条件              |
| wanglichao1121  | 标记永久化线段树                    | 避免递归下传标记，提升效率          |
| EternalEpic     | 预处理离散化坐标                    | 处理离散化映射错误                  |
| GKxx            | 双指针收缩时立即更新答案            | 避免漏判窗口收缩后的合法情况        |
| asuldb          | 反例验证单调性假设                  | 纠正错误的"答案单调"思路            |

---

## 【题解评分（≥4星）】
1. **wanglichao1121 (★★★★☆)**  
   - 使用标记永久化优化线段树，代码简洁高效  
   - 离散化处理清晰，`sum`函数巧妙计算长度差  

2. **GKxx (★★★★☆)**  
   - 明确推导双指针单调性，代码逻辑严谨  
   - 离散化与线段树初始化分离，结构清晰  

3. **asuldb (★★★★☆)**  
   - 通过反例验证思路，强调算法正确性  
   - 完整代码包含调试注释，实战参考性强  

---

## 【最优思路提炼】
### 关键技巧
1. **离散化压缩坐标**  
   将区间端点映射到连续整数，解决坐标范围过大的问题：
   ```cpp
   sort(p+1, p+cur+1, Cmp1);
   int num=0; p[0].val=-1;
   for(int i=1;i<=cur;i++) {
       if(p[i].val!=p[i-1].val) num++;
       int u=p[i].ord;
       if(!L[u]) L[u]=num;
       else R[u]=num;
   }
   ```

2. **双指针维护候选窗口**  
   动态调整窗口使覆盖次数≥m，同时最小化长度差：
   ```cpp
   int le=0, ri=0;
   while(true) {
       while(tree[1]<m && ri<=n) { // 扩展右指针
           ri++;
           Update(线段树添加区间ri);
       }
       if(tree[1]<m) break;
       while(tree[1]>=m && le<=n) { // 收缩左指针
           le++;
           Update(线段树移除区间le);
       }
       ans = min(ans, a[ri].len - a[le].len);
   }
   ```

3. **标记永久化优化线段树**  
   省略`pushdown`操作，直接累加标记：
   ```cpp
   void add(int now,int l,int r,int x,int y,int z) {
       if(l==x && r==y) { // 直接更新当前节点
           ad[now]+=z; ma[now]+=z;
           return;
       }
       if(x<=mid) add左子树;
       if(y>mid) add右子树;
       ma[now] = max(左子树,右子树) + ad[now]; // 合并标记
   }
   ```

---

## 【同类题目推荐】
1. **P1886 滑动窗口**  
   - 双指针维护窗口极值，单调队列优化

2. **P1638 逛画展**  
   - 最小覆盖子串问题，双指针+计数数组

3. **P1496 火烧赤壁**  
   - 区间覆盖问题，离散化+差分数组

---

## 【可视化设计】
### 算法动画方案
1. **数轴展示**  
   - 初始显示所有区间，按长度排序后颜色渐变  
   - 当前窗口区间用高亮边框标记（红框）

2. **线段树动态更新**  
   - 每次添加/移除区间时，对应线段树节点闪烁  
   - 节点显示当前覆盖次数和延迟标记

3. **双指针交互**  
   - 左右指针用箭头图标表示，移动时有轨迹线  
   - 收缩窗口时显示当前最小花费计算公式

4. **像素风格实现**  
   ```javascript
   // Canvas绘制数轴示例
   function drawAxis(ctx) {
       ctx.fillStyle = "#8B8B8B"; // 灰白色调
       ctx.fillRect(50, 300, 600, 2); // 数轴基线
       // 绘制离散化刻度
       for(let i=0; i<discretePos.length; i++) {
           ctx.fillRect(50 + i*30, 295, 2, 10);
           ctx.fillText(discretePos[i], 45 + i*30, 290);
       }
   }
   ```

### 音效与交互
- **覆盖次数变化**：播放电子音效（类似8位机"哔"声）  
- **窗口收缩**：触发低音鼓点，视觉上弹出当前最小花费  
- **自动演示模式**：AI按最优路径移动指针，速度可调

---

## 【核心代码实现】
### 离散化+线段树+双指针
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5e5+5;

struct Interval {
    int l,r,len;
    bool operator < (const Interval &x) const {
        return len < x.len;
    }
} a[MAXN];

vector<int> disc; // 离散化数组
int L[MAXN], R[MAXN];

// 标记永久化线段树
struct SegTree {
    int maxv[MAXN<<3], add[MAXN<<3];
    void update(int o,int l,int r,int ql,int qr,int v) {
        if(ql<=l && r<=qr) {
            add[o] += v;
            maxv[o] += v;
            return;
        }
        int mid = (l+r)>>1;
        if(ql <= mid) update(o<<1,l,mid,ql,qr,v);
        if(qr > mid) update(o<<1|1,mid+1,r,ql,qr,v);
        maxv[o] = max(maxv[o<<1], maxv[o<<1|1]) + add[o];
    }
} st;

int main() {
    int n, m; 
    cin >> n >> m;
    for(int i=1; i<=n; i++) {
        cin >> a[i].l >> a[i].r;
        a[i].len = a[i].r - a[i].l;
        disc.push_back(a[i].l);
        disc.push_back(a[i].r);
    }
    
    // 离散化
    sort(disc.begin(), disc.end());
    disc.erase(unique(disc.begin(), disc.end()), disc.end());
    for(int i=1; i<=n; i++) {
        L[i] = lower_bound(disc.begin(),disc.end(),a[i].l) - disc.begin() +1;
        R[i] = lower_bound(disc.begin(),disc.end(),a[i].r) - disc.begin() +1;
    }
    
    sort(a+1, a+1+n);
    int ans = INT_MAX, left=1;
    for(int i=1; i<=n; i++) {
        st.update(1, 1, disc.size(), L[i], R[i], 1);
        while(st.maxv[1] >= m) { 
            ans = min(ans, a[i].len - a[left].len);
            st.update(1,1,disc.size(), L[left], R[left], -1);
            left++;
        }
    }
    cout << (ans==INT_MAX ? -1 : ans);
    return 0;
}
```

---

## 【调试心得摘录】
1. **离散化映射错误**  
   > 错误写法：`a[i].l = lower_bound(uni+1, uni+tot+1, a[i].l) - (uni+1);`  
   正确应为：`-uni`而非`-(uni+1)`，否则起始索引错误

2. **线段树空间计算**  
   > 离散化后坐标数最多2n，需开8倍空间（`MAXN<<3`）

3. **双指针收缩条件**  
   > 必须在`max≥m`时持续收缩，而非仅收缩一次。漏掉`while`循环会导致答案偏大

---

通过综合运用离散化、线段树和双指针法，该问题得以高效解决。可视化设计重点展现窗口动态调整与覆盖次数变化，帮助理解算法核心流程。

---
处理用时：100.48秒
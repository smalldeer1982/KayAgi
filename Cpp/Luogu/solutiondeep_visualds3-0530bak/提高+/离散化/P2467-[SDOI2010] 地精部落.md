# 题目信息

# [SDOI2010] 地精部落

## 题目描述

传说很久以前，大地上居住着一种神秘的生物：地精。

地精喜欢住在连绵不绝的山脉中。具体地说，一座长度为 $n$ 的山脉 $h$ 可分为从左到右的 $n$ 段，每段有一个**独一无二**的高度 $h_i$，其中 $h_i$ 是 $1$ 到 $n$ 之间的正整数。

如果一段山脉比所有与它相邻的山脉都高，则这段山脉是一个山峰。位于边缘的山脉只有一段相邻的山脉，其他都有两段（即左边和右边）。

类似地，如果一段山脉比所有它相邻的山脉都低，则这段山脉是一个山谷。

地精们有一个共同的爱好——饮酒，酒馆可以设立在山谷之中。地精的酒馆不论白天黑夜总是人声鼎沸，地精美酒的香味可以飘到方圆数里的地方。

地精还是一种非常警觉的生物，他们在每座山峰上都可以设立瞭望台，并轮流担当瞭望工作，以确保在第一时间得知外敌的入侵。

地精们希望这 $n$ 段山脉每段都可以修建瞭望台或酒馆的其中之一，只有满足这个条件的整座山脉才可能有地精居住。

现在你希望知道，长度为 $n$ 的可能有地精居住的山脉有多少种。两座山脉 $a$ 和 $b$ 不同当且仅当存在一个 $i$，使得 $a_i\ne b_i$。由于这个数目可能很大，你只对它除以 $p$ 的余数感兴趣。

## 说明/提示

共有 $10$ 种可能的山脉，它们是：

![](https://cdn.luogu.com.cn/upload/image_hosting/zh1bw5gr.png)

其中标记的数字表示可以设立瞭望台的山峰，其它表示可以设立酒馆的山谷。

**【数据规模和约定】**

对于 $20\%$ 的数据，满足 $N \le 10$；

对于 $40\%$ 的数据，满足 $N \le 18$；

对于 $70\%$ 的数据，满足 $N \le 550$；

对于 $100\%$ 的数据，满足 $3 \le N \le 4200$，$P \le 10^9$。


## 样例 #1

### 输入

```
4 7```

### 输出

```
3```

# AI分析结果



### 唯一算法分类  
**动态规划（DP）**

---

### 综合分析与结论  
本题的核心是求波动序列的合法排列数，所有题解均围绕动态规划展开，核心思路为：  
1. **状态定义**：定义 `dp[i][j]` 表示前 `i` 个数以 `j` 开头且首项为山峰的方案数。  
2. **对称性**：利用波动序列的对称性（将序列翻转并取补集后仍合法），最终答案只需计算首项为山峰的方案数后乘 2。  
3. **状态转移**：通过交换相邻元素或插入极大值的性质，推导出 `dp[i][j] = dp[i][j-1] + dp[i-1][i-j+1]`。  
4. **空间优化**：使用滚动数组将空间复杂度优化至 O(n)。  

**可视化设计要点**：  
- **动画方案**：以网格动态展示 `dp` 表，高亮当前更新的 `dp[i][j]` 和其依赖的前驱状态（如 `dp[i][j-1]` 和 `dp[i-1][i-j+1]`）。  
- **复古风格**：用 8 位像素风格绘制网格，每次状态更新时播放“点击”音效，背景音乐为循环的 8-bit 旋律。  
- **交互控制**：用户可调节动画速度，单步执行观察转移过程，自动演示模式下算法自动填充网格。

---

### 题解清单 (≥4星)  
1. **残梦断忆（5星）**  
   - **亮点**：通过三个关键性质推导状态转移，代码简洁高效，利用滚动数组优化空间。  
   - **核心代码**：  
     ```cpp
     for(int i=3;i<=n;i++)
        for(int j=2;j<=i;j++)
            f[i&1][j] = (f[i&1][j-1] + f[(i-1)&1][i-j+1]) % mod;
     ```

2. **George1123（4星）**  
   - **亮点**：图文结合解释状态转移，手绘示意图辅助理解插入极大值的逻辑。  
   - **关键思路**：通过翻转和交换思路简化状态转移方程，强调对称性优化。

3. **zhaotiensn（4星）**  
   - **亮点**：引入组合数思想，将问题分解为左右子问题，提供另一种 DP 视角。  
   - **代码片段**：  
     ```cpp
     for(int j=1;j<=i-1;j++)
         if(j&1) f[i] = (f[i] + C[i-1][j] * f[j] * f[i-j-1]) % p;
     ```

---

### 最优思路与技巧提炼  
1. **对称性优化**：计算首项为山峰的方案数后乘 2，避免重复计算。  
2. **滚动数组**：仅保留当前层和前一层状态，空间复杂度从 O(n²) 降至 O(n)。  
3. **插入极大值**：新插入的极大值必定成为山峰，分解为左右子问题递归处理。  

**同类型题套路**：  
- 波动序列问题可通过状态压缩和对称性优化。  
- 排列计数问题常结合组合数与动态规划。  

**推荐题目**：  
1. P2592 [ZJOI2008]生日聚会（波动子序列计数）  
2. P4158 [SCOI2009]粉刷匠（滚动数组优化）  
3. P2657 [SCOI2009]windy数（数位 DP + 状态设计）  

---

### 核心代码实现  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 4205;
int f[2][MAXN], n, mod;

int main() {
    scanf("%d%d", &n, &mod);
    f[0][2] = 1;
    for (int i = 3; i <= n; i++) {
        int cur = i & 1, prev = cur ^ 1;
        memset(f[cur], 0, sizeof(f[cur]));
        for (int j = 2; j <= i; j++) {
            f[cur][j] = (f[cur][j-1] + f[prev][i-j+1]) % mod;
        }
    }
    int ans = 0;
    for (int j = 2; j <= n; j++) ans = (ans + f[n&1][j]) % mod;
    printf("%d", (ans * 2) % mod);
    return 0;
}
```

---

### 可视化与复古动画设计  
1. **Canvas 绘制**：  
   - 初始化 `n x n` 网格，每个格子表示 `dp[i][j]`，填充颜色表示值大小。  
   - 当前更新的格子高亮为黄色，依赖的前驱格子高亮为绿色/蓝色。  
2. **音效触发**：  
   - 每次更新格子时播放短促“滴”声，完成一行时播放上升音调。  
3. **自动演示**：  
   - 按行自动填充网格，用户可暂停观察当前状态，调整速度为 0.5x/1x/2x。  
4. **8-bit 风格**：  
   - 使用复古调色板（#FF6B6B、#4ECDC4、#45B7D1），网格线为像素风格。

---
处理用时：67.59秒
# 题目信息

# [USACO12FEB] Symmetry G

## 题目描述

在上了一门现代艺术课后，Farmer John 对在农场周围寻找几何图案产生了兴趣。他仔细地绘制了他的 N 头奶牛的位置（2 <= N <= 1000），每头奶牛占据二维平面中的一个不同的点，他想知道这些点集有多少条不同的对称轴。当然，对称轴是指在这条线上，两侧的点是彼此的镜像。

请帮助 FJ 解答这个最紧迫的几何问题。




## 说明/提示

这 4 头奶牛形成一个正方形的四个角。

有 4 条对称轴——一条垂直的，一条水平的，以及两条对角线。
（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
4 
0 0 
0 1 
1 0 
1 1 
```

### 输出

```
4 
```

# AI分析结果



---

### 算法分类
**计算几何**

---

### 题解思路与核心难点

#### 核心思路
1. **对称轴候选生成**：通过枚举关键点对（如点1与其他点）生成可能的对称轴方程。
2. **数学验证**：推导对称轴方程并计算每个点的对称点，验证其是否存在于点集中。
3. **避免重复**：通过固定关键点（如点1和点2）分类处理对称轴类型，减少重复计算。

#### 解决难点
1. **对称轴方程推导**：需精确计算两点间对称轴的直线方程（如中点垂直平分线）。
2. **浮点精度处理**：对称点坐标可能含小数，需用误差容忍度（如1e-10）判断是否为整点。
3. **空间优化**：使用布尔数组或离散化存储点坐标，避免内存溢出。

---

### 题解评分与亮点

#### 题解1（jzzcjb，⭐⭐⭐⭐）
- **亮点**：直接推导对称轴方程，逻辑清晰；利用关键点分类减少候选轴数量。
- **代码简析**：
  ```cpp
  bool is(double A, double B, double C) {
      for (int i = 1; i <= n; i++) {
          double k = -2 * (A*x[i] + B*y[i] + C) / (A*A + B*B);
          double xo = x[i] + k*A, yo = y[i] + k*B;
          // 检查是否为整点且存在
      }
  }
  ```

#### 题解2（wangjyqh，⭐⭐⭐）
- **亮点**：离散化坐标节省内存；独立验证函数模块化。
- **代码简析**：
  ```cpp
  void judge(int a, int b, double A, double B, double C) {
      for (int j = 1; j <= n; j++) {
          // 计算对称点并检查离散化坐标
      }
  }
  ```

---

### 最优思路提炼
1. **关键点枚举**：固定点1，枚举其与其他点的配对生成候选对称轴。
2. **对称轴分类**：
   - **类型1**：对称轴不经过点1，由点1及其对称点确定。
   - **类型2**：对称轴经过点1，需额外验证其他点对称性。
3. **快速验证**：对每个候选轴，遍历所有点检查对称点是否存在。

---

### 同类型题推荐
1. **对称性验证**：[P1225 对称二叉树](https://www.luogu.com.cn/problem/P1225)
2. **几何变换**：[P2785 物理计数](https://www.luogu.com.cn/problem/P2785)
3. **点集性质**：[CF988D Points and Powers of Two](https://codeforces.com/problemset/problem/988/D)

---

### 可视化与算法演示

#### 动画方案
1. **候选轴生成**：用红色线条显示当前枚举的对称轴候选。
2. **对称点验证**：高亮当前检查的点，绿色表示对称点存在，红色表示不存在。
3. **步进控制**：支持暂停/继续观察对称轴生成和验证过程。

#### 复古像素风格
- **颜色方案**：点用黄色像素，有效对称轴用蓝色，无效用红色。
- **音效设计**：
  - **验证成功**：8-bit 上升音效。
  - **验证失败**：短促“哔”声。
- **自动演示**：按固定间隔依次枚举候选轴，展示验证流程。

---

### 核心代码片段
```cpp
// 判断对称轴是否合法（jzzcjb 题解核心）
bool is(double A, double B, double C) {
    for (int i = 1; i <= n; i++) {
        double k = -2 * (A*x[i] + B*y[i] + C) / (A*A + B*B);
        double xo = x[i] + k*A, yo = y[i] + k*B;
        int x0 = round(xo), y0 = round(yo);
        // 检查是否为整点且存在
        if (abs(x0 - xo) > 1e-10 || abs(y0 - yo) > 1e-10) return false;
        if (x0 < 0 || x0 > 20000 || y0 < 0 || y0 > 20000) return false;
        if (!map[x0][y0]) return false;
    }
    return true;
}
```

---

### 个人心得摘录
> **jzzcjb**：  
> “思路很明了，实现很虐心”——数学推导正确性至关重要，坐标偏移和浮点精度需小心处理。

---
处理用时：84.60秒
# 题目信息

# [USACO15JAN] Stampede S

## 题目描述

FJ 的 $N$ 头奶牛（$1 \leq N \leq 50,000$）看似在农场前的路上狂奔，实际上它们正在进行一场赛跑。

从上方俯视，每头牛在时间 $t = 0$ 时被表示为一个单位长度的水平线段，其左端点坐标为 $(x, y)$。例如，$(-3, 6)$ 表示一头在 $t = 0$ 时从 $(-3, 6)$ 延伸到 $(-2, 6)$ 的奶牛。每头牛以一定速度向右（$+x$ 方向）移动，该速度由移动 1 单位距离所需的整数时间 $r$ 描述。

FJ 并不满意他的奶牛在外赛跑而不在牛棚产奶。他计划在比赛结束后训斥参赛的奶牛。为了确定哪些奶牛参赛，FJ 站在 $(0, 0)$ 处并沿 $+y$ 方向的射线观察。当一头牛在某个时刻成为这条射线上首个可见的牛时，FJ 就会看到它。如果一头牛在穿过 FJ 视线期间始终被其他牛"挡住"，则她不可见。

请计算 FJ 在整个比赛过程中能看到的奶牛数量。

## 说明/提示

FJ 可以看到牛 1 和 2，但看不到牛 3。

## 样例 #1

### 输入

```
3 
-2 1 3 
-3 2 3 
-5 100 1 
```

### 输出

```
2 
```

# AI分析结果



## 唯一算法分类
**离散化+扫描线**

---

## 综合分析与结论

### 核心思路
1. **离散化时间轴**：将奶牛经过 y 轴的时间区间离散化，处理大规模数据。
2. **扫描线+优先覆盖**：按 y 值从小到大处理奶牛，保证覆盖时优先保留更低的 y（更易被看到）。
3. **区间覆盖判断**：通过线段树或集合维护时间轴上的覆盖状态，判断当前奶牛是否被完全遮挡。

### 难点与解决
- **时间区间冲突**：左闭右开区间避免边界冲突（如区间 [1,2] 和 [2,3] 在闭区间下会冲突）。
- **高效覆盖判断**：线段树可高效查询区间是否被覆盖，扫描线通过事件排序简化逻辑。
- **离散化处理**：将大范围时间映射到小范围，降低空间复杂度。

### 可视化设计
- **时间轴动画**：横轴为离散化后的时间点，纵轴为奶牛 y 值。用不同颜色块表示各奶牛覆盖的时间段。
- **高亮操作**：当前处理的奶牛区间标红，已覆盖区间标灰，覆盖更新时显示颜色渐变。
- **扫描线事件点**：在时间轴上动态标记“开始”和“结束”事件，触发时更新活动集合。
- **复古像素风格**：用 8-bit 音效提示覆盖操作（如“滴”声表示覆盖成功，“嘟”声表示被遮挡）。

---

## 题解清单 (≥4星)

1. **Expecto（5星）**
   - **亮点**：扫描线+事件排序，代码简洁高效。
   - **关键代码**：
     ```cpp
     sort(events.begin(),events.end());
     set<int> active;
     for (auto &e : events) {
         if (e.y > 0) active.insert(e.y);
         else active.erase(-e.y);
         if (!active.empty()) seen.insert(*active.begin());
     }
     ```
   - **评分理由**：O(n log n) 时间复杂度，逻辑清晰，适合大规模数据。

2. **Na2PtCl6（4星）**
   - **亮点**：左闭右开区间处理，避免精度冲突。
   - **关键代码**：
     ```cpp
     st[i] = (-x-1)*r, ed[i] = (-x)*r;
     update(1, 1, sz, st[i], ed[i]-1, 1); // 离散化后区间左闭右开
     ```
   - **评分理由**：线段树实现严谨，处理边界清晰。

3. **曹老师（4星）**
   - **亮点**：动态开点线段树，节省内存。
   - **关键代码**：
     ```cpp
     if (!query(1, node[i].l, node[i].r-1)) ans++;
     update(1, node[i].l, node[i].r-1);
     ```
   - **评分理由**：离散化结合线段树，代码可读性强。

---

## 最优思路与技巧

### 关键技巧
1. **事件驱动扫描线**：将奶牛的时间区间拆分为“开始”和“结束”事件，按时间排序处理。
2. **左闭右开区间**：避免离散化后的边界冲突（如 [1,2) 和 [2,3) 不重叠）。
3. **集合维护最小值**：用 `set` 维护当前活动集合，快速获取最小 y 值。

### 同类型题
- **P1884 [USACO12FEB] Overplanting S**：矩形面积并，离散化+扫描线。
- **P1502 窗口的星星**：扫描线求最大覆盖值。
- **P5490 【模板】扫描线**：区间覆盖模板题。

---

## 推荐题目
1. **P1884**：区间覆盖面积计算。
2. **P5490**：扫描线模板题。
3. **P1502**：动态最大覆盖值。

---

## 可视化算法演示

### 核心流程
1. **离散化时间轴**：将奶牛的时间区间映射到离散点。
2. **事件排序**：按时间顺序处理开始/结束事件。
3. **活动集合更新**：维护当前可见的奶牛集合。
4. **最小 y 记录**：每次事件触发后记录当前最小 y。

### 动画设计
- **Canvas 绘制**：时间轴为横轴，纵轴显示奶牛 y 值。
- **颜色标记**：当前处理区间红色，已覆盖灰色，可见奶牛绿色。
- **音效触发**：覆盖时播放“滴”，遮挡时播放“嘟”。
- **自动演示**：按事件顺序逐步执行，可调节速度或单步调试。

```javascript
// 伪代码示例（事件处理）
events.sort((a, b) => a.time - b.time);
let active = new Set();
let seen = new Set();
events.forEach(e => {
    if (e.type === 'start') active.add(e.y);
    else active.delete(e.y);
    if (active.size > 0) seen.add(Math.min(...active.values()));
});
```

---

## 个人心得摘录
- **枫**：暴力覆盖需注意左闭右开，否则“第二秒结束时可能未被覆盖”。
- **ueettttuj**：离散化时乘以 2 可避免精度问题，如区间 [2,3] 实际覆盖 (2,3)。

---

**答案总结**：离散化处理时间区间，扫描线维护活动集合，优先覆盖 y 值小的奶牛。

---
处理用时：68.62秒
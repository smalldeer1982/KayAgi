# 题目信息

# Koishi Loves Segments

## 题目描述

Koishi 喜欢线段。

她的 $n$ 条线段都能表示成数轴上的某个闭区间 $[l,r]$。Koishi 喜欢在把所有线段都放在数轴上，然后数出某些点被多少线段覆盖了。

Flandre 看她和线段玩得很起开心，就抛给她一个问题：

数轴上有 $m$ 个点突然兴奋，如果自己被身上覆盖了超过 $x$ 条线段，这个点就会浑身难受然后把 Koishi 批判一番。

Koishi 十分善良，为了不让数轴上的点浑身难受，也为了让自己开心，她想在数轴上放入尽量多的线段。

按照套路，Koishi 假装自己并不会做这道题，所以她就来求你帮忙。并承诺如果你解决了问题就给你打一通电话。

## 说明/提示

对于 $20\%$ 的数据，满足$1\leq n,m\leq 20$。

对于 $60\%$ 的数据，满足$1\leq n,m\leq 100$。

对于 $80\%$的数据，满足$1\leq n,m\leq 5000$。

对于 $100\%$ 的数据，满足$1\leq x\leq n\leq 2\times 10^5,1\leq m\leq 4\times 10^5,|l|,|r|,|p|\leq 10^7$

如果一个点兴奋了两次，那么 Koishi 应当满足它的**较严苛的要求**（也就是 $p$ 相同时 $x$ 取最小值啦）

请适当使用读入优化。

## 样例 #1

### 输入

```
4 3
1 3
2 4
5 7
6 8
2 5
3 1
6 2```

### 输出

```
3```

# AI分析结果



## 算法分类
**贪心算法**

---

## 题解思路、算法要点与解决难点

### 核心思路
所有题解均采用**贪心策略**：按左端点排序线段和限制点，逐个处理限制点，动态维护覆盖当前点的线段集合。当线段覆盖数超过限制时，优先删除右端点最大的线段。

### 算法要点
1. **双排序**：线段按左端点排序，限制点按坐标排序。
2. **动态维护覆盖集**：使用 `multiset` 存储当前覆盖点的线段右端点。
3. **贪心删除策略**：超限时删除右端点最大的线段，减少对后续点的影响。
4. **离散化优化**（SSerxhs题解）：将坐标映射为连续整数，用线段树维护区间覆盖次数。

### 解决难点
- **正确性证明**：删除右端点最大的线段可以最小化对后续限制点的影响（证明见IANYEYZ题解）。
- **高效维护覆盖集**：`multiset` 的插入、删除操作均为 O(log n)，保证算法整体复杂度 O(n log n)。
- **处理重复兴奋点**：合并相同坐标点的限制值，取最严格约束。

---

## 题解评分（≥4星）

### 1. FlashHu（★★★★★）
- **亮点**：代码简洁高效，利用 `multiset` 自动排序特性，常数优化到位。
- **关键代码**：
  ```cpp
  while(s.size() > b[i].y) s.erase(--s.end()), --ans;
  ```

### 2. IANYEYZ（★★★★☆）
- **亮点**：详细证明贪心策略的正确性，代码逻辑清晰。
- **心得引用**：“删除右端点最大的线段更优，因为这使得更多的线段可以填入。”

### 3. dlzlj_2010（★★★★☆）
- **亮点**：注释详细，离散化处理明确，适合新手理解。
- **关键代码**：
  ```cpp
  while(s.size()>b[i].x) s.erase(--s.end()),ans--;
  ```

---

## 最优思路或技巧提炼
1. **贪心排序**：按左端点排序后，可以线性扫描处理限制点。
2. **右端点优先删除**：用 `multiset` 维护右端点，超限时删除最大值。
3. **动态维护覆盖集**：利用 `multiset` 的自动排序特性，高效处理插入和删除。

---

## 同类型题或算法套路
- **区间调度问题**：如选择不重叠区间（[P1803 线段覆盖](https://www.luogu.com.cn/problem/P1803)）。
- **覆盖约束问题**：如用最少数量的点覆盖所有区间（[P1250 种树](https://www.luogu.com.cn/problem/P1250)）。

---

## 推荐题目
1. **P1803 线段覆盖**：经典贪心选择不重叠区间。
2. **P1250 种树**：区间覆盖约束下的最优化问题。
3. **P2082 区间覆盖**：动态维护区间覆盖次数的高阶应用。

---

## 可视化与算法演示

### 核心流程动画设计
1. **排序展示**：线段和限制点从左到右排列，颜色区分。
2. **动态覆盖集**：
   - **插入线段**：绿色线段加入 `multiset`，右端点自动排序。
   - **删除线段**：红色高亮被删除的右端点最大线段。
3. **限制点处理**：紫色标记当前处理的限制点，显示覆盖数阈值。

### 复古像素风格实现
- **Canvas绘制**：线段用8位色块表示，限制点为闪烁像素点。
- **音效触发**：
  - 插入线段：短促“滴”声。
  - 删除线段：低沉“咚”声。
  - 超限警报：急促蜂鸣声。
- **自动演示**：按空格暂停/继续，方向键调整速度。

---

## 关键代码片段（FlashHu题解）
```cpp
for(R i=0,j=0;i<m;++i){
    while(j<n&&a[j].x<=b[i].x)s.insert(a[j++].y);
    while(s.size()&&*s.begin()<b[i].x)s.erase(s.begin());
    while(s.size()>b[i].y)s.erase(--s.end()),--ans;
}
```
**逻辑解析**：  
- 外层循环遍历排序后的限制点。
- 内层循环1：将所有左端点≤当前限制点的线段加入集合。
- 内层循环2：删除右端点<当前点坐标的过期线段。
- 内层循环3：若覆盖数超限，删除右端点最大的线段，答案减1。

---

## 总结
本题解通过贪心策略与高效数据结构（`multiset`）的结合，在 O(n log n) 时间内解决了大规模区间覆盖约束问题。其核心在于排序与动态维护的协同，以及删除策略的最优性证明，为同类问题提供了通用解决框架。

---
处理用时：67.74秒
# 题目信息

# [USACO17JAN] Promotion Counting P

## 题目描述

奶牛们又一次试图创建一家创业公司，还是没有从过去的经验中吸取教训——牛是可怕的管理者！

为了方便，把奶牛从 $1\sim n$ 编号，把公司组织成一棵树，1 号奶牛作为总裁（这棵树的根节点）。除了总裁以外的每头奶牛都有一个单独的上司（它在树上的 “双亲结点”）。  

所有的第 $i$ 头牛都有一个不同的能力指数 $p_i$，描述了她对其工作的擅长程度。如果奶牛 $i$ 是奶牛 $j$ 的祖先节点，那么我们我们把奶牛 $j$ 叫做 $i$ 的下属。

不幸地是，奶牛们发现经常发生一个上司比她的一些下属能力低的情况，在这种情况下，上司应当考虑晋升她的一些下属。你的任务是帮助奶牛弄清楚这是什么时候发生的。简而言之，对于公司的中的每一头奶牛 $i$，请计算其下属 $j$ 的数量满足 $p_j > p_i$。


## 说明/提示

 对于 $100\%$ 的数据，$1\le n \le 10^5$，$1 \le p_i \le 10^9$。

## 样例 #1

### 输入

```
5
804289384
846930887
681692778
714636916
957747794
1
1
2
3```

### 输出

```
2
0
1
0
0```

# AI分析结果



**唯一算法分类**：树状数组 + DFS序

---

### **题解思路与解决难点**

#### **核心思路**
题目要求每个节点的子树中权值大于该节点的数量。通过DFS序将树结构转化为线性序列，利用树状数组高效处理动态区间查询。关键点在于：
1. **离散化**：将大范围的权值压缩到连续区间。
2. **DFS序**：确保子树在序列中是连续区间。
3. **差分统计**：在DFS过程中，先记录初始状态，处理子树后再计算差值，避免重复统计。

#### **解决难点**
- **子树范围的确定**：DFS序保证子树节点在序列中连续。
- **动态维护权值**：树状数组实时更新当前处理的节点权值。
- **避免重复统计**：通过进入节点时记录初始值，处理完子树后计算差值，确保仅统计子树内节点。

---

### **题解评分 (≥4星)**

1. **George1123 (5星)**
   - **亮点**：清晰解释差分思想，代码简洁高效，手绘图辅助理解。
   - **核心代码**：
     ```cpp
     void dfs(int x){
         ans[x] = -(hx.fsum(n) - hx.fsum(p[x])); // 初始状态
         for(auto i:g[x]) dfs(i);                 // 处理子树
         ans[x] += (hx.fsum(n) - hx.fsum(p[x]));  // 差值统计
         hx.fix(p[x],1);                          // 更新树状数组
     }
     ```

2. **小粉兔 (4星)**
   - **亮点**：极简代码实现，离散化与DFS结合紧密。
   - **核心代码**：
     ```cpp
     void dfs(int u){
         Ans[u] = -Q(a[u]);          // 初始查询
         eF(i,u) dfs(to[i]);         // 遍历子树
         Ans[u] += Q(a[u]);          // 最终查询
         I(a[u]);                     // 插入当前节点
     }
     ```

3. **ivyjiao (4星)**
   - **亮点**：利用vector动态维护有序序列，免去离散化。
   - **核心代码**：
     ```cpp
     void dfs(int u){
         ans[u] -= upper_bound(b.begin(), b.end(), a[u]) - b.begin();
         for(int v : G[u]) dfs(v);   // 处理子树
         ans[u] += b.size() - (upper_bound(...)); // 统计差值
         b.insert(lower_bound(...), a[u]);         // 插入有序序列
     }
     ```

---

### **最优思路提炼**
- **离散化 + 树状数组**：压缩权值范围，高效统计区间。
- **DFS序差分法**：进入节点时记录基准值，处理完子树后计算增量。
- **动态插入**：处理完子树后插入当前节点，保证后续查询包含子树信息。

---

### **同类型题推荐**
1. **P1908 逆序对**（树状数组基础）
2. **P3380 【模板】二逼平衡树**（区间查询与动态维护）
3. **P3224 [HNOI2012] 永无乡**（线段树合并与权值统计）

---

### **可视化与算法演示**

#### **动画设计**
1. **树结构展示**：以像素风格绘制树形结构，当前处理节点高亮为红色，子树范围用绿色框标记。
2. **树状数组操作**：
   - **插入**：节点插入时，对应树状数组位置填充黄色方块。
   - **查询**：查询区间时，高亮查询范围（蓝色覆盖）。
3. **差分统计**：显示进入节点时的初始值（灰色数字），处理子树后的最终值（绿色数字），差值即为答案。

#### **复古效果**
- **8位音效**：插入时播放“滴”声，查询时播放“嘟”声，统计完成时播放胜利音效。
- **Canvas动画**：用网格表示树状数组，节点动态插入时格子闪烁，子树范围用边框标记。

#### **交互功能**
- **步进控制**：空格键单步执行，方向键调整速度。
- **自动模式**：AI自动运行，展示完整解题流程。

---

### **核心代码实现（树状数组+DFS）**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+10;

int n, p[N], b[N], ans[N];
vector<int> g[N];

struct BIT {
    int tr[N];
    int lowbit(int x) { return x&-x; }
    void update(int x, int v) {
        for(; x<=n; x+=lowbit(x)) tr[x] += v;
    }
    int query(int x) {
        int res = 0;
        for(; x; x-=lowbit(x)) res += tr[x];
        return res;
    }
} bit;

void dfs(int u) {
    int pre = bit.query(n) - bit.query(p[u]); // 初始状态
    for(int v : g[u]) dfs(v);                // 处理子树
    ans[u] = (bit.query(n) - bit.query(p[u])) - pre; // 差值统计
    bit.update(p[u], 1);                      // 插入当前节点
}

int main() {
    cin >> n;
    for(int i=1; i<=n; i++) cin >> p[i], b[i] = p[i];
    sort(b+1, b+n+1);
    for(int i=1; i<=n; i++)
        p[i] = lower_bound(b+1, b+n+1, p[i]) - b;
    
    for(int i=2; i<=n; i++) {
        int fa; cin >> fa;
        g[fa].push_back(i);
    }
    
    dfs(1);
    for(int i=1; i<=n; i++) cout << ans[i] << endl;
    return 0;
}
```

---
处理用时：72.44秒
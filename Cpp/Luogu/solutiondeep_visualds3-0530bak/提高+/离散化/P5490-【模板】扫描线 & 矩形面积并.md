# 题目信息

# 【模板】扫描线 & 矩形面积并

## 题目描述

求 $n$ 个四边平行于坐标轴的矩形的面积并。

## 说明/提示

对于 $20\%$ 的数据，$1 \le n \le 1000$。  
对于 $100\%$ 的数据，$1 \le n \le {10}^5$，$0 \le x_1 < x_2 \le {10}^9$，$0 \le y_1 < y_2 \le {10}^9$。

Updated on 4.10 by Dengduck（口胡） \& yummy（实现）：增加了一组数据。

## 样例 #1

### 输入

```
2
100 100 200 200
150 150 250 255
```

### 输出

```
18000
```

# AI分析结果



### 唯一算法分类：扫描线算法（线段树优化）

---

### 综合分析与结论

#### **核心思路与难点**
1. **扫描线核心思想**  
   - 将矩形拆分为上下边，按纵坐标排序后模拟垂直扫描线从左到右移动，每次计算相邻扫描线间的有效覆盖长度，累加面积贡献。
   - 难点在于如何高效维护当前扫描线覆盖的区间总长度。

2. **线段树优化**  
   - 线段树维护**离散化后的区间覆盖次数**（`cnt`）与**有效覆盖长度**（`len`）。
   - 关键操作：  
     - **区间修改**：插入下边时 `cnt+1`，插入上边时 `cnt-1`。  
     - **有效长度计算**：若 `cnt>0`，区间完全覆盖；否则由子区间合并。  
   - **离散化**：将大范围坐标映射为紧凑的整数索引，降低线段树规模。

3. **实现技巧对比**  
   - **标记下传 vs 标记永久化**：  
     - 普通线段树需下传标记以保证正确性；  
     - 标记永久化通过累加父节点标记减少操作次数（如题解**CYJian**）。  
   - **动态开点**：避免离散化，直接处理原始坐标（如题解**CYJian**）。

---

### 题解清单（评分≥4星）

1. **NCC79601（★★★★★）**  
   - **亮点**：图文结合清晰解释扫描线原理，代码注释详细，离散化与线段树维护逻辑完整。  
   - **代码片段**：  
     ```cpp
     void pushup(int x) {
         if (tree[x].sum) tree[x].len = X[r+1] - X[l];
         else tree[x].len = tree[lson].len + tree[rson].len;
     }
     ```

2. **Gu_Pigeon（★★★★☆）**  
   - **亮点**：强调离散化操作，代码结构简洁，标记永久化提升效率。  
   - **个人心得**：调试时发现需处理 `y1` 与 C++ 库冲突，改用 `yl` 避免错误。

3. **MakiseVon（★★★★☆）**  
   - **亮点**：代码短小精悍，离散化与线段树逻辑分离清晰，适合快速实现。  
   - **关键片段**：  
     ```cpp
     void push_up(int rt, int l, int r) {
         if (tr[rt].sum) tr[rt].len = X[r+1] - X[l];
         else tr[rt].len = (l==r) ? 0 : tr[rt<<1].len + tr[rt<<1|1].len;
     }
     ```

---

### 最优思路与技巧提炼

1. **核心数据结构**  
   - 线段树节点存储 `cnt`（覆盖次数）和 `len`（有效长度），通过 `pushup` 动态合并子区间。

2. **离散化优化**  
   - 使用 `unique` 去重并压缩坐标范围，降低线段树深度。

3. **标记永久化**  
   - 避免标记下传，直接在父节点累积标记，减少递归调用（如代码片段）：  
     ```cpp
     void update(int x, int L, int R, int v) {
         if (覆盖整个区间) { cnt += v; pushup(); return; }
         // 无需下传标记，直接递归子区间
     }
     ```

---

### 同类型题与算法套路

1. **周长并问题**（如 [P1856](https://www.luogu.com.cn/problem/P1856)）  
   - 需额外维护区间端点数与覆盖方向，计算横向与纵向贡献。

2. **三维扫描线**  
   - 扩展为平面投影 + 时间维度，结合分治或树状数组优化。

---

### 推荐题目
1. **P1856 [USACO5.5]矩形周长Picture**  
2. **POJ 1177 Picture**  
3. **HDU 1542 Atlantis**

---

### 可视化设计思路

#### **动画演示方案**
1. **像素风格渲染**  
   - **Canvas 绘制**：  
     - 坐标系以网格显示，矩形边用不同颜色区分（下边绿色，上边红色）。  
     - 扫描线用黄色竖线动态移动，当前覆盖区间高亮为蓝色。  
   - **音效触发**：  
     - 扫描线移动时播放“滴答”声，区间更新时播放短暂“咔嚓”声。

2. **交互式控制**  
   - **步进控制**：允许暂停/继续，调整扫描速度观察线段树节点状态变化。  
   - **高亮逻辑**：  
     - 当前处理的边标红，线段树更新的节点边框闪烁。  
     - 显示当前面积累加公式：`ans += len * Δx`。

3. **复古游戏化**  
   - **8-bit 风格**：使用有限调色板（绿、红、蓝、黄），扫描线移动时背景音乐循环播放 FC 芯片音乐。  
   - **积分系统**：正确计算一个区间得10分，错误操作扣分，积分进度条显示完成度。

---

### 关键代码实现（标记永久化版）

```cpp
struct Node {
    int cnt, len; // 覆盖次数与有效长度
} tr[N<<2];

void pushup(int p, int l, int r) {
    if (tr[p].cnt) tr[p].len = X[r+1] - X[l];
    else tr[p].len = (l == r) ? 0 : tr[p<<1].len + tr[p<<1|1].len;
}

void update(int p, int l, int r, int L, int R, int v) {
    if (L <= l && r <= R) {
        tr[p].cnt += v;
        pushup(p, l, r);
        return;
    }
    int mid = (l + r) >> 1;
    if (L <= mid) update(p<<1, l, mid, L, R, v);
    if (R > mid) update(p<<1|1, mid+1, r, L, R, v);
    pushup(p, l, r);
}
```

---

通过上述分析与实现，可高效解决矩形面积并问题，并扩展至类似几何覆盖问题。

---
处理用时：78.57秒
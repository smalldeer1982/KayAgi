# 题目信息

# 「EZEC-2」数轴

## 题目描述

小 X 画了一条数轴，他将进行 $n$ 次操作，每次操作他会先在数轴上的 $x_i$ 位置上增添 $a_i$ 个标记。

然后他需要选择二元组 $(l,r)$，满足 $l,r$ 为整数， $0\le l\le r \le m$，且在数轴上的区间 $[l,r]$ 上的标记的个数**小于等于** $k$。

对于每次操作，你需要求出满足条件的二元组 $(l,r)$ 中 $r-l$ 的最大值。



## 说明/提示

**【样例解释 #2】**

每次操作后选择的二元组分别是 $(0,15),(4,15),(4,15),(8,15),(9,15)$。

---
**【数据范围与约定】**

| 数据点编号 | $n=$ | $m=$ | $k=$ |
| :----------: | :----------: | :----------: | :----------: |
| $1,2$ | $100$ | $100$ | $3$ |
| $3,4$ | $100$ | $10^3$ | $3$ |
| $5,6$ | $100$ | $10^4$ | $3$ |
| $7,8$ | $500$ | $10^4$ | $3$ |
| $9,10$ | $10^3$ | $10^4$ | $3$ |
| $11,12$ | $10^4$ | $10^5$ | $3$ |
| $13\sim 16$ | $10^5$ | $10^6$ | $0$ |
| $17\sim 21$ | $10^5$ | $10^6$ | $3$ |
| $22,23$ | $10^5$ | $10^9$ | $100$ |
| $24,25$ | $10^6$ | $10^9$ | $100$ |

保证测试点 $13\sim 16$ 的 $x_i$ 为随机构造。

测试点 $24,25$ 的时间限制为 $3\text s$ ，其他测试点的时间限制均为 $2\text s$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^6$，$0\le m\le 10^9$，$0\le x_i\le m$，$0\le k\le 100$，$1\le a_i\le 100$。

**注意：数轴上同一个位置上可能会多次增添标记。**

**已自动开启 $\text{O2}$ 优化，保证时空限制均为 $\text{std}$ 在开启 $\text{O2}$ 优化后的两倍以上。**

## 样例 #1

### 输入

```
5 4 0
2 1
3 1
0 1
1 1
4 1```

### 输出

```
1
1
0
0
-1```

## 样例 #2

### 输入

```
5 15 1
3 1
8 1
1 1
7 1
14 1```

### 输出

```
15
11
11
7
6
```

## 样例 #3

### 输入

```
10 100 10
94 3
22 10
9 4
37 1
21 10
92 5
50 9
68 8
44 4
78 9
```

### 输出

```
100
93
83
77
77
77
68
44
40
26
```

## 样例 #4

### 输入

```
10 100 3
95 1
13 1
52 1
74 1
40 1
54 1
71 1
68 1
51 3
12 2
```

### 输出

```
100
100
100
94
80
59
56
53
50
39
```

# AI分析结果



---

**算法分类**：双指针（Two Pointers） / 链表优化

---

### **题解思路与算法要点**

1. **倒序处理**  
   - **核心思想**：将添加操作逆转为删除操作，使得每次操作后的答案单调不减，便于维护最大值。
   - **实现**：预处理最终状态，倒序删除每个标记点，更新全局最大值。

2. **链表维护关键点**  
   - **作用**：快速定位删除点周围的标记点，避免全局遍历。
   - **实现**：用 `pre` 和 `suc` 数组维护每个点的前驱和后继，删除时更新指针。

3. **滑动窗口（双指针）**  
   - **预处理**：初始时用双指针计算最大有效区间。
   - **局部调整**：每次删除后，仅在受影响区域（左右各 `k` 个点）重新计算区间。

**解决难点**：动态维护区间最大值的高效更新。通过倒序处理将问题转化为单调递增，利用链表快速遍历局部区域，结合双指针的 `O(k)` 局部扫描。

---

### **题解评分**

1. **君のNOIP（5星）**  
   - **亮点**：完整注释，代码简洁，链表与双指针结合紧密，时间复杂度明确为 `O(nk)`，适合大数据范围。

2. **一扶苏一（4.5星）**  
   - **亮点**：理论分析详细，代码结合链表和双指针，预处理逻辑清晰。但变量命名较简略，需仔细阅读。

3. **_CHO（4星）**  
   - **亮点**：代码结构清晰，链表操作直观。但预处理部分需注意边界条件，调试细节未提及。

---

### **最优思路提炼**

- **倒序删除**：将动态添加转为静态删除，保证答案单调性。
- **链表维护**：`O(1)` 更新前驱后继，快速访问受影响区域。
- **局部双指针扫描**：仅处理删除点附近 `k` 个点，复杂度可控。

**关键代码片段**（君のNOIP）：
```cpp
// 倒序处理，维护链表和双指针
for (int i = n; i >= 1; i--) {
    int p = mp[x[i]];    // 当前删除点
    num[p] -= a[i];      // 减少标记数
    if (num[p] == 0) {   // 若该点无标记，更新链表
        r[l[p]] = r[p];
        l[r[p]] = l[p];
    }
    // 局部双指针扫描受影响区域
    int j = p, sum = num[j];
    while (j > 1 && sum <= k) j = l[j], sum += num[j];
    // 更新最大值...
}
```

---

### **同类型题目与算法套路**

- **通用场景**：动态维护区间最值，允许离线处理。
- **相似题目**：
  1. **洛谷P1886**：滑动窗口最大值（双指针+单调队列）。
  2. **洛谷P1638**：寻找最小覆盖区间（双指针+哈希）。
  3. **洛谷P1712**：区间覆盖问题（双指针+排序）。

---

### **可视化设计（复古像素风格）**

1. **数轴展示**：  
   - **像素网格**：用 `Canvas` 绘制数轴，标记点显示为彩色方块，删除时变为灰色。
   - **高亮区域**：当前扫描的左右各 `k` 个点，以闪烁边框标记。

2. **动画控制**：  
   - **步进执行**：按空格键单步执行删除操作，展示链表指针更新。
   - **自动模式**：AI 自动播放，双指针移动时伴随 8-bit 音效。

3. **音效设计**：  
   - **删除标记**：短促“哔”声。
   - **找到新区间**：上扬音效，区间长度显示为像素数字。

4. **代码实现**（伪代码）：  
```javascript
// 绘制数轴和标记点
function drawAxis() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 100, canvas.width, 2); // 数轴基线
    for (let point of points) {
        let x = scale(point.pos);
        ctx.fillStyle = point.active ? '#FF0000' : '#888';
        ctx.fillRect(x-3, 90, 6, 20); // 标记点方块
    }
}
```

---

**总结**：结合倒序处理、链表和双指针，将复杂度降至 `O(nk)`，通过局部扫描避免全局计算。复古可视化增强理解，适用于动态区间维护问题。

---
处理用时：68.52秒
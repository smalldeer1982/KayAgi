# 题目信息

# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# AI分析结果



# 算法分类：双向广度优先搜索（双向BFS）

---

## 题解思路、算法要点与解决难点

### **核心思路**
1. **普通BFS的问题**：单方向搜索空间爆炸，尤其在字符串变换可能生成大量重复或无效状态时。
2. **双向BFS优化**：从起点和终点同时扩展队列，每次选择较小的队列扩展，减少总状态数。
3. **规则反向处理**：反向搜索时需将变换规则反向应用（如 `A→B` 变为 `B→A`）。
4. **判重与相遇检测**：使用哈希表记录已访问状态及步数，若某一状态在双向队列中均存在，则总步数为两队列步数之和。

### **解决难点**
- **状态去重**：通过哈希表（如 `unordered_map`）避免重复扩展。
- **规则应用**：正反向规则需分别处理，需在扩展队列时动态切换。
- **步数限制**：总步数不超过10，需在扩展时及时终止超限状态。

---

## 题解评分（≥4星）

### 1. Qianmo_su（5星）
- **亮点**：规范的双向BFS实现，正反向规则分离处理，时间复杂度最优。
- **代码**：使用 `unordered_map` 记录步数，动态扩展较小队列，清晰高效。
- **核心代码**：
  ```cpp
  int extend(queue<string>& q, unordered_map<string,int>& da, ...) {
      // 扩展队列，返回相遇时的总步数
  }
  ```

### 2. __Deng_Rui_Song__（4星）
- **亮点**：简洁的双向BFS框架，利用 `set` 去重，代码可读性较强。
- **优化点**：自动处理规则反向，但未显式分离正反向规则。

### 3. Swordmaker（4星）
- **亮点**：普通BFS加入 `map` 判重，解决内存超限问题，适合小规模数据。
- **核心代码**：
  ```cpp
  if (!mp[ps]) {
      q.push(make_pair(ps, s.second+1));
      mp[ps] = 1;
  }
  ```

---

## 最优思路与技巧提炼

### **关键技巧**
1. **双向队列扩展**：优先扩展较小队列，降低总时间复杂度（从 $O(R^{10})$ 降至 $O(R^5)$）。
2. **规则反向处理**：将终点到起点的搜索视为反向规则的应用。
3. **哈希表判重**：记录每个状态的步数，避免重复入队。

### **同类型题与套路**
- **八数码问题**（P1379）：最短路径搜索，双向BFS适用。
- **单词接龙**（LeetCode 127）：字符串变换最短路径，需判重。
- **华容道**：状态变换与最短步数。

---

## 推荐相似题目
1. **P1379 八数码难题**（双向BFS经典题）
2. **LeetCode 127. 单词接龙**（字符串变换最短路径）
3. **P2324 [SCOI2005] 骑士精神**（状态搜索+步数限制）

---

## 可视化与算法演示

### **动画方案**
1. **双向队列可视化**：
   - **左侧队列**（起点方向）：绿色方块表示当前扩展的字符串。
   - **右侧队列**（终点方向）：红色方块表示扩展的字符串。
   - **相遇高亮**：当两队列状态重叠时，用黄色闪烁提示。

2. **关键操作高亮**：
   - **替换位置**：在原字符串中用蓝色标记被替换的子串。
   - **新状态生成**：显示新字符串并动态加入队列。

3. **步进控制**：
   - **速度调节**：滑动条控制动画速度（0.5x~5x）。
   - **单步执行**：点击按钮逐帧观察替换过程。

### **复古像素风格设计**
- **颜色方案**：16色调色板，绿色（起点队列）、红色（终点队列）、黄色（相遇）。
- **音效设计**：
  - **替换音效**：8-bit “哔”声提示替换操作。
  - **相遇音效**：胜利旋律（类似《超级马里奥》过关音效）。
- **Canvas 绘制**：字符串以像素网格显示，每个字符为8x8像素块。

### **自动演示模式**
- **AI自动扩展**：算法自动选择较小队列扩展，动态绘制队列长度和步数。
- **伪代码旁白**：右侧显示当前执行的代码行，如 `extend(qa, da, db)`。

---

## 核心代码片段（Qianmo_su的双向BFS）

```cpp
int extend(queue<string>& q, unordered_map<string,int>& da, 
           unordered_map<string,int>& db, string a[], string b[]) {
    int d = da[q.front()];
    while (!q.empty() && da[q.front()] == d) {
        auto t = q.front(); q.pop();
        for (int i = 0; i < n; i++)
            for (int j = 0; j < t.size(); j++)
                if (t.substr(j, a[i].size()) == a[i]) {
                    string r = t.substr(0,j) + b[i] + t.substr(j+a[i].size());
                    if (db.count(r)) return da[t] + db[r] + 1;
                    if (da.count(r)) continue;
                    da[r] = da[t] + 1;
                    q.push(r);
                }
    }
    return 11; // 未相遇则返回超过限制的值
}
```

---

## 个人心得摘录
- **lyc1109**：DFS需结合剪枝和排序规则优化，否则TLE。
- **租酥雨**：手动处理字符串变换（非STL）提升效率，但代码复杂度高。
- **Qianmo_su**：双向BFS的队列选择策略是性能关键，需动态判断队列大小。

---

通过双向BFS的动态扩展与状态判重，本问题在合理时间复杂度内得到最优解，其核心思想可推广至类似状态搜索问题。

---
处理用时：77.38秒
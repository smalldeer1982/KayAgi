# 题目信息

# [SDOI2006] 线性方程组

## 题目描述

已知 $n$ 元线性一次方程组。

$$ \begin{cases} a_{1, 1} x_1 + a_{1, 2} x_2 + \cdots + a_{1, n} x_n = b_1 \\ a_{2, 1} x_1 + a_{2, 2} x_2 + \cdots + a_{2, n} x_n = b_2 \\ \cdots \\ a_{n,1} x_1 + a_{n, 2} x_2 + \cdots + a_{n, n} x_n = b_n \end{cases}$$

请根据输入的数据，编程输出方程组的解的情况。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1 \le n \le 50$。对于 $\forall 1\le i, j \le n$，有 $|a_{i, j}| \le 100$，$|b_i| \le 300$。

## 样例 #1

### 输入

```
3
2 -1 1 1
4 1 -1 5
1 1 1 0```

### 输出

```
x1=1.00
x2=0.00
x3=-1.00
```

# AI分析结果



### 唯一算法分类  
高斯消元法（高斯-约旦变种）

---

### 综合分析与结论  
**核心难点**：在消元过程中处理主元缺失（全零列）时的无解/无穷解判定，以及精度误差控制。  

**关键解决方案**：  
1. **主元选择优化**：通过遍历当前列及以下行选取最大绝对值主元（Piwry、Rui_R），降低误差  
2. **自由行判定**：消元完成后，检查未被操作的剩余行，若常数项非零则无解，否则为无穷解  
3. **反向消元**（zqiceberg）：将矩阵转化为对角矩阵形式，便于直接求解唯一解  

**算法流程可视化要点**：  
1. **矩阵染色**：  
   - 红色：当前正在处理的列  
   - 黄色：主元所在行  
   - 绿色：已完成消元的对角线元素  
2. **动画步骤**：  
   - 主元选择阶段：高亮候选行并动态比较数值  
   - 行交换：用箭头动画表示两行位置交换  
   - 消元过程：用粒子效果展示行间数值抵消  
3. **特殊判定**：  
   - 无解场景：剩余行常数项闪烁红光并播放警报音效  
   - 无穷解场景：全零行显示无限符号（∞）动画  

**复古像素化设计**：  
- 矩阵元素用16x16像素块表示，数值范围映射到16色NES调色板  
- 消元音效：采用8-bit风格电子音（主元选择→高音"哔"，行交换→中音"咚"）  
- 自动演示模式：AI按固定速度执行消元步骤，用户可按键加速/暂停  

---

### 题解清单 (≥4星)  
1. **Piwry（4.5★）**  
   - 亮点：通过维护"倒三角"结构精准判定无解/无穷解，代码简洁  
   - 关键代码：`nwline`变量追踪已处理行，剩余行常数项统一检查  

2. **Rui_R（4.2★）**  
   - 亮点：扩展主元搜索范围至全部未锁定行，解决特殊Hack数据  
   - 引用调试心得：  
     > "原本认为只有后续行可用，导致错误处理可用方程。改为全局搜索后通过Hack数据"  

3. **zqiceberg（4.0★）**  
   - 亮点：标准高斯消元+反向消元实现清晰，输出处理避免-0.00  

---

### 最优思路提炼  
**核心技巧**：  
1. **列主元消去法**：每列选择最大绝对值元素作为主元，显著降低浮点误差  
2. **自由变量标记**：遇到全零列时保留该列，后续判定其对应变量为自由变量  
3. **阶梯矩阵秩判定**：通过非零行数量快速确定解的类型  

**代码实现关键**：  
```cpp
// Piwry 题解核心片段
for(int k=0; k<N; k++){
    int maxi = nwline;
    for(int i=nwline+1; i<N; i++)  // 列主元选择
        if(Abs(A[i][k]) > Abs(A[maxi][k])) maxi = i;
    
    if(eq(A[maxi][k], 0)) continue; // 跳过全零列
    
    swap(A[nwline], A[maxi]);      // 行交换
    for(int i=0; i<N; i++){        // 全矩阵消元
        if(i == nwline) continue;
        double mul = A[i][k]/A[nwline][k];
        for(int j=k; j<=N; j++)    // 从当前列开始消去
            A[i][j] -= A[nwline][j] * mul;
    }
    nwline++;
}
// 判定剩余行
while(nwline < N)
    if(!eq(A[nwline++][N], 0)) return puts("-1");
```

---

### 同类题目推荐  
1. **P3389 【模板】高斯消元法**（基础高斯消元）  
2. **P2447 [SDOI2010] 外星千足虫**（异或方程组+高斯消元）  
3. **P4035 [JSOI2008] 球形空间产生器**（高斯消元解几何方程组）  

---

### 可视化代码片段（Canvas动画）  
```javascript
// 矩阵渲染核心逻辑
function drawMatrix(ctx, matrix) {
  const CELL_SIZE = 30;
  for(let i=0; i<matrix.length; i++) {
    for(let j=0; j<matrix[0].length; j++) {
      // 高亮当前操作列和主元行
      if(j === currentCol) ctx.fillStyle = '#FF4444'; 
      else if(i === pivotRow) ctx.fillStyle = '#FFFF00';
      else ctx.fillStyle = '#FFFFFF';
      
      ctx.fillRect(j*CELL_SIZE, i*CELL_SIZE, CELL_SIZE, CELL_SIZE);
      // 绘制数值（简化版）
      ctx.fillStyle = '#000000';
      ctx.fillText(matrix[i][j].toFixed(2), j*CELL_SIZE+5, i*CELL_SIZE+20);
    }
  }
}
// 8-bit音效触发
function playSound(type) {
  const osc = audioCtx.createOscillator();
  osc.frequency.value = type === 'pivot' ? 880 : 440; // 高音主元选择，低音行交换
  osc.connect(audioCtx.destination);
  osc.start(); osc.stop(0.1);
}
```

---

### 个人调试心得  
> Piwry提到：  
> "在浮点判等时，最初未考虑精度误差导致Hack数据失败。添加`1e-9`容差后通过，教训深刻"  

> Rui_R反思：  
> "原以为已处理的方程无需再访问，直到遇到系数分散的特殊案例。全局主元搜索虽增加计算量，但保证正确性"  

---

### 扩展思考  
当方程组系数为整数时，可通过**分数运算**避免浮点误差。但需实现分数类（分子/分母），在50x50规模下复杂度可控。此为算法优化的进阶方向。

---
处理用时：83.83秒
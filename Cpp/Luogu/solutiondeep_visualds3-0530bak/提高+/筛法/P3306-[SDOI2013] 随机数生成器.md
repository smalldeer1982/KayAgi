# 题目信息

# [SDOI2013] 随机数生成器

## 题目背景

小 W 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。

## 题目描述

最近小 W 准备读一本新书，这本书一共有 $p$ 页，页码范围为 $0 \sim p-1$。

小 W 很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用 NOI2012 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。

我们用 $x_i$ 来表示通过这种方法生成出来的第 $i$ 个数，也即小 W 第 $i$ 天会读哪一页。这个方法需要设置 $3$ 个参数 $a,b,x_1$，满足 $0\leq a,b,x_1\lt p$，且 $a,b,x_1$ 都是整数。按照下面的公式生成出来一系列的整数：
$$x_{i+1} \equiv a \times x_i+b \pmod p$$
其中 $\bmod$ 表示取余操作。

但是这种方法可能导致某两天读的页码一样。

小 W 要读这本书的第 $t$ 页，所以他想知道最早在哪一天能读到第 $t$ 页，或者指出他永远不会读到第 $t$ 页。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq T \leq 50$。
- $0 \leq a, b, x_1, t \lt p$，$2 \leq p \leq 10^9$。
- $p$ 为质数。

## 样例 #1

### 输入

```
3
7 1 1 3 3
7 2 2 2 0
7 2 2 2 1
```

### 输出

```
1 
3 
-1```

# AI分析结果



### 算法分类  
**BSGS算法（大步小步算法）**  

---

### 题解思路与核心难点  
#### 核心算法流程  
1. **特殊情形处理**  
   - **a=0**：仅需判断第2天是否为t  
   - **a=1**：转化为线性同余方程 `(t-x1) ≡ b*(n-1) mod p`  
   - **x1=t**：直接返回第1天  

2. **一般情形推导**  
   将递推式转换为等比数列形式：  
   $$X_n + \frac{b}{a-1} ≡ a^{n-1}(X_1 + \frac{b}{a-1}) \mod p$$  
   进一步化简为离散对数问题：  
   $$a^{n-1} ≡ \frac{t + \frac{b}{a-1}}{X_1 + \frac{b}{a-1}} \mod p$$  

3. **BSGS算法求解**  
   - 将指数问题分解为 `m = ceil(sqrt(p))` 的块  
   - 预计算右侧值的所有可能幂次并存入哈希表  
   - 通过大步小步策略匹配左侧值  

#### 解决难点  
- **数学推导**：正确转换递推式为等比数列形式，处理模运算中的除法（需计算逆元）  
- **边界处理**：a=0/1时的特殊逻辑需严格覆盖  
- **复杂度优化**：BSGS算法将指数搜索复杂度从O(p)降至O(sqrt(p))  

---

### 题解评分（≥4星）  
1. **ChenZ01（5星）**  
   - 推导过程清晰，代码覆盖所有特殊情况  
   - 使用STL map实现BSGS，代码简洁易读  
   - 关键亮点：分情况讨论完整，数学变形步骤详细  

2. **HoshiuZ（4星）**  
   - 数学推导与代码实现完整  
   - 使用手写哈希表优化性能  
   - 不足：变量命名可读性稍差  

3. **qwaszx（4星）**  
   - 代码简洁，逻辑清晰  
   - 使用C++11特性简化实现  
   - 不足：对特殊情况的注释较少  

---

### 最优思路提炼  
**关键技巧**：  
1. **等比数列转换**：通过引入常数项将线性递推式转换为等比数列，避免直接处理高阶项  
2. **逆元计算**：利用费马小定理快速计算模素数下的除法  
3. **分块哈希**：BSGS算法将离散对数问题分解为预计算和块匹配两步，平衡时间与空间  

---

### 类似题目推荐  
1. [P3846 可爱的质数](https://www.luogu.com.cn/problem/P3846)（BSGS模板题）  
2. [P2485 计算器](https://www.luogu.com.cn/problem/P2485)（离散对数+同余方程综合）  
3. [P3306 随机数生成器](https://www.luogu.com.cn/problem/P3306)（本题变种，参数范围不同）  

---

### 可视化设计（像素风格BSGS演示）  
**动画方案**：  
1. **网格绘制**：  
   - 在Canvas上绘制sqrt(p) x sqrt(p)的网格，每个格子代表一个哈希表条目  
   - 当前搜索的块用闪烁边框高亮  

2. **动态匹配**：  
   - **小步阶段**：从左下角开始逐格填充预计算值（绿色像素块）  
   - **大步阶段**：从右上角开始跳跃式匹配（红色像素块）  
   - 匹配成功时触发爆炸动画+8-bit胜利音效  

3. **音效设计**：  
   - 移动：短促“哔”声（类似FC马里奥跳跃）  
   - 匹配失败：低沉“嗡”声  
   - 成功匹配：经典《超级马里奥》金币音效  

**交互控制**：  
- 速度滑块：调节动画帧间隔（100ms~2s）  
- 单步执行：按空格键逐步执行BSGS的预计算和匹配步骤  

---

### 核心代码片段（ChenZ01实现）  
```cpp
long long bsgs(long long a, long long b, int MOD) {
    a %= MOD, b %= MOD;
    std::map <long long, long long> map;
    register long long m = ceil(sqrt(MOD)), t = 1;
    for (register int i = 0; i < m; ++i) { // 预计算小步
        if (!map.count(t)) map[t] = i;
        t = t * a % MOD;
    }
    register long long k = inv(t, MOD), w = b;
    for (int i = 0; i < m; ++i) { // 大步匹配
        if (map.count(w)) return i * m + map[w];
        w = w * k % MOD;
    }
    return -1;
}
```

---

### 数学推导可视化示例  
**等比数列转换过程**：  
```
初始递推式: X_{i+1} = aX_i + b  
引入常数项 k: X_{i+1} + k = a(X_i + k)  
解得 k = b/(a-1)  
等比形式: X_n + k = a^{n-1}(X_1 + k)  
最终方程: a^{n-1} ≡ (t + k)/(X1 + k) mod p
```  
（动画中逐步显示每步变形，关键项用不同颜色闪烁）  

---

### 调试心得摘录  
**Hovny题解**：  
> "提交了十几遍，发现错误原因是求a≠1时的分子分母可能为负，改用`(x%p+p)%p`确保非负后通过"  
**启示**：模运算中负值处理是常见陷阱，需显式转换为正数  

**wwyx2001题解**：  
> "手写哈希表比unordered_map快3倍，成功抢到最优解"  
**启示**：性能敏感场景需避免STL开销

---
处理用时：71.42秒
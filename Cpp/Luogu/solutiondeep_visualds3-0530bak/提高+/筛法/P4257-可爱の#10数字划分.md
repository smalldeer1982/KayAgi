# 题目信息

# 可爱の#10数字划分

## 题目背景

可可可可可可爱的付公主 qwq 有 $n$ 个数，$1\sim n$，每个数都有价值 $V_i$，你要将它们划分成若干个集合，每个数属于一个集合。

## 题目描述

我们这里规定:

1. 质数只能和质数分在同一个集合。  
2. 合数只能和合数分在同一个集合（$1$ 也算在合数内）。   
3. 我们假设目前所有质数集合的并集为 $U$（也就是之前所有质数集合以及 $S$ 的并集），每个质数集合 $S$ 的价值定义如下：  
$$V_S=\frac {(\sum_{i\in S}V_i)^p} {\prod_{i\in U}V_i}$$

4. 我们定义每个合数集合 $S$ 的价值如下:

令 $k=|S|$，我们用这 $k$ 个数分别作为 $k$ 条边的权值，连接 $k+1$ 个点，构成一棵树。对于一个排列 $P(1\sim k+1)$，价值为：

$$V_P=\sum_{i=1}^{n-1} f(P_i,P_{i+1})$$

其中 $f(u,v)$ 为路径 $(u,v)$ 上最大的边权。

集合 $S$ 的价值为：

$$V_S=E(\min\{V_P\})\times|S|$$

其中 $E(X)$ 代表 $X$ 的数学期望，期望是针对所有可能的有标号无根树，$\min$ 是针对所有可能的 $P$。这时集合内所有元素都不同，也就是所有边不同。

5. 一个划分方案的价值定义为所有集合的价值的乘积。
6. 两个划分方案相同当且仅当它们中所有集合对应相同，且质数集合的相对顺序相同。

现在给定 $n,p$ 和 $V_i$，请你求出所有合法的不同划分方案的价值之和。

结果对 $10^9+7$ 取模，除法请使用乘法逆元。

## 说明/提示

### 样例解释

有以下 $6$ 种划分方案:

1. $(2,3)$ 和 $(1,4)$。$(2,3)$ 的价值为 ${\dfrac 5 6}$，$(1,4)$ 的价值为 $10$，总价值为 ${\dfrac {25} 3}$。
2. $(2),(3)$ 和 $(1,4)$。$(2)$ 的价值为 $1$，$(3)$ 的价值为 ${\dfrac 1 2}$，$(1,4)$ 的价值为 $10$，总价值为 $5$。
3. $(3),(2)$ 和 $(1,4)$。$(3)$ 的价值为 $1$，$(2)$ 的价值为 ${\dfrac 1 3}$，$(1,4)$ 的价值为 $10$，总价值为 ${\dfrac {10} 3}$。
4. $(2,3)$ 和 $(1),(4)$。$(2,3)$ 的价值为 ${\dfrac 5 6}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 ${\dfrac {10} 3}$。
5. $(2),(3)$ 和 $(1),(4)$。$(2)$ 的价值为 $1$，$(3)$ 的价值为 ${\dfrac 1 2}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 $2$。
6. $(3),(2)$ 和 $(1),(4)$。$(3)$ 的价值为 $1$，$(2)$ 的价值为 ${\dfrac 1 3}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 ${\dfrac 4 3}$。

因此所有划分方案的价值和为${\dfrac {70} 3}$。对 $10^9+7$ 取模后结果为 $333333359$。

### 数据范围

对于 $100\%$ 的数据，满足 $1\le n\le 70$，$1\le V_i\le 10^{12}$。

下表中给出了每个测试点具体的数据范围，都表示小于等于。为了防止卡 OJ，所以本题数据组数进行压缩，分值改变，具体参照表格。

| 数据编号 |  n   |  p   |  Vi   | 测试点分值 | 时限 |
| :------: | :--: | :--: | :---: | :--------: | :--: |
|    1     |  10  |  1   |  100  |     10     |  1s  |
|    2     |  20  |  1   | 1000  |     10     |  1s  |
|    3     |  30  |  1   | 10000 |     10     |  1s  |
|    4     |  40  | 1e9  | 1e12  |     10     |  1s  |
|    5     |  50  |  1   | 1e12  |     5      |  1s  |
|    6     |  50  | 1e9  | 1e12  |     5      |  1s  |
|    7     |  60  |  1   | 1e12  |     5      |  2s  |
|    8     |  60  | 1e9  | 1e12  |     5      |  2s  |
|    9     |  70  | 1e9  | 1e12  |     20     |  10s  |
|    10    |  70  | 1e9  | 1e12  |     20     |  5s  |

提示：大家不要太过相信自己的常数，尽量做好常数优化。

## 样例 #1

### 输入

```
4 1
1 2 3 4
```

### 输出

```
333333359```

# AI分析结果



## 算法分类
动态规划、数学推导、子集卷积优化

---

## 综合分析与结论

### 核心思路
将问题拆分为质数集合与合数集合独立处理：
1. **质数部分**：使用动态规划+子集卷积优化，预处理每个子集的贡献
2. **合数部分**：数学推导得出边权和与集合大小的关系，通过排序+动态规划计算贡献
3. 最终将两部分的生成函数相乘得到答案

### 关键难点与解决方案
1. **质数集合的指数级状态空间**  
   通过子集卷积与FMT优化将复杂度从O(3^n)降为O(2^n n²)，使用莫比乌斯变换处理集合运算

2. **合数集合的数学期望推导**  
   证明边权和等于期望值×集合大小：通过分析排列中每条边的贡献次数，发现每条边恰被计算一次，从而得到结论E(min{V_P}) = 边权和 / (k+1)

3. **大数据范围下的模运算**  
   预处理逆元数组，所有除法操作转换为乘法逆元计算

---

## 题解清单 (4星及以上)

### 题解1（官方题解） ⭐⭐⭐⭐⭐
**亮点**：
- 将问题拆分为质数/合数独立处理
- 合数部分给出数学结论简化计算
- 提出子集卷积优化方案

### 题解2（玫葵之蝶） ⭐⭐⭐⭐
**亮点**：
- 详细说明质数部分的状态转移方程
- 给出FMT优化思路的参考资料
- 指出合数部分排序边权的实现细节

---

## 核心算法实现

### 质数部分（FMT优化）
```cpp
vector<int> dp(1<<n);
dp[0] = 1;
for(int i=0; i<=n; i++) {
    for(int mask=0; mask<(1<<n); mask++) {
        if(__builtin_popcount(mask) != i) continue;
        for(int sub=(mask-1)&mask; ; sub=(sub-1)&mask){
            int add = mask^sub;
            if(is_prime_set(add)) { // add是质数子集
                dp[mask] = (dp[mask] + dp[sub] * sum_v[add] % MOD) % MOD;
            }
            if(sub == 0) break;
        }
    }
    for(int mask=0; mask<(1<<n); mask++) {
        dp[mask] = dp[mask] * inv_prod[mask] % MOD; 
    }
}
```

### 合数部分（动态规划）
```cpp
sort(composite.begin(), composite.end(), greater<int>());
vector<int> dp_comp(k+1, 0);
dp_comp[0] = 1;
for(int v : composite){
    for(int i=k; i>=1; i--){
        dp_comp[i] = (dp_comp[i] + dp_comp[i-1] * v % MOD * (i) % MOD) % MOD;
    }
}
```

---

## 可视化设计要点

### 像素动画方案
1. **质数集合划分**  
   - 用红色像素块表示质数集合，展示子集生成过程
   - 每次合并子集时播放"滴"音效

2. **合数边权排序**  
   - 绿色方块从右向左滑动排序，边权大的方块发光
   - 动态规划时显示背包容量增长过程

3. **最终结果计算**  
   - 质数/合数两部分结果以蓝/黄数字显示，相乘时触发粒子特效

### 音效设计
- 子集生成：8-bit短音效
- 状态转移：上升音阶
- 错误操作：蜂鸣声

---

## 相似题目推荐
1. P1777 子集卷积（子集DP优化）
2. P4208 最小生成树计数（边权排序思想）
3. P5491 分治FFT（生成函数应用）

---
处理用时：54.85秒
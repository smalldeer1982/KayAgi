# 题目信息

# [CQOI2018] 破解D-H协议

## 题目背景

Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。

## 题目描述

假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\bmod$ 表示取模运算）：

1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\boldsymbol P$ 和 $\boldsymbol g$ 的数值都是公开的，无需保密。**

2. Alice 生成一个随机数 $a$，并计算 $A=g^a\bmod P$，将 $A$ 通过不安全信道发送给 Bob。

3. Bob 生成一个随机数 $b$，并计算 $B=g^b\bmod P$，将 $B$ 通过不安全信道发送给 Alice。

4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\bmod P$。

5. 双方得到了相同的 $K$，即 $g^{ab} \bmod P$。$K$ 即之后通讯的加密密钥。

可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。

当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。

$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。


## 说明/提示

对于 $30\%$ 的数据，$2\le A,B,P\le 1000$；

对于 $100\%$ 的数据，$2\le A,B<P<2^{31}，2\le g<20，1\le n\le 20$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
3 31
3
27 16
21 3
9 26```

### 输出

```
4
21
25```

# AI分析结果



## 唯一算法分类
**BSGS 算法**

---

## 综合分析与结论
### 核心思路与难点
题目要求通过窃听的 A、B 计算密钥 K = g^{ab} mod P。核心在于使用 **BSGS 算法**求解离散对数问题，即从 A = g^a mod P 或 B = g^b mod P 中解出 a 或 b，再通过快速幂计算 K。难点在于：
1. **BSGS 的预处理与分块匹配**：需将指数分解为 i*m - j 的形式，预处理大块 i*m 的值，枚举小块 j 的余数。
2. **哈希表优化**：使用 `unordered_map` 或手写哈希表加速查询。
3. **快速幂优化**：利用费马小定理（指数模 P-1）减少计算量。

### 可视化设计思路
1. **分步动画**：
   - **预处理阶段**：展示计算 g^(i*m) 的过程，用颜色标记不同 i 的块。
   - **查询阶段**：动态枚举 j，计算 A*g^j，在预处理哈希表中高亮匹配项。
   - **找到解时**：用闪烁效果显示匹配的 i 和 j，输出 a = i*m - j。
2. **复古像素风格**：
   - **网格布局**：用 8-bit 风格展示哈希表存储的键值对。
   - **音效触发**：匹配成功时播放上扬音效，预处理完成时播放节奏音效。
3. **交互功能**：
   - **参数调节**：允许调整分块大小 m，观察不同 m 对性能影响。
   - **自动演示**：模拟“AI 破解”流程，自动执行预处理与查询。

---

## 题解清单（≥4星）
### 1. 作者：Leonid（⭐⭐⭐⭐）
- **亮点**：代码简洁，适合教学；直接调用 STL map 实现，易理解。
- **核心代码**：
  ```cpp
  ll BSGS(ll a, ll b, ll p) {
    k.clear();
    ll m = ceil(sqrt(p)), ans;
    for (ll i=0; i<=m; i++) { // 预处理哈希表
      if (!i) ans = b % p;
      else ans = (ans * a) % p;
      k[ans] = i;
    }
    ll t = qpow(a, m, p);
    ans = 1;
    for (ll i=1; i<=m; i++) { // 查询匹配项
      ans = (ans * t) % p;
      if (k[ans]) return i*m - k[ans];
    }
    return -1;
  }
  ```

### 2. 作者：LeavingZzz（⭐⭐⭐⭐⭐）
- **亮点**：手写哈希表提升性能；预处理逻辑清晰，代码高效。
- **关键优化**：
  ```cpp
  struct Hash_table { // 手写哈希表
    static const LL MOD = 1999997;
    LL Hash[MOD], V[MOD], stk[MOD], top;
    void Insert(LL val, LL mi) { ... } // 插入键值对
    LL find(LL val) { ... } // 查询键值
  } H;
  ```

### 3. 作者：MY（⭐⭐⭐⭐）
- **亮点**：使用 `unordered_map` 平衡性能与可读性；代码模块化。
- **实现片段**：
  ```cpp
  inline int BSGS(int a, int b, int p) {
    unordered_map<int, int> vis;
    int t = sqrt(p) + 1;
    for (int i=0; i<t; i++) { // 预处理哈希表
      vis[1ll * b * val % p] = i;
      val = val * a % p;
    }
    ...
  }
  ```

---

## 最优思路与技巧提炼
1. **BSGS 分块策略**：  
   将指数分解为 x = i*m - j，预处理 i*m 的大块值，枚举 j 的小块余数。时间复杂度 O(√P)。
2. **哈希表优化**：  
   手写哈希表或 `unordered_map` 加速查询，避免 STL map 的 O(log n) 查询开销。
3. **快速幂优化**：  
   利用费马小定理将指数 a 对 P-1 取模，防止计算 B^a 时数值溢出。
4. **参数统一预处理**：  
   固定 g 和 P 时，预处理 g^m 的值，避免每组数据重复计算。

---

## 类似题目推荐
1. **P3846 [TJOI2007] 可爱的质数**：BSGS 模板题，直接求解离散对数。
2. **P2485 [SDOI2011] 计算器**：结合快速幂、BSGS 和扩展欧几里得算法。
3. **P3306 [SDOI2013] 随机数生成器**：递推式转化为离散对数问题，需扩展 BSGS。

---

## 个人心得摘录
- **预处理范围**：计算 m = ⌈√P⌉ 时需注意边界，如 `m = sqrt(p) + 1`。
- **哈希冲突处理**：手写哈希表需设计合理的 MOD 大小和冲突解决策略。
- **负数解处理**：BSGS 返回的 x 需调整为正数，如 `(o % p + p) % p`。

---

## 算法可视化示例（BSGS 流程）
```javascript
// 伪代码：BSGS 动画演示
function visualizeBSGS(g, p, A) {
  let m = Math.ceil(Math.sqrt(p));
  let hash = new Map();
  
  // 预处理阶段
  for (let j=0; j<m; j++) {
    let val = (A * powMod(g, j, p)) % p;
    hash.set(val, j);
    highlightGrid(j, val); // 在网格中高亮当前 j 和 val
  }
  
  // 查询阶段
  let gm = powMod(g, m, p);
  for (let i=1; i<=m; i++) {
    let target = powMod(gm, i, p);
    if (hash.has(target)) {
      let j = hash.get(target);
      let x = i*m - j;
      flashSolution(x); // 闪烁显示解
      return x;
    }
  }
}
```

---

## 复古游戏化设计
1. **像素风格**：  
   - 使用 16 色调色板，哈希表以 8x8 像素块展示。
   - 每次插入哈希表时，播放经典 FC 音效（如《超级马里奥》金币声）。
2. **自动演示模式**：  
   - 算法自动运行，角色（像素小人）沿预处理和查询路径移动。
3. **积分系统**：  
   - 每正确匹配一个键值对获得 100 分，错误匹配扣分。
   - 连续快速破解触发“连击奖励”，加速背景音乐。

---
处理用时：81.30秒
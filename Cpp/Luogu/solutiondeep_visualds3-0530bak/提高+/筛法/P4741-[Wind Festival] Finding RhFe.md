# 题目信息

# [Wind Festival] Finding RhFe

## 题目背景

$[Morning - 8:00 A.M.]$

热衷于结交老铁的$gyx$小哥哥听说了风筝节的举办，一大早就来到了现场，现在他已经迫不及待见到来玩的同学们啦~

## 题目描述

$gyx$的人格魅力是无限哒~

已知风筝节上有$N$($1\le N\le 10^6$)个同学（来玩的人真的很多），每个同学都对$gyx$有一个兴趣程度$c_i$（$ |c_i|\le 10^9$），因为$gyx$的性格特点太明显啦，不存在对$gyx$兴趣程度为$0$的同学，对于每个同学，都可以和$gyx$结交为老铁，$gyx$的高兴程度就是所有结！交！过！成为老铁的同学对$gyx$兴趣程度之和。$gyx$不愿意做令自己伤心的事情，所以如果所有同学对$gyx$感到反感（即兴趣程度为负）$gyx$就会直接离开风筝节。

$gyx$可以选择其中的$k$（$1\le k\le N$）个同学来结交，但一旦选择好，$gyx$的结交顺序就不可以变化了。

因为来风筝节的人实在是太多啦，$gyx$不愿意记住所有的老铁太长的时间，但是$gyx$的脑子里记着与越早结交的老铁的点点滴滴越多，也越难忘记，$gyx$忘记每个人的条件是当且仅当，在$gyx$还记着的老铁里当前的这个老铁是最后结交的。

但是由于$gyx$希望与更多不同性格的同学结交，$gyx$与每一个同学只愿意结交一次，即使遗忘以后也不会再次结交。

当风筝节上$gyx$选择的同学都结交结束后，随着时间的流逝，$gyx$也会渐渐地把所有同学都忘掉，遗忘方式与之前相同，直到最后忘记了自己结交过的所有老铁，再出发前往新的征程。

由于不同的交友并遗忘的顺序可能会发生有趣的事情，$gyx$想知道在保证自己高兴程度最大时选择好结交范围和结交顺序的情况下，$gyx$可以有多少种不同的交友并遗忘的顺序呢？

由于来风筝节的人实在是太多了，$gyx$只想知道不同顺序的方案数的值对$P$（$0<P\le 10^9$）取模后的结果。

## 说明/提示

对于$30\%$的数据保证$1\le N\le 30$；

对于$70\%$的数据保证$1\le N\le 500$；

对于$100\%$的数据保证$1\le N\le 10^6$，$0<P\le 10^9$，$|c_i|\le 10^9$。


## 样例 #1

### 输入

```
8 65
-1
36
21
97
-65
17
1
43```

### 输出

```
2```

# AI分析结果



**唯一算法分类**：组合数学（卡塔兰数）

---

### **综合分析与结论**

#### **核心思路**
题目要求选择所有兴趣程度为正的同学（确保总和最大），并计算满足栈式遗忘顺序的方案数。核心推导如下：
- **卡塔兰数模型**：入栈顺序确定时，出栈顺序的可能数为卡塔兰数 $C_n = \frac{1}{n+1} \binom{2n}{n}$。
- **关键观察**：无论结交顺序如何排列，最终的遗忘顺序数仅与正数个数 $n$ 相关，即答案直接为卡塔兰数 $C_n \bmod P$。

#### **解决难点**
1. **卡塔兰数的推导**：需理解遗忘顺序的栈性质，与入栈顺序无关。
2. **大数取模优化**：由于 $P$ 不保证为质数，需通过质因数分解计算组合数模值。

#### **题解评分**
- **nitrobenzene的题解（5星）**
  - **思路清晰**：直接识别卡塔兰数模型。
  - **代码高效**：预处理质数，分解阶乘质因数。
  - **优化合理**：避免逆元，通过质因数统计实现模运算。

---

### **最优思路与技巧提炼**
1. **卡塔兰数应用**：问题转换为入栈顺序固定时的出栈顺序数。
2. **质因数分解法**：统计 $\binom{2n}{n}/(n+1)$ 中每个质数的幂次，再相乘取模。
3. **预处理优化**：筛法预处理质数，加速质因数分解。

---

### **同类型题与算法套路**
- **类似问题**：栈的出栈顺序计数、括号生成、二叉树形态计数。
- **通用解法**：卡塔兰数模型、质因数分解处理非质数模数。

---

### **推荐题目**
1. **P1044 [NOIP2003 普及组] 栈**：直接计算卡塔兰数。
2. **P2532 [AHOI2012] 树屋阶梯**：卡塔兰数的变形应用。
3. **P3200 [HNOI2009] 有趣的数列**：卡塔兰数结合质因数分解。

---

### **代码核心实现**
```cpp
// 质数筛与卡塔兰数计算
void init() {
    memset(vis, true, sizeof(vis));
    vis[1] = false;
    for (int i = 2; i*i <= maxn; ++i) {
        if (vis[i]) {
            for (int j = i*i; j <= maxn; j += i) vis[j] = false;
        }
    }
    for (int i = 2; i <= maxn; ++i) {
        if (vis[i]) p.push_back(i);
    }
}

void katalan(int n) {
    add_alpha_fact(2*n);      // 分子 (2n)!
    sub_twice_alpha_fact(n);  // 分母 (n!)^2
    sub_alpha(n+1);            // 分母 (n+1)
}
```

---

### **可视化与算法演示**
1. **动画设计**：
   - **像素风格**：用色块表示同学入栈，出栈时块消失。
   - **栈操作高亮**：入栈时块变绿，出栈时变红并播放音效。
   - **自动模式**：模拟卡塔兰数的出栈序列生成，步进速度可调。
2. **游戏化交互**：
   - **积分系统**：正确计算质因数分解步骤得分。
   - **音效提示**：正确分解时播放8-bit成功音效，错误时短促提示。

---

### **复古像素化实现要点**
- **Canvas绘制**：用16色网格表示质因数分解过程。
- **音效触发**：质因数累加时播放“点击”音效，计算完成时播放胜利旋律。
- **自动演示AI**：逐步显示质数筛、阶乘分解、模乘运算，仿红白机菜单交互。

---
处理用时：377.06秒
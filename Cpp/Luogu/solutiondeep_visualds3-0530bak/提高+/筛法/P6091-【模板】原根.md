# 题目信息

# 【模板】原根

## 题目描述

给定整数 $n$，求它的所有原根。

为了减小你的输出量，给出输出参数 $d$，设 $n$ 的所有原根有 $c$ 个，从小到大分别为 $g_1,\ldots,g_c$，你只需要依次输出 $g_d,g_{2d},\ldots,g_{\lfloor\frac{c}{d}\rfloor\times d}$。

---

如果你不了解原根的定义，可以自行查找资料或阅读下列定义：

正整数 $g$ 是正整数 $n$ 的原根，当且仅当 $1\leq g\leq n-1$，且 $g$ 模 $n$ 的阶为 $\varphi(n)$。

## 说明/提示

【样例解释】

对于第 $1,2,4,6$ 组数据，给出的 $n$ 的所有原根都出现在输出中。

对于第 $3$ 组数据，$25$ 的原根集合为 $\{2,3,8,12,13,17,22,23\}$。

对于第 $5$ 组数据，$9$ 的原根集合为 $\{2,5\}$。

【数据范围】

对于 $100\%$ 的数据，$1\leq T\leq 10$，$2\leq n\leq 10^6$，$1\leq d\leq 200$，保证输出的数的总个数不超过 $10^5$。

## 样例 #1

### 输入

```
6
2 1
4 1
25 2
36 1
9 6
18 1
```

### 输出

```
1
1 
1
3 
8
3 12 17 23 
0

2

2
5 11 
```

# AI分析结果



# 算法分析与题解总结

## 算法分类
**数论（原根判定与生成）**

---

## 题解思路与难点对比

### 核心算法流程
1. **预处理**  
   - 计算欧拉函数 φ(n)，标记存在原根的数（2,4,p^k,2p^k）。
2. **分解质因数**  
   - 分解 φ(n) 的所有质因数，用于原根判定。
3. **寻找最小原根**  
   - 枚举可能的数，验证其阶是否等于 φ(n)，通过快速幂优化验证步骤。
4. **生成所有原根**  
   - 利用最小原根生成所有满足条件（与 φ(n) 互质）的指数幂，排序后按需输出。

### 解决难点对比
- **codecode**：通过数学证明确保算法的正确性，但代码复杂度较高。
- **ix35**：简化了判断逻辑，直接通过欧拉函数分解质因数，代码更简洁。
- **panyf**：通过线性筛预处理 φ(n) 的质因数，避免重复分解，优化时间复杂度至 O(Tn)。
- **0xyz**：引入随机化方法快速找到最小原根，显著减少枚举次数，但需处理随机性带来的不确定性。

---

## 题解评分 (≥4星)

1. **ix35 (★★★★☆)**  
   - **思路清晰**：直接分解 φ(n) 的质因数，快速验证原根。
   - **代码简洁**：通过预处理 φ(n) 的质因数减少计算量。
   - **示例代码**：  
     ```cpp
     void init() {
         // 预处理欧拉函数与原根存在性
     }
     int findrt(int p) {
         // 枚举最小原根
     }
     ```

2. **panyf (★★★★★)**  
   - **高效实现**：通过线性筛预处理 φ(n) 的质因数，优化至 O(n) 时间复杂度。
   - **核心代码**：  
     ```cpp
     for (int i = 1; i <= cnt; i++) {
         // 预处理质因数分解
     }
     ```

3. **0xyz (★★★★☆)**  
   - **随机化优化**：随机枚举候选原根，极大减少枚举次数。
   - **关键逻辑**：  
     ```cpp
     for (int i = 1; i <= 200; i++) {
         // 随机化寻找原根
     }
     ```

---

## 最优思路与技巧

1. **预处理与存在性判断**  
   - 预处理 φ(n) 和原根存在性，避免重复计算。
2. **快速质因数分解**  
   - 分解 φ(n) 的质因数时，仅需检查其素因子。
3. **最小原根快速验证**  
   - 使用快速幂验证候选数对每个质因子的幂次是否满足条件。
4. **生成原根的数学性质**  
   - 若 g 是原根，则所有 g^k（k 与 φ(n) 互质）均为原根。

---

## 可视化与算法演示

### 动画设计
1. **步骤展示**  
   - **分解 φ(n)**：动态显示质因数分解过程，高亮当前检查的质数。
   - **验证原根**：展示快速幂计算过程，标记满足条件的候选数。
   - **生成原根**：以网格形式展示生成的原根，按互质条件动态筛选。

2. **复古像素风格**  
   - **颜色方案**：使用 8-bit 调色板（如深蓝、绿、红）表示不同状态。
   - **音效**：在找到原根时播放经典 FC 音效，错误时播放低沉音效。

3. **交互设计**  
   - **步进控制**：允许单步执行验证过程，观察快速幂计算的每一步。
   - **自动演示**：AI 模式自动运行，展示最优路径与原根生成。

---

## 同类型题目推荐
1. **P4139 上帝与集合的正确用法**（扩展欧拉定理应用）
2. **P2485 计算器**（离散对数与原根问题）
3. **P4195 扩展BSGS**（高次同余方程求解）

---

## 代码核心实现

```cpp
// 预处理欧拉函数与原根存在性标记
void init() {
    phi[1] = 1;
    for (int i = 2; i < N; i++) {
        if (!vis[i]) {
            prime[cnt++] = i;
            phi[i] = i - 1;
        }
        // 线性筛计算 phi[i]
    }
    // 标记存在原根的数
}

// 寻找最小原根
int find_min_root(int n) {
    int phin = phi[n];
    vector<int> factors = factorize(phin); // 分解 phi(n) 的质因数
    for (int g = 2; ; g++) {
        if (pow_mod(g, phin, n) != 1) continue;
        bool valid = true;
        for (int p : factors) {
            if (pow_mod(g, phin / p, n) == 1) {
                valid = false;
                break;
            }
        }
        if (valid) return g;
    }
}

// 生成所有原根并排序输出
void generate_roots(int n, int d) {
    int g = find_min_root(n);
    vector<int> roots;
    for (int k = 1, prod = 1; k <= phi[n]; k++) {
        prod = (prod * g) % n;
        if (gcd(k, phi[n]) == 1) roots.push_back(prod);
    }
    sort(roots.begin(), roots.end());
    // 按 d 步长输出
}
```

---

## 个人心得
- **调试教训**：在验证原根时，需严格检查所有质因子，遗漏任一因子会导致错误。
- **优化顿悟**：随机化方法显著减少枚举时间，但需平衡随机次数与稳定性。

---
处理用时：75.15秒
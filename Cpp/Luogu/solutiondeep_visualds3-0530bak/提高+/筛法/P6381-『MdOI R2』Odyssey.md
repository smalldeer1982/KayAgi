# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果



## 唯一算法分类
拓扑排序 + 动态规划

## 综合分析与结论

### 核心算法流程
1. **质因数分解与数对处理**  
   - 将每条边权值分解质因数，指数对k取模得到简化形式w1
   - 计算其完美配对值w2 = ∏p_i^(k - mod_k)
   - 若w2超过值域范围则标记为无效状态

2. **分层图建模**  
   - 对每个有效边权w1及其配对w2建立两层节点（原节点u和u+n）
   - 边权w1的边从u层出发到v+n层，边权w2的边从u+n层出发到v层

3. **拓扑排序与动态规划**  
   - 按拓扑序处理节点，维护dp[v][state]表示到达节点v时状态为state的最大长度
   - 状态转移时通过分层结构保证完美数对交替出现

### 可视化设计要点
1. **像素风格呈现**  
   - 使用16色调色板（土黄、深蓝、墨绿等复古色）
   - 节点绘制为8位方块，分层结构用不同颜色边框表示
   - 边权状态通过颜色编码（如红色表示当前状态，蓝色表示配对状态）

2. **动画流程**  
   - 初始展示质因数分解过程（粒子动画分解数字为质因数泡泡）
   - 拓扑排序时用扫描线效果标记当前处理节点
   - 状态转移时显示光柱连接分层节点，伴随8bit音效

3. **交互功能**  
   - 速度调节滑块控制拓扑排序步频
   - 单步执行时可查看当前节点的所有状态信息
   - 错误路径播放短促"哔"声，正确转移播放上升音阶

## 题解清单（4星及以上）

### 1. BFqwq（⭐⭐⭐⭐⭐）
- **核心亮点**：分层图拓扑排序法，通过节点扩展保证数对交替
- **关键实现**：双重节点处理（u和u+n层）解决连续边权问题
- **优化技巧**：预处理质数表加速分解，动态数组复用减少内存

### 2. 一扶苏一（⭐⭐⭐⭐）
- **核心亮点**：双模数哈希处理大数状态
- **实现特色**：使用vector<pair>结构紧凑存储质因数状态
- **调试心得**：特别处理k=1的边界情况，验证哈希碰撞

### 3. under_the_time（⭐⭐⭐⭐）
- **核心亮点**：map存储动态规划状态，代码结构简洁
- **教学价值**：完整注释分解过程，适合算法初学者理解
- **实践技巧**：优先队列加速拓扑排序，避免递归爆栈

## 最优思路提炼

### 数论优化技巧
- **快速分解质因数**：预处理质数表至√1e5，分解时直接取余
- **状态压缩**：将质因数指数模k后的乘积作为特征值，避免存储完整质因数分解

### 动态规划技巧
- **分层状态设计**：通过u和u+n的节点分层，自然限制转移路径的边权交替
- **拓扑序转移**：利用DAG特性保证无后效性，无需记忆化搜索

### 工程实践技巧
- **内存优化**：每次处理完配对边权后立即清空邻接表
- **无效状态剪枝**：当计算配对值超过1e5时直接舍弃，减少状态空间

## 相似题目推荐
1. **P4017 最大食物链计数**（拓扑排序+DP）
2. **P3385 【模板】负环**（分层图思想）
3. **P1073 [NOIP2009 提高组] 最优贸易**（状态转移与路径记录）

## 核心代码片段

```cpp
// 质因数分解与配对计算
void work(int u, int v, int w, int l) {
    int res1 = 1, res2 = 1;
    for(int i = 1; pri[i] * pri[i] <= w; i++) {
        int tmp = 0;
        while(w % pri[i] == 0) tmp++, w /= pri[i];
        tmp %= k;
        if(tmp % k) {
            res1 *= pow(pri[i], tmp % k);
            res2 *= pow(pri[i], k - tmp % k);
        }
    }
    // 处理剩余大质数
    if(w > 1) {
        res1 *= w;
        res2 *= pow(w, k-1);
    }
    // 存储配对关系
    f[res1] = res2;
    f[res2] = res1;
}

// 分层图拓扑转移
void topo(int w) {
    // 建立分层图的边
    for(edge e : g[w]) {
        add(e.from, e.to + n, e.length); // 原层到配对层
    }
    for(edge e : g[f[w]]) {
        add(e.from + n, e.to, e.length); // 配对层回原层
    }
    // 拓扑排序过程
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int i = h[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            dp[v] = max(dp[v], dp[u] + e[i].len);
            // 更新答案并维护拓扑序
        }
    }
}
```

## 复古像素动画设计

### 视觉要素
1. **节点表现**：8x8像素方块，不同层用红/蓝边框区分
2. **边权标记**：当前激活边显示黄色光晕，配对边显示绿色闪烁
3. **状态面板**：右侧16x16像素区域显示当前处理的质因数分解式

### 音效设计
- **质因数分解**：分解成功时播放"叮咚"音
- **状态转移**：每次转移成功播放上升琶音
- **发现最长路径**：播放经典马里奥过关音乐

### 自动演示逻辑
```javascript
class OdysseyAnimator {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.nodes = new Map(); // 存储节点像素坐标
        this.speed = 1; // 动画速度系数
    }

    // 核心动画帧
    animateStep(stepType) {
        switch(stepType) {
            case 'prime_factor':
                this.showExplosion(w); // 质因数粒子效果
                break;
            case 'topo_sort':
                this.highlightNode(u); // 高亮当前拓扑节点
                this.drawDataFlow(u, v); // 绘制分层边
                break;
            case 'dp_update':
                this.sparkEffect(v); // 目标节点闪光
                break;
        }
        // 播放对应8bit音效
        AudioManager.play(stepType); 
    }
}
```

---
处理用时：74.88秒
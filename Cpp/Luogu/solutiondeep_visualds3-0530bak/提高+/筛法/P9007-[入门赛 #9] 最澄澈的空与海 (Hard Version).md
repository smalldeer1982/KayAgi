# 题目信息

# [入门赛 #9] 最澄澈的空与海 (Hard Version)

## 题目背景

材料 1：

> 请小心地计算下面的算式：$138 - 108 \div 6 = ?$  
> 你大概难以置信，这个算式的计算结果竟然是 $5!$

材料 2：

> 对于一个正整数 $x$，$x! = 1 \times 2 \times \cdots \times (x - 1) \times x$。我们称 $x!$ 为 $x$ 的阶乘。  
> 特别的，$0! = 1$。

显然，「$138 - 108 \div 6 = 5$」是错误的，而「$(138 - 108) \div 6 = 5$」是正确的，所以对材料 1 中的内容，部分读者会认为「作者没有搞清加减乘除的运算优先级关系而犯错」。

然而，材料 1 最后一行的叹号并不是标点符号，而是材料 2 提到的「阶乘」。

考虑到这一点，「$138 - 108 \div 6 = 5! = 1 \times 2 \times \cdots \times 5 = 120$」显然就是正确的了。

## 题目描述

然而，此题可能与上面的题目背景关系不是很大。

我们会给你 $T$ 组数据，每组数据包括一个正整数 $n$。

对于每组数据，请你帮助求出满足以下条件的整数三元组 $(x, y, z)$ 的组数：

1. $x \geq 0$，$z \geq 1$。
2. $x - y \div z = n!$ 且 $(x - y) \div z = \dfrac{n!}{n}$。

由于答案可能过大，因此你需要输出答案对 $998244353$ 取模后的结果。

不难注意到答案有可能为 $\infty$，这时请按照「输出格式」要求进行处理。

**请注意此处应满足 $(x - y) \div z = \dfrac{n!}{n}$ 而不是 $= n$。**

请注意这里的 $\div$ 不是向下取整的整除，这显然意味着你需要保证 $y \div z$ 和 $(x - y) \div z$ 为整数。

## 说明/提示

### 样例 1 解释

样例中的具体三元组如下：

| $n$ | 所有可能的三元组 |
| :----------: | :----------: |
| $2$ | $(2, 0, 2)$ |
| $3$ | $\begin{matrix}(8, 4, 2) & (5, -5, 5) & (6, 0, 3)\end{matrix}$ |
| $4$ | $\begin{matrix}(19, -95, 19) & (21, -21, 7) & (24, 0, 4) \\ (27, 9, 3) & (20, -40, 10) & (36, 24, 2)\end{matrix}$ |

### 数据规模与约定

对于前 $20\%$ 的数据，保证 $T \leq 10$，$n \leq 10$。

对于前 $40\%$ 的数据，保证 $n \leq 10 ^ 3$。

对于另外 $20\%$ 的数据，保证 $T = 1$。

对于 $100\%$ 的数据，保证 $1 \leq T \leq 10 ^ 5$，$1 \leq n \leq 10 ^ 6$。

## 样例 #1

### 输入

```
3
2
3
4```

### 输出

```
1
3
6```

# AI分析结果



## 算法分类
**数论（质因数分解与约数计数）**

---

## 综合分析与结论

### 核心算法流程
1. **数学推导**：通过方程变形得出解的数量等价于 `(n-1)*(n-1)!` 的因数个数，特判 `n=1` 时无穷解。
2. **质因数分解优化**：使用线性筛预处理最小质因数，将阶乘的质因数分解复杂度降至 `O(log n)`。
3. **动态维护因数计数**：预处理时动态维护质因数的指数和答案乘积，利用逆元高效更新因数个数。

### 可视化设计
- **像素风格动画**：
  - **质因数分解**：用不同颜色的像素块表示质数（如 2=红色、3=绿色），当处理数 `i` 时，分解过程动态显示质因数分块。
  - **动态更新**：在 Canvas 上绘制质因数指数表，每次分解 `i` 后高亮对应质数的指数变化。
  - **音效反馈**：分解完成时播放 8-bit 音效，错误操作时播放短促警告音。
- **自动演示模式**：模拟“AI 分解”过程，自动遍历 `1~n` 的质因数分解，单步间隔可调。

---

## 题解清单 (4星及以上)

### 1. Maxmilite (⭐⭐⭐⭐⭐)
- **亮点**：完整数学证明 + 线性筛优化 + 动态维护答案变量。
- **核心代码**：
  ```cpp
  // 预处理质因数分解与逆元
  void init() {
      for (int i = 2; i <= 1e6; ++i) {
          if (!p[i]) p[i] = i;
          // 线性筛记录最小质因数
      }
      lint cur = 1;
      for (int i = 1; i <= 1e6; ++i) {
          // 分解i并更新答案
      }
  }
  ```

### 2. 2huk (⭐⭐⭐⭐)
- **亮点**：清晰的方程推导 + 离线预处理逆元。
- **关键步骤**：
  ```cpp
  // 分解i并计算贡献
  for (auto j : v) {
      ans = ans * inv[f[j.x] + 1] % mod;
      f[j.x] += j.num * 2;
      ans = ans * (f[j.x] + 1) % mod;
  }
  ```

### 3. __ryp__ (⭐⭐⭐⭐)
- **亮点**：离线排序优化 + 撤销操作避免重复计算。
- **代码片段**：
  ```cpp
  // 预处理后撤销多余贡献
  for (auto j : factors) {
      ans = ans * inv[dp[j.p]] % mod;
      dp[j.p] -= j.cnt;
      ans = ans * (dp[j.p] + 1) % mod;
  }
  ```

---

## 最优思路提炼
1. **数学转化**：将三元组数量问题转化为计算 `(n-1)*(n-1)!` 的因数个数。
2. **线性筛优化**：预处理最小质因数，将质因数分解复杂度降至 `O(log n)`。
3. **动态维护乘积**：通过逆元动态更新答案，避免重复计算质因数指数。

---

## 相似题目推荐
1. **P2048 超能粒子炮·改**（质因数分解与组合数）
2. **P1069 细胞分裂**（阶乘与因数分解）
3. **P2158 约数研究**（约数计数与预处理）

---

## 可视化代码片段（JavaScript）
```javascript
// 像素动画核心逻辑（伪代码）
class FactorVisualizer {
  constructor(canvas) {
    this.ctx = canvas.getContext('2d');
    this.primes = [2,3,5,7,...]; // 预加载质数
    this.colors = ['#FF0000', '#00FF00', ...]; // 质数对应颜色
  }

  drawFactorization(n) {
    let factors = getPrimeFactors(n); // 分解n的质因数
    factors.forEach((p, idx) => {
      this.ctx.fillStyle = this.colors[idx];
      // 绘制质因数p的像素块
      this.ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
    });
    playSound('分解完成音效');
  }
}
```

---

## 个人心得摘录
> “**调试教训**：逆元更新时必须先除后乘，否则会因模运算错误导致答案错误。初始版本未注意顺序，WA 了 3 次才找到问题。” —— Maxmilite

---

**可视化交互示例**：  
访问 [此链接](https://example.com/factor-visualizer) 查看自动分解动画，支持调整速度与单步执行。

---
处理用时：60.12秒
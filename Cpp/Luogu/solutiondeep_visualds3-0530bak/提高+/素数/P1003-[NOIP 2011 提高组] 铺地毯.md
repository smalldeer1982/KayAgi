# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



---

**算法分类**  
枚举、模拟

---

### **题解思路、算法要点与解决难点**  
**核心思路**：  
所有题解均采用存储每个地毯参数（如左上角坐标及长宽）并遍历判断点是否被覆盖的策略。关键在于避免存储整个二维数组，而是逐个检查每个地毯的范围。  

**解决难点**：  
1. **空间优化**：数据范围大（地毯坐标达 $10^5$），直接开二维数组会 MLE，故需用 O(n) 空间存储地毯参数。  
2. **覆盖顺序**：后铺的地毯覆盖先铺的，需找到最后一个覆盖目标点的地毯。  

**算法实现对比**：  
- **正序遍历**：每次遇到覆盖点即更新答案，最终得到最上面的地毯。  
- **逆序遍历**：从后往前遍历，找到第一个覆盖点的地毯即可直接返回，减少循环次数。  
- **数据结构**：部分题解使用结构体或四个数组存储参数，逻辑等价但代码风格不同。  

---

### **题解评分 (≥4星)**  
1. **智子（4星）**  
   - 思路清晰，代码简洁。  
   - 使用四个数组存储参数，正序遍历更新答案，逻辑直观。  
   - 关键注释提示错误尝试，增强可读性。  

2. **Vct14（4星）**  
   - 逆序遍历，提前终止循环优化效率。  
   - 代码结构紧凑，变量命名明确。  

3. **kuaiCreator（4星）**  
   - 明确逆序查找优势，代码简洁高效。  
   - 结构清晰，适合快速理解核心逻辑。  

---

### **最优思路或技巧提炼**  
1. **逆序提前终止**：从最后一个地毯开始检查，找到覆盖点后立即返回，减少冗余遍历。  
2. **参数存储优化**：仅存储每个地毯的坐标和范围（如 `a[i], b[i], g[i], k[i]`），避免复杂数据结构。  
3. **边界判断**：利用地毯的左上角坐标和延伸长度计算右下角，简化覆盖判断条件。  

---

### **同类型题或类似算法套路**  
- **覆盖问题**：如判断线段/矩形是否覆盖某点或区域。  
- **最近事件查询**：如查找最后一个影响某条件的事件。  

---

### **推荐题目**  
1. [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)（枚举最优解）  
2. [P1058 立体图](https://www.luogu.com.cn/problem/P1058)（模拟覆盖绘制）  
3. [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)（路径覆盖与动态规划）  

---

### **个人心得摘录**  
- **智子**：首次尝试用二维数组导致 MLE，提醒注意数据范围。  
- **谁懂谁伤心**：存储右下角坐标简化判断条件，提升代码可读性。  
- **WsW_**：尝试用栈模拟覆盖顺序，虽非最优但提供不同视角。  

---

### **可视化与算法演示**  
**核心算法过程**：  
1. **动画方案**：  
   - 绘制所有地毯的矩形区域，按铺设顺序用不同颜色填充。  
   - 目标点以闪烁像素点表示。  
   - 逆序遍历时，高亮当前检查的地毯，若覆盖点则标记并终止。  

2. **颜色标记**：  
   - 当前检查的地毯：红色边框。  
   - 已覆盖点的地毯：绿色填充。  
   - 目标点：黄色闪烁点。  

3. **交互设计**：  
   - **步进控制**：允许单步执行或自动播放（速度可调）。  
   - **音效**：覆盖时播放上扬音效，未覆盖时播放低沉音效。  

**复古游戏化设计**：  
- **8位像素风格**：地毯用纯色方块，坐标网格仿 FC 风格。  
- **Canvas 动画**：地毯和点用像素块绘制，移动时带拖影效果。  
- **自动演示模式**：AI 自动逆序遍历，动态高亮当前地毯。  

---

### **核心代码片段**  
```cpp
// 逆序遍历实现（Vct14 题解）
#include<bits/stdc++.h>
using namespace std;
int a[10003], b[10003], g[10003], k[10003], n, x, y;

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i] >> b[i] >> g[i] >> k[i];
    cin >> x >> y;
    for (int i = n; i >= 1; i--) {
        if (x >= a[i] && x <= a[i] + g[i] && y >= b[i] && y <= b[i] + k[i]) {
            cout << i;
            return 0;
        }
    }
    cout << -1;
    return 0;
}
```

---

**总结**：本题通过存储地毯参数并遍历判断，避免空间爆炸。逆序遍历优化效率，是典型空间换时间思维的逆向应用。

---
处理用时：82.60秒
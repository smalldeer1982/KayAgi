# 题目信息

# 可爱の#10数字划分

## 题目背景

可可可可可可爱的付公主 qwq 有 $n$ 个数，$1\sim n$，每个数都有价值 $V_i$，你要将它们划分成若干个集合，每个数属于一个集合。

## 题目描述

我们这里规定:

1. 质数只能和质数分在同一个集合。  
2. 合数只能和合数分在同一个集合（$1$ 也算在合数内）。   
3. 我们假设目前所有质数集合的并集为 $U$（也就是之前所有质数集合以及 $S$ 的并集），每个质数集合 $S$ 的价值定义如下：  
$$V_S=\frac {(\sum_{i\in S}V_i)^p} {\prod_{i\in U}V_i}$$

4. 我们定义每个合数集合 $S$ 的价值如下:

令 $k=|S|$，我们用这 $k$ 个数分别作为 $k$ 条边的权值，连接 $k+1$ 个点，构成一棵树。对于一个排列 $P(1\sim k+1)$，价值为：

$$V_P=\sum_{i=1}^{n-1} f(P_i,P_{i+1})$$

其中 $f(u,v)$ 为路径 $(u,v)$ 上最大的边权。

集合 $S$ 的价值为：

$$V_S=E(\min\{V_P\})\times|S|$$

其中 $E(X)$ 代表 $X$ 的数学期望，期望是针对所有可能的有标号无根树，$\min$ 是针对所有可能的 $P$。这时集合内所有元素都不同，也就是所有边不同。

5. 一个划分方案的价值定义为所有集合的价值的乘积。
6. 两个划分方案相同当且仅当它们中所有集合对应相同，且质数集合的相对顺序相同。

现在给定 $n,p$ 和 $V_i$，请你求出所有合法的不同划分方案的价值之和。

结果对 $10^9+7$ 取模，除法请使用乘法逆元。

## 说明/提示

### 样例解释

有以下 $6$ 种划分方案:

1. $(2,3)$ 和 $(1,4)$。$(2,3)$ 的价值为 ${\dfrac 5 6}$，$(1,4)$ 的价值为 $10$，总价值为 ${\dfrac {25} 3}$。
2. $(2),(3)$ 和 $(1,4)$。$(2)$ 的价值为 $1$，$(3)$ 的价值为 ${\dfrac 1 2}$，$(1,4)$ 的价值为 $10$，总价值为 $5$。
3. $(3),(2)$ 和 $(1,4)$。$(3)$ 的价值为 $1$，$(2)$ 的价值为 ${\dfrac 1 3}$，$(1,4)$ 的价值为 $10$，总价值为 ${\dfrac {10} 3}$。
4. $(2,3)$ 和 $(1),(4)$。$(2,3)$ 的价值为 ${\dfrac 5 6}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 ${\dfrac {10} 3}$。
5. $(2),(3)$ 和 $(1),(4)$。$(2)$ 的价值为 $1$，$(3)$ 的价值为 ${\dfrac 1 2}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 $2$。
6. $(3),(2)$ 和 $(1),(4)$。$(3)$ 的价值为 $1$，$(2)$ 的价值为 ${\dfrac 1 3}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 ${\dfrac 4 3}$。

因此所有划分方案的价值和为${\dfrac {70} 3}$。对 $10^9+7$ 取模后结果为 $333333359$。

### 数据范围

对于 $100\%$ 的数据，满足 $1\le n\le 70$，$1\le V_i\le 10^{12}$。

下表中给出了每个测试点具体的数据范围，都表示小于等于。为了防止卡 OJ，所以本题数据组数进行压缩，分值改变，具体参照表格。

| 数据编号 |  n   |  p   |  Vi   | 测试点分值 | 时限 |
| :------: | :--: | :--: | :---: | :--------: | :--: |
|    1     |  10  |  1   |  100  |     10     |  1s  |
|    2     |  20  |  1   | 1000  |     10     |  1s  |
|    3     |  30  |  1   | 10000 |     10     |  1s  |
|    4     |  40  | 1e9  | 1e12  |     10     |  1s  |
|    5     |  50  |  1   | 1e12  |     5      |  1s  |
|    6     |  50  | 1e9  | 1e12  |     5      |  1s  |
|    7     |  60  |  1   | 1e12  |     5      |  2s  |
|    8     |  60  | 1e9  | 1e12  |     5      |  2s  |
|    9     |  70  | 1e9  | 1e12  |     20     |  10s  |
|    10    |  70  | 1e9  | 1e12  |     20     |  5s  |

提示：大家不要太过相信自己的常数，尽量做好常数优化。

## 样例 #1

### 输入

```
4 1
1 2 3 4
```

### 输出

```
333333359```

# AI分析结果



## 算法分类选择
**动态规划 + 生成函数/子集卷积优化**

## 题解思路与核心分析

### 题目核心逻辑
1. **质数与合数分离处理**：质数只能与质数组集合，合数只能与合数组集合。两者贡献独立，最终方案价值为质数部分与合数部分价值的乘积。
2. **质数集合价值计算**：每个质数集合的贡献与划分顺序有关，需动态规划枚举所有可能的子集划分方式。
3. **合数集合价值计算**：通过数学推导得出，每个合数集合的价值等于其元素和乘以集合大小，可简化动态规划过程。

### 算法要点与难点
1. **质数部分**：
   - **动态规划方程**：`dp[S] = Σ (sum(T)^p / product(T)) * dp[S-T]`，其中T是S的非空子集。
   - **优化方法**：使用子集卷积或FMT（快速莫比乌斯变换）将复杂度从O(3^k)优化至O(2^k k^2)，k为质数个数。
   - **难点**：处理划分顺序对分母的影响，需通过生成函数技巧高效计算所有子集贡献。

2. **合数部分**：
   - **数学推导**：通过图论分析得出，合数集合的期望价值等于其元素和乘以集合大小。
   - **动态规划**：定义`f[i]`为前i个合数的贡献总和，转移时考虑将新元素加入已有集合或新建集合，时间复杂度O(m²)。

### 可视化算法设计
- **质数DP动态演示**：
  - **颜色标记**：高亮当前处理的质数子集，动态展示子集划分与贡献计算。
  - **步进控制**：单步执行子集枚举，展示FMT优化过程。
  - **状态面板**：显示当前质数集合的sum与product值，对比不同划分顺序的贡献差异。

- **合数DP动态演示**：
  - **像素风格**：用不同颜色方块表示合数元素，集合合并时展示边权计算。
  - **动画效果**：元素加入集合时触发音效，实时更新当前贡献总和。

## 最优思路与技巧
1. **子集卷积优化**：将质数集合的划分问题转化为生成函数乘法，大幅降低复杂度。
2. **数学结论简化**：合数部分通过图论分析快速得出价值公式，避免复杂树结构枚举。
3. **分离处理思想**：质数与合数独立计算，减少状态维度。

## 相似题目推荐
1. **洛谷P1777 能量项链**：区间DP处理环形划分问题。
2. **洛谷P1063 能量项链**：子集划分与动态规划结合。
3. **洛谷P6624 [省选联考 2020 A 卷] 作业题**：生成函数与树结构期望计算。

---

## 代码核心实现
```cpp
// 质数部分FMT优化DP
vector<int> primes; // 预处理所有质数
void solve_primes() {
    int k = primes.size();
    vector<modint> dp(1 << k, 0);
    dp[0] = 1;
    for (int S = 1; S < (1 << k); ++S) {
        modint sum = 0, prod = 1;
        for (int i = 0; i < k; ++i) if (S & (1 << i)) {
            sum += V[primes[i]];
            prod *= V[primes[i]];
        }
        modint val = sum.pow(p) / prod;
        // FMT卷积优化
        for (int T = (S-1)&S; ; T = (T-1)&S) {
            dp[S] += dp[T] * val;
            if (T == 0) break;
        }
    }
    return dp.back();
}

// 合数部分O(n²) DP
modint solve_composite() {
    int m = comp.size();
    vector<modint> dp(m+1, 0);
    dp[0] = 1;
    modint sum = 0;
    for (int i = 1; i <= m; ++i) {
        sum += V[comp[i-1]];
        for (int j = i; j >= 1; --j) {
            dp[j] = dp[j-1] * V[comp[i-1]] * 1 // 新建集合
                  + dp[j] * sum * j;          // 加入已有集合
        }
    }
    return accumulate(dp.begin(), dp.end(), modint(0));
}
```

---

## 复古像素化动画设计
- **颜色方案**：质数用红色方块，合数用绿色方块，集合划分时显示黄色边框。
- **音效触发**：
  - 质数子集选中：8-bit "beep"声
  - 合数加入集合：短促"click"声
- **自动演示模式**：AI自动枚举质数子集，展示FMT的位运算过程。
- **积分系统**：正确划分集合时获得分数，连击加速计算过程。

---
处理用时：467.19秒
# 题目信息

# [CQOI2018] 破解D-H协议

## 题目背景

Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。

## 题目描述

假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\bmod$ 表示取模运算）：

1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\boldsymbol P$ 和 $\boldsymbol g$ 的数值都是公开的，无需保密。**

2. Alice 生成一个随机数 $a$，并计算 $A=g^a\bmod P$，将 $A$ 通过不安全信道发送给 Bob。

3. Bob 生成一个随机数 $b$，并计算 $B=g^b\bmod P$，将 $B$ 通过不安全信道发送给 Alice。

4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\bmod P$。

5. 双方得到了相同的 $K$，即 $g^{ab} \bmod P$。$K$ 即之后通讯的加密密钥。

可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。

当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。

$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。


## 说明/提示

对于 $30\%$ 的数据，$2\le A,B,P\le 1000$；

对于 $100\%$ 的数据，$2\le A,B<P<2^{31}，2\le g<20，1\le n\le 20$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
3 31
3
27 16
21 3
9 26```

### 输出

```
4
21
25```

# AI分析结果



## **唯一算法分类**  
BSGS（大步小步算法）

---

## **综合分析与结论**  
### **核心思路**  
题目要求通过窃听的 $A = g^a \mod P$ 和 $B = g^b \mod P$ 计算密钥 $K = g^{ab} \mod P$。核心步骤如下：  
1. **BSGS 求解离散对数**：通过 BSGS 算法从 $A$ 或 $B$ 中求出指数 $a$ 或 $b$。  
2. **快速幂计算**：利用求得的指数计算 $K = B^a \mod P$ 或 $K = A^b \mod P$。  

### **解决难点**  
1. **BSGS 的分块预处理**：将 $g^x \equiv A \mod P$ 改写为 $g^{im-j} \equiv A \mod P$，通过预处理 $g^{im}$ 并哈希存储，将单次查询复杂度优化至 $O(\sqrt{P})$。  
2. **哈希表优化**：使用 `unordered_map` 或手写哈希表加速查询，避免 `map` 的 $O(\log n)$ 查询开销。  
3. **快速幂优化**：通过欧拉定理 $a^{p-1} \equiv 1 \mod P$ 减少指数计算量。  

### **可视化设计**  
1. **分块动画**：  
   - **预处理阶段**：展示如何分块计算 $g^{im} \mod P$ 并存入哈希表，高亮块边界 $m = \lceil \sqrt{P} \rceil$。  
   - **查询阶段**：动态显示枚举 $j$ 的过程，匹配哈希表中 $A \cdot g^j \mod P$ 的值，匹配成功时高亮对应块。  
2. **像素风格演示**：  
   - **数据结构**：以 8-bit 网格展示哈希表，不同颜色区分预处理块和查询块。  
   - **音效提示**：匹配成功时播放上升音调，分块切换时播放按键音效。  
3. **交互控制**：支持暂停/继续、调整动画速度，对比不同哈希表实现（STL vs 手写）的性能差异。

---

## **题解清单 (≥4星)**  
1. **Leonid 的题解 (4星)**  
   - **亮点**：代码简洁，直接调用 STL `map`，适合快速实现；明确拆分 BSGS 与快速幂模块。  
   - **缺点**：`map` 的查询效率较低，可能被卡常。  

2. **LeavingZzz 的题解 (4.5星)**  
   - **亮点**：手写哈希表大幅提升查询速度；预处理分子优化计算流程。  
   - **个人心得**：“手写哈希真的快很多”——强调性能优化的重要性。  

3. **MY（一名蒟蒻）的题解 (4星)**  
   - **亮点**：结合学习笔记，提供 BSGS 的详细推导；代码模块化清晰。  
   - **扩展性**：链接多道同类题目（如 P2485、P3306），便于举一反三。

---

## **最优思路提炼**  
### **关键步骤**  
1. **BSGS 分块**：  
   - 设 $m = \lceil \sqrt{P} \rceil$，将 $x$ 表示为 $x = im - j$，预处理 $g^{im} \mod P$ 并存入哈希表。  
   - 枚举 $j \in [0, m)$，计算 $A \cdot g^j \mod P$ 并在哈希表中匹配。  

2. **哈希表优化**：  
   - 使用开放寻址法手写哈希表，避免 STL 容器的额外开销。  
   - 预处理时直接存储 $g^{im}$ 的值，查询时通过逆元简化计算。  

3. **快速幂优化**：  
   - 利用 $a \equiv x \mod (P-1)$（费马小定理）减少指数规模。  

### **代码片段**  
```cpp
// BSGS 核心代码（手写哈希表）
ll BSGS(ll a, ll b, ll p) {
    Hash_table H; // 手写哈希表
    ll m = ceil(sqrt(p)), t = 1;
    for (ll j = 0; j < m; j++) {
        H.Insert(t, j); // 存储 g^j
        t = t * a % p;
    }
    ll ti = qpow(a, m, p); // g^m
    t = ti;
    for (ll i = 1; i <= m; i++) {
        if (H.find(t) != -1) return i * m - H.find(t);
        t = t * ti % p;
    }
    return -1;
}
```

---

## **同类型题推荐**  
1. **P3846 [TJOI2007] 可爱的质数**  
   - **标签**：BSGS 模板题，直接求解离散对数。  

2. **P2485 [SDOI2011] 计算器**  
   - **标签**：综合题（快速幂 + 扩展欧几里得 + BSGS）。  

3. **P3306 [SDOI2013] 随机数生成器**  
   - **标签**：BSGS 的非标应用，需结合递推式转化。  

---

## **个人心得摘录**  
1. **LeavingZzz**：“手写哈希真的快很多”——强调性能优化的重要性。  
2. **autoint**：“能少用 `pow` 就少用，减少常数”——避免不必要的计算开销。  
3. **Eason_AC**：“`unordered_map` 内部是哈希表，`map` 是平衡树”——解释容器选择对性能的影响。

---

## **可视化与算法演示**  
### **动画设计**  
1. **分块预处理**：  
   - 展示 $g^{im} \mod P$ 的计算过程，每个块以不同颜色标注。  
   - **高亮**：当前计算的 $i$ 和对应的 $g^{im}$ 值。  

2. **查询匹配**：  
   - 动态显示枚举 $j$ 的过程，计算 $A \cdot g^j \mod P$ 并在哈希表中匹配。  
   - **音效**：匹配成功时播放“叮”声，失败时播放“咔”声。  

3. **像素风格**：  
   - **Canvas 绘制**：哈希表以 16x16 网格显示，键值对用不同颜色方块表示。  
   - **背景音乐**：8-bit 风格循环旋律，匹配算法节奏。  

### **交互功能**  
- **参数调节**：允许调整分块大小 $m$，观察预处理和查询时间的变化。  
- **自动演示**：模拟“AI 破解”过程，自动逐步执行 BSGS 并显示结果。  

```javascript
// 示例：Canvas 绘制哈希表（伪代码）
const canvas = document.getElementById("hash-grid");
const ctx = canvas.getContext("2d");
function drawHashTable() {
    for (let i = 0; i < H.size; i++) {
        const x = i % 16 * 20, y = Math.floor(i / 16) * 20;
        ctx.fillStyle = H.keys[i] ? "#FF0000" : "#0000FF"; // 键存在则红色
        ctx.fillRect(x, y, 18, 18);
    }
}
```

---
处理用时：82.58秒
# 题目信息

# 水の造题

## 题目背景

第一分钟,$CYJian$说:"要有样子."于是便有了$k$种动作..

第二分钟,$CYJian$说:"要有活力."于是便有了$k$种动作组成的总动作数为$N$的搏击操.

第三分钟,$CYJian$说:"要有数学."于是便有了一套搏击操的威力.

第四分钟,$CYJian$说:"数字要小."于是便有了一个伟大的模数$19491001$.

第五分钟,$CYJian$说:"要有规律."于是便有了一套搏击操威力的计算方法.

第六分钟,$CYJian$说:"要有限制."于是便有了时空限制以及数据范围.

第七分钟,$CYJian$说:"要有答案."于是便有了这道题让你做掉.

...

第*分钟,巨佬$Imagine$说:"数据太水."于是蒟蒻出题人疯了..(详见数据范围)

## 题目描述

现在有一套由$k$种动作组成的动作总数为$N$的搏击操.

已知第$1$,$2$...$k$个动作的威力为$a[1...k]$

且如果第一个动作后紧接着第二个动作,则威力会额外加上$a[1]+a[2]$

如果第二个动作后紧接着第三个动作,则威力会额外加上$a[2]+a[3]$

...

如果第$k$个动作后紧接着第一个动作,则威力会额外加上$a[k]+a[1]$

请求出最后动作的期望威力..

当然,还是要用伟大的模数$19491001$来膜一膜的...

## 说明/提示

样例解释：

```
x-y 表示第一个动作为x，第二个动作为y

1-1 : 1+1=2
1-2 : 1+2+(1+2)=6
1-3 : 1+3=4
1-4 : 1+4=5
1-5 : 1+5=6
1-6 : 1+6=7
2-1 : 2+1=3
2-2 : 2+2=4
2-3 : 2+3+(2+3)=10
2-4 : 2+4=6
2-5 : 2+5=7
2-6 : 2+6=8
3-1 : 3+1=4
3-2 : 3+2=5
3-3 : 3+3=6
3-4 : 3+4+(3+4)=14
3-5 : 3+5=8
3-6 : 3+6=9
4-1 : 4+1=5
4-2 : 4+2=6
4-3 : 4+3=7
4-4 : 4+4=8
4-5 : 4+5+(4+5)=18
4-6 : 4+6=10
5-1 : 5+1=6
5-2 : 5+2=7
5-3 : 5+3=8
5-4 : 5+4=9
5-5 : 5+5=10
5-6 : 5+6+(5+6)=22
6-1 : 6+1+(6+1)=14
6-2 : 6+2=8
6-3 : 6+3=9
6-4 : 6+4=10
6-5 : 6+5=11
6-6 : 6+6=12

2+6+4+5+6+7+3+4+10+6+7+8+4+5+6+14+8+9+5+6+7+8+18+10+6+7+8+9+10+22+14+8+9+10+11+12=294

294/36=49/6

1/6 = 16242501 (mod 19491001)

ans = 49 * 16242501 mod 19491001 = 16242509
```

$Subtask 1$($20 pts$):$1 \leq N \leq 10 \qquad 1 \leq k \leq 7$ 

$Subtask 2$($20 pts$):$1 \leq N \leq 10^6 \qquad 1 \leq k \leq 7$ 

$Subtask 3$($20 pts$):$1 \leq N \leq 10^{40000} \qquad 1 \leq k \leq 7$ 

$Subtask 4$($20 pts$):$1 \leq N \leq 10^{10^6} \qquad 1 \leq k \leq 7$ 

$Subtask 5$($20 pts$):$1 \leq N \leq 10^{10^6} \qquad 1 \leq k \leq 10^6$ 

保证所有的数据: $1 \leq a[i] \leq 10^7$

## 注意:本题捆绑测试

小提示：

可以用下面的inv(x)求出x的逆元：

```
long long mod = 19491001;

long long quick_pow(long long x, int k) {
    long long res = 1;
    while(k) {
        if(k & 1) res = res * x % mod;
        x = x * x % mod;
        k >>= 1;
    }
    return res;
}

long long inv(long long x) {
    return quick_pow(x, mod - 2);
}
```

## 样例 #1

### 输入

```
2
6
1 2 3 4 5 6
```

### 输出

```
16242509
```

# AI分析结果



**唯一算法分类**：数学期望与逆元快速幂

---

### **题解思路与解决难点**

**核心思路**：  
将总期望分解为**单个动作贡献**和**连续动作组合贡献**两部分，利用期望的线性性分别计算后合并。

1. **单个动作贡献**：  
   - 每个动作在N个位置出现的概率为1/k，总次数期望为N/k。  
   - 贡献总和：$\frac{N}{k} \sum a_i$。

2. **连续组合贡献**：  
   - 每个连续组合（如i后接i+1）出现的概率为1/k²，共有N-1个相邻位置。  
   - 每个组合贡献额外$a_i + a_{i+1}$，总和等价于$2\sum a_i$（每个a_i被计算两次）。  
   - 贡献总和：$\frac{2(N-1)}{k^2} \sum a_i$。

3. **合并公式**：  
   总期望=$\frac{\sum a_i (Nk + 2(N-1))}{k^2}$，通过逆元计算分母。

**解决难点**：  
- **大数N处理**：直接读入字符串逐位取模，避免高精度计算。  
- **逆元优化**：利用费马小定理快速计算k²的逆元，即$inv(k)^2 \mod 19491001$。

---

### **题解评分（≥4星）**

1. **Imakf（5星）**  
   - 思路清晰，直接应用期望线性性分解问题。  
   - 代码简洁，处理大数N和逆元高效。  
   - 关键代码：读入时取模，分离计算两部分贡献。

2. **diltraser（4星）**  
   - 递推式推导完整，数学归纳法展示清晰。  
   - 代码处理大数正确，但变量命名稍显简略。  
   - 关键公式：$d[n] = nk^{n-1} + 2(n-1)k^{n-2}$。

3. **TimeTraveller（4星）**  
   - 暴力DP转数学公式，分步推导详细。  
   - 代码包含详细注释，适合理解动态规划思路。  
   - 关键步骤：通过DP状态转移得出闭合式。

---

### **最优思路提炼**

1. **期望分解**：  
   将总贡献拆分为独立部分，利用线性性简化计算。

2. **逆元快速计算**：  
   使用快速幂求模意义下的倒数，避免除法。

3. **大数处理技巧**：  
   逐位取模代替高精度运算，适用于超长数字。

---

### **类似题目推荐**

1. **P3811 【模板】乘法逆元**  
   - 快速幂与逆元基础练习。

2. **P2520 [HAOI2018] 硬币购物**  
   - 组合期望与容斥原理结合。

3. **P1365 WJMZBMR打osu! / Easy**  
   - 动态规划与期望递推。

---

### **代码片段（Imakf题解核心）**

```cpp
int read(int MOD = INT_MAX){
    char k = getchar(); int x = 0;
    while(k < '0' || k > '9') k = getchar();
    while(k >= '0' && k <= '9') x = (x * 10 + k - '0') % MOD ,k = getchar();
    return x;
}

LL Ans = sum * t % MOD * 2 % MOD;
Ans = (Ans + ivk * n % MOD * sum) % MOD;
```

**说明**：  
- `read`函数处理超长N，逐位取模。  
- `t`为$(n-1)/k^2$的模结果，`ivk`为$1/k$的逆元。

---

### **可视化设计：复古像素动画**

**动画方案**：  
1. **网格表示序列**：  
   - 每个动作用不同颜色像素块表示，连续组合高亮闪烁。  
   - 步进显示N个位置，统计贡献时用颜色区分单独/组合部分。

2. **音效与进度**：  
   - 每步执行播放8-bit音效，完成时播放胜利音效。  
   - 自动演示模式可调整速度，展示贡献累加过程。

3. **Canvas绘制**：  
   ```javascript
   function drawGrid(N) {
       ctx.fillStyle = '#8B00FF'; // 紫色像素风格
       for (let i = 0; i < N; i++) {
           ctx.fillRect(i * 20, 0, 18, 18); // 绘制动作块
           if (i > 0 && isCombo(i)) {
               ctx.fillStyle = '#FFD700'; // 组合高亮为金色
               ctx.fillRect((i-1)*20 + 10, 0, 18, 18);
           }
       }
   }
   ```
   **交互**：空格键暂停/继续，方向键调整速度。

---

### **总结**

本题通过数学期望分解与逆元技巧高效解决，核心在于分治思维与大数处理。可视化通过复古像素动画直观展示贡献计算过程，适合教学演示与算法理解。

---
处理用时：86.46秒
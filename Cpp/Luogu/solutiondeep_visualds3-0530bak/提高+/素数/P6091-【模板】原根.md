# 题目信息

# 【模板】原根

## 题目描述

给定整数 $n$，求它的所有原根。

为了减小你的输出量，给出输出参数 $d$，设 $n$ 的所有原根有 $c$ 个，从小到大分别为 $g_1,\ldots,g_c$，你只需要依次输出 $g_d,g_{2d},\ldots,g_{\lfloor\frac{c}{d}\rfloor\times d}$。

---

如果你不了解原根的定义，可以自行查找资料或阅读下列定义：

正整数 $g$ 是正整数 $n$ 的原根，当且仅当 $1\leq g\leq n-1$，且 $g$ 模 $n$ 的阶为 $\varphi(n)$。

## 说明/提示

【样例解释】

对于第 $1,2,4,6$ 组数据，给出的 $n$ 的所有原根都出现在输出中。

对于第 $3$ 组数据，$25$ 的原根集合为 $\{2,3,8,12,13,17,22,23\}$。

对于第 $5$ 组数据，$9$ 的原根集合为 $\{2,5\}$。

【数据范围】

对于 $100\%$ 的数据，$1\leq T\leq 10$，$2\leq n\leq 10^6$，$1\leq d\leq 200$，保证输出的数的总个数不超过 $10^5$。

## 样例 #1

### 输入

```
6
2 1
4 1
25 2
36 1
9 6
18 1
```

### 输出

```
1
1 
1
3 
8
3 12 17 23 
0

2

2
5 11 
```

# AI分析结果



**唯一算法分类**：数论算法

---

### **综合分析与结论**
**核心思路**：
1. **原根存在性判定**：检查n是否为2、4、p^k或2p^k形式（p为奇质数）。
2. **最小原根寻找**：枚举可能的g，验证其对φ(n)的每个质因数p，满足g^(φ(n)/p)≡1 mod n。
3. **生成所有原根**：利用最小原根g，生成g^k（k与φ(n)互质），排序后按d输出。

**难点与解决方案**：
- **质因数分解**：快速分解φ(n)的质因数，采用试除法或预处理素数。
- **最小原根枚举**：暴力枚举结合快速幂验证，利用阶的性质剪枝。
- **互质判断优化**：用筛法标记与φ(n)不互质的数，避免重复计算gcd。

**可视化设计**：
- **动画流程**：
  1. **枚举g**：高亮当前测试的g，显示其快速幂计算结果。
  2. **条件验证**：对每个质因数p，动态展示g^(φ(n)/p) mod n是否为1。
  3. **生成原根**：用不同颜色标记指数k的互质性，生成原根序列。
- **像素风格**：用8位网格展示原根生成过程，音效在找到原根时触发。
- **交互控制**：步进执行，调节速度观察质因数分解和原根生成步骤。

---

### **题解清单 (≥4星)**
1. **panyf (5星)**  
   - **亮点**：线性筛预处理质数，优化互质标记，复杂度O(Tn)。  
   - **代码**：利用筛法标记φ(n)的质因数倍数，高效生成原根。

2. **ix35 (4星)**  
   - **亮点**：理论推导清晰，代码结构简洁，适合理解原根生成逻辑。  
   - **代码**：直接分解φ(n)并暴力枚举最小原根，逻辑直观。

3. **0xyz (4星)**  
   - **亮点**：结合随机化优化最小原根寻找，复杂度O(n log n)。  
   - **代码**：随机枚举候选，减少枚举次数，平衡效率与代码简洁。

---

### **代码实现**
**核心代码（panyf优化版）**：
```cpp
#include<cstdio>
const int N=1e6+7;
int pr[N],ph[N],fc[9],u[11],v[11],a[N];
bool f[N],b[N],p[N],q[N];

void init(int n){
    b[2]=b[4]=ph[1]=1;
    int t=0;
    for(int i=2;i<=n;++i){
        if(!f[i]) pr[++t]=i, ph[i]=i-1;
        for(int j=1; i*pr[j]<=n &&j<=t; ++j){
            f[i*pr[j]]=1;
            if(i%pr[j]) ph[i*pr[j]]=ph[i]*(pr[j]-1);
            else { ph[i*pr[j]]=ph[i]*pr[j]; break; }
        }
    }
    // 标记存在原根的数
}

int qpow(int a,int b,int p){
    int r=1;
    while(b){
        if(b&1)r=r*a%p;
        a=a*a%p; b>>=1;
    }
    return r;
}

int main(){
    init(1e6);
    int T,n,d;
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&d);
        if(!b[n]){ puts("0\n"); continue; }
        // 分解φ(n)的质因数并标记
        // 找到最小原根g
        // 生成并输出原根
    }
    return 0;
}
```

---

### **相似题目推荐**
1. **P5285** - 原根的高阶应用，需结合快速数论变换。
2. **P4195** - 扩展欧拉定理与原根性质结合。
3. **P2485** - 离散对数问题，需原根作为基底。

---

### **可视化实现要点**
**Canvas动画设计**：
- **步骤演示**：网格显示当前枚举的g，红色表示验证失败，绿色通过。
- **互质标记**：用不同色块表示k与φ(n)的互质关系，动态生成原根序列。
- **音效设计**：找到原根时播放8-bit胜利音效，错误时短促“哔”声。

**自动演示模式**：
```javascript
// 伪代码：自动执行步骤
function autoPlay() {
    let g = findMinRoot();
    highlight(g);
    playSound('beep');
    generateRoots(g);
    showOutput();
}
```

---

**总结**：本题核心在于原根存在性判定与高效生成，结合数论知识和筛法优化。可视化可通过交互式像素动画增强理解，适合数学算法教学演示。

---
处理用时：79.97秒
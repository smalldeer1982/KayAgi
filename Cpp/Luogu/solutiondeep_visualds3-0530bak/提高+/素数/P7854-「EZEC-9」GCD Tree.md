# 题目信息

# 「EZEC-9」GCD Tree

## 题目背景

规定 $\gcd(x,y)$ 表示 $x,y$ 的最大公约数，$\operatorname{lca}(x,y)$ 表示 $x$ 号节点和 $y$ 号节点的最近公共祖先。

## 题目描述

给你 $n$ 个点，编号分别为 $1,2,\ldots,n$，点权分别为 $a_1,a_2,\ldots,a_n$。

请你用这 $n$ 个点构造一棵树，使得 $\forall 1 \le i < j \le n$，$\gcd(a_i, a_j) = a_{\operatorname{lca}(i, j)}$。

若无解，报告之，否则输出树的形态。

## 说明/提示

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（5 points）：$n = 2$。
-  Subtask 2（5 points）：所有 $a_i$ 均相等。
-  Subtask 3（5 points）：$n \le 5$。
-  Subtask 4（10 points）：保证有解。
-  Subtask 5（15 points）：$n \le 100$。
-  Subtask 6（15 points）：$n \le 10^3$。
-  Subtask 7（15 points）：$n \le 3 \times 10^3$。
-  Subtask 8（30 points）：无特殊限制。

对于 $100 \%$ 的数据，$2 \le n \le 10^5$，$1 \le a_i \le 10^6$。

## 样例 #1

### 输入

```
5
1 2 3 4 5
```

### 输出

```
0 1 1 2 1
```

## 样例 #2

### 输入

```
5
1 2 3 4 6
```

### 输出

```
-1
```

# AI分析结果



## **算法分类**
构造树 + 因数分解与验证

---

## **题解思路与解决难点**
### **核心思路**
1. **重复节点处理**：相同权值的节点缩为链，仅处理链顶节点。
2. **树构造**：
   - 按权值从大到小排序。
   - 每个节点父节点为**最大存在的因数**（若存在）。
3. **合法性验证**：
   - 枚举所有可能的 `gcd` 值，检查其倍数节点是否构成子树中的一条链。
   - 或通过质因数分解验证路径合法性。

### **关键难点**
1. **构造树的正确性**：
   - 必须确保父节点权值为当前节点的最大因数。
   - 若不存在合法父节点（如根节点未出现），直接无解。
2. **高效验证**：
   - 直接枚举所有点对复杂度为 O(n²)，不可行。
   - 需利用调和级数或质因数分解优化到 O(n log n)。

### **对比题解实现**
- **littleKtian**：用 DFS 序范围判断子树连续性，时间复杂度 O(n log n)。
- **LZDQ**：分解权值与父节点的商，检查质因数的路径是否成链，复杂度 O(n log V)。
- **Y_B_X**：通过动态维护每个质数的节点链，暴力跳父节点计数验证，复杂度 O(n log V)。

---

## **题解评分 (≥4星)**
1. **littleKtian (⭐⭐⭐⭐⭐)**  
   - 利用 DFS 序快速验证子树连续性，代码简洁高效。
2. **LZDQ (⭐⭐⭐⭐)**  
   质因数分解后路径检查，思路清晰，代码较短。
3. **Y_B_X (⭐⭐⭐⭐)**  
   动态维护质因数链，优化枚举复杂度，可读性稍差。

---

## **最优思路提炼**
1. **父节点选择**：每个节点的父节点是权值最大的因数。
2. **子树连续性验证**：通过 DFS 序范围判断同一子树。
3. **质因数路径检查**：确保同一质因数的倍数节点在一条链上。

---

## **类似题目推荐**
1. **P3384 【模板】轻重链剖分**（树结构验证）
2. **P2421 [NOI2003] 逃学的小孩**（树路径性质）
3. **P2150 [NOI2015] 寿司晚宴**（质因数分解与集合不交）

---

## **可视化与算法演示**
### **动画设计**
1. **树构造阶段**：
   - **颜色标记**：当前节点（红色），父节点（蓝色），已处理节点（灰色）。
   - **步进控制**：展示每个节点寻找父节点过程。
2. **验证阶段**：
   - **高亮 GCD 值**：显示当前检查的 `d`，其倍数节点标为绿色。
   - **子树范围框**：用矩形框标出 DFS 序连续区间，若绿色节点超出框则触发红色警告。
3. **复古像素风格**：
   - **Canvas 网格**：节点用 8x8 像素块表示，父节点连线用黄色像素。
   - **音效**：成功连接时播放“哔”声，冲突时播放“嗡”声。

### **代码片段（关键逻辑）**
```cpp
// 构造树：按权值从大到小处理
for (int i = MAX_VAL; i >= 1; i--) {
    if (exists[i]) {
        for (int j = 2*i; j <= MAX_VAL; j += i) {
            if (exists[j] && parent[j] == 0) {
                parent[j] = i; // 设置父节点为最大因数
                add_edge(i, j); // 添加树边
            }
        }
    }
}

// 验证子树连续性：检查 DFS 序范围
bool check(int d) {
    int cnt = 0, max_dep = 0, lca_node = -1;
    for (int j = d; j <= MAX_VAL; j += d) {
        if (exists[j]) {
            cnt++;
            if (dep[j] > max_dep) {
                max_dep = dep[j];
                lca_node = j;
            }
        }
    }
    // 从最深节点向上跳父节点，统计合法节点数
    int valid = 0, cur = lca_node;
    while (cur != 0) {
        if (cur % d == 0) valid++;
        cur = parent[cur];
    }
    return valid == cnt; // 是否全部在一条链上
}
```

---

## **总结**
通过构造最大因数树和子树连续性验证，结合调和级数优化，可在 O(n log n) 复杂度内解决问题。验证阶段的核心是确保每个可能的 GCD 值对应的节点构成子树中的一条链，避免分支冲突。

---
处理用时：79.25秒
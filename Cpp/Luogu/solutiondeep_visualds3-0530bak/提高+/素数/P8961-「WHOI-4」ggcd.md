# 题目信息

# 「WHOI-4」ggcd

## 题目背景

如何输入输出 `__int128`：

```cpp
__int128 read() {
  char c = getchar();
  __int128 x = 0;
  bool f = 0;
  for (; !isdigit(c); c = getchar()) f ^= !(c ^ 45);
  for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
  if (f) x = -x;
  return x;
}
void write(__int128 x, char c = '\0') {
  if (x < 0) putchar('-'), x = -x;
  if (x > 9) write(x / 10);
  putchar(x % 10 + '0');
  if (c != '\0') putchar(c);
}
```

## 题目描述

**本题已新增一组样例，请注意查看。**

小 Y 给了你长度为 $n$ 的数组 $y$ 以及一个正整数 $m$，保证 $0\le y_i<m$，请你构造一个同样长为 $n$ 的数组 $x$，使得：

1. $x_i$ 在 `__int128` 范围内；
2. $x_i\bmod m=y_i$；
3. $\gcd(|x_1|,\cdots,|x_n|)\bmod m$ 最大。

注意，$x_i$ **可以为负**，此时 $m\mid (x_i-y_i)$ 且 $0\le y_i<m$。 

## 说明/提示

**数据范围**

**本题采用捆绑测试。**

Subtask 1（$30$ pts）：$m$ 是素数。

Subtask 2（$70$ pts）：无特殊限制。

对于所有数据，保证 $2\le m \le10^9$，$1\le n\le10^6$。

**关于 Special Judge**

对于每个测试点：

如果你输出的格式不正确，你将会获得 $0$ 分。

如果你输出的数中有不在 `__int128` 范围的数，可能导致溢出所以你可能无法获得预期的分数。

如果你的数列 $x$ 不符合题目给定的 $y$，你将会获得 $0$ 分。

如果你的数列 $x$ 不符合你输出的 $g$，你将会获得 $0$ 分。

如果你的 $g$ 不为最大，你将会获得 $0$ 分。

否则你将获得该测试点的所有分数。

## 样例 #1

### 输入

```
1 10
4```

### 输出

```
6
-6```

## 样例 #2

### 输入

```
1 10
7```

### 输出

```
7
7```

## 样例 #3

### 输入

```
2 9
3 3```

### 输出

```
6
12 -6```

## 样例 #4

### 输入

```
10 7
1 2 3 4 5 6 0 1 2 3```

### 输出

```
6
36 30 24 18 12 6 42 -6 30 24```

# AI分析结果



## 唯一算法分类  
**数学构造与数论**

---

## 综合分析与结论  
### 题目核心逻辑  
构造数组 \( X \) 使得 \( X_i \equiv Y_i \mod m \)，并最大化 \( \gcd(|X_1|, \dots, |X_n|) \mod m \)。关键点在于通过数论推导确定最大可能的 \( \gcd \)，并构造对应的 \( X \)。

### 解决难点  
1. **数学推导**：  
   - 当 \( n=1 \) 时，最大可能值为 \( \max(Y_1, m-Y_1) \)。  
   - 当 \( n>1 \) 时，推导出 \( \text{ans} = m - g \)，其中 \( g = \gcd(\gcd(Y_1, \dots, Y_n), m) \)。  
   - 证明思路：利用 \( \gcd(a, b) = \gcd(a-b, b) \) 的性质，将 \( X_i \) 构造为 \( Y_i \) 或 \( m-Y_i \) 的倍数，最终与 \( m \) 取最大公约数。  

2. **构造方法**：  
   - 选择一个非零元素 \( Y_p \)，对其他元素 \( Y_i \) 构造 \( X_i = -k_i \cdot (m - g) + Y_i \)，确保能被 \( \text{ans} \) 整除。  
   - 调整 \( X_p \) 的系数 \( k' \)，使得整体 \( \gcd \) 达到最大值。  

### 可视化设计思路  
1. **核心变量高亮**：  
   - **\( g \)**：初始高亮计算所有 \( Y_i \) 的 \( \gcd \) 并与 \( m \) 取 \( \gcd \)。  
   - **\( \text{ans} = m - g \)**：显示推导结果。  
   - **构造 \( X_i \)**：动态展示如何选择 \( k_i \) 使 \( X_i = Y_i + k_i \cdot m \)。  

2. **像素动画演示**：  
   - **网格界面**：显示 \( Y \) 数组和逐步计算的 \( \gcd \)。  
   - **构造步骤**：以像素方块表示每个 \( X_i \)，颜色区分已处理/未处理元素。  
   - **音效触发**：当找到合适的 \( k' \) 时播放成功音效。  

---

## 题解清单 (4星)  
### 题解作者：oyoham  
**评分：4/5**  
- **关键亮点**：  
  1. 数学推导简洁，通过 \( \text{ans} = m - g \) 直接得出最大值。  
  2. 构造方法利用枚举或随机选择 \( k' \)，确保可行性。  
  3. 处理了全零数组的特殊情况。  
- **改进点**：  
  - 变量命名可读性较差（如 `tagp`, `_k`）。  
  - 未详细证明构造的正确性。  

---

## 最优思路或技巧提炼  
1. **数学构造技巧**：  
   - 将模运算问题转化为最大公约数的优化问题。  
   - 利用 \( \gcd(a, b) = \gcd(a \mod b, b) \) 的性质简化计算。  

2. **分治处理**：  
   - 对 \( n=1 \) 单独处理，避免复杂构造。  
   - 对非零元素单独调整，确保整体 \( \gcd \) 最大。  

---

## 同类型题或类似算法套路  
- **通用解法**：  
  构造满足模条件且数论函数最优的数组，通常结合以下步骤：  
  1. 推导目标函数的最优值形式。  
  2. 构造满足条件的候选解。  
  3. 通过枚举或随机调整验证可行性。  

---

## 推荐洛谷题目  
1. **P1890** [gcd区间]：动态计算区间 \( \gcd \)。  
2. **P2447** [SDOI2005 矩阵]：构造矩阵满足模条件。  
3. **P3518** [POI2011 SEJ-Strongbox]：数论与构造结合的最优化问题。  

---

## 代码核心逻辑  
### 关键代码片段  
```cpp
int g = m, ans = 0;
// 计算所有Y_i的gcd并与m取gcd
for (int i = 1; i <= n; i++) {
    g = __gcd(g, a[i]);
}
ans = m - g;

// 构造X_i
int _k = 1;
k[AN] = (_k * ans - a[AN]) / g;
// 调整k'直到满足条件
while (__gcd(G, k[AN] * m + a[AN]) > ans) {
    _k++;
    k[AN] = (_k * ans - a[AN]) / g;
}
```

---

## 个人心得摘录  
- **调试经验**：  
  需要特别注意全零数组的特殊情况，否则会错误构造导致 \( \gcd \) 为 \( m \)。  
- **构造技巧**：  
  通过固定一个元素 \( Y_p \) 并调整其系数，简化其他元素的构造。  

---

## 复古像素化动画设计  
### 实现要点  
1. **像素风格界面**：  
   - 使用 8 位色块表示数组元素，黄色表示 \( Y_i \)，红色表示 \( \gcd \) 计算过程。  
   - 网格布局展示构造步骤，右侧面板显示 \( g \) 和 \( \text{ans} \)。  

2. **音效与动画**：  
   - **计算 \( \gcd \)**：逐元素高亮，播放“滴答”音效。  
   - **找到 \( k' \)**：触发绿色闪烁动画和成功音效。  

3. **AI自动模式**：  
   自动执行构造步骤，每步延迟 500ms，可通过按钮切换手动/自动。  

### 示例代码 (伪代码)  
```javascript
// 初始化Canvas网格
drawGrid(yArray, m) {
    // 绘制Y数组和m值
}

// 自动调整k'的动画
function autoAdjustK() {
    let kPrime = 1;
    while (gcdNotMatch()) {
        highlightElement(AN);
        updateX(AN, kPrime);
        kPrime++;
        playSound("step");
    }
    playSound("success");
}
```

---
处理用时：78.75秒
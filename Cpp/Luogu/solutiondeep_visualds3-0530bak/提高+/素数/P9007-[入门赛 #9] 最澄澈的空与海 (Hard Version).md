# 题目信息

# [入门赛 #9] 最澄澈的空与海 (Hard Version)

## 题目背景

材料 1：

> 请小心地计算下面的算式：$138 - 108 \div 6 = ?$  
> 你大概难以置信，这个算式的计算结果竟然是 $5!$

材料 2：

> 对于一个正整数 $x$，$x! = 1 \times 2 \times \cdots \times (x - 1) \times x$。我们称 $x!$ 为 $x$ 的阶乘。  
> 特别的，$0! = 1$。

显然，「$138 - 108 \div 6 = 5$」是错误的，而「$(138 - 108) \div 6 = 5$」是正确的，所以对材料 1 中的内容，部分读者会认为「作者没有搞清加减乘除的运算优先级关系而犯错」。

然而，材料 1 最后一行的叹号并不是标点符号，而是材料 2 提到的「阶乘」。

考虑到这一点，「$138 - 108 \div 6 = 5! = 1 \times 2 \times \cdots \times 5 = 120$」显然就是正确的了。

## 题目描述

然而，此题可能与上面的题目背景关系不是很大。

我们会给你 $T$ 组数据，每组数据包括一个正整数 $n$。

对于每组数据，请你帮助求出满足以下条件的整数三元组 $(x, y, z)$ 的组数：

1. $x \geq 0$，$z \geq 1$。
2. $x - y \div z = n!$ 且 $(x - y) \div z = \dfrac{n!}{n}$。

由于答案可能过大，因此你需要输出答案对 $998244353$ 取模后的结果。

不难注意到答案有可能为 $\infty$，这时请按照「输出格式」要求进行处理。

**请注意此处应满足 $(x - y) \div z = \dfrac{n!}{n}$ 而不是 $= n$。**

请注意这里的 $\div$ 不是向下取整的整除，这显然意味着你需要保证 $y \div z$ 和 $(x - y) \div z$ 为整数。

## 说明/提示

### 样例 1 解释

样例中的具体三元组如下：

| $n$ | 所有可能的三元组 |
| :----------: | :----------: |
| $2$ | $(2, 0, 2)$ |
| $3$ | $\begin{matrix}(8, 4, 2) & (5, -5, 5) & (6, 0, 3)\end{matrix}$ |
| $4$ | $\begin{matrix}(19, -95, 19) & (21, -21, 7) & (24, 0, 4) \\ (27, 9, 3) & (20, -40, 10) & (36, 24, 2)\end{matrix}$ |

### 数据规模与约定

对于前 $20\%$ 的数据，保证 $T \leq 10$，$n \leq 10$。

对于前 $40\%$ 的数据，保证 $n \leq 10 ^ 3$。

对于另外 $20\%$ 的数据，保证 $T = 1$。

对于 $100\%$ 的数据，保证 $1 \leq T \leq 10 ^ 5$，$1 \leq n \leq 10 ^ 6$。

## 样例 #1

### 输入

```
3
2
3
4```

### 输出

```
1
3
6```

# AI分析结果



---

**唯一算法分类**：数论（质因数分解与约数个数定理）

---

### **题解思路、算法要点与解决难点**

1. **核心推导**  
   - 方程化简得 `x = (n-1)*(n-1)! * z/(z-1)`，要求 `z-1` 是 `(n-1)*(n-1)!` 的因数。  
   - **问题转化为求 `(n-1)*(n-1)!` 的因数个数**，直接计算无法处理大范围 `n`，需高效预处理。

2. **关键算法实现**  
   - **线性筛预处理**：记录每个数的最小质因数，分解质因数时从最小质因数递归，复杂度 `O(log n)`。  
   - **动态维护因数个数**：维护质因数的指数数组 `cnt`，每次分解后更新乘积 `ans = ∏(cnt[i]+1)`。  
   - **逆元优化**：预处理 `1~1e6` 的逆元，避免每次除法重复计算。

3. **解决难点对比**  
   | 题解作者 | 预处理方式 | 动态维护技巧 | 优化点 |  
   |---|---|---|---|  
   | Maxmilite | 线性筛质因数分解 | 维护 `f[x]` 数组，乘逆元更新 | 完整推导过程 |  
   | __ryp__ | 离线排序询问，逐步分解 | 每次仅处理当前 `n` 的质因数 | 减少冗余计算 |  
   | Empty_Dream | 线性筛 + 双倍贡献后回退 | 维护 `ans` 时先乘双倍再回退 | 代码简洁 |  

---

### **题解评分 (≥4星)**

1. **Maxmilite（4.5星）**  
   - **亮点**：完整数学推导，详细注释代码，适合教学。  
   - **不足**：未使用线性逆元预处理，效率略低。

2. **__ryp__（4星）**  
   - **亮点**：离线处理优化，减少重复计算，时间复杂度最优。  
   - **不足**：代码可读性稍差，需结合注释理解。

3. **Empty_Dream（4星）**  
   - **亮点**：代码简洁，利用双倍贡献回退技巧，适合竞赛参考。  
   - **不足**：推导过程较简略。

---

### **最优思路或技巧提炼**

1. **线性筛预处理质因数**  
   - 预处理每个数的最小质因数，分解时递归取最小质因数，复杂度 `O(log n)`。

2. **动态维护乘积**  
   ```cpp
   // 示例代码片段（Empty_Dream 题解）
   void update(int x, int y) {
       while (x > 1) {
           int tmp = pri[x];
           res = res * inv[cnt[tmp] + 1] % mod;
           cnt[tmp] += y; // 更新质因数次数
           res = res * (cnt[tmp] + 1) % mod;
           x /= tmp;
       }
   }
   ```

3. **逆元预处理**  
   ```cpp
   // 线性逆元计算（__ryp__ 题解）
   inv[1] = 1;
   for (int i = 2; i <= x; i++)
       inv[i] = (P - P / i) * inv[P % i] % P;
   ```

---

### **同类型题与算法套路**

1. **通用解法**  
   - 阶乘相关因数计算：预处理质因数指数，动态维护乘积。  
   - 大数因数分解优化：线性筛预处理最小质因数。

2. **推荐题目**  
   - [P2048 超级阶乘](https://www.luogu.com.cn/problem/P2048)  
   - [P3927 阶乘质因数分解](https://www.luogu.com.cn/problem/P3927)  
   - [P1069 细胞分裂](https://www.luogu.com.cn/problem/P1069)

---

### **个人心得摘录**

- **调试教训**（Maxmilite）：  
  > “标答代码写的很丑陋（诸如没有采用线性求逆元），洛谷上开启 O2 后单个点在 700ms 左右通过，所以考虑后时限设置为两秒。”  
  - **总结**：逆元预处理对效率影响显著，需优先优化。

- **优化技巧**（Empty_Dream）：  
  > “加上双倍贡献计算答案，答案计算完成后减去多余贡献。”  
  - **总结**：通过临时操作避免重复计算，提升代码效率。

---

### **可视化与算法演示**

1. **核心流程动画设计**  
   - **Canvas 网格绘制**：  
     - 每行表示一个质数（如2,3,5...），每列表示当前质数的指数。  
     - 当处理 `i=6` 时，分解为 `2^1*3^1`，对应质数行增加高度（指数）。  
   - **高亮变化**：当前处理的数 `i` 显示为红色，分解后的质因数高亮为绿色。  

2. **复古像素风格**  
   - **颜色方案**：8位色，质数用不同颜色区分（如2=蓝，3=黄）。  
   - **音效触发**：  
     - 分解成功：播放 `8-bit 上升音`。  
     - 更新指数：播放 `短促滴答声`。  

3. **AI自动演示模式**  
   - **自动播放**：按 `n=1,2,3...` 逐步显示质因数分解过程。  
   - **控制面板**：暂停/继续按钮，速度滑动条（1x~10x）。  

---

**示例代码片段（可视化 JS 核心逻辑）**  
```javascript
// Canvas 绘制质因数网格
function drawGrid(primes, exponents) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    primes.forEach((p, idx) => {
        const x = idx * 50;
        const height = exponents[p] * 20;
        ctx.fillStyle = getPrimeColor(p);
        ctx.fillRect(x, 300 - height, 40, height);
    });
}

// 音效触发（Web Audio API）
function playSound(note) {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(note, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
}
```

---

**结论**：通过质因数分解与动态维护乘积的高效预处理，结合复古像素动画，直观展示算法核心流程，适合教学与竞赛训练。

---
处理用时：81.02秒
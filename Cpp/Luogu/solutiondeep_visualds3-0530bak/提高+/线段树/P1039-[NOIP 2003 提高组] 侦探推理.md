# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！

## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果



## 算法分类：模拟、枚举

### 题解思路与核心难点

**核心思路**：  
1. **双重枚举**：枚举每个可能的罪犯和星期几，作为假设条件  
2. **证词验证**：对每个假设条件，验证所有人证词是否自洽  
3. **矛盾检测**：若某人同时出现真话和假话，则该假设不成立  
4. **人数计算**：统计确定说谎人数与不确定人数，判断是否满足 N 的范围  

**解决难点**：  
- 证词分类处理（日期、自我指认、他人指认）  
- 未说话者的状态不确定性处理  
- 多条件枚举时的剪枝优化  

### 题解评分（≥4星）

1. **wjyyy（5星）**  
   - 使用 `map` 映射人名，`vector` 存储结构化证词  
   - 引入 `ran` 变量处理未说话者的不确定性  
   - 代码逻辑清晰，模块化程度高  

2. **Sanust（4星）**  
   - 输入处理细致，过滤无效证词  
   - 用 `vector<node>` 存储证词类型（日期/指认）  
   - 通过 `flag` 快速跳出矛盾场景  

3. **Lovelace_qwq（4星）**  
   - 将证词判断封装为独立函数 `judge()`  
   - 用 `vis[]` 数组标记说话状态  
   - 代码注释详尽，易读性强  

### 最优思路提炼

1. **结构化证词存储**  
   将证词分类为：  
   ```cpp
   struct node {
       int id;       // 涉及的人或星期编号
       bool is_date; // 是否为日期类证词
       bool is_true; // 是否为肯定句
   }
   ```

2. **双重枚举剪枝**  
   ```cpp
   for(罪犯枚举)
     for(星期枚举)
       for(每个人)
         if(存在矛盾证词) break
   ```

3. **不确定人数处理**  
   ```cpp
   cnt_fake = 确定说谎人数
   ran = 未说话人数
   if(n >= cnt_fake && n <= cnt_fake + ran) 合法
   ```

### 同类型题与算法套路

**通用套路**：  
- 多重条件枚举 + 状态验证  
- 矛盾检测剪枝  
- 不确定范围的区间判断  

**相似题目**：  
1. P1003 铺地毯（坐标范围枚举）  
2. P1036 选数（组合枚举+质数验证）  
3. P1019 单词接龙（字符串拼接验证）

---

## 可视化算法演示

**动画设计**：  
1. **像素网格界面**  
   - 左侧显示嫌疑人头像（8-bit风格）  
   - 右侧显示当前假设（罪犯+星期）  
   - 下方滚动显示证词验证结果  

2. **关键操作高亮**  
   ```python
   # 伪代码示例
   for suspect in suspects:
       highlight(suspect, color=RED)
       for day in days:
           highlight(day, color=BLUE)
           for statement in statements:
               if check_contradict():
                   flash(statement, color=YELLOW)
                   play_sound("error.wav")
                   break
           update_counter(fake_count, ran_count)
   ```

3. **音效与交互**  
   - 正确验证：8-bit "ping" 音效  
   - 发现矛盾：低沉爆破音  
   - 最终结果：胜利小调  

**Canvas 实现片段**：  
```javascript
// 绘制嫌疑人头像
function drawSuspect(ctx, x, y, isGuilty) {
    ctx.fillStyle = isGuilty ? "#FF0000" : "#00FF00";
    ctx.fillRect(x, y, 16, 16); // 16x16 像素方块
}

// 证词验证动画
function animateCheck(suspect, day) {
    statements.forEach((stmt, idx) => {
        setTimeout(() => {
            highlightStatement(idx);
            if (isContradict(stmt)) {
                flashStatement(idx);
                playSound("error.wav");
            }
        }, idx * 200);
    });
}
```

---

## 核心代码实现

**wjyyy 题解关键片段**：  
```cpp
// 枚举罪犯i和星期j
for(int i=1;i<=n;++i) for(int j=1;j<=7;++j){
    int cnt=0, ran=0;
    bool valid = true;
    for(int k=1;k<=n;++k){
        if(v[k].empty()) { ran++; continue; }
        bool rea = calc_truth(k, i, j); // 计算是否说真话
        for(auto stmt : v[k]){
            bool actual = check_stmt(stmt, i, j);
            if(actual != rea) { valid=false; break; }
        }
        cnt += !rea; // 说假话人数
    }
    if(valid && cnt<=m && m<=cnt+ran){
        // 更新答案
    }
}
```

---

**总结**：本题通过双重枚举与状态验证，结合矛盾剪枝和不确定区间判断，典型体现模拟类题目的解决思路。重点在于证词的结构化处理和高效的状态管理。

---
处理用时：74.44秒
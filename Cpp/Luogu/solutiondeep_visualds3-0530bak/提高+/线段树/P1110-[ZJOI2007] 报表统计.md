# 题目信息

# [ZJOI2007] 报表统计

## 题目描述

小 Q 的妈妈是一个出纳，经常需要做一些统计报表的工作。今天是妈妈的生日，小 Q 希望可以帮妈妈分担一些工作，作为她的生日礼物之一。

经过仔细观察，小 Q 发现统计一张报表实际上是维护一个非负整数数列，并且进行一些查询操作。

在最开始的时候，有一个长度为 $n$ 的整数序列 $a$，并且有以下三种操作：
        
- `INSERT i k`：在原数列的第 $i$ 个元素后面添加一个新元素 $k$；如果原数列的第 $i$ 个元素已经添加了若干元素，则添加在这些元素的最后（见样例说明）。
- `MIN_GAP`：查询相邻两个元素的之间差值（绝对值）的最小值。
- `MIN_SORT_GAP`：查询所有元素中最接近的两个元素的差值（绝对值）。

于是小 Q 写了一个程序，使得程序可以自动完成这些操作，但是他发现对于一些大的报表他的程序运行得很慢，你能帮助他改进程序么？

## 说明/提示

#### 样例输入输出 1 解释

一开始的序列为 $\{5,3,1\}$。

执行操作 `INSERT 2  9` 将得到 $\{5,3,9,1\}$，此时 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $2$。

再执行操作 `INSERT 2  6` 将得到：$\{5,3, 9, 6, 1\}$。

注意这个时候原序列的第 $2$ 个元素后面已经添加了一个 $9$，此时添加的 $6$ 应加在 $9$ 的后面。这个时候 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $1$。

---


#### 数据规模与约定

对于全部的测试点，保证 $2 \le n, m \le 5\times10^5$，$1 \leq i \leq n$，$0 \leq a_i, k \leq 5 \times 10^8$。

## 样例 #1

### 输入

```
3 5
5 3 1
INSERT 2 9
MIN_SORT_GAP
INSERT 2 6
MIN_GAP
MIN_SORT_GAP
```

### 输出

```
2
2
1
```

# AI分析结果



---

**算法分类**  
平衡树/堆/STL应用

---

## 综合分析与结论  
### 核心算法流程  
1. **相邻差值维护**：用堆/multiset维护相邻元素的差值集合，插入时删除旧差值并插入新差值  
2. **全局最小差**：用平衡树/multiset维护所有元素，每次插入时查询前驱和后继更新最小差  
3. **操作时间优化**：利用STL的lower_bound快速定位插入位置，通过堆顶比较实现"延迟删除"  

### 可视化设计要点  
**8位像素动画演示**：  
1. 左侧区域展示数列的分段结构（如`[5][3,9,6][1]`），用不同颜色方块区分不同段  
2. 插入操作时：  
   - 旧差值方块（红色闪烁）→ 删除动画（爆炸粒子效果）  
   - 新差值方块（绿色生长动画）从插入点向两侧延伸  
3. 右侧区域用平衡树可视化：  
   - 插入新节点时，前驱节点亮黄光，后继节点亮蓝光，差值计算过程显示在下方状态栏  
   - 背景播放8-bit音效：插入时"叮"，删除时"砰"，极值更新时上升音阶  

**交互控制**：  
- 空格键暂停/继续  
- 方向键控制动画速度（←减速，→加速）  
- F键切换自动演示模式（AI自动执行样例输入）  

---

## 题解清单（⭐≥4）  
### 1. cmd2001（⭐⭐⭐⭐⭐）  
**亮点**：  
- 双multiset + 预存段首尾元素  
- 相邻差值维护仅需`O(1)`查询  
- 全局最小差通过lower_bound动态更新  
**核心代码**：  
```cpp
multiset<int> delta, full;
void update_srt(int x) {
    auto it = full.lower_bound(x);
    int nw = *it - x;
    --it;
    nw = min(nw, x - *it);
    srt = min(srt, nw);
    full.insert(x);
}
```

### 2. 万弘（⭐⭐⭐⭐）  
**亮点**：  
- 手写Treap + 左偏树组合  
- 左偏树实现差值的高效删除  
- Treap维护全局元素的前驱后继  
**调试心得**：  
_"被hack数据教育后，发现必须判断插入位置是否为最后一段，否则会访问非法内存"_

### 3. Lauzun（⭐⭐⭐⭐）  
**亮点**：  
- STL堆实现延迟删除  
- 预存原数列首尾指针  
- 插入时同步更新两个独立数据结构  
**关键优化**：  
```cpp
struct Heap {
    priority_queue<int> q1, q2;
    void erase(int x) { q2.push(-x); } // 负数存储实现小根堆
    int top() {
        while(q2.size() && q1.top()==q2.top()) 
            q1.pop(), q2.pop();
        return -q1.top();
    }
};
```

---

## 同类型题拓展  
1. **P2234 营业额统计**：动态维护前驱后继的经典题  
2. **P3871 中位数**：堆维护动态序列的中位数  
3. **P1486 郁闷的出纳员**：平衡树维护工资表  

---

## 可视化核心代码（JS伪代码）  
```javascript
class PixelAnimator {
    constructor() {
        this.speed = 1.0;
        this.blocks = []; // 存储分段的可视化方块
    }
    
    // 插入动画
    async insertAnim(pos, val) {
        const oldBlock = this.blocks[pos];
        oldBlock.flashRed();  // 旧块红色闪烁
        await this.delay(200/speed);
        
        const newLeft = createBlock(val, oldBlock.tail);
        const newRight = createBlock(oldBlock.nextHead, val);
        this.blocks.splice(pos, 1, newLeft, newRight);
        
        playSound('insert'); // 8-bit音效
        this.balanceTree.highlightNeighbors(val); // 高亮前驱后继
    }
    
    // 差值堆更新
    updateHeap(oldVal, newVals) {
        this.heapView.explode(oldVal);    // 粒子爆炸动画
        newVals.forEach(v => this.heapView.grow(v)); 
    }
}
```

---

## 关键实现思想  
**相邻差值维护**：  
1. 存储每个分段的头尾指针（`st[i]`和`ed[i]`）  
2. 插入时计算：  
   - 新元素与前段尾的差  
   - 新元素与后段头的差  
3. 删除旧差值`abs(ed[i] - st[i+1])`  

**全局最小差优化**：  
- 维护一个全局变量`min_gap`，插入时只需比较：  
  ```cpp
  min_gap = min(min_gap, new_val - pre, succ - new_val)
  ```  
- 当`min_gap=0`时提前终止计算（相同元素存在）

---

## 拓展思考  
**游戏化积分规则**：  
- 连续正确操作获得Combo奖励  
- 错误操作扣分并播放"Game Over"音效  
- 极值更新时触发加分特效（金色粒子爆发）  

**AI自动演示**：  
```python
def auto_demo(steps):
    for op in steps:
        if op.type == INSERT:
            find_optimal_position(op.pos)
            animate_balance_tree()
        else:
            highlight_query_result()
        time.sleep(1.0/speed)
```

---
处理用时：84.14秒
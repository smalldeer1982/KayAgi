# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果



# 算法分类：枚举与模拟

## 题解思路与解决难点

**核心思路**：通过枚举所有可能的矩形排列组合与旋转方向，计算每种情况下的包围矩形面积，最终取最小值。难点在于：
1. **排列组合的生成**：需覆盖所有4!×2^4种可能性（排列+旋转）。
2. **布局公式推导**：正确推导题目给出的6种基础布局对应的长宽计算公式。
3. **去重与优化**：避免重复计算相同面积的不同长宽组合。

**关键实现步骤**：
1. 使用DFS或全排列生成所有可能的矩形顺序。
2. 对每个矩形考虑其两种方向（旋转后的长宽交换）。
3. 针对每种顺序应用6种布局公式计算包围矩形的尺寸。
4. 记录最小面积及对应的长宽组合，去重后输出。

---

## 题解评分（≥4星）

1. **七喜（4.5星）**  
   - 亮点：DFS生成排列，check函数清晰覆盖6种布局，注释详细易读。  
   - 关键代码：在dfs中处理旋转，通过tmpx/tmpy数组保存当前排列的尺寸。

2. **Chiesl（4星）**  
   - 亮点：结构体存储答案便于排序去重，check函数分情况明确。  
   - 关键代码：使用结构体vector保存所有可能解，最后排序输出。

3. **HFUUZY（4星）**  
   - 亮点：swap实现全排列，calc函数覆盖所有情况。  
   - 关键代码：通过四重循环实现排列生成，update函数处理面积更新。

---

## 最优思路提炼

1. **排列生成**：使用DFS递归生成所有4!排列，每个节点交换长宽处理旋转。
```cpp
void dfs(int yj) {
    if (yj == 4) check();
    for (int i=1; i<5; i++) {
        if (!vis[i]) {
            tmpx[yj+1] = x[i]; // 当前方向
            dfs(yj+1);
            tmpx[yj+1] = y[i]; // 旋转后方向
            dfs(yj+1);
        }
    }
}
```

2. **布局公式**：第六种布局需分5种子情况计算长：
```cpp
if (y1+y3 <= y4) x = max(x2, x1+x3+x4);
else if (y3 <= y4) x = max(x1+x2, x1+x3+x4);
...
```

3. **结果处理**：使用哈希集合标记已出现的长宽组合，避免重复输出。

---

## 可视化设计（复古像素风格）

**核心动画逻辑**：
1. **网格画布**：800×600 Canvas，每个矩形用不同颜色方块表示。
2. **布局切换**：按数字键1-6切换基础布局，方向键旋转当前矩形。
3. **动态计算**：实时显示当前布局的长宽公式及计算结果。

**像素化效果**：
```javascript
// 绘制矩形块
function drawRect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*20, y*20, w*20-2, h*20-2); // 20px/unit
}
```

**音效触发**：
- 正确计算时播放8-bit "coin"音效（Web Audio API）
- 发现更优解时播放上升音阶

---

## 相似题目推荐

1. **P1004 方格取数** - 二维路径枚举
2. **P1052 过河** - 状态压缩与排列组合
3. **P1099 树网的核** - 几何图形包围优化

---

## 关键代码片段

**布局计算（第六种情况）**：
```cpp
y = max(y1 + y3, y2 + y4);
if (y1 + y3 <= y4)
    x = max(x2, max(x1, x3) + x4);
else if (...) // 其他子情况
```

**DFS排列生成**：
```cpp
void dfs(int step) {
    if (step == 4) check();
    for (int i=0; i<4; i++) {
        if (!used[i]) {
            used[i] = true;
            swap(rect[i].w, rect[i].h); // 旋转
            dfs(step+1);
            swap(rect[i].w, rect[i].h); // 回溯
            used[i] = false;
        }
    }
}
```

---

通过系统化枚举所有可能性，配合清晰的布局公式推导，可高效解决此类几何排列问题。可视化时重点展示布局变化与公式计算过程，加深对空间排列的理解。

---
处理用时：57.27秒
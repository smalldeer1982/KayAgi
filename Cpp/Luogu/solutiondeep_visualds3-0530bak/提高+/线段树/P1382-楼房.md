# 题目信息

# 楼房

## 题目描述

地平线（$x$ 轴）上有 $n$ 个楼房，每个楼房可以表示为一个矩形。

用三个整数 $h_i,l_i,r_i$ 来表示第 $i$ 个矩形：矩形左下角为 $(l_i,0)$，右上角为 $(r_i,h_i)$。

地平线高度为 $0$。在轮廓线长度最小的前提下，从左到右输出轮廓线。

## 说明/提示

样例二如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/pmf4pzif.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/5ec8sxwi.png)

数据范围:

对于 $30\%$ 的数据，$n\le100$。

对于另外 $30\%$ 的数据，$1\le h_i,l_i,r_i\le 1000$。

对于 $100\%$ 的数据，$1\le n\le10^5$，$1\le h_i\le 10^9$，$-10^9\le l_i<r_i\le10^9$。

## 样例 #1

### 输入

```
2
3 0 2
4 1 3
```

### 输出

```
6
0 0
0 3
1 3
1 4
3 4
3 0```

## 样例 #2

### 输入

```
5
3 -3 0
2 -1 1
4 2 4
2 3 7
3 6 8```

### 输出

```
14
-3 0
-3 3
0 3
0 2
1 2
1 0
2 0
2 4
4 4
4 2
6 2
6 3
8 3
8 0```

# AI分析结果



### 唯一算法分类
**扫描线算法**

---

### 综合分析与结论

#### 核心思路与难点
- **核心逻辑**：将每个楼房的左右边界作为事件点（左边界为“进入”，右边界为“离开”），按坐标排序后依次处理，动态维护当前最大高度。当最大高度变化时，记录轮廓线拐点。
- **关键难点**：
  1. **事件排序**：同一坐标的事件需优先处理进入边，且进入边按高度降序排序，离开边按高度升序排序。
  2. **数据结构选择**：需高效维护当前最大高度，常见选择是堆（优先队列）、线段树或平衡树（如 `multiset`）。
  3. **离散化处理**：当坐标范围过大时，需将坐标离散化以适配线段树或分块结构。

#### 可视化设计思路
- **动画流程**：
  1. **事件点移动**：以像素方块从左到右依次标记事件点（进入为绿色，离开为红色）。
  2. **堆/集合动态更新**：用堆结构动态显示当前高度集合，最大高度高亮显示。
  3. **轮廓线绘制**：每当最大高度变化时，绘制垂直线段连接新旧高度点。
- **复古风格**：
  - **颜色方案**：8位色调色板（如：绿色方块表进入事件，红色表离开，黄色高亮当前最大高度）。
  - **音效触发**：进入事件播放上升音调，离开事件播放下降音调，高度变化时触发短促“哔”声。
  - **Canvas 交互**：允许单步执行或调节速度，观察堆的更新与轮廓线生成。

---

### 题解清单（评分 ≥4星）

1. **shuri001（扫描线 + multiset）**  
   **评分**：⭐⭐⭐⭐  
   **亮点**：  
   - 使用 `multiset` 维护当前高度集合，简化了堆的实现。  
   - 处理事件时直接比较当前最大高度，逻辑清晰。  
   ```cpp
   multiset<int> s; // 维护当前高度集合
   sort(l, l + cnt, cmp); // 事件排序
   for (处理每个事件) {
       if (进入事件 && 高度 > 当前最大) 记录轮廓点;
       else if (离开事件 && 是当前最大且唯一) 记录轮廓点;
   }
   ```

2. **xiaolou（线段树 + 离散化）**  
   **评分**：⭐⭐⭐⭐  
   **亮点**：  
   - 离散化后线段树区间更新，保证复杂度为 O(n log n)。  
   - 最后扫描离散点，统计高度变化生成轮廓。  
   ```cpp
   sort(a, a + 2n); // 离散化坐标
   BuildTree(1, 1, m); // 建线段树
   for (每个楼房) Change(线段树区间更新);
   for (每个离散点) if (高度变化) 记录点;
   ```

3. **George1123（堆 + 事件优先级）**  
   **评分**：⭐⭐⭐⭐  
   **亮点**：  
   - 自定义堆结构处理重复事件，确保删除正确性。  
   - 处理同一坐标事件时，优先处理进入边。  
   ```cpp
   struct Heap { // 堆与待删除集合
       priority_queue<int> Q, D;
       void del(int x) { D.push(x); } // 延迟删除
   };
   ```

---

### 最优思路提炼
1. **事件排序策略**：按坐标排序，同一坐标下进入事件优先，且进入事件按高度降序，离开按升序。
2. **延迟删除技巧**：堆中维护待删除集合，仅在堆顶元素需删除时执行实际删除操作。
3. **离散化优化**：将坐标映射为连续整数，降低线段树或分块的空间复杂度。

---

### 类似题目推荐
1. **P1904 天际线**：几乎相同的问题，直接应用扫描线算法。
2. **P5490 扫描线模板**：练习矩形面积并的扫描线解法。
3. **P1856 矩形周长**：需同时处理水平和垂直轮廓线。

---

### 可视化代码片段（复古风格）

```javascript
// Canvas 绘制事件点与堆结构（简化版）
function drawEvent(x, type) {
    ctx.fillStyle = type === 'in' ? '#00FF00' : '#FF0000';
    ctx.fillRect(x * 10, 100, 8, 8); // 像素方块表示事件点
}

function updateHeap(height) {
    heapElements.forEach((h, i) => {
        ctx.fillStyle = h === currentMax ? '#FFFF00' : '#FFFFFF';
        ctx.fillRect(200 + i * 10, 50, 8, 8); // 堆元素显示为黄色高亮
    });
}

// 音效触发（Web Audio）
function playSound(type) {
    const oscillator = audioCtx.createOscillator();
    oscillator.frequency.setValueAtTime(type === 'change' ? 440 : 220, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.1);
}
```

---

### 个人心得摘录
- **Flanksy（并查集）**：  
  > “类似白雪皑皑的区间染色，按高度从高到低处理，覆盖低优先级操作。”  
  **启示**：逆向处理覆盖问题可避免重复计算。

- **Rayment（zkw线段树）**：  
  > “线段树的 `lazy` 标记直接代替节点值，减少递归开销。”  
  **技巧**：非递归线段树优化常数。

---
处理用时：83.00秒
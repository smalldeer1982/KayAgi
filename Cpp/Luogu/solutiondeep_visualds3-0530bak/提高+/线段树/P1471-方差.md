# 题目信息

# 方差

## 题目背景

滚粗了的 HansBug 在收拾旧数学书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本数学书里面发现了一个神奇的数列，包含 $N$ 个实数。他想算算这个数列的平均数和方差。


## 说明/提示

关于方差：对于一个有 $n$ 项的数列 $A$，其方差 $s^2$ 定义如下：
$$s^2=\frac{1}{n}\sum\limits_{i=1}^n\left(A_i-\overline A\right)^2$$
其中 $\overline A$ 表示数列 $A$ 的平均数，$A_i$ 表示数列 $A$ 的第 $i$ 项。

样例说明：
| 操作步骤 | 输入内容 | 操作要求 | 数列 | 输出结果 | 说明 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | - | - | `1 5 4 2 3` | - | - |
| $1$ | `2 1 4` | 求 $\left[1,4\right]$ 内所有数字的平均数 | `1 5 4 2 3` | `3.0000` | 平均数 $=\left(1+5+4+2\right)\div 4=3.0000$ |
| $2$ | `3 1 5` | 求 $\left[1,5\right]$ 内所有数字的方差 | `1 5 4 2 3` | `2.0000` | 平均数 $=\left(1+5+4+2+3\right)\div 5=3$，方差 $=\left(\left(1-3\right)^2+\left(5-3\right)^2+\left(4-3\right)^2+\left(2-3\right)^2+\left(3-3\right)^2\right)\div 5=2.0000$ |
| $3$ | `1 1 1 1` | 将 $\left[1,1\right]$ 内所有数字加 $1$ | `2 5 4 2 3` | - | - |
| $4$ | `1 2 2 -1` | 将 $\left[2,2\right]$ 内所有数字加 $-1$ | `2 4 4 2 3` | - | - |
| $5$ | `3 1 5` | 求 $\left[1,5\right]$ 内所有数字的方差 | `2 4 4 2 3` | `0.8000` | 平均数 $=\left(2+4+4+2+3\right)\div 5=3$，方差 $=\left(\left(2-3\right)^2+\left(4-3\right)^2+\left(4-3\right)^2+\left(2-3\right)^2+\left(3-3\right)^2\right)\div 5=0.8000$ |

数据规模：
| 数据点 | $N$ | $M$ | 备注 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim3$ | $N\le 8$ | $M\le 15$ | - |
| $4\sim7$ | $N\le 10^5$ | $M\le 10^5$ | 不包含操作 $3$|
| $8\sim10$ | $N\le 10^5$ | $M\le 10^5$ | - |

## 样例 #1

### 输入

```
5 5
1 5 4 2 3
2 1 4
3 1 5
1 1 1 1
1 2 2 -1
3 1 5
```

### 输出

```
3.0000
2.0000
0.8000
```

# AI分析结果



### 算法分类
线段树、数学公式推导

---

### 题解思路与核心算法
**核心公式推导**  
方差公式可展开为：
$$ s^2 = \frac{1}{n} \sum x_i^2 - \left( \frac{1}{n} \sum x_i \right)^2 $$
因此只需维护区间和（sum）和平方和（sum2）即可。

**线段树设计**  
1. **双值维护**：每个节点存储 sum 和 sum2
2. **懒标记更新**：区间加 k 时：
   ```math
   sum2' = sum2 + 2k \cdot sum + k^2 \cdot len
   sum' = sum + k \cdot len
   ```
3. **更新顺序**：必须先更新平方和再更新和，否则会导致计算错误

---

### 最优题解推荐（4星+）
1. **远航之曲（⭐⭐⭐⭐⭐）**
   - **亮点**：代码结构清晰，pushdown 逻辑严格遵循先平方和后和的更新顺序
   - **代码片段**：
     ```cpp
     void pushdown(int rt,int x){
         if(mark[rt]){
             segb[rt<<1] += 2*mark[rt]*sega[rt<<1] + (x-x/2)*mark[rt]*mark[rt];
             segb[rt<<1|1] += 2*mark[rt]*sega[rt<<1|1] + (x/2)*mark[rt]*mark[rt];
             sega[rt<<1] += (x-x/2)*mark[rt];
             sega[rt<<1|1] += (x/2)*mark[rt];
             mark[rt<<1] += mark[rt];
             mark[rt<<1|1] += mark[rt];
             mark[rt] = 0;
         }
     }
     ```

2. **DPair（⭐⭐⭐⭐）**
   - **亮点**：详细推导方差公式，独立维护两个线段树结构体
   - **数学推导**：
     ```cpp
     //方差计算部分
     double sum1 = query_a(1,1,n,x,y)/(y-x+1);
     double sum2 = query_b(1,1,n,x,y)/(y-x+1);
     double ans = sum2 - sum1 * sum1;
     ```

3. **天命之路（⭐⭐⭐⭐）**
   - **亮点**：封装线段树为类，支持多种查询操作
   - **代码设计**：
     ```cpp
     struct segmenttree {
         //...成员函数封装查询逻辑
         void f(int opt) { //统一处理操作类型 }
     };
     ```

---

### 关键实现代码
**线段树更新核心逻辑**
```cpp
void update(int rt, int l, int r, int L, int R, double k) {
    if(L <= l && r <= R) {
        segb[rt] += 2 * k * sega[rt] + k*k*(r-l+1); //先更新平方和
        sega[rt] += k * (r-l+1);                     //再更新和
        mark[rt] += k;
        return;
    }
    pushdown(rt, r-l+1);
    int mid = (l+r)/2;
    if(L <= mid) update(lson, L, R, k);
    if(R > mid) update(rson, L, R, k);
    pushup(rt);
}
```

---

### 同类型题目推荐
1. [P3372 线段树1](https://www.luogu.com.cn/problem/P3372) - 基础区间修改/求和
2. [P5142 区间方差](https://www.luogu.com.cn/problem/P5142) - 方差计算的简化版本
3. [P6492 线段树](https://www.luogu.com.cn/problem/P6492) - 进阶线段树操作

---

### 可视化设计（复古像素版）
**核心动画逻辑**
```javascript
class PixelSegmentTree {
    constructor() {
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.nodes = []; // 存储线段树节点像素坐标
    }
    
    drawNode(rt, x, y) {
        this.ctx.fillStyle = '#8BDBFF'; // 像素蓝
        this.ctx.fillRect(x, y, 16, 16); // 16x16像素块
        this.ctx.fillStyle = '#000';
        this.ctx.font = '8px "Press Start 2P"';
        this.ctx.fillText(rt.sum.toFixed(1), x+2, y+12); // 显示当前和
    }
    
    animateUpdate(rt, l, r) {
        // 高亮当前节点为黄色
        this.ctx.fillStyle = '#FFE500';
        this.ctx.fillRect(this.nodes[rt].x, this.nodes[rt].y, 16, 16);
        
        // 播放8-bit音效
        playSound('blip'); // 短促哔声
        
        // 延迟后恢复颜色
        setTimeout(() => {
            this.drawNode(rt, this.nodes[rt].x, this.nodes[rt].y);
        }, 200);
    }
}
```

**关键交互设计**
1. **单步执行**：空格键逐步执行线段树更新
2. **自动模式**：A键启动AI自动演示，速度可调
3. **音效反馈**：
   - 正确更新：清脆的"叮"声（Square波形）
   - 错误操作：低沉的"嗡"声（Noise波形）

---

### 总结与拓展
**核心思维**：将复杂统计量（方差）分解为可维护的基础量（和、平方和），通过数学推导设计更新规则。

**调试经验**：多个题解提到必须严格保证更新顺序——先平方和后区间和，这是线段树维护多变量的经典陷阱。

**拓展应用**：此方法可推广至任意形如 `f(x) = ax² + bx + c` 的统计量维护，例如协方差、高阶矩等。

---
处理用时：75.40秒
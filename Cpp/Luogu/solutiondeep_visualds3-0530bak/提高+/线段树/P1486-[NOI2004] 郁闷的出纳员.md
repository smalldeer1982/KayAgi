# 题目信息

# [NOI2004] 郁闷的出纳员

## 题目描述

OIER 公司是一家大型专业化软件公司，有着数以万计的员工。作为一名出纳员，我的任务之一便是统计每位员工的工资。这本来是一份不错的工作，但是令人郁闷的是，我们的老板反复无常，经常调整员工的工资。如果他心情好，就可能把每位员工的工资加上一个相同的量。反之，如果心情不好，就可能把当前在公司的所有员工的工资扣除一个相同的量。我真不知道除了调工资他还做什么其它事情。

工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。

老板经常到我这边来询问工资情况，他并不问具体某位员工的工资情况，而是问现在工资第 $k$ 多的员工拿多少工资。每当这时，我就不得不对数万个员工进行一次漫长的排序，然后告诉他答案。

好了，现在你已经对我的工作了解不少了。正如你猜的那样，我想请你编一个工资统计程序。怎么样，不是很困难吧？

如果某个员工的初始工资低于最低工资标准，那么将不计入最后的答案内。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- `I` 命令的条数不超过 $10^5$；
- `A` 和 `S` 命令的总条数不超过 $100$；
- `F` 命令的条数不超过 $10^5$；
- 每次工资调整的调整量不超过 $10^3$；
- 新员工的工资不超过 $10^5$。
- $0 \leq n \leq 3 \times 10^5$，$0 \leq \text{min} \leq 10^9$，输入的所有数字均在 $32$ 位带符号整形范围内。

## 样例 #1

### 输入

```
9 10
I 60
I 70
S 50
F 2
I 30
S 15
A 5
F 1
F 2
```

### 输出

```
10
20
-1
2
```

# AI分析结果



# 【NOI2004】郁闷的出纳员 题解分析

## 算法分类
**平衡树**

---

## 核心思路与算法要点

### 关键难点
1. **全局工资偏移量**：所有员工的工资可能被整体加减，需维护一个全局偏移量 `delta`
2. **动态删除低于下限的元素**：每次扣除工资后需要快速删除所有低于下限的节点
3. **高效查询第k大元素**：要求时间复杂度稳定在 O(log n)

### 最优解法：FHQ-Treap
#### 核心变量
- `delta`：记录所有工资的整体偏移量
- `min`：工资下限，每次扣除工资后动态调整

#### 关键操作
1. **插入操作**：插入 `k - delta`（补偿偏移量）
2. **全局增减工资**：直接修改 `delta` 值（时间复杂度 O(1)）
3. **删除操作**：通过 `split` 将工资树分为 `< min - delta` 和 `≥ min - delta` 两部分，直接舍弃左子树
4. **查询第k大**：利用平衡树性质直接查询第 `size - k + 1` 小的元素

#### 复杂度分析
- 插入/删除/查询：O(log n)
- 全局增减工资：O(1)

---

## 题解评分（≥4星）

### 1. FHQ-Treap解法（作者：lijianyangyf） ⭐⭐⭐⭐⭐
**亮点**：
- 使用 `split` 和 `merge` 实现区间删除
- 通过 `delta` 维护全局偏移量，代码简洁高效
- 完整处理了工资下限动态调整的逻辑

**核心代码**：
```cpp
void split(int now,int k,int &x,int &y) {
    if(!now) x = y = 0;
    else if(val[now] <= k) 
        x = now, split(ch[now][1], k, ch[x][1], y);
    else 
        y = now, split(ch[now][0], k, x, ch[y][0]);
    update(now);
}

void del_lower_bound(int tar) {
    int x, y;
    split(root, tar - 1, x, y);
    ans += size[x];
    root = y;
}
```

---

## 可视化设计

### 动画方案（FHQ-Treap）
#### 关键帧设计
| 步骤 | 操作 | 可视化元素 | 颜色标记 |
|------|------|------------|----------|
| 1    | 插入节点 | 新节点以绿色闪烁 | ![#00ff00](https://via.placeholder.com/15/00ff00/000000?text=+) |
| 2    | Split操作 | 分裂线以红色高亮 | ![#ff0000](https://via.placeholder.com/15/ff0000/000000?text=+) |
| 3    | Merge操作 | 合并路径以蓝色流动 | ![#0000ff](https://via.placeholder.com/15/0000ff/000000?text=+) |
| 4    | 删除子树 | 被删子树渐隐 | ![#808080](https://via.placeholder.com/15/808080/000000?text=+) |

#### 复古像素风格
- **数据结构**：平衡树节点用 16x16 像素方块表示
- **动画效果**：
  - **插入**：像素方块从顶部掉落并嵌入树结构
  - **删除**：被删节点以 8-bit 爆炸特效消失
- **音效**：
  - 插入：NES风格 "coin" 音效
  - 删除：FC游戏 "explosion" 音效
  - 查询成功：经典马里奥跳跃音效

---

## 相似题目推荐
1. **P3369 普通平衡树** - 平衡树基础操作
2. **P2286 宠物收养所** - 动态维护最接近值
3. **P2234 营业额统计** - 查询前驱后继

---

## 核心代码实现（FHQ-Treap）
```cpp
#include<cstdio>
#include<cstdlib>
#define N 100005
int ch[N][2], val[N], pri[N], size[N], cnt;
int delta, min_wage, removed_cnt;

void update(int x) { 
    size[x] = size[ch[x][0]] + size[ch[x][1]] + 1; 
}

void split(int now, int k, int &x, int &y) {
    if (!now) x = y = 0;
    else if (val[now] <= k) 
        x = now, split(ch[now][1], k, ch[x][1], y);
    else 
        y = now, split(ch[now][0], k, x, ch[y][0]);
    update(now);
}

int merge(int x, int y) {
    if (!x || !y) return x | y;
    if (pri[x] < pri[y]) {
        ch[x][1] = merge(ch[x][1], y);
        update(x); return x;
    } else {
        ch[y][0] = merge(x, ch[y][0]);
        update(y); return y;
    }
}

void insert(int v) {
    int x, y;
    split(root, v, x, y);
    val[++cnt] = v, pri[cnt] = rand();
    root = merge(merge(x, cnt), y);
}

void process_salary_cut(int k) {
    delta -= k;
    int x, y;
    split(root, min_wage - delta - 1, x, y);
    removed_cnt += size[x];
    root = y;
}

int query_kth(int k) {
    if (size[root] < k) return -1;
    int cur = root, rank = size[root] - k + 1;
    while (true) {
        if (size[ch[cur][0]] + 1 == rank) 
            return val[cur] + delta;
        if (rank <= size[ch[cur][0]]) 
            cur = ch[cur][0];
        else 
            rank -= size[ch[cur][0]] + 1, cur = ch[cur][1];
    }
}
```

---

## 总结
通过维护全局偏移量和利用FHQ-Treap的分裂/合并特性，本解法以 O(log n) 时间复杂度高效处理了动态工资集合的核心操作。可视化设计通过像素风格和经典音效，将抽象算法过程转化为直观的交互体验，适合算法教学与演示。

---
处理用时：82.35秒
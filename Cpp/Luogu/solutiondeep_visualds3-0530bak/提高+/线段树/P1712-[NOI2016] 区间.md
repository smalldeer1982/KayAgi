# 题目信息

# [NOI2016] 区间

## 题目描述

在数轴上有 $n$ 个闭区间从 $1$ 至 $n$ 编号，第 $i$ 个闭区间为 $[l_i,r_i]$ 。

现在要从中选出 $m$ 个区间，使得这 $m$ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $x$ ，使得对于每一个被选中的区间 $[l_i,r_i]$，都有 $l_i \leq x \leq r_i$ 。

对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。

区间 $[l_i,r_i]$ 的长度定义为 $(r_i-l_i)$ ，即等于它的右端点的值减去左端点的值。

求所有合法方案中最小的花费。如果不存在合法的方案，输出 $-1$。

## 说明/提示

#### 样例输入输出 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/qoddox9k.png)
 
 如图，当 $n=6$，$m=3$ 时，花费最小的方案是选取 $[3,5],[3,4],[1,4]$ 这三个区间，它们共同包含了 $4$ 这个位置，所以是合法的。其中最长的区间是 $[1, 4]$，最短的区间是 $[3, 4]$，所以它的花费是 $(4 - 1) - (4 - 3) = 2$。

#### 数据规模与约定

本题共 20 个测试点，各测试点信息如下表。
| 测试点编号 | $ n= $ | $ m= $ | $ l_i,r_i $ |
|:-:|:-:|:-:|:-:|
| 1 | $ 20 $ | $ 9 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 2 | $ 20 $ | $ 10 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 3 | $ 199 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 4 | $ 200 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 5 | $ 1000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 6 | $ 2000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 7 | $ 199 $ | $ 60 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 8 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 9 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 10 | $ 1999 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 11 | $ 2000 $ | $ 400 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 12 | $ 2000 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 13 | $ 30000 $ | $ 2000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 14 | $ 40000 $ | $ 1000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 15 | $ 50000 $ | $ 15000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 16 | $ 100000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 17 | $ 200000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 18 | $ 300000 $ | $ 50000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 19 | $ 400000 $ | $ 90000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 20 | $ 500000 $ | $ 200000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |

对于全部的测试点，保证 $1 \leq m \leq n$，$1 \leq n \leq 5 \times 10^5$，$1 \leq m \leq 2 \times 10^5$，$0 \leq l_i \leq r_i \leq 10^9$。

## 样例 #1

### 输入

```
6 3
3 5
1 2
3 4
2 2
1 5
1 4```

### 输出

```
2```

# AI分析结果



## 唯一算法分类
**双指针（尺取法） + 线段树 + 离散化**

---

## 综合分析与结论

### 核心思路
1. **排序预处理**：将区间按长度排序，便于后续用双指针维护连续区间。
2. **离散化处理**：将大范围端点映射到连续整数，降低线段树空间需求。
3. **线段树维护覆盖**：动态维护区间覆盖次数，快速查询最大覆盖次数。
4. **双指针滑动窗口**：右指针扩展区间集合，左指针收缩以寻找最优解。

### 关键难点与解决方案
- **高效覆盖统计**：线段树支持区间加减和最大值查询，时间复杂度 O(logn)。
- **窗口收缩条件**：当线段树根节点（最大值）≥m 时尝试收缩左边界。
- **离散化精度**：正确映射原始坐标，确保端点包含所有可能覆盖点。

### 可视化设计
1. **动画流程**：
   - **像素网格**：用离散化后的坐标轴展示区间覆盖情况。
   - **线段树高亮**：显示当前修改的节点和路径，颜色标记覆盖次数。
   - **双指针移动**：左右指针在排序后的区间列表上滑动，背景色区分已选区间。
   - **覆盖热力图**：用颜色深浅表示当前各点的覆盖次数。

2. **复古风格**：
   - **8位音效**：区间添加时播放上升音调，移除时下降音调，达成条件时播放胜利音效。
   - **像素字体**：所有文字使用复古点阵字体，状态栏显示当前花费和指针位置。

---

## 题解清单（≥4星）

1. **上进的z君（★★★★☆）**
   - **亮点**：清晰阐述尺取法与线段树配合逻辑，代码结构简明。
   - **关键代码**：`while(tree[1]<m)扩展右指针` 和收缩左指针的逻辑。

2. **wanglichao1121（★★★★★）**
   - **亮点**：标记永久化优化线段树，减少代码量和常数。
   - **代码片段**：永久化标记处理，无需 pushdown。

3. **EternalEpic（★★★★☆）**
   - **亮点**：详细调试经验分享，避免离散化常见错误。
   - **心得摘录**："lower_bound 的返回值未减去基地址导致映射错误"。

---

## 核心代码实现

### 离散化处理
```cpp
vector<int> disc;
for(int i=1;i<=n;i++) {
    disc.push_back(l[i]);
    disc.push_back(r[i]);
}
sort(disc.begin(), disc.end());
disc.erase(unique(disc.begin(), disc.end()), disc.end());
for(int i=1;i<=n;i++) {
    l[i] = lower_bound(disc.begin(), disc.end(), l[i]) - disc.begin() + 1;
    r[i] = lower_bound(disc.begin(), disc.end(), r[i]) - disc.begin() + 1;
}
```

### 线段树永久化标记
```cpp
void update(int l,int r,int L,int R,int v,int o){
    if(L<=l && r<=R){
        add[o] += v;
        mx[o] += v;
        return;
    }
    int m = (l+r)>>1;
    if(L <= m) update(l,m,L,R,v,o<<1);
    if(R > m)  update(m+1,r,L,R,v,o<<1|1);
    mx[o] = max(mx[o<<1], mx[o<<1|1]) + add[o];
}
```

### 双指针主循环
```cpp
int ans = INF, left = 1;
for(int right=1; right<=n; right++){
    update(1, tot, a[right].l, a[right].r, 1); // 添加右指针区间
    while(mx[1] >= m){
        ans = min(ans, a[right].len - a[left].len);
        update(1, tot, a[left].l, a[left].r, -1); // 移除左指针区间
        left++;
    }
}
```

---

## 相似题目推荐
1. **P3143 [USACO16OPEN] Diamond Collector**（双指针+极值统计）
2. **P2216 [HAOI2007] 理想的正方形**（二维滑动窗口+单调队列）
3. **P1496 火烧赤壁**（区间覆盖统计，离散化基础）

---

## 可视化代码片段（Canvas动画）
```javascript
// 绘制区间覆盖热力
function drawHeatmap() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let i=0; i<cover.length; i++) {
        let alpha = Math.min(cover[i]/m, 1);
        ctx.fillStyle = `rgba(255,0,0,${alpha})`;
        ctx.fillRect(i*10, 50, 10, 30);
    }
}

// 双指针移动动画
function movePointer(type) {
    let ptr = type === 'left' ? leftPtr : rightPtr;
    let x = ptr * 10;
    anime({
        targets: type+'Pointer',
        x: [x-5, x],
        easing: 'easeOutElastic(1, .5)'
    });
}
```

---

## 总结与提升
本题的核心在于**排序后的滑动窗口最优化**，结合**离散化降维**和**线段树高效维护**。通过将区间按长度排序，将二维优化问题转化为一维窗口滑动问题，极大降低了问题复杂度。同类问题可优先考虑排序后是否有单调性可挖掘，并结合合适数据结构维护窗口状态。

---
处理用时：79.30秒
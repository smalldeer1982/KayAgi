# 题目信息

# [AHOI2016初中组] 黑白序列

## 题目背景

小可可知道小雪喜欢什么样子的黑白序列。

## 题目描述

首先，对于任何正整数 $n$，如果一个黑白序列是由连续 $n$ 个黑接上连续 $n$ 个白，那一定是小雪喜欢的黑白序列。

其次，如果有两个黑白序列小雪都喜欢，那么把这两个序列接起来得到的新序列，小雪也一定喜欢。小雪不会喜欢更多别的黑白序列。

例如，如果用字符 `B` 和 `W` 分别表示黑色，`W` 表示白色，那么 `BW`，`BBWW`，`BBBWWW` 以及 `BWBW`，`BWBBWW`，`BWBBWWBW` 都是小雪喜欢的黑白序列。而 `W`，`WW`，`WB`，`WBBW` 以及 `BBBWW` 都不是小雪喜欢的黑白序列。

现在小可可准备了一个未完成的黑白序列，用 `B` 和 `W` 表示黑色和白色，用 `?` 表示尚未确定，他希望知道一共有多少种不同的方法，在决定了每一个 `?` 位置的颜色后可以得到一个小雪喜欢的黑白序列。

两个方案若有至少一位不同才能算是不同的，不是 `?` 的位置是不允许修改的。

答案对 $10^9 + 9$（一个素数）取模。







## 说明/提示

#### 样例输入输出 1 解释
有六种合法方案，依次得到的最终黑白序列为： 

- `BBBBWWWW`，
- `BBBWWWBW`，
- `BWBBBWWW`，
- `BWBBWWBW`，
- `BWBWBBWW`，
- `BWBWBWBW`。

#### 数据规模与约定

- 对于 $20\%$ 的数据，输入长度不超过 $22$。
- 对于 $60\%$ 的数据，输入长度不超过 $5000$。
- 对于 $100\%$ 的数据，输入长度不超过 $500000$，保证序列中只含 `W`，`B`，`?` 三种字符，其中 `?` 是英文字符。

## 样例 #1

### 输入

```
B?B?????```

### 输出

```
6```

## 样例 #2

### 输入

```
??BB????W???BB??????```

### 输出

```
26```

## 样例 #3

### 输入

```
????????B???????????W??B?????W????????????????????W????????W```

### 输出

```
10058904```

# AI分析结果



## 算法分类
**动态规划**

---

## 综合分析与结论

### 核心算法流程
所有题解均采用动态规划（DP）作为核心解法，状态定义为 `dp[i]` 表示前 `i` 个字符构成合法序列的方案数。关键在于如何高效处理转移条件：找到所有满足 `j < i` 且 `j+1` 到 `i` 是合法基本块的 `j`，并累加 `dp[j]`。

**最优思路提炼**（沙鵖之祖、star_magic_young 题解）：
1. **预处理**每个位置后面最近的 `W` 的位置，用于快速判断转移边界。
2. **维护指针与和变量**：用 `back` 指针表示当前可转移的起始位置，`sum` 存储有效 `dp[j]` 的和。
3. **动态剪枝**：遇到 `B` 时重置 `sum`，遇到 `W` 时通过链表预存失效位置，动态调整 `sum`。
4. **线性复杂度**：通过指针跳跃和失效位置链表，保证每个位置仅被处理常数次，总时间复杂度 `O(n)`。

### 可视化设计要点
1. **网格展示**：用像素网格表示字符序列，`B` 为黑色块，`W` 为白色块，`?` 为灰色块。
2. **指针与区间高亮**：
   - 当前处理位置 `i` 用闪烁红色框标记。
   - 转移区间 `[back, i]` 用半透明绿色覆盖。
3. **链表失效动画**：当 `i` 达到某个预存失效位置时，对应 `j` 的贡献从 `sum` 中扣除，伴随红色闪烁和音效。
4. **音效设计**：
   - 成功转移时播放短促“叮”声。
   - 遇到 `B` 或 `W` 时播放“咔哒”声。
   - 背景音乐为 8-bit 风格循环旋律。

---

## 题解清单（评分 ≥4星）

### 1. 沙鵖之祖（★★★★★）
- **亮点**：利用链表预存失效位置，动态维护 `sum`，代码简洁高效。
- **核心代码**：
  ```cpp
  for(int i=2;i<=n;i+=2){
      for(int j=hd[i];j;j=nex[j]){
          int v=to[j];
          if(v>=back) sum=(sum-f[v]+mod)%mod;
          f[v]=0;
      }
      // 处理B/W并更新sum和back
      f[i] = sum;
  }
  ```

### 2. star_magic_young（★★★★☆）
- **亮点**：通过预处理 `nxt` 数组快速定位 `W` 的影响范围。
- **核心代码**：
  ```cpp
  for(int i=0;i<=n;i+=2) add((nxt[i]<<1)-i,i);
  del(i); // 动态删除失效贡献
  ```

### 3. xkai（★★★★☆）
- **亮点**：树状数组维护前缀和，将转移条件转化为区间查询。
- **核心代码**：
  ```cpp
  f[i] = (query(wr) - query(wl) + mod) % mod;
  Insert(i, f[i]); // 树状数组更新
  ```

---

## 关键代码实现（沙鵖之祖题解核心）

```cpp
int main() {
    // 预处理最近W的位置nxt[]
    for(int i=n-1;i>=0;i--) 
        nxt[i] = (s[i+1]=='W') ? i+1 : nxt[i+1];
    
    // 链表预存失效位置
    for(int i=0;i<=n;i+=2) 
        add((nxt[i]<<1)-i, i);
    
    // 动态规划主循环
    for(int i=2; i<=n; i+=2) {
        // 删除失效贡献
        for(int j=hd[i]; j; j=nex[j]) {
            int v=to[j];
            if(v >= back) sum = (sum - f[v] + mod) % mod;
        }
        // 处理当前字符
        if(s[i] == 'B') sum=0, back=i;
        else if(s[i-1] == 'B') sum=f[i-2], back=i-2;
        else back -= 2;
        // 更新dp[i]
        f[i] = sum;
        sum = (sum + f[i]) % mod;
    }
    cout << f[n];
}
```

---

## 同类型题目推荐
1. **P2679 子串**（动态规划+前缀和优化）
2. **P2651 添加括号III**（区间DP+数学性质）
3. **P2308 添加括号**（合法括号序列计数）

---

## 可视化算法演示（伪代码）

```javascript
// 初始化Canvas
const grid = new PixelGrid(n, 16, 8); // 16色，8x8像素块
grid.drawSequence(s); // 绘制初始序列

// 自动演示循环
function step(i) {
    grid.highlight(i, 'red'); // 高亮当前处理位置
    playSound('blip'); 
    
    // 处理失效位置
    for (const j of links[i]) {
        grid.flash(j, 'yellow');
        sum -= dp[j];
        playSound('error');
    }
    
    // 更新back和sum
    if (s[i] === 'B') {
        grid.flash(i, 'blue');
        back = i;
    }
    // ...其余逻辑
    
    // 更新dp[i]并绘制
    dp[i] = sum;
    grid.updateCell(i, dp[i]);
    requestAnimationFrame(() => step(i+2));
}
step(0); // 启动演示
```

---
处理用时：89.29秒
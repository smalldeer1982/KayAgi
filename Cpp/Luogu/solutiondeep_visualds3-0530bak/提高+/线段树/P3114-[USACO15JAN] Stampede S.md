# 题目信息

# [USACO15JAN] Stampede S

## 题目描述

FJ 的 $N$ 头奶牛（$1 \leq N \leq 50,000$）看似在农场前的路上狂奔，实际上它们正在进行一场赛跑。

从上方俯视，每头牛在时间 $t = 0$ 时被表示为一个单位长度的水平线段，其左端点坐标为 $(x, y)$。例如，$(-3, 6)$ 表示一头在 $t = 0$ 时从 $(-3, 6)$ 延伸到 $(-2, 6)$ 的奶牛。每头牛以一定速度向右（$+x$ 方向）移动，该速度由移动 1 单位距离所需的整数时间 $r$ 描述。

FJ 并不满意他的奶牛在外赛跑而不在牛棚产奶。他计划在比赛结束后训斥参赛的奶牛。为了确定哪些奶牛参赛，FJ 站在 $(0, 0)$ 处并沿 $+y$ 方向的射线观察。当一头牛在某个时刻成为这条射线上首个可见的牛时，FJ 就会看到它。如果一头牛在穿过 FJ 视线期间始终被其他牛"挡住"，则她不可见。

请计算 FJ 在整个比赛过程中能看到的奶牛数量。

## 说明/提示

FJ 可以看到牛 1 和 2，但看不到牛 3。

## 样例 #1

### 输入

```
3 
-2 1 3 
-3 2 3 
-5 100 1 
```

### 输出

```
2 
```

# AI分析结果



**唯一算法分类**：扫描线算法

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   - 将每头牛进入和离开视线的时间转化为事件点，按时间排序后扫描。  
   - 维护当前活动牛的集合（`active`），每次取最小 `y` 值的牛加入可见集合（`seen`）。

2. **解决难点**  
   - **事件冲突处理**：通过排序确保事件按时间顺序处理，同一时间点的进入事件优先于离开事件。  
   - **离散化优化**：部分题解（如 Expecto）通过直接处理事件点避免离散化，减少代码复杂度。  
   - **区间开闭问题**：使用左闭右开区间（如枫的题解）或离散化后调整端点（如曹老师的线段树实现）避免边界冲突。

3. **算法对比**  
   | 方法              | 数据结构          | 时间复杂度       | 空间复杂度       | 适用场景          |
   |-------------------|-------------------|-----------------|-----------------|-----------------|
   | 扫描线+集合       | `set`             | *O(n log n)*    | *O(n)*          | 事件处理简单高效 |
   | 离散化+暴力覆盖   | 数组              | *O(n²)*         | *O(n)*          | 数据量较小       |
   | 线段树+离散化     | 线段树            | *O(n log n)*    | *O(n)*          | 需要动态区间覆盖 |

---

### **题解评分 ≥4星**

1. **Expecto（4星）**  
   - **亮点**：通过事件排序和集合维护活动牛，代码简洁高效。  
   - **关键代码**：
     ```cpp
     sort(events.begin(), events.end());
     set<int> active, seen;
     for (auto &e : events) {
         if (e.y > 0) active.insert(e.y);
         else active.erase(-e.y);
         if (!active.empty()) seen.insert(*active.begin());
     }
     ```

2. **曹老师（4星）**  
   - **亮点**：线段树动态维护区间覆盖，支持离散化和左闭右开区间。  
   - **关键代码**：
     ```cpp
     build(1, 1, cnt);
     for (int i=1; i<=n; i++) {
         if (!query(1, node[i].l, node[i].r-1)) ans++;
         update(1, node[i].l, node[i].r-1);
     }
     ```

3. **Na2PtCl6（4星）**  
   - **亮点**：通过乘2扩大离散化精度，避免区间端点冲突。  
   - **关键代码**：
     ```cpp
     sc[i] = (-x[i]-1)*r[i] * 2;
     sc[i+n] = (-x[i])*r[i] * 2;
     ```

---

### **最优思路或技巧提炼**

1. **扫描线+最小堆**  
   - 将事件点排序后，维护当前活动的最小 `y` 值，避免重复计算区间覆盖。  
   - **实现关键**：用 `set` 或优先队列维护活动牛的 `y` 值，每次取最小值。

2. **离散化+左闭右开区间**  
   - 离散化时间端点后，将区间调整为左闭右开，避免边界冲突。  
   - **示例**：牛的时间区间 `[st, ed]` 离散化为 `[st_idx, ed_idx)`。

3. **线段树懒标记优化**  
   - 线段树更新时通过懒标记（`lazy`）延迟操作，减少重复覆盖的计算量。

---

### **同类型题或类似算法套路**

- **区间覆盖问题**：如贴海报、会议室安排等。  
- **扫描线算法**：如矩形面积并（[P1884](https://www.luogu.com.cn/problem/P1884)）、天际线问题。

---

### **推荐相似题目**

1. **P1884 覆盖**  
   - 求矩形覆盖面积，扫描线算法经典应用。

2. **P1496 火烧赤壁**  
   - 区间覆盖统计，需离散化处理。

3. **P5490 扫描线**  
   - 模板题，练习线段树与扫描线结合。

---

### **可视化与算法演示**

**动画方案**：  
1. **时间轴与事件点**  
   - 水平时间轴标记所有事件点（进入/离开），颜色区分事件类型（绿色为进入，红色为离开）。  
   - 当前处理的事件点高亮显示（黄色），活动牛集合用动态列表展示（右侧面板）。  

2. **活动集合更新**  
   - 进入事件：将牛 `y` 值加入集合，更新最小 `y` 值（蓝色高亮）。  
   - 离开事件：移除对应 `y` 值，若集合非空，显示新的最小 `y`（绿色高亮）。  

3. **复古像素风格**  
   - **Canvas 绘制**：时间轴为8位像素风格，牛图标为16x16像素块，音效使用FC风格音效库。  
   - **自动演示模式**：按时间步进播放，支持暂停/继续，速度可调。  

**核心代码片段（JS伪代码）**：  
```javascript
class Event {
  constructor(time, y, isEnter) {
    this.time = time;
    this.y = isEnter ? y : -y;
  }
}

function visualize() {
  events.sort((a, b) => a.time - b.time);
  let active = new Set();
  let seen = new Set();
  for (let e of events) {
    if (e.y > 0) active.add(e.y);
    else active.delete(-e.y);
    if (active.size > 0) {
      seen.add(Math.min(...active));
    }
    drawActiveSet(active); // Canvas 更新活动集合
  }
}
```

---

### **个人心得摘录**

- **调试踩坑**（Expecto题解）：  
  > “本蒟蒻想了好久……注意离散化时的取值略加修改。WA是因为区间端点未正确处理。”  
  **总结**：离散化需明确区间开闭，乘2或调整端点可避免冲突。

- **线段树优化**（曹老师题解）：  
  > “懒标记不仅要下传，还要上传合并区间状态。”  
  **总结**：线段树需注意懒标记的完整传递和区间合并逻辑。

---
处理用时：80.06秒
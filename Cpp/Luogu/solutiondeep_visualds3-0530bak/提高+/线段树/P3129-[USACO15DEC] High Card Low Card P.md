# 题目信息

# [USACO15DEC] High Card Low Card P

## 题目描述

奶牛 Bessie 是卡牌游戏的狂热爱好者，这相当令人惊讶，因为她没有灵活的手指。不幸的是，牛群中的其他奶牛都不是好的对手。事实上，她们的表现非常糟糕，总是以完全可预测的方式出牌！尽管如此，对 Bessie 来说，如何获胜仍然是一个挑战。

Bessie 和她的朋友 Elsie 正在玩一个简单的卡牌游戏。她们拿一副 $2N$ 张牌，方便地编号为 $1 \ldots 2N$，并将其分成 $N$ 张牌给 Bessie 和 $N$ 张牌给 Elsie。然后，两人进行 $N$ 轮游戏，每轮 Bessie 和 Elsie 各打出一张牌。最初，打出更高牌的玩家得一分。然而，在游戏中的某个时刻，Bessie 可以决定改变规则，使得在接下来的游戏中，打出更低牌的玩家得一分。Bessie 可以选择不使用这个选项，让整个游戏保持在“高牌获胜”模式，或者她也可以立即启用这个选项，让整个游戏遵循“低牌获胜”的规则。

已知 Bessie 可以预测 Elsie 出牌的顺序，请确定 Bessie 可以获得的最大分数。

## 说明/提示

在这里，Bessie 手中的牌必须是 2、5、6 和 7，她最多可以利用这些牌赢得 3 分。例如，她可以先击败 1 这张牌，然后将规则切换为“低牌获胜”，之后她可以再赢得两轮。

## 样例 #1

### 输入

```
4
1
8
4
3```

### 输出

```
3```

# AI分析结果



# [USACO15DEC] High Card Low Card P

**唯一算法分类**：贪心

---

## **题解思路与算法要点**

### **核心思路**
1. **前后缀分解**：  
   - 预处理两个数组 `f[i]` 和 `g[i]`，分别表示前 `i` 轮使用“高牌获胜”规则的最大得分，以及从第 `i` 轮开始使用“低牌获胜”规则的最大得分。  
   - 枚举分界点 `k`，答案取 `max(f[k] + g[k+1])`，即前 `k` 轮用高规则，后 `n-k` 轮用低规则。

2. **贪心选牌**：  
   - **高规则**：每次选择比对方当前牌大的最小可用牌（`lower_bound` 找后继）。  
   - **低规则**：每次选择比对方当前牌小的最大可用牌（反向用 `lower_bound` 找前驱）。  
   - **数据结构**：用 `set` 维护可用牌，实现快速查找和删除。

3. **正确性证明**：  
   - 若某张牌被重复使用，可通过替换未使用的更优牌调整方案，确保总得分不减少。

---

## **题解评分（≥4星）**

1. **yukuai26（5星）**  
   - 思路清晰，代码简洁，利用 `set` 快速查找。  
   - 关键亮点：通过正反 `set` 预处理 `f` 和 `g`，时间复杂度 `O(n log n)`。

2. **functionendless（4星）**  
   - 提供正确性证明，解释重复牌的替换策略。  
   - 代码实现稍显冗长，但逻辑明确。

3. **AcerMo（4星）**  
   - 代码简练，反向 `set` 查询时通过 `it--` 巧妙处理前驱。  
   - 无冗余操作，直接遍历分界点。

---

## **最优思路与技巧**

1. **贪心预处理**：  
   - 分别计算前缀和后缀的最大得分，确保局部最优解的组合为全局最优。

2. **数据结构优化**：  
   - 使用 `set` 维护可用牌，快速查找并删除已用牌，避免重复。

3. **分界点枚举**：  
   - 枚举所有可能的规则切换点，取最大值。

---

## **相似题目推荐**
1. [P3143 [USACO16OPEN] Diamond Collector S](https://www.luogu.com.cn/problem/P3143)  
   - 分界点枚举与前后缀处理。
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)  
   - 贪心策略与数据结构优化。
3. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)  
   - 贪心选择最优删除顺序。

---

## **可视化与算法演示**

### **核心算法流程**
1. **初始化牌池**：  
   - 对方出牌序列为 `[1, 8, 4, 3]`，Bessie 的牌为 `[2, 5, 6, 7]`。  
   - 用两个 `set` 分别维护高规则和低规则的可用牌。

2. **前缀处理（高规则）**：  
   - 对每轮 `i`，找到比 `a[i]` 大的最小牌（绿色高亮），删除该牌，得分 `+1`。  
   - **动画**：牌池动态缩小，当前选中牌闪烁。

3. **后缀处理（低规则）**：  
   - 对每轮 `i`，找到比 `a[i]` 小的最大牌（红色高亮），删除该牌，得分 `+1`。  
   - **动画**：反向遍历，牌池更新，当前牌标记为红色。

4. **合并结果**：  
   - 遍历所有分界点，计算 `f[i] + g[i+1]`，取最大值。

### **复古游戏化设计**
- **像素风格**：卡牌以 8-bit 方块表示，高规则用绿色，低规则用红色。  
- **音效**：得分时播放“升级”音效，切换规则时播放“开关”音效。  
- **自动演示**：按帧逐步展示选牌过程，支持暂停/继续。

---

## **代码实现（关键片段）**

```cpp
#include <set>
#include <iostream>
using namespace std;

int main() {
    int n, a[100005], f[100005], g[100005];
    set<int> high, low;

    // 初始化牌池
    for (int i = 1; i <= 2*n; ++i) {
        if (!vis[i]) {
            high.insert(i);
            low.insert(-i); // 反向存储
        }
    }

    // 计算前缀 f[i]
    for (int i = 1; i <= n; ++i) {
        auto it = high.lower_bound(a[i]);
        if (it != high.end()) {
            high.erase(it);
            f[i] = f[i-1] + 1;
        } else f[i] = f[i-1];
    }

    // 计算后缀 g[i]
    for (int i = n; i >= 1; --i) {
        auto it = low.lower_bound(-a[i]);
        if (it != low.end()) {
            low.erase(it);
            g[i] = g[i+1] + 1;
        } else g[i] = g[i+1];
    }

    // 合并结果
    int ans = 0;
    for (int i = 0; i <= n; ++i)
        ans = max(ans, f[i] + g[i+1]);
    cout << ans;
    return 0;
}
```

---

**总结**：通过贪心预处理前后缀得分，结合分界点枚举，实现了高效求解。核心在于 `set` 的灵活使用和替换策略的正确性保证。

---
处理用时：69.48秒
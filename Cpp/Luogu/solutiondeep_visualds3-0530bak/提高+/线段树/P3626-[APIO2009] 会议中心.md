# 题目信息

# [APIO2009] 会议中心

## 题目描述

Siruseri 政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很 感兴趣，他们希望能够在里面举行会议。

对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。 会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。

显 然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有 4 个公司。他们对租借会堂发出了请求，并提出了 他们所需占用会堂的起止日期（如下表所示）。

```cpp
       开始日期 结束日期 
 公司1    4        9 
 公司2    9        11 
 公司3    13       19 
 公司4    10       17 
```
上例中，最多将会堂租借给两家公司。租借策略分别是租给公司 1 和公司 3， 或是公司 2 和公司 3，也可以是公司 1 和公司 4。注意会议中心一天最多租借给 一个公司，所以公司 1 和公司 2 不能同时租借会议中心，因为他们在第九天重合 了。

销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首 先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出 其中字典序最小1的候选策略作为最终的策略。

例中，会堂最终将被租借给公司 1 和公司 3：3 个候选策略是 {(1,3),(2,3),(1,4)}。而在字典序中(1,3)<(1,4)<(2,3)。 你的任务是帮助销售主管确定应该将会堂租借给哪些公司。


## 说明/提示

对于 50%的输入，N≤3000。

在所有输入中，N≤200000。


## 样例 #1

### 输入

```
4 
4 9
9 11 
13 19 
10 17```

### 输出

```
2
1 3```

# AI分析结果



### 【算法分类】
**贪心 + 倍增 + 离散化**

---

### 【核心思路与难点分析】

**问题核心**：  
在保证最大不相交线段数量的前提下，选择字典序最小的线段集合。

**核心思路**：  
1. **第一问**：经典最大不相交区间问题，贪心选右端点最小的线段  
2. **第二问**：  
   - 按编号顺序尝试加入每个线段  
   - 若加入后不影响总数量，则必须选择（保证字典序最小）  
   - 使用倍增快速计算区间可容纳线段数  
   - 用 set 维护已选线段的前驱/后继关系

**关键技巧**：  
```text
当尝试加入线段 [l,r] 时：
1. 在已选线段中找到最近的左区间 L 和右区间 R
2. 检查条件：原区间 [L.r+1, R.l-1] 的最大线段数 = 
   [L.r+1, l-1] 的最大数 + [r+1, R.l-1] 的最大数 + 1
3. 若成立则保留该线段
```

**可视化设计要点**：  
1. **Canvas 动态绘制**：  
   - 绿色块表示已选线段，红色块表示候选线段  
   - 当前检测线段用闪烁黄色边框标记  
   - 显示倍增查询时的跳跃过程（虚线箭头）  
2. **音效提示**：  
   - 成功加入线段时播放 "coin.wav"  
   - 跳过线段时播放 "error.wav"  
3. **8-bit 风格**：  
   - 线段用 16x16 像素块表示  
   - 编号显示为复古字体  
   - 背景音乐使用 chiptune 风格循环

---

### 【最优题解评分】

#### 题解1：jjsnam（★★★★★）
- **亮点**：  
  1. 完整解释倍增预处理方法  
  2. 详细分析 set 维护前驱/后继的技巧  
  3. 提供哨兵线段简化边界判断  
- **关键代码**：  
  ```cpp
  // 倍增查询区间最大线段数
  int getMx(int st, int r) {
      int res = 0;
      for(int k=Log2; k>=0; k--)
          if(seg[ne[st][k]].r <= r)
              res += (1<<k), st = ne[st][k];
      return res;
  }
  ```

#### 题解2：喵仔牛奶（★★★★☆）
- **亮点**：  
  1. 使用珂朵莉树维护区间  
  2. 代码结构简洁  
- **优化点**：  
  ```cpp
  // 离散化后处理区间覆盖
  if(get_ans(now.l, l-1) + get_ans(r+1, now.r) +1 == get_ans(now.l, now.r))
      insert_to_set();
  ```

#### 题解3：kczno1（★★★★☆）
- **亮点**：  
  1. 手动二分优化查询  
  2. 动态规划结合倍增  
- **关键片段**：  
  ```cpp
  // 维护前缀最小字典序
  for(int j=21;j>=0;j--)
      if(Min[u][j] != Min[v][j])
          ... // 比较链上最小值
  ```

---

### 【核心算法实现】

**倍增预处理**：  
```cpp
// 预处理每个线段的跳跃指针
for(int i=n; i>0; --i) {
    f[i][0] = next_segment_id;
    for(int j=1; j<=20; ++j)
        f[i][j] = f[f[i][j-1]][j-1];
}

// 查询区间 [L,R] 的最大线段数
int query(int L, int R) {
    int cnt = 0, cur = L;
    for(int j=20; j>=0; --j) {
        if(f[cur][j] <= R) {
            cnt += (1<<j);
            cur = f[cur][j];
        }
    }
    return cnt;
}
```

---

### 【相似题目推荐】
1. P1803 线段覆盖（基础贪心）  
2. P2896 [USACO08FEB]连击游戏（区间分组+字典序）  
3. P2949 工作调度（贪心+优先队列）

---

### 【可视化示例】
**动画流程**：  
1. 初始化显示所有线段（灰色）  
2. 按编号遍历线段，检测能否加入：  
   - 若通过条件检查：线段变绿，播放音效  
   - 否则变红后恢复原色  
3. 当前检测线段高亮显示编号  
4. 侧边栏显示已选线段集合的字典序

**交互设计**：  
```javascript
// 伪代码示例
class Segment {
    constructor(l, r, id) {
        this.l = l; this.r = r; 
        this.id = id;
        this.color = '#888';
    }
    
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(l*scaleX, 100, (r-l)*scaleX, 20);
        drawTextCenter(ctx, this.id, ...);
    }
}

function checkSegment(seg) {
    let L = findPrev(seg.l);
    let R = findNext(seg.r);
    let original = queryMax(L, R);
    let newVal = queryMax(L, seg.l-1) + 
                 queryMax(seg.r+1, R) + 1;
    return newVal >= original;
}
```

---

### 【总结】
该题结合了贪心策略与高效数据结构，**核心突破点在于如何快速验证每个线段的加入可行性**。通过倍增预处理和 set 的巧妙使用，将时间复杂度控制在 O(n log n)，是处理复杂区间问题的经典范式。

---
处理用时：68.28秒
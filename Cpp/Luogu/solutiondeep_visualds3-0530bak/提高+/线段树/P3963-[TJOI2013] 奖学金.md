# 题目信息

# [TJOI2013] 奖学金

## 题目背景

小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。

## 题目描述

小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  
要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。


## 说明/提示

### 样例 1 解释

选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^3$，$c \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $3 \leq n  \leq 10^5$，$n \leq c \leq 2 \times 10^5$，$0 \leq f \leq 2\times 10^9$，$0 \leq a_i \leq 2 \times 10^9$，$0 \leq b_i \leq 10^5$。

## 样例 #1

### 输入

```
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出

```
35```

## 样例 #2

### 输入

```
5 6 9
4 0
4 1
6 3
8 0
10 4
10 5
```

### 输出

```
6```

# AI分析结果



## 算法分类
**贪心 + 优先队列/堆**

---

## 综合分析与结论

### 核心思路
1. **排序预处理**：将所有学生按成绩升序排序
2. **双堆维护**：用大根堆预处理每个位置左右两侧前k小奖学金的和
   - 左堆维护中位数左侧前k小奖学金
   - 右堆维护中位数右侧前k小奖学金
3. **枚举验证**：从成绩高到低枚举可能的中位数，验证左右堆和+中位数奖学金是否≤f

### 解决难点
- **动态维护前k小和**：通过大根堆动态保留k个最小元素，保证堆顶是当前k元素中的最大值
- **预处理优化**：正反两次遍历分别计算左右两侧的前缀和数组，避免重复计算

### 可视化设计
1. **像素化数组展示**：用不同颜色区分已选/未选学生，中位数高亮为金色方块
2. **堆动态演示**：以8-bit风格绘制左右堆，堆顶元素用闪烁特效
3. **音效反馈**：
   - 元素入堆时播放"咔"声
   - 替换堆顶元素时播放"叮"声
   - 找到合法解时播放胜利音效
4. **自动演示模式**：AI自动从后往前遍历，每步展示堆维护过程

---

## 题解清单（≥4星）

### 1. 胖头鱼学员（★★★★★）
- **亮点**：双堆预处理思路清晰，代码简洁高效
- **核心代码**：
```cpp
priority_queue<int> q;
for(int i=1;i<=c-n/2-1;i++){
    if(i<=(m/2)) q.push(a[i].w),sum += a[i].w;
    else if(a[i].w<q.top()) {
        sum += a[i].w - q.top();
        q.pop(); q.push(a[i].w);
    }
    f[i] = sum;
}
```

### 2. ycyaw（★★★★☆）
- **亮点**：反向遍历处理右堆，变量命名规范
- **优化点**：使用固定数组替代STL优先队列（实测效率更高）

### 3. ix35（★★★★☆）
- **特色**：权值线段树实现，提供不同解法参考
- **心得**：强调叶子节点需返回k*val的细节处理

---

## 最优思路提炼

### 关键技巧
1. **逆序贪心枚举**：从高成绩向低枚举，首个合法解即为最优
2. **堆维护前k小和**：
   - 维护容量为k的大根堆
   - 新元素比堆顶小时替换，动态维护最小和
3. **双前缀和数组**：
   - `f[i]`记录前i项的最小k和
   - `g[i]`记录后i项的最小k和

### 代码模板
```cpp
sort(students); // 按成绩排序
build_left_heap();  // 从左到右预处理左堆
build_right_heap(); // 从右到左预处理右堆

for(int i=中位数候选区间){
    if(left_sum[i] + right_sum[i] + mid_value <= f)
        return current_score;
}
```

---

## 相似题目推荐

1. **P1168 中位数**（动态维护中位数）
2. **P3871 中位数**（带修改操作的中位数维护）
3. **P1801 黑匣子**（动态维护第k小值）

---

## 可视化核心逻辑

```javascript
// 伪代码演示堆维护动画
class ScholarshipVisualizer {
    constructor(data) {
        this.students = data.sort((a,b) => a.grade - b.grade);
        this.leftHeap = new MaxHeap();
        this.rightHeap = new MaxHeap();
    }

    animate() {
        // 预处理左堆
        for(let i=0; i<this.students.length; i++){
            this.highlightStudent(i, 'blue');
            if(this.leftHeap.size < k) {
                this.leftHeap.add(students[i].money);
                playSound('pop');
            } else if(students[i].money < this.leftHeap.peek()) {
                this.leftHeap.replace(students[i].money);
                playSound('swap');
            }
            updateLeftSumDisplay();
        }
        
        // 逆序处理右堆
        // ...类似逻辑...
        
        // 枚举中位数
        for(let i=midStart; i>=midEnd; i--){
            this.highlightStudent(i, 'gold');
            if(checkSumValid()){
                playVictoryAnimation();
                return;
            }
        }
    }
}
```

---

## 调试心得摘录

> "调试两天发现叶子节点必须返回k*b[l]，因为同一节点可能存储多个相同奖学金值" —— 渡墨残殇  
> **启示**：离散化处理时需考虑重复元素的累积计算

> "反向遍历时堆维护顺序易错，必须从后往前更新右堆" —— ycyaw  
> **启示**：双堆预处理方向需与枚举方向配合

---

## 复古动画要素

1. **8-bit风格**：
   - 学生成绩条用绿色像素块表示
   - 堆结构显示为红色砖块堆叠
2. **音效设计**：
   - 背景音乐：8-bit版《卡农》循环
   - 堆操作音效：FC风格电子音
3. **成就系统**：
   - 连续找到3个合法解解锁"奖学金猎手"成就
   - 首次正确解答播放烟花特效

通过将算法过程游戏化，使学习者能在趣味交互中掌握贪心策略与堆维护技巧。

---
处理用时：68.46秒
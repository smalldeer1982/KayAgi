# 题目信息

# 【模板】扫描线 & 矩形面积并

## 题目描述

求 $n$ 个四边平行于坐标轴的矩形的面积并。

## 说明/提示

对于 $20\%$ 的数据，$1 \le n \le 1000$。  
对于 $100\%$ 的数据，$1 \le n \le {10}^5$，$0 \le x_1 < x_2 \le {10}^9$，$0 \le y_1 < y_2 \le {10}^9$。

Updated on 4.10 by Dengduck（口胡） \& yummy（实现）：增加了一组数据。

## 样例 #1

### 输入

```
2
100 100 200 200
150 150 250 255
```

### 输出

```
18000
```

# AI分析结果



---

## 唯一算法分类
扫描线算法（线段树优化）

---

## 综合分析与结论

### 核心算法流程
1. **事件预处理**：将每个矩形拆分为上下两条边（下边权值+1，上边权值-1），按y坐标排序
2. **离散化处理**：将x坐标离散化映射到线段树区间
3. **线段树维护**：
   - 节点存储区间被覆盖次数（cnt）和有效长度（len）
   - 更新规则：若覆盖次数>0则len=区间长度，否则合并子节点len
4. **扫描计算**：依次处理每个扫描线事件，累加相邻事件间的高度差与当前有效长度的乘积

### 可视化设计要点
1. **像素动画**：
   - 使用16色调色板，绿色表示当前扫描线，蓝色表示覆盖区域
   - 用不同色块区分线段树节点状态（红：覆盖1次，橙：覆盖多次）
2. **交互面板**：
   - 步进控制展示每个扫描线事件的处理过程
   - 实时显示线段树结构及当前有效长度
3. **音效系统**：
   - 添加事件时播放上升音调（800Hz）
   - 移除事件时播放下降音调（400Hz）
   - 完成面积计算时播放8-bit胜利音效

---

## 题解清单（⭐≥4）

1. **NCC79601（⭐⭐⭐⭐⭐）**
   - 亮点：清晰图解扫描线原理，完整注释线段树维护逻辑
   - 代码关键点：用`X[r+1] - X[l]`处理离散化区间映射

2. **Gu_Pigeon（⭐⭐⭐⭐）**
   - 亮点：详细解释离散化与线段树映射关系，提供可视化GIF
   - 个人心得：强调"线段树维护线段而非点"的核心思想

3. **MakiseVon（⭐⭐⭐⭐）**
   - 亮点：精简代码实现，用`pushup`替代标记下传
   - 优化点：`unique`去重与`lower_bound`查找的完美配合

---

## 核心代码实现

### 离散化与事件处理
```cpp
vector<int> xs; // 离散化数组
for (auto &[x1,y1,x2,y2] : rects) {
    lines.push_back({x1, y1, y2, 1});  // 入边
    lines.push_back({x2, y1, y2, -1}); // 出边
    xs.push_back(x1); xs.push_back(x2);
}
sort(xs.begin(), xs.end());
xs.erase(unique(xs.begin(), xs.end()), xs.end());
```

### 线段树关键逻辑
```cpp
struct Node {
    int cnt;    // 覆盖次数
    int len;    // 有效长度
} tr[N * 4];

void pushup(int u, int l, int r) {
    if (tr[u].cnt) tr[u].len = xs[r+1] - xs[l];
    else if (l == r) tr[u].len = 0;
    else tr[u].len = tr[u<<1].len + tr[u<<1|1].len;
}

void update(int u, int l, int r, int L, int R, int v) {
    if (xs[r+1] <= L || R <= xs[l]) return;
    if (L <= xs[l] && xs[r+1] <= R) {
        tr[u].cnt += v;
        pushup(u, l, r);
        return;
    }
    int mid = (l + r) >> 1;
    update(u<<1, l, mid, L, R, v);
    update(u<<1|1, mid+1, r, L, R, v);
    pushup(u, l, r);
}
```

---

## 同类型题目推荐
1. **P1856 [USACO5.5]矩形周长Picture**（周长并问题）
2. **P5815 [CQOI2005]三角形覆盖问题**（动态覆盖统计）
3. **P1502 窗口的星星**（带权值扫描线）

---

## 调试心得分录
- **越界陷阱**：线段树应开8倍空间（每个矩形产生2个事件）
- **精度灾难**：必须用`lower_bound`处理离散化映射，直接除法会丢失精度
- **排序稳定性**：y坐标相同时，入边要先于出边处理

---

## 可视化演示设计
```javascript
// 伪代码示例：像素动画核心逻辑
class ScanlineViz {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.palette = ['#2C3E50', '#E74C3C', '#3498DB', '#2ECC71']; // 像素风格配色
    }

    drawStep(lines, currentY) {
        // 绘制当前扫描线
        this.ctx.fillStyle = this.palette[2];
        this.ctx.fillRect(0, currentY, canvas.width, 2);
        
        // 绘制覆盖区域
        activeRects.forEach(rect => {
            this.ctx.fillStyle = this.palette[3];
            this.ctx.fillRect(rect.x1, rect.y1, rect.x2-rect.x1, currentY-rect.y1);
        });
    }

    playSound(freq) {
        // 8-bit音效生成
        const osc = new OscillatorNode(ctx, {frequency: freq});
        osc.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.1);
    }
}
```

---

**通过上述设计与实现，学习者可直观理解扫描线算法的运行机制，配合交互式调试体验，深化对线段树维护区间覆盖的理解**

---
处理用时：82.52秒
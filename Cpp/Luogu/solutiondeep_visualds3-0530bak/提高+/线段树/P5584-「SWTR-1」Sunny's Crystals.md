# 题目信息

# 「SWTR-1」Sunny's Crystals

## 题目背景

小 $\mathrm{S}$ 喜欢收集水晶。

## 题目描述

小 $\mathrm{S}$ 有 $n$ 个水晶，每个水晶有一个属性 $d_i$ ，为这个水晶的**价值**。

有一天，小 $\mathrm{A}$ 来到了 小 $\mathrm{S}$ 家，让 小 $\mathrm{S}$ 把他的水晶排成一个序列，并且摧毁所有价值为 $w$ 的水晶。

但是，由于这个序列的特殊性，你的每次摧毁必须要满足：

- 该水晶在序列里的位置**必须要是 $2$ 的次幂**，即你只能摧毁在 $2^x$ 这个位置上的水晶，$0\leq x \leq \log_2 y$ 且为整数，其中 $y$ 为现在序列里水晶的个数。

摧毁后，**所有在该水晶后面的水晶都会向前移动一格**。

例如，水晶价值序列 $6\  10\  4\  7\  8$，你只能摧毁位置为 $1,2,4$ 上的水晶。

如果摧毁 $2$ 号水晶，序列就会变成 $6\  4\  7\  8$。

为了节省时间，小 $\mathrm{S}$ 想知道**最少**多少次可以摧毁所有价值为 $w$ 的水晶，且第 $i$ 次摧毁的水晶初始位置是什么。

**本题使用 Special Judge**，如果有多种答案，任意输出一种即可。

## 说明/提示

---

### 样例说明

样例 $1$：

先摧毁后面的 $4$，初始位置为 $4$，**价值**序列变成： $1\  4\  2\  5$。

再摧毁前面的 $4$，初始位置为 $2$。

总次数是 $2$ 次。

样例 $2$：

先摧毁第 $1$ 个 $2$，初始位置为 $2$，序列变成：$1\  2\  2\  2$。

再摧毁剩下的第 $1$ 个 $2$，初始位置为 $3$，序列变成：$1\  2\  2$。

再摧毁第一个 $2$，初始位置为 $4$，序列变成：$1\  2$。

再摧毁第一个 $2$，初始位置为 $5$。

总次数是 $4$ 次。

---

### 数据范围与约定

对于 $15\%$ 的数据，有 $n\leq5$。

对于 $25\%$ 的数据，有 $n\leq20$。

对于 $30\%$ 的数据，有 $n\leq1000$。

对于 $35\%$ 的数据，有 $n\leq10000$。

对于 $50\%$ 的数据，有 $n\leq3\times 10^5$。

对于 $80\%$ 的数据，有 $n\leq10^6$。

对于 $100\%$ 的数据，有 $1\leq n\leq3\times 10^6,1\leq d_i\leq 40000$，保证 $w$ 的个数不大于 $1.5\times 10^6$。

---

碎掉的水晶在阳光下闪闪发光……

## 样例 #1

### 输入

```
5 4
1 4 2 4 5```

### 输出

```
2
4 2```

## 样例 #2

### 输入

```
5 2
1 2 2 2 2```

### 输出

```
4
2 3 4 5```

## 样例 #3

### 输入

```
5 8
6 10 4 7 8```

### 输出

```
2
4 5```

# AI分析结果



---

## 唯一算法分类  
**贪心算法 & 数据结构优化**

---

## 综合分析与结论  
### 核心问题与解法要点  
题目要求通过最少的操作摧毁所有目标水晶，每次操作只能摧毁 2 的次幂位置。关键难点在于动态维护可摧毁位置，并高效选择最优操作。所有题解均基于以下贪心策略：  
1. **优先摧毁最靠后的目标水晶**（避免影响后续操作）  
2. **若无可摧毁目标，摧毁最前面的非目标水晶**（最大化位置调整效果）  

### 算法实现对比  
#### 线段树解法（Alex_Wei、Acestar、Fzrcy）  
- **核心变量**：`dis[i]` 表示第 `i` 个目标水晶到最近可摧毁位置的距离。  
- **数据结构**：线段树维护 `dis` 的最小值，支持区间减 1 操作。  
- **关键步骤**：  
  - 查询最小值为 0 的最靠后位置（摧毁目标）  
  - 若最小值非 0，批量摧毁非目标水晶至最小值归零  
  - **可视化要点**：线段树节点颜色标记最小值变化，高亮区间减 1 操作。  

#### 指针模拟解法（localhost、Mine_King）  
- **核心变量**：维护一组指针 `p[b]`，指向当前每个 2 的次幂位置。  
- **操作优化**：每次摧毁后，调整后续指针右移跳过已摧毁位置。  
- **复杂度**：`O(n log n)`，常数极小。  
- **可视化要点**：动态显示指针移动，用不同颜色标记有效/无效位置，音效提示摧毁动作。  

### 复古像素化设计  
- **Canvas 动画**：  
  - 水晶序列以 8-bit 像素方块表示，目标水晶用红色，可摧毁位置闪烁黄框。  
  - 每次操作后，后方水晶前移动画（像素平移效果）。  
- **音效**：  
  - 摧毁目标时播放高音“叮”，摧毁非目标时播放低音“咚”。  
  - 背景音乐为 8-bit 风格循环旋律。  
- **游戏化**：将操作分为关卡，每摧毁一个目标得 10 分，连续摧毁触发连击奖励。  

---

## 题解清单（≥4星）  
1. **localhost 的指针模拟解法（5星）**  
   - **亮点**：代码简洁高效，无需复杂数据结构，实测性能优于线段树。  
   - **关键代码**：  
     ```cpp  
     while(tot) {
         bool f=0;
         Fdr(i,b,1) if(a[p[i]]==w) { // 从高位指针开始找目标
             ANS[++ans]=p[i];
             a[p[i]]=0; // 标记已摧毁
             Fur(j,i,b) while(!a[++p[j]]); // 调整后续指针
             --tot; f=1; break;
         }
         if(!f) { // 无目标可摧毁
             ANS[++ans]=p[1];
             Fur(i,1,b) while(!a[++p[i]]);
         }
     }
     ```  
   - **个人心得**：通过逆向遍历指针快速找到最靠后目标，实测比正向快 20%。  

2. **Alex_Wei 的线段树解法（4星）**  
   - **亮点**：理论严谨，区间修改与查询逻辑清晰。  
   - **关键代码**：  
     ```cpp  
     void update(int L,int R,int l,int r,int rt) {
         if(L<=l && r<=R) { laz[rt]++; t[rt]--; return; }
         push_down(rt);
         if(L<=mid) update(L,R,l,mid,ls);
         if(R>mid) update(L,R,mid+1,r,rs);
         t[rt] = min(t[ls], t[rs]);
     }
     ```  
   - **调试经验**：懒惰标记需在查询前下推，否则会导致错误。  

3. **Mine_King 的指针维护解法（4星）**  
   - **亮点**：通过预计算 2 的次幂位置，减少运行时计算。  
   - **优化技巧**：指针数组 `p[b]` 初始化为 `2^x`，动态调整时跳过已删除元素。  

---

## 同类型题与推荐  
1. **区间覆盖问题**（如 [P2082 区间覆盖](https://www.luogu.com.cn/problem/P2082)）  
   - 类似动态维护可用区间。  
2. **任务调度优化**（如 [P5815 任务调度](https://www.luogu.com.cn/problem/P5815)）  
   - 贪心选择最优执行顺序。  
3. **数据结构应用**（如 [P3372 线段树模板](https://www.luogu.com.cn/problem/P3372)）  
   - 区间修改与极值查询。  

---

## 可视化算法演示  
### 核心流程（以指针模拟法为例）  
1. **初始化**：  
   - 绘制水晶序列，标记目标为红色，非目标为蓝色。  
   - 显示 2 的次幂位置指针（黄框）。  
2. **摧毁操作**：  
   - 若存在目标：  
     - 播放高音，红色方块爆炸特效，后方方块左移。  
     - 指针向右滑动至下一个有效位置。  
   - 若无目标：  
     - 播放低音，首个蓝色方块变灰，指针集体右移。  
3. **胜利条件**：所有目标被摧毁后，播放胜利音效与烟花动画。  

### 交互设计  
- **控制面板**：暂停/继续、单步执行、调整动画速度（1x-5x）。  
- **数据面板**：显示当前操作次数、剩余目标数、连击计数。  

---

**答案至此结束，核心逻辑与可视化方案已完整呈现。**

---
处理用时：82.47秒
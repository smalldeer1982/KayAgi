# 题目信息

# 【模板】子序列自动机

## 题目背景

本题中，若 $x$ 是 $y$ 的子序列，则等价于存在一个**单调递增**序列 $z$，满足 $|z| = |x|$，$z_{|x|} \leq |y|$，且 $\forall i \in [1, ~|x|],~y_{z_i} = x_i$。其中 $|x|,~|y|,~|z|$ 分别代表序列 $x,~y,~z$ 的长度，$x_i,~y_i,~z_i$ 分别代表序列 $x,~y,~z$ 的第 $i$ 项。

这是一道在 ``yLOI2020`` 备选题里被毙掉的题目。

## 题目描述

给定一个长度为 $n$ 的正整数序列 $a$ ，有 $q$ 次询问，第 $i$ 次询问给定一个长度为 $L_i$ 的序列 $b_i$，请你判断 $b_i$ 是不是 $a$ 的子序列。序列 $a$ 和所有 $b_i$ 中的元素都不大于一个给定的正整数 $m$。

## 说明/提示

#### 样例 1 解释

- 对于第一次询问，原序列中没有 $5$，所以给定序列显然不是原序列的子序列。
- 对于第二次询问，存在两个合法的序列 $z$，分别是 $\{2,~3\}$ 和 $\{2,~4\}$。即 $a_{2} = b_{2, 1},~a_3 = b_{2, 2}$ 或 $a_2 = b_{2, 1},~a_{4} = b_{2, 2}$。这里 $b_{i, j}$ 代表序列 $b_i$ 的第 $j$ 个元素，序列 $z$ 的含义见【题目背景】，下同。
- 对于第三次询问，不存在合法的序列 $z$。
- 对于第四次询问，存在两个合法的序列 $z$，分别是 $\{1,~3,~5\}$ 和 $\{1,~4,~5\}$。
- 对于第五次询问，存在一个合法的序列 $z$，为 $\{1,~2,~3,~4,~5\}$。

#### 数据范围与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（20 points）：$type = 1$，$n, q, m \leq 100$，$\sum_{i = 1}^{q} l_i \leq 10^3$。
- Subtask 2（35 points）：$type = 2$，$n,q \leq 10^5$，$m \leq 26$，$\sum_{i = 1}^{q} l_i \leq 10^6$。
- Subtask 3（45 points）：$type = 3$，$n,q,m \leq 10^5$，$\sum_{i = 1}^q L_i \leq 10^6$。

对于全部的测试点，保证 $1 \leq n, m, q \leq 10^5$，$1 \leq a_i, b_{i, j} \leq m$，$1 \leq l_i \leq 10^6$，$\sum_{i = 1}^{q} l_i \leq 10^6$。


### 提示

- 请注意常数因子对程序效率造成的影响。
- 本题输入规模较大，请注意数据读入对程序效率造成的影响。
- 请注意输入第一行的顺序为先输入询问次数 $q$，再输入序列元素最大值 $m$。

## 样例 #1

### 输入

```
0 5 5 5
1 3 2 2 4
3 1 5 2
2 3 2
3 1 2 3
3 1 2 4
5 1 3 2 2 4
```

### 输出

```
No
Yes
No
Yes
Yes```

# AI分析结果



1. **唯一算法分类**  
   子序列自动机

---

2. **综合分析与结论**  

**核心思路**  
通过预处理原序列每个字符的出现位置，利用二分查找或可持久化线段树快速定位匹配点。核心目标是高效判断查询序列是否为原序列的子序列。

**解决难点**  
- **大字符集处理**：当字符集规模达到 1e5 时，直接存储每个位置的转移数组不可行。  
- **贪心优化**：每次匹配最靠前的字符位置以保证正确性。  
- **空间效率**：通过二分查找（vector 存储）或可持久化线段树避免存储全量转移数组。

**可视化设计**  
- **动画方案**：展示原序列的字符位置数组（如 `vector<int> v[5]`），用红色高亮当前查询字符，绿色箭头表示二分查找过程，蓝色标记找到的位置。  
- **步进控制**：允许单步执行匹配过程，观察指针如何从原序列起始位置逐步跳到匹配点。  
- **复古像素风格**：用 8-bit 方块表示字符位置，匹配成功时播放 "ping" 音效，失败时播放 "buzz" 音效。

---

3. **题解清单 (≥4星)**  

1. **AThousandSuns（5星）**  
   - **亮点**：利用 vector + 二分实现，代码简洁，时空效率极高。  
   - **关键代码**：  
     ```cpp
     vector<int> v[maxn]; // 存储每个值的出现位置
     bool check() {
         int at = 0;
         for (int x : query_seq) {
             auto it = lower_bound(v[x].begin(), v[x].end(), at + 1);
             if (it == v[x].end()) return false;
             at = *it;
         }
         return true;
     }
     ```

2. **一扶苏一（4星）**  
   - **亮点**：可持久化线段树实现子序列自动机，处理大字符集通用性强。  
   - **关键代码**：  
     ```cpp
     void build() { // 可持久化线段树构建
         for (int i = n; i >= 1; --i)
             upd(root[i-1], root[i], a[i], i);
     }
     ```

3. **虹（4星）**  
   - **亮点**：离线处理，通过队列动态维护待匹配查询，时间复杂度 O(∑L)。  
   - **关键代码**：  
     ```cpp
     list<int> lst[m];
     for (int i = 1; i <= q; ++i)
         lst[query[i][0]].push_back(i);
     ```

---

4. **最优思路提炼**  
**关键技巧**：对每个字符建立位置数组，匹配时贪心选择最靠前的可用位置，通过二分查找快速定位。  

**实现步骤**：  
1. 预处理：将原序列中每个字符的所有出现位置存入 vector。  
2. 匹配过程：维护当前匹配位置 `at`，对查询序列的每个字符，在其位置数组中二分查找第一个大于 `at` 的位置。  
3. 失败条件：若任意字符找不到合法位置，返回 false。

---

5. **同类型题推荐**  
- **LeetCode 392**：判断子序列（基础版）  
- **洛谷 P3500**：[POI2010] DIV-Divisibility（扩展应用）  
- **CodeForces 1183H**：子序列删除问题（动态规划 + 子序列自动机）

---

6. **个人心得摘录**  
> "普及组选手的解法往往更注重实用性。当字符集较大时，二分查找法不仅代码简单，且常数极小，比赛时优先考虑这种解法。" —— AThousandSuns  

> "调试时发现，二分必须用 `lower_bound` 且起始位置要+1，否则会重复匹配同一个位置。" —— _lfxxx_

---

7. **可视化与算法演示**  
**像素动画方案**：  
- **Canvas 绘制**：  
  1. 将原序列 `a[]` 绘制为横向色块，不同颜色表示不同字符。  
  2. 查询序列 `b[]` 显示在下方，当前匹配字符高亮闪烁。  
  3. 每次匹配时，在原序列的对应色块上显示绿色边框，播放 "click" 音效。  

**AI 自动演示**：  
- **规则**：自动匹配字符，若成功则箭头跳转，失败时显示红色叉号。  
- **音效**：成功时播放 8-bit 风格胜利旋律，失败时播放低沉警示音。

**交互控制**：  
- 速度调节滑块控制匹配速度（100ms ~ 2s/步）。  
- 支持暂停/继续，拖拽进度条回放关键步骤。

---
处理用时：70.75秒
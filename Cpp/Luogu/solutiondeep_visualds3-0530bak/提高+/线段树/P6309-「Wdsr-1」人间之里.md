# 题目信息

# 「Wdsr-1」人间之里

## 题目背景

- 这里是幻想乡中最多人类居住的地方。因为有许多妖怪也会光临的店，所以会有各种妖怪到访，不过都是些安份的妖怪，这是一个和平的地方（×1稗田家所在地，毫无疑问也在人类村落。

- 人类必要的生活用品，都能在这里买到。也有一些专门退治妖怪的人住在这，所以这里的生活是较安全的。

- 要说人类村落为什么没有被袭击，那就是妖怪的贤者在背后保护（×2幻想乡的人类灭绝的话，妖怪们也不好过。）。不外出的话，就不会遇上大难。

- 若外出途中遇到比自己强的妖怪（×3高概率的对方比自己强。），就恭恭敬敬地打招呼吧。 还有令人意外的是，有很多店会开到深夜，夜晚会变成妖怪专用店。妖怪多在夜晚活动，店也在那段时间兴旺。可以说妖怪才是很好的客人。

- 特别是卖酒的店，妖怪和人类同乐已成了日常一景。

$$\tag*{——摘自《东方求闻史纪》}$$

## 题目描述

虽然人间之里可以说是全幻想乡对于人类最安全的地方，但是异变发生时，还是可能会出现意外，所以要建立避难所。

人间之里可以抽象为一条坐标轴，其上有 $n$ 个点上建有房屋。这些房屋的坐标分别为 $x_1,x_2,...,x_n$，且在第 $i$ 座房屋中居住着 $v_i$ 位居民。

每次发生异变时，会有一段**坐标连续**的房屋受到影响，而此时便需要在某一坐标处建立避难所。一个避难所的"不便程度"为受影响的房屋中的**每一个居民**与避难所的距离之和。  

（举例来说，假设只有房屋 $i$ 受到了影响，则在 $z$ 处建立避难所的"不便程度"为 $v_i*|x_i-z|$ ） 

当然，坐落在幻想乡中人间之里的不可能一成不变，所以房屋的位置和居民的数量都可能会发生变化。

具体来说，你需要处理 $m$ 次询问或修改，每一次输入的格式如下：

- `1 l r`，表示询问 当**坐标**位于 $[l,r]$ 范围内的房屋受到异变影响时，在所有建立避难所的方案中，最小的"不便程度"是多少。

- `2 a b c`，表示将第 $a$ 座房屋的坐标修改为 $b$，其中居住的村民的数量变为 $c$ 。 

**注意：**
- 在 $1$ 操作中的"受到异变影响"均为假设，所以对之后的查询不产生作用。

- 在 $2$ 操作中发生变化的是第 $a$ 座房屋而不是坐标为 $a$ 的房屋。



## 说明/提示

**【样例解释】**

对于第一个询问，共有两座房屋受到影响，一处位于 $x=4$ 处，有 $3$ 位村民，一处位于 $x=7$ 处，有 $6$ 位村民。

避难所选在 $x=7$ 处时，"不便程度"为：

$$\left\vert 7 - 4 \right\vert \times 3 + \left\vert 7 - 7 \right\vert \times 6 = 9$$

可以证明 $9$ 是所有建立避难所的方案中"不便程度"的最小值。

--------------------

**【数据范围】**

- 对于 $100\%$ 的数据：
    
    $1 \le n,m \le 3 \times 10 ^ 5$。

    $1 \le a \le n$，$-10 ^ 9 \le l \le r  \le 10 ^ 9 \le n$，$-10 ^ 9 \le x_i,b \le 10 ^ 9$，$0 \le  v_i,c \le 10 ^ 3$。

- **详细的数据范围：**

    设 $mx$ 为所有输入的整数绝对值的最大值。

    测试点编号 | $n,m \le$  | $mx \le$ | 分值
    :-: | :-: | :-: | :-:
    $1$ | $100$ | $100$ | $10$
    $2$ | $8 \times 10 ^ 3$ | $8 \times 10 ^ 3$ | $15$
    $3$ | $8 \times 10 ^ 3$ | $10 ^ 9$ | $5$
    $4$ | $10 ^ 5$ | $10 ^ 5$ | $30$
    $5$ | $10 ^ 5$ | $10 ^ 9$ | $10$
    $6$ | $3 \times 10 ^ 5$ | $10 ^ 9$ | $30$


## 样例 #1

### 输入

```
10 10
-2 -3 -7 2 -6 7 -3 -5 4 -7 
0 2 2 0 4 6 2 4 3 3 
1 4 7
1 -5 7
1 -1 8
2 8 9 2
2 7 -3 5
2 7 4 3
2 2 -1 7
1 -9 -7
2 2 3 1
1 -1 0
```

### 输出

```
9
82
9
0
0```

# AI分析结果



---

### **算法分类**
**数据结构（线段树/树状数组）**

---

### **题解思路与核心难点**
#### **核心思路**  
题目要求动态维护区间内房屋坐标与居民数，快速计算选定避难所的最小总距离。关键在于：  
1. **最优避难所位置**：为区间内带权中位数（总权重的一半位置）。  
2. **贡献计算**：拆解绝对值为前缀和表达式，维护 `v_i` 和 `v_i * x_i` 的区间和。  
3. **动态维护**：支持单点修改和区间查询，需高效数据结构（线段树/树状数组）。

#### **难点与解决**  
- **离散化处理**：坐标范围大（±1e9），需离散化或动态开点。  
- **快速定位中位数**：通过二分或线段树内部二分高效查找。  
- **贡献公式拆解**：将总距离拆解为与中位数位置相关的前缀和差。

---

### **题解评分（≥4星）**
1. **Jsxts_（树状数组，4星）**  
   - **亮点**：离线离散化，树状数组维护前缀和，代码简洁高效。  
   - **代码**：利用倍增法快速定位中位数，公式拆解清晰。  
   ```cpp
   // 关键代码：倍增查找中位数位置
   int l = q[i].l - 1;
   for (int j = 1 << 19; j; j >>= 1)
       l += (l + j <= q[i].r && getsum(l + j) - t <= s) * j;
   l++;
   ```
2. **AFewSuns（线段树，4星）**  
   - **亮点**：线段树维护动态区间，处理离散化与边界问题。  
   - **代码**：通过 `find_pre` 和 `find_nxt` 处理空节点，确保中位数有效。  
   ```cpp
   // 关键代码：线段树二分查找中位数
   ll mid = getc(0, 2e9, ro, 0, l - 1) + (getc(0, 2e9, ro, l, r) + 1) / 2;
   mid = find(head, 0, m, mid);
   ```
3. **Running_a_way（动态开点线段树，5星）**  
   - **亮点**：动态开点避免离散化，在线处理所有操作，最优解实现。  
   - **代码**：直接维护大范围坐标，高效查找与更新。  
   ```cpp
   // 关键代码：动态开点线段树更新
   void update(0, 2e9, ro, a[x], -b[x]);
   a[x] = y, b[x] = z;
   update(0, 2e9, ro, a[x], b[x]);
   ```

---

### **最优思路与技巧**
1. **带权中位数定位**：利用前缀和快速确定最小总距离的位置。  
2. **公式拆解优化**：将总距离拆解为 `v_i` 和 `v_i * x_i` 的线性组合，减少计算复杂度。  
3. **数据结构选择**：树状数组适合离线离散化，动态开点线段树适合在线大范围坐标。

---

### **同类型题目与套路**
- **类似问题**：动态维护中位数、区间带权重心查询。  
- **通用解法**：线段树/树状数组维护前缀和，结合二分或内部二分定位关键点。  
- **推荐题目**：  
  1. [P1364 医院设置](https://www.luogu.com.cn/problem/P1364)（静态带权重心）  
  2. [P3345 幻想乡战略游戏](https://www.luogu.com.cn/problem/P3345)（动态树重心维护）  
  3. [CF817F MEX Queries](https://codeforces.com/problemset/problem/817/F)（动态开点线段树）

---

### **可视化与算法演示**
#### **核心算法流程**  
1. **线段树节点更新**：  
   - 修改坐标时，动态调整线段树节点，高亮变化的坐标点（红色闪烁）。  
   - 显示当前节点的 `v_i` 和 `v_i * x_i` 总和。  
2. **中位数查找**：  
   - 在查询区间时，逐步二分查找中位数位置，用绿色箭头标记当前搜索范围。  
   - 显示前缀和累加过程（蓝色进度条）。  
3. **贡献计算**：  
   - 拆分区间为左半部分和右半部分，显示公式中的各项计算值。  

#### **复古像素风格设计**  
- **颜色方案**：  
  - 线段树节点：深绿色背景，白色文字显示数值。  
  - 当前操作节点：黄色高亮边框。  
  - 中位数位置：红色方块标记。  
- **音效**：  
  - 节点更新：短促“滴”声。  
  - 查找成功：上扬音调。  
- **Canvas 动画**：  
  - 网格化展示数轴，线段树节点以方块堆叠表示区间覆盖。  
  - 修改操作时，对应坐标点闪烁并显示数值变化。

---

### **代码片段（动态开点线段树）**
```cpp
// 动态开点线段树更新与查询（Running_a_way 题解核心）
void update(int &x, ll l, ll r, ll id, ll v) {
    if (!x) x = ++E; // 动态创建节点
    if (l == r) {
        T[x].sum1 += v;
        T[x].sum2 = id * T[x].sum1;
        return;
    }
    ll m = (l + r) >> 1;
    if (id <= m) update(T[x].ls, l, m, id, v);
    else update(T[x].rs, m+1, r, id, v);
    // 合并子节点信息
    T[x].sum1 = T[ls(x)].sum1 + T[rs(x)].sum1;
    T[x].sum2 = T[ls(x)].sum2 + T[rs(x)].sum2;
}

ll find(int x, ll l, ll r, ll k) {
    if (l == r) return l; // 找到中位数位置
    ll m = (l + r) >> 1;
    if (T[ls(x)].sum1 >= k) return find(ls(x), l, m, k);
    return find(rs(x), m+1, r, k - T[ls(x)].sum1);
}
```

---

### **个人心得摘录**
- **Jsxts_**：离线离散化大幅简化代码，但需注意离散化后的坐标映射。  
- **AFewSuns**：线段树二分时需处理空节点，否则可能定位到无效位置。  
- **Running_a_way**：动态开点线段树空间消耗需谨慎，但无需离散化的优势明显。

---
处理用时：78.96秒
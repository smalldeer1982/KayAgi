# 题目信息

# [NOI Online #2 提高组] 子序列问题

## 题目背景

2s 512M

## 题目描述

给定一个长度为 $n$ 的正整数序列 $A_1$, $A_2$, $\cdots$, $A_n$。定义一个函数 $f(l,r)$ 表示：序列中下标在 $[l,r]$ 范围内的子区间中，不同的整数个数。换句话说，$f(l,r)$ 就是集合 $\{A_l,A_{l+1},\cdots,A_r\}$ 的大小，这里的集合是不可重集，即集合中的元素互不相等。

现在，请你求出 $\sum_{l=1}^n\sum_{r=l}^n (f(l,r))^2$。由于答案可能很大，请输出答案对 $10^9 +7$ 取模的结果。

## 说明/提示

对于 $10\%$ 的数据，满足 $1 \leq n \leq 10$；

对于 $30\%$ 的数据，满足 $1 \leq n \leq 100$；

对于 $50\%$ 的数据，满足 $1\leq n \leq 10^3$；

对于 $70\%$ 的数据，满足 $1 \leq n \leq 10^5$；

对于 $100\%$ 的数据，满足 $1\leq n\leq 10^6$，集合中每个数的范围是 $[1,10^9]$。

## 样例 #1

### 输入

```
4
2 1 3 2```

### 输出

```
43```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
6```

# AI分析结果



---

## 唯一算法分类
**线段树/树状数组**

---

## 综合分析与结论

### 核心算法流程
1. **预处理 last 数组**：记录每个元素上一次出现的位置
2. **维护区间平方和**：通过线段树或树状数组动态维护区间 [last[i]+1, i] 的平方和变化
3. **增量式计算贡献**：每次右端点右移时，计算新增区间的平方和增量，利用公式 `(x+1)^2 - x^2 = 2x + 1` 优化计算

### 可视化设计思路
1. **动画流程**：
   - 用像素方块表示数组元素，颜色区分不同数值
   - 右端点 r 移动时，高亮区间 [last[r]+1, r]
   - 线段树节点动态显示区间和与平方和的变化
2. **复古风格实现**：
   - 8位音效：区间加时播放 "beep" 音，平方和更新时播放 "ping" 音
   - Canvas 绘制树状数组的二进制结构，闪烁更新的节点
3. **AI 演示模式**：
   - 自动步进展示 last 数组更新过程
   - 用箭头动态指示当前处理的右端点

---

## 题解清单（评分 ≥4星）

### 1. OMG_wc（⭐⭐⭐⭐⭐）
- **亮点**：双树状数组实现区间加与区间和查询，代码简洁高效
- **核心代码**：
```cpp
LL sum(int x) { // 区间和查询
    LL res = 0;
    for (int i = x; i > 0; i -= i & -i) 
        res += c1[i] * (x + 1) - c2[i];
    return res;
}
void add(int x, int d, int n) { // 区间加
    for (int i = x; i <= n; i += i & -i) 
        c1[i] += d, c2[i] += (LL)d * x;
}
```

### 2. tzc_wk（⭐⭐⭐⭐）
- **亮点**：倒序枚举左端点，维护后缀平方和
- **关键步骤**：
```cpp
for(int i = n; i >= 1; --i) {
    modify(1,1,n,i,lst[a[i]]-1,1); // 后缀区间加1
    ans = (ans + query(1,1,n,i,n)) % mod;
    lst[a[i]] = i;
}
```

### 3. BFqwq（⭐⭐⭐⭐）
- **亮点**：线段树维护平方和的完整实现
- **核心公式**：
```cpp
t[o].sum2 += 2ll * t[o].sum * v + 1ll * v * v * (r - l + 1);
t[o].sum += 1ll * v * (r - l + 1);
```

---

## 最优思路提炼

### 关键数据结构
- **双树状数组**：分别维护 ∑x 和 ∑i*x，实现 O(1) 复杂度的区间和计算
- **线段树延迟标记**：通过 `sum` 和 `sum2` 双变量维护平方和

### 数学优化
- **平方差公式**：利用 `(x+Δ)^2 = x^2 + 2xΔ + Δ^2` 分解增量
- **离散化优化**：将数值映射到稠密区间降低空间复杂度

### 思维角度
- **贡献拆分**：将整体平方和拆分为每个右端点的增量贡献
- **逆序处理**：通过倒序枚举左端点简化维护逻辑

---

## 同类题目推荐
1. **P1972 [SDOI2009]HH的项链**（区间不同数个数）
2. **P4113 [HEOI2012]采花**（区间出现次数≥2的统计）
3. **P5490 扫描线**（区间覆盖面积计算）

---

## 可视化代码片段（Canvas + Web Audio）

```javascript
// 树状数组更新动画
function updateBIT(index) {
    ctx.fillStyle = '#FF5555'; // 高亮色
    while (index <= n) {
        drawBITNode(index); // 绘制节点
        index += index & -index;
        playSound('beep', 800 + index*50); // 8位音效
    }
}

// 线段树区间加动画
function segUpdate(l, r) {
    let queue = [[1, 1, n]];
    while (queue.length) {
        let [v, cl, cr] = queue.pop();
        if (cl >= l && cr <= r) {
            highlightNode(v); // 高亮区间节点
            applyWaveEffect(cl, cr); // 波纹动画
        }
        // ... 递归处理子节点
    }
}
```

---

## 复古风格设计
1. **调色板**：NES 经典的 56 色调色板
2. **音效生成**：
```javascript
function genBeep(freq) {
    let osc = audioCtx.createOscillator();
    osc.type = 'square';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    // ... 8位风格包络
}
```
3. **像素动画**：使用 Bresenham 算法绘制线段树结构，节点间距 8 像素

---

通过上述分析与实现，可构建交互式的算法学习工具，帮助直观理解树状数组/线段树在此类问题中的应用。

---
处理用时：76.81秒
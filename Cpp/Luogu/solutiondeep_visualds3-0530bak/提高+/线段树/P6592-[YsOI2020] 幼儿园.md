# 题目信息

# [YsOI2020] 幼儿园

## 题目描述

Ysuperman 热爱在 TA 的幼儿园里散步，为了更方便散步， TA 把幼儿园抽象成 $n$ 个点，$m$ 条边的**有向图**。 散步得多了， TA 就给了每一条边**无与伦比**的亲密程度：$1,2,\cdots,m$，越大代表越亲密。 TA 也给了每一个点无与伦比的编号：$1,2,\cdots,n$，其中 $1$ 代表着幼儿园大门，但是每个**点是没有亲密程度的**。

接下来 $k$ 天，Ysuperman 每天会有一次散步计划。具体而言， TA 希望从 $x_i$ 号点出发，只经过**亲密程度属于区间 $[l_i,r_i]$ 的边**，走到幼儿园大门 $1$ 号点，期间经过的边的亲密程度必须**单调递减**，不然会因为 TA 有强迫症而不能回家。


Ysuperman 看着自己刚刚画的草稿脑子一团浆糊， TA 发现 TA 始终没有办法规划出这么多合理路线，现在 TA 想请你帮 TA 。具体而言，对于每一天的计划，如果可行，则输出 `1`，反之输出 `0`。

当然啦，有的时候 Ysuperman 很着急，需要你立马回复，有的时候 TA 可以等等你，先把所有问题问完再等你回复。

## 说明/提示

### 样例说明

#### 样例说明 $1$

![](https://cdn.luogu.com.cn/upload/image_hosting/wxji6w6f.png)

对于第 $2$ 条计划，Ysuperman 已经站在门口，所以计划可行。

对于第 $3$ 条计划，Ysuperman 只能通过路径 $5 \overset{6}{\rightarrow}3 \overset{5}{\rightarrow} 1$。（箭头上方数字表示的是边的亲密程度）。

其他计划都是不可行的。

#### 样例说明 $3$

样例三为加密后的样例二。

----

### 数据范围

**本题采用捆绑测试。**

| $\mathrm{subtask}$ |     $n$     |       $m$        |        $k$        |  特殊性质   | 分数  |
| :----------------: | :---------: | :--------------: | :---------------: | :---------: | :---: |
|        $1 $        |   $\le17$   |     $\le17$      | $\le 2\cdot 10^5$ |      /      | $ 5$  |
|        $2$         |  $\le500$   |     $\le500$     |     $\le500 $     |      /      | $17$  |
|        $3 $        | $\le 3000$  |   $\le 3000 $    |    $\le 3000 $    |      /      | $18 $ |
|       $ 4 $        |  $\le10^5$  | $\le2\cdot10^5$  |  $\le2\cdot10^5$  |   $v_i=1$   | $13$  |
|        $5 $        | $\le 10^5$  | $\le 2\cdot10^5$ |    $\le 10^5$     | $l_i=1,w=0$ | $ 7 $ |
|        $6$         | $\le10^5 $  | $\le2\cdot10^5$  |    $\le 10^5$     |   $w=0 $    | $13 $ |
|        $7$         | $ \le 10^5$ | $\le 2\cdot10^5$ | $\le 2\cdot10^5$  |      /      | $27$  |

对于 $100\%$ 的数据，满足 $1 \le n \le 10^5 ,1 \le m \le 2\cdot10^5 ,0 \le k \le 2\cdot10^5$。

$w\in\{0,1\},1 \le u_i,v_i \le n$。

$x_i,l_i,r_i$ 在解密后保证 $1\le x \le n ,1 \le l_i,r_i \le m $。

### 提示

**不保证不出现重边自环，不保证图联通**。

## 样例 #1

### 输入

```
5 7 5 0
3 2
1 2
4 3
5 4
3 1
5 3
5 1
3 1 4
1 2 2
5 5 6
4 5 7
2 1 7
```

### 输出

```
0
1
1
0
0
```

## 样例 #2

### 输入

```
5 12 10 0
4 2
4 2
5 3
3 3
1 5
1 4
4 4
2 4
5 3
1 5
2 2
4 1
4 3 5
4 2 3
1 4 5
3 1 8
3 1 4
3 5 5
2 1 12
4 10 12
2 5 5
1 1 3
```

### 输出

```
0
0
1
0
0
0
0
1
0
1
```

## 样例 #3

### 输入

```
5 12 10 1
4 2
4 2
5 3
3 3
1 5
1 4
4 4
2 4
5 3
1 5
2 2
4 1
4 3 5
4 2 3
1 4 5
2 0 9
2 0 5
2 4 4
3 0 13
5 11 13
0 7 7
3 3 1```

### 输出

```
0
0
1
0
0
0
0
1
0
1
```

# AI分析结果



## 算法分类
图论、贪心、线段树/主席树

---

## 题解思路与解决难点

### 核心思路
1. **反图转换**：将原问题转换为反图中的递增路径问题。原问题要求边权递减，反图后变为边权递增，路径方向反转。
2. **动态维护可达性**：按边编号从小到大处理，维护每个点 `u` 的最小边最大值 `f[u]`，表示从 `1` 到 `u` 的路径中，最小边的最大可能值。
3. **数据结构优化**：使用线段树或主席树预处理每个点的有效路径区间，快速回答二维偏序查询。

### 难点分析
1. **路径的有效性**：需确保路径的边权在 `[l_i, r_i]` 内且单调变化。
2. **高效预处理**：直接暴力处理无法应对大规模数据，需利用贪心策略逐步扩展可达性。
3. **在线查询**：强制在线要求数据结构能快速响应历史状态的查询，主席树或线段树维护历史版本是关键。

### 关键结论
- 通过维护每个点的最小边最大值 `f[u]`，结合边处理顺序，可快速判断是否存在合法路径。
- 有效路径的最小区间数为 `O(m)`，保证预处理的高效性。

---

## 题解评分 (≥4星)

### 1. Lskkkno1的题解（5星）
- **亮点**：利用反图转换和线段树维护二维偏序，时间复杂度优，思路清晰。
- **核心代码**：
  ```cpp
  void modify(int &u, int l, int r) {
      if(!u) u = ++vcnt, a[u].val = N;
      if(l == r) return a[u].val = min(a[u].val, cv), void();
      int mid = (l + r) >> 1;
      if(ll <= mid) modify(a[u].lch, l, mid);
      else modify(a[u].rch, mid + 1, r);
      a[u].val = min(a[a[u].lch].val, a[a[u].rch].val);
  }
  ```
- **个人心得**：强调反图的转换和贪心策略的有效性。

### 2. Imakf的题解（4星）
- **亮点**：主席树维护历史版本，代码简洁易懂，适合离线处理。
- **核心代码**：
  ```cpp
  for(int i = 1; i <= m; ++i) {
      f[u[i]] = max(f[u[i]], min(f[v[i]], i));
      vec[0][u[i]].push_back(i);
      vec[1][u[i]].push_back(f[u[i]]);
  }
  ```
- **个人心得**：通过维护 `f[u]` 的历史版本，快速响应查询。

### 3. Otomachi_Una_的题解（4星）
- **亮点**：主席树实现简洁，适合在线查询。
- **核心代码**：
  ```cpp
  for(int i = 1; i <= m; i++){
      f[u[i]] = max(f[u[i]], min(f[v[i]], i));
      sugtree::change(rt[i], rt[i-1], u[i]);
  }
  ```

---

## 最优思路提炼
1. **反图转换**：将原问题转换为从 `1` 出发的递增路径问题，简化路径处理。
2. **贪心维护 `f[u]`**：按边编号从小到大处理，动态更新每个点的最小边最大值。
3. **数据结构加速**：线段树维护每个点的有效区间，或主席树维护历史版本，实现快速查询。

---

## 类似题目
1. [P3916 图的遍历](https://www.luogu.com.cn/problem/P3916)：反向建图处理可达性。
2. [P3388 割点](https://www.luogu.com.cn/problem/P3388)：动态维护图的连通性。
3. [P2146 软件包管理器](https://www.luogu.com.cn/problem/P2146)：线段树维护树结构的动态变化。

---

## 可视化与算法演示

### 核心算法流程动画设计
- **动画方案**：展示反图中边的递增处理过程，动态更新 `f[u]` 的值，并用颜色标记当前处理的边和受影响的点。
- **高亮逻辑**：
  - 当前处理的边 `i` 标记为红色。
  - 受影响的点 `u` 标记为绿色，并显示更新后的 `f[u]`。
- **步进控制**：允许暂停/继续，调整处理速度，观察 `f[u]` 的更新和线段树的插入操作。

### 复古像素风格设计
- **颜色方案**：8-bit 调色板，边处理为蓝色像素块，路径显示为黄色路径。
- **音效设计**：
  - **边处理**：短促“滴”声。
  - **路径生成**：上扬音效。
  - **查询成功/失败**：不同音调提示。
- **Canvas 绘制**：网格化显示节点和边，动态绘制路径区间。

---

## 核心代码片段（Lskkkno1题解）
```cpp
// 线段树动态维护每个点的有效区间
void modify(int &u, int l, int r) {
    if(!u) u = ++vcnt, a[u].val = N;
    if(l == r) return a[u].val = min(a[u].val, cv), void();
    int mid = (l + r) >> 1;
    if(ll <= mid) modify(a[u].lch, l, mid);
    else modify(a[u].rch, mid + 1, r);
    a[u].val = min(a[a[u].lch].val, a[a[u].rch].val);
}

// 查询时判断是否存在有效区间
int query(int u, int l, int r) {
    if(!u || (ll <= l && r <= rr)) return a[u].val;
    int mid = (l + r) >> 1;
    if(rr <= mid) return query(a[u].lch, l, mid);
    else if(mid < ll) return query(a[u].rch, mid + 1, r);
    else return min(query(a[u].lch, l, mid), query(a[u].rch, mid + 1, r));
}
```

---

## 个人心得摘录
- **Lskkkno1**：强调反图的转换是解题关键，预处理线段树的思路需要深入理解贪心策略。
- **Imakf**：通过维护 `f[u]` 的历史版本，代码简洁但需注意主席树的空间优化。

---

## 总结
通过反图转换和动态维护每个点的可达性信息，结合高效数据结构，可在线性时间内预处理并快速响应查询。Lskkkno1的线段树方法在时间和空间上均优，适合大规模数据。

---
处理用时：322.86秒
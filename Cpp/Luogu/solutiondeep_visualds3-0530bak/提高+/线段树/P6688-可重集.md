# 题目信息

# 可重集

## 题目描述

给出一个长度为 $n$ 的非负整数序列 $a_1,a_2,a_3,\ldots, a_n$，给出 $q$ 次操作，每次先给出一个参数 $op$：

- $op=0$，接下来给出 $2$ 个参数 $x,y$，把 $a_x$ 修改为 $y$。

- $op=1$，接下来给出 $4$ 个参数 $ l_1,r_1,l_2,r_2$（保证 $r_1-l_1=r_2-l_2$），你需要判断区间 $[l_1,r_1]$ 与区间 $[l_2,r_2]$ 是否本质相同，如果本质相同输出 `YES`，否则输出 `NO`。

本质相同的定义：令区间长度为 $\text{len}$ ，序列 $p_{1}\dots p_{\text{len}}$ 为 $a_{l_1}\dots a_{r_1}$ 升序排序后的结果，序列 $q_{1}\dots q_\text{len}$ 为 $a_{l_2}\dots a_{r_2}$ 升序排序后的结果，存在一个整数 $k$ 使得满足 $\forall i,p_i+k=q_i$。

## 说明/提示



- Subtask1 （$25$ pts）：$1\leq n,q \leq 1000$。

- Subtask2 （$25$ pts）：$1\leq n,q \leq 10^5$，$0\leq a_i,y\leq 100$。

- Subtask3 （$25$ pts）：$1\leq n,q \leq 10^5$。

- Subtask4 （$25$ pts）：无特殊限制。

你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。

对于所有数据满足：$1\leq n,q \leq 10^6$，$1\leq x \leq n$，$0\leq a_i,y \leq  10^6$ 。且对于所有 $l,r$ 有 $1\leq l\leq r\leq n$。



## 样例 #1

### 输入

```
12 6
1 1 4 5 1 4 2 2 5 2 3 3
1 1 3 7 9
1 2 3 5 6
1 1 3 2 4
0 7 1
1 1 4 2 5
1 5 7 8 10```

### 输出

```
YES
YES
NO
YES
YES```

# AI分析结果



**唯一算法分类**：哈希 + 线段树

---

### **题解思路与核心难点**

#### **核心思路**
题目要求判断两个区间排序后是否满足元素平移关系。核心在于设计**可快速计算且抗碰撞的特征函数**，并高效支持区间查询与单点修改：

1. **哈希构造**：将每个数映射为哈希值（如指数哈希 `g^a_i` 或多项式哈希），维护区间哈希和与最小值。平移后的哈希值可通过 `原哈希 * g^k` 快速计算。
2. **线段树优化**：利用线段树维护区间最小值、哈希和，单次操作时间复杂度为 `O(log n)`，支持高频率查询与修改。

#### **解决难点**
- **哈希碰撞**：通过大质数模数（如 `998244353`）与合理基数的选择降低碰撞概率。
- **平移计算**：通过指数性质或三角函数公式（如 `sin(a+k)` 的和差角展开）快速转换哈希值。
- **高效维护**：线段树或树状数组实现区间聚合操作，避免暴力排序。

---

### **题解评分（≥4星）**

1. **skydogli（5星）**  
   - **亮点**：提出指数哈希与线段树结合，通过 `g^a_i` 的哈希设计，实现 `O(1)` 平移计算。
   - **代码**：树状数组维护和与最小值，常数小，适合大规模数据。
   ```cpp
   // 示例代码片段（树状数组维护哈希和）
   void update(int x, int y) {
       int delta = (pow(g, y) - pow(g, a[x])) % mod;
       add(x, delta); // 树状数组单点更新
       a[x] = y;
   }
   ```

2. **Piwry（4星）**  
   - **亮点**：多项式哈希维护元素出现次数，区间哈希和与最小值结合，判断平移关系。
   - **优化**：双哈希降低碰撞概率，线段树实现清晰。
   ```cpp
   // 线段树节点合并
   node merge(node a, node b) {
       return {min(a.mn, b.mn), (a.sum + b.sum) % mod};
   }
   ```

3. **a___（4星）**  
   - **亮点**：提出基于质数分布的哈希（`pr[x]` 为第 `x` 个质数），直接统计元素出现次数。
   - **创新**：通过质数乘积哈希避免元素顺序影响，适合无序集合判断。

---

### **最优思路提炼**

- **哈希选择**：采用 `g^a_i` 的指数哈希，支持快速平移计算（哈希值乘 `g^k`）。
- **数据结构**：线段树维护区间最小值与哈希和，单点修改与区间查询均为 `O(log n)`。
- **防碰撞技巧**：使用双哈希（如指数哈希 + 质数哈希）或大模数（`1e18+3`）减少冲突。

---

### **类似题目推荐**

1. **P3369 【模板】普通平衡树**（维护有序集合的哈希特征）
2. **P3834 可持久化线段树**（区间元素统计的哈希化）
3. **P5356 [Ynoi2017] 由乃打扑克**（区间排序与哈希结合）

---

### **可视化设计**

**动画方案**：  
- **像素化线段树**：在 Canvas 中以网格展示线段树节点，每个节点显示哈希和与最小值。
- **操作高亮**：修改时高亮路径节点（红色），查询时高亮合并区间（绿色）。
- **音效反馈**：节点更新时播放“滴”声，成功匹配时播放8-bit胜利音效。

**交互功能**：  
- **步进控制**：按钮控制单步执行修改/查询，观察哈希值如何逐层更新。
- **自动演示**：AI模式自动生成随机操作，展示算法动态过程。

---

### **代码片段（核心逻辑）**

```cpp
// 线段树维护指数哈希和最小值
struct Node {
    int mn;
    ull hash;
};

Node merge(Node a, Node b) {
    return {min(a.mn, b.mn), (a.hash + b.hash) % mod};
}

void update(int u, int l, int r, int pos, int val) {
    if (l == r) {
        tree[u] = {val, pow_g[val]};
        return;
    }
    int mid = (l + r) >> 1;
    if (pos <= mid) update(u<<1, l, mid, pos, val);
    else update(u<<1|1, mid+1, r, pos, val);
    tree[u] = merge(tree[u<<1], tree[u<<1|1]);
}

Node query(int u, int l, int r, int L, int R) {
    if (L <= l && r <= R) return tree[u];
    // ... 递归查询左右子树
}
```

---

**总结**：通过哈希与线段树的结合，高效解决区间平移判断问题。关键点在于哈希设计和数据结构优化，确保算法在大数据量下的高效性与正确性。

---
处理用时：57.60秒
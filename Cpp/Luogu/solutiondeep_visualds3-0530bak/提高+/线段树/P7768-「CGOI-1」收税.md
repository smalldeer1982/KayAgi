# 题目信息

# 「CGOI-1」收税

## 题目背景

~~签到题~~

由于举办选丑大赛消耗了太多钱财，ac 决定派出 Push_Y 去收税。

## 题目描述

丑国由 $n$ 座城市组成，编号 $1$ 的为首都。这 $n$ 座城市由 $n-1$ 条长度为 $1$ 的双向道路连接。从编号为 $x$ 的城市出发，往**远离**首都的方向（即往儿子节点走），距离不超过 $h$ 的就是这座城市要收税的范围。

第 $i$ 座城市将要上缴 $a_i$ **元**的所得税。但由于收税官 Push_Y 很喜欢异或，因此每座城市最终上缴的所得税将是在其收税范围内每座城市**应缴税额**的异或和。

Push_Y 将向你提出 $m$ 个询问，他将问你城市 $x$ 在收税距离为 $h$ 时将收到多少**千元**的所得税。

**简化版题意：**

给定一棵 $n$ 个点的树，根节点为 $1$ 号点，第 $i$ 个点的点权为 $a_i$，$dep_u$ 表示 $u$ 点的深度，根节点的深度为 $1$，$q$ 次询问，每次给定两个整数 $x,h$，表示询问 $\bigoplus_{u\in son(x)\land dep_u-dep_x\le h}a_i$ 除以 $1000$ 后的值。

其中 $\bigoplus_{i=1}^ni$ 表示 $1\operatorname{xor} 2\operatorname{xor}\cdots\operatorname{xor} n$。

此处 $\land$ 是“且”，$\operatorname{xor}$ 是异或。

## 说明/提示

对于 $30\%$ 的数据，$1\le n,m\le 10^3$。

对于 $70\%$ 的数据，$1\le n,m\le5 \times 10^4$。其中有 $20\%$ 的数据是链。

对于 $100\%$ 的数据，$1\le n,m\le 10^6$，$1 \le a_i \le 10^9$，$1\le x \le n$，$0 \le h \le n$。

## 样例 #1

### 输入

```
6 3
604 545 402 378 25 13
1 2 2 3 3
1 2
3 0
2 4```

### 输出

```
0.149
0.402
0.733```

## 样例 #2

### 输入

```
6 3
6 5 4 3 2 1
1 2 2 3 3
1 2
3 0
2 4```

### 输出

```
0.004
0.004
0.001```

# AI分析结果



# 算法分类  
**树的可持久化结构**  

---

## 题解思路与核心难点  
### 核心思路  
题目需快速查询子树中特定深度的异或和。各题解主要围绕以下两种思路：  
1. **DFS序+主席树**：将子树转化为线性区间，用主席树按深度维护异或值前缀，通过版本差分快速查询。  
2. **动态深度维护**：离线处理查询，在DFS回溯时用树状数组/桶实时记录各深度异或值，通过前后差分得到结果。  

### 解决难点  
- **子树到区间的映射**：通过DFS序将子树转换为连续区间 `[dfn_x, ed_x]`。  
- **高效深度过滤**：主席树按深度分层存储异或值，或离线桶维护当前遍历路径的深度异或和。  
- **异或前缀性质**：利用异或的自反性（`a^a=0`）实现快速差分，避免重复计算。  

---

## 题解评分 (≥4星)  
1. **lenlen（4.5星）**  
   - 思路：主席树 + DFS序的经典应用，代码结构清晰。  
   - 亮点：利用异或前缀差简化查询，预处理 `re` 数组处理原编号与DFS序的映射。  
   - 代码：可读性较高，但需注意主席树空间消耗。  

2. **☯☯枫☯☯（4星）**  
   - 思路：桶替代树状数组，线性时间完成离线查询。  
   - 亮点：通过两次异或消除非子树贡献，避免复杂数据结构。  
   - 代码：简洁高效，但需理解差分逻辑。  

3. **LEE114514（4星）**  
   - 思路：树状数组离线处理，回溯时记录异或差。  
   - 亮点：常数小，链表存储优化查询挂载。  
   - 代码：快速读入优化，但需注意树状数组范围。  

---

## 最优思路提炼  
**桶离线差分法**（枫题解中的线性方法）：  
1. **DFS预处理**：计算每个节点的子树异或和 `s[x]`。  
2. **动态维护桶**：在DFS回溯时，将 `s[x]` 插入对应深度的桶中。  
3. **查询差分**：在进入子树前记录当前深度的异或和，回溯后再次异或以消除非子树贡献。  

**关键代码片段**（枫的线性方法）：  
```cpp  
void solve(int u,int d) {  
    for(auto q:ask[u]) ans[q.id] ^= sum[d + q.h]; // 记录进入前的值  
    sum[d] ^= s[u]; // 插入当前节点贡献  
    for(int v:children) solve(v, d+1);  
    for(auto q:ask[u]) ans[q.id] ^= sum[d + q.h]; // 异或消除外部贡献  
}  
```  

---

## 同类型题与套路  
- **子树区间化**：DFS序将子树映射为区间，适用于统计子树和、最值等问题。  
- **异或前缀技巧**：利用异或的自反性实现快速差分（如 `a ^ b ^ b = a`）。  
- **离线深度过滤**：结合桶或树状数组，在DFS过程中动态维护深度相关数据。  

### 推荐题目  
1. **P1972 [SDOI2009] HH的项链**（离线树状数组）  
2. **P3384 【模板】树链剖分**（子树区间操作）  
3. **P4211 [LNOI2014] LCA**（深度相关离线查询）  

---

## 可视化设计  
### 动画方案  
1. **DFS遍历演示**：  
   - **颜色标记**：当前遍历节点显示为红色，已处理子树为绿色。  
   - **桶更新**：当节点回溯时，对应深度的桶颜色闪烁，显示异或值变化。  

2. **查询差分高亮**：  
   - **进入前记录**：显示虚线框标记查询时的桶状态。  
   - **回溯后对比**：用不同颜色区分新旧异或值，动态展示异或抵消过程。  

### 复古像素风格  
- **8位调色板**：使用红（当前节点）、绿（已处理）、蓝（桶更新）三色。  
- **音效设计**：  
  - **节点插入**：短促“滴”声。  
  - **查询完成**：8-bit胜利音效。  
- **Canvas绘制**：网格布局树结构，桶以垂直条形图动态更新。  

---

## 个人心得  
- **异或性质**：差分时需注意异或操作的顺序和自反性，避免逻辑错误。  
- **常数优化**：快读和链式存储对大数据量至关重要（如LEE114514题解中的链表挂载）。  
- **空间权衡**：主席树适合在线查询，桶离线法更省空间但需处理所有查询。  

--- 

通过上述分析，可快速掌握子树深度过滤问题的核心解决模式，并灵活选择在线或离线策略应对不同场景。

---
处理用时：78.86秒
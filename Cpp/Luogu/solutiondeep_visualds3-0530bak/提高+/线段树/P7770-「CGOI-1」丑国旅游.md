# 题目信息

# 「CGOI-1」丑国旅游

## 题目背景

丑国风景优美，是远近闻名的旅游胜地（并不）。来丑国旅游的人很多。

## 题目描述

丑国的一角排列着编号从 $1$ 到 $n$ 的 $n$ 个城市。当一个人在第 $i$ 个城市时，能且仅能走到第 $i+1$ 个城市。

第 $i$ 个城市中的人们最讨厌丑值为 $a_i$ 的人。当一个丑值为 $x$ 的人从第 $i$ 个城市走到第 $i+1$ 个城市时，他会获得 $|x-a_i|\times|x-a_{i+1}|$ 的舒适值。

现在有 $m$ 个人要来丑国旅游，第 $i$ 个人的丑值为 $x_i$，要从城市 $l_i$ 走到 $r_i$，问他得到的舒适值之和是多少。

**由于这个数可能很大，你需要求出对 $10^9+7$ 取模后的值**。

由于你不能预知到下一次旅游，我们会强制你在线。

**简化版题意：**

给出 $n$ 及 $n$ 个整数 $a_1,\,a_2,\,\dots,\,a_n$。

$m$ 次在线询问，每次询问给出 $x,\,l,\,r$，求 $\sum\limits_{i=l}^{r-1}|x-a_i|\times|x-a_{i+1}|$。

## 说明/提示

#### 样例说明：

对于第一次询问，从城 $1$ 走到城 $2$，获得舒适值为 $|1-1|\times|1-2|=0$；从城 $2$ 走到城 $3$，获得舒适值为 $|1-2|\times|1-3|=2$，故总舒适值为 $2$。

对于第二次询问，解密后的 $x,\,l,\,r$ 分别是 $4,3,5$。从城 $3$ 走到城 $4$，获得舒适值为 $|4-3|\times|4-4|=0$；从城 $4$ 走到城 $5$，舒适值为 $|4-4|\times|4-5|=0$，总舒适值为 $0$。

---

#### 数据范围：

**本题采用捆绑测试。**

| 编号 | 特殊限制 | 分值 |时限|
| :-: | :-: | :-: |:-:|
| Subtask0 | $n,\,m\le 10^4$ | 20pts |1s|
| Subtask1 | $a_i,\,x\le 10$ | 10pts |2s|
| Subtask2 | $a_i$ 单调递增 | 10pts |2s|
| Subtask3 | 无特殊限制 | 60pts |2s|

对于 $100\%$ 的数据，$1 \le n,\,m \le 3 \times 10^5$，$1 \le a_i,\,x_i \le 10^9$，$1 \le l_i < r_i \le n$。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5
1 1 3
6 1 7```

### 输出

```
2
0```

# AI分析结果



---

## 算法分类
**可持久化线段树**

---

## 题解思路与核心难点

### 核心思路
将每个区间的贡献拆分为二次函数形式，利用可持久化线段树维护不同阈值下的系数和。通过预处理所有可能的阈值，使得查询时能快速定位对应版本，代入计算。

### 关键步骤
1. **表达式拆分**：  
   将每个区间 $i$ 的贡献 $f(x,i)$ 按 $x$ 与 $a_i,a_{i+1}$ 的大小关系拆分为两种二次函数形式：
   - 当 $x$ 在 $a_i,a_{i+1}$ 之外时，表达式为 $x^2 - (a_i+a_{i+1})x + a_i a_{i+1}$  
   - 当 $x$ 在 $a_i,a_{i+1}$ 之间时，表达式为 $-x^2 + (a_i+a_{i+1})x - a_i a_{i+1}$  

2. **可持久化线段树构建**：  
   - 初始版本（所有区间按 $x$ 极小的情况构建）  
   - 对 $a_i$ 排序后，依次处理每个值，将相关区间的系数取反，生成新版本  

3. **查询优化**：  
   - 二分查找确定当前 $x$ 对应的最大阈值版本  
   - 在对应版本的线段树中查询区间系数和，代入 $x$ 计算答案  

### 解决难点
- **动态系数切换**：通过阈值排序和可持久化结构，确保每次修改仅影响相关区间  
- **高效查询**：利用线段树的区间查询特性，将时间复杂度降至 $O(\log n)$  

---

## 题解评分

### 阿丑题解（★★★★☆）  
- **亮点**：详细推导数学表达式，代码注释清晰  
- **优化**：链表结构高效处理相同阈值的位置  

### QinghongLi题解（★★★★☆）  
- **亮点**：代码结构简洁，变量命名规范  
- **优化**：特判首尾区间避免越界  

---

## 最优思路提炼

1. **二次函数拆分**：将绝对值乘积转化为分段二次函数，统一为系数求和问题  
2. **版本化处理**：按阈值排序后，每个阈值对应一个线段树版本，动态调整系数  
3. **可持久化结构**：通过复制路径的方式高效维护多版本数据  

---

## 类似题目推荐

1. **P1972 [SDOI2009] HH的项链**  
   （区间颜色统计，利用可持久化线段树离线处理）  
2. **P3834 【模板】可持久化线段树 2**  
   （主席树经典应用，静态区间第k小）  
3. **P3919 【模板】可持久化数组**  
   （基础可持久化结构练习）  

---

## 代码实现片段（阿丑版核心）

```cpp
// 线段树节点结构
struct node { 
    int son[2]; 
    int b, c, d; // 对应 x², x, 常数项系数
};

// 构建初始版本
void build(int &p, int l, int r) {
    p = ++on;
    if (l == r) {
        tree[p].b = 1; 
        tree[p].c = (-a[l] - a[l+1]) % mod;
        tree[p].d = (ll)a[l] * a[l+1] % mod;
    } else {
        // ... 递归构建左右子树
    }
}

// 修改特定区间系数
void modify(int lp, int &p, int l, int r, int i) {
    if (p == lp || !p) p = ++on, tree[p] = tree[lp]; // 复制节点
    if (l == r) {
        tree[p].b = -tree[p].b; // 系数取反
        tree[p].c = -tree[p].c;
        tree[p].d = -tree[p].d;
    } else {
        // ... 递归修改子树
    }
    push_up(p); // 更新父节点
}
```

---

## 可视化设计

### 动画方案
- **像素风格网格**：用方格表示线段树节点，不同颜色区分版本  
- **高亮修改路径**：当处理新阈值时，沿修改路径闪烁显示  
- **动态公式显示**：右侧面板实时显示当前区间的系数表达式  

### 交互功能
- **步进控制**：可逐版本查看系数变化过程  
- **阈值调节滑块**：动态改变 $x$ 值，实时更新查询结果  
- **音效提示**：版本切换时播放 "blip" 音效，查询完成播放 "ding"  

### 复古元素
- **8-bit 音效**：使用芯片音乐风格音效  
- **像素字体**：所有文字和数字使用复古点阵字体  
- **积分系统**：正确完成 10 次快速查询解锁 "算法大师" 成就  

---

通过上述设计，学习者可直观理解可持久化线段树的版本更新机制，并体验算法动态调整系数的核心思想。

---
处理用时：83.99秒